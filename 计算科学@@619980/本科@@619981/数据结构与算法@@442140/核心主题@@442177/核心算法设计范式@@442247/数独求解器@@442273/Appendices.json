{"hands_on_practices": [{"introduction": "理论是灰色的，而实践之树常青。让我们从构建一个高效的数独求解器开始。这个练习将指导你使用回溯算法，并通过位掩码（bitmasking）这一巧妙的数据结构来高效地跟踪和检查约束，同时应用“最少剩余值”（MRV）启发式策略智能地导航搜索空间，从而打下坚实的编程基础[@problem_id:3277909]。", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用一种基于原则、由数据结构驱动的方法来解决标准数独实例。谜题是一个大小为 $9\\times 9$ 的方形网格，其中填充了来自集合 $\\{1,2,3,4,5,6,7,8,9\\}$ 的数字，并用零表示空白格。一个有效的数独解法为每个空白格分配一个数字，使得三个约束条件成立：(i) 每一行都恰好包含一次来自 $\\{1,\\dots,9\\}$ 的每个数字，(ii) 每一列都恰好包含一次来自 $\\{1,\\dots,9\\}$ 的每个数字，以及 (iii) 每个 $3\\times 3$ 的子网格（宫）都恰好包含一次来自 $\\{1,\\dots,9\\}$ 的每个数字。\n\n请使用以下基本基础和定义作为您算法推导和实现的基础：\n- 集合与集合交集：一个单元格的可用数字集合，是其所在行、列和宫中尚未使用的数字集合的交集。\n- 集合的位级表示：用一个 $9$ 位的掩码来表示数字集合 $\\{1,\\dots,9\\}$，其中位 $k$（从零开始索引）对应于数字 $k+1$。位值为 $1$ 表示可用，为 $0$ 表示不可用。按位与（Bitwise AND）操作模拟集合交集，位清除（bit clearing）模拟从集合中移除元素，位测试（bit testing）用于枚举候选数字。\n- 回溯搜索（深度优先搜索，DFS）：系统地为变量尝试候选值，在遇到矛盾时进行回溯。\n- 确定性决胜规则以确保解的可复现性：总是选择一个剩余值最少（Minimum Remaining Values, MRV）的未填充单元格，即当前可用候选数字最少的单元格；若出现平局，则选择行主序中最早的单元格；在一个单元格内，按升序尝试候选数字。\n\n您的程序必须遵守以下要求：\n- 维护三个用于表示可用性的位掩码数组：一个用于行，一个用于列，一个用于 $3\\times 3$ 的宫。将每个掩码初始化为全1（表示数字 $\\{1,\\dots,9\\}$ 均可用），然后对于输入网格中的每个预填充数字 $d$，在其对应的行、列和宫的掩码中清除表示 $d$ 的位。如果任何预填充数字与其所在行、列或宫中先前遇到的数字冲突（即相应的位已被清除），则该实例无解。\n- 在每个搜索步骤中，通过对相应行、列和宫的可用性掩码进行按位与操作，来计算一个空白单元格的候选掩码。如果此掩码为零，则说明发现了矛盾。\n- 在一个单元格中填入数字 $d$ 时，通过清除表示 $d$ 的位来更新三个可用性掩码；在回溯时，恢复这些掩码。\n- 如果一个实例是可解的，返回任何一个遵守MRV和升序候选值策略的解。如果一个实例是无解的，则报告其无解。\n\n测试套件和答案规范：\n对于每个测试实例，您的程序必须计算一个单独的整数结果，定义如下：\n- 如果实例是可解的，设解的第一行数字为 $[r_1,r_2,\\dots,r_9]$。输出将这 $9$ 个数字按顺序连接得到的整数，即十进制整数 $r_1\\cdot 10^{8} + r_2\\cdot 10^{7} + \\dots + r_9$。\n- 如果实例是无解的，输出整数 $-1$。\n\n使用以下四个测试用例。每个测试用例都是一个 $9\\times 9$ 的矩阵，用零表示空白格。\n\n测试用例 1（一个标准的可解实例）：\n- 第 1 行：$(5,3,0,0,7,0,0,0,0)$\n- 第 2 行：$(6,0,0,1,9,5,0,0,0)$\n- 第 3 行：$(1,9,8,0,0,2,0,6,7)$\n- 第 4 行：$(8,0,0,0,6,0,0,0,3)$\n- 第 5 行：$(4,0,0,8,0,3,0,0,1)$\n- 第 6 行：$(7,0,0,0,2,0,0,0,6)$\n- 第 7 行：$(0,6,0,0,0,0,2,8,0)$\n- 第 8 行：$(0,0,0,4,1,9,0,0,5)$\n- 第 9 行：$(0,0,0,0,8,0,0,7,9)$\n\n测试用例 2（一个已经求解的有效网格）：\n- 第 1 行：$(5,3,4,6,7,8,9,1,2)$\n- 第 2 行：$(6,7,2,1,9,5,3,4,8)$\n- 第 3 行：$(1,9,8,3,4,2,5,6,7)$\n- 第 4 行：$(8,5,9,7,6,1,4,2,3)$\n- 第 5 行：$(4,2,6,8,5,3,7,9,1)$\n- 第 6 行：$(7,1,3,9,2,4,8,5,6)$\n- 第 7 行：$(9,6,1,5,3,7,2,8,4)$\n- 第 8 行：$(2,8,7,4,1,9,6,3,5)$\n- 第 9 行：$(3,4,5,2,8,6,1,7,9)$\n\n测试用例 3（因行冲突而无解；注意第一行中的重复数字）：\n- 第 1 行：$(6,3,4,6,7,8,9,1,2)$\n- 第 2 行：$(6,7,2,1,9,5,3,4,8)$\n- 第 3 行：$(1,9,8,3,4,2,5,6,7)$\n- 第 4 行：$(8,5,9,7,6,1,4,2,3)$\n- 第 5 行：$(4,2,6,8,5,3,7,9,1)$\n- 第 6 行：$(7,1,3,9,2,4,8,5,6)$\n- 第 7 行：$(9,6,1,5,3,7,2,8,4)$\n- 第 8 行：$(2,8,7,4,1,9,6,3,5)$\n- 第 9 行：$(3,4,5,2,8,6,1,7,9)$\n\n测试用例 4（另一个已求解的有效网格）：\n- 第 1 行：$(1,2,3,4,5,6,7,8,9)$\n- 第 2 行：$(4,5,6,7,8,9,1,2,3)$\n- 第 3 行：$(7,8,9,1,2,3,4,5,6)$\n- 第 4 行：$(2,1,4,3,6,5,8,9,7)$\n- 第 5 行：$(3,6,5,8,9,7,2,1,4)$\n- 第 6 行：$(8,9,7,2,1,4,3,6,5)$\n- 第 7 行：$(5,3,1,6,4,2,9,7,8)$\n- 第 8 行：$(6,4,2,9,7,8,5,3,1)$\n- 第 9 行：$(9,7,8,5,3,1,6,4,2)$\n\n最终输出格式：\n您的程序应生成单行输出，其中按顺序包含测试用例1到4的结果，形式为方括号内以逗号分隔的列表。例如，该行应类似于 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，不含空格。\n\n不应从标准输入读取任何输入。执行所需的所有数据必须直接嵌入到程序中。", "solution": "该问题要求基于一组指定的原则设计并实现一个数独求解器：回溯搜索、用于表示数字可用性的位掩码表示法，以及用于变量排序的剩余最少值（MRV）启发式方法。该解必须是确定性的，并且能处理可解和无解的谜题实例。\n\n该问题定义严谨且在算法上是自包含的。它在科学上基于已建立的约束满足问题（CSPs）理论，而数独是该理论的一个典型例子。所要求的方法——结合深度优先搜索、用于提高效率的位级数据结构以及启发式引导搜索——是一种标准且有效的方法。该问题是良定义的，提供了确定性的决胜规则，这保证了对于任何给定的有效输入，都有唯一的算法路径，从而得到唯一的解。所有术语都得到了正式定义，测试用例和输出格式也得到了精确说明。因此，该问题是有效的，我们可以着手进行合理的求解。\n\n一个 $9 \\times 9$ 的数独谜题可以被建模为一个约束满足问题（CSP）。变量是网格的 $81$ 个单元格，我们可以用它们的坐标 $(i, j)$ 来表示，其中 $i, j \\in \\{0, 1, \\dots, 8\\}$。每个单元格的定义域是允许的数字集合 $\\{1, 2, \\dots, 9\\}$。约束条件要求每一行、每一列以及九个 $3 \\times 3$ 的宫中的所有单元格都必须包含不同的数字。\n\n指定算法的核心是使用位掩码来表示每一行、每一列和每一个宫的可用数字集合。一个 $9$ 位的整数可以表示集合 $D = \\{1, 2, \\dots, 9\\}$。我们将数字 $d$ 映射到第 $(d-1)$ 位（从零开始索引）。位值为 $1$ 表示该数字可用，而为 $0$ 表示不可用。因此，数字 $d$ 的位掩码是 $1 \\ll (d-1)$。所有数字都可用的初始状态，由所有 $9$ 位都设置为 $1$ 的掩码表示，即 $2^9 - 1 = 511$，二进制表示为 `0b111111111`。对于确定一个单元格的可用候选数字至关重要的集合交集操作，可以通过按位 `AND` 操作高效地计算。\n\n我们将维护三个数组来跟踪数字的可用性：\n- `rows[9]`: 一个数组，其中 `rows[i]` 是第 $i$ 行可用数字的位掩码。\n- `cols[9]`: 一个数组，其中 `cols[j]` 是第 $j$ 列可用数字的位掩码。\n- `boxes[9]`: 一个数组，其中 `boxes[k]` 是第 $k$ 个宫可用数字的位掩码。单元格 $(i, j)$ 对应的宫索引 $k$ 的计算方式为 $k = \\lfloor i/3 \\rfloor \\cdot 3 + \\lfloor j/3 \\rfloor$。\n\n求解过程包括两个主要阶段：初始化和递归搜索。\n\n**1. 初始化阶段**\n求解器使用给定的 $9 \\times 9$ 网格进行初始化。\n- 首先，将 `rows`、`cols` 和 `boxes` 掩码数组初始化为“全部可用”的掩码 $511$。\n- 创建一个包含所有空白单元格（值为 $0$ 的单元格）的列表，并保持行主序。这对于决胜规则至关重要。\n- 然后，算法遍历输入网格。对于每个位于 `grid[i][j]` 且值为非零数字 $d$ 的预填充单元格：\n    a. 计算数字 $d$ 的位掩码 `mask_d = 1  (d-1)`。\n    b. 执行有效性检查。数字 $d$ 必须在其所在的行 $i$、列 $j$ 和对应的宫 $k$ 中是可用的。这当且仅当表示 $d$ 的位在 `rows[i]`、`cols[j]` 和 `boxes[k]` 中都被设置时才成立。如果 `(rows[i]  mask_d) == 0`，或者对列或宫掩码的相同检查失败，则谜题存在初始矛盾，是无解的。\n    c. 如果检查通过，则认为数字 $d$ 已在该行、列和宫中使用。通过清除表示 $d$ 的位来更新相应的掩码：`rows[i] = ~mask_d`、`cols[j] = ~mask_d` 和 `boxes[k] = ~mask_d`。\n\n如果此初始化过程完成而没有发现任何矛盾，算法将进入搜索阶段。否则，它将终止并报告该实例为无解。\n\n**2. 递归回溯搜索**\n通过一个递归函数来执行解的搜索，该函数为空白单元格的可能数字分配实现了一个深度优先搜索（DFS）。\n\n- **基本情况：** 当空白单元格列表为空时，递归成功终止。这表示每个单元格都已被分配一个有效的数字，一个完整的解已经找到。函数返回 `True`。\n\n- **递归步骤：**\n    a. **变量选择（MRV启发式）：** 算法选择接下来要填充哪个空白单元格。根据MRV启发式，我们必须选择可用候选数字数量最少的单元格。为此，我们遍历当前的空白单元格列表。对于每个空白单元格 $(i, j)$：\n        i. 候选数字集合是其所在行、列和宫中可用数字的交集。这通过 `candidates_mask = rows[i]  cols[j]  boxes[k]` 计算，其中 $k = \\lfloor i/3 \\rfloor \\cdot 3 + \\lfloor j/3 \\rfloor$。\n        ii. 候选数字的数量是 `candidates_mask` 中置位（为1的位）的数量，也称为置位数（population count）。\n        iii. 作为一种前向检查，如果任何空白单元格的 `candidates_mask` 为 $0$，意味着在当前状态下该单元格没有有效数字可选。这条路径会导致矛盾，因此函数必须立即通过返回 `False` 来回溯。\n        iv. 算法跟踪具有最少正候选数的单元格。问题规定，平局通过选择在行主序中出现最早的单元格来解决。由于我们的空白列表已经按此顺序排列，我们只需在发现具有严格更少候选数的单元格时更新我们的选择。\n\n    b. **值选择与递归：** 一旦选定了最佳单元格 $(i, j)$，算法会尝试在其中填入一个数字。\n        i. 根据问题的决胜规则，它按升序遍历数字 $d \\in \\{1, \\dots, 9\\}$。\n        ii. 对于每个数字 $d$，它通过测试 `candidates_mask` 中对应的位来检查它是否为有效候选者。\n        iii. 如果 $d$ 是一个有效候选者：\n            - **放置：** 将数字 $d$ 放置在 `grid[i][j]`。通过从 `rows[i]`、`cols[j]` 和 `boxes[k]` 中清除表示 $d$ 的位来更新状态。按位 `XOR`（异或）操作 (`^=`) 非常适合此任务，因为它既能清除位（如果当前已设置），又可以在回溯时再次使用以恢复它。\n            - **递归：** 调用递归函数来解决剩余的空白单元格。\n            - **传播成功：** 如果递归调用返回 `True`，意味着找到了一个解。这个 `True` 值会向上传递到调用栈，搜索终止。\n\n    c. **回溯：** 如果对单元格 $(i, j)$ 的所有候选数字的循环完成而递归调用没有返回 `True`，这意味着从当前状态无法达到任何解。算法必须回溯。\n        i. 撤销赋值：将 `grid[i][j]` 重置为 $0$。\n        ii. 通过再次应用与 `mask_d` 的 `XOR` 操作，将状态掩码恢复到之前的值。\n        iii. 函数返回 `False`，向父调用表明所选路径失败。\n\n如果对递归函数的初始调用返回 `False`，则该谜题无解。\n\n**3. 输出生成**\n求解器完成后，为该实例生成一个单一的整数结果。\n- 如果找到了解，将完成的网格第一行的数字 $[r_1, r_2, \\dots, r_9]$ 连接起来，形成一个十进制整数。\n- 如果谜题被确定为无解（无论是在初始化期间还是通过搜索），结果为 $-1$。\n对所有提供的测试用例运行求解器，并将结果收集并格式化为指定的字符串格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SudokuSolver:\n    \"\"\"\n    Solves a 9x9 Sudoku puzzle using backtracking, bitmasking, and the\n    Minimum Remaining Values (MRV) heuristic.\n    \"\"\"\n\n    def __init__(self, grid):\n        \"\"\"\n        Initializes the solver, sets up data structures, and validates the\n        initial grid configuration.\n        \"\"\"\n        self.grid = np.array(grid, dtype=int)\n        self.initial_grid_is_valid = True\n\n        # Bitmasks for rows, cols, and boxes. 0b111111111 represents {1..9}.\n        self.all_digits_mask = (1  9) - 1\n        self.rows = [self.all_digits_mask] * 9\n        self.cols = [self.all_digits_mask] * 9\n        self.boxes = [self.all_digits_mask] * 9\n        self.blanks = []\n\n        self._initialize_masks()\n\n    def _initialize_masks(self):\n        \"\"\"\n        Populates masks based on pre-filled numbers and identifies blank cells.\n        Checks for initial contradictions in the grid.\n        \"\"\"\n        for r in range(9):\n            for c in range(9):\n                digit = self.grid[r, c]\n                if digit != 0:\n                    if not self._update_masks(r, c, digit, 'place'):\n                        self.initial_grid_is_valid = False\n                        return\n                else:\n                    self.blanks.append((r, c))\n\n    def _update_masks(self, r, c, d, action):\n        \"\"\"\n        Updates the availability masks for a given cell and digit.\n        If 'place', it validates and clears the bit.\n        If 'backtrack_xor', it restores/clears the bit using XOR.\n        \"\"\"\n        box_idx = (r // 3) * 3 + (c // 3)\n        mask_d = 1  (d - 1)\n\n        if action == 'place':\n            # Check for contradiction before placing\n            if not (self.rows[r]  mask_d and self.cols[c]  mask_d and self.boxes[box_idx]  mask_d):\n                return False\n            # Place the digit by clearing its bit\n            self.rows[r] = ~mask_d\n            self.cols[c] = ~mask_d\n            self.boxes[box_idx] = ~mask_d\n        elif action == 'backtrack_xor':\n            # Flip the bit using XOR\n            self.rows[r] ^= mask_d\n            self.cols[c] ^= mask_d\n            self.boxes[box_idx] ^= mask_d\n        \n        return True\n    \n    def solve_puzzle(self):\n        \"\"\"\n        Public method to start the solving process.\n        \"\"\"\n        if not self.initial_grid_is_valid:\n            return -1\n\n        if self._backtrack():\n            top_row = self.grid[0, :]\n            return int(\"\".join(map(str, top_row)))\n        else:\n            return -1\n\n    def _backtrack(self):\n        \"\"\"\n        Recursive backtracking algorithm (DFS).\n        \"\"\"\n        if not self.blanks:\n            return True  # Base case: All cells filled\n\n        # 1. Variable Selection: Find blank cell with MRV\n        min_candidates_count = 10\n        best_cell_info = None  # (index in blanks list, r, c, candidates_mask)\n\n        for i, (r, c) in enumerate(self.blanks):\n            box_idx = (r // 3) * 3 + (c // 3)\n            candidates_mask = self.rows[r]  self.cols[c]  self.boxes[box_idx]\n            count = bin(candidates_mask).count('1')\n\n            if count == 0:\n                return False  # Forward checking: contradiction detected\n\n            if count  min_candidates_count:\n                min_candidates_count = count\n                best_cell_info = (i, r, c, candidates_mask)\n\n        idx_in_blanks, r, c, candidates_mask = best_cell_info\n        \n        # Temporarily remove the chosen cell from the list\n        cell_to_fill = self.blanks.pop(idx_in_blanks)\n\n        # 2. Value Selection: Try candidates in ascending order\n        for d in range(1, 10):\n            mask_d = 1  (d - 1)\n            if candidates_mask  mask_d:\n                # Place digit and update state\n                self.grid[r, c] = d\n                # Using XOR to flip the bit from 1 to 0\n                self._update_masks(r, c, d, 'backtrack_xor') \n\n                if self._backtrack():\n                    return True\n\n                # Backtrack: undo placement and restore state\n                self._update_masks(r, c, d, 'backtrack_xor')\n\n        # If no candidate leads to a solution, restore the chosen cell and backtrack fully\n        self.blanks.insert(idx_in_blanks, cell_to_fill)\n        self.grid[r,c] = 0 # Explicitly clear the cell on the grid\n\n        return False\n\ndef solve():\n    \"\"\"\n    Main function to run the Sudoku solver on the provided test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        np.array([\n            [5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [1, 9, 8, 0, 0, 2, 0, 6, 7],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]\n        ]),\n        # Test case 2\n        np.array([\n            [5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test case 3\n        np.array([\n            [6, 3, 4, 6, 7, 8, 9, 1, 2], # Duplicate 6\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test case 4\n        np.array([\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [4, 5, 6, 7, 8, 9, 1, 2, 3],\n            [7, 8, 9, 1, 2, 3, 4, 5, 6],\n            [2, 1, 4, 3, 6, 5, 8, 9, 7],\n            [3, 6, 5, 8, 9, 7, 2, 1, 4],\n            [8, 9, 7, 2, 1, 4, 3, 6, 5],\n            [5, 3, 1, 6, 4, 2, 9, 7, 8],\n            [6, 4, 2, 9, 7, 8, 5, 3, 1],\n            [9, 7, 8, 5, 3, 1, 6, 4, 2]\n        ])\n    ]\n\n    results = []\n    for grid in test_cases:\n        solver = SudokuSolver(grid)\n        result = solver.solve_puzzle()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3277909"}, {"introduction": "从“解题”到“出题”是一个质的飞跃。一个设计精良的数独谜题必须有且仅有一个唯一解，这个练习将挑战你利用求解器作为工具，来构建一个谜题生成器[@problem_id:3277827]。你将从一个完整的数独终盘开始，通过巧妙地移除数字并反复验证解的唯一性，来亲身体验算法设计与问题分解的魅力。", "problem": "你需要设计并实现一个完整的、可运行的程序，该程序基于约束满足问题（CSP）的正式框架，生成具有唯一解的数独谜题。数独谜题是一个部分填充的 $9\\times 9$ 网格，填充数字为 $\\{1,2,3,4,5,6,7,8,9\\}$，并满足以下约束：每一行必须包含每个数字恰好一次，每一列必须包含每个数字恰好一次，每个 $3\\times 3$ 的子网格也必须包含每个数字恰好一次。如果存在唯一一种将数字完整赋给所有单元格且满足所有约束的方案，则该谜题具有唯一解。目标是生成此类谜题，并从基本原理出发验证其解的唯一性。\n\n使用的基本定义：\n- 一个数独实例是一个有限定义域的约束满足问题（CSP），其中每个单元格是一个变量，其定义域为 $\\{1,2,3,4,5,6,7,8,9\\}$，约束条件在行、列和子网格上强制执行“所有不同”（all-different）的关系。\n- CSP 的一个解是一个赋值映射，它将每个变量映射到其定义域中的一个值，并满足所有约束。\n- 唯一性要求解的数量恰好为一；形式上，解集的基数等于 $1$。\n\n你的程序必须：\n1. 从任意一个有效的已解数独终盘开始，通过应用结构保持变换来构造新的有效已解数独终盘，确保行、列和子网格始终是 $\\{1,2,3,4,5,6,7,8,9\\}$ 的排列这一不变量。\n2. 通过从一个已解终盘中移除提示数（已填充的单元格）来生成数独谜题，同时保持谜题具有唯一解的特性。必须通过使用基于原则的约束传播和回溯法来计算解的数量，从而验证唯一性。当找到超过 $1$ 个解时，解计数器必须提前终止。\n3. 通过使用种子（seed）来实现确定性的伪随机性，以便可复现地生成不同的谜题。\n\n测试套件：\n为以下参数对 $(s,k)$ 实现并运行生成器，其中 $s$ 是伪随机种子， $k$ 是尝试保留的目标提示数：\n- 情况 1：$(s,k) = (17,30)$。\n- 情况 2：$(s,k) = (12345,26)$。\n- 情况 3：$(s,k) = (2024,38)$。\n你的生成器应尝试移除提示数，直到谜题失去唯一性或剩余提示数将低于 $k$ 为止，以先发生者为准。\n\n答案规格：\n对于每个测试用例，计算以下结果：\n- 最终谜题中实际保留的提示数的整数计数。\n- 一个布尔值，指示最终谜题是否通过计数验证为具有唯一解。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来。列表中的每个元素对应一个测试用例（按给定顺序），并且本身是一个双元素列表 $\\big[\\text{clue\\_count},\\text{is\\_unique}\\big]$。例如，格式为 $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$，其中每个 $a_i$ 是一个整数，每个 $b_i$ 是一个布尔值。", "solution": "生成具有唯一解的数独谜题问题，是一个根植于约束满足问题（CSP）理论的、定义明确的算法挑战。一个数独谜题可以被建模为一个包含 $81$ 个变量的 CSP，每个变量对应 $9 \\times 9$ 网格中的一个单元格。每个变量的定义域是数字集合 $\\{1, 2, 3, 4, 5, 6, 7, 8, 9\\}$。约束条件是应用于每行、每列以及九个 $3 \\times 3$ 子网格中变量的“所有不同”（all-different）约束。谜题的一个解是为所有变量赋上值的一个完整且一致的赋值。该问题要求生成的谜题其解是唯一的，即解集的基数恰好为 $1$。\n\n我们的方法是系统性的，并基于这些原则。它包括三个主要阶段：首先，生成一个完整且有效的数独终盘；其次，实现一个能够验证解唯一性的求解器；第三，使用这个求解器从完整终盘中移除提示数，以形成一个符合唯一性和提示数数量约束的最小谜题。\n\n**1. 通过结构保持变换生成已解数独终盘**\n\n我们不从一个空网格开始求解 CSP（这在计算上非常耗时），而是从一个已知的、有效的、已解的数独终盘开始。从这个基础终盘出发，可以通过应用一系列保持数独特性（即每行、每列和每个 $3 \\times 3$ 子网格都是 $\\{1, 2, \\dots, 9\\}$ 的一个排列）的变换，生成大量其他有效的已解终盘。这些变换包括：\n\n- **数字重标**：对整个网格中的数字 $\\{1, \\dots, 9\\}$ 应用一个置换。例如，可以将每个 $1$ 替换为 $5$，每个 $5$ 替换为 $1$ 等。\n- **行和列的置换**：\n    - 行可以在其各自的 $3$ 行带内进行置换（例如，行 $0, 1, 2$ 可以重新排列）。\n    - 列可以在其各自的 $3$ 列栈内进行置换（例如，列 $3, 4, 5$ 可以重新排列）。\n    - 三个行带（行 $0-2$、$3-5$、$6-8$）可以相互置换。\n    - 三个列栈（列 $0-2$、$3-5$、$6-8$）可以相互置换。\n- **网格转置**：网格可以沿其主对角线进行转置，交换行和列的角色。\n\n通过应用一系列基于确定性伪随机数生成器（用特定种子 $s$ 初始化）选择的变换，我们可以以可复现的方式生成各种各样的已解终盘。\n\n**2. 通过带提前终止的回溯法进行唯一性验证**\n\n问题的核心是验证一个谜题是否恰好只有一个解。这是一个 #P-完全问题，但对于 $9 \\times 9$ 的网格，使用高效的回溯算法是可行的。该算法系统地探索可能赋值的搜索空间。\n\n过程如下：\n- 定义一个递归函数，该函数尝试逐个单元格填充网格。\n- 它识别下一个未赋值的变量（单元格）。如果所有单元格都已赋值，则表示已找到一个有效解，函数返回 $1$。\n- 对于选定的未赋值单元格，函数遍历其定义域中所有可能的值（$1$ 到 $9$）。\n- 对于每个值，检查将其放入单元格是否违反任何数独约束（行、列或子网格）。\n- 如果该值有效，则将其暂时赋给该单元格，并递归调用自身来解决谜题的其余部分。递归调用找到的解的数量会累加到一个运行总数中。\n- 递归调用返回后，该单元格被取消赋值（其值重置为 $0$），以允许探索搜索树的其他分支（这就是“回溯”）。\n\n为了验证唯一性，我们采用了一项关键优化。如果解的总数大于 $1$，我们就不关心其具体数量。因此，一旦找到两个不同的解，计数过程就可以终止。求解器的实现将返回 $0$（无解）、$1$（唯一解）或 $2$（代表至少两个解）。这种“提前退出”策略极大地剪枝了搜索空间，使得该过程比一个完整的解计数算法效率高得多。\n\n**3. 通过贪心移除提示数生成谜题**\n\n从第一步生成的完全解出的终盘开始，我们通过移除提示数（非零数字）来生成一个谜题。目标是尽可能多地移除提示数，同时确保谜题保持唯一解，并且最终的提示数数量至少为给定的目标值 $k$。步骤如下：\n\n- 创建一个包含所有 $81$ 个单元格位置的列表，并使用带种子的生成器将其随机打乱（以保证可复现性）。\n- 算法遍历这个打乱后的单元格位置列表。\n- 对于每个单元格，检查当前的提示数是否大于目标值 $k$。如果不是，则过程终止，因为我们不能再移除提示数而不低于目标值。\n- 如果提示数大于 $k$，算法会暂时移除当前单元格的数字（将其值设为 $0$）。\n- 然后，它调用上述的回溯求解器，以最多为 $2$ 的限制来计算修改后网格的解的数量。\n- 如果求解器返回恰好为 $1$，说明谜题仍然是唯一可解的。该移除操作被确认，提示数减一。\n- 如果求解器返回任何其他值（$0$ 或 $2$），则意味着移除该提示数会破坏唯一性属性。通过恢复单元格的原始数字来撤销该移除操作。\n\n这个贪心过程持续进行，直到所有单元格位置都已尝试移除，或者达到了提示数阈值 $k$。最终生成的谜题保证有唯一解，并且至少有 $k$ 个提示数。每个测试用例的最终输出包括生成的谜题中实际保留的提示数，以及其唯一性的布尔确认。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to generate and validate Sudoku puzzles based on test cases.\n    \"\"\"\n\n    # Base solved Sudoku grid. All other solved grids are derived from this.\n    base_grid = np.array([\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ])\n\n    def is_valid_placement(grid, row, col, num):\n        \"\"\"Checks if placing a number in a cell is valid.\"\"\"\n        if num in grid[row, :]:\n            return False\n        if num in grid[:, col]:\n            return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        if num in grid[start_row:start_row + 3, start_col:start_col + 3]:\n            return False\n        return True\n\n    def count_solutions_limited(grid, limit):\n        \"\"\"\n        Recursively counts solutions of a Sudoku grid using backtracking.\n        Terminates early if the count reaches the specified limit.\n        \"\"\"\n        try:\n            row, col = np.argwhere(grid == 0)[0]\n        except IndexError:\n            # No empty cells found, so this is one complete solution.\n            return 1\n\n        count = 0\n        for num in range(1, 10):\n            if is_valid_placement(grid, row, col, num):\n                grid[row, col] = num\n                count += count_solutions_limited(grid, limit - count)\n                if count >= limit:\n                    # Early exit if we've found enough solutions\n                    grid[row, col] = 0 # Backtrack before returning\n                    return count\n        \n        # Backtrack\n        grid[row, col] = 0\n        return count\n\n    def generate_solved_grid(rng, base):\n        \"\"\"\n        Generates a new valid solved Sudoku grid from a base grid using\n        structure-preserving transformations.\n        \"\"\"\n        grid = base.copy()\n\n        # 1. Relabel digits\n        mapping = np.arange(10)\n        mapping[1:] = rng.permutation(np.arange(1, 10))\n        grid = mapping[grid]\n\n        # 2. Transpose (50% chance)\n        if rng.random()  0.5:\n            grid = grid.T\n\n        # 3. Permute row bands and rows within bands\n        band_order = rng.permutation(3)\n        new_grid = np.vstack([grid[band_order[i]*3 : band_order[i]*3+3, :] for i in range(3)])\n        for band in range(3):\n            row_order = rng.permutation(3)\n            rows = new_grid[band*3:band*3+3, :]\n            new_grid[band*3:band*3+3, :] = rows[row_order, :]\n        grid = new_grid\n\n        # 4. Permute column stacks and columns within stacks\n        stack_order = rng.permutation(3)\n        new_grid = np.hstack([grid[:, stack_order[i]*3 : stack_order[i]*3+3] for i in range(3)])\n        for stack in range(3):\n            col_order = rng.permutation(3)\n            cols = new_grid[:, stack*3:stack*3+3]\n            new_grid[:, stack*3:stack*3+3] = cols[:, col_order]\n        grid = new_grid\n        \n        return grid\n\n    def create_puzzle(solved_grid, rng, k):\n        \"\"\"\n        Removes clues from a solved grid to create a puzzle with at least k clues\n        and a unique solution.\n        \"\"\"\n        puzzle = solved_grid.copy()\n        # Get a random order of cells to try removing\n        indices = rng.permutation(np.arange(81))\n        \n        clues = 81\n        for idx in indices:\n            if clues = k:\n                break\n            \n            row, col = divmod(idx, 9)\n            \n            value = puzzle[row, col]\n            puzzle[row, col] = 0\n            \n            # Check for uniqueness. We need exactly 1 solution.\n            # We count up to 2 solutions for efficiency.\n            num_sols = count_solutions_limited(puzzle.copy(), 2)\n            \n            if num_sols != 1:\n                # If not unique, restore the value and try the next cell\n                puzzle[row, col] = value\n            else:\n                # If unique, the removal is successful\n                clues -= 1\n        \n        final_clue_count = np.count_nonzero(puzzle)\n        is_unique = (count_solutions_limited(puzzle.copy(), 2) == 1)\n\n        return final_clue_count, is_unique\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (17, 30),\n        (12345, 26),\n        (2024, 38),\n    ]\n\n    results = []\n    for s, k in test_cases:\n        # Initialize the pseudo-random number generator with the seed\n        rng = np.random.default_rng(s)\n        \n        # 1. Generate a new valid solved grid\n        solved_grid = generate_solved_grid(rng, base_grid)\n        \n        # 2. Create a puzzle by removing clues\n        clue_count, is_unique = create_puzzle(solved_grid, rng, k)\n        \n        results.append([clue_count, is_unique])\n\n    # Format the results into the required string format `[[c1,b1],[c2,b2],...]`\n    formatted_results = []\n    for clue_count, is_unique in results:\n        # Python's `True`/`False` string representation is standard.\n        formatted_results.append(f\"[{clue_count},{str(is_unique)}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3277827"}, {"introduction": "跳出回溯的框架，让我们用一种更抽象、更强大的视角来审视数独问题。这个练习将引导你将数独问题重构为一个经典的“精确覆盖问题”（Exact Cover Problem）[@problem_id:3277848]。你将亲手实现计算机科学大师 Donald Knuth 提出的优雅的 X 算法及其“舞蹈链”（Dancing Links）实现，感受数据结构与算法的精妙结合如何高效解决复杂的组合问题。", "problem": "实现一个完整的、可运行的程序，通过将标准数独实例规约为一个精确覆盖问题，并应用 Donald Knuth 的带有舞蹈链（DLX）的算法 X 来解决该问题。任务是使用以下基础，从零开始设计并实现数据结构和搜索算法。\n\n基本原理：\n- 精确覆盖的定义：给定一个有限全集 $\\mathcal{U}$ 和一个 $\\mathcal{U}$ 的子集族 $\\mathcal{S}$，一个精确覆盖是一个子集 $\\mathcal{C} \\subseteq \\mathcal{S}$，使得 $\\mathcal{U}$ 中的每个元素都恰好包含在 $\\mathcal{C}$ 的一个成员中。\n- 数独约束：一个标准的数独由一个 $9 \\times 9$ 的网格组成。有效的解满足以下不变量：\n  1. 每个单元格包含一个 $\\{1,2,\\dots,9\\}$ 中的数字。\n  2. 每行包含 $\\{1,2,\\dots,9\\}$ 中的每个数字恰好一次。\n  3. 每列包含 $\\{1,2,\\dots,9\\}$ 中的每个数字恰好一次。\n  4. 每个 $3 \\times 3$ 的宫包含 $\\{1,2,\\dots,9\\}$ 中的每个数字恰好一次。\n\n您的程序必须：\n- 将数独构造成一个精确覆盖实例，其中每个候选赋值“行”对应于在单元格 $(r,c)$（其中 $r \\in \\{0,\\dots,8\\}$，$c \\in \\{0,\\dots,8\\}$）中放置数字 $d \\in \\{1,\\dots,9\\}$，而全集则编码了四族约束：单元格占用、行-数字、列-数字和宫-数字。在无约束的情况下，这将产生 $729$ 个候选行和 $324$ 个约束列。\n- 实现舞蹈链（DLX），它是算法 X 的一种链式结构实现，用于在回溯搜索期间高效地对稀疏的精确覆盖矩阵执行覆盖和揭示操作。\n- 尊重给定数字，通过将候选解限制为与提供的非零数字一致的解。使用 $0$ 表示空单元格。\n\n测试套件：\n为以下三个测试用例提供解决方案。每个测试用例是一个 $9 \\times 9$ 的网格，以九行九个整数的形式给出。整数 $0$ 表示一个空单元格。\n- 测试用例 A（具有唯一解的常规可解实例）：\n  - 第 1 行：$(5,\\,3,\\,0,\\,0,\\,7,\\,0,\\,0,\\,0,\\,0)$\n  - 第 2 行：$(6,\\,0,\\,0,\\,1,\\,9,\\,5,\\,0,\\,0,\\,0)$\n  - 第 3 行：$(0,\\,9,\\,8,\\,0,\\,0,\\,0,\\,0,\\,6,\\,0)$\n  - 第 4 行：$(8,\\,0,\\,0,\\,0,\\,6,\\,0,\\,0,\\,0,\\,3)$\n  - 第 5 行：$(4,\\,0,\\,0,\\,8,\\,0,\\,3,\\,0,\\,0,\\,1)$\n  - 第 6 行：$(7,\\,0,\\,0,\\,0,\\,2,\\,0,\\,0,\\,0,\\,6)$\n  - 第 7 行：$(0,\\,6,\\,0,\\,0,\\,0,\\,0,\\,2,\\,8,\\,0)$\n  - 第 8 行：$(0,\\,0,\\,0,\\,4,\\,1,\\,9,\\,0,\\,0,\\,5)$\n  - 第 9 行：$(0,\\,0,\\,0,\\,0,\\,8,\\,0,\\,0,\\,7,\\,9)$\n- 测试用例 B（接近完成，只有一个空格）：\n  - 第 1 行：$(0,\\,3,\\,4,\\,6,\\,7,\\,8,\\,9,\\,1,\\,2)$\n  - 第 2 行：$(6,\\,7,\\,2,\\,1,\\,9,\\,5,\\,3,\\,4,\\,8)$\n  - 第 3 行：$(1,\\,9,\\,8,\\,3,\\,4,\\,2,\\,5,\\,6,\\,7)$\n  - 第 4 行：$(8,\\,5,\\,9,\\,7,\\,6,\\,1,\\,4,\\,2,\\,3)$\n  - 第 5 行：$(4,\\,2,\\,6,\\,8,\\,5,\\,3,\\,7,\\,9,\\,1)$\n  - 第 6 行：$(7,\\,1,\\,3,\\,9,\\,2,\\,4,\\,8,\\,5,\\,6)$\n  - 第 7 行：$(9,\\,6,\\,1,\\,5,\\,3,\\,7,\\,2,\\,8,\\,4)$\n  - 第 8 行：$(2,\\,8,\\,7,\\,4,\\,1,\\,9,\\,6,\\,3,\\,5)$\n  - 第 9 行：$(3,\\,4,\\,5,\\,2,\\,8,\\,6,\\,1,\\,7,\\,9)$\n- 测试用例 C（因给定数字矛盾而无解）：\n  - 第 1 行：$(5,\\,5,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 2 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 3 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 4 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 5 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 6 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 7 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 8 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 9 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n\n答案规范和输出格式：\n- 对于每个测试用例，您的程序必须计算以下之一：\n  - 如果存在解，则以行主序输出解出的网格，形式为一个包含 $81$ 个整数的扁平列表，每个整数在 $\\{1,\\dots,9\\}$ 范围内。\n  - 如果不存在解，则输出一个空列表。\n- 您的程序应生成单行输出，其中包含所有三个测试用例的结果，形式为用方括号括起来的逗号分隔列表。例如：“$[[\\dots],[\\dots],[]]$”。不应打印额外的空白或文本。\n\n约束和注意事项：\n- 您必须实现 Donald Knuth 的带有舞蹈链（DLX）的算法 X。不接受直接的约束传播或不使用 DLX 的朴素回溯。\n- 将给定的网格视为不可变的给定数字；将 $0$ 解释为空单元格。\n- 此问题不涉及物理单位、角度单位或百分比。所有输出均为指定的无单位整数。", "solution": "用户希望通过将数独谜题规约为精确覆盖问题，并应用 Donald Knuth 的带有舞蹈链（DLX）技术的算法 X 来解决它。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **问题：** 使用带有舞蹈链（DLX）的算法 X 解决数独。\n- **核心概念（精确覆盖）：** 给定一个全集 $\\mathcal{U}$ 和一个子集族 $\\mathcal{S}$，找到一个子集 $\\mathcal{C} \\subseteq \\mathcal{S}$，其中 $\\mathcal{U}$ 的每个元素恰好出现在 $\\mathcal{C}$ 的一个成员中。\n- **数独约束：** 对于一个 $9 \\times 9$ 的网格：\n    1. 每个单元格有一个来自 $\\{1, \\dots, 9\\}$ 的数字。\n    2. 每行有来自 $\\{1, \\dots, 9\\}$ 的每个数字恰好一次。\n    3. 每列有来自 $\\{1, \\dots, 9\\}$ 的每个数字恰好一次。\n    4. 每个 $3 \\times 3$ 的宫有来自 $\\{1, \\dots, 9\\}$ 的每个数字恰好一次。\n- **实现要求：**\n    1.  将数独构造成一个精确覆盖问题，有 $729$ 行（选择）和 $324$ 列（约束）。\n    2.  从零开始实现 DLX。\n    3.  通过限制候选选择来处理初始的非零数字（给定数字）。\n- **测试用例：**\n    - 测试用例 A：一个标准的可解谜题。\n    - 测试用例 B：一个接近完成的谜题。\n    - 测试用例 C：一个带有矛盾的无解谜题。\n- **输出格式：**\n    - 对于可解的情况，一个包含 $81$ 个整数的扁平列表，代表按行主序排列的已解网格。\n    - 对于无解的情况，一个空列表。\n    - 单行输出，例如 `[[...],[...],[]]`，包含所有结果。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n- **科学基础：** 该问题牢固地植根于计算机科学，特别是在组合搜索算法领域。将数独规约为精确覆盖问题是一种经典的、数学上合理的技巧。算法 X 及其 DLX 实现是解决此类问题的标准方法。该问题遵循算法学和离散数学的既定原则。\n- **定义明确：** 问题定义清晰。输入是一组 $9 \\times 9$ 的网格。任务是为每个网格找到一个有效的数独解。有效解的条件已明确说明。对可解和无解情况的输出格式都进行了精确规定。每个测试用例都有一个唯一的、有意义的答案（一个解出的网格或一个无解的确认）。\n- **客观性：** 问题陈述使用精确、无歧义的语言编写。所有约束、数据和要求都是形式化和客观的。没有主观因素。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。它是一个基于既定计算机科学原理的、定义明确的算法任务。以下解决方案提供了所需算法的 principled 实现。\n\n### 解决方案设计\n\n该解决方案的架构围绕将数独规约为一个精确覆盖问题，然后使用带有舞蹈链（DLX）的算法 X 的自定义实现来解决。\n\n**1. 将数独作为精确覆盖问题**\n\n核心思想是将数独约束表示为精确覆盖问题的全集 $\\mathcal{U}$，并将可能的操作（在单元格中放置一个数字）表示为子集族 $\\mathcal{S}$。\n\n-   **约束的全集 ($\\mathcal{U}$):** $324$ 条游戏规则是我们的全集元素，它们成为矩阵的列。\n    1.  **单元格占用：** 对于 $81$ 个单元格中的每一个 $(r, c)$，约束是它必须只包含一个数字。这给出了 $9 \\times 9 = 81$ 列。列索引：$c_{1} = 9r + c$。\n    2.  **行-数字：** 对于 $9$ 行和 $9$ 个数字中的每一个，约束是数字 $d$ 必须在行 $r$ 中恰好出现一次。这给出了 $9 \\times 9 = 81$ 列。列索引：$c_{2} = 81 + 9r + (d-1)$。\n    3.  **列-数字：** 对于 $9$ 列和 $9$ 个数字中的每一个，约束是数字 $d$ 必须在列 $c$ 中恰好出现一次。这给出了 $9 \\times 9 = 81$ 列。列索引：$c_{3} = 162 + 9c + (d-1)$。\n    4.  **宫-数字：** 对于 $9$ 个宫和 $9$ 个数字中的每一个，约束是数字 $d$ 必须在宫 $b$ 中恰好出现一次。这给出了 $9 \\times 9 = 81$ 列。列索引：$c_{4} = 243 + 9b + (d-1)$，其中宫索引 $b$ 计算为 $b = 3\\lfloor r/3 \\rfloor + \\lfloor c/3 \\rfloor$。\n\n-   **子集族 ($\\mathcal{S}$):** 候选操作是矩阵的行。单个“选择”是在单元格 $(r, c)$ 中放置一个数字 $d \\in \\{1,\\dots,9\\}$。共有 $9 \\times 9 \\times 9 = 729$ 种这样的可能选择。\n    -   每个选择，例如在单元格 $(r,c)$ 中放置数字 $d$，恰好满足四个约束：一个单元格约束，一个行-数字约束，一个列-数字约束，以及一个宫-数字约束。\n    -   因此，我们问题的 $729 \\times 324$ 矩阵表示中的每一行都恰好包含四个 $1$。\n\n寻找数独解等同于从这些选择（行）中找到一个包含 $81$ 个行的子集，使得 $324$ 个约束（列）中的每一个都被恰好一个选定的行所满足。这就是精确覆盖的定义。\n\n**2. 算法 X 与舞蹈链（DLX）**\n\n算法 X 是一种用于寻找精确覆盖的递归回溯算法。舞蹈链（DLX）是 Donald Knuth 提出的一种高效实现技术，它使用特定的数据结构来表示稀疏矩阵。\n\n-   **数据结构：** 稀疏的 $729 \\times 324$ 矩阵使用一个环形双向链表来表示。\n    -   矩阵中的每个 $1$ 成为一个 `Node` 对象。每个节点有四个指针：`L` (左)、`R` (右)、`U` (上)、`D` (下)。\n    -   同一矩阵行中的节点水平链接成一个循环列表。\n    -   同一矩阵列中的节点垂直链接成一个循环列表。\n    -   每列都有一个特殊的 `Column` 头节点。这些头节点本身水平链接成一个循环列表，该列表还包括一个主 `root` 节点。此列表跟踪当前活动的约束。\n    -   每个 `Column` 头节点存储其列的 `size`（$1$ 的数量），这对于搜索启发式至关重要。\n\n-   **搜索算法 (`search`):**\n    1.  **基本情况：** 如果 `root` 节点的右邻居是它自己（即 `root.R == root`），则所有列都已被覆盖，找到了一个解。\n    2.  **列选择：** 选择一个列 `c` 进行覆盖。使用 S-启发式（最短列）：选择具有最小 `size` 的列。这能有效地修剪搜索树。\n    3.  **覆盖操作 (`cover(c)`):** 这是 DLX 效率的核心。要覆盖列 `c`：\n        -   将其从列头的水平列表中解除链接。\n        -   对于在列 `c` 中有节点的每一行 `i`，通过解除其*其他*节点与各自列的链接，将该整行从考虑中“移除”。这是通过修改其垂直邻居的 `U` 和 `D` 指针来完成的。\n    4.  **递归与回溯：**\n        -   遍历刚刚被 `cover(c)` “移除”的每一行 `r`。\n        -   对于每个 `r`，暂时将其添加到解中。\n        -   对于行 `r` 中的每个节点 `j`（`c` 中的那个除外），覆盖其列 `j.col`。\n        -   递归调用 `search`。如果返回 `True`，则找到了解；将 `True` 沿调用栈向上传播。\n        -   如果递归调用失败，则回溯。取消选择行 `r`，并通过以与 `cover` 操作相反的顺序执行 `uncover` 操作，将矩阵恢复到其先前状态。\n    5.  **揭示操作 (`uncover(c)`):** 此操作通过重新链接所有节点和头节点，完美地逆转 `cover(c)`，恢复矩阵结构。\n\n**3. 处理给定数字和矛盾**\n\n初始的谜题状态（“给定数字”）通过预处理 DLX 结构来处理。\n\n-   对于每个给定的数字 $d$ 在单元格 $(r, c)$，我们被迫做出该选择。\n-   识别出对应于选择 $(r,c,d)$ 的矩阵行。该行从一开始就被有效地“选择”为解的一部分。\n-   选择此行意味着它满足的所有约束都必须被满足。这是通过遍历此行的节点并对其各自的列调用 `cover` 操作来实现的。\n-   如果给定数字存在矛盾（例如，同一行中有两个 $5$，如测试用例 C 所示），此过程将失败。例如，处理第一个 `5` 将覆盖“第 1 行中的 5”的 `行-数字` 约束。当处理第二个 `5` 时，其在矩阵中对应的行将已被先前的 `cover` 操作消除。程序会检测到这种不可能性，并在不启动搜索的情况下将谜题标记为无解。\n\n这种 principled 设计将抽象的数独谜题转化为具体的数学结构，并使用一种高效的专用算法来解决它。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SudokuDLXSolver:\n    \"\"\"\n    Solves a Sudoku puzzle by reducing it to an exact cover problem\n    and applying Donald Knuth's Algorithm X with Dancing Links (DLX).\n    \"\"\"\n\n    class Node:\n        \"\"\"A node in the DLX matrix, representing a '1'.\"\"\"\n        def __init__(self, col_header=None, row_idx=-1):\n            self.L = self.R = self.U = self.D = self\n            self.col = col_header\n            self.row_idx = row_idx\n\n    class Column(Node):\n        \"\"\"A column header in the DLX matrix, representing a constraint.\"\"\"\n        def __init__(self, name=\"\"):\n            super().__init__(self)\n            self.size = 0\n            self.name = name\n\n    def __init__(self, grid):\n        \"\"\"Initializes the solver and builds the DLX structure for the given grid.\"\"\"\n        self.grid = grid\n        self.N = 9\n        self.N2 = self.N * self.N\n        self.num_cols = 4 * self.N2  # 324 constraints\n        \n        self.solution_indices = []\n        self.solution_grid = None\n        self._build_dlx_structure()\n        self.is_solvable = self._handle_givens()\n\n    def _get_row_data_from_idx(self, row_idx):\n        \"\"\"Converts a matrix row index back to (row, col, digit) of the Sudoku.\"\"\"\n        val = row_idx\n        digit = (val % self.N) + 1\n        val //= self.N\n        col = val % self.N\n        val //= self.N\n        row = val\n        return row, col, digit\n\n    def _build_dlx_structure(self):\n        \"\"\"Constructs the toroidal doubly-linked list for the Sudoku exact cover matrix.\"\"\"\n        self.root = self.Column(\"root\")\n        self.columns = [self.Column(str(i)) for i in range(self.num_cols)]\n\n        self.root.R = self.columns[0]\n        self.columns[0].L = self.root\n        self.columns[-1].R = self.root\n        self.root.L = self.columns[-1]\n\n        for i in range(self.num_cols - 1):\n            self.columns[i].R = self.columns[i+1]\n            self.columns[i+1].L = self.columns[i]\n\n        for r in range(self.N):\n            for c in range(self.N):\n                for d_idx, d in enumerate(range(1, self.N + 1)):\n                    row_idx = r * self.N2 + c * self.N + d_idx\n                    box = (r // 3) * 3 + (c // 3)\n                    \n                    cols_to_cover = [\n                        r * self.N + c,                      # Cell (r,c) constraint\n                        self.N2 + r * self.N + d_idx,        # Row-Digit (r,d) constraint\n                        2 * self.N2 + c * self.N + d_idx,    # Col-Digit (c,d) constraint\n                        3 * self.N2 + box * self.N + d_idx,  # Box-Digit (b,d) constraint\n                    ]\n                    \n                    first_node = None\n                    prev_node = None\n                    for col_idx in cols_to_cover:\n                        col_header = self.columns[col_idx]\n                        new_node = self.Node(col_header, row_idx)\n\n                        new_node.U = col_header.U\n                        new_node.D = col_header\n                        col_header.U.D = new_node\n                        col_header.U = new_node\n                        col_header.size += 1\n\n                        if first_node is None:\n                            first_node = new_node\n                        if prev_node is not None:\n                            new_node.L = prev_node\n                            prev_node.R = new_node\n                        prev_node = new_node\n                    \n                    first_node.L = prev_node\n                    prev_node.R = first_node\n\n    def _handle_givens(self):\n        \"\"\"\n        Pre-processes the matrix by selecting rows corresponding to the givens.\n        Returns False if a contradiction is found in the givens.\n        \"\"\"\n        for r_idx in range(self.N):\n            for c_idx in range(self.N):\n                digit = self.grid[r_idx, c_idx]\n                if digit != 0:\n                    d_idx = digit - 1\n                    row_idx = r_idx * self.N2 + c_idx * self.N + d_idx\n                    \n                    found_row_node = None\n                    # Search for any node in the required row. We start from the cell constraint column.\n                    cell_col_idx = r_idx * self.N + c_idx\n                    p = self.columns[cell_col_idx].D\n                    while p != self.columns[cell_col_idx]:\n                        if p.row_idx == row_idx:\n                            found_row_node = p\n                            break\n                        p = p.D\n                    \n                    if found_row_node is None:\n                        return False # Contradiction in givens\n\n                    # Select this row: cover all columns it belongs to\n                    self.solution_indices.append(found_row_node.row_idx)\n                    self.cover(found_row_node.col)\n                    q = found_row_node.R\n                    while q != found_row_node:\n                        self.cover(q.col)\n                        q = q.R\n        return True\n\n    def cover(self, c):\n        \"\"\"Covers a column and all intersecting rows.\"\"\"\n        c.R.L = c.L\n        c.L.R = c.R\n        i = c.D\n        while i != c:\n            j = i.R\n            while j != i:\n                j.D.U = j.U\n                j.U.D = j.D\n                j.col.size -= 1\n                j = j.R\n            i = i.D\n\n    def uncover(self, c):\n        \"\"\"Uncovers a column, reversing a cover operation.\"\"\"\n        i = c.U\n        while i != c:\n            j = i.L\n            while j != i:\n                j.col.size += 1\n                j.D.U = j\n                j.U.D = j\n                j = j.L\n            i = i.U\n        c.R.L = c\n        c.L.R = c\n\n    def _search(self):\n        \"\"\"The recursive backtracking search of Algorithm X.\"\"\"\n        if self.root.R == self.root:\n            self._reconstruct_solution()\n            return True\n\n        # S-heuristic: choose column with the smallest size.\n        c = None\n        min_size = float('inf')\n        j = self.root.R\n        while j != self.root:\n            if j.size  min_size:\n                min_size = j.size\n                c = j\n            j = j.R\n\n        if c is None or c.size == 0:\n            return False\n\n        self.cover(c)\n\n        r_node = c.D\n        while r_node != c:\n            self.solution_indices.append(r_node.row_idx)\n            j_node = r_node.R\n            while j_node != r_node:\n                self.cover(j_node.col)\n                j_node = j_node.R\n\n            if self._search():\n                return True\n\n            self.solution_indices.pop()\n            j_node = r_node.L\n            while j_node != r_node:\n                self.uncover(j_node.col)\n                j_node = j_node.L\n            \n            r_node = r_node.D\n        \n        self.uncover(c)\n        return False\n\n    def _reconstruct_solution(self):\n        \"\"\"Builds the final 9x9 grid from the solution row indices.\"\"\"\n        solved_grid = np.zeros((self.N, self.N), dtype=int)\n        for row_idx in self.solution_indices:\n            r, c, d = self._get_row_data_from_idx(row_idx)\n            solved_grid[r, c] = d\n        self.solution_grid = solved_grid.flatten().tolist()\n\n    def solve(self):\n        \"\"\"Runs the solver and returns the solution.\"\"\"\n        if not self.is_solvable:\n            return []\n        if self._search():\n            return self.solution_grid\n        else:\n            return []\n\ndef solve():\n    test_cases = [\n        # Test Case A (General solvable)\n        np.array([\n            [5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]\n        ]),\n        # Test Case B (Nearly complete)\n        np.array([\n            [0, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test Case C (Unsolvable)\n        np.array([\n            [5, 5, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0]\n        ])\n    ]\n\n    results = []\n    for grid in test_cases:\n        solver = SudokuDLXSolver(grid)\n        result = solver.solve()\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # [ [1,2,3], [], [4,5,6] ] -> \"[[1,2,3],[],[4,5,6]]\"\n    result_strings = []\n    for r in results:\n        if r:\n            result_strings.append(f\"[{','.join(map(str, r))}]\")\n        else:\n            result_strings.append(\"[]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3277848"}]}