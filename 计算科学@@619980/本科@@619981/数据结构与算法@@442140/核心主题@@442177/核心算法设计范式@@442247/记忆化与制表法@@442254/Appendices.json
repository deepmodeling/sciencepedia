{"hands_on_practices": [{"introduction": "我们将从一个经典问题——“凑零钱”——开始我们的实践之旅。这个问题是学习动态规划“制表法”的绝佳起点，因为它直观地展示了如何通过自底向上地构建解来解决一个更大的问题。通过计算凑成每个金额所需的最少硬币数，你将掌握制表法的核心思想：利用已经解决的子问题的最优解来构建下一个子问题的解。[@problem_id:3251178]", "problem": "给定一个由正整数列表表示的有限硬币面额多重集，以及一个由非负整数表示的目标金额。目标是针对每个提供的测试用例，计算出使用每种面额无限供应的硬币，恰好凑成目标金额所需的最少硬币数量；或者确定无法凑出该确切金额。最终算法必须采用自底向上的制表法（tabulation）设计，并且只能使用 $\\mathcal{O}(C)$ 的额外空间，其中 $C$ 表示测试用例中的目标金额。您的程序不得依赖任何交互式输入，并且必须在预定义的测试套件上确定性地运行。\n\n推导的基本依据：\n- 最优子结构：目标金额的任何最优解都可以分解为一个较小子金额的最优解外加一枚额外的硬币。\n- 重叠子问题：在不同的分解路径中，子金额的最小硬币数量会重复出现。\n\n定义与约束：\n- 设硬币为正整数列表 $\\{d_1, d_2, \\ldots, d_n\\}$，其中 $n \\in \\mathbb{N}$。\n- 设目标金额为 $C \\in \\mathbb{N}_0$。\n- 每个测试用例的输出必须是一个整数：所需的最少硬币数量，如果无法凑出等于 $C$ 的确切金额，则为 $-1$。\n- 制表过程必须计算从 $0$ 到 $C$ 的所有中间金额的值，且仅使用一个长度为 $C+1$ 的数组或渐近等效的空间。\n\n测试套件：\n- 案例 1：硬币 $[1, 2, 5]$，目标 $11$。\n- 案例 2：硬币 $[2, 4]$，目标 $7$。\n- 案例 3：硬币 $[3, 7, 10]$，目标 $14$。\n- 案例 4：硬币 $[9, 6, 5, 1]$，目标 $11$。\n- 案例 5：硬币 $[5, 7]$，目标 $5$。\n- 案例 6：硬币 $[7, 9]$，目标 $0$。\n\n要求的输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$\\text{[result1,result2,result3]}$），其中每个 $\\text{result}$ 是对应测试用例所需的最少硬币数量的整数答案（如果不可能，则为 $-1$）。", "solution": "用户希望解决经典的硬币找零问题，即给定一组硬币面额，求解凑出特定目标金额所需的最少硬币数量。该问题必须使用自底向上的制表法解决，空间复杂度为 $\\mathcal{O}(C)$，其中 $C$ 是目标金额。\n\n### 第一步：提取已知信息\n\n-   **硬币面额**：一个由正整数组成的有限多重集，$\\{d_1, d_2, \\ldots, d_n\\}$，其中 $n \\in \\mathbb{N}$。\n-   **目标金额**：一个非负整数，$C \\in \\mathbb{N}_0$。\n-   **目标**：计算恰好凑成金额 $C$ 所需的最少硬币数量。如果不存在这样的组合，结果为 $-1$。\n-   **基本原则**：解决方案必须基于最优子结构和重叠子问题。\n-   **算法约束**：必须使用自底向上的制表法。\n-   **空间约束**：算法只能使用 $\\mathcal{O}(C)$ 的额外空间。\n-   **测试套件**：\n    -   案例 1：硬币 $[1, 2, 5]$，目标 $11$。\n    -   案例 2：硬币 $[2, 4]$，目标 $7$。\n    -   案例 3：硬币 $[3, 7, 10]$，目标 $14$。\n    -   案例 4：硬币 $[9, 6, 5, 1]$，目标 $11$。\n    -   案例 5：硬币 $[5, 7]$，目标 $5$。\n    -   案例 6：硬币 $[7, 9]$，目标 $0$。\n-   **输出格式**：单行字符串 `[result1,result2,...]`。\n\n### 第二步：使用提取的已知信息进行验证\n\n-   **科学基础**：该问题是计算机科学和组合优化领域一个公认的经典问题。它牢固地植根于动态规划的数学原理。没有违反科学事实或逻辑之处。\n-   **适定性**：问题定义清晰。输入（硬币面额，目标金额）已指定，期望的输出（最少硬币数或 $-1$）也明确无误。对于任何有效的输入，都存在唯一的最小解。\n-   **客观性**：问题陈述是形式化、精确的，并且不含主观或偏见的语言。\n\n该问题不存在任何无效性缺陷：\n1.  **科学/事实不健全**：无。该问题是一个标准的算法挑战。\n2.  **无法形式化/不相关**：无。该问题直接关于动态规划（制表法），并且完全可以形式化。\n3.  **不完整/矛盾的设置**：无。为每个测试用例提供了所有必要信息。\n4.  **不现实/不可行**：无。该问题处理的是抽象整数，而非物理约束。\n5.  **不适定/结构不良**：无。该问题是适定的。\n6.  **伪深刻/琐碎**：无。虽然这是一个经典问题，但它要求特定的、非平凡的算法实现（制表法）并遵守空间约束，使其成为一项有实质内容的练习。\n7.  **无法科学验证**：无。每个测试用例的结果都可以通过数学方法进行验证。\n\n### 第三步：结论与行动\n\n该问题是 **有效的**。将提供一个解决方案。\n\n### 基于原则的解决方案设计\n\n该问题表现出两个关键特性，使其适合使用动态规划解决：最优子结构和重叠子问题。\n\n1.  **最优子结构**：目标金额 $C$ 的一个最优解可以由更小子问题的最优解构造而成。如果凑成金额 $C$ 的最少硬币数是 $k$，其中一枚硬币的面额是 $d_j$，那么剩下的 $k-1$ 枚硬币必须构成凑成金额 $C - d_j$ 的最少硬币数量。\n\n2.  **重叠子问题**：在计算金额 $C$ 的解时，需要用到更小子金额（例如 $C-d_1$、$C-d_2$）的解。在解决其他子问题时，会再次需要这些相同的子金额的解，如果不存储结果，就会导致重复计算。\n\n设 $M(c)$ 为凑成金额 $c$ 所需的最少硬币数。我们的目标是计算 $M(C)$。\n\n根据最优子结构原理推导出的递归公式如下：\n-   **基本情况**：$M(0) = 0$。凑成金额 $0$ 需要 $0$ 枚硬币。\n-   **递归步骤**：对于任何金额 $c > 0$，我们可以通过取一枚面额为 $d_j$ 的硬币，并将其加到金额为 $c - d_j$ 的最优解上，来凑成该金额。我们必须尝试每一种可能的硬币，并选择导致总硬币数量最少的那一种。\n    $$ M(c) = 1 + \\min_{d_j \\in D, d_j \\le c} \\{ M(c - d_j) \\} $$\n    其中 $D$ 是硬币面额的集合。如果没有硬币 $d_j$ 可用于构成 $c$ 的有效解，则 $M(c) = \\infty$。\n\n直接递归实现此公式效率低下，因为它会重复计算相同子问题的解。制表法通过自底向上迭代地构建解来避免这种情况。\n\n制表法算法流程如下：\n1.  创建一个大小为 $C+1$ 的表（数组），我们称之为 `T`。`T[i]` 将存储 $M(i)$ 的值。\n2.  初始化该表以表示初始状态。基本情况是 $M(0) = 0$，所以我们设置 $T[0] = 0$。对于从 $1$ 到 $C$ 的所有其他金额 $i$，目前尚无已知解，因此我们将 $T[i]$ 初始化为一个代表无穷大的值。一个实用的无穷大选择是保证比任何可能的有效答案都大的数，例如 $C+1$（因为如果使用面值为 $1$ 的硬币，最大硬币数量不可能超过 $C$）。\n3.  从 $1$ 迭代到目标金额 $C$。对于每个金额 $i$，我们利用表中已计算的值，应用递归公式来计算 $T[i]$：\n    对于每种硬币面额 $d_j \\in D$：\n    如果 $i \\ge d_j$，我们可以通过使用一枚硬币 $d_j$ 来尝试凑成金额 $i$。所需的硬币数量将是 $1 + T[i - d_j]$。\n    我们用在所有可能的 $d_j$ 选择中找到的最小值来更新 $T[i]$：\n    $$ T[i] = \\min(T[i], 1 + T[i - d_j]) $$\n4.  循环完成后，$T[C]$ 的值将是凑成目标金额 $C$ 所需的最少硬币数量。如果 $T[C]$ 仍然是“无穷大”值（$C+1$），则意味着没有硬币组合可以凑成 $C$，答案为 $-1$。\n\n这种制表法的时间复杂度为 $\\mathcal{O}(n \\cdot C)$，其中 $n$ 是硬币面额的数量，这是由于嵌套循环所致。空间复杂度为 $\\mathcal{O}(C)$，因为需要一个大小为 $C+1$ 的存储数组 `T`，这满足了问题的约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Coin Change problem for a predefined test suite using\n    bottom-up dynamic programming (tabulation).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        ([1, 2, 5], 11),\n        # Case 2\n        ([2, 4], 7),\n        # Case 3\n        ([3, 7, 10], 14),\n        # Case 4\n        ([9, 6, 5, 1], 11),\n        # Case 5\n        ([5, 7], 5),\n        # Case 6\n        ([7, 9], 0),\n    ]\n\n    results = []\n    for coins, target in test_cases:\n        # Base case: target amount is 0, requires 0 coins.\n        if target == 0:\n            results.append(0)\n            continue\n\n        # Let infinity be a value greater than any possible number of coins.\n        # target + 1 is a safe choice.\n        infinity = target + 1\n        \n        # Create a DP table of size target + 1 to store the minimum coins\n        # for each amount from 0 to target.\n        # dp[i] will be the minimum coins for amount i.\n        dp = np.full(target + 1, infinity, dtype=int)\n\n        # Base case: 0 coins are needed to make an amount of 0.\n        dp[0] = 0\n\n        # Build the table from the bottom up.\n        # Iterate through all amounts from 1 to target.\n        for amount in range(1, target + 1):\n            # For each amount, try each coin denomination.\n            for coin in coins:\n                # If the current coin can be used to form the amount:\n                if amount >= coin:\n                    # Update the dp table with the minimum number of coins.\n                    # The number of coins is 1 (the current coin) + the number\n                    # of coins for the remaining amount (amount - coin).\n                    dp[amount] = min(dp[amount], 1 + dp[amount - coin])\n\n        # The final result is in dp[target].\n        final_count = dp[target]\n\n        # If dp[target] is still infinity, the amount cannot be made.\n        if final_count == infinity:\n            results.append(-1)\n        else:\n            results.append(int(final_count))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3251178"}, {"introduction": "在掌握了基本的制表法之后，我们来挑战一个更进一步的主题：空间优化。寻找最长回文子序列通常需要一个二维表格来记录所有子串的结果，导致 $O(N^2)$ 的空间复杂度。本练习将引导你分析动态规划的状态依赖关系，巧妙地将空间复杂度降至 $O(N)$，这是在实际工程中处理大规模数据时一项至关重要的技能。[@problem_id:3251302]", "problem": "实现一个自底向上的动态规划（制表法）算法，以计算给定字符串的最长回文子序列（LPS）的长度，并且只使用 $O(N)$ 的辅助空间，其中 $N$ 是输入字符串的长度。字符串的子序列定义为可以从原字符串中删除零个或多个字符而不改变其余字符顺序而得到的序列。回文是正向和反向读取都相同的序列。您的解决方案必须是迭代的（无递归），必须利用重叠子问题和最优子结构，并且除了输入和输出外，必须严格使用 $O(N)$ 的额外内存。\n\n从适用于动态规划的第一性原理开始：\n- 子序列和回文的正式定义，\n- 用于子问题分解的最优性原理（贝尔曼原理），\n- 重叠子问题的识别，\n并推导出一个正确的、能够达到所述空间界限的制表策略。您不得在内存中构建一个 $O(N^2)$ 的表，也不得存储用于重构的决策集；只要求计算 LPS 的长度。\n\n您的程序应为每个测试字符串计算其最长回文子序列的整数长度。对于空字符串，定义 LPS 长度为 $0$。\n\n输入不是在运行时提供的。相反，请按以下确切顺序将以下测试套件直接嵌入到您的程序中：\n- $\"\"$,\n- $\"a\"$,\n- $\"abcde\"$,\n- $\"aaaaa\"$,\n- $\"bbbab\"$,\n- $\"cbbd\"$,\n- $\"character\"$,\n- $\"agbdba\"$.\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序与测试套件相同。例如，对于三个结果 $3$、$0$ 和 $2$，要求的格式是 $[3,0,2]$。\n\n设计目标和约束：\n- 您的推导必须仅依赖于基本定义和动态规划范式（最优性原理和重叠子问题）。\n- 算法必须在 $O(N^2)$ 时间内运行，并使用 $O(N)$ 的辅助空间。\n- 每个测试用例的答案类型是整数。", "solution": "用户希望解决“最长回文子序列”（LPS）问题。\n\n### 第一步：提取已知条件\n- **问题**：计算最长回文子序列（LPS）的长度。\n- **算法**：自底向上的动态规划（制表法）。\n- **空间复杂度约束**：$O(N)$ 的辅助空间，其中 $N$ 是输入字符串的长度。\n- **时间复杂度约束**：$O(N^2)$。\n- **实现约束**：解决方案必须是迭代的（无递归），并且不得在内存中构建 $O(N^2)$ 的表。\n- **推导要求**：解决方案必须从第一性原理推导得出，包括正式定义、最优性原理和重叠子问题的识别。\n- **基本情况定义**：对于空字符串，LPS 长度定义为 $0$。\n- **测试套件**：实现必须按顺序使用以下测试字符串：`\"\"`, `\"a\"`, `\"abcde\"`, `\"aaaaa\"`, `\"bbbab\"`, `\"cbbd\"`, `\"character\"`, `\"agbdba\"`。\n- **输出格式**：单行输出，包含一个用方括号括起来的逗号分隔的整数结果列表（例如 `[3,0,2]`）。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题是计算机科学中的一个公认标准，特别是在算法和动态规划领域。它牢固地植根于数理逻辑和计算理论。\n- **适定性**：该问题是适定的。对于任何给定的字符串，都存在一个 LPS，其长度是一个唯一的整数，从而确保了唯一的解。时间和空间复杂度的约束是标准的，并且对于此问题是可实现的。\n- **客观性**：该问题使用计算机科学中常见的精确、客观和形式化的语言进行陈述。\n\n该问题不存在任何无效性缺陷：\n1.  **科学上不健全**：该问题在算法上和数学上都是健全的。\n2.  **无法形式化**：该问题可以完美地形式化为动态规划模型。\n3.  **不完整/矛盾**：该问题提供了所有必要的定义、约束、测试用例和输出格式。时间和空间约束与已知的优化解决方案一致。\n4.  **不切实际**：该问题是一个经典、现实的算法挑战。\n5.  **不适定**：对于任何输入字符串，都存在一个唯一的、有意义的解。\n6.  **过于简单**：虽然这是一个标准问题，但要求从第一性原理推导出 $O(N)$ 空间复杂度的解决方案并非易事，需要对动态规划状态中的依赖关系进行仔细推理。\n7.  **无法验证**：结果是可以通过计算验证的。\n\n### 第三步：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 解决方案推导\n\n解决方案按要求从第一性原理推导得出。\n\n**1. 正式定义**\n设 $S$ 是一个长度为 $N$ 的字符串。设 $S[i]$ 表示索引 $i$ 处的字符，其中 $0 \\le i  N$。\n- $S$ 的**子序列**（subsequence）是可以从 $S$ 中删除零个或多个字符而不改变其余字符顺序而得到的序列。\n- **回文**（palindrome）是正向和反向读取都相同的序列。\n- **最长回文子序列（LPS）**是 $S$ 的一个子序列，它既是回文，又具有最大可能长度。我们寻求的就是这个最大长度。\n\n**2. 最优性原理与子问题结构**\n该问题表现出最优子结构，这是动态规划的一个关键特性。最优性原理指出，一个问题的最优解包含其子问题的最优解。\n\n让我们定义一个子问题 $L(i, j)$，作为子字符串 $S[i \\dots j]$（包含两端）的 LPS 长度。我们的目标是找到 $L(0, N-1)$。\n\n我们可以通过考虑其端点字符 $S[i]$ 和 $S[j]$ 来构建 $L(i, j)$ 的解：\n- **情况 1：端点字符匹配，即 $S[i] = S[j]$。**\n  在这种情况下，这两个字符可以构成一个回文的外部对。回文的其余部分必须是内部子字符串 $S[i+1 \\dots j-1]$ 的 LPS。因此，$S[i \\dots j]$ 的 LPS 长度是 $2$ 加上 $S[i+1 \\dots j-1]$ 的 LPS 长度。\n  $$L(i, j) = 2 + L(i+1, j-1)$$\n\n- **情况 2：端点字符不匹配，即 $S[i] \\neq S[j]$。**\n  由于 $S[i]$ 和 $S[j]$ 不能同时成为同一个回文对的两端，因此 $S[i \\dots j]$ 的 LPS 不能同时使用它们。因此，LPS 必须是子字符串 $S[i+1 \\dots j]$（不包括 $S[i]$）的 LPS 或子字符串 $S[i \\dots j-1]$（不包括 $S[j]$）的 LPS。我们取两者中能产生更长结果的那个。\n  $$L(i, j) = \\max(L(i+1, j), L(i, j-1))$$\n\n**基本情况：**\n- 长度为 $1$ 的子字符串（其中 $i = j$）是长度为 $1$ 的回文。所以，$L(i, i) = 1$。\n- 一个概念上的子字符串，其起始索引大于结束索引（$i > j$），是空的，所以其 LPS 长度为 $0$。\n\n**3. 递推关系与重叠子问题**\n$S[i \\dots j]$ 的 LPS 长度的完整递推公式为：\n$$\nL(i, j) = \n\\begin{cases} \n0  \\text{if } i > j \\\\\n1  \\text{if } i = j \\\\\n2 + L(i+1, j-1)  \\text{if } i  j \\text{ and } S[i] = S[j] \\\\\n\\max(L(i+1, j), L(i, j-1))  \\text{if } i  j \\text{ and } S[i] \\neq S[j]\n\\end{cases}\n$$\n直接递归实现此关系会效率低下，因为它会多次重复计算相同的子问题。例如，$L(i+1, j)$ 和 $L(i, j-1)$ 的计算都涉及到子问题 $L(i+1, j-1)$。这种重叠子问题的特性证明了使用动态规划来存储和重用子问题结果的合理性。\n\n**4. $O(N^2)$ 空间复杂度的制表法**\n自底向上（制表法）的方法解决规模递增的子问题。我们可以使用一个二维表 $\\text{dp}[i][j]$ 来存储 $L(i, j)$ 的值。该表的大小为 $N \\times N$。\n\n填充表时必须遵循一个顺序，使得在计算 $\\text{dp}[i][j]$ 时，其依赖的值（$\\text{dp}[i+1][j-1]$、$\\text{dp}[i+1][j]$ 和 $\\text{dp}[i][j-1]$）都已知。这可以通过遍历子字符串的长度 `l`（从 $1$ 到 $N$）来实现。\n\n- 对于 `l = 1`：对所有 $i$，$`dp[i][i] = 1`。\n- 对于 `l = 2 \\dots N`：\n  - 对于 `i = 0 \\dots N-l`：\n    - 令 `j = i + l - 1`。\n    - 如果 `S[i] == S[j]`，则 `dp[i][j] = 2 + dp[i+1][j-1]`。\n    - 如果 `S[i] != S[j]`，则 `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`。\n\n最终答案是 `dp[0][N-1]`。此方法需要 $O(N^2)$ 的时间和 $O(N^2)$ 的空间。\n\n**5. $O(N)$ 空间复杂度的制表法优化**\n为了满足 $O(N)$ 的空间约束，我们必须分析递推关系中的依赖性。任何单元格 $\\text{dp}[i][j]$ 的计算仅依赖于第 `i` 行、第 `j-1` 列的值（$\\text{dp}[i][j-1]$）以及来自第 `i+1` 行的值（$\\text{dp}[i+1][j]$ 和 $\\text{dp}[i+1][j-1]$）。这表明，要计算当前行 `i` 的值，我们只需要前一行 `i+1` 的值。我们不需要整个 $N \\times N$ 的表。\n\n这允许使用两个大小为 $N$ 的一维数组进行优化，一个用于当前行的计算，另一个用于保存前一行的结果。这需要 $O(N)$ 的空间。\n\n甚至可以进一步优化到只使用一个一维数组。让我们使用一个大小为 $N$ 的一维数组 `dp`。我们将用索引 `i` 从 $N-1$ 向下迭代到 $0$。在每次外部 `i` 循环开始时，`dp` 数组将保存第 `i+1` 行的结果。然后，我们将在原地更新它以保存第 `i` 行的结果。\n\n$\\text{dp}[j]$（表示 $L(i, j)$）的更新规则是：\n- 如果 `S[i] == S[j]`，我们需要 $L(i+1, j-1)$。\n- 如果 `S[i] != S[j]`，我们需要 $\\max(L(i+1, j), L(i, j-1))$。\n\n让我们追踪在固定 `i` 的情况下，当 `j` 从 `i+1` 迭代到 $N-1$ 时，原地更新数组的依赖关系：\n- 为了计算新的 `dp[j]`，我们需要 $L(i, j-1)$，这是当前迭代中新计算的 `dp[j-1]` 值。这没有问题。\n- 我们还需要 $L(i+1, j)$，这是 `dp[j]` 在被更新*之前*的值。\n- 我们还需要 $L(i+1, j-1)$，这是 `dp[j-1]` 在内层循环上一步（`j-1`）中被更新*之前*的值。\n\n这会产生数据覆盖问题。为了解决它，我们必须在计算新的 `dp[j]` 之前保存 $L(i+1, j)$ 的值。然后，这个保存的值可以在下一个内层循环步骤（`j+1`）中用作所需的 $L(i+1, (j+1)-1) = L(i+1, j)$ 值。\n\n**最终的 $O(N)$ 空间算法：**\n1. 初始化一个大小为 $N$ 的一维数组 `dp`。\n2. 从 $N-1$ 向下迭代 `i` 到 $0$。\n3. 对于每个 `i`：\n   a. 设置 `dp[i] = 1`（基本情况 $L(i, i)=1$）。\n   b. 初始化一个变量 `prev_val = 0`。这将存储字符匹配情况下所需的“对角线”值 $L(i+1, j-1)$。最初，对于 `j=i+1`，这对应于 $L(i+1, i)$，它是一个长度为 $0$ 的空子字符串。\n   c. 从 $i+1$ 迭代 `j` 到 $N-1$。\n      i. 保存 `dp[j]` 的当前值，称之为 `temp`。这是 $L(i+1, j)$。\n      ii. 如果 `S[i] == S[j]`：\n          新值为 $2 + L(i+1, j-1)$。值 $L(i+1, j-1)$ 存储在来自上一个 `j` 步骤的 `prev_val` 中。因此，设置 `dp[j] = prev_val + 2`。\n      iii. 如果 `S[i] != S[j]`：\n          新值为 $\\max(L(i+1, j), L(i, j-1))$。$L(i+1, j)$ 是 `temp`，$L(i, j-1)$ 是 `dp[j-1]` 的新值。因此，设置 `dp[j] = max(temp, dp[j-1])`。\n      iv. 将 `prev_val` 更新为 `temp`，以便在下一个 `j` 迭代中使用。\n4. 循环完成后，`dp[N-1]` 保存着最终答案 $L(0, N-1)$。\n\n该算法由于嵌套循环而在 $O(N^2)$ 时间内运行，并使用 $O(N)$ 的空间用于 `dp` 数组。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the length of the Longest Palindromic Subsequence for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        \"\",\n        \"a\",\n        \"abcde\",\n        \"aaaaa\",\n        \"bbbab\",\n        \"cbbd\",\n        \"character\",\n        \"agbdba\",\n    ]\n\n    results = []\n    for s in test_cases:\n        results.append(lps_length_optimized(s))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef lps_length_optimized(s: str) -> int:\n    \"\"\"\n    Computes the length of the Longest Palindromic Subsequence using bottom-up\n    dynamic programming with O(N) auxiliary space.\n\n    The derivation is based on the recurrence relation for L(i, j), the length of the\n    LPS in the substring s[i..j].\n\n    L(i, j) = 1,                                   if i = j\n              2 + L(i+1, j-1),                      if s[i] == s[j]\n              max(L(i+1, j), L(i, j-1)),            if s[i] != s[j]\n\n    This function implements the space-optimized tabulation where a single 1D array `dp`\n    is used to store the results of the previous row's computations while calculating\n    the current row's values.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The integer length of the LPS.\n    \"\"\"\n    n = len(s)\n    if n = 1:\n        return n\n\n    # dp array of size N will store the results.\n    # At the start of the outer loop `i`, dp stores the LPS lengths for substrings starting at `i+1`.\n    # It is then updated in-place to store results for substrings starting at `i`.\n    dp = np.zeros(n, dtype=int)\n\n    # Outer loop iterates backwards from the end of the string.\n    for i in range(n - 1, -1, -1):\n        # Base case: LPS of a single character string s[i..i] is 1.\n        dp[i] = 1\n        \n        # prev_val holds the value from the \"top-left\" diagonal in the conceptual 2D DP table.\n        # For a given (i, j), it stores L(i+1, j-1).\n        prev_val = 0\n        \n        # Inner loop computes LPS for substrings s[i..j] of increasing length.\n        for j in range(i + 1, n):\n            # Store dp[j] which is L(i+1, j) before it's overwritten.\n            # This is needed for the L(i+1, j) part of the max() and to update prev_val.\n            temp = dp[j]\n            \n            if s[i] == s[j]:\n                # If characters match, the length is 2 + length of the inner palindrome.\n                # The inner palindrome corresponds to s[i+1..j-1], and its LPS length\n                # is stored in prev_val from the previous j-step.\n                dp[j] = prev_val + 2\n            else:\n                # If characters do not match, we take the maximum of excluding s[i] or s[j].\n                # L(i+1, j) is `temp`.\n                # L(i, j-1) is the newly computed `dp[j-1]`.\n                dp[j] = max(temp, dp[j-1])\n            \n            # Update prev_val for the next iteration of j.\n            # At j+1, we will need L(i+1, j), which is the `temp` from this iteration.\n            prev_val = temp\n            \n    # The final result for the whole string s[0..n-1] is in dp[n-1].\n    return int(dp[n-1])\n\nsolve()\n```", "id": "3251302"}, {"introduction": "最后的练习将考察你的建模和抽象能力。“盒子堆叠”问题初看起来很复杂，因为它涉及三维空间、旋转和堆叠规则。成功的关键在于将这个问题转化为我们熟悉的动态规划模型，即“最长递增子序列”问题的变种。这个练习将教会你如何在面对一个新问题时，首先定义好“状态”和“状态转移”，从而应用动态规划的强大威力。[@problem_id:3251271]", "problem": "给定一个包含三维长方体盒子的有限多重集。每种盒子类型由代表其正交边长的三个正整数指定。您可以任意旋转盒子，因此三条边中的任意一条都可以作为垂直高度，剩下的两条作为水平底边。每种输入的盒子类型都有无限的供应量。如果每个放置在上方的盒子的两个底边都严格小于其正下方盒子的相应底边，则该堆叠是有效的。目标是最大化堆叠的总垂直高度。\n\n此任务的基础是基于最优性原则和重叠子问题存在的动态规划方法论。具体而言：\n- 最优子结构：如果最优堆叠的底部是一个特定的盒子（以特定方向放置），那么其上方的堆叠部分对于被约束为底面严格小于该定向底面的盒子的子问题而言，是一个最优堆叠。\n- 重叠子问题：由“在给定定向底面约束下可实现的最大高度”定义的子问题，在选择不同底部盒子时会反复出现，除非进行记忆化或制表，否则会被重复求解。\n\n您的任务是实现两种算法：\n- 一种带记忆化的自顶向下动态规划算法，其中记忆化状态必须明确包含作为当前底座候选盒子的方向。\n- 一种带制表的自底向上动态规划算法，按照尊重严格底面尺寸约束的顺序遍历定向候选盒子。\n\n两种算法对于每个测试用例都必须返回相同的最大高度。这些算法必须在以下精确且通用的规则下运行：\n- 对于任何尺寸为 $\\{x,y,z\\}$ 的盒子，您可以使用其三种方向中的任意一种，即从 $\\{x,y,z\\}$ 中选择一个作为高度，另外两个作为有序底边。有序底面表示为一个数对 $(b_1,b_2)$，其中 $b_1 \\ge b_2$，两个底面之间的比较是按分量进行的：底面 $(b_1,b_2)$ 仅当 $c_1  b_1$ 且 $c_2  b_2$ 时，才能在其上方承载另一个底面 $(c_1,c_2)$。\n- 每个堆叠元素都是一个定向盒子。您有无限数量的每种输入盒子类型可用，并且可以根据严格的底面约束选择任何方向，一个盒子只能通过其有序底面对进行比较，并将其选择的高度贡献给总高度。\n- 如果不使用任何盒子，则高度为 $0$。\n\n实现一个完整的程序，为以下每个测试用例计算可实现的最大堆叠高度。在每个案例中，输入是一个盒子列表，每个盒子由一个正整数三元组给出。您必须使用下面确切的测试套件。\n\n测试套件：\n- 案例 $1$：$[]$\n- 案例 $2$：$[[3,2,1]]$\n- 案例 $3$：$[[4,3,2],[3,2,1]]$\n- 案例 $4$：$[[4,4,4],[4,4,4]]$\n- 案例 $5$：$[[6,5,4],[5,4,3],[7,6,1],[9,8,2],[8,7,3]]$\n\n您的程序必须使用两种方法计算每个案例的最大总高度（一个整数），验证结果是否匹配，然后生成单行输出，其中包含一个用方括号括起来的、无空格的逗号分隔列表。例如，您的输出必须具有 $[h_1,h_2,\\dots,h_k]$ 的形式，其中每个 $h_i$ 都是一个整数。此问题不涉及物理单位。不涉及角度。不涉及百分比。\n\n设计要求覆盖范围：\n- 具有非平凡方向选择和堆叠的一般情况：案例 $5$。\n- 无盒子的边界情况：案例 $1$。\n- 最佳方向决定答案的单个盒子情况：案例 $2$。\n- 严格不等式起作用的相同立方体边缘案例：案例 $4$。\n- 用于验证严格不等式和方向相互作用的小型多盒场景：案例 $3$。\n\n您的程序必须完全自包含，不读取任何输入。它必须硬编码上述测试套件，并以指定格式在单行中打印结果。", "solution": "所提出的问题是经典盒子堆叠问题的一个变体，这是动态规划的一个标准应用。任务是从一组给定的、每种都有无限供应的盒子类型中选择盒子，以在特定的堆叠约束下，找到可能的最大堆叠高度。\n\n### 问题形式化与验证\n\n该问题定义明确、数学上合理且内部一致。它是一个形式化的算法挑战，不违反任何科学原则。已知条件如下：\n- 一组输入的盒子类型，每种类型由一个包含三个正整数尺寸的元组 $\\{x, y, z\\}$ 定义。\n- 每种盒子类型都有无限供应。\n- 一个盒子可以通过选择一个维度作为高度、另外两个作为底面维度，以三种方式中的任意一种定向。\n- 任何方向的底面尺寸 $(d_1, d_2)$ 都被规范地表示为一个有序对 $(b_1, b_2)$，其中 $b_1 = \\max(d_1, d_2)$ 且 $b_2 = \\min(d_1, d_2)$。\n- 一个底面为 $(c_1, c_2)$ 的盒子可以放置在一个底面为 $(b_1, b_2)$ 的盒子之上，当且仅当 $c_1  b_1$ 且 $c_2  b_2$。这是一个严格的按分量不等式。\n- 目标是最大化有效堆叠中盒子的高度总和。空堆叠的高度为 $0$。\n\n该问题具备动态规划解法所需的两个关键属性：\n1.  **最优子结构**：最大高度的堆叠由一个底部盒子和放置在其上的一个最优的较小盒子堆叠组成。\n2.  **重叠子问题**：寻找可以放置在给定底座上的最大高度堆叠的子问题会重复出现。\n\n这个问题可以建模为在有向无环图（DAG）中寻找最长路径。DAG 的节点是可能的盒子方向，每个节点的权重是其高度。如果对应于节点 $B$ 的盒子可以直接放置在对应于节点 $A$ 的盒子上，则存在从节点 $A$到节点 $B$ 的有向边。堆叠规则中的严格不等式保证了该图是无环的。\n\n### 算法策略\n\n**1. 状态表示与预处理**\n\n首先，我们从输入的盒子类型中生成所有可能的唯一方向。每个尺寸为 $\\{x, y, z\\}$ 的盒子最多可以产生三种不同的方向，我们将其表示为元组 $(h, b_1, b_2)$，其中 $h$ 是高度，$(b_1, b_2)$ 是有序底面，且 $b_1 \\ge b_2$。所有输入盒子类型的所有这些唯一方向的集合构成了我们问题的状态空间。\n\n设这个包含 $M$ 个唯一方向的集合为 $O$。为了便于动态规划的递推，我们对这个列表进行排序。一个稳健的排序方案是按降序对方向进行排序，首先按 $b_1$ 排序，其次按 $b_2$ 排序。设排序后的列表为 $O = [o_0, o_1, \\dots, o_{M-1}]$。这种排序确保了如果一个定向盒子 $o_i$ 可以放置在另一个盒子 $o_j$ 上，那么 $o_j$ 必须有更大的底面，由于排序，这意味着 $j  i$。这种结构类似于最长递增子序列（LIS）问题。\n\n**2. 算法1：自底向上动态规划（制表法）**\n\n我们使用一个大小为 $M$ 的表 `dp`，其中 $\\text{dp}[i]$ 存储以定向盒子 $o_i$ 为最顶部盒子的有效堆叠的最大高度。\n\n表的填充方式如下：\n- 对于从 $0$ 到 $M-1$ 的每个 $i$，$\\text{dp}[i]$ 初始化为盒子 $o_i$ 的高度，表示一个单盒子的堆叠。\n- 然后，我们遍历所有在它之前的盒子 $o_j$（其中 $j  i$），并检查 $o_i$ 是否可以放置在 $o_j$ 上。$o_i$ 的底面是 $(b_{i1}, b_{i2})$，$o_j$ 的底面是 $(b_{j1}, b_{j2})$。条件是 $b_{i1}  b_{j1}$ 且 $b_{i2}  b_{j2}$。\n- 如果 $o_i$ 可以放置在 $o_j$ 上，我们就有一个可能以 $o_i$ 结尾的更高堆叠。我们根据以下递推关系更新 $\\text{dp}[i]$：\n$$\n\\text{dp}[i] = \\max(\\text{dp}[i], \\text{height}(o_i) + \\text{dp}[j])\n$$\n- 在遍历完所有 $i$ 和 $j$ 之后，`dp` 表中的最大值就是任何可能堆叠的最大高度。如果 $M=0$，答案为 $0$。\n\n**3. 算法2：自顶向下动态规划（记忆化）**\n\n这种方法使用带记忆化的递归来解决相同的问题。我们定义一个递归函数 $\\text{getMaxHeight}(i)$，它计算以定向盒子 $o_i$ 作为其**最底部**元素堆叠的最大高度。一个记忆化表 `memo` 用于存储子问题的结果以避免重复计算。\n\n该函数的定义如下：\n- **基本情况**：如果 $\\text{memo}[i]$ 的结果已经被计算，则直接返回。\n- **递归步骤**：为了找到以 $o_i$ 为底部的堆叠的最大高度，我们考虑所有可以放置在 $o_i$ 之上的其他盒子 $o_j$。由于我们的排序，我们只需要检查 $j > i$ 的情况。该高度是 $o_i$ 的高度加上可以在其上构建的堆叠的最大高度。\n$$\n\\text{getMaxHeight}(i) = \\text{height}(o_i) + \\max(\\{0\\} \\cup \\{\\text{getMaxHeight}(j) \\mid j > i \\text{ and } o_j \\text{ fits on } o_i\\})\n$$\n- $\\text{memo}[i]$ 的结果在返回前被存储。\n\n为了找到总的最大堆叠高度，我们必须对所有可能的底部盒子 $i \\in [0, M-1]$ 调用 $\\text{getMaxHeight}(i)$，并取其返回值的最大值。如果 $M=0$，答案为 $0$。\n\n两种算法都通过系统地探索由可能堆叠构成的 DAG 定义的状态空间来正确解决问题。它们的结果必须相同。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the box stacking problem for a fixed suite of test cases\n    using both tabulation and memoization approaches and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [[3, 2, 1]],\n        [[4, 3, 2], [3, 2, 1]],\n        [[4, 4, 4], [4, 4, 4]],\n        [[6, 5, 4], [5, 4, 3], [7, 6, 1], [9, 8, 2], [8, 7, 3]],\n    ]\n\n    def _generate_and_sort_orientations(boxes):\n        \"\"\"\n        Generates all unique orientations from a list of box dimensions and\n        sorts them in descending order of base dimensions.\n\n        An orientation is a tuple (height, base_dim1, base_dim2) where base_dim1 >= base_dim2.\n        \"\"\"\n        orientations = set()\n        for box in boxes:\n            x, y, z = box\n            # Orientation 1: height=x, base=(y, z)\n            orientations.add((x, max(y, z), min(y, z)))\n            # Orientation 2: height=y, base=(x, z)\n            orientations.add((y, max(x, z), min(x, z)))\n            # Orientation 3: height=z, base=(x, y)\n            orientations.add((z, max(x, y), min(x, y)))\n        \n        # Sort by base_dim1 desc, then base_dim2 desc.\n        return sorted(list(orientations), key=lambda o: (o[1], o[2]), reverse=True)\n\n    def solve_tabulation(oriented_boxes):\n        \"\"\"\n        Calculates max stack height using bottom-up DP (tabulation).\n        dp[i] = max height of a stack with oriented_boxes[i] as the TOP box.\n        \"\"\"\n        if not oriented_boxes:\n            return 0\n        \n        n = len(oriented_boxes)\n        dp = [box[0] for box in oriented_boxes]  # Initialize with own height\n\n        for i in range(n):\n            box_i_h, box_i_b1, box_i_b2 = oriented_boxes[i]\n            for j in range(i):\n                # Check if box i can be placed on box j.\n                # Because of descending sort, j  i means box j has a larger or equal base.\n                box_j_h, box_j_b1, box_j_b2 = oriented_boxes[j]\n                \n                if box_i_b1  box_j_b1 and box_i_b2  box_j_b2:\n                    dp[i] = max(dp[i], box_i_h + dp[j])\n\n        return max(dp) if dp else 0\n\n    def solve_memoization(oriented_boxes):\n        \"\"\"\n        Calculates max stack height using top-down DP (memoization).\n        _get_max_height(i) = max height of a stack with oriented_boxes[i] as the BOTTOM box.\n        \"\"\"\n        if not oriented_boxes:\n            return 0\n\n        n = len(oriented_boxes)\n        memo = {}\n\n        def _get_max_height(i):\n            if i in memo:\n                return memo[i]\n\n            box_i_h, box_i_b1, box_i_b2 = oriented_boxes[i]\n            max_height_above = 0\n            \n            # Find the best stack to place on top of box i.\n            # Due to sorting, we only need to look at boxes with a smaller base.\n            for j in range(i + 1, n):\n                box_j_h, box_j_b1, box_j_b2 = oriented_boxes[j]\n                if box_j_b1  box_i_b1 and box_j_b2  box_i_b2:\n                    max_height_above = max(max_height_above, _get_max_height(j))\n            \n            result = box_i_h + max_height_above\n            memo[i] = result\n            return result\n\n        # The final answer is the maximum height starting with any box as the base.\n        max_total_height = 0\n        for i in range(n):\n            max_total_height = max(max_total_height, _get_max_height(i))\n            \n        return max_total_height\n\n    results = []\n    for case in test_cases:\n        orientations = _generate_and_sort_orientations(case)\n        \n        res_tab = solve_tabulation(orientations)\n        res_memo = solve_memoization(orientations)\n        \n        # Verification that both methods yield the same result.\n        assert res_tab == res_memo, f\"Mismatch for case {case}: Tab={res_tab}, Memo={res_memo}\"\n        \n        results.append(res_tab)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3251271"}]}