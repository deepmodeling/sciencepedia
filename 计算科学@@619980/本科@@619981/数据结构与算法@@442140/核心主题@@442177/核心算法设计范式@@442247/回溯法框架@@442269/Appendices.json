{"hands_on_practices": [{"introduction": "子集和问题是组合优化的一个典型范例，也是学习回溯算法的绝佳起点。这个练习要求我们构建一个决策树，对每个元素做出“包含”或“不包含”在最终子集中的决策。通过解决这个问题 [@problem_id:3212780]，你将掌握回溯算法的递归结构、状态表示以及基于可行性和限界条件的剪枝策略，为解决更复杂的问题打下坚实基础。", "problem": "您需要设计并实现一个回溯框架，以解决一个带约束的子集和决策问题的变体。该问题的基础如下。子集和问题定义在一个包含非负权重的有限物品集上，该物品集由一个索引集 $\\{0,1,\\dots,n-1\\}$ 表示。每个物品 $i$ 都有一个相关的非负整数权重 $w_i \\in \\mathbb{Z}_{\\ge 0}$，并属于一个颜色类别，该类别由一个映射 $col(i)$ 决定，其值域为一个有限的颜色标签集 $\\mathcal{C}$。指定一个目标和 $T \\in \\mathbb{Z}_{\\ge 0}$。任务是确定一个子集 $S \\subseteq \\{0,\\dots,n-1\\}$，使得 $\\sum_{i \\in S} w_i = T$，并满足约束条件：对于每个颜色类别 $c \\in \\mathcal{C}$，子集 $S$ 中颜色为 $c$ 的物品数量最多为 $k$ 个，其中 $k \\in \\mathbb{Z}_{\\ge 0}$ 是一个统一的界限。\n\n您的程序必须实现一个有原则的回溯搜索，该搜索按索引升序探索物品索引上的二元决策树，并应用基于组合搜索中以下经过充分检验的事实的可行性剪枝规则。首先，可行性剪枝：任何当前和超过 $T$ 的部分分配都无法扩展为有效解，因为所有权重都是非负的。其次，充分性剪枝：如果当前部分和与尚未考虑的物品所能达到的剩余和的上界之和严格小于 $T$，则任何扩展都无法达到目标。您必须确保算法遵守颜色基数约束，即对于每种颜色 $c$，来自 $S$ 且 $col(i)=c$ 的索引数量不超过 $k$。如果存在有效子集，程序必须在所有有效子集中返回按升序排列的字典序最小的索引列表。如果不存在有效子集，则返回空列表。索引是从零开始的，所以第一个物品的索引是 $0$。\n\n您对每个测试用例的输出必须是构成所选子集的、按升序排列的整数索引列表；如果不存在解，则输出空列表。最终输出格式必须将所有测试用例的结果聚合到单行输出中，该输出包含一个由方括号括起来的逗号分隔列表形式的结果（例如，$[result_1,result_2,result_3]$），其中每个 $result_j$ 本身都是一个整数列表（可能为空）。\n\n提供的测试套件包含 $6$ 个测试用例，涵盖了一般情况、边界条件和边缘情况。对于每个测试用例，物品由权重和颜色的数组定义，并指定了参数 $T$ 和 $k$。每个测试用例所需的输出是一个索引列表：\n\n- 测试用例 1（常规成功路径）：\n  - 权重：$[3,7,2,5,8]$\n  - 颜色：$['red', 'blue', 'red', 'green', 'blue']$\n  - 目标：$T=10$\n  - 颜色界限：$k=2$\n  - 要求输出类型：表示升序索引的整数列表，其和为 $10$，并满足每种颜色最多 $2$ 个物品的约束；返回字典序最小的有效列表。\n\n- 测试用例 2（颜色使用上的边界条件，k=1）：\n  - 权重：$[4,4,4,4]$\n  - 颜色：$['red', 'red', 'blue', 'blue']$\n  - 目标：$T=8$\n  - 颜色界限：$k=1$\n  - 要求输出类型：构成有效子集的整数列表。\n\n- 测试用例 3（颜色约束严重限制了可行性）：\n  - 权重：$[6,6,6]$\n  - 颜色：$['green', 'green', 'green']$\n  - 目标：$T=18$\n  - 颜色界限：$k=2$\n  - 要求输出类型：空列表，因为任何和为 $18$ 的子集都违反了颜色界限。\n\n- 测试用例 4（由于权重导致目标无法达到）：\n  - 权重：$[2,4,6]$\n  - 颜色：$['r', 'g', 'b']$\n  - 目标：$T=5$\n  - 颜色界限：$k=2$\n  - 要求输出类型：空列表。\n\n- 测试用例 5（存在多个解；选择字典序最小的）：\n  - 权重：$[1,1,2,2,3,3]$\n  - 颜色：$['A', 'A', 'B', 'B', 'A', 'B']$\n  - 目标：$T=6$\n  - 颜色界限：$k=2$\n  - 要求输出类型：字典序最小的有效索引列表。\n\n- 测试用例 6（k=0 且目标为平凡值的边缘情况）：\n  - 权重：$[5,3]$\n  - 颜色：$['x', 'y']$\n  - 目标：$T=0$\n  - 颜色界限：$k=0$\n  - 要求输出类型：空列表，代表有效的、和为 $0$ 的空子集。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，例如 $[[i\\_0,i\\_1],[j\\_0,j\\_1,j\\_2],[]]$，并按 1 到 6 的顺序包含这 6 个测试用例的精确计算列表。", "solution": "所提出的问题是子集和问题的一个约束变体，这是组合优化和算法学中的一个经典课题。一个严谨的解决方案必须建立在一个健全的回溯框架之上，该框架系统地探索解空间，同时积极地剪除不可行的搜索路径。\n\n### 基于原则的设计\n\n**1. 形式化问题定义**\n\n令物品集由索引 $I = \\{0, 1, \\dots, n-1\\}$ 表示。每个物品 $i \\in I$ 由一个非负整数权重 $w_i \\in \\mathbb{Z}_{\\ge 0}$ 和一个颜色 $c_i$（来自有限颜色集 $\\mathcal{C}$）来表征。给定一个非负整数目标和 $T \\in \\mathbb{Z}_{\\ge 0}$ 以及一个统一的非负整数颜色基数界限 $k \\in \\mathbb{Z}_{\\ge 0}$，目标是找到一个索引子集 $S \\subseteq I$，该子集在所有满足以下两个主要条件的子集中是字典序最小的：\n\n1.  **和约束**：子集中物品的权重之和必须等于目标和：$\\sum_{i \\in S} w_i = T$。\n2.  **颜色约束**：对于任何给定的颜色 $c \\in \\mathcal{C}$，子集 $S$ 中具有该颜色的物品数量不得超过界限 $k$。形式上，对于每一个 $c \\in \\mathcal{C}$，满足 $|\\{i \\in S \\mid c_i = c\\}| \\le k$。\n\n如果不存在满足这些条件的子集 $S$，则问题要求返回一个空列表。\n\n**2. 回溯框架**\n\n此问题的搜索空间包含物品集 $I$ 的所有 $2^n$ 个可能的子集。穷举搜索在计算上是不可行的。回溯提供了一种系统化的方法来遍历此空间，该空间可以建模为一个深度为 $n$ 的二元决策树。在树的每一层 $i$（从 $0$ 到 $n-1$），对物品 $i$ 作出决策：要么将其包含在候选解集中，要么将其排除。算法对此树执行深度优先遍历。\n\n为实现这一点，我们定义一个递归函数 `backtrack`，其状态捕获搜索的进度。每次递归调用时状态的基本参数是：\n- $i$：当前正在考虑包含或排除的物品的索引。\n- $W_{curr}$：在当前搜索树路径中已选物品的权重之和。\n- $S_{curr}$：表示部分解的列表，包含已选物品的索引。\n- $C_{counts}$：一个数据结构，例如哈希表，用于存储 $S_{curr}$ 中每种颜色的物品计数。\n\n**3. 递归逻辑与剪枝**\n\n`backtrack` 函数的核心由基本情况、剪枝规则和递归步骤组成。\n\n**基本情况：**\n- **找到解**：如果在任何时候 $W_{curr}$ 等于 $T$，则表示已用 $S_{curr}$ 中的物品找到了一个有效解。由于搜索的结构是为了首先找到字典序最小的解，算法可以立即终止并将 $S_{curr}$ 作为最终答案。\n- **搜索耗尽**：如果索引 $i$ 达到 $n$，则所有物品都已被考虑。如果 $W_{curr} \\neq T$，则此特定搜索路径是死胡同，递归必须回退（回溯）。\n\n**剪枝策略：**\n为避免探索搜索树的无用分支，应用了两个剪枝规则：\n1.  **可行性剪枝**：由于所有权重都是非负的（$w_i \\ge 0$），如果 $W_{curr}$ 在任何时候超过 $T$，和就不可能再减少。因此，任何 $W_{curr} > T$ 的路径都会被立即放弃。\n2.  **充分性剪枝**：可以使用一个乐观界来剪除不可能达到目标 $T$ 的路径。令 $W_{rem}(i) = \\sum_{j=i}^{n-1} w_j$ 为从索引 $i$ 开始的所有剩余物品的权重之和。如果当前和加上这个剩余可能和小于目标（即 $W_{curr} + W_{rem}(i)  T$），那么此路径无法扩展为有效解。为了高效地应用此规则，所有 $i$ 的后缀和 $W_{rem}(i)$ 都被预先计算。\n\n**4. 字典序最小性与递归步骤**\n\n对字典序最小解的要求决定了搜索顺序。算法按索引升序（$i=0, 1, \\dots, n-1$）考虑物品。在每一步 $i$，它必须优先考虑**包含**物品 $i$ 的决策，而不是**排除**它的决策。这确保了如果存在解，第一个找到的解将由尽可能小的索引组成，使其在字典序上最小。\n\n递归步骤如下：\n\n1.  **尝试包含物品 $i$**：\n    a. 检查包含物品 $i$ 是否符合颜色约束。当前解中颜色为 $c_i$ 的物品计数 $C_{counts}[c_i]$ 必须严格小于 $k$。\n    b. 如果有效，更新状态：将 $W_{curr}$ 增加 $w_i$，将 $i$ 附加到 $S_{curr}$，并增加 $C_{counts}[c_i]$。\n    c. 进行递归调用：`backtrack`(i+1, ...)。\n    d. 调用返回后，撤销状态更改（即回溯），为探索“排除”分支做准备。\n    e. 如果递归调用找到了解，则设置一个标志以终止所有其他正在进行和未来的递归调用。\n\n2.  **尝试排除物品 $i$**：\n    a. 当且仅当“包含”分支没有导致解时，算法才继续探索“排除”的可能性。\n    b. 除索引外，状态保持不变。\n    c. 进行递归调用：`backtrack`(i+1, ...)。\n\n这种有纪律的探索，结合剪枝，构成了一个正确且高效的算法来解决所述问题。对于 $T=0$ 的基本情况需要单独处理：空集是一个有效的解，因为它的和为 $0$，并且包含每种颜色的 $0$ 个物品，对任何 $k \\ge 0$ 都满足颜色约束。它也自然是字典序最小的解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    class ConstrainedSubsetSumSolver:\n        \"\"\"\n        A solver for the constrained subset sum problem using a backtracking framework.\n        \"\"\"\n        def __init__(self, weights, colors, target, k_bound):\n            self.weights = weights\n            self.colors = colors\n            self.target = target\n            self.k_bound = k_bound\n            self.n = len(weights)\n            \n            self.solution = []\n            self.found_solution = False\n            \n            # Pre-compute suffix sums for sufficiency pruning.\n            # self.suffix_sums[i] stores the sum of weights from index i to n-1.\n            self.suffix_sums = [0] * (self.n + 1)\n            for i in range(self.n - 1, -1, -1):\n                self.suffix_sums[i] = self.suffix_sums[i + 1] + self.weights[i]\n\n        def solve(self):\n            \"\"\"\n            Initializes and starts the backtracking search.\n            Returns the lexicographically smallest solution or an empty list.\n            \"\"\"\n            # The empty set is the valid, lexicographically smallest solution for T=0.\n            if self.target == 0:\n                return []\n\n            unique_colors = set(self.colors)\n            color_counts = {c: 0 for c in unique_colors}\n            \n            self._backtrack(0, 0, [], color_counts)\n            \n            return self.solution\n\n        def _backtrack(self, index, current_sum, current_path, color_counts):\n            \"\"\"\n            The core recursive backtracking function.\n            \"\"\"\n            # If a solution has been found, terminate this branch.\n            if self.found_solution:\n                return\n\n            # --- Base cases ---\n            # 1. Success: A valid solution is found.\n            if current_sum == self.target:\n                self.solution = list(current_path)\n                self.found_solution = True\n                return\n\n            # 2. Failure: All items considered but target not met.\n            if index == self.n:\n                return\n\n            # --- Pruning rules ---\n            # 1. Feasibility pruning: Current sum exceeds target.\n            if current_sum > self.target:\n                return\n            \n            # 2. Sufficiency pruning: Not enough remaining weight to reach target.\n            if current_sum + self.suffix_sums[index]  self.target:\n                return\n\n            # --- Recursive step ---\n            # To find the lexicographically smallest solution, we explore the \"include\"\n            # branch before the \"exclude\" branch.\n\n            # Choice 1: Include item `index`\n            item_weight = self.weights[index]\n            item_color = self.colors[index]\n            \n            if color_counts[item_color]  self.k_bound:\n                # Add item to the current path\n                current_path.append(index)\n                color_counts[item_color] += 1\n                \n                # Recurse\n                self._backtrack(index + 1, current_sum + item_weight, current_path, color_counts)\n                \n                # Backtrack: remove item from the current path\n                color_counts[item_color] -= 1\n                current_path.pop()\n\n                # If the \"include\" branch found a solution, we are done.\n                if self.found_solution:\n                    return\n\n            # Choice 2: Exclude item `index`\n            # This is explored only if the \"include\" branch did not find a solution.\n            self._backtrack(index + 1, current_sum, current_path, color_counts)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: General happy path\n        {'weights': [3, 7, 2, 5, 8], 'colors': ['red', 'blue', 'red', 'green', 'blue'], 'T': 10, 'k': 2},\n        # Test Case 2: Boundary on color usage with k=1\n        {'weights': [4, 4, 4, 4], 'colors': ['red', 'red', 'blue', 'blue'], 'T': 8, 'k': 1},\n        # Test Case 3: Color constraint critically limits feasibility\n        {'weights': [6, 6, 6], 'colors': ['green', 'green', 'green'], 'T': 18, 'k': 2},\n        # Test Case 4: Unreachable target due to weights\n        {'weights': [2, 4, 6], 'colors': ['r', 'g', 'b'], 'T': 5, 'k': 2},\n        # Test Case 5: Multiple solutions, choose lexicographically smallest\n        {'weights': [1, 1, 2, 2, 3, 3], 'colors': ['A', 'A', 'B', 'B', 'A', 'B'], 'T': 6, 'k': 2},\n        # Test Case 6: Edge case with k=0 and trivial target\n        {'weights': [5, 3], 'colors': ['x', 'y'], 'T': 0, 'k': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = ConstrainedSubsetSumSolver(case['weights'], case['colors'], case['T'], case['k'])\n        result = solver.solve()\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[0,1],[0,2],[]]\n    formatted_results = []\n    for res in results:\n        res_str = f\"[{','.join(map(str, res))}]\"\n        formatted_results.append(res_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3212780"}, {"introduction": "在掌握了基础的回溯模式后，下一个挑战是如何优化算法以应对更复杂的搜索空间。这个问题 [@problem_id:3212818] 提出了一个数字划分任务，其目标是最小化子集和的极差。一个朴素的回溯搜索会因巨大的状态空间而效率低下，因此本练习的重点是引入关键的优化技巧：利用启发式策略（如排序）尽早发现优质解，并学习如何通过“对称性破除”来避免大量重复计算。", "problem": "给定一个由非负整数组成的有限多重集，表示为序列 $\\{a_1,a_2,\\dots,a_n\\}$，以及一个整数 $k$，$1 \\le k \\le n$。一个有效的解决方案是，将所有元素划分为恰好 $k$ 个非空、两两不相交的子集，其并集为整个多重集。设子集和为 $s_1,s_2,\\dots,s_k$。目标是最小化极差 $R = \\max_{1 \\le j \\le k} s_j - \\min_{1 \\le j \\le k} s_j$。任务是设计并实现一个程序，该程序使用带有原则性剪枝和对称性约减的回溯法框架，从状态空间树搜索和可行分配约束的基本定义出发，计算 $R$ 的最小可能值。你的程序不得读取任何输入；相反，它必须解决以下测试套件，并生成一个单一的聚合输出。\n\n定义和约束：\n- 多重集元素 $\\{a_1,\\dots,a_n\\}$ 是非负整数，且 $1 \\le k \\le n$。\n- 一个划分为 $k$ 个子集的划分是有效的，当且仅当每个子集都非空，且子集之间两两不相交，其并集等于原始多重集。\n- 对于前 $i$ 个元素的任何部分分配，设当前子集和为向量 $(t_1,\\dots,t_k)$；设待分配的剩余总和为 $T_{\\mathrm{rem}} = \\sum_{j=i+1}^n a_j$。只有当你可以从某个回溯节点推导出其可达成的最佳目标值的严格下界，并且该下界不优于已找到的最佳解时，才可对该节点进行剪枝。\n\n测试套件：\n- 测试用例 1：$S = \\{3,1,4,2,2\\}$，$k = 2$。\n- 测试用例 2：$S = \\{5,7,9\\}$，$k = 1$。\n- 测试用例 3：$S = \\{10,10,9,1\\}$，$k = 3$。\n- 测试用例 4：$S = \\{8,1,2,3\\}$，$k = 3$。\n- 测试用例 5：$S = \\{1,2,3,4\\}$，$k = 4$。\n\n你的程序必须为每个测试用例计算可达成的最小极差 $R$（作为一个整数）。最终输出必须是一行，包含一个逗号分隔的列表，其中包含按上述测试用例顺序排列的5个结果，并用方括号括起来。例如，如果结果是 $v_1,v_2,v_3,v_4,v_5$，程序必须以“[v1,v2,v3,v4,v5]”的精确格式打印一行。", "solution": "所提出的问题是一个有效的组合优化问题，其正式名称为多路数字划分问题，旨在将一个数字多重集划分为固定数量的子集，以最小化一个特定的目标函数，在本例中即为子集和的极差。该问题是良定义的，在计算机科学和离散数学中有科学依据，并且所有给出的定义和约束都是自洽和一致的。\n\n任务是找到一个将包含 $n$ 个非负整数的多重集 $S = \\{a_1, a_2, \\dots, a_n\\}$ 划分为恰好 $k$ 个非空子集的方法，使得这些子集和的极差最小化。设这些子集为 $S_1, S_2, \\dots, S_k$。它们的和为 $s_j = \\sum_{a \\in S_j} a$。目标是最小化 $R = \\max_{j} s_j - \\min_{j} s_j$。这个问题是NP-hard的，意味着对于一般情况，没有已知的算法可以在多项式时间内解决它。回溯算法提供了一种系统性的方法来探索所有可能划分的整个搜索空间，并保证能找到最优解。为了使这种方法在给定的测试用例上计算上可行，我们必须结合原则性的剪枝和对称性约减技术。\n\n解决方案的核心是一个递归回溯函数，它探索部分分配的状态空间树。此搜索中的一个状态由 $(i, \\vec{t})$ 定义，其中 $i$ 是多重集 $S$ 中下一个待分配元素的索引，而 $\\vec{t} = (t_1, t_2, \\dots, t_k)$ 是一个表示 $k$ 个子集当前和的向量。\n\n算法流程如下：\n\n1.  **初始化与启发式策略**：首先将多重集 $S$ 按降序排序。这是一种强大的启发式策略。首先放置较大的元素往往会较早地在子集和中产生较大的不平衡，这使得算法能够快速建立一个关于最小极差的合理好的上界。一个更紧的上界能够实现更积极的搜索空间剪枝。到目前为止找到的最小极差 $R_{\\text{best}}$ 被初始化为一个较大的值，例如所有元素的总和 $\\sum_{i=1}^n a_i$。\n\n2.  **递归状态探索**：回溯函数，例如 `backtrack(i, t)`，工作方式如下：\n    *   **基准情形**：当索引 $i$ 达到 $n$ 时，所有元素都已被分配到一个子集中。这对应于搜索树中的一个叶节点，并代表一个完整的划分。计算此划分的极差 $R = \\max(\\vec{t}) - \\min(\\vec{t})$。如果这个极差优于目前为止找到的最佳极差 ($R  R_{\\text{best}}$)，则将 $R_{\\text{best}}$ 更新为 $R$。\n    *   **递归步骤**：对于当前索引 $i$ 处的元素 $a_i$，函数遍历 $k$ 个子集中的每一个。对于每个子集 $j \\in \\{1, \\dots, k\\}$，它通过更新其和 $t'_j = t_j + a_i$ 来尝试将 $a_i$ 放入子集 $j$。然后它进行递归调用 `backtrack(i+1, t')` 来分配下一个元素。递归调用返回后，它必须通过恢复和 $t_j = t'_j - a_i$ 来“撤销”放置操作，以探索元素 $a_i$ 的其他可能性。\n\n3.  **剪枝（定界）**：回溯法的效率取决于其“剪枝”那些不可能产生比当前最优解更好的解的子树的能力。在任何节点 $(i, \\vec{t})$，我们可以计算部分和的当前极差 $R_{\\text{current}} = \\max(\\vec{t}) - \\min(\\vec{t})$。由于所有元素 $a_i$ 都是非负的，随着更多元素的加入，子集的和只能增加或保持不变。因此，随着我们深入搜索树，和的极差是一个非递减函数。这给了我们一个严格的下界：从当前节点派生的任何完整划分的最终极差将至少为 $R_{\\text{current}}$。因此，如果在任何时候 $R_{\\text{current}} \\ge R_{\\text{best}}$，我们可以立即剪掉当前分支，因为它不可能产生更好的解。\n\n4.  **对称性约减**：这 $k$ 个子集是不可区分的。例如，对于元素 $\\{a, b\\}$ 和 $k=2$，划分 $\\{\\{a\\}, \\{b\\}\\}$ 与 $\\{\\{b\\}, \\{a\\}\\}$ 是相同的。探索这两种情况是多余的。为了消除这种对称状态，我们可以对子集的形成方式施加一个任意的排序约束。一个标准方法是规定一个新元素只能被放入*第一个*空子集中。在我们的状态表示中，子集被索引为 $j=1, \\dots, k$，如果子集 $1, \\dots, m$ 非空（其和 $t_j > 0$）而子集 $m+1$ 为空（$t_{m+1} = 0$），我们只考虑将当前元素 $a_i$ 放入子集 $1, \\dots, m, m+1$ 中的一个。这是通过在从将一个元素放入先前为空的子集后回溯时立即中断对子集的循环来实现的。也就是说，如果在将 $a_i$ 放入子集 $j$（其中 $t_j$ 先前为 $0$）后调用 `backtrack`，我们就不再继续尝试将 $a_i$ 放入子集 $j+1, \\dots, k$。这确保了只有在子集 $1, \\dots, j-1$ 已经被填充的情况下，子集 $j$ 才会被填充，从而有效地打破了对称性。在 $k \\le n$ 的情况下，该策略还隐式地满足了问题约束，即在叶节点处找到的任何有效最终划分中，所有 $k$ 个子集都必须是非空的。\n\n通过结合这些原则——一个由回溯法构建的递归搜索、降序排序启发式策略、下界剪枝和对称性约减——我们构建了一个能够正确且高效地找到给定划分问题的最小极差的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass PartitionSolver:\n    \"\"\"\n    Solves the k-partition problem to minimize the range of subset sums\n    using a backtracking algorithm with pruning and symmetry reduction.\n    \"\"\"\n    def __init__(self, s, k):\n        # Sort the multiset in descending order as a heuristic to find good\n        # solutions early and improve pruning effectiveness.\n        self.s = sorted(s, reverse=True)\n        self.k = k\n        self.n = len(self.s)\n        # Initialize the best-found range to a loose upper bound (the total sum).\n        self.min_range = sum(self.s)\n\n    def find_min_range(self):\n        \"\"\"\n        Public method to initiate the search for the minimal range.\n        Handles trivial cases and starts the backtracking search.\n        \"\"\"\n        # If there's only one subset, the range is always 0.\n        if self.k == 1:\n            return 0\n        \n        # This condition is guaranteed not to occur by the problem statement,\n        # but is good practice for a general solver.\n        if self.k > self.n:\n            # It's impossible to have k non-empty subsets.\n            return -1  # Or raise an error\n\n        # subset_sums[j] will store the sum of elements in the j-th subset.\n        subset_sums = np.zeros(self.k, dtype=int)\n        \n        # Start the recursive search from the first element (index 0).\n        self.backtrack(0, subset_sums)\n        \n        return self.min_range\n\n    def backtrack(self, element_index, subset_sums):\n        \"\"\"\n        The recursive backtracking function.\n        \n        Args:\n            element_index: The index of the current element in self.s to be placed.\n            subset_sums: A numpy array of the current sums of the k subsets.\n        \"\"\"\n        # --- Pruning Step ---\n        # Calculate the current range of sums.\n        current_range = np.max(subset_sums) - np.min(subset_sums)\n        \n        # If the current range is already worse than or equal to the best one found so\n        # far, this path cannot lead to a better solution. Prune the search here.\n        if current_range >= self.min_range:\n            return\n\n        # --- Base Case ---\n        # If all elements have been placed, we have a complete partition.\n        if element_index == self.n:\n            # The current_range is the final range for this partition.\n            # Update the global minimum if this partition is better.\n            self.min_range = min(self.min_range, current_range)\n            return\n\n        # --- Recursive Step ---\n        current_element = self.s[element_index]\n        \n        # Try placing the current element in each of the k subsets.\n        for i in range(self.k):\n            # Place the element.\n            subset_sums[i] += current_element\n            \n            # Recur for the next element.\n            self.backtrack(element_index + 1, subset_sums)\n            \n            # Backtrack: remove the element to explore other possibilities.\n            subset_sums[i] -= current_element\n            \n            # --- Symmetry Reduction ---\n            # If the subset was empty before we added the element, it means we have\n            # just explored the branch where we start a new subset. To avoid\n            # symmetric solutions, we do not need to try starting another new\n            # subset with this same element. We enforce an implicit order on filling\n            # empty subsets.\n            if subset_sums[i] == 0:\n                break\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver for each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    test_cases = [\n        {'S': [3, 1, 4, 2, 2], 'k': 2},\n        {'S': [5, 7, 9], 'k': 1},\n        {'S': [10, 10, 9, 1], 'k': 3},\n        {'S': [8, 1, 2, 3], 'k': 3},\n        {'S': [1, 2, 3, 4], 'k': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        s_list = case['S']\n        k_val = case['k']\n        solver = PartitionSolver(s_list, k_val)\n        result = solver.find_min_range()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3212818"}, {"introduction": "回溯框架不仅能用于直接求解问题，还可以作为模块化工具嵌入到更宏大的算法设计中。这个问题 [@problem_id:3212854] 挑战我们去处理“过度约束”的系统，目标是识别并移除最少的约束使其变得可解。在这里，回溯求解器本身扮演了一个“检查器”的角色，被一个更高层次的搜索过程反复调用，这充分展示了如何将回溯思想分层应用，以解决复杂的元问题（meta-problem）。", "problem": "给定您若干个有限的离散约束满足问题（CSP）实例。每个实例由一个有限的变量集、每个变量的一个有限定义域以及一个有限的约束集组成，其中每个约束是变量子集上的一个关系。一个约束满足问题（CSP）由一个三元组 $(V, \\{D_v\\}_{v \\in V}, \\{C_i\\}_{i=1}^m)$ 定义，其中 $V$ 是变量集，$D_v$ 是变量 $v \\in V$ 的有限定义域，每个约束 $C_i$ 是其作用域 $\\mathrm{scope}(C_i) \\subseteq V$ 上允许的元组集合。一个赋值 $A: V \\to \\bigcup_{v \\in V} D_v$ 是一个解，当且仅当对于每个约束 $C_i$，$A$ 在 $\\mathrm{scope}(C_i)$ 上的投影是 $C_i$ 的一个元素。\n\n您的任务是设计并实现一个程序，对每个 CSP 实例，找出需要移除的最小约束子集，使得剩余的约束至少有一个解。在所有最小基数的子集中，您必须返回约束索引（使用基于 1 的索引）的字典序最小列表。列表的字典序按常规方式定义：对于两个等长的列表 $[a_1,\\dots,a_k]$ 和 $[b_1,\\dots,b_k]$，第一个不同的元素决定了顺序；如果一个列表是另一个列表的前缀，则较短的列表在前。如果 CSP 本身是可解的，您必须返回空列表 $[]$。\n\n您必须使用回溯框架来测试移除候选子集后剩余约束的可满足性，并遵循基本定义：递归地构建一个部分赋值 $A$，并在某个约束的作用域内所有变量都被赋值后，一旦该约束被违反，就拒绝任何扩展。这是唯一允许的剪枝标准；不要使用未由 CSP 定义证明的派生捷径。\n\n对于下面的每个实例，变量、定义域和约束都用数学方式指定。约束索引是基于 1 的，并且必须在您的输出中使用。\n\n测试套件：\n- 实例 $1$：\n  - 变量：$V = \\{x, y, z\\}$。\n  - 定义域：$D_x = D_y = D_z = \\{0, 1\\}$。\n  - 约束：\n    - $C_1$：$x = y$。\n    - $C_2$：$y = z$。\n    - $C_3$：$x \\neq z$。\n- 实例 $2$：\n  - 变量：$V = \\{a, b\\}$。\n  - 定义域：$D_a = D_b = \\{1, 2, 3\\}$。\n  - 约束：\n    - $C_1$：$a  b$。\n- 实例 $3$：\n  - 变量：$V = \\{x, y\\}$。\n  - 定义域：$D_x = D_y = \\{0, 1\\}$。\n  - 约束：\n    - $C_1$：$x = 0$。\n    - $C_2$：$x = 1$。\n    - $C_3$：$y = 0$。\n    - $C_4$：$y = 1$。\n- 实例 $4$：\n  - 变量：$V = \\{p, q, r\\}$。\n  - 定义域：$D_p = D_q = D_r = \\{0, 1\\}$。\n  - 约束：\n    - $C_1$：$p + q = 1$。\n    - $C_2$：$q + r = 1$。\n    - $C_3$：$p = r$。\n    - $C_4$：$p + q + r = 3$。\n\n答案规范：\n- 对于每个实例，程序必须输出要移除的约束的基于 1 的索引列表，该列表应具有最小的可能基数，并在其中选择字典序最小的一个。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个实例的答案本身也格式化为列表。例如，如果有 $k$ 个实例，输出形式应为 $[[i_{1,1},\\dots,i_{1,t_1}],[i_{2,1},\\dots,i_{2,t_2}],\\dots,[i_{k,1},\\dots,i_{k,t_k}]]$，不含空格。对于给定的 4 个实例的测试套件，您的程序必须输出一个形式为 $[[\\dots],[\\dots],[\\dots],[\\dots]]$ 的单行，其中包含四个列表。\n\n所有输出都是无单位的整数及其列表。程序必须是自包含的，并且不得读取输入。", "solution": "该问题要求我们为若干个有限离散约束满足问题（CSP）实例，找到必须移除的最小约束子集，以使问题变得可满足。如果存在多个具有最小基数的此类子集，我们需要选择其基于 1 的索引构成字典序最小列表的那个。\n\n约束满足问题由一个三元组 $(V, \\{D_v\\}_{v \\in V}, \\{C_i\\}_{i=1}^m)$ 正式定义，其中 $V$ 是一个有限变量集，$\\{D_v\\}_{v \\in V}$ 是每个变量的有限定义域集，而 $\\{C_i\\}_{i=1}^m$ 是一个约束集。每个约束 $C_i$ 在一个称为其作用域 $\\mathrm{scope}(C_i)$ 的变量子集上指定一个关系。一个解是一个从各自定义域中为变量赋上值的完整赋值，该赋值能同时满足所有约束。\n\n该任务本质上是一个搜索问题。我们在寻找一个要移除的最优约束子集。搜索空间是原始约束集 $\\{C_i\\}_{i=1}^m$ 的幂集。最优性标准按优先级顺序为：\n$1$. 移除子集的基数必须最小化。\n$2$. 移除约束的基于 1 的已排序索引列表必须是字典序最小的。\n\n这种结构提示了一种特定的搜索策略。我们可以对要移除的约束数量进行迭代，称这个数量为 $k$，从 $k=0$ 开始向上递增。对于每个 $k$ 值，我们生成 $k$ 个约束索引的所有可能组合。为了满足字典序要求，必须按字典序生成和测试这些组合。第一个使得剩余 CSP 被发现是可满足的被移除约束的组合即构成解。由于我们从最小的 $k$ 开始，并按字典序检查组合，这个过程保证能找到正确答案。\n\n总体算法如下：\n$1$. 对于一个给定的有 $m$ 个约束的 CSP 实例，设约束索引为 $\\{1, 2, \\dots, m\\}$。\n$2$. 对于从 $0$ 到 $m$ 的 $k$：\n    $a$. 从 $\\{1, 2, \\dots, m\\}$ 中生成 $k$ 个索引的所有组合。用于生成组合的标准库函数通常会按字典序生成它们，这正是所要求的。\n    $b$. 对于每个要移除的索引组合：\n        $i$. 构成一个新的 CSP，包含所有原始变量、定义域和未被标记为移除的约束子集。\n        $ii$. 检查这个新的 CSP 是否可满足。\n        $iii$. 如果它是可满足的，那么当前索引组合就是最小的、字典序最小的解。返回此索引列表并终止对此实例的搜索。\n\n这个过程的核心是可满足性检查。问题强制要求使用回溯算法。回溯求解器系统地探索可能赋值的空间。它通过逐个为变量赋值来增量地构建解。\n\n回溯过程实现为一个递归函数：\n- **状态**：递归维护一个部分赋值，这是一个从变量子集到其定义域值的映射。\n- **基本情况**：如果赋值是完整的（即 $V$ 中的所有变量都已赋值），则找到了一个解，CSP 是可满足的。递归返回 `true`。\n- **递归步骤**：\n    $1$. 选择一个未赋值的变量 $v \\in V$。\n    $2$. 遍历定义域 $D_v$ 中的每个值 $d$。\n    $3$. 试探性地将赋值 $v \\to d$ 添加到当前的部分赋值中。\n    $4$. **一致性检查**：验证这个新的部分赋值是否与所有活动约束一致。根据问题规范，此检查仅对那些作用域被当前部分赋值完全覆盖的约束执行。如果任何此类约束被违反，当前路径就是不一致的，我们剪掉搜索树的这个分支。\n    $5$. 如果部分赋值是一致的，就用扩展后的赋值递归调用回溯函数。如果递归调用返回 `true`，意味着在该路径下找到了一个完整的解，所以我们向上传播 `true`。\n- **回溯**：如果对 $D_v$ 中所有值的循环完成而没有找到解，意味着在给定先前赋值的情况下，不存在对 $v$ 的有效赋值。我们通过移除对 $v$ 的赋值（如果已添加）来进行回溯，并返回 `false`。\n\n对求解器的初始调用使用空赋值。如果在探索了所有可能性后，顶层调用返回 `false`，则 CSP 是不可满足的。\n\n这种结合外部循环搜索最优约束子集和内部回溯求解器检查可满足性的方法，能够根据所有指定要求正确且完整地解决问题。\n\n让我们简要分析一下提供的实例：\n- **实例 1**：变量 $\\{x, y, z\\}$，定义域 $\\{0, 1\\}$。约束：$C_1: x = y$, $C_2: y = z$, $C_3: x \\neq z$。约束 $C_1$ 和 $C_2$ 意味着 $x=z$，这与 $C_3$ 矛盾。完整的集合是不可满足的。移除任何单个约束都可以解决这个矛盾。移除 $C_1$（索引 1）是 $k=1$ 时测试的第一个选项，使其成为字典序最小的解：$[1]$。\n\n- **实例 2**：变量 $\\{a, b\\}$，定义域 $\\{1, 2, 3\\}$。约束：$C_1: a  b$。这个 CSP 本身是可满足的（例如 $a=1, b=2$）。因此，不需要移除任何约束。解是空列表 $[]$。\n\n- **实例 3**：变量 $\\{x, y\\}$，定义域 $\\{0, 1\\}$。约束：$C_1: x = 0$, $C_2: x = 1$, $C_3: y = 0$, $C_4: y = 1$。这里有两个独立的矛盾：变量 $x$ 的 $C_1$ 与 $C_2$ 矛盾，变量 $y$ 的 $C_3$ 与 $C_4$ 矛盾。我们需要从每对矛盾约束中至少移除一个，所以最小移除数量是 $k=2$。能够解决这两个矛盾的字典序最小的索引对是 $(1, 3)$。移除 $C_1$ 和 $C_3$ 后剩下 $x=1$ 和 $y=1$，这是可满足的。解是 $[1, 3]$。\n\n- **实例 4**：变量 $\\{p, q, r\\}$，定义域 $\\{0, 1\\}$。约束：$C_1: p + q = 1, C_2: q + r = 1, C_3: p = r, C_4: p + q + r = 3$。约束 $C_4$ 仅能被 $(p,q,r)=(1,1,1)$ 满足。然而，这个赋值违反了 $C_1$（$1+1=2 \\neq 1$）和 $C_2$（$1+1=2 \\neq 1$）。反过来看，约束 $\\{C_1, C_2, C_3\\}$ 可被 $(0,1,0)$ 和 $(1,0,1)$ 满足，但这两种情况都不能满足 $C_4$。因此，该系统是不可满足的。移除 $C_4$ 使得剩余的系统 $\\{C_1, C_2, C_3\\}$ 变得可满足。由于这是一个 $k=1$ 的解，并且单独移除 $C_1, C_2,$ 或 $C_3$ 并不能使系统可满足，因此移除 $C_4$ 是最优解。答案是 $[4]$。", "answer": "```python\nimport itertools\n\nclass Constraint:\n    \"\"\"Represents a constraint in a CSP.\"\"\"\n    def __init__(self, scope, check_func, index):\n        \"\"\"\n        Initializes a Constraint.\n\n        Args:\n            scope (tuple): A tuple of variable names in the constraint's scope.\n            check_func (callable): A function that returns True if the constraint is satisfied.\n            index (int): The 1-based index of the constraint.\n        \"\"\"\n        self.scope = scope\n        self.check_func = check_func\n        self.index = index\n\ndef is_consistent(assignment, constraints):\n    \"\"\"\n    Checks if a partial assignment is consistent with the given constraints.\n    A constraint is checked only if all variables in its scope are assigned.\n    \"\"\"\n    for const in constraints:\n        if all(var in assignment for var in const.scope):\n            args = [assignment[var] for var in const.scope]\n            if not const.check_func(*args):\n                return False\n    return True\n\ndef backtrack_solver(assignment, unassigned_vars, domains, constraints):\n    \"\"\"\n    Recursively solves the CSP using backtracking.\n    \"\"\"\n    if not unassigned_vars:\n        return True  # All variables are assigned, a solution is found.\n\n    var_to_assign = unassigned_vars[0]\n    remaining_vars = unassigned_vars[1:]\n\n    for value in domains[var_to_assign]:\n        assignment[var_to_assign] = value\n        if is_consistent(assignment, constraints):\n            if backtrack_solver(assignment, remaining_vars, domains, constraints):\n                return True\n    \n    # Backtrack by removing the assignment\n    del assignment[var_to_assign]\n    \n    return False\n\ndef check_satisfiability(variables, domains, constraints):\n    \"\"\"\n    Wrapper function to initiate the backtracking solver.\n    \"\"\"\n    return backtrack_solver({}, list(variables), domains, constraints)\n\ndef solve_instance(instance):\n    \"\"\"\n    Solves a single CSP instance by finding the minimal, lexicographically\n    smallest set of constraints to remove for satisfiability.\n    \"\"\"\n    variables = instance['variables']\n    domains = instance['domains']\n    all_constraints = instance['constraints']\n    num_constraints = len(all_constraints)\n    \n    constraint_indices = range(1, num_constraints + 1)\n\n    for k in range(num_constraints + 1):\n        for removed_indices_tuple in itertools.combinations(constraint_indices, k):\n            removed_indices_set = set(removed_indices_tuple)\n            active_constraints = [c for c in all_constraints if c.index not in removed_indices_set]\n            \n            if check_satisfiability(variables, domains, active_constraints):\n                return list(removed_indices_tuple)\n    \n    # This part should not be reached as removing all constraints always yields a solution.\n    return []\n\ndef solve():\n    \"\"\"\n    Defines all test cases, solves them, and prints the results in the specified format.\n    \"\"\"\n    # Instance 1\n    instance1 = {\n        'variables': ['x', 'y', 'z'],\n        'domains': {'x': {0, 1}, 'y': {0, 1}, 'z': {0, 1}},\n        'constraints': [\n            Constraint(scope=('x', 'y'), check_func=lambda x, y: x == y, index=1),\n            Constraint(scope=('y', 'z'), check_func=lambda y, z: y == z, index=2),\n            Constraint(scope=('x', 'z'), check_func=lambda x, z: x != z, index=3),\n        ]\n    }\n\n    # Instance 2\n    instance2 = {\n        'variables': ['a', 'b'],\n        'domains': {'a': {1, 2, 3}, 'b': {1, 2, 3}},\n        'constraints': [\n            Constraint(scope=('a', 'b'), check_func=lambda a, b: a  b, index=1),\n        ]\n    }\n\n    # Instance 3\n    instance3 = {\n        'variables': ['x', 'y'],\n        'domains': {'x': {0, 1}, 'y': {0, 1}},\n        'constraints': [\n            Constraint(scope=('x',), check_func=lambda x: x == 0, index=1),\n            Constraint(scope=('x',), check_func=lambda x: x == 1, index=2),\n            Constraint(scope=('y',), check_func=lambda y: y == 0, index=3),\n            Constraint(scope=('y',), check_func=lambda y: y == 1, index=4),\n        ]\n    }\n\n    # Instance 4\n    instance4 = {\n        'variables': ['p', 'q', 'r'],\n        'domains': {'p': {0, 1}, 'q': {0, 1}, 'r': {0, 1}},\n        'constraints': [\n            Constraint(scope=('p', 'q'), check_func=lambda p, q: p + q == 1, index=1),\n            Constraint(scope=('q', 'r'), check_func=lambda q, r: q + r == 1, index=2),\n            Constraint(scope=('p', 'r'), check_func=lambda p, r: p == r, index=3),\n            Constraint(scope=('p', 'q', 'r'), check_func=lambda p, q, r: p + q + r == 3, index=4),\n        ]\n    }\n    \n    test_cases = [instance1, instance2, instance3, instance4]\n    \n    results = [solve_instance(case) for case in test_cases]\n    \n    # Format the final output string\n    results_as_strings = [str(res).replace(\" \", \"\") for res in results]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n\n```", "id": "3212854"}]}