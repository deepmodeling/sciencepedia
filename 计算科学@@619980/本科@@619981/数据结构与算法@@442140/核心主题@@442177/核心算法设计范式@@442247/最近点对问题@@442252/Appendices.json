{"hands_on_practices": [{"introduction": "我们从一个简化版的问题开始，将最近点对问题置于一维空间中。这个练习旨在让你专注于分治算法的递归结构，而不必处理高维空间中复杂的几何问题。通过将查找过程与归并排序相结合 [@problem_id:3252361]，你将亲身体会到，在一维排序数组中，最近点对必然是相邻的，并学习如何利用这一特性来高效地“合并”子问题的解。", "problem": "给定一个一维实数轴上的有限实值点列表。对于一个大小为 $n$ 的列表 $A$，定义两点 $x$ 和 $y$ 之间的距离为 $|x - y|$，并定义最近点对距离为 $d^{\\star} = \\min_{i \\ne j} |A_i - A_j|$（当 $n \\ge 2$ 时）。如果 $n  2$，则定义最近点对距离为 $+\\infty$。请设计并实现一个程序，使用归并排序的分治结构来计算最近点对距离，并达到 $\\mathcal{O}(n \\log n)$ 的时间复杂度。你不得调用任何内置的排序过程；相反，算法必须显式地执行一个基于合并的分治递归，该递归同时进行排序并计算最近点对距离。\n\n对于每个测试用例，你的程序必须返回一个非负实数（即最近点对距离），或者在定义指定的情况下返回 $+\\infty$。此问题不涉及物理单位。实数上的序关系必须被视为常规的全序关系。\n\n要求的测试套件：\n- 情况 1：输入 $[7,1,5,9,3,2]$。\n- 情况 2：输入 $[1,2,4,8,16]$。\n- 情况 3：输入 $[10,8,6,4,2,0]$。\n- 情况 4：输入 $[5,5,5,5]$。\n- 情况 5：输入 $[-10,-3,0,2,7]$。\n- 情况 6：输入 $[42]$。\n- 情况 7：输入 $[]$。\n- 情况 8：输入 $[-1000000,1000000,-999999]$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,\\dots]$），结果的顺序与测试套件的顺序相同。每个结果必须是一个实数（将 $+\\infty$ 打印为浮点无穷大值）。", "solution": "问题要求设计并实现一个算法，用于在一维点列表 $A$ 中找到最近点对距离。两点 $x$ 和 $y$ 之间的距离定义为 $|x - y|$。对于一个大小为 $n$ 的列表，最近点对距离 $d^{\\star}$ 定义为 $d^{\\star} = \\min_{i \\ne j} |A_i - A_j|$（当 $n \\ge 2$ 时），而当 $n  2$ 时，$d^{\\star} = +\\infty$。该算法必须遵循一种基于归并排序结构的分治策略，达到 $\\mathcal{O}(n \\log n)$ 的时间复杂度，并且实现时不得使用任何内置排序函数。\n\n问题陈述是有效的。这是一个定义明确的计算问题，它基于标准的数学概念（实数、绝对距离、最小值）和算法理论（分治、时间复杂度）。所有术语都是客观且精确定义的，且约束条件是自洽的。\n\n解决这个问题的核心原则是将寻找最小距离的过程整合到归并排序算法的递归结构中。一个朴素的暴力方法会比较每一对点，导致时间复杂度为 $\\mathcal{O}(n^2)$，这太慢了。我们将要建立一个更高效的方法，它利用排序过程来减少所需的比较次数。\n\n对于一维情况，一个关键的数学洞见可以显著简化问题：如果一个点列表是排序的，那么最近的点对在排序后的列表中必定是相邻的。这可以用反证法来证明。假设最近的点对 $(x, y)$（其中 $x  y$）在排序后的列表中不相邻。这意味着至少存在另一个点 $z$ 使得 $x  z  y$。距离 $|z - x| = z - x$ 必然小于距离 $|y - x| = y - x$。这与 $(x, y)$ 是最近点对的假设相矛盾。因此，最近点对必须是相邻的。\n\n这个洞见启发了一个算法：首先在 $\\mathcal{O}(n \\log n)$ 时间内对列表 $A$ 进行排序，然后执行一次线性扫描（$\\mathcal{O}(n)$ 时间）来找到相邻元素之间的最小距离。然而，问题陈述要求一个集成算法，其中递归**同时进行排序和计算**距离。我们可以设计一个递归函数来完成这个任务，该函数在每一步都返回排序后的列表以及在该列表中找到的最小距离。\n\n让我们定义一个递归函数 $\\text{RecursiveClosestPair}(A)$，它接受一个大小为 $n$ 的列表 $A$，并返回一个元组 $(A_{\\text{sorted}}, d)$，其中 $A_{\\text{sorted}}$ 是 $A$ 的排序版本，而 $d$ 是 $A$ 中元素间的最近点对距离。\n\n该算法的结构遵循经典的分治范式：\n\n1.  **基准情形**：如果列表 $A$ 的元素少于 2 个（即 $n=0$ 或 $n=1$），则无法形成点对。根据问题定义，最近点对距离为 $+\\infty$。列表本身已经是有序的。因此，当 $n  2$ 时，函数返回 $(A, +\\infty)$。\n\n2.  **分解**：如果 $n \\ge 2$，列表 $A$ 被划分为大小约相等的两半，一个左子列表 $L$ 和一个右子列表 $R$。我们可以选择中点 $m = \\lfloor n/2 \\rfloor$，使得 $L = A[0..m-1]$ 且 $R = A[m..n-1]$。\n\n3.  **解决**：对两个子列表递归调用该函数：\n    *   $(L_{\\text{sorted}}, d_L) = \\text{RecursiveClosestPair}(L)$\n    *   $(R_{\\text{sorted}}, d_R) = \\text{RecursiveClosestPair}(R)$\n    在此步骤结束时，我们得到两个已排序的子列表 $L_{\\text{sorted}}$ 和 $R_{\\text{sorted}}$，以及各自子列表内部的最小距离 $d_L$ 和 $d_R$。\n\n4.  **合并**：此步骤整合来自子问题的结果，以解决列表 $A$ 的问题。\n    a.  首先，将两个已排序的子列表 $L_{\\text{sorted}}$ 和 $R_{\\text{sorted}}$ 合并成一个单一的有序列表 $A_{\\text{merged}}$。这是归并排序算法中的标准合并过程，需要 $\\mathcal{O}(n)$ 的时间。\n    b.  在此阶段，我们有了一个完整的、已排序的列表 $A_{\\text{merged}}$，其中包含原始列表 $A$ 的所有元素。根据我们之前的证明， $A$ 中元素的整体最近点对距离必定是 $A_{\\text{merged}}$ 中相邻元素之间的最小距离。我们对 $A_{\\text{merged}}$ 执行一次线性扫描来找到这个最小相邻距离，称之为 $d_{\\text{adj}}$。这次扫描也需要 $\\mathcal{O}(n)$ 的时间。\n    c.  列表 $A$ 的真正最小距离必定是左子问题中找到的距离 ($d_L$)、右子问题中找到的距离 ($d_R$) 以及通过检查新排序列表找到的最小距离 ($d_{\\text{adj}}$) 这三者中的最小值。所以，当前递归层级的结果是 $d = \\min(d_L, d_R, d_{\\text{adj}})$。\n    d.  然后，函数返回元组 $(A_{\\text{merged}}, d)$。\n\n对于初始列表 $A$ 的最终结果，是顶层调用 $\\text{RecursiveClosestPair}(A)$ 所返回元组中的距离部分。\n\n该算法的时间复杂度可以用递推关系 $T(n) = 2T(n/2) + \\mathcal{O}(n)$ 来描述。项 $2T(n/2)$ 源于对两个大小为 $n/2$ 的子问题的递归调用。$\\mathcal{O}(n)$ 项代表了在合并步骤中所做的工作，这部分工作主要由合并两个已排序子列表和随后的线性扫描所主导，这两者都与列表大小 $n$ 呈线性关系。根据主定理，这个递推关系解为 $T(n) = \\mathcal{O}(n \\log n)$，满足了问题的时间复杂度要求。\n\n这个设计正确地实现了一个基于合并的分治递归，它同时对数据进行排序并计算最近点对距离，从而满足了问题的所有约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef closest_pair_recursive(arr):\n    \"\"\"\n    Recursively sorts a list and finds the closest-pair distance within it.\n    This function explicitly follows the merge sort divide-and-conquer structure.\n\n    Args:\n        arr (list): A list of real numbers.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: The sorted version of the input list.\n            - float: The minimum distance between any two distinct points in the list.\n    \"\"\"\n    n = len(arr)\n\n    # Base case: If the list has fewer than 2 elements, the distance is defined as infinity.\n    # A list with 0 or 1 elements is trivially sorted.\n    if n  2:\n        return arr, np.inf\n\n    # Divide: Split the list into two halves.\n    mid = n // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Conquer: Recursively process the left and right halves.\n    # This yields the sorted halves and the minimum distances within each half.\n    left_sorted, d_left = closest_pair_recursive(left_half)\n    right_sorted, d_right = closest_pair_recursive(right_half)\n\n    # Combine: Merge the sorted halves and find the overall minimum distance.\n    # 1. Merge the two sorted lists `left_sorted` and `right_sorted`.\n    merged_arr = []\n    i, j = 0, 0\n    while i  len(left_sorted) and j  len(right_sorted):\n        if left_sorted[i] = right_sorted[j]:\n            merged_arr.append(left_sorted[i])\n            i += 1\n        else:\n            merged_arr.append(right_sorted[j])\n            j += 1\n    \n    # Append any remaining elements from either list.\n    merged_arr.extend(left_sorted[i:])\n    merged_arr.extend(right_sorted[j:])\n\n    # 2. Scan the newly merged and sorted list to find the minimum adjacent distance.\n    # This check implicitly covers pairs where one point was in the original left\n    # half and the other was in the right half.\n    d_adj = np.inf\n    # The loop runs only if there are at least 2 elements to compare.\n    for k in range(len(merged_arr) - 1):\n        dist = merged_arr[k+1] - merged_arr[k]\n        if dist  d_adj:\n            d_adj = dist\n\n    # 3. The minimum distance for the current list is the minimum of the distances\n    # from the left subproblem, the right subproblem, and the adjacent scan.\n    min_dist = min(d_left, d_right, d_adj)\n\n    return merged_arr, min_dist\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [7, 1, 5, 9, 3, 2],\n        [1, 2, 4, 8, 16],\n        [10, 8, 6, 4, 2, 0],\n        [5, 5, 5, 5],\n        [-10, -3, 0, 2, 7],\n        [42],\n        [],\n        [-1000000, 1000000, -999999],\n    ]\n\n    results = []\n    for case in test_cases:\n        # For lists with fewer than 2 elements, the distance is defined as +inf.\n        # This handles the base case at the top level, consistent with the recursion.\n        if len(case)  2:\n            results.append(np.inf)\n        else:\n            # The recursive function returns both the sorted list and the min distance.\n            # We only need the distance for the final result.\n            _, distance = closest_pair_recursive(case)\n            results.append(float(distance))\n\n    # Final print statement in the exact required format.\n    # The representation of np.inf as a string 'inf' is standard.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3252361"}, {"introduction": "从一维成功过渡后，我们现在升维到更经典的二维情况，这是通往三维问题的关键桥梁。虽然分治的整体框架（划分与递归）保持不变，但“合并”步骤变得不再平凡。此练习的核心是思考“中间带”问题 [@problem_id:3205365]：在划分线的两侧宽度为 $2\\delta$ 的区域内，如何在线性时间 $O(n)$ 内找到可能存在的更近点对，从而避免退化为暴力搜索？解决这个子问题是掌握整个算法的关键。", "problem": "给定一个二维欧几里得平面上的有限点集。设 $P = \\{p_i\\}_{i=1}^n$，其中每个点 $p_i = (x_i,y_i) \\in \\mathbb{R}^2$。任务是设计并实现一个基于分治范式的算法，用以计算任意两个不同点之间的最小欧几里得距离。该算法必须从算法设计的基本定义和法则出发，旨在达到 $O(n \\log n)$ 的时间复杂度。\n\n基本基础：\n- 两点 $p=(x,y)$ 和 $q=(x',y')$ 之间的欧几里得距离定义为 $d(p,q) = \\sqrt{(x-x')^2 + (y-y')^2}$。\n- 分治算法将问题分解为子问题，递归求解，然后在 $O(n)$ 时间内合并解。\n\n你的程序必须实现以下内容：\n- 输入是固定的并嵌入在程序中。程序必须使用分治算法为每个测试用例计算最小欧几里得距离 $d^*$，该算法：\n  1. 按点的 $x$ 坐标对点进行排序。\n  2. 递归地解决左半部分和右半部分上的最近点对问题，得到距离 $\\delta_L$ 和 $\\delta_R$。\n  3. 通过考虑位于以中位数 $x$ 坐标为中心、宽度为 $2\\delta$ 的条带内的点来合并两个半区，其中 $\\delta = \\min(\\delta_L, \\delta_R)$。合并步骤必须在线性时间内完成，以保证整体 $O(n \\log n)$ 复杂度。\n\n需要明确处理的边界情况：\n- 如果两个点相同，最小距离为 $0$。\n- 如果 $n=2$，最小距离是这两点之间的距离。\n\n测试套件：\n- 测试用例 1: $[(0,0),(10,10),(10,11),(20,25),(5,6),(100,-50),(-10,12)]$\n- 测试用例 2: $[(0,0),(1,1)]$\n- 测试用例 3: $[(5,-7),(5,-7),(0,0)]$\n- 测试用例 4: $[(0,0),(1,0),(2,0),(3,0),(4,0),(5,0)]$\n- 测试用例 5: $[(0,1),(0,2),(0,3),(0,4),(0,5)]$\n- 测试用例 6: $[(-1000,500),(-999,500),(400,-800),(401,-800)]$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果必须是四舍五入到六位小数的浮点数。", "solution": "该问题要求为二维点集设计并实现一个 $O(n \\log n)$ 的分治算法来寻找最近点对。\n\n### 基于原理的设计\n\n暴力方法检查所有点对，复杂度为 $O(n^2)$，效率低下。分治策略能提供更优的解法。\n\n1.  **分解 (Divide)**：将点集 $P$ 按 $x$ 坐标中位数分为大小近似相等的两个子集 $P_L$ 和 $P_R$。\n2.  **解决 (Conquer)**：递归地找到 $P_L$ 中的最小距离 $\\delta_L$ 和 $P_R$ 中的最小距离 $\\delta_R$。\n3.  **合并 (Combine)**：令 $\\delta = \\min(\\delta_L, \\delta_R)$。我们需要检查是否存在一个跨越两个子集的点对 $(p_L, p_R)$，其距离小于 $\\delta$。\n\n为使总复杂度达到 $O(n \\log n)$，合并步骤必须在线性时间 $O(n)$ 内完成。\n\n### 详细算法与论证\n\n**1. 预处理：**\n首先根据点的 $x$ 坐标对整个点集 $P$ 进行排序，得到列表 $P_x$。此操作需 $O(n \\log n)$ 时间。\n\n**2. 递归结构：**\n递归函数 `find_closest(Px)` 在一个按 $x$ 坐标排序的点列表上操作。\n\n*   **基准情形**：如果点的数量 $n \\le 3$，则通过暴力方法计算最小距离。\n\n*   **分解与解决**：将 $P_x$ 分为 $P_L$ 和 $P_R$，并进行递归调用得到 $\\delta_L$ 和 $\\delta_R$。令 $\\delta = \\min(\\delta_L, \\delta_R)$。\n\n*   **合并步骤**：这是算法的关键。任何距离小于 $\\delta$ 的跨界点对 $(p_L, p_R)$ 必须满足 $|p_L.x - p_R.x|  \\delta$。因此，我们只需关注一个以分割线为中心、宽度为 $2\\delta$ 的垂直“条带”内的点。设 $S$ 为此条带内的点集。\n\n    对 $S$ 中的所有点对进行朴素比较仍可能效率低下。为确保合并步骤为 $O(n)$，我们需利用几何约束。经典的方法是，将条带内的点 $S$ 按 $y$ 坐标排序得到 $S_y$。然后，对 $S_y$ 中的每个点 $p$，我们只需检查其后的有限个（常数个）点。这是因为任何可能与 $p$ 形成更近点对的点 $q$，必须满足 $|p.y - q.y|  \\delta$。填充论证表明，在以 $p$ 为参考的 $\\delta \\times 2\\delta$ 矩形区域内，满足此条件的点数量有上界（约为7个）。\n\n    然而，每次在合并步骤中对条带点进行排序将导致 $O(n \\log n)$ 的合并时间，从而使总复杂度变为 $O(n(\\log n)^2)$。为了实现 $O(n)$ 的合并，可以采用更高效的技巧，例如在递归中维护 $y$ 排序的列表，或使用基于哈希的网格方法。\n\n    一个简单而高效的 $O(n)$ 合并方法是：\n    1.  **构建条带**：在线性时间内从 $P_x$ 中筛选出所有在 $2\\delta$ 条带内的点。\n    2.  **网格哈希**：将此二维条带沿 $y$ 轴划分为边长为 $\\delta$ 的单元格（一维网格）。使用哈希表（字典）来存储落入每个单元格的点，其中键为 `key = int(p.y / delta)`。\n    3.  **邻居搜索**：遍历条带中的每个点 $p$。对于每个 $p$，我们只需检查其自身所在单元格、以及相邻的两个单元格（`key-1`, `key`, `key+1`）中的点。由于填充论证，每个单元格中的点数是常数，因此每次检查也是常数时间。\n    4.  **复杂度**：构建条带、填充哈希表和检查邻居都可以在与条带中点数成正比的时间内完成，即 $O(|S|) = O(n)$。\n\n这样，总的递推关系为 $T(n) = 2T(n/2) + O(n)$，根据主定理，解为 $T(n) = O(n \\log n)$。这满足了问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef distance_2d(p1, p2):\n    \"\"\"Computes the Euclidean distance between two points in 2D space.\"\"\"\n    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef brute_force_closest_pair_2d(points):\n    \"\"\"Finds the minimum distance in a small set of points by brute force.\"\"\"\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            d = distance_2d(points[i], points[j])\n            if d  min_dist:\n                min_dist = d\n    return min_dist\n\ndef closest_pair_recursive_2d(Px):\n    \"\"\"\n    The recursive core of the divide-and-conquer algorithm for 2D points.\n    Px is a list of points sorted by x-coordinate.\n    \"\"\"\n    n = len(Px)\n    if n = 3:\n        if n  2:\n            return float('inf')\n        return brute_force_closest_pair_2d(Px)\n\n    mid = n // 2\n    median_point = Px[mid]\n    \n    d_left = closest_pair_recursive_2d(Px[:mid])\n    d_right = closest_pair_recursive_2d(Px[mid:])\n    \n    delta = min(d_left, d_right)\n\n    if delta == 0:\n        return 0.0\n\n    strip_points = [p for p in Px if abs(p[0] - median_point[0])  delta]\n    \n    # Grid hashing for O(n) combine step\n    grid = {}\n    cell_size = delta\n    min_dist_strip = delta\n    \n    for p in strip_points:\n        key = int(p[1] / cell_size)\n        \n        # Check neighboring cells\n        for dk in range(-1, 2):\n            check_key = key + dk\n            if check_key in grid:\n                for neighbor in grid[check_key]:\n                    d = distance_2d(p, neighbor)\n                    if d  min_dist_strip:\n                        min_dist_strip = d\n        \n        if key not in grid:\n            grid[key] = []\n        grid[key].append(p)\n        \n    return min_dist_strip\n\ndef solve_closest_pair_2d(points):\n    \"\"\"Main function to initiate the 2D closest pair algorithm.\"\"\"\n    sorted_points = sorted(list(points))\n    return closest_pair_recursive_2d(sorted_points)\n\ndef solve():\n    test_cases = [\n        [(0,0),(10,10),(10,11),(20,25),(5,6),(100,-50),(-10,12)],\n        [(0,0),(1,1)],\n        [(5,-7),(5,-7),(0,0)],\n        [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0)],\n        [(0,1),(0,2),(0,3),(0,4),(0,5)],\n        [(-1000,500),(-999,500),(400,-800),(401,-800)]\n    ]\n    \n    results = []\n    for case in test_cases:\n        if len(case)  2:\n            result = float('inf')\n        else:\n            result = solve_closest_pair_2d(case)\n        results.append(f\"{result:.6f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3205365"}, {"introduction": "最后的这项实践将挑战你解决完整的三维最近点对问题。它综合了前两个练习的要点：你需要应用分治的递归思想，并将在二维空间中思考的“中间带”高效处理策略推广到三维。这个练习 [@problem_id:3205365] 旨在通过一个完整的实现，巩固你对该算法在通用维度下保持 $O(n \\log n)$ 复杂度的核心几何约束和优化技巧的理解。", "problem": "给定三维欧几里得空间中的一个有限点集。设 $P = \\{p_i\\}_{i=1}^n$，其中每个 $p_i = (x_i,y_i,z_i) \\in \\mathbb{R}^3$。任务是设计并实现一个基于分治范式的算法，以计算任意两个不同点之间的最小欧几里得距离。该算法必须从数据结构和算法中适用于算法设计的基本定义和法则出发，包括欧几里得度量性质、递归、渐近复杂度和问题分解。唯一允许的操作是那些可从这些基础推导出来的操作。该算法在科学上必须是合理的，并完全基于这些基础进行论证，而不是通过捷径公式或临时提示。对于每个测试用例，输出应为一个数值，四舍五入到六位小数，不需要物理单位。\n\n基本基础：\n- 两点 $p=(x,y,z)$ 和 $q=(x',y',z')$ 之间的欧几里得距离定义为 $$d(p,q) = \\sqrt{(x-x')^2 + (y-y')^2 + (z-z')^2}.$$ 这源于$\\mathbb{R}^3$上内积诱导的范数以及勾股定理。\n- 分治范式将一个包含 $n$ 个元素的问题分解为大约包含 $n/2$ 个元素的子问题，递归地解决它们，然后在必须被证明为 $O(n)$ 的时间内合并它们的解，以达到 $O(n \\log n)$ 的目标复杂度。\n- 渐近复杂度使用标准的 Landau 符号度量，其中 $O(\\cdot)$ 表示一个在常数因子内的上界。\n\n你的程序必须实现以下内容：\n- 输入是固定的并嵌入在程序中。程序必须使用分治算法为每个测试用例计算最小欧几里得距离 $d^*$，该算法：\n  1. 按点的 $x$ 坐标对点进行排序。\n  2. 递归地解决左半部分和右半部分上的最近点对问题，以获得距离 $\\delta_L$ 和 $\\delta_R$。\n  3. 通过考虑位于以中位数 $x$ 平面为中心、宽度为 $2\\delta$ 的条带内的点来合并两个半区，其中 $\\delta = \\min(\\delta_L,\\delta_R)$，并且仅使用第一性原理的几何约束来限制候选对的比较。其正确性论证必须依赖于以下性质：如果 $d(p,q)  \\delta$，则 $|x-x'|  \\delta$、$|y-y'|  \\delta$ 和 $|z-z'|  \\delta$，并且落入任何边长为 $\\delta$、点对间距至少为 $\\delta$ 的立方体内的点的数量受一个与维度相关的常数限制，从而确保在固定维度下合并步骤为线性时间。\n  4. 不使用绕过这些约束的启发式方法。\n\n需要明确处理的边界情况：\n- 如果两个点相同，则最小距离为 $0$，四舍五入后表示为 $0.000000$。\n- 如果 $n=2$，最小距离是这两点之间的距离。\n- 点可能具有负坐标和较大的数值；算法必须保持正确性和数值稳定性。\n\n测试套件：\n- 测试用例 1 $[(0,0,0),(10,10,10),(10,10,11),(20,25,30),(5,6,7),(100,-50,25),(-10,12,8)]$\n- 测试用例 2 $[(0,0,0),(1,1,1)]$\n- 测试用例 3 $[(5,-7,2),(5,-7,2),(0,0,0)]$\n- 测试用例 4 $[(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,0,0),(6,0,0),(7,0,0),(8,0,0),(9,0,0)]$\n- 测试用例 5 $[(0,1,1),(0,2,2),(0,3,3),(0,4,4),(0,4,5)]$\n- 测试用例 6 $[(-1000,500,-300),(-999,500,-300),(400,-800,1000),(401,-800,1000)]$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含上述六个测试用例的结果，形式为用方括号括起来的逗号分隔列表。每个结果必须是四舍五入到六位小数的浮点数（例如，$[1.000000,1.732051,0.000000,1.000000,1.000000,1.000000]$）。不应打印任何其他文本。", "solution": "该问题要求设计并实现一个分治算法，以找到三维点集 $P = \\{p_i\\}_{i=1}^n \\subset \\mathbb{R}^3$ 中任意两个不同点之间的最小欧几里得距离。解决方案必须源于算法设计和复杂度理论的第一性原理。\n\n### 基于原理的设计\n\n寻找最近点对问题是计算几何学中的一个经典问题。暴力方法会检查每对不同点之间的距离，涉及 $\\binom{n}{2} = \\frac{n(n-1)}{2}$ 次比较。这导致时间复杂度为 $O(n^2)$，对于大的 $n$ 而言效率低下。分治范式提供了一种更高效的方法。\n\n分治算法的核心原理是将一个问题分解为更小的、相似的子问题，递归地解决它们，然后合并它们的解来解决原始问题。对于最近点对问题，可以按以下方式构建：\n\n1.  **分解 (Divide)**：将点集 $P$ 划分为两个大小近似相等的子集，$P_L$ 和 $P_R$。\n2.  **解决 (Conquer)**：递归地找到 $P_L$ 中的最小距离（设为 $\\delta_L$）和 $P_R$ 中的最小距离（设为 $\\delta_R$）。\n3.  **合并 (Combine)**：整个集合 $P$ 中的最小距离是 $\\delta_L$、$\\delta_R$ 以及一对点 $(p_L, p_R)$（其中 $p_L \\in P_L$ 且 $p_R \\in P_R$）之间最小距离的最小值。令 $\\delta = \\min(\\delta_L, \\delta_R)$。如果存在距离小于 $\\delta$ 的点对 $(p_L, p_R)$，则必须找出这对点。\n\n算法复杂度的分析取决于递推关系 $T(n) = 2T(n/2) + T_{\\text{combine}}(n)$。为了达到 $O(n \\log n)$ 的目标复杂度，合并步骤 $T_{\\text{combine}}(n)$ 的复杂度必须为 $O(n)$。\n\n### 详细算法与论证\n\n**1. 预处理：**\n为了便于分解步骤，我们首先根据点的 $x$ 坐标对整个点集 $P$进行排序。这将创建一个排序后的列表 $P_x$。这个初始排序需要 $O(n \\log n)$ 的时间。\n\n**2. 递归结构：**\n递归函数，我们称之为 `find_closest(Px)`，作用于一个已经按 $x$ 坐标排好序的点列表。\n\n*   **基准情形 (Base Case)**：如果点的数量很少（例如，$n \\le 3$），则通过暴力方法计算最小距离。这需要常数时间 $O(1)$。对于 $n  2$，距离未定义，我们可以用无穷大表示。\n\n*   **分解步骤 (Divide Step)**：我们将排序后的列表 $P_x$ 分为两半，$P_L = P_x[0 \\dots n/2-1]$ 和 $P_R = P_x[n/2 \\dots n-1]$。分割线是一个通过中位数 $x$ 坐标 $x_{med} = P_x[n/2].x$ 的垂直平面。\n\n*   **解决步骤 (Conquer Step)**：我们进行两次递归调用：$\\delta_L = \\text{find\\_closest}(P_L)$ 和 $\\delta_R = \\text{find\\_closest}(P_R)$。\n\n*   **合并步骤 (Combine Step)**：这是算法最关键的部分。令 $\\delta = \\min(\\delta_L, \\delta_R)$。如果存在更近的点对，它必须由一个来自 $P_L$ 的点和一个来自 $P_R$ 的点组成。设这样的点对为 $(p_L, p_R)$，其距离 $d(p_L, p_R)$ 小于 $\\delta$。这样的点对必须满足其坐标差也有界：$|x_L - x_R|  \\delta$、$|y_L - y_R|  \\delta$ 和 $|z_L - z_R|  \\delta$。\n\n    这一观察使我们能够大幅缩小搜索空间。我们只需考虑位于以分割平面 $x = x_{med}$ 为中心、宽度为 $2\\delta$ 的垂直“条带”（或称平板区域）内的点。设 $S$ 为 $P$ 中 $x$ 坐标在范围 $[x_{med} - \\delta, x_{med} + \\delta]$ 内的点集。\n\n    为确保合并步骤为 $O(n)$，我们采用一种基于网格的哈希技术：\n    1.  **网格构建**：我们在 $y-z$ 平面上定义一个单元格边长为 $\\delta$ 的二维网格。我们遍历条带 $S$ 中的点。对于每个点 $p=(x,y,z) \\in S$，我们将其映射到由 $(\\lfloor y/\\delta \\rfloor, \\lfloor z/\\delta \\rfloor)$ 索引的网格单元中。我们使用哈希表来存储落入每个单元格的点。\n    2.  **邻居搜索**：对于从条带中处理的每个点 $p$，我们只需在其周围一个小的有限区域内检查邻居。一个点 $q$ 如果满足 $d(p, q)  \\delta$，则必须有 $|p.y - q.y|  \\delta$ 和 $|p.z - q.z|  \\delta$。这意味着 $q$ 必须位于 $p$ 自己的网格单元或其八个相邻单元之一（一个以 $p$ 的单元格为中心的 $3 \\times 3$ 单元格块）中。\n    3.  **复杂度论证**：正如问题所述，在任何边长为 $\\delta$ 的立方体内，点对间距至少为 $\\delta$ 的点的数量受一个常数限制。一个堆积论证证明了任何单个网格单元中的点数也受一个小的常数限制。因此，对于每个点 $p \\in S$，我们只需将其与常数数量的其他点进行距离检查。\n    4.  **实现**：我们遍历条带中的点。对于每个点 $p$，我们在网格中检查相关的相邻单元格，寻找已经处理并添加到网格中的点。然后，我们将 $p$ 添加到其对应的网格单元中。这确保了每对点实际上只被检查一次。\n\n这种基于网格的处理条带的方法需要 $O(|S|) = O(n)$ 的时间。总的递推关系变为 $T(n) = 2T(n/2) + O(n)$，根据主定理 (Master Theorem) 解得 $T(n) = O(n \\log n)$。包括初始排序在内的总时间复杂度为 $O(n \\log n)$。该算法具有科学合理性，并满足问题的所有要求。如果在任何时候发现距离为 $0$（表示存在相同的点），算法可以立即终止并返回 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef distance(p1, p2):\n    \"\"\"Computes the Euclidean distance between two points in 3D space.\"\"\"\n    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)\n\ndef brute_force_closest_pair(points):\n    \"\"\"\n    Finds the minimum distance in a small set of points by brute force.\n    Assumes len(points) > 1.\n    \"\"\"\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            d = distance(points[i], points[j])\n            if d  min_dist:\n                min_dist = d\n    return min_dist\n\ndef closest_pair_recursive(Px):\n    \"\"\"\n    The recursive core of the divide-and-conquer algorithm.\n    Px is a list of points sorted by x-coordinate.\n    \"\"\"\n    n = len(Px)\n\n    # Base case: for a small number of points, use brute force.\n    if n = 3:\n        # If n  2, there are no pairs, so the distance is infinite.\n        if n  2:\n            return float('inf')\n        return brute_force_closest_pair(Px)\n\n    # Divide step: Split the points into two halves.\n    mid = n // 2\n    median_point = Px[mid]\n    \n    # Create left and right subsets of points sorted by x.\n    Px_left = Px[:mid]\n    Px_right = Px[mid:]\n\n    # Conquer step: Recursively find the closest pair in each half.\n    d_left = closest_pair_recursive(Px_left)\n    d_right = closest_pair_recursive(Px_right)\n\n    delta = min(d_left, d_right)\n\n    # Optimization: if a pair of identical points was found, the distance is 0.\n    # We can't find a smaller non-negative distance, so we can terminate early.\n    if delta == 0:\n        return 0.0\n\n    # Combine step: Check for a closer pair across the two halves.\n    # Such a pair must lie in a \"strip\" of width 2*delta around the median x-plane.\n    strip_points = [p for p in Px if abs(p[0] - median_point[0])  delta]\n    \n    # To achieve an O(n) combine step, we use a grid (hashing) method\n    # on the y-z plane to find candidate pairs in the strip efficiently.\n    grid = {}\n    cell_size = delta\n    min_dist_strip = delta\n\n    for p in strip_points:\n        # Determine the grid cell key for the point p based on its y and z coordinates.\n        key = (int(p[1] / cell_size), int(p[2] / cell_size))\n        \n        # Check neighboring cells for points closer than delta.\n        # We check a 3x3 block of cells in the y-z plane centered at the current point's cell.\n        for dy in range(-1, 2):\n            for dz in range(-1, 2):\n                check_key = (key[0] + dy, key[1] + dz)\n                if check_key in grid:\n                    for neighbor in grid[check_key]:\n                        d = distance(p, neighbor)\n                        if d  min_dist_strip:\n                            min_dist_strip = d\n        \n        # Add the current point to the grid for subsequent points to check against.\n        if key not in grid:\n            grid[key] = []\n        grid[key].append(p)\n        \n    return min_dist_strip\n\n\ndef solve_closest_pair(points):\n    \"\"\"\n    Main function to initiate the closest pair algorithm. It sorts the points\n    by the x-coordinate and calls the recursive helper function.\n    \"\"\"\n    # An initial sort by x-coordinate is required for the divide-and-conquer strategy.\n    # Sorting a list of tuples sorts them element by element, starting with the first (x).\n    sorted_points = sorted(list(points))\n\n    return closest_pair_recursive(sorted_points)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(0,0,0),(10,10,10),(10,10,11),(20,25,30),(5,6,7),(100,-50,25),(-10,12,8)],\n        [(0,0,0),(1,1,1)],\n        [(5,-7,2),(5,-7,2),(0,0,0)],\n        [(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,0,0),(6,0,0),(7,0,0),(8,0,0),(9,0,0)],\n        [(0,1,1),(0,2,2),(0,3,3),(0,4,4),(0,4,5)],\n        [(-1000,500,-300),(-999,500,-300),(400,-800,1000),(401,-800,1000)]\n    ]\n\n    results = []\n    for case in test_cases:\n        if len(case)  2:\n            # Although all given test cases have n>=2, this handles the general case.\n            # The minimum distance between fewer than two points is considered infinite.\n            result = float('inf') \n        else:\n            result = solve_closest_pair(case)\n        \n        # Format the result to six decimal places.\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3205365"}]}