{"hands_on_practices": [{"introduction": "在掌握了线性数组的基础之上，我们来挑战一个常见的变体：环形数组中的最大子数组和。这个问题的巧妙之处在于其解的结构：最优解要么是一个不“环绕”的标准线性子数组，要么是一个“环绕”的子数组。对于环绕的情况，其和等于数组总和减去中间“未被选中”部分的和。为了使环绕部分的和最大化，我们只需找到那个和为 *最小* 的线性子数组并减去它。这个问题 [@problem_id:3250540] 完美地展示了“问题规约”的思想，即如何将一个新问题转化为我们已经知道如何解决的问题。", "problem": "给定一个长度为 $n$（$n \\geq 1$）的有限整数序列 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$，将线性数组上的非空连续子数组定义为满足 $0 \\leq i \\leq j \\leq n-1$ 的整数 $i$ 和 $j$ 的任意序列 $\\langle a_i, a_{i+1}, \\dots, a_j \\rangle$。对于循环数组，索引算术以 $n$ 为模进行，因此非空连续子数组可以环绕边界，并且是满足 $0 \\leq k \\leq n-1$ 和 $0 \\leq \\ell \\leq n-1$ 的整数 $k$ 和 $\\ell$ 的任意形式为 $\\langle a_k, a_{k+1}, \\dots, a_{n-1}, a_0, a_1, \\dots, a_\\ell \\rangle$ 的序列，且该序列至少包含一个元素。子数组的和是其元素的常规整数加法。循环数组中的最大子数组和是在循环索引下所有非空连续子数组中可能的最大和。\n\n仅从上述基本定义和分治法（D and C）的一般设计原则出发（分治法将一个问题分解为若干不相交部分的子问题，独立地解决它们，然后组合它们的解以获得原始问题的解），实现一个程序，为下面提供的每个测试用例计算循环数组中的最大子数组和。您的实现必须采用真正的分治策略来计算必要的量；不要使用贪心扫描或动态规划。\n\n评估您程序的测试套件：\n- 案例 $1$：[\\,5, -3, 5\\,]\n- 案例 $2$：[\\,-5, -1, -8\\,]\n- 案例 $3$：[\\,7\\,]\n- 案例 $4$：[\\,-7\\,]\n- 案例 $5$：[\\,2, 2, 2\\,]\n- 案例 $6$：[\\,0, -2, 0, -3\\,]\n- 案例 $7$：[\\,10, -12, 11, -1, 12\\,]\n- 案例 $8$：[\\,-2, 1\\,]\n\n对于每个案例，要求的输出是在循环解释下的最大子数组和，表示为一个整数。\n\n最终输出格式规范：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\,\\text{result}_1,\\text{result}_2,\\dots\\,]$）。结果必须按顺序对应案例1到8。不涉及单位，也不应打印任何额外文本。", "solution": "用户希望我解决“最大循环子数组和”问题。\n该问题是有效的。这是一个在算法和数据结构领域内定义明确的计算问题，基于标准的数学定义。它自成体系、客观，并且其解决方案是可验证的。使用分治（D and C）策略的约束是一种标准的算法范式，这使得该问题成为算法设计中一个不平凡的练习，而不仅仅是某个已知贪心算法的简单应用。\n\n寻找循环数组中最大子数组和的问题可以分解为两个不同的情况。设输入数组为 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$。在这种循环排列中，一个非空连续子数组要么是：\n$1$. 一个不环绕数组两端的标准线性子数组。\n$2$. 一个确实环绕的子数组，由数组的后缀和前缀组成，例如 $\\langle a_k, \\dots, a_{n-1}, a_0, \\dots, a_{\\ell} \\rangle$。\n\n因此，最大循环子数组和是在这两种情况下找到的和的最大值。\n\n**情况1：最大线性子数组和**\n\n这是标准的最大子数组问题。根据问题的约束，我们必须使用分治策略来解决这个问题。针对此问题的线性分治方法涉及对数组段 $A[\\text{low} \\dots \\text{high}]$ 执行以下步骤：\n- **分解**：在中间点 $m = \\lfloor (\\text{low} + \\text{high}) / 2 \\rfloor$ 将数组分成两半。两个子问题分别在 $A[\\text{low} \\dots m]$ 和 $A[m+1 \\dots \\text{high}]$ 上。\n- **解决**：递归地解决这两个半区。\n- **合并**：$A[\\text{low} \\dots \\text{high}]$ 中的最大子数组可以位于以下三个位置之一：\n    a) 完全在左半部分 $A[\\text{low} \\dots m]$ 内。\n    b) 完全在右半部分 $A[m+1 \\dots \\text{high}]$ 内。\n    c) 跨越中点 $m$。一个跨越中点的子数组是左半部分的最大可能后缀和与右半部分的最大可能前缀和之和。\n\n为了高效地执行合并步骤，我们的递归函数不仅必须返回给定段的最大子数组和，还必须返回更丰富的信息。具体来说，对于任何数组段，我们将计算一个包含四个值的元组：\n$1$. $S_{\\text{total}}$：该段中所有元素的总和。\n$2$. $S_{\\text{max\\_sub}}$：该段内的最大子数组和。\n$3$. $S_{\\text{max\\_prefix}}$：该段任意非空前缀的最大和。\n$4$. $S_{\\text{max\\_suffix}}$：该段任意非空后缀的最大和。\n\n递归的基准情况是单个元素的数组 $\\langle x \\rangle$，对于它，所有四个值都只是 $x$。\n在合并步骤中，给定来自左半部分（$L$）和右半部分（$R$）的结果：\n- $S_{\\text{total}} = L.S_{\\text{total}} + R.S_{\\text{total}}$\n- $S_{\\text{max\\_prefix}} = \\max(L.S_{\\text{max\\_prefix}}, L.S_{\\text{total}} + R.S_{\\text{max\\_prefix}})$\n- $S_{\\text{max\\_suffix}} = \\max(R.S_{\\text{max\\_suffix}}, R.S_{\\text{total}} + L.S_{\\text{max\\_suffix}})$\n- $S_{\\text{max\\_sub}} = \\max(L.S_{\\text{max\\_sub}}, R.S_{\\text{max\\_sub}}, L.S_{\\text{max\\_suffix}} + R.S_{\\text{max\\_prefix}})$\n\n情况1的解，我们记为 $S_{\\text{max\\_linear}}$，是这个分治过程对整个数组 $A$ 返回的值 $S_{\\text{max\\_sub}}$。\n\n**情况2：最大环绕子数组和**\n\n一个环绕子数组等价于整个数组从中“移除”一个非环绕（线性）子数组。为了最大化环绕部分的和，必须移除一个具有*最小*可能和的线性子数组。\n设 $S_{\\text{total}}$ 是 $A$ 中所有元素的总和。一个环绕子数组的和是 $S_{\\text{total}} - S_{\\text{removed}}$，其中 $S_{\\text{removed}}$ 是被排除在外的非空线性子数组的和。\n最大化此表达式等同于最小化 $S_{\\text{removed}}$。\n因此，最大环绕子数组和是 $S_{\\text{max\\_wrap}} = S_{\\text{total}} - S_{\\text{min\\_linear}}$，其中 $S_{\\text{min\\_linear}}$ 是最小线性子数组和。\n\n最小线性子数组和可以使用相同的分治机制找到。注意恒等式：$\\min(X) = -\\max(-X)$。我们可以通过将 $A$ 的所有元素取反形成一个新数组 $A'$，找到 $A'$ 的最大线性子数组和，然后将结果取反来找到 $S_{\\text{min\\_linear}}$。\n$S_{\\text{min\\_linear}}(A) = -S_{\\text{max\\_linear}}(-A)$。\n\n**组合情况并处理边界情况**\n\n最终答案是 $\\max(S_{\\text{max\\_linear}}, S_{\\text{max\\_wrap}})$。然而，存在一个关键的边界情况。环绕和的逻辑，$S_{\\text{total}} - S_{\\text{min\\_linear}}$，假设被“移除”的子数组是 $A$ 的一个*真*子数组。如果最小线性子数组就是整个数组本身，“移除”它将留下一个空集，根据问题定义，这不是一个有效的非空子数组。\n\n这种情况当且仅当 $S_{\\text{min\\_linear}} = S_{\\text{total}}$ 时发生。例如，当数组的所有元素都是非正数时，就会发生这种情况。在这种情况下，任何环绕子数组的和都将小于或等于一个非环绕子数组的和，因此环绕情况不是最大值的有效候选者。答案必须是最大线性子数组和 $S_{\\text{max\\_linear}}$。\n\n因此，最终算法是：\n$1$. 对于长度为 $n$ 的数组 $A$：如果 $n = 1$，答案是 $a_0$。\n$2$. 使用分治过程计算数组 $A$ 的 $S_{\\text{total}}$ 和 $S_{\\text{max\\_linear}}$。\n$3$. 对取反后的数组 $-A$ 使用分治过程找到 $S'_{\\text{max\\_linear}}$，并计算 $S_{\\text{min\\_linear}} = -S'_{\\text{max\\_linear}}$。\n$4$. 如果 $S_{\\text{min\\_linear}} = S_{\\text{total}}$，答案是 $S_{\\text{max\\_linear}}$。\n$5$. 否则，答案是 $\\max(S_{\\text{max\\_linear}}, S_{\\text{total}} - S_{\\text{min\\_linear}})$。\n这种方法正确地计算了最大循环子数组和，同时严格遵守了分治范式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the maximum circular subarray sum problem\n    for a suite of test cases using a Divide and Conquer strategy.\n    \"\"\"\n\n    test_cases = [\n        [5, -3, 5],\n        [-5, -1, -8],\n        [7],\n        [-7],\n        [2, 2, 2],\n        [0, -2, 0, -3],\n        [10, -12, 11, -1, 12],\n        [-2, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_max_circular_subarray_sum(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _dnc_linear_solver(arr: np.ndarray) -> tuple[int, int, int, int]:\n    \"\"\"\n    Computes linear subarray properties using Divide and Conquer.\n\n    Args:\n        arr: A numpy array of integers.\n\n    Returns:\n        A tuple containing:\n        (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n    \"\"\"\n    n = arr.shape[0]\n    if n == 1:\n        val = arr[0]\n        return (val, val, val, val)\n\n    mid = n // 2\n    left_arr, right_arr = arr[:mid], arr[mid:]\n\n    left_total, left_max_sub, left_max_pre, left_max_suf = _dnc_linear_solver(left_arr)\n    right_total, right_max_sub, right_max_pre, right_max_suf = _dnc_linear_solver(right_arr)\n\n    # Combine results\n    total_sum = left_total + right_total\n    \n    # Max prefix of combined array is either max prefix of left, or all of left + max prefix of right.\n    max_prefix_sum = max(left_max_pre, left_total + right_max_pre)\n    \n    # Max suffix of combined array is either max suffix of right, or all of right + max suffix of left.\n    max_suffix_sum = max(right_max_suf, right_total + left_max_suf)\n    \n    # Max subarray is in left, in right, or crosses the middle.\n    crossing_sum = left_max_suf + right_max_pre\n    max_subarray_sum = max(left_max_sub, right_max_sub, crossing_sum)\n\n    return (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n\ndef find_max_circular_subarray_sum(arr: list[int]) -> int:\n    \"\"\"\n    Calculates the maximum circular subarray sum for a given array.\n\n    Args:\n        arr: A list of integers, with length n >= 1.\n\n    Returns:\n        The maximum circular subarray sum.\n    \"\"\"\n    n = len(arr)\n    # The problem statement guarantees n >= 1. The D base case handles n = 1.\n    \n    arr_np = np.array(arr, dtype=np.int64)\n\n    # Case 1: Find the maximum subarray sum in the linear (non-wrapping) array.\n    total_sum, max_linear_sum, _, _ = _dnc_linear_solver(arr_np)\n\n    # Case 2: Find the maximum wrapping subarray sum.\n    # This is total_sum - min_linear_subarray_sum.\n    # We find min_linear_subarray_sum by finding the max subarray sum of the negated array.\n    # min_sum(A) = -max_sum(-A)\n    neg_arr_np = -arr_np\n    _, max_sum_of_neg_arr, _, _ = _dnc_linear_solver(neg_arr_np)\n    min_linear_sum = -max_sum_of_neg_arr\n\n    # Edge Case: If the minimum linear subarray is the entire array itself\n    # (which happens when all numbers are non-positive), total_sum == min_linear_sum.\n    # In this case, the wrapping sum corresponds to removing the whole array, leaving an\n    # empty set, which is invalid. So, the answer must be the non-wrapping max sum.\n    # This check correctly handles the all-non-positive (and single element) cases.\n    if total_sum == min_linear_sum and n > 0:\n        return max_linear_sum\n    else:\n        max_wrapping_sum = total_sum - min_linear_sum\n        return max(max_linear_sum, max_wrapping_sum)\n\nsolve()\n```", "id": "3250540"}, {"introduction": "最后一个练习将问题扩展到寻找两个不相交的子数组，使其总和最大化。解决这个问题的核心思想是，这两个子数组之间必然存在一个“分割点”。我们可以遍历所有可能的分割点，将原数组分成左右两部分，问题就转化为分别求左部的最大子数组和右部的最大子数组。虽然这符合分治的思想，但更高效的实现方式是采用动态规划 [@problem_id:3250589]。通过一次前向遍历和一次后向遍历预先计算出所有前缀和后缀的最大子数组信息，我们就能在常数时间内得到每个分割点对应的解，从而将整体复杂度优化到线性时间。", "problem": "给定一个长度为 $n$ 的整数数组 $A$，其元素可以是负数、零或正数。子数组定义为 $A$ 的一个连续段 $[i,j]$，其中 $0 \\le i \\le j \\le n-1$。子数组 $[i,j]$ 的和为 $\\sum_{k=i}^{j} A[k]$。任务是找到两个不相交的非空子数组 $[i_1,j_1]$ 和 $[i_2,j_2]$，使得 $j_1  i_2$，并且它们的总和 $\\sum_{k=i_1}^{j_1} A[k] + \\sum_{k=i_2}^{j_2} A[k]$ 最大化。\n\n从以下基础概念开始：\n- 数组、子数组和求和的定义，以及划分问题域并在边界上组合最优子解的分治范式。\n- 一个经过充分验证的事实是，一个区间上的最大子数组和可以通过比较左半部分的最优解、右半部分的最优解，以及一个跨越边界的解（由左半部分的最优后缀和右半部分的最优前缀构成）来确定。\n\n约束和约定：\n- 对 $A$ 中的位置使用 $0$-based 索引。\n- $[i_1,j_1]$ 和 $[i_2,j_2]$ 都必须是非空的。\n- 不相交意味着没有共享的索引；允许相邻，因此 $j_1 = i_2 - 1$ 是允许的。\n- 如果存在多个具有相同最大总和的最优解，则通过选择字典序最小的四元组 $(i_1, j_1, i_2, j_2)$ 来打破平局，其中字典序首先比较 $i_1$，然后是 $j_1$，然后是 $i_2$，最后是 $j_2$。\n\n实现一个完整的、可运行的程序，对于每个提供的测试用例，输出一个包含五个整数的列表 $[S, i_1, j_1, i_2, j_2]$，其中 $S$ 是最大总和，$[i_1,j_1]$ 和 $[i_2,j_2]$ 是满足约束和打破平局规则的所选子数组。\n\n不涉及物理单位。所有答案都是整数。程序必须生成单行输出，包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身格式化为一个子列表（例如：$[[S_1,i_{1,1},j_{1,1},i_{2,1},j_{2,1}],[S_2,i_{1,2},j_{1,2},i_{2,2},j_{2,2}],\\ldots]$）。\n\n测试套件（每个 $A^{(t)}$ 是一个独立的测试用例）：\n- 测试 $1$：$A^{(1)} = [\\,3,\\,-1,\\,2,\\,-1,\\,2,\\,-5,\\,4,\\,-1,\\,2\\,]$。\n- 测试 $2$：$A^{(2)} = [\\,-7,\\,-3,\\,-5,\\,-2,\\,-9\\,]$。\n- 测试 $3$：$A^{(3)} = [\\,1,\\,2,\\,3,\\,4\\,]$。\n- 测试 $4$：$A^{(4)} = [\\,5,\\,-6,\\,7,\\,-2,\\,3,\\,-1,\\,2\\,]$。\n- 测试 $5$：$A^{(5)} = [\\,0,\\,-1,\\,0,\\,-1,\\,0\\,]$。\n\n你的程序应该生成单行输出，包含所有结果，格式为一个由方括号括起来的逗号分隔列表，每个结果本身格式化为一个无空格的、由方括号括起来的逗号分隔列表，例如：$[[S_1,i_{1,1},j_{1,1},i_{2,1},j_{2,1}],[S_2,i_{1,2},j_{1,2},i_{2,2},j_{2,2}],\\ldots]$。", "solution": "问题要求在给定长度为 $n$ 的整数数组 $A$ 中找到两个非空、不相交的子数组 $[i_1, j_1]$ 和 $[i_2, j_2]$，使得它们的总和最大化。不相交的约束被指定为 $j_1  i_2$。这意味着第一个子数组必须完全在第二个子数组之前。给定了一个打破平局的规则：如果多对子数组产生相同的最大和，必须选择对应于字典序最小的四元组 $(i_1, j_1, i_2, j_2)$ 的那一对。\n\n通过观察其结构，这个问题可以被高效地解决。条件 $j_1  i_2$ 意味着数组中存在一个概念上的“分割点”，将两个子数组分开。如果我们考虑任何整数 $k$ 使得 $0 \\le k  n-1$，我们可以将数组 $A$ 划分为左半部分 $A[0 \\dots k]$ 和右半部分 $A[k+1 \\dots n-1]$。对于任何有效的解 $([i_1, j_1], [i_2, j_2])$，必定存在某个分割点 $k$，使得 $[i_1, j_1]$ 完全包含在 $A[0 \\dots k]$ 中，而 $[i_2, j_2]$ 完全包含在 $A[k+1 \\dots n-1]$ 中。\n\n因此，为了找到最大总和，我们可以遍历所有可能的分割点 $k$（从 $0$ 到 $n-2$）。对于每个分割点 $k$，我们找到左半部分 $A[0 \\dots k]$ 的最大子数组和，以及右半部分 $A[k+1 \\dots n-1]$ 的最大子数组和。这两个最大值之和是整体解的一个候选。最终答案将是所有可能的 $k$ 值对应的这些候选解中的最大值。\n\n这种方法的朴素实现将涉及在每次分割时对每个部分运行像 Kadane 算法这样的算法，导致总时间复杂度为 $O(n^2)$。我们可以使用动态规划将其优化到 $O(n)$。核心思想是预先计算数组所有可能的前缀和后缀的最大子数组信息。\n\n让我们定义两个大小为 $n$ 的辅助数组 $L$ 和 $R$。\n$L[k]$ 将存储前缀 $A[0 \\dots k]$ 内最大和子数组的信息（和、起始索引、结束索引）。\n$R[k]$ 将存储后缀 $A[k \\dots n-1]$ 内最大和子数组的相同信息。\n\n打破平局的规则要求我们选择具有字典序最小索引的解。这必须被纳入我们对 $L[k]$ 和 $R[k]$ 的定义中。\n- $L[k]$：在 $A[0 \\dots k]$ 中所有具有最大可能和的子数组中，我们选择其索引对 $(i, j)$ 字典序最小的那个。\n- $R[k]$：在 $A[k \\dots n-1]$ 中所有具有最大可能和的子数组中，我们选择其索引对 $(i, j)$ 字典序最小的那个。\n\n**步骤 1：计算前缀最大值数组 $L$**\n我们可以通过从 $k=0$ 到 $n-1$ 的单次前向遍历来计算 $L$。在每个步骤 $k$，我们需要两部分信息：\n1. 恰好在索引 $k$ 处结束的最大子数组。我们称之为 `current_max_info`。\n2. 前缀 $A[0 \\dots k]$ 内的全局最大子数组。这就是 $L[k]$。\n\n为了计算索引 $k$ 处的 `current_max_info`，我们比较两种选择：在 $k$ 处开始一个新的子数组（和为 $A[k]$），或者扩展在 $k-1$ 处结束的最大子数组。\n设 `current_max_info[k] = (s_c, i_c, j_c)`。\n如果 `current_max_info[k-1].s + A[k] \\ge A[k]`，我们扩展前一个子数组。新的和是 `current_max_info[k-1].s + A[k]`，索引为 `(current_max_info[k-1].i, k)`。\n否则，我们开始一个新的子数组 `(A[k], k, k)`。\n\n然后通过比较 $L[k-1]$ 和 `current_max_info[k]` 来确定 $L[k]$。\n设 $L[k-1] = (s_L, i_L, j_L)$ 且 `current_max_info[k] = (s_c, i_c, j_c)`。\n- 如果 $s_c > s_L$，那么 $L[k]$ 变为 `current_max_info[k]`。\n- 如果 $s_c  s_L$，那么 $L[k]$ 保持为 $L[k-1]$。\n- 如果 $s_c = s_L$，我们应用打破平局的规则：$L[k]$ 是具有字典序更小的索引对 $(i, j)$ 的那个。\n\n**步骤 2：计算后缀最大值数组 $R$**\n类似地，我们通过从 $k=n-1$ 向下到 $0$ 的单次后向遍历来计算 $R$。逻辑是类似的。\n为了计算 `current_max_info`（对于一个从 $k$ 开始的子数组），我们比较开始一个新的子数组 `(A[k], k, k)` 与扩展从 $k+1$ 开始的最大子数组。这里的 `current_max_info` 的平局打破规则很重要。如果扩展得到的和与新开始的相同，即 `(A[k] + s_{k+1}, k, j_{k+1})` vs `(A[k], k, k)`，起始索引 $k$ 是相同的，但结束索引 $k$ 小于 $j_{k+1}$。为了得到字典序更小的索引，我们在和相等的情况下倾向于开始一个新的子数组。所以，我们只在 `A[k] + s_{k+1} > A[k]` 时进行扩展。\n\n然后，$R[k]$ 是 $R[k+1]$ 和索引 $k$ 的 `current_max_info` 中“更好”的那个，使用相同的“和优先，索引其次”的比较方法。\n\n**步骤 3：合并结果**\n在 $L$ 和 $R$ 数组完全计算出来后，我们遍历所有可能的分割点 $k$，从 $0$ 到 $n-2$。对于每个 $k$，我们考虑由 $L[k]$ 和 $R[k+1]$ 给出的子数组对。\n设 $L[k] = (s_1, i_1, j_1)$ 且 $R[k+1] = (s_2, i_2, j_2)$。\n这个分割的总和是 $S = s_1 + s_2$。对应的索引四元组是 $(i_1, j_1, i_2, j_2)$。\n\n我们维护一个变量 `best_solution`，它存储迄今为止找到的最佳结果，并初始化为一个非常小的和。在每次迭代 $k$ 中，我们将当前候选和 $S$ 与 `best_solution` 中的和进行比较。\n- 如果 $S$ 更大，我们用新的和与四元组更新 `best_solution`。\n- 如果 $S$ 相等，我们将当前的四元组 $(i_1, j_1, i_2, j_2)$ 与 `best_solution` 中存储的四元组进行比较，如果新的四元组字典序更小，则更新。\n\n该算法的总时间复杂度是计算 $L$ 的 $O(n)$，计算 $R$ 的 $O(n)$，以及最后合并步骤的 $O(n)$。空间复杂度为 $O(n)$，用于存储 $L$ 和 $R$ 数组。这是一个解决该问题的有效方案。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    This function orchestrates the solving process for all test cases provided in the problem.\n    It calls the main solver for each case and formats the output as specified.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([3, -1, 2, -1, 2, -5, 4, -1, 2]),\n        np.array([-7, -3, -5, -2, -9]),\n        np.array([1, 2, 3, 4]),\n        np.array([5, -6, 7, -2, 3, -1, 2]),\n        np.array([0, -1, 0, -1, 0]),\n    ]\n\n    all_results = []\n    for A in test_cases:\n        result = find_max_two_disjoint_subarrays(A)\n        all_results.append(result)\n\n    # Format the final output string to match the exact requirement (no spaces).\n    formatted_results = [f'[{\",\".join(map(str, res))}]' for res in all_results]\n    final_output = f'[{\",\".join(formatted_results)}]'\n    print(final_output)\n\ndef find_max_two_disjoint_subarrays(A):\n    \"\"\"\n    Finds two disjoint, non-empty subarrays [i1, j1] and [i2, j2] with j1  i2\n    that maximize their total sum, handling tie-breaking rules.\n    \"\"\"\n    n = len(A)\n    if n  2:\n        # Cannot form two disjoint non-empty subarrays.\n        # Problem constraints imply n >= 2 based on test cases and description.\n        # Fallback to a placeholder for robustness, though not expected to be hit.\n        return [-float('inf'), -1, -1, -1, -1] \n\n    # L[k] stores (max_sum, i, j) for the best subarray in A[0...k]\n    L = [None] * n\n    # R[k] stores (max_sum, i, j) for the best subarray in A[k...n-1]\n    R = [None] * n\n\n    # Step 1: Forward pass to compute L\n    # current_max_info: (sum, i, j) for max subarray ending at current position\n    current_max_info = (A[0], 0, 0)\n    L[0] = current_max_info\n    for k in range(1, n):\n        prev_sum, prev_i, _ = current_max_info\n        \n        # Compare extending the previous max subarray or starting a new one\n        extended_sum = prev_sum + A[k]\n        if extended_sum >= A[k]:\n            current_max_info = (extended_sum, prev_i, k)\n        else:\n            current_max_info = (A[k], k, k)\n            \n        # Update L[k] by comparing with L[k-1] and current_max_info\n        prev_best_sum, prev_best_i, prev_best_j = L[k-1]\n        curr_best_sum, curr_best_i, curr_best_j = current_max_info\n        \n        if curr_best_sum > prev_best_sum:\n            L[k] = current_max_info\n        elif curr_best_sum == prev_best_sum:\n            if (curr_best_i, curr_best_j)  (prev_best_i, prev_best_j):\n                L[k] = current_max_info\n            else:\n                L[k] = L[k-1]\n        else:\n            L[k] = L[k-1]\n\n    # Step 2: Backward pass to compute R\n    current_max_info = (A[n-1], n-1, n-1)\n    R[n-1] = current_max_info\n    for k in range(n-2, -1, -1):\n        prev_sum, _, prev_j = current_max_info\n        \n        # Compare extending forward or starting new\n        # Tie-break for smaller (i,j) tuple: prefer (k,k) over (k, prev_j)\n        extended_sum = prev_sum + A[k]\n        if extended_sum > A[k]:\n            current_max_info = (extended_sum, k, prev_j)\n        else:\n            current_max_info = (A[k], k, k)\n            \n        # Update R[k] by comparing with R[k+1] and current_max_info\n        prev_best_sum, prev_best_i, prev_best_j = R[k+1]\n        curr_best_sum, curr_best_i, curr_best_j = current_max_info\n\n        if curr_best_sum > prev_best_sum:\n            R[k] = current_max_info\n        elif curr_best_sum == prev_best_sum:\n            if (curr_best_i, curr_best_j)  (prev_best_i, prev_best_j):\n                R[k] = current_max_info\n            else:\n                R[k] = R[k+1]\n        else:\n            R[k] = R[k+1]\n\n    # Step 3: Combine results\n    max_total_sum = -float('inf')\n    best_quad = (-1, -1, -1, -1)\n\n    for k in range(n - 1):\n        s1, i1, j1 = L[k]\n        s2, i2, j2 = R[k+1]\n        current_total_sum = s1 + s2\n        \n        if current_total_sum > max_total_sum:\n            max_total_sum = current_total_sum\n            best_quad = (i1, j1, i2, j2)\n        elif current_total_sum == max_total_sum:\n            current_quad = (i1, j1, i2, j2)\n            if current_quad  best_quad:\n                best_quad = current_quad\n    \n    i1, j1, i2, j2 = best_quad\n    return [max_total_sum, i1, j1, i2, j2]\n\nsolve()\n```", "id": "3250589"}]}