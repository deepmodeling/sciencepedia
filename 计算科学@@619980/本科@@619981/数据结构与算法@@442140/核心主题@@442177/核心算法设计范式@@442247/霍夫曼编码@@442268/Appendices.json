{"hands_on_practices": [{"introduction": "理解任何编码方案的第一个实践步骤是学习如何解码。这个练习将带你体验霍夫曼编码的解码过程，其核心在于利用“前缀码”的特性，确保每一段二进制序列都能被唯一、无歧义地翻译回原始符号。通过这个练习，你将掌握从左到右扫描比特流并匹配码本，将压缩数据还原为原始信息的基本技能 [@problem_id:1630289]。", "problem": "一个深空探测器使用由四个不同标记（我们记作 Alpha ($\\alpha$)、Beta ($\\beta$)、Gamma ($\\gamma$) 和 Delta ($\\delta$)）组成的流将观测数据发送回地球。为了节省传输带宽，数据流使用霍夫曼编码进行压缩。将每个标记映射到其二进制表示的码本如下：\n*   $\\alpha$: `0`\n*   $\\beta$: `10`\n*   $\\gamma$: `110`\n*   $\\delta$: `111`\n\n接收到的一段传输包含二进制序列 `11010011100`。你的任务是解码这个序列。以下哪个选项表示原始的标记序列？\n\nA. $\\gamma\\beta\\delta\\alpha\\alpha$\n\nB. $\\gamma\\beta\\alpha\\gamma\\alpha\\alpha$\n\nC. $\\delta\\alpha\\beta\\beta\\alpha\\gamma$\n\nD. $\\gamma\\beta\\alpha\\delta\\alpha\\alpha$\n\nE. $\\gamma\\alpha\\beta\\delta\\alpha\\alpha$", "solution": "该问题要求我们使用给定的霍夫曼码本解码一个二进制序列。霍夫曼编码的一个基本属性是它是一种前缀码。这意味着没有码字是任何其他码字的前缀，这保证了任何编码序列都可以无歧义地解码成唯一的符号序列。\n\n解码算法通过从左到右读取二进制流来进行。我们逐个累积比特，直到当前的比特串与码本中的一个码字匹配。一旦找到匹配项，我们就记录下相应的符号，然后从流中的下一个比特开始继续这个过程。\n\n提供的码本是：\n*   $\\alpha$: `0`\n*   $\\beta$: `10`\n*   $\\gamma$: `110`\n*   $\\delta$: `111`\n\n需要解码的二进制序列是 `11010011100`。\n\n让我们一步一步地应用解码过程：\n\n1.  我们从序列的开头开始：`11010011100`。\n    -   我们读取第一个比特 `1`。它不是我们码本中的一个完整码字。\n    -   我们读取第二个比特，形成字符串 `11`。这也不在码本中。\n    -   我们读取第三个比特，形成 `110`。这个字符串匹配符号 $\\gamma$ 的编码。我们记录 $\\gamma$ 作为解码序列的第一个符号。\n    -   剩余的比特序列是 `10011100`。\n\n2.  我们从剩余序列的开头继续解码：`10011100`。\n    -   我们读取第一个比特 `1`。这不是一个码字。\n    -   我们读取第二个比特，形成 `10`。这个字符串匹配 $\\beta$ 的编码。我们记录 $\\beta$ 作为第二个符号。\n    -   剩余的比特序列是 `011100`。\n\n3.  我们处理新的序列：`011100`。\n    -   我们读取第一个比特 `0`。这个字符串匹配 $\\alpha$ 的编码。我们记录 $\\alpha$ 作为第三个符号。\n    -   剩余的比特序列是 `11100`。\n\n4.  我们继续处理序列 `11100`。\n    -   我们读取第一个比特 `1`。不是一个码字。\n    -   我们读取第二个比特，形成 `11`。不是一个码字。\n    -   我们读取第三个比特，形成 `111`。这个字符串匹配 $\\delta$ 的编码。我们记录 $\\delta$ 作为第四个符号。\n    -   剩余的比特序列是 `00`。\n\n5.  我们处理序列 `00`。\n    -   我们读取第一个比特 `0`。这匹配 $\\alpha$ 的编码。我们记录 $\\alpha$ 作为第五个符号。\n    -   剩余的比特序列是 `0`。\n\n6.  最后，我们解码序列的最后一部分：`0`。\n    -   我们读取比特 `0`。这匹配 $\\alpha$ 的编码。我们记录 $\\alpha$ 作为第六个也是最后一个符号。\n    -   剩余序列现在为空，所以解码完成。\n\n按顺序连接我们识别出的符号，我们得到原始序列为 $\\gamma\\beta\\alpha\\delta\\alpha\\alpha$。\n\n我们现在将这个结果与给出的多项选择选项进行比较：\nA. $\\gamma\\beta\\delta\\alpha\\alpha$\nB. $\\gamma\\beta\\alpha\\gamma\\alpha\\alpha$\nC. $\\delta\\alpha\\beta\\beta\\alpha\\gamma$\nD. $\\gamma\\beta\\alpha\\delta\\alpha\\alpha$\nE. $\\gamma\\alpha\\beta\\delta\\alpha\\alpha$\n\n我们的解码序列 $\\gamma\\beta\\alpha\\delta\\alpha\\alpha$ 与选项 D 匹配。", "answer": "$$\\boxed{D}$$", "id": "1630289"}, {"introduction": "既然我们已经掌握了解码，下一步就是亲手构建一个霍夫曼编码。这个练习将引导你完成霍夫曼编码的核心贪心算法，从概率最小的符号开始逐步构建编码树，并计算最终编码的平均长度 $L$。我们还会将其与由信源熵 $H$ 决定的理论压缩极限进行比较，从而直观地评估编码的效率 [@problem_id:1630316]。", "problem": "一个深空探测器正在监测一颗遥远系外行星的大气层。它配备了探测六种特定类型分子的设备，这些分子用符号 $\\{S_1, S_2, S_3, S_4, S_5, S_6\\}$ 标记。由于该行星的大气化学特性，这些分子以不同的频率被探测到。经过长时间的观测，探测器确定了在任何一次测量中探测到每种分子类型的稳定概率如下：\n$P(S_1) = 0.1$\n$P(S_2) = 0.1$\n$P(S_3) = 0.1$\n$P(S_4) = 0.1$\n$P(S_5) = 0.3$\n$P(S_6) = 0.3$\n\n为了节省传回地球的带宽，探测到的符号数据流将使用最优二进制前缀码进行编码。您的任务是分析这种编码方案的效率。\n\n计算该信源的两个基本量：\n1. 为这些符号构建的霍夫曼码的平均码长 $L$。\n2. 信源的熵 $H$。\n\n在构建霍夫曼码时，如果在选择合并节点时出现概率相同的情况，可以任意选择这些概率相同的节点。\n\n请按顺序以比特/符号为单位给出 $L$ 和 $H$ 的答案。将最终数值答案四舍五入至四位有效数字。", "solution": "给定六个符号，其概率分别为 $p_{1}=0.1$，$p_{2}=0.1$，$p_{3}=0.1$，$p_{4}=0.1$，$p_{5}=0.3$ 和 $p_{6}=0.3$。为了求出霍夫曼码的平均码长 $L$，我们通过迭代合并两个概率最小的节点来构建编码：\n- 初始概率集合：$\\{0.1, 0.1, 0.1, 0.1, 0.3, 0.3\\}$。\n- **第1步：** 合并两个 $0.1$ 得到 $0.2$。集合变为 $\\{0.1, 0.1, 0.2, 0.3, 0.3\\}$。\n- **第2步：** 再次合并两个 $0.1$ 得到 $0.2$。集合变为 $\\{0.2, 0.2, 0.3, 0.3\\}$。\n- **第3步：** 合并两个 $0.2$ 得到 $0.4$。集合变为 $\\{0.3, 0.3, 0.4\\}$。\n- **第4步：** 合并两个 $0.3$ 得到 $0.6$。集合变为 $\\{0.4, 0.6\\}$。\n- **第5步：** 合并 $0.4$ 和 $0.6$ 得到 $1.0$。\n\n通过回溯构建过程，我们可以确定每个符号的码长：\n- 概率为 $0.3$ 的两个符号 ($S_5, S_6$) 在第4步被合并，它们的父节点 ($0.6$) 在第5步（最后一步）被合并。它们的深度为2。所以 $l_5 = 2, l_6 = 2$。\n- 概率为 $0.1$ 的四个符号 ($S_1, S_2, S_3, S_4$) 的码长更长。它们在第1步和第2步被两两合并成权重为 $0.2$ 的节点。这两个 $0.2$ 的节点在第3步被合并成 $0.4$。最后这个 $0.4$ 的节点在第5步被合并。它们的深度为3。所以 $l_1=l_2=l_3=l_4=3$。\n\n因此，平均码长为：\n$$\nL=\\sum_{i=1}^{6}p_{i}l_{i}=4\\cdot (0.1\\cdot 3)+2\\cdot (0.3\\cdot 2)=1.2+1.2=2.4\\ \\text{比特/符号}。\n$$\n\n以比特/符号为单位的熵为：\n$$\nH=-\\sum_{i=1}^{6}p_{i}\\log_{2}p_{i}=-4\\cdot (0.1\\log_{2}0.1)-2\\cdot (0.3\\log_{2}0.3).\n$$\n使用 $\\log_{2}(0.1)\\approx -3.3219280949$ 和 $\\log_{2}(0.3)\\approx -1.7369655942$，我们得到：\n$$\nH\\approx -0.4(-3.3219280949)-0.6(-1.7369655942)=1.3287712379+1.0421793565\\approx 2.3709505945.\n$$\n四舍五入到四位有效数字，得到 $L=2.400$ 和 $H=2.371$，单位均为比特/符号。", "answer": "$$\\boxed{\\begin{pmatrix}2.400  2.371\\end{pmatrix}}$$", "id": "1630316"}, {"introduction": "霍夫曼编码非常强大，但它总是最佳选择吗？最后一个练习是一个思想实验，旨在探索霍夫曼编码最优性的边界。通过分析一个特定的概率分布，我们将精确地找出在何种条件下，简单的定长编码与霍夫曼编码的效率完全相同，从而更深刻地理解其贪心策略为何以及何时能带来显著的压缩收益 [@problem_id:1630282]。", "problem": "在信息论领域，霍夫曼编码是一种著名的无损数据压缩算法。它根据信源可能产生的每个符号的估计出现概率，构建一个可变长度的前缀码。一种替代的、更简单的方法是使用定长编码。\n\n考虑一个信源，它从字母表 $\\mathcal{A} = \\{S_1, S_2, S_3, S_4\\}$ 中生成符号。对于这个四符号字母表，一个定长二进制编码会为每个符号分配一个唯一的2比特码字，从而得到每个符号恰好2比特的平均码长。\n\n假设符号的概率分布结构是：两个符号具有高概率 $p_h$，另外两个符号具有低概率 $p_l$，其中 $p_h > p_l > 0$。当然，这些概率之和必须为1。\n\n确定比值 $R = p_h / p_l$ 的具体数值，使得无论在算法构建过程中如何选择打破平局，霍夫曼编码的平均码长都保证恰好为每个符号2比特。", "solution": "设四个符号的概率为 $\\{p_h, p_h, p_l, p_l\\}$，其中 $p_h > p_l > 0$，且满足归一化约束 $2p_h + 2p_l = 1$。一个定长编码的平均码长为2比特/符号。我们要找出一个比值 $R = p_h / p_l$，使得霍夫曼编码的平均码长也恰好为2。\n\n霍夫曼算法的第一步是合并两个概率最低的节点，即两个概率为 $p_l$ 的符号。这会创建一个权重为 $2p_l$ 的新节点。此时，我们有一个包含三个节点的待合并列表，其权重为 $\\{p_h, p_h, 2p_l\\}$。\n\n算法的下一步取决于这些权重的大小关系，这直接与比值 $R$ 相关：\n\n1.  **情况一：$p_h  2p_l$ (即 $R  2$)**\n    此时，两个最小的权重是 $p_h$ 和 $p_h$。我们将它们合并成一个权重为 $2p_h$ 的新节点。然后，我们合并权重为 $2p_l$ 和 $2p_h$ 的两个节点。这会生成一个完全二叉树，其中所有四个叶子节点（原始符号）都在深度2的位置。因此，每个符号的码长都是2，平均码长也恰好是2。在这种情况下，没有平局需要打破。\n\n2.  **情况二：$p_h > 2p_l$ (即 $R > 2$)**\n    此时，两个最小的权重是 $2p_l$ 和 $p_h$。合并它们将导致一个非平衡的树结构。最终的码长将不全是2（例如，深度为1、2、3、3），平均码长也将不为2。\n\n3.  **情况三：$p_h = 2p_l$ (即 $R = 2$)**\n    此时，权重列表变为 $\\{p_h, p_h, p_h\\}$，我们遇到了一个三向平局。根据问题要求，平均码长必须在所有平局打破方式下都为2。\n    *   **平局打破方式 A：** 合并两个原始的 $p_h$ 节点。这与情况一的逻辑完全相同，最终的平均码长为2。\n    *   **平局打破方式 B：** 合并一个原始的 $p_h$ 节点和由两个 $p_l$ 节点合并而来的新节点（其权重也为 $p_h$）。这将产生一个权重为 $2p_h$ 的节点。最后一步是合并这个新节点和剩下的 $p_h$ 节点。\n        让我们来追踪码长：一个 $p_h$ 符号在深度1，另一个 $p_h$ 符号在深度2，两个 $p_l$ 符号在深度3。\n        平均码长 $L$ 为：\n        $L = 1 \\cdot p_h + 2 \\cdot p_h + 2 \\cdot (3 \\cdot p_l) = 3p_h + 6p_l$。\n        既然我们处于 $p_h = 2p_l$ 的情况，我们可以代入：\n        $L = 3(2p_l) + 6p_l = 6p_l + 6p_l = 12p_l$。\n        利用归一化条件 $2p_h + 2p_l = 1$，代入 $p_h = 2p_l$ 得：\n        $2(2p_l) + 2p_l = 6p_l = 1$，所以 $p_l = 1/6$。\n        因此，平均码长为 $L = 12 \\cdot (1/6) = 2$。\n\n**结论**\n在 $R=2$ 的情况下，无论如何打破平局，最终的平均码长都恰好为2比特/符号。对于 $R  2$ 的情况，平均码长也为2（并且没有平局需要打破）。问题要求的是一个*具体的数值*，在这个数值下，结果是*有保证的*，尤其是在面临选择（即平局）时。这个特殊的、需要考虑平局的临界情况正是 $R=2$。", "answer": "$$\\boxed{2}$$", "id": "1630282"}]}