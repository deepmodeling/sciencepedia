{"hands_on_practices": [{"introduction": "逆序对的数量是衡量一个序列“无序”程度的指标。虽然通过检查所有可能的数对来计算逆序对的朴素方法需要二次时间，但分治法提供了一种更为高效的 $O(n \\log n)$ 解法。本练习将引导你应用分治策略，通过巧妙地修改归并排序算法，在排序的同时高效地统计跨越子数组的逆序对，从而深入理解分治法的精髓。[@problem_id:3205394]", "problem": "您的任务是设计并实现一个分治算法，用于计算一个有限的不同整数序列中的逆序对数量。逆序对被定义为一对索引 $(i,j)$，满足 $i<j$ 且 $A[i]>A[j]$。您必须实现一个算法，其最坏情况运行时间为 $O(n \\log n)$，其中 $n$ 表示输入序列的长度。\n\n定义和假设：\n- 长度为 $n$ 的序列 $A$ 如果包含 $n$ 个不同的整数（不必然是从 $1$ 到 $n$ 的整数），则称其为一个排列。\n- $A$ 的逆序数是满足 $i<j$ 且 $A[i]>A[j]$ 的索引对 $(i,j)$ 的数量。\n\n您的程序必须：\n- 实现一个分治算法来计算逆序数，仅使用整数比较和基本算术运算。不允许使用朴素的二次时间复杂度的遍历所有数对的方法。\n- 使用以下固定的测试套件，它是一个包含7个序列的列表，每个序列都表示为Python风格的列表。对于本问题，请将这些列表视为程序的全部输入，不要读取任何外部输入。\n    1. $[]$\n    2. $[1]$\n    3. $[1,2,3,4,5]$\n    4. $[5,4,3,2,1]$\n    5. $[2,3,8,6,1]$\n    6. $[1,3,5,2,4,6]$\n    7. $[10,3,7,4,9,1,8,2,5,6]$\n\n输出规范：\n- 对于上述7个序列中的每一个，计算其逆序数，结果为一个非负整数。\n- 您的程序应生成单行输出，其中包含7个结果，格式为逗号分隔的列表，并用方括号括起来，不含空格。例如，如果7个测试用例的结果为 $r_1,r_2,\\dots,r_7$，则输出应精确地为一行 $[r_1,r_2,\\dots,r_7]$。\n\n注意：\n- 不涉及物理或角度单位，也不需要百分比。所有输出都是整数。\n- 需要使用的算法设计范式是分治法，时间复杂度目标是 $O(n \\log n)$。", "solution": "我们从离散数学和算法分析的核心定义开始。设长度为 $n$ 的序列 $A$ 是一个包含 $n$ 个不同整数的列表。逆序对是一对索引 $(i,j)$，满足 $i<j$ 且 $A[i]>A[j]$。逆序数是集合 $\\{(i,j)\\mid 1\\le i<j\\le n,\\ A[i]>A[j]\\}$ 的基数。\n\n我们寻求一种在分治范式下最坏情况时间复杂度为 $O(n \\log n)$ 的算法。我们所依赖的基础是：\n- 分治方法论：通过将一个大小为 $n$ 的问题分解为大小约为 $n/2$ 的子问题，递归地解决这些子问题，并在 $O(n)$ 时间内合并它们的解来解决原问题。\n- 主定理适用于形式为 $T(n)=a\\,T(n/b)+f(n)$ 的递推关系，当 $a=2$、$b=2$ 且 $f(n)=\\Theta(n)$ 时，可以得出 $T(n)=O(n \\log n)$。\n\n设计：\n1. 分解步骤：将 $A$ 分成两半，$L$（左）和 $R$（右），大小分别为 $\\lfloor n/2\\rfloor$ 和 $\\lceil n/2\\rceil$。\n2. 解决步骤：递归地计算 $L$ 和 $R$ 的逆序数，分别表示为 $I_L$ 和 $I_R$，并同时生成 $L$ 和 $R$ 的排序版本。由于整数是不同的，排序定义了一个严格的全序关系。\n3. 合并步骤：将两个已排序的半区合并成一个单一的排序序列，同时计算跨区逆序对 $I_C$，即 $i$ 在左半区、$j$ 在右半区的逆序对 $(i,j)$。在一个标准的稳定合并过程中，维持指向 $L$ 的索引 $p$ 和指向 $R$ 的索引 $q$。当 $L[p]\\le R[q]$ 时，我们追加 $L[p]$ 并增加 $p$。当 $L[p]>R[q]$ 时，我们追加 $R[q]$ 并增加 $q$，并将 $(|L|-p)$ 加到逆序数上，因为 $R[q]$ 小于 $L$ 中所有剩余的元素 $L[p],L[p+1],\\dots,L[|L|-1]$，每个元素都贡献一个跨区逆序对。\n\n正确性：\n我们用对 $n$ 的数学归纳法证明该算法返回精确的逆序数和一个排序好的序列。\n- 基本情况：对于 $n=0$ 和 $n=1$，没有逆序对，所以计数为 $0$，序列自然有序。算法返回 $0$ 和原序列，这是正确的。\n- 归纳步骤：假设对于所有长度小于 $n$ 的序列，算法都是正确的。考虑一个长度为 $n$ 的序列 $A$。将其分为 $L$ 和 $R$ 后，根据归纳假设，递归调用正确地返回了 $I_L$ 和排序后的 $L$，以及 $I_R$ 和排序后的 $R$。$A$ 中的每一个逆序对要么完全在 $L$ 内部，要么完全在 $R$ 内部，要么是一个跨区逆序对，其第一个索引在 $L$ 中，第二个索引在 $R$ 中。合并过程精确地计算了跨区逆序对：每当一个来自 $R$ 的元素在合并顺序中排在 $L$ 中剩余元素之前时，它与这些剩余元素中的每一个都恰好构成一个逆序对；而当一个来自 $L$ 的元素排在来自 $R$ 的元素之前时，不会形成新的跨区逆序对。因此，总逆序数是 $I_L+I_R+I_C$，这正是算法所计算的。合并过程也从两个已排序的半区生成了正确的排序序列。因此，该算法是正确的。\n\n复杂度：\n设 $T(n)$ 表示在长度为 $n$ 的序列上的运行时间。递推关系满足\n$$\nT(n)=\n\\begin{cases}\n\\Theta(1),  &\\text{if } n\\le 1,\\\\\n2\\,T(n/2)+\\Theta(n),  &\\text{if } n>1,\n\\end{cases}\n$$\n因为我们对两半进行两次递归调用，并执行一个线性时间的合并。根据主定理，当 $a=2$，$b=2$，且 $f(n)=\\Theta(n)$ 时，我们得到 $T(n)=\\Theta(n\\log n)$。因此，该算法的运行时间为 $O(n\\log n)$。\n\n应用于测试套件：\n我们将该算法应用于指定的7个序列。对于每个序列，算法输出一个整数逆序数。最终输出必须是单行格式 $[r_1,r_2,\\dots,r_7]$，不含空格，其中 $r_k$ 是第 $k$ 个测试用例的逆序数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_inversions(arr):\n    # Returns (sorted_arr, inversion_count)\n    def sort_count(a):\n        n = len(a)\n        if n = 1:\n            return a[:], 0\n        mid = n // 2\n        left_sorted, left_inv = sort_count(a[:mid])\n        right_sorted, right_inv = sort_count(a[mid:])\n        merged = []\n        i = j = 0\n        cross_inv = 0\n        len_left = len(left_sorted)\n        len_right = len(right_sorted)\n        # Merge with inversion counting\n        while i  len_left and j  len_right:\n            if left_sorted[i] = right_sorted[j]:\n                merged.append(left_sorted[i])\n                i += 1\n            else:\n                merged.append(right_sorted[j])\n                # All remaining items in left_sorted form inversions with right_sorted[j]\n                cross_inv += (len_left - i)\n                j += 1\n        if i  len_left:\n            merged.extend(left_sorted[i:])\n        if j  len_right:\n            merged.extend(right_sorted[j:])\n        return merged, left_inv + right_inv + cross_inv\n\n    _, inv = sort_count(arr)\n    return inv\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],  # 1: empty\n        [1],  # 2: single element\n        [1,2,3,4,5],  # 3: already sorted\n        [5,4,3,2,1],  # 4: reverse sorted\n        [2,3,8,6,1],  # 5: mixed distinct integers\n        [1,3,5,2,4,6],  # 6: interleaved\n        [10,3,7,4,9,1,8,2,5,6],  # 7: length 10 permutation\n    ]\n\n    results = []\n    for case in test_cases:\n        result = count_inversions(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205394"}, {"introduction": "网格中的最小代价路径问题是进入动态规划世界的经典入门练习。这个问题的网格结构很自然地将大问题分解为更小的子问题，清晰地展示了最优子结构和重叠子问题这两个动态规划的核心原则。通过解决这个问题，你将学会如何定义状态、推导状态转移方程，并自底向上地构建解决方案。[@problem_id:3205401]", "problem": "考虑一个具有整数坐标的 $(n+1) \\times (m+1)$ 网格，其中每个单元格 $(i,j)$（$0 \\le i \\le n$ 且 $0 \\le j \\le m$）都有一个由函数 $c(i,j)$ 给出的非负或负的进入成本。一条路径从进入单元格 $(0,0)$ 开始，并在进入单元格 $(n,m)$ 时结束。在每一步，路径只能移动到坐标为 $(i+1,j)$ 或 $(i,j+1)$ 的单元格，确保移动在两个索引上都是单调非递减的。路径的总成本定义为沿途所有进入单元格的成本之和，包括起始单元格和结束单元格。您的任务是设计一个动态规划算法，根据这些规则计算从 $(0,0)$ 到达 $(n,m)$ 的最小可能总成本，然后实现一个程序，将此算法应用于指定的测试套件。\n\n设计必须基于有向无环图算法设计的基本原则，特别是基于网格结构和允许移动的最优子结构和重叠子问题的概念。允许向右和向下移动的网格构成一个有向无环图，且路径成本是可加的。不允许使用任何启发式捷径；该方法必须通过对子问题的原则性推理得出。\n\n不涉及物理单位。测试套件中的所有输出都必须记录为整数。\n\n使用以下测试套件，其中每个用例由 $(n,m)$ 和成本函数 $c(i,j)$ 指定：\n\n- 测试用例 1：$n=2, m=3$，其中对于范围内的所有 $i,j$，有 $c(i,j)=i^2+2j+1$。\n- 测试用例 2：$n=0, m=0$，其中对于范围内的所有 $i,j$，有 $c(i,j)=5$。\n- 测试用例 3：$n=3, m=3$，其中对于范围内的所有 $i,j$，有 $c(i,j)=1$，但 $c(1,1)=1000$ 且 $c(2,2)=1000$。\n- 测试用例 4：$n=5, m=0$，其中对于范围内的所有 $i,j$，有 $c(i,j)=i$。\n- 测试用例 5：$n=3, m=5$，其中对于范围内的所有 $i,j$，有 $c(i,j)=(-1)^{i+j}$。\n\n您的程序应计算每个测试用例的最小总成本，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4,x_5]$），$x_k$ 是测试用例 k 的最小总成本。", "solution": "该问题提法恰当，并且在科学上基于有向无环图的算法设计原则。这是一个经典的网格上最小成本路径问题，可以使用动态规划高效解决。\n\n该问题可以建模为在有向无环图（DAG）中寻找最小权重路径。$(n+1) \\times (m+1)$ 网格的单元格代表图的顶点 $(i,j)$，其中 $0 \\le i \\le n$ 且 $0 \\le j \\le m$。允许的移动，即从一个单元格 $(i,j)$ 移动到 $(i+1,j)$ 或 $(i,j+1)$，定义了图的有向边。具体来说，对于每个单元格 $(i,j)$，如果 $i  n$，则存在一条到 $(i+1,j)$ 的有向边；如果 $j  m$，则存在一条到 $(i,j+1)$ 的有向边。由于移动总是前往两个坐标索引都大于或等于当前位置的单元格（单调非递减），因此无法形成环，证实该图是一个有向无环图。进入单元格的成本 $c(i,j)$ 可被视为与每个顶点相关的权重。路径的总成本是沿途所有顶点的权重之和。\n\n该问题结构表现出两个使其适合使用动态规划的关键特性：\n$1$. **最优子结构**：从起始单元格 $(0,0)$ 到任何单元格 $(i,j)$ 的最小成本路径，必定是通过扩展从其某个直接前驱节点（即 $(i-1,j)$ 或 $(i,j-1)$）出发的最小成本路径而形成的。\n$2$. **重叠子问题**：到达特定单元格 $(i,j)$ 的最小成本在计算后续单元格（特别是 $(i+1,j)$ 和 $(i,j+1)$）的最小成本时会被多次引用。\n\n我们将子问题定义为计算从起始单元格 $(0,0)$ 到达任意单元格 $(i,j)$ 的最小成本。令 $DP(i,j)$ 表示此最小成本。我们的最终目标是求出 $DP(n,m)$。\n\n$DP(i,j)$ 的递推关系推导如下：\n\n**基础情况**：到达起始单元格 $(0,0)$ 的路径只包含该单元格本身。因此，到达 $(0,0)$ 的最小成本就是它自身的成本。\n$$DP(0,0) = c(0,0)$$\n\n**递推步骤**：对于任何其他单元格 $(i,j)$，路径必须从其某个有效的前驱节点到达。\n- 对于顶行中 $i=0$ 且 $j0$ 的单元格，唯一有效的前驱节点是 $(0,j-1)$。到达 $(0,j)$ 的最小成本路径是到达 $(0,j-1)$ 的最小成本路径后接着移动到 $(0,j)$。因此：\n$$DP(0,j) = DP(0,j-1) + c(0,j) \\quad \\text{for } j  0$$\n- 对于第一列中 $i0$ 且 $j=0$ 的单元格，唯一有效的前驱节点是 $(i-1,0)$。类似地：\n$$DP(i,0) = DP(i-1,0) + c(i,0) \\quad \\text{for } i  0$$\n- 对于任何其他 $i0$ 且 $j0$ 的单元格 $(i,j)$，路径必须来自 $(i-1,j)$（向下移动）或 $(i,j-1)$（向右移动）。根据最优性原理，我们必须选择路径成本最小的前驱节点。到达 $(i,j)$ 的总成本是其自身成本加上到达其前驱节点的最小成本：\n$$DP(i,j) = c(i,j) + \\min(DP(i-1,j), DP(i,j-1)) \\quad \\text{for } i0, j0$$\n\n我们可以用自底向上的方式迭代计算 $DP(i,j)$ 的值。我们创建一个 $(n+1) \\times (m+1)$ 的表来存储 $DP$ 值。计算过程如下：\n$1$. 使用基础情况初始化 $DP(0,0)$。\n$2$. 使用 $DP(0,j)$ 的递推关系填充表的第一行（$i=0$）。\n$3$. 使用 $DP(i,0)$ 的递推关系填充表的第一列（$j=0$）。\n$4$. 对于从 $1$ 到 $n$ 的 $i$ 和从 $1$ 到 $m$ 的 $j$，使用 $DP(i,j)$ 的通用递推关系填充表的其余部分。每个 $DP(i,j)$ 仅依赖于已经计算过的值（即 $DP(i-1,j)$ 和 $DP(i,j-1)$）。\n\n问题的最终答案是存储在目标单元格 $DP(n,m)$ 处的值。该算法的时间复杂度是 $O(nm)$，因为 $(n+1) \\times (m+1)$ 表中的每个单元格都只被访问一次。存储 DP 表的空间复杂度也是 $O(nm)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef min_cost_path(n: int, m: int, cost_func) -> int:\n    \"\"\"\n    Computes the minimum cost path on a grid using dynamic programming.\n\n    Args:\n        n: The maximum row index (grid is (n+1) x (m+1)).\n        m: The maximum column index.\n        cost_func: A function c(i, j) that returns the cost of cell (i, j).\n\n    Returns:\n        The minimum cost to travel from (0,0) to (n,m).\n    \"\"\"\n    # Grid dimensions are (n+1) x (m+1)\n    rows, cols = n + 1, m + 1\n\n    # Create the cost matrix C using the provided cost function.\n    # np.vectorize is used to apply the element-wise function over the indices.\n    indices = np.indices((rows, cols))\n    C = np.vectorize(cost_func)(indices[0], indices[1])\n\n    # DP table to store the minimum cost to reach cell (i, j)\n    DP = np.zeros((rows, cols), dtype=int)\n\n    # Base case: cost to reach (0,0) is just its own cost\n    DP[0, 0] = C[0, 0]\n\n    # Fill the first row (can only come from the left)\n    for j in range(1, cols):\n        DP[0, j] = C[0, j] + DP[0, j - 1]\n\n    # Fill the first column (can only come from above)\n    for i in range(1, rows):\n        DP[i, 0] = C[i, 0] + DP[i - 1, 0]\n    \n    # Fill the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            DP[i, j] = C[i, j] + min(DP[i - 1, j], DP[i, j - 1])\n\n    # The result is the minimum cost to reach the bottom-right cell\n    return int(DP[n, m])\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {'n': 2, 'm': 3, 'cost_func': lambda i, j: i**2 + 2*j + 1},\n        {'n': 0, 'm': 0, 'cost_func': lambda i, j: 5},\n        {'n': 3, 'm': 3, 'cost_func': lambda i, j: 1000 if (i, j) in [(1, 1), (2, 2)] else 1},\n        {'n': 5, 'm': 0, 'cost_func': lambda i, j: i},\n        {'n': 3, 'm': 5, 'cost_func': lambda i, j: (-1)**(i + j)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = min_cost_path(case['n'], case['m'], case['cost_func'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205401"}, {"introduction": "旅行商问题 (TSP) 是一个著名的 NP 难问题，在理论和实践中都具有重要意义。尽管目前尚不存在多项式时间的解法，但动态规划（特别是 Held-Karp 算法）能够为小规模实例找到精确的最优解。本练习将展示一种高级动态规划技术，即使用“状态压缩”或“位掩码 (bitmask)”来表示访问过的城市子集，从而有效地在指数级的状态空间中进行搜索。[@problem_id:3205307]", "problem": "设计并实现一个程序，该程序使用位掩码的动态规划方法解决小规模实例的旅行商问题 (TSP)，然后从第一性原理推导其最坏情况下的时间和空间复杂度。该问题定义如下：给定一个包含 $n$ 个城市（标记为 $\\{0,1,\\ldots,n-1\\}$）的完全有向或无向加权图，其边权重为非负整数，找到一条成本最低的哈密顿回路，该回路从城市 $0$ 出发，恰好访问每个城市一次，然后返回城市 $0$。假设 $n \\leq 20$，所有对角线上的元素均为 $0$；如果图是无向的，则权重是对称的。您的任务是完成以下工作。\n\n- 基于最优性原理和紧凑的位掩码子集表示，实现一个动态规划算法，以计算每个给定实例的精确最小旅行成本。使用精确整数算术。\n- 使用子问题分解和动态规划最优性原理的基本概念来证明您的算法设计的合理性，而不是依赖于预先记忆的公式。您还必须通过对子集和状态转移进行计数论证，来推导并证明在最坏情况下以 $n$ 为变量的时间和空间复杂度。\n- 对于下方的每个测试实例，计算从城市 $0$ 开始并结束于城市 $0$ 的最小旅行成本。所有边权重都是整数，所有测试用例的输出也都是整数。\n\n使用以下测试套件。每个邻接矩阵都明确地以数组的数组形式给出，其中第 $i$ 行第 $j$ 列的条目等于从城市 $i$ 到城市 $j$ 的旅行成本。\n\n- 测试用例 A: $n = 1$\n  - 矩阵: $[[\\,0\\,]]$.\n- 测试用例 B: $n = 2$\n  - 矩阵: $[[\\,0,\\,3\\,],[\\,4,\\,0\\,]]$.\n- 测试用例 C: $n = 4$\n  - 矩阵:\n    $[\n      [\\,0,\\,10,\\,15,\\,20\\,],\n      [\\,10,\\,0,\\,35,\\,25\\,],\n      [\\,15,\\,35,\\,0,\\,30\\,],\n      [\\,20,\\,25,\\,30,\\,0\\,]\n    ]$.\n- 测试用例 D: $n = 5$ (非对称有向)\n  - 矩阵:\n    $[\n      [\\,0,\\,5,\\,1,\\,5,\\,5\\,],\n      [\\,1,\\,0,\\,7,\\,8,\\,7\\,],\n      [\\,5,\\,5,\\,0,\\,1,\\,5\\,],\n      [\\,5,\\,7,\\,9,\\,0,\\,1\\,],\n      [\\,5,\\,1,\\,5,\\,1,\\,0\\,]\n    ]$.\n  特意设计的廉价回路是 $0 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 0$，成本为 $5$（此回路上的每条边成本均为 $1$，第一行中所有其他非对角线边的成本为 $5$；其他行的选择是为了保持所有条目为非负整数）。\n- 测试用例 E: $n = 10$ (对称无向)\n  - 矩阵:\n    $[\n      [\\,0,\\,8,\\,12,\\,3,\\,20,\\,15,\\,9,\\,10,\\,19,\\,7\\,],\n      [\\,8,\\,0,\\,13,\\,6,\\,5,\\,12,\\,14,\\,9,\\,3,\\,16\\,],\n      [\\,12,\\,13,\\,0,\\,9,\\,13,\\,7,\\,6,\\,12,\\,11,\\,4\\,],\n      [\\,3,\\,6,\\,9,\\,0,\\,4,\\,8,\\,16,\\,7,\\,5,\\,14\\,],\n      [\\,20,\\,5,\\,13,\\,4,\\,0,\\,2,\\,12,\\,6,\\,15,\\,9\\,],\n      [\\,15,\\,12,\\,7,\\,8,\\,2,\\,0,\\,3,\\,17,\\,10,\\,11\\,],\n      [\\,9,\\,14,\\,6,\\,16,\\,12,\\,3,\\,0,\\,1,\\,13,\\,2\\,],\n      [\\,10,\\,9,\\,12,\\,7,\\,6,\\,17,\\,1,\\,0,\\,4,\\,8\\,],\n      [\\,19,\\,3,\\,11,\\,5,\\,15,\\,10,\\,13,\\,4,\\,0,\\,6\\,],\n      [\\,7,\\,16,\\,4,\\,14,\\,9,\\,11,\\,2,\\,8,\\,6,\\,0\\,]\n    ]$.\n\n最终输出格式。您的程序应生成单行输出，其中包含按测试用例 A 到 E 的顺序排列的结果，格式为逗号分隔的列表并用方括号括起来。例如，对于通用结果 $r_A$、$r_B$、$r_C$、$r_D$ 和 $r_E$，输出必须是\n$[r_A,r_B,r_C,r_D,r_E]$\n不含任何额外的空格或文本。\n\n注意事项和说明。\n- 使用标准计算模型，在该模型中，对固定宽度整数的位运算被视为常数时间操作。\n- 本问题不涉及角度和物理单位。\n- 每个测试用例的答案都是整数。", "solution": "该问题陈述经评估有效。这是一个在算法设计领域中定义明确、具有科学依据的问题，具体涉及旅行商问题（TSP）的精确解法。该问题是自包含的，提供了所有必要的数据、定义和约束。指定的方法——使用位掩码的动态规划——是解决小规模TSP实例的标准且正确的方法。约束条件（$n \\leq 20$）与此精确算法已知的指数级复杂度相符。\n\n**1. 算法设计：基于最优性原理的动态规划**\n\n旅行商问题（TSP）旨在寻找加权图中的最小成本哈密顿回路。我们的任务是找到这样一个从特定城市（标记为 $0$）出发并返回的回路。动态规划解法的核心在于定义一个子问题，该子问题可以被逐步扩展以解决更大的问题，这一特性被称为最优子结构。\n\n设所有城市的集合为 $V = \\{0, 1, \\ldots, n-1\\}$。一次旅行是这些城市的一个排列。我们固定起始城市为 $0$。一条从城市 $0$ 开始并访问城市集合 $S \\subseteq V$ 的路径是一个不同城市的序列 $(c_0, c_1, \\ldots, c_k)$，其中 $c_0=0$ 且 $\\{c_0, \\ldots, c_k\\} = S$。\n\n**子问题定义：**\n设 $dp(S, j)$ 为从城市 $0$ 开始，恰好访问集合 $S \\subseteq V$ 中的每个城市一次，并最终停在城市 $j \\in S$ 的路径的最小成本。起始城市 $0$ 必须在 $S$ 中。\n\n**最优性原理与递推关系：**\n最优性原理指出，一个问题的最优解包含其子问题的最优解。考虑状态 $(S, j)$ 的一条最优路径，其中 $|S|  1$。这条路径必然是从集合 $S \\setminus \\{j\\}$ 中的某个城市 $k$ 到达城市 $j$ 的。为了使整条路径最优，从城市 $0$ 到城市 $k$ 并访问了 $S \\setminus \\{j\\}$ 中所有城市的子路径也必须是最优的。这正是子问题 $dp(S \\setminus \\{j\\}, k)$。将这个最优子路径扩展到城市 $j$ 的成本是 $dp(S \\setminus \\{j\\}, k) + \\text{cost}(k, j)$，其中 $\\text{cost}(k, j)$ 是从 $k$ 到 $j$ 的边权重。为了找到状态 $(S, j)$ 的最小成本，我们必须考虑所有可能的前驱城市 $k$。这引出了以下递推关系：\n\n$$\ndp(S, j) = \\min_{k \\in S \\setminus \\{j\\}} \\{ dp(S \\setminus \\{j\\}, k) + \\text{cost}(k, j) \\}\n$$\n\n**基本情况：**\n最小的子问题是从城市 $0$ 开始到城市 $0$ 结束，只访问了集合 $\\{0\\}$ 的路径。这条平凡路径的成本为 $0$。\n$$\ndp(\\{0\\}, 0) = 0\n$$\n对于任何其他城市 $j \\neq 0$，$dp(\\{0\\}, j)$ 是未定义的，因为只包含城市 $0$ 的路径不能在 $j$ 结束。我们可以用一个无穷大的初始值来表示这一点。\n\n**使用位掩码实现：**\n已访问城市的集合 $S$ 可以用一个长度为 $n$ 的整数位掩码来高效表示。掩码是一个整数，如果城市 $i \\in S$，则其第 $i$ 位为 $1$，否则为 $0$。\n- 集合 $S$ 由一个整数 `mask` 表示。\n- 条件 $j \\in S$ 通过位运算 `(mask  j)  1 == 1` 来检查。\n- 集合 $S \\setminus \\{j\\}$ 由 `mask ^ (1  j)` 表示。\n\nDP状态变为 $dp[\\text{mask}][j]$。我们可以通过按掩码大小（即置位比特数）递增的顺序，或者更简单地，仅按掩码本身的数值递增顺序来计算 $dp[\\text{mask}][j]$ 的值。由于子问题的掩码 `prev_mask` 在数值上总是小于当前问题的 `mask`，因此其值已经被计算过了。\n\n算法流程如下：\n1. 初始化一个 $2^n \\times n$ 的表 $dp$，用无穷大填充，表示成本。\n2. 设置基本情况：$dp[1][0] = 0$。（集合 $\\{0\\}$ 的掩码是 $2^0 = 1$）。\n3. 从 $2$ 到 $2^n - 1$ 遍历 `mask`。对于每个 `mask`，遍历所有可能的终点城市 `j`（从 $0$ 到 $n-1$）。\n4. 如果城市 `j` 在 `mask` 所代表的集合中，则寻找最优子路径。令 `prev_mask = mask ^ (1  j)`。遍历所有可能的前驱城市 `k`（从 $0$ 到 $n-1$）。\n5. 如果城市 `k` 在 `prev_mask` 所代表的集合中，应用递推公式：$dp[\\text{mask}][j] = \\min(dp[\\text{mask}][j], dp[\\text{prev_mask}][k] + \\text{cost}[k][j])$。\n\n**最终解：**\n在DP表完全填充后，条目 $dp[(1 \\ll n) - 1][j]$ 包含了从城市 $0$ 到城市 $j$ 访问所有 $n$ 个城市的最小路径成本。最后一步是通过从城市 $j$ 返回到城市 $0$ 来完成回路。我们必须检查所有可能的终点 $j \\in \\{1, \\ldots, n-1\\}$，并找到产生最小总旅行成本的那个。\n$$\n\\text{最小旅行成本} = \\min_{j \\in \\{1, \\ldots, n-1\\}} \\{ dp[(1 \\ll n) - 1][j] + \\text{cost}(j, 0) \\}\n$$\n对于 $n=1$ 的边缘情况，旅行是平凡的 $0 \\to 0$，成本为 $0$。\n\n**2. 复杂度分析**\n\n**空间复杂度：**\n主要的数据结构是DP表，它存储了所有子问题的成本。该表有一个维度用于 `mask`，另一个维度用于终点城市 `j`。\n- 可能的 `mask` 数量为 $2^n$。\n- 可能的终点城市数量为 $n$。\n因此，状态（以及DP表中的条目）总数为 $n \\cdot 2^n$。假设每个条目需要常数存储空间，则空间复杂度为 $O(n \\cdot 2^n)$。\n\n**时间复杂度：**\n运行时间由填充DP表所需的操作数决定。这等同于计算每个状态转移的成本之和。计算一个状态 $dp[\\text{mask}][j]$ 涉及遍历所有可能的前驱 $k$。\n基本计算的总数与以下表达式成正比：\n$$\n\\sum_{\\text{mask}=1}^{2^n-1} \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} \\text{work}(mask, j, k)\n$$\n其中，如果 $j$ 在 `mask` 中且 $k$ 在不含 $j$ 的 `mask` 中，则 `work` 为 $O(1)$。这可以通过按已访问城市集合的大小 $s = |\\text{S}|$ 对状态进行分组来更精确地分析。\n\n设 $s$ 是掩码中置位比特的数量。大小为 $s$ 的掩码数量由二项式系数 $\\binom{n}{s}$ 给出。对于每个这样的掩码，我们可以选择 $s$ 个城市中的任意一个作为终点 $j$。对于 `mask` 和 $j$ 的每种选择，我们遍历所有 $s-1$ 个可能的前驱城市 $k \\in S \\setminus \\{j\\}$。\n\n因此，内层循环执行的总次数为：\n$$\n\\text{时间} \\propto \\sum_{s=1}^{n} \\left( \\binom{n}{s} \\cdot s \\cdot (s-1) \\right)\n$$\n我们使用组合恒等式 $\\binom{n}{s} s = n \\binom{n-1}{s-1}$ 和 $\\binom{n-1}{s-1} (s-1) = (n-1) \\binom{n-2}{s-2}$：\n$$\n\\sum_{s=2}^{n} \\binom{n}{s} s(s-1) = \\sum_{s=2}^{n} n \\binom{n-1}{s-1} (s-1) = n \\sum_{s=2}^{n} (n-1) \\binom{n-2}{s-2}\n$$\n令 $p = s-2$。总和变为：\n$$\nn(n-1) \\sum_{p=0}^{n-2} \\binom{n-2}{p}\n$$\n根据二项式定理，$\\sum_{p=0}^{m} \\binom{m}{p} = 2^m$。此处，$m=n-2$。\n$$\nn(n-1) \\cdot 2^{n-2}\n$$\n此表达式表明时间复杂度由与 $n^2 2^n$ 成正比的项主导。计算旅行成本的最后一步需要 $O(n)$ 时间，可以忽略不计。因此，该算法的最坏情况时间复杂度为 $O(n^2 \\cdot 2^n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tsp(cost_matrix: np.ndarray) -> int:\n    \"\"\"\n    Solves the Traveling Salesperson Problem using dynamic programming with bitmasking.\n\n    Args:\n        cost_matrix: An n x n numpy array representing the cost of travel between cities.\n\n    Returns:\n        The minimum cost of a Hamiltonian cycle starting and ending at city 0.\n    \"\"\"\n    n = cost_matrix.shape[0]\n\n    # Handle the trivial case where n=1. The tour is 0 -> 0 with cost 0.\n    if n = 1:\n        return 0\n\n    # DP table: dp[mask][j] stores the minimum cost of a path from city 0\n    # to city j, visiting the set of cities represented by 'mask'.\n    # Mask is an integer where the i-th bit is 1 if city i has been visited.\n    dp = np.full((1  n, n), float('inf'))\n\n    # Base case: The path from city 0 to city 0, visiting only {0}, has cost 0.\n    # The mask for {0} is 1 (binary ...001).\n    dp[1, 0] = 0\n\n    # Iterate through all subsets (masks) of cities, from size 2 up to n.\n    # The mask must contain the starting city 0, so bit 0 must be set.\n    for mask in range(3, 1  n, 2):  # iterate over odd masks > 1\n        # 'j' is the current endpoint of the path.\n        for j in range(1, n):\n            # Check if city 'j' is in the current subset 'mask'.\n            if (mask >> j)  1:\n                # 'prev_mask' represents the subset of cities visited before reaching 'j'.\n                prev_mask = mask ^ (1  j)\n                \n                # 'k' is the city visited just before 'j'. It can be any city in 'prev_mask'.\n                for k in range(n):\n                    if (prev_mask >> k)  1:\n                        # If a path to k exists, update the path to j.\n                        if dp[prev_mask, k] != float('inf'):\n                            dp[mask, j] = min(dp[mask, j], dp[prev_mask, k] + cost_matrix[k, j])\n\n    # After filling the DP table, find the minimum total tour cost.\n    # A full tour visits all cities, so the mask is (1  n) - 1.\n    final_mask = (1  n) - 1\n    min_tour_cost = float('inf')\n\n    # We need to find the minimum cost by returning to city 0 from any other city j.\n    for j in range(1, n):\n        if dp[final_mask, j] != float('inf'):\n            tour_cost = dp[final_mask, j] + cost_matrix[j, 0]\n            if tour_cost  min_tour_cost:\n                min_tour_cost = tour_cost\n\n    return int(min_tour_cost)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        np.array([[0]]),\n        np.array([[0, 3], [4, 0]]),\n        np.array([\n            [0, 10, 15, 20],\n            [10, 0, 35, 25],\n            [15, 35, 0, 30],\n            [20, 25, 30, 0]\n        ]),\n        np.array([\n            [0, 5, 1, 5, 5],\n            [1, 0, 7, 8, 7],\n            [5, 5, 0, 1, 5],\n            [5, 7, 9, 0, 1],\n            [5, 1, 5, 1, 0]\n        ]),\n        np.array([\n            [0, 8, 12, 3, 20, 15, 9, 10, 19, 7],\n            [8, 0, 13, 6, 5, 12, 14, 9, 3, 16],\n            [12, 13, 0, 9, 13, 7, 6, 12, 11, 4],\n            [3, 6, 9, 0, 4, 8, 16, 7, 5, 14],\n            [20, 5, 13, 4, 0, 2, 12, 6, 15, 9],\n            [15, 12, 7, 8, 2, 0, 3, 17, 10, 11],\n            [9, 14, 6, 16, 12, 3, 0, 1, 13, 2],\n            [10, 9, 12, 7, 6, 17, 1, 0, 4, 8],\n            [19, 3, 11, 5, 15, 10, 13, 4, 0, 6],\n            [7, 16, 4, 14, 9, 11, 2, 8, 6, 0]\n        ])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_tsp(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205307"}]}