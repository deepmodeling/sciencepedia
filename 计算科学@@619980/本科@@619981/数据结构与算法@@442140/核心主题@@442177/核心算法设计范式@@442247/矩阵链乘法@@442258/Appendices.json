{"hands_on_practices": [{"introduction": "在我们构建算法来寻找最优成本之前，不妨先来一次“逆向工程”。这个练习将帮助你巩固矩阵维度、乘法成本以及“最优”括号化方案含义之间的基本关系。通过从一个已知的最优解反向推导矩阵的维度，你将对为何这个问题本身具有挑战性获得更深刻的直觉。[@problem_id:3249096]", "problem": "给定一个由三个矩阵组成的链 $A_1$、$A_2$ 和 $A_3$，它们的维度兼容，$A_1 \\in \\mathbb{R}^{d_0 \\times d_1}$，$A_2 \\in \\mathbb{R}^{d_1 \\times d_2}$ 以及 $A_3 \\in \\mathbb{R}^{d_2 \\times d_3}$，其中 $d_0$、$d_1$、$d_2$ 和 $d_3$ 是未知的正整数。假设已知（例如，通过完整的动态规划计算）该链的最优加括号方式为 $(A_1A_2)A_3$，并且此最优计算的标量乘法次数的精确最小值为 $C^{\\ast} = 204$。此外，还告知您，单独计算子乘积 $A_1A_2$ 和 $A_2A_3$ 分别需要 $120$ 次和 $210$ 次标量乘法。\n\n仅从矩阵乘法的标准定义及其标量运算次数出发，推导在 $(A_1A_2)A_3$ 为最优加括号方式的条件下，维度 $d_0$、$d_1$、$d_2$ 和 $d_3$ 必须满足的等式和不等式。然后，计算比值 $d_1/d_0$。将最终答案表示为最简分数。无需四舍五入，不涉及单位。", "solution": "本问题要求基于矩阵链乘法问题的成本信息，确定两个矩阵维度之比 $d_1/d_0$。\n\n首先，我们使用矩阵乘法成本的标准定义来形式化给定的信息。一个维度为 $p \\times q$ 的矩阵与一个维度为 $q \\times r$ 的矩阵相乘，需要 $p \\times q \\times r$ 次标量乘法。\n\n链中的矩阵为 $A_1 \\in \\mathbb{R}^{d_0 \\times d_1}$、$A_2 \\in \\mathbb{R}^{d_1 \\times d_2}$ 和 $A_3 \\in \\mathbb{R}^{d_2 \\times d_3}$，其中 $d_0, d_1, d_2, d_3$ 是正整数。\n\n我们已知单独计算两个子乘积的成本：\n1.  计算 $A_1A_2$ 的成本为 $120$。其维度为 $d_0 \\times d_1$ 和 $d_1 \\times d_2$。因此，标量乘法次数由维度之积给出：\n    $$d_0 d_1 d_2 = 120$$\n2.  计算 $A_2A_3$ 的成本为 $210$。其维度为 $d_1 \\times d_2$ 和 $d_2 \\times d_3$。相关成本为：\n    $$d_1 d_2 d_3 = 210$$\n\n对于一个包含三个矩阵的链，其完整乘积 $A_1A_2A_3$ 有两种可能的加括号方式：\n-   $P_1: (A_1A_2)A_3$\n-   $P_2: A_1(A_2A_3)$\n\n让我们计算每种加括号方式的总成本。\n$P_1$ 的成本是计算中间乘积 $A_{12} = A_1A_2$ 的成本，加上将 $A_{12}$ 与 $A_3$ 相乘的成本。矩阵 $A_{12}$ 的维度为 $d_0 \\times d_2$。\n计算 $A_{12}$ 的成本已知为 $d_0 d_1 d_2 = 120$。\n将 $A_{12}$ (大小为 $d_0 \\times d_2$) 与 $A_3$ (大小为 $d_2 \\times d_3$) 相乘的成本是 $d_0 d_2 d_3$。\n所以，$P_1$ 的总成本是 $C_1 = d_0 d_1 d_2 + d_0 d_2 d_3$。\n\n$P_2$ 的成本是计算中间乘积 $A_{23} = A_2A_3$ 的成本，加上将 $A_1$ 与 $A_{23}$ 相乘的成本。矩阵 $A_{23}$ 的维度为 $d_1 \\times d_3$。\n计算 $A_{23}$ 的成本已知为 $d_1 d_2 d_3 = 210$。\n将 $A_1$ (大小为 $d_0 \\times d_1$) 与 $A_{23}$ (大小为 $d_1 \\times d_3$) 相乘的成本是 $d_0 d_1 d_3$。\n所以，$P_2$ 的总成本是 $C_2 = d_1 d_2 d_3 + d_0 d_1 d_3$。\n\n题目说明 $(A_1A_2)A_3$ 是最优加括号方式，且最小乘法次数为 $C^{\\ast} = 204$。这蕴含了两个条件：\n1.  最优路径的成本为 $C_1 = C^{\\ast} = 204$。\n2.  最优路径的成本小于或等于任何其他路径的成本，即 $C_1 \\le C_2$。\n\n使用第一个条件，我们得到：\n$$C_1 = d_0 d_1 d_2 + d_0 d_2 d_3 = 204$$\n我们已经知道 $d_0 d_1 d_2 = 120$。将此值代入 $C_1$ 的方程中：\n$$120 + d_0 d_2 d_3 = 204$$\n求解项 $d_0 d_2 d_3$：\n$$d_0 d_2 d_3 = 204 - 120 = 84$$\n\n现在我们有一个包含三个方程的方程组，关联了这些维度的乘积：\n(i) $d_0 d_1 d_2 = 120$\n(ii) $d_1 d_2 d_3 = 210$\n(iii) $d_0 d_2 d_3 = 84$\n\n问题要求的是比值 $d_1/d_0$ 的值。我们可以通过将方程(ii)除以方程(iii)来得到这个比值。由于所有维度 $d_i$ 都是正整数，乘积 $d_1 d_2 d_3$ 和 $d_0 d_2 d_3$ 均不为零，因此除法是有效的操作。\n$$\\frac{d_1 d_2 d_3}{d_0 d_2 d_3} = \\frac{210}{84}$$\n分子和分母中的项 $d_2$ 和 $d_3$ 可以消掉：\n$$\\frac{d_1}{d_0} = \\frac{210}{84}$$\n为了化简分数，我们可以找到 $210$ 和 $84$ 的最大公约数。\n$210 = 2 \\times 3 \\times 5 \\times 7$\n$84 = 2^2 \\times 3 \\times 7$\n最大公约数是 $2 \\times 3 \\times 7 = 42$。\n或者，我们也可以看出 $210 = 21 \\times 10$ 和 $84 = 21 \\times 4$。\n$$\\frac{d_1}{d_0} = \\frac{21 \\times 10}{21 \\times 4} = \\frac{10}{4} = \\frac{5}{2}$$\n\n作为一致性检验，我们可以验证最优性条件 $C_1 \\le C_2$。\n$$d_0 d_1 d_2 + d_0 d_2 d_3 \\le d_1 d_2 d_3 + d_0 d_1 d_3$$\n代入已知值：\n$$120 + 84 \\le 210 + d_0 d_1 d_3$$\n$$204 \\le 210 + d_0 d_1 d_3$$\n由于 $d_0, d_1, d_3$ 是正整数，它们的乘积 $d_0 d_1 d_3$ 是一个正整数。不等式成立，因为 $204$ 小于 $210$ 加上一个正值。这证实了问题数据是内部一致的。因此，比值 $d_1/d_0$ 的推导被证实是可靠的。\n最终答案是该比值的最简分数。", "answer": "$$\\boxed{\\frac{5}{2}}$$", "id": "3249096"}, {"introduction": "标准的矩阵链乘法问题旨在最小化计算成本，但其底层的动态规划框架远比这更加灵活。这个练习要求你反其道而行之，找出“最差”的括号化方案。通过将递推关系中的 `min` 操作简单地替换为 `max`，你可以体会到最优子结构方法的通用性，并加深对动态规划模型本身的理解。[@problem_id:3249152]", "problem": "考虑一个由数组 $p = [p_0, p_1, \\dots, p_n]$ 表示的矩阵维度序列，其中矩阵 $A_i$ 的维度为 $p_i \\times p_{i+1}$，适用于 $i \\in \\{0, 1, \\dots, n-1\\}$。矩阵乘法这个二元运算是满足结合律的，因此最终的乘积 $A_0 A_1 \\cdots A_{n-1}$ 是良定义的，但标量乘法的总次数取决于乘积的加括号方式。这个问题的基本依据是两个经过充分检验的事实：一个 $a \\times b$ 矩阵与一个 $b \\times c$ 矩阵相乘的成本是 $a \\cdot b \\cdot c$ 次标量乘法，且矩阵乘法满足结合律。利用这些事实，推导出一个方法，对于一个给定的维度数组 $p$，该方法能确定使得计算乘积 $A_0 A_1 \\cdots A_{n-1}$ 所需标量乘法总次数最大化的加括号方式，并输出在这种最优加括号方式下所需的最大标量乘法次数。你不能假设 $p$ 除了包含正整数项外有任何特殊结构。你必须从所述事实出发，根据第一性原理进行推理，并设计一个从这些原理逻辑推导而来的算法解决方案，不得使用简便公式。\n\n你的程序必须实现这一逻辑，并为以下维度数组测试套件计算最大标量乘法次数：\n案例 $1$：$p = [7, 13]$。\n案例 $2$：$p = [40, 20, 30]$。\n案例 $3$：$p = [5, 10, 3, 12]$。\n案例 $4$：$p = [10, 10, 10, 10, 10]$。\n案例 $5$：$p = [2, 100, 2, 100, 2]$。\n案例 $6$：$p = [6, 12, 8, 10, 20, 5]$。\n\n对于每个案例，输出必须是一个单一整数，等于由 $p$ 定义的矩阵链在所有有效加括号方式下所需标量乘法次数的最大值。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,\\dots,r_6]$），其中 $r_i$ 对应案例 $i$。本问题不涉及物理单位、角度单位或百分比格式；答案是纯整数。\n\n确保你的算法对于任何满足 $n \\ge 0$ 且对所有 $i$ 都有 $p_i \\in \\mathbb{N}$ 的有效输入 $p$ 都是通用且正确的，并且在 $n=1$ 时（单个矩阵“相乘”需要 $0$ 次标量乘法）明确返回 $0$。测试套件的构建旨在覆盖各种场景：只有一个矩阵的边界情况、两个矩阵的平凡乘法、加括号方式会改变成本的小型矩阵链、维度统一导致不同加括号方式成本相同的矩阵链、大小维度交替以突显加括号方式影响的矩阵链，以及测试一般行为的较长矩阵链。", "solution": "基本依据是两个经过充分检验的事实：矩阵乘法满足结合律，以及一个 $a \\times b$ 矩阵与一个 $b \\times c$ 矩阵相乘的成本是 $a \\cdot b \\cdot c$ 次标量乘法。这些事实意味着，虽然矩阵链的最终乘积与加括号方式无关，但标量乘法的总次数取决于乘法的执行顺序。为了设计一个最大化标量乘法总次数的算法，我们使用基于原理的推理来推导一个递推关系，该关系利用了最优子结构和重叠子问题，这启发我们使用动态规划（DP）。\n\n设矩阵链为 $A_0, A_1, \\dots, A_{n-1}$，其中 $A_i$ 的维度为 $p_i \\times p_{i+1}$；因此维度数组为 $p = [p_0, p_1, \\dots, p_n]$。考虑子链 $A_i \\cdots A_j$（其中 $0 \\le i \\le j \\le n-1$）的任何一种加括号方式。在该子链的任何有效加括号方式中，都存在一个索引 $k$（$i \\le k  j$），在这一步进行的最后一次乘法，是将两个子乘积 $(A_i \\cdots A_k)$ 和 $(A_{k+1} \\cdots A_j)$ 结合起来。这次最后乘法所贡献的成本是 $p_i \\cdot p_{k+1} \\cdot p_{j+1}$，因为 $(A_i \\cdots A_k)$ 的维度是 $p_i \\times p_{k+1}$，而 $(A_{k+1} \\cdots A_j)$ 的维度是 $p_{k+1} \\times p_{j+1}$。整个加括号方式的总成本是左子链的成本、右子链的成本以及最后一次乘法的成本之和。\n\n为了最大化标量乘法的总次数，定义 DP 表 $M[i][j]$ 为计算 $A_i \\cdots A_j$ 所需的最大标量乘法次数。基本情况是对于所有 $i$，$M[i][i] = 0$，因为单个矩阵不需要任何乘法。对于 $i  j$，从基本成本分解推导出的递推关系是\n$$\nM[i][j] = \\max_{i \\le k  j} \\big( M[i][k] + M[k+1][j] + p_i \\cdot p_{k+1} \\cdot p_{j+1} \\big).\n$$\n这个递推关系直接源于矩阵乘法的结合律结构以及组合子链的成本可加性。最优子结构性质成立：如果 $A_i \\cdots A_j$ 的一种加括号方式达到了最大总成本，并且在某个 $k$ 处分割，那么 $A_i \\cdots A_k$ 和 $A_{k+1} \\cdots A_j$ 的加括号方式对于它们各自的子问题也必须是最大成本的，否则，用成本更高的加括号方式替换它们将会严格增加总成本，这与最大性相矛盾。因为相同的子链会出现在不同的分割方式中，所以存在重叠子问题。\n\nDP 算法按链长度递增的顺序计算 $M[i][j]$。具体来说，我们遍历从 $2$ 到 $n$ 的子链长度 $\\ell$，并对每对满足 $j = i + \\ell - 1$ 的 $(i,j)$，使用上述递推关系计算 $M[i][j]$。由于对 $\\ell$、$i$ 和 $k$ 的三重嵌套循环，该算法的运行时间为 $O(n^3)$，并使用 $O(n^2)$ 的空间存储表 $M$。\n\n边界情况可以自然地处理。当 $n = 1$（即 $|p| = 2$）时，只有一个矩阵，成本为 $0$。当 $n = 2$（即 $|p| = 3$）时，只有一次乘法，成本为 $p_0 \\cdot p_1 \\cdot p_2$。对于维度统一的情况，如 $p = [10, 10, 10, 10, 10]$，每次乘法的成本 $p_i \\cdot p_{k+1} \\cdot p_{j+1}$ 都等于 $10 \\cdot 10 \\cdot 10 = 1000$，并且所有加括号方式的总成本相同，等于 $1000 \\cdot (n-1)$，其中 $n$ 是矩阵数量，对于 $n = 4$ 即为 $3000$。\n\n以案例 $3$ 的 $p = [5, 10, 3, 12]$（$n=3$ 个矩阵）为例作一个示例推导：\n- 加括号方式 $(A_0 A_1) A_2$ 产生的成本为 $$5 \\cdot 10 \\cdot 3 + 5 \\cdot 3 \\cdot 12 = 150 + 180 = 330.$$\n- 加括号方式 $A_0 (A_1 A_2)$ 产生的成本为 $$10 \\cdot 3 \\cdot 12 + 5 \\cdot 10 \\cdot 12 = 360 + 600 = 960.$$\n因此最大值为 $960$，与 DP 公式一致。对于案例 $5$ 的 $p = [2, 100, 2, 100, 2]$（$n=4$ 个矩阵），DP 将选择一个能强制在大的中间维度上进行乘法的分割，通过 $A_0 (A_1 A_2) A_3$ 或 $A_0 ((A_1 A_2) A_3)$ 这两种加括号方式，得到最大总成本 $40400$，这两种方式都执行了两次涉及 $100 \\times 100$ 中间矩阵的高成本乘法。\n\n最终的程序实现了这种 DP 最大化方法，并为指定的测试套件生成一行整数结果，其格式为用方括号括起来的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_mcm_cost(dimensions):\n    \"\"\"\n    Compute the maximum number of scalar multiplications needed to multiply\n    a chain of matrices with dimension array 'dimensions' using dynamic programming.\n    Each matrix A_i has dimensions dimensions[i] x dimensions[i+1].\n\n    Parameters:\n        dimensions (list[int]): The dimension array p of length n+1.\n\n    Returns:\n        int: The maximum number of scalar multiplications among all parenthesizations.\n    \"\"\"\n    # Number of matrices in the chain\n    n = len(dimensions) - 1\n    # If there is 0 or 1 matrix, cost is 0\n    if n = 1:\n        return 0\n\n    # dp[i][j] will store the maximum cost to compute Ai..Aj (0-based indices for matrices)\n    dp = [[0] * n for _ in range(n)]\n\n    # Consider chain lengths from 2 to n\n    for chain_len in range(2, n + 1):\n        for i in range(0, n - chain_len + 1):\n            j = i + chain_len - 1\n            max_cost = -1\n            # Try all possible splits k between i and j-1\n            for k in range(i, j):\n                cost_left = dp[i][k]\n                cost_right = dp[k + 1][j]\n                # Cost of multiplying the two resulting matrices:\n                # dims: (dimensions[i] x dimensions[k+1]) * (dimensions[k+1] x dimensions[j+1])\n                mult_cost = dimensions[i] * dimensions[k + 1] * dimensions[j + 1]\n                total_cost = cost_left + cost_right + mult_cost\n                if total_cost > max_cost:\n                    max_cost = total_cost\n            dp[i][j] = max_cost\n\n    return dp[0][n - 1]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [7, 13],                  # Case 1: single matrix -> 0\n        [40, 20, 30],             # Case 2: two matrices -> 40*20*30\n        [5, 10, 3, 12],           # Case 3: 3 matrices, nontrivial\n        [10, 10, 10, 10, 10],     # Case 4: uniform dimensions\n        [2, 100, 2, 100, 2],      # Case 5: alternating large/small dimensions\n        [6, 12, 8, 10, 20, 5],    # Case 6: larger chain\n    ]\n\n    results = []\n    for dims in test_cases:\n        result = max_mcm_cost(dims)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3249152"}, {"introduction": "一个真正高效的算法应当能够利用输入的特殊性质。本练习引入了一个实际场景：矩阵链中可能包含单位矩阵，而与单位矩阵相乘在理想情况下是零成本操作。你需要修改标准的动态规划算法，以识别这些特殊情况并相应地调整成本计算，这展示了抽象算法如何为获得实际性能提升而被量身定制。[@problem_id:3249082]", "problem": "给定您几个矩阵链乘法（MCM）问题的实例。每个实例包含一个矩阵链，其维度由一个整数序列指定，以及一个相应的标志序列，指示链中哪些矩阵是单位矩阵。任务是确定在标准矩阵乘法成本模型下，计算整个链的乘积所需的最小标量乘法次数。其中，有一个额外的、有科学依据的简化：当以最优方式实现时，与单位矩阵相乘的标量乘法成本为零。\n\n解决此问题的基础包括以下经过充分检验的定义和事实：\n- 一个矩阵链由一个维度向量 $\\mathbf{p} = (p_0, p_1, \\dots, p_n)$ 定义，其中矩阵 $A_i$ 的维度为 $p_{i-1} \\times p_i$，对于 $i \\in \\{1, 2, \\dots, n\\}$。\n- 矩阵乘法的结合律确保了乘积 $A_1 A_2 \\cdots A_n$ 与括号的加法无关；然而，计算成本取决于乘法的括号如何划分。\n- 将一个维度为 $a \\times b$ 的矩阵与一个维度为 $b \\times c$ 的矩阵相乘的成本（使用朴素算法）是 $a \\cdot b \\cdot c$ 次标量乘法。\n- 一个维度为 $d \\times d$ 的单位矩阵 $I_d$ 对于任何维度兼容的矩阵 $X$ 都满足 $I_d X = X$ 和 $X I_d = X$。在最优实现下，只要维度兼容，与 $I_d$ 相乘可以被视为无操作，其标量乘法成本为零。\n\n您的目标是利用问题的最优子结构和上述单位矩阵简化规则，计算每个给定测试用例的最小标量乘法次数。您不得假设任何矩阵是可逆的，除非它被明确标记为单位矩阵。标记为单位矩阵的矩阵必须是方阵，即必须满足条件 $p_{i-1} = p_i$；如果一个标志指示为单位矩阵但相应维度不相等，则应将该矩阵视为非单位矩阵。\n\n输入作为固定的测试套件嵌入在程序中。没有外部输入。对于每个测试用例，程序必须计算乘完整个链所需的最小标量乘法次数，并利用适当加括号后与单位矩阵相乘成本为零这一事实。\n\n测试套件规范：\n- 用例 $1$：维度 $\\langle 10, 20, 20, 5, 5, 30 \\rangle$；对应于 $(A_1, A_2, A_3, A_4, A_5)$ 的矩阵的单位矩阵标志为 $\\langle 0, 1, 0, 1, 0 \\rangle$。这里 $A_2$ 是一个大小为 $20 \\times 20$ 的单位矩阵，$A_4$ 是一个大小为 $5 \\times 5$ 的单位矩阵。\n- 用例 $2$：维度 $\\langle 7, 7, 7, 7, 7 \\rangle$；单位矩阵标志为 $\\langle 1, 1, 1, 1 \\rangle$。链中的所有矩阵都是大小为 $7 \\times 7$ 的单位矩阵。\n- 用例 $3$：维度 $\\langle 13, 17 \\rangle$；单位矩阵标志为 $\\langle 0 \\rangle$。一个大小为 $13 \\times 17$ 的非单位矩阵。\n- 用例 $4$：维度 $\\langle 8, 8, 3, 3 \\rangle$；单位矩阵标志为 $\\langle 1, 0, 1 \\rangle$。这里 $A_1$ 是一个大小为 $8 \\times 8$ 的单位矩阵，$A_3$ 是一个大小为 $3 \\times 3$ 的单位矩阵。\n- 用例 $5$：维度 $\\langle 4, 4, 4, 4, 9 \\rangle$；单位矩阵标志为 $\\langle 1, 1, 1, 0 \\rangle$。前三个矩阵是大小为 $4 \\times 4$ 的单位矩阵，其后是一个大小为 $4 \\times 9$ 的非单位矩阵。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，例如 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_i$ 是第 $i$ 个测试用例的最小标量乘法次数。\n- 每个 $r_i$ 必须是一个整数。\n\n覆盖性设计：\n- 测试套件检查了一个含有散布的单位矩阵的通用情况（用例 $1$），一个整个链都是单位矩阵的边界情况（用例 $2$），一个单个矩阵的边界情况（用例 $3$），一个两端都是单位矩阵的情况（用例 $4$），以及一个含有连续单位矩阵的情况（用例 $5$）。\n\n您的程序必须仅基于上述原则实现一个正确的解决方案。它不能请求任何用户输入，并且必须严格遵守所描述的最终输出格式。", "solution": "该问题要求计算一个矩阵链乘积所需的最小标量乘法次数，特殊条件是与单位矩阵相乘的成本为零。这是经典矩阵链乘法（MCM）问题的一个变体，可以使用动态规划高效解决。\n\n设 $n$ 个矩阵的链为 $A_1, A_2, \\dots, A_n$。这些矩阵的维度由一个包含 $n+1$ 个整数的序列 $\\mathbf{p} = (p_0, p_1, \\dots, p_n)$ 给出，其中矩阵 $A_i$ 的维度为 $p_{i-1} \\times p_i$，对于 $i \\in \\{1, 2, \\dots, n\\}$。一个附加的标志序列指示哪些矩阵可能是单位矩阵。一个矩阵 $A_i$ 当且仅当它被如此标记并且其维度为方形（即 $p_{i-1} = p_i$）时，才被视作单位矩阵。\n\n解决方案的核心是找到乘积 $A_1 A_2 \\cdots A_n$ 的最优括号划分方式。该问题具有最优子结构：一个矩阵链的最优解包含其子链的最优解。令 $M_{i,j}$ 为计算子链 $A_i \\cdots A_j$ 乘积所需的最小标量乘法次数。我们的目标是计算 $M_{1,n}$。\n\n基本情况是单个矩阵的乘法，不需要任何运算。因此，对于任何 $i \\in \\{1, \\dots, n\\}$：\n$$M_{i,i} = 0$$\n\n对于长度大于一的子链（$i  j$），最后一次乘法必须在两个子乘积 $(A_i \\cdots A_k)$ 和 $(A_{k+1} \\cdots A_j)$ 之间进行，其中 $k$ 是某个分割点，满足 $i \\le k  j$。对于给定的分割点 $k$，总成本是计算两个子乘积的成本加上它们最终相乘的成本之和。\n$$\n\\text{Cost} = M_{i,k} + M_{k+1,j} + (\\text{cost to multiply } (A_i \\cdots A_k) \\text{ and } (A_{k+1} \\cdots A_j))\n$$\n我们必须选择使该总成本最小化的分割点 $k$。\n\n对标准MCM算法的关键修改在于计算最终乘法的成本。标准成本为 $p_{i-1} \\cdot p_k \\cdot p_j$，因为乘积 $(A_i \\cdots A_k)$ 是一个 $p_{i-1} \\times p_k$ 矩阵，而 $(A_{k+1} \\cdots A_j)$ 是一个 $p_k \\times p_j$ 矩阵。然而，如果这两个子乘积中的任何一个是单位矩阵，则乘法成本为零。\n\n当且仅当子链中的每个矩阵 $A_k$（$k$ 从 $i$ 到 $j$）都是单位矩阵时，矩阵乘积 $A_i \\cdots A_j$ 的结果才是一个单位矩阵。让我们定义一个布尔谓词 $IsId_{subchain}(i, j)$，如果乘积 $A_i \\cdots A_j$ 是一个单位矩阵，则其值为真，否则为假。这可以为所有子链预先计算。设 $\\mathcal{I}_k$ 是一个布尔值，如果 $A_k$ 是一个有效的单位矩阵，则为真。那么：\n$$IsId_{subchain}(i, j) \\iff \\bigwedge_{m=i}^{j} \\mathcal{I}_m$$\n\n将两个子乘积相乘的成本，我们称之为 $C_{mult}(i, k, j)$，现在可以定义为：\n$$\nC_{mult}(i, k, j) = \n\\begin{cases} \n0  \\text{if } IsId_{subchain}(i, k) \\text{ or } IsId_{subchain}(k+1, j) \\\\\np_{i-1} \\cdot p_k \\cdot p_j  \\text{otherwise}\n\\end{cases}\n$$\n结合这些元素，我们得到 $M_{i,j}$ 的最终递推关系：\n$$M_{i,j} = \\min_{i \\le k  j} \\left\\{ M_{i,k} + M_{k+1,j} + C_{mult}(i, k, j) \\right\\}$$\n该算法通过求解长度递增的子链（$l = 2, 3, \\dots, n$）的 $M_{i,j}$ 来进行。对于每个长度 $l$，我们为所有可能的起始索引 $i$ 计算 $M_{i, i+l-1}$。这种自底向上的方法确保了当我们计算 $M_{i,j}$ 时，所有更小子问题（如 $M_{i,k}$ 和 $M_{k+1,j}$）的值都已经被计算出来了。最终答案是存储在 $M_{1,n}$ 中的值。\n对于 $n \\le 1$ 个矩阵的问题实例，不需要进行乘法运算，因此成本显然为 $0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the matrix chain multiplication problem for a fixed test suite.\n    \"\"\"\n    \n    # Test suite specification from the problem statement.\n    # Each test case is a tuple: (dimensions_list, identity_flags_list)\n    test_cases = [\n        # Case 1\n        ([10, 20, 20, 5, 5, 30], [0, 1, 0, 1, 0]),\n        # Case 2\n        ([7, 7, 7, 7, 7], [1, 1, 1, 1]),\n        # Case 3\n        ([13, 17], [0]),\n        # Case 4\n        ([8, 8, 3, 3], [1, 0, 1]),\n        # Case 5\n        ([4, 4, 4, 4, 9], [1, 1, 1, 0]),\n    ]\n\n    results = []\n    for p, identity_flags in test_cases:\n        result = _solve_mcm_instance(p, identity_flags)\n        results.append(result)\n\n    # Print the results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_mcm_instance(p, identity_flags):\n    \"\"\"\n    Calculates the minimum multiplication cost for a single MCM instance.\n    Uses a dynamic programming approach modified for zero-cost identity multiplication.\n    \"\"\"\n    n = len(p) - 1\n\n    # For 0 or 1 matrix, the cost is 0 as no multiplications are needed.\n    if n = 1:\n        return 0\n\n    # 1. Preprocessing Step: Identify valid identity matrices\n    # A matrix A_i (0-indexed) is an identity matrix if its flag is set\n    # and it is square (p[i] == p[i+1]).\n    is_identity_matrix = np.zeros(n, dtype=bool)\n    for i in range(n):\n        if identity_flags[i] == 1 and p[i] == p[i+1]:\n            is_identity_matrix[i] = True\n\n    # 2. Precomputation Step: Identify subchains that are products of only identities\n    # is_identity_subchain[i][j] is true if A_i * ... * A_j is an identity matrix.\n    is_identity_subchain = np.zeros((n, n), dtype=bool)\n    for i in range(n):\n        is_identity_subchain[i, i] = is_identity_matrix[i]\n        for j in range(i + 1, n):\n            is_identity_subchain[i, j] = is_identity_subchain[i, j-1] and is_identity_matrix[j]\n\n    # 3. Dynamic Programming Calculation\n    # dp[i][j] stores the minimum cost to multiply matrices A_i through A_j.\n    dp = np.full((n, n), np.inf)\n\n    # Base case: cost for a single matrix (chain length 1) is 0.\n    for i in range(n):\n        dp[i, i] = 0\n\n    # Fill DP table for chain lengths from 2 to n.\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Cost is sum of subproblems + cost of multiplying sub-results.\n                cost = dp[i, k] + dp[k+1, j]\n                \n                # The multiplication cost is non-zero only if both sub-products\n                # are NOT identity matrices.\n                if not is_identity_subchain[i, k] and not is_identity_subchain[k+1, j]:\n                    # Mapping to dimension array p:\n                    # Sub-product A_i...A_k has dimensions p[i] x p[k+1]\n                    # Sub-product A_{k+1}...A_j has dimensions p[k+1] x p[j+1]\n                    # Cost of multiplication is p[i] * p[k+1] * p[j+1]\n                    cost += p[i] * p[k+1] * p[j+1]\n                \n                if cost  dp[i, j]:\n                    dp[i, j] = cost\n                    \n    return int(dp[0, n-1])\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3249082"}]}