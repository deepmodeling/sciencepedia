{"hands_on_practices": [{"introduction": "第一个练习将理论应用于实际计算。通过将“最早截止日期”（EDD）规则应用于一组具体的任务，你将确定最优调度方案及其产生的最小最大延迟。这个练习旨在巩固核心概念，让你亲身体验该算法如何最小化目标函数 [@problem_id:3252772]。", "problem": "在一个模拟密室逃脱的单资源环境中，一位密室逃脱主持人必须一次只向一个团队提供一个提示。共有 $6$ 个提示，每个提示都需要一个已知的不可抢占的持续时间 $t_i$，并有一个截止日期 $d_i$，理想情况下应在该日期前完成以保持团队的进度。主持人从时间 $0$ 开始，并且必须连续不断地提供提示，中间没有空闲时间。目标是，在所有可能的 $6$ 个提示的排序中，确定最大延迟的最小可能值。最大延迟定义为 $L_{\\max} = \\max_{i} \\left(C_i - d_i\\right)$，其中 $C_i$ 是所选序列中提示 $i$ 的完成时间。仅使用完成时间和延迟的核心定义，并通过相邻提示之间的成对交换从基本原理出发进行推理，以证明您所选排序的最优性。\n\n这些提示是：\n- 提示 $1$：$t_1 = 3$， $d_1 = 4$。\n- 提示 $2$：$t_2 = 2$， $d_2 = 7$。\n- 提示 $3$：$t_3 = 5$， $d_3 = 9$。\n- 提示 $4$：$t_4 = 4$， $d_4 = 6$。\n- 提示 $5$：$t_5 = 2$， $d_5 = 3$。\n- 提示 $6$：$t_6 = 6$， $d_6 = 15$。\n\n将可实现的最小 $L_{\\max}$ 值以单个实数的形式陈述。不需要单位。如果您执行任何中间计算，请保持精确；最终答案不需要四舍五入。", "solution": "问题要求计算一组 $6$ 个不可抢占的提示的最大延迟 $L_{\\max}$ 的最小可能值。这些提示由单一资源从时间 $t=0$ 开始提供，并且必须连续提供，意味着没有空闲时间。\n\n首先，我们将问题形式化。设提示集合为 $\\mathcal{J} = \\{1, 2, 3, 4, 5, 6\\}$。每个提示 $i \\in \\mathcal{J}$ 都有一个处理时间 $t_i > 0$ 和一个截止日期 $d_i$。一个调度是 $\\mathcal{J}$ 中提示的一个排列 $\\sigma = (\\sigma(1), \\sigma(2), \\dots, \\sigma(6))$。第一个提示 $\\sigma(1)$ 的开始时间是 $S_{\\sigma(1)} = 0$。对于任何后续的提示 $\\sigma(k)$（其中 $k > 1$），其开始时间是前一个提示的完成时间，即 $S_{\\sigma(k)} = C_{\\sigma(k-1)}$。提示 $\\sigma(k)$ 的完成时间是 $C_{\\sigma(k)} = S_{\\sigma(k)} + t_{\\sigma(k)}$。由于没有空闲时间，序列中位置为 $k$ 的提示的完成时间是所有直至并包括该位置的提示的处理时间之和：\n$$C_{\\sigma(k)} = \\sum_{j=1}^{k} t_{\\sigma(j)}$$\n提示 $i$ 的延迟定义为 $L_i = C_i - d_i$。目标是找到一个调度 $\\sigma$，使得最大延迟 $L_{\\max}(\\sigma) = \\max_{i \\in \\mathcal{J}} (C_i - d_i)$ 最小化。\n\n问题明确要求，必须使用成对交换论证从基本原理出发来证明所选排序的最优性。这个论证确立了最早截止日期（EDD）调度规则的最优性，该规则指出，按截止日期的非递减顺序对提示进行排序可以最小化最大延迟。\n\n让我们来证明 EDD 规则的最优性。考虑一个不是 EDD 调度的任意调度 $S$。如果 $S$ 不是一个 EDD 调度，那么必然存在至少一对提示，比如说提示 $i$ 和提示 $j$，它们被相邻调度，其中 $i$ 紧挨着 $j$ 的前面，但是 $d_i > d_j$。设该调度的形式为 $S = (\\pi_1, i, j, \\pi_2)$，其中 $\\pi_1$ 和 $\\pi_2$ 是其他提示的（可能为空的）子序列。\n\n设 $T$ 为前缀序列 $\\pi_1$ 中最后一个提示的完成时间。如果 $\\pi_1$ 为空，则 $T=0$。在调度 $S$ 中，提示 $i$ 和 $j$ 的完成时间为：\n$$C_i = T + t_i$$\n$$C_j = T + t_i + t_j$$\n它们各自的延迟为：\n$$L_i = T + t_i - d_i$$\n$$L_j = T + t_i + t_j - d_j$$\n这对提示中的最大延迟是 $\\max(L_i, L_j)$。\n\n现在，我们通过交换 $i$ 和 $j$ 的顺序来创建一个新的调度 $S'$：$S' = (\\pi_1, j, i, \\pi_2)$。$\\pi_1$ 中所有提示的完成时间保持不变。处理提示对 $(i, j)$ 的总时间是 $t_i + t_j$，这与处理提示对 $(j, i)$ 的时间相同。因此，后缀序列 $\\pi_2$ 中所有提示的开始时间和完成时间也保持不变。这样，$\\pi_1$ 或 $\\pi_2$ 中任何提示的延迟都不受此次交换的影响。我们只需要分析提示 $i$ 和 $j$ 的最大延迟变化。\n\n在调度 $S'$ 中，新的完成时间 $C'_j$ 和 $C'_i$ 分别为：\n$$C'_j = T + t_j$$\n$$C'_i = T + t_j + t_i$$\n新的延迟 $L'_j$ 和 $L'_i$ 分别为：\n$$L'_j = T + t_j - d_j$$\n$$L'_i = T + t_j + t_i - d_i$$\n这对提示的新的最大延迟是 $\\max(L'_j, L'_i)$。\n\n我们想证明 $\\max(L'_j, L'_i) \\le \\max(L_i, L_j)$。\n让我们分析一下新的延迟值与旧的延迟值的关系。\n比较 $L'_i$ 与 $L_j$：\n$L'_i = T + t_j + t_i - d_i$\n$L_j = T + t_i + t_j - d_j$\n因为我们假设存在一个逆序，$d_i > d_j$，这意味着 $-d_i  -d_j$。因此，$L'_i  L_j$。\n\n现在，让我们比较 $L'_j$ 与 $L_j$：\n$L'_j = T + t_j - d_j$\n$L_j = (T + t_j - d_j) + t_i$\n由于所有处理时间都是正数（$t_i > 0$），很明显 $L'_j  L_j$。\n\n我们已经证明，两个新的延迟 $L'_i$ 和 $L'_j$ 都严格小于原来的延迟 $L_j$：\n$$L'_i  L_j \\quad \\text{and} \\quad L'_j  L_j$$\n这意味着新的延迟的最大值也必须严格小于 $L_j$：\n$$\\max(L'_j, L'_i)  L_j$$\n根据最大函数的定义，$L_j \\le \\max(L_i, L_j)$，因此可以得出：\n$$\\max(L'_j, L'_i)  L_j \\le \\max(L_i, L_j)$$\n因此，将一个满足 $d_i > d_j$ 的相邻对 $(i,j)$ 交换为 $(j,i)$ 不会增加调度的最大延迟。实际上，它只能减少最大延迟或使其保持不变（如果最大延迟是由 $\\pi_1$ 或 $\\pi_2$ 中的其他某个提示决定的）。通过重复应用此类交换，任何调度都可以转换为 EDD 调度。每一步都不会增加最大延迟。因此，EDD 调度的最大延迟必须小于或等于任何其他调度的最大延迟。它是一个最优调度。\n\n我们现在将 EDD 规则应用于给定的数据：\n- 提示 $1$：$t_1 = 3$， $d_1 = 4$。\n- 提示 $2$：$t_2 = 2$， $d_2 = 7$。\n- 提示 $3$：$t_3 = 5$， $d_3 = 9$。\n- 提示 $4$：$t_4 = 4$， $d_4 = 6$。\n- 提示 $5$：$t_5 = 2$， $d_5 = 3$。\n- 提示 $6$：$t_6 = 6$， $d_6 = 15$。\n\n将这些提示按其截止日期（$d_i$）的非递减顺序排序，得到以下序列：\n$1$. 提示 $5$ ($d_5 = 3$)\n$2$. 提示 $1$ ($d_1 = 4$)\n$3$. 提示 $4$ ($d_4 = 6$)\n$4$. 提示 $2$ ($d_2 = 7$)\n$5$. 提示 $3$ ($d_3 = 9$)\n$6$. 提示 $6$ ($d_6 = 15$)\n\n最优调度是序列 $(5, 1, 4, 2, 3, 6)$。我们现在计算这个序列中每个提示的完成时间和延迟。开始时间为 $S=0$。\n\n- **提示 5**：\n  - $t_5 = 2$， $d_5 = 3$。\n  - 开始时间 $S_5 = 0$。\n  - 完成时间 $C_5 = 0 + 2 = 2$。\n  - 延迟 $L_5 = C_5 - d_5 = 2 - 3 = -1$。\n\n- **提示 1**：\n  - $t_1 = 3$， $d_1 = 4$。\n  - 开始时间 $S_1 = C_5 = 2$。\n  - 完成时间 $C_1 = 2 + 3 = 5$。\n  - 延迟 $L_1 = C_1 - d_1 = 5 - 4 = 1$。\n\n- **提示 4**：\n  - $t_4 = 4$， $d_4 = 6$。\n  - 开始时间 $S_4 = C_1 = 5$。\n  - 完成时间 $C_4 = 5 + 4 = 9$。\n  - 延迟 $L_4 = C_4 - d_4 = 9 - 6 = 3$。\n\n- **提示 2**：\n  - $t_2 = 2$， $d_2 = 7$。\n  - 开始时间 $S_2 = C_4 = 9$。\n  - 完成时间 $C_2 = 9 + 2 = 11$。\n  - 延迟 $L_2 = C_2 - d_2 = 11 - 7 = 4$。\n\n- **提示 3**：\n  - $t_3 = 5$， $d_3 = 9$。\n  - 开始时间 $S_3 = C_2 = 11$。\n  - 完成时间 $C_3 = 11 + 5 = 16$。\n  - 延迟 $L_3 = C_3 - d_3 = 16 - 9 = 7$。\n\n- **提示 6**：\n  - $t_6 = 6$， $d_6 = 15$。\n  - 开始时间 $S_6 = C_3 = 16$。\n  - 完成时间 $C_6 = 16 + 6 = 22$。\n  - 延迟 $L_6 = C_6 - d_6 = 22 - 15 = 7$。\n\n最优调度中各个提示的延迟值为 $\\{-1, 1, 3, 4, 7, 7\\}$。最大延迟是这些值的最大值：\n$$L_{\\max} = \\max(-1, 1, 3, 4, 7, 7) = 7$$\n因此，最大延迟的最小可能值为 $7$。", "answer": "$$\\boxed{7}$$", "id": "3252772"}, {"introduction": "除了寻找最优调度方案，衡量一个非最优调度的“无序”程度也极具启发性。这个问题将调度理论与组合数学联系起来，要求你计算将给定序列转换为最优 EDD 顺序所需的最少相邻交换次数。这个数值，即“逆序数”，为衡量一个调度的次优性提供了一个具体的度量标准 [@problem_id:3252854]。", "problem": "考虑一个单机、非抢占式调度问题，其中有 $n$ 个独立作业，所有作业都在时间 $0$ 发布。每个作业 $J_i$ 有一个正的加工时间 $p_i$ 和一个到期日 $d_i$。作业 $J_i$ 的延迟定义为 $L_i = C_i - d_i$，其中 $C_i$ 是作业 $J_i$ 在调度中的完成时间。最早到期日（Earliest Due Date, EDD）规则，也称为最早截止时间优先（Earliest Deadline First, EDF）规则，是按 $d_i$ 的非递减顺序排列作业的序列。如果出现平局（到期日相同），则按作业索引 $i$ 的递增顺序确定性地打破平局。\n\n给定以下作业集合：\n- $J_1$: $p_1 = 4$, $d_1 = 14$\n- $J_2$: $p_2 = 3$, $d_2 = 9$\n- $J_3$: $p_3 = 2$, $d_3 = 17$\n- $J_4$: $p_4 = 5$, $d_4 = 9$\n- $J_5$: $p_5 = 7$, $d_5 = 20$\n- $J_6$: $p_6 = 6$, $d_6 = 13$\n- $J_7$: $p_7 = 4$, $d_7 = 15$\n- $J_8$: $p_8 = 3$, $d_8 = 11$\n- $J_9$: $p_9 = 2$, $d_9 = 12$\n\n假设当前的调度排列为\n$$\\sigma = [J_5,\\, J_2,\\, J_7,\\, J_1,\\, J_4,\\, J_9,\\, J_3,\\, J_6,\\, J_8].$$\n\n仅使用相邻交换（每次交换序列中两个相邻的作业），确定将 $\\sigma$ 转换为 EDD/EDF 顺序所需的最少相邻交换次数。将您的最终答案表示为一个不带单位的整数。", "solution": "问题要求找到将给定的作业排列 $\\sigma$ 转换为最早到期日（EDD）顺序所需的最少相邻交换次数。这是一个组合学中的经典问题，其解法与排列中的逆序对概念相关。\n\n首先，我们必须确定目标排列，即按 EDD 规则排序的作业序列。作业按其到期日 $d_i$ 的非递减顺序排序。指定的打破平局规则是，对于到期日相同的作业，按其索引 $i$ 的递增顺序排列。\n\n给定的作业数据为：\n- $J_1$: $p_1 = 4$, $d_1 = 14$\n- $J_2$: $p_2 = 3$, $d_2 = 9$\n- $J_3$: $p_3 = 2$, $d_3 = 17$\n- $J_4$: $p_4 = 5$, $d_4 = 9$\n- $J_5$: $p_5 = 7$, $d_5 = 20$\n- $J_6$: $p_6 = 6$, $d_6 = 13$\n- $J_7$: $p_7 = 4$, $d_7 = 15$\n- $J_8$: $p_8 = 3$, $d_8 = 11$\n- $J_9$: $p_9 = 2$, $d_9 = 12$\n\n请注意，加工时间 $p_i$ 与确定 EDD 顺序无关，因此也与所需的交换次数无关。\n\n让我们列出作业及其到期日 $d_i$ 和索引 $i$：\n- $(d_1, i_1) = (14, 1)$\n- $(d_2, i_2) = (9, 2)$\n- $(d_3, i_3) = (17, 3)$\n- $(d_4, i_4) = (9, 4)$\n- $(d_5, i_5) = (20, 5)$\n- $(d_6, i_6) = (13, 6)$\n- $(d_7, i_7) = (15, 7)$\n- $(d_8, i_8) = (11, 8)$\n- $(d_9, i_9) = (12, 9)$\n\n首先按 $d_i$ 排序，对于平局则按 $i$ 排序：\n1. $(9, 2)$ 和 $(9, 4)$。由于 $d_2 = d_4$，打破平局的规则规定 $J_2$（索引为 $2$）排在 $J_4$（索引为 $4$）之前。\n2. $(11, 8)$\n3. $(12, 9)$\n4. $(13, 6)$\n5. $(14, 1)$\n6. $(15, 7)$\n7. $(17, 3)$\n8. $(20, 5)$\n\n因此，EDD 顺序，我们称之为目标排列 $\\pi$，是：\n$$\\pi = [J_2, J_4, J_8, J_9, J_6, J_1, J_7, J_3, J_5]$$\n\n初始排列为：\n$$\\sigma = [J_5, J_2, J_7, J_1, J_4, J_9, J_3, J_6, J_8]$$\n\n组合学中有一个基本定理：将一个排列转换为有序序列所需的最少相邻交换次数等于该排列中的逆序对数量。排列中的一个逆序对是指一对顺序与其自然排序顺序相反的元素。\n\n为了应用这个定理，我们必须首先将我们的作业映射到一组表示其排序顺序的整数。令一个作业在目标排列 $\\pi$ 中的位置为其“秩”。\n- 秩 1: $J_2$\n- 秩 2: $J_4$\n- 秩 3: $J_8$\n- 秩 4: $J_9$\n- 秩 5: $J_6$\n- 秩 6: $J_1$\n- 秩 7: $J_7$\n- 秩 8: $J_3$\n- 秩 9: $J_5$\n\n使用这个映射，我们可以将初始排列 $\\sigma$ 重写为秩的排列，我们称之为 $\\sigma'$：\n- $J_5 \\rightarrow 9$\n- $J_2 \\rightarrow 1$\n- $J_7 \\rightarrow 7$\n- $J_1 \\rightarrow 6$\n- $J_4 \\rightarrow 2$\n- $J_9 \\rightarrow 4$\n- $J_3 \\rightarrow 8$\n- $J_6 \\rightarrow 5$\n- $J_8 \\rightarrow 3$\n所以，数字排列是：\n$$\\sigma' = [9, 1, 7, 6, 2, 4, 8, 5, 3]$$\n\n问题现在简化为计算 $\\sigma'$ 中的逆序对数量。一个逆序对是一对索引 $(i, j)$，使得 $i  j$ 且 $\\sigma'_i > \\sigma'_j$。我们计算每个元素右侧比它小的元素的数量。\n\n1. 对于元素 $9$（在第一个位置）：它大于 $1, 7, 6, 2, 4, 8, 5, 3$。这产生 $8$ 个逆序对。\n2. 对于元素 $1$（在第二个位置）：其右侧没有更小的元素。这产生 $0$ 个逆序对。\n3. 对于元素 $7$：它大于 $6, 2, 4, 5, 3$。这产生 $5$ 个逆序对。\n4. 对于元素 $6$：它大于 $2, 4, 5, 3$。这产生 $4$ 个逆序对。\n5. 对于元素 $2$：其右侧没有更小的元素。这产生 $0$ 个逆序对。\n6. 对于元素 $4$：它大于 $3$。这产生 $1$ 个逆序对。\n7. 对于元素 $8$：它大于 $5, 3$。这产生 $2$ 个逆序对。\n8. 对于元素 $5$：它大于 $3$。这产生 $1$ 个逆序对。\n9. 对于元素 $3$：其右侧没有元素。这产生 $0$ 个逆序对。\n\n逆序对的总数是这些计数的总和：\n$$N_{swaps} = 8 + 0 + 5 + 4 + 0 + 1 + 2 + 1 + 0 = 21$$\n\n因此，将 $\\sigma$ 转换为 EDD 顺序 $\\pi$ 所需的最少相邻交换次数为 $21$。", "answer": "$$\\boxed{21}$$", "id": "3252854"}, {"introduction": "现实世界中的调度问题通常涉及在不同时间到达的任务，以及暂停和恢复任务的能力。这个练习将基础模型扩展到包含“释放时间”和“抢占”的场景，要求你设计并实现一个动态调度算法。通过解决这个更复杂的场景，你将学会在一个在线环境中应用“最早截止日期优先”（EDF）原则，随着事件的展开做出最优决策 [@problem_id:3252827]。", "problem": "给定一个单机调度问题，其中每个作业必须在单台机器上以非抢占式或抢占式方式处理，该机器在任何时候最多只能处理一个作业。每个作业有三个属性：发布时间 $r_i$、处理时间 $p_i$ 和截止期限 $d_i$。机器是持续可用的，作业仅在其发布时间或之后才可被处理，作业可以被抢占并在之后无惩罚地恢复，并且所有参数都是整数。作业 $i$ 的完成时间为 $C_i$，其延迟定义为 $L_i = C_i - d_i$。目标是最小化最大延迟 $L_{\\max} = \\max_i L_i$。所有时间都是无单位的整数。\n\n从完成时间和延迟的基本定义出发，请从第一性原理设计一个算法，该算法在每个时刻决定运行哪个可用作业，以最小化 $L_{\\max}$。您的算法必须对允许抢占的任意整数输入 $\\{(r_i,p_i,d_i)\\}$ 都是正确的，并且必须计算出可能的最小 $L_{\\max}$ 值。您的推理不能依赖于未经证明的启发式方法或黑箱定理，必须基于基本定义和逻辑上有效的交换论证。\n\n您的程序必须实现此算法，并为以下每个测试用例计算可能的最小 $L_{\\max}$。每个测试用例是一个作业列表，以三元组 $(r_i,p_i,d_i)$ 的形式给出：\n\n- 测试用例 1: $[(0,3,9),(0,2,8),(0,2,15)]$。\n- 测试用例 2: $[(0,10,100),(5,1,7)]$。\n- 测试用例 3: $[(0,5,3),(0,2,5)]$。\n- 测试用例 4: $[(0,3,10),(2,0,1)]$。\n- 测试用例 5: $[(0,7,20),(3,4,8),(4,2,6)]$。\n- 测试用例 6: $[(0,2,5),(5,2,20)]$。\n- 测试用例 7: $[(0,2,5),(1,2,5)]$。\n\n您的程序必须产生单行输出，其中包含用方括号括起来的、以逗号分隔的测试用例结果列表，顺序与上述相同，例如 $[x_1,x_2,\\dots,x_7]$。每个测试的结果必须是一个整数，等于该测试用例在无惩罚抢占条件下可实现的最小 $L_{\\max}$。不应打印额外的文本或空白，也不应读取任何输入。程序必须是自包含的，并且可以按原样运行。", "solution": "用户要求提供一种算法来解决带有发布时间和抢占的单机调度问题，目标是最小化最大延迟，定义为 $L_{\\max} = \\max_i L_i$，其中 $L_i = C_i - d_i$。此处，$C_i$ 是作业 $i$ 的完成时间，$d_i$ 是其截止期限。每个作业 $i$ 由一个三元组 $(r_i, p_i, d_i)$ 定义，分别代表其发布时间、处理时间和截止期限。所有参数都是整数。\n\n问题在于从第一性原理设计一个算法，并通过交换论证来证明其正确性。所需的算法是最早截止期限优先（EDF）规则的动态版本。\n\n### 提议的算法：最早截止期限优先（EDF）\n\n贪心策略如下：在任何时间点 $t$，从可用作业（即已发布，$r_i \\le t$，但尚未完成的作业）集合中，选择截止期限 $d_i$ 最早的作业进行处理。如果可用作业集合为空，则机器保持空闲。这被称为最早截止期限优先（EDF）算法。\n\n### 正确性证明\n\n我们将通过交换论证来证明EDF算法的最优性。证明包括两部分：首先，证明当有可用作业时，最优调度无需有任何空闲时间；其次，证明任何非EDF调度都可以转换为EDF调度，而不会增加最大延迟。\n\n#### 第一部分：空闲时间\n\n设 $S_{OPT}$ 是一个最小化 $L_{\\max}$ 的最优调度。假设在某个时间 $t_1$，至少有一个可用作业，但机器在 $S_{OPT}$ 的时间间隔 $[t_1, t_2)$ 内是空闲的。设作业 $j$ 是在 $t_1$ 时的一个可用作业。由于机器是空闲的，这个作业 $j$（以及任何其他工作）必须被安排在某个时间 $t_3 \\ge t_2$ 执行。\n\n我们可以通过将某个作业的 $\\delta > 0$ 单位工作量从一个始于或晚于 $t_2$ 的时间段移动到始于 $t_1$ 的空闲时间段，来从 $S_{OPT}$ 构造一个新的调度 $S'$。具体来说，我们可以将作业 $j$ 的一部分处理工作从稍后的时间提前到区间 $[t_1, t_1+\\delta]$ 内执行，其中 $\\delta = \\min(t_2-t_1, p_j(t_1))$，$p_j(t_1)$ 是作业 $j$ 在时间 $t_1$ 的剩余处理时间。\n\n在新的调度 $S'$ 中，所有作业的完成时间都不会晚于它们在 $S_{OPT}$ 中的完成时间，因此它们的延迟不会增加。因此，$L_{\\max}(S') \\le L_{\\max}(S_{OPT})$。我们可以重复这个过程，直到调度中在有可用作业时不再有空闲时间。这表明存在一个尽可能“繁忙”的最优调度。\n\n#### 第二部分：交换论证\n\n设 $S_{EDF}$ 是由我们的EDF算法生成的调度。设 $S_{OPT}$ 是一个“繁忙”的（根据第一部分）但非EDF的最优调度。如果 $S_{OPT}$ 不是一个EDF调度，那么必然存在第一个时间点 $t$，在该时间点上它选择处理的作业与EDF的选择不同。\n\n在时间 $t$，$S_{EDF}$ 选择了一个可用作业 $j$，使得对于任何其他可用作业 $k$，都有 $d_j \\le d_k$。由于 $S_{OPT}$ 与之不同，它必须选择另一个不同的可用作业，比如说 $k$，必然有 $d_k \\ge d_j$。为简化论证，我们假设 $d_k > d_j$。\n\n在 $S_{OPT}$ 中，作业 $k$ 从 $t$ 开始被处理了一段时间 $\\Delta > 0$。作业 $j$ 必须在稍后的时间被处理。我们找到 $t$ 之后 $S_{OPT}$ 处理作业 $j$ 的第一个时间区间 $[t', t'+\\Delta']$。\n\n我们现在通过交换这些工作块来从 $S_{OPT}$ 构造一个新的调度 $S'$。令 $\\delta = \\min(\\Delta, \\Delta')$。\n- 在 $S'$ 中，于区间 $[t, t+\\delta]$ 内处理作业 $j$。\n- 在 $S'$ 中，于区间 $[t', t'+\\delta]$ 内处理作业 $k$。\n- 在所有其他时间，$S'$ 与 $S_{OPT}$ 相同。\n\n这个新的调度 $S'$ 是有效的，因为作业 $j$ 在时间 $t$ 是可用的，而作业 $k$（在 $t$ 时可用）在稍后的时间 $t'$ 也必然是可用的。\n\n让我们分析 $S'$ 相对于 $S_{OPT}$ 的延迟。设 $C_i$ 和 $C'_i$ 分别是 $S_{OPT}$ 和 $S'$ 中的完成时间。\n1.  对于任何作业 $i \\neq j, k$，其处理不受影响。因此，$C'_i = C_i$ 且 $L'_i = L_i$。\n2.  对于作业 $j$，它的一部分工作被提早执行。这只会导致其完成时间提前或保持不变。所以，$C'_j \\le C_j$，这意味着 $L'_j = C'_j - d_j \\le C_j - d_j = L_j$。\n3.  对于作业 $k$，它的一部分工作被延迟了。其完成时间 $C'_k$ 可能大于 $C_k$。然而，在 $S_{OPT}$ 中作业 $j$ 在 $[t', t'+\\delta]$ 占用的时间片现在可用于其他工作，包括作业 $k$。作业 $j$ 和 $k$ 的总工作量在先前 $S_{OPT}$ 中包含它们执行的相同总时间窗口内完成。关键是，作业 $k$ 在 $S'$ 中的完成时间 $C'_k$ 不会超过作业 $j$ 在 $S_{OPT}$ 中的完成时间 $C_j$。这是因为在 $S_{OPT}$ 中 $t$ 时刻之后用于作业 $j$ 的任何时间片现在都在 $S'$ 中可用于作业 $k$。因此，$C'_k \\le C_j$。\n\n现在我们可以比较作业 $k$ 的延迟：\n$L'_k = C'_k - d_k \\le C_j - d_k$。\n由于我们从 $d_j  d_k$ 的前提开始，可以推断出 $-d_k  -d_j$。\n所以，$L'_k \\le C_j - d_k  C_j - d_j = L_j$。\n\n我们已经证明了 $L'_j \\le L_j$ 和 $L'_k  L_j$。这意味着 $\\max(L'_j, L'_k) \\le L_j \\le \\max(L_j, L_k)$。作业对 $\\{j, k\\}$ 的最大延迟没有增加。由于所有其他作业的延迟不变，因此整体最大延迟没有增加：$L_{\\max}(S') \\le L_{\\max}(S_{OPT})$。\n\n通过重复应用这种交换，我们可以将 $S_{OPT}$ 转换为在每一步都与 $S_{EDF}$ 匹配的调度，而从不增加最大延迟。这证明了由最早截止期限优先算法生成的调度 $S_{EDF}$ 是最优的。\n\n### 算法实现\n\nEDF算法可以实现为离散事件模拟。“事件”是指需要做出调度决策的时刻，即新作业的发布或当前运行作业的完成。\n\n1.  维护一个全局的 `currentTime`（当前时间）。\n2.  保留一个尚未发布的作业列表，按发布时间 $r_i$ 排序。\n3.  使用一个最小优先队列来存储可用作业，按其截止期限 $d_i$ 排序。\n4.  主模拟循环将 `currentTime` 从一个事件推进到下一个事件。\n    -   在 `currentTime`，将任何新发布的作业添加到优先队列中。\n    -   如果机器正忙，检查优先队列中是否有任何作业的截止期限比正在运行的作业更早。如果有，则抢占当前作业（将其返回优先队列）并开始新作业。\n    -   如果机器空闲，则从优先队列中提取截止期限最小的作业来运行。\n    -   如果机器空闲且没有可用作业，则将 `currentTime` 推进到下一个作业的发布时间。\n    -   计算到下一个事件（当前作业完成或下一个作业发布）的时间。将 `currentTime` 推进这段时间，并更新当前作业的剩余处理时间。\n    -   如果一个作业完成，记录其完成时间并将机器设置为空闲状态。\n5.  当所有作业都完成时，模拟结束。\n6.  最后，计算所有作业的 $L_{\\max} = \\max_i(C_i - d_i)$。这将是可能的最小最大延迟。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to solve the scheduling problem for all test cases.\n    \"\"\"\n    test_cases = [\n        [(0, 3, 9), (0, 2, 8), (0, 2, 15)],\n        [(0, 10, 100), (5, 1, 7)],\n        [(0, 5, 3), (0, 2, 5)],\n        [(0, 3, 10), (2, 0, 1)],\n        [(0, 7, 20), (3, 4, 8), (4, 2, 6)],\n        [(0, 2, 5), (5, 2, 20)],\n        [(0, 2, 5), (1, 2, 5)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = edf_scheduler(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef edf_scheduler(jobs_data):\n    \"\"\"\n    Calculates the minimum maximum lateness for a set of jobs using the\n    Earliest Deadline First (EDF) scheduling algorithm with preemption.\n\n    Args:\n        jobs_data: A list of tuples, where each tuple is (r_i, p_i, d_i)\n                   representing release time, processing time, and deadline.\n\n    Returns:\n        The minimum possible maximum lateness (L_max).\n    \"\"\"\n    if not jobs_data:\n        return 0\n\n    # Job representation: Use a dictionary to hold mutable state (p_rem).\n    # 'id' is the original index, used for tracking.\n    jobs = [{'id': i, 'r': r, 'p': p, 'd': d, 'p_rem': p}\n            for i, (r, p, d) in enumerate(jobs_data)]\n    \n    # Map job IDs to their data for O(1) access.\n    job_map = {j['id']: j for j in jobs}\n    \n    # Jobs to be processed, sorted by release time.\n    unreleased_jobs = sorted(jobs, key=lambda j: j['r'])\n\n    # Min-priority queue for available jobs, ordered by deadline.\n    # Stores tuples of (deadline, job_id).\n    available_jobs_pq = []\n\n    completion_times = {}\n    current_time = 0\n    current_job_id = None\n    processed_job_count = 0\n\n    # The simulation runs until all jobs are completed.\n    while processed_job_count  len(jobs):\n        \n        # If the machine is idle and no jobs are available, jump time to the next release.\n        if current_job_id is None and not available_jobs_pq and unreleased_jobs:\n            current_time = max(current_time, unreleased_jobs[0]['r'])\n        \n        # Add all jobs released by the current time to the available pool.\n        while unreleased_jobs and unreleased_jobs[0]['r'] = current_time:\n            job = unreleased_jobs.pop(0)\n            heapq.heappush(available_jobs_pq, (job['d'], job['id']))\n\n        # If a job just finished or the machine was idle, select the next job to run (EDF).\n        if current_job_id is None and available_jobs_pq:\n            _, current_job_id = heapq.heappop(available_jobs_pq)\n\n        # Preemption check: if an available job has an earlier deadline than the current one.\n        if current_job_id is not None and available_jobs_pq:\n            best_available_d, _ = available_jobs_pq[0]\n            if best_available_d  job_map[current_job_id]['d']:\n                # The available job preempts the current job.\n                heapq.heappush(available_jobs_pq, (job_map[current_job_id]['d'], current_job_id))\n                _, current_job_id = heapq.heappop(available_jobs_pq)\n        \n        if current_job_id is None:\n            # This handles idle periods between jobs when the ready queue is temporarily empty.\n            continue\n            \n        current_job = job_map[current_job_id]\n\n        # Determine the time slice for the current job. It runs until it's finished\n        # or a new job is released, whichever comes first.\n        time_to_completion = current_job['p_rem']\n        time_to_next_release = float('inf')\n        if unreleased_jobs:\n            time_to_next_release = unreleased_jobs[0]['r'] - current_time\n        \n        time_to_run = max(0, min(time_to_completion, time_to_next_release))\n\n        # Update state based on the time slice.\n        current_job['p_rem'] -= time_to_run\n        current_time += time_to_run\n\n        # If the job has finished processing.\n        if current_job['p_rem'] == 0:\n            completion_times[current_job_id] = current_time\n            current_job_id = None\n            processed_job_count += 1\n            \n    # Calculate the maximum lateness over all jobs.\n    max_lateness = -float('inf')\n    for i in range(len(jobs_data)):\n        d = jobs_data[i][2]\n        c = completion_times[i]\n        max_lateness = max(max_lateness, c - d)\n            \n    return int(max_lateness)\n\nsolve()\n```", "id": "3252827"}]}