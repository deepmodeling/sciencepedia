{"hands_on_practices": [{"introduction": "仅仅求出最长公共子序列（LCS）的长度只是第一步，一个更深入的问题是：满足该长度的LCS一共有多少个？本练习引导你扩展标准的动态规划方法，不仅求解最优值，还要统计最优解的数量。通过这一实践，你将学会如何利用动态规划表来处理复杂的计数问题，加深对最优路径多样性的理解。[@problem_id:3247580]", "problem": "给定两个固定字母表上的有限字符串。字符串的子序列是通过删除零个或多个符号而不改变其余符号的相对顺序得到的。两个字符串的最长公共子序列 (LCS) 是指同时作为两个字符串的子序列、且长度最长的任何子序列。请严格从子序列的定义以及考虑输入字符串前缀时出现的最优子结构性质出发，推导出一个动态规划过程，该过程用于计算两个字符串的不同 LCS 的数量。您的推导必须定义一个关于前缀的递推关系，论证基本情况的合理性，并说明为什么您的计数方法不会因为通过不同对齐方式实现的相同子序列而重复计数。\n\n在推导出您的方法后，将其应用于具体的字符串\n- $A = \\text{BACBCA}$，长度为 $6$，\n- $B = \\text{ABCABA}$，长度为 $6$，\n并计算 $A$ 和 $B$ 的不同 LCS 的数量。仅报告最终计数，结果为一个精确整数。无需四舍五入。最终答案必须是单一实数值数字。", "solution": "该问题要求完成两件事：首先，推导一个动态规划过程，用于计算两个字符串的不同最长公共子序列 (LCS) 的数量；其次，将此过程应用于具体的字符串 $A = \\text{BACBCA}$ 和 $B = \\text{ABCABA}$。\n\n### 第一部分：动态规划过程的推导\n\n设两个字符串为 $A = a_1a_2...a_m$ 和 $B = b_1b_2...b_n$。我们将 $A$ 的长度为 $i$ 的前缀表示为 $A_i = a_1...a_i$，同样地，$B$ 的长度为 $j$ 的前缀表示为 $B_j = b_1...b_j$。\n\n该推导需要两个阶段的动态规划。首先，我们计算所有前缀对的 LCS 长度。其次，我们利用这些信息来计算不同 LCS 的数量。\n\n**阶段一：计算LCS的长度**\n\n设 $L(i,j)$ 为前缀 $A_i$ 和 $B_j$ 的一个 LCS 的长度。$L(i,j)$ 的值由基于 LCS 问题的最优子结构性质的著名递推关系确定。\n\n- **基本情况**：任何字符串与空字符串的 LCS 是空字符串，其长度为 $0$。\n$$ L(i,0) = 0 \\text{ for } 0 \\le i \\le m $$\n$$ L(0,j) = 0 \\text{ for } 0 \\le j \\le n $$\n- **递推关系**：对于 $i > 0$ 和 $j > 0$：\n如果前缀的最后一个字符匹配 ($a_i = b_j$)，则 $A_i$ 和 $B_j$ 的 LCS 是通过找到较短前缀 $A_{i-1}$ 和 $B_{j-1}$ 的一个 LCS，并在其后附加公共字符 $a_i$ 形成的。\n如果最后一个字符不匹配 ($a_i \\neq b_j$)，则 $A_i$ 和 $B_j$ 的一个 LCS 是 $A_{i-1}$ 和 $B_j$ 的一个 LCS，或者是 $A_i$ 和 $B_{j-1}$ 的一个 LCS。我们取其中长度最长的那个。\n这导出了递推关系：\n$$ L(i,j) = \\begin{cases} 1 + L(i-1, j-1)  \\text{if } a_i=b_j \\\\ \\max(L(i-1,j), L(i,j-1))  \\text{if } a_i \\neq b_j \\end{cases} $$\n使用这些规则可以计算一个大小为 $(m+1) \\times (n+1)$ 的 $L(i,j)$ 表。\n\n**阶段二：计算不同LCS的数量**\n\n设 $C(i,j)$ 为前缀 $A_i$ 和 $B_j$ 的不同 LCS 的数量。这些 LCS 的长度由 $L(i,j)$ 给出。我们推导一个依赖于预先计算的 $L$ 表的 $C(i,j)$ 的递推关系。\n\n对于 $A_i, B_j$ 的不同 LCS 集合（我们称之为 $S(i,j)$），是通过取那些对最大长度 $L(i,j)$ 有贡献的子问题的 LCS 集合的并集而形成的。计数 $C(i,j)$ 就是 $|S(i,j)|$。\n\n- **基本情况**：任何字符串和空字符串之间唯一的公共子序列是空字符串。因此，总存在且仅存在一个 LCS（即空字符串）。\n$$ C(i,0) = 1 \\text{ for } 0 \\le i \\le m $$\n$$ C(0,j) = 1 \\text{ for } 0 \\le j \\le n $$\n\n- **递推关系**：对于 $i > 0$ 和 $j > 0$，我们考虑与计算长度时相同的几种情况。\n\n1.  **情况1：$a_i = b_j$**\n    $A_i, B_j$ 的 LCS 是通过将 $a_i$ 附加到 $A_{i-1}, B_{j-1}$ 的 LCS 之后形成的。其长度为 $L(i,j) = 1+L(i-1, j-1)$。从子问题 $(A_{i-1}, B_j)$ 或 $(A_i, B_{j-1})$ 得到的任何 LCS 的长度最多为 $L(i-1, j-1)+1$。可以证明它们的长度严格小于 $L(i,j)$，因此它们对 $A_i, B_j$ 的 LCS 集合没有贡献。因此，$(A_i, B_j)$ 的不同 LCS 数量与 $(A_{i-1}, B_{j-1})$ 相同。\n    $$ C(i,j) = C(i-1, j-1) $$\n\n2.  **情况2：$a_i \\neq b_j$**\n    $A_i, B_j$ 的 LCS 是 $A_{i-1}, B_j$ 的 LCS 和/或 $A_i, B_{j-1}$ 的 LCS。其长度为 $L(i,j) = \\max(L(i-1,j), L(i,j-1))$。\n\n    a) 如果 $L(i-1,j) > L(i,j-1)$：$(A_i, B_{j-1})$ 的 LCS 严格更短。所有 $(A_i, B_j)$ 的 LCS 都必须来自 $(A_{i-1}, B_j)$。\n    $$ C(i,j) = C(i-1,j) $$\n\n    b) 如果 $L(i,j-1) > L(i-1,j)$：对称地，所有 LCS 都必须来自 $(A_i, B_{j-1})$。\n    $$ C(i,j) = C(i,j-1) $$\n\n    c) 如果 $L(i-1,j) = L(i,j-1)$：LCS 可以来自两个子问题。LCS 的集合是 $S(i-1,j) \\cup S(i,j-1)$。根据容斥原理，计数为 $C(i,j) = |S(i-1,j)| + |S(i,j-1)| - |S(i-1,j) \\cap S(i,j-1)|$。\n    交集 $S(i-1,j) \\cap S(i,j-1)$ 由同时是 $A_{i-1}$ 和 $B_{i-1}$ 的子序列的 LCS 组成。为了使这些序列成为交集的成员，它们的长度必须是 $L(i,j)$。如果 $L(i,j) > L(i-1,j-1)$，这个交集必定为空，因为 $A_{i-1}$ 和 $B_{j-1}$ 的任何公共子序列都太短。如果 $L(i,j)=L(i-1,j-1)$，那么交集恰好是 $A_{i-1}, B_{j-1}$ 的 LCS 集合。\n    因此：\n    - 如果 $L(i,j) > L(i-1, j-1)$：$C(i,j) = C(i-1,j) + C(i,j-1)$。这确保了没有重复计数，因为来自 $(A_{i-1},B_j)$ 的 LCS（必须以关键方式使用 $b_j$）和来自 $(A_i,B_{j-1})$ 的 LCS（必须以关键方式使用 $a_i$）构成了不相交的字符串集合。更形式化地说，任何在交集中的字符串必须同时是 $A_{i-1}$ 和 $B_{j-1}$ 的子序列，但其长度 $L(i,j)$ 严格大于这对字符串的 LCS 长度 $L(i-1,j-1)$，这是一个矛盾。\n    - 如果 $L(i,j) = L(i-1, j-1)$：$C(i,j) = C(i-1,j) + C(i,j-1) - C(i-1,j-1)$。这正确地减去了两个子问题共有的 LCS 的数量，这些 LCS 恰好是 $(A_{i-1}, B_{j-1})$ 的 LCS。\n\n使用这些规则可以计算一个大小为 $(m+1) \\times (n+1)$ 的 $C(i,j)$ 表。最终答案是 $C(m,n)$。\n\n### 第二部分：应用于给定字符串\n\n我们将推导出的方法应用于 $A = \\text{BACBCA}$（长度 $m=6$）和 $B = \\text{ABCABA}$（长度 $n=6$）。\n\n**阶段一：$L(i,j)$ 表**\n\n计算出的 $L(i,j)$ 表如下，其中行对应 $A$ 的前缀，列对应 $B$ 的前缀：\n$$\nL = \\begin{pmatrix}\n  \\text{ } & \\text{ } & \\text{A} & \\text{B} & \\text{C} & \\text{A} & \\text{B} & \\text{A} \\\\\n\\text{ } & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\\text{B} & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\\n\\text{A} & 0 & 1 & 1 & 1 & 2 & 2 & 2 \\\\\n\\text{C} & 0 & 1 & 1 & 2 & 2 & 2 & 2 \\\\\n\\text{B} & 0 & 1 & 2 & 2 & 2 & 3 & 3 \\\\\n\\text{C} & 0 & 1 & 2 & 3 & 3 & 3 & 3 \\\\\n\\text{A} & 0 & 1 & 2 & 3 & 4 & 4 & 4\n\\end{pmatrix}\n$$\n$A$ 和 $B$ 的 LCS 长度是 $L(6,6)=4$。\n\n**阶段二：$C(i,j)$ 表**\n\n使用 $L$ 表和 $C(i,j)$ 的递推关系，我们计算 $C(i,j)$ 表。\n- 对于所有的 $i,j$，$C(i,0) = 1$ 且 $C(0,j)=1$。\n- 对于 $i,j > 0$：\n  - 如果 $a_i=b_j$，则 $C(i,j) = C(i-1,j-1)$。\n  - 如果 $a_i \\ne b_j$：\n    - 如果 $L(i-1,j) > L(i,j-1)$，则 $C(i,j) = C(i-1,j)$。\n    - 如果 $L(i-1,j)  L(i,j-1)$，则 $C(i,j) = C(i,j-1)$。\n    - 如果 $L(i-1,j) = L(i,j-1)$：\n      - 如果 $L(i-1,j-1)  L(i,j)$，则 $C(i,j) = C(i-1,j) + C(i,j-1)$。\n      - 如果 $L(i-1,j-1) = L(i,j)$，则 $C(i,j) = C(i-1,j) + C(i,j-1) - C(i-1,j-1)$。\n\n计算出的 $C(i,j)$ 表是：\n$$\nC = \\begin{pmatrix}\n  \\text{ }  \\text{ }  \\text{A}  \\text{B}  \\text{C}  \\text{A}  \\text{B}  \\text{A} \\\\\n\\text{ }  1  1  1  1  1  1  1 \\\\\n\\text{B}  1  1  1  1  1  1  1 \\\\\n\\text{A}  1  1  2  2  1  1  1 \\\\\n\\text{C}  1  1  2  2  3  3  3 \\\\\n\\text{B}  1  1  1  3  4  3  3 \\\\\n\\text{C}  1  1  1  1  1  4  4 \\\\\n\\text{A}  1  1  1  1  1  1  4\n\\end{pmatrix}\n$$\n我们来验证最后一个条目，$C(6,6)$：\n$a_6 = \\text{'A'}$ 且 $b_6=\\text{'A'}$。它们匹配。\n所以，$C(6,6) = C(5,5)$。\n从表中可知，$C(5,5) = 4$。\n我们来验证 $C(5,5)$：\n$a_5=\\text{'C'}, b_5=\\text{'B'}$。它们不匹配。\n$L(5,5)=3$。从 $L$ 表中，$L(4,5)=3$ 且 $L(5,4)=3$。它们相等。\n我们比较 $L(5,5)$ 和 $L(4,4)=2$。因为 $L(5,5) > L(4,4)$，我们使用加法规则：\n$C(5,5) = C(4,5) + C(5,4) = 3 + 1 = 4$。\n值 $C(4,5)=3$ 和 $C(5,4)=1$ 是通过类似地从前几行和前几列的条目计算得出的。完整的表格计算证实了这些值。\n\n字符串 $A$ 和 $B$ 的不同 LCS 的最终数量由 $C(6,6)$ 给出。\n$C(6,6) = 4$。\n\n四个不同的 LCS 是：`BABA`、`ACBA`、`BCBA`、`ABCA`。", "answer": "$$\\boxed{4}$$", "id": "3247580"}, {"introduction": "当存在多个长度相同的最长公共子序列时，我们往往需要根据特定标准来选择其中一个。本练习引入了一个额外的约束：找出所有LCS中字典序最小的那一个。你将设计一个算法，将预先计算好的LCS长度表与贪心策略相结合，从而学会在解空间中进行导航，以找到满足多重标准的最优解。[@problem_id:3247478]", "problem": "考虑一个固定的有序字母表上的两个有限字符串。设该字母表为按通常顺序排列的小写英文字母，并由此字母表以常规方式定义字典序。字符串的子序列是通过删除零个或多个字符而不改变其余字符顺序得到的任意序列。两个字符串的公共子序列是同时出现在两者中的子序列。最长公共子序列 (LCS) 是任意一个具有最大可能长度的公共子序列。\n\n从上述基本定义出发，设计一个算法，对于给定的两个输入字符串 $A$ 和 $B$，计算出 $A$ 和 $B$ 的字典序最小的最长公共子序列 (LCS)。您的推导必须从第一性原理（子序列、公共子序列和字典序的定义）开始，并且必须在不借助快捷公式的情况下证明算法的正确性。同时，请根据 $|A|$、$|B|$ 和字母表大小来证明算法的时间复杂度。\n\n然后，将您的算法应用于具体输入 $A = \\text{\"banana\"}$ 和 $B = \\text{\"ananas\"}$，以获得字典序最小的 LCS 字符串 $S$。最后，定义数值编码\n$$\nH(S) = \\sum_{i=1}^{|S|} \\text{code}(S_i)\\cdot 31^{|S|-i},\n$$\n其中 $\\text{code}(\\text{'a'}) = 1, \\text{code}(\\text{'b'}) = 2, \\ldots, \\text{code}(\\text{'z'}) = 26$，并且 $S_i$ 表示 $S$ 的第 $i$ 个字符。精确计算 $H(S)$。将最终答案表示为一个无舍入的精确整数。", "solution": "### 解题推导\n\n设两个输入字符串为 $A$ 和 $B$，其长度分别为 $m = |A|$ 和 $n = |B|$。字母表用 $\\Sigma$ 表示，其大小为 $\\sigma$。\n\n字符串 $X$ 的子序列是通过从 $X$ 中删除零个或多个字符而形成的。例如，“ana”是“banana”的一个子序列。$A$ 和 $B$ 的公共子序列是同时作为 $A$ 和 $B$ 的子序列的字符串。最长公共子序列 (LCS) 是具有最大可能长度的公共子序列。\n\n为了找到字典序最小的 LCS，一个从左到右构造结果字符串的贪心方法是合适的。在每一步中，我们必须选择能够开启字符串剩余部分有效 LCS 的最小可能字符。\n\n为了支持这种贪心策略，我们需要一种方法来获知 $A$ 和 $B$ 任意后缀对的 LCS 长度。我们定义一个二维数组 $L$，其中 $L[i][j]$ 存储后缀 $A[i..m-1]$ 和 $B[j..n-1]$ 的 LCS 长度。我们对字符串和 DP 表使用基于 0 的索引。表的维度将是 $(m+1) \\times (n+1)$。\n\n$L[i][j]$ 中的值是使用动态规划计算的，基于以下递推关系：\n$$\nL[i][j] =\n\\begin{cases}\n  0  \\text{if } i=m \\text{ or } j=n \\\\\n  1 + L[i+1][j+1]  \\text{if } A[i] = B[j] \\\\\n  \\max(L[i+1][j], L[i][j+1])  \\text{if } A[i] \\neq B[j]\n\\end{cases}\n$$\n通过将 $i$ 从 $m$ 向下迭代到 $0$，将 $j$ 从 $n$ 向下迭代到 $0$ 来填充该表。完整字符串 $A$ 和 $B$ 的 LCS 长度即为 $L[0][0]$。\n\n在预先计算好 $L$ 表之后，我们可以构造字典序最小的 LCS，我们称之为 $S$。我们将 $S$ 初始化为空字符串，并将 $A$ 和 $B$ 中的当前指针设置为 $i=0$ 和 $j=0$。我们逐个字符地迭代构建 $S$。\n\n在构造的每一步，我们位于字符串 $A$ 和 $B$ 的索引 $(i, j)$ 处。我们需要找到 $S$ 的下一个字符。剩余后缀 $A[i..m-1]$ 和 $B[j..n-1]$ 的 LCS 总长度为 $L[i][j]$。我们按字典序（从 'a' 到 'z'）遍历字母表 $\\Sigma$ 中的每个字符 $c$。对于每个 $c$，我们在 $A$ 中找到它在索引 $i$ 或之后首次出现的位置（假设为索引 $i'$），在 $B$ 中找到它在索引 $j$ 或之后首次出现的位置（假设为索引 $j'$）。\n\n如果我们将这个字符 $c$ 选为我们 LCS 的下一个字符，我们就承诺使用 $A[i']$ 和 $B[j']$。从这一点开始，我们可以形成的公共子序列的长度是 $1$（对于字符 $c$）加上剩余后缀 $A[i'+1..m-1]$ 和 $B[j'+1..n-1]$ 的 LCS 长度，即 $L[i'+1][j'+1]$。\n\n为确保我们正走在通往最大长度有效 LCS 的路径上，我们必须只选择那些能导向总长度为 $L[i][j]$ 的字符 $c$。也就是说，当且仅当以下条件成立时，字符 $c$（在 $i'$ 和 $j'$ 处找到）才是一个有效的选择：\n$$L[i][j] = 1 + L[i'+1][j'+1]$$\n由于我们按字典序递增的顺序遍历 $c \\in \\Sigma$，第一个满足此条件的字符 $c$ 保证是 LCS 该位置上字典序最小的可能字符。\n\n一旦找到这样的字符 $c$，我们将其附加到 $S$ 上，并将我们在 $A$ 和 $B$ 中的位置更新为 $i=i'+1$ 和 $j=j'+1$。我们重复此过程，直到剩余 LCS 的长度变为 $0$（即 $L[i][j]=0$）。\n\n### 算法摘要\n1.  初始化一个 $(m+1) \\times (n+1)$ 的表 $L$。\n2.  使用后缀 LCS 的 DP 递推关系填充 $L$。$i$ 从 $m$ 向下迭代到 $0$，$j$ 从 $n$ 向下迭代到 $0$。\n3.  初始化 $S = \\text{\"\"}$，$i=0$，$j=0$。\n4.  当 $L[i][j]  0$ 时：\n    a. 对于从 'a'到 'z' 的每个字符 $c$：\n        i.  找到最小的索引 $i' \\ge i$ 使得 $A[i'] = c$。\n        ii. 找到最小的索引 $j' \\ge j$ 使得 $B[j'] = c$。\n        iii. 如果 $i'$ 和 $j'$ 都存在，检查是否 $L[i][j] = 1 + L[i'+1][j'+1]$。\n        iv. 如果条件成立，将 $c$ 附加到 $S$，更新 $i=i'+1$，$j=j'+1$，并跳出内层循环（遍历字符），以继续构造 $S$ 的下一个字符。\n5.  返回 $S$。\n\n### 正确性与复杂度分析\n-   **正确性**：$L$ 表的预计算正确地确定了所有后缀对的 LCS 长度。构造步骤在每个阶段都做出贪心选择。通过按字母顺序遍历字符，它优先选择较小的字符。条件 $L[i][j] = 1 + L[i'+1][j'+1]$ 确保了这一选择不会妨碍形成最大长度的公共子序列。因此，该算法正确地构造了唯一的、字典序最小的 LCS。\n-   **时间复杂度**：设 $m=|A|$，$n=|B|$，且 $\\sigma=|\\Sigma|$。\n    1.  DP 表计算：填充大小为 $(m+1) \\times (n+1)$ 的 $L$ 表需要 $O(m \\cdot n)$ 时间，因为每个单元格的计算是 $O(1)$。\n    2.  寻找下一个字符：在构造的每一步中天真地搜索 $i'$ 和 $j'$ 会很低效。我们可以预先计算 `next_occurrence` 表，例如 `next_A[i][c]` 和 `next_B[j][c]`，它们存储从索引 $i$ 或 $j$ 开始字符 $c$ 的下一次出现位置。这个预计算需要 $O((m+n)\\sigma)$ 的时间。\n    3.  LCS 构造：主循环对 LCS 的每个字符运行一次。LCS 的长度最多为 $\\min(m, n)$。在循环内部，我们遍历大小为 $\\sigma$ 的字母表。使用预计算的表，查找 $i'$ 和 $j'$ 是 $O(1)$ 的。因此，构造过程需要 $O(\\min(m,n) \\cdot \\sigma)$ 的时间。\n    - 总时间复杂度是这些部分的总和：$O(m \\cdot n + (m+n)\\sigma)$。考虑到在这个问题中 $\\sigma=26$ 是一个常数，复杂度可以表述为 $O(m \\cdot n)$。\n\n### 应用于 $A = \\text{\"banana\"}$ 和 $B = \\text{\"ananas\"}$\n\n设 $A = \\text{\"banana\"}$ ($m=6$) 和 $B = \\text{\"ananas\"}$ ($n=6$)。我们应用该算法。首先，计算后缀的 $L$ 表。LCS 的长度是 $L[0][0]=5$。\n\n-   **步骤 1**：找到 $S$ 的第一个字符。当前状态：$i=0, j=0$。$L[0][0]=5$。\n    -   尝试 $c = \\text{'a'}$。$A$ 中的第一个 'a' 在 $i'=1$。$B$ 中的第一个 'a' 在 $j'=0$。\n    -   我们需要检查 $L[0][0] = 1 + L[1+1][0+1] = 1 + L[2][1]$ 是否成立。\n    -   $L[2][1]$ 是 $A[2..]=\\text{\"nana\"}$ 和 $B[1..]=\\text{\"nanas\"}$ 的 LCS 长度。LCS 是 \"nana\"，长度为 4。所以 $L[2][1]=4$。\n    -   条件 $5 = 1 + 4$ 成立。\n    -   所以，第一个字符是 'a'。$S = \\text{\"a\"}$。更新 $i=2, j=1$。\n\n-   **步骤 2**：找到第二个字符。当前状态：$i=2, j=1$。$L[2][1]=4$。\n    -   尝试 $c = \\text{'a'}$。$A[2..]$ 中的第一个 'a' 在 $i'=3$。$B[1..]$ 中的第一个 'a' 在 $j'=2$。\n    -   检查 $L[2][1] = 1 + L[3+1][2+1] = 1 + L[4][3]$ 是否成立。\n    -   $L[4][3]$ 是 $A[4..]=\\text{\"na\"}$ 和 $B[3..]=\\text{\"nas\"}$ 的 LCS。LCS 是 \"na\"，长度为 2。\n    -   条件 $4 = 1+2$ 不成立。'a' 不是选择。\n    -   尝试 $c = \\text{'n'}$。$A[2..]$ 中的第一个 'n' 在 $i'=2$。$B[1..]$ 中的第一个 'n' 在 $j'=1$。\n    -   检查 $L[2][1] = 1 + L[2+1][1+1] = 1+L[3][2]$ 是否成立。\n    -   $L[3][2]$ 是 $A[3..]=\\text{\"ana\"}$ 和 $B[2..]=\\text{\"anas\"}$ 的 LCS。LCS 是 \"ana\"，长度为 3。\n    -   条件 $4 = 1+3$ 成立。\n    -   第二个字符是 'n'。$S = \\text{\"an\"}$。更新 $i=3, j=2$。\n\n-   **步骤 3**：找到第三个字符。当前状态：$i=3, j=2$。$L[3][2]=3$。\n    -   尝试 $c = \\text{'a'}$。$A[3..]$ 中的第一个 'a' 在 $i'=3$。$B[2..]$ 中的第一个 'a' 在 $j'=2$。\n    -   检查 $L[3][2] = 1 + L[3+1][2+1] = 1+L[4][3]$ 是否成立。\n    -   $L[4][3]$ 是 $A[4..]=\\text{\"na\"}$ 和 $B[3..]=\\text{\"nas\"}$ 的 LCS，长度为 2。\n    -   条件 $3 = 1+2$ 成立。\n    -   第三个字符是 'a'。$S = \\text{\"ana\"}$。更新 $i=4, j=3$。\n\n-   **步骤 4**：找到第四个字符。当前状态：$i=4, j=3$。$L[4][3]=2$。\n    -   尝试 $c = \\text{'a'}$。$A[4..]$ 中的第一个 'a' 在 $i'=5$。$B[3..]$ 中的第一个 'a' 在 $j'=4$。\n    -   检查 $L[4][3] = 1 + L[5+1][4+1] = 1+L[6][5]$ 是否成立。$L[6][5]=0$。\n    -   条件 $2=1+0$ 不成立。\n    -   尝试 $c = \\text{'n'}$。$A[4..]$ 中的第一个 'n' 在 $i'=4$。$B[3..]$ 中的第一个 'n' 在 $j'=3$。\n    -   检查 $L[4][3] = 1 + L[4+1][3+1] = 1+L[5][4]$ 是否成立。\n    -   $L[5][4]$ 是 $A[5..]=\\text{\"a\"}$ 和 $B[4..]=\\text{\"as\"}$ 的 LCS。LCS 是 \"a\"，长度为 1。\n    -   条件 $2=1+1$ 成立。\n    -   第四个字符是 'n'。$S = \\text{\"anan\"}$。更新 $i=5, j=4$。\n\n-   **步骤 5**：找到第五个字符。当前状态：$i=5, j=4$。$L[5][4]=1$。\n    -   尝试 $c = \\text{'a'}$。$A[5..]$ 中的第一个 'a' 在 $i'=5$。$B[4..]$ 中的第一个 'a' 在 $j'=4$。\n    -   检查 $L[5][4] = 1 + L[5+1][4+1] = 1+L[6][5]$ 是否成立。$L[6][5]=0$。\n    -   条件 $1=1+0$ 成立。\n    -   第五个字符是 'a'。$S = \\text{\"anana\"}$。更新 $i=6, j=5$。\n\n当前状态：$i=6, j=5$。$L[6][5]=0$。循环终止。\n字典序最小的 LCS 是 $S = \\text{\"anana\"}$。\n\n### $H(S)$ 的计算\n\n编码函数是 $H(S) = \\sum_{k=1}^{|S|} \\text{code}(S_k) \\cdot 31^{|S|-k}$。\n对于 $S = \\text{\"anana\"}$，有 $|S|=5$。字符编码为 $\\text{code}(\\text{'a'}) = 1$ 和 $\\text{code}(\\text{'n'}) = 14$。\n\n$H(\\text{\"anana\"}) = \\text{code}(\\text{'a'}) \\cdot 31^{5-1} + \\text{code}(\\text{'n'}) \\cdot 31^{5-2} + \\text{code}(\\text{'a'}) \\cdot 31^{5-3} + \\text{code}(\\text{'n'}) \\cdot 31^{5-4} + \\text{code}(\\text{'a'}) \\cdot 31^{5-5}$\n$H(S) = \\text{code}(\\text{'a'}) \\cdot 31^4 + \\text{code}(\\text{'n'}) \\cdot 31^3 + \\text{code}(\\text{'a'}) \\cdot 31^2 + \\text{code}(\\text{'n'}) \\cdot 31^1 + \\text{code}(\\text{'a'}) \\cdot 31^0$\n$H(S) = 1 \\cdot 31^4 + 14 \\cdot 31^3 + 1 \\cdot 31^2 + 14 \\cdot 31^1 + 1 \\cdot 31^0$\n\n我们计算 $31$ 的幂：\n$31^0 = 1$\n$31^1 = 31$\n$31^2 = 961$\n$31^3 = 29791$\n$31^4 = 923521$\n\n代入这些值：\n$H(S) = 1 \\cdot (923521) + 14 \\cdot (29791) + 1 \\cdot (961) + 14 \\cdot (31) + 1 \\cdot (1)$\n$H(S) = 923521 + 417074 + 961 + 434 + 1$\n$H(S) = 1340595 + 961 + 434 + 1$\n$H(S) = 1341556 + 434 + 1$\n$H(S) = 1341990 + 1$\n$H(S) = 1341991$\n\n精确的整数值为 $1341991$。", "answer": "$$\\boxed{1341991}$$", "id": "3247478"}]}