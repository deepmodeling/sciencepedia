{"hands_on_practices": [{"introduction": "我们首先探讨一个根本性问题：为什么优先选择价值密度最高的物品这一贪心策略对分数背包问题是最优的？通过与该策略会失效的 0/1 背包问题进行对比，这个练习将揭示物品“可分割性”所扮演的关键角色。本练习将加深你对交换论证（exchange argument）等证明技巧的理解，以及贪心算法之所以有效的核心原理。[@problem_id:3232116]", "problem": "考虑 $0/1$ 背包问题：给定 $n$ 个物品，其价值为 $\\{v_i\\}_{i=1}^n$，重量为 $\\{w_i\\}_{i=1}^n$，以及一个容量 $W$，选择一个物品子集以最大化 $\\sum_{i \\in S} v_i$，约束条件为 $\\sum_{i \\in S} w_i \\le W$，其中每个物品 $i$ 要么被完整地取走，要么完全不取。一种著名的贪心策略是按价值重量比 $v_i/w_i$ 的降序对物品进行排序，并重复地选取下一个能装入的物品。该策略对于物品可分割的变种（分数背包）是最优的，但对于 $0/1$ 背包问题并非最优。\n\n从背包问题中可行性和最优性的基本定义以及交换论证的原理出发：通过在保持可行性的同时交换部分内容，将一个可行解转换为一个更好的解。使用这些基础来分析以下实例以及一个针对 $0/1$ 情况的常见但有缺陷的基于交换的证明尝试。\n\n考虑三个物品和容量 $W$：\n- 物品 $a$：$v_a = 100$, $w_a = 51$。\n- 物品 $b$：$v_b = 60$, $w_b = 50$。\n- 物品 $c$：$v_c = 60$, $w_c = 50$。\n令 $W = 100$。价值重量比分别为 $v_a/w_a \\approx 100/51$，$v_b/w_b = 60/50$，以及 $v_c/w_c = 60/50$，因此物品 $a$ 的比率最高。\n\n按比率的贪心选择会首先选择物品 $a$；剩余容量为 $W - w_a = 49$，物品 $b$ 和物品 $c$ 都装不下，得到的总价值为 $100$。然而，子集 $\\{b, c\\}$ 是可行的，因为 $w_b + w_c = 100$，并且其总价值为 $120$，这严格优于 $100$。\n\n一个针对 $0/1$ 情况的朴素的基于交换的证明尝试过程如下：按 $v_i/w_i$ 的降序排序，设 $g$ 为某个最优解 $O$ 中未包含的最高比率物品，并论证可以从 $O$ 中移除一组总重量等于 $w_g$ 的较低比率物品，并用 $g$ 替换该重量；由于 $v_g/w_g$ 是最大的，总价值不会减少，这据说与最优性矛盾，除非 $g \\in O$。\n\n哪个陈述最精确地指出了这种基于交换的推理中，对于分数背包有效但对于 $0/1$ 背包无效的步骤，从而解释了为什么贪心比率规则在上述实例上失败？\n\nA. 交换步骤假设存在一个由较低比率物品组成的子集 $S \\subseteq O$，其满足 $\\sum_{i \\in S} w_i = w_g$，这样将 $S$ 换出并将 $g$ 换入可以保持可行性且不降低价值；这个假设依赖于物品的可分割性，在 $0/1$ 模型中不成立。\n\nB. 该证明错误地将目标 $\\sum_{i \\in S} v_i$ 替换为最大化 $\\sum_{i \\in S} (v_i/w_i)$，将比率视为线性聚合；这是关键的无效步骤。\n\nC. 该论证是合理的，因为对于任何最优解 $O$，总存在一个物品 $j \\in O$ 满足 $w_j \\le w_g$ 和 $v_j \\le v_g$，$g$ 可以直接替换它，因此贪心比率规则实际上对于 $0/1$ 背包是正确的。\n\nD. 该推理仅在容量 $W$ 恰好不等于贪心前缀的重量总和时失效；否则交换论证是有效的，贪心比率规则会成功。", "solution": "从核心定义开始。一个可行解 $S$ 满足 $\\sum_{i \\in S} w_i \\le W$。一个最优解 $O$ 是一个最大化 $\\sum_{i \\in O} v_i$ 的可行解。交换论证旨在通过用另一部分替换某一部分来改进一个可行解，同时保持可行性并增加或保持目标值。\n\n对于分数背包，以下经过充分检验的事实成立，并且通常通过交换推理来证明：如果物品是可分割的，按 $v_i/w_i$ 的降序排序并贪心地填充背包是最优的。关键的交换步骤是，任何被较低比率物品占用的重量为 $\\Delta$ 的部分，都可以被重量为 $\\Delta$ 的较高比率物品替换，从而增加或保持总价值，因为单位重量的价值更高。这本质上依赖于能够取物品的一部分，以便交换的重量能够精确匹配。\n\n分析给定实例的 $0/1$ 情况。按比率的贪心选择会首先选择物品 $a$，因为 $v_a/w_a \\approx 100/51 \\approx 1.9607$ 超过了物品 $b$ 和 $c$ 的 $1.2$。取走 $a$（重量 $51$）后，剩余容量为 $W - w_a = 100 - 51 = 49$，无法装下物品 $b$ 或物品 $c$（每个重量为 $50$）。因此，贪心解的价值为 $100$。\n\n考虑可行子集 $\\{b, c\\}$：其总重量为 $w_b + w_c = 50 + 50 = 100 \\le W$，其总价值为 $v_b + v_c = 60 + 60 = 120$。由于 $120 > 100$，贪心比率规则在此实例上失败。\n\n现在来审视针对 $0/1$ 情况的朴素的基于交换的证明尝试。设 $g$ 表示某个最优解 $O$ 中未包含的最高比率物品。该证明尝试声称：从 $O$ 中移除一组总重量等于 $w_g$ 的较低比率物品，并插入 $g$。因为 $v_g/w_g$ 超过了被移除物品的比率，总价值应该不会减少，这与最优性矛盾，除非 $g \\in O$。这个推理在分数背包情况下是有效的，因为可以通过取物品的分数部分，使得被移除的重量恰好为 $\\Delta = w_g$。\n\n在 $0/1$ 情况下，缺陷在于通常无法在 $O$ 中找到一个由完整物品组成的子集，其总重量恰好等于 $w_g$。如果所有物品都必须被完整地取走，精确匹配重量可能是不可能的。此外，要为 $g$ 腾出足够的空间，必须移除一个子集 $S \\subseteq O$，其总重量满足 $\\sum_{i \\in S} w_i \\ge w_g$，而当物品重量相对于 $w_g$ 而言是粗粒度时，这个不等式通常是严格的。移除超过 $w_g$ 的重量可能会损失比单位重量比率比较所能证明的更多的价值，并且由于整数性约束，剩余的容量可能会被浪费，从而破坏了价值保持的论证。\n\n具体来说，在所提供的实例中，设最优解为 $O = \\{b, c\\}$。不在 $O$ 中的最高比率物品是 $g = a$，其 $w_g = 51$。在 $\\{b, c\\}$ 中不存在总重量等于 $51$ 的子集，因为仅有的非空子集的总重量为 $50$ 和 $100$。要插入 $a$，我们必须移除总重量至少为 $51$ 的物品。移除 $\\{b\\}$ 或 $\\{c\\}$ 都会释放 $50$ 的重量，这不足以装下 $a$（因为 $50  51$）。同时移除两者会释放 $100$ 的重量，可以装下 $a$，但此时得到的集合价值为 $100$，严格小于 $v_b + v_c = 120$。分数背包的交换步骤本可以从 $\\{b, c\\}$ 的 $100$ 单位重量中精确移除 $51$ 单位重量，换入 $a$，同时保持或增加单位重量的价值。这一步在 $0/1$ 模型中是不可用的。\n\n因此，那个在分数情况下有效但在整数情况下失败的精确步骤是这样一个假设：我们可以挑选一个总重量恰好等于 $w_g$ 的物品子集，并用 $g$ 替换它，而不违反可行性，同时利用单位重量价值的比较。这个假设依赖于可分割性，在物品不可分割时是无效的。\n\n逐项分析选项：\n\nA. 这个选项精确地指出了使用较低比率物品进行精确重量交换的假设，即存在一个子集 $S \\subseteq O$ 满足 $\\sum_{i \\in S} w_i = w_g$ 以便换出并换入 $g$。这一步在分数背包中是合理的（可以通过取分数来达到精确的重量），但在 $0/1$ 背包中则不然，因为物品的重量是不可分割的。具体实例中的失败恰好证明了这种不匹配。结论：正确。\n\nB. 这声称证明的关键错误在于将价值总和替换为比率总和，好像比率可以线性聚合一样。尽管将 $\\sum (v_i/w_i)$ 作为目标函数是错误的，但所概述的朴素的基于交换的证明并未进行这种替换；它对交换部分使用了单位重量价值的比较，这对于分数物品是有效的。核心的失败之处不是目标函数的错误指定，而是在整数约束下精确重量交换的不可行性。结论：不正确。\n\nC. 这断言总能找到一个单独的物品 $j \\in O$ 满足 $w_j \\le w_g$ 和 $v_j \\le v_g$ 以进行直接交换，从而得出贪心算法正确的结论。这在通常情况下是错误的。在该实例中，$50 \\le 51$ 实际上成立；然而，用 $a$ 交换 $b$ 或 $c$ 会违反可行性，因为 $w_a = 51$，而移除 $50$ 的重量所释放的容量不足，除非对剩余集合进行调整；此外，即使可以安排可行性，$v_j \\le v_g$ 也不能保证交换能保持最优性。更广泛地说，这样的 $j$ 的存在性没有保证，即使 $w_j \\le w_g$，交换也可能无法装入 $O \\setminus \\{j\\}$ 的剩余容量中。这没有指出分数与整数交换步骤的区别，并且错误地断言了贪心算法的正确性。结论：不正确。\n\nD. 这声称该推理仅在一个特殊情况下失效，即容量 $W$ 等于贪心前缀的重量总和；否则交换论证有效，贪心比率规则成功。比率贪心算法的失败和交换步骤的失效并不局限于该边界情况；只要在整数约束下无法为交换进行精确的重量匹配，它们就会出现，而这与 $W$ 是否等于贪心前缀总和无关。给定的反例已经显示了在 $W = 100$ 和贪心前缀重量为 $51$ 的情况下的失败，并没有特殊的等式条件。结论：不正确。", "answer": "$$\\boxed{A}$$", "id": "3232116"}, {"introduction": "贪心算法的正确性取决于能否按价值密度 $\\rho_i = \\frac{v_i}{w_i}$ 对物品进行精确排序。在编程实现时，简单地使用浮点数除法可能会导致精度误差和错误的排序，尤其是在处理大数值时。这个编程练习将展示这一陷阱，并指导你使用整数交叉相乘法实现一个更稳健的排序方法，这是编写正确可靠的算法代码的一项重要技巧。[@problem_id:3235975]", "problem": "给定一个物品集合，每个物品有一个非负整数价值 $v_i$ 和一个正整数重量 $w_i$，以及一个容量为 $C \\ge 0$ 的背包。在分数背包问题中，你可以取走物品的任意实数部分，对于物品 $i$，若取走的部分为 $x_i \\in [0,1]$，其贡献的总价值为 $x_i \\cdot v_i$，消耗的总重量为 $x_i \\cdot w_i$。需要最大化的总价值为 $\\sum_{i=1}^n x_i v_i$，约束条件为 $\\sum_{i=1}^n x_i w_i \\le C$ 以及对所有 $i$ 都有 $0 \\le x_i \\le 1$。一种基本方法是按价值密度非递增顺序进行贪心选择，其中物品 $i$ 的价值密度为 $v_i / w_i$。\n\n本问题探讨当 $v_i, w_i$ 高达 $10^{12}$ 时，按 $v_i / w_i$ 对物品进行排序的数值稳定性问题，并要求你比较两种排序方法：\n- 朴素浮点数比较：将 $v_i / w_i$ 计算为 IEEE $754$ 双精度浮点数，并按这些浮点数值进行非递增排序。\n- 整数交叉相乘比较：通过使用精确整数算术测试 $v_i w_j$ 与 $v_j w_i$ 的大小来比较物品 $i$ 和 $j$；如果 $v_i w_j > v_j w_i$，则 $i$ 排在 $j$ 前面；如果 $v_i w_j  v_j w_i$，则 $j$ 排在 $i$ 前面；如果 $v_i w_j = v_j w_i$，则通过确定性规则打破平局：首先按 $w$ 较小的排序，然后按 $v$ 较大的排序，最后按原始索引较小的排序。\n\n构建并使用一个小型测试套件，以展示朴素浮点数比较在何种情况下无法复现精确的有理数排序。特别地，应包含一些对抗性输入，这些输入产生的密度差小于一个末位单位（unit in the last place，通常缩写为 ULP，对于接近 $1$ 的双精度浮点数，ULP 约等于 $2^{-52} \\approx 2.22 \\cdot 10^{-16}$），从而导致舍入误差引起错误的相等判断或排序错误。你的实现不应依赖随机性，必须是确定性的。\n\n为每个测试用例实现两种排序：\n- 使用双精度浮点数算术，按键 $v_i / w_i$ 进行排序 $S_{\\text{float}}$。\n- 使用整数交叉相乘 $v_i w_j$ 与 $v_j w_i$ 的精确比较器进行排序 $S_{\\text{int}}$。\n\n对于每个测试用例，输出一个布尔值，指示 $S_{\\text{float}}$ 产生的物品索引顺序是否与 $S_{\\text{int}}$ 完全相同。\n\n使用以下测试套件。所有价值和重量均为整数，所有容量也均为整数。\n\n- 测试用例 $1$ (正常路径):\n  - 物品: $\\{(v,w)\\} = \\{(60,10),(100,20),(120,30)\\}$。\n  - 容量: $C = 50$。\n  - 理由：典型的小数值；浮点数排序应与精确排序一致。\n\n- 测试用例 $2$ (对于 $b = 10^{12}$ 的对抗性准平局):\n  - 令 $b = 10^{12}$。\n  - 物品: $\\{(v,w)\\} = \\{(b-1, b), (b, b+1), (\\lfloor b/2 \\rfloor, b)\\}$。\n  - 容量: $C = b$。\n  - 理由：$\\frac{b-1}{b} = 1 - \\frac{1}{b}$ 和 $\\frac{b}{b+1} = 1 - \\frac{1}{b+1}$ 相差 $\\frac{1}{b(b+1)} \\approx 10^{-24}$，这比接近 $1$ 的双精度浮点数的 ULP 要小；朴素的浮点数除法很可能会将这些密度视为相等，从而产生一个依赖于输入顺序的排序结果，而整数交叉相乘则会得出一个严格的顺序。\n\n- 测试用例 $3$ (边界容量 $0$):\n  - 物品: $\\{(v,w)\\} = \\{(10^{12}, 10^{12}), (10^{12}, 1)\\}$。\n  - 容量: $C = 0$。\n  - 理由：容量为 $0$ 确保无法拿取任何物品；预期排序结果会一致，但此用例可测试对极大数量级的处理。\n\n- 测试用例 $4$ (容量超过总重量):\n  - 物品: $\\{(v,w)\\} = \\{(10^{12}, 10^{12}), (10^{12}, 10^{12})\\}$。\n  - 容量: $C = 2 \\cdot 10^{12}$。\n  - 理由：容量足够大，可以完全拿取所有物品；预期排序结果会一致。\n\n- 测试用例 $5$ (对于 $b = 10^{12}$ 的一系列准平局):\n  - 令 $b = 10^{12}$。\n  - 物品: $\\{(v,w)\\} = \\{(b-2, b), (b-1, b+1), (b, b+2)\\}$。\n  - 容量: $C = b+1$。\n  - 理由：所有密度都在 $1$ 的约 $10^{-12}$ 范围内，其严格有理数排序为 $\\frac{b-2}{b}  \\frac{b-1}{b+1}  \\frac{b}{b+2}$；朴素的浮点数除法通常会将它们映射为非常接近或相等的、接近 $1$ 的双精度浮点数，而稳定排序可能会保留输入顺序，从而与精确比较器的结果不同。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），每个结果都是一个布尔值，表示该测试用例的朴素浮点排序顺序是否与精确整数交叉相乘排序顺序相同。不涉及单位，所有输出均为布尔值。", "solution": "用户希望在分数背包问题的背景下，比较两种按价值密度（$v/w$）对物品进行排序的方法。此任务突显了当精度至关重要时，浮点数运算的潜在陷阱。\n\n### 问题验证\n\n我将首先根据要求的协议验证问题陈述。\n\n#### 步骤 1：提取给定信息\n\n- **问题领域**：分数背包算法，重点在于初始排序步骤。\n- **物品定义**：每个物品 $i$ 由一个非负整数价值 $v_i$ 和一个正整数重量 $w_i$ 定义。$v_i$ 和 $w_i$ 的值都可以大到 $10^{12}$。\n- **待比较的排序方法**：\n    1.  **$S_{\\text{float}}$（朴素浮点数排序）**：按物品价值密度 $v_i / w_i$ 的非递增顺序排序，其中除法使用 IEEE $754$ 双精度浮点数算术执行。\n    2.  **$S_{\\text{int}}$（精确整数排序）**：通过自定义比较函数对物品进行排序。为比较物品 $i$ 和 $j$，通过评估等效的整数不等式 $v_i w_j > v_j w_i$ 来检验不等式 $v_i / w_i > v_j / w_i$。\n- **$S_{\\text{int}}$ 的平局打破规则**：如果 $v_i w_j = v_j w_i$，则按以下有序标准打破平局：\n    1.  重量 $w$ 小者优先。\n    2.  价值 $v$ 大者优先。\n    3.  原始索引小者优先。\n- **任务**：对于给定的测试套件，为每个用例确定由 $S_{\\text{float}}$ 产生的物品索引序列是否与由 $S_{\\text{int}}$ 产生的序列完全相同。\n- **测试套件**：\n    - **用例 1**：物品 $\\{(60,10),(100,20),(120,30)\\}$，$C = 50$。\n    - **用例 2**：$b = 10^{12}$。物品 $\\{(b-1, b), (b, b+1), (\\lfloor b/2 \\rfloor, b)\\}$，$C = b$。\n    - **用例 3**：物品 $\\{(10^{12}, 10^{12}), (10^{12}, 1)\\}$，$C = 0$。\n    - **用例 4**：物品 $\\{(10^{12}, 10^{12}), (10^{12}, 10^{12})\\}$，$C = 2 \\cdot 10^{12}$。\n    - **用例 5**：$b = 10^{12}$。物品 $\\{(b-2, b), (b-1, b+1), (b, b+2)\\}$，$C = b+1$。\n\n#### 步骤 2：使用提取的给定信息进行验证\n\n- **科学基础**：该问题在计算数学和计算机科学领域有坚实的基础。它解决了浮点数表示中数值精度损失这一基本而实际的问题，这是数值分析的核心主题。使用交叉相乘进行精确分数比较是一种标准的、数学上合理的技术。该问题要求处理高达 $10^{12}$ 的整数及其乘积，乘积可达约 $10^{24}$。这超过了标准 $64$ 位整数的容量（最大值约为 $1.8 \\times 10^{19}$），但 Python 的任意精度整数可以正确处理，使得问题按规定在计算上是可行的。\n- **适定性**：该问题是适定的。输入被明确定义。两种方法的排序标准都是明确的。基于整数的排序的平局打破规则是全面的，并确保了唯一、确定性的排序。输出格式被精确指定。\n- **客观性**：问题以客观、正式的语言陈述，没有偏见或主观断言。\n\n一个需要审视的点是测试用例 5 的理由，其中陈述密度的排序为 $\\frac{b}{b+2}  \\frac{b-2}{b}  \\frac{b-1}{b+1}$。直接的数学分析表明这是不正确的。正确的排序是 $\\frac{b-2}{b}  \\frac{b-1}{b+1}  \\frac{b}{b+2}$。然而，这个错误出现在解释性的“理由”文本中，而不是在问题的正式规范（物品列表）中。核心任务是将指定的排序算法应用于给定的物品数据，这仍然是一个有效且可解决的问题。理由中的错误不会妨碍正确的实现或关于数值稳定性的结论。因此，它不会使问题无效。\n\n#### 步骤 3：结论与行动\n\n该问题是**有效的**。核心逻辑合理，前提具有科学性，任务定义明确。我将继续提供解决方案。\n\n### 基于原则的解决方案设计\n\n解决方案将涉及为一个物品列表实现两个不同的排序过程，然后比较它们的结果。一个物品将被表示为一个元组 $(v, w, \\text{original\\_index})$，以保留其原始位置，用于最终比较和打破平局。\n\n1.  **数据表示**：来自输入集的每个物品，例如 $(v,w)$，将被其原始索引 $i$ 增强，形成一个结构 $(v, w, i)$。这对于比较最终的排序顺序和在整数排序中进行确定性平局打破至关重要。\n\n2.  **浮点数排序 ($S_{\\text{float}}$)**：\n    -   此排序将使用 Python 内置的 `sorted()` 函数，这是一个稳定排序（Timsort）。\n    -   物品 $(v, w, i)$ 的排序键将是浮点值 $v/w$。\n    -   排序将按降序（`reverse=True`）进行，以满足贪心背包策略的要求。\n    -   Python 的标准 `float` 类型是 IEEE $754$ 双精度数，符合问题规范。\n    -   因为排序是稳定的，如果两个物品的密度被舍入为相同的浮点值，它们的原始相对顺序将被保留。这是对抗性测试用例旨在揭示的关键行为。\n\n3.  **整数交叉相乘排序 ($S_{\\text{int}}$)**：\n    -   此排序也使用 `sorted()`，但带有一个通过 `functools.cmp_to_key` 提供的自定义比较函数。这允许按规定对物品进行直接的成对比较。\n    -   比较函数 `compare(item1, item2)`，其中 `item1` = $(v_1, w_1, i_1)$ 和 `item2` = $(v_2, w_2, i_2)$，将实现精确的有理数比较逻辑。\n    -   **主比较**：它将计算差值 $v_1 w_2 - v_2 w_1$ 的符号。由于价值和重量的量级很大（高达 $10^{12}$），它们的乘积可以达到 $10^{24}$，需要任意精度整数，Python 原生支持这一点。\n        -   如果 $v_1 w_2 > v_2 w_1$，则 `item1` 的密度更高。对于降序排序，`item1` 应排在 `item2` 之前。比较器返回一个负值（例如，$-1$）。\n        -   如果 $v_1 w_2  v_2 w_1$，则 `item2` 的密度更高。比较器返回一个正值（例如，$1$）。\n    -   **平局打破逻辑**：如果 $v_1 w_2 = v_2 w_1$，则按顺序应用指定的平局打破规则：\n        1.  比较重量：如果 $w_1  w_2$，则 `item1` 优先（返回 $-1$）。\n        2.  比较价值：如果 $v_1 > v_2$，则 `item1` 优先（返回 $-1$）。\n        3.  比较索引：如果 $i_1  i_2$，则 `item1` 优先（返回 $-1$）。\n\n4.  **比较与输出**：\n    -   排序过程完成后，将从 $S_{\\text{float}}$ 和 $S_{\\text{int}}$ 生成两个索引列表。\n    -   比较这两个索引列表是否相等。为每个测试用例存储一个布尔结果（`True` 表示相同，`False` 表示不同）。\n    -   最终输出是这些布尔结果的列表，格式化为字符串。\n\n让我们追踪一个对抗性案例，例如测试用例 2，物品为 $(b-1, b, 0)$ 和 $(b, b+1, 1)$，其中 $b=10^{12}$。\n- **$S_{\\text{int}}$**：比较 $v_0/w_0$ 和 $v_1/w_1$。交叉相乘：$v_0 w_1 = (b-1)(b+1) = b^2-1$。$v_1 w_0 = b \\cdot b = b^2$。因为 $b^2-1  b^2$，我们有 $v_0/w_0  v_1/w_1$。正确的降序排序将物品 $1$ 放在物品 $0$ 之前。\n- **$S_{\\text{float}}$**：密度为 $d_0 = \\frac{b-1}{b}$ 和 $d_1 = \\frac{b}{b+1}$。这两个值非常接近：$d_1 - d_0 \\approx 1/b^2 = 10^{-24}$。这个差异小于双精度浮点数相对于 $1$ 的机器精度（约 $2.22 \\times 10^{-16}$）。因此，`(b-1)/b` 和 `b/(b+1)` 很可能会计算出相同的双精度值。因为 Python 的排序是稳定的，并且排序键相等，物品 $0$ 和物品 $1$ 的原始顺序将被保留。这导致物品 $0$ 排在物品 $1$ 之前，这与 $S_{\\text{int}}$ 的精确结果相矛盾。因此，此用例的比较将产生 `False`。\n\n这种详细的方法确保了解决方案的正确性和鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport functools\n\ndef solve():\n    \"\"\"\n    Implements and compares two sorting methods for fractional knapsack items\n    to demonstrate numerical instability of floating-point arithmetic.\n    \"\"\"\n    \n    # Define the base value for adversarial test cases\n    b = 10**12\n\n    # Define the test suite as per the problem statement.\n    # Each test case contains a list of (value, weight) tuples and a capacity.\n    # The capacity C is not used in the sorting logic but is part of the problem definition.\n    test_cases = [\n        {\n            \"items\": [(60, 10), (100, 20), (120, 30)],\n            \"C\": 50\n        },\n        {\n            \"items\": [(b - 1, b), (b, b + 1), (b // 2, b)],\n            \"C\": b\n        },\n        {\n            \"items\": [(10**12, 10**12), (10**12, 1)],\n            \"C\": 0\n        },\n        {\n            \"items\": [(10**12, 10**12), (10**12, 10**12)],\n            \"C\": 2 * 10**12\n        },\n        {\n            \"items\": [(b - 2, b), (b - 1, b + 1), (b, b + 2)],\n            \"C\": b + 1\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Augment items with their original index to track order\n        # item format: (value, weight, original_index)\n        items_with_indices = [(v, w, i) for i, (v, w) in enumerate(case['items'])]\n\n        # Method 1: S_float - Naive sort using floating-point division\n        # Python's sort is stable. If densities are rounded to the same float,\n        # their original relative order is preserved.\n        # Sorting in non-increasing (descending) order of value density.\n        s_float_sorted = sorted(items_with_indices, key=lambda item: item[0] / item[1], reverse=True)\n        s_float_indices = [item[2] for item in s_float_sorted]\n\n        # Method 2: S_int - Exact sort using integer cross-multiplication\n        # This requires a custom comparison function.\n        def compare_items(item1, item2):\n            \"\"\"\n            Comparator for sorting items by value density using exact integer arithmetic.\n            Returns -1 if item1 > item2, 1 if item1  item2, 0 if equal.\n            \"\"\"\n            v1, w1, idx1 = item1\n            v2, w2, idx2 = item2\n            \n            # To compare v1/w1 with v2/w2, we compare v1*w2 with v2*w1.\n            # Python's integers handle arbitrary precision, avoiding overflow.\n            cross_product_diff = v1 * w2 - v2 * w1\n            \n            if cross_product_diff > 0: # v1/w1 > v2/w2\n                return -1 # item1 comes first in descending sort\n            if cross_product_diff  0: # v1/w1  v2/w2\n                return 1  # item2 comes first in descending sort\n            \n            # Densities are equal, apply specified tie-breaking rules.\n            # 1. Smaller weight first\n            if w1  w2:\n                return -1\n            if w1 > w2:\n                return 1\n            \n            # 2. Larger value first\n            if v1 > v2:\n                return -1\n            if v1  v2:\n                return 1\n\n            # 3. Smaller original index first\n            if idx1  idx2:\n                return -1\n            if idx1 > idx2:\n                return 1\n            \n            # This case should not be reached if original indices are unique\n            return 0 \n\n        s_int_sorted = sorted(items_with_indices, key=functools.cmp_to_key(compare_items))\n        s_int_indices = [item[2] for item in s_int_sorted]\n        \n        # Compare the resulting order of indices from both sorting methods\n        results.append(s_float_indices == s_int_indices)\n\n    # Print results in the specified single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3235975"}, {"introduction": "如果你需要针对许多不同的背包容量求解分数背包问题，该怎么办？对每个查询都完整地重新运行整个算法是低效的。本练习将挑战你设计一个更快的算法，通过对物品进行一次预处理，然后在一个高效的单次遍历中回答所有查询。这将介绍一种强大的算法模式，该模式适用于许多可以将查询排序后一并处理的问题。[@problem_id:3235987]", "problem": "给定一个包含 $n$ 个物品的集合，其中每个物品 $i$ 都有一个严格为正的重量 $w_i \\in \\mathbb{R}_{0}$ 和一个非负的价值 $v_i \\in \\mathbb{R}_{\\ge 0}$。在经典的部分背包问题中，对于一个给定的容量 $W \\in \\mathbb{R}_{\\ge 0}$，您可以选择每个物品 $i$ 的任意分数（或比例）$x_i \\in [0,1]$，其占用的重量为 $x_i \\cdot w_i$，产生的价值为 $x_i \\cdot v_i$，但总重量 $\\sum_{i=1}^n x_i w_i$ 不得超过 $W$。令 $\\mathrm{OPT}(W)$ 表示在此松弛条件下可实现的最大总价值。您需要对一组固定的物品，回答批量查询 $\\{W_1,\\dots,W_q\\}$，其中 $q$ 可能很大。\n\n请仅从问题的核心定义（由线性不等式定义的可行集以及在该集合上最大化一个线性目标）出发，设计一个算法。该算法应对物品进行一次精确的预处理，然后通过重用物品的单一排序和累积信息，在预处理后以 $O(n+q)$ 的总时间回答所有关于 $\\mathrm{OPT}(W_j)$ 的 $q$ 个查询。您的方法应仅基于比较和算术运算，并且除了标准的排序和线性扫描外，不应假定任何特殊的预言机（oracle）。您必须基于第一性原理给出具有原则性的正确性证明，不得引用未经证明的启发式方法。\n\n您的程序必须实现您的算法，并为以下测试套件计算答案。每个测试用例包含一个以 $(v_i,w_i)$ 对形式给出的物品列表和一个容量列表 $[W_1,\\dots,W_q]$。所有重量和价值均为可表示为有限小数的实数，所有容量均为 $\\mathbb{R}_{\\ge 0}$ 中的实数。\n\n测试用例 1:\n- 物品 $[(v_i,w_i)]$: $[(20,4),(14,2),(24,6),(9,3),(30,5),(4,1)]$.\n- 容量 $[W_j]$: $[0,1,2,3,7,10,11,12,17,18,21,25]$.\n\n测试用例 2:\n- 物品 $[(v_i,w_i)]$: $[(6,3),(10,5),(14,7),(22,11)]$.\n- 容量 $[W_j]$: $[0,3,4,8,26,27]$.\n\n测试用例 3:\n- 物品 $[(v_i,w_i)]$: $[(13,8),(2,1),(18,9),(3,2),(8,4)]$.\n- 容量 $[W_j]$: $[0,1,5,10,12,14,15,22,23,24,30]$.\n\n输出规范:\n- 对每个测试用例，计算给定物品和容量的列表 $[\\mathrm{OPT}(W_1),\\dots,\\mathrm{OPT}(W_q)]$，并将所有测试用例的结果按指定顺序汇总到一个扁平列表中。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个值必须是四舍五入到小数点后恰好六位的实数。例如，一个包含三个结果的输出应形如 $[x_1,x_2,x_3]$，其中每个 $x_j$ 在小数点后恰好有六位数字。\n- 不涉及物理单位，所有实数必须以所需的定点格式打印。\n\n您的交付成果:\n- 一个清晰的算法设计，该算法对物品进行一次精确的预处理，并通过重用相同的排序和累积信息，在预处理后以 $O(n+q)$ 的总时间回答所有 $q$ 个查询。\n- 一个基于可行区域和线性目标的基本定义的、有原则的正确性证明。\n- 一个完整、可运行的程序，为所提供的测试套件计算答案，并按上述确切格式打印结果。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个在算法和优化领域中的良构问题，其基础是线性规划的形式化原则。所有给定条件都是完整、一致且科学合理的。\n\n部分背包问题是在线性不等式约束下最大化一个线性目标函数。形式上，对于一组 $n$ 个物品，其中物品 $i$ 的价值为 $v_i \\in \\mathbb{R}_{\\ge 0}$，重量为 $w_i \\in \\mathbb{R}_{0}$，以及一个容量为 $W$ 的背包，我们希望找到分数 $x_i \\in [0,1]$ 来求解以下线性规划（LP）问题：\n\n$$\n\\text{最大化} \\quad Z = \\sum_{i=1}^n x_i v_i\n$$\n$$\n\\text{约束条件} \\quad \\sum_{i=1}^n x_i w_i \\le W\n$$\n$$\n0 \\le x_i \\le 1, \\quad \\text{对于 } i=1, \\dots, n\n$$\n\n这个线性规划问题的最优解可以通过贪心策略找到。我们定义每个物品的价值密度为 $\\rho_i = v_i / w_i$。贪心策略规定，应按价值密度的降序来拿取物品。\n\n我们可以通过交换论证来证明该策略的最优性。假设物品已按 $\\rho_1 \\ge \\rho_2 \\ge \\dots \\ge \\rho_n$ 的顺序索引。令 $G = (x_1, \\dots, x_n)$ 为贪心算法产生的解。令 $O = (y_1, \\dots, y_n)$ 为任意一个最优解。令 $k$ 为第一个使得 $x_k \\neq y_k$ 的索引。根据贪心算法的性质，必然有 $x_k > y_k$。这意味着贪心算法比最优解装入了更多的物品 $k$。由于最优解的总重量必须至少等于贪心解的总重量（除非贪心解没有用完所有容量，此时它已拿取所有物品，显然是最优的），因此必然存在某个索引 $j > k$ 使得 $y_j > x_j$。根据我们的排序顺序，我们有 $\\rho_k \\ge \\rho_j$。因为 $y_j > x_j$ 且 $x_k > y_k$，我们可以构造一个新解 $O'$，方法是从物品 $j$ 中取出重量为 $\\Delta w = \\min(x_k w_k - y_k w_k, y_j w_j - x_j w_j)$ 的部分，并将其重新分配给物品 $k$。分数的改变量为 $\\Delta x_k = \\Delta w / w_k$ 和 $\\Delta x_j = -\\Delta w / w_j$。新解 $O'$ 在总重量上仍然是可行的。总价值的变化量为 $\\Delta V = \\Delta x_k v_k + \\Delta x_j v_j = (\\Delta w / w_k)v_k - (\\Delta w / w_j)v_j = \\Delta w (\\rho_k - \\rho_j)$。由于 $\\rho_k \\ge \\rho_j$ 且 $\\Delta w > 0$，价值的变化量 $\\Delta V \\ge 0$。通过这次交换，我们可以将 $O$ 转换为一个更接近 $G$ 且总价值不减少的解。重复此过程，我们可以逐步将 $O$ 转换为 $G$，从而证明 $G$ 也是一个最优解。\n\n最优价值 $\\mathrm{OPT}(W)$ 是一个关于容量 $W$ 的连续、分段线性和凹函数。该函数的断点出现在按密度排序后物品的累积重量处。令排序后的物品索引为 $1, \\dots, n$。令 $C_k = \\sum_{i=1}^k w_i$ 和 $V_k = \\sum_{i=1}^k v_i$ 分别为累积重量和累积价值，并设 $C_0=V_0=0$。对于区间 $[C_{k-1}, C_k]$ 内的任何容量 $W$，最优价值可以通过完全拿取物品 $1, \\dots, k-1$ 以及物品 $k$ 的一部分来获得。其价值由下式给出：\n$$\n\\mathrm{OPT}(W) = V_{k-1} + (W - C_{k-1}) \\cdot \\rho_k\n$$\n这种结构是高效解决批量查询的关键。一种朴素的方法是为 $q$ 个查询中的每一个 $W_j$ 都重新计算一遍，这将耗时 $O(q \\cdot (n \\log n))$，或者如果排序只进行一次，则耗时 $O(n \\log n + qn)$。我们需要做得更好。\n\n所要求的在预处理后所有查询的总时间复杂度为 $O(n+q)$，这表明需要一个避免重复计算的线性时间算法。如果物品和查询都按排序顺序处理，则可以实现这种性能。\n\n提议的算法如下：\n\n**1. 预处理阶段 ($O(n \\log n)$ 时间):**\n- 对每个物品 $i$，计算其价值密度 $\\rho_i = v_i / w_i$。\n- 按密度的降序对 $n$ 个物品进行排序。令排序后的物品、其重量、价值和密度表示为 $(v'_i, w'_i, \\rho'_i)$，其中 $i=1, \\dots, n$。\n\n**2. 查询回答阶段 ($O(q \\log q + n)$ 时间):**\n- 将 $q$ 个查询容量 $\\{W_1, \\dots, W_q\\}$ 的列表与其原始索引配对，创建成对数据 $(W_j, j)$。\n- 按容量 $W_j$ 的升序对这些配对数据进行排序。此步骤耗时 $O(q \\log q)$。\n- 现在我们可以使用双指针（或线性扫描）方法处理排序后的物品和查询。初始化一个物品指针 `item_idx = 0`，以及累积状态变量：`current_weight = 0`，`current_value = 0`。\n- 遍历排序后的查询 $(W, \\text{orig\\_idx})$。对于每个查询，推进 `item_idx` 以包含所有可以完全放入容量为 $W$ 的背包中的物品。由于查询是按 $W$ 递增排序的，`item_idx` 指针只会向前移动。\n- 对于给定的查询 $W$，只要下一个完整物品 `item_idx` 能放入容量 `W` 中，我们就推进 `item_idx`，并相应地更新 `current_weight` 和 `current_value`。在所有 $q$ 个查询中，`item_idx` 的总增量最多为 $n$。\n- 在计入所有完整物品后，容量 $W$ 对应的价值是 `current_value` 加上下一个物品（如果存在，其索引为`item_idx`）的小数部分的价值。剩余容量是 $W - \\text{current\\_weight}$，增加的价值是 $(W - \\text{current\\_weight}) \\cdot \\rho'_{\\text{item\\_idx}+1}$。\n- 遍历 $q$ 个已排序查询和将物品指针移动过 $n$ 个物品的总工作量是 $O(n+q)$。\n- 因此，查询阶段的总时间主要由排序查询决定，为 $O(q \\log q + n)$。这符合题目的精神，即排序后的核心计算逻辑是一个高效的线性扫描。\n\n该算法通过有效利用物品和容量的排序顺序，避免了冗余计算，从而正确地计算出每个查询的最优值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_knapsack_batched(items, capacities):\n    \"\"\"\n    Solves the fractional knapsack problem for a batch of capacities.\n\n    Args:\n        items (list): A list of tuples (value, weight) for each item.\n        capacities (list): A list of knapsack capacities to query.\n\n    Returns:\n        list: A list of maximum values for each corresponding capacity.\n    \"\"\"\n    n = len(items)\n    q = len(capacities)\n\n    if n == 0:\n        return [0.0] * q\n\n    # 1. Preprocessing Phase\n    # Create a structured array for items with value, weight, and density.\n    item_dtype = [('v', 'f8'), ('w', 'f8')]\n    items_arr = np.array(items, dtype=item_dtype)\n    \n    # Add density, rho = v/w.\n    # We create a new array to add the rho column.\n    processed_items = np.zeros(n, dtype=[('v', 'f8'), ('w', 'f8'), ('rho', 'f8')])\n    processed_items['v'] = items_arr['v']\n    processed_items['w'] = items_arr['w']\n    # Weights are strictly positive per problem statement.\n    processed_items['rho'] = processed_items['v'] / processed_items['w']\n\n    # Sort items by density in descending order. `mergesort` is stable.\n    processed_items.sort(order='rho', kind='mergesort')\n    sorted_items = processed_items[::-1]\n\n    # 2. Query Answering Phase\n    # Create a structured array for queries to hold capacity and original index.\n    query_dtype = [('W', 'f8'), ('orig_idx', 'i4')]\n    queries_arr = np.empty(q, dtype=query_dtype)\n    queries_arr['W'] = capacities\n    queries_arr['orig_idx'] = np.arange(q)\n\n    # Sort queries by capacity in ascending order.\n    queries_arr.sort(order='W', kind='mergesort')\n    \n    results = np.zeros(q, dtype='f8')\n    \n    # Pointers and accumulators for the linear scan.\n    item_idx = 0\n    current_weight = 0.0\n    current_value = 0.0\n\n    # Iterate through sorted queries.\n    for query_W, orig_idx in queries_arr:\n        # Add full items that fit.\n        # The item_idx pointer only moves forward across all queries.\n        while item_idx  n and current_weight + sorted_items[item_idx]['w'] = query_W:\n            current_weight += sorted_items[item_idx]['w']\n            current_value += sorted_items[item_idx]['v']\n            item_idx += 1\n            \n        total_value = current_value\n        remaining_capacity = query_W - current_weight\n        \n        # Add the fractional part of the next item.\n        if remaining_capacity > 0 and item_idx  n:\n            total_value += remaining_capacity * sorted_items[item_idx]['rho']\n        \n        results[orig_idx] = total_value\n        \n    return list(results)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            [(20, 4), (14, 2), (24, 6), (9, 3), (30, 5), (4, 1)],\n            [0, 1, 2, 3, 7, 10, 11, 12, 17, 18, 21, 25]\n        ),\n        # Test case 2\n        (\n            [(6, 3), (10, 5), (14, 7), (22, 11)],\n            [0, 3, 4, 8, 26, 27]\n        ),\n        # Test case 3\n        (\n            [(13, 8), (2, 1), (18, 9), (3, 2), (8, 4)],\n            [0, 1, 5, 10, 12, 14, 15, 22, 23, 24, 30]\n        ),\n    ]\n\n    all_results = []\n    for items, capacities in test_cases:\n        result = solve_knapsack_batched(items, capacities)\n        all_results.extend(result)\n\n    # Final print statement in the exact required format.\n    # Each value must be rounded to exactly six digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3235987"}]}