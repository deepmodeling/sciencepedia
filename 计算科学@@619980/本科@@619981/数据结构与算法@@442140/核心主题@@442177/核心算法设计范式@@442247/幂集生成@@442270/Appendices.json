{"hands_on_practices": [{"introduction": "直接在内存中生成包含 $2^n$ 个元素的整个幂集通常是低效且不切实际的。本练习将指导你使用核心的位掩码技术，实现一个内存高效的“懒惰”幂集迭代器。这种方法仅在需要时才逐个生成子集，是处理组合对象时一项至关重要的编程技能。[@problem_id:3259468]", "problem": "要求您实现一个完整的、可运行的程序，为有限的不同整数序列构建一个“惰性”幂集迭代器。该迭代器必须仅在显式请求时才计算下一个子集，而不会在内存中预先计算或实例化整个幂集。此任务的基本依据是幂集的数学定义以及子集与二进制指示向量之间公认的双射关系。对于一个包含 $n$ 个不同元素的有限集 $S$，其幂集 $\\mathcal{P}(S)$ 是 $S$ 的所有子集的集合，其基数为 $2^n$。通过将二进制字符串中的每个位置 $i$ 映射到 $S$ 的第 $i$ 个元素是否存在，在 $\\mathcal{P}(S)$ 与所有长度为 $n$ 的二进制字符串集合 $\\{0,1\\}^n$ 之间存在一个双射。将指示向量的整数解释视为一个无符号数，其中最低有效位（定义为 Least Significant Bit, LSB）对应输入序列的第一个元素，下一位对应第二个元素，依此类推。所要求的子集枚举顺序是按照相应指示向量的整数值的升序排列，从整数 $0$（映射到空子集）开始，到整数 $2^n - 1$ 结束。\n\n程序要求：\n- 实现一个 $\\mathcal{P}(S)$ 的“惰性”迭代器，该迭代器仅在显式推进时才生成下一个子集，并且除了当前子集外，绝不实例化更多内容。除了存储输入序列外，空间开销必须为 $\\mathcal{O}(n)$，其中 $n$ 是输入序列的长度。\n- 枚举顺序必须严格按照指示向量的整数值升序排列，且 LSB 与输入序列的第一个元素对齐。\n- 程序必须包含一个内部测试套件，该套件包含多个参数集，并生成一行输出，其中包含所有测试用例的聚合结果，格式为方括号内以逗号分隔的列表，无空格。每个测试用例的结果必须是一个子集列表，其中每个子集表示为一个整数列表。\n\n测试套件规范：\n- 每个测试用例由一对 $(A, k)$ 组成，其中 $A$ 是一个有限的不同整数序列，$k$ 是一个非负整数，指定从迭代器请求多少个连续的子集，从空子集开始。如果 $k$ 超过 $2^{|A|}$，迭代器应在生成 $2^{|A|}$ 个子集后自然停止。\n- 使用以下测试用例：\n  - 用例 1：$A = [\\,]$, $k = 1$。\n  - 用例 2：$A = [\\,7\\,]$, $k = 2$。\n  - 用例 3：$A = [\\,1,2,3\\,]$, $k = 4$。\n  - 用例 4：$A = [\\,2,4,6,8\\,]$, $k = 9$。\n  - 用例 5：$A = [\\,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\\,]$, $k = 5$。\n\n答案规范：\n- 对于每个用例，答案是由惰性迭代器按指定顺序生成的前 $k$ 个子集的列表。每个子集本身是一个从输入序列中提取的整数列表。\n- 最终程序输出必须是单行文本，其中包含所有测试用例的聚合结果，格式为方括号内以逗号分隔的列表，无空格。例如，如果有三个测试用例的结果分别为 $R_1$、$R_2$ 和 $R_3$，则确切的输出格式为 $[R_1,R_2,R_3]$，其中每个 $R_i$ 是一个整数列表的列表（用方括号打印）。\n\n不允许用户输入。此问题中没有物理量，因此无需指定单位。不涉及角度和百分比。程序必须遵守指定的执行环境，并完全按照上述格式生成最终输出。", "solution": "为给定不同整数序列生成幂集的问题是一个源于集合论的经典组合任务，并且是算法设计的基础。基于双射的数学原理，可以构建一个直接且高效的解决方案。\n\n对于基数为 $|S| = n$ 的有限集 $S$，其幂集（表示为 $\\mathcal{P}(S)$）是 $S$ 所有可能子集的集合。幂集的基数为 $|\\mathcal{P}(S)| = 2^n$。在 $\\mathcal{P}(S)$ 中的子集与所有长度为 $n$ 的二进制字符串集合之间，存在一一对应关系（双射）。\n\n这种双射可以通过考虑 $S$ 中元素的有序序列（例如 $s_0, s_1, \\dots, s_{n-1}$）来建立。$S$ 的任何子集都可以由一个 $n$ 位二进制指示向量 $b = (b_{n-1}, \\dots, b_1, b_0)$ 唯一表示，其中如果元素 $s_j$ 存在于子集中，则位 $b_j$ 为 $1$，否则为 $0$。\n\n问题规定了精确的映射和枚举顺序。所有 $n$ 位二进制向量的集合对应于从 $0$ 到 $2^n - 1$ 的整数。子集的枚举必须遵循这些整数的升序。位到元素的映射定义为：最低有效位（LSB），即位 $0$，对应输入序列的第一个元素（索引为 $0$），位 $1$ 对应第二个元素（索引为 $1$），依此类推，直到位 $n-1$ 对应第 $n$ 个元素。\n\n任务是创建一个“惰性”迭代器，它只在被请求时才生成每个子集，而不是将整个幂集实例化到内存中。这一点对于效率至关重要，因为幂集的大小随输入序列的大小呈指数增长。要求的 $\\mathcal{O}(n)$ 空间复杂度开销排除了存储所有 $2^n$ 个子集的可能性。\n\n满足这些要求的算法可以设计如下：\n1.  设输入序列为 $A$，长度为 $n$。\n2.  子集的总数为 $N = 2^n$。\n3.  我们使用一个计数器（称之为 `i`），它从整数 $0$ 迭代到 $N-1$。`i` 的每个值唯一标识一个子集。\n4.  对于每个整数 `i`，我们即时构建相应的子集。为此，我们从 $j = 0$ 迭代到 $n-1$。在每一步 $j$，我们检查 `i` 的第 $j$ 位是否被设置为 $1$。\n5.  检查 `i` 的第 $j$ 位可以通过位运算高效完成。表达式 `(i >> j)  1` 在 `i` 的第 $j$ 位为 $1$ 时求值为 $1$，否则为 $0$。`>>` 运算符是右位移。\n6.  如果第 $j$ 位为 $1$，我们将输入序列中索引为 $j$ 的元素 $A[j]$ 包含在当前子集中。\n7.  对于每个请求的子集，重复此过程，迭代器在每次后续调用时将计数器 `i` 加一。\n\n在 Python 中，实现这种惰性迭代最地道的方法是使用生成器函数。生成器函数使用 `yield` 关键字返回一个值并暂停其执行，同时保留其内部状态（在此例中是计数器 `i`）。当请求下一个值时，函数从其离开的地方继续执行。这种方法自然满足了惰性求值和 $\\mathcal{O}(n)$ 空间复杂度的要求，因为它只存储输入序列、计数器的当前状态以及用于构建单个子集的内存。\n\n最终程序将实现此生成器。然后，它将遍历指定的测试用例。对于每个用例 $(A, k)$，它将创建一个新的生成器实例并检索前 $k$ 个子集，如果子集总数少于 $k$，则检索更少的子集。所有测试用例的结果被聚合成一个单一列表，然后根据具体的输出要求格式化为无空格的字符串表示。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lazy_power_set(sequence):\n    \"\"\"\n    A lazy iterator (generator) for the power set of a sequence.\n\n    The enumeration order follows the ascending integer value of the\n    binary indicator vector, where the LSB corresponds to the first\n    element of the sequence.\n\n    Args:\n        sequence (list): A list of distinct elements.\n\n    Yields:\n        list: The next subset in the enumeration.\n    \"\"\"\n    n = len(sequence)\n    num_subsets = 1  n  # This is 2**n\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            # Check if the j-th bit of i is set.\n            # (i >> j) shifts the j-th bit to the LSB position.\n            #  1 isolates this bit.\n            if (i >> j)  1:\n                subset.append(sequence[j])\n        yield subset\n\ndef format_list_no_spaces(obj):\n    \"\"\"\n    Recursively formats a list or other object into a string\n    representation without spaces after commas, as required by the spec.\n    \"\"\"\n    if isinstance(obj, list):\n        # Recursively format each item and join with commas.\n        return f\"[{','.join(format_list_no_spaces(item) for item in obj)}]\"\n    else:\n        # For non-list items, use their standard string representation.\n        return str(obj)\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([], 1),\n        ([7], 2),\n        ([1, 2, 3], 4),\n        ([2, 4, 6, 8], 9),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 5),\n    ]\n\n    all_results = []\n    for A, k in test_cases:\n        case_result = []\n        iterator = lazy_power_set(A)\n        \n        try:\n            for _ in range(k):\n                case_result.append(next(iterator))\n        except StopIteration:\n            # This handles cases where k > 2**|A|. The loop will\n            # naturally terminate when the iterator is exhausted.\n            pass\n            \n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The custom formatter ensures no spaces are included in the list representations.\n    print(format_list_no_spaces(all_results))\n\nsolve()\n```", "id": "3259468"}, {"introduction": "在掌握了如何生成所有子集之后，下一步常见的任务是只找出那些满足特定条件的子集。本练习将向你展示如何根据子集的大小（基数）进行筛选。通过将集合的属性（基数的奇偶性）与其位掩码表示的一个特性（“1”位的数量，或称总体计数）联系起来，你将学会一种强大的“生成并测试”的解题模式。[@problem_id:3259575]", "problem": "您的任务是生成有限集的子集，但仅限于那些满足指定子集大小奇偶性约束的子集。假设一个有限集表示为一个由不同整数组成的列表。奇偶性约束指定了子集的基数必须是偶数还是奇数。目标是设计一个程序，对于一组预定义的输入测试套件，使用确定性的顺序和表示方法，生成所有满足所要求奇偶性的子集的族。\n\n基本原理。请使用以下基本事实：\n- 一个包含 $n$ 个不同元素的集合，其幂集包含 $2^n$ 个子集。\n- 在 $0$ 到 $2^n - 1$ 范围内的整数与一个 $n$ 元素集的子集之间，通过二进制表示存在一一对应关系：一个整数的第 $i$ 位决定了第 $i$ 个元素的包含与否。\n- 一个子集大小的奇偶性，等于其对应二进制表示中 $1$ 的位数（也称为置位计数）的奇偶性。\n\n任务。实现一个完整的程序，该程序：\n- 不接受外部输入，而是在程序内部使用提供的测试套件。\n- 对于每个测试用例，给定一个由不同整数组成的列表 $A$ 和一个奇偶性选择器 $P \\in \\{\\text{\"even\"}, \\text{\"odd\"}\\}$，生成 $A$ 的所有子集，这些子集的基数具有 $P$ 指定的奇偶性。\n- 在生成子集之前，按升序对 $A$ 进行排序，以确保每个子集内元素的一致规范排序。\n- 从 $0$ 到 $2^n - 1$（其中 $n = |A|$），按位掩码的整数递增顺序枚举候选子集，并且只包含那些大小奇偶性与 $P$ 匹配的子集。\n- 将每个子集表示为按升序排列的整数列表，并将子集族表示为此类列表的列表。\n\n排序要求。对于一个长度为 $n$ 的输入列表 $A$，在按升序对 $A$ 排序后，定义第 $i$ 个位置（从零开始索引）对应于排序后列表的第 $i$ 个元素。对于从 $0$ 到 $2^n - 1$ 的每个整数掩码 $m$，当且仅当 $m$ 的第 $i$ 位为 $1$ 时，包含位置 $i$ 的元素。一个子集当且仅当 $m$ 中 $1$ 的位数模 $2$ 的结果与要求的奇偶性一致时，才被包含在输出中。子集族必须按 $m$ 的递增顺序列出。\n\n约束和说明。\n- $A$ 的所有元素都是不同的整数。\n- 奇偶性选择器是一个等于 \"even\" 或 \"odd\" 的字符串。\n- 没有随机性；顺序完全由上述位掩码枚举确定。\n- 不涉及物理量。\n\n测试套件。您的程序必须按此精确顺序解决以下测试用例：\n- 测试用例 1：$A = [1,2,3,4]$, $P = \\text{\"even\"}$。\n- 测试用例 2：$A = [-1,0,2]$, $P = \\text{\"odd\"}$。\n- 测试用例 3：$A = []$, $P = \\text{\"even\"}$。\n- 测试用例 4：$A = []$, $P = \\text{\"odd\"}$。\n- 测试用例 5：$A = [5]$, $P = \\text{\"odd\"}$。\n\n要求的输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个结果是对应测试用例的子集列表。每个子集必须呈现为整数列表。例如，输出必须具有以下形式:\n[[subsets_for_case_1],[subsets_for_case_2],[subsets_for_case_3],[subsets_for_case_4],[subsets_for_case_5]]\n不需要额外的文本或空白字符。\n\n答案类型。每个测试用例的结果是一个由整数列表组成的列表，因此汇总的最终输出是此类列表的列表。所有数字都是整数，且列表只包含整数。\n\n交付成果。提供一个完整的、可运行的程序，该程序按规定构建测试套件，精确生成所定义的输出，并打印聚合的单行结果。", "solution": "所述问题是有效的。它在科学上基于集合论和离散数学的原理，特别是关于幂集的性质及其使用二进制整数的表示。该问题是适定 (well-posed) 的，提供了确定性算法、无歧义的输入和精确定义的输出格式，确保了唯一且可验证的解。所有术语都是客观且明确定义的。\n\n该问题要求生成给定有限集 $A$ 的所有子集，这些子集的基数（大小）满足指定的奇偶性约束，即偶数或奇数。解决方案必须遵循特定的确定性排序。\n\n基本原理是一个 $n$ 元素集的幂集 $\\mathcal{P}(A)$ 与从 $0$ 到 $2^n - 1$ 的整数集合之间的双射。设输入集为 $A$。我们首先对其进行排序以建立其元素的规范排序：$A_{sorted} = \\{a_0, a_1, \\ldots, a_{n-1}\\}$，其中 $n = |A|$ 是 $A$ 的基数。\n\n在 $[0, 2^n - 1]$ 范围内的每个整数 $m$ 都可以唯一地表示为一个 $n$ 位二进制数，$m = (b_{n-1}b_{n-2}\\dots b_1 b_0)_2$，其中每个 $b_i \\in \\{0, 1\\}$。这种二进制表示作为构造子集 $S_m \\subseteq A_{sorted}$ 的“掩码”。构造规则是：第 $i$ 个元素 $a_i$ 被包含在子集 $S_m$ 中，当且仅当掩码 $m$ 的第 $i$ 位 $b_i$ 为 $1$。形式上，\n$$S_m = \\{ a_i \\in A_{sorted} \\mid \\text{the } i\\text{-th bit of } m \\text{ is } 1 \\}$$\n例如，如果 $A_{sorted} = \\{a_0, a_1, a_2\\}$ 且掩码为 $m=5$，其二进制为 $(101)_2$，则对应的子集是 $S_5 = \\{a_0, a_2\\}$。\n\n子集的基数 $|S_m|$ 正是 $m$ 的二进制表示中 $1$ 的数量。这个量被称为 $m$ 的置位计数或汉明权重，我们将其表示为 $\\text{popcount}(m)$。\n\n问题对子集大小施加了奇偶性约束。这直接转化为对整数掩码置位计数的奇偶性约束。设要求的奇偶性由字符串 $P$ 指定，它可以是 `\"even\"` 或 `\"odd\"`。我们可以将其映射到一个目标整数奇偶性 $p$，其中 `\"even\"` 对应 $p=0$，`\"odd\"` 对应 $p=1$。一个子集 $S_m$ 被包含在最终结果中，当且仅当其基数具有所要求的奇偶性：\n$$|S_m| \\pmod 2 = p$$\n这等价于：\n$$\\text{popcount}(m) \\pmod 2 = p$$\n\n算法过程如下：\n$1$. 给定输入列表 $A$ 和奇偶性字符串 $P$，确定整数基数 $n = |A|$ 和目标奇偶性 $p \\in \\{0, 1\\}$。\n$2$. 按升序对列表 $A$ 进行排序，得到 $A_{sorted}$。\n$3$. 初始化一个空列表，它将作为所有有效子集的集合。\n$4$. 从 $0$ 到 $2^n - 1$ 遍历每个整数掩码 $m$。此顺序是问题陈述中明确要求的。\n$5$. 对于每个 $m$，计算其置位计数 $\\text{popcount}(m)$。\n$6$. 检查置位计数的奇偶性是否与目标奇偶性匹配：$\\text{popcount}(m) \\pmod 2 = p$。\n$7$. 如果奇偶性匹配，则构造相应的子集。这通过为当前子集创建一个空列表，并从 $0$ 到 $n-1$ 遍历索引 $i$ 来完成。如果 $m$ 的第 $i$ 位是 $1$（这可以通过位运算 `(m >> i)  1 == 1` 来检查），则将 $A_{sorted}$ 中的元素 $a_i$ 追加到当前子集。\n$8$. 将完全构造好的子集追加到结果集合中。\n\n此过程保证了所有子集都被考虑到，只有满足奇偶性约束的子集被选中，并且最终的子集集合按照其对应整数掩码的递增值排序，符合要求。\n\n对于边缘情况：\n- 如果 $A$ 是空集，则 $n=0$。$m$ 的循环从 $0$ 运行到 $2^0-1=0$，因此只考虑 $m=0$。$m=0$ 的置位计数为 $0$，这是偶数。因此，如果 $P=\\text{\"even\"}$，结果是一个包含一个子集（即空集本身）的列表：`[[]]`。如果 $P=\\text{\"odd\"}$，则没有匹配项，结果是一个空列表：`[]`。这与组合学原理一致。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite, generating subsets\n    of a given set that have a specified size parity.\n    \"\"\"\n\n    # The test suite is defined as a list of tuples, where each tuple\n    # contains the set (as a list of integers) and the parity string.\n    test_cases = [\n        ([1, 2, 3, 4], \"even\"),\n        ([-1, 0, 2], \"odd\"),\n        ([], \"even\"),\n        ([], \"odd\"),\n        ([5], \"odd\"),\n    ]\n\n    # This list will store the results for each test case.\n    results = []\n\n    for case in test_cases:\n        A, parity_str = case\n        n = len(A)\n        \n        # As required, sort the input list to ensure canonical order.\n        A.sort()\n        \n        # Determine the target parity as an integer (0 for even, 1 for odd).\n        target_parity = 0 if parity_str == \"even\" else 1\n        \n        # This list will hold all subsets for the current test case that\n        # satisfy the parity constraint.\n        subsets_for_case = []\n        \n        # Iterate through all possible integer masks from 0 to 2^n - 1.\n        # Each mask corresponds to a unique subset of A.\n        for m in range(2**n):\n            # The population count (number of set bits) of the mask `m` is\n            # equal to the cardinality of the subset it represents.\n            # int.bit_count() is used for an efficient popcount calculation.\n            if m.bit_count() % 2 == target_parity:\n                # If the parity of the subset size matches the target,\n                # construct the subset.\n                current_subset = []\n                for i in range(n):\n                    # Check if the i-th bit of the mask is set.\n                    if (m >> i)  1:\n                        # If it is, include the i-th element of the sorted list.\n                        current_subset.append(A[i])\n                \n                # Add the constructed subset to the list for this case.\n                # The subsets are naturally ordered by the increasing value of `m`.\n                subsets_for_case.append(current_subset)\n        \n        results.append(subsets_for_case)\n\n    # The problem requires a specific, compact string representation for the\n    # final list of lists. Using json.dumps with custom separators is the\n    # most robust way to achieve this format without extraneous whitespace.\n    output_str = json.dumps(results, separators=(',', ':'))\n\n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3259575"}, {"introduction": "幂集生成是解决许多复杂组合问题的基础，其中一个经典例子就是子集和问题。本练习要求你找出所有元素之和落在指定区间内的子集。这不仅需要你结合子集生成与求和计算，还为你展示了解决这类问题时，如何从基础的穷举搜索过渡到更高级的算法，例如“中间相遇”法。[@problem_id:3259397]", "problem": "给定一个长度为 $n$ 的有限整数序列 $S$。考虑 $S$ 的幂集，它是所有 $2^n$ 个子集的集合，包括空子集。对于任何子集，其和定义为 $S$ 中所选位置上元素的总和。由于 $S$ 可能包含重复值，两个和相同的不同子集（由不同的索引集标识）必须都被计算在内。允许空子集，其和为 $0$。你还被给定一个由两个整数组成的闭区间 $[W_{\\min}, W_{\\max}]$，其中 $W_{\\min} \\le W_{\\max}$。任务是设计一个算法，对于每个输入实例，枚举所有其和在范围 $[W_{\\min}, W_{\\max}]$ 内的子集。该算法必须基于集合、和以及子集的二进制表示等基本定义。\n\n你的算法设计必须从以下基本原则出发：\n- 一个大小为 $n$ 的集合的幂集，其基数为 $2^n$。\n- 每个位置子集都可以表示为一个长度为 $n$ 的二进制向量（或等价地，一个从 $0$ 到 $2^n - 1$ 的整数位掩码），其中第 $i$ 位指示索引 $i$ 是否被包含。\n- 对于 $S$ 的任意一个大小为 $n_1$ 和 $n_2$（其中 $n_1 + n_2 = n$）的两部分的二分， $S$ 的每个子集都唯一地对应于左半部分的一个子集和右半部分的一个子集的并集，并且整体的和是各部分和的总和。\n\n你的程序必须为每个测试用例生成一个多重集，其中包含所有在 $[W_{\\min}, W_{\\max}]$ 内的子集和。这个多重集需要按非递减顺序排序，并保留元素的重复次数；也就是说，如果多个不同的子集在区间内有相同的和，那么这个和应该出现多次。为了使输出紧凑且可验证，你应该只输出这些和，而不是子集本身。\n\n输入不是从标准输入读取。相反，你的程序应在内部定义并运行下面指定的测试套件。对于每个测试用例，计算出有效的子集和的有序多重集，并按照规定将每个测试用例的结果聚合成单行。\n\n需要遵循的定义和规则：\n- 序列 $S$ 可能包含重复的整数和负整数。\n- 空子集被包括在内；其和为 $0$。\n- 区间 $[W_{\\min}, W_{\\max}]$ 是包含两个端点的。\n- 子集通过 $S$ 的索引来区分，而不仅仅是通过值。如果 $S$ 在不同索引处包含相等的值，那么选择它们的不同索引组合会产生不同的子集。\n\n在程序中实现的测试套件：\n- 测试用例 1：$S = [1, 2, 3]$，$W_{\\min} = 3$，$W_{\\max} = 5$。\n- 测试用例 2：$S = [0, 0]$，$W_{\\min} = 0$，$W_{\\max} = 0$。\n- 测试用例 3：$S = []$ (空序列)，$W_{\\min} = 0$，$W_{\\max} = 1$。\n- 测试用例 4：$S = [5, -2, 7, -3]$，$W_{\\min} = 0$，$W_{\\max} = 5$。\n- 测试用例 5：$S = [2, 2, 2]$，$W_{\\min} = 4$，$W_{\\max} = 4$。\n- 测试用例 6：$S = [1, 2]$，$W_{\\min} = 10$，$W_{\\max} = 20$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 每个单独的测试用例结果本身必须是一个用方括号括起来的、以逗号分隔的整数列表，并且整个输出中不含任何空白字符。\n- 例如，如果有三个测试用例的结果分别是列表 $[0, 1, 1]$、$[2, 3]$ 和 $[4]$，那么输出行必须是 `\"[[0,1,1],[2,3],[4]]\"` 这个确切的单字符串。\n- 因此，对于指定的六个测试用例，你的程序必须打印一个单行，其格式类似于 `\"[case1,case2,case3,case4,case5,case6]\"`，其中每个 `“case$k$”` 是如上定义的测试用例 $k$ 的无空白、用方括号括起来的整数列表。\n\n你的算法推理和实现应基于上述基本原则，不得使用未经证实的捷径。每个测试用例的答案是一个整数列表，聚合后的最终输出是所描述格式的单行。此纯离散问题不适用任何物理单位或角度单位，也没有需要表达的百分比。", "solution": "问题陈述已经过严格验证，并被确定为有效。这是一个基于离散数学和集合论基本原则（特别是关于幂集和子集和）的良定义计算问题。它是自洽的、客观的，并且没有任何科学或逻辑上的缺陷。因此，我们可以着手提供一个完整的解决方案。\n\n该问题要求我们找到给定长度为 $n$ 的整数序列 $S$ 的所有子集和，这些和需落在指定的闭区间 $[W_{\\min}, W_{\\max}]$ 内。问题的核心在于对子集进行系统性的枚举和求和。\n\n**基本原则：通过二进制整数表示子集**\n\n问题正确地指出，一个包含 $n$ 个元素的集合的幂集基数为 $2^n$。这 $2^n$ 个子集中的每一个都可以唯一地映射到范围 $[0, 2^n - 1]$ 内的一个整数 $k$。这个映射是通过考虑 $k$ 的 $n$ 位二进制表示来建立的。设序列为 $S = (S_0, S_1, \\dots, S_{n-1})$。一个整数 $k$ 对应一个子集，其中元素 $S_j$ 被包含当且仅当 $k$ 的第 $j$ 位（从右边数，即最低有效位）为 $1$。\n\n例如，如果 $S = [10, 20, 30]$（$n=3$），整数 $k=5$ 的二进制表示为 $101_2$。这对应于包含 $S_0=10$ 和 $S_2=30$ 的子集，其和为 $10+30=40$。整数 $k=0$（$000_2$）对应于和为 $0$ 的空集，而 $k=7$（$111_2$）对应于和为 $10+20+30=60$ 的全集。\n\n**直接算法方法**\n\n这种从 $0$ 到 $2^n - 1$ 的整数与 $S$ 的子集之间的一一对应关系提供了一种直接的（或称为暴力的）算法：\n1.  初始化一个空的多重集 `results`，用于存储有效的和。\n2.  遍历从 $0$ 到 $2^n - 1$ 的每个整数 $k$。\n3.  对于每个 $k$，计算其对应的子集和。初始化一个变量 `current_sum` 为 $0$。\n4.  遍历从 $0$ 到 $n-1$ 的每个索引 $j$。\n5.  要检查 $k$ 的第 $j$ 位是否被设置，我们可以使用按位与（AND）操作。如果 $(k \\text{ AND } 2^j) \\neq 0$（或等价地 `(k >> j)  1 == 1`），则表示第 $j$ 个元素 $S_j$ 在子集中。在这种情况下，将 $S_j$ 加到 `current_sum` 上。\n6.  对于给定的 $k$，在遍历完所有索引 $j$ 之后，`current_sum` 就计算完成了。\n7.  检查这个和是否落在目标范围内：$W_{\\min} \\le \\text{current\\_sum} \\le W_{\\max}$。\n8.  如果是，则将 `current_sum` 添加到 `results` 多重集中。\n9.  在遍历所有 $k$ 的主循环结束后，按非递减顺序对 `results` 多重集进行排序。\n\n该算法的时间复杂度由两个嵌套循环决定。外层循环运行 $2^n$ 次，内层循环运行 $n$ 次。因此，总时间复杂度为 $O(n \\cdot 2^n)$。空间复杂度由有效和的数量决定，最坏情况下可能是全部 $2^n$ 个和，导致 $O(2^n)$ 的空间。对于测试套件中出现的较小的 $n$ 值（最大为 $n=4$），这种方法在计算上是可行的，并且实现起来简单直接。\n\n**优化方法：中途相遇法原则**\n\n问题陈述通过提及二分法，暗示了一种更高级的技术。这指向了“中途相遇”算法，该算法对于较大的 $n$ 值效率显著更高。\n\n其原理是，$S$ 的任何子集都可以通过取 $S$ 第一部分的一个子集和第二部分的一个子集的并集来形成。因此，$S$ 的任何子集和都是第一部分的一个子集和与第二部分的一个子集和的和。\n1.  **分割**：将长度为 $n$ 的序列 $S$ 分成两半：长度为 $n_1 = \\lfloor n/2 \\rfloor$ 的 $S_1 = (S_0, \\dots, S_{n_1-1})$，和长度为 $n_2 = n - n_1$ 的 $S_2 = (S_{n_1}, \\dots, S_{n-1})$。\n2.  **生成半部和**：\n    *   使用上述直接方法为 $S_1$ 生成所有 $2^{n_1}$ 个子集和。将这些和存储在一个列表 `sums1` 中。\n    *   类似地，为 $S_2$ 生成所有 $2^{n_2}$ 个子集和，并将其存储在列表 `sums2` 中。\n3.  **组合与搜索**：我们寻找满足 $W_{\\min} \\le s_1 + s_2 \\le W_{\\max}$ 的数对 $(s_1, s_2)$，其中 $s_1 \\in \\text{sums1}$ 且 $s_2 \\in \\text{sums2}$。对于一个固定的 $s_1$，这个不等式可以重写为 $W_{\\min} - s_1 \\le s_2 \\le W_{\\max} - s_1$。\n4.  **高效搜索**：为了高效地找到符合条件的 $s_2$ 值，我们首先对其中一个列表（例如 `sums2`）进行排序。然后，对于 `sums1` 中的每个 $s_1$，我们可以在已排序的 `sums2` 上使用二分搜索来找到满足条件 $W_{\\min} - s_1 \\le s_2 \\le W_{\\max} - s_1$ 的元素范围。对每个 $s_1$ 进行此操作的时间为 $O(\\log(2^{n_2})) = O(n_2)$。\n5.  **收集与排序**：将所有通过这种方式找到的和 $s_1 + s_2$ 收集到一个最终的 `results` 列表中，然后对其进行排序。\n\n这个优化算法的时间复杂度主要由生成半部和以及组合步骤决定。生成 `sums1` 需要 $O(n_1 \\cdot 2^{n_1})$，`sums2` 需要 $O(n_2 \\cdot 2^{n_2})$。排序 `sums2` 需要 $O(2^{n_2} \\log(2^{n_2})) = O(n_2 \\cdot 2^{n_2})$。主循环运行 $2^{n_1}$ 次，每一步进行二分搜索需要 $O(n_2)$ 的时间。由于 $n_1 \\approx n/2$ 且 $n_2 \\approx n/2$，总复杂度大约为 $O(n \\cdot 2^{n/2})$。对于大的 $n$ 来说，这比 $O(n \\cdot 2^n)$ 是一个显著的改进。例如，如果 $n=40$，$2^{40}$ 在计算上是不可能的，而 $40 \\cdot 2^{20}$ 则是可处理的。\n\n**针对此问题的实现选择**\n\n鉴于所提供的测试套件中任何序列 $S$ 的最大长度为 $n=4$，复杂度为 $O(n \\cdot 2^n)$ 的直接暴力方法已经绰绰有余，并且更容易正确实现。其逻辑是使用位掩码表示子集这一核心原则的直接转换。因此，所提供的解决方案将实现这种直接方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the subset sum problem for a predefined test suite.\n    The final output is a single line, formatted as a list of lists of integers.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    test_cases = [\n        {'S': [1, 2, 3], 'W_min': 3, 'W_max': 5},\n        {'S': [0, 0], 'W_min': 0, 'W_max': 0},\n        {'S': [], 'W_min': 0, 'W_max': 1},\n        {'S': [5, -2, 7, -3], 'W_min': 0, 'W_max': 5},\n        {'S': [2, 2, 2], 'W_min': 4, 'W_max': 4},\n        {'S': [1, 2], 'W_min': 10, 'W_max': 20},\n    ]\n\n    # Helper function to generate all subset sums for a given sequence.\n    def get_all_subset_sums(s_list):\n        n = len(s_list)\n        num_subsets = 1  n  # This is 2**n\n        all_sums = []\n        for i in range(num_subsets):\n            current_sum = 0\n            for j in range(n):\n                # Check if the j-th bit is set in the integer i\n                if (i >> j)  1:\n                    current_sum += s_list[j]\n            all_sums.append(current_sum)\n        return all_sums\n\n    all_results = []\n    \n    for case in test_cases:\n        S = case['S']\n        W_min = case['W_min']\n        W_max = case['W_max']\n\n        # Step 1: Generate all possible subset sums.\n        # This is the direct application of the principle mapping integers 0..2^n-1\n        # to subsets.\n        all_sums = get_all_subset_sums(S)\n        \n        # Step 2: Filter sums to find those within the interval [W_min, W_max].\n        valid_sums = []\n        for s in all_sums:\n            if W_min = s = W_max:\n                valid_sums.append(s)\n        \n        # Step 3: Sort the resulting multiset of sums.\n        valid_sums.sort()\n        \n        all_results.append(valid_sums)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[3,3,4,5],[0,0,0,0],...]\n    case_results_str = []\n    for res_list in all_results:\n        # Format each inner list: [i1,i2,...] with no whitespace\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        case_results_str.append(inner_str)\n    \n    final_output = f\"[{','.join(case_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3259397"}]}