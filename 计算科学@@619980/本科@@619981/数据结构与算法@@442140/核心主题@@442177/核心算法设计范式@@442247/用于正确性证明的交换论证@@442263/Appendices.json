{"hands_on_practices": [{"introduction": "区间调度是贪心算法的经典入门问题。虽然“最早完成时间”策略是正确的，但其他一些直观的策略，例如“最早开始时间”，却可能导致次优解。这个练习将挑战你扮演一个算法“调试者”的角色，通过一个具体的反例，精确定位交换论证在证明这个错误策略时具体是在哪一步失效的 [@problem_id:3232103]。", "problem": "考虑单机上的区间调度问题：一个有限的请求集合 $I = \\{I_1, I_2, I_3, I_4, I_5\\}$，其中每个请求 $I_k$ 占据一个时间区间 $[s_k, f_k)$，满足 $s_k \\in \\mathbb{R}$，$f_k \\in \\mathbb{R}$ 且 $s_k  f_k$。两个请求 $I_a$ 和 $I_b$ 是兼容的，当且仅当 $f_a \\le s_b$ 或 $f_b \\le s_a$。一个调度是 $I$ 的任意子集 $S \\subseteq I$，其中所有请求两两兼容。目标是最大化基数 $|S|$。只使用以下基本基础：给定的兼容性、可行性和最优性的形式化定义，以及标准的交换论证概念，该论证试图将任何最优调度转换为一个与指定贪心选择一致的调度，而不降低目标值。\n\n设实例为\n- $I_1 : [1, 10)$，\n- $I_2 : [2, 3)$，\n- $I_3 : [3, 4)$，\n- $I_4 : [4, 5)$，\n- $I_5 : [5, 6)$。\n\n考虑按最小开始时间选择请求的贪心规则：在每一步，从未被考虑的请求中，选择一个与已选请求兼容且开始时间 $s_k$ 最小的请求（任意打破平局），并将其不可撤销地添加到调度中。假设我们从空调度开始，并将此规则应用于给定实例。\n\n任务：\n- 确定由最小开始时间贪心规则产生的调度及其基数。\n- 确定一个最大基数调度及其基数。\n- 识别一个单一的局部交换，通过将一个已选请求换成另一个可用请求，将贪心调度变为一个严格更大的可行调度，并正式指出在为最小开始时间规则尝试正确性证明时被违反的交换谓词。\n\n哪个选项正确地指出了交换和被违反的谓词？\n\nA. 将 $I_1 : [1, 10)$ 换出为 $I_2 : [2, 3)$；之后，可以追加请求 $I_3 : [3, 4)$、$I_4 : [4, 5)$ 和 $I_5 : [5, 6)$，从而严格增大了可行集的大小。被违反的交换谓词是：“对于任何最优调度 $S^\\star$，存在一个最优调度 $S'$，满足 $|S'| \\ge |S^\\star|$ 且包含具有最小开始时间的请求。”\n\nB. 将 $I_3 : [3, 4)$ 换出为 $I_1 : [1, 10)$，同时保持基数不变。被违反的交换谓词是：“在开始时间顺序下，兼容性是可传递的；因此按开始时间排序可以最大化请求数量。”\n\nC. 将 $I_1 : [1, 10)$ 换出为 $I_2 : [2, 3)$；被违反的交换谓词是：“对于任何最优调度 $S^\\star$，存在一个最优调度 $S'$，满足 $|S'| \\ge |S^\\star|$ 且包含具有最小结束时间的请求”，这对于给定实例不成立。\n\nD. 将 $I_1 : [1, 10)$ 换出为 $I_2 : [2, 3)$；被违反的交换谓词是：“最小化第一个开始时间可以最小化累积空闲时间，从而最大化基数。”\n\n选择唯一的最佳答案。", "solution": "根据定义，两个区间 $I_a = [s_a, f_a)$ 和 $I_b = [s_b, f_b)$ 是兼容的，当且仅当 $f_a \\le s_b$ 或 $f_b \\le s_a$。一个可行调度是 $I$ 的任意子集，其中所有请求对都兼容，而一个最优调度是最大化基数的可行调度。\n\n步骤1：从基本原则出发，应用最小开始时间贪心规则。从空调度开始，可用的请求及其开始时间为：$s_1 = 1$，$s_2 = 2$，$s_3 = 3$，$s_4 = 4$，$s_5 = 5$。最小的开始时间是 $s_1 = 1$，所以贪心规则选择 $I_1 : [1, 10)$。根据兼容性，任何其他请求 $I_k$ 必须满足 $f_k \\le s_1$ 或 $f_1 \\le s_k$。由于 $f_1 = 10$，$f_1 \\le s_k$ 将要求 $10 \\le s_k$，但是 $s_2 = 2$，$s_3 = 3$，$s_4 = 4$，$s_5 = 5$，所以没有一个请求满足 $10 \\le s_k$。同样，$f_k \\le s_1$ 将要求 $f_k \\le 1$，这对于任何 $k \\in \\{2, 3, 4, 5\\}$ 都不成立，因为 $f_2 = 3$，$f_3 = 4$，$f_4 = 5$ 且 $f_5 = 6$。因此，在选择了 $I_1$ 之后，无法在保持兼容性的前提下添加任何其他请求。贪心调度是 $S_{\\text{greedy}} = \\{I_1\\}$，其基数为 $|S_{\\text{greedy}}| = 1$。\n\n步骤2：确定一个最大基数调度。考虑调度 $S^\\star = \\{I_2, I_3, I_4, I_5\\}$。按时间顺序检查两两兼容性：\n- $I_2 = [2, 3)$ 和 $I_3 = [3, 4)$ 是兼容的，因为 $f_2 = 3 \\le s_3 = 3$。\n- $I_3 = [3, 4)$ 和 $I_4 = [4, 5)$ 是兼容的，因为 $f_3 = 4 \\le s_4 = 4$。\n- $I_4 = [4, 5)$ 和 $I_5 = [5, 6)$ 是兼容的，因为 $f_4 = 5 \\le s_5 = 5$。\n通过所构建链的传递性，所有相邻对都是兼容的，而非相邻对则由维持不重叠条件的等式隔开。因此 $S^\\star$ 是可行的，其基数为 $|S^\\star| = 4$。没有调度可以超过基数4，因为一旦排除 $I_1$，在时间 $s_2 = 2$ 之后只有4个请求可以无重叠地可行地容纳，而这个序列达到了这个界限。因此 $S^\\star$ 是一个最大基数调度。\n\n步骤3：识别一个从贪心调度出发，严格增大可行集大小的局部交换，并指出被违反的交换谓词。从 $S_{\\text{greedy}} = \\{I_1\\}$ 开始：\n- 移除 $I_1$ 并添加 $I_2$ 得到 $S_1 = \\{I_2\\}$。\n- 由于 $f_2 = 3 \\le s_3 = 3$，我们可以追加 $I_3$ 得到 $S_2 = \\{I_2, I_3\\}$。\n- 类似地，$f_3 = 4 \\le s_4 = 4$ 允许追加 $I_4$ 得到 $S_3 = \\{I_2, I_3, I_4\\}$。\n- 最后，$f_4 = 5 \\le s_5 = 5$ 允许追加 $I_5$ 得到 $S_4 = \\{I_2, I_3, I_4, I_5\\}$。\n这个单一的局部交换——将 $I_1$ 换成 $I_2$——创造了将可行集大小从1严格增加到4的机会。\n\n在一个贪心规则的交换论证中，核心的交换谓词通常断言，对于任何最优调度 $S^\\star$，都存在另一个最优调度 $S'$，其满足 $|S'| \\ge |S^\\star|$ 并且与贪心选择的第一个位置一致（即，包含贪心选择的请求）。对于最小开始时间规则，这个谓词变为：“对于任何最优调度 $S^\\star$，存在一个最优调度 $S'$，其满足 $|S'| \\ge |S^\\star|$ 且包含具有最小开始时间的请求。” 在这个实例中，任何基数为4的最优调度（例如 $S^\\star = \\{I_2, I_3, I_4, I_5\\}$）都不能包含 $I_1$，因为 $I_1$ 与 $I_2, I_3, I_4, I_5$ 全部重叠。包含 $I_1$ 会迫使调度大小降至1。因此，证明最小开始时间启发式算法正确性所需的交换谓词被违反了：不可能将一个最优调度转换为包含 $I_1$ 的调度而不严格降低目标值。\n\n逐个选项分析：\n- 选项A：提议的交换是 $I_1 \\mapsto I_2$，并且后续构建 $\\{I_3, I_4, I_5\\}$ 是可行的，产生的基数为 $4  1$。陈述的被违反的谓词正是证明最小开始时间规则正确性所需的交换谓词（“任何最优调度都可以被转换为包含最小开始时间请求的调度，而基数不减少”），而这个谓词对于给定实例是不成立的。结论 — 正确。\n- 选项B：提议的交换用 $I_1$ 替换 $I_3$。这不能保持基数，因为添加 $I_1$ 会消除与 $I_4$ 和 $I_5$ 的兼容性，使调度大小缩减至1。陈述的谓词援引了一个与开始时间顺序相关的不存在的传递性属性；在开始时间顺序下，兼容性并不以保证按开始时间排序最优的方式传递。结论 — 不正确。\n- 选项C：交换 $I_1 \\mapsto I_2$ 是可行的，但是所命名的谓词是最小结束时间规则的经典交换谓词（“存在一个包含最小结束时间请求的最优调度”），这个谓词是成立的，并且是按最早结束时间的正确贪心算法的基础。它不是最小开始时间规则被违反的谓词。结论 — 不正确。\n- 选项D：交换 $I_1 \\mapsto I_2$ 是可行的，但是陈述的谓词声称最小化第一个开始时间可以最小化累积空闲时间并最大化基数。这既不是区间调度的标准交换谓词，也不是一个有效的交换谓词，并且对于该实例是错误的，因为选择具有最小开始时间的 $I_1$ 会在之后产生最大的空闲时间（由于直到时间10的阻塞）和最小的基数。结论 — 不正确。\n\n因此，唯一的最佳答案是选项A。", "answer": "$$\\boxed{A}$$", "id": "3232103"}, {"introduction": "接下来我们看一个更微妙的例子：0/1背包问题。按价值重量比的贪心策略对“部分背包问题”是最优的，但对0/1背包问题却不成立，这使得该策略极具迷惑性。本练习要求你深入分析交换论证的细节，理解为什么物品的“可分割性”是证明成立的关键假设，以及在0/1背包问题中，这个假设的缺失是如何破坏整个证明逻辑的 [@problem_id:3232116]。", "problem": "考虑 $0/1$ 背包问题：给定 $n$ 个物品，其价值为 $\\{v_i\\}_{i=1}^n$，重量为 $\\{w_i\\}_{i=1}^n$，以及一个容量 $W$，选择一个物品子集以最大化 $\\sum_{i \\in S} v_i$，约束条件为 $\\sum_{i \\in S} w_i \\le W$，其中每个物品 $i$ 要么被完整地取走，要么完全不取。一个著名的贪心策略是按价值重量比 $v_i/w_i$ 的降序对物品进行排序，并重复地拿取能放得下的下一个物品。该策略对于物品可分割的变体（即分数背包问题）是最优的，但对于 $0/1$ 背包问题并非最优。\n\n请从背包问题中可行性和最优性的基本定义以及交换论证的原理出发：通过在保持可行性的同时交换部分内容，将一个可行解转换为一个更好的解。使用这些基础来分析以下实例以及一个针对 $0/1$ 情况的常见但有缺陷的基于交换的证明尝试。\n\n考虑三个物品和容量 $W$：\n- 物品 $a$：$v_a = 100$，$w_a = 51$。\n- 物品 $b$：$v_b = 60$，$w_b = 50$。\n- 物品 $c$：$v_c = 60$，$w_c = 50$。\n设 $W = 100$。价值重量比分别为 $v_a/w_a \\approx 100/51$，$v_b/w_b = 60/50$，$v_c/w_c = 60/50$，因此物品 $a$ 的比率最高。\n\n按比率贪心选择会首先选择物品 $a$；剩余容量为 $W - w_a = 49$，物品 $b$ 和物品 $c$ 都放不下，得到的总价值为 $100$。然而，子集 $\\{b, c\\}$ 是可行的，因为 $w_b + w_c = 100$，并且其总价值为 $120$，这严格优于 $100$。\n\n一个针对 $0/1$ 情况的朴素的基于交换的证明尝试过程如下：按 $v_i/w_i$ 降序排序，令 $g$ 为某个最优解 $O$ 中未包含的最高比率物品，并论证可以从 $O$ 中移除一组总重量等于 $w_g$ 的较低比率物品，并用 $g$ 替换该重量；由于 $v_g/w_g$ 是最大的，总价值不会减少，这似乎与最优性相矛盾，除非 $g \\in O$。\n\n哪个陈述最精确地指出了这种基于交换的推理中，对于分数背包问题有效但对于 $0/1$ 背包问题无效的步骤，从而解释了为什么贪心比率规则在上述实例上失败？\n\nA. 交换步骤假设存在一个由较低比率物品组成的子集 $S \\subseteq O$，其总重量为 $\\sum_{i \\in S} w_i = w_g$，这样用 $g$ 换出 $S$ 就能保持可行性且不降低价值；这个假设依赖于物品的可分割性，在 $0/1$ 模型中不成立。\n\nB. 该证明错误地将目标 $\\sum_{i \\in S} v_i$ 替换为最大化 $\\sum_{i \\in S} (v_i/w_i)$，好像比率可以线性累加一样；这是关键的无效步骤。\n\nC. 该论证是合理的，因为对于任何最优解 $O$，总存在一个物品 $j \\in O$ 满足 $w_j \\le w_g$ 和 $v_j \\le v_g$，$g$ 可以直接替换它，所以贪心比率规则实际上对于 $0/1$ 背包问题是正确的。\n\nD. 该推理仅在容量 $W$ 恰好等于贪心前缀的重量总和时才会失效；否则交换论证是有效的，贪心比率规则会成功。", "solution": "从核心定义开始。一个可行解 $S$ 满足 $\\sum_{i \\in S} w_i \\le W$。一个最优解 $O$ 是一个最大化 $\\sum_{i \\in O} v_i$ 的可行解。交换论证旨在通过用另一部分替换某一部分来改进一个可行解，同时保持可行性，并增加或保持目标值。\n\n对于分数背包问题，以下经过充分检验的事实成立，并且通常通过交换推理来证明：如果物品是可分割的，按 $v_i/w_i$ 降序排序并贪心地填充背包是最优的。关键的交换步骤是，任何由较低比率物品占用的重量 $\\Delta$ 都可以被 $\\Delta$ 重量的高比率物品替换，从而增加或保持总价值，因为单位重量的价值更高。这本质上依赖于能够取物品的一部分，以便交换的重量完全匹配。\n\n分析给定实例的 $0/1$ 情况。按比率贪心选择会首先选择物品 $a$，因为 $v_a/w_a \\approx 100/51 \\approx 1.9607$ 超过了物品 $b$ 和 $c$ 的 $1.2$。取走 $a$（重量 $51$）后，剩余容量为 $W - w_a = 100 - 51 = 49$，无法容纳物品 $b$ 或物品 $c$（每个重量为 $50$）。因此，贪心策略得到的价值为 $100$。\n\n考虑可行子集 $\\{b, c\\}$：其总重量为 $w_b + w_c = 50 + 50 = 100 \\le W$，其总价值为 $v_b + v_c = 60 + 60 = 120$。由于 $120  100$，贪心比率规则在此实例上失败。\n\n现在来审视针对 $0/1$ 情况的朴素的基于交换的证明尝试。令 $g$ 表示某个最优解 $O$ 中未包含的最高比率物品。该证明尝试声称：从 $O$ 中移除一组总重量等于 $w_g$ 的较低比率物品，并放入 $g$。因为 $v_g/w_g$ 超过了被移除物品的比率，总价值应该不会减少，这与最优性相矛盾，除非 $g \\in O$。这种推理在分数情况下是有效的，因为可以通过取物品的一部分来精确地选择被移除的重量为 $\\Delta = w_g$。\n\n在 $0/1$ 情况下，缺陷在于通常无法在 $O$ 中找到一个由完整物品组成的子集，其总重量恰好等于 $w_g$。如果所有物品都必须整体取走，那么精确匹配重量可能是不可能的。此外，为了给 $g$ 腾出足够的空间，必须移除一个子集 $S \\subseteq O$，其总重量满足 $\\sum_{i \\in S} w_i \\ge w_g$，而当物品重量相对于 $w_g$ 较粗略时，这个不等式通常是严格的。移除超过 $w_g$ 的重量可能会损失超出单位重量比率比较所能证明的价值，并且由于整体性，剩余的容量可能会被浪费，从而破坏了价值保持的论证。\n\n具体来说，在所提供的实例中，令 $O = \\{b, c\\}$ 为最优解。不在 $O$ 中的最高比率物品是 $g = a$，其重量 $w_g = 51$。在 $\\{b, c\\}$ 中不存在总重量等于 $51$ 的子集，因为仅有的非空子集的总重量为 $50$ 和 $100$。要放入 $a$，我们必须移除总重量至少为 $51$ 的物品。移除 $\\{b\\}$ 或 $\\{c\\}$ 只能腾出 $50$ 的重量，不足以容纳 $a$（因为 $50  51$）。同时移除两者则腾出 $100$ 的重量，可以容纳 $a$，但此时得到的集合价值为 $100$，严格小于 $v_b + v_c = 120$。分数的交换步骤本可以从 $\\{b, c\\}$ 的 $100$ 单位重量中精确移除 $51$ 单位的重量，换入 $a$，同时保持或增加单位重量的价值。该步骤在 $0/1$ 模型中是不可用的。\n\n因此，在分数情况下有效但在整体情况下失效的精确步骤是：假设我们可以挑选一个总重量恰好等于 $w_g$ 的物品子集，并用 $g$ 替换它而不违反可行性，同时利用单位重量的比较。这个假设依赖于可分割性，在物品是原子性（不可分割）时是无效的。\n\n逐个选项分析：\n\nA. 此选项指出了使用较低比率材料进行精确重量交换的假设，即存在 $S \\subseteq O$ 且 $\\sum_{i \\in S} w_i = w_g$ 以便换出并换入 $g$。这正是在分数背包问题中合理的步骤（可以通过取分数部分来达到精确重量），但在 $0/1$ 背包问题中不成立，因为物品重量是不可分割的。具体实例中的失败恰恰证明了这种不匹配。结论：正确。\n\nB. 这声称证明的关键错误在于将价值总和替换为比率总和，好像比率可以线性累加。尽管将 $\\sum (v_i/w_i)$ 视为目标是错误的，但所概述的朴素交换证明并未进行该替换；它对交换的部分使用单位重量比较，这对于分数物品是有效的。核心的失败不是目标规范错误，而是在整体性约束下无法进行精确重量交换。结论：不正确。\n\nC. 这断言总能找到一个单独的物品 $j \\in O$，满足 $w_j \\le w_g$ 和 $v_j \\le v_g$ 以进行直接交换，并由此得出贪心算法是正确的。这在一般情况下是错误的。在该实例中，$O$ 中没有单个物品满足 $w_j \\le w_g$（$50 \\le 51$ 成立；但是，用 $a$ 换 $b$ 或 $c$ 会违反可行性，因为 $w_a = 51$，而移除 $50$ 的重量腾出的容量不足，除非对剩余集合进行调整；此外，即使可以安排可行性，$v_j \\le v_g$ 也不能保证交换能保持最优性）。更广泛地说，这样的 $j$ 的存在没有保证，即使 $w_j \\le w_g$，交换也可能无法放入 $O \\setminus \\{j\\}$ 的剩余容量中。这没有指出分数与整体交换步骤的区别，并且错误地断言贪心算法的正确性。结论：不正确。\n\nD. 这声称推理仅在 $W$ 恰好等于贪心前缀的重量总和这种特殊情况下才会失效，暗示否则交换是有效的。比率贪心算法的失败以及交换步骤的失效并不局限于那种边缘情况；只要在整体性约束下无法实现交换的精确重量匹配，它们就会出现，而这与 $W$ 是否等于某个贪心前缀总和无关。给定的反例已经表明，当 $W = 100$ 且贪心前缀重量为 $51$ 时，算法失败，并没有特殊的相等条件。结论：不正确。", "answer": "$$\\boxed{A}$$", "id": "3232116"}, {"introduction": "交换论证不仅能证明算法的正确性，还能帮助我们理解最优解的结构。在最小生成树（MST）问题中，当边的权重不唯一时，可能存在多个不同的最优解。本练习将展示如何运用交换论证的变体（具体来说，是最小生成树的环路性质），来构造一个最优解到另一个最优解的转换路径，从而揭示所有最小生成树之间的深刻联系 [@problem_id:3232114]。", "problem": "考虑一个无向、连通的带权图 $G=(V,E,w)$，其顶点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$，边权函数 $w:E\\to \\mathbb{R}_{\\ge 0}$ 在以下边上定义：\n- $w(\\{v_1,v_2\\})=1$, $w(\\{v_2,v_3\\})=1$, $w(\\{v_1,v_3\\})=1$,\n- $w(\\{v_4,v_5\\})=1$, $w(\\{v_5,v_6\\})=1$, $w(\\{v_4,v_6\\})=1$,\n- $w(\\{v_3,v_4\\})=2$, $w(\\{v_2,v_5\\})=2$, $w(\\{v_1,v_6\\})=2$。\n设 $T_A$ 和 $T_B$ 是 $G$ 的两个生成树，定义如下：\n$$\nT_A=\\big\\{\\{v_1,v_2\\},\\{v_2,v_3\\},\\{v_4,v_5\\},\\{v_5,v_6\\},\\{v_3,v_4\\}\\big\\},\n$$\n$$\nT_B=\\big\\{\\{v_1,v_3\\},\\{v_2,v_3\\},\\{v_4,v_6\\},\\{v_5,v_6\\},\\{v_2,v_5\\}\\big\\}。\n$$\n您将使用基于最小生成树(MST)的环路和切割性质的交换论证来推导其正确性。\n\n任务：\n- 仅从生成树的基本定义以及MST的标准切割和环路性质出发，解释为什么在一个可能存在相等权重的连通图中，任意两个MST都可以通过一系列交换相互转换。每次交换都通过添加一条边来形成一个唯一的环路，并从该环路上移除另一条等权重的边，从而在每一步都保持最小性。\n- 使用此推理，为给定的图 $G$ 构建一个显式的、基于环路的等权重交换序列，将 $T_A$ 转换为 $T_B$。\n- 计算将 $T_A$ 转换为 $T_B$ 所需的最少等权重环路边交换次数。\n\n您的最终答案必须是一个整数。不需要四舍五入。最终答案中不要包含任何单位。", "solution": "该问题陈述明确、自洽且科学上合理，基于图论的基本原理。所提供的图数据和生成树 $T_A$、$T_B$ 符合最小生成树 (MST) 的性质。验证表明，$T_A$ 的总权重为 $w(T_A) = w(\\{v_1,v_2\\}) + w(\\{v_2,v_3\\}) + w(\\{v_4,v_5\\}) + w(\\{v_5,v_6\\}) + w(\\{v_3,v_4\\}) = 1+1+1+1+2 = 6$。$T_B$ 的总权重为 $w(T_B) = w(\\{v_1,v_3\\}) + w(\\{v_2,v_3\\}) + w(\\{v_4,v_6\\}) + w(\\{v_5,v_6\\}) + w(\\{v_2,v_5\\}) = 1+1+1+1+2 = 6$。通过在图 $G$ 上执行 Kruskal 算法或 Prim 算法，可以确认生成树的最小可能权重确实是 $6$。因此，$T_A$ 和 $T_B$ 都是 $G$ 的有效 MST。我们现在可以进行求解。\n\n该问题包括三个部分：理论解释、显式构造转换过程以及计算最少交换次数。\n\n**第一部分：转换MST的理论基础**\n\n我们必须解释为什么图 $G=(V,E,w)$ 的任意两个 MST 都可以通过一系列等权重边的交换相互转换。这一性质对于理解 MST 的结构至关重要，尤其是在边权重不唯一的情况下。该论证依赖于 MST 的切割和环路性质。\n\n设 $T_1$ 和 $T_2$ 是图 $G$ 的两个不同的 MST。由于它们都是 MST，它们的总权重必然相同，即 $W(T_1) = W(T_2)$。因为 $T_1 \\neq T_2$，所以 $T_1$ 中的边集（记为 $E(T_1)$）与 $T_2$ 中的边集（记为 $E(T_2)$）不同。这意味着对称差 $E(T_1) \\Delta E(T_2) = (E(T_1) \\setminus E(T_2)) \\cup (E(T_2) \\setminus E(T_1))$ 非空。\n\n让我们任意选取一条边 $e \\in E(T_1) \\setminus E(T_2)$。将边 $e$ 加入树 $T_2$ 会形成一个唯一的环路，我们称之为 $C$。由于 $T_2$ 是一个 MST，环路性质指出，对于任何不在 $T_2$ 中的边（如 $e$），它必须是将其加入 $T_2$ 所形成的唯一环路上的最大权重边。这意味着对于环路 $C$ 上的任何边 $f$（其中 $f \\neq e$），我们必须有 $w(f) \\le w(e)$。\n\n现在，考虑树 $T_1$。从 $T_1$ 中移除边 $e=(u,v)$ 会将顶点集 $V$ 划分为两个不相交的集合，比如说 $S$ 和 $V \\setminus S$，其中 $u \\in S$ 且 $v \\in V \\setminus S$。这个划分定义了一个切割。环路 $C$（存在于 $T_2 \\cup \\{e\\}$ 中）通过 $T_2$ 中的一条路径连接 $u$ 和 $v$。由于 $u \\in S$ 且 $v \\in V \\setminus S$，这条在 $T_2$ 中的路径必须包含至少一条跨越切割 $(S, V \\setminus S)$ 的边。设 $f$ 是 $C$ 上跨越该切割的一条边。由于 $e$ 是 $T_1$ 中唯一跨越此切割的边，因此 $f$ 不可能在 $T_1$ 中。所以，我们找到了这样一条边 $f$，使得 $f \\in C$，$f \\in E(T_2)$，且 $f \\notin E(T_1)$，这意味着 $f \\in E(T_2) \\setminus E(T_1)$。\n\n现在让我们将环路性质应用于 $T_1$。如果我们将边 $f$ 加入 $T_1$，会形成一个唯一的环路 $C'$。在 $T_1$ 中连接 $f$ 的两个端点的路径必须包括边 $e$，因为 $f$ 连接了两个顶点集 $S$ 和 $V \\setminus S$，而这两个集合在 $T_1$ 中仅由 $e$ 连接。由于 $e$ 在环路 $C'$ 上，且 $T_1$ 是一个 MST，环路性质意味着 $f$ 必须是 $C'$ 上的最大权重边。因此，$w(e) \\le w(f)$。\n\n我们已经建立了两个不等式：\n1. 从考虑 $T_2$ 和环路 $C$ 得出：$w(f) \\le w(e)$。\n2. 从考虑 $T_1$ 和环路 $C'$ 得出：$w(e) \\le w(f)$。\n\n这两个不等式共同意味着 $w(e) = w(f)$。\n\n这证明了对于任何边 $e \\in E(T_1) \\setminus E(T_2)$，都存在一条边 $f \\in E(T_2) \\setminus E(T_1)$，其权重与 $e$ 相同，即 $w(e)=w(f)$。边 $f$ 位于将 $e$ 添加到 $T_2$ 时形成的唯一环路上。\n我们可以执行一次交换：创建一个新的生成树 $T' = T_2 \\cup \\{e\\} \\setminus \\{f\\}$。$T'$ 的总权重为 $W(T') = W(T_2) + w(e) - w(f) = W(T_2)$。由于 $T'$ 是一个与 MST 权重相同的生成树，所以 $T'$ 也是一个 MST。\n\n新的 MST $T'$ 与 $T_1$ 相比，多了一条公共边。具体来说， $|E(T_1) \\cap E(T')| = |E(T_1) \\cap E(T_2)| + 1$。通过重复这个交换过程 $|E(T_1) \\setminus E(T_2)|$ 次，我们可以通过一系列中间的 MST 将 $T_2$ 转换为 $T_1$。\n\n**第二部分：$T_A$到$T_B$的显式转换**\n\n首先，我们找出 $T_A$ 和 $T_B$ 之间不同的边集。\n$T_A=\\big\\{\\{v_1,v_2\\},\\{v_2,v_3\\},\\{v_4,v_5\\},\\{v_5,v_6\\},\\{v_3,v_4\\}\\big\\}$\n$T_B=\\big\\{\\{v_1,v_3\\},\\{v_2,v_3\\},\\{v_4,v_6\\},\\{v_5,v_6\\},\\{v_2,v_5\\}\\big\\}$\n\n在 $T_A$ 中但不在 $T_B$ 中的边集是 $T_A \\setminus T_B = \\big\\{\\{v_1,v_2\\}, \\{v_4,v_5\\}, \\{v_3,v_4\\}\\big\\}$。\n在 $T_B$ 中但不在 $T_A$ 中的边集是 $T_B \\setminus T_A = \\big\\{\\{v_1,v_3\\}, \\{v_4,v_6\\}, \\{v_2,v_5\\}\\big\\}$。\n\n这些集合的大小为 $3$，所以需要 $3$ 次交换。我们从 $T^{(0)} = T_A$ 开始，将其转换为 $T_B$。\n\n**交换 1：**\n我们从 $T_B \\setminus T_A$ 中选择一条边加入到我们当前的树 $T^{(0)}$。我们选择 $e_1 = \\{v_1, v_3\\}$，其权重为 $w(e_1) = 1$。\n将 $e_1$ 加入 $T_A$ 会产生环路 $C_1 = (v_1, v_2, v_3, v_1)$。此环路上的边是 $\\{v_1,v_2\\}, \\{v_2,v_3\\}, \\{v_1,v_3\\}$。\n权重为 $w(\\{v_1,v_2\\})=1$, $w(\\{v_2,v_3\\})=1$ 和 $w(\\{v_1,v_3\\})=1$。\n为了保持 MST 的性质，我们必须从 $C_1$ 中移除一条权重最大的边，即权重为 $1$ 的边。为了向 $T_B$ 靠近，我们必须移除一条属于 $T_A \\setminus T_B$ 的边。$C_1$ 中属于 $T_A$ 的边是 $\\{v_1,v_2\\}$ 和 $\\{v_2,v_3\\}$。其中，$\\{v_1,v_2\\}$ 在 $T_A \\setminus T_B$ 中，而 $\\{v_2,v_3\\}$ 在 $T_A \\cap T_B$ 中。因此，我们必须移除 $f_1 = \\{v_1,v_2\\}$。\n这是一次等权重交换，因为 $w(e_1) = w(f_1) = 1$。\n新的树是 $T^{(1)} = T_A \\cup \\{e_1\\} \\setminus \\{f_1\\} = \\big\\{\\{v_1,v_3\\}, \\{v_2,v_3\\}, \\{v_4,v_5\\}, \\{v_5,v_6\\}, \\{v_3,v_4\\}\\big\\}$。\n\n**交换 2：**\n我们当前的树是 $T^{(1)}$。剩余需要添加的边是 $\\{v_4,v_6\\}$ 和 $\\{v_2,v_5\\}$。我们选择 $e_2=\\{v_4,v_6\\}$，其权重为 $w(e_2)=1$。\n将 $e_2$ 加入 $T^{(1)}$ 会产生环路 $C_2 = (v_4, v_5, v_6, v_4)$。此环路上的边是 $\\{v_4,v_5\\}, \\{v_5,v_6\\}, \\{v_4,v_6\\}$。\n权重为 $w(\\{v_4,v_5\\})=1$, $w(\\{v_5,v_6\\})=1$ 和 $w(\\{v_4,v_6\\})=1$。\n我们必须从 $C_2$ 中移除一条属于 $T^{(1)} \\setminus T_B = \\big\\{\\{v_4,v_5\\}, \\{v_3,v_4\\}\\big\\}$ 的边。在 $C_2$ 上唯一的这样的边是 $f_2=\\{v_4,v_5\\}$。\n这是一次等权重交换，因为 $w(e_2) = w(f_2) = 1$。\n新的树是 $T^{(2)} = T^{(1)} \\cup \\{e_2\\} \\setminus \\{f_2\\} = \\big\\{\\{v_1,v_3\\}, \\{v_2,v_3\\}, \\{v_5,v_6\\}, \\{v_3,v_4\\}, \\{v_4,v_6\\}\\big\\}$。\n\n**交换 3：**\n我们当前的树是 $T^{(2)}$。唯一剩余需要添加的边是 $e_3=\\{v_2,v_5\\}$，其权重为 $w(e_3)=2$。\n将 $e_3$ 加入 $T^{(2)}$ 会产生一个环路 $C_3$。为了找到它，我们在 $T^{(2)}$ 中追踪从 $v_2$ 到 $v_5$ 的路径：$v_2 - v_3 - v_4 - v_6 - v_5$。\n所以，环路是 $C_3 = (v_2, v_3, v_4, v_6, v_5, v_2)$。\n此环路上的边及其权重是：\n- 来自 $T^{(2)}$ 的路径上的边：$w(\\{v_2,v_3\\})=1$, $w(\\{v_3,v_4\\})=2$, $w(\\{v_4,v_6\\})=1$, $w(\\{v_6,v_5\\})=1$。\n- 添加的边：$w(\\{v_2,v_5\\})=2$。\n此环路上的最大权重为 $2$。具有此权重的边是新添加的边 $e_3=\\{v_2,v_5\\}$ 和边 $f_3=\\{v_3,v_4\\}$。为了打破环路并保持 MST，我们必须移除 $f_3=\\{v_3,v_4\\}$。\n这条边在 $T^{(2)} \\setminus T_B = \\big\\{\\{v_3,v_4\\}\\big\\}$ 中，所以这是正确的待移除边。\n这是一次等权重交换，因为 $w(e_3) = w(f_3) = 2$。\n新的树是 $T^{(3)} = T^{(2)} \\cup \\{e_3\\} \\setminus \\{f_3\\} = \\big\\{\\{v_1,v_3\\}, \\{v_2,v_3\\}, \\{v_5,v_6\\}, \\{v_4,v_6\\}, \\{v_2,v_5\\}\\big\\}$。\n\n这个最终的树 $T^{(3)}$ 与 $T_B$ 完全相同。我们成功地通过 $3$ 次等权重交换将 $T_A$ 转换为 $T_B$。\n\n**第三部分：最少交换次数**\n\n将一个 MST 转换为另一个所需的最少交换次数由只存在于其中一棵树中的边的数量决定。这是集合差的基数。正如理论部分所建立的，每次交换操作都会使这个差集的大小恰好减少一。\n因此，交换次数是 $|T_A \\setminus T_B|$（或等价地，$|T_B \\setminus T_A|$）。\n从第二部分，我们发现：\n$T_A \\setminus T_B = \\big\\{\\{v_1,v_2\\}, \\{v_4,v_5\\}, \\{v_3,v_4\\}\\big\\}$\n这个集合的基数是 $|T_A \\setminus T_B| = 3$。\n因此，将 $T_A$ 转换为 $T_B$ 所需的最少等权重环路边交换次数是 $3$。\n我们的显式构造恰好使用了这个步数，证实了结果。", "answer": "$$\n\\boxed{3}\n$$", "id": "3232114"}]}