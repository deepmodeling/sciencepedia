{"hands_on_practices": [{"introduction": "在我们深入探讨包含插入、删除和替换的完整编辑距离算法之前，通过一个简化版本来热身是很有帮助的。这个练习将编辑操作限制为仅允许字符替换，这实际上是在计算两个等长字符串之间的“汉明距离”(Hamming distance)。通过解决这个问题[@problem_id:3230949]，你将能够专注于逐位比较和累积成本的基本思想，为理解更复杂的动态规划算法打下坚实的基础。", "problem": "考虑有限字母表上的两个字符串 $S$ 和 $T$。经典的编辑距离（Levenshtein距离）定义为使用替换、插入和删除操作将一个字符串转换为另一个字符串的最小总成本，其中每个操作都被赋予一个非负成本。在本问题中，假设不允许插入和删除，替换是唯一允许的操作。每个完全匹配的字符成本为 $0$，每次替换的成本为 $1$。在这些限制下，两个输入字符串必须具有相等的长度。\n\n令 $S$ 为将模式 $\\text{\"abcd\"}$ 重复 $6$ 次得到的 $24$ 个字符的字符串，令 $T$ 为将模式 $\\text{\"abce\"}$ 重复 $6$ 次得到的 $24$ 个字符的字符串。具体来说，\n$S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$ 且 $T = \\text{\"abceabceabceabceabceabce\"}$。\n计算在上述操作模型下 $S$ 和 $T$ 之间的受限编辑距离。你的最终答案必须是一个整数，不需要四舍五入。", "solution": "该问题要求计算两个字符串 $S$ 和 $T$ 之间的受限编辑距离。我将首先验证问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- 唯一允许的操作是替换。不允许插入和删除。\n- 完全匹配的字符成本为 $0$。\n- 替换（不匹配）的成本为 $1$。\n- 一个约束是输入字符串必须具有相等的长度。\n- 字符串 $S$ 的长度为 $24$，由模式 $\\text{\"abcd\"}$ 重复 $6$ 次构成。因此，$S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$。\n- 字符串 $T$ 的长度为 $24$，由模式 $\\text{\"abce\"}$ 重复 $6$ 次构成。因此，$T = \\text{\"abceabceabceabceabceabce\"}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是计算机科学和离散数学中常见的字符串度量问题的一个具体实例。所定义的“受限编辑距离”即是著名的汉明距离（Hamming distance），它被定义用于等长字符串。该问题是适定（well-posed）的：字符串被明确定义，它们的长度相等（$24$），满足所述约束，并且成本函数是明确的。所有必要的信息都已提供且内部一致。该问题是客观且可形式化的。因此，该问题被认为是有效的。\n\n### 解题过程\n设两个字符串为 $S$ 和 $T$，长度均为 $N$。令 $S = s_1s_2...s_N$ 且 $T = t_1t_2...t_N$，其中 $s_i$ 和 $t_i$ 分别是 $S$ 和 $T$ 在第 $i$ 个位置的字符。\n\n该问题定义了一种受限编辑距离，其中只有替换是允许的操作。将 $S$ 转换为 $T$ 的成本是每个位置上操作成本的总和。由于只允许替换，我们比较从 $1$到 $N$ 的每个位置 $i$ 上的字符。单个位置 $i$ 的成本函数，我们称之为 $c_i$，定义如下：\n$c_i = 0$ 如果 $s_i = t_i$ (匹配)\n$c_i = 1$ 如果 $s_i \\neq t_i$ (替换)\n\n总的受限编辑距离，我们记为 $D(S, T)$，是所有位置上这些成本的总和。这在形式上等同于汉明距离。\n$$D(S, T) = \\sum_{i=1}^{N} c_i$$\n\n在本问题中，字符串为 $S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$ 和 $T = \\text{\"abceabceabceabceabceabce\"}$。\n两个字符串的长度均为 $N=24$。\n\n字符串 $S$ 是通过将基本模式 $P_S = \\text{\"abcd\"}$ 重复 $6$ 次构建的。\n字符串 $T$ 是通过将基本模式 $P_T = \\text{\"abce\"}$ 重复 $6$ 次构建的。\n\n每个模式的长度是 $ L=4$。总长度为 $N = 6 \\times L = 6 \\times 4 = 24$。\n\n由于字符串具有重复结构，总距离 $D(S, T)$可以通过首先计算基本模式之间的距离 $D(P_S, P_T)$，然后乘以重复次数 $6$ 来得到。\n\n我们来计算模式 $P_S = \\text{\"abcd\"}$ 和 $P_T = \\text{\"abce\"}$ 之间的距离 $D(P_S, P_T)$。我们逐个字符进行比较：\n- 位置 $1$：'a' vs 'a'。字符匹配，成本为 $0$。\n- 位置 $2$：'b' vs 'b'。字符匹配，成本为 $0$。\n- 位置 $3$：'c' vs 'c'。字符匹配，成本为 $0$。\n- 位置 $4$：'d' vs 'e'。字符不匹配，成本为 $1$。\n\n一个模式块的距离是这些成本的总和：\n$$D(P_S, P_T) = 0 + 0 + 0 + 1 = 1$$\n\n总距离 $D(S, T)$ 是 $6$ 个对应块的距离之和。由于每个块都相同，总距离是单个块距离的 $6$ 倍。\n$$D(S, T) = 6 \\times D(P_S, P_T)$$\n$$D(S, T) = 6 \\times 1 = 6$$\n\n或者，我们可以写出完整的求和式。令 $S_k$ 和 $T_k$ 为字符串的第 $k$ 个块，其中 $k \\in \\{1, 2, 3, 4, 5, 6\\}$。那么 $S = S_1 S_2 S_3 S_4 S_5 S_6$ 且 $T = T_1 T_2 T_3 T_4 T_5 T_6$。\n由于对所有的 $k$都有 $S_k = P_S$ 和 $T_k = P_T$，总距离为：\n$$D(S, T) = \\sum_{k=1}^{6} D(S_k, T_k) = \\sum_{k=1}^{6} D(P_S, P_T) = \\sum_{k=1}^{6} 1 = 6$$\n\n$S$ 和 $T$ 之间的受限编辑距离是字符不同的位置总数。在每个长度为 $4$ 的 $6$ 个块中，只有最后一个字符不同。因此，总共有 $6$ 个不匹配。由于每次不匹配的成本为 $1$，总成本为 $6$。", "answer": "$$\n\\boxed{6}\n$$", "id": "3230949"}, {"introduction": "掌握了编辑操作的核心思想后，让我们将这种思维方式应用于一个崭新的挑战。这个练习[@problem_id:3230960]要求你计算将一个给定字符串转换为回文串所需的最小编辑次数。它完美地展示了动态规划思想的通用性——我们如何将基于字符比较和编辑选择的逻辑，从简单的字符串-字符串匹配，推广到解决具有不同结构特性（如回文）的问题。", "problem": "设 $S$ 是字符串 $S=\\text{\"abracad\"}$，其长度 $n=7$。回文串是指一个字符串 $P$ 与其反转后的字符串相同，即 $P=P^{\\text{rev}}$。考虑单位成本为 $1$ 的标准 Levenshtein 编辑操作：单字符插入、单字符删除和单字符替换。从这些编辑操作的基本定义和回文串的结构特性出发，根据第一性原理推导出一个方法，以确定将 $S$ 转换为任意回文串所需的最少编辑次数。精确计算这个最少编辑次数。最终答案必须是一个实数值。无需四舍五入。", "solution": "用户要求我找出将给定字符串转换成回文串所需的最少编辑操作（插入、删除、替换，单位成本均为1）次数。\n\n### 步骤1：提取已知条件\n- 字符串为 $S = \\text{\"abracad\"}$。\n- 字符串长度为 $n=7$。\n- 回文串是指一个字符串 $P$ 与其反转后的字符串相同，即 $P = P^{\\text{rev}}$。\n- 允许的编辑操作是单字符插入、删除和替换。\n- 每个操作的成本为 $1$。\n- 目标是求出将 $S$ 转换为任意回文串的最小总成本。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题是算法和数据结构领域的经典问题，具体涉及字符串操作和动态规划。\n- **科学性（关键）**：该问题基于明确定义的数学和计算机科学概念：字符串、回文串和 Levenshtein 编辑距离。这些概念是合理且严格定义的。\n- **适定性**：该问题是适定的。它要求在一组定义好的操作上求最小值，这保证了存在一个唯一的、稳定的、有意义的数值解。\n- **客观性（关键）**：该问题以精确、客观的语言陈述，没有歧义或主观论断。\n\n该问题不存在任何无效性缺陷：\n1.  它不违反任何科学或数学原理。\n2.  这是一个可形式化的问题，与编辑距离直接相关。\n3.  问题设置是完整和一致的。\n4.  条件是纯计算性的，而非物理性的，因此是可行的。\n5.  它结构良好，并允许唯一解。\n6.  这是一个标准的、非平凡的问题，需要特定的算法方法。\n7.  结果是可验证的。\n\n### 步骤3：结论与行动\n问题有效。我将进行完整的推导和求解。\n\n### 方法推导\n设给定字符串为 $S$，长度为 $n$。我们希望找到将 $S$ 转换为回文串所需的最少编辑（插入、删除或替换）次数。设对于一个通用子串 $S[i \\dots j]$，这个最少编辑次数用函数 $D(i, j)$ 表示。我们的目标是计算 $D(0, n-1)$。\n\n我们可以通过考虑子串两端的字符 $S[i]$ 和 $S[j]$ 来建立 $D(i, j)$ 的递推关系。\n\n**基本情况：**\n- 对于长度为 $1$ 的子串 $S[i \\dots i]$，它本身已经是回文串。因此，不需要编辑。$D(i, i) = 0$。\n- 对于长度为 $0$ 的子串（例如，当 $j  i$ 时），它也自然是回文串。成本为 $0$。\n\n**递推步骤：**\n考虑子串 $S[i \\dots j]$，其中 $i  j$。\n1.  **情况1：最外层字符匹配，$S[i] = S[j]$。**\n    如果子串两端的字符匹配，它们已经相互满足了回文属性。我们不需要编辑它们。问题简化为使内部子串 $S[i+1 \\dots j-1]$ 成为回文串。因此，最少编辑次数与内部子串所需的编辑次数相同。\n    $$D(i, j) = D(i+1, j-1) \\quad \\text{if } S[i] = S[j]$$\n\n2.  **情况2：最外层字符不匹配，$S[i] \\neq S[j]$。**\n    由于 $S[i]$ 和 $S[j]$ 不匹配，我们必须执行至少一次编辑操作来解决这种不匹配。我们有三个基本选择，类似于 Levenshtein 距离操作：\n    a. **替换：** 我们可以更改其中一个字符以匹配另一个字符。例如，我们可以用等于 $S[j]$ 的字符替换 $S[i]$，或者用等于 $S[i]$ 的字符替换 $S[j]$。无论哪种情况，成本都是 $1$ 次编辑。此操作后，两端匹配，剩下的子问题是使内部字符串 $S[i+1 \\dots j-1]$ 成为回文串。此选择的总成本是 $1 + D(i+1, j-1)$。\n    b. **删除/插入（左侧）：** 我们可以删除字符 $S[i]$。成本是 $1$ 次编辑。然后剩下的子问题是使剩余的子串 $S[i+1 \\dots j]$ 成为回文串。总成本是 $1 + D(i+1, j)$。这个操作在结果上等同于将 $S[i \\dots j-1]$ 转换为回文串，然后在开头插入一个字符以匹配 $S[j]$。\n    c. **删除/插入（右侧）：** 对称地，我们可以删除字符 $S[j]$。成本是 $1$ 次编辑。剩下的子问题是使 $S[i \\dots j-1]$ 成为回文串。总成本是 $1 + D(i, j-1)$。\n\n    因为我们想要最少的编辑次数，所以我们必须选择导致最小总成本的操作。\n    $$D(i, j) = 1 + \\min \\left( D(i+1, j), D(i, j-1), D(i+1, j-1) \\right) \\quad \\text{if } S[i] \\neq S[j]$$\n\n这个递推关系可以使用动态规划高效地解决。我们构建一个二维表，例如 `dp[i][j]`，来存储 $D(i, j)$ 的值。我们按子串长度从 $1$ 到 $n$ 递增的顺序填充该表。\n\n### 计算\n我们将此方法应用于字符串 $S = \\text{\"abracad\"}$（$n=7$，索引从 $0$ 到 $6$）。设 `dp[i][j]` 是存储 $D(i, j)$ 的表。\n\n**长度 $L=1$：**\n对于所有 $i \\in \\{0, \\dots, 6\\}$，`dp[i][i] = 0`。\n\n**长度 $L=2$：**\n- `dp[0][1]` (\"ab\"): $S[0] \\neq S[1] \\implies 1 + \\min(dp[1][1], dp[0][0], dp[1][0]) = 1 + \\min(0, 0, 0) = 1$。\n- 根据相同逻辑，对于所有长度为 $2$ 且字符不匹配的子串：\n  `dp[1][2]`(\"br\") $= 1$，`dp[2][3]`(\"ra\") $= 1$，`dp[3][4]`(\"ac\") $= 1$，`dp[4][5]`(\"ca\") $= 1$，`dp[5][6]`(\"ad\") $= 1$。\n\n**长度 $L=3$：**\n- `dp[0][2]` (\"abr\"): $S[0] \\neq S[2] \\implies 1 + \\min(dp[1][2], dp[0][1], dp[1][1]) = 1 + \\min(1, 1, 0) = 1$。\n- `dp[1][3]` (\"bra\"): $S[1] \\neq S[3] \\implies 1 + \\min(dp[2][3], dp[1][2], dp[2][2]) = 1 + \\min(1, 1, 0) = 1$。\n- `dp[2][4]` (\"rac\"): $S[2] \\neq S[4] \\implies 1 + \\min(dp[3][4], dp[2][3], dp[3][3]) = 1 + \\min(1, 1, 0) = 1$。\n- `dp[3][5]` (\"aca\"): $S[3] = S[5] \\implies dp[4][4] = 0$。\n- `dp[4][6]` (\"cad\"): $S[4] \\neq S[6] \\implies 1 + \\min(dp[5][6], dp[4][5], dp[5][5]) = 1 + \\min(1, 1, 0) = 1$。\n\n**长度 $L=4$：**\n- `dp[0][3]` (\"abra\"): $S[0] = S[3] \\implies dp[1][2] = 1$。\n- `dp[1][4]` (\"brac\"): $S[1] \\neq S[4] \\implies 1 + \\min(dp[2][4], dp[1][3], dp[2][3]) = 1 + \\min(1, 1, 1) = 2$。\n- `dp[2][5]` (\"raca\"): $S[2] \\neq S[5] \\implies 1 + \\min(dp[3][5], dp[2][4], dp[3][4]) = 1 + \\min(0, 1, 1) = 1$。\n- `dp[3][6]` (\"acad\"): $S[3] \\neq S[6] \\implies 1 + \\min(dp[4][6], dp[3][5], dp[4][5]) = 1 + \\min(1, 0, 1) = 1$。\n\n**长度 $L=5$：**\n- `dp[0][4]` (\"abrac\"): $S[0] \\neq S[4] \\implies 1 + \\min(dp[1][4], dp[0][3], dp[1][3]) = 1 + \\min(2, 1, 1) = 2$。\n- `dp[1][5]` (\"braca\"): $S[1] \\neq S[5] \\implies 1 + \\min(dp[2][5], dp[1][4], dp[2][4]) = 1 + \\min(1, 2, 1) = 2$。\n- `dp[2][6]` (\"racad\"): $S[2] \\neq S[6] \\implies 1 + \\min(dp[3][6], dp[2][5], dp[3][5]) = 1 + \\min(1, 1, 0) = 1$。\n\n**长度 $L=6$：**\n- `dp[0][5]` (\"abraca\"): $S[0] = S[5] \\implies dp[1][4] = 2$。\n- `dp[1][6]` (\"bracad\"): $S[1] \\neq S[6] \\implies 1 + \\min(dp[2][6], dp[1][5], dp[2][5]) = 1 + \\min(1, 2, 1) = 2$。\n\n**长度 $L=7$：**\n- `dp[0][6]` (\"abracad\"): $S[0] \\neq S[6] \\implies 1 + \\min(dp[1][6], dp[0][5], dp[1][5]) = 1 + \\min(2, 2, 2) = 3$。\n\n将字符串 $S=\\text{\"abracad\"}$ 转换为回文串所需的最少编辑次数由 `dp[0][6]` 给出，其值为 $3$。\n\n举例来说，一个可能的三次编辑序列是：\n1.  将 $S[1]$（'b'）改为 'a'。\n2.  将 $S[2]$（'r'）改为 'c'。\n3.  将 $S[6]$（'d'）改为 'a'。\n原字符串 \"abracad\" 变为 \"aacacaa\"，这是一个回文串。总成本为 $3$。", "answer": "$$\\boxed{3}$$", "id": "3230960"}, {"introduction": "计算两个字符串之间的编辑距离是一回事，但如何在一个庞大的数据集中高效地使用它是另一回事。这个高级练习[@problem_id:3216177]将引导你进入一个真实的计算机科学应用场景：使用 BK-Tree（Burkhard-Keller 树）构建一个高效的拼写检查器。你将亲身体会到，如何利用编辑距离的数学特性——特别是它满足的三角不等式——来设计一个能够智能剪枝、避免与字典中每个单词都进行比较的、高性能的近似字符串搜索数据结构。", "problem": "您需要设计并实现一个完整的程序，该程序构建并查询一个Burkhard–Keller树（BK-Tree），以使用Levenshtein距离进行近似字符串匹配。BK-Tree是一种有根树，其中每条边都由一个非负整数距离标记，每个节点存储定义域中的单个元素；它支持在某个度量下的高效范围查询。在此问题中，定义域是固定字母表上的有限字符串集合，度量是Levenshtein距离。目标是从第一性原理推导出剪枝规则，并实现由此产生的搜索算法。\n\n基本基础和定义：\n- 度量空间是一个对 $(X, d)$，其中 $X$ 是一个集合，$d: X \\times X \\to \\mathbb{R}_{\\ge 0}$ 是一个满足非负性、不可分者同一性、对称性和三角不等式的函数。三角不等式规定：对于所有 $x, y, z \\in X$，$d(x, z) \\le d(x, y) + d(y, z)$。\n- 字符串 $s$ 和 $t$ 之间的Levenshtein距离 $D(s, t)$ 是将 $s$ 转换为 $t$ 所需的最小单字符插入、删除和替换次数。众所周知，$D$ 是一个度量，即 $D$ 满足上述度量公理。\n- Burkhard–Keller树（BK-Tree）通过以下方式组织元素：对于每个存储元素 $u$ 的节点，如果存在一个元素 $v$ 使得 $D(u, v) = \\ell$，则在边标签为 $\\ell \\in \\mathbb{Z}_{\\ge 0}$ 的位置放置一个子节点。在插入过程中，从根节点开始，一个元素 $v$ 被路由到一个其边标签等于 $D(u, v)$ 的子节点；如果该子节点不存在，则在该边上创建一个新节点。\n\n任务：\n- 从三角不等式和范围查询的定义出发，推导出在查询所有满足 $D(q, v) \\le k$ 的元素 $v$ 时（给定查询字符串 $q$ 和半径 $k \\in \\mathbb{Z}_{\\ge 0}$），允许对搜索空间进行剪枝的子节点边标签所需满足的必要条件。问题描述没有提供显式的不等式；推导必须从度量公理开始，并得出一个可用于BK-Tree搜索的剪枝准则。\n- 使用动态规划实现一个Levenshtein距离函数 $D(s, t)$。\n- 从一个有序的单词词典构建一个BK-Tree，为每个单词分配一个等于其在给定列表中位置的索引（从 $0$ 开始）。每个BK-Tree节点应存储单词及其索引。插入操作应遵循使用 $D$ 的BK-Tree规则。\n- 实现一个范围查询，对于给定的 $(q, k)$，返回满足 $D(q, W[i]) \\le k$ 的索引 $i$ 的排序列表，其中 $W$ 是词典列表。\n\n测试套件和参数：\n- 使用以下词典 $W$（每个单词被分配的索引等于其在列表中的位置）：索引 $0$：\"book\"；索引 $1$：\"books\"；索引 $2$：\"boo\"；索引 $3$：\"boon\"；索引 $4$：\"boom\"；索引 $5$：\"bone\"；索引 $6$：\"cook\"；索引 $7$：\"cool\"；索引 $8$：\"school\"；索引 $9$：\"fool\"；索引 $10$：\"boar\"；索引 $11$：\"board\"；索引 $12$：\"bored\"；索引 $13$：\"bond\"；索引 $14$：\"band\"；索引 $15$：\"ban\"；索引 $16$：\"an\"；索引 $17$：\"a\"；索引 $18$：\"bo\"；索引 $19$：\"hook\"；索引 $20$：\"brook\"。\n- 对以下 $(q, k)$ 对运行范围查询：\n  - $(\\text{\"boon\"}, k = 1)$\n  - $(\\text{\"book\"}, k = 0)$\n  - $(\\text{\"\"}, k = 2)$ 其中允许空字符串\n  - $(\\text{\"scholl\"}, k = 1)$\n  - $(\\text{\"xyz\"}, k = 10)$\n- 对于每个测试用例，要求的答案是匹配的词典条目索引的排序列表。每个单独的测试用例结果必须是一个整数列表。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用方括号括起来的逗号分隔的整数列表。例如，一个有效的输出格式是 $[[i_1,i_2],[j_1,j_2,j_3],\\dots]$，不含空格。", "solution": "该问题要求从第一性原理推导Burkhard–Keller树（BK-Tree）的搜索剪枝规则，并实现一个完整的程序来构建和查询这样一棵用于近似字符串匹配的树。匹配基于Levenshtein距离 $D$，查询旨在寻找词典 $W$ 中所有与查询字符串 $q$ 的距离在给定半径 $k$ 之内的字符串 $v$，即 $D(q, v) \\le k$。\n\nBK-Tree高效性的基础在于其存储的元素属于一个度量空间 $(X, d)$。度量空间是一个集合 $X$ 配备一个距离函数 $d: X \\times X \\to \\mathbb{R}_{\\ge 0}$，该函数满足四个公理：\n$1$. 非负性：$d(x, y) \\ge 0$\n$2$. 不可分者同一性：$d(x, y) = 0 \\iff x = y$\n$3$. 对称性：$d(x, y) = d(y, x)$\n$4$. 三角不等式：$d(x, z) \\le d(x, y) + d(y, z)$\n\n在这个问题中，集合 $X$ 是有限字符串的集合，距离函数 $d$ 是Levenshtein距离 $D$。已知 $(X, D)$ 是一个度量空间。搜索算法的剪枝规则是三角不等式的直接推论。\n\n剪枝规则的推导：\n设 $q$ 为查询字符串，$k$ 为搜索半径。目标是找到树中所有满足 $D(q, v) \\le k$ 的字符串 $v$。搜索算法遍历该树，在每个节点处，它必须决定其哪些子树（如果有的话）可能包含匹配项。\n\n考虑搜索在树中任意节点的状态。设此节点包含字符串 $u$。算法已经计算出查询字符串 $q$ 与该节点字符串 $u$ 之间的距离 $d_u = D(q, u)$。现在，考虑 $u$ 的一个子节点。通向该子节点的边上标记着一个整数距离 $\\ell$。根据BK-Tree的构造，位于以此子节点为根的子树中的任何字符串 $v$ 都必须满足条件 $D(u, v) = \\ell$。\n\n为了确定是否需要探索这个子树，我们将三角不等式应用于三个字符串：查询字符串 $q$、当前节点的字符串 $u$ 以及子树中一个潜在的匹配项 $v$。\n\n从三角不等式，我们得到两个关键关系：\n$1$. $D(q, u) \\le D(q, v) + D(v, u)$。根据对称性，$D(v, u) = D(u, v)$，所以我们可以写成 $D(q, u) \\le D(q, v) + D(u, v)$。整理后得到：\n$$D(q, u) - D(u, v) \\le D(q, v)$$\n\n$2$. $D(u, v) \\le D(u, q) + D(q, v)$。根据对称性，$D(u, q) = D(q, u)$，所以 $D(u, v) \\le D(q, u) + D(q, v)$。整理后得到：\n$$D(u, v) - D(q, u) \\le D(q, v)$$\n\n这两个不等式可以合并成一个更紧凑的形式，通常称为反向三角不等式：\n$$|D(q, u) - D(u, v)| \\le D(q, v)$$\n\n我们正在搜索满足主要查询条件 $D(q, v) \\le k$ 的字符串 $v$。如果子树中的字符串 $v$ 是一个有效匹配，那么将反向三角不等式与查询条件结合起来可得：\n$$|D(q, u) - D(u, v)| \\le D(q, v) \\le k$$\n\n这意味着，要在子树中存在任何潜在的匹配 $v$，必须满足一个必要条件：\n$$|D(q, u) - D(u, v)| \\le k$$\n\n让我们代入已知值：$d_u = D(q, u)$ 是在当前节点计算出的距离，而 $\\ell = D(u, v)$ 是通向子树的边的标签。探索该子树的必要条件变为：\n$$|d_u - \\ell| \\le k$$\n\n这个不等式就是剪枝规则。它表明我们只需要沿着那些标签 $\\ell$ 与查询到当前节点的距离 $d_u$ “接近”的边遍历子节点。展开绝对值得到了需要检查的边标签范围：\n$$-k \\le d_u - \\ell \\le k$$\n这等价于：\n$$d_u - k \\le \\ell \\le d_u + k$$\n\n因此，搜索算法按以下步骤进行：\n$1$. 从BK-Tree的根节点开始。\n$2$. 在一个包含字符串 $u$ 的给定节点处：\n   a. 计算距离 $d_u = D(q, u)$。\n   b. 如果 $d_u \\le k$，则字符串 $u$ 是一个匹配项。将其索引添加到结果集中。\n   c. 遍历 $u$ 的所有子节点。对于每个通过标签为 $\\ell$ 的边连接的子节点，检查是否满足 $d_u - k \\le \\ell \\le d_u + k$。\n   d. 如果满足条件，则对该子节点递归地应用搜索过程。否则，从搜索中剪掉树的整个该分支。\n\n这个推导出的规则使得算法可以避免为词典中大部分字符串计算Levenshtein距離，从而使其效率显著高于线性扫描。\n\n实现将包括三个主要部分：\n$1$. 一个使用标准动态规划方法和代价矩阵来计算Levenshtein距离 $D(s, t)$ 的函数。\n$2$. 一个BK-Tree的基于类的表示，其中包含一个`Node`结构来存储单词、其索引及其子节点的字典，以及一个`BKTree`类来管理插入和查询。\n$3$. 一个查询方法，该方法使用推导出的剪枝规则 $|d_u - \\ell| \\le k$ 实现递归搜索。\n\n最终的程序将根据提供的词典构建树，然后执行指定的查询，并按要求收集和格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef levenshtein_distance(s1: str, s2: str) - int:\n    \"\"\"\n    Calculates the Levenshtein distance between two strings using dynamic programming.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    \n    # Initialize DP table. dp[i][j] will be the distance between the first\n    # i chars of s1 and the first j chars of s2.\n    dp = np.zeros((m + 1, n + 1), dtype=int)\n    \n    # Base cases: distance from an empty string to a non-empty one is the\n    # length of the non-empty string (all insertions).\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n        \n    # Fill the rest of the table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if s1[i - 1] == s2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1,        # Deletion\n                           dp[i][j - 1] + 1,        # Insertion\n                           dp[i - 1][j - 1] + cost) # Substitution/Match\n                           \n    return dp[m][n]\n\nclass BKNode:\n    \"\"\"A node in the Burkhard-Keller Tree.\"\"\"\n    def __init__(self, word: str, index: int):\n        self.word = word\n        self.index = index\n        self.children = {}  # dict mapping distance to child BKNode\n\nclass BKTree:\n    \"\"\"A Burkhard-Keller Tree for approximate string matching.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def add(self, word: str, index: int):\n        \"\"\"Adds a word with its index to the tree.\"\"\"\n        if self.root is None:\n            self.root = BKNode(word, index)\n            return\n\n        current_node = self.root\n        while True:\n            dist = levenshtein_distance(current_node.word, word)\n            if dist in current_node.children:\n                current_node = current_node.children[dist]\n            else:\n                current_node.children[dist] = BKNode(word, index)\n                break\n\n    def query(self, query_word: str, k: int) - list[int]:\n        \"\"\"\n        Finds all words in the tree within Levenshtein distance k of the query_word.\n        Returns a sorted list of indices.\n        \"\"\"\n        if self.root is None:\n            return []\n            \n        matches = []\n        # A stack for iterative traversal to avoid deep recursion\n        stack = [self.root]\n\n        while stack:\n            node = stack.pop()\n            # Calculate distance from query word to the current node's word\n            dist_to_node = levenshtein_distance(query_word, node.word)\n\n            # If the current node is a match, add its index\n            if dist_to_node = k:\n                matches.append(node.index)\n\n            # Use the triangle inequality to prune branches\n            # We only need to visit children in the range [d-k, d+k]\n            low = dist_to_node - k\n            high = dist_to_node + k\n\n            for dist, child in node.children.items():\n                if low = dist = high:\n                    stack.append(child)\n        \n        matches.sort()\n        return matches\n\ndef solve():\n    # Define the dictionary and test cases from the problem statement.\n    dictionary = [\n        \"book\", \"books\", \"boo\", \"boon\", \"boom\", \"bone\", \"cook\", \"cool\",\n        \"school\", \"fool\", \"boar\", \"board\", \"bored\", \"bond\", \"band\", \"ban\",\n        \"an\", \"a\", \"bo\", \"hook\", \"brook\"\n    ]\n    \n    test_cases = [\n        (\"boon\", 1),\n        (\"book\", 0),\n        (\"\", 2),\n        (\"scholl\", 1),\n        (\"xyz\", 10)\n    ]\n\n    # Build the BK-Tree\n    bktree = BKTree()\n    for i, word in enumerate(dictionary):\n        bktree.add(word, i)\n        \n    all_results = []\n    for q, k in test_cases:\n        result = bktree.query(q, k)\n        all_results.append(result)\n\n    # Format the output exactly as specified: [[i1,i2],[j1],...] with no spaces\n    case_strings = []\n    for res_list in all_results:\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3216177"}]}