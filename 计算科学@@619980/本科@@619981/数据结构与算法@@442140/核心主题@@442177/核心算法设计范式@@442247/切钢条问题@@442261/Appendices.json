{"hands_on_practices": [{"introduction": "这个练习将通过引入负价格来挑战你对钢管切割问题核心原则的理解。这种情况代表了特定长度切割件的处理成本，它考验了标准动态规划递推关系的稳健性。通过解决这个问题，你将巩固对贝尔曼方程的掌握，并学习如何调整你的动态规划实现以适应值不完全为正的更一般情况 [@problem_id:3267470]。", "problem": "给定一个切钢管问题的实例，其中某些长度的钢管段具有负价格，代表不受欢迎长度的处理成本。一根总长度为 $n$ 的钢管必须被分割成一个正整数长度的多重集，其长度之和恰好为 $n$。对于每段长度为 $i$ 的钢管，其贡献的收益为 $p[i]$，该值可以为负、零或正。目标是最大化通过分割钢管获得的总收益，总收益是所选钢管段价格的总和。没有每次切割的费用，并且钢管必须完全分割成总和为 $n$ 的整数长度；分解不能留下任何剩余部分。\n\n使用的基本原理和定义：\n- 动态规划的最优性原理（Bellman 原理）指出，如果一个问题表现出最优子结构，那么该问题的最优解内部包含了其子问题的最优解。\n- 最优子结构：如果长度为 $n$ 的钢管的最优分解以一段长度为 $i$ 的钢管段结束，那么对剩余长度 $n-i$ 的分解本身必须是对于长度 $n-i$ 的最优分解。\n- 重叠子问题：不同分解方案的子问题会重复使用相同剩余长度的解。\n\n任务：\n- 根据上述基本原理和定义，推导出正确的算法策略，以计算在给定任意钢管长度 $n$ 和价格列表 $p$ 的情况下可实现的最大收益，即使某些 $p[i]$ 条目为负。\n- 实现一个完整的、可运行的程序来评估以下测试套件。对于每个测试用例，计算最大收益并以整数形式报告。\n\n测试套件：\n- 测试 $1$：$n = 8$，价格为 $p[1] = 1$, $p[2] = 5$, $p[3] = -3$, $p[4] = 4$, $p[5] = -2$, $p[6] = 7$, $p[7] = 0$, $p[8] = 8$。\n- 测试 $2$：$n = 5$，价格为 $p[1] = -5$, $p[2] = -1$, $p[3] = -4$, $p[4] = -3$, $p[5] = -2$。\n- 测试 $3$：$n = 0$，价格为 $p[1] = 2$, $p[2] = -1$。注意，由于 $n = 0$，空分解是唯一有效的分割，其收益为 $0$。\n- 测试 $4$：$n = 9$，价格为 $p[1] = -100$, $p[2] = 5$, $p[3] = 0$, $p[4] = 9$, $p[5] = -10$, $p[6] = 10$, $p[7] = -1$, $p[8] = 0$, $p[9] = 19$。\n- 测试 $5$：$n = 10$，价格为 $p[1] = 2$, $p[2] = 3$, $p[3] = 4$, $p[4] = -100$, $p[5] = 7$, $p[6] = 8$, $p[7] = 9$, $p[8] = 10$, $p[9] = 11$, $p[10] = 12$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含测试 $1$、测试 $2$、测试 $3$、测试 $4$ 和测试 $5$ 的最大收益。例如，该行的格式应为字符 '['，后跟 $r_1$, ',', $r_2$, ',', $r_3$, ',', $r_4$, ',', $r_5$，最后是字符 ']'。", "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n**步骤 1：提取已知条件**\n- **问题类型**：带有非正价格的切钢管问题。\n- **钢管长度**：$n$，一个非负整数。\n- **价格列表**：$p[i]$ 是长度为 $i$ 的钢管段的收益，其中 $i$ 是一个正整数。价格可以是正数、负数或零。\n- **目标**：将长度为 $n$ 的钢管分割成一个整数长度的多重集，其长度总和恰好为 $n$，从而最大化总收益。\n- **约束**：整根钢管必须被完全分割。没有“每次切割”的成本。\n- **基本原理**：解决方案必须从最优性原理以及最优子结构和重叠子问题的性质中推导出来。\n- **测试套件**：\n  - 测试 $1$：$n = 8$，长度 $1$ 到 $8$ 的价格为 $p = [1, 5, -3, 4, -2, 7, 0, 8]$。\n  - 测试 $2$：$n = 5$，长度 $1$ 到 $5$ 的价格为 $p = [-5, -1, -4, -3, -2]$。\n  - 测试 $3$：$n = 0$，长度 $1$ 到 $2$ 的价格为 $p = [2, -1]$。题目规定对于 $n=0$，收益为 $0$。\n  - 测试 $4$：$n = 9$，长度 $1$ 到 $9$ 的价格为 $p = [-100, 5, 0, 9, -10, 10, -1, 0, 19]$。\n  - 测试 $5$：$n = 10$，长度 $1$ 到 $10$ 的价格为 $p = [2, 3, 4, -100, 7, 8, 9, 10, 11, 12]$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是经典切钢管问题的一个变体，是算法设计和动态规划中的一个标准课题。引入负价格（代表处理成本）是一个有效、合乎逻辑的扩展，不违反任何数学或科学原理。\n- **良态问题**：该问题是良态的。对于任意给定的 $n$ 和价格列表 $p$，存在一组有效的分割方案（例如，切成 $n$ 段长度为 $1$ 的钢管），因此保证存在一个最大收益值。目标定义明确。\n- **客观性**：问题陈述使用了精确、可形式化的语言（例如，“最大化总收益”、“分割成一个多重集”、“总和恰好为 $n$”）。\n\n**步骤 3：结论与行动**\n该问题具有科学依据、是良态的、客观且自洽的。这是一个有效的问题，可以为其推导出解决方案。\n\n### 算法策略的推导\n\n该问题旨在最大化收益，并表现出问题陈述中定义的最优子结构和重叠子问题的特性，这些是可用动态规划解决的问题的标志。负价格的存在不会使此结构失效。\n\n令 $r(j)$ 表示长度为 $j$ 的钢管可实现的最大收益，其中 $j$ 是一个非负整数。我们的目标是计算 $r(n)$。\n\n**基本情况：**\n对于长度为 $j=0$ 的钢管，唯一可能的分割是空集。长度之和为 $0$，收益之和也为 $0$。这与测试 $3$ 的规定相符。因此，我们递推关系的基本情况是：\n$$r(0) = 0$$\n\n**递推公式：**\n对于长度为 $j > 0$ 的钢管，我们必须至少进行一次切割。一个最优分割是通过进行第一次切割，得到一段长度为 $i$ 的钢管（其中 $1 \\le i \\le j$），然后对剩余长度为 $j-i$ 的钢管进行最优分割而形成的。这是最优性原理的直接应用。\n\n如果我们选择第一段的长度为 $i$，我们将获得 $p_i$ 的收益（使用 $p_i$ 表示长度为 $i$ 的钢管段的价格，如问题文本所示），然后剩下的问题是找到长度为 $j-i$ 的钢管的最大收益，即 $r(j-i)$。对于这个选择 $i$，总收益为 $p_i + r(j-i)$。\n\n为了找到长度为 $j$ 的总最大收益，我们必须考虑所有可能的第一段长度 $i$（从 $1$ 到 $j$），并选择能产生最大总收益的那一个。这给出了该问题的 Bellman 方程：\n$$r(j) = \\max_{1 \\le i \\le j} \\{ p_i + r(j-i) \\}$$\n这个递推关系无论价格 $p_i$ 的符号如何都成立。最大化运算符 $\\max(\\cdot)$ 会正确地识别出最佳选项，无论最终收益是正还是负。例如，$\\max(-5, -10) = -5$。\n\n**算法设计（自底向上动态规划）：**\n基于该递推关系，我们可以从 $0$ 到 $n$ 按 $j$ 的递增顺序迭代计算 $r(j)$ 的值。这避免了重复计算重叠子问题的解。\n\n1.  创建一个数据结构，通常是一个数组，我们称之为 $R$，大小为 $n+1$，用于存储 $r(0), r(1), \\dots, r(n)$ 的值。\n2.  初始化该数组。设置基本情况 $R[0] = 0$。对于所有其他索引 $j > 0$，将 $R[j]$ 初始化为一个保证小于任何可能收益的值，例如负无穷大 ($-\\infty$)。\n3.  使用变量 $j$ 从 $1$ 迭代到 $n$。在每次迭代中，使用推导出的递推关系计算 $R[j]$。这涉及一个从 $1$ 到 $j$ 的嵌套循环 $i$：\n    $$R[j] = \\max_{1 \\le i \\le j} \\{ p_i + R[j-i] \\}$$\n    这里，$p_i$ 对应于长度为 $i$ 的价格（来自输入的价格列表，例如，在 0-索引 数组中为 `prices[i-1]`），而 $R[j-i]$ 是已计算出的剩余长度的最优收益。\n4.  外层循环完成后，$R[n]$ 的值将包含长度为 $n$ 的钢管可能的最大收益。这个值就是解。\n\n这种自底向上的动态规划方法通过在较小子问题的最优解基础上构建，正确且高效地解决了切钢管问题，即使存在负价格也是如此。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the provided test suite for the rod cutting problem with negative prices.\n    \"\"\"\n\n    def get_max_revenue(n, prices):\n        \"\"\"\n        Calculates the maximum revenue for cutting a rod of length n using dynamic programming.\n\n        Args:\n            n (int): The length of the rod.\n            prices (list[int]): A list of prices, where prices[i-1] is the price\n                                for a piece of length i.\n\n        Returns:\n            int: The maximum possible revenue.\n        \"\"\"\n        if n == 0:\n            return 0\n\n        # revenue[j] will store the maximum revenue for a rod of length j.\n        # We initialize with negative infinity because revenues can be negative.\n        revenue = np.full(n + 1, -np.inf, dtype=np.float64)\n\n        # Base case: a rod of length 0 has a revenue of 0.\n        revenue[0] = 0\n\n        # Build the table revenue[] in a bottom-up manner.\n        for j in range(1, n + 1):\n            # For each length j, consider all possible first cuts of length i.\n            for i in range(1, j + 1):\n                # The total revenue for this choice is the price of the first piece\n                # plus the optimal revenue for the remaining piece.\n                # price for length i is at index i-1 in the prices list.\n                current_revenue = prices[i - 1] + revenue[j - i]\n                \n                # Update the max revenue for length j if this choice is better.\n                if current_revenue > revenue[j]:\n                    revenue[j] = current_revenue\n        \n        # The final answer is the max revenue for length n.\n        return int(revenue[n])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (8, [1, 5, -3, 4, -2, 7, 0, 8]),\n        # Test 2\n        (5, [-5, -1, -4, -3, -2]),\n        # Test 3\n        (0, [2, -1]),\n        # Test 4\n        (9, [-100, 5, 0, 9, -10, 10, -1, 0, 19]),\n        # Test 5\n        (10, [2, 3, 4, -100, 7, 8, 9, 10, 11, 12]),\n    ]\n\n    results = []\n    for n, p in test_cases:\n        result = get_max_revenue(n, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3267470"}, {"introduction": "在掌握了基本解法之后，这个练习将专注于算法优化，这是计算机科学家的一项关键技能。你将遇到一个“稀疏”价格表，其中大多数切割件没有价值——这是现实世界数据中的一个常见特征。你的目标是重新设计标准的 $O(n^2)$ 算法，通过利用这种稀疏性使其运行得更快，从而促使你更深入地思考动态规划解法的结构 [@problem_id:3267293]。", "problem": "您将解决经典的切钢管问题：一根整数长度为 $n$ 的钢管可以被切割成整数尺寸的小段，每个长度为 $i \\in \\{1,2,\\dots,n\\}$ 的小段都有一个相应的售价 $p_i \\ge 0$。目标是选择一种切割方案，使得所有小段的长度之和恰好为 $n$，同时最大化总收益。时间复杂度为 $O(n^2)$ 的标准动态规划公式会为每个 $j \\in \\{1,2,\\dots,n\\}$ 计算出将 $j$ 表示为正整数之和的所有方式所能获得的最大收益。在本任务中，价格列表是稀疏的：即大多数 $p_i$ 的值为零。您必须设计并实现一个利用这种稀疏性的算法，当非零价格的数量很少时，其渐近运行时间要严格优于 $O(n^2)$。\n\n基本原理和约束：\n- 该算法必须源自 Bellman 最优性原理和动态规划的最优子结构定义，这两者都是经过充分检验的算法基石。具体来说，对于任意 $j \\in \\{1,\\dots,n\\}$，长度为 $j$ 的最优收益等于最佳第一刀的收益加上剩余部分的最优收益。\n- 可用的小段长度集合恰好是 $\\{1,2,\\dots,n\\}$；对可使用的长度没有限制，但价格可能为零。所有 $p_i$ 均为整数且 $p_i \\ge 0$。\n- 您必须基于这些基本原理进行推理，构建一个改进算法，其最坏情况下的时间复杂度为 $O(n \\cdot m)$，其中 $m$ 是满足 $p_i > 0$ 的索引 $i$ 的数量。该改进必须通过消除涉及 $p_i = 0$ 的状态转移来实现，同时要保证算法的正确性。\n- 您必须明确说明，为什么该算法即使不遍历价格为零的长度，也仍然能计算出正确的最大收益。\n\n输出要求：\n- 对于每个测试用例，计算完整钢管长度 $n$ 所能获得的最大收益。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），列表中的每个 $r_k$ 都是一个整数。\n\n本问题不涉及角度单位、物理单位和百分比。\n\n测试套件：\n- 测试用例 $1$：$n = 8$，价格列表 $p = [1,0,4,5,0,0,0,0]$。\n- 测试用例 $2$：$n = 9$，价格列表 $p = [0,0,0,7,0,0,0,0,0]$。\n- 测试用例 $3$：$n = 5$，价格列表 $p = [0,0,0,0,0]$。\n- 测试用例 $4$：$n = 7$，价格列表 $p = [2,0,0,0,9,0,0]$。\n- 测试用例 $5$：$n = 20$，价格列表 $p = [0,5,7,0,0,0,17,19,0,0,0,0,0,0,0,0,0,0,0,0]$。\n\n覆盖性设计：\n- 测试用例 1 是一个一般情况，包含几个有利可图的长度，涵盖了小尺寸和中等尺寸的切割。\n- 测试用例 2 确保只存在一个长度大于 1 的非零价格，需要用价格为零的长度来填充以达到精确尺寸。\n- 测试用例 3 是一个所有价格都为零的边界情况。\n- 测试用例 4 测试了存在有利可图的单位长度段的情况，以确保收益的单调增长。\n- 测试用例 5 侧重于组合多个有利可图的长度，并检查高价格密度的小段是否占主导地位。\n\n最终输出格式：\n- 您的程序必须打印单单一行：一个包含五个整数结果的列表，按测试用例的顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$。", "solution": "该问题要求在价格列表稀疏的条件下，为切钢管问题设计一种高效算法。标准动态规划解法的时间复杂度为 $O(n^2)$，我们必须利用许多价格 $p_i$ 为零这一事实来改进它。目标复杂度为 $O(n \\cdot m)$，其中 $m$ 是价格非零的小段数量。推导过程必须基于 Bellman 最优性原理。\n\n### 基于原理的稀疏算法推导\n\n切钢管问题具有最优子结构。设 $r_j$ 为长度为 $j$ 的整数长度钢管可获得的最大收益。为了找到切割长度为 $j$ 的钢管的最优方法，我们可以先切下长度为 $i$（其中 $1 \\le i \\le j$）的一段，然后对剩余长度为 $j-i$ 的部分进行最优切割。这种选择的收益是 $p_i + r_{j-i}$。Bellman 最优性原理指出，我们必须选择使该值最大化的切割点 $i$。这给出了标准的动态规划递推关系：\n$$r_j = \\max_{1 \\le i \\le j} \\{p_i + r_{j-i}\\}$$\n基础情况为 $r_0 = 0$。对于 $j=1, \\dots, n$ 直接计算此递推关系需要嵌套循环，从而导致 $O(n^2)$ 的时间复杂度。\n\n为了利用稀疏性，我们分析不同切割的贡献。我们可以将所有可能的第一刀集合 $\\{1, 2, \\dots, j\\}$ 划分为两个不相交的集合：\n1. $I_p(j) = \\{i \\mid 1 \\le i \\le j, p_i > 0\\}$：价格为正的可用小段长度集合。\n2. $I_z(j) = \\{i \\mid 1 \\le i \\le j, p_i = 0\\}$：价格为零的可用小段长度集合。\n\n通过在这两个集合上分别进行最大化，该递推关系可以重写为：\n$$r_j = \\max \\left( \\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}, \\max_{i \\in I_z(j)} \\{0 + r_{j-i}\\} \\right)$$\n我们来分析外部 $\\max$ 函数中的两项。第一项，$\\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}$，考虑了所有有利可图的第一刀。对于任意 $j$，这类切割的数量最多为 $m$，即非零价格的总数。\n\n第二项是 $\\max_{i \\in I_z(j)} \\{r_{j-i}\\}$。为简化这一项，我们首先确立收益函数 $r_j$ 的一个关键属性：它随 $j$ 的增加是非递减的。\n对于任意长度为 $j \\ge 1$ 的钢管，一种可行（但不一定最优）的切割策略是切下一段长度为 1 的小段，然后对剩余长度为 $j-1$ 的部分进行最优切割。此特定策略的收益为 $p_1 + r_{j-1}$。最优收益 $r_j$ 必须至少与任何单一策略的收益一样大。因此，$r_j \\ge p_1 + r_{j-1}$。鉴于所有价格均为非负（$p_i \\ge 0$）的约束，我们有 $p_1 \\ge 0$，这意味着 $r_j \\ge r_{j-1}$。通过归纳法，这对所有 $j \\ge 1$ 都成立，因此 $r_0 \\le r_1 \\le r_2 \\le \\dots \\le r_n$。\n\n在确定了 $r_j$ 是一个非递减函数后，我们回到 $\\max_{i \\in I_z(j)} \\{r_{j-i}\\}$ 这一项。由于任何切割都满足 $i \\ge 1$，我们有 $j-i \\le j-1$。因为 $r_k$ 是非递减的，所以对于所有 $i \\ge 1$，必然有 $r_{j-i} \\le r_{j-1}$。因此，集合 $\\{r_{j-i} \\mid i \\in I_z(j)\\}$ 中的最大值的上界是 $r_{j-1}$。\n所以，我们有：\n$$\\max_{i \\in I_z(j)} \\{r_{j-i}\\} \\le r_{j-1}$$\n\n$r_j$ 的完整递推关系因此受限于：\n$$r_j \\le \\max \\left( \\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}, r_{j-1} \\right)$$\n然而，我们也知道 $r_j \\ge r_{j-1}$。这意味着解至少为 $r_{j-1}$。任何针对长度 $j$ 的最优解，要么是某个更小长度的最优解加上一些价格为零的切割（此时其收益已被 $r_k$ 的非递减性捕获，并以 $r_{j-1}$ 为界），要么是进行了一次新的有利可图的切割。这导出了精确且改进后的递推关系：\n$$r_j = \\max \\left( r_{j-1}, \\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\} \\right)$$\n\n### 正确性证明\n这个新的递推关系可以正确计算最大收益，同时避免了对价格为零的长度进行迭代。证明如下：\n对于长度为 $j$ 的钢管，其最优解来自一个划分 $j = \\sum_k c_k$。其收益为 $\\sum_k p_{c_k}$。\n1.  **情况1：长度 $j$ 的最优解与某个长度 $j'  j$ 的最优解相同。** 如果对 $j$ 的划分只是对 $j'$ 的划分加上一些价格为零的小段，就会出现这种情况。例如，长度为 $j$ 的最大收益是通过将其切成一段长度为 1（$p_1=0$）的小段和一段经过最优切割的长度为 $j-1$ 的钢管实现的。在这种情况下，$r_j = r_{j-1}$。我们递推关系中的 `r_{j-1}` 项正确地捕获了可以从更小钢管长度“继承”过来的最大可能收益。由于 $r_k$ 是非递减的，所以 $r_{j-1}$ 是从任何更小长度 $j'  j$ 可能获得的最高收益。\n\n2.  **情况2：每个针对长度 $j$ 的最优解都至少包含一段价格 $p_i > 0$ 的小段 $i$。** 在这种情况下，最优解是通过进行第一刀切割 $i$（其中 $p_i > 0$）并对余下的 $j-i$ 部分进行最优求解来找到的。我们递推关系中的 $\\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}$ 项明确地在所有有利可图的第一刀中找到了最佳选项。\n\n通过取这两种情况的最大值，我们覆盖了所有可能性，从而保证了最优性。该算法能正确计算最大收益，因为它考虑了所有有利可图的切割，同时也考虑了这样一种可能性：即对长度为 $j$ 的最优策略可能只是在长度为 $j-1$ 的最优解上增加一个零收益的小段。\n\n### 算法设计与复杂度分析\n基于推导出的递推关系，我们可以构建一个高效的算法。\n\n1.  初始化一个大小为 $n+1$ 的一维数组 `revenue`，用于存储最优收益 $r_0, r_1, \\dots, r_n$。设置 `revenue[0] = 0`。\n2.  预处理价格列表 $p$，为那些价格为正的长度 $i$ 创建一个 `(i, price)` 对的列表。设该列表的大小为 $m$。\n3.  用一个循环对 $j$ 从 $1$ 到 $n$ 进行迭代，以计算 `revenue[j]`。\n4.  对于每个 $j$，计算 `max_from_positive_cuts`，即进行一次有利可图的第一刀切割所能获得的最大收益。将其初始化为 0（或一个足够小的数）。遍历这 $m$ 个有利可图的切割 `(i, price)`。如果 $i \\le j$，则用 `price + revenue[j-i]` 更新此最大值。\n5.  设置 `revenue[j] = max(revenue[j-1], max_from_positive_cuts)`。\n6.  最终答案是 `revenue[n]`。\n\n时间复杂度由嵌套循环决定。外层循环运行 $n$ 次（$j$ 从 1 到 $n$）。内层循环遍历包含 $m$ 个正价格的列表。因此，总时间复杂度为 $O(n \\cdot m)$，当 $m \\ll n$ 时，这严格优于 $O(n^2)$。空间复杂度为 $O(n)$，用于存储 `revenue` 数组。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sparse rod cutting problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        (8, [1, 0, 4, 5, 0, 0, 0, 0]),\n        (9, [0, 0, 0, 7, 0, 0, 0, 0, 0]),\n        (5, [0, 0, 0, 0, 0]),\n        (7, [2, 0, 0, 0, 9, 0, 0]),\n        (20, [0, 5, 7, 0, 0, 0, 17, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    ]\n\n    results = []\n    for n, p in test_cases:\n        result = compute_max_revenue(n, p)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_revenue(n: int, prices: list[int]) - int:\n    \"\"\"\n    Computes the maximum revenue for the rod cutting problem using a sparse DP approach.\n    \n    The algorithm has a time complexity of O(n*m), where n is the rod length and m is the\n    number of pieces with a non-zero price.\n\n    Args:\n        n: The integer length of the rod.\n        prices: A list of integers where prices[i-1] is the price for a piece of length i.\n\n    Returns:\n        The maximum obtainable revenue.\n    \"\"\"\n    # revenue[j] will store the maximum revenue for a rod of length j.\n    # Initialize with zeros. revenue[0] is 0 by definition.\n    revenue = np.zeros(n + 1, dtype=int)\n\n    # Pre-process to find all pieces with positive prices.\n    # Store them as (length, price) tuples. Length is 1-based.\n    positive_prices = []\n    for i in range(len(prices)):\n        if prices[i]  0:\n            length = i + 1\n            price = prices[i]\n            positive_prices.append((length, price))\n\n    # Main DP loop. Iterate from length j = 1 to n.\n    for j in range(1, n + 1):\n        # This variable will hold max_{i in I_p(j)} {p_i + r_{j-i}}.\n        # Initialize to 0, which is safe since revenues are non-negative.\n        max_rev_from_pos_cuts = 0\n\n        # Iterate only through pieces with positive prices.\n        for length, price in positive_prices:\n            if length = j:\n                # Consider making a first cut of this `length`.\n                current_rev = price + revenue[j - length]\n                if current_rev  max_rev_from_pos_cuts:\n                    max_rev_from_pos_cuts = current_rev\n        \n        # The recurrence relation is r_j = max(r_{j-1}, max_rev_from_pos_cuts).\n        # r_{j-1} accounts for optimal solutions that just append zero-priced pieces\n        # to an optimal solution for a smaller rod.\n        revenue[j] = max(revenue[j - 1], max_rev_from_pos_cuts)\n\n    return revenue[n]\n\nsolve()\n```", "id": "3267293"}, {"introduction": "许多优化问题不仅要求找到最佳值，还需要找出达成该值的具体方案。最后的这个练习将钢管切割问题从寻找最大收益提升到识别所有能产生该收益的独特切割方案。你将学习如何增强你的动态规划算法，以存储和重构实际的解，这是一种适用于各种动态规划问题的强大技术 [@problem_id:3267391]。", "problem": "给定一个以纯数学术语表述的经典切杆问题。对于一个整数杆长 $L \\ge 0$ 和一个价格表 $P_1, P_2, \\dots, P_L$（其中 $P_i$ 是长度为 $i$ 的单段的售价），一个切割方案是任意一个其元素之和恰好为 $L$ 的正整数多重集。一个切割方案的总收益是其各组成部分价格的总和。您的任务是为每个指定的实例，重构出所有能获得最大可能总收益的唯一切割方案（作为多重集处理，因此顺序无关），并同时给出该最大收益值。\n\n您的算法设计应仅基于基本定义和原则：离散优化中的最优子结构定义、动态规划（DP, Dynamic Programming）的定义，以及任何最优解都由子问题的最优解构成的最优性原理。除这些原则外，不要假定任何快捷公式。切割是免费的，切割段数不受限制，并且所有切割段都必须是整数长度。每个价格 $P_i$ 都是一个非负整数。\n\n用其频率向量 $\\mathbf{c} = (c_1, c_2, \\dots, c_L)$ 来表示每个唯一的切割方案，其中 $c_i$ 是长度为 $i$ 的段的数量。当且仅当两个切割方案的频率向量相同时，它们被认为是相同的。对于 $L = 0$，恰好有一种方案：空多重集，由长度为0的空频率向量表示。\n\n您的程序必须解决以下测试套件。每个测试用例包含一个对 $(\\mathbf{P}, L)$，其中 $\\mathbf{P}$ 是一个列表 $(P_1,P_2,\\dots,P_L)$。\n\n- 测试用例 1：$L = 4$，$\\mathbf{P} = (1, 5, 8, 9)$。\n- 测试用例 2：$L = 5$，$\\mathbf{P} = (2, 5, 7, 8, 10)$。\n- 测试用例 3：$L = 0$，$\\mathbf{P} = ()$。\n- 测试用例 4：$L = 7$，$\\mathbf{P} = (1, 5, 8, 9, 10, 17, 17)$。\n- 测试用例 5：$L = 6$，$\\mathbf{P} = (2, 4, 6, 8, 10, 12)$。\n\n对每个测试用例，计算：\n- 长度为 $L$ 的所有切割方案中的最大收益 $R^\\star$。\n- 达到 $R^\\star$ 的所有唯一最优频率向量 $\\mathbf{c}$ 的完整集合。\n\n为了使输出完全确定且可解析，请将最优频率向量按 $(c_1, c_2, \\dots, c_L)$ 的字典升序排序，并将每个测试用例的答案编码为单个整数列表：\n- 首先放置 $R^\\star$。\n- 然后放置最优方案的数量 $K$。\n- 然后，对于指定顺序中的 $K$ 个方案中的每一个，追加其完整的频率向量 $(c_1, c_2, \\dots, c_L)$。\n\n您的程序应将所有五个测试用例的答案汇总到一行中，方法是打印这些按测试用例组织的列表的列表，用逗号分隔且无空格，例如，`[[\\dots],[\\dots],\\dots]`。此任务不涉及物理单位、角度或百分比。每个测试用例唯一可接受的输出是完全按照上述规定排列的整数。", "solution": "## 问题验证\n\n### 步骤1：提取已知信息\n- **任务**：对于给定的整数杆长 $L \\ge 0$ 和价格表 $(P_1, P_2, \\dots, P_L)$，找出最大可能总收益 $R^\\star$ 以及所有能实现此收益的唯一切割方案。\n- **切割方案**：一个正整数的多重集，其元素之和恰好为 $L$。切割段的顺序无关。\n- **方案表示**：一个频率向量 $\\mathbf{c} = (c_1, c_2, \\dots, c_L)$，其中 $c_i$ 是长度为 $i$ 的段的数量。\n- **特殊情况 $L=0$**：唯一的方案是空多重集，由长度为0的空频率向量表示。\n- **约束条件**：$P_i$ 是非负整数。切割是免费的。所有切割段都必须是整数长度。\n- **输出格式**：对于每个测试用例，输出一个单一的整数列表：$[R^\\star, K, c_{1,1}, \\dots, c_{1,L}, \\dots, c_{K,1}, \\dots, c_{K,L}]$，其中 $K$ 是最优方案的数量，且这 $K$ 个频率向量按字典序排序。\n- **测试套件**：\n    1. $L = 4$，$\\mathbf{P} = (1, 5, 8, 9)$\n    2. $L = 5$，$\\mathbf{P} = (2, 5, 7, 8, 10)$\n    3. $L = 0$，$\\mathbf{P} = ()$\n    4. $L = 7$，$\\mathbf{P} = (1, 5, 8, 9, 10, 17, 17)$\n    5. $L = 6$，$\\mathbf{P} = (2, 4, 6, 8, 10, 12)$\n\n### 步骤2：使用提取的已知信息进行验证\n根据验证标准对问题进行评估。\n- **科学性**：该问题是计算机科学和离散数学中动态规划的一个经典范例。它在数学上是严谨的，在事实上是合理的。满足此标准。\n- **良构性**：对于任何给定的输入，都存在有限数量的切割方案，这保证了最大收益的存在。寻找此最大值及所有相应方案的目标是明确定义的。满足此标准。\n- **客观性**：问题使用形式化数学语言陈述，没有任何主观性或模糊性。满足此标准。\n- **不完整或矛盾的设定**：问题是自洽的。所有必要的定义（方案、收益、向量表示）、约束和特殊情况（例如，$L=0$）都已提供。不存在矛盾。满足此标准。\n- **其他缺陷**：该问题并非微不足道，因为它需要一个系统性算法（DP）来解决。它不是隐喻性的、不良构的或无法验证的。\n\n### 步骤3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n## 算法解决方案\n\n寻找切杆最优收益的问题是一个经典的离散优化问题，它表现出最优子结构的特性。这个特性是动态规划的基石。\n\n**最优性原理与最大收益的递推关系**\n\n最优性原理指出，一个问题的最优解可以由其子问题的最优解构造而成。对于切杆问题，对长度为 $L$ 的杆的最优切割方案，必须包含对其剩余部分的最优切割方案。\n\n设 $R[j]$ 表示从长度为 $j$ 的杆可获得的最大收益，其中 $j \\in \\{0, 1, \\dots, L\\}$。基本情况是长度为0的杆，它没有切割段，因此收益为 $R[0] = 0$。对于任何长度 $j  0$，我们可以通过考虑所有可能的第一刀来确定 $R[j]$。如果我们切下第一段的长度为 $i$（其中 $1 \\le i \\le j$），我们得到一段长度为 $i$、价格为 $P_i$ 的切割段，以及一根长度为 $j-i$ 的剩余杆。根据定义，我们能从剩余部分获得的最大收益是 $R[j-i]$。对于这种第一刀的选择，总收益为 $P_i + R[j-i]$。为了找到长度 $j$ 的最优收益，我们必须对所有可能的第一刀 $i$ 进行最大化：\n\n$$R[j] = \\max_{1 \\le i \\le j} (P_i + R[j-i])$$\n\n这个递推关系使我们能够以自底向上的方式计算从1到 $L$ 所有长度的最大收益。\n\n**所有最优切割方案的重构**\n\n该任务不仅要求最大收益，还要求所有能实现该收益的唯一切割方案。为了实现这一点，我们的动态规划状态必须存储比单个数值更多的信息。我们将 $S[j]$ 定义为长度为 $j$ 的杆的所有最优频率向量的集合。一个频率向量 $\\mathbf{c} = (c_1, c_2, \\dots, c_L)$ 代表一个包含 $c_i$ 个长度为 $i$ 的段的方案。\n\n这些方案集合的状态转移如下：对于给定的长度 $j$，在计算出最优收益 $R[j]$ 后，我们识别出所有能得到此收益的第一刀 $i$，即所有满足 $P_i + R[j-i] = R[j]$ 的 $i \\in \\{1, \\dots, j\\}$。\n\n对于每个这样的最优第一刀 $i$，我们考虑长度为 $j-i$ 的剩余子问题的所有最优方案。设 $\\mathbf{c'} = (c'_1, \\dots, c'_L)$ 是集合 $S[j-i]$ 中的一个最优频率向量。通过向该方案中添加一段长度为 $i$ 的切割段，我们为长度 $j$ 形成了一个新方案。相应的新频率向量 $\\mathbf{c} = (c_1, \\dots, c_L)$ 通过将 $\\mathbf{c'}$ 的第 $i$ 个分量加一得到，即 $c_i = c'_i + 1$ 且对于 $k \\ne i$ 有 $c_k = c'_k$。\n\n集合 $S[j]$ 是由所有最优第一刀 $i$ 和 $S[j-i]$ 中所有相应的最优子方案生成的所有新方案的并集。为 $S[j]$ 使用集合数据结构可以自然地处理因不同切割顺序（例如，切割 $1+2$ 与 $2+1$）而可能产生的重复方案的消除。\n\n**算法流程**\n\n1.  处理 $L=0$ 的基本情况。根据问题描述，最大收益为 $R^\\star=0$，且只有一个最优方案，即空频率向量。\n2.  对于 $L0$，初始化一个大小为 $L+1$ 的数组 $R$ 用于存储收益，以及一个大小为 $L+1$ 的集合列表 $S$ 用于存储方案。\n3.  设置动态规划的基本情况：$R[0] = 0$，且 $S[0]$ 包含一个全零的频率向量，代表长度为0的杆的“空”切割集合。\n4.  从 $1$ 到 $L$ 迭代 $j$：\n    a. 使用已计算出的值 $R[0], \\dots, R[j-1]$，通过应用递推关系确定最大收益 $R[j]$。\n    b. 为 $S[j]$ 初始化一个空集合。\n    c. 遍历从 $1$ 到 $j$ 的所有可能的第一刀 $i$。\n    d. 如果切割 $i$ 是最优的（即 $P_i + R[j-i] = R[j]$），则遍历 $S[j-i]$ 中的每个方案 $\\mathbf{c'}$。对于每个 $\\mathbf{c'}$，通过添加一段长度为 $i$ 的切割段来构造一个新方案 $\\mathbf{c}$，并将其添加到集合 $S[j]$ 中。\n5.  循环完成后，原始问题的最大收益是 $R[L]$。所有最优切割方案的集合是 $S[L]$。\n6.  为满足输出规范，将集合 $S[L]$ 转换为列表，并将其元素（频率向量）按字典序排序。最后，构建指定的整数列表格式。\n\n这种基于动态规划的算法系统地探索解空间，基于贝尔曼原理保证了最优性，并正确地重构了所有唯一的最优解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_optimal_cuts(P, L):\n    \"\"\"\n    Calculates the maximum revenue and all optimal cutting patterns for a given rod length and price table.\n    \"\"\"\n    if L == 0:\n        # As per the problem spec, L=0 has R*=0, K=1, and an empty frequency vector.\n        return [0, 1]\n\n    # prices P is a list/tuple where P[i] is the price for length i+1.\n    \n    # dp_rev[j] will store the maximum revenue for a rod of length j.\n    dp_rev = np.zeros(L + 1, dtype=int)\n    \n    # dp_patterns[j] will store a set of all optimal pattern vectors (as tuples) for length j.\n    dp_patterns = [set() for _ in range(L + 1)]\n\n    # Base case for a rod of length 0 within a larger problem of length L  0.\n    # The pattern is a frequency vector of L zeros.\n    dp_patterns[0].add(tuple([0] * L))\n\n    # Bottom-up DP to fill the tables.\n    for j in range(1, L + 1):\n        # First pass: find the maximum possible revenue for length j.\n        max_rev = -1\n        for i in range(1, j + 1):\n            # i is the length of the first cut.\n            # Price for length i is at P[i-1].\n            # Remainder is j-i, with optimal revenue dp_rev[j-i].\n            current_rev = P[i-1] + dp_rev[j-i]\n            if current_rev  max_rev:\n                max_rev = current_rev\n        \n        dp_rev[j] = max_rev\n        \n        # Second pass: find all patterns that achieve this maximum revenue.\n        current_j_patterns = set()\n        for i in range(1, j + 1):\n            if P[i-1] + dp_rev[j-i] == max_rev:\n                # This first cut 'i' contributes to an optimal solution for length j.\n                \n                # Get all optimal patterns for the remainder piece of length j-i.\n                remainder_patterns = dp_patterns[j-i]\n                \n                for p_tuple in remainder_patterns:\n                    # p_tuple is a frequency vector (c_1, ..., c_L).\n                    # Create a new pattern by adding one piece of length i.\n                    new_pattern_list = list(p_tuple)\n                    new_pattern_list[i-1] += 1\n                    current_j_patterns.add(tuple(new_pattern_list))\n        \n        dp_patterns[j] = current_j_patterns\n\n    # Extract final results for length L.\n    R_star = dp_rev[L]\n    # Sort the patterns lexicographically as required.\n    optimal_patterns_sorted = sorted(list(dp_patterns[L]))\n    K = len(optimal_patterns_sorted)\n\n    # Format the output list as specified: [R*, K, pattern1..., pattern2...]\n    result = [R_star, K]\n    for p in optimal_patterns_sorted:\n        result.extend(p)\n        \n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: L=4, P=(1, 5, 8, 9)\n        ((1, 5, 8, 9), 4),\n        # Test case 2: L=5, P=(2, 5, 7, 8, 10)\n        ((2, 5, 7, 8, 10), 5),\n        # Test case 3: L=0, P=()\n        ((), 0),\n        # Test case 4: L=7, P=(1, 5, 8, 9, 10, 17, 17)\n        ((1, 5, 8, 9, 10, 17, 17), 7),\n        # Test case 5: L=6, P=(2, 4, 6, 8, 10, 12)\n        ((2, 4, 6, 8, 10, 12), 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        P, L = case\n        result = calculate_optimal_cuts(P, L)\n        results.append(result)\n\n    # The final print statement must produce the single-line format: [[...],[...],...]\n    # 1. Convert each inner list of integers to a string like \"[i1,i2,...]\".\n    inner_list_strs = [f\"[{','.join(map(str, res_list))}]\" for res_list in results]\n    # 2. Join these strings with commas.\n    # 3. Enclose the whole thing in brackets.\n    final_output_str = f\"[{','.join(inner_list_strs)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3267391"}]}