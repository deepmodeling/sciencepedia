{"hands_on_practices": [{"introduction": "墓碑（tombstone）机制虽然解决了删除操作的难题，但其创建和存在并非没有代价。本练习将引导你通过一个具体的场景，计算生成特定墓碑布局所需的最小探测次数。这有助于你深入理解插入和删除操作的基本成本，并思考如何以最高效的方式实现目标状态，从而建立起关于此删除策略开销的直观认识。[@problem_id:3227311]", "problem": "考虑一个使用开放寻址法和线性探测的哈希表。该表的大小为 $m=7$，槽位索引为 $0,1,2,3,4,5,6$。键是整数，哈希函数为 $h(k)=k \\bmod 7$。一次成功的删除会将删除的槽位标记为墓碑（记为 $\\dagger$），而不是将其置空；查找一个键时，从 $h(k)$ 开始，对后续索引以 7 为模进行线性探测，直到找到该键或一个空槽位为止，墓碑不会终止查找。插入一个键 $k$ 时，从 $h(k)$ 开始进行线性探测，直到找到一个空槽位或第一个墓碑，并将键存储在那里。代价模型是开放寻址法的标准模型：在查找、插入或删除过程中的每次槽位检查计为一次探测。\n\n从一个空表开始，你可以选择任何整数键并执行任意的插入和删除操作序列。你的目标是达到一个最终状态，在该状态下，表中恰好在槽位 $2$、$4$ 和 $6$ 处有墓碑，所有其他槽位均为空，且表中没有剩余的活动键。在上述规则下，要达到这样的最终状态，整个操作序列所需的最小总槽位检查（探测）次数是多少？请给出一个精确的整数答案，不带单位。", "solution": "问题要求将一个大小为 $m=7$ 的空哈希表转换到一个在槽位 $2$、$4$ 和 $6$ 处有墓碑，而所有其他槽位均为空的状态，所需的最小总槽位检查（探测）次数。该哈希表使用开放寻址法和线性探测，哈希函数为 $h(k) = k \\bmod 7$。\n\n首先，我们来分析创建一个墓碑的过程。在一个槽位 $i$ 创建一个墓碑，需要先将一个键插入该槽位，然后删除同一个键。这至少需要一个插入操作和一个删除操作。\n\n任何操作（插入、查找或删除）的代价定义为检查的槽位数。由于每个操作都必须检查至少一个槽位，因此任何单个操作的代价至少为 $1$。因此，创建一个墓碑的最小代价至少是 $1$（用于插入）$+ 1$（用于删除）$= 2$ 次探测。\n\n我们的目标是在槽位 $2$、$4$ 和 $6$ 创建三个不同的墓碑。由于每个墓碑的创建至少需要两次探测，并且创建一个墓碑的操作不会消除创建另一个墓碑所需的操作，因此创建三个墓碑的总探测次数必须至少为 $3 \\times 2 = 6$。这就确定了总代价的一个下界。\n\n现在，我们必须确定这个 $6$ 次探测的下界是否可以达到。为此，我们需要构造一个操作序列，该序列能达到目标状态，且总代价恰好为 $6$。总代价为 $6$ 要求三次必要的插入和三次必要的删除中的每一次都恰好花费 $1$ 次探测。\n\n我们来分析一次插入和一次删除的代价。\n插入一个键 $k$ 的代价是从索引 $h(k)$ 开始探测的槽位数，直到找到一个可用槽位。可用槽位被定义为空槽位或第一个包含墓碑的槽位。如果索引 $h(k)$ 处的槽位本身就是可用的，则代价可以最小化为 $1$。\n删除驻留在槽位 $i$ 的键 $k$ 的代价是从 $h(k)$ 开始探测直到到达槽位 $i$ 的槽位数。如果放置键 $k$ 时满足 $h(k)=i$，则代价可以最小化为 $1$。\n\n为了使在槽位 $i$ 创建墓碑的插入和删除操作代价都为 $1$，我们应该选择一个键 $k$ 使得 $h(k)=i$。让我们基于这个原则设计一个操作序列。我们需要在槽位 $i_1=2$，$i_2=4$ 和 $i_3=6$ 创建墓碑。\n\n我们可以选择三个不同的键 $k_1, k_2, k_3$，使其哈希值对应于期望的墓碑位置。我们选择 $k_1=2$，$k_2=4$ 和 $k_3=6$。\n$h(k_1) = 2 \\bmod 7 = 2$\n$h(k_2) = 4 \\bmod 7 = 4$\n$h(k_3) = 6 \\bmod 7 = 6$\n\n考虑以下操作序列，从一个空表开始。\n\n1.  **插入键 $k_1=2$**：探测从 $h(2)=2$ 开始。槽位 $2$ 是空的。键 $2$ 被放置在槽位 $2$。\n    探测次数：$1$。\n    表状态：`[ , , 2, , , , ]`。\n    累计探测次数：$1$。\n\n2.  **插入键 $k_2=4$**：探测从 $h(4)=4$ 开始。槽位 $4$ 是空的。键 $4$ 被放置在槽位 $4$。\n    探测次数：$1$。\n    表状态：`[ , , 2, , 4, , ]`。\n    累计探测次数：$1+1=2$。\n\n3.  **插入键 $k_3=6$**：探测从 $h(6)=6$ 开始。槽位 $6$ 是空的。键 $6$ 被放置在槽位 $6$。\n    探测次数：$1$。\n    表状态：`[ , , 2, , 4, , 6]`。\n    累计探测次数：$2+1=3$。\n\n此时，所有必要的键都已在表中。现在我们删除它们以创建墓碑。\n\n4.  **删除键 $k_1=2$**：查找从 $h(2)=2$ 开始。在第一个被探测的槽位，即索引 $2$ 处，找到键 $2$。该槽位被标记为墓碑（$\\dagger$）。\n    探测次数：$1$。\n    表状态：`[ , , †, , 4, , 6]`。\n    累计探测次数：$3+1=4$。\n\n5.  **删除键 $k_2=4$**：查找从 $h(4)=4$ 开始。在槽位 $4$ 找到键 $4$。该槽位被标记为墓碑。\n    探测次数：$1$。\n    表状态：`[ , , †, , †, , 6]`。\n    累计探测次数：$4+1=5$。\n\n6.  **删除键 $k_3=6$**：查找从 $h(6)=6$ 开始。在槽位 $6$ 找到键 $6$。该槽位被标记为墓碑。\n    探测次数：$1$。\n    表状态：`[ , , †, , †, , †]`。\n    累计探测次数：$5+1=6$。\n\n表的最终状态是在槽位 $2$、$4$ 和 $6$ 有墓碑，而所有其他槽位（$0, 1, 3, 5$）保持为空。这完全符合问题的要求。此序列的总探测次数为 $6$。\n\n既然我们已经确定了 $6$ 次探测的下界，并展示了一个实现此代价的操作序列，那么最小总探测次数必定是 $6$。任何其他键的选择或操作顺序都不可能导致更低的代价。例如，使用一个哈希到与其最终位置 $i$ 不同的值（即 $h(k) \\neq i$）的键 $k$，将导致插入（由于冲突或槽位已被占用）和删除的探测次数都大于 $1$，从而增加总代价。特定的插入规则（在第一个墓碑处停止）不会改变这个最优策略，因为最小代价路径涉及向空槽位中插入。", "answer": "$$\\boxed{6}$$", "id": "3227311"}, {"introduction": "从单个墓碑的创建成本出发，我们进一步探讨它们的累积效应。虽然墓碑解决了删除问题，但过多的墓碑会严重降低哈希表的性能，甚至导致插入操作完全失败。本练习要求你推导出在使用二次探测的哈希表中，能够保证新元素成功插入所能容忍的最大墓碑数量。这将促使你将墓碑密度的概念与探测序列的数学性质联系起来，理解其性能极限。[@problem_id:3227267]", "problem": "一个大小为 $m$ 的哈希表使用开放定址法，其二次探测序列定义为\n$$\nh(k,i) \\equiv \\big(h(k,0) + i^2\\big) \\bmod m \\quad \\text{for } i=0,1,2,\\dots,\n$$\n其中 $m$ 是一个奇素数，且 $h(k,0) \\in \\{0,1,\\dots,m-1\\}$ 是键 $k$ 的基地址。删除操作通过在被删除的单元格中放置一个墓碑（tombstone）来实现。在搜索过程中，墓碑被视作已占用（探测会继续），而在插入过程中，实现只向真正为空的单元格中插入；在执行周期性重建之前，墓碑单元格不会被重用。\n\n假设在某个时刻，表中恰好有 $T$ 个墓碑和 $m-T$ 个真正为空的单元格（没有活动的键）。一个键 $k$ 的插入操作当且仅当其探测序列遇到至少一个真正为空的单元格时才会成功。\n\n请从第一性原理出发，推导出最大的整数 $T_{\\max}(m)$，使得无论这 $T_{\\max}(m)$ 个墓碑如何放置在表中，也无论插入哪个键（即，对于任何基地址 $h(k,0)$），插入操作都保证成功。你的最终答案必须是一个关于 $m$ 的封闭形式表达式，并且不得包含不等式或方程式。", "solution": "问题要求我们找出最大的整数 $T_{\\max}(m)$，它代表墓碑的数量，使得无论这 $T_{\\max}(m)$ 个墓碑如何放置，也无论待插入键的初始哈希值是多少，向一个大小为 $m$ 的哈希表中插入的操作都保证成功。\n\n插入操作失败，当且仅当待插入键的探测序列完全由被墓碑占据的位置组成。如果一个探测序列不可能完全由墓碑组成，那么插入操作就保证成功。\n\n哈希表使用开放定址法和二次探测。表的大小为 $m$，它是一个奇素数。对于一个基地址为 $h(k,0) = h_0$ 的键 $k$，其探测序列由以下索引序列定义：\n$$h(k,i) = (h_0 + i^2) \\bmod m, \\quad \\text{for } i=0, 1, 2, \\dots$$\n令 $S_{h_0}$ 为此探测序列访问过的不同表索引的集合。访问的位置由添加到基地址 $h_0$ 的偏移量集合 $\\{i^2 \\bmod m\\}$ 决定。我们必须首先确定这个集合的大小，即 $|S_{h_0}|$。\n\n$S_{h_0}$ 的大小等于 $(h_0 + i^2) \\bmod m$ 的不同值的数量。由于加上 $h_0$ 并对 $m$ 取模只是对索引的循环移位，因此访问位置集合的大小等于唯一偏移值集合 $\\{i^2 \\bmod m \\text{ for } i=0, 1, 2, \\dots\\}$ 的大小。\n\n我们来计算当 $i \\in \\{0, 1, \\dots, m-1\\}$ 时 $i^2 \\bmod m$ 的不同值的数量。\n1. 对于 $i=0$，我们有 $0^2 \\equiv 0 \\pmod m$。这给出了一个唯一的值。\n2. 对于 $i \\in \\{1, 2, \\dots, m-1\\}$，我们研究两个平方在模 $m$ 下何时同余。令 $x, y \\in \\{1, 2, \\dots, m-1\\}$。同余式 $x^2 \\equiv y^2 \\pmod m$ 等价于 $x^2 - y^2 \\equiv 0 \\pmod m$，可以因式分解为 $(x-y)(x+y) \\equiv 0 \\pmod m$。\n因为 $m$ 是一个素数，这意味着 $m$ 必须整除 $(x-y)$ 或 $m$ 必须整除 $(x+y)$。\n- 如果 $m | (x-y)$，因为 $x, y \\in \\{1, \\dots, m-1\\}$，那么必然有 $x=y$。\n- 如果 $m | (x+y)$，因为 $2 \\le x+y \\le 2(m-1)$，那么必然有 $x+y=m$ 或 $x+y=2m$。后者只有在 $x=y=m$ 时才可能，但这不在我们的范围内。所以，$x+y=m$。\n\n这意味着对于任何 $x \\in \\{1, \\dots, m-1\\}$，它的平方 $x^2 \\pmod m$ 与 $y=m-x$ 的平方相同，因为 $(m-x)^2 = m^2 - 2mx + x^2 \\equiv x^2 \\pmod m$。\n非零值 $\\{1, \\dots, m-1\\}$ 可以被划分为 $(m-1)/2$ 个形式为 $\\{x, m-x\\}$ 的数对。例如，$\\{1, m-1\\}, \\{2, m-2\\}, \\dots, \\{ (m-1)/2, (m+1)/2 \\}$。每个数对中的所有元素在模 $m$ 下产生相同的平方值。\n对于 $x \\in \\{1, 2, \\dots, (m-1)/2\\}$， $x$ 的平方在模 $m$ 下都是不同的。如果对于 $1 \\le y  x \\le (m-1)/2$ 有 $x^2 \\equiv y^2 \\pmod m$，那么 $y-x \\not\\equiv 0 \\pmod m$ 且 $y+x \\not\\equiv 0 \\pmod m$，因为 $2  x+y  m-1  m$，这导致了矛盾。\n因此，对于 $i^2 \\pmod m$ 恰好有 $(m-1)/2$ 个不同的非零值。这些是模 $m$ 的二次剩余。\n\n将来自 $i=0$ 的单个值 $0$ 与 $(m-1)/2$ 个非零值结合起来， $i^2 \\pmod m$ 的不同偏移量的总数为 $1 + \\frac{m-1}{2} = \\frac{m+1}{2}$。\n因此，对于奇素数模 $m$ 的二次探测，任何探测序列都会恰好访问 $|S_{h_0}| = \\frac{m+1}{2}$ 个不同的单元格。\n\n如果对于任意 $T$ 个墓碑的放置方式和任意起始哈希值 $h_0$，探测序列 $S_{h_0}$ 都不是墓碑位置集合的子集，则插入操作保证成功。表中只包含墓碑和空单元格。如果探测序列中的一个位置不是墓碑，那么它必定为空，插入操作就会成功。\n\n设 $N_S = \\frac{m+1}{2}$ 为任何探测序列中的单元格数量。\n设 $T$ 为表中的墓碑数量。\n要使插入失败，其探测序列中的所有 $N_S$ 个单元格都必须被墓碑占据。这只有在墓碑数量至少等于探测序列中单元格数量时才可能，即 $T \\ge N_S$。\n\n反之，如果墓碑数量 $T$ 严格小于任何探测序列中的单元格数量，即 $T  N_S$，那么一个探测序列的所有单元格就不可能都是墓碑。根据鸽巢原理，如果一个探测序列访问 $N_S$ 个不同的单元格，而表中只有 $T  N_S$ 个墓碑，那么访问到的单元格中至少有一个不能是墓碑。由于表中没有其他键，这个单元格必定为空。因此，插入操作保证成功。\n\n保证成功的条件是 $T  \\frac{m+1}{2}$。\n由于 $T$ 必须是一个整数，满足此不等式的最大整数 $T$ 是\n$$T = \\left\\lfloor \\frac{m+1}{2} - \\epsilon \\right\\rfloor$$\n其中 $\\epsilon$ 是一个无穷小的正数。由于 $m$ 是一个奇素数，$m+1$ 是一个偶数，所以 $\\frac{m+1}{2}$ 是一个整数。严格小于 $\\frac{m+1}{2}$ 的最大整数是 $\\frac{m+1}{2} - 1$。\n$$T_{\\max}(m) = \\frac{m+1}{2} - 1 = \\frac{m+1-2}{2} = \\frac{m-1}{2}$$\n\n为了确认这是最大可能值，我们必须证明当 $T = T_{\\max}(m) + 1$ 时，成功不是必然的。\n令 $T = \\frac{m-1}{2} + 1 = \\frac{m+1}{2}$。\n有了这么多墓碑，我们可以构造一个插入失败的场景。选择一个任意的基地址，比如 $h_0=0$。探测序列 $S_0$ 访问 $\\frac{m+1}{2}$ 个不同的单元格。我们可以将 $T = \\frac{m+1}{2}$ 个墓碑精确地放置在这 $\\frac{m+1}{2}$ 个位置上。然后，对于一个 $h(k,0)=0$ 的键 $k$ 进行插入将会失败，因为它的整个探测序列都由墓碑组成。\n因为当 $T=\\frac{m+1}{2}$ 时，存在一种墓碑的放置方式和一个键的选择，使得插入失败，所以对于这个 $T$ 值，成功不是必然的。\n\n因此，保证插入成功的最大整数 $T_{\\max}(m)$ 是 $\\frac{m-1}{2}$。", "answer": "$$\\boxed{\\frac{m-1}{2}}$$", "id": "3227267"}, {"introduction": "墓碑并非解决开放寻址删除问题的唯一方案。本练习将介绍一种完全不使用墓碑的替代方法——“回填式删除”（backward-shift deletion）。你的任务是逆向工程，判断一个给定的哈希表最终状态是否可以通过此方法达到。这需要你理解该删除算法的核心不变量：删除部分元素后的最终表，等同于这些被删除的元素从未被插入过的结果。通过这个练习，你不仅能掌握一种新的删除策略，还能加深对数据结构不变量重要性的理解。[@problem_id:3227225]", "problem": "给定一个使用开放定址法和线性探测法的哈希表。该表长度为 $m$，存储不重复的整数键。哈希函数为 $h(k) = k \\bmod m$。算法规则如下：\n- 插入：要插入一个键 $k$，从槽位 $h(k), h(k)+1, \\dots$ 开始探测（按模 $m$ 回绕），直到找到第一个空槽位，并将 $k$ 放置在那里。不使用墓碑标记。空槽位由一个特殊的哨兵值表示，该值不是有效的键。\n- 删除：删除操作是用于线性探测的后向移位删除（有时称为“填补空隙”）：在删除位置 $i$ 的键时，会连续地遍历该簇，将每个后续被占用的键向后移动一个槽位，直到遇到一个空槽位，从而确保搜索不变量得以保持。\n\n基本原理：\n- 一个采用开放定址法和线性探测的哈希表，会将键 $k$ 存储在探测序列 $h(k), h(k)+1, \\dots$（按模 $m$ 计算）中遇到的第一个可用槽位上。\n- 后向移位删除为所有剩余的键维持了线性探测的搜索不变量。\n\n任务：\n- 对于每个测试用例，给定整数 $m$ 和一个由不重复键组成的序列 $I$。从一个空表开始，通过按 $I$ 中出现的顺序使用线性探测插入这些键来构建哈希表。然后，执行一系列使用后向移位删除的删除操作，得到一个指定的最终配置 $F$，其中一些槽位为空，一些包含键。\n- 仅给定 $m$、插入顺序 $I$ 和最终配置 $F$，请确定在所述算法下，从按顺序插入 $I$ 形成的表中生成 $F$ 所必须发生的最少删除次数。如果无法通过任何使用后向移位删除的序列从初始表得到 $F$，则输出 $-1$。\n\n表示方法：\n- 最终配置 $F$ 是一个长度为 $m$ 的列表，其中每个条目要么是存储在该槽位的整数键，要么是空哨兵。空哨兵是整数 $-1$。\n\n形式化要求：\n- 设 $I = \\langle i_1, i_2, \\dots, i_n \\rangle$ 是不重复的已插入键的序列。设 $F$ 是长度为 $m$ 的最终数组，其条目在 $\\{-1\\} \\cup \\mathbb{Z}_{\\ge 0}$ 中，其中 $-1$ 表示空槽位，所有非负整数表示键。设 $S$ 是出现在 $F$ 中的所有键的集合。你的程序必须：\n  - 验证 $F$ 的每个非空条目都是 $I$ 的元素，并且 $F$ 中没有键出现超过一次。\n  - 通过将 $S$ 中的键，以它们在 $I$ 中出现时的相同相对顺序（即，将 $I$ 稳定地筛选出 $S$ 中的键），使用线性探测插入到一个大小为 $m$ 的空表中，来构建候选表 $C$。\n  - 如果 $C = F$，则返回 $|I| - |S|$ 作为最少删除次数。否则，返回 $-1$。\n\n需要在你的解决方案中推导出的基本原理：\n- 在线性探测的后向移位删除机制下，删除一部分键并填补空隙，其结果与从未插入这些被删除的键所得到的最终表相同，同时保留了剩余键在探测路径上的相对顺序。因此，最少删除次数等于存在于 $I$ 中但不存在于 $F$ 中的键的数量，前提是 $F$ 与仅按原始相对顺序插入剩余键所构建的表相匹配。\n\n测试套件：\n对于下述每个测试用例，$m$、$I$ 和 $F$ 均已给定。空哨兵是 $-1$。\n\n- 测试用例 1：\n  - $m = 11$\n  - $I = [10, 21, 32, 43]$\n  - $F = [43, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10]$\n  - 预期最少删除次数：整数结果。\n\n- 测试用例 2：\n  - $m = 11$\n  - $I = [10, 21, 32, 43]$\n  - $F = [10, -1, 43, -1, -1, -1, -1, -1, -1, -1, -1]$\n  - 这种排列旨在通过从插入 $I$ 开始的任何后向移位删除序列都无法实现。\n  - 预期输出：$-1$。\n\n- 测试用例 3：\n  - $m = 7$\n  - $I = [14, 21, 28]$\n  - $F = [-1, -1, -1, -1, -1, -1, -1]$\n\n- 测试用例 4：\n  - $m = 13$\n  - $I = [18, 41, 22, 44, 59]$\n  - 使用线性探测插入 $I$ 后，表的状态为：\n    - 槽位 $2 \\leftarrow 41$, 槽位 $5 \\leftarrow 18$, 槽位 $6 \\leftarrow 44$, 槽位 $7 \\leftarrow 59$, 槽位 $9 \\leftarrow 22$, 所有其他槽位为空。\n  - $F = [-1, -1, 41, -1, -1, 18, 44, 59, -1, 22, -1, -1, -1]$\n\n- 测试用例 5：\n  - $m = 5$\n  - $I = [0, 5, 10, 15]$\n  - $F = [5, 15, -1, -1, -1]$\n\n- 测试用例 6：\n  - $m = 7$\n  - $I = [1, 8, 15]$\n  - $F = [-1, 1, 22, -1, -1, -1, -1]$ 其中 22 从未被插入。\n\n- 测试用例 7：\n  - $m = 7$\n  - $I = [3, 10, 17]$\n  - $F = [-1, -1, -1, 3, 3, -1, -1]$ 其中包含一个重复的键。\n\n你的程序应生成单行输出，其中包含上述案例的结果，格式为一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”）。每个结果都必须是一个整数，用 $-1$ 表示不可能实现。", "solution": "我们从开放定址法、线性探测以及后向移位删除操作的基本定义开始。\n\n设 $m \\in \\mathbb{Z}_{0}$ 为表长，设 $h(k) = k \\bmod m$ 为键 $k \\in \\mathbb{Z}$ 的哈希函数。线性探测将 $k$ 的探测序列定义为循环序列 $h(k), h(k)+1, h(k)+2, \\dots$（按模 $m$ 计算）。插入操作将 $k$ 放置在该序列中遇到的第一个空槽位上。在位置 $i$ 上的后向移位删除会移除该位置的键，然后重复地将后续被占用的条目向后移动一步以填补空隙，直到遇到一个空槽位。其保持的不变量是，对于每个保留下来的键 $x$，从 $h(x)$ 开始并遵循线性探测序列的搜索，将在遇到空槽位之前找到 $x$。\n\n原理和关键属性：\n- 考虑一个由不重复键组成的序列 $I = \\langle i_1, i_2, \\dots, i_n \\rangle$，这些键使用线性探测被插入到一个初始为空、长度为 $m$ 的表中。设 $S \\subseteq \\{i_1,\\dots,i_n\\}$ 是在执行后向移位删除后保留下来的键的子集。可以从线性探测不变量的维持和后向移位删除的定义中推导出的关键属性是：最终只包含集合 $S$ 中键的表，与仅将 $S$ 中的键按其在 $I$ 中的相同相对顺序（即，在保持顺序的同时将 $I$ 筛选为 $S$）使用线性探测插入到一个空表中所产生的表是相同的。直观地说，每次删除都会产生一个空隙，该空隙立即通过将后续的键向后移动一个位置来填补，同时保持探测序列上的可达性；对任何删除集合重复此过程，等同于从未插入那些被删除的键，因为所有剩余的键继续占据其探测路径上最早的可用位置，并且它们的相对插入顺序通过局部的后向移位得以保留。\n\n推导纲要：\n- 基本事实：对于不使用墓碑标记的线性探测，键 $k$ 的位置取决于其探测路径上直至其最终位置的所有槽位的占用情况。如果占据较早槽位的某些键不存在，$k$ 将占据其路径上最早的可用槽位。\n- 后向移位删除通过填补空隙来模拟键的移除，并重新确立每个剩余的键都位于其探测路径上最早的可用槽位。由于移位是局部的，并且只将键向后移动到其探测路径上更早的位置，因此由原始插入顺序施加在探测序列上的键的相对顺序得以保留。这可以通过对删除次数进行归纳来证明：移除一个键并填补空隙，得到的表与按原始相对顺序插入除被移除键之外的所有键得到的表完全相同；如果这个结论对于 $t$ 次删除成立，那么将其应用于第 $(t+1)$ 次删除时，等价性仍然保持。\n\n对决策问题的影响：\n- 假设我们给定 $m$、包含 $n$ 个不重复键的原始插入序列 $I$，以及一个声称的最终配置 $F$（一个长度为 $m$ 的数组，使用空哨兵表示空槽位）。设 $S$ 是 $F$ 中的键集合。如果 $F$ 可以通过从插入 $I$ 构建的表中删除某些键得到，那么 $F$ 必须等于仅按 $I$ 中的相对顺序插入 $S$ 中的键所得到的表。如果不是，则不存在任何后向移位删除序列可以从插入 $I$ 得到 $F$。\n- 此外，如果 $F$ 是可实现的，那么最少的删除次数恰好是 $|I| - |S|$，因为每个被删除的键必须对应于 $I$ 中一个不存在于 $F$ 中的不重复键，反之，精确删除这 $|I| - |S|$ 个键并使用后向移位删除，将产生上述论证的、对于 $S$ 的唯一可实现的最终排列。少于这个次数的删除无法一次性移除多个键，也不需要多余的删除操作。\n\n算法：\n- 一个测试用例的输入参数：$m$、$I$ 和 $F$。\n- 步骤 1：验证 $F$ 的所有非空条目都是不重复的，并且都属于 $I$。如果 $F$ 中有任何键不在 $I$ 中，或者 $F$ 中出现重复键，或者 $|F| \\neq m$，则返回 $-1$。\n- 步骤 2：设 $S$ 是通过将 $I$ 稳定地筛选出出现在 $F$ 中的那些键而形成的序列（保留它们在 $I$ 中的顺序）。通过将 $S$ 中的键使用线性探测插入到一个长度为 $m$ 的空表中，来构建一个候选表 $C$。\n- 步骤 3：如果 $C = F$，则输出 $|I| - |S|$；否则，输出 $-1$。\n\n正确性证明：\n- 根据从后向移位删除不变量推导出的属性，如果存在任何删除序列可以产生 $F$，那么 $F$ 必须等于 $C$。反之，如果 $F = C$，那么精确删除 $I \\setminus S$ 中的键并使用后向移位删除操作即可产生 $F$。因此，该决策是充分且必要的，最少删除次数恰好是被移除键的数量。\n\n复杂度：\n- 构建 $C$ 在每个测试中最多需要 $O(m \\cdot |S|)$ 时间（在最坏情况下，每次插入最多执行 $m$ 次探测），但在负载适中时平均次数较少。验证和比较的时间复杂度是 $m$ 的线性函数。\n\n将算法应用于测试套件：\n- 测试用例 1：$m = 11$， $I = [10,21,32,43]$，$F$ 在索引 $10$ 和 $0$ 分别放置了键 $\\{10,43\\}$。将 $I$ 筛选为 $S = [10,43]$ 并插入，恰好得到 $F$。最少删除次数 $= 4 - 2 = 2$。\n- 测试用例 2：相同的 $m$ 和 $I$，$F$ 将 $10$ 放在索引 $0$ 处，将 $43$ 放在索引 $2$ 处。插入 $S = [10,43]$ 会将 $10$ 放在索引 $10$ 处，将 $43$ 放在索引 $0$ 处，这与 $F$ 不匹配，因此输出 $-1$。\n- 测试用例 3：$m = 7$，$I = [14,21,28]$，$F$ 全部为空。$S = []$，所以最少删除次数 $= 3 - 0 = 3$ 且 $C = F$。\n- 测试用例 4：$m = 13$，$I = [18,41,22,44,59]$，$F$ 等于插入 $I$ 后立即得到的表。因此 $S = I$，最少删除次数 $= 0$。\n- 测试用例 5：$m = 5$，$I = [0,5,10,15]$，$F = [5,15,-1,-1,-1]$。$S = [5,15]$，插入 $S$ 得到 $F$。最少删除次数 $= 4 - 2 = 2$。\n- 测试用例 6：$m = 7$，$I = [1,8,15]$，$F$ 包含键 $22 \\notin I$，因此为 $-1$。\n- 测试用例 7：$m = 7$，$I = [3,10,17]$，$F$ 包含重复的键 $3$，因此为 $-1$。\n\n最终输出应为单行，包含七个测试用例的有序结果，形式为方括号括起来的逗号分隔整数列表。", "answer": "[2,-1,3,0,2,-1,-1]", "id": "3227225"}]}