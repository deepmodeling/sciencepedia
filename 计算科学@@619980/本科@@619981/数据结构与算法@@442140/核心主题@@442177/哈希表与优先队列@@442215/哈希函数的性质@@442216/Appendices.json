{"hands_on_practices": [{"introduction": "理论学习的最终目的是应用于实践。要真正理解哈希函数的性质，最好的方法莫过于亲手分析和实现它们。本节的第一个练习将带你回到哈希函数最核心的功能：将庞大的键空间映射到有限的哈希值域。在这个练习中，你的任务是计算在给定范围内，有多少输入对 $(x,y)$ 会映射到同一个特定的哈希值 [@problem_id:3261635]。这不仅是对“冲突”概念的直接量化，更重要的是，它将促使你运用模运算的性质来设计一个高效的算法，从而避免暴力枚举，深刻体会哈希函数背后的数学原理。", "problem": "考虑哈希函数 $h: \\mathbb{Z} \\times \\mathbb{Z} \\to \\{0,1,\\dots,m-1\\}$，其定义为 $h(x,y) = (x^2 + y) \\bmod m$，其中 $m$ 是一个给定的正整数。对于一个固定的目标哈希值 $v \\in \\{0,1,\\dots,m-1\\}$，其原像集包含所有满足 $x \\in [X_{\\min}, X_{\\max}]$、$y \\in [Y_{\\min}, Y_{\\max}]$ 以及 $x^2 + y \\equiv v \\pmod{m}$ 的整数对 $(x,y)$。请仅从哈希函数、模 $m$ 同余和整数区间的正式定义出发，推导出一个基于原理的方法，以确定对于任何有效的参数集，存在多少个这样的数对。对于每个提供的测试用例，你的程序必须计算在指定范围内，通过函数 $h$ 映射到 $v$ 的数对 $(x,y)$ 的总数。\n\n所有量均为整数。假设 $m \\geq 1$ 且 $X_{\\min} \\leq X_{\\max}$ 和 $Y_{\\min} \\leq Y_{\\max}$。你的程序不得显式枚举所有数对，除非推导过程证明此法可行；程序必须基于从模运算的核心定义和性质推导出的逻辑。要求的输出是表示每个测试用例此类数对数量的整数。\n\n测试套件：\n- 用例 1：$m = 7$，$v = 3$，$X_{\\min} = 0$，$X_{\\max} = 20$，$Y_{\\min} = 0$，$Y_{\\max} = 30$。\n- 用例 2：$m = 1$，$v = 0$，$X_{\\min} = -5$，$X_{\\max} = 5$，$Y_{\\min} = -5$，$Y_{\\max} = 5$。\n- 用例 3：$m = 13$，$v = 0$，$X_{\\min} = 0$，$X_{\\max} = 100$，$Y_{\\min} = 0$，$Y_{\\max} = 100$。\n- 用例 4：$m = 9$，$v = 4$，$X_{\\min} = -20$，$X_{\\max} = -1$，$Y_{\\min} = -30$，$Y_{\\max} = -10$。\n- 用例 5：$m = 8$，$v = 7$，$X_{\\min} = 0$，$X_{\\max} = 50$，$Y_{\\min} = 3$，$Y_{\\max} = 3$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含以上述用例顺序排列的结果，形式为用方括号括起来的逗号分隔列表。例如，如果五个用例的结果是 $a_1, a_2, a_3, a_4, a_5$，则输出必须严格符合 $[a_1,a_2,a_3,a_4,a_5]$ 的格式。", "solution": "该问题定义明确、数学上合理且内容自洽。它基于数论的既定原理（特别是模运算）以及与哈希函数相关的计算机科学概念。所有给定的参数都有清晰的定义，约束条件也是一致的。因此，该问题被认为是有效的，并且可以推导出一种形式化的解法。\n\n目标是对于给定的整数 $m, v, X_{\\min}, X_{\\max}, Y_{\\min}, Y_{\\max}$，找到满足以下三个条件的整数对 $(x,y)$ 的数量：\n1.  $x \\in [X_{\\min}, X_{\\max}]$\n2.  $y \\in [Y_{\\min}, Y_{\\max}]$\n3.  $h(x,y) = (x^2 + y) \\bmod m = v$\n\n第三个条件可以使用模 $m$ 同余的定义来表示：\n$$x^2 + y \\equiv v \\pmod{m}$$\n这个同余式可以整理以分离出变量 $y$：\n$$y \\equiv v - x^2 \\pmod{m}$$\n一种朴素的方法是遍历指定矩形域中的所有可能的数对 $(x,y)$，并检查同余式是否成立。然而，如果 $x$ 和 $y$ 的范围很大，这种方法的计算成本会非常高。题目描述本身就表明需要一种更具原则性的、基于模运算的方法。\n\n一个更有效的策略是遍历其中一个变量（比如 $x$）的值，并对每个 $x$ 计算有效的 $y$ 值的数量。一个关键的观察是，对 $y$ 的约束条件仅通过 $x^2 \\pmod{m}$ 的值与 $x$ 相关。\n\n假设 $x_1$ 和 $x_2$ 是两个整数，满足 $x_1 \\equiv x_2 \\pmod{m}$。那么 $x_1^2 \\equiv x_2^2 \\pmod{m}$。因此，对于 $x_1$ 和 $x_2$，$y$ 所需满足的同余式是相同的：\n$$y \\equiv v - x_1^2 \\pmod{m} \\implies y \\equiv v - x_2^2 \\pmod{m}$$\n这一洞见使我们能够将区间 $[X_{\\min}, X_{\\max}]$ 内的所有整数 $x$ 按其模 $m$ 的剩余类进行分组。对于任何属于给定剩余类 $r \\in \\{0, 1, \\dots, m-1\\}$ 的 $x$（其中 $x \\equiv r \\pmod{m}$），$y$ 所需的余数是相同的。设 $y$ 所需的这个余数为 $c_r$：\n$$c_r = (v - r^2) \\pmod{m}$$\n问题现在简化为两个主要步骤：\n1.  对于每个剩余类 $r \\in \\{0, 1, \\dots, m-1\\}$，确定在区间 $[Y_{\\min}, Y_{\\max}]$ 内满足 $y \\equiv c_r \\pmod{m}$ 的整数 $y$ 的数量。\n2.  对于每个剩余类 $r$，确定在区间 $[X_{\\min}, X_{\\max}]$ 内满足 $x \\equiv r \\pmod{m}$ 的整数 $x$ 的数量。\n\n总数对数量是这两个计数乘积对所有剩余类 $r$ 的总和。\n让我们将此计数方法形式化。我们需要一个函数来计算区间 $[A, B]$ 中与 $c \\pmod{m}$ 同余的整数数量。一个整数 $z$ 满足 $z \\equiv c \\pmod{m}$ 当且仅当 $z-c$ 是 $m$ 的倍数。因此，我们需要计算区间 $[A-c, B-c]$ 中 $m$ 的倍数的数量。在区间 $[L, R]$ 中 $m$ 的倍数数量可以计算为 $\\lfloor R/m \\rfloor - \\lfloor (L-1)/m \\rfloor$。当使用向下取整除法时，这个公式对于正整数和负整数都是稳健的。\n\n将此方法应用于我们的问题：\n设 $N_y(c_r)$ 为对于所需余数 $c_r$ 的有效 $y$ 值的数量。这对应于计算在区间 $[Y_{\\min}, Y_{\\max}]$ 中与 $c_r \\pmod{m}$ 同余的整数数量。\n$$N_y(c_r) = \\left\\lfloor \\frac{Y_{\\max} - c_r}{m} \\right\\rfloor - \\left\\lfloor \\frac{Y_{\\min} - c_r - 1}{m} \\right\\rfloor$$\n设 $N_x(r)$ 为在区间 $[X_{\\min}, X_{\\max}]$ 中与 $r \\pmod{m}$ 同余的 $x$ 值的数量。\n$$N_x(r) = \\left\\lfloor \\frac{X_{\\max} - r}{m} \\right\\rfloor - \\left\\lfloor \\frac{X_{\\min} - r - 1}{m} \\right\\rfloor$$\n\n整体算法流程如下：\n1.  将总计数初始化为 $0$。\n2.  遍历 $x$ 的每个可能的剩余类，即 $r$ 从 $0$ 到 $m-1$。\n3.  对于每个 $r$，计算 $y$ 所需的余数：$c_r = (v - r^2) \\pmod{m}$。\n4.  计算 $N_y(c_r)$，即在 $[Y_{\\min}, Y_{\\max}]$ 范围内与 $c_r \\pmod{m}$ 同余的 $y$ 值的数量。\n5.  如果 $N_y(c_r) > 0$，则计算 $N_x(r)$，即在 $[X_{\\min}, X_{\\max}]$ 范围内与 $r \\pmod{m}$ 同余的 $x$ 值的数量。\n6.  将乘积 $N_x(r) \\times N_y(c_r)$ 加到总计数中。\n7.  遍历完所有 $r$ 后，总计数即为最终答案。\n\n该算法的时间复杂度为 $O(m)$，效率非常高，且与 $x$ 和 $y$ 的范围大小无关。\n\n当 $m=1$ 时会出现一个特殊情况。在这种情况下，任何整数都与 $0 \\pmod 1$ 同余。条件 $x^2 + y \\equiv v \\pmod 1$ 总是成立的（因为 $v$ 必须为 $0$）。问题简化为计算该矩形区域内数对的总数，即 $(X_{\\max} - X_{\\min} + 1) \\times (Y_{\\max} - Y_{\\min} + 1)$。通用算法也能正确处理这种情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(m, v, x_min, x_max, y_min, y_max):\n    \"\"\"\n    Calculates the number of integer pairs (x,y) in the given ranges satisfying\n    (x^2 + y) mod m = v, based on principles of modular arithmetic.\n    \"\"\"\n    # The condition is y === v - x^2 (mod m).\n    # The required remainder for y depends only on r_x = x mod m.\n    # The overall strategy is to iterate through each residue class r_x from 0 to m-1,\n    # calculate the number of valid y's for that class, calculate the number of\n    # x's belonging to that class, and sum up the products.\n\n    # This is a general function to count integers in [lower, upper]\n    # that are congruent to `rem` modulo `mod`.\n    # Based on the formula: count = floor( (upper-rem)/mod ) - floor( (lower-rem-1)/mod )\n    # This is equivalent to counting multiples of `mod` in the range [lower-rem, upper-rem].\n    def count_congruent(lower, upper, mod, rem):\n        u_bound = upper - rem\n        l_bound = lower - rem\n        return (u_bound // mod) - ((l_bound - 1) // mod)\n\n    # Special case for m=1. Any integer is congruent to 0 mod 1.\n    # Since v must be 0, the condition is always met.\n    if m == 1:\n        num_x = x_max - x_min + 1\n        num_y = y_max - y_min + 1\n        return num_x * num_y\n\n    # Step 1: Pre-calculate the number of valid y's for each possible residue class of x.\n    # Let r_x = x mod m. The required residue for y is c_r = (v - r_x^2) mod m.\n    y_counts_per_residue = [0] * m\n    for r_x in range(m):\n        c_r = (v - r_x**2) % m\n        y_counts_per_residue[r_x] = count_congruent(y_min, y_max, m, c_r)\n\n    # Step 2: Sum up contributions for each residue class.\n    total_pairs = 0\n    for r_x in range(m):\n        # Optimization: if no y values work for this residue, skip calculation for x.\n        if y_counts_per_residue[r_x] == 0:\n            continue\n\n        # Count how many x's in [x_min, x_max] belong to residue class r_x.\n        num_x = count_congruent(x_min, x_max, m, r_x)\n        \n        # Add the product to the total.\n        total_pairs += num_x * y_counts_per_residue[r_x]\n            \n    return total_pairs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # m, v, X_min, X_max, Y_min, Y_max\n        (7, 3, 0, 20, 0, 30),\n        (1, 0, -5, 5, -5, 5),\n        (13, 0, 0, 100, 0, 100),\n        (9, 4, -20, -1, -30, -10),\n        (8, 7, 0, 50, 3, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, v, x_min, x_max, y_min, y_max = case\n        result = solve_case(m, v, x_min, x_max, y_min, y_max)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3261635"}, {"introduction": "当不同的键被映射到同一个地址时，冲突就发生了。一个好的冲突解决方法是哈希表性能的关键。开放定址法是一种重要的策略，而其性能又与探测序列的特性密切相关。这个练习将带你深入探索二次探测法的具体行为 [@problem_id:3261658]。你的任务不再是被动地分析一个给定的场景，而是要主动地构造一个特定的键序列，以“迫使”二次探测在插入最后一个键时达到其理论上的最长探测路径。完成这项挑战需要你运用素数模下的二次剩余等数论知识，从而深刻理解为何表的大小等参数选择对哈希表的性能至关重要。", "problem": "给定一个初始为空的开放寻址哈希表，其大小为 $M$，并具有以下属性。基本哈希函数为 $h_0(k) = k \\bmod M$。开放寻址 (OA) 通过二次探测 (QP) 执行，探测函数为 $h(k,i) = \\left(h_0(k) + i^2\\right) \\bmod M$，其中探测索引 $i = 0, 1, 2, \\dots$ 依次递增。假设 $M$ 是一个奇素数，哈希表存储整数且不支持删除操作，其插入过程会一直探测，直到找到第一个空槽位并将键放入其中。\n\n从上述基本定义出发，设计一个整数键序列 $\\{k_j\\}$，将其插入到空表中，使得在插入序列中的最后一个键时，探测过程在放置该键之前总共精确地检查 $\\frac{M+1}{2}$ 个不同的槽位（计算包括找到已占用槽位的不成功探测和找到空槽位的最终成功探测）。你的构造必须基于模运算和哈希函数行为的第一性原理进行证明，而不是通过临时性的规定。\n\n你的程序必须：\n- 对于每个指定的 $M$ 值，构造这样一个键序列，使用定义的二次探测将它们插入哈希表，并记录在插入最后一个键期间执行的不同探测总数（包括找到空槽位的成功探测）。\n- 根据所提供的定义忠实地模拟哈希表，确保每次探测都按照 $i$ 从 $0$ 开始的递增顺序检查槽位索引 $h(k,i)$，并在找到第一个空槽位时停止并将键放置在那里。\n- 仅使用整数；不涉及物理单位。\n- 将所有提供的测试用例的结果汇总为一行，形式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_j$ 是对应测试用例的整数探测次数。\n\n测试套件：\n- 情况 1: $M = 3$ (边界素数)。\n- 情况 2: $M = 7$ (小素数)。\n- 情况 3: $M = 11$ (中等大小的素数)。\n- 情况 4: $M = 17$ (较大的素数)。\n- 情况 5: $M = 101$ (显著大的素数)。\n\n你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_j$ 是在测试套件中为相应 $M$ 插入最后一个键时执行的探测总次数（包括成功的一次）。该解决方案必须在纯数学和逻辑上普遍适用于任何现代编程语言，但你的最终答案必须按规定以可运行的 Python 代码形式提供。", "solution": "用户的要求是设计一个整数键序列 $\\{k_j\\}$，将其插入一个大小为 $M$ 的初始为空的开放寻址哈希表中。最后一个键的插入必须导致恰好 $\\frac{M+1}{2}$ 次不同的探测尝试。哈希表使用二次探测，其函数为 $h(k,i) = (h_0(k) + i^2) \\bmod M$，其中 $h_0(k) = k \\bmod M$ 且 $M$ 是一个奇素数。\n\n**1. 使用素数模的二次探测分析**\n\n该问题的核心在于当表大小 $M$ 是素数时二次探测的数论性质。对于一个键 $k$，探测的索引序列由 $(h_0(k) + i^2) \\pmod M$ 给出，其中 $i = 0, 1, 2, \\dots$。访问的不同槽位数取决于 $i^2 \\pmod M$ 的不同值的数量。\n\n我们来分析模素数 $M$ 的二次剩余集合，$S = \\{i^2 \\pmod M \\mid i \\in \\{0, 1, \\dots, M-1\\}\\}$。\n- 当 $i=0$ 时，我们有 $0^2 \\equiv 0 \\pmod M$。\n- 对于任何 $i \\in \\{1, \\dots, M-1\\}$，如果我们有两个探测索引 $i$ 和 $j$ 满足 $0 \\le i  j  M$ 且 $i^2 \\equiv j^2 \\pmod M$，这意味着 $j^2 - i^2 \\equiv 0 \\pmod M$，即 $(j-i)(j+i) \\equiv 0 \\pmod M$。\n- 因为 $M$ 是素数，它必须整除 $(j-i)$ 或 $(j+i)$。\n- 由于 $0  j-i  M$，$M$ 不能整除 $(j-i)$。\n- 因此，$M$ 必须整除 $(j+i)$。由于 $0  i+j  2M$，唯一的可能性是 $j+i = M$。\n\n这意味着对于任何 $i \\in \\{1, 2, \\dots, \\frac{M-1}{2}\\}$，其模 $M$ 的平方与 $M-i$ 的平方相同，因为 $(M-i)^2 = M^2 - 2Mi + i^2 \\equiv i^2 \\pmod M$。\n对于 $i=1, 2, \\dots, \\frac{M-1}{2}$，$i^2 \\pmod M$ 的值都是不同的。如果对于 $1 \\le i  j \\le \\frac{M-1}{2}$ 有 $i^2 \\equiv j^2 \\pmod M$，那么 $j+i=M$。然而，$i+j \\le (\\frac{M-1}{2}-1) + \\frac{M-1}{2} = M-2$，这小于 $M$。这是一个矛盾。\n\n因此，$i^2 \\pmod M$ 的不同值集合是由 $i=0, 1, \\dots, \\frac{M-1}{2}$ 生成的。这个集合的大小恰好是 $\\frac{M-1}{2} + 1 = \\frac{M+1}{2}$。这证明了对于任何键，二次探测最多会访问 $\\frac{M+1}{2}$ 个不同的槽位。问题要求我们构造一个达到这个最大值的情景。\n\n**2. 键序列的构造**\n\n要强制一次插入执行恰好 $N = \\frac{M+1}{2}$ 次探测，我们必须确保它尝试访问的前 $N-1$ 个槽位被占用，而第 $N$ 个槽位是空的。\n\n设最终的键为 $k_{final}$。为了简化对其探测序列的分析，我们选择 $k_{final}$ 使其基本哈希值 $h_0(k_{final})$ 为 $0$。一个之前未被插入过的简单选择是 $k_{final} = M$，因为 $h_0(M) = M \\pmod M = 0$。\n\n对于 $k_{final}=M$ 的探测序列将访问索引为 $h(M, i) = (0 + i^2) \\pmod M = i^2 \\pmod M$ 的槽位。探测尝试对应于 $i=0, 1, 2, \\dots$。\n\n为了实现 $\\frac{M+1}{2}$ 次探测，我们需要对 $i = 0, 1, \\dots, \\frac{M-1}{2}$ 进行探测尝试。\n- 对于 $i = \\frac{M-1}{2}$ 的探测必须是找到空槽位的那一次。\n- 对于 $i = 0, 1, \\dots, \\frac{M-1}{2}-1 = \\frac{M-3}{2}$ 的探测必须找到已占用的槽位。\n\n这意味着我们必须通过插入一个键序列来预先填充哈希表，该序列会占用所有 $j \\in \\{0, 1, \\dots, \\frac{M-3}{2}\\}$ 的索引为 $j^2 \\pmod M$ 的槽位。这样的槽位数量为 $\\frac{M-3}{2} - 0 + 1 = \\frac{M-1}{2}$。\n\n占用给定索引 `idx` 的槽位的最直接方法是插入一个键 `k`，使得 $h_0(k) = \\text{idx}$。最简单的选择是插入键 $k = \\text{idx}$ 本身。由于我们是在一个空表中进行预填充，并且所有目标索引 $j^2 \\pmod M$（对于 $j \\in \\{0, \\dots, \\frac{M-3}{2}\\}$）都是不同的且小于 $M$，因此插入键 $k = j^2 \\pmod M$ 将通过单次探测直接将其放入槽位 $j^2 \\pmod M$ 中。\n\n因此，构造的键序列如下：\n1.  **预填充序列**：插入键 $\\{k_j'\\} = \\{j^2 \\pmod M \\mid j=0, 1, \\dots, \\frac{M-3}{2}\\}$。共有 $\\frac{M-1}{2}$ 个这样的键。\n2.  **最终键**：要插入的最后一个键是 $k_{final} = M$。\n\n**3. 构造的验证**\n\n让我们模拟将最后一个键 $k_{final}=M$ 插入到准备好的哈希表中的过程。\n- 基本哈希值为 $h_0(M) = 0$。\n- **探测 $i=0$**：索引为 $(0+0^2) \\pmod M = 0$。此槽位已被键 $0^2 \\pmod M$ 填充。探测不成功。\n- **探测 $i=1$**：索引为 $(0+1^2) \\pmod M = 1$。此槽位已被键 $1^2 \\pmod M$ 填充。探测不成功。\n- ...\n- **探测 $i = \\frac{M-3}{2}$**：索引为 $(0 + (\\frac{M-3}{2})^2) \\pmod M$。此槽位已被键 $(\\frac{M-3}{2})^2 \\pmod M$ 填充。探测不成功。\n这些是 $\\frac{M-1}{2}$ 次不成功的探测。\n\n- **探测 $i = \\frac{M-1}{2}$**：索引为 $(0 + (\\frac{M-1}{2})^2) \\pmod M$。此槽位不属于预填充序列。它是空的。探测成功。\n\n插入 $k_{final}$ 的总探测次数是不成功探测的次数与一次成功探测之和：\n$$ \\text{总探测次数} = \\left(\\frac{M-1}{2}\\right) + 1 = \\frac{M+1}{2} $$\n这符合问题的要求。因此，该设计得到了验证。程序将为每个给定的 $M$ 值实现此构造和模拟。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hash table problem for a given suite of test cases.\n\n    For each prime M, it constructs a sequence of keys that, when inserted,\n    causes the final key's insertion to take exactly (M+1)/2 probes\n    using quadratic probing. It then simulates this process and records the\n    probe count.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    test_cases = [3, 7, 11, 17, 101]\n    results = []\n\n    for M in test_cases:\n        # Initialize the hash table of size M.\n        # We use -1 as a sentinel for an empty slot, as all keys are non-negative.\n        table = np.full(M, -1, dtype=int)\n\n        # 1. CONSTRUCT AND INSERT THE PRE-FILL KEY SEQUENCE\n        # The goal is to occupy the first (M-1)/2 probe locations for a key hashing to 0.\n        # These locations correspond to probe indices j = 0, 1, ..., (M-3)/2.\n        # The slot indices are (j^2 mod M).\n        # The number of slots to pre-fill is (M-1)/2. The range upper bound is exclusive.\n        num_prefill_slots = (M - 1) // 2\n\n        for j in range(num_prefill_slots):\n            # The key to insert is the index of the slot we want to fill.\n            # h_0(k) = k % M. Since k  M, h_0(k) = k.\n            key_to_insert = (j * j) % M\n            \n            # Since all pre-fill keys are inserted into an empty table at distinct\n            # base hash locations, each insertion takes exactly one probe.\n            # We don't need to simulate the probing for these keys.\n            table[key_to_insert] = key_to_insert\n\n        # 2. DEFINE THE FINAL KEY AND SIMULATE ITS INSERTION\n        # We choose a final key that hashes to 0 but is not in the pre-fill set.\n        # k_final = M is a safe choice, as all pre-fill keys are  M.\n        final_key = M\n        base_hash = final_key % M  # This will be 0\n\n        # Simulate the insertion of the final key and count the probes.\n        probe_count = 0\n        i = 0\n        while True:\n            probe_count += 1\n            index = (base_hash + i*i) % M\n\n            if table[index] == -1:  # Found an empty slot.\n                # The problem asks for the probe count, so the simulation can stop here.\n                # The actual insertion would be: table[index] = final_key\n                break\n            \n            # The slot is occupied, continue to the next probe.\n            i += 1\n        \n        results.append(probe_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3261658"}, {"introduction": "掌握了哈希与冲突解决的基础后，让我们将视野拓宽，看看哈希思想如何作为强大工具，在简单的数据存取之外解决复杂的算法问题。最后一个练习将带你进入计算生物学的世界，解决一个实际且富有挑战性的问题：在允许少量不匹配的情况下，寻找两条DNA序列之间最长的公共子串 [@problem_id:3261679]。你将实现一个精妙的算法，它融合了多种强大的技术：利用滚动哈希实现快速的子串比较，运用“鸽巢原理”巧妙地处理不匹配的容错，并结合二分搜索来高效地寻找最优解。这个练习将充分展示哈希作为现代算法设计中一个基本构件的强大威力与灵活性。", "problem": "给定两个基于脱氧核糖核酸 (DNA) 字母表 $\\{A,C,G,T\\}$ 的有限字符串，记为 $S$ 和 $T$，以及一个非负整数 $k$。定义两个等长字符串 $U$ 和 $V$ 的汉明距离 $d_H(U,V)$ 为相应位置上符号不同的位置数量。最长k错配公共子串长度是满足以下条件的最大整数 $\\ell$：存在索引 $i$ 和 $j$（$0 \\le i \\le |S| - \\ell$ 且 $0 \\le j \\le |T| - \\ell$），使得 $d_H\\big(S[i:i+\\ell], T[j:j+\\ell]\\big) \\le k$。\n\n从哈希函数、滚动哈希和汉明距离的基本定义出发，设计并实现一个算法，该算法使用滚动哈希来判断（对于一个固定的长度 $\\ell$）是否存在 $S$ 和 $T$ 的长度为 $\\ell$ 的子串，其汉明距离至多为 $k$。然后，在一个搜索过程中使用这个判断程序，以确定最长k错配公共子串的长度。该算法必须依赖于：\n- 在有限模数上的多项式滚动哈希，带有预计算的幂和前缀哈希，以实现 $O(1)$ 时间复杂度的子串哈希查询。\n- 一个组合学事实：对于任何两个长度相等且在至多 $k$ 个位置上不同的字符串，若将其长度划分为 $k+1$ 个连续块，则保证至少有一个块完全匹配。\n\n你的程序必须：\n- 将每个DNA字符映射到集合 $\\{1,2,3,4\\}$ 中的一个整数。\n- 使用具有两个不同大质数模数的双哈希方法来降低碰撞概率。\n- 对于给定的长度 $\\ell$，将 $\\ell$ 个位置划分为 $k+1$ 个连续块，其中前 $r$ 个块的大小为 $q+1$，其余块的大小为 $q$，这里 $q = \\left\\lfloor \\frac{\\ell}{k+1} \\right\\rfloor$ 且 $r = \\ell \\bmod (k+1)$。\n- 对于每个块索引 $b \\in \\{0,1,\\dots,k\\}$，使用滚动哈希，通过其第 $b$ 个块的哈希值为所有长度为 $\\ell$ 的 $S$ 的子串建立索引。对于每个长度为 $\\ell$ 的 $T$ 的子串，使用相同的第 $b$ 个块的哈希值从 $S$ 中检索候选子串，并通过直接计算汉明距离来确认候选子串，如果距离至多为 $k$ 则接受。\n- 在 $\\ell \\in \\{0,1,\\dots,\\min(|S|,|T|)\\}$ 上进行搜索，以找到发生接受情况的最大 $\\ell$ 值。对于提供的测试套件，该搜索必须是正确且高效的。\n\n最终输出必须是单行文本，包含整个测试套件的结果，格式为一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。每个结果必须是其测试用例的最长k错配公共子串长度的整数值。\n\n测试套件：\n- 情况 1：$S = $ \"AAAAAA\", $T = $ \"AAAATA\", $k = 1$。\n- 情况 2：$S = $ \"ACGT\", $T = $ \"ACGT\", $k = 0$。\n- 情况 3：$S = $ \"AAAA\", $T = $ \"TTTT\", $k = 0$。\n- 情况 4：$S = $ \"ACGTCGTA\", $T = $ \"ACGACGTA\", $k = 2$。\n- 情况 5：$S = $ \"\", $T = $ \"ACGT\", $k = 1$。\n- 情况 6：$S = $ \"ACGTACGT\", $T = $ \"ACGTTTGT\", $k = 1$。\n\n你的程序必须生成一行输出，其中包含按上述顺序排列的六个整数结果，并采用指定的格式。", "solution": "用户的要求是详细的问题陈述，我现在将对其进行验证。\n\n### 第一步：提取已知条件\n\n-   **输入**：\n    1.  两个基于DNA字母表 $\\{A, C, G, T\\}$ 的有限字符串 $S$ 和 $T$。\n    2.  一个非负整数 $k$。\n\n-   **定义**：\n    1.  **汉明距离 $d_H(U,V)$**：对于两个等长字符串 $U$ 和 $V$，这是相应位置上符号不同的位置数量。\n    2.  **最长k错配公共子串长度**：满足以下条件的最大整数 $\\ell$：存在索引 $i$ 和 $j$（$0 \\le i \\le |S| - \\ell$， $0 \\le j \\le |T| - \\ell$），使得 $d_H\\big(S[i:i+\\ell], T[j:j+\\ell]\\big) \\le k$。\n\n-   **算法约束**：\n    1.  解决方案必须采用一个由两部分组成的算法：一个嵌套在搜索过程中的判断过程。\n    2.  判断过程，对于固定的长度 $\\ell$，确定是否存在 $S$ 和 $T$ 中长度为 $\\ell$ 的子串，其汉明距离至多为 $k$。\n    3.  搜索过程找到使判断过程返回“真”的最大 $\\ell$。搜索必须覆盖范围 $\\ell \\in \\{0, 1, \\dots, \\min(|S|,|T|)\\}$。\n    4.  该算法必须基于一个带有预计算的幂和前缀哈希的多项式滚动哈希，以实现 $O(1)$ 时间复杂度的子串哈希查询。要求使用带有两个不同大质数模数的双哈希方法。\n    5.  DNA字符必须映射到 $\\{1, 2, 3, 4\\}$ 中的整数。\n    6.  判断过程的核心必须使用组合学原理：对于任意两个长度为 $\\ell$ 且汉明距离 $\\le k$ 的字符串，若将字符串划分为 $k+1$ 个连续块，则保证至少有一对相应的块是完全相同的。\n    7.  对于给定的 $\\ell$，这 $k+1$ 个块定义如下：令 $q = \\lfloor \\frac{\\ell}{k+1} \\rfloor$ 且 $r = \\ell \\bmod (k+1)$。前 $r$ 个块的大小为 $q+1$，其余块的大小为 $q$。\n    8.  判断过程必须对每个块索引 $b \\in \\{0, 1, \\dots, k\\}$，通过其第 $b$ 个块的哈希值为所有长度为 $\\ell$ 的 $S$ 的子串建立索引。然后，对于每个长度为 $\\ell$ 的 $T$ 的子串，使用其第 $b$ 个块的哈希值从 $S$ 中找到候选匹配，并通过计算完整的汉明距离进行验证。\n\n-   **测试套件**：\n    -   情况 1：$S = $ \"AAAAAA\", $T = $ \"AAAATA\", $k = 1$。\n    -   情况 2：$S = $ \"ACGT\", $T = $ \"ACGT\", $k = 0$。\n    -   情况 3：$S = $ \"AAAA\", $T = $ \"TTTT\", $k = 0$。\n    -   情况 4：$S = $ \"ACGTCGTA\", $T = $ \"ACGACGTA\", $k = 2$。\n    -   情况 5：$S = $ \"\", $T = $ \"ACGT\", $k = 1$。\n    -   情况 6：$S = $ \"ACGTACGT\", $T = $ \"ACGTTTGT\", $k = 1$。\n\n-   **输出格式**：单行文本，包含一个用方括号括起来的逗号分隔的整数结果列表。\n\n### 第二步：使用提取的已知条件进行验证\n\n-   **科学或事实上的不健全性**：问题在科学上是健全的。它基于计算机科学（字符串算法、哈希）和数学（组合学、数论）中已确立的概念。其核心组合学原理是鸽巢原理的直接应用：如果最多有 $k$ 个错配（鸽子）分布在 $k+1$ 个块（鸽巢）中，那么至少有一个块必须不包含任何鸽子（错配）。\n-   **不可形式化或不相关**：问题是高度形式化的，并且与字符串匹配算法的设计和分析直接相关。\n-   **不完整或矛盾的设置**：问题陈述异常明确，不仅提供了目标，还为所需算法提供了详细的蓝图。没有矛盾之处。\n-   **不切实际或不可行**：问题是一个标准的计算任务，没有涉及任何物理上不可能的条件。\n-   **不适定或结构不良**：问题是适定的。解的存在性得到保证（长度为 $0$ 总是可能的），并且详细的算法规定导向一个唯一的、确定性的结果。\n-   **伪深刻、琐碎或同义反复**：问题不平凡，需要仔细实现几个复杂组件（二分搜索、双滚动哈希、基于块的候选者生成）。它代表了一种标准而优雅的算法技巧。\n-   **超出科学可验证性范围**：算法的正确性可以通过数学推理来证明，其输出对于任何给定的输入都是可验证的。\n\n### 第三步：结论与行动\n\n问题陈述是**有效的**。它自洽、有科学依据且定义严谨。我将继续提供一个完整的解决方案。\n\n### 基于原则的设计与解决方案\n\n该问题要求设计一个算法来找到两个字符串 $S$ 和 $T$ 之间最长的k错配公共子串长度 $\\ell_{max}$。该方法被构建为一个优化问题，通过对一个判断问题进行搜索来解决。\n\n**1. 总体策略：对答案进行二分搜索**\n\n让我们定义一个布尔函数 `check($\\ell$)`，如果存在一对来自 $S$ 和 $T$ 的长度为 $\\ell$ 的子串，其汉明距离至多为 $k$，则该函数为真，否则为假。这个函数是单调的：如果 `check($\\ell$)` 为真，那么对于任何 $1 \\le \\ell'  \\ell$，`check($\\ell'$)` 也为真。这是因为一个有效配对的长度为 $\\ell$ 的子串的任何前缀都将构成一个有效配对的长度为 $\\ell'$ 的子串，因为汉明距离不会增加。\n\n这种单调性允许我们使用二分搜索来高效地找到使 `check($\\ell$)` 为真的最大 $\\ell$。$\\ell$ 的搜索空间是区间 $[0, \\min(|S|,|T|)]$。二分搜索将反复探测这个空间，收敛到最优值 $\\ell_{max}$。\n\n**2. 判断过程：`check($\\ell$)`**\n\n算法的核心是 `check($\\ell$)` 函数。一个朴素的实现会比较 $S$ 中的每个长度为 $\\ell$ 的子串与 $T$ 中的每个此类子串，这种方法的复杂度对于大字符串来说是令人望而却步的。问题指定了一种基于关键组合学洞见的更复杂的方法。\n\n**组合学原理**：如果两个长度为 $\\ell$ 的字符串 $U$ 和 $V$ 的汉明距离 $d_H(U, V) \\le k$，并且我们将两个字符串都划分为 $k+1$ 个连续块，那么根据鸽巢原理，至少有一对相应的块必须是完全相同的。如果每一对块都至少有一个错配，那么错配的总数将至少是 $k+1$，这与前提矛盾。\n\n这个原理使我们能够将问题从寻找整个长度 $\\ell$ 上的近似匹配，转化为寻找一个更小块上的至少一个精确匹配。精确匹配可以用哈希非常高效地解决。\n\n**块划分**：对于给定的长度 $\\ell$ 和错配容忍度 $k$，我们将长度划分为 $B = k+1$ 个块。基本块大小为 $q = \\left\\lfloor \\frac{\\ell}{B} \\right\\rfloor$，较大块的数量为 $r = \\ell \\bmod B$。前 $r$ 个块的大小为 $q+1$，剩下的 $B-r$ 个块的大小为 $q$。我们可以预计算这 $k+1$ 个块的起始偏移量。\n\n**3. 使用滚动哈希进行高效的精确匹配**\n\n为了高效地找到相同的块，我们使用多项式滚动哈希。\n\n**多项式滚动哈希**：一个字符串 $W = w_0w_1...w_{m-1}$ 被映射到一个整数哈希值。首先，每个字符 $w_i$ 被映射到集合 $\\{1, 2, 3, 4\\}$ 中的一个正整数 $c(w_i)$。然后哈希值定义为：\n$$ H(W) = \\left( \\sum_{i=0}^{m-1} c(w_i) \\cdot p^{m-1-i} \\right) \\pmod{M} $$\n其中 $p$ 是一个比字母表大小大的质数基数，而 $M$ 是一个大的质数模数。\n\n**双哈希**：为了极大地减少哈希碰撞（两个不同的字符串产生相同的哈希值）的概率，我们使用不同的基数（$p_1, p_2$）和模数（$M_1, M_2$）为每个字符串计算两个独立的哈希值。一个字符串因此由一对哈希值 $(h_1, h_2)$ 表示。\n\n**$O(1)$ 子串哈希**：在初始的 $O(|S|)$ 预计算之后，我们可以在 $O(1)$ 时间内计算任何子串的哈希值。我们为每个哈希函数预计算两个数组：\n1.  基数的幂：$P[i] = p^i \\pmod M$。\n2.  前缀哈希：$H_{pref}[i] = H(S[0:i-1])$。\n\n一个子串 $S[i:j]$（长度为 $len = j-i+1$）的哈希值则为：\n$$ H(S[i:j]) = \\left( H_{pref}[j+1] - H_{pref}[i] \\cdot P[len] \\right) \\pmod M $$\n必须注意处理减法产生的负数结果，方法是在最终取模前加上 $M$。\n\n**4. `check($\\ell$)` 算法**\n\n有了这些工具，`check($\\ell$)` 的算法如下（假设 $\\ell > 0$）：\n\n1.  确定长度为 $\\ell$ 的字符串中 $k+1$ 个块中每个块的起点和终点。\n2.  对于每个块索引 $b \\in \\{0, 1, ..., k\\}$：\n    a. 创建一个哈希表 `hash_to_indices`，用于存储来自 $S$ 的子串的第 $b$ 个块的哈希值。\n    b. 遍历所有起始位置 $i$（从 $0$ 到 $|S|-\\ell$）。对于每个子串 $S[i:i+\\ell]$：\n        i.  确定与第 $b$ 个块对应的切片：$S[i+\\text{start}_b : i+\\text{end}_b]$。\n        ii. 使用预计算的表在 $O(1)$ 时间内计算其双哈希 $(h_1, h_2)$。\n        iii. 存储完整子串的起始索引：`hash_to_indices[(h_1, h_2)].append(i)`。\n    c. 遍历所有起始位置 $j$（从 $0$ 到 $|T|-\\ell$）。对于每个子串 $T[j:j+\\ell]$：\n        i.  确定与第 $b$ 个块对应的切片：$T[j+\\text{start}_b : j+\\text{end}_b]$。\n        ii. 计算其双哈希 $(h'_1, h'_2)$。\n        iii. 如果这个哈希 $(h'_1, h'_2)$ 在 `hash_to_indices` 中作为键存在，我们就找到了候选配对。\n        iv. 对于与此哈希关联的每个候选起始索引 $i_{cand}$：\n            -   执行逐字符比较以计算 $d_H(S[i_{cand}:i_{cand}+\\ell], T[j:j+\\ell])$。\n            -   如果距离 $\\le k$，则找到了一个有效配对。返回 `True`。\n3.  如果遍历完所有 $k+1$ 个块的外部循环都没有找到匹配，则不存在这样的一对长度为 $\\ell$ 的子串。返回 `False`。\n\n由于鸽巢原理，这个过程保证是正确的。它的效率来自于将大量昂贵的 $O(\\ell)$ 近似比较减少为数量少得多的 $O(1)$ 哈希计算和查找，之后仅对强候选者进行少数 $O(\\ell)$ 的验证。_", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (\"AAAAAA\", \"AAAATA\", 1),\n        # Case 2\n        (\"ACGT\", \"ACGT\", 0),\n        # Case 3\n        (\"AAAA\", \"TTTT\", 0),\n        # Case 4\n        (\"ACGTCGTA\", \"ACGACGTA\", 2),\n        # Case 5\n        (\"\", \"ACGT\", 1),\n        # Case 6\n        (\"ACGTACGT\", \"ACGTTTGT\", 1),\n    ]\n\n    results = []\n    for S, T, k in test_cases:\n        result = find_longest_k_mismatch_substring(S, T, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_longest_k_mismatch_substring(S, T, k):\n    \"\"\"\n    Finds the longest k-mismatch common substring length using binary search.\n    \"\"\"\n    n, m = len(S), len(T)\n    if n == 0 or m == 0:\n        return 0\n\n    checker = KMismatchChecker(S, T, k)\n    \n    ans = 0\n    low, high = 1, min(n, m)\n    \n    while low = high:\n        ell = low + (high - low) // 2\n        if checker.check(ell):\n            ans = ell\n            low = ell + 1\n        else:\n            high = ell - 1\n            \n    return ans\n\nclass KMismatchChecker:\n    \"\"\"\n    A class to check for the existence of a k-mismatch substring of a given length ell.\n    It precomputes rolling hash structures for efficiency.\n    \"\"\"\n    CHAR_MAP = {'A': 1, 'C': 2, 'G': 3, 'T': 4}\n    P1, M1 = 313, 10**9 + 7\n    P2, M2 = 353, 10**9 + 9\n\n    class RollingHasher:\n        def __init__(self, text, p, m, char_map):\n            self.n = len(text)\n            self.p = p\n            self.m = m\n            \n            self.prefix_hash = np.zeros(self.n + 1, dtype=np.int64)\n            self.powers = np.ones(self.n + 1, dtype=np.int64)\n            \n            for i in range(self.n):\n                self.prefix_hash[i+1] = (self.prefix_hash[i] * self.p + char_map[text[i]]) % self.m\n            \n            for i in range(self.n):\n                self.powers[i+1] = (self.powers[i] * self.p) % self.m\n\n        def get_hash(self, i, length):\n            \"\"\"Computes hash of substring of given length starting at i.\"\"\"\n            h = (self.prefix_hash[i + length] - self.prefix_hash[i] * self.powers[length]) % self.m\n            return h + self.m if h  0 else h\n\n    def __init__(self, S, T, k):\n        self.S = S\n        self.T = T\n        self.k = k\n        self.n = len(S)\n        self.m = len(T)\n        \n        self.s_hasher1 = self.RollingHasher(S, self.P1, self.M1, self.CHAR_MAP)\n        self.s_hasher2 = self.RollingHasher(S, self.P2, self.M2, self.CHAR_MAP)\n        self.t_hasher1 = self.RollingHasher(T, self.P1, self.M1, self.CHAR_MAP)\n        self.t_hasher2 = self.RollingHasher(T, self.P2, self.M2, self.CHAR_MAP)\n\n    @staticmethod\n    def _get_block_structure(ell, k):\n        \"\"\"Calculates the start and length of each of the k+1 blocks.\"\"\"\n        if ell == 0:\n            return [], []\n        num_blocks = k + 1\n        base_len = ell // num_blocks\n        rem = ell % num_blocks\n        \n        block_starts = [0] * (num_blocks + 1)\n        block_lengths = [0] * num_blocks\n\n        for i in range(num_blocks):\n            length = base_len + 1 if i  rem else base_len\n            block_lengths[i] = length\n            block_starts[i+1] = block_starts[i] + length\n            \n        return block_starts, block_lengths\n\n    def _hamming_distance(self, s1_start, s2_start, length):\n        \"\"\"Calculates Hamming distance between substrings of S and T.\"\"\"\n        dist = 0\n        for i in range(length):\n            if self.S[s1_start + i] != self.T[s2_start + i]:\n                dist += 1\n        return dist\n\n    def check(self, ell):\n        \"\"\"\n        Checks if a k-mismatch common substring of length ell exists.\n        \"\"\"\n        if ell == 0:\n            return True\n        if ell > min(self.n, self.m):\n            return False\n\n        block_starts, block_lengths = self._get_block_structure(ell, self.k)\n        \n        for b in range(self.k + 1):\n            s_block_hashes = defaultdict(list)\n            block_start_offset = block_starts[b]\n            block_len = block_lengths[b]\n            \n            if block_len == 0:\n                continue\n                \n            # Index substrings of S by their b-th block's hash\n            for i in range(self.n - ell + 1):\n                h1 = self.s_hasher1.get_hash(i + block_start_offset, block_len)\n                h2 = self.s_hasher2.get_hash(i + block_start_offset, block_len)\n                s_block_hashes[(h1, h2)].append(i)\n\n            if not s_block_hashes:\n                continue\n\n            # Check substrings of T against the index\n            for j in range(self.m - ell + 1):\n                h1 = self.t_hasher1.get_hash(j + block_start_offset, block_len)\n                h2 = self.t_hasher2.get_hash(j + block_start_offset, block_len)\n\n                if (h1, h2) in s_block_hashes:\n                    for s_start_idx in s_block_hashes[(h1, h2)]:\n                        # Candidate found, verify with Hamming distance\n                        if self._hamming_distance(s_start_idx, j, ell) = self.k:\n                            return True\n                            \n        return False\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3261679"}]}