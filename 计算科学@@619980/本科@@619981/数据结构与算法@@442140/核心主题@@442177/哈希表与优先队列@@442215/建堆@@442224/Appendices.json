{"hands_on_practices": [{"introduction": "要真正掌握 `buildHeap` 算法，没有什么比亲手追踪元素在数组中的移动轨迹更有效的方法了。这个练习要求你精确模拟自底向上构建最大堆的整个过程，并预测一个特定元素在建堆结束后的最终位置。通过这个实践 [@problem_id:3219649]，你将深化对 `siftDown` 操作以及其中确定性规则（如平局处理）的理解，并能准确把握算法的每一步细节。", "problem": "你的任务是预测一个数组中从指定索引开始的元素，在经过自底向上的堆构建操作后，其在数组中的最终位置。所讨论的数据结构是一个用基于零的索引数组表示的二叉最大堆。堆属性要求对于每个有子节点的索引 $j$，其键值必须大于或等于其每个子节点的键值。数组到树的映射关系如下：对于任意索引 $j$，其左子节点（如果存在）位于索引 $2j + 1$ 处，其右子节点（如果存在）位于索引 $2j + 2$ 处。对于任意索引 $k  0$，其父节点位于索引 $\\left\\lfloor \\dfrac{k - 1}{2} \\right\\rfloor$ 处。\n\n仅从基本定义出发：二叉堆属性、上述数组表示的映射关系，以及基于比较的堆作为由键值比较所导出的偏序关系的定义。考虑标准的自底向上堆构建过程，该过程通过从内部节点到叶子节点的反复局部恢复（使用向下调整操作）来强制满足堆属性。在对索引为 $j$ 的节点进行向下调整期间，假设遵循以下确定性的比较和处理平局的规则：\n- 在现有的子节点中，考虑键值最大的那个。如果两个子节点都存在且它们的键值相等，则选择索引为 $2j + 1$ 的左子节点。\n- 仅当所选子节点的键值严格大于索引 $j$ 处节点的键值时，才执行交换。\n- 在发生交换的子节点索引处继续此过程，直到不需要交换或到达叶子节点时停止。\n\n自底向上的构建过程会从最后一个内部节点开始，按降序遍历到根节点。最后一个内部节点的索引是 $\\left\\lfloor \\dfrac{n - 2}{2} \\right\\rfloor$，其中 $n$ 是数组的长度。对于按此顺序访问的每个索引 $j$，都会从 $j$ 开始执行上述的向下调整操作。\n\n你的程序必须对每个给定的“整数数组和初始索引 $i$”对，确定从索引 $i$ 开始的元素在堆完全构建后的最终索引位置。元素的身份必须通过其原始索引来追踪，而不是通过其键值，以便正确处理重复的键值。\n\n全程使用基于零的索引。每个案例的结果是一个整数索引。不涉及物理单位或角度。\n\n实现一个完整的、可运行的程序，使用以下测试套件，并以单行输出的形式生成最终位置。输出内容为用方括号括起来的逗号分隔列表，结果顺序与测试用例相同。每个数组都按字面量给出，每个索引 $i$ 都有指定。测试套件如下：\n- 案例 $1$：数组 $[\\,3,\\,1,\\,6,\\,5,\\,2,\\,4\\,]$，$i = 1$。\n- 案例 $2$：数组 $[\\,9,\\,7,\\,8,\\,3,\\,2,\\,1,\\,5\\,]$，$i = 6$。\n- 案例 $3$：数组 $[\\,1,\\,2,\\,3,\\,4\\,]$，$i = 0$。\n- 案例 $4$：数组 $[\\,1,\\,2,\\,2\\,]$，$i = 0$。\n- 案例 $5$：数组 $[\\,10,\\,9,\\,8,\\,7,\\,6,\\,5\\,]$，$i = 4$。\n- 案例 $6$：数组 $[\\,2,\\,2,\\,2,\\,2\\,]$，$i = 2$。\n- 案例 $7$：数组 $[\\,1,\\,2\\,]$，$i = 1$。\n- 案例 $8$：数组 $[\\,{-3},\\,{-1},\\,{-2}\\,]$，$i = 0$。\n- 案例 $9$：数组 $[\\,0,\\,1,\\,2,\\,3,\\,4,\\,5,\\,6\\,]$，$i = 6$。\n- 案例 $10$：数组 $[\\,7\\,]$，$i = 0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots,r_{10}]$），其中每个 $r_k$ 是案例 $k$ 的最终索引。", "solution": "问题要求在对一个数组执行标准的自底向上最大堆构建（堆化）操作后，确定一个最初位于给定索引 $i$ 的元素的最终索引。由于为堆操作提供了精确的规则，这个过程是确定性的。\n\n要解决这个问题，我们必须模拟堆的构建过程，同时追踪我们感兴趣的特定元素的位置。由于数组中可能包含重复的键值，元素的身份必须与其原始位置绑定。我们通过将输入的键值数组（例如 `arr`）转换为一个增强的“对”数组来实现这一点。原始数组中索引 $k$ 处的每个元素都表示为一个元组 $(key, original\\_index)$，即 $(arr[k], k)$。所有后续操作都在这个增强数组上执行。\n\n堆构建算法，通常称为 `build_heap`，作用于一个大小为 $n$ 的数组。它以逆序遍历准二叉树的内部节点，从最后一个父节点一直到根节点。在基于零的数组中，最后一个父节点的索引由 $\\left\\lfloor \\dfrac{n - 2}{2} \\right\\rfloor$ 给出。循环从该索引递减至 $0$。对于此范围内的每个索引 $j$，都会调用一个向下调整的过程 `sift_down`，以确保以 $j$ 为根的子树满足最大堆属性。\n\n`sift_down(j)` 过程是堆构建的核心。它确保索引 $j$ 处的元素在其子树中被正确放置。该过程如下：\n1.  设当前节点位于索引 `root` 处，初始值为 $j$。\n2.  确定该节点的子节点。左子节点位于索引 $2 \\cdot \\text{root} + 1$ 处，右子节点位于 $2 \\cdot \\text{root} + 2$ 处。\n3.  选择键值最大的子节点。根据指定的规则：\n    - 如果两个子节点都存在且它们的键值相等，则选择左子节点（位于 $2 \\cdot \\text{root} + 1$ 处）。\n    - 否则，选择键值严格较大的子节点。\n4.  如果所选子节点的键值严格大于 `root` 处当前节点的键值，则在该节点与所选子节点之间执行交换。\n5.  如果发生了交换，`sift_down` 过程会从子节点的索引处递归（或迭代）地继续，该子节点现在持有最初位于 `root` 的元素。\n6.  当当前节点的键值大于或等于其子节点的键值时，或当到达叶子节点（即没有子节点）时，该过程终止。\n\n通过将此 `build_heap` 过程应用于增强数组，元素（包括其原始索引）被重新排列以满足最大堆属性。算法完成后，最终的数组是一个有效的最大堆。通过在最终数组中搜索 `original_index` 与给定初始索引 $i$ 相匹配的元组，可以找到被追踪元素的最终位置。\n\n让我们追踪案例 3：数组为 $[\\,1,\\,2,\\,3,\\,4\\,]$，要追踪的元素从索引 $i = 0$ 开始。\n- 初始键值数组为 $[\\,1,\\,2,\\,3,\\,4\\,]$。大小为 $n = 4$。我们追踪原始索引为 $0$ 的元素。\n- 增强数组为 $A = [\\,(1, 0),\\,(2, 1),\\,(3, 2),\\,(4, 3)\\,]$。\n- `build_heap` 过程从最后一个父节点（索引为 $\\left\\lfloor \\dfrac{4 - 2}{2} \\right\\rfloor = 1$）开始。循环将先对 $j=1$ 执行，然后对 $j=0$ 执行。\n\n- **步骤 1：`sift_down(1)`**\n  - 索引 $1$ 处的节点是 $(2, 1)$。其左子节点在索引 $2(1) + 1 = 3$ 处，是 $(4, 3)$。没有右子节点。\n  - 子节点的键值 $4$ 严格大于节点的键值 $2$。执行交换。\n  - 数组变为 $A = [\\,(1, 0),\\,(4, 3),\\,(3, 2),\\,(2, 1)\\,]$。\n  - 过程从 $(2, 1)$ 的新位置（即索引 $3$）继续。这是一个叶子节点，所以 `sift_down(1)` 终止。\n\n- **步骤 2：`sift_down(0)`**\n  - 索引 $0$ 处的节点是 $(1, 0)$。其子节点在索引 $1$ 和 $2$ 处，分别是 $(4, 3)$ 和 $(3, 2)$。\n  - 键值最大的子节点是索引 $1$ 处的 $(4, 3)$。\n  - 该子节点的键值 $4$ 严格大于节点的键值 $1$。执行交换。\n  - 数组变为 $A = [\\,(4, 3),\\,(1, 0),\\,(3, 2),\\,(2, 1)\\,]$。\n  - 过程从 $(1, 0)$ 的新位置（即索引 $1$）继续。\n  - 现在在索引 $1$ 处，节点是 $(1, 0)$。其左子节点在索引 $2(1) + 1 = 3$ 处，是 $(2, 1)$。\n  - 子节点的键值 $2$ 严格大于节点的键值 $1$。执行交换。\n  - 数组变为 $A = [\\,(4, 3),\\,(2, 1),\\,(3, 2),\\,(1, 0)\\,]$。\n  - 过程从索引 $3$ 继续，这是一个叶子节点。程序终止。\n\n- **最终状态：** 堆构建完成。最终数组为 $A = [\\,(4, 3),\\,(2, 1),\\,(3, 2),\\,(1, 0)\\,]$。\n- 我们搜索原始索引为 $0$ 的元素，即元组 $(1, 0)$。它位于索引 $3$ 处。\n- 因此，案例 3 的最终位置是 $3$。\n\n将此确定性过程实现并应用于所有测试用例，以获得最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sift_down(arr, root_idx, heap_size):\n    \"\"\"\n    Performs the downward adjustment for a max-heap.\n\n    This function takes an array of (key, original_index) tuples and ensures\n    the subtree rooted at root_idx satisfies the max-heap property.\n    This implementation follows the specific deterministic rules from the problem.\n    \"\"\"\n    root = root_idx\n    while True:\n        # Determine the index of the child to potentially swap with.\n        largest_child_idx = -1\n        left_child_idx = 2 * root + 1\n        right_child_idx = 2 * root + 2\n\n        # Start by assuming the left child is the largest, if it exists.\n        if left_child_idx  heap_size:\n            largest_child_idx = left_child_idx\n\n        # If the right child exists and is greater than the current largest, update.\n        # This handles the tie-breaking rule: if keys are equal, left child is preferred.\n        if right_child_idx  heap_size and arr[right_child_idx][0]  arr[largest_child_idx][0]:\n            largest_child_idx = right_child_idx\n        \n        # If there are no children, the process stops.\n        if largest_child_idx == -1:\n            break\n\n        # Perform swap only if the selected child's key is strictly greater.\n        if arr[largest_child_idx][0]  arr[root][0]:\n            arr[root], arr[largest_child_idx] = arr[largest_child_idx], arr[root]\n            # Continue sifting down from the new position.\n            root = largest_child_idx\n        else:\n            # The heap property holds for this subtree, so stop.\n            break\n\ndef build_heap(arr):\n    \"\"\"\n    Constructs a max-heap in-place from an array of (key, original_index) tuples.\n    \"\"\"\n    n = len(arr)\n    # The last parent node is at index floor((n - 2) / 2). Integer division // performs floor.\n    start_idx = (n - 2) // 2\n    for i in range(start_idx, -1, -1):\n        sift_down(arr, i, n)\n\ndef find_final_position(initial_array, tracked_original_index):\n    \"\"\"\n    Simulates the heap build and finds the final position of a tracked element.\n    \"\"\"\n    n = len(initial_array)\n    if n == 0:\n        return -1 # Should not happen with given test cases\n\n    # Create an augmented array to track elements by original index.\n    # Each element is a tuple: (key, original_index).\n    augmented_arr = [(initial_array[i], i) for i in range(n)]\n\n    # Build the max-heap in-place.\n    build_heap(augmented_arr)\n\n    # Find the final index of the element we are tracking.\n    for i in range(n):\n        if augmented_arr[i][1] == tracked_original_index:\n            return i\n            \n    return -1 # Should not be reached if tracked_original_index is valid.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        ([3, 1, 6, 5, 2, 4], 1),\n        ([9, 7, 8, 3, 2, 1, 5], 6),\n        ([1, 2, 3, 4], 0),\n        ([1, 2, 2], 0),\n        ([10, 9, 8, 7, 6, 5], 4),\n        ([2, 2, 2, 2], 2),\n        ([1, 2], 1),\n        ([-3, -1, -2], 0),\n        ([0, 1, 2, 3, 4, 5, 6], 6),\n        ([7], 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        arr, tracked_idx = case\n        result = find_final_position(arr, tracked_idx)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3219649"}, {"introduction": "理解算法的平均性能很重要，但探究其最坏情况的边界同样关键。这个练习将挑战你扮演一个“对手”的角色，设计并生成一个能最大化 `buildHeap` 过程中父子交换次数的输入数组。你不仅需要实现一个“对抗性”的输入生成器 [@problem_id:3219678]，还需要将其产生的成本与理论上的最坏情况成本进行比较，从而验证你的构造是否达到了最优。这个过程将加深你对算法性能极限的认识，并连接起理论分析与实际验证。", "problem": "设 $n \\in \\mathbb{N}$ 表示一个数组中键的数量，该数组在零基索引下被解释为一棵完全二叉树，其中索引为 $i$ 的父节点，其子节点的索引为 $2i+1$ 和 $2i+2$（当这些索引小于 $n$ 时）。考虑二叉最大堆属性，该属性要求对于每个内部节点索引 $i$，只要相应的子节点存在，不等式 $A[i] \\geq A[2i+1]$ 和 $A[i] \\geq A[2i+2]$ 就必须成立。定义数组 $A$ 的堆无序度量 $\\Delta$ 为违反此属性的父子边的数量，即\n$$\n\\Delta(A) = \\left|\\left\\{ j \\in \\{1,2,\\dots,n-1\\} \\,\\middle|\\, A\\left(\\left\\lfloor \\frac{j-1}{2} \\right\\rfloor\\right)  A(j) \\right\\}\\right|.\n$$\n您必须通过显式选择哪些边违反最大堆属性，然后分配能同时满足所有这些局部不等式的数值，来构造具有受控值 $\\Delta$ 的包含 $n$ 个键的数组。一种有效的构造策略是，为根节点赋值 $A(0) = 0$，并且对于每个子节点索引 $j$（其父节点为 $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$），设置\n$$\nA(j) =\n\\begin{cases}\nA(p) + 1,  \\text{如果边 } (p \\to j) \\text{ 被指定为违反}, \\\\\nA(p) - 1,  \\text{否则},\n\\end{cases}\n$$\n这确保了每个指定的边 $(p \\to j)$ 恰好贡献一次违反，而所有未指定的边都满足最大堆属性。对于给定的 $n$，边的数量是 $n-1$，所以 $\\Delta$ 的取值范围可以从 $0$ 到 $n-1$。\n\n定义 Floyd 的自底向上堆构造（堆化）的成本为在所有内部节点上执行标准下沉（sift-down）操作期间所执行的键值比较次数。设 $f(n,\\Delta)$ 表示在具有堆无序度量 $\\Delta$ 的 $n$ 个键的输入数组上执行堆化操作所需的键值比较次数。\n\n仅从上述核心定义和标准的完全二叉树索引规则出发，通过对下沉操作在完全二叉树上的运作方式进行推理，推导出 $f(n,\\Delta)$ 的一个有根据的表达式和界限。然后，实现一个程序，该程序：\n- 对于一组 $(n,\\Delta)$ 对，使用上述赋值方法构造数组，\n- 对每个构造的数组运行 Floyd 的自底向上堆化算法，同时计算键值比较次数，\n- 在单行中输出测得的 $f(n,\\Delta)$ 值列表。\n\n目标是通过构造和测量来测试，当 $\\Delta$ 从 $0$ 变化到 $n-1$ 时，$f(n,\\Delta)$ 是否在 $O(n)$ 和 $O(n \\log n)$ 之间插值。\n\n使用以下参数值 $(n,\\Delta)$ 的测试套件来覆盖有代表性的情况，包括边界测试和压力测试：\n1. $(1,0)$,\n2. $(7,0)$,\n3. $(7,6)$,\n4. $(31,0)$,\n5. $(31,15)$,\n6. $(31,30)$,\n7. $(100,0)$,\n8. $(100,50)$,\n9. $(100,99)$.\n\n对于每个测试用例，计算并记录如上定义的整数 $f(n,\\Delta)$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[f(1,0),f(7,0),\\dots]$）。不应打印任何额外的文本或格式。", "solution": "出发点是基于数组的二叉最大堆的定义，该数组被索引为一棵完全二叉树，以及局部堆属性 $A[i] \\geq A[2i+1]$ 和 $A[i] \\geq A[2i+2]$，此属性适用于每个存在子节点的内部节点 $i$。堆无序度量 $\\Delta(A)$ 被定义为违反此属性的父子边的数量。构造方法为根节点赋值 $A(0)=0$，并且对于每个子节点索引 $j$（其父节点为 $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$），如果 $(p \\to j)$ 是一个指定的违反，则设置 $A(j) = A(p) + 1$，否则设置 $A(j) = A(p) - 1$。由于树是无环的，并且这些约束是局部的且一致的，因此存在满足所有指定不等式的数值分配，如上所述。根据构造，对于每个指定的违反边，我们有 $A(p)  A(j)$；对于每个非违反边，我们有 $A(p)  A(j)$；因此，这种赋值方法恰好产生 $\\Delta$ 次违反。由于我们只使用 $\\pm 1$ 的整数增量，不同节点的值可能重合，但最大堆属性只关心成对的父子比较，并通过这种构造得到正确控制。\n\n我们现在考虑通过 Floyd 自底向上堆化进行堆构造的成本，记为 $f(n,\\Delta)$，以所有下沉操作期间执行的键值比较次数来衡量。Floyd 的方法从内部节点索引 $i = \\left\\lfloor \\frac{n}{2} \\right\\rfloor - 1$ 开始，向下直到 $0$，对每个节点启动下沉操作。在节点 $i$ 处的下沉过程如下：重复选择较大的子节点（当左右子节点都存在时，这最多需要一次键值比较），并将当前节点的键与该较大子节点进行比较（一次键值比较）。如果当前节点的键大于或等于较大子节点的键，则该节点的下沉操作停止；否则，交换并从子节点的位置继续。因此，在一次下沉操作中，每下降一层，最多执行两次键值比较（一次用于选择较大的子节点，一次用于测试节点和较大子节点之间的堆属性），而在只有一个子节点的情况下，每层只需要一次键值比较。\n\n一个包含 $n$ 个节点的完全二叉树的高度以 $\\lfloor \\log_2 n \\rfloor$ 为界。设 $h(i)$ 表示以 $i$ 为根的子树的高度（沿最长路径到叶节点的距离）。在自底向上堆化中，所有内部节点可能遍历的总层数受总和 $\\sum_{i=0}^{\\lfloor n/2 \\rfloor - 1} h(i)$ 的限制。对于一棵完全二叉树，这个总和是 $O(n)$；这个经典界限源于层级结构：大约有 $n/2$ 个高度为 $1$ 的节点，$n/4$ 个高度为 $2$ 的节点，依此类推，得出\n$$\n\\sum_{i} h(i) \\leq \\sum_{d=1}^{\\lfloor \\log_2 n \\rfloor} d \\cdot \\frac{n}{2^d} = n \\cdot \\sum_{d=1}^{\\infty} \\frac{d}{2^d} = O(n).\n$$\n因此，每层计两次键值比较，Floyd 堆化执行的总键值比较次数满足\n$$\nf(n,\\Delta) \\leq c \\cdot n\n$$\n其中 $c$ 是一个与 $\\Delta$ 无关的常数。此外，因为每个内部节点至少执行一次键值比较来确定是否需要进行下沉操作（用于选择较大的子节点或与单个子节点比较），我们也有一个下界 $f(n,\\Delta) \\geq c' \\cdot n$，其中 $c'$ 是某个常数。因此，对于 Floyd 堆化，成本 $f(n,\\Delta)$ 对所有允许的 $\\Delta \\in \\{0,1,\\ldots,n-1\\}$ 都是一致的 $\\Theta(n)$。\n\n经验测试要求验证当 $\\Delta$ 变化时，$f(n,\\Delta)$ 是否在 $O(n)$ 和 $O(n \\log n)$ 之间插值。上述推导表明，对于 Floyd 方法，$f(n,\\Delta)$ 不会增长到 $O(n \\log n)$；相反，无论 $\\Delta$ 如何，它都保持在 $O(n)$。但是，常数会随违反的结构而变化，因此测量将表明键值比较的次数随 $\\Delta$ 而变化，但不会表现出 $O(n \\log n)$ 的增长。\n\n该程序实现了：\n- 使用指定的赋值规则构造具有受控 $\\Delta$ 的数组，\n- 一个计算键值比较次数的自底向上堆化算法，\n- 一个覆盖边界情况 $\\Delta=0$、最大无序情况 $\\Delta=n-1$ 以及中间值的 $(n,\\Delta)$ 对测试套件。\n\n最终输出是单行，其中包含为给定测试套件测得的 $f(n,\\Delta)$ 值列表，格式为用方括号括起来的逗号分隔列表，如要求所述。不涉及物理单位、角度单位或百分比单位；输出是表示键值比较次数的整数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ComparisonCounter:\n    def __init__(self):\n        self.count = 0\n\n    def lt(self, a, b):\n        # Count a single key comparison for a  b\n        self.count += 1\n        return a  b\n\ndef build_array_with_delta(n, delta):\n    \"\"\"\n    Construct an array A of length n with exactly 'delta' violating edges\n    relative to the max-heap property, using the local assignment rule:\n      A(0) = 0,\n      A(child) = A(parent) + 1 if the edge is designated as violating,\n      A(child) = A(parent) - 1 otherwise.\n    We designate the first 'delta' child indices (1..n-1) as violating.\n    \"\"\"\n    if delta  0 or delta  max(0, n - 1):\n        raise ValueError(\"delta must be in [0, n-1]\")\n    A = [0] * n\n    # Mark violating edges by child index: first 'delta' child indices are violations\n    violate = [False] * n\n    for j in range(1, 1 + delta):\n        if j  n:\n            violate[j] = True\n    # Assign values level-order using the relation to parent\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left  n:\n            A[left] = A[i] + (1 if violate[left] else -1)\n        if right  n:\n            A[right] = A[i] + (1 if violate[right] else -1)\n    return A\n\ndef compute_delta(A):\n    \"\"\"\n    Compute the heap-disorder metric Delta(A): number of violating parent-child edges.\n    \"\"\"\n    n = len(A)\n    violations = 0\n    for j in range(1, n):\n        p = (j - 1) // 2\n        if A[p]  A[j]:\n            violations += 1\n    return violations\n\ndef heapify_count_comparisons(A):\n    \"\"\"\n    Perform Floyd's bottom-up heapify on array A (max-heap),\n    counting the number of key comparisons.\n    Returns the number of comparisons performed.\n    \"\"\"\n    n = len(A)\n    counter = ComparisonCounter()\n\n    def sift_down(i):\n        # Sift down node at index i\n        while True:\n            left = 2 * i + 1\n            if left = n:\n                break  # no children\n            # Determine larger child\n            right = left + 1\n            larger_child = left\n            if right  n:\n                # Compare left and right child to choose the larger one\n                if counter.lt(A[left], A[right]):\n                    larger_child = right\n            # Compare parent with larger child\n            if not counter.lt(A[i], A[larger_child]):\n                break\n            # Swap and continue\n            A[i], A[larger_child] = A[larger_child], A[i]\n            i = larger_child\n\n    # Bottom-up heapify: start from last internal node down to root\n    start = n // 2 - 1\n    for i in range(start, -1, -1):\n        sift_down(i)\n    return counter.count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 0),\n        (7, 0),\n        (7, 6),\n        (31, 0),\n        (31, 15),\n        (31, 30),\n        (100, 0),\n        (100, 50),\n        (100, 99),\n    ]\n\n    results = []\n    for n, delta in test_cases:\n        A = build_array_with_delta(n, delta)\n        # Optional sanity check (not printed): ensure constructed Delta matches target\n        # assert compute_delta(A) == delta, f\"Constructed Delta {compute_delta(A)} != target {delta}\"\n        # Count comparisons during heapify\n        comparisons = heapify_count_comparisons(A)\n        results.append(comparisons)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3219600"}, {"introduction": "理解算法的平均性能很重要，但探究其最坏情况的边界同样关键。这个练习将挑战你扮演一个“对手”的角色，设计并生成一个能最大化 `buildHeap` 过程中父子交换次数的输入数组。你不仅需要实现一个“对抗性”的输入生成器 [@problem_id:3219678]，还需要将其产生的成本与理论上的最坏情况成本进行比较，从而验证你的构造是否达到了最优。这个过程将加深你对算法性能极限的认识，并连接起理论分析与实际验证。", "problem": "给定一个包含 $n$ 个不同键的二叉最大堆的数组表示，其中索引从 $1$ 开始，索引为 $i$ 的节点的子节点位于索引 $2i$ 和 $2i+1$ 处（只要这些索引不超过 $n$）。考虑 Floyd 的自底向上建堆算法（也称为“build-heap”），该算法从 $i=\\left\\lfloor n/2 \\right\\rfloor$ 到 $i=1$ 对每个内部节点 $i$ 调用下滤（sift-down）操作。将一次下滤操作的成本定义为元素在其遍历路径上为恢复该位置的堆属性而执行的父子节点交换次数。build-heap 的总成本是所有内部节点上这些交换次数的总和。\n\n从堆、数组索引算术和 Floyd 的 build-heap 过程的核心定义出发，推导一个有原则的对抗性输入生成器。对于任意给定的 $n$，该生成器能产生一个 $\\{1,2,\\dots,n\\}$ 的排列，使得 build-heap 执行的父子节点交换总数最大化。证明描述生成器所达到的成本与最坏情况成本接近程度的理论界限，并用堆的形状参数来表示。\n\n您必须从以下基本点出发：\n- 二叉堆的形状不变量：底层树是包含 $n$ 个节点的唯一完全二叉树；数组索引映射 $(i \\mapsto 2i, 2i+1)$ 在索引存在时表示左、右子节点。\n- Floyd 的 build-heap 算法处理索引 $i=\\left\\lfloor n/2 \\right\\rfloor, \\left\\lfloor n/2 \\right\\rfloor - 1, \\dots, 1$，使用下滤操作在每个位置 $i$ 恢复堆属性。\n- 每次下滤操作中，当某个子节点的键值大于当前节点的键值时，会将当前节点的键与其较大的子节点的键交换，此过程重复进行，直到两个子节点都不存在，或两个子节点的键值都不大于当前节点的键值。\n\n您的程序必须：\n- 实现一个生成器，该生成器为索引分配值，使得键值随深度严格递增：对于所有可行的深度 $d$，深度为 $d$ 的所有节点所获得的键值都严格小于深度为 $d+1$ 的所有节点的键值。该生成器必须旨在最大化 build-heap 过程中的父子节点交换总数。\n- 实现 Floyd 的 build-heap 算法并计算父子节点交换的总次数。\n- 实现最坏情况下总交换次数的公式 $$S_{\\max}(n) = \\sum_{i=1}^{\\left\\lfloor n/2 \\right\\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor,$$ 该值等于包含 $n$ 个节点的完全二叉树中每个内部节点的高度（最长向下路径上的边数）之和。使用此公式来评估最优性。\n\n您必须证明该生成器达到了最坏情况，因此比率 $$\\rho(n) = \\frac{S_{\\text{gen}}(n)}{S_{\\max}(n)} = 1$$，并根据 $n$ 和 $H=\\left\\lfloor \\log_2 n \\right\\rfloor$ 推导 $S_{\\max}(n)$ 基于形状的界限，包括 $n=2^H$ 和 $n=2^{H+1}-1$ 的特殊情况。\n\n测试套件和最终输出：\n- 使用以下测试值 $n$：$[1,2,3,4,7,8,10,15]$。\n- 对于测试套件中的每个 $n$，计算比率 $\\rho(n)$ 的小数值。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个比率格式化为恰好三位小数（例如，$[1.000,1.000,1.000]$）。如果 $S_{\\max}(n)=0$，按照约定将 $\\rho(n)$ 定义为 $1.000$，因为生成器达到了 $0$ 这个最大成本。", "solution": "所述问题是有效的。它在数据结构和算法领域有科学依据，问题阐述清晰，目标明确，约束充分，并以精确、客观的语言表达。它提出了一个涉及形式化证明和算法实现的非平凡挑战。因此，我们可以着手提供完整的解决方案。\n\n问题要求为 Floyd 的 build-heap 算法推导一个对抗性输入生成器，以最大化父子节点交换的总次数。然后，我们必须证明此生成器实现的成本 $S_{\\text{gen}}(n)$ 等于理论上的最大最坏情况成本 $S_{\\max}(n)$，并针对特定情况，根据堆的形状参数推导出此成本的表达式。\n\n让我们首先分析 `sift-down` 操作的成本，这是 build-heap 过程的基本组成部分。在最大堆中，对索引为 $i$ 的节点执行 `sift-down` 操作旨在恢复堆属性，即任何节点 $j$ 的键必须大于或等于其子节点的键。该操作通过重复地将当前节点的键与其较大子节点的键进行交换（如果该子节点的键更大）来进行。此过程一直持续到该键到达一个位置，其值大于或等于其两个子节点的键，或者它成为一个叶节点。\n\n对节点 $i$ 进行单次 `sift-down` 调用的成本定义为执行的交换次数。当最初位于节点 $i$ 的键被迫在树中尽可能向下移动时，此交换次数达到最大值。从节点 $i$ 到其后代叶节点的最长可能路径定义了节点 $i$ 的*高度*。为了让一个键走完这条完整路径，它的值必须小于它沿途与之比较的所有节点的键。在一个大小为 $n$ 的完全二叉树中，索引为 $i$ 的节点的高度 $h(i)$ 由 $h(i) = \\lfloor \\log_2(n/i) \\rfloor$ 给出，其中高度是到叶节点的最长向下路径上的边数。\n\nFloyd 的 build-heap 算法遍历所有内部节点，从 $i = \\lfloor n/2 \\rfloor$ 到 $1$，并在每个节点上应用 `sift-down`。总成本 $S(n)$ 是这些单独调用成本的总和：\n$$S(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} C_i$$\n其中 $C_i$ 是 `sift-down(i)` 的交换次数。单次 `sift-down(i)` 的最大可能成本是 $h(i)$。因此，build-heap 的最大可能总成本是所有内部节点高度的总和：\n$$S_{\\max}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor$$\n这与问题陈述中提供的公式相符。\n\n我们的任务是设计一个对抗性输入生成器。目标是构造一个键集 $\\{1, 2, \\dots, n\\}$ 的排列，迫使每次 `sift-down` 调用都达到其最大可能成本。为了使任意内部节点 $i$ 处的键下移至叶节点，其值必须小于它将与之比较的任何键。这提出了一个通用原则：将较小的键放在较浅的深度，将较大的键放在较深的深度。问题明确提出了这样一个生成器：为索引分配值，使得键值随深度严格增加。\n\n让我们将此生成器形式化。索引为 $i$ 的节点（根节点深度为 $0$）的深度为 $d(i) = \\lfloor \\log_2 i \\rfloor$。生成器创建一个 $\\{1, 2, \\dots, n\\}$ 的排列 `A`，使得对于任意两个索引 $j$ 和 $k$，如果 $d(j)  d(k)$，则 $A[j]  A[k]$。这可以通过将所有节点索引 $i \\in \\{1, \\dots, n\\}$ 按其深度 $d(i)$ 排序，然后将键 $1, 2, \\dots, n$ 按升序分配给这个排序序列中的节点来实现。\n\n现在，我们必须证明这个生成器达到了最大成本 $S_{\\max}(n)$。考虑对任意内部节点 $i$ 进行的 `sift-down` 操作。根据构造，键 $A[i]$ 小于其子节点 $A[2i]$ 和（如果存在）$A[2i+1]$ 的键，因为子节点处于更深的层次。`sift-down` 过程会将 $A[i]$ 与其子节点中键值较大的那个进行交换。因此，键 $A[i]$ 移动到一个深度为 $d(i)+1$ 的新节点。下一层的键（原为 $i$ 的孙辈）位于深度 $d(i)+2$。我们的构造保证了键 $A[i]$ 也小于这些键。这个过程将重复进行，键 $A[i]$ 在每一层都会被向下交换，直到到达一个叶节点。因此，交换的次数将恰好是它下降的层数，即节点 $i$ 的高度 $h(i)$。\n\n由于这对每个内部节点 $i \\in \\{1, \\dots, \\lfloor n/2 \\rfloor\\}$ 都成立，因此生成输入的总成本为：\n$$S_{\\text{gen}}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor$$\n这与 $S_{\\max}(n)$ 的表达式完全相同。因此，我们证明了 $S_{\\text{gen}}(n) = S_{\\max}(n)$。所以，对于所有 $n  1$，比率 $\\rho(n) = S_{\\text{gen}}(n) / S_{\\max}(n)$ 等于 $1$。对于 $n=1$，没有内部节点，所以 $S_{\\max}(1)=0$ 且 $S_{\\text{gen}}(1)=0$。根据问题的约定，$\\rho(1)=1$。\n\n最后，我们为两种特殊情况推导 $S_{\\max}(n)$ 基于形状的界限。一个已知且强大的恒等式（可通过归纳法证明）指出，一个包含 $n$ 个节点的完全二叉树中所有节点的高度之和为 $n - d(n)$，其中 $d(n)$ 是 $n$ 的二进制表示中置位（1）的数目。由于任何叶子节点的高度都是 $0$，这个和等于内部节点的高度之和：\n$$S_{\\max}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = n - d(n)$$\n\n使用这个恒等式，我们可以为指定的特殊情况找到精确的表达式。堆的总高度为 $H = \\lfloor \\log_2 n \\rfloor$。\n\n1.  **情况 $n=2^{H+1}-1$（一个完美二叉树）：** 该树的高度为 $H$。其二进制表示由 $H+1$ 个连续的 1 组成。因此，$d(n) = H+1$。最坏情况下的成本是：\n    $$S_{\\max}(n) = n - d(n) = n - (H+1)$$\n2.  **情况 $n=2^H$（一个最后一层只有一个节点的完全二叉树）：** 对于这种情况，问题陈述中对 $H$ 的定义存在轻微的歧义。对于 $n=2^k$，树的高度是 $k$，而 $\\lfloor \\log_2 n \\rfloor$ 的值也是 $k$。我们假设问题意指 $n=2^k$，对于某个整数 $k \\geq 1$，此时树高为 $k$。值 $H = \\lfloor\\log_2 n\\rfloor$ 将等于 $k$。$n=2^k$ 的二进制表示是一个 $1$ 后面跟着 $k$ 个零。因此，$d(n) = 1$。最坏情况下的成本是：\n    $$S_{\\max}(n) = n - d(n) = n - 1$$\n\n这些公式为这些特定堆形状提供了精确的最坏情况成本，用 $n$ 及其相关的高度参数 $H$ 表示。两个推导都证实了交换次数的数量级为 $O(n)$，具体来说，其上界为 $n - O(\\log n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It calculates the ratio rho(n) for each n and prints the results.\n    \"\"\"\n\n    def generate_adversarial_input(n):\n        \"\"\"\n        Generates a permutation of {1, ..., n} that maximizes build-heap cost.\n        Keys are assigned such that they strictly increase with node depth.\n        1-based indexing is used for the heap array.\n        \"\"\"\n        if n == 0:\n            return np.array([], dtype=int)\n        \n        # Create a list of (depth, index) tuples for each node\n        nodes = []\n        for i in range(1, n + 1):\n            depth = int(np.log2(i))\n            nodes.append((depth, i))\n        \n        # Sort nodes primarily by depth, secondarily by index\n        nodes.sort()\n        \n        # Create the array and assign keys {1, 2, ..., n} based on sorted order\n        # The array is of size n+1 to accommodate 1-based indexing.\n        A = np.zeros(n + 1, dtype=int)\n        for key, (_, index) in enumerate(nodes, 1):\n            A[index] = key\n            \n        return A\n\n    def sift_down(A, i, n):\n        \"\"\"\n        Performs the sift-down operation on a max-heap.\n        Starts at index i and restores the heap property downwards.\n        Returns the number of parent-child exchanges.\n        \"\"\"\n        exchanges = 0\n        k = i\n        while True:\n            largest = k\n            left = 2 * k\n            right = 2 * k + 1\n            \n            # Find the largest among the node and its children\n            if left = n and A[left]  A[largest]:\n                largest = left\n            if right = n and A[right]  A[largest]:\n                largest = right\n            \n            # If the current node is already the largest, the sub-heap is valid\n            if largest == k:\n                break\n            \n            # Swap with the largest child and continue sifting down\n            A[k], A[largest] = A[largest], A[k]\n            exchanges += 1\n            k = largest\n            \n        return exchanges\n\n    def get_generated_cost(n):\n        \"\"\"\n        Calculates the total exchanges for build-heap on the adversarial input.\n        \"\"\"\n        if n = 1:\n            return 0\n        \n        A = generate_adversarial_input(n)\n        total_exchanges = 0\n        \n        # Floyd's build-heap algorithm\n        for i in range(n // 2, 0, -1):\n            total_exchanges += sift_down(A, i, n)\n            \n        return total_exchanges\n\n    def get_max_cost(n):\n        \"\"\"\n        Calculates the theoretical maximum cost using the formula\n        S_max(n) = sum of heights of all internal nodes.\n        \"\"\"\n        if n = 1:\n            return 0\n            \n        total_height = 0\n        for i in range(1, n // 2 + 1):\n            height = int(np.log2(n / i))\n            total_height += height\n            \n        return total_height\n    \n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 7, 8, 10, 15]\n\n    results = []\n    for n in test_cases:\n        s_gen = get_generated_cost(n)\n        s_max = get_max_cost(n)\n        \n        # The ratio rho(n) = S_gen(n) / S_max(n).\n        # By convention, if S_max(n) is 0, the ratio is 1.000.\n        if s_max == 0:\n            rho = 1.0\n        else:\n            rho = s_gen / s_max\n            \n        results.append(f\"{rho:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3219678"}]}