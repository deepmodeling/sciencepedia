{"hands_on_practices": [{"introduction": "即使是精心设计的哈希函数也无法完全避免冲突。本练习将通过一个实际的编程任务，让您亲手构造导致哈希冲突的键集合 [@problem_id:3238328]。您将使用经典的 `djb2` 哈希函数，通过系统性地生成字符串，直到在同一个桶中找到指定数量的冲突键，从而直观地体验随着键数量的增加和装载因子的上升，哈希冲突如何变得不可避免。", "problem": "给定一个特定的字符串哈希函数族和一个将哈希值映射到桶索引的精确规则。您的任务是针对几种参数设置，通过算法构造一组不同的、全部落入同一个桶中的可打印键，并计算首次发生这种达到要求大小的冲突时的负载因子。\n\n定义和假设：\n- 哈希函数是经典的 djb2 函数。对于一个有限的字符串 $s = c_1 c_2 \\dots c_n$，哈希值 $H(s)$ 通过迭代定义：$h_0 = 5381$，对于每个字符 $c_i$，$h_i = 33 \\cdot h_{i-1} + \\operatorname{ord}(c_i)$，其中 $\\operatorname{ord}(c_i)$ 是字符 $c_i$ 的美国信息交换标准代码（ASCII）码。最终的哈希值为 $H(s) = h_n$，使用无限精度整数算术（即无溢出）进行计算。\n- 对于大小为 $M$ 的哈希表，桶索引为 $B(s) = H(s) \\bmod M$，这是一个在 $\\{0,1,\\dots,M-1\\}$ 范围内的整数。\n- 将 $N$ 个键插入大小为 $M$ 的表中后的负载因子 $\\alpha$ 为 $\\alpha = N / M$，并且必须以小数形式报告（而非百分比）。\n\n每个测试用例需遵循的构造规则：\n- 字母表是给定的一个由不同可打印字符组成的有限集合。键是基于该字母表的任意非空字符串。\n- 按长度非递减的顺序枚举键，对于相同长度的键，则按字母表诱导的字典序枚举。具体来说，首先按字典序枚举所有长度为 1 的字符串；然后是长度为 2 的，以此类推。\n- 将键逐个（概念上）插入一个初始为空、有 $M$ 个桶的哈希表中，使用桶索引 $B(s)$，并统计到目前为止落入每个桶中的键的数量。\n- 当某个桶的计数值首次达到至少为 $k$ 时停止，其中 $k$ 是该测试用例的目标冲突重数。在那个确切的停止时刻：\n  - 令 $L$ 为最先落入该桶的 $k$ 个不同键中的最大长度（这将等于达到停止条件时当前枚举的长度）。\n  - 令 $N$ 为截至（并包括）导致停止条件的那个键所枚举的键的总数。\n  - 令 $\\alpha = N / M$ 为停止时的负载因子，表示为一个四舍五入到六位小数的小数。\n  - 令 $b$ 为第一个达到占用数 $k$ 的桶的索引（在 $\\{0,1,\\dots,M-1\\}$ 范围内）。\n\n您的程序必须精确实现上述过程，并为每个测试用例返回三元组 $[L, \\alpha, b]$。\n\n您必须使用的基本依据：\n- 上文给出的 djb2 哈希的定义、通过模运算获得 $B(s)$ 的算术方法，以及负载因子 $\\alpha = N / M$ 的定义。\n\n测试套件：\n- 用例 A: $M = 16$, $k = 3$, 字母表 $= \\text{\"ab\"}$。\n- 用例 B: $M = 32$, $k = 4$, 字母表 $= \\text{\"abc\"}$。\n- 用例 C: $M = 1$, $k = 5$, 字母表 $= \\text{\"ab\"}$。\n- 用例 D: $M = 64$, $k = 3$, 字母表 $= \\text{\"abcd\"}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个内部列表对应一个测试用例的结果 $[L,\\alpha,b]$，顺序与测试套件中的顺序相同。负载因子 $\\alpha$ 必须四舍五入到六位小数。例如：$[[L_1,\\alpha_1,b_1],[L_2,\\alpha_2,b_2],[L_3,\\alpha_3,b_3],[L_4,\\alpha_4,b_4]]$。", "solution": "问题陈述被评估为有效。它在计算机科学领域，特别是在哈希表和冲突分析方面，具有科学依据。djb2 哈希函数、桶索引、键生成和停止条件的定义是精确、无歧义且自洽的。这构成了一个适定问题 (well-posed problem)，对于每个测试用例都有一个唯一的、确定性可计算的解。不存在矛盾、未定义的术语或违反数学、逻辑原则的情况。该任务是指定算法的直接实现。\n\n解决方案是通过直接模拟所述过程找到的。对于每个由哈希表大小 $M$、目标冲突重数 $k$ 和字符字母表指定的测试用例，我们执行以下步骤：\n\n1.  初始化一个数据结构来维护 $M$ 个桶中每个桶的键计数。一个大小为 $M$、所有元素初始化为零的整数数组是合适的。我们可以将此数组表示为 `counts`，其中 `counts`[$j$] 存储映射到桶 $j$ 的键的数量。\n\n2.  将已枚举键的总数 $N$ 初始化为 0。\n\n3.  按指定顺序开始生成键：长度非递减，固定长度内按字典序。这从所有长度为 $L=1$ 的键开始，然后是所有长度为 $L=2$ 的键，以此类推。\n\n4.  对于每个生成的键字符串 $s = c_1 c_2 \\dots c_L$：\n    a. 递增总键计数器 $N$。\n    b. 计算 djb2 哈希值 $H(s)$。该过程由以下递归关系定义：\n    $$h_0 = 5381$$\n    $$h_i = (33 \\cdot h_{i-1}) + \\operatorname{ord}(c_i) \\quad \\text{for } i \\in \\{1, 2, \\dots, L\\}$$\n    最终哈希值为 $H(s) = h_L$。计算必须使用不会溢出的整数算术，这对于像 Python 这样的语言是标准配置。\n\n    c. 使用模运算规则确定桶索引 $b$：\n    $$b = H(s) \\bmod M$$\n    结果 $b$ 将是集合 $\\{0, 1, \\dots, M-1\\}$ 中的一个整数。\n\n    d. 递增确定桶的计数：`counts`[$b$] = `counts`[$b$] $+ 1$。\n\n    e. 检查是否满足停止条件。如果 `counts`[$b$] 等于目标重数 $k$，则过程终止。\n\n5.  终止时，我们已找到第一个累积了 $k$ 个键的桶。在此确切时刻，我们记录所需的三元组 $[L, \\alpha, b]$：\n    -   $L$ 是其插入操作触发了停止条件的键的长度。\n    -   $N$ 是到此为止枚举的键的总数。\n    -   负载因子为 $\\alpha = N / M$。该值作为浮点数计算，然后按规定四舍五- 入到六位小数。\n    -   $b$ 是达到计数值 $k$ 的桶的索引。\n\n此过程是确定性的，并对所提供的四个测试用例中的每一个重复执行：\n-   用例 A：($M=16$, $k=3$, 字母表=\"ab\")\n-   用例 B：($M=32$, $k=4$, 字母表=\"abc\")\n-   用例 C：($M=1$, $k=5$, 字母表=\"ab\")：这是一个特殊情况，其中 $M=1$，因此所有键都哈希到桶 0。问题简化为在枚举序列中找到第 5 个键。\n-   用例 D：($M=64$, $k=3$, 字母表=\"abcd\")\n\n实现将使用一个针对键长度 $L$ 的循环，以及一个嵌套机制（例如 Python 中的 `itertools.product`）来生成该长度的所有字符串，然后再继续处理长度 $L+1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the hash collision problem for the given test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (M, k, alphabet)\n        (16, 3, \"ab\"),\n        (32, 4, \"abc\"),\n        (1, 5, \"ab\"),\n        (64, 3, \"abcd\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, alphabet = case\n        result = find_collision(m, k, alphabet)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list is '[item1, item2, ...]'\n    # Joining these with a comma and wrapping in brackets gives the desired output.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef djb2_hash(s: str) -> int:\n    \"\"\"\n    Computes the djb2 hash for a given string s.\n    Python's integers handle arbitrary precision, satisfying the\n    \"unbounded integer arithmetic\" requirement.\n    \"\"\"\n    h = 5381\n    for char in s:\n        # The operation is h = (h * 33) + ord(char)\n        h = (h  5) + h + ord(char)\n    return h\n\ndef find_collision(m: int, k: int, alphabet: str) - list:\n    \"\"\"\n    Finds the first occurrence of k collisions in a single bucket for the given parameters.\n\n    Args:\n        m: The size of the hash table.\n        k: The target collision multiplicity.\n        alphabet: The set of characters to build keys from.\n\n    Returns:\n        A list containing [L, alpha, b] where:\n        L is the length of the string that caused the k-th collision.\n        alpha is the load factor at that time, rounded to 6 decimal places.\n        b is the bucket index with k collisions.\n    \"\"\"\n    bucket_counts = np.zeros(m, dtype=int)\n    num_keys_total = 0\n    current_length = 1\n\n    while True:\n        # Generate all keys of the current length in lexicographic order.\n        # itertools.product ensures this order.\n        keys_of_length_l = itertools.product(alphabet, repeat=current_length)\n\n        for key_tuple in keys_of_length_l:\n            key_str = \"\".join(key_tuple)\n            num_keys_total += 1\n\n            # Calculate hash and bucket index\n            hash_val = djb2_hash(key_str)\n            bucket_index = hash_val % m\n\n            # Update bucket count and check stopping condition\n            bucket_counts[bucket_index] += 1\n            if bucket_counts[bucket_index] >= k:\n                # Stopping condition met. Calculate results.\n                load_factor = num_keys_total / m\n                alpha_rounded = round(load_factor, 6)\n                \n                return [current_length, alpha_rounded, bucket_index]\n        \n        # If no collision found, move to the next length\n        current_length += 1\n\nsolve()\n```", "id": "3238328"}, {"introduction": "在开放寻址哈希表中，每次冲突都会引发一次“探查”序列来寻找空槽，这直接影响了性能。一个关键的理论结果是，插入操作的预期冲突次数与装载因子 $\\alpha$ 密切相关，并且随着 $\\alpha$ 接近 1 而急剧增长。这个练习要求您推导并应用计算预期总冲突数的公式，从而将统一哈希的理论分析与哈希表填充过程中的可观察行为联系起来 [@problem_id:3238369]。", "problem": "您将实现一个程序，从第一性原理出发，对一个抽象的开放地址哈希表进行反向工程。该哈希表模拟真实世界的行为，但只暴露可观察的效应。您的任务是反向工程出其碰撞行为和调整大小的阈值（最大负载因子）。您的目标是，仅根据第一次调整大小发生的时间，推导出该哈希表的最大负载因子必须是多少，并在均匀哈希模型下，计算在该第一次调整大小之前发生的期望碰撞总数。\n\n定义和假设：\n- 该表是一个开放地址哈希表，其容量 $m \\in \\mathbb{N}$ 为2的幂，初始容量为 $m = m_0$。\n- 负载因子为 $\\alpha = n / m$，其中 $n$ 是存储的键的数量，$m$ 是当前容量。\n- 碰撞是指在插入过程中尝试探测一个已填充的槽位；对于某次给定的插入操作，碰撞次数等于探测次数减一。\n- 哈希表使用一个由未知阈值 $0  \\lambda^\\star \\leq 1$ 定义的调整大小规则：在某次插入操作使得键总数达到 $n$ 后，如果 $n > \\lambda^\\star m$，哈希表将立即调整大小至容量 $2m$。不发生删除操作。\n- 您可以假设均匀哈希：每次探测都会检查一个独立的槽位，该槽位在 $m$ 个槽位中是均匀随机选择的，并且为了计算期望，每次探测都与其他探测独立。您需要计算期望值，而不是模拟随机探测。\n\n您的任务：\n1. 为未知的最大负载因子阈值推导一个反向工程估计量。假设在向初始容量为 $m$ 的表中进行第 $(c+1)$ 次插入后，立即发生了第一次调整大小。将估计量 $\\widehat{\\lambda}$ 定义为\n   $$ \\widehat{\\lambda} = \\frac{c}{m}. $$\n   这个定义反映了未触发调整大小的最大表满率。\n2. 在均匀哈希模型下，计算截至并包括第 $c$ 次插入（即在任何调整大小之前）的总期望碰撞次数。将此值表示为一个实数。\n3. 对于每个测试用例，生成一个结果三元组 $[\\widehat{\\lambda}, \\text{expected\\_collisions}, c]$，其中：\n   - $\\widehat{\\lambda}$ 报告为保留小数点后六位的小数，\n   - $\\text{expected\\_collisions}$ 报告为保留小数点后六位的小数，\n   - $c$ 是一个整数，等于在第一次调整大小发生之前执行的插入次数。如果在表满之前没有发生调整大小，则 $c = m$。\n\n您必须基于以下基本原理：\n- 负载因子 $\\alpha = n/m$ 的定义。\n- 几何分布，描述了直到首次成功所需的独立伯努利试验次数：如果成功概率为 $p \\in (0,1]$，则期望试验次数为 $1/p$。\n- 调和数 $H_k = \\sum_{i=1}^k \\frac{1}{i}$，并约定 $H_0 = 0$。\n\n不要使用未从上述基本原理推导出的快捷公式；请解释您的期望碰撞表达式是如何从第一性原理得出的。\n\n测试套件：\n您将把您的程序应用于以下独立的测试用例。每个测试用例为黑盒表设置初始容量 $m_0$ 和隐藏的最大负载因子阈值 $\\lambda^\\star$。如前所述，黑盒表在调整大小时会将容量加倍。\n\n- 测试用例 A: $m_0 = 8$, $\\lambda^\\star = \\frac{2}{3}$。\n- 测试用例 B: $m_0 = 16$, $\\lambda^\\star = 0.5$。\n- 测试用例 C: $m_0 = 4$, $\\lambda^\\star = \\frac{7}{8}$。\n- 测试用例 D: $m_0 = 8$, $\\lambda^\\star = 1.0$。\n\n每个测试用例的操作协议：\n- 逐个插入不同的整数键 $0,1,2,\\dots$，并在以下情况中最早发生时停止：\n  1) 观察到第一次调整大小事件（在一次插入后，容量立即从 $m$ 变为 $2m$），或\n  2) 表在未调整大小的情况下达到 $n = m$。\n- 令 $c$ 为在调整大小发生前插入的键的数量（如果表满前未发生调整大小，则 $c=m$）。\n\n要求输出格式：\n- 您的程序应生成单行输出，其中包含一个按 A、B、C、D 顺序排列的包含四个三元组的列表。每个三元组的形式必须为 $[\\widehat{\\lambda},\\text{expected\\_collisions},c]$，其中两个实数需四舍五入到小数点后六位。不需要单位。整行必须看起来像一个有效的列表字面量，没有多余的空格，例如：\n  [[0.625000,2.076190,5],[...],[...],[...]]", "solution": "我们从定义和基本概率事实出发。负载因子为 $\\alpha = n/m$，其中 $n$ 是存储的键的数量，$m$ 是容量。在插入过程中，当一次探测检查到一个已被占用的槽位时，就会发生碰撞。在均匀哈希模型下，每次探测被建模为一次独立的伯努利试验，其成功（找到一个空槽位）的概率为 $1 - \\alpha$，因为空槽位的比例是 $1 - \\alpha$。\n\n1) 估计最大负载因子阈值。\n\n设未知的调整大小阈值为 $\\lambda^\\star \\in (0,1]$，并假设当某次插入后键数 $n$ 满足 $n > \\lambda^\\star m$ 时，表会立即调整大小。令 $c$ 表示在容量为 $m$ 时未触发调整大小的最大插入次数。那么有 $c \\le \\lambda^\\star m  c + 1$。定义估计量\n$$ \\widehat{\\lambda} = \\frac{c}{m} $$\n会得到与观察到的行为兼容的、未触发调整大小的最大比率。即使在表满之前没有发生调整大小，这个定义也是一致且定义良好的：如果 $\\lambda^\\star = 1$，那么 $c = m$ 且 $\\widehat{\\lambda} = 1$。\n\n2) 第一次调整大小前的期望碰撞次数。\n\n考虑在任何调整大小之前，向容量为 $m$ 的表中进行的插入操作，此时表中已有 $i$ 个键，其中 $i \\in \\{0,1,2,\\dots,c-1\\}$。此次插入前的负载因子是\n$$ \\alpha_i = \\frac{i}{m}. $$\n在均匀哈希模型下，为了计算期望，每次探测命中空槽位的概率为 $1 - \\alpha_i$，且与之前的探测独立。找到第一个空槽位所需的探测次数 $X_i$ 服从成功概率为 $p = 1 - \\alpha_i$ 的几何分布，因此\n$$ \\mathbb{E}[X_i] = \\frac{1}{1 - \\alpha_i}. $$\n该次插入的碰撞次数等于 $X_i - 1$，所以\n$$ \\mathbb{E}[\\text{collisions on insertion } i] = \\mathbb{E}[X_i - 1] = \\frac{1}{1 - \\alpha_i} - 1 = \\frac{\\alpha_i}{1 - \\alpha_i}. $$\n对 $i$ 从 $0$ 到 $c - 1$ 求和，得到第一次调整大小前的期望总碰撞次数：\n$$ \\mathbb{E}[\\text{total collisions up to } c] = \\sum_{i=0}^{c-1} \\frac{\\alpha_i}{1 - \\alpha_i} = \\sum_{i=0}^{c-1} \\frac{\\frac{i}{m}}{1 - \\frac{i}{m}} = \\sum_{i=0}^{c-1} \\frac{i}{m - i}. $$\n为简化计算，令 $j = m - i$。当 $i$ 从 $0$ 取到 $c-1$ 时，$j$ 从 $m$ 递减到 $m - c + 1$。注意到\n$$ \\frac{i}{m - i} = \\frac{m - j}{j} = \\frac{m}{j} - 1. $$\n因此，\n$$ \\sum_{i=0}^{c-1} \\frac{i}{m - i} = \\sum_{j=m - c + 1}^{m} \\left( \\frac{m}{j} - 1 \\right) = m \\sum_{j=m - c + 1}^{m} \\frac{1}{j} - c. $$\n使用调和数 $H_k = \\sum_{\\ell=1}^{k} \\frac{1}{\\ell}$ 和 $H_0 = 0$，我们得到闭式解：\n$$ \\mathbb{E}[\\text{total collisions up to } c] = m \\left( H_m - H_{m - c} \\right) - c. $$\n对于所有 $c \\le m$，该表达式都是有限的，包括边界情况 $c = m$（此时 $H_{m - c} = H_0 = 0$）。当 $c$ 接近 $m$ 时，它的增长数量级为 $m \\log m$，这反映了将开放地址哈希表填充到接近满时的急剧成本。\n\n3) 应用于测试用例。\n\n对于每个测试用例，我们向黑盒表中执行插入操作，直到发生第一次调整大小或表在未调整大小的情况下达到 $n = m$。我们由此读出 $c$ 并计算\n$$ \\widehat{\\lambda} = \\frac{c}{m}, \\quad \\text{and} \\quad \\mathbb{E}[\\text{total collisions}] = m \\left( H_m - H_{m - c} \\right) - c. $$\n我们将 $\\widehat{\\lambda}$ 和期望碰撞总数报告为四舍五入到六位小数的十进制数，将 $c$ 报告为整数。\n\n- 对于测试用例 A，$m = 8$，$\\lambda^\\star = \\frac{2}{3}$，未触发调整大小的最大键数是 $c = \\left\\lfloor \\frac{2}{3} \\cdot 8 \\right\\rfloor = 5$，因此 $\\widehat{\\lambda} = \\frac{5}{8} = 0.625000$。期望总碰撞次数等于 $8 \\left( H_8 - H_3 \\right) - 5 \\approx 2.076190$。\n- 对于测试用例 B，$m = 16$，$\\lambda^\\star = 0.5$，未触发调整大小的最大键数是 $c = \\left\\lfloor 0.5 \\cdot 16 \\right\\rfloor = 8$，因此 $\\widehat{\\lambda} = \\frac{8}{16} = 0.500000$。期望总碰撞次数等于 $16 \\left( H_{16} - H_8 \\right) - 8 \\approx 2.605950$。\n- 对于测试用例 C，$m = 4$，$\\lambda^\\star = \\frac{7}{8}$，我们有 $c = \\left\\lfloor \\frac{7}{8} \\cdot 4 \\right\\rfloor = 3$，$\\widehat{\\lambda} = \\frac{3}{4} = 0.750000$，期望总碰撞次数等于 $4 \\left( H_4 - H_1 \\right) - 3 \\approx 1.333333$。\n- 对于测试用例 D，$m = 8$，$\\lambda^\\star = 1.0$，在表满之前不会发生调整大小，所以 $c = 8$，$\\widehat{\\lambda} = \\frac{8}{8} = 1.000000$，期望总碰撞次数等于 $8 \\left( H_8 - H_0 \\right) - 8 \\approx 13.742857$。\n\n这些结果直接来自于估计量的定义以及在均匀哈希下从几何分布推导出的调和数求和公式。程序将完全按照规定计算这些值，并根据要求的输出格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BlackBoxHashTable:\n    \"\"\"\n    A minimal black-box open-addressing table model:\n    - Capacity starts at m (power of two).\n    - After an insertion that brings count to n, if n > lambda_star * m, capacity doubles.\n    - No deletions, no actual slot layout; we only model counts and resize policy.\n    \"\"\"\n    def __init__(self, initial_capacity: int, lambda_star: float):\n        self.capacity = initial_capacity\n        self.lambda_star = float(lambda_star)\n        self.count = 0\n        self.initial_capacity = initial_capacity\n\n    def insert(self) -> bool:\n        \"\"\"\n        Insert a new distinct key (keys are implicit). Returns True if a resize happened\n        immediately after this insertion, else False. If the table is already full (count == capacity),\n        insertion does nothing and returns False (no resize).\n        \"\"\"\n        # If full, cannot insert (no resize here; by spec we will stop at full)\n        if self.count >= self.capacity:\n            return False\n\n        # Perform insertion\n        self.count += 1\n\n        # Check resize condition: strictly exceeds threshold after insertion\n        if self.count > self.lambda_star * self.capacity:\n            # Resize to double the capacity\n            self.capacity *= 2\n            return True\n\n        return False\n\n\ndef harmonic(n: int) -> float:\n    \"\"\"Compute H_n = sum_{k=1}^n 1/k with H_0 = 0.\"\"\"\n    if n == 0:\n        return 0.0\n    # For small n in this test suite, direct summation is precise enough\n    return sum(1.0 / k for k in range(1, n + 1))\n\n\ndef expected_total_collisions_before_resize(m: int, c: int) -> float:\n    \"\"\"\n    Under uniform hashing, the expected total number of collisions up to c insertions is:\n        m * (H_m - H_{m-c}) - c\n    where H_k are harmonic numbers and H_0 = 0.\n    \"\"\"\n    H_m = harmonic(m)\n    H_m_minus_c = harmonic(m - c)\n    return m * (H_m - H_m_minus_c) - c\n\n\ndef estimate_lambda_and_collisions(initial_capacity: int, lambda_star: float):\n    \"\"\"\n    Drive the black-box table until first resize or full.\n    Return (lambda_hat, expected_collisions, c), where:\n      - lambda_hat = c / m\n      - expected_collisions = m * (H_m - H_{m-c}) - c\n      - c = number of successful insertions before the first resize (or full)\n    \"\"\"\n    box = BlackBoxHashTable(initial_capacity, lambda_star)\n    m = initial_capacity\n    c = 0\n    resized = False\n    # Insert until first resize or table becomes full\n    while True:\n        if box.count >= box.capacity:\n            # full, stop\n            c = box.count\n            break\n        did_resize = box.insert()\n        if did_resize:\n            # The resize happened right after this insertion; this insertion is (c+1)-th\n            # We define c as the number of insertions before a resize occurs.\n            c = box.count - 1\n            resized = True\n            break\n        # No resize yet, continue\n        # We will set c only when we stop; keep looping\n\n    if not resized and c == 0:\n        # If we exited without resize but loop didn't run (capacity 0 case not in tests),\n        # ensure c reflects the count\n        c = box.count\n\n    lambda_hat = c / m if m > 0 else 0.0\n    expected_collisions = expected_total_collisions_before_resize(m, c)\n    return lambda_hat, expected_collisions, c\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple is (initial_capacity m0, hidden threshold lambda_star).\n    test_cases = [\n        (8, 2.0 / 3.0),   # Test case A\n        (16, 0.5),        # Test case B\n        (4, 7.0 / 8.0),   # Test case C\n        (8, 1.0),         # Test case D\n    ]\n\n    results = []\n    for m0, lam in test_cases:\n        lambda_hat, expected_collisions, c = estimate_lambda_and_collisions(m0, lam)\n        # Format floats to six digits after the decimal point\n        lambda_hat_str = f\"{lambda_hat:.6f}\"\n        expected_collisions_str = f\"{expected_collisions:.6f}\"\n        # Build the triple as a string without spaces to match the exact required output format\n        triple_str = f\"[{lambda_hat_str},{expected_collisions_str},{c}]\"\n        results.append(triple_str)\n\n    # Final print statement in the exact required format: list of triples without spaces\n    print(f\"[{','.join(results)}]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3238369"}]}