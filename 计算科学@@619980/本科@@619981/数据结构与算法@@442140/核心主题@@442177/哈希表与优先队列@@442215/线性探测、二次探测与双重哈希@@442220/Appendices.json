{"hands_on_practices": [{"introduction": "我们首先探讨像线性探测这样的简单哈希方法的脆弱性。这项练习要求你扮演“攻击者”的角色，设计一个特定的键序列来触发其最坏情况下的行为，从而导致所谓的“主聚集”现象。通过推导并量化这种场景下的性能，你将对线性探测的这一关键缺陷有一个具体而深刻的理解。[@problem_id:3244644]", "problem": "考虑一个大小为 $m$ 的哈希表，它使用开放地址法和线性探测。冲突解决方法是：在插入或搜索键 $k$ 时，探测表索引序列 $h(k), h(k)+1, h(k)+2, \\dots$（对 $m$ 取模），直到找到一个空槽位（在插入时）或找到目标键（在成功搜索时）。主哈希函数为 $h(k) = k \\bmod m$。该表初始为空。您将插入 $n$ 个不同的键 $k_1, k_2, \\dots, k_n$（其中 $0  n  m$），并且在所有插入操作完成后，对从集合 $\\{k_1, k_2, \\dots, k_n\\}$ 中均匀随机抽取的一个键执行成功搜索。定义负载因子 $\\alpha$ 为 $\\alpha = \\frac{n}{m}$。\n\n您的任务是设计一个对抗性的 $m$ 选择和一串不同的键 $k_1, \\dots, k_n$，使得线性探测在表中创建一个长度为 $n$ 的单一连续簇，然后量化在上述均匀随机键模型下成功搜索所需的期望探测次数。您必须完成以下操作：\n\n- 指定一个有效的 $m$ 和用 $m$ 表示的 $k_1, \\dots, k_n$ 的选择，确保在 $h(k) = k \\bmod m$ 的哈希函数下，所有键都哈希到相同的初始索引，从而通过线性探测强制形成一个单一的连续簇。论证这些键是不同的，并且所产生的簇是长度为 $n$ 的连续簇。\n\n- 从开放地址法、线性探测以及由 $h(k)$ 导出的探测序列的核心定义出发，推导当查询键从已插入的 $n$ 个键中均匀抽取时，成功搜索所需的期望探测次数。将您的最终答案表示为负载因子 $\\alpha$ 和 $m$ 的闭式解析表达式。\n\n不得引用任何快捷公式；直接从定义以及对抗性序列对探测序列的结构性影响来推导结果。最终答案必须是单一的闭式解析表达式。不需要四舍五入。", "solution": "问题陈述经验证具有科学依据，表述清晰，客观且完整。它描述了哈希中线性探测的经典最坏情况，这是算法分析中的一个标准课题。该问题没有任何科学或逻辑上的缺陷。因此，我们可以开始求解。\n\n任务是首先构造一个能产生特定对抗性条件（单一连续簇）的键序列，然后推导在这种条件下成功搜索的期望探测次数。\n\n### 第一部分：对抗性键序列的构造\n\n目标是选择一个哈希表大小 $m$ 和一个包含 $n$ 个不同键的序列 $k_1, k_2, \\dots, k_n$，使得所有键都哈希到相同的初始表索引，从而在线性探测下生成一个长簇。\n\n设哈希表大小 $m$ 为一个满足 $m > n > 0$ 的整数。\n主哈希函数为 $h(k) = k \\bmod m$。\n为确保所有键都哈希到相同的索引，我们必须有 $h(k_1) = h(k_2) = \\dots = h(k_n)$。不失一般性，我们选择这个公共哈希索引为 $0$。这要求对于所有的 $i \\in \\{1, 2, \\dots, n\\}$ 都有 $k_i \\bmod m = 0$。这等价于说明每个键 $k_i$ 都必须是 $m$ 的整数倍。\n\n我们还必须确保这些键是不同的。一个同时满足这两个条件的简单选择是将键定义为 $m$ 的连续非零倍数。我们将键序列指定为：\n$$k_i = i \\cdot m \\quad \\text{for } i = 1, 2, \\dots, n$$\n\n我们验证这个键的选择满足了所需标准：\n1.  **唯一性**：设 $i$ 和 $j$ 是 $\\{1, 2, \\dots, n\\}$ 中两个不同的索引，即 $i \\neq j$。由于 $m > n > 0$，因此有 $i \\cdot m \\neq j \\cdot m$。所以，键 $k_1, k_2, \\dots, k_n$ 都是不同的。\n2.  **公共哈希索引**：对于序列中的任何键 $k_i = i \\cdot m$，哈希函数计算得出 $h(k_i) = (i \\cdot m) \\bmod m = 0$。所有键都哈希到初始索引 $0$。\n\n现在，我们分析将这 $n$ 个键按顺序插入一个初始为空的哈希表后的状态。\n-   **插入 $k_1 = 1 \\cdot m$**：哈希索引为 $h(k_1)=0$。索引为 $0$ 的表槽位是空的，所以 $k_1$ 被放置在索引 $0$ 处。这需要 $1$ 次探测。\n-   **插入 $k_2 = 2 \\cdot m$**：哈希索引为 $h(k_2)=0$。槽位 $0$ 此时被 $k_1$ 占据。线性探测前进到下一个索引 $(0+1) \\bmod m = 1$。槽位 $1$ 是空的，所以 $k_2$ 被放置在索引 $1$ 处。这需要 $2$ 次探测（一次探测槽位 $0$，一次探测槽位 $1$）。\n-   **插入 $k_3 = 3 \\cdot m$**：哈希索引为 $h(k_3)=0$。槽位 $0$ 被占据。探测索引 $1$ 发现它也被占据。探测索引 $(0+2) \\bmod m = 2$ 发现一个空槽位。所以，$k_3$ 被放置在索引 $2$ 处。这需要 $3$ 次探测。\n\n我们可以用一个简单的归纳论证来形式化这个过程。假设在插入键 $k_1, \\dots, k_{j-1}$ 之后，索引为 $0, 1, \\dots, j-2$ 的表槽位被占据。现在，考虑插入键 $k_j = j \\cdot m$。其哈希索引为 $h(k_j)=0$。线性探测序列为 $0, 1, 2, \\dots$。探测将检查槽位 $0, 1, \\dots, j-2$，所有这些槽位都已被占据。下一次探测是索引 $j-1$。由于 $j-1  n  m$，该索引在表范围内，并且根据我们的假设是空的。因此，$k_j$ 被放置在索引 $j-1$ 处。插入 $k_j$ 所需的探测次数为 $(j-1) - 0 + 1 = j$。\n\n这个过程对从 $1$ 到 $n$ 的所有 $j$ 都成立。在插入所有 $n$ 个键 $k_1, \\dots, k_n$ 之后，索引为 $0, 1, \\dots, n-1$ 的哈希表槽位都被占据。这形成了一个长度为 $n$ 的单一连续簇，符合问题的要求。\n\n### 第二部分：成功搜索的期望探测次数\n\n我们要计算成功搜索的期望探测次数，其中要搜索的键是从已插入的 $n$ 个键的集合 $\\{k_1, k_2, \\dots, k_n\\}$ 中均匀随机抽取的。\n\n成功搜索一个键所需的探测次数与最初插入该键所需的探测次数相同。设 $C(k)$ 是搜索键 $k$ 所需的探测次数。根据我们在第一部分的分析，插入（并因此找到）键 $k_i$ 所需的探测次数是 $C(k_i) = i$。\n\n要搜索的键是按均匀概率抽取的。这意味着搜索任何特定键 $k_i$ 的概率是 $P(\\text{search } k_i) = \\frac{1}{n}$。\n\n设 $E[C_S]$ 为成功搜索的期望探测次数。根据期望值的定义，我们有：\n$$E[C_S] = \\sum_{i=1}^{n} C(k_i) \\cdot P(\\text{search } k_i)$$\n代入我们找到的值：\n$$E[C_S] = \\sum_{i=1}^{n} i \\cdot \\frac{1}{n}$$\n我们可以将常数 $\\frac{1}{n}$ 从求和中提取出来：\n$$E[C_S] = \\frac{1}{n} \\sum_{i=1}^{n} i$$\n该求和是前 $n$ 个正整数之和，其有一个著名的闭式公式：\n$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$\n将此代回期望值的表达式中：\n$$E[C_S] = \\frac{1}{n} \\left( \\frac{n(n+1)}{2} \\right) = \\frac{n+1}{2}$$\n问题要求最终答案用负载因子 $\\alpha = \\frac{n}{m}$ 和表大小 $m$ 来表示。根据负载因子的定义，我们可以将 $n$ 表示为 $n = \\alpha m$。\n\n将 $n = \\alpha m$ 代入我们的 $E[C_S]$ 结果中：\n$$E[C_S] = \\frac{(\\alpha m) + 1}{2} = \\frac{\\alpha m + 1}{2}$$\n这就是在指定的对抗性条件下，成功搜索的期望探测次数的最终闭式解析表达式。", "answer": "$$\\boxed{\\frac{\\alpha m + 1}{2}}$$", "id": "3244644"}, {"introduction": "在认识到线性探测的问题后，我们转向更复杂的双重哈希。然而，它的强大功能依赖于严谨的实现。本练习将展示一个“病态”案例，其中一个糟糕的第二哈希函数 $h_2(k)$ 会产生极短的探测序列，即使在负载因子很低的情况下也会导致插入失败。分析这个案例将揭示数论在设计真正健壮的哈希表中所扮演的关键角色，并强调选择合适的哈希函数的重要性。[@problem_id:3244585]", "problem": "给定一个开放寻址哈希表，其表大小为 $m$，并采用标准的双重哈希方案。根据定义，当插入一个键 $k$ 时，第 $j$ 次探查会检查表索引\n$$\ni_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m,\n$$\n其中 $j \\in \\{0,1,2,\\dots\\}$，一旦找到空槽位就停止，或者在索引重复之前未遇到空槽位则报告失败。负载因子为 $\\alpha \\equiv n/m$，其中 $n$ 是当前存储的键的数量。\n\n考虑以下为分离辅助哈希函数的影响而设计的具体设置：\n\n- 表大小 $m = 64$。\n- 主哈希 $h_1(k) \\equiv k \\bmod 64$（因此，对于模64的均匀分布余数，它是近乎完美的）。\n- 辅助哈希 $h_2(k) \\equiv 8$ 对所有键成立（因此步长是固定的）。\n- 一个包含9个键的序列 $S$，按给定顺序插入到一个初始为空的表中：\n$$\nS = \\{0,\\,64,\\,128,\\,192,\\,256,\\,320,\\,384,\\,448,\\,512\\}。\n$$\n- 如果所有9个键的插入都成功，负载因子将为 $\\alpha = 9/64$。\n\n仅使用开放寻址与双重哈希的核心定义以及模算术的基本性质，选择以下所有关于此设置及其所展示的病态情况以及如何避免该情况的正确陈述。\n\nA. 在 $m=64$，$h_1(k) \\equiv k \\bmod 64$，$h_2(k) \\equiv 8$ 以及给定序列 $S$ 的情况下，尽管负载因子 $\\alpha = 9/64$ 很小，第9个键的插入仍然会失败。\n\nB. 如果 $m$ 是任意素数，并且保证对于每个键 $k$，$h_2(k)$ 都在 $\\{1,2,\\dots,m-1\\}$ 范围内，那么对于任何插入序列，在表完全填满之前，任何插入都不会失败，因为每个双重哈希探查序列都可以访问所有 $m$ 个槽位。\n\nC. 如果保持 $m=64$ 和 $h_1(k) \\equiv k \\bmod 64$ 不变，将双重哈希替换为线性探查（即使用步长1），对于相同的序列 $S$，第9次插入仍然会失败。\n\nD. 此设置中的失败完全是因为 $h_1$ 很差；如果将 $h_1$ 替换为模64余数上的任何排列（即，在 $\\{0,1,\\dots,63\\}$ 上的任何双射 $h_1$），即使 $h_2(k) \\equiv 8$ 不变，失败也会消失。\n\nE. 对于一般的 $m$ 和任意固定的键 $k$，其双重哈希探查序列可以到达的不同表索引的数量等于 $m / \\gcd(h_2(k), m)$，其中 $\\gcd$ 表示最大公约数；因此，如果 $\\gcd(h_2(k), m) > 1$，则键 $k$ 的探查序列被限制在表的一个真子集中。", "solution": "问题描述了一个使用双重哈希方案的开放寻址哈希表。我们被要求分析一个特定的病态案例，并评估关于它及其根本原因的几个陈述。\n\n首先，我们来验证问题陈述。\n给定条件如下：\n- 哈希表大小：$m = 64$。\n- 主哈希函数：$h_1(k) \\equiv k \\bmod 64$。\n- 辅助哈希函数：$h_2(k) \\equiv 8$ 对所有键成立。\n- 探查序列公式：$i_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m$，其中 $j \\in \\{0, 1, 2, \\dots\\}$。\n- 插入初始为空的表的键序列：$S = \\{0, 64, 128, 192, 256, 320, 384, 448, 512\\}$。该序列中有9个键。\n\n该问题在科学上基于数据结构与算法的原理，特别是哈希技术。它定义明确，所有必要的参数都已给出。语言客观且无歧义。这个设置虽然展示了糟糕的哈希实践，但作为一个理论练习是有效的。这是一个旨在测试对双重哈希机制理解的有效问题。\n\n我们首先分析给定哈希函数在指定键序列下的行为。\n对于序列 $S = \\{0, 64, \\dots, 512\\}$ 中的每个键 $k$，$k$ 都是64的整数倍。也就是说，对于某个整数 $q \\in \\{0, 1, \\dots, 8\\}$，$k = q \\cdot 64$。\n因此，主哈希函数 $h_1(k) \\equiv k \\bmod 64$ 会将 $S$ 中的每个键映射到相同的初始索引：\n$$h_1(k) = (q \\cdot 64) \\bmod 64 = 0$$\n这是一个极端的主冲突情况：所有9个键都映射到槽位0。\n\n辅助哈希函数是一个常数，$h_2(k) = 8$。\n因此，对于任何键 $k \\in S$ 的探查序列由下式给出：\n$$i_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m \\equiv 0 + j \\cdot 8 \\pmod{64} \\equiv 8j \\pmod{64}$$\n\n该探查序列访问的不同索引的数量由通用公式 $m / \\gcd(h_2(k), m)$ 给出，其中 $\\gcd$ 是最大公约数。在这种情况下，步长为 $h_2(k) = 8$，表大小为 $m = 64$。\n可到达的不同槽位的数量是：\n$$ \\frac{m}{\\gcd(h_2(k), m)} = \\frac{64}{\\gcd(8, 64)} = \\frac{64}{8} = 8 $$\n对于 $S$ 中的任何键，其探查序列只能访问8个不同的槽位。具体的槽位是 $\\{8 \\cdot 0 \\bmod 64, 8 \\cdot 1 \\bmod 64, \\dots, 8 \\cdot 7 \\bmod 64\\}$，即集合 $\\{0, 8, 16, 24, 32, 40, 48, 56\\}$。在 $j=7$ 之后，探查序列重复，因为 $i_8 = 8 \\cdot 8 \\bmod 64 = 0 = i_0$。\n\n现在，我们来追踪 $S$ 中键的插入过程：\n1.  插入 $k=0$：探查索引0。该槽位为空。键被放置在此处。\n2.  插入 $k=64$：探查索引0（已占用），然后探查索引 $0 + 1 \\cdot 8 = 8$（空）。键被放置在索引8处。\n3.  插入 $k=128$：探查索引0（已占用）、8（已占用），然后探查索引16（空）。键被放置在索引16处。\n...\n8.  插入 $k=448$：探查索引 $0, 8, 16, 24, 32, 40, 48$（均已占用），然后探查索引56（空）。键被放置在索引56处。\n\n在前8个键插入后，所有8个可到达的槽位 $\\{0, 8, 16, 24, 32, 40, 48, 56\\}$ 都被填满。表中包含 $n=8$ 个元素，负载因子为 $\\alpha = 8/64 = 1/8$。\n\n现在，考虑第9个键 $k=512$ 的插入。\n它的哈希值为 $h_1(512)=0$ 和 $h_2(512)=8$。探查序列与之前的相同：$0, 8, 16, \\dots, 56$。\n插入算法将检查槽位 $0, 8, 16, 24, 32, 40, 48$ 和 $56$。它会发现这些槽位都已被占用。下一次探查（对于 $j=8$）将再次是索引0。由于探查序列已经重复且没有找到空槽位，插入过程失败。尽管表中仍有 $64 - 8 = 56$ 个槽位是空的，但插入还是失败了。\n\n基于此分析，我们可以评估每个选项。\n\nA. 在 $m=64$，$h_1(k) \\equiv k \\bmod 64$，$h_2(k) \\equiv 8$ 以及给定序列 $S$ 的情况下，尽管负载因子 $\\alpha = 9/64$ 很小，第9个键的插入仍然会失败。\n如上所述，在插入前8个键之后，对于 $h_1(k)=0$ 的键，所有可到达的槽位都已被占用。第9个键 $k=512$ 同样有 $h_1(512)=0$，因此探查相同的槽位序列。由于所有这些槽位都已占用，插入失败。在这次失败的插入尝试时，负载因子为 $n/m = 8/64$。如果插入成功，潜在的负载因子将是 $\\alpha=9/64$，约等于0.14，这是一个很小的值。该陈述与我们的推导完全一致。\n**结论：正确。**\n\nB. 如果 $m$ 是任意素数，并且保证对于每个键 $k$，$h_2(k)$ 都在 $\\{1,2,\\dots,m-1\\}$ 范围内，那么对于任何插入序列，在表完全填满之前，任何插入都不会失败，因为每个双重哈希探查序列都可以访问所有 $m$ 个槽位。\n一个探查序列访问的不同槽位数量是 $m / \\gcd(h_2(k), m)$。如果 $m$ 是一个素数，那么对于任何满足 $1 \\le c \\le m-1$ 的整数 $c$，都有 $\\gcd(c, m) = 1$。由于保证 $h_2(k)$ 在 $\\{1, 2, \\dots, m-1\\}$ 范围内，我们有 $\\gcd(h_2(k), m) = 1$。因此，访问的不同槽位数量为 $m / 1 = m$。这意味着任何键的探查序列都会生成所有表索引 $\\{0, 1, \\dots, m-1\\}$ 的一个排列。因此，在尝试插入一个键时，其探查序列最终将访问表中的每一个槽位。如果表未满（即至少存在一个空槽位），则插入保证能找到一个空槽位并成功。只有当表完全满（$n=m$）时，插入才会失败。该陈述是设计稳健的双重哈希方案的一个正确且基本的原则。\n**结论：正确。**\n\nC. 如果保持 $m=64$ 和 $h_1(k) \\equiv k \\bmod 64$ 不变，将双重哈希替换为线性探查（即使用步长1），对于相同的序列 $S$，第9次插入仍然会失败。\n线性探查等同于将所有键的步长设置为1。在双重哈希公式的背景下，这对应于 $h_2(k) = 1$。探查序列为 $i_j \\equiv h_1(k) + j \\pmod m$。$S$ 中的所有键仍然映射到 $h_1(k)=0$。1. 插入 $k=0$：放置在索引0。2. 插入 $k=64$：探查0（已占用），放置在索引1。3. 插入 $k=128$：探查0, 1（已占用），放置在索引2。…… 8. 插入 $k=448$：探查 $0, \\dots, 6$（已占用），放置在索引7。9. 插入 $k=512$：探查 $0, \\dots, 7$（已占用）。下一次探查是索引8，该位置为空。插入成功，将 $k=512$ 放置在索引8。插入不会失败。原因是步长为1时，$\\gcd(1, 64) = 1$，所以探查序列可以访问所有64个槽位。该陈述声称插入会失败，这是错误的。\n**结论：不正确。**\n\nD. 此设置中的失败完全是因为 $h_1$ 很差；如果将 $h_1$ 替换为模64余数上的任何排列（即，在 $\\{0,1,\\dots,63\\}$ 上的任何双射 $h_1$），即使 $h_2(k) \\equiv 8$ 不变，失败也会消失。\n该陈述声称失败*完全*是由于 $h_1$。失败机制有两个组成部分：首先，$h_1$ 将 $S$ 中的所有键映射到同一个槽位，造成了主冲突簇；其次，$h_2$ 生成了一个短的探查序列，因为 $\\gcd(h_2(k), m) > 1$。如果 $h_1$ 是一个排列，那么 $S$ 中的9个不同键将映射到9个不同的初始槽位。每个键都将在其初始槽位中插入，不会发生任何冲突。对于这个特定的序列 $S$，失败确实会消失。然而，“完全”这个词很关键。它暗示 $h_2$ 不是原因。这是错误的。如选项C的分析所示，如果我们保留“差的”$h_1$ 但使用一个更好的 $h_2$（比如线性探查中的 $h_2(k)=1$），对于这个序列，失败也会消失。既然在保持 $h_1$ 不变的情况下修复 $h_2$ 也能解决这个问题，那么 $h_1$ 不可能是唯一的原因。这种病态情况是 $h_1$ 引起的主冲突和 $h_2$ 导致的探查序列长度不足共同作用的结果。\n**结论：不正确。**\n\nE. 对于一般的 $m$ 和任意固定的键 $k$，其双重哈希探查序列可以到达的不同表索引的数量等于 $m / \\gcd(h_2(k), m)$，其中 $\\gcd$ 表示最大公约数；因此，如果 $\\gcd(h_2(k), m) > 1$，则键 $k$ 的探查序列被限制在表的一个真子集中。\n探查序列是一个模 $m$ 的算术级数：$p_j = a + j \\cdot s \\pmod m$，其中 $a=h_1(k)$，$s=h_2(k)$。该序列生成的值的集合是模 $m$ 整数加法群 $\\mathbb{Z}_m$ 中由 $s$ 生成的循环子群的一个陪集。该子群的阶（大小）为 $|\\langle s \\rangle| = m / \\gcd(s, m)$。一个陪集的大小与子群相同。因此，探查序列中不同索引的数量恰好是 $m / \\gcd(h_2(k), m)$。结论直接得出：如果 $\\gcd(h_2(k), m) > 1$，则分母大于1，这意味着可到达索引的数量 $m / \\gcd(h_2(k), m)$ 严格小于 $m$。因此，探查序列被限制在表的一个真子集中。这个陈述是一个应用于哈希的正确且基本的数论定理。\n**结论：正确。**\n\n总而言之，陈述A、B和E是正确的。", "answer": "$$\\boxed{ABE}$$", "id": "3244585"}, {"introduction": "理论提供了基础，但实践才能带来真知。在这项总结性练习中，你将构建一个测试框架，来实验性地比较线性探测、二次探测和双重哈希。通过模拟不同的键插入顺序并测量实际的性能指标，你将亲手验证每种方法的理论特性，并对聚集行为、探测成本以及算法对输入顺序的敏感性建立起扎实的直观理解。[@problem_id:3244620]", "problem": "要求你编写一个完整、可运行的程序，为开放寻址法哈希表构建一个系统性的测试工具，并定量地展示在不同探测策略下，插入顺序如何影响簇的形态和探测成本。重点是线性探测、二次探测和双重哈希。\n\n从以下基本概念开始：\n- 一个使用开放寻址法的哈希表将每个键存储在大小为 $m$ 的定长数组的恰好一个槽位中。要插入一个键 $k$，我们会考虑一个索引的探测序列，按顺序检查它们，并将 $k$ 放置在遇到的第一个空槽位中。\n- 哈希函数将键映射到初始索引（对 $m$ 取模）。\n- 对于给定的探测方案，键 $k$ 的探测序列由一个关于 $k$ 和探测次数 $t$ 的确定性函数定义，并对 $m$ 取模。\n\n本问题中使用的定义：\n- 对每个键 $k$，定义主哈希为 $h(k) = k \\bmod m$。\n- 线性探测：探测序列为 $h(k), h(k)+1, h(k)+2, \\dots$，对 $m$ 取模。\n- 二次探测：探测序列为 $h(k) + c_1 t + c_2 t^2$，对 $m$ 取模，其中常数 $c_1 = 1$ 和 $c_2 = 1$。因此，在第 $t$ 次尝试时，探测索引为 $h(k) + t + t^2 \\pmod m$。如果在 $m$ 次探测内未找到空槽位，则该排列在二次探测下的插入失败。\n- 双重哈希：定义第二个步长函数为 $h_2(k) = 1 + (k \\bmod (m-1))$。探测序列为 $h(k), h(k) + h_2(k), h(k) + 2 h_2(k), \\dots$，对 $m$ 取模。假设 $m$ 是素数，以确保 $h_2(k)$ 与 $m$ 互质。\n\n簇指标：\n- 考虑在按给定顺序插入给定集合中的所有键后表的占用情况。簇定义为长度为 $m$ 的循环数组上已占用槽位的最大连续序列。将所有这些簇（位于空槽位之间）的长度收集到一个多重集中。表状态的簇签名定义为这些长度的排序列表。此签名取决于最终的占用模式，但在环形旋转下保持不变。例如，如果 $m=11$ 且已占用槽位形成三个长度分别为 $[4,2,1]$ 的序列，则簇签名为 $[1,2,4]$。\n- 探测成本指标：对于一个键的插入，探测次数是直到该键被放置（包括成功放置的槽位）所检查的槽位数量。一个键集合的完整插入顺序的总探测成本是所有已插入键的探测次数之和。\n\n你的任务：\n- 对于下方的每个测试用例，考虑相同的键集合，并枚举其插入顺序的所有排列。对于每种探测方案（线性、二次、双重），为每个排列模拟开放寻址插入过程，并计算：\n  1) 在该方案下，所有成功插入全部键的排列中，观察到的不同簇签名的数量。\n  2) 所有这些排列中的最小总探测成本。\n  3) 所有这些排列中的最大总探测成本。\n- 如果某个排列在二次探测下导致插入失败（即，在 $m$ 次探测内未能为某个键找到空槽位），则从其所有指标计算中排除该排列；但仍包括所有其他成功的排列。对于线性探测和双重哈希，在给定参数下，所有排列都将成功。\n\n测试套件：\n- 情况1：表大小 $m = 11$，键 $K = [10,21,32,43,54]$。\n- 情况2：表大小 $m = 13$，键 $K = [0,13,26,39,1,14]$。\n- 情况3：表大小 $m = 17$，键 $K = [16,33,50,67,1,18,35]$。\n\n所有键均为整数，所有 $m$ 均为素数，负载因子小于等于 $0.5$，以确保真实的开放寻址行为。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，并按顺序排列。每个条目本身必须是一个包含三个条目的列表，分别对应于线性探测、二次探测和双重哈希。对于每种探测方案，输出一个包含三个整数的列表：$[\\text{不同签名数}, \\text{最小总探测数}, \\text{最大总探测数}]$。\n- 具体来说，最终的单行输出必须如下所示：\n  - $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]],[[d_1,e_1,f_1],[d_2,e_2,f_2],[d_3,e_3,f_3]],[[g_1,h_1,i_1],[g_2,h_2,i_2],[g_3,h_3,i_3]]$，并包含在一对外层方括号内。不得有任何额外文本。\n- 示例模式（非实际结果）：$[[1,10,14],[2,9,15],[1,8,12]],[[3,20,28],[2,18,27],[1,16,22]],[[5,24,35],[4,23,34],[2,20,30]]$。\n\n角度单位和物理单位不适用。所有要求的答案都是整数。你的程序必须是完全自包含的，且不得读取任何输入。它必须计算并打印上述描述的单行最终结果。", "solution": "在尝试解决问题之前，需对问题进行验证。\n\n### 第一步：提取已知信息\n- **哈希表**：一个采用开放寻址法的哈希表，具有一个大小为 $m$ 的定长数组。\n- **主哈希函数**：$h(k) = k \\bmod m$。\n- **探测策略**：\n    1.  **线性探测**：在第 $t \\ge 0$ 次尝试时的探测位置为 $(h(k) + t) \\pmod m$。\n    2.  **二次探测**：在第 $t \\ge 0$ 次尝试时的探测位置为 $(h(k) + c_1 t + c_2 t^2) \\pmod m$，其中常数 $c_1 = 1$ 和 $c_2 = 1$。如果在 $m$ 次探测内未找到空槽位，则插入失败。\n    3.  **双重哈希**：在第 $t \\ge 0$ 次尝试时的探测位置为 $(h(k) + t \\cdot h_2(k)) \\pmod m$，其中第二个哈希函数为 $h_2(k) = 1 + (k \\bmod (m-1))$。假设 $m$ 为素数。\n- **指标**：\n    1.  **簇签名**：循环表数组中所有最大连续已占用槽位序列的长度的排序列表。\n    2.  **总探测成本**：在给定的插入序列中，所有键的探测次数之和，其中单个键的探测次数是放置前检查的槽位数。\n- **任务**：对于每个测试用例，遍历键的所有插入顺序排列。对于三种探测方案中的每一种，计算：\n    1.  在所有成功排列中，不同簇签名的数量。\n    2.  在所有成功排列中，最小的总探测成本。\n    3.  在所有成功排列中，最大的总探测成本。\n- **排除条件**：对于二次探测，任何导致插入失败的排列都将从该方案的指标计算中排除。\n- **测试套件**：\n    -   情况1：$m = 11$，键 $K = [10, 21, 32, 43, 54]$。\n    -   情况2：$m = 13$，键 $K = [0, 13, 26, 39, 1, 14]$。\n    -   情况3：$m = 17$，键 $K = [16, 33, 50, 67, 1, 18, 35]$。\n- **输出格式**：一个单行，表示一个嵌套的结果列表：`[[case1_results], [case2_results], [case3_results]]`，其中每个 `case_results` 是 `[[linear_metrics], [quadratic_metrics], [double_hashing_metrics]]`，每个 `metrics` 是 `[distinct_signatures, min_total_probes, max_total_probes]`。\n\n### 第二步：使用提取的已知信息进行验证\n评估问题陈述的有效性。\n1.  **科学依据**：该问题在数据结构和算法的基本原理方面有充分的依据，特别是关于哈希表和开放寻址法。线性探测、二次探测和双重哈希的定义是标准的且描述正确。使用素数模 $m$ 和特定形式的 $h_2(k)$ 是双重哈希的最佳实践，以确保能搜索整个表。\n2.  **良构性**：该问题是良构的。输入定义清晰，所需的计算是确定性的，期望的输出也明确规定。每个键集合的排列数量（$5! = 120$，$6! = 720$，$7! = 5040$）是有限且计算上可行的，确保可以推导出唯一的解。\n3.  **客观性**：问题以精确、客观和数学化的语言陈述。诸如“簇签名”和“总探测成本”等指标的定义是明确的，没有主观解释的余地。\n4.  **完整性与一致性**：问题是自包含的。所有必要的参数（$m$、$K$、探测常数）和定义都已提供。二次探测失败的条件已明确说明。所述的负载因子（$\\alpha = |K|/m \\le 0.5$）对于开放寻址是现实的，并如断言所述，保证了线性探测和双重哈希的成功。\n\n### 第三步：结论与行动\n问题是**有效的**。这是一个计算机科学领域严谨的计算练习，没有任何科学、逻辑或结构上的缺陷。将提供一个完整的解决方案。\n\n### 解决方案\n该解决方案需要对不同条件下的哈希表性能进行系统性模拟和分析。其核心方法是，对于给定的键集合，枚举所有可能的插入顺序，并对每种顺序，为三种指定的开放寻址方案中的每一种模拟插入过程。\n\n**方法论**\n\n1.  **系统性枚举**：对于每个由表大小 $m$ 和键集合 $K$ 定义的测试用例，我们生成键的所有 $|K|!$ 种排列。这确保了每一种可能的插入顺序都被检查到。Python 中的 `itertools.permutations` 库函数适合此任务。\n\n2.  **哈希表模拟**：对于每个排列和每个探测方案，我们模拟将键插入一个大小为 $m$ 的初始为空的哈希表中。哈希表表示为一个数组，初始化为空状态（例如 `None`）。对于要插入的每个键：\n    -   我们根据当前方案（线性、二次或双重哈希）的指定公式生成探测序列。探测尝试计数器 $t$ 从 $0$ 开始。\n    -   探测序列为 $p(k, t) = (h(k) + f(t)) \\pmod m$，其中 $f(t)$ 是探测函数：\n        -   线性：$f(t) = t$。\n        -   二次：$f(t) = t + t^2$。\n        -   双重哈希：$f(t) = t \\cdot h_2(k)$，其中 $h_2(k) = 1 + (k \\bmod (m-1))$。\n    -   我们遍历探测序列，计算探测次数，直到找到一个空槽位。然后将键放入此槽位。\n    -   此键的探测次数被加到当前排列的总数中。\n    -   对于二次探测，如果模拟循环完成 $m$ 次尝试仍未找到空槽位，则该排列的插入被标记为失败，并且根据问题规则，此排列的数据将从二次探测方案中丢弃。\n\n3.  **指标计算**：在成功插入给定排列的所有键后：\n    -   **总探测成本**：这是该排列中所有键的探测次数的累加和。\n    -   **簇签名**：该指标描述了已占用槽位的最终配置。为了计算它，我们首先将表的占用情况表示为一个二进制序列（例如，1表示占用，0表示空闲）。为了处理表的循环特性，我们通过循环移位使其从第一个空槽位开始，从而将序列线性化。这不会改变簇的长度或相对位置。然后，我们按空槽位（'0'）分割这个线性化序列，并收集得到的连续已占用槽位块（'1's）的长度。对这些长度进行排序以生成规范的簇签名。\n\n4.  **结果聚合**：在遍历所有排列后，我们为每个探测方案聚合结果：\n    -   我们将所有成功排列中遇到的所有唯一簇签名收集到一个集合中，以计算不同签名的数量。\n    -   我们跟踪在所有成功排列中观察到的最小和最大总探测成本。\n\n对于三个测试用例中的每一个，都重复这一完整过程。最终结果被组装成所需的嵌套列表结构，并格式化为无空格的单行字符串。提供的 Python 实现精确地遵循了这一逻辑。", "answer": "[[[1,15,15],[5,8,12],[1,7,7]],[[1,21,21],[6,11,16],[2,8,10]],[[1,28,28],[7,13,20],[3,10,12]]]", "id": "3244620"}]}