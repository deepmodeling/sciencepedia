{"hands_on_practices": [{"introduction": "除法和乘法不仅仅是算术运算，它们也是算法设计中的基本工具，而哈希函数是其中的一个典型应用。本练习将引导你深入探究哈希函数的设计原理，通过构建一个白盒测试套件来验证其关键属性并揭示常见哈希方案的潜在弱点。这不仅仅是一次编程实践，更是对算法进行严格验证和批判性分析思维的训练。[@problem_id:3229012]", "problem": "要求您仅使用核心数学定义，实现、论证和验证两种哈希表的索引策略，这两种策略通常被称为除法和乘法。然后，您必须构建一个白盒测试套件，用于生成对抗性输入和边界输入（包括形式为 $x = 2^k - 1$ 的键和大小为 $m = 2^k$ 的表），并检查在多个独立实现和参数选择下必须保持的不变式。\n\n使用的基本依据：\n- 对于任意整数 $x$ 和 $m$（其中 $m \\ge 1$），$x$ 除以 $m$ 的余数 $r$ 是满足 $0 \\le r < m - 1$ 和 $x = q m + r$（对于某个整数 $q$）的唯一整数。\n- 对于任意实数 $y$，定义向下取整函数 $\\lfloor y \\rfloor$ 为小于或等于 $y$ 的最大整数，并定义小数部分 $\\{y\\} = y - \\lfloor y \\rfloor \\in [0, 1)$。\n\n需要实现的任务：\n1. 为除法实现一个索引函数，该函数返回 $x$ 对 $m$ 取模的余数，结果为一个在 $[0, m-1]$ 区间内的整数。以两种代数上等价的方式实现它，并验证它们在所有测试输入上都相等：\n   - 使用标准的余数函数。\n   - 使用恒等式 $x - m \\cdot \\left\\lfloor \\dfrac{x}{m} \\right\\rfloor$。\n2. 当 $m$ 是 2 的幂时，实现第三种位级索引函数，该函数仅使用位运算，并且在这种情况下可证明与除法等价。\n3. 为乘法实现一个索引函数，使用一个固定的实数乘数 $A \\in (0, 1)$：仅使用上述定义计算 $\\left\\lfloor m \\cdot \\{x A\\} \\right\\rfloor$。\n\n您的程序必须检查的白盒不变式：\n- 范围安全性：每个计算出的索引都必须在 $[0, m-1]$ 范围内。\n- 同一规范的独立实现之间的等价性：当 $m = 2^k$ 时，对于所有测试的 $x$（包括负整数），除法和位级方法的结果必须一致。\n- 除法下的算术级数稳定性：对于形式为 $x = t m + r$ 的键（其中 $m$ 和 $r$ 固定），对于所有整数 $t$，除法必须返回 $r$。\n- 乘法对 $A$ 选择的敏感性：当使用类无理数斜率（例如，$(0, 1)$ 内的一个高质量常数）时，桶计数的分布应近似均匀；当使用有理数斜率（如 $A = \\dfrac{1}{2}$）且 $m = 2^k$ 时，应只使用少数几个桶。\n\n要求的测试套件。您的程序必须计算一个包含七个布尔结果的列表，每个结果对应以下一个测试用例及其不变式。请严格使用下面给出的参数值，不得使用随机性。\n\n- 测试 $1$ (2的幂等价性与范围)：设 $m = 2^{10}$，并测试 $\\{0, 1, \\dots, 4095\\}$ 中的所有整数 $x$。验证两种除法实现和位级实现的结果都相等且在范围内。\n- 测试 $2$ (素数模下的算术级数)：设 $m = 1019$ (素数)，$r = 57$，并对 $t \\in \\{0, 1, \\dots, 999\\}$ 测试 $x = t m + r$。验证两种除法实现对所有测试的 $x$ 都返回 $r$。\n- 测试 $3$ (2的幂模下的负数键)：设 $m = 2^8$。测试 $\\{-300, -299, \\dots, 300\\}$ 中的所有 $x$。验证两种除法实现的结果相等，并且位级实现的结果与它们对所有测试的 $x$ 都相等。\n- 测试 $4$ (乘法的近似均匀性)：设 $m = 2^{10}$，$A = \\dfrac{\\sqrt{5} - 1}{2}$，并测试 $x \\in \\{0, 1, \\dots, 65535\\}$。计算所有 $m$ 个桶的桶计数。设 $N = 65536$ 并检查谓词 $\\max\\text{count} - \\min\\text{count} \\le \\lceil 4 \\sqrt{N / m} \\rceil$。返回一个布尔值，指示该条件是否成立。\n- 测试 $5$ (有理数斜率的退化检测)：设 $m = 2^{10}$，$A = \\dfrac{1}{2}$，并测试 $x \\in \\{0, 1, \\dots, 4095\\}$。验证是否恰好使用了 $2$ 个不同的桶。如果检测到这种退化现象，则返回一个布尔值 true。\n- 测试 $6$ (算术级数上的跨方法对比)：设 $m = 2^{10}$，$A = \\dfrac{\\sqrt{5} - 1}{2}$，固定 $r = 7$，并对 $t \\in \\{0, 1, \\dots, 2047\\}$ 测试 $x = t m + r$。验证除法恰好使用 $1$ 个桶，而乘法至少使用 $900$ 个不同的桶。\n- 测试 $7$ (2的幂模下的大整数边界条件)：设 $m = 2^{20}$，并测试 $x \\in \\{2^{61} - 1, 2^{61}, 2^{61} + 1, -(2^{61} - 1), -2^{61}, -(2^{61} + 1)\\}$。验证两种除法实现和位级实现在所有这些 $x$ 上的结果相等。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由七个布尔值组成的逗号分隔列表，并用方括号括起来，不含空格。例如，一个有效的输出类似于“[true1,true2,true3,true4,true5,true6,true7]”，其中每个“truei”是编程语言布尔值到字符串转换生成的“True”或“False”。\n\n不允许用户输入。不允许访问外部文件或网络。所有数值答案均为无单位的实数或整数，不涉及物理单位或角度。七个测试用例的输出必须各为一个布尔值。", "solution": "用户提供的问题陈述已经过仔细分析，并被确定为**有效**。它在科学上基于算法和数据结构的既定原则，特别是哈希表索引生成。该问题定义良好，所有参数、定义和约束都清晰明确地作了规定。它要求实现和验证标准的哈希方法，并通过一个全面、设计良好的测试套件来检验，该套件旨在探究这些方法的基本数学特性和实际行为。\n\n### 基于原则的解决方案设计\n\n该解决方案涉及实现两种主要的哈希策略——除法和乘法——然后对它们进行一系列严格的白盒测试。设计基于所提供的精确数学定义。\n\n#### 1. 除法\n\n除法通过计算键 $x$ 除以表大小 $m$ 的余数来得到哈希索引。在数学上，这表示为 $h(x) = x \\pmod m$。问题要求用三种不同的方式实现此方法，并且在指定条件下它们必须是等价的。\n\n**实现1：标准余数**\n此实现使用编程语言提供的内置余数运算符。在 Python 中，运算符 `%` 用于计算余数。对于一个正模数 $m > 0$，Python 的 `x % m` 对任何整数 $x$（正数或负数）都能正确地产生一个在区间 $[0, m-1]$ 内的结果，这与问题对余数的定义完全匹配：即唯一的整数 $r$ 满足 $x = qm + r$ 且 $0 \\le r < m$。\n\n**实现2：基于向下取整的恒等式**\n此实现基于数学恒等式 $x \\pmod m = x - m \\lfloor \\frac{x}{m} \\rfloor$。对于整数算术，这等同于 `x - m * (x // m)`，其中 `//` 是整数向下取整除法运算符。此公式在数学上与标准余数等价，并且对于所有整数 $x$ 和正整数 $m$，必须产生相同的结果。\n\n**实现3：针对2的幂模数的位运算方法**\n当表大小 $m$ 是2的幂时，即 $m = 2^k$（对于某个整数 $k \\ge 1$），操作 $x \\pmod m$ 等价于隔离出 $x$ 的二进制表示的低 $k$ 位。这是因为任何整数 $x$ 都可以写成 $x = q \\cdot 2^k + r$，其中 $r$ 是由低 $k$ 位表示的整数。因此余数就是 $r$。这种位级提取可以通过与一个掩码进行按位与（AND）运算来高效执行。所需的掩码是 $m-1$，其二进制表示为一串 $k$ 个1。因此，哈希索引计算为 $h(x) = x \\text{ & } (m-1)$，其中 `&` 表示按位与运算符。当使用在现代计算架构中标准的二进制补码表示法时，这种等价性对正整数和负整数都成立。\n\n#### 2. 乘法\n\n乘法通过公式 $h(x) = \\lfloor m \\cdot \\{xA\\} \\rfloor$ 计算哈希索引，其中 $A$ 是一个在 $(0, 1)$ 范围内的选定常数，$\\{y\\} = y - \\lfloor y \\rfloor$ 表示实数 $y$ 的小数部分。\n\n**实现与原理**\n该方法的工作原理是首先将整数键 $x$ 映射到一个实数 $xA$。然后，小数部分 $\\{xA\\}$ 提供一个在区间 $[0, 1)$ 内的值，从而有效地打乱了键的值。乘以 $m$ 将该值缩放到范围 $[0, m)$，最后的向下取整操作将其映射到一个在 $[0, m-1]$ 范围内的整数索引。\n\n该方法的有效性对 $A$ 的选择高度敏感。\n- 如果 $A$ 是一个小数部分具有“良好”分布特性的无理数（例如，黄金分割率的共轭数 $A = \\frac{\\sqrt{5}-1}{2} \\approx 0.618$），则产生的哈希值倾向于均匀地分布在各个桶中。这对于避免冲突是理想的。\n- 如果 $A$ 是一个简单的有理数，例如 $A = \\frac{p}{q}$（其中 $p, q$ 是小整数），该方法可能会表现出退化行为。例如，如果 $A = 1/2$ 且 $m$ 是2的幂，那么将只会产生两个不同的哈希值，导致性能极差。\n\n实现将使用标准的双精度浮点运算（例如 `numpy.float64`）来表示 $A$ 并执行中间计算。\n\n#### 3. 测试套件与不变式\n\n七个测试用例旨在验证所实现的哈希函数的正确性和特定属性。\n\n- **测试 1、3 和 7** 是等价性检查。它们确认除法的三种实现对于一系列输入——正整数（测试1）、负整数（测试3）和测试标准定长整数类型极限的极大整数（测试7）——产生相同的结果。这验证了底层的数学等价性。\n- **测试 2** 验证了模运算的一个基本属性：对于任何算术级数 $x_t = tm+r$，通过除法得到的哈希值始终是常数余数 $r$。这确保了实现在算术上是健全的。\n- **测试 4** 对乘法的均匀性提供了量化检查。通过选择一个好的常数 $A$ 和一个大的键集合，它测量了桶占用率的分布情况。条件 $\\max(\\text{count}) - \\min(\\text{count}) \\le \\lceil 4 \\sqrt{N / m} \\rceil$ 是一种启发式方法，用以确认分布接近均匀（计数的范围相对于计数的预期标准差是有界的）。\n- **测试 5** 与测试4相对应。它通过使用一个不好的 $A$ 选择（$A=1/2$）和一个2的幂的表大小来展示乘法的退化情况，验证这会导致哈希空间灾难性地崩溃到只有两个桶。\n- **测试 6** 在相同的输入数据（一个算术级数）上提供了两种方法之间的直接对比。它确认除法可预测地将所有键映射到单个桶中，而乘法使用一个好的常数 $A$ 则将键广泛地散布在整个哈希表中，突显了它们对输入模式的不同敏感性。\n\n解决方案将是一个独立的 Python 程序，实现这些函数并执行七个测试，按规定生成一个布尔结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates division and multiplication hashing methods.\n    \"\"\"\n\n    # --------------------------------------------------------------------------\n    # HASH FUNCTION IMPLEMENTATIONS\n    # --------------------------------------------------------------------------\n\n    def division_method_mod(x: int, m: int) -> int:\n        \"\"\"\n        Computes the hash index using the canonical remainder operator.\n        Corresponds to x mod m.\n        \"\"\"\n        return x % m\n\n    def division_method_floor(x: int, m: int) -> int:\n        \"\"\"\n        Computes the hash index using the identity x - m * floor(x/m).\n        \"\"\"\n        if m == 0:\n            raise ValueError(\"Modulus m must be positive.\")\n        return x - m * (x // m)\n\n    def division_method_bitwise(x: int, m: int) -> int:\n        \"\"\"\n        Computes the hash index using bitwise AND for m = 2^k.\n        \"\"\"\n        # This implementation assumes m is a power of 2, but the logic\n        # doesn't strictly require a check as it's only used in contexts\n        # where this is guaranteed.\n        return x & (m - 1)\n\n    def multiplication_method(x: int, m: int, A: float) -> int:\n        \"\"\"\n        Computes the hash index using the multiplication method:\n        h(x) = floor(m * {x*A}), where {y} = y - floor(y).\n        \"\"\"\n        if m == 0:\n            raise ValueError(\"Table size m must be positive.\")\n        if not (0  A  1):\n            raise ValueError(\"Constant A must be in (0, 1).\")\n        \n        y = x * A\n        # The fractional part {y} is y - floor(y).\n        frac_part = y - np.floor(y)\n        # Final index calculation\n        index = np.floor(m * frac_part)\n        return int(index)\n\n    # --------------------------------------------------------------------------\n    # WHITE-BOX TEST SUITE\n    # --------------------------------------------------------------------------\n\n    def test1() - bool:\n        \"\"\"\n        Test 1: Power-of-two equivalence and range.\n        m = 2^10, x in {0, ..., 4095}.\n        Verify all three division methods are equal and in range.\n        \"\"\"\n        m = 2**10\n        for x in range(4096):\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3 and 0 = h1  m):\n                return False\n        return True\n\n    def test2() - bool:\n        \"\"\"\n        Test 2: Arithmetic progression under prime modulus.\n        m = 1019, r = 57, x = t*m + r for t in {0, ..., 999}.\n        Verify both division methods return r.\n        \"\"\"\n        m = 1019\n        r = 57\n        for t in range(1000):\n            x = t * m + r\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            if not (h1 == r and h2 == r):\n                return False\n        return True\n\n    def test3() - bool:\n        \"\"\"\n        Test 3: Negative keys under power-of-two modulus.\n        m = 2^8, x in {-300, ..., 300}.\n        Verify all three division methods are equal.\n        \"\"\"\n        m = 2**8\n        for x in range(-300, 301):\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3):\n                return False\n        return True\n\n    def test4() - bool:\n        \"\"\"\n        Test 4: Near-uniformity for multiplication method.\n        m = 2^10, A = (sqrt(5)-1)/2, x in {0, ..., 65535}.\n        Check max(counts) - min(counts) = ceil(4 * sqrt(N/m)).\n        \"\"\"\n        m = 2**10\n        A = (np.sqrt(5) - 1) / 2\n        N = 65536\n        counts = np.zeros(m, dtype=int)\n        \n        for x in range(N):\n            h = multiplication_method(x, m, A)\n            if not (0 = h  m): return False # Implicit range safety check\n            counts[h] += 1\n            \n        max_count = np.max(counts)\n        min_count = np.min(counts)\n        bound = np.ceil(4 * np.sqrt(N / m))\n        \n        return (max_count - min_count) = bound\n\n    def test5() - bool:\n        \"\"\"\n        Test 5: Degeneracy detection for rational slope.\n        m = 2^10, A = 1/2, x in {0, ..., 4095}.\n        Verify exactly 2 distinct buckets are used.\n        \"\"\"\n        m = 2**10\n        A = 0.5\n        buckets = set()\n        for x in range(4096):\n            h = multiplication_method(x, m, A)\n            buckets.add(h)\n        return len(buckets) == 2\n\n    def test6() - bool:\n        \"\"\"\n        Test 6: Cross-method contrast on arithmetic progression.\n        m = 2^10, A = (sqrt(5)-1)/2, r = 7, x = t*m + r for t in {0, ..., 2047}.\n        Verify division method uses 1 bucket, multiplication uses = 900.\n        \"\"\"\n        m = 2**10\n        A = (np.sqrt(5) - 1) / 2\n        r = 7\n        div_buckets = set()\n        mul_buckets = set()\n\n        for t in range(2048):\n            x = t * m + r\n            h_div = division_method_mod(x, m)\n            h_mul = multiplication_method(x, m, A)\n            div_buckets.add(h_div)\n            mul_buckets.add(h_mul)\n            \n        return len(div_buckets) == 1 and len(mul_buckets) = 900\n\n    def test7() - bool:\n        \"\"\"\n        Test 7: Large-integer boundary conditions.\n        m = 2^20, test specific large integers around 2^61.\n        Verify equality of all three division methods.\n        \"\"\"\n        m = 2**20\n        p = 2**61\n        keys = [p - 1, p, p + 1, -(p - 1), -p, -(p + 1)]\n        \n        for x in keys:\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3):\n                return False\n        return True\n\n    # --------------------------------------------------------------------------\n    # EXECUTION\n    # --------------------------------------------------------------------------\n    \n    test_functions = [test1, test2, test3, test4, test5, test6, test7]\n    results = [func() for func in test_functions]\n    \n    # Format the final output string as specified: [True,False,...] without spaces.\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3229012"}, {"introduction": "选择“最佳”算法通常取决于输入数据的内在结构，稀疏多项式乘法便是一个绝佳的例证。在本练习中，你将亲手实现一个为稀疏数据量身定制的乘法算法，并将其与为稠密数据设计的强大算法（基于快速傅里叶变换 $FFT$）进行性能对比分析。这个实践案例将让你深刻理解一个核心原则：渐进最优的算法在面对具有特殊结构的数据时，未必总是实际应用中的最佳选择。[@problem_id:3229171]", "problem": "给定两个以单向链表形式表示的稀疏单变量多项式。每个节点包含一个指数和一个系数，并且链表按指数升序排序。对于一个具有整数指数和整数系数的多项式 $P(x)$，其表示为一个节点链表 $[(e_0,c_0)] \\rightarrow [(e_1,c_1)] \\rightarrow \\dots$，其中 $e_i$ 是非负整数，$c_i$ 是整数，且指数是严格递增的。您必须实现这种稀疏多项式的乘法，并根据一个简单明确的成本模型，推导出一个有原则的决策规则，以判断何时使用快速傅里叶变换（FFT）比稀疏方法更有效。\n\n基本依据和假设：\n- 使用多项式乘法的定义：对于 $P(x) = \\sum_{i=0}^{d_P} a_i x^i$ 和 $Q(x) = \\sum_{j=0}^{d_Q} b_j x^j$，它们的乘积为 $R(x) = P(x) \\cdot Q(x) = \\sum_{k=0}^{d_P + d_Q} \\left( \\sum_{i+j=k} a_i b_j \\right) x^k$。\n- 在稀疏链表表示法中，设 $t_P$ 是 $P(x)$ 中非零项的数量，$t_Q$ 是 $Q(x)$ 中非零项的数量。稀疏乘法方法遍历所有项对，并将乘积累加到相应的指数桶中。\n- 使用经过充分检验的算法事实：\n  - 朴素的稀疏项对乘法执行 $O(t_P \\cdot t_Q)$ 次标量乘法和加法；将其成本建模为 $T_{\\text{sparse}} = c_s \\cdot t_P \\cdot t_Q$，其中 $c_s$ 是一个捕获单位操作成本的正常量。\n  - 对长度为 $n$ 的密集数组进行卷积的快速傅里叶变换（FFT）的成本为 $O(n \\log n)$；将其建模为 $T_{\\text{fft}} = c_f \\cdot n \\log_2 n$，其中 $c_f$ 是一个捕获单位操作成本的正常量，$\\log_2$ 是以 2 为底的对数。\n- 密集卷积长度 $n$ 必须至少是能捕获所有系数的最小长度，即 $n \\ge d_P + d_Q + 1$。为了使用基-2 FFT，将 $n$ 设置为大于或等于 $d_P + d_Q + 1$ 的最小 2 的幂。\n- 系数运算使用精确整数算术执行。\n- 如果某个系数累加到 $0$，则相应的项将从输出的稀疏表示中省略。\n- 如果其中一个多项式是零多项式（没有节点），则乘积也是零多项式。\n\n您的任务：\n- 实现一个稀疏乘法程序，该程序接收 $P(x)$ 和 $Q(x)$ 的两个链表，并返回 $R(x) = P(x) \\cdot Q(x)$ 的链表，其中项按指数排序，且已移除零系数项。\n- 对每个测试用例，计算：\n  - 乘积多项式 $R(x)$，表示为一个按指数排序的指数-系数对列表，形式为列表的列表 $[[e_1,c_1],[e_2,c_2],\\dots]$。\n  - 选定的 FFT 长度 $n_{\\text{fft}}$，定义为当 $P(x)$ 和 $Q(x)$ 都不为零时，大于或等于 $d_P + d_Q + 1$ 的最小 2 的幂；如果任一多项式为零，则定义 $n_{\\text{fft}} = 1$。\n  - 一个盈亏平衡密集长度 $n_{\\text{be}}$（以 2 的幂形式），根据方程 $T_{\\text{fft}}(n) \\le T_{\\text{sparse}}$（即 $c_f \\cdot n \\log_2 n \\le c_s \\cdot t_P \\cdot t_Q$）计算。将 $n_{\\text{be}}$ 解释为大于或等于满足此不等式的最小正实数 $n$ 的最小 2 的幂；如果 $t_P \\cdot t_Q = 0$，则设 $n_{\\text{be}} = 1$。\n  - 一个布尔值，指示对于给定的多项式和成本常数，FFT 是否更有效，定义为 $T_{\\text{fft}}(n_{\\text{fft}})  T_{\\text{sparse}}$。\n- 以纯数学术语表达最终输出；不涉及物理单位或角度单位。所有数值必须是适当的整数或浮点数。\n\n测试套件：\n- 使用以下四个测试用例，每个用例由一对稀疏多项式和成本常数 $c_s$ 和 $c_f$ 指定。\n  - 用例 1：$P(x)$ 的项为 $[(0,3),(1,2),(4,5)]$，$Q(x)$ 的项为 $[(0,1),(2,4)]$，其中 $c_s = 1.0$ 且 $c_f = 0.1$。\n  - 用例 2：$P(x)$ 的所有项为 $[(0,1),(1,1),(2,1),\\dots,(31,1)]$，$Q(x)$ 的所有项也为 $[(0,1),(1,1),(2,1),\\dots,(31,1)]$，其中 $c_s = 1.0$ 且 $c_f = 0.1$。\n  - 用例 3：$P(x)$ 只有一个项 $[(1000,2)]$，$Q(x)$ 只有一个项 $[(2000,3)]$，其中 $c_s = 1.0$ 且 $c_f = 0.1$。\n  - 用例 4：$P(x)$ 是零多项式 $[]$，$Q(x)$ 的项为 $[(0,5),(3,2)]$，其中 $c_s = 1.0$ 且 $c_f = 0.1$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，且不含任何空格。\n- 每个测试用例的结果本身必须是一个形如 $[R_{\\text{pairs}},n_{\\text{fft}},n_{\\text{be}},\\text{fft\\_more\\_efficient}]$ 的列表，其中 $R_{\\text{pairs}}$ 是 $R(x)$ 的指数-系数对列表，$n_{\\text{fft}}$ 和 $n_{\\text{be}}$ 是整数，而 $\\text{fft\\_more\\_efficient}$ 是一个布尔值。\n- 因此，完整的输出必须是 $[[R_1,n_{\\text{fft},1},n_{\\text{be},1},B_1],[R_2,n_{\\text{fft},2},n_{\\text{be},2},B_2],[R_3,n_{\\text{fft},3},n_{\\text{be},3},B_3],[R_4,n_{\\text{fft},4},n_{\\text{be},4},B_4]]$ 的形式，其中每个内部列表都遵循指定的结构，并且整个字符串不包含任何空格。", "solution": "问题陈述已经过分析并确定为有效。它在科学上基于算法分析和数据结构的原理，问题提出得当，定义清晰明确，并且是自包含的，为测试用例提供了所有必要的数据和约束。\n\n任务是实现稀疏多项式乘法，并与基于FFT的方法进行性能分析。该解决方案涉及对每个提供的测试用例进行几个计算步骤。\n\n**1. 稀疏多项式乘法**\n\n两个稀疏多项式 $P(x) = \\sum_{i} c_{P,i} x^{e_{P,i}}$ 和 $Q(x) = \\sum_{j} c_{Q,j} x^{e_{Q,j}}$ 的乘积产生一个乘积多项式 $R(x)$。$R(x)$ 中的每一项都是由 $P(x)$ 中的一项与 $Q(x)$ 中的一项相乘形成的。所得项的系数等于原始系数的乘积 $c_{P,i} \\cdot c_{Q,j}$，指数等于原始指数的和 $e_{P,i} + e_{Q,j}$。\n\n稀疏乘法算法的核心是计算所有这样的逐项乘积，然后合并具有相同指数的项。字典（哈希映射）是用于此累加的有效数据结构。字典的键是乘积多项式的指数，值是相应的累加系数。\n\n算法流程如下：\n1. 初始化一个空字典 `product_terms`，用于存储按指数映射的结果系数。\n2. 如果任一输入多项式是零多项式（表示为空项列表），则乘积也是零多项式，并返回一个空列表。\n3. 遍历多项式 $P(x)$ 的每一项 $(e_p, c_p)$。\n4. 对于 $P(x)$ 的每一项，遍历多项式 $Q(x)$ 的每一项 $(e_q, c_q)$。\n5. 对每一对项，计算新指数 $e_{new} = e_p + e_q$ 和新系数 $c_{new} = c_p \\cdot c_q$。\n6. 在 `product_terms` 字典中更新指数 $e_{new}$ 的系数：`product_terms[e_new] = product_terms.get(e_new, 0) + c_new`。\n7. 遍历所有项对后，过滤 `product_terms` 字典，移除系数为零的任何条目。\n8. 根据指数按升序对剩余项进行排序。\n9. 将排序后的项格式化为指定的列表的列表形式 $[[e_1, c_1], [e_2, c_2], \\dots]$。\n\n此过程正确计算了乘积多项式，同时遵循指定的稀疏表示，确保项已排序且系数非零。\n\n**2. FFT长度 ($n_{\\text{fft}}$) 的计算**\n\n用于多项式乘法的快速傅里叶变换（FFT）算法需要将多项式转换为密集的系数数组表示。此数组的长度 $n$ 必须足够大，以容纳乘积多项式而不会发生混叠。两个多项式 $P(x)$ 和 $Q(x)$ 的乘积的次数是 $d_P + d_Q$。因此，乘积多项式中的系数数量最多为 $d_P + d_Q + 1$。\n\n对于基-2 FFT算法，数组长度 $n$ 必须是2的幂。因此，$n_{\\text{fft}}$ 定义为大于或等于 $d_P + d_Q + 1$ 的最小2的幂。\n- 首先，从输入的多项式中确定次数 $d_P$ 和 $d_Q$。对于一个表示为按指数排序的项列表的非零多项式，其次数是最后一项的指数。\n- 所需的最小长度为 $N = d_P + d_Q + 1$。\n- 然后，$n_{\\text{fft}}$ 计算为 $2^k$，其中 $k = \\lceil \\log_2 N \\rceil$。这可以使用位运算高效计算，例如，在 Python 中对于 $N  0$，可使用 `1  (N-1).bit_length()`。\n- 根据问题规范，如果任一多项式是零多项式，则 $n_{\\text{fft}}$ 定义为 $1$。\n\n**3. 盈亏平衡长度 ($n_{\\text{be}}$) 的计算**\n\n盈亏平衡长度 $n_{\\text{be}}$ 标志着基于FFT的方法的计算成本变得小于或等于稀疏方法的成本的点。成本由以下模型给出：\n- $T_{\\text{sparse}} = c_s \\cdot t_P \\cdot t_Q$\n- $T_{\\text{fft}}(n) = c_f \\cdot n \\log_2 n$\n\n盈亏平衡条件由不等式 $T_{\\text{fft}}(n) \\le T_{\\text{sparse}}$ 给出，这可以转换为 $c_f \\cdot n \\log_2 n \\le c_s \\cdot t_P \\cdot t_Q$。\n设 $K = \\frac{c_s \\cdot t_P \\cdot t_Q}{c_f}$。问题是找到区域 $n \\log_2 n \\le K$ 的边界。函数 $f(n) = n \\log_2 n$ 在 $n \\ge 1$ 时是单调递增的。我们必须找到超越方程 $n \\log_2 n = K$ 的根 $n_{root}$。这需要一种数值求根方法，例如二分法。\n\n二分法操作如下：\n1. 定义函数 $g(n) = n \\log_2 n - K$。我们寻求 $g(n)=0$ 的根。\n2. 对于 $K  0$，根 $n_{root}$ 大于 $1$。我们可以建立一个保证包含根的搜索区间 $[low, high]$（例如 $[1, K+2]$）。\n3. 通过计算中点 `mid = (low + high) / 2` 并评估 $g(mid)$ 来迭代地缩小区间。如果 $g(mid)  0$，则根在 $[mid, high]$ 中；否则，它在 $[low, mid]$ 中。\n4. 经过足够次数的迭代后，区间变得足够小，其端点可以作为 $n_{root}$ 的近似值。\n\n一旦找到 $n_{root}$，$n_{\\text{be}}$ 就定义为大于或等于 $n_{root}$ 的最小2的幂。这计算为 $2^k$，其中 $k = \\lceil \\log_2(n_{root}) \\rceil$。\n特殊情况：如果 $t_P \\cdot t_Q = 0$，则 $K=0$，根为 $n_{root}=1$，并且问题规定 $n_{\\text{be}} = 1$。\n\n**4. 效率比较**\n\n决定对于给定的多项式对，FFT方法是否更有效，是基于使用计算出的FFT长度 $n_{\\text{fft}}$ 对两种成本模型进行直接比较。\n- 计算 $T_{\\text{sparse}} = c_s \\cdot t_P \\cdot t_Q$。\n- 计算 $T_{\\text{fft}}(n_{\\text{fft}}) = c_f \\cdot n_{\\text{fft}} \\log_2 n_{\\text{fft}}$。\n- 当且仅当 $T_{\\text{fft}}(n_{\\text{fft}})  T_{\\text{sparse}}$ 时，布尔值 `fft_more_efficient` 为真。\n\n**示例：用例1的演练**\n\n- 给定：$P(x) = [(0,3), (1,2), (4,5)]$，$Q(x) = [(0,1), (2,4)]$，$c_s = 1.0$，$c_f = 0.1$。\n- 属性：$t_P = 3$，$d_P = 4$；$t_Q = 2$，$d_Q = 2$。\n\n1.  **乘积 $R(x)$**：\n    - 项的乘积：$(0,3)\\times(0,1)\\to(0,3)$，$(0,3)\\times(2,4)\\to(2,12)$，$(1,2)\\times(0,1)\\to(1,2)$，$(1,2)\\times(2,4)\\to(3,8)$，$(4,5)\\times(0,1)\\to(4,5)$，$(4,5)\\times(2,4)\\to(6,20)$。\n    - 所有结果指数都是唯一的。排序后得到 $R_{\\text{pairs}} = [[0,3],[1,2],[2,12],[3,8],[4,5],[6,20]]$。\n\n2.  **$n_{\\text{fft}}$**：\n    - $N = d_P + d_Q + 1 = 4 + 2 + 1 = 7$。\n    - 大于或等于 7 的最小2的幂是 8。因此，$n_{\\text{fft}} = 8$。\n\n3.  **$n_{\\text{be}}$**：\n    - $K = \\frac{c_s \\cdot t_P \\cdot t_Q}{c_f} = \\frac{1.0 \\cdot 3 \\cdot 2}{0.1} = 60$。\n    - 求解 $n \\log_2 n = 60$。二分法搜索发现 $n_{root} \\approx 15.26$。\n    - 大于或等于 15.26 的最小2的幂是 16。因此，$n_{\\text{be}} = 16$。\n\n4.  **效率**：\n    - $T_{\\text{sparse}} = 1.0 \\cdot 3 \\cdot 2 = 6$。\n    - $T_{\\text{fft}}(8) = 0.1 \\cdot 8 \\log_2 8 = 0.1 \\cdot 8 \\cdot 3 = 2.4$。\n    - 因为 $2.4  6$，`fft_more_efficient` 为 `True`。\n\n- **用例1的最终结果**：$[[[0,3],[1,2],[2,12],[3,8],[4,5],[6,20]], 8, 16, True]$", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the polynomial multiplication and analysis problem for a suite of test cases.\n    \"\"\"\n\n    def multiply_sparse(p1, p2):\n        \"\"\"\n        Multiplies two sparse polynomials represented as lists of [exponent, coefficient] pairs.\n        \"\"\"\n        if not p1 or not p2:\n            return []\n\n        product_terms = {}\n        for exp1, coeff1 in p1:\n            for exp2, coeff2 in p2:\n                new_exp = exp1 + exp2\n                new_coeff = coeff1 * coeff2\n                product_terms[new_exp] = product_terms.get(new_exp, 0) + new_coeff\n        \n        # Filter out zero-coefficient terms and sort by exponent\n        result = sorted(\n            [[exp, coeff] for exp, coeff in product_terms.items() if coeff != 0],\n            key=lambda term: term[0]\n        )\n        return result\n\n    def get_poly_properties(p):\n        \"\"\"\n        Returns the number of terms (t) and degree (d) of a polynomial.\n        \"\"\"\n        if not p:\n            return 0, -1 # Convention for zero polynomial\n        num_terms = len(p)\n        degree = p[-1][0] if p else -1\n        return num_terms, degree\n\n    def solve_n_log2_n_eq_K(K):\n        \"\"\"\n        Numerically solves n * log2(n) = K for n using the bisection method.\n        \"\"\"\n        if K  0:\n            return float('nan')\n        if K == 0:\n            return 1.0\n\n        # Function f(n) = n*log2(n) - K. We are finding the root of f(n).\n        # We know the root is  1 for K  0.\n        # A safe upper bound for the root is K+2, since for n  2, n*log2(n)  n.\n        low = 1.0\n        high = K + 2.0\n\n        # 100 iterations is sufficient for high precision floating point results.\n        for _ in range(100):\n            mid = (low + high) / 2.0\n            if mid == 0: # Should not happen with our bounds\n                low = 1e-9 # Safety against log(0)\n                continue\n            \n            val = mid * np.log2(mid)\n            \n            if val  K:\n                low = mid\n            else:\n                high = mid\n        \n        return high\n\n    test_cases = [\n        # Case 1\n        (\n            [[0, 3], [1, 2], [4, 5]], \n            [[0, 1], [2, 4]], \n            1.0, 0.1\n        ),\n        # Case 2\n        (\n            [[i, 1] for i in range(32)],\n            [[i, 1] for i in range(32)],\n            1.0, 0.1\n        ),\n        # Case 3\n        (\n            [[1000, 2]],\n            [[2000, 3]],\n            1.0, 0.1\n        ),\n        # Case 4\n        (\n            [],\n            [[0, 5], [3, 2]],\n            1.0, 0.1\n        )\n    ]\n\n    results = []\n    for p1, p2, cs, cf in test_cases:\n        # Task a: Compute Product Polynomial R(x)\n        R_pairs = multiply_sparse(p1, p2)\n\n        t_p, d_p = get_poly_properties(p1)\n        t_q, d_q = get_poly_properties(p2)\n\n        # Task b: Compute n_fft\n        if t_p == 0 or t_q == 0:\n            n_fft = 1\n        else:\n            n_min = d_p + d_q + 1\n            if n_min = 0: # Should not happen for non-zero polys\n                n_fft = 1\n            else:\n                # Smallest power of 2 = n_min\n                n_fft = 1  (n_min - 1).bit_length()\n\n        # Task c: Compute n_be\n        if t_p * t_q == 0:\n            n_be = 1\n        else:\n            K = (cs * t_p * t_q) / cf\n            n_root = solve_n_log2_n_eq_K(K)\n            if n_root = 1.0:\n                n_be = 1\n            else:\n                # Smallest power of 2 = n_root\n                power = math.ceil(np.log2(n_root))\n                n_be = 1  int(power)\n\n        # Task d: Compute FFT efficiency\n        T_sparse = cs * t_p * t_q\n        if n_fft == 1:\n            T_fft = 0 # log2(1) = 0\n        else:\n            T_fft = cf * n_fft * np.log2(n_fft)\n        \n        is_fft_more_efficient = T_fft  T_sparse\n        \n        # Format the result for this case\n        r_pairs_str = f\"[{','.join(f'[{e},{c}]' for e, c in R_pairs)}]\"\n        case_result = f\"[{r_pairs_str},{n_fft},{n_be},{str(is_fft_more_efficient)}]\"\n        results.append(case_result)\n\n    final_output = f\"[{','.join(results)}]\"\n    final_output = final_output.replace(\" \", \"\") # Remove all spaces as per spec\n    print(final_output)\n\nsolve()\n```", "id": "3229171"}, {"introduction": "高效的乘法策略在计算数学领域（如密码学和组合学）中至关重要，而计算大数阶乘的模是其中的一个常见问题。本练习将展示强大的“分治”思想如何被应用于处理计算密集型任务。通过递归地分解问题，你将学会如何在避免算术溢出的同时高效地计算大量数字的乘积，从而加深对递归思维和模算术的理解。[@problem_id:3229157]", "problem": "要求您设计并实现一个程序，该程序使用分治乘法策略计算阶乘对素数取模的结果。给定非负整数 $n$ 和素数模 $p$，目标是通过利用快速乘法和乘积树式的分治递归，高效地计算 $n! \\bmod p$ 的值，即使在 $n$ 非常大的情况下也能如此。\n\n您的设计中需要使用并证明以下基本原理：\n- 阶乘的定义：对于整数 $n \\ge 0$，$n! = \\prod_{k=1}^{n} k$，并约定 $0! = 1$。\n- 整数模 $p$ 环的基本性质：对于素数 $p$，模乘法满足结合律和交换律，且模 $p$ 约简与乘法兼容，即 $(ab) \\bmod p = \\big((a \\bmod p)(b \\bmod p)\\big) \\bmod p$。\n- 关于整除性的基本观察：如果 $n \\ge p$ 且 $p$ 是素数，那么 $p$ 整除 $n!$，因此 $n! \\equiv 0 \\pmod p$。\n- 平衡的分治乘法通过配对子乘积来保持操作数大小平衡，从而降低计算成本，这与快速整数乘法相辅相成。\n\n您的算法任务：\n- 对于输入 $(n, p)$（其中 $p$ 为素数），计算 $n! \\bmod p$。\n- 如果 $n \\ge p$，则根据上述整除性事实直接输出 $0$。\n- 否则，使用分治的区间乘积递归计算乘积 $\\prod_{k=1}^{n} k$ 对 $p$ 取模的结果，该递归将 $[1,n]$ 分成近似相等的两半，将子乘积对 $p$ 取模相乘，并递归直到处理单个元素。\n\n您的实现约束：\n- 程序必须是一个完整的、可运行的程序，在不读取任何输入的情况下，评估以下测试套件并按指定格式打印结果。\n\n测试套件（每个测试用例都是一对 $(n, p)$，其中 $p$ 是素数）：\n- 用例 1：$(n, p) = (0, 101)$。\n- 用例 2：$(n, p) = (1, 101)$。\n- 用例 3：$(n, p) = (20, 101)$。\n- 用例 4：$(n, p) = (100, 101)$。\n- 用例 5：$(n, p) = (200, 193)$。\n- 用例 6：$(n, p) = (65536, 65537)$。\n\n所有答案均为整数。不涉及物理单位。不适用角度。不适用百分比。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试套件的顺序相同，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是用例 $i$ 的整数结果。", "solution": "对用户提供的问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n- **目标**：计算非负整数 $n$ 和素数模 $p$ 下的 $n! \\pmod{p}$。\n- **方法论**：采用分治乘法策略，也称为乘积树。\n- **基本定义和性质**：\n    - 阶乘：对于 $n \\ge 1$，$n! = \\prod_{k=1}^{n} k$，且 $0! = 1$。\n    - 模算术：$(ab) \\bmod p = \\big((a \\bmod p)(b \\bmod p)\\big) \\bmod p$。\n    - 整除性法则：如果 $n \\ge p$ 且 $p$ 为素数，则 $p$ 是 $n!$ 的一个因子，这意味着 $n! \\equiv 0 \\pmod{p}$。\n- **算法说明**：\n    - 如果 $n \\ge p$，结果为 $0$。\n    - 如果 $n  p$，则需使用一个递归函数计算乘积 $\\prod_{k=1}^{n} k$ 对 $p$ 取模的结果，该函数将乘法范围 $[1, n]$ 分为两个平衡的子范围。\n- **测试套件**：\n    - 用例 1：$(n, p) = (0, 101)$\n    - 用例 2：$(n, p) = (1, 101)$\n    - 用例 3：$(n, p) = (20, 101)$\n    - 用例 4：$(n, p) = (100, 101)$\n    - 用例 5：$(n, p) = (200, 193)$\n    - 用例 6：$(n, p) = (65536, 65537)$\n- **输出格式**：单行文本：`[r_1,r_2,r_3,r_4,r_5,r_6]`。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据既定标准对问题进行评估。\n- **科学依据**：该问题基于数论（模算术、素数性质、阶乘）和计算机科学（分治算法）的基本且正确的原理。提供的素数 $101$、$193$ 和 $65537$（一个费马素数，$F_4$）确实是素数。这些原理并非推测性的。\n- **适定性**：该问题是适定的。对于任何有效的输入 $(n, p)$，量 $n! \\pmod{p}$ 是一个唯一的、明确定义的整数。所描述的算法是确定性的，并能得出唯一的解。\n- **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n- **缺陷分析**：\n    1.  **科学或事实不健全**：无。前提在事实上和数学上都是健全的。\n    2.  **不可形式化或不相关**：无。该问题是算法数论中的一个标准练习，并且可以直接形式化。\n    3.  **设置不完整或矛盾**：无。所有必要的数据、定义和约束都已提供且自洽。\n    4.  **不切实际或不可行**：无。这些计算完全在标准现代计算机的能力范围之内。\n    5.  **不适定或结构不良**：无。问题结构清晰，并指导采用一种特定的、有效的算法方法。\n    6.  **伪深刻、琐碎或同义反复**：无。虽然某些测试用例很简单，但一般性问题和所需方法并非无足轻重。$(65536, 65537)$ 的用例展示了高效算法相对于朴素迭代方法在处理大输入时的实用性。\n    7.  **超出科学可验证性范围**：无。结果在数学上是可验证的。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n问题是计算非负整数 $n$ 的阶乘对素数 $p$ 取模，记为 $n! \\pmod{p}$。\n\n首先，我们处理特殊情况。根据定义，$0! = 1$。因此，对于 $n=0$，对于任何模数 $p  1$，结果都是 $1$。\n\n数论中的一个关键观察简化了许多输入的问题。阶乘 $n!$ 是所有小于等于 $n$ 的正整数的乘积：$n! = 1 \\cdot 2 \\cdot \\dots \\cdot p \\cdot \\dots \\cdot n$。如果 $n \\ge p$，那么素数 $p$ 本身就是这个乘积中的一个因子。因此，$n!$ 可以被 $p$ 整除，用模算术的语言来说就是 $n! \\equiv 0 \\pmod{p}$。这提供了一个高效的检查，我们的算法必须优先执行。\n\n当 $n  p$ 时，情况会变得更为复杂。在这种情况下，整数 $1, 2, \\dots, n$ 都不能被素数 $p$ 整除。因此，它们的乘积 $n!$ 也不能被 $p$ 整除，且 $n! \\not\\equiv 0 \\pmod{p}$。我们必须计算这个乘积。朴素的迭代乘法虽然正确，但可能效率低下。问题要求使用分治策略，我们将对其进行形式化。\n\n我们定义一个函数 $P(a, b)$，用于计算一个范围内的整数乘积：\n$$\nP(a, b) = \\prod_{k=a}^{b} k = a \\cdot (a+1) \\cdot \\dots \\cdot b\n$$\n我们的目标是计算 $P(1, n) \\pmod{p}$。分治方法基于将范围 $[a, b]$ 分为两个子范围。我们选择一个中点 $m = \\lfloor(a+b)/2\\rfloor$。然后，乘积可以表示为：\n$$\nP(a, b) = \\left( \\prod_{k=a}^{m} k \\right) \\cdot \\left( \\prod_{k=m+1}^{b} k \\right) = P(a, m) \\cdot P(m+1, b)\n$$\n这个恒等式允许进行递归定义。为了计算 $P(a, b)$，我们递归地计算子范围 $P(a, m)$ 和 $P(m+1, b)$ 的乘积，然后将结果相乘。\n\n至关重要的是，我们关心的是对 $p$ 取模的结果。模算术的性质表明，模运算可以分配到乘法上：$(X \\cdot Y) \\pmod p = \\big( (X \\pmod p) \\cdot (Y \\pmod p) \\big) \\pmod p$。我们在递归的每一步都应用这个原理，以防止中间数变得过大。模乘积的递归关系是：\n$$\nP(a, b) \\pmod{p} = \\left( \\big(P(a, m) \\pmod{p}\\big) \\cdot \\big(P(m+1, b) \\pmod{p}\\big) \\right) \\pmod{p}\n$$\n递归需要基准情形来终止。当范围 $[a, b]$ 只包含一个元素时，即 $a=b$，乘积就是 $a$。如果范围为空，$a  b$，乘积是乘法单位元，即 $1$。\n\n这种通常被称为“乘积树”的递归结构将 $n-1$ 次乘法组织成一个深度为 $O(\\log n)$ 的平衡二叉树。虽然总乘法次数仍为 $O(n)$，但当使用用于极大整数乘法的高级算法（例如 Karatsuba、Toom-Cook 或基于 FFT 的方法）时，这种结构特别有利，因为它倾向于平衡操作数的大小，从而最大化这些次二次算法的效率。Python 内置的任意精度整数支持可能在内部利用了这些方法。\n\n让我们分析两个重要的测试用例：\n1.  **用例 4：$(n, p) = (100, 101)$**。这里，我们计算 $(p-1)! \\pmod{p}$。威尔逊定理（Wilson's Theorem）是初等数论的基石之一，它指出对于任何素数 $p$，都有 $(p-1)! \\equiv -1 \\pmod{p}$。因此，对于 $p=101$，我们期望 $100! \\equiv -1 \\equiv 100 \\pmod{101}$。\n2.  **用例 6：$(n, p) = (65536, 65537)$**。这是威尔逊定理在更大规模上的另一个实例。模数 $p = 65537$ 是费马素数 $F_4 = 2^{(2^4)} + 1$。我们被要求计算 $(p-1)! \\pmod{p}$。结果必须是 $-1 \\equiv 65536 \\pmod{65537}$。我们的分治算法将通过大约 $65535$ 次模乘法得到这个结果，这些乘法组织在一个深度为 $\\log_2(65536) = 16$ 的递归树中。\n\n最终算法如下：\n1.  定义一个主函数 `factorial_mod_p(n, p)`。\n2.  如果 $n=0$，返回 $1$。\n3.  如果 $n \\ge p$，返回 $0$。\n4.  否则，调用一个递归辅助函数 `product_range(1, n, p)`。\n5.  `product_range(a, b, p)` 函数实现分治逻辑：\n    - 基准情形：如果 $a  b$，返回 $1$。如果 $a=b$，返回 $a$。\n    - 递归步骤：计算 $m = (a+b)//2$，为 `product_range(a, m, p)` 和 `product_range(m+1, b, p)` 进行递归调用，将结果相乘，并取模 $p$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\ndef solve():\n    \"\"\"\n    Computes n! mod p for a set of test cases using a divide-and-conquer\n    multiplication strategy.\n    \"\"\"\n    # Set a higher recursion limit for potentially deep recursions,\n    # although the test cases here do not require it.\n    # The deepest recursion for n=65536 is log2(65536) = 16.\n    sys.setrecursionlimit(2000)\n\n    # The recursive helper function to compute the product of a range modulo p.\n    def _product_range_recursive(a: int, b: int, p: int) - int:\n        \"\"\"\n        Computes (a * (a+1) * ... * b) mod p using a recursive divide-and-conquer\n        approach.\n        \"\"\"\n        # Base case for empty product.\n        if a  b:\n            return 1\n        \n        # Base case for a single-element product.\n        if a == b:\n            return a\n        \n        # Optimization for a small range to reduce recursion overhead.\n        if b - a  4:\n            res = 1\n            for i in range(a, b + 1):\n                res = (res * i) % p\n            return res\n\n        # Recursive step: split the range, compute sub-products, and combine.\n        mid = (a + b) // 2\n        \n        left_product = _product_range_recursive(a, mid, p)\n        right_product = _product_range_recursive(mid + 1, b, p)\n        \n        return (left_product * right_product) % p\n\n    # The main function to compute n! mod p.\n    def factorial_mod_p(n: int, p: int) - int:\n        \"\"\"\n        Computes n! mod p, handling the special cases and invoking the\n        recursive product function.\n        \"\"\"\n        # By convention, 0! = 1.\n        if n == 0:\n            return 1\n        \n        # If n = p, then n! is divisible by p, so n! === 0 (mod p).\n        if n = p:\n            return 0\n        \n        # For 0  n  p, compute the product 1 * 2 * ... * n mod p.\n        return _product_range_recursive(1, n, p)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 101),     # Case 1\n        (1, 101),     # Case 2\n        (20, 101),    # Case 3\n        (100, 101),   # Case 4\n        (200, 193),   # Case 5\n        (65536, 65537) # Case 6\n    ]\n\n    results = []\n    for n, p in test_cases:\n        result = factorial_mod_p(n, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3229157"}]}