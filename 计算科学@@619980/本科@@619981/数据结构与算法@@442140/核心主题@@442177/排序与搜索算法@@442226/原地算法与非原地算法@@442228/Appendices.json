{"hands_on_practices": [{"introduction": "我们的探索始于一个基础任务：从数组中移除特定元素。这个练习将一个简单的非原地算法与一个使用经典双指针技术的、更节省空间的原地算法进行对比。通过分析写操作的数量，你将具体理解数据分布如何影响原地算法的性能 [@problem_id:3241063]。", "problem": "设计并分析两种算法，用于从一个数组中移除所有等于给定值 $x$ 的元素，同时保留剩余元素的原始相对顺序。使用以下基础概念：将原地算法（in-place algorithm）定义为在输入数据结构之外使用 $O(1)$ 额外空间的算法；将算法的稳定性（stability）定义为保留相等元素的原始顺序；以及一个简单的操作模型，其中“写入”是任何将值存储到数组单元格的赋值操作。目标是定义一个精确的写入计数度量标准，并比较一种原地稳定压缩算法和一种非原地稳定筛选算法。\n\n要求：\n- 实现一个原地稳定压缩算法，该算法使用两个索引将保留的元素向左移动。该算法必须在 $O(1) $的额外内存下运行，并且不能分配与输入长度成比例的辅助数组。仅当一个值被存入一个其索引与源索引不同的目标数组单元格时，才应计为一次写入，从而排除冗余的自我赋值。不要计算对压缩后前缀以外的单元格的任何写入，也不要计算任何内存释放或大小调整操作。\n- 实现一个非原地稳定筛选算法，该算法通过追加每个不等于 $x$ 的元素来构建一个新数组。每次向新数组追加操作计为一次写入。忽略对原始数组的任何写入。\n\n令 $n$ 表示数组长度，令 $m$ 表示等于 $x$ 的元素数量，令 $f$ 表示匹配项的比例，即 $f = m/n$。令 $k = n - m$ 表示保留的元素数量。原地算法必须保持稳定性。非原地算法必须保持稳定性。两种算法都必须根据定义的规则，按写入次数进行评估。\n\n测试套件：\n- 案例 A：$n = 10$, $f = 0.3$，数组 $A = \\{\\,$ $1$, $2$, $0$, $3$, $4$, $0$, $5$, $0$, $6$, $7$ $\\}$，$x = 0$。\n- 案例 B：$n = 10$, $f = 0.0$，数组 $B = \\{\\,$ $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$, $10$ $\\}$，$x = 0$。\n- 案例 C：$n = 8$, $f = 1.0$，数组 $C = \\{\\,$ $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ $\\}$，$x = 0$。\n- 案例 D：$n = 12$, $f = 0.5$，数组 $D = \\{\\,$ $0$, $0$, $0$, $0$, $0$, $0$, $1$, $2$, $3$, $4$, $5$, $6$ $\\}$，$x = 0$。\n- 案例 E：$n = 12$, $f = 0.25$，数组 $E = \\{\\,$ $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$, $0$, $0$, $0$ $\\}$，$x = 0$。\n\n您的程序必须为每个案例计算一个包含写入次数 $[W_{\\text{in}}, W_{\\text{out}}]$ 的双元素列表，其中 $W_{\\text{in}}$ 是原地算法的写入次数，$W_{\\text{out}}$ 是非原地算法的写入次数。最终输出格式必须是单行，包含一个由这些双元素列表组成的逗号分隔列表，并用方括号括起来。例如，格式为 $[\\,[a_1, b_1], [a_2, b_2]\\,]$，其中 $a_i$ 和 $b_i$ 是整数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个案例的结果格式化为双元素列表 $[W_{\\text{in}},W_{\\text{out}}]$（例如，`[[5,7],[0,10],[0,0]]`）。", "solution": "该问题要求对两种稳定的算法进行比较分析，这两种算法用于从数组中移除所有出现的值`$x$`。比较基于为原地压缩算法和非原地筛选算法精确定义的写入计数度量标准。\n\n令`$n$`为输入数组的长度，`$m$`为等于`$x$`的元素数量，`$k = n - m$`为要保留的元素数量。\n\n### 算法1：非原地稳定筛选 (Out-of-Place Stable Filter)\n\n该算法构建一个新数组来存储结果。它遍历输入数组，对于每个不等于`$x$`的元素，将其追加到新数组中。\n\n**稳定性：** 这种方法具有内在的稳定性。元素按其原始顺序从源数组中读取，被保留的元素以相同的序列写入目标数组，从而保持其初始相对顺序。\n\n**空间复杂度：** 该算法需要一个新数组来存储`$k$`个保留的元素。因此，其辅助空间复杂度为`$O(k)$`，在`$m=0$`的情况下，最高可达`$O(n)$`。根据定义，这是一种非原地算法。\n\n**写入次数 ($W_{\\text{out}}$):** 问题将此算法的写入次数定义为每次向新数组追加操作计为一次写入。由于恰好有`$k = n - m$`个元素被保留和追加，因此总写入次数恰好为`$k$`。\n$$W_{\\text{out}} = k = n - m$$\n\n### 算法2：原地稳定压缩 (In-Place Stable Compaction)\n\n该算法在原地修改数组，使用`$O(1)$`的额外空间。它采用双索引策略。一个“读取”索引（我们称之为`$i$`）从索引`$0$`到`$n-1$`扫描整个数组。一个“写入”索引（我们称之为`$j$`）跟踪下一个可用于存放保留元素的位置。\n\n过程如下：\n$1$. 初始化写入索引 `$j = 0$`.\n$2$. 使用读取索引 `$i$` 从 `$0$` 迭代到 `$n-1$`.\n$3$. 如果位于 `$A[i]$` 的元素不等于 `$x$`，则必须保留它。\n$4$. 此元素被放置在位置 `$A[j]$`。根据问题的规则，仅当源索引和目标索引不同时，即 `$i \\neq j$` 时，才计为一次写入。\n$5$. 将一个保留元素放置在 `$A[j]$` 后，写入索引 `$j$` 递增。\n\n**稳定性：** 此算法是稳定的。假设 `$A[p]$` 和 `$A[q]$` 是两个要保留的元素，其原始索引为 `$p  q$`。读取索引 `$i$` 会在遇到 `$A[q]$` 之前先遇到 `$A[p]$`。假设 `$A[p]$` 被写入 `$A[j_1]$`。然后写入索引递增。当读取索引稍后遇到 `$A[q]$` 时，它将被写入 `$A[j_2]$`，其中 `$j_2 > j_1$`。因此，原始的相对顺序得以保留。\n\n**写入次数 ($W_{\\text{in}}$):** 仅当 `$i \\neq j$` 时，才为位于索引 `$i$` 的保留元素计为一次写入。索引 `$i$` 和 `$j$` 从 `$0$` 开始，只要遇到的每个元素都被保留，它们就会一起递增。当在索引 `$i_{rem}$` 处首次发现要移除的元素（值为 `$x$`）时，读取索引 `$i$` 递增，但写入索引 `$j$` 不递增。从这一点开始，对于任何后续索引为 `$i > i_{rem}$` 的元素，都将满足 `$i > j$`。因此，对于每个出现在*第一次出现x之后*的保留元素，它将从位置 $i$ 移动到新位置 $j$（其中 $j  i$），这需要一次写入。任何出现在第一个 `$x$` 之前的保留元素都将有 `$i=j$`，因此不产生写入。\n\n因此，`$W_{\\text{in}}$`是数组中位于第一次出现`$x$`的索引处或之后的保留元素的数量。如果不存在等于`$x$`的元素，则`$W_{\\text{in}} = 0$`。\n\n### 应用于测试案例\n\n我们将这些推导出的计数规则应用于每个测试案例。\n\n**案例 A:** `$A = \\{1, 2, 0, 3, 4, 0, 5, 0, 6, 7\\}$, $x = 0$。\n- `$n = 10$, $m = 3$, 所以 $k = n - m = 7$.\n- `$W_{\\text{out}} = k = 7$。\n- `$x=0$` 首次出现在索引 `$2$`。出现在索引 `$2$` 或之后并被保留的元素是 `$3, 4, 5, 6, 7$`。共有 `$5$` 个这样的元素。\n- `$W_{\\text{in}} = 5$。\n- 结果: `[$5$, $7$]`\n\n**案例 B:** `$B = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\}$, $x = 0$。\n- `$n = 10$, $m = 0$, 所以 $k = n - m = 10$.\n- `$W_{\\text{out}} = k = 10$。\n- 值 `$x=0$` 未出现在数组中。对于原地算法，条件 `$i \\neq j$` 永远不会为真。\n- `$W_{\\text{in}} = 0$。\n- 结果: `[$0$, $10$]`\n\n**案例 C:** `$C = \\{0, 0, 0, 0, 0, 0, 0, 0\\}$, $x = 0$。\n- `$n = 8$, $m = 8$, 所以 $k = n - m = 0$.\n- `$W_{\\text{out}} = k = 0$。\n- 没有元素需要保留。原地算法的内部循环条件永远不会满足。\n- `$W_{\\text{in}} = 0$。\n- 结果: `[$0$, $0$]`\n\n**案例 D:** `$D = \\{0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6\\}$, $x = 0$。\n- `$n = 12$, $m = 6$, 所以 $k = n - m = 6$.\n- `$W_{\\text{out}} = k = 6$。\n- `$x=0$` 首次出现在索引 `$0$`。所有 `$6$` 个保留的元素（`$1, 2, 3, 4, 5, 6$`）都出现在此索引之后。\n- `$W_{\\text{in}} = 6$。\n- 结果: `[$6$, $6$]`\n\n**案例 E:** `$E = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0\\}$, $x = 0$。\n- `$n = 12$, $m = 3$, 所以 $k = n - m = 9$.\n- `$W_{\\text{out}} = k = 9$。\n- `$x=0$` 首次出现在索引 `$9$`。在此索引或之后没有保留的元素。\n- `$W_{\\text{in}} = 0$。\n- 结果: `[$0$, $9$]`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_inplace_writes(arr: np.ndarray, x: int) - int:\n    \"\"\"\n    Calculates the number of writes for the in-place stable compaction algorithm.\n\n    A write is counted if a kept element is moved to a new position,\n    i.e., its source index `i` is not equal to its destination index `j`.\n    This happens for every kept element that appears after the first\n    occurrence of the value `x`.\n    \"\"\"\n    writes = 0\n    write_idx = 0\n    for read_idx in range(len(arr)):\n        if arr[read_idx] != x:\n            if read_idx != write_idx:\n                writes += 1\n            write_idx += 1\n    return writes\n\ndef calculate_outofplace_writes(arr: np.ndarray, x: int) - int:\n    \"\"\"\n    Calculates the number of writes for the out-of-place stable filter.\n\n    A write is counted for each element appended to the new array.\n    This is equal to the number of elements that are not equal to `x`.\n    \"\"\"\n    # Number of elements to keep is n - m, where m is count of x.\n    n = len(arr)\n    m = np.count_nonzero(arr == x)\n    k = n - m\n    return k\n\ndef solve():\n    \"\"\"\n    Executes the analysis for all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        (np.array([1, 2, 0, 3, 4, 0, 5, 0, 6, 7]), 0),  # Case A\n        (np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), 0), # Case B\n        (np.array([0, 0, 0, 0, 0, 0, 0, 0]), 0),       # Case C\n        (np.array([0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6]), 0), # Case D\n        (np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0]), 0)  # Case E\n    ]\n\n    results = []\n    for arr, x in test_cases:\n        w_in = calculate_inplace_writes(arr, x)\n        w_out = calculate_outofplace_writes(arr, x)\n        results.append(f\"[{w_in},{w_out}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3241063"}, {"introduction": "接下来，我们处理常见的列表去重问题，它展现了一组更丰富的权衡。这个练习要求你比较使用辅助集合的直观非原地方法与一个涉及排序的原地策略。分析这两种方法将揭示空间复杂度、时间复杂度以及保留元素顺序之间的经典相互作用 [@problem_id:3241056]。", "problem": "要求您形式化并量化一种使用辅助集合的非原地列表去重算法与另一种先排序后使用双指针扫描的原地算法之间的权衡。工作模型设定为：整数列表存储在随机存取存储器中，并且可以对整数应用全序关系和相等关系。\n\n我们从核心定义开始：\n- 如果一个算法除了输入数据外，最多只使用常数个与元素大小相同的额外内存位置（该数量独立于输入大小），则称其为原地算法。如果一个算法的额外内存使用量随输入大小增长，则称其为非原地算法。\n- 去重算法是一个转换列表的过程，使得结果中每个不同的值仅出现一次。\n\n您的任务是针对相同的输入，实现并分析两种去重策略：\n\n1. 非原地策略。该策略从左到右迭代，使用一个辅助集合来跟踪已出现过的值，并将每个首次出现的值写入一个新列表。这保留了首次出现的顺序。\n\n2. 原地策略。该策略首先使用一种原地比较排序算法对数组进行排序，该排序仅依赖于整数的全序关系，并且最多使用常数个与元素大小相同的额外内存位置。然后，它执行一次线性的双指针扫描，以原地方式紧凑化已排序的数组，使得每个不同的值在数组的前部段中仅出现一次。\n\n您必须根据原始操作和内存模型的精确定义，量化以下内容：\n\n- 比较：对两个最初来自输入列表的元素调用整数全序或相等关系的任何行为。每次此类使用计为一次比较。对于使用哈希集合的非原地策略，不将哈希或哈希表探测计为比较；在此定义下，其比较次数为零。\n\n- 写入：将输入元素的值赋给原始列表或算法新分配的辅助列表中某个位置的任何操作。交换两个元素计为两次写入，因为它对两个位置进行了赋值。将一个值追加到新分配的列表计为一次写入。\n\n- 额外空间：在算法执行期间，在输入数组之外分配的元素大小的内存槽的最大数量，以元素为单位进行度量，并忽略常数因子（如固定数量的标量变量）。对于非原地算法，模型化为辅助集合为每个不同的输入值存储一个元素槽，生成的唯一值列表也为每个不同的输入值存储一个元素槽，总计为 $2u$，其中 $u$ 是输入中不同元素的数量。对于原地算法，将额外空间视为 $0$，因为排序是原地的，且双指针扫描仅使用常数个索引变量。\n\n正确性要求：\n- 设 $n$ 为输入大小，$u$ 为输入中不同值的数量。非原地算法必须返回一个长度为 $u$ 的列表，并保留首次出现的顺序。原地算法必须转换输入，使得前 $u$ 个位置恰好包含所有不同的值，其顺序可能因排序而与原始顺序不同。为了验证，只需非原地结果中的值集合与原地结果前 $u$ 个位置中的值集合相等，并且两者长度均为 $u$ 即可。\n\n设计约束：\n- 原地排序子程序必须是真正的原地比较排序。除了常数个元素大小的临时空间外，您不得使用任何外部存储；例如，原地堆排序是可以接受的。然后，双指针扫描在线性时间内运行。\n\n要执行的测试套件：\n- 使用以下整数输入列表：\n  - 用例 A: $[3,1,2,3,2,4,5,1,3]$\n  - 用例 B: $[]$\n  - 用例 C: $[5,4,3,2,1]$\n  - 用例 D: $[7,7,7,7]$\n  - 用例 E: $[0,-1,-1,2,-3,2,0,0,-3,5]$\n  - 用例 F: $[1,1,2,2,3,3,3,4]$\n  - 用例 G: $[9,8,8,7,6,6,6,5,5,4,3,3,2,1,1]$\n\n每个测试用例的必需输出：\n- 对于每个用例，生成一个包含八个值的列表：\n  - $L_{\\mathrm{out}}$: 非原地唯一值列表的长度（一个整数）。\n  - $L_{\\mathrm{in}}$: 排序和扫描后原地唯一值前缀的长度（一个整数）。\n  - $E$: 一个布尔值，当且仅当两个结果中的值集合相等且 $L_{\\mathrm{out}} = L_{\\mathrm{in}}$ 时为真。\n  - $S_{\\mathrm{out}}$: 非原地算法的额外空间（以元素为单位），模型化为 $2L_{\\mathrm{out}}$（一个整数）。\n  - $S_{\\mathrm{in}}$: 原地算法的额外空间（以元素为单位），模型化为 $0$（一个整数）。\n  - $W_{\\mathrm{out}}$: 非原地算法的总写入次数（一个整数）。\n  - $W_{\\mathrm{in}}$: 原地算法的总写入次数，包括排序交换和原地紧凑化写入（一个整数）。\n  - $C_{\\mathrm{in}}$: 原地算法的总比较次数，包括排序比较和扫描中的相等检查（一个整数）。对于非原地算法，根据所述模型，其比较次数视为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应于测试用例 A 到 G 的八值列表。例如，最外层结构必须类似于 $[[\\dots],[\\dots],\\dots]$，程序不应插入任何空格。内部值必须是指定的布尔值和整数。不应打印任何其他文本。", "solution": "我们从基本原理出发，将正确性和资源使用建立在原地算法、非原地算法、全序关系和元素大小内存槽的核心定义之上。\n\n使用辅助集合的非原地去重算法的正确性源于集合的基本属性：集合不包含重复项，并支持插入测试。从左到右遍历长度为 $n$ 的输入，并维护一个已见值的集合，可以确保每个不同的值只在其首次遇到时被追加一次。因此，输出长度等于不同输入值的数量 $u$，并且输出保留了首次出现的顺序。在我们的操作模型下，我们将哈希和哈希表探测视为“比较”之外的操作，因为它们不涉及对两个输入元素调用整数全序或相等关系；因此，非原地算法的比较计数为 $0$。每次我们追加一个新的唯一项时，都会对辅助列表执行一次写入，所以 $W_{\\mathrm{out}} = u$。根据指定的额外空间模型，集合为每个不同元素存储一个槽，唯一值列表也为每个不同元素存储一个槽，因此额外空间为 $S_{\\mathrm{out}} = 2u$ 个元素槽。\n\n对于原地策略，我们依赖于两个组成部分。\n\n首先，像堆排序这样的原地比较排序算法只使用输入数组和常数个临时变量。堆排序会原地构建一个二叉堆，然后重复地将第一个元素交换到其最终位置并恢复堆属性。该算法调用输入元素的全序关系来进行堆比较，并使用交换操作，每次交换会写入两个数组位置。这满足了原地的定义，因为没有分配与 $n$ 成比例的额外数组，所以额外空间 $S_{\\mathrm{in}} = 0$。其时间开销是超线性的，但我们这里的重点是量化具体的操作计数 $C_{\\mathrm{in}}$（两个输入元素之间的比较次数）和 $W_{\\mathrm{in}}$（将输入元素写入数组位置的次数），我们的实现会为提供的输入精确地统计这些数值。从数组构建堆以及后续的下沉操作是一系列的成对比较和交换；每次交换写入两个数组槽，每次堆顺序检查使用两个输入元素的全序比较，这都会计入 $C_{\\mathrm{in}}$。\n\n其次，排序后，一次双指针扫描将相等的连续段紧凑化为一个唯一值前缀。因为数组已排序，所有重复项都位于连续的区域中。我们维护一个指向最后一个唯一值位置的写入索引和一个向前扫描的读取索引。对于每个不等于最后一个已写入唯一值的新值，我们推进写入索引并将当前读取的元素赋给新的写入位置。每一步都精确使用一次两个输入元素之间的相等比较。这使得前 $u$ 个位置恰好包含每个不同值的一个副本，并且不保留任何特定的原始顺序，这在这里是可以接受的。扫描过程本身对 $C_{\\mathrm{in}}$ 和 $W_{\\mathrm{in}}$ 有贡献，但只使用常数个标量，因此在我们的模型下不贡献额外的元素大小的空间。\n\n结果的等价性建立如下。非原地方法精确地产生输入中存在的不同值的集合。原地方法排序后，在数组前缀为每个相等的连续段写入一个代表，这也精确地产生了相同的不同值集合。设 $L_{\\mathrm{out}}$ 表示非原地方法返回的长度，$L_{\\mathrm{in}}$ 表示原地方法返回的前缀长度。根据上述推理，两者都等于 $u$。因此，当且仅当这些长度匹配且它们的值集合相等时，$E$ 为真。我们的程序通过比较集合和长度来检查此条件。\n\n权衡直接源于这些定义。在一个典型的哈希表模型中，非原地方法使用期望为 $n$ 的线性时间，并使用 $S_{\\mathrm{out}} = 2u$ 个额外元素槽，其写入次数等于 $u$。原地方法使用 $S_{\\mathrm{in}} = 0$ 个额外元素槽，但代价是超线性的排序工作，产生了反映堆维护和紧凑化过程的具体计数 $C_{\\mathrm{in}}$ 和 $W_{\\mathrm{in}}$。双指针扫描本身是线性的，每个扫描位置有一次比较，并且在新运行段开始时最多有 $u-1$ 次紧凑化写入。\n\n为确保可衡量和可测试的结果，程序实例化了指定的测试套件，并为每个用例报告一个元组 $[L_{\\mathrm{out}}, L_{\\mathrm{in}}, E, S_{\\mathrm{out}}, S_{\\mathrm{in}}, W_{\\mathrm{out}}, W_{\\mathrm{in}}, C_{\\mathrm{in}}]$，形式为布尔值和整数的列表，并按要求聚合到单行打印的外部列表中。此输出允许直接观察核心权衡：通过支付因排序而产生的额外比较和写入，将额外空间从 $2u$ 减少到 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Allowed library; not strictly needed but permitted.\n\nfrom typing import List, Tuple\n\nclass Counters:\n    def __init__(self):\n        self.comparisons = 0  # Count of element-to-element comparisons (order or equality)\n        self.writes = 0       # Count of element writes (assignments into array slots)\n\ndef heapsort_in_place(arr: List[int], ctr: Counters) - None:\n    \"\"\"\n    In-place heapsort on arr, updating counters:\n    - comparisons: number of element-to-element comparisons\n    - writes: number of element assignments into array slots\n    Each swap counts as two writes.\n    \"\"\"\n    n = len(arr)\n\n    def sift_down(start: int, end: int):\n        i = start\n        while True:\n            left = 2 * i + 1\n            right = left + 1\n            largest = i\n            if left  end:\n                ctr.comparisons += 1\n                if arr[left]  arr[largest]:\n                    largest = left\n            if right  end:\n                ctr.comparisons += 1\n                if arr[right]  arr[largest]:\n                    largest = right\n            if largest != i:\n                # swap arr[i] and arr[largest]\n                arr[i], arr[largest] = arr[largest], arr[i]\n                ctr.writes += 2\n                i = largest\n            else:\n                break\n\n    # Build max heap\n    # Start from the last parent node and sift down\n    for i in range(n // 2 - 1, -1, -1):\n        sift_down(i, n)\n\n    # Extract elements from heap one by one\n    for end in range(n - 1, 0, -1):\n        # Move current max to the end (swap root with end)\n        arr[0], arr[end] = arr[end], arr[0]\n        ctr.writes += 2\n        sift_down(0, end)\n\ndef dedup_out_of_place_preserve_order(arr: List[int]) - Tuple[List[int], int]:\n    \"\"\"\n    Out-of-place deduplication using an auxiliary set to preserve first occurrence order.\n    Returns (unique_list, writes), where writes is the number of appends performed.\n    By problem's comparison model, comparisons are treated as 0 for this algorithm.\n    \"\"\"\n    seen = set()\n    unique = []\n    writes = 0\n    for x in arr:\n        if x not in seen:\n            seen.add(x)\n            unique.append(x)\n            writes += 1\n    return unique, writes\n\ndef dedup_sorted_two_pointer_in_place(arr: List[int], ctr: Counters) - int:\n    \"\"\"\n    Given arr already sorted in-place, perform two-pointer sweep to compact unique values\n    into the prefix of the array. Updates counters:\n    - comparisons: equality checks between adjacent run endpoints\n    - writes: assignments when moving a newly found unique to the next write position\n    Returns the length of the unique prefix.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    write_idx = 0\n    for read_idx in range(1, n):\n        ctr.comparisons += 1  # equality check\n        if arr[read_idx] != arr[write_idx]:\n            write_idx += 1\n            if write_idx != read_idx:\n                arr[write_idx] = arr[read_idx]\n                ctr.writes += 1\n    return write_idx + 1\n\ndef analyze_case(arr: List[int]) - List:\n    # Out-of-place analysis\n    out_unique, out_writes = dedup_out_of_place_preserve_order(arr)\n    L_out = len(out_unique)\n    S_out = 2 * L_out  # per model: set + unique list, one slot each per distinct element\n\n    # In-place analysis (we operate on a copy to avoid mutating the original test case)\n    in_arr = list(arr)\n    in_ctr = Counters()\n    heapsort_in_place(in_arr, in_ctr)\n    L_in = dedup_sorted_two_pointer_in_place(in_arr, in_ctr)\n    # In-place extra space per model: 0\n    S_in = 0\n\n    # Equivalence: same length and same set of distinct values\n    unique_in_place_set = set(in_arr[:L_in])\n    out_unique_set = set(out_unique)\n    equivalent = (L_out == L_in) and (unique_in_place_set == out_unique_set)\n\n    result = [\n        L_out,\n        L_in,\n        equivalent,\n        S_out,\n        S_in,\n        out_writes,\n        in_ctr.writes,\n        in_ctr.comparisons,\n    ]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [3,1,2,3,2,4,5,1,3],                   # Case A\n        [],                                     # Case B\n        [5,4,3,2,1],                            # Case C\n        [7,7,7,7],                              # Case D\n        [0,-1,-1,2,-3,2,0,0,-3,5],              # Case E\n        [1,1,2,2,3,3,3,4],                      # Case F\n        [9,8,8,7,6,6,6,5,5,4,3,3,2,1,1],        # Case G\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    # Convert booleans to lowercase 'true'/'false' or keep Python's True/False?\n    # The problem statement allows booleans; Python prints True/False without quotes.\n    # We must ensure no spaces: we'll build the string manually.\n    def format_value(v):\n        if isinstance(v, bool):\n            return \"True\" if v else \"False\"\n        else:\n            return str(v)\n\n    def format_list(lst):\n        return \"[\" + \",\".join(format_value(x) for x in lst) + \"]\"\n\n    output = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(output)\n\nsolve()\n```", "id": "3241056"}, {"introduction": "作为实践的结尾，我们从数组拓展到链式数据结构领域。这个高级问题要求你仅通过重用现有节点指针，将一个二叉搜索树转换为一个有序的双向链表，这是对原地操作能力的真正考验。为了满足严格的 $O(1)$ 额外空间限制，成功解决此问题需要一种优雅的非递归遍历方法，从而深化你设计复杂原地算法的专业知识 [@problem_id:3241084]。", "problem": "你必须编写一个完整的程序，针对一个固定的二叉搜索树测试套件，将每棵树转换为一个有序的双向链表。此过程只能重用树节点的指针（不分配新节点），并报告可量化的检查结果。目标是展示一种原地算法，并通过可验证的标准将其与非原地方法区分开来。\n\n定义和基本原理：\n- 二叉搜索树（BST）是一种二叉树，它满足对于每个键为 $x$ 的节点，其左子树中所有节点的键都严格小于 $x$，其右子树中所有节点的键都严格大于 $x$。\n- 双向链表（DLL）是一种链式结构，其中每个节点都有一个指向其前驱和一个指向其后继的指针。在此任务中，最终链表中节点的左指针将用作前驱指针，右指针将用作后继指针。\n- 如果一个算法在转换数据结构时，除了常数个指针变量外，仅使用 $O(1)$ 的额外空间，并且不分配新节点，则该算法是原地的。非原地转换会分配新节点来构建目标结构，因此不会重用原始节点。\n\n你必须从第一性原理出发推导：\n- 利用 BST 的性质以及一个经过充分检验的事实：对 BST 进行中序遍历会以非递减的键顺序（由于键是唯一的，这里是严格递增）访问节点。将此与原地算法的逻辑约束相结合，即重用现有节点指针来形成 DLL，而不分配新节点。\n- 设计一个算法，该算法按排序顺序访问节点，并在访问期间重排指针，使访问过的节点成为该排序顺序下 DLL 的一部分。该算法必须遵守 $O(1)$ 的辅助空间使用率（不包括输入本身），并且不得分配任何新的链表节点。\n- 提供论证，说明生成的 DLL 是正确的（从头到尾排序）、双向一致的（每个后继节点的前驱是当前节点，反之亦然），并且是原地的（转换前后的节点身份集合相同）。\n\n程序要求：\n1. 用整数键表示树节点。通过将给定序列的键按标准 BST 插入规则（如上所述的严格不等式）插入到初始为空的 BST 中来构建每棵 BST，因此树的形状由插入顺序决定。所有键都是唯一的。\n2. 通过重排节点现有的左、右指针，使其分别作为前驱和后继指针，将每棵 BST 原地转换为 DLL。\n3. 对于每个测试用例，计算：\n   - 从头到尾遍历生成的 DLL 所获得的键列表。\n   - 一个布尔值，用于断言双向完整性：从尾到头的反向遍历产生的结果恰好是正向序列的逆序，头节点的前驱指针为空，尾节点的后继指针为空。\n   - 一个布尔值，用于断言原地性：如果 $S_{\\text{before}}$ 是转换前树中可达节点身份（内存身份）的集合，而 $S_{\\text{after}}$ 是转换后通过 DLL（从头到尾）可达节点身份的集合，则 $S_{\\text{before}} = S_{\\text{after}}$。\n4. 转换过程中不得分配新节点；只允许重排指针。允许使用辅助变量，但总辅助空间必须保持为 $O(1)$。\n\n测试套件：\n- 用例 $1$：由插入序列 $\\langle \\rangle$ 构建的空树。\n- 用例 $2$：由 $\\langle 7 \\rangle$ 构建的单节点树。\n- 用例 $3$：平衡形状的插入顺序 $\\langle 4,2,6,1,3,5,7 \\rangle$。\n- 用例 $4$：右偏斜的插入顺序 $\\langle 1,2,3,4,5 \\rangle$。\n- 用例 $5$：左偏斜的插入顺序 $\\langle 5,4,3,2,1 \\rangle$。\n- 用例 $6$：混合插入顺序 $\\langle 10,5,1,7,40,30,50 \\rangle$。\n\n输出格式：\n- 你的程序应生成单行输出，包含一个结果列表，每个测试用例一个结果，格式如下。对于每个用例，输出一个三元组，包括：\n  1. 正向 DLL 键，作为整数列表。\n  2. 如上定义的双向完整性布尔值。\n  3. 如上定义的原地性布尔值。\n- 具体来说，你的程序必须打印单行：\n  \"[[forward1,bidir1,inplace1],[forward2,bidir2,inplace2],...,[forward6,bidir6,inplace6]]\"\n其中 $forwardi$ 是用例 $i$ 的整数列表，$bidiri$ 和 $inplacei$ 是布尔值。\n\n约束和说明：\n- 设 $n$ 为节点数。目标原地转换算法的运行时间必须为 $O(n)$，辅助空间为 $O(1)$。不要为 DLL 分配任何新节点；重用原始节点及其指针。\n- 测试套件涵盖了空结构、平凡的单例、平衡树、偏斜树和混合形状树，用于探查正确性和原地属性。\n\n你的程序必须是自包含的，不需要任何输入，并严格按照指定格式打印一行输出。", "solution": "该问题要求将二叉搜索树（BST）原地转换为一个有序的双向链表（DLL）。此问题的有效性已得到确认，因为它具有科学依据、问题明确、目标客观，并且其所有组成部分都经过了形式化定义且相互一致。核心挑战在于满足原地约束，该约束被严格定义为使用 $O(1)$ 的辅助空间。这个约束使得朴素的递归解法无效，因为递归会消耗调用栈上 $O(h)$ 的空间，其中 $h$ 是树的高度。对于一个偏斜树，这会变成 $O(n)$（其中 $n$ 是节点数），从而违反了所述约束。\n\n### $O(1)$ 空间算法的原理性设计\n\nBST 的一个基本性质是中序遍历会按键值的非递减顺序访问其节点。由于问题指定了唯一的键，因此顺序是严格递增的。我们的目标是将树转换为能反映此排序顺序的 DLL。因此，算法必须执行中序遍历，并在遍历过程中，重排树节点的 `left` 和 `right` 指针，使其在 DLL 中作为 `predecessor` 和 `successor` 指针。\n\n为了实现具有 $O(1)$ 辅助空间的中序遍历，我们必须避免使用显式栈和递归。实现这一目标的经典算法是 **Morris 中序遍历**。该算法利用树自身的指针创建临时的“线索”，从而允许遍历在没有栈的情况下导航回树的上层。我们将调整这种遍历机制来执行 DLL 转换所需的指针重排。\n\n该算法维护一个指向当前正在处理的节点的指针，我们称之为 `$current$`，它被初始化为树的 `$root$`。它还使用一个指针 `$prev$` 来跟踪添加到 DLL 的最后一个节点，该节点代表正在构建的链表的尾部。最终链表的头部在访问第一个节点时由一个 `$head$` 指针捕获。\n\n遍历过程如下：\n\n1.  初始化 `$head = \\text{None}$`，`$prev = \\text{None}`，以及 `$current = root$`。\n\n2.  循环直到 `$current$` 为 `None`：\n    a.  **如果 `$current$` 没有左子节点：** 这意味着 `$current$` 是中序序列中的下一个节点。我们“访问”它。\n        i.  如果 `$prev$` 存在，我们建立双向连接：`$prev.right = current$` 和 `$current.left = prev$`。\n        ii. 如果 `$prev$` 为 `None`，这意味着 `$current$` 是遍历中的第一个节点（最小的元素），所以我们设置 `$head = current$`。\n        iii. 我们更新 `$prev = current$`，将其标记为我们链表的新尾部。\n        iv. 我们移动到中序序列中的下一个节点，即 `$current$` 的原始右子节点：`$current = current.right$`。\n\n    b.  **如果 `$current$` 有左子节点：** 我们还不能访问 `$current$`。我们必须首先遍历其整个左子树。为了在处理完左子树后返回到 `$current$`，我们建立一个临时线索。\n        i.  找到 `$current$` 的中序前驱。这是其左子树中最右边的节点。我们称之为 `$predecessor$`。我们通过从 `$current.left$` 开始，并重复向右子节点移动，直到不能再移动为止来找到它。\n        ii. **如果线索不存在**（即 `$predecessor.right$` 为 `None`）：\n            - 我们创建线索：`$predecessor.right = current$`。\n            - 然后我们继续遍历左子树：`$current = current.left$`。\n        iii. **如果线索已经存在**（即 `$predecessor.right == current$`）：这表示我们已经完成了左子树的遍历，并通过线索返回到了 `$current$`。\n            - 首先，我们必须移除临时线索，以恢复前驱节点右指针在被重用之前的完整性。由于前驱是子树的最右节点，其原始右子节点总是 `None`，所以我们设置 `$predecessor.right = \\text{None}`。\n            - 现在，我们可以“访问” `$current$`。此时，DLL 的尾部节点 `$prev$` 正是我们刚刚来自的 `$predecessor$`。我们将它们连接起来：`$prev.right = current$` 和 `$current.left = prev$`。\n            - 我们更新 `$prev = current$`。\n            - 最后，我们继续遍历 `$current$` 的原始右子树：`$current = current.right$`。\n\n这个过程持续进行，直到所有节点都被访问并连接起来。`$head$` 指针将指向排序后 DLL 的开头。\n\n### 属性验证\n\n-   **正确性（排序顺序）：** 该算法是 Morris 中序遍历的直接改编，而已证明 Morris 中序遍历会按排序顺序访问节点。由于我们是按访问顺序连接节点，因此生成的 DLL 保证按键排序。\n\n-   **双向完整性：** 对于每个被访问的节点 `$current$`，它都会与 `$prev$` 节点连接，`$prev$` 是排序序列中紧邻的前一个节点。链接 `$prev.right = current$` 和 `$current.left = prev$` 是显式设置的，确保了双向一致性。列表的头部（当第一个节点被访问时，$prev$ 还是 `None`，它的 `left` 不会被设置）没有前驱，因此其 `left` 指针保持为 `None`。列表的尾部（最后的 `$prev$`）没有后继，其 `right` 指针在其处理步骤后保持为 `None`。\n\n-   **原地性（$O(1)$ 空间）：** 该算法使用固定数量的辅助指针变量（`$head$`, `$prev$`, `$current$`, `$predecessor$`）。它不使用递归栈或任何其他大小取决于输入树大小或形状的数据结构。所有的指针操作都重用了原始树节点的现有 `$left$` 和 `$right$` 字段。没有分配新节点。因此，该算法严格遵守 $O(1)$ 辅助空间复杂度的要求。\n\n-   **时间复杂度（$O(n)$）：** 虽然寻找前驱的内部循环看似增加了复杂性，但对 Morris 遍历的仔细分析表明，树中的每条边被遍历的次数是常数次（每个方向最多两次）。因此，总时间复杂度是线性的，$O(n)$，这是最优的，因为每个节点都必须被访问。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Main solver function that defines the test suite, runs the conversion and validation,\n    and prints the formatted output.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        Represents a node in the Binary Search Tree.\n        The left and right pointers will be reused for the Doubly Linked List.\n        \"\"\"\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n\n        def __repr__(self):\n            # For debugging purposes\n            return f\"Node({self.key})\"\n\n    def build_bst(keys):\n        \"\"\"Builds a BST from a sequence of keys using standard insertion.\"\"\"\n        def insert(root, key):\n            if not root:\n                return Node(key)\n            if key  root.key:\n                root.left = insert(root.left, key)\n            else:  # key  root.key, as keys are distinct\n                root.right = insert(root.right, key)\n            return root\n\n        root = None\n        for key in keys:\n            root = insert(root, key)\n        return root\n\n    def get_node_identities(root):\n        \"\"\"Returns the set of memory addresses of all nodes in the tree.\"\"\"\n        if not root:\n            return set()\n        \n        identities = set()\n        queue = [root]\n        visited = {root}\n        \n        while queue:\n            node = queue.pop(0)\n            identities.add(id(node))\n            if node.left and node.left not in visited:\n                visited.add(node.left)\n                queue.append(node.left)\n            if node.right and node.right not in visited:\n                visited.add(node.right)\n                queue.append(node.right)\n        return identities\n\n    def bst_to_dll_inplace(root):\n        \"\"\"\n        Converts a BST to a sorted DLL in-place using an O(1) space algorithm\n        based on Morris In-order Traversal.\n        Returns the head of the DLL.\n        \"\"\"\n        head = None\n        prev = None\n        current = root\n\n        while current:\n            if not current.left:\n                # Visit current node\n                if not head:\n                    head = current\n                if prev:\n                    prev.right = current\n                    current.left = prev\n                prev = current\n                \n                # Move to the next node in the in-order traversal\n                current = current.right\n            else:\n                # Find in-order predecessor\n                predecessor = current.left\n                while predecessor.right and predecessor.right != current:\n                    predecessor = predecessor.right\n\n                if not predecessor.right:\n                    # Create temporary thread\n                    predecessor.right = current\n                    current = current.left\n                else: # predecessor.right == current (thread exists)\n                    # Break the thread\n                    predecessor.right = None\n                    \n                    # Visit current node (it comes after its predecessor)\n                    if prev: # prev is the predecessor\n                        prev.right = current\n                        current.left = prev\n                    \n                    prev = current\n                    \n                    # Move to the original right subtree\n                    current = current.right\n        return head\n\n    def run_test_case(insertion_sequence):\n        \"\"\"\n        Runs one full test case: builds BST, gets identities, converts, and verifies.\n        \"\"\"\n        # 1. Build BST and get pre-conversion state\n        root = build_bst(insertion_sequence)\n        s_before = get_node_identities(root)\n\n        # 2. Perform in-place conversion\n        head = bst_to_dll_inplace(root)\n\n        # 3. Perform verification checks on the resulting DLL\n        \n        # 3a. In-placeness check\n        s_after = set()\n        curr = head\n        while curr:\n            s_after.add(id(curr))\n            curr = curr.right\n        is_inplace = (s_before == s_after)\n        \n        # 3b. Forward traversal and find tail\n        forward_keys = []\n        tail = None\n        curr = head\n        while curr:\n            forward_keys.append(curr.key)\n            if not curr.right:\n                tail = curr\n            curr = curr.right\n            \n        # 3c. Bidirectional integrity check\n        is_bidir_correct = True\n        \n        # Check null termination\n        if (head and head.left is not None) or (tail and tail.right is not None):\n            is_bidir_correct = False\n        \n        # Check reverse traversal\n        if is_bidir_correct:\n            backward_keys = []\n            curr = tail\n            while curr:\n                backward_keys.append(curr.key)\n                curr = curr.left\n            \n            # For empty list, backward_keys[::-1] is still []\n            if forward_keys != backward_keys[::-1]:\n                is_bidir_correct = False\n        \n        return [forward_keys, is_bidir_correct, is_inplace]\n\n    # Fixed test suite as per the problem statement\n    test_cases = [\n        [],                            # Case 1: empty tree\n        [7],                           # Case 2: single-node tree\n        [4, 2, 6, 1, 3, 5, 7],         # Case 3: balanced-shape\n        [1, 2, 3, 4, 5],               # Case 4: right-skewed\n        [5, 4, 3, 2, 1],               # Case 5: left-skewed\n        [10, 5, 1, 7, 40, 30, 50],     # Case 6: mixed\n    ]\n\n    results = []\n    for case_keys in test_cases:\n        results.append(run_test_case(case_keys))\n\n    # Format the final output string manually to match the exact requirement\n    # \"[[forward1,bidir1,inplace1],[forward2,bidir2,inplace2],...]\"\n    # This avoids ambiguity with spaces from standard str() or repr()\n    result_strings = []\n    for fwd_keys, bidir, inplace in results:\n        fwd_str = '[' + ','.join(map(str, fwd_keys)) + ']'\n        result_strings.append(f\"[{fwd_str},{str(bidir)},{str(inplace)}]\")\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3241084"}]}