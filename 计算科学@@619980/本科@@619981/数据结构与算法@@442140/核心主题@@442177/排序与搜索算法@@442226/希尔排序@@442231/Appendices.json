{"hands_on_practices": [{"introduction": "希尔排序的效率在很大程度上取决于其所使用的间隔序列。这个练习将理论付诸实践，要求你亲手实现希尔排序，并为其植入性能监测的“探针”，以量化比较两种经典的间隔序列——Ciura 序列和 Donald Knuth 序列——在处理逆序数组时的表现。通过计算和比较元素比较与数据移动的次数，你将直观地感受到不同间隔序列设计对算法性能的实际影响，从而加深对希尔排序核心机制的理解。[@problem_id:3270119]", "problem": "您需要实现一个完整的程序，使用两种不同的间隔序列来测量希尔排序在逆序排序数组上的操作计数。目标是比较 Ciura 间隔序列和 Donald Knuth 间隔序列的元素比较次数与数据移动次数，并汇总多种数组大小下的结果。\n\n从数据结构与算法中的以下基本原理开始：希尔排序是插入排序的一种泛化，它通过使用一个间隔序列先对相距较远的元素进行排序，然后逐步将间隔缩减至 $1$ 来提高性能。对于任意固定的间隔 $h$，该算法对由间隔为 $h$ 的索引处的元素组成的子序列执行插入排序。插入排序的正确性依赖于其循环不变量：在将一个选定元素（“键”）插入到左侧部分之前，该部分是已排序的，并且插入操作保持有序性。这一观察可通过将插入排序应用于间隔为 $h$ 的子序列而推广至希尔排序。\n\n所使用的定义如下：\n- 一个长度为 $n$ 的逆序排序数组，当 $n \\ge 1$ 时是数组 $[n,n-1,\\dots,2,1]$，当 $n=0$ 时是空数组。\n- 一次键比较被计数，是指每当对两个数组元素进行比较求值时，特别是在 $h$-插入过程中计算谓词 $A[j-h] > \\text{temp}$ 时。只计算元素与元素之间的比较；诸如 $j \\ge h$ 的索引边界检查不被计数。\n- 一次数据移动被计为对数组索引的一次写入。这包括每次插入时的每次移位 $A[j] \\leftarrow A[j-h]$ 和最终放置 $A[j] \\leftarrow \\text{temp}$。即使没有发生移位且元素被写回其原始位置，该次写入也被计为一次数据移动。\n- Ciura 间隔序列由基础列表 $\\{1,4,10,23,57,132,301,701\\}$ 定义，并对于更大的 $n$ 通过 $h_{\\text{next}}=\\left\\lfloor 2.25 \\cdot h \\right\\rfloor$ 乘法扩展，直到超过 $n$，然后按降序使用所有 $h \\le n$ 的间隔。\n- Donald Knuth 间隔序列由 $h_0=1$ 和 $h_{k+1}=3h_k+1$ 定义，枚举直到超过 $n$，并按降序使用所有 $h \\le n$ 的间隔。\n\n实现带有监测功能的希尔排序，该功能用于按上述定义计数比较次数和数据移动次数。将其应用于以下大小的逆序排序数组：\n- $n \\in \\{0,1,8,23,100,1000\\}$。\n\n对于每个数组大小 $n$，计算以下七个整数：\n- $n$，\n- $C_{\\text{Ciura}}$，使用 Ciura 序列的比较次数，\n- $M_{\\text{Ciura}}$，使用 Ciura 序列的数据移动次数，\n- $C_{\\text{Knuth}}$，使用 Knuth 序列的比较次数，\n- $M_{\\text{Knuth}}$，使用 Knuth 序列的数据移动次数，\n- $\\Delta C = C_{\\text{Ciura}} - C_{\\text{Knuth}}$，\n- $\\Delta M = M_{\\text{Ciura}} - M_{\\text{Knuth}}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。此顶层列表中的每个条目对应一个测试用例，并且其本身必须是按上述确切顺序排列的七个整数的列表。例如，输出格式为\n$[[n_1,C_{\\text{Ciura},1},M_{\\text{Ciura},1},C_{\\text{Knuth},1},M_{\\text{Knuth},1},\\Delta C_1,\\Delta M_1],\\dots,[n_k,C_{\\text{Ciura},k},M_{\\text{Ciura},k},C_{\\text{Knuth},k},M_{\\text{Knuth},k},\\Delta C_k,\\Delta M_k]]$，\n整行中不含任何空格。", "solution": "经评估，用户提供的问题是有效的。这是一个在算法分析领域内定义明确、有科学依据且客观的任务。其定义、约束和目标清晰且充分，足以产生一个唯一的、可计算的解决方案。\n\n该问题要求实现注入了计数键比较和数据移动逻辑的希尔排序算法。然后将此实现应用于指定大小的逆序排序数组，并使用两种不同的间隔序列：一种由 Ciura 提出，另一种由 Donald Knuth 提出。然后对结果进行汇总和格式化。\n\n解决方案的结构如下：\n$1$. 实现带有监测功能的希尔排序算法。\n$2$. 实现指定间隔序列的生成逻辑。\n$3$. 对每个测试用例执行算法并整理结果。\n\n**$1$. 带有监测功能的希尔排序算法**\n\n希尔排序算法通过执行一系列带有间隔的插入排序来对大小为 $n$ 的数组 $A$ 进行排序。对于一个按降序使用的给定间隔序列 $h_k, h_{k-1}, \\dots, h_1=1$，该算法会遍历每个间隔 $h$。对于每个 $h$，它实际上对 $h$ 个独立的子序列执行插入排序。这些子序列的元素位于索引 $(i, i+h, i+2h, \\dots)$ 处，其中起始位置 $i \\in \\{0, 1, \\dots, h-1\\}$。\n\n该算法的核心是 $h$-排序遍。对于每个 $i \\ge h$ 的元素 $A[i]$，我们将其视为一个键，插入到它之前、间隔为 $h$ 的元素组成的已排序子序列中。\n\n设 $A$ 为大小为 $n$ 的数组。设 `gaps` 为按降序排列的间隔列表。过程如下：\n对于 `gaps` 中的每个间隔 $h$：\n  对于从 $h$ 到 $n-1$ 的每个索引 $i$：\n    $1$. 存储待插入的元素：$\\text{temp} \\leftarrow A[i]$。\n    $2$. 初始化插入索引：$j \\leftarrow i$。\n    $3$. 将比 `temp` 大的元素向右移动 $h$ 个位置。当 $j \\ge h$ 且 $A[j-h] > \\text{temp}$ 时：\n       - 比较操作 $A[j-h] > \\text{temp}$ 被计数。设总比较次数为 $C$。每次该谓词被求值时，我们增加 $C$。\n       - 移位操作 $A[j] \\leftarrow A[j-h]$ 是一次数据移动。设总移动次数为 $M$。每次这样的赋值都会增加 $M$。\n       - 移动到下一个插入位置：$j \\leftarrow j - h$。\n    $4$. 循环结束后，如果发生了另一次导致循环终止的比较（即 $A[j-h] \\le \\text{temp}$），该次比较也要被计数。\n    $5$. 将 `temp` 元素放置在其正确的排序位置：$A[j] \\leftarrow \\text{temp}$。这是当前插入操作的最后一次数据移动，因此 $M$ 增加。\n\n该过程的监测方式如下：\n- **比较次数 ($C$)**：每次谓词 $A[j-h] > \\text{temp}$ 被求值时增加。\n- **数据移动次数 ($M$)**：每次对数组的写入操作都会增加，包括每次移位 $A[j] \\leftarrow A[j-h]$ 和最终放置 $A[j] \\leftarrow \\text{temp}$。\n\n为两种间隔序列分别创建一个初始逆序排序数组的副本，以确保两个排序过程都在相同的初始数据上操作。\n\n**$2$. 间隔序列的生成**\n\n指定了两种间隔序列：\n\n**Ciura 间隔序列**：\n该序列基于实验数据。基础序列是 $\\{1, 4, 10, 23, 57, 132, 301, 701\\}$。对于大小为 $n$ 的数组，该序列进行乘法扩展。生成过程是取最后一个生成的间隔 $h_k$，并计算下一个间隔为 $h_{k+1} = \\lfloor 2.25 \\cdot h_k \\rfloor$。此扩展持续进行，直到生成的间隔超过 $n$。最终使用的序列包含所有生成的不大于 $n$ 的间隔，并按降序排序。\n\n对于给定的 $n$，其过程是：\n$1$. 用基础值初始化一个间隔列表：`gaps` $\\leftarrow \\{1, 4, 10, 23, 57, 132, 301, 701\\}$。\n$2$. 设 $h$ 为 `gaps` 中的最大值。\n$3$. 当 $h \\le n$ 时，计算 $\\text{next\\_h} \\leftarrow \\lfloor 2.25 \\cdot h \\rfloor$。如果 $\\text{next\\_h} > h$，则将其附加到 `gaps` 中并更新 $h \\leftarrow \\text{next\\_h}$。否则，停止扩展。\n$4$. 筛选生成的列表，只保留 $g \\le n$ 的间隔。\n$5$. 返回按降序排序的筛选后列表。\n\n**Donald Knuth 间隔序列**：\n该序列由递推关系 $h_{k+1} = 3h_k + 1$ 定义，其中 $h_0 = 1$。序列生成到（但不包括）第一个超过数组大小 $n$ 的值为止。\n该序列为 $\\{1, 4, 13, 40, 121, 364, \\dots\\}$。\n\n对于给定的 $n$，其过程是：\n$1$. 初始化 `gaps` $\\leftarrow []$ 和 $h \\leftarrow 1$。\n$2$. 当 $h \\le n$ 时，将 $h$ 附加到 `gaps` 并更新 $h \\leftarrow 3h+1$。\n$3$. 返回按降序排序的 `gaps`。\n\n**$3$. 实验执行与输出**\n\n程序对每个数组大小 $n \\in \\{0, 1, 8, 23, 100, 1000\\}$ 执行带有监测功能的希尔排序。对于每个 $n$：\n$1$. 创建一个逆序排序数组 $A = [n, n-1, \\dots, 1]$。对于 $n=0$，$A$ 是空数组。\n$2$. 为大小 $n$ 生成 Ciura 和 Knuth 的间隔序列。\n$3$. 在 $A$ 的一个副本上运行两次带有监测功能的排序：一次使用 Ciura 间隔以获得 $C_{\\text{Ciura}}$ 和 $M_{\\text{Ciura}}$，另一次使用 Knuth 间隔以获得 $C_{\\text{Knuth}}$ 和 $M_{\\text{Knuth}}$。\n$4$. 计算差值 $\\Delta C = C_{\\text{Ciura}} - C_{\\text{Knuth}}$ 和 $\\Delta M = M_{\\text{Ciura}} - M_{\\text{Knuth}}$。\n$5$. 存储七个结果整数（$n, C_{\\text{Ciura}}, M_{\\text{Ciura}}, C_{\\text{Knuth}}, M_{\\text{Knuth}}, \\Delta C, \\Delta M$）。\n\n最后，所有结果被格式化为一个表示列表的列表的单字符串，正如问题陈述所指定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_ciura_gaps(n: int) -> list[int]:\n    \"\"\"\n    Generates Ciura's gap sequence for a given array size n.\n    The sequence is based on {1, 4, 10, 23, 57, 132, 301, 701} and is\n    extended by h_next = floor(2.25 * h) until exceeding n.\n    Gaps used are = n, in descending order.\n    \"\"\"\n    if n == 0:\n        return []\n        \n    gaps = [1, 4, 10, 23, 57, 132, 301, 701]\n    \n    # Extend the sequence if n is larger than the largest base gap\n    if n > gaps[-1]:\n        h = gaps[-1]\n        while True:\n            # According to the rule \"extended ... until exceeding n\", a gap > n stops generation.\n            next_h = int(h * 2.25)\n            if next_h > n:\n                break\n            # Ensure progress and avoid duplicates\n            if next_h > h:\n                gaps.append(next_h)\n                h = next_h\n            else:\n                break\n    \n    # Per rule \"used in descending order with all h = n\"\n    usable_gaps = [g for g in gaps if g = n]\n    return sorted(usable_gaps, reverse=True)\n\ndef generate_knuth_gaps(n: int) -> list[int]:\n    \"\"\"\n    Generates Donald Knuth's gap sequence (3h+1) for a given array size n.\n    The sequence is enumerated until exceeding n and used in descending order.\n    \"\"\"\n    if n == 0:\n        return []\n\n    gaps = []\n    h = 1\n    while h = n:\n        gaps.append(h)\n        h = 3 * h + 1\n    return sorted(gaps, reverse=True)\n\ndef shell_sort_instrumented(arr: np.ndarray, gaps: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Performs Shell sort on a copy of the array with the given gap sequence.\n    Returns the count of key comparisons and data movements.\n    \"\"\"\n    A = arr.copy()\n    n = len(A)\n    comparisons = 0\n    movements = 0\n\n    if n  2:\n        return 0, 0\n\n    for h in gaps:\n        for i in range(h, n):\n            temp = A[i]\n            j = i\n            while j >= h:\n                comparisons += 1\n                if A[j - h] > temp:\n                    A[j] = A[j - h]\n                    movements += 1\n                    j -= h\n                else:\n                    break\n            \n            # Final placement of the temp element is always counted as one move.\n            A[j] = temp\n            movements += 1\n\n    return comparisons, movements\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and print the results in the required format.\n    \"\"\"\n    test_cases_n = [0, 1, 8, 23, 100, 1000]\n\n    all_results = []\n    \n    for n in test_cases_n:\n        if n == 0:\n            all_results.append([0, 0, 0, 0, 0, 0, 0])\n            continue\n\n        array = np.arange(n, 0, -1, dtype=int)\n\n        gaps_ciura = generate_ciura_gaps(n)\n        gaps_knuth = generate_knuth_gaps(n)\n\n        C_ciura, M_ciura = shell_sort_instrumented(array, gaps_ciura)\n        C_knuth, M_knuth = shell_sort_instrumented(array, gaps_knuth)\n\n        delta_C = C_ciura - C_knuth\n        delta_M = M_ciura - M_knuth\n\n        result_case = [n, C_ciura, M_ciura, C_knuth, M_knuth, delta_C, delta_M]\n        all_results.append(result_case)\n\n    string_cases = [f\"[{','.join(map(str, case))}]\" for case in all_results]\n    final_output = f\"[{','.join(string_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3270119"}, {"introduction": "在掌握了基于固定间隔序列的希尔排序后，一个自然而然的进阶问题是：我们能否让算法变得“更智能”，根据排序过程中的反馈动态调整其行为？本练习旨在探索这一思想，要求你设计并实现一种自适应希尔排序。在这里，下一个间隔大小不再是预设的，而是根据当前一轮排序中元素的交换次数动态决定。这个挑战将促使你从算法的使用者转变为设计者，深入思考排序“无序度”与算法步进策略之间的关系。[@problem_id:3270048]", "problem": "给定一个整数输入列表，设计并实现一个源自希尔排序（Shell Sort）的、基于比较的排序算法，该算法根据每趟排序中测量的工作量来调整其增量序列。只能使用公认的原则作为基础：基于比较的排序的定义、插入排序的定义和不变量，以及希尔排序的定义，即以递减的增量对交错子序列进行一系列插入排序。在下述指定规则下，该算法必须是完全确定性的。\n\n基础原理：\n- 基于比较的排序算法通过执行成对比较和重新排列来确定顺序。特别地，增量为 $g$ 的插入排序维持一个不变量：在处理完索引 $i$ 后，所有满足 $k \\le i$ 且 $k$ 与 $i \\mod g$ 同余的位置 $k$ 在它们自身之间是有序的。\n- 希尔排序是对插入排序的推广，它使用增量 $g_0, g_1, \\ldots, g_T$（其中 $g_T = 1$）进行多趟排序，使得在最后一趟排序后，列表按升序排列。\n\n自适应增量规则说明：\n- 设 $n$ 为列表长度，定义初始增量为 $g_0 = \\lfloor n / 2 \\rfloor$。\n- 在增量为 $g_t$ 的第 $t$ 趟排序中，定义 $s_t$ 为增量插入排序在整个列表上执行的、索引为 $j$ 和 $j - g_t$ 的元素对的交换总次数。实现插入过程时，需通过重复交换相距 $g_t$ 的相邻元素来向左移动一个键，直到局部不变量成立，并将每次这样的相邻交换计为一次交换。\n- 定义每个插入位置的平均交换次数为 $$a_t = \\begin{cases} \\dfrac{s_t}{n - g_t}  \\text{if } n - g_t  0, \\\\ 0  \\text{if } n - g_t = 0. \\end{cases}$$\n- 根据以下自适应规则选择下一个增量 $g_{t+1}$：\n$$\ng_{t+1} = \\begin{cases}\n0  \\text{if } g_t = 1 \\text{ (terminate after this pass)}, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\dfrac{g_t}{4} \\right\\rfloor\\right)  \\text{if } s_t = 0, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\dfrac{g_t}{3} \\right\\rfloor\\right)  \\text{if } 0  a_t  1, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\dfrac{g_t}{2} \\right\\rfloor\\right)  \\text{if } a_t \\ge 1.\n\\end{cases}\n$$\n当所需工作量较少（交换次数少）时，此规则会更积极地减小增量；而当所需工作量较大（交换次数多）时，则会更保守地减小增量，从而确保增量单调递减至 $g=1$ 并最终终止。\n\n任务：\n- 实现上述自适应希尔排序，以升序对列表进行排序。\n- 对于每个输入列表，输出一个包含以下内容的列表：已排序的列表、所有趟数的总交换次数，以及执行的总趟数（即所使用的不同增量值的数量，包括适用情况下的增量 $g=1$ 的最后一趟）。\n- 算法不得依赖任何外部随机性，并且对于通过相邻交换实现的增量插入的指定机制，必须是稳定的。\n\n测试套件：\n使用以下列表作为输入测试用例。每个列表都是一个有序的整数列表，应完全按原样处理。\n- 案例 $1$：$[9,8,3,7,5,6,4,1,2]$。\n- 案例 $2$：$[1,2,3,4,5,6,7,8,9]$。\n- 案例 $3$：$[9,8,7,6,5,4,3,2,1]$。\n- 案例 $4$：$[5,3,5,2,5,1,5]$。\n- 案例 $5$：$[42]$。\n- 案例 $6$：$[]$。\n- 案例 $7$：$[-3,1,-2,4,0]$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个结果必须是 $[\\text{sorted\\_list}, \\text{total\\_swaps}, \\text{total\\_passes}]$ 形式的列表。例如，整个输出应在一行上显示为 $[[\\cdots], [\\cdots], \\ldots]$，不含任何额外文本。", "solution": "用户希望实现一个源自希尔排序（Shell Sort）的、基于比较的排序算法，该算法根据每趟排序中测量的工作量来调整其增量序列。只能使用公认的原则作为基础：基于比较的排序的定义、插入排序的定义和不变量，以及希尔排序的定义，即以递减的增量对交错子序列进行一系列插入排序。在下述指定规则下，该算法必须是完全确定性的。\n\n### 第1步：提取已知信息\n- **算法**：自适应希尔排序。\n- **基础**：基于比较的排序、插入排序、希尔排序。\n- **排序顺序**：升序。\n- **初始增量**：$g_0 = \\lfloor n / 2 \\rfloor$，其中 $n$ 是列表长度。\n- **工作量度量**：$s_t$ 是第 $t$ 趟排序中，相距 $g_t$ 的元素对交换（swaps）的总次数。\n- **平均交换次数**：若 $n - g_t  0$，则 $a_t = \\frac{s_t}{n - g_t}$，否则 $a_t = 0$。\n- **增量更新规则**：\n$$\ng_{t+1} = \\begin{cases}\n0  \\text{if } g_t = 1 \\text{ (termination)}, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\frac{g_t}{4} \\right\\rfloor\\right)  \\text{if } s_t = 0, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\frac{g_t}{3} \\right\\rfloor\\right)  \\text{if } 0  a_t  1, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\frac{g_t}{2} \\right\\rfloor\\right)  \\text{if } a_t \\ge 1.\n\\end{cases}\n$$\n- **输出**：对于每个输入列表，一个结果列表 `[sorted_list, total_swaps, total_passes]`。\n- **测试用例**：`[9,8,3,7,5,6,4,1,2]`、`[1,2,3,4,5,6,7,8,9]`、`[9,8,7,6,5,4,3,2,1]`、`[5,3,5,2,5,1,5]`、`[42]`、`[]`、`[-3,1,-2,4,0]`。\n\n### 第2步：使用提取的已知信息进行验证\n- **科学依据**：该问题基于计算机科学中的标准、定义明确的算法（希尔排序、插入排序）。自适应规则是一项新颖的修改，但在数学和逻辑上是合理的。该问题是有效的。\n- **良构性**：该问题是良构的。初始状态是输入列表。操作是确定性的，并且增量序列保证（对于 $g_t  1$）单调递减并最终达到 1，从而确保终止。对于任何输入都存在唯一解。\n- **客观性**：问题陈述使用了精确、无歧义的术语和形式化定义。不存在主观因素。\n\n### 第3步：结论与行动\n问题有效。将提供一个完整的解决方案。\n\n自适应希尔排序算法的设计基于基于比较的排序的基本原理。该算法推广了插入排序，插入排序通过迭代地构建列表的已排序前缀来工作。插入排序的核心不变量是，在每一步 $i$，从索引 0 到 $i$ 的子列表都是已排序的。希尔排序对此进行了改进，它首先对相距较远的元素进行排序，然后逐渐减小被比较和交换元素之间的增量。这等同于在多个交错的子列表上执行插入排序。增量为 $g$ 的一趟排序涉及对由索引为 $k, k+g, k+2g, \\ldots$（其中 $k \\in \\{0, 1, \\ldots, g-1\\}$）的元素组成的 $g$ 个子列表中的每一个独立地执行插入排序。\n\n该算法被结构化为一个主函数 `adaptive_shell_sort`，它负责协调整个排序过程；以及一个辅助函数 `gapped_insertion_sort`，它为给定的增量执行单趟排序。\n\n主函数 `adaptive_shell_sort` 将总交换次数 $s_{total}$ 和总趟数 $p_{total}$ 初始化为 0。它处理列表长度 $n$ 小于或等于 1 的平凡边界情况，此时列表已经排序，函数返回 0 次交换和 0 趟排序。对于非平凡情况，它计算初始增量 $g_0 = \\lfloor n/2 \\rfloor$。排序在一个循环中进行，只要当前增量 $g_t  0$，循环就会继续。\n\n在循环内部，执行单趟排序：\n$1$. 趟数计数器 $p_{total}$ 递增。\n$2$. 使用当前列表和增量 $g_t$ 调用辅助函数 `gapped_insertion_sort`。该函数对交错子列表进行原地排序，并返回执行的交换次数 $s_t$。\n$3$. 将该趟的交换次数 $s_t$ 加到总交换次数 $s_{total}$ 中。\n$4$. 根据指定的自适应规则计算下一个增量 $g_{t+1}$。首先，检查终止条件：如果 $g_t = 1$，则列表现已完全排序，因此将下一个增量设置为 0 以退出循环。否则，根据当前趟所做的工作（由 $s_t$ 衡量）来确定 $g_{t+1}$。\n    - 如果 $s_t = 0$，列表已经是 $g_t$-有序的，这表明有序度很高。增量被积极地减小：$g_{t+1} = \\max(1, \\lfloor g_t/4 \\rfloor)$。\n    - 如果 $s_t  0$，则计算每个插入元素的平均交换次数 $a_t = s_t / (n - g_t)$。分母 $n - g_t$ 代表在增量插入排序期间可能被移动的元素数量（即索引在 $g_t, \\ldots, n-1$ 的元素）。\n    - 如果 $0  a_t  1$，则完成了适量的工作。增量减小为 $g_{t+1} = \\max(1, \\lfloor g_t/3 \\rfloor)$。\n    - 如果 $a_t \\ge 1$，则完成了大量的工作，这表明列表相对于该增量是高度无序的。增量被保守地减小，以便在下一趟中进行更多比较：$g_{t+1} = \\max(1, \\lfloor g_t/2 \\rfloor)$。\n使用 $\\max(1, \\ldots)$ 确保增量不会过早变为 0，并确保最后一趟排序总是在 $g=1$ 时进行。\n\n辅助函数 `gapped_insertion_sort(arr, gap)` 实现了一趟排序。它从索引 $i = \\text{gap}$ 到 $n-1$ 遍历列表。对于每个元素 `arr[i]`，它被插入到其交错子列表内的正确位置。问题指定此插入必须通过“重复交换相距 $g_t$ 的相邻元素”来执行。这是通过一个内层循环实现的，该循环比较 `arr[j]` 和 `arr[j - gap]`，如果它们顺序错误则交换它们，并将 $j$ 递减 `gap`，直到元素到达其排序位置。每次这样的交换都被计数，并返回总数。\n\n整个过程是确定性的并且会终止，因为增量序列在 $g_t  1$ 时是严格递减的，并以 1 为下界，最终达到 1 然后变为 0。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gapped_insertion_sort(arr, gap):\n    \"\"\"\n    Performs a gapped insertion sort on the list `arr` for a given `gap`.\n    The list is modified in-place.\n    Returns the total number of swaps performed.\n    \"\"\"\n    n = len(arr)\n    swaps = 0\n    for i in range(gap, n):\n        j = i\n        while j >= gap and arr[j - gap] > arr[j]:\n            arr[j], arr[j - gap] = arr[j - gap], arr[j]\n            swaps += 1\n            j -= gap\n    return swaps\n\ndef adaptive_shell_sort(arr):\n    \"\"\"\n    Sorts a list of integers using an adaptive Shell Sort algorithm.\n    Returns the sorted list, total swaps, and total passes.\n    \"\"\"\n    n = len(arr)\n    if n = 1:\n        return arr, 0, 0\n\n    total_swaps = 0\n    total_passes = 0\n    current_gap = n // 2\n\n    while current_gap > 0:\n        total_passes += 1\n        \n        pass_swaps = gapped_insertion_sort(arr, current_gap)\n        total_swaps += pass_swaps\n\n        if current_gap == 1:\n            current_gap = 0\n        else:\n            s_t = pass_swaps\n            if s_t == 0:\n                current_gap = max(1, current_gap // 4)\n            else:\n                a_t = s_t / (n - current_gap)\n                if 0  a_t  1:\n                    current_gap = max(1, current_gap // 3)\n                else:\n                    current_gap = max(1, current_gap // 2)\n    \n    return arr, total_swaps, total_passes\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on test cases and print the output.\n    \"\"\"\n    test_cases = [\n        [9, 8, 3, 7, 5, 6, 4, 1, 2],\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [9, 8, 7, 6, 5, 4, 3, 2, 1],\n        [5, 3, 5, 2, 5, 1, 5],\n        [42],\n        [],\n        [-3, 1, -2, 4, 0],\n    ]\n\n    results = []\n    for case in test_cases:\n        arr_copy = list(case)\n        sorted_list, total_swaps, total_passes = adaptive_shell_sort(arr_copy)\n        results.append([sorted_list, total_swaps, total_passes])\n\n    formatted_results = []\n    for res in results:\n        sorted_list, total_swaps, total_passes = res\n        list_str = f\"[{','.join(map(str, sorted_list))}]\"\n        res_str = f\"[{list_str},{total_swaps},{total_passes}]\"\n        formatted_results.append(res_str)\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3270048"}, {"introduction": "算法分析不仅关乎时间效率，空间效率同样至关重要。为了从不同角度审视算法的资源消耗，本练习将引导你分析一个非原地的、递归版本的希尔排序的空间复杂度。这个思想实验虽然基于一个为教学目的而设计的假设场景，但它能有效地训练你分析递归算法中辅助空间（包括临时数据结构和函数调用栈）使用情况的能力。通过推导出一个精确的闭式表达式，你将掌握量化分析算法内存占用的严谨方法。[@problem_id:3270034]", "problem": "给定一个非原地的、递归版本的希尔排序，其定义如下。设输入为一个长度为 $n$ 的数组，其中 $n$ 是 $2$ 的幂，即对于某个整数 $m \\geq 0$，有 $n = 2^{m}$。步长序列固定为 $g_{0} = g_{1} = \\dots = g_{m-1} = 2$ 且 $g_{m} = 1$。算法 RecShell 对一个长度为 $\\ell$ 的子数组进行如下操作：\n\n1. 如果 $\\ell = 1$，立即返回（基本情况）。\n2. 否则，通过将当前子数组划分为模 $2$ 的两个剩余类，分配 $g = 2$ 个总长度等于 $\\ell$ 的临时数组 $T_{0}$ 和 $T_{1}$（即，$T_{0}$ 接收当前子数组所有偶数索引上的元素，$T_{1}$ 接收所有奇数索引上的元素）。所有 $T_{r}$ 在处理此层级期间保持分配状态。\n3. 对其中一个 $T_{r}$（例如 $T_{0}$），然后对另一个 $T_{r}$（例如 $T_{1}$）递归调用 RecShell，每次都使用相同的步长策略，但使用当前 $T_{r}$ 的长度作为新的 $\\ell$。\n4. 在两个递归调用都返回后，将 $T_{0}$ 和 $T_{1}$ 中的元素写回到它们在父子数组中的位置，并释放 $T_{0}$ 和 $T_{1}$。\n\n假设递归调用遵循深度优先遍历顺序，因此在任何时刻，只有一个活跃的递归分支，并且在祖先层级分配的所有临时数组都保持分配状态，直到递归回溯经过该层级。以“数组元素等效单位”来衡量辅助空间：每个分配的临时数组单元计为 $1$ 个单位。为了计算调用栈的影响，假设每个激活记录（栈帧）消耗 $\\sigma$ 个数组元素等效单位；也就是说，如果最大并发调用栈深度为 $d$，则栈消耗 $d \\sigma$ 个数组元素等效单位。\n\n仅使用上述定义以及以下事实：(i) 递归消耗一个后进先出（LIFO）的调用栈，其最大并发深度等于递归调用的最大嵌套深度；(ii) 在每个非基本情况的层级，两个临时数组 $T_{0}$ 和 $T_{1}$ 总共恰好包含当前子数组的所有 $\\ell$ 个元素，推导出一个关于 $n$ 和 $\\sigma$ 的精确、封闭形式的表达式，表示在长度为 $n$ 的输入上执行 RecShell 过程中的任何时刻所使用的最大并发辅助空间（以数组元素等效单位计）。\n\n你的最终答案必须是一个只包含 $n$ 和 $\\sigma$ 的单一封闭形式解析表达式（没有不等式，没有大O表示法，没有额外的文字说明）。不要四舍五入。明确写出任何对数的底数。", "solution": "用户想要找到递归算法 `RecShell` 在大小为 $n$（其中 $n = 2^m$，对于某个整数 $m \\ge 0$）的输入上使用的最大并发辅助空间。辅助空间是临时数组使用的空间和调用栈使用的空间之和。\n\n设 $S(t)$ 为执行过程中给定时间 $t$ 的总辅助空间。$S(t)$ 由两部分组成：用于临时数组的空间 $S_{\\text{arrays}}(t)$ 和用于调用栈的空间 $S_{\\text{stack}}(t)$。\n$$S(t) = S_{\\text{arrays}}(t) + S_{\\text{stack}}(t)$$\n目标是找到 $\\max_{t} S(t)$。\n\n算法 `RecShell` 被调用来处理长度为 $\\ell$ 的子数组。\n- 如果 $\\ell=1$，这是一个基本情况，函数返回。\n- 如果 $\\ell  1$，它会分配两个总大小为 $\\ell$ 的临时数组 $T_0$ 和 $T_1$，然后先对 $T_0$ 再对 $T_1$ 递归调用自身。由于输入长度 $n$ 是 $2$ 的幂，递归调用中遇到的任何子数组长度 $\\ell$ 也将是 $2$ 的幂（具体为 $\\ell=n, \\frac{n}{2}, \\frac{n}{4}, \\dots, 2$）。因此，两个临时数组 $T_0$ 和 $T_1$ 的长度都将是 $\\frac{\\ell}{2}$。\n\n让我们将空间使用量分析为递归深度的函数。初始调用 `RecShell(n)` 位于深度 $d=1$。它在深度 $d=2$ 调用 `RecShell(\\frac{n}{2})$，依此类推，直到调用 `RecShell(1)`。\n\n深度为 $d$ 时的调用栈空间由 $S_{\\text{stack}} = d \\cdot \\sigma$ 给出。这部分空间使用量随递归深度的增加而单调增加。\n\n临时数组空间 $S_{\\text{arrays}}$ 是所有并发分配的临时数组大小的总和。问题描述指出，父调用的临时数组在其子调用执行期间保持分配状态。\n考虑达到最大深度的执行路径。这是“深度优先”路径，我们总是对第一个临时数组 $T_0$ 进行递归。\n调用栈上的调用序列将是：\n`RecShell(n)` $\\to$ `RecShell(\\frac{n}{2})$ $\\to$ `RecShell(\\frac{n}{4})$ $\\to \\dots \\to$ `RecShell(2)` $\\to$ `RecShell(1)`。\n\n输入长度 $n$ 被给定为 $n = 2^m$。当长度为 $1 = 2^0$ 时，递归停止。递归调用中子数组的长度分别为 $2^m, 2^{m-1}, 2^{m-2}, \\dots, 2^1, 2^0$。\n对于 $k \\ge 1$，对长度为 $2^k$ 的子数组的调用将递归调用处理长度为 $2^{k-1}$ 的子数组。\n调用 `RecShell(n)` 对应于 $k=m$。调用 `RecShell(2)` 对应于 $k=1$。基本情况是 `RecShell(1)`，对应于 $k=0$。\n\n当 `RecShell(1)` 处于活动状态时，达到最大递归深度。让我们追踪此时的状态。\n调用栈包含 $m+1$ 个激活记录：从 `RecShell(n)` 到 `RecShell(1)` 的每次调用各一个。\n- 调用栈深度为 $d_{\\text{max}} = m+1$。\n- 调用栈消耗的空间为 $S_{\\text{stack}} = (m+1)\\sigma$。\n\n此时，我们需要确定所有已分配临时数组的总大小。对 `RecShell(\\ell)` 的调用会分配总大小为 $\\ell$ 的临时数组，前提是 $\\ell  1$。基本情况 `RecShell(1)` 不会分配任何数组。\n栈上已分配数组的调用有：\n`RecShell(n)`（分配大小为 $n$）\n`RecShell(\\frac{n}{2})$（分配大小为 $\\frac{n}{2}$）\n`RecShell(\\frac{n}{4})$（分配大小为 $\\frac{n}{4}$）\n...\n`RecShell(2)`（分配大小为 $2$）\n\n临时数组的总空间是这些大小的和：\n$$S_{\\text{arrays}} = n + \\frac{n}{2} + \\frac{n}{4} + \\dots + 2$$\n这是一个几何级数。使用 $n=2^m$，该级数为：\n$$S_{\\text{arrays}} = 2^m + 2^{m-1} + 2^{m-2} + \\dots + 2^1$$\n这是和 $\\sum_{i=1}^{m} 2^i$。对于首项为 $a$，公比为 $r$，项数为 $k$ 的几何级数，其求和公式为 $a\\frac{r^k-1}{r-1}$。这里，$a=2$，$r=2$，共有 $m$ 项。\n$$S_{\\text{arrays}} = 2 \\cdot \\frac{2^m - 1}{2-1} = 2(2^m - 1) = 2(n-1) = 2n-2$$\n\n在最大递归深度点，总辅助空间是栈空间和数组空间之和：\n$$S_{\\text{max}} = S_{\\text{arrays}} + S_{\\text{stack}} = (2n-2) + (m+1)\\sigma$$\n\n随着递归的深入，栈空间和累积的数组空间都会增加。因此，最大空间使用量发生在递归最深处。当递归回溯时，栈深度和已分配数组集的数量都会减少，因此总空间将小于此最大值。后续的递归分支（例如，对 $T_1$ 子数组的递归）将遵循相同的模式并达到相同的最大值，但不会超过它。\n\n问题要求最终答案用 $n$ 和 $\\sigma$ 表示。我们必须用 $n$ 来表示 $m$。\n给定 $n = 2^m$，我们可以对两边取以 $2$ 为底的对数：\n$$\\log_2(n) = \\log_2(2^m)$$\n$$m = \\log_2(n)$$\n这对于 $m \\ge 0$ 时的 $n=2^m$ 是有效的。注意，如果 $m=0$，则 $n=1$。算法进行一次对 `RecShell(1)` 的调用，这是一个基本情况。没有数组被分配（$S_{\\text{arrays}}=0$）。最大栈深度为 $d=1$。空间为 $1 \\cdot \\sigma = \\sigma$。我们的公式给出：$2(1)-2 + (\\log_2(1)+1)\\sigma = 0 + (0+1)\\sigma = \\sigma$。该公式对 $m=0, n=1$ 成立。\n\n将 $m = \\log_2(n)$ 代入 $S_{\\text{max}}$ 的表达式中：\n$$S_{\\text{max}} = 2n - 2 + (\\log_2(n) + 1)\\sigma$$\n\n这就是在执行 `RecShell` 期间所使用的最大并发辅助空间的精确封闭形式表达式。", "answer": "$$\n\\boxed{2n - 2 + \\sigma(\\log_{2}(n) + 1)}\n$$", "id": "3270034"}]}