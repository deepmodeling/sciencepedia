{"hands_on_practices": [{"introduction": "二分搜索是处理有序数组的基石，但当数组的单调性被循环移位破坏时，我们该如何应对？本练习 [@problem_id:3268840] 引导你修改经典的二分搜索算法，以在 $O(\\log n)$ 时间内在一个旋转排序数组中查找元素。通过在每一步中巧妙地识别出有序的子区间，你将学会如何在新约束下保留分治策略的核心威力。", "problem": "给定一个有限整数序列，该序列最初是一个长度为 $n$（$n \\geq 1$）的严格递增数组 $A$，随后通过未知数量 $k$（其中 $k \\in \\{0,1,\\dots,n-1\\}$）的循环右移变换成一个新数组 $B$。形式上，对于每个索引 $i \\in \\{0,1,\\dots,n-1\\}$，该变换满足\n$$\nB[i] = A\\big((i - k) \\bmod n\\big).\n$$\n$A$ 中的所有元素都是唯一的，并且 $A$ 是按严格升序排序的，即对于所有索引 $i$（$0 \\leq i  n-1$），都有 $A[i]  A[i+1]$。你必须设计一个基于比较搜索基本原理的算法，在不重构 $A$ 或 $k$、也不重新排序 $B$ 的情况下，确定目标值 $x$ 在 $B$ 中的索引（如果存在）。你的算法的最坏情况时间复杂度必须为 $O(\\log n)$。\n\n推理的基本依据：\n- 定义域是具有常规全序关系 $\\leq$ 的整数集。\n- 二分搜索作用于一个在全序序列上单调的谓词，从而能够在每一步通过二分法排除一半的搜索区间。\n- 对一个严格递增数组进行循环右移，会将结果数组 $B$ 分割成两个连续的部分，每个部分都是严格递增的，并在 $B$ 中最小元素所在的枢轴索引处分开。\n\n你的程序必须为多个独立的测试用例实现此搜索。对于每个测试用例，将提供一个数组 $B$ 和一个目标值 $x$，你必须返回 $x$ 在 $B$ 中的从零开始的索引（如果存在），如果 $x$ 不在 $B$ 中则返回 $-1$。每个测试用例的结果必须是一个整数。你不能显式地假设或计算移位量 $k$。\n\n测试套件：\n- 情况 1：$B = [7,9,11,1,3,5]$, $x = 3$。\n- 情况 2：$B = [1,2,3,4,5,6]$, $x = 6$。\n- 情况 3：$B = [42]$, $x = 7$。\n- 情况 4：$B = [30,40,50,5,10,20]$, $x = 5$。\n- 情况 5：$B = [12,-10,-5,0,5]$, $x = 12$。\n- 情况 6：$B = [4,5,6,7,0,1,2]$, $x = 0$。\n- 情况 7：$B = [4,5,6,7,0,1,2]$, $x = 3$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例相同。例如，如果三个用例的结果是 $r_1$、$r_2$ 和 $r_3$，则输出行将是 $[r_1,r_2,r_3]$。", "solution": "该问题被评估为**有效**。它自成体系，科学地基于算法设计原则，并且问题陈述清晰。该问题要求为一种特定的数据结构——循环移位的排序数组——设计一个高效的搜索算法，这是计算机科学中一个公认的经典问题。约束和目标清晰且逻辑一致。\n\n任务是在 $O(\\log n)$ 时间内，在一个长度为 $n$ 的循环移位的严格递增数组 $B$ 中找到目标值 $x$。数组 $B$ 是由一个严格递增数组 $A$ 经过未知量 $k \\in \\{0, 1, \\dots, n-1\\}$ 的循环右移形成的。这种结构意味着 $B$ 由两个连续的段组成，每一段都是严格递增排序的。这两段的连接点，通常称为枢轴（pivot），是原始数组 $A$ 的最大元素后面跟着其最小元素的位置。\n\n标准的二分搜索算法不能直接应用，因为整个数组 $B$ 不是单调递增的。然而，二分搜索的核心原则——每一步排除一半的搜索空间——可以被调整应用。关键在于，在每一步中，识别出数组中保证有序的一个段，然后确定目标值 $x$ 是否可能位于该段内。\n\n设搜索空间由索引 $[low, high]$ 定义，初始化为 $[0, n-1]$。在我们算法的每次迭代中，我们执行以下步骤：\n\n1.  计算中间索引：$mid = low + \\lfloor(high - low) / 2\\rfloor$。\n2.  将中间索引处的元素 $B[mid]$ 与目标值 $x$ 进行比较。如果 $B[mid] = x$，则找到目标，返回其索引 $mid$。\n3.  如果 $B[mid] \\ne x$，我们必须决定下一步要探索当前搜索空间的哪一半，是 $[low, mid-1]$ 还是 $[mid+1, high]$。这个决定基于识别有序的子段。我们将 $B[mid]$ 与当前搜索区间的一个端点（例如 $B[low]$）进行比较。\n\n    -   **情况 A：$B[low] \\le B[mid]$。** 这个条件意味着从索引 $low$ 到 $mid$ 的子数组是严格递增排序的。枢轴（如果它存在于 $[low, high]$ 范围内）必定在右半部分，即在 $[mid+1, high]$ 中。\n        -   现在我们可以确定目标 $x$ 是否属于这个有序的左半部分。如果 $B[low] \\le x  B[mid]$，那么 $x$ 必定位于区间 $[low, mid-1]$ 内。因此，我们通过设置 $high = mid - 1$ 来更新搜索空间。\n        -   否则，$x$ 必定在右半部分，即 $[mid+1, high]$ 中。我们通过设置 $low = mid + 1$ 来更新搜索空间。\n\n    -   **情况 B：$B[low] > B[mid]$。** 这个条件意味着枢轴位于从索引 $low$ 到 $mid$ 的子数组内。因此，从索引 $mid+1$ 到 $high$ 的右子数组必须是一个单一的、连续的有序块。\n        -   我们确定目标 $x$ 是否属于这个有序的右半部分。如果 $B[mid]  x \\le B[high]$，那么 $x$ 必定位于区间 $[mid+1, high]$ 内。我们通过设置 $low = mid + 1$ 来更新搜索空间。\n        -   否则，$x$ 必定在左半部分，即 $[low, mid-1]$ 中。我们通过设置 $high = mid - 1$ 来更新搜索空间。\n\n4.  只要 $low \\le high$，循环就继续。如果循环终止（即 $low > high$），则意味着在数组 $B$ 中未找到目标 $x$。在这种情况下，算法返回 $-1$。\n\n这种改进的二分搜索算法在每次迭代中都将搜索空间减半，无论满足哪种情况。比较次数与数组大小 $n$ 成对数关系。因此，该算法在不重构原始数组 $A$、不确定移位量 $k$、也不重新排序 $B$ 的情况下，达到了所要求的最坏情况时间复杂度 $O(\\log n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n\n    def search_in_rotated_array(B, x):\n        \"\"\"\n        Performs a modified binary search to find a target x in a cyclically\n        shifted sorted array B.\n\n        Args:\n            B (np.ndarray): The cyclically shifted sorted array of integers.\n            x (int): The target value to search for.\n\n        Returns:\n            int: The zero-based index of x if found, otherwise -1.\n        \"\"\"\n        low = 0\n        high = len(B) - 1\n\n        while low = high:\n            mid = low + (high - low) // 2\n\n            if B[mid] == x:\n                return mid\n\n            # Case A: The left half of the search space [low...mid] is sorted.\n            # This is identified by B[low] = B[mid].\n            if B[low] = B[mid]:\n                # Check if the target is within the range of the sorted left half.\n                if B[low] = x  B[mid]:\n                    high = mid - 1\n                else:\n                    # Target must be in the right half.\n                    low = mid + 1\n            # Case B: The right half of the search space [mid+1...high] is sorted.\n            # This is implied if the left half is not sorted.\n            else:\n                # Check if the target is within the range of the sorted right half.\n                if B[mid]  x = B[high]:\n                    low = mid + 1\n                else:\n                    # Target must be in the left half.\n                    high = mid - 1\n        \n        # Target was not found in the array.\n        return -1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([7, 9, 11, 1, 3, 5]), 3),  # Case 1\n        (np.array([1, 2, 3, 4, 5, 6]), 6),  # Case 2\n        (np.array([42]), 7),                # Case 3\n        (np.array([30, 40, 50, 5, 10, 20]), 5), # Case 4\n        (np.array([12, -10, -5, 0, 5]), 12),    # Case 5\n        (np.array([4, 5, 6, 7, 0, 1, 2]), 0),  # Case 6\n        (np.array([4, 5, 6, 7, 0, 1, 2]), 3)   # Case 7\n    ]\n\n    results = []\n    for B, x in test_cases:\n        result = search_in_rotated_array(B, x)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3268840"}, {"introduction": "在掌握了如何处理简单的单调性破坏后，让我们来挑战一个更复杂的结构：“双调数组”。这种数组先单调递增，然后单调递减，形成一个独特的“山峰”形状。本练习 [@problem_id:3268712] 要求你设计一个多阶段搜索策略，首先用对数时间复杂度的算法定位峰值，然后将问题分解为在两个独立的单调序列上进行二分搜索，这充分体现了“分而治之”的思想。", "problem": "给定一个全序数组和严格单调序列的基本定义。如果一个长度为 $n$ 的数组 $A$ 中存在一个唯一的索引 $p$（$0  p  n - 1$），使得 $A[0]  A[1]  \\dots  A[p]$ 且 $A[p] > A[p+1] > \\dots > A[n-1]$，则称该数组是双调的（bitonic）。给定一个双调数组 $A$ 和一个目标值 $x$，任务是从第一性原理出发，设计一种仅使用比较操作并利用双调数组结构特性的搜索策略，以找到一个索引 $i$ 使得 $A[i] = x$（如果存在这样的索引），或者报告不存在这样的索引。该策略必须基于严格递增和严格递减序列的性质以及全序关系推导得出，并且对于满足双调定义的数组，其时间复杂度必须为 $\\mathcal{O}(\\log n)$。\n\n您的程序必须实现该搜索策略，并将其应用于以下测试套件。下面的所有数组都是双调的，具有严格递增和严格递减的段，并且所有索引都是从 $0$ 开始的。对于每对 $(A_j, x_j)$，如果存在一个整数索引 $i_j$ 使得 $A_j[i_j] = x_j$，则返回该索引；如果不存在，则返回 $-1$。\n\n测试套件：\n- 情况 $1$：$A_1 = [1,3,7,12,14,13,9,5,2]$, $x_1 = 9$。\n- 情况 $2$：$A_2 = [2,4,8,15,14,10,3]$, $x_2 = 15$。\n- 情况 $3$：$A_3 = [1,2,3,4,3,1]$, $x_3 = 10$。\n- 情况 $4$：$A_4 = [1,5,9,11,10,4,2]$, $x_4 = 1$。\n- 情况 $5$：$A_5 = [0,2,5,7,6,3,1]$, $x_5 = 1$。\n- 情况 $6$：$A_6 = [1,3,2]$, $x_6 = 2$。\n- 情况 $7$：$A_7 = [1,4,9,12,11,7,3]$, $x_7 = 4$。\n- 情况 $8$：$A_8 = [3,8,12,11,10,6,5]$, $x_8 = 6$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$）。每个结果必须是一个整数索引，如果未找到，则为 $-1$。输出必须严格按照陈述的顺序汇总八个情况的答案。", "solution": "用户提供的问题陈述已经过验证，被确定为一个定义明确、有科学依据且结构严谨的算法挑战。它没有矛盾、歧义和事实错误。任务是为双调数组设计一个高效的搜索算法，遵循指定的复杂度约束，并从第一性原理推导出解决方案。\n\n### 基于第一性原理的搜索策略推导\n\n问题要求为长度为 $n$ 的双调数组 $A$ 设计一个搜索算法，以查找目标值 $x$。双调数组由一个唯一的索引 $p \\in (0, n-1)$ 定义，使得子数组 $A[0 \\dots p]$ 严格递增，而子数组 $A[p \\dots n-1]$ 严格递减。这种结构是实现高效搜索的关键。在有序数据中搜索的基本原理是二分搜索，其运行时间为 $\\mathcal{O}(\\log n)$。然而，标准的二分搜索需要一个单一、统一的单调序列。由于峰值 $A[p]$ 的存在，双调数组不满足此条件。\n\n我们的策略是将问题分解为可以应用标准搜索原理的可管理子问题。分解的关键在于定位峰值元素，它将数组划分为两个不同的、纯粹单调的序列。\n\n总体策略包括三个主要步骤：\n1.  定位峰值元素 $A[p]$，它是数组中的最大值。\n2.  在严格递增的子数组 $A[0 \\dots p]$ 中搜索目标 $x$。\n3.  如果未找到，则在严格递减的子数组 $A[p \\dots n-1]$ 中搜索目标 $x$。\n\n为了满足 $\\mathcal{O}(\\log n)$ 的总体复杂度要求，每个步骤都必须在对数时间内执行。\n\n#### 步骤 1：寻找双调峰值\n\n峰值索引 $p$ 是数组中最大元素的索引。我们可以使用一种改进的二分搜索算法高效地找到这个索引。该搜索利用了任何给定元素周围斜率的局部属性。对于任何索引 $m$（$0  m  n-1$）：\n- 如果 $A[m-1]  A[m]  A[m+1]$，则索引 $m$ 位于递增段。峰值必定在 $m$ 的右侧。\n- 如果 $A[m-1] > A[m] > A[m+1]$，则索引 $m$ 位于递减段。峰值必定在 $m$ 的左侧。\n- 如果 $A[m-1]  A[m]$ 且 $A[m] > A[m+1]$，则 $m$ 就是峰值索引 $p$。\n\n这使我们能够在每一步中舍弃一半的搜索空间。设搜索区间为 $[l, h]$。我们计算中点 $m = l + \\lfloor(h-l)/2\\rfloor$。通过比较 $A[m]$ 及其相邻的 $A[m+1]$，我们决定在何处继续搜索：\n- 如果 $A[m]  A[m+1]$，我们处于递增斜率上，因此峰值必定位于区间 $[m+1, h]$ 中。\n- 如果 $A[m] > A[m+1]$，我们处于峰值或递减斜率上，因此峰值必定位于区间 $[l, m]$ 中。\n\n重复此过程，直到搜索区间 $[l, h]$ 收敛到单个元素，即 $l=h$。这个最终索引就是峰值索引 $p$。此搜索的时间复杂度为 $\\mathcal{O}(\\log n)$。\n\n#### 步骤 2：在递增子数组上进行二分搜索\n\n一旦知道了峰值索引 $p$，我们就得到了一个严格递增的子数组 $A[0 \\dots p]$。该子数组由关系 $\\le$ 全序排列。我们可以应用标准的二分搜索算法在此段中查找 $x$。\n\n在 $A[0 \\dots p-1]$ 上的二分搜索算法操作如下：\n- 设搜索区间为 $[l, h]$，初始化为 $[0, p-1]$。\n- 当 $l \\le h$ 时：\n    - 计算中点 $m = l + \\lfloor(h-l)/2\\rfloor$。\n    - 如果 $A[m] = x$，则在索引 $m$ 处找到元素。\n    - 如果 $A[m]  x$，目标必定在区间的右半部分，所以我们设置 $l = m+1$。\n    - 如果 $A[m] > x$，目标必定在区间的左半部分，所以我们设置 $h = m-1$。\n如果循环完成而没有找到 $x$，则元素不在此段中。此搜索的时间复杂度为 $\\mathcal{O}(\\log p)$，其上界为 $\\mathcal{O}(\\log n)$。我们还必须检查是否 $A[p]=x$。\n\n#### 步骤 3：在递减子数组上进行二分搜索\n\n如果在递增部分没有找到 $x$，我们就在严格递减的子数组 $A[p+1 \\dots n-1]$ 中搜索。该子数组由关系 $\\ge$ 全序排列。可以对二分搜索进行调整以适应这种降序。\n\n在 $A[p+1 \\dots n-1]$ 上的二分搜索算法操作如下：\n- 设搜索区间为 $[l, h]$，初始化为 $[p+1, n-1]$。\n- 当 $l \\le h$ 时：\n    - 计算中点 $m = l + \\lfloor(h-l)/2\\rfloor$。\n    - 如果 $A[m] = x$，则在索引 $m$ 处找到元素。\n    - 如果 $A[m]  x$，因为数组是递减的，目标（一个更大的值）必定在左半部分。我们设置 $h = m-1$。\n    - 如果 $A[m] > x$，目标（一个更小的值）必定在右半部分。我们设置 $l = m+1$。\n如果循环完成，则 $x$ 不在此段中。此搜索的复杂度为 $\\mathcal{O}(\\log(n-p-1))$，其上界为 $\\mathcal{O}(\\log n)$。\n\n#### 完整算法的综合\n\n完整的算法集成了这三个步骤：\n\n1.  给定双调数组 $A$ 和目标 $x$。处理数组元素少于 3 个的边界情况。\n2.  调用峰值查找算法获取索引 $p$。这需要 $\\mathcal{O}(\\log n)$ 时间。\n3.  如果 $A[p] = x$，返回 $p$。\n4.  如果 $x > A[p]$，则 $x$ 不可能存在于数组中，因为 $A[p]$ 是最大值。返回 $-1$。\n5.  在区间 $[0, p-1]$ 上执行升序二分搜索。如果在索引 $i$ 处找到 $x$，则返回 $i$。这需要 $\\mathcal{O}(\\log n)$ 时间。\n6.  如果未找到，则在区间 $[p+1, n-1]$ 上执行降序二分搜索。如果在索引 $j$ 处找到 $x$，则返回 $j$。否则，返回 $-1$。这也需要 $\\mathcal{O}(\\log n)$ 时间。\n\n总时间复杂度是这些步骤的复杂度之和，即 $\\mathcal{O}(\\log n) + \\mathcal{O}(\\log n) + \\mathcal{O}(\\log n) = \\mathcal{O}(\\log n)$。这满足了问题的要求，并且是从有序集合的基本性质和双调数组的特定结构推导出来的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bitonic array search problem for a given test suite.\n    \"\"\"\n\n    def find_peak(arr):\n        \"\"\"\n        Finds the peak element in a bitonic array in O(log n) time.\n        The array must be bitonic as per the problem definition (n >= 3).\n        \"\"\"\n        n = len(arr)\n        low, high = 0, n - 1\n        while low  high:\n            mid = low + (high - low) // 2\n            # Compare mid with its right neighbor to determine the slope\n            if arr[mid]  arr[mid + 1]:\n                # We are on the increasing part, so the peak is to the right\n                low = mid + 1\n            else:\n                # We are at the peak or on the decreasing part, peak is to the left or at mid\n                high = mid\n        # When low == high, we have found the peak\n        return low\n\n    def binary_search_ascending(arr, low, high, x):\n        \"\"\"\n        Performs binary search on a strictly increasing subarray.\n        \"\"\"\n        while low = high:\n            mid = low + (high - low) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid]  x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    def binary_search_descending(arr, low, high, x):\n        \"\"\"\n        Performs binary search on a strictly decreasing subarray.\n        \"\"\"\n        while low = high:\n            mid = low + (high - low) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid]  x:\n                # Since the array is descending, larger values are to the left\n                high = mid - 1\n            else:\n                # Smaller values are to the right\n                low = mid + 1\n        return -1\n\n    def search_bitonic(arr, x):\n        \"\"\"\n        Main function to search for an element in a bitonic array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n        \n        # The problem definition implies n >= 3, so peak is not at 0 or n-1.\n        # This implementation of find_peak is robust for n >= 1.\n        peak_index = find_peak(arr)\n\n        # Check if the peak element is the target\n        if arr[peak_index] == x:\n            return peak_index\n        \n        # If target is greater than the peak, it cannot be in the array\n        if arr[peak_index]  x:\n            return -1\n\n        # Search in the increasing part (left of the peak)\n        result = binary_search_ascending(arr, 0, peak_index - 1, x)\n        if result != -1:\n            return result\n\n        # If not found, search in the decreasing part (right of the peak)\n        result = binary_search_descending(arr, peak_index + 1, n - 1, x)\n        return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([1, 3, 7, 12, 14, 13, 9, 5, 2]), 9),\n        (np.array([2, 4, 8, 15, 14, 10, 3]), 15),\n        (np.array([1, 2, 3, 4, 3, 1]), 10),\n        (np.array([1, 5, 9, 11, 10, 4, 2]), 1),\n        (np.array([0, 2, 5, 7, 6, 3, 1]), 1),\n        (np.array([1, 3, 2]), 2),\n        (np.array([1, 4, 9, 12, 11, 7, 3]), 4),\n        (np.array([3, 8, 12, 11, 10, 6, 5]), 6),\n    ]\n\n    results = []\n    for arr, x in test_cases:\n        result = search_bitonic(arr, x)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3268712"}, {"introduction": "搜索问题不仅限于一维序列。当数据扩展到二维，例如在一个行列均有序的矩阵中，新的高效策略便应运而生。本练习 [@problem_id:3268809] 旨在探索并比较在二维有序矩阵中查找元素的三种不同方法，从朴素的线性扫描到巧妙的“阶梯式”搜索。通过实现和分析这些策略，你将深刻理解如何利用多维数据结构特性来设计时间复杂度为 $O(N+M)$ 的优雅算法。", "problem": "给定一个矩阵 $\\mathbf{A} \\in \\mathbb{Z}^{N \\times M}$，其性质为每一行都从左到右严格递增，每一列都从上到下严格递增。形式上，对于所有索引 $i$ 和 $j$（其中 $0 \\le i  N$ 且 $0 \\le j  M$），当 $j+1  M$ 时，$\\mathbf{A}[i][j]  \\mathbf{A}[i][j+1]$ 成立；当 $i+1  N$ 时，$\\mathbf{A}[i][j]  \\mathbf{A}[i+1][j]$ 成立。假设 $\\mathbb{Z}$ 上的全序关系为基础，所有比较都使用标准的整数关系。\n\n你的任务是实现并比较多种搜索策略，以在此类矩阵中定位一个目标值 $x \\in \\mathbb{Z}$。这些策略必须遵循搜索的基本原理来实现：\n\n- 策略1：朴素线性扫描。按行主序遍历条目，并在每个位置测试是否满足 $\\mathbf{A}[i][j] = x$，直到找到目标或检查完所有条目为止。\n\n- 策略2：带边界检查的逐行二分搜索。对于每一行 $i$，首先检查 $x$ 是否位于该行第一个和最后一个元素定义的闭区间内，即测试 $x  \\mathbf{A}[i][0]$ 和 $x > \\mathbf{A}[i][M-1]$ 来决定是否可以跳过该行。如果不能跳过，则在该行上执行二分搜索以尝试找到 $x$。\n\n- 策略3：从右上角开始的单调阶梯搜索。初始化 $(i,j) = (0, M-1)$，并重复将 $\\mathbf{A}[i][j]$ 与 $x$ 进行比较。如果 $\\mathbf{A}[i][j] = x$，则搜索成功终止。如果 $\\mathbf{A}[i][j]  x$，则增加 $i$（向下移动）。如果 $\\mathbf{A}[i][j] > x$，则减少 $j$（向左移动）。只要 $0 \\le i  N$ 且 $0 \\le j  M$，就继续此过程。\n\n精确定义基本操作成本模型如下。单次比较是指矩阵条目与目标值之间使用 $$, $>$, 或 $=$ 之一的关系运算符进行一次求值。你的程序必须计算并报告在每个测试用例上，每种策略执行的此类比较的确切次数。对于朴素线性扫描，每次访问一个条目以测试相等性时计为一次比较。对于逐行二分搜索，计算每个被考虑行的边界检查比较次数，以及二分搜索每一步的比较次数，当相等性检查和 $$ 测试都执行时要分开计数。对于阶梯搜索，计算相等性测试，如果不相等，则计算用于决定移动方向的后续 $$ 或 $>$ 测试。\n\n索引必须是从零开始的：将位置报告为 $[i,j]$，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,M-1\\}$。如果目标值不在矩阵中，则报告 $[-1,-1]$。\n\n测试套件。使用下面这组完全相同的矩阵和目标值来验证解决方案的不同方面。每个案例指定 $(\\mathbf{A}, x)$:\n\n- 案例1（一般情况）: \n  $\\mathbf{A} = \\begin{bmatrix}\n  1   4   7   11  15 \\\\\n  2   5   8   12  19 \\\\\n  3   6   9   16  22 \\\\\n  10  13  14  17  24\n  \\end{bmatrix}$, $x = 14$.\n\n- 案例2（未找到，值介于现有条目之间）: \n  $\\mathbf{A}$ 与案例1相同, $x = 20$.\n\n- 案例3（边界最小矩阵）:\n  $\\mathbf{A} = \\begin{bmatrix} 5 \\end{bmatrix}$, $x = 5$.\n\n- 案例4（矩形高矩阵，含负值和正值）:\n  $\\mathbf{A} = \\begin{bmatrix}\n  -10  -3  0 \\\\\n  -9  -2  1 \\\\\n  -5  2   3 \\\\\n  4   6   8 \\\\\n  7   9   11\n  \\end{bmatrix}$, $x = -2$.\n\n- 案例5（目标在右上角）:\n  $\\mathbf{A} = \\begin{bmatrix}\n  1  2  3 \\\\\n  4  5  6\n  \\end{bmatrix}$, $x = 3$.\n\n- 案例6（目标在左下角）:\n  $\\mathbf{A} = \\begin{bmatrix}\n  2  5  9   12 \\\\\n  3  8  10  15 \\\\\n  6  11  13  20\n  \\end{bmatrix}$, $x = 6$.\n\n要求的最终输出格式。对于每个测试用例，生成一个列表 $[i, j, c_{\\text{naive}}, c_{\\text{rowbin}}, c_{\\text{stair}}]$，其中 $[i,j]$ 是策略3（阶梯搜索）定位到的位置，如果未找到则为 $[-1,-1]$，$c_{\\text{naive}}$ 是策略1执行的比较次数，$c_{\\text{rowbin}}$ 是策略2执行的比较次数，$c_{\\text{stair}}$ 是策略3执行的比较次数。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果；即，一个形如 $[[\\dots],[\\dots],\\dots]$ 的每案例结果列表，不含空格。\n\n所有数值答案必须是整数。角度和物理单位不适用于此问题；无需进行单位转换。", "solution": "所提出的问题要求实现并比较分析三种不同的算法，用于在 $N \\times M$ 整数矩阵 $\\mathbf{A}$ 中搜索目标值 $x$。该矩阵具有一种特殊结构：其行和列均严格递增。该性质形式化表述为，对于所有 $i \\in \\{0, \\dots, N-1\\}$ 和 $j \\in \\{0, \\dots, M-2\\}$，$\\mathbf{A}[i][j]  \\mathbf{A}[i][j+1]$；以及对于所有 $j \\in \\{0, \\dots, M-1\\}$ 和 $i \\in \\{0, \\dots, N-2\\}$，$\\mathbf{A}[i][j]  \\mathbf{A}[i+1][j]$。我们将从基本原理出发分析每种策略，重点关注矩阵条目与目标值 $x$ 之间的比较次数，将其作为主要成本度量。\n\n### 策略1：朴素线性扫描\n\n这是最直接的方法。该算法按预定顺序（通常是行主序）遍历矩阵 $\\mathbf{A}$ 的每个条目，并将其与目标值 $x$进行比较。一旦找到匹配项，搜索立即终止。如果遍历整个矩阵仍未找到 $x$，则搜索不成功地结束。\n\n设矩阵的维度为 $N \\times M$。算法按如下方式进行：\n对于 $i$ 从 $0$ 到 $N-1$：\n  对于 $j$ 从 $0$ 到 $M-1$：\n    比较 $\\mathbf{A}[i][j]$ 与 $x$。\n    如果 $\\mathbf{A}[i][j] = x$，则在位置 $[i, j]$ 找到匹配项。终止。\n\n成本模型为每次相等性测试指定一次比较。在最坏情况下（目标是最后一个元素或不存在），此策略将执行 $N \\times M$ 次比较。因此，时间复杂度为 $O(N \\cdot M)$。此策略没有利用行和列的有序性质。\n\n### 策略2：逐行二分搜索\n\n此策略利用了矩阵每一行都是一个有序数组这一事实。它遍历每一行，并对每一行决定是否有必要进行搜索。如果目标值 $x$ 在该行的值范围之外，则可以跳过该行。第 $i$ 行的范围是闭区间 $[\\mathbf{A}[i][0], \\mathbf{A}[i][M-1]]$。算法首先执行边界检查：如果 $x  \\mathbf{A}[i][0]$ 或 $x > \\mathbf{A}[i][M-1]$，则该行不可能包含 $x$ 并被跳过。根据指定的成本模型，此检查涉及一次比较 ($x  \\mathbf{A}[i][0]$)。如果该比较为假，则进行第二次比较 ($x > \\mathbf{A}[i][M-1]$)。因此，每行的边界检查成本为1次或2次比较。\n\n如果边界检查表明 $x$ 可能在当前行中，则对该行执行标准的二分搜索。在对索引从 `low` 到 `high` 的子数组进行二分搜索的步骤中，我们计算 `mid` 并将 $\\mathbf{A}[i][\\text{mid}]$ 与 $x$ 进行比较。如果它们相等，则搜索成功。这花费1次比较。如果不相等，则另一次比较确定 $\\mathbf{A}[i][\\text{mid}]$ 是小于还是大于 $x$，从而将搜索空间缩小到左半部分或右半部分。此步骤总共花费2次比较。\n\n对长度为 $M$ 的单行进行二分搜索的最坏情况复杂度为 $O(\\log M)$。由于可能需要对所有 $N$ 行都执行此操作，因此该策略的总复杂度为 $O(N \\log M)$。与朴素扫描相比，这是一个显著的改进，特别是对于较大的 $M$。\n\n### 策略3：单调阶梯搜索\n\n这是三种策略中最复杂精妙的一种，因为它同时利用了行和列的有序性质。搜索从矩阵的特定角落开始。一个常见且高效的选择是右上角，即 $(i, j) = (0, M-1)$。设当前位置的值为 $v = \\mathbf{A}[i][j]$。\n\n搜索根据与目标 $x$ 的比较迭代进行：\n1. 如果 $v = x$，则找到目标。搜索终止。此步骤花费1次比较。\n2. 如果 $v > x$，这意味着当前列 $j$ 中在第 $i$ 行或其下方的所有元素也必定大于 $x$（由于列有序性质，对于 $k > i$ 有 $\\mathbf{A}[k][j] \\ge \\mathbf{A}[i][j] > x$）。因此，可以从搜索空间中排除整个列 $j$。算法通过减少 $j$ 向左移动。此步骤花费2次比较（一次用于相等性判断，一次用于方向判断）。\n3. 如果 $v  x$，这意味着当前行 $i$ 中在第 $j$ 列左侧的所有元素也必定小于 $x$（由于行有序性质，对于 $k  j$ 有 $\\mathbf{A}[i][k] \\le \\mathbf{A}[i][j]  x$）。因此，可以排除整个行 $i$。算法通过增加 $i$ 向下移动。此步骤也花费2次比较。\n\n只要索引 $(i, j)$ 在矩阵边界内（$0 \\le i  N$ 且 $0 \\le j \\ge 0$），搜索就会继续。在每一步，算法都会排除一行或一列。在最坏情况下，搜索路径将从右上角遍历到左下角，最多涉及 $N-1$ 次向下移动和 $M-1$ 次向左移动。因此，总步数最多为 $(N-1) + (M-1) + 1 = N+M-1$。时间复杂度为 $O(N+M)$，这通常优于 $O(N \\log M)$，除非 $M$ 比 $N$ 大指数级。\n\n这种“阶梯”路径在每一步都有效地裁剪掉一行或一列的搜索空间，从而提高了效率。返回的位置是按规定由该方法找到的位置。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef naive_scan(A, x):\n    \"\"\"\n    Performs a naive linear scan to find x in A.\n    Returns: (position, comparisons)\n    \"\"\"\n    comparisons = 0\n    if A.size == 0:\n        return [-1, -1], 0\n    N, M = A.shape\n    for i in range(N):\n        for j in range(M):\n            comparisons += 1\n            if A[i, j] == x:\n                return [i, j], comparisons\n    return [-1, -1], comparisons\n\ndef row_wise_binary_search(A, x):\n    \"\"\"\n    Performs a row-wise binary search to find x in A.\n    Returns: (position, comparisons)\n    \"\"\"\n    comparisons = 0\n    if A.size == 0:\n        return [-1, -1], 0\n    N, M = A.shape\n    if M == 0:\n        return [-1, -1], 0\n        \n    for i in range(N):\n        # Bounding checks\n        comparisons += 1\n        if x  A[i, 0]:\n            continue\n        \n        # This check is only performed if the first one fails\n        comparisons += 1\n        if x > A[i, M - 1]:\n            continue\n\n        # Binary search on the row\n        low, high = 0, M - 1\n        while low = high:\n            mid = low + (high - low) // 2\n            \n            comparisons += 1\n            if A[i, mid] == x:\n                return [i, mid], comparisons\n            \n            # Second comparison for direction\n            comparisons += 1\n            if A[i, mid]  x:\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n    return [-1, -1], comparisons\n\ndef staircase_search(A, x):\n    \"\"\"\n    Performs a monotone staircase search to find x in A.\n    Returns: (position, comparisons)\n    \"\"\"\n    comparisons = 0\n    if A.size == 0:\n        return [-1, -1], 0\n    N, M = A.shape\n    if M == 0:\n        return [-1, -1], 0\n\n    i, j = 0, M - 1\n    while i  N and j >= 0:\n        comparisons += 1\n        if A[i, j] == x:\n            return [i, j], comparisons\n        \n        # Second comparison for direction\n        comparisons += 1\n        if A[i, j] > x:\n            j -= 1\n        else: # A[i, j]  x\n            i += 1\n            \n    return [-1, -1], comparisons\n\ndef solve():\n    test_cases = [\n        (np.array([\n            [1, 4, 7, 11, 15],\n            [2, 5, 8, 12, 19],\n            [3, 6, 9, 16, 22],\n            [10, 13, 14, 17, 24]\n        ]), 14),\n        (np.array([\n            [1, 4, 7, 11, 15],\n            [2, 5, 8, 12, 19],\n            [3, 6, 9, 16, 22],\n            [10, 13, 14, 17, 24]\n        ]), 20),\n        (np.array([[5]]), 5),\n        (np.array([\n            [-10, -3, 0],\n            [-9, -2, 1],\n            [-5, 2, 3],\n            [4, 6, 8],\n            [7, 9, 11]\n        ]), -2),\n        (np.array([\n            [1, 2, 3],\n            [4, 5, 6]\n        ]), 3),\n        (np.array([\n            [2, 5, 9, 12],\n            [3, 8, 10, 15],\n            [6, 11, 13, 20]\n        ]), 6),\n    ]\n\n    results = []\n    for A, x in test_cases:\n        pos_naive, c_naive = naive_scan(A, x)\n        pos_rowbin, c_rowbin = row_wise_binary_search(A, x)\n        pos_stair, c_stair = staircase_search(A, x)\n        \n        result_list = [*pos_stair, c_naive, c_rowbin, c_stair]\n        results.append(result_list)\n        \n    def format_result(res):\n        return f\"[{','.join(map(str, res))}]\"\n\n    print(f\"[{','.join(map(format_result, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "3268809"}]}