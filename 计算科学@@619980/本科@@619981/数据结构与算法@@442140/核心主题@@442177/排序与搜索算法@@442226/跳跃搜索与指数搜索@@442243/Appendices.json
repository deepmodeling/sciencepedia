{"hands_on_practices": [{"introduction": "标准的搜索算法通常只返回目标值的单个匹配项。然而，在许多实际应用中，例如在一个已排序的日志文件中查找一个特定用户的所有连续活动记录，我们需要找到目标值首次出现和最后出现的位置。这个练习 [@problem_id:3242935] 挑战你扩展跳跃搜索，设计一个“双向”策略，在找到一个匹配项后，向左和向右两个方向高效地扩展搜索，从而精确定位包含所有重复值的完整区间。", "problem": "给定一个可能包含重复值的非递减有序数组。请设计并实现一个完整的、可运行的程序，该程序针对每个提供的测试用例，使用双向跳跃搜索策略计算查询值的首次和末次出现位置的索引。该双向策略必须仅依赖于排序数组的单调性和一个有原则的跳跃步长选择，而不使用二分搜索。您的设计必须从最坏情况比较次数的角度明确论证跳跃步长的选择，然后使用对称的向左和向右跳跃扩展来隔离重复值的范围。\n\n基本原理与约束：设数组表示为 $A = [A_0, A_1, \\dots, A_{n-1}]$，其中 $n \\in \\mathbb{N}$ 且 $n \\geq 0$，查询值表示为 $v \\in \\mathbb{Z}$。该数组满足对于所有索引 $i,j \\in \\{0,1,\\dots,n-1\\}$ 且 $i \\leq j$，有 $A_i \\leq A_j$。搜索成本由元素比较的次数来量化。您必须从排序属性和比较计数模型出发进行推理；不得在没有论证的情况下依赖或引用预先推导出的最优参数。您必须根据最小化跳跃式区间定位的最坏情况比较次数来选择一个关于 $n$ 的函数作为跳跃步长，并在您的解决方案中论证这一选择。\n\n要求的算法行为：\n- 使用向前跳跃定位一个可能包含 $v$ 的块，然后在该块内进行线性扫描，以找到某个索引 $i$ 使得 $A_i = v$（如果存在）。\n- 如果找到了这样的索引 $i$，则使用固定大小的反向跳跃向左扩展，以框定首次出现的位置，然后执行局部线性扫描，以确定确切的首次出现索引 $i_{\\text{first}}$。\n- 使用固定大小的向前跳跃向右扩展，以框定末次出现的位置，然后执行局部线性扫描，以确定确切的末次出现索引 $i_{\\text{last}}$。\n- 如果 $v$ 不存在，则返回列表 $[-1,-1]$。\n\n测试套件：您的程序必须在无需任何外部输入、文件或网络调用的情况下，运行以下所有测试用例。每个测试用例是一个序对 $(A, v)$。\n\n- 情况 1：$A = [\\,1,2,2,2,3,4,5\\,]$, $v = 2$。\n- 情况 2：$A = [\\,5,5,5,6,7\\,]$, $v = 5$。\n- 情况 3：$A = [\\,1,2,3,9,9,9\\,]$, $v = 9$。\n- 情况 4：$A = [\\,1,2,3,4\\,]$, $v = 6$。\n- 情况 5：$A = [\\,8\\,]$, $v = 8$。\n- 情况 6：$A = [\\,8\\,]$, $v = 9$。\n- 情况 7：$A = [\\,7,7,7,7,7,7,7,7\\,]$, $v = 7$。\n- 情况 8：$A = [\\,0,1,1,1,2,2,4,4,4,4,5,9,9,11\\,]$, $v = 4$。\n- 情况 9：$A = [\\,\\,]$（空数组），$v = 3$。\n\n答案规范：\n- 对于每个测试用例，程序必须输出一个包含恰好两个整数的列表 $[i_{\\text{first}}, i_{\\text{last}}]$，其中 $i_{\\text{first}}$ 是 $v$ 在 $A$ 中首次出现的索引，$i_{\\text{last}}$ 是 $v$ 在 $A$ 中末次出现的索引。如果 $v$ 不存在，则输出 $[-1,-1]$。\n- 程序的最终输出必须是单行字符串，其中包含一个由方括号括起来的、以逗号分隔的各用例结果列表，且内部结果列表中没有空格。例如，如果有三个用例的输出分别为 $[\\,1,3\\,]$、$[\\,0,2\\,]$ 和 $[\\,4,4\\,]$，则程序必须打印字符串 `\"[[$1$,$3$],[$0$,$2$],[$4$,$4$]]\"`。\n\n您的程序必须是完全自包含的，可直接执行，并以通用编程语言表达。在数值上，所有输出都是纯索引（整数），不涉及任何物理单位。不涉及角度或百分比。除了数组是非递减有序的之外，该算法不得对数据分布做任何假设。", "solution": "所提出的问题是有效的，因为它基于算法设计的科学原理，问题定义良好，具有唯一且可验证的解，并以客观、正式的语言表述。它没有任何科学、逻辑或事实上的不健全之处。\n\n该问题要求设计一种算法，在大小为 $n$ 的排序数组 $A$ 中查找查询值 $v$ 的首次和末次出现。该数组按非递减顺序排序，即对于所有索引 $i, j$ 且 $0 \\le i \\le j  n$，有 $A_i \\le A_j$。解决方案必须采用基于跳跃的搜索策略，并明确避免使用二分搜索。一个核心要求是基于最小化最坏情况下的比较次数来论证跳跃步长 $k$ 的选择。\n\n整个算法分为三个阶段：\n1.  初步跳跃搜索，以找到 $A_i=v$ 的任意一个索引 $i$。\n2.  从该索引开始的向左扩展跳跃搜索，以定位首次出现的位置 $i_{\\text{first}}$。\n3.  对称的向右扩展跳跃搜索，以精确定位末次出现的位置 $i_{\\text{last}}$。\n\n**跳跃步长的论证**\n\n跳跃搜索通过检查固定间隔（大小为 $k$）的元素来快速缩小目标值可能存在的区域。总搜索成本主要由两个操作决定：跳跃本身和随后在缩小的块内的线性扫描。\n\n1.  **跳跃阶段**：我们探测索引 $k, 2k, 3k, \\dots, m \\cdot k$，直到搜索越过 $v$ 的可能位置。在最坏情况下（例如，$v$ 是最后一个元素），跳跃次数 $m$ 约为 $\\frac{n}{k}$。这为总成本贡献了 $\\frac{n}{k}$ 次比较。\n\n2.  **线性扫描阶段**：跳跃阶段之后，我们确定一个大小最多为 $k$ 的块，如果 $v$ 存在，则它必然位于该块内。然后在此块内执行线性搜索。在最坏情况下，这需要额外的 $k-1$ 次比较。\n\n最坏情况下的总比较次数 $C(k)$ 是这两个阶段成本的总和：\n$$C(k) = \\frac{n}{k} + (k-1)$$\n为了找到最小化此成本的最优跳跃步长 $k$，我们可以将 $k$ 视为一个连续变量，并使用微积分求函数 $C(k)$ 的最小值。$C(k)$ 关于 $k$ 的一阶导数是：\n$$\\frac{dC}{dk} = -\\frac{n}{k^2} + 1$$\n将此导数设为 $0$ 以求得临界点，可得：\n$$-\\frac{n}{k^2} + 1 = 0 \\implies k^2 = n \\implies k = \\sqrt{n}$$\n此推导确定了最小化最坏情况比较次数的最优跳跃步长是 $k = \\sqrt{n}$。对于离散元素的数组，我们使用其整数部分 $k = \\lfloor \\sqrt{n} \\rfloor$。如果 $n=0$，此计算不适用；如果 $n>0$ 且 $\\lfloor \\sqrt{n} \\rfloor = 0$，则必须强制使用最小步长 $1$ 以确保搜索能向前推进。使用此最优跳跃步长的搜索，其总体时间复杂度为 $O(\\sqrt{n})$。这个跳跃步长 $k$ 将在算法的所有阶段中保持一致使用。\n\n**算法实现**\n\n搜索 $[i_{\\text{first}}, i_{\\text{last}}]$ 的过程如下。\n\n**阶段1：初步搜索 $v$ 的一个出现位置**\n首先，处理边界情况：如果数组为空 ($n=0$)，$v$ 不可能存在，因此返回 $[-1, -1]$。否则，我们计算跳跃步长 $k = \\max(1, \\lfloor \\sqrt{n} \\rfloor)$。\n\n1.  **块定位**：我们使用大小为 $k$ 的向前跳跃来找到一个可能包含 $v$ 的块。我们初始化两个指针 `prev` 和 `curr` 为 $0$。只要 $A_{\\text{curr}}  v$，我们就将 `curr` 增加 $k$，并在每次跳跃前将 `prev` 设置为 `curr` 的旧值。当 $A_{\\text{curr}} \\geq v$ 或 `curr` 超出数组边界时，此过程停止。\n2.  **线性扫描**：如果元素 $v$ 存在，它必然位于索引区间 $[\\text{prev}, \\min(\\text{curr}, n-1)]$ 内。我们在此块内执行线性扫描，以找到一个索引（称之为 `found_idx`），使得 $A_{\\text{found\\_idx}} = v$。如果扫描完成仍未找到 $v$，则该元素在数组中不存在，我们返回 $[-1, -1]$。\n\n**阶段2：寻找首次出现的位置 ($i_{\\text{first}}$)**\n如果阶段1成功，我们便拥有一个索引 `found_idx`，其中 $A_{\\text{found\\_idx}} = v$。我们现在开始搜索首次出现的位置。\n\n1.  **向左框定**：从 `found_idx` 开始，我们使用大小为 $k$ 的跳跃向左扩展。我们定义一个搜索范围 `[start_rng, end_rng]`。初始时，`end_rng` 设置为 `found_idx`。我们重复地将 `end_rng` 更新为当前位置，并将 `start_rng`向左跳跃 $k$，只要 `start_rng` 是一个有效的正索引且 $A_{\\text{start\\_rng}} = v$。这会快速建立一个保证包含 $i_{\\text{first}}$ 的区间 `[start_rng, end_rng]`。\n2.  **局部线性扫描**：然后我们从 `start_rng` 到 `end_rng` 执行一次精细的向前线性扫描。在此范围内第一个满足 $A_j = v$ 的索引 $j$ 就是所求的首次出现位置 $i_{\\text{first}}$。\n\n**阶段3：寻找末次出现的位置 ($i_{\\text{last}}$)**\n此阶段与阶段2类似，但是从 `found_idx` 向右扩展。\n\n1.  **向右框定**：从 `found_idx` 开始，我们向右扩展。初始时，`start_rng` 设置为 `found_idx`。我们重复地将 `start_rng` 更新为当前位置，并将 `end_rng` 向右跳跃 $k$，只要 `end_rng` 在数组边界内且 $A_{\\text{end\\_rng}} = v$。此过程确定了一个保证包含 $i_{\\text{last}}$ 的区间 `[start_rng, end_rng]`。\n2.  **局部线性扫描**：为了精确定位索引，我们从 `end_rng` 向 `start_rng` 执行一次向后线性扫描。遇到的第一个（从右边算起）满足 $A_j = v$ 的索引 $j$ 就是末次出现的位置 $i_{\\text{last}}$。\n\n最后，算法返回列表 $[i_{\\text{first}}, i_{\\text{last}}]$，其中包含 $v$ 的首次和末次出现的索引。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dual_jump_search(A, v):\n    \"\"\"\n    Computes the first and last occurrences of a value v in a sorted array A\n    using a dual jump-based search strategy.\n    \n    Args:\n        A (list): A sorted list of numbers in non-decreasing order.\n        v (int or float): The value to search for.\n        \n    Returns:\n        list: A list [i_first, i_last] of the first and last indices of v.\n              Returns [-1, -1] if v is not found.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return [-1, -1]\n\n    # k is chosen to minimize worst-case comparisons, derived from d/dk(n/k + k-1) = 0.\n    k = int(n**0.5)\n    if k == 0:\n        k = 1\n\n    # Phase 1: Initial Jump Search to find any occurrence of v.\n    found_idx = -1\n    \n    # 1.a: Find a block where v might be located.\n    prev = 0\n    curr = 0\n    while curr  n and A[curr]  v:\n        prev = curr\n        curr += k\n\n    # 1.b: Linear scan within the identified block.\n    block_end = min(curr, n - 1)\n    for i in range(prev, block_end + 1):\n        if A[i] == v:\n            found_idx = i\n            break\n    \n    if found_idx == -1:\n        return [-1, -1]\n\n    # Phase 2: Find the first occurrence (i_first) by expanding leftward.\n    i_first = -1\n    \n    # 2.a: Bracket the first occurrence with reverse jumps.\n    end_rng_first = found_idx\n    start_rng_first = max(0, found_idx - k)\n    \n    while start_rng_first > 0 and A[start_rng_first] == v:\n        end_rng_first = start_rng_first\n        start_rng_first = max(0, start_rng_first - k)\n\n    # 2.b: Linear scan within the bracket to find the exact first index.\n    for j in range(start_rng_first, end_rng_first + 1):\n        if A[j] == v:\n            i_first = j\n            break\n\n    # Phase 3: Find the last occurrence (i_last) by expanding rightward.\n    i_last = -1\n    \n    # 3.a: Bracket the last occurrence with forward jumps.\n    start_rng_last = found_idx\n    end_rng_last = min(n - 1, found_idx + k)\n\n    while end_rng_last  n - 1 and A[end_rng_last] == v:\n        start_rng_last = end_rng_last\n        end_rng_last = min(n - 1, end_rng_last + k)\n\n    # 3.b: Linear scan (backwards) within the bracket for the exact last index.\n    for j in range(end_rng_last, start_rng_last - 1, -1):\n        if A[j] == v:\n            i_last = j\n            break\n            \n    return [i_first, i_last]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, printing the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 2, 2, 2, 3, 4, 5], 2),\n        ([5, 5, 5, 6, 7], 5),\n        ([1, 2, 3, 9, 9, 9], 9),\n        ([1, 2, 3, 4], 6),\n        ([8], 8),\n        ([8], 9),\n        ([7, 7, 7, 7, 7, 7, 7, 7], 7),\n        ([0, 1, 1, 1, 2, 2, 4, 4, 4, 4, 5, 9, 9, 11], 4),\n        ([], 3)\n    ]\n\n    results = []\n    for A, v in test_cases:\n        result = dual_jump_search(A, v)\n        results.append(result)\n\n    # Format the final output string as per the specification.\n    # e.g., [[1,3],[0,2],[-1,-1]]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3242935"}, {"introduction": "现实世界中的数据很少以单一、扁平的列表形式存在；它们通常被组织成层次结构，例如书籍的章节、数据库的索引页等。这个练习 [@problem_id:3242865] 将跳跃搜索的应用从简单数组提升到一个更复杂的“二级索引”数据结构上。通过解决这个问题，你将学会如何将搜索算法分层应用，首先在宏观的“块”级别上进行跳跃搜索以快速定位，然后在微观的“块内”进行精确查找，这是处理大规模、结构化数据集的一项关键技能。", "problem": "考虑一个两级索引数据结构 $X$，它被定义为一个由内部序列 $X[0], X[1], \\dots, X[B-1]$ 组成的有限序列，其中每个 $X[b]$ 是一个由可比较键组成的有限序列，按非递减顺序排列，内部序列中允许存在重复项，也允许存在空的内部序列。该数据结构满足全局排序约束：对于所有块索引 $b$ 和 $b+1$，若 $X[b]$ 和 $X[b+1]$ 均非空，则 $\\max(X[b])  \\min(X[b+1])$。这使得所有内部序列的拼接结果是全局有序的。你需要为这种两级索引设计并实现一种改编自跳跃搜索的算法，该算法需遵循以下原则。\n\n- 只允许进行键的比较；不得使用哈希或辅助平衡树。\n- 外部搜索必须对每个非空块使用一个单调代表函数（例如，一个边界值）来决定哪个块可能包含查询键。\n- 在候选块内的内部搜索必须使用一种不预先假设目标位置知识的方法，并且该方法必须在有序数组上是渐进高效的。\n- 步长和边界必须从第一性原理推导得出，而不是通过猜测，并且必须通过在有序结构的约束下最小化最坏情况下的比较次数来证明其合理性。\n\n形式上，给定一个查询键 $x$，你的算法必须：\n- 通过对非空块序列使用每个块的单调代表值执行跳跃式搜索，来确定一个候选块索引 $b^\\*$。如果没有任何候选块可能包含 $x$，则报告未找到 $x$。\n- 在 $X[b^\\*]$ 内部搜索，找到满足 $X[b^\\*][j] = x$ 的最左侧位置 $j$。如果存在这样的位置，则返回序对 $[b^\\*, j]$；否则，报告未找到 $x$。\n\n你的程序必须实现此算法，并在以下测试套件上运行。每个测试用例包含一个特定的两级索引和一个查询键 $x$。\n\n定义三个数据集：\n- $\\mathcal{D}_A = [[1, 3, 5, 5], [8, 9, 10], [14, 14, 15, 16], [20, 21]]$。\n- $\\mathcal{D}_B = [[-10, -5], [0], [2, 4, 6, 8, 10], [13, 17, 19], [23]]$。\n- $\\mathcal{D}_C = [[], [1, 2, 3], [5], [7, 7, 7, 7], [9, 12]]$。\n\n在以下有序的测试用例列表上运行该算法：\n- $(\\mathcal{D}_A, 14)$。\n- $(\\mathcal{D}_A, 1)$。\n- $(\\mathcal{D}_A, 21)$。\n- $(\\mathcal{D}_A, 7)$。\n- $(\\mathcal{D}_A, 0)$。\n- $(\\mathcal{D}_A, 100)$。\n- $(\\mathcal{D}_B, 17)$。\n- $(\\mathcal{D}_C, 7)$。\n- $(\\mathcal{D}_C, 4)$。\n- $(\\mathcal{D}_B, -10)$。\n\n对于每个测试用例，如果找到键，输出必须是序对 $[b^\\*, j]$（两个条目均为整数）；如果未找到键，则输出为整数 $-1$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如, $[r_1, r_2, r_3]$），结果的顺序与上述测试用例的顺序相同。不涉及物理单位、角度或百分比；所有输出要么是整数，要么是整数列表。", "solution": "该问题要求为一种表示为 $X$ 的两级索引数据结构设计并实现一个专门的搜索算法。该结构由 $B$ 个内部序列 $X[0], \\dots, X[B-1]$ 组成。每个内部序列都按非递减顺序排序，并且对于任何相邻的非空块 $X[b]$ 和 $X[b+1]$，全局排序约束 $\\max(X[b])  \\min(X[b+1])$ 确保了所有元素的拼接是全局有序的。任务是通过改编跳跃搜索的原理来找到查询键 $x$ 的最左侧出现位置。\n\n解决方案是一个两阶段的搜索过程。第一阶段是外部搜索，用于识别可能包含键 $x$ 的单个候选块。第二阶段是内部搜索，用于探查这个特定块以定位该键。\n\n**外部搜索：块识别**\n\n外部搜索作用于非空块的有序序列。假设有 $N$ 个这样的块。问题要求使用每个块的单调代表值进行跳跃式搜索。一个有效且自然的选择是使用每个非空块的第一个元素作为代表值，即 $R_i = \\min(X[b_i])$，其中 $b_i$ 是第 $i$ 个非空块的原始索引。全局排序约束保证了这个代表值序列是严格递增的，即对于所有 $i \\in [0, N-2]$ 都有 $R_i  R_{i+1}$。\n\n核心原理是找到最优的跳跃步长 $k$，以最小化最坏情况下的比较次数。该搜索包括两个阶段：跳跃和线性扫描。\n1.  **跳跃阶段：** 我们以步长 $k$ 跳跃遍历代表值。找到包含目标的区间所需的最大跳跃次数为 $\\lceil N/k \\rceil - 1$。\n2.  **线性扫描阶段：** 一旦跳跃超过了目标的潜在位置（即，我们找到了一个索引 $j$ 使得 $R_j > x$），我们必须在前一个大小为 $k-1$ 的区间内执行线性扫描，以精确定位正确的块。\n\n因此，外部搜索的总比较次数是步长 $k$ 的函数，由 $C(k) \\approx N/k + k - 1$ 给出。为了最小化这个成本，我们将 $k$ 视为一个连续变量，并通过将其导数设为零来求最小值：\n$$\n\\frac{dC}{dk} = -\\frac{N}{k^2} + 1 = 0\n$$\n这得出 $k^2 = N$，因此最优步长是 $k = \\sqrt{N}$。对于离散数量的块，我们使用其整数部分，即 $k = \\lfloor \\sqrt{N} \\rfloor$。\n\n外部搜索算法如下：\n1.  构建一个包含非空块及其原始索引的列表。设其大小为 $N$。如果 $N=0$，则无法找到该键。\n2.  处理边界情况：如果查询键 $x$ 小于第一个非空块的第一个元素，则 $x$ 不存在。\n3.  使用步长 $k = \\lfloor \\sqrt{N} \\rfloor$，在非空块列表中跳跃，直到找到一个索引 `curr`，使得 `curr` 处的代表值大于 $x$。前一个访问的索引是 `prev`。候选块必须位于索引范围 `[prev, curr - 1]` 内。\n4.  从 `curr - 1` 向下到 `prev` 执行反向线性扫描，找到其代表值小于或等于 $x$ 的最后一个块。这个块 $X[b^\\*]$ 就是唯一可能包含 $x$ 的候选块。\n\n**内部搜索：键定位**\n\n一旦确定了候选块 $X[b^\\*]$，我们必须在其内部进行搜索。问题规定，该搜索必须在有序数据上是渐进高效的，并且不依赖于对键位置的先验知识。二分搜索完美符合这些标准。\n\n为了满足找到满足 $X[b^\\*][j] = x$ 的*最左侧*位置 $j$ 的要求，需要对标准二分搜索进行修改。当在索引 `mid` 处找到一个等于 $x$ 的元素时，将该索引存储为潜在答案，并随后将搜索范围缩小到当前范围的左半部分（即，从头到 `mid - 1`）。这确保了如果 $x$ 存在多个，搜索将继续进行直到找到第一个。\n\n**算法综合**\n\n完整的算法集成了这两个阶段：\n1.  提取非空块序列及其原始索引。设该序列的大小为 $N$。如果 $N=0$，则终止并报告“未找到”。\n2.  如果查询键 $x$ 小于整个数据结构中的最小元素，则报告“未找到”。\n3.  在 $N$ 个块的代表值上执行步长为 $k = \\lfloor\\sqrt{N}\\rfloor$ 的跳跃搜索，以识别候选块 $X[b^\\*]$。如果没有块可以包含该键（如果 $x$ 落在块之间的间隙中，就会发生这种情况），则后续的内部搜索将正确地失败。\n4.  在 $X[b^\\*]$ 内执行寻找最左侧位置的二分搜索来查找 $x$。\n5.  如果内部搜索在局部索引 $j$ 处找到该键，则返回序对 $[b^\\*, j]$。\n6.  如果内部搜索未找到该键，则报告“未找到”。这个结果是确定的，因为 $X[b^\\*]$ 是 $x$ 唯一可能存在的位置。", "answer": "```python\nimport numpy as np\n\ndef search_in_two_level_index(data_structure, query_key):\n    \"\"\"\n    Performs a two-level search on the described data structure.\n\n    Args:\n        data_structure (list of lists): The two-level index X.\n        query_key (int or float): The key to search for.\n\n    Returns:\n        list or int: [block_index, inner_index] if found, otherwise -1.\n    \"\"\"\n    # Step 1: Filter to get non-empty blocks and their original indices.\n    non_empty_info = []\n    for i, block in enumerate(data_structure):\n        if block:\n            non_empty_info.append((i, block))\n\n    if not non_empty_info:\n        return -1\n\n    num_non_empty = len(non_empty_info)\n\n    # Step 2: Outer search (Jump Search) to find the candidate block.\n    # Check if the key is smaller than the very first element.\n    if query_key  non_empty_info[0][1][0]:\n        return -1\n\n    # Derive step size from first principles.\n    step_size = int(np.sqrt(num_non_empty))\n    if step_size == 0: # This case occurs if num_non_empty is 1.\n        step_size = 1\n\n    prev_idx = 0\n    curr_idx = 0\n    # Jumping phase.\n    while curr_idx  num_non_empty and non_empty_info[curr_idx][1][0] = query_key:\n        prev_idx = curr_idx\n        curr_idx += step_size\n\n    # Linear scanning phase within the identified interval.\n    candidate_block_info = None\n    # The range to scan in `non_empty_info` is [prev_idx, min(curr_idx, num_non_empty)].\n    # We scan backwards to find the last block whose first element is = query_key.\n    for i in range(min(curr_idx, num_non_empty) - 1, prev_idx - 1, -1):\n        if non_empty_info[i][1][0] = query_key:\n            candidate_block_info = non_empty_info[i]\n            break\n    \n    if candidate_block_info is None:\n        return -1\n\n    original_block_idx, block_data = candidate_block_info\n\n    # A quick check: if the query key is larger than the last element of the candidate block, it cannot be in it.\n    if query_key > block_data[-1]:\n        return -1\n\n    # Step 3: Inner search (Leftmost-finding Binary Search).\n    low = 0\n    high = len(block_data) - 1\n    found_idx = -1\n\n    while low = high:\n        mid = low + (high - low) // 2\n        \n        if block_data[mid] == query_key:\n            found_idx = mid\n            high = mid - 1  # Continue searching left for the first occurrence.\n        elif block_data[mid]  query_key:\n            low = mid + 1\n        else: # block_data[mid] > query_key\n            high = mid - 1\n            \n    if found_idx != -1:\n        return [original_block_idx, found_idx]\n    else:\n        return -1\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the search algorithm on them, producing\n    the final formatted output.\n    \"\"\"\n    d_a = [[1, 3, 5, 5], [8, 9, 10], [14, 14, 15, 16], [20, 21]]\n    d_b = [[-10, -5], [0], [2, 4, 6, 8, 10], [13, 17, 19], [23]]\n    d_c = [[], [1, 2, 3], [5], [7, 7, 7, 7], [9, 12]]\n\n    test_cases = [\n        (d_a, 14),\n        (d_a, 1),\n        (d_a, 21),\n        (d_a, 7),\n        (d_a, 0),\n        (d_a, 100),\n        (d_b, 17),\n        (d_c, 7),\n        (d_c, 4),\n        (d_b, -10),\n    ]\n\n    results = []\n    for data_structure, query_key in test_cases:\n        result = search_in_two_level_index(data_structure, query_key)\n        if isinstance(result, list):\n            # Format list [b, j] as a string \"[b,j]\" without spaces.\n            results.append(f\"[{result[0]},{result[1]}]\")\n        else:\n            results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3242865"}, {"introduction": "指数搜索等算法的威力并不仅限于处理有限的、已知的数组。这个思想实验 [@problem_id:3242857] 将你带入一个更抽象的领域：在一个概念上无限的序列中进行搜索。该问题要求你从一个已知条件不满足的点（$P(S) = \\text{false}$）出发，反向应用指数搜索来寻找最后一个满足条件的点。这不仅能检验你对算法核心逻辑的深刻理解，还能训练你根据已有信息灵活调整搜索策略的能力。", "problem": "考虑一个索引为 $0, 1, 2, \\dots$ 的概念上无限的可索引序列，在该序列中，你只能对索引 $i \\in \\mathbb{N}$ 查询一个单调布尔谓词 $P(i)$。假设存在一个未知的阈值索引 $t \\in \\mathbb{N}$，使得对于所有 $i \\leq t$，$P(i)$ 为 $\\text{true}$，而对于所有 $i  t$，$P(i)$ 为 $\\text{false}$。给定一个索引 $S \\in \\mathbb{N}$，其满足 $P(S) = \\text{false}$，但你不知道 $t$。目标是使用尽可能少的谓词求值来找到最后一个使得 $P(t) = \\text{true}$ 的索引 $t$。\n\n从单调性和基于比较的搜索的基本定义出发，选择一个选项，该选项正确地说明了如何从 $S$ 开始反向使用指数搜索来界定 $t$ 的范围，然后以一个正确的、时间复杂度渐近最小的搜索来最终找到 $t$。令 $D = S - t$ 表示从起始的 false 索引 $S$ 到目标 $t$ 的（未知）距离。\n\nA. 从 $S$ 开始，探测 $P(S-1)$、$P(S-2)$、$P(S-4)$、$P(S-8)$、$\\dots$（反向偏移量加倍），直到找到第一个满足 $P(j) = \\text{true}$ 的索引 $j = S - 2^{m}$，其中 $m \\geq 0$ 是最小的。令前一个探测点的索引为 $j' = S - 2^{m-1}$（约定当 $m = 0$ 时，$j' = S$）。根据单调性，$P(j) = \\text{true}$ 且 $P(j') = \\text{false}$，这将 $t$ 界定在 $[j, j'-1]$ 区间内。在 $[j, j'-1]$ 上执行标准二分搜索以找到 $t$。谓词求值总次数为 $\\mathcal{O}(\\log D)$。\n\nB. 从 $S$ 开始，探测 $P(S-1)$、$P(S-2)$、$P(S-3)$、$\\dots$（单位步长反向移动），直到到达第一个满足 $P(k) = \\text{true}$ 的索引 $k$，然后在 $[k, S-1]$ 上执行二分搜索以找到 $t$。谓词求值总次数为线性阶段的 $\\mathcal{O}(D)$ 加上二分搜索阶段的 $\\mathcal{O}(\\log D)$。\n\nC. 忽略给定的 $S$，而是从索引 $0$ 开始执行前向指数搜索：探测 $P(1)$、$P(2)$、$P(4)$、$P(8)$、$\\dots$，直到找到第一个满足 $P(u) = \\text{false}$ 的 false 索引 $u = 2^{q}$，其中 $q$ 是最小的，这将 $t$ 界定在 $[2^{q-1}, 2^{q}-1]$ 区间内。然后在该区间上执行二分搜索以找到 $t$。谓词求值总次数为 $\\mathcal{O}(\\log t)$。\n\nD. 从 $S$ 开始，以偏移量 $1, 2, 4, 8, \\dots$ 反向探测，直到遇到第一个严格小于 $S$ 的 false 索引（即，找到满足 $P(j) = \\text{false}$ 的 $j = S - 2^{m}$，其中 $m \\geq 1$ 是最小的），然后在 $[j, S]$ 上执行二分搜索以找到 $t$。谓词求值总次数为 $\\mathcal{O}(\\log D)$。", "solution": "该问题要求我们从一个已知谓词 $P(S)$ 为 `false` 的点 $S$ 出发，在一个概念上无限的、具有单调性的序列中，寻找最后一个满足 $P(t)$ 为 `true` 的索引 $t$。该序列的单调性定义为：存在一个阈值 $t$，使得当 $i \\le t$ 时 $P(i)$ 为真，当 $i > t$ 时 $P(i)$ 为假。目标是利用给定的信息 $S$ 设计一个最高效的搜索策略，其中效率由谓词求值的次数衡量。\n\n**策略分析**\n\n最优策略必须利用所有已知信息来最小化搜索范围。我们已知 $P(S) = \\text{false}$，并且根据单调性，必然有 $t  S$。问题是寻找 $t$ 的位置，即从 $S$ 向左（索引减小的方向）遇到的 `true`/`false` 边界。搜索的未知距离为 $D = S - t$。一个高效的算法其复杂度应该与 $\\log D$ 相关，而不是与 $t$ 或 $S$ 的绝对大小相关。\n\n正确的算法范式是“指数搜索 + 二分搜索”的结合：\n1.  **范围界定（指数搜索）**：从已知点 $S$ 开始，以指数级增长的步长向左探测，即检查 $S-2^0, S-2^1, S-2^2, \\dots$。由于我们从一个 `false` 区域开始，这个阶段的目标是尽快找到一个 `true` 值，从而“跨越”边界 $t$。一旦在某个索引 $j = S - 2^m$ 处探测到 $P(j) = \\text{true}$，我们便成功地界定了 $t$ 的范围。因为这是我们找到的第一个 `true` 值，所以前一个探测点 $j' = S - 2^{m-1}$ 必然满足 $P(j') = \\text{false}$。因此，目标索引 $t$ 必定位于区间 $[j, j'-1]$ 内。此阶段的探测次数与 $m$ 成正比，而 $m$ 满足 $2^m \\approx D$，故其复杂度为 $O(\\log D)$。\n2.  **精确定位（二分搜索）**：在已确定的有限区间 $[j, j'-1]$ 内，我们可以使用标准的二分搜索来精确找到 $t$。该区间的大小约为 $2^{m-1}$，因此二分搜索的复杂度为 $O(\\log(2^{m-1})) = O(m) = O(\\log D)$。\n\n整个算法的总复杂度为 $O(\\log D) + O(\\log D) = O(\\log D)$，这是渐近最优的。\n\n**选项评估**\n\n*   **A**: 此选项完美地描述了上述的反向指数搜索和二分搜索策略。它从 $S$ 开始反向指数探测以寻找第一个 `true` 值，正确地确定了包含 $t$ 的边界 $[j, j'-1]$，并在此区间内使用二分搜索。其复杂度分析 $\\mathcal{O}(\\log D)$ 也是正确的。因此，这是正确的答案。\n\n*   **B**: 此选项建议使用单位步长的线性扫描。这种方法虽然能找到 $t$，但其成本为 $\\mathcal{O}(D)$，在 $D$ 很大时效率低下，不符合“尽可能少的谓词求值”的要求。\n\n*   **C**: 此选项建议忽略给定的信息 $S$，从头开始进行标准的正向指数搜索。其复杂度为 $\\mathcal{O}(\\log t)$。虽然在没有额外信息时这是标准做法，但它浪费了宝贵的已知条件 $S$。当 $t$ 很大而 $D = S - t$ 很小时，$\\mathcal{O}(\\log t)$ 远劣于 $\\mathcal{O}(\\log D)$。因此，这不是最优策略。\n\n*   **D**: 此选项的逻辑是错误的。它建议从 `false` 点 $S$ 出发，反向搜索另一个 `false` 点。这并不能帮助我们界定 `true`/`false` 的边界。为了确定边界 $t$，我们必须找到一个与起始点 $S$ 的谓词值相反的点，即一个 `true` 点。\n\n综上所述，只有选项 A 提出了一个逻辑正确且渐近最优的算法。", "answer": "$$\\boxed{A}$$", "id": "3242857"}]}