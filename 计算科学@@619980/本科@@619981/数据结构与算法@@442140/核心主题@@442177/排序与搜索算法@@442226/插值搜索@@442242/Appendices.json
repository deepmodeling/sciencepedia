{"hands_on_practices": [{"introduction": "插值查找的性能高度依赖于数据的分布。此练习将引导您在一个非均匀分布的数据集 $A[i] = i^2$ 上，逐步应用插值公式进行计算。通过亲手追踪算法在多项式增长数据上的执行过程，您可以直观地理解其与理想均匀分布情况的偏差，并建立对其真实世界行为的深刻认识。[@problem_id:3241452]", "problem": "考虑一个长度为 $n$ 的已排序数组 $A$，其元素定义为 $A[i] = i^{2}$，其中整数索引 $i \\in \\{0, 1, \\dots, n-1\\}$。设 $n = 1001$。你将使用以下算法规范，对键值 $x = 900^{2}$ 执行插值搜索。\n\n初始化 $low = 0$ 和 $high = n - 1$。当 $low \\leq high$ 时，计算探测索引\n$$\np = low + \\left\\lfloor \\frac{x - A[low]}{A[high] - A[low]} \\cdot (high - low) \\right\\rfloor,\n$$\n约定如果 $A[low] = A[high]$，则 $p = low$。计算出 $p$ 后，访问 $A[p]$ 并与 $x$ 进行比较：\n- 如果 $A[p] = x$，则搜索成功并终止。\n- 如果 $A[p] < x$，则设置 $low = p + 1$ 并继续。\n- 如果 $A[p] > x$，则设置 $high = p - 1$ 并继续。\n\n将单次“探测”定义为一次循环迭代，在其中计算索引 $p$ 并精确访问数组值 $A[p]$ 一次。不要将任何其他操作计为探测。从指定的初始条件开始，确定此插值搜索在成功找到 $A$ 中的 $x$ 之前执行的探测确切次数。最终答案必须是单个整数值。无需进行四舍五入。", "solution": "基本原理是在已排序数组上进行插值搜索的定义，该方法使用端点之间的线性插值来估计目标键值的可能位置。具体来说，在任何一次具有当前边界 $low$ 和 $high$ 的迭代中，探测索引 $p$ 由以下公式定义：\n$$\np = low + \\left\\lfloor \\frac{x - A[low]}{A[high] - A[low]} \\cdot (high - low) \\right\\rfloor,\n$$\n且更新规则源自 $A[p]$ 与 $x$ 的比较。\n\n在本例中，数组对所有 $i$ 满足 $A[i] = i^{2}$，因此在任何一次边界为 $low = L$ 和 $high = H$ 的迭代中，该公式可以进行代数简化。记 $x = k^{2}$，其中 $k = 900$。那么\n$$\n\\frac{x - A[L]}{A[H] - A[L]} \\cdot (H - L)\n= \\frac{k^{2} - L^{2}}{H^{2} - L^{2}} \\cdot (H - L)\n= \\frac{(k - L)(k + L)}{(H - L)(H + L)} \\cdot (H - L)\n= \\frac{(k - L)(k + L)}{H + L}.\n$$\n因此，\n$$\np = L + \\left\\lfloor \\frac{(k - L)(k + L)}{H + L} \\right\\rfloor.\n$$\n\n我们现在逐步执行搜索，将每次计算出的 $p$ 和对 $A[p]$ 的单次访问计为一次探测。\n\n初始条件为 $n = 1001$，所以 $low = 0$，$high = 1000$，且 $x = 900^{2} = 810000$。\n\n- 探测 1：$L = 0$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 0 + \\left\\lfloor \\frac{(900 - 0)(900 + 0)}{1000 + 0} \\right\\rfloor\n    = \\left\\lfloor \\frac{810000}{1000} \\right\\rfloor\n    = 810.\n  $$\n  访问 $A[810] = 810^{2} = 656100$。因为 $656100  810000$，设置 $low = p + 1 = 811$ 并保持 $high = 1000$。\n\n- 探测 2：$L = 811$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 811 + \\left\\lfloor \\frac{(900 - 811)(900 + 811)}{1000 + 811} \\right\\rfloor\n    = 811 + \\left\\lfloor \\frac{89 \\cdot 1711}{1811} \\right\\rfloor.\n  $$\n  计算 $89 \\cdot 1711 = 152279$。然后 $\\left\\lfloor \\frac{152279}{1811} \\right\\rfloor = 84$，因为 $1811 \\cdot 84 = 152124$ 且 $1811 \\cdot 85 = 153935  152279$。因此 $p = 811 + 84 = 895$。\n  访问 $A[895] = 895^{2} = 801025$。因为 $801025  810000$，设置 $low = p + 1 = 896$ 并保持 $high = 1000$。\n\n- 探测 3：$L = 896$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 896 + \\left\\lfloor \\frac{(900 - 896)(900 + 896)}{1000 + 896} \\right\\rfloor\n    = 896 + \\left\\lfloor \\frac{4 \\cdot 1796}{1896} \\right\\rfloor\n    = 896 + \\left\\lfloor \\frac{7184}{1896} \\right\\rfloor.\n  $$\n  因为 $1896 \\cdot 3 = 5688$ 且 $1896 \\cdot 4 = 7584  7184$，我们得到 $\\left\\lfloor \\frac{7184}{1896} \\right\\rfloor = 3$，所以 $p = 896 + 3 = 899$。\n  访问 $A[899] = 899^{2} = 808201$。因为 $808201  810000$，设置 $low = p + 1 = 900$ 并保持 $high = 1000$。\n\n- 探测 4：$L = 900$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 900 + \\left\\lfloor \\frac{(900 - 900)(900 + 900)}{1000 + 900} \\right\\rfloor\n    = 900 + \\left\\lfloor \\frac{0 \\cdot 1800}{1900} \\right\\rfloor\n    = 900.\n  $$\n  访问 $A[900] = 900^{2} = 810000$。因为 $A[900] = x$，搜索成功并终止。\n\n我们在找到键值之前，恰好执行了 $4$ 次探测。根据问题的定义，没有其他操作被计为探测。因此，探测的确切次数是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3241452"}, {"introduction": "在看到插值查找的性能会受到影响后，一个自然的问题是：它到底能变得多糟？这个思想实验将挑战您逆向工程一个数据集，迫使插值查找做出最差的首次猜测。通过构建这种最坏情况，您将深刻理解该算法的内在线性假设及其在何种条件下会彻底失效，从而掌握其理论性能的边界。[@problem_id:3241327]", "problem": "考虑一个由 $n$ 个不同实数组成的严格递增有序数组 $A[1], A[2], \\ldots, A[n]$，其中 $n \\geq 3$。插值搜索通过在端点 $A[1]$ 和 $A[n]$ 之间对查询键 $x$ 的位置进行线性插值，然后取整到整数索引，来估计 $x$ 的位置。\n\n仅利用在有序表上两端点之间进行线性插值的原理，推导当搜索区间为整个数组 $[1, n]$ 时，插值搜索的第一个探测索引 $p$ 的表达式。\n\n然后，设计一个具体的数组族 $A$（如有必要可参数化），并指定一个特定的 $x$ 值，使得第一个探测索引 $p$ 可证明地是最差的下一个选择，即它落在离真实索引 $k$ (其中 $A[k] = x$) 最远的索引上。你的构造必须满足 $A[1] = 0$，$A[n] = 1$，且对于所有 $i \\in \\{2, \\ldots, n-1\\}$ 都有 $A[i] \\in (0, 1)$，并满足 $A[1]  A[2]  \\cdots  A[n]$。请严格证明，在这些约束条件下，由端点插值产生的第一个探测索引 $p$ 是离 $k$ 可能的最远索引。\n\n最后，计算在这种情况下可以实现的最大可能绝对索引误差 $|p - k|$，将其表示为 $n$ 的函数。请用一个封闭形式的解析表达式来表示你的最终答案。不需要进行取整。", "solution": "### 第 1 部分：第一个探测索引的推导\n插值搜索的原理是将数据建模为位于一条直线上。给定一个有序数组 `A`，我们在（索引，值）平面上考虑点 `(1, A[1])` 和 `(n, A[n])`。通过这两点的直线方程为：\n$$ V(i) = A[1] + \\frac{A[n] - A[1]}{n - 1}(i - 1) $$\n为了找到给定值 `x` 的估计索引，我们令 `V(i) = x` 并解出 `i`。设索引的连续（实值）估计值为 `pos`。\n$$ x = A[1] + \\frac{A[n] - A[1]}{n - 1}(\\text{pos} - 1) $$\n重新整理以解出 `pos`：\n$$ x - A[1] = \\frac{A[n] - A[1]}{n - 1}(\\text{pos} - 1) $$\n$$ \\text{pos} - 1 = (x - A[1]) \\frac{n - 1}{A[n] - A[1]} $$\n$$ \\text{pos} = 1 + (n - 1) \\frac{x - A[1]}{A[n] - A[1]} $$\n整数探测索引 `p` 是通过对此连续估计值取下整得到的，这在许多编程语言中对应于标准整数算术。\n$$ p = \\left\\lfloor 1 + (n - 1) \\frac{x - A[1]}{A[n] - A[1]} \\right\\rfloor $$\n由于 `1` 是整数，我们可以将其写为：\n$$ p = 1 + \\left\\lfloor (n - 1) \\frac{x - A[1]}{A[n] - A[1]} \\right\\rfloor $$\n这就是第一个探测索引的通用表达式。\n\n### 第 2 部分：最坏情况场景的构造\n我们有约束条件 `A[1] = 0` 和 `A[n] = 1`。将它们代入 `p` 的公式中：\n$$ p = 1 + \\left\\lfloor (n - 1) \\frac{x - 0}{1 - 0} \\right\\rfloor = 1 + \\lfloor (n - 1)x \\rfloor $$\n我们在数组中搜索一个存在的值 `x`，因此对于某个索引 `k \\in \\{1, 2, \\ldots, n\\}` 有 `x = A[k]`。因此，探测索引为：\n$$ p = 1 + \\lfloor (n - 1)A[k] \\rfloor $$\n我们的目标是构造一个数组 `A` 并选择一个 `k`，以最大化绝对索引误差 `|p - k| = |(1 + \\lfloor (n - 1)A[k] \\rfloor) - k|`。\n\n`p` 的值取决于 `n` 和 `A[k]`，但值得注意的是，它不依赖于 `A` 的其他元素。对 `A` 的约束是它必须严格递增，且 `A[1]=0` 和 `A[n]=1`。对于任何 `k \\in \\{2, \\ldots, n-1\\}` 的选择和任何值 `v \\in (0,1)`，都可以构造一个有效的数组 `A` 使得 `A[k] = v`。这是因为我们总可以在区间 `(0, v)` 中放入所需的 `k-2` 个点，在区间 `(v, 1)` 中放入 `n-k-1` 个点。\n\n我们通过考虑 `k \\in \\{2, \\ldots, n-1\\}`（因为 `k=1` 给出 `x=0`, `p=1`, 误差为 `0`）和 `A[k]` 的可用选择来分析误差 `|p - k|`。\n\n为了最大化 `|p - k|`，我们必须使 `p` 和 `k` 尽可能地相差大。这表明应选择其中一个接近其最小值，另一个接近其最大值。索引 `k` 的范围可以从 `2` 到 `n-1`。探测索引 `p = 1 + \\lfloor (n-1)A[k] \\rfloor` 的范围可以从 `1` 到 `n-1`，因为对于 `k \\in \\{2, \\ldots, n-1\\}` 有 `0  A[k]  1`，这意味着 `0  (n-1)A[k]  n-1`，所以 `0 \\le \\lfloor(n-1)A[k]\\rfloor \\le n-2`。\n\n**情况 1：`k` 大，`p` 小。**\n我们选择 `k` 为其在搜索范围内的最大可能值，即 `k = n-1`。为了最大化误差 `|p - (n-1)|`，我们应该使 `p` 尽可能小。`p` 的最小可能值为 `1`。\n要使 `p = 1`，我们需要 `\\lfloor (n-1)A[n-1] \\rfloor = 0`。\n这个不等式在 `0 \\le (n-1)A[n-1]  1` 时成立，可以简化为 `0 \\le A[n-1]  \\frac{1}{n-1}`。由于 `A` 必须严格递增且 `A[1]=0`，我们必须有 `A[n-1] > 0`。\n所以，如果我们选择 `A[n-1]` 为 `(0, \\frac{1}{n-1})` 中的任何值，探测索引将为 `p=1`。\n让我们搜索 `x = A[n-1]`。真实索引是 `k=n-1`。探测索引是 `p=1`。\n绝对误差是 `|p - k| = |1 - (n-1)| = n-2`。\n\n**情况 2：`k` 小，`p` 大。**\n我们选择 `k` 为其最小可能值，即 `k = 2`。为了最大化误差 `|p - 2|`，我们应该使 `p` 尽可能大。`\\lfloor (n-1)A[2] \\rfloor` 的最大可能值是 `n-2`，因为 `A[2]  A[n] = 1`。\n要使 `\\lfloor (n-1)A[2] \\rfloor = n-2`，我们需要 `n-2 \\le (n-1)A[2]  n-1`，这意味着 `\\frac{n-2}{n-1} \\le A[2]  1`。\n这是 `A[2]` 的一个有效范围。如果我们在此范围内选择 `A[2]`，探测索引将为 `p = 1 + (n-2) = n-1`。让我们搜索 `x = A[2]`。真实索引是 `k=2`。探测索引是 `p=n-1`。\n绝对误差是 `|p - k| = |(n-1) - 2| = n-3`。\n\n比较这两种情况，最大误差是 `n-2`，因为 `n \\geq 3` 意味着 `n-2 \\ge n-3`。\n\n为了严格证明这是最坏情况，我们构造一个特定的数组族。\n设 `n \\ge 3`。数组 `A` 定义如下：\n- `A[1] = 0`\n- `A[n] = 1`\n- `A[n-1] = \\frac{1}{2(n-1)}`。这满足 `0  A[n-1]  \\frac{1}{n-1}`。\n- 对于 `i \\in \\{2, \\ldots, n-2\\}`，通过线性间隔定义 `A[i]`：`A[i] = \\frac{i-1}{n-2} A[n-1] = \\frac{i-1}{n-2} \\cdot \\frac{1}{2(n-1)}`。\n\n这个构造是有效的，因为 `0 = A[1]  A[2]  \\cdots  A[n-1]  A[n]=1`。\n具体来说，`A[2] = \\frac{1}{(n-2)2(n-1)} > 0 = A[1]`。序列 `A[2], \\ldots, A[n-1]` 是严格递增的。并且 `A[n-1] = \\frac{1}{2(n-1)}  1 = A[n]`。\n\n现在，令搜索键为 `x = A[n-1] = \\frac{1}{2(n-1)}`。\n真实索引是 `k = n-1`。\n探测索引计算如下：\n$$ p = 1 + \\left\\lfloor (n-1)x \\right\\rfloor = 1 + \\left\\lfloor (n-1) \\cdot \\frac{1}{2(n-1)} \\right\\rfloor = 1 + \\left\\lfloor \\frac{1}{2} \\right\\rfloor = 1 + 0 = 1 $$\n探测点落在索引 `1` 上。\n绝对索引误差为 `|p - k| = |1 - (n-1)| = n-2`。\n这个构造表明 `n-2` 的误差是可以实现的。我们的分析表明，在问题的约束条件下，这是可能的最大误差。\n\n### 第 3 部分：最大可能绝对索引误差\n如上文推导和证明，当真实键位于索引 `k=n-1` 且其值很小，导致探测点落在索引 `p=1` 时，达到最大可能绝对索引误差 `|p - k|`。这个最大误差是 `n` 的函数。\n$$ \\text{最大误差} = n-2 $$", "answer": "$$\\boxed{n-2}$$", "id": "3241327"}, {"introduction": "掌握了插值查找的潜在缺陷后，我们便可以着手设计一个更优的解决方案。本实践要求您设计一个“智能”的自适应搜索算法，它能监控自身性能，并在插值效率低下时动态切换到更稳健的二分查找。这是一个关于算法设计的综合性练习，旨在展示如何结合不同方法的优点，构建出既高效又可靠的实用系统。[@problem_id:3241345]", "problem": "您需要设计并实现一个在有序数组上运行的自调整搜索算法。该算法以基于插值的探测开始，并在观测到进展持续不佳时动态切换到二分搜索。该算法必须作用于一个按非递减顺序排序的实数或整数值数组，并且必须返回给定目标值出现的索引，如果目标不存在，则返回 $-1$。程序必须是独立完整的，并且无需任何输入即可运行。\n\n设计必须基于基本定义和经过充分检验的事实：\n\n1. 一个长度为 $n$ 的有序数组 $A$ 满足对于所有 $0 \\le i \\le j \\le n-1$，都有 $A[i] \\le A[j]$。\n2. 二分搜索维护一个不变子区间 $[l,r]$，并且在每次探测时，将剩余的区间长度 $L_t = r - l + 1$ 减少约一半。\n3. 基于插值的探测依赖于关于索引到值的单调映射 $x \\mapsto A[x]$ 的线性模型假设，当值在索引范围内近似均匀分布时，这个假设是合理的。它维护不变量 $A[l] \\le \\text{key} \\le A[r]$，并通过估计关键字相对于 $A[l]$ 和 $A[r]$ 的位置来选择 $[l,r]$ 内的探测位置。\n\n该算法必须定量地监控其自身进展。将时间 $t$ 的区间长度定义为 $L_t = r_t - l_t + 1$。在每次插值探测及对 $[l_{t+1}, r_{t+1}]$ 的相应更新后，定义区间缩减率\n$$\n\\rho_t = \\frac{L_t - L_{t+1}}{L_t}。\n$$\n使用固定的窗口大小 $w$ 和阈值 $\\tau$，并计算最后 $w$ 个观测到的 $\\rho_t$ 值的移动平均值。如果该移动平均值低于 $\\tau$（表示每次探测的缩减效果持续不佳），则立即切换到二分搜索来处理剩余的搜索范围。\n\n算法要求和边界情况处理：\n\n- 算法必须维护不变子区间 $[l,r]$，并在每次于选定索引 $i$ 读取并比较 $A[i]$ 以指导搜索时，计为一次探测。为计算估计值而访问 $A[l]$ 和 $A[r]$ 本身不计为一次探测，除非在这些索引处也与目标值进行了比较。\n- 如果在不变子区间内的任何时刻，分母 $A[r] - A[l]$ 变为 $0$，则表示数组在 $[l,r]$ 上的值是恒定的。在这种情况下，应直接切换到在 $[l,r]$ 上进行二分搜索，以避免未定义的插值，并继续探测直至终止。\n- 如果目标关键字超出了当前的不变边界（即 $\\text{key}  A[l]$ 或 $\\text{key}  A[r]$），则终止并返回 $-1$，该情况下的探测次数为零。\n- 当目标多次出现时，返回其出现范围内的任何一个有效索引都是可接受的。\n- 程序必须为每个测试用例报告三个输出：找到的索引 $i$（如果未找到则为 $-1$），探测总数 $p$，以及一个布尔值 $b$，指示是否在任何时候使用了二分搜索（如果切换或直接使用了则为 $\\text{True}$，否则为 $\\text{False}$）。\n\n测试套件和参数：\n\n所有用例均使用相同的阈值和窗口：$\\tau = 0.3$ 和 $w = 4$。对于每个用例，按如下方式定义有序数组 $A$ 和目标关键字。\n\n- 情况1（均匀分布，理想情况）：$A = \\{0,1,2,\\dots,999\\}$ 且 $\\text{key} = 750$。\n- 情况2（非线性间距，偏斜映射）：$A = \\{i^3 : i \\in \\{0,1,2,\\dots,199\\}\\}$ 且 $\\text{key} = 729$。\n- 情况3（大量重复导致局部平坦区域）：$A$ 包含1000个5，后接序列 $\\{6,7,\\dots,105\\}$，且 $\\text{key} = 5$。\n- 情况4（目标缺失的边界条件）：$A = \\{0,1,2,\\dots,9999\\}$ 且 $\\text{key} = 10001$。\n- 情况5（极度偏斜增长，近似指数）：$A = \\{\\lfloor 10^{i/100} \\rfloor : i \\in \\{0,1,2,\\dots,1000\\}\\}$ 且 $\\text{key}$ 等于 $A$ 中索引为800的元素。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。此顶层列表的每个元素对应一个测试用例，并且其本身必须是一个按 $[i,p,b]$ 顺序排列的三项列表，其中 $i$ 是整数索引或 $-1$，$p$ 是按上述定义计数的整数探测次数，$b$ 是一个指示是否使用了二分搜索的布尔值。例如，打印的行必须如下所示\n$[[i_1,p_1,b_1],[i_2,p_2,b_2],[i_3,p_3,b_3],[i_4,p_4,b_4],[i_5,p_5,b_5]]$。", "solution": "该问题要求设计并实现一个用于有序数组的混合搜索算法。此算法使用基于插值的探测来启动搜索，并在观测到其性能不达标时自动切换到二分搜索。解决方案必须基于这些搜索算法的基本原理，并遵守特定的实现要求。\n\n### 原理与算法设计\n\n一个长度为 $n$ 的有序数组 $A$ 在索引和值之间展现出一种单调非递减关系，即对于所有 $0 \\le i \\le j \\le n-1$，都有 $A[i] \\le A[j]$。这一属性是构建比线性扫描更高效的搜索算法的基础。\n\n#### 二分搜索\n二分搜索是一种稳健的算法，它保证了 $O(\\log n)$ 的对数时间复杂度。它在一个搜索子区间 $[l, r]$ 上操作，并探测中间元素 $A[\\text{mid}]$，其中 $\\text{mid} = l + \\lfloor(r-l)/2\\rfloor$。根据 $A[\\text{mid}]$ 与目标关键字的比较结果，它在每一步中都将搜索空间减半。区间长度 $L_t = r_t - l_t + 1$ 被缩减，使得 $L_{t+1} \\approx L_t/2$。其性能与数组内的值分布无关。\n\n#### 插值搜索\n插值搜索利用搜索区间 $[l, r]$ 边界上元素的值来估计目标关键字的位置。它假设从索引到值的映射近似是线性的。探测位置 `pos` 通过线性插值计算得出：\n$$\n\\text{pos} = l + \\left\\lfloor \\frac{(r-l)(key - A[l])}{A[r] - A[l]} \\right\\rfloor\n$$\n对于均匀分布的数据，插值搜索的平均时间复杂度为 $O(\\log \\log n)$，这在渐进意义上比二分搜索更快。然而，对于非均匀分布的数据（例如，指数增长或聚集的值），其性能会显著下降，最坏情况下的复杂度为 $O(n)$。\n\n#### 带有自调整功能的混合算法\n所提出的算法旨在结合两种方法的优点：插值搜索的潜在高速度和二分搜索的有保障的性能。它通过定量监控自身进展，并在插值搜索被证明无效时切换策略来实现这一点。\n\n**性能监控：**\n搜索的进展通过在步骤 $t$ 的每次探测后的区间缩减率 $\\rho_t$ 来衡量。给定探测前的区间长度 $L_t = r_t - l_t + 1$ 和探测后的长度 $L_{t+1}$，缩减率为：\n$$\n\\rho_t = \\frac{L_t - L_{t+1}}{L_t} = 1 - \\frac{L_{t+1}}{L_t}\n$$\n接近 $1$ 的 $\\rho_t$ 值表示一次非常有效的探测，而接近 $0$ 的值则表示进展甚微。对于二分搜索，$\\rho_t \\approx 0.5$。\n\n**切换逻辑：**\n为避免因单次不成功的探测而过早切换，算法会计算最后 $w$ 个观测到的 $\\rho_t$ 值的简单移动平均值。如果此平均值低于预定义的阈值 $\\tau$，则表明存在持续的性能不佳模式。此时，算法会断定插值搜索所假设的线性模型对于给定的数据分布是无效的，并为当前子区间 $[l, r]$ 中剩余的搜索切换到更稳健的二分搜索。\n\n### 实现细节与边界情况处理\n\n该算法实现为一个具有两种模式的状态机：`'interpolation'` 和 `'binary'`。\n\n1.  **初始化**：搜索范围初始化为整个数组 $[0, n-1]$。执行一次初始检查，判断目标 `key` 是否在数组的值范围之外，即 `key  A[0]` 或 `key > A[n-1]`。如果是，则搜索立即终止，返回索引 $-1$ 并且探测次数为零，因为该关键字不可能存在。\n\n2.  **主循环**：只要区间有效（$l \\le r$），搜索就继续进行。\n\n3.  **插值模式**：\n    *   **分母检查**：插值公式的一个关键边界情况是当 $A[r] = A[l]$ 时。这表明当前子区间 $[l, r]$ 中的所有元素都相同。尝试进行插值将导致除以零。根据问题规范，如果发生这种情况，算法将切换到二分搜索。这是因为如果 `key` 等于这个恒定值，二分搜索可以高效地找到一个索引；如果不等，它将正确地确定其不存在。\n    *   **探测位置计算**：计算 `pos` 索引。必须注意确保使用整数算术执行计算，或将其正确转换为整数索引。\n    *   **探测和更新**：将元素 $A[\\text{pos}]$ 与 `key` 进行比较，计入一次探测，并缩小范围 $[l, r]$。\n    *   **性能更新**：更新 `l` 或 `r` 后，计算新的 $\\rho_t$ 并将其添加到一个记录最近缩减率的列表（或双端队列）中。\n    *   **切换条件检查**：如果缩减率列表至少有 $w$ 个元素，则计算它们的平均值。如果该值小于 $\\tau$，则模式切换为 `'binary'`，并将布尔标志 `used_binary` 设置为 `True`。\n\n4.  **二分搜索模式**：\n    *   一旦算法进入此模式，它将保持在该模式直到终止。\n    *   遵循标准的二分搜索过程：计算 `mid`，探测 $A[\\text{mid}]$，并缩小范围 $[l, r]$。每次探测都会被计数。\n\n5.  **终止**：如果循环结束仍未找到关键字（$l > r$），则关键字不在数组中，返回索引 $-1$。如果在任何时候找到关键字，则立即返回其索引。最终的返回值聚合了找到的索引、探测总数以及指示是否曾使用过二分搜索的布尔标志。\n\n此设计提供了一种稳健且自适应的搜索机制，在各种数据分布上都表现良好，满足了问题陈述的所有要求。以下代码为指定的测试套件实现了这一逻辑。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Designs and executes the self-tuning hybrid search algorithm\n    on a predefined test suite.\n    \"\"\"\n\n    def hybrid_search(A: np.ndarray, key: int, tau: float, w: int):\n        \"\"\"\n        Performs a hybrid interpolation-binary search.\n\n        Args:\n            A: Sorted numpy array of numbers.\n            key: The target value to search for.\n            tau: The performance threshold for switching to binary search.\n            w: The window size for the moving average of range reduction.\n\n        Returns:\n            A list containing [found_index, num_probes, used_binary_search].\n        \"\"\"\n        n = A.size\n        l, r = 0, n - 1\n\n        probes = 0\n        used_binary = False\n        mode = 'interpolation'\n        reductions = deque(maxlen=w)\n\n        # Initial bounds check as per problem statement\n        if n == 0 or key  A[l] or key > A[r]:\n            # 'probes' remains 0 as specified\n            return [-1, 0, False]\n\n        while l = r:\n            if mode == 'binary':\n                if not used_binary:\n                    used_binary = True\n                \n                mid = l + (r - l) // 2\n                probes += 1\n                \n                if A[mid] == key:\n                    return [mid, probes, used_binary]\n                elif A[mid]  key:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:  # mode == 'interpolation'\n                # Invariant check: key must be within A[l] and A[r]\n                # This should hold but is a good safeguard.\n                if key  A[l] or key > A[r]:\n                    break\n\n                # Handle flat region to avoid division by zero and switch to binary search.\n                if A[r] == A[l]:\n                    if A[l] == key:\n                        # The key is in this flat region.\n                        # As specified, switch to binary search to find an index.\n                        mode = 'binary'\n                        continue\n                    else:\n                        # Key is not in this flat region, so it's not in the array.\n                        break\n                \n                old_l, old_r = l, r\n                \n                # Interpolation formula\n                # Pos must be clamped within [l, r] to handle potential floating point inaccuracies\n                # or extreme key values, though theory suggests it's not needed if key is in range.\n                pos_float = l + ((r - l) / (A[r] - A[l])) * (key - A[l])\n                pos = int(pos_float)\n                pos = max(l, min(pos, r))\n\n                probes += 1\n                \n                if A[pos] == key:\n                    return [pos, probes, used_binary]\n                elif A[pos]  key:\n                    l = pos + 1\n                else:\n                    r = pos - 1\n                \n                # Calculate performance metric\n                L_t = old_r - old_l + 1\n                L_t1 = r - l + 1\n                \n                if L_t > 0: # Avoid division by zero if range somehow becomes empty/invalid\n                    rho_t = (L_t - L_t1) / L_t\n                    reductions.append(rho_t)\n                \n                # Check switch condition\n                if len(reductions) == w:\n                    avg_rho = sum(reductions) / w\n                    if avg_rho  tau:\n                        mode = 'binary'\n                        used_binary = True\n\n        return [-1, probes, used_binary]\n\n    # --- Test Suite Definition ---\n    tau = 0.3\n    w = 4\n\n    test_cases = []\n\n    # Case 1: Uniform distribution\n    A1 = np.arange(1000)\n    key1 = 750\n    test_cases.append((A1, key1))\n\n    # Case 2: Nonlinear spacing (cubic)\n    A2 = np.array([i**3 for i in range(200)])\n    key2 = 729  # which is 9^3\n    test_cases.append((A2, key2))\n\n    # Case 3: Heavy duplicates\n    A3 = np.array([5] * 1000 + list(range(6, 106)))\n    key3 = 5\n    test_cases.append((A3, key3))\n\n    # Case 4: Target absent boundary condition\n    A4 = np.arange(10000)\n    key4 = 10001\n    test_cases.append((A4, key4))\n    \n    # Case 5: Extremely skewed growth (exponential-like)\n    A5 = np.array([int(10**(i/100)) for i in range(1001)])\n    key5 = A5[800]\n    test_cases.append((A5, key5))\n    \n    results = []\n    for A, key in test_cases:\n        result = hybrid_search(A, key, tau, w)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3241345"}]}