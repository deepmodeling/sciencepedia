{"hands_on_practices": [{"introduction": "线性搜索不仅限于寻找精确匹配。在许多实际应用中，我们更关心找到与目标值“最接近”的元素。这个练习将挑战你在单次遍历和有限内存（$O(1)$）的约束下，在一个数据流中找到最佳匹配项，这需要你维护一个“迄今为止最佳”的状态。[@problem_id:3244875]", "problem": "给定多个有限数据流，每个流被建模为一个实数有限序列 $x_0, x_1, \\dots, x_{n-1}$ 和一个目标实数值 $v$。您必须设计并实现一个线性搜索算法，该算法对每个流仅进行一次正向扫描，仅使用 $\\mathcal{O}(1)$ 的额外内存，并返回一个从零开始的索引 $i^\\*$，使得绝对差 $\\lvert x_{i^\\*} - v \\rvert$ 在流的所有元素中最小。在出现平局（即多个索引达到相同的最小绝对差）的情况下，您必须返回其中最小的索引。如果流为空（即 $n = 0$），则返回 $-1$。\n\n您的设计必须从基本原则出发：\n- 线性搜索定义为按 $x_0, x_1, \\dots, x_{n-1}$ 的顺序检查元素，而不重新访问先前的元素，并且除了输入本身之外，只维护常数个标量变量。\n- 对于任何有限实数集，最小值都存在。对于一个有限非空序列，使某个实值标准最小化的索引可以被定义为最小值的参数（arg minimum），而像取最小索引这样的确定性平局决胜规则会产生唯一的答案。\n- 绝对值函数 $\\lvert \\cdot \\rvert$ 通过映射 $x \\mapsto \\lvert x - v \\rvert$ 在 $\\mathbb{R}$ 上导出了一个相对于 $v$ 的全预序。\n\n您的程序必须根据这些原则实现线性搜索，并遵循以下精确规则：\n- 索引是从零开始的；对于 $n \\ge 1$，有效索引在 $\\{0, 1, \\dots, n-1\\}$ 集合中。\n- 如果 $n = 0$，则返回 $-1$。\n- 仅使用 $\\mathcal{O}(1)$ 额外内存：您可以维护一组固定的标量，例如当前最佳索引和当前最佳绝对差。您绝不能为辅助存储分配与 $n$ 成正比的内存。\n- 如果您发现一个元素 $x_i$ 满足 $\\lvert x_i - v \\rvert = 0$，您可以提前终止，因为不存在更小的绝对差。\n\n测试套件：\n将您的程序应用于以下测试用例。每个测试用例是一个对 $(\\text{stream}, v)$，其中流被明确列出，而 $v$ 是一个实数。为便于阅读，每个流都以字面列表表示法写出，但您的算法在概念上必须将其作为只进数据流来处理。\n\n- 测试 A：流 $[3, 10, 9, 2, 5]$，目标 $v = 7$。\n- 测试 B：流 $[7, 8, 7, 6]$，目标 $v = 7$。\n- 测试 C：流 $[]$，目标 $v = 7$。\n- 测试 D：流 $[1.5]$，目标 $v = 2.7$。\n- 测试 E：流 $[4, 10]$，目标 $v = 7$。\n- 测试 F：流 $[-5, -2, -1, -3]$，目标 $v = -2.4$。\n- 测试 G：流 $[10^{12}, -10^{12}, 3, 10^{12} - 1]$，目标 $v = 0$。\n- 测试 H：流 $[1.0, 1.2, 1.4, 1.6]$，目标 $v = 1.5$。\n- 测试 I：流 $[5, 5, 5]$，目标 $v = 4.9$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序为测试 A 到测试 I 返回的索引，格式为逗号分隔的列表并用方括号括起来，例如 $[a,b,c,d,e,f,g,h,i]$，其中 $a$ 到 $i$ 均为整数。不应打印任何其他文本。", "solution": "用户提供了一个问题陈述，要求设计和实现一个线性搜索算法。现在将执行验证过程。\n\n### 步骤 1：提取已知条件\n\n- **数据模型**：一个实数有限序列 $x_0, x_1, \\dots, x_{n-1}$，表示一个数据流，以及一个目标实数值 $v$。\n- **目标**：找到从零开始的索引 $i^*$，该索引能最小化绝对差 $\\lvert x_{i^*} - v \\rvert$。\n- **约束 1（线性扫描）**：算法必须对流进行一次正向扫描（$x_0, x_1, \\dots, x_{n-1}$），不得重新访问元素。\n- **约束 2（内存）**：算法仅能使用 $\\mathcal{O}(1)$ 的额外内存，即常数个标量变量。\n- **约束 3（平局决胜）**：在出现平局的情况下，即多个索引产生相同的最小绝对差，必须返回其中最小的索引。\n- **约束 4（空流）**：如果流为空（$n=0$），算法必须返回 $-1$。\n- **约束 5（索引）**：索引是从零开始的，对于长度为 $n \\ge 1$ 的流，有效索引在集合 $\\{0, 1, \\dots, n-1\\}$ 中。\n- **优化（提前终止）**：如果找到一个元素 $x_i$ 使得 $\\lvert x_i - v \\rvert = 0$，算法可以提前终止。\n- **基本原则**：\n    - 线性搜索按顺序检查元素。\n    - 对于任何有限实数集，最小值都存在。最小参数（arg min）可以通过平局决胜规则唯一确定。\n    - 函数 $x \\mapsto \\lvert x - v \\rvert$ 在 $\\mathbb{R}$ 上定义了一个全预序。\n- **测试用例**：\n    - A：流 $[3, 10, 9, 2, 5]$，目标 $v = 7$。\n    - B：流 $[7, 8, 7, 6]$，目标 $v = 7$。\n    - C：流 $[]$，目标 $v = 7$。\n    - D：流 $[1.5]$，目标 $v = 2.7$。\n    - E：流 $[4, 10]$，目标 $v = 7$。\n    - F：流 $[-5, -2, -1, -3]$，目标 $v = -2.4$。\n    - G：流 $[10^{12}, -10^{12}, 3, 10^{12} - 1]$，目标 $v = 0$。\n    - H：流 $[1.0, 1.2, 1.4, 1.6]$，目标 $v = 1.5$。\n    - I：流 $[5, 5, 5]$，目标 $v = 4.9$。\n- **输出格式**：包含一个逗号分隔的整数结果列表的单行，并用方括号括起来。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行审查。\n\n- **科学上合理**：该问题在根本上是合理的。它植根于实数分析（绝对值、最小化）和计算机科学（算法分析、线性搜索、时间和空间复杂度）的基本原则。所引用的所有原则都是正确的。\n- **适定性**：该问题是适定的。目标陈述清晰：在索引 $i$ 上找到 $\\lvert x_i - v \\rvert$ 的最小参数（arg min）。约束是明确的。定义域（实数有限序列）已指定。所提供的平局决胜规则（最小索引）和对空流情况的处理确保了对于任何有效输入都存在一个唯一、稳定且有意义的解。\n- **客观性**：问题以精确、无歧义的数学和算法语言表达，没有主观解释的余地。\n\n该问题不存在以下任何使其无效的缺陷：\n1.  **科学或事实上的不合理**：无。\n2.  **不可形式化或不相关**：该问题与线性搜索直接相关，并且是完全可形式化的。\n3.  **不完整或矛盾的设置**：问题是自洽的，所有约束都是一致的。\n4.  **不切实际或不可行**：这些条件对于算法问题是标准的，并且在计算上是可行的。\n5.  **不适定或结构不良**：该问题是适定的。\n6.  **伪深刻、琐碎或同义反复**：该问题是算法设计中的一个标准基础练习，不是一个琐碎或人为设计的谜题。\n7.  **超出科学可验证范围**：对于任何给定输入，结果在数学上都是可验证的。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。将开发并呈现一个解决方案。\n\n### 解决方案\n\n任务是在序列 $X = (x_0, x_1, \\dots, x_{n-1})$ 中找到一个元素 $x_{i^*}$ 的索引 $i^*$，使得函数 $f(x_i) = \\lvert x_i - v \\rvert$ 最小化。我们被限制在单次正向遍历和 $\\mathcal{O}(1)$ 内存。\n\n**基于原则的设计**\n\n该设计源于在序列上进行线性搜索以寻找极值的性质。核心思想是在迭代时维护“迄今为止最佳”解的状态。\n\n1.  **状态变量**：为了满足 $\\mathcal{O}(1)$ 内存约束，我们需要常数个变量来跟踪状态。必要的状态包括：\n    - 迄今为止找到的最佳元素的索引，我们称之为 $i_{best}$。\n    - 对应于该元素的最小绝对差，我们称之为 $\\delta_{min}$。\n\n2.  **初始化**：\n    - 首先，我们必须处理空流（$n=0$）的边界情况。根据问题规则，函数必须返回 $-1$。\n    - 对于非空流（$n \\ge 1$），我们可以使用第一个元素 $x_0$ 来初始化我们的状态。这是一个有效的比较起点。我们设置 $i_{best} \\leftarrow 0$ 和 $\\delta_{min} \\leftarrow \\lvert x_0 - v \\rvert$。\n\n3.  **迭代改进**：\n    - 我们对流的其余部分（索引从 $1$ 到 $n-1$）执行一次单向遍历。\n    - 在每次迭代 $i$ 中，我们计算当前的绝对差 $\\delta_i = \\lvert x_i - v \\rvert$。\n    - 然后我们将 $\\delta_i$ 与存储的最小差值 $\\delta_{min}$ 进行比较。\n    - 如果 $\\delta_i  \\delta_{min}$，我们找到了一个严格更优的元素。我们更新状态：$\\delta_{min} \\leftarrow \\delta_i$ 和 $i_{best} \\leftarrow i$。\n    - 如果 $\\delta_i \\ge \\delta_{min}$，我们什么也不做。这隐式地处理了平局决胜规则：如果 $\\delta_i = \\delta_{min}$，我们保留当前的 $i_{best}$，因为它比当前索引 $i$ 小，从而满足了在平局时返回最小索引的要求。\n\n4.  **提前终止优化**：\n    - 对于非负函数 $\\lvert \\cdot \\rvert$，可能的最小值为 $0$。\n    - 在迭代过程中，如果在任何时刻我们发现一个元素 $x_i$ 使得 $\\delta_i = \\lvert x_i - v \\rvert = 0$，我们就找到了全局最小值。后续的任何元素都不可能产生更小的差值。\n    - 因此，我们可以立即更新 $i_{best} \\leftarrow i$ 并终止搜索，返回 $i_{best}$。这个优化是有效的，并且可以在某些输入上提高性能。我们的初始化步骤本身可能在索引 0 处找到一个完美匹配。我们可以在初始化后检查 $\\delta_{min}$ 是否为 0，并立即返回 0。类似地，在循环内部，如果我们发现 $\\delta_i = 0$，我们可以立即返回 $i$。\n\n5.  **最终确定**：\n    - 循环完成后（无论是到达流的末尾还是提前终止），存储在 $i_{best}$ 中的值就是根据问题规范所保证的解。\n\n**算法总结**\n\n设输入流为长度为 $n$ 的 $X$，目标为 $v$。\n\n1.  如果 $n = 0$，返回 $-1$。\n2.  初始化 $i_{best} \\leftarrow 0$。\n3.  初始化 $\\delta_{min} \\leftarrow \\lvert X[0] - v \\rvert$。\n4.  如果 $\\delta_{min} = 0$，返回 $i_{best}$。\n5.  对于从 $1$ 到 $n-1$ 的 $i$：\n    a. 计算 $\\delta_i \\leftarrow \\lvert X[i] - v \\rvert$。\n    b. 如果 $\\delta_i  \\delta_{min}$：\n        i.  更新 $\\delta_{min} \\leftarrow \\delta_i$。\n        ii. 更新 $i_{best} \\leftarrow i$。\n        iii. 如果 $\\delta_{min} = 0$，跳出循环。\n6.  返回 $i_{best}$。\n\n该算法正确地实现了一个线性搜索，它遵守所有指定的约束：单次正向遍历、$\\mathcal{O}(1)$ 内存使用、正确的平局决胜规则、空情况处理以及可选的提前终止。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear search problem for a predefined test suite.\n    \"\"\"\n\n    def linear_search_closest(stream, v):\n        \"\"\"\n        Finds the index i* of the element in the stream that minimizes |x_i* - v|.\n\n        Args:\n            stream (list[float]): A finite sequence of real numbers.\n            v (float): The target real value.\n\n        Returns:\n            int: The zero-based index of the element closest to v.\n                 Returns -1 if the stream is empty. In case of a tie,\n                 the smallest index is returned.\n        \"\"\"\n        # Constraint 4: Handle the empty stream case.\n        if not stream:\n            return -1\n\n        # Initialization using the first element (index 0).\n        # i_best holds the index of the best element found so far.\n        # delta_min holds the minimum absolute difference found so far.\n        best_index = 0\n        min_diff = abs(stream[0] - v)\n\n        # Optimization: If the first element is a perfect match, we can return immediately.\n        if min_diff == 0:\n            return best_index\n\n        # Constraint 1: Linear scan from the second element to the end.\n        for i in range(1, len(stream)):\n            current_diff = abs(stream[i] - v)\n\n            # Compare current difference with the minimum found so far.\n            if current_diff  min_diff:\n                # A new minimum is found. Update state.\n                min_diff = current_diff\n                best_index = i\n                \n                # Optimization: Early termination if a perfect match is found.\n                if min_diff == 0:\n                    break\n        \n        # The loop naturally handles the tie-breaking rule (Constraint 3):\n        # If current_diff == min_diff, we do not update best_index,\n        # thus preserving the smaller, earlier index.\n        \n        # The memory usage is O(1) as we only use a few scalar variables\n        # (best_index, min_diff, i, current_diff) irrespective of stream size.\n\n        return best_index\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A\n        ([3, 10, 9, 2, 5], 7),\n        # Test B\n        ([7, 8, 7, 6], 7),\n        # Test C\n        ([], 7),\n        # Test D\n        ([1.5], 2.7),\n        # Test E\n        ([4, 10], 7),\n        # Test F\n        ([-5, -2, -1, -3], -2.4),\n        # Test G\n        ([10**12, -10**12, 3, 10**12 - 1], 0),\n        # Test H\n        ([1.0, 1.2, 1.4, 1.6], 1.5),\n        # Test I\n        ([5, 5, 5], 4.9)\n    ]\n\n    results = []\n    for stream, v in test_cases:\n        result = linear_search_closest(stream, v)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244875"}, {"introduction": "标准的线性搜索发生在一维序列上，但如果数据结构本身是“循环”的呢？本练习要求你设计一个能在环形数组上执行的线性搜索算法。你需要巧妙地运用模运算来处理索引的“回绕”，并确保算法能正确终止，且每个元素仅被访问一次。[@problem_id:3244873]", "problem": "考虑一个大小为 $n$ 的整数循环数组，其中 $n \\ge 1$，表示为序列 $A[0],A[1],\\dots,A[n-1]$。循环数组意味着有效位置是整数 $0,1,\\dots,n-1$，并且移动“超过” $n-1$ 后会从位置 $0$ 继续。给定一个起始位置 $s$（其中 $0 \\le s \\le n-1$）和一个目标值 $x$。设计并实现一个线性搜索的变体，该变体在循环数组中按照明确定义的遍历顺序一次检查一个元素，并满足以下所有约束：它总是终止，它从不重复检查任何位置，如果存在索引 $i$ 使得 $A[i]=x$ 则返回该索引，否则返回 $-1$。您的算法不能修改 $A$，不能重排 $A$，并且只能执行顺序扫描；不要使用任何辅助搜索结构。主要效率目标是最小化元素检查次数，最坏情况下的检查次数恰好为 $n$，而当在检查所有位置之前找到目标时，最好情况下的检查次数严格小于 $n$。您的设计必须基于线性搜索作为顺序检查的定义以及用于循环结构索引算术的模运算性质。遍历顺序必须是 $s$ 和 $n$ 的函数，并且必须仅使用沿圆环的向前移动来明确定义。\n\n您的程序必须是自包含的，不使用外部输入。对于下面的每个测试用例，程序应生成一个整数作为搜索结果，最终输出为一行，其中包含所有测试用例结果的逗号分隔列表，并用方括号括起来（例如，“[1,-1,4]”）。\n\n请使用以下测试套件，它涵盖了典型场景、环绕行为、目标不存在、边界条件和重复值的情况。每个测试用例是一个三元组 $(A,x,s)$，其中 $A$ 是数组， $x$ 是目标值， $s$ 是起始位置：\n- 测试用例 1：$A=[4,7,1,9,3]$, $x=9$, $s=1$。\n- 测试用例 2：$A=[5,2,8,6]$, $x=2$, $s=3$。\n- 测试用例 3：$A=[10,20,30]$, $x=15$, $s=2$。\n- 测试用例 4：$A=[42]$, $x=42$, $s=0$。\n- 测试用例 5：$A=[7,7,7,7]$, $x=7$, $s=2$。\n- 测试用例 6：$A=[3,1,4,1,5]$, $x=1$, $s=0$。\n- 测试用例 7：$A=[2,3,5,7,11]$, $x=2$, $s=4$。\n\n您的程序应生成单行输出，其中包含严格遵循“[r1,r2,r3,r4,r5,r6,r7]”格式的结果，其中每个 $r_k$ 是根据上述规则为测试用例 $k$ 生成的整数结果。此问题不涉及任何物理单位、角度或百分比；所有值都是整数，必须纯粹作为数学和逻辑实体来处理。", "solution": "该问题要求为循环数组设计一种线性搜索算法。搜索必须从指定的起始索引 $s$ 开始，并顺序进行，在最坏情况下恰好检查每个元素一次。解决方案必须基于线性搜索和模运算的原理。\n\n首先，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n-   一个大小为 $n$ 的整数数组 $A$，其中 $n \\ge 1$。\n-   该数组是循环的，意味着索引在集合 $\\{0, 1, \\dots, n-1\\}$ 中，并且移动超过 $n-1$ 后会环绕到 $0$。\n-   一个起始位置 $s$，其中 $0 \\le s \\le n-1$。\n-   一个目标整数值 $x$。\n-   算法必须是线性搜索的变体，一次检查一个元素。\n-   遍历顺序必须明确定义，从 $s$ 开始，并且只使用向前移动。\n-   算法必须总是终止。\n-   任何位置不能被检查超过一次。\n-   如果存在索引 $i$ 使得 $A[i]=x$，算法必须返回该索引；否则，必须返回 $-1$。\n-   算法不得修改或重排数组 $A$。\n-   不得使用辅助搜索结构。\n-   最坏情况下的元素检查次数必须恰好为 $n$。\n-   如果在检查所有位置之前找到目标，最好情况下的检查次数必须严格小于 $n$。\n-   设计必须基于线性搜索原理和模运算。\n-   提供了测试用例：\n    1.  $A=[4,7,1,9,3]$, $x=9$, $s=1$。\n    2.  $A=[5,2,8,6]$, $x=2$, $s=3$。\n    3.  $A=[10,20,30]$, $x=15$, $s=2$。\n    4.  $A=[42]$, $x=42$, $s=0$。\n    5.  $A=[7,7,7,7]$, $x=7$, $s=2$。\n    6.  $A=[3,1,4,1,5]$, $x=1$, $s=0$。\n    7.  $A=[2,3,5,7,11]$, $x=2$, $s=4$。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据指定标准对问题进行评估：\n-   **科学基础**：该问题在计算机科学和数学方面有充分的依据，特别涉及数据结构（数组）上的算法和数论（模运算）。这是一个标准的、可形式化的问题。\n-   **适定性**：该问题定义清晰，约束明确。目标（找到一个元素或确定其不存在）是精确的，搜索过程的条件（起点、遍历顺序、终止）足以定义一种唯一的算法策略。\n-   **客观性**：问题以精确、正式的语言陈述，没有主观性或歧义。\n-   **无缺陷**：该问题没有违反任何无效性标准。它是一致的、完整的并且是可解的。各项约束相互兼容，并导向一个合乎逻辑的解决方案。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将开发一个解决方案。\n\n**基于原理的解决方案**\n问题的核心是定义一个遍历序列，该序列从索引 $s$ 开始，并精确访问大小为 $n$ 的循环数组中的每个索引一次。“沿圆环向前移动”的要求与线性搜索的约束相结合，自然而然地导出了一个基于模运算的解决方案。\n\n设数组为 $A$，大小为 $n$。索引为 $\\{0, 1, \\dots, n-1\\}$。给定一个起始索引 $s$。搜索将通过检查索引 $s, s+1, s+2$ 等处的元素来进行。为了处理循环的“环绕”行为，我们使用模运算符。\n\n该算法可以构建为一个迭代 $n$ 次的循环。一个循环计数器（我们称之为 $i$）将从 $0$ 运行到 $n-1$。这个计数器代表到目前为止已检查的元素数量，或者等效地，代表从起始位置 $s$ 的偏移量。\n\n对于偏移量 $i \\in \\{0, 1, \\dots, n-1\\}$ 的每个值，要检查的数组 $A$ 中的实际索引（我们称之为 $j$）计算如下：\n$$\nj = (s + i) \\pmod n\n$$\n这个公式确保了从 $s$ 开始的顺序向前扫描：\n-   当 $i=0$ 时，索引为 $j = (s+0) \\pmod n = s$。检查的第一个元素是 $A[s]$。\n-   当 $i=1$ 时，索引为 $j = (s+1) \\pmod n$。\n-   这个过程一直持续到 $i=n-1$，对应的索引为 $j = (s+n-1) \\pmod n$。\n\n索引集合 $\\{ (s+i) \\pmod n \\mid i \\in \\{0, 1, \\dots, n-1\\} \\}$ 正好是集合 $\\{0, 1, \\dots, n-1\\}$。这是模运算的一个基本性质：将一个完全剩余系（在这里是 $\\{0, 1, \\dots, n-1\\}$）加上一个常数 $s$ 并对 $n$ 取模，会产生另一个完全剩余系。因此，这种遍历方式保证了数组的每个元素都被恰好访问一次。\n\n算法流程如下：\n1.  初始化一个迭代 $n$ 次的循环，迭代变量 $i$ 从 $0$ 到 $n-1$。\n2.  在循环内部，计算当前要检查的索引：$j = (s + i) \\pmod n$。\n3.  将此索引处的元素 $A[j]$ 与目标值 $x$ 进行比较。\n4.  如果 $A[j] = x$，则目标已找到。算法必须立即终止并返回索引 $j$。这满足了提前终止的要求，以及最好情况下比较次数少于 $n$ 的性能要求。\n5.  如果在检查完所有 $n$ 个位置后循环完成仍未找到目标值 $x$，则意味着 $x$ 不在数组中。在这种情况下，算法返回 $-1$。这满足了最坏情况下恰好进行 $n$ 次比较的要求。\n\n该设计满足所有问题约束：它是一种顺序扫描，使用模运算，从 $s$ 开始，每个元素访问一次，它会终止，并且在不修改数组或使用辅助搜索数据结构的情况下返回正确的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the circular array linear search problem for a predefined suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (numpy array A, target x, start_index s)\n    test_cases = [\n        (np.array([4, 7, 1, 9, 3]), 9, 1),\n        (np.array([5, 2, 8, 6]), 2, 3),\n        (np.array([10, 20, 30]), 15, 2),\n        (np.array([42]), 42, 0),\n        (np.array([7, 7, 7, 7]), 7, 2),\n        (np.array([3, 1, 4, 1, 5]), 1, 0),\n        (np.array([2, 3, 5, 7, 11]), 2, 4),\n    ]\n\n    results = []\n\n    def circular_linear_search(arr, target, start_pos):\n        \"\"\"\n        Performs a linear search on a circular array.\n\n        Args:\n            arr (np.ndarray): The circular array of integers.\n            target (int): The value to search for.\n            start_pos (int): The starting index for the search.\n\n        Returns:\n            int: The index of the first occurrence of the target found during the traversal,\n                 or -1 if the target is not in the array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n\n        # The loop iterates n times to ensure every element is checked once in the worst case.\n        # The variable 'i' represents the number of steps taken from the starting position.\n        for i in range(n):\n            # Calculate the current index to check using modular arithmetic.\n            # This handles the \"wrap-around\" behavior of the circular array.\n            current_index = (start_pos + i) % n\n            \n            if arr[current_index] == target:\n                # If the target is found, return its index immediately.\n                return current_index\n        \n        # If the loop completes, the target was not found in the array.\n        return -1\n\n    for A, x, s in test_cases:\n        result = circular_linear_search(A, x, s)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244873"}, {"introduction": "了解一个算法的局限性与其优势同样重要。当面临在两个数组中寻找首个共同元素的任务时，朴素的嵌套线性搜索会导致效率低下。此练习将引导你通过使用哈希集合，将一个$O(n \\cdot m)$的解决方案优化为$O(n+m)$，这是一个典型的以空间换取时间的例子。[@problem_id:3245002]", "problem": "给定两个有限的整数数组，记为 $A$ 和 $B$。设 $|A| = n$ 且 $|B| = m$，其中 $n$ 和 $m$ 为非负整数。在数据结构与算法中，一项基本操作是顺序或线性搜索，即给定一个目标值 $x$ 和一个数组，它会按顺序检查数组元素，执行相等性比较，直到找到 $x$ 或断定 $x$ 不存在。另一项基本操作是基于哈希的集合中的成员资格测试，在均匀哈希假设下，通常认为每次查询的期望时间为常数时间。你的任务是设计一个程序，找出 $A$ 和 $B$ 之间的第一个公共元素，其中“第一个”是根据 $A$ 中从左到右的顺序定义的。\n\n形式上，设 $A = [a_0,a_1,\\dots,a_{n-1}]$ 且 $B = [b_0,b_1,\\dots,b_{m-1}]$。定义输出三元组为 $[v,i,j]$，其中 $v$ 是 $A$ 中最早出现的（即满足 $a_i$ 出现在 $B$ 中的最小索引 $i$）同时也存在于 $B$ 中的值，$i$ 是 $v$ 在 $A$ 中的索引，$j$ 是 $v$ 在 $B$ 中出现的最左侧索引。如果不存在这样的值，程序应输出哨兵值 $[-1,-1,-1]$。朴素方法执行嵌套的线性搜索：对 $A$ 中的每个 $a_i$，在线性搜索 $B$ 以查找 $a_i$；如果找到，则报告 $a_i$ 及索引 $i$ 和 $j$，否则继续。一种更优的方法是，构建一个由 $B$ 中元素填充的哈希集合，并为每个值单独记录其在 $B$ 中首次出现的索引，然后对 $A$ 进行一次线性扫描，测试其元素是否在该集合中。\n\n从线性搜索的核心定义和广为接受的哈希集均匀哈希假设出发，提出、论证并实现基于哈希集的方法。你的程序必须是自包含的（无输入），使用下面的测试套件，并生成单行输出，其中包含所有测试用例的聚合结果。\n\n测试套件（数组明确显示）：\n- 案例 $1$ (正常情况): $A = [3,5,7,9]$, $B = [10,11,5,12]$.\n- 案例 $2$ (无公共元素): $A = [1,2,3]$, $B = [4,5]$.\n- 案例 $3$ (首元素公共): $A = [8,1]$, $B = [8]$.\n- 案例 $4$ (两数组中均有重复元素): $A = [4,4,4]$, $B = [0,4,4]$.\n- 案例 $5$ (第一个数组为空): $A = []$, $B = [1,2]$.\n- 案例 $6$ (第二个数组为空): $A = [1,2]$, $B = []$.\n- 案例 $7$ (负数和零): $A = [-5,-1,0,2]$, $B = [3,-1,4]$.\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是三个整数的列表 $[v,i,j]$。例如，如果只有两个测试用例，一个可接受的输出是 $[[5,1,2],[-1,-1,-1]]$。对于本问题，输出必须按顺序将所有七个测试用例的结果聚合为单个列表，例如 $[[\\dots],[\\dots],\\dots]$。\n\n约束与假设：\n- 使用随机存取机（RAM）模型，其中算术和比较操作的成本为单位成本。\n- 如果没有公共元素，按规定输出 $[-1,-1,-1]$；哨兵值 $-1$ 必须是整数。\n- 元素是标准的机器整数，适配 Python 的整数类型；不涉及物理单位。", "solution": "问题陈述在形式上是有效的。它在科学上基于算法设计和复杂度分析的原理，问题定义良好，具有明确的定义和约束，并以客观、正式的语言表达。没有矛盾、信息缺失或违反科学或数学原则之处。因此，我们可以着手提出解决方案。\n\n目标是找出两个整数数组 $A = [a_0, a_1, \\dots, a_{n-1}]$（长度为 $n$）和 $B = [b_0, b_1, \\dots, b_{m-1}]$（长度为 $m$）之间的第一个公共元素。术语“第一个”是根据数组 $A$ 的顺序定义的；也就是说，我们要寻找具有最小索引 $i$ 且同时存在于数组 $B$ 中的元素 $a_i$。要求的输出是一个三元组 $[v, i, j]$，其中 $v = a_i$，$i$ 是 $v$ 在 $A$ 中的索引，$j$ 是 $v$ 在 $B$ 中*首次*出现的索引（即满足 $b_j = v$ 的最小 $j$）。如果没有公共元素，指定的哨兵输出为 $[-1, -1, -1]$。\n\n如问题描述中所提及的，一种朴素方法涉及嵌套循环。我们将遍历 $A$ 中的每个元素 $a_i$（从 $i=0$ 到 $n-1$），并对每个 $a_i$ 在 $B$ 的所有元素中进行第二次内部线性搜索（从 $j=0$ 到 $m-1$）以检查是否相等。我们第一次找到匹配（即 $a_i = b_j$）时，就找到了解。外层循环最多运行 $n$ 次，内层循环在每次外层迭代中最多运行 $m$ 次。在单位成本比较的随机存取机（RAM）模型下，这导致最坏情况下的时间复杂度为 $O(n \\cdot m)$。对于大型数组，这种平方复杂度是低效的。\n\n通过利用基于哈希的数据结构，可以设计出更高效的算法，以空间换时间。问题建议使用哈希集，但为了满足返回数组 $B$ 中*最左侧*索引 $j$ 的要求，哈希映射（或字典）是更合适的工具。该策略分为两个阶段：一个是对数组 $B$ 的预处理阶段，另一个是对数组 $A$ 的搜索阶段。\n\n**阶段 1：预处理数组 $B$**\n\n此阶段的目标是构建一个数据结构，该结构允许对 $B$ 中的任何值及其首次出现的索引进行近乎瞬时的查找。哈希映射是实现此目标的理想选择。我们可以将 $B$ 中存在的每个唯一值映射到其首次对应的索引。\n\n步骤如下：\n1. 初始化一个空的哈希映射，我们称之为 $\\text{value\\_to\\_index\\_map}$。\n2. 遍历数组 $B$，从索引 $j = 0$到 $m-1$。\n3. 对于每个元素 $b_j$，检查值 $b_j$ 是否已是 $\\text{value\\_to\\_index\\_map}$ 中的一个键。\n4. 如果 $b_j$ *不在*映射中，这表示这是我们第一次遇到这个值。我们将 $b_j$ 作为键添加到映射中，并将其当前索引 $j$作为关联值。\n5. 如果 $b_j$ 已在映射中，我们什么也不做，从而保留其首次出现的索引。\n\n在单次遍历 $B$ 之后，$\\text{value\\_to\\_index\\_map}$ 包含了 $B$ 的所有唯一元素作为键，其对应的值是它们在 $B$ 中的最左侧索引。在均匀哈希假设下，每次向哈希映射中插入操作的期望时间为常数时间，即 $O(1)$。因此，此阶段的总时间复杂度为 $O(m)$。所需空间与 $B$ 中唯一元素的数量成正比，最多为 $m$，因此空间复杂度为 $O(\\min(m, U))$，其中 $U$ 是 $B$ 中唯一元素的数量。\n\n**阶段 2：在数组 $A$ 中搜索**\n\n预处理完成后，我们现在可以高效地找到第一个公共元素。\n\n步骤如下：\n1. 遍历数组 $A$，从索引 $i = 0$到 $n-1$。\n2. 对于每个元素 $a_i$，在 $\\text{value\\_to\\_index\\_map}$ 中查找键 $a_i$。\n3. 因为我们是按顺序遍历 $A$，根据定义，我们在映射中找到的第一个作为键的 $a_i$ 就是第一个公共元素。\n4. 找到这样的 $a_i$后，我们就得到了解：值 $v = a_i$，它在 $A$ 中的索引是 $i$，它在 $B$ 中的最左侧索引可以从映射中检索得到，即 $j = \\text{value\\_to\\_index\\_map}[a_i]$。然后我们返回三元组 $[v, i, j]$ 并终止算法。\n\n如果循环完成而没有在映射中找到 $A$ 的任何元素，这意味着两个数组之间没有公共元素。在这种情况下，我们按要求返回哨兵值 $[-1, -1, -1]$。\n\n**总体复杂度与论证**\n\n基于哈希映射的方法的总时间复杂度是两个阶段的复杂度之和：$O(m) + O(n) = O(n+m)$。这种线性时间复杂度是渐进最优的，因为任何算法在最坏情况下都必须检查两个数组的每个元素才能保证结果正确。哈希映射的空间复杂度为 $O(\\min(m, U))$。这种方法明显优于朴素的 $O(n \\cdot m)$ 方法，尤其是在处理大规模输入时。该实现正确处理了如空数组（$n=0$ 或 $m=0$）和数组内重复元素等边缘情况，严格遵守了问题定义。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite and prints the aggregated result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        ([3, 5, 7, 9], [10, 11, 5, 12]),\n        # Case 2 (no common element)\n        ([1, 2, 3], [4, 5]),\n        # Case 3 (first element common)\n        ([8, 1], [8]),\n        # Case 4 (duplicates in both arrays)\n        ([4, 4, 4], [0, 4, 4]),\n        # Case 5 (empty first array)\n        ([], [1, 2]),\n        # Case 6 (empty second array)\n        ([1, 2], []),\n        # Case 7 (negative numbers and zero)\n        ([-5, -1, 0, 2], [3, -1, 4]),\n    ]\n\n    all_results_str = []\n    for a, b in test_cases:\n        result = find_first_common_element(a, b)\n        # Format the result list as a string \"[v,i,j]\" without spaces\n        v, i, j = result\n        all_results_str.append(f\"[{v},{i},{j}]\")\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(all_results_str)}]\")\n\ndef find_first_common_element(A, B):\n    \"\"\"\n    Finds the first common element between arrays A and B.\n\n    The function finds the element `v` that appears earliest in `A` and is also\n    present in `B`. It returns a list `[v, i, j]`, where `i` is the index of `v`\n    in `A` and `j` is the index of the first occurrence of `v` in `B`.\n\n    If no common element exists, it returns [-1, -1, -1].\n\n    Args:\n        A (list[int]): The first array.\n        B (list[int]): The second array.\n\n    Returns:\n        list[int]: A list containing the value, index in A, and index in B,\n                   or [-1, -1, -1] if no common element is found.\n    \"\"\"\n    # Phase 1: Pre-process array B to create a hash map of values\n    # to their first-seen (leftmost) index.\n    b_value_to_index_map = {}\n    for j, val in enumerate(B):\n        if val not in b_value_to_index_map:\n            b_value_to_index_map[val] = j\n\n    # Phase 2: Iterate through array A and check for membership in the map.\n    # The first element found is the answer due to the left-to-right scan of A.\n    for i, val in enumerate(A):\n        if val in b_value_to_index_map:\n            j_in_b = b_value_to_index_map[val]\n            return [val, i, j_in_b]\n\n    # If the loop completes, no common element was found.\n    return [-1, -1, -1]\n\n# Execute the solution.\nsolve()\n```", "id": "3245002"}]}