{"hands_on_practices": [{"introduction": "理论是算法学习的基石，而实践则是检验和深化理解的试金石。本次动手实践将从一个有趣的角度切入：如果我们只知道冒泡排序过程中的所有交换操作和最终的有序结果，能否反推出原始的数组呢？这个练习 [@problem_id:3257578] 将排序过程视为一系列可逆的置换操作。通过从后向前“撤销”每一次交换，你将能深刻体会到冒泡排序每一步操作的精确影响，从而对算法的底层机制建立更牢固的直观认识。", "problem": "给定一个未知整数数组经过优化冒泡排序后所执行的相邻交换的按时间顺序的记录，以及该数组最终的有序输出。该优化的冒泡排序变体在每一轮遍历后会缩减比较边界，因为剩余未排序前缀中的最大元素已被移动到末尾；如果某轮遍历没有执行任何交换，它会提前终止。每次记录的交换是当时被交换的相邻元素对 $\\left(A[i], A[i+1]\\right)$ 的索引 $i$。索引是从 $0$ 开始的。所有值都是整数，可能包含重复值。您的任务是重建排序前的原始数组。\n\n使用的基本定义：\n- 升序冒泡排序会重复比较相邻元素对 $\\left(A[i], A[i+1]\\right)$，并在 $A[i] > A[i+1]$ 时交换它们。每次完整的遍历之后，算法会将有效范围减一，因为剩余的最大元素已经到达其最终位置。优化变体会在一次遍历完成且没有发生任何交换时终止。\n- 在索引 $i$ 处的一次相邻交换是交换位置 $i$ 和 $i+1$ 处元素的函数 $t_i$。\n- 按时间顺序排列的交换记录 $S = \\left[i_0, i_1, \\dots, i_{k-1}\\right]$ 对应于在演变中的数组上进行的相邻对换的复合。如果 $A_0$ 表示未知的原始数组，$B$ 表示最终的有序数组，那么存在一个置换 $P$ 使得 $B = P\\left(A_0\\right)$，其中 $P$ 是由交换记录引起的相邻对换的复合。逆置换 $P^{-1}$ 可以从 $B$ 恢复出 $A_0$。\n\n您的程序必须实现一个算法，在给定以下信息的情况下：\n- 数组长度 $n$，\n- 最终的有序数组 $B$，\n- 以及由优化冒泡排序产生的按时间顺序排列的交换索引列表 $S$，\n\n返回原始数组 $A_0$。该数组在通过优化冒泡排序后，会产生完全相同的交换记录 $S$ 和最终有序数组 $B$。\n\n请使用纯粹的数学和逻辑推理，基于上述基本定义来设计您的算法。不要依赖任何快捷公式；请从关于置换和相邻对换的第一性原理推导重建过程。\n\n测试套件和要求的输出：\n- 将您的算法应用于以下五个测试用例。每个测试用例提供 $\\left(n, B, S\\right)$，并期望得到重建的原始数组 $A_0$ 作为结果。\n    1. $n = 5$， $B = \\left[1,2,4,5,8\\right]$， $S = \\left[0,1,2,1\\right]$。\n    2. $n = 4$， $B = \\left[1,2,3,4\\right]$， $S = \\left[\\right]$。\n    3. $n = 5$， $B = \\left[1,2,3,4,5\\right]$， $S = \\left[0,1,2,3,0,1,2,0,1,0\\right]$。\n    4. $n = 4$， $B = \\left[1,1,2,3\\right]$， $S = \\left[0,1,2,1\\right]$。\n    5. $n = 1$， $B = \\left[42\\right]$， $S = \\left[\\right]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的重建数组。这些数组以逗号分隔的列表形式包含在方括号中，每个数组本身也以方括号括起、逗号分隔的形式打印，且不含空格。例如，输出应类似于 $\\left[\\left[a_{0,0},a_{0,1},\\dots\\right],\\left[a_{1,0},a_{1,1},\\dots\\right],\\dots\\right]$。", "solution": "问题要求从一个最终的有序数组 $B$ 和一个由优化冒泡排序算法产生的按时间顺序排列的交换索引记录 $S$ 中，重建一个原始整数数组（记为 $A_0$）。任务的核心是逆转排序过程以恢复初始状态 $A_0$。这可以通过将由交换记录定义的置换的逆运算应用于最终数组 $B$ 来完成。\n\n让我们根据所提供的定义来形式化这个过程。原始数组为 $A_0$。排序过程涉及一系列 $k$ 次相邻交换，其中 $k$ 是记录在 $S = [i_0, i_1, \\dots, i_{k-1}]$ 中的总交换次数。令 $t_i$ 代表交换数组中索引 $i$ 和 $i+1$ 处元素的相邻对换算子。\n\n排序过程逐步转换数组。为使推导清晰，我们对交换序列使用从1开始的索引，令 $A^{(j)}$ 为第 $j$ 次交换后数组的状态（$j$ 从 $1$ 到 $k$）。\n初始状态为 $A^{(0)} = A_0$。\n第一次交换（在索引 $i_0$ 处）后的状态是 $A^{(1)} = t_{i_0}(A^{(0)})$。\n第二次交换（在索引 $i_1$ 处）后的状态是 $A^{(2)} = t_{i_1}(A^{(1)})$。\n这个过程对所有 $k$ 次交换都适用。最终的有序数组 $B$ 是最后一次交换后的状态：\n$$B = A^{(k)} = t_{i_{k-1}}(A^{(k-1)})$$\n通过反复代入先前状态的表达式，我们可以将 $B$ 表示为所有对换算子应用于原始数组 $A_0$ 的复合：\n$$B = t_{i_{k-1}}(t_{i_{k-2}}(\\dots(t_{i_0}(A_0))\\dots))$$\n用函数复合的语言来写，就是：\n$B = (t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0})(A_0)$\n让我们将整个排序过程产生的总置换 $P$ 定义为这个对换的复合：\n$P = t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0}$\n因此，原始数组 $A_0$ 和最终数组 $B$ 之间的关系是 $B = P(A_0)$。\n\n我们的目标是找到 $A_0$。为此，我们必须将逆置换 $P^{-1}$ 应用于等式两边：\n$P^{-1}(B) = P^{-1}(P(A_0))$\n$P^{-1}(B) = (P^{-1} \\circ P)(A_0)$\n由于 $P^{-1} \\circ P$ 是单位置换，我们得到：\n$A_0 = P^{-1}(B)$\n现在，我们必须找到逆置换 $P^{-1}$。复合算子 $(g \\circ f)^{-1}$ 的逆是 $f^{-1} \\circ g^{-1}$。将此规则应用于 $P$：\n$P^{-1} = (t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0})^{-1} = t_{i_0}^{-1} \\circ t_{i_1}^{-1} \\circ \\dots \\circ t_{i_{k-1}}^{-1}$\n相邻对换 $t_i$ 是一个交换两个元素的操作。应用两次相同的交换会将元素恢复到其原始位置。因此，任何相邻对换都是其自身的逆：$t_i \\circ t_i = \\text{identity}$（单位变换），这意味着 $t_i^{-1} = t_i$。\n\n将 $t_i^{-1} = t_i$ 代入 $P^{-1}$ 的表达式中，我们得到：\n$P^{-1} = t_{i_0} \\circ t_{i_1} \\circ \\dots \\circ t_{i_{k-1}}$\n最后，我们可以将 $A_0$ 的重建表示为：\n$A_0 = (t_{i_0} \\circ t_{i_1} \\circ \\dots \\circ t_{i_{k-1}})(B)$\n这个复合运算指示我们，要获得 $A_0$，必须从最终数组 $B$ 开始，并按 $t_{i_{k-1}}$、$t_{i_{k-2}}$... 直到 $t_{i_0}$ 的顺序应用这些对换。这等同于按时间倒序遍历给定的交换记录 $S = [i_0, i_1, \\dots, i_{k-1}]$，并应用每一次交换。\n\n重建 $A_0$ 的算法如下：\n$1$. 创建最终有序数组 $B$ 的一个可变副本。我们称之为 `current_array`。\n$2$. 从最后一个索引 $k-1$ 向下遍历到第一个索引 $0$，迭代交换索引列表 $S$。\n$3$. 对于在此反向迭代中遇到的每个交换索引 $i_j$，在 `current_array` 的索引 $i_j$ 处执行一次相邻交换。也就是说，交换元素 `current_array`$[i_j]$ 和 `current_array`$[i_j+1]$。\n$4$. 循环完成后，`current_array` 将持有原始数组 $A_0$ 的状态。\n\n此算法完全按照要求，从置换及其逆的第一性原理推导而来。它正确地逆转了记录的变换过程，以恢复初始状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the array reconstruction problem for a given suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (n, B, S)\n    # n: integer, length of the array\n    # B: list, the final sorted array\n    # S: list, the chronological list of swap indices\n    test_cases = [\n        (5, [1, 2, 4, 5, 8], [0, 1, 2, 1]),\n        (4, [1, 2, 3, 4], []),\n        (5, [1, 2, 3, 4, 5], [0, 1, 2, 3, 0, 1, 2, 0, 1, 0]),\n        (4, [1, 1, 2, 3], [0, 1, 2, 1]),\n        (1, [42], [])\n    ]\n\n    def reconstruct_array(n, B, S):\n        \"\"\"\n        Reconstructs the original array A0 from the final sorted array B and\n        the chronological swap record S.\n\n        Args:\n            n (int): The length of the array.\n            B (list): The final sorted array.\n            S (list): The chronological list of swap indices.\n\n        Returns:\n            list: The reconstructed original array A0.\n        \"\"\"\n        # Start with the final sorted array. Use a numpy array for mutability and\n        # to adhere to the specified environment.\n        current_array = np.array(B)\n\n        # To find the original array, we must reverse the sorting process.\n        # This is achieved by applying the swaps in the reverse chronological order\n        # to the final sorted array. The inverse of a swap is the swap itself.\n        for swap_index in reversed(S):\n            # temp = current_array[swap_index]\n            # current_array[swap_index] = current_array[swap_index + 1]\n            # current_array[swap_index + 1] = temp\n            \n            # A more Pythonic way to swap elements\n            current_array[swap_index], current_array[swap_index + 1] = \\\n                current_array[swap_index + 1], current_array[swap_index]\n\n        return current_array.tolist()\n\n    results = []\n    for case in test_cases:\n        n, B, S = case\n        original_array = reconstruct_array(n, B, S)\n        results.append(original_array)\n\n    # Format the results into the exact single-line string specified.\n    # e.g., [[a,b,c],[d,e],...]\n    formatted_results = []\n    for r in results:\n        formatted_results.append(f\"[{','.join(map(str, r))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3257578"}, {"introduction": "在掌握了冒泡排序的机械过程后，让我们将视野提升到对问题空间结构的分析。这个练习 [@problem_id:3257618] 提出了一个富有挑战性的问题：将一个代表最佳情况的有序数组，转变为一个代表最差情况的逆序数组，最少需要多少次“任意位置”的交换？解决这个问题需要将算法分析与离散数学中的置换理论联系起来。你将发现，答案并非简单的暴力计算，而是隐藏在一个关于排列循环分解的优雅结论之中，这将极大地锻炼你的抽象思维和数学建模能力。", "problem": "考虑一个包含 $n$ 个不同关键字的数组，需要使用冒泡排序的优化变体将其按非递减顺序排序。该算法从左到右逐轮比较相邻的元素对，当它们顺序错误时进行交换，并在任何一轮没有发生交换后立即提前终止。最佳情况输入被定义为任何使得算法在第一轮后就终止的输入。最坏情况输入被定义为任何使得算法执行最大轮数，且在数组变为有序之前每一轮都有交换发生的输入。\n\n单个“对换”操作在此定义为：在一次操作中交换数组中任意两个不同索引 $i$ 和 $j$ 处的元素（不限于相邻元素）。从一个最佳情况输入开始，确定要获得一个用于优化冒泡排序的最坏情况输入，所需执行的此类对换操作的最小次数。请用关于 $n$ 的闭式解析表达式来表示你的答案。无需进行四舍五入，也不涉及物理单位。", "solution": "该问题在算法分析和离散数学领域内提法明确且具有科学依据。所有术语要么是标准的，要么有明确定义，且前提条件是自洽且一致的。因此，该问题被认为是有效的，并且可以推导出解。\n\n首先，我们必须为所描述的优化冒泡排序算法精确地刻画最佳情况和最坏情况的输入。该数组由 $n$ 个不同的关键字组成，需要按非递减顺序排序。\n\n最佳情况输入被定义为算法在第一轮后终止的输入。这种情况发生当且仅当第一轮中交换次数为零。要实现这一点，每一对相邻元素都必须已经处于非递减顺序。由于所有关键字都不同，这意味着数组必须是严格按升序排序的。设不同的关键字集合为 $\\{k_1, k_2, \\dots, k_n\\}$，其中 $k_1  k_2  \\dots  k_n$。最佳情况输入是数组 $A_{best} = [k_1, k_2, \\dots, k_n]$。\n\n最坏情况输入被定义为算法执行最大轮数，且每一轮都有交换发生的输入。在冒泡排序的每一轮中，尚未在其最终排序位置的最大元素会被“冒泡”到其正确位置。经过 $p$ 轮后，数组中最大的 $p$ 个元素保证处于其最终排序位置。可能涉及交换的最大轮数是 $n-1$，此后整个数组都有序。为确保在这 $n-1$ 轮中的每一轮都发生交换，我们必须最大化其无序程度。当数组按逆序（降序）排序时，可以达到这个效果。在这种配置下，每对相邻元素都顺序错误，从而保证了第一轮中的交换次数达到最大。最大的元素 $k_n$ 从第一个位置开始，需要 $n-1$ 次相邻交换才能移动到最后一个位置。此轮过后，第二大的元素 $k_{n-1}$ 位于剩余未排序子数组的第一个位置，依此类推。交换将在第 $1, 2, \\dots, n-1$ 轮中发生。第 $n$ 轮会发现数组已有序，不执行任何交换，从而导致终止。因此，最坏情况输入是按逆序排序的数组：$A_{worst} = [k_n, k_{n-1}, \\dots, k_1]$。\n\n问题要求将 $A_{best}$ 转换为 $A_{worst}$ 所需的“对换”（交换任意两个不同索引 $i$ 和 $j$ 处的元素）的最小次数。不失一般性，我们可以用整数 $\\{1, 2, \\dots, n\\}$ 来表示这些不同的关键字。\n起始数组（最佳情况）是 $A_{best} = [1, 2, \\dots, n]$。\n目标数组（最坏情况）是 $A_{worst} = [n, n-1, \\dots, 1]$。\n\n这种转换对应于元素 $\\{1, 2, \\dots, n\\}$ 的一个排列 $\\pi$。在 $A_{best}$ 中位置 $i$ 处的元素是 $i$。这个元素在 $A_{worst}$ 中移动到位置 $n-i+1$。因此，该排列可以定义为 $\\pi(i) = n-i+1$，对于 $i \\in \\{1, 2, \\dots, n\\}$。\n\n在 $n$ 个元素上生成一个排列 $\\sigma$ 所需的最小交换次数（在排列理论中称为对换）由公式 $n - c(\\sigma)$ 给出，其中 $c(\\sigma)$ 是 $\\sigma$ 的循环分解中不相交循环的数量。我们的任务是找出我们的排列 $\\pi(i) = n-i+1$ 的不相交循环数量。\n\n让我们分析一下循环的结构。一个循环是通过重复应用 $\\pi$ 形成的。\n考虑一个元素 $i$：$\\pi(i) = n-i+1$。\n再次应用 $\\pi$：$\\pi(\\pi(i)) = \\pi(n-i+1) = n - (n-i+1) + 1 = n - n + i - 1 + 1 = i$。\n由于对所有 $i$ 都有 $\\pi(\\pi(i)) = i$，该排列是一个对合。这意味着其所有不相交循环的长度要么是 $1$（不动点），要么是 $2$（对换）。\n\n一个循环的形式是 $(i, \\pi(i)) = (i, n-i+1)$。\n一个元素 $i$ 是一个不动点（长度为 $1$ 的循环），如果 $i = \\pi(i)$，即 $i = n-i+1$。这可以简化为 $2i = n+1$，或 $i = \\frac{n+1}{2}$。\n一个元素 $i$ 是一个2-循环的一部分，如果 $i \\neq \\pi(i)$，即 $i \\neq \\frac{n+1}{2}$。\n\n我们通过考虑 $n$ 的奇偶性来分析循环的数量 $c(\\pi)$。\n\n情况1：$n$ 是偶数。\n令 $n = 2k$，其中 $k$ 是某个正整数。不动点的条件是 $i = \\frac{2k+1}{2} = k + \\frac{1}{2}$。由于 $i$ 必须是整数，所以没有不动点。所有元素都是形如 $(i, 2k-i+1)$ 的2-循环的一部分。\n这些对是：\n$(1, 2k)$\n$(2, 2k-1)$\n`...`\n$(k, k+1)$\n共有 $k$ 个这样的不相交2-循环。因此，循环总数为 $c(\\pi) = k = \\frac{n}{2}$。\n\n情况2：$n$ 是奇数。\n令 $n = 2k+1$，其中 $k$ 是某个非负整数。不动点的条件是 $i = \\frac{(2k+1)+1}{2} = \\frac{2k+2}{2} = k+1$。所以，元素 $k+1$ 是一个不动点，形成一个1-循环 $(k+1)$。\n剩下的 $n-1 = 2k$ 个元素形成 $k$ 个不相交的2-循环：\n$(1, 2k+1)$\n$(2, 2k)$\n`...`\n$(k, k+2)$\n循环总数是2-循环和1-循环的数量之和：$c(\\pi) = k + 1$。由于 $k = \\frac{n-1}{2}$，我们有 $c(\\pi) = \\frac{n-1}{2} + 1 = \\frac{n+1}{2}$。\n\n我们可以使用上取整函数统一 $c(\\pi)$ 的表达式：$c(\\pi) = \\lceil \\frac{n}{2} \\rceil$。\n如果 $n=2k$，$c(\\pi) = \\lceil \\frac{2k}{2} \\rceil = k = \\frac{n}{2}$。正确。\n如果 $n=2k+1$，$c(\\pi) = \\lceil \\frac{2k+1}{2} \\rceil = \\lceil k + \\frac{1}{2} \\rceil = k+1 = \\frac{n+1}{2}$。正确。\n\n最小对换次数 $S_n$ 是 $n - c(\\pi)$。\n$S_n = n - \\lceil \\frac{n}{2} \\rceil$\n\n我们来为这两种情况计算这个表达式：\n情况1：$n$ 是偶数 ($n=2k$)。\n$S_n = n - \\frac{n}{2} = \\frac{n}{2}$。\n\n情况2：$n$ 是奇数 ($n=2k+1$)。\n$S_n = n - \\frac{n+1}{2} = \\frac{2n - (n+1)}{2} = \\frac{n-1}{2}$。\n\n这两个结果可以用一个使用下取整函数的单一闭式表达式来表示：$S_n = \\lfloor \\frac{n}{2} \\rfloor$。\n如果 $n=2k$，$\\lfloor \\frac{2k}{2} \\rfloor = \\lfloor k \\rfloor = k = \\frac{n}{2}$。正确。\n如果 $n=2k+1$，$\\lfloor \\frac{2k+1}{2} \\rfloor = \\lfloor k + \\frac{1}{2} \\rfloor = k = \\frac{n-1}{2}$。正确。\n\n因此，将一个已排序的数组转换为一个逆序排序的数组所需的最小对换次数是 $\\lfloor \\frac{n}{2} \\rfloor$。", "answer": "$$\\boxed{\\left\\lfloor \\frac{n}{2} \\right\\rfloor}$$", "id": "3257618"}]}