{"hands_on_practices": [{"introduction": "二分搜索的威力远不止于检查元素是否存在。它的真正力量在于高效地在有序数据中定位插入点或边界。本练习将引导你从第一性原理出发，实现 `lower_bound` 和 `upper_bound` [@problem_id:3215126]，这两个基础操作是解决许多复杂问题的基石。通过分别实现迭代和递归版本，你将加深对循环不变量和搜索区间管理的理解。", "problem": "你必须编写一个完整的程序，对于由一个已排序数组和一个键组成的每个测试用例，计算两个插入索引，以在不使用任何库搜索或插入辅助函数的情况下保持非递减顺序。目标是推导并实现迭代和递归两种二分查找方法，每种方法都用于定位由单调谓词导出的边界索引。具体来说，给定一个长度为 $n$ 的整数有限序列 $A$，该序列在整数的标准全序下按非递减顺序排序，以及一个键 $x$，你必须计算：\n- 下界索引 $L$，定义为最小的索引 $i \\in \\{0,\\dots,n\\}$，使得在该位置 $i$ 插入 $x$ 能保持排序顺序，并且 $x$ 的位置不早于任何已存在的等于 $x$ 的元素。等价地，$L$ 是满足 $A[i] \\ge x$ 的最小索引 $i$，并约定在 $i = n$ 时该条件为真。\n- 上界索引 $U$，定义为最小的索引 $i \\in \\{0,\\dots,n\\}$，使得在该位置 $i$ 插入 $x$ 能保持排序顺序，并且 $x$ 的位置严格位于任何已存在的等于 $x$ 的元素之后。等价地，$U$ 是满足 $A[i]  x$ 的最小索引 $i$，并约定在 $i = n$ 时该条件为真。\n\n你必须使用以下基础从第一性原理推导出这两个索引：\n- 一个序列 $A$ 是按非递减顺序排序的，当且仅当对于所有索引 $i$ 和 $j$（其中 $0 \\le i  j  n$），我们有 $A[i] \\le A[j]$。\n- 对于任何固定的 $x$，在索引 $i \\in \\{0,\\dots,n-1\\}$ 上定义的谓词 $P(i):\\; A[i] \\ge x$ 和 $Q(i):\\; A[i]  x$，并通过 $P(n) = \\text{true}$ 和 $Q(n) = \\text{true}$ 进行扩展，在排序假设下单调（一旦为真，对于更大的 $i$ 总是为真）。\n\n基于这些，推导出一个二分查找算法，作为在索引的半开区间上进行的不变量驱动的搜索，通过将区间减半直到找到满足谓词的最小索引。实现：\n- 一个返回 $L$ 的迭代二分查找。\n- 一个返回 $U$ 的递归二分查找。\n\n不允许使用任何直接实现二分查找或插入计算的标准库函数。特别地，你不能调用任何等同于在标准库中计算下界或上界的函数。\n\n你的程序必须运行以下测试套件。每个测试用例是一对 $(A, x)$，其中 $A$ 按非递减顺序排序：\n- 情况1：$A = [1,3,3,5,7]$, $x = 3$。\n- 情况2：$A = [2,4,6]$, $x = 1$。\n- 情况3：$A = [2,4,6]$, $x = 9$。\n- 情况4：$A = [5,5,5,5]$, $x = 5$。\n- 情况5：$A = [1,2,4,5]$, $x = 3$。\n- 情况6：$A = []$, $x = 42$。\n- 情况7：$A = [10]$, $x = 10$。\n- 情况8：$A = [10]$, $x = 11$。\n- 情况9：$A = [10]$, $x = 9$。\n\n你的程序必须对每个用例应用迭代算法计算 $L$ 和递归算法计算 $U$，并将结果按顺序汇总到单个输出行中，格式如下：一个单一列表，其中每个元素是一个包含两个整数的列表 $[L,U]$，没有额外的空白，并且整个输出打印在同一行上。形式上，如果有 $m$ 个用例，输出一个编码为 $[[L_1,U_1],[L_2,U_2],\\dots,[L_m,U_m]]$ 的单行。\n\n所有答案都是整数；不涉及物理单位或角度。你可以使用大O表示法（Big O）分析时间复杂度，但最终输出仅为指定的整数对列表。", "solution": "该问题是有效的。这是一个来自数据结构和算法领域的良定义、有科学依据的问题。它不含任何无效标准，为推导和实现二分查找算法的两种变体提供了一套完整且一致的定义和要求。\n\n核心任务是在范围 $\\{0, \\dots, n\\}$ 中找到满足单调谓词的最小索引 $i$。如果对于任何索引 $i$ 和 $j$ 且 $i  j$，$P(i) \\implies P(j)$，则谓词 $P(i)$ 在一个排序序列上是单调的。这意味着如果谓词在某个索引处为真，那么它对于所有后续索引都为真。这个属性意味着真值序列 `[P(0), P(1), ..., P(n-1)]` 的形式将是 `[False, ..., False, True, ..., True]`。问题就是要找到第一个 `True` 的索引。我们通过将谓词在 $n$ 处定义为空真（vacuously true）来将其扩展到索引 $n$，确保在 $\\{0, \\dots, n\\}$ 范围内总存在一个“第一个真值”。\n\n这种结构非常适合二分查找。算法维护一个索引的候选区间 $[low, high)$，该区间保证包含目标索引。该区间被迭代地减半，直到其大小变为1，此时 $low$ 等于 $high$ 并指向满足谓词的第一个索引。\n\n让插入索引的搜索空间为从 $0$ 到 $n$ 的整数。我们定义一个半开搜索区间 $[low, high)$。我们的目标是找到满足给定谓词的最小索引 $k$。我们维持不变量，即答案 $k$ 包含在 $[low, high)$ 中。\n\n最初，整个搜索空间就是候选区间，因此我们设置 $low = 0$ 和 $high = n$。注意，索引 $n$ 是一个有效的插入点。循环或递归在 $low  high$ 时继续进行。\n\n在每一步中，我们计算一个中点 $mid = low + \\lfloor \\frac{high - low}{2} \\rfloor$。然后我们评估该索引处的谓词 $P(mid)$。\n- 如果 $P(mid)$ 为真，这意味着第一个真值可能在索引 $mid$ 或更早的索引处。因此，我们可以舍弃区间的右半部分 $[mid+1, high)$，并在 $[low, mid]$ 中继续搜索。我们通过设置 $high = mid$ 来实现这一点。\n- 如果 $P(mid)$ 为假，这意味着第一个真值必须在严格大于 $mid$ 的索引处。因此，我们可以舍弃区间的左半部分 $[low, mid]$，并在 $[mid+1, high)$ 中继续搜索。我们通过设置 $low = mid + 1$ 来做到这一点。\n\n当 $low = high$ 时，过程终止。此时，区间已缩小到一个点。这个值，$low$（或 $high$），就是使 $P(k)$ 为真的最小索引 $k$。\n\n**下界 (L) - 迭代实现**\n下界 $L$ 被定义为满足 $A[i] \\ge x$ 的最小索引 $i \\in \\{0, \\dots, n\\}$。这对应于查找第一个大于或等于 $x$ 的元素。\n\n谓词是 $P(i):\\; A[i] \\ge x$。对于一个非递减排序的数组 $A$，这个谓词是单调的。我们可以应用上面推导的通用二分查找算法来找到满足 $P(i)$ 的最小索引 $i$。问题指定了迭代实现。\n\n算法如下：\n1. 初始化 $low = 0$ 和 $high = n$。\n2. 当 $low  high$ 时：\n   a. 计算 $mid = low + (high - low) // 2$。\n   b. 如果 $A[mid] \\ge x$，目标索引在 $[low, mid]$ 中。设置 $high = mid$。\n   c. 如果 $A[mid]  x$，目标索引在 $[mid+1, high]$ 中。设置 $low = mid + 1$。\n3. 返回 $low$。\n\n**上界 (U) - 递归实现**\n上界 $U$ 被定义为满足 $A[i] > x$ 的最小索引 $i \\in \\{0, \\dots, n\\}$。这对应于找到严格在所有等于 $x$ 的元素之后的插入点。\n\n谓词是 $Q(i):\\; A[i] > x$。对于一个非递减排序的数组 $A$，这个谓词也是单调的。我们应用相同的二分查找逻辑，但按照规定使用递归实现。\n\n递归函数，例如 `search(low, high)`，将是：\n1. 基本情况：如果 $low \\ge high$，区间为空或只有一个点。返回 $low$。\n2. 递归步骤：\n   a. 计算 $mid = low + (high - low) // 2$。\n   b. 如果 $A[mid] > x$，目标索引在 $[low, mid]$ 中。递归调用 `search(low, mid)`。\n   c. 如果 $A[mid] \\le x$，目标索引在 $[mid+1, high]$ 中。递归调用 `search(mid + 1, high)`。\n\n一个包装函数将用完整区间 `search(0, n)` 来启动搜索。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the binary search problem for all test cases.\n    Derives and implements iterative lower_bound and recursive upper_bound.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 3, 3, 5, 7], 3),\n        ([2, 4, 6], 1),\n        ([2, 4, 6], 9),\n        ([5, 5, 5, 5], 5),\n        ([1, 2, 4, 5], 3),\n        ([], 42),\n        ([10], 10),\n        ([10], 11),\n        ([10], 9),\n    ]\n\n    def find_lower_bound_iterative(A, x):\n        \"\"\"\n        Computes the lower bound L, the smallest index i such that A[i] >= x.\n        This is an iterative implementation of binary search.\n        The search space is the half-open interval [low, high).\n        \"\"\"\n        n = len(A)\n        low, high = 0, n\n        # Invariant: The answer is in the interval [low, high).\n        # All indices k  low have A[k]  x.\n        while low  high:\n            mid = low + (high - low) // 2\n            # Predicate: A[mid] >= x\n            if A[mid] >= x:\n                # The element at mid satisfies the condition.\n                # The first occurrence could be at mid or to the left.\n                # Thus, we narrow the search to [low, mid].\n                high = mid\n            else:  # A[mid]  x\n                # The element at mid does not satisfy the condition.\n                # The first occurrence must be to the right of mid.\n                # Thus, we narrow the search to [mid + 1, high).\n                low = mid + 1\n        # When the loop terminates, low == high, which is the first index\n        # where the predicate A[i] >= x is true.\n        return low\n\n    def find_upper_bound_recursive(A, x):\n        \"\"\"\n        Wrapper function to compute the upper bound U, the smallest index i\n        such that A[i] > x. It initiates the recursive search.\n        \"\"\"\n        n = len(A)\n        \n        def _search(low, high):\n            \"\"\"\n            Recursive helper function for binary search.\n            \"\"\"\n            # Base case: When the interval is empty or a single point,\n            # low is the answer.\n            if low >= high:\n                return low\n            \n            mid = low + (high - low) // 2\n            # Predicate: A[mid] > x\n            if A[mid] > x:\n                # The element at mid satisfies the condition.\n                # The first occurrence could be at mid or to the left.\n                # Recurse on the interval [low, mid].\n                return _search(low, mid)\n            else:  # A[mid] = x\n                # The element at mid does not satisfy the condition.\n                # The first occurrence must be to the right of mid.\n                # Recurse on the interval [mid + 1, high).\n                return _search(mid + 1, high)\n\n        return _search(0, n)\n\n    results = []\n    for A, x in test_cases:\n        # Per problem, compute L iteratively and U recursively.\n        L = find_lower_bound_iterative(A, x)\n        U = find_upper_bound_recursive(A, x)\n        results.append([L, U])\n\n    # Format the final output string to exactly match [[L1,U1],[L2,U2],...]\n    # without any extra whitespace as specified.\n    formatted_pairs = []\n    for pair in results:\n        formatted_pairs.append(f\"[{pair[0]},{pair[1]}]\")\n    \n    final_output = f\"[{','.join(formatted_pairs)}]\"\n    print(final_output)\n\n\nsolve()\n```", "id": "3215126"}, {"introduction": "在掌握了 `lower_bound` 和 `upper_bound` 的基础上，我们可以解决一个常见的实际问题：统计一个元素在含有重复项的排序数组中出现的次数。通过使用边界查找技巧定位元素的第一个和最后一个出现位置，我们可以高效地计算出总数 [@problem_id:3215120]。这个练习将展示如何将基础的边界查找算法组合起来，以 $\\mathcal{O}(\\log n)$ 的时间复杂度解决问题，远优于朴素的线性扫描方法。", "problem": "给定一个在全序集上长度为 $n$ 的有限序列 $A$，以一个非递减有序数组的形式表示。对于一个查询键 $k$，定义其出现总次数 $\\mathrm{count}(A,k)$ 为集合 $\\{ i \\mid 0 \\le i  n \\text{ and } A[i] = k \\}$ 的基数。你的任务是设计并实现一个程序，利用二分搜索的基本原理——即通过利用全序关系的比较来反复将搜索区间减半——来计算多个测试用例的 $\\mathrm{count}(A,k)$。实现必须遵循以下所有要求。\n\n- 使用以下基本原理：一个全序关系对任意一对元素 $x$ 和 $y$ 导出三分性，使得 $x  y$、$x = y$ 或 $x > y$ 中有且仅有一个成立；此外，当 $A$ 按非递减顺序排序时，若 $i  j$ 则有 $A[i] \\le A[j]$。基于此，二分搜索维护一个索引区间 $[L,R]$，并在中点 $M = \\left\\lfloor \\dfrac{L+R}{2} \\right\\rfloor$ 处将 $A[M]$ 与 $k$进行比较，以舍弃一半的搜索空间，同时保持关于 $k$ 可能出现位置的不变性。\n- 实现两个从此基础派生出的子程序：\n  1. 一个迭代二分搜索，返回第一个满足 $A[i_{\\min}] = k$ 的索引 $i_{\\min}$（如果存在），否则返回 $-1$。此搜索必须是纯迭代的。\n  2. 一个递归二分搜索，返回最后一个满足 $A[i_{\\max}] = k$ 的索引 $i_{\\max}$（如果存在），否则返回 $-1$。此搜索必须是纯递归的。\n- 按如下方式计算 $\\mathrm{count}(A,k)$：如果 $i_{\\min} = -1$，则 $\\mathrm{count}(A,k) = 0$；否则 $\\mathrm{count}(A,k) = i_{\\max} - i_{\\min} + 1$。\n- 程序不得执行任何与 $n$ 成正比的线性扫描来定位边界；它必须依靠二分搜索逻辑来找到两个边界。\n\n你的程序必须作为一个无输入的自包含脚本运行。它必须计算以下测试套件的结果，并打印一行包含方括号内的、由逗号分隔的整数列表。对于每个测试用例，输出是对应的 $\\mathrm{count}(A,k)$ 值。\n\n测试套件：\n- 测试用例 1：$A = [1, 1, 2, 2, 2, 3, 4]$, $k = 2$\n- 测试用例 2：$A = [1, 2, 3, 4]$, $k = 5$\n- 测试用例 3：$A = [7, 7, 7, 7, 7]$, $k = 7$\n- 测试用例 4：$A = [10]$, $k = 10$\n- 测试用例 5：$A = [10]$, $k = 9$\n- 测试用例 6：$A = []$ (空数组), $k = 1$\n- 测试用例 7：$A = [2, 2, 2, 3, 4, 5]$, $k = 2$\n- 测试用例 8：$A = [1, 1, 3, 4, 4, 4]$, $k = 4$\n- 测试用例 9：$A = [1, 2, 3, 3, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8]$, $k = 3$\n- 测试用例 10：$A = [-5, -3, -3, -3, -1, 0, 0, 1]$, $k = -3$\n\n程序的正确性、效率和边界情况处理能力将被评估。每个测试用例的预期渐近运行时间为每次边界搜索 $\\mathcal{O}(\\log n)$，其中迭代部分的总额外空间为 $\\mathcal{O}(1)$，递归部分的调用栈深度为 $\\mathcal{O}(\\log n)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表，例如 $[r_1,r_2,\\dots,r_{10}]$，其中 $r_i$ 是测试用例 $i$ 的整数结果。", "solution": "所述问题是有效的。它构成了一个根植于计算机科学基本原理的、定义明确的算法挑战，特别是关于在排序数据结构上的搜索算法。该问题具有科学依据，内部一致，并包含得出唯一可验证解所需的所有信息。目标是通过使用二分搜索的两种不同变体——一种迭代式和一种递归式——找到键 $k$ 在排序数组 $A$ 中首次和末次出现的索引，从而计算其出现次数。\n\n其基本原理是，对于一个排序数组 $A$，对于任意索引 $i  j$，属性 $A[i] \\le A[j]$ 使得高效搜索成为可能。标准的二分搜索可以找到键的*某个*出现位置，但不一定是第一个或最后一个。为了找到连续相同元素块的边界，必须修改标准算法。\n\n**1. 迭代搜索首次出现位置 ($i_{\\min}$)**\n\n为了找到第一个满足 $A[i_{\\min}] = k$ 的索引 $i_{\\min}$，我们实现一个迭代二分搜索。该算法维护一个索引搜索区间 $[L, R]$，其中 $n$ 是数组 $A$ 的长度，该区间初始化为 $[0, n-1]$。一个变量 `first_occurrence_index` 用于存储目前找到的最左侧 $k$ 的出现位置的索引，并初始化为 $-1$。搜索循环在 $L \\le R$ 的条件下持续进行。\n\n在每次迭代中，计算中点 $M = \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$。$A[M]$ 与 $k$ 之间的比较决定了如何缩减搜索空间：\n- 如果 $A[M]  k$，则 $k$ 的任何出现位置都必须位于区间的右半部分。因此，通过设置 $L = M + 1$ 来更新搜索空间。\n- 如果 $A[M] > k$，则 $k$ 的任何出现位置都必须位于左半部分。通过设置 $R = M - 1$ 来更新搜索空间。\n- 关键的修改发生在 $A[M] = k$ 时。这个索引 $M$ 是首次出现的候选位置。我们通过设置 `first_occurrence_index = M` 来记录它。然而，左侧可能存在更早的出现位置。因此，我们通过设置 $R = M - 1$ 来继续只在左子区间中搜索。\n\n这个过程保证了每当我们找到一个 $k$ 的实例时，都会积极地向更小的索引搜索。循环终止前 `first_occurrence_index` 中记录的最后一个索引将是 $k$ 的首次出现位置。如果未找到该键，该变量将保持为 $-1$。\n\n**2. 递归搜索末次出现位置 ($i_{\\max}$)**\n\n为了找到最后一个满足 $A[i_{\\max}] = k$ 的索引 $i_{\\max}$，指定使用递归二分搜索。其逻辑与搜索 $i_{\\min}$ 的逻辑对称。递归函数在数组的子区间 $[L, R]$ 上操作。\n\n- 递归的基准情况是当 $L > R$ 时。这表示区间为空，其中不可能找到 $k$ 的出现位置，因此函数返回 $-1$。\n- 在递归步骤中，我们计算中点 $M = \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$。\n- 如果 $A[M] > k$，末次出现位置（如果存在）必定在左子区间。函数在 $[L, M-1]$ 上进行递归。\n- 如果 $A[M]  k$，末次出现位置（如果存在）必定在右子区间。函数在 $[M+1, R]$ 上进行递归。\n- 如果 $A[M] = k$，我们找到了在索引 $M$ 处的一个出现。这是末次出现的候选位置。为了确定是否存在更晚的出现，函数在右子区间 $[M+1, R]$ 上递归调用自身。设此调用的结果为 `result_from_right`。如果 `result_from_right` 不等于 $-1$，意味着找到了一个更晚的出现，那个索引就是应返回的正确索引。如果 `result_from_right` 等于 $-1$，则确认 $M$ 的右侧不存在出现，使得 $M$ 成为末次出现的索引。\n\n**3. $\\mathrm{count}(A,k)$ 的计算**\n\n总次数由两个搜索子程序的结果得出。\n首先，执行迭代搜索以找到 $i_{\\min}$。\n- 如果返回值为 $i_{\\min} = -1$，则键 $k$ 不存在于数组 $A$ 中。因此，$\\mathrm{count}(A,k)$ 为 $0$。\n- 如果 $i_{\\min} \\ne -1$，则该键存在。接着我们执行递归搜索以找到 $i_{\\max}$。因为该键存在，这个搜索保证能找到一个有效的索引。总出现次数是包含性区间 $[i_{\\min}, i_{\\max}]$ 中元素的数量，计算方式为 $\\mathrm{count}(A,k) = i_{\\max} - i_{\\min} + 1$。\n\n该设计遵守了所有问题约束。每次搜索（查找 $i_{\\min}$ 和 $i_{\\max}$）的时间复杂度为 $\\mathcal{O}(\\log n)$，因为搜索区间在每一步都被减半。查找 $i_{\\min}$ 的迭代搜索使用 $\\mathcal{O}(1)$ 的辅助空间。查找 $i_{\\max}$ 的递归搜索在调用栈上使用 $\\mathcal{O}(\\log n)$ 的辅助空间，这对应于递归的最大深度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_first_iterative(A: np.ndarray, k: int) -> int:\n    \"\"\"\n    Finds the first occurrence of key k in a sorted array A using iterative binary search.\n    Returns the index of the first occurrence, or -1 if not found.\n    \"\"\"\n    n = len(A)\n    low, high = 0, n - 1\n    first_occurrence_index = -1\n\n    while low = high:\n        # Use floor division, though standard in Python 3\n        mid = low + (high - low) // 2\n        \n        if A[mid]  k:\n            low = mid + 1\n        elif A[mid] > k:\n            high = mid - 1\n        else:  # A[mid] == k\n            first_occurrence_index = mid\n            # Try to find an earlier occurrence in the left half\n            high = mid - 1\n            \n    return first_occurrence_index\n\ndef _find_last_recursive_helper(A: np.ndarray, k: int, low: int, high: int) -> int:\n    \"\"\"\n    Helper function for finding the last occurrence of key k recursively.\n    \"\"\"\n    if low > high:\n        return -1\n\n    mid = low + (high - low) // 2\n\n    if A[mid] > k:\n        return _find_last_recursive_helper(A, k, low, mid - 1)\n    elif A[mid]  k:\n        return _find_last_recursive_helper(A, k, mid + 1, high)\n    else:  # A[mid] == k\n        # This is a potential last occurrence. Check if a later one exists.\n        found_later = _find_last_recursive_helper(A, k, mid + 1, high)\n        if found_later != -1:\n            return found_later  # A later occurrence was found\n        else:\n            return mid # This must be the last occurrence\n\ndef find_last_recursive(A: np.ndarray, k: int) -> int:\n    \"\"\"\n    Finds the last occurrence of key k in a sorted array A using recursive binary search.\n    Returns the index of the last occurrence, or -1 if not found.\n    \"\"\"\n    n = len(A)\n    return _find_last_recursive_helper(A, k, 0, n - 1)\n\ndef count_occurrences(A: np.ndarray, k: int) -> int:\n    \"\"\"\n    Computes the total number of occurrences of k in A.\n    \"\"\"\n    i_min = find_first_iterative(A, k)\n    \n    if i_min == -1:\n        return 0\n    \n    # If the key exists, find its last occurrence\n    i_max = find_last_recursive(A, k)\n    \n    return i_max - i_min + 1\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (np.array([1, 1, 2, 2, 2, 3, 4], dtype=int), 2),\n        # Case 2\n        (np.array([1, 2, 3, 4], dtype=int), 5),\n        # Case 3\n        (np.array([7, 7, 7, 7, 7], dtype=int), 7),\n        # Case 4\n        (np.array([10], dtype=int), 10),\n        # Case 5\n        (np.array([10], dtype=int), 9),\n        # Case 6\n        (np.array([], dtype=int), 1),\n        # Case 7\n        (np.array([2, 2, 2, 3, 4, 5], dtype=int), 2),\n        # Case 8\n        (np.array([1, 1, 3, 4, 4, 4], dtype=int), 4),\n        # Case 9\n        (np.array([1, 2, 3, 3, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8], dtype=int), 3),\n        # Case 10\n        (np.array([-5, -3, -3, -3, -1, 0, 0, 1], dtype=int), -3),\n    ]\n\n    results = []\n    for A, k in test_cases:\n        result = count_occurrences(A, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3215120"}, {"introduction": "现在，让我们将二分搜索的技巧应用于一种非标准但结构化的场景：旋转排序数组。这种情况破坏了标准排序数组的简单单调性，要求我们调整比较逻辑以适应新的结构。本练习 [@problem_id:3214996] 将挑战你识别数组局部隐藏的有序性，并据此正确地收缩搜索空间，特别是在处理由重复元素带来的模糊情况时，这将极大锻炼你的问题分析与算法设计能力。", "problem": "给你一个有限的整数数组，该数组最初按非递减顺序排序，然后旋转了未知的步数。允许重复元素。形式上，设 $A$ 是一个长度为 $n \\ge 1$ 的数组，它是由一个非递减数组 $B$ 旋转 $k$ 个位置产生的，其中 $k \\in \\{0,1,\\dots,n-1\\}$。等价地，存在一个 $k$，使得对于所有 $i \\in \\{0,1,\\dots,n-1\\}$，都有 $A[i] = B[(i+k) \\bmod n]$。任务是设计并实现两个过程，一个迭代的和一个递归的，每个过程都返回旋转点的索引。\n\n旋转点的定义：将旋转点索引 $r$ 定义为最小的索引 $i \\in \\{0,1,\\dots,n-1\\}$，使得 $A[i]$ 是 $A$ 的全局最小值。如果有多个索引达到相同的全局最小值，$r$ 是其中最小的一个。如果数组未旋转（即 $k = 0$），则 $r = 0$。这个定义等价于最小元素的索引，并附加了取最左侧出现位置的平局决胜规则。\n\n推导基础：仅使用以下关于数组和顺序的基本事实来推导这两个过程。\n- 数组 $A$ 是两个非递减子数组 $A[0],A[1],\\dots,A[r-1]$ 和 $A[r],A[r+1],\\dots,A[n-1]$ 的串联，并且对于所有 $i$ 都有 $A[r] \\le A[i]$。\n- 对于任何索引 $l$ 和 $r$（其中 $0 \\le l \\le r \\le n-1$），中点索引 $m = \\left\\lfloor \\dfrac{l+r}{2} \\right\\rfloor$ 将子数组 $A[l],A[l+1],\\dots,A[r]$ 分为两半。\n- 在非递减和旋转的假设下，形如 $A[m] \\le A[r]$、$A[m]  A[r]$ 和 $A[m] > A[r]$ 的比较揭示了两半之间的相对顺序。\n\n你的程序必须实现两个函数，它们都返回所定义的索引 $r$：\n- 一个基于迭代二分搜索的函数，仅使用 $O(1)$ 的额外空间。\n- 一个基于递归二分搜索的函数，每次递归调用最多探索一半，在非退化情况下使用 $O(\\log n)$ 的栈深度；请注意，在存在许多相等元素的情况下，比较可能无法得出结论，并迫使出现最坏情况下的 $O(n)$ 行为。\n\n输入模型：没有外部输入。请使用以下固定的测试数组集 $A^{(t)}$，$t \\in \\{1,2,\\dots,8\\}$：\n\n- $A^{(1)} = [15,18,2,3,6,12]$，预期 $r^{(1)} = 2$。\n- $A^{(2)} = [3,4,5,2,2,2]$，预期 $r^{(2)} = 3$。\n- $A^{(3)} = [1,1,1,1]$，预期 $r^{(3)} = 0$。\n- $A^{(4)} = [10]$，预期 $r^{(4)} = 0$。\n- $A^{(5)} = [2,2,3,4,5,1,1]$，预期 $r^{(5)} = 5$。\n- $A^{(6)} = [4,5,6,7,0,1,2,2,2]$，预期 $r^{(6)} = 4$。\n- $A^{(7)} = [2,2,2,3,4,5,1,2]$，预期 $r^{(7)} = 6$。\n- $A^{(8)} = [0,0,1,2,2,2,3]$，预期 $r^{(8)} = 0$。\n\n正确性要求：对于每个 $t \\in \\{1,2,\\dots,8\\}$，你的迭代函数和递归函数都必须返回相同的索引 $r^{(t)}$。如果它们对于任何测试数组的结果不一致，你的程序必须检测到这种差异并以运行时错误终止。\n\n输出规范：你的程序应该产生单行输出，包含一个类JSON的列表，其中每个元素对应一个测试数组，并且本身是一个双元素列表 $[x^{(t)}_{\\mathrm{it}}, x^{(t)}_{\\mathrm{rec}}]$，分别是由迭代和递归过程返回的索引。例如，输出格式必须严格为\n$[[x^{(1)}_{\\mathrm{it}},x^{(1)}_{\\mathrm{rec}}],[x^{(2)}_{\\mathrm{it}},x^{(2)}_{\\mathrm{rec}}],\\dots,[x^{(8)}_{\\mathrm{it}},x^{(8)}_{\\mathrm{rec}}]]$\n不含空格。每个 $x^{(t)}_{\\mathrm{it}}$ 和 $x^{(t)}_{\\mathrm{rec}}$ 都是一个整数。\n\n你的实现必须是一个完整的、可在现代编程语言中运行的程序，没有外部输入，它会以指定格式精确打印一行，并使用提供的测试套件。不涉及物理单位、角度或百分比，因此不需要单位说明。", "solution": "问题陈述在形式上是有效的。它是自洽的、数学上是适定的，并基于已确立的算法设计原则。目标是设计并实现两个算法，一个迭代，一个递归，以在可能包含重复元素的、经过旋转的非递减排序数组中找到旋转点。\n\n旋转点 $r$ 被定义为最小的索引 $i \\in \\{0, 1, \\dots, n-1\\}$，使得元素 $A[i]$ 是数组 $A$ 的全局最小值。即使存在多个相等的最小值，此定义也能唯一地确定目标索引。\n\n问题的核心在于调整二分搜索算法。标准的二分搜索作用于一个完全排序的数组。在这里，数组 $A$ 由两个串联的非递减子数组组成。设数组长度为 $n$。如果旋转点在索引 $r$ 处，则第一个子数组是 $A[0..r-1]$，第二个是 $A[r..n-1]$。只要旋转是非平凡的（即 $r > 0$），第一个子数组中的所有元素都大于或等于第二个子数组中的任何元素。任务是高效地定位索引 $r$，它标志着第二个子数组的开始。\n\n我们的策略是维护一个搜索区间 $[l, r]$（这里的变量 $r$ 指的是右边界，而不是旋转点），并保证该区间包含旋转点。我们通过比较中点元素 $A[m]$ 与其中一个边界上的元素（例如 $A[r]$）来反复缩小这个区间。\n\n设搜索区间由索引 $l$（左）和 $r$（右）定义。初始时，$l=0$ 且 $r=n-1$。中点是 $m = \\lfloor(l+r)/2\\rfloor$。丢弃搜索区间的左半部分还是右半部分的决定基于以下情况分析：\n\n1.  **情况 $A[m]  A[r]$**：这个不等式意味着子数组 $A[m..r]$ 是按非递减顺序排序的。如果旋转点在区间 $(m, r]$ 内，那么数值上会出现一个“下降”，这将与 $A[m..r]$ 的有序性相矛盾。因此，旋转点必须在索引 $m$ 或其左侧。我们可以安全地舍弃区间 $(m, r]$ 的右半部分，并将搜索范围限制在 $[l, m]$。我们更新右边界：$r \\leftarrow m$。\n\n2.  **情况 $A[m] > A[r]$**：这个不等式表明从 $m$ 到 $r$ 的子数组不是单调的。“下降”必定发生在索引 $m$ 和 $r$ 之间。具体来说，旋转点必须位于区间 $(m, r]$ 内。因此，我们可以舍弃区间 $[l, m]$ 的左半部分，并在 $[m+1, r]$ 中继续搜索。我们更新左边界：$l \\leftarrow m+1$。\n\n3.  **情况 $A[m] = A[r]$**：这是由重复元素引入的模糊情况。我们无法明确确定旋转点在 $m$ 的左侧还是右侧。例如，在数组 $[1, 0, 1, 1, 1]$ 中，当 $l=0, r=4, m=2$ 时，我们有 $A[m]=A[r]=1$，但最小值在索引 $1$ 处（在 $m$ 的左侧）。在数组 $[1, 1, 1, 0, 1]$ 中，当 $l=0, r=4, m=2$ 时，我们同样有 $A[m]=A[r]=1$，但最小值在索引 $3$ 处（在 $m$ 的右侧）。\n    为了解决这种模糊性，我们利用旋转点是最小值的*最小*索引这一定义。如果旋转点在索引 $r$ 处，它必须是该最小值的首次出现。然而，在 $m  r$ 的条件下，$A[m]=A[r]$ 意味着 $A[r]$ 不是其值的首次出现。因此，索引 $r$ 不可能是旋转点。我们可以通过将搜索空间缩小到 $[l, r-1]$ 来安全地舍弃索引 $r$ 处的元素。我们更新右边界：$r \\leftarrow r-1$。这一步确保了正确性，但在最坏情况下（例如，像 $[1, 1, \\dots, 1]$ 这样的数组），可能导致线性搜索行为，使性能从 $O(\\log n)$ 退化到 $O(n)$。\n\n当 $l=r$ 时，搜索过程终止。此时，搜索区间已收敛到单个索引，根据我们的不变量，该索引必为旋转点。\n\n**迭代实现**\n上述逻辑可以使用一个 `while` 循环实现，只要 $l  r$ 就继续。变量 $l$ 和 $r$ 根据三种情况在循环内部更新。这种方法使用 $O(1)$ 的额外空间。\n\n**递归实现**\n相同的逻辑可以递归地表达。定义一个函数，比如 `find(A, l, r)`。递归的基线条件是 $l \\ge r$，此时返回 $l$。在递归步骤中，函数计算 $m$，然后在其缩小的区间上调用自身：`find(A, l, m)`、`find(A, m+1, r)` 或 `find(A, l, r-1)`。这种方法在调用栈上维护其状态，大多数情况下空间复杂度为 $O(\\log n)$，但在最坏情况下由于第三种条件，空间复杂度为 $O(n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_rotation_point_iterative(arr):\n    \"\"\"\n    Finds the rotation point of a rotated sorted array using an iterative binary search.\n    The rotation point is the index of the minimum element.\n    If there are multiple minima, it's the index of the first one.\n    \n    Args:\n        arr (list or np.ndarray): The rotated sorted array.\n        \n    Returns:\n        int: The index of the rotation point.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return -1 # Or raise an error for empty array\n    if n == 1:\n        return 0\n        \n    l, r = 0, n - 1\n    \n    # The loop continues as long as the search space has more than one element.\n    # The invariant is that the rotation point is always in the range [l, r].\n    while l  r:\n        m = l + (r - l) // 2\n        \n        # Case 1: The subarray from m to r is sorted.\n        # The minimum must be in the left part, including m.\n        if arr[m]  arr[r]:\n            r = m\n        # Case 2: The \"drop\" is in the right part (m, r].\n        # The minimum must be in the right part, after m.\n        elif arr[m] > arr[r]:\n            l = m + 1\n        # Case 3 (ambiguous): arr[m] == arr[r].\n        # We can't decide which half contains the minimum.\n        # However, we can safely discard arr[r] because if it were the\n        # rotation point (the first minimum), arr[m] couldn't be equal to it.\n        # So, we shrink the search space from the right.\n        else: # arr[m] == arr[r]\n            r = r - 1\n            \n    # When the loop terminates, l == r, which is the rotation point.\n    return l\n\ndef _find_recursive_helper(arr, l, r):\n    \"\"\"Helper for the recursive implementation.\"\"\"\n    # Base case: search space has converged to one element.\n    if l >= r:\n        return l\n        \n    m = l + (r - l) // 2\n    \n    if arr[m]  arr[r]:\n        # Recurse on the left half [l, m].\n        return _find_recursive_helper(arr, l, m)\n    elif arr[m] > arr[r]:\n        # Recurse on the right half [m+1, r].\n        return _find_recursive_helper(arr, m + 1, r)\n    else: # arr[m] == arr[r]\n        # Ambiguous case, recurse on [l, r-1].\n        return _find_recursive_helper(arr, l, r - 1)\n\ndef find_rotation_point_recursive(arr):\n    \"\"\"\n    Finds the rotation point of a rotated sorted array using a recursive binary search.\n    This function is a wrapper for the main recursive logic.\n    \n    Args:\n        arr (list or np.ndarray): The rotated sorted array.\n        \n    Returns:\n        int: The index of the rotation point.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return -1\n    return _find_recursive_helper(arr, 0, n - 1)\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([15, 18, 2, 3, 6, 12]),      # expected r = 2\n        ([3, 4, 5, 2, 2, 2]),       # expected r = 3\n        ([1, 1, 1, 1]),             # expected r = 0\n        ([10]),                     # expected r = 0\n        ([2, 2, 3, 4, 5, 1, 1]),     # expected r = 5\n        ([4, 5, 6, 7, 0, 1, 2, 2, 2]), # expected r = 4\n        ([2, 2, 2, 3, 4, 5, 1, 2]),   # expected r = 6\n        ([0, 0, 1, 2, 2, 2, 3]),     # expected r = 0\n    ]\n\n    results = []\n    for case_list in test_cases:\n        # Per problem specification, use numpy array\n        case_arr = np.array(case_list)\n        \n        # Calculate result from both iterative and recursive functions\n        r_it = find_rotation_point_iterative(case_arr)\n        r_rec = find_rotation_point_recursive(case_arr)\n\n        # Correctness requirement check\n        if r_it != r_rec:\n            raise RuntimeError(\n                f\"Mismatch for case {case_list}: iterative={r_it}, recursive={r_rec}\"\n            )\n        \n        results.append([r_it, r_rec])\n\n    # Final print statement in the exact required format: [[r1_it,r1_rec],[r2_it,r2_rec],...]\n    # Using str() and replace() to achieve the no-space JSON-like format\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3214996"}]}