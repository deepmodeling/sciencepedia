{"hands_on_practices": [{"introduction": "算法的真正力量在于其适应性。第一个练习将挑战你将计数排序从简单的整数数组推广开来。你将实现一个稳定版本，通过使用“键函数”提取可排序的整数键，来对任何对象集合进行排序。这项技术是构建灵活且可复用的排序工具的基础。[@problem_id:3224624]", "problem": "设计并实现一个稳定的排序过程，该过程通过使用键提取函数来改编计数排序，使其能够对任意元素的数组进行操作。设 $A$ 为一个元素的有限序列，并设 $\\mathrm{key\\_func}$ 为一个函数，使得对于每个元素 $x \\in A$，$\\mathrm{key\\_func}(x)$ 都是某个给定的非负整数 $k$ 的闭区间 $[0,k]$ 内的一个整数。您的任务是从第一性原理出发，推导出一个稳定的算法，该算法利用键的有界整数范围，根据由 $\\mathrm{key\\_func}$ 计算出的键对 $A$ 进行非递减排序。\n\n您的推导必须基于以下基本事实和定义：\n- 在随机存取机器（RAM）模型下，数组支持随机存取和索引，每次访问的时间是确定性的。\n- 一个有限离散值集合中各个值的出现频率可以通过计数来制表，而累积总和可以用于计算分组放置的位置。\n- 一个排序算法是稳定的，当且仅当任何两个具有相等键的元素在输出中出现的相对顺序与它们在输入中出现的相对顺序相同。\n- 对于任何由 $k$ 界定的非负整数有限序列，其键的多重集可以由一个长度为 $k+1$ 的频率数组表示。\n\n您必须构建该算法，使其满足：\n- 利用计数能力统计 $[0,k]$ 中每个可能键的出现次数，并利用累积信息来确定性地放置元素。\n- 保持上文定义的稳定性属性。\n- 运行时间与 $|A| + k$ 成正比，使用的额外空间与 $|A| + k$ 成正比。\n\n程序规范：\n- 实现一个函数 $\\text{sort}(A,\\mathrm{key\\_func},k)$，它返回一个由 $A$ 中元素组成的新序列，该序列根据 $\\mathrm{key\\_func}(x)$ 的非递减顺序排序，并保持键相等元素间的输入顺序。\n- 为进行验证，请将您的函数应用于以下测试套件。在每种情况下，$A$ 都是一个由对 $(v,i)$ 组成的列表，其中 $v$ 是与键函数相关的值，$i$ 是一个唯一标识符。对于每个测试用例，所需的输出是经过稳定的基于键的排序后得到的标识符 $i$ 的列表。测试用例如下：\n  1. 具有重复键的一般情况：$A_1 = [(3,101),(1,102),(3,103),(0,104),(5,105),(1,106),(2,107),(5,108),(4,109),(2,110)]$，$\\mathrm{key\\_func}_1(v,i) = v$，$k_1 = 5$。\n  2. 边界情况，$k=0$（所有键都相同）：$A_2 = [(7,201),(3,202),(9,203),(1,204),(7,205),(3,206)]$，$\\mathrm{key\\_func}_2(v,i) = 0$，$k_2 = 0$。\n  3. 边缘情况，输入为空：$A_3 = [\\ ]$，$\\mathrm{key\\_func}_3(v,i) = 0$，$k_3 = 3$。\n  4. 对字符串的非平凡键函数：$A_4 = [(\\text{\"delta\"},301),(\\text{\"mu\"},302),(\\text{\"epsilon\"},303),(\\text{\"pi\"},304),(\\text{\"alpha\"},305),(\\text{\"beta\"},306),(\\text{\"omicron\"},307)]$，$\\mathrm{key\\_func}_4(v,i) = |v| \\bmod 4$，其中 $|v|$ 表示字符串 $v$ 的长度，且 $k_4 = 3$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含 4 个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个结果本身必须是按诱导排序顺序排列的标识符列表，并用方括号括起来。例如，输出格式为 $[\\ [i\\_1,i\\_2,\\dots],[\\dots],[\\dots],[\\dots]\\ ]$，不含任何额外文本。所需的输出是整数列表。", "solution": "我们从以下基本事实出发：对于在已知范围 $[0,k]$ 内有界的任何有限整数多重集，可以通过频率数组来统计出现次数，并且这些频率的累积总和可以为稳定排列生成确定性的放置索引。在随机存取机器模型下，数组支持常数时间的索引访问，这确保了累积和放置步骤的运行时间与访问的索引数量成正比。\n\n设 $A$ 是一个长度为 $n = |A|$ 的序列，并设 $K(x) = \\mathrm{key\\_func}(x) \\in [0,k]$ 是元素 $x$ 的整数键。目标是使用在 $n+k$ 上线性的操作和在 $n+k$ 上线性的额外内存，根据非递减的键 $K(x)$ 构造一个对 $A$ 的稳定排序。\n\n该算法构造如下：\n1. 计数阶段。分配一个长度为 $k+1$ 并初始化为 0 的数组 $C$。对于 $A$ 中的每个元素 $x$，读取其键 $t = K(x)$ 并递增 $C[t] \\leftarrow C[t] + 1$。此遍处理后，对于所有的 $t \\in \\{0,1,\\dots,k\\}$，$C[t]$ 存储了键为 $t$ 的元素的数量。\n\n2. 前缀和（累积）阶段。原地转换 $C$，使 $C[t]$ 成为输出数组中键为 $t$ 的元素的起始索引（偏移量）。初始化一个累加器 $s \\leftarrow 0$，并对于从 0 到 $k$ 的 $t$，执行：\n   - 令 $c \\leftarrow C[t]$。\n   - 设置 $C[t] \\leftarrow s$。\n   - 更新 $s \\leftarrow s + c$。\n   此阶段之后，对于每个键 $t$，$C[t]$ 等于输出数组中应放置键为 $t$ 的元素的第一个位置。由于 $s$ 的增量是截至键 $t$ 所见元素的总数，不同键的段是连续且不重叠的，跨越索引范围 $[C[t], C[t] + \\text{count}(t) - 1]$。\n\n3. 稳定放置阶段。分配一个长度为 $n$ 的输出数组 $B$。从左到右遍历 $A$。对于每个元素 $x$，计算 $t = K(x)$，将 $x$ 放置在 $B$ 的索引 $C[t]$ 处，然后递增 $C[t] \\leftarrow C[t] + 1$。因为 $C[t]$ 最初存储键 $t$ 的左边界，并在每次放置后递增，所以具有相同键的元素会按照从 $A$ 中读取的完全相同的顺序被分配到严格递增的索引。这保持了稳定性：如果 $x$ 在 $A$ 中出现在 $y$ 之前且 $K(x)=K(y)$，则 $x$ 在 $B$ 中被放置在比 $y$ 更小的索引处。\n\n正确性论证：\n- 按键排序：通过构造，所有键为 $t$ 的元素都被分配到 $[L_t, R_t]$ 范围内的索引，其中 $L_t$ 是前缀和阶段后存储在 $C[t]$ 中的值，而 $R_t = L_t + \\text{count}(t) - 1$。对于 $t_1  t_2$，这些范围按 $t_1$ 然后 $t_2$ 的顺序排列，因为累加 $s$ 确保了 $L_{t_2} = L_{t_1} + \\sum_{u = t_1}^{t_2-1} \\text{count}(u) \\ge L_{t_1} + \\text{count}(t_1)$，所以所有用于 $t_1$ 的索引都在用于 $t_2$ 的索引之前。因此，输出 $B$ 是按键非递减的。\n- 稳定性：在键 $t$ 内部，每当一个键为 $t$ 的元素被放置时，用于放置的索引都会递增，这与遍历 $A$ 的从左到右顺序相同。因此，键相等的元素保持了输入顺序。\n\n复杂度分析：\n- 计数阶段访问 $n$ 个元素中的每一个一次，并对每个元素执行 $O(1)$ 的工作，总时间为 $O(n)$。\n- 前缀和阶段访问从 $0$ 到 $k$ 的每个键索引一次，总时间为 $O(k)$。\n- 放置阶段访问 $n$ 个元素中的每一个一次，总时间为 $O(n)$。\n- 总时间为 $O(n + k)$。使用的辅助存储是包含 $n$ 个元素的输出数组加上包含 $k+1$ 个条目的计数数组，因此额外空间为 $O(n + k)$。\n\n测试套件应用：\n- 测试 1：$A_1 = [(3,101),(1,102),(3,103),(0,104),(5,105),(1,106),(2,107),(5,108),(4,109),(2,110)]$，$\\mathrm{key\\_func}_1(v,i) = v$，$k_1 = 5$。稳定排序按键 $0,1,2,3,4,5$ 的顺序分组，得到标识符的顺序为 $[104,102,106,107,110,101,103,109,105,108]$。\n- 测试 2：$A_2$ 与 $\\mathrm{key\\_func}_2(v,i) = 0$ 和 $k_2 = 0$ 将所有元素放入单个键桶中，并根据稳定性，返回原始顺序的标识符 $[201,202,203,204,205,206]$。\n- 测试 3：$A_3 = [\\ ]$ 产生空列表 $[\\ ]$，与 $k_3$ 无关。\n- 测试 4：$A_4$ 与 $\\mathrm{key\\_func}_4(v,i) = |v| \\bmod 4$ 和 $k_4 = 3$ 为给定字符串计算出键 $[1,2,3,2,1,0,3]$，按键 $0,1,2,3$ 的稳定分组得到标识符 $[306,301,305,302,304,303,307]$。\n\n指定的输出是单行，将这些每个测试的列表按顺序聚合为一个用方括号括起来的逗号分隔列表，每个子列表也用方括号括起来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Not strictly required; included per allowed environment.\n\ndef counting_sort_by_key(A, key_func, k):\n    \"\"\"\n    Stable counting-based sort of arbitrary elements by integer key in [0, k].\n    Returns a new list with elements of A sorted by key_func(x) in nondecreasing order.\n    \"\"\"\n    n = len(A)\n    # Frequency array for keys 0..k\n    counts = [0] * (k + 1)\n    for x in A:\n        t = key_func(x)\n        if not isinstance(t, int):\n            raise ValueError(\"key_func must return an integer.\")\n        if t  0 or t > k:\n            raise ValueError(\"key_func returned a key outside [0, k].\")\n        counts[t] += 1\n\n    # Convert counts to starting indices (prefix sums)\n    total = 0\n    for t in range(k + 1):\n        c = counts[t]\n        counts[t] = total\n        total += c\n\n    # Stable placement\n    output = [None] * n\n    for x in A:\n        t = key_func(x)\n        idx = counts[t]\n        output[idx] = x\n        counts[t] = idx + 1\n\n    return output\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test 1: General case with repeated keys\n    A1 = [(3, 101), (1, 102), (3, 103), (0, 104), (5, 105),\n          (1, 106), (2, 107), (5, 108), (4, 109), (2, 110)]\n    def key_func1(x):\n        return x[0]\n    k1 = 5\n\n    # Test 2: Boundary case k = 0 (all keys identical)\n    A2 = [(7, 201), (3, 202), (9, 203), (1, 204), (7, 205), (3, 206)]\n    def key_func2(x):\n        return 0\n    k2 = 0\n\n    # Test 3: Edge case empty input\n    A3 = []\n    def key_func3(x):\n        return 0\n    k3 = 3\n\n    # Test 4: Nontrivial key function on strings: length mod 4\n    A4 = [(\"delta\", 301), (\"mu\", 302), (\"epsilon\", 303),\n          (\"pi\", 304), (\"alpha\", 305), (\"beta\", 306), (\"omicron\", 307)]\n    def key_func4(x):\n        return len(x[0]) % 4\n    k4 = 3\n\n    test_cases = [\n        (A1, key_func1, k1),\n        (A2, key_func2, k2),\n        (A3, key_func3, k3),\n        (A4, key_func4, k4),\n    ]\n\n    results = []\n    for A, key_func, k in test_cases:\n        sorted_A = counting_sort_by_key(A, key_func, k)\n        # Extract the identifiers (second component)\n        ids_in_order = [x[1] for x in sorted_A]\n        results.append(ids_in_order)\n\n    # Helper to format a list of ints without spaces\n    def format_list(lst):\n        return \"[\" + \",\".join(map(str, lst)) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(\"[\" + \",\".join(format_list(lst) for lst in results) + \"]\")\n\nsolve()\n```", "id": "3224624"}, {"introduction": "标准计数排序有一个显著的局限性：其空间和时间复杂度取决于键值的范围 $k$。这个练习将正面解决这一弱点，通过改造算法使其适用于大键值范围内的稀疏数据。你将用哈希表替代计数数组，创建一个即使在键值很大或为负数时也同样高效的版本，从而揭示一种关键的优化策略。[@problem_id:3224735]", "problem": "您的任务是设计并分析一个稳定的排序过程，该过程用于处理整数键记录，这些记录的键范围可能非常大。设定是稀疏的：仅存在键的一小部分子集，但键本身的大小可能任意大。您必须开发一种计数排序的变体，它使用哈希表来存储计数，而不是使用由键索引的直接映射数组。该算法必须是稳定的：当两个记录具有相同的键时，它们在输出中的相对顺序必须与它们在输入中的相对顺序相匹配。\n\n推导的基本依据：仅使用以下基本事实来证明算法的正确性和复杂度。\n- 计数排序依赖于计算每个键的出现次数来确定输出位置，其稳定性是通过以保持相同键的输入顺序的方式将项目放入输出来实现的。\n- 在标准的随机化和均匀哈希假设下，哈希表为插入、查找和更新操作提供期望常数时间的操作。\n- 非负计数的前缀和为输出数组中的连续段提供起始索引。\n\n您的程序必须实现一个函数，该函数接收一个记录列表，其中每个记录是一个对 $\\left(x_i, id_i\\right)$，包含整数键 $x_i$ 和整数标识符 $id_i$，并返回按 $x_i$ 非递减排序后 $id_i$ 的稳定顺序。您不得分配大小与最大键值成比例的数组；相反，您必须使用哈希表进行计数。实现必须对所有输入都是稳定的。\n\n将输入大小定义为 $n$（记录数），并令 $u$ 为输入中存在的不同键的数量。您的分析必须从列出的基本依据出发，建立关于 $n$ 和 $u$ 的渐近时间和空间复杂度。\n\n测试套件。您的程序必须在以下六个测试用例上运行该算法，并汇总结果：\n- 测试用例 1：记录 $\\left[\\left(7,0\\right),\\left(3,1\\right),\\left(7,2\\right),\\left(2,3\\right),\\left(3,4\\right),\\left(9,5\\right)\\right]$。按键进行的预期稳定排序会产生与非递减顺序的键相对应的 $id$ 序列。\n- 测试用例 2：记录 $\\left[\\;\\right]$（空列表）。\n- 测试用例 3：记录 $\\left[\\left(42,0\\right)\\right]$。\n- 测试用例 4：记录 $\\left[\\left(5,0\\right),\\left(5,1\\right),\\left(5,2\\right),\\left(5,3\\right)\\right]$。\n- 测试用例 5：记录 $\\left[\\left(-1000000000,0\\right),\\left(1000000000,1\\right),\\left(0,2\\right),\\left(-1000000000,3\\right),\\left(1000000000,4\\right)\\right]$。\n- 测试用例 6：记录 $\\left[\\left(100,0\\right),\\left(-50,1\\right),\\left(100,2\\right),\\left(50,3\\right),\\left(-50,4\\right),\\left(200,5\\right),\\left(0,6\\right)\\right]$。\n\n对于每个测试用例，结果是按键以稳定、非递减顺序排列的标识符 $id_i$ 列表。所有输出都是整数列表。\n\n最终输出格式。您的程序必须生成单行输出，其中包含六个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，其中每个元素本身也是一个用方括号括起来的逗号分隔整数列表，并且任何地方都没有空格。例如，如果六个结果是列表 $R_1,\\dots,R_6$，则输出必须是 $\\left[\\;R_1,R_2,R_3,R_4,R_5,R_6\\;\\right]$ 的确切形式。此问题中没有物理单位或角度测量，也不需要百分比。程序必须是自包含的，且不得读取任何输入。", "solution": "问题陈述被评估为有效。它在科学上基于计算机科学原理，特别是算法设计，并且问题定义良好、客观且完整。它提出了一个可以被形式化指定和解决的非平凡算法挑战。\n\n任务是为具有整数键的记录开发一种稳定的排序算法，其中键的范围可能非常大，但记录的数量是可管理的。这种情况使得传统的计数排序不切实际，因为它需要一个大小与最大键值成比例的辅助数组。所提出的解决方案是计数排序的一个变体，它利用哈希表来管理计数，从而绕过了大键范围的限制。该算法必须是稳定的，这意味着具有相同键的记录保持其原始的相对顺序。\n\n设 $n$ 为输入列表中的记录数，$u$ 为唯一键的数量。每个记录是一个对 $(x_i, id_i)$，其中 $x_i$ 是一个整数键，$id_i$ 是一个整数标识符。\n\n该算法遵循所提供的基本原则，分为三个主要阶段构建。\n\n**阶段 1：频率计数**\n\n第一步是计算输入中每个唯一键的出现次数。为此，我们使用一个哈希表，称之为 `counts`。我们遍历 $n$ 个输入记录。对于每个记录 $(x_i, id_i)$，我们在 `counts` 哈希表中更新键 $x_i$ 的计数。如果 $x_i$ 尚未在表中，则以计数 1 插入；否则，其现有计数加一。\n\n- **原理**：此步骤利用了哈希表为插入和更新提供期望常数时间操作的特性。因此，处理所有 $n$ 个记录的期望时间为 $O(n)$。\n- **空间**：`counts` 哈希表将为 $u$ 个唯一键中的每一个存储一个条目。因此，此阶段的空间复杂度为 $O(u)$。\n\n**阶段 2：位置计算**\n\n第二阶段确定共享相同键的每组记录在最终输出数组中的起始位置。这类似于标准计数排序中的前缀和计算。\n\n1.  **提取并排序键**：首先，我们从 `counts` 哈希表中提取 $u$ 个唯一键。为了建立输出的非递减顺序，必须对这些键进行排序。设排序后的唯一键为 $k_1, k_2, \\dots, k_u$。此步骤的时间复杂度主要由排序决定，使用标准的基于比较的排序算法为 $O(u \\log u)$。\n\n2.  **计算起始索引**：我们创建第二个哈希表 `positions`，将每个唯一键映射到其在最终排序数组中的起始索引。这是通过计算已排序键的计数的前缀和来完成的。一个运行的 `offset`（偏移量）被初始化为 $0$。我们遍历已排序的键 $k_j$（$j=1, \\dots, u$）：\n    - 键 $k_j$ 的起始位置是当前的 `offset`。我们设置 `positions[k_j] = offset`。\n    - 然后，`offset` 增加键为 $k_j$ 的元素数量，该数量存储在 `counts[k_j]` 中。\n    \n    这个过程计算出第一块项目（键为 $k_1$）将从索引 $0$ 开始。第二块（键为 $k_2$）将从索引 `counts[k_1]` 开始。第三块（键为 $k_3$）将从索引 `counts[k_1] + counts[k_2]` 开始，依此类推。\n\n- **原理**：此步骤直接应用了计数的前缀和提供连续段起始索引的原理。通过对已排序的唯一键执行此操作，我们将键的抽象顺序映射到内存中的具体索引。\n- **复杂度**：此步骤涉及对已排序键的 $O(u)$ 次迭代。此阶段的主要成本仍然是 $O(u \\log u)$ 的排序步骤。`positions` 哈希表需要 $O(u)$ 的空间。\n\n**阶段 3：稳定放置**\n\n最后一个阶段将记录标识符以其稳定、排序后的顺序放入大小为 $n$ 的输出数组中。\n\n为确保稳定性，我们必须按原始顺序遍历输入记录 $(x_i, id_i)$（从 $i=1$ 到 $n$）。对于每个记录：\n1.  在 `positions` 哈希表中查找其键 $x_i$ 的当前放置索引。设此为 `p = positions[x_i]`。\n2.  将标识符 $id_i$ 放入输出数组的索引 `p` 处。\n3.  在 `positions` 哈希表中增加键 $x_i$ 的位置：`positions[x_i] = p + 1`。\n\n- **原理**：稳定性的实现是因为我们按顺序处理输入记录。如果两个记录具有相同的键，则输入中较早出现的那个将首先被放置。它的放置操作会增加该键的起始位置，确保具有相同键的后续记录紧随其后放置，从而保持它们最初的相对顺序。\n- **复杂度**：此阶段涉及对 $n$ 个输入记录的单次遍历。循环内的每一步都包括一次哈希表查找和一次更新，这些都是期望 $O(1)$ 的操作。因此，此阶段的总时间为 $O(n)$。需要一个大小为 $n$ 的输出数组，这为空间复杂度贡献了 $O(n)$。\n\n**总体复杂度分析**\n\n- **时间复杂度**：总期望时间是三个阶段复杂度的总和：$O(n)$（计数）+ $O(u \\log u)$（排序键）+ $O(n)$（放置）。这可以简化为 $O(n + u \\log u)$。\n- **空间复杂度**：空间由 `counts` 哈希表（$O(u)$）、`positions` 哈希表（$O(u)$）、用于排序键的临时存储（$O(u)$）以及输出数组（$O(n)$）的存储决定。因此，总空间复杂度为 $O(n + u)$。\n\n这种算法设计成功地将计数排序应用于稀疏、大范围键的场景，同时保持了稳定性并遵守了指定的约束和基本原则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hash-based counting sort problem for the given test cases.\n    \"\"\"\n\n    def hash_counting_sort(records):\n        \"\"\"\n        Implements a stable, hash-based counting sort for integer-keyed records.\n\n        The algorithm handles sparse keys over a potentially large range by using\n        hash tables for counting and position mapping, avoiding the creation of\n        an array proportional to the key range.\n\n        Args:\n            records: A list of tuples, where each tuple is a pair (key, id).\n\n        Returns:\n            A list of ids, stably sorted by their corresponding keys in non-decreasing order.\n        \"\"\"\n        n = len(records)\n        if n == 0:\n            return []\n\n        # Phase 1: Frequency Counting\n        # Use a dictionary (hash table) to count occurrences of each key.\n        # Time: O(n) expected, Space: O(u) where u is the number of unique keys.\n        counts = {}\n        for key, _ in records:\n            counts[key] = counts.get(key, 0) + 1\n\n        # Phase 2: Position Calculation\n        # 1. Get unique keys and sort them to establish the output order.\n        # Time: O(u log u)\n        unique_keys = sorted(counts.keys())\n        \n        # 2. Compute prefix sums to find the starting index for each key's block.\n        #    Store these starting positions in a hash table.\n        # Time: O(u), Space: O(u)\n        positions = {}\n        start_pos = 0\n        for key in unique_keys:\n            positions[key] = start_pos\n            start_pos += counts[key]\n\n        # Phase 3: Stable Placement\n        # Create an output array. Iterate through the *original* input records to\n        # ensure stability. Place each item's id in its correct sorted position\n        # and increment the position for that key.\n        # Time: O(n) expected, Space: O(n) for the output array.\n        output = [0] * n\n        for key, item_id in records:\n            # Get the current position for this key\n            pos = positions[key]\n            # Place the id in the output array\n            output[pos] = item_id\n            # Increment the position for the next item with the same key\n            positions[key] += 1\n            \n        return output\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(7, 0), (3, 1), (7, 2), (2, 3), (3, 4), (9, 5)],\n        [],\n        [(42, 0)],\n        [(5, 0), (5, 1), (5, 2), (5, 3)],\n        [(-1000000000, 0), (1000000000, 1), (0, 2), (-1000000000, 3), (1000000000, 4)],\n        [(100, 0), (-50, 1), (100, 2), (50, 3), (-50, 4), (200, 5), (0, 6)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = hash_counting_sort(case)\n        results.append(result)\n\n    # Format the final output string exactly as required: no spaces, comma-separated lists within a list.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3224735"}, {"introduction": "深刻理解一个算法，意味着要明白其中每个细节为何至关重要。最后一个练习将展示一个在放置步骤中存在微小但关键错误的计数排序实现。通过分析这个错误带来的后果，你将巩固对算法稳定性及正确性背后机制的理解，学会像调试器一样思考。[@problem_id:3224722]", "problem": "考虑对一个长度为 $n$ 的数组 $A$ 进行计数排序，其元素是 $\\{1,2,\\dots,k\\}$ 中的整数键。设 $C$ 是计数数组，它通过先统计频率然后计算前缀和得到，因此对于每个键 $v \\in \\{1,2,\\dots,k\\}$，$C[v]$ 等于 $A$ 中小于或等于 $v$ 的元素数量。设输出数组 $B$ 的索引从 $1$ 到 $n$（即，基于 1 的索引）。在一个正确的稳定计数排序中，最后的放置阶段会从 $i=n$ 向下扫描到 $i=1$，并使用 $C$ 中的信息将每个元素 $A[i]$ 映射到 $B$ 中其键的连续块内的一个索引。\n\n从第一性原理出发，前缀和不变量意味着，对于每个键 $v$，$B$ 中被所有 $v$ 的出现所占据的目标位置块正是索引集\n$$\nI_v = \\{\\, C[v-1]+1,\\, C[v-1]+2,\\, \\dots,\\, C[v] \\,\\},\n$$\n其中 $C[0]$ 定义为 $0$。这是因为 $C[v]$ 计的是键至多为 $v$ 的元素数量，而 $C[v-1]$ 计的是键至多为 $v-1$ 的元素数量，所以等于 $v$ 的元素数量是 $C[v]-C[v-1]$，它们的位置必须填充从 $C[v-1]+1$ 到 $C[v]$ 的连续区间。\n\n现在假设一个实现在放置步骤中有一个特定的错误：当从 $n$ 向下扫描到 $1$ 时，它在放置元素之前执行递减操作 $C[A[i]] := C[A[i]] - 1$，然后将 $A[i]$ 写入 $B[C[A[i]]]$。所有其他步骤（频率统计和将 $C$ 计算为前缀和）都正确执行，扫描顺序是从 $i=n$ 向下到 $i=1$。请描述在上述基于 1 的索引机制下，这个错误导致的输出 $B$ 的结构特征。\n\n选择最佳的描述。\n\nA. 输出 $B$ 是 $A$ 的一个正确的稳定排序；递减和放置顺序的改变没有影响。\n\nB. $B$ 中的键按值保持非递减顺序，但与正确输出相比，每个键的块都向较低索引方向移动了一个位置；这导致对最小的键尝试写入 $B[0]$，并使 $B[n]$ 未被写入。\n\nC. 输出 $B$ 按键正确排序，但不再是稳定的；值相等的键可能以与其在 $A$ 中顺序相反的相对顺序出现。\n\nD. 由于递减和放置步骤的颠倒，输出按键变为严格递减排序。\n\nE. 算法写入了所有 $n$ 个元素，但产生了正确排序输出的一个全局左循环移位：每个元素向左移动一个位置，第一个元素移动到位置 $n$。", "solution": "用户希望我分析一个有错误的计数排序算法实现。\n\n### 步骤 1：问题验证\n\n我将首先根据指定规则验证问题陈述。\n\n#### 提取已知条件\n*   **输入数组**：一个长度为 $n$ 的数组 $A$。\n*   **元素域**：$A$ 的元素是来自集合 $\\{1, 2, \\dots, k\\}$ 的整数键。\n*   **计数数组**：使用一个数组 $C$。\n*   **`C` 数组计算**：$C$ 被正确计算。首先，它存储频率。然后，计算前缀和，使得对于任何键 $v \\in \\{1, 2, \\dots, k\\}$，$C[v]$ 是 $A$ 中键小于或等于 $v$ 的元素总数。\n*   **输出数组**：一个从 $1$ 到 $n$ 索引的数组 $B$（基于 1 的索引）。\n*   **辅助定义**：$C[0]$ 定义为 $0$。\n*   **键 $v$ 的正确块**：问题陈述指出，对于键 $v$，$B$ 中的索引集合是 $I_v = \\{C[v-1]+1, C[v-1]+2, \\dots, C[v]\\}$。\n*   **放置循环**：最后的放置阶段从 $i=n$ 向下迭代到 $i=1$。\n*   **错误**：错误在于放置步骤。对于每个元素 $A[i]$，该实现按顺序执行以下两个操作：\n    1.  `C[A[i]] := C[A[i]] - 1` （递减步骤）\n    2.  `B[C[A[i]]] = A[i]` （放置步骤）\n    这与正确的稳定实现相反，后者是在 `B[C[A[i]]]` 处放置元素，*然后* 才递减 `C[A[i]]`。\n\n#### 验证结论\n问题陈述在科学上是合理的、定义明确且客观的。它描述了计算机科学的一个子领域——算法和数据结构领域内的一个场景。前提清晰、内部一致，并提供了推导该错误算法行为所需的所有必要信息。所描述的错误是编程中一种常见的差一错误或操作顺序错误。这个问题并非微不足道，需要仔细追踪算法的状态。\n\n**结论：** 问题是 **有效的**。\n\n### 步骤 2：推导解决方案\n\n我现在将从第一性原理推导该错误算法的行为。\n\n让我们分析一下在最后的放置循环开始之前，计数数组 $C$ 的状态。如前所述，对于任何键 $v$，$C[v]$ 保存着 $A$ 中小于或等于 $v$ 的元素的数量。因此，严格等于 $v$ 的元素数量是 $C[v] - C[v-1]$。这些元素在输出数组 $B$ 中的正确位置构成了一个大小为 $C[v] - C[v-1]$ 的连续块。根据前缀和，这些位置被正确地识别为从 $C[v-1]+1$ 到 $C[v]$ 的索引。\n\n标准的稳定算法在处理键为 $v$ 的元素时，会将它们按索引递减的顺序放置在索引 $\\{C[v-1]+1, \\dots, C[v]\\}$ 中，从而保留来自输入数组 $A$ 的相对顺序。\n\n现在，让我们针对一个特定的键 $v$ 来追踪这个有错误的算法。假设输入数组 $A$ 中有 $m = C[v] - C[v-1]$ 个键为 $v$ 的元素。放置循环从 $i=n$ 向下迭代到 $1$。\n\n考虑循环处理的第一个键为 $v$ 的元素。这将是 $A$ 中索引 $i$ 最大的那个。设这个元素为 $A[j]$，其中 $A[j]=v$。\n*   在此步骤之前，`C[v]` 的值是其原始的、正确计算的前缀和。\n*   **步骤 1 (错误)：** `C[v]` 被递减。它的新值是 `original_C[v] - 1`。\n*   **步骤 2 (错误)：** $A[j]$ 被放置在 `B[C[v]]`，即 `B[original_C[v] - 1]`。\n\n现在，考虑处理的第二个键为 $v$ 的元素（即在 $A$ 中具有第二大索引的那个）。\n*   在此步骤之前，`C[v]` 的值是 `original_C[v] - 1`。\n*   **步骤 1 (错误)：** `C[v]` 再次被递减。它的新值是 `original_C[v] - 2`。\n*   **步骤 2 (错误)：** 这个元素被放置在 `B[C[v]]`，即 `B[original_C[v] - 2]`。\n\n这个模式对所有 $m$ 个键为 $v$ 的元素都继续。要处理的第 $m$ 个（也是最后一个）键为 $v$ 的元素（即在 $A$ 中索引最小的那个）将在 $C[v]$ 从其原始值递减 $m$ 次后被放置。\n*   放置索引将是 `original_C[v] - m`。\n*   代入 $m = \\text{original\\_C}[v] - \\text{original\\_C}[v-1]$，索引为：\n    $$ \\text{original\\_C}[v] - (\\text{original\\_C}[v] - \\text{original\\_C}[v-1]) = \\text{original\\_C}[v-1] $$\n\n所以，在 $B$ 中被键为 $v$ 的元素填充的索引块是：\n$$ \\{ \\text{original\\_C}[v-1], \\text{original\\_C}[v-1]+1, \\dots, \\text{original\\_C}[v]-1 \\} $$\n\n让我们将其与正确的索引块进行比较：\n$$ \\{ \\text{original\\_C}[v-1]+1, \\text{original\\_C}[v-1]+2, \\dots, \\text{original\\_C}[v] \\} $$\n\n比较显示，键 $v$ 的整个索引块被移动了 $-1$，即向较低索引方向移动了一个位置。这对每个键 $v$ 都成立。\n\n让我们分析其后果：\n\n1.  **排序顺序：** 键 $v_1$ 的块是 $\\{C[v_1-1], \\dots, C[v_1]-1\\}$。键 $v_2  v_1$ 的块从索引 $C[v_2-1]$ 开始。由于 $v_1   v_2$，我们有 $v_1 \\le v_2-1$，这意味着 $C[v_1] \\le C[v_2-1]$。$v_1$ 使用的最大索引是 $C[v_1]-1$。键 $v_1+1$ 使用的最小索引是 $C[v_1]$。这些块彼此之间保持连续和有序。因此，输出数组 $B$ 仍然按键非递减排序。\n\n2.  **稳定性：** 算法仍然从 $i=n$ 向下处理到 $1$。对于任何两个键相同的元素 $A[i_1] = A[i_2] = v$ 且 $i_1  i_2$，元素 $A[i_2]$ 会先被处理。它被放置在某个索引，比如 $j$。下一次处理键为 $v$ 的元素时（即 $A[i_1]$），它将被放置在一个比 $j$ 更小的索引处，因为 $C[v]$ 在每一步都会递减。因此，等键元素的相对顺序被保留了下来。排序保持稳定。\n\n3.  **边界条件：**\n    *   **下界：** 考虑数组中存在的最小键，称之为 $v_{min}$。键为 $v_{min}$ 的元素将被放置在从 $C[v_{min}-1]$ 开始的索引中。由于 $v_{min}$ 是最小的键，没有比它更小的元素，所以 $C[v_{min}-1] = 0$。因此，算法将尝试将第一个处理的键为 $v_{min}$ 的元素写入 $B[0]$。由于 $B$ 是基于 1 的索引，这是一个越界写入。\n    *   **上界：** 元素总数为 $n$。最大可能键 $k$ 的前缀和是 $C[k]=n$。输入中实际存在的最大键值 $v_{max}$ 的元素将被放置在最高为 $C[v_{max}]-1$ 的索引处。由于 $A$ 中所有元素都 $\\le v_{max}$，所以必然有 $C[v_{max}]=n$。因此，写入数组 $B$ 的最高索引是 $n-1$。这意味着位置 $B[n]$ 永远不会被写入，并将保持未初始化状态。\n\n总而言之，这个错误导致每个键的块向左移动一个位置。这保留了排序顺序和稳定性，但它会导致尝试对索引 $0$ 进行越界写入，并使索引 $n$ 未被写入。\n\n### 步骤 3：逐项分析选项\n\n*   **A. 输出 $B$ 是 $A$ 的一个正确的稳定排序；递减和放置顺序的改变没有影响。**\n    这是不正确的。正如所推导的，这一改变导致所有元素全局移动一个位置，从而产生不正确的输出，并伴有边界错误（尝试写入 $B[0]$ 且没有写入 $B[n]$）。\n    **结论：不正确。**\n\n*   **B. $B$ 中的键按值保持非递减顺序，但与正确输出相比，每个键的块都向较低索引方向移动了一个位置；这导致对最小的键尝试写入 $B[0]$，并使 $B[n]$ 未被写入。**\n    这完全符合我们的推导。键保持排序。每个块 $\\{C[v-1]+1, \\dots, C[v]\\}$ 被映射到 $\\{C[v-1], \\dots, C[v]-1\\}$，这是一个 $-1$ 的移位。对于最小的键 $v_{min}$，这涉及到写入索引 $C[v_{min}-1]=0$。写入的总体最大索引是 $C[v_{max}]-1 = n-1$，使得 $B[n]$ 为空。\n    **结论：正确。**\n\n*   **C. 输出 $B$ 按键正确排序，但不再是稳定的；值相等的键可能以与其在 $A$ 中顺序相反的相对顺序出现。**\n    这是不正确的。对输入数组的向后扫描，结合为每个键递减位置计数器，确保了输入中较晚出现的元素被放置在输出中较高的索引处，从而保留了稳定性。\n    **结论：不正确。**\n\n*   **D. 由于递减和放置步骤的颠倒，输出按键变为严格递减排序。**\n    这是不正确的。基于前缀和的基本块结构被保留了下来，只是发生了移位。较小键的块仍然出现在较大键的块之前。排序顺序仍然是非递减的。\n    **结论：不正确。**\n\n*   **E. 算法写入了所有 $n$ 个元素，但产生了正确排序输出的一个全局左循环移位：每个元素向左移动一个位置，第一个元素移动到位置 $n$。**\n    这有两个原因是不正确的。首先，算法没有写入所有 $n$ 个元素；它尝试写入 $B[0]$ 并且未能写入 $B[n]$。其次，这种行为是全局左移，而不是循环移位。循环移位会将位置 $1$ 的元素移动到位置 $n$。这个有错误的算法实际上丢失了应该放在位置 $1$ 的元素（通过将其写入位置 $0$），并使位置 $n$ 为空。\n    **结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3224722"}]}