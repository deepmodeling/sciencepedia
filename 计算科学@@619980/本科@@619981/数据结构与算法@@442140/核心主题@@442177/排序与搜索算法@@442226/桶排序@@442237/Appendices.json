{"hands_on_practices": [{"introduction": "桶排序通常用简单的实数来介绍。我们如何将其应用于更复杂的数据类型，例如没有单一自然顺序的复数？本练习要求您基于复数的某个属性（例如其模 $|z|$ 或辐角 $\\theta(z)$）定义一个主排序键，并使用另一个属性作为次要键来解决排序冲突。这项实践能加深您对映射函数的理解，这是桶排序的核心，并教会您如何通过建立清晰确定的排序规则来处理多维数据。[@problem_id:3219470]", "problem": "要求您设计并实现一个广义桶排序，该排序能够根据用户选择的映射函数对复数进行排序。该映射函数基于复模和复辐角的标准定义。实现必须是一个完整、可运行的程序。目标受众是数据结构与算法课程的高年级本科生。\n\n从以下基本概念开始：\n- 一个复数 $z \\in \\mathbb{C}$ 可以写作 $z = x + iy$，其中 $x = \\Re(z)$ 且 $y = \\Im(z)$。\n- $z$ 的模（或大小）为 $|z| = \\sqrt{x^2 + y^2}$。\n- $z$ 的主辐角是 $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$；归一化辐角是 $\\theta(z) \\in [0, 2\\pi)$，其定义为：如果 $\\operatorname{Arg}(z) \\ge 0$，则 $\\theta(z) = \\operatorname{Arg}(z)$，否则 $\\theta(z) = \\operatorname{Arg}(z) + 2\\pi$。角度单位是弧度。\n\n定义一个广义桶排序，它：\n- 接受一个有限的复数列表 $\\{z_1, z_2, \\dots, z_n\\}$。\n- 接受一个映射选择 $m(\\cdot)$，该映射可以是模 $m(z) = |z|$ 或归一化辐角 $m(z) = \\theta(z)$。\n- 给定桶的数量 $B \\in \\mathbb{Z}_{\\ge 1}$（整数），使用可推导的线性缩放将每个元素分配到 $B$ 个桶中的一个。对于基于模的映射，假设一个已知的有限范围 $[r_{\\min}, r_{\\max}]$，其中 $0 \\le r_{\\min}  r_{\\max}$ 且 $r_{\\max} > 0$，并推导出一个线性缩放函数 $\\phi: [r_{\\min}, r_{\\max}] \\to [0, B)$，使得桶索引为 $b(z) = \\lfloor \\phi(m(z)) \\rfloor$。对于基于辐角的映射，已知范围是 $[0, 2\\pi)$，桶索引为 $b(z) = \\lfloor \\phi(m(z)) \\rfloor$，其中 $\\phi$ 是您推导出的适当函数。\n- 以科学上一致的方式处理 $z = 0$ 的特殊情况：对于基于模的映射，$m(0) = 0$ 在范围内；对于基于辐角的映射，其辐角未定义，按照约定，您必须将 $z = 0$ 分配到索引为 $0$ 的桶中。\n- 在每个桶内，通过应用次要键来打破平局，从而产生确定性顺序。当 $m(z) = |z|$ 时，使用 $\\theta(z)$ 作为次要键；当 $m(z) = \\theta(z)$ 时，使用 $|z|$ 作为次要键。最终的全局排序首先按桶索引升序排列，然后按次要键升序排列。\n\n您必须在不使用任何外部输入的情况下实现该算法。映射和分桶必须从给出的基本定义中推導得出；不要依赖于那些无法从基本定义推导出的快捷公式。程序必须执行以下测试套件，并生成单一的合并输出行。所有角度都必须以弧度为单位。除弧度外，角度不需要其他物理单位。\n\n测试套件：\n- 案例 1（正常路径，基于模）：$B = 5$，$r_{\\min} = 0$，$r_{\\max} = 5$，数字为 $[3 + 4i,\\,-1 + 0.5i,\\,0 + 0i,\\,2 - 2i,\\,-3 - 4i]$。\n- 案例 2（边界条件，基于辐角）：$B = 8$，数字为 $[1 + 0i,\\,-1 + 0i,\\,0 - 1i,\\,0 + 1i,\\,0 + 0i,\\,1 - 1i,\\,-1 + 1i]$。\n- 案例 3（边缘情况，多个元素在一个桶中，基于模）：$B = 3$，$r_{\\min} = 0$，$r_{\\max} = 1$，数字为 $[0.1 + 0.2i,\\,-0.1 - 0.2i,\\,0.2 - 0.1i,\\,0 + 0i]$。\n\n答案规范：\n- 对每个案例，输出最终排序后的复数列表，编码为数对 $[\\Re(z), \\Im(z)]$ 的列表，其中每个数对是包含两个实数的列表。例如，$z = 3 + 4i$ 编码为 $[3.0, 4.0]$。\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为一个用方括号括起来的逗号分隔列表。外层列表包含三个元素（每个案例一个），其中每个元素都是一个数对列表。例如，格式为 $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$，其中每个 $\\text{result}_k$ 是一个 $[\\Re(z), \\Im(z)]$ 数对的列表。\n\n您的程序必须是完整、可运行的，并以指定格式生成准确的单行输出。不允许用户输入。", "solution": "该问题是有效的。它提出了一个适定的算法设计挑战，植根于标准的数学定义和计算机科学原理。它是自洽的、客观的，并且其要求是内部一致的。因此，我们可以着手进行形式化的求解。\n\n任务是为一个复数列表 $\\{z_1, z_2, \\dots, z_n\\}$ 设计一个广义桶排序算法。排序基于一个主键，即用户选择的映射 $m(z)$，而平局则由一个次要键来打破。\n\n首先，我们根据所提供的定义建立必要的数学函数。一个复数是 $z = x + iy$，其中 $x, y \\in \\mathbb{R}$。\n主要映射是模 $|z| = \\sqrt{x^2 + y^2}$ 和归一化辐角 $\\theta(z)$。归一化辐角 $\\theta(z)$ 定义在范围 $[0, 2\\pi)$ 内。它由主辐角 $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$ 推导而来，主辐角是向量 $(x,y)$ 与正实轴之间的夹角。它们的关系是：\n$$\n\\theta(z) = \\begin{cases} \\operatorname{Arg}(z)  \\text{if } \\operatorname{Arg}(z) \\ge 0 \\\\ \\operatorname{Arg}(z) + 2\\pi  \\text{if } \\operatorname{Arg}(z)  0 \\end{cases}\n$$\n对于特殊情况 $z = 0$，其辐角在数学上是未定义的。问题为此情况提供了约定：\n1.  对于基于辐角的排序，$z=0$ 被分配到索引为 0 的桶。\n2.  对于基于模的排序，其中 $\\theta(z)$ 是次要键，我们需要一个确定性的值。与 $\\theta(x+0i)$ 当 $x \\to 0^+$ 时的极限一致的自然选择是定义 $\\theta(0) = 0$。\n\n桶排序的核心是将元素分配到 $B$ 个桶中，其中 $B \\in \\mathbb{Z}_{\\ge 1}$。这需要一个函数，将主键值的范围映射到桶索引 $\\{0, 1, \\dots, B-1\\}$。问题指定了一个线性缩放函数 $\\phi$ 和一个桶索引公式 $b(z) = \\lfloor \\phi(m(z)) \\rfloor$。\n\n让我们为每种映射类型推导缩放函数。\n\n情况 1：基于模的映射，$m(z) = |z|$。\n已知 $|z|$ 的值在范围 $[r_{\\min}, r_{\\max}]$ 内，其中 $0 \\le r_{\\min}  r_{\\max}$。我们需要将这个值范围映射到 $B$ 个桶。我们可以将值范围划分为 $B$ 个相等的子区间。每个子区间的宽度是 $w = (r_{\\max} - r_{\\min}) / B$。如果一个值 $v = |z|$ 位于第 $k$ 个子区间，即 $[r_{\\min} + k \\cdot w, r_{\\min} + (k+1) \\cdot w)$，那么它就落入第 $k$ 个桶。这个条件等价于 $k \\cdot w \\le v - r_{\\min}  (k+1) \\cdot w$，这意味着 $k \\le \\frac{v - r_{\\min}}{w}  k+1$。向下取整得到桶索引 $k = \\lfloor \\frac{v - r_{\\min}}{w} \\rfloor$。代入 $w$ 可得：\n$$\nb(z) = \\left\\lfloor B \\cdot \\frac{|z| - r_{\\min}}{r_{\\max} - r_{\\min}} \\right\\rfloor\n$$\n这个公式对 $|z| \\in [r_{\\min}, r_{\\max})$ 有效。对于边界情况 $|z| = r_{\\max}$，公式会得出 $\\lfloor B \\rfloor = B$，这是一个越界索引。标准约定是将任何等于或大于 $r_{\\max}$ 的值放入最后一个桶，即 $B-1$。因此，鲁棒的桶索引公式是：\n$$\nb(z) = \\min\\left(\\left\\lfloor B \\cdot \\frac{|z| - r_{\\min}}{r_{\\max} - r_{\\min}} \\right\\rfloor, B-1\\right)\n$$\n这处理了所有 $|z| \\ge r_{\\min}$ 的值。$|z|  r_{\\min}$ 的值会产生负索引，我们假设这种情况不会发生，或者也可以将它们放入桶 0。\n\n情况 2：基于辐角的映射，$m(z) = \\theta(z)$。\n对于任何 $z \\neq 0$，归一化辐角 $\\theta(z)$ 的值范围是 $[0, 2\\pi)$。遵循与上述相同的逻辑，我们有一个长度为 $2\\pi$ 的范围。每个桶的值范围宽度为 $w = 2\\pi/B$。对于值 $v = \\theta(z)$ 的桶索引是：\n$$\nb(z) = \\left\\lfloor \\frac{\\theta(z)}{w} \\right\\rfloor = \\left\\lfloor \\frac{\\theta(z)}{2\\pi/B} \\right\\rfloor = \\left\\lfloor B \\cdot \\frac{\\theta(z)}{2\\pi} \\right\\rfloor\n$$\n由于 $\\theta(z)$ 在半开区间 $[0, 2\\pi)$ 内，项 $B \\cdot \\frac{\\theta(z)}{2\\pi}$ 在 $[0, B)$ 内。该值的向下取整结果将始终在有效索引范围 $\\{0, 1, \\dots, B-1\\}$ 内。不需要对上界进行特殊的钳位处理。根据问题描述，$z=0$ 是一个特殊情况，直接分配到桶 0。\n\n整体排序算法如下：\n1.  初始化 $B$ 个空列表（桶）。\n2.  遍历输入列表中的每个复数 $z$：\n    a.  确定映射类型（模或辐角）。\n    b.  如果是基于辐角且 $z=0$，则将 $z$ 放入桶 0。\n    c.  否则，计算主键值 $m(z)$。\n    d.  使用相应的推导公式计算桶索引 $b(z)$。\n    e.  将 $z$ 追加到 `buckets[b(z)]` 处的列表中。\n3.  从索引 0 到 $B-1$ 遍历每个桶：\n    a.  对桶内的元素进行排序。排序键是次要键：\n        i.  如果主映射是模，则按归一化辐角 $\\theta(z)$ 升序排序。\n        ii. 如果主映射是辐角，则按模 $|z|$ 升序排序。\n4.  按顺序串联已排序的桶，生成最终排序好的复数列表。\n此过程确保了根据指定规则的确定性和正确的排序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite for the generalized bucket sort.\n    \"\"\"\n\n    def normalized_argument(z: complex) - float:\n        \"\"\"\n        Calculates the normalized argument of a complex number in the range [0, 2*pi).\n        By convention, the argument of 0 is 0.\n        \"\"\"\n        if z == 0:\n            return 0.0\n        angle = np.angle(z)\n        return angle if angle = 0 else angle + 2 * np.pi\n\n    def generalized_bucket_sort(\n        numbers: list[complex],\n        B: int,\n        map_type: str,\n        r_min: float | None = None,\n        r_max: float | None = None\n    ) - list[complex]:\n        \"\"\"\n        Sorts a list of complex numbers using a generalized bucket sort algorithm.\n\n        Args:\n            numbers: The list of complex numbers to sort.\n            B: The number of buckets.\n            map_type: 'modulus' or 'argument', the primary sorting key.\n            r_min: The minimum value of the range for modulus sorting.\n            r_max: The maximum value of the range for modulus sorting.\n\n        Returns:\n            The sorted list of complex numbers.\n        \"\"\"\n        if B  1:\n            raise ValueError(\"Number of buckets B must be at least 1.\")\n\n        buckets: list[list[complex]] = [[] for _ in range(B)]\n\n        if map_type == 'modulus':\n            if r_min is None or r_max is None or r_max = r_min:\n                raise ValueError(\"A valid range [r_min, r_max] must be provided for modulus mapping.\")\n            \n            range_len = r_max - r_min\n            for z in numbers:\n                val = np.abs(z)\n                if val  r_min:\n                    b_index = 0\n                elif val = r_max:\n                    b_index = B - 1\n                else:\n                    # Scale to [0, B) and take the floor.\n                    b_index = int(B * (val - r_min) / range_len)\n                    # The index should be clamped to B-1, although int() on scaling for val  r_max\n                    # will not exceed B-1. This is for robustness.\n                    b_index = min(b_index, B - 1)\n                \n                buckets[b_index].append(z)\n\n            # Sort each bucket using the secondary key (normalized argument)\n            for i in range(B):\n                buckets[i].sort(key=normalized_argument)\n\n        elif map_type == 'argument':\n            for z in numbers:\n                if z == 0:\n                    # Special case for z=0 as per problem description\n                    b_index = 0\n                else:\n                    val = normalized_argument(z)\n                    # Scale to [0, B) and take the floor\n                    b_index = int(B * val / (2 * np.pi))\n                    # Clamp index for robustness, though should not be necessary for arg in [0, 2*pi)\n                    b_index = min(b_index, B - 1)\n                \n                buckets[b_index].append(z)\n            \n            # Sort each bucket using the secondary key (modulus)\n            for i in range(B):\n                buckets[i].sort(key=np.abs)\n\n        else:\n            raise ValueError(f\"Invalid map_type: {map_type}. Must be 'modulus' or 'argument'.\")\n\n        # Concatenate buckets to get the final sorted list\n        sorted_list = []\n        for bucket in buckets:\n            sorted_list.extend(bucket)\n            \n        return sorted_list\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"params\": {\n                \"numbers\": [3+4j, -1+0.5j, 0+0j, 2-2j, -3-4j],\n                \"B\": 5, \"map_type\": \"modulus\", \"r_min\": 0.0, \"r_max\": 5.0\n            }\n        },\n        {\n            \"name\": \"Case 2\",\n            \"params\": {\n                \"numbers\": [1+0j, -1+0j, 0-1j, 0+1j, 0+0j, 1-1j, -1+1j],\n                \"B\": 8, \"map_type\": \"argument\"\n            }\n        },\n        {\n            \"name\": \"Case 3\",\n            \"params\": {\n                \"numbers\": [0.1+0.2j, -0.1-0.2j, 0.2-0.1j, 0+0j],\n                \"B\": 3, \"map_type\": \"modulus\", \"r_min\": 0.0, \"r_max\": 1.0\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        sorted_numbers = generalized_bucket_sort(**case[\"params\"])\n        # Format the result into a list of [Re, Im] pairs\n        formatted_result = [[z.real, z.imag] for z in sorted_numbers]\n        results.append(str(formatted_result))\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list is used, as it matches the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3219470"}, {"introduction": "当数据出现聚集时，朴素的桶排序算法性能会急剧下降，因为大多数元素可能会落入少数几个桶中。本练习旨在挑战您解决这个常见的性能问题。您将实现一种自适应桶排序，它通过从输入数据中抽取少量样本来确定非均匀的桶边界，从而有效地为稀疏区域创建更宽的桶，为密集集群创建更窄的桶。这项练习展示了一种强大的数据驱动优化技术，并突出了算法设计与数据统计属性之间的联系，帮助您构建更稳健、更高效的排序解决方案。[@problem_id:3219363]", "problem": "您的任务是实现一个非比较排序算法，该算法利用输入域的知识对实数进行排序。输入由闭区间 $[0.0, 1.0]$ 内的实数序列组成，并附带一条额外信息：在现实场景中，这些数字通常密集地聚集在 $0.0$ 和 $1.0$ 附近。您必须设计并实现一种自适应桶排序，该排序对 $[0.0, 1.0]$ 内的任何输入都保持正确，并通过减轻由数据聚集引起的桶不平衡来力求保持近线性的时间性能。\n\n请从以下基本且经过充分验证的事实出发：\n- 排序是重新排列一个序列使其变为非递减的任务。对于 $n$ 个独立的键，基于比较的排序算法在最坏情况下的平均比较次数下界为 $\\Omega(n \\log n)$；这可由决策树论证得出。\n- 桶排序并非纯粹基于比较；它利用键域的结构，根据元素的值将其放入桶中，然后对每个桶内进行排序。当元素来自一个足够规则的分布时，使用 $b$ 个桶会使每个桶的期望占用量接近 $n / b$，这使得在桶内采用合适的内部排序算法时，总的期望时间可以达到近线性。\n- 如果键的底层分布不均匀，而是密集地聚集在两端（此处指 $0.0$ 和 $1.0$ 附近），那么在 $[0.0, 1.0]$ 上使用等宽的桶会导致严重的失衡（两端的桶非常大），从而损害性能。一个有原则的补救方法是通过一个单调变换来使桶边界适应数据，该变换近似于累积分布函数（CDF），从而大致均衡桶的占用率。\n\n您的任务：\n- 实现一个用于处理实数数组 $x \\in [0.0, 1.0]$ 的自适应桶排序，该排序应满足：\n  1. 构造 $b$ 个桶，其边界是根据输入数据自适应选择的，以便即使在 $0.0$ 和 $1.0$ 附近存在严重聚集的情况下，每个桶的期望计数也大致平衡。您可以使用从输入中提取的小型试点样本来估计分位数并确定非均匀的桶边界，但您绝不能仅为了选择边界而对整个输入进行完全排序。\n  2. 使用稳定且确定性的规则处理边界值，将每个值放入唯一一个桶中。具体来说，当一个值等于桶的边界时，它必须被放入索引较高的桶中。\n  3. 稳定地对每个桶进行排序，然后按递增顺序连接各桶以生成最终结果。\n  4. 对 $[0.0, 1.0]$ 内的所有输入（无“非数字”或无穷大值）都是正确的，并通过保持典型的桶大小较小，在良性分布下以期望近线性时间为目标。\n- 科学现实性约束：从分布形状对桶占用率的影响方面证明该方法的合理性，并解释使用试点样本来近似分位数如何提供一种数据驱动的、对 $[0.0, 1.0]$ 的单调重参数化，从而有助于平衡桶。\n\n测试套件和答案规范：\n- 使用以下六个测试案例，每个都是 $[0.0, 1.0]$ 内的实数列表：\n  1. 在两端有密集聚类，并带有一些中间值：\n     $[0.0, 0.0005, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.45, 0.5, 0.48, 0.52, 0.55, 0.990, 0.991, 0.992, 0.993, 0.994, 0.995, 0.996, 0.997, 0.998, 0.999, 1.0]$。\n  2. 一个边界值多、重复值多且已按非递减顺序排列的案例：\n     $[0.0, 0.0, 0.0, 0.0, 0.0, 0.0001, 0.0002, 0.9998, 0.9999, 1.0, 1.0, 1.0, 1.0, 1.0]$。\n  3. 测试案例1的逆序（即，值的多重集相同，但按严格递减顺序排列）。\n  4. 单元素输入：\n     $[1.0]$。\n  5. 空输入：\n     $[\\ ]$（无元素）。\n  6. 大致均匀覆盖整个域：\n     $[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]$。\n- 对于每个测试案例，您的程序必须使用您实现的自适应桶排序计算排序后的输出，并与由标准稳定比较排序生成的参考非递减顺序进行验证。对于每个案例，输出一个布尔值，当且仅当您的结果与参考结果（逐元素）完全相等时为 `True`，否则为 `False`。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，对于三个测试案例，格式为 $[\\text{True},\\text{False},\\text{True}]$）。不应打印任何额外的空格或文本。\n\n角度单位和物理单位不适用于此问题。所有数值都是 $[0.0, 1.0]$ 范围内的无单位实数。", "solution": "该问题要求为闭区间 $[0.0, 1.0]$ 内的实数序列实现一个自适应桶排序算法。关键挑战在于即使输入数据在端点 $0.0$ 和 $1.0$ 附近高度聚集，也要保持效率，特别是近线性的时间复杂度。\n\n**1. 基本原理：标准桶排序与自适应桶排序**\n\n标准桶排序是一种高效的、非基于比较的排序算法，对于均匀分布的输入，其期望运行时间为线性。它的工作原理是将输入范围划分为若干个等宽的子区间，称为“桶”。对于一个包含 $n$ 个元素、范围在 $[0.0, M)$ 的输入数组，我们可以使用 $b$ 个桶，其中桶 $i$ 对应于区间 $[i \\cdot M/b, (i+1) \\cdot M/b)$。一个元素 $x$ 被放入索引为 $\\lfloor b \\cdot x / M \\rfloor$ 的桶中。在所有元素分配完毕后，对每个桶单独进行排序，然后将排好序的桶连接起来，生成最终的排序数组。\n\n总时间复杂度是分配时间（为 $\\mathcal{O}(n+b)$）和对所有桶进行排序的时间之和。如果输入数据来自均匀分布，每个桶期望包含 $n/b$ 个元素。如果我们在每个桶内对少量元素使用高效的排序算法（如插入排序），那么对所有桶进行排序的期望时间为 $\\sum_{i=0}^{b-1} \\mathcal{O}(n_i^2)$ 或 $\\sum_{i=0}^{b-1} \\mathcal{O}(n_i \\log n_i)$，其中 $n_i$ 是桶 $i$ 中的元素数量。当 $b \\approx n$ 时，每个桶的期望大小是常数，总的期望时间复杂度变为 $\\mathcal{O}(n)$。\n\n当输入分布不均匀时，这种标准方法的主要缺陷就显现出来了。如问题所述，如果数据高度聚集（例如在 $0.0$ 和 $1.0$ 附近），对应这些区域的桶将变得异常大。在最坏的情况下，几乎所有 $n$ 个元素都可能落入同一个桶中，导致性能退化到内部排序算法的水平，通常是 $\\mathcal{O}(n \\log n)$，从而抵消了桶排序的优势。\n\n**2. 自适应策略：数据驱动的桶边界**\n\n为了抵消非均匀分布的影响，算法必须使其桶边界适应数据本身。目标是定义非均匀宽度的桶区间，使得每个桶接收到的元素数量大致相同。这是通过创建一种数据驱动的、对区间 $[0.0, 1.0]$ 的单调重参数化来实现的。\n\n从任意分布获得均匀分布的理想变换是累积分布函数（CDF），记为 $F_X(x)$。对于一个随机变量 $X$，变换后的变量 $Y = F_X(X)$ 在 $[0,1]$ 上是均匀分布的。由于输入数据的真实CDF是未知的，我们必须对其进行近似。\n\n一种近似CDF逆函数（即分位数函数）的实用方法是从输入数据中抽取一个小的试点样本。通过找到该样本的分位数，我们可以建立桶的边界，这些边界在数据密集的区域间隔更细，在稀疏区域间隔更宽。\n\n**3. 算法设计与实现**\n\n所提出的自适应桶排序算法按以下步骤进行：\n\n1.  **处理边界情况**：对于大小 $n \\le 1$ 的输入数组，该数组已经是有序的。实现会原样返回它。\n\n2.  **采样**：为了遵守“不能仅为确定边界而对整个输入进行排序”的约束（这将是一个 $\\mathcal{O}(n \\log n)$ 的操作，违背了初衷），我们从输入数组中提取一个确定性的、亚线性的试点样本。一个系统性样本，通过以合适的步长 $k$ 从数组中每隔 $k$ 个元素取一个来创建，是一个很好的确定性策略。对于大小为 $n$ 的输入和期望的样本大小 $s  n$，我们可以设置 $k = \\lfloor n/s \\rfloor$。此采样步骤的成本为 $\\mathcal{O}(s)$。\n\n3.  **边界确定**：我们选择一定数量的桶，比如 $b$ 个。要创建 $b$ 个桶，我们需要 $b-1$ 个边界点。这些点通过计算试点样本的分位数来确定。例如，要创建 $b$ 个大小大致相等的桶，我们从排好序的样本中找到 $(1/b), (2/b), \\ldots, ((b-1)/b)$ 分位数。此步骤的成本主要由对样本排序决定，为 $\\mathcal{O}(s \\log s)$。由于 $s$ 在 $n$ 上是亚线性的，此成本低于 $\\mathcal{O}(n \\log n)$。这个关键步骤确保了整个算法仍然可能比基于比较的排序更快。如果样本产生重复的边界值（在聚集数据中很常见），则将它们移除以形成一个严格递增的唯一边界序列。\n\n4.  **分配**：利用自适应边界 $\\{p_1, p_2, \\ldots, p_{m-1}\\}$（其中 $m \\le b$ 是最终生成的桶数），我们可以创建 $m$ 个空桶。原始输入数组中的每个元素 $x$ 都被放入其对应的桶中。元素 $x$ 的桶索引可以通过在边界数组上进行二分查找来高效地找到。问题规定，等于边界值 $p_i$ 的元素必须放入索引较高的桶中。这对应于找到一个索引 $j$，使得 $p_{j-1} \\le x  p_j$（其中 $p_0 = -\\infty$ 且 $p_m = +\\infty$）。此分配步骤耗时 $\\mathcal{O}(n \\log m)$。\n\n5.  **排序与连接**：对 $m$ 个桶中的每一个单独进行排序。问题要求使用稳定排序。Python的内置 `list.sort()` 方法（Timsort）是稳定且高效的，尤其对于小型或近乎有序的列表，使其成为一个绝佳选择。最后，将排好序的桶中的元素按顺序连接起来，生成最终的排序数组。由于现在桶的负载是平衡的，此步骤的总时间期望会很低。\n\n这种自适应方法能正确排序来自 $[0.0, 1.0]$ 的任何输入，并通过确保任何单个桶的大小不会增长到占 $n$ 的一大部分，从而旨在保持期望的近线性时间复杂度 $\\mathcal{O}(n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_bucket_sort(arr: list[float]) - list[float]:\n    \"\"\"\n    Sorts a list of real numbers in [0.0, 1.0] using an adaptive bucket sort.\n\n    The algorithm uses a sample of the data to create non-uniform bucket\n    boundaries, aiming to balance the number of elements per bucket. This\n    makes it robust against clustered data distributions.\n    \"\"\"\n    n = len(arr)\n\n    # 1. Handle edge cases where sorting is trivial.\n    if n = 1:\n        return arr\n\n    # For very small arrays, a direct sort is more efficient than the\n    # overhead of bucket sort. This threshold is heuristic.\n    if n  4:\n        return sorted(arr)\n\n    # 2. Determine bucket boundaries adaptively.\n    # We choose a fixed number of buckets for simplicity.\n    num_buckets = 10\n    \n    # To comply with the \"no full sort for boundaries\" rule, we must use a sample\n    # with size s  n. Sorting this sample costs O(s log s).\n    # We use systematic sampling for determinism: take every k-th element.\n    # Here, we simply take every 2nd element, guaranteeing s  n.\n    step = 2\n    sample = np.array(arr[::step])\n\n    # Calculate quantiles from the sample to serve as bucket boundaries.\n    # np.quantile sorts the sample, costing O(s log s).\n    quantile_fractions = np.linspace(0, 1, num_buckets + 1)[1:-1]\n    \n    if len(sample) == 0:\n        # This can happen if n=1 and step  1. Handled by initial checks.\n        # As a fallback, use uniform buckets.\n        boundaries = np.linspace(0, 1, num_buckets + 1)[1:-1]\n    else:\n        boundaries = np.quantile(sample, quantile_fractions)\n    \n    # Remove duplicate boundaries to prevent empty buckets between identical boundary values.\n    unique_boundaries = np.unique(boundaries)\n    \n    # 3. Distribute elements into buckets.\n    # The number of actual buckets is `len(unique_boundaries) + 1`.\n    num_actual_buckets = len(unique_boundaries) + 1\n    buckets = [[] for _ in range(num_actual_buckets)]\n    \n    for x in arr:\n        # np.searchsorted performs a binary search to find the correct bucket index.\n        # side='right' places elements equal to a boundary in the higher-indexed bucket,\n        # as required by the problem statement.\n        bucket_idx = np.searchsorted(unique_boundaries, x, side='right')\n        buckets[bucket_idx].append(x)\n        \n    # 4. Sort each bucket and concatenate the results.\n    final_sorted_list = []\n    for bucket in buckets:\n        # Python's list.sort() (Timsort) is a stable and efficient algorithm.\n        bucket.sort()\n        final_sorted_list.extend(bucket)\n        \n    return final_sorted_list\n\ndef solve():\n    \"\"\"\n    Runs the adaptive bucket sort on the test suite and verifies correctness.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    case1 = [0.0, 0.0005, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.45, 0.5, 0.48, 0.52, 0.55, 0.990, 0.991, 0.992, 0.993, 0.994, 0.995, 0.996, 0.997, 0.998, 0.999, 1.0]\n    case2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0001, 0.0002, 0.9998, 0.9999, 1.0, 1.0, 1.0, 1.0, 1.0]\n    case3 = sorted(case1, reverse=True)\n    case4 = [1.0]\n    case5 = []\n    case6 = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n    \n    test_cases = [case1, case2, case3, case4, case5, case6]\n\n    results = []\n    for case in test_cases:\n        # Create a copy to ensure the original test case data is not modified.\n        input_list = list(case)\n        \n        # Get the result from the adaptive bucket sort implementation.\n        my_sorted_result = adaptive_bucket_sort(input_list)\n        \n        # Get the reference sorted list using a standard stable sort (Timsort).\n        reference_sorted_result = sorted(input_list)\n        \n        # Compare the results for correctness.\n        is_correct = (my_sorted_result == reference_sorted_result)\n        results.append(is_correct)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3219363"}, {"introduction": "对现实世界的浮点数据进行排序是一项复杂的任务，因为存在像 $\\mathrm{NaN}$、 $+\\infty$ 和 $-\\infty$ 这样的特殊值，使得像 $x \\lt y$ 这样的标准比较并非总是明确定义的。这个问题将引导您通过创建一个巧妙的保序映射来解决这一难题，该映射将每个浮点值（包括特殊值）转换为一个遵循 IEEE 754 总排序规则的对应整数键。通过应对这一挑战，您将更深刻地体会到算法与底层数据表示之间的相互作用，这是编写正确且稳健的数值软件的关键技能。[@problem_id:3219392]", "problem": "设计并实现一种改进的桶排序，该排序能够根据 IEEE 754 全序（total order）正确地对 IEEE 754 双精度浮点值进行排序，包括特殊值“非数”(NaN)、正无穷大和负无穷大。你的程序必须实现以下内容。\n\n1. 基本原理和约束。从核心定义开始：\n   - 桶排序假设一个包含 $n$ 个键的列表，这些键来自一个可以映射到 $B$ 个桶中的域，使得键近似均匀地分布在各个桶中。在每个桶内，应用一种稳定的、基于比较的方法（例如，插入排序），然后按顺序连接各个桶。\n   - IEEE 754 双精度浮点数分为带符号的零、有限数、带符号的无穷大和 NaN。标准比较运算符未在这些值上定义全序，因为任何与 NaN 的比较都是无序的。然而，IEEE 754 标准指定了一个全序，它区分 $-0.0$ 和 $+0.0$，将 $-\\infty$ 置于所有有限数之前，将 $+\\infty$ 置于所有有限数之后、所有 NaN 之前，并将所有 NaN 置于 $+\\infty$ 之后。\n\n2. 任务。设计一种有原则的方法来修改桶排序，使其：\n   - 能将任何有限的和特殊的双精度值排成 IEEE 754 全序，而不依赖于对 NaN 未定义的浮点比较。\n   - 桶的分配是基于一种保序映射，该映射将每个浮点值映射到一个整数键，该整数键根据 IEEE 754 全序是全序的，并且这个整数键被一致地用于桶的放置和桶内排序。\n   - 对于在全序下相等的值，该算法是稳定的。\n   - 对于大小为 $n$ 的输入，选择桶的数量 $B$ 为 $B=\\lceil \\sqrt{n} \\rceil$。\n   - 对于桶索引的计算，如果 $k_{\\min}$ 和 $k_{\\max}$ 分别是输入中的最小和最大整数键，那么每个键为 $k$ 的元素必须被放入索引为\n     $$\\left\\lfloor \\dfrac{(k - k_{\\min}) \\cdot B}{(k_{\\max} - k_{\\min}) + 1} \\right\\rfloor,$$\n     的桶中，即使所有键都相等，这也保证了索引在 $\\{0,1,\\dots,B-1\\}$ 范围内。\n\n3. 输出。对每个测试用例，输出排序后的列表。将所有测试用例的结果汇总到单行输出中，该行包含每个测试用例的结果，形式为用方括号括起来的逗号分隔列表，没有空格。例如，对于产生结果 $r_1$、$r_2$ 和 $r_3$ 的三个测试用例，程序必须以精确的格式打印单行\n   - $[r_1,r_2,r_3]$，\n   其中每个 $r_i$ 本身是一个列表字面量，其元素使用该语言的规范浮点字面量形式打印，即用 \"nan\" 表示 NaN，\"inf\" 表示 $+\\infty$，\"-inf\" 表示 $-\\infty$，带符号的零表示为 \"$-0.0$\" 和 \"$0.0$\"。\n\n4. 测试套件。你的程序必须硬编码并排序以下测试数组，并以上述指定格式输出它们的排序形式。\n   - 测试 A (正常路径，混合类型): $[3.0,\\ \\mathrm{NaN},\\ -\\infty,\\ +\\infty,\\ 2.5,\\ -0.0,\\ 0.0,\\ -1.0,\\ 1.0\\times10^{-308},\\ -1.0\\times10^{-308},\\ 0.5]$.\n   - 测试 B (边界情况，仅含特殊值): $[\\mathrm{NaN},\\ -\\infty,\\ +\\infty]$.\n   - 测试 C (零和次规范数): $[-0.0,\\ 0.0,\\ 5.0\\times10^{-324},\\ -5.0\\times10^{-324}]$.\n   - 测试 D (极端大小的有限数): $[1.7976931348623157\\times10^{308},\\ -1.7976931348623157\\times10^{308},\\ 2.2250738585072014\\times10^{-308},\\ -2.2250738585072014\\times10^{-308}]$.\n\n5. 答案格式。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，没有空格，并严格按照测试 A、B、C、D 的顺序。每个测试用例的结果必须是同样无空格格式的列表字面量。每个列表的元素必须打印为规范字面量：\"nan\" 表示 $\\mathrm{NaN}$，\"inf\" 表示 $+\\infty$，\"-inf\" 表示 $-\\infty$，并保留带符号的零。\n\n不应读取任何输入；程序必须是完全自包含的，并且必须只输出所要求的那一行。", "solution": "该问题要求设计并实现一种改进的桶排序算法，该算法能够根据标准中定义的 `totalOrder` 谓词对 IEEE 754 双精度浮点数进行排序。该顺序规定如下：\n$$-\\infty  \\dots  \\text{negative finite numbers}  -0.0  +0.0  \\text{positive finite numbers}  \\dots  +\\infty  \\text{NaNs}$$\n标准的基于比较的排序会失败，因为任何涉及非数 (NaN) 的比较都是未定义的。解决方案的核心是设计一个保序映射，将任意双精度浮点数 $x$ 映射到一个 $64$ 位无符号整数键 $k = f(x)$，使得对于任意两个浮点数 $x_1$ 和 $x_2$，如果在 `totalOrder` 下 $x_1  x_2$，则 $f(x_1)  f(x_2)$。之后桶排序就可以在这些整数键上操作。\n\n有原则的设计过程如下：\n\n1.  **浮点数的整数表示**：一个 IEEE 754 双精度浮点数存储为一个 $64$ 位的值。我们可以将这个位模式重新解释为一个 64 位无符号整数，称之为 $u$。这个整数 `u` 由一个符号位（最高有效位，MSB）、一个 $11$ 位指数和一个 $52$ 位小数部分组成。\n\n    -   如果符号位为 $0$（对于正数、$+0.0$、$+\\infty$ 和正 NaNs），浮点数的数值顺序与其 $u$ 表示的整数顺序直接对应。对于两个这样的浮点数 $x_1$ 和 $x_2$，如果 $x_1  x_2$，则 $u_1  u_2$。\n    -   如果符号位为 $1$（对于负数、$-0.0$、$-\\infty$ 和负 NaNs），数值顺序与其 $u$ 表示的整数顺序相反。对于两个这样的浮点数 $x_1$ 和 $x_2$，如果 $x_1  x_2$，则 $u_1 > u_2$。这是因为该表示法是符号-数值（sign-magnitude）表示法，其中当 MSB 为 $1$ 时，更大的量值（更负的数）会导致更大的整数表示。\n\n2.  **构建保序键映射**：为了建立一个遵循 `totalOrder` 的单一单调键序列，我们将浮点数映射到一个 $64$ 位无符号整数键空间。我们可以将所有负值映射到键空间的下半部分 ($[0, 2^{63}-1]$)，并将所有正值映射到上半部分 ($[2^{63}, 2^{64}-1]$)。\n\n    -   **对于符号位为 $1$ 的浮点数 $x$（负值）**：其 `uint64` 表示 $u$ 是反序的。为了纠正这一点，我们应用一个逆序转换。按位非（bitwise NOT）操作 $\\sim u$（对于 64 位无符号整数，等价于 $(2^{64}-1) - u$）可以达到此目的。例如，$u(-0.0) = 0x8000000000000000$ 映射为 $\\sim u = 0x7FFFFFFFFFFFFFFF$，而 $u(-\\infty) = 0xFFF0000000000000$ 映射为 $\\sim u = 0x000FFFFFFFFFFFFF$。这正确地将 $-\\infty$ 放在此键范围的低端，将 $-0.0$ 放在高端。\n\n    -   **对于符号位为 $0$ 的浮点数 $x$（正值）**：其 `uint64` 表示 $u$ 已经是保序的。为确保这些键大于所有来自负浮点数的键，我们将它们移到 $64$ 位范围的上半部分。这通过将 $u$ 加上 $2^{63}$（即 $0x8000000000000000$）来实现。例如，$u(+0.0)=0x0$ 映射为 $0x8000000000000000$，而 $u(+\\infty)=0x7FF0000000000000$ 映射为 $0xFFF0000000000000$。\n\n    这个映射函数 $f(x)$ 定义如下：\n    $$\n    f(x) = \\begin{cases} (2^{64}-1) - u  \\text{if sign bit of } u \\text{ is } 1 \\\\ u + 2^{63}  \\text{if sign bit of } u \\text{ is } 0 \\end{cases}\n    $$\n    其中 $u$ 是浮点数 $x$ 的 $64$ 位无符号整数表示。这个函数在整数键上正确地建立了一个与 IEEE 754 `totalOrder` 相匹配的全序，包括 $-0.0$ 和 $+0.0$ 的相对顺序。\n\n3.  **改进的桶排序算法**：\n    -   **第 1 步：生成键**：对于大小为 $n$ 的输入数组中的每个浮点数 $x_i$，计算其对应的整数键 $k_i = f(x_i)$。将这些存储为序对 $(k_i, x_i)$。\n    -   **第 2 步：桶初始化**：在所有生成的键中找到最小键 $k_{\\min}$ 和最大键 $k_{\\max}$。桶的数量 $B$ 设置为 $\\lceil \\sqrt{n} \\rceil$。创建 $B$ 个空桶。\n    -   **第 3 步：分配**：对于每个序对 $(k, x)$，使用问题中指定的公式计算其桶索引 $j$：\n      $$j = \\left\\lfloor \\dfrac{(k - k_{\\min}) \\cdot B}{(k_{\\max} - k_{\\min}) + 1} \\right\\rfloor$$\n      这个公式确保索引 $j$ 在有效范围 $\\{0, 1, \\dots, B-1\\}$ 内。此处利用 Python 任意精度整数的特性来计算分子，以防止计算过程中的溢出。将序对 $(k, x)$ 放入桶 $j$ 中。\n    -   **第 4 步：桶内排序**：根据整数键 $k$ 单独对每个桶进行排序。为了满足稳定性要求，必须使用稳定的排序算法。插入排序是一种简单、稳定的算法，适合此任务，因为桶预计会很小且近乎有序。\n    -   **第 5 步：连接**：按从桶 $0$ 到桶 $B-1$ 的顺序连接已排序的桶，以生成最终的有序序对序列。\n    -   **第 6 步：最终结果**：从排序后的序对序列中提取原始浮点值，以获得最终的排序数组。整个过程是稳定的，因为键映射是确定性的，且桶内排序是稳定的。\n\n这种有原则的方法正确地将一个对于标准比较运算符来说定义不明确的问题转换为了一个定义明确的整数排序问题，然后使用桶排序高效地解决该问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing a modified bucket sort for IEEE 754 doubles,\n    including special values, and printing the sorted results for the given test suite.\n    \"\"\"\n\n    def float_to_key(x: float) - np.uint64:\n        \"\"\"\n        Maps an IEEE 754 double-precision float to a 64-bit unsigned integer key\n        that preserves the IEEE 754 totalOrder.\n        \"\"\"\n        # Reinterpret the 64-bit float as a 64-bit unsigned integer.\n        u = np.float64(x).view(np.uint64)\n        \n        # Check the sign bit (the most significant bit).\n        if (u >> 63) == 1:\n            # Negative floats (including -0.0, -inf, and negative NaNs).\n            # Their uint64 representation is in reverse of the desired totalOrder.\n            # Applying bitwise NOT (on 64 bits) reverses the order.\n            # In Python, ~u doesn't work as expected for uint64, so we simulate it.\n            return np.uint64((1  64) - 1) - u\n        else:\n            # Positive floats (including +0.0, +inf, and positive NaNs).\n            # Their uint64 representation is already in the correct relative order.\n            # We add 2**63 to shift them to the upper half of the uint64 range,\n            # ensuring all positive keys are greater than all negative keys.\n            return u + np.uint64(1  63)\n\n    def insertion_sort(bucket: list):\n        \"\"\"\n        Sorts a bucket (list of (key, value) tuples) in-place using insertion sort.\n        This is a stable sorting algorithm.\n        \"\"\"\n        for i in range(1, len(bucket)):\n            key_item = bucket[i]\n            j = i - 1\n            # Compare items based on their integer key (item[0]).\n            while j = 0 and bucket[j][0]  key_item[0]:\n                bucket[j + 1] = bucket[j]\n                j -= 1\n            bucket[j + 1] = key_item\n\n    def modified_bucket_sort(arr: list) - list:\n        \"\"\"\n        Sorts a list of floats using a modified bucket sort algorithm.\n        \"\"\"\n        n = len(arr)\n        if n = 1:\n            return arr\n        \n        # 1. Map floats to order-preserving integer keys.\n        keyed_arr = [(float_to_key(x), x) for x in arr]\n\n        # 2. Find min and max keys.\n        keys = [item[0] for item in keyed_arr]\n        k_min = min(keys)\n        k_max = max(keys)\n\n        # 3. Initialize buckets.\n        num_buckets = math.ceil(math.sqrt(n))\n        buckets = [[] for _ in range(num_buckets)]\n\n        # If all keys are the same, all items go to the first bucket.\n        if k_max == k_min:\n            denominator = np.uint64(1)\n        else:\n            denominator = k_max - k_min + np.uint64(1)\n        \n        # 4. Distribute items into buckets.\n        for item in keyed_arr:\n            k = item[0]\n            # Use Python's arbitrary-precision integers for the numerator to avoid overflow.\n            numerator = (int(k) - int(k_min)) * num_buckets\n            idx = numerator // int(denominator)\n            buckets[idx].append(item)\n            \n        # 5. Sort each bucket and concatenate the results.\n        sorted_arr = []\n        for bucket in buckets:\n            # Use a stable sort (insertion sort as specified).\n            insertion_sort(bucket)\n            sorted_arr.extend(bucket)\n            \n        # 6. Extract the original float values.\n        return [item[1] for item in sorted_arr]\n\n    def format_float(f: float) - str:\n        \"\"\"\n        Formats a float into the required string representation for special values.\n        \"\"\"\n        if np.isnan(f):\n            return \"nan\"\n        if np.isposinf(f):\n            return \"inf\"\n        if np.isneginf(f):\n            return \"-inf\"\n        if f == 0.0 and np.signbit(f):\n            return \"-0.0\"\n        return str(f)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A (happy path, mixture)\n        [3.0, np.nan, -np.inf, np.inf, 2.5, -0.0, 0.0, -1.0, 1.0e-308, -1.0e-308, 0.5],\n        # Test B (boundary with only specials)\n        [np.nan, -np.inf, np.inf],\n        # Test C (zeros and subnormals)\n        [-0.0, 0.0, 5.0e-324, -5.0e-324],\n        # Test D (extreme finite magnitudes)\n        [1.7976931348623157e+308, -1.7976931348623157e+308, 2.2250738585072014e-308, -2.2250738585072014e-308],\n    ]\n\n    results_str = []\n    for case in test_cases:\n        sorted_list = modified_bucket_sort(case)\n        formatted_list_str = \",\".join([format_float(x) for x in sorted_list])\n        results_str.append(f\"[{formatted_list_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3219392"}]}