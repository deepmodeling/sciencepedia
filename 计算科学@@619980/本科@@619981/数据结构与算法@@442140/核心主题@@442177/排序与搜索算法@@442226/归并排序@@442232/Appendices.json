{"hands_on_practices": [{"introduction": "归并排序通常用数组来教学，但其核心思想同样适用于其他数据结构。本练习将归并排序应用于单向链表，这种数据结构不支持常数时间的随机访问。你将探索如何在无法直接使用索引的情况下实现“分割”步骤，以及在节点不可变的约束下完成“合并”操作，从而深化对算法本质的理解。[@problem_id:3252314]", "problem": "您的任务是设计并实现一个稳定的、基于比较的排序算法，该算法作用于一个单链表，并受限于原始节点不可变的约束。您的推理必须从单链表和分治范式的定义开始：单链表是一个节点序列，每个节点包含一个值和一个指向下一个节点的指针；分治法则是将输入划分为子问题，递归地解决每个子问题，然后合并结果。您不能依赖任何预先提供的算法捷径；必须从这些基础出发推导出方法。具体约束是原始节点的 next 指针不能被修改；排序后的输出必须构建为一个新的单链表，其节点是新分配的。该算法必须是稳定的，这意味着如果两个元素具有相等的键，它们在输出中的相对顺序必须与它们在输入中的相对顺序相匹配。您的程序必须为一套涵盖一般情况、边界条件和边缘情况的测试套件生成可量化的输出。\n\n要求：\n1. 数据模型和约束：\n   - 输入是一个单链表，每个节点包含一个整数键和可选的符号标签。\n   - 原始列表的 next 指针必须被视为不可变的。您只能创建新节点；您可以读取原始节点，但不得修改任何原始的 next 指针。\n   - 输出必须是一个新的单链表，包含相同的键，按非递减顺序排序，并保持稳定性。\n2. 算法设计任务：\n   - 实现一个稳定的归并排序算法，作用于单链表，该算法通过构建一个排序后的副本来完成，而不修改原始节点。合并操作的设计必须通过根据原始的从左到右的优先级来解决键相等的情况，从而保持稳定性。\n   - 确定将列表分成两半而不改变原始指针的方法（例如，通过将指针按计算出的中点位置推进），并从第一性原理出发论证其正确性和复杂性。\n3. 复杂度和正确性期望：\n   - 算法的运行时间应为 $\\mathcal{O}(n \\log n)$，其中 $n$ 是输入列表中的节点数；使用的额外内存应为 $\\mathcal{O}(n)$（用于新分配的节点）加上 $\\mathcal{O}(\\log n)$（因递归产生的栈帧）。请从分治结构和单链表的属性推导这些界限，而不是依赖记忆的公式。\n4. 测试套件和输出：\n   - 将您的实现应用于以下输入测试套件。每个测试用例指定一个键序列；当标签存在时，它们是不用于比较的次要标签，旨在验证稳定性。\n     - 测试用例 $1$ (一般情况): 键 $\\left[4,1,3,9,7,0,2,5,8,6\\right]$。\n     - 测试用例 $2$ (边界：空列表): 键 $\\left[\\,\\right]$。\n     - 测试用例 $3$ (边界：单个元素): 键 $\\left[42\\right]$。\n     - 测试用例 $4$ (重复项): 键 $\\left[5,3,3,5,2,2,1,1\\right]$。\n     - 测试用例 $5$ (已排序): 键 $\\left[1,2,3,4,5\\right]$。\n     - 测试用例 $6$ (负数和混合数): 键 $\\left[-3,-1,-7,0,2\\right]$。\n     - 测试用例 $7$ (使用标签进行稳定性验证): 对偶 $\\left[(2,a),(1,x),(2,b),(1,y),(2,c)\\right]$，其中键是第一部分，标签 $a,x,b,y,c$ 是符号标签。仅按键排序，并通过检查每个等键组内标签的出现顺序是否与原始输入中相同来验证输出的稳定性。\n   - 对于测试用例 $1$ 到 $6$，将排序后的键作为整数列表输出。对于测试用例 $7$，输出一个布尔值，断言稳定性是否成立（当且仅当等键组内的标签顺序被保留时为真）。\n5. 最终输出格式：\n   - 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔的结果列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_7\\right]$。每个 $\\text{result}_i$ 必须是整数列表或布尔值，并严格按照上述测试用例的顺序排列。不应打印任何额外的文本或行。\n\n此问题不涉及物理单位、角度单位或百分比；仅需要纯整数键和布尔值输出。", "solution": "问题陈述要求设计并实现一个稳定的、基于比较的排序算法，作用于一个单链表。核心约束是原始列表的节点是不可变的（它们的 `next` 指针不能被改变），并且排序后的输出必须是一个新构建的链表。解决方案必须从分治范式的第一性原理推导出来。\n\n### **问题验证**\n\n**第一步：提取已知条件**\n\n*   **输入数据结构**：一个单链表，每个节点包含一个整数 `key` 和一个可选的符号 `tag`。\n*   **不可变性约束**：原始输入列表中节点的 `next` 指针不得被修改。\n*   **输出数据结构**：一个新的单链表，带有新分配的节点，包含与输入相同的数据，按键的非递减顺序排序。\n*   **算法要求**：一个从分治范式推导出的稳定归并排序。\n*   **稳定性要求**：如果两个元素具有相等的键，它们在排序后输出中的相对顺序必须与它们在输入中的相对顺序相同。\n*   **复杂度要求**：\n    *   时间：$\\mathcal{O}(n \\log n)$。\n    *   空间：$\\mathcal{O}(n)$ 用于新节点，$\\mathcal{O}(\\log n)$ 用于递归栈。这些界限必须被推导出来。\n*   **测试用例**：\n    1.  键：$\\left[4,1,3,9,7,0,2,5,8,6\\right]$\n    2.  键：$\\left[\\,\\right]$\n    3.  键：$\\left[42\\right]$\n    4.  键：$\\left[5,3,3,5,2,2,1,1\\right]$\n    5.  键：$\\left[1,2,3,4,5\\right]$\n    6.  键：$\\left[-3,-1,-7,0,2\\right]$\n    7.  键-标签对：$\\left[(2,a),(1,x),(2,b),(1,y),(2,c)\\right]$\n*   **输出格式**：单行输出，包含一个用方括号括起来的逗号分隔的结果列表（对于用例 $1$-$6$ 是排序后的整数列表，对于用例 $7$ 是布尔值）。\n\n**第二步：使用提取的已知条件进行验证**\n\n问题是有效的。\n*   **有科学依据**：该问题是计算机科学中的一个经典练习，专注于链表、排序算法（特别是归并排序）和算法复杂度这些已成熟的主题。\n*   **定义明确**：目标、约束和要求的输出都得到了精确的说明。单链表、不可变性约束和稳定性要求的结合，定义了一个虽然不简单但可解的问题，对于任何给定的输入都有一个唯一、正确的输出。\n*   **目标明确**：问题使用正式、无歧义的语言陈述。\n\n问题没有违反任何无效性标准。它在算法领域内是一个完整、一致且可形式化的问题。\n\n**第三步：结论与行动**\n\n此问题是 **有效的**。将提供一个解决方案。\n\n### **基于原则的解决方案**\n\n#### **1. 基本原则**\n\n**单链表**是一种线性数据结构，由一系列节点组成。每个节点存储一个有效载荷（本例中为一个键和可选的标签）和一个指向后续节点的单一引用或指针。通过对列表第一个节点（即 `head`）的引用来访问列表。最后一个节点的指针为 `null`，表示列表的结束。\n\n**分治**范式是一种算法策略，包含三个阶段：\n1.  **分解 (Divide)**：将问题划分为多个规模更小、独立的同类型子问题。\n2.  **解决 (Conquer)**：解决这些子问题，通常通过递归应用相同算法。如果子问题足够小（基本情况），则直接解决。\n3.  **合并 (Combine)**：将子问题的解合并起来，以构建原问题的解。\n\n我们将应用此范式来排序一个长度为 $n$ 的单链表。\n\n#### **2. 算法设计：针对链表的不可变归并排序**\n\n**基本情况 (解决)**\n最简单的排序情况是空列表或只有一个元素的列表。根据定义，这两种情况都已经是有序的。\n- 如果列表长度为 $n=0$（为空），则其排序版本也是一个空列表。\n- 如果列表长度为 $n=1$，则其排序版本是一个新列表，包含一个新分配的、具有相同值的单个节点。\n\n**分解步骤**\n分解步骤的核心是将长度为 $n$ 的列表分成两个大小约相等的子列表，长度分别为 $\\lfloor n/2 \\rfloor$ 和 $\\lceil n/2 \\rceil$。在数组中，这是一个通过索引计算实现的 $\\mathcal{O}(1)$ 操作。对于单链表，我们必须遍历列表以找到中点。为了在不修改原始列表指针的情况下做到这一点，我们首先找到列表的总长度 $n$。中点位于索引 $m = \\lfloor n/2 \\rfloor$ 处。第一个子列表是从 `head` 开始到长度为 $m$ 的节点序列。第二个子列表从索引 $m$ 处的节点开始，一直到原始列表的末尾，长度为 $n - m$。\n\n为了实现这一点，我们的递归排序函数将接受一个起始节点和待排序列表段的长度。\n1.  计算中点索引：$m = \\lfloor \\text{length}/2 \\rfloor$。\n2.  通过从当前头节点开始并将其指针推进 $m$ 次来找到右子列表的头节点。\n3.  左子列表由原始头节点和长度 $m$ 定义。\n4.  右子列表由步骤2中找到的新头节点和长度 $\\text{length} - m$ 定义。\n\n这个划分过程需要 $\\mathcal{O}(m) = \\mathcal{O}(n)$ 步的遍历来找到第二个子列表的头节点。\n\n**递归调用 (解决)**\n在概念上划分列表后，我们对两个子列表递归调用排序函数：\n- `sorted_left = mergesort(head_left, m)`\n- `sorted_right = mergesort(head_right, \\text{length} - m)`\n\n每个递归调用返回一个新的、已排序的链表。\n\n**合并步骤 (Merge)**\n此步骤接收两个已排序的链表 `sorted_left` 和 `sorted_right`，并将它们合并成一个单一的、新构建的、已排序的链表。这个合并操作是该算法稳定性和名称的来源。\n\n1.  为新列表创建一个 `dummy_head`。这通过提供一个固定的入口点来简化逻辑，避免了对第一个节点插入的特殊处理。一个 `tail` 指针将跟踪新列表的最后一个节点，初始指向 `dummy_head`。\n2.  当 `sorted_left` 和 `sorted_right` 都非空时进行迭代。在每次迭代中，比较两个列表当前头节点的键。\n3.  **稳定性**：为确保稳定性，如果 `sorted_left.key = sorted_right.key`，我们必须从 `sorted_left` 中选择节点。这条规则保证了对于键相等的元素，那个在原始输入中先出现（因此在左子列表中）的元素会被先放入输出中。\n    - 如果 `sorted_left.key = sorted_right.key`：用 `sorted_left` 的数据创建一个新节点，将其附加到 `tail.next`，然后前移 `sorted_left` 指针。\n    - 否则：用 `sorted_right` 的数据创建一个新节点，将其附加到 `tail.next`，然后前移 `sorted_right` 指针。\n4.  更新 `tail` 指针，使其指向新创建的节点。\n5.  循环终止后，其中一个列表将被耗尽。另一个列表可能仍包含元素。必须将剩余的（已排序的）部分附加到新列表中。这通过遍历剩余的节点并为每个节点创建新副本来附加到 `tail` 来完成。\n6.  最终排序好的列表是 `dummy_head.next`。\n\n这个合并过程会检查 $n$ 个元素中的每一个一次，并为每个元素创建一个新节点，因此合并步骤的时间和空间复杂度均为 $\\mathcal{O}(n)$。\n\n#### **3. 复杂度和正确性分析**\n\n**时间复杂度**\n设 $T(n)$ 表示排序一个长度为 $n$ 的列表所需的时间。\n- **分解**：找到中点需要 $\\mathcalO(n)$ 时间。\n- **解决**：对大小近似为 $n/2$ 的子问题进行两次递归调用，耗时 $2T(n/2)$。\n- **合并**：合并两个已排序的子列表需要 $\\mathcalO(n)$ 时间。\n\n递推关系为：$T(n) = 2T(n/2) + \\mathcal{O}(n)$。基本情况是 $T(1) = \\mathcal{O}(1)$。\n这是经典的归并排序递推式。我们可以通过递归树来分析它：\n- **第 0 层**：一个大小为 $n$ 的问题。分解/合并成本：$c \\cdot n$。\n- **第 1 层**：两个子问题，每个大小为 $n/2$。总成本：$2 \\cdot c \\cdot (n/2) = c \\cdot n$。\n- **第 k 层**：$2^k$ 个子问题，每个大小为 $n/2^k$。总成本：$2^k \\cdot c \\cdot (n/2^k) = c \\cdot n$。\n当问题大小为 $1$ 时递归停止，这发生在第 $k$ 层，其中 $n/2^k = 1$，即 $k = \\log_2 n$。\n总时间是所有层成本的总和：$(\\text{层数}) \\times (\\text{每层成本}) = (\\log_2 n) \\times (c \\cdot n)$。\n因此，时间复杂度为 $\\mathcal{O}(n \\log n)$。\n\n**空间复杂度**\n- **输出列表**：问题规范要求创建一个新的排序列表。这需要分配 $n$ 个新节点，导致 $\\mathcal{O}(n)$ 的空间复杂度。这是问题的固有要求，而非辅助成本。\n- **递归栈**：递归树的最大深度为 $\\log_2 n$。每次递归调用在调用栈上为其参数和局部变量消耗常数空间。因此，递归栈使用的辅助空间为 $\\mathcal{O}(\\log n)$。\n\n总空间复杂度为 $\\mathcal{O}(n)$（用于输出）+ $\\mathcal{O}(\\log n)$（用于栈），主要由线性项主导，因此为 $\\mathcal{O}(n)$。问题陈述正确地要求将这两个部分分开识别。\n\n**稳定性分析**\n稳定性由 `merge` 函数保证。在合并两个列表时，如果两个键相等，即 `key1 == key2`，我们的规则 `key1 = key2` 确保选择来自左子列表（`list1`）的元素。由于分解阶段保留了子列表内元素的相对顺序，这一选择始终将原本在左侧的元素置于原本在右侧的元素之前，从而在整个排序过程中保持它们最初的相对顺序。此属性在每个合并步骤中都成立，从而确保最终排序的列表是稳定的。带有标签的测试用例专门用于验证此属性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Data model for the singly linked list\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, key, tag=None, next_node=None):\n        self.key = key\n        self.tag = tag\n        self.next = next_node\n\n    def __repr__(self):\n        if self.tag is not None:\n            return f\"Node(key={self.key}, tag={self.tag})\"\n        return f\"Node(key={self.key})\"\n\n# Helper functions for list manipulation\ndef create_linked_list(data):\n    \"\"\"Creates a singly linked list from an iterable of keys or (key, tag) tuples.\"\"\"\n    dummy = Node(0)\n    current = dummy\n    for item in data:\n        if isinstance(item, tuple):\n            key, tag = item\n            current.next = Node(key, tag)\n        else:\n            current.next = Node(item)\n        current = current.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    \"\"\"Converts a singly linked list back to a Python list of keys.\"\"\"\n    result = []\n    current = head\n    while current:\n        result.append(current.key)\n        current = current.next\n    return result\n\ndef check_stability(original_data, sorted_head):\n    \"\"\"\n    Verifies the stability of the sort.\n    - True if for every key, the tags in the sorted output appear in the\n      same relative order as in the original input.\n    - False otherwise.\n    \"\"\"\n    if not original_data:\n        return True\n\n    original_tags_by_key = {}\n    for key, tag in original_data:\n        if key not in original_tags_by_key:\n            original_tags_by_key[key] = []\n        original_tags_by_key[key].append(tag)\n    \n    sorted_tags_by_key = {}\n    current = sorted_head\n    while current:\n        key, tag = current.key, current.tag\n        if key not in sorted_tags_by_key:\n            sorted_tags_by_key[key] = []\n        sorted_tags_by_key[key].append(tag)\n        current = current.next\n\n    for key in original_tags_by_key:\n        if key not in sorted_tags_by_key:\n            # This case shouldn't happen in a correct sort\n            return False \n        if original_tags_by_key[key] != sorted_tags_by_key[key]:\n            return False\n            \n    return True\n\n# Core Mergesort Algorithm\ndef _merge(left, right):\n    \"\"\"\n    Merges two sorted linked lists into a new sorted list, maintaining stability.\n    \"\"\"\n    dummy_head = Node(None)\n    tail = dummy_head\n    \n    p1, p2 = left, right\n    \n    while p1 is not None and p2 is not None:\n        # The = condition is crucial for stability\n        if p1.key = p2.key:\n            tail.next = Node(p1.key, p1.tag)\n            p1 = p1.next\n        else:\n            tail.next = Node(p2.key, p2.tag)\n            p2 = p2.next\n        tail = tail.next\n        \n    # Append remaining nodes from either list (one of them must be exhausted)\n    # New nodes must be created to respect the immutability of the sub-lists.\n    remaining = p1 if p1 is not None else p2\n    while remaining is not None:\n        tail.next = Node(remaining.key, remaining.tag)\n        tail = tail.next\n        remaining = remaining.next\n\n    return dummy_head.next\n\ndef _mergesort_recursive(head, length):\n    \"\"\"\n    Recursively divides the list and merges the sorted halves.\n    \"\"\"\n    # Base case: A list of length 0 or 1 is already sorted.\n    if length = 1:\n        if head is None:\n            return None\n        # Return a new list of one element\n        return Node(head.key, head.tag)\n\n    # Divide: Find the midpoint and split the list conceptually.\n    mid = length // 2\n    \n    # Traverse to the head of the right sublist\n    mid_node = head\n    for _ in range(mid):\n        mid_node = mid_node.next\n\n    # Conquer: Recursively sort both halves.\n    # The first half is from `head` with length `mid`.\n    # The second half is from `mid_node` with length `length - mid`.\n    left_sorted_head = _mergesort_recursive(head, mid)\n    right_sorted_head = _mergesort_recursive(mid_node, length - mid)\n    \n    # Combine: Merge the two sorted halves.\n    return _merge(left_sorted_head, right_sorted_head)\n\ndef mergesort(head):\n    \"\"\"\n    Public entry point for the mergesort algorithm.\n    \"\"\"\n    # First, determine the length of the list.\n    length = 0\n    current = head\n    while current:\n        length += 1\n        current = current.next\n    \n    return _mergesort_recursive(head, length)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'keys': [4,1,3,9,7,0,2,5,8,6], 'type': 'sort'},\n        {'keys': [], 'type': 'sort'},\n        {'keys': [42], 'type': 'sort'},\n        {'keys': [5,3,3,5,2,2,1,1], 'type': 'sort'},\n        {'keys': [1,2,3,4,5], 'type': 'sort'},\n        {'keys': [-3,-1,-7,0,2], 'type': 'sort'},\n        {'keys': [(2,'a'),(1,'x'),(2,'b'),(1,'y'),(2,'c')], 'type': 'stability'},\n    ]\n\n    results = []\n    for case in test_cases:\n        input_data = case['keys']\n        head = create_linked_list(input_data)\n        \n        sorted_head = mergesort(head)\n        \n        if case['type'] == 'sort':\n            result = linked_list_to_list(sorted_head)\n            # Use repr to get the list format with brackets\n            results.append(repr(result))\n        elif case['type'] == 'stability':\n            is_stable = check_stability(input_data, sorted_head)\n            # Use standard Python boolean representation ('True'/'False')\n            results.append(str(is_stable))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3252314"}, {"introduction": "归并排序的分治结构不仅能用于排序，还能高效解决复杂的计数问题。此练习要求在归并排序的合并阶段，统计满足 $A[i] > 2 \\cdot A[j]$ 且 $i  j$ 的“重要逆序对”数量。通过这个练习，你将学会如何利用归并排序的内在属性来解决超越排序本身的问题，从而更深刻地体会分治思想的精髓。[@problem_id:3252453]", "problem": "给定一个在整数全序域上的长度为 $n$ 的数组 $A$，其中全序关系 $\\le$ 满足传递性、反对称性和完全性。基本基础是分治法 (DC) 的定义：将一个大小为 $n$ 的集合上的问题分解为更小子集上的子问题，独立解决这些子问题，并使用问题既定的不变量（在此，不变量是合并步骤后数组有序）来组合解。您的任务是实现一个分治归并排序的变体，在其归并步骤中，计算跨子数组的索引对 $(i,j)$（其中 $0 \\le i  j  n$）且满足 $A[i] > 2 \\cdot A[j]$ 的数量。最终的算法必须为每个输入数组返回两个输出：数组的排序后版本和整个数组中此类配对的总数。期望的计算复杂度为 $\\mathcal{O}(n \\log n)$ 时间和 $\\mathcal{O}(n)$ 辅助空间，这源于归并排序的标准特性。\n\n要求：\n- 使用数组、全序关系和分治归并排序结构的定义作为基本基础。在组合步骤中，只比较或合并来自左子数组和右子数组的元素。\n- 只计算满足数组索引顺序 $i  j$ 的配对 $(i,j)$，并且在归并步骤中，$i$ 属于左子数组，$j$ 属于右子数组；将所有递归层级的这些计数汇总，即可得到原始数组中满足 $A[i] > 2 \\cdot A[j]$ 的配对总数。\n- 对每个测试用例，生成一个包含两个元素的列表：排序后的数组和配对的整数计数。\n\n测试套件：\n- 情况 1：$A = []$。\n- 情况 2：$A = [5]$。\n- 情况 3：$A = [1,3,2,3,1]$。\n- 情况 4：$A = [10,9,8,7,6,5,4,3,2,1]$。\n- 情况 5：$A = [-5,-4,-2,-1]$。\n- 情况 6：$A = [0,0,0,0]$。\n- 情况 7：$A = [2,4,3,5,1,-2,8,16]$。\n- 情况 8：$A = [2147483647,-2147483648]$。\n\n最终输出格式：\n- 您的程序应产生一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个项目本身必须是一个形式为 $[\\text{sorted\\_array}, \\text{count}]$ 的双元素列表。例如，一个包含两个用例的有效输出应如下所示：$[[[1,2,3],2],[[1],0]]$。您的程序不得读取任何输入，并且必须使用上述数组作为内置测试套件。", "solution": "该问题要求实现一个分治算法，具体来说是归并排序的一个变体，用以计算一个长度为 $n$ 的数组 $A$ 中满足 $i  j$ 和 $A[i] > 2 \\cdot A[j]$ 的索引对 $(i, j)$ 的数量。该算法还必须返回数组的排序后版本。规定的计算复杂度为 $\\mathcal{O}(n \\log n)$ 时间和 $\\mathcal{O}(n)$ 辅助空间。\n\n解决方案的基础在于分治 (DC) 范式。一个大小为 $n$ 的集合上的问题被递归地分解为更小的、独立的子问题。这些子问题的解随后被组合起来，形成原始问题的解。对于计数配对的任务，这一原则可以形式化如下：\n\n令 $C(A)$ 为数组 $A$ 中满足给定条件的配对数量。当我们将 $A$ 在其中点 $m = \\lfloor n/2 \\rfloor$ 分割成左子数组 $A_{left} = A[0 \\dots m-1]$ 和右子数组 $A_{right} = A[m \\dots n-1]$ 时，任何满足 $i  j$ 的配对 $(i,j)$ 必然属于以下三种不相交的类别之一：\n1. 索引 $i$ 和 $j$ 都在左子数组中。\n2. 索引 $i$ 和 $j$ 都在右子数组中。\n3. 索引 $i$ 在左子数组中，索引 $j$ 在右子数组中。\n\n这种分解给出了总数的递推关系：\n$$ C(A) = C(A_{left}) + C(A_{right}) + C_{cross}(A_{left}, A_{right}) $$\n其中 $C_{cross}$ 表示一个元素来自左子数组、另一个来自右子数组的配对数量。这种结构天然适合基于归并排序的算法。对子数组的递归调用处理了前两项，而 $C_{cross}$ 项在归并步骤中计算。\n\n该算法是一个递归函数，我们称之为 `Solve(A)`，它返回一个包含 $A$ 的排序后版本和所需配对数量的元组。\n\n**基本情况：**\n如果数组 $A$ 的长度 $n \\le 1$，那么它根据定义已经是有序的，并且不可能存在满足 $i  j$ 的配对 $(i,j)$。因此，函数返回 $(A, 0)$。\n\n**递归步骤：**\n对于长度为 $n > 1$ 的数组 $A$，函数执行以下步骤：\n1.  **分解 (Divide)：** 将数组 $A$ 分为两半：$A_{left} = A[0 \\dots m-1]$ 和 $A_{right} = A[m \\dots n-1]$，其中 $m = \\lfloor n/2 \\rfloor$。\n2.  **解决 (Conquer)：** 对每一半递归调用该函数：\n    - $(S_{left}, count_{left}) = \\text{Solve}(A_{left})$\n    - $(S_{right}, count_{right}) = \\text{Solve}(A_{right})$\n    这里，$S_{left}$ 和 $S_{right}$ 分别是对应子数组的排序后版本，$count_{left}$ 和 $count_{right}$ 是完全包含在它们内部的配对数量。\n3.  **合并 (Combine)：** 此步骤涉及两个子任务：将已排序的子数组 $S_{left}$ 和 $S_{right}$ 合并成一个单一的排序后数组 $S_{merged}$，并计算跨子数组的配对数量 $count_{cross}$。当前层级的总计数为 $count_{left} + count_{right} + count_{cross}$。\n\n**核心：归并与计算跨子数组配对**\n算法的关键部分是合并步骤，该步骤必须在线性时间（即 $\\mathcal{O}(|S_{left}| + |S_{right}|)$）内操作，以保持整体 $\\mathcal{O}(n \\log n)$ 的时间复杂度。\n\n**计算跨子数组配对：**\n给定两个已排序的数组 $S_{left}$ 和 $S_{right}$。我们需要计算元素对 $(u,v)$ 的数量，其中 $u \\in S_{left}$ 且 $v \\in S_{right}$ 并且满足 $u > 2v$。元素 $u$ 和 $v$ 对应于原始数组中的值 $A[i]$ 和 $A[j]$，其中 $i$ 在左分区，$j$ 在右分区，因此 $i  j$ 自动满足。\n\n由于 $S_{left}$ 和 $S_{right}$ 都已排序，我们可以使用双指针方法在线性时间内完成此计数。初始化两个指针，$i$ 指向 $S_{left}$ 的开头，$j$ 指向 $S_{right}$ 的开头。对于 $S_{left}$ 中的每个元素 $S_{left}[i]$，我们前进 $j$ 指针，直到找到第一个不满足 $S_{left}[i] > 2 \\cdot S_{right}[j]$ 的元素。此时，$S_{right}$ 中从索引 $0$ 到 $j-1$ 的所有元素都与 $S_{left}[i]$ 构成有效配对。因此，我们向跨子数组计数中增加 $j$。然后我们前进 $i$ 到 $S_{left}$ 中的下一个元素，并从相同的 $j$ 值继续，因为 $S_{left}$ 是单调递增的。\n\n**合并为排序后的数组：**\n在计算完跨子数组的配对数后，我们执行标准的归并操作，将 $S_{left}$ 和 $S_{right}$ 合并成一个单一的、完全排序的数组。这可以通过使用另一组指针来完成，以将元素按正确顺序复制到一个新的辅助数组或就地（如果使用辅助缓冲区）地放入原始数组中。\n\n**最终返回：**\n`Solve` 函数返回一个元组，包含合并后的排序数组和总计数 $count_{left} + count_{right} + count_{cross}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite and prints the-\n    results in the specified format.\n    \"\"\"\n    \n    test_cases = [\n        [],\n        [5],\n        [1, 3, 2, 3, 1],\n        [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],\n        [-5, -4, -2, -1],\n        [0, 0, 0, 0],\n        [2, 4, 3, 5, 1, -2, 8, 16],\n        [2147483647, -2147483648],\n    ]\n\n    def _merge_sort_and_count(arr):\n        \"\"\"\n        Recursively sorts an array and counts pairs (i, j) with i  j\n        and arr[i] > 2 * arr[j].\n\n        Args:\n            arr (list): The input list of integers.\n\n        Returns:\n            tuple: A tuple containing the sorted list and the integer count.\n        \"\"\"\n        n = len(arr)\n        if n = 1:\n            return list(arr), 0\n\n        mid = n // 2\n        \n        # Conquer: Recursively solve for subarrays\n        sorted_left, count_left = _merge_sort_and_count(arr[:mid])\n        sorted_right, count_right = _merge_sort_and_count(arr[mid:])\n        \n        # Combine Step Part 1: Count cross-subarray pairs\n        # This must be done on the sorted subarrays to achieve O(n) complexity for this step.\n        count_cross = 0\n        j = 0\n        for i in range(len(sorted_left)):\n            while j  len(sorted_right) and sorted_left[i] > 2 * sorted_right[j]:\n                j += 1\n            count_cross += j\n            \n        # Combine Step Part 2: Merge the sorted subarrays\n        merged_array = []\n        i, j = 0, 0\n        while i  len(sorted_left) and j  len(sorted_right):\n            if sorted_left[i] = sorted_right[j]:\n                merged_array.append(sorted_left[i])\n                i += 1\n            else:\n                merged_array.append(sorted_right[j])\n                j += 1\n        \n        # Append any remaining elements\n        merged_array.extend(sorted_left[i:])\n        merged_array.extend(sorted_right[j:])\n        \n        total_count = count_left + count_right + count_cross\n        \n        return merged_array, total_count\n\n    results = []\n    for case in test_cases:\n        result_array, result_count = _merge_sort_and_count(case)\n        results.append([result_array, result_count])\n\n    # Format the final output string precisely as required, without extra spaces.\n    result_strings = []\n    for res_arr, res_count in results:\n        arr_str = f\"[{','.join(map(str, res_arr))}]\"\n        result_strings.append(f\"[{arr_str},{res_count}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3252453"}, {"introduction": "在实际应用中，我们常需要对无法用标准原生数据类型表示的数据进行排序，且排序的稳定性至关重要。此项挑战要求你为以字符串形式表示的大整数实现一个稳定的归并排序。你需要从第一性原理出发设计一个自定义的比较函数，并确保合并操作能够保持相等元素的原始相对顺序，这是对你综合编程和算法设计能力的全面考验。[@problem_id:3252457]", "problem": "给定一个带符号十进制整数的集合，这些整数可能因过大而无法装入原生机器类型，每个整数都表示为一个字符串，该字符串由一个可选的前导负号后跟数字组成。你的任务是，仅使用源自整数顺序的数学定义的、基于字符串的比较，从第一性原理出发，设计并实现一个针对此类值的稳定归并排序。最终程序必须是确定性的，并且不得读取任何输入。它必须生成一行输出，汇总所提供测试套件所需的结果。\n\n使用的基本原则和定义：\n- 将整数建模为在整数常规序关系下的一个全序集中的元素。全序由反对称性、传递性和完全性定义。两个整数相等当且仅当它们的数值相同。\n- 算法范式为分治法：递归地将列表拆分为子列表，递归地对每个子列表进行排序，并通过一个保持顺序的合并过程来组合结果。\n- 如果任意两个在该序下比较相等的不同元素，它们在输出中的相对顺序等于它们在输入中的相对顺序，则该排序算法是稳定的。\n\n表示与比较：\n- 每个输入元素都是一个表示带符号十进制整数的字符串。允许一个可选的单个前导负号，然后是一个或多个十进制数字。可能出现前导零，且不得改变数值。数值为零的字符串必须被同等对待，无论其符号或零的数量如何；例如，字符串 \"0\"、\"000\" 和 \"-0\" 都表示相同的整数值。\n- 定义一个比较器，给定两个这样的字符串，纯粹通过字符串操作来确定整数顺序：\n  1. 通过从数字序列中移除任何前导零，将每个字符串规范化为一个符号和数字序列；如果剩余的数字为空，则将值视为零，符号视为非负。\n  2. 如果一个规范化符号为负，另一个为非负，则负值较小，除非两者都为零，此时它们相等。\n  3. 如果两者都为非负，则首先按数字长度比较，如果长度相等，则按字典序比较。\n  4. 如果两者都为负，则首先按数字长度反向比较（数字越多意味着值越小），如果长度相等，则按反向字典序比较。\n\n目标算法：\n- 实现一个自顶向下的递归归并排序，它在中间点 $m = \\lfloor (l + r)/2 \\rfloor$ 处分割子数组，递归地对左子数组 $[l,m)$ 和右子数组 $[m,r)$ 进行排序，并将它们合并成一个单一的有序列表。\n- 合并必须是稳定的：当比较器确定两个元素相等时，必须首先放置来自左子数组的元素。\n- 统计在整个排序过程中，合并时比较器执行的元素间比较的次数。对于给定的测试用例，将此计数设为整数 $C$。仅统计在合并步骤中，左子数组和右子数组代表之间的比较器调用次数；不计算边界检查或其他程序性条件判断。\n\n输出指纹：\n- 为避免打印极大数值，同时仍能验证排序顺序，使用模运算计算已排序序列的校验和。设 $p = 10^9 + 7$ 是一个素数，且 $B = 911382323$。对于已排序的值序列 $(v_0, v_1, \\dots, v_{n-1})$（解释为整数），定义\n  $$F = \\left( \\sum_{i=0}^{n-1} \\left(\\left(v_i \\pmod p\\right) \\cdot B^i \\pmod p\\right) \\right) \\bmod p.$$\n  对于负值，将 $v \\pmod p$ 解释为 $\\{0,1,\\dots,p-1\\}$ 中的最小非负余数。\n- 此外，验证稳定性。设 $S$ 是一个布尔值，当且仅当对于每个出现多次的数值，这些出现在输出中的相对顺序等于它们在输入中的相对顺序时，$S$ 为真。\n\n需要生成什么：\n- 对于每个测试用例，你的程序必须输出一个包含三个条目 $[F, C, S]$ 的列表，其中 $F$ 是校验和整数，$C$ 是比较器调用计数的整数，$S$ 是一个布尔值。最终的单行输出必须是一个包含这些按测试用例排列的三元组的单一列表，用逗号分隔并用方括号括起来，例如 $[[F_1,C_1,S_1],[F_2,C_2,S_2],\\dots]$。\n\n测试套件和要求的覆盖范围：\n使用以下五个测试用例，每个都是一个如指定的带符号十进制字符串列表。没有输入；程序必须在内部精确地构造这些列表。\n\n- 案例 A（包含重复项、零和负零的一般混合案例）：\n  [\"$12$\",\"$-3$\",\"$00012$\",\"$5$\",\"$-0003$\",\"$0$\",\"$000$\",\"$12345678901234567890$\",\"$-10000000000000000000$\",\"$0000$\",\"$-0$\"]。\n\n- 案例 B（已按升序排序，包括数值相等的组）：\n  [\"$-10000000000000000000$\",\"$-3$\",\"$-0003$\",\"$-0$\",\"$0$\",\"$000$\",\"$0000$\",\"$5$\",\"$12$\",\"$00012$\",\"$12345678901234567890$\"]。\n\n- 案例 C（案例 B 的逆序，以测试不利的合并模式）：\n  案例 B 的逆序。\n\n- 案例 D（空列表）：\n  []。\n\n- 案例 E（使用极大数值进行压力测试，不枚举所有数字构造）：设 $N_1$ 是由 $1000$ 个数字“$9$”组成的字符串，设 $N_2$ 是由字符“$-$”、字符“$1$”和 $999$ 个数字“$0$”拼接而成的字符串，设 $N_3$ 是由字符“$1$”和 $1000$ 个数字“$0$”拼接而成的字符串，设 $Z_1$ 是由 $500$ 个数字“$0$”组成的字符串，设 $Z_2$ 是字符串“$000$”。测试用例是 $[N_1, N_2, N_3, Z_1, \"$123$\", \"$-123$\", Z_2]$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。例如：“[[F1,C1,True],[F2,C2,True],[F3,C3,True],[F4,C4,True],[F5,C5,True]]”。用计算出的整数替换 $F_k$ 和 $C_k$，并根据你的语言使用相应的布尔字面量 true 或 false（对于 Python，即 True 或 False）。", "solution": "该问题陈述定义严谨、自成一体，并在算法设计和数学领域有科学依据。它提出了一个明确的目标：为以字符串表示的大整数实现一个稳定的归并排序，并计算特定的指标（一个校验和 `F`、一个比较次数 `C` 和一个稳定性标志 `S`）。关于整数比较、归并排序算法、稳定性和输出指标的定义都是精确和无歧义的。没有矛盾、缺失信息或违反科学原理的地方。因此，该问题被认为是有效的，可以构建一个解决方案。\n\n解决方案主要分为三个部分：1) 一个用于字符串表示整数的健壮比较器，2) 一个利用该比较器的稳定归并排序算法，以及 3) 计算所需输出指标的程序。\n\n### 1. 整数字符串比较器\n\n设计一个比较函数，用于确定以字符串形式给出的两个整数（例如 $s_1$ 和 $s_2$）的相对顺序。此函数按要求纯粹基于字符串表示进行操作。\n\n**1.1. 规范化表示**\n为了处理像前导零和带符号零这样的变体，每个字符串首先被转换成一个由符号和数字序列组成的规范形式。一个字符串 $s$ 被规范化为一个元组 `(is_negative, digits)`。\n- 符号 $is\\_negative$ 是一个布尔值，如果数字为负则为 true。\n- $digits$ 字符串包含数值的数字，没有前导零。\n- 对值零应用一个特殊规则：字符串 \"$0$\"、\"$-0$\"、\"$000$\" 等都表示相同的数值。它们的规范形式被统一地定义为 $(false, \"0\")$。对于任何非零数，前导零被剥离。例如，\"$-0034$\" 变成 $(true, \"34\")$，\"$012$\" 变成 $(false, \"12\")$。\n\n**1.2. 比较逻辑**\n设 $s_1$ 和 $s_2$ 的规范形式分别为 $(neg_1, d_1)$ 和 $(neg_2, d_2)$。比较过程如下，如果 $s_1  s_2$ 返回 $-1$，如果 $s_1 = s_2$ 返回 $0$，如果 $s_1 > s_2$ 返回 $1$。\n\n1.  **相等性检查**：如果 $d_1 = d_2$ 且 $neg_1 = neg_2$，则数字相等。两者都是规范零（即 $d_1 = \"0\"$ 且 $d_2 = \"0\"$）的特殊情况也导致相等，无论原始符号如何。\n2.  **符号比较**：如果符号不同 ($neg_1 \\neq neg_2$)，则负数较小。如果 $neg_1$ 为 true，则 $s_1  s_2$。如果 $neg_2$ 为 true，则 $s_2  s_1$。\n3.  **同符号比较**：\n    -   **都为非负** ($neg_1 = false, neg_2 = false$)：位数较少的数字较小。如果 $d_1$ 和 $d_2$ 的长度不同，较短的那个对应较小的值。如果长度相等，则对数字字符串 $d_1$ 和 $d_2$ 进行标准的字典序比较来确定顺序。\n    -   **都为负** ($neg_1 = true, neg_2 = true$)：逻辑相反。位数较多的数字较小（更负）。如果 $d_1$ 和 $d_2$ 的长度不同，较长的那个对应较小的值。如果长度相等，则使用反向字典序比较：如果 $d_1$ 在字典序上大于 $d_2$，则对应于 $s_1$ 的整数小于 $s_2$ 的整数。\n\n### 2. 稳定归并排序算法\n\n排序算法是一个自顶向下的递归归并排序，它遵循分治范式。\n\n**2.1. 递归结构**\n一个函数 `merge_sort` 接受一个列表（或由开始和结束索引 $l$ 和 $r$ 定义的子数组）作为输入。索引遵循半开区间 $[l, r)$ 的约定，其中 $r$ 是不包含的。\n- **基本情况**：如果子数组的大小小于或等于 1（即 $r - l \\le 1$），它已经是有序的，递归终止。\n- **分割**：子数组在中间点 $m = l + \\lfloor (r - l) / 2 \\rfloor$ 处被分成两半。得到的两个子数组是 $[l, m)$ 和 $[m, r)$。\n- **解决**：在两个子数组上递归调用 `merge_sort` 函数：`merge_sort(array, l, m)` 和 `merge_sort(array, m, r)`。\n- **合并**：调用一个 `merge` 过程将两个现在已排序的子数组 $[l, m)$ 和 $[m, r)$ 合并到原始数组位置 $[l, r)$ 上的一个单一有序子数组中。\n\n**2.2. 稳定合并过程**\n`merge` 过程是算法稳定性和比较计数的关键。它接受两个已排序的子数组，一个左子数组 $L$ 和一个右子数组 $R$，并将它们合并。\n1.  创建左子数组和右子数组的临时副本。\n2.  初始化指向 $L$、$R$ 和主数组中目标块起始位置的指针。\n3.  使用上面描述的字符串比较器，逐个比较来自 $L$ 和 $R$ 的元素。每次这样的比较（一个来自 $L$ 的元素和一个来自 $R$ 的元素之间）都会使全局比较计数器 $C$ 增加。\n4.  为确保稳定性，如果比较器确定两个元素相等（返回 0），则首先选择来自左子数组 $L$ 的元素。这个规则通过在比较结果小于或等于 0 时放置来自 $L$ 的元素来实现。\n5.  这个过程一直持续到其中一个临时子数组被用完。然后将另一个子数组的剩余元素复制到主数组中。\n\n### 3. 输出指标计算\n\n对于每个测试用例，计算三个值：校验和 $F$、比较次数 $C$ 和稳定性标志 $S$。\n\n**3.1. 比较次数 ($C$)**\n使用一个计数器，实现为一个可变对象（例如，一个只有一个元素的列表 `[0]`），以便通过引用在递归调用中传递。在 `merge` 过程中，每当一个来自左子数组的元素与一个来自右子数组的元素进行比较时，它就会精确地增加一次。\n\n**3.2. 稳定性验证 ($S$)**\n为了经验性地验证实现的稳定性，输入数组的每个元素都用其原始索引进行扩充，将一个字符串数组 `['s1', 's2', ...]` 转换成一个元组数组 `[('s1', 0), ('s2', 1), ...]`。对这个扩充后的数组执行归并排序，但比较器被指示只比较元组的字符串部分。排序后，扫描结果数组。对于任何通过比较器判断相等的相邻元素 $(s_i, index_i)$ 和 $(s_{i+1}, index_{i+1})$（即 $s_i$ 和 $s_{i+1}$ 代表相同的整数值），我们检查它们的原始索引是否按升序排列，即 $index_i  index_{i+1}$。如果对于任何这样的对，这个条件被违反，那么排序就是不稳定的，并且 $S$ 被设置为 $false$。如果在扫描整个排序数组后没有发现任何此类违规，则 $S$ 为 $true$。\n\n**3.3. 校验和计算 ($F$)**\n数组排序后，在已排序的字符串值序列 $(v_0, v_1, \\dots, v_{n-1})$ 上计算校验和 $F$。计算使用以下公式：\n$$F = \\left( \\sum_{i=0}^{n-1} \\left(\\left(v_i \\pmod p\\right) \\cdot B^i \\pmod p\\right) \\right) \\bmod p$$\n其中 $p = 10^9 + 7$ 且 $B = 911382323$。\n计算过程如下：\n- 初始化总校验和 $F = 0$。\n- 初始化 $B^i \\pmod p$ 的一个项，称之为 $B_{pow} = 1$。\n- 从 $i = 0$ 到 $n-1$ 迭代：\n    - 将字符串 $v_i$ 转换为一个整数。Python 的 `int()` 类型支持任意精度，这在这里是必需的。\n    - 计算余数 $v_i' = \\text{int}(v_i) \\pmod p$。Python 的 `%` 运算符对于负输入能正确计算最小非负余数。\n    - 计算此元素的项：$term = (v_i' \\cdot B_{pow}) \\pmod p$。\n    - 将此项加到总和中：$F = (F + term) \\pmod p$。\n    - 为下一次迭代更新 $B$ 的幂：$B_{pow} = (B_{pow} \\cdot B) \\pmod p$。\n这种在每一步都进行模约简的迭代方法可以防止中间值变得过大，并且计算效率高。对于空列表，总和为空，所以 $F=0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the stable merge sort implementation.\n    \"\"\"\n\n    def canonicalize_string(s: str) -> tuple[bool, str]:\n        \"\"\"\n        Converts a number string to a canonical form (is_negative, digits).\n        - \"0\", \"-0\", \"00\" all canonicalize to (False, \"0\").\n        - \"-007\" canonicalizes to (True, \"7\").\n        - \"007\" canonicalizes to (False, \"7\").\n        \"\"\"\n        if not s:\n            # Should not happen with problem constraints, but for robustness\n            return (False, \"0\")\n\n        is_negative = s.startswith('-')\n        digits = s.lstrip('-').lstrip('0')\n\n        if not digits:\n            return (False, \"0\")  # This covers \"0\", \"-0\", \"00\", etc.\n        \n        return (is_negative, digits)\n\n    def compare_string_integers(s1: str, s2: str) -> int:\n        \"\"\"\n        Compares two integers represented as strings.\n        Returns:\n            -1 if s1  s2\n             0 if s1 == s2\n             1 if s1 > s2\n        \"\"\"\n        if s1 == s2:\n             return 0\n\n        neg1, d1 = canonicalize_string(s1)\n        neg2, d2 = canonicalize_string(s2)\n\n        # Handle the canonical zero case\n        if d1 == \"0\" and d2 == \"0\":\n            return 0\n        \n        # Compare signs\n        if neg1 and not neg2:\n            return -1\n        if not neg1 and neg2:\n            return 1\n        \n        # Signs are the same\n        len1, len2 = len(d1), len(d2)\n\n        if not neg1:  # Both are non-negative\n            if len1 != len2:\n                return -1 if len1  len2 else 1\n            # Lengths are equal, compare lexicographically\n            if d1  d2:\n                return -1\n            elif d1 > d2:\n                return 1\n            else:\n                return 0\n        else:  # Both are negative\n            if len1 != len2:\n                return 1 if len1  len2 else -1 # More digits -> smaller value\n            # Lengths are equal, compare reverse lexicographically\n            if d1  d2:\n                return 1\n            elif d1 > d2:\n                return -1\n            else:\n                return 0\n\n    def _merge(arr, l, m, r, comparisons, comparator):\n        \"\"\"Helper function to merge two sorted subarrays.\"\"\"\n        left_half = arr[l:m]\n        right_half = arr[m:r]\n        \n        i, j, k = 0, 0, l\n        \n        while i  len(left_half) and j  len(right_half):\n            comparisons[0] += 1\n            # Stable sort: element from left is chosen if equal\n            if comparator(left_half[i], right_half[j]) = 0:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n            \n        while i  len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n        \n        while j  len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    def _recursive_merge_sort(arr, l, r, comparisons, comparator):\n        \"\"\"Recursive part of merge sort on interval [l, r).\"\"\"\n        if r - l = 1:\n            return\n        \n        m = l + (r - l) // 2\n        _recursive_merge_sort(arr, l, m, comparisons, comparator)\n        _recursive_merge_sort(arr, m, r, comparisons, comparator)\n        _merge(arr, l, m, r, comparisons, comparator)\n\n    def process_case(arr: list[str]) -> list:\n        \"\"\"\n        Processes a single test case: sorts the array and computes F, C, S.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return [0, 0, True]\n\n        # Augment with original indices for stability check\n        indexed_arr = [(arr[i], i) for i in range(n)]\n\n        # Comparator for augmented items\n        tuple_comparator = lambda a, b: compare_string_integers(a[0], b[0])\n        \n        # Sort\n        comparisons = [0]\n        _recursive_merge_sort(indexed_arr, 0, n, comparisons, tuple_comparator)\n        C = comparisons[0]\n        \n        # Verify stability (S)\n        is_stable = True\n        for i in range(n - 1):\n            s_i, idx_i = indexed_arr[i]\n            s_i_plus_1, idx_i_plus_1 = indexed_arr[i+1]\n            if tuple_comparator(indexed_arr[i], indexed_arr[i+1]) == 0:\n                if idx_i > idx_i_plus_1:\n                    is_stable = False\n                    break\n        S = is_stable\n\n        # Calculate checksum (F)\n        p = 10**9 + 7\n        B = 911382323\n        F = 0\n        B_pow_i = 1\n        \n        sorted_strings = [item[0] for item in indexed_arr]\n        \n        for i in range(n):\n            v_i_val = int(sorted_strings[i])\n            v_i_mod_p = v_i_val % p\n            \n            term = (v_i_mod_p * B_pow_i) % p\n            F = (F + term) % p\n            \n            B_pow_i = (B_pow_i * B) % p\n            \n        return [F, C, S]\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case A\n        [\"12\", \"-3\", \"00012\", \"5\", \"-0003\", \"0\", \"000\", \"12345678901234567890\", \"-10000000000000000000\", \"0000\", \"-0\"],\n        # Case B\n        [\"-10000000000000000000\", \"-3\", \"-0003\", \"-0\", \"0\", \"000\", \"0000\", \"5\", \"12\", \"00012\", \"12345678901234567890\"],\n        # Case C\n        [\"12345678901234567890\", \"00012\", \"12\", \"5\", \"0000\", \"000\", \"0\", \"-0\", \"-0003\", \"-3\", \"-10000000000000000000\"],\n        # Case D\n        [],\n        # Case E\n        [\n            \"9\" * 1000, \n            \"-1\" + \"0\" * 999, \n            \"1\" + \"0\" * 1000, \n            \"0\" * 500, \n            \"123\", \n            \"-123\", \n            \"000\"\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Format output without spaces as per example\n    output_str = f\"[{','.join(f'[{r[0]},{r[1]},{r[2]}]' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3252457"}]}