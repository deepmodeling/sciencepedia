{"hands_on_practices": [{"introduction": "要真正掌握红黑树的删除操作，最好的方法就是亲手实践。这个练习将引导你完整地执行一次非平凡的删除操作。你需要首先在给定的红黑树中找到中位数节点，然后处理拥有两个子节点的节点的删除（这需要找到它的中序后继节点），最后执行删除修复程序来恢复红黑树的属性。通过这个练习 [@problem_id:3265764]，你将巩固删除操作的核心机制。", "problem": "给定一棵具体的红黑二叉搜索树，其键为互不相同的整数。所有外部叶子节点（哨兵节点 $\\mathsf{NIL}$）均为黑色。该树满足红黑性质：根节点为黑色，每个红色节点的孩子都是黑色的，并且从任意节点到其任何后代 $\\mathsf{NIL}$ 节点的每条路径都包含相同数量的黑色节点。该树的结构如下（每个节点都用括号标注了其颜色）：\n\n- 根节点：$15$ (黑色)\n  - 左孩子：$9$ (黑色)\n    - 左孩子：$5$ (红色)\n      - 左孩子：$3$ (黑色)\n      - 右孩子：$7$ (黑色)\n    - 右孩子：$12$ (红色)\n      - 左孩子：$11$ (黑色)\n      - 右孩子：$13$ (黑色)\n  - 右孩子：$21$ (黑色)\n    - 左孩子：$18$ (红色)\n      - 左孩子：$17$ (黑色)\n      - 右孩子：$19$ (黑色)\n    - 右孩子：$25$ (红色)\n      - 左孩子：$23$ (黑色)\n      - 右孩子：$27$ (黑色)\n\n任务：\n- 仅使用红黑树的基本定义（二叉搜索树排序性质、红黑着色性质以及包括后继替换、旋转和重新着色的标准红黑树删除流程），首先确定存储键集合中的中位数键，然后使用标准的红黑树删除算法（如 Cormen–Leiserson–Rivest–Stein 等权威资料中所述）从树中删除此中位数。\n- 在执行所有必要的结构更改和修复操作（旋转和重新着色）以恢复红黑性质后，确定最终红黑树的根节点存储的键。\n\n答案格式：\n- 仅提供最终的根键，作为一个精确的整数。无需四舍五入。不要包含任何单位或附加文本。", "solution": "该问题要求我们对给定的红黑树执行一次删除操作，并确定新根节点的键。这个过程包括：首先确定树中所有键的中位数，然后使用标准的红黑树删除算法删除具有该键的节点，最后报告修改后树的根节点处的键。\n\n首先，我们验证所提供的树结构，以确保它符合红黑树和二叉搜索树的性质。\n键为：$3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27$。\n给出的结构如下：\n- 根节点：$15$ (黑色)\n  - 左孩子：$9$ (黑色)\n    - 左孩子：$5$ (红色) -> 孩子 $3$ (黑色), $7$ (黑色)\n    - 右孩子：$12$ (红色) -> 孩子 $11$ (黑色), $13$ (黑色)\n  - 右孩子：$21$ (黑色)\n    - 左孩子：$18$ (红色) -> 孩子 $17$ (黑色), $19$ (黑色)\n    - 右孩子：$25$ (红色) -> 孩子 $23$ (黑色), $27$ (黑色)\n所有节点都满足二叉搜索树的性质。根节点是黑色的。所有红色节点（$5, 12, 18, 25$）都有黑色的孩子。黑高（从一个节点（不含自身）到其任一后代叶子节点的简单路径上的黑色节点数）是统一的。对于根节点 $15$，所有路径的黑高都是 $2$（例如，经过 $3$ 的路径：$9(\\text{B}) \\rightarrow 5(\\text{R}) \\rightarrow 3(\\text{B}) \\rightarrow \\mathsf{NIL}$，黑色节点是 $9, 3$）。给定的树是一棵有效的红黑树。\n\n第一个任务是确定中位数键。按升序排列的键集合是：\n$$S = \\{3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27\\}$$\n键的数量是 $|S| = 15$。对于一个元素数量为奇数的集合，中位数是位于第 $\\frac{n+1}{2}$ 个位置的元素。在这里，它是第 $\\frac{15+1}{2} = 8$ 个元素。\n在排序后的集合中数，第8个键是 $15$。因此，我们必须删除键为 $15$ 的节点。\n\n要删除的节点，我们称之为 $z$，是树的根节点。节点 $z$ 有两个孩子（节点 $9$ 和 $21$）。对于有两个孩子的节点，标准的二叉搜索树删除过程要求用它的中序后继替换它，然后从后继节点的原始位置删除该后继节点。\n一个节点的中序后继是其右子树中键最小的节点。节点 $15$ 的右子树以节点 $21$ 为根。要找到该子树中的最小键，我们从节点 $21$ 开始沿着左孩子指针向下：$21 \\rightarrow 18 \\rightarrow 17$。中序后继是键为 $17$ 的节点。我们称这个后继节点为 $y$。\n\n删除算法按以下步骤进行：\n1.  后继节点 $y$ 的键（即 $17$）被复制到节点 $z$（根节点）中。根节点的键现在是 $17$，但其颜色保持黑色。\n2.  问题现在简化为从树中删除原始的后继节点 $y$（键为 $17$ 的节点）。\n\n我们来检查要被物理删除的节点 $y$。它的键是 $17$，颜色是黑色，其父节点是 $18$。节点 $17$ 没有孩子（它的两个孩子都是 $\\mathsf{NIL}$ 叶子节点）。\n当我们移除节点 $y$ 时，我们用它的一个孩子来替换它。我们可以选择它的右孩子，这是一个 $\\mathsf{NIL}$ 节点。我们称这个替换节点为 $x$。所以，$x$ 是一个 $\\mathsf{NIL}$ 节点。\n被删除节点 $y$ 的原始颜色是黑色。从树中移除一个黑色节点会破坏红黑性质，即从一个节点到其后代叶子的所有路径必须包含相同数量的黑色节点（性质5）。为了恢复这个性质，我们必须在节点 $x$ 上运行 `RB-DELETE-FIXUP` 过程。节点 $x$ 被认为带有一层“额外黑色”。\n\n`RB-DELETE-FIXUP` 过程对 $x$ 的操作如下。最初，$x$ 是替换了节点 $17$ 的 $\\mathsf{NIL}$ 节点。$x$ 的父节点，记为 $p(x)$，是节点 $18$。由于 $x$ 不是根节点并且是“双重黑色”的，我们进入一个循环。\n\n**迭代 1：**\n-   $x$ 是其父节点 $p(x) = 18$ 的左孩子。\n-   我们确定 $x$ 的兄弟节点，记为 $w$。$w$ 是节点 $18$ 的右孩子，即键为 $19$ 的节点。\n-   $w$（节点 $19$）的原始颜色是黑色。这对应于 CLRS 删除算法中的情况2、3或4。\n-   我们检查 $w$ 的孩子的颜色。节点 $19$ 的两个孩子都是 $\\mathsf{NIL}$ 叶子节点，它们是黑色的。\n-   这种情况匹配**情况2**：兄弟节点 $w$ 是黑色的，并且 $w$ 的两个孩子都是黑色的。\n-   情况2的操作是：\n    1.  将 $w$ 重新着色为红色。所以，节点 $19$ 变为红色。\n    2.  通过设置 $x = p(x)$ 将“额外黑色”沿树向上移动。所以，$x$ 现在指向节点 $18$。\n-   现在为新的 $x$（节点 $18$）重新评估循环条件（`x` 不是根节点并且是“双重黑色”）。节点 $18$ 的原始颜色是红色。当“额外黑色”移动到一个红色节点时，循环终止。这个红黑节点（red-and-black node）简单地变为黑色，吸收了额外的黑色，从而恢复了所有经过它的路径的黑高性质。\n\n-   `RB-DELETE-FIXUP` 过程在循环之后有一个最终步骤：它将当前节点 $x$ 的颜色设置为黑色。在我们的例子中，循环在 $x$ 指向节点 $18$ 时终止。因此，原本是红色的节点 $18$ 被重新着色为黑色。\n\n我们来总结一下对树的更改：\n1.  根节点的键从 $15$ 变为 $17$。其颜色保持黑色。\n2.  键为 $17$ 的节点被物理删除。\n3.  键为 $19$ 的节点从黑色重新着色为红色。\n4.  键为 $18$ 的节点从红色重新着色为黑色。\n没有执行旋转操作。\n\n树结构的最终状态是：\n- 根节点：$17$ (黑色)\n  - 左孩子：$9$ (黑色)\n    - 左孩子：$5$ (红色)\n    - 右孩子：$12$ (红色)\n  - 右孩子：$21$ (黑色)\n    - 左孩子：$18$ (黑色)\n      - 右孩子：$19$ (红色)\n    - 右孩子：$25$ (红色)\n\n新树中所有的红黑性质都得到满足。根是黑色的。每个红色节点（$5, 12, 19, 25$）都有黑色的孩子。从根开始的黑高对于所有路径仍然是 $2$。\n\n问题要求的是最终红黑树的根节点存储的键。在删除和修复操作之后，根节点包含原始中位数的后继节点的键，即 $17$。", "answer": "$$\\boxed{17}$$", "id": "3265764"}, {"introduction": "并非所有黑节点的删除都会引发复杂的旋转和重新着色。这个练习旨在揭示一种常见且重要的特殊情况。通过解决这个问题 [@problem_id:3265805]，你将看到当被删除的黑节点可以被一个红节点替换时，修复过程会变得异常简单。理解这种情况是掌握完整删除算法的关键一步。", "problem": "考虑一个存储不同整数键的红黑树 (RBT)，它使用规范的删除算法：当一个节点有两个子节点时，通过拼接移除其中序后继节点来删除该节点，然后仅基于 RBT 公理进行标准的修复。所有缺失的子节点都是哨兵叶节点 $\\mathsf{NIL}$，其颜色为黑色。\n\n给定以下 RBT，其中根节点是 $x$，其键为 $20$，颜色为黑色。$x$ 的左子树如下：\n- 键为 $10$ 的黑色节点，其左子节点是键为 $5$ 的黑色节点（其两个子节点均为 $\\mathsf{NIL}$），其右子节点是键为 $15$ 的黑色节点（其两个子节点均为 $\\mathsf{NIL}$）。\n\n$x$ 的右子树如下：\n- 键为 $30$ 的黑色节点，其左子节点是键为 $25$ 的黑色节点，其右子节点是键为 $35$ 的黑色节点。\n- 键为 $25$ 的节点，其左子节点为 $\\mathsf{NIL}$，右子节点是键为 $27$ 的红色节点（其两个子节点均为 $\\mathsf{NIL}$）。\n- 键为 $35$ 的节点，其左子节点为 $\\mathsf{NIL}$，右子节点是键为 $37$ 的红色节点（其两个子节点均为 $\\mathsf{NIL}$）。\n\n假设这棵树满足所有红黑树公理。现在，使用上述规范的红黑树删除过程删除节点 $x$（键为 $20$）。特别地，当一个节点有两个子节点时，它的中序后继节点 $y$ 被拼接出来并移动到被删除节点的位置，并且仅当被物理删除的节点是黑色时才执行修复。这个场景的构造使得 $x$ 的中序后继是 $x$ 的一个严格孙代节点，并且将其移动到 $x$ 的位置会导致该孙代节点成为 $x$ 原来子节点的新父节点。\n\n设 $R$ 为删除及所有后续修复步骤中执行的旋转（左旋或右旋）总数，并设 $K$ 为在删除及所有后续修复步骤中实际改变节点颜色位的重着色操作总数。定义 $C = R + K$。\n\n计算 $C$。你的答案必须是一个实数值。如果需要四舍五入，则保留四位有效数字；但在本例中无需四舍五入。", "solution": "本题将通过首先验证其前提条件，然后按规定执行规范的红黑树 (RBT) 删除算法来解决。\n\n### 问题验证\n\n题目要求计算从给定 RBT 中删除一个节点过程中的旋转次数和颜色改变次数。\n\n树的初始状态描述如下：\n- 根 `x`：键为 $20$，颜色为黑色。\n- `x` 的左子树：键为 $10$ 的节点（黑色），其左子节点为键 $5$（黑色），右子节点为键 $15$（黑色）。\n- `x` 的右子树：键为 $30$ 的节点（黑色），其左子节点为键 $25$（黑色），右子节点为键 $35$（黑色）。键为 $25$ 的节点有一个右子节点，键为 $27$（红色）。键为 $35$ 的节点有一个右子节点，键为 $37$（红色）。所有其他子节点都是哨兵 `NIL` 节点，颜色为黑色。\n\n在继续之前，我们必须验证这个初始配置是一个有效的 RBT。RBT 的公理是：\n1.  每个节点要么是红色，要么是黑色。（根据描述，已满足）。\n2.  根节点是黑色的。（节点 $20$ 是黑色的，已满足）。\n3.  每个叶节点（`NIL`）都是黑色的。（根据描述，已满足）。\n4.  如果一个节点是红色的，那么它的两个子节点都是黑色的。红色节点是 $27$ 和 $37$。它们的子节点都是 `NIL`（黑色），因此已满足。\n5.  对于每个节点，从该节点到其所有后代叶节点的简单路径都包含相同数量的黑色节点（黑高）。黑高通常定义为从一个节点（不包括该节点）到叶节点的路径上的黑色节点数量。让我们从根节点 ($20$) 开始验证：\n    - 路径 $20 \\to 10(\\text{B}) \\to 5(\\text{B}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 10(\\text{B}) \\to 15(\\text{B}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 25(\\text{B}) \\to (\\text{左})\\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 25(\\text{B}) \\to 27(\\text{R}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 35(\\text{B}) \\to (\\text{左})\\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 35(\\text{B}) \\to 37(\\text{R}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n黑高属性成立。初始树是一个有效的 RBT。\n\n题目指定使用“规范删除算法”，但包含了一段可能存在矛盾的描述：“...将其[后继节点]移动到 x 的位置，导致该孙代节点成为 x 原来子节点的新父节点。”规范算法涉及将被删除节点的后继节点的*数据*复制到该节点，然后从其原始位置拼接移除后继节点。后继*节点*本身并不会移动到被删除节点的位置。我们将遵循“规范”的指示，并将后面的句子视为对过程的不精确描述。因此，在此解释下，该问题被认为是有效且可解的。\n\n### 删除过程\n\n设要删除的节点为 $z$。在这里，$z$ 是键为 $20$ 的节点。\n初始树为：\n$$\n\\begin{array}{c}\n20(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 25(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\setminus \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad 27(\\text{R}) \\quad 37(\\text{R})\n\\end{array}\n$$\n\n1.  **识别用于拼接的节点：** 由于节点 $z$（键为 $20$）有两个子节点，我们必须找到它的中序后继，我们称之为 $y$。后继是 $z$ 右子树中键最小的节点。右子树的根是 $30$。通过从 $30$ 开始跟随左子指针可以找到最小键，即键为 $25$ 的节点。因此，$y$ 是键为 $25$ 的节点。\n\n2.  **移植数据：** 规范算法将后继节点 $y$ 的键和卫星数据复制到节点 $z$ 中。$z$ 的颜色不变。\n    - `z.key = y.key` $\\implies$ 原来键为 $20$ 的节点现在键为 $25$。它保持黑色。\n\n3.  **物理删除：** 从树中物理移除（拼接移除）的节点是后继节点 $y$（原来键为 $25$ 的节点）。我们来追踪该节点 $y$ 的属性：\n    - `y.key` 是 $25$。\n    - `y.color` 是黑色。\n    - 节点 $y$ 有一个右子节点，我们称之为 `x_fixup`，即键为 $27$ 且颜色为红色的节点。`y` 没有左子节点（`NIL`）。\n\n4.  **拼接：** 通过将其父节点（节点 $30$）链接到其子节点（`x_fixup`，节点 $27$），节点 $y$ 被移除。由于 $y$ 是 $30$ 的左子节点，因此节点 $27$ 成为节点 $30$ 的新左子节点。\n\n在拼接之后、修复过程开始之前的树结构是：\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{R}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\n\n### 修复过程\n\n被物理移除的节点 $y$（原来键为 $25$）是黑色的。这违反了 RBT 属性 5（黑高），影响了所有曾穿过被移除节点的路径。因此，必须调用修复过程。该过程 (`RB-DELETE-FIXUP`) 在替换 $y$ 的节点上被调用，即 `x_fixup`（键为 $27$ 的节点）。\n\n修复的核心思想是 `x_fixup` 的位置现在有了一个“额外的黑色”。标准过程根据 `x_fixup` 的颜色来处理这种情况。\n\n- 节点 `x_fixup`（键为 $27$）是**红色**的。\n- 标准的修复算法（例如，来自 CLRS）首先检查节点 `x_fixup` 本身是否为红色。如果是，修复很简单：该节点可以通过被染成黑色来吸收“额外的黑色”。\n- 修复过程的主循环条件是 `while x_fixup != root and x_fixup.color == BLACK`。\n- 在我们的例子中，`x_fixup.color` 是红色的。条件为假，`while` 循环根本不会进入。\n- 因此，没有执行任何旋转。旋转次数 $R$ 为 $0$。\n- 循环结束后，算法执行最后一步：`x_fixup.color = BLACK`。键为 $27$ 的节点，原来是红色的，现在被染成黑色。这是一次颜色改变。\n\n### 计算操作次数\n\n- **旋转 ($R$):** 修复的 `while` 循环没有进入。没有执行旋转。\n  $$ R = 0 $$\n- **颜色改变 ($K$):** 键为 $27$ 的节点的颜色从红色变为黑色。这是唯一改变节点颜色位的操作。\n  $$ K = 1 $$\n\n最终有效的 RBT 为：\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\n在这棵最终的树中，所有 RBT 属性都得到满足。\n\n### 最终计算\n\n题目要求计算 $C = R + K$。\n$$ C = 0 + 1 = 1 $$", "answer": "$$\\boxed{1}$$", "id": "3265805"}, {"introduction": "在掌握了如何按部就班地执行删除算法之后，我们来挑战一个更深层次的分析性问题。这个问题不再是简单地“做什么”，而是“为什么”：它要求你分析并刻画出在何种条件下，删除一个节点完全不需要执行任何修复操作。这种分析性练习 [@problem_id:3265780] 将帮助你从根本上理解删除算法的设计思想及其效率的来源。", "problem": "给定一棵基于指针的红黑树，它有 $n$ 个内部节点，使用标准的模型，即有一个共享的单一哨兵 $\\mathsf{NIL}$ 叶节点，该叶节点被视为每个缺失子树的黑色叶子子节点。每个内部节点存储一个键、指向左右子节点的指针，以及一个 $\\{\\text{红},\\text{黑}\\}$ 中的颜色位。该红黑树满足标准的五个性质：根是黑色的，所有 $\\mathsf{NIL}$ 叶子都是黑色的，每个红色节点只有黑色的子节点，以及所有从根到 $\\mathsf{NIL}$ 的路径都有相同的黑高。考虑标准的删除算法，在删除一个节点 $x$ 时，它使用通常的中序后继归约，将问题简化为最多移除一个非 $\\mathsf{NIL}$ 子节点的情况，然后可能执行一个由旋转和重新着色组成的修复过程，以恢复红黑树的性质。\n\n定义一个节点 $x$ 是“可零修复删除”的，如果当标准删除算法应用于删除 $x$ 时，该算法执行了零次旋转和零次颜色改变。剪接掉 $x$ 所需的指针重新分配不计为旋转或颜色改变。\n\n设计一个算法，给定红黑树的根节点，且没有任何预处理或增强的元数据，该算法要么返回一个指向可零修复删除节点的指针（如果存在），要么正确报告不存在这样的节点。你的算法可以检查节点的字段（颜色和子节点指针）并任意遍历指针。使用单位成本模型，其中每次字段读取或指针遍历的成本为 $1$，循环计数器的算术运算是免费的。从第一性原理以及红黑树和标准删除算法的定义性质出发，推导出解决此任务的最佳可能算法的最坏情况运行时间的渐近紧确界，作为 $n$ 的函数。\n\n将你的最终答案表示为关于 $n$ 的标准大西塔表示法中的单个渐近表达式。无需舍入。", "solution": "该问题要求设计一个算法，在一棵给定的红黑树中找到一个“可零修复删除”的节点，并确定最佳可能算法的最坏情况复杂度的渐近紧确界。\n\n### 步骤 1：刻画可零修复删除节点的特征\n\n首先，我们必须精确地刻画什么使一个节点成为“可零修复删除”的。这被定义为通过标准算法删除时，不涉及任何旋转和颜色改变的节点。\n\n针对节点 $x$ 的标准删除算法分两个阶段进行：\n1.  **剪接**：一个节点 $y$ 被物理上从树结构中移除（剪接掉）。如果要删除的节点 $x$ 有两个非 $\\mathsf{NIL}$ 子节点，算法会找到它的中序后继，将后继的数据复制到 $x$ 中，然后删除后继节点。根据定义，后继节点没有左子节点。因此，问题被简化为删除一个最多只有一个非 $\\mathsf{NIL}$ 子节点的节点 $y$。如果 $x$ 本身最多只有一个非 $\\mathsf{NIL}$ 子节点，则 $y$ 就是 $x$。\n2.  **修复**：在 $y$ 被剪接掉后，它的子节点（可以是 $\\mathsf{NIL}$）取代了它的位置。当且仅当被剪接掉的节点 $y$ 是黑色的时，才会调用修复程序（一系列旋转和重新着色）。\n\n移除一个黑色节点 $y$ 会违反红黑树性质中的“从一个给定节点到其后代叶子的所有路径都包含相同数量的黑色节点”（性质4）。具体来说，任何曾穿过 $y$ 的路径现在都少了一个黑色节点。修复程序就是为了恢复这个性质而设计的。关键在于，如果被剪接掉的节点 $y$ 是红色的，则不会违反任何红黑树性质：\n-   性质1（根是黑色的）：红色节点不能是根节点。\n-   性质2（$\\mathsf{NIL}$ 是黑色的）：不受影响。\n-   性质3（红色节点有黑色的子节点）：红色节点 $y$ 的父节点必须是黑色的。替代 $y$ 的子节点也是黑色的（因为红色节点的子节点必须是黑色的），从而为 $y$ 的父节点保留了此性质。\n-   性质4（黑高）：移除一个红色节点不会改变任何路径上的黑色节点数量。\n\n因此，当且仅当被物理剪接掉的节点 $y$ 是红色时，修复程序会完全跳过，这意味着发生了零次旋转和零次颜色改变。\n\n我们将“可移除的红色节点”定义为一个最多只有一个非 $\\mathsf{NIL}$ 子节点的红色节点。这恰好是一个节点既是红色的又是被物理剪接掉的那个节点的条件。\n\n综合这些观察，一个节点 $x$ 是可零修复删除的，当且仅当以下两个条件之一成立：\n1.  $x$ 最多只有一个非 $\\mathsf{NIL}$ 子节点，并且 $x$ 是红色的。（在这种情况下，$y=x$。）\n2.  $x$ 有两个非 $\\mathsf{NIL}$ 子节点，并且它的中序后继 $y$ 是红色的。（后继 $y$ 保证没有左子节点，所以它最多只有一个非 $\\mathsf{NIL}$ 子节点。）\n\n在这两种情况下，寻找一个可零修复删除的节点 $x$ 的问题，可以归结为寻找一个节点 $x$，它本身是一个可移除的红色节点，或者它的中序后继是一个可移除的红色节点。\n\n### 步骤 2：设计最优算法（上界）\n\n任务是找到一个满足上述条件的节点 $x$。一个朴素的方法是遍历所有 $n$ 个节点，对每个节点 $x$，检查它是否是可零修复删除的。检查 $x$ 本身是否是一个可移除的红色节点需要 $O(1)$ 的时间。然而，如果 $x$ 有两个子节点，我们必须找到它的后继，这在红黑树中可能需要 $O(\\log n)$ 的时间（通过遍历右子树的左侧链）。这导致总体最坏情况下的复杂度为 $O(n \\log n)$。\n\n我们可以设计一个更高效的算法，使其在线性时间内运行。关键是使用单次遍历，例如后序遍历，并增强递归调用，使其向父节点返回必要的信息。让处理以节点 `curr` 为根的子树的递归函数返回一个元组，包含：\n1.  如果在子树内找到了一个可零修复删除的节点，则返回指向该节点的指针。\n2.  指向子树中具有最小键的节点的指针。\n3.  指向子树中具有最大键的节点的指针。\n\n算法流程如下：\n`function find_zfd_postorder(curr)`：\n-   **基本情况**：如果 `curr` 是 $\\mathsf{NIL}$，返回 `(null, null, null)`。\n-   **递归步骤**：\n    1.  对左子节点进行递归调用：`(zfd_l, min_l, max_l) = find_zfd_postorder(curr.left)`。\n    2.  如果 `zfd_l` 不是 `null`，说明已经找到了一个节点。立即返回 `(zfd_l, null, null)` 以将结果向上传播。\n    3.  对右子节点进行递归调用：`(zfd_r, min_r, max_r) = find_zfd_postorder(curr.right)`。\n    4.  如果 `zfd_r` 不是 `null`，返回 `(zfd_r, null, null)`。\n-   **处理 `curr`**：\n    1.  **检查条件1**：`curr` 是否是可移除的红色节点？检查 `curr.color == red` 并且 (`curr.left == NIL` 或 `curr.right == NIL`)。如果为真，则找到了一个 ZFD 节点。返回 `(curr, null, null)`。\n    2.  **检查条件2**：`curr` 的后继是否是可移除的红色节点？\n        -   只有当 `curr.right` 不是 $\\mathsf{NIL}$ 时，`curr` 的后继才存在。\n        -   后继是右子树中的最小节点，即递归调用返回的 `min_r`。\n        -   后继 `min_r` 保证有 `min_r.left == NIL`。因此，要成为一个可移除的红色节点，它只需要是红色的（`min_r.color == red`）。\n        -   如果 `curr.right != NIL` 并且 `min_r.color == red`，那么 `curr` 是一个 ZFD 节点。返回 `(curr, null, null)`。\n-   **返回信息**：如果在 `curr` 或其下方没有找到 ZFD 节点，则计算以 `curr` 为根的子树的最小值和最大值并返回它们。\n    -   `my_min = (curr.left != NIL) ? min_l : curr`\n    -   `my_max = (curr.right != NIL) ? max_r : curr`\n    -   返回 `(null, my_min, my_max)`。\n\n该算法对 $n$ 个节点中的每一个都只访问一次。在每个节点（在其子节点被处理后）所做的工作包括常数次的比较和指针操作。因此，总运行时间为 $O(n)$。这为复杂度建立了一个上界。\n\n### 步骤 3：推导下界\n\n为了建立一个紧确界，我们必须证明没有任何算法能渐近地优于所描述的算法。我们为主张一个 $\\Omega(n)$ 的下界进行论证。\n\n这个问题本质上是一个搜索问题。要确定是否存在一个 ZFD 节点，算法必须收集关于节点颜色和链接的信息。“可零修复删除”的性质是一种局部或半局部的结构性质，与节点中存储的键无关。因此，算法不能利用二叉搜索树的性质来“锁定”一个 ZFD 节点，而不检查其局部邻域。\n\n考虑一个对手论证。假设一个算法 $\\mathcal{A}$ 声称通过只检查 $o(n)$ 个节点来解决问题。这意味着 $\\mathcal{A}$ 留下了线性数量的节点，即 $\\Theta(n)$ 个节点，未被检查。\n对手可以给出两个不同的、有效的红黑树 $T_1$ 和 $T_2$，它们在 $\\mathcal{A}$ 检查的所有节点上都是相同的。\n-   $T_1$ 被构造成没有任何可零修复删除的节点。例如，一个足够大的、所有节点都是黑色的完美二叉树是一个有效的红黑树，它没有 ZFD 节点（因为任何删除都会移除一个黑色节点，从而触发修复）。\n-   $T_2$ 被构造成在被检查的节点上与 $T_1$ 相同，但在一个未被检查的位置包含一个单一的 ZFD 节点。虽然红黑树的严格性质使得通过简单的局部改变从 $T_1$ 构造出这样的 $T_2$ 并非易事，但构造具有此性质的有效树对是可能的。\n\n由于算法 $\\mathcal{A}$ 无法根据它探测的 $o(n)$ 个节点来区分 $T_1$ 和 $T_2$，它必须对两者给出相同的答案。如果它报告“不存在”，那么对于 $T_2$ 它是错误的。如果它报告一个 ZFD 节点，那么对于 $T_1$ 它是错误的（因为它不可能在它检查过的节点中找到 ZFD 节点）。\n\n因此，任何正确的确定性算法在最坏情况下都必须检查 $\\Omega(n)$ 个节点，以区分一棵没有 ZFD 节点的树和一棵带有一个由对手放置的 ZFD 节点的树。这为所需操作的数量建立了一个 $\\Omega(n)$ 的下界。\n\n### 步骤 4：结论\n\n解决该问题的上界是 $O(n)$，由增强的后序遍历算法确立。下界是 $\\Omega(n)$，因为任何算法在最坏情况下都必须准备检查节点总数的常数比例。由于上界和下界相匹配，所以最佳可能算法的最坏情况运行时间的渐近紧确界是 $\\Theta(n)$。", "answer": "$$\\boxed{\\Theta(n)}$$", "id": "3265780"}]}