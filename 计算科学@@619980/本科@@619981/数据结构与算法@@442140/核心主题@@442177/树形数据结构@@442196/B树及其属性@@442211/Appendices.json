{"hands_on_practices": [{"introduction": "理论分析常常始于理想模型。这个练习将带你分析一个“完美满”B树的结构，并计算在不同阶数之间转换的总I/O成本。通过这个计算，你将能够熟练运用B树的高度、阶数和节点数之间的基本关系，并理解为何I/O操作是衡量其性能的核心指标。[@problem_id:3211998]", "problem": "为方便分析，我们首先给出一个关于B树阶数的精确定义。一个阶为 $m$ 的B树是一棵有根树，其中每个内部节点（根节点可能例外）拥有介于 $\\lceil m/2 \\rceil$ 到 $m$ 之间的子节点，并且每个节点存储的键数量恰好比其子节点数少一。我们将B树视为一棵多路搜索树（而非B$+$-树）：键存储在所有节点中，对树进行中序遍历可以得到树中所有键的全局排序。\n\n假设源树是一棵阶为 $m_1 = 4$、高度为 $h_1 = 2$ 的完美满B树（其中高度指从根到叶子的最长路径上的边数，因此根节点位于第 $0$ 层，叶子节点位于第 $h_1$ 层）。在一棵阶为 $m$ 的完美满B树中，每个内部节点都恰好有 $m$ 个子节点，并且每个节点（包括根节点和叶子节点）都恰好存储 $m-1$ 个键。\n\n你需要将此源树转换为一棵等效的、阶为 $m_2 = 8$ 的B树，该树包含完全相同的键集合，转换过程通过以下两阶段流水线完成：\n- 阶段 1：对源树进行中序遍历，生成一个包含所有键的单一排序流。\n- 阶段 2：将此排序流批量加载到一棵阶为 $m_2$ 的完美满B树中。\n\n假设采用标准的外存模型，其中每个节点占用一个磁盘页，每次页面读取或写入计为一次输入/输出（I/O）操作。假设在阶段 1 中，源树的每个节点被精确读取一次；在阶段 2 中，目标树的每个节点被精确写入一次。忽略任何其他成本（如CPU计算或额外的遍历）。\n\n题目保证源树中的键总数使得在阶段 2 中批量加载一棵阶为 $m_2$ 的完美满B树是可行的。\n\n仅使用上述定义和关于等比数列的标准知识，计算此次转换产生的总I/O操作次数，结果为一个整数。不要提供不等式或方程式；请给出一个单一数字作为最终结果。无需四舍五入。", "solution": "此题的求解过程遵循以下步骤：首先，通过提取给定信息来验证题目的有效性，检查是否存在任何不一致或模糊之处。如果题目有效，则进行求解。\n\n### 步骤 1: 提取已知条件\n- **源树：** 一棵阶为 $m_1 = 4$、高度为 $h_1 = 2$ 的完美满B树。\n- **高度定义：** 从根到叶子的最长路径上的边数。这意味着根节点在第 $0$ 层，叶子节点在第 $h_1$ 层。\n- **完美满B树定义：** 对于一个阶为 $m$ 的树，每个内部节点恰好有 $m$ 个子节点，每个节点（包括叶子节点）恰好存储 $m-1$ 个键。\n- **目标树：** 一棵阶为 $m_2 = 8$ 的完美满B树，包含与源树相同的键集合。\n- **转换过程：**\n  - 阶段 1：对源树进行中序遍历，生成一个排序的键流。\n  - 阶段 2：将此排序流批量加载以创建目标树。\n- **I/O 成本模型：**\n  - 阶段 1 的成本是源树的每个节点一次读I/O。\n  - 阶段 2 的成本是目标树的每个节点一次写I/O。\n  - 所有其他成本均忽略不计。\n- **保证：** 源树中的键总数确保可以构建一棵阶为 $m_2$ 的完美满B树。\n\n### 步骤 2: 使用提取的已知条件进行验证\n- **科学依据：** 该问题基于计算机科学中的标准、明确定义的概念，特别是数据结构和算法领域（B树）。所描述的定义和操作在学术上是合理的。\n- **问题良定性：** 提供了所有必要的参数（$m_1$、$h_1$、$m_2$）和定义（完美满、高度、I/O成本）。目标是计算一个单一的特定数值。所给出的保证消除了构建目标树可行性的任何歧义。\n- **客观性：** 问题以精确、正式的语言陈述，不含主观或基于观点的内容。\n\n该问题没有表现出问题验证清单中列出的任何缺陷。它是算法领域一个定义明确的计算问题。\n\n### 步骤 3: 结论与行动\n该问题是 **有效的**。下面开始求解。\n\n总I/O操作数是阶段 1 和阶段 2 的I/O操作数之和。\n总I/O = (阶段 1 的I/O) + (阶段 2 的I/O)。\n\n**阶段 1：I/O 成本**\n阶段 1 的成本是源树中的总节点数，因为每个节点被精确读取一次。设此数量为 $N_1$。\n\n源树是一棵阶为 $m_1 = 4$、高度为 $h_1 = 2$ 的完美满B树。根据高度的定义，该树的层级从 $0$ 到 $h_1$。在一棵阶为 $m_1$ 的完美满B树中，每个内部节点恰好有 $m_1$ 个子节点。\n- 在第 $0$ 层，有 $1$ 个节点（根节点）。即 $m_1^0$。\n- 由于 $h_1 = 2 > 0$，根节点是一个内部节点，拥有 $m_1 = 4$ 个子节点。因此，在第 $1$ 层，有 $m_1^1 = 4$ 个节点。\n- 由于第 $2$ 层是叶子层，第 $1$ 层的节点是内部节点。这 $4$ 个节点每个都有 $m_1 = 4$ 个子节点。因此，在第 $2$ 层，有 $4 \\times 4 = 16$ 个节点。即 $m_1^2$。\n\n总节点数 $N_1$ 是所有层级节点数的总和：\n$$N_1 = \\sum_{i=0}^{h_1} m_1^i = \\sum_{i=0}^{2} 4^i = 4^0 + 4^1 + 4^2$$\n$$N_1 = 1 + 4 + 16 = 21$$\n这是一个等比数列，其和也可以按如下方式计算：\n$$N_1 = \\frac{m_1^{h_1+1} - 1}{m_1 - 1} = \\frac{4^{2+1} - 1}{4 - 1} = \\frac{4^3 - 1}{3} = \\frac{64 - 1}{3} = \\frac{63}{3} = 21$$\n阶段 1 的I/O成本为 $N_1 = 21$。\n\n**阶段 2：I/O 成本**\n阶段 2 的成本是目标树中的总节点数，因为每个节点被精确写入一次。设此数量为 $N_2$。为了求得 $N_2$，我们必须首先确定树中的总键数 $K$。\n\n根据完美满B树的定义，每个节点存储 $m-1$ 个键。源树有 $N_1 = 21$ 个节点，阶为 $m_1 = 4$。\n总键数 $K$ 为：\n$$K = N_1 \\times (m_1 - 1)$$\n$$K = 21 \\times (4 - 1) = 21 \\times 3 = 63$$\n目标树存储了同样数量的 $K = 63$ 个键。它是一棵阶为 $m_2 = 8$ 的完美满B树。在这棵树中，每个节点存储 $m_2 - 1$ 个键。\n$$m_2 - 1 = 8 - 1 = 7$$\n目标树的节点数 $N_2$ 是总键数除以每个节点的键数：\n$$N_2 = \\frac{K}{m_2 - 1} = \\frac{63}{7} = 9$$\n阶段 2 的I/O成本为 $N_2 = 9$。\n作为检验，与问题的保证一致，一个阶为 $m_2=8$、有 $N_2=9$ 个节点的完美满B树的高度为 $h_2=1$，因为节点数为 $\\sum_{i=0}^{1} 8^i = 8^0 + 8^1 = 1 + 8 = 9$。\n\n**总I/O操作**\n总I/O成本是两个阶段成本的总和：\n$$ \\text{Total I/O} = N_1 + N_2 = 21 + 9 = 30 $$", "answer": "$$\\boxed{30}$$", "id": "3211998"}, {"introduction": "理想模型为我们提供了理论基石，但真实世界的情形往往更为复杂。这个编程练习要求你亲手实现B树的插入算法，并观察在不同数据插入顺序下（例如，随机顺序与有序顺序）B树最终形成的结构差异。这个实践将直观地揭示插入历史如何影响树的高度和节点填充率，从而影响整体性能。[@problem_id:3212087]", "problem": "您的任务是为一个最小度为 $t$、在一组不重复的整数键上构建的B树实现一个构建器和分析器。该B树必须使用标准的自顶向下插入算法构建，该算法在下降前会分裂满节点，保持B树的所有不变量，并忽略任何可能出现的重复键（在提供的测试套件中不会出现重复项）。根据指定的插入顺序构建B树后，您必须计算其结构的量化指标，以反映插入顺序如何影响节点的占用率和高度 $h$。\n\n需要使用的基本基础和不变量：\n- 一个最小度为 $t$ 的B树是一个有根的、平衡的多路搜索树，其中每个节点（根节点可能除外）包含 $t-1$ 到 $2t-1$ 个键，如果是内部节点，则有 $t$ 到 $2t$ 个子节点。除非树为空，否则根节点包含 $1$ 到 $2t-1$ 个键。\n- 所有叶子节点都在同一深度。高度 $h$ 定义为任何从根到叶子路径上的边数。因此，一个单节点树（根即叶子）的高度为 $h=0$。\n- 任何节点中的最大键数为 $2t-1$。一个节点的占用率是该节点中的键数与 $2t-1$ 的比率。\n- 标准的B树自顶向下插入过程在继续下降之前会分裂遇到的任何满节点，从而确保当插入操作到达叶子节点时，该叶子节点不是满的。\n\n对于每个根据给定插入顺序构建的B树，计算以下指标：\n- 高度 $h$。\n- 节点总数。\n- 所有节点的最小占用率。\n- 所有节点的最大占用率。\n- 所有节点的平均占用率。\n\n您将比较在两种不同插入顺序下，由相同键集合构建的两个B树，并量化上述指标的差异。\n\n实现约束：\n- 仅使用上述结构不变量和标准的自顶向下B树插入方法；不要对最终结构使用任何预计算的公式。\n- 所有键都是不重复的整数；如果出现重复键，则应忽略（在提供的数据中不会出现）。\n- 此问题不涉及物理单位。\n- 所有浮点数结果在最终输出中必须四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n对于每个测试用例，给定 $t$ 和同一键集的两种插入顺序 $A$ 和 $B$。从 $A$ 和 $B$ 分别构建两个B树，并为每个树计算指标。\n\n- 测试用例 $1$：\n  - $t = 5$\n  - $A = [11,7,19,3,5,13,17]$\n  - $B = [3,5,7,11,13,17,19]$\n- 测试用例 $2$：\n  - $t = 2$\n  - $A = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]$\n  - $B = [15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]$\n- 测试用例 $3$：\n  - $t = 3$\n  - $A = [8,16,24,32,40,48,56,64,72,80,88,96,7,15,23,31,39,47,55,63]$\n  - $B = [63,55,47,39,31,23,15,7,96,88,80,72,64,56,48,40,32,24,16,8]$\n\n每个测试用例的所需输出：\n对于每个测试用例，按顺序生成以下 $10$ 个值，其中下标表示由顺序 $A$ 或 $B$ 构建的树：\n- $h_A$, $h_B$,\n- $\\text{avgOcc}_A$, $\\text{avgOcc}_B$,\n- $\\text{minOcc}_A$, $\\text{minOcc}_B$,\n- $\\text{maxOcc}_A$, $\\text{maxOcc}_B$,\n- $\\text{nodes}_A$, $\\text{nodes}_B$。\n\n这里，$\\text{avgOcc}$、$\\text{minOcc}$ 和 $\\text{maxOcc}$ 分别是在树中所有节点上计算的平均、最小和最大节点占用率，对所有节点都使用分母 $2t-1$。高度 $h_A$ 和 $h_B$ 是整数；节点计数是整数；所有占用率必须打印为四舍五入到恰好 $6$ 位小数的浮点数。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含三个测试用例的所有值，连接成一个用方括号括起来的、以逗号分隔的列表。顺序是测试用例1的10个值，后跟测试用例2的10个值，再后跟测试用例3的10个值。例如，您的输出必须看起来像\n\"[v1,v2,v3,...,v30]\"\n不含空格。所有浮点值必须四舍五入到恰好 $6$ 位小数。所有整数必须不带小数点显示。", "solution": "用户提供的问题是有效的。这是一个在数据结构和算法领域中定义明确的任务，基于B树构建和分析的既定原则。所有必要的参数、定义和约束都已提供，使得问题自成体系、一致且可解。任务是实现一个B树数据结构，根据指定的插入顺序填充它，并分析其结构属性。\n\n解决方案首先设计和实现B树数据结构，然后创建一个函数来分析其属性，最后将这些工具应用于提供的测试用例。\n\n### 基于原则的设计\n\n解决方案基于以下原则和算法组件：\n\n**1. B树节点和树结构**\n\nB树是一种平衡的多路搜索树。其结构由一个最小度定义，表示为 $t \\ge 2$。\n\n- **节点结构 (`BTreeNode`)**: 树中的每个节点存储：\n    - `keys`：一个已排序的键列表。除根节点外，任何节点中的键数 $n$ 必须满足 $t-1 \\le n \\le 2t-1$。根节点可以有 $1 \\le n \\le 2t-1$ 个键。\n    - `children`：一个指向子节点的指针列表。一个有 $n$ 个键的内部节点有 $n+1$ 个子节点。\n    - `leaf`：一个布尔标志，指示该节点是叶子节点（没有子节点）还是内部节点。\n    - `t`：树的最小度。\n\n- **树结构 (`BTree`)**: 整个树由一个类管理，该类持有对 `root` 节点和参数 `t` 的引用。\n\n**2. 插入算法：带主动分裂的自顶向下方法**\n\n问题指定了标准的自顶向下插入算法，其中在下降过程中遇到的任何满节点都会*在*递归进入它之前被分裂。这确保了当插入点到达叶子节点时，该叶子节点保证为非满，从而简化了过程。\n\n- **`insert(k)`**：这是插入操作的主要入口点。\n    1.  如果树为空，则创建一个新的根节点并插入键 $k$。\n    2.  如果根节点已满（即包含 $2t-1$ 个键），则必须将其分裂。创建一个新的空根节点，旧根成为其子节点，然后对这个新根执行 `split_child` 操作以分裂其唯一的子节点（旧根）。旧根的中位数键被移到新根中，新根现在有两个子节点。然后，从这个新的、非满的根开始，通过调用辅助函数 `insert_nonfull` 继续插入。\n    3.  如果根节点未满，则直接在根节点上调用 `insert_nonfull`。\n\n- **`split_child(x, i)`**：此函数分裂一个非满节点 $x$ 的第 $i$ 个子节点。设待分裂的子节点为 $y = x.\\text{children}[i]$。由于 $y$ 是满的，它有 $2t-1$ 个键。\n    1.  创建一个新节点 $z$。\n    2.  $y$ 的中位数键（索引为 $t-1$ 的键）被上移到父节点 $x$ 中。\n    3.  $y$ 中大于中位数的 $t-1$ 个键被移动到 $z$ 中。\n    4.  如果 $y$ 是一个内部节点，其对应的 $t$ 个子节点被移动到 $z$。\n    5.  新节点 $z$ 被插入到 $x$ 的子节点列表中，紧跟在 $y$ 之后。\n\n- **`insert_nonfull(x, k)`**：这个递归函数将一个键 $k$ 插入到一个非满节点 $x$ 中。\n    1.  **如果 $x$ 是叶子节点**：在已排序的 `keys` 列表中找到 $k$ 的正确位置并插入它。\n    2.  **如果 $x$ 是内部节点**：\n        a. 找到键 $k$ 所属的子树，即 $x.\\text{children}[i]$。\n        b. 如果该子节点 $x.\\text{children}[i]$ 是满的，首先调用 `split_child(x, i)` 将其分裂。这会将一个中位数键提升到 $x$ 并创建一个新的兄弟节点。分裂后，我们必须重新评估 $k$ 是属于原始子节点还是新的兄弟节点，并在必要时调整索引 $i$。\n        c. 在适当的（且现在保证为非满的）子节点上递归调用 `insert_nonfull`。\n\n其中包含一个检查以忽略重复键：在插入到叶子节点或下降到子节点之前，我们会检查当前节点中是否已存在该键。\n\n**3. 分析算法：用于计算指标的树遍历**\n\n一旦B树构建完成，其结构指标通过遍历所有节点来计算。此分析采用递归的深度优先遍历。\n\n- **`analyze_tree(tree)`**：此函数组织分析过程。\n    1.  它处理空树的边缘情况。\n    2.  它从根节点开始，以深度 $0$ 发起递归遍历。\n    3.  遍历函数 `_analyze_recursive(node, depth)` 访问每个节点并收集主要数据：节点总数、叶子节点的深度（由此得出高度 $h$）以及每个节点的占用率。\n    4.  节点占用率按定义计算：（节点中的键数）/ ($2t-1$)。\n    5.  遍历收集到所有节点占用率的列表后，计算最小值、最大值和平均值。\n    6.  返回最终指标（$h$、总节点数和占用率统计数据）。\n\n高度 $h$ 定义为从根到叶子路径上的边数。一个单节点树（根即叶子）的深度为 $0$，因此其高度为 $h=0$。这种定义通过递归深度跟踪方法自然得到处理。\n\n通过将此实现应用于给定的测试用例，我们可以以编程方式为插入顺序 $A$ 和 $B$ 构建B树，计算每个树所需的指标，并以指定格式呈现结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a B-tree builder and analyzer, and runs the provided test suite.\n    \"\"\"\n\n    class BTreeNode:\n        \"\"\"A B-tree node.\"\"\"\n        def __init__(self, t, leaf=False):\n            self.t = t\n            self.leaf = leaf\n            self.keys = []\n            self.children = []\n            # n is implicitly len(self.keys)\n\n        @property\n        def n(self):\n            return len(self.keys)\n\n    class BTree:\n        \"\"\"A B-tree.\"\"\"\n        def __init__(self, t):\n            if t < 2:\n                raise ValueError(\"B-tree minimum degree t must be at least 2.\")\n            self.t = t\n            self.root = None\n\n        def insert(self, k):\n            \"\"\"Inserts a key into the B-tree.\"\"\"\n            if self.root is None:\n                self.root = BTreeNode(self.t, leaf=True)\n                self.root.keys.append(k)\n                return\n\n            # If root is full, split it before inserting.\n            if self.root.n == 2 * self.t - 1:\n                old_root = self.root\n                new_root = BTreeNode(self.t, leaf=False)\n                self.root = new_root\n                new_root.children.append(old_root)\n                self._split_child(new_root, 0)\n                self._insert_non_full(new_root, k)\n            else:\n                self._insert_non_full(self.root, k)\n\n        def _insert_non_full(self, x, k):\n            \"\"\"Inserts a key into a non-full node.\"\"\"\n            i = len(x.keys) - 1\n            if x.leaf:\n                # Find position and insert key.\n                # First, check for duplicates.\n                pos_check = np.searchsorted(x.keys, k)\n                if pos_check < x.n and x.keys[pos_check] == k:\n                    return # Ignore duplicate\n\n                x.keys.append(0)  # Make space\n                while i >= 0 and k < x.keys[i]:\n                    x.keys[i + 1] = x.keys[i]\n                    i -= 1\n                x.keys[i + 1] = k\n            else:\n                # Find the child to descend into.\n                # First, check for duplicates.\n                pos_check = np.searchsorted(x.keys, k)\n                if pos_check < x.n and x.keys[pos_check] == k:\n                    return # Ignore duplicate\n\n                while i >= 0 and k < x.keys[i]:\n                    i -= 1\n                i += 1\n\n                # If child is full, split it.\n                if len(x.children[i].keys) == 2 * self.t - 1:\n                    self._split_child(x, i)\n                    # Key might now belong to the new sibling.\n                    if k > x.keys[i]:\n                        i += 1\n                self._insert_non_full(x.children[i], k)\n\n        def _split_child(self, x, i):\n            \"\"\"Splits the i-th child of node x.\"\"\"\n            t = self.t\n            y = x.children[i]\n            z = BTreeNode(t, y.leaf)\n\n            # Move median key of y to x.\n            x.keys.insert(i, y.keys[t - 1])\n            x.children.insert(i + 1, z)\n\n            # Move upper half of y's keys to z.\n            z.keys = y.keys[t:]\n            y.keys = y.keys[:t - 1]\n            \n            # If y is not a leaf, move its upper half children to z.\n            if not y.leaf:\n                z.children = y.children[t:]\n                y.children = y.children[:t]\n\n    def analyze_tree(tree):\n        \"\"\"Computes metrics for a given B-tree.\"\"\"\n        if tree.root is None:\n            return {\n                'h': -1, 'nodes': 0, 'minOcc': 0.0,\n                'maxOcc': 0.0, 'avgOcc': 0.0\n            }\n        \n        occupancies = []\n        node_count = 0\n        max_depth = 0\n        max_keys = 2 * tree.t - 1\n\n        q = [(tree.root, 0)] # (node, depth)\n        visited = {tree.root}\n\n        while q:\n            curr_node, depth = q.pop(0)\n            node_count += 1\n            max_depth = max(max_depth, depth)\n            \n            occupancy = curr_node.n / max_keys if max_keys > 0 else 0\n            occupancies.append(occupancy)\n            \n            if not curr_node.leaf:\n                for child in curr_node.children:\n                    if child not in visited:\n                        q.append((child, depth + 1))\n                        visited.add(child)\n\n        return {\n            'h': max_depth,\n            'nodes': node_count,\n            'minOcc': min(occupancies) if occupancies else 0.0,\n            'maxOcc': max(occupancies) if occupancies else 0.0,\n            'avgOcc': np.mean(occupancies) if occupancies else 0.0\n        }\n\n    test_cases = [\n        {\n            \"t\": 5,\n            \"A\": [11, 7, 19, 3, 5, 13, 17],\n            \"B\": [3, 5, 7, 11, 13, 17, 19]\n        },\n        {\n            \"t\": 2,\n            \"A\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n            \"B\": [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n        },\n        {\n            \"t\": 3,\n            \"A\": [8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 7, 15, 23, 31, 39, 47, 55, 63],\n            \"B\": [63, 55, 47, 39, 31, 23, 15, 7, 96, 88, 80, 72, 64, 56, 48, 40, 32, 24, 16, 8]\n        }\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        t = case[\"t\"]\n        keys_A = case[\"A\"]\n        keys_B = case[\"B\"]\n        \n        tree_A = BTree(t)\n        for key in keys_A:\n            tree_A.insert(key)\n        metrics_A = analyze_tree(tree_A)\n        \n        tree_B = BTree(t)\n        for key in keys_B:\n            tree_B.insert(key)\n        metrics_B = analyze_tree(tree_B)\n        \n        case_results = [\n            metrics_A['h'], metrics_B['h'],\n            metrics_A['avgOcc'], metrics_B['avgOcc'],\n            metrics_A['minOcc'], metrics_B['minOcc'],\n            metrics_A['maxOcc'], metrics_B['maxOcc'],\n            metrics_A['nodes'], metrics_B['nodes']\n        ]\n        all_results.extend(case_results)\n\n    formatted_results = []\n    for val in all_results:\n        if isinstance(val, float):\n            formatted_results.append(f\"{val:.6f}\")\n        else:\n            formatted_results.append(str(val))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3212087"}, {"introduction": "一个真正稳固的系统设计，必须考虑到意外的“损坏”情况。这个高级挑战将模拟一个场景：B树内部节点的“分隔键”失效，不再能正确指引搜索路径。你需要跳出标准算法的框架，仅依赖那些依然可靠的B树性质，设计一个鲁棒的搜索算法。这个练习旨在锻炼你从第一性原理出发解决问题的能力，并理解数据结构不变性的重要性。[@problem_id:3212077]", "problem": "给定 B 树（一种平衡多路搜索树）的数学定义，它满足以下关于最小度参数 $t$ 的核心属性：\n- 除根节点外，每个节点包含 $t-1$ 到 $2t-1$ 个有序键。\n- 每个拥有 $m$ 个键的内部节点恰好包含 $m+1$ 个子节点。\n- 每个节点中的键按非递减顺序排序。\n- 在一棵正确的树中，对于一个拥有键 $k_0,k_1,\\dots,k_{m-1}$ 和子节点 $c_0,c_1,\\dots,c_m$ 的内部节点，子树 $c_i$ 中的所有键都位于由 $k_{i-1}$ 和 $k_{i}$ 在排序顺序中界定的区间内，两端使用合适的无穷值。\n\n考虑一棵已损坏的 B 树，其中一些父节点的分隔键不再能正确地划分其子子树的值集。也就是说，存在一些内部节点，其子子树包含的值超出了父节点键所隐含的名义区间。你唯一可以假设的保证是：\n- 每个节点（无论是内部节点还是叶节点）内存储的键都按非递减顺序排序。\n- 存储在叶节点中的所有键是该树所表示集合的地面真实数据元素。\n- 结构性元数约束（每个节点的键和子节点数量）对于某个最小度 $t$ 仍在有效范围内，但你没有被提供 $t$ 的值，也不得依赖它。\n- 父节点的分隔键可能是错误的，因此不得信任它们来唯一确定用于搜索的单个子节点。\n\n任务：设计并实现一个鲁棒的搜索算法，该算法在给定一个键 $x$ 时，返回 $x$ 是否存在于这棵损坏的 B 树中。你的算法必须在分隔边界任意损坏的情况下保持正确，只要节点局部的键序得以保留且叶节点的键是准确的。你应该从第一性原理和关于该树的可观察事实出发进行推理。该算法必须：\n- 检查 $x$ 是否存在于当前节点存储的键中。\n- 仅使用关于子树的可验证信息（可从当前树实例中推导）来选择要遍历的子子树。\n- 避免排除任何可能包含 $x$ 的子子树。\n- 以一个布尔值答案终止，指明 $x$ 是否存在。\n\n在你的推导和设计中使用的基本依据：\n- B 树的节点不变量定义（节点局部键有序，元数边界）。\n- 搜索原则，即树中存在的任何值必须出现在某个叶节点中，并且任何叶节点值都受其路径上子树中的最小值和最大值的限制。\n\n你必须生成一个完整的、可运行的程序，该程序构建三个小型 B 树（在内存中表示）并对指定的查询执行鲁棒搜索。这些树和查询构成了测试套件，具体如下。\n\n定义以下树：\n\n- 树 $\\mathrm{T}_1$（正确分隔）：根节点有键 $\\{10,20\\}$ 和子节点：\n    - 子节点 $c_0$ 是一个叶节点，其键为 $\\{2,5,9\\}$。\n    - 子节点 $c_1$ 是一个叶节点，其键为 $\\{12,15,19\\}$。\n    - 子节点 $c_2$ 是一个叶节点，其键为 $\\{21,25,28\\}$。\n\n- 树 $\\mathrm{T}_2$（根部分隔损坏）：与 $\\mathrm{T}_1$ 相同，但根节点的键变为 $\\{14,20\\}$，而子节点保持不变：\n    - 子节点 $c_0$ 的叶节点键为 $\\{2,5,9\\}$。\n    - 子节点 $c_1$ 的叶节点键为 $\\{12,15,19\\}$。\n    - 子节点 $c_2$ 的叶节点键为 $\\{21,25,28\\}$。\n\n- 树 $\\mathrm{T}_3$（因损坏导致范围重叠）：根节点有键 $\\{15,30\\}$ 和子节点：\n    - 子节点 $c_0$ 是一个叶节点，其键为 $\\{5,10,25\\}$。\n    - 子节点 $c_1$ 是一个叶节点，其键为 $\\{16,18\\}$。\n    - 子节点 $c_2$ 是一个叶节点，其键为 $\\{31,34\\}$。\n\n对以下查询执行鲁棒搜索：\n- 在 $\\mathrm{T}_1$ 上，搜索 $x=25$。\n- 在 $\\mathrm{T}_2$ 上，搜索 $x=12$。\n- 在 $\\mathrm{T}_2$ 上，搜索 $x=13$。\n- 在 $\\mathrm{T}_2$ 上，搜索 $x=2$。\n- 在 $\\mathrm{T}_3$ 上，搜索 $x=25$。\n- 在 $\\mathrm{T}_3$ 上，搜索 $x=18$。\n- 在 $\\mathrm{T}_3$ 上，搜索 $x=29$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例相同（例如，$\\mathrm{[}\\mathrm{result}_1,\\mathrm{result}_2,\\dots\\mathrm{]}$）。每个结果必须是一个布尔值，指明被查询的值是否存在于相应的树中。不涉及任何物理单位、角度单位或百分比；所有输出都是纯布尔值。", "solution": "该问题要求设计并实现一种鲁棒的搜索算法，用于 B 树结构，其中基于键的子子树间分隔的定义属性已损坏。该算法必须仅使用保证有效的信息，正确判断查询键 $x$ 是否存在。\n\n### 问题验证\n\n首先，我们对问题陈述进行验证。\n\n**步骤 1：提取的已知条件**\n- **标准 B 树定义：** 一种具有最小度 $t$ 的平衡多路搜索树，其中节点包含 $t-1$ 到 $2t-1$ 个键，拥有 $m$ 个键的内部节点有 $m+1$ 个子节点，且键是有序的。正确的分隔意味着子树 $c_i$ 中的键受父节点键 $k_{i-1}$ 和 $k_i$ 的限制。\n- **损坏的 B 树保证：**\n    1. 父节点的分隔键不可靠，不得用于选择要搜索的子子树。\n    2. 任何单个节点内的键都按非递减顺序排序。\n    3. 所有叶节点中存储的所有键的集合构成了完整且正确的数据元素集。\n    4. 结构性元数约束（每个节点的键和子节点数量）对于某个未知的最小度 $t$ 是有效的。\n- **任务：** 为键 $x$ 设计一个鲁棒的搜索算法，返回一个指示其是否存在的布尔值。该算法必须：\n    - 在当前节点中检查 $x$。\n    - 仅使用可验证信息来决定遍历哪些子节点。\n    - 避免排除任何可能包含 $x$ 的子子树。\n- **测试用例：** 提供了三个特定的树结构（$T_1$、$T_2$、$T_3$）和七个特定的搜索查询，用于实现和验证。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上和算法上都是合理的。它提出了一个标准数据结构问题的变体，侧重于面对数据损坏时的鲁棒性。这是计算机科学中的一个有效课题，特别是在容错系统和数据恢复的研究中。\n- **科学依据：** 该问题基于 B 树的正式定义，这是数据结构中的一个基本概念。“损坏”是对标准不变量的明确修改，导致一个全新但可形式化的问题。\n- **问题适定：** 该问题提供了明确的目标（找到键 $x$）和一套完整的约束（哪些是可靠的 vs. 不可靠的）。存在解决方案（例如，暴力搜索所有叶节点是一个有效但效率低下的解决方案），挑战在于设计一个更有原则且更高效的算法。提供的测试用例使成功标准明确无误。\n- **客观性：** 语言精确，没有主观性。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。我们可以着手推导解决方案。\n\n### 鲁棒搜索算法的推导\n\n根本的挑战在于，标准的 B 树搜索依赖于这样一个性质：如果在父节点中 $k_{i-1}  x  k_i$，那么 $x$ 只能在子子树 $c_i$ 中。由于这个性质被违反，将搜索键 $x$ 与父节点的键进行比较，无法为将搜索剪枝到单个子节点提供可靠的指导。\n\n**1. 识别可验证信息**\n\n我们必须将搜索策略完全建立在已声明的保证之上。最关键的保证是：\n- 任何给定节点内的键都是有序的。\n- 完整的值集合位于叶节点中。\n\n从这些原则出发，我们可以推导出键 $x$ 存在于以节点 $N$ 为根的任何子树中的一个必要条件。如果 $x$ 在该子树中，它必须大于或等于该子树中的真实最小值，并小于或等于真实最大值。我们分别用 $\\min_{true}(N)$ 和 $\\max_{true}(N)$ 表示以 $N$ 为根的子树中的真实最小值和最大值。\n\n搜索键 $x$ 只有在 $x \\in [\\min_{true}(N), \\max_{true}(N)]$ 时，才可能存在于 $N$ 的子树中。\n\n**2. 计算子树的真实值范围**\n\n由于所有数据元素都存在于叶节点中，任何子树的真实值范围都由其后代叶节点中的键决定。我们可以为树中的每个节点计算这个范围。这个计算可以作为预处理步骤执行一次，并将结果缓存在每个节点上。后序遍历是实现这一目标的自然方式。\n\n为节点 $N$ 计算并缓存这些真实边界的算法如下：\n- **基本情况：** 如果 $N$ 是一个叶节点，其键保证是有序的。因此，$\\min_{true}(N)$ 是节点中的第一个键，而 $\\max_{true}(N)$ 是最后一个键。如果叶节点为空，其范围是空泛的；我们可以使用 $[\\infty, -\\infty]$。\n- **递归步骤：** 如果 $N$ 是一个拥有子节点 $\\{C_0, C_1, \\dots, C_m\\}$ 的内部节点，我们首先递归地计算其所有子节点的真实范围。问题陈述不保证子子树之间的键范围有任何排序（例如，不保证 $\\max_{true}(C_i)  \\min_{true}(C_{i+1})$）。因此，为了保证鲁棒性，我们必须找到其所有子节点中的最小值和最大值。\n$$ \\min_{true}(N) = \\min_{i=0}^{m} \\{\\min_{true}(C_i)\\} $$\n$$ \\max_{true}(N) = \\max_{i=0}^{m} \\{\\max_{true}(C_i)\\} $$\n这个预计算为每个节点增补了一个可验证的 `min_val` 和 `max_val` 属性，代表了其整个子树中包含的所有键的真实边界。\n\n**3. 鲁棒搜索算法**\n\n在预计算了真实值范围后，从节点 $N$ 开始对键 $x$ 进行的鲁棒搜索过程如下：\n\n1.  **检查当前节点：** 在当前节点 $N$ 的有序键中搜索 $x$。鉴于键的有序性，二分搜索是高效的。如果找到 $x$，算法终止，返回 `true`。\n2.  **叶节点终止：** 如果 $N$ 是一个叶节点且在步骤 1 中未找到 $x$，则 $x$ 不可能在该子树中。该路径的算法返回 `false`。\n3.  **内部节点递归：** 如果 $N$ 是一个内部节点，算法必须探索所有其真实值范围可能包含 $x$ 的子节点。它遍历 $N$ 的每个子节点 $C_i$。\n4.  **可能性检查：** 对于每个子节点 $C_i$，检查 $x$ 是否落入其预计算的真实范围：$\\min_{true}(C_i) \\le x \\le \\max_{true}(C_i)$。\n5.  **递归搜索：** 如果上一步的条件满足，子子树 $C_i$ 是 $x$ 的一个可能位置。算法在 $C_i$ 上递归调用自身。如果这个递归调用返回 `true`，意味着已找到 $x$，主搜索可以通过返回 `true` 来终止。\n6.  **穷尽搜索：** 如果算法遍历了所有可能的子节点，但没有一个递归调用找到 $x$，则可以断定 $x$ 不在 $N$ 的任何子树中。函数返回 `false`。\n\n该算法是正确的，因为它从不依赖于损坏的父节点分隔键进行导航。相反，它基于哪些值范围包含在哪些子树中的可验证地面真实信息，动态地构建其搜索路径，确保没有可能的路径被过早地剪枝。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the B-tree.\n    Each node stores its keys, children, and pre-computed true min/max values\n    of the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, keys, children=None):\n        \"\"\"\n        Initializes a Node.\n        \n        Args:\n            keys (list[int]): A list of keys stored in the node.\n            children (list[Node], optional): A list of child nodes. Defaults to None.\n        \"\"\"\n        # Ensure keys are stored in a sorted NumPy array for efficient search.\n        self.keys = np.array(keys, dtype=np.int64)\n        self.children = children if children else []\n        self.is_leaf = not bool(self.children)\n        \n        # These will be populated by compute_bounds.\n        self.min_val = None\n        self.max_val = None\n\ndef compute_bounds(node):\n    \"\"\"\n    Performs a post-order traversal to compute and cache the true minimum and\n    maximum key values for the subtree rooted at each node.\n    \n    Args:\n        node (Node): The root of the subtree to process.\n    \"\"\"\n    if node.is_leaf:\n        if node.keys.size > 0:\n            node.min_val = node.keys[0]\n            node.max_val = node.keys[-1]\n        else:\n            # An empty leaf has an invalid range.\n            node.min_val = float('inf')\n            node.max_val = float('-inf')\n        return\n\n    # Post-order: process children first.\n    child_min_vals = []\n    child_max_vals = []\n    for child in node.children:\n        compute_bounds(child)\n        child_min_vals.append(child.min_val)\n        child_max_vals.append(child.max_val)\n    \n    # The true range of an internal node is the union of the ranges of all its children.\n    # This robustly handles any child ordering.\n    if child_min_vals:\n        node.min_val = min(child_min_vals)\n    if child_max_vals:\n        node.max_val = max(child_max_vals)\n\ndef robust_search(node, x):\n    \"\"\"\n    Searches for a key 'x' in a potentially corrupted B-tree.\n    \n    Args:\n        node (Node): The current node to search in.\n        x (int): The key to search for.\n    \n    Returns:\n        bool: True if the key is found, False otherwise.\n    \"\"\"\n    # 1. Check if x is in the current node's keys.\n    # np.searchsorted gives the index where x would be inserted to maintain order.\n    # If the element at that index is x, we have found the key.\n    idx = np.searchsorted(node.keys, x)\n    if idx  len(node.keys) and node.keys[idx] == x:\n        return True\n\n    # 2. If this is a leaf node and x was not found, the search path ends here.\n    if node.is_leaf:\n        return False\n\n    # 3. For an internal node, recurse on all plausible children.\n    # A child is plausible if x is within its pre-computed true value range.\n    for child in node.children:\n        # The node must have a valid range to be considered.\n        if child.min_val is not None and child.max_val is not None:\n            if child.min_val = x = child.max_val:\n                # If found in any plausible subtree, the overall result is True.\n                if robust_search(child, x):\n                    return True\n    \n    # 4. If x was not found in the node or any plausible child subtree.\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to define trees, run queries, and print results.\n    \"\"\"\n    # --- Define Tree T1 (correctly separated) ---\n    t1_c0 = Node(keys=[2, 5, 9])\n    t1_c1 = Node(keys=[12, 15, 19])\n    t1_c2 = Node(keys=[21, 25, 28])\n    t1_root = Node(keys=[10, 20], children=[t1_c0, t1_c1, t1_c2])\n    compute_bounds(t1_root)\n\n    # --- Define Tree T2 (corrupted separation) ---\n    # Children are identical to T1, but root keys are different.\n    t2_c0 = Node(keys=[2, 5, 9])\n    t2_c1 = Node(keys=[12, 15, 19])\n    t2_c2 = Node(keys=[21, 25, 28])\n    t2_root = Node(keys=[14, 20], children=[t2_c0, t2_c1, t2_c2])\n    compute_bounds(t2_root)\n\n    # --- Define Tree T3 (overlapping ranges) ---\n    t3_c0 = Node(keys=[5, 10, 25])\n    t3_c1 = Node(keys=[16, 18])\n    t3_c2 = Node(keys=[31, 34])\n    t3_root = Node(keys=[15, 30], children=[t3_c0, t3_c1, t3_c2])\n    compute_bounds(t3_root)\n\n    # Define the test cases from the problem statement.\n    queries = [\n        (t1_root, 25),\n        (t2_root, 12),\n        (t2_root, 13),\n        (t2_root, 2),\n        (t3_root, 25),\n        (t3_root, 18),\n        (t3_root, 29),\n    ]\n\n    results = []\n    for tree_root, key_to_find in queries:\n        result = robust_search(tree_root, key_to_find)\n        results.append(str(result).lower())\n\n    # Final print statement in the exact required format.\n    # Python's str() of a boolean is 'True' or 'False'. Need lowercase.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3212077"}]}