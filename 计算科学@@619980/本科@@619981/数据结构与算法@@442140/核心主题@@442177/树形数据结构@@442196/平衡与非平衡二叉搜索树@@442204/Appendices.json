{"hands_on_practices": [{"introduction": "在了解了如何从头构建一棵平衡树之后，我们来深入探究像 AVL 树这类自平衡树的内部工作机制。本练习 [@problem_id:3213257] 是一个思想实验：触发一次“双旋转”（一种相对复杂的再平衡操作）所需的最少节点数量是多少？通过从再平衡的触发条件出发进行逆向推理，你将对这些旋转操作为何以及何时被触发建立起更深刻的直觉。", "problem": "考虑一个作为 Adelson-Velsky 和 Landis (AVL) 树维护的二叉搜索树 (BST)，其中空子树的高度定义为 $-1$，叶子节点的高度为 $0$，对于任何节点 $v$，高度平衡因子定义为 $\\operatorname{bf}(v) = h(\\text{left}(v)) - h(\\text{right}(v))$。当 $|\\operatorname{bf}(v)| \\ge 2$ 时，会发生 AVL 冲突，而当第一个违反 AVL 平衡的节点 $z$ 的平衡因子为 $\\operatorname{bf}(z) = 2$ 且其左孩子 $y$ 的平衡因子为 $\\operatorname{bf}(y) = -1$（左右情况）时，或者当 $\\operatorname{bf}(z) = -2$ 且其右孩子 $y$ 的平衡因子为 $\\operatorname{bf}(y) = +1$（右左情况）时，恰好需要进行双旋转。\n\n根据这些定义以及 BST 的插入机制（将新键作为叶子节点附加，同时保持中序排序），确定在一次强制进行 AVL 双旋转（左右或右左）的插入操作之后，树中存在的不同节点的最少数量。选择最佳答案。\n\nA. $2$ 个节点\n\nB. $3$ 个节点\n\nC. $4$ 个节点\n\nD. $5$ 个节点", "solution": "用户要求我确定在一次插入操作之后，导致需要进行双旋转的 AVL 树中节点的最少数量。\n\n### 步骤 1：问题验证\n\n首先，我将验证问题陈述。\n\n**1. 提取已知条件：**\n- 数据结构：作为 Adelson-Velsky 和 Landis (AVL) 树维护的二叉搜索树 (BST)。\n- 高度定义：\n    - 空子树的高度为 $-1$。\n    - 叶子节点的高度为 $0$。\n- 平衡因子：对于节点 $v$，平衡因子为 $\\operatorname{bf}(v) = h(\\text{left}(v)) - h(\\text{right}(v))$。\n- AVL 冲突：在节点 $v$ 处，如果 $|\\operatorname{bf}(v)| \\ge 2$，则发生 AVL 冲突。冲突在被插入节点的第一个（最接近插入点的）变得不平衡的祖先节点处被识别。\n- 双旋转条件：\n    - 左右（LR）情况：当违规节点 $z$ 的 $\\operatorname{bf}(z) = 2$ 且其左孩子 $y$ 的 $\\operatorname{bf}(y) = -1$ 时发生。\n    - 右左（RL）情况：当违规节点 $z$ 的 $\\operatorname{bf}(z) = -2$ 且其右孩子 $y$ 的平衡因子为 $\\operatorname{bf}(y) = +1$ 时发生。\n- 插入机制：新键作为新叶子节点附加，保持 BST 的中序属性。\n- 问题：在一次强制进行双旋转的插入操作之后，整个树中不同节点的最少数量是多少？\n\n**2. 使用提取的已知条件进行验证：**\n问题陈述具有科学依据、提法恰当且客观。\n- **科学正确性：** AVL 树、高度、平衡因子以及双旋转的具体条件的定义在数据结构研究中是标准的。将空子树的高度定义为 $-1$ 是一种常用约定，它简化了叶子节点的计算（$h(\\text{leaf}) = \\max(-1, -1) + 1 = 0$）。\n- **完整性和一致性：** 问题提供了唯一确定双旋转条件所需的所有定义。整个设定是自洽的，没有歧义。\n- **适定性：** 问题要求在一组特定约束下的最小值，这是 AVL 树形式系统内一个定义明确的优化问题。预计存在一个唯一的最小整数解。\n\n**3. 结论与行动：**\n问题有效。我将继续推导解决方案。\n\n### 步骤 2：解决方案推导\n\n我们需要找到在插入单个节点后满足双旋转条件的最小可能 AVL 树。我们来分析其中一种情况，即左右（LR）双旋转。右左（RL）情况是对称的，将得到相同的最小节点数。\n\n当一次插入导致节点 $z$ 的平衡因子变为 $\\operatorname{bf}(z) = 2$ 且其左孩子 $y$ 的平衡因子为 $\\operatorname{bf}(y) = -1$ 时，需要在 $z$ 处进行 LR 旋转。\n\n我们用上撇符号（例如 $h', \\operatorname{bf}'$）表示插入*前*树的状态，不用上撇符号表示插入*后*的状态。\n\n1.  **对节点 $z$ 的分析：** 一次插入最多使插入路径上的子树高度增加 $1$。要使 $\\operatorname{bf}(z)$ 变为 $2$，插入必须发生在 $z$ 的左子树中。在插入之前，该树是一棵有效的 AVL 树，意味着对所有节点 $v$ 都有 $|\\operatorname{bf}'(v)| \\le 1$。因此，$z$ 的平衡因子必定是 $\\operatorname{bf}'(z) = 1$。插入操作使 $z$ 的左子树高度增加了 $1$，从而导致冲突。\n    - $\\operatorname{bf}'(z) = h'(\\text{left}(z)) - h'(\\text{right}(z)) = 1$。\n    - 插入后：$h(\\text{left}(z)) = h'(\\text{left}(z)) + 1$。右子树的高度不变，$h(\\text{right}(z)) = h'(\\text{right}(z))$。\n    - $\\operatorname{bf}(z) = h(\\text{left}(z)) - h(\\text{right}(z)) = (h'(\\text{left}(z)) + 1) - h'(\\text{right}(z)) = \\operatorname{bf}'(z) + 1 = 1 + 1 = 2$。\n\n2.  **对节点 $y$ 的分析：** 节点 $y$ 是 $z$ 的左孩子。LR 旋转的条件是插入后 $\\operatorname{bf}(y) = -1$。插入发生在 $y$ 的子树中。\n    - 为了得到 $\\operatorname{bf}(y) = h(\\text{left}(y)) - h(\\text{right}(y)) = -1$，插入必须增加了 $y$ 的右子树的高度。如果插入发生在左子树，$\\operatorname{bf}(y)$ 会变为正数（或者如果之前是 $-1$ 则保持为 $0$，但那意味着 $y$ 已经不平衡了）。\n    - 所以，新节点被插入到 $y$ 的右子树中。插入前，$h'(\\text{left}(y)) = h'(\\text{right}(y))$，这意味着 $\\operatorname{bf}'(y) = 0$。插入操作使 $h(\\text{right}(y))$ 增加了 $1$，导致 $\\operatorname{bf}(y) = -1$。\n\n3.  **构建最小树：** 我们需要找到最小的有效 AVL 树，在插入前，它有一个节点 $z$ 满足 $\\operatorname{bf}'(z)=1$，且其左孩子 $y$ 满足 $\\operatorname{bf}'(y)=0$。为了使总节点数最少，我们必须最小化所有组成子树的高度。\n\n    - **插入前状态：**\n        - 为了以最少的节点数满足 $\\operatorname{bf}'(y) = 0$，我们可以假设 $y$ 没有孩子节点。在这种情况下，其左右子树都为空，每个高度为 $-1$。\n        - $h'(\\text{left}(y)) = -1$ 且 $h'(\\text{right}(y)) = -1$。\n        - 这使得 $y$ 成为一个叶子节点，高度为 $h'(y) = \\max(-1, -1) + 1 = 0$。\n        - 其平衡因子为 $\\operatorname{bf}'(y) = -1 - (-1) = 0$。这个条件得到满足。\n        - 现在看节点 $z$。我们需要 $\\operatorname{bf}'(z) = 1$。由于 $y$ 是 $z$ 的左孩子，我们有 $h'(\\text{left}(z)) = h'(y) = 0$。\n        - 平衡因子方程为 $\\operatorname{bf}'(z) = h'(\\text{left}(z)) - h'(\\text{right}(z)) = 0 - h'(\\text{right}(z)) = 1$。\n        - 这意味着 $h'(\\text{right}(z)) = -1$，即 $z$ 没有右孩子。\n        - 因此，最小的插入前树由节点 $z$ 和其唯一的左孩子 $y$ 组成。这棵树有 $2$ 个节点。它是一棵有效的 AVL 树，因为 $\\operatorname{bf}'(y)=0$ 且 $\\operatorname{bf}'(z)=1$。\n\n    - **插入：**\n        - 为了触发 LR 双旋转，我们必须在 $y$ 的右子树中插入一个新节点，称之为 $x$。\n        - 由于 $y$ 最初没有右孩子，$x$ 成为 $y$ 的右孩子。\n\n    - **插入后状态：**\n        - 最终的树由三个节点组成：$z$ 是根节点，$y$ 是 $z$ 的左孩子，$x$ 是 $y$ 的右孩子。\n        - 树中的总节点数为 $3$。\n        - 我们来验证一下最终状态下的平衡因子，以确认它会触发双旋转：\n            - 节点 $x$ 是叶子节点：$h(x) = 0$。其平衡因子为 $\\operatorname{bf}(x) = -1 - (-1) = 0$。\n            - 节点 $y$：$h(\\text{left}(y)) = -1$，$h(\\text{right}(y)) = h(x) = 0$。\n              $\\operatorname{bf}(y) = h(\\text{left}(y)) - h(\\text{right}(y)) = -1 - 0 = -1$。这符合 LR 旋转的条件。\n            - 节点 $z$：$h(\\text{left}(z)) = h(y) = \\max(-1, 0)+1=1$。$h(\\text{right}(z)) = -1$。\n              $\\operatorname{bf}(z) = h(\\text{left}(z)) - h(\\text{right}(z)) = 1 - (-1) = 2$。这是 AVL 冲突。\n\n既然我们有一个不平衡节点 $z$，其 $\\operatorname{bf}(z)=2$，且其左孩子 $y$ 的 $\\operatorname{bf}(y)=-1$，那么一次 LR 双旋转是必需的。该树的配置恰好包含 $3$ 个节点。任何更少数量的节点都无法构成高度为 2 的树，而这是在根节点处产生高度差为 2 所必需的。因此，3 是最小节点数。\n\n### 步骤 3：逐项分析\n\n- **A. $2$ 个节点：** 不正确。一次插入后，一棵树至少有 $2$ 个节点。一个 $2$ 节点的树由一个根和一个孩子组成，形成一条长度为 $1$ 的路径。其高度为 $1$。根节点的平衡因子要么是 $1$，要么是 $-1$。不可能出现 AVL 冲突。为了达到 $\\pm 2$ 的平衡因子，树的高度必须至少为 $2$，这需要最少 $3$ 个节点。\n\n- **B. $3$ 个节点：** 正确。如上所述，一棵具有 $3$ 个节点且排列成“之”字形路径的树，是在插入第三个节点后触发双旋转的最小配置。具体来说，从一个 2 节点树（根 $z$ 和左孩子 $y$）开始，将第三个节点 $x$ 作为 $y$ 的右孩子插入，会得到一个需要进行左右双旋转的 3 节点树。\n\n- **C. $4$ 个节点：** 不正确。虽然可以构建需要双旋转的更大的树，但问题要求的是最小节点数。既然存在一个有 $3$ 个节点的配置，那么 $4$ 不可能是最小值。\n\n- **D. $5$ 个节点：** 不正确。与选项 C 类似，这不可能是最小节点数，因为一个更小的有 $3$ 个节点的配置满足了问题的条件。", "answer": "$$\\boxed{B}$$", "id": "3213257"}, {"introduction": "我们已经学习了如何构建和维护树的平衡。最后一个练习 [@problem_id:3213176] 将探讨再平衡过程带来的一个深远影响。如果只给你一棵 AVL 树的最终平衡状态，我们能否推断出其构建过程中的插入顺序？这个问题旨在探究数据结构的最终状态与其操作历史之间的关系，并揭示一个核心观点：正是那些维持平衡的旋转操作，同时也抹去了关于操作顺序的历史痕迹。", "problem": "给你一个 Adelson–Velsky and Landis (AVL) 树的最终形态，它是一种高度平衡的二叉搜索树 (BST)。回顾一下基本定义：二叉搜索树 (BST) 存储不同的键，使得对于每个键为 $k$ 的节点，其左子树中的所有键都 $ k$，其右子树中的所有键都 $> k$；AVL 树强制执行一个不变性，即每个节点的平衡因子都在 $\\{-1,0,1\\}$ 集合中，其中平衡因子是左子树的高度减去右子树的高度。在 AVL 树中插入一个新键时，首先根据 BST 规则放置该键，然后执行局部旋转（这会保持 BST 属性）来恢复 AVL 的平衡不变性。\n\n请考虑以下基于这些定义的探究性问题。如果只给定一个包含不同键的 AVL 树的最终结构（没有时间戳或操作日志），你能从可能产生该结构的插入序列集合以及最后插入的键的可识别性方面推断出什么？\n\n选择最准确的陈述：\n\nA. 对于任何给定的、包含不同键的 AVL 树最终结构，都存在唯一的插入序列可以生成它，并且最后插入的键总是最终树中高度最大的最深叶子节点。\n\nB. 多个不同的插入序列可以导致相同的、包含不同键的 AVL 树最终结构，并且通常情况下，仅从最终结构无法唯一确定最后插入的键。\n\nC. 当且仅当根节点的平衡因子为 $0$ 时，才能从最终的 AVL 结构中唯一确定最后插入的键。\n\nD. 如果所有键都不同，最后插入的键必须是最终 AVL 树中的一个叶子节点，尽管它可能无法被唯一识别。\n\nE. 最终的 AVL 结构决定了所有插入过程中使用的旋转类型的多重集，这反过来又唯一确定了最后插入的键。", "solution": "用户希望我扮演一位严谨苛刻的 STEM 领域教授，来验证并解决一个关于 AVL 树的问题。\n\n### 第一步：提取已知条件\n- **系统：**Adelson–Velsky and Landis (AVL) 树，它是一种高度平衡的二叉搜索树 (BST)。\n- **BST 属性：**对于任何键为 $k$ 的节点，其左子树中的所有键都小于 $k$，其右子树中的所有键都大于 $k$。所有键都是不同的。\n- **AVL 不变性：**每个节点的平衡因子都在集合 $\\{-1, 0, 1\\}$ 中。\n- **平衡因子定义：**左子树的高度减去右子树的高度。\n- **插入过程：**首先根据 BST 规则插入一个新键，创建一个新叶子。然后，如果 AVL 不变性被破坏，则沿着从新叶子到根的路径执行局部旋转以恢复平衡。\n- **场景：**我们只得到一个 AVL 树的最终静态结构。没有提供操作历史（例如，插入顺序、旋转日志）。\n- **问题：**关于可能产生该树的插入序列集合以及最后插入的键的身份，可以推断出什么？\n\n### 第二步：使用提取的已知条件进行验证\n问题陈述在科学上是合理的，并且是良构的。\n- **科学依据：**BST、AVL 树、平衡因子以及带再平衡的插入过程的定义在计算机科学和数据结构领域是标准且正确的。\n- **良构性：**该问题提出了一个关于数据结构状态与其创建操作历史之间关系的清晰概念性问题。这是一个非平凡但可回答的问题，旨在探究对 AVL 树动态变化的理解。通过逻辑推理和构造实例可以得出有意义的结论。\n- **客观性：**问题以精确、客观的术语陈述，没有歧义或主观元素。\n\n该问题不违反任何无效性标准。它是算法分析中一个有效、可形式化的问题。\n\n### 第三步：判断与行动\n问题陈述是**有效的**。我将继续进行解答和逐项分析。\n\n***\n\n### 基于原理的推导\n\n核心问题是 AVL 树的最终结构是否唯一地决定了创建它的插入序列。如果序列不唯一，我们至少能唯一地识别出最后插入的键吗？这两个问题的答案都取决于再平衡旋转的性质。旋转旨在恢复高度平衡属性，同时保持 BST 属性，但它们可以显著改变树的拓扑结构，从而有效地抹去最近一次插入的“痕迹”。不同的插入历史，一些涉及旋转，一些不涉及，可能会收敛到相同的最终结构。\n\n为了证明这一点，我们将使用反例。\n\n**论点 1：多个不同的插入序列可以导致相同的最终 AVL 结构。**\n\n考虑不同的键集合 $\\{10, 20, 30\\}$。我们来分析几个插入序列。\n\n- **序列 1：$(10, 20, 30)$**\n  1. 插入 $10$：树为 `(10)`。\n  2. 插入 $20$：树为 `(10)`，其右孩子为 `(20)`。根节点 $10$ 的平衡因子为 $-1$。这是一棵有效的 AVL 树。\n  3. 插入 $30$：BST 插入将 $30$ 作为 $20$ 的右孩子。树变为 `(10) -> R:(20) -> R:(30)`。节点 $10$ 的平衡因子现在是 $h_{left} - h_{right} = -1 - 1 = -2$。树变得不平衡。需要在节点 $10$ 处进行一次左旋。节点 $20$ 成为新的根，其左孩子为 $10$，右孩子为 $30$。\n  - 最终的树根为 $20$，左孩子为 $10$，右孩子为 $30$。所有节点的平衡因子都为 $0$。\n\n- **序列 2：$(30, 20, 10)$**\n  1. 插入 $30$：`(30)`。\n  2. 插入 $20$：`(30)`，其左孩子为 `(20)`。根节点 $30$ 的平衡因子为 $1$。\n  3. 插入 $10$：BST 插入将 $10$ 作为 $20$ 的左孩子。树变为 `(30) -> L:(20) -> L:(10)`。节点 $30$ 的平衡因子现在是 $h_{left} - h_{right} = 1 - (-1) = 2$。需要在节点 $30$ 处进行一次右旋。节点 $20$ 成为新的根。\n  - 最终的树根为 $20$，左孩子为 $10$，右孩子为 $30$。这与序列 1 的结构完全相同。\n\n- **序列 3：$(20, 10, 30)$**\n  1. 插入 $20$：`(20)`。\n  2. 插入 $10$：`(20)`，其左孩子为 `(10)`。\n  3. 插入 $30$：`(20)`，其右孩子为 `(30)`。\n  - 最终的树根为 $20$，左孩子为 $10$，右孩子为 $30$。没有需要旋转。这同样是相同的最终结构。\n\n这些例子明确证明，多个不同的插入序列可以产生完全相同的最终 AVL 树结构。\n\n**论点 2：最后插入的键不一定在最终树中是叶子节点。**\n\n插入操作总是在叶子位置添加一个新键。然而，随后的再平衡旋转可以提升这个新节点。\n\n- **示例：插入序列 $(3, 5, 4)$**\n  1. 插入 $3$：`(3)`。\n  2. 插入 $5$：`(3)`，其右孩子为 `(5)`。$3$ 的平衡因子为 $-1$。\n  3. 插入 $4$：BST 插入将 $4$ 作为 $5$ 的左孩子。树为 `(3) -> R:(5) -> L:(4)`。\n     - 节点 $5$ 的平衡因子为 $1$。节点 $3$ 的平衡因子为 $-2$。\n     - 这需要一次双旋转（右-左旋转）。首先，在节点 $5$ 处进行右旋，使 $4$ 成为 $3$ 的右孩子。然后，在节点 $3$ 处进行左旋，将 $4$ 提升为根节点。\n     - 最终的树根为 $4$，左孩子为 $3$，右孩子为 $5$。\n  - 在这种情况下，最后插入的键 $4$ 是最终树的根节点，而不是叶子节点。\n\n在确立了这些原则之后，我们可以评估每个选项。\n\n### 逐项分析\n\n**A. 对于任何给定的、包含不同键的 AVL 树最终结构，都存在唯一的插入序列可以生成它，并且最后插入的键总是最终树中高度最大的最深叶子节点。**\n这个陈述提出了两个论点，两者都是错误的。\n1. “存在唯一的插入序列”：我们对键 $\\{10, 20, 30\\}$ 的分析表明，至少有三个不同的序列产生了相同的最终树。\n2. “最后插入的键总是最深的叶子节点”：我们对序列 $(3, 5, 4)$ 的分析表明，最后插入的键 $4$ 成为了最终树的根节点，而不是叶子节点。\n**结论：不正确。**\n\n**B. 多个不同的插入序列可以导致相同的、包含不同键的 AVL 树最终结构，并且通常情况下，仅从最终结构无法唯一确定最后插入的键。**\n这个陈述与我们的发现完全一致。\n1. “多个不同的插入序列可以导致相同的最终 AVL 结构”：这已通过 $\\{10, 20, 30\\}$ 的例子得到证明。\n2. “通常情况下，最后插入的键无法被唯一确定”：在同一个例子中，对于根为 $20$ 的最终树，最后插入的键可能是 $10$（来自序列 $(30, 20, 10)$）或 $30$（来自序列 $(10, 20, 30)$）。由于我们无法仅从最终结构中区分这些可能性，因此最后插入的键不是唯一可识别的。\n**结论：正确。**\n\n**C. 当且仅当根节点的平衡因子为 $0$ 时，才能从最终的 AVL 结构中唯一确定最后插入的键。**\n这是一个双向条件陈述。我们只需要找到一个不成立的方向即可。让我们测试这个方向：“如果根的平衡因子为 $0$，那么最后插入的键是唯一可识别的。”\n考虑我们从 $(3, 5, 4)$ 例子中得到的最终树：根为 $4$，左孩子为 $3$，右孩子为 $5$。根的平衡因子是 $h_{left} - h_{right} = 0 - 0 = 0$。\n我们知道序列 $(3, 5, 4)$ 产生了这棵树，其中 $4$ 是最后插入的键。\n让我们测试另一个序列：$(4, 3, 5)$。\n1. 插入 $4$：`(4)`。\n2. 插入 $3$：`(4)`，其左孩子为 `(3)`。\n3. 插入 $5$：`(4)`，其右孩子为 `(5)`。\n这个序列也产生了相同的树，但最后插入的键是 $5$。\n既然我们找到了一个根平衡因子为 $0$ 的树，其中最后插入的键可能是 $4$ 或 $5$（或者通过序列 $(4, 5, 3)$ 插入的 $3$），那么最后插入的键就不是唯一可识别的。这证伪了该陈述。\n**结论：不正确。**\n\n**D. 如果所有键都不同，最后插入的键必须是最终 AVL 树中的一个叶子节点，尽管它可能无法被唯一识别。**\n核心论点是最后插入的键“必须是叶子节点之一”。我们使用序列 $(3, 5, 4)$ 的例子提供了一个直接的反例。最后插入的键 $4$ 由于再平衡旋转被提升为最终树的根节点。因此，最后插入的键不一定是叶子节点。\n**结论：不正确。**\n\n**E. 最终的 AVL 结构决定了所有插入过程中使用的旋转类型的多重集，这反过来又唯一确定了最后插入的键。**\n其初始前提是“最终的 AVL 结构决定了旋转类型的多重集”。我们使用键 $\\{10, 20, 30\\}$ 的例子推翻了这一点。\n- 序列 $(10, 20, 30)$ 使用了一次左旋。\n- 序列 $(30, 20, 10)$ 使用了一次右旋。\n- 序列 $(20, 10, 30)$ 使用了零次旋转。\n所有三个序列都得到了相同的最终结构，但具有不同的旋转历史。因此，最终结构不能决定旋转历史。该陈述的第一部分是错误的，使得整个陈述都是错误的。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3213176"}]}