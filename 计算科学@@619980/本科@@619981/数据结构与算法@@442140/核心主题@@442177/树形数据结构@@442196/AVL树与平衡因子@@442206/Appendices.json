{"hands_on_practices": [{"introduction": "在编写复杂的树结构代码之前，能够在纸上模拟其操作是至关重要的一步。本练习旨在通过手动追踪一系列精心设计的插入操作，来巩固你对 AVL 树核心机制的理解。你将亲手计算每个节点的高度和平衡因子，并观察在插入特定键之后，树是如何失衡并触发一次右-左（RL）旋转的 [@problem_id:3210713]。这个过程将为你建立坚实的直觉，为后续更复杂的算法设计与调试打下基础。", "problem": "您将使用 Adelson–Velsky and Landis (AVL) 树的核心定义来分析在二叉搜索树插入过程中如何触发旋转以及平衡因子如何演变。设一个节点的高度为其到最远叶子节点的边数。因此，叶子节点的高度为 0，而空（None）子树的高度约定为 -1。任何非叶子节点的高度为 $1 + \\max\\{\\text{左子节点高度}, \\text{右子节点高度}\\}$。节点 $v$ 的平衡因子为 $\\operatorname{bf}(v) = \\text{height(left}(v)) - \\text{height(right}(v))$。如果每个节点的平衡因子都在 $\\{-1, 0, 1\\}$ 范围内，则该 AVL 树是平衡的。插入时，节点 $z$ 会触发：\n- 一次左-左 ($LL$) 旋转，如果 $\\operatorname{bf}(z) = +2$ 且插入发生在 $z$ 的左子节点的左子树中，\n- 一次右-右 ($RR$) 旋转，如果 $\\operatorname{bf}(z) = -2$ 且插入发生在 $z$ 的右子节点的右子树中，\n- 一次左-右 ($LR$) 旋转，如果 $\\operatorname{bf}(z) = +2$ 且 $z$ 的左子节点的 $\\operatorname{bf} = -1$（修复方法是对左子节点进行一次左旋，然后对 $z$ 进行一次右旋），\n- 一次右-左 ($RL$) 旋转，如果 $\\operatorname{bf}(z) = -2$ 且 $z$ 的右子节点的 $\\operatorname{bf} = +1$（修复方法是对右子节点进行一次右旋，然后对 $z$ 进行一次左旋）。\n\n考虑将键集合 $\\{1,2,3,4,5,6,7\\}$ 按特定顺序 $\\langle 4, 6, 5, 2, 1, 3, 7 \\rangle$ 插入一个初始为空的二叉搜索树中。这个顺序会在插入键 $5$ 之后、在该步骤执行任何重新平衡操作之前，强制在节点 $4$ 处进行一次右-左 ($RL$) 旋转。\n\n对于步骤 $t \\in \\{1,2,\\dots,7\\}$，令 $V_t$ 表示第 $t$ 次插入后、在该步骤执行任何重新平衡操作之前存在的节点集合，并令 $\\operatorname{bf}_t^{-}(v)$ 表示在该重新平衡前的树中节点 $v \\in V_t$ 的平衡因子。定义累积不平衡量\n$$\nS \\;=\\; \\sum_{t=1}^{7} \\;\\sum_{v \\in V_t} \\left|\\operatorname{bf}_t^{-}(v)\\right|.\n$$\n\n任务：\n- 仅使用上述基本定义，论证为何给定的插入顺序在插入键 $5$ 之后会强制在节点 $4$ 处进行一次 $RL$ 旋转。\n- 在每个步骤 $t$ 计算每个 $v \\in V_t$ 的 $\\operatorname{bf}_t^{-}(v)$，并在其第一个不平衡的祖先节点处识别所有旋转触发条件。\n- 计算 $S$ 的精确值。\n\n您的最终答案必须是 $S$ 的精确值（一个整数）。无需四舍五入。", "solution": "该问题是有效的，因为它是自洽的，科学上基于 AVL 树的理论，并且提法清晰。定义、插入序列以及待计算的量都已明确指定，确保存在唯一且有意义的解。\n\n解答过程分为两部分。首先，我们将论证为何在插入键 $5$ 后，节点 $4$ 处会强制进行一次 RL 旋转。其次，我们将跟踪 7 个键中每一个的插入过程，在每个步骤 $t$ 计算重新平衡前的平衡因子集合 $\\operatorname{bf}_t^{-}(v)$，并对它们的绝对值求和，以找到总的累积不平衡量 $S$。\n\n### 关于右-左 (RL) 旋转的论证\n\n我们从一棵空树开始。\n1.  插入 $4$：树是一个单节点 $4$。$h(4)=0$, $\\operatorname{bf}(4)=0$。\n2.  插入 $6$：由于 $6 > 4$，$6$ 成为 $4$ 的右子节点。树的结构为 $4 \\rightarrow (\\text{right}) \\ 6$。\n    - $h(6) = 0$。\n    - $h(4) = 1 + \\max(h(\\text{left}), h(6)) = 1 + \\max(-1, 0) = 1$。\n    - $\\operatorname{bf}(4) = h(\\text{left}) - h(6) = -1 - 0 = -1$。树是平衡的。\n\n3.  插入 $5$：由于 $5 > 4$，我们向右走到节点 $6$。由于 $5 < 6$，我们向左走。$5$ 作为 $6$ 的左子节点插入。在任何重新平衡之前，结构是 $4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$。让我们分析这次插入之后的状态，记为 $t=3$。\n    - 设 $v_4, v_5, v_6$ 是键为 $4, 5, 6$ 的节点。\n    - 新叶子节点的高度为 $h(v_5) = 0$。其平衡因子为 $\\operatorname{bf}_3^{-}(v_5) = 0 - 0 = 0$。\n    - 其父节点的高度为 $h(v_6) = 1 + \\max(h(v_5), h(\\text{empty})) = 1+\\max(0, -1) = 1$。\n    - $v_6$ 的平衡因子为 $\\operatorname{bf}_3^{-}(v_6) = h(v_5) - h(\\text{empty}) = 0 - (-1) = +1$。\n    - 根节点的高度为 $h(v_4) = 1 + \\max(h(\\text{empty}), h(v_6)) = 1+\\max(-1, 1) = 2$。\n    - $v_4$ 的平衡因子为 $\\operatorname{bf}_3^{-}(v_4) = h(\\text{empty}) - h(v_6) = -1 - 1 = -2$。\n\n从插入点 ($v_5$) 向上回溯，第一个平衡因子在 $\\{-1, 0, 1\\}$ 集合之外的节点是 $z=v_4$。其平衡因子为 $\\operatorname{bf}_3^{-}(v_4) = -2$。问题将节点 $z$ 的 RL 旋转触发条件定义为：“$\\operatorname{bf}(z) = -2$ 且 $z$ 的右子节点的 $\\operatorname{bf} = +1$”。此处，$z=v_4$，其右子节点是 $v_6$，我们已计算出 $\\operatorname{bf}_3^{-}(v_6) = +1$。\n两个条件都满足。因此，插入键 $5$ 会强制在节点 $4$ 处进行一次 RL 旋转。\n\n### $S$ 的分步计算\n\n我们现在计算 $S = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)|$。对于每个步骤 $t$，我们展示重新平衡前的树状态，计算平衡因子，对其绝对值求和，并描述重新平衡操作。\n\n**步骤 $t=1$：插入 $4$**\n-   重新平衡前的树：一个单节点 $4$。\n-   $V_1 = \\{4\\}$。\n-   $\\operatorname{bf}_1^{-}(4) = 0$。\n-   $\\sum_{v \\in V_1} |\\operatorname{bf}_1^{-}(v)| = |0| = 0$。\n-   树是平衡的。\n\n**步骤 $t=2$：插入 $6$**\n-   重新平衡前的树：$4 \\rightarrow (\\text{right}) \\ 6$。\n-   $V_2 = \\{4, 6\\}$。\n-   $\\operatorname{bf}_2^{-}(6) = 0$。\n-   $\\operatorname{bf}_2^{-}(4) = h(\\text{left}) - h(\\text{right}) = -1 - 0 = -1$。\n-   $\\sum_{v \\in V_2} |\\operatorname{bf}_2^{-}(v)| = |-1| + |0| = 1$。\n-   树是平衡的。\n\n**步骤 $t=3$：插入 $5$**\n-   重新平衡前的树：$4 \\rightarrow (\\text{right}) \\ 6 \\rightarrow (\\text{left}) \\ 5$。\n-   $V_3 = \\{4, 5, 6\\}$。\n-   $\\operatorname{bf}_3^{-}(5) = 0$。\n-   $\\operatorname{bf}_3^{-}(6) = h(5) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $\\operatorname{bf}_3^{-}(4) = h(\\text{empty}) - h(6) = -1 - 1 = -2$。\n-   $\\sum_{v \\in V_3} |\\operatorname{bf}_3^{-}(v)| = |-2| + |0| + |1| = 3$。\n-   旋转：节点 $4$ 不平衡（$\\operatorname{bf}=-2$），其右子节点的 $\\operatorname{bf}=+1$。在节点 $4$ 处执行一次 **RL 旋转**。树变为以 $5$ 为根，左子节点为 $4$，右子节点为 $6$。\n\n**步骤 $t=4$：插入 $2$**\n-   从 $t=3$ 重新平衡后的树：$5 \\rightarrow (\\text{left}) \\ 4, (\\text{right}) \\ 6$。\n-   在 $t=4$ 时重新平衡前的树：$5 \\rightarrow (\\text{left}) \\ (4 \\rightarrow (\\text{left}) \\ 2), (\\text{right}) \\ 6$。\n-   $V_4 = \\{2, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_4^{-}(2)=0$, $\\operatorname{bf}_4^{-}(6)=0$。\n-   $\\operatorname{bf}_4^{-}(4) = h(2) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $\\operatorname{bf}_4^{-}(5) = h(4) - h(6) = 1 - 0 = 1$。\n-   $\\sum_{v \\in V_4} |\\operatorname{bf}_4^{-}(v)| = |0| + |1| + |1| + |0| = 2$。\n-   树是平衡的。\n\n**步骤 $t=5$：插入 $1$**\n-   从 $t=4$ 得到的树：$5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ 2 \\big), (\\text{right}) \\ 6$。\n-   在 $t=5$ 时重新平衡前的树：$5 \\rightarrow \\big( (\\text{left}) \\ 4 \\rightarrow(\\text{left}) \\ (2 \\rightarrow \\text{left} \\ 1) \\big), (\\text{right}) \\ 6$。\n-   $V_5 = \\{1, 2, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_5^{-}(1)=0$, $\\operatorname{bf}_5^{-}(6)=0$。\n-   $\\operatorname{bf}_5^{-}(2) = h(1) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $h(2)=1$, $h(4)=1+\\max(h(2), h(\\text{empty}))=2$。$\\operatorname{bf}_5^{-}(4) = h(2) - h(\\text{empty}) = 1 - (-1) = 2$。\n-   $h(4)=2$, $h(5)=1+\\max(h(4), h(6)) = 3$。$\\operatorname{bf}_5^{-}(5) = h(4) - h(6) = 2 - 0 = 2$。\n-   $\\sum_{v \\in V_5} |\\operatorname{bf}_5^{-}(v)| = |0| + |1| + |2| + |2| + |0| = 5$。\n-   旋转：节点 $4$ 是第一个不平衡的节点（$\\operatorname{bf}=+2$）。插入发生在其左子节点的左子树中。在节点 $4$ 处执行一次 **LL 旋转**（一次右单旋）。以 $4$ 为根的子树变为以 $2$ 为根，左子节点为 $1$，右子节点为 $4$。这修复了所有祖先节点的平衡，包括节点 $5$。\n\n**步骤 $t=6$：插入 $3$**\n-   从 $t=5$ 重新平衡后的树：$5 \\rightarrow \\big( (\\text{left}) \\ (2 \\rightarrow (\\text{left}) \\ 1, (\\text{right}) \\ 4) \\big), (\\text{right}) \\ 6$。\n-   在 $t=6$ 时重新平衡前的树：插入 $3$ ($3<5, 3>2, 3<4$) 作为 $4$ 的左子节点。\n-   $V_6 = \\{1, 2, 3, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_6^{-}(1)=0$, $\\operatorname{bf}_6^{-}(3)=0$, $\\operatorname{bf}_6^{-}(6)=0$。\n-   $\\operatorname{bf}_6^{-}(4) = h(3) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $h(4)=1, h(1)=0$，所以 $\\operatorname{bf}_6^{-}(2) = h(1) - h(4) = 0 - 1 = -1$。\n-   $h(2)=2, h(6)=0$，所以 $\\operatorname{bf}_6^{-}(5) = h(2) - h(6) = 2 - 0 = 2$。\n-   $\\sum_{v \\in V_6} |\\operatorname{bf}_6^{-}(v)| = |0| + |-1| + |0| + |1| + |2| + |0| = 4$。\n-   旋转：节点 $5$ 不平衡（$\\operatorname{bf}=+2$），其左子节点（$2$）的 $\\operatorname{bf}=-1$。在节点 $5$ 处执行一次 **LR 旋转**。最终的树以 $4$ 为根。\n\n**步骤 $t=7$：插入 $7$**\n-   从 $t=6$ 重新平衡后的树：根为 $4$，左子节点为 $2$（其子节点为 $1,3$），右子节点为 $5$（其右子节点为 $6$）。\n-   在 $t=7$ 时重新平衡前的树：$7$ 作为 $6$ 的右子节点插入。\n-   $V_7 = \\{1, 2, 3, 4, 5, 6, 7\\}$。\n-   $\\operatorname{bf}_7^{-}(1)=0, \\operatorname{bf}_7^{-}(3)=0, \\operatorname{bf}_7^{-}(7)=0$。\n-   $\\operatorname{bf}_7^{-}(2) = h(1) - h(3) = 0 - 0 = 0$。\n-   $\\operatorname{bf}_7^{-}(6) = h(\\text{empty}) - h(7) = -1 - 0 = -1$。\n-   $h(2)=1$。$h(6)=1$, $\\operatorname{bf}_7^{-}(5) = h(\\text{empty}) - h(6) = -1 - 1 = -2$。\n-   $h(5)=2$, $\\operatorname{bf}_7^{-}(4) = h(2) - h(5) = 1 - 2 = -1$。\n-   $\\sum_{v \\in V_7} |\\operatorname{bf}_7^{-}(v)| = |0| + |0| + |0| + |-1| + |-2| + |-1| + |0| = 4$。\n-   旋转：节点 $5$ 不平衡（$\\operatorname{bf}=-2$）。插入发生在其右子节点的右子树中。在节点 $5$ 处执行一次 **RR 旋转**（一次左单旋）。\n\n**S 的最终计算**\n总累积不平衡量 $S$ 是每步总和的累加：\n$$\nS = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)| = 0 + 1 + 3 + 2 + 5 + 4 + 4\n$$\n$$\nS = 19\n$$", "answer": "$$\\boxed{19}$$", "id": "3210713"}, {"introduction": "掌握了手动追踪后，下一步便是将理论付诸代码。AVL 树的一个关键效率特性在于，插入操作引起的平衡调整通常只会影响从插入点到根节点的路径上的一小部分祖先节点。本练习 [@problem_id:3211032] 向你发起挑战：寻找一个特定的插入键，使得平衡因子的更新在树中传播得尽可能“深”，从而最大化更新链条的长度。完成这项挑战，需要你精确地对 AVL 插入算法的终止条件进行建模，从而深化对平衡维护动态过程的理解。", "problem": "给定阿德尔森-韦尔斯基和兰迪斯 (Adelson-Velsky and Landis, AVL) 树的定义，这是一种二叉搜索树 (BST)，它通过确保对于每个节点，其左子树和右子树的高度差（称为平衡因子）在 $\\{-1,0,+1\\}$ 范围内，来维持一个高度平衡不变量。对于一个节点 $v$，其平衡因子为 $bf(v) = h(\\text{left}(v)) - h(\\text{right}(v))$，其中 $h(\\cdot)$ 表示子树的高度（定义为从该节点到其最远叶子节点的边数；因此，叶子节点的高度为 0，空子树的高度为 -1）。向 AVL 树中插入新元素时，首先像在 BST 中一样放置新键，然后在返回根节点的路径上更新平衡因子。当此路径上的某个节点 $z$ 的平衡因子 $bf(z)$ 达到 $+2$ 或 $-2$ 时，会执行一次旋转（单旋转或双旋转）以恢复不变量。在向上的更新阶段，有两个标准的终止条件：(i) 如果在某个节点 $u$ 处，平衡因子从 $\\pm 1$ 变为 $0$，则 $u$ 的高度不增加，其更上层的祖先节点也不会受到影响；(ii) 如果在某个节点 $z$ 处发生旋转，重新平衡后以 $z$ 为根的子树的高度将等于插入前的高度，因此其更上层的祖先节点也不会受到影响。\n\n请精确定义以下目标。设 $T$ 为一棵有效的 AVL 树。对于一个不在 $T$ 中的键 $k$，考虑使用上述传统旋转和停止规则将 $k$ 插入到 $T$ 中的过程。定义传播计数 $P_T(k)$ 为在向上更新阶段，算法为其计算并赋予新平衡因子值的不同节点的数量。这些节点位于从插入位置向上到（并包括）算法终止的第一个祖先节点的搜索路径上（终止原因可能是平衡因子达到 $\\pm 2$ 触发旋转，或平衡因子变为 $0$）。等价地，$P_T(k)$ 计数了在更新传播停止之前，有多少个祖先节点接收了平衡因子更新。\n\n基本定义中的观察：\n- BST 属性根据 $k$ 与现有键的比较，唯一地确定了插入路径。\n- 平衡因子的更新源于子树高度的变化；从 $0$ 变为 $\\pm 1$ 表示高度增加，从 $\\pm 1$ 变为 $0$ 停止传播，达到 $\\pm 2$ 则触发旋转并停止传播。\n- 任何落在 $T$ 的两个连续中序键之间的区间内的键 $k$，都会产生相同的插入路径和相同的传播行为；因此，从每个这样的区间中选择一个规范代表，再加上代表低于最小值和高于最大值的两个无界区间的代表，就足够了。\n\n您的任务是编写一个完整的、可运行的程序，对于每个提供的测试用例，通过按给定顺序将一系列整数键插入一个空树来构建初始 AVL 树，然后对一个规范的有限候选键集合 $k$ 评估 $P_T(k)$。该集合定义如下：设 $T$ 的已排序中序键为 $a_0, a_1, \\dots, a_{n-1}$。候选集 $C(T)$ 必须包括：\n- $a_0 - 1$，\n- $a_{n-1} + 1$，\n- 对于每个 $i \\in \\{0,1,\\dots,n-2\\}$ 且 $a_{i+1} - a_i \\ge 2$ 的情况，包括整数中点 $\\left\\lfloor \\dfrac{a_i + a_{i+1}}{2} \\right\\rfloor$。\n任何与现有键相等的候选键都必须被丢弃。对于每个 $k \\in C(T)$，通过将 $k$ 插入一个根据给定序列重新构建的 $T$ 的全新副本中来模拟 AVL 插入，以计算 $P_T(k)$。对于每个测试用例，选择一个使 $P_T(k)$ 最大化的键 $k^\\star \\in C(T)$；如果出现平局，则选择最小的那个 $k^\\star$。每个测试用例所需的输出是键值对 $[k^\\star,P_T(k^\\star)]$。\n\n最终输出格式必须是单行文本，包含一个逗号分隔的所有测试用例的键值对列表，并用方括号括起来，即一个外部列表，其元素是包含两个整数的内部列表。例如，格式必须类似于 $[[x_1,y_1],[x_2,y_2],\\dots]$，不含空格，也没有额外文本。\n\n本问题中不涉及物理单位、角度单位或百分比。所有值均为整数。\n\n测试套件：\n- 情况 1（一般平衡情况）：按顺序插入键 $[30,20,40,10,25,35,50]$。\n- 情况 2（边界最小树）：按顺序插入键 $[100]$。\n- 情况 3（左深偏置）：按顺序插入键 $[50,30,70,20,40,60,80,10]$。\n- 情况 4（混合深度）：按顺序插入键 $[15,5,25,2,7,20,30,1,3,6,8]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应于上述顺序的一个测试用例，并具有键值对格式 $[k^\\star,P_T(k^\\star)]$。", "solution": "该问题定义明确，科学上基于数据结构原理，并包含了确定性解法所需的所有信息。因此，该问题被认为是有效的。\n\n问题的核心是，对于给定的阿德尔森-韦尔斯基和兰迪斯 (AVL) 树 $T$，确定哪个候选键 $k$（不在 $T$ 中）在 AVL 插入的向上回溯阶段导致最长的平衡因子更新链。此链的长度定义为传播计数 $P_T(k)$。\n\n解决方法包括三个主要阶段：\n1.  为每个测试用例构建初始 AVL 树。\n2.  生成候选键集合 $C(T)$。\n3.  模拟每个候选键的插入过程，计算其传播计数 $P_T(k)$，并找到使该计数最大化的键 $k^\\star$。\n\n**1. AVL 树的实现**\n\n首先，实现一个标准的 AVL 树数据结构。这包括一个 `Node` 类，用于存储键、指向左右子节点的指针以及以该节点为根的子树的高度。叶节点的高度定义为 $0$，空子树的高度定义为 $-1$。\n\n`AVLTree` 类封装了树的根节点，并提供一个 `insert` 方法。插入过程遵循标准的 AVL 算法：\n- 一个新键像在常规二叉搜索树 (BST) 中一样被插入。\n- 然后，算法从新节点的父节点开始向上遍历至根节点，更新路径上每个节点的 `height` 和平衡因子。节点 $v$ 的平衡因子由 $bf(v) = h(\\text{left}(v)) - h(\\text{right}(v))$ 给出，其中 $h(\\cdot)$ 是子树的高度。\n- 如果某个节点的平衡因子变为 $\\pm 2$，则执行一次旋转（单旋转或双旋转）以恢复 AVL 属性。旋转的类型（左-左、右-右、左-右、右-左）由不平衡节点及其相关子节点的平衡因子决定。\n\n还实现了一个辅助函数 `inorder_keys`，用于按排序顺序检索已构建树的键，这在下一阶段是必需的。\n\n**2. 候选集生成**\n\n对于给定的 AVL 树 $T$，其键按中序排序为 $a_0, a_1, \\dots, a_{n-1}$，根据问题定义构建候选键集合 $C(T)$：\n- 键 $a_0 - 1$，代表比任何现有键都小的插入。\n- 键 $a_{n-1} + 1$，代表比任何现有键都大的插入。\n- 对于每对连续键 $(a_i, a_{i+1})$，如果间隙 $a_{i+1} - a_i \\ge 2$，则包含整数中点 $\\lfloor \\frac{a_i + a_{i+1}}{2} \\rfloor$。此键代表落在 $a_i$ 和 $a_{i+1}$ 之间的插入。\n\n这些候选键代表了所有不在树中的键的拓扑上不同的插入路径。\n\n**3. 传播计数计算与最大化**\n\n核心任务是为每个 $k \\in C(T)$ 计算传播计数 $P_T(k)$。这是通过一个模拟函数 `calculate_propagation_count` 完成的，该函数不修改原始树 $T$。其逻辑如下：\n\n1.  **寻找插入路径**：对 $T$ 执行标准的 BST 搜索以找到键 $k$ 的路径，从而确定从根到 $k$ 将被插入位置的路径。路径上的节点被存储起来。\n\n2.  **向上遍历和计数**：算法接着模拟向上的更新阶段，从预期新节点的父节点开始，沿存储的路径向根节点移动。\n    - 初始化一个计数器 `propagation_count`为 $0$。\n    - 对于向上路径上的每个节点 $u$：\n        a. `propagation_count` 递增，因为算法必须为 $u$ 计算一个新的平衡因子。\n        b. 从原始树结构中检索 $u$ 的当前平衡因子 $bf_{old}(u)$。\n        c. 计算一个假设的新平衡因子 $bf_{new}(u)$。如果插入发生在 $u$ 的左子树中，其高度增加，因此 $bf_{new}(u) = bf_{old}(u) + 1$。如果在右子树中，则 $bf_{new}(u) = bf_{old}(u) - 1$。\n        d. 算法检查问题中描述的两个终止条件：\n            i. **平衡因子变为 0**：如果 $bf_{new}(u) = 0$，这意味着 $bf_{old}(u)$ 必定是 $\\pm 1$。在这种情况下，较短的子树已生长到与较高子树的高度相匹配。以 $u$ 为根的子树的整体高度不变，因此向祖先节点的传播停止。模拟循环终止。\n            ii. **触发旋转**：如果 $|bf_{new}(u)| = 2$，节点 $u$ 变得不平衡。将会执行一次旋转。AVL 旋转的一个重要特性是，重新平衡后的子树（根节点为替换 $u$ 的节点）的高度与插入前 $u$ 处原始子树的高度相同。因此，没有进一步的高度更新会传播给祖先节点。模拟循环终止。\n\n3.  **寻找最优键**：对于每个测试用例，为 $C(T)$ 中的每个 $k$ 运行此模拟。跟踪结果 $(k, P_T(k))$。最终选择是产生最大传播计数的键 $k^\\star$，平局则通过选择最小的 $k^\\star$ 来解决。\n\n这个系统化的过程正确地模拟了指定的行为，并能够确定每个测试用例所需的键值对 $[k^\\star, P_T(k^\\star)]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\nclass Node:\n    \"\"\"Node class for the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 0  # Height of a leaf node is 0. Height of a null subtree is -1.\n\nclass AVLTree:\n    \"\"\"AVL Tree implementation.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"Public method to insert a key into the AVL tree.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _get_height(self, node):\n        \"\"\"Returns the height of a node, or -1 for a null subtree.\"\"\"\n        return node.height if node else -1\n\n    def _update_height(self, node):\n        \"\"\"Updates the height of a node based on its children's heights.\"\"\"\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n\n    def get_balance(self, node):\n        \"\"\"Calculates the balance factor of a node.\"\"\"\n        return self._get_height(node.left) - self._get_height(node.right) if node else 0\n\n    def _rotate_right(self, y):\n        \"\"\"Performs a right rotation on subtree rooted at y.\"\"\"\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        self._update_height(y)\n        self._update_height(x)\n        return x\n\n    def _rotate_left(self, x):\n        \"\"\"Performs a left rotation on subtree rooted at x.\"\"\"\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        self._update_height(x)\n        self._update_height(y)\n        return y\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper function for insertion and rebalancing.\"\"\"\n        if not node:\n            return Node(key)\n        \n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        else:\n            return node  # Duplicate keys are not inserted\n\n        self._update_height(node)\n        balance = self.get_balance(node)\n\n        # Rebalancing cases\n        # Left-Left case\n        if balance > 1 and key < node.left.key:\n            return self._rotate_right(node)\n        # Right-Right case\n        if balance < -1 and key > node.right.key:\n            return self._rotate_left(node)\n        # Left-Right case\n        if balance > 1 and key > node.left.key:\n            node.left = self._rotate_left(node.left)\n            return self._rotate_right(node)\n        # Right-Left case\n        if balance < -1 and key < node.right.key:\n            node.right = self._rotate_right(node.right)\n            return self._rotate_left(node)\n        \n        return node\n\n    def inorder_keys(self):\n        \"\"\"Returns a list of keys in sorted order.\"\"\"\n        keys = []\n        self._inorder_traversal(self.root, keys)\n        return keys\n\n    def _inorder_traversal(self, node, keys):\n        if not node:\n            return\n        self._inorder_traversal(node.left, keys)\n        keys.append(node.key)\n        self._inorder_traversal(node.right, keys)\n\ndef calculate_propagation_count(tree, k):\n    \"\"\"\n    Simulates an AVL insertion of key k into tree T and returns the propagation count P_T(k).\n    \"\"\"\n    if not tree.root:\n        return 0\n    \n    path = []\n    node = tree.root\n    while node:\n        path.append(node)\n        if k < node.key:\n            node = node.left\n        else:\n            node = node.right\n\n    propagation_count = 0\n    child_key = k\n\n    # Traverse path upwards from the would-be parent of the new node\n    for i in range(len(path) - 1, -1, -1):\n        u = path[i]\n        propagation_count += 1\n        \n        bf_old = tree.get_balance(u)\n        \n        # Determine which subtree of u grew\n        if child_key < u.key:  # Left subtree grew\n            bf_new = bf_old + 1\n        else:  # Right subtree grew\n            bf_new = bf_old - 1\n\n        # Check for termination conditions\n        if bf_new == 0:  # bf changed from ±1 to 0; height of subtree at u doesn't change\n            break\n        if abs(bf_new) == 2:  # Rotation triggered; height of rebalanced subtree is same as original\n            break\n        \n        # For the next iteration, the 'child' is the current node u from the perspective of its parent\n        child_key = u.key\n    \n    return propagation_count\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        [30, 20, 40, 10, 25, 35, 50],\n        [100],\n        [50, 30, 70, 20, 40, 60, 80, 10],\n        [15, 5, 25, 2, 7, 20, 30, 1, 3, 6, 8],\n    ]\n\n    final_results = []\n    for keys in test_cases:\n        tree = AVLTree()\n        for key in keys:\n            tree.insert(key)\n        \n        sorted_keys = tree.inorder_keys()\n        \n        candidates = set()\n        if sorted_keys:\n            candidates.add(sorted_keys[0] - 1)\n            candidates.add(sorted_keys[-1] + 1)\n            for i in range(len(sorted_keys) - 1):\n                if sorted_keys[i+1] - sorted_keys[i] >= 2:\n                    candidates.add((sorted_keys[i] + sorted_keys[i+1]) // 2)\n\n        existing_keys = set(sorted_keys)\n        valid_candidates = sorted(list(candidates - existing_keys))\n\n        max_p = -1\n        best_k = -1\n\n        for k in valid_candidates:\n            p_k = calculate_propagation_count(tree, k)\n            if p_k > max_p:\n                max_p = p_k\n                best_k = k\n        \n        final_results.append([best_k, max_p])\n\n    # Format the output as specified: [[k1,p1],[k2,p2],...] with no spaces\n    print(f\"[{','.join([f'[{r[0]},{r[1]}]' for r in final_results])}]\")\n\nsolve()\n```", "id": "3211032"}, {"introduction": "在掌握了插入操作后，我们自然地转向另一个核心操作：删除。AVL 树的删除过程可能相当复杂，因为它同样需要通过旋转来恢复平衡。本练习 [@problem_id:3211065] 提供了一个独特的视角：它不要求你直接实现完整的、带旋转的删除算法，而是让你去识别那些“幸运”的节点——删除它们并不会破坏树的 AVL 平衡特性。通过解决这个问题，你将学会如何分析节点移除对整个树的子树高度和平衡因子的连锁影响，这对于理解和实现稳健的删除算法至关重要。", "problem": "给定几棵有效的 Adelson-Velsky and Landis (AVL) 树。一棵 Adelson-Velsky and Landis (AVL) 树是一棵二叉搜索树，其中对于每个节点 $v$，其平衡因子 $\\beta(v)$ 满足 $|\\beta(v)| \\leq 1$，其中 $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$，$h(\\cdot)$ 表示子树的高度。一个节点的高度被定义为其到最远叶子节点的路径上的边数。因此，叶子节点的高度为0，空（None）子树的高度约定为-1。二叉搜索树满足一个不变性：对于每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。\n\n旋转是一种局部重构操作（单旋转或双旋转），用于在因更新而产生不平衡节点时，恢复 $|\\beta(v)| \\leq 1$ 的不变性。在 Adelson-Velsky and Landis (AVL) 树中，当且仅当存在一个节点 $v$ 使得 $|\\beta(v)| = 2$ 时，更新后才需要进行旋转。\n\n从二叉搜索树中删除节点遵循以下经过充分测试的规则集：给定一个键 $x$，\n- 如果键为 $x$ 的节点没有子节点，则移除它；\n- 如果它有一个子节点，则用其子节点替换它；\n- 如果它有两个子节点，则用其中序后继的键（其右子树中的最小键）替换它的键，然后从右子树中删除该后继节点。\n\n基于上述基本定义，您的任务是为每棵给定的有效 Adelson-Velsky and Landis (AVL) 树，找出一个键，使得使用上述标准的二叉搜索树删除方法删除该键后，树中的任何位置都不需要进行旋转。等价地说，执行删除操作后，得到的树对于每个节点 $v$ 仍然必须满足 $|\\beta(v)| \\leq 1$。如果多个键满足此属性，您必须选择其中最小的一个。如果不存在这样的键，则输出 $-1$。\n\n测试套件：\n每棵树由一个不同整数键的插入序列指定。您需要按照给定顺序插入这些键来构建树，使用标准的 Adelson-Velsky and Landis (AVL) 树插入方法，该方法在插入过程中根据需要通过旋转来维持 $|\\beta(v)| \\leq 1$。请使用以下插入序列（每个数字都是一个整数键，按给定顺序呈现；所有数字都应解释为纯整数，不带任何单位）：\n- 情况 $1$：$[10, 5, 15, 3, 7, 13, 17]$\n- 情况 $2$：$[8, 4, 12, 2, 6, 10, 14, 1, 3]$\n- 情况 $3$：$[50, 25, 75, 10, 37, 62, 87, 5, 12, 31, 43, 57, 68, 81, 93]$\n- 情况 $4$：$[30, 20, 40, 10, 25, 35, 50, 27, 26]$\n- 情况 $5$：$[1, 2, 3, 4, 5, 6]$\n\n您的程序必须：\n- 通过按给定顺序插入序列来构造每棵 Adelson-Velsky and Landis (AVL) 树。\n- 对于每棵构造好的树，考虑使用前面描述的标准二叉搜索树删除操作删除每个存在的键 $x$。对于每次删除，判断删除后的树是否仍然是 Adelson-Velsky and Landis (AVL) 树（即对所有节点 $v$ 都有 $|\\beta(v)| \\leq 1$）。收集所有删除后不需要任何旋转的键 $x$，并选择最小的一个。如果集合为空，则该情况返回 $-1$。\n\n最终输出格式：\n您的程序应生成单行输出，包含所有五个情况的结果，形式为逗号分隔的列表，并用方括号括起来，例如 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_i$ 是为情况 $i$ 选择的整数键，如果不存在这样的键，则为 $-1$。此问题中不出现角度或物理单位，所有报告的值均为纯整数。", "solution": "该问题要求我们为一组给定的 Adelson-Velsky and Landis (AVL) 树，找出这样一个最小的键：使用标准的二叉搜索树 (BST) 删除算法删除该键后，不需要进行任何再平衡旋转。如果对于每个节点 $v$，其平衡因子 $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$ 满足 $|\\beta(v)| \\leq 1$，则该 AVL 树是平衡的。如果一次更新（如删除）导致任何节点的平衡因子变为 $|\\beta(v)| = 2$，则需要进行旋转。因此，任务是找到最小的键，其删除后能使树中所有节点 $v$ 仍然满足 $|\\beta(v)| \\leq 1$。\n\n对于每个测试用例，解决方案遵循一个多步骤的系统化方法。\n\n**1. AVL 树的构建**\n首先，我们必须从提供的插入序列构建初始的有效 AVL 树。这需要一个稳健的 AVL 树数据结构实现。\n\n-   **节点结构**：树中的每个节点存储其 `key`、指向其 `left` 和 `right` 子节点的指针，以及其 `height`。叶子节点的高度为 $0$，`None`（空）子树的高度为 $-1$。内部节点的高度为 $1 + \\max(\\text{左子节点高度, 右子节点高度})$。\n\n-   **插入算法**：对于给定序列中的每个键，我们执行一次 AVL 插入。这从标准的 BST 插入开始，将新键放置在叶子位置。然后，随着递归回溯到根节点，我们更新插入路径上每个节点的高度。每次高度更新后，我们计算节点的平衡因子。如果一个节点变得不平衡（$|\\beta(v)| = 2$），我们执行相应的单旋转或双旋转来恢复 AVL 属性。四种不平衡情况是：\n    1.  **左-左情况**：一次右旋转。\n    2.  **左-右情况**：对左子节点进行一次左旋转，然后对当前节点进行一次右旋转。\n    3.  **右-右情况**：一次左旋转。\n    4.  **右-左情况**：对右子节点进行一次右旋转，然后对当前节点进行一次左旋转。\n\n通过对输入序列中的每个键应用此过程，我们为每个测试用例构建了所需的初始 AVL 树。\n\n**2. 删除与验证的模拟**\n问题的核心是检查删除每个键的后果。这个过程必须是模拟，因为我们并非永久性地改变树，而是为每个键测试一个假设情景。\n\n-   **系统性迭代**：我们首先获取构建好的 AVL 树中所有键的排序列表。对 BST（因此也包括 AVL 树）进行中序遍历，自然会得到升序排列的键。然后我们遍历这些键。第一个满足条件的键将是最小的，从而满足问题的要求。\n\n-   **删除模拟**：对于每个待测试的键 $x$：\n    1.  **创建副本**：为避免修改原始树（后续测试需要用到），我们创建整个树结构的深拷贝。\n    2.  **执行 BST 删除**：在此副本上，我们执行问题陈述中指定的 BST 删除算法，但关键是*不带*再平衡（旋转）步骤。该算法如下：\n        -   如果待删除节点**没有子节点**，直接移除它。\n        -   如果它有**一个子节点**，该节点被其子节点替换。\n        -   如果它有**两个子节点**，其键被其中序后继（右子树中的最小键）的键替换。然后，从右子树中递归删除该后继节点。\n    3.  **更新高度**：在递归删除过程中，从被删除节点回到根节点的路径上所有节点的高度都会被更新。\n\n-   **验证检查**：在删除引起的结构变化和随后的高度更新之后，我们必须验证结果树是否仍然是一棵有效的 AVL 树。\n    1.  **遍历树**：我们对修改后的树副本进行一次完整遍历（例如，前序或后序遍历）。\n    2.  **检查平衡因子**：对于树中的每个节点 $v$，我们计算其平衡因子 $\\beta(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$。\n    3.  **条件检查**：如果我们发现任何节点的 $|\\beta(v)| > 1$，这意味着需要进行旋转来恢复平衡。因此，删除键 $x$ 不是一个有效的解决方案。\n    4.  **成功候选者**：如果遍历完成并且所有节点都满足 $|\\beta(v)| \\leq 1$，那么删除键 $x$ 不需要任何旋转。它是一个有效的候选者。\n\n**3. 确定最终答案**\n-   对于每个测试用例，我们遍历排序后的键。找到的第一个有效候选键，根据定义，就是最小的此类键。我们将此键记录为该用例的结果，然后继续处理下一个测试用例。\n-   如果遍历完树中的所有键，没有一个键在删除后能得到一棵平衡树，这意味着不存在这样的键。在这种情况下，该测试用例的答案是 $-1$。\n\n将此构建、模拟和验证的综合过程应用于所有五个测试用例，以生成最终的结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport copy\nimport sys\n\n# Increase recursion limit for deep trees during validation.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 0\n\nclass AVLTree:\n    \"\"\"AVL tree implementation with methods for insertion, deletion, and validation.\"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def _height(self, node):\n        return node.height if node else -1\n\n    def _get_balance(self, node):\n        if not node:\n            return 0\n        return self._height(node.left) - self._height(node.right)\n\n    def _right_rotate(self, z):\n        y = z.left\n        T3 = y.right\n        y.right = z\n        z.left = T3\n        z.height = 1 + max(self._height(z.left), self._height(z.right))\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        return y\n\n    def _left_rotate(self, y):\n        z = y.right\n        T2 = z.left\n        z.left = y\n        y.right = T2\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        z.height = 1 + max(self._height(z.left), self._height(z.right))\n        return z\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, root, key):\n        if not root:\n            return Node(key)\n        elif key < root.key:\n            root.left = self._insert(root.left, key)\n        else:\n            root.right = self._insert(root.right, key)\n\n        root.height = 1 + max(self._height(root.left), self._height(root.right))\n        balance = self._get_balance(root)\n\n        # Rebalance if necessary\n        # Case 1: Left Left\n        if balance > 1 and key < root.left.key:\n            return self._right_rotate(root)\n        # Case 2: Right Right\n        if balance < -1 and key > root.right.key:\n            return self._left_rotate(root)\n        # Case 3: Left Right\n        if balance > 1 and key > root.left.key:\n            root.left = self._left_rotate(root.left)\n            return self._right_rotate(root)\n        # Case 4: Right Left\n        if balance < -1 and key < root.right.key:\n            root.right = self._right_rotate(root.right)\n            return self._left_rotate(root)\n        \n        return root\n\n    def _get_min_value_node(self, root):\n        current = root\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def bst_delete(self, key):\n        \"\"\"Performs BST deletion without rebalancing, only height updates.\"\"\"\n        self.root = self._bst_delete(self.root, key)\n    \n    def _bst_delete(self, root, key):\n        if not root:\n            return root\n\n        if key < root.key:\n            root.left = self._bst_delete(root.left, key)\n        elif key > root.key:\n            root.right = self._bst_delete(root.right, key)\n        else: # Node to be deleted is found\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n            \n            # Node with two children\n            temp = self._get_min_value_node(root.right)\n            root.key = temp.key\n            root.right = self._bst_delete(root.right, temp.key)\n\n        if not root: # In case the tree becomes empty\n            return root\n\n        root.height = 1 + max(self._height(root.left), self._height(root.right))\n        return root\n\n    def is_balanced(self):\n        \"\"\"Checks if the entire tree satisfies the AVL property.\"\"\"\n        return self._is_balanced_recursive(self.root)\n\n    def _is_balanced_recursive(self, root):\n        if not root:\n            return True\n        \n        balance = self._get_balance(root)\n        if abs(balance) > 1:\n            return False\n            \n        return self._is_balanced_recursive(root.left) and \\\n               self._is_balanced_recursive(root.right)\n\n    def get_all_keys(self):\n        \"\"\"Returns a sorted list of all keys in the tree.\"\"\"\n        keys = []\n        self._inorder_traversal(self.root, keys)\n        return keys\n\n    def _inorder_traversal(self, root, keys_list):\n        if root:\n            self._inorder_traversal(root.left, keys_list)\n            keys_list.append(root.key)\n            self._inorder_traversal(root.right, keys_list)\n            \ndef solve():\n    \"\"\"Main function to solve the problem for all test cases.\"\"\"\n    test_cases = [\n        [10, 5, 15, 3, 7, 13, 17],\n        [8, 4, 12, 2, 6, 10, 14, 1, 3],\n        [50, 25, 75, 10, 37, 62, 87, 5, 12, 31, 43, 57, 68, 81, 93],\n        [30, 20, 40, 10, 25, 35, 50, 27, 26],\n        [1, 2, 3, 4, 5, 6]\n    ]\n\n    final_results = []\n    for insertion_sequence in test_cases:\n        # 1. Build the initial AVL tree for the current case.\n        avl_tree = AVLTree()\n        for key in insertion_sequence:\n            avl_tree.insert(key)\n        \n        # 2. Get a sorted list of all keys in the tree.\n        all_keys = avl_tree.get_all_keys()\n        \n        # 3. Find the smallest key whose deletion doesn't require rotation.\n        result_for_case = -1\n        for key_to_delete in all_keys:\n            # a. Create a deep copy to simulate deletion on.\n            tree_copy = copy.deepcopy(avl_tree)\n            \n            # b. Perform standard BST deletion (without rebalancing).\n            tree_copy.bst_delete(key_to_delete)\n            \n            # c. Check if the resulting tree is still balanced.\n            if tree_copy.is_balanced():\n                result_for_case = key_to_delete\n                break  # Found the smallest key, move to the next test case.\n        \n        final_results.append(result_for_case)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3211065"}]}