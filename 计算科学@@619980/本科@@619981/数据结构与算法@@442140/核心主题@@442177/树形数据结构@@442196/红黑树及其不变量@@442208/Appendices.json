{"hands_on_practices": [{"introduction": "在深入编写复杂代码之前，让我们先检验一下我们对概念的理解。真正掌握红黑树不变量，意味着我们无需执行所有步骤就能预测一次插入操作的结果。这个练习要求你分析树的局部结构，并仅根据基本规则推断出新插入节点的最终颜色 [@problem_id:3266375]。这种实践能够磨练你直接根据不变量进行推理的能力，这是算法设计与分析中的一项关键技能。", "problem": "给定定义红黑树 (RBT) 的形式化不变量和二叉搜索树属性。你的任务是仅使用这些不变量，而不模拟任何结构更新，推导并实现一个方法，用于预测当标准红黑树插入过程完成时，新插入的键为 $k$ 的节点的最终颜色。你必须从不变量出发进行推理，仅通过对预插入位置的局部配置进行逻辑分析，来确定新添加节点在算法终止后的颜色。以下定义构成了你推导的基础。\n\n二叉搜索树属性：对于任意键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。\n\n红黑树不变量：\n- 根节点是黑色的。\n- 每个叶节点（外部哨兵叶节点）都是黑色的。\n- 如果一个节点是红色的，那么它的两个子节点都是黑色的。\n- 对于每个节点，从该节点到其任一后代叶节点的所有简单路径都包含相同数量的黑色节点（这个数量称为该节点的黑高，计数不包括该节点本身，但包括黑色哨兵叶节点）。\n\n你的程序必须：\n- 使用二叉搜索树属性遍历现有树，以确定新键 $k$ 的预父节点及其所在的一侧（$\\text{left}$ 或 $\\text{right}$）。\n- 仅使用上述不变量来推断插入过程完成后新节点的最终颜色，而不执行任何旋转或重新着色操作。\n- 将颜色编码为整数：$0$ 表示红色，$1$ 表示黑色。\n\n测试套件：\n为以下固定的场景提供预测，每个场景都包含一棵现有的树和一个插入键 $k$。\n\n- 测试用例 1：一棵空树；插入 $k=42$。\n- 测试用例 2：一棵树，其根节点键为 $10$（黑色），左子节点键为 $5$（黑色），右子节点键为 $15$（黑色）；插入 $k=2$。\n- 测试用例 3：一棵树，其根节点键为 $10$（黑色），左子节点键为 $5$（红色），右子节点键为 $15$（红色）；插入 $k=7$。\n- 测试用例 4：一棵树，其根节点键为 $10$（黑色），左子节点键为 $5$（红色），右子节点键为 $15$（黑色）；插入 $k=7$。\n- 测试用例 5：一棵树，其根节点键为 $10$（黑色），左子节点键为 $5$（黑色），右子节点键为 $15$（红色）；插入 $k=20$。\n\n假设：\n- 所有给定的树在插入前都满足红黑树不变量。\n- 键 $k$ 与所有现有键都不同。\n- 外部叶节点被视为黑色哨兵，不是内部节点；在推理颜色时，缺失的子节点被视为黑色叶节点。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含按 $1$ 到 $5$ 的顺序排列的每个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，`[r_1,r_2,r_3,r_4,r_5]`），其中每个 $r_i$ 是 $\\{0,1\\}$ 中的一个整数。不应打印任何其他文本。", "solution": "我们从二叉搜索树属性和红黑树不变量开始。二叉搜索树属性确定了新键 $k$ 将被附加到的唯一位置，即作为某个父节点 $P$ 的左子节点或右子节点。红黑树不变量约束了插入节点在算法完成后可能的最终颜色，但没有指定中间步骤。\n\n与不变量和标准插入实践一致的基本事实：\n- 新的内部节点初始被着色为红色。如果立即将其着色为黑色，会使穿过该新节点的路径的黑高增加 $1$，从而违反了从根到叶节点的所有简单路径包含相同数量黑色节点的不变量。将其着色为红色可在附加时局部地保持黑高。\n- 如果父节点 $P$ 是黑色的，那么附加一个红色子节点不会违反红色节点不能有红色子节点的不变量。因此，不需要采取任何会改变新节点颜色的纠正措施；新节点保持红色。\n- 如果父节点 $P$ 是红色的，那么附加一个红色子节点会违反红色节点必须有黑色子节点的不变量。这个冲突必须通过局部重新着色和可能的旋转来解决，同时保持黑高。\n\n设 $G$ 为预插入节点的祖父节点，设 $U$ 为叔父节点（$P$ 的兄弟节点）。根据红色节点不能有红色父节点的不变量，当 $P$ 是红色时，$G$ 必须是黑色的。\n\n我们考虑由不变量引申出的情况：\n\n情况 1：树为空。根据根节点是黑色的不变量，插入的节点必须成为根节点并最终为黑色。因此，最终颜色为 $1$。\n\n情况 2：父节点 $P$ 是黑色的。因为新节点初始为红色，且黑色父节点拥有红色子节点不违反任何不变量，所以不需要进行影响新节点颜色的转换。最终颜色为 $0$。\n\n情况 3：父节点 $P$ 是红色，叔父节点 $U$ 也是红色。在 $P$ 处的冲突可以通过将 $P$ 和 $U$ 重新着色为黑色，并将 $G$ 重新着色为红色来消除。这保持了黑高，因为所有通过 $G$ 的路径上的黑色节点数量保持不变：我们在 $G$ 处移除了一个黑色节点，但在两侧通过 $P$ 和 $U$ 各增加了一个黑色节点，而新节点保持红色。如果重新着色导致 $G$ 有一个红色的父节点，该过程会逻辑上继续向树上方进行，但原始新节点的颜色保持红色。因此，最终颜色为 $0$。\n\n情况 4：父节点 $P$ 是红色，叔父节点 $U$ 是黑色（包括哨兵节点）。所有路径具有相等黑高以及红色节点不能有红色子节点的不变量，迫使进行局部重构。根据 $k$ 相对于 $P$ 和 $G$ 的朝向，存在两种几何子情况：\n- 内侧朝向：$P$ 是 $G$ 的左子节点，且 $k$ 插入到 $P$ 的右侧；或者 $P$ 是 $G$ 的右子节点，且 $k$ 插入到 $P$ 的左侧。在这种配置下，唯一与不变量一致的局部解决方案是，在一次准备性的局部旋转后，$\\{G,P,k\\}$ 中的中间键成为父节点并被着色为黑色，以恢复红色子节点约束并维持黑高。在内侧情况下，这个中间节点就是新插入的节点，因此它最终为黑色。最终颜色为 $1$。\n- 外侧朝向：$P$ 是 $G$ 的左子节点，且 $k$ 插入到 $P$ 的左侧；或者 $P$ 是 $G$ 的右子节点，且 $k$ 插入到 $P$ 的右侧。在这种配置下，一次围绕 $G$ 的旋转，加上将中间节点（即 $P$）着色为黑色、将 $G$ 着色为红色的重新着色操作，即可恢复不变量，而新节点作为 $P$ 的一个子节点保持红色。最终颜色为 $0$。\n\n这些结论是唯一地从不变量中得出的：保持所有从根到叶路径的黑高相等，以及禁止红色节点有红色子节点。没有必要完整模拟旋转过程；只需要检查 $P$ 和 $U$ 的局部颜色以及 $k$ 相对于 $P$ 和 $G$ 的相对朝向。\n\n将此推理应用于测试套件：\n\n- 测试用例 1（在空树上插入 $k=42$）：新节点成为根节点，必须为黑色。输出 $1$。\n- 测试用例 2（根 $10$ 黑色；子节点 $5$ 黑色，$15$ 黑色；$k=2$）：预父节点是 $5$（黑色），所以新节点保持红色。输出 $0$。\n- 测试用例 3（根 $10$ 黑色；左子节点 $5$ 红色；右子节点 $15$ 红色；$k=7$）：父节点为红色，叔父节点为红色，应用重新着色规则，新节点保持红色。输出 $0$。\n- 测试用例 4（根 $10$ 黑色；左子节点 $5$ 红色；右子节点 $15$ 黑色；$k=7$）：父节点为红色，叔父节点为黑色，内侧朝向（左-右）。新节点最终为黑色。输出 $1$。\n- 测试用例 5（根 $10$ 黑色；左子节点 $5$ 黑色；右子节点 $15$ 红色；$k=20$）：父节点为红色，叔父节点为黑色，外侧朝向（右-右）。新节点保持红色。输出 $0$。\n\n因此，按顺序要求的输出为 $[1,0,0,1,0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nRED = 0\nBLACK = 1\n\nclass Node:\n    def __init__(self, key: int, color: int):\n        self.key = key\n        self.color = color\n        self.left = None\n        self.right = None\n        self.parent = None\n\n    def set_left(self, child):\n        self.left = child\n        if child is not None:\n            child.parent = self\n\n    def set_right(self, child):\n        self.right = child\n        if child is not None:\n            child.parent = self\n\ndef bst_find_parent(root, k):\n    \"\"\"\n    Traverse the BST to find the would-be parent of key k and the side ('L' or 'R').\n    Returns (parent_node, side) where side is None if tree is empty.\n    \"\"\"\n    if root is None:\n        return None, None\n    curr = root\n    parent = None\n    side = None\n    while curr is not None:\n        parent = curr\n        if k  curr.key:\n            side = 'L'\n            curr = curr.left\n        else:\n            side = 'R'\n            curr = curr.right\n    return parent, side\n\ndef is_left_child(node):\n    return node.parent is not None and node.parent.left is node\n\ndef is_right_child(node):\n    return node.parent is not None and node.parent.right is node\n\ndef predicted_final_color(root, k):\n    \"\"\"\n    Predict the final color (0 for red, 1 for black) of the node with key k\n    after insertion completes, using only RBT invariants and local configuration.\n    \"\"\"\n    # Empty tree: new node becomes root, which must be black.\n    if root is None:\n        return BLACK\n\n    parent, side = bst_find_parent(root, k)\n    # Parent is black: new node remains red.\n    if parent.color == BLACK:\n        return RED\n\n    # Parent is red: examine grandparent and uncle.\n    grandparent = parent.parent\n    # In a valid RBT, grandparent must exist and be black if parent is red.\n    # Determine uncle (sibling of parent).\n    if grandparent is None:\n        # Defensive fallback: if this happens, treat as becoming root (black).\n        return BLACK\n    uncle = grandparent.right if is_left_child(parent) else grandparent.left\n\n    # Treat missing uncle (None) as black sentinel.\n    uncle_color = BLACK if uncle is None else uncle.color\n\n    if uncle_color == RED:\n        # Recoloring case: new node remains red.\n        return RED\n    else:\n        # Uncle is black: orientation determines outcome.\n        # Inner if parent is left child and insertion to right, or parent is right child and insertion to left.\n        parent_is_left = is_left_child(parent)\n        inner = (parent_is_left and side == 'R') or ((not parent_is_left) and side == 'L')\n        if inner:\n            # Triangle (inner) case: inserted node becomes black.\n            return BLACK\n        else:\n            # Linear (outer) case: inserted node remains red.\n            return RED\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: Empty tree, insert k=42\n    root1 = None\n    k1 = 42\n    tests.append((root1, k1))\n\n    # Test 2: Root 10 (black), left 5 (black), right 15 (black); insert k=2\n    root2 = Node(10, BLACK)\n    n5_2 = Node(5, BLACK)\n    n15_2 = Node(15, BLACK)\n    root2.set_left(n5_2)\n    root2.set_right(n15_2)\n    k2 = 2\n    tests.append((root2, k2))\n\n    # Test 3: Root 10 (black), left 5 (red), right 15 (red); insert k=7\n    root3 = Node(10, BLACK)\n    n5_3 = Node(5, RED)\n    n15_3 = Node(15, RED)\n    root3.set_left(n5_3)\n    root3.set_right(n15_3)\n    k3 = 7\n    tests.append((root3, k3))\n\n    # Test 4: Root 10 (black), left 5 (red), right 15 (black); insert k=7\n    root4 = Node(10, BLACK)\n    n5_4 = Node(5, RED)\n    n15_4 = Node(15, BLACK)\n    root4.set_left(n5_4)\n    root4.set_right(n15_4)\n    k4 = 7\n    tests.append((root4, k4))\n\n    # Test 5: Root 10 (black), left 5 (black), right 15 (red); insert k=20\n    root5 = Node(10, BLACK)\n    n5_5 = Node(5, BLACK)\n    n15_5 = Node(15, RED)\n    root5.set_left(n5_5)\n    root5.set_right(n15_5)\n    k5 = 20\n    tests.append((root5, k5))\n\n    return tests\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    results = []\n    for root, k in test_cases:\n        result = predicted_final_color(root, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3266375"}, {"introduction": "红黑树算法因其棘手的边界情况而臭名昭著，尤其是在再平衡逻辑中。如果这个逻辑有缺陷会发生什么？这个问题提出了一个假设情景：一个开发者错误地实现了对“之字形”（zig-zag）情况的修复，并要求你找出一个能暴露该错误的插入序列 [@problem_id:3266349]。通过思考如何“破坏”代码，你将更深刻地体会到，为什么标准的旋转和重新着色规则被如此精确地构建，以维护所有的不变量。", "problem": "您正在测试一个红黑树 (RBT) 的实现，它是一种满足以下不变性的二叉搜索树：根节点是黑色的，每个红色节点的孩子都是黑色的，并且从根到任意空叶子的每条路径都具有相同数量的黑色节点（黑高）。\n\n在标准的插入修复中，当一个新插入的节点与其叔叔节点为黑色（或空）时发生红-红冲突，旋转的选择取决于相对于祖父节点的形状：一个同侧配置 (zig-zig) 通过在祖父节点处进行一次单旋转来解决，而一个异侧配置 (zig-zag) 则通过由在父节点处的一次旋转和随后在祖父节点处的一次旋转组成的双旋转来解决。\n\n假设该实现在 zig-zag 情况下存在特定错误：每当新插入的节点及其父节点位于祖父节点的异侧 (zig-zag) 且叔叔节点为黑色时，代码会执行$2$次同方向的单旋转 (zig-zig)，而不是所要求的交叉方向的双旋转。换句话说，代码不是在父节点处朝插入节点方向旋转，然后在祖父节点处朝相反方向旋转，而是应用了两次同方向的旋转，其锚定方式如同 zig-zig 情况一样。\n\n从一个初始为空的树开始，插入从一个全序域中抽取的不同键，下列哪个插入序列必然会通过强制执行一个带有黑色叔叔节点的 zig-zag 再平衡步骤来暴露此错误，从而导致不正确的 zig-zig 操作无法恢复红黑树的不变性或二叉搜索树的属性？\n\n选择所有适用的选项。\n\nA. 按顺序插入：$3,1,2$。\n\nB. 按顺序插入：$3,5,4$。\n\nC. 按顺序插入：$1,2,3$。\n\nD. 按顺序插入：$3,2,1$。", "solution": "用户希望我验证问题陈述，如果有效，则解决它。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 数据结构是红黑树 (RBT)，具有以下不变性：\n    1. 根节点是黑色的。\n    2. 每个红色节点的孩子都是黑色的。\n    3. 从根到任意空叶子的每条路径都具有相同数量的黑色节点（黑高）。\n- 上下文是针对涉及新插入节点 $X$、其父节点 $P$ 和祖父节点 $G$ 的红-红冲突的插入修复过程。\n- $X$ 的叔叔节点是黑色或空。\n- 标准的 zig-zig（同侧）配置通过在祖父节点处进行一次单旋转来解决。\n- 标准的 zig-zag（异侧）配置通过双旋转（在父节点处旋转，然后在祖父节点处旋转）来解决。\n- 该实现在特定条件下存在错误：带有黑色叔叔节点的 zig-zag 情况。\n- 错误操作的描述是：“代码会执行$2$次同方向的单旋转(zig-zig)，而不是所要求的交叉方向的双旋转。换句话说，……它应用了两次同方向的旋转，其锚定方式如同 zig-zig 情况一样。”\n- 任务是识别从空树开始的哪些插入序列必然会暴露此错误。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在红黑树理论中有充分的依据，这是计算机科学和数据结构中的一个标准主题。RBT 的不变性和再平衡情况（zig-zig、zig-zag）在原则上描述正确。\n- **问题的适定性/模糊性**：错误操作的描述非常模糊。标准的 zig-zig 冲突修复涉及*单次*旋转，而不是两次。“执行$2$次同方向的单旋转 (zig-zig)” 这个说法是自相矛盾的。此外，尝试执行两次同向旋转（例如，两次左旋）通常是不可能的，因为被旋转的节点可能没有所需的子节点。\n\n然而，“其锚定方式如同 zig-zig 情况一样”这句话提出了一个合理的解释：算法错误地识别了 zig-zag 情况，并应用了相应的 zig-zig 情况的修复程序。这是一种常见的实现错误类型。\n- **标准的 L-R zig-zag 情况**：新节点 $X$ 是左孩子父节点 $P$ 的右孩子。正确的修复是在 $P$ 处进行一次左旋，然后在祖父节点 $G$ 处进行一次右旋。相应的 L-L zig-zig 情况将通过在 $G$ 处进行一次单次右旋来修复。\n- **标准的 R-L zig-zag 情况**：新节点 $X$ 是右孩子父节点 $P$ 的左孩子。正确的修复是在 $P$ 处进行一次右旋，然后在祖父节点 $G$ 处进行一次左旋。相应的 R-R zig-zig 情况将通过在 $G$ 处进行一次单次左旋来修复。\n\n对该错误行为最宽容且技术上最合理的解释是，当遇到 zig-zag 情况时，代码错误地应用了适用于类似 zig-zig 情况的单次旋转。\n- 对于左-右 (Left-Right) zig-zag，错误的操作是在祖父节点处进行一次右旋。\n- 对于右-左 (Right-Left) zig-zag，错误的操作是在祖父节点处进行一次左旋。\n\n在这种解释下，问题变得适定且可解。\n\n**步骤 3：结论与行动**\n- **结论**：问题被认为是**有效的**，但这取决于对上述模糊的错误描述所做的合理解释。分析将基于此解释进行。\n\n### 求解过程\n\n分析将追踪每个序列在初始为空的红黑树中的插入过程。如果一个序列 (1) 创建了一个带有黑色叔叔节点的 zig-zag 再平衡场景，并且 (2) 错误的修复操作导致生成的树违反了二叉搜索树 (BST) 属性或红黑树的不变性之一，那么该序列就暴露了错误。在下图中，(B) 表示黑色节点，(R) 表示红色节点。\n\n**解释后的错误操作：**\n- 如果发生左-右 (L-R) zig-zag，则对祖父节点执行一次右旋。\n- 如果发生右-左 (R-L) zig-zag，则对祖父节点执行一次左旋。\n- 在这两种情况下，都会应用标准的 zig-zig 修复的重新着色：子树的新根变为黑色，其子节点变为红色。\n\n**选项 A：按顺序插入 $3, 1, 2$**\n\n1.  **插入 $3$**：根节点是 $3(B)$。\n    $$3(B)$$\n2.  **插入 $1$**：$1  3$。$1$ 成为 $3$ 的左孩子。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    1(R)\n    \\end{array}\n    $$\n3.  **插入 $2$**：$2 > 1$ 且 $2  3$。$2$ 成为 $1$ 的右孩子。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    1(R) \\\\\n    \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ 2(R)\n    \\end{array}\n    $$\n    发生红-红冲突。新节点是 $X=2$，其父节点是 $P=1$，祖父节点是 $G=3$。\n    -   $P=1$ 是 $G=3$ 的左孩子。\n    -   $X=2$ 是 $P=1$ 的右孩子。\n    -   这是一个**左-右 (L-R) zig-zag** 配置。\n    -   $X=2$ 的叔叔节点是 $G=3$ 的右孩子，它是一个空叶子，被视作黑色。\n    -   满足了触发错误的条件。\n\n    **应用错误操作**：代码将此视为左-左 (L-L) zig-zig 情况，并对祖父节点 $G=3$ 执行一次右旋。标准的 L-L 修复的重新着色也被应用（子树的新根 $1$ 继承旧根的颜色黑色，旧根 $3$ 变为红色）。\n\n    初始子树：\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    1(R) \\\\\n    \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ 2(R)\n    \\end{array}\n    $$\n    在右旋($3$)和重新着色后：\n    $$\n    \\begin{array}{c}\n    1(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 3(R) \\\\\n    \\ \\ / \\\\\n    \\ 2(R)\n    \\end{array}\n    $$\n    **分析结果树**：\n    -   **BST 属性**：中序遍历为 $1, 2, 3$。BST 属性得以保持。\n    -   **RBT 不变性**：节点 $3(R)$ 有一个红色子节点 $2(R)$。这违反了每个红色节点必须有黑色孩子的规则。\n    -   由于 RBT 的一个不变性被违反，该错误被暴露出来。\n\n    **对 A 的结论**：**正确**。\n\n**选项 B：按顺序插入 $3, 5, 4$**\n\n1.  **插入 $3$**：根节点是 $3(B)$。\n2.  **插入 $5$**：$5 > 3$。$5$ 成为 $3$ 的右孩子。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 5(R)\n    \\end{array}\n    $$\n3.  **插入 $4$**：$4  5$ 且 $4 > 3$。$4$ 成为 $5$ 的左孩子。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 5(R) \\\\\n    \\ \\ / \\\\\n    \\ 4(R)\n    \\end{array}\n    $$\n    发生红-红冲突。新节点是 $X=4$，其父节点是 $P=5$，祖父节点是 $G=3$。\n    -   $P=5$ 是 $G=3$ 的右孩子。\n    -   $X=4$ 是 $P=5$ 的左孩子。\n    -   这是一个**右-左 (R-L) zig-zag** 配置。\n    -   $X=4$ 的叔叔节点是 $G=3$ 的左孩子，它是一个空叶子，被视作黑色。\n    -   满足了触发错误的条件。\n\n    **应用错误操作**：代码将此视为右-右 (R-R) zig-zig 情况，并对祖父节点 $G=3$ 执行一次左旋。标准的 R-R 修复的重新着色也被应用。\n\n    初始子树：\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 5(R) \\\\\n    \\ \\ / \\\\\n    \\ 4(R)\n    \\end{array}\n    $$\n    在左旋($3$)和重新着色后：\n    $$\n    \\begin{array}{c}\n    5(B) \\\\\n    /    \\\\\n    3(R) \\\\\n    \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ 4(R)\n    \\end{array}\n    $$\n    **分析结果树**：\n    -   **BST 属性**：中序遍历为 $3, 4, 5$。BST 属性得以保持。\n    -   **RBT 不变性**：节点 $3(R)$ 有一个红色子节点 $4(R)$。这违反了每个红色节点必须有黑色孩子的规则。\n    -   由于 RBT 的一个不变性被违反，该错误被暴露出来。\n\n    **对 B 的结论**：**正确**。\n\n**选项 C：按顺序插入 $1, 2, 3$**\n\n1.  **插入 $1$**：根节点是 $1(B)$。\n2.  **插入 $2$**：$2 > 1$。$2$ 成为 $1$ 的右孩子。\n3.  **插入 $3$**：$3 > 2$。$3$ 成为 $2$ 的右孩子。\n    $$\n    \\begin{array}{c}\n    1(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 2(R) \\\\\n    \\ \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ \\ \\ 3(R)\n    \\end{array}\n    $$\n    发生红-红冲突。新节点是 $X=3$，父节点是 $P=2$，祖父节点是 $G=1$。\n    -   $P=2$ 是 $G=1$ 的右孩子。\n    -   $X=3$ 是 $P=2$ 的右孩子。\n    -   这是一个**右-右 (R-R) zig-zig** 配置。\n    -   该错误被定义为仅在 zig-zag 情况下发生。此序列不会触发错误代码。将应用标准的、正确的修复。\n\n    **对 C 的结论**：**不正确**。\n\n**选项 D：按顺序插入 $3, 2, 1$**\n\n1.  **插入 $3$**：根节点是 $3(B)$。\n2.  **插入 $2$**：$2  3$。$2$ 成为 $3$ 的左孩子。\n3.  **插入 $1$**：$1  2$。$1$ 成为 $2$ 的左孩子。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    2(R) \\\\\n    /    \\\\\n    1(R)\n    \\end{array}\n    $$\n    发生红-红冲突。新节点是 $X=1$，父节点是 $P=2$，祖父节点是 $G=3$。\n    -   $P=2$ 是 $G=3$ 的左孩子。\n    -   $X=1$ 是 $P=2$ 的左孩子。\n    -   这是一个**左-左 (L-L) zig-zig** 配置。\n    -   该错误被定义为仅在 zig-zag 情况下发生。此序列不会触发错误代码。\n\n    **对 D 的结论**：**不正确**。", "answer": "$$\\boxed{AB}$$", "id": "3266349"}, {"introduction": "现在，是时候将你所学的知识综合起来，实现一个完整、可工作的算法了。这最后一个练习将指导你从零开始构建一个迭代式的红黑树插入算法，并严格要求只使用常数级别的额外空间，即 $O(1)$ [@problem_id:3266412]。这个任务是你学习过程的顶点，它要求你正确地管理指针、实现旋转，并应用迭代修复逻辑，来构建一个能够维持其所有关键不变量的健壮数据结构。", "problem": "您需要为 Red-Black Tree (RBT) 设计并实现一个迭代插入算法，且仅使用常数大小的额外空间（渐近大O表示法 ($O$) 指的是增长率，$O(1)$ 意为相对于键的数量是常数）。您的程序必须从给定的整数键序列构建一个 Red-Black Tree (RBT)，并验证在每个序列的所有插入操作后，该树是否满足 Red-Black Tree 的不变量。您必须生成一行输出，按下面指定的精确格式汇总所有测试用例的结果。\n\n将使用的基本定义：\n- 一个 Binary Search Tree (BST) 满足以下属性：对于任意键为 $k$ 的节点，其左子树中的每个键都严格小于 $k$，其右子树中的每个键都严格大于 $k$。\n- 一个 Red-Black Tree (RBT) 是一种 BST，其每个节点都有一个额外的颜色属性（红色或黑色），并满足以下不变量：\n  1. 根节点是黑色的。\n  2. 所有叶子节点都是同一个哨兵叶子节点（通常表示为单个共享节点），并且是黑色的。\n  3. 每个红色节点都有两个黑色的子节点。\n  4. 对于每个节点，从该节点到其任何一个叶子节点的每条简单路径都包含相同数量的黑色节点。\n\n您必须迭代地实现插入。重复的键将被忽略（也就是说，如果插入一个与现有键相等的键，树保持不变）。哨兵叶子节点必须被显式表示并且是黑色的。\n\n为了验证和报告，您必须计算：\n- 一个布尔值，指示在序列中的所有插入操作后，是否所有的 Red-Black Tree 不变量都成立。\n- 根节点的黑高（一个整数），其中黑高定义如下。令 $\\mathrm{bh}^{\\star}(x)$ 表示黑高，其递推关系如下：\n  - 如果 $x$ 是哨兵叶子节点，则 $\\mathrm{bh}^{\\star}(x) = 1$。\n  - 如果 $x$ 是一个真实节点，那么在不变量成立的情况下，$\\mathrm{bh}^{\\star}(x) = \\mathrm{bh}^{\\star}(x.\\mathrm{left}) + \\mathbf{1}_{\\{\\text{color}(x) = \\text{black}\\}} = \\mathrm{bh}^{\\star}(x.\\mathrm{right}) + \\mathbf{1}_{\\{\\text{color}(x) = \\text{black}\\}}$，其中 $\\mathbf{1}$ 是指示函数。\n- 树的高度 $h(T)$（一个整数），定义为从根节点到真实叶子节点的最长简单路径上的真实节点数（对于空树，$h(T) = 0$；对于只有一个真实节点的树，$h(T) = 1$）。\n\n在插入过程中，您的程序除了节点本身之外，只能使用常数数量的额外空间。构建后使用的验证程序在空间复杂度上不受限制，但必须是正确的。\n\n测试套件：\n为以下每个插入序列构建 RBT，按顺序进行，每种情况都从一棵空树开始。序列中的重复项必须被忽略。\n1. 情况 A（一般混合顺序）：$\\langle 10, 20, 30, 15, 25, 5, 1, 7, 12, 17 \\rangle$。\n2. 情况 B（严格递增）：$\\langle 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \\rangle$。\n3. 情况 C（严格递减）：$\\langle 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 \\rangle$。\n4. 情况 D（单个元素）：$\\langle 42 \\rangle$。\n5. 情况 E（包含待忽略的重复项）：$\\langle 5, 3, 7, 3, 5, 7, 2, 8 \\rangle$。\n6. 情况 F（重着色链行为）：$\\langle 11, 2, 14, 1, 7, 5, 8, 15, 13, 12 \\rangle$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有六种情况的结果，形式为逗号分隔的子列表列表，每个子列表的格式为 $[\\text{boolean}, \\text{integer}, \\text{integer}]$，其中布尔值写为小写单词 $true$ 或 $false$。例如，输出必须严格采用以下形式：\n$[[\\text{ok}_A,\\text{bh}_A,\\text{h}_A],[\\text{ok}_B,\\text{bh}_B,\\text{h}_B],[\\text{ok}_C,\\text{bh}_C,\\text{h}_C],[\\text{ok}_D,\\text{bh}_D,\\text{h}_D],[\\text{ok}_E,\\text{bh}_E,\\text{h}_E],[\\text{ok}_F,\\text{bh}_F,\\text{h}_F]]$，\n打印行中没有空格。\n\n不涉及物理单位；所有输出均为无量纲的整数和布尔值。程序必须是完整的，并且无需任何额外输入即可运行。", "solution": "该问题要求设计并实现一个用于 Red-Black Tree (RBT) 的迭代插入算法，其额外空间复杂度为常数 $O(1)$。从若干键序列构建树之后，该算法必须验证 RBT 不变量的完整性，并报告树的结构属性。\n\n### 问题验证\n首先，对问题陈述进行严格验证。\n\n**步骤 1：提取已知条件**\n- **数据结构**：Red-Black Tree (RBT)，一种 Binary Search Tree (BST)。\n- **节点属性**：`key`、`color`（`RED` 或 `BLACK`）、`left` 子节点、`right` 子节点、`parent` 父节点。\n- **RBT 不变量**：\n    1. 根节点是黑色的。\n    2. 所有叶子节点（哨兵）都是黑色的。\n    3. 红色节点必须有两个黑色的子节点。\n    4. 从一个给定节点到其任何后代叶子节点的每条简单路径都包含相同数量的黑色节点。\n- **哨兵叶子节点**：必须使用一个单一、共享的黑色哨兵节点来代表所有叶子。\n- **插入规则**：必须以迭代方式实现插入，而非递归。\n- **空间复杂度约束**：插入和修复操作必须使用相对于树中节点数量为 $O(1)$ 的额外空间。\n- **重复键**：树中已存在的键在插入时将被忽略。\n- **验证指标**：\n    1. `ok`：一个布尔值，指示是否所有 RBT 不变量都成立。\n    2. `bh`：根节点的黑高，$\\mathrm{bh}^{\\star}(\\text{root})$，由递推关系定义：如果 $x$ 是哨兵叶子节点，则 $\\mathrm{bh}^{\\star}(x) = 1$，否则 $\\mathrm{bh}^{\\star}(x) = \\mathrm{bh}^{\\star}(x.\\mathrm{left}) + \\mathbf{1}_{\\{\\text{color}(x) = \\text{black}\\}}$。\n    3. `h`：树的高度，定义为从根到真实叶子节点的最长路径上的真实节点数。\n- **测试用例**：提供了六个特定的整数序列用于构建和测试 RBT。\n- **输出格式**：单行逗号分隔的子列表列表，例如 `[[ok_A,bh_A,h_A],...]`。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础**：该问题牢固地定位于标准计算机科学课程之内，特别是数据结构与算法的研究。Red-Black Tree 是一种经典且被充分理解的数据结构。RBT 不变量及相关操作的定义是标准的教科书内容。该问题在科学和数学上是合理的。\n- **良构性**：该问题是良构的。输入（键序列）有明确定义，期望的输出（一个布尔值和两个整数指标）有明确规定。已知存在迭代的 RBT 插入算法，并且对于任何给定的插入序列，它都能产生一个唯一的、有效的 RBT。\n- **客观性**：该问题使用精确、客观和正式的语言陈述。没有主观或基于意见的成分。\n- **完整性与一致性**：该问题是自包含的。提供了 RBT、不变量、高度和黑高的所有必要定义。没有矛盾之处。插入操作 $O(1)$ 空间复杂度的约束是指导选择迭代算法而非递归算法（会使用 $O(\\log n)$ 的栈空间）的关键要求。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。这是一个基于既定计算机科学原理的、定义明确的算法任务。将提供一个解决方案。\n\n### 算法设计\n\n解决方案涉及创建一个 `RedBlackTree` 类，该类封装了树的逻辑，包括一个用于其元素的 `Node` 类。\n\n**1. 数据结构**\n- 定义一个 `Node` 类，包含属性：`key`、`color`、`parent`、`left` 和 `right`。\n- `RedBlackTree` 类持有一个对树的 `root` 的引用和一个单一的 `NIL` 节点，该节点按要求作为所有叶子的哨兵。`NIL` 节点始终为 `BLACK`。\n\n**2. 旋转**\n树旋转操作 `left_rotate` 和 `right_rotate` 是用于重新平衡树的基本操作。它们局部地重构树以维持 RBT 属性，同时保持 BST 属性。这些操作细致地更新受影响节点的 `parent`、`left` 和 `right` 指针。对于迭代实现，正确管理父指针至关重要。\n\n**3. 迭代插入**\n新键 $k$ 的插入是一个两阶段过程：BST 插入，然后是修复阶段。\n- **阶段 1：BST 插入**：算法从 `root` 开始迭代遍历树，为新节点找到合适的位置，类似于标准的 BST。一个指针 `y` 跟踪当前节点 `x` 的父节点。如果找到一个键为 $k$ 的节点，则中止插入，忽略重复项。否则，创建一个键为 $k$ 的新节点 `z`，并将其链接为 `y` 的子节点。新节点 `z` 被着色为 `RED`，其子节点设置为 `NIL` 哨兵。\n- **阶段 2：迭代修复**：一个 `RED` 父节点下的 `RED` 子节点（“红-红”冲突）是可能出现的主要问题。一个迭代的修复过程 `insert_fixup` 恢复 RBT 不变量。此过程使用一个 `while` 循环，只要当前节点 `z` 不是根节点且其父节点 `z.parent` 是 `RED`，循环就继续。循环内的逻辑取决于 `z` 的叔叔节点（`z` 父节点的兄弟节点）的颜色。\n    - **情况 1：`z` 的叔叔节点是 `RED`**：这是最简单的情况。我们将 `z` 的父节点和叔叔节点重新着色为 `BLACK`，将 `z` 的祖父节点重新着色为 `RED`。然后通过将 `z` 设为其祖父节点（`z = z.parent.parent`）将问题上移至树的更高层，并继续循环。\n    - **情况 2：`z` 的叔叔节点是 `BLACK`（三角形）**：当 `z` 和其父节点位于各自父节点的相对两侧时（例如，`z` 是右子节点，其父节点是左子节点），就会发生这种情况。对 `z` 的父节点进行一次旋转，将其转换为“直线”情况（情况 3）。\n    - **情况 3：`z` 的叔叔节点是 `BLACK`（直线）**：当 `z` 和其父节点在同一侧时（例如，两者都是左子节点），就会发生这种情况。我们将父节点重新着色为 `BLACK`，祖父节点重新着色为 `RED`，并对祖父节点执行一次旋转。这解决了红-红冲突，循环终止。\n循环结束后，树的根节点总是被设置为 `BLACK`，以保证不变量 1。整个过程仅使用少数几个指针（`z`、其父节点、祖父节点和叔叔节点），因此只需要 $O(1)$ 的额外空间。\n\n**4. 验证与度量**\n为给定序列构建树后，计算三个指标。\n- **不变量验证**：实现一个全面的递归函数 `_verify_and_get_bh_recursive`。该函数遍历树，同时检查是否违反不变量 3（红色节点不能有红色子节点）和不变量 4（所有路径具有相同的黑高）。如果子树有效，则返回其黑高；如果违反了不变量，则返回一个错误信号（例如，-1）。主验证函数 `verify_all_invariants` 还会检查不变量 1（根是黑色的），并使用递归检查的结果返回最终的 `True` 或 `False`。\n- **黑高计算**：问题定义黑高 $\\mathrm{bh}^{\\star}$ 使得 $\\mathrm{bh}^{\\star}(\\text{sentinel}) = 1$。递归验证函数的设计正是为了计算这个值。因此，`get_black_height` 只需在根节点上调用此函数。\n- **树高计算**：另一个标准的递归函数 `_height_recursive` 计算树的高度，定义为从根到真实叶子的最长路径上的真实节点数，正确处理空树和 `NIL` 节点的基准情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Color constants\nRED = 0\nBLACK = 1\n\nclass Node:\n    \"\"\"A node in the Red-Black Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.parent = None\n        self.left = None\n        self.right = None\n        self.color = RED  # New nodes are initially red\n\nclass RedBlackTree:\n    \"\"\"An implementation of a Red-Black Tree.\"\"\"\n    def __init__(self):\n        self.NIL = Node(None)\n        self.NIL.color = BLACK\n        self.NIL.left = self.NIL\n        self.NIL.right = self.NIL\n        self.NIL.parent = self.NIL # Self-parent for convenience\n        self.root = self.NIL\n\n    def left_rotate(self, x):\n        \"\"\"Performs a left rotation on node x.\"\"\"\n        y = x.right\n        x.right = y.left\n        if y.left != self.NIL:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent == self.NIL:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def right_rotate(self, y):\n        \"\"\"Performs a right rotation on node y.\"\"\"\n        x = y.left\n        y.left = x.right\n        if x.right != self.NIL:\n            x.right.parent = y\n        x.parent = y.parent\n        if y.parent == self.NIL:\n            self.root = x\n        elif y == y.parent.right:\n            y.parent.right = x\n        else:\n            y.parent.left = x\n        x.right = y\n        y.parent = x\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the tree iteratively.\"\"\"\n        y = self.NIL\n        x = self.root\n\n        while x != self.NIL:\n            y = x\n            if key  x.key:\n                x = x.left\n            elif key > x.key:\n                x = x.right\n            else:\n                # Duplicate key, do nothing\n                return\n\n        z = Node(key)\n        z.parent = y\n        if y == self.NIL:\n            self.root = z\n        elif z.key  y.key:\n            y.left = z\n        else:\n            y.right = z\n        \n        z.left = self.NIL\n        z.right = self.NIL\n        z.color = RED\n\n        self.insert_fixup(z)\n\n    def insert_fixup(self, z):\n        \"\"\"Restores the Red-Black properties after insertion.\"\"\"\n        while z.parent.color == RED:\n            if z.parent == z.parent.parent.left:\n                uncle = z.parent.parent.right\n                if uncle.color == RED: # Case 1: Uncle is RED\n                    z.parent.color = BLACK\n                    uncle.color = BLACK\n                    z.parent.parent.color = RED\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.right: # Case 2: Triangle\n                        z = z.parent\n                        self.left_rotate(z)\n                    # Case 3: Line\n                    z.parent.color = BLACK\n                    z.parent.parent.color = RED\n                    self.right_rotate(z.parent.parent)\n            else: # Symmetric case\n                uncle = z.parent.parent.left\n                if uncle.color == RED: # Case 1\n                    z.parent.color = BLACK\n                    uncle.color = BLACK\n                    z.parent.parent.color = RED\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.left: # Case 2\n                        z = z.parent\n                        self.right_rotate(z)\n                    # Case 3\n                    z.parent.color = BLACK\n                    z.parent.parent.color = RED\n                    self.left_rotate(z.parent.parent)\n        self.root.color = BLACK\n\n    def _verify_and_get_bh_recursive(self, node):\n        \"\"\"\n        Recursively verifies RBT properties 3 and 4, and computes black-height.\n        Returns black-height if subtree is valid, -1 otherwise.\n        \"\"\"\n        if node == self.NIL:\n            return 1  # bh*(sentinel) = 1\n\n        left_bh = self._verify_and_get_bh_recursive(node.left)\n        right_bh = self._verify_and_get_bh_recursive(node.right)\n\n        # Propagate error signal\n        if left_bh == -1 or right_bh == -1:\n            return -1\n\n        # Invariant 4: Black-heights of children must be equal\n        if left_bh != right_bh:\n            return -1\n\n        # Invariant 3: Red node's children must be black\n        if node.color == RED:\n            if node.left.color == RED or node.right.color == RED:\n                return -1\n\n        # Calculate black-height for this node's subtree\n        if node.color == BLACK:\n            return left_bh + 1\n        else: # Node is RED\n            return left_bh\n    \n    def verify_all_invariants(self):\n        \"\"\"Verifies all RBT invariants.\"\"\"\n        # Invariant 1: Root is BLACK. An empty tree's root is NIL, which is black.\n        if self.root != self.NIL and self.root.color != BLACK:\n            return False\n        \n        # Invariant 2 is true by design (self.NIL is always black).\n\n        # Check invariants 3 and 4\n        return self._verify_and_get_bh_recursive(self.root) != -1\n    \n    def get_black_height(self):\n        \"\"\"Returns the black-height of the tree, or -1 if invalid.\"\"\"\n        return self._verify_and_get_bh_recursive(self.root)\n    \n    def _height_recursive(self, node):\n        \"\"\"Computes height (number of real nodes on longest path).\"\"\"\n        if node == self.NIL:\n            return 0\n        return 1 + max(self._height_recursive(node.left), self._height_recursive(node.right))\n\n    def get_height(self):\n        \"\"\"Returns the height of the tree.\"\"\"\n        return self._height_recursive(self.root)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case A (general mixed order)\n        [10, 20, 30, 15, 25, 5, 1, 7, 12, 17],\n        # Case B (strictly increasing)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n        # Case C (strictly decreasing)\n        [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],\n        # Case D (single element)\n        [42],\n        # Case E (contains duplicates to be ignored)\n        [5, 3, 7, 3, 5, 7, 2, 8],\n        # Case F (recoloring chain behavior)\n        [11, 2, 14, 1, 7, 5, 8, 15, 13, 12]\n    ]\n\n    results = []\n    for keys in test_cases:\n        rbt = RedBlackTree()\n        for key in keys:\n            rbt.insert(key)\n        \n        is_valid = rbt.verify_all_invariants()\n        black_height = rbt.get_black_height()\n        height = rbt.get_height()\n        results.append([is_valid, black_height, height])\n    \n    # Format the final output string exactly as specified\n    result_strings = []\n    for r in results:\n        is_valid_str = str(r[0]).lower()\n        bh_str = str(r[1])\n        h_str = str(r[2])\n        result_strings.append(f\"[{is_valid_str},{bh_str},{h_str}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3266412"}]}