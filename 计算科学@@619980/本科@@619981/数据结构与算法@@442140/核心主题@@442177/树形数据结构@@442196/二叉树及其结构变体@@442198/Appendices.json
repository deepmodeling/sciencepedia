{"hands_on_practices": [{"introduction": "要真正掌握数据结构，最好的方式莫过于亲手实现其核心算法。本节的第一个练习将带你深入理解二叉树的递归本质。我们将通过判断一棵二叉树是否对其根节点中心对称，来实践递归思想和树的遍历，这不仅是编码练习，更是对结构之美的深刻体会。[@problem_id:3216104]", "problem": "您的任务是设计并实现一个程序，该程序使用数据结构的基本定义和第一性原理，判断给定的二叉树是否围绕其根对称。\n\n从二叉树的递归定义开始：一个二叉树要么是空的，要么由一个节点组成，该节点有一个左孩子和一个右孩子，它们本身也都是二叉树。设一棵树表示为 $T$，其根为 $r$，其左右子树分别为 $T_{\\text{L}}$ 和 $T_{\\text{R}}$。\n\n定义从根到任意节点的路径为一个在字母表 $\\{\\text{L}, \\text{R}\\}$ 上的有限序列，分别表示向左或向右遍历。对于任意路径 $p \\in \\{\\text{L}, \\text{R}\\}^{\\ast}$，通过函数 $\\phi$ 定义路径的镜像，使得 $\\phi(\\text{L}) = \\text{R}$ 且 $\\phi(\\text{R}) = \\text{L}$，并同态地扩展到字符串，使得对于任意 $k \\in \\mathbb{N}$，有 $\\phi(p_{1}p_{2}\\cdots p_{k}) = \\phi(p_{1})\\phi(p_{2})\\cdots\\phi(p_{k})$。一棵根为 $r$ 的二叉树 $T$ 围绕其根对称的充要条件是：对于通向左子树 $T_{\\text{L}}$ 中节点 $u$ 的每一条路径 $p$，在右子树 $T_{\\text{R}}$ 中都存在一个位于路径 $\\phi(p)$ 的节点 $v$，使得存储在 $u$ 处的值等于存储在 $v$ 处的值，反之亦然，并且所有这样的对应关系在每一层深度都成立。如果任意一侧缺少节点而另一侧存在节点，则该树不对称。\n\n算法的输入是一个序列，该序列以列表形式按层序（广度优先）编码树。对于索引 $i$，其左孩子位于索引 $2i+1$ 处，右孩子位于索引 $2i+2$ 处，前提是这些索引存在且父节点不为空。使用 $\\texttt{None}$ 表示节点的缺失。例如，列表 $\\left[\\,1,2,2,3,4,4,3\\,\\right]$ 编码了一个高度为 $3$ 的完美对称树。列表 $\\left[\\,1,2,2,\\texttt{None},3,\\texttt{None},3\\,\\right]$ 编码了一个不对称的树，因为其镜像位置的节点并非都存在或值不匹配。\n\n您的任务是：\n- 实现一个过程，该过程在给定这样一个层序列表的情况下，构建相应的二叉树（需处理表示节点缺失的标记 $\\texttt{None}$），然后基于上述定义判断该树是否围绕其根对称。\n- 该判断必须基于二叉树的递归结构和镜像路径映射 $\\phi$；不允许使用任何捷径或预打包的对称性检查函数。\n\n您的程序应评估以下测试套件。每个测试用例都是一个使用 $\\texttt{None}$ 表示缺失节点的层序列表：\n- 测试 $1$：$\\left[\\,\\,\\right]$ (空树)。\n- 测试 $2$：$\\left[\\,1\\,\\right]$。\n- 测试 $3$：$\\left[\\,1,2,2,3,4,4,3\\,\\right]$。\n- 测试 $4$：$\\left[\\,1,2,2,\\texttt{None},3,\\texttt{None},3\\,\\right]$。\n- 测试 $5$：$\\left[\\,1,2,2,3,\\texttt{None},\\texttt{None},4\\,\\right]$。\n- 测试 $6$：$\\left[\\,1,2,2,3,4,4,3,\\texttt{None},\\texttt{None},5,6,6,5,\\texttt{None},\\texttt{None}\\,\\right]$。\n- 测试 $7$：$\\left[\\,1,\\texttt{None},2\\,\\right]$。\n\n对于每个测试用例，要求的输出是一个布尔值，指示该树是否围绕其根对称。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，例如 $\\left[\\,\\texttt{True},\\texttt{False}\\,\\right]$。最终输出不得有空格，格式必须严格为：“[result1,result2,...]”。", "solution": "问题陈述经评估有效。这是一个在数据结构与算法领域内定义明确、具有科学依据的问题，包含了得出唯一解所需的所有必要信息和定义。\n\n任务是判断一个以层序列表格式提供的二叉树是否围绕其根对称。解决方案在逻辑上分解为两个主要阶段：首先，从其列表表示中重建树的数据结构；其次，根据所提供的基于递归和路径的定义来验证其对称性。\n\n首先，我们处理从层序列表构建二叉树的问题。二叉树节点是一个基本结构，包含一个值以及指向其左右孩子的指针，而左右孩子本身也是二叉树。我们可以为此目的定义一个 `TreeNode` 类。输入列表以广度优先的方式表示树，其中对于索引为 $i$ 的父节点，其左孩子位于索引 $2i+1$ 处，右孩子位于索引 $2i+2$ 处。值 $\\texttt{None}$ 表示节点缺失。\n\n构建算法如下：\n$1$. 如果输入列表为空，则树为空，我们返回 $\\texttt{None}$。\n$2$. 否则，索引 0 处的元素是树的根。为其创建一个 `TreeNode`。\n$3$. 初始化一个队列，并将根节点加入队列。该队列将用于存放需要分配子节点的父节点。\n$4$. 初始化一个计数器（例如 $j$）为 $1$，用于遍历输入列表以获取子节点的值。\n$5$. 当队列不为空且索引 $j$ 在列表范围内时，我们从队列中取出一个父节点。\n$6$. 索引 $j$ 处的值对应左孩子。如果此值不为 $\\texttt{None}$，则创建一个新的 `TreeNode` 并将其赋为父节点的左孩子，然后将此新节点入队。索引 $j$ 递增。\n$7$. 新索引 $j$ 处的值对应右孩子。如果此值不为 $\\texttt{None}$，则创建一个新的 `TreeNode`，将其赋为父节点的右孩子，并将其入队。索引 $j$ 再次递增。\n$8$. 此过程持续进行，直到列表中的所有节点都已处理完毕，从而正确地重建树结构。\n\n其次，我们处理对称性的验证。问题定义一棵根为 $r$ 的树 $T$ 是对称的，条件是对于其左子树 $T_{\\text{L}}$ 中的每条路径 $p$，在右子树 $T_{\\text{R}}$ 中都存在一个值相等的节点位于镜像路径 $\\phi(p)$ 处，反之亦然。镜像函数 $\\phi$ 在路径序列中交换 $\\text{L}$ 和 $\\text{R}$。\n\n这个形式化定义很自然地导出一个优雅的递归解法。一棵树是对称的，当且仅当其左右子树互为镜像。我们可以定义一个递归辅助函数，称之为 `areMirrors(node1, node2)`，用以判断以 `node1` 和 `node2` 为根的两棵树是否互为镜像。该函数由以下条件定义：\n\n$1$. **基本情况 1**：如果 `node1` 和 `node2` 均为空（即 $\\texttt{None}$），那么它们互为平凡镜像。函数返回 `True`。这对应于路径在两个子树中同时终止的情况。\n$2$. **基本情况 2**：如果 `node1` 或 `node2` 中恰好有一个为空而另一个不为空，则它们不可能是镜像。函数返回 `False`。这对应于这样的条件：如果一侧的给定路径上存在节点，则其对应节点必须在另一侧的镜像路径上存在。\n$3$. **递归步骤**：如果两个节点均不为空，它们互为镜像的充要条件是满足以下三个条件：\n    a. 它们根节点的值必须相等：`node1.value == node2.value`。\n    b. `node1` 的左子树必须是 `node2` 的右子树的镜像。这通过递归调用 `areMirrors(node1.left, node2.right)` 来检查。\n    c. `node1` 的右子树必须是 `node2` 的左子树的镜像。这通过递归调用 `areMirrors(node1.right, node2.left)` 来检查。\n\n这种递归结构直接实现了路径映射的要求。初始调用 `areMirrors(root.left, root.right)` 比较了从根出发的路径 $\\text{L}$ 与路径 $\\phi(\\text{L}) = \\text{R}$。随后的递归调用，例如 `areMirrors(node1.left, node2.right)`，实际上是在比较原始树左子树中类似 $\\text{L}p$（以 $\\text{L}$ 开头的路径）的路径与原始树右子树中类似 $\\text{R}\\phi(p)$（以 $\\text{R}$ 开头，后跟 $p$ 的镜像）的路径，从而确保在每一层级上的结构和值的对应关系。主函数 `isSymmetric(root)` 仅处理空树（它是对称的）的情况，否则通过 `areMirrors(root.left, root.right)` 对其两个主子树启动递归检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TreeNode:\n    \"\"\"\n    Represents a node in a binary tree.\n    \"\"\"\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(level_order_list):\n    \"\"\"\n    Constructs a binary tree from a level-order list representation.\n    None indicates an absent node.\n    \"\"\"\n    if not level_order_list:\n        return None\n\n    root = TreeNode(level_order_list[0])\n    queue = [root]\n    i = 1\n    while queue and i  len(level_order_list):\n        current_node = queue.pop(0)\n\n        if i  len(level_order_list) and level_order_list[i] is not None:\n            current_node.left = TreeNode(level_order_list[i])\n            queue.append(current_node.left)\n        i += 1\n\n        if i  len(level_order_list) and level_order_list[i] is not None:\n            current_node.right = TreeNode(level_order_list[i])\n            queue.append(current_node.right)\n        i += 1\n\n    return root\n\ndef are_mirrors(node1, node2):\n    \"\"\"\n    Recursively checks if two trees are mirror images of each other.\n    \"\"\"\n    # Base case: both are null, they are mirrors.\n    if not node1 and not node2:\n        return True\n    \n    # Base case: one is null but the other isn't, not mirrors.\n    if not node1 or not node2:\n        return False\n    \n    # Recursive step: check values and mirrored subtrees.\n    return (node1.val == node2.val and\n            are_mirrors(node1.left, node2.right) and\n            are_mirrors(node1.right, node2.left))\n\ndef is_symmetric(root):\n    \"\"\"\n    Determines if a binary tree is symmetric around its root.\n    \"\"\"\n    # An empty tree is symmetric.\n    if not root:\n        return True\n    # A tree is symmetric if its left and right subtrees are mirror images.\n    return are_mirrors(root.left, root.right)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [1],\n        [1, 2, 2, 3, 4, 4, 3],\n        [1, 2, 2, None, 3, None, 3],\n        [1, 2, 2, 3, None, None, 4],\n        [1, 2, 2, 3, 4, 4, 3, None, None, 5, 6, 6, 5, None, None],\n        [1, None, 2]\n    ]\n\n    results = []\n    for case in test_cases:\n        # Build the tree from the list representation.\n        root = build_tree(case)\n        # Check for symmetry and store the boolean result.\n        result = is_symmetric(root)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216104"}, {"introduction": "从通用的二叉树转向更专业的二叉搜索树（BST），我们将探索其排序属性如何催生出高效算法。这个练习要求你在给定一棵BST和两个节点的情况下，找到它们的最低公共祖先（LCA）。挑战在于，你需要利用BST的有序性设计一个时间复杂度为 $O(h)$、额外空间复杂度仅为 $O(1)$ 的迭代算法，从而直观地感受BST属性带来的巨大优势。[@problem_id:3216153]", "problem": "你的任务是在严格的额外空间限制下，计算二叉搜索树（BST）中两个节点的最低公共祖先（LCA）。\n\n我们从基本定义开始：二叉搜索树（BST）是一种有根二叉树，其中每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。对于有根树中的节点 $u$ 和 $v$，如果节点 $w$ 位于从根到 $u$ 的唯一简单路径上，则 $w$ 是 $u$ 的一个祖先。$u$ 和 $v$ 的最低公共祖先（LCA）是唯一的节点 $w$，该节点既是 $u$ 的祖先也是 $v$ 的祖先，并且其所有后代都不是 $u$ 和 $v$ 的公共祖先。\n\n你的任务是实现一个算法，给定一棵二叉搜索树和两个目标键 $p$ 和 $q$，如果这两个键都存在于树中，则返回它们LCA的键；否则，返回 $-1$。用于确定LCA的算法必须仅使用 $O(1)$ 的额外空间运行，这意味着它不能使用递归或任何随输入大小扩展的辅助数据结构。存储树本身所需的内存不计入此额外空间限制。\n\nBST的构建：对于每个测试用例，必须按照给定的顺序插入不同的整数键来构建BST，并遵循标准的BST插入规则：小于节点键的键 $x$ 插入到左子节点，大于节点键的键 $x$ 插入到右子节点。\n\n存在性要求：如果键 $p$ 或 $q$ 中有任意一个不存在于BST中，你必须为该测试用例返回 $-1$。\n\n返回值：对于每个测试用例，返回一个整数：如果两个键都存在，则返回LCA的键，否则返回 $-1$。\n\n你必须实现一个完整的、可运行的程序，该程序硬编码以下测试套件，按所述构建每个BST，并为每个测试用例计算所需的结果：\n- 测试用例 $1$：插入顺序 $[20,10,30,5,15,25,35]$，查询 $(p,q)=(5,15)$。\n- 测试用例 $2$：插入顺序 $[20,10,30,5,15,25,35]$，查询 $(p,q)=(5,35)$。\n- 测试用例 $3$：插入顺序 $[20,10,30,5,15,25,35]$，查询 $(p,q)=(30,35)$。\n- 测试用例 $4$：插入顺序 $[8,3,10,1,6,14,4,7,13]$，查询 $(p,q)=(2,7)$。\n- 测试用例 $5$：插入顺序 $[1,2,3,4,5]$，查询 $(p,q)=(2,5)$。\n- 测试用例 $6$：插入顺序 $[5,4,3,2,1]$，查询 $(p,q)=(1,3)$。\n- 测试用例 $7$：插入顺序 $[42]$，查询 $(p,q)=(42,42)$。\n- 测试用例 $8$：插入顺序 $[42]$，查询 $(p,q)=(42,7)$。\n- 测试用例 $9$：插入顺序 $[10,5,15]$，查询 $(p,q)=(100,200)$。\n\n复杂度目标：对于高度为 $h$ 的树，LCA计算应花费 $O(h)$ 时间和 $O(1)$ 额外空间。\n\n最终输出格式：你的程序应生成单行输出，其中包含九个测试用例的结果，格式为逗号分隔的列表，用方括号括起来且无空格，例如 $[r_1,r_2,\\dots,r_9]$，其中每个 $r_i$ 是如上所述的整数。\n\n无需读取任何输入。你的程序必须构建上述确切的测试套件，并以指定格式生成相应的输出。", "solution": "该问题要求我们在二叉搜索树（BST）中找到由键 $p$ 和 $q$ 标识的两个节点的最低公共祖先（LCA）。该解决方案在寻找LCA的算法部分受到 $O(1)$ 的严格空间复杂度约束。此外，算法必须首先验证键 $p$ 和 $q$ 是否都存在于树中；如果任何一个缺失，指定的返回值为 $-1$。\n\n该解决方案基于BST的基本属性开发，并为每个测试用例构建为三个逻辑阶段：BST构建、节点存在性验证和LCA计算。\n\n**1. 二叉搜索树（BST）构建**\n\n根据问题描述，对于每个测试用例，通过插入给定的不同整数键序列来构建一棵BST。BST是一种有根二叉树，对于任何键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。使用迭代插入算法来构建树。对于要插入的每个键，我们从根节点开始遍历树，如果键小于当前节点的键则向左移动，如果大于则向右移动，直到找到一个可以附加新节点的空位（一个 `None` 子指针）。\n\n**2. 节点存在性验证**\n\n一个关键的预备步骤是确认指定的两个键 $p$ 和 $q$ 确实存在于所构建的BST中。如果没有此检查，LCA算法可能会为两个甚至不在树中的键返回一个“分裂点”节点，从而导致不正确的结果。为了遵守空间复杂度约束并保持一致性，我们采用迭代搜索算法。从根开始，我们遵循BST属性遍历树。如果找到目标键，则搜索成功。如果到达一个 `None` 指针，则该键不在树中。对 $p$ 和 $q$ 都执行此搜索。如果任一搜索失败，该测试用例的处理即终止，并按要求返回值 $-1$。对于每个键，此检查花费 $O(h)$ 时间和 $O(1)$ 额外空间，其中 $h$ 是树的高度。\n\n**3. 最低公共祖先（LCA）计算**\n\n如果确认键 $p$ 和 $q$ 都存在，我们就开始寻找它们的LCA。BST的有序特性使得一个高效的迭代算法成为可能，该算法满足 $O(1)$ 的额外空间限制。其逻辑关键在于识别从根到 $p$ 和 $q$ 的路径发生分叉的节点。根据定义，这个分叉点就是LCA。\n\n设当前正在检查的节点为 `current`，初始设为树的根。设其键为 $c$。迭代过程如下：\n\n- **情况1：两个键都大于当前节点的键。** 如果 $p > c$ 且 $q > c$，这意味着两个目标节点都必须位于 `current` 节点的右子树中。因此，它们的LCA也必定在右子树中。通过将 `current` 指针更新为其右子节点来缩小搜索范围：`current = current.right`。\n\n- **情况2：两个键都小于当前节点的键。** 如果 $p  c$ 且 $q  c$，两个目标节点都在左子树中。它们的LCA也必定在左子树中。搜索从左子节点继续：`current = current.left`。\n\n- **情况3：键在当前节点处分裂。** 如果以上两个条件都不满足，这意味着 `current` 节点是从根节点出发的路径上第一个位于 $p$ 和 $q$ 之间（含 $p$ 或 $q$）的节点。这可能通过三种方式发生：\n    - $p  c$ 且 $q > c$（反之亦然），意味着到 $p$ 和 $q$ 的路径在 `current` 处分叉。\n    - $c = p$，意味着 `current` 节点是目标节点之一。由于 $q$ 存在于树中，它必然在 `current` 的一个子树中（或者 $q=p$），这使得 `current` 成为LCA。\n    - $c = q$，这与前一个子情况类似。\n\n在情况3的所有变体中，`current` 节点都是LCA。循环终止，并返回 `current` 节点的键 $c$。\n\n该算法从根向下遍历一条单一路径。该路径的长度受树的高度 $h$ 限制，因此时间复杂度为 $O(h)$。由于该算法只需要一个指针（`current`）来遍历树，其额外空间复杂度为 $O(1)$，完全满足问题的约束条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCA in a BST problem for a hardcoded suite of test cases.\n    The solution follows these steps for each case:\n    1. Constructs the BST from a list of keys.\n    2. Verifies that both query keys, p and q, exist in the tree.\n    3. If they exist, it computes their LCA using an O(1) space iterative algorithm.\n    4. If either key is missing, it returns -1.\n    5. Collects all results and prints them in the specified format.\n    \"\"\"\n\n    class Node:\n        \"\"\"Represents a node in a Binary Search Tree.\"\"\"\n        def __init__(self, key):\n            self.key = int(key)\n            self.left = None\n            self.right = None\n\n    def build_bst(keys):\n        \"\"\"Constructs a BST by iteratively inserting keys.\"\"\"\n        if not keys:\n            return None\n        \n        root = Node(keys[0])\n        for key in keys[1:]:\n            current = root\n            while True:\n                if key  current.key:\n                    if current.left is None:\n                        current.left = Node(key)\n                        break\n                    else:\n                        current = current.left\n                elif key > current.key:\n                    if current.right is None:\n                        current.right = Node(key)\n                        break\n                    else:\n                        current = current.right\n        return root\n\n    def search_bst(root, key):\n        \"\"\"Iteratively searches for a key in the BST. O(1) space.\"\"\"\n        current = root\n        while current is not None:\n            if key == current.key:\n                return True\n            elif key  current.key:\n                current = current.left\n            else:\n                current = current.right\n        return False\n\n    def find_lca(root, p, q):\n        \"\"\"\n        Iteratively finds the LCA of two keys p and q in a BST. O(1) space.\n        This function assumes both p and q are present in the BST.\n        \"\"\"\n        current = root\n        while current is not None:\n            # If both p and q are greater than current node's key, LCA is in the right subtree\n            if p > current.key and q > current.key:\n                current = current.right\n            # If both p and q are smaller than current node's key, LCA is in the left subtree\n            elif p  current.key and q  current.key:\n                current = current.left\n            # Otherwise, this is the split point, so this node is the LCA.\n            # This covers cases where one key is on one side and the other is on the other,\n            # or when one of the keys is the current node.\n            else:\n                return current.key\n        return -1 # Should not be reached given presence check\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (5, 15)},\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (5, 35)},\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (30, 35)},\n        {'keys': [8, 3, 10, 1, 6, 14, 4, 7, 13], 'pq': (2, 7)},\n        {'keys': [1, 2, 3, 4, 5], 'pq': (2, 5)},\n        {'keys': [5, 4, 3, 2, 1], 'pq': (1, 3)},\n        {'keys': [42], 'pq': (42, 42)},\n        {'keys': [42], 'pq': (42, 7)},\n        {'keys': [10, 5, 15], 'pq': (100, 200)},\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        p, q = case['pq']\n        \n        # 1. Construct the BST\n        root = build_bst(keys)\n        \n        # 2. Verify presence of both p and q\n        p_found = search_bst(root, p)\n        q_found = search_bst(root, q)\n        \n        if p_found and q_found:\n            # 3. If present, find the LCA\n            lca_key = find_lca(root, p, q)\n            results.append(lca_key)\n        else:\n            # 4. If either is not present, return -1\n            results.append(-1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216153"}, {"introduction": "在前一个练习的基础上，我们来挑战一个更复杂的BST问题：在一个BST中寻找键值之和等于特定目标值的两个节点。虽然将树转换为有序数组可以简化问题，但真正的挑战在于满足严格的空间复杂度限制。这个实践将引导你设计一种精妙的算法，通过在树结构上直接使用两个同步的状态迭代器（一个正向，一个反向）来模拟经典的双指针法，从而在有限的空间内解决问题。[@problem_id:3216226]", "problem": "给定一个存储整数键的有限有根二叉搜索树 (BST)，其中二叉搜索树 (BST) 的定义为：对于每个键为 $k$ 的节点，其左子树中的键严格小于 $k$，其右子树中的键大于或等于 $k$。键可能包含重复值。设 $X$ 为一个目标整数。任务是设计并实现一个程序，判断是否存在两个不同的节点，其键之和为 $X$，如果存在，则返回这样的一对键。如果存在多个有效的键对，任何一对都是可接受的。如果不存在这样的键对，则返回一个空列表。\n\n你的推导和设计必须从以下基本原则出发：\n- 上述定义的二叉搜索树 (BST) 的排序属性。\n- 一个经过充分检验的事实：对二叉搜索树 (BST) 进行中序遍历会得到一个非递减的键序列，而逆中序遍历会得到一个非递增的键序列。\n\n算法的约束条件：\n- 对于一个有 $n$ 个节点的树，算法必须在 $\\mathcal{O}(n)$ 时间内运行。\n- 算法最多使用 $\\mathcal{O}(h)$ 的额外内存，其中 $h$ 是树的高度，并且不得将整棵树或其遍历结果物化为数组或列表。\n- 用于求和的两个节点必须是不同的；同一个节点不能使用两次来求和得到 $X$（即使对于某个键 $k$ 有 $2 \\cdot k = X$）。\n\n你的程序应按照给定顺序插入键来构建二叉搜索树 (BST)，插入规则是，与节点键相等的键被插入到右子树。对于每个测试用例，返回结果为以下两种形式之一：\n- 一个包含两个整数的列表 $[a,b]$，表示一个有效键对的键，满足 $a + b = X$ 且对应树中的两个不同节点，或\n- 一个空列表 $[]$，如果不存在这样的键对。\n\n测试套件（每个测试用例由一个插入序列和一个目标 $X$ 组成）：\n- 用例 $1$：插入序列 $\\langle 8,3,10,1,6,14,4,7,13\\rangle$，目标 $X = 17$。\n- 用例 $2$：插入序列 $\\langle -10,-3,0,5,9\\rangle$，目标 $X = -13$。\n- 用例 $3$：插入序列 $\\langle 5,5,3,7\\rangle$（存在重复值），目标 $X = 10$。\n- 用例 $4$：插入序列 $\\langle 2,1,4\\rangle$，目标 $X = 8$。\n- 用例 $5$：插入序列 $\\langle 42\\rangle$，目标 $X = 84$。\n- 用例 $6$：插入序列 $\\langle 1,2,3,4,5\\rangle$（退化的右倾树），目标 $X = 6$。\n- 用例 $7$：插入序列 $\\langle 5,3,7\\rangle$，目标 $X = 10$（测试当键的实例只有一个时，禁止使用同一节点两次的规则）。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含所有测试用例的结果，结果形式为一个逗号分隔的列表，并用方括号括起来。每个结果本身必须是一个不带空格的方括号列表。例如，三个测试用例的有效输出可能看起来像 $[[a,b],[],[c,d]]$。你的程序不得读取任何输入，并且必须按所列顺序使用上述测试套件。所有数值必须以十进制数字打印，不带额外空格。", "solution": "所述问题是有效的。这是一个在数据结构领域内定义明确的算法挑战，它基于计算机科学的既定原则。问题本身是自包含的、无歧义的，其约束条件虽然严格但可以解决。因此，我们可以进行解法的形式化推导。\n\n问题要求设计一个算法，在一个给定的二叉搜索树（BST）中寻找是否存在两个不同节点，其键之和等于目标值 $X$。该算法必须在 $\\mathcal{O}(n)$ 时间和 $\\mathcal{O}(h)$ 辅助空间内运行，其中 $n$ 是节点数，$h$ 是树的高度。该 BST 对重复键遵循一个特定的插入规则：如果键 $k$ 大于或等于节点 $k'$ 的键，则 $k$ 被插入到右子树。\n\n**1. 基本原则：BST 遍历与有序序列**\n\n构建此解法的基础是 BST 与有序数据之间的关系。问题陈述已正确提供了这一基础：\n- 对 BST 进行中序遍历（左子树、根、右子树）会得到一个非递减排序的键序列。\n- 对 BST 进行逆中序遍历（右子树、根、左子树）会得到一个非递增排序的键序列。\n\n设中序遍历得到的键序列为 $S_{asc} = \\langle k_1, k_2, \\dots, k_n \\rangle$，其中 $k_i \\leq k_{i+1}$。我们的任务等价于找到两个对应不同节点的索引 $i$ 和 $j$，使得 $k_i + k_j = X$。\n\n**2. 有序数组上的双指针法**\n\n如果允许使用 $\\mathcal{O}(n)$ 的空间，一个直接的解法是：\n1. 对 BST 进行中序遍历，并将所有 $n$ 个节点的键存储在一个数组中。该数组将是非递减排序的。\n2. 使用“双指针”技术。初始化一个指针 `low` 指向数组的开头，一个指针 `high` 指向数组的末尾。\n3. 当 `low` 小于 `high` 时循环：\n    - 设当前和为 $S = \\text{array}[\\text{low}] + \\text{array}[\\text{high}]$。\n    - 如果 $S = X$，则找到一个键对。\n    - 如果 $S  X$，和太小。为了增大它，我们必须选择一个更大的值，因此递增 `low`。\n    - 如果 $S > X$，和太大。为了减小它，我们必须选择一个更小的值，因此递减 `high`。\n\n这种方法的时间复杂度为：遍历 $\\mathcal{O}(n)$，双指针扫描 $\\mathcal{O}(n)$，总计 $\\mathcal{O}(n)$。然而，它需要 $\\mathcal{O}(n)$ 的空间来存储数组，这违反了 $\\mathcal{O}(h)$ 的空间约束。\n\n**3. $\\mathcal{O}(h)$ 空间算法的推导**\n\n为了满足 $\\mathcal{O}(h)$ 的空间约束，我们必须避免将整个键序列物化。核心思想是直接在 BST 结构上模拟双指针法。我们需要一种机制来按需获取“下一个”最小的键和“下一个”最大的键，而无需一次性处理整棵树。\n\n这一需求引出了两个有状态迭代器的设计：\n- 一个**中序迭代器**，每次请求时，它会产生非递减键序列中的下一个节点。\n- 一个**逆中序迭代器**，每次请求时，它会产生非递增键序列中的下一个节点。\n\nBST 的迭代式遍历可以用一个栈来实现。对于中序遍历，我们重复将左子节点推入栈中。当需要下一个项时，我们弹出一个节点，访问它，然后通过将其右子树的左子链推入栈来处理其右子树。这个栈的最大深度对应于从根到叶子的最长路径，即树的高度 $h$。因此，一个基于栈的迭代器使用 $\\mathcal{O}(h)$ 空间。同样的原理适用于逆中序迭代器，它会优先推送右子节点。\n\n通过同时使用这两个迭代器，一个用于升序序列，一个用于降序序列，我们可以在遵守 $\\mathcal{O}(h)$ 空间限制的同时，完美地模拟双指针方法。\n\n**4. 算法设计与实现**\n\n算法流程如下：\n\n1.  **节点表示**：定义一个 `TreeNode` 类，包含一个整数键以及对左右子节点的引用。`TreeNode` 对象的同一性将被用来满足“不同节点”的约束。\n\n2.  **迭代器实现**：\n    - `InOrderIterator`：\n        - 维护一个栈。\n        - 用根节点初始化时，它会沿着树的左侧路径向下遍历，将每个节点推入栈中。这使得迭代器准备好返回具有最小键的节点。\n        - `next()` 方法从栈中弹出一个节点（下一个中序节点），然后通过遍历弹出节点的右子节点的左侧路径，为下一次调用做准备。\n    - `ReverseInOrderIterator`：\n        - 与 `InOrderIterator` 对称操作。\n        - 初始化时，它会沿着右侧路径向下遍历，推送节点，为产生最大键做准备。\n        - 它的 `next()` 方法弹出一个节点，然后通过遍历弹出节点的左子节点的右侧路径进行准备。\n\n3.  **主控制循环**：\n    - 用 BST 的根节点初始化一个 `InOrderIterator` 实例和一个 `ReverseInOrderIterator` 实例。\n    - 从每个迭代器获取第一个节点：`node_asc`（最小的）和 `node_desc`（最大的）。\n    - 进入一个循环，只要两个迭代器都能提供节点，并且它们指向的不是同一个对象（`node_asc is not node_desc`），循环就继续。这个条件对于正确性至关重要，确保我们只考虑不同节点的对。\n    - 在循环内部：\n        a. 计算键的和：$S = \\text{node\\_asc.key} + \\text{node\\_desc.key}$。\n        b. 如果 $S = X$，我们找到了一个有效的键对。返回它们的键，例如 $[\\text{node\\_asc.key}, \\text{node\\_desc.key}]$。\n        c. 如果 $S  X$，我们需要一个更大的和。我们推进中序迭代器以获取下一个最小的键：`node_asc = iter_asc.next()`。\n        d. 如果 $S > X$，我们需要一个更小的和。我们推进逆中序迭代器以获取下一个最大的键：`node_desc = iter_desc.next()`。\n    - 如果循环在没有找到键对的情况下终止（因为迭代器已经交错或在同一节点相遇），则不存在这样的键对。返回一个空列表。\n\n**5. 复杂度分析**\n\n- **时间复杂度**：每个迭代器遍历 BST 的边。在主循环的每一步中，两个迭代器中恰好有一个被推进。由于迭代器从有序序列的两端开始并向彼此移动，树中的每个节点最多被一个前进的迭代器访问一次。在整个遍历过程中，`next()` 方法内部完成的工作均摊到每个节点上是常数时间。因此，总时间复杂度为 $\\mathcal{O}(n)$。\n\n- **空间复杂度**：该算法使用两个栈，每个迭代器一个。每个栈的最大大小受限于树的高度 $h$。因此，所需的总辅助空间为 $\\mathcal{O}(h) + \\mathcal{O}(h) = \\mathcal{O}(h)$。在一个平衡的 BST 中，$h = \\mathcal{O}(\\log n)$，而在一个退化（倾斜）的树中，$h = \\mathcal{O}(n)$。空间复杂度正确地遵守了指定的约束。\n\n这个设计满足了所有问题要求，提供了一个在给定约束条件下既正确又高效的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TreeNode:\n    \"\"\"\n    A node in a Binary Search Tree.\n    \"\"\"\n    def __init__(self, key):\n        self.key = int(key)\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return f\"TreeNode({self.key})\"\n\nclass BST:\n    \"\"\"\n    Binary Search Tree implementation with a specific insertion rule for duplicates.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Inserts a key into the BST. If the key is >= a node's key, it goes to the right.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n    \n    def _insert_recursive(self, node, key):\n        if key  node.key:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:  # key >= node.key\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n\n    @staticmethod\n    def from_sequence(sequence):\n        \"\"\"\n        Builds a BST from a sequence of keys.\n        \"\"\"\n        tree = BST()\n        for key in sequence:\n            tree.insert(key)\n        return tree.root\n\nclass InOrderIterator:\n    \"\"\"\n    An iterator that yields BST nodes in non-decreasing order of keys (in-order).\n    Uses O(h) space, where h is the tree height.\n    \"\"\"\n    def __init__(self, root):\n        self.stack = []\n        self._push_left_path(root)\n\n    def _push_left_path(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self):\n        if not self.stack:\n            return None\n        node = self.stack.pop()\n        if node.right:\n            self._push_left_path(node.right)\n        return node\n\nclass ReverseInOrderIterator:\n    \"\"\"\n    An iterator that yields BST nodes in non-increasing order of keys (reverse in-order).\n    Uses O(h) space, where h is the tree height.\n    \"\"\"\n    def __init__(self, root):\n        self.stack = []\n        self._push_right_path(root)\n\n    def _push_right_path(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.right\n\n    def next(self):\n        if not self.stack:\n            return None\n        node = self.stack.pop()\n        if node.left:\n            self._push_right_path(node.left)\n        return node\n\ndef find_two_sum_pair(root, target):\n    \"\"\"\n    Finds a pair of distinct nodes in a BST that sum to a target value.\n    \n    Args:\n        root: The root of the BST.\n        target: The target integer sum.\n\n    Returns:\n        A list [a, b] with the keys of the two nodes if found, otherwise an empty list.\n    \"\"\"\n    if not root:\n        return []\n\n    iter_asc = InOrderIterator(root)\n    iter_desc = ReverseInOrderIterator(root)\n\n    node_asc = iter_asc.next()\n    node_desc = iter_desc.next()\n\n    while node_asc and node_desc and node_asc is not node_desc:\n        current_sum = node_asc.key + node_desc.key\n        \n        if current_sum == target:\n            return [node_asc.key, node_desc.key]\n        elif current_sum  target:\n            node_asc = iter_asc.next()\n        else: # current_sum > target\n            node_desc = iter_desc.next()\n            \n    return []\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        ( (8, 3, 10, 1, 6, 14, 4, 7, 13), 17 ),\n        # Case 2\n        ( (-10, -3, 0, 5, 9), -13 ),\n        # Case 3\n        ( (5, 5, 3, 7), 10 ),\n        # Case 4\n        ( (2, 1, 4), 8 ),\n        # Case 5\n        ( (42,), 84 ),\n        # Case 6\n        ( (1, 2, 3, 4, 5), 6 ),\n        # Case 7\n        ( (5, 3, 7), 10 ),\n    ]\n\n    results = []\n    for sequence, target in test_cases:\n        root = BST.from_sequence(sequence)\n        result = find_two_sum_pair(root, target)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[3,14],[-10,-3],[3,7],[],[],[1,5],[3,7]]\n    # str(list) adds spaces, so we remove them.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3216226"}]}