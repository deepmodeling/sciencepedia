{"hands_on_practices": [{"introduction": "掌握任何复杂系统的第一步都是理解其规则。本练习让你扮演“规则检查员”的角色，通过从第一性原理出发，为红黑树编写一个验证器。实现这个过程将迫使你精确理解每一条红黑树不变量，这是进行更复杂操作（如插入、删除或修改）的绝对前提。[@problem_id:3269583]", "problem": "设计并实现一个验证器，用于判断给定的带颜色二叉搜索树是否为有效的红黑树 (RBT)，其时间复杂度为 $O(N)$，其中 $N$ 是从指定根节点可达的节点数。该验证器必须从第一性原理出发，仅从核心定义开始推导，并且必须对所有有限树都正确。\n\n红黑树 (RBT) 是一种二叉搜索树 (BST)，其每个内部节点都带有一种颜色，并满足以下从搜索树的基本定义和平衡黑高概念派生出的不变量：\n- 二叉搜索树 (BST) 属性：对于每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。假设键为整数且严格有序。\n- 根颜色属性：根节点（如果存在）为黑色。\n- 红色属性（无红-红边）：红色节点不能有红色的子节点。\n- 黑高属性：对于每个节点，从该节点到其任何后代空叶子节点的任意简单路径上，黑色节点的数量都相同。空子节点（叶子）本身不计入此数。\n- 按照惯例，空树被认为是黑高为 $0$ 的有效红黑树。\n\n程序内部要使用的输入模型（不应读取外部输入）：一个带颜色的 BST 表示为一个序对 $(\\text{nodes}, \\text{root})$，其中：\n- $\\text{nodes}$ 是一个从 $0$ 到 $n-1$ 索引的数组，每个条目是一个记录 $(\\text{key}, \\text{color}, \\text{left}, \\text{right})$。\n- $\\text{key}$ 是一个整数键。\n- $\\text{color}$ 是一个字符，'B'（黑色）或 'R'（红色）。\n- $\\text{left}$ 和 $\\text{right}$ 是子节点的索引，范围在 $\\{0,\\dots,n-1\\}$，或为 $-1$ 表示空子节点。\n- $\\text{root}$ 是根节点的索引，范围在 $\\{0,\\dots,n-1\\}$，或为 $-1$ 表示空树。\n- 只有从 $\\text{root}$ 可达的节点在语义上是树的一部分；可能存在不可达的节点，但验证器必须忽略它们。\n\n任务要求：\n- 推导并实现一个验证算法，该算法仅使用前面的定义，通过执行单次深度优先遍历，同时强制执行 BST 排序约束、红色属性和黑高相等性，在 $O(N)$ 时间和 $O(H)$ 额外空间内检查所有 RBT 不变量，其中 $H$ 是树的高度。\n- 程序应硬编码并评估以下参数值测试套件，每个都是一个独立的 $(\\text{nodes}, \\text{root})$ 实例。对于每种情况，返回一个布尔值，指示该实例是否为有效的 RBT。\n\n要嵌入程序中的测试套件：\n\n- 情况 1 (有效的 RBT，非平凡)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, 4), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 2 (右子树违反 BST 排序)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, 4), (9, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 3 (孤立的红-红冲突，所有其他不变量包括相等的黑高都满足)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, -1), (15, 'R', -1, -1), (2, 'R', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 4 (黑高不匹配，无红-红冲突)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', -1, -1), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 5 (根节点非黑色，其他不变量满足)：\n  - $\\text{nodes} = [ (10, 'R', 1, 2), (5, 'B', 3, 4), (15, 'B', -1, -1), (2, 'R', -1, -1), (7, 'R', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 6 (单节点黑树)：\n  - $\\text{nodes} = [ (42, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 7 (空树)：\n  - $\\text{nodes} = [\\ ]$\n  - $\\text{root} = -1$\n\n输出格式：\n- 你的程序应生成一行输出，其中包含一个逗号分隔的布尔值列表，用方括号括起来，并严格按照测试用例的顺序，例如 $[ \\text{True}, \\text{False}, \\dots ]$。\n\n不允许用户输入或外部文件。所有计算都是无单位的，纯粹是组合性的；不适用任何物理单位。不使用角度。不出现百分比。每种情况的答案必须是布尔值。", "solution": "该问题要求设计并实现一个红黑树 (RBT) 的验证器。验证器必须在 $O(N)$ 时间和 $O(H)$ 辅助空间内判断给定的带颜色二叉搜索树是否为有效的 RBT，其中 $N$ 是从根可达的节点数，H 是树的高度。推导过程必须从第一性原理出发。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n问题为有效的红黑树提供了以下定义和约束：\n1.  **二叉搜索树 (BST) 属性**：对于每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。\n2.  **根颜色属性**：根节点（如果存在）为黑色 ($'B'$)。\n3.  **红色属性（无红-红边）**：红色 ($'R'$) 节点不能有红色的子节点。\n4.  **黑高属性**：对于每个节点，从该节点到其任何后代空叶子节点的任意简单路径上，黑色节点的数量都相同。空子节点（叶子）本身不计入此数。\n5.  **空树**：空树是有效的 RBT，黑高为 $0$。\n\n输入是一个序对 $(\\text{nodes}, \\text{root})$，其中 $\\text{nodes}$ 是一个节点记录 $(\\text{key}, \\text{color}, \\text{left}, \\text{right})$ 的数组，而 root 是根节点的索引。根索引为 $-1$ 表示空树。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n根据所需标准评估问题陈述：\n-   **科学性**：该问题基于红黑树的正式定义，这是计算机科学中的一个经典数据结构。所列出的属性是 RBT 的标准、普遍接受的不变量。该问题在科学上是合理的。\n-   **良构性**：问题定义清晰。输入格式已指定，期望的输出是一个布尔决策。时间和空间复杂度的约束（$O(N)$ 和 $O(H)$）是具体且可实现的。对于任何给定的输入，都存在唯一、正确的答案。\n-   **客观性**：问题使用正式、客观的定义进行陈述，避免了任何主观或模糊的语言。\n\n该问题不存在任何使其无效的缺陷。它是一个在算法和数据结构领域内定义明确的正式问题。\n\n**第 3 步：结论与行动**\n\n问题是**有效的**。将开发并实现一个解决方案。\n\n### 验证算法的推导\n\n目标是在单次遍历中同时验证所有 RBT 属性，以达到 $O(N)$ 的时间复杂度。对树进行递归的深度优先遍历是自然的方法。我们将设计一个递归辅助函数，该函数遍历树并沿途验证属性。\n\n设递归辅助函数为 `validate_subtree(node_idx, parent_color, min_bound, max_bound)`。该函数将分析以索引 `node_idx` 为根的子树，并返回一个序对 `(is_valid, black_height)`，其中 `is_valid` 是一个布尔值，指示该子树是否满足 RBT 属性（给定其祖先的上下文），而 `black_height` 是从 `node_idx` 到任一后代空叶子节点的任何路径上的黑节点计数，不包括空叶子。\n\n**1. 基本情况：空节点**\n\n空节点由索引 $-1$ 表示。根据**黑高属性**的定义，空叶子不计入黑高。因此，从一个空节点出发到叶子的路径长度为 $0$。一个空子树显然满足所有其他属性。\n-   `validate_subtree(-1, ...)` 返回 `(True, 0)`。\n\n**2. 递归步骤：内部节点**\n\n对于索引为 `node_idx` 的内部节点，我们必须验证所有属性。\n\n-   **不可达节点**：遍历从指定的 `root` 开始，只跟随有效的子节点索引。`nodes` 数组中任何从 `root` 不可达的节点都永远不会被访问，从而根据问题规范正确地忽略它们。\n\n-   **红色属性**：该属性规定红色节点不能有红色子节点。要检查这一点，递归函数必须知道父节点的颜色。参数 `parent_color` 即为此目的。在当前颜色为 `current_color` 的节点处，我们检查 `current_color == 'R'` 和 `parent_color == 'R'` 是否成立。如果满足此条件，则该属性被违反。\n\n-   **BST 属性**：为确保树是有效的二叉搜索树，每个节点的键必须位于其祖先定义的特定范围内。根节点可以有任何键。对于任何其他节点，其键必须大于其左链祖先的键，且小于其右链祖先的键。我们通过向下传递一个有效范围 `(min_bound, max_bound)` 来强制执行此规则。对于一个键为 $k$ 的节点，其左子树中的所有键必须在范围 `(min_bound, k)` 内，其右子树中的所有键必须在范围 `(k, max_bound)` 内。\n\n-   **黑高属性**：该属性规定，对于任何节点 $n$，从 $n$ 到任何后代空叶子节点的简单路径上的黑节点数是恒定的。设此数为 $BH(n)$。如果节点 $n$ 有子节点 $n_l$ 和 $n_r$，则从 $n$ 出发的任何路径都必须经过 $n_l$ 或 $n_r$。为了使黑节点的总数恒定，必须有 $BH(n_l) = BH(n_r)$。我们的递归函数返回它所验证的子树的黑高。因此，在对左右子节点进行递归调用并返回 `(is_left_valid, left_bh)` 和 `(is_right_valid, right_bh)` 之后，我们必须检查 `left_bh == right_bh` 是否成立。如果它们不相等，则该属性被违反。\n\n-   **计算黑高**：如果子节点的属性都满足，则当前节点子树的黑高 $BH(\\text{node})$ 是根据其子节点（现已验证相等）的黑高 $BH(\\text{child})$ 和其自身颜色计算的。从当前节点开始的路径上的黑节点计数是其自身的贡献（如果是黑色则为 $1$，红色则为 $0$）加上其子节点的计数。因此，$BH(\\text{node}) = BH(\\text{child}) + (\\text{1 if node is black else 0})$。\n\n**3. 主验证函数**\n\n主函数 `is_valid_rbt(nodes, root)` 协调整个验证过程。\n\n1.  **空树**：如果 `root` 为 $-1$，则树为空。根据定义，这是一个有效的 RBT。返回 `True`。\n2.  **根颜色属性**：如果树不为空，则根节点必须为黑色。我们获取根节点的数据并检查其颜色。如果为红色，则树无效。返回 `False`。\n3.  **启动遍历**：遍历从根节点开始。根节点没有父节点，因此我们可以将其父节点视为“黑色”，以确保 `红色属性` 检查不会错误地失败。初始键范围是无界的，表示为 $(-\\infty, +\\infty)$。\n4.  **最终裁决**：主函数调用 `validate_subtree(root, 'B', -infinity, +infinity)` 并返回结果元组中的布尔部分。\n\n这个全面的、单次遍历的递归算法验证了所有指定的属性。它对每个可达节点只访问一次，在每个节点上执行常数时间的工作。这导致时间复杂度为 $O(N)$。空间复杂度由递归栈的最大深度决定，该深度等于树的高度 $H$，因此实现了 $O(H)$ 的辅助空间。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RBT verification problem for a hard-coded suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (valid RBT, non-trivial)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, 4), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 2 (BST ordering violation in the right subtree)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, 4), (9, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 3 (isolated red-red violation)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, -1), (15, 'R', -1, -1), (2, 'R', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 4 (black-height mismatch)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', -1, -1), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 5 (root not black)\n        (\n            [ (10, 'R', 1, 2), (5, 'B', 3, 4), (15, 'B', -1, -1), (2, 'R', -1, -1), (7, 'R', -1, -1) ],\n            0\n        ),\n        # Case 6 (single-node black tree)\n        (\n            [ (42, 'B', -1, -1) ],\n            0\n        ),\n        # Case 7 (empty tree)\n        (\n            [],\n            -1\n        ),\n    ]\n\n    results = []\n    for nodes, root in test_cases:\n        verifier = RBTVerifier(nodes)\n        results.append(verifier.is_valid_rbt(root))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass RBTVerifier:\n    \"\"\"\n    A verifier for Red-Black Trees derived from first principles.\n    \"\"\"\n    def __init__(self, nodes):\n        self._nodes = nodes\n\n    def is_valid_rbt(self, root_idx: int) -> bool:\n        \"\"\"\n        Checks if the tree rooted at root_idx is a valid Red-Black Tree.\n        \"\"\"\n        # Property 5: The empty tree is a valid RBT.\n        if root_idx == -1:\n            return True\n\n        root_node = self._nodes[root_idx]\n        root_color = root_node[1]\n\n        # Property 2: The root node, if it exists, is colored black.\n        if root_color == 'R':\n            return False\n\n        # Start recursive validation. The root's parent can be considered black.\n        # The key range for the root is unbounded.\n        is_valid, _ = self._validate_subtree(root_idx, 'B', float('-inf'), float('inf'))\n        return is_valid\n\n    def _validate_subtree(self, node_idx: int, parent_color: str, min_bound: float, max_bound: float) -> tuple[bool, int]:\n        \"\"\"\n        Recursively validates the RBT properties for the subtree at node_idx.\n\n        Returns a tuple: (is_valid, black_height).\n        black_height is the count of black nodes on any path from this node\n        to a descendant null leaf, not including the null leaf itself.\n        A black_height of 0 is used to signal failure internally.\n        \"\"\"\n        # Base case: A null child path has 0 black nodes.\n        if node_idx == -1:\n            return True, 0\n\n        key, color, left_idx, right_idx = self._nodes[node_idx]\n\n        # Property 3 (Red Property): A red node cannot have a red child.\n        if color == 'R' and parent_color == 'R':\n            return False, 0\n\n        # Property 1 (BST Property): Key must be within the bounds set by ancestors.\n        if not (min_bound  key  max_bound):\n            return False, 0\n        \n        # Recurse on children, updating bounds and passing current node's color.\n        left_valid, left_bh = self._validate_subtree(left_idx, color, min_bound, key)\n        if not left_valid:\n            return False, 0\n            \n        right_valid, right_bh = self._validate_subtree(right_idx, color, key, max_bound)\n        if not right_valid:\n            return False, 0\n\n        # Property 4 (Black-height Property): All simple paths from this node to\n        # descendant leaves must contain the same number of black nodes.\n        # This means the black-heights returned by its children must be equal.\n        if left_bh != right_bh:\n            return False, 0\n\n        # This subtree is valid. Calculate its black-height.\n        # The black-height is the child's black-height plus 1 if this node is black.\n        current_bh = left_bh + (1 if color == 'B' else 0)\n        \n        return True, current_bh\n\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3269583"}, {"introduction": "在能够验证红黑树的正确性后，我们可以探索如何扩展其功能。本练习探讨了一个实际问题：如何高效地更新树中的一个键值。通过组合已经存在的、性能有保障的删除和插入操作，你可以设计出一个既优雅又高效的解决方案，这体现了在复杂系统中利用现有模块构建新功能的核心工程思想。[@problem_id:3269521]", "problem": "要求您从二叉搜索树（BST）和红黑树（RBT）的基本定义出发进行推理，并实现一个程序，支持在红黑树中以对数时间完成键值更新操作。二叉搜索树（BST）存储可比较的键，其中序遍历会得到一个严格递增的序列。红黑树（RBT）是一种带有颜色属性的BST，满足以下经典不变性：每个节点要么是红色要么是黑色；根节点是黑色；每个叶子哨兵（空子节点）是黑色；每个红色节点的子节点都是黑色；从任一节点到其每个后代叶子节点的每条简单路径都包含相同数量的黑色节点。这些经过充分检验的性质意味着，标准的RBT插入和删除操作通过执行对数次数的旋转和重新着色，并始终保持BST的排序属性，其运行时间为 $O(\\log N)$，其中 $N$ 是键的数量。\n\n请设计一个算法，在仅给定基本定义以及标准RBT插入和删除过程存在的前提下，在 $O(\\log N)$ 时间内更新RBT中的一个键。该更新操作必须接收一个现有键 $k_{\\text{old}}$ 和一个新键 $k_{\\text{new}}$，并将树进行转换，使得原先等于 $k_{\\text{old}}$ 的键变为 $k_{\\text{new}}$，同时保持BST的排序属性和RBT的不变性。您必须明确处理以下情况：\n- 如果 $k_{\\text{old}}$ 不在树中，不执行任何更改。\n- 如果 $k_{\\text{new}}$ 已存在于树中且 $k_{\\text{new}} \\neq k_{\\text{old}}$，不执行任何更改。\n- 如果 $k_{\\text{new}} = k_{\\text{old}}$ 且 $k_{\\text{old}}$ 存在，这是一个空操作。\n\n每个测试用例的输出必须以一个列表的形式量化树的最终状态，该列表按顺序包含以下组成部分：\n- 一个整数有效性标志，当且仅当最终的树满足所有RBT不变性并且是有效的BST时等于 $1$，否则为 $0$。\n- 最终的键数量（一个整数）。\n- 树的黑高（一个整数），定义为从根节点到任一空叶子哨兵的简单路径上的黑色节点数量（不包含哨兵）；如果树不是一个有效的RBT，则此部分输出 $-1$。\n- 树的高度（一个整数），定义为从根到叶的最长简单路径上的实际节点数量；空树的高度为 $0$。\n- 中序遍历结果，为一个严格递增的整数列表。\n\n您的程序应生成单行输出，包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个结果都必须是按上述结构组织的列表。\n\n测试套件。对于每个测试，初始树通过按所列顺序插入给定的键来构建，然后按顺序应用所列的更新请求序列 $(k_{\\text{old}}, k_{\\text{new}})$。键是整数，初始列表包含唯一值。\n- 测试 1：\n  - 初始键：$[10, 20, 30, 15, 25, 5, 1]$。\n  - 更新操作：$(15, 17)$, $(25, 22)$, $(1, 26)$。\n- 测试 2：\n  - 初始键：$[7, 3, 18, 10, 22, 8, 11, 26]$。\n  - 更新操作：$(3, 2)$, $(26, 30)$, $(7, 7)$, $(8, 9)$。\n- 测试 3：\n  - 初始键：$[1, 2, 3, 4, 5]$。\n  - 更新操作：$(6, 0)$, $(2, 3)$, $(5, 5)$, $(4, -1)$。\n- 测试 4：\n  - 初始键：$[50, 25, 75, 12, 37, 62, 87, 6, 18, 31, 43, 56, 68, 81, 93]$。\n  - 更新操作：$(37, 38)$, $(62, 24)$, $(81, 90)$, $(12, 13)$, $(93, 1)$。\n\n您的实现必须基于上述核心定义和性质，不得假定任何专门的快捷公式。更新操作所需的时间复杂度为 $O(\\log N)$，并且需要从第一性原理出发进行证明。最终输出必须是单行文本，格式为一个类JSON的Python列表，其中包含按上述测试顺序排列的各个测试用例的结果列表。", "solution": "问题要求设计并实现一个算法，在红黑树（RBT）中以 $O(\\log N)$ 的时间将一个键的值从 $k_{\\text{old}}$ 更新为 $k_{\\text{new}}$，其中 $N$ 是树中键的数量。解决方案必须从二叉搜索树（BST）和红黑树（RBT）的基本性质推导得出。\n\n二叉搜索树维持一个关键的不变性：对于任何键为 $k$ 的节点，其左子树中的所有键都小于 $k$，其右子树中的所有键都大于 $k$。这个属性决定了树中每个节点的结构位置。红黑树是一种特殊的自平衡BST，它在维持这种排序性的同时，还满足一组基于颜色的不变性，以确保树的高度保持在节点数量的对数级别，即 $O(\\log N)$。RBT上的标准操作（如插入和删除）通过有限次数的局部重新着色和结构调整操作（旋转）来保持所有不变性，并在 $O(\\log N)$ 时间内完成。\n\n考虑一个朴素的更新操作方法：\n1. 找到包含键 $k_{\\text{old}}$ 的节点 $x$。\n2. 直接修改该节点的键：$x.key \\leftarrow k_{\\text{new}}$。\n\n这种方法是有缺陷的，因为它可能违反基本的BST排序属性。节点 $x$ 在树中的特定位置是基于其键值 $k_{\\text{old}}$ 相对于其祖先和后代的值而确定的。将其键更改为 $k_{\\text{new}}$ 并不会改变其位置。如果 $k_{\\text{new}}$ 违反了与 $x$ 的父节点、子节点或树中任何其他节点的排序关系，BST属性就会被破坏。例如，如果一个键为10的节点有一个键为15的右子节点，将父节点的键更新为20将违反BST属性，因为一个键为20的节点将位于其自己的子节点（键为15的节点）的左子树中。通过移动节点及其子树来修复这种结构性违规，同时保持RBT不变性，将是一个高度复杂、非局部的操作，其复杂度可能等同于甚至超过删除和插入操作。\n\n一种更具原则性的方法是认识到，更改键的值等同于更改其在树的顺序中的身份。$k_{\\text{new}}$ 的正确结构位置可能与 $k_{\\text{old}}$ 的完全不同。因此，该操作必须有效地将键从其旧位置“移动”到新位置。使用标准的、定义明确的RBT操作来实现这一目标的最直接方法是执行一次删除，然后执行一次插入。\n\n提出的算法如下：\n1.  **处理前置条件**：问题为几个边界情况指定了行为。\n    - 如果 $k_{\\text{old}} = k_{\\text{new}}$，该操作为空操作，无需更改。\n    - 如果树中已存在键为 $k_{\\text{new}}$ 的节点（且 $k_{\\text{new}} \\neq k_{\\text{old}}$），则不应执行任何更改。这可以防止创建重复的键，因为这会违反BST属性。此检查需要搜索 $k_{\\text{new}}$，耗时 $O(\\log N)$。\n    - 如果键 $k_{\\text{old}}$ 不在树中，则不进行任何更改。\n\n2.  **核心逻辑**：如果不满足不采取行动的前置条件（即 $k_{\\text{old}} \\neq k_{\\text{new}}$，$k_{\\text{new}}$ 不在树中，且 $k_{\\text{old}}$ 在树中），则继续执行更新。\n    - **删除**：执行标准的RBT删除操作，删除键 $k_{\\text{old}}$。问题说明此操作可用且运行时间为 $O(\\log N)$。此过程会正确移除节点并重新平衡树以维持所有RBT不变性。如果未找到 $k_{\\text{old}}$，`delete` 操作自然不执行任何操作，满足了问题的要求。\n    - **插入**：执行标准的RBT插入操作，插入新键 $k_{\\text{new}}$。此操作的运行时间也为 $O(\\log N)$，它会将新键放置在正确的结构位置，同时保持所有RBT不变性。\n\n**复杂度分析**：\n整个 `update` 算法由常数个标准RBT操作组成：\n- 一次搜索操作，检查 $k_{\\text{new}}$ 是否存在：$O(\\log N)$。\n- 一次删除操作，删除 $k_{\\text{old}}$（其中包含一次搜索）：$O(\\log N)$。\n- 一次插入操作，插入 $k_{\\text{new}}$：$O(\\log N)$。\n\n总时间复杂度是这些操作的总和，即 $O(\\log N) + O(\\log N) + O(\\log N) = O(\\log N)$。这满足了问题的性能要求。这种先删除后插入的策略通过利用基础RBT操作有保证的正确性和性能，正确而高效地执行了键更新。\n\n实现将包括一个完整的RBT数据结构，包含 `insert`、`delete`、它们的修复例程以及旋转操作。`update` 方法将如前所述协调这些基本操作。最后，将实现一组验证方法，用于检查树的最终状态是否符合所有BST和RBT不变性，并计算所需的输出指标（有效性标志、节点数、黑高、高度和中序遍历）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# Increase recursion limit for deep trees; a safeguard for robust tree algorithms.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in the Red-Black Tree.\"\"\"\n    def __init__(self, key, color='RED', parent=None, left=None, right=None):\n        self.key = key\n        self.color = color\n        self.parent = parent\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f\"Node(key={self.key}, color={self.color})\"\n\nclass RedBlackTree:\n    \"\"\"A Red-Black Tree implementation supporting key updates.\"\"\"\n    def __init__(self):\n        # The NIL sentinel is a single black node representing all leaves.\n        self.NIL = Node(key=None, color='BLACK')\n        self.root = self.NIL\n        self.size = 0\n\n    def _left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left is not self.NIL:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is self.NIL:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def _right_rotate(self, y):\n        x = y.left\n        y.left = x.right\n        if x.right is not self.NIL:\n            x.right.parent = y\n        x.parent = y.parent\n        if y.parent is self.NIL:\n            self.root = x\n        elif y == y.parent.right:\n            y.parent.right = x\n        else:\n            y.parent.left = x\n        x.right = y\n        y.parent = x\n\n    def insert(self, key):\n        if self.find(key) is not self.NIL:\n            return\n\n        z = Node(key=key, left=self.NIL, right=self.NIL)\n        y = self.NIL\n        x = self.root\n\n        while x is not self.NIL:\n            y = x\n            if z.key  x.key:\n                x = x.left\n            else:\n                x = x.right\n\n        z.parent = y\n        if y is self.NIL:\n            self.root = z\n        elif z.key  y.key:\n            y.left = z\n        else:\n            y.right = z\n\n        z.color = 'RED'\n        self._insert_fixup(z)\n        self.size += 1\n\n    def _insert_fixup(self, z):\n        while z.parent.color == 'RED':\n            if z.parent == z.parent.parent.left:\n                y = z.parent.parent.right  # Uncle\n                if y.color == 'RED':\n                    z.parent.color = 'BLACK'\n                    y.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.right:\n                        z = z.parent\n                        self._left_rotate(z)\n                    z.parent.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    self._right_rotate(z.parent.parent)\n            else:\n                y = z.parent.parent.left  # Uncle\n                if y.color == 'RED':\n                    z.parent.color = 'BLACK'\n                    y.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.left:\n                        z = z.parent\n                        self._right_rotate(z)\n                    z.parent.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    self._left_rotate(z.parent.parent)\n        self.root.color = 'BLACK'\n\n    def _transplant(self, u, v):\n        if u.parent is self.NIL:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        v.parent = u.parent\n\n    def delete(self, key):\n        z = self.find(key)\n        if z is self.NIL:\n            return False\n\n        y = z\n        y_original_color = y.color\n        if z.left is self.NIL:\n            x = z.right\n            self._transplant(z, z.right)\n        elif z.right is self.NIL:\n            x = z.left\n            self._transplant(z, z.left)\n        else:\n            y = self._tree_minimum(z.right)\n            y_original_color = y.color\n            x = y.right\n            if y.parent == z:\n                x.parent = y\n            else:\n                self._transplant(y, y.right)\n                y.right = z.right\n                y.right.parent = y\n            self._transplant(z, y)\n            y.left = z.left\n            y.left.parent = y\n            y.color = z.color\n        \n        if y_original_color == 'BLACK':\n            self._delete_fixup(x)\n        \n        self.size -= 1\n        return True\n\n    def _delete_fixup(self, x):\n        while x is not self.root and x.color == 'BLACK':\n            if x == x.parent.left:\n                w = x.parent.right\n                if w.color == 'RED':\n                    w.color = 'BLACK'\n                    x.parent.color = 'RED'\n                    self._left_rotate(x.parent)\n                    w = x.parent.right\n                if w.left.color == 'BLACK' and w.right.color == 'BLACK':\n                    w.color = 'RED'\n                    x = x.parent\n                else:\n                    if w.right.color == 'BLACK':\n                        w.left.color = 'BLACK'\n                        w.color = 'RED'\n                        self._right_rotate(w)\n                        w = x.parent.right\n                    w.color = x.parent.color\n                    x.parent.color = 'BLACK'\n                    w.right.color = 'BLACK'\n                    self._left_rotate(x.parent)\n                    x = self.root\n            else:\n                w = x.parent.left\n                if w.color == 'RED':\n                    w.color = 'BLACK'\n                    x.parent.color = 'RED'\n                    self._right_rotate(x.parent)\n                    w = x.parent.left\n                if w.right.color == 'BLACK' and w.left.color == 'BLACK':\n                    w.color = 'RED'\n                    x = x.parent\n                else:\n                    if w.left.color == 'BLACK':\n                        w.right.color = 'BLACK'\n                        w.color = 'RED'\n                        self._left_rotate(w)\n                        w = x.parent.left\n                    w.color = x.parent.color\n                    x.parent.color = 'BLACK'\n                    w.left.color = 'BLACK'\n                    self._right_rotate(x.parent)\n                    x = self.root\n        x.color = 'BLACK'\n\n    def find(self, key):\n        x = self.root\n        while x is not self.NIL and key != x.key:\n            if key  x.key:\n                x = x.left\n            else:\n                x = x.right\n        return x\n\n    def _tree_minimum(self, x):\n        while x.left is not self.NIL:\n            x = x.left\n        return x\n\n    def update(self, k_old, k_new):\n        if k_old == k_new:\n            return\n        if self.find(k_new) is not self.NIL:\n            return\n        if self.delete(k_old):\n            self.insert(k_new)\n\n    def get_in_order_traversal(self):\n        result = []\n        def _in_order(node):\n            if node is not self.NIL:\n                _in_order(node.left)\n                result.append(node.key)\n                _in_order(node.right)\n        _in_order(self.root)\n        return result\n\n    def get_height(self):\n        if self.root is self.NIL:\n            return 0\n        def _height(node):\n            if node is self.NIL:\n                return 0\n            return 1 + max(_height(node.left), _height(node.right))\n        return _height(self.root)\n\n    def get_final_state(self):\n        in_order = self.get_in_order_traversal()\n        \n        is_bst = all(in_order[i]  in_order[i+1] for i in range(len(in_order)-1))\n\n        def _validate_rbt_recursive(node):\n            if node is self.NIL:\n                return True, True, 0\n            \n            p4_node = True\n            if node.color == 'RED' and (node.left.color == 'RED' or node.right.color == 'RED'):\n                p4_node = False\n            \n            p4_left, p5_left, bh_left = _validate_rbt_recursive(node.left)\n            p4_right, p5_right, bh_right = _validate_rbt_recursive(node.right)\n            \n            is_p4_valid = p4_node and p4_left and p4_right\n            is_p5_valid = p5_left and p5_right and (bh_left == bh_right)\n            \n            bh = -1\n            if is_p5_valid:\n                bh = bh_left + (1 if node.color == 'BLACK' else 0)\n            \n            return is_p4_valid, is_p5_valid, bh\n\n        validity_flag = 0\n        black_height = -1\n        \n        if self.root is self.NIL:\n            validity_flag = 1\n            black_height = 0\n        elif self.root.color == 'BLACK':\n            p4_valid, p5_valid, bh = _validate_rbt_recursive(self.root)\n            if is_bst and p4_valid and p5_valid:\n                validity_flag = 1\n                black_height = bh\n        \n        return [validity_flag, self.size, black_height, self.get_height(), in_order]\n\ndef solve():\n    test_cases = [\n        {\"initial_keys\": [10, 20, 30, 15, 25, 5, 1], \"updates\": [(15, 17), (25, 22), (1, 26)]},\n        {\"initial_keys\": [7, 3, 18, 10, 22, 8, 11, 26], \"updates\": [(3, 2), (26, 30), (7, 7), (8, 9)]},\n        {\"initial_keys\": [1, 2, 3, 4, 5], \"updates\": [(6, 0), (2, 3), (5, 5), (4, -1)]},\n        {\"initial_keys\": [50, 25, 75, 12, 37, 62, 87, 6, 18, 31, 43, 56, 68, 81, 93], \"updates\": [(37, 38), (62, 24), (81, 90), (12, 13), (93, 1)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        tree = RedBlackTree()\n        for key in case[\"initial_keys\"]:\n            tree.insert(key)\n        \n        for k_old, k_new in case[\"updates\"]:\n            tree.update(k_old, k_new)\n            \n        final_state = tree.get_final_state()\n        results.append(final_state)\n\n    print(str(results).replace(\"], [\", \"],[\",).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3269521"}, {"introduction": "这项练习将你的思维从处理单个元素的增量操作，提升到处理整个数据结构的批量转换。任务要求在 $O(N)$ 的线性时间内，将一棵 Adelson-Velsky and Landis (AVL) 树转换成一棵功能等价的红黑树。要达到这一目标，你必须摒弃逐个插入的低效方法，转而利用一种更根本的技术：从有序序列出发，直接构建一棵满足特定颜色和结构属性的平衡树。[@problem_id:3269511]", "problem": "您的任务是设计并实现一个算法，该算法能为任意有效的 Adelson-Velsky and Landis (AVL) 树，构建一棵存储完全相同键集合的有效红黑树 (Red-Black tree, RBT)，总时间复杂度为 $O(N)$，其中 $N$ 是键的数量。该算法必须从第一性原理出发，使用二叉搜索树 (Binary Search Tree, BST)、AVL 树和红黑树的定义及不变量进行推导和论证。\n\n您必须编写一个完整、可运行的程序，对每个测试用例执行以下步骤：\n- 从一个存储一组不同整数键的有效 AVL 树开始。\n- 将该 AVL 树转换为一个有效的红黑树，该红黑树存储相同的键，不必要保留原始形状，但必须严格保持 BST 属性和键的集合。\n- 验证生成的 RBT 是否满足所有 RBT 不变量，并计算根节点的黑高。黑高定义为从根到任意空叶子的任何路径上的黑色节点数量，不包括空叶子本身。验证必须包括 BST 属性、红黑着色约束，以及与源 AVL 树的键集合是否相等。\n- 对于每个测试用例，返回一个包含两个值的列表：根节点的黑高（整数），以及一个布尔值，该布尔值指示生成的红黑树是否有效且存储了完全相同的键。\n\n您必须使用的基本定义：\n- 二叉搜索树 (BST) 是一种有根二叉树，其节点存储键并满足排序不变量，即节点左子树中所有键都严格小于该节点的键，而节点右子树中所有键都严格大于该节点的键。对 BST 进行中序遍历会得到严格递增排序的键。\n- Adelson-Velsky and Landis (AVL) 树是一种保持高度平衡的 BST：对于每个节点，其左子树的高度与右子树的高度之差（平衡因子）在 $\\{-1,0,1\\}$ 范围内；节点的高度是从该节点到叶子的最长路径上的边数。按照惯例，空树的高度为 $-1$，叶子节点的高度为 $0$。\n- 红黑树 (RBT) 是一种赋予了节点着色函数的 BST，每个节点被赋予红色或黑色，并遵循以下不变量：根是黑色的，红色节点的两个子节点都是黑色的，并且从根到任意空叶子的每条路径都包含相同数量的黑色节点。节点的黑高定义为从该节点到任一空叶子的路径上黑色节点的数量，不包括空叶子。\n\n您的算法必须在最坏情况下以 $O(N)$ 的时间完成转换。为了达到此时间限制，唯一允许的策略是避免对每个键进行重新平衡，而是使用基于 BST 和红黑树不变量的 $O(N)$ 时间复杂度的结构性构建技术。\n\n测试套件规范：\n- 您必须通过标准的 AVL 插入操作，使用以下不同整数键的序列在内部构建 AVL 树：\n    1. $[10,20,30,40,50,25]$ (一个触发旋转的通用案例)。\n    2. $[]$ (空树，用于测试边界情况 $N=0$)。\n    3. $[42]$ (单节点树，用于测试边界情况 $N=1$)。\n    4. $[1,2,3,4,5,6,7]$ (生成一个完美平衡的形状)。\n    5. $[1,2,3,\\dots,64]$ (从 $1$ 到 $64$ 的连续整数序列，一个较大的案例)。\n- 对于每个测试用例，程序必须输出一个列表 $[b, v]$，其中 $b$ 是根节点的黑高（整数），$v$ 是一个布尔值，当且仅当生成的红黑树有效且其中序遍历与源 AVL 树的中序遍历完全匹配时，该值为 $True$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表被方括号包围，其中每个元素是对应于每个测试用例的 $[b, v]$ 两项列表，顺序与上述指定相同。例如，输出必须具有 $[[b_1,v_1],[b_2,v_2],\\dots,[b_5,v_5]]$ 的形式，并显示在单行上。\n\n此问题不涉及物理量、角度或百分比；因此，没有单位规范适用。", "solution": "问题要求设计并实现一个算法，以 $O(N)$ 的时间复杂度将给定的 Adelson-Velsky and Landis (AVL) 树转换为一个有效的红黑树 (RBT)，其中 $N$ 是树中节点的数量。该解决方案必须从第一性原理出发进行论证。\n\n一个朴素的方法是遍历 AVL 树以提取其键，然后将它们逐个插入到一棵新的 RBT 中，这将导致 $O(N \\log N)$ 的时间复杂度，因为向 RBT 中插入 $N$ 个键中的每一个都需要 $O(\\log N)$ 的时间。为了达到要求的 $O(N)$ 复杂度，必须采用一种避免单独重平衡操作的结构性构建方法。所提出的算法包含三个主要阶段，每个阶段都在 $O(N)$ 时间内完成。\n\n**阶段 1：从 AVL 树中提取有序键**\n\nAVL 树是二叉搜索树 (BST) 的一种特定类型。任何 BST 的一个基本属性是，对其节点进行中序遍历会得到严格递增的有序键。我们可以对给定的 AVL 树执行中序遍历，以获得一个包含其所有 $N$ 个键的有序数组。此遍历过程会精确地访问每个节点和每条边一次，因此需要 $O(N)$ 的时间。设得到的有序键数组为 $A$。\n\n**阶段 2：从有序数组构建一棵完美平衡的 BST**\n\n给定一个包含 $N$ 个键的有序数组 $A$，我们可以在 $O(N)$ 时间内构建一棵高度最小的 BST。这是通过一个递归过程实现的。核心思想是选择数组的中位数元素作为树的根。中位数左侧的所有元素构成左子树，右侧的所有元素构成右子树。此过程递归地应用于左右子数组。\n\n设递归函数为 `Build(A, start, end)`，它从子数组 $A[\\text{start} \\dots \\text{end}]$ 构建一棵树：\n1. 如果 $\\text{start}  \\text{end}$，返回空指针，表示一棵空树。\n2. 计算中间索引 $\\text{mid} = \\text{start} + \\lfloor (\\text{end} - \\text{start}) / 2 \\rfloor$。\n3. 使用键 $A[\\text{mid}]$ 创建一个新节点。该节点成为当前子树的根。\n4. 递归调用 `Build(A, start, mid - 1)` 构建左子树，并将其指定为根的左子节点。\n5. 递归调用 `Build(A, mid + 1, end)` 构建右子树，并将其指定为根的右子节点。\n6. 返回构建的根节点。\n\n此构建过程的时间复杂度由递推关系 $T(N) = 2T(N/2) + O(1)$ 描述，根据主定理 (Master Theorem) 可解得 $O(N)$。生成的 BST 高度尽可能平衡；其高度 $h$ 为 $\\lfloor \\log_2 N \\rfloor$。在此树中，从根到任一叶节点的任何路径的长度要么是 $h$，要么是 $h-1$。\n\n**阶段 3：为 BST 着色以形成有效的红黑树**\n\n最后阶段是为新构建的 BST 的每个节点分配颜色（红色或黑色），以满足所有 RBT 不变量。我们构建的树的结构规律性允许采用一种简单而优雅的着色方案，该方案可在单次 $O(N)$ 遍历中应用。\n\nRBT 的不变量如下：\n1.  **根属性**：根节点是黑色的。\n2.  **红色属性**：如果一个节点是红色的，那么它的两个子节点都必须是黑色的。\n3.  **黑高属性**：对于每个节点，从该节点到其后代所有空叶子的简单路径都包含相同数量的黑色节点。\n\n以下着色算法满足这些属性：\n1. 在阶段 2 的递归构建过程中，我们还可以向下传递正在创建的节点的当前深度。设根的深度为 $0$。\n2. 构建的树的高度为 $h = \\lfloor \\log_2 N \\rfloor$。这个值可以预先计算。\n3. 对于每个深度为 $d(v)$ 的节点 $v$，根据以下规则为其分配颜色：\n   - 如果 $d(v)  h$，则将 $v$ 涂成黑色。\n   - 如果 $d(v) = h$，则将 $v$ 涂成红色。\n4. 在树构建和着色后，通过显式地将根的颜色设置为黑色来强制执行根属性。这处理了 $N=1$ 的特殊情况，此时 $h=0$，否则根节点会被涂成红色。\n\n**着色方案的论证：**\n\n让我们正式验证该方案能生成一棵有效的 RBT。\n\n-   **根属性**：根的颜色被显式设置为黑色。此属性成立。\n\n-   **红色属性**：红色节点必须有两个黑色子节点。根据我们的着色规则，只有深度为 $d(v) = h$ 的节点才能是红色的。此类节点的子节点（如果存在）将位于深度 $h+1$ 处。然而，我们树中的最大深度是 $h$。因此，任何深度为 $h$ 的节点的所有子节点都是空叶子，它们被视为黑色。此外，一个深度为 $h$ 的红色节点的父节点必然位于深度 $h-1$ 处。由于 $h-1  h$，父节点被涂成黑色。因此，路径上没有两个相邻节点是红色的。此属性成立。\n\n-   **黑高属性**：我们必须证明从根到任一空叶子的任何路径都具有相同数量的黑色节点。设此计数为黑高 $bh$。考虑从根到任意空叶子的一条路径。该空叶子的父节点，我们称之为 $p$，必须是我们树中的一个节点。\n    -   **情况 1**：父节点 $p$ 的深度为 $d(p) = h-1$。从根到 $p$ 的路径由 $h$ 个节点组成，深度分别为 $0, 1, \\dots, h-1$。根据我们的规则，所有这些节点都被涂成黑色。到该空叶子路径上的黑色节点总数为 $h$。\n    -   **情况 2**：父节点 $p$ 的深度为 $d(p) = h$。从根到 $p$ 的路径由 $h+1$ 个节点组成。深度为 $0, 1, \\dots, h-1$ 的节点是黑色的。深度为 $h$ 的节点 $p$ 是红色的。到该空叶子路径上的黑色节点数量是到 $p$ 路径上的黑色节点数量，即 $h$。\n    在两种情况下，从根到任何空叶子的黑色节点数量恰好是 $h = \\lfloor \\log_2 N \\rfloor$。黑高属性成立，且根的黑高为 $h$。\n\n由于所有三个阶段——中序遍历、平衡 BST 构建和着色——都需要 $O(N)$ 的时间，因此转换的总时间复杂度为 $O(N)$。每个测试用例的最终输出将是计算出的根节点黑高以及一个布尔值，该布尔值通过验证程序确认生成的 RBT 是否有效且保留了原始键集合。", "answer": "```python\nimport sys\nimport numpy as np\n\n# A large recursion limit is needed for the larger test cases.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Node class for both AVL and Red-Black trees.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        # AVL-specific attribute\n        self.height = 1\n        # RBT-specific attribute\n        self.color = 'RED' # Default to RED for easier construction\n\n# --- AVL Tree Implementation ---\nclass AVLTree:\n    def get_height(self, node):\n        if not node:\n            return 0\n        return node.height\n\n    def get_balance(self, node):\n        if not node:\n            return 0\n        return self.get_height(node.left) - self.get_height(node.right)\n\n    def right_rotate(self, y):\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        return x\n\n    def left_rotate(self, x):\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        return y\n\n    def insert(self, root, key):\n        if not root:\n            return Node(key)\n        elif key  root.key:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n\n        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))\n        balance = self.get_balance(root)\n\n        # Left Left Case\n        if balance > 1 and key  root.left.key:\n            return self.right_rotate(root)\n        # Right Right Case\n        if balance  -1 and key > root.right.key:\n            return self.left_rotate(root)\n        # Left Right Case\n        if balance > 1 and key > root.left.key:\n            root.left = self.left_rotate(root.left)\n            return self.right_rotate(root)\n        # Right Left Case\n        if balance  -1 and key  root.right.key:\n            root.right = self.right_rotate(root.right)\n            return self.left_rotate(root)\n\n        return root\n\n    def in_order_traversal(self, root):\n        res = []\n        if root:\n            res = self.in_order_traversal(root.left)\n            res.append(root.key)\n            res = res + self.in_order_traversal(root.right)\n        return res\n\n# --- Conversion and Verification ---\n\ndef avl_to_rbt(avl_root):\n    \"\"\"\n    Converts an AVL tree to a Red-Black tree in O(N) time.\n    \"\"\"\n    # Stage 1: Get sorted keys from AVL\n    sorted_keys = AVLTree().in_order_traversal(avl_root)\n    n = len(sorted_keys)\n\n    if n == 0:\n        return None\n\n    # Stage 2  3: Build a perfectly balanced BST and color it.\n    # The height h of the tree will be floor(log2(n)).\n    h = int(np.floor(np.log2(n)))\n    \n    def build_and_color(keys, start, end, depth):\n        if start > end:\n            return None\n        \n        mid = start + (end - start) // 2\n        node = Node(keys[mid])\n        \n        node.left = build_and_color(keys, start, mid - 1, depth + 1)\n        node.right = build_and_color(keys, mid + 1, end, depth + 1)\n        \n        # Color based on depth\n        if depth  h:\n            node.color = 'BLACK'\n        else:\n            node.color = 'RED'\n        \n        return node\n\n    rbt_root = build_and_color(sorted_keys, 0, n - 1, 0)\n\n    # Force root to be black\n    if rbt_root:\n        rbt_root.color = 'BLACK'\n        \n    return rbt_root\n\ndef verify_rbt(rbt_root, original_keys):\n    \"\"\"\n    Verifies the RBT invariants and returns (black_height, is_valid).\n    \"\"\"\n    n = len(original_keys)\n    if rbt_root is None:\n        return (0, n == 0)\n\n    # 1. Check Key Preservation and BST property\n    rbt_keys = AVLTree().in_order_traversal(rbt_root)\n    if rbt_keys != original_keys:\n        return (-1, False)\n\n    # 2. Check Root Property\n    if rbt_root.color != 'BLACK':\n        return (-1, False)\n\n    # 3. Check Red and Black-Height properties recursively\n    def verify_properties_recursive(node):\n        if node is None:\n            # According to problem definition, black height of a path to a null leaf\n            # does not include the leaf. So a path to a null leaf from a null parent is 0.\n            return 0, True\n\n        left_bh, left_valid = verify_properties_recursive(node.left)\n        right_bh, right_valid = verify_properties_recursive(node.right)\n\n        # Check for black-height violation from children\n        if not left_valid or not right_valid or left_bh != right_bh:\n            return -1, False\n        \n        # Check for red property violation\n        if node.color == 'RED':\n            if (node.left and node.left.color == 'RED') or \\\n               (node.right and node.right.color == 'RED'):\n                return -1, False\n\n        # Calculate black-height for this node's subtree\n        current_bh = left_bh + (1 if node.color == 'BLACK' else 0)\n        return current_bh, True\n\n    root_bh, is_valid = verify_properties_recursive(rbt_root)\n    \n    return root_bh, is_valid\n\ndef solve():\n    test_cases = [\n        [10, 20, 30, 40, 50, 25],\n        [],\n        [42],\n        list(range(1, 8)),\n        list(range(1, 65)),\n    ]\n    \n    avl_builder = AVLTree()\n    results = []\n    \n    for keys in test_cases:\n        # Build AVL tree\n        avl_root = None\n        for key in keys:\n            avl_root = avl_builder.insert(avl_root, key)\n            \n        # Convert to RBT\n        rbt_root = avl_to_rbt(avl_root)\n        \n        # Verify RBT and get black height\n        # original_keys in sorted order is required for verification\n        sorted_keys = sorted(keys)\n        black_height, is_valid = verify_rbt(rbt_root, sorted_keys)\n        \n        results.append([black_height, is_valid])\n\n    # Format output as required: [[b_1,v_1],[b_2,v_2],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3269511"}]}