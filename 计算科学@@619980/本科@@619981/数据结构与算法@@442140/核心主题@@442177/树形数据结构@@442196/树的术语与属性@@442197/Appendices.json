{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。本节练习旨在检验你对二叉树结构性约束的深刻理解。我们不再局限于计算节点数或高度，而是探讨一个更根本的问题：一个给定的深度集合是否能构成一棵合法的二叉树的所有叶节点的深度？[@problem_id:3280782] 这个练习将引导你发现一个优雅的数学不等式，它揭示了树的“分支预算”是如何被分配的，从而加深你对树形结构内在限制的认识。", "problem": "一个有根二叉树是一个有限的有序树，其中每个节点最多有两个子节点。叶子是出度为 $0$ 的节点，节点的深度是指从根到该节点的唯一路径上的边数。考虑一个有限有根二叉树中所有叶子深度的多重集。下列哪个多重集可以作为某个有效的有根二叉树的全部叶子深度集合？请选择所有适用的选项。\n\nA. $\\{1,1,2,3\\}$\n\nB. $\\{2,2,3,3,3\\}$\n\nC. $\\{0,2,3\\}$\n\nD. $\\{1,3,4,4,5,5,5\\}$\n\nE. $\\{2,2,2,2\\}$\n\n请根据上述核心定义和二叉树的普遍公认属性提供理由，不要假设存在特殊限制，例如每个内部节点都恰好有两个子节点。", "solution": "问题要求确定给定的数字多重集中，哪些可以表示一个有限有根二叉树的所有叶子的深度。有根二叉树允许节点有 $0$、 $1$ 或 $2$ 个子节点。\n\n任何此类树的叶子深度都遵循一个基本属性。设 $D$ 为一个有限有根二叉树中所有叶子深度的多重集。这个多重集 $D = \\{d_1, d_2, \\ldots, d_k\\}$ 是有效的，当且仅当它满足两个条件：\n1.  如果 $0 \\in D$，那么 $D$ 必须是 $\\{0\\}$。深度为 $0$ 的叶子意味着根节点是叶子。如果根是叶子，它就没有子节点，树只包含这一个节点。因此，不可能有其他深度的叶子。\n2.  多重集中每个深度 $d$ 对应的 $2^{-d}$ 的总和必须小于或等于 $1$。这是 Kraft 不等式的一种形式，用于前缀码，其中叶子深度对应于码字长度。\n    $$ \\sum_{i=1}^{k} 2^{-d_i} \\le 1 $$\n\n让我们为这个不等式提供一个简要的证明。我们可以通过从一个节点（根）开始，并重复应用扩展操作来构造任何二叉树。\n- **基本情况：**最简单的树是一个单节点，即根节点。该节点也是一个深度为 $d=0$ 的叶子。总和为 $2^{-0} = 1$。不等式 $1 \\le 1$ 成立。\n- **归纳步骤：**假设我们有一个有效的二叉树，其总和为 $S = \\sum_{l \\in \\text{leaves}} 2^{-d(l)} \\le 1$。我们可以通过选择一个深度为 $d_0$ 的叶子 $l_0$ 并将其变为内部节点来扩展该树。\n    - 如果我们给 $l_0$ 一个子节点，这个新子节点将成为一个深度为 $d_0+1$ 的叶子。原来的叶子 $l_0$ 从叶子集合中移除。新的总和 $S'$ 为：\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} = S - 2^{-d_0} + \\frac{1}{2} 2^{-d_0} = S - \\frac{1}{2} 2^{-d_0} $$\n      由于 $S \\le 1$，新的总和 $S'$ 也小于或等于 $1$。\n    - 如果我们给 $l_0$ 两个子节点，这两个新子节点将成为叶子，深度均为 $d_0+1$。原来的叶子 $l_0$ 被移除。新的总和 $S'$ 为：\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} + 2^{-(d_0+1)} = S - 2^{-d_0} + 2 \\cdot \\left(\\frac{1}{2} 2^{-d_0}\\right) = S $$\n      总和保持不变。\n\n因为我们从总和为 $1$ 开始，而这些操作要么保持总和不变，要么减少总和，所以任何有限有根二叉树的总和必须小于或等于 $1$。反之，任何满足该不等式的深度多重集都对应于一个有效的树，这也是成立的，并且可以通过构造性算法证明。\n\n我们现在将根据这个原则评估每个选项。\n\n**A. $\\{1,1,2,3\\}$**\n深度多重集为 $D = \\{1,1,2,3\\}$。我们计算总和：\n$$ S = 2^{-1} + 2^{-1} + 2^{-2} + 2^{-3} = \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} $$\n$$ S = 1 + \\frac{1}{4} + \\frac{1}{8} = \\frac{8}{8} + \\frac{2}{8} + \\frac{1}{8} = \\frac{11}{8} $$\n由于 $S = \\frac{11}{8} > 1$，不等式不成立。\n结论：**错误**。\n\n**B. $\\{2,2,3,3,3\\}$**\n深度多重集为 $D = \\{2,2,3,3,3\\}$。我们计算总和：\n$$ S = 2^{-2} + 2^{-2} + 2^{-3} + 2^{-3} + 2^{-3} = 2 \\cdot 2^{-2} + 3 \\cdot 2^{-3} $$\n$$ S = 2 \\cdot \\frac{1}{4} + 3 \\cdot \\frac{1}{8} = \\frac{1}{2} + \\frac{3}{8} = \\frac{4}{8} + \\frac{3}{8} = \\frac{7}{8} $$\n由于 $S = \\frac{7}{8} \\le 1$，不等式成立。这样的树可以被构造出来。\n结论：**正确**。\n\n**C. $\\{0,2,3\\}$**\n深度多重集 $D = \\{0,2,3\\}$ 包含深度 $0$。深度为 $0$ 的叶子意味着根是叶子。如果根是叶子，它的出度为 $0$，不能有任何子节点。因此，该树只包含一个节点。在这种树中，所有叶子深度的集合将只是 $\\{0\\}$。存在其他叶子深度 $2$ 和 $3$ 造成了矛盾。\n结论：**错误**。\n\n**D. $\\{1,3,4,4,5,5,5\\}$**\n深度多重集为 $D = \\{1,3,4,4,5,5,5\\}$。我们计算总和：\n$$ S = 2^{-1} + 2^{-3} + 2 \\cdot 2^{-4} + 3 \\cdot 2^{-5} $$\n$$ S = \\frac{1}{2} + \\frac{1}{8} + 2 \\cdot \\frac{1}{16} + 3 \\cdot \\frac{1}{32} = \\frac{1}{2} + \\frac{1}{8} + \\frac{1}{8} + \\frac{3}{32} $$\n$$ S = \\frac{1}{2} + \\frac{2}{8} + \\frac{3}{32} = \\frac{1}{2} + \\frac{1}{4} + \\frac{3}{32} $$\n为了对这些分数求和，我们使用公分母 $32$：\n$$ S = \\frac{16}{32} + \\frac{8}{32} + \\frac{3}{32} = \\frac{16+8+3}{32} = \\frac{27}{32} $$\n由于 $S = \\frac{27}{32} \\le 1$，不等式成立。这样的树可以被构造出来。\n结论：**正确**。\n\n**E. $\\{2,2,2,2\\}$**\n深度多重集为 $D = \\{2,2,2,2\\}$。我们计算总和：\n$$ S = 2^{-2} + 2^{-2} + 2^{-2} + 2^{-2} = 4 \\cdot 2^{-2} = 4 \\cdot \\frac{1}{4} = 1 $$\n由于 $S = 1 \\le 1$，不等式成立。这种树的一个简单例子是高度为 $2$ 的完美二叉树，它有 $4$ 个叶子，深度都为 $2$。\n结论：**正确**。", "answer": "$$\\boxed{BDE}$$", "id": "3280782"}, {"introduction": "掌握了树的基本属性后，我们可以将其应用于量化分析中。这个练习将带你进入一个完美二叉树的理想世界，并结合概率论进行思考。通过计算在一棵完美二叉树中随机选取的两个节点互为兄弟节点的概率 [@problem_id:3280837]，你将学会如何运用组合计数技巧来精确分析高度结构化的数据结构，这对于评估在这些结构上运行的算法的平均性能至关重要。", "problem": "考虑一个高度为 $h \\geq 1$ 的满二叉树，其中根节点的深度为 $0$，每个内部节点恰好有 $2$ 个子节点，且所有叶子节点都在深度 $h$ 处。根据定义，深度为 $d$ 的节点数量为 $2^{d}$。如果两个节点是同一个内部节点的两个不同子节点（即它们是兄弟节点），则称它们“共享一个共同的父节点”。从树中所有不同的无序节点对集合中，均匀随机地选择一对节点。仅使用满二叉树的核心定义和基本计数原理，推导出所选节点对共享一个共同父节点的概率。将你的答案表示为关于 $h$ 的闭式解析表达式。", "solution": "问题要求计算在一个高度为 $h$ 的满二叉树中，随机选择的一对不同节点共享一个共同父节点的概率。选择是从所有可能的不同节点的无序对集合中均匀随机进行的。\n\n概率 $P$ 定义为有利结果数与所有可能结果总数之比：\n$$ P = \\frac{\\text{Number of pairs sharing a common parent}}{\\text{Total number of distinct pairs of nodes}} $$\n\n首先，我们必须确定高度为 $h$ 的满二叉树中的总节点数 $N$。问题说明深度为 $d$ 的节点数为 $2^d$。由于树的高度为 $h$，深度范围从 $d=0$（根节点）到 $d=h$（叶子节点）。总节点数是每一层深度的节点数之和：\n$$ N = \\sum_{d=0}^{h} 2^d $$\n这是一个有 $h+1$ 项的有限几何级数，首项为 $2^0 = 1$，公比为 $2$。其和由公式 $S_n = a(r^n - 1)/(r - 1)$ 给出。在这里，$a=1$，$r=2$，项数 $n = h+1$。\n$$ N = \\frac{1(2^{h+1} - 1)}{2 - 1} = 2^{h+1} - 1 $$\n\n接下来，我们计算所有可能结果的总数，即从总共 $N$ 个节点中选择一个由 $2$ 个不同节点组成的无序对的方式数。这由二项式系数 $\\binom{N}{2}$ 给出：\n$$ \\text{Total pairs} = \\binom{N}{2} = \\frac{N(N-1)}{2} $$\n代入 $N$ 的表达式：\n$$ \\text{Total pairs} = \\frac{(2^{h+1} - 1)((2^{h+1} - 1) - 1)}{2} = \\frac{(2^{h+1} - 1)(2^{h+1} - 2)}{2} $$\n我们可以从分子中的第二项中提出一个因子 $2$：\n$$ \\text{Total pairs} = \\frac{(2^{h+1} - 1) \\cdot 2(2^h - 1)}{2} = (2^{h+1} - 1)(2^h - 1) $$\n\n现在，我们必须确定有利结果的数量。一个有利结果是一对共享一个共同父节点的节点。根据问题定义，这样的节点是同一个内部节点的两个不同子节点（即，它们是兄弟节点）。在一个满二叉树中，每个内部节点恰好有 $2$ 个子节点。因此，每个内部节点都恰好是这样一对节点的父节点。有利的节点对数量等于树中内部节点的数量。\n\n高度为 $h$ 的满二叉树的内部节点位于从 $d=0$ 到 $d=h-1$ 的所有深度。深度为 $h$ 的节点都是叶子节点。内部节点的数量 $I$ 是这些深度上节点数的总和：\n$$ I = \\sum_{d=0}^{h-1} 2^d $$\n这又是另一个几何级数，这次有 $h$ 项。\n$$ I = \\frac{1(2^h - 1)}{2 - 1} = 2^h - 1 $$\n所以，共享一个共同父节点的节点对数量为 $2^h - 1$。\n\n最后，我们可以通过将有利结果数除以总结果数来计算概率 $P$：\n$$ P = \\frac{2^h - 1}{(2^{h+1} - 1)(2^h - 1)} $$\n问题的定义是 $h \\geq 1$，这确保了 $2^h - 1 \\geq 2^1 - 1 = 1$。因此，项 $(2^h - 1)$ 非零，可以从分子和分母中约去。\n$$ P = \\frac{1}{2^{h+1} - 1} $$\n这就是所求概率关于高度 $h$ 的闭式解析表达式。", "answer": "$$\\boxed{\\frac{1}{2^{h+1} - 1}}$$", "id": "3280837"}, {"introduction": "从理论到实践的飞跃是学习数据结构的关键一步。本练习是一个经典的树重建问题，它要求你将后序遍历和节点深度这两个核心概念结合起来，设计一个算法来还原树的父子关系。[@problem_id:3280807] 这不仅是对你理论知识的检验，更是对你算法思维和问题分解能力的锻炼，展示了如何利用树的内在属性来解决看似复杂的反向工程问题。", "problem": "给定一棵有根有序树的后序遍历，以及遍历序列中每个节点的深度（定义为从根到该节点的边数）。请仅使用有根树、后序遍历和节点深度的基本定义，设计一个算法，以重构给定遍历顺序中每个节点的父节点。有根有序树的定义是：一个连通无环图，有一个指定的根节点，且每个节点的子节点都是有序的。后序遍历的递归定义是：对于一个节点，首先按顺序对其所有子节点进行后序遍历，然后访问该节点本身。节点的深度定义为从根到该节点的唯一简单路径上的边数。您的程序必须验证给定序列与这些定义的一致性，如果有效，则返回父节点数组；如果无效，则返回一个空列表。\n\n每个测试用例的输入模型：\n- 一个以后序遍历方式给出的节点标识符序列 $S$。标识符是任意的，但为了输出表示的方便，节点将按其在 $S$ 中的位置进行索引，即索引从 $0$ 到 $n-1$，其中 $n$ 是节点数。\n- 一个与 $S$ 等长的非负整数深度序列 $D$，其中 $D[j]$ 是 $S[j]$ 的深度。\n\n输出规范：\n- 对于每个测试用例，返回一个长度为 $n$ 的列表 $P$，其中 $P[j]$ 等于节点 $S[j]$ 的父节点在遍历顺序中的索引，如果 $S[j]$ 是根节点，则为 $-1$。\n- 如果输入序列不表示一个与给定的后序遍历和深度约束一致的有效有根有序树，则为该测试用例输出空列表 $[]$。\n- 您的程序应生成单行输出，包含一个由方括号括起来的、逗号分隔的结果列表。每个测试用例的结果本身也是一个由方括号括起来的、没有空格的逗号分隔列表。例如，输出格式必须类似于 $[[p\\_0,p\\_1,\\dots,p\\_{n-1}],[q\\_0,q\\_1,\\dots],[\\dots]]$，且在同一行上。\n\n科学真实性与基本原理：\n- 仅使用上述核心定义，并推导出重构树所需的算法属性。不要依赖未经证明的快捷公式。\n\n测试套件：\n- 案例 $1$ (通用分支)：$S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$。\n- 案例 $2$ (单个节点)：$S=[0]$, $D=[0]$。\n- 案例 $3$ (深链)：$S=[0,1,2,3]$, $D=[3,2,1,0]$。\n- 案例 $4$ (无效；末尾无根节点)：$S=[0,1]$, $D=[1,1]$。\n\n您的程序必须在内部精确处理这四个案例，并以上述格式生成最终的单行输出。", "solution": "用户提供的问题经评估有效。\n\n### 第 1 步：提取已知信息\n- **输入数据**：\n    - 一个后序遍历的节点标识符序列 $S$。节点按其在 $S$ 中的位置进行索引，从 $0$到 $n-1$，其中 $n$ 是节点数。\n    - 一个与 $S$ 等长的非负整数深度序列 $D$，其中 $D[j]$ 对应 $S$ 中索引为 $j$ 的节点的深度。\n- **要求输出**：\n    - 一个长度为 $n$ 的列表 $P$，其中 $P[j]$ 是索引为 $j$ 的节点的父节点索引。根节点的父节点为 $-1$。\n    - 如果输入序列 $S$ 和 $D$ 不一致或不代表一个有效的有根有序树，则返回空列表 $[]$。\n- **核心定义**：\n    - **有根有序树**：一个连通无环图，有一个指定的根节点，且每个节点的子节点都是有序的。\n    - **后序遍历**：对于任意节点，首先按指定顺序递归地访问其所有子节点的子树，最后访问该节点本身。\n    - **节点深度**：从根节点到该节点的唯一简单路径上的边数。根节点的深度为 $0$。\n- **测试套件**：\n    - 案例 $1$：$S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$。\n    - 案例 $2$：$S=[0]$, $D=[0]$。\n    - 案例 $3$：$S=[0,1,2,3]$, $D=[3,2,1,0]$。\n    - 案例 $4$：$S=[0,1]$, $D=[1,1]$。\n\n### 第 2 步：使用提取的已知信息进行验证\n对该问题进行严格的验证过程。\n\n- **科学依据**：该问题从根本上基于图论和数据结构中已确立的形式化定义，特别是关于有根有序树、后序遍历和节点深度的定义。这些概念在数学上是精确的，并为算法问题奠定了坚实的基础。\n- **适定性**：该问题是适定的。后序遍历序列和每个节点深度的组合提供了足够的约束，以唯一确定树中的父子关系（如果这样的树存在的话）。任务是推导出这种结构并验证其存在性。\n- **客观性**：该问题以客观、形式化的语言陈述，没有歧义或主观解释。\n- **完整性与一致性**：该问题提供了所有必要的定义和约束。从定义中可以推导出一个关键属性：任何子树的根都是该子树后序遍历中最后访问的节点。因此，整棵树的根必须是序列 $S$ 的最后一个元素，并且其深度必须为 $0$。让我们用提供的案例来测试这一点：\n    - 案例 $1$：最后一个节点索引是 $6$。$D[6] = 0$。一致。\n    - 案例 $2$：最后一个节点索引是 $0$。$D[0] = 0$。一致。\n    - 案例 $3$：最后一个节点索引是 $3$。$D[3] = 0$。一致。\n    - 案例 $4$：最后一个节点索引是 $1$。$D[1] = 1$。这违反了定义，因为根节点的深度必须为 $0$。该问题正确地将此案例识别为无效。\n该问题是自包含且内部一致的。\n\n### 第 3 步：结论与行动\n该问题是**有效**的。这是一个定义明确的算法挑战，植根于数据结构的基本原理。可以继续进行求解过程。\n\n### 基于原理的解决方案\n该解决方案是通过对后序遍历和节点深度的基本定义进行推理得出的。\n\n后序遍历序列具有一个决定性属性：父节点总是在其所有子节点的子树遍历完成之后立即被访问。这意味着对于任何节点 $v$，其父节点 $p$ 必须在后序序列中出现在更晚的位置。因此，如果节点根据其在遍历 $S$ 中的出现顺序被索引为 $0, 1, \\dots, n-1$，那么索引为 $j$ 的节点的父节点必定是某个索引为 $k > j$ 的节点。\n\n此外，深度的定义规定，对于任何带有父节点 $p$ 的节点 $v$，它们的深度关系为 $depth(v) = depth(p) + 1$。\n\n结合这两个属性提供了一种强大的重构方法。如果我们按逆序（从索引 $j = n-1$ 向下到 $0$）处理遍历序列 $S$，我们实际上是从父节点向其后代移动。在此逆向扫描的任何时刻，对于一个索引为 $j$、深度为 $D[j] = d$ 的节点，其父节点必定是某个索引为 $k > j$、深度为 $D[k] = d-1$ 的节点。关键的洞察在于识别出索引为 $k$ 的哪个节点是正确的父节点。\n\n由于后序遍历中子树的嵌套结构，索引为 $j$ 的节点的正确父节点是其右侧（即索引 $k>j$）*最近遇到*的深度为 $d-1$ 的节点。这个“最近的”节点代表了在父节点深度层级上最小的包围子树的根。\n\n这引出了以下算法：\n\n$1$. **验证**：首先，我们执行初始一致性检查。\n    - 序列不能为空。设 $n$ 为节点数。如果 $n=0$，根据问题至少有一个节点的隐含假设，这是无效的。\n    - 遍历中的最后一个节点 $S[n-1]$ 必须是根。因此，其深度 $D[n-1]$ 必须恰好为 $0$。\n    - 所有其他节点都必须是非根节点，因此它们在 $j  n-1$ 处的深度 $D[j]$ 必须大于 $0$。\n\n$2$. **重构**：我们从右到左迭代，从 $j = n-1$ 向下到 $0$。我们使用一个映射（map），称之为 `last_at_depth`，来存储每个深度层级上最近看到的节点的索引。\n    - 初始化一个大小为 $n$ 的整数数组 $P$，默认值为 $-1$。\n    - 初始化映射 `last_at_depth`。\n    - 开始循环， $j$ 从 $n-1$ 向下到 $0$：\n        a. 设当前节点的深度为 $d = D[j]$。\n        b. 如果 $d  0$，该节点必须有父节点。父节点的深度必须是 $d-1$。我们查找 `last_at_depth[d-1]`。\n            i. 如果在深度 $d-1$ 处尚未见过父节点（即 `d-1` 不是 `last_at_depth` 中的键），则深度序列与有效的树结构不一致。输入无效。\n            ii. 否则，父节点就是索引为 `last_at_depth[d-1]` 的节点。我们设置 $P[j] = \\text{last\\_at\\_depth}[d-1]$。\n        c. 如果 $d=0$（这只应对 $j=n-1$ 成立），该节点是根，其父节点保持为 $-1$。\n        d. 最后，我们用当前节点的信息更新映射：`last_at_depth[d] = j`。这将当前节点确立为后续（向左）作为其子节点的节点的潜在父节点。\n\n如果算法完成且未发现任何不一致性，数组 $P$ 就包含了该树唯一的父节点结构。\n\n让我们追踪案例 1：$S=[0,1,2,3,4,5,6]$, $D=[2,2,1,2,2,1,0]$。\n- $n=7$。$D[6]=0$，对于根节点有效。\n- 初始化 $P = [-1, -1, -1, -1, -1, -1, -1]$ 和 `last_at_depth = {}`。\n\n- $j=6$：节点索引 $6$，深度 $D[6]=0$。这是根节点。$P[6]$ 保持为 $-1$。更新 `last_at_depth[0] = 6`。\n- $j=5$：节点索引 $5$，深度 $D[5]=1$。父节点深度必须为 $0$。查找 `last_at_depth[0]`，其值为 $6$。设置 $P[5] = 6$。更新 `last_at_depth[1] = 5`。\n- $j=4$：节点索引 $4$，深度 $D[4]=2$。父节点深度必须为 $1$。查找 `last_at_depth[1]`，其值为 $5$。设置 $P[4] = 5$。更新 `last_at_depth[2] = 4`。\n- $j=3$：节点索引 $3$，深度 $D[3]=2$。父节点深度必须为 $1$。查找 `last_at_depth[1]`，其值为 $5$。设置 $P[3] = 5$。更新 `last_at_depth[2] = 3`。\n- $j=2$：节点索引 $2$，深度 $D[2]=1$。父节点深度必须为 $0$。查找 `last_at_depth[0]`，其值为 $6$。设置 $P[2] = 6$。更新 `last_at_depth[1] = 2`。\n- $j=1$：节点索引 $1$，深度 $D[1]=2$。父节点深度必须为 $1$。查找 `last_at_depth[1]`，其值为 $2$。设置 $P[1] = 2$。更新 `last_at_depth[2] = 1`。\n- $j=0$：节点索引 $0$，深度 $D[0]=2$。父节点深度必须为 $1$。查找 `last_at_depth[1]`，其值为 $2$。设置 $P[0] = 2$。更新 `last_at_depth[2] = 0`。\n\n最终的父节点数组为 $P = [2, 2, 6, 5, 5, 6, -1]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_parent_array(S, D):\n    \"\"\"\n    Reconstructs the parent array of a rooted ordered tree from its post-order\n    traversal and node depths.\n\n    Args:\n        S (list): A sequence of node identifiers in post-order. For this problem,\n                  it's assumed to be [0, 1, ..., n-1].\n        D (list): A sequence of non-negative integer depths corresponding to S.\n\n    Returns:\n        list: A list P where P[j] is the parent index of node S[j], or -1 for the root.\n              Returns an empty list if the input is invalid.\n    \"\"\"\n    n = len(S)\n    if n == 0:\n        return []\n\n    # Validation: The last node in a post-order traversal must be the root,\n    # and the root's depth must be 0.\n    if D[n - 1] != 0:\n        return []\n\n    if n == 1:\n        return [-1]\n\n    # The parent array P, initialized with -1 for all nodes.\n    # P[j] will store the index of the parent of the node at index j.\n    P = np.full(n, -1, dtype=int)\n\n    # This dictionary maps a depth level to the index of the most recently\n    # seen node at that depth.\n    last_node_at_depth = {0: n - 1}\n\n    # Iterate from the second-to-last node down to the first.\n    for j in range(n - 2, -1, -1):\n        depth = D[j]\n        \n        # Validation: All non-root nodes must have a depth greater than 0.\n        if depth == 0:\n            return []\n\n        parent_depth = depth - 1\n        \n        # Validation: A parent must exist at the required depth. If not, the\n        # depth sequence is inconsistent with a valid tree structure.\n        if parent_depth not in last_node_at_depth:\n            return []\n\n        parent_idx = last_node_at_depth[parent_depth]\n        P[j] = parent_idx\n        \n        # Record the current node as the most recently seen at its depth.\n        last_node_at_depth[depth] = j\n\n    return P.tolist()\n\n\ndef solve():\n    \"\"\"\n    Defines the test cases from the problem, solves them, and prints the\n    final output in the exact specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general branching)\n        (list(range(7)), [2, 2, 1, 2, 2, 1, 0]),\n        # Case 2 (single node)\n        (list(range(1)), [0]),\n        # Case 3 (deep chain)\n        (list(range(4)), [3, 2, 1, 0]),\n        # Case 4 (invalid; no root at the end)\n        (list(range(2)), [1, 1]),\n    ]\n\n    results = []\n    for s, d in test_cases:\n        result = reconstruct_parent_array(s, d)\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    # Example: [[-1],[1,2,3,-1]]\n    output_parts = []\n    for res in results:\n        if not res:\n            output_parts.append(\"[]\")\n        else:\n            output_parts.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n\n```", "id": "3280807"}]}