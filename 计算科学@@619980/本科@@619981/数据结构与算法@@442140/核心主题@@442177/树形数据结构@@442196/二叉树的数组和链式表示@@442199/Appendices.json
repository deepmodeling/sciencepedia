{"hands_on_practices": [{"introduction": "一棵二叉树的抽象结构可以通过其前序和中序遍历序列唯一确定。本练习旨在挑战您将这种逻辑定义直接转换为具体的隐式数组表示，这是一项将抽象算法与物理内存布局联系起来的基本技能。通过放弃构建中间链式结构，您将掌握把树的层次结构映射到数组刚性索引方案的递归逻辑。[@problem_id:3207658]", "problem": "给定一个二叉树的两个遍历数组：一个前序遍历数组和一个中序遍历数组。每个数组都包含代表树节点标签的唯一的正整数。任务是重建该二叉树，然后直接生成其隐式数组表示，而不构造任何中间的链式节点表示。\n\n基本定义：\n- 二叉树是节点的有限集合，每个节点可能有一个左孩子和一个右孩子。遍历是系统地访问所有节点的方法。\n- 深度优先搜索（DFS）前序遍历按以下顺序访问节点：根、左子树、右子树。\n- 深度优先搜索（DFS）中序遍历按以下顺序访问节点：左子树、根、右子树。\n- 二叉树的隐式数组表示定义在一个从零开始索引的数组上，如果一个节点占据索引 $i$，那么它的左孩子占据索引 $2i+1$，右孩子占据索引 $2i+2$。如果孩子不存在，相应的位置被视为空置。在本问题中，空置位置必须用哨兵值 $-1$ 填充。\n\n要求：\n- 你必须根据左、右孩子分别对应 $i \\mapsto (2i+1,\\,2i+2)$ 的映射关系，直接从遍历数组重构隐式数组表示，将每个节点值放置在正确的索引上。你不能构建或存储任何中间的链式节点结构。\n- 所有节点值都是唯一的正整数，且遍历数组描述的是一个有效的二叉树。\n\n测试套件：\n对于每个测试用例，第一个数组是前序遍历，第二个数组是中序遍历。必须重建该树，并将其隐式数组表示（空置位置用 $-1$ 填充）作为输出。\n\n1. 平衡树（正常情况）：\n   - 前序：$[4,2,1,3,6,5,7]$\n   - 中序：$[1,2,3,4,5,6,7]$\n\n2. 空树（边界情况）：\n   - 前序：$[]$\n   - 中序：$[]$\n\n3. 单节点（边界情况）：\n   - 前序：$[10]$\n   - 中序：$[10]$\n\n4. 左斜树（边缘情况）：\n   - 前序：$[5,4,3,2,1]$\n   - 中序：$[1,2,3,4,5]$\n\n5. 右斜树（边缘情况）：\n   - 前序：$[1,2,3,4,5]$\n   - 中序：$[1,2,3,4,5]$\n\n6. 混合形状（非平凡稀疏）：\n   - 前序：$[8,4,6,12,10]$\n   - 中序：$[4,6,8,10,12]$\n\n最终输出格式：\n你的程序应该生成一行输出，其中包含所有测试用例按顺序构造的数组，形式为一个用方括号括起来的逗号分隔列表。具体来说，如果有 $k$ 个测试用例，它们构造的数组分别是 $A_1, A_2, \\dots, A_k$，那么输出必须是单行 $[A_1,A_2,\\dots,A_k]$，其中每个 $A_j$ 本身是一个用方括号括起来、逗号分隔、无空格的整数列表，并且空置位置用 $-1$ 填充。", "solution": "从前序和中序遍历重构二叉树的问题是有效的。这是计算机科学中一个公认的、非平凡的问题，其基础是树遍历算法的基本性质。\n\n### 步骤 1：提取已知信息\n- **输入**：两个由唯一正整数组成的数组：一个二叉树的前序遍历数组和一个中序遍历数组。\n- **任务**：重构该树并将其表示为隐式数组。\n- **定义（前序遍历）**：根、左子树、右子树。\n- **定义（中序遍历）**：左子树、根、右子树。\n- **定义（隐式数组表示）**：位于从零开始的索引 $i$ 处的节点，其左孩子位于索引 $2i+1$，右孩子位于索引 $2i+2$。\n- **约束**：必须直接生成隐式数组表示，而不构造任何中间的链式节点数据结构。\n- **哨兵值**：输出数组中的空置位置必须用 $-1$ 填充。\n- **测试用例**：\n    1. 前序：$[4,2,1,3,6,5,7]$，中序：$[1,2,3,4,5,6,7]$\n    2. 前序：$[]$，中序：$[]$\n    3. 前序：$[10]$，中序：$[10]$\n    4. 前序：$[5,4,3,2,1]$，中序：$[1,2,3,4,5]$\n    5. 前序：$[1,2,3,4,5]$，中序：$[1,2,3,4,5]$\n    6. 前序：$[8,4,6,12,10]$，中序：$[4,6,8,10,12]$\n\n### 步骤 2：使用提取的已知信息进行验证\n问题陈述内部一致、有科学依据且定义明确。\n- **科学依据**：一个二叉树（具有唯一的节点值）由其前序和中序遍历唯一确定，这是数据结构中的一个基本定理。\n- **定义明确**：输入有清晰的定义，期望的输出格式有精确的规定。保证节点值唯一确保了可以解析出唯一的树结构。\n- **目标**：问题使用正式、无歧义的语言描述。\n\n该问题不表现出任何无效性标准。这是一个标准的算法挑战，既可以形式化，也可以解决。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。将提供一个合理的解决方案。\n\n### 基于原则的解决方案设计\n从前序和中序遍历重构二叉树的核心原则在于每种遍历所提供的特定顺序信息。\n1.  任何前序遍历序列的第一个元素始终是相应树或子树的根。\n2.  一旦知道了根节点的值，其在中序遍历序列中的位置会将所有其他节点划分为两个不相交的集合：出现在根节点左侧的节点构成左子树，出现在右侧的节点构成右子树。\n\n挑战在于应用此原则直接构造一个隐式数组表示 $A$，其中索引为 $i$ 的节点其子节点位于索引 $2i+1$（左）和 $2i+2$（右），而不创建中间的链式 `Node` 对象表示。\n\n递归方法天然适合这种分解。我们可以定义一个递归函数，该函数对前序和中序遍历的子数组（或更高效地，对索引范围）进行操作，其任务是将给定子树的根放置在最终数组中的特定目标索引处。\n\n为了管理隐式数组表示潜在的稀疏性（例如，在斜树中），并在不进行初步遍历的情况下确定最终数组的大小，我们可以使用字典或哈希映射来存储确定下来的 `(索引, 值)` 对。此映射可作为最终数组的稀疏表示。递归完成后，该映射包含所有节点的放置位置。然后，可以通过初始化一个大小为 `max_index + 1` 并填充哨兵值 $-1$ 的数组，并从该映射中填充数据，来构造最终的密集数组。\n\n算法流程如下：\n1.  为了实现高效查找，预处理中序遍历数组，将其转换为一个哈希映射 `inorder_map`，该映射将每个节点值映射到其索引。这使得在中序序列中查找根节点位置的时间复杂度为 $O(1)$，这对整体高效算法至关重要。如果没有这一步，每一步都需要 $O(N)$ 的扫描，导致算法时间复杂度为 $O(N^2)$。\n2.  定义一个递归函数 `build(pre_start, pre_end, in_start, in_end, array_idx)`，其中：\n    - `pre_start, pre_end`：当前子问题在前序数组中的起始和结束索引。\n    - `in_start, in_end`：当前子问题在中序数组中的起始和结束索引。\n    - `array_idx`：当前子树的根必须放置在概念上的输出数组中的索引。\n3.  `build` 函数的逻辑：\n    - **基本情况**：如果 `pre_start > pre_end`，则子树为空。终止此路径的递归。\n    - **识别根节点**：当前子树的根是 `root_val = preorder[pre_start]`。\n    - **放置根节点**：将根节点的值存储在我们稀疏映射的指定索引处：`tree_map[array_idx] = root_val`。\n    - **分区**：在当前中序段中找到根的索引：`in_root_idx = inorder_map[root_val]`。左子树中的节点数是 `left_subtree_size = in_root_idx - in_start`。\n    - **在左子树上递归**：左子树对应于 `preorder` 索引 `pre_start + 1` 到 `pre_start + left_subtree_size` 和 `inorder` 索引 `in_start` 到 `in_root_idx - 1`。其根将被放置在索引 `2 * array_idx + 1`。使用这些新参数进行递归调用。\n    - **在右子树上递归**：右子树对应于 `preorder` 索引 `pre_start + left_subtree_size + 1` 到 `pre_end` 和 `inorder` 索引 `in_root_idx + 1` 到 `in_end`。其根将被放置在索引 `2 * array_idx + 2`。进行第二次递归调用。\n4.  要启动该过程，进行初始调用 `build(0, N-1, 0, N-1, 0)`，其中 $N$ 是节点总数，整个树的根放置在索引 $0$ 处。\n5.  初始调用返回后，`tree_map` 将包含所有节点及其正确的索引。\n6.  如果树不为空，通过在 `tree_map` 中找到最大索引来确定所需的数组大小：`max_idx = max(tree_map.keys())`。\n7.  创建大小为 `max_idx + 1` 的最终数组，将其所有元素初始化为 $-1$，然后使用 `tree_map` 中的 `(索引, 值)` 对来填充它。\n\n这种单遍递归方法以最优的时间复杂度 $O(N)$ 正确构造了隐式数组表示，因为每个节点仅被处理一次，并且递归栈和 `inorder_map` 的空间复杂度为 $O(N)$。对于斜树，输出数组的大小在最坏情况下可能高达 $O(2^N)$，但其大小由特定树的结构动态确定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # 1. Balanced tree (happy path)\n        ([4, 2, 1, 3, 6, 5, 7], [1, 2, 3, 4, 5, 6, 7]),\n        # 2. Empty tree (boundary)\n        ([], []),\n        # 3. Single node (boundary)\n        ([10], [10]),\n        # 4. Left-skewed tree (edge case)\n        ([5, 4, 3, 2, 1], [1, 2, 3, 4, 5]),\n        # 5. Right-skewed tree (edge case)\n        ([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]),\n        # 6. Mixed shape (non-trivial sparse)\n        ([8, 4, 6, 12, 10], [4, 6, 8, 10, 12]),\n    ]\n\n    results = []\n    for preorder, inorder in test_cases:\n        result = build_implicit_array(preorder, inorder)\n        results.append(result)\n\n    # Format each result list into a string like \"[v1,v2,...]\" with no spaces\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    \n    # Print the final output as a single-line comma-separated list of these strings\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef build_implicit_array(preorder: list[int], inorder: list[int]) -> list[int]:\n    \"\"\"\n    Reconstructs the implicit array representation of a binary tree from its\n    preorder and inorder traversals.\n\n    Args:\n        preorder: A list of integers representing the preorder traversal.\n        inorder: A list of integers representing the inorder traversal.\n\n    Returns:\n        A list of integers for the implicit array representation, with -1\n        for unused positions.\n    \"\"\"\n    if not preorder:\n        return []\n\n    # O(N) step to create a map for O(1) lookups of inorder indices.\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    tree_map = {}  # Using a dictionary as a sparse array for {index: value}\n    n = len(preorder)\n\n    def build_recursive(pre_start, pre_end, in_start, in_end, array_idx):\n        \"\"\"\n        Recursively populates the tree_map.\n        \n        Args:\n            pre_start, pre_end: Slice indices for the preorder array.\n            in_start, in_end: Slice indices for the inorder array.\n            array_idx: The index in the final implicit array for the current root.\n        \"\"\"\n        # Base case: If the current subtree is empty, do nothing.\n        if pre_start > pre_end:\n            return\n\n        # The root of the current subtree is the first element in its preorder traversal.\n        root_val = preorder[pre_start]\n        tree_map[array_idx] = root_val\n\n        # Find the root's position in the inorder traversal to partition subtrees.\n        in_root_idx = inorder_map[root_val]\n        left_subtree_size = in_root_idx - in_start\n        \n        # Recurse for the left child.\n        # Its preorder traversal is the next 'left_subtree_size' elements.\n        # Its inorder traversal is the elements to the left of the root.\n        # Its array index is 2*i+1.\n        build_recursive(\n            pre_start + 1,\n            pre_start + left_subtree_size,\n            in_start,\n            in_root_idx - 1,\n            2 * array_idx + 1\n        )\n        \n        # Recurse for the right child.\n        # Its preorder traversal follows the left subtree's elements.\n        # Its inorder traversal is the elements to the right of the root.\n        # Its array index is 2*i+2.\n        build_recursive(\n            pre_start + left_subtree_size + 1,\n            pre_end,\n            in_root_idx + 1,\n            in_end,\n            2 * array_idx + 2\n        )\n\n    # Initial call for the entire tree, root at index 0.\n    build_recursive(0, n - 1, 0, n - 1, 0)\n    \n    # Determine the size of the final array from the maximum index used.\n    if not tree_map:\n        return []\n    max_idx = max(tree_map.keys())\n    \n    # Create the dense array and populate it from the sparse map.\n    # Using np.full for initialization as per environment specification.\n    result_array = np.full(max_idx + 1, -1, dtype=int)\n    for idx, val in tree_map.items():\n        result_array[idx] = val\n        \n    return result_array.tolist()\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3207658"}, {"introduction": "学习了如何构建树之后，下一个关键步骤是学习如何验证其完整性。本练习让您扮演数据结构侦探的角色，负责检查一个可能包含损坏数据的基于数组的树。通过应用严格的父子索引规则，您将识别出“孤儿”节点等结构性异常，从而巩固您对该表示法基础原则的理解。[@problem_id:3207807]", "problem": "给定一个长度为 $n$ 的数组 $A$，该数组使用从0开始的索引来编码一个二叉树。在这种表示方法中，如果索引 $i$ 处存在一个节点，那么它的左孩子位于索引 $2i + 1$ 处，右孩子位于索引 $2i + 2$ 处，前提是这些索引小于 $n$。数组条目满足以下约束：每个有效节点的键都是一个严格的正整数，而整数 $0$ 表示一个损坏或缺失的节点。您的任务是设计并实现一个算法，该算法基于二叉树的数组表示和链式表示的基本属性，来检测由损坏引起的结构不一致性。\n\n基本原理：\n- 二叉树是一个有限的节点集合，每个节点最多有两个孩子（左孩子和右孩子）。\n- 在使用从0开始的索引的数组表示中，索引 $j > 0$ 的父节点是 $p = \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor$。根节点位于索引 $0$。\n- 在任何一致的二叉树数组表示中，对于任何存在于索引 $j$ 的节点（即 $A[j] > 0$），其通往索引 $0$ 的祖先链 $j, \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor, \\left\\lfloor \\dfrac{\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor - 1}{2} \\right\\rfloor, \\dots$ 上的所有祖先也必须存在。等价地说，如果任何祖先缺失，则该节点不能存在。\n- 在链式表示中，每个存在的节点都有指向其存在的左孩子和右孩子的指针，从而形成一个父子关系图。该图的连通分量是通过只考虑存在的节点以及连接它们的父子关系来形成的。\n\n需要报告的结构不一致性：\n1. 满足 $A[j] > 0$ 且从 $j$ 到根节点的路径上至少存在一个缺失祖先的索引 $j$ 的列表（按升序排序）。这些是违反了“所有祖先必须存在”这一要求的节点。为清晰起见，这些索引被称为孤儿索引，但其定义要求检查整个祖先链，而不仅仅是直接父节点。\n2. 一个布尔值，指示根节点是否缺失但同时存在其他节点，即 $A[0] = 0$ 且存在索引 $j > 0$ 使得 $A[j] > 0$。\n3. 由存在的节点在父子关系下形成的连通分量的数量。这等于满足 $A[j] > 0$ 且 $j = 0$ 或 $A\\left[\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor\\right] = 0$ 的索引 $j$ 的数量（即，其直接父节点缺失的节点被视为分量的根）。\n\n您的程序必须为以下每个测试用例构建这些报告（数组被明确给出；键使用整数，其中 $0$ 表示损坏）：\n- 测试用例 1：$A_1 = [1, 2, 3, 4, 0, 0, 7]$，$n_1 = 7$。\n- 测试用例 2：$A_2 = [0, 2, 0, 0, 5]$，$n_2 = 5$。\n- 测试用例 3：$A_3 = [1, 0, 3, 0, 0, 6, 0, 8]$，$n_3 = 8$。\n- 测试用例 4：$A_4 = []$，$n_4 = 0$。\n- 测试用例 5：$A_5 = [9]$，$n_5 = 1$。\n\n对于每个测试用例，输出应为一个列表，其中包含：\n- 孤儿索引列表（如上定义），按升序排序。\n- 指示根节点是否缺失但同时存在其他节点的布尔值。\n- 如上定义的连通分量的整数数量。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。此顶层列表的每个元素本身都是一个具有上述结构的列表。例如，包含两个测试用例的输出将如下所示：$[[\\dots,\\dots,\\dots],[\\dots,\\dots,\\dots]]$。", "solution": "问题陈述已经过严格验证，并被评估为有效。它在科学上基于数据结构的原理，特别是二叉树的数组表示法。该问题定义明确，所有术语、约束和目标都有清晰客观的定义。没有内部矛盾、信息缺失或歧义。该问题是可形式化的，并需要一个基于所提供定义的实质性算法解决方案。\n\n任务是设计一个算法，用于分析基于数组表示的二叉树中由值为 $0$ 的损坏或缺失节点引起的三种特定类型的结构不一致性。长度为 $n$ 的数组 $A$ 使用从0开始的索引，其中对于索引 $i$ 处的节点，其左孩子和右孩子分别位于索引 $2i + 1$ 和 $2i + 2$。\n\n分析将分解为三个独立的算法，每个算法对应一份所需的报告。\n\n**1. 孤儿索引的检测**\n\n第一份要求的报告是一个排序后的“孤儿”索引列表。如果一个索引 $j$ 处的节点存在（$A[j] > 0$），但其到根节点（索引 $0$）的路径上至少有一个祖先缺失，则该索引 $j$ 被定义为孤儿。\n\n**原理：**在一个结构一致的、基于数组的二叉树中，一个非根索引 $j$ 处节点的存在，必然要求其父节点在索引 $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$ 处也存在。通过归纳法，这个要求可以扩展到从 $j$ 到根节点索引 $0$ 的整个祖先链。如果一个节点 $A[j] > 0$ 在从 $j$ 到 $0$ 的路径上有一个祖先 $A[k] = 0$，这就违反了这一原则，表明存在结构性断裂。\n\n**算法：**为了识别所有孤儿索引，我们可以遍历数组 $A$ 的每个索引 $j$（从 $1$ 到 $n-1$）。索引 $0$ 处的根节点没有祖先，因此不可能是孤儿。对于每个 $A[j] > 0$ 的索引 $j$，我们向上追溯其祖先。设一个临时变量 `current_index` 初始化为 $j$。当 `current_index` 大于 $0$ 时，我们计算父节点索引 $p = \\left\\lfloor \\frac{\\text{current\\_index}-1}{2} \\right\\rfloor$。然后我们检查 $A[p] = 0$ 是否成立。如果成立，则索引 $j$ 处的节点有一个缺失的祖先，因此将 $j$ 添加到我们的孤儿索引列表中，并且对这个特定 $j$ 的检查可以终止。如果 $A[p] > 0$，我们通过设置 `current_index = p` 继续遍历。如果循环完成而没有找到缺失的祖先，则索引 $j$ 处的节点不是孤儿。生成的索引列表将保持升序排序。\n\n**2. 识别存在节点但无根的树**\n\n第二份报告是一个布尔值，指示索引 $0$ 处的根节点是否缺失，而同时其他节点存在。\n\n**原理：**数组表示法隐含地定义了一个源自索引 $0$ 处根节点的单一层次结构。当 $A[0] = 0$ 而存在某个 $j>0$ 使得 $A[j] > 0$ 时，这种情况代表了一个基本的不一致性：树结构缺少其指定的起点，但却包含其他非空部分。\n\n**算法：**这是一个对两个条件的直接检查。首先，我们验证数组是否非空（$n>0$）且其第一个元素是否为零（$A[0] = 0$）。如果不是这种情况，则条件为假。如果是，我们接着检查数组中是否有任何其他元素为正。这可以通过从索引 $j=1$ 遍历到 $n-1$ 并检查 $A[j] > 0$ 来完成。一旦找到这样的元素，我们就可以断定整个条件为真。如果循环结束仍未找到任何正元素，则条件为假。对于空数组（$n=0$），该条件定义为假。\n\n**3. 连通分量的枚举**\n\n第三份报告是连通分量的数量。一个连通分量由通过直接父子关系连接的现有节点集合定义。\n\n**原理：**问题将分量的根定义为任何满足以下条件的现有节点（$A[j] > 0$）：该节点是主根（$j=0$），或者其直接父节点缺失（$A[\\left\\lfloor \\frac{j-1}{2} \\right\\rfloor] = 0$）。每个这样的节点都充当一个不相交子树或分量的根。因此，连通分量的总数等于这些分量根的总数。\n\n**算法：**我们将分量计数器初始化为 $0$。然后我们遍历从 $0$ 到 $n-1$ 的每个索引 $j$。对于每个索引，我们首先检查节点是否存在，即 $A[j] > 0$。如果存在，我们应用分量根测试。如果 $j=0$，根据定义它是一个分量的根，因此我们增加计数器。如果 $j>0$，我们计算其父节点的索引 $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$ 并检查 $A[p] = 0$ 是否成立。如果父节点缺失，则索引 $j$ 处的节点是一个分量的根，我们增加计数器。检查完所有索引后，计数器的最终值就是连通分量的总数。\n\n这三个算法为检测指定的结构不一致性提供了一个完整且正确的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes binary trees encoded in arrays for structural inconsistencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [1, 2, 3, 4, 0, 0, 7],       # Test case 1\n        [0, 2, 0, 0, 5],             # Test case 2\n        [1, 0, 3, 0, 0, 6, 0, 8],    # Test case 3\n        [],                          # Test case 4\n        [9],                         # Test case 5\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n\n        # 1. Detect orphan indices\n        orphan_indices = []\n        # Iterate from index 1, as the root at index 0 has no ancestors.\n        for j in range(1, n):\n            if A[j] > 0:\n                is_orphan = False\n                current_idx = j\n                # Traverse up the ancestor chain to the root\n                while current_idx > 0:\n                    # Calculate parent index using floor, as per the definition.\n                    # int() is used because np.floor returns a float.\n                    parent_idx = int(np.floor((current_idx - 1) / 2))\n                    \n                    if A[parent_idx] == 0:\n                        is_orphan = True\n                        break  # An orphan is found, no need to check further ancestors.\n                    \n                    current_idx = parent_idx\n                \n                if is_orphan:\n                    orphan_indices.append(j)\n        # The list is naturally sorted as we iterate j in ascending order.\n\n        # 2. Check for rootless tree condition\n        is_rootless = False\n        if n > 0 and A[0] == 0:\n            # Check if any other node is present\n            if any(val > 0 for val in A[1:]):\n                is_rootless = True\n\n        # 3. Count connected components\n        num_components = 0\n        for j in range(n):\n            if A[j] > 0:\n                # A present node is a component root if it is the main root (j=0)\n                # or if its immediate parent is missing.\n                if j == 0:\n                    num_components += 1\n                else:\n                    parent_idx = int(np.floor((j - 1) / 2))\n                    if A[parent_idx] == 0:\n                        num_components += 1\n\n        # Collate the results for the current test case.\n        case_result = [orphan_indices, is_rootless, num_components]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of lists is used as it matches the\n    # structure of the example output format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3207807"}, {"introduction": "标准的隐式数组表示仅仅是众多可能性之一。本练习探讨了如何将传统的链式树转换为一个为特定任务——后序遍历——而优化的定制扁平数组。您的目标是重新排列节点，使得后序遍历成为一次简单高效的线性扫描，这展示了为提升算法性能而量身定制数据结构的强大理念。[@problem_id:3207735]", "problem": "考虑一个以链接形式表示的有限、有根二叉树。该链接表示包含整数个节点 $n$，节点由其原始索引 $0,1,\\dots,n-1$ 标记。还有两个长度为 $n$ 的数组 $L$ 和 $R$，其中 $L[i]$ 是节点 $i$ 的左子节点的索引，如果左子节点不存在则为哨兵值 $-1$；$R[i]$ 是节点 $i$ 的右子节点的索引，如果右子节点不存在则为哨兵值 $-1$。树有一个指定的根索引 $r$；对于空树，根为 $-1$，数组 $L$ 和 $R$ 均为空。每个节点索引指向一个唯一的节点，且该结构是无环的，并从根节点连接到所有节点。\n\n您的任务是设计并实现一个算法，在内存中构建该树的扁平数组表示，使得后序遍历成为对该数组从索引 $0$ 到 $n-1$ 的简单线性扫描。换句话说，该数组应按原始树的精确后序顺序包含所有节点。此外，子节点指针必须更新以反映新的数组索引：对于放置在新数组位置 $i$ 的节点，其左指针应为其左子节点的新数组索引（如果没有则为 $-1$），右指针同理。\n\n该问题的基础是二叉树的定义、树遍历的定义以及深度优先搜索（DFS）的过程步骤。二叉树是一种有向无环图，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。后序遍历递归地定义为：以后序遍历左子树，然后以后序遍历右子树，最后访问节点本身。深度优先搜索（DFS）沿着树的一个分支尽可能深地探索，直到需要回溯，它可以使用显式栈迭代实现，或使用函数调用递归实现。\n\n您的程序必须为每个测试用例计算：\n- 长度为 $n$ 的数组 $A$，使得从索引 $0$ 到 $n-1$ 扫描 $A$ 会得到相对于原始链接表示的后序节点序列。\n- 在新数组坐标系中更新后的长度为 $n$ 的左子节点数组 $L'$，其中 $L'[i]$ 是位于 $A$ 中位置 $i$ 的节点的左子节点的新数组索引，如果它没有左子节点则为 $-1$。\n- 在新数组坐标系中更新后的长度为 $n$ 的右子节点数组 $R'$，其中 $R'[i]$ 是位于 $A$ 中位置 $i$ 的节点的右子节点的新数组索引，如果它没有右子节点则为 $-1$。\n\n请设计您的算法，使其运行时间与 $n$ 呈线性关系，空间也与 $n$ 呈线性关系。除给定定义外，不要假设任何特殊属性。计算必须精确，且不得依赖于未说明的启发式方法。\n\n测试套件：\n为以下测试用例提供解决方案。对于每个用例，$n$ 等于 $L$ 和 $R$ 的长度，节点标记为 $0,1,\\dots,n-1$。\n\n- 用例 $1$（空树）：$n=0$, $L=\\left[ \\right]$, $R=\\left[ \\right]$, $r=-1$。\n- 用例 $2$（单节点）：$n=1$, $L=\\left[ -1 \\right]$, $R=\\left[ -1 \\right]$, $r=0$。\n- 用例 $3$（左斜树）：$n=4$, $L=\\left[ 1,2,3,-1 \\right]$, $R=\\left[ -1,-1,-1,-1 \\right]$, $r=0$。\n- 用例 $4$（高度为 $2$ 的完全二叉树）：$n=7$, $L=\\left[ 1,3,5,-1,-1,-1,-1 \\right]$, $R=\\left[ 2,4,6,-1,-1,-1,-1 \\right]$, $r=0$。\n- 用例 $5$（有缺失子节点的树）：$n=6$, $L=\\left[ 1,-1,4,-1,-1,-1 \\right]$, $R=\\left[ 2,3,-1,-1,5,-1 \\right]$, $r=0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有五个用例的结果，形式为方括号括起来的逗号分隔列表。每个用例的结果必须是三元组 $\\left[ A, L', R' \\right]$，其中 $A$、$L'$ 和 $R'$ 是如上定义的整数列表。例如，总体输出应类似于 $\\left[ \\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4,\\text{case}_5 \\right]$，其中每个 $\\text{case}_i$ 是第 $i$ 个测试用例的三元组。", "solution": "用户提供的问题是有效的。它在计算机科学领域，特别是在数据结构和算法方面，具有科学依据。该问题定义明确，具有清晰的目标、充分的输入数据，以及对二叉树和后序遍历的明确定义。这是一个客观、可形式化的任务，没有矛盾、不成立的前提或主观断言。\n\n该问题要求将给定的有根二叉树的链接表示转换为扁平数组表示。关键约束是，对这个新数组从索引 $0$ 到 $n-1$ 的线性扫描必须等同于对原始树的后序遍历。这需要构建三个数组：一个数组 $A$，按后序包含原始节点索引；以及两个相应的数组 $L'$ 和 $R'$，包含新坐标系中更新后的子节点指针。该算法必须在与节点数 $n$ 成线性的时间和空间内运行。\n\n两遍扫描算法为该问题提供了一个高效直接的解决方案，并遵循指定的复杂度约束。\n\n### 算法设计\n\n问题的核心是根据特定的遍历顺序对树的节点重新索引。这可以分解为两个主要阶段：\n$1$. **生成后序序列**：首先，我们必须确定原始节点索引的后序序列。该序列将定义目标数组 $A$ 的内容。\n$2$. **重映射子节点指针**：一旦数组 $A$ 中节点的新顺序建立，原始的左右子节点指针必须从原始索引空间转换到数组 $A$ 的新索引空间。\n\n### 阶段 1：后序遍历\n\n二叉树的后序遍历递归定义为：\n$1$. 遍历左子树。\n$2$. 遍历右子树。\n$3$. 访问根节点。\n\n这个定义很自然地适用于递归的深度优先搜索（DFS）实现。我们可以定义一个函数，称之为 $\\text{DFS-Post-Order}(u)$，它接受一个原始节点索引 $u$ 作为输入。\n\n$\\text{DFS-Post-Order}(u)$ 的过程如下：\n- 如果节点索引 $u$ 是哨兵值 $-1$（表示一个不存在的子节点），函数立即返回。\n- 函数对 $u$ 的左子节点（由 $L[u]$ 给出）进行递归调用：$\\text{DFS-Post-Order}(L[u])$。\n- 然后函数对 $u$ 的右子节点（由 $R[u]$ 给出）进行递归调用：$\\text{DFS-Post-Order}(R[u])$。\n- 最后，在对两个子树的递归调用完成后，函数处理节点 $u$ 本身，将其索引追加到一个全局列表中。这个列表将成为我们的目标数组 $A$。\n\n通过以树的根 $r$ 为参数调用 $\\text{DFS-Post-Order}(r)$ 来启动此过程，我们将用原始节点索引按精确的后序序列填充列表 $A$。对于 $r = -1$ 的空树，此过程被简单跳过，得到一个空数组 $A$，这是正确的结果。此阶段的时间复杂度为 $O(n)$，因为DFS精确地访问每个节点和每条边一次。空间复杂度由递归栈的深度决定，为 $O(h)$，其中 $h$ 是树的高度。在退化（倾斜）树的最坏情况下，$h$ 可以是 $O(n)$，导致空间复杂度为 $O(n)$。\n\n### 阶段 2：指针重映射\n\n在阶段 $1$ 之后，我们得到了长度为 $n$ 的数组 $A$，其中 $A[i]$ 是现在占据新的后序表示中位置 $i$ 的节点的原始索引。为了计算新的指针数组 $L'$ 和 $R'$，我们需要为每个节点确定其子节点的新索引。\n\n对于一个位于新索引 $i$ 的节点，其原始索引为 $A[i]$。其原始子节点的索引为 $L[A[i]]$ 和 $R[A[i]]$。为了找到与这些原始子节点索引相对应的新索引，我们需要一个从原始索引空间到新索引空间的映射。\n\n我们定义一个大小为 $n$ 的映射数组 $M$，其中 $M[j]$ 存储原始索引为 $j$ 的节点的新索引。这个映射可以通过对数组 $A$ 的一次遍历来构建。我们用索引 $i$ 从 $0$ 到 $n-1$ 进行迭代：\n$$M[A[i]] = i$$\n这个构建过程需要 $O(n)$ 的时间和 $O(n)$ 的空间。\n\n有了映射 $M$，我们就可以构建最终的指针数组 $L'$ 和 $R'$。我们将 $L'$ 和 $R'$ 初始化为大小为 $n$ 的数组。然后我们遍历新的索引，从 $i = 0$ 到 $n-1$：\n- 位于新位置 $i$ 的节点是原始索引为 $u_{\\text{orig}} = A[i]$ 的节点。\n- 该节点的原始左子节点是 $c_L = L[u_{\\text{orig}}]$。\n- 如果 $c_L$ 不是 $-1$，它的新索引是 $M[c_L]$。我们设置 $L'[i] = M[c_L]$。否则，如果 $c_L$ 是 $-1$，我们设置 $L'[i] = -1$。\n- 类似地，对于原始右子节点 $c_R = R[u_{\\text{orig}}]$：如果 $c_R \\neq -1$，我们设置 $R'[i] = M[c_R]$；否则，设置 $R'[i] = -1$。\n\n这第二遍扫描也需要 $O(n)$ 的时间。因此，总算法的时间复杂度为 $O(n) + O(n) + O(n) = O(n)$，中间和最终数组的空间复杂度为 $O(n) + O(n) = O(n)$，满足所有问题约束。\n\n### 算法总结\n1.  处理空树情况（$n=0, r=-1$），返回三个空数组。\n2.  为后序序列初始化一个空列表 $A$。\n3.  从根节点 $r$ 开始执行递归 DFS。在对节点 $u$ 的 DFS 的后序访问步骤中，将 $u$ 追加到 $A$。\n4.  创建一个大小为 $n$ 的映射数组 $M$。通过遍历 $A$ 来填充它：对于每个 $i \\in [0, n-1]$，设置 $M[A[i]] = i$。\n5.  初始化两个结果数组 $L'$ 和 $R'$，大小为 $n$，默认值为 $-1$。\n6.  从 $i=0$ 遍历到 $n-1$：\n    a. 令 $u_{\\text{orig}} = A[i]$。\n    b. 找到原始子节点：$c_L = L[u_{\\text{orig}}]$ 和 $c_R = R[u_{\\text{orig}}]$。\n    c. 如果 $c_L \\neq -1$，设置 $L'[i] = M[c_L]$。\n    d. 如果 $c_R \\neq -1$，设置 $R'[i] = M[c_R]$。\n7.  返回三元组 $[A, L', R']$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to increase the recursion limit for deep trees,\n# although not strictly necessary for the given test cases.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Solves the tree representation problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (empty tree)\n        {'n': 0, 'L': [], 'R': [], 'r': -1},\n        # Case 2 (single node)\n        {'n': 1, 'L': [-1], 'R': [-1], 'r': 0},\n        # Case 3 (left-skewed tree)\n        {'n': 4, 'L': [1, 2, 3, -1], 'R': [-1, -1, -1, -1], 'r': 0},\n        # Case 4 (full binary tree of height 2)\n        {'n': 7, 'L': [1, 3, 5, -1, -1, -1, -1], 'R': [2, 4, 6, -1, -1, -1, -1], 'r': 0},\n        # Case 5 (tree with missing children)\n        {'n': 6, 'L': [1, -1, 4, -1, -1, -1], 'R': [2, 3, -1, -1, 5, -1], 'r': 0}\n    ]\n\n    all_results = []\n\n    def format_case_result(result_triple):\n        \"\"\"Custom formatter to produce output strings without spaces.\"\"\"\n        A, Lp, Rp = result_triple\n        A_str = f\"[{','.join(map(str, A))}]\"\n        Lp_str = f\"[{','.join(map(str, Lp))}]\"\n        Rp_str = f\"[{','.join(map(str, Rp))}]\"\n        return f\"[{A_str},{Lp_str},{Rp_str}]\"\n    \n    for case in test_cases:\n        n, L, R, r = case['n'], case['L'], case['R'], case['r']\n\n        if n == 0:\n            all_results.append(format_case_result([[], [], []]))\n            continue\n        \n        # Phase 1: Perform post-order traversal to get array A\n        A = []\n        def dfs_post_order(node_idx):\n            if node_idx == -1:\n                return\n            \n            # 1. Traverse left subtree\n            dfs_post_order(L[node_idx])\n            # 2. Traverse right subtree\n            dfs_post_order(R[node_idx])\n            # 3. Visit node\n            A.append(node_idx)\n\n        dfs_post_order(r)\n\n        # Phase 2: Remap child pointers\n        \n        # Create a map from original node index to new array index\n        original_to_new_map = [-1] * n\n        for i in range(n):\n            original_node_idx = A[i]\n            original_to_new_map[original_node_idx] = i\n\n        # Create new pointer arrays L' and R'\n        L_prime = [-1] * n\n        R_prime = [-1] * n\n\n        for i in range(n):\n            # i is the new index\n            # A[i] is the original index of the node at this new position\n            original_node_idx = A[i]\n            \n            # Get original children\n            original_left_child = L[original_node_idx]\n            original_right_child = R[original_node_idx]\n            \n            # Update left pointer for the new representation\n            if original_left_child != -1:\n                new_left_child_idx = original_to_new_map[original_left_child]\n                L_prime[i] = new_left_child_idx\n            \n            # Update right pointer for the new representation\n            if original_right_child != -1:\n                new_right_child_idx = original_to_new_map[original_right_child]\n                R_prime[i] = new_right_child_idx\n        \n        all_results.append(format_case_result([A, L_prime, R_prime]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3207735"}]}