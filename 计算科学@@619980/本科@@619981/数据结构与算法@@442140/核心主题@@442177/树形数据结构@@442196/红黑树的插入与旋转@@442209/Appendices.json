{"hands_on_practices": [{"introduction": "第一个练习提供了一个直接的、动手的机会来应用红黑树的插入规则。通过在不实际修改树的情况下，预测给定插入操作所引发的颜色翻转和旋转操作的精确序列，你将加深对修复算法逐步逻辑的理解[@problem_id:3266139]。这个练习对于将理论知识转化为对数据结构行为的实际预测分析至关重要。", "problem": "考虑一个增加了红黑属性的二叉搜索树（BST）（通常称为红黑树），其中以下核心定义成立：根节点是黑色的，每个节点要么是红色要么是黑色，每个红色节点的子节点都是黑色的，并且从根到任意叶子节点的每条路径都包含相同数量的黑色节点（黑高）。插入操作的步骤是：首先像在BST中一样放置新键，初始时将新节点染成红色，然后通过局部重新着色（仅当新插入节点的父节点和叔节点都为红色时）和由父子关系方向决定的旋转（左旋、右旋、左右旋、右左旋）来恢复红黑属性。\n\n设 $T$ 是一个有效的红黑树，其键和颜色如下。根是键为 $50$ 的黑色节点。其左子节点是键为 $30$ 的红色节点，右子节点是键为 $70$ 的黑色节点。节点 $30$ 有两个子节点：左边是键为 $20$ 的黑色节点，右边是键为 $40$ 的黑色节点。节点 $20$ 有两个子节点：左边是键为 $15$ 的红色节点，右边是键为 $25$ 的红色节点。所有其他未明确提及的子节点都是叶子节点，并且是黑色的。\n\n在不绘制或模拟对 $T$ 的操作的情况下，利用红黑属性和插入修复规则，预测插入键 $k=23$ 时触发的平衡操作的确切序列。为了得到最终的数值答案，请使用映射 $L \\mapsto 1$、$R \\mapsto 2$、$\\text{LR} \\mapsto 3$、$\\text{RL} \\mapsto 4$ 以及当父节点和叔节点都为红色时的重新着色步骤（称之为颜色翻转）$C \\mapsto 5$ 来按时间顺序对序列进行编码。如果序列包含 $m$ 个步骤，其代码为 $c_{1},c_{2},\\ldots,c_{m}$，则编码整数定义为\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i}.\n$$\n返回单个数字 $E$ 作为您的最终答案。无需四舍五入。", "solution": "我们从红黑树的不变性和二叉搜索树（BST）的插入机制开始。插入一个键的过程是，首先将新键放置在其BST位置上，并将新节点初始着色为红色。任何后续的冲突都通过局部重新着色和旋转来修复，这由以下既定事实指导：\n\n1. 如果新插入的节点有一个红色的父节点和一个红色的叔节点，则在其祖父节点处执行一次颜色翻转：父节点和叔节点被重新着色为黑色，祖父节点被重新着色为红色，之后从祖父节点继续进行修复。\n2. 如果新插入的节点有一个红色的父节点和一个黑色的叔节点，则需要进行旋转。具体的旋转类型取决于相对于祖父节点的局部配置是左-左、左-右、右-右还是右-左。在左-左情况下，在祖父节点处执行右旋；在右-右情况下，在祖父节点处执行左旋；在左-右情况下，首先在父节点处进行左旋，然后在祖父节点处进行右旋；在右-左情况下，首先在父节点处进行右旋，然后在祖父节点处进行左旋。旋转后，进行局部重新着色以恢复红黑属性，一旦当前节点的父节点为黑色，循环就终止。\n\n现在我们确定键 $k=23$ 在树 $T$ 中的BST位置：\n- 将 $23$ 与 $50$ 比较：因为 $23  50$，转到左子节点 $30$。\n- 将 $23$ 与 $30$ 比较：因为 $23  30$，转到左子节点 $20$。\n- 将 $23$ 与 $20$ 比较：因为 $23 > 20$，转到右子节点 $25$。\n- 将 $23$ 与 $25$ 比较：因为 $23  25$，插入位置是 $25$ 的左子节点。\n\n因此，带有键 $23$ 的新节点被插入为节点 $25$ 的左子节点，并初始着色为红色。\n\n插入后，立即检查新插入的红色节点周围的局部配置：\n- 父节点是节点 $25$，它是红色的。\n- 叔节点是父节点的兄弟节点，即节点 $15$，该节点也是红色的。\n- 祖父节点是节点 $20$，它是黑色的。\n\n因为父节点和叔节点都是红色的，我们在祖父节点 $20$ 处执行一次颜色翻转。根据重新着色规则，$25$ 变为黑色，$15$ 变为黑色，$20$ 变为红色。这次重新着色后，继续进行修复的当前节点是祖父节点，即节点 $20$（现在是红色）。这构成了一个颜色翻转步骤，编码为 $C \\mapsto 5$。\n\n接下来，我们检查当前节点 $20$ 及其父节点是否存在冲突：\n- $20$ 的父节点是 $30$，它是红色的。\n- 在这一层，$20$ 的叔节点是节点 $40$，它是黑色的。\n- 在这一层，祖父节点是 $50$，它是黑色的。\n- 方向如下：$20$ 是 $30$ 的左子节点，$30$ 是 $50$ 的左子节点，这是相对于 $50$ 的左-左情况。\n\n在左-左配置中，当父节点为红色且叔节点为黑色时，补救措施是在祖父节点 $50$ 处进行一次右旋，然后进行局部重新着色。在 $50$ 处执行右旋，使 $30$ 成为子树的根， $50$ 成为其右子节点，$20$ 成为其左子节点。此情况下的标准重新着色使 $30$ 变为黑色，$50$ 变为红色，从而局部恢复红黑属性并打破了红-红链。这构成了一个右旋步骤，编码为 $R \\mapsto 2$。\n\n这次旋转后，当前节点的父节点是黑色的，所以修复过程终止。因此，平衡操作的确切序列按时间顺序为：\n- 首先，一次颜色翻转 ($C$)。\n- 其次，一次右旋 ($R$)。\n\n使用规定的编码 $L \\mapsto 1$, $R \\mapsto 2$, $\\text{LR} \\mapsto 3$, $\\text{RL} \\mapsto 4$, $C \\mapsto 5$，序列 $(C, R)$ 对应于代码序列 $(5, 2)$。编码整数计算如下：\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i} \\;=\\; 5\\cdot 10^{\\,2-1} \\;+\\; 2\\cdot 10^{\\,2-2} \\;=\\; 5\\cdot 10 \\;+\\; 2\\cdot 1 \\;=\\; 50 \\;+\\; 2 \\;=\\; 52.\n$$\n因此，所需的最终数字是 $52$。", "answer": "$$\\boxed{52}$$", "id": "3266139"}, {"introduction": "在练习了追踪修复算法之后，下一个练习挑战你进行逆向思维。你不再是追踪一个插入操作的后果，而是需要构建一个插入序列，以刻意导致一个特定的复杂结果：双旋转[@problem_id:3266096]。这项任务将加深你对触发插入修复中最复杂情况的结构性条件——特别是“内侧子节点”配置——的直觉，从而巩固你对为何以及何时需要不同类型旋转的理解。", "problem": "红黑树 (RBT) 是一种增加了以下不变性的二叉搜索树 (BST)：(i) 每个节点要么是红色，要么是黑色；(ii) 根节点是黑色的；(iii) 所有外部空叶子节点都是黑色的；(iv) 没有红色节点有红色的子节点；以及 (v) 从一个节点到其任意后代外部叶子节点的每条简单路径都包含相同数量的黑色节点（黑高）。插入操作首先像在二叉搜索树中一样插入新键并将其着色为红色，然后通过一系列有限的局部重新着色和旋转来恢复不变性。在标准的教科书修复算法中，设新插入的节点为 $z$，其父节点为 $P$，其祖父节点为 $G$，其叔父节点为 $U$。当 $P$ 为红色时：\n- 情况1：$U$ 是红色的。将 $P$ 和 $U$ 重新着色为黑色，$G$ 重新着色为红色，并继续处理，令 $z \\leftarrow G$。\n- 情况2：$U$ 是黑色的，且 $z$ 是一个内侧子节点（相对于 $G$ 是“左-右”或“右-左”结构）。围绕 $P$ 旋转一次，以转变为情况3。\n- 情况3：$U$ 是黑色的，且 $z$ 是一个外侧子节点（相对于 $G$ 是“左-左”或“右-右”结构）。围绕 $G$ 旋转一次并进行适当的重新着色。最后，将根节点重新着色为黑色。\n\n在此算法中，单次插入最多可以触发2次旋转。您的任务是确定一个最小的例子（总插入键数量最少），其中单次插入在其修复过程中需要恰好2次旋转，并正确说明是哪种情况转换导致了该次插入的2次旋转。\n\n选择所有同时满足以下条件的选项：\n- 提供一个向初始为空的树中插入不同整数键的最小序列，其最后一次插入在该插入的修复过程中触发了恰好2次旋转，并且\n- 使用上面的情况编号，正确地指明了导致这2次旋转的情况转换解释。\n\nA. 按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复过程在同一个祖父节点上执行了$\\text{情况2}$，随后是$\\text{情况3}$，从而产生恰好2次旋转。\n\nB. 按顺序插入 $[10, 5, 1, 7]$。解释：最后一次插入的修复过程执行了$\\text{情况1}$，随后是$\\text{情况3}$，从而产生恰好2次旋转。\n\nC. 按顺序插入 $[10, 15, 12]$。解释：最后一次插入的修复过程执行了$\\text{情况2}$，随后是$\\text{情况3}$（“左-右”情况的镜像），从而产生恰好2次旋转。\n\nD. 按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复过程执行了$\\text{情况1}$，随后是$\\text{情况3}$，从而产生恰好2次旋转。\n\nE. 按顺序插入 $[10, 5, 3]$。解释：最后一次插入的修复过程仅为$\\text{情况3}$，产生恰好2次旋转。", "solution": "问题要求我们找到向红黑树中插入的最小序列，该序列的最后一次插入操作在修复过程中恰好引起2次旋转，并根据所给的情况定义，给出对这些旋转的正确解释。\n\n问题的核心是理解修复算法如何产生旋转。让我们分析每种情况产生的旋转次数：\n- **情况1**：叔父节点 $U$ 是红色的。这种情况只涉及节点重新着色，并通过设置 $z \\leftarrow G$ 将问题向上传播。它执行**零**次旋转。\n- **情况2**：叔父节点 $U$ 是黑色的，且 $z$ 是一个内侧子节点。这种情况围绕父节点 $P$ 执行**一次**旋转。此情况的明确目的是将结构转换为情况3的配置。\n- **情况3**：叔父节点 $U$ 是黑色的，且 $z$ 是一个外侧子节点。这种情况围绕祖父节点 $G$ 执行**一次**旋转，然后终止循环。\n\n单次插入最多可以触发2次旋转。要实现恰好2次旋转，修复过程必须执行一个情况处理序列，其旋转总数为2次。\n根据定义：\n- 一个 `情况1 -> 情况3` 的序列将包含来自情况1的零次旋转，随后是在树的更高层级上由情况3产生的一次旋转，总共为1次旋转。\n- 仅有 `情况3` 的情况会产生1次旋转。\n- 实现恰好2次旋转的唯一方法是首先遇到**情况2**，它执行1次旋转，并根据定义将子树转换为**情况3**的配置。这个情况3随后被立即处理，执行第二次旋转并终止修复过程。\n\n因此，唯一能产生恰好2次旋转的机制是 **情况2 → 情况3** 的序列。这种情况发生在修复涉及“内侧子节点”（相对于祖父节点的“左-右”或“右-左”之字形配置）的双红违规时。现在，我们基于这一原则来评估每个选项。\n\n一个最小的例子需要一个祖父-父-子结构，这意味着至少需要3个节点。选项A和C都提出了包含3个键的序列。\n\n**选项 A：按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复过程在同一个祖父节点上执行了$\\text{情况2}$，随后是$\\text{情况3}$，从而产生恰好2次旋转。**\n\n1.  插入10：树是一个单个的黑色节点，$10(\\text{B})$。\n2.  插入5：树是 $10(\\text{B}) \\leftarrow 5(\\text{R})$。这是一棵合法的红黑树。\n3.  插入7：\n    -   标准的BST插入将7作为5的右子节点。树的结构为 $10(\\text{B}) \\leftarrow 5(\\text{R}) \\rightarrow 7(\\text{R})$。\n    -   这产生了一个违规：$7(\\text{R})$ 的父节点 $5(\\text{R})$ 也是红色的。\n    -   在对 $z=7$ 的修复中：父节点 $P=5$，祖父节点 $G=10$。叔父节点 $U$（10的右子节点）是一个空叶子节点，是黑色的。\n    -   $P$ 是 $G$ 的左子节点，而 $z$ 是 $P$ 的右子节点。这是一个“左-右”配置，属于内侧子节点。这是**情况2**。\n    -   情况2的操作：对 $P=5$ 执行一次左旋。这是**第一次旋转**。现在 $G=10$ 下的子树以 $7(\\text{R})$ 作为其左子节点，而 $7(\\text{R})$ 又以 $5(\\text{R})$ 作为其左子节点。\n    -   这将结构转变为“左-左”外侧子节点配置。这现在是**情况3**。\n    -   情况3的操作：对 $G=10$ 执行一次右旋，并进行重新着色。这是**第二次旋转**。\n    -   修复过程终止。总旋转次数恰好为2。解释是正确的。\n    -   **结论：正确。**\n\n**选项 B：按顺序插入 $[10, 5, 1, 7]$。解释：最后一次插入的修复过程执行了$\\text{情况1}$，随后是$\\text{情况3}$，从而产生恰好2次旋转。**\n\n1.  插入 10, 5, 1：这些插入之后，树变为 $5(\\text{B})$，其子节点为 $1(\\text{R})$ 和 $10(\\text{R})$。\n2.  插入 7：\n    -   BST 插入将7作为10的左子节点。树的结构为：$5(\\text{B}) \\rightarrow 10(\\text{R}) \\leftarrow 7(\\text{R})$。\n    -   违规：$7(\\text{R})$ 的父节点 $P=10(\\text{R})$ 是红色的。\n    -   在对 $z=7$ 的修复中：$P=10$，$G=5$。叔父节点 $U$ 是 $G=5$ 的另一个子节点，即 $1(\\text{R})$。\n    -   由于叔父节点 $U=1$ 是红色的，这是**情况1**。\n    -   情况1的操作：将 $P(10)$ 和 $U(1)$ 重新着色为黑色，并将 $G(5)$ 重新着色为红色。$z$ 更新为 $G=5$。节点5是根节点，所以它的父节点是黑色的（空）。`while P is red` 循环终止。最后一步是将根节点着色为黑色。情况1执行**零**次旋转。\n    -   插入7导致了零次旋转。该解释在事实上是错误的，因为它声称发生了2次旋转，并且 `情况1 -> 情况3` 的序列无论如何也只会产生1次旋转。\n    -   **结论：错误。**\n\n**选项 C：按顺序插入 $[10, 15, 12]$。解释：最后一次插入的修复过程执行了$\\text{情况2}$，随后是$\\text{情况3}$（“左-右”情况的镜像），从而产生恰好2次旋转。**\n\n1.  插入10：树是一个单个的黑色节点，$10(\\text{B})$。\n2.  插入15：树是 $10(\\text{B}) \\rightarrow 15(\\text{R})$。\n3.  插入12：\n    -   BST插入将12作为15的左子节点。树的结构为：$10(\\text{B}) \\rightarrow 15(\\text{R}) \\leftarrow 12(\\text{R})$。\n    -   违规：$12(\\text{R})$ 的父节点 $P=15(\\text{R})$ 是红色的。\n    -   在对 $z=12$ 的修复中：$P=15$，$G=10$。叔父节点 $U$（10的左子节点）是一个空叶子节点，是黑色的。\n    -   $P$ 是 $G$ 的右子节点，而 $z$ 是 $P$ 的左子节点。这是一个“右-左”配置，是选项A的镜像。这是一个内侧子节点的情况。这是**情况2**。\n    -   情况2的操作：对 $P=15$ 执行一次右旋。这是**第一次旋转**。\n    -   这将结构转变为“右-右”外侧子节点配置。这现在是**情况3**。\n    -   情况3的操作：对 $G=10$ 执行一次左旋。这是**第二次旋转**。\n    -   修复过程终止，共执行了恰好2次旋转。解释是正确的。\n    -   **结论：正确。**\n\n**选项 D：按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复过程执行了$\\text{情况1}$，随后是$\\text{情况3}$，从而产生恰好2次旋转。**\n\n-   插入序列与选项A中的相同。正如已确定的，修复过程执行的是 `情况2 -> 情况3` 序列。此选项提供了不正确的解释 `情况1 -> 情况3`。`情况1` 根本不会发生。此外，一个 `情况1 -> 情况3` 的序列只会产生1次旋转，而不是2次。因此，该解释是错误的。\n-   **结论：错误。**\n\n**选项 E：按顺序插入 $[10, 5, 3]$。解释：最后一次插入的修复过程仅为$\\text{情况3}$，产生恰好2次旋转。**\n\n1.  插入 10：$10(\\text{B})$。\n2.  插入 5：$10(\\text{B}) \\leftarrow 5(\\text{R})$。\n3.  插入 3：\n    -   BST插入将3作为5的左子节点。树的结构为：$10(\\text{B}) \\leftarrow 5(\\text{R}) \\leftarrow 3(\\text{R})$。\n    -   违规：$3(\\text{R})$ 的父节点 $P=5(\\text{R})$ 是红色的。\n    -   在对 $z=3$ 的修复中：$P=5$，$G=10$。叔父节点 $U$ 是黑色的（空叶子节点）。\n    -   $P$ 是 $G$ 的左子节点，而 $z$ 是 $P$ 的左子节点。这是一个“左-左”配置，一个外侧子节点。这直接是**情况3**。\n    -   情况3的操作：执行一次旋转（对 $G=10$ 进行右旋）并重新着色。修复过程终止。\n    -   这次插入恰好产生**一次**旋转。该解释错误地声称产生了2次。\n    -   **结论：错误。**\n\n总而言之，选项A和C都提供了最小的3键插入序列，其中最后一次插入触发了恰好2次旋转，并且两者都为这一现象提供了正确的 `情况2 -> 情况3` 的解释。", "answer": "$$\\boxed{AC}$$", "id": "3266096"}, {"introduction": "最后一个练习将超越标准的算法应用，进入到调试和验证的关键技能层面。你将分析一个存在细微错误的 `LeftRotate` 实现，并设计一个输入序列来暴露其缺陷，最终导致红黑树不变量的破坏[@problem_id:3266135]。这个练习能磨练你对基于指针的数据结构和算法前置条件的推理能力，这些技能在现实世界中编写健壮和正确的代码时非常宝贵。", "problem": "考虑一棵红黑树（RBT），它维护以下不变性：（i）根节点是黑色的，（ii）每个叶子节点（哨兵节点 $\\mathsf{nil}$）都是黑色的，（iii）没有红色节点拥有红色的子节点，以及（iv）对于每个节点，从该节点到其所有后代叶子节点的简单路径都包含相同数量的黑色节点（等同的黑高）。标准插入过程首先像在二叉搜索树（BST）中一样插入一个新键，并将新节点着色为红色，然后应用由 Thomas H. Cormen、Charles E. Leiserson、Ronald L. Rivest 和 Clifford Stein (CLRS) 所著的《算法导论》（第三版）中广泛使用的修复程序来恢复红黑树的不变性。修复程序根据需要执行旋转操作；哨兵节点 $\\mathsf{nil}$ 用作共享的黑色叶子节点，并且父指针的使用与 CLRS 实现中一样。\n\n假设 `LeftRotate` 操作的实现存在以下错误：当对节点 $x$（其右子节点为 $y$）执行左旋操作时，实现省略了赋值操作 $x.\\mathrm{p} \\leftarrow y$（即 $x$ 的父指针没有更新为指向 $y$）。所有其他赋值操作均遵循标准的 CLRS `LeftRotate` 规范，包括 $y.\\mathrm{p}$ 被正确更新以及子指针被正确调整。`RightRotate` 操作的实现是正确的。每次插入后，CLRS 插入修复程序都会运行至完成。\n\n从一棵空的红黑树开始，下列哪个插入序列提供了一个最小反例，即在序列中的所有键都已插入并应用了（有错误的）修复程序后，该树违反了至少一个红黑树不变性，而其左/右子指针仍然表示一个有效的二叉搜索树？\n\nA. 插入 $10$，然后 $20$，然后 $30$，然后 $5$。\n\nB. 插入 $10$，然后 $20$，然后 $30$，然后 $25$。\n\nC. 插入 $10$，然后 $5$，然后 $1$，然后 $0$。\n\nD. 插入 $10$，然后 $2$，然后 $3$，然后 $4$。\n\n仅选择一个明确展示由所述的 `LeftRotate` 父指针错误引起的红黑树不变性违例的选项，而不是由于不正确的二叉搜索树排序或其他未指明的故障。根据第一性原理证明该选择的合理性：红黑树不变性、CLRS 插入修复逻辑以及旋转操作的指针语义。", "solution": "问题的核心在于理解错误的 `LeftRotate(x)` 操作的后果。在标准的 `LeftRotate(x)` 中，其中 $y$ 是 $x$ 的右子节点，$y$ 在树中取代了 $x$ 的位置，而 $x$ 成为 $y$ 的左子节点。最后一步 $x.p \\leftarrow y$ 对于反映这种新关系至关重要。错误在于这一步被省略了。因此，在错误的 `LeftRotate(x)` 之后，$x$ 的父指针 $x.p$ 将保留其旧值（指向 $x$ 的原始父节点），而不是指向 $y$。这造成了子/父指针之间的不一致。如果 `RB-INSERT-FIXUP` 程序中的后续操作依赖于这个损坏的父指针，就会发生 RBT 不变性违例。\n\nCLRS 中的 `RB-INSERT-FIXUP` 程序在修复节点 $z$ 与其父节点 $p$ 之间的红-红违例时，在两种情况下会调用 `LeftRotate`：\n1.  **对称情况2**：如果 $p$ 是其父节点 $g$（$z$ 的祖父节点）的左子节点，而 $z$ 是 $p$ 的右子节点。执行一次 `LeftRotate(p)`。\n2.  **情况3**：如果 $p$ 是 $g$ 的右子节点，而 $z$ 是 $p$ 的右子节点。执行一次 `LeftRotate(g)`。\n\n我们现在将追踪每个给定的插入序列，以确定哪一个会触发 `LeftRotate` 并随后因损坏的父指针而导致 RBT 不变性违例。\n\n**A. 插入 $10$，然后 $20$，然后 $30$，然后 $5$。**\n\n1.  **插入 $10$**：树为 `$10(B)$`。\n2.  **插入 $20$**：`$20(R)$` 是 `$10(B)$` 的右子节点。没有违例。树为 `$10(B) \\rightarrow 20(R)$`。\n3.  **插入 $30$**：`$30(R)$` 作为 `$20(R)$` 的右子节点插入。这产生了一个红-红违例。\n    -   $z=30(R)$, $p=z.p=20(R)$, $g=p.p=10(B)$。\n    -   父节点 $p$ 是 $g$ 的右子节点，$z$ 是 $p$ 的右子节点。这是**情况3**。\n    -   修复程序执行：\n        a. 将 $p$ 重新着色为黑色：`$20(B)$`。\n        b. 将 $g$ 重新着色为红色：`$10(R)$`。\n        c. 执行 `LeftRotate(g)`，即 `LeftRotate(10)`。\n    -   在错误的 `LeftRotate(10)` 中，设 $x=10$，$y=20$。该操作正确地使 `$20$` 成为子树的新根，`$10$` 成为其左子节点。然而，步骤 `$x.p \\leftarrow y$`（即 `$10.p \\leftarrow 20$`）被**省略**了。由于 `$10$` 是根节点，其父指针为 `nil`。因此，`$10.p$` 仍然是 `nil`。\n    -   修复后，树的子指针表示 `$20(B)$` 为根节点，左子节点为 `$10(R)$`，右子节点为 `$30(R)$`。\n    -   父指针：`$20.p$` 是 `nil`，`$30.p$` 是 `$20$`。关键在于，`$10.p$` 是 `nil`（因错误所致）。\n    -   此时，所有 RBT 不变性都成立。\n4.  **插入 $5$**：`$5(R)$` 作为 `$10(R)$` 的左子节点插入。这产生了一个红-红违例。\n    -   $z=5(R)$, $p=z.p=10(R)$。`RB-INSERT-FIXUP` 中的 `while (z.p.color == RED)` 循环开始。\n    -   在循环内部，算法计算祖父节点 `g = p.p = 10.p`。由于上一步的错误，`$10.p$` 是 `nil`。\n    -   CLRS 算法假定如果一个节点的父节点 $p$ 是红色的，那么 $p$ 不可能是根节点，因此祖父节点 $g$ 必须存在（即不为 `nil`）。这个错误违反了这一先决条件。\n    -   任何访问 $g$ 的子节点（例如，为了找到叔叔节点 `y = g.right`）的尝试都将导致空指针解引用。一个健壮的实现可能会提前终止修复程序。假设程序中止，`$5(R)$` 和 `$10(R)$` 之间的红-红违例将永远不会被解决。\n    -   最终的树状态（基于子指针）是：\n        $$\n        \\begin{array}{c}\n        20(B) \\\\\n        /   \\quad \\\\\n        10(R) \\quad 30(R) \\\\\n        / \\\\\n        5(R)\n        \\end{array}\n        $$\n    -   **验证**：\n        -   子指针表示一个有效的 BST（$5  10  20  30$）。\n        -   RBT 不变性 (iii) 被**违反**：节点 `$5(R)$` 有一个红色的父节点 `$10(R)$`。\n        -   这个违例是该错误的直接结果，该错误导致了修复失败。\n\n因此，这个序列是一个有效的反例。\n\n**B. 插入 $10$，然后 $20$，然后 $30$，然后 $25$。**\n\n1.  **插入 $10, 20, 30$**：与选项 A 相同。树的根为 `$20(B)$`，子节点为 `$10(R)$` 和 `$30(R)$`，并且存在错误的指针 `$10.p = \\text{nil}`。\n2.  **插入 $25$**：`$25(R)$` 作为 `$30(R)$` 的左子节点插入。这产生了一个红-红违例。\n    -   $z=25(R)$, $p=z.p=30(R)$, $g=p.p=20(B)$。叔叔节点 $u = g.left = 10(R)$。\n    -   这是**情况1**（红色叔叔节点）。修复程序将 $p$ (`$30$`) 重新着色为黑色，$u$ (`$10$`) 重新着色为黑色，$g$ (`$20$`) 重新着色为红色。然后，$z$ 更新为 $g$ (`$20$`)，循环继续。\n    -   新的 $z$ 是 `$20(R)$`。它的父节点 `z.p` 是 `nil`，是黑色的。循环终止。\n    -   插入的最后一步将根节点着色为黑色，所以 `$20$` 再次变为黑色。\n    -   最终的树是有效的，并且满足所有 RBT 不变性。在为 `$25$` 进行修复期间，从未访问过错误的指针 `$10.p$`。\n\n因此，这个序列不是一个反例。\n\n**C. 插入 $10$，然后 $5$，然后 $1$，然后 $0$。**\n\n这个序列完全是左侧插入。\n1.  **插入 $10, 5, 1$**：插入 `$1$` 产生了一个红-红违例（`$1(R), 5(R)$`）。$p = 5$ 是 $g = 10$ 的左子节点，$z = 1$ 是 $p$ 的左子节点。这是对称情况3，它会触发 `RightRotate(10)`。\n2.  **插入 $0$**：插入 `$0$` 产生了一个红-红违例（`$0(R), 1(R)$`）。这会触发情况1的修复（红色叔叔节点）。\n整个序列只涉及 `RightRotate` 操作，而这些操作被指定为是正确的。有错误的 `LeftRotate` 从未被调用。因此，生成的树将是一个有效的 RBT。\n\n因此，这个序列不是一个反例。\n\n**D. 插入 $10$，然后 $2$，然后 $3$，然后 $4$。**\n\n1.  **插入 $10, 2$**：树为 `$10(B) \\leftarrow 2(R)$`。\n2.  **插入 $3$**：`$3(R)$` 作为 `$2(R)$` 的右子节点插入。红-红违例。\n    -   $z=3(R)$, $p=2(R)$, $g=10(B)$。\n    -   $p$ 是 $g$ 的左子节点，$z$ 是 $p$ 的右子节点。这是**对称情况2**。\n    -   修复程序设置 $z \\leftarrow p$（所以 $z$ 变成 `$2$`）并执行 `LeftRotate(z)`（即 `LeftRotate(2)`）。\n    -   有错误的 `LeftRotate(2)` 被调用。设 $x=2, y=3$。`$2$` 的父节点是 `$10$`。该操作省略了 `$x.p \\leftarrow y$`（`$2.p \\leftarrow 3$`)，所以 `$2.p$` 仍然指向 `$10$`。\n    -   修复继续，转变为对称情况3，执行一次正确的 `RightRotate(10)`。所有操作完成后，树是一个有效的 RBT，但内部状态不一致：`$3$` 的子节点是 `$2$`，但 `$2.p$` 指向 `$10$`。\n3.  **插入 $4$**：插入 `$4(R)`，导致红-红违例。修复是情况1（红色叔叔节点）。修复操作读取了叔叔节点 `$2$` 的颜色，但没有使用 `$2$` 的父指针进行导航。错误的指针 `$2.p$` 从未被访问。最终的树满足所有 RBT 不变性。\n\n因此，这个序列不是一个反例，因为尽管错误被触发了，但它没有导致最终的树违反四个外部 RBT 不变性中的任何一个。\n\n### 结论\n\n只有选项 A 的插入序列会导致这样一种状态：错误的 `LeftRotate` 导致父指针损坏，这反过来又导致后续的 `RB-INSERT-FIXUP` 失败，使树处于违反红-红属性（RBT 不变性 iii）的状态。\n\n**选项最终分析：**\n-   **A**：产生了一个红-红违例，由于修复程序因错误而失败，该违例未被修复。**正确**。\n-   **B**：错误被触发，但后续插入的修复不依赖于损坏的指针。最终的树是一个有效的 RBT。**不正确**。\n-   **C**：有错误的 `LeftRotate` 从未被调用。最终的树是一个有效的 RBT。**不正确**。\n-   **D**：错误被触发，产生了一个不一致的父指针，但后续的修复没有以违反 RBT 不变性的方式暴露这种不一致。最终的树是一个有效的 RBT。**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3266135"}]}