{"hands_on_practices": [{"introduction": "表达式树以其结构明确了运算的先后顺序，但我们更习惯使用中缀表示法，它依赖于运算符的优先级和结合性规则。本练习旨在连接这两种表示方式。通过为一个表达式树生成带有最少括号的中缀字符串，你将亲手实现这些解析规则，从而加深对运算符优先级和结合性如何影响表达式结构的理解。[@problem_id:3232525]", "problem": "实现一个程序，该程序为给定的一组表达式树，生成相应的中缀表达式字符串。这些字符串必须使用最少数量的必要括号，以确保在常规的运算符优先级和结合性解析规则下，能够唯一且精确地重构出原始树。必须打印的输出是每棵树所用括号对的数量，这些数量汇总在单行中，形式为方括号括起来的逗号分隔列表。\n\n表达式树是一种有根有序树，其中每个内部节点都是一个运算符，每个叶节点则是一个变量或常量。本问题中的规范运算符及其常规解析规则定义如下：\n- 二元运算符：$+$, $-$, $\\times$, $\\div$, 和 $^$。\n- 一元前缀运算符：$-$（一元取反）。\n- 优先级（从高到低）：$^$ 的优先级为 $4$，一元 $-$ 的优先级为 $3$，$\\times$ 和 $\\div$ 的优先级为 $2$，以及 $+$ 和 $-$ 的优先级为 $1$。\n- 结合性：$^$ 是右结合的，$+$, $-$, $\\times$, 和 $\\div$ 是左结合的。一元 $-$ 以常规方式作用于其单个操作数，其计算先于任何优先级较低的二元运算符。\n\n本任务的基础是表达式树的定义以及关于运算符优先级和结合性的经过充分验证的解析事实：在解析中缀表示法时，较高优先级的运算符比低优先级的运算符绑定得更紧密，而当优先级相同时，结合性决定了分组方式（$^$ 向右分组；$+$, $-$, $\\times$, 和 $\\div$ 向左分组）。括号在局部覆盖这些默认的分组规则。你的目标是从这些基础定义出发，推导出一个算法，该算法能够精确地判断何时需要在子表达式周围添加括号，以确保打印出的中缀字符串能解析回原始树。\n\n你的程序必须在内部构建并美化打印以下表达式树测试套件。每棵树都使用节点构造函数以结构化形式指定，为便于阅读，其中的变量和常量以 LaTeX 格式显示，但你的程序应将它们表示为标准的树结构。为清晰起见，令 $\\operatorname{Bin}(op, L, R)$ 表示一个二元节点，其运算符为 $op$，左右子节点分别为 $L$ 和 $R$；令 $\\operatorname{Un}(op, C)$ 表示一个一元节点，其运算符为 $op$，子节点为 $C$。令 $\\operatorname{Var}(name)$ 和 $\\operatorname{Const}(value)$ 表示叶节点。\n\n测试套件（涵盖正常路径、结合性和优先级边界、一元运算符交互以及嵌套边界情况）：\n1. $\\operatorname{Var}(x)$\n2. $\\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n3. $\\operatorname{Bin}(-, \\operatorname{Var}(a), \\operatorname{Bin}(-, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n4. $\\operatorname{Bin}(\\div, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n5. $\\operatorname{Bin}(^, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c))$\n6. $\\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Bin}(^, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n7. $\\operatorname{Un}(-, \\operatorname{Bin}(\\times, \\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c)))$\n8. $\\operatorname{Bin}(^, \\operatorname{Un}(-, \\operatorname{Var}(a)), \\operatorname{Un}(-, \\operatorname{Var}(b)))$\n9. $\\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Bin}(\\times, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n10. $\\operatorname{Un}(-, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)))$\n\n你的程序必须实现一个美化打印器，该打印器为每个节点根据优先级和结合性规则决定是否用括号包裹其子表达式，以便在使用相同的规则重新解析打印出的字符串时，能够精确地重构出原始表达式树。在为每个测试用例生成美化打印的字符串后，你的程序应计算该字符串中使用的括号对的整数数量（每个 \"(\" 字符的出现必须匹配一个对应的 \")\"，并计为一对）。这个数量就是相应测试用例的结果。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 `[r_1,r_2,...,r_10]`，其中每个 $r_i$ 是测试用例 $i$ 的括号对整数数量。\n\n不涉及物理单位。不出现角度。不出现百分比。答案为整数。\n\n请通过遵守上述基本定义和事实来确保科学真实性。算法不得依赖任何预设最终决策规则的捷径；相反，应从运算符的优先级和结合性属性中推导出何时添加括号的决策。", "solution": "问题在于，确定将给定表达式树表示为中缀字符串所需的最少括号对数量，以确保根据标准的运算符优先级和结合性规则解析该字符串时，能够重构出原始树。\n\n### 步骤1：问题形式化与最小化原则\n\n表达式树的结构明确定义了运算的顺序。然而，中缀字符串则依赖解析规则来确定这个顺序。括号只服务于一个目的：当默认的解析规则与树的结构发生冲突时，覆盖这些规则。最小化原则规定，我们只应在缺少括号会导致生成不同解析树时才插入括号。\n\n是否为子表达式添加括号的决定，取决于子表达式根部的运算符（“子”运算符）与其在树中父节点的运算符（“父”运算符）之间的相互作用。\n\n让我们按照给定的信息定义运算符属性：\n- **优先级**：从运算符到整数的映射，其中较高的值表示较高的优先级。\n  - `$P(^) = 4$`\n  - `$P(\\text{unary}-) = 3$`\n  - `$P(\\times), P(\\div) = 2$`\n  - `$P(+), P(-) = 1$`\n- **结合性**：对相同优先级的运算符进行分组的规则。\n  - 右结合 (`R`)：`$^$`（例如，$a \\wedge b \\wedge c \\equiv a \\wedge (b \\wedge c)$）\n  - 左结合 (`L`)：`$+, -, \\times, \\div$`（例如，$a - b - c \\equiv (a - b) - c$）\n\n### 步骤2：括号添加规则的推导\n\n我们可以通过分析默认解析会改变树结构的情况，来推导出需要添加括号的条件。我们考虑树中的一个节点 $N$，它对应一个子表达式。令 $op_N$ 为节点 $N$ 处的运算符，令 $P$ 为其父节点，运算符为 $op_P$。\n\n#### 规则1：优先级冲突\n如果运算符 $op_N$ 的优先级低于其父运算符 $op_P$，则节点 $N$ 处的运算必须用括号括起来。若不加括号，高优先级的父运算符 $op_P$ 将会与 $N$ 的某个直接操作数绑定，从而改变树的结构。\n- **条件**：如果 $P(op_N)  P(op_P)$，则添加括号。\n- **示例**：对于树 `$\\operatorname{Bin}(\\div, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$`，它表示 `$a / (b+c)$`。父运算符是 `$\\div$` ($P=2$)，子运算符是 `$+$` ($P=1$)。由于 $P(+)  P(\\div)$，子表达式 `$(b+c)$` 需要括号。如果省略括号，`$a / b + c$` 将被解析为 `$(a/b)+c$`。\n\n#### 规则2：结合性冲突\n如果 $op_N$ 和 $op_P$ 具有相同的优先级，结合性规则将决定默认的分组方式。如果树的结构与此默认分组相矛盾，则需要括号。\n\n- **情况2a：左结合运算符** (`$+, -, \\times, \\div$`)\n  - 这些运算符从左到右分组。结构 `$(L \\, op \\, M) \\, op \\, R$` 是默认形式。\n  - 如果一个带有运算符 $op_N$ 的节点 $N$ 是一个带有相同优先级的左结合运算符 $op_P$ 的节点 $P$ 的 *右* 子节点，则需要括号。\n  - **条件**：如果 $P(op_N) = P(op_P)$，$op_P$ 是左结合的，且 $N$ 是右子节点，则添加括号。\n  - **示例**：对于 `$\\operatorname{Bin}(-, \\operatorname{Var}(a), \\operatorname{Bin}(-, \\operatorname{Var}(b), \\operatorname{Var}(c)))$`，它表示 `$a - (b-c)$`。两个运算符都是 `-`，它是左结合的。子表达式 `$(b-c)$` 是右子节点。省略括号会得到 `$a-b-c$`，它将被解析为 `$(a-b)-c$`，这是一棵不同的树。\n\n- **情况2b：右结合运算符** (`$^$`)\n  - 该运算符从右到左分组。结构 `$L \\, op \\, (M \\, op \\, R)$` 是默认形式。\n  - 如果一个带有运算符 $op_N$ 的节点 $N$ 是一个带有相同优先级的右结合运算符 $op_P$ 的节点 $P$ 的 *左* 子节点，则需要括号。\n  - **条件**：如果 $P(op_N) = P(op_P)$，$op_P$ 是右结合的，且 $N$ 是左子节点，则添加括号。\n  - **示例**：对于 `$\\operatorname{Bin}(^, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c))$`，它表示 `$(a^b)^c$`。两个运算符都是 `$^$`，它是右结合的。子表达式 `$(a^b)$` 是左子节点。省略括号会得到 `$a^b^c$`，它将被解析为 `$a^(b^c)$`。\n\n#### 规则3：一元减号（`$-$`）的特殊情况\n\n一元减号运算符引入了一些独特的场景。\n\n- **情况3a：一元子表达式作为二元运算符的子节点。**\n  - 如果 `$\\operatorname{Un}(-, C)$` 是二元运算符 $op_P$ 的 *左* 子节点，并且 $P(\\text{unary}-)  P(op_P)$，则需要括号。\n  - **示例**：`$\\operatorname{Bin}(^, \\operatorname{Un}(-, \\operatorname{Var}(a)), \\operatorname{Var}(b))$` 表示 `$(-a)^b$`。这里，$P(\\text{unary}-) = 3$ 且 $P(^) = 4$。如果不加括号，字符串 `-a^b` 会被解析为 `-(a^b)`，因为 `$^$` 具有更高的优先级。因此，括号是强制性的：`(-a)^b`。\n\n  - 如果 `$\\operatorname{Un}(-, C)$` 是二元运算符 $op_P$ 的 *右* 子节点，通常不需要括号，例如 `$a \\times -b$`，它明确地表示 `$a \\times (-b)$`。\n  - **例外**：如果父运算符 $op_P$ 本身是二元减号，则需要括号以避免歧义。\n  - **示例**：对于表示 `$a - (-b)$` 的表达式树，字符串 `$a - -b$` 在许多上下文中是语法无效或有歧义的。因此括号是必需的：`$a - (-b)$`。\n\n- **情况3b：二元子表达式作为一元减号的子节点。**\n  - 如果一个带有运算符 $op_N$ 的节点 $N$ 是 `$\\operatorname{Un}(-, ...)$` 的子节点，规则更简单：如果 $P(op_N)  P(\\text{unary}-)$，则需要括号。\n  - **示例**：`$\\operatorname{Un}(-, \\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Var}(b)))$` 表示 `$-(a+b)$`。由于 $P(+)  P(\\text{unary}-)$，需要括号。`-a+b` 会被解析为 `(-a)+b`。\n\n### 步骤3：算法实现\n\n这些推导出的规则可以在一个遍历表达式树的递归函数中实现。函数 `get_paren_count(node, parent_op, is_right_child)` 计算以 `node` 为根的子树所需的括号对数量。\n\n1.  **基本情况**：如果 `node` 是一个叶节点（`Var` 或 `Const`），它需要 `$0$` 对括号。\n2.  **递归步骤**：\n    a. 对 `node` 的所有子节点递归调用 `get_paren_count`，将 `node` 的运算符作为新的 `parent_op` 传入。将这些调用返回的计数相加。\n    b. 应用推导出的规则，根据 `node.op`、`parent_op` 及其位置（`is_right_child`），确定 `node` 自身的子表达式是否需要加括号。\n    c. 如果需要括号，则将总计数加 `$1$`。\n    d. 返回总计数。\n\n该算法系统地应用运算符解析的基本原则来计算所需的最小括号数，确保生成的中缀字符串既正确又简洁。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Data Structures for Expression Trees ---\n\nclass Node:\n    \"\"\"Base class for a node in an expression tree.\"\"\"\n    def __init__(self, op):\n        self.op = op\n\nclass Var(Node):\n    \"\"\"Represents a variable or constant (a leaf node).\"\"\"\n    def __init__(self, name):\n        super().__init__(name)\n    def __repr__(self):\n        return f\"Var({self.op})\"\n\nclass UnaryOp(Node):\n    \"\"\"Represents a unary operation.\"\"\"\n    def __init__(self, op, child):\n        super().__init__(op)\n        self.child = child\n    def __repr__(self):\n        return f\"UnaryOp({self.op}, {self.child})\"\n\nclass BinaryOp(Node):\n    \"\"\"Represents a binary operation.\"\"\"\n    def __init__(self, op, left, right):\n        super().__init__(op)\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"BinaryOp({self.op}, {self.left}, {self.right})\"\n\n# --- Problem Definition: Operators and Rules ---\n\nOP_INFO = {\n    # Operator: (precedence, associativity)\n    '^': (4, 'R'),\n    'u-': (3, 'R'), # Unary minus\n    '*': (2, 'L'),\n    '/': (2, 'L'),\n    'x': (2, 'L'), # For representation of the multiplication symbol\n    '÷': (2, 'L'), # For representation of the division symbol\n    '+': (1, 'L'),\n    '-': (1, 'L'), # Binary minus\n}\n\ndef solve():\n    \"\"\"\n    Main function to construct test cases and compute parenthesis counts.\n    \"\"\"\n    # --- Test Suite Construction ---\n    \n    # Aliases for brevity in test case definitions\n    Bin = BinaryOp\n    Un = UnaryOp\n    V = Var\n    \n    # Test cases defined as per the problem statement's structural form.\n    # LaTeX representations: +, -, ×, ÷, ^\n    test_cases = [\n        # 1. Var(x)\n        V('x'),\n        # 2. Bin(+, Var(a), Bin(+, Var(b), Var(c)))\n        Bin('+', V('a'), Bin('+', V('b'), V('c'))),\n        # 3. Bin(-, Var(a), Bin(-, Var(b), Var(c)))\n        Bin('-', V('a'), Bin('-', V('b'), V('c'))),\n        # 4. Bin(÷, Var(a), Bin(+, Var(b), Var(c)))\n        Bin('÷', V('a'), Bin('+', V('b'), V('c'))),\n        # 5. Bin(^, Bin(^, Var(a), Var(b)), Var(c))\n        Bin('^', Bin('^', V('a'), V('b')), V('c')),\n        # 6. Bin(^, Var(a), Bin(^, Var(b), Var(c)))\n        Bin('^', V('a'), Bin('^', V('b'), V('c'))),\n        # 7. Un(-, Bin(×, Bin(+, Var(a), Var(b)), Var(c)))\n        Un('u-', Bin('x', Bin('+', V('a'), V('b')), V('c'))),\n        # 8. Bin(^, Un(-, Var(a)), Un(-, Var(b)))\n        Bin('^', Un('u-', V('a')), Un('u-', V('b'))),\n        # 9. Bin(+, Var(a), Bin(×, Var(b), Var(c)))\n        Bin('+', V('a'), Bin('x', V('b'), V('c'))),\n        # 10. Un(-, Bin(^, Var(a), Var(b)))\n        Un('u-', Bin('^', V('a'), V('b'))),\n    ]\n\n    results = []\n    for tree in test_cases:\n        count = get_paren_count(tree, parent_op=None, is_right_child=False)\n        results.append(count)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef needs_parens(node, parent_op, is_right_child):\n    \"\"\"\n    Determines if a subexpression rooted at `node` needs parentheses.\n    This function implements the derived rules for parenthesization.\n    \"\"\"\n    if parent_op is None:\n        return False\n\n    node_op = node.op\n    p_node, assoc_node = OP_INFO[node_op]\n    p_parent, assoc_parent = OP_INFO[parent_op]\n\n    # Rule 1: Precedence conflict\n    if p_node  p_parent:\n        return True\n\n    # Rule 2: Associativity conflict for binary operators\n    if isinstance(node, BinaryOp) and p_node == p_parent:\n        if assoc_parent == 'L' and is_right_child:\n            return True\n        if assoc_parent == 'R' and not is_right_child:\n            return True\n\n    # Rule 3: Special cases for UnaryOp children\n    if isinstance(node, UnaryOp):\n        # Case `(-a)^b`: precedence of u- is less than ^\n        if not is_right_child and p_node  p_parent:\n            return True\n        # Case `a - (-b)`\n        if is_right_child and parent_op == '-':\n            return True\n            \n    return False\n\ndef get_paren_count(node, parent_op, is_right_child):\n    \"\"\"\n    Recursively traverses the tree to count the minimum required parenthesis pairs.\n    \"\"\"\n    if isinstance(node, Var):\n        return 0\n\n    count = 0\n    if isinstance(node, UnaryOp):\n        # Recurse on the single child\n        # The child's position is irrelevant for a unary parent\n        count += get_paren_count(node.child, node.op, False)\n    elif isinstance(node, BinaryOp):\n        # Recurse on left and right children\n        count += get_paren_count(node.left, node.op, False)\n        count += get_paren_count(node.right, node.op, True)\n\n    # Check if the current node's subexpression needs parentheses\n    if needs_parens(node, parent_op, is_right_child):\n        count += 1\n        \n    return count\n\n# Execute the solution\nsolve()\n\n```", "id": "3232525"}, {"introduction": "将抽象的数学表达式转化为机器可以执行的指令，是编译器的核心任务之一，而表达式树在其中扮演着关键角色。本练习将指导你完成这一过程的模拟：将表达式树转换为一个简单的基于栈的虚拟机指令序列。你会发现，对树进行后序遍历可以自然地生成逆波兰表达式（RPN），这正是栈式计算机最高效的求值方式，从而具体地体验从高级语言到低级代码的转换过程。[@problem_id:3232522]", "problem": "给定有根、有序的表达式树，其中每个内部节点是一个运算符，每个叶节点是一个变量或一个常量。目标是将每个表达式树转换为一个扁平的整数编码指令序列，供一个基于栈的虚拟机使用。当该序列被执行时，它会根据实数算术的语义对表达式进行求值。这些语义是根据树的结构和后进先出栈的行为从第一性原理定义的。\n\n基本定义：\n- 表达式树是一个有限有根有序树。每个叶节点代表一个常量或一个变量。每个一元运算符节点恰好有一个子节点，每个二元运算符节点恰好有两个子节点。设一棵树所计算的整个表达式记为 $E$，其求值过程通过树的结构递归定义。\n- 基于栈的虚拟机维护一个值栈 $S$。指令以确定性的方式对 $S$ 进行操作。\n\n指令集与编码：\n- 操作码是整数代码，映射关系如下：\n  - $0$：压入常量，记为 $\\text{PUSH\\_CONST}$，它带一个立即数操作数，即常量值。\n  - $1$：压入变量，记为 $\\text{PUSH\\_VAR}$，它带一个立即数操作数，即变量的非负整数索引。\n  - $2$：加法，记为 $\\text{ADD}$，它从 $S$ 中弹出栈顶两个元素 $r$ 和 $l$（其中 $r$ 是右操作数，$l$ 是左操作数），然后压入 $l + r$。\n  - $3$：减法，记为 $\\text{SUB}$，它弹出 $r$ 和 $l$，然后压入 $l - r$。\n  - $4$：乘法，记为 $\\text{MUL}$，它弹出 $r$ 和 $l$，然后压入 $l \\times r$。\n  - $5$：除法，记为 $\\text{DIV}$，它弹出 $r$ 和 $l$，然后压入 $l / r$。\n  - $6$：一元取反，记为 $\\text{NEG}$，它弹出 $a$，然后压入 $-a$。\n  - $7$：幂运算，记为 $\\text{POW}$，它弹出 $r$ 和 $l$，然后压入 $l^r$。\n- 指令流是一个扁平的整数列表。对于 $\\text{PUSH\\_CONST}$ 和 $\\text{PUSH\\_VAR}$，操作码后面紧跟着整数操作数（分别是常量值或变量索引）。对于所有其他操作码，指令仅为单个操作码整数。\n- 变量由非负整数索引标识。例如，变量 $x$ 可能绑定到索引 $0$，变量 $y$ 绑定到索引 $1$，依此类推。常量是整数；假设它们在 $64$ 位有符号整数范围内。\n\n要求的编译语义：\n- 表达式树的指令序列必须通过对树的后序遍历（先子节点后父节点）产生，并按如下方式生成指令：\n  - 对于值为 $c$ 的常量叶节点：生成 $[0, c]$。\n  - 对于索引为 $i$ 的变量叶节点：生成 $[1, i]$。\n  - 对于带子节点 $u$ 的一元取反节点：先生成 $u$ 的序列，然后生成 $[6]$。\n  - 对于带左子节点 $L$ 和右子节点 $R$ 且运算符为 $\\oplus \\in \\{+, -, \\times, \\div, \\wedge\\}$ 的二元运算符节点：先生成 $L$ 的序列，再生成 $R$ 的序列，然后生成与 $\\oplus$ 对应的操作码（即，$+$ 对应 $[2]$，$-$ 对应 $[3]$，$\\times$ 对应 $[4]$，$\\div$ 对应 $[5]$，$\\wedge$ 对应 $[7]$）。\n\n科学真实性与通用性：\n- 该方法必须从表达式树和上述确定性栈语义的核心定义推导得出，不依赖于这些定义之外的捷径。\n- 在这些语义下，编译后的序列必须对任何由支持的运算符组成的表达式都正确。\n\n测试套件：\n- 使用以下五个不同的表达式树和变量索引绑定来测试您的编译。对于每种情况，根据上述编码，生成相应的指令流作为整数列表。\n  - 情况 $1$（通用二元组合）：$(x + 3) \\times (y - 2)$，其中 $x$ 映射到索引 $0$，$y$ 映射到索引 $1$。\n  - 情况 $2$（一元与二元混合）：$(-x) + 5$，其中 $x$ 映射到索引 $0$。\n  - 情况 $3$（幂运算与除法）：$\\dfrac{a^{3}}{b + 1}$，其中 $a$ 映射到索引 $2$，$b$ 映射到索引 $3$。\n  - 情况 $4$（单个常量）：$42$。\n  - 情况 $5$（深度左结合减法）：$(((x - 1) - 2) - 3)$，其中 $x$ 映射到索引 $0$。\n  - 情况 $6$（双重一元取反）：$-(-(c))$，其中 $c$ 映射到索引 $5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，且任何地方都没有空格。每个元素应该是对应于一个测试用例的内部指令列表，按情况 $1$ 到情况 $6$ 的顺序排列。例如，生成类似 `[[i_{1,1},i_{1,2},...],[i_{2,1},...],...]` 的内容，其中每个 $i_{k,j}$ 是一个整数。确保确切的格式没有空格。", "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于计算机科学的原理，特别是关于数据结构（表达式树）和编译理论（栈式机和指令编码）。该问题是适定的，具有一套清晰、客观、完备的定义和约束，可以为每个测试用例推导出唯一且可验证的解。\n\n将表达式树转换为基于栈的虚拟机指令序列的核心原理是后序遍历算法。后序遍历先访问左子节点，再访问右子节点（对于二元节点），最后访问父节点。这种`左-右-父`的顺序自然对应于逆波兰表示法（RPN），或称后缀表示法，其中操作数出现在其运算符之前。基于栈的机器被设计用来高效地计算 RPN 表达式：它将操作数压入栈，当遇到运算符时，弹出所需数量的操作数，执行运算，然后将结果压回栈中。\n\n该问题要求我们将此过程形式化为一个编译算法。我们将为以节点 $N$ 为根的给定子树生成指令序列的函数表示为 $\\text{Compile}(N)$。$\\text{Compile}(N)$ 的输出是一个代表机器指令的扁平整数列表。该函数的行为根据节点 $N$ 的类型递归定义。\n\n指令集用整数操作码定义：\n- $\\text{PUSH\\_CONST} = 0$：带一个操作数（常量值）。\n- $\\text{PUSH\\_VAR} = 1$：带一个操作数（变量索引）。\n- $\\text{ADD} = 2$, $\\text{SUB} = 3$, $\\text{MUL} = 4$, $\\text{DIV} = 5$：二元运算符。\n- $\\text{NEG} = 6$：一元运算符。\n- $\\text{POW} = 7$：二元运算符。\n\n编译算法由以下规则定义：\n\n1.  **基本情况：叶节点**\n    - 如果节点 $N$ 是值为 $c$ 的常量叶节点，机器必须将此常量压入栈。指令序列为 $[\\text{PUSH\\_CONST}, c]$。因此，$\\text{Compile}(N) = [0, c]$。\n    - 如果节点 $N$ 是索引为 $i$ 的变量叶节点，机器必须将该变量的值压入栈。指令序列为 $[\\text{PUSH\\_VAR}, i]$。因此，$\\text{Compile}(N) = [1, i]$。\n\n2.  **递归情况：一元运算符节点**\n    - 如果节点 $N$ 是一个带单个子节点 $U$ 的一元运算符（例如，取反 $\\text{NEG}$），后序遍历规定我们首先处理子树。求值要求操作数（即计算 $U$ 的结果）在应用运算符之前位于栈上。因此，我们首先为子节点生成指令，然后附加运算符的操作码。\n    - $\\text{Compile}(N) = \\text{Compile}(U) \\oplus [\\text{OP}_{\\text{unary}}]$，其中 $\\oplus$ 表示列表拼接，$\\text{OP}_{\\text{unary}}$ 是一元运算符的操作码（例如，$\\text{NEG}$ 对应 $6$）。\n\n3.  **递归情况：二元运算符节点**\n    - 如果节点 $N$ 是一个带左子节点 $L$ 和右子节点 $R$ 的二元运算符（例如，加法 $+$），后序遍历会访问 $L$，然后是 $R$，最后是 $N$。为了求值，机器需要左操作数在栈上，其后是右操作数。因此，我们先为 $L$ 生成指令，再为 $R$ 生成指令，最后附加运算符的操作码。\n    - $\\text{Compile}(N) = \\text{Compile}(L) \\oplus \\text{Compile}(R) \\oplus [\\text{OP}_{\\text{binary}}]$，其中 $\\text{OP}_{\\text{binary}}$ 是二元运算符的操作码（例如，$\\text{ADD}$ 对应 $2$）。\n\n让我们用测试用例 1 来演示这个算法：表达式 $(x + 3) \\times (y - 2)$，其中变量 $x$ 的索引为 $0$，$y$ 的索引为 $1$。\n\n表达式树的根是一个乘法节点（$\\times$）。\n- 左子节点 $L$ 是子表达式 $(x + 3)$ 的加法节点（$+$）。\n- 右子节点 $R$ 是子表达式 $(y - 2)$ 的减法节点（$-$）。\n\n编译过程如下：\n$\\text{Compile}(\\times) = \\text{Compile}(+) \\oplus \\text{Compile}(-) \\oplus [4]$\n\n- 计算 $(x + 3)$ 的 $\\text{Compile}(+)$：\n  - 左子节点是变量 $x$（索引 $0$）。$\\text{Compile}(x) = [1, 0]$。\n  - 右子节点是常量 $3$。$\\text{Compile}(3) = [0, 3]$。\n  - $+$ 的操作码是 $2$。\n  - $\\text{Compile}(+) = \\text{Compile}(x) \\oplus \\text{Compile}(3) \\oplus [2] = [1, 0] \\oplus [0, 3] \\oplus [2] = [1, 0, 0, 3, 2]$。\n\n- 计算 $(y - 2)$ 的 $\\text{Compile}(-)$：\n  - 左子节点是变量 $y$（索引 $1$）。$\\text{Compile}(y) = [1, 1]$。\n  - 右子节点是常量 $2$。$\\text{Compile}(2) = [0, 2]$。\n  - $-$ 的操作码是 $3$。\n  - $\\text{Compile}(-) = \\text{Compile}(y) \\oplus \\text{Compile}(2) \\oplus [3] = [1, 1] \\oplus [0, 2] \\oplus [3] = [1, 1, 0, 2, 3]$。\n\n- 最后，我们组装完整的序列：\n  - $\\text{Compile}(\\times) = [1, 0, 0, 3, 2] \\oplus [1, 1, 0, 2, 3] \\oplus [4]$\n  - 得到的指令流是 $[1, 0, 0, 3, 2, 1, 1, 0, 2, 3, 4]$。\n\n执行时，此序列执行以下栈操作：\n1. PUSH\n2. PUSH\n3. ADD (栈现在包含 $x+3$)\n4. PUSH\n5. PUSH\n6. SUB (栈现在包含 $x+3$, $y-2$)\n7. MUL (栈现在包含 $(x+3) \\times (y-2)$)\n\n将此过程系统地应用于所有提供的测试用例，以生成它们各自的指令流。该逻辑是确定性的，直接从表达式树和基于栈的计算的基本定义中推导得出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of compiling expression trees into a flat sequence\n    of integer-encoded instructions for a stack-based virtual machine.\n    \"\"\"\n\n    # Opcodes as defined in the problem statement.\n    OP_PUSH_CONST = 0\n    OP_PUSH_VAR = 1\n    OP_ADD = 2\n    OP_SUB = 3\n    OP_MUL = 4\n    OP_DIV = 5\n    OP_NEG = 6\n    OP_POW = 7\n\n    # Mapping from operator symbols to opcodes for convenience.\n    OPCODE_MAP = {\n        '+': OP_ADD,\n        '-': OP_SUB,\n        '*': OP_MUL,\n        '/': OP_DIV,\n        'NEG': OP_NEG,\n        '^': OP_POW,\n    }\n\n    def compile_tree(node):\n        \"\"\"\n        Recursively compiles an expression tree node into an instruction list\n        based on a postorder traversal.\n        The tree structure is represented using nested dictionaries.\n        \"\"\"\n        # Case 1: Binary operator node\n        if 'op' in node and 'L' in node and 'R' in node:\n            left_instr = compile_tree(node['L'])\n            right_instr = compile_tree(node['R'])\n            op_code = OPCODE_MAP[node['op']]\n            return left_instr + right_instr + [op_code]\n        \n        # Case 2: Unary operator node\n        elif 'op' in node and 'arg' in node:\n            arg_instr = compile_tree(node['arg'])\n            op_code = OPCODE_MAP[node['op']]\n            return arg_instr + [op_code]\n            \n        # Case 3: Variable leaf node\n        elif 'var' in node:\n            return [OP_PUSH_VAR, node['var']]\n            \n        # Case 4: Constant leaf node\n        elif 'const' in node:\n            return [OP_PUSH_CONST, node['const']]\n            \n        else:\n            # This should not be reached with well-formed trees.\n            raise ValueError(\"Invalid node format in expression tree\")\n\n    # Define the six test cases using the nested dictionary representation.\n    test_cases = [\n        # Case 1: (x + 3) * (y - 2) with x=0, y=1\n        {'op': '*', 'L': {'op': '+', 'L': {'var': 0}, 'R': {'const': 3}}, 'R': {'op': '-', 'L': {'var': 1}, 'R': {'const': 2}}},\n        \n        # Case 2: (-x) + 5 with x=0\n        {'op': '+', 'L': {'op': 'NEG', 'arg': {'var': 0}}, 'R': {'const': 5}},\n        \n        # Case 3: a^3 / (b + 1) with a=2, b=3\n        {'op': '/', 'L': {'op': '^', 'L': {'var': 2}, 'R': {'const': 3}}, 'R': {'op': '+', 'L': {'var': 3}, 'R': {'const': 1}}},\n        \n        # Case 4: 42\n        {'const': 42},\n        \n        # Case 5: (((x - 1) - 2) - 3) with x=0\n        {'op': '-', 'L': {'op': '-', 'L': {'op': '-', 'L': {'var': 0}, 'R': {'const': 1}}, 'R': {'const': 2}}, 'R': {'const': 3}},\n        \n        # Case 6: -(-(c)) with c=5\n        {'op': 'NEG', 'arg': {'op': 'NEG', 'arg': {'var': 5}}},\n    ]\n\n    results = []\n    for tree in test_cases:\n        instruction_list = compile_tree(tree)\n        results.append(instruction_list)\n\n    # Format the output exactly as specified: [[i_1,1,...],[i_2,1,...],...] with no spaces.\n    # 1. Convert each inner list of integers to a string like '[1,2,3]'.\n    # 2. Join these strings with commas.\n    # 3. Enclose the final result in brackets.\n    result_strings = []\n    for res_list in results:\n        # Create string representation of inner list without spaces\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        result_strings.append(inner_str)\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3232522"}, {"introduction": "表达式树的用途远不止于求值，它也是进行程序静态分析的强大工具。本练习要求你在不实际执行计算的情况下，通过分析表达式树的结构来预测其在64位整数环境下是否会发生溢出。通过在树的每个节点上使用精确的数学计算来追踪可能的值范围，你将学会如何利用数据结构来提前发现潜在的运行时错误，这是保证软件健壮性的关键技术。[@problem_id:3232665]", "problem": "给定一组算术表达式树，其中所有叶节点均为整数字面量，内部节点为从集合 $\\{+, -, \\times, \\div\\}$ 中选取的运算符，并支持一元取反 $-$。其求值语义遵循常规的整数数学运算法则，并附加以下精确规则。\n\n1. 每个表达式都根据其树结构进行求值（即递归地，一个节点的值是其运算符作用于其子节点值的结果）。文本表示中的括号明确地编码了树结构并覆盖了运算符优先级。\n2. 目标机器的整数类型为有符号 $64$ 位二进制补码，其可表示范围为从 $-2^{63}$ 到 $2^{63}-1$（含）。\n3. 整数除法的语义是向零截断：对于任意整数 $a$ 和 $b$（$b \\neq 0$），$a \\div b$ 的结果是 $\\mathrm{sgn}(a)\\,\\mathrm{sgn}(b)\\,\\lfloor \\frac{|a|}{|b|} \\rfloor$。在此模型中，除法唯一的溢出情况是 $(-2^{63}) \\div (-1)$，其数学结果为 $2^{63}$，因此无法表示。\n4. 一元取反仅在输入为 $-2^{63}$ 时溢出，因为其数学上的相反数是 $2^{63}$。\n5. 如果在使用精确的数学整数进行求值时，至少有一个节点（包括叶节点）产生的值超出了可表示范围，那么该表达式就被称为溢出，即使最终的整体结果在理论上是可表示的。如果一个叶节点的字面量超出了范围 $[-2^{63}, 2^{63}-1]$，则该叶节点溢出。\n\n您的任务是实现一个程序，对这些表达式进行静态分析：给定固定的树，判断在使用精确整数算术求值时，是否有任何节点在任何中间步骤中产生的值超出了有符号 $64$ 位二进制补码的范围。该分析不得依赖于机器的环绕（wraparound）或模运算；它必须通过将精确的数学整数与范围边界进行比较来检测溢出。\n\n您可以假定的基本前提：\n- 表达式树的正式定义：一个有根、有序的树，其内部节点带有运算符标签，叶节点带有整数标签。\n- 有符号 $64$ 位二进制补码整数范围 $[-2^{63}, 2^{63}-1]$ 的定义。\n- 整数算术的标准性质，包括在适用情况下的结合律和分配律，以及整数除法向零截断的定义。\n\n在此问题设置中的输入格式：\n- 没有外部输入。相反，一组固定的表达式测试套件被嵌入到您的程序中。每个表达式都以单个字符串的形式提供，使用上述规则描述的语法。可以出现空白字符，且应被忽略。允许的标记（token）包括十进制整数字面量（可能带有前导零）、括号 $($ 和 $)$、二元运算符 $+、-、\\times$（表示为 $*$）和 $\\div$（表示为 $/$），以及应用于带括号子表达式或字面量的一元取反运算符 $-$。\n\n要求输出：\n- 对于每个测试表达式，如果在上述规则下进行精确求值时，任何节点会发生溢出，则输出整数 $1$，否则输出 $0$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 `[r_1,r_2,...,r_k]`，不含空格。\n\n需要在程序内部实现的测试套件（每个都是一个需要分析的完整表达式）：\n1. $((1 + 2) * 3) - 4$\n2. $9223372036854775807 + 1$\n3. $3037000500 * 3037000500$\n4. $-(-9223372036854775808)$\n5. $-9223372036854775808 / -1$\n6. $9223372036854775808$\n7. $9223372036854775807 + (-9223372036854775807)$\n8. $-(9223372036854775807)$\n\n这些测试用例涵盖了：一个在小数值附近的典型安全计算、在边界 $2^{63}-1$ 上的加法、一个略大于 $2^{63}-1$ 安全平方根的乘法、一元取反的边界情况、整数除法的边界情况、一个本身就超出范围的叶节点字面量、一个在边界上的抵消求和，以及一个在边界上的安全一元取反。\n\n您的程序必须实现一个解析器，根据常规的优先级和括号从每个字符串构建隐式树，执行所定义的静态分析，并以所描述的精确格式将结果打印为单个由方括号括起的整数 $0$ 或 $1$ 的列表。此问题不涉及任何物理单位或角度。唯一可接受的输出格式是精确地包含该列表的一行，不含任何附加文本。", "solution": "提交分析的问题陈述被认为是有效的。它在计算机科学领域具有科学依据，特别涉及数据结构（表达式树）和计算机算术（整数溢出）。该问题是适定 (well-posed) 的，对表达式语法、求值语义以及有符号 $64$ 位整数表示下的溢出标准有清晰明确的定义。所有术语都得到了正式定义，任务是客观且可验证的。\n\n该问题要求对算术表达式进行静态分析，以确定在求值的任何中间步骤中是否会发生溢出。这将通过两个主要阶段完成：首先，将中缀表达式字符串解析为抽象语法树（AST）；其次，递归遍历 AST 以模拟精确的整数求值，同时检查是否违反了指定的整数范围。\n\n**1. 数学和计算框架**\n\n目标整数类型是有符号 $64$ 位二进制补码整数。此类整数 $v$ 的可表示范围由下式给出：\n$$ -2^{63} \\le v \\le 2^{63}-1 $$\n让我们将这些边界定义为分析用的常量：\n- $MIN\\_INT = -2^{63} = -9223372036854775808$\n- $MAX\\_INT = 2^{63}-1 = 9223372036854775807$\n\n如果在表达式树的任何节点（包括叶节点的初始值，即字面量）上计算出的任何值落在此闭区间 $[MIN\\_INT, MAX\\_INT]$ 之外，则发生溢出。分析必须使用精确整数算术执行，这可以通过使用 Python 的任意精度整数来实现。\n\n运算符集合为 $\\{+, -, \\times, \\div\\}$，以及表示为 $-$ 的一元取反。除法 $a \\div b$ 使用向零截断的语义。\n\n**2. 表达式解析：从中缀字符串到抽象语法树**\n\n为了从结构上分析表达式，我们必须首先将输入字符串从中缀表示法转换为一种更易于计算处理的形式，即抽象语法树（AST）。递归下降解析器是完成此任务的一种优雅而有效的方法。这种方法能自然地处理运算符的优先级和结合性。\n\n语法可以分层定义：\n-   `expression` 由一个或多个 `term` 通过加法运算符（$+$ 或 $-$）连接而成。\n-   `term` 由一个或多个 `factor` 通过乘法运算符（$\\times$ 或 $\\div$）连接而成。\n-   `factor` 是基本单元，可以是一个整数字面量、一个带括号的 `expression`，或是一个应用于另一个 `factor` 的一元取反。\n\n这个层次结构正确地强制了乘法和除法比加法和减法具有更高的优先级。对于相同优先级的运算符，左结合性由解析函数的迭代结构自然处理。\n\n解析器将由以下组件实现：\n-   **词法分析器（Tokenizer）**：一个预处理步骤，将输入字符串分解为标记（token）列表，例如数字、运算符（$+、-、*、/$）和括号。空白字符被忽略。减法和取反运算符都被简单地标记为 `-`；解析器的语法上下文将决定其元数（二元与一元）。\n-   **AST 节点**：树将由表示数字、一元运算和二元运算的节点构成。例如：`NumberNode(value)`、`UnaryOpNode(op, operand)` 和 `BinaryOpNode(op, left_child, right_child)`。\n-   **递归解析函数**：\n    -   `parse_expression()`：解析加法和减法。\n    -   `parse_term()`：解析乘法和除法。\n    -   `parse_factor()`：解析字面量、带括号的表达式，并处理一元取反。此函数递归调用自身的能力使其能够处理像 `-(--5)` 这样的表达式。\n\n**3. 通过 AST 遍历进行静态溢出分析**\n\n一旦构建了 AST，就会执行一次后序遍历来对表达式求值并检查溢出。一个递归函数，我们称之为 `analyze(node)`，将遍历该树。对于每个节点，此函数将返回一个元组：`(value, overflow_flag)`，其中 `value` 是以该节点为根的子表达式的精确数学结果，`overflow_flag` 是一个布尔值，指示该子表达式内部是否发生了溢出。\n\n`analyze(node)` 函数的逻辑如下：\n\n-   **基本情况（叶节点 - `NumberNode`）**：\n    1.  `value` 是整数字面量本身。\n    2.  如果 `value  MIN_INT` 或 `value > MAX_INT`，则 `overflow_flag` 设置为 `True`，否则为 `False`。\n    3.  返回 `(value, overflow_flag)`。\n\n-   **递归步骤（内部节点 - `UnaryOpNode` 或 `BinaryOpNode`）**：\n    1.  对子节点递归调用 `analyze()`，以获取它们各自的 `(value, overflow_flag)` 元组。\n    2.  如果任何子节点的 `overflow_flag` 为 `True`，溢出条件将向上传播。当前节点的总体 `overflow_flag` 将为 `True`，无论其自身的操作如何。\n    3.  对从子节点接收到的精确整数 `value` 执行当前节点的操作（例如，$+、-、\\times、\\div$）。设结果为 `v_result`。\n    4.  问题明确定义了两个特殊的溢出情况，必须在常规范围检查之前进行检查：\n        -   对于除法，情况 $(-2^{63}) \\div (-1)$ 结果为 $2^{63}$，会溢出。\n        -   对于一元取反，情况 $-(-2^{63})$ 结果为 $2^{63}$，会溢出。\n        这些情况会被常规范围检查隐式处理，但重要的是要承认它们作为指定的边界条件的角色。\n    5.  检查 `v_result` 是否在范围 $[MIN\\_INT, MAX\\_INT]$ 内。设 `current_overflow = (v_result  MIN_INT or v_result > MAX_INT)`。\n    6.  当前节点的最终 `overflow_flag` 是其子节点标志与 `current_overflow` 的逻辑或。\n    7.  返回 `(v_result, final_overflow_flag)`。\n\n整个表达式的结果是由 `analyze(root_node)` 返回的 `overflow_flag`。然后根据输出格式的要求，将此标志转换为整数（`True` 为 $1$，$0$ 为 `False`）。通过对测试套件中的每个表达式应用此过程，我们可以生成最终的结果列表。", "answer": "```python\nimport re\nfrom collections import namedtuple\nimport numpy as np\n\n# According to the problem, numpy is an available library.\n# However, the logic for this problem is best implemented with\n# Python's native arbitrary-precision integers to perform exact\n# mathematical calculations for overflow checking. np.int64 would\n# exhibit wraparound behavior, which is what we are trying to detect, not replicate.\n# The import is included to adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the static expression analysis problem by parsing expressions into\n    an AST and recursively checking for 64-bit integer overflows.\n    \"\"\"\n    \n    MIN_INT = -2**63\n    MAX_INT = 2**63 - 1\n\n    # --- AST Node Definitions ---\n    NumberNode = namedtuple('NumberNode', ['value'])\n    BinaryOpNode = namedtuple('BinaryOpNode', ['op', 'left', 'right'])\n    UnaryOpNode = namedtuple('UnaryOpNode', ['op', 'operand'])\n\n    # --- Tokenizer ---\n    def tokenize(expression):\n        \"\"\"Converts an expression string into a list of tokens.\"\"\"\n        token_specification = [\n            ('NUMBER',   r'\\d+'),\n            ('OPERATOR', r'[+\\-*/()]'),\n            ('SKIP',     r'\\s+'),\n            ('MISMATCH', r'.'),\n        ]\n        tok_regex = '|'.join('(?P%s>%s)' % pair for pair in token_specification)\n        tokens = []\n        for mo in re.finditer(tok_regex, expression):\n            kind = mo.lastgroup\n            value = mo.group()\n            if kind == 'SKIP':\n                continue\n            if kind == 'MISMATCH':\n                raise ValueError(f\"Unexpected character: {value}\")\n            tokens.append(value)\n        return tokens\n\n    # --- Recursive Descent Parser ---\n    class Parser:\n        \"\"\"\n        Parses a list of tokens into an Abstract Syntax Tree (AST).\n        - expr   -> term (('+'|'-') term)*\n        - term   -> factor (('*'|'/') factor)*\n        - factor -> NUMBER | '(' expr ')' | '-' factor\n        \"\"\"\n        def __init__(self, tokens):\n            self.tokens = tokens\n            self.pos = 0\n\n        def peek(self):\n            return self.tokens[self.pos] if self.pos  len(self.tokens) else None\n\n        def consume(self, expected_token=None):\n            token = self.peek()\n            if expected_token and token != expected_token:\n                raise ValueError(f\"Expected {expected_token} but got {token}\")\n            self.pos += 1\n            return token\n\n        def parse(self):\n            if not self.tokens:\n                return None\n            node = self.parse_expression()\n            if self.peek() is not None:\n                raise ValueError(\"Extra characters at end of expression\")\n            return node\n\n        def parse_factor(self):\n            token = self.peek()\n            if token is None:\n                raise ValueError(\"Unexpected end of expression, expected a factor\")\n            if token.isdigit():\n                return NumberNode(int(self.consume()))\n            elif token == '(':\n                self.consume('(')\n                node = self.parse_expression()\n                self.consume(')')\n                return node\n            elif token == '-':\n                self.consume('-')\n                operand = self.parse_factor()\n                return UnaryOpNode('-', operand)\n            else:\n                raise ValueError(f\"Unexpected token in factor: {token}\")\n\n        def parse_term(self):\n            node = self.parse_factor()\n            while self.peek() in ('*', '/'):\n                op = self.consume()\n                right = self.parse_factor()\n                node = BinaryOpNode(op, node, right)\n            return node\n\n        def parse_expression(self):\n            node = self.parse_term()\n            while self.peek() in ('+', '-'):\n                op = self.consume()\n                right = self.parse_term()\n                node = BinaryOpNode(op, node, right)\n            return node\n\n    # --- Analysis Function ---\n    def analyze(node):\n        \"\"\"\n        Recursively analyzes an AST node, returning (value, has_overflowed).\n        The value is an exact Python integer.\n        has_overflowed is a boolean.\n        \"\"\"\n        if isinstance(node, NumberNode):\n            v = node.value\n            overflow = not (MIN_INT = v = MAX_INT)\n            return v, overflow\n        \n        if isinstance(node, UnaryOpNode):\n            operand_val, child_overflow = analyze(node.operand)\n            if child_overflow:\n                return 0, True  # Propagate overflow, value doesn't matter\n            \n            result = -operand_val\n            current_overflow = not (MIN_INT = result = MAX_INT)\n            return result, current_overflow\n\n        if isinstance(node, BinaryOpNode):\n            left_val, left_overflow = analyze(node.left)\n            right_val, right_overflow = analyze(node.right)\n            \n            if left_overflow or right_overflow:\n                return 0, True # Propagate overflow\n            \n            op = node.op\n            result = 0\n            if op == '+':\n                result = left_val + right_val\n            elif op == '-':\n                result = left_val - right_val\n            elif op == '*':\n                result = left_val * right_val\n            elif op == '/':\n                if right_val == 0:\n                    # Division by zero is an error, but problem asks about overflow.\n                    # The test cases do not include division by zero.\n                    # We can treat this as an unrecoverable state. For this problem, we can assume it won't happen.\n                    pass\n                \n                # Integer division truncating towards zero\n                if left_val * right_val  0:\n                    result = -(-left_val // right_val)\n                else:\n                    result = left_val // right_val\n            \n            current_overflow = not (MIN_INT = result = MAX_INT)\n            return result, current_overflow\n        \n        raise TypeError(f\"Unknown node type: {type(node)}\")\n\n    # --- Main Execution Logic ---\n    test_cases = [\n        \"((1 + 2) * 3) - 4\",\n        \"9223372036854775807 + 1\",\n        \"3037000500 * 3037000500\",\n        \"-(-9223372036854775808)\",\n        \"-9223372036854775808 / -1\",\n        \"9223372036854775808\",\n        \"9223372036854775807 + (-9223372036854775807)\",\n        \"-(9223372036854775807)\"\n    ]\n\n    results = []\n    for expr in test_cases:\n        try:\n            tokens = tokenize(expr)\n            parser = Parser(tokens)\n            ast = parser.parse()\n            if ast is None:\n                # Handle empty expression string if needed\n                results.append(0)\n                continue\n            \n            _, has_overflowed = analyze(ast)\n            results.append(1 if has_overflowed else 0)\n        except (ValueError, TypeError) as e:\n            # For this problem's controlled test cases, errors indicate a flaw in the implementation.\n            # In a real-world scenario, this would handle malformed input.\n            # For now, we assume valid inputs as per the problem.\n            results.append(1) # Consider any parse error as a failure/overflow for robustness.\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3232665"}]}