{"hands_on_practices": [{"introduction": "要真正掌握 AVL 树的旋转，我们不妨先从一个基本问题入手：旋转在什么情况下*不会*发生？这个练习将带你分析一个最简单的非平凡场景——向空树中插入三个元素。通过推导完全避免旋转所需的插入顺序，你将从根本上理解平衡因子是如何变化的，以及插入顺序对树结构的关键影响。[@problem_id:3210827]", "problem": "考虑一个空的 Adelson-Velsky 和 Landis (AVL) 树，它是一种二叉搜索树，并维护这样一个不变性：对于每个节点 $v$，其左子树和右子树的高度差的绝对值最多为 $1$。如果在一次插入后，某个节点的平衡因子（定义为左子树的高度减去右子树的高度）变为 $2$ 或 $-2$，则立即执行一次旋转（单旋转或双旋转）。设有三个不同的键 $a, b, c$，满足 $a < b < c$。如果这三个键以随机均匀的顺序插入到一棵初始为空的 AVL 树中，最终的树在构建过程中不需要任何旋转操作的概率是多少？", "solution": "问题要求我们对三个不同键 $\\{a, b, c\\}$（其中 $a < b < c$）的所有 $3! = 6$ 种可能的插入顺序进行分析，并确定哪些顺序在构建树的过程中不需要任何旋转操作。\n\nAVL 树的旋转在且仅在一次插入后，某个节点的平衡因子变为 $+2$ 或 $-2$ 时被触发。我们需要找到那些在任何插入步骤后，所有节点的平衡因子都保持在 $\\{-1, 0, 1\\}$ 集合内的插入序列。\n\n让我们逐一分析这 6 种排列：\n\n1.  **插入顺序 $(a, b, c)$**：\n    -   插入 $a$：树为 $(a)$。平衡。\n    -   插入 $b$：$b > a$，树为 $a \\rightarrow (\\text{右}) b$。节点 $a$ 的平衡因子为 $-1$。平衡。\n    -   插入 $c$：$c > b$，树为 $a \\rightarrow (\\text{右}) b \\rightarrow (\\text{右}) c$。节点 $a$ 的平衡因子变为 $-2$。**需要旋转** (RR)。\n\n2.  **插入顺序 $(a, c, b)$**：\n    -   插入 $a$：$(a)$。\n    -   插入 $c$：$a \\rightarrow (\\text{右}) c$。$a$ 的平衡因子为 $-1$。\n    -   插入 $b$：$b < c$ 且 $b > a$，树为 $a \\rightarrow (\\text{右}) (c \\rightarrow (\\text{左}) b)$。节点 $a$ 的平衡因子变为 $-2$。**需要旋转** (RL)。\n\n3.  **插入顺序 $(b, a, c)$**：\n    -   插入 $b$：$(b)$。\n    -   插入 $a$：$a < b$，树为 $b \\rightarrow (\\text{左}) a$。节点 $b$ 的平衡因子为 $+1$。\n    -   插入 $c$：$c > b$，树为 $a \\leftarrow (\\text{左}) b \\rightarrow (\\text{右}) c$。节点 $b$ 的平衡因子变为 $0$。所有节点的平衡因子都在 $\\{-1, 0, 1\\}$ 内。**不需要旋转**。\n\n4.  **插入顺序 $(b, c, a)$**：\n    -   插入 $b$：$(b)$。\n    -   插入 $c$：$b \\rightarrow (\\text{右}) c$。节点 $b$ 的平衡因子为 $-1$。\n    -   插入 $a$：$a < b$，树为 $a \\leftarrow (\\text{左}) b \\rightarrow (\\text{右}) c$。节点 $b$ 的平衡因子变为 $0$。**不需要旋转**。\n\n5.  **插入顺序 $(c, a, b)$**：\n    -   插入 $c$：$(c)$。\n    -   插入 $a$：$c \\rightarrow (\\text{左}) a$。节点 $c$ 的平衡因子为 $+1$。\n    -   插入 $b$：$b > a$ 且 $b < c$，树为 $c \\rightarrow (\\text{左}) (a \\rightarrow (\\text{右}) b)$。节点 $c$ 的平衡因子变为 $+2$。**需要旋转** (LR)。\n\n6.  **插入顺序 $(c, b, a)$**：\n    -   插入 $c$：$(c)$。\n    -   插入 $b$：$c \\rightarrow (\\text{左}) b$。$c$ 的平衡因子为 $+1$。\n    -   插入 $a$：$a < b$，树为 $c \\rightarrow (\\text{左}) b \\rightarrow (\\text{左}) a$。节点 $c$ 的平衡因子变为 $+2$。**需要旋转** (LL)。\n\n在 6 种可能的插入顺序中，只有 2 种（$(b, a, c)$ 和 $(b, c, a)$）不需要旋转。这两种情况的共同点是，中间值 $b$ 首先被插入作为根。\n\n因此，在所有排列中随机选择一个时，不需要旋转的概率是 $2/6 = 1/3$。", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "3210827"}, {"introduction": "在理解了旋转的触发条件之后，下一个关键步骤是亲手执行整个过程。本练习为你提供了一个精心设计的插入序列，它将触发包括复杂双旋转（如右-左旋转）在内的多种情况。通过在每次插入后精确计算每个节点的平衡因子，你将获得对 Adelson-Velsky and Landis (AVL) 树复杂的再平衡机制的精细掌控。[@problem_id:3210713]", "problem": "您将使用 Adelson–Velsky 和 Landis (AVL) 树的核心定义来分析在二叉搜索树插入过程中旋转是如何被触发的，以及平衡因子是如何演变的。设空子节点的高度为 $-1$，节点的高度为 $1 + \\max\\{\\text{左子节点的高度}, \\text{右子节点的高度}\\}$，节点 $v$ 的平衡因子为 $\\operatorname{bf}(v) = \\text{height(left}(v)) - \\text{height(right}(v))$。如果一棵 AVL 树的每个节点的平衡因子都在 $\\{-1, 0, 1\\}$ 集合中，则该树是平衡的。插入时，一个节点 $z$ 会触发：\n- 一次左-左 ($LL$) 旋转，如果 $\\operatorname{bf}(z) = +2$ 且插入发生在 $z$ 的左子节点的左子树中，\n- 一次右-右 ($RR$) 旋转，如果 $\\operatorname{bf}(z) = -2$ 且插入发生在 $z$ 的右子节点的右子树中，\n- 一次左-右 ($LR$) 旋转，如果 $\\operatorname{bf}(z) = +2$ 且 $z$ 的左子节点的 $\\operatorname{bf} = -1$（修正操作为对左子节点进行一次左旋，然后对 $z$ 进行一次右旋），\n- 一次右-左 ($RL$) 旋转，如果 $\\operatorname{bf}(z) = -2$ 且 $z$ 的右子节点的 $\\operatorname{bf} = +1$（修正操作为对右子节点进行一次右旋，然后对 $z$ 进行一次左旋）。\n\n考虑以特定顺序 $\\langle 4, 6, 5, 2, 1, 3, 7 \\rangle$ 将键 $\\{1,2,3,4,5,6,7\\}$ 插入到一棵初始为空的二叉搜索树中。这个顺序会在插入键 $5$ 之后、该步骤进行任何再平衡操作之前的时刻，在节点 $4$ 处强制触发一次右-左 ($RL$) 旋转。\n\n对于步骤 $t \\in \\{1,2,\\dots,7\\}$，令 $V_t$ 表示在第 $t$ 次插入后、该步骤进行任何再平衡操作之前存在的节点集合，并令 $\\operatorname{bf}_t^{-}(v)$ 表示在该再平衡前的树中节点 $v \\in V_t$ 的平衡因子。定义累积不平衡量\n$$\nS \\;=\\; \\sum_{t=1}^{7} \\;\\sum_{v \\in V_t} \\left|\\operatorname{bf}_t^{-}(v)\\right|.\n$$\n\n任务：\n- 仅使用上述基本定义，论证为何给定的插入顺序会在插入键 $5$ 之后的时刻，在节点 $4$ 处强制触发一次 $RL$ 旋转。\n- 在每个步骤 $t$ 计算每个 $v \\in V_t$ 的 $\\operatorname{bf}_t^{-}(v)$，并在其第一个不平衡的祖先处识别所有旋转触发。\n- 计算 $S$ 的精确值。\n\n你的最终答案必须是 $S$ 的精确值（一个整数）。无需四舍五入。", "solution": "该问题是有效的，因为它是自包含的，在科学上基于 AVL 树的理论，且定义明确。定义、插入序列以及待计算的量都得到了明确的说明，确保了存在唯一且有意义的解。\n\n解题过程分为两部分。首先，我们将论证为何在插入键 5 后，在节点 4 处会强制触发一次 RL 旋转。其次，我们将追踪 7 个键中每一个的插入过程，计算每个步骤 $t$ 的再平衡前平衡因子集合 $\\operatorname{bf}_t^{-}(v)$，并将它们的绝对值相加，以求得总的累积不平衡量 $S$。\n\n### 关于右-左 (RL) 旋转的论证\n\n我们从一棵空树开始。\n1.  插入 $4$：树是单个节点 $4$。$h(4)=0$，$\\operatorname{bf}(4)=0$。\n2.  插入 $6$：因为 $6 > 4$，$6$ 成为 $4$ 的右子节点。树的结构是 $4 \\rightarrow (\\text{右}) \\ 6$。\n    - $h(6) = 1 + \\max(-1, -1) = 0$。\n    - $h(4) = 1 + \\max(h(\\text{左}), h(6)) = 1 + \\max(-1, 0) = 1$。\n    - $\\operatorname{bf}(4) = h(\\text{左}) - h(6) = -1 - 0 = -1$。树是平衡的。\n\n3.  插入 $5$：因为 $5 > 4$，我们向右走到节点 $6$。因为 $5 < 6$，我们向左走。$5$ 作为 $6$ 的左子节点被插入。在任何再平衡之前的结构是 $4 \\rightarrow (\\text{右}) \\ 6 \\rightarrow (\\text{左}) \\ 5$。让我们分析这次插入之后的状态，记为 $t=3$。\n    - 令 $v_4, v_5, v_6$ 分别为键为 $4, 5, 6$ 的节点。\n    - 新叶子节点的高度是 $h(v_5) = 0$。它的平衡因子是 $\\operatorname{bf}_3^{-}(v_5) = 0 - 0 = 0$。\n    - 其父节点的高度是 $h(v_6) = 1 + \\max(h(v_5), h(\\text{空})) = 1+\\max(0, -1) = 1$。\n    - $v_6$ 的平衡因子是 $\\operatorname{bf}_3^{-}(v_6) = h(v_5) - h(\\text{空}) = 0 - (-1) = +1$。\n    - 根节点的高度是 $h(v_4) = 1 + \\max(h(\\text{空}), h(v_6)) = 1+\\max(-1, 1) = 2$。\n    - $v_4$ 的平衡因子是 $\\operatorname{bf}_3^{-}(v_4) = h(\\text{空}) - h(v_6) = -1 - 1 = -2$。\n\n从插入点（$v_5$）向上追溯，第一个平衡因子不在集合 $\\{-1, 0, 1\\}$ 内的节点是 $z=v_4$。它的平衡因子是 $\\operatorname{bf}_3^{-}(v_4) = -2$。问题将节点 $z$ 的 RL 旋转触发定义为：“$\\operatorname{bf}(z) = -2$ 且 $z$ 的右子节点的 $\\operatorname{bf} = +1$”。这里，$z=v_4$，它的右子节点是 $v_6$，并且我们已计算出 $\\operatorname{bf}_3^{-}(v_6) = +1$。\n两个条件都满足。因此，插入键 5 在节点 4 处强制触发了一次 RL 旋转。\n\n### $S$ 的分步计算\n\n现在我们计算 $S = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)|$。对于每个步骤 $t$，我们展示再平衡前的树状态，计算平衡因子，计算它们绝对值的和，并描述再平衡操作。\n\n**步骤 $t=1$：插入 $4$**\n-   再平衡前的树：一个单节点 $4$。\n-   $V_1 = \\{4\\}$。\n-   $\\operatorname{bf}_1^{-}(4) = 0$。\n-   $\\sum_{v \\in V_1} |\\operatorname{bf}_1^{-}(v)| = |0| = 0$。\n-   树是平衡的。\n\n**步骤 $t=2$：插入 $6$**\n-   再平衡前的树：$4 \\rightarrow (\\text{右}) \\ 6$。\n-   $V_2 = \\{4, 6\\}$。\n-   $\\operatorname{bf}_2^{-}(6) = 0$。\n-   $\\operatorname{bf}_2^{-}(4) = h(\\text{左}) - h(\\text{右}) = -1 - 0 = -1$。\n-   $\\sum_{v \\in V_2} |\\operatorname{bf}_2^{-}(v)| = |-1| + |0| = 1$。\n-   树是平衡的。\n\n**步骤 $t=3$：插入 $5$**\n-   再平衡前的树：$4 \\rightarrow (\\text{右}) \\ 6 \\rightarrow (\\text{左}) \\ 5$。\n-   $V_3 = \\{4, 5, 6\\}$。\n-   $\\operatorname{bf}_3^{-}(5) = 0$。\n-   $\\operatorname{bf}_3^{-}(6) = h(5) - h(\\text{空}) = 0 - (-1) = 1$。\n-   $\\operatorname{bf}_3^{-}(4) = h(\\text{空}) - h(6) = -1 - 1 = -2$。\n-   $\\sum_{v \\in V_3} |\\operatorname{bf}_3^{-}(v)| = |-2| + |0| + |1| = 3$。\n-   旋转：节点 $4$ 不平衡（$\\operatorname{bf}=-2$），其右子节点的 $\\operatorname{bf}=+1$。在节点 $4$ 处执行一次 **RL 旋转**。树变为以 $5$ 为根，左子节点为 $4$，右子节点为 $6$。\n\n**步骤 $t=4$：插入 $2$**\n-   $t=3$ 再平衡后的树：$5 \\rightarrow (\\text{左}) \\ 4, (\\text{右}) \\ 6$。\n-   $t=4$ 再平衡前的树：$5 \\rightarrow (\\text{左}) \\ (4 \\rightarrow (\\text{左}) \\ 2), (\\text{右}) \\ 6$。\n-   $V_4 = \\{2, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_4^{-}(2)=0$, $\\operatorname{bf}_4^{-}(6)=0$。\n-   $\\operatorname{bf}_4^{-}(4) = h(2) - h(\\text{空}) = 0 - (-1) = 1$。\n-   $\\operatorname{bf}_4^{-}(5) = h(4) - h(6) = 1 - 0 = 1$。\n-   $\\sum_{v \\in V_4} |\\operatorname{bf}_4^{-}(v)| = |0| + |1| + |1| + |0| = 2$。\n-   树是平衡的。\n\n**步骤 $t=5$：插入 $1$**\n-   $t=4$ 后的树：$5 \\rightarrow \\big( (\\text{左}) \\ 4 \\rightarrow(\\text{左}) \\ 2 \\big), (\\text{右}) \\ 6$。\n-   $t=5$ 再平衡前的树：$5 \\rightarrow \\big( (\\text{左}) \\ 4 \\rightarrow(\\text{左}) \\ (2 \\rightarrow \\text{左} \\ 1) \\big), (\\text{右}) \\ 6$。\n-   $V_5 = \\{1, 2, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_5^{-}(1)=0$, $\\operatorname{bf}_5^{-}(6)=0$。\n-   $\\operatorname{bf}_5^{-}(2) = h(1) - h(\\text{空}) = 0 - (-1) = 1$。\n-   $h(2)=1$，所以 $\\operatorname{bf}_5^{-}(4) = h(2) - h(\\text{空}) = 1 - (-1) = 2$。\n-   $h(4)=2$，所以 $\\operatorname{bf}_5^{-}(5) = h(4) - h(6) = 2 - 0 = 2$。\n-   $\\sum_{v \\in V_5} |\\operatorname{bf}_5^{-}(v)| = |0| + |1| + |2| + |2| + |0| = 5$。\n-   旋转：节点 $4$ 是第一个不平衡的节点（$\\operatorname{bf}=+2$）。插入发生在其左子节点的左子树中。在节点 $4$ 处执行一次 **LL 旋转**（一次右旋）。以 $4$ 为根的子树变为以 $2$ 为根，左子节点为 $1$，右子节点为 $4$。这修正了所有祖先节点的平衡，包括节点 $5$。\n\n**步骤 $t=6$：插入 $3$**\n-   $t=5$ 再平衡后的树：$5 \\rightarrow \\big( (\\text{左}) \\ (2 \\rightarrow (\\text{左}) \\ 1, (\\text{右}) \\ 4) \\big), (\\text{右}) \\ 6$。\n-   $t=6$ 再平衡前的树：插入 $3$（$3 < 5, 3 > 2, 3 < 4$）作为 $4$ 的左子节点。\n-   $V_6 = \\{1, 2, 3, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_6^{-}(1)=0$, $\\operatorname{bf}_6^{-}(3)=0$, $\\operatorname{bf}_6^{-}(6)=0$。\n-   $\\operatorname{bf}_6^{-}(4) = h(3) - h(\\text{空}) = 0 - (-1) = 1$。\n-   $h(4)=1, h(1)=0$，所以 $\\operatorname{bf}_6^{-}(2) = h(1) - h(4) = 0 - 1 = -1$。\n-   $h(2)=2, h(6)=0$，所以 $\\operatorname{bf}_6^{-}(5) = h(2) - h(6) = 2 - 0 = 2$。\n-   $\\sum_{v \\in V_6} |\\operatorname{bf}_6^{-}(v)| = |0| + |-1| + |0| + |1| + |2| + |0| = 4$。\n-   旋转：节点 $5$ 不平衡（$\\operatorname{bf}=+2$），其左子节点（$2$）的 $\\operatorname{bf}=-1$。在节点 $5$ 处执行一次 **LR 旋转**。最终的树以 $4$ 为根。\n\n**步骤 $t=7$：插入 $7$**\n-   $t=6$ 再平衡后的树：以 $4$ 为根，左子节点为 $2$（子节点为 $1,3$），右子节点为 $5$（右子节点为 $6$）。\n-   $t=7$ 再平衡前的树：$7$ 作为 $6$ 的右子节点被插入。\n-   $V_7 = \\{1, 2, 3, 4, 5, 6, 7\\}$。\n-   $\\operatorname{bf}_7^{-}(1)=0, \\operatorname{bf}_7^{-}(3)=0, \\operatorname{bf}_7^{-}(7)=0$。\n-   $\\operatorname{bf}_7^{-}(2) = h(1) - h(3) = 0 - 0 = 0$。\n-   $\\operatorname{bf}_7^{-}(6) = h(\\text{空}) - h(7) = -1 - 0 = -1$。\n-   $h(2)=1$。$h(6)=1$，所以 $\\operatorname{bf}_7^{-}(5) = h(\\text{空}) - h(6) = -1 - 1 = -2$。\n-   $h(5)=2$，所以 $\\operatorname{bf}_7^{-}(4) = h(2) - h(5) = 1 - 2 = -1$。\n-   $\\sum_{v \\in V_7} |\\operatorname{bf}_7^{-}(v)| = |0| + |0| + |0| + |-1| + |-2| + |-1| + |0| = 4$。\n-   旋转：节点 $5$ 不平衡（$\\operatorname{bf}=-2$）。插入发生在其右子节点的右子树中。在节点 $5$ 处执行一次 **RR 旋转**（一次左旋）。\n\n**S 的最终计算**\n总累积不平衡量 $S$ 是每步总和的累加：\n$$\nS = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)| = 0 + 1 + 3 + 2 + 5 + 4 + 4\n$$\n$$\nS = 19\n$$", "answer": "$$\\boxed{19}$$", "id": "3210713"}, {"introduction": "我们已经通过案例分析了不同的旋转类型（$LL, RR, LR, RL$），现在是时候从分析转向综合了。这个高级练习挑战你用一种更优雅、更强大的视角来统一所有旋转操作：实现一个单一的“三节点重构”逻辑。这种方法不仅代码更简洁，而且揭示了所有四种旋转类型背后共通的几何原理，是從“会用”到“精通”的关键一步。[@problem_id:3210793]", "problem": "实现一个自平衡二叉搜索树，使用 Adelson-Velsky 和 Landis (AVL) 旋转，并采用单一、统一的三节点重构逻辑，该逻辑在一个代码块中处理所有四种不平衡配置，而不区分单旋转和双旋转。请从以下基础概念开始。二叉搜索树是一种二叉树，其中对于每个键为 $k_v$ 的节点 $v$，其左子树中的所有键都严格小于 $k_v$，而其右子树中的所有键都严格大于 $k_v$。节点 $v$ 的高度函数 $h(v)$ 递归定义为：如果 $v$ 为空，则 $h(v) = -1$；否则，$h(v) = 1 + \\max(h(v_{\\text{left}}), h(v_{\\text{right}}))$。平衡因子 $bf(v)$ 定义为 $bf(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$。AVL 树为每个节点 $v$ 维持 $|bf(v)| \\leq 1$；插入后，如果某个节点 $a$ 变得不平衡，即 $|bf(a)| \\geq 2$（这是通过单次局部重构即可恢复平衡的最小阈值），则必须执行再平衡操作。您的程序必须实现 AVL 插入，遵循二叉搜索树的插入规则，然后更新高度，并在需要时执行单一的统一重构步骤，具体如下：设 $a$ 为插入路径上第一个满足 $|bf(a)| \\geq 2$ 的祖先节点，设 $b$ 为 $a$ 的较高子节点，并设 $c$ 为 $b$ 的较高子节点（当 $b$ 的两个子节点等高时，选择左子节点作为 $c$）。通过三节点重构来恢复平衡，该操作将 $\\{a, b, c\\}$ 中键值的中位数提升为局部根节点，并重新连接四个子树，以保持二叉搜索树的顺序和 AVL 的高度不变性。旋转逻辑必须表示为单一的统一代码块，覆盖所有四种配置（$LL$、$RR$、$LR$、$RL$），而无需显式区分单旋转和双旋转。重复的键应被忽略（树中存储唯一的键）。\n\n您的程序必须对下面的每个测试用例应用插入操作，并为每个用例生成最终树的前序遍历，结果为一个整数列表。测试套件如下：\n1. 空序列：$[]$（边界条件）\n2. 左-左不平衡：$[30, 20, 10]$\n3. 右-右不平衡：$[10, 20, 30]$\n4. 左-右不平衡：$[30, 10, 20]$\n5. 右-左不平衡：$[10, 30, 20]$\n6. 多次再平衡：$[10, 20, 30, 40, 50, 25]$\n7. 仅有重复项：$[10, 10, 10]$（边界条件）\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例的前序遍历列表，整行中不含任何空格。例如，如果有三个测试用例分别产生列表 $[a_1, a_2]$、$[b_1]$ 和 $[]$，则程序应打印单行 $[[a_1,a_2],[b_1],[]]$。", "solution": "该问题要求实现 Adelson-Velsky 和 Landis (AVL) 树，这是一种自平衡二叉搜索树。关键约束是在插入过程中，对出现的所有四种不平衡情况（$LL$、$RR$、$LR$、$RL$）使用单一、统一的三节点重构逻辑。\n\n首先，我们定义树节点的结构。每个 `Node` 对象必须存储一个键、对其左、右子节点的引用以及它在树中的高度。节点的高度对于确定平衡因子至关重要。根据问题描述，节点 $v$ 的高度 $h(v)$ 定义为：如果 $v$ 是空引用（叶节点的子节点），则为 -1；否则为 $1 + \\max(h(v_{\\text{left}}), h(v_{\\text{right}}))$。一个新创建的叶子节点高度为 0。\n\n插入过程始于标准的二叉搜索树插入。一个新键被放置在新叶节点中，同时保持 BST 属性：对于任何键为 $k_v$ 的节点，其左子树中的所有键都严格小于 $k_v$，而其右子树中的所有键都严格大于 $k_v$。问题规定，重复的键将被忽略。\n\n插入之后，我们从新叶节点沿树向上回溯至根节点。在此路径上的每个节点，我们执行两个操作：\n$1$. 更新节点的高度。由于其某个子树中添加了新节点，它的高度可能已增加。\n$2$. 检查不平衡。计算平衡因子 $bf(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$。AVL 属性规定，对于每个节点 $v$，必须满足 $|bf(v)| \\le 1$。插入操作可能会违反此属性。\n\n如果我们发现一个节点 $a$ 满足 $|bf(a)| \\ge 2$，则需要进行重构。问题指出，这必须在插入路径上遇到的第一个此类祖先节点 $a$ 处完成。这是变得不平衡的最深节点。插入操作的递归实现很自然地处理了这一点，因为检查和重构是在递归的回溯路径上执行的。\n\n解决方案的核心是统一的三节点重构逻辑。这个过程在不平衡节点 $a$ 处触发，并涉及其子节点 $b$ 和孙节点 $c$，它们的确定方式如下：\n- $a$：插入路径上第一个满足 $|bf(a)| \\ge 2$ 的祖先节点。\n- $b$：$a$ 的较高子节点。由于 $|bf(a)| \\ge 2$，一个子节点严格高于另一个，使得该选择明确无误。如果 $bf(a) > 1$，则 $b = a_{\\text{left}}$；如果 $bf(a) < -1$，则 $b = a_{\\text{right}}$。\n- $c$：$b$ 的较高子节点。问题指定了决胜规则：如果 $h(b_{\\text{left}}) \\ge h(b_{\\text{right}})$，则 $c = b_{\\text{left}}$；否则 $c = b_{\\text{right}}$。\n\n这三个节点 $\\{a, b, c\\}$，连同它们不属于 $\\{a, b, c\\}$ 内部的四个子树，构成了需要重新配置的局部子结构。统一重构不依赖于具体情况（$LL、RR、LR、RL$），而是依赖于 $a、b、c$ 键值的排序顺序。\n\n设按键值排序后的节点 $\\{a, b, c\\}$ 为 $\\{z, y, x\\}$，其中 $k_z < k_y < k_x$。三节点重构将中位数键值的节点 $y$ 提升为新的局部根节点。节点 $z$ 成为 $y$ 的左子节点，节点 $x$ 成为 $y$ 的右子节点。这种配置从本质上保持了这三个节点的二叉搜索树属性。\n\n最后一步是重新连接四个原始子树，我们可以将其表示为 $T_0, T_1, T_2, T_3$。这些子树对应四个键范围：小于 $k_z$ 的键、介于 $k_z$ 和 $k_y$ 之间的键、介于 $k_y$ 和 $k_x$ 之间的键以及大于 $k_x$ 的键。我们可以通过检查其根节点的键相对于 $k_z, k_y, k_x$ 的值，来确定四个原始子树中哪一个对应哪个范围。然后根据 BST 属性执行重新连接：\n- $z_{\\text{left}} \\leftarrow T_0$ (键值 $< k_z$)\n- $z_{\\text{right}} \\leftarrow T_1$ (键值 $> k_z$ 且 $< k_y$)\n- $x_{\\text{left}} \\leftarrow T_2$ (键值 $> k_y$ 且 $< k_x$)\n- $x_{\\text{right}} \\leftarrow T_3$ (键值 $> k_x$)\n\n重新连接节点和子树后，必须按 $z、x$ 最后 $y$ 的顺序重新计算它们的高度，以反映新结构。节点 $y$ 作为重构后子树的新根，在递归插入调用中返回给父节点，从而完成再平衡。\n\n这整个重构过程构成了一个单一的逻辑块。它通过将旋转抽象为对三个节点及其四个关联子树进行重新排序的通用操作，正确地处理了所有四种不平衡配置，从而满足了问题的主要约束。\n\n最后，为了生成所需的输出，实现了一个前序遍历。此遍历访问当前节点，然后是其左子树，再然后是其右子树，将键收集到一个列表中。对提供的每个测试用例都执行此操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# It's good practice to increase recursion limit for recursive data structures.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Node class for the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 0  # A new node is initially added as a leaf, height 0\n\nclass AVLTree:\n    \"\"\"AVL tree implementation with a unified tri-node restructuring logic.\"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def get_height(self, node):\n        \"\"\"Returns the height of a node, -1 for None.\"\"\"\n        if not node:\n            return -1\n        return node.height\n\n    def get_balance(self, node):\n        \"\"\"Returns the balance factor of a node.\"\"\"\n        if not node:\n            return 0\n        return self.get_height(node.left) - self.get_height(node.right)\n\n    def insert(self, key):\n        \"\"\"Public method to insert a key into the tree.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper function for insertion.\"\"\"\n        # 1. Standard BST insertion\n        if not node:\n            return Node(key)\n        elif key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        else:\n            return node  # Duplicates are ignored\n\n        # 2. Update height of the ancestor node\n        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))\n\n        # 3. Get the balance factor\n        balance = self.get_balance(node)\n\n        # 4. If the node becomes unbalanced, then trigger restructuring\n        if abs(balance) > 1:\n            return self._restructure(node)\n\n        return node\n\n    def _restructure(self, a):\n        \"\"\"Performs a unified tri-node restructuring.\"\"\"\n        # Identify nodes b and c as per the problem description\n        if self.get_balance(a) > 1:\n            b = a.left\n        else: # balance < -1\n            b = a.right\n\n        if self.get_height(b.left) >= self.get_height(b.right):\n            c = b.left\n        else:\n            c = b.right\n\n        # Sort nodes a, b, c by key to find the median\n        nodes_p = [a, b, c]\n        z, y, x = sorted(nodes_p, key=lambda n: n.key)\n\n        # Identify the four subtrees T0, T1, T2, T3\n        T0, T1, T2, T3 = None, None, None, None\n        \n        # Collect all children of a, b, c\n        all_children = []\n        for v in nodes_p:\n            all_children.append(v.left)\n            all_children.append(v.right)\n            \n        # The four subtrees are the children that are not a, b, or c themselves\n        for t in all_children:\n            if t not in nodes_p:\n                if t is None:\n                    continue\n                # Assign subtrees to T0-T3 based on their key range\n                if t.key < z.key:\n                    T0 = t\n                elif z.key < t.key < y.key:\n                    T1 = t\n                elif y.key < t.key < x.key:\n                    T2 = t\n                else: # t.key > x.key\n                    T3 = t\n\n        # Perform the restructuring\n        # The median node y becomes the new root of this local subtree\n        y.left = z\n        y.right = x\n        \n        # Re-attach the four subtrees\n        z.left = T0\n        z.right = T1\n        x.left = T2\n        x.right = T3\n\n        # Update heights of the modified nodes, from bottom-up\n        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        \n        # Return the new root of the balanced subtree\n        return y\n\n    def preorder(self):\n        \"\"\"Returns the pre-order traversal of the tree.\"\"\"\n        result = []\n        self._preorder_recursive(self.root, result)\n        return result\n\n    def _preorder_recursive(self, node, result):\n        if node:\n            result.append(node.key)\n            self._preorder_recursive(node.left, result)\n            self._preorder_recursive(node.right, result)\n\ndef solve():\n    test_cases = [\n        [],\n        [30, 20, 10],\n        [10, 20, 30],\n        [30, 10, 20],\n        [10, 30, 20],\n        [10, 20, 30, 40, 50, 25],\n        [10, 10, 10],\n    ]\n\n    results = []\n    for keys in test_cases:\n        tree = AVLTree()\n        for key in keys:\n            tree.insert(key)\n        results.append(tree.preorder())\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join(str(r).replace(' ', '') for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3210793"}]}