{"hands_on_practices": [{"introduction": "B+树的性能保证不仅取决于其平衡结构，还取决于其节点填充率的下限。为了深刻理解B+树在动态更新（插入和删除）下的行为，一个极好的练习是尝试构建一个“最稀疏”的B+树。这个练习 [@problem_id:3212380] 将指导你通过一系列精心设计的操作，构建一个所有节点都恰好维持在最低填充率的B+树，从而让你对节点的合并与再平衡机制有更直观和深刻的认识。", "problem": "考虑一个阶为 $m$ 的B+树，其键为有序整数集合，并具有以下标准属性。每个内部节点最多有 $m$ 个子节点，除根节点外，至少有 $\\left\\lceil \\frac{m}{2} \\right\\rceil$ 个子节点；如果根节点不是叶子节点，它至少有 $2$ 个子节点。每个叶子节点只存储数据键（树中的所有键都存在于叶子节点中），并且可以容纳 $\\left\\lceil \\frac{m}{2} \\right\\rceil$ 到 $m$ 个键。一个有 $c$ 个子节点的内部节点恰好持有 $c-1$ 个分隔键。插入和删除操作使用标准的B+树再平衡语义：当上溢时，节点分裂；当下溢时，尝试从兄弟节点进行重新分配，如果不可能，则执行合并操作；在所有情况下，根据标准算法的要求，更新父节点的分隔键以及可能更高的祖先节点。\n\n从一个空树开始，构造一个具体的、明确的整数键插入和删除序列，对于任何给定的高度 $h \\geq 1$（根节点在深度 $0$，叶子节点在深度 $h$），该序列能将树转变为一个高度为 $h$ 的配置，其中除根节点外的每个内部节点恰好有 $\\left\\lceil \\frac{m}{2} \\right\\rceil$ 个子节点，根节点恰好有 $2$ 个子节点，并且每个叶子节点恰好有 $\\left\\lceil \\frac{m}{2} \\right\\rceil$ 个键。对于每个 $h$，您的构造过程必须是有限的，并且必须仅依赖于上面定义的标准B+树操作。请证明为什么您的构造在所构造序列的末尾能够达到并保持所述的最小占用配置。\n\n然后，用 $m$ 和 $h$ 表示，确定一个闭式表达式 $N_{\\min}(h,m)$，用于计算当树的高度恰好为 $h$ 并且处于上述最小占用配置时，树中存储的最小可能总键数。请以 $N_{\\min}(h,m)$ 的单个闭式解析表达式的形式提供您的最终答案。无需四舍五入。", "solution": "该问题经评估有效。这是一个在数据结构与算法领域内定义明确的问题，基于B+树的标准定义。其前提条件内部一致且科学合理。\n\n该问题包含两个部分。第一，设计一个构造性过程，以创建一个处于最小配置、指定高度为 $h$ 的B+树。第二，推导该树中键数量的闭式表达式。\n\n设B+树的阶为 $m$。一个内部节点（根节点除外）的最小子节点数为 $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$。一个叶子节点的最小键数也为 $k$。对于非叶子的根节点，最小子节点数为 $2$。我们假设 $m \\geq 3$，这确保了 $k \\geq 2$。\n\n**第一部分：最小树的构造**\n\n一个高度为 $h \\geq 1$ 的树的目标配置如下：\n- 根节点，在深度 $0$ 处，恰好有 $2$ 个子节点。\n- 位于深度 $i \\in \\{1, 2, \\ldots, h-1\\}$ 的每个内部节点恰好有 $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$ 个子节点。\n- 位于深度 $h$ 的每个叶子节点恰好包含 $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$ 个键。\n\n可以通过算法描述一个操作序列来达到此状态。总策略是首先构造一个所需高度为 $h$ 的B+树，然后系统地使用基于删除的操作（重新分配和合并）来“修剪”这棵树，直到所有节点都达到其指定的最小占用率。\n\n对于给定的高度 $h \\geq 1$ 的构造过程：\n\n1.  **高度增长阶段：** 最初的目标是创建一个任意有效的高度为 $h$ 的B+树。这通过强制一系列根节点分裂来完成。\n    a.  从一棵空树开始。插入 $m+1$ 个不同的整数键。根据标准的B+树插入算法，初始的叶子节点将会上溢并分裂。一个新的根节点被创建，它有 $2$ 个子节点（两个新的叶子节点），树的高度变为 $1$。\n    b.  要将高度从 $i-1$ 增加到 $i$，高度为 $i-1$ 的树的根节点必须分裂。一个有 $c$ 个子节点的根节点包含 $c-1$ 个分隔键。要使其上溢，需要强制它容纳 $m+1$ 个子节点，这意味着在分裂前它必须包含 $m$ 个分隔键。\n    c.  假设我们有一棵高度为 $i-1$ 的树。其根节点拥有一定数量的子节点，比如 $c_{root}$ 个。要使这个根节点分裂，我们必须在其后代节点中引发 $m+1 - c_{root}$ 次分裂，使得产生的新分隔键被提升到根节点。这可以通过一系列有针对性的插入来实现。例如，重复插入比任何现有键都大的键，将导致沿树的最右路径发生一连串的分裂。通过策划足够数量的此类插入，我们可以使足够多的分隔键被提升到根节点，将其填满直到有 $m$ 个分隔键，然后在下一次提升时分裂。\n    d.  重复此过程，直到形成一棵高度为 $h$ 的树。当一棵高度为 $h-1$ 的树的根节点分裂时，新的根节点有 $2$ 个子节点，整个树的高度变为 $h$。\n\n2.  **修剪阶段：** 在增长阶段之后，我们得到了一棵有效的高度为 $h$ 的B+树。根节点有 $2$ 个子节点，因为它是由一次分裂刚刚形成的。但是，树中的其他节点不保证处于最小配置。我们现在修剪这棵树，通常以自下而上的方式进行。\n    a.  **修剪叶子节点：** 对于深度为 $h$ 的每个包含 $n_L$ 个键且 $n_L > k$ 的叶子节点 $L$：从 $L$ 中删除 $n_L - k$ 个键。由于 $k$ 是允许的最小键数，这些删除不会在 $L$ 本身引起下溢。\n    b.  **修剪内部节点：** 对于深度为 $i \\in \\{1, \\ldots, h-1\\}$ 的每个拥有超过 $c_N > k$ 个子节点的内部节点 $N$：我们必须将其子节点数量减少到 $k$。这通过在其子节点之间强制进行 $c_N - k$ 次合并操作来完成。\n        i.  为了强制节点 $N$ 的两个相邻子节点 $C_1$ 和 $C_2$ 合并，必须使其中一个发生下溢，而其兄弟节点无法通过重新分配提供键/子节点。这可以被精心安排。我们确保以 $C_1$ 和 $C_2$ 为根的子树中的所有节点已经通过自下而上应用此过程被修剪到它们的最小尺寸。\n        ii.  然后，我们在 $C_1$ 的子树中选择一个叶子节点并删除一个键，使其发生下溢（它现在有 $k-1$ 个键）。由于其兄弟叶子节点是最小的（有 $k$ 个键），重新分配是不可能的，从而强制合并。\n        iii.  在叶子层的这次合并会从父节点中移除一个子节点。这个效应会向上传播。深度为 $j$ 的两个节点合并，会导致它们在深度 $j-1$ 的父节点失去一个子节点。\n        iv.  通过系统地触发此类合并，我们可以将节点 $N$ 的子节点数量从 $c_N$ 减少到 $k$。对所有非根且占用过多的内部节点重复此过程。\n\n这个两阶段的构造方法保证能产生所需的最小配置。使用的每个操作（插入、删除、分裂、合并、重新分配）都是B+树维护算法的标准部分。目标占用率（根节点的子节点为 $2$，所有其他节点为 $k$）等于或高于B+树属性所要求的最小值，因此这是一个有效、稳定的配置。\n\n**第二部分：$N_{\\min}(h,m)$的推导**\n\n我们现在计算这个最小配置、高度为 $h$ 的B+树中存储的总键数 $N_{\\min}(h,m)$。在B+树中，数据键只存储在叶子节点中。因此，我们需要找出叶子节点的总数，并将其乘以每个叶子节点中的键数。\n\n设 $k = \\left\\lceil \\frac{m}{2} \\right\\rceil$。最小树的结构如下：\n- 根节点在深度 $0$ 处，有 $2$ 个子节点。这在深度 $1$ 处产生了 $2$ 个节点。\n- 在深度为 $i$（其中 $1 \\leq i \\leq h-1$）的每个内部节点有 $k$ 个子节点。\n- 在深度为 $h-1$ 的节点是叶子节点的父节点，并且每个也有 $k$ 个子节点。\n\n让我们计算每个深度 $i$ 的节点数量：\n- 深度 $0$ 的节点数：$1$（根节点）。\n- 深度 $1$ 的节点数：$2$（根节点的子节点）。\n- 深度 $2$ 的节点数：深度 $1$ 的 $2$ 个节点各有 $k$ 个子节点，因此深度 $2$ 有 $2 \\times k$ 个节点。\n- 深度 $3$ 的节点数：深度 $2$ 的 $2k$ 个节点各有 $k$ 个子节点，因此深度 $3$ 有 $(2k) \\times k = 2k^2$ 个节点。\n\n通过归纳法，对于 $1 \\leq i \\leq h$，深度为 $i$ 的节点数为 $2 \\times k^{i-1}$。\n\n为了找到叶子节点的数量，我们对深度 $i=h$ 进行计算。\n叶子节点数 = 深度为 $h$ 的节点数 = $2 \\times k^{h-1}$。\n\n根据指定的最小配置，每个叶子节点恰好包含 $k$ 个键。\n总键数 $N_{\\min}(h,m)$ 是叶子节点数与每个叶子节点键数的乘积。\n$$N_{\\min}(h,m) = (\\text{Number of leaves}) \\times (\\text{Keys per leaf})$$\n$$N_{\\min}(h,m) = (2 \\times k^{h-1}) \\times k$$\n$$N_{\\min}(h,m) = 2 \\times k^h$$\n\n将 $k$ 的定义代入表达式，我们得到以 $h$ 和 $m$ 表示的最终闭式公式：\n$$N_{\\min}(h,m) = 2 \\left( \\left\\lceil \\frac{m}{2} \\right\\rceil \\right)^h$$\n\n该公式表示在阶为 $m$、高度为 $h$ 的B+树中可能的最小键数。", "answer": "$$\n\\boxed{2 \\left( \\left\\lceil \\frac{m}{2} \\right\\rceil \\right)^h}\n$$", "id": "3212380"}, {"introduction": "在数据库系统和文件系统的演进中，将数据从一种索引结构迁移到另一种是常见任务。这个练习 [@problem_id:3212354] 提出了一个实际问题：如何高效地将一个B树转换为B+树？通过分析不同的转换策略，你将发现，相比于逐个插入的朴素方法，利用B树的有序性进行“批量加载”是一种在复杂度和实际性能上都远为优越的算法思想。", "problem": "考虑一个阶为 $m$ 的 B 树，它存储了 $n$ 个不同的键。根据定义，一个阶为 $m$ 的 B 树，除了根节点外，每个节点都满足以下约束：每个内部节点有 $\\lceil m/2 \\rceil$ 到 $m$ 个子节点，因此有 $\\lceil m/2 \\rceil - 1$ 到 $m - 1$ 个键；根节点有 $2$ 到 $m$ 个子节点（除非它本身是叶子节点）。一个阶为 $m$ 的 B+ 树是一种搜索树，其中所有数据键都位于叶子节点中；内部节点只包含用于引导搜索的分隔键，所有叶子节点都在同一深度，内部节点有 $\\lceil m/2 \\rceil$ 到 $m$ 个子节点（根节点的最小子节点数有通常的放宽），每个叶子节点包含 $\\lceil m/2 \\rceil$ 到 $m - 1$ 个键，并且所有叶子节点通过兄弟指针按键序链接。\n\n要求您将给定的阶为 $m$ 的 B 树转换为一个结构正确的、阶数同样为 $m$ 的 B+ 树，且不改变键的多重集，并在标准的随机存取机（RAM）模型上分析您的方法的最坏情况时间复杂度。请选择一个选项，该选项既描述了正确的转换算法，又指出了以 $n$ 和 $m$ 表示的转换过程的紧凑最坏情况时间复杂度。\n\nA. 对 B 树进行中序遍历以获得按升序排列的 $n$ 个键。将这些键从左到右填充到叶子节点中，每个叶子节点包含 $\\lceil m/2 \\rceil$ 到 $m - 1$ 个键，并链接连续的叶子节点。通过将每个父节点最多分组 $m$ 个连续子节点，并当父节点有 $d$ 个子节点时，用每个非最左子节点的最小键填充父节点的 $d - 1$ 个分隔键，自底向上构建内部层级。如果最后一个叶子块未满，则在构建父节点之前，在相邻的叶子节点之间重新分配键以满足占用率约束。总的最坏情况时间为 $O(n)$，需要 $O(n)$ 的辅助空间。\n\nB. 重用原始 B 树的内部节点，将其键重新标记为分隔符，并在其下方附加新创建的叶子节点，这些叶子节点包含与内部节点相同的键。调整指针以确保所有叶子节点都在同一深度。因为除了局部指针重连之外不需要遍历，所以最坏情况时间为 $O(\\log n)$。\n\nC. 使用标准的 B+ 树插入算法，将 B 树中的 $n$ 个键逐个插入一个初始为空的阶为 $m$ 的 B+ 树中，该算法在溢出时分裂节点，在下溢时重新分配。这将生成一个有效的 B+ 树，在最坏情况下需要 $O(n \\log n)$ 的时间。\n\nD. 如果不重新排序所有键并通过重复的再平衡来重建树，就不可能保证转换后的 B+ 树具有相同的阶数 $m$；任何转换都必须花费 $\\Omega(n \\log n)$ 的时间。", "solution": "该问题要求找到将B树高效转换为B+树的算法及其复杂度。\n\n1.  **核心任务**：转换的本质是将一个键与数据分布于所有节点（B树）的结构，变为一个所有数据键都只存在于叶子节点（B+树）的结构。关键在于B树本身已经维护了所有键的有序性。\n\n2.  **最优策略**：最高效的方法是利用B树的有序性，避免逐个插入的高昂成本。\n    *   **步骤一：提取有序键**。对B树进行一次中序遍历（in-order traversal），可以在 $O(n)$ 时间内提取出所有 $n$ 个键，并得到一个已排序的键列表。\n    *   **步骤二：批量加载 (Bulk Loading)**。从这个排序好的键列表自底向上构建一个新的B+树。这个过程同样可以在 $O(n)$ 时间内完成。首先，将 $n$ 个键顺序填充到叶子节点中，并用指针连接它们。然后，根据叶子节点生成上一层的内部节点，再根据上一层生成更上一层，直到构建出根节点。由于每一层的节点总数呈几何级数递减（大约 $n/m, n/m^2, \\dots, 1$），构建所有内部节点的总工作量是线性的，即 $O(n)$。\n\n3.  **算法分析**：整个过程包括一次 $O(n)$ 的遍历和一次 $O(n)$ 的构建，总时间复杂度为 $O(n)$。此过程需要 $O(n)$ 的辅助空间来存储排序后的键列表。\n\n4.  **选项评估**：\n    *   **选项 A**：该选项描述了上述最优的批量加载算法。它首先通过中序遍历（或等效方式）获得排序键，然后自底向上构建B+树。其 $O(n)$ 的时间复杂度和 $O(n)$ 的空间复杂度声明是正确的。因此，这是一个正确且高效的解决方案。\n    *   **选项 B**：该方法存在根本性缺陷。它只重用了内部节点，忽略了B树叶子节点中存储的键。所描述的指针调整无法构建出合法的B+树。其 $O(\\log n)$ 的复杂度也是错误的，因为它没有处理全部 $n$ 个键。因此，该选项不正确。\n    *   **选项 C**：该方法——将 $n$ 个键逐个插入新的B+树——在功能上是可行的。然而，B+树单次插入的最坏情况时间复杂度为 $O(\\log_m n)$，重复 $n$ 次的总时间复杂度为 $O(n \\log_m n)$。虽然算法本身是正确的，但它不是最高效的转换方法，因此不是最佳答案。\n    *   **选项 D**：该选项声称转换的下界是 $\\Omega(n \\log n)$，这是错误的。因为我们可以通过对B树进行中序遍历在 $O(n)$ 时间内获得一个排序好的列表，绕过了通用的 $\\Omega(n \\log n)$ 排序下界。如选项A所示，存在一个线性的转换算法。因此，该选项不正确。\n\n综上所述，选项A提供了最有效且正确的转换算法和复杂度分析。", "answer": "$$\\boxed{A}$$", "id": "3212354"}, {"introduction": "理论知识最终需要通过实践来巩固。这个练习 [@problem_id:3212331] 将带你亲手实现一个B+树，并为其增加一个高级功能——“指尖搜索”（finger search）。通过利用B+树特有的叶子节点链表结构，指尖搜索可以显著加速具有局部性特征的连续查询，这个实现过程将让你深刻体会到B+树相比于B树在特定应用场景下的设计优势。", "problem": "你需要实现一个 B$+$ 树，该树支持插入、基准搜索以及一种利用叶级链表加速邻近近期结果搜索的“指尖搜索”。实现必须遵循以下基本原理和核心定义，不得使用捷径。\n\n从以下数据结构与算法中标准的多路平衡搜索树的基本法则和核心定义开始：\n\n1. 一个阶为 $b$ 的 B 树是一棵有根树，其中除了根节点外，每个内部节点都有 $\\lceil b/2 \\rceil$ 到 $b$ 个子节点，并存储 $\\lceil b/2 \\rceil - 1$ 到 $b - 1$ 个分隔键，所有叶子节点都处于同一深度。\n2. B$+$ 树是对 B 树的修改，所有搜索键和相关记录都存放在叶子节点中，而内部节点只存储分隔键和指针。叶子节点通过“next”指针（可选地还有“previous”指针）形成一个链表，从而提供保序的顺序访问。\n3. 在一个最大子节点数为 $b$ 的 B$+$ 树中，每个内部节点最多存储 $b - 1$ 个键，其键的数量恰好比子节点数少一。每个叶子节点最多存储 $b - 1$ 个键。当一个节点溢出时，它会分裂成两个节点，并将一个分隔键提升到父节点中。当父节点溢出时，它会递归地向上分裂，直到根节点，这可能导致树的高度增加 $1$。\n\n你必须在一个参数为 $b$ 的 B$+$ 树上实现以下操作：\n\n- 插入 $\\text{insert}(k)$：将一个键 $k$ 插入树中，同时维持上述所有 B$+$ 树的不变性，包括叶级链接和分裂时的分隔键提升。\n- 基准搜索 $\\text{standard\\_search}(k)$：从根节点开始，向下遍历内部节点（每次决策基于分隔键）以到达可能包含 $k$ 的叶子节点；报告 $k$ 是否存在。节点访问次数计算如下：每个访问过的内部节点计为 $1$，最后访问的叶子节点计为 $1$。\n- 指尖搜索 $\\text{finger\\_search}(k)$：给定一个当前指向某个叶子节点（初始为 $\\text{None}$）的“指尖”，通过扫描叶级指针来尝试定位包含 $k$ 的叶子节点。具体来说，从指尖所在的叶子节点开始；如果 $k$ 位于该叶子节点存储的最小键和最大键的范围内，则使用该叶子节点。否则，当 $k$ 小于当前叶子节点的最小键时，通过前一个指针向左移动；当 $k$ 大于当前叶子节点的最大键时，通过下一个指针向右移动，每次访问一个叶子节点计为 $1$。如果指尖为 $\\text{None}$，则退回到基准搜索。每次查询后，将指尖更新为搜索结束的叶子节点（如果 $k$ 存在，则为包含 $k$ 的叶子节点，否则为搜索将放置 $k$ 的叶子节点）。\n- 对于 $\\text{standard\\_search}(k)$ 和 $\\text{finger\\_search}(k)$，你都必须将“节点访问次数”计量为访问的内部节点和叶子节点的总和。在 $\\text{standard\\_search}(k)$ 中，这等于从根到叶子路径上的内部节点数加上 $1$（用于叶子节点）。在 $\\text{finger\\_search}(k)$ 中，这等于从指尖叶子节点开始遍历的叶子节点数，加上 $0$ 个内部节点，除非指尖为 $\\text{None}$，此时使用标准搜索。\n\n你的程序必须为每个测试用例构建一个 B$+$ 树，使用基准搜索和指尖搜索（按照规定更新演变的指尖）运行一系列查询，并为每个测试用例聚合查询序列上的节点访问次数差异：\n$$\nD \\;=\\; \\sum_{q \\in Q} \\left( c_{\\text{std}}(q) \\;-\\; c_{\\text{finger}}(q) \\right),\n$$\n其中 $Q$ 是查询序列，$c_{\\text{std}}(q)$ 是 $\\text{standard\\_search}(q)$ 下的节点访问计数，$c_{\\text{finger}}(q)$ 是 $\\text{finger\\_search}(q)$ 下的节点访问计数。一个正数的 $D$ 表示指尖搜索在总体上执行了更少的节点访问；一个负数的 $D$ 表示其性能比基准搜索差。\n\n测试套件：\n你必须硬编码以下测试用例，每个用例由 $(b, K, Q)$ 指定，其中 $b$ 是每个内部节点的最大子节点数，$K$ 是要插入的键序列，$Q$ 是搜索查询序列。对于 $K$，所有键都是升序的整数，但对于 $Q$，键可以是任意的。\n\n- 测试用例 1：$b = 4$，$K = [\\,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32\\,]$，$Q = [\\,6,7,8,9,10\\,]$。\n- 测试用例 2：$b = 4$，$K = [\\,1,2,3,\\dots,64\\,]$（即从 $1$ 到 $64$ 的所有整数），$Q = [\\,5,60,4,58\\,]$。\n- 测试用例 3：$b = 3$，$K = [\\,10,20,30,40,50,60\\,]$，$Q = [\\,35,30,25,10,5\\,]$。\n- 测试用例 4：$b = 5$，$K = [\\,5,15,25,35,45,55,65,75,85,95\\,]$，$Q = [\\,75,76,77,78,80,85\\,]$。\n\n对于每个测试用例，使用指定的 $b$ 构建树，并按顺序插入 $K$ 中的所有键。然后，通过计算 $\\text{standard\\_search}(q)$ 得到的 $c_{\\text{std}}(q)$ 和 $\\text{finger\\_search}(q)$ 得到的 $c_{\\text{finger}}(q)$ 来处理 $Q$ 中的每个查询 $q$，按描述更新指尖，并累加差异 $D$。\n\n答案规格：\n你的程序必须生成单行输出，其中包含四个测试用例的 $D$ 值，格式为一个用方括号括起来的逗号分隔列表，顺序与给定测试用例的顺序相同。例如，一个有效的格式是 [$d_1$,$d_2$,$d_3$,$d_4$]，其中每个 $d_i$ 是一个整数。\n\n此问题不涉及物理单位、角度或百分比。输出为整数，并且必须严格按照指定的列表格式单行打印。", "solution": "用户的请求是实现一个具有特定插入和搜索功能的 B$+$ 树，然后用它来评估标准自顶向下搜索和利用叶级链表的“指尖”搜索之间的性能差异。该问题定义明确，在数据结构理论方面有科学依据，并提供了足够的细节来构建一个确定性的解决方案。因此，它被认为是一个有效的问题。\n\n### I. 数据结构设计\n\n将使用一组类来实现 B$+$ 树，以表示节点和树本身，并遵循所提供的定义。\n\n1.  **`BPlusTreeNode`**：所有节点的基类，包含一个 `keys` 列表和对 `parent` 节点的引用。\n2.  **`BPlusTreeInternalNode`**：内部节点的子类。它继承自 `BPlusTreeNode` 并增加了一个 `children` 指针列表。内部节点存储分隔键以引导搜索。\n3.  **`BPlusTreeLeafNode`**：叶子节点的子类。它也继承自 `BPlusTreeNode` 并存储所有数据键。关键的是，它包含 `prev_leaf` 和 `next_leaf` 指针，以在叶子层级形成双向链表，从而为指尖搜索启用顺序遍历。\n4.  **`BPlusTree`**：封装树结构的主类。它持有一个对 `root` 节点的引用、阶参数 $b$ 以及 `finger` 指针，该指针是在 `finger_search` 中使用的对 `BPlusTreeLeafNode` 的引用。\n\n### II. 算法实现\n\n这些操作基于标准的 B$+$ 树算法实现，并根据问题的具体要求进行了细化。\n\n#### 插入 (`insert(k)`)\n插入遵循一个两阶段过程：\n1.  **搜索阶段**：从根开始遍历树，找到应该插入键 $k$ 的相应叶子节点。此遍历与标准搜索相同。\n2.  **插入与分裂阶段**：\n    a. 将键 $k$ 插入到目标叶子节点的已排序 `keys` 列表中。\n    b. 如果叶子节点的容量超出（即，它持有 $b$ 个键），则必须进行分裂。该叶子节点的键被分为两组。前 $\\lfloor b/2 \\rfloor$ 个键保留在原始叶子节点中，其余的键形成一个新的叶子节点。新叶子节点的第一个键被“复制提升”到父内部节点中，作为新的分隔符。新的叶子节点被整合到叶级链表中。\n    c. 将分隔键插入父节点是一个递归过程。如果父内部节点也溢出（即，它有超过 $b$ 个子节点），它也需要分裂。对于一个有 $b$ 个键（和 $b+1$ 个子节点）的内部节点，位于索引 $\\lceil b/2 \\rceil - 1$ 的键被“推上”其父节点，剩余的键和子节点被分配到原始节点和一个新的内部节点之间。这个过程可以一直传播到根节点。如果根节点本身也分裂，将创建一个新的根，树的高度增加一。\n\n#### 标准搜索 (`standard_search(k)`)\n这是一个直接的自顶向下搜索。\n1.  从 `root` 开始。\n2.  如果当前节点是内部节点，则将搜索键 $k$ 与该节点的分隔键进行比较，以确定要跟随哪个子指针。每个访问的内部节点会使访问成本增加 $1$。\n3.  重复此过程直到到达一个叶子节点。访问叶子节点会使成本最终增加 $1$。因此，总成本等于树的高度。搜索在包含 $k$ 或如果 $k$ 存在时本应包含它的叶子节点处结束。\n\n#### 指尖搜索 (`finger_search(k)`)\n此搜索利用“引用局部性”原理，假设后续的搜索可能靠近前一次搜索的位置。\n1.  一个 `finger` 指向最后一次搜索结束的叶子节点。如果 `finger` 是 `None`（例如，对于第一次查询），则搜索默认使用 `standard_search`。\n2.  如果存在 `finger`，搜索从它指向的叶子节点开始。访问成本从 $1$ 开始。\n3.  如果 $k$ 不在当前叶子节点的键范围内，搜索将遍历叶级链表。\n    - 如果 $k$ 小于当前叶子节点的最小键，则使用 `prev_leaf` 指针向左移动。\n    - 如果 $k$ 大于当前叶子节点的最大键，则使用 `next_leaf` 指针向右移动。\n4.  每个遍历的叶子节点（包括起始和结束叶子节点）都会使访问成本增加 $1$。根据问题指定的停止条件，当当前叶子节点是 $k$ 不再严格超出其范围的节点时，遍历停止。\n5.  在任何搜索（`standard_search` 或 `finger_search`）之后，`finger` 都会更新为指向该搜索终止的叶子节点。\n\n### III. 执行与计算\n\n对于每个测试用例 $(b, K, Q)$，程序首先通过顺序插入列表 $K$ 中的所有键来构建 B$+$ 树。然后，对于列表 $Q$ 中的每个查询键 $q$，它同时执行 `standard_search` 和 `finger_search`。记录节点访问成本 $c_{\\text{std}}(q)$ 和 $c_{\\text{finger}}(q)$。将差值 $c_{\\text{std}}(q) - c_{\\text{finger}}(q)$ 累加到总差值 $D$ 中。每次查询后都会更新 `finger`。所有测试用例的最终 $D$ 值列表构成了解决方案。\n\n该实现依赖 Python 的 `bisect` 模块，以在节点的已排序键列表中进行高效搜索。", "answer": "```python\nimport bisect\nimport math\n\nclass BPlusTreeNode:\n    \"\"\"Base class for B+ Tree nodes.\"\"\"\n    def __init__(self, parent=None, is_leaf=False):\n        self.parent = parent\n        self.keys = []\n        self.is_leaf = is_leaf\n\nclass BPlusTreeInternalNode(BPlusTreeNode):\n    \"\"\"Internal node for a B+ Tree.\"\"\"\n    def __init__(self, parent=None):\n        super().__init__(parent, is_leaf=False)\n        self.children = []\n\n    def find_child(self, key):\n        \"\"\"Find the child to follow for a given key.\"\"\"\n        idx = bisect.bisect_right(self.keys, key)\n        return self.children[idx]\n\nclass BPlusTreeLeafNode(BPlusTreeNode):\n    \"\"\"Leaf node for a B+ Tree.\"\"\"\n    def __init__(self, parent=None):\n        super().__init__(parent, is_leaf=True)\n        self.prev_leaf = None\n        self.next_leaf = None\n\nclass BPlusTree:\n    \"\"\"\n    B+ Tree implementation supporting insertion and two search methods.\n    \n    Attributes:\n        b (int): Maximum number of children for internal nodes.\n        root (BPlusTreeNode): The root of the tree.\n        finger (BPlusTreeLeafNode): Pointer to the last accessed leaf for finger search.\n    \"\"\"\n    def __init__(self, b):\n        if b  3:\n            raise ValueError(\"B-Tree order b must be at least 3\")\n        self.b = b\n        self.root = BPlusTreeLeafNode()\n        self.finger = None\n\n    def _find_leaf(self, key):\n        \"\"\"Traverse to a leaf, counting node accesses.\"\"\"\n        node = self.root\n        cost = 0\n        while not node.is_leaf:\n            cost += 1\n            node = node.find_child(key)\n        cost += 1  # For the leaf itself\n        return node, cost\n\n    def _find_leaf_no_cost(self, key):\n        \"\"\"Traverse to a leaf without counting cost.\"\"\"\n        node = self.root\n        while not node.is_leaf:\n            node = node.find_child(key)\n        return node\n\n    def insert(self, key):\n        \"\"\"Insert a key into the B+ tree.\"\"\"\n        leaf = self._find_leaf_no_cost(key)\n        \n        # Avoid duplicates for simplicity as per implicit problem setup\n        if key in leaf.keys:\n            return\n\n        bisect.insort_left(leaf.keys, key)\n\n        # A leaf overflows if it has b keys.\n        if len(leaf.keys) == self.b:\n            self._split_leaf(leaf)\n\n    def _split_leaf(self, leaf):\n        \"\"\"Split a full leaf node.\"\"\"\n        mid_idx = self.b // 2\n        \n        new_leaf = BPlusTreeLeafNode(parent=leaf.parent)\n        new_leaf.keys = leaf.keys[mid_idx:]\n        leaf.keys = leaf.keys[:mid_idx]\n\n        new_leaf.next_leaf = leaf.next_leaf\n        if leaf.next_leaf:\n            leaf.next_leaf.prev_leaf = new_leaf\n        leaf.next_leaf = new_leaf\n        new_leaf.prev_leaf = leaf\n        \n        promotion_key = new_leaf.keys[0]\n        self._insert_in_parent(leaf, promotion_key, new_leaf)\n\n    def _insert_in_parent(self, left_child, key, right_child):\n        \"\"\"Recursively insert a key and a new child into a parent node.\"\"\"\n        parent = left_child.parent\n        if parent is None:\n            new_root = BPlusTreeInternalNode()\n            new_root.keys = [key]\n            new_root.children = [left_child, right_child]\n            left_child.parent = new_root\n            right_child.parent = new_root\n            self.root = new_root\n            return\n\n        idx = bisect.bisect_left(parent.keys, key)\n        parent.keys.insert(idx, key)\n        parent.children.insert(idx + 1, right_child)\n        right_child.parent = parent\n        \n        # An internal node overflows if it has more than b children.\n        if len(parent.children) > self.b:\n            self._split_internal(parent)\n\n    def _split_internal(self, node):\n        \"\"\"Split a full internal node.\"\"\"\n        # For b children, there are b-1 keys. For b+1 children, b keys.\n        mid_idx = self.b // 2\n\n        promoted_key = node.keys[mid_idx]\n        \n        new_node = BPlusTreeInternalNode(parent=node.parent)\n        new_node.keys = node.keys[mid_idx + 1:]\n        new_node.children = node.children[mid_idx + 1:]\n        \n        node.keys = node.keys[:mid_idx]\n        node.children = node.children[:mid_idx + 1]\n\n        for child in new_node.children:\n            child.parent = new_node\n            \n        self._insert_in_parent(node, promoted_key, new_node)\n\n    def standard_search(self, key):\n        \"\"\"Perform a standard top-down search.\"\"\"\n        leaf, cost = self._find_leaf(key)\n        return leaf, cost\n\n    def finger_search(self, key):\n        \"\"\"Perform a finger search starting from the last accessed leaf.\"\"\"\n        if self.finger is None:\n            return self.standard_search(key)\n\n        current_leaf = self.finger\n        cost = 1\n\n        if not current_leaf.keys or key  current_leaf.keys[0]:\n            while current_leaf.prev_leaf and key  current_leaf.keys[0]:\n                current_leaf = current_leaf.prev_leaf\n                cost += 1\n        elif key > current_leaf.keys[-1]:\n            while current_leaf.next_leaf and key > current_leaf.keys[-1]:\n                current_leaf = current_leaf.next_leaf\n                cost += 1\n        \n        return current_leaf, cost\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute the performance difference D.\n    \"\"\"\n    test_cases = [\n        (4, list(range(1, 33)), [6, 7, 8, 9, 10]),\n        (4, list(range(1, 65)), [5, 60, 4, 58]),\n        (3, [10, 20, 30, 40, 50, 60], [35, 30, 25, 10, 5]),\n        (5, [5, 15, 25, 35, 45, 55, 65, 75, 85, 95], [75, 76, 77, 78, 80, 85]),\n    ]\n\n    results = []\n    for b, K, Q in test_cases:\n        tree = BPlusTree(b=b)\n        for key in K:\n            tree.insert(key)\n        \n        total_diff = 0\n        for q in Q:\n            # Standard search (finger is not updated by this)\n            std_leaf, c_std = tree.standard_search(q)\n            \n            # Finger search (uses and then updates finger)\n            finger_leaf, c_finger = tree.finger_search(q)\n            tree.finger = finger_leaf\n            \n            total_diff += (c_std - c_finger)\n            \n        results.append(total_diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3212331"}]}