{"hands_on_practices": [{"introduction": "要真正掌握 B 树的删除操作，理解其最坏情况下的性能至关重要。这个练习引导我们探讨一个看似简单的问题：单次密钥删除最多能引发多少次节点合并？通过构建一个特定的“瘦”B 树并追踪删除操作，我们可以揭示合并操作的级联效应，这种效应会从叶节点一直传播到根节点。这项分析不仅能加深我们对 B 树再平衡机制的理解，也为评估算法在极端场景下的开销提供了理论依据。[@problem_id:3211412]", "problem": "B树是一种平衡多路搜索树，它由一个最小度 $t \\geq 2$ 参数化。在一个最小度为 $t$ 的B树中，每个内部节点（根节点可能除外）包含 $t-1$ 到 $2t-1$ 个键，因此有 $t$ 到 $2t$ 个子节点；根节点包含 $1$ 到 $2t-1$ 个键，除非它同时也是一个叶节点，这种情况下它可以包含 $0$ 个键。我们将B树的高度 $h$ 定义为从根节点到任意叶节点的最长简单路径上的边数，因此，一个仅由根节点组成的树的高度为 $0$。\n\n考虑B树的标准删除操作，该操作基于以下经过充分检验的事实和核心定义：除根节点外，节点不能下溢（键数降至 $t-1$ 以下）；如果在删除过程中子节点将发生下溢，算法要么通过父节点旋转从兄弟节点重新分配一个键，要么通过从父节点移动一个分隔键到合并后的节点中，将该子节点与一个相邻的兄弟节点合并。单次合并步骤会将恰好 $2$ 个兄弟节点合并成 $1$ 个节点，并使父节点的键数减少 $1$。\n\n假设您在一个最小度为 $t$、高度为 $h$（如上测量）的B树中执行单次键删除操作。您只需计算将两个兄弟节点合并为一个节点的节点合并操作的数量；不要计算重新分配（旋转）操作，也不要将（如果发生）用其唯一子节点替换根节点的最终行为计为一次合并，尽管在该替换之前发生的任何合并都应被计算在内。\n\n在删除操作之前，对于符合B树不变量的一种对抗性但有效的键排列（即最坏情况），单次键删除可能导致的最大节点合并次数是多少？请用 $t$ 和 $h$ 表示。请用变量 $t$ 和 $h$ 的闭式解析表达式给出答案。无需四舍五入。", "solution": "用户希望我确定在最小度为 $t$、高度为 $h$ 的B树中，单次键删除操作所能引起的最大理论节点合并次数。\n\n### 问题验证\n问题陈述提供了B树的正确和标准定义，包括最小度 $t$、节点的键数以及高度 $h$ 的定义。关于B树删除算法的描述，特别是通过重新分配（旋转）或合并来处理节点下溢的方式，也是标准的。问题要求在“对抗性的但有效的排列”下计算最大合并次数，这是算法学中分析最坏情况的标准提问方式。问题是自包含的，科学上基于数据结构理论，并且表述清晰。因此，问题是有效的，可以推导出解决方案。\n\n### 解题推导\n\n为了确定最大合并操作次数，我们必须构建一个最坏情况。当一个节点的键数降至最小值 $t-1$ 以下，并且无法从相邻的兄弟节点重新分配键时，就会触发合并操作。这种情况发生在节点下溢到只有 $t-2$ 个键，并且其邻居也处于最小状态，即恰好有 $t-1$ 个键。如果一个层级上的合并导致其父节点下溢，而父节点的下溢又需要通过合并来解决，如此向上传播，就会发生级联合并，从而产生最大数量的合并次数。\n\n让我们定义一个能够促成这种最大合并级联的对抗性B树结构。\n高度 $h$ 是从根节点到叶节点的边数。这意味着有 $h+1$ 个节点层级，我们可以将其从层级 $0$（根节点）到层级 $h$（叶节点）进行索引。\n最坏情况是一种“瘦高”的B树，其中从根到某个叶节点的特定路径上的所有节点都处于最小填充状态。\n1.  我们选择一条由节点 $N_0, N_1, \\dots, N_h$ 构成的路径，其中 $N_0$ 是根节点，$N_1$ 是 $N_0$ 的子节点，依此类推，直到叶节点 $N_h$。\n2.  为了使级联完全传播，该路径上的每个节点 $N_i$（对于 $i \\in \\{0, 1, \\dots, h-1\\}$）必须具有其类型所允许的最小键数。对于除根节点外的内部节点，这是 $t-1$ 个键。对于根节点，最小键数是 $1$。因此，我们假设对于 $i \\in \\{1, \\dots, h-1\\}$，$N_i$ 有 $t-1$ 个键，而根节点 $N_0$ 有 $1$ 个键。\n3.  将要进行删除操作的叶节点 $N_h$ 也必须是最小的，包含 $t-1$ 个键。\n4.  关键在于，为了在每个层级都强制进行合并而不是旋转，我们路径上节点的兄弟节点也必须是最小的。也就是说，对于每个将要下溢的节点 $N_i$，其相邻的兄弟节点 $S_i$ 必须恰好有 $t-1$ 个键。\n\n在这种B树配置下，让我们追踪从叶节点 $N_h$ 删除一个键所产生的影响。\n\n**从叶节点删除及初始合并（层级 $h$）**\n我们从叶节点 $N_h$ 中删除一个键。\n*   $N_h$ 的初始状态：$t-1$ 个键。\n*   删除后的状态：$t-2$ 个键。由于 $t \\geq 2$，所以 $t-2  t-1$，节点 $N_h$ 发生下溢。\n*   为了修复下溢，我们检查 $N_h$ 的一个相邻兄弟节点，称之为 $S_h$。根据我们的对抗性设计，$S_h$ 也是最小的，有 $t-1$ 个键。因此无法进行旋转。\n*   执行一次合并操作。节点 $N_h$、其兄弟节点 $S_h$ 以及它们父节点 $N_{h-1}$ 中的分隔键被合并成一个新节点。这构成了**第一次合并**。合并后的新节点包含 $(t-2) + (t-1) + 1 = 2t-2$ 个键，这是一个有效的键数（因为 $2t-2 \\leq 2t-1$）。\n\n**下溢的传播与级联合并**\n层级 $h$ 的合并操作需要从其父节点 $N_{h-1}$ 向下拉一个分隔键。\n*   $N_{h-1}$ 的初始状态：$t-1$ 个键（根据我们的对抗性设计）。\n*   其键被下拉后的状态：$(t-1)-1 = t-2$ 个键。现在，层级 $h-1$ 的节点 $N_{h-1}$ 发生下溢。\n*   为了修复这个下溢，我们检查 $N_{h-1}$ 的一个兄弟节点，比如 $S_{h-1}$。这个兄弟节点也是最小的，有 $t-1$ 个键。无法进行旋转。\n*   在 $N_{h-1}$ 和 $S_{h-1}$ 之间执行一次合并，从它们的父节点 $N_{h-2}$ 向下拉一个分隔键。这是**第二次合并**。\n\n这个过程继续向上传播。在层级 $i$（其中 $1 \\le i \\le h$）的一次合并操作是由该层级的下溢引起的。这次合并会消耗父节点（层级 $i-1$）的一个键，导致它也发生下溢，因为它也是最小的。这又触发了在层级 $i-1$ 的一次合并。\n\n**最终合并（层级 1）**\n级联沿着原始删除位置的祖先路径向上传播。\n*   在层级 $1$ 的节点 $N_1$ 处触发了下溢。\n*   节点 $N_1$ 原本有 $t-1$ 个键，但由于层级 $2$ 的合并，它现在只有 $t-2$ 个键。\n*   它的兄弟节点 $S_1$ 也有 $t-1$ 个键。它们必须合并。\n*   这次合并操作从它们的父节点，即根节点 $N_0$，向下拉一个键。这是根节点的两个子节点之间的一次合并。\n\n**计算合并次数**\n合并操作在每个层级都会发生，从叶节点层级（$h$）开始，级联上升到根节点的子节点层级（层级 $1$）。\n*   合并 1：发生在层级 $h$。\n*   合并 2：发生在层级 $h-1$。\n*   ...\n*   合并 $i$：发生在层级 $h-i+1$。\n*   ...\n*   最终合并：发生在层级 $1$。\n\n总合并次数是从层级 $1$ 到 $h$ 的层级数，包含两端。总数是 $h - 1 + 1 = h$。\n\n在层级 $1$ 的最终合并之后，根节点 $N_0$ 失去了一个键。在我们的最坏情况设置中，根节点只有 $1$ 个键。这个键被下拉到合并后的节点中。根节点现在剩下 $0$ 个键和一个子节点。B树结构随后要求移除这个空的根节点，并使其唯一的子节点成为新的根。问题陈述明确指出，不要将这最后一步减少树高的操作计为一次合并。因此，合并操作链在层级 $1$ 的那次之后就停止了。\n\n因此，最大合并次数等于此次级联合并中的合并次数。这个数字恰好是 $h$。这对任何 $t \\geq 2$ 都成立。例如，如果 $h=1$，从一个最小叶节点删除会导致一次与其兄弟节点的合并，根节点失去一个键。总共是 $1$ 次合并。如果 $h=0$，树是单个节点，不可能发生合并，所以计数是 $0$。该公式成立。\n\n最大合并次数仅取决于高度 $h$，而与最小度 $t$ 无关。参数 $t$ 定义了最小状态的条件，但潜在级联的长度是由树的高度决定的。\n\n因此，理论上的最大节点合并次数是 $h$。", "answer": "$$\n\\boxed{h}\n$$", "id": "3211412"}, {"introduction": "理论分析之后，让我们通过一个具体的计算来实践。这个练习将 B 树与另一种经典的平衡树——红黑树——进行了直接对比。你将需要在一个给定的数据集上，严格按照两种数据结构的删除规则，一步步追踪并计算删除同一个密钥所需的“密钥比较”次数。通过这种精细的比较，你可以直观地感受到 B 树基于节点的合并/重分配策略与红黑树基于节点旋转和重新着色的策略在操作细节和开销上的根本差异。[@problem_id:3211517]", "problem": "考虑以下两棵搜索树，它们都构建在同一个由不同整数键组成的有限集合上。设数据集为\n$$\nS=\\{2,5,10,12,15,20,22,25,30,32,35\\}。\n$$\n树 A 是一棵最小度为 $t=3$ 的 B 树（因此，除了根节点外，每个节点存储 $t-1=2$ 到 $2t-1=5$ 个键）。树 A 的高度为 $2$，其确切结构如下：\n- 根节点存储键 $[10,20,30]$。\n- 它有 $4$ 个叶子子节点，从左到右依次为：\n  - 子节点 $0$：$[2,5]$，\n  - 子节点 $1$：$[12,15]$，\n  - 子节点 $2$：$[22,25]$，\n  - 子节点 $3$：$[32,35]$。\n树 B 是一棵有效的红黑树（RBT），存储着相同的键集 $S$，其二叉搜索树（BST）形状明确给出如下：\n- 根节点的键为 $20$。\n- $20$ 的左子树根为 $10$；$10$ 的左子节点为 $5$，$5$ 有左子节点 $2$ 但无右子节点；$10$ 的右子节点为 $15$，$15$ 有左子节点 $12$ 但无右子节点。\n- $20$ 的右子树根为 $30$；$30$ 的左子节点为 $25$，$25$ 有左子节点 $22$ 但无右子节点；$30$ 的右子节点为 $32$，$32$ 有右子节点 $35$ 但无左子节点。\n你需要比较从每棵树中删除单个键 $k=20$ 时所执行的键比较次数。比较过程需遵循以下精确的计数模型和算法假设，这些模型和假设基于 B 树和红黑树操作的标准定义：\n- 一次“键比较”仅在算法比较搜索键 $x$ 与存储的键 $y$ 以决定相等性或遍历方向时计数；与哨兵指针或节点度的比较不计入。\n- 在 B 树（树 A）中，对于任何包含 $m$ 个键的节点，算法通过从左到右的线性扫描来定位 $x$ 的位置，依次将 $x$ 与节点中的每个键进行比较，直到找到第一个 $\\ge x$ 的键或相等。每次这样的比较都要计数。使用标准的 B 树删除过程：如果 $x$ 位于内部节点，且其相邻的子节点键数均少于 $t$，则执行与分隔键的合并操作，然后在合并后的子节点中递归删除。合并过程中的连接/重新分配利用已知的排序顺序，不产生任何键比较。\n- 在红黑树（树 B）中，删除操作按标准红黑树的方式进行：首先通过对键进行普通二叉搜索来定位 $x$；如果节点有两个子节点，则用其的中序后继替换它，其中序后继是通过仅使用指针检查（无键比较）下降到其右子树的最左侧节点来找到的，然后删除该后继节点。旋转、重新着色以及任何指针或空子节点检查均不产生键比较；只计算在键搜索过程中 $x$ 与节点键之间的比较。\n令 $C_{B}$ 表示从树 A（B 树）中删除 $k=20$ 的总键比较次数，令 $C_{R}$ 表示从树 B（红黑树）中删除 $k=20$ 的总键比较次数。计算单个数值差\n$$\n\\Delta = C_{B}-C_{R}。\n$$\n以单个整数形式提供 $\\Delta$ 的值。无需四舍五入。", "solution": "目标是计算差值 $\\Delta = C_{B} - C_{R}$，其中 $C_{B}$ 是从给定的 B 树（树 A）中删除键 $k=20$ 所需的键比较次数，而 $C_{R}$ 是从给定的红黑树（树 B）中执行相同删除操作所需的键比较次数。题目为计算这些比较次数提供了一套特定的规则。\n\n首先，我们分析从 B 树（树 A）中删除的操作来确定 $C_{B}$。\n\n该 B 树的最小度为 $t=3$。根节点包含键 $[10, 20, 30]$。要删除的键是 $k=20$。根据所提供的规则，删除过程分两个主要阶段进行。\n\n**阶段 1：在 B 树中搜索键。**\n搜索从根节点开始。题目规定，节点内的搜索是从左到右的线性扫描。\n1.  我们从包含键 $[10, 20, 30]$ 的根节点开始。\n2.  将搜索键 $k=20$ 与节点的第一个键 $10$ 进行比较。由于 $20 > 10$，搜索继续。这是第一次比较。\n3.  将搜索键 $k=20$ 与节点的第二个键 $20$ 进行比较。由于 $20 = 20$，找到了该键。这是第二次比较。\n在根节点中定位键 $k=20$ 的总比较次数为 $2$。\n\n**阶段 2：执行删除操作。**\n键 $k=20$ 位于一个内部节点（根节点）中。题目指定了一个特定的删除过程：“如果 $x$ 位于内部节点，且其相邻的子节点键数均少于 $t$，则执行与分隔键的合并操作，并对合并后的子节点递归执行删除。”\n\n1.  键 $k=20$ 作为根节点的子节点 1 和子节点 2 之间的分隔键。\n2.  子节点 1 包含键 $[12, 15]$，因此它有 $2$ 个键。\n3.  子节点 2 包含键 $[22, 25]$，因此它有 $2$ 个键。\n4.  最小度为 $t=3$。条件“至少 $t$ 个键”意味着拥有 $3$ 个或更多键。\n5.  子节点 1 有 $2$ 个键，少于 $3$ 个。子节点 2 也有 $2$ 个键，同样少于 $3$ 个。\n6.  条件“相邻的子节点键数均少于 $t$”被满足。因此，执行合并操作。\n7.  子节点 1、分隔键 $k=20$ 以及子节点 2 被合并成一个新的节点。这个新节点的内容是子节点 1 的键、键 $20$ 以及子节点 2 的键，结果为有序列表 $[12, 15, 20, 22, 25]$。\n8.  题目规定，此合并操作不产生任何键比较。\n9.  合并后，删除算法递归地从这个新形成的节点中删除 $k=20$。\n\n**阶段 3：递归删除步骤。**\n现在的任务是从包含 $[12, 15, 20, 22, 25]$ 的节点中删除键 $k=20$。该节点是一个叶节点。从叶节点删除涉及搜索键然后移除它。\n\n1.  使用线性扫描在节点 $[12, 15, 20, 22, 25]$ 中查找 $k=20$。\n2.  将 $k=20$ 与 $12$ 比较。$20 > 12$。这是一次比较。\n3.  将 $k=20$ 与 $15$ 比较。$20 > 15$。这是第二次比较。\n4.  将 $k=20$ 与 $20$ 比较。$20 = 20$。找到该键。这是第三次比较。\n此递归步骤中的总比较次数为 $3$。\n\nB 树删除的总键比较次数 $C_{B}$ 是初始搜索和递归删除步骤中比较次数的总和。\n$C_{B} = 2 + 3 = 5$。\n\n接下来，我们分析从红黑树（树 B）中删除的操作来确定 $C_{R}$。\n\n红黑树的删除过程也受题目中列出的特定规则的约束。\n\n**阶段 1：在红黑树中搜索键。**\n搜索 $k=20$ 使用“对键进行普通二叉搜索”。\n\n1.  搜索从树 B 的根节点开始，该节点包含键 $20$。\n2.  将搜索键 $k=20$ 与根节点的键 $20$ 进行比较。它们相等。在第一次比较时就找到了该节点。\n定位该键的总比较次数为 $1$。\n\n**阶段 2：执行删除操作。**\n包含 $k=20$ 的节点是根节点，并且有两个子节点（键分别为 $10$ 和 $30$ 的节点）。\n\n1.  规则是用其中序后继的键替换该节点中的键，然后删除后继的原始节点。\n2.  题目规定，中序后继是“通过仅使用指针检查（无键比较）下降到其右子树的最左侧节点来找到的”。因此，找到后继（即键为 $22$ 的节点）花费 $0$ 次比较。\n3.  键 $20$ 被 $22$ 替换。问题现在简化为删除后继的原始节点。\n4.  键 $22$ 的原始节点是一个叶节点（它没有子节点）。删除一个已经定位的节点不会产生额外的键搜索比较。\n5.  任何后续的红黑树修复操作（旋转和重新着色）也被指定为不产生任何键比较。\n\n红黑树删除的总键比较次数 $C_{R}$ 完全来自初始的键搜索。\n$C_{R} = 1$。\n\n最后，我们计算所需的差值 $\\Delta$。\n$\\Delta = C_{B} - C_{R}$\n$\\Delta = 5 - 1 = 4$。\n键比较次数的差值为 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3211517"}, {"introduction": "最后，我们将知识应用于一个更具挑战性的设计与实现任务。这个练习要求你为一个 B 树设计并实现一种“批量删除”功能，即一次性从同一个叶节点中删除多个密钥。这里的核心挑战在于优化再平衡过程：当节点因批量删除而严重“欠载”时，如何智能地组合使用从兄弟节点“借用”（旋转）和“合并”两种策略，以最小化代价高昂的合并操作。这不仅是对 B 树删除和合并机制的综合运用，更是对算法设计中权衡与优化思想的深度实践。[@problem_id:3211492]", "problem": "您必须设计并实现一个完整的程序，该程序模拟一个支持“批量删除”操作的 $B$ 树。在批量删除操作中，一次性从同一个叶节点中删除 $k$ 个键，然后优化后续的合并与再平衡过程。请使用以下关于 $B$ 树的基础知识，并基于这些原则推导您的算法，而不是使用简化的公式。\n\n基础知识与不变量：\n- 一个最小度为 $t$ 的 $B$ 树将排序后的键存储在节点中，每个非根节点包含 $t-1$ 到 $2t-1$ 个键，每个内部节点包含 $t$ 到 $2t$ 个子节点。如果根节点是内部节点，它可以包含 $1$ 到 $2t-1$ 个键；如果根节点是叶节点，它可以包含 $1$ 到 $2t-1$ 个键，或者在树没有键时为空。\n- 所有叶节点都位于相同的深度。位于两个相邻父节点键之间的子节点的子树中的所有键，必须严格地处于由这两个父节点键定义的相应区间内。\n- 当一个节点将要超过 $2t-1$ 个键时，插入操作会触发分裂，将中位数键向上移动。从叶节点删除键可能会在节点键数少于 $t-1$ 时造成下溢，这需要尽可能通过父节点分隔符从兄弟节点进行旋转（借用），或者在借用无法弥补不足时，通过父节点分隔符与兄弟节点进行合并。合并可能会将不足向上传播到父节点，从而重复该过程。\n\n任务：\n- 实现一个最小度为 $t$ 的 $B$ 树，支持插入整数键，并支持一个批量删除操作，该操作限制为从同一个叶节点中删除 $k$ 个键。您必须实现一个优化的批量再平衡策略：从叶节点移除 $k$ 个键后，在进行合并之前，尽可能地从兄弟节点进行多次旋转（借用），并根据兄弟节点的剩余容量选择旋转次数，以最小化合并次数。如果旋转无法弥补不足，则与一个相邻的兄弟节点执行一次合并，然后递归地修复任何向上传播的不足。对于旋转，应用标准的 $B$ 树旋转语义：从左兄弟节点借用时，用左兄弟节点的最大键替换父节点分隔符，并将父节点分隔符下移到下溢节点中；从右兄弟节点借用时，用右兄弟节点的最小键替换父节点分隔符，并将父节点分隔符下移到下溢节点中。对于合并，将父节点分隔符下移到两个被合并的节点之间，并连接它们的键（如果是内部节点，则还连接子节点）。\n- 您的程序还必须验证，在批量删除和再平衡之后，$B$ 树的不变量仍然成立：每个节点的键数在界限内，键是排序的，内部节点的子节点数比键数多一，所有叶节点具有相同的深度，并且键的范围得到遵守。\n\n测试套件的接口设计：\n- 程序必须通过插入给定的整数序列来构建初始的 $B$ 树，然后在包含指定枢轴键的叶节点上执行批量删除。对于批量删除，删除该叶节点中当前最小的 $k$ 个键。可以设置一个布尔标志，请求在批量删除之前，将目标叶节点的两个直接兄弟节点都预先削减到最小键数 $t-1$，以测试侧重于合并的行为。\n- 对于每个测试用例，您的程序必须以下列列表形式报告结果：执行的总合并次数（一个整数），执行的总旋转次数（一个整数），$B$ 树的最终高度（一个整数，其中只有一个叶节点的树高度为 $1$），以及一个布尔值，指示所有操作后 $B$ 树的不变量是否成立。\n\n测试套件：\n- 用例 1：$t=3$，插入从 $1$ 到 $30$ 的整数，枢轴键为 $11$，从该叶节点删除 $k=3$ 个键，禁用预先削减。\n- 用例 2：$t=3$，插入从 $1$ 到 $30$ 的整数，枢轴键为 $11$，从该叶节点删除 $k=4$ 个键，禁用预先削减。\n- 用例 3：$t=3$，插入从 $1$ 到 $30$ 的整数，枢轴键为 $11$，从该叶节点删除 $k=4$ 个键，启用预先削减（在批量删除前，将目标叶节点的两个兄弟节点都削减到 $t-1$ 个键）。\n- 用例 4：$t=2$，插入从 $1$ 到 $10$ 的整数，枢轴键为 $6$，从该叶节点删除 $k=3$ 个键，启用预先削减。\n\n要求的输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且本身必须是按 $[$合并次数, 旋转次数, 高度, 是否有效$]$ 顺序排列的列表。例如：$[[m_1,r_1,h_1,v_1],[m_2,r_2,h_2,v_2],\\dots]$。", "solution": "设计必须从最小度为 $t$ 的 $B$ 树的核心不变量开始。每个非根节点必须包含至少 $t-1$ 个键和至多 $2t-1$ 个键，而内部节点必须比键多一个子节点。除非树为空，否则根节点必须至少有 $1$ 个键。所有叶节点都在同一深度，每个子节点的键区间由父节点的分隔符决定。任何删除算法都必须在节点发生下溢时恢复这些界限。\n\n当一次从单个叶节点删除 $k$ 个键时，第一步是从该叶节点中移除这 $k$ 个键。假设该叶节点最初有 $m$ 个键。删除后，它有 $m-k$ 个键。如果 $m-k \\ge t-1$（并且该叶节点不是根节点），则没有发生下溢，操作完成。否则，存在一个大小为 $d = (t-1) - (m-k) > 0$ 的不足，必须通过父节点旋转从兄弟节点借用，或者与一个兄弟节点合并并向上递归修复来纠正。\n\n批量删除后的再平衡优化依赖于在一次局部计算中分析兄弟节点的剩余容量，而不是执行 $k$ 次独立的删除操作。如果叶节点在其父节点中的索引是 $i$，定义左兄弟节点为 $L$（如果 $i>0$），右兄弟节点为 $R$（如果 $i  \\text{parent.degree}-1$）。对于一个有 $\\ell_S$ 个键的兄弟节点 $S$，其超出最小键数的剩余量为 $\\max(0, \\ell_S-(t-1))$。可用于借用的总剩余量是左、右兄弟节点剩余量之和。每次借用操作对应一次标准的 $B$ 树旋转：\n\n- 从左兄弟节点借用时，使用父节点键 $K_p = \\text{parent.keys}[i-1]$：将 $K_p$ 下移到下溢节点中，并用左兄弟节点的最大键替换父节点中的 $K_p$；在内部节点的情况下，还要将左兄弟节点的最右侧子节点指针转移，成为下溢节点新的最左侧子节点。\n- 从右兄弟节点借用时，使用父节点键 $K_p = \\text{parent.keys}[i]$：将 $K_p$ 下移到下溢节点中，并用右兄弟节点的最小键替换父节点中的 $K_p$；在内部节点的情况下，还要将右兄弟节点的最左侧子节点指针转移，成为下溢节点新的最右侧子节点。\n\n如果可用剩余量之和大于或等于不足量 $d$，那么一个消耗所需键数的多重旋转序列可以将叶节点恢复到最小键数而无需任何合并。为了满足 $d$，应贪婪地先从左兄弟节点借用（最多借用其剩余量），然后从右兄弟节点借用，因为旋转的代价严格低于合并：一次旋转是局部的常数时间操作 $O(1)$，而一次合并会减少父节点的子节点数量，并可能导致父节点下溢，这必须沿树向上递归修复。\n\n如果总剩余量不足以满足 $d$，则与一个相邻的兄弟节点执行一次合并。选择存在的一侧进行合并；单次合并能够以最小的结构变化，为下溢节点增加最大数量的键。合并操作包括将适当的父节点分隔符键下移到两个节点之间，并连接它们的键（如果是内部节点，则还连接子节点），然后从父节点中移除该分隔符和多余的子节点。合并后，父节点失去一个键和一个子节点；如果此时父节点发生下溢（键数少于 $t-1$ 个，或者如果它是内部根节点，键数少于 $1$ 个），我们必须在父节点层级递归地应用相同的借用或合并逻辑。这可能级联至根节点。如果根节点变为空且只有一个子节点，则将根节点收缩为其子节点，使树的高度减 $1$。\n\n正确性源于在每一步都维护 $B$ 树的不变量。旋转保持了节点内部的有序性和全局的键区间属性，因为父节点分隔符维持其作用，并且借用的键通过父节点的移动方式与标准 $B$ 树删除完全相同。合并保持了区间属性，因为下移的父节点分隔符将两个相邻子节点的键序列连接起来。向上递归确保了任何父节点的下溢都以符合 $B$ 树规则的方式得到修复。由于所有操作都沿着一条从根到叶的路径发生，并可能向上级联，一次批量删除的时间复杂度为 $O(h + r + m)$，其中 $h$ 是树的高度，$r$ 是旋转次数，$m$ 是合并次数；通过优化，在兄弟节点剩余容量的约束下，合并次数被最小化，而旋转次数受限于可用的剩余量。从结构上看，在单个节点上，每次旋转是 $O(1)$，每次合并也是 $O(1)$，使得在典型的平衡场景中，总工作量为 $O(h)$。\n\n对于测试套件，程序通过插入整数构建 $B$ 树，定位包含指定枢轴键的叶节点，并删除该叶节点内的 $k$ 个最小键。一个可选标志可以在批量删除前将目标叶节点的两个直接兄弟节点都削减到恰好 $t-1$ 个键，以确保无法进行借用而必须进行合并，从而重点测试向上传播逻辑。在每个用例之后，程序输出合并次数、旋转次数、最终高度（根节点层计为高度 $1$），以及一个表示有效性的布尔值。最终输出按要求将四个用例的结果汇总到单行列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BTreeNode:\n    def __init__(self, t, leaf=False):\n        self.t = t\n        self.keys = []\n        self.children = []\n        self.leaf = leaf\n\n    def __repr__(self):\n        return f\"Node(keys={self.keys}, leaf={self.leaf})\"\n\n\nclass BTree:\n    def __init__(self, t):\n        self.t = t\n        self.root = BTreeNode(t, leaf=True)\n        self.rotations = 0\n        self.merges = 0\n\n    # Standard B-tree insertion (CLRS style)\n    def insert(self, k):\n        root = self.root\n        if len(root.keys) == 2*self.t - 1:\n            s = BTreeNode(self.t, leaf=False)\n            s.children.append(root)\n            self._split_child(s, 0)\n            self.root = s\n            self._insert_nonfull(s, k)\n        else:\n            self._insert_nonfull(root, k)\n\n    def _insert_nonfull(self, x, k):\n        i = len(x.keys) - 1\n        if x.leaf:\n            # insert in sorted order\n            x.keys.append(k)\n            i = len(x.keys) - 2\n            while i >= 0 and x.keys[i] > k:\n                x.keys[i+1] = x.keys[i]\n                i -= 1\n            x.keys[i+1] = k\n        else:\n            while i >= 0 and k  x.keys[i]:\n                i -= 1\n            i += 1\n            if len(x.children[i].keys) == 2*self.t - 1:\n                self._split_child(x, i)\n                if k > x.keys[i]:\n                    i += 1\n            self._insert_nonfull(x.children[i], k)\n\n    def _split_child(self, x, i):\n        t = self.t\n        y = x.children[i]\n        z = BTreeNode(t, leaf=y.leaf)\n        # median key at index t-1\n        median = y.keys[t-1]\n        # distribute keys\n        z.keys = y.keys[t:]\n        y.keys = y.keys[:t-1]\n        if not y.leaf:\n            z.children = y.children[t:]\n            y.children = y.children[:t]\n        x.children.insert(i+1, z)\n        x.keys.insert(i, median)\n\n    # Search returns node containing key or leaf where it would be inserted\n    def search(self, k):\n        return self._search_node(self.root, k)\n\n    def _search_node(self, x, k):\n        i = 0\n        while i  len(x.keys) and k > x.keys[i]:\n            i += 1\n        if i  len(x.keys) and k == x.keys[i]:\n            return x, i\n        if x.leaf:\n            return x, None\n        else:\n            return self._search_node(x.children[i], k)\n\n    # Find parent of a given node and child's index\n    def find_parent(self, current, target):\n        if current.leaf:\n            return None, None\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            if not child.leaf:\n                p, idx = self.find_parent(child, target)\n                if p is not None:\n                    return p, idx\n            else:\n                # continue\n                pass\n        # Try descending anyway based on key ranges to find parent in deeper subtrees\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            p, idx = self.find_parent(child, target)\n            if p is not None:\n                return p, idx\n        return None, None\n\n    # Helpers for rotations\n    def rotate_from_left(self, parent, idx):\n        # Borrow from left sibling into child at idx\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # Move parent separator down into node, replace parent separator with left's max key\n        # Also move child pointer for internal nodes\n        if node.leaf:\n            # insert parent key at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # replace parent key with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        else:\n            # node gains parent.sep at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # node must take left's last child to the front\n            child_to_move = left.children.pop()\n            node.children.insert(0, child_to_move)\n            # parent sep replaced with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        self.rotations += 1\n\n    def rotate_from_right(self, parent, idx):\n        right = parent.children[idx+1]\n        node = parent.children[idx]\n        if node.leaf:\n            # append parent key\n            node.keys.append(parent.keys[idx])\n            # replace parent key with right's first key\n            parent.keys[idx] = right.keys.pop(0)\n        else:\n            node.keys.append(parent.keys[idx])\n            child_to_move = right.children.pop(0)\n            node.children.append(child_to_move)\n            parent.keys[idx] = right.keys.pop(0)\n        self.rotations += 1\n\n    # Merge helpers\n    def merge_with_left(self, parent, idx):\n        # Merge child at idx with left sibling at idx-1\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # move parent separator down\n        left.keys.append(parent.keys[idx-1])\n        # concatenate node\n        left.keys.extend(node.keys)\n        if not left.leaf:\n            left.children.extend(node.children)\n        # remove from parent\n        parent.keys.pop(idx-1)\n        parent.children.pop(idx)\n        self.merges += 1\n        return left  # merged node reference\n\n    def merge_with_right(self, parent, idx):\n        node = parent.children[idx]\n        right = parent.children[idx+1]\n        # move parent separator down\n        node.keys.append(parent.keys[idx])\n        node.keys.extend(right.keys)\n        if not node.leaf:\n            node.children.extend(right.children)\n        parent.keys.pop(idx)\n        parent.children.pop(idx+1)\n        self.merges += 1\n        return node\n\n    # Fix underflow after deletions\n    def fix_underflow(self, node):\n        # If node is root, handle special cases\n        while True:\n            if node is self.root:\n                # If root is internal and empty with one child, collapse\n                if not node.leaf and len(node.keys) == 0 and len(node.children) == 1:\n                    self.root = node.children[0]\n                # Leaf root may be empty if tree emptied; nothing else to do\n                return\n            parent, idx = self.find_parent(self.root, node)\n            if parent is None:\n                # Should not happen\n                return\n            min_keys = (self.t - 1)\n            if len(node.keys) >= min_keys:\n                return\n            deficiency = min_keys - len(node.keys)\n            # calculate available surplus from siblings\n            # Try left\n            if idx - 1 >= 0:\n                left = parent.children[idx-1]\n                avail_left = len(left.keys) - (self.t - 1)\n            else:\n                left = None\n                avail_left = 0\n            # Try right\n            if idx + 1  len(parent.children):\n                right = parent.children[idx+1]\n                avail_right = len(right.keys) - (self.t - 1)\n            else:\n                right = None\n                avail_right = 0\n            # Borrow as much as possible\n            borrow_left = min(deficiency, max(0, avail_left))\n            for _ in range(borrow_left):\n                self.rotate_from_left(parent, idx)\n                deficiency -= 1\n                if deficiency == 0:\n                    break\n            if deficiency > 0:\n                borrow_right = min(deficiency, max(0, avail_right))\n                for _ in range(borrow_right):\n                    self.rotate_from_right(parent, idx)\n                    deficiency -= 1\n                    if deficiency == 0:\n                        break\n            # If still deficient, merge\n            if len(node.keys)  min_keys:\n                if left is not None:\n                    merged = self.merge_with_left(parent, idx)\n                    # After merge, set node to parent to check if parent underflows\n                    node = parent\n                    continue\n                elif right is not None:\n                    merged = self.merge_with_right(parent, idx)\n                    node = parent\n                    continue\n                else:\n                    # No siblings? Should not happen in B-tree except at root\n                    node = parent\n                    continue\n            else:\n                return\n\n    # Batch delete k smallest keys from leaf containing pivot key\n    def batch_delete_from_leaf_by_pivot(self, pivot_key, k, pre_reduce_siblings_to_min=False):\n        # Find leaf containing pivot key\n        node, idx = self.search(pivot_key)\n        # Ensure node is the leaf containing the key\n        # If the found node is internal (unlikely since search returns leaf when not found),\n        # traverse to leaf containing pivot_key\n        if not node.leaf:\n            # descend to the child where pivot would be\n            x = node\n            i = 0\n            while i  len(x.keys) and pivot_key > x.keys[i]:\n                i += 1\n            node = x.children[i]\n            while not node.leaf:\n                i = 0\n                while i  len(node.keys) and pivot_key > node.keys[i]:\n                    i += 1\n                node = node.children[i]\n        # Optionally pre-reduce siblings to minimum keys\n        if pre_reduce_siblings_to_min:\n            parent, child_idx = self.find_parent(self.root, node)\n            if parent is not None:\n                # Reduce left sibling\n                if child_idx - 1 >= 0:\n                    left = parent.children[child_idx-1]\n                    # delete from left to reach t-1 keys\n                    excess = len(left.keys) - (self.t - 1)\n                    if excess > 0:\n                        # delete excess smallest keys in left\n                        to_delete = left.keys[:excess]\n                        for key in to_delete:\n                            # Remove key from left\n                            left.keys.remove(key)\n                        # Fix underflow if created (shouldn't create underflow by removing surplus)\n                        # But if we removed too many due to earlier structure, still fix\n                        self.fix_underflow(left)\n                # Reduce right sibling\n                if child_idx + 1  len(parent.children):\n                    right = parent.children[child_idx+1]\n                    excess = len(right.keys) - (self.t - 1)\n                    if excess > 0:\n                        to_delete = right.keys[:excess]\n                        for key in to_delete:\n                            right.keys.remove(key)\n                        self.fix_underflow(right)\n        # Now delete k smallest keys in the target leaf\n        to_remove = node.keys[:min(k, len(node.keys))]\n        for key in to_remove:\n            # Remove key\n            node.keys.remove(key)\n        # Fix potential underflow\n        self.fix_underflow(node)\n\n    # Validation of B-tree invariants\n    def validate(self):\n        if self.root is None:\n            return True\n        # Check leaf depths\n        leaf_depths = []\n\n        def dfs(node, depth):\n            # keys sorted\n            if any(node.keys[i] >= node.keys[i+1] for i in range(len(node.keys)-1)):\n                return False\n            # bounds\n            if node is self.root:\n                # root can be leaf or internal\n                if node.leaf:\n                    # allow empty root leaf or between 1 and 2t-1 keys\n                    if len(node.keys) > 2*self.t - 1:\n                        return False\n                else:\n                    if len(node.keys)  1 or len(node.keys) > 2*self.t - 1:\n                        return False\n            else:\n                if len(node.keys)  self.t - 1 or len(node.keys) > 2*self.t - 1:\n                    return False\n            if not node.leaf:\n                if len(node.children) != len(node.keys) + 1:\n                    return False\n                for child in node.children:\n                    if child is None:\n                        return False\n            else:\n                leaf_depths.append(depth)\n            # recurse\n            if not node.leaf:\n                for child in node.children:\n                    if not dfs(child, depth+1):\n                        return False\n            return True\n\n        ok = dfs(self.root, 1)\n        if not ok:\n            return False\n        # All leaves same depth\n        if len(leaf_depths) == 0:\n            return True\n        return all(d == leaf_depths[0] for d in leaf_depths)\n\n    def height(self):\n        h = 0\n        node = self.root\n        while node is not None:\n            h += 1\n            if node.leaf:\n                break\n            node = node.children[0]\n        return h\n\n\ndef build_btree_with_range(t, start, end):\n    bt = BTree(t)\n    for k in range(start, end+1):\n        bt.insert(k)\n    return bt\n\n\ndef run_test_case(t, insert_range, pivot, k, pre_reduce=False):\n    bt = build_btree_with_range(t, insert_range[0], insert_range[1])\n    # perform batch deletion\n    bt.batch_delete_from_leaf_by_pivot(pivot, k, pre_reduce_siblings_to_min=pre_reduce)\n    # collect results\n    merges = bt.merges\n    rotations = bt.rotations\n    height = bt.height()\n    valid = bt.validate()\n    return [merges, rotations, height, valid]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: t=3, insert 1..30, pivot 11, k=3, no pre-reduction\n        (3, (1, 30), 11, 3, False),\n        # Case 2: t=3, insert 1..30, pivot 11, k=4, no pre-reduction\n        (3, (1, 30), 11, 4, False),\n        # Case 3: t=3, insert 1..30, pivot 11, k=4, pre-reduction enabled\n        (3, (1, 30), 11, 4, True),\n        # Case 4: t=2, insert 1..10, pivot 6, k=3, pre-reduction enabled\n        (2, (1, 10), 6, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        t, insert_range, pivot, k, pre_reduce = case\n        result = run_test_case(t, insert_range, pivot, k, pre_reduce)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3211492"}]}