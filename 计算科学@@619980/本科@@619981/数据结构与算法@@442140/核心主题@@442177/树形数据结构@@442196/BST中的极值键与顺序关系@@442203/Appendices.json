{"hands_on_practices": [{"introduction": "二叉搜索树（BST）最根本的特性是其有序性，这一点通过中序遍历可以清晰地体现出来，即遍历结果为一个严格递增的序列。本练习旨在挑战你运用这一核心特性来诊断树的结构问题。通过在一个“几乎”有效的二叉搜索树中识别出不符合预期的有序性中断点，你将能精确定位出被错误交换的两个键，同时还需要遵守严格的内存空间限制。这项练习将深化你对中序遍历及其与二叉搜索树结构完整性之间关系的理解。[@problem_id:3233436]", "problem": "给定一个二叉搜索树（BST）的形式化设定。二叉搜索树（BST）是一种有根二叉树，其中每个节点存储一个唯一的键 $k \\in \\mathbb{Z}$，使得对于任何带有键 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。对一个有效的二叉搜索树（BST）进行中序遍历，会以严格递增的顺序访问各个键。考虑一棵树，它是一个有效的二叉搜索树（BST），但其中恰好有两个节点的键被交换了。你的任务是在不修改树结构的情况下，仅使用 $O(h)$ 的额外空间（其中 $h$ 是树的高度）来定位这两个被交换的键。\n\n您可以假设以下基本依据和事实：\n- 二叉搜索树（BST）的顺序定义：对于每个键为 $k$ 的节点，其左子树中的键都小于 $k$，其右子树中的键都大于 $k$。\n- 对具有唯一键的有效二叉搜索树（BST）进行中序遍历，会产生一个严格递增的键序列。\n\n你的程序必须：\n- 使用标准的二叉搜索树（BST）插入规则，按指定顺序将给定的键插入一个初始为空的树中，从而构建一个二叉搜索树（BST）。\n- 交换两个指定节点（通过它们在任何交换前的原始键来识别）的键。\n- 使用至多 $O(h)$ 的额外空间，检测并返回这两个被交换的键，形式为一个包含两个按升序排列的整数的列表。\n- 对所有提供的测试用例重复此过程，并按指定的输出格式将所有结果打印在单行上。\n\n约束和要求：\n- 所有键都是唯一的整数。\n- 恰好有一对节点的键被交换。\n- 额外空间使用必须为 $O(h)$，其中 $h$ 是树的高度。对于 $n$ 个节点，通过使用大小为 $O(h)$ 的显式栈进行单次中序遍历，时间复杂度应为 $O(n)$。\n\n用于覆盖一般情况和边界情况的测试套件。每个测试用例由一个插入序列和一个要交换的键对指定：\n- 测试用例 1：插入序列 $[4,2,6,1,3,5,7]$，交换对 $(3,6)$。\n- 测试用例 2：插入序列 $[4,2,6,1,3,5,7]$，交换对 $(3,4)$。\n- 测试用例 3：插入序列 $[1,2,3,4,5,6]$，交换对 $(1,6)$。\n- 测试用例 4：插入序列 $[1,2]$，交换对 $(1,2)$。\n- 测试用例 5：插入序列 $[10,5,15,2,7,12,20,1,3,6,8,11,13,18,25]$，交换对 $(1,25)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,\\dots]$），其中每个 $result_i$ 本身是一个包含两个元素的列表 $[a,b]$，表示为测试用例 $i$ 检测到的按升序排列的被交换键。\n- 对于上述测试套件，你的程序必须以 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4],[a_5,b_5]]$ 的格式精确打印一行，不含空格。", "solution": "### 问题验证\n\n**步骤 1：提取已知信息**\n- 二叉搜索树（BST）是一种有根二叉树，每个节点都有一个唯一的键 $k \\in \\mathbb{Z}$。\n- 对于任何键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。\n- 对一个有效的二叉搜索树进行中序遍历会以严格递增的顺序访问键。\n- 输入是一棵有效的二叉搜索树，但其中恰好有两个节点的键被交换了。\n- 任务是定位这两个被交换的键。\n- 约束：解决方案必须仅使用 $O(h)$ 的额外空间，其中 $h$ 是树的高度，并且不得修改树的结构。对于有 $n$ 个节点的树，时间复杂度应为 $O(n)$。\n- 算法必须通过从给定的插入序列构建一个二叉搜索树，交换两个指定节点的键，然后检测被交换的键来进行。\n- 测试用例：\n    1. 插入序列：$[4,2,6,1,3,5,7]$，交换对：$(3,6)$\n    2. 插入序列：$[4,2,6,1,3,5,7]$，交换对：$(3,4)$\n    3. 插入序列：$[1,2,3,4,5,6]$，交换对：$(1,6)$\n    4. 插入序列：$[1,2]$，交换对：$(1,2)$\n    5. 插入序列：$[10,5,15,2,7,12,20,1,3,6,8,11,13,18,25]$，交换对：$(1,25)$\n- 输出必须是单行：`[[a_1,b_1],[a_2,b_2],...]`，不含空格。\n\n**步骤 2：使用提取的已知信息进行验证**\n根据验证标准对问题陈述进行评估。\n- **科学性**：该问题基于计算机科学的基本、明确定义的概念，特别是数据结构（二叉搜索树）和算法（遍历、复杂度分析）理论。所有定义和性质都是标准的。该问题在科学上和数学上是合理的。\n- **适定性**：该问题是适定的。给定一个恰好有两个键被交换的二叉搜索树，这个结构性缺陷会在中序遍历本应产生的有序序列中，制造出一个可预测且可识别的模式。这使得设计一个确定性算法来找到唯一的被交换键对成为可能。\n- **客观性**：该问题使用精确、形式化的语言陈述，没有歧义或主观性。\n- **完整性和一致性**：该问题提供了所有必要的信息：数据结构的定义、缺陷的性质、操作约束（$O(h)$ 空间，$O(n)$ 时间），以及一组清晰的用于验证的测试用例。这些约束是相互一致的，并且是此类问题的标准约束。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。这是计算机科学领域一个标准的、定义明确的算法挑战。将提供一个解决方案。\n\n### 基于原则的解决方案\n\n这个问题的解决关键在于二叉搜索树（BST）的一个基本性质：对一个有效的二叉搜索树进行中序遍历，会得到一个严格递增的键序列。设对一个有 $n$ 个节点的二叉搜索树进行中序遍历得到的键序列为 $S = (k_1, k_2, \\dots, k_n)$。对于一个有效的二叉搜索树，必须满足对于所有 $i \\in \\{1, 2, \\dots, n-1\\}$ 都有 $k_i  k_{i+1}$。\n\n当恰好有两个节点的键被交换时，这个严格递增的性质就会被破坏。我们的目标是在一次中序遍历中通过检测这些破坏点来识别参与交换的两个节点，同时遵守 $O(h)$ 的空间复杂度约束，其中 $h$ 是树的高度。\n\n使用一个显式的节点栈进行迭代中序遍历可以满足这个空间约束，因为栈的最大深度等于树的高度 $h$。在遍历过程中，我们可以将每个访问到的节点的键与前一个访问到的节点的键进行比较，以发现任何逆序对。\n\n设原始的、正确的、已排序的键序列为 $(x_1, x_2, \\dots, x_n)$。假设键 $x_i$ 和 $x_j$ 被交换，其中 $i  j$ 因而 $x_i  x_j$。产生的中序序列将会被打乱。我们分析两种不同情况下的破坏点位置。\n\n**情况 1：不相邻的键被交换。**\n原始序列是 $(\\dots, x_{i-1}, x_i, x_{i+1}, \\dots, x_{j-1}, x_j, x_{j+1}, \\dots)$。\n交换 $x_i$ 和 $x_j$ 后，序列变为 $(\\dots, x_{i-1}, x_j, x_{i+1}, \\dots, x_{j-1}, x_i, x_{j+1}, \\dots)$。\n我们来检查非单调性的点：\n1.  在原 $x_i$ 的位置，现在是 $x_j$。这对键是 $(x_j, x_{i+1})$。由于 $i+1 \\le j$，我们有 $x_{i+1} \\le x_j$。因为所有键都是唯一的，如果 $i+1  j$，那么 $x_{i+1}  x_j$。这就产生了第一个破坏点：$x_j > x_{i+1}$。第一个错位的元素是 $x_j$。\n2.  在原 $x_j$ 的位置，现在是 $x_i$。前面的键是 $x_{j-1}$。这对键是 $(x_{j-1}, x_i)$。由于 $i  j-1$，我们有 $x_i  x_{j-1}$。这就产生了第二个破坏点：$x_{j-1} > x_i$。第二个错位的元素是 $x_i$。\n\n在这种情况下，我们会在遍历的序列中找到两对相邻的键 $(k_p, k_{p+1})$，使得 $k_p > k_{p+1}$。第一对的第一个键 ($k_p$) 和第二对的第二个键 ($k_{p+1}$) 构成了被交换的键对。\n\n**情况 2：相邻的键被交换。**\n原始序列是 $(\\dots, x_{i-1}, x_i, x_{i+1}, x_{i+2}, \\dots)$，我们交换 $x_i$ 和 $x_{i+1}$。\n序列变为 $(\\dots, x_{i-1}, x_{i+1}, x_i, x_{i+2}, \\dots)$。\n这里只有一个非单调性的点：对 $(x_{i+1}, x_i)$，其中 $x_{i+1} > x_i$。在这种情况下，我们会找到恰好一对相邻的键 $(k_p, k_{p+1})$，使得 $k_p > k_{p+1}$。这两个键，$k_p$ 和 $k_{p+1}$，正是被交换的键。\n\n**算法策略**\n一个统一的算法可以处理这两种情况。我们执行一次迭代中序遍历，并跟踪前一个访问过的节点。我们维护三个指向节点的指针（或存储其键的变量）：`first`、`middle` 和 `last`。\n\n1.  将 `prev`（遍历中的前一个节点）、`first`、`middle`、`last` 初始化为 null 状态。\n2.  使用栈执行迭代中序遍历。对于每个访问的节点 `curr`：\n3.  如果 `prev` 不为 null 且 `prev.key > curr.key`，则发现一个破坏点。\n    a. 如果 `first` 为 null，这是遇到的第一个破坏点。我们记录 `first = prev` 和 `middle = curr`。`first` 持有错位对的第一个元素，`middle` 持有第二个元素（以防这是唯一的破坏点，如相邻交换的情况）。\n    b. 如果 `first` 不为 null，这是第二个破坏点。我们记录 `last = curr`。这个 `curr` 节点是非相邻情况下错位对的第二个元素。\n4.  更新 `prev = curr` 并继续遍历。\n5.  遍历完成后：\n    a. 如果 `last` 不为 null（即我们找到了两个破坏点），那么被交换的键是 `first.key` 和 `last.key`。\n    b. 如果 `last` 为 null（即我们只找到了一个破坏点），那么被交换的键是 `first.key` 和 `middle.key`。\n6.  最终结果是检测到的键对，按升序排序。\n\n该算法由于对树进行了一次完整的遍历，因此能在 $O(n)$ 时间内正确识别出被交换的键，并且需要 $O(h)$ 的辅助空间用于遍历栈，满足了所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a Binary Search Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef insert_node(root, key):\n    \"\"\"Inserts a key into the BST and returns the root.\"\"\"\n    if root is None:\n        return Node(key)\n    \n    current = root\n    while True:\n        if key  current.key:\n            if current.left is None:\n                current.left = Node(key)\n                return root\n            current = current.left\n        else: # key > current.key, as keys are distinct\n            if current.right is None:\n                current.right = Node(key)\n                return root\n            current = current.right\n\ndef find_node(root, key):\n    \"\"\"Finds and returns the node with the given key.\"\"\"\n    current = root\n    while current is not None:\n        if key == current.key:\n            return current\n        elif key  current.key:\n            current = current.left\n        else:\n            current = current.right\n    return None\n\ndef find_swapped_keys(root):\n    \"\"\"\n    Finds the two swapped keys in a BST using an iterative in-order traversal.\n    Space complexity: O(h), where h is the tree height.\n    Time complexity: O(n), where n is the number of nodes.\n    \"\"\"\n    stack = []\n    current = root\n    \n    prev_node = None\n    first_violator = None\n    middle_violator = None\n    last_violator = None\n\n    while current is not None or stack:\n        while current is not None:\n            stack.append(current)\n            current = current.left\n            \n        current = stack.pop()\n        \n        # In-order processing logic\n        if prev_node is not None and prev_node.key > current.key:\n            # A violation is found\n            if first_violator is None:\n                # First violation\n                first_violator = prev_node\n                middle_violator = current\n            else:\n                # Second violation\n                last_violator = current\n\n        prev_node = current\n        current = current.right\n\n    if last_violator:\n        # Non-adjacent swap\n        key1 = first_violator.key\n        key2 = last_violator.key\n    else:\n        # Adjacent swap\n        key1 = first_violator.key\n        key2 = middle_violator.key\n        \n    return sorted([key1, key2])\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {'insert': [4, 2, 6, 1, 3, 5, 7], 'swap': (3, 6)},\n        {'insert': [4, 2, 6, 1, 3, 5, 7], 'swap': (3, 4)},\n        {'insert': [1, 2, 3, 4, 5, 6], 'swap': (1, 6)},\n        {'insert': [1, 2], 'swap': (1, 2)},\n        {'insert': [10, 5, 15, 2, 7, 12, 20, 1, 3, 6, 8, 11, 13, 18, 25], 'swap': (1, 25)},\n    ]\n\n    results_str = []\n    for case in test_cases:\n        # 1. Construct the BST\n        root = None\n        for key in case['insert']:\n            root = insert_node(root, key)\n            \n        # 2. Find and swap the specified nodes' keys\n        key_to_swap1, key_to_swap2 = case['swap']\n        node1 = find_node(root, key_to_swap1)\n        node2 = find_node(root, key_to_swap2)\n        if node1 and node2:\n            node1.key, node2.key = node2.key, node1.key\n\n        # 3. Detect the swapped keys\n        swapped_pair = find_swapped_keys(root)\n        \n        # 4. Format the result string\n        results_str.append(f\"[{swapped_pair[0]},{swapped_pair[1]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3233436"}, {"introduction": "虽然标准的二叉搜索树能高效地查找单个特定的键，但如果我们想查询一个键的范围，又该如何呢？下一个练习将向你介绍一种名为“数据结构增强”的强大技术。通过在每个节点上存储少量额外信息——在本例中是其子树中的最小键——我们就能设计出能够“剪枝”掉树中整个区域的算法，从而实现高效的范围查询。这项练习将指导你实现并利用这种增强技术，以远超简单线性扫描的效率，在给定的闭区间 $[L, R]$ 中找到最小的键。[@problem_id:3233410]", "problem": "您需要设计并实现一个算法，该算法通过增强二叉搜索树（BST）来回答以下形式的查询：给定一个闭区间 $[L,R]$，返回树中位于该区间的最小键值；如果区间内不包含任何存储的键值，则返回 $-1$。您的设计和实现必须基于二叉搜索树（BST）的基本性质从第一性原理出发进行论证，并且在高度平衡的树上必须达到 $O(\\log n)$ 的时间复杂度，其中 $n$ 是存储的键值数量。\n\n请从以下基本原则开始：\n- 对于全序键值的二叉搜索树（BST）满足：对于任意键值为 $k$ 的节点，其左子树中的所有键值都严格小于 $k$，其右子树中的所有键值都严格大于 $k$。\n- 高度平衡的BST的高度为 $h=O(\\log n)$，这意味着任何单条从根到叶的路径长度为 $O(\\log n)$。\n- 增强数据结构是指在每个节点上存储额外的字段，这些字段是该节点子树的函数，其计算和维护过程不会违反BST的排序不变性。\n\n您的任务：\n1. 为每个节点增加一个字段，用于存储其子树（包括节点自身）中的最小键值。一旦其子节点已知，该字段必须能根据其子节点和节点自身的键值在 $O(1)$ 时间内计算得出。\n2. 仅使用BST的排序属性和上述增强字段，设计一个 $O(h)$ 算法（其中 $h$ 为树的高度），用于查找给定区间 $[L,R]$ 内的最小键值；如果区间内没有键值，则返回 $-1$。在高度为 $h=O(\\log n)$ 的高度平衡BST上，该算法可达到目标时间复杂度 $O(\\log n)$。\n3. 您的算法不能在最坏情况下扫描所有键值或执行 $O(n)$ 的遍历；它必须依赖于访问 $O(h)$ 个节点，并利用增强字段在 $O(1)$ 时间内处理整个子树。\n\n操作约束：\n- 所有键值都是唯一的整数。\n- 区间是闭合且包含端点的。如果 $LR$，则视为空区间并返回 $-1$。\n- 如果没有键值位于 $[L,R]$ 内，返回 $-1$。\n- 不涉及物理单位。\n\n实现要求：\n- 通过从已排序的数组构建（例如，通过递归选择中位数）为测试用例构建高度平衡的BST，确保高度 $h=O(\\log n)$。\n- 实现一个函数，给定 $L$ 和 $R$，使用增强字段在 $O(h)$ 时间内返回 $[L,R]$ 中的最小键值。\n\n测试套件：\n对于此任务，请根据指定的键值集合构建BST，并回答所列的查询。每个测试用例都是独立的；您可以为每个用例重新构建BST。预期的最终答案必须是整数。请使用以下测试用例：\n- 用例 1：键值 $[1,3,4,6,7,8,10,13,14]$，查询 $L=5$，$R=13$。\n- 用例 2：键值 $[1,3,4,6,7,8,10,13,14]$，查询 $L=15$，$R=20$。\n- 用例 3：键值 $[1,3,4,6,7,8,10,13,14]$，查询 $L=7$，$R=7$。\n- 用例 4：键值 $[1,3,4,6,7,8,10,13,14]$，查询 $L=0$，$R=2$。\n- 用例 5：键值 $[1,3,4,6,7,8,10,13,14]$，查询 $L=-5$，$R=100$。\n- 用例 6：键值 $[1,3,4,6,7,8,10,13,14]$，查询 $L=9$，$R=5$。\n- 用例 7：键值 $[42]$，查询 $L=10$，$R=100$。\n- 用例 8：键值 $[42]$，查询 $L=43$，$R=50$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含上述用例的结果，格式为用方括号括起来的逗号分隔列表，例如 $[a_1,a_2,\\dots,a_8]$，其中每个 $a_i$ 是按顺序排列的第 $i$ 个用例的整数答案。不应打印任何额外文本。", "solution": "该问题要求设计并实现一个算法，在一个增强的二叉搜索树（BST）中查找闭区间 $[L, R]$ 内的最小键值。该算法必须达到 $O(h)$ 的时间复杂度，其中 $h$ 是树的高度，对于具有 $n$ 个节点的高度平衡BST，这对应于 $O(\\log n)$ 的复杂度。\n\n我们首先阐述基本原则。\n\n二叉搜索树（BST）是一种基于节点的二叉树数据结构，对于任意键值为 $k$ 的节点 $x$，它具有以下性质：\n1.  $x$ 的左子树中的所有键值都严格小于 $k$。\n2.  $x$ 的右子树中的所有键值都严格大于 $k$。\n3.  左子树和右子树也都是二叉搜索树。\n\n对于此问题，我们对BST进行增强。增强操作涉及向每个节点添加额外信息，以高效地支持新的查询。在任何树的修改过程中，必须保持增强数据的完整性，并且其值必须能从节点的本地信息及其子节点的增强信息中计算得出。\n\n**1. 节点增强**\n\n按照规定，我们为BST中的每个节点 $x$ 增加一个额外的字段，我们将其表示为 $x.min\\_key$。该字段存储在以 $x$ 为根的整个子树中（包括 $x$ 自身）找到的最小键值。\n\n$x.min\\_key$ 的值可以根据节点自身的键值及其子节点的增强字段计算得出。设 $x.key$ 为节点 $x$ 的键值，其左右子节点分别为 $x.left$ 和 $x.right$。根据BST的性质，$x$ 右子树中的任何键值都大于 $x.key$，$x$ 左子树中的任何键值都小于 $x.key$。因此，以 $x$ 为根的子树中的最小键值要么是 $x.key$ 本身（如果 $x$ 没有左子节点），要么是左子树中的某个键值。根据定义，左子树中的最小键值存储在 $x.left.min\\_key$ 中。\n\n因此，$x.min\\_key$ 的值由以下递推关系给出：\n$$\nx.min\\_key =\n\\begin{cases}\nx.left.min\\_key  \\text{if } x.left \\text{ is not null} \\\\\nx.key  \\text{if } x.left \\text{ is null}\n\\end{cases}\n$$\n此计算仅需引用左子节点的增强字段，每个节点耗时 $O(1)$。在构建树时，这些值可以通过后序遍历的方式高效计算（即，在子节点的值计算完毕之后）。对于要求从排序数组进行递归构建的情况，此计算在递归回溯时自然发生。\n\n**2. 算法设计**\n\n我们现在设计一个算法 `FindMinInRange(node, L, R)`，用于查找 `node` 子树中落在区间 $[L, R]$ 内的最小键值。如果不存在这样的键值，算法将返回一个特殊值 $\\infty$。主函数将处理初始调用并将 $\\infty$ 转换为所需的输出 $-1$。\n\n该算法利用了基本的BST排序性质和 `min_key` 增强字段来有效地裁剪搜索空间。为查找最小值，搜索会优先探索具有较小键值的部分：首先是左子树，然后是当前节点，最后是右子树。\n\n递归算法如下：\n\n`FindMinInRange(node, L, R)`:\n\n1.  **基本情况**：如果 `node` 为空，则子树为空，不包含任何键值。返回 $\\infty$。\n\n2.  **使用增强字段进行剪枝**：我们首先检查是否可以丢弃整个子树。子树中的最小键值是 `node.min_key`。如果这个最小值大于区间的上界 `R`，那么整个子树中不可能有键值在 $[L, R]$ 内。\n    如果 $R  \\text{node.min\\_key}$，则返回 $\\infty$。\n\n3.  **使用BST性质进行剪枝**：如果当前节点的键值 `node.key` 小于区间的下界 `L`，那么根据BST的性质，`node.key` 及其左子树中的所有键值都在区间 $[L, R]$ 之外。唯一的解可能存在于右子树中。\n    如果 $\\text{node.key}  L$，则返回 `FindMinInRange(node.right, L, R)`。\n\n4.  **递归搜索**：如果算法执行到这一步，我们知道 $\\text{node.key} \\ge L$ 且 $\\text{node.min\\_key} \\le R$。这意味着子树中可能存在一个有效的键值。因为我们正在寻找最小值，所以必须按键值递增的顺序进行搜索。\n    a. **搜索左子树**：最小的潜在候选键值位于左子树中。我们递归地搜索它：\n       `result_left = FindMinInRange(node.left, L, R)`\n       如果此搜索找到了一个有效的键值（即 $\\text{result\\_left} \\neq \\infty$），则可以保证该键值小于 `node.key` 以及右子树中的任何键值。因此，它是 `node` 整个子树中有效的最小键值。我们可以立即返回它。\n       如果 $\\text{result\\_left} \\neq \\infty$，则返回 `result_left`。\n\n    b. **检查当前节点**：如果左子树的搜索没有结果，下一个最小的候选键值是当前节点的键值 `node.key`。我们已经确定 `node.key >= L`。现在我们检查它是否也满足上界。\n       如果 $\\text{node.key} \\le R$，那么 `node.key` 就是最小的有效键值（因为左子树中没有）。返回 `node.key`。\n\n    c. **搜索右子树**：如果左子树搜索无果，并且当前节点的键值不在区间内（即 $\\text{node.key} > R$），唯一剩下的可能性就在右子树中。\n       返回 `FindMinInRange(node.right, L, R)`。\n\n**3. 复杂度分析**\n\n在递归的每个节点上，算法执行常数次比较，并可能进行一到两次递归调用。然而，对控制流的分析表明，访问的节点总数与树的高度 $h$ 成正比。该逻辑确保在探索一个分支（例如左子树）后，算法要么终止，要么沿着单条路径继续。例如，如果在左子树中找到解，函数会立即返回，而不会探索当前节点或右子树。这种结构限制了遍历。在最坏情况下，搜索路径类似于从根到叶的一条路径。因此，时间复杂度为 $O(h)$。对于高度平衡的BST，其高度 $h = O(\\log n)$，因此复杂度为 $O(\\log n)$，满足问题要求。\n\n当 $L  R$ 时定义了一个空区间，这是一个特殊情况。这在主包装函数中发起递归搜索之前通过一次检查来处理，在 $O(1)$ 时间内返回 $-1$。", "answer": "```python\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the augmented Binary Search Tree.\n    Each node stores its key, left and right children, and the minimum key\n    in the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        # Augmentation: stores the minimum key in the subtree of this node.\n        self.min_key = key\n\ndef build_balanced_bst(keys):\n    \"\"\"\n    Constructs a height-balanced BST from a sorted list of keys.\n    The augmentation field (min_key) is computed recursively.\n    \n    Args:\n        keys: A sorted list of unique integer keys.\n    \n    Returns:\n        The root node of the constructed BST, or None if the list is empty.\n    \"\"\"\n    if not keys:\n        return None\n\n    # Recursively choose the median as the root to ensure balance.\n    mid_idx = len(keys) // 2\n    root = Node(keys[mid_idx])\n\n    root.left = build_balanced_bst(keys[:mid_idx])\n    root.right = build_balanced_bst(keys[mid_idx+1:])\n\n    # Compute the augmentation field after children are constructed.\n    # The minimum key in a subtree is the minimum of its leftmost branch.\n    if root.left:\n        root.min_key = root.left.min_key\n    else:\n        root.min_key = root.key\n        \n    return root\n\ndef _find_min_in_range_recursive(node, L, R):\n    \"\"\"\n    Recursive helper to find the minimum key in the interval [L, R].\n    \n    Args:\n        node: The current node in the BST.\n        L: The lower bound of the interval (inclusive).\n        R: The upper bound of theinterval (inclusive).\n        \n    Returns:\n        The minimum key in the interval, or np.inf if no such key exists.\n    \"\"\"\n    # Base Case: If the node is null, there are no keys in this subtree.\n    if node is None:\n        return np.inf\n\n    # Pruning Step 1 (using augmentation): If the smallest key in the entire\n    # subtree is greater than R, no key in this subtree can be in the range.\n    if R  node.min_key:\n        return np.inf\n\n    # Pruning Step 2 (using BST property): If the current node's key is less than L,\n    # then itself and its entire left subtree are out of range. Search right.\n    if node.key  L:\n        return _find_min_in_range_recursive(node.right, L, R)\n\n    # At this point, node.key >= L. A solution might be in the left subtree,\n    # at the current node, or in the right subtree. We search in that order\n    # to find the minimum.\n\n    # 1. Search the left subtree.\n    result_left = _find_min_in_range_recursive(node.left, L, R)\n    if result_left != np.inf:\n        # If a valid key is found in the left subtree, it's guaranteed to be\n        # the smallest possible answer in this branch.\n        return result_left\n\n    # 2. Check the current node.\n    if node.key = R:\n        # The left subtree had no solution. If the current node is valid,\n        # it is the smallest valid key we can find from this point on.\n        return node.key\n\n    # 3. Search the right subtree.\n    # This is reached only if the left subtree had no solution and the\n    # current node's key was invalid (i.e., node.key > R).\n    return _find_min_in_range_recursive(node.right, L, R)\n\ndef find_min_in_range(root, L, R):\n    \"\"\"\n    Wrapper function for the interval minimum query.\n    \n    Args:\n        root: The root of the augmented BST.\n        L: The lower bound of the interval.\n        R: The upper bound of the interval.\n        \n    Returns:\n        The minimum key in [L, R], or -1 if the interval is invalid or no key is found.\n    \"\"\"\n    # An empty interval [L, R] with L > R contains no keys.\n    if L > R:\n        return -1\n\n    result = _find_min_in_range_recursive(root, L, R)\n\n    # The recursive helper uses np.inf to signal \"not found\".\n    # Convert this to the required output format of -1.\n    return int(result) if result != np.inf else -1\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (5, 13)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (15, 20)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (7, 7)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (0, 2)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (-5, 100)},\n        {'keys': [1, 3, 4, 6, 7, 8, 10, 13, 14], 'query': (9, 5)},\n        {'keys': [42], 'query': (10, 100)},\n        {'keys': [42], 'query': (43, 50)},\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        L, R = case['query']\n        \n        # Build the augmented, height-balanced BST for the current case.\n        root = build_balanced_bst(keys)\n        \n        # Perform the query and store the result.\n        result = find_min_in_range(root, L, R)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3233410"}, {"introduction": "在数据结构增强概念的基础上，我们可以解答更复杂的基于顺序关系的问题。最后的这项练习将探索“顺序统计树”，它是一种通过增强子树大小信息的二叉搜索树。这种增强使得我们能够在对数时间内确定任一键的排名，或者反过来，找出指定排名的键。你将实现这些核心操作来解决一个更具普遍性的问题：找到给定键 $k$ 的第 $m$ 个后继，从而展示增强数据结构在处理复杂顺序关系查询时的全部威力。[@problem_id:3233472]", "problem": "您需要设计并实现一个增强二叉搜索树（BST）数据结构，以支持基于顺序的查询。从二叉搜索树（BST）的核心定义开始：对于任何键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。BST 的中序遍历会以严格递增的顺序访问键。您的任务是为每个节点增加其子树的大小信息，并利用此信息高效地计算极值和基于顺序的查询。\n\n定义存储在 BST 中的不同整数键集合中，实数值查询键 $k$ 的广义第 $m$ 后继如下。设 $r(k)$ 为树中小于或等于 $k$ 的键的数量。设 $n$ 为树中键的总数。$k$ 的广义第 $m$ 后继是中序排名为 $r(k)+m$ 的键，其中排名从 1 开始计数。如果 $r(k)+m$ 不在区间 $[1,n]$ 内，则广义第 $m$ 后继不存在。该定义允许 $k$ 不存在于树中，也允许 $m$ 为零。特别地，当 $m=1$ 且 $k$ 存在于树中时，这与常规的后继一致；当 $m=0$ 时，如果存在，它返回小于或等于 $k$ 的最大键。\n\n实现一个程序，该程序：\n- 从给定的不同整数键的有限列表中构建一个 BST。假设键是唯一的；如果插入操作试图添加重复键，必须忽略该操作，不改变树的结构。\n- 为每个节点增加其子树大小，定义为 $1+\\text{size(left)}+\\text{size(right)}$，其中空子树的大小为 $0$。\n- 支持两个操作，其时间复杂度与树高成正比：\n  - $r(k)$: 返回小于或等于 $k$ 的键的数量。\n  - $\\text{select}(t)$: 返回中序排名为 $t$ 的键（$t$ 从 1 开始）。\n- 当目标排名在 $[1,n]$ 内时，计算 $k$ 的广義第 $m$ 后继为 $\\text{select}(r(k)+m)$，否则报告一个哨兵值。\n\n顺序关系和域假设：\n- 所有键都是半开区间 $[0,10^9)$ 内的整数。\n- 严格全序是标准的整数小于关系（$$）。\n- 查询可以使用任何整数 $k$（不一定在 $[0,10^9)$ 内）；$m$ 是一个非负整数。\n- 如果广义第 $m$ 后继不存在，则输出哨兵整数 $-1$。\n\n测试套件和要求的输出格式：\n- 对于以下每一组参数，从提供的键列表（如果存在重复则忽略）构建 BST，然后使用上述定义计算给定 $(k,m)$ 的广义第 $m$ 后继。程序必须汇总所有测试用例的结果，并打印一行由逗号分隔的列表，用方括号括起，例如 $[x_1,x_2,\\dots,x_T]$，其中每个 $x_i$ 是测试用例 $i$ 的整数答案。\n\n使用以下测试套件：\n- 情况 1：键 $[20,10,30,5,15,25,35]$，查询 $(k=10,m=1)$。\n- 情况 2：键 $[20,10,30,5,15,25,35]$，查询 $(k=10,m=0)$。\n- 情况 3：键 $[20,10,30,5,15,25,35]$，查询 $(k=10,m=3)$。\n- 情况 4：键 $[20,10,30,5,15,25,35]$，查询 $(k=34,m=1)$。\n- 情况 5：键 $[20,10,30,5,15,25,35]$，查询 $(k=35,m=1)$。\n- 情况 6：键 $[20,10,30,5,15,25,35]$，查询 $(k=-100,m=1)$。\n- 情况 7：键 $[1,2,3,4]$，查询 $(k=2,m=2)$。\n- 情况 8：键 $[1,2,3,4]$，查询 $(k=2,m=10)$。\n- 情况 9：键 $[1,2,3,4]$，查询 $(k=100,m=0)$。\n- 情况 10：键 $[]$ (空树)，查询 $(k=5,m=1)$。\n\n您的程序应生成一行输出，包含一个由逗号分隔并用方括号括起来的结果列表，例如 $[x_1,x_2,\\dots,x_{10}]$，其中每个 $x_i$ 是用例 $i$ 的整数结果。", "solution": "问题要求设计并实现一个增强二叉搜索树（BST），以高效地回答基于顺序的查询。核心任务是计算键 $k$ 的广义第 $m$ 后继，其定义为中序排名为 $r(k)+m$ 的键，其中 $r(k)$ 是树中小于或等于 $k$ 的键的数量。\n\n解决方案基于顺序统计树，这是一种每个节点都增加了以其为根的子树大小信息的 BST。这种增强使得基于排名的查询能够高效计算。\n\n**1. 数据结构：增强 BST 节点**\n\n我们为 BST 定义一个 `Node`。除了标准的 `key`、`left`子指针和 `right` 子指针外，每个节点还将存储一个 `size` 属性。节点的 `size` 定义为以该节点为根的子树中节点的总数（包括节点本身）。\n$$\n\\text{node.size} = 1 + \\text{size}(\\text{node.left}) + \\text{size}(\\text{node.right})\n$$\n其中 `size(null node)` 定义为 $0$。新插入的叶节点的大小为 $1$。\n\n**2. 核心操作**\n\n功能构建在三个主要操作之上：`insert`、`r`（排名）和 `select`。所有这些操作的时间复杂度都设计为与树的高度成正比，即 $O(h)$。对于平衡树，这是 $O(\\log n)$；对于退化的树，这是 $O(n)$，其中 $n$ 是键的数量。\n\n**2.1. 插入 (`insert(key)`)**\n\n`insert` 操作遵循标准的 BST 插入逻辑来为新键找到正确的位置。\n- 如果树为空，新键成为根节点，其 `size` 初始化为 $1$。\n- 我们从根节点开始遍历树，将要插入的键与当前节点的键进行比较。如果新键较小，则向左走；如果较大，则向右走。\n- 如果找到具有相同键的节点，则根据问题规范，中止插入以避免重复。\n- 在遍历树以查找插入点时，我们必须更新路径上每个节点的 `size` 属性。从插入新节点的递归调用返回后，会重新计算父节点的 `size`。这确保了从新叶节点到根节点的每个节点的 `size` 都正确地增加了 $1$。\n\n**2.2. 排名查询 (`r(k)`)**\n\n函数 $r(k)$ 计算树中小于或等于 $k$ 的键的数量。这等同于找到小于或等于 $k$ 的最大键的中序排名。\n算法从根节点开始遍历树：\n- 设当前节点为 $x$。\n- 如果 $k  x.\\text{key}$：所有小于或等于 $k$ 的键必定在 $x$ 的左子树中。我们在 $x.\\text{left}$ 中递归搜索。\n- 如果 $k > x.\\text{key}$：$x$ 的左子树中的所有键，加上 $x$ 本身，都小于或等于 $k$。来自树的这一部分的计数是 $\\text{size}(x.\\text{left}) + 1$。我们将此计数与在右子树 $x.\\text{right}$ 中递归搜索的结果相加。\n- 如果 $k = x.\\text{key}$：$x$ 的左子树中的所有键，加上 $x$ 本身，都小于或等于 $k$。计数为 $\\text{size}(x.\\textleft) + 1$。搜索终止。\n- 如果我们到达一个空指针，计数为 $0$。\n\n**2.3. 选择查询 (`select(t)`)**\n\n函数 $\\text{select}(t)$ 查找具有给定中序排名 $t$ 的键，其中排名是 1-索引的。\n该算法利用 `size` 属性来导航树：\n- 设当前节点为 $x$。设其左子树的大小为 $s_L = \\text{size}(x.\\text{left})$。\n- 键 $x.\\text{key}$ 本身的排名是 $s_L + 1$。\n- 如果 $t = s_L + 1$：当前节点 $x$ 就是目标。我们返回 $x.\\text{key}$。\n- 如果 $t  s_L + 1$：目标键在左子树中。我们在 $x.\\text{left}$ 中递归搜索排名为 $t$ 的键。\n- 如果 $t > s_L + 1$：目标键在右子树中。我们已经跳过了左子树和根节点中的 $s_L + 1$ 个键。因此，我们必须在右子树 $x.\\text{right}$ 中查找排名为 $t - (s_L + 1)$ 的键。\n\n**3. 计算广义第 m 后继**\n\n有了 `r` 和 `select` 函数，计算查询键 $k$ 的广义第 $m$ 后继就变得很简单。设 $n$ 为树中键的总数，即根节点的大小。\n1. 计算 $k$ 的排名：$\\text{rank}_k = r(k)$。\n2. 计算目标排名：$\\text{target\\_rank} = \\text{rank}_k + m$。\n3. 检查目标排名是否有效。一个排名 $t$ 是有效的当且仅当 $1 \\le t \\le n$。\n4. 如果 $1 \\le \\text{target\\_rank} \\le n$，则结果是 $\\text{select}(\\text{target\\_rank})$。\n5. 否则，广义后继不存在，我们返回哨兵值 $-1$。这处理了树为空（$n=0$）或目标排名超出有效范围的情况。\n\n此设计满足了问题的所有要求，以所需的时间复杂度为每个操作提供了指定的功能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in an augmented Binary Search Tree.\n    Each node stores its key, pointers to left and right children,\n    and the size of the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.size = 1\n\nclass AugmentedBST:\n    \"\"\"\n    An augmented Binary Search Tree that supports order-statistic queries.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def _get_size(self, node):\n        \"\"\"Helper to get size of a node's subtree, returns 0 if node is None.\"\"\"\n        return node.size if node else 0\n\n    def insert(self, key):\n        \"\"\"Inserts a key into the BST, ignoring duplicates.\"\"\"\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        \"\"\"Recursively inserts a key and updates subtree sizes.\"\"\"\n        if not node:\n            return Node(key)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key)\n        else: # Key already exists, do nothing.\n            return node\n            \n        # Update the size of the current node\n        node.size = 1 + self._get_size(node.left) + self._get_size(node.right)\n        return node\n\n    def r(self, k):\n        \"\"\"Returns the number of keys in the tree less than or equal to k.\"\"\"\n        return self._r_recursive(self.root, k)\n\n    def _r_recursive(self, node, k):\n        \"\"\"Recursive helper for rank query.\"\"\"\n        if not node:\n            return 0\n        \n        if k  node.key:\n            return self._r_recursive(node.left, k)\n        elif k > node.key:\n            return self._get_size(node.left) + 1 + self._r_recursive(node.right, k)\n        else: # k == node.key\n            return self._get_size(node.left) + 1\n\n    def select(self, t):\n        \"\"\"Returns the key with the t-th in-order rank (1-indexed).\"\"\"\n        if not self.root or not (1 = t = self.root.size):\n            return None # Or raise an error, indicates invalid rank\n        return self._select_recursive(self.root, t)\n\n    def _select_recursive(self, node, t):\n        \"\"\"Recursive helper for select query.\"\"\"\n        if not node:\n            # This case should not be reached if initial rank is valid.\n            return None\n\n        left_size = self._get_size(node.left)\n        current_rank = left_size + 1\n        \n        if t == current_rank:\n            return node.key\n        elif t  current_rank:\n            return self._select_recursive(node.left, t)\n        else: # t > current_rank\n            return self._select_recursive(node.right, t - current_rank)\n\n    def generalized_successor(self, k, m):\n        \"\"\"\n        Computes the generalized m-th successor of k.\n        \"\"\"\n        n = self._get_size(self.root)\n        if n == 0:\n            return -1\n            \n        rank_k = self.r(k)\n        target_rank = rank_k + m\n        \n        if 1 = target_rank = n:\n            return self.select(target_rank)\n        else:\n            return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 0)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 3)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (34, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (35, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (-100, 1)}),\n        ({'keys': [1, 2, 3, 4], 'query': (2, 2)}),\n        ({'keys': [1, 2, 3, 4], 'query': (2, 10)}),\n        ({'keys': [1, 2, 3, 4], 'query': (100, 0)}),\n        ({'keys': [], 'query': (5, 1)}),\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        k, m = case['query']\n        \n        bst = AugmentedBST()\n        for key in keys:\n            bst.insert(key)\n        \n        result = bst.generalized_successor(k, m)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3233472"}]}