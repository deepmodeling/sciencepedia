{"hands_on_practices": [{"introduction": "深入理解一个算法不仅在于掌握其高层逻辑，还在于分析其具体的操作成本。本练习将聚焦于一个基础成本度量：指针修改的次数。通过该练习，你将揭示一个常见设计选择（即在节点中包含父指针）对二叉搜索树（BST）删除操作的微妙而重要的影响。[@problem_id:3219142]", "problem": "考虑一个标准的二叉搜索树（BST），其节点存储一个键和两个分别表示为 $left$ 和 $right$ 的子指针。BST 的不变量是：对于任意节点 $x$，其左子树 $x.left$ 中所有节点的键都严格小于 $x.key$，其右子树 $x.right$ 中所有节点的键都严格大于 $x.key$。删除操作必须在改变树结构后继续保持 BST 不变量，并且最多只能修改常数个指针。\n\n定义一次“指针改变”为对以下任一字段的单次写入：指向树的全局 $root$ 指针，或节点的 $left$、$right$ 或（如果存在）$parent$ 指针。对一个正在被销毁且已从树中断开连接的节点的内部字段的写入不计入在内。删除操作可以读取任意数量的指针，但我们不计算读取次数；只有写入操作才算作指针改变。\n\n假设删除算法是广泛使用的后继者复制法：要删除一个节点 $z$，\n1. 如果 $z$ 最多只有一个子节点，则通过将 $z$ 的（可能为 null 的）子节点直接连接到 $z$ 的父节点（如果 $z$ 是根节点，则连接到 $root$）来将 $z$ 拼接出去。\n2. 如果 $z$ 有两个子节点，找到 $z$ 的中序后继 $y$（即 $z$ 右子树中的最小值），将 $y.key$ 复制到 $z.key$ 中，然后删除 $y$。根据其构造，$y$ 没有左子节点；其右子节点可能为 null 或非 null。不执行其他键的复制操作。\n\n在以下两种模型中，分析此删除算法所执行的指针改变的确切数量：\n- 模型 A：节点不存储 $parent$ 指针。\n- 模型 B：节点存储一个必须始终保持正确的 $parent$ 指针。\n\n对于每种模型，推导出指针改变数量的紧确的最佳情况和最坏情况下的界限（针对所有可能的 BST 形状和删除目标），并给出能达到这些界限的场景作为证明。最终答案以单行矩阵的形式表示，顺序为 $(\\text{模型 A 中的最佳情况}, \\text{模型 A 中的最坏情况}, \\text{模型 B 中的最佳情况}, \\text{模型 B 中的最坏情况})$。您的答案必须是精确值，无需四舍五入。", "solution": "问题陈述是数据结构与算法领域中一个明确定义的问题。它清晰地定义了二叉搜索树（BST）、待分析的特定删除算法（后继者复制法）以及“指针改变”的精确定义。该问题是自洽的，在计算机科学原理上有科学依据，且没有歧义或矛盾。因此，该问题是有效的，可以对其进行严谨的分析。\n\n设 $z$ 是要被删除的节点。分析分为两部分，对应问题中定义的两种模型。一次指针改变是对 `root`、`left`、`right` 或 `parent` 指针字段的单次写入操作。\n\n指定的删除算法如下：\n1.  如果节点 $z$ 最多只有一个子节点（即 $z.left$ 为 `null` 或 $z.right$ 为 `null`），则将 $z$ 拼接出去。其父节点的相应子指针被更新，以指向 $z$ 的单个子节点（也可能为 `null`）。如果 $z$ 是根节点，则更新全局 `root` 指针。\n2.  如果节点 $z$ 有两个子节点，则找到它的中序后继节点 $y$。根据定义，$y$ 是 $z$ 右子树中键最小的节点。将 $y$ 的键复制到 $z$ 中（即 $z.key \\leftarrow y.key$）。然后，问题简化为从其原始位置删除节点 $y$。由于 $y$ 是一个子树中的最小元素，它保证没有左子节点（$y.left$ 为 `null`），因此删除它属于第一种情况（最多一个子节点）。\n\n我们现在为每种模型分析指针改变的数量。\n\n### 模型 A：节点不带 `parent` 指针\n\n在此模型中，仅有的指针是 `root`、`left` 和 `right`。\n\n**情况 1：删除最多有一个子节点的节点 $z$。**\n设 `p` 是 $z$ 的父节点，`c` 是 $z$ 的单个子节点（如果 $z$ 是叶节点，则为 `null`）。\n- 如果 $z$ 是树的根节点，则 `p` 为 `null`。全局 `root` 指针被更新以指向 `c`。这恰好是 **一次** 指针改变：`root \\leftarrow c`。\n- 如果 $z$ 不是根节点，其父节点 `p` 必须更新其一个子指针。如果 $z$ 是 `p` 的左子节点，指针改变为 `p.left \\leftarrow c`。如果 $z$ 是右子节点，改变为 `p.right \\leftarrow c`。无论哪种情况，这都恰好构成 **一次** 指针改变。\n因此，在模型 A 中，删除一个最多有一个子节点的节点总是导致恰好 $1$ 次指针改变。\n\n**情况 2：删除有两个子节点的节点 $z$。**\n该算法将后继节点 $y$ 的键复制到 $z$，然后删除 $y$。指针的改变仅与删除 $y$ 相关。如前所述，$y$ 没有左子节点，因此删除它属于情况 1 的一个实例。节点 $y$ 始终在 $z$ 的右子树中，因此它永远不可能是整棵树的根。因此，$y$ 始终有一个父节点，我们称之为 $y_p$。\n为了删除 $y$，$y_p$ 的相应子指针被更新，以指向 $y$ 唯一可能的子节点 $y.right$。这涉及一次写入：要么是 $y_p.left \\leftarrow y.right$（如果 $y$ 是一个左子节点），要么是 $y_p.right \\leftarrow y.right$（如果 $y$ 是其父节点的直接右子节点）。这总是恰好 **一次** 指针改变。\n\n**模型 A 的结论：**\n在所有可能的情况下——删除叶节点、带有一个子节点的节点或带有两个子节点的节点——指定的算法都恰好执行 $1$ 次指针改变。\n- **模型 A 中指针改变的最佳情况次数是 $1$。** 每次删除都会达到这个次数。\n- **模型 A 中指针改变的最坏情况次数是 $1$。** 这是任何删除操作的最大改变次数。\n\n### 模型 B：节点带 `parent` 指针\n\n在此模型中，我们还必须维护 `parent` 指针的正确性。\n\n**情况 1：删除最多有一个子节点的节点 $z$。**\n设 `p` 是 $z$ 的父节点，`c` 是 $z$ 的单个子节点。\n与模型 A 中一样，`p` 的一个指针（或 `root` 指针）被更新以绕过 $z$ 并指向 `c`。这是 **一次** 指针改变。\n此外，如果子节点 `c` 不为 `null`，它的 `parent` 指针必须从 $z$ 更新为 `p`。这个操作 `c.parent \\leftarrow p` 是 **第二次** 指针改变。\n- 如果 $z$ 是一个叶节点，则 `c` 为 `null`。没有 `parent` 指针需要更新。总共是 **一次** 指针改变。\n- 如果 $z$ 有一个子节点 `c`，则有两个指针被改变：`p` 的子指针（或 `root`）和 `c` 的 `parent` 指针。总共是 **两次** 指针改变。\n\n**情况 2：删除有两个子节点的节点 $z$。**\n同样，该操作简化为删除后继节点 $y$，它最多只有一个子节点（其右子节点 $y.right$）。设 `y_p` 是 $y$ 的父节点，`y_c` 是 $y$ 的右子节点。指针改变的数量通过将情况 1 的逻辑应用于节点 $y$ 来确定。\n- $y_p$ 的子指针被更新以指向 $y_c$。这是 **一次** 指针改变。\n- 如果 $y_c$ 不为 `null`，它的 `parent` 指针必须更新为 $y_p$。这是 **第二次** 指针改变。\n如果 $y$ 是叶节点（`y_c` 为 `null`），总改变次数为 $1$；如果 $y$ 有一个右子节点，总改变次数为 $2$。\n\n**模型 B 的结论：**\n指针改变的次数可以是 $1$ 或 $2$。\n- **模型 B 中指针改变的最佳情况次数是 $1$。**\n  当被实际拼接出去的节点是叶节点时，达到这个最小值。\n  - 场景 1：删除一个叶节点 $z$。只需要一次指针改变，即将父节点的子指针设置为 `null`。\n  - 场景 2：删除一个有两个子节点的节点 $z$，且其中序后继 $y$ 是一个叶节点。删除 $y$ 只需要一次指针改变。\n- **模型 B 中指针改变的最坏情况次数是 $2$。**\n  当被实际拼接出去的节点有一个子节点时，达到这个最大值。\n  - 场景 1：删除一个恰好有一个子节点 `c` 的节点 $z$。需要两次改变：一次是父节点的子指针，另一次是 `c` 的 `parent` 指针。\n  - 场景 2：删除一个有两个子节点的节点 $z$，且其中序后继 $y$ 有一个右子节点 $y_c$。删除 $y$ 需要两次改变：一次是其父节点的子指针，另一次是 $y_c$ 的 `parent` 指针。\n\n### 最终总结\n每个模型的指针改变次数如下：\n- 模型 A（无 `parent`）：最佳情况 = $1$，最坏情况 = $1$。\n- 模型 B（有 `parent`）：最佳情况 = $1$，最坏情况 = $2$。\n\n最终答案以单行矩阵的形式呈现，顺序为 $(\\text{模型 A 中的最佳情况}, \\text{模型 A 中的最坏情况}, \\text{模型 B 中的最佳情况}, \\text{模型 B 中的最坏情况})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 1  1  1  2 \\end{pmatrix}\n}\n$$", "id": "3219142"}, {"introduction": "在分析了底层机制之后，我们转向实际的编程实现。现实世界的数据常常包含重复键，这与基础BST定义的严格不等式相违背。本练习要求你通过在一个复合键上定义一个严格全序关系，来实现一个能正确处理重复项的BST——这是一种标准且强大的技术。[@problem_id:3219123]", "problem": "您需要实现一个二叉搜索树（BST），用于存储由一个整数键和一个卫星数据引用（一个对象）组成的记录。二叉搜索树（BST）由以下不变性定义：对于每个键为 $k$ 的节点，其左子树中的所有键在严格全序的比较下都严格小于 $k$，其右子树中的所有键都严格大于 $k$。由于本任务需要处理重复的整数键，您必须将比较提升为对复合键 $(k,i)$ 的严格全序，其中 $k$ 是整数键，$i$ 是与载荷对象关联的唯一标识标签。$(k,i)$ 上的严格全序是字典序的：$(k_1,i_1)  (k_2,i_2)$ 当且仅当 $k_1  k_2$ 或者 ($k_1 = k_2$ 且 $i_1  i_2$)。这确保了具有相同整数键的元素通过其载荷的标识标签进行确定性排序。\n\n您的设计必须基于以下基本原则：上述核心BST不变性、键上存在严格全序，以及中序遍历的正确性（该遍历会按严格全序的非递减顺序产生键）。使用这些基础来推导维护该不变性的插入、搜索和删除操作。特别地，删除操作必须能够移除具有相同整数键的多个实例中的特定一个。目标由整数键 $k$ 和卫星数据引用 $p$ 共同指定；引用相等性必须是基于指针同一性（即，是同一个对象，而不仅仅是内容相等）。您的实现必须保证在删除 $(k,p)$ 时，移除的是其载荷为同一对象 $p$ 的那个精确节点，并且结果树继续遵守基于 $(k,i)$ 字典序的BST不变性。\n\n您必须实现：\n- 一个插入操作，通过比较复合键 $(k,i)$ 来放置节点，其中 $i$ 是载荷对象的标识标签。\n- 一个按键搜索操作，返回其整数键等于查询值 $k$ 的所有载荷标识标签 $i$，并按中序遍历排序，以使它们的 $i$ 值按升序排列。\n- 一个按键和引用删除操作，精确移除整数键等于 $k$ 且其载荷对象与所提供的对象 $p$ 在指针上是同一的节点。对于有两个子节点的节点，使用从BST不变性推导出的标准中序后继替换法：用其右子树中在严格全序下的最小值替换该节点的内容，然后在该后继的原始位置删除它。对于有一个子节点或叶子节点的情况，进行适当的拼接。\n\n您的程序必须运行以下测试套件。在所有情况下，载荷标识标签 $i$ 是您为每个创建的载荷对象确定性地分配的一个整数，并随对象保留。对于每个测试用例，请按顺序执行插入操作，然后执行删除操作 $(k,p)$，接着对给定的键 $s$ 执行搜索。输出必须在删除操作完成后计算。\n\n测试套件：\n- 测试 $1$：插入 $(5,10)$, $(3,20)$, $(7,30)$, $(3,21)$, $(5,11)$, $(7,31)$。删除实例 $(5,p)$，其中 $p$ 是标识标签为 $11$ 的载荷对象。然后搜索 $s=5$。\n- 测试 $2$：插入 $(4,40)$, $(2,50)$, $(6,60)$, $(6,61)$。删除实例 $(6,p)$，其中 $p$ 的标识标签为 $61$。然后搜索 $s=6$。\n- 测试 $3$：插入 $(8,80)$, $(8,81)$, $(9,90)$。删除实例 $(8,p)$，其中 $p$ 的标识标签为 $80$。然后搜索 $s=8$。\n- 测试 $4$：插入 $(6,100)$, $(4,101), (7,102), (5,103), (3,104), (6,105)$。删除实例 $(6,p)$，其中 $p$ 的标识标签为 $100$。然后搜索 $s=6$。\n- 测试 $5$：不插入任何内容。尝试删除 $(1,p)$，其中 $p$ 的标识标签为 $200$。然后搜索 $s=1$。\n- 测试 $6$：插入 $(10,300)$, $(10,301)$。尝试删除 $(10,p)$，其中 $p$ 的标识标签为 $302$（该标签在树中不存在）。然后搜索 $s=10$。\n\n对于每个测试用例，您的程序必须输出一个包含四个元素的列表：\n- 删除后的整数键的中序列表（每个元素是 $k$）。\n- 删除后的载荷标识标签的中序列表（每个元素是 $i$）。\n- 给定 $s$ 的搜索结果的整数计数。\n- 一个表示删除是否成功的布尔值。\n\n最终输出格式要求：\n您的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个如上所述的四元素列表，例如：$[[\\dots],[\\dots],\\dots,\\text{True}]$。打印的行中不得有空格。输出必须仅为基本类型：布尔值、整数或这些类型的列表。不涉及物理单位或角度，因此无需指定。", "solution": "该问题要求实现一个能够存储可能包含重复整数键的记录的二叉搜索树（BST）。BST数据结构的正确性建立在其键上存在一个严格全序的基础上。为满足此要求，引入了复合键及相应的字典序排序。任务是推导并实现`insert`、`search`和`delete`操作，以在该排序规则下维护BST不变性，并根据指定的测试套件验证实现。\n\n### 严格全序原则\n\n二叉搜索树由一个不变性定义：对于任何键为 $k_n$ 的节点 $n$，其左子树中的所有键都严格小于 $k_n$，其右子树中的所有键都严格大于 $k_n$。这要求在键集上存在一个严格全序关系，记为 $$。如果键不是唯一的（例如，允许重复的整数键），那么整数上的标准比较不构成严格全序，因为对于两个具有相同键 $k$ 的不同项，两者均不严格小于对方。\n\n为解决此问题，题目指定了一个复合键 $(k, i)$，其中 $k$ 是整数键，$i$ 是与载荷关联的唯一标识标签。通过字典序比较建立严格全序：\n$$(k_1, i_1)  (k_2, i_2) \\iff (k_1  k_2) \\lor (k_1 = k_2 \\land i_1  i_2)$$\n鉴于每个载荷对象的标识标签 $i$ 是唯一的，这个复合键 $(k, i)$ 保证在树中的每个节点都是唯一的。这种构造使得BST不变性可以被明确地维护。\n\n### 数据结构设计\n\n为了高效地实现所需的操作，特别是删除操作，我们定义一个包含指向其父节点指针的`Node`结构。\n\n- **`Payload` 类**：一个用于持有唯一标识标签的简单对象。\n- **`Node` 类**：包含整数键 $k$、对 `Payload` 对象 $p$ 的引用，以及指向其 `left`、`right` 和 `parent` 节点的指针。用于比较的复合键是 `(node.key, node.payload.identity_tag)`。\n\n### 核心操作\n\n#### 插入操作\n\n`insert(k, p)` 操作添加一个具有整数键 $k$ 和载荷 $p$ 的新节点。该算法遵循BST不变性：\n1.  创建一个包含 $(k, p)$ 及其关联复合键 $(k, i)$ 的新 `Node`，其中 $i=p.\\text{identity\\_tag}$。\n2.  从树的根节点开始，向下遍历以找到插入点。在每个节点 `current`，将新节点的复合键 $(k, i)$ 与 `current` 的复合键进行比较。\n3.  如果 $(k, i)$ 小于 `current` 的键，则进入左子节点。\n4.  如果 $(k, i)$ 大于 `current` 的键，则进入右子节点。\n5.  此过程持续进行，直到遇到一个 `None`（空）子指针。新节点在此位置插入，其父指针设置为遍历的最后一个节点。\n\n#### 搜索操作\n\n`search(s)` 操作必须返回所有整数键为 $s$ 的载荷的标识标签。这些标签必须按升序排列。\n1.  对于给定的键 $k$，其标签的排序是字典序比较和树的中序遍历的自然结果。\n2.  可以通过递归的、剪枝的中序遍历来高效地实现搜索。设函数为 `_in_order_search(node, s)`。\n3.  如果 `node` 为 `None`，则终止递归。\n4.  如果搜索键 $s$ 小于 `node.key`，根据BST不变性，任何匹配的节点只能存在于左子树中。在 `node.left` 上递归。\n5.  如果 $s$ 大于 `node.key`，任何匹配的节点只能存在于右子树中。在 `node.right` 上递归。\n6.  如果 $s$ 等于 `node.key`，则匹配项可能存在于左、右子树中（具有不同的标识标签）。因此，我们必须：\n    a. 在 `node.left` 上递归。\n    b. 记录当前节点的载荷标识标签。\n    c. 在 `node.right` 上递归。\n此过程仅探索树的相关部分，并按正确的排序顺序收集标签。\n\n#### 删除操作\n\n`delete(k, p)` 操作必须移除与整数键 $k$ 和指针同一的载荷对象 $p$ 均匹配的特定节点。\n\n1.  **找到节点**：首先，必须定位目标节点。这通过从根节点开始遍历树来实现，使用复合键 $(k, i)$（其中 $i=p.\\text{identity\\_tag}$）来引导搜索。如果找到节点，我们还需验证指针同一性（`node.payload is p`）以确保正确性，尽管如果实现正确，唯一的复合键使得这一步是多余的。如果搜索路径在 `None` 处结束，则节点不存在，删除失败。\n\n2.  **移除节点**：一旦找到目标节点（称之为 $z$），其移除方式取决于其子节点的数量。一个辅助函数 `_transplant(u, v)`（用以节点 $v$ 的子树替换节点 $u$ 的子树）可以简化逻辑。\n\n    -   **情况 1：$z$ 没有左子节点。** 节点 $z$ 由其右子节点替换。这涵盖了叶子节点（右子节点为 `None`）和只有右子节点的节点。我们调用 `_transplant(z, z.right)`。\n\n    -   **情况 2：$z$ 有左子节点但没有右子节点。** 节点 $z$ 由其左子节点替换。我们调用 `_transplant(z, z.left)`。\n\n    -   **情况 3：$z$ 有两个子节点。** 这是最复杂的情况。BST不变性要求用一个能保持顺序的节点来替换 $z$。标准算法使用 $z$ 的中序后继，即 $z$ 右子树中键最小的节点。设该后继为 $y$。\n        a.  将 $y$ 的内容（键和载荷）复制到 $z$ 中。\n        b.  问题现在简化为删除原始节点 $y$。根据其在子树中为最小值的定义，$y$ 没有左子节点。因此，它的删除属于情况 1 或 2，这是一个可以通过递归或迭代解决的更简单的问题。\n        c.  一种源自 CLRS（我们遵循的）更直接的实现不复制数据，而是重新链接指针：\n            i.  如果后继 $y$ 不是 $z$ 的右子节点，首先用 $y$ 自己的右子节点替换 $y$，然后让 $y$ 接管 $z$ 的右子树。\n            ii. 用 $y$ 替换 $z$。\n            iii. 让 $y$ 接管 $z$ 的左子树。\n\n这种系统的、基于原则的方法确保所有操作都维护BST不变性，从而保证了数据结构的正确性。", "answer": "```python\nimport numpy as np\n\nclass Payload:\n    \"\"\"A simple payload class to hold a unique identity tag.\"\"\"\n    def __init__(self, identity_tag):\n        self.identity_tag = identity_tag\n    \n    def __repr__(self):\n        return f\"Payload({self.identity_tag})\"\n\nclass Node:\n    \"\"\"A node in the Binary Search Tree.\"\"\"\n    def __init__(self, key, payload):\n        self.key = key\n        self.payload = payload\n        self.left = None\n        self.right = None\n        self.parent = None\n    \n    @property\n    def composite_key(self):\n        return (self.key, self.payload.identity_tag)\n\n    def __repr__(self):\n        return f\"Node(k={self.key}, i={self.payload.identity_tag})\"\n\nclass BST:\n    \"\"\"\n    Binary Search Tree implementation handling duplicate integer keys\n    via a composite key (k, i) and lexicographic ordering.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key, payload):\n        \"\"\"Inserts a new node with the given key and payload.\"\"\"\n        new_node = Node(key, payload)\n        y = None\n        x = self.root\n        \n        while x is not None:\n            y = x\n            if new_node.composite_key  x.composite_key:\n                x = x.left\n            else:\n                x = x.right\n        \n        new_node.parent = y\n        if y is None:\n            self.root = new_node\n        elif new_node.composite_key  y.composite_key:\n            y.left = new_node\n        else:\n            y.right = new_node\n\n    def search(self, key_to_find):\n        \"\"\"\n        Returns a list of identity tags for all nodes with the given integer key.\n        The results are sorted by identity tag due to in-order traversal.\n        \"\"\"\n        results = []\n        self._in_order_search(self.root, key_to_find, results)\n        return results\n\n    def _in_order_search(self, node, key_to_find, results):\n        if node is None:\n            return\n        \n        if key_to_find  node.key:\n            self._in_order_search(node.left, key_to_find, results)\n        elif key_to_find > node.key:\n            self._in_order_search(node.right, key_to_find, results)\n        else: # key_to_find == node.key\n            self._in_order_search(node.left, key_to_find, results)\n            results.append(node.payload.identity_tag)\n            self._in_order_search(node.right, key_to_find, results)\n\n    def _find_node(self, key, payload):\n        \"\"\"Finds a specific node by its composite key and payload identity.\"\"\"\n        node = self.root\n        target_composite_key = (key, payload.identity_tag)\n        while node is not None and target_composite_key != node.composite_key:\n            if target_composite_key  node.composite_key:\n                node = node.left\n            else:\n                node = node.right\n        \n        # Additionally verify pointer identity\n        if node and node.payload is payload:\n            return node\n        return None\n\n    def delete(self, key, payload):\n        \"\"\"Deletes the specific node identified by key and payload object.\"\"\"\n        node_to_delete = self._find_node(key, payload)\n        if node_to_delete is None:\n            return False\n        \n        self._delete_node(node_to_delete)\n        return True\n\n    def _transplant(self, u, v):\n        \"\"\"Replaces subtree rooted at u with subtree rooted at v.\"\"\"\n        if u.parent is None:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        if v is not None:\n            v.parent = u.parent\n\n    def _find_min(self, node):\n        \"\"\"Finds the node with the minimum key in a subtree.\"\"\"\n        while node.left is not None:\n            node = node.left\n        return node\n\n    def _delete_node(self, z):\n        \"\"\"Helper function to perform the deletion of node z.\"\"\"\n        if z.left is None:\n            self._transplant(z, z.right)\n        elif z.right is None:\n            self._transplant(z, z.left)\n        else:\n            y = self._find_min(z.right)\n            if y.parent != z:\n                self._transplant(y, y.right)\n                y.right = z.right\n                y.right.parent = y\n            \n            self._transplant(z, y)\n            y.left = z.left\n            y.left.parent = y\n\n    def get_in_order_traversal(self):\n        \"\"\"Returns two lists: keys and tags from an in-order traversal.\"\"\"\n        keys = []\n        tags = []\n        self._in_order_collect(self.root, keys, tags)\n        return keys, tags\n    \n    def _in_order_collect(self, node, keys, tags):\n        if node is not None:\n            self._in_order_collect(node.left, keys, tags)\n            keys.append(node.key)\n            tags.append(node.payload.identity_tag)\n            self._in_order_collect(node.right, keys, tags)\n\ndef solve():\n    test_cases = [\n        {\n            \"inserts\": [(5, 10), (3, 20), (7, 30), (3, 21), (5, 11), (7, 31)],\n            \"delete\": (5, 11),\n            \"search\": 5\n        },\n        {\n            \"inserts\": [(4, 40), (2, 50), (6, 60), (6, 61)],\n            \"delete\": (6, 61),\n            \"search\": 6\n        },\n        {\n            \"inserts\": [(8, 80), (8, 81), (9, 90)],\n            \"delete\": (8, 80),\n            \"search\": 8\n        },\n        {\n            \"inserts\": [(6, 100), (4, 101), (7, 102), (5, 103), (3, 104), (6, 105)],\n            \"delete\": (6, 100),\n            \"search\": 6\n        },\n        {\n            \"inserts\": [],\n            \"delete\": (1, 200),\n            \"search\": 1\n        },\n        {\n            \"inserts\": [(10, 300), (10, 301)],\n            \"delete\": (10, 302),\n            \"search\": 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        bst = BST()\n        payload_map = {}\n\n        # Perform insertions\n        for k, i in case[\"inserts\"]:\n            p = Payload(i)\n            payload_map[i] = p\n            bst.insert(k, p)\n        \n        # Perform deletion\n        del_key, del_tag = case[\"delete\"]\n        payload_to_delete = payload_map.get(del_tag)\n        # If the payload wasn't inserted, we create a dummy for the delete attempt\n        if payload_to_delete is None:\n            payload_to_delete = Payload(del_tag)\n        \n        deletion_succeeded = bst.delete(del_key, payload_to_delete)\n        \n        # Get post-deletion state\n        in_order_keys, in_order_tags = bst.get_in_order_traversal()\n        \n        # Perform search\n        search_results = bst.search(case[\"search\"])\n        search_count = len(search_results)\n        \n        results.append([\n            in_order_keys,\n            in_order_tags,\n            search_count,\n            deletion_succeeded\n        ])\n\n    # Format the output as a single line JSON-like string with no spaces\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3219123"}, {"introduction": "递归算法的优雅有其现实的局限性，尤其是在处理深度不平衡的树时，存在栈溢出的风险。这最后一个练习将探讨一种健壮的解决方案：使用父指针实现的迭代方法作为备用策略。这是编写兼具正确性和鲁棒性的生产级代码的关键一课。[@problem_id:3219097]", "problem": "你必须编写一个完整、可运行的程序，该程序针对一组给定的测试用例，构建和操作一个二叉搜索树 (BST)，同时分析递归深度并使用迭代回退机制。二叉搜索树 (BST) 是一种有根二叉树，其中对于任意键值为 $k$ 的节点，其左子树中的每个键值都严格小于 $k$，且其右子树中的每个键值都严格大于 $k$。目标是在 BST 上实现搜索、插入和删除操作，分析在深度较大的树中递归深度的影响，并使用父指针实现一种迭代回退机制，以避免超过递归深度限制。\n\n基本原则：\n- 每次操作后，BST 的排序属性必须保持不变。\n- 在 BST 路径上，递归算法的递归深度受其所循路径长度的限制。在最坏的情况下，如果 BST 退化成一条链，该路径长度将接近节点数 $n$。\n- 父指针允许进行迭代遍历和更新，这些操作遵循与递归算法相同的路径，但不会消耗调用栈帧。\n\n程序要求：\n- 实现一个 BST，其中每个节点存储一个键值以及指向其左子节点、右子节点和父节点的指针。\n- 为三个核心操作（搜索、插入、删除）实现递归和迭代两种版本。\n- 将树 $T$ 的高度 $h(T)$ 定义为从根到叶的最长简单路径上的节点数。空树的高度为 $0$。\n- 使用以下决策规则以避免递归深度溢出：给定一个递归深度限制 $L$，如果估计的递归深度 $\\leq L$，则选择递归版本，否则选择迭代版本。使用 BST 的当前高度 $h$ 来估计递归深度，具体如下：\n  - 对于搜索键值 $x$：估计 $d \\leq h$。\n  - 对于删除键值 $x$：估计 $d \\leq h$。\n  - 对于插入键值 $x$：估计 $d \\leq h + 1$。\n- 在决策规则内部计算 $h$ 时，使用不依赖递归的迭代方法（例如，广度优先遍历）。\n- 插入操作忽略重复项。\n- 对于删除操作，实现标准的三种情况删除法：\n  - 节点没有子节点：移除它。\n  - 节点有一个子节点：通过将其子节点连接到其父节点来将其拼接掉。\n  - 节点有两个子节点：用其中序后继（右子树中的最小值）的键值替换其键值，然后删除该后继节点。当选择迭代版本时，使用父指针执行结构更新，而不使用递归栈。\n\n每个测试用例的产出：\n- 使用上述决策规则和给定的 $L$，通过插入给定初始序列中的所有键值来构建初始 BST。\n- 按顺序应用所列操作，每次操作同样使用决策规则。\n- 对每个测试用例，输出一个形式为 $[H, F, S, I]$ 的结果列表，其中：\n  - $H$ 是所有操作后 BST 的最终高度（如上定义），表示为整数。\n  - $F$ 是一个布尔值，指示在初始构建或操作期间是否至少使用过一次迭代回退（如果至少使用过一次则为 true，否则为 false）。\n  - $S$ 是一个布尔值，等于测试用例中执行的最后一次搜索操作的结果（如果找到搜索的键值则为 true，否则为 false）。如果测试用例中没有搜索操作，则取 $S = \\text{false}$。\n  - $I$ 是 BST 最终的中序遍历，为一个整数列表。\n- 程序必须将所有测试用例的结果汇总到一行中，以逗号分隔的列表形式打印，并用方括号括起来，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 本身是一个列表 $[H,F,S,I]$。\n\n测试套件：\n- 测试用例 $1$（平衡插入，预计无回退）：\n  - $L = 100$\n  - 初始插入序列：$[8,4,12,2,6,10,14,1,3,5,7,9,11,13,15]$\n  - 操作：搜索 $7$；删除 $8$；插入 $16$；删除 $2$；搜索 $100$\n- 测试用例 $2$（退化链，深度接近 $n$，预计有回退）：\n  - $L = 40$\n  - 初始插入序列：$[1,2,\\dots,60]$\n  - 操作：搜索 $60$；插入 $61$；删除 $1$；删除 $61$；搜索 $30$\n- 测试用例 $3$（空树边界条件）：\n  - $L = 5$\n  - 初始插入序列：$[]$\n  - 操作：搜索 $10$；删除 $10$；插入 $10$；搜索 $10$；删除 $10$\n- 测试用例 $4$（深度等于限制的边界情况，搜索操作预计无回退）：\n  - $L = 20$\n  - 初始插入序列：$[1,2,\\dots,20]$\n  - 操作：搜索 $20$\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果都按所述格式化。例如：$[[H_1,F_1,S_1,I_1],[H_2,F_2,S_2,I_2],[H_3,F_3,S_3,I_3],[H_4,F_4,S_4,I_4]]$。", "solution": "该解决方案围绕一个 `BST` 类构建，该类封装了管理由 `Node` 对象组成的二叉搜索树的逻辑。每个操作（`search`、`insert`、`delete`）都通过一个公开方法实现，该方法应用指定的决策规则来选择使用递归或迭代的私有辅助方法。\n\n**1. 节点结构**\n\n基本构建块是 `Node` 类。每个 `Node` 实例存储一个整数 `key` 和三个指针：`left`、`right` 和 `parent`。`parent` 指针对于树修改的迭代实现至关重要，因为它允许从一个节点向上遍历并修改其父节点的子指针，而无需递归栈。\n\n$$\n\\text{Node} = \\{ \\text{key} \\in \\mathbb{Z}, \\text{left} \\in \\{\\text{Node}, \\text{None}\\}, \\text{right} \\in \\{\\text{Node}, \\text{None}\\}, \\text{parent} \\in \\{\\text{Node}, \\text{None}\\} \\}\n$$\n\n**2. 迭代式高度计算**\n\n选择递归方法还是迭代方法的决策规则取决于当前树的高度 $h$。为防止高度计算本身在深度较大的树中可能导致栈溢出，我们必须以迭代方式实现它。广度优先搜索 (BFS) 或层序遍历是自然的选择。该算法用根节点初始化一个队列，然后逐层处理树，每遍历一层就增加高度计数器。总层数对应于树的高度，定义为从根到叶的最长路径上的节点数。空树正确地得到高度 $0$。\n\n**3. 决策规则与回退机制**\n\n一个核心的 `BST` 类管理树的 `root`、递归限制 $L$ 和一个布尔标志 `fallback_used`。在执行 `search`、`insert` 或 `delete` 之前，计算当前高度 $h$。\n- 对于 `search` 和 `delete`，如果 $h \\le L$，则调用递归版本。否则，将 `fallback_used` 设置为 `true` 并执行迭代版本。\n- 对于 `insert`，估计深度为 $h+1$，因为新节点可能会增加树的高度。因此，如果 $h+1 \\le L$，则使用递归版本；否则，触发迭代回退。\n\n**4. 核心操作：双重实现**\n\n- **搜索**：递归和迭代搜索都是标准的。递归版本通过函数调用向下遍历树，而迭代版本使用 `while` 循环，更新指向当前节点的指针，直到找到键或到达 `None` 指针。\n\n- **插入**：递归插入遍历到正确位置，并沿调用栈向上传递新创建的节点，允许父节点链接它。在递归下降过程中设置父指针。迭代插入首先向下遍历以找到适当的父节点，然后创建新节点并手动将其链接到父节点。\n\n- **删除**：删除是最复杂的操作，特别是其迭代版本。\n    - **递归删除**：此实现遵循标准的三种情况逻辑。当删除具有两个子节点的节点时，其键被其中序后继的键替换，然后递归调用以从右子树中删除该后继节点。在递归返回时，会仔细更新父指针。\n    - **迭代删除**：此实现对于深度较大的树更健壮，并且严重依赖父指针。使用一个辅助函数 `_transplant`，通过正确地重新连接父节点的子指针和子节点的父指针，用另一个子树替换一个子树。\n        - **0/1 子节点情况**：待删除节点直接用其单个子节点（或 `None`）进行移植替换。\n        - **2 子节点情况**：找到该节点的有序后继 $y$。如果 $y$ 不是待删除节点的直接右子节点，则首先用 $y$ 自己的右子节点移植 $y$，以将其移出原始位置。然后，通过让 $y$ 继承目标节点的子节点来准备替换目标节点。最后，用准备好的后继 $y$ 移植替换目标节点。此过程无需递归即可细致地更新所有 `parent`、`left` 和 `right` 指针。\n\n通过遵循此设计，最终的程序能正确实现指定的 BST 逻辑，遵守递归深度限制，并为每个测试用例生成所需的分析结果。", "answer": "```python\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the Binary Search Tree.\n    Each node stores a key, and pointers to its left, right, and parent nodes.\n    \"\"\"\n    def __init__(self, key, parent=None):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.parent = parent\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass BST:\n    \"\"\"\n    Implements a Binary Search Tree with both recursive and iterative operations,\n    governed by a recursion depth limit.\n    \"\"\"\n    def __init__(self, L):\n        self.root = None\n        self.L = L\n        self.fallback_used = False\n\n    def get_height_iterative(self):\n        \"\"\"\n        Calculates the height of the tree iteratively using BFS.\n        Height is defined as the number of nodes on the longest root-to-leaf path.\n        An empty tree has height 0.\n        \"\"\"\n        if not self.root:\n            return 0\n        height = 0\n        q = [self.root]\n        while q:\n            height += 1\n            level_size = len(q)\n            for _ in range(level_size):\n                node = q.pop(0)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return height\n\n    def search(self, key):\n        \"\"\"Public search method with decision logic.\"\"\"\n        h = self.get_height_iterative()\n        if h = self.L:\n            node = self._search_recursive(self.root, key)\n        else:\n            self.fallback_used = True\n            node = self._search_iterative(key)\n        return node is not None\n\n    def _search_recursive(self, node, key):\n        if not node or node.key == key:\n            return node\n        if key  node.key:\n            return self._search_recursive(node.left, key)\n        else:\n            return self._search_recursive(node.right, key)\n\n    def _search_iterative(self, key):\n        current = self.root\n        while current and current.key != key:\n            if key  current.key:\n                current = current.left\n            else:\n                current = current.right\n        return current\n\n    def insert(self, key):\n        \"\"\"Public insert method with decision logic.\"\"\"\n        h = self.get_height_iterative()\n        # Optimization: check for duplicate before calling recursive to avoid side effects\n        if self._search_iterative(key):\n            return\n\n        if h + 1 = self.L:\n            self.root = self._insert_recursive(self.root, key)\n        else:\n            self.fallback_used = True\n            self._insert_iterative(key)\n\n    def _insert_recursive(self, node, key, parent=None):\n        if not node:\n            return Node(key, parent)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key, node)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key, node)\n        \n        return node\n\n    def _insert_iterative(self, key):\n        if not self.root:\n            self.root = Node(key)\n            return\n\n        current = self.root\n        parent = None\n        while current:\n            parent = current\n            if key  current.key:\n                current = current.left\n            elif key > current.key:\n                current = current.right\n            else:\n                return # Duplicate found, do nothing\n\n        new_node = Node(key, parent)\n        if key  parent.key:\n            parent.left = new_node\n        else:\n            parent.right = new_node\n\n    def delete(self, key):\n        \"\"\"Public delete method with decision logic.\"\"\"\n        h = self.get_height_iterative()\n        \n        if h = self.L:\n            self.root = self._delete_recursive(self.root, key)\n        else:\n            self.fallback_used = True\n            self._delete_iterative(key)\n\n    def _delete_recursive(self, node, key):\n        if not node:\n            return None\n\n        if key  node.key:\n            node.left = self._delete_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_recursive(node.right, key)\n        else: # Node to be deleted is found\n            if not node.left:\n                temp = node.right\n                if temp:\n                    temp.parent = node.parent\n                return temp\n            elif not node.right:\n                temp = node.left\n                if temp:\n                    temp.parent = node.parent\n                return temp\n            \n            successor = self._find_min_iterative(node.right)\n            node.key = successor.key\n            node.right = self._delete_recursive(node.right, successor.key)\n        \n        # After any recursive change, fix parent pointers of children\n        if node.left:\n            node.left.parent = node\n        if node.right:\n            node.right.parent = node\n        \n        return node\n    \n    def _transplant(self, u, v):\n        \"\"\"Replaces subtree rooted at u with subtree at v.\"\"\"\n        if not u.parent:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        if v:\n            v.parent = u.parent\n\n    def _delete_iterative(self, key):\n        node_to_delete = self._search_iterative(key)\n        if not node_to_delete:\n            return\n\n        if not node_to_delete.left:\n            self._transplant(node_to_delete, node_to_delete.right)\n        elif not node_to_delete.right:\n            self._transplant(node_to_delete, node_to_delete.left)\n        else:\n            successor = self._find_min_iterative(node_to_delete.right)\n            if successor.parent != node_to_delete:\n                self._transplant(successor, successor.right)\n                successor.right = node_to_delete.right\n                successor.right.parent = successor\n            \n            self._transplant(node_to_delete, successor)\n            successor.left = node_to_delete.left\n            successor.left.parent = successor\n            \n    def _find_min_iterative(self, node):\n        while node.left:\n            node = node.left\n        return node\n    \n    def in_order_traversal(self):\n        \"\"\"Returns a list of keys in in-order.\"\"\"\n        result = []\n        self._in_order_recursive(self.root, result)\n        return result\n\n    def _in_order_recursive(self, node, result):\n        if node:\n            self._in_order_recursive(node.left, result)\n            result.append(node.key)\n            self._in_order_recursive(node.right, result)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": 100,\n            \"initial\": [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15],\n            \"ops\": [('search', 7), ('delete', 8), ('insert', 16), ('delete', 2), ('search', 100)]\n        },\n        {\n            \"L\": 40,\n            \"initial\": list(range(1, 61)),\n            \"ops\": [('search', 60), ('insert', 61), ('delete', 1), ('delete', 61), ('search', 30)]\n        },\n        {\n            \"L\": 5,\n            \"initial\": [],\n            \"ops\": [('search', 10), ('delete', 10), ('insert', 10), ('search', 10), ('delete', 10)]\n        },\n        {\n            \"L\": 20,\n            \"initial\": list(range(1, 21)),\n            \"ops\": [('search', 20)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        bst = BST(case[\"L\"])\n        last_search_result = False\n\n        # Build initial tree\n        for key in case[\"initial\"]:\n            bst.insert(key)\n\n        # Apply operations\n        for op_type, key in case[\"ops\"]:\n            if op_type == 'search':\n                last_search_result = bst.search(key)\n            elif op_type == 'insert':\n                bst.insert(key)\n            elif op_type == 'delete':\n                bst.delete(key)\n        \n        H = bst.get_height_iterative()\n        F = bst.fallback_used\n        S = last_search_result\n        I = bst.in_order_traversal()\n        \n        all_results.append([H, F, S, I])\n\n    # Format the final output string\n    # Python's str() on a list gives a representation like '[item1, item2]', which matches the required format.\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3219097"}]}