{"hands_on_practices": [{"introduction": "递归思想的核心在于将一个复杂问题分解为更小、更易于处理的子问题。硬币找零问题 ([@problem_id:3213512]) 是一个经典的例子，它完美地展示了如何通过“包含”与“不包含”某一元素的策略来划分问题空间，从而构建出清晰的递归关系。通过解决这个问题，你将掌握递归分解的基本技巧。", "problem": "你需要设计并实现一个递归过程，用于计算在不考虑顺序的情况下，使用无限数量的各种面额硬币凑成一个非负整数总额的不同方式的数量。设 $S$ 是一个包含 $m$ 个正整数的数组，代表硬币面额；设 $n$ 为目标总和。该计数函数必须基于组合枚举和递归分解的基本原理，并且必须正确处理所有能防止无限递归并确保正确性的基準情况。\n\n形式上，定义一个函数 $count(S, m, n)$，它返回由 $S$ 中前 $m$ 种硬币组成、总和为 $n$ 的不同多重集的数量。仅因同一多重集硬币的排序不同而产生的两种表示方式必须被视为相同（例如，使用硬币 $[1,2,2]$ 和 $[2,1,2]$ 没有区别）。每种面额的硬币可以使用任意非负次数。\n\n你的设计必须从组合计数的基本定义出发，并且必须使用一个将解空间划分为不相交子问题的递归步骤。该函数必须实现以下基准情况并证明其合理性：\n- $n = 0$ 应返回 $1$，对应于使用空多重集这一种凑成零的有效方式。\n- $n  0$ 应返回 $0$，因为由正数面额组成的多重集不可能加总得到一个负数目标。\n- 当 $m \\le 0$ 且 $n > 0$ 时，应返回 $0$，因为在没有可用硬币类型的情况下，无法凑成一个正数总和。\n\n你的程序必须使用与这些基准情况一致的递归方法来实现 $count(S, m, n)$，并采用一个源自组合计数原理且逻辑上合理的递归步骤。实现中不得依赖任何非递归的捷径；任何优化都必须保留其递归结构。\n\n不涉及物理单位、角度或百分比。所有输出均为整数。\n\n测试套件：\n按给定的确切顺序，为以下参数集计算 $count(S, m, n)$：\n- 情况 1：$S = [2, 3, 5, 6]$，$m=4$，$n=10$。\n- 情况 2：$S = [2, 3, 5, 6]$，$m=4$，$n=0$。\n- 情况 3：$S = [2, 3]$，$m=0$，$n=7$。\n- 情况 4：$S = [1, 2, 3]$，$m=3$，$n=4$。\n- 情况 5：$S = [1, 2, 5]$，$m=2$，$n=5$。\n- 情况 6：$S = [2]$，$m=1$，$n=-5$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为测试套件各案例的结果，并严格按顺序排列（例如，[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$,$r_6$]，其中每个 $r_i$ 是案例 $i$ 的整数结果）。", "solution": "用户提供的问题是组合枚举和算法设计中的一个经典练习，通常被称为硬币找零问题（或整数划分问题的一个变体）。任务是构建一个递归函数 $count(S, m, n)$，用以计算使用数组 $S$ 中给定的前 $m$ 种硬币面额凑成总和 $n$ 的不同方式的数量。该问题要求一个从基本原理出发构建的解决方案，特别是要用到递归分解和对指定基准情况的显式处理。\n\n递归解决方案的设计基于将一个问题的解空间划分为一系列更小的、不相交子问题的原则。那么，解的总数就是这些子问题解的和。令 $C(m, n)$ 表示函数 $count(S, m, n)$，代表使用集合 $\\{S[0], S[1], \\dots, S[m-1]\\}$ 中的硬币凑成总和 $n$ 的方式数量。\n\n递归步骤的核心是考虑可用集合中的最后一种硬币，即 $S[m-1]$（假设数组 $S$ 使用从零开始的索引）。凑成总和 $n$ 的每一种可能方式，要么至少使用一次该硬币，要么完全不使用它。这两个类别是互斥且穷尽的，从而构成了对解空间的完美划分。\n\n1.  **不包含第 $m$ 种硬币 ($S[m-1]$) 的解：** 如果我们决定不使用硬币 $S[m-1]$，问题就简化为仅使用剩下的 $m-1$ 种硬币（即 $\\{S[0], \\dots, S[m-2]\\}$）来凑成总和 $n$。根据定义，实现这一点的方式数量为 $C(m-1, n)$。\n\n2.  **至少包含一次第 $m$ 种硬币 ($S[m-1]$) 的解：** 如果我们确定至少使用一次硬币 $S[m-1]$，我们可以先拿出一枚这样的硬币。需要凑成的剩余总和为 $n - S[m-1]$。这个剩余总和必须使用可用集合中的硬币来凑成。由于硬币可无限次重复使用，所以可用的硬币集合仍然是 $\\{S[0], \\dots, S[m-1]\\}$。因此，凑成这个剩余总和的方式数量为 $C(m, n - S[m-1])$。\n\n根据组合学的加法法则，使用前 $m$ 种硬币凑成总和 $n$ 的总方式数，是这两个不相交集合中解的数量之和。这就得出了以下基本递推关系：\n$$\nC(m, n) = C(m-1, n) + C(m, n - S[m-1])\n$$\n\n这个递推关系必须由能够终止递归的基准情况来确定。问题陈述中提供了这些基准情况，其合理性证明如下：\n\n-   **基准情况 1：$n = 0$**\n    函数必须返回 $1$。目标总和为 $0$ 可以通过一种方式精确实现：即不选择任何硬币（空多重集）。无论可用的硬币是什么，这一点都成立，因此对于任何 $m \\ge 0$ 都有 $C(m, 0) = 1$。\n\n-   **基准情况 2：$n  0$**\n    函数必须返回 $0$。使用均为正整数的面额不可能湊成一个负数总和。这种情况通常在递归步骤中减去一个比剩余目标 $n$ 更大的硬币值 $S[m-1]$ 时达到。因此，对于 $n  0$ 有 $C(m, n) = 0$。\n\n-   **基准情况 3：$m \\le 0$ 且 $n > 0$**\n    函数必须返回 $0$。如果没有可用的硬币（$m \\le 0$）而目标总和为正（$n > 0$），则不可能凑成该总和。这种情况在递归步骤 $C(m-1, n)$ 将 $m$ 递减至零时达到。条件 $n > 0$ 至关重要，因为 $n=0$ 的情况具有优先权。\n\n结合递推关系和基准情况，可以得出 $count(S, m, n)$ 的完整递归算法：\n1.  如果 $n = 0$，返回 $1$。\n2.  如果 $n  0$，返回 $0$。\n3.  如果 $m \\le 0$ 且 $n > 0$，返回 $0$。\n4.  否则，返回 $count(S, m-1, n) + count(S, m, n - S[m-1])$。\n\n这个表述正确地实现了基于基本原理的要求逻辑，并满足了问题陈述的所有条件。实现部分将把这一逻辑直接转化为一个递归的 Python 函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count(S, m, n):\n    \"\"\"\n    Recursively counts the number of ways to form the sum n using the first m coins from S.\n\n    Args:\n        S (list[int]): The array of coin denominations.\n        m (int): The number of coin types to consider from the start of S.\n        n (int): The target sum.\n\n    Returns:\n        int: The number of distinct ways to make the sum.\n    \"\"\"\n    # Base Case 1: If the target sum is 0, there is one solution (the empty set).\n    if n == 0:\n        return 1\n\n    # Base Case 2: If the target sum is negative, no solution is possible.\n    if n  0:\n        return 0\n\n    # Base Case 3: If there are no coins (m = 0) and the sum is positive (n > 0),\n    # no solution is possible.\n    if m = 0 and n > 0:\n        return 0\n\n    # Recursive Step:\n    # The total number of solutions is the sum of two disjoint sets:\n    # 1. Solutions that do not include the m-th coin (S[m-1]).\n    #    This is count(S, m - 1, n).\n    # 2. Solutions that include at least one m-th coin (S[m-1]).\n    #    This is count(S, m, n - S[m-1]).\n    # Note that S is 0-indexed, so the m-th coin is at index m-1.\n    return count(S, m - 1, n) + count(S, m, n - S[m - 1])\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the coin change problem.\n    \"\"\"\n    # The test cases are defined as tuples of (S, m, n).\n    test_cases = [\n        # Case 1: S = [2,3,5,6], m = 4, n = 10\n        ([2, 3, 5, 6], 4, 10),\n        # Case 2: S = [2,3,5,6], m = 4, n = 0\n        ([2, 3, 5, 6], 4, 0),\n        # Case 3: S = [2,3], m = 0, n = 7\n        ([2, 3], 0, 7),\n        # Case 4: S = [1,2,3], m = 3, n = 4\n        ([1, 2, 3], 3, 4),\n        # Case 5: S = [1,2,5], m = 2, n = 5\n        ([1, 2, 5], 2, 5),\n        # Case 6: S = [2], m = 1, n = -5\n        ([2], 1, -5)\n    ]\n\n    results = []\n    for S, m, n in test_cases:\n        result = count(S, m, n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3213512"}, {"introduction": "在掌握了如何用递归进行计数后，我们可以进一步学习如何用它来生成所有可能的解。字符串全排列问题 ([@problem_id:3213530]) 要求我们系统地构建出所有可能的排列组合，这展示了递归在探索解空间时的强大能力。处理重复字符的额外挑战，则突出了在每次递归调用中精确管理状态的重要性。", "problem": "要求你实现并论证一个纯递归算法，该算法通过重复选择一个字符作为首字符来生成给定字符串的所有排列。该算法必须遵循以下递归形式：基准情形是当输入字符串长度为 $1$ 时，递归步骤通过固定一个首字符并对剩余字符进行递归，从长度为 $n-1$ 的解构造出长度为 $n$ 的解。你还必须正确处理包含重复字符的输入字符串，以确保生成的排列是唯一的，并且不能使用非递归的全局去重方法。\n\n基本依据和约束条件：\n- 设 $s$ 是一个非空的小写英文字母字符串，且 $|s| = n$。\n- 该算法必须通过对 $n$ 的结构递归来定义：\n  - 基准情形：如果 $n = 1$，返回仅包含 $s$ 的列表。\n  - 递归步骤：如果 $n \\ge 2$，对于每个索引 $i$（$0 \\le i  n$），选择字符 $s_i$ 作为首字符，递归地生成移除了第 $i$ 个字符后的剩余字符串 $s$ 的所有排列，并将 $s_i$ 前置到每个子排列的前面。\n- 为确保在 $s$ 含有重复字符时排列的唯一性，在每次递归调用中，你必须避免在当前调用深度多次选择相同的首字符。这必须通过跟踪在当前深度已使用过的首字符并跳过重复项来实现。不要使用库中的排列工具或迭代算法来替代该递归结构。\n- 该函数必须生成排列；然而，为了可测试性，你的程序应仅输出为每个测试用例生成的唯一排列的数量。\n\n输入规范：\n- 没有外部输入。你必须在程序中硬编码下述测试套件。\n\n输出规范：\n- 对于测试套件中的每个测试用例，计算你的递归算法产生的唯一排列的数量，并按顺序收集这些计数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如，“[1,2,3]”。列表元素必须是整数。\n\n测试套件：\n- 按顺序使用以下字符串作为测试用例，以检验一般行为、基准情形以及对重复字符的处理：\n  - $s_1 = \\text{\"a\"}$。\n  - $s_2 = \\text{\"ab\"}$。\n  - $s_3 = \\text{\"aba\"}$。\n  - $s_4 = \\text{\"abcd\"}$。\n  - $s_5 = \\text{\"aabb\"}$。\n  - $s_6 = \\text{\"aaa\"}$。\n\n覆盖性设计：\n- $s_1$ 检查基准情形 $n=1$。\n- $s_2$ 检查一个所有字符都不同的最小非平凡情形。\n- $s_3$ 检查当一个字符重复时唯一性控制是否正确。\n- $s_4$ 检查一个所有字符都不同的较大数据规模情形。\n- $s_5$ 检查具有更复杂去重需求的多个重复字符情形。\n- $s_6$ 检查所有字符都相同的极端情形。\n\n你的任务：\n- 严格遵循基准情形 $n=1$ 和选择首字符的递归步骤，实现递归排列生成器，并在每个深度跳过重复的首字符选择。\n- 将其应用于测试套件，计算每个用例的唯一排列数量，并以要求的格式打印计数列表。", "solution": "该问题已经过分析，被认为是有效的。这是一个在算法和计算机科学领域中定义明确、自成体系且有科学依据的问题。问题陈述清晰、客观，并为构建唯一且可验证的解提供了所有必要信息。\n\n任务是实现一个纯递归算法，用以生成字符串 $s$ 的所有唯一排列，该字符串可能包含重复字符。唯一性必须在递归生成过程中强制执行，而不是通过后处理。该算法的核心由其递归结构指定。\n\n设 $P(s)$ 为生成长度为 $n = |s|$ 的字符串 $s$ 的唯一排列集合的函数。该算法通过对 $n$ 的结构递归来定义。\n\n**基准情形：**\n对于长度 $n = 1$ 的字符串 $s$，只有一个排列：字符串本身。\n$$P(s) = \\{s\\}, \\quad \\text{如果 } |s| = 1$$\n例如，$P(\\text{\"a\"}) = \\{\\text{\"a\"}\\}$。排列的数量是 $1$。\n\n**递归步骤：**\n对于长度 $n \\ge 2$ 的字符串 $s$，通过从 $s$ 中选择每个唯一的字符作为新排列的首字符来构建排列集合。对于每个这样的唯一首字符，我们递归地生成剩余字符的排列，并将所选的首字符前置到它们前面。\n\n为了正确处理重复字符并避免生成重复的排列，我们必须确保在任何给定的递归层级，我们不会用相同的首字符多次启动递归子问题。我们可以通过维护一个集合来实现这一点，该集合记录在当前递归调用中已选作首字符的字符。\n\n设 $s = s_0s_1\\dots s_{n-1}$。设 $U$ 是一个集合，用于跟踪在当前递归深度已被选为首字符的字符。初始时，$U$ 为空。我们从索引 $i=0$到 $n-1$ 遍历 $s$。\n\n对于每个索引 $i$：\n1. 设候选首字符为 $c = s_i$。\n2. 检查 $c$ 是否已在集合 $U$ 中。\n   - 如果 $c \\in U$，我们已在此深度处理过该字符作为首字符。我们跳过本次迭代以避免冗余计算和重复结果。\n   - 如果 $c \\notin U$，我们继续。将 $c$ 添加到 $U$（即，$U := U \\cup \\{c\\}$）。\n3. 通过从 $s$ 中移除字符 $s_i$ 来构造剩余子串 $s'$。这可以表示为 $s' = s_0\\dots s_{i-1}s_{i+1}\\dots s_{n-1}$。\n4. 对剩余字符串递归调用排列函数：$P(s')$。\n5. 对于返回的集合 $P(s')$ 中的每个排列 $p$，通过前置 $c$ 形成新的排列：$c \\cdot p$。\n6. 收集所有由 $c$ 的唯一选择生成的此类排列。\n\n$P(s)$ 的最终结果是为每个唯一首字符生成的所有排列的并集：\n$$P(s) = \\bigcup_{c \\in \\text{unique_chars}(s)} \\{c \\cdot p \\mid p \\in P(s' \\text{ 其中 } s' \\text{ 是 } s \\text{ 移除一个 } c \\text{ 实例后的字符串})\\}$$\n\n让我们跟踪 $s = \\text{\"aba\"}$（其中 $n=3$）的执行过程。\n$P(\\text{\"aba\"})$：\n- 初始化 $U = \\emptyset$。\n- **迭代 $i=0$**：$c = s_0 = \\text{'a'}$。因为 $\\text{'a'} \\notin U$，将其加入：$U = \\{\\text{'a'}\\}$。\n  - 剩余字符串为 $s' = \\text{\"ba\"}$。\n  - 递归调用 $P(\\text{\"ba\"})$。\n    - $P(\\text{\"ba\"})$ 将生成 $\\{\\text{\"ba\"}, \\text{\"ab\"}\\}$。\n  - 将 $\\text{'a'}$ 前置到每个排列前：$\\{\\text{\"aba\"}, \\text{\"aab\"}\\}$。\n- **迭代 $i=1$**：$c = s_1 = \\text{'b'}$。因为 $\\text{'b'} \\notin U$，将其加入：$U = \\{\\text{'a'}, \\text{'b'}\\}$。\n  - 剩余字符串为 $s' = \\text{\"aa\"}$。\n  - 递归调用 $P(\\text{\"aa\"})$。\n    - $P(\\text{\"aa\"})$：初始化 $U' = \\emptyset$。\n      - 迭代 $i=0$：$c' = \\text{'a'}$。加入到 $U'$。剩余部分是 $\\text{\"a\"}$。$P(\\text{\"a\"})$ 返回 $\\{\\text{\"a\"}\\}$。前置 $c'$ 得到 $\\{\\text{\"aa\"}\\}$。\n      - 迭代 $i=1$：$c' = \\text{'a'}$。因为 $\\text{'a'} \\in U'$，跳过。\n    - $P(\\text{\"aa\"})$ 返回 $\\{\\text{\"aa\"}\\}$。\n  - 将 $\\text{'b'}$ 前置到每个排列前：$\\{\\text{\"baa\"}\\}$。\n- **迭代 $i=2$**：$c = s_2 = \\text{'a'}$。因为 $\\text{'a'} \\in U$，跳过。\n- 最终的排列集合是所有有效迭代结果的并集：$\\{\\text{\"aba\"}, \\text{\"aab\"}\\} \\cup \\{\\text{\"baa\"}\\} = \\{\\text{\"aba\"}, \\text{\"aab\"}, \\text{\"baa\"}\\}$。\n- 唯一排列的数量是 $3$。\n\n这个计数与多重集排列的组合公式相符。如果一个长度为 $n$ 的字符串有 $k$ 个不同字符，其重数分别为 $n_1, n_2, \\dots, n_k$（其中 $\\sum_{j=1}^{k} n_j = n$），则唯一排列的数量由多项式系数给出：\n$$\n\\frac{n!}{n_1! n_2! \\dots n_k!}\n$$\n\n让我们根据此公式验证测试用例：\n- $s_1 = \\text{\"a\"}$：$n=1, n_a=1$。数量 = $\\frac{1!}{1!} = 1$。\n- $s_2 = \\text{\"ab\"}$：$n=2, n_a=1, n_b=1$。数量 = $\\frac{2!}{1!1!} = 2$。\n- $s_3 = \\text{\"aba\"}$：$n=3, n_a=2, n_b=1$。数量 = $\\frac{3!}{2!1!} = \\frac{6}{2} = 3$。\n- $s_4 = \\text{\"abcd\"}$：$n=4$。不同字符。数量 = $\\frac{4!}{1!1!1!1!} = 24$。\n- $s_5 = \\text{\"aabb\"}$：$n=4, n_a=2, n_b=2$。数量 = $\\frac{4!}{2!2!} = \\frac{24}{4} = 6$。\n- $s_6 = \\text{\"aaa\"}$：$n=3, n_a=3$。数量 = $\\frac{3!}{3!} = 1$。\n\n所描述的算法通过递归正确地实现了这一组合原理。在每个深度使用的‘已用字符’集合可防止递归树中出现冗余分支，这等效于在组合公式中除以重复字符计数的阶乘。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the number of unique permutations for a given\n    set of test strings using a specified recursive algorithm.\n    \"\"\"\n\n    def get_unique_permutations(s: str) - list[str]:\n        \"\"\"\n        Generates all unique permutations of a string using a recursive approach.\n\n        The algorithm adheres to the specified recursive structure:\n        - Base Case: If the string length is 1, return the string itself.\n        - Recursive Step: For each unique character in the string, fix it as the\n          first character, and recursively find all permutations of the remaining\n          characters. Prepend the fixed character to each of these sub-permutations.\n\n        Uniqueness is handled by tracking which characters have been used as the\n        first character at each level of the recursion to avoid redundant computations.\n\n        Args:\n            s: The input string.\n\n        Returns:\n            A list of unique permutation strings.\n        \"\"\"\n        # Base case: if |s| = 1, there is only one permutation.\n        # This matches the problem specification.\n        n = len(s)\n        if n == 1:\n            return [s]\n\n        # Recursive step: for |s| = 2.\n        result_permutations = []\n        \n        # used_first_chars tracks characters already chosen to be first at this depth.\n        # This is the key to ensuring uniqueness without global deduplication.\n        used_first_chars = set()\n\n        for i in range(n):\n            first_char = s[i]\n            \n            # If this character has already been used as a starting point at this\n            # level of recursion, skip it to prevent duplicate permutations.\n            if first_char in used_first_chars:\n                continue\n            \n            # Mark this character as used for this recursion depth.\n            used_first_chars.add(first_char)\n\n            # Construct the remaining string by removing the character at index i.\n            remaining_s = s[:i] + s[i+1:]\n\n            # Recursively find all permutations of the remaining substring.\n            sub_permutations = get_unique_permutations(remaining_s)\n\n            # Prepend the current first_char to each sub-permutation and add to results.\n            for p in sub_permutations:\n                result_permutations.append(first_char + p)\n                \n        return result_permutations\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        \"a\",      # s_1: Base case n=1\n        \"ab\",     # s_2: Simple distinct case\n        \"aba\",    # s_3: Repeated character\n        \"abcd\",   # s_4: Larger distinct case\n        \"aabb\",   # s_5: Multiple repeated characters\n        \"aaa\",    # s_6: All characters identical\n    ]\n\n    results = []\n    for s_test in test_cases:\n        # The problem asks for the *count* of unique permutations.\n        permutations = get_unique_permutations(s_test)\n        count = len(permutations)\n        results.append(count)\n\n    # Final print statement must be in the exact required format.\n    # e.g., \"[1,2,3,24,6,1]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution.\nsolve()\n```", "id": "3213530"}, {"introduction": "虽然递归是一个强大的工具，但朴素的递归实现有时会面临性能陷阱，尤其是在子问题大量重叠时。单词拆分问题 ([@problem_id:3213661]) 就是一个典型的例子，其朴素解法会导致指数级的时间复杂度。通过这个练习，你将学会识别并解决重叠子问题，并掌握“记忆化”这一关键优化技术，为理解动态规划铺平道路。", "problem": "您需要实现一个单词拆分决策问题的递归解法，该解法基于字符串递归的原则。设字母表表示为 $\\Sigma$，字典是一个有限集 $\\mathcal{D} \\subseteq \\Sigma^{\\ast}$，输入字符串为 $s \\in \\Sigma^{\\ast}$。递归设计必须基于以下基本概念：每个字符串 $s$ 都可以分解为一个前缀 $p$ 和一个后缀 $t$，使得 $s = p \\cdot t$；空字符串表示为 $\\epsilon$；递归在严格变短的后缀上进行，直到达到 $\\epsilon$。基本情况是当 $s = \\epsilon$ 时。递归步骤检查字典中的单词 $w \\in \\mathcal{D}$ 是否为 $s$ 的前缀，如果是，则对其相应的后缀 $t$ 进行递归。\n\n对于任何 $s \\in \\Sigma^{\\ast}$，相对于 $\\mathcal{D}$ 定义以下两个量：\n- 分词计数 $C(s)$，即将 $s$ 拆分为一个来自 $\\mathcal{D}$ 的单词序列，且该序列连接起来等于 $s$ 的不同方式的数量。\n- 最小单词数 $M(s)$，即使用 $\\mathcal{D}$ 对 $s$ 进行任何有效分词所需的最少单词数量。约定如果没有有效分词，则 $M(s) = -1$。\n\n您的程序必须为每个测试用例计算三个输出：\n- 一个布尔值 $B(s)$，指示是否存在至少一个有效分词。即，当且仅当 $C(s)  0$ 时 $B(s)$ 为 $\\text{True}$，否则为 $\\text{False}$。\n- 整数 $C(s)$。\n- 整数 $M(s)$。\n\n递归必须遵守以下设计约束：\n- 基本情况：对于 $s = \\epsilon$，$C(\\epsilon) = 1$ 且 $M(\\epsilon) = 0$。\n- 递归步骤：对于 $s \\neq \\epsilon$，考虑所有 $w \\in \\mathcal{D}$ 使得 $w$ 是 $s$ 的前缀。对于每个这样的 $w$，令后缀为 $t$ 满足 $s = w \\cdot t$，并对 $t$ 进行递归。对于 $C(s)$，将所有有效前缀的贡献相加。对于 $M(s)$，取所有允许有效分词的后缀 $t$ 的 $1 + M(t)$ 的最小值。如果没有有效前缀能导向一个有效分词，则 $C(s) = 0$ 且 $M(s) = -1$。\n- 使用记忆化以避免对重叠子问题的冗余重复计算，从而确保递归在 $|s|$ 和 $|\\mathcal{D}|$ 的多项式时间内运行。说明保证递归终止并确保其良基性的度量。\n\n测试套件。您的程序必须为以下测试用例集计算结果，每个测试用例都是一个对 $(s, \\mathcal{D})$：\n- 情况 1：$s = \\text{\"catsanddog\"}$，$\\mathcal{D} = \\{\\text{\"cat\"}, \\text{\"cats\"}, \\text{\"and\"}, \\text{\"sand\"}, \\text{\"dog\"}\\}$。\n- 情况 2：$s = \\text{\"\"}$ (空字符串)，$\\mathcal{D} = \\{\\text{\"a\"}\\}$。\n- 情况 3：$s = \\text{\"abc\"}$，$\\mathcal{D} = \\{\\text{\"ab\"}, \\text{\"ac\"}\\}$。\n- 情况 4：$s = \\text{\"leetcode\"}$，$\\mathcal{D} = \\{\\text{\"leet\"}, \\text{\"code\"}, \\text{\"leetcode\"}\\}$。\n- 情况 5：$s = \\text{\"aaaaaaa\"}$，$\\mathcal{D} = \\{\\text{\"a\"}, \\text{\"aa\"}, \\text{\"aaaa\"}\\}$。\n\n输出规范。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身是一个形式为 $[\\;B(s),\\;C(s),\\;M(s)\\;]$ 的列表。例如，输出格式必须为 $[\\,[\\;B(s_1),C(s_1),M(s_1)\\;],\\,[\\;B(s_2),C(s_2),M(s_2)\\;],\\ldots\\,]$。本问题不涉及物理单位，也没有角度或百分比。", "solution": "该问题要求实现一个递归算法来解决单词拆分问题，并增加了计算可能的分词数量和查找有效分词中最少单词数的功能。该解法必须采用记忆化以实现多项式时间性能。\n\n解法的核心是一个递归函数，它作用于给定的字符串 $s \\in \\Sigma^{\\ast}$ 和字典 $\\mathcal{D} \\subseteq \\Sigma^{\\ast}$。该函数计算三个量：一个布尔值 $B(s)$，指示是否存在有效分词；一个整数 $C(s)$，表示不同分词的总数；以及一个整数 $M(s)$，表示分词中的最小单词数。\n\n递归结构通过将字符串 $s$ 分解为一个前缀 $w$ 和一个后缀 $t$ 来定义，使得 $s = w \\cdot t$。递归过程是找到 $s$ 的所有存在于字典 $\\mathcal{D}$ 中的前缀 $w$，然后对相应的后缀 $t$ 递归地解决问题。\n\n递归关系和基本情况正式定义如下：\n\n设 $s$ 为输入字符串，$\\mathcal{D}$ 为字典。\n\n基本情况：对于空字符串 $s = \\epsilon$：\n- 空字符串被认为是其自身的有效分词，包含零个单词。\n- 对空字符串进行分词的方式数量为 $1$：$C(\\epsilon) = 1$。\n- 此分词中的最小单词数为 $0$：$M(\\epsilon) = 0$。\n- 由于 $C(\\epsilon)  0$，存在分词：$B(\\epsilon) = \\text{True}$。\n\n递归步骤：对于非空字符串 $s \\neq \\epsilon$：\n通过考虑所有作为 $s$ 前缀的单词 $w \\in \\mathcal{D}$ 来计算这些量。对于每个这样的 $w$，我们找到相应的后缀 $t$（其中 $s = w \\cdot t$），并对 $t$ 进行递归调用。\n\n1.  分词计数，$C(s)$：$s$ 的总分词数是所有可能的后缀 $t$ 的分词数之和，这些后缀是通过从 $s$ 中剥离一个有效的字典单词前缀 $w$ 得到的。\n    $$\n    C(s) = \\sum_{w \\in \\mathcal{D} \\mid s \\text{ starts with } w} C(s[|w|..])\n    $$\n    其中 $s[|w|..]$ 表示从 $s$ 中移除长度为 $|w|$ 的前缀 $w$ 后的后缀。如果不存在这样的 $w$，则和为空，且 $C(s) = 0$。\n\n2.  最小单词数，$M(s)$：$s$ 的最小单词数是其所有可有效分词的后缀的最小单词数中的最小值加一。\n    $$\n    M(s) = \\min \\{1 + M(t) \\mid s = w \\cdot t, w \\in \\mathcal{D}, C(t) > 0\\}\n    $$\n    如果这样的后缀 $t$ 的集合为空（即，没有前缀 $w \\in \\mathcal{D}$ 能导向一个可以被分词的后缀 $t$），则 $s$ 不存在有效分词。在这种情况下，我们遵守约定 $M(s) = -1$。\n\n3.  分词存在性，$B(s)$：此布尔值直接由分词计数确定。\n    $$\n    B(s) = (C(s) > 0)\n    $$\n\n终止性与良基性：递归保证终止。确保终止的度量是字符串的长度 $|s|$，它是一个非负整数。每次递归调用都是对 $s$ 的一个后缀 $t$进行的，其对应的前缀 $w$ 是字典中的一个词，因此是非空的。这意味着 $|t|  |s|$。一个非负整数的严格递减序列必须是有限的。因此，该递归是良基的，并且总会在 $|s| = 0$（即 $s = \\epsilon$）的基本情况处终止。\n\n记忆化：由于对相同子串多次重复计算结果（重叠子问题），朴素的递归实现将具有指数时间复杂度。为了优化这一点，我们使用记忆化，这是动态规划的一种典型技术。一个缓存（例如，哈希映射）存储每个已处理子串 $s'$ 的结果 $(B(s'), C(s'), M(s'))$。在为任何字符串 $s'$ 计算结果之前，会检查缓存。如果结果存在，则立即返回。否则，继续进行计算，并将新计算出的结果在返回前存入缓存。这确保了每个唯一后缀的子问题只被解决一次。时间复杂度变为多项式级别，在一个直接的实现中，大约与 $|s|^2 \\cdot |\\mathcal{D}|$ 成正比，或者更精确地说，由子问题的数量（$s$ 的每个后缀对应一个子问题，共 $|s|+1$ 个）乘以每个子问题的工作量（遍历 $\\mathcal{D}$）决定。\n\n算法实现：设计一个单一的递归函数来计算三元组 $(B(s), C(s), M(s))$，以避免对递归树的冗余遍历。\n- 该函数接受字符串 $s$、字典 $\\mathcal{D}$ 和记忆化缓存作为参数。\n- 它首先检查缓存中是否有 $s$。如果找到，则返回缓存的值。\n- 然后它检查基本情况 $s = \\epsilon$，如果为真，则返回 $(\\text{True}, 1, 0)$。\n- 对于递归步骤，它将 `total_count` 初始化为 $0$，将 `min_words` 初始化为一个代表无穷大的值（例如 `float('inf')`）。\n- 它遍历 $\\mathcal{D}$ 中的每个单词 $w$。如果 $w$ 是 $s$ 的前缀，它会对后缀 $t$ 进行递归调用。\n- 如果对 $t$ 的递归调用返回的结果表明存在有效分词（即 $B(t)$ 为 True），它会聚合结果：`total_count` 增加 $C(t)$，`min_words` 更新为 $\\min(\\text{min\\_words}, 1 + M(t))$。\n- 在检查完所有前缀后，如果 `total_count` 仍为 $0$，则表示没有找到分词。$s$ 的结果为 $(\\text{False}, 0, -1)$。\n- 否则，结果为 $(\\text{True}, \\text{total\\_count}, \\text{min\\_words})$。\n- 最后，这个结果被存储在 $s$ 的缓存中并返回。\n这种集成方法通过单一、高效的递归过程正确计算了所有三个所需的量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        (\"catsanddog\", {\"cat\", \"cats\", \"and\", \"sand\", \"dog\"}),\n        (\"\", {\"a\"}),\n        (\"abc\", {\"ab\", \"ac\"}),\n        (\"leetcode\", {\"leet\", \"code\", \"leetcode\"}),\n        (\"aaaaaaa\", {\"a\", \"aa\", \"aaaa\"}),\n    ]\n\n    results = []\n    for s, word_dict in test_cases:\n        memo = {}\n        b_s, c_s, m_s = _solve_recursive(s, word_dict, memo)\n        results.append([b_s, c_s, m_s])\n\n    # Final print statement in the exact required format.\n    # str() on a list gives a good representation, e.g., \"[True, 2, 3]\"\n    # However, the spec requires \"[ True, 2, 3 ]\", so we format it manually.\n    formatted_results = []\n    for res in results:\n        # Convert boolean to lowercase 'true'/'false' as often seen in JSON-like contexts\n        # The problem sample shows `[ B(s), C(s), M(s) ]` with True/False capitalized\n        # so str(bool) is correct. A space is also requested.\n        formatted_results.append(f\"[{res[0]}, {res[1]}, {res[2]}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _solve_recursive(s: str, word_dict: set, memo: dict):\n    \"\"\"\n    Recursively solves the word break problem with memoization.\n\n    Args:\n        s (str): The input string to segment.\n        word_dict (set): The dictionary of valid words.\n        memo (dict): The memoization cache.\n\n    Returns:\n        tuple[bool, int, int]: A tuple containing (B(s), C(s), M(s)).\n            - B(s): True if a segmentation exists, False otherwise.\n            - C(s): The number of distinct valid segmentations.\n            - M(s): The minimum number of words in a segmentation (-1 if none).\n    \"\"\"\n    if s in memo:\n        return memo[s]\n\n    # Base case: The empty string has one segmentation (the empty one)\n    # with zero words.\n    if not s:\n        # C(epsilon) = 1, M(epsilon) = 0\n        return True, 1, 0\n\n    total_count = 0\n    min_words = float('inf')\n\n    # Recursive step: Iterate through all dictionary words as potential prefixes.\n    for word in word_dict:\n        if s.startswith(word):\n            suffix = s[len(word):]\n            \n            # Recurse on the suffix.\n            b_suffix, c_suffix, m_suffix = _solve_recursive(suffix, word_dict, memo)\n\n            # If the suffix can be segmented, aggregate the results.\n            if b_suffix:\n                # Add the number of segmentations of the suffix.\n                total_count += c_suffix\n                \n                # Update the minimum words count for the current string.\n                min_words = min(min_words, 1 + m_suffix)\n\n    # After checking all possible prefixes, finalize the result for s.\n    if total_count == 0:\n        # No valid segmentation found for s.\n        result = (False, 0, -1)\n    else:\n        # A valid segmentation was found.\n        result = (True, total_count, int(min_words))\n    \n    # Cache the result before returning.\n    memo[s] = result\n    return result\n\n# Execute the solution.\nsolve()\n```", "id": "3213661"}]}