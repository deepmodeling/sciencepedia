{"hands_on_practices": [{"introduction": "本练习将探讨位运算与集合论之间的基本对应关系。通过逐位分析掩码分区问题，您将建立解决许多位掩码问题的核心直觉：将复杂问题分解为每个位的独立选择。这个练习能加深您对简单位运算规则如何扩展以解决复杂组合问题的理解。[@problem_id:3217117]", "problem": "给定一个非负整数掩码 $M$。将一个掩码解释为其标准二进制表示中 $1$-位的位置集合，因此 $M$ 的子掩码是任何一个其 $1$-位位置集合为 $M$ 的 $1$-位位置集合之子集的非负整数。两个掩码 $A$ 和 $B$ 被视为一个有序对 $(A,B)$。仅使用集合运算和位掩码的基本定义，确定 $M$ 的子掩码所构成的有序对 $(A,B)$ 的确切数量，使得 $A$ 和 $B$ 的 $1$-位位置集合满足 $A \\cap B = \\emptyset$ 且 $A \\cup B = M$。为具体起见，设 $M$ 为十六进制数 $\\mathrm{1F3A7C}$ 所表示的整数。请给出确切的整数答案，不要四舍五入。", "solution": "问题要求计算满足以下条件的非负整数有序对 $(A,B)$ 的数量：$A$ 和 $B$ 是给定掩码 $M$ 的子掩码，并且满足条件 $A \\cap B = \\emptyset$ 和 $A \\cup B = M$。问题陈述，这些掩码应被解释为其 $1$-位的位置集合。\n\n设 $S_M$ 为 $M$ 的二进制表示中值为 $1$ 的比特位的位置集合。$A$ 和 $B$ 是 $M$ 的子掩码这一条件，等价于说它们对应的 $1$-位位置集合 $S_A$ 和 $S_B$ 是 $S_M$ 的子集。即，$S_A \\subseteq S_M$ 且 $S_B \\subseteq S_M$。\n\n问题给出的条件是：\n$1$. $A \\cap B = \\emptyset$：这意味着 $A$ 的 $1$-位位置集合与 $B$ 的 $1$-位位置集合不相交。用集合符号表示为 $S_A \\cap S_B = \\emptyset$。对于整数本身，用位运算表示，这等价于 $(A \\text{ AND } B) = 0$。\n$2$. $A \\cup B = M$：这意味着 $A$ 和 $B$ 的 $1$-位位置集合的并集等于 $M$ 的 $1$-位位置集合。用集合符号表示为 $S_A \\cup S_B = S_M$。用位运算表示，这等价于 $(A \\text{ OR } B) = M$。\n\n$S_A \\cup S_B = S_M$ 和 $S_A \\cap S_B = \\emptyset$ 这两个集合论条件共同意味着集合 $S_A$ 和 $S_B$ 构成了集合 $S_M$ 的一个划分。我们的任务是计算这种集合有序对 $(S_A, S_B)$ 的数量。\n\n让我们逐位分析这些约束条件。考虑任意整数 $i \\ge 0$ 的第 $i$ 个比特位。\n\n情况1：$M$ 的第 $i$ 位是 $0$。\n由于 $A$ 和 $B$ 必须是 $M$ 的子掩码，它们的第 $i$ 位也必须是 $0$。这是因为 $S_A \\subseteq S_M$ 且 $S_B \\subseteq S_M$，所以如果 $i \\notin S_M$，那么必然有 $i \\notin S_A$ 且 $i \\notin S_B$。对于这个比特位，条件是满足的：$(A \\text{ OR } B)$ 的第 $i$ 位是 $0 \\text{ OR } 0 = 0$，与 $M$ 相匹配；$(A \\text{ AND } B)$ 的第 $i$ 位是 $0 \\text{ AND } 0 = 0$，与空交集一致。对于任何这样的比特位，$A$ 和 $B$ 中对应的比特只有一种可能的选择（它们都必须是 $0$）。\n\n情况2：$M$ 的第 $i$ 位是 $1$。\n这意味着 $i \\in S_M$。\n条件 $S_A \\cup S_B = S_M$ 意味着对于这个位置 $i$，我们必须有 $i \\in S_A$ 或 $i \\in S_B$。\n条件 $S_A \\cap S_B = \\emptyset$ 意味着 $i$ 不能同时在 $S_A$ 和 $S_B$ 中。\n结合这两个要求，对于 $M$ 中值为 $1$ 的每个比特位 $i$，$A$ 或 $B$ 中必须有且仅有一个在该位置上为 $1$。这为每个这样的比特位提供了两种可能性：\na) $A$ 的第 $i$ 位是 $1$，$B$ 的第 $i$ 位是 $0$。\nb) $A$ 的第 $i$ 位是 $0$，$B$ 的第 $i$ 位是 $1$。\n\n由于每个比特位的选择独立于所有其他比特位的选择，总的有序对 $(A,B)$ 数量可以通过将每个比特位的选择数相乘得到。\n设 $N$ 为 $M$ 二进制表示中 $1$-位的数量。这也被称为 $M$ 的 population count 或汉明权重。对于 $M$ 中值为 $1$ 的 $N$ 个比特位中的每一个，都有 $2$ 种可能的方式将该位分配给 $A$ 或 $B$。对于所有其他值为 $0$ 的比特位，只有 $1$ 种选择（$A$ 和 $B$ 的该位都必须是 $0$）。\n\n因此，有序对 $(A,B)$ 的总数是 $2^N$。\n\n问题给出了 $M$ 的一个具体十六进制值：$M = \\mathrm{1F3A7C}_{16}$。我们必须计算其二进制表示中 $1$-位的数量 $N$。我们将每个十六进制数字转换为其等效的 $4$ 位二进制数：\n- $1_{16} = 0001_2$ (包含 $1$ 个 1)\n- $F_{16} = 1111_2$ (包含 $4$ 个 1)\n- $3_{16} = 0011_2$ (包含 $2$ 个 1)\n- $A_{16} = 1010_2$ (包含 $2$ 个 1)\n- $7_{16} = 0111_2$ (包含 $3$ 个 1)\n- $C_{16} = 1100_2$ (包含 $2$ 个 1)\n\n$M$ 的二进制表示是 $0001\\ 1111\\ 0011\\ 1010\\ 0111\\ 1100_2$。\n$1$-位的总数 $N$ 是每个十六进制数字中 $1$-位的数量之和：\n$N = 1 + 4 + 2 + 2 + 3 + 2 = 14$。\n\n有序对 $(A,B)$ 的总数是 $2^N = 2^{14}$。\n我们计算这个值：\n$2^{10} = 1024$\n$2^{14} = 2^4 \\times 2^{10} = 16 \\times 1024$\n$16 \\times 1024 = 16 \\times (1000 + 24) = 16000 + 16 \\times 24 = 16000 + 384 = 16384$。\n\n因此，恰好有 $16384$ 个这样的有序对 $(A,B)$。", "answer": "$$\\boxed{16384}$$", "id": "3217117"}, {"introduction": "位掩码不仅能表示集合，更是紧凑表示系统状态的强大工具。此问题挑战您将一个状态转换谜题建模为图上的最短路径问题。您将学习如何使用位掩码作为图的顶点，使用按位异或（XOR）操作作为边，并应用广度优先搜索（BFS）等经典算法来找到最优解。[@problem_id:3217223]", "problem": "给定一个初始位掩码 $m$、一个目标位掩码 $g$ 以及一个由切换掩码 $t_i$（其中 $i \\in \\{1,2,\\dots,k\\}$）组成的有限列表。一次切换操作将按位异或 (XOR) 应用于当前掩码：如果当前掩码为 $x$，应用切换掩码 $t_i$ 会将其转换为 $x \\oplus t_i$。所有掩码都限制在固定的位宽 $B$ 内，这意味着只考虑最低的 $B$ 位，并且所有操作都在集合 $\\{0,1,\\dots,2^B-1\\}$ 内进行。\n\n构建一个程序，确定将 $m$ 转换为 $g$ 所需的最少切换操作次数，如果通过任何切换序列都无法从 $m$ 到达 $g$，则返回 $-1$。您的程序必须生成单行输出，该输出是一个用方括号括起来的逗号分隔列表，汇总了给定测试套件的结果。\n\n推理必须从基本定义和事实出发：\n- 按位异或 (XOR)，记作 $\\oplus$，是按位定义的，使用模 $2$ 加法且不带进位。对于位宽为 $B$ 的任意位掩码 $a$ 和 $b$，$a \\oplus b$ 是一个掩码，其在位位置 $j \\in \\{0,1,\\dots,B-1\\}$ 上的位为 $(a_j + b_j) \\bmod 2$。\n- XOR 遵循代数性质：$a \\oplus a = 0$，$a \\oplus 0 = a$，交换律 $a \\oplus b = b \\oplus a$，以及结合律 $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$。在 $\\oplus$ 运算下，每个元素都是自身的逆元。\n- 在无权图上进行的广度优先搜索 (BFS) 会按路径长度的非递减顺序探索顶点，因此能找到从源点到任何可达顶点的最短路径。\n\n将可达的掩码建模为一个无权有向图的顶点，其顶点集为 $V = \\{0,1,\\dots,2^B-1\\}$。当且仅当存在某个切换掩码 $t_i$ 使得 $y = x \\oplus t_i$ 时，才存在一条从 $x$ 到 $y$ 的边。问题要求的是在该图中，从顶点 $m$ 开始到顶点 $g$ 的最短路径长度。如果从 $m$ 无法到达 $g$，则答案为 $-1$。\n\n输入协议由下面的测试套件固定；您的程序不得读取任何外部输入。最终输出格式必须是单行，包含一个整数列表，表示每个测试用例的最小切换次数，格式严格为 $[r_1,r_2,\\dots,r_n]$，不含空格。\n\n测试套件（每个用例是一个四元组 $(B,m,g,\\{t_i\\})$）：\n- 用例 1：$B = 8$，$m = 26$，$g = 229$，$\\{t_i\\} = [160,39,255,91]$。\n- 用例 2：$B = 8$，$m = 123$，$g = 123$，$\\{t_i\\} = [5,7,200]$。\n- 用例 3：$B = 8$，$m = 0$，$g = 4$，$\\{t_i\\} = [1,2]$。\n- 用例 4：$B = 8$，$m = 42$，$g = 40$，$\\{t_i\\} = [0,5,5,7]$。\n- 用例 5：$B = 4$，$m = 0$，$g = 11$，$\\{t_i\\} = [1,2,4,8]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4,r_5]$。期望的输出是整数；对于不可达的目标，输出 $-1$。", "solution": "所述问题是有效的。它在科学上基于有限域数学和图论，问题阐述清晰，目标明确，没有歧义或矛盾。所有必要信息均已在测试套件中提供。因此，我们可以着手解决。\n\n问题要求找到将初始位掩码 $m$ 转换为目标位掩码 $g$ 所需的最小切换操作次数。这是一个典型的无权图上的最短路径问题。可以通过首先将问题形式化为图论模型，然后应用合适的搜索算法来系统地推导出解决方案。\n\n首先，我们来定义状态空间的结构。固定位宽 $B$ 的所有可能位掩码的集合构成了图的顶点集 $V$，其中 $V = \\{0, 1, \\dots, 2^B - 1\\}$。一次操作包括从给定列表 $\\{t_1, t_2, \\dots, t_k\\}$ 中应用一个切换掩码 $t_i$。切换的效果由按位异或 (XOR) 运算定义，记为 $\\oplus$。如果当前掩码为 $x$，应用切换掩码 $t_i$ 会得到一个新掩码 $x' = x \\oplus t_i$。\n\n这种变换定义了我们图的边。如果存在一个切换掩码 $t_i$ 使得 $v = u \\oplus t_i$，那么在两个顶点（掩码）$u$ 和 $v$ 之间就存在一条边。XOR 运算是其自身的逆运算，即 $(u \\oplus t_i) \\oplus t_i = u \\oplus (t_i \\oplus t_i) = u \\oplus 0 = u$。这意味着如果存在一条从 $u$ 到 $v$ 的边，那么也存在一条从 $v$ 到 $u$ 的边。因此，该图是无向的。每条边代表一次切换操作，所以该图是无权的。因此，问题等价于寻找从起始顶点 $m$ 到目标顶点 $g$ 的最短路径长度。\n\n在无权图中寻找最短路径最适合的算法是广度优先搜索 (BFS)。BFS 逐层系统地探索图，保证能以最少的边数发现到任何可达顶点的路径。\n\n另一种视角揭示了其底层的代数结构。一个包含 $L$ 次切换操作的序列 $t_{i_1}, t_{i_2}, \\dots, t_{i_L}$ 将 $m$ 转换为 $g$ 的过程如下：\n$$ g = m \\oplus t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L} $$\n根据 XOR 的结合律和交换律，我们可以重新排列这个表达式。将表达式两边与 $m$ 进行异或运算，得到：\n$$ m \\oplus g = (m \\oplus m) \\oplus (t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L}) $$\n$$ m \\oplus g = 0 \\oplus (t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L}) $$\n令 $D = m \\oplus g$ 为“差异掩码”。问题等价于从集合 $\\{t_i\\}$ 中找出能异或得到 $D$ 的最少数量的切换掩码。这将问题重新定义为寻找从零掩码 $0$ 到掩码 $D$ 的最短路径。这是一个在二元域 $\\mathbb{F}_2$ 上的向量空间问题。虽然这个观点在概念上很优雅，但无论是从 $m$ 搜索 $g$ 还是从 $0$ 搜索 $D$，BFS 算法仍然是实用的解决方法。我们将坚持从 $m$ 搜索到 $g$ 的直接表述。\n\nBFS 算法的流程如下：\n$1.$ 初始化一个队列来管理待访问的顶点。队列将存储形如 $(mask, distance)$ 的元组。将起始状态 $(m, 0)$ 加入队列。\n$2.$ 初始化一个集合或布尔数组 `visited`，以跟踪已入队的掩码。这对于防止循环和冗余计算至关重要。将 $m$ 添加到 `visited` 集合中。\n$3.$ 如果 $m=g$，则距离为 $0$。这个平凡情况由初始状态处理。\n$4.$ 当队列不为空时，循环执行：\n    a. 出队当前状态 `(current_mask, current_dist)`。\n    b. 对于所提供列表中的每个唯一的切换掩码 $t_j$：\n        i. 计算 `next_mask` 为 `current_mask` $\\oplus$ $t_j$。\n        ii. 如果 `next_mask` 是目标 $g$，则已找到最短路径。其长度为 `current_dist` $+ 1$。算法可以终止并返回此值。\n        iii. 如果 `next_mask` 尚未被访问过，则将其添加到 `visited` 集合中，并以新的距离入队：`(next_mask, current_dist + 1)`。\n$5.$ 如果队列变空而目标 $g$ 仍未找到，这意味着 $g$ 与 $m$ 不在图的同一个连通分量中。因此，$g$ 是不可达的。在这种情况下，函数应返回 $-1$。\n\n输入列表 $\\{t_i\\}$ 中的重复切换掩码不会增加新的转换，可以被筛选成一个唯一集合。值为 $0$ 的切换也是一个有效的操作，对应于一个自环 ($x \\oplus 0 = x$)，`visited` 集合可以正确处理这种情况。\n\n这种基于 BFS 的方法为解决给定参数 $B$、$m$、$g$ 和 $\\{t_i\\}$ 的问题提供了一个完整且正确的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef find_min_toggles(B, m, g, toggles):\n    \"\"\"\n    Determines the minimum number of toggle operations to transform mask m into g.\n\n    This function models the problem as a shortest path search on an unweighted graph\n    of possible bit masks. Vertices are the masks, and an edge exists between two masks\n    if one can be transformed into the other by a single toggle operation (XOR).\n    Breadth-First Search (BFS) is used to find the shortest path from m to g.\n\n    Args:\n        B (int): The bit-width of the masks. All masks are in the range [0, 2**B - 1].\n        m (int): The initial bit mask.\n        g (int): The target bit mask.\n        toggles (list[int]): A list of toggle masks.\n\n    Returns:\n        int: The minimum number of operations, or -1 if g is unreachable from m.\n    \"\"\"\n    # If the start and target masks are the same, 0 operations are needed.\n    if m == g:\n        return 0\n\n    # Use a set of unique toggles to avoid redundant computations.\n    # A toggle of 0 results in a self-loop (x -> x ^ 0 = x) and does not help\n    # reach new states, so it can be safely ignored.\n    unique_toggles = {t for t in toggles if t != 0}\n\n    # The queue for BFS stores tuples of (mask, distance_from_m).\n    # Initialize with the starting mask and a distance of 0.\n    queue = collections.deque([(m, 0)])\n\n    # A set to keep track of visited masks to avoid cycles and redundant exploration.\n    visited = {m}\n\n    # Perform the BFS.\n    while queue:\n        current_mask, dist = queue.popleft()\n\n        # Explore all possible next states from the current mask.\n        for t in unique_toggles:\n            next_mask = current_mask ^ t\n\n            # If the next mask is the target, we have found the shortest path.\n            if next_mask == g:\n                return dist + 1\n\n            # If the next mask has not been visited, add it to the queue and visited set.\n            if next_mask not in visited:\n                visited.add(next_mask)\n                queue.append((next_mask, dist + 1))\n\n    # If the queue is exhausted and the target was not found, it is unreachable.\n    return -1\n\ndef solve():\n    \"\"\"\n    Solves the problem for the suite of test cases provided in the prompt.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: B=8, m=26, g=229, {t_i}=[160,39,255,91]\n        (8, 26, 229, [160, 39, 255, 91]),\n        # Case 2: B=8, m=123, g=123, {t_i}=[5,7,200]\n        (8, 123, 123, [5, 7, 200]),\n        # Case 3: B=8, m=0, g=4, {t_i}=[1,2]\n        (8, 0, 4, [1, 2]),\n        # Case 4: B=8, m=42, g=40, {t_i}=[0,5,5,7]\n        (8, 42, 40, [0, 5, 5, 7]),\n        # Case 5: B=4, m=0, g=11, {t_i}=[1,2,4,8]\n        (4, 0, 11, [1, 2, 4, 8]),\n    ]\n\n    results = []\n    for B, m, g, toggles in test_cases:\n        result = find_min_toggles(B, m, g, toggles)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217223"}, {"introduction": "现在，我们将位掩码的应用提升到解决具有深刻代数结构的问题上。这个经典的“开关灯”谜题揭示了位运算与二元域 $GF(2)$ 上线性代数之间惊人的联系。通过将谜题表示为线性方程组，您将练习使用高效的位运算来实现高斯消元法，这项技术不仅限于解决谜题，更广泛应用于纠错码等领域。[@problem_id:3217249]", "problem": "给定 $N$ 个电灯开关和 $N$ 个灯泡。开关 $i$ 可以切换一组灯泡的状态。这个子集由一个十进制非负整数掩码 $m_i$ 表示，其中最低有效位（位 $0$）对应灯泡 $1$，位 $1$ 对应灯泡 $2$，以此类推，位 $j$ 对应灯泡 $j+1$。切换操作是模 $2$ 累加的：按下一个开关会翻转其对应子集中每个灯泡的状态；按同一个开关两次等于没有按。\n\n你的目标是按下一系列开关，使得从所有灯泡都关闭的状态开始，最终只有灯泡 $1$ 是亮的。按动开关的顺序无关紧要，因为切换操作在模 $2$ 加法下是可交换的。因此，任何解都可以表示为一个二进制决策向量 $x \\in \\{0,1\\}^N$，其中当且仅当开关 $i$ 被按了奇数次时，$x_i = 1$。设 $A \\in \\{0,1\\}^{N \\times N}$ 是一个矩阵，其元素 $A_{j,i} = 1$ 当且仅当开关 $i$ 切换灯泡 $j$ 的状态，否则 $A_{j,i} = 0$。设 $b \\in \\{0,1\\}^N$ 是目标向量，其中 $b_1 = 1$ 且对于所有 $j \\neq 1$，$b_j = 0$。你必须求解在二元有限域（GF($2$)）上的以下线性方程组\n$$\nA x = b \\quad \\text{over GF}(2).\n$$\n如果方程组无解，你必须指出其不可能性。如果方程组至少有一个解，由于自由变量的存在，可能会有多个解。在这种情况下，你必须返回通过在 GF($2$) 上使用固定的列顺序 $1,2,\\dots,N$ 进行高斯消元，并将所有自由变量设置为 $0$ 所得到的规范解。\n\n你的程序必须：\n- 通过设置 $A_{j,i} = 1$ 当且仅当 $m_i$ 的第 $(j-1)$ 位为 $1$，从掩码 $m_i$ 构建 $A$。\n- 使用对应于按位异或（exclusive OR，记作 XOR，等于模 $2$ 加法）的行操作，在 GF($2$) 上求解 $A x = b$。\n- 如果无解，则为该测试用例输出空列表。\n- 如果有解，则输出按下的开关索引序列，该序列是一个按升序排列的、以 $1$ 为基准的整数列表，对应于规范解中所有 $x_i=1$ 的索引 $i$。\n\n你可以无需证明直接使用的基本事实：\n- 位的布尔代数规则，包括异或（XOR）是可结合和可交换的，以及对于任何位 $a$，$a \\oplus a = 0$。\n- GF($2$) 上线性方程组的性质，以及使用行交换和行异或的高斯消元法会保留解集。\n- 将一个 $N$ 位的向量表示为一个非负整数掩码，等同于将这些位打包成该整数的二进制表示。\n\n使用位掩码将增广矩阵的行表示为整数，并使用位运算进行行操作来实现你的解法。\n\n测试套件：\n- 测试用例 $1$：$N = 5$，掩码 $[13,22,19,26,21]$。\n- 测试用例 $2$：$N = 4$，掩码 $[1,2,7,4]$。\n- 测试用例 $3$：$N = 1$，掩码 $[1]$。\n- 测试用例 $4$：$N = 3$，掩码 $[2,4,6]$。\n- 测试用例 $5$：$N = 5$，掩码 $[0,1,0,0,0]$。\n\n输出规格：\n- 对于每个测试用例，输出一个以 $1$ 为基准的、按升序排列的开关索引列表，表示为达到仅灯泡 $1$ 亮起状态而需要按下的开关，使用上述的规范解。如果不可能，则为该测试用例输出空列表 $[]$。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，按给定顺序排列，形式为一个逗号分隔的列表，并用方括号括起来，不含空格。每个元素是单个测试用例的列表。例如，如果有三个测试用例，一个有效的输出格式是 $[[1,3],[],[2]]$。", "solution": "该问题要求在二元有限域 GF($2$) 上求解一个线性方程组 $A x = b$。该系统由 $N$ 个开关和 $N$ 个灯泡定义，其中每个开关对灯泡的作用由一个整数掩码给出。目标是找到一组要按下的开关（由向量 $x \\in \\{0,1\\}^N$ 表示），使得从所有灯泡都关闭的状态开始，最终只有第一个灯泡被点亮。\n\n首先，我们必须通过为方程组 $Ax=b$ 构建增广矩阵 $[A|b]$ 来将问题形式化。设 $N$ 为开关和灯泡的数量。矩阵 $A$ 是一个 $N \\times N$ 矩阵，其中当开关 $i$ 切换灯泡 $j$ 的状态时，条目 $A_{j,i}$ 为 $1$，否则为 $0$。问题说明，掩码 $m_i$ 的第 $k$ 位对应于灯泡 $k+1$。因此，如果掩码 $m_i$ 的第 $(j-1)$ 位为 $1$，则 $A_{j,i} = 1$。这意味着 $A$ 的第 $i$ 列是掩码 $m_i$ 的向量表示。目标状态向量 $b$ 是 $[1, 0, \\dots, 0]^T$，表示只有灯泡 $1$ 是亮的。\n\n为了高效地求解该方程组，我们采用 GF($2$) 上的高斯消元法，其中加法是按位异或（XOR）运算，乘法是按位与（AND）运算。问题指定将增广矩阵的行表示为整数并使用位运算。增广矩阵 $[A|b]$ 的一行有 $N+1$ 个元素。我们可以将第 $j$ 行 $[A_{j,1}, \\dots, A_{j,N}, b_j]$ 表示为单个整数。我们使用位 $0, \\dots, N-1$ 来存储 $x_1, \\dots, x_N$ 的系数（即 $A$ 的各列对应的元素），并使用位 $N$ 来存储增广部分 $b_j$。矩阵 $A$ 的第 $j$ 行（对于 $j=1, \\dots, N$）是通过从每个给定的掩码 $m_1, \\dots, m_N$ 中取其第 $(j-1)$ 位来构建的。\n\n使用高斯消元法的求解过程包括两个主要阶段：\n\n1.  **前向消元**：增广矩阵被转换为行阶梯形矩阵。我们遍历列 $j=0, \\dots, N-1$ 和行 $i=0, \\dots, N-1$。对于每一列 $j$，我们在行 $k \\geq i$ 中寻找一个主元（一个 $1$）。如果找到主元，我们将第 $k$ 行与第 $i$ 行交换，并使用新的主元行，通过将其与列 $j$ 中有 $1$ 的任何其他行进行异或操作，来消除该列中主元下方的所有 $1$。这个过程确定了主元列（对应于基本变量）和非主元列（对应于自由变量）。\n\n2.  **一致性检查和回代**：前向消元后，我们检查不一致性。如果任何行形如 $[0, \\dots, 0 | 1]$，则方程组无解。这对应于等于 $2^N$ 的整数表示。如果方程组是一致的，我们按照规定找到规范解：所有自由变量都设置为 $0$。然后我们使用回代法，从最后一个主元行开始向上求解基本（主元）变量。对于对应于主元变量 $x_p$ 的主元行 $i$，方程的形式为 $x_p \\oplus \\bigoplus_{kp, k \\text{ 为列索引}} c_k x_k = b'_i$。由于对于 $kp$ 的变量 $x_k$ 已经确定（或者是自由变量并设置为 $0$），我们可以解出 $x_p$ 为 $x_p = b'_i \\oplus \\bigoplus_{kp} c_k x_k$。\n\n最终的解向量 $x$ 指示了要按下哪些开关。输出是一个排序后的、以 $1$ 为基准的开关索引 $i$ 的列表，其中 $x_i=1$。如果不存在解，则返回一个空列表。\n\n让我们用一个例子来说明：$N=3$，掩码 $m=[2,4,6]$。\n$m_1=2=(010)_2$, $m_2=4=(100)_2$, $m_3=6=(110)_2$。\n矩阵 $A$ 的列由这些掩码的位模式构成。\n$A = \\begin{pmatrix} 0  1  1 \\\\ 1  0  1 \\\\ 0  0  0 \\end{pmatrix}$。目标向量是 $b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n增广矩阵 $[A|b]$ 为 $\\begin{pmatrix} 0  1  1  |  1 \\\\ 1  0  1  |  0 \\\\ 0  0  0  |  0 \\end{pmatrix}$。\n我们交换第 $1$ 行和第 $2$ 行，以在左上角获得一个主元：$\\begin{pmatrix} 1  0  1  |  0 \\\\ 0  1  1  |  1 \\\\ 0  0  0  |  0 \\end{pmatrix}$。\n这已经是行阶梯形矩阵。主元列是第 $0$ 列和第 $1$ 列（对应 $x_1, x_2$）。$x_3$ 对应的列是自由列。\n该方程组是一致的。规范解将自由变量 $x_3$ 设置为 $0$。\n根据第 2 行：$x_2 \\oplus x_3 = 1 \\implies x_2 \\oplus 0 = 1 \\implies x_2=1$。\n根据第 1 行：$x_1 \\oplus x_3 = 0 \\implies x_1 \\oplus 0 = 0 \\implies x_1=0$。\n解为 $x=[0, 1, 0]$，意味着按下了开关 $2$。输出为 $[2]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (5, [13, 22, 19, 26, 21]),\n        (4, [1, 2, 7, 4]),\n        (1, [1]),\n        (3, [2, 4, 6]),\n        (5, [0, 1, 0, 0, 0]),\n    ]\n\n    results = []\n    for N, masks in test_cases:\n        result = solve_single_case(N, masks)\n        results.append(result)\n\n    # Format the final output string\n    # e.g., [[1,3,5],[1],[1],[2],[2]]\n    output_str = \"[\" + \",\".join(map(str, results)).replace(\" \", \"\") + \"]\"\n    print(output_str)\n\ndef solve_single_case(N, masks):\n    \"\"\"\n    Solves a single instance of the lights and switches problem.\n    Args:\n        N: The number of switches and bulbs.\n        masks: A list of integers representing the switch-bulb connections.\n    Returns:\n        A sorted list of 1-indexed switch numbers to press for the canonical solution,\n        or an empty list if no solution exists.\n    \"\"\"\n    \n    # Step 1: Construct the augmented matrix as a list of integers.\n    # Each integer represents a row. Bit i corresponds to variable x_{i+1} (column i).\n    # Bit N corresponds to the augmented part (vector b).\n    aug_matrix = [0] * N\n    for j in range(N):  # Corresponds to row j, for bulb j+1\n        row_mask = 0\n        for i in range(N):  # Corresponds to column i, for switch i+1\n            # A_{j,i} is 1 if switch i+1 toggles bulb j+1.\n            # This is given by the j-th bit of masks[i].\n            if (masks[i]  j)  1:\n                row_mask |= (1  i)\n\n        # The target vector b has b_1 = 1, b_j = 0 for j!=1.\n        # This affects the first row (j=0).\n        if j == 0:\n            row_mask |= (1  N)\n        \n        aug_matrix[j] = row_mask\n\n    # Step 2: Forward elimination to achieve row echelon form.\n    pivot_row = 0\n    pivot_cols = []\n    for j in range(N):  # Iterate through columns to find pivots\n        if pivot_row == N:\n            break\n        \n        # Find a row >= pivot_row with a 1 in the current column j\n        i = pivot_row\n        while i  N and (aug_matrix[i]  j)  1 == 0:\n            i += 1\n            \n        if i  N:  # A pivot is found at (i, j)\n            # Swap rows to bring the pivot to the diagonal position (pivot_row, j)\n            aug_matrix[pivot_row], aug_matrix[i] = aug_matrix[i], aug_matrix[pivot_row]\n            \n            pivot_val = aug_matrix[pivot_row]\n            \n            # Eliminate 1s below the pivot in the current column j\n            for k in range(pivot_row + 1, N):\n                if (aug_matrix[k]  j)  1:\n                    aug_matrix[k] ^= pivot_val\n            \n            pivot_cols.append(j)\n            pivot_row += 1\n\n    # Step 3: Check for inconsistency.\n    # This occurs if we have a row [0, 0, ..., 0 | 1].\n    for i in range(pivot_row, N):\n        if aug_matrix[i] == (1  N):\n            return []  # No solution\n\n    # Step 4: Back substitution to find the canonical solution.\n    # Free variables (non-pivot columns) are implicitly set to 0.\n    x = [0] * N\n    # Iterate backwards through the pivot rows\n    for i in range(pivot_row - 1, -1, -1):\n        pivot_col = pivot_cols[i]\n        row_val = aug_matrix[i]\n        \n        # Calculate the sum of terms involving already-determined variables\n        # The equation for this row is: x_{pivot_col} + sum_{k>pivot_col} c_k*x_k = b'\n        rhs_sum = 0\n        for k in range(pivot_col + 1, N):\n            if (row_val  k)  1:\n                rhs_sum ^= x[k]\n        \n        # The augmented bit for this row\n        b_val = (row_val  N)  1\n        \n        # Solve for x_{pivot_col}\n        x[pivot_col] = b_val ^ rhs_sum\n        \n    # Step 5: Format the output as a sorted list of 1-indexed switch numbers.\n    solution = []\n    for i in range(N):\n        if x[i] == 1:\n            solution.append(i + 1)\n            \n    return solution\n\nsolve()\n\n```", "id": "3217249"}]}