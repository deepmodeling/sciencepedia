{"hands_on_practices": [{"introduction": "学习如何构建递推关系是一项基本技能，它能将实际问题转化为数学模型。这个问题 [@problem_id:1395092] 旨在通过一个调度约束的场景，训练你将问题分解为更小、自相似子问题的核心思维。通过分析最后一个时间槽是否被占用这两种情况，你将练习构建递推关系的基本方法。", "problem": "一个系统管理员负责在 $n$ 个连续的时间段（标记为 $1, 2, \\dots, n$）内安排一系列维护作业。由于作业的性质和共享资源的限制，系统被配置为禁止在两个连续的时间段内安排作业。一个“有效调度”被定义为任何遵守此规则的、为维护而选择的时间段集合。这也包括不执行任何作业的可能性（即选择空的时间段集合）。\n\n设 $S_n$ 为 $n$ 个时间段内所有可能的不同有效调度的数量。对于 $n \\ge 2$，序列 $S_n$ 可以用一个二阶常整数系数的线性齐次递推关系来描述，其形式为 $S_n = c_1 S_{n-1} + c_2 S_{n-2}$。\n\n确定整数系数的有序对 $(c_1, c_2)$。", "solution": "设 $S_n$ 表示有效调度的数量（即集合 $\\{1,2,\\dots,n\\}$ 中没有两个连续元素的子集）。对于 $n \\geq 2$，考虑一个有效调度，并根据最后一个时间段 $n$ 是否被选中来进行分类讨论。\n\n如果 $n$ 未被选中，则所有的选择都在集合 $\\{1,2,\\dots,n-1\\}$ 中进行，且遵循相同的约束，因此有 $S_{n-1}$ 种可能性。\n\n如果 $n$ 被选中，则根据约束，$n-1$ 不能被选中，所以剩余的选择在集合 $\\{1,2,\\dots,n-2\\}$ 中进行，且遵循相同的约束，因此有 $S_{n-2}$ 种可能性。\n\n这两种情况是互斥且穷尽的，因此根据加法原理，\n$$\nS_n = S_{n-1} + S_{n-2}.\n$$\n这是一个二阶常整数系数的线性齐次递推关系。将其与 $S_n = c_{1} S_{n-1} + c_{2} S_{n-2}$ 进行匹配，可得\n$$\nc_{1} = 1,\\quad c_{2} = 1.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1  1\\end{pmatrix}}$$", "id": "1395092"}, {"introduction": "在建立递推关系之后，下一步是求解其闭式解，以便深入理解算法的效率。本练习 [@problem_id:3264331] 演示了“展开法”或“迭代法”，这是一种通过反复代入递推关系直至发现规律的强大技巧。你将看到如何利用对数的基本性质，将一个看似复杂的求和过程转化为一个简洁的阶乘表达式。", "problem": "一位工程师分析一个通过逐个插入 $n$ 个不同键来构建平衡搜索结构的递归过程。在一个理想化的成本模型中，由于路径遍历和局部再平衡，插入第 $k$ 个键精确执行 $\\log_{2} k$ 个原始步骤，其中 $k \\in \\{2,3,\\ldots,n\\}$。设 $T(n)$ 表示处理 $n$ 个键所需的原始步骤总数，基础情况为 $T(1) = 0$。通过将总成本建模为递归子问题的成本与在当前规模下所做工作的成本之和，该工程师得出了以下递推关系：\n$$\nT(n) = T(n-1) + \\log_{2} n \\quad \\text{for } n \\geq 2, \\quad T(1)=0.\n$$\n从算法分析的第一性原理（顺序组合意味着成本相加）、经过充分检验的对数性质（例如从乘法到加法的同态）以及阶乘函数的定义出发，推导出一个关于 $n$ 的显式函数作为 $T(n)$ 的闭式表达式，该表达式不包含求和符号和渐近记号。使用以 2 为底的对数。你的最终答案必须是关于 $n$ 的单个解析表达式。", "solution": "该问题要求为由以下递推关系定义的总成本 $T(n)$ 找到一个闭式表达式：\n$$\nT(n) = T(n-1) + \\log_{2} n \\quad \\text{for } n \\geq 2\n$$\n基础情况为 $T(1) = 0$。\n\n推导过程通过展开递推关系来进行。这种技术，也称为伸缩求和或迭代法，包括对较小的参数重复代入函数定义，直到达到基础情况。\n\n对于整数 $n \\geq 2$，我们可以写出：\n$$\nT(n) = T(n-1) + \\log_{2} n\n$$\n代入 $T(n-1) = T(n-2) + \\log_{2}(n-1)$ 的表达式，我们得到：\n$$\nT(n) = \\left( T(n-2) + \\log_{2}(n-1) \\right) + \\log_{2} n = T(n-2) + \\log_{2}(n-1) + \\log_{2} n\n$$\n对 $T(n-2)$、$T(n-3)$ 等继续这个代入过程，直到 $T(2)$：\n$$\nT(n) = T(n-3) + \\log_{2}(n-2) + \\log_{2}(n-1) + \\log_{2} n\n$$\n$$\n\\vdots\n$$\n$$\nT(n) = T(1) + \\log_{2}(2) + \\log_{2}(3) + \\ldots + \\log_{2}(n-1) + \\log_{2} n\n$$\n这可以用求和符号紧凑地表示为：\n$$\nT(n) = T(1) + \\sum_{k=2}^{n} \\log_{2} k\n$$\n问题指定了基础情况 $T(1) = 0$。将此值代入方程中，得到：\n$$\nT(n) = 0 + \\sum_{k=2}^{n} \\log_{2} k = \\sum_{k=2}^{n} \\log_{2} k\n$$\n问题要求一个不含求和符号的表达式，这需要利用对数的性质。对数的基本性质表明，对数之和等于其参数乘积的对数。对于一个公共底数 $b > 0$, $b \\neq 1$：\n$$\n\\sum_{i} \\log_{b}(x_i) = \\log_{b} \\left( \\prod_{i} x_i \\right)\n$$\n将此性质应用于我们关于 $T(n)$ 且底数 $b=2$ 的表达式：\n$$\nT(n) = \\log_{2}(2) + \\log_{2}(3) + \\ldots + \\log_{2}(n) = \\log_{2} \\left( 2 \\times 3 \\times \\ldots \\times n \\right)\n$$\n对数参数中的乘积是 $2 \\times 3 \\times \\ldots \\times n$。这个乘积与阶乘函数密切相关，阶乘函数对非负整数 $n$ 定义为：\n$$\nn! = \\prod_{k=1}^{n} k = 1 \\times 2 \\times 3 \\times \\ldots \\times n\n$$\n由于乘以 $1$ 不会改变乘积的值，我们有：\n$$\n2 \\times 3 \\times \\ldots \\times n = 1 \\times 2 \\times 3 \\times \\ldots \\times n = n!\n$$\n因此，我们可以用 $n!$ 代替对数内的乘积：\n$$\nT(n) = \\log_{2}(n!)\n$$\n这个表达式就是所要求的闭式解。它是 $n$ 的一个显式函数，不包含求和符号或渐近记号，并使用了指定的以 2 为底的对数。当寻求 $n$ 很大时的近似值时，这个结果可以通过斯特林公式（Stirling's formula）的对数形式来近似，但此处要求的答案是其精确形式 $\\log_{2}(n!)$。", "answer": "$$\\boxed{\\log_{2}(n!)}$$", "id": "3264331"}, {"introduction": "并非所有的递推关系都符合标准模式，对于更复杂的形式，我们需要运用高级技巧，例如变量替换。这个问题 [@problem_id:3264360] 提出了一个具有非标准结构的递推关系，引导你通过巧妙地重新定义输入变量，将其转化为一个更简单的形式。掌握这种方法是分析复杂算法时解决棘手问题的关键。", "problem": "在等价成本随机存取机（RAM）模型下，一个算法处理大小为 $n$ 的输入，在每个阶段，它将问题分解为 $\\sqrt{n}$ 个输入大小为 $\\sqrt{n}$ 的相似子问题，然后对 $n$ 个项目进行一次线性时间的合并/扫描。对于所有是2的幂的 $n$，这产生了一个形式为 $T(n) = \\sqrt{n}\\,T(\\sqrt{n}) + n$ 的时间复杂度递推关系。假设初始条件为 $T(2) = 6$。为了进行分析，将注意力限制在形式为 $n = 2^{2^{m}}$ 的输入上，其中 $m$ 是一个非负整数。从递推关系的基本定义出发，仅使用关于指数和对数的公认事实，推导出 $T(n)$ 作为 $m$ 和 $n$ 的函数的闭式解析表达式。请将最终答案表示为仅依赖于 $m$ 的单个闭式表达式（不含近似或不等式），并且不包含任何单位。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是算法分析领域中一个定义良好、有科学依据的问题。我们可以着手求解。\n\n问题给出了一个算法时间复杂度“$T(n)$”的递推关系：\n$$T(n) = \\sqrt{n}\\,T(\\sqrt{n}) + n$$\n该关系适用于大小为“$n$”且为“$2$”的幂的输入。分析进一步限制于特定形式“$n = 2^{2^{m}}$”，其中“$m$”是一个非负整数，即“$m \\in \\{0, 1, 2, \\dots\\}$”。给出的初始条件为“$T(2) = 6$”。\n\n指定的形式“$n = 2^{2^{m}}$”提示我们通过变量替换来简化递推关系。让我们针对“$n$”的这种特定结构，定义一个新函数“$f(m)$”来对应“$T(n)$”：\n$$f(m) = T(2^{2^{m}})$$\n“$m=0$”的基本情况对应于“$n = 2^{2^0} = 2^1 = 2$”。因此，初始条件转化为：\n$$f(0) = T(2) = 6$$\n现在，让我们用“$f(m)$”来表示原递推关系中的各项。在右侧，“$T$”的参数是“$\\sqrt{n}$”。对于“$n = 2^{2^{m}}$”，这变为：\n$$\\sqrt{n} = \\left(2^{2^{m}}\\right)^{1/2} = 2^{\\frac{1}{2} \\cdot 2^{m}} = 2^{2^{m-1}}$$\n因此，“$T(\\sqrt{n})$”对应于“$f(m-1)$”：\n$$T(\\sqrt{n}) = T(2^{2^{m-1}}) = f(m-1)$$\n将这些代入原递推关系“$T(n) = \\sqrt{n}\\,T(\\sqrt{n}) + n$”中，我们得到了一个关于“$f(m)$”的新递推关系：\n$$f(m) = \\left(2^{2^{m-1}}\\right) f(m-1) + 2^{2^m}$$\n这个递推关系看起来很复杂，但可以通过归一化来简化。我们将两边同除以“$2^{2^m}$”：\n$$\\frac{f(m)}{2^{2^m}} = \\frac{2^{2^{m-1}}}{2^{2^m}} f(m-1) + \\frac{2^{2^m}}{2^{2^m}}$$\n为了简化系数“$\\frac{2^{2^{m-1}}}{2^{2^m}}$”，我们使用指数性质“$a^x/a^y = a^{x-y}$”。在我们的例子中，指数分别是“$2^{m-1}$”和“$2^m$”。注意到“$2^m = 2 \\cdot 2^{m-1} = 2^{m-1} + 2^{m-1}$”。\n$$\\frac{2^{2^{m-1}}}{2^{2^m}} = 2^{2^{m-1} - 2^m} = 2^{2^{m-1} - (2 \\cdot 2^{m-1})} = 2^{-2^{m-1}} = \\frac{1}{2^{2^{m-1}}}$$\n将此代回到归一化后的递推关系中，得到：\n$$\\frac{f(m)}{2^{2^m}} = \\frac{1}{2^{2^{m-1}}} f(m-1) + 1$$\n$$\\frac{f(m)}{2^{2^m}} = \\frac{f(m-1)}{2^{2^{m-1}}} + 1$$\n这揭示了一个简单的结构。让我们定义一个新函数“$g(m)$”如下：\n$$g(m) = \\frac{f(m)}{2^{2^m}}$$\n于是“$g(m)$”的递推关系是一个简单的等差数列：\n$$g(m) = g(m-1) + 1$$\n这可以通过展开递推关系来求解：\n$$g(m) = g(m-1) + 1 = (g(m-2)+1) + 1 = g(m-2) + 2 = \\dots = g(0) + m$$\n为了求出“$g(0)$”，我们使用基本情况“$f(0) = 6$”：\n$$g(0) = \\frac{f(0)}{2^{2^0}} = \\frac{T(2)}{2^1} = \\frac{6}{2} = 3$$\n将这个值代回到“$g(m)$”的表达式中，我们得到“$g(m)$”的闭式解：\n$$g(m) = m + 3$$\n现在，我们必须进行反向代换以求出“$T(n)$”的表达式。首先，我们求出“$f(m)$”：\n$$f(m) = g(m) \\cdot 2^{2^m} = (m+3) \\cdot 2^{2^m}$$\n由于当“$n=2^{2^m}$”时，“$f(m) = T(n)$”，我们得到了“$T(n)$”作为“$m$”的函数的解：\n$$T(n)\\Big|_{n=2^{2^m}} = (m+3) 2^{2^m}$$\n问题要求将“$T(n)$”表示为“$m$”和“$n$”的函数。由于“$n = 2^{2^m}$”，我们可以将表达式写为：\n$$T(n) = (m+3) n$$\n此外，我们可以通过取对数将“$m$”用“$n$”表示。\n$$n = 2^{2^m} \\implies \\log_2(n) = 2^m \\implies \\log_2(\\log_2(n)) = m$$\n将此代入我们关于“$T(n)$”的表达式中，得到一个仅以“$n$”为变量的闭式解：\n$$T(n) = n (\\log_2(\\log_2(n)) + 3)$$\n最终答案要求是一个依赖于“$m$”的表达式。根据我们的推导“$f(m) = T(2^{2^m}) = (m+3) 2^{2^m}$”。", "answer": "$$ \\boxed{(m+3)2^{2^{m}}} $$", "id": "3264360"}]}