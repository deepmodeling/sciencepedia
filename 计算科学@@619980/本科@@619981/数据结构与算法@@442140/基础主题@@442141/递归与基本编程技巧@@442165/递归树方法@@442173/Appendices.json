{"hands_on_practices": [{"introduction": "递归树方法是分析分治算法复杂度的有力工具。通过将递归过程可视化，我们可以清晰地看到每一层递归所产生的代价。这个练习 [@problem_id:3265011] 将带你分析一个经典的分治递归关系，其特殊之处在于每层级的代价并非恒定，而是随着递归深度的增加而变化，最终引导我们求解一个有趣的级数和。", "problem": "您正在分析一个分治算法的运行时间，该算法对于大小为 $n$ 的输入，将问题分解为 $2$ 个大小为 $n/2$ 的子问题，并在进行递归调用前执行 $g(n)$ 单位的非递归工作。您希望整个递归树的总工作量为 $\\mathcal{O}\\left(n(\\ln n)^{2}\\right)$ 数量级。考虑 $g(n)=n\\ln n$ 这一具体选择，并定义递推关系\n$$\nT(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+n\\ln n,\\quad T(1)=0,\n$$\n并简化假设 $n$ 是 $2$ 的幂。使用第一性原理的递归树方法（计算每层的节点数和每个节点的工作量），推导出一个关于 $n$ 的 $T(n)$ 的精确封闭形式表达式。请将您的最终答案表示为关于 $n$ 的单个简化解析表达式。除非指明底数，否则所有对数均为自然对数。最终答案中请勿使用渐近符号。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n从问题陈述中逐字提取的已知条件如下：\n- 递推关系：$T(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+n\\ln n$\n- 基本情况：$T(1)=0$\n- 假设：$n$ 是 $2$ 的幂。\n- 方法：第一性原理的递归树方法。\n- 期望输出：$T(n)$ 的精确封闭形式表达式。\n- 对数约定：除非明确指出底数，否则所有对数均为自然对数，记为 $\\ln$。\n\n该陈述还包含一个上下文说明，即对于函数 $g(n)=n\\ln n$，总工作量预计为 $\\mathcal{O}\\left(n(\\ln n)^{2}\\right)$ 数量级。这可作为对最终结果进行渐近检查的指导。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学依据：**该问题是算法分析中的一个标准练习，这是计算机科学和离散数学的核心课题。该递推关系是分治算法的典型形式。所涉及的对象和操作在数学上是明确定义的。该问题具有科学合理性。\n- **适定性：**该问题是适定的。它提供了一个常系数线性递推关系、一个已定义的非齐次项 ($n\\ln n$) 和一个必要的基本情况 ($T(1)=0$)。$n$ 是 $2$ 的幂这一约束确保了 $T$ 的参数在整个递归过程中保持为整数，从而简化了分析。这些条件保证了唯一精确解的存在。\n- **客观性：**该问题以精确、形式化的数学语言陈述，没有任何主观性、模糊性或基于观点的主张。\n\n基于此分析，该问题没有任何科学或逻辑上的缺陷，是自洽的，且结构清晰明确。因此，它被判定为**有效**。\n\n### 第 3 步：结论与行动\n该问题有效。现在将推导完整的解。\n\n该问题要求在 $n$ 是 $2$ 的幂的假设下，根据基本情况 $T(1)=0$ 求解递推关系\n$$\nT(n)=2T\\left(\\frac{n}{2}\\right)+n\\ln(n)\n$$\n我们将按照规定使用递归树方法。\n\n递归树将递归调用的成本可视化。树中的每个节点代表为特定规模的子问题所执行的非递归工作。\n树的根节点对应于大小为 $n$ 的初始问题。根节点的非递归工作量为 $n\\ln(n)$。根节点有 $2$ 个子节点，每个子节点代表一个大小为 $n/2$ 的子问题。\n\n我们逐层分析这棵树。我们定义根节点在第 $i=0$ 层。\n- **第 $i=0$ 层**：有 $1=2^0$ 个节点，对应于大小为 $n/2^0 = n$ 的问题。该节点的工作量为 $n\\ln(n)$。该层的总工作量为 $1 \\cdot n\\ln(n) = n\\ln(n)$。\n- **第 $i=1$ 层**：有 $2=2^1$ 个节点，每个节点对应于大小为 $n/2^1 = n/2$ 的子问题。每个节点的工作量为 $(n/2)\\ln(n/2)$。该层的总工作量为 $2 \\cdot (n/2)\\ln(n/2) = n\\ln(n/2)$。\n- **第 $i$ 层**：通过归纳法，在深度为 $i$ 时，有 $2^i$ 个节点。每个节点对应于大小为 $n/2^i$ 的子问题。在每个这样的节点上执行的非递归工作量为 $(n/2^i)\\ln(n/2^i)$。第 $i$ 层的总工作量是节点数与每个节点工作量的乘积：\n$$\n\\text{Work}_{\\text{level } i} = 2^i \\cdot \\left(\\frac{n}{2^i}\\right) \\ln\\left(\\frac{n}{2^i}\\right) = n \\ln\\left(\\frac{n}{2^i}\\right)\n$$\n当子问题大小变为 $1$ 时，递归终止。设 $k$ 为树达到此状态时的深度。我们将子问题大小设为 $1$：\n$$\n\\frac{n}{2^k} = 1 \\implies n = 2^k \\implies k = \\log_2(n)\n$$\n由于我们假设 $n$ 是 $2$ 的幂，因此 $k$ 是一个整数。树共有 $k+1$ 层，索引从 $i=0$ 到 $i=k$。叶节点在第 $k$ 层。\n叶节点（第 $k$ 层）的工作量对应于基本情况 $T(1)$。问题陈述 $T(1)=0$，因此叶节点层的总工作量为 $2^k \\cdot T(1) = n \\cdot 0 = 0$。\n\n总工作量 $T(n)$ 是从根节点到叶节点前一层（即从 $i=0$ 到 $i=k-1$）所有层级工作量的总和。\n$$\nT(n) = \\sum_{i=0}^{k-1} \\text{Work}_{\\text{level } i} = \\sum_{i=0}^{\\log_2(n)-1} n \\ln\\left(\\frac{n}{2^i}\\right)\n$$\n现在我们可以计算这个总和。\n$$\nT(n) = n \\sum_{i=0}^{\\log_2(n)-1} \\left[ \\ln(n) - \\ln(2^i) \\right] = n \\sum_{i=0}^{\\log_2(n)-1} \\left[ \\ln(n) - i\\ln(2) \\right]\n$$\n为简化计算过程中的符号，我们代入 $k=\\log_2(n)$。\n$$\nT(n) = n \\sum_{i=0}^{k-1} (\\ln(n) - i\\ln(2))\n$$\n我们可以将求和分为两部分：\n$$\nT(n) = n \\left[ \\sum_{i=0}^{k-1} \\ln(n) - \\sum_{i=0}^{k-1} i\\ln(2) \\right] = n \\left[ \\ln(n) \\sum_{i=0}^{k-1} 1 - \\ln(2) \\sum_{i=0}^{k-1} i \\right]\n$$\n第一个和是 $k$ 个项的和：$\\sum_{i=0}^{k-1} 1 = k$。\n第二个和是等差数列的和：$\\sum_{i=0}^{k-1} i = \\frac{(k-1)k}{2}$。\n将这些结果代回 $T(n)$ 的表达式中：\n$$\nT(n) = n \\left[ k\\ln(n) - \\ln(2) \\frac{k(k-1)}{2} \\right]\n$$\n为了得到以 $n$ 表示的最终表达式，我们代入 $k = \\log_2(n)$。使用换底公式会很方便，即 $\\log_2(n) = \\frac{\\ln(n)}{\\ln(2)}$。\n$$\nT(n) = n \\left[ \\frac{\\ln(n)}{\\ln(2)} \\ln(n) - \\frac{\\ln(2)}{2} \\frac{\\ln(n)}{\\ln(2)} \\left(\\frac{\\ln(n)}{\\ln(2)} - 1\\right) \\right]\n$$\n$$\nT(n) = n \\left[ \\frac{(\\ln(n))^2}{\\ln(2)} - \\frac{\\ln(n)}{2} \\left(\\frac{\\ln(n) - \\ln(2)}{\\ln(2)}\\right) \\right]\n$$\n提出公因式 $\\frac{n}{\\ln(2)}$：\n$$\nT(n) = \\frac{n}{\\ln(2)} \\left[ (\\ln(n))^2 - \\frac{\\ln(n)}{2}(\\ln(n) - \\ln(2)) \\right]\n$$\n$$\nT(n) = \\frac{n}{\\ln(2)} \\left[ (\\ln(n))^2 - \\frac{1}{2}(\\ln(n))^2 + \\frac{1}{2}\\ln(n)\\ln(2) \\right]\n$$\n$$\nT(n) = \\frac{n}{\\ln(2)} \\left[ \\frac{1}{2}(\\ln(n))^2 + \\frac{1}{2}\\ln(n)\\ln(2) \\right]\n$$\n从括号内的项中提出因子 $\\frac{1}{2}$ 和 $\\ln(n)$，得到：\n$$\nT(n) = \\frac{n}{2\\ln(2)} \\left[ (\\ln(n))^2 + \\ln(n)\\ln(2) \\right] = \\frac{n \\ln(n) (\\ln(n) + \\ln(2))}{2 \\ln(2)}\n$$\n这就是 $T(n)$ 的精确封闭形式表达式。其主导项与 $n(\\ln n)^2$ 成正比，这与问题描述中提到的 $\\mathcal{O}(n(\\ln n)^2)$ 数量级一致。\n对基本情况 $T(1)=0$ 的检验确认了结果的正确性：\n$$\nT(1) = \\frac{1 \\ln(1) (\\ln(1) + \\ln(2))}{2 \\ln(2)} = \\frac{1 \\cdot 0 \\cdot (0 + \\ln(2))}{2 \\ln(2)} = 0\n$$\n推导完成，结果已验证。", "answer": "$$\n\\boxed{\\frac{n \\ln(n) (\\ln(n) + \\ln(2))}{2 \\ln(2)}}\n$$", "id": "3265011"}, {"introduction": "并非所有递归算法都遵循“分而治之”的模式。有些算法通过将问题规模减小一个固定的量（例如 $n-1$）来进行递归，这种“减法递归”会产生一种截然不同的递归树结构——深而窄。这个练习 [@problem_id:3265077] 将展示如何运用递归树方法分析此类问题，并揭示一个出人意料的模式：尽管递归调用繁多，但每一层的代价可能是一个恒定值。", "problem": "一个处理输入大小为 $n$ 的算法，会对大小为 $n-1$ 的子问题进行 $2$ 次递归调用，并在该层级执行 $2^{n}$ 的额外非递归工作。设运行时间满足递归关系 $T(n) = 2\\,T(n-1) + 2^{n}$ (对于所有整数 $n \\geq 1$)，其基础值为一个固定的正常数 $T(0)$。使用递归树方法，从第一性原理出发，推导出一个关于 $n$ 和 $T(0)$ 的 $T(n)$ 的精确封闭形式表达式。你的推导必须从递归树的核心定义开始，即逐层分解，其中总成本等于所有层级的非递归工作之和加上基础情形的累积贡献，并且必须仅依赖于结合律和分配律等代数性质。将你的最终答案表示为单个封闭形式的解析表达式。无需四舍五入，也不涉及单位。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个算法分析中定义明确的问题，为推导给定递归关系的封闭形式解提供了完整且一致的设定。\n\n该问题要求解递归关系 $T(n) = 2T(n-1) + 2^n$ (对于整数 $n \\geq 1$)，其中基础情形 $T(0)$ 是一个正常数。解必须使用递归树方法从第一性原理推导得出。\n\n递归树将递归调用的成本可视化。树中的每个节点代表单个子问题的成本。总成本 $T(n)$ 是树中所有节点成本的总和。\n\n让我们逐层构建这棵树。\n\n在第 $0$ 层（树的根节点），我们有大小为 $n$ 的初始问题。在这一层执行的非递归工作量为 $2^n$。$T(n)$ 的节点产生对大小为 $n-1$ 的子问题的 $2$ 次递归调用。\n\n在第 $1$ 层，有 $2$ 个节点，每个节点对应一个大小为 $n-1$ 的子问题。对于这些子问题中的每一个，非递归工作量为 $2^{n-1}$。因此，第 $1$ 层的总非递归工作量是节点数乘以每个节点的工作量，即 $2 \\times 2^{n-1} = 2^n$。这 $2$ 个节点中的每一个又产生 $2$ 次递归调用，总共导致对大小为 $n-2$ 的子问题的 $2 \\times 2 = 2^2$ 次调用。\n\n在第 $2$ 层，有 $2^2$ 个节点，每个节点对应一个大小为 $n-2$ 的子问题。对于这些子问题中的每一个，非递归工作量为 $2^{n-2}$。第 $2$ 层的总非递归工作量是 $2^2 \\times 2^{n-2} = 2^n$。\n\n我们可以将其推广到任意层级 $k$。在第 $k$ 层，有 $2^k$ 个节点。每个节点对应一个大小为 $n-k$ 的子问题。在每个这样的节点上完成的非递归工作量是 $2^{n-k}$。第 $k$ 层的总非递归工作量是节点数与每个节点工作量的乘积：\n$$\n\\text{Cost at Level } k = 2^k \\times 2^{n-k} = 2^{k + (n-k)} = 2^n\n$$\n这对 $k = 0, 1, 2, \\dots$ 成立。\n\n当子问题大小变为 $0$ 时，递归终止，因为基础情形是 $T(0)$。这发生在子问题大小 $n-k$ 等于 $0$ 的层级 $k$。解出 $k$，我们得到 $k=n$。\n这意味着树的深度为 $n$。包含来自递归调用的非递归工作的层级是第 $0$ 层、第 $1$ 层，...，直到第 $n-1$ 层。在第 $n$ 层，递归停止，我们剩下的是基础情形。\n\n在第 $n$ 层，子问题大小为 $n-n=0$。这一层的节点数量是 $2^n$。这些节点中的每一个都对应一个基础情形 $T(0)$，并对总和贡献一个成本 $T(0)$。\n\n为了求得总成本 $T(n)$，我们将树的所有层级的成本相加。这包括两部分：从第 $0$ 层到第 $n-1$ 层所有层级的非递归工作之和，以及第 $n$ 层基础情形的成本之和。\n\n$1$. 总非递归工作量是从 $k=0$ 到 $k=n-1$ 各层成本的总和。正如我们所发现的，这些层级中每一层的成本都是 $2^n$。\n$$\n\\text{Total non-recursive work} = \\sum_{k=0}^{n-1} (\\text{Cost at Level } k) = \\sum_{k=0}^{n-1} 2^n\n$$\n由于 $2^n$ 相对于求和索引 $k$ 是一个常数，这个和等价于将 $2^n$ 自身相加 $n$ 次（对于 $k=0, 1, \\dots, n-1$）。\n$$\n\\sum_{k=0}^{n-1} 2^n = n \\times 2^n\n$$\n\n$2$. 基础情形的总成本是在第 $n$ 层产生的成本。在这一层，有 $2^n$ 个叶节点，每个叶节点贡献一个成本 $T(0)$。\n$$\n\\text{Total base case cost} = (\\text{Number of leaves}) \\times (\\text{Cost per leaf}) = 2^n \\times T(0)\n$$\n\n总运行时间 $T(n)$ 是这两个部分的总和。\n$$\nT(n) = (\\text{Total non-recursive work}) + (\\text{Total base case cost})\n$$\n$$\nT(n) = n \\cdot 2^n + 2^n \\cdot T(0)\n$$\n通过应用分配律，我们可以提出公因式 $2^n$ 来获得最终的封闭形式表达式。\n$$\nT(n) = 2^n (n + T(0))\n$$\n这就是根据要求从第一性原理推导出的，关于 $n$ 和 $T(0)$ 的 $T(n)$ 的精确封闭形式表达式。", "answer": "$$\n\\boxed{2^n (n + T(0))}\n$$", "id": "3265077"}, {"introduction": "递归树的分析能力不仅限于时间复杂度。这个强大的模型同样可以用来分析算法的空间使用情况，例如递归调用栈的最大深度。这个练习 [@problem_id:3265136] 创新地要求我们分析一个递归过程在执行期间任意时刻所占用的最大栈内存，这不仅需要我们构建递归树，更需要我们理解其深度优先的执行顺序，从而找到内存占用的峰值路径。", "problem": "考虑一个对大小为 $n \\in \\mathbb{N}$ 的输入（其中 $n$ 是 $2$ 的幂）的递归过程。对于每次以参数 $m > 1$ 的调用，该过程会精确分配 $\\alpha \\,\\ln m$ 单位的栈内存（其中 $\\alpha > 0$ 是一个固定常数，$\\ln$ 表示自然对数），然后以深度优先的顺序进行两次递归调用：首先是对大小为 $m/2$ 的输入，在该调用返回后，再对大小为 $m/4$ 的输入。大小为 $\\alpha \\,\\ln m$ 的栈帧会一直保持分配状态，直到两次递归调用都返回。对于 $m \\leq 1$ 的情况，该过程立即返回，不分配任何内存。忽略任何未明确说明的内存开销。\n\n仅使用算法分析中关于递归树和调用栈的基本原理，推导在输入大小为 $n$ 的执行过程中任意时刻使用的最大瞬时栈内存 $M(n)$ 的精确闭式表达式。你的分析必须基于递归树的结构特性（节点标签和深度）以及调用栈帧在其返回前一直存在的定义进行推理。请用一个关于 $n$ 和 $\\alpha$ 的单一解析表达式来表示你的最终答案，使用初等函数，并可以利用 $n$ 是 $2$ 的幂这一事实。最终答案中不要使用渐近符号。", "solution": "### 步骤 1：提取已知条件\n- 输入大小为 $n \\in \\mathbb{N}$，其中 $n$ 是 $2$ 的幂。\n- 递归过程是为参数 $m$ 定义的。\n- 当 $m > 1$ 时，过程分配 $\\alpha \\ln m$ 单位的栈内存，其中 $\\alpha > 0$ 是一个常数。\n- 过程以深度优先顺序进行两次递归调用：首先对大小 $m/2$，然后对大小 $m/4$。\n- 大小为 $\\alpha \\ln m$ 的栈帧在对 $m/2$ 和 $m/4$ 的两次递归调用都返回之前，会一直保持分配状态。\n- 当 $m \\leq 1$ 时，过程不分配内存并返回。\n- 目标是找到最大瞬时栈内存 $M(n)$，表示为关于 $n$ 和 $\\alpha$ 的精确闭式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据、定义明确且客观。\n- **科学依据：** 该问题涉及递归、调用栈和算法分析，这些是计算机科学（一门形式化的 STEM 学科）的核心概念。对数和求和的使用在数学上是合理的。\n- **定义明确：** 问题陈述清晰且自成一体。约束条件（$n$ 是 $2$ 的幂，深度优先顺序）和内存分配规则都得到了精确说明。这种结构确保了唯一且有意义的解的存在。\n- **客观性：** 语言正式且无歧义。各数量都用数学精度进行了定义（例如 $\\alpha \\ln m$）。没有主观或基于意见的元素。\n\n该问题没有任何无效性缺陷。这是一个算法分析中的标准问题。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供完整的解答。\n\n### 解题推导\n设 $M(m)$ 是在对大小为 $m$ 的输入执行过程期间任意时刻使用的最大瞬时栈内存。我们需要求 $M(n)$。\n\n问题陈述，对于一个输入 $m > 1$，会分配一个大小为 $\\alpha \\ln m$ 的栈帧。该帧在过程进行两次连续的、深度优先的调用期间持续存在：首先是对 `procedure(m/2)`，然后是对 `procedure(m/4)`。\n\n我们来分析 `procedure(m)` 执行期间的内存使用情况。\n1.  `procedure(m)` 的帧被推入栈中，消耗 $\\alpha \\ln m$ 的内存。\n2.  进行第一次递归调用 `procedure(m/2)`。在此子问题整个执行期间，栈中包含 `procedure(m)` 的帧。此阶段的最大内存使用量是当前帧的内存与子问题 `procedure(m/2)` 所需最大内存之和。这个最大值为 $\\alpha \\ln m + M(m/2)$。\n3.  在 `procedure(m/2)` 完成并返回后，进行第二次递归调用 `procedure(m/4)`。类似地，此阶段的最大内存使用量是 $\\alpha \\ln m + M(m/4)$。\n\n由于这两个阶段是顺序发生的，`procedure(m)` 执行期间的总最大内存使用量是每个阶段峰值使用量的最大值。这给了我们以下关于 $M(m)$ 的递推关系：\n$$M(m) = \\alpha \\ln m + \\max\\left( M(m/2), M(m/4) \\right) \\quad \\text{for } m > 1$$\n基本情况由 $m \\leq 1$ 的条件给出，此时不分配内存。因此：\n$$M(m) = 0 \\quad \\text{for } m \\leq 1$$\n\n为了解这个递推关系，我们首先需要简化 $\\max$ 项。我们来证明对于 $m \\ge 1$，$M(m)$ 是一个关于 $m$ 的单调递增函数。\n基本情况：\n$M(1) = 0$。\n$M(2) = \\alpha \\ln 2 + \\max(M(1), M(1/2)) = \\alpha \\ln 2 + \\max(0, 0) = \\alpha \\ln 2$。\n因为 $\\alpha > 0$ 且 $\\ln 2 > 0$，我们有 $M(2) > M(1)$。\n现在，我们进行归纳假设，对于所有满足 $2 \\le k  m$ 的 $2$ 的幂 $k$，$M(k) > M(k/2)$。\n我们想证明 $M(m) > M(m/2)$。根据我们的归纳假设，因为 $m/2  m$，我们有 $M(m/2) > M((m/2)/2) = M(m/4)$。\n因此，$\\max(M(m/2), M(m/4)) = M(m/2)$。\n对于 $m  2$ 的递推关系变为：\n$$M(m) = \\alpha \\ln m + M(m/2)$$\n我们必须证明 $M(m) > M(m/2)$。这一点是显而易见的：\n$M(m) = M(m/2) + \\alpha \\ln m$。由于 $m  1$ 且 $\\alpha  0$，项 $\\alpha \\ln m$ 严格为正。因此，$M(m) > M(m/2)$。归纳法成立。\n\n对于 $n  1$ 的简化递推关系是：\n$$M(n) = \\alpha \\ln n + M(n/2)$$\n基本情况是 $M(1) = 0$。由于 $n$ 是 $2$ 的幂，设 $n=2^k$，其中 $k \\ge 0$ 是一个整数。注意 $k = \\log_2 n$。\n我们可以通过展开递推关系来求解它：\n$$M(n) = M(2^k) = \\alpha \\ln(2^k) + M(2^{k-1})$$\n$$M(2^k) = \\alpha \\ln(2^k) + \\left(\\alpha \\ln(2^{k-1}) + M(2^{k-2})\\right)$$\n$$M(2^k) = \\alpha \\ln(2^k) + \\alpha \\ln(2^{k-1}) + \\alpha \\ln(2^{k-2}) + \\dots + M(2^1)$$\n最后一步是 $M(2^1) = M(2) = \\alpha \\ln 2 + M(1) = \\alpha \\ln 2$。\n所以，我们得到一个和式：\n$$M(n) = \\alpha \\left( \\ln(2^k) + \\ln(2^{k-1}) + \\dots + \\ln(2^1) \\right)$$\n$$M(n) = \\alpha \\sum_{i=1}^{k} \\ln(2^i)$$\n使用对数性质 $\\ln(x^y) = y \\ln x$：\n$$M(n) = \\alpha \\sum_{i=1}^{k} i \\ln 2 = \\alpha \\ln 2 \\sum_{i=1}^{k} i$$\n前 $k$ 个整数的和由公式 $\\sum_{i=1}^{k} i = \\frac{k(k+1)}{2}$ 给出。\n将此代入我们关于 $M(n)$ 的表达式中：\n$$M(n) = \\alpha \\ln 2 \\left( \\frac{k(k+1)}{2} \\right)$$\n现在，我们必须用 $n$ 和 $\\alpha$ 来表示结果。我们代入 $k = \\log_2 n = \\frac{\\ln n}{\\ln 2}$：\n$$M(n) = \\frac{\\alpha \\ln 2}{2} \\left( \\frac{\\ln n}{\\ln 2} \\right) \\left( \\frac{\\ln n}{\\ln 2} + 1 \\right)$$\n$$M(n) = \\frac{\\alpha \\ln n}{2} \\left( \\frac{\\ln n}{\\ln 2} + 1 \\right)$$\n为了得到更紧凑的形式，我们继续化简：\n$$M(n) = \\frac{\\alpha \\ln n}{2} \\left( \\frac{\\ln n + \\ln 2}{\\ln 2} \\right)$$\n使用对数性质 $\\ln a + \\ln b = \\ln(ab)$：\n$$M(n) = \\frac{\\alpha (\\ln n) (\\ln(2n))}{2 \\ln 2}$$\n这就是最大瞬时栈内存的精确闭式表达式。", "answer": "$$\\boxed{\\frac{\\alpha (\\ln n) (\\ln(2n))}{2 \\ln 2}}$$", "id": "3265136"}]}