{"hands_on_practices": [{"introduction": "这个练习是让你初步领略位运算在算法设计中威力的经典入门。我们将探索如何利用异或（XOR）运算符独特的代数性质，以惊人的优雅和效率解决一个看似复杂的问题。通过这个实践，你将巩固对“自反性” ($x \\oplus x = 0$) 等性质的理解，学会如何利用它们来“抵消”信息，从而分离出我们唯一想要的结果。[@problem_id:3275306]", "problem": "给定一个静态数组，即一个具有固定长度的连续内存块，其中每个元素都恰好出现两次，只有一个元素恰好出现一次。目标是仅使用按位异或操作来找出那个单一元素。静态数组支持常数时间的随机访问，其逻辑模型是元素占据从 $0$ 到 $n-1$ 的连续索引，其中 $n$ 表示元素数量。\n\n从以下关于离散二元运算和静态数组的基本原理出发：\n- 一个长度为 $n$ 的静态数组 $A$ 是一个序列 $(A[0], A[1], \\dots, A[n-1])$，它被连续存储，且其大小 $n$ 不会改变。\n- 按位异或（记作 $\\oplus$）是一种作用于整数的二元运算，它在其二进制补码表示上按位定义，并具有以下经过充分验证的代数性质：$a \\oplus a = 0$，$a \\oplus 0 = a$，交换律 $a \\oplus b = b \\oplus a$，以及结合律 $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$。\n\n从这些原理出发，推导出一个计算只出现一次的单一元素的算法，过程中不依赖任何捷徑公式。你的算法必须：\n- 读取一个静态数组 $A$ 并输出一个整数。\n- 仅使用按位异或运算 $\\oplus$ 来组合数组元素；不使用任何哈希、排序或超出 $O(1)$ 额外内存的辅助数据结构。\n- 运行时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。\n\n此问题不涉及物理单位、角度或百分比。\n\n为了可测试性，请将你的算法应用于以下静态数组测试套件，每个数组都满足除一个元素外，其他所有元素都恰好出现两次的条件：\n- 测试 $1$：数组 $[\\,2,\\,1,\\,4,\\,5,\\,2,\\,4,\\,1\\,]$。\n- 测试 $2$：数组 $[\\,42\\,]$。\n- 测试 $3$：数组 $[\\,{-7},\\,{-7},\\,0,\\,0,\\,{-3}\\,]$。\n- 测试 $4$：数组 $[\\,2147483647,\\,99,\\,2147483647\\,]$。\n- 测试 $5$：数组 $[\\,8,\\,9,\\,9,\\,10,\\,10,\\,11,\\,11,\\,12,\\,12,\\,8,\\,13\\,]$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。具体来说，如果测试 $1$ 到 $5$ 的结果分别为 $r_1, r_2, r_3, r_4, r_5$，则打印该行 $[r_1,r_2,r_3,r_4,r_5]$。", "solution": "该问题已经过验证，并被确定为是合理的。它具有科学依据，提法得当且客观。该问题是基于按位运算的数学性质的一个可形式化的算法设计练习。所有必要信息均已提供，约束条件一致且清晰。\n\n目标是设计一个算法，用于在一个长度为 $n$ 的静态数组 $A$ 中找出唯一元素，而所有其他元素都恰好出现两次。该算法受限于只能使用按位异或（XOR）运算（记作 $\\oplus$）来组合元素。它必须在 $O(n)$ 时间和 $O(1)$ 空间内运行。\n\n算法的推导过程源于问题陈述中提供的 XOR 运算的基本代数性质：\n1.  自逆性质：对于任意整数 $a$，$a \\oplus a = 0$。\n2.  单位元：对于任意整数 $a$，$a \\oplus 0 = a$。\n3.  交换律：对于任意整数 $a, b$，$a \\oplus b = b \\oplus a$。\n4.  结合律：对于任意整数 $a, b, c$，$(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$。\n\n考虑对数组 $A$ 的所有元素应用 XOR 运算得到的结果 $R$：\n$$ R = A[0] \\oplus A[1] \\oplus \\dots \\oplus A[n-1] = \\bigoplus_{i=0}^{n-1} A[i] $$\n问题陈述指出，该数组由一个数字多重集构成，其中除一个唯一元素外，每个元素都出现两次。设出现两次的不同元素集合为 $\\{v_1, v_2, \\dots, v_k\\}$，唯一元素为 $u$。因此，数组 $A$ 是多重集 $\\{v_1, v_1, v_2, v_2, \\dots, v_k, v_k, u\\}$ 的一个排列。\n\n由于 XOR 的交换律和结合律，总异或和的运算顺序不影响最终结果。我们可以对数组中的元素进行重新分组，将相同的值配对：\n$$ R = (v_1 \\oplus v_1) \\oplus (v_2 \\oplus v_2) \\oplus \\dots \\oplus (v_k \\oplus v_k) \\oplus u $$\n对每一对应用自逆性质 $a \\oplus a = 0$：\n$$ v_i \\oplus v_i = 0 \\quad \\text{for } i = 1, \\dots, k $$\n将此结果代入 $R$ 的表达式中：\n$$ R = 0 \\oplus 0 \\oplus \\dots \\oplus 0 \\oplus u $$\n任意数量的 $0$ 的异或和为 $0$。因此，表达式化简为：\n$$ R = 0 \\oplus u $$\n最后，应用单位元性质 $a \\oplus 0 = a$：\n$$ R = u $$\n此推导严格证明了数组中所有元素的异或和恰好等于唯一元素 $u$。\n\n这导出了以下算法：\n1.  初始化一个累加器变量为 $0$，它是 XOR 运算的单位元。\n2.  从索引 $i=0$ 到 $n-1$ 遍历数组 $A$。\n3.  对于每个元素 $A[i]$，通过计算 `accumulator = accumulator` $\\oplus$ `A[i]` 来更新累加器。\n4.  迭代完成后，累加器的最终值就是那个唯一元素。\n\n该算法对 $n$ 个元素中的每一个访问一次，每次执行一次常数时间的 XOR 操作。因此，其时间复杂度为 $O(n)$。该算法只需要一个变量作为累加器，所以其空间复杂度为 $O(1)$。这些复杂度满足问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies an algorithm to find the single unique element in arrays\n    where all other elements appear twice, using only bitwise XOR operations.\n    \"\"\"\n\n    def find_unique_element(arr: np.ndarray) -> np.int64:\n        \"\"\"\n        Computes the unique element in an array by XORing all its elements.\n\n        This method is based on the algebraic properties of XOR:\n        1. a ^ a = 0 (self-inverse)\n        2. a ^ 0 = a (identity)\n        3. a ^ b = b ^ a (commutativity)\n        4. (a ^ b) ^ c = a ^ (b ^ c) (associativity)\n\n        The XOR sum of all elements simplifies to the unique element because all\n        paired elements cancel each other out (e.g., v1^v1^v2^v2^u = 0^0^u = u).\n\n        Args:\n            arr: A NumPy array of integers where one element appears once\n                 and all others appear twice.\n\n        Returns:\n            The integer that appears exactly once in the array.\n        \"\"\"\n        # The identity element for the XOR operation is 0.\n        # We use a fixed-size integer type consistent with a static array model.\n        accumulator = np.int64(0)\n        \n        # Iterate through all elements of the array.\n        for element in arr:\n            # Update the accumulator by XORing it with the current element.\n            accumulator ^= element\n            \n        return accumulator\n\n    # Define the test cases from the problem statement.\n    # The arrays are defined with a 64-bit integer type to accommodate the\n    # full range of values including negatives and large numbers.\n    test_cases = [\n        np.array([2, 1, 4, 5, 2, 4, 1], dtype=np.int64),\n        np.array([42], dtype=np.int64),\n        np.array([-7, -7, 0, 0, -3], dtype=np.int64),\n        np.array([2147483647, 99, 2147483647], dtype=np.int64),\n        np.array([8, 9, 9, 10, 10, 11, 11, 12, 12, 8, 13], dtype=np.int64),\n    ]\n\n    results = []\n    for case in test_cases:\n        # For each test case, apply the derived algorithm.\n        unique_element = find_unique_element(case)\n        results.append(unique_element)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3275306"}, {"introduction": "在异或抵消技术的基础上，下一个问题提出了一个更普遍的场景，简单的异或累加已无法解决。这个挑战促使我们从更基础的层面——逐个比特位——来思考数字。你将学到一种强大的方法，它将位分析与模运算相结合，系统地重建出那个出现次数独特的数字，这展示了一种适用于更广泛问题的通用策略。[@problem_id:3217582]", "problem": "你需要设计并实现一个基于位运算的算法，用于在一个多重集中找出一个出现次数与其他所有数不同的整数。假设有一个包含有符号 $64$ 位整数的整数数组，其中每个不同的整数都恰好出现 $k$ 次，只有一个整数例外，它恰好出现 $p$ 次，且 $1 \\le p  k$。目标是基于二进制表示和模运算的基本原理，在不依赖哈希或排序的情况下，以与元素数量呈线性的时间复杂度和相对于输入大小为常数的辅助空间复杂度计算出这个唯一的整数。保证输入中的所有整数都在有符号 $64$ 位范围内，即 $[-2^{63}, 2^{63}-1]$ 之间。\n\n使用的基本原理：\n- 整数的二进制表示和位运算，包括在 $64$ 位定宽字上进行的位与（AND）、位或（OR）和位移操作，其中有符号值使用二进制补码编码。\n- 以 $k$ 为模的模运算，特别是模约减对加法的分配律。\n- 二进制补码中位的语义，包括位于位置 $63$ 表示符号的最高有效位（MSB）和位于位置 $0$ 的最低有效位（LSB）。\n\n你的程序必须为以下每个测试用例计算出唯一的整数，每个测试用例由一个三元组 $(\\text{array},k,p)$ 指定：\n- 测试用例 1：$([2,2,2,7,-1,-1,-1,42,42,42],3,1)$\n- 测试用例 2：$([13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22],5,2)$\n- 测试用例 3：$([0,0,0,5,5,5,5,-7,-7,-7,-7],4,3)$\n- 测试用例 4：$([-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3],7,6)$\n- 测试用例 5：$([-8,-8,17,17,1152921504606847099],2,1)$，其中 $1152921504606847099=2^{60}+123$。\n- 测试用例 6：$([-4611686018427387897,-4611686018427387897,9,9,9,0,0,0],3,2)$，其中 $-4611686018427387897=-2^{62}+7$。\n\n你的算法除了规定的出现次数和定宽二进制补码模型外，不得假定任何其他属性，并且必须通过对位级结构和模属性的推理来重构答案。整个测试套件的最终输出必须是一个整数列表，对应于每个测试用例的唯一数字，输出在单行上，形式为用方括号括起来的逗号分隔列表。例如，输出格式必须为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots]$。此问题中不涉及物理单位、角度或百分比；所有输出均为纯整数。", "solution": "问题陈述经过了严格验证，被认为是自洽的、有科学依据的、定义明确且客观的。这是一个基于计算机科学和数学基本原理的算法设计中的形式化问题。\n\n解决此问题的核心原则是逐位重构这个唯一的整数。这可以通过分析数组中所有数字在每个位上的比特总和，并利用模运算的性质来实现。这些整数是有符号的 $64$ 位值，这意味着我们必须考虑 $W=64$ 的位宽。问题对时间（$O(N)$，其中 $N$ 是元素数量）和空间（$O(1)$）的限制排除了排序或使用哈希表等辅助数据结构的方法。\n\n设输入数组为 $A$。该数组包含一个整数多重集，其中每个不同的数出现 $k$ 次，只有一个唯一的整数（我们称之为 $x$）出现 $p$ 次，且 $1 \\le p  k$。设其他不同整数的集合为 $\\{y_1, y_2, \\ldots, y_m\\}$。\n\n考虑单个比特位 $j$，其中 $j$ 的范围从 $0$（最低有效位，LSB）到 $63$（最高有效位，MSB）。设 $b_j(n) \\in \\{0, 1\\}$ 为整数 $n$ 的第 $j$ 位的值。算法的基础是计算数组 $A$ 中所有数在第 $j$ 位上的比特之和。设此和为 $S_j$：\n$$ S_j = \\sum_{n \\in A} b_j(n) $$\n这个和可以根据数字的出现次数进行划分。唯一的数 $x$ 对此和的贡献为 $p \\cdot b_j(x)$，其他每个数 $y_i$ 的贡献为 $k \\cdot b_j(y_i)$。因此，总和可以表示为：\n$$ S_j = p \\cdot b_j(x) + \\sum_{i=1}^{m} k \\cdot b_j(y_i) = p \\cdot b_j(x) + k \\sum_{i=1}^{m} b_j(y_i) $$\n第二项 $k \\sum_{i=1}^{m} b_j(y_i)$ 根据定义是 $k$ 的整数倍。令 $N_j = \\sum_{i=1}^{m} b_j(y_i)$，它就是第 $j$ 位为 1 的“非唯一”数的数量。方程变为：\n$$ S_j = p \\cdot b_j(x) + k \\cdot N_j $$\n现在，我们应用以 $k$ 为模的模运算。将方程对 $k$ 取模：\n$$ S_j \\pmod k = (p \\cdot b_j(x) + k \\cdot N_j) \\pmod k $$\n使用模加法的性质 $(a+b) \\pmod k = ((a \\pmod k) + (b \\pmod k)) \\pmod k$：\n$$ S_j \\pmod k = (p \\cdot b_j(x) \\pmod k + k \\cdot N_j \\pmod k) \\pmod k $$\n由于 $k \\cdot N_j \\pmod k = 0$，方程简化为：\n$$ S_j \\pmod k = (p \\cdot b_j(x)) \\pmod k $$\n我们必须确定 $b_j(x)$ 的值，它只能是 $0$ 或 $1$。\n情况 1：唯一数 $x$ 的第 $j$ 位为 $0$，即 $b_j(x) = 0$。\n在这种情况下，方程变为 $S_j \\pmod k = (p \\cdot 0) \\pmod k = 0$。\n情况 2：唯一数 $x$ 的第 $j$ 位为 $1$，即 $b_j(x) = 1$。\n在这种情况下，方程变为 $S_j \\pmod k = (p \\cdot 1) \\pmod k = p \\pmod k$。\n根据问题约束 $1 \\le p  k$，我们知道 $p$ 不是 $k$ 的倍数，具体来说 $p \\pmod k = p$。因此，如果 $b_j(x)=1$，那么 $S_j \\pmod k = p$，这是一个非零值。\n\n结合这两种情况，我们得到一个明确的决策规则：\n- 如果 $S_j \\pmod k = 0$，那么 $b_j(x)$ 必定为 $0$。\n- 如果 $S_j \\pmod k \\neq 0$，那么 $b_j(x)$ 必定为 $1$。\n\n这个逻辑使我们能够独立地确定唯一数 $x$ 的每一位。算法流程如下：\n1. 初始化一个 $64$ 位的结果整数 `result` 为 $0$。\n2. 对每个比特位 $j$（从 $0$ 到 $63$）进行迭代。\n3. 对于每个 $j$，计算输入数组中所有数在第 $j$ 位上的比特之和 $S_j$。\n4. 计算 $S_j \\pmod k$。\n5. 如果结果非零，则表示唯一数 $x$ 的第 $j$ 位为 $1$。在这种情况下，使用位或（OR）操作和一个掩码将 `result` 的第 $j$ 位置为 1：`result |= (1  j)`。\n\n这个过程对于二进制补码表示的有符号整数同样适用。位运算逻辑作用于数字的二进制表示，而计数属性与一个比特位是正数表示的一部分还是负数表示的一部分无关。当一个数是负数时，使用的是它的二进制补码表示。对每个位置的比特求和可以正确地计算所有数（无论正负）的贡献。在遍历完所有 $64$ 个比特位后，`result` 变量将持有唯一数 $x$ 的完整 $64$ 位二进制补码表示。\n\n实现必须小心处理 $64$ 位有符号整数。由于标准的 Python 整数具有任意精度，我们将使用 `numpy.int64` 和 `numpy.uint64` 来强制执行问题中指定的定宽语义，特别是对于像位移和掩码这样的位运算，以确保符号扩展和位模式得到正确处理。\n对于输入中的每个数字 `num` 和每个比特位 `j`，我们提取其第 $j$ 位。一个可靠的方法是先将 `num` 转换为无符号 $64$ 位整数 `numpy.uint64(num)`，然后使用位运算。这可以防止对负数进行右移时出现符号扩展问题。最终累积的位模式存储在 `numpy.uint64` 变量中，然后被转换回 `numpy.int64` 以产生最终的有符号整数结果。\n\n时间复杂度由两个嵌套循环决定。外层循环运行常数次，即 $64$ 次。内层循环遍历输入数组的 $N$ 个元素。这使得总时间复杂度为 $O(64 \\cdot N)$，即 $O(N)$。空间复杂度为 $O(1)$，因为无论输入大小 $N$ 如何，我们只使用了几个固定大小的变量（例如，用于比特和与结果的变量）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_unique_integer(arr, k, p):\n    \"\"\"\n    Finds the integer that appears p times in an array where all other\n    distinct integers appear k times.\n\n    The algorithm reconstructs the unique integer bit by bit. For each bit\n    position j from 0 to 63, it sums the j-th bits of all numbers in the\n    array. Let this sum be S_j. The sum of bits from numbers that appear k\n    times will be a multiple of k. Thus, S_j mod k will reveal the j-th\n    bit of the unique number.\n\n    Specifically, S_j = (p * b_j(x)) + (k * M), where b_j(x) is the j-th\n    bit of the unique number x, and M is an integer.\n    So, S_j mod k = (p * b_j(x)) mod k.\n    Since 1 = p  k, p is not a multiple of k.\n    - If b_j(x) = 0, then S_j mod k = 0.\n    - If b_j(x) = 1, then S_j mod k = p != 0.\n    Thus, a non-zero remainder implies the j-th bit of x is 1.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): The multiplicity of the non-unique numbers.\n        p (int): The multiplicity of the unique number.\n\n    Returns:\n        numpy.int64: The integer with unique multiplicity.\n    \"\"\"\n    \n    # The result is built up as an unsigned 64-bit integer to correctly handle\n    # bitwise operations on all 64 bits, including the sign bit.\n    result_unsigned = np.uint64(0)\n    \n    # Iterate over each of the 64 bit positions\n    for j in range(64):\n        bit_sum = 0\n        \n        # Create a mask to isolate the j-th bit. Must be uint64 to avoid overflow warnings\n        # for j=63, as 1  63 would be negative in signed int64.\n        bit_mask = np.uint64(1)  np.uint64(j)\n        \n        for num_py in arr:\n            # Cast the Python int to a numpy 64-bit signed integer to work with\n            # a fixed-width two's complement representation.\n            num_np = np.int64(num_py)\n            \n            # To check the j-th bit correctly for both positive and negative numbers,\n            # we cast the number's bit pattern to its unsigned equivalent.\n            # This ensures that bitwise operations (like ) treat all bits,\n            # including the MSB (sign bit), uniformly as data.\n            if (np.uint64(num_np)  bit_mask):\n                bit_sum += 1\n        \n        # If the sum of bits at this position is not a multiple of k,\n        # it means the unique number has a '1' at this bit position.\n        if bit_sum % k != 0:\n            # Set the corresponding bit in our result.\n            result_unsigned |= bit_mask\n            \n    # Cast the final unsigned bit pattern back to a signed 64-bit integer.\n    # This correctly reinterprets the two's complement representation.\n    return np.int64(result_unsigned)\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the solver for each, printing the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([2,2,2,7,-1,-1,-1,42,42,42], 3, 1),\n        ([13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22], 5, 2),\n        ([0,0,0,5,5,5,5,-7,-7,-7,-7], 4, 3),\n        ([-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3], 7, 6),\n        ([-8,-8,17,17,1152921504606847099], 2, 1),\n        ([-4611686018427387897,-4611686018427387897,9,9,9,0,0,0], 3, 2),\n    ]\n\n    results = []\n    for arr, k, p in test_cases:\n        # The parameter 'p' is not strictly necessary for this implementation\n        # but is passed for completeness according to the problem statement.\n        result = find_unique_integer(arr, k, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217582"}, {"introduction": "最后一个实践将我们的焦点从分析数据集合转移到构造一个满足特定位运算和大小限制的数字。它表明，深刻理解二进制表示法对于解决数论和优化问题至关重要。通过解决这个问题，你将学会如何推断一个整数的位模式与其值之间的关系，这是底层编程和算法优化中的一项关键技能。[@problem_id:3217636]", "problem": "考虑一个非负的 $64$ 位无符号整数 $N$，它以二进制形式写成一个有限的二进制字。两个非负整数 $x$ 和 $y$ 的按位与运算（记作 $x \\text{  } y$）是按位定义的：如果 $x$ 的二进制数字为 $\\{x_i\\}_{i \\geq 0}$，$y$ 的二进制数字为 $\\{y_i\\}_{i \\geq 0}$，那么 $x \\text{  } y$ 的第 $i$ 位是 $x_i y_i$，其中并列表示 $0$ 和 $1$ 的普通乘积。二进制字按其最高有效位（MSB）排序：如果 $x$ 的最高非零位出现在位置 $k$（最低有效位（LSB）在位置 $0$），那么在十进制下 $x \\in [2^k, 2^{k+1}-1]$。\n\n给定 $N = 987654321$，确定满足 $M > N$ 和 $N \\text{  } M = 0$ 的最小无符号整数 $M$。将最终答案表示为十进制整数。", "solution": "用户希望我解决以下问题：\n\n**问题陈述：**\n考虑一个非负的 $64$ 位无符号整数 $N$，它以二进制形式写成一个有限的二进制字。两个非负整数 $x$ 和 $y$ 的按位与运算（记作 $x \\text{  } y$）是按位定义的：如果 $x$ 的二进制数字为 $\\{x_i\\}_{i \\geq 0}$，$y$ 的二进制数字为 $\\{y_i\\}_{i \\geq 0}$，那么 $x \\text{  } y$ 的第 $i$ 位是 $x_i y_i$，其中并列表示 $0$ 和 $1$ 的普通乘积。二进制字按其最高有效位（MSB）排序：如果 $x$ 的最高非零位出现在位置 $k$（最低有效位（LSB）在位置 $0$），那么在十进制下 $x \\in [2^k, 2^{k+1}-1]$。\n\n给定 $N = 987654321$，确定满足 $M > N$ 和 $N \\text{  } M = 0$ 的最小无符号整数 $M$。将最终答案表示为十进制整数。\n\n### 步骤1：提取已知条件\n- $N$ 是一个非负的 $64$ 位无符号整数。\n- $N$ 的值为 $987654321$。\n- 按位与运算 $x \\text{  } y$ 定义为结果的第 $i$ 位是 $x$ 和 $y$ 的第 $i$ 位的乘积。\n- 我们要寻找满足以下两个条件的最小无符号整数 $M$：\n    1. $M > N$\n    2. $N \\text{  } M = 0$\n- $M$ 的最终答案必须以十进制表示。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在数学上和计算上是良定义的。它基于数论和计算机科学的标准原理，特别是整数表示和按位运算。已知条件是完整的、一致的且无歧义的。问题是客观的且可以形式化的。因此，该问题被认为是**有效的**。\n\n### 步骤3：求解\n设整数 $N$ 和 $M$ 的二进制表示为\n$$ N = \\sum_{i=0}^{\\infty} n_i 2^i, \\quad n_i \\in \\{0, 1\\} $$\n$$ M = \\sum_{i=0}^{\\infty} m_i 2^i, \\quad m_i \\in \\{0, 1\\} $$\n系数 $n_i$ 和 $m_i$ 分别是数 $N$ 和 $M$ 在位置 $i$ 上的位。\n\n条件 $N \\text{  } M = 0$ 意味着对于任何位位置 $i$，相应位的乘积必须为零。\n$$ n_i m_i = 0 \\quad \\forall i \\ge 0 $$\n这意味着如果某个位 $n_i$ 是 $1$，那么对应的位 $m_i$ 必须是 $0$。\n\n设 $k$ 是 $N$ 的最高有效位（MSB）的索引。这意味着 $n_k=1$ 且对于所有 $i > k$ 都有 $n_i=0$。$k$ 的值由 $k = \\lfloor \\log_2 N \\rfloor$ 给出。这也意味着 $2^k \\le N  2^{k+1}$。\n\n根据条件 $N \\text{  } M = 0$ 以及 $n_k=1$ 的事实，我们必须有 $m_k=0$。\n\n现在，我们来分析条件 $M > N$。设 $j$ 是 $M$ 的最高有效位的索引。\n$j$ 相对于 $k$ 的值有三种可能性：\n\n情况1：$j  k$。\n如果 $M$ 的最高有效位在索引 $j  k$ 处，那么 $M$ 最多是所有直到 $j$ 的 $2$ 的幂之和。\n$$ M = \\sum_{i=0}^{j} m_i 2^i \\le \\sum_{i=0}^{j} 1 \\cdot 2^i = 2^{j+1} - 1 $$\n因为 $j  k$，所以我们有 $j+1 \\le k$。因此，$M \\le 2^k - 1$。\n我们知道 $N \\ge 2^k$。因此，在这种情况下，$M  N$。这违反了条件 $M > N$。\n\n情况2：$j = k$。\n如果 $M$ 的最高有效位在索引 $k$ 处，这将意味着 $m_k=1$。然而，正如我们从条件 $N \\text{  } M = 0$ 中推导出的， $m_k=0$ 是必须的。这是一个矛盾。因此，$M$ 的最高有效位不能在索引 $k$ 处。\n\n综合情况1和情况2的推论，任何满足 $N \\text{  } M = 0$ 且对于 $i \\ge k$ 的所有位 $m_i=0$ 的 $M$ 都将小于 $N$。具体来说，如果对于所有 $i \\ge k$ 都有 $m_i=0$，那么 $M = \\sum_{i=0}^{k-1} m_i 2^i \\le 2^k - 1  N$。\n\n情况3：$j > k$。\n要使 $M > N$ 成为可能，$M$ 的最高有效位必须在索引 $j > k$ 处。\n这意味着 $M \\ge 2^j$。为了使 $M$ 尽可能小，我们需要为其最高有效位选择最小可能的索引 $j$。大于 $k$ 的最小整数 $j$ 是 $j=k+1$。\n\n让我们假设 $M$ 的最高有效位在索引 $k+1$ 处。这意味着 $M \\ge 2^{k+1}$。\n满足这个条件的最小整数是 $M_{cand} = 2^{k+1}$。让我们验证这个候选值是否满足两个必要条件。\n\n1.  **检查 $M_{cand} > N$**：\n    根据 $k = \\lfloor \\log_2 N \\rfloor$ 的定义，我们有 $N  2^{k+1}$。我们的候选值是 $M_{cand} = 2^{k+1}$，所以条件 $M_{cand} > N$ 得到满足。\n\n2.  **检查 $N \\text{  } M_{cand} = 0$**：\n    候选值 $M_{cand} = 2^{k+1}$ 只有一个位设置为 $1$，该位在位置 $k+1$。所有其他位都是 $0$。其二进制表示为 $m_{k+1}=1$ 且对于 $i \\neq k+1$ 有 $m_i=0$。\n    根据 $k$ 是 $N$ 的最高有效位索引的定义，$N$ 的第 $k+1$ 位 $n_{k+1}$ 是 $0$。\n    位置 $k+1$ 处的按位与是 $n_{k+1} m_{k+1} = 0 \\cdot 1 = 0$。\n    对于所有其他位置 $i \\neq k+1$，$m_i=0$，所以 $n_i m_i = 0$。\n    因此，$N \\text{  } M_{cand} = 0$。\n\n两个条件都由 $M_{cand} = 2^{k+1}$ 满足。\n因为我们已经确定任何有效解 $M$ 的最高有效位必须在索引 $j \\ge k+1$ 处，所以任何有效解都必须满足 $M \\ge 2^{k+1}$。因此，$M = 2^{k+1}$ 是最小的可能值。\n\n问题现在简化为计算 $N=987654321$ 时的 $2^{k+1}$。\n首先，我们求出 $k = \\lfloor \\log_2 N \\rfloor$。\n我们可以通过找到界定 $N$ 的 $2$ 的幂来确定 $k$。\n$2^{10} = 1024 \\approx 10^3$\n$2^{20} = (2^{10})^2 \\approx (10^3)^2 = 10^6$\n$2^{30} = (2^{10})^3 \\approx (10^3)^3 = 10^9$\n让我们精确计算 $2^{29}$ 和 $2^{30}$。\n$2^{29} = 2^{30-1} = \\frac{1}{2} \\cdot 2^{30}$。\n$2^{30} = (2^{10})^3 = 1024^3 = 1048576 \\times 1024 = 1073741824$。\n$2^{29} = \\frac{1073741824}{2} = 536870912$。\n\n我们将 $N$ 与这些值进行比较：\n$536870912  987654321  1073741824$\n这等价于 $2^{29}  N  2^{30}$。\n从这个不等式中，我们发现 $N$ 的最高有效位在索引 $k=29$ 处。\n\n满足条件的最小整数 $M$ 是 $M = 2^{k+1} = 2^{29+1} = 2^{30}$。\n$M$ 的值是：\n$$ M = 2^{30} = 1073741824 $$", "answer": "$$\\boxed{1073741824}$$", "id": "3217636"}]}