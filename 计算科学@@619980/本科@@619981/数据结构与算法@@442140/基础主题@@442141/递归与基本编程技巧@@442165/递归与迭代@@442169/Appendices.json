{"hands_on_practices": [{"introduction": "将一个多级链表扁平化为一个单层列表，是检验递归与迭代转换能力的经典问题。这个练习旨在揭示递归深度优先遍历的内在机制，并通过使用显式栈（explicit stack）来实现等效的迭代算法，从而将隐式的函数调用栈转换为具体的、可操作的数据结构。通过完成此练习 [@problem_id:3265439]，你将亲手体验这两种编程范式在逻辑上的等价性。", "problem": "给定一个多级单向链表，其中每个节点包含一个整数值和最多两个指针：一个 next 指针和一个 child 指针。next 指针沿主层级链接节点，而 child 指针可能指向另一个单向链表的头节点（其节点本身也可能带有 child 指针），从而形成一个有限有向无环结构。任务是实现两个函数，以深度优先前序的方式将整个结构展开为单级单向链表，一个使用递归，另一个使用显式栈进行迭代，然后验证两种方法产生相同的输出。\n\n从以下基本原理开始：\n- 单向链表是一个节点序列，其中每个节点包含一个值和指向下一个节点的指针。在此问题中，一个节点还可能包含一个指向子链表的指针。结构中没有环；因此，遍历会终止。\n- 深度优先遍历在处理其后代节点之前先处理当前节点，并确保在向下进入子节点时，遍历会遵循待处理的 next 指针之间的后进先出（LIFO）顺序。这等效于在递归中使用隐式调用栈或在迭代中使用显式栈。\n\n形式上，展开语义定义如下。设该多级链表为一个有限有向无环图，其中节点最多有一个 next 类型的出边和最多一个 child 类型的出边。展开操作通过以下方式生成一个单级链表：\n- 访问节点 $x$，输出 $x$ 的值。\n- 如果 $x$ 有一个指向子链表头节点的 child 指针，则在继续处理 $x$ 的原始 next 后继节点之前，先按顺序完全展开该子链表。\n- 展开后，所有 child 指针必须设置为空（null），而 next 指针必须形成与所述深度优先前序相匹配的单级链表。\n这是对由 child 边引发的隐式树状扩展进行的严格前序遍历，其不变性在于：节点的子链表紧接在该节点之后拼接，而原始的 next 后继节点在拼接的子链表尾部之后继续。\n\n实现两个函数：\n- 一个基于递归的展开函数，它使用隐式调用栈进入子链表，并返回展开后链表的头节点。\n- 一个基于迭代的展开函数，它使用显式栈数据结构来模拟调用栈的 LIFO 行为。\n\n约束和假设：\n- 节点值为整数。为清晰起见，在单个测试用例中所有值都是唯一的。\n- 没有环；每个指针图都是有限且无环的。\n- 两种实现都必须原地执行展开，通过调整指针而不分配新节点，并且必须将所有 child 指针设置为空。\n\n用于覆盖多个方面的测试套件和参数：\n- 案例 1（边界：空结构）：顶层链为空，即头节点为 null。期望的展开顺序为空列表 `[]`。\n- 案例 2（边界：单个节点）：顶层 next 链为 `1`。没有子节点。期望的展开顺序为 `[1]`。\n- 案例 3（通用情况：多个子节点和嵌套子节点）：顶层 next 链为 $1 \\to 2 \\to 3 \\to 4$。子节点：节点 $2$ 有子节点 $7 \\to 8$，节点 $8$ 有子节点 $11$，节点 $3$ 有子节点 $9 \\to 10$。根据定义，期望的展开顺序为 `[1,2,7,8,11,3,9,10,4]`。\n- 案例 4（深度嵌套）：顶层 next 链为 $1 \\to 2 \\to 3$。子节点：节点 $1$ 有子节点 $4$，节点 $4$ 有子节点 $5$，节点 $5$ 有子节点 $6$。期望的展开顺序为 `[1,4,5,6,2,3]`。\n- 案例 5（不同位置有多个子节点）：顶层 next 链为 $1 \\to 2 \\to 3 \\to 4 \\to 5$。子节点：节点 $2$ 有子节点 $6$，节点 $4$ 有子节点 $7 \\to 8 \\to 9$。期望的展开顺序为 `[1,2,6,3,4,7,8,9,5]`。\n\n你的程序必须：\n- 完全按照规定构造测试结构。\n- 使用基于递归的方法生成展开序列，并独立地使用带显式栈的迭代方法生成展开序列。\n- 验证每个测试用例的两个序列是否相同。\n- 最终输出格式：单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例。对于测试用例 $i$，当且仅当递归方法生成的序列与迭代方法生成的序列匹配时，输出该展开序列作为整数列表；否则，为该用例输出单元素列表 `[-1]`。例如，一个包含五个测试用例的输出字符串格式为 `[[...],[...],[...],[...],[...]]`，其中每个 `[...]` 是一个整数列表。", "solution": "该问题要求实现并验证两种不同的方法——一种递归，一种迭代——来展开一个多级单向链表。此结构是一个有限有向无环图，其中每个节点拥有一个整数值、一个定义主链的 `next` 指针，以及一个指向子链表头节点的 `child` 指针。展开操作必须遵循严格的深度优先前序遍历，最终形成一个单级链表。实现必须是原地的，即它们通过修改现有指针而不分配新节点来完成，并且必须将所有 `child` 指针设置为 `null`。\n\n首先，我们定义节点的结构，记为 $N$。每个节点 $N$ 包含三个部分：一个整数值 $v$，一个指向下一个节点的指针 $N_{next}$，以及一个指向子节点的指针 $N_{child}$。\n\n$$N = (v, N_{next}, N_{child})$$\n\n展开操作通过在父节点之后立即拼接子链表，将多级结构转换为线性序列。如果一个节点 $N_i$ 有一个由 $N_c$ 作为头节点的子链表和一个后继节点 $N_j$，则结构 $... \\to N_i \\to N_j \\to ...$（其中 $N_i$ 的子节点为 $N_c$）将被转换。从 $N_c$ 开始的子链表被展开为一个从 $N_c$ 到其尾部 $T_c$ 的线性片段。然后，该片段被插入到 $N_i$ 和 $N_j$ 之间，形成序列 $... \\to N_i \\to N_c \\to ... \\to T_c \\to N_j \\to ...$。在此过程中，所有的 $N_{child}$ 指针都被设置为 `null`。\n\n### 递归展开\n\n递归方法非常适合此问题，因为展开的定义本身就是递归的。展开一个链表的函数可以调用自身来展开遇到的任何子链表。一个健壮的递归实现涉及一个辅助函数，该函数接收一个链表的头节点，将其展开，并返回现在已展开链表的尾部。返回的这个尾部对于正确拼接链表片段至关重要。\n\n我们定义一个函数 $\\text{FlattenRecursive}(h)$，其中 $h$ 是一个链表段的头节点。此函数返回展开后链表段的尾部。\n算法流程如下：\n1.  初始化一个指针 `current` 指向头节点 $h$。\n2.  使用 `current` 指针逐层遍历链表。\n3.  在每个 `current` 节点处：\n    a. 如果存在子指针 $N_{child}$：\n        i.  存储原始的 next 指针，$N_{next} = \\text{current.next}$。\n        ii. 对子链表递归调用该函数：$T_c = \\text{FlattenRecursive}(\\text{current.child})$。$T_c$ 是展开后子链表的尾部。\n        iii. 将展开的子链表拼接到主链表中：\n            - 设置 $\\text{current.next} = \\text{current.child}$。\n            - 设置 $\\text{current.child} = \\text{null}$。\n            - 将子链表的尾部链接到原始的 next 节点：$T_c.\\text{next} = N_{next}$。\n        iv. 为了继续遍历，将 `current` 指针更新到新插入段的末尾，即 $T_c$。这确保了循环的下一次迭代能正确处理拼接段之后的部分。\n    b. 如果 `current.next` 为空，意味着我们已到达当前遍历路径的末尾。这个 `current` 节点是到目前为止展开链表的尾部，因此返回它。\n    c. 将 `current` 前进到 `current.next`。\n\n递归的基本情况是一个没有子节点的链表段，在这种情况下，遍历仅需找到并返回该线性段的尾部。\n\n### 迭代展开\n\n迭代方法必须模拟递归调用栈的 LIFO（后进先出）行为。为此，使用一个显式栈数据结构。该栈将存储稍后必须处理的节点指针。具体来说，当我们进入一个子链表时，父节点的原始 `next` 指针必须被保存起来，以便稍后连接。\n\n迭代算法 $\\text{FlattenIterative}(h)$ 的操作如下：\n1.  如果头节点 $h$ 为 `null`，则链表为空，我们返回。\n2.  初始化一个空栈 $S$。\n3.  初始化一个指针 `current` 指向头节点 $h$。\n4.  开始一个循环，只要 `current` 不为 `null` 就继续。\n5.  在循环内部，对于 `current` 节点：\n    a. 如果存在子指针 $\\text{current.child}$：\n        i.  如果 `next` 指针 $\\text{current.next}$ 也存在，则将其推入栈 $S$。这会保存当前层级的剩余链表，以便在整个子分支被展开并附加后进行处理。\n        ii. 提升子链表，使其成为主链表的下一部分：$\\text{current.next} = \\text{current.child}$。\n        iii. 将子指针置为空：$\\text{current.child} = \\text{null}$。\n    b. 如果 `current` 节点现在位于一个链的末端（即 $\\text{current.next}$ 为 `null`）并且栈 $S$ 不为空，这表示我们已经处理完一个（可能嵌套的）子分支。现在我们必须将此分支连接回先前保存的链表段。\n        i.  从栈 $S$ 中弹出一个节点，并将其设置为下一个节点：$\\text{current.next} = S.\\text{pop()}$。\n    c. 将 `current` 前进到下一个节点：$\\text{current} = \\text{current.next}$。\n\n这个迭代过程以深度优先的方式系统地探索整个结构。将 `next` 指针推入栈并立即处理 `child` 指针确保了前序遍历。当一个分支被遍历完时，栈提供了继续点，完美地模拟了递归调用的返回。\n\n### 验证\n为了验证正确性，对于每个测试用例，我们必须创建初始结构的两个相同副本。一个副本传递给递归函数，另一个传递给迭代函数。在两个函数都完成后，遍历得到的单级链表，并将其节点值收集到两个序列中。然后对这两个序列进行比较。如果它们相同，则验证成功。否则，实现之间存在差异。这种比较验证了两种实现算法的逻辑等价性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Node definition for the multi-level singly linked list.\"\"\"\n    def __init__(self, val, next_node=None, child=None):\n        self.val = val\n        self.next = next_node\n        self.child = child\n\n    def __repr__(self):\n        return f\"Node({self.val})\"\n\ndef _flatten_recursive(current):\n    \"\"\"\n    Recursive helper that flattens the list starting at `current`\n    and returns the tail of the flattened list.\n    \"\"\"\n    if not current:\n        return None\n\n    tail = current\n    while tail.next:\n        tail = tail.next\n\n    it = current\n    while it:\n        if it.child:\n            original_next = it.next\n            child_tail = _flatten_recursive(it.child)\n            \n            # Splice the flattened child list\n            it.next = it.child\n            it.child = None\n            \n            child_tail.next = original_next\n            \n            # Update the main tail if the new segment is at the end\n            if original_next is None:\n                tail = child_tail\n            \n            # Continue traversal from the end of the spliced segment\n            it = child_tail\n        else:\n            it = it.next\n            \n    return tail\n\ndef flatten_recursive(head):\n    \"\"\"\n    Main recursive function to flatten the list.\n    It calls a helper that performs the actual an-place flattening.\n    \"\"\"\n    if head:\n        _flatten_recursive(head)\n    return head\n\ndef flatten_iterative(head):\n    \"\"\"\n    Iterative function to flatten the list in-place using a stack.\n    \"\"\"\n    if not head:\n        return None\n\n    stack = []\n    current = head\n    \n    while current:\n        if current.child:\n            # If there's a next node, save it to the stack to process later\n            if current.next:\n                stack.append(current.next)\n            \n            # Promote child to be the next node\n            current.next = current.child\n            current.child = None\n            \n        # If we reach the end of a chain and the stack has saved pointers\n        if not current.next and stack:\n            # Pop from stack to connect the chain\n            current.next = stack.pop()\n        \n        # Move to the next node\n        current = current.next\n        \n    return head\n\ndef build_structure(nodes_def):\n    \"\"\"\n    Helper to build the list structure from a dictionary definition.\n    `nodes_def` is a dict of val -> (next_val, child_val).\n    \"\"\"\n    if not nodes_def:\n        return None\n        \n    nodes = {val: Node(val) for val in nodes_def}\n    for val, (next_val, child_val) in nodes_def.items():\n        if next_val is not None:\n            nodes[val].next = nodes[next_val]\n        if child_val is not None:\n            nodes[val].child = nodes[child_val]\n            \n    # Find head (node with no incoming edges, assumed to be the smallest value for simplicity)\n    # This is a simplification; a more robust way would be to pass the head's value.\n    in_degrees = {val: 0 for val in nodes}\n    for _, (next_val, child_val) in nodes_def.items():\n        if next_val is not None:\n            in_degrees[next_val] += 1\n        if child_val is not None:\n            in_degrees[child_val] += 1\n    \n    head_val = min([val for val, deg in in_degrees.items() if deg == 0 and val in nodes_def])\n    return nodes.get(head_val)\n\n\ndef build_from_case(case_def):\n    \"\"\"\n    Builds the test case structure. \n    case_def is a tuple: (head_val, definition_dict).\n    \"\"\"\n    if not case_def:\n        return None\n    head_val, nodes_def = case_def\n    if not nodes_def:\n        return None if head_val is None else Node(head_val)\n\n    nodes = {val: Node(val) for val in nodes_def}\n    for val, connections in nodes_def.items():\n        next_val, child_val = connections\n        if next_val in nodes:\n            nodes[val].next = nodes[next_val]\n        if child_val in nodes:\n            nodes[val].child = nodes[child_val]\n    return nodes.get(head_val)\n\ndef deepcopy_structure(head):\n    \"\"\"\n    Performs a deep copy of the graph structure to ensure tests are independent.\n    Uses a memoization dictionary to handle DAGs correctly.\n    \"\"\"\n    if not head:\n        return None\n    \n    memo = {}\n\n    def copy_node(node):\n        if not node:\n            return None\n        if id(node) in memo:\n            return memo[id(node)]\n        \n        new_node = Node(node.val)\n        memo[id(node)] = new_node\n        \n        new_node.next = copy_node(node.next)\n        new_node.child = copy_node(node.child)\n        \n        return new_node\n        \n    return copy_node(head)\n\ndef get_list_values(head):\n    \"\"\"Converts a flattened linked list to a Python list of values.\"\"\"\n    values = []\n    current = head\n    while current:\n        values.append(current.val)\n        current = current.next\n    return values\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run flatteners, and verify results.\n    \"\"\"\n    # Test cases defined as (head_value, {node_val: (next_val, child_val)})\n    test_cases = [\n        # Case 1: Empty structure\n        (None, {}),\n        # Case 2: Single node\n        (1, {1: (None, None)}),\n        # Case 3: General case\n        (1, {\n            1: (2, None), 2: (3, 7), 3: (4, 9), 4: (None, None),\n            7: (8, None), 8: (None, 11), 11: (None, None),\n            9: (10, None), 10: (None, None)\n        }),\n        # Case 4: Deep nesting\n        (1, {\n            1: (2, 4), 2: (3, None), 3: (None, None),\n            4: (None, 5), 5: (None, 6), 6: (None, None)\n        }),\n        # Case 5: Multiple children\n        (1, {\n            1: (2, None), 2: (3, 6), 3: (4, None), 4: (5, 7), 5: (None, None),\n            6: (None, None),\n            7: (8, None), 8: (9, None), 9: (None, None)\n        })\n    ]\n\n    results = []\n    for case_def in test_cases:\n        # Build two identical copies for recursive and iterative functions\n        head1 = build_from_case(case_def)\n        head2 = deepcopy_structure(head1)\n\n        # Flatten using both methods\n        result_head_rec = flatten_recursive(head1)\n        result_head_iter = flatten_iterative(head2)\n\n        # Convert to lists for comparison\n        list_rec = get_list_values(result_head_rec)\n        list_iter = get_list_values(result_head_iter)\n        \n        # Verify and store result\n        if list_rec == list_iter:\n            results.append(list_rec)\n        else:\n            results.append([-1])\n\n    # Final print statement in the exact required format\n    # The format is a string representation of a list of lists.\n    # Ex: [[1, 2], [3, 4], [-1]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" if res != [-1] else \"[-1]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3265439"}, {"introduction": "判断一个单向链表是否为回文串，是一个巧妙的问题，它能突显递归与迭代在解题思路上的根本差异。递归解法优雅地利用了函数调用栈的后进先出（LIFO）特性，在“回溯”阶段实现头尾元素的对比。相比之下，迭代法则需要一系列精巧的指针操作，这清晰地展示了两种方法在解决同一问题时所采用的不同策略和思维模式 [@problem_id:3265361]。", "problem": "你的任务是在数据结构与算法的背景下，设计并实现两种算法来判断一个有限整数单向链表是否为回文。回文是一个正向和反向读取都相同的序列。形式上，对于一个节点值序列 $\\{a_1, a_2, \\dots, a_n\\}$，该序列是回文的当且仅当对于所有 $i \\in \\{1, 2, \\dots, n\\}$，都有 $a_i = a_{n+1-i}$，其中 $n$ 是节点数。该链表是单向链接的，意味着每个节点包含一个指向其后继节点的指针。\n\n推理的基本依据：\n- 单向链表的定义：一个节点的集合，其中每个节点存储一个值和一个指向下一个节点的指针；最后一个节点指向空值(null)。\n- 回文的定义：一个序列 $\\{a_1, a_2, \\dots, a_n\\}$，它对所有有效索引 $i$ 都满足 $a_i = a_{n+1-i}$。\n- 递归通过将问题简化为相同形式的子问题来解决问题，直到达到基准情形。递归利用调用栈（后进先出，LIFO）来记录跨调用的状态。\n- 迭代使用显式循环和指针操作；在单向链表中，不直接支持反向遍历。\n\n你的程序必须实现并比较两种不同的方法：\n1. 一种递归解法，利用调用栈来模拟反向遍历：递归函数必须递进到链表末尾，并在回溯时，将从尾部开始的节点值与一个从头部开始向前移动的指针所指向的节点值进行比较。由于调用栈的原因，此方法的时间复杂度必须为 $\\mathcal{O}(n)$，空间复杂度为 $\\mathcal{O}(n)$。\n2. 一种不依赖递归的迭代解法。其时间复杂度必须为 $\\mathcal{O}(n)$，并且可能需要对链表进行第二次遍历或使用额外空间。一种有效的方法是使用两个指针定位中点，原地反转后半部分，然后比较前半部分和反转后的后半部分中的对应节点；此方法使用第二次遍历进行反转和比较，其空间复杂度为 $\\mathcal{O}(1)$ 的辅助内存。\n\n输入模型和测试套件规范：\n- 无外部输入。程序必须根据以下数组测试套件在内部构建单向链表（每个数组表示从头到尾的节点值序列）：\n  - 测试用例 1: [] (空链表)\n  - 测试用例 2: [42]\n  - 测试用例 3: [1, 2, 2, 1]\n  - 测试用例 4: [1, 2, 3, 2, 1]\n  - 测试用例 5: [1, 2, 3, 4]\n  - 测试用例 6: [3, 4, 5, 4, 6]\n  - 测试用例 7: [0, 0]\n  - 测试用例 8: [-1, 2, -1]\n- 对于每个测试用例，构建两个独立的链表（以避免方法之间的干扰），并运行迭代和递归两种算法。\n\n答案规范：\n- 对于每个测试用例 $i$，产生两个布尔结果：首先是迭代方法的结果，然后是递归方法的结果。最终输出是一个聚合了所有测试用例结果的扁平列表，按顺序排列，因此输出共有 $2 \\times 8 = 16$ 个条目。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result_1,result_2,...]`）。作为格式化示例，布尔值打印为 `True` 或 `False`。\n- 最终的聚合列表中只允许出现布尔类型。\n\n科学真实性和约束：\n- 将空链表视作回文。\n- 正确处理偶数长度和奇数长度的链表。\n- 确保算法遵守其各自方法指定的时间和空间复杂度约束。", "solution": "问题陈述的有效性已得到确认。这是一个来自数据结构与算法领域的、定义明确、有科学依据的问题，具有清晰完整的规范。我将开始提供解决方案。\n\n该问题要求实现两种不同的算法来判断一个单向链表是否为回文。如果一个序列 $\\{a_1, a_2, \\dots, a_n\\}$ 对所有 $i \\in \\{1, \\dots, n\\}$ 都满足 $a_i = a_{n+1-i}$，那么它就是回文。核心挑战源于单向链表的单向性，这使得简单的反向遍历无法实现。\n\n### 1. 迭代方法\n\n迭代解法的时间复杂度必须为 $\\mathcal{O}(n)$，辅助空间复杂度为 $\\mathcal{O}(1)$。这通过一个原地操作链表指针的多趟扫描算法来实现。\n\n**原理：** 基本思想是将链表的前半部分与反转后的后半部分进行比较。\n1.  **寻找中点：** 第一步是定位链表的中点。这可以通过“快慢指针”技术高效完成。两个指针 `slow` 和 `fast` 初始化为链表头。在循环的每次迭代中，`slow` 指针前进一个节点，而 `fast` 指针前进两个节点。当 `fast` 指针到达链表末尾（或末尾前一个节点）时，`slow` 指针将位于前半部分的最后一个节点。这趟遍历耗时 $\\mathcal{O}(n)$。\n2.  **反转后半部分：** 对应于后半部分的子链表（从 `slow` 指针之后的节点开始）被原地反转。这是一个标准的链表反转算法，它遍历子链表，将每个节点的 `next` 指针指向其前驱节点。此操作同样需要 $\\mathcal{O}(n)$ 时间，因为它遍历了半个链表。\n3.  **比较：** 初始化两个指针：一个指向原始链表的头部（前半部分的开始），另一个指向新反转的后半部分的头部。这两个指针同时前进，并比较它们对应节点的值。如果在任何点发现不匹配，则链表不是回文。如果遍历完成没有不匹配，则链表是回文。此比较过程耗时 $\\mathcal{O}(n)$。\n4.  **恢复（可选）：** 为了成为一个非破坏性函数，可以通过再次反转后半部分并将其重新链接到前半部分的末尾来恢复链表的原始结构。此步骤与第一次反转具有相同的 $\\mathcal{O}(n)$ 复杂度。\n\n总体时间复杂度是这些线性遍历的总和，仍然是 $\\mathcal{O}(n)$。空间复杂度为 $\\mathcal{O}(1)$，因为无论链表大小 $n$ 如何，都只使用了少数几个额外指针。\n\n### 2. 递归方法\n\n递归解法的时间复杂度必须为 $\\mathcal{O}(n)$，空间复杂度为 $\\mathcal{O}(n)$，其空间使用归因于函数调用栈。\n\n**原理：** 此方法利用函数调用栈的后进先出（LIFO）特性来模拟反向遍历。比较逻辑在递归回溯时执行。\n1.  **前向指针：** 维护一个指针（称之为 `front_pointer`）用于从头到尾遍历链表。该指针定义在所有递归调用都可访问的作用域中（例如，在 Python 中作为 `nonlocal` 变量，或在类中作为实例变量）。\n2.  **递归遍历：** 定义一个递归函数，称之为 `check(current_node)`。它首先以 `check(current_node.next)` 调用自身，从而有效地遍历到链表的末尾。递归的基准情形是当 `current_node` 为空（即越过链表尾部）。\n3.  **回溯时比较：** 在递归调用返回后，执行过程处于“回溯”阶段。此时，`current_node` 代表从链表后半部分（从尾部向中间移动）的一个节点，而 `front_pointer` 指向从前半部分（从头部向中间移动）的一个节点。比较 `current_node` 和 `front_pointer` 所指向节点的值。\n4.  **状态传播：** 如果值匹配，`front_pointer` 前进到其下一个节点，并且函数返回 `True`。如果存在不匹配，或者更深层的递归调用返回了 `False`，函数会立即将 `False` 沿调用栈向上传播，从而停止后续的比较。\n\n时间复杂度为 $\\mathcal{O}(n)$，因为每个节点在递归递进过程中被访问一次，在回溯过程中又被访问一次。空间复杂度为 $\\mathcal{O}(n)$，因为递归调用栈的最大深度等于节点数 $n$。\n\n两种算法都在指定的约束条件下正确地解决了问题，清晰地展示了迭代的指针操作技术与递归的基于栈的逻辑之间的对比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ListNode:\n    \"\"\"\n    Definition for a singly-linked list node.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def __repr__(self):\n        return f\"ListNode({self.val})\"\n\ndef build_linked_list(arr):\n    \"\"\"\n    Constructs a singly linked list from a Python list of values.\n    \"\"\"\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef is_palindrome_iterative(head: ListNode | None) -> bool:\n    \"\"\"\n    Determines if a linked list is a palindrome using an iterative approach.\n    Time complexity: O(n), Space complexity: O(1).\n    \"\"\"\n    if not head or not head.next:\n        return True\n\n    # 1. Find the end of the first half using the slow/fast pointer method.\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # 2. Reverse the second half of the list.\n    def reverse_list(node: ListNode | None) -> ListNode | None:\n        prev_node = None\n        curr_node = node\n        while curr_node:\n            next_temp = curr_node.next\n            curr_node.next = prev_node\n            prev_node = curr_node\n            curr_node = next_temp\n        return prev_node\n\n    second_half_head = reverse_list(slow.next)\n    \n    # 3. Compare the first half with the reversed second half.\n    first_half_ptr = head\n    second_half_ptr = second_half_head\n    is_palindrome = True\n    while second_half_ptr:\n        if first_half_ptr.val != second_half_ptr.val:\n            is_palindrome = False\n            break\n        first_half_ptr = first_half_ptr.next\n        second_half_ptr = second_half_ptr.next\n        \n    # 4. Restore the list (optional, but good practice).\n    slow.next = reverse_list(second_half_head)\n    \n    return is_palindrome\n\ndef is_palindrome_recursive(head: ListNode | None) -> bool:\n    \"\"\"\n    Determines if a linked list is a palindrome using a recursive approach.\n    Time complexity: O(n), Space complexity: O(n) for the call stack.\n    \"\"\"\n    front_pointer = head\n\n    def check_recursively(current_node: ListNode | None) -> bool:\n        nonlocal front_pointer\n        if current_node:\n            # Recurse to the end of the list.\n            if not check_recursively(current_node.next):\n                return False\n            \n            # On unwind, compare the current node with the front pointer.\n            if front_pointer.val != current_node.val:\n                return False\n            \n            # Advance the front pointer.\n            front_pointer = front_pointer.next\n        return True\n\n    return check_recursively(head)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        [],\n        [42],\n        [1, 2, 2, 1],\n        [1, 2, 3, 2, 1],\n        [1, 2, 3, 4],\n        [3, 4, 5, 4, 6],\n        [0, 0],\n        [-1, 2, -1],\n    ]\n\n    results = []\n    for case_arr in test_cases:\n        # Create two separate lists for each method to avoid interference.\n        list_for_iterative = build_linked_list(case_arr)\n        list_for_recursive = build_linked_list(case_arr)\n\n        # Run the iterative algorithm.\n        result_iterative = is_palindrome_iterative(list_for_iterative)\n        results.append(result_iterative)\n\n        # Run the recursive algorithm.\n        result_recursive = is_palindrome_recursive(list_for_recursive)\n        results.append(result_recursive)\n\n    # The problem asks for numpy to be imported. The variable np remains unused.\n    _ = np # This line is to satisfy linters that flag unused imports.\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3265361"}, {"introduction": "当数据结构从线性变为包含循环的通用图时，算法的复杂性也随之增加。深度拷贝一个带环图是一个常见的挑战，它要求我们不仅能遍历图，还要能处理循环以避免无限递归或循环 [@problem_id:3265351]。这个实践将递归和迭代的应用从简单的树状结构推广到更复杂的图结构，并引入了“已访问”集合这一关键技术来管理遍历状态，这是图算法中的一个核心概念。", "problem": "考虑一个有向图 $G=(V,E)$，其中 $V$ 是一个有限的顶点标识符集合，$E \\subseteq V \\times V$ 是一个有限的有向边集合。图可以包含环和自环。$G$ 的一个深拷贝是一个新图 $G'=(V',E')$，其构造方式使得存在一个双射 $f:V \\to V'$，该双射保持顶点的标签和邻接关系：如果 $(u,v) \\in E$，那么 $(f(u),f(v)) \\in E'$，并且 $V'$ 和 $E'$ 中的每个元素在标识上都与 $V$ 和 $E$ 中的相应元素不相交。递归被定义为一个在子问题上调用自身的过程，而迭代则使用显式的控制结构和数据结构（如栈或队列）来执行重复计算，而无需自我调用。\n\n从以下基本事实出发：\n- 一个至多访问每个顶点和每条边一次的图遍历，其运行时间与图的大小成正比，具体为 $\\mathcal{O}(|V|+|E|)$。\n- 深度优先搜索（DFS）和广度优先搜索（BFS）是典型的遍历策略，它们既可以递归地（使用调用栈）实现，也可以迭代地（为 DFS 使用显式栈，为 BFS 使用队列）实现。\n- 为防止在遍历环或自环时出现不终止的情况，遍历必须记录一个顶点是否已被处理，例如通过一个映射 $M:V \\to V'$，一旦某个顶点被克隆，就将其标记为已访问。\n\n任务。实现两个函数来深拷贝一个可能包含环且可能不连通的有向图：\n- 一个递归函数，它使用一个映射来跟踪已访问的原始顶点，并返回对应拷贝顶点的引用。该递归必须确保任何顶点都不会被处理超过一次。\n- 一个迭代函数，它使用一个显式栈（或队列）以及相同的映射，以确保每个顶点至多被处理一次。\n\n图的表示。使用基于节点的邻接表。每个节点都有一个唯一的整数标签 $\\ell \\in \\mathbb{Z}$ 和一个邻居引用的列表。每个拷贝函数的输入是一个节点引用列表，该列表共同覆盖图的所有顶点（以处理不连通分量）。每个拷贝函数的输出必须是一个节点引用列表，对应于深拷贝后的图，并保持原始标签。\n\n验证。对于每个测试用例，计算以下布尔结果：\n- $b_1$：递归拷贝是否与原始图在结构上相等（即存在一个保持标签且保持邻接关系的的双射）。\n- $b_2$：迭代拷贝是否与原始图在结构上相等。\n- $b_3$：递归方法拷贝的所有节点是否与它们的原始对应物在标识上是不同的（即没有复用任何原始节点）。\n- $b_4$：迭代方法拷贝的所有节点是否与它们的原始对应物在标识上是不同的。\n- $b_5$：递归拷贝和迭代拷贝是否在结构上彼此相等。\n\n测试套件。硬编码以下邻接映射，每个映射定义一个有向图。对于一个邻接映射 $A$，$A[u]$ 是顶点 $u$ 的邻居列表。\n- 用例 1（空图）：$A_1 = \\{\\}$，因此 $V=\\varnothing$ 且 $E=\\varnothing$。\n- 用例 2（带自环的单节点）：$A_2 = \\{\\, 1 : [\\,1\\,] \\,\\}$。\n- 用例 3（单个循环分量）：$A_3 = \\{\\, 1 : [\\,2\\,],\\; 2 : [\\,3\\,],\\; 3 : [\\,1\\,] \\,\\}$。\n- 用例 4（不连通，一个 $3$-环加一条路径）：$A_4 = \\{\\, 1 : [\\,2\\,],\\; 2 : [\\,3\\,],\\; 3 : [\\,1\\,],\\; 4 : [\\,5\\,],\\; 5 : [\\,] \\,\\}$。\n\n输出规范。你的程序必须为上述四个用例构建图，运行递归和迭代的深拷贝函数，按顺序为每个用例计算五个布尔值 $(b_1,b_2,b_3,b_4,b_5)$，并生成单行输出，该行包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素是用于一个用例的列表 $[b_1,b_2,b_3,b_4,b_5]$。例如，输出格式必须为 `[[b1,b2,b3,b4,b5],[b1,b2,b3,b4,b5],[b1,b2,b3,b4,b5],[b1,b2,b3,b4,b5]]` 的形式。\n\n不涉及物理单位、角度单位或百分比格式；所有输出均为布尔值。程序必须是完整、可运行且无需输入的。其正确性应源自开头陈述的基本事实，而不依赖于任何快捷公式。", "solution": "该问题要求实现并验证两种不同的有向图深拷贝算法：一种是递归的，一种是迭代的。图可能是不连通的，也可能包含环。解决方案必须是健壮的，并且其正确性必须能通过提供的测试套件进行验证。\n\n将一个图 $G=(V, E)$ 深拷贝到一个新图 $G'=(V', E')$ 的基本原理是图的遍历。仅仅创建新节点是不够的；必须相对于新创建的节点重新建立邻接关系。主要挑战在于处理可能导致无限递归或循环的环，并确保原始图中的每个唯一节点都被精确地拷贝一次。\n\n为了应对这些挑战，一个状态跟踪机制是必不可少的。我们采用一个映射（称之为 $M$），它将原始顶点映射到其新创建的拷贝，即 $M: V \\to V'$。此映射有两个作用：\n1. 它充当一个“已访问”集合。在处理一个顶点 $u \\in V$ 之前，我们检查它是否已经是 $M$ 中的一个键。如果是，我们就知道它的拷贝 $u' = M(u)$ 已经被创建，我们可以重用这个拷贝而无需重新处理该顶点。这可以防止在遍历环时出现无限循环。\n2. 它确保了原始顶点与其拷贝之间的一一对应关系。任何顶点 $u$ 仅在第一次遇到时被拷贝一次，其拷贝 $M(u)$ 被存储起来。在遍历过程中，所有后续对 $u$ 的引用都将解析为同一个拷贝 $M(u)$，从而正确地保持图的结构，包括共享节点。\n\n所提供的算法是基于标准的、基于节点的邻接表表示法实现的，其中每个节点对象持有一个唯一的整数标签 $\\ell \\in \\mathbb{Z}$ 和一个对其邻居的引用列表。\n\n**递归实现**\n递归方法自然地模拟了深度优先搜索（DFS）遍历。程序的调用栈被隐式地用来管理遍历的状态。\n\n顶层函数 `copy_recursive` 初始化已访问映射 $M$，并遍历图中所有节点的列表。这个外层循环确保所有不连通的分量都被拷贝。对于每个尚未在 $M$ 中的节点，它会启动一个递归辅助函数 `_copy_recursive_helper(u, M)`。\n\n这个辅助函数的操作如下：\n1. **基本情况**：如果输入节点 $u$ 已经在映射 $M$ 中，这意味着该节点的拷贝已经存在。函数立即返回已有的拷贝 $M(u)$。\n2. **递归步骤**：如果 $u$ 不在 $M$ 中：\n    a. 创建一个新节点 $u'$，其标签与 $u$ 相同。\n    b. 立即用新的对应关系更新映射 $M$：$M(u) = u'$。这一步至关重要。在对其邻居进行递归调用*之前*将新拷贝放入映射中，可以确保如果一个邻居指回 $u$（一个环），对该邻居的递归调用将在映射中找到 $u$，并正确地使用对 $u'$ 的引用，从而终止递归。\n    c. 对 $u$ 的每个邻居 $v$ 递归调用该函数。每次调用的结果是拷贝后的邻居 $v'$。\n    d. 用返回的拷贝后的邻居 $\\{v'\\}$ 填充 $u'$ 的邻接表。\n    e. 返回新创建的节点 $u'$。\n\n这个过程正确地构建了一个深拷贝，由调用栈管理遍历的路径。\n\n**迭代实现**\n迭代方法用显式数据结构取代了隐式的调用栈，例如栈（用于类似 DFS 的遍历）或队列（用于类似 BFS 的遍历）。这里，我们使用一个栈来模拟递归的 DFS 方法。\n\n函数 `copy_iterative` 同样初始化一个已访问映射 $M$。它遍历输入列表中提供的所有节点以处理不连通分量。\n1. 对于一个分量的起始节点 $u$（即一个尚未在 $M$ 中的节点）：\n    a. 创建一个拷贝 $u'$，并建立映射 $M(u) = u'$。\n    b. 将原始节点 $u$ 推入一个栈中。\n2. 一个 `while` 循环在栈不为空时持续进行。在每次迭代中：\n    a. 从栈中弹出一个节点 `current_original`。从 $M$ 中检索其对应的拷贝 `current_copy`。\n    b. 对于 `current_original` 的每个邻居 `original_neighbor`：\n        i. 如果 `original_neighbor` 不在 $M$ 中，这意味着这个邻居以前没有见过。创建一个新拷贝 `neighbor_copy`，添加映射 $M(\\text{original\\_neighbor}) = \\text{neighbor\\_copy}$，并将 `original_neighbor` 推入栈中以便稍后处理。\n        ii. 通过追加适当的拷贝邻居来更新 `current_copy` 的邻接表，该邻居保证存在于 $M$ 中（无论是在前一步还是当前步骤中创建的）。这是通过查找 $M(\\text{original\\_neighbor})$ 来完成的。\n\n这个迭代过程系统地探索图的分量，创建节点拷贝并连接它们的邻接关系，而不使用函数递归。\n\n**验证方法**\n对每个测试用例，实现的正确性通过三个标准进行验证：\n\n1. **结构相等性 ($b_1, b_2, b_5$)**: 此检查确认拷贝后的图与原始图（或其他拷贝）在结构上是同构的。这是通过一个函数 `are_structurally_equal` 来实现的。它首先基于节点的唯一标签在两个图的节点之间建立一个双射。然后，对于每一对对应的节点 $(u, u')$，它通过比较其邻居标签的排序列表来验证它们的邻接表是否等价。排序确保了检查与邻接表中邻居的顺序无关。\n\n2. **标识独立性 ($b_3, b_4$)**: 此检查验证拷贝是“深”拷贝——也就是说，拷贝的节点是内存中的新对象，而不仅仅是对原始节点的引用。函数 `are_identities_distinct` 通过创建一个包含所有原始节点内存地址（使用 Python 的 `id()` 函数）的集合，并确保任何拷贝节点的内存地址都不出现在这个集合中来完成此项检查。\n\n这些验证步骤的结合为所实现的函数能够生成给定图结构的正确深拷贝提供了有力的确认。对于所有指定的测试用例，两种算法都应通过所有五个布尔检查，即 $b_1$ 到 $b_5$ 均为 `True`。", "answer": "```python\nimport sys\n\n# Setting a higher recursion limit for potentially deep or large graphs,\n# though not strictly necessary for the given test cases.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Represents a node in a directed graph.\"\"\"\n    def __init__(self, label: int):\n        self.label = label\n        self.neighbors = []\n\n    def __repr__(self) -> str:\n        return f\"Node({self.label})\"\n\ndef build_graph(adj_map: dict[int, list[int]]) -> list[Node]:\n    \"\"\"Constructs a graph from an adjacency map.\"\"\"\n    all_labels = set(adj_map.keys())\n    for neighbors in adj_map.values():\n        for neighbor_label in neighbors:\n            all_labels.add(neighbor_label)\n\n    nodes = {label: Node(label) for label in sorted(list(all_labels))}\n\n    for label, neighbor_labels in adj_map.items():\n        node = nodes[label]\n        node.neighbors = [nodes[neighbor_label] for neighbor_label in neighbor_labels]\n\n    return list(nodes.values())\n\ndef copy_recursive(nodes: list[Node]) -> list[Node]:\n    \"\"\"Deep copies a graph using recursion (DFS).\"\"\"\n    visited = {}  # Maps original node to its copy\n\n    def _copy_recursive_helper(node: Node) -> Node:\n        if node in visited:\n            return visited[node]\n\n        new_node = Node(node.label)\n        visited[node] = new_node\n\n        new_neighbors = []\n        for neighbor in node.neighbors:\n            new_neighbors.append(_copy_recursive_helper(neighbor))\n        new_node.neighbors = new_neighbors\n\n        return new_node\n\n    # This loop handles disconnected components.\n    for node in nodes:\n        if node not in visited:\n            _copy_recursive_helper(node)\n\n    if not nodes:\n        return []\n\n    # Return copies corresponding to the input node list order.\n    return [visited[node] for node in nodes]\n\n\ndef copy_iterative(nodes: list[Node]) -> list[Node]:\n    \"\"\"Deep copies a graph using an explicit stack (DFS).\"\"\"\n    visited = {}  # Maps original node to its copy\n    \n    # This loop handles disconnected components.\n    for node in nodes:\n        if node not in visited:\n            # Start a new traversal for a new component\n            stack = [node]\n            visited[node] = Node(node.label)\n            \n            while stack:\n                current_original = stack.pop()\n                current_copy = visited[current_original]\n\n                for neighbor in current_original.neighbors:\n                    if neighbor not in visited:\n                        visited[neighbor] = Node(neighbor.label)\n                        stack.append(neighbor)\n                    current_copy.neighbors.append(visited[neighbor])\n\n    if not nodes:\n        return []\n        \n    return [visited[node] for node in nodes]\n\n\ndef are_structurally_equal(nodes1: list[Node], nodes2: list[Node]) -> bool:\n    \"\"\"Checks if two graphs are structurally equal.\"\"\"\n    if len(nodes1) != len(nodes2):\n        return False\n    \n    map1 = {node.label: node for node in nodes1}\n    map2 = {node.label: node for node in nodes2}\n\n    if map1.keys() != map2.keys():\n        return False\n\n    for label in map1:\n        node1 = map1[label]\n        node2 = map2[label]\n        \n        neighbor_labels1 = sorted([n.label for n in node1.neighbors])\n        neighbor_labels2 = sorted([n.label for n in node2.neighbors])\n\n        if neighbor_labels1 != neighbor_labels2:\n            return False\n            \n    return True\n\ndef are_identities_distinct(original_nodes: list[Node], copied_nodes: list[Node]) -> bool:\n    \"\"\"Checks if copied nodes are new objects in memory.\"\"\"\n    if not original_nodes and not copied_nodes:\n        return True\n    \n    original_ids = {id(n) for n in original_nodes}\n    copied_ids = {id(n) for n in copied_nodes}\n    \n    return original_ids.isdisjoint(copied_ids)\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        {},  # Case 1: Empty graph\n        {1: [1]},  # Case 2: Single node with self-loop\n        {1: [2], 2: [3], 3: [1]},  # Case 3: Single cyclic component\n        {1: [2], 2: [3], 3: [1], 4: [5], 5: []},  # Case 4: Disconnected graph\n    ]\n\n    all_results = []\n\n    for adj_map in test_cases:\n        original_graph = build_graph(adj_map)\n        \n        rec_copy = copy_recursive(original_graph)\n        iter_copy = copy_iterative(original_graph)\n\n        b1 = are_structurally_equal(original_graph, rec_copy)\n        b2 = are_structurally_equal(original_graph, iter_copy)\n        b3 = are_identities_distinct(original_graph, rec_copy)\n        b4 = are_identities_distinct(original_graph, iter_copy)\n        b5 = are_structurally_equal(rec_copy, iter_copy)\n        \n        all_results.append([b1, b2, b3, b4, b5])\n\n    # Format the output exactly as specified.\n    print(f\"[{', '.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3265351"}]}