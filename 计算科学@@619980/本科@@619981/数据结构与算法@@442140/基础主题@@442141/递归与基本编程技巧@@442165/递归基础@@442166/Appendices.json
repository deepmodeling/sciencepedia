{"hands_on_practices": [{"introduction": "编写递归函数是一回事，而理解其效率则是另一回事。许多递归算法的性能可以通过主定理（Master Theorem）轻松分析，但当递推关系不符合其标准形式时，我们就需要更基本的工具。这个练习将挑战你分析一个非典型的递推关系 $T(n) = T(\\sqrt{n}) + \\ln n$，通过使用一种称为“展开法”或“代入法”的基础技巧，来精确求解其时间复杂度。掌握这种分析方法，是任何严肃的算法设计者和程序员必备的核心技能。[@problem_id:3264680]", "problem": "考虑一个作用于大小为 $n$ 的输入的递归过程，该过程在对大小为 $\\sqrt{n}$ 的输入进行单次递归调用前，会执行恰好 $\\ln n$ 次基本操作，并在输入大小达到 2 时终止。设 $T(n)$ 表示该过程在输入大小为 $n$ 时执行的基本操作的精确次数，包括所有递归调用。假设基本情况的成本为 $T(2)$，一个固定常数，并且 $\\ln$ 表示自然对数。为避免由平方根递归引起的舍入问题，假设输入大小被限制在集合 $\\{2^{2^{k}} : k \\in \\mathbb{N}, k \\geq 0\\}$ 中，以使每次递归调用都恰好落在一个整数上，直到达到基本情况 2。\n\n请从递归作为重复自我归约的基本定义以及每次调用操作的精确计数出发，在所述假设下，推导 $T(n)$ 关于 $n$ 和 $T(2)$ 的闭式表达式。你的答案必须是一个精确的解析表达式，而非渐近形式，并且应该使用自然对数表示。", "solution": "问题陈述已经过分析并被确定为有效。这是一个算法分析领域中的适定问题，没有科学或逻辑上的不一致之处。所提供的假设，特别是对于输入大小 $n$ 的定义域限制，确保了递推关系可以被精确无歧义地求解。\n\n该问题描述了一个递归过程。设 $T(n)$ 为输入大小为 $n$ 时的基本操作总数。该过程执行 $\\ln n$ 次操作，然后对大小为 $\\sqrt{n}$ 的输入进行递归调用。因此，总成本 $T(n)$ 是当前步骤的成本与递归子问题成本之和。这可以表示为以下递推关系：\n$$T(n) = \\ln(n) + T(\\sqrt{n})$$\n当输入大小达到 2 时，递归终止，此时成本为一个常数，记为 $T(2)$。这为递推关系提供了基本情况。\n\n为了找到 $T(n)$ 的闭式表达式，我们可以使用重复代入法，也称为展开法或迭代法。\n\n从 $T(n)$ 的递推关系开始：\n$$T(n) = \\ln(n) + T(n^{1/2})$$\n我们代入递归项 $T(n^{1/2})$ 的表达式：\n$$T(n^{1/2}) = \\ln(n^{1/2}) + T((n^{1/2})^{1/2}) = \\ln(n^{1/2}) + T(n^{1/4})$$\n将此代回 $T(n)$ 的方程中：\n$$T(n) = \\ln(n) + \\ln(n^{1/2}) + T(n^{1/4})$$\n使用对数性质 $\\ln(x^y) = y \\ln(x)$，上式变为：\n$$T(n) = \\ln(n) + \\frac{1}{2}\\ln(n) + T(n^{1/4})$$\n我们可以重复这个代入过程。下一步得到：\n$$T(n) = \\ln(n) + \\frac{1}{2}\\ln(n) + \\ln(n^{1/4}) + T(n^{1/8})$$\n$$T(n) = \\ln(n) + \\frac{1}{2}\\ln(n) + \\frac{1}{4}\\ln(n) + T(n^{1/8})$$\n一个清晰的模式出现了。经过 $m$ 步展开后，$T(n)$ 的表达式为：\n$$T(n) = \\ln(n) \\left(1 + \\frac{1}{2} + \\frac{1}{4} + \\dots + \\frac{1}{2^{m-1}}\\right) + T(n^{1/2^m})$$\n$$T(n) = \\ln(n) \\sum_{i=0}^{m-1} \\left(\\frac{1}{2}\\right)^i + T(n^{1/2^m})$$\n当输入大小达到基本情况 2 时，递归终止。我们需要找到发生这种情况所需的步数 $m$。\n$$n^{1/2^m} = 2$$\n为求解 $m$，我们对两边取自然对数：\n$$\\ln(n^{1/2^m}) = \\ln(2)$$\n$$\\frac{1}{2^m} \\ln(n) = \\ln(2)$$\n对 $\\frac{1}{2^m}$ 进行整理可得：\n$$\\frac{1}{2^m} = \\frac{\\ln(2)}{\\ln(n)}$$\n展开式中的项 $T(n^{1/2^m})$ 变为 $T(2)$。\n\n$T(n)$ 表达式中的和是一个有限几何级数：\n$$S_m = \\sum_{i=0}^{m-1} \\left(\\frac{1}{2}\\right)^i = \\frac{1 - (1/2)^m}{1 - 1/2}$$\n$$S_m = \\frac{1 - (1/2)^m}{1/2} = 2\\left(1 - \\left(\\frac{1}{2}\\right)^m\\right)$$\n现在我们将这个和代回 $T(n)$ 的方程中：\n$$T(n) = \\ln(n) \\cdot 2\\left(1 - \\left(\\frac{1}{2}\\right)^m\\right) + T(2)$$\n我们可以使用之前推导出的关系 $\\frac{1}{2^m} = \\frac{\\ln(2)}{\\ln(n)}$ 来替换项 $(1/2)^m$：\n$$T(n) = 2\\ln(n) \\left(1 - \\frac{\\ln(2)}{\\ln(n)}\\right) + T(2)$$\n将 $2\\ln(n)$ 项分配到括号中：\n$$T(n) = 2\\ln(n) \\cdot 1 - 2\\ln(n) \\cdot \\frac{\\ln(2)}{\\ln(n)} + T(2)$$\n$$T(n) = 2\\ln(n) - 2\\ln(2) + T(2)$$\n使用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$，这可以更紧凑地写为：\n$$T(n) = 2(\\ln(n) - \\ln(2)) + T(2) = 2\\ln\\left(\\frac{n}{2}\\right) + T(2)$$\n为确保正确性，我们可以将此闭式解代回原始递推关系 $T(n) = \\ln(n) + T(\\sqrt{n})$ 进行验证：\n\\begin{align*}\n\\text{右端} = \\ln(n) + T(\\sqrt{n}) \\\\\n= \\ln(n) + \\left(2\\ln(\\sqrt{n}) - 2\\ln(2) + T(2)\\right) \\\\\n= \\ln(n) + \\left(2\\ln(n^{1/2}) - 2\\ln(2) + T(2)\\right) \\\\\n= \\ln(n) + \\left(2 \\cdot \\frac{1}{2}\\ln(n) - 2\\ln(2) + T(2)\\right) \\\\\n= \\ln(n) + \\ln(n) - 2\\ln(2) + T(2) \\\\\n= 2\\ln(n) - 2\\ln(2) + T(2)\n\\end{align*}\n这个结果与我们推导出的 $T(n)$ 表达式相匹配，证实了解是正确的。基本情况的检验 $T(2) = 2\\ln(2) - 2\\ln(2) + T(2) = T(2)$ 也成立。假设 $n$ 属于集合 $\\{2^{2^{k}} : k \\in \\mathbb{N}, k \\geq 0\\}$ 保证了 $T$ 的参数在取平方根时始终是 2 的整数次幂，直到达到 2。\n例如，如果 $n=2^{2^k}$，则 $\\sqrt{n}=2^{2^{k-1}}$，依此类推，经过 $k$ 步后达到 $2^{2^0}=2$。这验证了我们推导的结构。\n\n$T(n)$ 的最终闭式表达式是 $n$ 和常数 $T(2)$ 的函数。", "answer": "$$\\boxed{2\\ln(n) - 2\\ln(2) + T(2)}$$", "id": "3264680"}, {"introduction": "汉诺塔问题是阐释递归思想优雅与力量的经典范例。本练习在这一经典问题之上增加了一个有趣的“转折”——一个特定的约束条件，迫使我们对算法的内在逻辑进行更深层次的剖析。这不仅是一个代码挑战，更是一个思想实验，旨在检验你是否真正理解了递归如何将问题分解为子问题，以及在递归的每一层中，问题的状态是如何被维护和传递的。通过分析这个约束如何与标准解法的每一步相互作用，你将对递归过程获得更深刻的洞察。[@problem_id:3264714]", "problem": "考虑经典汉诺塔问题，有三根柱子，分别标记为 $S$ (源)、$A$ (辅助) 和 $T$ (目标)，以及 $n$ 个盘子，标记为 $1, 2, \\dots, n$，其中盘子 $1$ 最小，盘子 $n$ 最大。最初，所有 $n$ 个盘子都堆叠在柱子 $S$ 上，从上（小）到下（大）按尺寸递增的顺序排列。一次合法的移动指将一个盘子从一根柱子的顶部移动到另一根柱子的顶部，并且在任何时候，都不能将盘子放在比它小的盘子上面。\n\n在这些规则之外，施加一个约束，即特定的盘子 $k$ 在整个过程中任何时候都不能占据柱子 $A$。你必须将整个盘子堆从柱子 $S$ 移动到柱子 $T$，同时遵守所有规则和附加的约束。\n\n假设 $k = n$，因此被禁止的盘子是最大的那个。请以闭合形式确定完成此任务所需的最少移动次数，作为 $n$ 的函数。请以单一解析表达式的形式给出最终答案，不要进行四舍五入或近似计算。", "solution": "对问题陈述进行严格验证如下：\n1.  **提取已知条件**：\n    - 一个包含 $3$ 根柱子的系统：源柱 $S$、辅助柱 $A$ 和目标柱 $T$。\n    - 一组 $n$ 个盘子，按尺寸递增顺序标记为 $1, 2, \\dots, n$。\n    - 初始状态：所有 $n$ 个盘子都在柱子 $S$ 上。\n    - 最终状态：所有 $n$ 个盘子都在柱子 $T$ 上。\n    - 汉诺塔的标准规则：\n        i. 一次只能移动一个盘子。\n        ii. 一次移动包括从一个柱子堆的顶部取下最上面的盘子，并将其放置在另一个柱子堆的顶部。\n        iii. 不得将盘子放在比它小的盘子之上。\n    - 附加约束：特定盘子 $k$ 永远不得占据柱子 $A$。\n    - 本问题的具体实例：被禁止的盘子是最大的那个，即 $k=n$。\n    - 目标：确定将所有 $n$ 个盘子从 $S$ 移动到 $T$ 所需的最少移动次数。\n\n2.  **验证结论**：\n    - 该问题是**有效的**。它是离散数学和算法中的一个经典问题（汉诺塔）的适定变体。它自成体系、逻辑一致，并且没有科学或事实上的不健全之处。该约束虽然修改了问题空间，但没有引入矛盾或使问题无法解决。目标定义明确，旨在寻求一个确定的数学量。\n\n求解过程如下。\n\n设 $N(n, S, A, T)$ 表示在盘子 $n$ 永远不能放置在柱子 $A$ 上的约束下，使用辅助柱 $A$ 将 $n$ 个盘子从源柱 $S$ 移动到目标柱 $T$ 所需的最少移动次数。\n\n将 $n$ 个盘子的整个塔从柱子 $S$ 移动到柱子 $T$ 的过程，在某个时刻必然涉及最大盘子（盘子 $n$）的移动。要将盘子 $n$ 从 $S$ 移走，唯一的方法是所有较小的盘子（即盘子 $1, 2, \\dots, n-1$）都不在柱子 $S$ 上。此外，为了将盘子 $n$ 移动到其最终目的地 $T$，柱子 $T$ 上不能有任何较小的盘子。因此，为了能够将盘子 $n$ 从 $S$ 移动到 $T$，所有 $n-1$ 个较小的盘子必须位于唯一剩下的柱子 $A$ 上。\n\n因此，整个过程可以分解为三个不同的、顺序的阶段：\n\n**阶段 1：将盘子 $1, 2, \\dots, n-1$ 从柱子 $S$ 移动到柱子 $A$。**\n- 在此阶段，最大的盘子 $n$ 停留在柱子 $S$ 的底部。\n- 约束规定盘子 $n$ 不能占据柱子 $A$。由于在此阶段盘子 $n$ 未被移动，因此没有违反该约束。\n- 盘子 $1, 2, \\dots, n-1$ 不受此特定约束的限制，只要遵守标准规则，它们可以根据需要自由使用 $S$、$A$ 和 $T$ 这三根柱子。\n- 因此，此阶段等同于解决一个标准的汉诺塔问题，其中有 $n-1$ 个盘子， $S$ 为源柱， $A$ 为目标柱， $T$ 为辅助柱。\n- 对于有 $m$ 个盘子的标准汉诺塔问题，最少移动次数为 $2^m - 1$。对于此阶段， $m = n-1$，移动次数为 $2^{n-1} - 1$。\n\n**阶段 2：将盘子 $n$ 从柱子 $S$ 移动到柱子 $T$。**\n- 阶段 1 之后，柱子 $S$ 的顶部是盘子 $n$，而柱子 $T$ 是空的。根据标准规则，此移动是合法的。\n- 约束是盘子 $n$ 不得放置在柱子 $A$ 上。移动是从 $S$ 到 $T$，因此满足此约束。\n- 此阶段仅包含一次移动。移动次数为 $1$。\n\n**阶段 3：将盘子 $1, 2, \\dots, n-1$ 从柱子 $A$ 移动到柱子 $T$。**\n- 阶段 2 之后，盘子 $n$ 位于柱子 $T$ 的底部，并在接下来的过程中一直保持在该位置。\n- 任务是将 $n-1$ 个盘子从柱子 $A$ 移动到柱子 $T$。\n- 由于盘子 $n$ 不会被移动，对其的约束自然得到满足。\n- 盘子 $1, 2, \\dots, n-1$ 可以自由使用任何柱子。\n- 此阶段构成一个标准的汉诺塔问题，其中有 $n-1$ 个盘子， $A$ 为源柱， $T$ 为目标柱， $S$ 为辅助柱。\n- 此阶段所需的最少移动次数同样为 $2^{n-1} - 1$。\n\n总的最少移动次数 $N(n, S, A, T)$ 是这三个阶段移动次数的总和：\n$$N(n, S, A, T) = (\\text{阶段 1 的移动次数}) + (\\text{阶段 2 的移动次数}) + (\\text{阶段 3 的移动次数})$$\n$$N(n, S, A, T) = (2^{n-1} - 1) + 1 + (2^{n-1} - 1)$$\n$$N(n, S, A, T) = 2 \\cdot (2^{n-1}) - 2 + 1$$\n$$N(n, S, A, T) = 2^n - 1$$\n\n为确认此解是最小的，我们注意到所描述的移动序列与解决无约束汉诺塔问题的标准递归算法完全对应。一个基本结论是，这个标准算法是最优的，需要 $2^n-1$ 次移动。由于有约束问题的合法移动序列集是无约束问题合法序列集的子集，因此有约束问题的最少移动次数必须大于或等于无约束问题的最少移动次数。既然我们找到了一个长度为 $2^n-1$ 的有约束问题的有效序列，这必然是最少移动次数。对于 $k=n$ 的特定情况，附加的约束并未改变最优策略或最少移动次数。", "answer": "$$\\boxed{2^n - 1}$$", "id": "3264714"}]}