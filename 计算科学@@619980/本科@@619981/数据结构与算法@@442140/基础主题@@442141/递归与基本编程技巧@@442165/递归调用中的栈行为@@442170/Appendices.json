{"hands_on_practices": [{"introduction": "理论上理解递归是一回事，但亲眼见证其物理限制则是另一回事。第一个练习将通过计算在有限的栈内存下所能达到的最大递归深度，来帮助你弥合理论与实践之间的差距。通过解决这个问题[@problem_id:3274462]，你将对每次递归调用如何消耗内存，以及为何“无限”递归会导致栈溢出错误，建立起一个具体的直观认识。", "problem": "考虑一个单线程程序，它运行在一个为每个线程强制设定了固定栈大小限制的操作系统上。一个递归函数在没有尾调用优化的情况下被编译，并且在每次调用时，在其栈帧上分配一个大小为 $1 \\text{ kilobyte}$ 的局部对象。假设没有其他局部变量，并且任何每帧的固定开销（例如保存的返回地址和帧指针）相对于所分配的对象来说都可以忽略不计，因此每次调用的主要栈使用量是这个 $1 \\text{ kilobyte}$ 的对象。该线程的栈被限制为 $2 \\text{ megabytes}$，并且此外未被使用。\n\n根据关于递归中栈帧分配的基本原理，以及二进制定义 $1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$ 和 $1 \\text{ megabyte} = 2^{20} \\text{ bytes}$，确定在不导致栈溢出的情况下可以实现的最大递归深度（同时活动的递归调用数）。\n\n以单个整数形式提供你的答案。无需四舍五入。", "solution": "问题要求在给定的栈使用限制下，计算一个函数的最大递归深度。我们已知可用的总栈大小以及每次递归调用消耗的栈空间量。解决方案需要计算有多少个这样的栈帧可以放入可用的总栈空间中。\n\n设 $S_{\\text{total}}$ 为线程的总栈大小限制。\n设 $S_{\\text{frame}}$ 为每次递归函数调用所分配的栈空间（即一个栈帧的大小）。\n设 $D_{\\text{max}}$ 为最大递归深度。\n\n根据题目描述，我们已知：\n总栈大小为 $S_{\\text{total}} = 2 \\text{ megabytes}$。\n每次调用的栈使用量主要由一个大小为 $S_{\\text{frame}} = 1 \\text{ kilobyte}$ 的局部对象决定。题目说明可以忽略任何其他开销。\n题中给出了单位的二进制定义：\n$1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$\n$1 \\text{ megabyte} = 2^{20} \\text{ bytes}$\n\n为了找到最大递归深度，我们必须首先将总栈大小和每帧的栈使用量用相同的单位表示，我们选择字节作为单位。\n\n首先，我们将总栈大小 $S_{\\text{total}}$ 转换为字节：\n$$S_{\\text{total}} = 2 \\text{ megabytes} = 2 \\times (1 \\text{ megabyte}) = 2 \\times (2^{20} \\text{ bytes})$$\n使用指数性质 $a^m \\times a^n = a^{m+n}$，其中 $a=2$，$m=1$，$n=20$：\n$$S_{\\text{total}} = 2^1 \\times 2^{20} \\text{ bytes} = 2^{1+20} \\text{ bytes} = 2^{21} \\text{ bytes}$$\n\n接下来，我们将每帧的栈使用量 $S_{\\text{frame}}$ 转换为字节：\n$$S_{\\text{frame}} = 1 \\text{ kilobyte} = 1 \\times (1 \\text{ kilobyte}) = 1 \\times (2^{10} \\text{ bytes}) = 2^{10} \\text{ bytes}$$\n\n最大递归深度 $D_{\\text{max}}$ 是在超过总栈大小限制之前可以分配的栈帧总数。由于题目指明栈此外未被使用且每帧开销可忽略不计，我们可以通过将可用的总栈大小除以单个栈帧的大小来求得 $D_{\\text{max}}$。\n$$D_{\\text{max}} = \\frac{S_{\\text{total}}}{S_{\\text{frame}}}$$\n\n代入以字节为单位的值：\n$$D_{\\text{max}} = \\frac{2^{21} \\text{ bytes}}{2^{10} \\text{ bytes}}$$\n\n使用指数性质 $\\frac{a^m}{a^n} = a^{m-n}$，其中 $a=2$，$m=21$，$n=10$：\n$$D_{\\text{max}} = 2^{21-10} = 2^{11}$$\n\n最后，我们计算 $2^{11}$ 的整数值：\n$$2^{11} = 2 \\times 2^{10} = 2 \\times 1024 = 2048$$\n\n因此，在不导致栈溢出的情况下可以实现的最大递归深度是 $2048$。这代表了同时活动的递归调用的总数。", "answer": "$$\\boxed{2048}$$", "id": "3274462"}, {"introduction": "在探讨了物理内存的限制之后，我们现在将注意力转移到算法本身。递归的深度并非任意的，而是算法设计及其输入的直接结果。这个练习[@problem_id:3274586]要求你为一个在每一步都将输入减半的函数，精确地确定其栈深度，从而揭示递归结构与对数复杂度之间的优美关系。", "problem": "考虑一个对非负整数集合进行操作的确定性过程，该过程使用标准的后进先出（LIFO）调用栈。运行时系统不执行尾调用优化，因此每次过程调用都会将一个新的激活记录（AR）推入栈中，并且该激活记录会一直保留在栈上，直到其调用返回。对输入 $x \\in \\mathbb{Z}_{\\ge 0}$ 定义函数 $f$ 如下：如果 $x = 0$，则 $f$ 立即返回，不进行任何进一步的调用；如果 $x > 0$，则 $f$ 进行一次对 $f(\\lfloor x/2 \\rfloor)$ 的递归调用，并在该调用返回后返回。最大栈深度定义为在单次调用 $f(x)$ 的执行过程中，栈上同时存在的激活记录的最大数量，包括初始调用和任何递归调用，如果达到基本情况，也包括其帧。从整数除法、向下取整函数以及递归下调用栈行为的核心定义出发，确定输入为 $x = 10^{9}$ 时的确切最大栈深度。给出你的最终答案，为一个精确的整数。不需要四舍五入。", "solution": "设 $D(x)$ 表示调用函数 $f(x)$ 时的最大栈深度，其中 $x \\in \\mathbb{Z}_{\\ge 0}$。问题定义了函数 $f$ 和调用栈的行为。\n\n根据问题描述：\n1.  对 $f(x)$ 的一次调用会将一个新的激活记录（AR）推入栈中。\n2.  如果 $x=0$，函数返回。在此调用期间，栈上的最大AR数量为 $1$（用于 $f(0)$ 本身）。因此，最大深度的基本情况是 $D(0) = 1$。\n3.  如果 $x > 0$，函数 $f(x)$ 对 $f(\\lfloor x/2 \\rfloor)$ 进行一次递归调用。在执行对 $f(\\lfloor x/2 \\rfloor)$ 的调用时，$f(x)$ 的AR保留在栈上。执行 $f(x)$ 的最大栈深度将是 $f(x)$ 本身的 $1$ 个AR，加上在对 $f(\\lfloor x/2 \\rfloor)$ 的嵌套调用期间达到的最大深度。\n\n这为我们提供了最大栈深度 $D(x)$ 的以下递推关系：\n$$\nD(x) = \\begin{cases}\n1 & \\text{if } x = 0 \\\\\n1 + D(\\lfloor x/2 \\rfloor) & \\text{if } x > 0\n\\end{cases}\n$$\n\n为了找到 $x = 10^9$ 时的最大栈深度，我们需要解这个递推关系。我们可以对任意 $x > 0$ 展开这个递推。设 $x_0 = x$，并定义序列 $x_{i+1} = \\lfloor x_i/2 \\rfloor$（对于 $i \\ge 0$）。由于 $x$ 是一个正整数，这个序列将严格递减，直到达到 $0$。设 $m$ 是使参数变为 $0$ 所需的步数，使得 $x_m = 0$ 且 $x_{m-1} > 0$。\n\n展开递推关系：\n$$\n\\begin{aligned}\nD(x) & = 1 + D(x_1) \\\\\n& = 1 + (1 + D(x_2)) \\\\\n& = 1 + 1 + (1 + D(x_3)) \\\\\n& \\vdots \\\\\n& = \\underbrace{1 + 1 + \\cdots + 1}_{m \\text{ times}} + D(x_m) \\\\\n& = m + D(0)\n\\end{aligned}\n$$\n使用基本情况 $D(0) = 1$，我们得到：\n$$D(x) = m + 1$$\n这里，$m$ 是我们必须应用变换 $n \\to \\lfloor n/2 \\rfloor$ 从 $x$ 得到 $0$ 的次数。然而，递推是从 $x$ 到 $x_{m-1}$ (共 $m$ 步)，最后一步是调用 $D(x_m)=D(0)$。总调用次数是 $m+1$。因此，栈深度是 $m+1$。\n操作 $n \\to \\lfloor n/2 \\rfloor$ 等效于其二进制表示的右移位。将一个正整数 $x$ 减少到 $0$ 所需的此类操作次数等于 $x$ 的二进制表示中的位数。\n\n对于任何正整数 $x$，其二进制表示的位数（我们称之为 $k$）由 $k = \\lfloor \\log_2(x) \\rfloor + 1$ 给出。\n递归调用的次数（直到参数变为0）是 $m = \\lfloor \\log_2(x) \\rfloor + 1$。\n总栈深度是初始调用加上所有递归调用的数量。调用链为 $f(x) \\to f(\\lfloor x/2 \\rfloor) \\to \\dots \\to f(1) \\to f(0)$。总调用次数为 $\\lfloor \\log_2(x) \\rfloor + 2$。\n因此，$D(x) = \\lfloor \\log_2(x) \\rfloor + 2$。\n\n我们需要计算输入为 $x = 10^9$ 时的最大栈深度。使用推导出的公式：\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2$$\n为了计算 $\\lfloor \\log_2(10^9) \\rfloor$，我们需要找到一个整数 $k$ 使得 $2^k \\le 10^9  2^{k+1}$。\n我们知道 $2^{10} = 1024$，它略大于 $10^3 = 1000$。\n\n由 $10^3  2^{10}$，我们可以将两边都取 $3$ 次方：\n$$(10^3)^3  (2^{10})^3$$\n$$10^9  2^{30}$$\n这告诉我们 $\\log_2(10^9)  30$，所以 $\\lfloor \\log_2(10^9) \\rfloor \\le 29$。\n\n现在我们必须检查 $\\log_2(10^9)$ 是否大于或等于 $29$。这等价于检查 $10^9 \\ge 2^{29}$。\n$$2^{29} = \\frac{2^{30}}{2} = \\frac{(2^{10})^3}{2} = \\frac{(1024)^3}{2}$$\n我们正在比较 $10^9$ 和 $\\frac{1024^3}{2}$。让我们重新整理这个比较：\n$$2 \\cdot 10^9 \\quad \\text{vs} \\quad 1024^3$$\n$$2 \\cdot (1000)^3 \\quad \\text{vs} \\quad (1024)^3$$\n两边都除以 $(1000)^3$：\n$$2 \\quad \\text{vs} \\quad \\left(\\frac{1024}{1000}\\right)^3$$\n$$2 \\quad \\text{vs} \\quad (1.024)^3$$\n我们来计算 $(1.024)^3$：\n$(1.024)^2 = 1.048576$\n$(1.024)^3 = 1.048576 \\times 1.024 \\approx 1.0737$\n现在比较变为：\n$$2 > 1.0737...$$\n这意味着 $2 \\cdot 10^9 > 1024^3$，也就是说 $10^9 > \\frac{1024^3}{2} = 2^{29}$。\n\n因此我们已经建立了不等式：\n$$2^{29}  10^9  2^{30}$$\n对所有部分取以 $2$ 为底的对数：\n$$\\log_2(2^{29})  \\log_2(10^9)  \\log_2(2^{30})$$\n$$29  \\log_2(10^9)  30$$\n因此，$\\log_2(10^9)$ 的向下取整是 $29$：\n$$\\lfloor \\log_2(10^9) \\rfloor = 29$$\n最后，我们可以计算最大栈深度：\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2 = 29 + 2 = 31$$\n对于输入 $x = 10^9$，确切的最大栈深度是 $31$。", "answer": "$$\\boxed{31}$$", "id": "3274586"}, {"introduction": "检验是否理解一个概念的最终方法，是从零开始构建它。在最后一个练习中，你将通过实现一个经典的算法——树的后序遍历——来揭开递归“魔法”的神秘面纱，但全程不允许使用递归函数调用。通过使用一个显式的栈数据结构来管理遍历状态[@problem_id:3274439]，你将亲眼见证它如何完美地模拟系统底层的调用栈，从而巩固你对递归机制的掌握。", "problem": "你必须仅使用一个标准栈（Stack）数据结构来实现二叉树的非递归后序遍历。遍历顺序必须是先访问左子树，然后是右子树，最后是节点本身。程序必须是自包含的，内部定义测试用例，并以下面指定的精确格式产生单行输出。\n\n推导和算法设计的基本依据必须从以下已确立的定义和事实开始：\n- 二叉树是节点的有限集合，其中每个节点最多有两个子节点，传统上称为左孩子和右孩子。后序遍历仅在访问了节点的左、右子树之后才访问该节点本身。\n- 栈（Stack）是一种至少支持入栈(push)、出栈(pop)、查看栈顶(peek)和判空(is-empty)操作的数据结构，并表现出后进先出（LIFO）的行为。\n- 递归函数的程序执行会在调用栈上构建和展开栈帧；这是运行时用来管理函数调用的一个隐式栈。\n\n本问题中树的表示方法：\n- 每棵树被定义为一个三元组列表 $\\left(v,\\ell,r\\right)$，每个节点对应一个三元组，其中 $v$ 是节点的整数值，$\\ell$ 是左孩子的索引，$r$ 是右孩子的索引。索引 $-1$ 表示空孩子。列表索引即为节点标识符。对于所有非空树，根节点位于索引 $0$ 处。对于空树，列表为空，其后序遍历也为空列表。\n\n实现一个函数，给定这样一个列表，返回其后序遍历（一个整数列表），要求不使用递归，并且仅使用一个栈来模拟调用栈的行为。除了栈和常数数量的标量变量外，不允许使用其他辅助数据结构。\n\n你的程序要使用的测试套件：\n- 情况 $1$ (平衡树): $\\left[(1,1,2),(2,3,4),(3,5,6),(4,-1,-1),(5,-1,-1),(6,-1,-1),(7,-1,-1)\\right]$。\n- 情况 $2$ (单节点): $\\left[(42,-1,-1)\\right]$。\n- 情况 $3$ (左斜树): $\\left[(10,1,-1),(20,2,-1),(30,3,-1),(40,-1,-1)\\right]$。\n- 情况 $4$ (右斜树): $\\left[(11,-1,1),(22,-1,2),(33,-1,3),(44,-1,-1)\\right]$。\n- 情况 $5$ (混合缺失子节点): $\\left[(5,1,2),(2,-1,3),(9,4,-1),(3,-1,-1),(7,-1,5),(8,-1,-1)\\right]$。\n- 情况 $6$ (空树): $\\left[\\right]$。\n\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如, $\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\dots\\right]$），其中包含所有结果。每个测试用例的结果必须是表示该树后序遍历的整数列表。\n\n最终输出纯粹是整数和整数列表。不涉及物理单位、角度单位或百分比。", "solution": "### 基于原理的解决方案\n\n目标是使用单个栈以迭代方式对二叉树执行后序遍历（左、右、根）。这模拟了递归遍历期间系统调用栈的行为。\n\n迭代后序遍历的主要挑战在于确定何时可以访问一个节点。一个节点 $N$ 只有在其左子树和右子树的遍历都完成后才能被处理。使用单个栈时，当我们在探索完一个子树后返回到节点 $N$ 时，我们需要知道我们是从其左孩子返回（此时必须接着遍历右子树），还是从其右孩子返回（此时终于可以处理节点 $N$）。\n\n为了解决这种歧义，我们使用一个栈和两个状态跟踪变量：\n1. 一个指针 `current_node_idx`，用于跟踪当前正在探索的节点。\n2. 一个指针 `last_visited_node_idx`，用于存储最近访问过（即已添加到输出中）的节点的索引。\n\n算法流程如下：\n1. 对于空树，遍历结果是空列表，这是一个在开始时处理的基本情况。对于非空树，主循环持续进行，只要还有节点需要处理，即 `current_node_idx` 不为 null（用索引 $-1$ 表示）或栈不为空。\n\n2. **向下遍历树**：如果 `current_node_idx` 有效，意味着我们正在向下遍历。我们将 `current_node_idx` 推入栈中以标记路径，然后前进到其左孩子。重复此过程，在从当前位置沿最左路径向下时，将节点推入栈中。\n\n3. **向上回溯并遍历右侧**：当 `current_node_idx` 变为空（$-1$）时，表示我们已经到达了路径的底部（一个空的左孩子）。现在我们必须查看栈顶的节点，称其索引为 `peek_node_idx`，但先不将其弹出。这是我们刚来自的空节点的父节点。我们必须决定接下来做什么：\n   - **情况 A：遍历右子树。** 我们检查 `peek_node_idx` 是否有右孩子。如果其右孩子存在且*不是* `last_visited_node_idx`，这意味着我们已经完成了 `peek_node_idx` 的左子树遍历，现在必须开始遍历其右子树。我们将 `current_node_idx` 设置为该右孩子的索引，并继续循环。\n   - **情况 B：访问当前节点。** 如果 `peek_node_idx` 没有右孩子，或者其右孩子是 `last_visited_node_idx`，这证实了它的两个子树都已被完全遍历。现在是“访问” `peek_node_idx` 处节点的正确时机。我们从栈中弹出其索引，将其值附加到结果列表中，并将 `last_visited_node_idx` 更新为 `peek_node_idx`。我们保持 `current_node_idx` 为 $-1$，以确保在下一次迭代中，我们再次从栈顶开始处理，从而有效地在树中向上移动。\n\n这个逻辑正确地模拟了递归调用的展开过程。`last_visited_node_idx` 变量是关键，它提供了必要的上下文来区分是从左孩子返回还是从右孩子返回，从而确保每个节点都按正确的后序顺序被访问。\n\n该算法利用单个栈和常数数量的标量变量（`current_node_idx`、`last_visited_node_idx` 以及循环内的临时变量），满足所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef post_order_iterative(tree_list: list[tuple[int, int, int]]) -> list[int]:\n    \"\"\"\n    Performs a non-recursive post-order traversal of a binary tree.\n\n    The tree is represented as a list of (value, left_idx, right_idx) tuples.\n    The algorithm uses a single stack to emulate the call stack of a recursive\n    function, satisfying the problem constraints.\n\n    Args:\n        tree_list: A list representing the nodes of the tree. Each element is\n                   a tuple (value, left_child_index, right_child_index). An\n                   index of -1 indicates a null child.\n\n    Returns:\n        A list of integers representing the post-order traversal of the tree.\n    \"\"\"\n    # An empty tree has an empty traversal.\n    if not tree_list:\n        return []\n\n    result = []\n    stack = []\n    \n    # current_node_idx tracks the node to be processed.\n    # We start with the root, which is always at index 0 for a non-empty tree.\n    current_node_idx = 0\n    \n    # last_visited_node_idx tracks the most recently processed node. This is\n    # crucial for determining if we are returning from a left or right child.\n    last_visited_node_idx = -1\n\n    while current_node_idx != -1 or stack:\n        if current_node_idx != -1:\n            # We are descending. Go left as far as possible.\n            # Push the current node index onto the stack to remember the path.\n            stack.append(current_node_idx)\n            _, left_child_idx, _ = tree_list[current_node_idx]\n            current_node_idx = left_child_idx\n        else:\n            # We have hit a dead end (null left child). Look at the stack.\n            peek_node_idx = stack[-1]  # Peek at the top of the stack\n            \n            # Get the right child of the node on top of the stack.\n            _, _, right_child_idx = tree_list[peek_node_idx]\n\n            if right_child_idx != -1 and right_child_idx != last_visited_node_idx:\n                # If there's a right child and we haven't visited its subtree yet,\n                # switch to traversing the right subtree.\n                current_node_idx = right_child_idx\n            else:\n                # If there is no right child, or we have already visited the\n                # right subtree, then it's time to process this node.\n                \n                # Pop the node index from the stack.\n                popped_node_idx = stack.pop()\n                \n                # Get the node's value and add it to the result.\n                value, _, _ = tree_list[popped_node_idx]\n                result.append(value)\n                \n                # Mark this node as the last one visited.\n                last_visited_node_idx = popped_node_idx\n                \n                # Keep current_node_idx as -1 to continue processing from the stack,\n                # effectively moving up the tree.\n                current_node_idx = -1\n                \n    return result\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the traversal algorithm on each, and prints\n    the results in the specified format.\n    \"\"\"\n    # The test suite provided in the problem statement.\n    test_cases = [\n        # Case 1 (balanced tree)\n        [(1, 1, 2), (2, 3, 4), (3, 5, 6), (4, -1, -1), (5, -1, -1), (6, -1, -1), (7, -1, -1)],\n        # Case 2 (single node)\n        [(42, -1, -1)],\n        # Case 3 (left-skewed)\n        [(10, 1, -1), (20, 2, -1), (30, 3, -1), (40, -1, -1)],\n        # Case 4 (right-skewed)\n        [(11, -1, 1), (22, -1, 2), (33, -1, 3), (44, -1, -1)],\n        # Case 5 (mixed missing children)\n        [(5, 1, 2), (2, -1, 3), (9, 4, -1), (3, -1, -1), (7, -1, 5), (8, -1, -1)],\n        # Case 6 (empty tree)\n        []\n    ]\n\n    all_results = []\n    for tree in test_cases:\n        traversal_result = post_order_iterative(tree)\n        all_results.append(traversal_result)\n    \n    # Python's default str() for lists uses single quotes for strings, \n    # but since we have integers, it's fine. We need to join these list\n    # representations with commas.\n    print(f\"[{','.join(str(res) for res in all_results)}]\")\n\n# solve() produces '[[4, 5, 2, 6, 7, 3, 1],[42],[40, 30, 20, 10],[44, 33, 22, 11],[3, 2, 8, 7, 9, 5],[]]'\n# The problem asks for format [[...],[...],...]\n# The default python list to string is '[4, 5, 2]'.\n# This is what's required. So `str(res)` is correct.\n# Final output string should be `f\"[{','.join(map(str, all_results))}]\"`\n\nsolve()\n```", "id": "3274439"}]}