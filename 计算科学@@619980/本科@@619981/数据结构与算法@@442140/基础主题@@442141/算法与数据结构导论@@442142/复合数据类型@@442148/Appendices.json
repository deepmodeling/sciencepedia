{"hands_on_practices": [{"introduction": "要真正掌握复合数据类型，我们必须深入底层，了解数据在内存中的表示方式。第一个练习将挑战你利用内存对齐——现代系统中一个普遍的特性——将多个信息片段打包到一个单独的字中。通过学习操控单个比特位，你将获得一个强大的工具，用于优化内存使用和理解底层系统设计。[@problem_id:3223001]", "problem": "要求你设计一个复合数据类型表示，它能将一个内存指针和三个独立的布尔标志打包到一个 $64$-bit 的字中。其背景是一个 $64$-bit 系统，在该系统中，动态内存分配保证任何堆指针都按 $8$ 字节对齐。按 $8$ 字节对齐意味着指针值 $p$ 总是可以被 $8$ 整除，等价于 $p \\bmod 8 = 0$，因此其最低有效三位为零。\n\n使用的基本原理和定义：\n- 二进制整数采用固定宽度的位向量表示；一个 $64$-bit 字表示范围在 $[0,2^{64}-1]$ 内的整数。\n- 位逻辑遵循经过充分测试的规则：按位与、按位或、按位异或和位移操作在每个位位置上进行。特别地，如果两组位占据不相交的位置，它们的按位或运算可以在无干扰的情况下将它们聚合起来。\n- 内存按 $2^{a}$ 字节对齐意味着任何对齐地址的最低 $a$ 位都为零。\n- 布尔值可以表示为位，其中 $0$ 编码逻辑假，$1$ 编码逻辑真。\n\n任务：\n1. 构建一个编码函数，该函数接收一个对齐的指针 $p$ 和一组三个布尔标志 $(b_0,b_1,b_2)$，生成一个能无损存储两者的 $64$-bit 字 $w$。\n2. 构建一个解码函数，该函数接收 $w$，并精确地恢复原始指针 $p$ 和标志 $(b_0,b_1,b_2)$。\n3. 仅使用对齐保证和位运算的性质，证明你的编码和解码在有效域上互为逆运算。你必须确保指针位和标志位不会相互干扰。\n4. 如果输入指针 $p$ 未按 $8$ 字节对齐，编码必须发出无效情况的信号。为此程序的目的，在此类情况下返回整数 $-1$。\n\n域和约束：\n- 将指针视为无符号整数，$p \\in \\{0,8,16,\\dots,2^{61}-8\\}$，这确保了有空间用最低三位来存储标志，同时使结果保持在 $64$-bit 字的范围内。\n- 仅使用整数和位运算；不要依赖浮点或字符串操作来执行打包和解包。\n\n测试套件：\n实现你的解决方案，并在以下参数集上运行它，每个参数集包含一个指针 $p$ 和标志 $(b_0,b_1,b_2)$：\n- 情况 A (一般情况): $p = 4096$, $(b_0,b_1,b_2) = (1,0,1)$。\n- 情况 B (所有标志为假，零指针): $p = 0$, $(b_0,b_1,b_2) = (0,0,0)$。\n- 情况 C (所有标志为真，高位指针): $p = 2^{60}$, $(b_0,b_1,b_2) = (1,1,1)$。\n- 情况 D (接近域下可表示最大值的边界指针): $p = 2^{61} - 8$, $(b_0,b_1,b_2) = (1,0,0)$。\n- 情况 E (无效的未对齐指针): $p = 12345$, $(b_0,b_1,b_2) = (1,1,0)$。\n\n要求的输出格式：\n- 对每种情况，输出一个整数：对于有效情况，输出打包后的 $64$-bit 字 $w$；对于无效情况，输出 $-1$。\n- 你的程序应生成单行输出，其中包含以逗号分隔并用方括号括起来的结果列表 (例如, \"[resultA,resultB,resultC,resultD,resultE]\")。\n- 本问题不涉及物理单位。", "solution": "该问题要求设计一种复合数据类型，将一个 $64$-bit 内存指针 $p$ 和三个布尔标志 $(b_0, b_1, b_2)$ 打包到一个 $64$-bit 字中。实现这一点的基本原理是，任何此类指针 $p$ 都明确保证按 $8$ 字节对齐。\n\n内存地址（或指针值）$p$ 按 $8$ 字节对齐，意味着 $p$ 是 $8$ 的整数倍。在数学上，这表示为 $p \\equiv 0 \\pmod{8}$。在二进制数系统中，任何 $8 = 2^3$ 的整数倍，其最低有效三位 (LSB)（即位置 $0$、$1$ 和 $2$）都必须为零。因此，这三位可用于存储，而不会干扰指针的值，因为对齐属性确保了它们是可预测的。我们可以利用这些“空闲”位来存储三个布尔标志。\n\n### 编码函数\n编码函数，我们称之为 $\\text{encode}(p, (b_0, b_1, b_2))$，它接收一个指针 $p$（表示为一个 $64$-bit 无符号整数）和一组三个布尔标志作为输入，生成一个 $64$-bit 字 $w$。\n\n首先，函数必须验证输入指针 $p$。对齐是一个关键的先决条件。通过验证 $p$ 是否为 $8$ 的倍数来进行检查。这可以通过算术运算 $p \\pmod{8} = 0$ 来计算，或更高效地使用位运算 $p \\ \\ \\ 7 == 0$。如果指针未对齐，则视为无效输入，函数必须按问题规定返回整数值 $-1$。\n\n如果指针有效，则继续进行编码。布尔标志 $(b_0, b_1, b_2)$ 由整数 $f_0, f_1, f_2 \\in \\{0, 1\\}$ 表示。我们建立一个直接映射，其中标志 $b_i$ 存储在位位置 $i$。这些标志被组合成一个 3 位整数，记为 $\\text{flags\\_val}$，其值在 $[0, 7]$ 范围内：\n$$\n\\text{flags\\_val} = (f_2 \\ll 2) \\ | \\ (f_1 \\ll 1) \\ | \\ f_0\n$$\n此表达式等价于算术和 $4f_2 + 2f_1 + f_0$。\n\n由于有效指针 $p$ 的最低有效三位保证为零，我们可以使用按位或 (OR) 运算合并 $p$ 和 $\\text{flags\\_val}$。这将标志位放入指针二进制表示中已清零的最低有效位，而不会干扰定义指针值的任何更高有效位。最终编码的字 $w$ 是：\n$$\nw = p \\ | \\ \\text{flags\\_val}\n$$\n\n### 解码函数\n解码函数 $\\text{decode}(w)$ 执行逆操作。它接收由我们的编码方案创建的 $64$-bit 字 $w$，并恢复原始指针 $p$ 和三个标志 $(b_0, b_1, b_2)$。\n\n要恢复原始指针 $p$，我们必须清除 $w$ 的最低有效三位，这些位现在持有标志数据。这通过对 $w$ 和一个掩码执行按位与 (AND) 运算来实现，该掩码的最低有效三位为 $0$，所有其他位为 $1$。此掩码是 $7$ 的按位补码（即 $\\sim 7$），对应于 $64$-bit 十六进制值 $0xFFFFFFFFFFFFFFF8$。\n$$\np_{\\text{recovered}} = w \\ \\ \\ (\\sim 7)\n$$\n此操作将位 $0$、$1$ 和 $2$ 清零，将指针恢复到其原始的对齐值。\n\n要恢复标志，我们必须从字 $w$ 中分离出每个最低有效三位：\n- 标志 $b_0$ 的整数值 $f_0$ 存储在 $w$ 的位 $0$ 中：\n  $$\n  f_0 = w \\ \\ \\ 1\n  $$\n- 标志 $b_1$ 的值 $f_1$ 在位 $1$ 中。我们通过右移来分离并归一化它：\n  $$\n  f_1 = (w \\ \\ \\ 2) \\gg 1\n  $$\n- 标志 $b_2$ 的值 $f_2$ 在位 $2$ 中：\n  $$\n  f_2 = (w \\ \\ \\ 4) \\gg 2\n  $$\n这些操作成功地将各个标志值提取为 $0$ 或 $1$。\n\n### 正确性证明\n现在我们将证明，对于任何有效指针 $p$ 和任何标志集 $(f_0, f_1, f_2)$，解码过程完全是编码的逆过程。设 $w = \\text{encode}(p, (f_0, f_1, f_2))$ 且 $(p', (f'_0, f'_1, f'_2)) = \\text{decode}(w)$。我们必须证明 $p' = p$ 且对于 $i \\in \\{0, 1, 2\\}$ 有 $f'_i = f_i$。\n\n1.  **前提**：\n    - 输入指针 $p$ 按 $8$ 字节对齐，意味着 $p \\bmod 8 = 0$。其二进制表示必须以三个零结尾：$p = (p_{63} \\dots p_3 000)_2$。\n    - 标志被组合成一个整数 $f_{\\text{val}} = 4f_2 + 2f_1 + f_0$。其二进制表示中位 $3$ 到位 $63$ 都为零：$f_{\\text{val}} = (0 \\dots 0 f_2 f_1 f_0)_2$。\n\n2.  **编码分析**：\n    编码后的字 $w$ 计算为 $w = p \\ | \\ f_{\\text{val}}$。\n    $$\n    w = (p_{63} \\dots p_3 000)_2 \\ | \\ (0 \\dots 0 f_2 f_1 f_0)_2 = (p_{63} \\dots p_3 f_2 f_1 f_0)_2\n    $$\n    因为由 $f_{\\text{val}}$ 设置的位位置（位 $0, 1, 2$）在 $p$ 中保证是被清除的（即为0），所以按位或运算只是简单地填充这些位。$w$ 的高 $61$ 位与 $p$ 的高 $61$ 位相同，而 $w$ 的低 $3$ 位持有标志值。\n\n3.  **解码分析**：\n    - **指针恢复**：恢复的指针 $p'$ 计算为 $p' = w \\ \\ \\ (\\sim 7)$。掩码 $(\\sim 7)$ 的二进制表示为 $(1 \\dots 1000)_2$。\n      $$\n      p' = (p_{63} \\dots p_3 f_2 f_1 f_0)_2 \\ \\ \\ (1 \\dots 11111000)_2 = (p_{63} \\dots p_3 000)_2\n      $$\n      此结果与原始指针 $p$ 逐位相同。因此，$p' = p$。\n\n    - **标志恢复**：恢复的标志 $f'_0, f'_1, f'_2$ 提取如下：\n      $$\n      f'_0 = (w \\ \\ \\ 1) = ((p_{63} \\dots f_0)_2 \\ \\ \\ (0 \\dots 001)_2) = (0 \\dots 0 f_0)_2 = f_0\n      $$\n      $$\n      f'_1 = ((w \\ \\ \\ 2) \\gg 1) = (((p_{63} \\dots f_0)_2 \\ \\ \\ (0 \\dots 010)_2) \\gg 1) = ((0 \\dots f_1 0)_2 \\gg 1) = (0 \\dots 0 f_1)_2 = f_1\n      $$\n      $$\n      f'_2 = ((w \\ \\ \\ 4) \\gg 2) = (((p_{63} \\dots f_0)_2 \\ \\ \\ (0 \\dots 100)_2) \\gg 2) = ((0 \\dots f_2 00)_2 \\gg 2) = (0 \\dots 0 f_2)_2 = f_2\n      $$\n      恢复的标志 $(f'_0, f'_1, f'_2)$ 与原始标志 $(f_0, f_1, f_2)$ 相同。\n\n**结论**：对于指定有效输入域，所定义的编码和解码函数是无损的逆运算。这种指针标记系统是正确且稳健的，它仅依赖于保证的内存对齐和位逻辑的基本性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pointer packing problem for the given test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: p = 4096, (b0,b1,b2) = (1,0,1)\n        (4096, (1, 0, 1)),\n        # Case B: p = 0, (b0,b1,b2) = (0,0,0)\n        (0, (0, 0, 0)),\n        # Case C: p = 2^60, (b0,b1,b2) = (1,1,1)\n        (2**60, (1, 1, 1)),\n        # Case D: p = 2^61 - 8, (b0,b1,b2) = (1,0,0)\n        (2**61 - 8, (1, 0, 0)),\n        # Case E: p = 12345, (b0,b1,b2) = (1,1,0)\n        (12345, (1, 1, 0)),\n    ]\n\n    def encode(p, flags):\n        \"\"\"\n        Packs a memory pointer and three boolean flags into a single 64-bit word.\n        \n        Args:\n            p (int): The pointer value, treated as an unsigned integer.\n            flags (tuple): A tuple of three integers (0 or 1) representing (b0, b1, b2).\n            \n        Returns:\n            int: The packed 64-bit word, or -1 if the pointer is not aligned.\n        \"\"\"\n        # A pointer is aligned to 8 bytes if its value is divisible by 8.\n        # This can be checked efficiently using the modulo operator or bitwise AND.\n        # p % 8 == 0 is equivalent to (p  7) == 0.\n        if p % 8 != 0:\n            return -1\n        \n        # Unpack the flag tuple. The problem uses (b0, b1, b2), so we map\n        # b0 to bit 0, b1 to bit 1, and b2 to bit 2.\n        b0, b1, b2 = flags\n        \n        # Combine the boolean flags (represented as 0 or 1) into a single\n        # integer value where each flag corresponds to a bit position.\n        flags_val = (b2  2) | (b1  1) | b0\n        \n        # Since the 3 least significant bits of an aligned pointer are zero,\n        # we can use a bitwise OR to merge the pointer and the flags without\n        # corrupting the pointer's original value.\n        return p | flags_val\n\n    results = []\n    for p, flags in test_cases:\n        result = encode(p, flags)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3223001"}, {"introduction": "结构体（`struct`）会同时存储其所有成员，而联合体（`union`）则允许多个成员共享同一块内存空间，这使得一种称为“类型双关”（type punning）的技术成为可能。本练习将探讨一个假设性的安全漏洞，它源于将同一块内存比特序列错误地解释为浮点数和整数。这是一个关于联合体强大功能与潜在危险的关键课程，它表明了深刻理解数据表示对于编写健壮、安全的代码至关重要。[@problem_id:3223153]", "problem": "给定一个存在漏洞的解析器的规范，该解析器使用一种类似联合体的复合数据类型，将一个$4$字节的字段进行类型双关，既作为无符号$32$位整数，也作为单精度浮点数。联合体是一种复合数据类型，它将多个成员类型覆盖在同一块内存上，因此所有成员共享相同的底层字节。该漏洞的产生原因是，代码通过将字节解释为浮点数来验证字段的有效性，但随后又将相同的字节用作表示长度的无符号整数，而没有采用一致的解释规则。您必须在一组精心选择的测试输入上对该漏洞进行形式化、模拟和评估。\n\n基本根据和假设：\n- 联合体拥有单一的存储区域，每个成员占用相同的地址。通过某个成员读取数据，将返回对相同底层位串的一种解释。\n- 机器模型如下。\n  - 字节序为小端序（little-endian），意味着最低有效字节存储在最低内存地址。如果内存中按地址递增顺序排列的字节是 $(b_0,b_1,b_2,b_3)$，那么无符号$32$位整数值 $n$ 为\n    $$\n    n \\;=\\; b_0 + 2^8 b_1 + 2^{16} b_2 + 2^{24} b_3.\n    $$\n  - 浮点数的解释遵循电气与电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ 单精度格式：$1$个符号位，$8$个指数位和$23$个小数位。将 $(b_0,b_1,b_2,b_3)$ 解释为 $\\text{float32}$ 值 $f$ 的方法是，将这$4$个字节按小端序视为 IEEE $754$ 表示的$32$个位。\n- 长度以字节为单位。定义最大允许的有效载荷长度 $L_{\\max} = 10^6$ 字节。\n\n需要模拟的存在漏洞的解析器逻辑：\n1. 设 $(b_0,b_1,b_2,b_3)$ 为字段的四个内存字节。计算相同字节在小端序下的浮点数重新解释值 $f$ 和无符号整数重新解释值 $n$。\n2. 当且仅当 $0 \\le f \\le 1$ 时，解析器认为该字段有效。如果有效，它将使用 $n$ 作为有效载荷长度。否则，它将拒绝该消息。\n3. 如果解析器认为字段有效，但所选长度 $n$ 超过了最大允许值，即 $0 \\le f \\le 1$ 且 $n  L_{\\max}$，则称该消息是可被利用的。\n\n您的任务：\n- 实现一个程序，对于下面提供的每个测试用例，根据上述规则计算消息是否可被利用，如果可被利用则输出 $1$，否则输出 $0$。所有计算必须遵守小端序布局和 IEEE $754$ 单精度规则。\n- 您的程序不能读取任何输入，并且必须内嵌以下测试套件。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔且不含空格的结果列表。例如：$\\texttt{[1,0,1]}$。\n\n测试套件（每个测试用例是一个$4$元组 $(b_0,b_1,b_2,b_3)$，表示按内存地址递增顺序排列的字节，其中每个 $b_i$ 是 $\\{0,\\dots,255\\}$ 中的一个整数）：\n- 用例 $1$：$(0x00, 0x00, 0x00, 0x00)$。\n- 用例 $2$：$(0x00, 0x00, 0x00, 0x3F)$，其位模式对应 $f = 0.5$ 和 $n = 0x3F000000$。\n- 用例 $3$：$(0x10, 0x00, 0x00, 0x00)$，一个小的整数长度，对应一个非规格化的正浮点数 $f$。\n- 用例 $4$：$(0x0A, 0xD7, 0x7F, 0x3F)$，其位模式对应 $f \\approx 0.99999994$ 和 $n = 0x3F7FD70A$。\n- 用例 $5$：$(0x00, 0x00, 0x80, 0xBF)$，其位模式对应 $f = -1.0$ 和 $n = 0xBF800000$。\n- 用例 $6$：$(0x00, 0x00, 0x80, 0x3F)$，其位模式对应 $f = 1.0$ 和 $n = 0x3F800000$。\n- 用例 $7$：$(0x00, 0x00, 0xC0, 0x7F)$，在 IEEE $754$ 标准下是一个静默非数 (quiet Not-a-Number)，因此不可比较。\n- 用例 $8$：$(0x40, 0x42, 0x0F, 0x00)$，是 $n = 1{,}000{,}000$ 的小端序编码，并对应一个非常小的正非规格化浮点数 $f$。\n\n输出规范：\n- 设这$8$个用例的结果按顺序为 $r_1,\\dots,r_8 \\in \\{0,1\\}$。您的程序应精确打印一行，内容为字符串 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$。", "solution": "用户提供的问题已经过验证，被确定为一个计算机科学领域中定义明确且具有科学依据的问题。它要求分析因将一个$4$字节内存区域同时重新解释为无符号整数和单精度浮点数而产生的类型混淆漏洞。我们将着手提供一个形式化的解决方案。\n\n问题的核心是为一组给定的测试用例模拟一个存在漏洞的解析器的逻辑。对于每个输入，即一个以小端序存储的$4$字节元组 $(b_0, b_1, b_2, b_3)$，我们必须确定该消息是否“可被利用”。这需要对相同的底层$32$位进行两种主要的重新解释。\n\n设内存中从最低地址开始的四个字节为 $(b_0, b_1, b_2, b_3)$，其中每个 $b_i$ 是一个从 $0$ 到 $255$ 的 $8$ 位值。\n\n**步骤 1：无符号整数重新解释**\n\n根据问题的小端序规范，这$4$个字节被解释为一个$32$位无符号整数，记为 $n$。$n$ 的值计算如下：\n$$\nn = b_0 \\cdot 2^0 + b_1 \\cdot 2^8 + b_2 \\cdot 2^{16} + b_3 \\cdot 2^{24} = \\sum_{i=0}^{3} b_i 2^{8i}\n$$\n这对应于构造一个$32$位的字，其中 $b_0$ 是最低有效字节，$b_3$ 是最高有效字节。\n\n**步骤 2：浮点数重新解释**\n\n同一个$32$位字被重新解释为一个符合 IEEE $754$ 标准的单精度浮点数 $f$。一个$32$位的 IEEE $754$ 数由三个字段组成：\n- 一个$1$位的符号位 ($S$)\n- 一个$8$位的偏置指数位 ($E$)\n- 一个$23$位的小数位 ($F$)\n\n$f$ 的值按如下方式确定：\n- 如果 $E = 255$ 且 $F \\neq 0$，$f$ 是非数 (Not-a-Number, NaN)。\n- 如果 $E = 255$ 且 $F = 0$，$f$ 是 $\\pm\\infty$，具体取决于 $S$。\n- 如果 $0  E  255$，$f$ 是一个规格化数：$f = (-1)^S \\times (1.F) \\times 2^{(E-127)}$。\n- 如果 $E = 0$ 且 $F \\neq 0$，$f$ 是一个非规格化数：$f = (-1)^S \\times (0.F) \\times 2^{(-126)}$。\n- 如果 $E = 0$ 且 $F = 0$，$f$ 是 $\\pm 0$，具体取决于 $S$。\n\n小端序内存布局 $(b_0, b_1, b_2, b_3)$ 对应于用于计算 $n$ 的同一个$32$位模式。\n\n**步骤 3：应用解析器逻辑**\n\n解析器的逻辑为每条消息定义了两个条件：\n1.  **有效性条件：** 当且仅当字段的浮点数解释值 $f$ 满足不等式 $0 \\le f \\le 1$ 时，该字段才有效。关键在于，任何涉及 NaN 值的比较其求值结果都为假，因此 $f$ 值为 NaN 将导致该字段无效。\n2.  **可利用性条件：** 如果一条消息被视为有效，*并且*其无符号整数解释值 $n$ 超过了最大允许的有效载荷长度 $L_{\\max} = 10^6$，则该消息是可被利用的。\n\n因此，一条消息是可被利用的，当且仅当 ($0 \\le f \\le 1$) 且 ($n  10^6$)。每个测试用例的结果若是可被利用的则为 $1$，否则为 $0$。\n\n**测试用例分析**\n\n我们现在将此过程应用于每个测试用例。\n\n**用例 1：** 输入字节 $(0x00, 0x00, 0x00, 0x00)$。\n- 整数 $n$：$n = 0x00000000 = 0$。\n- 浮点数 $f$：位模式全为零，表示 $f = 0.0$。\n- 有效性：$0 \\le 0.0 \\le 1$。为真。\n- 可利用性：$n  10^6 \\implies 0  10^6$。为假。\n- **结果：** $0$。\n\n**用例 2：** 输入字节 $(0x00, 0x00, 0x00, 0x3F)$。\n- 整数 $n$：$n = 0x3F000000 = 1,056,964,608$。\n- 浮点数 $f$：位模式为 $00111111000000000000000000000000$。这表示 $f = 0.5$。\n- 有效性：$0 \\le 0.5 \\le 1$。为真。\n- 可利用性：$n  10^6 \\implies 1,056,964,608  10^6$。为真。\n- **结果：** $1$。\n\n**用例 3：** 输入字节 $(0x10, 0x00, 0x00, 0x00)$。\n- 整数 $n$：$n = 0x00000010 = 16$。\n- 浮点数 $f$：位模式非零，但指数场为零，表示一个正的非规格化数。其值为 $f \\approx 2.24 \\times 10^{-44}$。\n- 有效性：$0 \\le f \\le 1$。为真。\n- 可利用性：$n  10^6 \\implies 16  10^6$。为假。\n- **结果：** $0$。\n\n**用例 4：** 输入字节 $(0x0A, 0xD7, 0x7F, 0x3F)$。\n- 整数 $n$：$n = 0x3F7FD70A = 1,065,359,114$。\n- 浮点数 $f$：位模式对应一个规格化数 $f \\approx 0.99948$。\n- 有效性：$0 \\le 0.99948 \\le 1$。为真。\n- 可利用性：$n  10^6 \\implies 1,065,359,114  10^6$。为真。\n- **结果：** $1$。\n\n**用例 5：** 输入字节 $(0x00, 0x00, 0x80, 0xBF)$。\n- 整数 $n$：$n = 0xBF800000 = 3,212,836,864$。\n- 浮点数 $f$：位模式为 $10111111100000000000000000000000$。这表示 $f = -1.0$。\n- 有效性：$0 \\le -1.0 \\le 1$。为假，因为 $0 \\le -1.0$ 为假。\n- **结果：** $0$。\n\n**用例 6：** 输入字节 $(0x00, 0x00, 0x80, 0x3F)$。\n- 整数 $n$：$n = 0x3F800000 = 1,065,353,216$。\n- 浮点数 $f$：位模式为 $00111111100000000000000000000000$。这表示 $f = 1.0$。\n- 有效性：$0 \\le 1.0 \\le 1$。为真。\n- 可利用性：$n  10^6 \\implies 1,065,353,216  10^6$。为真。\n- **结果：** $1$。\n\n**用例 7：** 输入字节 $(0x00, 0x00, 0xC0, 0x7F)$。\n- 整数 $n$：$n = 0x7FC00000 = 2,143,289,344$。\n- 浮点数 $f$：位模式的指数位全为一 ($E=255$)，小数部分非零，表示一个静默非数 (quiet Not-a-Number, NaN)。\n- 有效性：任何与 NaN 的比较（例如，$0 \\le \\text{NaN}$ 或 $\\text{NaN} \\le 1$）结果都为假。因此，有效性检查失败。\n- **结果：** $0$。\n\n**用例 8：** 输入字节 $(0x40, 0x42, 0x0F, 0x00)$。\n- 整数 $n$：$n = 0x000F4240 = 1,000,000$。\n- 浮点数 $f$：位模式表示一个正的非规格化数，$f \\approx 1.40 \\times 10^{-45}$。\n- 有效性：$0 \\le f \\le 1$。为真。\n- 可利用性：$n  10^6 \\implies 1,000,000  1,000,000$。由于是严格不等式，所以为假。\n- **结果：** $0$。\n\n测试套件的最终结果序列是 $[0, 1, 0, 1, 0, 1, 0, 0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a buggy parser to determine if messages are exploitable based on type-punning.\n    \n    A 4-byte field is interpreted as both a little-endian unsigned 32-bit integer (n)\n    and a little-endian IEEE 754 single-precision float (f).\n    A message is valid if 0 = f = 1.\n    A message is exploitable if it is valid AND n > L_max.\n    \"\"\"\n    \n    # Define the maximum allowed payload length from the problem statement.\n    L_max = 10**6\n\n    # Define the test suite from the problem statement.\n    # Each case is a 4-tuple of bytes (b0, b1, b2, b3) in little-endian order.\n    test_cases = [\n        (0x00, 0x00, 0x00, 0x00), # Case 1\n        (0x00, 0x00, 0x00, 0x3F), # Case 2\n        (0x10, 0x00, 0x00, 0x00), # Case 3\n        (0x0A, 0xD7, 0x7F, 0x3F), # Case 4\n        (0x00, 0x00, 0x80, 0xBF), # Case 5\n        (0x00, 0x00, 0x80, 0x3F), # Case 6\n        (0x00, 0x00, 0xC0, 0x7F), # Case 7\n        (0x40, 0x42, 0x0F, 0x00), # Case 8\n    ]\n\n    results = []\n    for case in test_cases:\n        # Create a numpy array of 8-bit unsigned integers from the byte tuple.\n        # This represents the in-memory layout of the 4 bytes.\n        byte_array = np.array(case, dtype=np.uint8)\n\n        # Reinterpret the 4-byte buffer as a single 32-bit unsigned integer.\n        # The 'u4' type is an unsigned 4-byte integer. The view method\n        # re-interprets the memory without copying data.\n        n = byte_array.view(np.uint32)[0]\n        \n        # Reinterpret the same buffer as a single-precision float.\n        # The 'f4' type is a 4-byte float.\n        f = byte_array.view(np.float32)[0]\n        \n        # Apply the parser's logic.\n        # 1. Validity Check: 0 = f = 1.\n        # Note: Comparisons with NaN always return False, which correctly\n        # invalidates the field for Case 7.\n        is_valid = (0.0 = f = 1.0)\n        \n        # 2. Exploitability Check: valid AND n > L_max\n        is_exploitable = is_valid and (n > L_max)\n        \n        # Append 1 if exploitable, 0 otherwise.\n        results.append(1 if is_exploitable else 0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3223153"}, {"introduction": "复合数据类型是构建复杂的现实世界系统的基本构件。在最后一个练习中，你将设计一个结构体（`struct`）来表示一个股票市场订单，并用它来构建一个简化的限价订单簿。这项挑战在于实现一个遵循严格价格-时间优先规则的撮合引擎，让你亲身体验数据结构设计和算法如何协同工作以解决实际问题。[@problem_id:3223154]", "problem": "您的任务是设计复合数据类型来实现一个简化的股票市场限价订单簿。每个订单是一条包含三个字段的记录：方向、价格和数量。方向指示订单是买单还是卖单，价格是订单愿意成交的限价，数量是单位数。目标是根据严格定义的规则撮合订单，将一系列到达的订单转换为订单簿的最终状态，然后报告指定测试用例的汇总结果。您的程序必须是一个可运行的完整程序。\n\n基本基础。从以下核心定义和事实开始，您应将其用作设计和算法的基础：\n- 复合数据类型是一种其元素由更原始类型组成的数据结构；在这里，订单是由方向、价格和数量组成的记录。形式上，一个订单可以表示为元组 $\\langle side, price, volume \\rangle$。\n- 为订单定义两种用于确定优先级的全序关系，以编码价格-时间优先原则：买单按 $price$ 降序、然后按到达时间升序排列优先级；卖单按 $price$ 升序、然后按到达时间升序排列优先级。这在每个价格水平内引入了一个与先入先出（FIFO）一致的严格弱序。\n- 撮合规则：一个价格为 $p_b$ 的新进买单，当且仅当 $p_b \\ge p_s$ 时，可以立即与价格为 $p_s$ 的最佳卖单撮合。一个价格为 $p_s$ 的新进卖单，当且仅当 $p_s \\le p_b$ 时，可以立即与价格为 $p_b$ 的最佳买单撮合。\n- 执行价格规则：执行价格等于挂单的限价；对于与价格为 $p_s$ 的挂单卖单撮合的新进买单，交易以价格 $p_s$ 执行；对于与价格为 $p_b$ 的挂单买单撮合的新进卖单，交易以价格 $p_b$ 执行。\n- 守恒：一次交易将新进订单的剩余 $volume$ 和挂单的剩余 $volume$ 减少相同的非负整数，该数量等于撮合数量，且数量始终为非负整数。\n- 不变量：处理完每个新进订单后，任何未成交的剩余部分都将按照上述全序关系插入到相应方向的订单簿中。\n\n要求的复合数据类型。设计以下内容：\n- 一种订单的记录类型，包含字段 $side \\in \\{\\text{BUY}, \\text{SELL}\\}$、$price \\in \\mathbb{N}$ 和 $volume \\in \\mathbb{N}$，以及一个到达索引 $t \\in \\mathbb{N}$。该索引随每个订单的到达而严格递增，并用于解决同一价格水平内的并列情况。您的程序应确保每个订单的 $price \\ge 1$ 和 $volume \\ge 1$。\n- 两个集合，分别代表买单簿和卖单簿，每个集合在任何时候都维持上述的全序关系。\n\n算法要求。实现一个算法，按如下方式处理一个有限的有序新进订单序列：\n- 对于在时间 $t$ 到达的每个新进订单 $\\langle side, price, volume \\rangle$，只要价格条件（对于买单为 $p_b \\ge p_s$，对于卖单为 $p_s \\le p_b$）成立且新进订单的 $volume$ 为正，就反复将其与订单簿另一方的最佳可用订单进行撮合。\n- 在每次撮合中，计算撮合数量 $q = \\min(v_{\\text{incoming}}, v_{\\text{resting}})$，将两个订单的数量都减少 $q$，并记录成交数量 $q$ 以便汇总。如果挂单的 $volume$ 变为 $0$，则将其从订单簿中移除；否则，更新其剩余的 $volume$。\n- 如果在所有可能的撮合之后，新进订单仍有正的 $volume$ 剩余，则将剩余部分根据上述全序关系插入到相应的订单簿中。\n\n最终输出规格。对于每个测试用例，在处理完整个订单序列后，计算：\n- 该用例中所有交易的总成交量 $V_{\\text{exec}} = \\sum q$。\n- 最佳买价元组 $(p_{\\text{bid}}, v_{\\text{bid}})$，即最高 $price$ 的买单（按最早时间解决并列）。如果买单簿为空，则报告 $p_{\\text{bid}} = -1$ 和 $v_{\\text{bid}} = 0$。\n- 最佳卖价元组 $(p_{\\text{ask}}, v_{\\text{ask}})$，即最低 $price$ 的卖单（按最早时间解决并列）。如果卖单簿为空，则报告 $p_{\\text{ask}} = -1$ 和 $v_{\\text{ask}} = 0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2}]$），其中每个结果是对应测试用例的列表 $[V_{\\text{exec}}, p_{\\text{bid}}, v_{\\text{bid}}, p_{\\text{ask}}, v_{\\text{ask}}]$。\n\n测试套件。使用以下测试用例，每个用例都指定为一个包含明确整数值的订单有序列表 $(side, price, volume)$：\n- 用例 1：$[\\langle \\text{BUY}, 100, 10 \\rangle, \\langle \\text{SELL}, 99, 5 \\rangle, \\langle \\text{SELL}, 100, 4 \\rangle, \\langle \\text{SELL}, 101, 10 \\rangle]$。预期行为：价格为 99 的第一个卖单与价格为 100 的买单撮合 5 个单位，然后价格为 100 的卖单撮合 4 个单位，留下价格为 100 的买单剩余 1 个单位，以及一个未撮合的价格为 101 的卖单。输出格式：$[V_{\\text{exec}}, p_{\\text{bid}}, v_{\\text{bid}}, p_{\\text{ask}}, v_{\\text{ask}}]$，值为整数。\n- 用例 2：$[\\langle \\text{SELL}, 50, 10 \\rangle, \\langle \\text{SELL}, 50, 7 \\rangle, \\langle \\text{BUY}, 50, 12 \\rangle]$。预期行为：同等价格下遵循 FIFO，买单在价格 50 处先撮合 10 个单位，再撮合 2 个单位，导致第二个卖单剩余 5 个单位；没有买单剩余。输出格式：按指定的整数格式。\n- 用例 3：$[\\langle \\text{BUY}, 30, 3 \\rangle, \\langle \\text{BUY}, 30, 4 \\rangle, \\langle \\text{SELL}, 25, 5 \\rangle]$。预期行为：价格为 25 的卖单以挂单买价 30 先撮合 3 个单位，再撮合 2 个单位，导致第二个买单剩余 2 个单位；没有卖单剩余。\n- 用例 4：$[\\langle \\text{BUY}, 20, 10 \\rangle, \\langle \\text{SELL}, 25, 1 \\rangle, \\langle \\text{BUY}, 19, 5 \\rangle]$。预期行为：没有撮合发生，因为最高买价 20 低于最低卖价 25；双方订单簿都保留有订单。\n- 用例 5：$[\\langle \\text{SELL}, 42, 2 \\rangle, \\langle \\text{SELL}, 45, 1 \\rangle, \\langle \\text{BUY}, 50, 5 \\rangle]$。预期行为：价格为 50 的买单先后消耗掉价格为 42 和 45 的卖单，导致价格为 50 的买单剩余 2 个单位；没有卖单剩余。\n\n单位和表示。所有 $price$ 和 $volume$ 值都是没有物理单位的整数。`side` 必须是 $\\{\\text{BUY}, \\text{SELL}\\}$ 中的一个。\n\n您的程序必须明确定义这些测试用例，根据上述规则计算结果，并以所描述的精确格式打印单行输出：一个包含各用例结果列表的、用方括号括起来的、逗号分隔的列表，无任何额外文本。", "solution": "该问题要求设计一个系统来模拟股票市场的限价订单簿。这包括为订单和订单簿创建复合数据类型，实现一个基于价格-时间优先原则处理订单序列的算法，以及根据订单簿的最终状态计算汇总统计数据。\n\n该解决方案围绕几个核心原则进行设计：选择合适的复合数据类型来表示订单簿的状态，以及一个能根据指定的撮合规则正确处理交易的算法。\n\n**1. 复合数据类型设计**\n\n基本单位是订单，它是一条包含方向、价格和数量的记录。为了处理价格-时间优先规则（该规则要求在相同价格水平的订单遵循先入先出（FIFO）准则），每个订单还必须关联其到达时间。\n\n-   **订单表示**：一个新进订单由元组 $\\langle side, price, volume \\rangle$ 定义。在系统内部，为了强制执行时间优先，我们用一个严格递增的到达索引 $t \\in \\mathbb{N}$ 来增强它。因此，一个在订单簿中等待的订单由其数量和到达时间表示，存储在特定的价格水平上。`price` 和 `volume` 是正整数（$\\mathbb{N}$，其中 $price \\ge 1, volume \\ge 1$），而 `side` 是 $\\{\\text{BUY}, \\text{SELL}\\}$ 的枚举。\n\n-   **订单簿表示**：设计的核心是买单簿和卖单簿的数据结构。每个订单簿必须维护一个根据特定全序关系排序的订单集合：\n    -   **买单簿**：订单按价格降序、然后按到达时间升序排列优先级。\n    -   **卖单簿**：订单按价格升序、然后按到达时间升序排列优先级。\n\n    为实现这一点，我们为每个订单簿设计一个复合数据结构。每个订单簿表示为一个价格水平的列表。每个价格水平本身也是一个复合类型：一个包含两个元素的列表 `[price, order_queue]`。\n    -   `price` 是一个整数。\n    -   `order_queue` 是一个先入先出队列（在 Python 中使用 `collections.deque` 实现），用于存储该价格水平上的各个订单。队列中的每个元素都是一个元组 $\\langle arrival\\_time, volume \\rangle$。\n\n    价格水平列表始终保持排序。对于买单簿，此列表按价格降序排序。对于卖单簿，则按价格升序排序。这种结构确保了最佳订单——价格最高的买单或价格最低的卖单——总是位于列表的开头（索引 $0$），从而实现高效的 $O(1)$ 访问。当添加新订单时，它们被放入正确价格水平的队列中。如果该价格水平不存在，则会创建一个新的并插入到列表中，同时保持排序顺序，此操作耗时 $O(N)$，其中 $N$ 是不同价格水平的数量。\n\n**2. 算法实现**\n\n该算法逐个处理一系列新进订单，更新买卖订单簿的状态并追踪总成交量。\n\n-   **初始化**：对于每个测试用例，我们从空的买单簿和卖单簿开始，总成交量 $V_{\\text{exec}}$ 为 $0$，到达时间计数器 $t$ 初始化为 $0$。\n\n-   **订单处理循环**：对于每个新进订单 $\\langle side_{in}, price_{in}, volume_{in} \\rangle$：\n    1.  到达时间 $t$ 递增。\n    2.  算法检查订单簿另一方是否存在潜在的撮合机会。\n    3.  **如果新进订单是买单**：\n        -   它将与最佳可用卖单（“最佳卖价”）进行撮合，该卖单位于 `sell_book` 数据结构的头部。\n        -   如果卖单簿不为空，且新进买单价格大于或等于最佳卖价，即 $p_{b, in} \\ge p_{s, best}$，则可以发生撮合。\n        -   只要新进订单还有剩余数量且价格条件成立，撮合过程就会重复进行。在每个步骤中：\n            a.  根据守恒规则，撮合数量 $q$ 是新进订单剩余数量和挂单卖单数量的最小值：$q = \\min(v_{incoming}, v_{resting})$。\n            b.  总成交量 $V_{\\text{exec}}$ 增加 $q$。\n            c.  新进订单和挂单的数量都减少 $q$。\n            d.  如果挂单卖单的数量变为 $0$，则将其从队列中移除。如果这导致该价格水平的队列为空，则从 `sell_book` 中移除整个价格水平。\n        -   如果在所有可能的撮合之后，新进买单仍有剩余数量（$v_{in}  0$），它将作为新的挂单被添加到 `buy_book` 中，并附带其到达时间 $t$ 和剩余数量。\n\n    4.  **如果新进订单是卖单**：\n        -   逻辑是对称的。它将与 `buy_book` 中的最佳可用买单（“最佳买价”）进行撮合。\n        -   如果买单簿不为空，且 $p_{s, in} \\le p_{b, best}$，则发生撮合。\n        -   撮合过程迭代进行，如上所述减少数量并更新 $V_{\\text{exec}}$。如果一个挂单买单被完全成交，它将被从订单簿中移除。\n        -   新进卖单的任何剩余数量都将被添加到 `sell_book` 中。\n\n**3. 最终输出计算**\n\n在处理完一个测试用例序列中的所有订单后，根据订单簿的最终状态计算所需的最终指标：\n\n-   **总成交量 ($V_{\\text{exec}}$)**：该值在整个模拟过程中累计得出。\n-   **最佳买价 ($(p_{\\text{bid}}, v_{\\text{bid}})$)**：\n    -   如果 `buy_book` 为空，结果为 $(-1, 0)$。\n    -   否则，最佳买价是 `buy_book` 中的第一个价格水平。价格 $p_{\\text{bid}}$ 是该水平的价格。数量 $v_{\\text{bid}}$ 是该价格水平队列中所有订单数量的总和。\n-   **最佳卖价 ($(p_{\\text{ask}}, v_{\\text{ask}})$)**：\n    -   如果 `sell_book` 为空，结果为 $(-1, 0)$。\n    -   否则，最佳卖价是 `sell_book` 中的第一个价格水平。价格 $p_{\\text{ask}}$ 是其价格，数量 $v_{\\text{ask}}$ 是该价格上所有订单的总量。\n\n这种结构化的方法确保了问题陈述中定义的所有规则——价格-时间优先、撮合逻辑和数量守恒——都得到严格遵守，从而对任何给定的输入序列都能得到一个确定且正确的最终状态。", "answer": "```python\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the simulation for each,\n    and print the results in the required format.\n    \"\"\"\n    # Define test cases as specified in the problem statement.\n    # Each order is a tuple: (side, price, volume)\n    test_cases = [\n        # Case 1\n        [('BUY', 100, 10), ('SELL', 99, 5), ('SELL', 100, 4), ('SELL', 101, 10)],\n        # Case 2\n        [('SELL', 50, 10), ('SELL', 50, 7), ('BUY', 50, 12)],\n        # Case 3\n        [('BUY', 30, 3), ('BUY', 30, 4), ('SELL', 25, 5)],\n        # Case 4\n        [('BUY', 20, 10), ('SELL', 25, 1), ('BUY', 19, 5)],\n        # Case 5\n        [('SELL', 42, 2), ('SELL', 45, 1), ('BUY', 50, 5)],\n    ]\n\n    all_results = []\n    for case_orders in test_cases:\n        result = process_order_sequence(case_orders)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    # e.g., [[9,100,1,101,10],[12,-1,0,50,5]]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef add_order_to_book(book, price, time, volume, is_buy):\n    \"\"\"\n    Adds a new order to the specified book, maintaining price sort order.\n    \n    A book is a list of [price, deque_of_orders], sorted by price.\n    - Buy book: descending price.\n    - Sell book: ascending price.\n    An order in the deque is a tuple (arrival_time, volume).\n    \"\"\"\n    # Find the correct position to insert or update.\n    for i, (p_level_price, order_queue) in enumerate(book):\n        if p_level_price == price:\n            order_queue.append((time, volume))\n            return\n        \n        # Determine insertion point to maintain sort order.\n        is_insert_point = (is_buy and price > p_level_price) or \\\n                          (not is_buy and price  p_level_price)\n        if is_insert_point:\n            book.insert(i, [price, collections.deque([(time, volume)])])\n            return\n    \n    # If the loop completes, append to the end.\n    book.append([price, collections.deque([(time, volume)])])\n\ndef process_order_sequence(orders):\n    \"\"\"\n    Processes a single sequence of orders and returns the final book state summary.\n    \"\"\"\n    # The buy_book is sorted by price descending.\n    # Each element: [price, collections.deque([(time, volume), ...])]\n    buy_book = []\n    \n    # The sell_book is sorted by price ascending.\n    sell_book = []\n\n    total_executed_volume = 0\n    arrival_time = 0\n\n    for side, price, volume in orders:\n        arrival_time += 1\n        \n        # Enforce problem constraints\n        if price  1 or volume  1:\n            # Skip invalid orders as a robust measure, though test data is valid.\n            continue\n        \n        if side == 'BUY':\n            volume_in = volume\n            # Match against the sell book\n            while volume_in > 0 and sell_book and price >= sell_book[0][0]:\n                best_ask_price_level = sell_book[0]\n                best_ask_queue = best_ask_price_level[1]\n                resting_order_time, resting_order_vol = best_ask_queue[0]\n\n                matched_vol = min(volume_in, resting_order_vol)\n                total_executed_volume += matched_vol\n                volume_in -= matched_vol\n                \n                new_resting_vol = resting_order_vol - matched_vol\n                if new_resting_vol == 0:\n                    best_ask_queue.popleft()\n                else:\n                    best_ask_queue[0] = (resting_order_time, new_resting_vol)\n                \n                if not best_ask_queue:\n                    sell_book.pop(0)\n\n            if volume_in > 0:\n                add_order_to_book(buy_book, price, arrival_time, volume_in, is_buy=True)\n\n        elif side == 'SELL':\n            volume_in = volume\n            # Match against the buy book\n            while volume_in > 0 and buy_book and price = buy_book[0][0]:\n                best_bid_price_level = buy_book[0]\n                best_bid_queue = best_bid_price_level[1]\n                resting_order_time, resting_order_vol = best_bid_queue[0]\n\n                matched_vol = min(volume_in, resting_order_vol)\n                total_executed_volume += matched_vol\n                volume_in -= matched_vol\n\n                new_resting_vol = resting_order_vol - matched_vol\n                if new_resting_vol == 0:\n                    best_bid_queue.popleft()\n                else:\n                    best_bid_queue[0] = (resting_order_time, new_resting_vol)\n                \n                if not best_bid_queue:\n                    buy_book.pop(0)\n\n            if volume_in > 0:\n                add_order_to_book(sell_book, price, arrival_time, volume_in, is_buy=False)\n\n    # Calculate final results for the test case\n    p_bid, v_bid = (-1, 0)\n    if buy_book:\n        p_bid = buy_book[0][0]\n        v_bid = sum(order[1] for order in buy_book[0][1])\n\n    p_ask, v_ask = (-1, 0)\n    if sell_book:\n        p_ask = sell_book[0][0]\n        v_ask = sum(order[1] for order in sell_book[0][1])\n\n    return [total_executed_volume, p_bid, v_bid, p_ask, v_ask]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3223154"}]}