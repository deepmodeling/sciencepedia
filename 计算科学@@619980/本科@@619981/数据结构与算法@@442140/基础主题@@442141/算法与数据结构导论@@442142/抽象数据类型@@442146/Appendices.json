{"hands_on_practices": [{"introduction": "抽象数据类型（ADT）的核心原则在于将“做什么”（接口）与“如何做”（实现）相分离。这项练习将引导你专注于这一核心原则，你将仅使用抽象的数学概念来定义一个环形缓冲区（`RingBuffer`）ADT。通过这种方式，你将练习在不受数组或模运算等具体实现细节的束缚下，思考其行为和公理，这对于提升你在软件设计与验证中形式化地规约数据结构的能力至关重要。[@problem_id:3202558]", "problem": "一个抽象数据类型由一个状态集合 $S$、一个具有精确定义域和陪域的操作集合 $Ops$ 以及约束这些操作如何转换状态和产生结果的公理来定义。对于一个标准的先进先出队列 (Queue)，其状态是元素集 $E$ 上的一个序列（$E$ 是固定的但其他方面是任意的），诸如 $enqueue$、$dequeue$ 和 $front$ 等操作在该序列上定义，并有公理来强制执行先进先出的规则。一个纯粹的抽象数据类型规范必须只涉及数学对象，如集合、序列以及全函数或偏函数，并且不得涉及实现细节，如数组、指针、索引或模运算。\n\n考虑将环形缓冲区（循环队列）定义为一个具有满时覆写语义的纯粹抽象数据类型。其容量在创建时固定，之后不再改变。其意图是，当缓冲区已满并发生 $enqueue$ 操作时，最旧的元素被丢弃以便为新元素腾出空间；所有其他行为（如 $dequeue$ 和 $front$）必须保持剩余元素的先进先出顺序。相比之下，标准的队列抽象数据类型在概念上是无界的，并且从不覆写元素；当一个队列用有限容器实现时，这种有限性是一个实现约束，而不是该抽象数据类型公理的一部分。\n\n哪个选项最准确地给出了一个具有满时覆写语义的环形缓冲区的纯粹抽象数据类型规范，并明确地将其公理与标准队列抽象数据类型的公理进行了对比，同时没有涉及表示细节？\n\nA. 状态是序列 $s \\in E^{\\le k}$，其中 $k \\in \\mathbb{N}$ 在创建时固定且 $|s| \\le k$。操作是偏函数：\n- $empty(s)$ 当且仅当 $|s| = 0$ 时返回 $\\mathsf{true}$；$full(s)$ 当且仅当 $|s| = k$ 时返回 $\\mathsf{true}$；$size(s) = |s|$；$capacity(s) = k$。\n- $enqueue(s, x)$ 返回一个新状态 $s'$，定义如下：\n  如果 $|s|  k$，则 $s' = s \\cdot x$；否则 $s' = drop\\_1(s) \\cdot x$，其中 $drop\\_1(s)$ 移除 $s$ 的第一个（最旧的）元素，$\\cdot$ 表示序列连接。\n- $dequeue(s)$ 仅在 $|s| > 0$ 时定义，并返回一个对 $(y, s')$，其中 $y$ 等于 $s$ 的第一个元素，$s'$ 等于 $drop\\_1(s)$；$front(s)$ 仅在 $|s| > 0$ 时定义，并返回第一个元素。\n公理强制规定，在 $enqueue$ 和 $dequeue$ 操作下序列顺序得以保持，$capacity(s)$ 是一个等于 $k$ 的不变量，并且 $enqueue$ 操作永远不会使 $|s|$ 超过 $k$。相比之下，标准队列的状态为 $s \\in E^{*}$（对 $|s|$ 没有限制），$full(s)$ 总是 $\\mathsf{false}$，并且 $enqueue(s, x)$ 总是产生 $s' = s \\cdot x$（从不覆写）。\n\nB. 状态由数组索引 $head, tail \\in \\mathbb{Z}$ 和一个固定数组 $A[0..k-1]$ 给出。操作 $enqueue$ 将 $x$ 写入 $A[tail]$，然后设置 $tail := (tail + 1) \\bmod k$，如果 $tail = head$ 则设置 $head := (head + 1) \\bmod k$。操作 $dequeue$ 读取 $A[head]$ 并设置 $head := (head + 1) \\bmod k$。这与队列的不同之处在于它对索引使用了模运算，但在其他方面是相同的。\n\nC. 状态是序列 $s \\in E^{*}$，带有一个可在需要时增长的可变容量函数 $capacity(s)$。操作 $enqueue(s, x)$ 总是返回 $s' = s \\cdot x$，如果 $|s| = capacity(s)$，则 $capacity(s') := capacity(s) + 1$。这与队列的不同之处在于它跟踪一个可自动调整大小的容量。\n\nD. 状态是序列 $s \\in E^{\\le k}$，但当 $|s| = k$ 时，$enqueue(s, x)$ 返回一个错误而不修改 $s$，而对 $|s| = 0$ 的 $dequeue(s)$ 返回一个特殊值 $\\bot \\in E$。这与队列的不同之处在于它有容量并在满时会出错，但除此之外公理是相同的。\n\nE. 状态是最多包含 $k$ 个元素的集合 $S \\subseteq E$。当 $|S| = k$ 时，操作 $enqueue(S, x)$ 从 $S$ 中移除一个任意元素并插入 $x$。操作 $dequeue(S)$ 返回 $S$ 中的任意元素。这与队列的不同之处在于它限制了基数，但通过完全避免使用序列来保持其抽象性质。", "solution": "问题要求为具有固定容量和满时覆写语义的环形缓冲区（或循环队列）构建一个纯粹的抽象数据类型 (ADT) 的规范。一个纯粹的 ADT 必须使用抽象的数学概念（如集合和序列）来定义，并且必须不包含实现细节，如数组、索引或指针。该规范还必须与标准的、无界队列 ADT 的规范进行对比。\n\n首先，让我们为一个基于序列的数据结构建立纯粹 ADT 规范的核心原则。\n- **状态空间**：ADT 的状态由一个数学对象表示。对于一个有序集合，序列是自然的选择。一个标准的、无界的队列的状态空间是 $s \\in E^*$，其中 $E$ 是元素集，$E^*$ 是 $E$ 上所有有限序列的集合。对于一个容量为 $k$ 的固定容量环形缓冲区，状态必须是一个长度 $|s|$ 不超过 $k$ 的序列 $s$。因此，状态空间是 $E^{\\le k} = \\{s \\in E^* | |s| \\le k \\}$。\n- **操作**：操作被定义为状态空间上的数学函数。它们将一个状态（可能还有其他参数）映射到一个新状态和/或一个结果值。\n- **公理**：这些是描述操作行为的形式化规则。例如，它们定义了 $enqueue$ 和 $dequeue$ 如何相互作用以强制执行先进先出 (FIFO) 规则。\n\n现在，让我们为固定容量 $k \\in \\mathbb{N}$ 定义所需的具有满时覆写语义的环形缓冲区 ADT。\n- 设状态为一个序列 $s \\in E^{\\le k}$。队列的头部（最旧的元素）是序列的第一个元素，尾部（最新的元素）是最后一个元素。\n- 操作 $enqueue(s, x)$ 必须处理两种情况：\n    1. 如果缓冲区未满，即 $|s|  k$，新元素 $x$ 被附加到序列末尾。新状态为 $s' = s \\cdot x$，其中 $\\cdot$ 表示序列连接。\n    2. 如果缓冲区已满，即 $|s| = k$，必须移除最旧的元素以腾出空间。最旧的元素是序列中的第一个元素。设 $drop\\_1(s)$ 是返回移除了第一个元素的序列 $s$ 的操作。然后将新元素 $x$ 附加到末尾。新状态为 $s' = drop\\_1(s) \\cdot x$。\n- 操作 $dequeue(s)$ 是一个偏函数，仅当缓冲区不为空 ($|s| > 0$) 时定义。它必须返回最旧的元素（序列的第一个元素）和新状态（移除了第一个元素的序列）。所以，$dequeue(s)$ 返回一个对 $(y, s')$，其中 $y$ 是 $s$ 的第一个元素，$s' = drop\\_1(s)$。\n- 操作 $front(s)$ 也是一个偏函数，为 $|s| > 0$ 定义。它返回最旧的元素（序列的第一个元素）而不修改状态。\n- 像 $size(s)=|s|$、$capacity(s)=k$、$empty(s) \\iff |s|=0$ 和 $full(s) \\iff |s|=k$ 这样的辅助操作完善了该规范。\n\n这个规范是纯粹的，因为它完全依赖于序列的数学理论。它与标准的队列 ADT 形成对比，后者的状态空间是 $E^*$（无界的），$full(s)$ 永远不为真，并且 $enqueue$ 的公理总是 $enqueue(s, x) \\rightarrow s \\cdot x$，没有覆写情况。\n\n现在，我们根据这个形式化的推导来评估每个选项。\n\n**选项 A**\n- **状态**：定义为序列 $s \\in E^{\\le k}$，具有固定的容量 $k$。这正确定地模拟了一个固定容量的结构。\n- **操作**：\n    - 基于序列长度 $|s|$ 的 $empty(s)$、$full(s)$、$size(s)$ 和 $capacity(s)$ 的定义是正确的。\n    - $enqueue(s, x)$ 的定义正确地区分了未满的情况（$|s|  k$），此时返回 $s \\cdot x$，和已满的情况，此时返回 $drop\\_1(s) \\cdot x$。这精确地使用抽象序列操作捕捉了满时覆写的语义。\n    - $dequeue(s)$ 和 $front(s)$ 的定义正确地将序列的第一个元素确定为要返回/移除的元素，保持了 FIFO 规则。\n- **纯粹性**：该规范仅使用序列、序列长度、连接以及按位置（第一个）访问/移除元素。它避免了实现细节，如数组、索引和模运算。这是一个纯粹的 ADT 规范。\n- **与队列的对比**：对比是准确的。标准队列的状态为 $s \\in E^*$，永不为满，其 $enqueue$ 操作更简单，从不覆写。\n- **结论**：**正确**。该选项为所描述的环形缓冲区提供了一个完美无瑕的纯粹 ADT 规范。\n\n**选项 B**\n- **状态**：使用数组 $A[0..k-1]$ 和整数索引 $head$ 和 $tail$ 定义。\n- **操作**：使用数组访问和对索引的模运算来定义，例如 $tail := (tail + 1) \\bmod k$。\n- **纯粹性**：这直接违反了对纯粹 ADT 规范的要求。它描述的是环形缓冲区的一种常见**实现**，而不是其抽象类型。问题明确禁止提及“数组、指针、索引或模运算”。\n- **结论**：**不正确**。\n\n**选项 C**\n- **状态**：定义为序列 $s \\in E^*$，这意味着概念上是无界的大小。它引入了一个“可变的容量函数”。\n- **操作**：$enqueue$ 操作总是附加元素，如果达到容量，容量本身会增长。\n- **行为**：这描述了一个动态调整大小的队列，而不是一个具有**固定容量**和**覆写**语义的环形缓冲区。指定的行为与要求从根本上不同。\n- **结论**：**不正确**。\n\n**选项 D**\n- **状态**：定义为序列 $s \\in E^{\\le k}$，这是一个正确的起点。\n- **操作**：当 $|s|=k$ 时，$enqueue(s, x)$ 操作“返回一个错误而不修改 $s$”。\n- **行为**：这描述了一个**有界队列**，它在满时会发出错误信号或阻塞。它没有实现指定的“满时覆写”语义，即丢弃最旧的元素为新元素腾出空间。\n- **结论**：**不正确**。\n\n**选项 E**\n- **状态**：定义为集合 $S \\subseteq E$。集合是一个无序的、由不同元素组成的集合。\n- **行为**：使用集合作为状态从根本上破坏了 FIFO 规则。顺序对于队列来说是必不可少的。操作证实了这个缺陷：满时的 $enqueue$ 会移除一个“任意”元素，而 $dequeue$ 会返回“任何”元素。这不是一个队列。\n- **结论**：**不正确**。\n\n基于以上分析，选项 A 是唯一一个为具有满时覆写语义的环形缓冲区提供正确且纯粹的 ADT 规范的选项，且与问题陈述的所有要求一致。", "answer": "$$\\boxed{A}$$", "id": "3202558"}, {"introduction": "从纯粹的规约转向实际设计，这项练习将挑战你构建一个用于在数据流中查找中位数的ADT。你将学习如何通过巧妙组合更简单、更知名的数据结构——在这里是两个堆——来创造一个功能更强大的新ADT。此问题突出了维护结构不变量对于保证算法正确性和实现高性能应用所需的对数时间复杂度的重要性。[@problem_id:3202610]", "problem": "考虑设计一个用于在线中位数服务的抽象数据类型 (ADT)，该服务存储一个可比较键的多重集并支持流式更新。该 ADT 称为 OnlineMedian，必须支持以下具有明确定义语义的操作：插入一个键 $\\;x\\;$ 为 $\\;\\mathrm{insert}(x)$，如果存在则删除一个键 $\\;x\\;$ 的出现为 $\\;\\mathrm{delete}(x)$，查询当前中位数为 $\\;\\mathrm{median}()\\;$，报告当前大小为 $\\;\\mathrm{size}()\\;$，以及测试是否为空为 $\\;\\mathrm{isEmpty}()\\;$。中位数必须确定性地定义为下中位数：对于大小为 $\\;n\\;$ 的多重集，如果 $\\;n\\;$ 是奇数，$\\;\\mathrm{median}()\\;$ 返回排序后唯一的中间元素；如果 $\\;n\\;$ 是偶数，它返回排序后排名为 $\\;\\lfloor n/2 \\rfloor\\;$ 的元素，即下半部分的最大值。ADT 必须维持一个不变式，即 $\\;\\mathrm{median}()\\;$ 返回存储的键之一（而不是平均值）。实现约束是 OnlineMedian 必须使用恰好两个堆来实现：一个最大二叉堆（优先队列）$\\;H_{\\mathrm{low}}\\;$ 存储下半部分，一个最小二叉堆 $\\;H_{\\mathrm{high}}\\;$ 存储上半部分。目标是在任意的 $\\;\\mathrm{insert}\\;$ 和 $\\;\\mathrm{delete}\\;$ 操作流下保持正确性，并使每个操作的时间复杂度保持在 $\\;O(\\log n)\\;$ 内（其中 $\\;n\\;$ 是当前大小），包括更新后任何必要的再平衡。此外，设计在删除和再平衡操作下必须是稳定的，即所选的中位数仅在集合更新和堆分区边界逻辑上强制其改变时才改变，而不是由于实现细节产物；具体来说，重复插入和删除等于中位数的键不能导致 $\\;\\mathrm{median}()\\;$ 的不确定性振荡。\n\n从基本定义和经过充分验证的事实出发：\n- 二叉堆是一个具有堆序性质的完全二叉树；最大二叉堆的根部始终是最大键，最小二叉堆的根部始终是最小键。\n- 标准堆操作（适用时的插入、提取根、增加/减少键）对于大小为 $\\;m\\;$ 的堆，运行时间为 $\\;O(\\log m)\\;$，因为完全二叉树的高度为 $\\;O(\\log m)\\;$。\n- 由二叉堆实现的优先队列支持 $\\;O(1)\\;$ 时间的根访问和 $\\;O(\\log m)\\;$ 时间的更新。\n\n以下哪个选项给出了正确的 ADT 规范，以及足以确保 $\\;\\mathrm{median}()\\;$ 的正确性和在删除与再平衡下的稳定性，同时保持每个操作时间复杂度为 $\\;O(\\log n)\\;$ 的不变式、删除策略和再平衡规则？\n\nA. 维护两个堆，其不变式为：$\\;|H_{\\mathrm{low}}| \\in \\{|H_{\\mathrm{high}}|, |H_{\\mathrm{high}}|+1\\}\\;$ 并且 $\\;H_{\\mathrm{low}}\\;$ 中的每个键都 $\\;\\le\\;$ $\\;H_{\\mathrm{high}}\\;$ 中的每个键。对于所有 $\\;n \\ge 1\\;$，将 $\\;\\mathrm{median}()\\;$ 定义为 $\\;H_{\\mathrm{low}}\\;$ 的根（下中位数）。实现 $\\;\\mathrm{insert}(x)\\;$ 的方法是：如果 $\\;x \\le \\mathrm{root}(H_{\\mathrm{low}})\\;$ （或者如果 $\\;H_{\\mathrm{low}}\\;$ 为空），则将 $\\;x\\;$ 插入 $\\;H_{\\mathrm{low}}\\;$，否则插入 $\\;H_{\\mathrm{high}}\\;$。插入后，如果 $\\;|H_{\\mathrm{low}}| = |H_{\\mathrm{high}}|+2\\;$，将 $\\;\\mathrm{root}(H_{\\mathrm{low}})\\;$ 移至 $\\;H_{\\mathrm{high}}\\;$；如果 $\\;|H_{\\mathrm{high}}| = |H_{\\mathrm{low}}|+1\\;$，将 $\\;\\mathrm{root}(H_{\\mathrm{high}})\\;$ 移至 $\\;H_{\\mathrm{low}}\\;$。通过在哈希表中使用每个值的计数器实现惰性删除来实现 $\\;\\mathrm{delete}(x)\\;$：删除时递减 $\\;x\\;$ 的计数器，并且每当访问 $\\;\\mathrm{root}(H_{\\mathrm{low}})\\;$ 或 $\\;\\mathrm{root}(H_{\\mathrm{high}})\\;$ 时，重复弹出其计数器指示没有活动实例的陈旧根。删除后使用相同的大小规则进行再平衡。论证在维护的分区下 $\\;\\mathrm{median}()\\;$ 是正确的，并且每个 $\\;\\mathrm{insert}\\;$ 和 $\\;\\mathrm{delete}\\;$ 执行常数数量的堆操作，每个操作为 $\\;O(\\log n)\\;$，外加 $\\;O(1)\\;$ 的哈希表更新，并且修剪陈旧根的摊销成本为每次更新 $\\;O(1)\\;$。\n\nB. 维护两个堆，其不变式为 $\\;H_{\\mathrm{low}}\\;$ 中的每个键都 $\\le$ $\\;H_{\\mathrm{high}}\\;$ 中的每个键，但允许 $\\;|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|\\;$ 无限制增长。无论 $\\;n\\;$ 为多少，都将 $\\;\\mathrm{median}()\\;$ 定义为 $\\;H_{\\mathrm{low}}\\;$ 的根，并且从不进行大小再平衡，因为堆访问反正也是 $\\;O(1)\\;$，堆插入是 $\\;O(\\log n)\\;$。处理 $\\;\\mathrm{delete}(x)\\;$ 的方法是：如果 $\\;x\\;$ 在某个堆的根部，则从该堆中删除它；否则什么也不做，直到 $\\;x\\;$ 到达根部。\n\nC. 维护与选项 A 中相同的分区，但每当 $\\;|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}| = 1\\;$ 时，通过提取所有元素并重新分区来重建两个堆，以恢复大小的完全相等。当 $\\;n\\;$ 为偶数时，将 $\\;\\mathrm{median}()\\;$ 定义为两个根的平均值，当 $\\;n\\;$ 为奇数时，定义为 $\\;\\mathrm{root}(H_{\\mathrm{low}})\\;$。通过线性扫描两个堆来找到 $\\;x\\;$，然后通过上浮或下沉来修复堆，以实现 $\\;\\mathrm{delete}(x)\\;$。\n\nD. 维护两个堆，其大小不变式为 $\\;||H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|| \\le 2\\;$，排序不变式为 $\\;H_{\\mathrm{low}}\\;$ 中的每个键都 $\\;\\le\\;$ $\\;H_{\\mathrm{high}}\\;$ 中的每个键。将 $\\;\\mathrm{median}()\\;$ 定义为较大堆的根；当大小相差 $\\;2\\;$ 时，返回较大堆的根，并且仅当差异达到 $\\;3\\;$ 时才进行再平衡。通过对支持堆的数组进行线性搜索，从当前包含 $\\;x\\;$ 的堆中移除它，然后重新堆化，以实现 $\\;\\mathrm{delete}(x)\\;$。\n\n选择满足所有要求的唯一最佳选项。", "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **ADT：** `OnlineMedian`，用于可比较键的多重集。\n*   **操作：** `insert(x)`、`delete(x)`、`median()`、`size()`、`isEmpty()`。\n*   **大小 `n`：** 多重集中当前的键数。\n*   **中位数定义：** 确定性地定义为“下中位数”。\n    *   如果 `n` 是奇数，中位数是排序后唯一的中间元素。\n    *   如果 `n` 是偶数，中位数是排序后排名为 `\\lfloor n/2 \\rfloor` 的元素。\n    *   问题陈述也称其为“下半部分的最大值”。\n    *   中位数必须是存储的键，而不是平均值。\n*   **实现约束：** 使用恰好两个二叉堆：\n    *   `H_low`：一个用于下半部分的最大二叉堆。\n    *   `H_high`：一个用于上半部分的最小二叉堆。\n*   **性能约束：** 所有操作必须在 `O(\\log n)` 时间内完成。\n*   **稳定性约束：** 中位数只应在逻辑上必要时才改变，并且不应因为对中位数键的重复插入/删除而因实现细节产物导致振荡。\n*   **已知事实：** 二叉堆的标准属性，包括更新的 `O(\\log m)` 时间和根访问的 `O(1)` 时间。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n首先，让我们精确地形式化中位数的定义。假设多重集排序为 `$e_1 \\le e_2 \\le \\dots \\le e_n$`。\n*   如果 `n` 是奇数，设 `n = 2k+1`。“唯一的中间元素”排名为 `k+1`。这也等于 `\\lceil n/2 \\rceil`。\n*   如果 `n` 是偶数，设 `n = 2k`。问题陈述中位数排名为 $\\lfloor n/2 \\rfloor = k$。注意，标准定义有时使用排名 `k+1`（两个中心元素中较小的一个）。然而，这个问题给出了一个明确的定义。让我们验证其一致性。对于 `n=5`，排名是 `3`。对于 `n=6`，排名是 `3`。对于奇数情况，这不是 $\\lfloor n/2 \\rfloor$ ($\\lfloor 5/2 \\rfloor = 2$)。让我们遵循问题的分段定义。\n    *   奇数 `n=2k+1`：排名 `k+1`。例如 `n=5`，排名 `3`。\n    *   偶数 `n=2k`：排名 `k`。例如 `n=4`，排名 `2`。\n这个排名的一个统一公式是 `\\lceil n/2 \\rceil`。\n    *   对于 `n=2k+1`，$\\lceil (2k+1)/2 \\rceil = \\lceil k+0.5 \\rceil = k+1$。这匹配。\n    *   对于 `n=2k`，$\\lceil (2k)/2 \\rceil = k$。问题中说是排名 $\\lfloor n/2 \\rfloor=k$。这也匹配。\n因此，中位数是在 1-索引排序的多重集中排名为 `r = \\lceil n/2 \\rceil` 的元素。\n\n问题提出了一种双堆结构来找到这个中位数。这是算法设计中一种标准且易于理解的方法。在 `O(\\log n)` 时间内完成 `delete(x)` 的要求是一个不平凡的扩展，但可以解决，通常使用惰性删除或通过使用哈希表来增强堆。问题定义明确，在计算机科学中有科学依据，并且所有术语都已指定。它不是不完整、矛盾或不适定的。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。我们可以继续进行求解。\n\n### 基于原理的推导与选项分析\n\n目标是将 `n` 个元素划分为下半部分 `L` 和上半部分 `H`，以便能够高效地找到中位数。中位数是排名为 `\\lceil n/2 \\rceil` 的元素，也就是 `\\lceil n/2 \\rceil` 个最小元素集合中的最大元素。\n\n这自然引出了以下设计：\n1.  `H_low`（一个最大堆）将存储 `\\lceil n/2 \\rceil` 个最小的元素。\n2.  `H_high`（一个最小堆）将存储剩下的 `\\lfloor n/2 \\rfloor` 个最大的元素。\n\n从这个设计中，出现了两个核心不变式：\n*   **分区不变式：** `H_low` 中的每个键必须小于或等于 `H_high` 中的每个键。如果 `max(H_low) \\le min(H_high)`，即 `root(H_low) \\le root(H_high)`，则该不变式得以维持。\n*   **大小不变式：** 堆的大小必须是 `|H_low| = \\lceil n/2 \\rceil` 和 `|H_high| = \\lfloor n/2 \\rfloor`。这等同于要求 `|H_low| = |H_high|`（当 `n` 为偶数时）或 `|H_low| = |H_high| + 1`（当 `n` 为奇数时）。\n\n有了这些不变式，`median()` 就是下半部分的最大值，即 `root(H_low)`。访问根是 `O(1)` 的。\n\n**操作：**\n*   **`insert(x)`**：为维持分区不变式，如果 `x` 小于或等于当前中位数（`root(H_low)`），它必须属于下半部分集合。因此，我们将 `x` 插入 `H_low`。否则，我们将其插入 `H_high`。插入后，大小不变式可能会被违反。需要一个再平衡步骤：如果一个堆变得过大，它的根被提取并插入到另一个堆中。这涉及常数次堆操作，使得 `insert(x)` 成为一个 `O(\\log n)` 操作。\n*   **`delete(x)`**：在堆中查找任意元素 `x` 需要 `O(n)` 时间，这违反了性能约束。为了达到 `O(\\log n)`，需要一种更复杂的方法。不能简单地用哈希表的指针来增强堆，因为元素在堆操作期间会移动。标准且最稳健的解决方案是**惰性删除**。我们为元素维护一个计数哈希表。`delete(x)` 操作只是在 `O(1)` 时间内递减一个计数器。堆中将包含计数为零的“陈旧”元素。当这些陈旧元素到达任一堆的根部，并且在进行中位数查询或再平衡步骤时需要它们时，必须将它们物理删除。这个清理过程（例如，`while count[root(H)] == 0: H.extract_root()`）会增加成本。虽然单次操作可能触发多次这样的删除，但这个成本在每次更新操作上摊销为 `O(\\log n)`，因为每个元素最多被插入一次、标记为删除一次、并从堆中物理删除一次。\n\n现在，我们基于此设计评估给定的选项。\n\n**A. 维护两个堆，其不变式为：`|H_{\\mathrm{low}}| \\in \\{|H_{\\mathrm{high}}|, |H_{\\mathrm{high}}|+1\\}` 并且 `H_{\\mathrm{low}}` 中的每个键都 `\\le` `H_{\\mathrm{high}}` 中的每个键。将 `median()` 定义为 `H_{\\mathrm{low}}` 的根。 ... 通过在哈希表中使用每个值的计数器实现惰性删除来实现 `delete(x)`...**\n\n*   **分析：** 此选项正确地确定了大小不变式 `|H_{\\mathrm{low}}| = \\lceil n/2 \\rceil` 和分区不变式 `max(H_{low}) \\le min(H_{high})`。将 `median()` 定义为 `root(H_{\\mathrm{low}})` 是这些不变式的直接结果。插入逻辑（`x \\le root(H_{\\mathrm{low}})` 指向 `H_{\\mathrm{low}}`）和再平衡规则完全正确。关键是，它提出了使用哈希表进行惰性删除来处理 `delete(x)`，这是实现所需的 `O(\\log n)` 摊销时间复杂度的正确方法。在访问根时，正确地将清理陈旧根确定为一个必要步骤。时间复杂度分析是合理的；每个操作需要常数次堆操作和哈希表查找，导致总体摊销时间为 `O(\\log n)`。稳定性也得到了保证，因为等于中位数的元素被确定性地放置在 `H_{\\mathrm{low}}` 中。\n*   **结论：** **正确**。\n\n**B. 维护两个堆，其不变式为 `H_{\\mathrm{low}}` 中的每个键都 `` `H_{\\mathrm{high}}` 中的每个键，但允许 `|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|` 无限制增长。将 `median()` 定义为 `H_{\\mathrm{low}}` 的根，无论 `n` 为多少，并且从不进行大小再平衡...**\n\n*   **分析：** 这个选项有多个致命缺陷。首先，如果 `|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|` 是无界的，堆就不再代表数据的下半部分和上半部分。`root(H_{\\mathrm{low}})` 将不会是中位数。放弃再平衡使得整个双堆中位数查找算法的前提失效。其次，删除策略——“什么也不做，直到 `x` 到达根部”——不是一个有效的算法，因为一个元素不保证会到达根部。第三，严格不等式 `key_low  key_high` 对于多重集是有问题的，因为不清楚如何放置边界值 `max(H_{low})` 的重复项。\n*   **结论：** **不正确**。\n\n**C. 维护与选项 A 中相同的分区，但每当 `|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}| = 1` 时，通过提取所有元素并重新分区来重建两个堆... 当 `n` 为偶数时将 `median()` 定义为两个根的平均值... 通过线性扫描两个堆来实现 `delete(x)`...**\n\n*   **分析：** 此选项因几个原因而不正确。重建堆的再平衡策略效率极低，需要 `O(n)` 或 `O(n \\log n)` 时间，这违反了每个操作 `O(\\log n)` 的约束。当 `n` 为偶数时将中位数定义为平均值，直接与问题要求中位数必须是存储的键之一相矛盾。最后，用线性扫描实现 `delete(x)` 是一个 `O(n)` 操作，再次违反了时间复杂度约束。\n*   **结论：** **不正确**。\n\n**D. 维护两个堆，其大小不变式为 `||H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|| \\le 2` ... 将 `median()` 定义为较大堆的根... 通过线性搜索来实现 `delete(x)`...**\n\n*   **分析：** 这个选项也是有缺陷的。大小不变式 `||H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|| \\le 2` 太宽松了。如果 `n=10`，正确的分割是 `(5,5)`。这个不变式将允许 `(6,4)`。在这种情况下，`H_{\\mathrm{low}}` 的大小为 `6`，其根可能是排名为 `6` 的元素，而不是所需的中位数（排名为 `5`）。将中位数定义为“较大堆的根”不是找到第 `\\lceil n/2 \\rceil` 个元素的一致方法。与选项 C 一样，它也提出了 `O(n)` 的线性搜索来进行删除，违反了性能要求。\n*   **结论：** **不正确**。\n\n基于详细分析，选项 A 是唯一一个为 `OnlineMedian` ADT 提供了正确、全面且高效的规范，满足了问题陈述中列出的所有约束。", "answer": "$$\\boxed{A}$$", "id": "3202610"}, {"introduction": "尽管ADT定义了清晰的接口，但其性能承诺的实现完全依赖于底层的实现。这项练习深入探讨了用压缩Trie树实现字典ADT时所面临的关键设计抉择。通过分析节点结构、边分裂与合并等不同策略，你将更深刻地理解内部实现细节如何直接影响ADT操作的效率和正确性，从而体会到抽象与具体实现之间的紧密联系。[@problem_id:3202637]", "problem": "您正在设计一个字典抽象数据类型 (ADT)，用于存储一个动态的键集合，其中每个键是有限字母表 $\\Sigma$ 上的一个有限字符串。该 ADT 支持对键 $x$ 的三个操作：insert$(x)$、member$(x)$ 和 delete$(x)$。每个操作的目标运行时间为 $O(|x|)$（以所处理键的长度 $|x|$ 为度量），衡量标准是遍历数据结构过程中符号比较的总次数以及常数时间的指针或映射查找次数。您选择实现一个带路径压缩的 trie 树（也称为基数树或 Patricia trie），其中每条边都用 $\\Sigma$ 上的一个非空字符串标记，并且出度为 $1$ 的节点路径被压缩成一条单独的边。假设您的机器模型对单个符号的比较收取单位成本，并且在明确说明时，对常数时间的映射查找也收取单位成本。\n\n从第一性原理出发，回顾以下基本原理：\n- 字典 ADT 支持插入、搜索和删除，其时间成本在约定的成本模型下根据输入参数的大小来衡量。\n- trie 树通过从根节点开始，沿着查询字符串的符号向下遍历，直到叶节点或终止节点，来表示一个字符串集合。它利用查询字符串后续符号的信息来决定要跟随哪条出边。\n- 在压缩 trie 树中，每次内部遍历都会将查询字符串的下一段与当前边上的标签进行比较，直到出现第一个不匹配或边标签被完全消耗为止。沿着任何从根到节点的路径，比较的符号总数最多不超过所处理查询字符串的长度。\n\n您必须选择能够在上述模型下为所有三个操作保持 $O(|x|)$ 界限的设计决策。考虑以下关于节点和操作语义的候选设计选择。请选择所有正确且足以维持所述 $O(|x|)$ 界限的选项。\n\nA. 维护压缩 trie 树的不变性：每个节点要么表示某个存储键的终止，要么出度 $\\ge 2$，并且每条边的标签都是非空字符串。在每个节点处，存储一个以每条出边标签的第一个符号为键的子节点映射，支持每步期望 $O(1)$ 的查找（例如，使用哈希）。在 insert$(x)$ 操作中，通过比较符号与边标签进行遍历；当在边标签内部首次出现不匹配时，通过创建最多 $2$ 条新边来分裂该边，以便 $x$ 的不匹配符号开始一条新的子边。将边标签存储为常数时间的子字符串（在底层字符串或共享缓冲区上的偏移量和长度），这样分裂操作的开销只与比较的符号数量呈线性关系。在 delete$(x)$ 操作中，清除 $x$ 的终止标志，然后沿着搜索路径向上回溯，每当一个节点变为非终止节点且出度为 1 时，就通过连接它们的边标签将其与其唯一的子节点合并，而无需重新遍历路径外的节点。\n\nB. 在每个节点处，通过一个在节点创建时初始化的大小为 $|\\Sigma|$ 的固定数组来表示子节点，以使分支决策在最坏情况下是 $O(1)$。Insert$(x)$ 为任何新创建的节点分配并初始化一个新数组。删除语义不合并节点；相反，节点保持原样以避免结构更新。\n\nC. 在 member$(x)$ 或 insert$(x)$ 中从一个节点遍历时，为了选择正确的子节点，扫描该节点的所有出边，并选择其标签与 $x$ 未消耗的后缀共享最长公共前缀的那条边。如果没有边共享非空前缀，则创建一个新的子边，用 $x$ 的整个剩余后缀进行标记。将边标签作为实际字符串存储在每条边上，在分裂时根据需要复制字符。\n\nD. 在每个节点维护一个非负整数计数器，其值等于前缀路径中包含此节点并在其处或其下方终止的存储键的数量。在 delete$(x)$ 操作中，遍历搜索路径，递减计数器；每当计数器变为 0 时，立即移除该节点及其关联的入边。如果删除后，父节点变为非终止节点且出度为 1，则通过连接边标签将其与其唯一的子节点合并。子节点选择继续使用标准压缩 trie 树遍历中的常数时间映射查找。\n\nE. 在每个节点处存储从根到该节点的完整前缀字符串（除了边标签），以允许对路径前缀进行常数时间的相等性检查。在任何导致分裂边或合并边的插入或删除操作后，更新每个受影响后代节点存储的完整前缀字符串，以使其与新的从根到节点的路径保持一致。\n\n哪些选项是正确的？", "solution": "问题陈述已经过验证，被认为是合理的。它描述了数据结构分析中的一个标准问题，具体而言是使用压缩 trie 树（基数树）并带有特定性能目标来实现字典 ADT。该问题提法恰当、有科学依据且客观。\n\n核心要求是为压缩 trie 树确定能够保证 `insert(x)`、`member(x)` 和 `delete(x)` 操作时间复杂度为 `$O(|x|)$` 的设计选择，其中 `$|x|$` 是字符串键 `$x$` 的长度。成本模型包括符号比较和常数时间的查找（例如，在哈希表中）。\n\n对这些操作的原则性分析得出以下要求：\n\n1.  **遍历 (`member` 操作):** 为了从根开始沿着键 `$x$` 遍历 trie 树，我们执行一系列步骤。在每个节点，我们必须确定正确的出边，即其标签以 `$x$` 未消耗部分的下一个字符开头的那条边。为了达到整体 `$O(|x|)$` 的复杂度，每个节点的这个子节点查找步骤必须花费常数时间，即 `$O(1)`。选择一条边后，我们将其标签与 `$x$` 剩余部分的前缀进行比较。路径上所有边的符号比较总数以 `$|x|$` 为界。因此，通过 `$O(1)` 时间的子节点选择，`member(x)` 的总时间为 `$O(|x|)$`。\n\n2.  **插入 (`insert` 操作):** 插入操作遵循与 `member(x)` 相同的遍历路径。当 (a) 当前节点没有匹配的出边，或 (b) 在边标签内发现不匹配时，遍历结束。\n    *   在情况 (a) 中，会创建一个新的子边，用 `$x$` 的剩余部分作为标签。这在 `$O(|x|)$` 的遍历基础上增加了常数数量的节点/边操作。\n    *   在情况 (b) 中，必须分裂该边。一条标签为 `$L$` 的边 `$(u, v)$` 被一个新节点 `$w$`、一条标签为公共前缀的边 `$(u, w)` 和一条标签为 `$L$` 剩余部分的边 `$(w, v)` 所取代。同时，为 `$x$` 的剩余部分也创建一条新边 `$(w, z)`。为保持此分裂操作的高效性，创建新标签不应涉及复制长字符串。将边标签存储为指向共享缓冲区的指针或索引（将它们表示为“常数时间子字符串”），可以在遍历找到分裂点后以 `$O(1)` 的时间执行分裂。这确保了 `insert(x)` 保持在 `$O(|x|)$` 范围内。\n\n3.  **删除 (`delete` 操作):** 删除操作首先要找到与 `$x$` 对应的节点，这需要 `$O(|x|)$` 时间。然后该节点被标记为非终止。为了维护压缩 trie 树的不变性（即非终止的内部节点至少有两个子节点），我们可能需要进行结构性更改。如果取消标记一个节点 `$u$` 导致其父节点 `$p$` 成为非终止节点且出度降至 `$1$`，则 `$p$` 必须与其唯一的剩余子节点合并。此合并操作涉及连接所涉及的两条边（进入 `$p$` 的边和从 `$p$` 出去的边）的标签。这个过程可能需要沿着路径向根节点重复进行。这些合并的成本必须加以控制。即使连接两个长度为 `$L_1$` 和 `$L_2$` 的标签需要 `$O(L_1 + L_2)$` 的时间来创建新字符串，这项工作也是在对应于被删除键 `$x$` 的路径上执行的。这条路径上所有边的总长度最多为 `$|x|$`。因此，沿路径所有合并的总成本以 `$O(|x|)$` 为界，`delete(x)` 的总体复杂度保持为 `$O(|x|)$`。\n\n在确立了这些原则之后，我们来评估每个选项。\n\n**A. 维护压缩 trie 树的不变性：每个节点要么表示某个存储键的终止，要么出度 $\\ge 2$，并且每条边的标签都是非空字符串。在每个节点处，存储一个以每条出边标签的第一个符号为键的子节点映射，支持每步期望 $O(1)$ 的查找（例如，使用哈希）。在 insert$(x)$ 操作中，通过比较符号与边标签进行遍历；当在边标签内部首次出现不匹配时，通过创建最多 $2$ 条新边来分裂该边，以便 $x$ 的不匹配符号开始一条新的子边。将边标签存储为常数时间的子字符串（在底层字符串或共享缓冲区上的偏移量和长度），这样分裂操作的开销只与比较的符号数量呈线性关系。在 delete$(x)$ 操作中，清除 $x$ 的终止标志，然后沿着搜索路径向上回溯，每当一个节点变为非终止节点且出度为 1 时，就通过连接它们的边标签将其与其唯一的子节点合并，而无需重新遍历路径外的节点。**\n\n该选项描述了一种规范、正确且高效的压缩 trie 树实现。\n-   **子节点查找:** 使用哈希表作为子节点指针，提供了所要求的期望 `$O(1)` 查找。\n-   **插入:** 边分裂过程是正确的。使用“常数时间子字符串”是标准技术，可确保分裂操作不会引入超出 `$O(|x|)$` 遍历的成本。\n-   **删除:** 沿路径向上回溯并合并出度为 `$1$` 的非终止节点的程序，是维护压缩 trie 树不变性的正确方法。如上文分析，这些合并的成本局限于 `$x$` 的路径上，因此总复杂度保持为 `$O(|x|)$`。\n所有描述的技术都是正确且充分的。\n\n结论: **正确**。\n\n**B. 在每个节点处，通过一个在节点创建时初始化的大小为 $|\\Sigma|$ 的固定数组来表示子节点，以使分支决策在最坏情况下是 $O(1)$。Insert$(x)$ 为任何新创建的节点分配并初始化一个新数组。删除语义不合并节点；相反，节点保持原样以避免结构更新。**\n\n此选项有两个致命缺陷。\n1.  **插入成本:** 为每个新节点初始化一个大小为 `$|\\Sigma|$` 的新数组需要 `$O(|\\Sigma|)$` 时间。插入一个键 `$x$` 在最坏情况下可能创建多个新节点（多达 `$|x|$` 个）。这导致总插入时间高达 `$O(|x| \\cdot |\\Sigma|)$`，违反了 `$O(|x|)$` 的要求，因为 `$|\\Sigma|$` 不一定是常数。\n2.  **删除不变性:** 删除期间不合并节点违反了压缩 trie 树的不变性。一条路径可能退化成一长串出度为 `$1$` 的节点链，从而破坏了压缩表示的性能优势。后续的 `member(y)` 操作可能需要遍历比必要时多得多的节点，其成本不再主要取决于压缩边的数量。\n\n结论: **不正确**。\n\n**C. 在 member$(x)$ 或 insert$(x)$ 中从一个节点遍历时，为了选择正确的子节点，扫描该节点的所有出边，并选择其标签与 $x$ 未消耗的后缀共享最长公共前缀的那条边。如果没有边共享非空前缀，则创建一个新的子边，用 $x$ 的整个剩余后缀进行标记。将边标签作为实际字符串存储在每条边上，在分裂时根据需要复制字符。**\n\n主要缺陷在于子节点选择方法。\n-   **子节点查找:** “扫描该节点的所有出边”意味着对子节点进行线性扫描。节点的出度可以高达 `$|\\Sigma|$`。这使得每个节点的查找在最坏情况下成为 `$O(|\\Sigma|)$` 操作，而不是 `$O(1)`。因此，操作的总时间复杂度将是 `$O(|x| \\cdot |\\Sigma|)$`，这违反了目标界限。\n\n结论: **不正确**。\n\n**D. 在每个节点维护一个非负整数计数器，其值等于前缀路径中包含此节点并在其处或其下方终止的存储键的数量。在 delete$(x)$ 操作中，遍历搜索路径，递减计数器；每当计数器变为 0 时，立即移除该节点及其关联的入边。如果删除后，父节点变为非终止节点且出度为 1，则通过连接边标签将其与其唯一的子节点合并。子节点选择继续使用标准压缩 trie 树遍历中的常数时间映射查找。**\n\n该选项描述了一种有效但更为复杂的实现。\n-   **子节点查找:** 它明确指出子节点选择使用常数时间映射查找，满足了一个关键要求。\n-   **删除:** 所描述的删除过程是合理的。它包含了必要的合并逻辑：“如果删除后，父节点变为非终止节点且出度为 1，则通过连接边标签将其与其唯一的子节点合并”。这确保了压缩不变性得以维护。计数器机制是一个附加功能，允许在子树变空时剪除整个子树。递减计数器、检查是否为零以及执行合并/剪枝都发生在键 `$x$` 的路径上。每个节点上这些操作的成本是常数（不包括标签连接，其成本如前所述在路径长度上分摊）。因此，整体的 `$O(|x|)$` 复杂度得以保持。该设计是充分且正确的。\n\n结论: **正确**。\n\n**E. 在每个节点处存储从根到该节点的完整前缀字符串（除了边标签），以允许对路径前缀进行常数时间的相等性检查。在任何导致分裂边或合并边的插入或删除操作后，更新每个受影响后代节点存储的完整前缀字符串，以使其与新的从根到节点的路径保持一致。**\n\n这个选项效率极低。\n-   **更新成本:** 当插入操作分裂一条边或删除操作合并 trie 树高层的边时，通往大量后代节点的路径会发生变化。该提议要求为*每个*受影响的后代更新“完整前缀字符串”。这将需要遍历修改点下方的整个子树。该子树的大小与 `$|x|$` 无关，并且可以任意大。因此，此类更新的成本不受 `$O(|x|)$` 的限制，违反了对 `insert` 和 `delete` 的要求时间复杂度。此外，对于标准的字典操作来说，存储完整前缀是多余的。\n\n结论: **不正确**。\n\n总之，选项 A 和 D 都描述了正确且充分的设计选择，可以为所有三个 ADT 操作实现指定的 `$O(|x|)$` 性能。", "answer": "$$\\boxed{AD}$$", "id": "3202637"}]}