{"hands_on_practices": [{"introduction": "让我们从一个基础但非常重要的内存分配策略开始：首次适应（first-fit）算法。在这个练习中，你将实现一个维护按地址排序的空闲链表的分配器。这个练习 [@problem_id:3239179] 的核心不仅在于实现分配（`alloc`）和释放（`free`）的基本逻辑，更在于学习如何根据一个精确的单位成本模型来量化分析其性能，这是评估和比较不同分配策略的关键技能。", "problem": "考虑一个堆内存分配器，其空闲列表按地址严格递增的顺序维护。您将为此分配器实现一个模拟器，并在一个精确定义的单位成本模型下对其性能进行实证分析。所有地址和大小都以整数为单位，堆从地址 $0$ 开始，容量为固定的整数 $C$。空闲列表初始时包含一个覆盖整个堆的块。分配请求和释放请求按顺序处理。\n\n定义和规则：\n- 堆具有 $C \\in \\mathbb{N}$ 个可寻址单元的容量。\n- 一个空闲块是一个对 $(a,s)$，其中起始地址 $a \\in \\mathbb{N}$，大小 $s \\in \\mathbb{N}$，表示半开区间 $[a,a+s)$。\n- 空闲列表是一个按 $a$ 严格递增排序的空闲块序列，不同块之间没有重叠或邻接。\n- 分配请求 alloc$(x)$ (其中 $x \\in \\mathbb{N}$) 使用首次适配策略：按地址顺序扫描空闲列表，找到第一个大小 $s \\ge x$ 的块 $(a,s)$。如果找到，则分配最低地址部分，返回一个已分配的块 $[a,a+x)$，并在 $s > x$ 时将空闲块分裂为 $(a+x, s-x)$，或在 $s = x$ 时将其移除。如果没有合适的块，分配失败。\n- 释放请求 free$(i)$ 将先前为句柄 $i \\in \\mathbb{N}$ 返回的块释放回空闲列表。执行插入操作以使空闲列表保持按起始地址排序，然后当且仅当与前驱和/或后继块完全邻接时，立即进行合并（即，对于前驱块 $(a_{\\text{pred}}, s_{\\text{pred}})$ 满足 $a_{\\text{pred}} + s_{\\text{pred}} = a_{\\text{new}}$，对后继块同理）。\n- 每次成功的分配都会被赋予一个唯一的句柄 $i \\in \\mathbb{N}$，从 $i=1$ 开始，每次成功分配后递增 $1$。后续的 free$(i)$ 指的是这个句柄。不会有请求试图释放一个从未被成功分配的句柄。\n\n单位成本步骤模型：\n- 对于 alloc$(x)$：在从左到右的扫描过程中，每个访问到的空闲块都计为 $1$ 步，包括满足请求的块或在失败情况下的最后一个被检查的块。分裂和更新操作不增加步骤数。\n- 对于 free$(i)$：在搜索插入位置时，每次从一个空闲块移动到下一个计为 $1$ 步。此外，检查与前驱的邻接性（如果存在）计为 $1$ 步，检查与后继的邻接性（如果存在）计为 $1$ 步。实际的合并操作除了这些邻接性检查外，不增加额外的步骤。\n\n外部碎片：\n- 在一个测试用例的所有操作完成后，设 $F$ 为空闲块的集合。定义 $T = \\sum_{(a,s) \\in F} s$ 和 $L = \\max\\{s : (a,s) \\in F\\}$，并约定当 $T=0$ 时外部碎片为 $0$。否则，外部碎片率为 $1 - \\frac{L}{T}$，这是一个在 $[0,1]$ 区间内的实数。\n\n您的任务：\n- 实现一个完整的程序，模拟此分配器，处理指定的测试套件，并报告来自单位成本模型的量化指标。\n\n每个测试用例的所需输出：\n- 每次 alloc$(\\cdot)$ 请求的平均步骤数，涵盖所有分配尝试（包括失败的尝试），以实数形式表示。\n- 每次 free$(\\cdot)$ 请求的平均步骤数，涵盖所有释放操作，以实数形式表示。\n- 最终的空闲块数量，以整数形式表示。\n- 最终的外部碎片率，一个在 $[0,1]$ 区间内的实数。\n\n舍入和最终输出格式：\n- 使用标准的四舍五入将所有实数舍入到恰好 $6$ 位小数，可接受平局舍入到偶数（ties to even），如同典型的浮点格式化。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，所有测试用例的值按顺序连接。例如，如果单个测试产生了 $4$ 个值 $r_1, r_2, r_3, r_4$，并且有多个测试，则最终输出的形式应为 $[r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{2,1}, r_{2,2}, \\dots]$，其中逗号分隔相邻的数字，且没有空格。\n\n测试套件：\n- 测试 $1$ （包含分裂和合并的常规路径）：容量 $C = 64$，按顺序执行操作，使用 alloc$(x)$ 和 free$(i)$ 表示法：\n  - alloc$(8)$、alloc$(8)$、alloc$(8)$、free$(2)$、alloc$(4)$、alloc$(4)$、alloc$(16)$、free$(1)$、free$(3)$、free$(4)$。\n- 测试 $2$ （边界精确匹配）：容量 $C = 32$，操作：\n  - alloc$(32)$、free$(1)$。\n- 测试 $3$ （碎片整形和部分匹配）：容量 $C = 64$，操作：\n  - alloc$(12)$、alloc$(12)$、alloc$(12)$、alloc$(12)$、free$(2)$、free$(4)$、alloc$(10)$、alloc$(10)$、free$(1)$、free$(3)$、alloc$(24)$。\n- 测试 $4$ （首次适配的不利扫描）：容量 $C = 128$，操作：\n  - alloc$(16)$、alloc$(16)$、alloc$(16)$、alloc$(16)$、alloc$(16)$、alloc$(16)$、free$(2)$、free$(4)$、free$(6)$、alloc$(32)$、free$(1)$、free$(3)$、free$(5)$、free$(7)$。\n- 测试 $5$ （使用伪随机数生成器 (PRNG) 的随机工作负载）：容量 $C = 256$。使用种子 $S = 123456$ 和以下规则生成一个包含 $N = 200$ 个操作的序列：\n  - 在每一步，以概率 $p = 0.6$ 选择 alloc，以概率 $1-p$ 选择 free。如果在没有活动句柄时选择了 free，则强制改为 alloc。\n  - 对于 alloc，从 $[1,32]$ 的整数中均匀抽取一个大小 $x$。尝试 alloc$(x)$；如果失败，它仍被计为一次分配尝试并计算其步骤成本，且不创建句柄。\n  - 对于 free，从当前活动的句柄中随机均匀选择一个并释放它。\n  - 仅使用 PRNG 来确定操作类型、分配大小以及要释放的句柄。PRNG 必须使用给定的种子 $S$ 进行初始化，以确保结果是可复现的。\n\n需要实现的内容：\n- 一个模拟器，它按地址顺序维护空闲列表，支持首次适配的 alloc、带立即合并功能的按地址排序插入的 free，根据单位成本模型计算步骤，并计算外部碎片。将其应用于上述测试套件，并按指定的顺序和舍入要求打印最终的扁平结果列表。", "solution": "我们从一个基于比较的单位成本模型中堆分配和列表扫描的核心定义开始。堆是一个由 $C$ 个整数大小的单元组成的连续数组，初始时完全空闲，表现为一个单一的块。一个空闲列表维护着按起始地址递增排序的不相交空闲块。该分配器使用首次适配（first-fit），这是一种基本方法，它依赖于对空闲列表的顺序扫描来找到第一个足够大的块以满足请求。\n\n数据结构设计：\n- 将空闲列表表示为一个由对 $(a,s)$ 组成的序列，按 $a$ 严格排序。这确保了列表中的前驱和后继恰好是空闲块中按地址的直接邻居。\n- 维护一个字典，将每个已分配的句柄 $i$ 映射到其块 $(a,s)$，以支持 free$(i)$。\n\n根据定义得出的分配算法（首次适配）：\n- 为分配一个大小为 $x$ 的请求，从左到右扫描空闲列表，直到遇到第一个满足 $s \\ge x$ 的块 $(a,s)$。如果存在这样的块，则向客户端返回子区间 $[a,a+x)$，并在 $s > x$ 时将空闲块更新为 $(a+x, s-x)$，或在 $s = x$ 时将其完全移除。\n- 如果不存在这样的块，则请求失败。\n- 在单位成本模型下，扫描中访问的每个块都精确计为 $1$ 步，无论请求是否成功，都包括最后访问的那个块。这遵循了顺序搜索的基本成本模型，其中每次节点访问都是一步。\n\n释放算法（按地址排序插入并合并）：\n- 对于 free$(i)$，从句柄中恢复 $(a,s)$ 并将其插回空闲列表中的唯一索引处，以保持地址顺序。由于列表是按 $a$ 排序的，可以通过从左到右的扫描找到插入点。每次前进到下一个列表节点都会在成本模型中贡献 $1$ 步。\n- 插入后，最多检查两个邻接关系以进行合并：\n  - 检查前驱邻接性：如果存在一个前驱 $(a_p,s_p)$ 且 $a_p + s_p = a$，则通过用单个合并后的块替换这两个块，合并为 $(a_p, s_p + s)$。该检查本身计为一步。\n  - 检查后继邻接性：如果存在一个后继 $(a_s,s_s)$ 且 $a + s = a_s$，则类似地合并为 $(a, s + s_s)$。该检查计为一步。如果前驱和后继都邻接，则两次合并都会发生，产生一个单一的组合块。\n- 实际的合并操作除了邻接检查外不产生额外步骤，这反映了在这个基于列表的模型中，比较和指针移动占主导地位的原则。\n\n外部碎片：\n- 完成一个测试用例后，如果 $F \\ne \\emptyset$，则计算 $T = \\sum_{(a,s) \\in F} s$ 和 $L = \\max\\{s : (a,s) \\in F\\}$，并约定当 $T=0$ 时碎片为 $0$。否则，外部碎片率为 $1 - \\frac{L}{T}$，由于 $L \\le T$，该值位于 $[0,1]$ 区间内。\n\n从第一性原理推导复杂度：\n- 设 $k$ 为当前空闲块的数量。在按地址排序的列表上进行顺序扫描以寻找首次适配，在最坏情况下会接触到多达 $k$ 个块，因此根据单位成本模型，最坏情况下的成本是 $\\Theta(k)$ 步。这直接源于顺序搜索的定义：每次访问块都恰好贡献一步，并且最多可以检查所有 $k$ 个块。\n- 对于 free$(i)$，按地址顺序查找插入点同样是在最多 $k$ 个块上进行顺序搜索，因此搜索成本为 $\\Theta(k)$。合并需要最多两次邻接检查（前驱和后继），贡献最多 $2$ 个额外步骤。因此，总的最坏情况释放成本为 $\\Theta(k)$。\n- 按地址排序的列表允许在找到插入点后，通过 $O(1)$ 次额外比较来完成合并，因为邻接性仅需使用直接相邻的块即可确定，这是按 $a$ 全序排列的结果。这消除了在其他地方搜索可能邻接的块的需要。\n\n实证测量计划与正确性：\n- 实现分配器和用于根据指定模型累积步骤数的检测工具：对于 alloc$(\\cdot)$，每个访问的空闲块计一步；对于 free$(\\cdot)$，计算搜索时每次前进的步骤，外加最多两次邻接检查。这些定义被直接应用为实现计数器的基本规则。\n- 对于每个测试用例，维护分配尝试次数、释放次数以及各自的总步骤数的计数器。在每个测试结束时，将平均值计算为有理数 $\\frac{\\text{总步骤数}}{\\text{次数}}$，并四舍五入到 $6$ 位小数。\n- 计算最终的空闲块数量 $|F|$ 和外部碎片率 $1 - \\frac{L}{T}$。\n\n测试套件覆盖范围的基本原理：\n- 测试 $1$ 练习了分裂、释放中间块、后续分配部分填充空洞以及释放相邻已分配块时的合并操作。\n- 测试 $2$ 检查了消耗整个堆的精确匹配以及将其释放回单个块的边界情况。\n- 测试 $3$ 通过部分匹配构造碎片，以测量外部碎片及其对首次适配扫描的影响。\n- 测试 $4$ 创建交替的已分配块和空闲块，以强制对一个较大请求进行长扫描，然后释放以测试完全合并回单个块的情况。\n- 测试 $5$ 使用由带有固定种子的伪随机数生成器 (PRNG) 生成的可复现随机工作负载，涵盖了变化的交错、大小、成功和失败情况，以提供性能的综合视图。\n\n程序精确地实现了这些定义，并按顺序为每个测试输出四个值：每次分配尝试的平均步骤数、每次释放的平均步骤数、最终的空闲块计数以及最终的外部碎片率，所有值都在一个单一的扁平列表中，并且实数四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass AddressOrderedAllocator:\n    def __init__(self, capacity: int):\n        # Free list: list of (start, size), sorted by start address\n        self.free_list = [(0, capacity)] if capacity > 0 else []\n        # Allocated blocks by handle -> (start, size)\n        self.allocated = {}\n        self.next_handle = 1\n\n    def alloc(self, size: int):\n        \"\"\"\n        First-fit allocation from address-ordered free list.\n        Returns (handle or None, steps).\n        Steps: 1 per visited free block.\n        \"\"\"\n        steps = 0\n        if size = 0:\n            return None, steps  # Ignore nonsensical requests; no steps.\n\n        for idx, (start, fsize) in enumerate(self.free_list):\n            steps += 1  # visiting this free block\n            if fsize >= size:\n                handle = self.next_handle\n                self.next_handle += 1\n                # allocate from the start of this block\n                alloc_start = start\n                alloc_size = size\n                self.allocated[handle] = (alloc_start, alloc_size)\n                # adjust free block\n                if fsize == size:\n                    # remove the block\n                    del self.free_list[idx]\n                else:\n                    # shrink the block at the front\n                    self.free_list[idx] = (start + size, fsize - size)\n                return handle, steps\n\n        # No fitting block found\n        return None, steps\n\n    def free(self, handle: int):\n        \"\"\"\n        Free a previously allocated handle.\n        Returns steps.\n        Steps: 1 per move while finding insertion point,\n               +1 for predecessor-adjacency check (if predecessor exists),\n               +1 for successor-adjacency check (if successor exists).\n        \"\"\"\n        steps = 0\n        if handle not in self.allocated:\n            return steps  # no steps per the model (invalid free won't occur in tests)\n\n        start, size = self.allocated.pop(handle)\n\n        # Find insertion index to keep address order\n        i = 0\n        n = len(self.free_list)\n        # Advance while current free block starts before the new block's start\n        while i  n and self.free_list[i][0]  start:\n            steps += 1  # moving to next free block during search\n            i += 1\n\n        # Insert the new free block at index i\n        self.free_list.insert(i, (start, size))\n        # Coalesce with predecessor if adjacent\n        # Check predecessor adjacency if exists\n        if i - 1 >= 0:\n            steps += 1  # predecessor adjacency check\n            pred_start, pred_size = self.free_list[i - 1]\n            cur_start, cur_size = self.free_list[i]\n            if pred_start + pred_size == cur_start:\n                # Merge predecessor and current\n                merged = (pred_start, pred_size + cur_size)\n                # Replace predecessor with merged and remove current\n                self.free_list[i - 1] = merged\n                del self.free_list[i]\n                i = i - 1  # merged block now at i-1\n\n        # Coalesce with successor if adjacent\n        if i + 1  len(self.free_list):\n            steps += 1  # successor adjacency check\n            cur_start, cur_size = self.free_list[i]\n            succ_start, succ_size = self.free_list[i + 1]\n            if cur_start + cur_size == succ_start:\n                merged = (cur_start, cur_size + succ_size)\n                self.free_list[i] = merged\n                del self.free_list[i + 1]\n\n        return steps\n\n    def external_fragmentation(self):\n        if not self.free_list:\n            return 0.0\n        total = sum(sz for _, sz in self.free_list)\n        if total == 0:\n            return 0.0\n        largest = max(sz for _, sz in self.free_list)\n        return 1.0 - (largest / total)\n\ndef run_scripted_test(capacity, ops):\n    \"\"\"\n    ops: list of tuples, ('A', size) or ('F', handle)\n    Allocation handles start at 1 and increment per successful allocation.\n    \"\"\"\n    alloc = AddressOrderedAllocator(capacity)\n    total_malloc_steps = 0\n    total_free_steps = 0\n    count_mallocs = 0\n    count_frees = 0\n\n    for op in ops:\n        if op[0] == 'A':\n            size = int(op[1])\n            handle, steps = alloc.alloc(size)\n            total_malloc_steps += steps\n            count_mallocs += 1\n            # If allocation succeeded, handle is recorded by allocator internally.\n            # Free operations refer to handle numbers as assigned in order,\n            # so scripted frees must match the created handles.\n        elif op[0] == 'F':\n            handle = int(op[1])\n            steps = alloc.free(handle)\n            total_free_steps += steps\n            count_frees += 1\n        else:\n            raise ValueError(\"Unknown operation\")\n\n    avg_malloc = (total_malloc_steps / count_mallocs) if count_mallocs > 0 else 0.0\n    avg_free = (total_free_steps / count_frees) if count_frees > 0 else 0.0\n    free_blocks = len(alloc.free_list)\n    frag = alloc.external_fragmentation()\n    return avg_malloc, avg_free, free_blocks, frag\n\ndef run_random_test(capacity, n_ops, p_alloc, size_low, size_high, seed):\n    \"\"\"\n    Generate operations using a PRNG with given seed.\n    - At each step: alloc with probability p_alloc, else free.\n    - If free but no live handles, force alloc.\n    - For alloc: size uniform integer in [size_low, size_high].\n    - For free: choose a live handle uniformly at random to free.\n    Count steps per the model for both alloc and free.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    alloc = AddressOrderedAllocator(capacity)\n    total_malloc_steps = 0\n    total_free_steps = 0\n    count_mallocs = 0\n    count_frees = 0\n\n    live_handles = []  # list of currently live handles\n\n    for _ in range(n_ops):\n        do_alloc = bool(rng.random()  p_alloc) or (len(live_handles) == 0)\n        if do_alloc:\n            size = int(rng.integers(size_low, size_high + 1))\n            handle, steps = alloc.alloc(size)\n            total_malloc_steps += steps\n            count_mallocs += 1\n            if handle is not None:\n                live_handles.append(handle)\n        else:\n            # Free: choose uniformly one live handle\n            idx = int(rng.integers(0, len(live_handles)))\n            handle = live_handles.pop(idx)\n            steps = alloc.free(handle)\n            total_free_steps += steps\n            count_frees += 1\n\n    avg_malloc = (total_malloc_steps / count_mallocs) if count_mallocs > 0 else 0.0\n    avg_free = (total_free_steps / count_frees) if count_frees > 0 else 0.0\n    free_blocks = len(alloc.free_list)\n    frag = alloc.external_fragmentation()\n    return avg_malloc, avg_free, free_blocks, frag\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: capacity 64, scripted operations\n        (\"scripted\", {\n            \"capacity\": 64,\n            \"ops\": [\n                ('A', 8), ('A', 8), ('A', 8), ('F', 2),\n                ('A', 4), ('A', 4), ('A', 16), ('F', 1),\n                ('F', 3), ('F', 4),\n            ]\n        }),\n        # Test 2: capacity 32, exact fit\n        (\"scripted\", {\n            \"capacity\": 32,\n            \"ops\": [\n                ('A', 32), ('F', 1),\n            ]\n        }),\n        # Test 3: fragmentation shaping\n        (\"scripted\", {\n            \"capacity\": 64,\n            \"ops\": [\n                ('A', 12), ('A', 12), ('A', 12), ('A', 12),\n                ('F', 2), ('F', 4), ('A', 10), ('A', 10),\n                ('F', 1), ('F', 3), ('A', 24),\n            ]\n        }),\n        # Test 4: adverse scan for first-fit\n        (\"scripted\", {\n            \"capacity\": 128,\n            \"ops\": [\n                ('A', 16), ('A', 16), ('A', 16), ('A', 16), ('A', 16), ('A', 16),\n                ('F', 2), ('F', 4), ('F', 6), ('A', 32),\n                ('F', 1), ('F', 3), ('F', 5), ('F', 7),\n            ]\n        }),\n        # Test 5: stochastic workload\n        (\"random\", {\n            \"capacity\": 256,\n            \"n_ops\": 200,\n            \"p_alloc\": 0.6,\n            \"size_low\": 1,\n            \"size_high\": 32,\n            \"seed\": 123456\n        }),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"scripted\":\n            avg_malloc, avg_free, free_blocks, frag = run_scripted_test(\n                params[\"capacity\"], params[\"ops\"]\n            )\n        elif kind == \"random\":\n            avg_malloc, avg_free, free_blocks, frag = run_random_test(\n                params[\"capacity\"], params[\"n_ops\"], params[\"p_alloc\"],\n                params[\"size_low\"], params[\"size_high\"], params[\"seed\"]\n            )\n        else:\n            raise ValueError(\"Unknown test kind\")\n\n        # Round real numbers to 6 decimals as strings; integers as-is\n        results.append(f\"{avg_malloc:.6f}\")\n        results.append(f\"{avg_free:.6f}\")\n        results.append(str(int(free_blocks)))\n        results.append(f\"{frag:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3239179"}, {"introduction": "简单的顺序扫描分配器虽然直观，但在真实场景下可能效率不高。为了提升性能，现代分配器常采用分级适应（segregated-fit）策略，其中伙伴系统（buddy system）是一个经典的实现。这个练习 [@problem_id:3239041] 将引导你构建一个功能更强大的伙伴分配器，它为不同大小的内存块维护独立的空闲链表，并支持高效的块分裂与合并操作，让你体验设计一个更接近实际系统的高效内存管理器。", "problem": "您需要实现一个分离适配（segregated-fit）堆分配器，该分配器为2的幂次大小的对象设有单独的空闲链表。分配器在固定大小的页面上操作，并使用伙伴系统（buddy system）的分裂（splitting）和合并（coalescing）原则。分配器必须支持在模拟堆中分配和释放对象，并按大小类别维护分离的空闲链表。所有大小均以字节为单位，除非明确指明为句柄，否则所有报告的数量必须以字节为单位。\n\n基本和核心定义：\n- 内存被建模为一个离散的地址空间，划分为大小为 $2^{12}$ 字节的页面。每个页面由一个整数页面索引标识，并具有在 $\\{0, 1, 2, \\dots, 2^{12}-1\\}$ 范围内的字节偏移量。\n- 分配器为大小类别 $C = \\{2^4, 2^5, \\dots, 2^{12}\\}$ 字节维护不相交的空闲链表。每个类别 $s \\in C$ 的空闲链表包含大小恰好为 $s$ 字节的空闲块。\n- 请求大小向上取整到最接近的、至少为 $2^4$ 的2的幂次方。也就是说，给定一个请求大小 $n$，分配器计算 $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$ 并确保 $r \\le 2^{12}$。对于 $n \\le 0$ 或 $n  2^{12}$ 的请求必须失败。\n- 分配使用带分裂的分离适配策略：如果存在大小为 $r$ 的空闲块，则分配它。如果没有，则选择存在可用空闲块的最小大小 $S \\in C$（其中 $S \\ge r$）；将其反复对半分裂，直到产生一个大小为 $r$ 的块。具体来说，在偏移量 $o$ 处分裂一个大小为 $S$ 的块会产生两个伙伴块，分别位于偏移量 $o$ 和 $o + S/2$ 处，每个大小为 $S/2$。将未使用的另一半重新插入其对应的空闲链表。\n- 释放使用伙伴合并策略：给定一个大小为 $s$、偏移量为 $o$ 的块，其伙伴位于偏移量 $b = o \\oplus s$（按位异或）。如果其伙伴存在且在同一页面内是空闲的，则将两者从它们的空闲链表中移除，并合并成一个大小为 $2s$、偏移量为 $o' = o \\wedge \\neg s$（与 $s$ 的按位非进行按位与）的块，然后向上重复此过程，直到没有空闲的伙伴或达到页面大小 $2^{12}$ 为止。\n- 句柄：对于在页面索引 $p$ 和偏移量 $o$ 处分配的块，分配器返回一个句柄 $h = p \\cdot 2^{12} + o$。这在模拟堆中唯一标识了该次分配。分配失败返回哨兵值 $-1$。\n- 操作：实现函数 $\\mathrm{alloc}(n)$ 和 $\\mathrm{free}(h)$。函数 $\\mathrm{alloc}(n)$ 返回一个句柄 $h$ 或 $-1$。函数 $\\mathrm{free}(h)$ 返回一个布尔值，表示成功（true）或失败（false），其中失败情况包括无效句柄、双重释放或不存在的页面引用。\n\n科学真实性与约束：\n- 分配器初始时没有页面。它必须在必要时创建新页面（大小为 $2^{12}$ 字节）以满足分配请求。每个新创建的页面都会向最大的空闲链表贡献一个大小为 $2^{12}$ 字节的空闲块。\n- 分配器单次请求分配的内存绝不能超过 $2^{12}$ 字节；没有用于多块连续分配的机制。\n- 必须保持空闲链表的不变性：每个空闲块只属于其大小类别对应的一个空闲链表，并且没有块会出现在多个链表中。\n\n测试套件：\n对于每个测试用例，应用指定的操作并计算所需的输出。所有大小均以字节为单位。必须实现以下测试用例：\n\n- 测试用例 $1$（正常路径，按类别取整）：\n  - 操作：$\\mathrm{alloc}(20)$、$\\mathrm{alloc}(30)$、$\\mathrm{alloc}(100)$、$\\mathrm{alloc}(2000)$。\n  - 输出：一个列表，包含每次请求实际分配的类别大小，即为每次分配所指定的块的大小（以字节为单位）。预期大小遵循向上取整到不小于 $2^4$ 的2的幂次方的规则。\n\n- 测试用例 $2$（分裂并完全合并回一个页面）：\n  - 操作：$\\mathrm{alloc}(1000)$、$\\mathrm{alloc}(1000)$，然后 $\\mathrm{free}$ 第一个句柄，再 $\\mathrm{free}$ 第二个句柄。\n  - 输出：分配器中剩下的大小为 $2^{12}$ 的空闲块的整数数量。如果伙伴合并正确，这应该导致所用页面产生一个大小为 $2^{12}$ 字节的单一空闲块。\n\n- 测试用例 $3$（超出最大类别的分配失败）：\n  - 操作：$\\mathrm{alloc}(5000)$。\n  - 输出：一个布尔值，指示分配是否失败（因为 $5000  2^{12}$，所以失败为 true）。\n\n- 测试用例 $4$（在大量小额分配下创建多页面）：\n  - 操作：执行 $260$ 次 $\\mathrm{alloc}(16)$ 分配。\n  - 输出：分配器创建的页面数的整数值。由于每个大小为 $2^{12}$ 的页面可以分裂成 $2^{12} / 2^4 = 256$ 个 16 字节的块，因此 $260$ 次分配会强制创建 $2$ 个页面。\n\n- 测试用例 $5$（双重释放检测）：\n  - 操作：$h \\leftarrow \\mathrm{alloc}(32)$，然后 $\\mathrm{free}(h)$，再 $\\mathrm{free}(h)$ 一次。\n  - 输出：一个布尔值，指示第二次 $\\mathrm{free}$ 是否失败（失败为 true）。\n\n- 测试用例 $6$（无效句柄释放检测）：\n  - 操作：在一个全新的分配器上执行 $\\mathrm{free}(123456)$。\n  - 输出：一个布尔值，指示 $\\mathrm{free}$ 是否失败（失败为 true）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个条目按顺序对应一个测试用例的结果：$[\\text{result}_1, \\text{result}_2, \\dots, \\text{result}_6]$。如上所述，条目可以是整数、布尔值或整数列表。该行前后不得有任何多余文本。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于内存管理算法的原理，特别是伙伴系统。该问题定义明确，所有必要的常量、算法和边界条件都已清晰界定。它是客观的，并提供了一套可形式化和可验证的测试用例。\n\n任务是实现一个基于伙伴系统的分离适配堆分配器。内存以大小为 $2^{12}$ 字节的页面进行管理。分配请求向上取整到最接近的2的幂次方，范围从最小 $2^4$ 字节到最大 $2^{12}$ 字节。分配器的核心依赖于两个基本操作：分裂较大的块以满足较小的请求，以及合并相邻的空闲“伙伴”块以形成更大的块，从而减轻外部碎片。\n\n将采用基于类的设计来封装分配器的状态和逻辑。\n\n**1. 数据结构**\n\n分配器的状态由三个主要数据结构管理：\n\n- **空闲链表 (`free_lists`)**：分配器使用分离适配策略，这要求为每个大小类别设置单独的空闲块列表。大小类别是2的幂次方，$C = \\{2^4, 2^5, \\dots, 2^{12}\\}$。字典是实现这一点的自然选择，它将每个大小 $s \\in C$ 映射到该大小空闲块的句柄集合。为确保在合并过程中能高效查找伙伴，每个大小类别的句柄集合将是一个集合（set），为插入、删除和成员测试提供平均 $O(1)$ 的时间复杂度。块由其句柄标识，句柄是一个整数，计算方式为 $h = p \\cdot 2^{12} + o$，其中 $p$ 是页面索引，$o$ 是页面内的字节偏移量。\n\n- **已分配块 (`allocated_blocks`)**：需要一个单独的字典来跟踪当前已分配的块。此结构将已分配块的句柄 $h$ 映射到其大小 $s$。这对于 `free(h)` 操作至关重要，该操作需要知道被释放块的大小才能找到其伙伴。此字典也作为验证句柄和检测尝试释放已空闲块（双重释放）的权威记录。\n\n- **页面管理 (`next_page_idx`)**：分配器开始时没有内存页面。页面按需创建。一个简单的整数计数器 `next_page_idx` 跟踪已创建的页面数量，下一个新页面的索引为 `next_page_idx`。当创建新页面时，`next_page_idx` 会递增，一个大小为 $2^{12}$ 的单一空闲块会被添加到相应的空闲链表中。\n\n**2. 算法设计：分配 `alloc(n)`**\n\n分配过程遵循一系列明确定义的步骤：\n\n- **请求验证和大小确定**：对一个 $n$ 字节的传入请求首先进行验证。$n \\le 0$ 或 $n  2^{12}$ 的请求是无效的，会立即失败。对于有效请求，其大小将向上取整到最接近的、至少为 $2^4$ 的2的幂次方 $r$。这通过公式 $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$ 计算。这可以使用 `numpy.log2` 和 `numpy.ceil` 高效实现。\n\n- **块搜索**：分配器在其 `free_lists` 中搜索可用块。它首先检查所需确切大小 $r$ 的空闲链表。如果此列表非空，则从中取出一个块。如果为空，则继续搜索更大的大小类别（$2r, 4r, \\dots, 2^{12}$），直到找到一个非空的空闲链表。\n\n- **页面供给**：如果搜索未能找到任何足够大的空闲块来满足请求（即所有空闲链表都为空，或只包含比 $r$ 小的块），分配器必须供给一个新页面。一个大小为 $2^{12}$ 的新页面被创建，其对应的块句柄（在页面 `next_page_idx`，偏移量 $0$ 处）被添加到大小为 $2^{12}$ 的空闲链表中。然后重新开始寻找可供分裂的块，此时保证能够成功，因为有了这个新的整页块。\n\n- **分裂**：一旦找到一个大小为 $S \\ge r$ 的块并将其从其空闲链表中移除，如果 $S  r$，它将被递归分裂。在偏移量 $o$ 处分裂一个大小为 $S$ 的块会产生两个大小为 $S/2$ 的伙伴块：一个在偏移量 $o$ 处，其伙伴在偏移量 $o + S/2$ 处。伙伴块会立即被添加到大小为 $S/2$ 的空闲链表中。第一个块（在偏移量 $o$ 处）被保留，并重复此过程，将其大小减半，直到获得所需大小 $r$ 的块。然后该块被分配。\n\n- **完成**：最终大小为 $r$ 的块的句柄连同其大小被记录在 `allocated_blocks` 映射中，并将句柄返回给调用者。分配失败则返回 $-1$。\n\n**3. 算法设计：释放 `free(h)`**\n\n释放通过合并来逆转分配过程：\n\n- **句柄验证**：第一步也是最关键的一步是验证句柄 $h$。函数检查 $h$ 是否作为键存在于 `allocated_blocks` 映射中。如果不存在，则句柄无效（它从未被分配，或已被释放）。在这种情况下，操作失败并返回 `false`。\n\n- **伙伴识别与合并**：如果句柄有效，则检索其大小 $s$。该块从 `allocated_blocks` 映射中移除。核心的合并循环开始。对于一个在页面 $p$ 内、偏移量为 $o$、大小为 $s$ 的块，其唯一的相同大小的伙伴位于同一页面内偏移量为 $o \\oplus s$ 的位置。分配器检查伙伴的句柄是否存在于大小为 $s$ 的空闲链表中。\n  - 如果伙伴是空闲的，它将被从其空闲链表中移除。这两个块合并成一个大小为 $2s$ 的单一块。这个新父块的偏移量由 $o' = o \\wedge \\neg s$ 给出，这实际上清除了对应于大小 $s$ 的位，从而得到对齐的 $2s$ 大小块的基地址。然后对这个新的、更大的块重复合并过程。\n  - 如果伙伴不是空闲的（即，它已被分配），则停止合并。\n\n- **完成**：当发现伙伴已被分配或块大小达到页面大小 $2^{12}$ 时，循环终止。最终产生的块（可能是原始块或一个更大的、合并后的块）被添加到适当的空闲链表中。函数返回 `true` 表示成功。这种系统性的合并是伙伴系统通过主动重建更大的空闲块来对抗外部碎片的核心机制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BuddyAllocator:\n    \"\"\"\n    Implements a segregated-fit heap allocator with a buddy system for splitting and coalescing.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the allocator with no pages.\"\"\"\n        self.PAGE_SIZE = 2**12\n        self.MIN_ALLOC_SIZE = 2**4\n        self.MAX_ALLOC_SIZE = self.PAGE_SIZE\n\n        # Size classes are powers of two from MIN_ALLOC_SIZE to MAX_ALLOC_SIZE.\n        self.size_classes = [2**i for i in range(int(np.log2(self.MIN_ALLOC_SIZE)), int(np.log2(self.MAX_ALLOC_SIZE)) + 1)]\n\n        # Free lists: a dictionary mapping size class to a set of handles of free blocks.\n        self.free_lists = {s: set() for s in self.size_classes}\n\n        # Allocated blocks: a dictionary mapping handle to its size.\n        self.allocated_blocks = {}\n\n        # Page management.\n        self.next_page_idx = 0\n\n    def _get_handle(self, page_idx, offset):\n        \"\"\"Computes a handle from a page index and offset.\"\"\"\n        return page_idx * self.PAGE_SIZE + offset\n\n    def _parse_handle(self, handle):\n        \"\"\"Decomposes a handle into its page index and offset.\"\"\"\n        page_idx = handle // self.PAGE_SIZE\n        offset = handle % self.PAGE_SIZE\n        return page_idx, offset\n\n    def _calculate_rounded_size(self, n):\n        \"\"\"Rounds up a request size to the nearest valid power of two.\"\"\"\n        if not (0  n = self.MAX_ALLOC_SIZE):\n            return None\n        \n        req_size = max(n, self.MIN_ALLOC_SIZE)\n        \n        # Use numpy for direct implementation of the formula: 2^ceil(log2(size))\n        power = np.ceil(np.log2(req_size))\n        return 2**int(power)\n\n    def alloc(self, n):\n        \"\"\"Allocates a block of memory of size n.\"\"\"\n        rounded_size = self._calculate_rounded_size(n)\n        if rounded_size is None:\n            return -1\n\n        target_size = rounded_size\n        \n        # Find the smallest available block size that fits the request.\n        alloc_size = -1\n        for s in self.size_classes:\n            if s >= target_size and len(self.free_lists[s]) > 0:\n                alloc_size = s\n                break\n        \n        # If no block is available, create a new page.\n        if alloc_size == -1:\n            page_idx = self.next_page_idx\n            self.next_page_idx += 1\n            \n            new_block_handle = self._get_handle(page_idx, 0)\n            self.free_lists[self.MAX_ALLOC_SIZE].add(new_block_handle)\n            alloc_size = self.MAX_ALLOC_SIZE\n        \n        # Get a block from the selected free list.\n        block_handle = self.free_lists[alloc_size].pop()\n        current_page, current_offset = self._parse_handle(block_handle)\n        \n        # Split the block down to the required size.\n        current_size = alloc_size\n        while current_size > target_size:\n            current_size //= 2\n            buddy_offset = current_offset + current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            self.free_lists[current_size].add(buddy_handle)\n            \n        # Allocate the final block.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.allocated_blocks[final_handle] = target_size\n        return final_handle\n\n    def free(self, handle):\n        \"\"\"Frees a previously allocated block of memory.\"\"\"\n        # 1. Validate handle against the map of allocated blocks.\n        if handle not in self.allocated_blocks:\n            return False\n            \n        page_idx, offset = self._parse_handle(handle)\n        if page_idx >= self.next_page_idx:\n            return False\n\n        # 2. Retrieve size and remove from allocated map.\n        size = self.allocated_blocks.pop(handle)\n        \n        current_page = page_idx\n        current_offset = offset\n        current_size = size\n\n        # 3. Coalesce with buddy if buddy is free.\n        while current_size  self.MAX_ALLOC_SIZE:\n            buddy_offset = current_offset ^ current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            \n            if buddy_handle in self.free_lists[current_size]:\n                self.free_lists[current_size].remove(buddy_handle)\n                current_offset = current_offset  (~current_size)\n                current_size *= 2\n            else:\n                break\n        \n        # 4. Add the final (possibly coalesced) block to the free list.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.free_lists[current_size].add(final_handle)\n        \n        return True\n\ndef run_test_case_1():\n    allocator = BuddyAllocator()\n    requests = [20, 30, 100, 2000]\n    allocated_sizes = []\n    for req in requests:\n        handle = allocator.alloc(req)\n        if handle != -1:\n            allocated_sizes.append(allocator.allocated_blocks[handle])\n    return allocated_sizes\n\ndef run_test_case_2():\n    allocator = BuddyAllocator()\n    h1 = allocator.alloc(1000)\n    h2 = allocator.alloc(1000)\n    allocator.free(h1)\n    allocator.free(h2)\n    return len(allocator.free_lists[allocator.MAX_ALLOC_SIZE])\n\ndef run_test_case_3():\n    allocator = BuddyAllocator()\n    handle = allocator.alloc(5000)\n    return handle == -1\n\ndef run_test_case_4():\n    allocator = BuddyAllocator()\n    for _ in range(260):\n        allocator.alloc(16)\n    return allocator.next_page_idx\n\ndef run_test_case_5():\n    allocator = BuddyAllocator()\n    h = allocator.alloc(32)\n    allocator.free(h)\n    second_free_success = allocator.free(h)\n    return not second_free_success\n\ndef run_test_case_6():\n    allocator = BuddyAllocator()\n    free_success = allocator.free(123456)\n    return not free_success\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        run_test_case_1,\n        run_test_case_2,\n        run_test_case_3,\n        run_test_case_4,\n        run_test_case_5,\n        run_test_case_6,\n    ]\n\n    results = [test() for test in test_cases]\n\n    # The problem asks for the standard string representation of Python objects.\n    # str([1, 2]) -> '[1, 2]' (with space)\n    # str(True) -> 'True' (capitalized)\n    # The default behavior of map(str,...) is the most faithful interpretation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3239041"}, {"introduction": "在掌握了分配器的实现细节之后，让我们通过一个思想实验来挑战你对内存分配核心原理的理解。这个练习 [@problem_id:3239183] 提出了一个看似简单却引人深思的问题：如何以最少的操作次数在堆上创建一个特定的内存布局？解答这个问题将迫使你跳出具体实现的框架，从更抽象的层面思考 `malloc` 和 `free` 操作的本质能力，特别是 `malloc` 如何通过分割空闲块来创造新的空闲空间。", "problem": "考虑一个理想化的动态内存分配器，它在一个大小为 $H = 2^{20}$ 字节（一兆字节，mebibyte）的线性堆上运行。该分配器提供两个操作：$\\mathtt{malloc}(s)$ 和 $\\mathtt{free}(p)$，其语义如下。\n\n1. 操作 $\\mathtt{malloc}(s)$ 返回一个指向先前空闲的、大小恰好为 $s$ 字节的连续块的指针。分配器将其元数据保存在一个独立的结构中，不占用 $H$ 字节的堆空间，并且其对齐粒度为 $a = 1$ 字节，因此对 $s = 1$ 字节的请求会被精确地放置为单字节块。分配操作可以为了满足请求而分割一个空闲块，但不能创建重叠的已分配块。\n\n2. 操作 $\\mathtt{free}(p)$ 释放先前由 $\\mathtt{malloc}$ 在地址 $p$ 返回的整个块。不允许部分释放块。当一个块被释放时，相邻的空闲块可能会合并，但在 $\\mathtt{free}$ 期间不会发生分配。\n\n最初，整个堆都是空闲的。您希望达到一种最终配置，在该配置中，整个 $H$ 字节的堆被划分为交替的 1 字节已分配块和 1 字节空闲块，从第一个字节为已分配块开始。换句话说，使用从零开始的字节索引，整个堆中已分配的字节集合为 $\\{0, 2, 4, \\dots\\}$，空闲的字节集合为 $\\{1, 3, 5, \\dots\\}$。\n\n在这些规则和初始条件下，要达到所述的交替配置，所需的最少总调用次数（包括 $\\mathtt{malloc}$ 和 $\\mathtt{free}$）是多少？请用一个精确的整数表示您的最终答案。无需四舍五入，最终答案中不应包含任何单位。", "solution": "在尝试给出解决方案之前，将根据指定标准对问题进行验证。\n\n### 第 1 步：提取已知条件\n-   堆大小：$H = 2^{20}$ 字节。\n-   操作 1：$\\mathtt{malloc}(s)$ 从一个空闲区域分配一个大小为 $s$ 字节的连续块。\n-   操作 2：$\\mathtt{free}(p)$ 释放地址 $p$ 处的整个块。\n-   分配器元数据单独存储，不消耗堆空间。\n-   对齐粒度：$a=1$ 字节。\n-   不允许部分释放块。\n-   分配操作可以分割一个空闲块。\n-   在 $\\mathtt{free}$ 操作时，相邻的空闲块可能会合并。\n-   初始状态：整个堆，从地址 $0$ 到 $H-1$，是一个单一的空闲块。\n-   目标状态：堆被划分为交替的 1 字节已分配块和 1 字节空闲块。已分配字节的地址集合是 $\\{0, 2, 4, \\dots, H-2\\}$，空闲字节的地址集合是 $\\{1, 3, 5, \\dots, H-1\\}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题在计算机科学领域，特别是在涉及内存管理的数据结构和算法方面，具有科学依据。它提出了一个理想化但逻辑上一致的模型。问题定义明确，有清晰的初始状态、目标状态和一组允许的操作。问题要求的是一个最小值，这是一个标准的优化问题。语言客观而精确。值 $H=2^{20}$ 是一个偶数，因此堆可以如所述完美地划分为 $H/2$ 个已分配块和 $H/2$ 个空闲块。问题是自洽的，不违反任何逻辑或科学原则。它并非无足轻重，需要一个最优性的构造性证明。\n\n### 第 3 步：结论与行动\n问题被认为是有效的。将提供一个合理的解决方案。\n\n### 解决方案\n目标是使用最少总次数的 $\\mathtt{malloc}(s)$ 和 $\\mathtt{free}(p)$ 调用来达到一个特定的最终内存配置。最终配置包括位于所有偶数地址的 $H/2$ 个大小为 1 字节的已分配块，以及位于所有奇数地址的 $H/2$ 个大小为 1 字节的空闲块。\n\n设 $N_{alloc}$ 为目标状态下已分配块的数量，$N_{free}$ 为空闲块的数量。根据在大小为 $H$ 的堆中 1 字节块的交替模式，我们有：\n$$N_{alloc} = \\frac{H}{2}$$\n$$N_{free} = \\frac{H}{2}$$\n在本例中，$H = 2^{20}$，所以 $N_{alloc} = N_{free} = \\frac{2^{20}}{2} = 2^{19}$。\n\n让我们确定总操作次数的下界。\n最终状态包含 $N_{alloc} = H/2 = 2^{19}$ 个独立的、不连续的已分配块。每次调用 $\\mathtt{malloc}(s)$ 返回一个指向单个连续内存块的指针。因此，要创建 $N_{alloc}$ 个独立的已分配块，我们必须至少调用 $N_{alloc}$ 次 $\\mathtt{malloc}$。$\\mathtt{free}$ 操作不会创建已分配块。设 $M$ 为 $\\mathtt{malloc}$ 的调用次数，$F$ 为 $\\mathtt{free}$ 的调用次数。\n最终存在的已分配块的数量最多为 $M$。因此，我们必须有 $M \\ge N_{alloc} = H/2$。\n总调用次数为 $M+F$。因此，可能的最小总调用次数的下界是 $H/2$：\n$$ \\text{Total Calls} = M + F \\ge M \\ge \\frac{H}{2} $$\n现在，我们必须确定是否可能用恰好 $H/2$ 次总调用来达到目标配置。这将要求 $F=0$ 且 $M=H/2$。我们需要展示一个由 $H/2$ 次 $\\mathtt{malloc}$ 调用组成的序列，该序列能产生期望的最终状态。\n\n考虑以下由 $H/2$ 个操作组成的序列，所有操作都是 $\\mathtt{malloc}(1)$ 调用。\n堆的初始状态是一个大小为 $H$ 的单一空闲块，我们可以将其表示为 $F(0, H)$。\n\n1.  **第 1 次调用：** $\\mathtt{malloc}(1)$。我们请求在地址 $0$ 处满足此分配。这是可能的，因为地址 $0$ 是空闲块 $F(0, H)$ 的一部分。该操作会分割初始块。\n    -   创建一个已分配块 $A(0, 1)$。\n    -   原始空闲块的剩余部分是 $F(1, H-1)$。\n    -   堆状态为：$[A(0,1) | F(1, H-1)]$。\n\n2.  **第 2 次调用：** $\\mathtt{malloc}(1)$。我们请求在地址 $2$ 处进行此分配。地址 $2$ 位于空闲块 $F(1, H-1)$ 内。“分配可以分割一个空闲块”这条规则允许这样做。分配器从 $F(1, H-1)$ 的中间划分出块 $A(2, 1)$。\n    -   创建一个已分配块 $A(2, 1)$。\n    -   空闲块 $F(1, H-1)$ 被分割成两个更小的、不相邻的空闲块：$F(1, 1)$ 和 $F(3, H-3)$。\n    -   堆状态为：$[A(0,1) | F(1,1) | A(2,1) | F(3, H-3)]$。\n\n这个过程可以继续下去。对于第 $k$ 次调用（其中 $k=1, \\dots, H/2$），我们在地址 $2(k-1)$ 处执行一次 $\\mathtt{malloc}(1)$。在第 $k$ 次调用之前，堆的末尾包含一个大的空闲块，形式为 $F(2k-3, H-(2k-3))$。对 $A(2k-2, 1)$ 的第 $k$ 次分配请求从此块中得到满足，将其分割为 $F(2k-3, 1)$ 和 $F(2k-1, H-(2k-1))$。\n\n让我们追踪到最后一次调用时的状态。\n在 $k = H/2 - 1$ 次调用后，我们在地址 $0, 2, \\dots, H-4$ 处有了已分配块。这已经创建了所需的、位于地址 $1, 3, \\dots, H-5$ 的空闲块。堆的状态是：\n$[A(0,1) | F(1,1) | \\dots | A(H-4,1) | F(H-3, 3)]$。\n最后一个剩下的大空闲块是 $F(H-3, 3)$，覆盖地址 $H-3, H-2, H-1$。\n\n**第 $(H/2)$ 次调用：** $\\mathtt{malloc}(1)$。我们请求在地址 $H-2$ 处进行此分配。该地址位于空闲块 $F(H-3, 3)$ 内。\n-   创建一个已分配块 $A(H-2, 1)$。\n-   空闲块 $F(H-3, 3)$ 被分割，留下两个 1 字节的空闲块：$F(H-3, 1)$ 和 $F(H-1, 1)$。\n\n在这 $H/2$ 次调用之后，堆的配置如下：\n-   已分配块：$A(0,1), A(2,1), \\dots, A(H-2,1)$。这是位于所有偶数地址的 $H/2$ 个已分配块的集合。\n-   空闲块：$F(1,1), F(3,1), \\dots, F(H-1,1)$。这是位于所有奇数地址的 $H/2$ 个空闲块的集合。\n\n这个配置正是目标状态。我们通过一个包含 $H/2$ 次 `malloc` 调用和零次 `free` 调用的序列成功地达到了这个状态。总调用次数为 $H/2$。\n\n由于总调用次数必须至少为 $H/2$，并且我们找到了一个包含 $H/2$ 次调用的有效序列来达到该结果，因此最小调用次数恰好为 $H/2$。\n\n给定堆大小为 $H = 2^{20}$。最小调用次数为：\n$$ \\frac{H}{2} = \\frac{2^{20}}{2} = 2^{19} $$\n计算此值：\n$$ 2^{19} = 524288 $$\n这就是所需的最少总调用次数。", "answer": "$$\\boxed{524288}$$", "id": "3239183"}]}