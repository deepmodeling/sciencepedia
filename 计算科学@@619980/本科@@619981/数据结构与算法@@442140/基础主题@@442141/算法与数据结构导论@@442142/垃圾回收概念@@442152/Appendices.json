{"hands_on_practices": [{"introduction": "引用计数是自动内存管理中一种直观的策略，但其著名缺陷在于无法回收循环引用的对象。本练习将引导你直面这一挑战，通过实现一种基于“试探性删除”思想的算法来识别和回收孤立的对象环 [@problem_id:3236414]。通过这个实践，你将把图论中的可达性分析应用于解决一个真实的系统问题，从而深入理解垃圾回收中的一个经典难题。", "problem": "给定自动内存管理中引用计数的概念框架，以及仅使用引用计数收集循环垃圾时面临的挑战。从以下基础出发：堆对象图被建模为一个有向图 $G = (V, E)$，其中 $|V| = n$，每个顶点 $v \\in V$ 是一个对象，每条有向边 $(u,v) \\in E$ 是从对象 $u$到对象 $v$ 的一个引用。一个对象 $v$ 的引用计数 $rc(v)$ 等于所有对象指向 $v$ 的引用总数，加上来自堆外部（例如，来自栈或寄存器等根）的引用数，这些外部引用被建模为一个外部引用向量 $ext: V \\to \\mathbb{N}$。一个候选对象集 $S \\subseteq V$ 由修改器（mutator）提供，作为可能参与循环的“可疑”对象。\n\n仅使用这些基本概念，推导限制于 $S$ 的试探性删除（trial deletion）的语义：它必须能保守地精确检测出 $S$ 中那些从 $S$ 外部不可达的对象。形式上，令 $ext\\_in(v)$ 表示从 $S$ 外部指向 $v$ 的引用数，由 $ext\\_in(v) = ext(v) + |\\{(u,v) \\in E \\mid u \\notin S\\}|$ 给出。定义基础集 $B = \\{ v \\in S \\mid ext\\_in(v) > 0 \\}$ 和存活集 $R \\subseteq S$，其中 $R$ 是 $S$ 中所有可以从 $B$ 出发、仅通过 $S$ 内部的边到达的顶点。可回收垃圾集为 $G_S = S \\setminus R$。您的程序必须以算法方式实现这些语义，并且其行为必须像一个在有限候选集 $S$ 上使用试探性删除的引用计数系统中的循环检测器。\n\n输入格式和执行模型：没有运行时输入。相反，您的程序必须硬编码一小组测试用例。每个测试用例是一个四元组 $(n, E, ext, S)$，其中 $n$ 是对象的数量，标记为从 $0$ 到 $n-1$ 的整数，$E$ 是有序对 $(u,v)$ 的列表，$ext$ 是一个长度为 $n$ 的列表，给出每个 $i \\in \\{0,\\dots,n-1\\}$ 的 $ext(i)$，$S$ 是候选整数的列表。对于每个测试用例，计算 $G_S$ 中对象标识符的排序列表。\n\n测试套件：\n- 测试用例 1：$n = 5$, $E = [(0,1),(1,2),(2,0),(2,3)]$, $ext = [0,0,0,1,0]$, $S = [0,1,2]$。\n- 测试用例 2：$n = 3$, $E = [(0,1)]$, $ext = [0,0,0]$, $S = []$。\n- 测试用例 3：$n = 3$, $E = [(0,1),(1,2)]$, $ext = [1,0,0]$, $S = [0,1,2]$。\n- 测试用例 4：$n = 3$, $E = [(0,1),(1,2),(2,0)]$, $ext = [0,0,0]$, $S = [0,1]$。\n- 测试用例 5：$n = 1$, $E = [(0,0)]$, $ext = [0]$, $S = [0]$。\n- 测试用例 6：$n = 6$, $E = [(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)]$, $ext = [0,1,0,0,0,0]$, $S = [0,1,2,3,4,5]$。\n\n要求：\n- 根据上述基本概念的定义，推导并实现一个正确且高效的算法，该算法与限制在 $S$ 上的试探性删除语义一致。您的程序不得依赖任何外部输入。\n- 对于每个测试用例，输出将通过在 $S$ 上进行试探性删除而回收的对象标识符的排序列表。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，且不含任何空格。每个元素是对应单个测试用例的排序列表。例如，最终输出应类似于 $[[\\dots],[\\dots],\\dots]$。\n\n答案规格：\n- 对于每个测试用例，答案是一个整数列表（可能为空）。\n- 单行输出必须按以上顺序汇总所有测试用例的列表，并且该行中不得包含任何空白字符。", "solution": "已根据指定标准对用户提供的问题陈述进行了分析和验证。\n\n### 第 1 步：提取已知信息\n\n-   **堆模型**：一个有向图 $G = (V, E)$，包含 $|V| = n$ 个顶点（对象）和一组有向边 $E$（引用）。\n-   **对象标识符**：从 $0$ 到 $n-1$ 的整数。\n-   **外部引用**：一个向量 $ext: V \\to \\mathbb{N}$，其中 $ext(v)$ 是从堆外部指向对象 $v$ 的引用数量。\n-   **候选集**：对象的一个子集 $S \\subseteq V$，被怀疑是垃圾循环的一部分。\n-   **指向 S 的外部入引用**：对于对象 $v \\in S$，从 $S$ 外部指向它的引用数量定义为 $ext\\_in(v) = ext(v) + |\\{(u,v) \\in E \\mid u \\notin S\\}|$。\n-   **基础集**：$B = \\{ v \\in S \\mid ext\\_in(v) > 0 \\}$。这些是 $S$ 中可从 $S$ 外部直接到达的对象。\n-   **存活集**：$R \\subseteq S$，定义为 $S$ 中所有可以从基础集 $B$ 出发，沿完全由 $S$ 内部的边组成的路径到达的顶点的集合。\n-   **可回收垃圾集**：$G_S = S \\setminus R$。\n-   **任务**：对于给定的一组测试用例，计算 $G_S$ 中对象标识符的排序列表。\n-   **测试套件**：\n    1.  测试用例 1：$n = 5$, $E = [(0,1),(1,2),(2,0),(2,3)]$, $ext = [0,0,0,1,0]$, $S = [0,1,2]$。\n    2.  测试用例 2：$n = 3$, $E = [(0,1)]$, $ext = [0,0,0]$, $S = []$。\n    3.  测试用例 3：$n = 3$, $E = [(0,1),(1,2)]$, $ext = [1,0,0]$, $S = [0,1,2]$。\n    4.  测试用例 4：$n = 3$, $E = [(0,1),(1,2),(2,0)]$, $ext = [0,0,0]$, $S = [0,1]$。\n    5.  测试用例 5：$n = 1$, $E = [(0,0)]$, $ext = [0]$, $S = [0]$。\n    6.  测试用例 6：$n = 6$, $E = [(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)]$, $ext = [0,1,0,0,0,0]$, $S = [0,1,2,3,4,5]$。\n-   **输出格式**：一个单行字符串 `[[...],[...],...]`，表示所有测试用例的结果列表，不含空格。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估：\n\n-   **科学基础**：该问题在计算机科学领域，特别是在涉及自动内存管理（垃圾回收）的数据结构和算法领域，具有坚实的理论基础。基于图的对象堆模型、引用计数的概念以及循环垃圾问题都是该领域的基本主题。“试探性删除”的语义被严格定义，并代表了一种有效的循环检测方法。该问题与*垃圾回收概念*这一主题直接相关。\n-   **适定性**：该问题在数学上是适定的。所有术语（$G, E, S, ext, ext\\_in, B, R, G_S$）都得到了明确无误的定义。目标——计算 $G_S$——是清晰的。该过程涉及标准的图算法（可达性），对此存在唯一且稳定的解。每个测试用例都提供了所有必要的数据。\n-   **客观性**：问题陈述使用了精确、形式化和客观的语言，没有任何主观性或模糊性。\n\n该问题不存在所列出的任何缺陷（科学上不健全、不可形式化、设置不完整、不切实际、不适定、伪深刻、外部不可验证）。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效的**。将推导并实现一个解决方案。\n\n### 算法推导\n\n任务是为每个测试用例计算可回收垃圾集 $G_S = S \\setminus R$。该算法直接实现了所提供的形式化定义。该过程可分解为三个主要的计算步骤。\n\n1.  **计算基础集 $B$**：基础集 $B$ 由候选集 $S$ 中所有可从 $S$ 外部到达的对象组成。如果一个对象具有非零的外部引用计数（$ext(v) > 0$），或者至少有一个来自 $S$ 外部对象的引用指向它，则该对象可从 $S$ 外部到达。这对应于条件 $ext\\_in(v) > 0$。\n\n    要计算 $B$，我们必须首先为每个 $v \\in S$ 计算 $ext\\_in(v)$。算法过程如下：\n    - 对于每个对象 $v \\in S$，使用外部引用向量中的值 $ext(v)$ 初始化 $ext\\_in(v)$ 的计数器。\n    - 遍历所有边 $(u, w) \\in E$。如果源 $u$ 不在 $S$ 中（$u \\notin S$）且目标 $w$ 在 $S$ 中（$w \\in S$），则增加 $ext\\_in(w)$ 的计数器。\n    - 在评估完所有边之后，通过收集所有 $v \\in S$ 中最终计算出的 $ext\\_in(v)$ 大于 $0$ 的对象来构成基础集 $B$。\n\n2.  **计算存活集 $R$**：存活集 $R$ 包含 $S$ 中所有可从基础集 $B$ 出发、使用完全位于 $S$ 内部的路径到达的对象。这是一个在由 $S$ 诱导的子图上的经典图可达性问题。该子图的节点是 $S$ 中的对象，其边是所有 $(u, v) \\in E$ 且 $u$ 和 $v$ 都在 $S$ 中的边。\n\n    从一组起始节点（$B$）查找所有可达节点的有效算法是广度优先搜索（BFS）。算法过程如下：\n    - 将存活集 $R$ 初始化为基础集 $B$ 的一个副本。\n    - 用 $B$ 的所有元素初始化一个用于遍历的队列。\n    - 当队列不为空时：\n        - 从队列中取出一个对象 $u$。\n        - 对于 $u$ 引用的每个对象 $v$（即，对于每条边 $(u, v) \\in E$）：\n            - 如果 $v$ 在候选集 $S$ 中且尚未被添加到存活集 $R$ 中，则将 $v$ 添加到 $R$ 并将其入队。\n    - BFS 终止时，集合 $R$ 精确地包含了 $S$ 中所有可从 $B$ 通过 $S$ 内部路径到达的对象。\n\n3.  **计算可回收垃圾集 $G_S$**：问题将可回收垃圾集定义为 $G_S = S \\setminus R$。这是指在候选集 $S$ 中但不在存活集 $R$ 中的对象集合。这些是 $S$ 中无法从任何外部来源（无论是直接还是通过其他存活对象的路径间接）到达的对象。\n\n    这最后一步是一个简单的集合差集运算。根据问题规范的要求，将得到的对象标识符集合按升序排序。\n\n这个三步过程正确且高效地实现了在候选集 $S$ 上进行试探性删除的指定语义。实现将把此逻辑应用于每个提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cyclic garbage collection problem based on trial deletion\n    semantics for a predefined suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: A simple cycle [0,1,2] that is garbage.\n        {\n            \"n\": 5,\n            \"E\": [(0, 1), (1, 2), (2, 0), (2, 3)],\n            \"ext\": [0, 0, 0, 1, 0],\n            \"S\": [0, 1, 2]\n        },\n        # Test case 2: Empty candidate set.\n        {\n            \"n\": 3,\n            \"E\": [(0, 1)],\n            \"ext\": [0, 0, 0],\n            \"S\": []\n        },\n        # Test case 3: A chain kept alive by an external reference.\n        {\n            \"n\": 3,\n            \"E\": [(0, 1), (1, 2)],\n            \"ext\": [1, 0, 0],\n            \"S\": [0, 1, 2]\n        },\n        # Test case 4: A cycle where S is a subset of the cycle, and an\n        #              external reference (from node 2) saves the S-subset.\n        {\n            \"n\": 3,\n            \"E\": [(0, 1), (1, 2), (2, 0)],\n            \"ext\": [0, 0, 0],\n            \"S\": [0, 1]\n        },\n        # Test case 5: A single-node cycle with no external refs.\n        {\n            \"n\": 1,\n            \"E\": [(0, 0)],\n            \"ext\": [0],\n            \"S\": [0]\n        },\n        # Test case 6: Two disjoint cycles. One is saved by an ext ref, one is not.\n        {\n            \"n\": 6,\n            \"E\": [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)],\n            \"ext\": [0, 1, 0, 0, 0, 0],\n            \"S\": [0, 1, 2, 3, 4, 5]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n, E, ext, S = case[\"n\"], case[\"E\"], case[\"ext\"], case[\"S\"]\n        \n        # For efficient lookups, convert S to a set.\n        S_set = set(S)\n        if not S_set:\n            results.append([])\n            continue\n\n        # Step 1: Compute the Base Set B\n        # B = { v in S | ext_in(v) > 0 }\n        # where ext_in(v) = ext(v) + |{(u,v) in E | u not in S}|\n        \n        ext_in = {v: ext[v] for v in S_set}\n        \n        # To find references from outside S, we can build a predecessor graph\n        # or iterate through all edges. Iterating through edges is straightforward.\n        for u, v in E:\n            if v in S_set and u not in S_set:\n                ext_in[v] += 1\n        \n        B = {v for v, count in ext_in.items() if count > 0}\n        \n        # Step 2: Compute the Survivor Set R\n        # R is the set of all vertices in S reachable from B using only edges within S.\n        # This is a graph traversal (BFS) starting from all nodes in B.\n        \n        adj = {i: [] for i in range(n)}\n        for u, v in E:\n            adj[u].append(v)\n            \n        R = set(B)\n        queue = list(B)\n        head = 0\n        \n        while head  len(queue):\n            u = queue[head]\n            head += 1\n            \n            for v in adj[u]:\n                # Traversal is restricted to paths within S\n                if v in S_set and v not in R:\n                    R.add(v)\n                    queue.append(v)\n\n        # Step 3: Compute the Recyclable Garbage Set G_S = S \\ R\n        G_S = S_set - R\n        \n        # Sort the results as required by the problem statement.\n        sorted_garbage = sorted(list(G_S))\n        results.append(sorted_garbage)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists, with no whitespace.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```", "id": "3236414"}, {"introduction": "现代垃圾回收器大多基于“分代假说”——即大多数对象“朝生暮死”——来优化性能。本练习将通过一个模拟实验，让你亲手构建一个违反该假说的对象分配模式，并观察其如何导致垃圾回收效率下降 [@problem_id:3236439]。这个实践不仅让你实现一个简化的分代回收器，更重要的是让你理解算法效率与其底层假设及工作负载之间的深刻联系。", "problem": "你必须编写一个完整、可运行的程序，来模拟一个简化的两代垃圾回收器 (GC)，并评估一种有意违反弱分代假说的具体分配模式。弱分代假说断言，大多数对象都是“朝生夕死”的；而违反该假说的模式则会产生许多中等生命周期的对象，这些对象存活时间足够长，可以在经历数次次要回收后被提升，然后在进入老年代后不久就死亡，从而导致低效的提升操作和代价高昂的主要回收。\n\n从以下基础概念开始：\n- 垃圾回收器 (GC) 术语与核心定义：\n  - 分代 GC 将堆对象划分为不相交的几代。新生代被频繁回收（次要回收），老年代则较少被回收（主要回收）。\n  - 当一个对象在经历指定次数的次要回收后仍然存活时，就会发生提升。\n  - 一次回收会扫描一组对象，以识别哪些是死的（不可达的）并回收它们。\n- 弱分代假说是指大多数对象“朝生夕死”的经验性观察。\n- 标记-清除回收会扫描并移除死对象，而不移动存活对象；在本问题中，对象是抽象的，其可达性通过一个生命周期计数器来确定性地建模，而不是通过图遍历。\n\n需要实现的模型：\n- 堆模型：\n  - 两代：新生代和老年代。\n  - 容量：新生代容量 $C_y$ 和老年代容量 $C_o$，以对象数量计算。\n- 对象模型：\n  - 每个对象拥有：\n    - 剩余生命周期 $L \\in \\mathbb{Z}_{\\ge 0}$，以时间步为单位。当 $L \\le 0$ 时，对象被视为死亡。\n    - 次要回收存活年龄 $a \\in \\mathbb{Z}_{\\ge 0}$，即它在新生代中存活所经历的次要回收次数。\n    - 一个分代标签，新生代或老年代。\n- 分配模式：\n  - 在每个离散时间步 $t \\in \\{1,2,\\dots,T\\}$，恰好有 $A$ 个新对象被分配到新生代。\n  - 在一个测试用例中分配的第 $i$ 个对象会获得一个确定性的生命周期，该生命周期通过在整数区间 $[L_{\\min}, L_{\\max}]$（含两端）上循环取值来指定：整个运行过程中的第 $k$ 次分配被赋予\n    $$L = L_{\\min} + \\left((k - 1) \\bmod (L_{\\max} - L_{\\min} + 1)\\right).$$\n  - 这种循环消除了随机性，使模拟过程具有确定性。\n- 每个时间步中的时间和 GC 事件（严格顺序）：\n  1. 如上所述，分配 $A$ 个新的新生代对象。\n  2. 当新生代对象数量超过 $C_y$ 时，循环运行次要回收：\n     - 扫描当前所有新生代对象（计入成本，见下文）。\n     - 移除死亡的新生代对象（即 $L \\le 0$ 的对象）。\n     - 对每个存活的新生代对象，将其次要回收存活年龄增加 $a \\leftarrow a + 1$。\n     - 如果 $a \\ge p$（提升阈值），将该对象提升到老年代，并重置其年龄记录（提升后你可以丢弃 $a$）。\n     - 统计每一次提升。\n  3. 对两代中的每个对象，将其生命周期递减 $L \\leftarrow L - 1$（这模拟了一个时间步的流逝）。\n  4. 当老年代对象数量超过 $C_o$ 时，循环运行主要回收：\n     - 扫描两代中的所有对象（计入成本，见下文）。\n     - 移除死亡的老年代对象（即 $L \\le 0$ 的对象）。\n     - 在此模型中，新生代对象不会在主要回收中被提升。\n- 成本模型：\n  - 分配标量成本以近似计算工作量：\n    - 次要回收成本是 $\\alpha$ 乘以回收开始时扫描的新生代对象数量。\n    - 主要回收成本是 $\\beta$ 乘以回收开始时扫描的两代总对象数量。\n    - 提升成本是每个被提升对象 $\\gamma$。\n  - 总 GC 成本是整个运行过程中所有扫描成本和提升成本的总和。\n- 低效率指数：\n  - 将低效率指数定义为\n    $$I = \\frac{\\text{总 GC 成本}}{\\text{总分配次数}} = \\frac{\\text{总 GC 成本}}{T \\cdot A}.$$\n\n违反弱分代假说的具体模式：\n- 选择合适的生命周期，使得大多数对象存活的时间恰好足够经历多次次要回收而被提升（通过达到或超过提升阈值 $p$），但随后很快在老年代中死亡。这导致了频繁的提升和代价高昂的主要回收，因为许多被提升的对象并没有长期存活。\n- 次要回收的频率由负载决定；如果新生代大约在 $s = \\left\\lceil \\frac{C_y}{A} \\right\\rceil$ 步后填满，那么将生命周期设置在 $p \\cdot s$ 附近可以确保许多对象被提升并很快死亡。在下面的测试套件中，所提供的 $(L_{\\min}, L_{\\max})$ 值就是为了具体实例化这种模式而选择的。\n\n所有测试中使用的常量：\n- 次要扫描权重 $\\alpha = 1.0$。\n- 主要扫描权重 $\\beta = 5.0$。\n- 提升成本 $\\gamma = 0.2$。\n\n你的任务：\n- 严格按照规定实现模拟器。\n- 对每个测试用例，计算上面定义的低效率指数 $I$。\n- 你的程序必须在无输入的情况下执行，并且必须打印单行输出，其中包含按指定顺序列出的小数列表。\n\n测试套件：\n- 每个测试用例以元组 $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max})$ 的形式给出。\n- 使用以下四个测试用例，它们展示了不同的行为：\n  1. 违反弱分代假说的典型路径：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 9, 10)$.\n  2. 符合假说的工作负载，其中大多数对象朝生夕死：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 1, 3)$.\n  3. 具有极其频繁的次要回收和立即提升的边界情况：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (30, 60, 1, 40, 120, 2, 2)$.\n  4. 即使在违反假说的模式下，大的老年代容量也会延迟主要回收：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (50, 10000, 2, 25, 300, 5, 6)$.\n\n要求的最终输出格式：\n- 你的程序应产生单行输出，其中包含四个测试用例的低效率指数，格式为方括号内用逗号分隔的列表，顺序与上面列出的一致。例如，格式必须如下所示：\n  $$[I_1, I_2, I_3, I_4].$$\n- 每个 $I_k$ 必须打印为十进制数。如果需要，你可以将它们格式化为固定小数位数，但它们必须是有效的十进制数字。", "solution": "问题陈述是有效的。它提出了一个定义明确、自成体系且具有科学依据的模拟任务，该任务属于计算机科学领域，具体涉及内存管理算法。参数、规则和目标都以足够的精度进行了规定，从而能够得出一个唯一的、确定性的解。\n\n### 步骤 1：提取已知条件\n\n- **分代 GC 模型**：一个具有两代（新生代和老年代）的垃圾回收器 (GC)。\n- **堆容量**：新生代容量 $C_y$，老年代容量 $C_o$。\n- **对象状态**：每个对象拥有一个剩余生命周期 $L \\in \\mathbb{Z}_{\\ge 0}$，一个次要回收存活年龄 $a \\in \\mathbb{Z}_{\\ge 0}$，以及一个分代标签（新生代或老年代）。如果 $L \\le 0$，则对象死亡。\n- **提升阈值**：如果一个对象的次要回收存活年龄 $a$ 达到或超过阈值 $p$（即 $a \\ge p$），它将从新生代提升到老年代。\n- **模拟时间**：模拟运行 $T$ 个离散时间步，从 $t=1$ 到 $t=T$。\n- **分配模式**：在每个时间步 $t$，$A$ 个新对象被分配到新生代。\n- **生命周期分配**：模拟过程中分配的第 $k$ 个对象被赋予生命周期 $L = L_{\\min} + \\left((k - 1) \\bmod (L_{\\max} - L_{\\min} + 1)\\right)$。\n- **每个时间步的操作顺序**：\n    1.  在新生代中分配 $A$ 个新对象。\n    2.  只要新生代对象数量超过 $C_y$，就循环执行次要回收。\n    3.  将两代中所有对象的生命周期 $L$ 减 1。\n    4.  只要老年代对象数量超过 $C_o$，就循环执行主要回收。\n- **次要回收过程**：\n    - 产生的成本是 $\\alpha$ 乘以回收开始时新生代中的对象数量。\n    - 新生代中所有死亡对象（$L \\le 0$）被移除。\n    - 每个存活的新生代对象的次要回收存活年龄 $a$ 增加。\n    - 存活且 $a \\ge p$ 的新生代对象被提升到老年代。每次提升的成本为 $\\gamma$。\n- **主要回收过程**：\n    - 产生的成本是 $\\beta$ 乘以回收开始时两代中的总对象数。\n    - 老年代中所有死亡对象（$L \\le 0$）被移除。\n- **成本模型常量**：\n    - 次要扫描权重：$\\alpha = 1.0$。\n    - 主要扫描权重：$\\beta = 5.0$。\n    - 提升成本：$\\gamma = 0.2$。\n- **低效率指数**：评估指标为 $I = \\frac{\\text{总 GC 成本}}{\\text{总分配次数}} = \\frac{\\text{总 GC 成本}}{T \\cdot A}$。\n- **测试套件**：\n    1.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 9, 10)$。\n    2.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 1, 3)$。\n    3.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (30, 60, 1, 40, 120, 2, 2)$。\n    4.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (50, 10000, 2, 25, 300, 5, 6)$。\n\n### 步骤 2：已知条件验证\n\n所给的问题陈述是有效的。\n- **科学依据**：该模型是一个简化的、但标准的两代垃圾回收器表示，这是系统编程和计算机科学中的一个基本概念。弱分代假说是一个公认的经验性原则，它为这种设计提供了动机。该问题是基于这些思想的一个确定性模拟。\n- **适定性**：所有参数和操作规则都已明确定义，确保了模拟在每一步的状态都是唯一的、可计算的。该问题的结构旨在为每个测试用例产生一个单一、有意义的数值结果 ($I$)。\n- **客观性**：该问题使用精确的技术语言，避免了主观性。所有量都得到了正式定义。\n\n问题表述没有指定的缺陷（例如，科学上不健全、不完整、模棱两可）。这是一个形式化的、可解的问题。\n\n### 步骤 3：求解过程\n\n将根据指定的模型实现一个确定性模拟。系统在任何时刻的状态由新生代和老年代中的对象集合、它们各自的生命周期和年龄以及累积的 GC 成本定义。\n\n**状态表示**\n堆将由两个对象集合表示，一个用于新生代，一个用于老年代。每个对象将是一个类的实例，封装其状态：剩余生命周期 $L$ 和次要回收存活年龄 $a$。\n\n- `young_generation`：新生代中的对象列表。\n- `old_generation`：老年代中的对象列表。\n- `total_gc_cost`：一个浮点数，用于跟踪累积成本。\n- `total_allocations_count`：一个整数 $k$，用于跟踪迄今为止已分配的对象总数，从 1 开始。\n\n**模拟算法**\n模拟通过从 1 到 $T$ 的离散时间步 $t$ 进行。\n\n对于每个具有参数 $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max})$ 的测试用例：\n1.  初始化 `young_generation` 和 `old_generation` 为空。初始化 `total_gc_cost = 0.0` 和 `total_allocations_count = 0`。\n2.  开始主循环：对于从 1 到 $T$ 的 $t$：\n    a.  **分配**：\n        - 生成 $A$ 个新对象。对于每个 $j \\in \\{1, \\dots, A\\}$：\n            - 增加 `total_allocations_count`。设当前值为 $k$。\n            - 计算对象生命周期：$L = L_{\\min} + \\left((k - 1) \\bmod (L_{\\max} - L_{\\min} + 1)\\right)$。\n            - 创建一个具有此生命周期 $L$ 和初始年龄 $a=0$ 的新对象。\n            - 将该对象添加到 `young_generation`。\n\n    b.  **次要回收阶段**：\n        - `while` `young_generation` 中的对象数大于 $C_y$ 时循环：\n            i.   将 $\\alpha \\times |\\text{young\\_generation}|$ 添加到 `total_gc_cost`。\n            ii.  创建三个临时列表：`survivors`、`promoted`、`next_young_generation`。\n            iii. 对于 `young_generation` 中的每个对象：\n                 - 如果其生命周期 $L  0$，则它是一个存活者。增加其年龄：$a \\leftarrow a + 1$。\n                 - 如果其新年龄 $a \\ge p$，则将其添加到 `promoted` 列表。\n                 - 否则（如果 $L  0$ 且 $a  p$），将其添加到 `next_young_generation` 列表。\n            iv.  将 `promoted` 对象添加到 `old_generation`。\n            v.   将 $\\gamma \\times |\\text{promoted}|$ 添加到 `total_gc_cost`。\n            vi.  用 `next_young_generation` 替换 `young_generation`。\n\n    c.  **时间推进**：\n        - 对于 `young_generation` 中的每个对象，将其生命周期递减：$L \\leftarrow L - 1$。\n        - 对于 `old_generation` 中的每个对象，将其生命周期递减：$L \\leftarrow L - 1$。\n\n    d.  **主要回收阶段**：\n        - `while` `old_generation` 中的对象数大于 $C_o$ 时循环：\n            i.   将 $\\beta \\times (|\\text{young\\_generation}| + |\\text{old\\_generation}|)$ 添加到 `total_gc_cost`。\n            ii.  原地过滤 `old_generation`，只保留 $L  0$ 的对象。\n\n3.  **最终计算**：\n    - 在完成 $T$ 步的循环后，计算低效率指数：\n      $$I = \\frac{\\text{total\\_gc\\_cost}}{T \\cdot A}$$\n    - 存储此值。\n\n对提供的四个测试用例中的每一个执行此过程，并收集得出的指数。", "answer": "```python\nimport numpy as np\n\n# Constants from the problem statement\nALPHA = 1.0  # Minor scan weight\nBETA = 5.0   # Major scan weight\nGAMMA = 0.2  # Promotion cost\n\nclass Object:\n    \"\"\"Represents an object in the heap with its state.\"\"\"\n    def __init__(self, lifetime):\n        self.lifetime = lifetime\n        self.age = 0  # Minor-survival age\n\ndef run_simulation(Cy, Co, p, A, T, Lmin, Lmax):\n    \"\"\"\n    Runs a single simulation for a given set of GC parameters.\n    \n    Args:\n        Cy (int): Young generation capacity.\n        Co (int): Old generation capacity.\n        p (int): Promotion threshold (age).\n        A (int): Allocations per time step.\n        T (int): Total time steps for the simulation.\n        Lmin (int): Minimum lifetime for allocated objects.\n        Lmax (int): Maximum lifetime for allocated objects.\n    \n    Returns:\n        float: The calculated inefficiency index.\n    \"\"\"\n    young_gen = []\n    old_gen = []\n    total_gc_cost = 0.0\n    total_allocations_count = 0\n    \n    lifetime_range_size = Lmax - Lmin + 1\n\n    for _ in range(1, T + 1):\n        # 1. Allocate A new objects\n        for _ in range(A):\n            total_allocations_count += 1\n            lifetime_offset = (total_allocations_count - 1) % lifetime_range_size\n            lifetime = Lmin + lifetime_offset\n            new_obj = Object(lifetime)\n            young_gen.append(new_obj)\n\n        # 2. Minor collection phase\n        while len(young_gen) > Cy:\n            # Add cost for scanning young generation\n            total_gc_cost += ALPHA * len(young_gen)\n            \n            survivors = []\n            promoted_count = 0\n            \n            # Identify survivors and objects to be promoted\n            for obj in young_gen:\n                if obj.lifetime > 0:\n                    obj.age += 1\n                    if obj.age >= p:\n                        # This object gets promoted. Resetting its age is not\n                        # strictly necessary as it's no longer used.\n                        old_gen.append(obj)\n                        promoted_count += 1\n                    else:\n                        survivors.append(obj)\n            \n            # Add promotion cost\n            total_gc_cost += GAMMA * promoted_count\n            \n            # Update the young generation\n            young_gen = survivors\n\n        # 3. Decrement lifetime for all objects\n        for obj in young_gen:\n            obj.lifetime -= 1\n        for obj in old_gen:\n            obj.lifetime -= 1\n\n        # 4. Major collection phase\n        while len(old_gen) > Co:\n            # Add cost for scanning both generations\n            total_gc_cost += BETA * (len(young_gen) + len(old_gen))\n            \n            # Reclaim dead objects in the old generation\n            old_gen = [obj for obj in old_gen if obj.lifetime > 0]\n\n    # Calculate the inefficiency index\n    total_allocations = T * A\n    if total_allocations == 0:\n        return 0.0\n    \n    inefficiency_index = total_gc_cost / total_allocations\n    return inefficiency_index\n\ndef solve():\n    \"\"\"\n    Executes the simulation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (Cy, Co, p, A, T, Lmin, Lmax)\n        (100, 500, 2, 30, 200, 9, 10),    # 1. Weak generational hypothesis violation\n        (100, 500, 2, 30, 200, 1, 3),     # 2. Conforming workload (objects die young)\n        (30, 60, 1, 40, 120, 2, 2),       # 3. Frequent GCs and immediate promotions\n        (50, 10000, 2, 25, 300, 5, 6),    # 4. Large old gen delaying major collections\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236439"}, {"introduction": "一个完整的内存管理系统不仅包括回收垃圾，还包括如何高效地分配内存。本练习要求你构建一个全面的仿真环境，在一个带有标记-整理（mark-sweep-compact）回收机制的堆上，对比“首次适应”（first-fit）和“最佳适应”（best-fit）两种分配策略对外部碎片化的影响 [@problem_id:3236476]。通过这个综合性实践，你将量化分析不同设计选择（如此处的分配策略）如何影响系统性能，从而培养从理论算法到实证评估的系统设计思维。", "problem": "您必须编写一个完整、可运行的程序，模拟在一个标记-清除-紧凑 (mark-sweep-compact) 回收方案下，两种分配策略（首次适配和最佳适配）的外部碎片情况，并比较它们在相同工作负载下的平均外部碎片。该模拟必须基于基本定义进行设计，而不是使用预先打包好的结果。\n\n定义和模型假设：\n- 受管堆与布局。堆是一个总大小为 $H$ 字节的一维数组。一个空闲列表 $\\mathcal{F}=\\{(s_i,\\ell_i)\\}_{i=1}^m$ 表示 $m$ 个空闲块，其中 $s_i$ 是起始地址，$\\ell_i$ 是以字节为单位的长度，这些块按地址排序且不重叠。对齐值为 $a$，每个请求的大小 $r$ 都向上取整到不小于 $r$ 的 $a$ 的最小倍数。\n- 分配策略。对于一个大小为 $R$ 的已对齐分配请求，首次适配策略选择地址顺序中第一个满足 $\\ell_i\\ge R$ 的块 $(s_i,\\ell_i)$。最佳适配策略选择满足 $\\ell_i\\ge R$ 且 $\\ell_i$ 最小的块；若大小相同，则选择 $s_i$ 较小的块来打破平局。无论哪种情况，如果 $\\ell_i=R$，该块将从 $\\mathcal{F}$ 中移除；如果 $\\ell_iR$，该块将被分割成一个位于 $s_i$、大小为 $R$ 的已分配段和一个剩余的空闲块 $(s_i+R,\\ell_i-R)$。\n- 外部碎片度量。对于给定的空闲列表 $\\mathcal{F}$，定义总空闲内存 $F=\\sum_{i=1}^{m}\\ell_i$ 和最大块 $L=\\max_{1\\le i\\le m}\\ell_i$（当 $m\\ge 1$ 时），并在 $m=0$ 时设 $F=0$ 和 $L=0$。那一刻的外部碎片为\n$$\nE=\\begin{cases}\n0,  \\text{if }F=0,\\\\\n1-\\dfrac{L}{F},  \\text{if }F>0.\n\\end{cases}\n$$\n- 标记-清除-紧凑方案与回收节奏。时间被划分为 $C$ 个周期。在每个周期中，依次进行 $A$ 次分配尝试。垃圾回收在每个周期之后（结束时）发生。当且仅当周期索引是 $P$ 的倍数时，该周期才会进行一次紧凑操作。在一个没有紧凑的周期结束时，方案执行标记-清除，但不重定位对象；被释放的空间与相邻的空闲区域合并，形成新的 $\\mathcal{F}$，作为 $[0,H)$ 中存活段的补集。在一个有紧凑的周期结束时，所有存活对象按其地址顺序被连续地重定位到从地址 0 开始的位置，并创建一个单独的空闲块 $(U,H-U)$，其中 $U$ 是紧凑后存活对象的总大小。\n- 存活性。每个已分配对象独立地拥有一个以其将存活的未来回收次数衡量的生命周期。设 $d$ 为每次回收的死亡概率，$s=1-d$ 为每次回收的存活概率。对于每个新分配的对象，从支撑集为 $\\{1,2,\\dots\\}$ 的几何分布 $S\\sim\\mathrm{Geometric}(d)$ 中抽取一个值，并将其存活次数设置为 $S-1\\in\\{0,1,2,\\dots\\}$。在每次回收时，当前存活计数器为 $k$ 的对象如果 $k=0$ 则死亡，否则将其计数器更新为 $k-1$。\n- 分配失败处理。在一个周期内，如果一个分配请求无法被当前的空闲列表 $\\mathcal{F}$ 满足，该请求将被丢弃（不进行分配），模拟继续处理下一个请求。在一个周期内，除了周期结束时的回收外，不会触发其他回收。\n- 测量协议。在每次分配尝试之前，立即根据 $\\mathcal{F}$ 计算当前的外部碎片 $E$，并将其添加到一个该次运行的动态列表中。平均外部碎片是算术平均值 $\\bar{E}=\\dfrac{1}{T}\\sum_{t=1}^{T} E_t$，其中 $T=C\\cdot A$ 是总分配尝试次数，$E_t$ 是在第 $t$ 次分配尝试之前立即计算的。报告的数值是分别针对首次适配和最佳适配的 $\\bar{E}$，它们在相同的工作负载和相同的随机性下进行测量。\n- 随机性与可复现性。对于给定的测试用例，请求的大小和生命周期使用指定的种子生成，并对两种策略完全相同地重用，以确保公平比较。请求大小作为整数在 $[r_{\\min},r_{\\max}]$ 范围内均匀随机抽取，然后向上对齐到 $a$ 的倍数。\n\n您的任务：\n- 遵循上述要求，实现一个包含两种分配策略（首次适配和最佳适配）的模拟器。对于每个提供的测试用例，使用指定的种子生成 $C\\cdot A$ 个请求大小和生命周期的序列，然后计算首次适配和最佳适配的平均外部碎片 $\\bar{E}$。\n- 对于每个测试用例，按此确切顺序输出一个包含两个浮点数的列表 $[\\bar{E}_{\\mathrm{first}},\\bar{E}_{\\mathrm{best}}]$。所有浮点数必须使用标准的四舍五入到最近值的方法保留 $6$ 位小数，平局时远离零的舍入（如典型的浮点数格式化）是可以接受的。\n\n测试套件：\n使用以下参数集，每个参数集由一个元组 $(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})$ 完全指定。\n- 测试 1：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(300000,20,5,800,8,128,8,0.3,42)$。\n- 测试 2：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(300000,10,1,800,8,128,8,0.4,12345)$。\n- 测试 3：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(250000,25,7,600,8,128,8,0.2,2024)$。\n- 测试 4：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(50000,10,3,500,8,64,8,1.0,777)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此顶层列表的每个元素对应一个测试用例，顺序与上面列出的一致，并且本身是一个双元素列表 $[\\bar{E}_{\\mathrm{first}},\\bar{E}_{\\mathrm{best}}]$。例如，一个有效的输出看起来像\n\"[ [0.012345,0.009876],[0.000000,0.000000],[0.023456,0.019999],[0.000000,0.000000] ]\"\n但其中的实际数字由您的模拟确定，并且不包含空格，除非您的编程语言会插入空格；您的实际程序必须严格按照指定格式打印一行。", "solution": "该问题要求实现一个内存管理堆的离散时间模拟，以比较首次适配和最佳适配分配策略产生的外部碎片。该模拟必须遵守关于内存布局、分配、垃圾回收（包括周期性紧凑）、对象存活性和测量的一套特定规则。\n\n该模型基于计算机科学中既定的内存管理原则。堆是一个大小为 $H$ 的连续内存块。堆在任何时间点的状态由已分配对象集和空闲块集表示。在此模拟中，这两者被维护为两个独立的列表，并且都按起始内存地址排序。\n\n- 已分配对象列表包含形式为 $(s, \\ell, k)$ 的元组，表示一个起始地址为 $s$、长度为 $\\ell$、存活计数器为 $k$ 的对象。\n- 空闲列表，记为 $\\mathcal{F}$，包含元组 $(s_i, \\ell_i)$，表示一个地址为 $s_i$、长度为 $\\ell_i$ 的空闲块。\n\n保持这些列表有序至关重要。它确保了首次适配策略（选择地址顺序中的第一个可用块）可以通过简单的线性扫描实现。它还能正确处理最佳适配策略的平局打破规则（在大小最小的合适块中选择起始地址较低的块）。此外，已排序的存活对象列表对于垃圾回收的清除和紧凑阶段都是必不可少的。Python 的 `bisect` 模块被用来在插入操作期间高效地维护这种有序性。\n\n模拟在 $C$ 个周期内进行，每个周期包含 $A$ 次分配尝试。工作负载由 $C \\times A$ 对（请求大小，生命周期）组成，使用指定的随机种子预先生成，以确保两种分配策略都在完全相同的请求序列上进行测试，从而实现公平比较。\n- **请求生成**：原始请求大小 $r$ 从 $[r_{\\min}, r_{\\max}]$ 中均匀抽取。然后每个大小都向上对齐到对齐值 $a$ 的最近倍数，得到实际请求大小 $R$。计算公式为 $R = \\lceil r/a \\rceil \\times a$。\n- **存活性模型**：对象的生命周期由每次回收的死亡概率 $d$ 决定。一个对象存活的回收次数 $S$ 服从支撑集为 {$1, 2, \\dots$} 的几何分布 $S \\sim \\mathrm{Geometric}(d)$。一个新分配的对象被赋予 $S-1$ 的存活计数器。\n\n对于总共 $T = C \\times A$ 次的每次分配尝试，模拟遵循以下步骤：\n1. **测量碎片**：在一次分配尝试之前，立即根据当前的空闲列表 $\\mathcal{F}$ 计算外部碎片 $E$。使用总空闲内存 $F = \\sum \\ell_i$ 和最大空闲块大小 $L = \\max \\ell_i$，当 $F0$ 时碎片为 $E = 1 - L/F$，当 $F=0$ 时 $E=0$。该值被记录下来。\n2. **分配**：处理一个大小为 $R$ 的已对齐请求。\n   - **首次适配**：按地址顺序扫描空闲列表 $\\mathcal{F}$，并选择第一个满足 $\\ell_i \\ge R$ 的块 $(s_i, \\ell_i)$。\n   - **最佳适配**：完全扫描空闲列表 $\\mathcal{F}$，以找到一个满足 $\\ell_i \\ge R$ 且使 $\\ell_i$ 最小化的块。\n如果找到合适的块，则用其进行分配。如果其大小 $\\ell_i$ 大于 $R$，则该块被分割，创建一个大小为 $R$ 的新已分配对象和一个大小为 $\\ell_i - R$ 的较小空闲块。如果 $\\ell_i = R$，则使用整个块。如果没有找到合适的块，分配请求失败并被丢弃。\n\n3. **垃圾回收**：每进行 $A$ 次分配后（在每个周期结束时），执行一次垃圾回收。\n   - **存活性更新**：对于每个存活计数器为 $k$ 的已分配对象，如果 $k=0$，该对象被标记为死亡。如果 $k0$，其计数器递减为 $k-1$。\n   - **紧凑**：如果周期索引是紧凑周期 $P$ 的倍数，则执行紧凑阶段。所有存活对象按其现有的相对地址顺序被重定位到堆的开头，从地址 0 开始。这会消除所有碎片，形成一个单一的连续存活数据块，后跟一个大的单一空闲块。\n   - **清除（无紧凑）**：如果不是紧凑周期，则执行清除操作。回收死对象占用的内存。通过识别剩余（已排序）存活对象之间以及与堆边界之间的间隙，构建一个新的空闲列表 $\\mathcal{F}$。此过程隐式地合并了相邻的空闲空间。\n\n每种策略的最终报告值是所有 $T$ 次分配尝试前记录的所有碎片值的算术平均值 $\\bar{E}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport bisect\n\nclass MemorySimulator:\n    \"\"\"\n    Simulates heap memory management with first-fit or best-fit allocation,\n    and a mark-sweep-compact garbage collector.\n    \"\"\"\n    def __init__(self, params, workload, strategy):\n        \"\"\"\n        Initializes the simulator with given parameters.\n        \n        Args:\n            params (tuple): Simulation parameters (H, C, P, A, ...).\n            workload (list): A list of (request_size, survival_counter) tuples.\n            strategy (str): Allocation strategy, 'first_fit' or 'best_fit'.\n        \"\"\"\n        (self.H, self.C, self.P, self.A, \n         self.r_min, self.r_max, self.a, self.d, self.seed) = params\n        self.workload = workload\n        self.strategy = strategy\n        \n        # State variables\n        self.allocated_objects = []  # List of (start, size, survival_counter)\n        self.free_list = [(0, self.H)] # List of (start, size)\n        self.fragmentation_scores = []\n\n    def run_simulation(self):\n        \"\"\"\n        Executes the full simulation over all cycles and allocation attempts.\n        \n        Returns:\n            float: The average external fragmentation over the simulation run.\n        \"\"\"\n        workload_idx = 0\n        for c in range(1, self.C + 1):\n            for _ in range(self.A):\n                self._measure_fragmentation()\n                \n                request_size, survival_counter = self.workload[workload_idx]\n                self._allocate(request_size, survival_counter)\n                workload_idx += 1\n                \n            self._collect_garbage(c)\n        \n        if not self.fragmentation_scores:\n            return 0.0\n        return np.mean(self.fragmentation_scores)\n\n    def _measure_fragmentation(self):\n        \"\"\"\n        Calculates and records the current external fragmentation.\n        \"\"\"\n        if not self.free_list:\n            total_free, largest_block = 0, 0\n        else:\n            free_block_sizes = [block[1] for block in self.free_list]\n            total_free = sum(free_block_sizes)\n            largest_block = max(free_block_sizes)\n        \n        fragmentation = 0.0 if total_free == 0 else 1.0 - (largest_block / total_free)\n        self.fragmentation_scores.append(fragmentation)\n\n    def _find_block_idx(self, size):\n        \"\"\"Finds a suitable free block index based on the allocation strategy.\"\"\"\n        if self.strategy == 'first_fit':\n            for i, (_, length) in enumerate(self.free_list):\n                if length >= size:\n                    return i\n            return None\n        \n        elif self.strategy == 'best_fit':\n            best_idx = -1\n            min_size = float('inf')\n            # The free list is sorted by address, so the first match in case of a\n            # size tie will have the smallest start address, satisfying the\n            # tie-breaking rule.\n            for i, (_, length) in enumerate(self.free_list):\n                if length >= size:\n                    if length  min_size:\n                        min_size = length\n                        best_idx = i\n            return best_idx if best_idx != -1 else None\n\n    def _allocate(self, size, survival_counter):\n        \"\"\"Attempts to allocate a block of memory of a given size.\"\"\"\n        block_idx = self._find_block_idx(size)\n        if block_idx is not None:\n            start, length = self.free_list.pop(block_idx)\n            \n            # Add to allocated list, keeping it sorted by start address.\n            new_obj = (start, size, survival_counter)\n            bisect.insort_left(self.allocated_objects, new_obj)\n            \n            # If the block was larger than needed, return remainder to free list.\n            if length > size:\n                new_free_block = (start + size, length - size)\n                bisect.insort_left(self.free_list, new_free_block)\n\n    def _collect_garbage(self, cycle_num):\n        \"\"\"Performs garbage collection at the end of a cycle.\"\"\"\n        # Identify live objects and decrement their survival counters.\n        live_objects = []\n        for obj in self.allocated_objects:\n            if obj[2] > 0:  # Object survives if counter > 0\n                live_objects.append((obj[0], obj[1], obj[2] - 1))\n        \n        self.allocated_objects = live_objects\n\n        # Perform compaction or sweep.\n        if cycle_num % self.P == 0:\n            # Compaction: Relocate all live objects to the start of the heap.\n            current_addr = 0\n            compacted_objects = []\n            for _, size, counter in self.allocated_objects:\n                compacted_objects.append((current_addr, size, counter))\n                current_addr += size\n            self.allocated_objects = compacted_objects\n            self.free_list = [] if current_addr >= self.H else [(current_addr, self.H - current_addr)]\n        else:\n            # Sweep: Rebuild free list from gaps between live objects.\n            self.free_list = []\n            last_addr = 0\n            for start, size, _ in self.allocated_objects:\n                if start > last_addr:\n                    self.free_list.append((last_addr, start - last_addr))\n                last_addr = start + size\n            if last_addr  self.H:\n                self.free_list.append((last_addr, self.H - last_addr))\n                \ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (300000, 20, 5, 800, 8, 128, 8, 0.3, 42),\n        (300000, 10, 1, 800, 8, 128, 8, 0.4, 12345),\n        (250000, 25, 7, 600, 8, 128, 8, 0.2, 2024),\n        (50000, 10, 3, 500, 8, 64, 8, 1.0, 777),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        H, C, P, A, r_min, r_max, a, d, seed = params\n        \n        # 1. Generate a single, reproducible workload for the test case.\n        rng = np.random.default_rng(seed)\n        total_attempts = C * A\n        \n        request_sizes = rng.integers(r_min, r_max + 1, size=total_attempts)\n        aligned_sizes = np.ceil(request_sizes / a) * a\n        aligned_sizes = aligned_sizes.astype(int)\n        \n        # S ~ Geometric(d) on {1, 2, ...}, survival counter is S-1\n        survival_draws = rng.geometric(p=d, size=total_attempts)\n        survival_counters = survival_draws - 1\n\n        workload = list(zip(aligned_sizes, survival_counters))\n\n        # 2. Run simulation for First-Fit\n        sim_ff = MemorySimulator(params, workload, 'first_fit')\n        avg_frag_ff = sim_ff.run_simulation()\n\n        # 3. Run simulation for Best-Fit using the same workload\n        sim_bf = MemorySimulator(params, workload, 'best_fit')\n        avg_frag_bf = sim_bf.run_simulation()\n\n        all_results.append([avg_frag_ff, avg_frag_bf])\n\n    # 4. Format and print the final output string exactly as required.\n    result_strings = [f\"[{ff:.6f},{bf:.6f}]\" for ff, bf in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3236476"}]}