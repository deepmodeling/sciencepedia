{"hands_on_practices": [{"introduction": "现代计算机在最底层是通过位运算来执行算术操作的。这个练习旨在揭示二进制表示与基本算术之间的直接联系，通过位移操作来实现乘以或除以2的幂。掌握这项技能不仅能加深对数字内部表示的理解，还能为编写高效的底层代码和性能优化打下坚实的基础 [@problem_id:3260707]。", "problem": "你的任务是仅使用在有符号整数上定义的位移运算符的语义，来实现整数乘以和除以2的幂。目标是从二进制位值计数法和二补数表示法出发进行推理，从而推导并实现正确的运算，而不依赖于显式的乘法、除法或求幂运算符。\n\n使用的基本原理：\n- 二进制位值计数法：任何非负整数 $n$ 都可以表示为 $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$，其中每个 $b_i \\in \\{0,1\\}$，$m$ 是一个非负整数。在二补数表示法中，负整数在算术右移下会无限扩展其符号位，以保持代数结构。\n- 有符号整数上的位移运算符语义：对于一个非负整数位移量 $k$，左移将每个比特位 $i$ 移动到位置 $i+k$；而算术右移将每个比特位 $i$ 移动到 $i-k$，并对负值复制其符号位。\n\n任务：\n- 在有符号数学整数上实现两个函数：\n  1. $f_{\\text{mul}}(n,k)$，仅使用左移运算符语义返回乘积 $n \\cdot 2^k$。\n  2. $f_{\\text{div\\_floor}}(n,k)$，仅使用算术右移运算符语义返回向下取整的除法结果 $\\left\\lfloor \\dfrac{n}{2^k} \\right\\rfloor$。\n- 约束条件：\n  - 输入 $n$ 和 $k$ 是数学整数，且 $k \\ge 0$。\n  - 实现中不得使用乘法、除法或求幂运算符。只能使用位移运算符来实现所需的操作。\n  - 将有符号整数作为数学对象进行无界精度操作；不要假设固定的字长。\n\n测试套件：\n- 使用以下参数对 $(n,k)$ 来验证正确性和边缘行为：\n  - $(13, 2)$ 表示 $n = 13$, $k = 2$。\n  - $(-13, 2)$ 表示 $n = -13$, $k = 2$。\n  - $(0, 5)$ 表示 $n = 0$, $k = 5$。\n  - $(1, 0)$ 表示 $n = 1$, $k = 0$。\n  - $(-1, 1)$ 表示 $n = -1$, $k = 1$。\n  - $(123456789, 3)$ 表示 $n = 123456789$, $k = 3$。\n  - $(-1073741824, 5)$ 表示 $n = -1073741824$, $k = 5$。\n  - $(7, 63)$ 表示 $n = 7$, $k = 63$。\n- 对于每个测试用例，计算两个整数：$f_{\\text{mul}}(n,k)$ 和 $f_{\\text{div\\_floor}}(n,k)$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个结果本身是一个不含空格的两个整数元素的列表，顺序与测试套件一致，例如：\n- 确切格式为 $[[a_1,b_1],[a_2,b_2],\\dots,[a_8,b_8]]$，其中对于第 $i$ 个测试用例，$a_i = f_{\\text{mul}}(n_i,k_i)$ 且 $b_i = f_{\\text{div\\_floor}}(n_i,k_i)$。", "solution": "该问题陈述被评估为有效。它在科学上基于二进制算术和二补数表示法的原理，问题设定良好，具有明确的目标和约束，并且使用客观、无歧义的语言进行表述。任务是从第一性原理出发，仅使用位移运算的语义等价物来推导和实现整数乘以和除以2的幂。\n\n我们将根据所提供的基本原理，推导所需的两个函数 $f_{\\text{mul}}(n,k)$ 和 $f_{\\text{div\\_floor}}(n,k)$ 的解。\n\n### $f_{\\text{mul}}(n,k) = n \\cdot 2^k$ 的推导\n\n问题是计算一个整数 $n$ 与2的幂 $2^k$ 的乘积（其中 $k \\ge 0$），且仅使用左位移语义。\n\n首先，考虑一个非负整数 $n$。根据二进制位值计数法，$n$ 可以表示为2的幂之和：\n$$n = \\sum_{i=0}^{m} b_i \\cdot 2^i$$\n其中 $b_i \\in \\{0, 1\\}$ 是 $n$ 在位置 $i$ 上的二进制数字（比特），$m$ 是表示 $n$ 所需的最高次幂。\n\n将 $n$ 乘以 $2^k$ 得：\n$$n \\cdot 2^k = \\left( \\sum_{i=0}^{m} b_i \\cdot 2^i \\right) \\cdot 2^k$$\n根据乘法对加法的分配律以及指数定律（$a^x \\cdot a^y = a^{x+y}$），我们可以将其重写为：\n$$n \\cdot 2^k = \\sum_{i=0}^{m} (b_i \\cdot 2^i \\cdot 2^k) = \\sum_{i=0}^{m} b_i \\cdot 2^{i+k}$$\n这个结果和表示一个新的整数，其中每个原始在位置 $i$ 的比特 $b_i$（贡献值为 $b_i \\cdot 2^i$）现在位于位置 $i+k$（贡献值为 $b_i \\cdot 2^{i+k}$）。这精确地描述了逻辑左移 $k$ 位的操作。从位置 $0$ 到 $k-1$ 的新低位比特被填充为零。\n\n对于负整数，我们依赖于二补数表示法。在此系统中，对有符号整数执行左位移（新引入的右侧比特为零）在算术上等同于乘以 $2^k$，前提是没有有效位因溢出而丢失。问题指定使用无界精度整数，这对应于Python的任意精度整数类型。这种抽象确保不会发生溢出。因此，左移操作对所有整数 $n$ 均有效。\n\n因此，函数 $f_{\\text{mul}}(n, k)$ 可以通过左位移操作来实现，在包括Python在内的许多编程语言中，该操作由 `` 表示。\n$$f_{\\text{mul}}(n,k) \\equiv n \\ll k$$\n\n### $f_{\\text{div\\_floor}}(n,k) = \\lfloor \\frac{n}{2^k} \\rfloor$ 的推导\n\n问题是计算一个整数 $n$ 除以2的幂 $2^k$ 的向下取整结果（其中 $k \\ge 0$），且仅使用算术右位移语义。\n\n首先，考虑一个非负整数 $n$，表示为 $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$。\n将 $n$ 除以 $2^k$ 得：\n$$\\frac{n}{2^k} = \\frac{1}{2^k} \\sum_{i=0}^{m} b_i \\cdot 2^i = \\sum_{i=0}^{m} b_i \\cdot 2^{i-k}$$\n我们可以在索引 $i=k$ 处将此和式拆分：\n$$\\frac{n}{2^k} = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k} + \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$$\n第一项 $\\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$ 是一个整数。它对应于 $n$ 的二进制表示右移 $k$ 位，位置 $0$ 到 $k-1$ 的比特被丢弃。\n第二项 $\\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$ 是非负项之和。其值满足 $0 \\le \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}  1$。此项代表除法的小数部分。\n\n一个数的向下取整（floor）是小于或等于该数的最大整数。由于第二项是一个小于1的非负分数，整个表达式的向下取整就是其整数部分：\n$$\\left\\lfloor \\frac{n}{2^k} \\right\\rfloor = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$$\n这个操作正是一个算术右移。对于非负数，算术右移与逻辑右移相同：比特向右移动 $k$ 位，空出的 $k$ 个最高位用 $0$ 填充，这是非负数的符号位。\n\n现在，考虑一个负整数 $n$。向下取整除法 $\\lfloor \\frac{n}{d} \\rfloor$ 向负无穷方向取整。例如，$\\lfloor \\frac{-13}{4} \\rfloor = \\lfloor -3.25 \\rfloor = -4$。这与截断（向零取整）不同，后者会得到 $-3$。问题明确要求向下取整除法，而对二补数进行的算术右移被定义为产生此确切结果。在算术右移中，比特向右移动，空出的高位用原始符号位的副本填充。对于负数，符号位是 $1$，所以新比特是 $1$。这个过程正确地保留了符号并使数值向负无穷方向取整。\n\nPython的整数右移运算符 `>>` 实现的是算术右移。对于正整数和负整数，此行为都有保证，并直接对应于除以2的幂的向下取整除法。\n\n因此，函数 $f_{\\text{div\\_floor}}(n, k)$ 可以通过算术右位移操作来实现。\n$$f_{\\text{div\\_floor}}(n,k) \\equiv n \\gg k$$\n\n实现将把这两个推导出的等价关系应用于提供的测试套件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of implementing multiplication and floor division by powers\n    of two using only bit shift operators, based on first principles of binary\n    arithmetic and two's complement representation.\n    \"\"\"\n    \n    # Define the functions based on the derived principles.\n    # f_mul(n, k) computes n * 2**k using the left shift operator.\n    # The derivation showed that n  k is equivalent to n * 2**k for all integers n\n    # and non-negative integers k, within an unbounded integer model.\n    f_mul = lambda n, k: n  k\n\n    # f_div_floor(n, k) computes floor(n / 2**k) using the arithmetic right shift operator.\n    # The derivation showed that n >> k (arithmetic right shift) is equivalent to\n    # floor(n / 2**k) for all integers n and non-negative integers k.\n    f_div_floor = lambda n, k: n >> k\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (13, 2),\n        (-13, 2),\n        (0, 5),\n        (1, 0),\n        (-1, 1),\n        (123456789, 3),\n        (-1073741824, 5),\n        (7, 63)\n    ]\n\n    results = []\n    for n, k in test_cases:\n        # Calculate the multiplication and division results for the current case.\n        mul_result = f_mul(n, k)\n        div_result = f_div_floor(n, k)\n        \n        # Append the pair of results to the list.\n        results.append([mul_result, div_result])\n\n    # Format the final output string exactly as specified:\n    # A comma-separated list of two-element lists, with no whitespace.\n    # e.g., [[a_1,b_1],[a_2,b_2],...]\n    output_str = f\"[{','.join(f'[{res[0]},{res[1]}]' for res in results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3260707"}, {"introduction": "除了算术功能，位运算符还具备强大的逻辑特性，能够以出乎意料的方式操控数据。一个经典的例子是不使用临时变量交换两个整数的值，这完美地展示了位运算的巧妙之处。此练习的核心是利用异或（XOR）运算的代数属性，即任何数与自身异或结果为零（$a \\oplus a = 0$），以及任何数与零异或结果为自身（$a \\oplus 0 = a$）[@problem_id:3260585]。通过这个实践，你将学会跳出传统算术的思维定式，领略位逻辑在状态操纵方面的优雅与力量。", "problem": "你需要编写一个完整的程序，定义并使用一个函数，仅通过位运算来交换两个原始整数，且不使用任何临时变量。目标是从第一性原理出发，论证这种交换为何是可能且正确的。程序必须实现该函数，在提供的测试套件上运行它，并以指定的格式打印聚合结果。\n\n在你的推理和算法设计中，应使用以下定义作为基本依据：整数在二进制中表示为比特序列，位运算独立作用于每个比特。按位异或（XOR）将用 $\\oplus$ 表示，按位与（AND）将用 $\\land$ 表示，按位或（OR）将用 $\\lor$ 表示。除了这些表示和运算之外，不应需要任何其他假设。\n\n交换函数的约束条件：\n- 函数必须接受两个整数 $a$ 和 $b$，并返回交换后的值。\n- 函数不得分配或使用任何额外的临时变量。\n- 在交换函数内部，不允许使用算术运算（如 $+$、$-$、$\\times$、$\\div$）、元组解包以及任何库或特定于语言的交换结构。\n- 函数的执行时间复杂度必须为 $\\mathcal{O}(1)$，空间复杂度为 $\\mathcal{O}(1)$。\n\n程序需要执行的测试套件：\n- 情况 1：$a = 3$, $b = 5$。\n- 情况 2：$a = 0$, $b = 0$。\n- 情况 3：$a = 0$, $b = 42$。\n- 情况 4：$a = -7$, $b = 13$。\n- 情况 5：$a = 2^{63} - 1$, $b = -2^{63}$。\n- 情况 6：$a = 123456789$, $b = 987654321$。\n- 情况 7：$a = 1$, $b = 1$。\n\n你的程序必须将交换函数应用于每个测试用例，并生成一行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表。列表中的每个元素本身必须是一个双整数列表 $[a',b']$，表示相应测试用例交换后的值，其中 $a'$ 是 $a$ 的新值（原为 $b$），$b'$ 是 $b$ 的新值（原为 $a$）。例如，输出格式应类似于 $[[b_1,a_1],[b_2,a_2],\\dots]$，不含空格。", "solution": "该问题是有效的。它提出了一个计算逻辑中明确定义的任务，该任务植根于位运算的基本代数性质。所有约束条件都是一致的，目标是明确的。\n\n任务是交换两个整数变量（我们称之为 $a$ 和 $b$）的值，而不使用辅助的临时变量。约束条件将允许的操作限定为仅能使用位运算。解决方案的关键在于按位异或（XOR）运算的性质，该运算用符号 $\\oplus$ 表示。\n\n从第一性原理出发的论证依赖于整数集合在按位异或运算下形成的代数结构。由于位运算独立作用于整数二进制表示中的每个比特，我们可以在单个比特的层面上分析其性质。集合 $\\{0, 1\\}$ 与异或运算构成一个阿贝尔群（abelian group）。其关键性质如下：\n\n1.  **交换律 (Commutativity)**：$x \\oplus y = y \\oplus x$。操作数的顺序无关紧要。\n2.  **结合律 (Associativity)**：$(x \\oplus y) \\oplus z = x \\oplus (y \\oplus z)$。运算的分组无关紧要。\n3.  **单位元 (Identity Element)**：存在一个单位元 $0$，使得 $x \\oplus 0 = x$。\n4.  **自反逆元 (Self-Inverse)**：每个元素都是其自身的逆元，即 $x \\oplus x = 0$。\n\n这些为单个比特建立的性质可以推广到任意比特长度的整数，因为这些运算是逐比特应用的。\n\n设变量的初始值为 $a_0$ 和 $b_0$。交换通过使用异或运算的三个赋值序列来实现。\n\n**第一步：** 通过将 $a$ 与 $b$ 进行异或运算来更新 $a$ 的值。\n$$a \\leftarrow a \\oplus b$$\n此步骤后，变量 $a$ 的值为 $a_1 = a_0 \\oplus b_0$。变量 $b$ 仍然保持其原始值 $b_0$。此时变量的状态是 $(a_1, b_0)$。\n\n**第二步：** 通过将 $b$ 与 $a$ 的新值进行异或运算来更新 $b$ 的值。\n$$b \\leftarrow a \\oplus b$$\n代入变量的当前值（$a=a_1$, $b=b_0$），我们得到：\n$$b \\leftarrow a_1 \\oplus b_0$$\n现在，代入第一步中 $a_1$ 的表达式：\n$$b \\leftarrow (a_0 \\oplus b_0) \\oplus b_0$$\n使用结合律，我们可以重新组合各项：\n$$b \\leftarrow a_0 \\oplus (b_0 \\oplus b_0)$$\n使用自反逆元性质（$b_0 \\oplus b_0 = 0$）：\n$$b \\leftarrow a_0 \\oplus 0$$\n最后，使用单位元性质（$a_0 \\oplus 0 = a_0$）：\n$$b \\leftarrow a_0$$\n此步骤后，变量 $b$ 正确地持有了 $a$ 的原始值，即 $a_0$。变量 $a$ 仍然持有值 $a_1 = a_0 \\oplus b_0$。此时状态为 $(a_1, a_0)$。\n\n**第三步：** 最后一次通过将 $a$ 与 $b$ 的新值进行异或运算来更新 $a$ 的值。\n$$a \\leftarrow a \\oplus b$$\n代入当前值（$a=a_1$, $b=a_0$）：\n$$a \\leftarrow a_1 \\oplus a_0$$\n现在，代入第一步中 $a_1$ 的表达式：\n$$a \\leftarrow (a_0 \\oplus b_0) \\oplus a_0$$\n使用交换律重新排列各项：\n$$a \\leftarrow (b_0 \\oplus a_0) \\oplus a_0$$\n使用结合律重新分组：\n$$a \\leftarrow b_0 \\oplus (a_0 \\oplus a_0)$$\n使用自反逆元性质（$a_0 \\oplus a_0 = 0$）：\n$$a \\leftarrow b_0 \\oplus 0$$\n最后，使用单位元性质（$b_0 \\oplus 0 = b_0$）：\n$$a \\leftarrow b_0$$\n在此最后一步之后，变量 $a$ 现在持有了 $b$ 的原始值，即 $b_0$。变量 $b$ 继续持有 $a_0$。\n\n变量的最终状态是 $(b_0, a_0)$。值已成功交换。此算法遵守所有规定的约束条件：它不使用临时变量，完全依赖于位运算，并且由固定数量的操作组成，因此时间复杂度为 $\\mathcal{O}(1)$，空间复杂度为 $\\mathcal{O}(1)$。\n\n实现部分将定义一个函数，该函数接收两个整数并应用这个三步异或序列，返回新值。然后将为提供的测试套件中的每个案例执行此函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of swapping integers using bitwise XOR and\n    prints the results for a given test suite.\n    \"\"\"\n\n    def xor_swap(a, b):\n        \"\"\"\n        Swaps two integers using only bitwise XOR operations.\n\n        This function implements the classic XOR swap algorithm, which swaps the\n        values of two variables without using a temporary variable. The logic\n        relies on the algebraic properties of the XOR operation.\n\n        Args:\n            a: The first integer.\n            b: The second integer.\n\n        Returns:\n            A tuple (a, b) with the swapped values.\n        \"\"\"\n        # Let initial values be a_0 and b_0.\n        # Step 1: a becomes a_0 ^ b_0. b is still b_0.\n        a = a ^ b\n        # Step 2: b becomes (a_0 ^ b_0) ^ b_0 = a_0 ^ (b_0 ^ b_0) = a_0 ^ 0 = a_0.\n        # So b now holds the original value of a.\n        b = a ^ b\n        # Step 3: a becomes (a_0 ^ b_0) ^ a_0 = (a_0 ^ a_0) ^ b_0 = 0 ^ b_0 = b_0.\n        # So a now holds the original value of b.\n        a = a ^ b\n        return a, b\n\n    # Define the test cases from the problem statement.\n    # Python integers have arbitrary precision, which correctly models\n    # the behavior of two's complement arithmetic for bitwise operations\n    # on fixed-width integers, including the large integer case.\n    test_cases = [\n        (3, 5),                       # Case 1\n        (0, 0),                       # Case 2\n        (0, 42),                      # Case 3\n        (-7, 13),                     # Case 4\n        (2**63 - 1, -2**63),          # Case 5\n        (123456789, 987654321),       # Case 6\n        (1, 1),                       # Case 7\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        swapped_a, swapped_b = xor_swap(a_val, b_val)\n        results.append((swapped_a, swapped_b))\n\n    # Format the output exactly as specified: [[b1,a1],[b2,a2],...]\n    # with no spaces.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3260585"}, {"introduction": "计算两个整数的平均值是一个常见的编程任务，但看似简单的实现 `(a+b)/2` 却隐藏着整数溢出的风险，这在实际系统中可能导致严重错误。这个练习将教你如何通过重构数学公式来编写健壮的数值代码，从而避免这种风险。其原理是将每个整数分解为除以 $2$ 后的商和余数，然后利用位移和位与操作对这些更小的、不会溢出的部分进行安全计算 [@problem_id:3260606]。这项实践不仅展示了如何将数学洞察力转化为安全高效的位运算算法，也培养了在处理数值时严谨细致的思维习惯。", "problem": "给定两个有符号整数 $a$ 和 $b$，它们来自现代中央处理器（CPU）使用的定宽二进制补码表示法。目标是计算算术平均数，定义为实数 $(a+b)/2$，并返回其向下取整到最接近的整数的值（即数学上的向下取整）。在定宽算术下，计算过程中的任何中间步骤都不得有整数溢出的风险。\n\n设计并实现一个程序，该程序：\n- 计算整数值 $\\left\\lfloor (a+b)/2 \\right\\rfloor$，而不使用任何可能对有效输入 $a$ 和 $b$ 产生溢出的操作。\n- 将 $a$ 和 $b$ 视为有符号整数，其行为与二进制补码语义和算术右移一致。\n- 不依赖任意精度算术；该方法必须在典型的定宽环境中有效，在这种环境中，即使最终的平均值在范围内，$a+b$ 也可能溢出。\n\n您的实现必须从二进制补码算术和位运算的核心定义中逻辑推导得出。除这些定义外，不要假设任何特殊属性。\n\n使用以下输入对测试套件，每个测试对指定为 $(a,b)$，并以指定的输出格式生成结果：\n- $(7, 9)$\n- $(2^{31}-1, 2^{31}-1)$\n- $(-2^{31}, -2^{31})$\n- $(2^{31}-1, -2^{31})$\n- $(-3, 2)$\n- $(-4, 2)$\n- $(0, -1)$\n- $(2^{63}-1, -2^{63})$\n- $(2^{31}-2, -2^{31}+1)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots,r_9]$），其中每个 $r_i$ 是对应于第 $i$ 个测试用例的整数结果 $\\left\\lfloor (a_i+b_i)/2 \\right\\rfloor$。", "solution": "用户提供的问题已经过分析，并被认定为**有效**。该问题科学地基于计算机算术原理，问题陈述清晰，约束明确，且表述客观。\n\n### 问题陈述分析\n\n目标是计算两个有符号整数算术平均数的向下取整值 $\\lfloor (a+b)/2 \\rfloor$，其约束条件是任何中间操作都不能导致整数溢出。整数 $a$ 和 $b$ 使用定宽二进制补码系统表示，这是现代CPU中的标准。\n\n朴素的计算方法 `(a+b)/2` 是不允许的，因为中间和 $a+b$ 可能会超过定宽整数类型可表示的最大（或最小）值，从而导致溢出。例如，在一个32位有符号整数系统中，如果 $a = 2^{31}-1$ 且 $b = 2^{31}-1$（可表示的最大值），它们的和 $a+b = 2^{32}-2$ 将会导致溢出。然而，真正的平均值 $\\lfloor (2^{31}-1 + 2^{31}-1)/2 \\rfloor = 2^{31}-1$ 是完全可以表示的。因此，该任务需要推导出一个等价的、能抵抗此类溢出的数学公式。\n\n### 从第一性原理推导\n\n我们的目标是计算 $m = \\lfloor \\frac{a+b}{2} \\rfloor$。我们将从整数除法的基本定义出发，推导出一个安全的方法。\n\n根据除法算法，任何整数 $x$ 都可以用除以2的形式表示为：\n$$x = 2 \\cdot \\left\\lfloor \\frac{x}{2} \\right\\rfloor + (x \\pmod 2)$$\n其中 $x \\pmod 2$ 是余数，如果 $x$ 是偶数则为0，如果 $x$ 是奇数则为1。\n\n让我们将此分解应用于整数 $a$ 和 $b$：\n$$a = 2 \\cdot \\left\\lfloor \\frac{a}{2} \\right\\rfloor + (a \\pmod 2)$$\n$$b = 2 \\cdot \\left\\lfloor \\frac{b}{2} \\right\\rfloor + (b \\pmod 2)$$\n\n将这些表达式代入和 $a+b$ 中可得：\n$$a+b = \\left(2 \\cdot \\left\\lfloor \\frac{a}{2} \\right\\rfloor + (a \\pmod 2)\\right) + \\left(2 \\cdot \\left\\lfloor \\frac{b}{2} \\right\\rfloor + (b \\pmod 2)\\right)$$\n\n通过重新组合各项，我们得到：\n$$a+b = 2 \\cdot \\left(\\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor\\right) + \\left((a \\pmod 2) + (b \\pmod 2)\\right)$$\n\n现在，我们可以通过除以2来计算平均值：\n$$\\frac{a+b}{2} = \\left(\\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor\\right) + \\frac{(a \\pmod 2) + (b \\pmod 2)}{2}$$\n\n为了找到所需的整数值，我们将向下取整函数应用于整个表达式：\n$$m = \\left\\lfloor \\left(\\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor\\right) + \\frac{(a \\pmod 2) + (b \\pmod 2)}{2} \\right\\rfloor$$\n\n由于 $\\lfloor \\frac{a}{2} \\rfloor$ 和 $\\lfloor \\frac{b}{2} \\rfloor$ 是整数，它们的和也是整数。根据向下取整函数的一个性质，即对于任何整数 $k$ 都有 $\\lfloor k+z \\rfloor = k + \\lfloor z \\rfloor$，我们可以将整数部分从主要的向下取整操作中分离出来：\n$$m = \\left\\lfloor \\frac{a}{2} \\right\\rfloor + \\left\\lfloor \\frac{b}{2} \\right\\rfloor + \\left\\lfloor \\frac{(a \\pmod 2) + (b \\pmod 2)}{2} \\right\\rfloor$$\n\n### 映射到位运算\n\n现在必须将这个数学公式转换为在定宽、二进制补码环境中安全的操作。问题陈述指定要使用算术右移。\n- 对于二进制补码系统中的任何有符号整数 $x$，操作 $\\lfloor x/2 \\rfloor$ 可以通过单次**算术右移**（表示为 `x >> 1`）来正确且高效地实现。此操作会保留符号位，从而正确处理正数和负数。\n- 求余操作 $x \\pmod 2$ 可以通过与1进行**按位与**（bitwise AND）来实现。表达式 `x  1` 在 $x$ 的最低有效位为1时（即 $x$ 为奇数）结果为1，否则为0。这在二进制补码中对正数和负数都成立。\n\n将这些位运算代入我们推导出的公式，得到最终的计算算法：\n$$m = (a \\gg 1) + (b \\gg 1) + (((a \\land 1) + (b \\land 1)) \\gg 1)$$\n其中 $\\gg$ 表示算术右移，$\\land$ 表示按位与。\n\n### 溢出安全性分析\n\n我们必须确认这个最终表达式中的任何中间计算都不会溢出。\n1.  **移位操作**：`a >> 1` 和 `b >> 1`。算术右移会减小数的绝对值（或对于-1保持不变），因此它永远不会溢出。\n2.  **求余计算**：`a  1` 和 `b  1`。这些操作的结果是0或1。\n3.  **余数之和**：`(a  1) + (b  1)`。此和的最大值为 $1+1=2$，不会溢出任何标准整数类型。随后的右移 `>> 1` 也是安全的。\n4.  **最终加法**：该表达式将三项相加：`(a >> 1)`、`(b >> 1)` 以及一个值为0或1的项。两个数的算术平均值总是在这两个数之间。因此，最终结果 $\\lfloor(a+b)/2\\rfloor$ 必须能在存储 $a$ 和 $b$ 的相同定宽整数类型内表示。我们的公式在数学上与此结果等价。主和 `(a >> 1) + (b >> 1)` 在数值上非常接近最终的平均值。它不会溢出，因为如果溢出，就意味着最终的平均值本身也超出了范围，这是一个矛盾。\n\n因此，该方法对于所有有效的输入 $a$ 和 $b$ 都能被证明是不会发生整数溢出的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the integer mean of pairs of numbers without intermediate overflow,\n    simulating fixed-width two's complement arithmetic.\n    \"\"\"\n    \n    # Define constants for clarity in the test cases.\n    INT32_MAX = 2**31 - 1\n    INT32_MIN = -2**31\n    INT64_MAX = 2**63 - 1\n    INT64_MIN = -2**63\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        (7, 9),\n        (INT32_MAX, INT32_MAX),\n        (INT32_MIN, INT32_MIN),\n        (INT32_MAX, INT32_MIN),\n        (-3, 2),\n        (-4, 2),\n        (0, -1),\n        (INT64_MAX, INT64_MIN),\n        (INT32_MAX - 1, INT32_MIN + 1), # Corresponds to (2**31-2, -2**31+1)\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        # To accurately model fixed-width, two's-complement arithmetic as\n        # specified in the problem, we use numpy.int64. This prevents Python's\n        # arbitrary-precision integers from hiding the overflow problem and\n        # ensures that bitwise operations behave as they would on a CPU.\n        a = np.int64(a_val)\n        b = np.int64(b_val)\n\n        # The core logic is derived from the principle of integer division.\n        # The mean floor( (a+b)/2 ) can be expressed as:\n        # floor(a/2) + floor(b/2) + floor( ( (a%2) + (b%2) ) / 2 )\n        #\n        # This is safely implemented using bitwise operations:\n        # - floor(x/2) is equivalent to an arithmetic right shift `x >> 1`.\n        # - x%2 is equivalent to a bitwise AND with 1, `x  1`.\n        #\n        # The computation avoids overflow because the initial divisions (shifts)\n        # reduce the magnitude of the operands before they are added.\n        \n        # Calculate floor(a/2) and floor(b/2)\n        a_div_2 = a >> 1\n        b_div_2 = b >> 1\n\n        # Calculate the sum of the remainders and its floored division by 2\n        remainder_term = ((a  1) + (b  1)) >> 1\n        \n        # The final result is the sum of the parts.\n        result = a_div_2 + b_div_2 + remainder_term\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3260606"}]}