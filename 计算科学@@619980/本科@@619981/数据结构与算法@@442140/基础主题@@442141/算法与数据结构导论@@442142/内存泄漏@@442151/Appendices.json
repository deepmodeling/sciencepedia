{"hands_on_practices": [{"introduction": "我们从一个基础模型开始。本练习 [@problem_id:3252070] 将帮助你区分两种主要的内存泄漏类型：未释放的对象本身，以及用于追踪这些对象的辅助数据结构产生的“陈旧”条目。通过模拟一系列内存分配和释放事件，你将学会量化不同类型的内存泄漏，为理解更复杂的场景打下坚实的基础。", "problem": "您将获得一个简化的、与语言无关的手动内存管理模型，该模型旨在捕获一种常见的数据结构泄漏模式：类构造函数会在一个全局静态映射中注册每个新构造对象的地址，但类析构函数不会移除该条目。在此模型中，每次成功的构造（分配）都会向一个全局静态注册表中插入一个条目，而每次成功的销毁都会释放对象的内存，但会留下一个过时的注册表条目。您的任务是实现一个算法，针对多个事件序列，计算每个序列的三个量：从未被销毁的对象仍在分配的字节数、由已销毁对象对应的过时全局映射条目泄漏的字节数，以及这两个量的总和。\n\n基本原理和定义：\n- 手动堆分配和释放遵循一个经过充分检验的规则，即分配会增加预留内存，而释放会减少预留内存。内存泄漏定义为程序终止时仍未释放的已分配内存。在本问题中，我们形式化了两种泄漏：\n  1) 对象泄漏：在序列结束时已分配但从未被销毁的对象。\n  2) 数据结构泄漏：本应由析构函数移除但未被移除，而留在全局静态注册表中的过时条目。\n- 设 $m$ 为每个注册表条目的固定开销（以字节为单位）。在本问题中，$m = 64$。\n- 每个事件是以下之一：\n  - ALLOC$(\\text{id}, s)$: 分配一个标识符为 $\\text{id}$、大小为 $s$ 字节的新对象。仅当 $\\text{id}$ 当前不处于活动状态时，此操作才有效。成功后，全局注册表会为此次分配存储一个条目，并且该对象以大小 $s$ 变为活动状态。\n  - DELETE$(\\text{id})$: 如果活动对象 $\\text{id}$ 处于活动状态，则销毁它。成功后，该对象的 $s$ 字节被释放，但由于析构函数未移除它，过时的注册表条目仍然存在。如果 $\\text{id}$ 不处于活动状态，则 DELETE 操作无效。\n- 设 $\\text{Alive}$ 为当前活动对象的集合。设 $s(x)$ 表示活动对象 $x \\in \\text{Alive}$ 的大小（以字节为单位）。设 $N_{\\text{stale}}$ 为事件序列中成功执行的 DELETE 操作次数（在此模型中，每次成功操作都对应一个过时的全局映射条目）。\n- 每个序列需要输出：\n  - 对象泄漏字节数：$L_{\\text{obj}} = \\sum_{x \\in \\text{Alive}} s(x)$。\n  - 数据结构泄漏字节数：$L_{\\text{map}} = m \\cdot N_{\\text{stale}}$。\n  - 总泄漏字节数：$L_{\\text{tot}} = L_{\\text{obj}} + L_{\\text{map}}$。\n- 所有输出都应表示为代表字节数的纯整数。\n\n用于测试的输入和事件语义：\n- 您无需读取输入。相反，您需要实现程序来评估以下六个测试序列。每个序列是一个事件列表，其中 ALLOC$(\\text{id}, s)$ 具有标识符 $\\text{id}$ 和大小 $s$ 字节，而 DELETE$(\\text{id})$ 仅具有标识符 $\\text{id}$。\n- 在所有情况下，固定的注册表条目成本为 $m = 64$。\n\n测试套件：\n1) 混合分配和删除的正常路径：\n   - 事件：ALLOC$(A, 100)$, ALLOC$(B, 200)$, DELETE$(A)$, ALLOC$(C, 50)$, DELETE$(C)$。\n2) 边界情况：空序列（无事件）。\n3) 删除后重用标识符：\n   - 事件：ALLOC$(X, 10)$, DELETE$(X)$, ALLOC$(X, 10)$。\n4) 仅分配，无删除：\n   - 事件：ALLOC$(A, 1)$, ALLOC$(B, 2)$, ALLOC$(C, 3)$。\n5) 多次删除和重新分配，以测试过时条目的累积：\n   - 事件：ALLOC$(D, 70)$, DELETE$(D)$, DELETE$(D)$, ALLOC$(E, 30)$, DELETE$(E)$, ALLOC$(E, 40)$, DELETE$(E)$。\n6) 边界情况：删除一个从未分配过的标识符：\n   - 事件：DELETE$(Z)$。\n\n算法要求：\n- 维护一个从活动标识符到其大小的映射。在执行 ALLOC$(\\text{id}, s)$ 时，当且仅当 $\\text{id}$ 尚不处于活动状态时才插入。在执行 DELETE$(\\text{id})$ 时，如果 $\\text{id}$ 处于活动状态，则移除它并将 $N_{\\text{stale}}$ 增加 1；否则，不执行任何操作。在序列末尾，使用上述公式计算 $L_{\\text{obj}}$、$L_{\\text{map}}$ 和 $L_{\\text{tot}}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身都是一个三整数列表 $[L_{\\text{obj}}, L_{\\text{map}}, L_{\\text{tot}}]$，按顺序对应每个测试序列的结果。例如：“[[a,b,c],[d,e,f],...]”，所有值都是以字节为单位的整数。", "solution": "问题陈述经验证是合理的。它提出了一个清晰、独立且逻辑一致的模型，用于在一个简化系统中分析两种特定类型的内存泄漏。定义、事件语义和所需计算都是明确且适定的，从而能够得出一个唯一且可验证的解。该模型是对计算机科学中（特别是在数据结构和算法领域）真实世界内存管理问题的有效抽象，并且不包含任何科学或事实上的缺陷。\n\n问题的核心是通过一系列离散事件来跟踪系统的状态。状态由两个部分定义：当前已分配（或称“活动”）对象的集合，以及由对象销毁所产生的过时注册表条目计数。该算法将处理给定序列中的每个事件，相应地更新状态，然后根据最终状态计算最终的泄漏指标。\n\n### 算法设计与状态管理\n\n对于每个测试序列，系统状态通过两个主要变量进行管理：\n1.  一个哈希映射（我们将其表示为 `alive_objects`），用于存储所有当前活动对象的标识符和大小。键是对象标识符（$\\text{id}$），值是其大小（$s$）。这种数据结构为插入、删除和查找操作提供了平均时间复杂度为 $O(1)$ 的性能，这对于此任务是最佳的。\n2.  一个整数计数器 $N_{\\text{stale}}$，初始化为 $0$，用于跟踪成功执行的 `DELETE` 操作次数。每次此类操作对应于全局注册表中的一个过时条目。\n\n每个注册表条目的固定开销是一个常量，$m = 64$ 字节。\n\n### 事件处理逻辑\n\n算法遍历序列中的每个事件，并应用以下规则：\n\n1.  **对于 `ALLOC$(\\text{id}, s)$` 事件：** 算法首先检查标识符 $\\text{id}$ 是否作为键存在于 `alive_objects` 映射中。\n    - 如果 $\\text{id}$ **不**存在，则分配成功。一个新条目被添加到映射中：`alive_objects[id] = s`。\n    - 如果 $\\text{id}$ 已经存在，根据问题描述（“仅当 $\\text{id}$ 当前不处于活动状态时，此操作才有效”），该事件无效，状态不发生改变。\n\n2.  **对于 `DELETE$(\\text{id})$` 事件：** 算法检查标识符 $\\text{id}$ 是否存在于 `alive_objects` 映射中。\n    - 如果 $\\text{id}$ 存在，则删除成功。该对象不再是活动的，因此其条目从 `alive_objects` 映射中移除。同时，由于有问题的析构函数在全局注册表中留下了一个过时条目，计数器 $N_{\\text{stale}}$ 增加 1。\n    - 如果 $\\text{id}$ 不存在，则该对象不处于活动状态，`DELETE` 操作无效。\n\n### 内存泄漏的最终计算\n\n在序列中的所有事件都处理完毕后，根据 `alive_objects` 和 $N_{\\text{stale}}$ 的最终状态计算所需的三个量：\n\n1.  **对象泄漏字节数 ($L_{\\text{obj}}$)：** 这是由已分配但从未被销毁的对象所消耗的内存。它是 `alive_objects` 映射中所有剩余对象大小的总和。\n    $$L_{\\text{obj}} = \\sum_{x \\in \\text{Alive}} s(x) = \\sum_{s_i \\in \\text{values(alive\\_objects)}} s_i$$\n    如果 `alive_objects` 为空，则 $L_{\\text{obj}} = 0$。\n\n2.  **数据结构泄漏字节数 ($L_{\\text{map}}$)：** 这是由全局注册表中的过时条目所消耗的内存。每次成功的删除都会产生一个大小为 $m$ 的过时条目。\n    $$L_{\\text{map}} = m \\cdot N_{\\text{stale}} = 64 \\cdot N_{\\text{stale}}$$\n\n3.  **总泄漏字节数 ($L_{\\text{tot}}$)：** 这是两种泄漏类型的总和。\n    $$L_{\\text{tot}} = L_{\\text{obj}} + L_{\\text{map}}$$\n\n### 示例追踪（测试用例 1）\n\n让我们用第一个测试序列来追踪算法：`ALLOC$(A, 100)$, ALLOC$(B, 200)$, DELETE$(A)$, ALLOC$(C, 50)$, DELETE$(C)$。\n- **初始状态：**`alive_objects` $= \\{\\}$, $N_{\\text{stale}} = 0$。\n- **事件 1：`ALLOC$(A, 100)$`**：`A` 不在 `alive_objects` 中。状态变为：`alive_objects` $= \\{'A': 100\\}$, $N_{\\text{stale}} = 0$。\n- **事件 2：`ALLOC$(B, 200)$`**：`B` 不在 `alive_objects` 中。状态变为：`alive_objects` $= \\{'A': 100, 'B': 200\\}$, $N_{\\text{stale}} = 0$。\n- **事件 3：`DELETE$(A)$`**：`A` 在 `alive_objects` 中。`A` 的条目被移除，$N_{\\text{stale}}$ 递增。状态变为：`alive_objects` $= \\{'B': 200\\}$, $N_{\\text{stale}} = 1$。\n- **事件 4：`ALLOC$(C, 50)$`**：`C` 不在 `alive_objects` 中。状态变为：`alive_objects` $= \\{'B': 200, 'C': 50\\}$, $N_{\\text{stale}} = 1$。\n- **事件 5：`DELETE$(C)$`**：`C` 在 `alive_objects` 中。`C` 的条目被移除，$N_{\\text{stale}}$ 递增。状态变为：`alive_objects` $= \\{'B': 200\\}$, $N_{\\text{stale}} = 2$。\n\n**最终计算：**\n- $L_{\\text{obj}} = s('B') = 200$ 字节。\n- $L_{\\text{map}} = 64 \\cdot N_{\\text{stale}} = 64 \\cdot 2 = 128$ 字节。\n- $L_{\\text{tot}} = 200 + 128 = 328$ 字节。\n此序列的结果是 $[200, 128, 328]$。对所有测试序列重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Processes several event sequences to calculate memory leak statistics\n    based on a simplified model of memory management.\n    \"\"\"\n    # The numpy import is included to adhere to the problem's specified execution\n    # environment, but is not functionally necessary for this solution as all\n    # calculations involve standard integer arithmetic.\n\n    # Define the test cases from the problem statement.\n    # Each event is represented as a tuple, e.g., ('ALLOC', 'ID', size)\n    # or ('DELETE', 'ID').\n    test_cases = [\n        # 1) Happy path with mixed allocations and deletions:\n        [('ALLOC', 'A', 100), ('ALLOC', 'B', 200), ('DELETE', 'A'), ('ALLOC', 'C', 50), ('DELETE', 'C')],\n        \n        # 2) Boundary: empty sequence (no events).\n        [],\n        \n        # 3) Reuse of identifiers after deletion:\n        [('ALLOC', 'X', 10), ('DELETE', 'X'), ('ALLOC', 'X', 10)],\n        \n        # 4) Only allocations, no deletions:\n        [('ALLOC', 'A', 1), ('ALLOC', 'B', 2), ('ALLOC', 'C', 3)],\n        \n        # 5) Multiple deletes and re-allocations stressing stale-entry accumulation:\n        [('ALLOC', 'D', 70), ('DELETE', 'D'), ('DELETE', 'D'), ('ALLOC', 'E', 30), ('DELETE', 'E'), ('ALLOC', 'E', 40), ('DELETE', 'E')],\n        \n        # 6) Boundary: delete of a never-allocated identifier:\n        [('DELETE', 'Z')],\n    ]\n\n    # Fixed overhead in bytes per stale registry entry.\n    m_overhead_per_entry = 64\n    \n    final_results = []\n\n    # Process each test sequence independently.\n    for event_sequence in test_cases:\n        # State variables for the current sequence.\n        # alive_objects maps an object's ID to its size.\n        alive_objects = {}\n        # n_stale counts the number of successful DELETE operations.\n        n_stale = 0\n        \n        # Process each event in the sequence.\n        for event in event_sequence:\n            event_type = event[0]\n            obj_id = event[1]\n\n            if event_type == 'ALLOC':\n                # An ALLOC is only valid if the ID is not currently alive.\n                if obj_id not in alive_objects:\n                    size = event[2]\n                    alive_objects[obj_id] = size\n            \n            elif event_type == 'DELETE':\n                # A DELETE only has an effect if the ID is currently alive.\n                if obj_id in alive_objects:\n                    # The object's memory is freed, so it's removed from the alive set.\n                    del alive_objects[obj_id]\n                    # The destructor faultily leaves a stale entry in the global map.\n                    n_stale += 1\n\n        # After processing all events, calculate the leak statistics.\n        \n        # Object leak: sum of sizes of all objects that were never destroyed.\n        l_obj = sum(alive_objects.values())\n        \n        # Data structure leak: total size of stale map entries.\n        l_map = m_overhead_per_entry * n_stale\n        \n        # Total leak: sum of object and data structure leaks.\n        l_tot = l_obj + l_map\n        \n        final_results.append([l_obj, l_map, l_tot])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3252070"}, {"introduction": "内存泄漏常常隐藏在复杂数据结构和语言特性的精妙细节之中。这个实践 [@problem_id:3251981] 模拟了一种在自定义的引用计数智能指针中出现的隐蔽泄漏，这种模式在 C++ 等语言中很常见。你将探索一个有缺陷的拷贝赋值运算符如何导致内存无法被释放，从而学会批判性地审视看似正确的资源管理代码。", "problem": "要求您形式化并分析一个受控的内存泄漏场景，该场景源于在一个标准向量内部使用的自定义智能指针中存在一个有缺陷的拷贝赋值运算符。您的任务是编写一个完整的、可运行的程序，该程序确定性地模拟以下语义，并为固定的测试套件生成指定的输出。\n\n考虑一个假设的自定义智能指针类型，它通过一个带有引用计数的控制块来管理堆分配。该向量将这些智能指针作为元素存储。以下基本定义适用：\n\n- 内存泄漏是指动态分配的块在程序执行结束时仍未被释放（在逻辑上程序无法访问）的情况。\n- 对于引用计数所有权，一个正确的拷贝赋值操作，在将源元素赋值给目标元素时，应首先递减目标当前块的引用计数，如果计数达到零则删除该块，然后递增源块的引用计数，最后使目标指向与源相同的块。\n- 拷贝构造应该只递增源的引用计数并指向同一个块；它不删除任何东西。\n- 元素的析构应该递减其块的引用计数，如果计数达到零则删除该块。\n\n在本练习中，您将模拟拷贝赋值运算符中的一个特定缺陷，该缺陷由向量内特定的赋值方向触发。该缺陷是：\n\n- 设向量表示为 $v$，其元素索引为 $0,1,2,\\dots$。当执行 $v[i] \\leftarrow v[j]$（拷贝赋值）时，如果在赋值时 $j  i$（即在同一向量中，源元素的索引严格小于目标元素的索引），那么有缺陷的运算符会：\n  - 递增源块的引用计数，\n  - 设置 $v[i]$ 指向源块，\n  - 但完全省略了对 $v[i]$ 先前持有的块进行递减操作。\n  这个疏忽导致了对前一个块的一次逻辑“释放”的泄漏，从而可能导致一个堆块在所有元素被销毁时都未被删除。\n- 如果 $j > i$，运算符行为正确：它会递减目标先前的块，若计数达到零则删除，然后递增源块并更新目标指针。\n- 如果 $j = i$，运算符是无操作（自赋值）。\n- 拷贝构造总是递增源的引用计数，并且不删除任何东西。\n- 析构总是递减所持有的块，并在计数达到零时将其删除。\n- “块删除”被建模为当且仅当一个块的引用计数因正确赋值或析构中的正确递减而变为零时发生。如果由于该缺陷，递减操作被跳过，该块的计数被人为地保持在较高水平，该块将在程序结束时保持分配状态，从而导致泄漏计数增加。\n\n您将编写一个程序，在引用计数和向量索引的层面上模拟这些规则。您不需要实际管理内存；相反，您的程序必须计算在每个测试用例结束时，向量被销毁后，有多少已分配的块仍未被删除（即引用计数严格为正）。每次 `push` 操作都会分配一个全新的块，其初始引用计数为 $1$。所有拷贝赋值 $v[i] \\leftarrow v[j]$ 都会根据上述有缺陷的运算符语义，将 $v[i]$ 别名到与 $v[j]$ 相同的块。\n\n您的程序应硬编码并执行以下测试套件。在每个测试用例中，向量开始时为空。操作以 `push(x)` 的形式表示，其中 `x` 是任意具体整数（实际数值与分配标识无关），`assign(i,j)` 表示根据上述规则求值的拷贝赋值 $v[i] \\leftarrow v[j]$。\n\n测试用例 1（展示从左到右赋值导致泄漏的正常路径）：\n- push$(10)$, push$(20)$, push$(30)$, push$(40)$\n- assign$(1,0)$, assign$(2,1)$, assign$(3,2)$\n\n测试用例 2（反向赋值，无泄漏）：\n- push$(10)$, push$(20)$, push$(30)$, push$(40)$\n- assign$(2,3)$, assign$(1,2)$, assign$(0,1)$\n\n测试用例 3（混合重复别名）：\n- push$(1)$, push$(2)$, push$(3)$\n- assign$(1,0)$, assign$(1,0)$, assign$(2,1)$\n\n测试用例 4（包含自赋值和单次泄漏）：\n- push$(5)$, push$(6)$, push$(7)$\n- assign$(0,0)$, assign$(2,1)$, assign$(2,0)$\n\n测试用例 5（边界情况：单个元素，仅自赋值）：\n- push$(42)$\n- assign$(0,0)$\n\n对于每个测试用例，在执行完所有操作后，通过按任意顺序析构其元素来模拟向量的销毁（根据上述规则，顺序不影响最终的泄漏计数）。当所有析构函数运行完毕后，一个块当且仅当其引用计数严格为正时，被认为是泄漏的。您的程序必须为每个测试用例计算泄漏块的总数，并将结果汇总到单行输出中。\n\n最终输出格式：\n- 您的程序应生成一行包含测试用例 1 到 5 的结果，格式为方括号内由逗号分隔的整数列表，例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$。", "solution": "用户提供的问题已经过验证，并被确定为计算机科学领域中一个有效且定义明确的问题，具体涉及内存管理、数据结构和算法。它为模拟由有缺陷的拷贝赋值运算符引起的内存泄漏场景提供了一套清晰、独立且逻辑一致的规则。\n\n该问题要求对引用计数的内存管理进行确定性模拟。一种自定义的智能指针类型，在存储于向量中时，其拷贝赋值运算符表现出一个缺陷。我们的任务是对该系统进行建模，执行一系列定义好的操作，并计算“泄漏”的内存块数量（即在所有程序对象被销毁后，引用计数为正的内存块）。\n\n为了形式化解决方案，我们将构建系统状态的模型，并定义该状态如何根据指定操作演变。\n\n**状态表示**\n\n系统在任何时间点的状态都可以由两个部分完全描述：\n1. 一个向量，表示为 $v$。该向量的元素 $v[i]$ 不直接存储数据，而是持有动态分配内存块的标识符。设 $v_i$ 是索引 $i$ 处的块标识符。\n2. 一个用于维护每个内存块引用计数的数据结构。我们可以将其建模为一个数组或映射 $C$，其中 $C_b$是标识符为 $b$ 的块的引用计数。\n\n块标识符是从 $0$ 开始的唯一整数。每次 `push` 操作都会分配一个新的块。\n\n**操作模拟**\n\n模拟通过执行一系列修改状态 $(v, C)$ 的操作来进行。\n\n**1. `push` 操作**\n`push(x)` 操作模拟分配一个新内存块，并将指向它的智能指针添加到向量的末尾。\n- 生成一个新的、唯一的块标识符 $b_{new}$。\n- 这个新块的引用计数被初始化为 $1$：$C_{b_{new}} \\leftarrow 1$。\n- 向量 $v$ 通过这个新的块标识符进行扩展。\n\n**2. `assign(i, j)` 操作**\n此操作模拟拷贝赋值 $v[i] \\leftarrow v[j]$。其行为取决于索引 $i$ 和 $j$ 之间的关系。\n- 设 $b_{src} = v_j$ 为源元素所指向块的标识符。\n- 设 $b_{dest\\_old} = v_i$ 为目标元素当前所指向块的标识符。\n\n规则如下：\n- **情况 $j = i$（自赋值）：** 该操作为无操作，状态 $(v, C)$ 保持不变。\n- **情况 $j > i$（正确赋值）：** 赋值运算符行为正确。\n    1. 目标先前持有的块的引用计数递减：$C_{b_{dest\\_old}} \\leftarrow C_{b_{dest\\_old}} - 1$。如果此计数变为 $0$，则该块被视为已释放。\n    2. 源块的引用计数递增：$C_{b_{src}} \\leftarrow C_{b_{src}} + 1$。\n    3. 目标元素 $v_i$ 更新为指向源块：$v_i \\leftarrow b_{src}$。\n- **情况 $j  i$（有缺陷的赋值）：** 运算符的缺陷被触发。\n    1. 源块的引用计数递增：$C_{b_{src}} \\leftarrow C_{b_{src}} + 1$。\n    2. 目标元素 $v_i$ 更新为指向源块：$v_i \\leftarrow b_{src}$。\n    3. 关键在于，对 $C_{b_{dest\\_old}}$ 的递减操作被 **省略** 了。这是内存泄漏的根源。最初位于 $v_i$ 的块的引用计数被人为地保持在较高水平，可能阻止其被释放。\n\n**终结与泄漏检测**\n\n在完成一个测试用例所有指定的 `push` 和 `assign` 操作后，我们模拟向量 $v$ 的销毁过程。这涉及到为其中的每个智能指针元素调用析构函数。\n- 对于向量最终状态中的每个元素 $v_k$，其析构函数会递减它所指向块的引用计数：$C_{v_k} \\leftarrow C_{v_k} - 1$。\n\n在此销毁阶段之后，一个内存块 $b$ 当且仅当其引用计数严格为正（即 $C_b > 0$）时，被认为是“泄漏”的。一个测试用例的泄漏块总数是所有此类块集合的基数：\n$$ \\text{Total Leaks} = \\left| \\{ b \\mid C_b > 0 \\} \\right| $$\n\n**示例演练：测试用例 1**\n- 操作：`push(10)`, `push(20)`, `push(30)`, `push(40)`; `assign(1,0)`, `assign(2,1)`, `assign(3,2)`。\n- **push 操作后**：\n    - $v = [0, 1, 2, 3]$\n    - $C = \\{C_0: 1, C_1: 1, C_2: 1, C_3: 1\\}$\n- **`assign(1,0)`**：$j=0  i=1$（有缺陷）。\n    - $b_{src}=0$， $b_{dest\\_old}=1$。\n    - $C_0 \\leftarrow C_0 + 1 = 2$。\n    - $v_1 \\leftarrow 0$。\n    - $C_1$ 未被递减。\n    - 状态：$v = [0, 0, 2, 3]$，$C=\\{C_0: 2, C_1: 1, C_2: 1, C_3: 1\\}$。块 $1$ 现在未被 $v$ 引用，但其计数为 $1$。\n- **`assign(2,1)`**：$j=1  i=2$（有缺陷）。\n    - $b_{src}=v_1=0$，$b_{dest\\_old}=2$。\n    - $C_0 \\leftarrow C_0 + 1 = 3$。\n    - $v_2 \\leftarrow 0$。\n    - $C_2$ 未被递减。\n    - 状态：$v = [0, 0, 0, 3]$，$C=\\{C_0: 3, C_1: 1, C_2: 1, C_3: 1\\}$。块 $2$ 现在未被 $v$ 引用，但其计数为 $1$。\n- **`assign(3,2)`**：$j=2  i=3$（有缺陷）。\n    - $b_{src}=v_2=0$，$b_{dest\\_old}=3$。\n    - $C_0 \\leftarrow C_0 + 1 = 4$。\n    - $v_3 \\leftarrow 0$。\n    - $C_3$ 未被递减。\n    - 状态：$v = [0, 0, 0, 0]$，$C=\\{C_0: 4, C_1: 1, C_2: 1, C_3: 1\\}$。块 $3$ 现在未被 $v$ 引用，但其计数为 $1$。\n- **销毁**：$v$ 中的 4 个元素都指向块 $0$。\n    - $C_0$ 被递减 4 次，所以 $C_0 \\leftarrow 4 - 4 = 0$。\n- **最终计数**：$C=\\{C_0: 0, C_1: 1, C_2: 1, C_3: 1\\}$。\n- **泄漏计数**：块 $1$、 $2$ 和 $3$ 的计数大于 $0$。泄漏总数为 $3$。\n\n通过将这种精确的模拟逻辑应用于每个测试用例，我们可以确定性地计算出所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_suite = [\n        # Test Case 1: happy path showing leaks due to left-to-right assignments\n        [\n            ('push', 10), ('push', 20), ('push', 30), ('push', 40),\n            ('assign', 1, 0), ('assign', 2, 1), ('assign', 3, 2)\n        ],\n        # Test Case 2: reverse-direction assignments, no leaks\n        [\n            ('push', 10), ('push', 20), ('push', 30), ('push', 40),\n            ('assign', 2, 3), ('assign', 1, 2), ('assign', 0, 1)\n        ],\n        # Test Case 3: mixture with repeated aliasing\n        [\n            ('push', 1), ('push', 2), ('push', 3),\n            ('assign', 1, 0), ('assign', 1, 0), ('assign', 2, 1)\n        ],\n        # Test Case 4: includes self-assignment and a single leak\n        [\n            ('push', 5), ('push', 6), ('push', 7),\n            ('assign', 0, 0), ('assign', 2, 1), ('assign', 2, 0)\n        ],\n        # Test Case 5: boundary: single element, self-assignment only\n        [\n            ('push', 42),\n            ('assign', 0, 0)\n        ]\n    ]\n\n    results = []\n    for operations in test_suite:\n        num_leaks = simulate_memory_leak(operations)\n        results.append(num_leaks)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_memory_leak(operations):\n    \"\"\"\n    Simulates the memory leak scenario for a given set of operations.\n\n    Args:\n        operations (list): A list of tuples, where each tuple represents an operation.\n                           e.g., ('push', 10) or ('assign', 1, 0).\n\n    Returns:\n        int: The total number of leaked blocks.\n    \"\"\"\n    # v is the vector, storing integer identifiers for memory blocks.\n    v = []\n    # ref_counts stores the reference count for each block.\n    # The index of the list is the block identifier.\n    ref_counts = []\n    next_block_id = 0\n\n    for op, *args in operations:\n        if op == 'push':\n            # A push operation allocates a new block with ref count 1.\n            v.append(next_block_id)\n            ref_counts.append(1)\n            next_block_id += 1\n        elif op == 'assign':\n            i, j = args\n\n            # Self-assignment is a no-op.\n            if i == j:\n                continue\n\n            src_block_id = v[j]\n            dest_block_id_old = v[i]\n            \n            if j  i:\n                # Flawed assignment: increment source, but DO NOT decrement destination's old block.\n                # This is the source of the memory leak.\n                ref_counts[src_block_id] += 1\n                v[i] = src_block_id\n            else:  # j  i\n                # Correct assignment: decrement old, increment new.\n                ref_counts[dest_block_id_old] -= 1\n                ref_counts[src_block_id] += 1\n                v[i] = src_block_id\n\n    # After all operations, simulate the destruction of the vector.\n    # Each element's destructor decrements the reference count of the block it holds.\n    for block_id in v:\n        ref_counts[block_id] -= 1\n\n    # A block is leaked if its reference count is  0 after all destructors have run.\n    # The problem requires numpy, so we use it for the final count.\n    if not ref_counts:\n        return 0\n    \n    ref_counts_np = np.array(ref_counts, dtype=np.int32)\n    num_leaks = np.sum(ref_counts_np  0)\n    \n    return int(num_leaks)\n\nsolve()\n```", "id": "3251981"}, {"introduction": "在大型软件项目中，知道存在内存泄漏只是第一步，找到其根源才是真正的挑战。本练习 [@problem_id:3252039] 通过分析分配事件的调用栈，向你介绍内存分析 (profiling) 的概念。你将实现一个算法来定位泄漏的“精准源头”，这项技术与现代调试工具帮助开发者高效修复内存问题的工作原理如出一辙。", "problem": "给定一个程序中手动内存管理和调用栈的形式化模型。一个分配事件记录一个对象标识符、一个字节数以及一个调用栈签名，该签名表示为由整数编码的函数标识符组成的有限序列。一个释放事件记录一个对象标识符。程序在某个最终时刻终止。内存泄漏是指在最终时刻之前，任何没有与相应释放事件配对的分配。目标是设计并实现一个算法，用于剖析泄漏内存的来源，该来源被定义为其后代共同占泄漏字节数量最多的调用栈前缀，以便精确定位泄漏最有可能源自何处。\n\n从以下基本基础开始：\n- 手动内存管理使用分配和释放操作。分配操作为对象保留内存并记录元数据。释放操作解除该保留。在终止前任何未被后续释放操作处理的分配都被视为泄漏。\n- 分配发生时的调用栈是一个由整数编码的函数标识符组成的有限序列（栈顶帧在前）。该序列表示导致分配的控制路径。\n- 对序列的前缀进行聚合是在层级数据中进行责任归属的标准方法：一个前缀会累积所有以该前缀开头的序列的数量。\n\n定义和要求：\n- 设事件日志为事件的有限序列 $E$。一个分配事件是一个元组 $(\\text{alloc}, o, b, s)$，其中 $o$ 是对象标识符， $b$ 是字节数， $s = \\langle f_1, f_2, \\dots, f_m \\rangle$ 是调用栈签名，其中 $m \\ge 1$，每个 $f_i$ 都是一个整数。一个释放事件是 $(\\text{free}, o)$。\n- 设 $T$ 表示程序终止。定义泄漏分配的集合 $L$ 为 $E$ 中所有的分配 $(o,b,s)$，使得在该分配之后、在 $T$ 之前没有出现相应的释放 $(\\text{free}, o)$。\n- 对于任何非空前缀 $p = \\langle f_1, \\dots, f_k \\rangle$，其中 $1 \\le k \\le m$，将归属于 $p$ 的聚合泄漏字节数定义为\n$$\nB(p) \\;=\\; \\sum_{(o,b,s) \\in L \\;:\\; s \\text{ begins with } p} \\; b.\n$$\n- 定义 pinpoint 来源 $p^\\star$ 为使 $B(p)$ 最大化的任意非空前缀。如果出现平局，选择长度 $k$ 最小的那个。如果仍然平局，选择字典序最小的序列（整数序列的标准字典序）。\n- 如果 $L$ 为空，则定义 pinpoint 来源为空列表。\n\n你的任务是：\n- 实现一个程序，该程序在给定一组固定的事件日志测试套件时，根据上述定义为每个测试用例计算 pinpoint 来源 $p^\\star$。\n\n约束和假设：\n- 对于并发活动的分配，对象标识符是唯一的。每个 $(\\text{free}, o)$ 会匹配 $E$ 中最近的未匹配的 $(\\text{alloc}, o, b, s)$（如果存在）。事件序列是格式正确的，不包含对同一 $o$ 的重复分配而中间没有 $(\\text{free}, o)$ 的情况。\n- 调用栈是整数的非空有限序列。\n\n测试套件：\n- 测试用例 1：\n  - 事件：$(\\text{alloc}, 1, 100, \\langle 10, 20, 30 \\rangle)$，$(\\text{alloc}, 2, 200, \\langle 10, 21 \\rangle)$，$(\\text{free}, 1)$，$(\\text{alloc}, 3, 300, \\langle 11, 20 \\rangle)$，然后是 $T$。\n- 测试用例 2：\n  - 事件：$(\\text{alloc}, 1, 50, \\langle 1 \\rangle)$，$(\\text{free}, 1)$，然后是 $T$。\n- 测试用例 3：\n  - 事件：$(\\text{alloc}, 1, 100, \\langle 5, 1 \\rangle)$，$(\\text{alloc}, 2, 100, \\langle 5, 1, 2 \\rangle)$，然后是 $T$。\n- 测试用例 4：\n  - 事件：$(\\text{alloc}, 1, 150, \\langle 7, 10 \\rangle)$，$(\\text{alloc}, 2, 150, \\langle 7, 11 \\rangle)$，$(\\text{alloc}, 3, 300, \\langle 8, 9 \\rangle)$，然后是 $T$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含四个测试用例的 pinpoint 来源，形式为用方括号括起来的逗号分隔列表，其中每个来源本身呈现为整数列表（空来源呈现为空列表），例如 $[\\,[\\,], [1], [2,3]\\,]$。具体到本问题，程序必须以这种单行格式输出为四个给定测试用例计算出的来源。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上植根于计算机科学的原理，特别是内存剖析和算法分析。该问题是适定的，提供了一套形式化、客观且自洽的定义和约束，对任何给定的输入都能唯一确定一个解。它没有逻辑矛盾、歧义或事实错误。\n\n任务是从分配和释放事件的日志中识别内存泄漏的“pinpoint 来源”$p^\\star$。一个分配事件由 $(\\text{alloc}, o, b, s)$ 给出，其中 $o$ 是对象标识符， $b$ 是分配的字节数， $s = \\langle f_1, f_2, \\dots, f_m \\rangle$ 是调用栈签名。一个释放事件是 $(\\text{free}, o)$。如果一个对象 $o$ 的分配在程序终止 $T$ 之前没有被后续的释放操作匹配，则发生内存泄漏。pinpoint 来源 $p^\\star$ 是与泄漏内存总字节数最大值相关联的非空调用栈前缀，并有特定的平局决胜规则。\n\n解决方案系统地分三个阶段构建：\n1.  **识别泄漏的分配**：首先，我们必须识别所有泄漏分配的集合 $L$。这通过按时间顺序处理事件日志来实现。使用一个哈希映射（字典）来跟踪当前活跃的分配，将每个对象标识符 $o$ 映射到其分配细节 $(b, s)$。\n    -   当遇到一个分配事件 $(\\text{alloc}, o, b, s)$ 时，在映射中为 $o$ 添加一个条目。\n    -   当遇到一个释放事件 $(\\text{free}, o)$ 时，从映射中删除对应的 $o$ 的条目，表示该内存已被释放。\n    -   在处理完所有事件直到终止 $T$ 后，映射中任何剩余的条目都对应于泄漏的分配。集合 $L$ 由这些剩余条目的元组 $(o, b, s)$ 组成。\n\n2.  **在调用栈前缀上聚合泄漏字节**：在识别出泄漏分配的集合 $L$ 之后，下一步是为 $L$ 中每个调用栈 $s$ 的每个非空前缀 $p$ 计算聚合的泄漏字节数 $B(p)$。数量 $B(p)$ 定义为：\n    $$\n    B(p) \\;=\\; \\sum_{(o,b,s) \\in L \\;:\\; s \\text{ begins with } p} \\; b.\n    $$\n    这种聚合可以使用一个哈希映射高效地执行，其中键是表示前缀的元组，值是累积的字节数。对于每个泄漏的分配 $(o, b, s)$，我们遍历其所有非空前缀 $p_k = \\langle f_1, \\dots, f_k \\rangle$（其中 $k=1, \\dots, m$）。对于每个这样的前缀 $p_k$，我们将字节数 $b$ 添加到我们的聚合映射中相应的条目。\n\n3.  **确定 Pinpoint 来源 ($p^\\star$)**：最后一个阶段是从计算出的前缀聚合中找到 pinpoint 来源 $p^\\star$。问题将 $p^\\star$ 定义为使 $B(p)$ 最大化的前缀，并按以下优先顺序应用平局决胜规则：\n    1.  $B(p)$ 的最大值。\n    2.  最小的前缀长度。\n    3.  字典序最小的前缀序列。\n\n    如果泄漏集合 $L$ 为空，则 $p^\\star$ 定义为空列表。否则，我们可以为聚合映射中的每个前缀 $p$ 构建一个候选元组列表 $(B(p), \\text{length}(p), p)$。通过对此列表进行排序，我们可以系统地应用选择标准。主排序键是 $B(p)$（降序）。次排序键是 $\\text{length}(p)$（升序）。第三排序键是前缀 $p$ 本身，按标准字典序升序排序。排序后列表的第一个元素的前缀就是所求的 pinpoint 来源 $p^\\star$。\n\n这种有原则的方法保证了根据问题的形式化定义正确识别 $p^\\star$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the pinpoint memory leak origin for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each event is a tuple. For allocations: ('alloc', obj_id, bytes, stack_tuple).\n    # For deallocations: ('free', obj_id).\n    test_cases = [\n        # Test case 1\n        [\n            ('alloc', 1, 100, (10, 20, 30)),\n            ('alloc', 2, 200, (10, 21)),\n            ('free', 1),\n            ('alloc', 3, 300, (11, 20)),\n        ],\n        # Test case 2\n        [\n            ('alloc', 1, 50, (1,)),\n            ('free', 1),\n        ],\n        # Test case 3\n        [\n            ('alloc', 1, 100, (5, 1)),\n            ('alloc', 2, 100, (5, 1, 2)),\n        ],\n        # Test case 4\n        [\n            ('alloc', 1, 150, (7, 10)),\n            ('alloc', 2, 150, (7, 11)),\n            ('alloc', 3, 300, (8, 9)),\n        ]\n    ]\n\n    def find_pinpoint_origin(events):\n        \"\"\"\n        Analyzes an event log to find the pinpoint origin of memory leaks.\n        \"\"\"\n        # Step 1: Identify Leaked Allocations\n        active_allocations = {}\n        for event in events:\n            event_type = event[0]\n            obj_id = event[1]\n            if event_type == 'alloc':\n                # event is ('alloc', obj_id, bytes, stack)\n                alloc_bytes = event[2]\n                stack = event[3]\n                active_allocations[obj_id] = {'bytes': alloc_bytes, 'stack': stack}\n            elif event_type == 'free':\n                # event is ('free', obj_id)\n                if obj_id in active_allocations:\n                    del active_allocations[obj_id]\n\n        leaked_allocations = list(active_allocations.values())\n        \n        # If there are no leaks, the pinpoint origin is the empty list.\n        if not leaked_allocations:\n            return []\n\n        # Step 2: Aggregate Leaked Bytes over Call Stack Prefixes\n        prefix_bytes = {}\n        for leak in leaked_allocations:\n            leak_bytes = leak['bytes']\n            stack = leak['stack']\n            # Generate all non-empty prefixes for the current stack\n            for i in range(1, len(stack) + 1):\n                prefix = stack[:i]\n                prefix_bytes[prefix] = prefix_bytes.get(prefix, 0) + leak_bytes\n\n        # Step 3: Determine the Pinpoint Origin\n        # Create a list of candidates to sort.\n        # Each candidate is a tuple: (bytes, prefix_length, prefix)\n        candidates = [\n            (byte_sum, len(prefix), prefix)\n            for prefix, byte_sum in prefix_bytes.items()\n        ]\n\n        # Sort candidates based on the specified tie-breaking rules:\n        # 1. Bytes (descending)\n        # 2. Prefix length (ascending)\n        # 3. Prefix (lexicographically ascending)\n        # Python's tuple sorting handles lexicographical order correctly.\n        # A negative sign on the byte_sum achieves descending order.\n        candidates.sort(key=lambda x: (-x[0], x[1], x[2]))\n\n        # The best prefix is the one from the top-ranked candidate.\n        best_prefix = candidates[0][2]\n        \n        return list(best_prefix)\n\n    results = []\n    for case in test_cases:\n        result = find_pinpoint_origin(case)\n        results.append(result)\n\n    # The final print statement must produce the exact single-line format.\n    # `str(list)` generates spaces, e.g., `[1, 2]`. The f-string joins these\n    # string representations with a comma, resulting in `[1, 2],[3, 4]`.\n    # Using `str(results).replace(' ', '')` ensures no spaces in the output.\n    final_output = str(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```", "id": "3252039"}]}