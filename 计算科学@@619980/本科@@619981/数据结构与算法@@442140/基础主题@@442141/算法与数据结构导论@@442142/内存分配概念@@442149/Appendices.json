{"hands_on_practices": [{"introduction": "本练习将带你探索内存分配器的基本决策过程：如何为新的数据块选择存放位置。我们将通过一个仓库物流的类比，模拟两种经典的分配策略——首次适应（First-Fit）与最佳适应（Best-Fit）。通过比较它们的分配结果，你将直观地理解不同的放置策略如何影响内存利用率和内部碎片。[@problem_id:3251611]", "problem": "考虑一个由非负整数容量序列 $S = (s_1, s_2, \\dots, s_n)$ 表示的有限货架集合，以及一个由非负整数尺寸序列 $P = (p_1, p_2, \\dots, p_m)$ 表示的托盘序列。每个货架最多能容纳一个托盘。一个尺寸为 $p_j$ 的托盘能放入容量为 $s_i$ 的货架中，当且仅当 $s_i \\ge p_j$。一旦一个托盘被放入货架，该货架就不可用于任何其他托盘。将托盘 $p_j$ 放入货架 $s_i$ 所产生的内部碎片定义为 $s_i - p_j$。如果没有可用货架的容量至少为 $p_j$，则托盘 $p_j$ 的分配失败。\n\n现有两种分配策略需要比较：\n\n- 首次适应（First-fit）：对序列中的每个托盘 $p_j$（按 $j = 1, 2, \\dots, m$ 的顺序），按递增的索引顺序 $i = 1, 2, \\dots, n$ 扫描货架，并将 $p_j$ 放入第一个满足 $s_i \\ge p_j$ 的可用货架中。\n- 最佳适应（Best-fit）：对序列中的每个托盘 $p_j$（按 $j = 1, 2, \\dots, m$ 的顺序），在所有满足 $s_i \\ge p_j$ 的可用货架中，选择容量 $s_i$ 最小的货架；如果出现平局，则选择索引最小的货架。\n\n从序列处理和确定性选择规则的核心定义出发，且不假定任何已有的专用公式，推导出一个程序化模拟。该模拟针对每个给定的测试用例，在相同的输入 $(S, P)$ 上执行这两种策略，并报告每种策略的以下整数指标：\n- 成功分配的托盘数量，记为 $A$。\n- 分配失败的次数，记为 $F$。\n- 总内部碎片，记为 $W$，其计算方式为对该策略下所有已分配的配对求和 $\\sum (s_i - p_j)$。\n\n你的程序必须严格按照定义实现这两种策略，其中最佳适应策略的平局决胜规则是在最小容量相同时选择最小的索引。最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，按 $[A_{\\text{FF}}, F_{\\text{FF}}, W_{\\text{FF}}, A_{\\text{BF}}, F_{\\text{BF}}, W_{\\text{BF}}]$ 的顺序附加六个整数，其中下标 $\\text{FF}$ 和 $\\text{BF}$ 分别表示首次适应和最佳适应。将所有测试用例的结果连接成一个扁平列表，并保持测试用例的顺序。\n\n使用以下测试套件，其旨在探查分配行为的不同方面：\n- 测试用例 1：$S = [9,8,10]$, $P = [8,10,9]$（因货架顺序和平局决胜导致策略差异）。\n- 测试用例 2：$S = [5,5,5]$, $P = [5,5,5,5]$（边界情况，精确匹配且托盘多于货架）。\n- 测试用例 3：$S = [4,4]$, $P = [5,6]$（所有托盘都太大）。\n- 测试用例 4：$S = [12,3]$, $P = []$（空托盘序列）。\n- 测试用例 5：$S = [5,9,6]$, $P = [6,5,9]$（因未来的精确匹配导致策略差异）。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，整数需严格按照指定顺序排列，且不含任何额外文本。", "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个定义明确的模拟任务，其根植于计算机科学的基本概念，特别是确定性资源分配算法。该问题是自洽的、逻辑一致且无歧义的。\n\n这个问题的核心是模拟两种不同的内存分配策略——首次适应和最佳适应，并将其应用于一组离散的资源（货架）和请求（托盘）。我们将为每次模拟正式推导步骤，然后实现它们以计算所需的性能指标。\n\n设货架容量集合由序列 $S = (s_1, s_2, \\dots, s_n)$ 表示，其中 $n$ 是货架数量，$s_i \\in \\mathbb{Z}_{\\ge 0}$ 是第 $i$ 个货架的容量。设托盘尺寸集合由序列 $P = (p_1, p_2, \\dots, p_m)$ 表示，其中 $m$ 是托盘数量，$p_j \\in \\mathbb{Z}_{\\ge 0}$ 是第 $j$ 个托盘的尺寸。\n\n系统状态可以通过一个布尔可用性向量 $U = (u_1, u_2, \\dots, u_n)$ 来跟踪，其中如果货架 $i$ 可用，则 $u_i = 1$，如果被占用，则 $u_i = 0$。最初，所有货架都可用，因此对于所有 $i \\in \\{1, 2, \\dots, n\\}$，有 $u_i = 1$。\n\n对于每种策略，我们将按给定顺序（从 $j=1$ 到 $m$）处理托盘。每种策略需要计算的指标如下：\n- $A$：成功分配的托盘总数。\n- $F$：分配失败的总次数。\n- $W$：总内部碎片，定义为所有已分配配对 $(p_j, s_{i^*})$ 的 $(s_{i^*} - p_j)$ 之和，即 $W = \\sum (s_{i^*} - p_j)$。\n\n**1. 首次适应（FF）策略**\n\n首次适应算法是一种顺序搜索启发式算法。对于每个托盘 $p_j$，我们从第一个货架到最后一个货架进行扫描，并将该托盘放入第一个足够大的货架中。\n\n对每个 $j \\in \\{1, 2, \\dots, m\\}$，该算法按以下步骤进行：\n- 初始化一个标志位 `placed_j = false`。\n- 遍历索引从 $1$ 到 $n$ 的货架。\n- 在每个货架 $i$ 处，检查两个条件：\n    1. 货架可用：$u_i = 1$。\n    2. 货架容量足够：$s_i \\ge p_j$。\n- 如果两个条件都满足，则这就是首次适应的货架。我们执行分配：\n    - 将此货架指定为选定的货架：$i^* = i$。\n    - 通过将该货架标记为已占用来更新系统状态：$u_{i^*} \\leftarrow 0$。\n    - 增加已分配托盘计数：$A \\leftarrow A + 1$。\n    - 将产生的内部碎片加到总和中：$W \\leftarrow W + (s_{i^*} - p_j)$。\n    - 设置 `placed_j = true` 并中断关于 $i$ 的内部循环，继续处理下一个托盘 $p_{j+1}$。\n- 如果遍历所有货架 $i$ 的循环完成且 `placed_j` 仍为 `false`，则表示没有找到合适的货架。托盘 $p_j$ 的分配失败。\n- 增加失败计数：$F \\leftarrow F + 1$。\n\n对所有托盘重复此过程。模拟的初始状态为 $A=0$, $F=0$, $W=0$，以及对所有 $i$ 都有 $u_i=1$。\n\n**2. 最佳适应（BF）策略**\n\n最佳适应算法试图更有效地利用空间。对于每个托盘 $p_j$，它会搜索所有可用的货架，以找到最紧密贴合该托盘的货架，即容量足够大但又是最小的那个。该策略旨在为未来可能出现的更大托盘保留大容量货架。\n\n对每个 $j \\in \\{1, 2, \\dots, m\\}$，该算法按以下步骤进行：\n- 识别所有既可用又容量充足的候选货架集合 $C_j$：\n$$ C_j = \\{ i \\in \\{1, \\dots, n\\} \\mid u_i = 1 \\land s_i \\ge p_j \\} $$\n- 如果这个集合 $C_j$ 为空，则无法为托盘 $p_j$ 进行分配。\n    - 增加失败计数：$F \\leftarrow F + 1$。\n- 如果 $C_j$ 非空，则必须选择一个最佳适应的货架。\n    - 首先，在所有候选货架中找到最小容量：\n    $$ s_{\\min} = \\min_{i \\in C_j} \\{s_i\\} $$\n    - 接下来，识别具有此最小容量的候选子集 $B_j \\subseteq C_j$：\n    $$ B_j = \\{ i \\in C_j \\mid s_i = s_{\\min} \\} $$\n    - 问题提供了平局决胜规则：如果多个货架具有相同的最小容量 $s_{\\min}$，则选择索引最小的那个。\n    $$ i^* = \\min_{i \\in B_j} \\{i\\} $$\n    - 将托盘 $p_j$ 分配给货架 $s_{i^*}$。\n    - 更新系统状态：$u_{i^*} \\leftarrow 0$。\n    - 增加已分配托盘计数：$A \\leftarrow A + 1$。\n    - 将碎片加到总和中：$W \\leftarrow W + (s_{i^*} - p_j)$。\n\n对所有托盘重复此过程，从与首次适应模拟相同的初始状态（$A=0, F=0, W=0, u_i=1$）开始。\n\n**实现设计**\n\n一个程序化的解决方案将包含两个不同的函数，每种策略一个。每个函数将接收货架容量 $S$ 和托盘尺寸 $P$ 作为输入。在每个函数内部，将初始化一个与 $U$ 对应的可用性数组。然后，该函数将遍历所有托盘，应用各自的逻辑来寻找货架或声明失败，并更新指标 $A$、$F$ 和 $W$。最后，该函数将返回这三个指标。主程序将对每个测试用例执行这两个函数，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef first_fit_strategy(shelves, pallets):\n    \"\"\"\n    Simulates the first-fit allocation strategy.\n\n    Args:\n        shelves (list): A list of nonnegative integer shelf capacities.\n        pallets (list): A list of nonnegative integer pallet sizes.\n\n    Returns:\n        tuple: A tuple containing (A, F, W) where A is the number of\n               allocations, F is the number of failures, and W is the\n               total internal fragmentation.\n    \"\"\"\n    num_shelves = len(shelves)\n    available_shelves = np.ones(num_shelves, dtype=bool)\n    \n    allocated_count = 0\n    failed_count = 0\n    total_fragmentation = 0\n\n    for pallet_size in pallets:\n        pallet_placed = False\n        for i in range(num_shelves):\n            if available_shelves[i] and shelves[i] >= pallet_size:\n                # Place the pallet in the first available-and-fitting shelf\n                available_shelves[i] = False\n                allocated_count += 1\n                total_fragmentation += shelves[i] - pallet_size\n                pallet_placed = True\n                break  # Move to the next pallet\n        \n        if not pallet_placed:\n            failed_count += 1\n            \n    return allocated_count, failed_count, total_fragmentation\n\ndef best_fit_strategy(shelves, pallets):\n    \"\"\"\n    Simulates the best-fit allocation strategy.\n\n    Args:\n        shelves (list): A list of nonnegative integer shelf capacities.\n        pallets (list): A list of nonnegative integer pallet sizes.\n\n    Returns:\n        tuple: A tuple containing (A, F, W) where A is the number of\n               allocations, F is the number of failures, and W is the\n               total internal fragmentation.\n    \"\"\"\n    num_shelves = len(shelves)\n    available_shelves = np.ones(num_shelves, dtype=bool)\n\n    allocated_count = 0\n    failed_count = 0\n    total_fragmentation = 0\n\n    for pallet_size in pallets:\n        best_shelf_index = -1\n        # Using a large number for initial minimum capacity\n        min_capacity = float('inf')\n\n        for i in range(num_shelves):\n            if available_shelves[i] and shelves[i] >= pallet_size:\n                # Found a potential shelf. Check if it's a better fit.\n                if shelves[i]  min_capacity:\n                    min_capacity = shelves[i]\n                    best_shelf_index = i\n        \n        if best_shelf_index != -1:\n            # A best-fit shelf was found, place the pallet\n            available_shelves[best_shelf_index] = False\n            allocated_count += 1\n            total_fragmentation += shelves[best_shelf_index] - pallet_size\n        else:\n            # No suitable shelf found\n            failed_count += 1\n\n    return allocated_count, failed_count, total_fragmentation\n\ndef solve():\n    \"\"\"\n    Runs the allocation simulations for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: S = [9,8,10], P = [8,10,9]\n        ([9, 8, 10], [8, 10, 9]),\n        # Test case 2: S = [5,5,5], P = [5,5,5,5]\n        ([5, 5, 5], [5, 5, 5, 5]),\n        # Test case 3: S = [4,4], P = [5,6]\n        ([4, 4], [5, 6]),\n        # Test case 4: S = [12,3], P = []\n        ([12, 3], []),\n        # Test case 5: S = [5,9,6], P = [6,5,9]\n        ([5, 9, 6], [6, 5, 9]),\n    ]\n\n    all_results = []\n    for s_capacities, p_sizes in test_cases:\n        # Each strategy must run on a fresh set of shelves\n        shelves_copy = list(s_capacities)\n        pallets_copy = list(p_sizes)\n        \n        # Run first-fit\n        ff_results = first_fit_strategy(shelves_copy, pallets_copy)\n        all_results.extend(ff_results)\n        \n        # Run best-fit\n        bf_results = best_fit_strategy(shelves_copy, pallets_copy)\n        all_results.extend(bf_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3251611"}, {"introduction": "在掌握了基本放置策略之后，本练习将深入探讨现实世界系统中更复杂、结构化的分配方案：伙伴系统（Buddy System）和分离空闲链表（Segregated Free List）。你将通过计算内存开销，特别是分配器元数据和内部碎片之间的权衡，来量化并比较它们的性能。这种分析对于理解为何在特定性能关键型应用中选择某种分配器至关重要。[@problem_id:3251579]", "problem": "您的任务是实现一个自包含程序，该程序为两种分配策略（伙伴系统和分离空闲链表）量化并比较由分配器元数据与内部碎片造成的总内存开销。该程序必须使用测试套件中提供的参数集，并在无需用户输入的情况下产生结果。此比较必须基于内存管理的核心定义和对齐规则，而非临时构建的公式。\n\n从以下基本基础和核心定义开始：\n- 在动态内存分配器中，每个分配的块都带有分配器元数据。设每个块的分配器头部为 $h$ 字节。对于一个请求 $r$ 字节有效载荷的请求，分配器必须在堆上提供一个总大小为 $s$ 字节的块。元数据开销是所有已分配块的 $h$ 之和；内部碎片是所有已分配块的 $s - h - r$ 之和，这是在计入头部后块内未使用的、可存放有效载荷的空间。\n- 伙伴系统返回大小为2的幂的块。具体来说，块大小必须是不小于总大小需求的最小2的幂，并受最小块大小约束。如果小于需求的最小2的幂太小，无法容纳 $r + h$，则选择下一个更大的2的幂。设伙伴系统的最小块大小为 $B_{\\min}$ 字节。\n- 分离空闲链表（SFL）分配器根据预定义的大小类（桶）返回块。在本问题中，桶是某个量子大小的均匀倍数。设该量子为 $q$ 字节，允许的桶大小范围从 $L_{\\min}$ 到 $L_{\\max}$（含两端）。SFL选择的块大小是该范围内不小于总大小需求的最小桶大小。\n\n您的程序必须在每个给定的测试用例中，为每个分配请求 $r$ 按如下方式实现这两种分配策略：\n- 计算伙伴系统的块大小 $s_{\\mathrm{buddy}}}$，其值为大于或等于 $\\max(r + h, B_{\\min})$ 的最小2的幂。然后计算单次请求的内部碎片 $f_{\\mathrm{buddy}} = s_{\\mathrm{buddy}} - h - r$。每次请求的元数据开销为 $h$。\n- 计算SFL的块大小 $s_{\\mathrm{SFL}}}$，其值为闭区间 $\\left[L_{\\min}, L_{\\max}\\right]$ 中大于或等于 $\\max(r + h, L_{\\min})$ 的最小 $q$ 的倍数。然后计算单次请求的内部碎片 $f_{\\mathrm{SFL}} = s_{\\mathrm{SFL}} - h - r$。每次请求的元数据开销为 $h$。\n\n对于每个测试用例中的每个分配器：\n- 总元数据开销是所有请求的 $\\sum h$。\n- 总内部碎片开销是所有请求的 $\\sum f$。\n- 总开销是元数据开销和内部碎片开销之和。\n- 验证容量可行性：分配的总堆内存占用是所选块大小的总和 $\\sum s$。此总和不得超过测试用例的内存容量 $M$。所有提供的测试用例均满足可行性；无需对不可行的情况进行特殊处理。\n\n单位：所有开销均以字节为单位报告。\n\n您的程序必须处理以下测试套件。每个测试用例指定了 $(M, B_{\\min}, h, q, L_{\\min}, L_{\\max}, R)$，其中 $R$ 是请求的有效载荷大小列表（以字节为单位）。\n\n- 测试用例 1 (通用混合大小):\n  - $M = 1024$\n  - $B_{\\min} = 16$\n  - $h = 8$\n  - $q = 16$\n  - $L_{\\min} = 16$\n  - $L_{\\max} = 256$\n  - $R = [13, 24, 7, 100, 33]$\n- 测试用例 2 (接近2的幂的边界对齐):\n  - $M = 2048$\n  - $B_{\\min} = 32$\n  - $h = 16$\n  - $q = 16$\n  - $L_{\\min} = 32$\n  - $L_{\\max} = 1024$\n  - $R = [32, 63, 64, 127, 128]$\n- 测试用例 3 (低于最小块的请求):\n  - $M = 512$\n  - $B_{\\min} = 64$\n  - $h = 8$\n  - $q = 32$\n  - $L_{\\min} = 64$\n  - $L_{\\max} = 256$\n  - $R = [1, 2, 3]$\n- 测试用例 4 (接近容量的重复大请求):\n  - $M = 4096$\n  - $B_{\\min} = 16$\n  - $h = 16$\n  - $q = 32$\n  - $L_{\\min} = 32$\n  - $L_{\\max} = 2048$\n  - $R = [1000, 1000, 1000]$\n\n最终输出格式规范：\n- 对于每个测试用例，按确切顺序计算六个以字节为单位的整数：伙伴系统总开销、伙伴系统元数据开销、伙伴系统内部碎片开销、SFL总开销、SFL元数据开销、SFL内部碎片开销。\n- 将所有测试用例的结果汇总到一行中，形式为用方括号括起来的逗号分隔列表。该列表通过连接测试用例1的六个整数，然后是测试用例2，然后是测试用例3，最后是测试用例4来展平。例如，输出必须看起来像 $[x_{1,1},x_{1,2},x_{1,3},x_{1,4},x_{1,5},x_{1,6},x_{2,1},\\dots,x_{4,6}]$，其中每个 $x_{i,j}$ 是一个以字节为单位的整数。", "solution": "问题在于量化和比较两种动态内存分配策略（伙伴系统和分离空闲链表（SFL））的内存开销。该分析基于分配器元数据和内部碎片的基本定义。\n\n首先，我们确立所提供的正式定义。设请求的有效载荷大小为 `$r$` 字节。分配器为每个块添加一个大小为 `$h$` 字节的元数据头部。单个请求从堆中需求的总大小为 `$d = r + h$`。分配器提供一个大小为 `$s \\ge d$` 的块。该块的开销由两部分组成：\n1.  元数据开销：头部的固定大小，`$h$`。\n2.  内部碎片：已分配块内的未使用空间，由 `$f = s - d = s - (r + h)$` 给出。\n\n一系列请求的总开销是这些单个组件的总和。对于一组 `$N$` 个请求，总元数据开销为 `$O_{meta} = \\sum_{i=1}^{N} h_i = N \\cdot h$`，总内部碎片为 `$O_{frag} = \\sum_{i=1}^{N} f_i$`。总内存开销为 `$O_{total} = O_{meta} + O_{frag}$`。\n\n问题的核心在于确定每种策略分配的块大小 `$s$`。\n\n**伙伴系统分配**\n伙伴系统分配大小为2的幂的块。对于给定的请求 `$r$`，分配器必须找到一个足够大的块来容纳有效载荷和头部，即 `$r+h$`。所选的块大小 `$s_{\\mathrm{buddy}}}$` 也必须至少为系统的最小块大小 `$B_{\\min}$`。因此，有效需求为 `$d_{\\mathrm{eff}} = \\max(r + h, B_{\\min})$`。分配的块大小是大于或等于 `$d_{\\mathrm{eff}}$` 的最小2的幂。这可以用数学方式表示为：\n$$s_{\\mathrm{buddy}} = 2^{\\lceil \\log_2(d_{\\mathrm{eff}}) \\rceil}$$\n以2为底的对数函数找到产生 `$d_{\\mathrm{eff}}$` 所需的精确（可能为小数）指数。向上取整函数 `$\\lceil \\cdot \\rceil$` 将此指数向上舍入到最接近的整数，这保证了当用作2的幂时，结果 `$s_{\\mathrm{buddy}}}$` 是满足 `$s_{\\mathrm{buddy}} \\ge d_{\\mathrm{eff}}$` 的最小2的幂。\n\n**分离空闲链表（SFL）分配**\nSFL分配器使用一组预定义的块大小（桶），这些大小是量子 `$q$` 的倍数，位于给定范围 `$[L_{\\min}, L_{\\max}]$` 内。与伙伴系统类似，分配必须满足 `$r+h$` 的需求和最小块大小 `$L_{\\min}$`。因此，有效需求为 `$d_{\\mathrm{eff}} = \\max(r + h, L_{\\min})$`。分配的块大小 `$s_{\\mathrm{SFL}}}$` 是大于或等于 `$d_{\\mathrm{eff}}$` 的最小 `$q$` 的倍数（并且在 `$[L_{\\min}, L_{\\max}]$` 范围内，这在提供的测试用例中是保证的）。这个大小可以计算为：\n$$s_{\\mathrm{SFL}} = q \\cdot \\lceil d_{\\mathrm{eff}} / q \\rceil$$\n将 `$d_{\\mathrm{eff}}$` 除以量子 `$q$` 可以确定需要多少个量子。向上取整函数将此需求向上舍入到下一个整数个量子。再乘以 `$q$` 即可得到最终的块大小。在整数算术中，这可以高效地计算为 `$s_{\\mathrm{SFL}} = ((d_{\\mathrm{eff}} + q - 1) / q) \\cdot q$`，其中除法是整数除法。\n\n**算法流程**\n对于由参数 `$(M, B_{\\min}, h, q, L_{\\min}, L_{\\max}, R)$` 指定的每个测试用例，我们执行以下计算：\n1.  将两个系统的总内部碎片累加器初始化为零：`$O_{\\mathrm{frag, buddy}} = 0$` 和 `$O_{\\mathrm{frag, SFL}} = 0$`。\n2.  两个系统的总元数据开销是恒定的，只需计算一次：`$O_{\\mathrm{meta}} = \\text{length}(R) \\cdot h$`。\n3.  遍历列表 `$R$` 中的每个请求大小 `$r$`：\n    a.  对于伙伴系统，计算 `$d_{\\mathrm{eff, buddy}} = \\max(r + h, B_{\\min})$`，并使用2的幂规则找到相应的块大小 `$s_{\\mathrm{buddy}}}$`。此请求的内部碎片为 `$f_{\\mathrm{buddy}} = s_{\\mathrm{buddy}} - (r+h)$`。将此值加到 `$O_{\\mathrm{frag, buddy}}}$` 上。\n    b.  对于SFL系统，计算 `$d_{\\mathrm{eff, SFL}} = \\max(r + h, L_{\\min})$`，并使用量子倍数规则找到块大小 `$s_{\\mathrm{SFL}}}$`。内部碎片为 `$f_{\\mathrm{SFL}} = s_{\\mathrm{SFL}} - (r+h)$`。将此值加到 `$O_{\\mathrm{frag, SFL}}}$` 上。\n4.  遍历所有请求后，计算每个系统的总开销：\n    - `$O_{\\mathrm{total, buddy}} = O_{\\mathrm{meta}} + O_{\\mathrm{frag, buddy}}$`\n    - `$O_{\\mathrm{total, SFL}} = O_{\\mathrm{meta}} + O_{\\mathrm{frag, SFL}}$`\n5.  按指定顺序为测试用例组合所需的六个整数值：伙伴系统总开销、伙伴系统元数据开销、伙伴系统内部碎片开销、SFL总开销、SFL元数据开销和SFL内部碎片开销。然后将所有测试用例的结果连接成一个列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and compares memory overhead for Buddy System and Segregated Free List\n    allocators based on a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (M, B_min, h, q, L_min, L_max, R) where R is a list of requests.\n    test_cases = [\n        (1024, 16, 8, 16, 16, 256, [13, 24, 7, 100, 33]),\n        (2048, 32, 16, 16, 32, 1024, [32, 63, 64, 127, 128]),\n        (512, 64, 8, 32, 64, 256, [1, 2, 3]),\n        (4096, 16, 16, 32, 32, 2048, [1000, 1000, 1000]),\n    ]\n\n    all_results = []\n\n    for M, B_min, h, q, L_min, L_max, R in test_cases:\n        \n        # --- Buddy System Calculation ---\n        buddy_total_frag = 0\n        for r in R:\n            # Total size needed for payload and header\n            demand = r + h\n            # Apply the minimum block size constraint from the buddy system rules\n            effective_demand = max(demand, B_min)\n            # Find the smallest power of two that is >= effective_demand\n            # s_buddy = 2^(ceil(log2(effective_demand)))\n            s_buddy = int(2**np.ceil(np.log2(effective_demand)))\n            # Internal fragmentation is the unused space within the allocated block\n            frag_buddy = s_buddy - demand\n            buddy_total_frag += frag_buddy\n            \n        buddy_total_meta = len(R) * h\n        buddy_total_overhead = buddy_total_meta + buddy_total_frag\n\n        # --- Segregated Free List (SFL) Calculation ---\n        sfl_total_frag = 0\n        for r in R:\n            # Total size needed for payload and header\n            demand = r + h\n            # Apply the minimum block size constraint from the SFL rules\n            effective_demand = max(demand, L_min)\n            # Find the smallest multiple of the quantum q that is >= effective_demand\n            # This is equivalent to q * ceil(effective_demand / q)\n            s_sfl = ((effective_demand + q - 1) // q) * q\n            # Internal fragmentation is the unused space\n            frag_sfl = s_sfl - demand\n            sfl_total_frag += frag_sfl\n\n        sfl_total_meta = len(R) * h\n        sfl_total_overhead = sfl_total_meta + sfl_total_frag\n        \n        # Assemble the 6 result values for the current test case\n        case_results = [\n            buddy_total_overhead, buddy_total_meta, buddy_total_frag,\n            sfl_total_overhead, sfl_total_meta, sfl_total_frag\n        ]\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3251579"}, {"introduction": "内存管理不仅关乎效率，更关乎安全。本练习将我们的关注点从性能转向一个在手动内存管理中常见且危险的错误：“释放后使用”（Use-After-Free）。你将动手实现一个模拟器，它采用一种称为“内存投毒”（Memory Poisoning）的强大调试技术，通过向已释放的内存块中填充特定模式来检测后续的非法访问，从而为你提供一堂关于内存安全的实践课。[@problem_id:3239152]", "problem": "要求您设计并实现一个确定性的堆内存分配模拟器，该模拟器带有一个释放后使用（use-after-free）检测器。该检测器通过向已释放的内存中注入特定的位模式（“毒化”），并在后续分配时检查这种“毒药”模式来工作。该模拟器必须为一个连续的字节堆、一系列可变大小的分配、释放和写入操作建模，并且必须报告在重用一个已释放的块时是否检测到了释放后使用。检测器的工作原理是：当一个块被释放时，向其内容中写入一个固定的重复毒药模式；之后当该块被重用时，验证该模式是否仍然完好无损。如果被重用块中的任何字节与毒药模式规定的值不同，则标记为发生了释放后使用。\n\n从与数据结构和算法一致的基本原理开始。将内存建模为一个具有随机存取能力的有限数组：堆 $\\mathcal{H}$ 是一个长度为 $C$ 的字节数组，索引从 $0$ 到 $C-1$。一个分配器管理一组块，每个块由一个元组 $(b_s, b_n, b_a)$ 表示，其中 $b_s$ 是起始索引，$b_n$ 是块的大小（以字节为单位），$b_a$ 是一个布尔值，指示该块当前是否已分配。我们考虑一种“首次适应”分配器，它会重用大小完全匹配的已释放块：当分配 $n$ 个字节时，如果存在一个大小 $b_n = n$ 的空闲块，则重用按起始地址递增顺序找到的第一个此类块；否则，如果在当前已用堆区域的末尾有足够的剩余容量，则创建一个新块。当释放一个块时，将一个毒药模式 $P$ 写入其内容，在其 $b_n$ 个字节的范围内循环重复。定义毒药模式为 $P[0] = \\text{0xDE}$，$P[1] = \\text{0xAD}$，$P[2] = \\text{0xBE}$，$P[3] = \\text{0xEF}$，其长度为 $L = 4$ 字节。\n\n释放后使用（use-after-free）错误是指，一个块被释放后，属于它的内存被一个陈旧引用写入，这违反了分配器的安全约束。检测器在重用时验证不变量：当一个大小为 $n$ 的分配请求重用了一个先前释放的块 $(b_s, n, \\text{false})$ 时，计算\n$$\n\\mathsf{UAF} = \\neg \\left( \\forall i \\in \\{0,1,\\dots,n-1\\},\\; \\mathcal{H}[b_s + i] = P[i \\bmod L] \\right).\n$$\n如果 $\\mathsf{UAF}$ 为真，模拟器记录该分配操作检测到了释放后使用；否则记录为假。在堆的末尾创建新块的分配不会触发此检查（它们总是被记录为假），因为它们不重用已释放的内存。\n\n实现一个完整的程序，构建这样一个模拟器并执行下面描述的测试套件。程序没有外部输入；它必须打印且仅打印一行输出，其中包含方括号内的逗号分隔列表，内容是每个测试用例的结果，这些结果是程序逻辑产生的布尔值。例如，一个有效的输出格式是 $[\\text{True},\\text{False},\\text{True}]$。\n\n测试套件：\n每个测试用例初始化一个容量为 $C = 64$ 字节的堆，并运行一系列操作。一个操作可以是“分配 $n$ 字节”、“释放句柄 $h$”或“在句柄 $h$ 内的偏移量 $o$ 处写入值 $v$”，其中所有偏移量和大小都是非负整数，值是范围在 $0$ 到 $255$ 之间的字节值。“写入”操作允许在已分配和已释放的块上进行，以模拟陈旧写入；它会覆盖 $\\mathcal{H}$ 中相应的字节。每个测试用例报告的结果是该测试用例中执行的最后一次分配操作所记录的布尔值 $\\mathsf{UAF}$。\n\n- 测试用例 1：\n  - 分配 $n = 16$ 字节，产生句柄 $h_1$。\n  - 释放 $h_1$。\n  - 再次分配 $n = 16$ 字节；将此次分配的检测器布尔值作为测试用例结果报告。\n\n- 测试用例 2：\n  - 分配 $n = 8$ 字节，产生句柄 $h_1$。\n  - 释放 $h_1$。\n  - 在句柄 $h_1$ 内的偏移量 $o = 2$ 处写入值 $v = \\text{0x00}$（这是一次陈旧写入）。\n  - 再次分配 $n = 8$ 字节；将此次分配的检测器布尔值作为测试用例结果报告。\n\n- 测试用例 3（跨越整个堆的边界条件）：\n  - 分配 $n = 64$ 字节，产生句柄 $h_1$。\n  - 释放 $h_1$。\n  - 在句柄 $h_1$ 内的偏移量 $o = 63$ 处写入值 $v = \\text{0x11}$（最后一个字节）。\n  - 再次分配 $n = 64$ 字节；将此次分配的检测器布尔值作为测试用例结果报告。\n\n- 测试用例 4（大小不匹配后紧跟精确重用）：\n  - 分配 $n = 12$ 字节，产生句柄 $h_1$。\n  - 释放 $h_1$。\n  - 在句柄 $h_1$ 内的偏移量 $o = 5$ 处写入值 $v = \\text{0x22}$（陈旧写入）。\n  - 分配 $n = 8$ 字节（由于没有大小为 8 的精确空闲块，因此在堆尾创建新块；检测器内部记录为假，但这不是最终结果）。\n  - 分配 $n = 12$ 字节（这将重用 $h_1$）；将此次分配的检测器布尔值作为测试用例结果报告。\n\n您的程序必须实现所述的模拟器并按顺序执行这四个测试用例。您的程序应产生单行输出，包含四个结果，格式为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，其中每个 $\\text{result}_i$ 是模拟器为相应测试用例的最后一次分配操作生成的布尔值，输出行中没有空格。", "solution": "该问题要求设计并实现一个确定性的堆内存分配模拟器。这个模拟器必须集成一个用于检测释放后使用（UAF）内存损坏的特定机制。我们首先根据描述来形式化系统的各个组成部分。\n\n堆，表示为 $\\mathcal{H}$，被建模为一个连续的内存块，可以用一个从零开始索引的字节数组来表示。堆的容量给定为 $C = 64$ 字节。堆的状态由一个分配器管理。\n\n分配器维护一个内存块列表。每个块由一个元组 $(b_s, b_n, b_a)$ 来表征，其中 $b_s$ 是块在 $\\mathcal{H}$ 中的起始索引（地址），$b_n$ 是其大小（以字节为单位），$b_a$ 是一个布尔标志，指示其分配状态（`true` 表示已分配，`false` 表示空闲）。“句柄”作为块的唯一标识符，我们可以将其实现为该块在分配器块列表中的索引。一个变量，我们称之为 $H_{top}$，用于跟踪堆已使用部分的末端，初始化为 $0$。\n\n操作定义如下：\n\n1.  **分配**：一个分配 $n$ 字节的请求会触发以下“首次适应且大小完全匹配”策略：\n    *   分配器按起始地址 $b_s$ 递增的顺序扫描其块列表。它搜索第一个当前空闲（$b_a = \\text{false}$）且大小完全匹配（$b_n = n$）的块。\n    *   **重用路径**：如果找到这样一个块 $(b_s, n, \\text{false})$，它将被重用。在将其标记为已分配之前，UAF 检测器会执行检查。\n        *   检测器验证块被释放时写入的毒药模式的完整性。检查由以下公式定义：\n            $$\n            \\mathsf{UAF} = \\neg \\left( \\forall i \\in \\{0, 1, \\dots, n-1\\},\\; \\mathcal{H}[b_s + i] = P[i \\bmod L] \\right)\n            $$\n            其中毒药模式为 $P = \\{\\text{0xDE}, \\text{0xAD}, \\text{0xBE}, \\text{0xEF}\\}$，长度 $L = 4$。如果括号内的条件为假（意味着至少有一个字节与预期的毒药值不匹配），$\\mathsf{UAF}$ 的值为 `true`，表示检测到释放后使用。否则，$\\mathsf{UAF}$ 为 `false`。\n        *   然后，该块的状态被更新为已分配（$b_a = \\text{true}$）。$\\mathsf{UAF}$ 布尔值被记录用于此操作。\n    *   **新分配路径**：如果没有找到合适的空闲块，分配器会尝试在堆的末尾创建一个新块。\n        *   它检查是否有足够的容量：$H_{top} + n \\le C$。\n        *   如果有，则创建一个新块 $(H_{top}, n, \\text{true})$ 并将其添加到分配器的列表中。然后 $H_{top}$ 更新为 $H_{top} + n$。\n        *   对于新分配，没有重用，因此不执行 UAF 检查。此操作的记录结果被定义为 `false`。\n\n2.  **释放**：当释放由句柄 $h$ 标识的块时，相应块的状态被设置为空闲（$b_a = \\text{false}$）。随后，其在 $\\mathcal{H}$ 内的内存区域必须被“毒化”。对于从 $0$ 到 $b_n-1$ 的每个字节索引 $i$，值 $P[i \\pmod L]$ 被写入内存位置 $\\mathcal{H}[b_s + i]$。\n\n3.  **写入**：对块 $h$ 中偏移量为 $o$ 的位置写入值 $v$ 的操作直接修改堆数组：$\\mathcal{H}[b_s + o] \\leftarrow v$。此操作无论块的分配状态如何都是允许的，从而模拟对已释放块的“陈旧写入”，这是导致释放后使用错误的原因。\n\n我们现在跟踪每个测试用例的执行，以确定预期的结果。每个测试用例都从一个容量为 $C=64$ 的空堆和一个空的块列表开始。\n\n**测试用例 1：**\n1.  `allocate 16`：没有空闲块存在。创建一个新块 $h_1$：$(b_s=0, b_n=16, b_a=\\text{true})$。$H_{top}$ 变为 $16$。记录的 UAF 状态为 `false`。\n2.  `free h_1`：块 $h_1$ 被标记为空闲。内存区域 $\\mathcal{H}[0 \\dots 15]$ 被毒化，模式为 `0xDE, 0xAD, 0xBE, 0xEF, ...` 循环重复。\n3.  `allocate 16`：分配器找到空闲块 $h_1$（大小完全匹配）。UAF 检测器检查 $\\mathcal{H}[0 \\dots 15]$。由于没有发生陈旧写入，每个字节都与毒药模式匹配。条件 $\\forall i, \\mathcal{H}[i] = P[i \\pmod 4]$ 为真。因此，$\\mathsf{UAF} = \\neg(\\text{true}) = \\text{false}$。\n    *   **结果 1**：`False`\n\n**测试用例 2：**\n1.  `allocate 8`：创建一个新块 $h_1$：$(b_s=0, b_n=8, b_a=\\text{true})$。$H_{top}$ 变为 $8$。UAF 为 `false`。\n2.  `free h_1`：块 $h_1$ 被标记为空闲。$\\mathcal{H}[0 \\dots 7]$ 被毒化，模式为 `0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF`。\n3.  `write v=0x00 at o=2 in h_1`：这是一次陈旧写入。它修改了地址为 $b_s+o = 0+2=2$ 的内存。所以，$\\mathcal{H}[2]$ 变为 `0x00`。预期的毒药值是 $P[2 \\pmod 4] = P[2] = \\text{0xBE}$。\n4.  `allocate 8`：分配器找到并重用空闲块 $h_1$。UAF 检测器检查 $\\mathcal{H}[0 \\dots 7]$。在索引 $i=2$ 处，它发现 $\\mathcal{H}[2] = \\text{0x00}$，但预期的是 $P[2] = \\text{0xBE}$。条件 $\\forall i, \\dots$ 为假。因此，$\\mathsf{UAF} = \\neg(\\text{false}) = \\text{true}$。\n    *   **结果 2**：`True`\n\n**测试用例 3：**\n1.  `allocate 64`：创建一个新块 $h_1$：$(b_s=0, b_n=64, b_a=\\text{true})$。$H_{top}$ 变为 $64$。UAF 为 `false`。\n2.  `free h_1`：块 $h_1$ 被标记为空闲。整个堆 $\\mathcal{H}[0 \\dots 63]$ 被毒化。\n3.  `write v=0x11 at o=63 in h_1`：一次陈旧写入将 $\\mathcal{H}[63]$ 修改为 `0x11`。预期的毒药值是 $P[63 \\pmod 4] = P[3] = \\text{0xEF}$。\n4.  `allocate 64`：分配器重用 $h_1$。在检查期间，在索引 $i=63$ 处，它发现 $\\mathcal{H}[63] = \\text{0x11}$，这与预期的 $P[3] = \\text{0xEF}$ 不相等。条件 $\\forall i, \\dots$ 为假。因此，$\\mathsf{UAF} = \\neg(\\text{false}) = \\text{true}$。\n    *   **结果 3**：`True`\n\n**测试用例 4：**\n1.  `allocate 12`：创建一个新块 $h_1$：$(b_s=0, b_n=12, b_a=\\text{true})$。$H_{top}$ 变为 $12$。UAF 为 `false`。\n2.  `free h_1`：块 $h_1$ 被标记为空闲，其内存区域 $\\mathcal{H}[0 \\dots 11]$ 被毒化。\n3.  `write v=0x22 at o=5 in h_1`：一次陈旧写入将 $\\mathcal{H}[5]$ 修改为 `0x22`。预期的毒药值是 $P[5 \\pmod 4] = P[1] = \\text{0xAD}$。\n4.  `allocate 8`：分配器搜索大小为 8 的空闲块。它找到 $h_1$，其大小为 12，因此不完全匹配。它转到新分配路径。创建一个新块 $h_2$：$(b_s=12, b_n=8, b_a=\\text{true})$。$H_{top}$ 变为 $12+8=20$。此操作的 UAF 结果是 `false`，但它不是最终操作。\n5.  `allocate 12`：分配器搜索大小为 12 的空闲块。它找到 $h_1$，这是一个完全匹配。UAF 检测器检查 $\\mathcal{H}[0 \\dots 11]$。在索引 $i=5$ 处，它将 $\\mathcal{H}[5] = \\text{0x22}$ 与预期的 $P[1] = \\text{0xAD}$ 进行比较。它们不相等。条件 $\\forall i, \\dots$ 为假。因此，$\\mathsf{UAF} = \\neg(\\text{false}) = \\text{true}$。\n    *   **结果 4**：`True`\n\n四个测试用例的最终预期结果是 `[False, True, True, True]`。实现将遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Block:\n    \"\"\"Represents a block of memory in the heap.\"\"\"\n    def __init__(self, start_idx, size, is_allocated):\n        self.start_idx = start_idx\n        self.size = size\n        self.is_allocated = is_allocated\n\nclass HeapSimulator:\n    \"\"\"\n    Simulates heap memory allocation with a use-after-free detector.\n    \"\"\"\n    def __init__(self, capacity):\n        self._capacity = capacity\n        # Define the poison pattern as specified in the problem.\n        self._poison_pattern = np.array([0xDE, 0xAD, 0xBE, 0xEF], dtype=np.uint8)\n        self._poison_len = len(self._poison_pattern)\n        # Initialize the heap state for each new simulation.\n        self.reset()\n\n    def reset(self):\n        \"\"\"Resets the simulator to its initial state.\"\"\"\n        self._heap = np.zeros(self._capacity, dtype=np.uint8)\n        self._blocks = []\n        self._heap_top = 0\n\n    def allocate(self, n):\n        \"\"\"\n        Allocates a block of size n, returning a handle and a UAF detection flag.\n        \"\"\"\n        # First-fit with exact size match policy\n        for i, block in enumerate(self._blocks):\n            if not block.is_allocated and block.size == n:\n                # Reuse path: found a suitable free block\n                uaf_detected = self._check_poison(block.start_idx, block.size)\n                block.is_allocated = True\n                handle = i\n                return handle, uaf_detected\n        \n        # New allocation path: no suitable free block found\n        if self._heap_top + n = self._capacity:\n            start_idx = self._heap_top\n            new_block = Block(start_idx, n, is_allocated=True)\n            self._blocks.append(new_block)\n            self._heap_top += n\n            handle = len(self._blocks) - 1\n            # UAF check is not performed for new blocks, result is False by definition\n            uaf_detected = False\n            return handle, uaf_detected\n        else:\n            # Out of memory case (not expected in test suite)\n            raise MemoryError(f\"Failed to allocate {n} bytes.\")\n\n    def free(self, handle):\n        \"\"\"Frees the block associated with the given handle and poisons it.\"\"\"\n        if handle  0 or handle >= len(self._blocks):\n            raise ValueError(\"Invalid handle.\")\n        \n        block = self._blocks[handle]\n        if not block.is_allocated:\n            # Freeing an already-freed block might indicate a bug, but problem spec doesn't say to handle it.\n            return\n            \n        block.is_allocated = False\n        self._poison_memory(block.start_idx, block.size)\n\n    def write(self, handle, offset, value):\n        \"\"\"Writes a byte value to a given offset within a block.\"\"\"\n        if handle  0 or handle >= len(self._blocks):\n            raise ValueError(\"Invalid handle.\")\n            \n        block = self._blocks[handle]\n        if offset  0 or offset >= block.size:\n            raise IndexError(\"Write offset is out of bounds for the block.\")\n\n        address = block.start_idx + offset\n        self._heap[address] = value\n\n    def _poison_memory(self, start_idx, size):\n        \"\"\"Writes the poison pattern into a region of the heap.\"\"\"\n        for i in range(size):\n            self._heap[start_idx + i] = self._poison_pattern[i % self._poison_len]\n\n    def _check_poison(self, start_idx, size):\n        \"\"\"\n        Checks if a memory region matches the poison pattern.\n        Returns True if a mismatch (UAF) is found, False otherwise.\n        \"\"\"\n        for i in range(size):\n            if self._heap[start_idx + i] != self._poison_pattern[i % self._poison_len]:\n                # Mismatch found. The universal quantifier is false.\n                # UAF = not(False) = True.\n                return True\n        # No mismatch found. The universal quantifier is true.\n        # UAF = not(True) = False.\n        return False\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the final results.\n    \"\"\"\n    C = 64\n    all_results = []\n\n    # --- Test Case 1 ---\n    sim = HeapSimulator(C)\n    h1, _ = sim.allocate(16)\n    sim.free(h1)\n    _, final_uaf_result = sim.allocate(16)\n    all_results.append(final_uaf_result)\n\n    # --- Test Case 2 ---\n    sim.reset()\n    h1, _ = sim.allocate(8)\n    sim.free(h1)\n    sim.write(h1, offset=2, value=0x00)\n    _, final_uaf_result = sim.allocate(8)\n    all_results.append(final_uaf_result)\n\n    # --- Test Case 3 ---\n    sim.reset()\n    h1, _ = sim.allocate(64)\n    sim.free(h1)\n    sim.write(h1, offset=63, value=0x11)\n    _, final_uaf_result = sim.allocate(64)\n    all_results.append(final_uaf_result)\n\n    # --- Test Case 4 ---\n    sim.reset()\n    h1, _ = sim.allocate(12)\n    sim.free(h1)\n    sim.write(h1, offset=5, value=0x22)\n    # This allocation is not the final one for the test case's result\n    sim.allocate(8) \n    # This is the final allocation, its result is the one we report\n    _, final_uaf_result = sim.allocate(12)\n    all_results.append(final_uaf_result)\n\n    # Format and print the final output exactly as required.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3239152"}]}