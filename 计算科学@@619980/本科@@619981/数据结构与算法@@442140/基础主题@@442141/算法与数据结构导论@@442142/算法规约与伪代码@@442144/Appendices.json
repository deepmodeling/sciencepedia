{"hands_on_practices": [{"introduction": "斐波那契数列是学习算法的经典入门问题。本练习引导你将斐波那契数列的递归定义直接转化为一个初步的算法，并分析其指数级时间复杂度的根源——重叠子问题。通过运用动态规划的思想，你将学习如何系统地将这个朴素的递归算法重构为一个高效的、仅需线性时间和常数空间的迭代版本，并使用循环不变量来证明其正确性。[@problem_id:3205750]", "problem": "给定一个斐波那契数列的递归规范，它将输入整数 $n$ 映射到第 $n$ 个斐波那契数 $F(n)$。该数列由非负整数上的核心递推关系定义：$F(0) = 0$，$F(1) = 1$，并且对于所有 $n \\ge 2$，$F(n) = F(n-1) + F(n-2)$。下面朴素的递归伪代码完全遵循此定义：\n- 输入：整数 $n \\ge 0$。\n- 过程 $\\mathrm{Fib}(n)$:\n  - 如果 $n \\le 1$ 则返回 $n$。\n  - 否则返回 $\\mathrm{Fib}(n-1) + \\mathrm{Fib}(n-2)$。\n\n任务：将此伪代码重构为一个更高效的动态规划版本，并从数据结构和算法的第一性原理出发论证其设计。你的推导应基于递推关系的基本定义、重叠子问题的概念以及将运行时间计为基本操作次数的成本模型。不要使用任何未经算法构建过程直接得出答案的快捷恒等式。\n\n你的交付成果必须包括：\n- 一份清晰的算法说明，描述如何使用自底向上的迭代和常数辅助空间，从 $F(n)$ 的定义和朴素递归会重复计算重叠子问题的观察出发，来计算 $F(n)$。\n- 重构后算法的伪代码，该伪代码需精确陈述循环不变量，确保计算在每次迭代中都以有效状态前进。\n- 一份正确性论证，建立循环不变量，并使用对迭代计数器的数学归纳法来断定对于所有 $n \\ge 0$，输出都等于 $F(n)$。\n- 一份复杂度分析，比较朴素递归版本和你的动态规划版本，使用大O表示法（例如，$O(n)$）表示，并根据成本模型和计算结构进行论证。\n- 一个Python程序，实现重构后的动态规划算法，并将其应用于下面的测试套件。\n\n测试套件：\n- $n \\in \\{0, 1, 2, 5, 10, 50, 90\\}$。\n\n输出格式：\n- 你的程序应生成单行输出，包含一个由逗号分隔并用方括号括起来的结果列表，顺序与测试套件相同，例如 $[r_0,r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是对应测试输入的整数 $F(n)$。", "solution": "该问题要求将一个用于斐波那契数列的朴素递归算法重构为一个高效的动态规划版本，并为其设计提供完整的论证。\n\n**1. 问题陈述分析**\n\n问题提供了斐波那契数列 $F(n)$ 对于非负整数 $n$ 的数学定义：\n- 基础情况：$F(0) = 0$，$F(1) = 1$。\n- 递推关系：对于 $n \\ge 2$，$F(n) = F(n-1) + F(n-2)$。\n\n它还提供了相应的朴素递归伪代码：\n- 过程 $\\mathrm{Fib}(n)$:\n  - 如果 $n \\le 1$ 则返回 $n$。\n  - 否则返回 $\\mathrm{Fib}(n-1) + \\mathrm{Fib}(n-2)$。\n\n任务是使用动态规划，特别是自底向上的迭代方法和常数辅助空间，将此算法转变为一个更高效的算法。这涉及识别朴素方法中的低效之处，并系统地推导出改进后的算法。\n\n**2. 朴素递归方法的低效性：重叠子问题**\n\n朴素递归算法的核心问题是冗余计算。计算 $F(n)$ 涉及两个递归调用，$\\mathrm{Fib}(n-1)$ 和 $\\mathrm{Fib}(n-2)$。$F(n)$ 的调用树会不断展开，许多子问题被多次计算。例如，要计算 $F(5)$，算法会调用 $F(4)$ 和 $F(3)$。而计算 $F(4)$ 又需要 $F(3)$ 和 $F(2)$。因此，子问题 $F(3)$ 被计算了两次。这种在递归树的不同分支中反复遇到相同子问题的现象，被称为**重叠子问题**。这是一个关键特征，表明动态规划是适用的。\n\n计算 $F(n)$ 的递归调用次数 $T(n)$ 遵循递推关系 $T(n) = T(n-1) + T(n-2) + 1$，其中 $T(0)=1$ 和 $T(1)=1$。此递推关系的解是 $n$ 的指数函数。具体来说，$T(n)$ 属于 $O(\\phi^n)$，其中 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 是黄金分割率。这种指数级时间复杂度使得朴素算法对于中等大小的 $n$ 值也不切实际。\n\n**3. 动态规划推导与算法说明**\n\n动态规划通过存储子问题的结果来解决重复计算的低效问题。一种自底向上（或迭代）的方法按规模从小到大的顺序计算子问题的解。要计算 $F(n)$，我们可以依次计算 $F(2), F(3), \\dots, F(n)$，并利用先前已计算出的值。\n\n递推关系 $F(i) = F(i-1) + F(i-2)$ 表明，要计算第 $i$ 个斐波那契数，我们只需要紧邻的前两个数，$F(i-1)$ 和 $F(i-2)$。这一观察对于空间优化至关重要。我们无需将所有先前计算的斐波那契数存储在一个数组中（一个 $O(n)$ 空间复杂度的解决方案），而只需维护最后两个值来计算下一个值。这导出了一个具有常数辅助空间 $O(1)$ 的算法。\n\n该算法过程如下：\n- 直接处理基础情况 $n=0$ 和 $n=1$。\n- 对于 $n \\ge 2$，我们初始化两个变量来保存 $F(0)$ 和 $F(1)$。\n- 然后我们从 $i=2$ 迭代到 $n$。在每次迭代 $i$ 中，我们使用代表 $F(i-2)$ 和 $F(i-1)$ 的两个存储值来计算 $F(i)$。\n- 计算出 $F(i)$ 后，我们更新这两个变量以保存 $F(i-1)$ 和 $F(i)$，为下一次迭代 $i+1$ 做准备。\n- 循环继续直到计算出 $F(n)$。\n\n**4. 带循环不变量的伪代码**\n\n以下伪代码形式化了这种常数空间、自底向上的迭代算法。\n\n- **过程** $\\mathrm{Fib\\_DP}(n)$:\n- **输入**：一个非负整数 $n$。\n- **输出**：第 $n$ 个斐波那契数 $F(n)$。\n\n1.  **如果** $n = 0$，**返回** $0$。\n2.  **如果** $n = 1$，**返回** $1$。\n3.  \n4.  // 为迭代计算初始化变量\n5.  $a \\leftarrow 0$  // 代表第 $(i-2)$ 个斐波那契数\n6.  $b \\leftarrow 1$  // 代表第 $(i-1)$ 个斐波那契数\n7.  \n8.  // 从 2 迭代到 n，以计算 F(2), F(3), ..., F(n)\n9.  **对于** $i$ 从 $2$ 到 $n$:\n10.     // **循环不变量**：在索引为 $i$ 的迭代开始时，\n11.     // 变量 $a$ 存储 $F(i-2)$，变量 $b$ 存储 $F(i-1)$。\n12. \n13.     $temp \\leftarrow a + b$  // 计算 $F(i) = F(i-2) + F(i-1)$\n14.     $a \\leftarrow b$         // 更新 $a$ 为 $F(i-1)$，为下次迭代做准备\n15.     $b \\leftarrow temp$      // 更新 $b$ 为 $F(i)$，为下次迭代做准备\n16. \n17. // 循环终止后，$b$ 保存着 $F(n)$ 的值。\n18. **返回** $b$。\n\n**5. 正确性论证**\n\n我们证明 $\\mathrm{Fib\\_DP}$ 算法对于所有非负整数 $n$ 都是正确的。\n\n- **基础情况**：对于 $n=0$ 和 $n=1$，算法分别正确返回 $0$ 和 $1$，这与 $F(0)$ 和 $F(1)$ 的定义相符。\n\n- **归纳步骤 ($n \\ge 2$)**：我们使用循环不变量来证明对于 $n \\ge 2$ 的正确性。\n  - **循环不变量 $P(i)$**：在索引为 $i$ 的循环开始时（其中 $i$ 的范围从 $2$ 到 $n$），$a = F(i-2)$ 且 $b = F(i-1)$。\n\n  - **初始化**：在第一次迭代（$i=2$）之前，算法设置 $a \\leftarrow 0$ 和 $b \\leftarrow 1$。根据斐波那契数列的定义，$F(2-2) = F(0) = 0$ 且 $F(2-1) = F(1) = 1$。因此，不变量 $P(2)$ 在第一次迭代开始时成立。\n\n  - **保持**：假设对于某个整数 $k$（$2 \\le k \\le n$），不变量 $P(k)$ 成立。这意味着在第 $k$ 次迭代开始时，我们有 $a = F(k-2)$ 和 $b = F(k-1)$。\n    在第 $k$ 次迭代的主体中：\n    1.  $temp \\leftarrow a + b$。根据归纳假设，$temp = F(k-2) + F(k-1)$。根据斐波那契递推关系，$temp = F(k)$。\n    2.  $a \\leftarrow b$。变量 a 被更新为持有值 $F(k-1)$。\n    3.  $b \\leftarrow temp$。变量 b 被更新为持有值 $F(k)$。\n\n    在下一次迭代开始时，索引将是 $k+1$。变量将是 $a = F(k-1) = F((k+1)-2)$ 和 $b = F(k) = F((k+1)-1)$。这表明不变量 $P(k+1)$ 成立。因此，循环不变量得以保持。\n\n  - **终止**：循环在 $i=n$ 的迭代完成后终止。在最后一次迭代（$i=n$）开始时，不变量 $P(n)$ 成立，意味着 $a=F(n-2)$ 和 $b=F(n-1)$。在这个最后的迭代内部，$b$ 被更新为 $F(n)$。然后循环结束。算法接着返回 $b$ 的值，此时为 $F(n)$。\n\n该论证表明，对于所有 $n \\ge 2$，算法都能正确计算 $F(n)$。结合基础情况，该算法对于所有非负整数 $n$ 都是正确的。\n\n**6. 复杂度分析**\n\n- **朴素递归算法 ($\\mathrm{Fib}$)**:\n  - **时间复杂度**：如前所述，操作次数与递归调用次数成正比，呈指数级增长。时间复杂度为 $O(\\phi^n)$，其中 $\\phi \\approx 1.618$。\n  - **空间复杂度**：空间复杂度由递归栈的最大深度决定。为计算 $F(n)$，递归会深入到 $F(1)$ 或 $F(0)$，导致最大深度为 $n$。因此，空间复杂度为 $O(n)$。\n\n- **动态规划算法 ($\\mathrm{Fib\\_DP}$)**:\n  - **时间复杂度**：对于 $n \\ge 2$，算法执行一个从 $i=2$ 到 $n$ 的单循环。该循环迭代 $n-1$ 次。在循环内部，执行恒定数量的基本操作（一次加法，两次赋值）。因此，总时间复杂度为 $O(n-1) = O(n)$。\n  - **空间复杂度**：算法使用固定数量的变量（$n, a, b, temp, i$），无论输入大小 $n$ 如何。这些变量所需的空间是恒定的。因此，辅助空间复杂度为 $O(1)$。\n\n**比较总结**\n\n| 算法 | 时间复杂度 | 辅助空间复杂度 |\n| :--- | :--- | :--- |\n| 朴素递归 | $O(\\phi^n)$ (指数级) | $O(n)$ (线性) |\n| 动态规划 | $O(n)$ (线性) | $O(1)$ (常数) |\n\n动态规划方法在时间复杂度上实现了指数级的改进，并将辅助空间从线性减少到常数，使其优越得多。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fib_dp(n: int) -> int:\n    \"\"\"\n    Computes the n-th Fibonacci number using dynamic programming with constant space.\n    \n    The algorithm is based on the recurrence F(n) = F(n-1) + F(n-2).\n    It iteratively computes Fibonacci numbers from F(2) up to F(n),\n    keeping track of only the last two computed values.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The n-th Fibonacci number, F(n).\n    \"\"\"\n    if not isinstance(n, int) or n  0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Base cases as per the definition F(0) = 0, F(1) = 1.\n    if n = 1:\n        return n\n\n    # Initialization for the iterative process.\n    # We start with 'a' as F(0) and 'b' as F(1) to compute F(2).\n    # In general, at the start of the loop to compute F(i), 'a' is F(i-2) and 'b' is F(i-1).\n    a, b = 0, 1\n\n    # The loop runs n-1 times. For n=2, it runs once. For n=3, twice, and so on.\n    # At each step, we update (a, b) from (F(i-2), F(i-1)) to (F(i-1), F(i)).\n    # The Python tuple assignment `a, b = b, a + b` elegantly performs this state update\n    # by first evaluating the right-hand side (b, a + b) using the old values of a and b,\n    # and then assigning them to the left-hand side variables.\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    # After the loop finishes, 'b' holds the value of F(n).\n    return b\n\ndef solve():\n    \"\"\"\n    Runs the dynamic programming Fibonacci algorithm on the specified test suite\n    and prints the results in the required format.\n    \"\"\"\n    # Test suite as specified in the problem statement.\n    test_cases = [0, 1, 2, 5, 10, 50, 90]\n\n    results = []\n    for n in test_cases:\n        # Calculate the Fibonacci number for each case using the optimized algorithm.\n        result = fib_dp(n)\n        results.append(result)\n\n    # Format the final output as a single-line, comma-separated list in brackets.\n    # Note: Python's integers handle arbitrary size, so F(90) does not overflow.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205750"}, {"introduction": "数组旋转是一个基础但重要的数据操作，而通过三次反转实现的原地旋转算法则是一种巧妙且高效的解决方案。这个练习将挑战你跳出常规思路，将一个看似复杂的整体变换分解为一系列简单的局部操作。你需要为这个非直观的算法编写精确的伪代码，并从第一性原理出发，通过分析置换的复合来严格证明其正确性，从而深入理解算法设计中的抽象和形式化验证。[@problem_id:3205801]", "problem": "您将得到一个数组旋转任务，需要用精确的伪代码进行描述，并根据形式化规约进行验证。设数组是一个函数 $A:\\{0,1,\\dots,n-1\\}\\to \\mathbb{Z}$，其中 $n$ 是数组长度，索引从0开始。向右旋转 $k$ 个位置是对索引的排列，它将每个位置 $i$ 映射到 $(i+k)\\bmod n$。目标是设计并实现一个原地算法，该算法使用恰好3次片段反转来执行此旋转。\n\n使用的基本原理和定义：\n- 长度为 $n$ 的数组 $A$ 是一个在 $\\{0,1,\\dots,n-1\\}$ 上索引的序列。\n- 对于整数 $l$ 和 $r$（$0\\le l\\le r  n$），反转操作 $\\mathrm{Reverse}(A, l, r)$ 会原地修改数组，使得子数组 $A[l..r]$ 的元素顺序被颠倒。\n\n您的任务是：\n- 为这个三反转算法提供一份精确的伪代码规约。\n- 根据形式化规约，通过分析排列的复合来证明该算法的正确性。\n- 实现一个可运行的 Python 程序，该程序对以下测试套件应用该算法，并以指定的格式打印结果。\n\n测试套件：\n- $A = [1, 2, 3, 4, 5], k = 2$\n- $A = [10], k = 100$\n- $A = [], k = 3$\n- $A = [0, 1, 2, 3], k = 0$\n- $A = [-1, -2, -3, -4, -5, -6], k = 3$\n- $A = [7, 8, 9, 10, 11, 12, 13], k = -2$\n\n输出格式：\n- 程序应生成单行输出，包含一个由逗号分隔并用方括号括起来的旋转后数组列表，例如 `[[4,5,1,2,3],[10],[],[0,1,2,3],[-4,-5,-6,-1,-2,-3],[9,10,11,12,13,7,8]]`。", "solution": "原地旋转数组是计算机科学中的一个基本任务。要求是设计一个算法，该算法使用恰好三次片段反转来实现此旋转，并在线性时间 $O(n)$ 和常数辅助空间 $O(1)$ 内运行。\n\n### 步骤1：算法规约（伪代码）\n\n首先，我们定义反转数组片段的基本操作。设 $A$ 是一个数组，$\\ell$ 和 $r$ 是待反转片段的起始和结束索引，其中 $0 \\le \\ell \\le r  n$。\n\n- 过程 $\\mathrm{Reverse}(A,\\ell,r)$:\n  - 当 $\\ell  r$ 时：\n    - 交换 $A[\\ell]$ 和 $A[r]$。\n    - 设置 $\\ell \\leftarrow \\ell+1$ 和 $r \\leftarrow r-1$。\n\n使用这个基本操作，我们可以构建旋转算法。在长度为 $n$ 的数组上向右旋转 $k$ 个位置，等价于将最后 $k$ 个元素移动到数组的开头，同时保持两个片段内部的顺序。这可以看作是将一个划分为两个块 $A = [B_1|B_2]$ 的数组转换为 $[B_2|B_1]$，其中 $B_1$ 的长度为 $n-k$，$B_2$ 的长度为 $k$。\n\n该算法应用三次反转来实现这种转换。\n\n- 过程 $\\mathrm{RotateRightByK}(A,k)$:\n  - 令 $n \\leftarrow \\mathrm{length}(A)$。\n  - 如果 $n=0$ 则返回。\n  - 标准化 $k \\leftarrow k \\bmod n$。这确保了 $k \\in \\{0, 1, \\dots, n-1\\}$。表达式 $(i+k)\\bmod n$ 对于任何整数 $k$ 都有明确定义，但为了划分数组，我们需要一个非负的有效旋转计数。\n  - 如果 $k=0$ 则返回。（这是一个优化；下面的逻辑即使在 $k=0$ 时也是正确的）。\n  - 调用 $\\mathrm{Reverse}(A, 0, n-k-1)$。这会反转前 $n-k$ 个元素的第一个块。\n  - 调用 $\\mathrm{Reverse}(A, n-k, n-1)$。这会反转后 $k$ 个元素的第二个块。\n  - 调用 $\\mathrm{Reverse}(A, 0, n-1)$。这会反转整个数组。\n\n### 步骤2：形式化规约\n\n- **前置条件**：$A$ 是一个长度为 $n \\ge 0$ 的数组，$k$ 是一个表示向右旋转位置数量的整数。\n- **后置条件**：数组 $A$ 被原地修改，其元素根据向右旋转 $k$ 位进行排列。设 $A_{initial}$ 表示操作前数组的状态，$A_{final}$ 表示操作后的状态。后置条件是对于所有索引 $i \\in \\{0, 1, \\dots, n-1\\}$，等式 $A_{final}[(i+k) \\pmod n] = A_{initial}[i]$ 成立。\n- **正确性规约**：该算法对数组索引产生的净排列必须与所有 $i \\in \\{0, 1, \\dots, n-1\\}$ 的排列 $\\pi_{rot_k}: i \\mapsto (i+k) \\pmod n$ 相同。\n\n### 步骤3：正确性论证\n\n我们必须证明这三次指定反转的复合实现了所需的旋转排列。设 $n$ 为数组 $A$ 的长度。设有效旋转量为 $k' = k \\pmod n$，其中 $0 \\le k'  n$。\n\n该算法由三次反转排列的顺序应用组成。我们将片段 $[l, r]$ 的反转排列定义为 $\\mathrm{rev}_{(l,r)}$。其排列映射为：如果 $i \\in [l, r]$，则 $\\mathrm{rev}_{(l,r)}(i) = l+r-i$；否则 $\\mathrm{rev}_{(l,r)}(i) = i$。\n\n算法应用的三个排列是：\n1.  $\\pi_1 = \\mathrm{rev}_{(0, n-k'-1)}$\n2.  $\\pi_2 = \\mathrm{rev}_{(n-k', n-1)}$\n3.  $\\pi_3 = \\mathrm{rev}_{(0, n-1)}$\n\n总排列是复合排列 $\\pi_{total} = \\pi_3 \\circ \\pi_2 \\circ \\pi_1$。我们需要证明对于任何初始索引 $i \\in \\{0, 1, \\dots, n-1\\}$，其最终位置是 $\\pi_{total}(i) = (i+k') \\pmod n$。我们通过考虑基于其初始位置的两种情况来分析任意索引 $i$ 的映射。\n\n**情况1：$i \\in [0, n-k'-1]$**（元素在第一个块中）。\n- **应用 $\\pi_1$**：索引 $i$ 在反转范围 $[0, n-k'-1]$ 内。\n  $i_1 = \\pi_1(i) = 0 + (n-k'-1) - i = n-k'-1-i$。\n  得到的索引 $i_1$ 也在范围 $[0, n-k'-1]$ 内。\n- **应用 $\\pi_2$**：索引 $i_1$ 在 $\\pi_2$ 的反转范围 $[n-k', n-1]$ 之外。\n  $i_2 = \\pi_2(i_1) = i_1 = n-k'-1-i$。\n- **应用 $\\pi_3$**：索引 $i_2$ 在 $\\pi_3$ 的反转范围 $[0, n-1]$ 内。\n  $i_3 = \\pi_3(i_2) = 0 + (n-1) - i_2 = n-1-(n-k'-1-i) = n-1-n+k'+1+i = i+k'$。\n\n对于 $i \\in [0, n-k'-1]$，最终位置是 $i+k'$。由于 $i \\le n-k'-1$，我们有 $i+k' \\le n-1$。因此，$(i+k') \\pmod n = i+k'$，这与目标旋转相匹配。\n\n**情况2：$i \\in [n-k', n-1]$**（元素在第二个块中）。\n- **应用 $\\pi_1$**：索引 $i$ 在 $\\pi_1$ 的反转范围 $[0, n-k'-1]$ 之外。\n  $i_1 = \\pi_1(i) = i$。\n- **应用 $\\pi_2$**：索引 $i_1 = i$ 在 $\\pi_2$ 的反转范围 $[n-k', n-1]$ 内。\n  $i_2 = \\pi_2(i_1) = (n-k') + (n-1) - i_1 = 2n-k'-1-i$。\n  得到的索引 $i_2$ 也在范围 $[n-k', n-1]$ 内（通过检查边界可以证明）。\n- **应用 $\\pi_3$**：索引 $i_2$ 在 $\\pi_3$ 的反转范围 $[0, n-1]$ 内。\n  $i_3 = \\pi_3(i_2) = 0 + (n-1) - i_2 = n-1 - (2n-k'-1-i) = n-1-2n+k'+1+i = i+k'-n$。\n\n对于 $i \\in [n-k', n-1]$，我们有 $i+k' \\ge (n-k')+k' = n$。向右旋转 $k'$ 的标准定义将 $i$ 映射到 $(i+k') \\pmod n$。由于 $i+k' \\ge n$ 且 $i+k'  (n-1)+n = 2n-1$，模运算得出 $(i+k') \\pmod n = i+k'-n$。这与我们推导出的最终位置 $i_3$ 相匹配。\n\n在这两种情况下，最初位于索引 $i$ 的元素的最终位置都是 $(i+k') \\pmod n$。因此，该算法是正确的。它使用了三次反转过程，每次耗时 $O(n)$，总时间复杂度为 $O(n)$。它在原地操作，仅使用少数变量来存储索引，因此需要 $O(1)$ 的辅助空间。这满足了所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the array rotation problem.\n    \"\"\"\n    # Define the test cases as specified in the problem statement.\n    # Each case is a tuple containing a list (array A) and an integer (rotation k).\n    test_cases = [\n        ([1, 2, 3, 4, 5], 2),\n        ([10], 100),\n        ([], 3),\n        ([0, 1, 2, 3], 0),\n        ([-1, -2, -3, -4, -5, -6], 3),\n        ([7, 8, 9, 10, 11, 12, 13], -2),\n    ]\n\n    rotated_results = []\n    for arr, k in test_cases:\n        # Create a copy to avoid modifying the original list in the test_cases definition.\n        arr_copy = arr.copy()\n        # Apply the rotation algorithm to the copied array.\n        rotate_right_by_k(arr_copy, k)\n        # Store the rotated array.\n        rotated_results.append(arr_copy)\n\n    # Format the results into a single string as required by the problem.\n    # e.g., [[4,5,1,2,3],[10],[],[0,1,2,3],[-4,-5,-6,-1,-2,-3],[9,10,11,12,13,7,8]]\n    # This involves converting each list to its string representation, removing spaces,\n    # joining them with commas, and enclosing the whole string in brackets.\n    output_str = f\"[{','.join(str(r).replace(' ', '') for r in rotated_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\ndef reverse(arr, l, r):\n    \"\"\"\n    Reverses a segment of the array `arr` in-place from index `l` to `r`.\n    This corresponds to the pseudo-code: Procedure Reverse(A, l, r).\n    \"\"\"\n    while l  r:\n        arr[l], arr[r] = arr[r], arr[l]\n        l += 1\n        r -= 1\n\ndef rotate_right_by_k(arr, k):\n    \"\"\"\n    Rotates the array `arr` to the right by `k` positions in-place using 3 reversals.\n    This corresponds to the pseudo-code: Procedure RotateRightByK(A, k).\n    \"\"\"\n    n = len(arr)\n    # Handle the edge case of an empty array.\n    if n == 0:\n        return\n\n    # Normalize k to be within the range [0, n-1].\n    # For k  0, k % n in Python correctly maps to a positive equivalent.\n    # e.g., -2 % 7 = 5.\n    k = k % n\n\n    # If k is 0, the array does not need to be rotated.\n    if k == 0:\n        return\n\n    # 1. Reverse the first n-k elements.\n    # The segment is A[0 ... n-k-1].\n    reverse(arr, 0, n - k - 1)\n\n    # 2. Reverse the last k elements.\n    # The segment is A[n-k ... n-1].\n    reverse(arr, n - k, n - 1)\n\n    # 3. Reverse the entire array.\n    # The segment is A[0 ... n-1].\n    reverse(arr, 0, n - 1)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3205801"}, {"introduction": "汉诺塔问题是计算机科学中阐释递归思想的典范。本练习要求你为这一经典问题设计并实现两种截然不同的算法规范：一种是优雅的递归解法，它体现了分治策略的精髓；另一种是确定性的迭代解法，它揭示了问题背后隐藏的数学模式。通过实现和验证这两种方法，你将深刻体会到递归与迭代在解决问题上的不同视角，并领悟如何将抽象的算法思想转化为具体、可执行的代码。[@problem_id:3205878]", "problem": "你需要为汉诺塔问题形式化并用伪代码实现两个算法规范，然后提供一个单一的可运行程序，该程序在一个预定义的测试套件上验证这些规范。汉诺塔问题包含三个柱子和 $n$ 个盘子，盘子从 $1$（最小）到 $n$（最大）编号。所有盘子最初都在一个指定的源柱上，目标是使用一个辅助柱将整个盘子栈移动到一个指定的目标柱上，需遵循以下约束：每次只能移动一个盘子，且任何盘子都不能放在比它小的盘子之上。\n\n基于数据结构与算法的公认基础理论：\n- 分治算法的递归分解原则，\n- 用于计算操作次数的数学归纳法和递推关系，\n- 使用离散表示、无需搜索的确定性状态生成方法，\n\n你必须产出两种算法设计：\n\n1. 一个递归规范：给定 $n \\ge 0$ 和柱子标签 $(s,a,t)$，返回将所有盘子从源柱 $s$ 移动到目标柱 $t$（使用辅助柱 $a$）所需的最短移动序列。一次移动是一个有序对 $(u,v)$，其中 $u \\ne v$，表示将顶层盘子从柱子 $u$ 合法地移动到柱子 $v$。\n\n2. 一个非递归的迭代规范：该规范仅使用循环、每步固定的时间复杂度的算术或位运算，以及具有常数时间访问能力的数据结构，来确定性地生成相同的最小移动序列。它不得使用递归、搜索或回溯。该设计必须确保每一步都恰好移动一个盘子，并且所有中间状态都符合约束条件。\n\n你的实现必须：\n- 提供两个函数，一个用于递归方法，一个用于迭代方法，每个函数都返回一个由柱子标签有序对组成的列表，表示完整的移动序列。\n- 对每个测试用例，验证两个序列是否相同，验证从初始配置模拟时该序列是否合法，并报告生成的总移动次数。\n\n程序要使用的测试套件是以下参数三元组 $(n,s,a,t)$ 列表：\n- 用例 1：$(0, \\text{\"S\"}, \\text{\"A\"}, \\text{\"T\"})$,\n- 用例 2：$(1, \\text{\"S\"}, \\text{\"A\"}, \\text{\"T\"})$,\n- 用例 3：$(2, \\text{\"S\"}, \\text{\"A\"}, \\text{\"T\"})$,\n- 用例 4：$(3, \\text{\"X\"}, \\text{\"Y\"}, \\text{\"Z\"})$,\n- 用例 5：$(4, \\text{\"S\"}, \\text{\"A\"}, \\text{\"T\"})$。\n\n不涉及物理单位或角度。所有输出均为纯离散值。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表。\n- 对于每个测试用例，程序必须输出一个列表 $[E,L,G]$，其中 $E$ 是一个布尔值，表示递归和迭代序列是否相同；$L$ 是算法生成的移动次数（整数）；$G$ 是一个布尔值，表示移动序列是否合法且最终导致整个盘子栈位于目标柱上。\n- 测试用例必须按上面列出的确切顺序处理，最终输出应将其 $[E,L,G]$ 结果汇总到一个顶级列表中。例如，最终输出应类似于 $[[E_1,L_1,G_1],[E_2,L_2,G_2],\\dots]$，其中每个 $E_i$ 是 $\\text{True}$ 或 $\\text{False}$，每个 $L_i$ 是一个整数。\n\n程序必须完全自包含，不读取任何输入，并严格只打印所需的单行输出。", "solution": "汉诺塔问题要求设计算法，遵循特定规则，将 $n$ 个盘子从源柱 $s$ 通过辅助柱 $a$ 移动到目标柱 $t$。这个问题是计算机科学中阐述递归的经典范例，也可以用一种不那么直观的迭代方法来解决。解决方案必须为递归算法和确定性迭代算法提供设计，实现它们，并在给定的测试套件上验证其正确性和等价性。\n\n### 基于原则的算法设计\n\n该解决方案建立在成熟的算法设计原则之上：递归分解、数学归纳法和确定性状态生成。\n\n#### 1. 递归规范\n\n递归方法是**分治**思想的直接应用。移动 $n$ 个盘子的问题可以被分解为更小的、自相似的子问题。\n\n设函数为 `HanoiRecursive(n, source, target, auxiliary)`，它生成将 $n$ 个盘子从 `source` 柱移动到 `target` 柱的移动序列。\n\n-   **基准情形：** 如果 $n=0$，则无需移动盘子。所需的移动序列为空。\n\n-   **递归步骤：** 对于 $n > 0$，过程如下：\n    1.  将顶部的 $n-1$ 个盘子从 `source` 柱移动到 `auxiliary` 柱，使用 `target` 柱作为临时存储。这是一个递归调用：`HanoiRecursive(n-1, source, auxiliary, target)`。\n    2.  将最大的盘子（即盘子 $n$）从 `source` 柱移动到 `target` 柱。这构成一次移动，表示为有序对 `(source, target)`。\n    3.  将 $n-1$ 个盘子从 `auxiliary` 柱移动到 `target` 柱，使用 `source` 柱作为临时存储。这是第二次递归调用：`HanoiRecursive(n-1, auxiliary, target, source)`。\n\n最终的移动序列是这三个步骤产生的序列的拼接。这种分解保证了约束条件永远不会被违反，因为最大的盘子 $n$ 仅在所有较小的盘子都在辅助柱上时才移动，从而使其源柱和目标柱为空闲状态，可供其移动。\n\n移动次数 $T(n)$ 遵循递推关系 $T(n) = 2T(n-1) + 1$，基准情形为 $T(0) = 0$。其闭式解为 $T(n) = 2^n - 1$，这可以通过数学归纳法证明，并且是可能的最少移动次数。\n\n#### 2. 迭代规范\n\n问题要求一个非递归的、确定性的算法，该算法能生成相同的最小移动序列。这可以通过观察移动序列中一个显著的模式，而无需搜索或回溯来实现。系统的状态可以通过一个简单的循环和算术运算，遍历所有 $2^n-1$ 次必要的移动。\n\n该算法依赖于跟踪三个柱子的状态，并在每一步中在特定的两根柱子之间执行唯一可能的合法移动。在给定步骤中涉及的柱子对以固定的三步周期交替。\n\n1.  初始化柱子数据结构。一个将柱子标签映射到列表（作为栈使用）的字典是合适的，其中 `source` 柱包含盘子 $[n, n-1, \\dots, 1]$。\n2.  根据 $n$ 的奇偶性确定移动柱子对的顺序。如果 $n$ 是偶数，柱子对的交替顺序为 `(source, auxiliary)`、`(source, target)`、`(auxiliary, target)`。如果 $n$ 是奇数，顺序则为 `(source, target)`、`(source, auxiliary)`、`(target, auxiliary)`。这可以通过设定一个有序的柱子三元组 `(p1, p2, p3)` 并循环在 `(p1, p2)`、`(p1, p3)` 和 `(p2, p3)` 之间移动来系统地实现。\n3.  从 $i$ 等于 $1$ 循环到 $2^n - 1$：在第 $i$ 步，根据 $i \\pmod 3$ 的值，选择上述三个柱子对中的一个，并执行其间唯一合法的移动。\n\n在两个柱子（例如柱 $U$ 和柱 $V$）之间的一次“合法移动”是通过比较它们顶部的盘子来确定的。设 $d_U$ 和 $d_V$ 为顶部盘子。\n-   如果一个柱子是空的（例如 $U$），则必须将盘子从 $V$ 移动到 $U$。\n-   否则，将两个盘子中较小的一个（$d_U$ 或 $d_V$）移动到较大的一个之上。\n这个规则为任何一对非空柱子确定性地定义了单次有效移动，满足了问题约束。该算法每步需要 $O(1)$ 时间来确定和记录移动，导致总时间复杂度与移动次数成正比，即 $O(2^n)$。\n\n#### 3. 合法性验证\n\n需要一个验证函数来确认生成的移动序列是合法的，并且能够达到目标状态。该函数模拟整个过程：\n\n1.  初始化配置，将 $n$ 个盘子放在源柱上。\n2.  遍历序列中的每次移动 $(u,v)$。对于每次移动：\n    a.  验证源柱 $u$ 不是空的。\n    b.  从柱 $u$ 弹出盘子 $d$。\n    c.  验证柱 $v$ 要么是空的，要么其顶部盘子比 $d$ 大。\n    d.  如果任一检查失败，则序列不合法。\n    e.  将盘子 $d$ 推入柱 $v$。\n3.  所有移动结束后，检查 `source` 和 `auxiliary` 柱是否为空，以及 `target` 柱是否包含所有 $n$ 个盘子并按正确的顺序排序，即 $[n, n-1, \\dots, 1]$。\n\n这个模拟过程为生成的序列的正确性提供了明确的检验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hanoi_recursive(n, source, target, auxiliary):\n    \"\"\"\n    Generates the sequence of moves for Towers of Hanoi using recursion.\n    Args:\n        n (int): The number of disks.\n        source (str): The label of the source peg.\n        target (str): The label of the target peg.\n        auxiliary (str): The label of the auxiliary peg.\n    Returns:\n        list: A list of (from_peg, to_peg) tuples representing the moves.\n    \"\"\"\n    if n > 0:\n        # Move n-1 disks from source to auxiliary.\n        moves1 = hanoi_recursive(n - 1, source, auxiliary, target)\n        # Move disk n from source to target.\n        move_n = [(source, target)]\n        # Move n-1 disks from auxiliary to target.\n        moves2 = hanoi_recursive(n - 1, auxiliary, target, source)\n        return moves1 + move_n + moves2\n    else:\n        return []\n\ndef perform_move(pegs, p1_label, p2_label):\n    \"\"\"\n    Helper function for the iterative solver. Performs the only legal\n    move between two pegs and returns the move as a tuple.\n    It modifies the pegs dictionary in place.\n    \"\"\"\n    s1 = pegs[p1_label]\n    s2 = pegs[p2_label]\n    \n    if not s1: # s1 is empty, so move from s2 to s1\n        disk = s2.pop()\n        s1.append(disk)\n        return p2_label, p1_label\n    elif not s2: # s2 is empty, so move from s1 to s2\n        disk = s1.pop()\n        s2.append(disk)\n        return p1_label, p2_label\n    elif s1[-1] > s2[-1]: # Top of s1 is a larger disk\n        disk = s2.pop()\n        s1.append(disk)\n        return p2_label, p1_label\n    else: # Top of s2 is a larger disk\n        disk = s1.pop()\n        s2.append(disk)\n        return p1_label, p2_label\n\ndef hanoi_iterative(n, source, target, auxiliary):\n    \"\"\"\n    Generates the sequence of moves for Towers of Hanoi using an iterative algorithm.\n    Args:\n        n (int): The number of disks.\n        source (str): The label of the source peg.\n        target (str): The label of the target peg.\n        auxiliary (str): The label of the auxiliary peg.\n    Returns:\n        list: A list of (from_peg, to_peg) tuples representing the moves.\n    \"\"\"\n    if n == 0:\n        return []\n\n    pegs = {\n        source: list(range(n, 0, -1)),\n        auxiliary: [],\n        target: []\n    }\n    \n    # The order of peg pairs depends on the parity of n.\n    # This logic sets up effective pegs p1, p2, p3 to handle the cycle.\n    if n % 2 == 0: # n is even, effective order is s->a, s->t, a->t\n        p1, p2, p3 = source, auxiliary, target\n    else: # n is odd, effective order is s->t, s->a, t->a\n        p1, p2, p3 = source, target, auxiliary\n        \n    total_moves = 2**n - 1\n    moves = []\n    \n    for i in range(1, total_moves + 1):\n        if i % 3 == 1:\n            from_p, to_p = perform_move(pegs, p1, p2)\n        elif i % 3 == 2:\n            from_p, to_p = perform_move(pegs, p1, p3)\n        else: # i % 3 == 0\n            from_p, to_p = perform_move(pegs, p2, p3)\n        moves.append((from_p, to_p))\n        \n    return moves\n\ndef verify_sequence(n, source, target, auxiliary, moves):\n    \"\"\"\n    Verifies if a sequence of moves is legal and solves the puzzle.\n    Args:\n        n (int): Number of disks.\n        source (str): Source peg label.\n        target (str): Target peg label.\n        auxiliary (str): Auxiliary peg label.\n        moves (list): The sequence of moves to verify.\n    Returns:\n        bool: True if the sequence is valid, False otherwise.\n    \"\"\"\n    if n == 0:\n        return len(moves) == 0\n\n    pegs = {\n        source: list(range(n, 0, -1)),\n        auxiliary: [],\n        target: []\n    }\n    \n    for from_p, to_p in moves:\n        # Check for invalid move from an empty peg\n        if not pegs.get(from_p) or not pegs[from_p]:\n            return False\n        \n        disk = pegs[from_p].pop()\n        \n        # Check rule: no larger disk on a smaller disk\n        if pegs.get(to_p) and pegs[to_p] and pegs[to_p][-1]  disk:\n            return False\n            \n        pegs[to_p].append(disk)\n        \n    # Check final state\n    goal_state = list(range(n, 0, -1))\n    if pegs[source] == [] and pegs[auxiliary] == [] and pegs[target] == goal_state:\n        return True\n    else:\n        return False\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite format: (n, source_label, auxiliary_label, target_label)\n    test_cases = [\n        (0, \"S\", \"A\", \"T\"),\n        (1, \"S\", \"A\", \"T\"),\n        (2, \"S\", \"A\", \"T\"),\n        (3, \"X\", \"Y\", \"Z\"),\n        (4, \"S\", \"A\", \"T\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, s, a, t = case\n        \n        # Consistent parameter order (n, source, target, auxiliary) for both functions\n        rec_moves = hanoi_recursive(n, s, t, a)\n        iter_moves = hanoi_iterative(n, s, t, a)\n        \n        # E: Check if recursive and iterative sequences are identical\n        are_equal = (rec_moves == iter_moves)\n        \n        # L: Length of the move sequence\n        num_moves = len(rec_moves)\n        \n        # G: Check if the sequence is legal and reaches the goal state\n        is_good = verify_sequence(n, s, t, a, rec_moves)\n        \n        results.append([are_equal, num_moves, is_good])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205878"}]}