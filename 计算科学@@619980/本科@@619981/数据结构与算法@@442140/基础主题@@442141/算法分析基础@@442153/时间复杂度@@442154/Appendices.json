{"hands_on_practices": [{"introduction": "理论是实践的向导，而动手实践则是检验和深化理论理解的唯一途径。在时间复杂度的学习中，掌握递归关系式的求解是分析分治算法性能的核心技能。虽然主定理为许多常见递归式提供了快捷的求解方式，但其适用范围有限。这个练习 [@problem_id:3279114] 恰好展示了一个主定理无法直接解决的案例，迫使我们回归到更根本的递归树方法或迭代展开法。通过解决这个问题，你将不仅仅得到一个答案，更重要的是，你将掌握处理非标准递归式的分析能力，从而更深刻地理解分治算法的成本是如何逐层累积的。", "problem": "考虑一个分治 (D&C) 过程，其运行时间由以下递推关系式描述：\n$$T(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+\\frac{n}{\\ln n},$$\n对于所有为2的幂的整数输入 $n \\geq 2$，其基本情况为 $T(1)=\\Theta(1)$。这里的 $\\ln$ 表示自然对数。在标准分析中，主定理 (MT) 无法直接处理非递归工作项为 $f(n)=n/\\ln n$ 的情况。\n\n从渐近增长的核心定义和分治递推的结构出发，并仅使用经过充分检验的分析工具（如严格的递归树求和与积分近似论证），推导当 $n \\to \\infty$ 时 $T(n)$ 的紧渐近增长阶。请用一个包含 $n$ 和初等函数的标准复杂度类表达式来表示你的最终答案。无需进行数值舍入。", "solution": "所述问题是有效的。这是一个在算法分析领域内的适定数学问题。它具有科学依据、是客观的，并包含了推导出唯一解所需的所有必要信息。标准主定理的不适用性被正确地指出了，这表明该问题需要一种更基本的分析，而这正是题目所要求的。\n\n我们的任务是求解以下递推关系的紧渐近增长阶：\n$$T(n) = 2 T\\left(\\frac{n}{2}\\right) + \\frac{n}{\\ln n}$$\n其基本情况为 $T(1) = \\Theta(1)$，适用于为2的整数次幂的 $n$ 值，即 $n=2^k$（其中 $k$ 为某个整数 $k \\ge 0$）。\n\n我们将使用递归树方法来求解这个递推关系。设 $n=2^k$，这意味着 $k = \\log_2(n)$。递归树的深度为 $k$。\n\n在递归树的每一层 $i$（根节点在第 $i=0$ 层），有 $2^i$ 个子问题。在第 $i$ 层，每个子问题的规模是 $n_i = n/2^i$。在第 $i$ 层的每个节点上完成的工作（不包括递归调用）是 $f(n_i) = \\frac{n_i}{\\ln n_i}$。\n\n第 $i$ 层的总工作量是节点数乘以每个节点的工作量：\n$$\\text{Work at level } i = 2^i \\times f\\left(\\frac{n}{2^i}\\right) = 2^i \\times \\frac{n/2^i}{\\ln(n/2^i)} = \\frac{n}{\\ln(n) - i \\ln(2)}$$\n总运行时间 $T(n)$ 是树的所有层级（从根节点第0层到叶节点前一层第 $k-1$ 层）的工作量之和，再加上叶节点（第 $k$ 层）的工作量。\n\n叶节点的数量是 $2^k = n$。每个叶节点的问题规模是 $n/2^k = 1$。每个叶节点的成本是 $T(1) = \\Theta(1)$。因此，叶节点的总成本是 $n \\times T(1) = \\Theta(n)$。\n\n总的非递归工作量是从第 $i=0$ 层到第 $k-1$ 层的工作量之和：\n$$\\sum_{i=0}^{k-1} \\frac{n}{\\ln(n) - i \\ln(2)}$$\n为了简化这个和式，我们代入 $\\ln(n) = \\ln(2^k) = k \\ln(2)$：\n$$\\text{Sum} = \\sum_{i=0}^{k-1} \\frac{n}{k \\ln(2) - i \\ln(2)} = \\frac{n}{\\ln(2)} \\sum_{i=0}^{k-1} \\frac{1}{k-i}$$\n我们对求和索引进行变换。令 $j = k-i$。当 $i$ 从 $0$ 遍历到 $k-1$ 时，$j$ 从 $k$ 递减到 $1$。和式变为：\n$$\\text{Sum} = \\frac{n}{\\ln(2)} \\sum_{j=1}^{k} \\frac{1}{j}$$\n求和项 $\\sum_{j=1}^{k} \\frac{1}{j}$ 是第 $k$ 个调和数，记作 $H_k$。一个公认的结果是，对于大的 $k$，调和级数具有以下渐近行为：\n$$H_k = \\ln(k) + \\gamma + O\\left(\\frac{1}{k}\\right)$$\n其中 $\\gamma$ 是欧拉-马歇罗尼常数。因此，$H_k = \\Theta(\\ln k)$。\n\n将此结果代回非递归工作量的表达式中：\n$$\\text{Sum} = \\frac{n}{\\ln(2)} H_k = \\frac{n}{\\ln(2)} \\Theta(\\ln k) = \\Theta(n \\ln k)$$\n总运行时间 $T(n)$ 是叶节点成本和非递归工作量之和：\n$$T(n) = \\Theta(n) + \\Theta(n \\ln k)$$\n当 $n \\to \\infty$ 时，$k = \\log_2(n) \\to \\infty$。由于 $\\ln(k)$ 是 $k$ 的增长函数，因此 $\\Theta(n \\ln k)$ 项主导了 $\\Theta(n)$ 项。\n因此，$T(n)$ 的渐近行为由下式给出：\n$$T(n) = \\Theta(n \\ln k)$$\n最后，我们必须用 $n$ 来表示这个结果。我们代入 $k = \\log_2(n)$：\n$$T(n) = \\Theta(n \\ln(\\log_2 n))$$\n我们可以简化对数项。使用对数换底公式，$\\log_2(n) = \\frac{\\ln(n)}{\\ln(2)}$：\n$$\\ln(\\log_2 n) = \\ln\\left(\\frac{\\ln n}{\\ln 2}\\right) = \\ln(\\ln n) - \\ln(\\ln 2)$$\n当 $n \\to \\infty$ 时，$\\ln(\\ln n) \\to \\infty$，而 $\\ln(\\ln 2)$ 是一个负常数。因此，$\\ln(\\ln n)$ 项占主导地位。这意味着 $\\ln(\\log_2 n) = \\Theta(\\ln(\\ln n))$。\n\n将这个最终的简化结果代入我们关于 $T(n)$ 的表达式中：\n$$T(n) = \\Theta(n \\cdot \\Theta(\\ln(\\ln n))) = \\Theta(n \\ln(\\ln n))$$\n这就是给定递推关系的紧渐近增长阶。", "answer": "$$\\boxed{\\Theta(n \\ln(\\ln n))}$$", "id": "3279114"}, {"introduction": "在算法设计的世界里，效率和正确性是评估一个算法优劣的两个关键维度。一个运行速度极快的算法如果不能给出正确的答案，那么它的价值便大打折扣。0/1 背包问题的贪心算法分析 [@problem_id:3279100] 就是一个绝佳的案例，它生动地揭示了这一点。这个练习不仅要求你准确分析一个包含排序和线性扫描的算法的时间复杂度，更重要的是，它通过一个经典的反例，让你理解为什么直观上看似合理的贪心策略（按价值密度比优先选取）对于 0/1  背包问题是无效的。这种批判性思维是从“会用算法”到“会设计和评估算法”的关键一步。", "problem": "考虑一个有 $n$ 个物品的 $0/1$ 背包问题，其中物品 $i$ 的重量 $w_i$ 和价值 $v_i$ 均为正整数，背包的容量为 $W$。一个常见的贪心启发式算法是：计算每个物品的价值重量比 $r_i = v_i / w_i$，按 $r_i$ 的非递增顺序对物品进行排序，然后按此顺序扫描一次，当且仅当一个物品能够放入且不超过剩余容量时才将其加入，否则跳过。仅使用渐进时间复杂度的基本定义、基于比较的排序模型以及对此贪心过程的精确描述，确定哪个陈述最能描述此贪心启发式算法的渐进时间复杂度，并给出一个具体原因说明它在一般情况下不能最优地解决 $0/1$ 背包问题。\n\n选择唯一最佳选项。\n\nA. 贪心启发式算法需要按 $r_i$ 排序，在基于比较的排序模型下这需要 $\\mathcal{O}(n \\log n)$ 的时间，然后是一次 $\\mathcal{O}(n)$ 时间的线性扫描，总时间为 $\\mathcal{O}(n \\log n)$。对于 $0/1$ 情况，它不是最优的；例如，当 $W = 50$，物品为 $(w,v) \\in \\{(10,60),(20,100),(30,120)\\}$ 时，按价值重量比的贪心顺序是 $(10,60)$，然后是 $(20,100)$，再然后是 $(30,120)$，得到的价值为 $60+100=160$，而最优解是选择 $(20,100)$ 和 $(30,120)$，价值为 $220$。\n\nB. 贪心启发式算法运行时间为 $\\mathcal{O}(n)$，因为它只进行一次扫描，并且当所有比率 $r_i$ 都不同时，它是最优的，因为此时顺序是唯一确定的。\n\nC. 贪心启发式算法运行时间为 $\\mathcal{O}(n \\log n)$，且仅当比率 $r_i$ 存在相同时才不是最优的；如果所有 $r_i$ 都不同，则它是最优的。\n\nD. 贪心启发式算法运行时间为 $\\mathcal{O}(n^2)$，因为它必须考虑多种组合，并且即使在小规模输入上也会失败；例如，当 $W = 50$，物品为 $(w,v) \\in \\{(10,60),(20,100),(30,120)\\}$ 时，该启发式算法首先因其最高比率而选择 $(30,120)$，然后无法再选择任何其他物品，得到价值 $120$，但最优价值是 $220$。", "solution": "我们从基本原理开始分析。$0/1$ 背包问题提供了一组 $n$ 个物品，其重量为 $w_i$，价值为 $v_i$，以及一个容量为 $W$ 的背包。所描述的贪心启发式算法计算 $r_i = v_i / w_i$，按 $r_i$ 的非递增顺序对物品进行排序，然后进行一次扫描，如果物品能放入剩余容量，就将其拿取。\n\n时间复杂度分析：\n- 为所有 $i \\in \\{1,\\dots,n\\}$ 计算 $r_i$ 需要 $\\mathcal{O}(n)$ 次算术运算。\n- 在基于比较的模型中，根据基于比较排序的经典下界，按实值键 $r_i$ 对 $n$ 个物品进行排序，在最坏情况下需要 $\\Omega(n \\log n)$ 次比较，而标准算法（如归并排序或堆排序）可以达到 $\\mathcal{O}(n \\log n)$。因此，排序步骤的时间复杂度是 $\\Theta(n \\log n)$。\n- 随后尝试添加每个物品的单次扫描是 $\\mathcal{O}(n)$。\n综合这些，总时间复杂度由排序步骤主导，为 $\\mathcal{O}(n \\log n)$。\n\n为什么该启发式算法对于 $0/1$ 情况不是最优的：\n按价值重量比的贪心选择对于分数背包问题（其中可以拿取物品的任意一部分）是可证最优的，因为交换论证表明，任何偏离非递增比率顺序的解都不能提高总价值。然而，在 $0/1$ 变体中，物品是不可分割的，因此交换论证不再成立。一个标准的反例表明，即使在比率都不同的情况下，该算法也会失败。\n\n考虑 $W = 50$ 和三个物品：\n- 物品 1：$(w_1,v_1) = (10,60)$，其 $r_1 = 60/10 = 6$。\n- 物品 2：$(w_2,v_2) = (20,100)$，其 $r_2 = 100/20 = 5$。\n- 物品 3：$(w_3,v_3) = (30,120)$，其 $r_3 = 120/30 = 4$。\n\n按价值重量比的贪心顺序是物品 1、物品 2、然后是物品 3。该启发式算法拿取物品 1（剩余容量 $40$），拿取物品 2（剩余容量 $20$），并且无法拿取物品 3（因为会超过 $W$）。总价值为 $60 + 100 = 160$。而最优的 $0/1$ 解是拿取物品 2 和物品 3，总重量为 $20 + 30 = 50$，总价值为 $100 + 120 = 220$，这严格大于 $160$。因此，该贪心启发式算法未能产生最优解。\n\n逐项分析选项：\n- 选项 A：它指出了排序步骤和单次扫描，得出总时间为 $\\mathcal{O}(n \\log n)$。这与上面的推导相符。它提供了 $W = 50$ 和物品 $(10,60)$, $(20,100)$, $(30,120)$ 的明确反例，并正确解释了贪心选择和更优的最优解。结论 — 正确。\n\n- 选项 B：它声称时间复杂度为 $\\mathcal{O}(n)$。这忽略了按 $r_i$ 排序的必要性，在基于比较的模型中这需要 $\\Omega(n \\log n)$ 的时间。此外，当比率不同时算法最优的说法是错误的：上面的反例具有不同的比率 $6$, $5$ 和 $4$，但该启发式算法仍然不是最优的。结论 — 错误，无论是在时间复杂度还是最优性方面。\n\n- 选项 C：它给出了正确的 $\\mathcal{O}(n \\log n)$ 时间，但断言只有在 $r_i$ 比率存在相同时才会失败。如上所示，即使所有 $r_i$ 都不同，失败也会发生。结论 — 错误。\n\n- 选项 D：它声称时间复杂度为 $\\mathcal{O}(n^2)$，这与 $\\mathcal{O}(n \\log n)$ 的分析相矛盾。其所称的反例也错误地识别了贪心选择：比率为 $6$, $5$ 和 $4$ 时，该启发式算法不会首先选择 $(30,120)$；它会首先选择 $(10,60)$。因此，其时间复杂度和所描述的行为都是不正确的。结论 — 错误。", "answer": "$$\\boxed{A}$$", "id": "3279100"}, {"introduction": "我们通常分析的是某个“给定”算法的时间复杂度，但这引出了一个更深层次的问题：解决一个特定问题本身，是否存在一个固有的、无法逾越的复杂度下界？也就是说，无论算法设计得多么巧妙，其最坏情况下的性能能否无限优化？这个问题引出了“问题复杂度下界”的概念。这个练习 [@problem_id:3279201] 将带领你探索如何在一个仅允许成对比较的计算模型中，为“找到第二小元素”这一问题推导出一个精确的比较次数下界。通过精巧的“锦标赛”比喻和“对手”论证，你将学会如何从信息论的角度思考问题，证明任何算法都必须付出的最小代价，这标志着你对算法复杂度的理解从分析“算法”提升到了分析“问题”的高度。", "problem": "考虑一个算法，它只能通过成对比较来访问一个包含 $n$ 个元素的数组，每次查询都询问一个元素是否小于另一个元素。假设所有元素都是不同的，并且来自一个严格全序集，该算法是自适应的：它可以根据先前比较的结果选择接下来要比较的元素对。在这种仅比较的设置中，我们将查询复杂度衡量为在所有输入上保证正确性所需的最坏情况下的成对比较次数。\n\n从比较决策树（CDT）的基本原理出发，其中每次比较产生一位信息，一个算法对应于一个二叉决策树，其叶子代表与正确识别相一致的结果，并利用经过验证的事实，即高度为 $h$ 的二叉树最多有 $2^{h}$ 个叶子，以及仅通过比较从 $k$ 个元素中选出最小值至少需要 $k-1$ 次比较，推导出识别数组中第二小元素所需的最坏情况下最少成対比较次数的紧确界。你的答案必须是一个关于 $n$ 的单一闭式解析表达式。不需要取整。", "solution": "用户希望推导出在包含 $n$ 个不同元素的数组中识别第二小元素所需的最坏情况下最少成对比较次数的紧确界。\n\n### 第一步：问题验证\n\n问题陈述已经过验证，被认为是有效的。这是一个在算法分析领域内定义明确、有科学依据且客观的问题。它提供了足够的信息和清晰的定义，可以进行形式化推导。所提供的关于比较决策树和寻找最小值复杂度的 Factual Information 是正确的，并为推导提供了坚实的基础。\n\n### 第二步：推导紧确界\n\n推导过程分为两部分：首先，通过构建一个算法来确定一个上界；其次，证明一个任何基于比较的算法都必须遵守的匹配下界。\n\n#### 上界\n\n我们可以通过首先确定最小元素 $S_1$ 来找到第二小元素，我们将其表示为 $S_2$。\n\n1.  **寻找最小值 ($S_1$)**：我们可以将寻找最小元素的过程建模为单淘汰赛。$n$ 个元素是参赛者。我们将它们配对进行比较。获胜者进入下一轮。这个过程一直持续到只剩下一个总冠军。这个冠军就是最小元素 $S_1$。在这样的锦标赛中，除了冠军之外的每个元素都必须恰好输掉一场比赛。由于每次比较产生一个失败者，因此确定 $S_1$ 需要进行恰好 $n-1$ 次比较。\n\n2.  **确定第二小值 ($S_2$) 的候选者**：第二小元素 $S_2$ 必定在某次比较中输给了另一个元素。如果 $S_2$ 输给了元素 $x$，那么必然有 $x = S_1$。如果 $x$ 是任何其他元素，我们就会得到关系 $S_1 < x < S_2$，这意味着 $S_2$ 至少是第三小的元素，这与假设矛盾。因此，$S_2$ 必须是那些曾与 $S_1$ 直接比较并落败的元素之一。\n\n3.  **寻找第二小值 ($S_2$)**：设 $K$ 是在锦标赛期间直接输给 $S_1$ 的元素集合。第二小元素 $S_2$ 就是集合 $K$ 中的最小元素。\n    $K$ 中元素的数量，我们记为 $|K|$，是 $S_1$ 在成为锦标赛冠军的路径上遇到并击败的对手数量。在一个平衡的锦标赛结构中，冠军参与 $\\lceil \\log_2(n) \\rceil$ 次比较。因此，在最坏情况下（对于 $K$ 的大小而言），$|K| = \\lceil \\log_2(n) \\rceil$。\n    要找到集合 $K$ 的最小元素，我们还需要 $|K|-1$ 次额外的比较。\n\n4.  **总比较次数（上界）**：该算法的总比较次数是第1步和第3步比较次数的总和：\n    $$ C_{\\text{upper}} = (n-1) + (|K|-1) $$\n    在该算法的最坏情况下， $|K| = \\lceil \\log_2(n) \\rceil$。\n    $$ C_{\\text{upper}} = (n-1) + (\\lceil \\log_2(n) \\rceil - 1) = n + \\lceil \\log_2(n) \\rceil - 2 $$\n    这就确定了所需比较次数的一个上界。\n\n#### 下界\n\n我们现在为*任何*找到第二小元素的基于比较的算法推导其最坏情况复杂度的下界。\n\n1.  **所需信息**：任何正确的算法都必须获取足够的信息来证明其输出。为了证明元素 $y$是 $S_2$，算法必须已经确定：\n    a. 恰好有一个元素 $S_1$ 小于 $y$。\n    b. 所有其他 $n-2$ 个元素都大于 $y$。\n\n2.  **计算必要的比较结果**：\n    - **寻找 $S_1$**：为了确定元素 $S_1$ 是最小值，其他每个元素 $x$ 都必须被证明比至少一个其他元素大（即，必须至少输掉一次比较）。每次比较只有一个失败者，因此为了确保 $n-1$ 个不同的元素都输过，至少需要 $n-1$ 次比较。\n    - **寻找 $S_2$**：如前所述，$S_2$ 必须在直接输给 $S_1$ 的元素集合 $K$ 中。设 $|K| = k$。为了将 $S_2$ 识别为集合 $K$ 中的最小值，算法必须确定 $S_2$ 小于 $K$ 中的其他 $k-1$ 个元素。证明这一点至少需要 $K$ 中元素之间的 $k-1$ 次比较。\n\n3.  **组合需求**：让我们考虑总比较次数 $C$。\n    - 一次比较 $(x,y)$，其中 $x$ 和 $y$ 都不是 $S_1$，为其中一个元素确立了一次失败。为了确保不在 $\\{S_1\\} \\cup K$ 中的 $n-1-k$ 个元素被识别为非最小值，必须发生至少 $n-1-k$ 次这样的比较，让它们失败。\n    - $K$ 中的 $k$ 个元素必须输给 $S_1$。这需要恰好 $k$ 次形如 $(S_1, y)$ 的比较，其中 $y \\in K$。\n    - $K \\setminus \\{S_2\\}$ 中的 $k-1$ 个元素必须被证明大于 $S_2$。这至少需要 $K$ 中元素之间的 $k-1$ 次比较。\n\n    从这三种必要的事件类型中获得的信息是不同的。类型为 $(S_1, y)$ 的比较确认了 $y \\in K$。类型为 $(y_i, y_j)$ 的比较（其中 $y_i, y_j \\in K$）建立了 $K$ 内部的顺序，这对于找到其最小值是必要的。这种排序信息并非由涉及 $S_1$ 的比较提供。因此，我们可以将这些不同信息需求所需的最小比较次数相加，得到总比较次数的下界。\n    $$ C_{\\text{lower}} \\ge (n-1-k) + k + (k-1) = n + k - 2 $$\n    这个下界取决于 $k$，即直接输给最终最小值 $S_1$ 的元素数量。\n\n4.  **为 $k$ 寻找下界**：表达式 $n+k-2$ 为给定的 $k$ 提供了一个下界。为了获得一个通用的复杂度下界，我们必须确定无论算法策略如何，对手（adversary）能强制产生的最小 $k$ 值。\n    元素数量 $k$ 对应于 $S_1$ 赢得的比较次数。在赢得 $k$ 次后，一个元素最多可以被证明比 $2^k-1$ 个其他元素小（这种情况发生在该元素赢得一个大小为 $2^k$ 的完美平衡锦标赛时）。要被证明为 $n$ 个元素中的最小值，一个元素必须被证明比所有其他 $n-1$ 个元素都小。抽象地说，$n-1$ 个失败者的集合必须被划分到直接输给 $S_1$ 的 $k$ 个元素中。这 $k$ 个直接失败者中的每一个都是一个由被击败元素组成的子树的“胜利者”。一个元素在没有任何胜利的情况下，最多可以是一组 $2^0=1$ 个元素（其自身）的胜利者。赢得一次，它可以是 $2^1=2$ 个元素的胜利者。赢得 $c$ 次，它最多可以是 $2^c$ 个元素的胜利者。冠军 $S_1$ 必须“征服”一个包含所有 $n$ 个元素的层次结构。直接对手的数量 $k$ 是其冠军被 $S_1$ 击败的子锦标赛的数量。为了覆盖 $n$ 个元素，我们必须有 $2^k \\ge n$。\n    这意味着 $k \\ge \\log_2(n)$。由于 $k$ 必须是整数，我们有：\n    $$ k \\ge \\lceil \\log_2(n) \\rceil $$\n    任何算法都可能被对手强制使其最终的冠军至少进行 $\\lceil \\log_2(n) \\rceil$ 场比赛。\n\n5.  **最终下界**：将 $k$ 的最小可能值代入我们的 $C$ 的下界表达式中：\n    $$ C_{\\text{lower}} \\ge n + \\lceil \\log_2(n) \\rceil - 2 $$\n\n#### 结论\n\n比较次数的上界是 $n + \\lceil \\log_2(n) \\rceil - 2$，并且任何算法的最坏情况下的下界也是 $n + \\lceil \\log_2(n) \\rceil - 2$。由于上界和下界相匹配，这就是紧确的最坏情况复杂度。", "answer": "$$\n\\boxed{n + \\lceil \\log_2(n) \\rceil - 2}\n$$", "id": "3279201"}]}