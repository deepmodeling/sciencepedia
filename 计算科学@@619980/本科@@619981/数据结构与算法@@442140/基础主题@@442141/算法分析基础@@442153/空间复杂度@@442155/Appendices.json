{"hands_on_practices": [{"introduction": "理论上的空间复杂度分析通常使用大 $O$ 表示法，但在实际的工程应用中，例如在高性能金融交易系统中，精确计算内存占用对于性能调优和容量规划至关重要。这个练习旨在弥合抽象分析与具体实现之间的鸿沟，它要求你基于一个常见数据结构的具体实现细节——包括元素大小、元数据开销和动态数组的扩容策略——来推导出其精确的内存使用量 [@problem_id:3272546]。", "problem": "一个电子拍卖撮合引擎使用两个二叉堆（BH）来维护一个限价订单簿，一个堆用于买单，一个堆用于卖单。每个二叉堆都实现为一个连续的动态数组，用于内联存储订单记录。该动态数组具有以下调整大小的策略：它以 $16$ 个元素的初始容量开始，并且每当满时，其容量就会加倍。在任何时刻，容量都是2的幂，并且至少是堆中当前的元素数量。每个堆的动态数组元数据由恰好三个 $64$ 位字段组成：一个指向底层缓冲区的指针、逻辑大小和容量，每个堆的元数据总共为 $24$ 字节。该系统在具有字节寻址功能的随机存取存储器（RAM）上运行，所有内存使用都应以字节为单位进行度量。\n\n存储在堆中的每个订单记录都是一个普通旧数据（POD）结构体，包含以下字段：\n- $64$ 位订单标识符（$8$ 字节）。\n- $64$ 位时间戳（$8$ 字节）。\n- $64$ 位以整数tick为单位的价格（$8$ 字节）。\n- $32$ 位数量（$4$ 字节）。\n- $32$ 位交易员标签（$4$ 字节）。\n\n假设没有每个元素的指针开销，没有需要考虑的外部碎片，也没有超出所述堆元数据的分配器记账。假设在给定的快照中，买单堆中恰好有 $N$ 个买单，卖单堆中恰好有 $M$ 个卖单。\n\n仅使用基于数组的堆的空间复杂度的基本定义以及上述实现细节，推导出一个单一的封闭形式解析表达式，用于表示存储两个堆所使用的总内存（以字节为单位），该表达式是 $N$ 和 $M$ 的函数。请用字节表示您的最终答案。不要提供不等式；请提供精确的表达式。无需进行四舍五入。", "solution": "该问题要求推导一个封闭形式的解析表达式，用于表示两个二叉堆（一个用于买单，一个用于卖单）所消耗的总内存，该表达式是它们所包含订单数量（分别表示为 $N$ 和 $M$）的函数。推导过程将首先确定单个订单记录的内存占用，然后确定单个堆的内存使用情况，最后将两个堆的内存使用量相加。\n\n首先，我们确定单个订单记录的大小。问题指明每个记录都是一个由五个字段组成的普通旧数据（POD）结构体。一个记录的总大小（我们表示为 $S_{rec}$）是其组成字段大小的总和。\n这些字段是：\n- $64$ 位订单标识符：$64 \\text{ bits} / 8 \\frac{\\text{bits}}{\\text{byte}} = 8$ 字节\n- $64$ 位时间戳：$8$ 字节\n- $64$ 位价格：$8$ 字节\n- $32$ 位数量：$32 \\text{ bits} / 8 \\frac{\\text{bits}}{\\text{byte}} = 4$ 字节\n- $32$ 位交易员标签：$4$ 字节\n\n将这些大小相加，得出单个订单记录的总大小：\n$$S_{rec} = 8 + 8 + 8 + 4 + 4 = 32 \\text{ bytes}$$\n问题声明假设没有填充，这与这些数据类型在 $64$ 位架构上的标准对齐方式一致，因此总大小为 $32$ 字节。\n\n接下来，我们分析单个堆结构的内存使用情况。一个堆的总内存是其元数据所用内存和为其底层动态数组缓冲区分配的内存之和。\n问题指明每个堆的元数据由三个 $64$ 位字段组成，总共 $3 \\times 8 = 24$ 字节。我们将这个固定的元数据大小表示为 $S_{meta}$。\n$$S_{meta} = 24 \\text{ bytes}$$\n\n动态数组缓冲区的大小取决于其容量，而不是其逻辑大小（当前持有的元素数量）。容量受一组特定规则的约束：\n1.  初始容量为 $16$ 个元素。\n2.  容量始终是2的幂。\n3.  容量始终至少是堆中的元素数量。\n4.  当数组满时，其容量加倍。\n\n设 $k$ 为给定堆中的元素数量。我们必须找到一个满足所有这些条件的容量表达式 $C(k)$。问题要求一个精确的表达式，这意味着容量是满足所有约束的最小可能值，这是对此类数据结构进行空间复杂度分析时的标准假设。\n容量必须是2的幂，即 $C(k) = 2^p$，其中 $p$ 为某个整数。\n容量必须至少为 $k$，所以 $C(k) \\ge k$。\n容量还必须至少为初始容量 $16$，所以 $C(k) \\ge 16$。\n综合这些条件，容量必须是大于或等于 $k$ 和 $16$ 的最小的2的幂。这可以表示为找到大于或等于 $\\max(k, 16)$ 的最小的2的幂。\n\n这可以用数学方式表达。对于任何正整数 $x$，大于或等于 $x$ 的最小的2的幂由表达式 $2^{\\lceil \\log_2(x) \\rceil}$ 给出。这个公式适用于我们的容量函数。我们必须处理对数的参数为零的情况。我们来分析当 $k \\ge 0$ 时 $\\max(k, 16)$ 的行为：\n- 如果 $k=0$，则 $\\max(0, 16) = 16$。\n- 如果 $1 \\le k \\le 16$，则 $\\max(k, 16) = 16$。\n- 如果 $k > 16$，则 $\\max(k, 16) = k$。\n对数的参数 $\\max(k, 16)$ 总是至少为 $16$，因此它总是正数。因此，容量函数 $C(k)$ 为：\n$$C(k) = 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n这个单一表达式正确地捕捉了对于任意元素数量 $k \\ge 0$ 时的容量。\n\n为缓冲区分配的内存 $S_{buffer}(k)$ 是容量乘以每个元素的大小：\n$$S_{buffer}(k) = C(k) \\times S_{rec} = 32 \\times 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n\n包含 $k$ 个元素的单个堆的总内存 $M_{heap}(k)$ 是元数据和缓冲区大小的总和：\n$$M_{heap}(k) = S_{meta} + S_{buffer}(k) = 24 + 32 \\times 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n\n最后，我们计算包含 $N$ 个订单的买单堆和包含 $M$ 个订单的卖单堆的总内存 $M_{total}$。这是每个堆所用内存的总和。\n$$M_{total}(N, M) = M_{heap}(N) + M_{heap}(M)$$\n$$M_{total}(N, M) = \\left( 24 + 32 \\times 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} \\right) + \\left( 24 + 32 \\times 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)$$\n合并各项，我们得到最终的封闭形式解析表达式：\n$$M_{total}(N, M) = 48 + 32 \\left( 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} + 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)$$\n该表达式表示以字节为单位的总内存，是 $N$ 和 $M$ 的函数，并符合问题的所有规范。", "answer": "$$\\boxed{48 + 32 \\left( 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} + 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)}$$", "id": "3272546"}, {"introduction": "这是一个经典的算法问题，它展示了一种强大的空间优化技术——位图（bitmap）。当我们要处理的数据范围已知且有界时，我们常常可以通过牺牲通用性来换取极高的内存效率。这个练习挑战你跳出直接使用哈希集合等标准数据结构的思维定式，从第一性原理出发，通过位操作来设计一个满足极度严苛内存限制的解决方案 [@problem_id:3272560]，它突显了理解数据的比特和字节级别表示对于实现巨大性能优化的重要性。", "problem": "给定一个从已知固定范围 $[1,K]$（其中 $K$ 是一个正整数）中抽取的整数流。任务是设计并实现一个算法，在随机存取机器 (RAM) 模型（Random Access Machine (RAM) 定义为一种计算模型，其中内存是单元的线性数组，对字 (word) 的基本操作耗时为常数时间）的意义下，该算法使用最多 $K/8 + O(1)$ 字节的内存来统计流中出现的不同整数的数量。您的算法必须从第一性原理出发，从空间复杂度、位和字节的基本定义以及 RAM 模型的约束开始推导。您必须论证内存使用上限和计数方法的正确性。\n\n需使用的基本原理：\n- 空间复杂度定义为函数 $S(n)$，它将输入大小 $n$ 映射到算法使用的内存单元数量，不包括常数时间寄存器。\n- 位 (bit) 是可以取值为 $0$ 或 $1$ 的基本信息单位；字节 (byte) 恰好是 $8$ 位。\n- 在随机存取机器 (RAM) 模型中，读写一个字是常数时间操作，内存使用量按分配的字数（或在使用子字封装时，按分配的位数或字节数）计算。\n\n算法要求：\n- 假设数据流中的每个元素都保证是 $[1,K]$ 范围内的整数，尽管数据流可能包含重复项，且其长度是任意的且预先未知。\n- 设计一种方法，使用位数组来跟踪存在性，其中每个位精确对应 $[1,K]$ 中的一个值。\n- 为表示存在性结构而分配的总辅助内存必须恰好是 $\\lceil K/8 \\rceil$ 字节，外加 $O(1)$ 个额外变量。您必须解释为什么这满足 $K/8 + O(1)$ 字节的要求。\n- 处理完数据流后，必须通过对存在性结构中设置为 $1$ 的位数求和来计算不同整数的数量。\n- 从值 $x \\in [1,K]$ 到其位位置的映射必须被清晰地指定和论证。\n\n程序要求：\n- 在一个无需用户输入的单个完整程序中实现该算法。\n- 使用一个紧凑的字节级结构来存储位，其中为存在性结构分配的字节数是 $\\lceil K/8 \\rceil$。\n- 对于计算设置为 $1$ 的位数，使用一种在字节粒度上操作并对每个字节中的 $1$ 的数量求和的方法。\n\n测试套件：\n您的程序必须嵌入并处理以下测试用例。对于每个测试用例，输入是一个序对 $(K,\\text{stream})$，其中 $K$ 是已知的最大值，$\\text{stream}$ 是要处理的序列。对于每种情况，输出观察到的不同整数的数量。\n1. $K=20$，$\\text{stream}=[1,3,3,5,20,20,2,2,2]$。\n2. $K=1$，$\\text{stream}=[1,1,1]$。\n3. $K=10$，$\\text{stream}=[10,9,8,1,2,2]$。\n4. $K=16$，$\\text{stream}=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,2,3,4]$。\n5. $K=32$，$\\text{stream}=[]$（空流）。\n6. $K=1000$，$\\text{stream}=[1,1000,500,500,250,750,250,999,2,2,3,4,4,10]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，以逗号分隔的列表形式并用方括号括起来，顺序与上面的测试用例相同。例如，输出必须形如 $[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_6]$，其中每个 $\\text{result}_i$ 是一个整数。", "solution": "对用户提供的问题陈述进行严格验证。\n\n### 第 1 步：提取已知条件\n- **输入：** 一个整数流。\n- **数据域：** 整数从一个已知的固定范围 $[1,K]$ 中抽取，其中 $K$ 是一个正整数。\n- **任务：** 统计流中出现的不同整数的数量。\n- **内存约束：** 算法必须最多使用 $K/8 + O(1)$ 字节的内存。\n- **计算模型：** 随机存取机器 (RAM)，其中内存是线性数组，基本操作耗时为常数时间。\n- **定义：**\n    - 空间复杂度 $S(n)$：对于大小为 $n$ 的输入，算法使用的内存单元数量，不包括常数时间寄存器。\n    - $1$ 字节恰好是 $8$ 位。\n- **算法要求：**\n    1. 必须使用位数组来跟踪每个整数的存在性。\n    2. 每个位必须精确对应 $[1,K]$ 中的一个值。\n    3. 用于存在性结构的总辅助内存必须恰好是 $\\lceil K/8 \\rceil$ 字节。\n    4. 总内存使用量必须是 $\\lceil K/8 \\rceil$ 字节加上 $O(1)$ 个额外变量。\n    5. 在处理完流之后，通过对设置为 $1$ 的位数求和来计算最终计数。\n    6. 从整数 $x \\in [1,K]$ 到其位位置的映射必须明确定义。\n- **程序要求：**\n    1. 在一个独立的、自包含的程序中实现。\n    2. 使用大小为 $\\lceil K/8 \\rceil$ 字节的紧凑字节级结构。\n    3. 以字节粒度计算置位的数量。\n- **测试套件：** 提供了一组六个测试用例，每个用例都带有相关参数 $(K, \\text{stream})$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地定位于计算机科学领域，特别是在数据结构和算法方面。位向量（或位图）、空间复杂度、RAM 模型和位运算等概念都是标准且成熟的原则。该问题在科学上和数学上是合理的。\n- **良定性：** 该问题是良定的。它明确了输入、输出以及对解决方案资源（内存）的可验证约束。对于任何给定的输入流，都存在一个唯一的整数计数。\n- **客观性：** 问题陈述是客观的，使用了精确、无歧义的技术语言。没有主观或基于意见的成分。\n- **完整性和一致性：** 该问题是自包含的。内存约束既被指定为“最多 $K/8 + O(1)$ 字节”，也被指定为“恰好 $\\lceil K/8 \\rceil$ 字节，外加 $O(1)$ 个额外变量”。这两者是一致的。因为对于任何整数 $K > 0$，上取整函数 $\\lceil K/8 \\rceil$ 满足不等式 $K/8 \\le \\lceil K/8 \\rceil \\le K/8 + 1$，所以量 $\\lceil K/8 \\rceil$ 确实等于 $K/8 + c$，其中常数 $c \\in [0, 1]$。这是 $K/8 + O(1)$ 的一种特定形式。因此，该设置是一致且完整的。\n- **现实性和可行性：** 该问题在计算上是可行的，并植根于内存管理的现实实践中，其中位级封装是一种常见的优化技术。\n- **结构性和平凡性：** 该问题结构良好且不平凡。它要求正确实现位操作，并对内存使用进行形式化论证，这考验了对基础知识的理解。它是展示空间高效数据结构的典型问题。\n\n### 第 3 步：结论与行动\n问题陈述是**有效的**。它是一个定义明确、标准的算法设计问题，具有一致性、完整性，并以成熟的计算机科学原理为基础。将提供一个解决方案。\n\n### 基于原则的解决方案推导\n\n目标是计算一个流中不同整数的数量，其中每个整数 $x$ 都保证在范围 $[1,K]$ 内。主要约束是内存使用量，不得超过 $K/8 + O(1)$ 字节。\n\n**1. 基本原则：存在性跟踪**\n\n为了计算不同的元素，我们必须记录哪些元素已经出现过。一种自然的表示方法是为范围 $[1,K]$ 中的每个可能整数维护一组布尔标志。我们将这组标志表示为 $S$。对于每个整数 $i \\in [1,K]$，我们可以有一个标志 $s_i$，如果 $i$ 已在流中出现，则 $s_i$ 为真，否则为假。最初，所有标志都为假。当一个整数 $x$ 从流中到达时，我们将其对应的标志 $s_x$ 设置为真。在流被完全处理后，不同元素的数量就是为真的标志总数。\n\n**2. 数据结构设计与空间复杂度分析**\n\n使用标准布尔数组的直接实现将需要 $K$ 个布尔变量。在许多编程语言中，一个布尔变量至少占用一个完整的字节（$8$ 位）内存。这将导致总内存使用量至少为 $K$ 字节，严重违反了指定的 $K/8 + O(1)$ 字节的内存约束。\n\n问题的核心在于以最高的空间效率实现这 $K$ 个标志。单个位是能够表示二元状态（真/假，或 $1/0$）的最小信息单位。因此，对于我们的 $K$ 个标志，最节省空间的表示方法是一个包含 $K$ 位的数组，通常称为位向量或位图。\n\n根据指定的 RAM 模型，内存是按字节寻址的。为了存储 $K$ 位，我们必须分配一个连续的字节块。由于每个字节包含 $8$ 位，所需的总字节数是能够容纳 $K$ 位的最小整数字节数。这个数量恰好是 $\\lceil K/8 \\rceil$。\n\n让我们形式上分析这个内存使用情况。位向量的内存为 $M_{vec} = \\lceil K/8 \\rceil$ 字节。我们知道对于任何实数 $z$，$\\lceil z \\rceil \\le z+1$。应用这个性质，我们有：\n$$M_{vec} \\le \\frac{K}{8} + 1$$\n$1$ 是一个常数，即 $O(1)$。因此，位向量的内存使用量是 $M_{vec} \\in O(K/8)$。更具体地说，它满足了 $K/8 + O(1)$ 字节的界限要求。该算法还需要少量、恒定数量的辅助变量，用于循环索引和处理当前流元素。这部分内存相对于 $K$ 和流长度是常数，并被包含在总体空间复杂度的 $O(1)$ 项中，使得总空间使用量为 $\\lceil K/8 \\rceil + O(1)$ 字节。\n\n**3. 整数到位映射**\n\n我们必须为每个整数 $x \\in [1,K]$ 定义一个到我们的位向量中唯一位的确定性一对一映射。位向量可以看作是一个 0-索引的 $K$ 位序列。一个自然的映射是将整数 $x$ 与第 $(x-1)$ 个位关联起来。设 $i_x = x-1$ 为整数 $x$ 的 0-索引位位置。\n\n要访问这个位，我们必须确定它在我们字节数组中的位置。设字节数组为 `bit_vector`。\n- 包含所需位的字节索引由整除得出：$j = \\lfloor i_x / 8 \\rfloor = (x-1) \\text{ div } 8$。\n- 该位在字节内的位置（从最低有效位 $0$ 到最高有效位 $7$）由余数得出：$p = i_x \\pmod 8 = (x-1) \\pmod 8$。\n\n**4. 算法步骤**\n\n**初始化：**\n1.  计算所需的字节数：$N_{bytes} = \\lceil K/8 \\rceil$。\n2.  分配一个大小为 $N_{bytes}$ 的字节数组 `bit_vector`，并将其所有元素初始化为 $0$。这确保所有 $K$ 个逻辑位初始都为 $0$，表示尚未看到任何整数。\n\n**流处理：**\n对于输入流中的每个整数 $x$：\n1.  计算位的 0-索引位置：$i_x = x - 1$。\n2.  确定字节索引：$j = i_x // 8$。\n3.  确定字节内的位位置：$p = i_x \\% 8$。\n4.  为了将该位置为 $1$，我们使用按位或运算。通过将 $1$ 左移 $p$ 个位置来创建一个掩码：$mask = 1 \\ll p$。\n5.  更新向量中的字节：`bit_vector[j] |= mask`。这个操作是幂等的，意味着对同一个 $x$ 重复操作，一旦位被置为 $1$ 后，其状态不会改变。\n\n**最终计数：**\n在整个流处理完毕后：\n1.  初始化一个总计数：`distinct_count = 0`。\n2.  遍历 `bit_vector` 中的每个字节 `b`，从索引 $0$ 到 $N_{bytes}-1$。\n3.  对于每个字节，计算其置位计数（即设置为 $1$ 的位数）。这可以使用内置函数或位操作技巧高效完成。\n4.  将这个每字节的计数加到 `distinct_count` 上。\n5.  `distinct_count` 的最终值就是流中观察到的不同整数的总数。\n\n该算法正确地计算了不同元素的数量，同时严格遵守了问题陈述中规定的内存约束和原则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the distinct integer counting problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases as specified in the problem statement.\n    # Each case is a tuple (K, stream).\n    test_cases = [\n        (20, [1, 3, 3, 5, 20, 20, 2, 2, 2]),\n        (1, [1, 1, 1]),\n        (10, [10, 9, 8, 1, 2, 2]),\n        (16, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4]),\n        (32, []),\n        (1000, [1, 1000, 500, 500, 250, 750, 250, 999, 2, 2, 3, 4, 4, 10]),\n    ]\n\n    results = []\n\n    for K, stream in test_cases:\n        # 1. Initialization\n        # Calculate the number of bytes needed to store K bits.\n        # This is equivalent to ceil(K / 8).\n        # np.ceil returns a float, so we cast to int.\n        num_bytes = int(np.ceil(K / 8))\n\n        # Allocate the bit vector as an array of 8-bit unsigned integers (bytes),\n        # initialized to all zeros.\n        bit_vector = np.zeros(num_bytes, dtype=np.uint8)\n\n        # 2. Stream Processing\n        for x in stream:\n            # The problem guarantees x is in [1, K].\n            # Map the integer x to a 0-indexed bit position.\n            bit_index = x - 1\n\n            # Determine the byte in the vector that contains this bit.\n            byte_index = bit_index // 8\n\n            # Determine the position of the bit within the byte (0-7).\n            bit_in_byte = bit_index % 8\n\n            # Create a mask to set the specific bit.\n            # (1  bit_in_byte) creates an integer with only the target bit set.\n            mask = np.uint8(1  bit_in_byte)\n\n            # Use bitwise OR to set the bit, marking the integer as seen.\n            # This operation is idempotent.\n            bit_vector[byte_index] |= mask\n        \n        # 3. Final Counting\n        distinct_count = 0\n        # Iterate through each byte of the bit vector.\n        for byte_val in bit_vector:\n            # Count the number of set bits (population count) in the current byte.\n            # int.bit_count() is a highly efficient method available in Python 3.10+.\n            distinct_count += int(byte_val).bit_count()\n        \n        results.append(distinct_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3272560"}, {"introduction": "当数据量不仅是“大”，而是远超可用内存时，我们该如何应对？这个问题将我们带入了处理海量数据的挑战之中。本练习介绍了流式处理和外部存储算法的核心思想，即通过对数据进行多轮（pass）处理来解决内存瓶颈。它将指导你设计一个完整的系统，该系统巧妙地结合了哈希分区、多轮扫描以及高效的内存数据结构（如哈希表和堆），从而在有限的内存预算内精确地解决一个“大数据”问题 [@problem_id:3272598]。", "problem": "您必须设计并实现一个程序，该程序根据给定的互联网协议第 $4$ 版 (IP) 地址流的规范和对随机存取存储器 (RAM) 的约束，使用一种峰值工作内存被明确限制和检查的算法，找出 $K$ 个最频繁的 IP 地址。您的程序应实现并模拟一种两遍扫描、哈希分区计数的算法，该算法在遵循内存使用模型的同时，能够得到精确的前 $K$ 个结果。所有计算都纯粹是数学和算法层面的；除了用于内存的字节外，不需要任何物理单位。\n\n您必须操作的基础由以下核心定义和事实构成：\n- 空间复杂度是函数 $S(n)$，它将输入大小 $n$ 映射到一个算法在执行过程中最坏情况下需要的内存单元（例如，字节）数量。\n- 在数据流模型中，算法按顺序查看输入序列 $x_1, x_2, \\dots, x_n$；一个 $p$ 遍扫描算法可以读取数据流 $p$ 次。\n- 在标准的独立性假设下，对桶进行均匀哈希可确保每个键都精确地映射到一个桶，并且键在桶之间的分布在期望上接近均匀。\n- 一个大小为 $K$ 的最小堆支持维护按键排序的 $K$ 个最大值，每次元素更新的时间复杂度为 $O(\\log K)$。\n\n任务要求和精确建模：\n1) 问题目标。给定一个互联网协议第 $4$ 版 (IP) 地址（键）的多重集流和一个整数 $K$，精确输出 $K$ 个最频繁的键，并按较小的数值 IP 来打破平局。所有 IP 地址必须表示为无符号 $32$ 位整数，通过点分四组表示法 $a.b.c.d$ 计算为 $(a \\ll 24) + (b \\ll 16) + (c \\ll 8) + d$，其中 $a,b,c,d \\in \\{0,\\dots,255\\}$。\n\n2) 算法模型。使用两遍扫描算法：\n- 第一遍扫描：通过应用一个固定的、确定性的哈希函数 $h(x)$，将项 $x$ 定向到桶 $h(x) \\bmod B$，从而将流划分为 $B$ 个逻辑桶。在实际的外存实现中，这将写出 $B$ 个分区文件，同时使用 $O(1)$ 的 RAM。在此模拟中，您可以在内存中访问整个流，但您必须在数学上将空间计算为仿佛此遍扫描仅使用了常数空间。\n- 第二遍扫描：对于每个桶索引 $i \\in \\{0,\\dots,B-1\\}$，重新扫描流，并仅对桶为 $i$ 的项进行精确计数，同时为该桶维护一个从 IP 到计数的内存哈希映射。完成桶 $i$ 的处理后，将该桶的计数合并到一个全局的前 $K$ 最小堆中，该堆以频率为键（按较小的数值 IP 打破平局）。然后丢弃该桶的映射，并继续处理下一个桶。\n\n3) 需强制执行和报告的内存模型。任何时刻的峰值工作内存是以下各项的总和：\n- 每个桶的计数映射，建模为 $U_i \\cdot b_e$ 字节，其中 $U_i$ 是当前桶 $i$ 中不同键的数量，$b_e$ 是每个条目的字节数。使用 $b_e = 24$ 字节。\n- 全局前 $K$ 堆，建模为 $H \\cdot b_a$ 字节，其中 $H \\le K$ 是当前堆的大小，$b_a$ 是每个堆条目的字节数。使用 $b_a = 24$ 字节。\n\n因此，在处理桶 $i$ 的任何时刻，建模的内存为 $U_i \\cdot b_e + H \\cdot b_a$ 字节。您的程序必须在整个执行过程中计算并记录此建模数量的最大值，并将其与给定的内存预算 $M$（以字节为单位）进行比较，以输出一个布尔值，指示建模的峰值使用量是否在预算内。\n\n4) 桶数量的选择。设 $D$ 为整个流中不同 IP 地址的数量。选择\n$$\nB = \\max\\left(1,\\ \\min\\left(D,\\ \\left\\lceil \\frac{D \\cdot b_e}{M \\cdot s}\\right\\rceil\\right)\\right),\n$$\n其中 $s$ 是一个用于补偿桶不平衡的安全系数。使用 $s = 2$。此选择通过一个因子 $s$ 将每个桶的期望不同键数保持在 $M/b_e$ 以下，同时将 $B$ 的上限设为 $D$，以便在极端情况下每个桶最多只落入一个不同的键。\n\n5) 哈希函数。为了确定性，通过 MurmurHash $3$ 中使用的 $64$ 位最终化函数（“fmix64”）定义 $h(x)$：\n- 将 $x$ 解释为无符号 $64$ 位整数（从 $32$ 位零扩展）。\n- 设\n$$\n\\begin{aligned}\ny \\leftarrow x, \\\\\ny \\leftarrow y \\oplus (y \\gg 33), \\\\\ny \\leftarrow (y \\times 0\\text{x}\\mathrm{ff51afd7ed558ccd})\\ \\bmod\\ 2^{64}, \\\\\ny \\leftarrow y \\oplus (y \\gg 33), \\\\\ny \\leftarrow (y \\times 0\\text{x}\\mathrm{c4ceb9fe1a85ec53})\\ \\bmod\\ 2^{64}, \\\\\ny \\leftarrow y \\oplus (y \\gg 33).\n\\end{aligned}\n$$\n然后设 $h(x) = y$。键 $x$ 的桶索引是 $h(x) \\bmod B$。\n\n6) 正确性目标。该算法必须精确输出整个流中 $K$ 个最频繁的 IP，并按较小的数值 IP 打破平局，因为给定 IP 的所有出现都会哈希到同一个桶中，因此每个 IP 的计数在其桶中被精确计算。全局堆在所有桶中保留了 $K$ 个最高的频率。\n\n7) 输出格式。对于每个测试用例，输出一个列表，其第一个元素是整数指示符 $b$，如果建模的峰值 RAM 使用量最多为 $M$，则 $b=1$，否则 $b=0$，后跟一个扁平化的整数序列，该序列将前 $K$ 个答案编码为 $(\\mathrm{ip\\_int}, \\mathrm{count})$ 对，按计数非递增顺序排列，平局则按较小的 $\\mathrm{ip\\_int}$ 排序。例如，一个包含对 $(x_1,c_1),(x_2,c_2)$ 且内存在预算内的结果将被编码为 $[1,x_1,c_1,x_2,c_2]$。\n您的程序应生成单行输出，其中包含所有给定测试用例的结果，格式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,\\dots]$，其中每个 $r_i$ 是一个按上述结构组织的列表。\n\n测试套件。在以下四种情况下实现并运行您的算法。在每种情况下，$b_e=24$，$b_a=24$，$s=2$。\n\n- 情况 1（一般情况）。流构成：\n  - $\\text{10.0.0.1}$ 出现 $50$ 次。\n  - $\\text{10.0.0.2}$ 出现 $30$ 次。\n  - $\\text{8.8.8.8}$ 出现 $25$ 次。\n  - $\\text{10.0.0.3}$ 出现 $20$ 次。\n  - $\\text{192.168.1.1}$ 出现 $15$ 次。\n  - $\\text{172.16.0.1}$ 出现 $12$ 次。\n  - $\\text{10.0.0.4}$ 出现 $5$ 次。\n  - $\\text{10.0.0.5}$ 出现 $5$ 次。\n  参数：$K=3$, $M=1{,}000{,}000$ 字节。\n\n- 情况 2（$K$ 超过不同键数量的边界情况）。流构成：\n  - $\\text{13.14.15.16}$ 出现 $4$ 次。\n  - $\\text{17.18.19.20}$ 出现 $4$ 次。\n  - $\\text{1.2.3.4}$ 出现 $3$ 次。\n  - $\\text{9.10.11.12}$ 出现 $2$ 次。\n  - $\\text{5.6.7.8}$ 出现 $1$ 次。\n  参数：$K=10$, $M=65{,}536$ 字节。\n\n- 情况 3（平局打破）。流构成：\n  - $\\text{1.1.1.1}$ 出现 $10$ 次。\n  - $\\text{1.1.1.2}$ 出现 $10$ 次。\n  - $\\text{1.1.1.3}$ 出现 $10$ 次。\n  - $\\text{1.1.1.4}$ 出现 $9$ 次。\n  - $\\text{1.1.1.5}$ 出现 $9$ 次。\n  - $\\text{1.1.1.6}$ 出现 $9$ 次。\n  参数：$K=4$, $M=131{,}072$ 字节。\n\n- 情况 4（内存不足）。流构成：\n  - $\\text{100.100.100.100}$ 出现 $1$ 次。\n  - $\\text{101.101.101.101}$ 出现 $1$ 次。\n  - $\\text{102.102.102.102}$ 出现 $1$ 次。\n  参数：$K=2$, $M=8$ 字节。\n\n您的程序必须完全按照上述规定在内部构建流，使用上述内存模型和哈希函数执行所描述的算法，并以所描述的精确聚合单行格式打印结果。不允许外部输入或文件。所有中间选择，例如桶的数量 $B$，都必须遵循上述定义。", "solution": "该问题要求设计并实现一种两遍扫描、哈希分区计数的算法，以从数据流中找出 $K$ 个最频繁的 IPv4 地址，同时遵守指定的内存模型。该问题定义明确、计算上可靠，并为确定性解决方案提供了所有必要的参数和定义。\n\n首先，我们按照规定将数据的表示和算法的组件形式化。\n\n一个采用点分四组表示法 $a.b.c.d$ 的 IPv4 地址，其中 $a, b, c, d \\in \\{0, 1, \\dots, 255\\}$，使用以下公式转换为一个无符号 $32$ 位整数，记为 $x_{\\text{ip}}$：\n$$\nx_{\\text{ip}} = (a \\ll 24) + (b \\ll 16) + (c \\ll 8) + d\n$$\n所有后续操作都在这些整数表示上执行。\n\n该算法在输入流（这些 IP 地址的多重集）上进行两次概念性扫描。\n\n一个关键的预备步骤是确定哈希分区方案的桶数 $B$。这个数值是根据流中不同 IP 地址的总数 $D$、内存预算 $M$、哈希映射中每个条目的内存成本 $b_e = 24$ 字节以及安全系数 $s = 2$ 来计算的。公式如下：\n$$\nB = \\max\\left(1,\\ \\min\\left(D,\\ \\left\\lceil \\frac{D \\cdot b_e}{M \\cdot s}\\right\\rceil\\right)\\right)\n$$\n该公式旨在选择一个足够大的 $B$，使得每个桶的期望不同键数 $D/B$ 所产生的哈希映射大小能够在安全系数 $s$ 调整后，符合内存预算 $M$。$\\max(1, \\dots)$ 确保至少存在一个桶，而 $\\min(D, \\dots)$ 是一个实际的上限，因为创建比不同项更多的桶是不必要的。\n\n确定性哈希函数 $h(x)$ 基于 MurmurHash3 的 `fmix64` 最终化函数。一个 IP 地址 $x_{\\text{ip}}$（一个 $32$ 位整数）首先被零扩展为一个 $64$ 位整数，我们将其表示为 $y$。该函数是一系列按位异或、移位和模 $2^{64}$ 乘法运算：\n$$\n\\begin{aligned}\ny \\leftarrow y \\oplus (y \\gg 33) \\\\\ny \\leftarrow (y \\times C_1) \\pmod{2^{64}} \\quad \\text{其中 } C_1 = 0\\text{x}\\mathrm{ff51afd7ed558ccd} \\\\\ny \\leftarrow y \\oplus (y \\gg 33) \\\\\ny \\leftarrow (y \\times C_2) \\pmod{2^{64}} \\quad \\text{其中 } C_2 = 0\\text{x}\\mathrm{c4ceb9fe1a85ec53} \\\\\ny \\leftarrow y \\oplus (y \\gg 33) \\\\\nh(x) \\leftarrow y\n\\end{aligned}\n$$\n然后，IP 地址 $x$ 的桶索引计算为 $h(x) \\pmod{B}$。\n\n**算法执行：**\n\n**第一遍扫描：**在我们的模拟中，这一遍是概念性的，因为整个流都在内存中可用。其目的是根据哈希值将所有 IP 地址的集合划分为 $B$ 个不相交的集合。给定 IP 地址的每一次出现都会哈希到同一个桶中，从而确保其总频率可以在第二遍扫描的单个桶处理步骤中被精确计算。\n\n**第二遍扫描：**这一遍执行计数和聚合。核心组件是用于计数的每个桶的哈希映射和用于维护前 $K$ 个结果的全局最小堆。\n利用最小堆来有效跟踪 $K$ 个最频繁的项。问题规定排序应按频率（降序）进行，若频率相同则按数值 IP 值（升序）进行。为了用最小堆实现这一点，我们必须存储堆元素，使得当按标准元组比较排序时，能够反映此排名。存储 $(count, -ip)$ 形式的元组可以达到此目的。最小堆将驱逐 $count$ 较小的元素，或者在 $count$ 相等的情况下，驱逐 $ip$ 较大的元素（即 $-ip$ 较小的元素）。这能正确地从顶尖候选中识别出“最小”的元素。\n\n第二遍扫描的过程如下：\n1. 初始化一个空的最小堆 `top_k_heap` 来存储结果。\n2. 初始化一个变量 `peak_memory_usage` 为 $0$。\n3. 对于从 $0$ 到 $B-1$ 的每个桶索引 $i$：\n    a. 创建一个临时的空哈希映射 `bucket_counts`，用于存储属于桶 $i$ 的 IP 的频率。\n    b. 遍历整个输入流。对于每个 IP 地址 $x$：\n        i. 如果 $h(x) \\pmod{B} = i$，则在 `bucket_counts` 中增加 $x$ 的计数。\n    c. 为桶 $i$ 处理完流后，该桶中的唯一键数量 $U_i$ 即为 `len(bucket_counts)`。\n    d. 全局堆的当前大小 $H$ 即为 `len(top_k_heap)`。\n    e. 根据公式 $M_{\\text{current}} = U_i \\cdot b_e + H \\cdot b_a$ 计算此步骤的建模内存使用量。\n    f. 更新峰值使用量：`peak_memory_usage` = $\\max(\\text{peak\\_memory\\_usage}, M_{\\text{current}})$。\n    g. 将 `bucket_counts` 中的计数合并到 `top_k_heap` 中。对于 `bucket_counts` 中的每一对 $(ip, count)$：\n        i. 创建堆项元组：`item = (count, -ip)`。\n        ii. 如果堆中元素少于 $K$ 个（`H  K`），则将 `item` 推入堆中。\n        iii. 如果堆已满（`H = K`），将 `item` 与堆中最小的元素 `heap[0]` 进行比较。如果 `item` 大于 `heap[0]`（表示一个更频繁或能打破平局的 IP），则用 `item` 替换 `heap[0]`。\n    h. `bucket_counts` 映射在概念上被丢弃。\n\n遍历完所有 $B$ 个桶后，`peak_memory_usage` 保存了在任何时间点使用的最大建模内存。将此值与预算 $M$ 进行比较，以确定内存检查标志 $b$。\n\n最后，`top_k_heap` 包含前 $K$ 个结果。从堆中提取元素，按降序排序（这对应于反向排序 `(count, -ip)` 元组），并格式化为所需的输出列表：$[b, ip_1, c_1, ip_2, c_2, \\dots]$。\n\n这种两遍扫描策略保证了计数的精确性，因为一个 IP 的所有实例都一起被处理。内存模型提供了一个框架来模拟和验证这种外存算法的空间效率。", "answer": "```python\nimport math\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on all test cases and print the results.\n    \"\"\"\n    # Problem constants\n    b_e = 24\n    b_a = 24\n    s = 2\n\n    # Test case definitions\n    test_suite = [\n        {\n            \"K\": 3, \"M\": 1_000_000,\n            \"stream_def\": {\n                \"10.0.0.1\": 50, \"10.0.0.2\": 30, \"8.8.8.8\": 25, \"10.0.0.3\": 20,\n                \"192.168.1.1\": 15, \"172.16.0.1\": 12, \"10.0.0.4\": 5, \"10.0.0.5\": 5\n            }\n        },\n        {\n            \"K\": 10, \"M\": 65536,\n            \"stream_def\": {\n                \"13.14.15.16\": 4, \"17.18.19.20\": 4, \"1.2.3.4\": 3,\n                \"9.10.11.12\": 2, \"5.6.7.8\": 1\n            }\n        },\n        {\n            \"K\": 4, \"M\": 131072,\n            \"stream_def\": {\n                \"1.1.1.1\": 10, \"1.1.1.2\": 10, \"1.1.1.3\": 10,\n                \"1.1.1.4\": 9, \"1.1.1.5\": 9, \"1.1.1.6\": 9\n            }\n        },\n        {\n            \"K\": 2, \"M\": 8,\n            \"stream_def\": {\n                \"100.100.100.100\": 1, \"101.101.101.101\": 1, \"102.102.102.102\": 1\n            }\n        }\n    ]\n\n    all_results = []\n\n    for case in test_suite:\n        K = case[\"K\"]\n        M = case[\"M\"]\n        stream_def = case[\"stream_def\"]\n        \n        # --- Helper functions ---\n        def ip_to_int(ip_str):\n            parts = ip_str.split('.')\n            return (int(parts[0])  24) + (int(parts[1])  16) + \\\n                   (int(parts[2])  8) + int(parts[3])\n\n        def fmix64(key):\n            # MurmurHash3 finalizer fmix64\n            # All operations are on 64-bit unsigned integers\n            key = int(key)  0xffffffffffffffff\n            \n            key ^= (key >> 33)\n            key = (key * 0xff51afd7ed558ccd)  0xffffffffffffffff\n            key ^= (key >> 33)\n            key = (key * 0xc4ceb9fe1a85ec53)  0xffffffffffffffff\n            key ^= (key >> 33)\n            return key\n\n        # --- Stream Generation ---\n        stream = []\n        for ip_str, count in stream_def.items():\n            ip_val = ip_to_int(ip_str)\n            stream.extend([ip_val] * count)\n        \n        distinct_ips = set(stream)\n        D = len(distinct_ips)\n\n        # --- Algorithm Implementation ---\n        \n        # 1. Calculate the number of buckets, B\n        if M * s == 0:\n            # Avoid division by zero; if memory or s is 0, practically infinite buckets are needed\n            # Capping at D is the most reasonable choice\n            B = D if D > 0 else 1\n        else:\n            B_float = (D * b_e) / (M * s)\n            B = max(1, min(D, math.ceil(B_float)))\n            if D == 0:\n                B = 1\n\n        # 2. Two-pass simulation\n        top_k_heap = [] # Min-heap storing (count, -ip)\n        peak_memory_usage = 0\n\n        for i in range(B):\n            # Pass 2, bucket i: Scan stream and count items for this bucket\n            bucket_counts = {}\n            for ip in stream:\n                if fmix64(ip) % B == i:\n                    bucket_counts[ip] = bucket_counts.get(ip, 0) + 1\n            \n            # Calculate and update peak memory usage\n            U_i = len(bucket_counts)\n            H = len(top_k_heap)\n            current_memory = U_i * b_e + H * b_a\n            peak_memory_usage = max(peak_memory_usage, current_memory)\n            \n            # Merge bucket counts into the global top-K heap\n            for ip, count in bucket_counts.items():\n                item = (count, -ip)\n                if len(top_k_heap)  K:\n                    heapq.heappush(top_k_heap, item)\n                elif item > top_k_heap[0]:\n                    heapq.heapreplace(top_k_heap, item)\n\n        # 3. Finalize results\n        memory_ok = 1 if peak_memory_usage = M else 0\n        \n        # Extract results from heap and sort for final output\n        # Sort in reverse to get descending count, then ascending IP\n        top_k_heap.sort(reverse=True)\n        \n        result_list = [memory_ok]\n        for count, neg_ip in top_k_heap:\n            result_list.append(-neg_ip)\n            result_list.append(count)\n            \n        all_results.append(result_list)\n\n    # Format the final output string as a list of lists\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3272598"}]}