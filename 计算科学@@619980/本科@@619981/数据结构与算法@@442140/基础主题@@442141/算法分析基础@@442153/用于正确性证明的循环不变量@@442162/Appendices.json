{"hands_on_practices": [{"introduction": "我们从一个基础练习开始。这个练习将分析一个用于计算阶乘的简单算法。通过一个给定的循环不变量 [@problem_id:3248254]，我们将一步步地检验正确性证明的三个关键环节：初始化、保持和终止。这个过程将帮助你巩固应用循环不变量证明方法的核心步骤。", "problem": "给定以下伪代码片段，用于计算非负整数 $n$ 的阶乘：\n- 输入: $n \\in \\mathbb{Z}_{\\ge 0}$\n- 初始化: $result := 1$\n- For循环: for $i$ from $1$ to $n$ (包含) do $result := result \\cdot i$\n\n我们尝试使用循环不变量来证明其正确性：在每次以当前循环索引 $i$ 开始的迭代之初，断言 $result = (i-1)!$ 成立。假设使用标准的 for 循环语义，其中不变量在循环入口处进行评估，并且循环按顺序遍历 $i = 1, 2, \\dots, n$。\n\n以下哪个选项最能指出这个代码-不变量对中可能存在的错误，该错误会阻碍对部分正确性和最终后置条件 $result = n!$ 的正确证明？\n\nA. 循环不变量在循环入口 $i = 1$ 时为假，因为 $0! \\ne 1$。\n\nB. 循环体 $result := result \\cdot i$ 违反了不变量，因为它将 $result$ 更改为 $i!$，所以不变量在循环体执行后无法保持。\n\nC. 终止时，循环在 $i = n$ 时退出，因此不变量仅得出 $result = (n-1)!$，这是一个差一错误。\n\nD. 只要在循环前将 $result$ 初始化为 $1$，就没有错误；不变量在每个循环入口处都成立，并在终止时意味着 $result = n!$。\n\nE. 初始化应为 $result := 0$ 以反映基线条件 $0! = 0$。\n\n选择唯一的最佳答案。", "solution": "该问题要求分析一个伪代码片段和用于证明其正确性的一个提议的循环不变量。目标是计算非负整数 $n$ 的阶乘，记作 $n!$。算法如下：\n\n- 输入: $n \\in \\mathbb{Z}_{\\ge 0}$\n- 初始化: $result := 1$\n- 循环: for $i$ from $1$ to $n$ do $result := result \\cdot i$\n\n提议的循环不变量是：在每次以循环索引 $i$ 开始的迭代之初，断言 $P(i): result = (i-1)!$ 成立。需要证明的最终后置条件是 $result = n!$。\n\n为了使用循环不变量验证循环的正确性，我们必须建立三个属性：\n\n1.  **初始化 (Initialization):** 在循环的第一次迭代之前，不变量为真。\n2.  **保持 (Maintenance):** 如果不变量在一次迭代开始时为真，那么它在下一次迭代开始时仍然为真。\n3.  **终止 (Termination):** 当循环终止时，不变量与终止条件相结合，可以推导出算法的正确性（即后置条件成立）。\n\n让我们针对给定的代码和不变量分析这三个属性。\n\n**1. 初始化**\n循环从 $i = 1$ 开始。在第一次迭代之前，变量 $result$ 被初始化为 $1$。我们必须检查不变量 $P(1)$ 在此时是否成立。\n对于 $i=1$ 的不变量是 $result = (1-1)! = 0!$。\n根据阶乘函数的标准定义，$0! = 1$。\n由于 $result$ 的初始值为 $1$，断言 $1 = 1$ 为真。\n因此，初始化属性成立。\n\n**2. 保持**\n我们假设不变量在任意一次迭代 $i$（其中 $1 \\le i \\le n$）开始时成立。这是归纳假设：假设 $result = (i-1)!$。\n在循环体内，语句 $result := result \\cdot i$ 被执行。\n执行该语句后，$result$ 的值变为 $(i-1)! \\cdot i$。\n根据阶乘的递归定义，$(i-1)! \\cdot i = i!$。\n循环的下一次迭代将以索引 $i+1$ 开始（假设 $i  n$）。为这次新迭代的不变量是 $P(i+1): result = ((i+1)-1)! = i!$。\n由于在迭代 $i$ 结束时 $result$ 的值确实是 $i!$，因此不变量在迭代 $i+1$ 开始时成立。\n因此，保持属性成立。\n\n**3. 终止**\n`for` 循环 `for i from 1 to n` 在 $i=n$ 的迭代完成后终止。此时，循环计数器增加到 $n+1$，循环条件（隐式为 $i \\le n$）变为假。\n所以，循环在 $i = n+1$ 时终止。\n我们使用循环不变量和这个终止条件来证明后置条件。\n不变量是 $result = (i-1)!$。\n将终止时的 $i$ 值（即 $i = n+1$）代入不变量，得到：\n$result = ((n+1)-1)! = n!$。\n这正是所期望的后置条件。在最后一次迭代（当 $i=n$ 时）之后，$result$ 的值被更新为 $(n-1)! \\cdot n = n!$，这与从终止时的不变量推导出的结果是一致的。\n\n我们再来考虑 $n=0$ 的基线情况。循环 `for i from 1 to 0` 不会执行。代码将 $result$ 初始化为 $1$ 然后终止。最终值为 $result = 1$，这是正确的，因为 $0! = 1$。循环不变量证明框架正确地处理了这种情况，因为在没有任何迭代的情况下，后置条件也得到了满足。\n\n由于所有三个属性（初始化、保持和终止）都成立，该代码-不变量对是正确的，并构成了部分正确性的有效证明。\n\n现在，我们来评估每个选项：\n\n**A. 循环不变量在循环入口 $i = 1$ 时为假，因为 $0! \\ne 1$。**\n这个陈述在事实上是错误的。根据定义，$0! = 1$。正如我们在初始化步骤的分析中所展示的，不变量在 $i=1$ 时成立。因此，此选项 **不正确**。\n\n**B. 循环体 $result := result \\cdot i$ 违反了不变量，因为它将 $result$ 更改为 $i!$，所以不变量在循环体执行后无法保持。**\n这个选项误解了“保持”的含义。不变量 $P(i)$ 指出 `result = (i-1)!`。在循环体执行后，`result` 变为 `i!`。这并没有违反保持属性；相反，这是确保*下一次*迭代的不变量 $P(i+1)$ 成立的关键步骤。不变量不需要在循环体的整个执行过程中都保持成立。它必须在迭代的边界（入口）处成立。因此，此选项 **不正确**。\n\n**C. 终止时，循环在 $i = n$ 时退出，因此不变量仅得出 $result = (n-1)!$，这是一个差一错误。**\n这个陈述基于对 for 循环终止条件的错误理解。循环会为 $i=1, 2, \\dots, n$ 执行。当循环计数器大于 $n$ 时，循环终止。在标准语义中，这发生在 $i$ 变为 $n+1$ 时。将终止条件 $i = n+1$ 应用于不变量，会得出正确的后置条件 $result = ((n+1)-1)! = n!$。该选项假设循环在 “$i=n$ 时” 退出是错误的，从而导致了不正确的结论。因此，此选项 **不正确**。\n\n**D. 只要在循环前将 $result$ 初始化为 $1$，就没有错误；不变量在每个循环入口处都成立，并在终止时意味着 $result = n!$。**\n这个陈述准确地总结了我们的分析。初始化、保持和终止属性对于给定的代码和不变量都成立。这个`代码-不变量对`是证明阶乘算法正确性的有效组合。因此，此选项 **正确**。\n\n**E. 初始化应为 $result := 0$ 以反映基线条件 $0! = 0$。**\n这个陈述包含一个事实错误：$0! = 1$，而不是 $0$。此外，将 $result$ 初始化为 $0$ 会导致对于任何 $n \\ge 1$，最终结果都因乘以 $0$ 而变为 $0$，这是不正确的。因此，此选项 **不正确**。", "answer": "$$\\boxed{D}$$", "id": "3248254"}, {"introduction": "循环不变量不仅是证明代码正确性的工具，更是强大的调试武器。在这个练习中，你将面对一个有缺陷的经典二分搜索算法 [@problem_id:3248327]。你的任务是运用所给定的不变量，精确地定位出代码逻辑的错误之处，从而亲身体会不变量在诊断和修复算法问题时的威力。", "problem": "给定一个程序，用于在严格递增的有序数组 $A[0 \\ldots n-1]$ 中搜索目标值 $t$。预期的循环不变量是一个闭区间声明：在每次循环迭代开始时，如果存在索引 $k$ 使得 $A[k] = t$，则 $low \\le k \\le high$；等价地，如果 $t$ 存在，其索引位于子数组 $A[low \\ldots high]$ 中。该算法如下：\n\n初始化 $low \\leftarrow 0$， $high \\leftarrow n-1$。\n当 $low \\le high$ 时：\n- 令 $mid \\leftarrow \\left\\lfloor \\dfrac{low + high}{2} \\right\\rfloor$。\n- 如果 $A[mid] = t$，返回 $mid$。\n- 否则如果 $A[mid]  t$，设置 $high \\leftarrow mid - 1$。\n- 否则，设置 $low \\leftarrow mid + 1$。\n如果循环终止，返回 $t$ 不存在。\n\n假设使用标准整数算术，除法采用精确下取整，且无溢出。仅使用关于严格递增数组的核心事实（对于所有索引 $i$ 和 $j$，如果 $i  j$ 则 $A[i]  A[j]$）以及不变量的定义。你的任务是确定是哪一步导致算法因违反所述不变量而有时会错过已存在的目标，并通过准确指出不变量如何未能被保持来证明你的选择。\n\n关于不变量，哪个选项最好地指出了缺陷及其原因？\n\nA. 初始化违反了不变量，因为 $high$ 应该设置为 $n$ 而不是 $n-1$，所以初始子数组 $A[low \\ldots high]$ 没有覆盖所有可能的候选位置。\n\nB. 在分支 $A[mid]  t$ 中，不变量的维持性被破坏：更新 $high \\leftarrow mid - 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，则对于某个满足 $A[k] = t$ 的 $k$ 来说，$low \\le k \\le high$ 可能不再成立。\n\nC. 在分支 $A[mid] > t$ 中，不变量的维持性被破坏：更新 $low \\leftarrow mid + 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，则对于某个满足 $A[k] = t$ 的 $k$ 来说，$low \\le k \\le high$ 可能不再成立。\n\nD. 不变量的陈述有误；它应该使用一个半开区间，即如果 $t$ 存在，则 $t$ 必须在 $A[low \\ldots high)$ 中，而使用闭区间是算法可能错过 $t$ 的原因。", "solution": "该问题陈述是算法分析中的一个有效练习，特别是使用循环不变量来验证算法的正确性。任务是根据给定的不变量来分析一个有缺陷的二分搜索实现。该问题提法恰当，科学上基于计算机科学原理，并且是客观的。\n\n分析的核心在于循环不变量的三个属性：初始化、维持和终止。让所述循环不变量表示为 $P$。\n$P$：在每次循环迭代开始时，如果存在索引 $k$ 使得 $A[k] = t$，则 $low \\le k \\le high$。\n\n**1. 初始化**\n\n算法初始化 $low \\leftarrow 0$ 和 $high \\leftarrow n-1$。循环不变量 $P$ 必须在第一次迭代前成立。初始搜索空间是整个数组 $A[0 \\ldots n-1]$。如果目标值 $t$ 存在于数组中的某个索引 $k$ 处，那么根据数组索引的定义，$k$ 必须在 $[0, n-1]$ 的界限内。因此，条件 $low \\le k \\le high$ (即 $0 \\le k \\le n-1$) 是成立的。初始化步骤正确地建立了不变量。\n\n**2. 维持**\n\n我们假设不变量 $P$ 在 `while` 循环迭代开始时成立。也就是说，如果对于某个 $k$ 有 $A[k] = t$，则 $low \\le k \\le high$。我们必须证明 $P$ 在下一次迭代开始时也成立。\n\n算法计算 $mid \\leftarrow \\left\\lfloor \\dfrac{low + high}{2} \\right\\rfloor$。\n循环体中有三种情况：\n\n情况1：$A[mid] = t$。算法找到目标并返回 $mid$，终止。循环不再继续，因此对于这条路径，维持属性没有被进一步测试。结果是正确的。\n\n情况2：$A[mid]  t$。数组 $A$ 是严格递增的，意味着对于任何索引 $i  j$，我们有 $A[i]  A[j]$。如果 $A[mid]  t$，那么对于任何索引 $j \\le mid$，我们有 $A[j] \\le A[mid]  t$。这意味着如果目标 $t$ 存在于数组中的索引 $k$ 处，它的索引必须大于 $mid$。也就是说，$k > mid$。结合我们的假设 ($low \\le k \\le high$) 和这个推论 ($k > mid$)，目标索引 $k$（如果存在）必须位于范围 $[mid + 1, high]$ 内。为了维持不变量，下一个搜索区间 $[low_{new}, high_{new}]$ 必须包含 $[mid + 1, high]$。正确的更新应该是 $low \\leftarrow mid + 1$。然而，算法执行的是 $high \\leftarrow mid - 1$。新的搜索区间变成了 $[low, mid-1]$。一个已知大于 $mid$ 的索引 $k$ 不可能在这个新区间内。因此，如果目标存在，新的状态就违反了不变量 $low_{new} \\le k \\le high_{new}$。\n\n情况3：`Else`。当 $A[mid] \\ne t$ 且 $A[mid] \\not t$ 时会触发此情况，这意味着 $A[mid] > t$。由于数组是严格递增的，如果 $A[mid] > t$，那么对于任何索引 $j \\ge mid$，我们有 $A[j] \\ge A[mid] > t$。这意味着如果目标 $t$ 存在于数组中的索引 $k$ 处，它的索引必须小于 $mid$。也就是说，$k  mid$。结合我们的假设 ($low \\le k \\le high$) 和这个推论 ($k  mid$)，目标索引 $k$（如果存在）必须位于范围 $[low, mid - 1]$ 内。为了维持不变量，下一个搜索区间 $[low_{new}, high_{new}]$ 必须包含 $[low, mid - 1]$。正确的更新应该是 $high \\leftarrow mid - 1$。然而，算法执行的是 $low \\leftarrow mid + 1$。新的搜索区间变成了 $[mid+1, high]$。一个已知小于 $mid$ 的索引 $k$ 不可能在这个新区间内。因此，如果目标存在，新的状态就违反了不变量 $low_{new} \\le k \\le high_{new}$。\n\n当 $A[mid] \\ne t$ 时，算法的两个更新分支都是不正确的，并且违反了循环不变量的维持属性。这两种情况的逻辑似乎被互换了。\n\n现在，我们评估给定的选项：\n\n**A. 初始化违反了不变量，因为 $high$ 应该设置为 $n$ 而不是 $n-1$，所以初始子数组 $A[low \\ldots high]$ 没有覆盖所有可能的候选位置。**\n如初始化分析所示，设置 $low \\leftarrow 0$ 和 $high \\leftarrow n-1$ 正确地建立了不变量。这个范围完全覆盖了数组 $A[0 \\ldots n-1]$ 的所有有效索引。对于一个大小为 $n$ 的 0-索引数组，使用闭区间不变量时，将 $high$ 设置为 $n$ 是不正确的，因为它可能导致访问越界的 $A[n]$。此选项**不正确**。\n\n**B. 在分支 $A[mid]  t$ 中，不变量的维持性被破坏：更新 $high \\leftarrow mid - 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，则对于某个满足 $A[k] = t$ 的 $k$ 来说，$low \\le k \\le high$ 可能不再成立。**\n我们对情况 $A[mid]  t$ 的维持步骤分析精确地证实了这一说法。如果 $A[mid]  t$，目标必须在当前搜索空间的上半部分 ($k > mid$)。更新 $high \\leftarrow mid-1$ 丢弃了这一半，并将搜索限制在下半部分，从而破坏了不变量。这个选项准确地描述了算法中的一个关键缺陷。此选项**正确**。\n\n**C. 在分支 $A[mid] > t$ 中，不变量的维持性被破坏：更新 $low \\leftarrow mid + 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，则对于某个满足 $A[k] = t$ 的 $k$ 来说，$low \\le k \\le high$ 可能不再成立。**\n我们对 `Else` 情况 ($A[mid] > t$) 的维持步骤分析也证实了这一说法。如果 $A[mid] > t$，目标必须在搜索空间的下半部分 ($k  mid$)。更新 $low \\leftarrow mid+1$ 丢弃了这一半，并将搜索限制在上半部分，破坏了不变量。这个选项也准确地描述了算法中的一个关键缺陷。此选项**正确**。\n\n**D. 不变量的陈述有误；它应该使用一个半开区间，即如果 $t$ 存在，则 $t$ 必须在 $A[low \\ldots high)$ 中，而使用闭区间是算法可能错过 $t$ 的原因。**\n选择闭区间 $[low, high]$ 不变量是二分搜索的一种标准且有效的方法。所给出的算法存在缺陷，是因为其更新逻辑未能正确维持这个不变量。一个正确的算法*可以*使用这个不变量来编写。问题出在代码上，而不是不变量的陈述。此选项**不正确**。\n\n**结论：**\n选项 B 和 C 都描述了算法维持步骤中有效且致命的缺陷。该算法错误地交换了 $A[mid]  t$ 和 $A[mid] > t$ 情况下的更新逻辑。然而，问题要求选择唯一的最佳选项。在提供的伪代码中，`Else if A[mid]  t` 分支出现在最后的 `Else` 分支（处理 $A[mid] > t$）之前。选项 B 中描述的缺陷与代码控制流中两个不正确的更新语句中的第一个相关联。因此，可以认为 B 指出了在分析条件逻辑序列时遇到的最直接的缺陷。", "answer": "$$\\boxed{B}$$", "id": "3248327"}, {"introduction": "现在，让我们来挑战一个逆向问题。与验证已有代码不同，这次你只拥有一个循环不变量和基本的循环结构 [@problem_id:3248351]。你的任务是“反向工程”，推导出循环体的具体实现。这个高级练习展示了循环不变量如何作为一种设计工具，指导我们编写出“构造即正确”的优雅代码。", "problem": "给定一个整数底数 $x$ 和一个非负整数指数 $n$。考虑一个通过维护三个整数变量 $p$、 $k$ 和 $y$ 来构建 $x^n$ 的算法，其初始化和循环守卫如下：\n- 初始化：$p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$，以及 $n_{\\text{original}} \\leftarrow n$。\n- 循环守卫：当 $y > 0$ 时继续。\n- 每次迭代开始时需要保持的循环不变量：$p = x^k$ 且 $k + y = n_{\\text{original}}$。\n\n你的任务是逆向工程一个正确的循环体，即确定循环体中必须执行的赋值语句，以维持循环不变量，并确保在终止时后置条件 $p = x^{n_{\\text{original}}}$ 成立。\n\n你的推导必须从以下基本依据出发：\n- 自然数上幂运算的定义：对于所有整数 $x$ 和所有整数 $k \\ge 0$，有 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$。\n- 自然数上的数学归纳法原理以及自然数上常规序的良基性。\n- 命令式程序中用于部分正确性的循环不变量和用于完全正确性的自然数变体的标准定义。\n\n假设以下域和约定：\n- $x$ 是任意整数，$n$ 是满足 $n \\ge 0$ 的任意整数。\n- 对于此问题，定义对于每个整数 $x$ 都有 $x^0 = 1$，包括 $x = 0$ 的情况，因此 $0^0$ 被视为 $1$。\n\n任务：\n1. 推导一个最小的循环体（仅包含对 $p$、$k$ 和 $y$ 的赋值），该循环体在每次迭代开始时保持不变量 $p = x^k$ 和 $k + y = n_{\\text{original}}$，递减一个自然数变体以确保终止，并在循环终止时产生后置条件 $p = x^{n_{\\text{original}}}$。\n2. 仅从上述基本依据出发，使用循环不变量方法证明你的循环的部分正确性和完全正确性。\n3. 实现一个程序，该程序对一组测试用例执行你的循环，并为每个测试用例返回：\n   - 终止时计算出的值 $p$。\n   - 一个布尔值，指示在每次迭代开始时不变量是否成立，以及在终止时后置条件 $p = x^{n_{\\text{original}}}$ 是否成立。\n\n测试套件：\n- $(x, n) = (2, 10)$\n- $(x, n) = (5, 0)$\n- $(x, n) = (0, 7)$\n- $(x, n) = (0, 0)$\n- $(x, n) = (-3, 4)$\n- $(x, n) = (-3, 5)$\n- $(x, n) = (2, 50)$\n- $(x, n) = (1, 100)$\n\n答案规格和输出格式：\n- 对于每个测试用例，输出一个包含两个元素的列表 $[p, b]$，其中 $p$ 是使用你推导的循环计算出的整数 $x^n$，$b$ 是一个布尔值，当且仅当在每次迭代开始时不变量都成立且最终状态满足 $p = x^{n_{\\text{original}}}$ 时为 $\\text{True}$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如：$[\\,[p_1, b_1],[p_2, b_2],\\dots]$。\n- 不需要用户输入。程序必须是自包含的，并且只使用整数算术和控制流；不要在循环体内部调用任何内置的幂函数来计算 $p$。为了在你的实现中验证不变量，你可以使用定义递归 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$ 来计算 $x^k$。", "solution": "基于给定的循环不变量设计一个计算 $x^n$ 的循环体，是程序验证和算法逆向工程中的一个标准练习。我将首先验证问题陈述，然后进行形式化的推导和正确性证明。\n\n### 步骤 1：问题验证\n\n我首先提取问题中陈述的给定信息和条件。\n\n- **输入**：一个整数底数 $x$ 和一个非负整数指数 $n$。\n- **算法变量**：三个整数变量 $p$、 $k$ 和 $y$。\n- **初始化**：$p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$，以及一个常量 $n_{\\text{original}} \\leftarrow n$。\n- **循环守卫**：循环只要 $y > 0$ 就继续。\n- **循环不变量**：命题 $I(p, k, y) \\equiv (p = x^k) \\land (k + y = n_{\\text{original}})$ 必须在每次循环迭代开始时都成立。\n- **后置条件**：终止时，$p$ 的最终值必须是 $x^{n_{\\text{original}}}$。\n- **基本依据**：推导必须基于：\n    1. 幂运算的递归定义：对于 $k \\ge 0$，有 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$。\n    2. 数学归纳法原理。\n    3. 用于证明部分正确性和完全正确性的循环不变量理论。\n- **域约定**：$x$ 是任意整数，$n$ 是一个满足 $n \\ge 0$ 的整数，并且为此问题目的，$x^0=1$ 对所有整数 $x$ 成立，包括 $0^0=1$。\n\n该问题在科学上和数学上是合理的、适定的和客观的。这是计算机科学中关于算法设计和正确性的一个标准问题，特别关注循环不变量。前提是一致的，并且提供了推导所需的所有必要信息。这个问题并非微不足道，因为它需要系统地应用程序验证的原理。因此，该问题被认为是有效的。\n\n### 步骤 2：循环体的推导\n\n设在任意一次循环迭代开始时变量的状态为 $(p, k, y)$。根据假设（循环不变量），我们假定此时：\n1. $p = x^k$\n2. $k + y = n_{\\text{original}}$\n\n循环守卫是 $y > 0$，因此我们也可以假设 $y$ 是一个正整数。\n目标是找到一系列对 $p$、$k$ 和 $y$ 的赋值，使得产生的新状态 $(p', k', y')$ 也满足不变量，即 $p' = x^{k'}$ 且 $k' + y' = n_{\\text{original}}$。此外，我们必须确保循环会终止。\n\n**确保终止**：\n如果 $y$ 最终变得小于或等于 $0$，循环就会终止。由于 $y$ 是一个在循环内部为正的整数，保证朝向终止进展的一个简单方法是在每次迭代中递减 $y$。让我们提出更新：\n$$y' \\leftarrow y - 1$$\n这定义了一个变体函数 $V(y) = y$，它是一个非负整数，在每次迭代中严格递减，从而保证了终止。\n\n**保持不变量**：\n现在，在给定对 $y$ 的更新的情况下，我们必须确定对 $k$ 和 $p$ 的更新，以保持不变量。\n\n首先，考虑不变量的第二部分，$k + y = n_{\\text{original}}$。我们需要新状态 $(k', y')$ 满足 $k' + y' = n_{\\text{original}}$。\n代入我们提出的更新 $y' = y - 1$：\n$$k' + (y - 1) = n_{\\text{original}}$$\n从迭代开始时成立的不变量中，我们知道 $y = n_{\\text{original}} - k$。将此代入前一个方程：\n$$k' + (n_{\\text{original}} - k - 1) = n_{\\text{original}}$$\n$$k' - k - 1 = 0$$\n$$k' = k + 1$$\n这给出了对 $k$ 的所需赋值：\n$$k' \\leftarrow k + 1$$\n\n接下来，考虑不变量的第一部分，$p = x^k$。我们需要新状态 $(p', k')$ 满足 $p' = x^{k'}$。\n代入我们推导出的更新 $k' = k + 1$：\n$$p' = x^{k+1}$$\n使用幂运算的基本定义，$x^{k+1} = x^k \\cdot x$。因此，我们必须有：\n$$p' = x^k \\cdot x$$\n从迭代开始时成立的不变量中，我们知道 $p = x^k$。将此代入 $p'$ 的方程：\n$$p' = p \\cdot x$$\n这提供了对 $p$ 的所需赋值：\n$$p' \\leftarrow p \\cdot x$$\n\n因此，推导出的最小循环体由以下三个赋值组成：\n1. $p \\leftarrow p \\cdot x$\n2. $k \\leftarrow k + 1$\n3. $y \\leftarrow y - 1$\n\n这些赋值的顺序无关紧要，只要它们都使用迭代开始时的 $p, k, y$ 的值即可。所提议的顺序执行可以实现这一点。\n\n### 步骤 3：正确性证明\n\n我们使用循环不变量方法来证明完全正确性。\n\n- **循环不变量 ($I$)**：$(p = x^k) \\land (k + y = n_{\\text{original}})$。\n- **变体 ($V$)**：$V(y) = y$。\n\n**1. 初始化（基本情况）**：\n我们必须证明不变量 $I$ 在循环的第一次迭代之前成立。\n- 初始状态是 $p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$，以及 $n_{\\text{original}} \\leftarrow n$。\n- 检查第一个合取项：$p = x^k$ 是否成立？这意味着检查 $1 = x^0$ 是否成立。根据问题的幂运算定义，这对所有整数 $x$ 都成立。\n- 检查第二个合取项：$k + y = n_{\\text{original}}$ 是否成立？这意味着检查 $0 + n = n$ 是否成立。这是成立的。\n- 不变量的两个部分都成立。初始化是正确的。\n\n**2. 保持性（归纳步骤）**：\n假设在一次迭代开始时，不变量 $I$ 成立且循环守卫 $y > 0$ 为真。设状态为 $(p, k, y)$。我们必须证明在执行循环体之后，不变量对于新状态 $(p', k', y')$ 仍然成立。\n- **假设**：$p = x^k$, $k + y = n_{\\text{original}}$ 且 $y > 0$。\n- **循环体**：$p' \\leftarrow p \\cdot x$，$k' \\leftarrow k + 1$，$y' \\leftarrow y - 1$。\n- **第一个合取项的证明 ($p' = x^{k'}$)**：\n  - $p' = p \\cdot x$ (根据赋值)\n  - $p' = (x^k) \\cdot x$ (根据假设 $p = x^k$)\n  - $p' = x^{k+1}$ (根据幂运算的定义)\n  - 由于 $k' = k + 1$，我们得到 $p' = x^{k'}$。第一个合取项成立。\n- **第二个合取项的证明 ($k' + y' = n_{\\text{original}}$)**：\n  - $k' + y' = (k + 1) + (y - 1)$ (根据赋值)\n  - $k' + y' = k + y$\n  - 由于根据假设有 $k + y = n_{\\text{original}}$，我们得到 $k' + y' = n_{\\text{original}}$。第二个合取项成立。\n- 循环体保持了不变量。这确立了部分正确性：如果循环终止，其结果是正确的。\n\n**3. 终止性和后置条件**：\n- **终止性**：变体是 $V(y) = y$。在初始化时，$y=n \\ge 0$。循环条件是 $y > 0$。在循环内部，$y$ 是严格为正的。更新是 $y' \\leftarrow y - 1$，所以 $y'  y$。一个严格递减的非负整数序列必须是有限的。因此，循环必须终止。\n- **后置条件**：当守卫 $y > 0$ 变为假时，循环终止。由于 $y$ 是一个在每一步都减 1 的整数，终止恰好发生在 $y = 0$ 时。\n  - 此时，不变量仍然成立（它在最后一次、未执行的检查开始时是成立的）。\n  - 从 $k + y = n_{\\text{original}}$，当 $y=0$ 时，我们得到 $k = n_{\\text{original}}$。\n  - 从 $p = x^k$，代入 $k = n_{\\text{original}}$，我们得到 $p = x^{n_{\\text{original}}}$。\n- 这就是所期望的后置条件。\n\n初始化、保持性和终止性的结合证明了该算法及所推导循环体的完全正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the derived algorithm on a suite of test cases\n    and verifying the loop invariant and postcondition for each case.\n    \"\"\"\n\n    def power_for_verification(base, exp):\n        \"\"\"\n        Computes base^exp using the fundamental recursive definition.\n        Handles the special case 0^0 = 1 as per the problem statement.\n        This function is used only for verifying the invariant and postcondition,\n        not in the main computation of p.\n        \"\"\"\n        if exp  0:\n            raise ValueError(\"Exponent must be non-negative.\")\n        if exp == 0:\n            return 1\n        \n        # Using integer arithmetic to avoid potential floating point issues\n        # and to handle large numbers.\n        result = 1\n        for _ in range(exp):\n            result *= base\n        return result\n\n    def execute_and_verify(x, n):\n        \"\"\"\n        Executes the derived exponentiation algorithm for a given base x and exponent n.\n        It checks if the loop invariant holds at the start of every iteration and\n        if the postcondition holds upon termination.\n\n        Returns:\n            A list [p, b], where p is the computed result and b is a boolean\n            indicating if all checks passed.\n        \"\"\"\n        # Initialization\n        p = 1\n        k = 0\n        y = n\n        n_original = n\n\n        all_checks_passed = True\n\n        # Check invariant after initialization and before the first iteration.\n        # This is a crucial step, especially for the n=0 case where the loop is skipped.\n        try:\n            p_check = (p == power_for_verification(x, k))\n            ky_check = (k + y == n_original)\n            if not (p_check and ky_check):\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        # Loop\n        while y > 0:\n            # Check invariant at the start of the current iteration\n            try:\n                p_check = (p == power_for_verification(x, k))\n                ky_check = (k + y == n_original)\n                if not (p_check and ky_check):\n                    all_checks_passed = False\n            except Exception:\n                all_checks_passed = False\n\n            # Loop body derived from the invariant\n            p = p * x\n            k = k + 1\n            y = y - 1\n        \n        # Check postcondition upon termination\n        try:\n            postcondition_check = (p == power_for_verification(x, n_original))\n            if not postcondition_check:\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        return [p, all_checks_passed]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 10),\n        (5, 0),\n        (0, 7),\n        (0, 0),\n        (-3, 4),\n        (-3, 5),\n        (2, 50),\n        (1, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        x, n = case\n        result = execute_and_verify(x, n)\n        # Convert Python boolean to string 'True'/'False' for final output format\n        result[1] = 'True' if result[1] else 'False'\n        results.append(str(result).replace(\"'\", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3248351"}]}