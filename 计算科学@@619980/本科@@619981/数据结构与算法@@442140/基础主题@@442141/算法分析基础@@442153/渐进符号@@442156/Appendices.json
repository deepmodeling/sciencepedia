{"hands_on_practices": [{"introduction": "要想真正掌握渐进符号，必须精确理解其形式化定义。本练习 [@problem_id:3210000] 是一个批判性思维挑战，它展示了一个看似合理但存在根本性缺陷的证明。通过剖析该论证并找出其中的逻辑谬误，你将巩固对大 $O$ 表示法中常量和变量的严格角色的理解。", "problem": "考虑函数 $f(n) = n$ 属于集合 $\\mathcal{O}(1)$ 这一论断以及下面给出的所谓证明。\n\n论断: $f(n) \\in \\mathcal{O}(1)$。\n\n所谓的证明：根据定义，只需找到常数 $c > 0$ 和 $n_0 \\in \\mathbb{N}$，使得对于所有 $n \\ge n_0$ 都有 $0 \\le f(n) \\le c \\cdot 1$。首先，对于每个 $n \\ge 1$，取 $c = n$。那么 $f(n) = n \\le c \\cdot 1$ 成立，因此所需的不等式得到满足。其次，观察到极限 $\\lim_{n \\to \\infty} \\frac{f(n)}{1} = \\lim_{n \\to \\infty} n$ “存在”，所以其增长是“良好”的，因此在渐近记法意义上受一个常数限制。最后，选择 $n_0 = 10$；对于所有 $n \\ge n_0$，我们有 $n \\le n_0$，所以 $f(n) \\le n_0 \\cdot 1$。因此 $f(n) \\in \\mathcal{O}(1)$。\n\n选择所有正确指出该所谓证明中逻辑错误的选项。\n\nA. 该论证允许常数 $c$ 依赖于 $n$（使用了 $c=n$），这违反了 $\\mathcal{O}$ 定义中的量词结构；常数必须独立于 $n$ 来选择。\n\nB. 使用极限 $\\lim_{n \\to \\infty} \\frac{f(n)}{1}$ 来得出 $\\mathcal{O}(1)$ 的结论是无效的；不仅因为这个极限是无穷大，而且极限的存在本身并不能确立 $\\mathcal{O}(1)$ 所要求的一致常数界。\n\nC. 声称“对于 $n \\ge n_0$ 有 $n \\le n_0$”的这一步颠倒了不等式，并且误解了 $n_0$ 的作用；$n_0$ 是一个界限必须在其之后成立的阈值，而不是 $n$ 本身的上界。\n\nD. 第一步中选择 $c = n$ 是可以接受的，因为它使得对于每个 $n$，$f(n) \\le c \\cdot 1$ 都为真，所以该证明正确地满足了 $\\mathcal{O}(1)$ 的定义。\n\nE. 证明中使用了不等式 $f(n) \\le c \\cdot 1$，但 $\\mathcal{O}(1)$ 的定义实际上要求 $f(n) \\ge c \\cdot 1$；不等式的方向是错误的。\n\nF. 唯一的问题是 $n_0 = 10$ 这个具体选择；选择一个足够大的 $n_0$ 会使得不等式 $n \\le n_0$ 对于所有 $n \\ge n_0$ 都成立，从而可以修正这个证明。", "solution": "用户提供了一个针对函数 $f(n) = n$ 属于集合 $\\mathcal{O}(1)$ 这一论断的所谓证明，并要求从一个选项列表中找出所有逻辑错误。\n\n首先，我们回顾一下大 $\\mathcal{O}$ 记号的正式定义。一个函数 $f(n)$ 属于 $\\mathcal{O}(g(n))$ 当且仅当存在常数 $c \\in \\mathbb{R}_{0}$ 和 $n_0 \\in \\mathbb{N}$，使得对于所有整数 $n \\ge n_0$，不等式 $0 \\le |f(n)| \\le c \\cdot |g(n)|$ 成立。对于本问题中的函数 $f(n) = n$ 和 $g(n) = 1$（当 $n \\ge 1$ 时它们是非负的），我们可以将不等式简化为 $0 \\le n \\le c \\cdot 1$。该定义的逻辑结构至关重要：$\\exists c > 0, \\exists n_0 \\in \\mathbb{N} : \\forall n \\ge n_0, f(n) \\le c \\cdot g(n)$。这意味着常数 $c$ 和 $n_0$ 必须一次性选定，并对所有超过阈值 $n_0$ 的 $n$ 值都有效。它们不能是 $n$ 的函数。\n\n$n \\in \\mathcal{O}(1)$ 这个论断是错误的。要使其为真，需要存在一个固定的常数 $c$，使得对于所有足够大的 $n$ 都有 $n \\le c$。这是不可能的，因为函数 $f(n)=n$ 是无界的。因此，所提供的“证明”必然存在缺陷。我们现在将分析这个所谓证明的每一步，然后评估给出的选项。\n\n这个所谓的证明包含三个不同且有缺陷的论证：\n1.  论证1：“对于每个 $n \\ge 1$，取 $c = n$。那么 $f(n) = n \\le c \\cdot 1$ 成立”。这个论证将常数 $c$ 设置为等于变量 $n$。这违反了 $\\mathcal{O}$ 记号定义中的量词顺序。常数 $c$ 必须独立于 $n$。\n2.  论证2：“$\\lim_{n \\to \\infty} \\frac{f(n)}{1} = \\lim_{n \\to \\infty} n$ '存在'，所以其增长是'良好'的，因此受一个常数限制...”。这个论证在多个方面都是错误的。极限 $\\lim_{n \\to \\infty} n$ 作为一个有限实数是不存在的；它发散到 $\\infty$。$f(n) \\in \\mathcal{O}(g(n))$ 的一个充分条件是 $\\limsup_{n \\to \\infty} \\frac{|f(n)|}{|g(n)|}  \\infty$。在本例中，极限是 $\\infty$，这证明了 $n \\notin \\mathcal{O}(1)$。该论证误解了极限检验法，并错误地声称极限“存在”。\n3.  论证3：“选择 $n_0 = 10$；对于所有 $n \\ge n_0$，我们有 $n \\le n_0$，所以 $f(n) \\le n_0 \\cdot 1$”。这个论证包含一个基本的逻辑矛盾。其前提是该陈述对所有 $n \\ge n_0$ 都成立。但所声称的不等式 $n \\le n_0$ 仅在 $n=n_0$ 时为真，而对所有 $n > n_0$ 都为假。它并非“对于所有 $n \\ge n_0$”都成立。这将 $n_0$ 作为 $n$ 的下限阈值的作用误解为 $n$ 的上限。\n\n现在我们来评估每个选项。\n\n**A. 该论证允许常数 $c$ 依赖于 $n$（使用了 $c=n$），这违反了 $\\mathcal{O}$ 定义中的量词结构；常数必须独立于 $n$ 来选择。**\n此选项正确地指出了所谓证明中第一个论证的错误。定义要求 $\\exists c$ 使得 $\\forall n \\ge n_0$。证明试图使用一个等价于 $\\forall n \\ge n_0, \\exists c$ 的结构，这是一个不同的逻辑陈述，不满足该定义。\n结论：**正确**。\n\n**B. 使用极限 $\\lim_{n \\to \\infty} \\frac{f(n)}{1}$ 来得出 $\\mathcal{O}(1)$ 的结论是无效的；不仅因为这个极限是无穷大，而且极限的存在本身并不能确立 $\\mathcal{O}(1)$ 所要求的一致常数界。**\n此选项正确地指出了第二个论证的错误。极限 $\\lim_{n \\to \\infty} n$ 是 $\\infty$，而不是一个有限值。比率 $\\frac{f(n)}{g(n)}$ 的极限发散到无穷大这一事实证明了 $f(n) \\notin \\mathcal{O}(g(n))$。证明中提出的推理完全是颠倒的。\n结论：**正确**。\n\n**C. 声称“对于 $n \\ge n_0$ 有 $n \\le n_0$”的这一步颠倒了不等式，并且误解了 $n_0$ 的作用；$n_0$ 是一个界限必须在其之后成立的阈值，而不是 $n$ 本身的上界。**\n此选项正确地指出了第三个论证的错误。陈述“对于所有 $n \\ge n_0$ 我们有 $n \\le n_0$”对于任何 $n > n_0$ 都是一个明显的谬误。它从根本上误解了 $n_0$ 建立了一个半无限区间 $[n_0, \\infty)$，在该区间上不等式必须得到满足。\n结论：**正确**。\n\n**D. 第一步中选择 $c = n$ 是可以接受的，因为它使得对于每个 $n$，$f(n) \\le c \\cdot 1$ 都为真，所以该证明正确地满足了 $\\mathcal{O}(1)$ 的定义。**\n此选项提出了一个不正确的理由。虽然选择 $c=n$ 确实使得不等式 $n \\le n$ 成立，但根据 $\\mathcal{O}$ 记号的规则，这种对 $c$ 的选择是不允许的，正如对选项 A 的分析中所解释的。因此，此选项错误地为一个有缺陷的步骤辩护。\n结论：**不正确**。\n\n**E. 证明中使用了不等式 $f(n) \\le c \\cdot 1$，但 $\\mathcal{O}(1)$ 的定义实际上要求 $f(n) \\ge c \\cdot 1$；不等式的方向是错误的。**\n此选项错误地陈述了 $\\mathcal{O}$ 记号的定义。$f(n) \\in \\mathcal{O}(g(n))$ 的定义要求一个上界，$f(n) \\le c \\cdot g(n)$。表示下界的不等式，$f(n) \\ge c \\cdot g(n)$，对应于 $\\Omega$ 记号。该所谓的证明使用了对于 $\\mathcal{O}$ 记号来说正确的不等式。\n结论：**不正确**。\n\n**F. 唯一的问题是 $n_0 = 10$ 这个具体选择；选择一个足够大的 $n_0$ 会使得不等式 $n \\le n_0$ 对于所有 $n \\ge n_0$ 都成立，从而可以修正这个证明。**\n此选项不正确，原因有二。首先，它声称关于 $n_0$ 的错误是*唯一*的问题，这是错误的，正如选项 A 和 B 中所记录的。其次，它提议的“修正”是不可能的。不存在任何 $n_0$ 值能使得陈述“$n \\le n_0$ 对于所有 $n \\ge n_0$ 都成立”为真。其推理存在根本性缺陷，无法通过选择不同的 $n_0$ 来修正。\n结论：**不正确**。", "answer": "$$\\boxed{ABC}$$", "id": "3210000"}, {"introduction": "在牢固掌握了定义之后，我们现在可以将其应用于算法分析的一项核心任务：比較不同函数的增长率。本练习 [@problem_id:3209962] 要求你使用小 $o$ ($o$) 表示法，为一组常见函数建立一个严格的增长层级。成功地对这些函数进行排序，有助于建立一个关于不同复杂度类别（从对数到阶乘）如何相互关联的直观理解。", "problem": "考虑函数 $f_1(n) = n \\log n$，$f_2(n) = n^{3/2}$，$f_3(n) = n!$，$f_4(n) = 2^n$ 和 $f_5(n) = (\\log n)^2$。使用小o (little-$o$) 和小omega (little-$\\omega$) 的严格定义，构建当 $n \\to \\infty$ 时这些函数之间最紧密的渐近关系链。也就是说，确定一个 $\\{1,2,3,4,5\\}$ 的排列 $\\pi$，使得\n$$\nf_{\\pi(1)}(n) \\in o\\!\\left(f_{\\pi(2)}(n)\\right), \\quad\nf_{\\pi(2)}(n) \\in o\\!\\left(f_{\\pi(3)}(n)\\right), \\quad\nf_{\\pi(3)}(n) \\in o\\!\\left(f_{\\pi(4)}(n)\\right), \\quad\nf_{\\pi(4)}(n) \\in o\\!\\left(f_{\\pi(5)}(n)\\right),\n$$\n并且等价地，对于每个 $i \\in \\{1,2,3,4\\}$，都有 $f_{\\pi(i+1)}(n) \\in \\omega\\!\\left(f_{\\pi(i)}(n)\\right)$。从第一性原理证明链中的每一个环节。\n\n令 $p_k$ 表示第 $k$ 个素数，其中 $p_1 = 2$，$p_2 = 3$，$p_3 = 5$，$p_4 = 7$，$p_5 = 11$。在确定了正确的排列 $\\pi$ 之后，计算精确整数\n$$\nE \\;=\\; \\prod_{i=1}^{5} p_{\\pi(i)}^{\\,i}.\n$$\n将最终值表示为一个没有舍入的精确整数。", "solution": "该问题需要完成两个主要任务。首先，我们必须使用小o记号的定义，为给定的五个函数建立一个严格的渐近序。其次，基于这个序，我们必须计算一个由素数的特定次幂的乘积得到的整数值 $E$。\n\n需要排序的函数是：\n$f_1(n) = n \\log n$\n$f_2(n) = n^{3/2}$\n$f_3(n) = n!$\n$f_4(n) = 2^n$\n$f_5(n) = (\\log n)^2$\n\n小o的定义如下：如果对于所有常数 $c > 0$，存在一个常数 $n_0$，使得对于所有 $n > n_0$，都有 $0 \\le g(n)  c \\cdot h(n)$，则函数 $g(n)$ 属于 $o(h(n))$。对于当 $n$ 足够大时为正的函数，这等价于极限的定义：\n$$\ng(n) \\in o(h(n)) \\iff \\lim_{n \\to \\infty} \\frac{g(n)}{h(n)} = 0\n$$\n我们将使用这个基于极限的定义来证明排序的每一步。对数的底不影响渐近序，因为不同底的对数通过一个常数因子相关联：$\\log_a n = \\frac{\\log_b n}{\\log_b a}$。为了微积分（特别是洛必达法则）的计算，我们将使用自然对数，记作 $\\ln(n)$。\n\n目标是找到一个 $\\{1,2,3,4,5\\}$ 的排列 $\\pi$，使得 $f_{\\pi(1)}(n) \\in o(f_{\\pi(2)}(n))$，$f_{\\pi(2)}(n) \\in o(f_{\\pi(3)}(n))$，依此类推。\n\n让我们进行两两比较。\n\n1.  比较 $f_5(n) = (\\ln n)^2$ 和 $f_1(n) = n \\ln n$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_5(n)}{f_1(n)} = \\lim_{n \\to \\infty} \\frac{(\\ln n)^2}{n \\ln n} = \\lim_{n \\to \\infty} \\frac{\\ln n}{n}\n    $$\n    这个极限是 $\\frac{\\infty}{\\infty}$ 的不定式，因此我们应用洛必达法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{\\ln n}{n} = \\lim_{n \\to \\infty} \\frac{\\frac{d}{dn}(\\ln n)}{\\frac{d}{dn}(n)} = \\lim_{n \\to \\infty} \\frac{1/n}{1} = 0\n    $$\n    由于极限为 $0$，我们有 $f_5(n) \\in o(f_1(n))$。\n\n2.  比较 $f_1(n) = n \\ln n$ 和 $f_2(n) = n^{3/2}$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_1(n)}{f_2(n)} = \\lim_{n \\to \\infty} \\frac{n \\ln n}{n^{3/2}} = \\lim_{n \\to \\infty} \\frac{\\ln n}{n^{1/2}}\n    $$\n    同样，我们得到 $\\frac{\\infty}{\\infty}$ 的形式，并应用洛必达法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{\\ln n}{n^{1/2}} = \\lim_{n \\to \\infty} \\frac{\\frac{d}{dn}(\\ln n)}{\\frac{d}{dn}(n^{1/2})} = \\lim_{n \\to \\infty} \\frac{1/n}{\\frac{1}{2}n^{-1/2}} = \\lim_{n \\to \\infty} \\frac{2n^{1/2}}{n} = \\lim_{n \\to \\infty} \\frac{2}{n^{1/2}} = 0\n    $$\n    因此，$f_1(n) \\in o(f_2(n))$。这证实了任何多对数因子的增长速度都慢于任何多项式因子（其中指数为正）。\n\n3.  比较 $f_2(n) = n^{3/2}$ 和 $f_4(n) = 2^n$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_2(n)}{f_4(n)} = \\lim_{n \\to \\infty} \\frac{n^{3/2}}{2^n}\n    $$\n    这是 $\\frac{\\infty}{\\infty}$ 的形式。应用洛必达法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{n^{3/2}}{2^n} = \\lim_{n \\to \\infty} \\frac{\\frac{3}{2}n^{1/2}}{2^n \\ln 2}\n    $$\n    这仍然是 $\\frac{\\infty}{\\infty}$ 的形式。再次应用该法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{\\frac{3}{2} \\cdot \\frac{1}{2} n^{-1/2}}{2^n (\\ln 2)^2} = \\lim_{n \\to \\infty} \\frac{3}{4 n^{1/2} 2^n (\\ln 2)^2} = 0\n    $$\n    分母增长到无穷大，而分子是常数。因此，$f_2(n) \\in o(f_4(n))$。这证实了多项式函数的增长速度慢于指数函数的一般原理。\n\n4.  比较 $f_4(n) = 2^n$ 和 $f_3(n) = n!$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_4(n)}{f_3(n)} = \\lim_{n \\to \\infty} \\frac{2^n}{n!}\n    $$\n    让我们考虑项 $a_n = \\frac{2^n}{n!}$。我们可以将其写为：\n    $$\n    a_n = \\frac{2}{1} \\cdot \\frac{2}{2} \\cdot \\frac{2}{3} \\cdot \\frac{2}{4} \\cdots \\frac{2}{n}\n    $$\n    对于 $n > 2$，当 $k=3, \\dots, n$ 时，项 $\\frac{2}{k}$ 都小于或等于 $\\frac{2}{3}$。\n    所以对于 $n \\ge 3$，我们有 $0  \\frac{2^n}{n!} = \\frac{2^2}{2!} \\cdot \\frac{2}{3} \\cdots \\frac{2}{n} \\le 2 \\cdot \\left(\\frac{2}{3}\\right)^{n-2}$。\n    当 $n \\to \\infty$ 时，$\\left(\\frac{2}{3}\\right)^{n-2} \\to 0$。根据夹逼定理，$\\lim_{n \\to \\infty} \\frac{2^n}{n!} = 0$。\n    因此，$f_4(n) \\in o(f_3(n))$。\n\n综合这些结果，我们得到以下严格的渐近序：\n$$\nf_5(n) \\in o(f_1(n)), \\quad f_1(n) \\in o(f_2(n)), \\quad f_2(n) \\in o(f_4(n)), \\quad f_4(n) \\in o(f_3(n))\n$$\n这对应于问题所要求的链：$f_{\\pi(1)}(n), f_{\\pi(2)}(n), f_{\\pi(3)}(n), f_{\\pi(4)}(n), f_{\\pi(5)}(n)$。\n通过匹配函数，我们确定排列 $\\pi$：\n- $f_{\\pi(1)}(n)$ 是增长最慢的函数，即 $f_5(n)$。所以，$\\pi(1) = 5$。\n- $f_{\\pi(2)}(n)$ 是序列中的下一个，即 $f_1(n)$。所以，$\\pi(2) = 1$。\n- $f_{\\pi(3)}(n)$ 是 $f_2(n)$。所以，$\\pi(3) = 2$。\n- $f_{\\pi(4)}(n)$ 是 $f_4(n)$。所以，$\\pi(4) = 4$。\n- $f_{\\pi(5)}(n)$ 是增长最快的函数，即 $f_3(n)$。所以，$\\pi(5) = 3$。\n\n该排列是 $\\pi(1)=5$, $\\pi(2)=1$, $\\pi(3)=2$, $\\pi(4)=4$, $\\pi(5)=3$。\n\n现在我们计算 $E$ 的值。给定的素数是 $p_1 = 2$，$p_2 = 3$，$p_3 = 5$，$p_4 = 7$ 和 $p_5 = 11$。\n$E$ 的公式是：\n$$\nE \\;=\\; \\prod_{i=1}^{5} p_{\\pi(i)}^{\\,i} = p_{\\pi(1)}^1 \\cdot p_{\\pi(2)}^2 \\cdot p_{\\pi(3)}^3 \\cdot p_{\\pi(4)}^4 \\cdot p_{\\pi(5)}^5\n$$\n代入 $\\pi(i)$ 的值：\n$$\nE = p_5^1 \\cdot p_1^2 \\cdot p_2^3 \\cdot p_4^4 \\cdot p_3^5\n$$\n代入素数值：\n$$\nE = (11)^1 \\cdot (2)^2 \\cdot (3)^3 \\cdot (7)^4 \\cdot (5)^5\n$$\n现在我们计算每一项的值：\n- $11^1 = 11$\n- $2^2 = 4$\n- $3^3 = 27$\n- $7^4 = (7^2)^2 = 49^2 = 2401$\n- $5^5 = 3125$\n\n我们将这些值相乘：\n$$\nE = 11 \\cdot 4 \\cdot 27 \\cdot 2401 \\cdot 3125\n$$\n为了简化计算，我们可以重新排列各项。让我们将易于相乘的项组合在一起。\n$$\nE = (4 \\cdot 3125) \\cdot (11 \\cdot 27) \\cdot 2401\n$$\n计算括号内的值：\n- $4 \\cdot 3125 = 12500$\n- $11 \\cdot 27 = 297$\n所以，表达式变为：\n$$\nE = 12500 \\cdot 297 \\cdot 2401\n$$\n现在将 $12500$ 乘以 $297$：\n$$\n12500 \\cdot 297 = 12500 \\cdot (300 - 3) = 12500 \\cdot 300 - 12500 \\cdot 3 = 3750000 - 37500 = 3712500\n$$\n表达式现在是：\n$$\nE = 3712500 \\cdot 2401\n$$\n这可以计算为 $3712500 \\cdot (2400 + 1)$:\n$$\nE = 3712500 \\cdot 2400 + 3712500 \\cdot 1\n$$\n让我们计算 $37125 \\cdot 24$：\n$37125 \\cdot 24 = 37125 \\cdot (20 + 4) = 742500 + 148500 = 891000$。\n所以，$3712500 \\cdot 2400 = 37125 \\cdot 100 \\cdot 24 \\cdot 100 = 891000 \\cdot 10000 = 8910000000$。\n最后，我们加上剩余的部分：\n$$\nE = 8910000000 + 3712500 = 8913712500\n$$\n精确整数值为 $8,913,712,500$。\n让我们用不同的分组方式重新验证计算：\n$E = (2^2 \\cdot 5^5) \\cdot (3^3 \\cdot 7^4) \\cdot 11^1 = (4 \\cdot 3125) \\cdot (27 \\cdot 2401) \\cdot 11$。\n- $4 \\cdot 3125 = 12500$。\n- $27 \\cdot 2401 = 27 \\cdot (2400+1) = 64800 + 27 = 64827$。\n$E = 12500 \\cdot 64827 \\cdot 11$。\n$E = 12500 \\cdot (64827 \\cdot 11) = 12500 \\cdot 713097$。\n为了计算 $125 \\cdot 713097$，我们可以使用性质 $125 = 1000/8$：\n$125 \\cdot 713097 = \\frac{713097000}{8} = 89137125$。\n所以，$E = 12500 \\cdot 713097 = 100 \\cdot (125 \\cdot 713097) = 100 \\cdot 89137125 = 8913712500$。\n两种计算方法都得到相同的结果，从而确认了最终答案。\n$$\nE = 8913712500\n$$", "answer": "$$\n\\boxed{8913712500}\n$$", "id": "3209962"}, {"introduction": "渐进分析是一个强大的工具，但将理论与实际应用联系起来至关重要。由于常数因子的存在，一个具有更优渐进复杂度的算法在所有输入规模下不一定都更快。本练习 [@problem_id:3210023] 旨在探索这种现实世界中的权衡，要求你计算两种算法的“交叉点”，即渐进性能更优的算法真正成为更高效选择的输入规模。", "problem": "您正在比较解决同一问题的两种算法，其输入规模为 $n$。它们的精确运行时间模型分别为 $T_{A}(n) = 500\\,n\\,\\ln n$ 和 $T_{B}(n) = 0.1\\,n^{2}$，其中 $\\ln$ 表示自然对数。从渐近的角度来看，$T_{A}(n)$ 属于 $\\Theta(n \\ln n)$ 类，$T_{B}(n)$ 属于 $\\Theta(n^{2})$ 类。根据渐近记号的基本定义以及 $n \\ln n \\in o(n^{2})$ 这一事实，存在一个阈值 $n_{0}$，当 $n$ 超过该值时，算法A的运行时间将严格小于算法B。将交叉点 $n_{0}$ 定义为方程 $T_{A}(n) = T_{B}(n)$ 的较大正数解，使得对于所有 $n \\ge n_{0}$，算法A都比算法B快。计算 $n_{0}$ 的一个近似值。为便于近似计算，假定 $n$ 为实数。将最终数值答案四舍五入到四位有效数字。", "solution": "我们正在寻找两种算法运行时间的交叉点。\n\n### 第1步：建立方程\n设算法A的运行时间为 $T_{A}(n) = 500\\,n\\,\\ln n$，算法B的运行时间为 $T_{B}(n) = 0.1\\,n^{2}$。交叉点 $n_0$ 是方程 $T_{A}(n) = T_{B}(n)$ 的较大正数解。\n\n$$500\\,n\\,\\ln n = 0.1\\,n^{2}$$\n\n因为我们在寻找 $n > 0$ 的解，我们可以安全地将方程两边同时除以 $n$：\n$$500\\,\\ln n = 0.1\\,n$$\n两边乘以 $10$ 以简化常数，得到：\n$$5000\\,\\ln n = n$$\n\n### 第2步：分析方程\n这是一个超越方程，无法用初等函数得到闭式解。我们必须使用数值方法来找到一个近似解。为了理解根的行为，我们分析函数 $g(n) = n - 5000\\,\\ln n$。我们寻求 $g(n)=0$ 的根。其导数为 $g'(n) = 1 - \\frac{5000}{n}$。\n导数在 $n=5000$ 时为零。\n- 当 $0  n  5000$ 时，$g'(n)  0$，因此 $g(n)$ 是递减的。\n- 当 $n > 5000$ 时，$g'(n) > 0$，因此 $g(n)$ 是递增的。\n这意味着函数在 $n=5000$ 处有一个全局最小值。最小值为 $g(5000) = 5000 - 5000\\,\\ln(5000) = 5000(1-\\ln(5000))$。因为 $e \\approx 2.718$，我们知道 $\\ln(5000) > \\ln(e^2) = 2 > 1$，因此 $g(5000)  0$。\n函数在 $n \\to 0^{+}$ 时趋于 $+\\infty$，在 $n \\to \\infty$ 时也趋于 $+\\infty$。因此，根据介值定理，存在两个正根：一个在区间 $(0, 5000)$ 内，另一个在区间 $(5000, \\infty)$ 内。问题要求的是较大的根。\n\n### 第3步：数值求解\n我们可以使用不动点迭代法来求解方程 $n = 5000\\,\\ln n$。我们定义迭代函数为 $h(n) = 5000\\,\\ln n$，并使用迭代公式 $n_{k+1} = h(n_k)$。\n为了收敛到较大的根 $n_0$，我们需要从一个大于 $5000$ 的初始猜测值 $n_{start}$ 开始，因为对于 $n > 5000$，导数 $|h'(n)| = |\\frac{5000}{n}|  1$。\n我们选择一个简单的初始猜测值，例如 $n_1 = 10000$。\n\n让我们执行迭代：\n- $n_2 = 5000\\,\\ln(10000) \\approx 5000 \\times 9.21034 = 46051.7$\n- $n_3 = 5000\\,\\ln(46051.7) \\approx 5000 \\times 10.73755 = 53687.8$\n- $n_4 = 5000\\,\\ln(53687.8) \\approx 5000 \\times 10.89083 = 54454.2$\n- $n_5 = 5000\\,\\ln(54454.2) \\approx 5000 \\times 10.90510 = 54525.5$\n- $n_6 = 5000\\,\\ln(54525.5) \\approx 5000 \\times 10.90639 = 54532.0$\n- $n_7 = 5000\\,\\ln(54532.0) \\approx 5000 \\times 10.90651 = 54532.6$\n- $n_8 = 5000\\,\\ln(54532.6) \\approx 5000 \\times 10.90652 = 54532.6$\n\n序列快速收敛到约 $54532.6$。问题要求答案四舍五入到四位有效数字。\n这个数字是 $54532.6$。\n第一个有效数字是 $5$。\n第二个有效数字是 $4$。\n第三个有效数字是 $5$。\n第四个有效数字是 $3$。\n第五个有效数字是 $2$。由于 $2  5$，我们向下舍入，这意味着我们保持第四位数字不变。\n四舍五入到四位有效数字后的数值是 $54530$。用科学记数法表示为 $5.453 \\times 10^{4}$。\n\n对于所有 $n \\ge n_0 \\approx 5.453 \\times 10^4$，算法A将比算法B更快。", "answer": "$$\n\\boxed{5.453 \\times 10^{4}}\n$$", "id": "3210023"}]}