{"hands_on_practices": [{"introduction": "本练习是分析基于指针的数据结构上算法的基础。虽然该算法看似只进行单次遍历，但要证明无论数据具体如何分布，它都精确执行 $n-1$ 次比较，则需要对循环不变量进行严谨的推理。这项实践旨在训练对迭代过程进行精确计数的核心技能，这是算法分析的基石 [@problem_id:3207266]。", "problem": "考虑一个包含 $n$ 个节点的单链表 $L$，其中每个节点存储一个整数键值和一个指向下一个节点的指针。假设 $L$ 中的键值按非递减顺序排序，因此所有重复的键值都出现在连续的节点中。以下迭代算法移除所有重复项，为每个不同的键值只保留一个节点：\n\n- 令 $x$ 表示 $L$ 的头节点。\n- 当 $x \\neq \\text{null}$ 且 $x.\\text{next} \\neq \\text{null}$ 时：\n    - 如果 $x.\\text{key} = x.\\text{next}.\\text{key}$，则设置 $x.\\text{next} := x.\\text{next}.\\text{next}$。\n    - 否则，设置 $x := x.\\text{next}$。\n\n假设采用标准的单位成本随机存取机（RAM）模型，在该模型中，每次键值比较（例如 $x.\\text{key} = x.\\text{next}.\\text{key}$）和每次指针赋值（例如 $x := x.\\text{next}$ 或 $x.\\text{next} := x.\\text{next}.\\text{next}$）都花费常数时间，记为 $O(1)$。在此模型下，对于任何符合给定假设的输入实例，从第一性原理推导出该算法执行的键值比较确切次数的闭式表达式（作为 $n$ 的函数）。然后，根据该次数推断出算法的紧渐近时间复杂度（用大$\\Theta$符号表示），作为 $n$ 的函数。将你的最终答案表示为使用大$\\Theta$符号的单个解析表达式。", "solution": "问题要求分析一个给定的迭代算法，该算法用于从一个已排序的单链表中移除重复项。分析必须首先得出一个关于键值比较次数的确切闭式表达式，然后推导出用大$\\Theta$符号表示的紧渐近时间复杂度。\n\n设单链表为 $L$，包含 $n$ 个节点。我们按顺序将原始节点表示为 $N_1, N_2, \\ldots, N_n$。设 $k_i$ 是存储在节点 $N_i$ 中的键值。由于链表按非递减顺序排序，我们有 $k_1 \\le k_2 \\le \\ldots \\le k_n$。算法如下：\n1. 初始化一个指针 $x$ 指向链表的头节点 $N_1$。\n2. 当 $x \\neq \\text{null}$ 且 $x.\\text{next} \\neq \\text{null}$ 时循环。\n3. 在循环内部，比较 $x.\\text{key}$ 和 $x.\\text{next}.\\text{key}$。\n   a. 如果它们相等，则发现一个重复项。通过设置 $x.\\text{next} := x.\\text{next}.\\text{next}$ 来移除节点 $x.\\text{next}$。指针 $x$ 保持在当前位置，以检查是否还有更多的重复项。\n   b. 如果它们不相等，则对于 $x$ 的当前键值没有重复项。通过设置 $x := x.\\text{next}$ 将指针 $x$ 前移到下一个节点。\n\n主要任务是找出键值比较的确切次数。在 `while` 循环的每次迭代中，键值比较 $x.\\text{key} = x.\\text{next}.\\text{key}$ 都会执行一次。因此，键值比较的总次数等于循环的总迭代次数。\n\n让我们分析循环迭代的次数。只要 $x.\\text{next} \\neq \\text{null}$，循环就会继续。我们将证明对于任何大小为 $n \\ge 1$ 的输入链表，循环都恰好执行 $n-1$ 次。\n如果 $n=0$，链表为空，$x$ 初始化为 $\\text{null}$，循环条件 $x \\neq \\text{null}$ 为假，执行 0 次比较。\n如果 $n=1$，$x$ 指向 $N_1$，但 $x.\\text{next}$ 是 $\\text{null}$。循环条件 $x.\\text{next} \\neq \\text{null}$ 为假，执行 0 次比较。注意在这种情况下 $n-1 = 0$。\n\n现在，考虑 $n \\ge 2$ 的情况。让我们追踪每次迭代开始时 $x.\\text{next}$ 所指向的节点。设迭代次数为 $i$，从 $i=1$ 开始。\n- **迭代 $i=1$**：最初，$x$ 指向 $N_1$。因此，$x.\\text{next}$ 指向 $N_2$。循环条件为真，进行第一次比较。\n- **迭代 $i=2$ 开始时**：第一次迭代后，我们分析 $x.\\text{next}$ 的位置。\n  - 情况 1 ($k_1 = k_2$)：执行赋值操作 $x.\\text{next} := x.\\text{next}.\\text{next}$。由于 $x$ 是 $N_1$ 且 $x.\\text{next}$ 是 $N_2$，因此 $N_1$ 的新 $x.\\text{next}$ 变为 $N_3$。指针 $x$ 本身不改变。所以，在第二次迭代开始时，$x$ 仍然是 $N_1$ 且 $x.\\text{next}$ 指向 $N_3$。\n  - 情况 2 ($k_1 \\neq k_2$)：执行赋值操作 $x := x.\\text{next}$。由于 $x$ 是 $N_1$ 且 $x.\\text{next}$ 是 $N_2$，$x$ 现在指向 $N_2$。新的 $x.\\text{next}$ 是原始列表中 $N_2$ 的后继节点，即 $N_3$。\n在这两种情况下，第二次迭代开始时，在 $x.\\text{next}$ 处被考虑的节点都是 $N_3$。\n\n我们可以概括这个观察结果。我们提出一个不变量：在第 $i$ 次迭代开始时（其中 $1 \\le i  n-1$），指针 $x.\\text{next}$ 指向原始节点 $N_{i+1}$。\n- **基础情况 ($i=1$)**：如上所示，这是成立的。\n- **归纳步骤**：假设不变量对于第 $i$ 次迭代成立，其中 $1 \\le i  n-1$。所以在第 $i$ 次迭代开始时，$x.\\text{next}$ 指向 $N_{i+1}$。进行一次比较。\n  - 如果 $x.\\text{key} = x.\\text{next}.\\text{key}$，$x$ 保持不变，而 $x.\\text{next}$ 被更新为指向 $N_{i+2}$。\n  - 如果 $x.\\text{key} \\neq x.\\text{next}.\\text{key}$，$x$ 被更新为指向 $N_{i+1}$，所以它的 `next` 指针指向 $N_{i+2}$。\n在这两种结果中，在第 $i+1$ 次迭代开始时，$x.\\text{next}$ 引用的节点是 $N_{(i+1)+1} = N_{i+2}$。不变量成立。\n\n这个归纳论证表明，循环会迭代 $i=1, 2, \\ldots, n-1$。在第 $(n-1)$ 次迭代中，$x.\\text{next}$ 指向 $N_n$。这次迭代之后：\n- 如果 $x.\\text{key} = N_n.\\text{key}$：$x.\\text{next}$ 被设置为 $N_n.\\text{next}$，即 $\\text{null}$。\n- 如果 $x.\\text{key} \\neq N_n.\\text{key}$：$x$ 被设置为 $N_n$，其 `next` 指针为 $\\text{null}$。\n在任何一种情况下，在下一次可能的迭代之前，循环条件 $x.\\text{next} \\neq \\text{null}$ 将为假。因此，循环在恰好 $n-1$ 次迭代后终止。\n\n对于 $n \\ge 1$，键值比较的次数 $C(n)$ 恰好是 $n-1$。对于 $n=0$，$C(0)=0$。覆盖所有非负整数 $n$ 的闭式表达式是 $C(n) = \\max(0, n-1)$。假设链表大小不为平凡情况（$n \\ge 1$），则计数为 $n-1$。\n\n接下来，我们推导紧渐近时间复杂度 $T(n)$。我们使用标准的单位成本RAM模型，其中每个基本操作的成本为 $O(1)$。该算法包括：\n1. 一个初始指针赋值 ($x := \\text{head}$)：这花费常数时间, $O(1)$。\n2. `while` 循环：\n   - 循环条件检查：条件 $x \\neq \\text{null}$ 和 $x.\\text{next} \\neq \\text{null}$ 在每次迭代开始时检查一次，并在循环终止时最后检查一次。对于 $n \\ge 1$，这总共相当于 $n$ 次检查。每次检查的成本为 $O(1)$，因此检查的总成本为 $n \\times O(1) = O(n)$。\n   - 循环体：对于 $n \\ge 1$，循环执行 $n-1$ 次。在每次迭代中，算法执行：\n     - 一次键值比较：$O(1)$。\n     - 一次指针赋值（在 `if` 或 `else` 分支中）：$O(1)$。\n   因此，每次迭代内部的工作量是常数，即 $O(1)$。在所有迭代中，循环体花费的总时间是 $(n-1) \\times O(1) = O(n)$。\n\n总时间复杂度是各项成本之和：\n$T(n) = (\\text{初始化}) + (\\text{循环检查}) + (\\text{循环体执行})$\n对于 $n \\ge 1$，$T(n) = O(1) + O(n) + O(n) = O(n)$。\n这确立了时间复杂度的上界。\n\n对于下界，我们观察到对于任何 $n \\ge 1$ 的输入，算法必须执行 $n-1$ 次迭代。每次迭代至少涉及一次键值比较和相关的指针操作，这些操作需要某个最小的常数时间 $c > 0$。因此，总时间必须至少与 $n-1$ 成正比。\n对于某个常数 $c>0$ 和 $n \\ge 1$，$T(n) \\ge c \\cdot (n-1)$。\n这意味着 $T(n) \\in \\Omega(n-1)$，可以简化为 $T(n) \\in \\Omega(n)$。\n\n由于 $T(n) \\in O(n)$ 且 $T(n) \\in \\Omega(n)$，该算法的紧渐近时间复杂度为 $\\Theta(n)$。", "answer": "$$\\boxed{\\Theta(n)}$$", "id": "3207266"}, {"introduction": "这个练习将我们从一维迭代分析带入二维空间。算法的执行路径不再是简单的线性扫描，而是在矩阵中根据决策进行的移动，每一步都排除掉一部分搜索空间。这项实践的挑战在于确定代表最坏情况的最长可能路径，它展示了一种分析此类“维度削减”算法的经典而巧妙的技巧 [@problem_id:3207190]。", "problem": "考虑一个大小为 $n \\times m$ 的实数矩形二维矩阵 $A$，其中 $n \\geq 1$ 且 $m \\geq 1$。$A$ 的每一行从左到右按非递减顺序排序，每一列从上到下按非递减顺序排序。定义一个确定性迭代搜索算法来定位给定的实数键 $x$，其过程如下：算法从右上角位置 $(i,j) = (1,m)$ 开始，并在索引保持在边界 $1 \\leq i \\leq n$ 和 $1 \\leq j \\leq m$ 内时重复以下步骤：\n- 将 $A[i,j]$ 与 $x$ 进行比较。\n- 如果 $A[i,j] = x$，则终止并报告成功。\n- 如果 $A[i,j]  x$，则更新 $j \\leftarrow j - 1$。\n- 如果 $A[i,j]  x$，则更新 $i \\leftarrow i + 1$。\n如果索引超出边界（具体来说，如果 $i = n+1$ 或 $j = 0$），则终止并报告 $x$ 不存在。\n\n请仅使用数据结构与算法中关于迭代算法和基于比较模型的基本定义，从第一性原理出发，推导该算法在任何有效的输入矩阵 $A$ 和任意实数键 $x$ 上执行的比较次数的精确最坏情况，并将其表示为关于 $n$ 和 $m$ 的函数。你的最终答案必须是关于 $n$ 和 $m$ 的单个解析闭式表达式。此答案不需要四舍五入或指定单位。", "solution": "目标是确定给定迭代算法所执行的比较次数的最坏情况。由于每次迭代恰好执行一次比较，所以比较次数等于主循环的迭代次数。为了找到最坏情况，我们必须找到可能的最大迭代次数。\n\n设每次迭代开始时算法的状态由被检查的矩阵单元的坐标 $(i,j)$ 表示。算法从 $(i,j) = (1,m)$ 开始。在每一步中，坐标从 $(i,j)$ 变为 $(i+1, j)$（“向下”移动）或 $(i, j-1)$（“向左”移动）。当找到键 $x$ 或索引超出边界时，算法终止。最坏情况发生在未找到键时（或在最长可能路径的最后一步找到），这会迫使算法运行最大步数。\n\n我们来分析索引 $(i,j)$ 的路径。设 $k$ 为比较次数，这对应于 $k$ 次循环迭代。设 $(i_t, j_t)$ 为第 $t$ 次迭代开始时的索引，其中 $t = 1, 2, \\dots, k$。\n初始状态为 $(i_1, j_1) = (1,m)$。\n\n为了分析路径长度，我们基于索引定义一个势函数（或一个类不变量）$S$：\n$$S(i,j) = (i - 1) + (m - j)$$\n在算法开始时（第 $t=1$ 次迭代开始），我们在 $(i_1, j_1) = (1,m)$，因此 $S$ 的初始值为：\n$$S_1 = S(1,m) = (1 - 1) + (m - m) = 0$$\n现在，我们来考察 $S$ 在每一步如何变化。假设在第 $t$ 次迭代开始时，状态为 $(i_t, j_t)$。下一个状态 $(i_{t+1}, j_{t+1})$ 由比较结果决定：\n1.  **向下移动**：如果 $A[i_t, j_t]  x$，则 $(i_{t+1}, j_{t+1}) = (i_t+1, j_t)$。\n    $S$ 的新值为 $S_{t+1} = S(i_t+1, j_t) = ((i_t+1) - 1) + (m - j_t) = (i_t - 1) + (m - j_t) + 1 = S_t + 1$。\n2.  **向左移动**：如果 $A[i_t, j_t] > x$，则 $(i_{t+1}, j_{t+1}) = (i_t, j_t-1)$。\n    $S$ 的新值为 $S_{t+1} = S(i_t, j_t-1) = (i_t - 1) + (m - (j_t-1)) = (i_t - 1) + (m - j_t) + 1 = S_t + 1$。\n\n在每次迭代中，$S$ 的值都恰好增加 $1$。由于 $S_1 = 0$，在第 $k$ 次迭代开始时，$S$ 的值将为 $S_k = k-1$。\n第 $k$ 次比较在坐标 $(i_k, j_k)$ 处进行。因此，我们有以下关系：\n$$k - 1 = S(i_k, j_k) = (i_k - 1) + (m - j_k)$$\n$$k = i_k + m - j_k$$\n算法执行 $k$ 次比较然后终止。终止的原因是下一次计算的索引 $(i_{k+1}, j_{k+1})$ 超出了矩阵边界。这意味着要么 $i_{k+1} = n+1$，要么 $j_{k+1} = 0$。\n这只可能在第 $k$ 次比较是在矩阵边界上的一个单元格 $(i_k, j_k)$ 进行时发生：\n- 如果下一步是“向下”移动导致终止，那么必然有 $i_k = n$。该移动试图将 $i_{k+1}$ 设置为 $n+1$。\n- 如果下一步是“向左”移动导致终止，那么必然有 $j_k = 1$。该移动试图将 $j_{k+1}$ 设置为 $0$。\n\n所以，最后一个访问的单元格 $(i_k, j_k)$ 必须满足 $i_k=n$ 或 $j_k=1$。我们想要找到最坏情况，这意味着我们要最大化 $k$。我们可以通过在所有可能到达的终止单元格 $(i_k, j_k)$ 上最大化表达式 $k = i_k + m - j_k$ 来实现。\n\n情况1：最后一个访问的单元格在最底行，即 $i_k=n$。\n比较次数为 $k = n + m - j_k$。为了最大化 $k$，我们必须最小化 $j_k$。列索引的最小可能值为 $j_k=1$。这给出了 $k$ 的一个最大可能值：\n$$k_{max} = n + m - 1$$\n这对应于算法在单元格 $(n,1)$ 处终止。\n\n情况2：最后一个访问的单元格在最左列，即 $j_k=1$。\n比较次数为 $k = i_k + m - 1$。为了最大化 $k$，我们必须最大化 $i_k$。行索引的最大可能值为 $i_k=n$。这给出了 $k$ 的一个最大可能值：\n$$k_{max} = n + m - 1$$\n这也对应于算法在单元格 $(n,1)$ 处终止。\n\n两种情况都得出了相同的最大值。搜索的最长路径是从右上角 $(1,m)$ 到左下角 $(n,1)$ 的任何路径。这样一条路径总共需要 $(n-1)$ 次“向下”移动和 $(m-1)$ 次“向左”移动。这样一条路径上访问的单元格总数为 $1 + (n-1) + (m-1) = n+m-1$。由于在每个单元格进行一次比较，所以总比较次数为 $n+m-1$。\n\n可以构造一个矩阵 $A$ 并选择一个键 $x$，迫使算法遍历这样一条路径。例如，令从 $(1,m)$ 到 $(n,1)$ 路径上的所有单元格 $A[i,j] = 1$，此路径“下方和左侧”的所有单元格 $A[i,j] = 0$，此路径“上方和右侧”的所有单元格 $A[i,j] = 2$。搜索 $x=1.5$ 就可以追踪这条路径。\n\n因此，精确的最坏情况比较次数是最长可能路径的长度，即 $n+m-1$。", "answer": "$$\\boxed{n+m-1}$$", "id": "3207190"}, {"introduction": "这是一个更高级的练习，将我们的分析从最坏情况推向平均情况，后者是实用算法设计中的一个关键概念。本题涉及一个经典的对数复杂度算法——二分搜索，其核心任务是在已知输入分布的情况下，精确计算比较次数的期望值。这需要更复杂的数学方法，将递归思想与组合求和技巧相结合，以获得一个精确的封闭形式解 [@problem_id:3207292]。", "problem": "考虑一个在包含 $n$ 个不同键的已排序数组 $A[0], A[1], \\dots, A[n-1]$ 上进行的迭代二分搜索，其中 $n$ 不是 $2$ 的幂。该搜索算法初始化下界 $\\ell = 0$ 和上界 $r = n-1$，并在每次迭代中计算中点索引 $m = \\left\\lfloor \\frac{\\ell + r}{2} \\right\\rfloor$。然后，算法通过对搜索键 $x$ 和元素 $A[m]$ 调用一个全序比较器来执行恰好一次键比较，这将产生三种结果之一：$x  A[m]$、$x = A[m]$ 或 $x  A[m]$。根据此结果，算法要么终止（如果 $x = A[m]$），要么相应地更新边界为 $\\ell \\leftarrow m+1$ 或 $r \\leftarrow m-1$，然后继续。就本问题而言，“键比较”指 $x$ 和 $A[m]$ 之间全序比较器的一次调用；不计算循环守卫检查或索引算术。\n\n假设搜索键 $x$ 保证存在于数组中，并且其索引在 $\\{0, 1, \\dots, n-1\\}$ 上均匀分布。从迭代算法分析的第一性原理出发，不使用任何预先推导的快捷公式，推导在该中点规则 $m = \\left\\lfloor \\frac{\\ell + r}{2} \\right\\rfloor$ 下，算法所执行的键比较的精确平均次数，作为仅关于 $n$ 的函数。您的最终答案必须是仅用 $n$ 表示的单个封闭形式表达式（可以使用向下取整和对数函数），并且不得在表达式之外包含任何辅助定义。无需进行舍入。", "solution": "设 $C_i$ 为找到索引为 $i$ 的键所需的比较次数，其中 $i \\in \\{0, 1, \\dots, n-1\\}$。由于键的索引是均匀分布的，搜索任何特定键 $A[i]$ 的概率是 $1/n$。平均比较次数 $E[C]$ 由期望给出：\n$$E[C] = \\sum_{i=0}^{n-1} \\frac{1}{n} C_i = \\frac{1}{n} \\sum_{i=0}^{n-1} C_i$$\n设 $S(n) = \\sum_{i=0}^{n-1} C_i$ 为所有可能的成功搜索的总比较次数。我们的目标是找到 $S(n)$ 的封闭形式表达式，然后计算 $E[C] = S(n)/n$。\n\n找到索引为 $i$ 的元素所需的比较次数 $C_i$ 等于隐式二分搜索树中对应于索引 $i$ 的节点的深度，假设根节点的深度为 $1$。因此，$S(n)$ 是该树中所有节点深度的总和，也称为内部路径长度。\n\n我们来分析一下搜索的结构。该算法定义在由边界 $[\\ell, r]$ 指定的子数组上。设该子数组的大小为 $k = r - \\ell + 1$。\n第一次比较发生在中点索引 $m = \\ell + \\lfloor \\frac{r-\\ell}{2} \\rfloor = \\ell + \\lfloor \\frac{k-1}{2} \\rfloor$。对于在该子数组中搜索的 $k$ 个键中的任何一个，都会执行这一次比较。\n这次比较之后，如果在 $A[m]$ 处没有找到键，搜索将在两个子数组之一中继续：\n1.  左子数组：从索引 $\\ell$ 到 $m-1$。其大小为 $(m-1) - \\ell + 1 = m-\\ell = \\lfloor \\frac{k-1}{2} \\rfloor$。\n2.  右子数组：从索引 $m+1$ 到 $r$。其大小为 $r - (m+1) + 1 = r-m = (r-\\ell) - (m-\\ell) = (k-1) - \\lfloor \\frac{k-1}{2} \\rfloor = \\lceil \\frac{k-1}{2} \\rceil$。\n\n设 $S(k)$ 表示大小为 $k$ 的子问题的总比较次数。对于 $k$ 种可能搜索中的每一种，第一次比较都会发生，这为总比较次数贡献了 $k$。中点处的元素经过 1 次比较（相对于此子问题）被找到。剩下的 $k-1$ 个元素在子数组中。在大小为 $n_L = \\lfloor \\frac{k-1}{2} \\rfloor$ 的左子数组中搜索的总比较次数是 $S(n_L)$。同样，对于大小为 $n_R = \\lceil \\frac{k-1}{2} \\rceil$ 的右子数组，总比较次数是 $S(n_R)$。\n在子数组中的每次搜索之前，都会在当前层级进行一次比较，因此我们必须将子数组的大小加到其总比较次数上。\n因此，$S(k) = 1 (\\text{对于根节点}) + [S(n_L) + n_L] + [S(n_R) + n_R]$。\n由于 $n_L + n_R = \\lfloor \\frac{k-1}{2} \\rfloor + \\lceil \\frac{k-1}{2} \\rceil = k-1$，这可以简化为：\n$$S(k) = 1 + S(n_L) + S(n_R) + (k-1) = k + S\\left(\\left\\lfloor \\frac{k-1}{2} \\right\\rfloor\\right) + S\\left(\\left\\lceil \\frac{k-1}{2} \\right\\rceil\\right)$$\n基本情况是 $S(0) = 0$ 和 $S(1) = 1$。\n\n这个关于总路径长度的递推关系仅取决于子问题的规模，而每一步都使子问题尽可能地平衡。这个过程生成了一棵树，其节点深度的多重集与具有 $n$ 个节点的“完全”二叉树的节点深度多重集相同（一棵除了最后一层外所有层都已填满，且最后一层从左到右填充的树）。因此，我们可以通过对一个大小为 $n$ 的标准完全二叉树中所有节点的深度求和来计算 $S(n)$。\n\n设 $H$ 为具有 $n$ 个节点的完全二叉树的高度，其中根节点的深度为 $1$。高度由 $H = \\lfloor \\log_2 n \\rfloor + 1$ 给出。找到深度为 $d$ 的元素所需的比较次数为 $d$。\n在高度为 $H$ 的完全二叉树中，第 $1, 2, \\dots, H-1$ 层是满的。深度为 $d$ 的节点数为 $2^{d-1}$。\n这前 $H-1$ 层的总节点数为 $\\sum_{d=1}^{H-1} 2^{d-1} = 2^{H-1}-1$。\n剩余的节点，即 $n - (2^{H-1}-1)$ 个，都必须位于深度为 $H$ 的层。\n\n总比较次数 $S(n)$ 是所有深度的（深度 $\\times$ 该深度的节点数）之和：\n$$S(n) = \\left( \\sum_{d=1}^{H-1} d \\cdot 2^{d-1} \\right) + H \\cdot \\left( n - (2^{H-1}-1) \\right)$$\n该和是有限差分微积分中的一个标准结果。设 $G_M = \\sum_{d=1}^{M} d \\cdot x^{d-1}$。当 $x=2$ 时，表达式简化为：\n$G_M = (M-1)2^M + 1$\n我们将其应用于 $M = H-1$ 的情况：\n$$\\sum_{d=1}^{H-1} d \\cdot 2^{d-1} = ((H-1)-1)2^{H-1} + 1 = (H-2)2^{H-1} + 1$$\n将此代回 $S(n)$ 的表达式中：\n$$S(n) = (H-2)2^{H-1} + 1 + H \\cdot (n - 2^{H-1} + 1)$$\n$$S(n) = H \\cdot 2^{H-1} - 2 \\cdot 2^{H-1} + 1 + Hn - H \\cdot 2^{H-1} + H$$\n$$S(n) = Hn - 2^H + H + 1$$\n现在，代入高度的表达式 $H = \\lfloor \\log_2 n \\rfloor + 1$：\n$$S(n) = (\\lfloor \\log_2 n \\rfloor + 1)n - 2^{\\lfloor \\log_2 n \\rfloor + 1} + (\\lfloor \\log_2 n \\rfloor + 1) + 1$$\n$$S(n) = (n+1)(\\lfloor \\log_2 n \\rfloor + 1) - 2^{\\lfloor \\log_2 n \\rfloor + 1} + 1$$\n平均比较次数为 $E[C] = S(n)/n$：\n$$E[C] = \\frac{(n+1)(\\lfloor \\log_2 n \\rfloor + 1) - 2^{\\lfloor \\log_2 n \\rfloor + 1} + 1}{n}$$\n此表达式就是仅作为 $n$ 的函数的精确平均键比较次数。", "answer": "$$\n\\boxed{\n\\frac{(n+1)(\\lfloor \\log_2 n \\rfloor + 1) - 2^{\\lfloor \\log_2 n \\rfloor + 1} + 1}{n}\n}\n$$", "id": "3207292"}]}