{"hands_on_practices": [{"introduction": "递归算法的正确性天然地与数学归纳法联系在一起，其中递归的“基础情形”（base case）直接对应于归纳证明的“奠基步骤”。一个正确的基础情形是整个归纳链条得以成立的基石。本练习 [@problem_id:3213544] 将挑战我们去发现一个归并排序实现中看似无害的缺陷，从而深刻理解一个错误的基础情形是如何破坏归纳假设，并导致整个算法失效的。", "problem": "一个程序员在一个长度为 $n$ 的数组 $A$ 上实现了一个递归归并排序，其结构如下：如果 $|A| \\le 2$，则不加改变地返回 $A$；否则，将 $A$ 分成两半 $L$ 和 $R$，递归地对它们进行排序以得到 $L'$ 和 $R'$，然后返回 $\\operatorname{Merge}(L', R')$。已知合并例程 $\\operatorname{Merge}(X, Y)$ 在其两个输入 $X$ 和 $Y$ 都按非递减顺序排序的前提条件下是正确的，在这种情况下，它会返回一个包含它们所有元素的、按非递减顺序排序的单一数组。\n\n仅使用关于递归算法和归并排序正确性的基本原理，即：\n- 正确性证明通过对 $n$ 进行数学归纳来证明：一个有效的基本情况必须为最小的 $n$ 建立该属性，而归纳步骤必须假设对于严格更小的规模是正确的，然后在其前提条件下，通过使用一个正确的组合步骤来证明对于 $n$ 的情况也是正确的。\n- 合并例程的正确性要求 $\\operatorname{Merge}$ 的每个输入都已按非递减顺序排序。\n\n观察到，这个实现对大小为 $2$ 的数组产生不正确的结果，并且同样的缺陷会传播到更大的数组，因为一些递归子问题的大小为 $2$。\n\n下列哪个陈述精确地诊断了该缺陷，并提出了一个能保持预期归并排序结构的最小修正方案？\n\nA. 该算法违反了 $\\operatorname{Merge}$ 的前提条件，因为基本情况允许返回一个未排序的大小为 $2$ 的数组，因此一些对 $\\operatorname{Merge}$ 的递归输入不是排序的。将基本情况改为 $|A| \\le 1$ 可确保到达合并步骤的每个子数组都是通过合并已排序的子数组构建的，从而恢复正确性。\n\nB. 当 $n = 2$ 时，分割例程肯定不正确，因为无法形成两半，而这是错误的根源。最小的修正是调整分割索引，使得当 $n = 2$ 时它能产生大小为 $1$ 和 $1$ 的两半。\n\nC. 基本情况 $|A| \\le 2$ 将时间复杂度从 $O(n \\log n)$ 改变为 $O(n)$，而这种降低的复杂度是不正确排序的原因。最小的修复是增加更多的递归层级以恢复 $O(n \\log n)$。\n\nD. 该算法未能对元素对进行排序，因为它在 $|A| = 2$ 时不加改变地返回它们，从而在更高层级违反了 $\\operatorname{Merge}$ 的已排序输入的前提条件。一个最小的修正是处理 $|A| = 2$ 的基本情况，即在返回前对两个元素执行一次比较和交换，从而确保所有对 $\\operatorname{Merge}$ 的输入都是排序的。\n\nE. 不正确的排序是因为合并例程不稳定；将其替换为稳定的合并可以修复大小为 $2$ 的数组，而无需改变基本情况。", "solution": "我们从递归和归并排序结构的基本原理出发来分析这个算法。\n\n归并排序的正确性通常通过对 $n = |A|$ 进行归纳来建立：\n- 基本情况：对于最小的规模，返回的结果必须按非递减顺序排序。一个典型的基本情况是 $n \\le 1$，因为任何大小为 $0$ 或 $1$ 的数组都是平凡有序的。\n- 归纳步骤：假设对严格更小规模的递归调用返回已排序的数组。在这个假设下，合并例程 $\\operatorname{Merge}(L', R')$ 必须接收两个已排序的数组并返回它们排序后的拼接结果，这依赖于 $L'$ 和 $R'$ 是已排序的这一前提条件。\n\n在给定的实现中，基本情况是 $|A| \\le 2$ 并且它不加改变地返回 $A$。如果 $|A| = 2$ 且 $A = [a_1, a_2]$ 满足 $a_1 > a_2$，那么 $A$ 是未排序的。不加改变地返回 $A$ 违反了基本情况所需满足的属性。此外，当 $n > 2$ 时，递归会产生大小包含 $2$ 的子问题，而这些子问题将返回未排序的数组，这些数组随后被传递给 $\\operatorname{Merge}$，从而违反了 $\\operatorname{Merge}$ 的前提条件。这打破了归纳链：递归结果是已排序的这一归纳假设对于 $n = 2$ 是不成立的，因此归纳步骤不能依赖于 $\\operatorname{Merge}$ 的正确性。\n\n一个具体的反例说明了这种传播：令 $A = [2, 1, 3, 4]$。分割产生 $L = [2, 1]$ 和 $R = [3, 4]$。在有缺陷的基本情况下，$L' = [2, 1]$ (未排序) 且 $R' = [3, 4]$ (已排序)。将 $L'$ 和 $R'$ 传递给 $\\operatorname{Merge}$ 违反了其前提条件，一个典型的合并操作会首先选择 2 (来自 $L'$)，然后是 1，然后是 3, 4，产生 $[2, 1, 3, 4]$，这是未排序的。\n\n基于这些原则，我们评估每个选项。\n\n选项 A：它正确地指出了 $\\operatorname{Merge}$ 的前提条件被违反，因为基本情况对 $|A| = 2$ 的数组返回了未排序的结果。将基本情况改为 $|A| \\le 1$ 确保递归会继续直到单元素数组，而单元素数组是平凡有序的。这样，根据归纳假设，每个递归调用都返回已排序的输出；因此，每一层对 $\\operatorname{Merge}$ 的所有输入都满足其已排序输入的前提条件，从而恢复了正确性。这个诊断和修复方案与归纳证明框架一致。结论：正确。\n\n选项 B：它声称分割例程是 $n = 2$ 时错误的根源。然而，在给定的实现中，当 $|A| \\le 2$ 时，算法立即返回 $A$ 而不执行任何分割。因此在 $n = 2$ 时不存在不正确的分割。此外，对于 $n > 2$，标准的分割确实会在 $n=2$ 时产生大小为 1 和 1 的两半，但由于基本情况阻止了在 $n=2$ 时的递归，这种情况在这里永远不会发生。缺陷不在于分割，而在于基本情况返回了可能未排序的元素对。结论：不正确。\n\n选项 C：它断言渐近时间复杂度变为 $O(n)$，并将其归咎为不正确排序的原因。对于足够大的 $n$，基本情况 $|A| \\le 2$ 不会改变整体的渐近时间复杂度；对于 $n > 2$，算法在分割和合并中仍然执行大约 $O(n \\log n)$ 的工作。此外，不正确的排序是一个正确性问题，而不是一个复杂度问题。在这种情况下，时间复杂度不可能是逻辑上未排序的原因。结论：不正确。\n\n选项 D：它诊断出当 $|A| = 2$ 时返回的元素对是未排序的，违反了 $\\operatorname{Merge}$ 的前提条件。提议的最小修正——在返回前对两个元素执行一次比较和交换——确保了所有返回的大小为 2 的数组都是已排序的。有了这个修复，归纳假设在 $n = 2$ 时成立，并且通过扩展，对于更大的 $n$ 也成立，因为所有对 $\\operatorname{Merge}$ 的输入都变成了已排序的，满足了其前提条件。这在修复基本情况的同时，保留了预期的递归结构。结论：正确。\n\n选项 E：它将问题归因于合并操作的不稳定性。稳定性影响相等键的相对顺序；它不影响输出是否在全局上按非递减顺序排序。在当前的基本情况下，具有不同元素的大小为 2 的数组是未排序的，当 $\\operatorname{Merge}$ 的输入未排序时，无论选择稳定还是不稳定的合并都无法修复对其前提条件的违反。结论：不正确。\n\n因此，正确的选项是 A 和 D。两者都指出了由基本情况引起的对已排序输入前提条件的违反，并提出了最小的、有效的修复方案：要么将基本情况减小到 $|A| \\le 1$，要么在 $|A| = 2$ 时显式地对元素对进行排序。", "answer": "$$\\boxed{AD}$$", "id": "3213544"}, {"introduction": "在掌握了通过代码理解归纳思想后，我们进一步挑战分析书面逻辑的能力。构建一个严谨的归纳证明，尤其是在归纳步骤中，需要无懈可击的推理。本练习 [@problem_id:3261411] 提供了一个针对简单排序算法的、看似可信但实际上错误的归纳证明，要求我们精确定位其逻辑上的致命缺陷。这训练了我们在算法分析中至关重要的批判性思维能力。", "problem": "考虑以下旨在在全序关系 $\\leq$ 下对数组进行排序的算法。给定一个数组 $A[1..n]$，其中 $n \\in \\mathbb{N}$，执行一次从左到右的遍历：对于从 $1$ 到 $n-1$ 的每个 $i$，如果 $A[i] > A[i+1]$，则交换 $A[i]$ 和 $A[i+1]$。在这一次遍历之后，算法停止。将此过程称为单次相邻交换程序。\n\n一位同事提出了以下归纳证明，以证明该程序能正确地对任何输入数组进行排序。\n\n断言：对于所有 $n \\in \\mathbb{N}$ 且 $n \\geq 1$，单次从左到右的相邻交换遍历可对任何数组 $A[1..n]$进行排序。\n\n关于 $n$ 的归纳证明提案：\n- 归纳基础：对于 $n = 1$，数组自然有序。对于 $n = 2$，单次比较和可能的交换会产生一个有序序列。\n- 归纳步骤：假设对于某个 $k \\geq 2$，任何长度为 $k$ 的数组在经过一次从左到右的相邻交换遍历后都会变得有序。考虑任何数组 $A[1..k+1]$。在遍历过程中，$A[1..k+1]$ 中的最大元素会移动到位置 $k+1$。此外，前 $k$ 个位置自身会经历与在长度为 $k$ 的数组上遍历时相同的 $(k-1)$ 次相邻比较。因此，根据归纳假设，在这次遍历之后，前 $k$ 个元素是有序的，并且由于最大元素位于位置 $k+1$，整个数组都是有序的。\n\n你的任务是找出该证明中确切的逻辑缺陷。仅根据以下基本原则，选择最准确地诊断出错误的选项：\n- 全序关系 $\\leq$ 下有序数组的定义：数组 $A$ 按非递减顺序排序，当且仅当对于所有 $1 \\leq i  n$ 的 $i$，$A[i] \\leq A[i+1]$。\n- 逆序对的定义：一对索引 $(i,j)$，满足 $1 \\leq i  j \\leq n$ 且 $A[i] > A[j]$。\n- 数学归纳法原理：要证明一个命题 $P(n)$ 对所有 $n \\geq n_0$ 成立，需证明 $P(n_0)$（归纳基础）成立，并且对于所有 $k \\geq n_0$，$P(k)$ 蕴含 $P(k+1)$（归纳步骤）。\n\n哪个陈述最准确地指出了该缺陷？\n\nA. 归纳步骤非法地将归纳假设应用于前 $k$ 个元素，仿佛它们是被独立处理的，而忽略了后续在位置 $k$ 和 $k+1$ 之间的比较可能会改变前 $k$ 个元素的内容并重新引入相邻逆序对；该假设被用于一个算法实际上并未解决的子问题上。\n\nB. 归纳无法开始，因为归纳基础忽略了 $n = 0$ 的情况，因此该证明未能对所有 $n \\geq 0$ 建立命题。\n\nC. 该证明混淆了“无相邻逆序对”属性和“有序性”，在全序关系下这两者并非等价。\n\nD. 该证明依赖于最小元素在一次遍历中移动到最前面，但算法只保证最大元素移动到最后面，因此其推理不适用。", "solution": "问题陈述在算法分析和证明技术领域提出了一个有效的任务。它为一个简单排序算法（冒泡排序的一轮）的正确性提供了一个有缺陷的归纳证明，并要求找出其中的逻辑错误。该问题是自洽的，科学上基于计算机科学原理，并且是客观的。不存在会妨碍严谨分析的矛盾、歧义或信息缺失。\n\n被“证明”的断言是：对于所有 $n \\in \\mathbb{N}$ 且 $n \\geq 1$，单次从左到右的相邻交换遍历可对任何数组 $A[1..n]$ 进行排序。这个断言是错误的。对于 $n=3$，一个简单的反例是数组 $A = [3, 2, 1]$。\n- 遍历从 $i = 1$ 开始。由于 $A[1] > A[2]$ (即 $3 > 2$)，我们交换它们。数组变为 $[2, 3, 1]$。\n- 接下来，$i = 2$。由于 $A[2] > A[3]$ (即 $3 > 1$)，我们交换它们。数组变为 $[2, 1, 3]$。\n- 遍历结束。最终数组是 $[2, 1, 3]$，它不是有序的，因为 $A[1] > A[2]$。\n\n任务是找出归纳证明中的缺陷，而不仅仅是证明该断言是错误的。让我们来分析所提供的证明结构。\n\n**关于 $n$ 的归纳证明提案：**\n- **归纳基础：**对于 $n = 1$，数组 $A[1..1]$ 没有可比较的元素对，自然是有序的。这是正确的。对于 $n = 2$，数组 $A[1..2]$ 会在 $A[1]$ 和 $A[2]$ 之间进行一次比较。如果 $A[1] > A[2]$，它们会被交换。无论哪种情况，最终数组都是有序的。这也是正确的。归纳基础成立。\n\n- **归纳步骤：** 该证明假设了归纳假设 (IH)，即 $P(k)$：对于某个 $k \\geq 2$，任何长度为 $k$ 的数组在单次遍历后都会变得有序。然后它试图证明 $P(k+1)$。对于数组 $A[1..k+1]$，证明 $P(k+1)$ 的论证基于两个断言：\n  1. “在遍历过程中，$A[1..k+1]$ 中的最大元素会移动到位置 $k+1$。” 这个断言是正确的。最大元素一旦被移动的比较窗口 $[i, i+1]$ 遇到，它将总是大于其右侧的元素，从而导致它被反复向右交换，直到到达该次遍历的最终位置。\n  2. “此外，前 $k$ 个位置自身会经历与在长度为 $k$ 的数组上遍历时相同的 $(k-1)$ 次相邻比较。因此，根据归纳假设，在这次遍历之后，前 $k$ 个元素是有序的……”\n\n第二个断言包含了关键的缺陷。归纳假设适用于*单次相邻交换程序*，作为作用于大小为 $k$ 的数组上的一个独立过程。在大小为 $k+1$ 的数组上运行的算法并**没有**孤立地对前 $k$ 个元素执行该程序。\n\n循环从 $i=1$ 运行到 $k$。前 $k-1$ 次迭代 ($i=1, \\dots, k-1$) 只涉及最初位于位置 $1, \\dots, k$ 的元素。然而，循环的最后一次迭代（$i=k$）比较的是 $A[k]$ 和 $A[k+1]$。如果在此处发生交换，原本在 $A[k+1]$ 的元素会被移到位置 $k$。这个位于位置 $k$ 的新元素可能比位置 $k-1$ 的元素小，从而在数组前缀 $A[1..k]$ 内产生一个新的相邻逆序对。\n\n让我们重新审视我们的反例 $A = [3, 2, 1]$，其中 $k+1 = 3$（因此 $k=2$）。\n- 归纳假设是 $P(2)$，这是成立的：对长度为2的数组进行一次遍历会将其排序。\n- 我们考虑长度为3的数组 $A = [3, 2, 1]$。\n- 遍历开始。对于 $i=1$，$[3, 2]$ 被交换，得到 $[2, 3, 1]$。在这个中间点，前缀 $A[1..2]$ 确实是有序的。\n- 证明的推理在下一步失败了。对于 $i=2$，我们比较 $A[2]=3$ 和 $A[3]=1$。我们交换它们。数组变为 $[2, 1, 3]$。\n- 该证明在完整遍历的*末尾*将归纳假设应用于子数组 $A[1..k]$。在我们的遍历结束时，数组是 $[2, 1, 3]$。前缀 $A[1..2]$ 是 $[2, 1]$，它不是有序的。涉及 $A[3]$ 的交换破坏了前缀的有序属性。\n- 根本错误在于将归纳假设应用于一个算法实际上并未独立解决的子问题上。子数组 $A[1..k]$ 的状态因其与元素 $A[k+1]$ 的交互而改变。\n\n现在，我们来评估每个选项。\n\n**A. 归纳步骤非法地将归纳假设应用于前 $k$ 个元素，仿佛它们是被独立处理的，而忽略了后续在位置 $k$ 和 $k+1$ 之间的比较可能会改变前 $k$ 个元素的内容并重新引入相邻逆序对；该假设被用于一个算法实际上并未解决的子问题上。**\n这个选项准确而精确地描述了上述分析中发现的缺陷。核心错误是错误地将归纳假设应用于一个并非自洽的子问题，因为它与子问题范围之外的元素（特别是 $A[k]$ 和 $A[k+1]$ 之间的交换）发生了交互。正如我们的反例所示，这次交换确实可以在前缀 $A[1..k]$ 中引入一个新的逆序对。这个陈述是**正确的**。\n\n**B. 归纳无法开始，因为归纳基础忽略了 $n = 0$ 的情况，因此该证明未能对所有 $n \\geq 0$ 建立命题。**\n该断言明确针对“$n \\in \\mathbb{N}$ 且 $n \\geq 1$”。一个针对所有 $n \\geq n_0$ 的命题 $P(n)$ 的归纳证明只需要建立基础情况 $P(n_0)$。在这里，$n_0=1$。该证明正确地建立了 $n=1$ 的基础情况（甚至 $n=2$）。没有要求证明 $n=0$ 的情况。这个陈述是**不正确的**。\n\n**C. 该证明混淆了“无相邻逆序对”属性和“有序性”，在全序关系下这两者并非等价。**\n在全序关系的背景下，这个陈述在事实上是错误的。问题本身将有序数组定义为：对于所有 $1 \\leq i  n$ 的 $i$，$A[i] \\leq A[i+1]$。这恰恰是“无相邻逆序对”的定义。如果没有相邻逆序对（对所有 $i$ 都有 $A[i] \\leq A[i+1]$），那么根据全序关系 $\\leq$ 的传递性，对于任何 $i  j$，我们有 $A[i] \\leq A[i+1] \\leq \\dots \\leq A[j]$，这意味着 $A[i] \\leq A[j]$。这意味着整个数组是有序的（即没有任何类型的逆序对）。因此，“无相邻逆序对”属性等价于“有序性”。这个陈述是**不正确的**。\n\n**D. 该证明依赖于最小元素在一次遍历中移动到最前面，但算法只保证最大元素移动到最后面，因此其推理不适用。**\n证明的文本明确指出，“……$A[1..k+1]$ 中的最大元素会移动到位置 $k+1$。” 它没有对最小元素做任何声明。该算法（冒泡排序的一轮）确实会将最大元素移动到末尾，但通常不会将最小元素移动到开头。这个选项曲解了证明中提出的论点。该证明依赖于算法的一个正确属性（最大值到末尾），但由此得出了一个有缺陷的结论。这个陈述是**不正确的**。\n\n因此，选项A是唯一正确指出归纳步骤中逻辑谬误的选项。", "answer": "$$\\boxed{A}$$", "id": "3261411"}, {"introduction": "现在，我们将运用这些分析技巧来审视一个图论中的基石算法——Dijkstra 算法。其正确性证明依赖于一个关键的归纳不变量：每当一个顶点被确定为“已处理”时，其计算出的距离就是最短距离。本练习 [@problem_id:3237619] 探究了当算法的一个基本前提（所有边权重为非负）被打破时会发生什么，它清晰地揭示了归纳证明是如何失效的，并最终导致算法得出错误的结果。通过这个练习，我们能更深刻地理解一个算法保证其正确性的边界条件。", "problem": "考虑一个带权重函数 $w:E\\to\\mathbb{R}$ 的有向图 $G=(V,E)$ 和一个指定的源顶点 $s\\in V$。单源最短路径 (SSSP) 问题是为每个顶点 $v\\in V$ 计算最短路径距离 $\\delta(s,v)$，该距离定义为所有从 $s$ 到 $v$ 的有向路径 $P$ 的边权重之和的最小值。Dijkstra 算法维护一个已确定的顶点集合 $S\\subseteq V$ 和一个暂定距离数组 $d:V\\to\\mathbb{R}\\cup\\{\\infty\\}$，其中初始时 $d[s]=0$，对于 $v\\neq s$ 则 $d[v]=\\infty$。在每次迭代中，它从优先队列 (PQ) 中提取一个 $d[y]$ 值最小的顶点 $y\\notin S$，将 $y$ 插入 $S$，并通过设置 $d[z]\\leftarrow \\min\\{d[z], d[y]+w(y,z)\\}$ 来松弛所有出边 $(y,z)\\in E$。Dijkstra 算法的经典贪心正确性证明依赖于一个不变式：当一个顶点 $y$ 被提取时（即“提取最小值并最终确定”步骤），则 $d[y]=\\delta(s,y)$，前提是所有边权重都是非负的，即对所有 $e\\in E$ 都有 $w(e)\\ge 0$。\n\n分析当图 $G$ 中恰好有一条负权重边时，其正确性论证。具体来说，假设存在唯一一条边 $(x,y)\\in E$ 满足 $w(x,y)0$，而所有其他边的权重均为非负。请指出贪心证明在哪一个精确的算法步骤和在哪一个精确的条件下（根据 $S$ 和 $V\\setminus S$ 之间的切割以及唯一负边的位置）会失效，即在提取顶点时，归纳论断 $d[y]=\\delta(s,y)$ 不再得到保证。\n\n选择最准确的陈述。\n\nA. 贪心证明在“提取最小值并最终确定”步骤失效：如果存在一个未确定的顶点 $x\\notin S$ 和一个已确定的顶点 $y\\in S$，使得唯一的负边 $(x,y)$ 以 $w(x,y)0$ 穿过切割进入 $S$，那么最终确定 $y$ 就可能不正确，因为一条路径 $s\\leadsto x\\to y$ 稍后可能会得到一个比 $d[y]$ 更小的值，从而在提取时违反了 $d[y]=\\delta(s,y)$。\n\nB. 贪心证明在松弛出边阶段失效：如果一个已确定的顶点 $y\\in S$ 有一条通向未确定顶点 $x\\notin S$ 的负出边 $(y,x)$ 且 $w(y,x)0$，那么松弛 $(y,x)$ 会使得 $d[y]=\\delta(s,y)$ 不成立，从而导致证明在松弛时失败。\n\nC. 贪心证明仅当从 $s$ 可达一个负环时才会失效；如果只有一个负边且没有环，Dijkstra 算法仍然正确，因此在这种情况下没有步骤会失败。\n\nD. 只要唯一的负边权重的绝对值很小，即对某个固定的 $\\epsilon>0$ 有 $\\min_{e\\in E} w(e)\\ge -\\epsilon$，贪心证明就永远不会失效，因为优先队列的顺序仍然近似有效，最终确定步骤也仍然安全。", "solution": "问题要求我们确定，当图中恰好有一条负权重边时，Dijkstra 算法的标准贪心正确性证明在何种精确条件下会失效。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n-   一个带权重函数 $w:E\\to\\mathbb{R}$ 的有向图 $G=(V,E)$。\n-   一个源顶点 $s\\in V$。\n-   单源最短路径 (SSSP) 问题是为所有 $v \\in V$ 找到 $\\delta(s,v)$。\n-   描述了 Dijkstra 算法，它维护一个已确定顶点的集合 $S$ 和暂定距离 $d[\\cdot]$。核心步骤是提取一个 $d[y]$ 值最小的顶点 $y \\notin S$，将其加入 $S$，并松弛其出边。\n-   对于非负边权重的标准正确性证明依赖于不变式：当一个顶点 $y$ 从优先队列中被提取时，其暂定距离就是其真实的最短路径距离，即 $d[y] = \\delta(s,y)$。\n-   分析的具体场景是一个图中恰好有一条边 $(x,y) \\in E$ 满足 $w(x,y)  0$。所有其他边 $e \\in E \\setminus \\{(x,y)\\}$ 都满足 $w(e) \\ge 0$。\n-   问题是要确定证明中的不变式 $d[y]=\\delta(s,y)$ 在哪个精确的算法步骤和条件下不再得到保证。\n\n**第 2 步：使用提取的信息进行验证**\n问题陈述是科学合理的、定义明确的且客观的。它针对一个基本算法，在其先决条件经过特定修改后，提出了一个关于其正确性证明的标准而又深刻的问题。该主题是算法研究的核心。未发现任何缺陷。\n\n**第 3 步：结论与行动**\n问题有效。我将继续进行解题推导。\n\n### 基于原理的推导\n\nDijkstra 算法在非负权重图上的正确性依赖于贪心选择属性。其证明通常是归纳性的。\n\n**归纳假设：** 对于已确定的顶点集合 $S$，对每个 $u \\in S$，计算出的距离 $d[u]$ 都是真实的最短路径距离，即 $d[u] = \\delta(s,u)$。\n\n**归纳步骤：** 设 $y$ 是 $V \\setminus S$ 中具有最小暂定距离的顶点，即 $d[y] = \\min_{v \\in V\\setminus S} d[v]$。Dijkstra 算法提取 $y$ 并将其加入 $S$。我们必须证明 $d[y] = \\delta(s,y)$。\n\n我们用反证法，假设 $d[y] > \\delta(s,y)$。这意味着存在一条比 $d[y]$ 中记录的长度更短的路径到达 $y$。设 $P^*$ 是从 $s$ 到 $y$ 的一条真实最短路径。由于 $s \\in S$ 且 $y \\notin S$，路径 $P^*$ 必须从 $S$ 穿越到 $V \\setminus S$。设 $(u,v)$ 是 $P^*$ 上第一条满足 $u \\in S$ 且 $v \\in V \\setminus S$ 的边。\n\n路径 $P^*$ 可以分解为 $s \\leadsto u \\to v \\leadsto y$。\n1.  子路径 $s \\leadsto u$ 是到 $u$ 的最短路径。根据归纳假设，由于 $u \\in S$，我们有 $d[u] = \\delta(s,u)$。\n2.  当顶点 $u$ 被加入 $S$ 时，其出边被松弛。因此，对于边 $(u,v)$，松弛步骤保证了 $d[v] \\le d[u] + w(u,v)$。代入 $d[u]=\\delta(s,u)$，我们得到 $d[v] \\le \\delta(s,u) + w(u,v)$。\n3.  $\\delta(s,u) + w(u,v)$ 这一项是 $P^*$ 从 $s$ 到 $v$ 的子路径长度。因此，$d[v]$ 小于或等于该子路径的长度。\n4.  $P^*$ 的总长度是 $\\delta(s,y) = \\text{length}(s \\leadsto u \\to v) + \\text{length}(v \\leadsto y)$。\n5.  **关键步骤：** 在标准证明中，所有边权重都是非负的。这意味着任何路径的长度都是非负的，所以 $\\text{length}(v \\leadsto y) \\ge 0$。\n6.  因此，$\\delta(s,y) \\ge \\text{length}(s \\leadsto v) \\ge d[v]$。\n7.  根据我们选择 $y$ 作为 $V\\setminus S$ 中暂定距离最小的顶点的规则，并且由于 $v$ 也在 $V\\setminus S$ 中，我们必然有 $d[y] \\le d[v]$。\n8.  结合这些不等式：$d[y] \\le d[v] \\le \\delta(s,y)$。\n这与我们最初的假设 $d[y] > \\delta(s,y)$ 相矛盾。因此，必然有 $d[y] = \\delta(s,y)$。\n\n**存在负边时证明的失效**\n\n如果路径段 $v \\leadsto y$ 的长度可以为负，则证明在第 6 步会产生严重错误。当图中只有一条负权重边时，如果该边位于 $v \\leadsto y$ 子路径上，这种情况就可能发生。如果 $\\text{length}(v \\leadsto y)  0$，我们就不能再断定 $\\delta(s,y) \\ge d[v]$。这就使得 $\\delta(s,y)  d[y]$ 成为可能。\n\n失败发生在“提取最小值并最终确定”步骤。当算法提取一个顶点 $y$ 时，它是在贪心假设下进行的，即稍后不会发现到 $y$ 的更短路径。这个假设的前提是，任何到 $y$ 的替代路径都必须经过某个其他未确定的顶点 $v \\in V \\setminus S$。由于对于所有这样的 $v$，都有 $d[y] \\le d[v]$，并且从 $v$ 开始的路径长度不会减少（因为权重非负），所以替代路径不可能更短。\n\n存在负边时，这个逻辑就失效了。一条通过未确定顶点 $v$（其 $d[v] > d[y]$）的路径，如果从 $v$ 开始的路径段包含负边，并且其权重足够小以抵消较大的初始距离 $d[v]$，那么这条路径整体上可能仍然更短。\n\n让我们用一个具体的例子来说明在提取时不变式 $d[y]=\\delta(s,y)$ 是如何被违反的。\n考虑 $V=\\{s, x, y\\}$, $E=\\{(s,y), (s,x), (x,y)\\}$，权重为 $w(s,y)=5$, $w(s,x)=10$, and $w(x,y)=-6$。唯一的负权重边是 $(x,y)$。\n\n1.  初始化：$S=\\emptyset$，$d[s]=0$，$d[x]=\\infty$，$d[y]=\\infty$。优先队列 (PQ)：$\\{s:0\\}$。\n2.  提取 $s$。将 $s$ 加入 $S$。$S=\\{s\\}$。松弛出边：\n    -   $d[y] \\leftarrow \\min\\{\\infty, d[s]+w(s,y)\\} = 5$。\n    -   $d[x] \\leftarrow \\min\\{\\infty, d[s]+w(s,x)\\} = 10$。\n    -   PQ：$\\{y:5, x:10\\}$。\n3.  **提取最小值并最终确定步骤：** $V\\setminus S = \\{x,y\\}$ 中 $d$ 值最小的顶点是 $y$，其 $d[y]=5$。算法提取 $y$ 并将其加入 $S$。此时，算法已确定 $d[y]=5$ 为最短路径距离。\n    -   然而，真实的最短路径是 $s \\to x \\to y$，总权重为 $w(s,x)+w(x,y) = 10 + (-6) = 4$。\n    -   不变式 $d[y]=\\delta(s,y)$ 在此步骤被违反。为什么？因为更短的路径经过了顶点 $x$，而当时 $x$ 仍在优先队列中，且暂定距离更高 ($d[x]=10 > d[y]=5$)。\n    -   导致这种失败的拓扑结构如下：在最终确定 $y$ 的那一刻，已确定的顶点集合是 $S=\\{s\\}$。负边是 $(x,y)$，其源点 $x$ 是未确定的 ($x \\in V \\setminus S$)，其目标点 $y$ 是正在被最终确定的顶点（因此将从 $V \\setminus S$ 移到 $S$）。此步骤后，$S=\\{s, y\\}$，负边 $(x,y)$ 变成了一条从 $V \\setminus S$ 穿越到 $S$ 的边。正是这种潜在路径的存在破坏了证明。\n\n### 逐项分析\n\n**A. 贪心证明在“提取最小值并最终确定”步骤失效：如果存在一个未确定的顶点 $x\\notin S$ 和一个已确定的顶点 $y\\in S$，使得唯一的负边 $(x,y)$ 以 $w(x,y)0$ 穿过切割进入 $S$，那么最终确定 $y$ 就可能不正确，因为一条路径 $s\\leadsto x\\to y$ 稍后可能会得到一个比 $d[y]$ 更小的值，从而在提取时违反了 $d[y]=\\delta(s,y)$。**\n该陈述正确地指出了失败的步骤：“提取最小值并最终确定”。它也正确地指出了失败的原因：一条通过未确定顶点 $x$ 并使用负边 $(x,y)$ 的路径可能会产生一条到 $y$ 的更短路径。对几何条件的描述——一条从一个未确定顶点 $x \\notin S$ 到一个已确定顶点 $y \\in S$ 的负边 $(x,y)$——刻画了使 $d[y]$ 的最终性失效的配置。尽管措辞在时间上略显笨拙（它描述了在 $y$ 被确定*之后* $S$ 的状态，以解释为什么确定 $y$ 是一个错误），但其底层的物理和逻辑论证是合理的，并指出了确切的失败机制。\n\n**结论：正确**\n\n**B. 贪心证明在松弛出边阶段失效：如果一个已确定的顶点 $y\\in S$ 有一条通向未确定顶点 $x\\notin S$ 的负出边 $(y,x)$ 且 $w(y,x)0$，那么松弛 $(y,x)$ 会使得 $d[y]=\\delta(s,y)$ 不成立，从而导致证明在松弛时失败。**\n这是不正确的。对边 $(y,x)$ 的松弛步骤是 $d[x] \\leftarrow \\min\\{d[x], d[y]+w(y,x)\\}$。这个操作更新的是 $d[x]$，而不是 $d[y]$。对于一个已确定的顶点 $y \\in S$，其 $d[y]$ 的值被认为是最终的，不会被改变。松弛步骤本身在机制上是合理的；失败源于贪心地选择要确定的顶点，而不是源于更新邻居的机制。\n\n**结论：不正确**\n\n**C. 贪心证明仅当从 $s$ 可达一个负环时才会失效；如果只有一个负边且没有环，Dijkstra 算法仍然正确，因此在这种情况下没有步骤会失败。**\n这是错误的。上面提供的反例（$s \\to y$ 权重为 5，$s \\to x$ 权重为 10，$x \\to y$ 权重为 -6）是一个有向无环图 (DAG)，所以它根本没有环。然而，Dijkstra 算法未能找到正确的最短路径。任何负权重边的存在都足以潜在地破坏 Dijkstra 算法，而不仅仅是负权重环（负权重环会使得对于从环可达的顶点，SSSP 问题本身是无定义的）。\n\n**结论：不正确**\n\n**D. 只要唯一的负边权重的绝对值很小，即对某个固定的 $\\epsilon>0$ 有 $\\min_{e\\in E} w(e)\\ge -\\epsilon$，贪心证明就永远不会失效，因为优先队列的顺序仍然近似有效，最终确定步骤也仍然安全。**\n这是错误的。证明的正确性是一个离散逻辑问题，而不是连续近似问题。负权重的绝对值大小无关紧要，只有其符号有影响。一个任意小的负权重都可能导致算法失败。例如，在我们的反例中，我们可以使用 $w(s,y)=5$，$w(s,x)=5.001$，以及 $w(x,y)=-0.002$。Dijkstra 会以距离 5 最终确定 $y$，而通过 $x$ 的真实最短路径长度为 $5.001 - 0.002 = 4.999$。无论负权重的绝对值有多小，只要它小于 0，算法就会失败。\n\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3237619"}]}