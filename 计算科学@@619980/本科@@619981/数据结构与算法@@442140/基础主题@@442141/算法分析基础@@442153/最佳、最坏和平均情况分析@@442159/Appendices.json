{"hands_on_practices": [{"introduction": "伸展树以其出色的*摊销*效率而闻名，但这一保证并不能避免单次操作的高昂成本。本练习将让你扮演“对手”的角色，构建一个特定的插入序列，迫使伸展树退化为其效率最低的形态——一条线性链表，并计算后续访问操作的巨大代价。这个实践有力地揭示了摊销性能和单次操作最坏情况性能之间的关键区别。[@problem_id:3214330]", "problem": "给定一棵初始为空的伸展树，它支持插入和搜索操作。操作方式为：首先执行标准的二叉搜索树（BST）插入，然后使用经典的自底向上伸展操作，将访问的或新插入的节点伸展（splay）到根节点。这些操作包括：单次旋转（zig）、同向双次旋转（zig-zig）和异向双次旋转（zig-zag）。一次旋转是标准的局部BST旋转，它能保持BST的有序性。假设采用精确单位成本模型，其中单次访问（一次搜索操作）的成本等于下降过程中的关键字比较总次数，加上将被访问节点伸展至根节点过程中的旋转总次数。所有关键字都是唯一的。\n\n您的任务是：\n- 设计一个包含 $n$ 个不同关键字的明确插入序列，在第 $n$ 次插入及其最后的伸展操作完成后，能得到一个其底层BST形状为一条简单路径（一个退化树，结构上与链表相同）的伸展树。\n- 证明您的构造确实会产生这样的退化形状。\n- 使用上述成本模型，计算在第 $n$ 次插入完成后立即对最小关键字进行一次访问的精确成本。将您的最终答案表示为 $n$ 的一个封闭形式函数。\n\n你的最终答案必须是关于 $n$ 的单个封闭形式表达式。无需四舍五入。最终答案中不要包含单位。", "solution": "用户要求一个关于伸展树的三部分解决方案：1) 一个能产生退化树的 $n$ 个关键字的插入序列，2) 对该序列的合理性证明，以及 3) 在生成的树中访问最小关键字的成本。该成本由一个特定模型定义。\n\n首先，我们设计插入序列。我们提议将关键字 $1, 2, 3, \\ldots, n$ 按严格递增的顺序插入到一个初始为空的伸展树中。现在我们将证明这个序列会产生一个简单路径的树结构。我们使用数学归纳法来证明。\n\n令 $P(k)$ 为命题：在依次插入关键字 $1, 2, \\ldots, k$ 后，得到的伸展树是一条“左倾链”，其中节点 $k$ 是根，节点 $k-1$ 是节点 $k$ 的左孩子，通常地，对于所有 $i \\in \\{2, \\ldots, k\\}$，节点 $i-1$ 是节点 $i$ 的左孩子。这种结构是一条简单路径。\n\n**基础情形：** 对于 $k=1$，我们将关键字 $1$ 插入一个空树中。得到的树是一个包含关键字 $1$ 的单节点。这是一条长度为 $1$ 的简单路径，因此 $P(1)$ 成立。\n\n**归纳假设：** 假设对于某个整数 $k \\geq 1$，命题 $P(k)$ 为真。也就是说，在按顺序插入关键字 $1, 2, \\ldots, k$ 后，伸展树是一条以 $k$ 为根的左倾链。\n\n**归纳步骤：** 现在我们插入关键字 $k+1$。\n$1$. **BST插入：** 插入过程从当前树的根节点（即节点 $k$）开始。由于待插入的关键字 $k+1$ 大于根节点的关键字 $k$，算法尝试移向右孩子。根据归纳假设，根节点 $k$ 没有右孩子。因此，创建一个包含关键字 $k+1$ 的新节点，并使其成为节点 $k$ 的右孩子。\n$2$. **伸展：** 插入后，新添加的节点 $k+1$ 被伸展到根。此时，节点 $k+1$ 是根节点 $k$ 的右孩子。由于其父节点是树的根，它没有祖父节点。这种配置会触发一次 **zig** 操作。\n$3$. **旋转：** 对右孩子的一次 `zig` 操作包括围绕其父节点的一次左旋。我们在节点 $k$ 处执行一次左旋。这个操作使得 $k+1$ 成为树的新根。原来的根 $k$ 成为新根 $k+1$ 的左孩子。节点 $k$ 原来的左子树，根据归纳假设是左倾链 $1 \\leftarrow 2 \\leftarrow \\dots \\leftarrow (k-1)$，仍然作为节点 $k$ 的左子树。\n$4$. **结果结构：** 最终的树以 $k+1$ 为根。它的左孩子是 $k$，其左孩子是 $k-1$，依此类推，直到叶节点 $1$。这个结构是一条左倾链，$1 \\leftarrow 2 \\leftarrow \\dots \\leftarrow (k+1)$。因此，命题 $P(k+1)$ 成立。\n\n根据数学归纳法原理，按递增顺序插入关键字 $1, 2, \\ldots, n$ 会得到一个以 $n$ 为根的简单路径（左倾链）的伸展树。\n\n接下来，我们计算在这棵树上对最小关键字（即 $1$）进行一次访问的成本。成本是搜索过程中的关键字比较次数与随后的伸展过程中的旋转次数之和。\n\n**1. 关键字比较次数：**\n该树是一条以 $n$ 为根的左倾链。为了定位关键字 $1$，搜索算法从根节点 $n$ 开始，沿着左孩子指针链一直到达节点 $1$。搜索路径为 $n \\rightarrow (n-1) \\rightarrow (n-2) \\rightarrow \\dots \\rightarrow 2 \\rightarrow 1$。在其中的每一个节点（共 $n$ 个）都会进行一次关键字比较。\n因此，关键字比较的次数是 $n$。\n\n**2. 旋转次数：**\n找到节点 $1$ 后，它被伸展到根。最初，节点 $1$ 的深度为 $n-1$。从节点 $1$ 到根的路径完全由“是……的左孩子”关系构成。伸展过程包含一系列将节点 $1$ 移向根的步骤。\n令 $x$ 为被伸展的节点（$x=1$），$p$ 为其父节点，$g$ 为其祖父节点。\n-   只要 $x$ 有祖父节点，其结构总是 $x$ 是 $p$ 的左孩子，而 $p$ 是 $g$ 的左孩子。这是 **zig-zig** 情况，需要两次旋转。每个 `zig-zig` 步骤将 $x$ 向根节点移动两层。这个过程重复 $\\lfloor \\frac{n-1}{2} \\rfloor$ 次。\n-   在一系列的 `zig-zig` 步骤之后，节点 $1$ 或者在根位置（如果 $n-1$ 是偶数），或者成为根节点的直接孩子（如果 $n-1$ 是奇数）。如果它是根的孩子，它的父节点就是根，所以需要执行最后一次 **zig** 步骤，这涉及一次旋转。\n\n总旋转次数是所有 `zig-zig` 步骤和可能的 `zig` 步骤的旋转次数之和：\n$$ \\text{旋转次数} = 2 \\times \\left\\lfloor \\frac{n-1}{2} \\right\\rfloor + ((n-1) \\pmod 2) $$\n这个表达式是一个标准恒等式，对于任何整数 $n \\geq 1$，它都简化为 $n-1$。\n-   如果 $n-1$ 是偶数，令 $n-1 = 2k$（对于某个整数 $k$）。旋转次数为 $2 \\times k + 0 = 2k = n-1$。\n-   如果 $n-1$ 是奇数，令 $n-1 = 2k+1$（对于某个整数 $k$）。旋转次数为 $2 \\times k + 1 = 2k+1 = n-1$。\n因此，伸展过程中执行的总旋转次数恰好是 $n-1$。\n\n**3. 总成本：**\n访问的总成本是关键字比较次数和旋转次数之和。\n$$ \\text{成本} = (\\text{比较次数}) + (\\text{旋转次数}) $$\n$$ \\text{成本} = n + (n-1) $$\n$$ \\text{成本} = 2n - 1 $$\n这就是所要求的成本关于 $n$ 的封闭形式表达式。", "answer": "$$\\boxed{2n-1}$$", "id": "3214330"}, {"introduction": "“压缩”一词直观地意味着体积变小，但这是否总是成立？本练习将推动你跳出时间复杂度的范畴，从输出大小的角度分析算法的最坏情况行为。你需要设计一个特殊的文件，它利用 LZW 算法的内部机制，使得“压缩”后的文件反而比原始文件更大，这将为你提供一个关于理解算法在实际应用中操作边界的重要性的深刻教训。[@problem_id:3214412]", "problem": "考虑如下为面向字节的文件定义的 Lempel–Ziv–Welch (LZW) 压缩算法。输入字母表是所有字节值的集合，因此字母表大小为 $256$。编码器初始化其字典，使其恰好包含 $256$ 个单字节字符串，每个字符串都映射到一个唯一的编码。在整个运行过程中，编码器对每个输出编码都使用 $12$ 位的定长编码。没有特殊的控制码（没有清除码，也没有信息结束码）。在每一步，编码器输出与当前输入前缀匹配的最长字典短语的编码，然后将该短语与下一个输入符号（如果还有的话）拼接成的新字符串添加到字典中，并将输入光标移过匹配的短语。\n\n结合数据结构与算法中最坏情况分析的核心定义（即，在给定大小的所有输入中资源使用的最大值）以及上述 LZW 规范，设计一个长度为 $N = 50{,}000$ 字节的文件，该文件在经过 LZW 压缩后会变大。你的设计必须确保在编码过程中，每一步的最长匹配长度都为 $1$。你可以假设存在字节字母表上的序列，其中所有相邻对都是唯一的；例如，任何枚举不同相邻对且无重复的序列的长度为 $N$ 的前缀都是可接受的。证明你的设计为何确实能迫使编码器为每个输入字节恰好输出一个编码。然后，计算压缩相对于原始文件大小所产生的确切额外位数。以比特为单位表示最终的大小差异。不需要四舍五入，你必须以单个实数值的形式提供最终答案。", "solution": "本分析的基本基础是算法分析中最坏情况行为的定义：对于给定的输入大小，最坏情况是指在所有有效输入中产生的最大成本（这里指最大压缩后的大小）。我们还依赖于 Lempel–Ziv–Welch (LZW) 压缩的标准操作，即使用 $12$ 位的定长编码、一个包含所有 $256$ 个单字节字符串的初始字典以及贪心最长匹配规则。我们的目标是展示一个输入，其结构迫使编码器以一种为每个输入字节产生最大输出长度的方式运行。\n\n设输入为在 $256$ 符号字母表上长度为 $N = 50{,}000$ 字节的序列 $S$。我们设计 $S$，使得对于 $i \\in \\{1, 2, \\dots, N-1\\}$，每个相邻字节对 $(S[i], S[i+1])$ 都是唯一的；也就是说，在 $S$ 的任何地方，没有连续符号的有序对会重复。这样的序列是存在的，因为在 $256$ 符号字母表上不同有序对的数量是 $256^{2} = 65{,}536$，这超过了 $N-1 = 49{,}999$，所以我们可以选择一个无重复地枚举不同对的序列的任意长度为 $N$ 的前缀。一种构造性的观点是考虑一个有向多重图，其顶点是 $256$ 个符号，边表示有序对；欧拉遍历可以不重复地访问所有边，从而产生一个循环序列，其中每个对恰好出现一次。取该循环的任意长度为 $N$ 的段即可实现所需属性，即该段内所有相邻对都是唯一的。\n\n我们现在证明，在此设计下，LZW 编码器为每个输入字节恰好输出一个编码。编码器开始时有一个包含所有单字节字符串的字典。在编码开始时，考虑指向 $S$ 中当前位置 $i$ 的指针。因为字典最初只包含单字节短语，所以在位置 $i$ 处匹配输入前缀的最长字典短语是单个符号 $S[i]$。编码器输出 $S[i]$ 的编码，然后（根据 LZW 的更新规则）将匹配的短语 $S[i]$ 与下一个符号 $S[i+1]$ 拼接形成的短语，即双字节字符串 $S[i]S[i+1]$，插入到字典中（前提是 $i+1 \\le N$）。然后编码器前进到下一个位置 $i' = i+1$。\n\n在位置 $i'$，字典现在包含了新添加的双字节短语 $S[i]S[i+1]$。然而，编码器尝试从 $S[i'] = S[i+1]$ 开始匹配最长短语。唯一可能从 $i'$ 开始匹配的双字节短语是 $S[i+1]S[i+2]$。根据 $S$ 的设计，所有相邻对都是唯一的。因此，除非紧邻的前一个对 $S[i]S[i+1]$ 恰好等于 $S[i+1]S[i+2]$（当所有对都唯一时这是不可能的），否则双字节短语 $S[i+1]S[i+2]$ 尚未在字典中。因此，在位置 $i'$ 的最长匹配长度再次为 $1$，即单字节 $S[i+1]$。编码器输出 $S[i+1]$ 的编码，并向字典中插入新的双字节短语 $S[i+1]S[i+2]$。这个论证对每个后续位置都成立，因为设计保证了在 $S$ 中任何地方都没有两个相等的相邻对。通过对 $i$ 从 $1$ 到 $N$ 进行归纳，可以得出每一步的最长匹配长度都为 $1$，并且编码器为每个输入字节恰好输出一个编码。因此，输出编码的总数恰好为 $N$。\n\n鉴于使用 $12$ 位的定长编码，压缩后的大小 $C$（以比特为单位）为\n$$\nC = 12 \\cdot N.\n$$\n原始文件由 $N$ 字节组成，因此其大小 $O$（以比特为单位）为\n$$\nO = 8 \\cdot N.\n$$\n压缩相对于原始文件产生的额外位数为\n$$\n\\Delta = C - O = 12 \\cdot N - 8 \\cdot N = 4 \\cdot N.\n$$\n代入 $N = 50{,}000$ 可得\n$$\n\\Delta = 4 \\cdot 50{,}000 = 200{,}000.\n$$\n因此，设计的输入触发了此定长 LZW 变体的最坏情况行为，比原始文件多产生了 $200{,}000$ 比特。最终答案，以比特表示，是 $200{,}000$。", "answer": "$$\\boxed{200000}$$", "id": "3214412"}, {"introduction": "现在，我们将从构建最坏情况转向对一个经典算法进行全面的数学分析。快速选择（Quickselect）算法的效率高度依赖于主元（pivot）的选择，这使其成为探索完整性能分析谱（最佳、最坏、平均）的理想案例。本练习要求你从第一性原理出发，推导其最佳、最坏以及至关重要的平均情况复杂度，它将展示一个算法即使在最坏情况下性能不佳（$O(n^2)$），但由于其出色的平均性能（$O(n)$），在实践中仍然极为高效。[@problem_id:3214466]", "problem": "给定一个包含 $n$ 个不同关键字的数组。考虑使用快速选择（Quickselect）算法来查找第 $k$ 小的关键字，其中，每次分区操作会将选定的主元与当前子数组中的每个其他元素精确比较一次，并且每个子问题的主元是从该子问题的元素中均匀随机选择的。假设在随机存取机（RAM）模型下，成本度量是关键字比较的次数。\n\n从快速选择算法和期望算子的核心定义出发，执行以下操作：\n\n- 形式化地定义在大小为 $m$ 的子数组上执行一次分区步骤所做的比较次数。\n- 从第一性原理出发，推导快速选择算法在大小为 $n$ 的数组中查找第 $k$ 小元素所需的最佳情况和最差情况下的比较次数，表示为 $n$ 的函数（您可以假设 $1 \\leq k \\leq n$ 是固定的）。\n- 令 $A(n)$ 表示当 $k$ 本身从 $\\{1,2,\\dots,n\\}$ 中均匀随机选择，并且每次递归时主元也均匀随机选择时，快速选择算法所做的期望比较次数。仅使用基本定义和期望的线性性质，推导出 $A(n)$ 的递推关系，并确定当 $n \\to \\infty$ 时，线性渐近式 $A(n) \\sim c n$ 中的首项系数 $c$。\n\n将 $c$ 的值作为您的最终答案报告。无需四舍五入，最终答案中不应包含任何单位。", "solution": "快速选择算法的工作原理是：选择一个主元，围绕该主元对当前子数组进行分区，然后在可能包含第 $k$ 小元素的那一半子数组中递归地继续。我们只计算关键字比较的次数。我们使用的基本事实是：对于一个大小为 $m$ 的子数组，分区操作会将主元与其余的 $m-1$ 个元素各比较一次；以及在平均情况分析中使用期望的线性性质。\n\n在大小为 $m$ 的子数组上执行一次分区步骤，会进行恰好 $m-1$ 次比较。这是由分区例程的定义得出的，该例程会扫描子数组，将每个非主元元素与主元比较一次。\n\n最佳情况分析：对于大小为 $n$ 的输入，最佳情况发生在第一次调用时选择的主元其秩恰好为 $k$。在这种情况下，算法对整个数组执行一次分区，成本为 $n-1$ 次比较，然后停止。因此，最佳情况下的比较次数是 $n-1$。\n\n最差情况分析：最差情况发生在每一步选择的主元相对于目标秩都是最差的，导致递归子问题的规模每次都恰好减少 1（例如，总是从大小为 $m$ 的问题递归到大小为 $m-1$ 的子问题）。总比较次数是所有层次分区成本的总和：\n$$\n\\sum_{m=2}^{n} (m-1) \\;=\\; \\sum_{j=1}^{n-1} j \\;=\\; \\frac{n(n-1)}{2}.\n$$\n因此，最差情况下的比较次数是 $\\frac{n(n-1)}{2}$。\n\n平均情况设置：令 $A(n)$ 为当 $k$ 在 $\\{1,2,\\dots,n\\}$ 中均匀随机，并且每次递归时主元也均匀随机选择时，查找第 $k$ 小元素的期望比较次数。我们通过对主元的秩进行条件化，并使用全期望定律来推导 $A(n)$ 的递推关系。\n\n顶层分区的成本是 $n-1$ 次比较。设主元的秩为 $r$（$r$ 在 $\\{1, \\dots, n\\}$ 中均匀随机），目标元素的秩为 $k$（$k$ 也在 $\\{1, \\dots, n\\}$ 中均匀随机）。\n- 如果 $r=k$，算法停止，不再有递归成本。\n- 如果 $r > k$，算法在大小为 $r-1$ 的左侧子数组上递归。\n- 如果 $r  k$，算法在大小为 $n-r$ 的右侧子数组上递归。\n\n期望成本 $A(n)$ 是顶层成本加上期望的递归成本。期望是针对 $r$ 和 $k$ 的所有可能值计算的。\n$$ A(n) = (n-1) + \\frac{1}{n^2} \\sum_{r=1}^n \\sum_{k=1, k \\ne r}^n (\\text{递归成本}) $$\n对于一个给定的主元秩 $r$，当 $k  r$ 时，我们递归到大小为 $r-1$ 的子问题上，这有 $r-1$ 个可能的 $k$ 值。当 $k > r$ 时，我们递归到大小为 $n-r$ 的子问题上，这有 $n-r$ 个可能的 $k$ 值。在这些子问题中，由于 $k$ 和主元的选择再次是随机的，其期望成本分别为 $A(r-1)$ 和 $A(n-r)$。\n$$ A(n) = n-1 + \\frac{1}{n^2} \\sum_{r=1}^n \\left( \\sum_{k=1}^{r-1} A(r-1) + \\sum_{k=r+1}^{n} A(n-r) \\right) $$\n$$ A(n) = n-1 + \\frac{1}{n^2} \\sum_{r=1}^n \\left( (r-1)A(r-1) + (n-r)A(n-r) \\right) $$\n注意到 $\\sum_{r=1}^n (r-1)A(r-1)$ 和 $\\sum_{r=1}^n (n-r)A(n-r)$ 是相同的求和，只是索引变量不同（令 $j=n-r$）。\n$$ A(n) = n-1 + \\frac{2}{n^2} \\sum_{j=0}^{n-1} j A(j) $$\n这是一个可以通过消除求和项来求解的递推关系。\n$n^2 A(n) = n^2(n-1) + 2 \\sum_{j=0}^{n-1} j A(j)$\n对于 $n-1$：\n$(n-1)^2 A(n-1) = (n-1)^2(n-2) + 2 \\sum_{j=0}^{n-2} j A(j)$\n将两式相减：\n$n^2 A(n) - (n-1)^2 A(n-1) = n^2(n-1) - (n-1)^2(n-2) + 2(n-1)A(n-1)$\n$n^2 A(n) = ((n-1)^2 + 2(n-1)) A(n-1) + n^2(n-1) - (n-1)^2(n-2)$\n$n^2 A(n) = (n-1)(n+1) A(n-1) + (n-1)(n^2 - (n-1)(n-2))$\n$n^2 A(n) = (n^2-1) A(n-1) + (n-1)(3n-2)$\n$A(n) = \\frac{n^2-1}{n^2} A(n-1) + \\frac{(n-1)(3n-2)}{n^2} = \\left(1-\\frac{1}{n^2}\\right)A(n-1) + 3 - \\frac{5}{n} + \\frac{2}{n^2}$\n对于大的 $n$，$A(n) \\approx A(n-1) + 3$。这是一个算术级数，表明 $A(n)$ 线性增长，斜率约为 $3$。\n因此，线性渐近式 $A(n) \\sim c n$ 中的首项系数 $c = 3$。", "answer": "$$\\boxed{3}$$", "id": "3214466"}]}