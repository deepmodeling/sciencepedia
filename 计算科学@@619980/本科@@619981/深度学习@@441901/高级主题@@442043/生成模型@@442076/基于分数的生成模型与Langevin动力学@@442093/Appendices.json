{"hands_on_practices": [{"introduction": "在我们使用或建模分数函数之前，我们必须首先理解它是什么。第一个练习将通过让你推导多变量高斯分布分数函数的解析形式，来为你提供一个基础性的理解 [@problem_id:3172987]。这个结果不仅仅是理论上的好奇心；它为分数模型的架构提供了关键的健全性检查，并为我们直观理解为什么分数指向更高概率密度的区域提供了基础。", "problem": "考虑一个 $d$ 维随机变量 $x \\in \\mathbb{R}^{d}$，它服从均值为 $\\mu \\in \\mathbb{R}^{d}$、协方差矩阵为严格正定矩阵 $\\Sigma \\in \\mathbb{R}^{d \\times d}$ 的多元高斯分布。其概率密度函数为\n$$\np(x) = \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right).\n$$\n在基于分数的生成模型中，分数函数定义为 $s(x) = \\nabla_{x} \\ln p(x)$。从所给的密度函数和分数函数的定义出发，推导 $s(x)$ 关于 $\\mu$ 和 $\\Sigma$ 的显式解析表达式。然后，利用过阻尼 Langevin 动力学随机微分方程 (SDE) $dX_{t} = s(X_{t})\\, dt + \\sqrt{2}\\, dW_{t}$（其中 $W_{t}$ 是一个标准的 $d$ 维维纳过程），简要解释为什么确定性漂移是 $x$ 的仿射函数，并找出该漂移消失的点。\n\n仅给出 $s(x)$ 的闭式表达式作为最终结果。不需要进行数值四舍五入，也不涉及物理单位。", "solution": "该问题陈述经核实具有科学依据，是适定且客观的。它在概率论和随机过程的标准数学框架内，为推导唯一且有意义的解提供了所有必要的定义和约束。\n\n出发点是一个 $d$ 维随机变量 $x \\in \\mathbb{R}^{d}$ 的多元高斯分布的概率密度函数 (PDF)，其均值为 $\\mu \\in \\mathbb{R}^{d}$，协方差矩阵为严格正定矩阵 $\\Sigma \\in \\mathbb{R}^{d \\times d}$：\n$$\np(x) = \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right)\n$$\n分数函数，记为 $s(x)$，定义为概率密度函数对数关于 $x$ 的梯度：\n$$\ns(x) = \\nabla_{x} \\ln p(x)\n$$\n为了推导 $s(x)$ 的表达式，我们首先计算 $p(x)$ 的自然对数：\n$$\n\\ln p(x) = \\ln \\left( \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right) \\right)\n$$\n利用对数的性质，特别是 $\\ln(a \\cdot b) = \\ln(a) + \\ln(b)$ 和 $\\ln(\\exp(c)) = c$，我们可以将各项分开：\n$$\n\\ln p(x) = \\ln \\left( \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\right) + \\ln \\left( \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right) \\right)\n$$\n$$\n\\ln p(x) = -\\frac{d}{2} \\ln(2\\pi) - \\frac{1}{2} \\ln(|\\Sigma|) - \\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\n$$\n前两项 $-\\frac{d}{2} \\ln(2\\pi)$ 和 $-\\frac{1}{2} \\ln(|\\Sigma|)$ 是关于变量 $x$ 的常数。因此，它们的梯度为零。现在我们可以通过求 $\\ln p(x)$ 的梯度来计算分数函数 $s(x)$：\n$$\ns(x) = \\nabla_{x} \\left( -\\frac{d}{2} \\ln(2\\pi) - \\frac{1}{2} \\ln(|\\Sigma|) - \\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu) \\right)\n$$\n$$\ns(x) = 0 - 0 - \\frac{1}{2} \\nabla_{x} \\left( (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu) \\right)\n$$\n为了计算二次型的梯度，我们使用矩阵演算中的一个标准结果。对于向量变量 $z$ 和对称矩阵 $A$，梯度由 $\\nabla_{z} (z^{\\top} A z) = 2 A z$ 给出。在我们的例子中，变量是 $x$，对应于 $z$ 的向量是 $(x - \\mu)$，对应于 $A$ 的矩阵是 $\\Sigma^{-1}$。根据定义，协方差矩阵 $\\Sigma$ 是对称的，而对称矩阵的逆矩阵也是对称的，所以 $\\Sigma^{-1}$ 是对称的。应用链式法则，我们有：\n$$\n\\nabla_{x} \\left( (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu) \\right) = 2 \\Sigma^{-1} (x - \\mu)\n$$\n将这个结果代回 $s(x)$ 的表达式中：\n$$\ns(x) = -\\frac{1}{2} \\left( 2 \\Sigma^{-1} (x - \\mu) \\right) = - \\Sigma^{-1} (x - \\mu)\n$$\n这就是多元高斯分布分数函数的显式解析表达式。\n\n问题还要求解释为什么在过阻尼 Langevin 动力学 SDE 中，确定性漂移是 $x$ 的仿射函数，并找出它在何处消失。该 SDE 由以下公式给出：\n$$\ndX_{t} = s(X_{t})\\, dt + \\sqrt{2}\\, dW_{t}\n$$\n确定性漂移项是 $s(X_{t})$。根据我们推导出的分数表达式，我们可以将其写为：\n$$\ns(X_t) = -\\Sigma^{-1}(X_t - \\mu) = -\\Sigma^{-1}X_t + \\Sigma^{-1}\\mu\n$$\n这个表达式的形式是 $A x + b$，其中 $A = -\\Sigma^{-1}$ 是一个 $d \\times d$ 矩阵，$b = \\Sigma^{-1}\\mu$ 是一个 $d \\times 1$ 向量。根据定义，这种形式的函数是一个仿射变换。因此，确定性漂移是状态 $X_t$ 的仿射函数。\n\n为了找到漂移消失的点，我们令 $s(x) = 0$：\n$$\n- \\Sigma^{-1} (x - \\mu) = 0\n$$\n由于 $\\Sigma$ 是一个严格正定矩阵，它是可逆的，其逆矩阵 $\\Sigma^{-1}$ 也是可逆的。我们可以在方程两边从左边乘以 $-\\Sigma$：\n$$\n(-\\Sigma)(-\\Sigma^{-1}) (x - \\mu) = (-\\Sigma) 0\n$$\n$$\nI (x - \\mu) = 0\n$$\n其中 $I$ 是 $d \\times d$ 单位矩阵。这可以简化为：\n$$\nx - \\mu = 0 \\implies x = \\mu\n$$\n因此，漂移在 $x = \\mu$ 处消失，这里是高斯分布的均值。这是符合预期的，因为分数函数指向对数概率的最速上升方向，而梯度在分布的众数处必须为零，对于高斯分布来说，众数就是其均值。", "answer": "$$\\boxed{-\\Sigma^{-1}(x - \\mu)}$$", "id": "3172987"}, {"introduction": "一旦我们有了分数函数，我们就可以用它来指导基于朗之万动力学的采样过程。这个练习将从理论转向数值实现 [@problem_id:3172952]。你将比较简单的欧拉-丸山法和更复杂的预测-校正方案，并分析它们在偏差-方差上的权衡。这个练习阐明了为生成建模而离散化随机微分方程时所面临的实际挑战和细微差别。", "problem": "您必须编写一个完整、可运行的程序，用于比较一个简单的 Euler–Maruyama 采样器和一个预测-校正采样器，该程序应用于一个一维的基于分数的流程。此比较必须基于对每个采样器生成的平稳分布的二阶矩进行估计时的偏差-方差权衡。请从以下基本依据和定义开始，并且不要假设任何快捷公式。\n\n考虑一个在一维基于分数的生成模型中，由模型分数函数驱动的随机微分方程 (SDE)。设分数函数为 $s_{\\theta}(x) = -\\left(1+\\delta\\right)x$，其中 $\\delta$ 是一个标量参数，用于编码模型与标准正态目标真实分数之间的失配。该 SDE 为\n$$\n\\mathrm{d}X_t = s_{\\theta}(X_t) \\,\\mathrm{d}t + \\sqrt{2}\\,\\mathrm{d}W_t,\n$$\n其中 $W_t$ 是一个标准的维纳过程。\n\n使用时间步长 $h$ 和 Euler–Maruyama 方法（Euler–Maruyama (EM)）对 SDE 进行离散化，该方法产生以下形式的更新\n$$\nX_{k+1} = X_k + h\\, s_{\\theta}(X_k) + \\sqrt{2h}\\, Z_k,\n$$\n其中 $Z_k \\sim \\mathcal{N}(0,1)$ 是独立的标准正态随机变量。\n\n定义一个预测-校正 (PC) 方案，该方案首先应用上述的 Euler–Maruyama 预测器得到一个中间值 $X_{k+1}^{(\\text{pred})}$，然后使用相同的分数函数和步长 $c$ 应用一个确定性的校正步骤：\n$$\nX_{k+1} = X_{k+1}^{(\\text{pred})} + c\\, s_{\\theta}\\!\\left(X_{k+1}^{(\\text{pred})}\\right).\n$$\n该 PC 方案结合了一个随机预测器和一个基于 $s_{\\theta}$ 的确定性漂移校正器。\n\n真实分布的目标二阶矩是标准正态变量的二阶矩，即 $E[X^2] = 1$。对于每个采样器（EM 和 PC），假设步数 $T$ 足够大，以使链达到平稳状态。关注于每个方案所导出的平稳分布下的二阶矩 $E[X^2]$，计算：\n- 绝对偏差，定义为 $\\left| E[X^2] - 1 \\right|$。\n- 由平稳分布的 $M$ 个独立样本的平均值构成的 $E[X^2]$ 的蒙特卡洛估计量的方差。在平稳分布下，对于 $X \\sim \\mathcal{N}(0, V)$，使用 $E[X^2] = V$ 和 $E[X^4] = 3V^2$ 的事实，来确定 $X^2$ 在 $M$ 个独立样本上的样本均值的估计量方差。\n\n您的程序必须为下面指定的每个测试用例计算 EM 和 PC 的这些量。使用平稳状态下的独立性理想化，将估计量方差表示为平稳方差 $V$ 和样本大小 $M$ 的闭式函数。\n\n测试套件（每个测试用例是一个元组 $(\\delta, h, T, c)$）：\n1. $(0,\\, 0.05,\\, 400,\\, 0)$: 无校正器的基线（预测-校正简化为 Euler–Maruyama）。\n2. $(0,\\, 0.05,\\, 400,\\, 0.005)$: 带有小确定性漂移的校正器，分数匹配。\n3. $(0.1,\\, 0.05,\\, 400,\\, 0.005)$: 正模型失配，相同的步数。\n4. $(-0.2,\\, 0.1,\\, 400,\\, 0.1)$: 负模型失配，更大的步数。\n\n对于估计量方差的计算，每个方法每个测试用例使用 $M = 10000$ 个独立样本。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 对于每个测试用例，按此顺序附加四个浮点数：$\\left[\\text{bias}_{\\text{EM}}, \\text{var}_{\\text{EM}}, \\text{bias}_{\\text{PC}}, \\text{var}_{\\text{PC}}\\right]$。\n- 将所有测试用例的结果连接成一个列表，保留上述测试套件的顺序。例如，两个用例的输出应如下所示：$\\left[\\text{b}_{1,\\text{EM}}, \\text{v}_{1,\\text{EM}}, \\text{b}_{1,\\text{PC}}, \\text{v}_{1,\\text{PC}}, \\text{b}_{2,\\text{EM}}, \\text{v}_{2,\\text{EM}}, \\text{b}_{2,\\text{PC}}, \\text{v}_{2,\\text{PC}}\\right]$。\n\n您的程序必须是自包含的，不需要用户输入，并遵守执行环境的限制。", "solution": "该问题要求对基于分数的生成模型中出现的一维 Ornstein–Uhlenbeck 型随机微分方程 (SDE) 的 Euler–Maruyama (EM) 采样器和预测-校正 (PC) 采样器进行比较。该比较基于每个采样器生成的平稳分布的二阶矩估计的偏差和方差。我们将首先为每种数值方案的平稳方差推导解析表达式。\n\nSDE 由下式给出：\n$$\n\\mathrm{d}X_t = s_{\\theta}(X_t) \\,\\mathrm{d}t + \\sqrt{2}\\,\\mathrm{d}W_t\n$$\n其分数函数为 $s_{\\theta}(x) = -(1+\\delta)x$。代入分数函数，我们得到一个线性 SDE：\n$$\n\\mathrm{d}X_t = -(1+\\delta)X_t \\,\\mathrm{d}t + \\sqrt{2}\\,\\mathrm{d}W_t\n$$\n这个连续时间过程的平稳分布是一个零均值正态分布 $\\mathcal{N}(0, V_{true})$，其中方差 $V_{true}$ 满足涨落-耗散关系 $-(1+\\delta)V_{true} + 1 = 0$，由此得出 $V_{true} = 1/(1+\\delta)$。然而，问题将目标二阶矩指定为 $E[X^2] = 1$，这对应于一个标准正态分布（即底层 SDE 中 $\\delta=0$ 的情况）。偏差将以这个目标值 1 为基准进行衡量。\n\n两种离散化方案都是线性的，其一般形式为 $X_{k+1} = A X_k + B Z_k$，其中 $Z_k \\sim \\mathcal{N}(0,1)$。这是一个 1 阶自回归过程 (AR(1))。如果 $|A|1$，该过程有唯一的平稳分布。由于新息 $Z_k$ 是高斯的，平稳分布也是均值为零的高斯分布，$X \\sim \\mathcal{N}(0, V)$。方差 $V$ 可以通过在平稳状态下令等式两边的方差相等来求得：\n$$\n\\mathrm{Var}(X_{k+1}) = \\mathrm{Var}(A X_k + B Z_k)\n$$\n由于 $X_k$ 和 $Z_k$ 是独立的，\n$$\nV = A^2 \\mathrm{Var}(X_k) + B^2 \\mathrm{Var}(Z_k) = A^2 V + B^2\n$$\n解出 $V$，我们得到平稳方差：\n$$\nV = \\frac{B^2}{1 - A^2}\n$$\n这个公式是我们分析的基石。\n\n对于每个采样器，我们首先找到其平稳方差 $V$。然后从 $V$ 推导出我们感兴趣的量：\n1.  二阶矩估计量的绝对偏差：$b = |E[X^2] - 1| = |V-1|$。\n2.  $E[X^2]$ 的蒙特卡洛估计量的方差。该估计量是样本均值 $\\hat{E}[X^2] = \\frac{1}{M}\\sum_{i=1}^M X_i^2$，其中 $X_i \\sim \\mathcal{N}(0, V)$ 是来自平稳分布的 $M$ 个独立样本。该估计量的方差为：\n    $$\n    \\mathrm{Var}(\\hat{E}[X^2]) = \\mathrm{Var}\\left(\\frac{1}{M}\\sum_{i=1}^M X_i^2\\right) = \\frac{1}{M}\\mathrm{Var}(X^2)\n    $$\n    对于 $X \\sim \\mathcal{N}(0, V)$，我们已知 $E[X^4] = 3V^2$。因此：\n    $$\n    \\mathrm{Var}(X^2) = E[(X^2)^2] - (E[X^2])^2 = E[X^4] - V^2 = 3V^2 - V^2 = 2V^2\n    $$\n    所以估计量方差为 $v = \\frac{2V^2}{M}$。\n\n现在，我们将此框架应用于每个采样器。\n\n**1. Euler–Maruyama (EM) 采样器**\n\n更新规则为：\n$$\nX_{k+1} = X_k + h s_{\\theta}(X_k) + \\sqrt{2h} Z_k\n$$\n代入 $s_{\\theta}(X_k) = -(1+\\delta)X_k$：\n$$\nX_{k+1} = X_k - h(1+\\delta)X_k + \\sqrt{2h} Z_k = \\left(1 - h(1+\\delta)\\right)X_k + \\sqrt{2h} Z_k\n$$\n这是一个 AR(1) 过程，其系数为：\n$$\nA_{\\text{EM}} = 1 - h(1+\\delta) \\quad \\text{和} \\quad B_{\\text{EM}} = \\sqrt{2h}\n$$\n平稳方差 $V_{\\text{EM}}$ 为：\n$$\nV_{\\text{EM}} = \\frac{B_{\\text{EM}}^2}{1-A_{\\text{EM}}^2} = \\frac{(\\sqrt{2h})^2}{1 - (1 - h(1+\\delta))^2} = \\frac{2h}{1 - (1 - 2h(1+\\delta) + h^2(1+\\delta)^2)} = \\frac{2h}{2h(1+\\delta) - h^2(1+\\delta)^2}\n$$\n$$\nV_{\\text{EM}} = \\frac{2}{(1+\\delta)(2 - h(1+\\delta))}\n$$\nEM 采样器的偏差和估计量方差为：\n$$\n\\text{bias}_{\\text{EM}} = |V_{\\text{EM}} - 1| \\quad \\text{和} \\quad \\text{var}_{\\text{EM}} = \\frac{2V_{\\text{EM}}^2}{M}\n$$\n\n**2. 预测-校正 (PC) 采样器**\n\nPC 方案由一个预测步骤和一个校正步骤组成。\n预测器：\n$$\nX_{k+1}^{(\\text{pred})} = X_k + h s_{\\theta}(X_k) + \\sqrt{2h} Z_k = (1 - h(1+\\delta))X_k + \\sqrt{2h} Z_k\n$$\n校正器：\n$$\nX_{k+1} = X_{k+1}^{(\\text{pred})} + c s_{\\theta}(X_{k+1}^{(\\text{pred})}) = X_{k+1}^{(\\text{pred})} - c(1+\\delta)X_{k+1}^{(\\text{pred})} = (1 - c(1+\\delta))X_{k+1}^{(\\text{pred})}\n$$\n结合这两个步骤，我们直接用 $X_k$ 来表示 $X_{k+1}$：\n$$\nX_{k+1} = (1 - c(1+\\delta)) \\left[ (1 - h(1+\\delta))X_k + \\sqrt{2h}Z_k \\right]\n$$\n$$\nX_{k+1} = (1 - c(1+\\delta))(1 - h(1+\\delta)) X_k + (1 - c(1+\\delta))\\sqrt{2h} Z_k\n$$\n这同样是一个 AR(1) 过程，其系数为：\n$$\nA_{\\text{PC}} = (1 - c(1+\\delta))(1 - h(1+\\delta)) \\quad \\text{和} \\quad B_{\\text{PC}} = (1 - c(1+\\delta))\\sqrt{2h}\n$$\n平稳方差 $V_{\\text{PC}}$ 为：\n$$\nV_{\\text{PC}} = \\frac{B_{\\text{PC}}^2}{1-A_{\\text{PC}}^2} = \\frac{\\left((1 - c(1+\\delta))\\sqrt{2h}\\right)^2}{1 - \\left((1 - c(1+\\delta))(1 - h(1+\\delta))\\right)^2}\n$$\n$$\nV_{\\text{PC}} = \\frac{(1 - c(1+\\delta))^2 (2h)}{1 - (1 - c(1+\\delta))^2 (1 - h(1+\\delta))^2}\n$$\nPC 采样器的偏差和估计量方差为：\n$$\n\\text{bias}_{\\text{PC}} = |V_{\\text{PC}} - 1| \\quad \\text{和} \\quad \\text{var}_{\\text{PC}} = \\frac{2V_{\\text{PC}}^2}{M}\n$$\n注意，如果 $c=0$，则 $A_{\\text{PC}}=A_{\\text{EM}}$ 且 $B_{\\text{PC}}=B_{\\text{EM}}$，因此 $V_{\\text{PC}} = V_{\\text{EM}}$。这是一致的，因为零步长校正器使得 PC 方案与 EM 方案完全相同。程序将实现这些推导出的公式，以计算每个测试用例所需的量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the bias-variance tradeoff for EM and PC samplers for a 1D SDE.\n\n    The solution is based on the analytical derivation of the stationary variance\n    for the discretized processes, which are AR(1) models.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (delta, h, T, c). The parameter T is not used in the\n    # analytical stationary-state calculation.\n    test_cases = [\n        (0.0, 0.05, 400, 0.0),\n        (0.0, 0.05, 400, 0.005),\n        (0.1, 0.05, 400, 0.005),\n        (-0.2, 0.1, 400, 0.1),\n    ]\n\n    # Sample size for Monte Carlo estimator variance calculation.\n    M = 10000.0\n\n    results = []\n    for delta, h, T, c in test_cases:\n        # Common term in the score function s_theta(x) = -(1 + delta) * x\n        one_plus_delta = 1.0 + delta\n\n        # --- Euler–Maruyama (EM) Analysis ---\n        \n        # The EM update is X_{k+1} = (1 - h*(1+delta)) * X_k + sqrt(2*h) * Z_k\n        # This is an AR(1) process X_{k+1} = A*X_k + B*Z_k\n        # The stationary variance is V_EM = B^2 / (1 - A^2)\n        \n        # Using an expanded form for better numerical stability with small h\n        v_em_numerator = 2.0\n        v_em_denominator = one_plus_delta * (2.0 - h * one_plus_delta)\n        \n        # Ensure stability by checking denominator > 0, which corresponds to\n        # 0  h*(1+delta)  2\n        if v_em_denominator = 0:\n            # This case won't be hit with the given test values.\n            v_em = float('inf')\n        else:\n            v_em = v_em_numerator / v_em_denominator\n        \n        # Absolute bias: |E[X^2] - 1| = |V_em - 1|\n        bias_em = abs(v_em - 1.0)\n        \n        # Estimator variance: Var([sum X_i^2]/M) = Var(X^2) / M = 2*V_em^2/M\n        var_em_estimator = (2.0 * v_em**2) / M\n\n        # --- Predictor-Corrector (PC) Analysis ---\n\n        # The PC update is X_{k+1} = (1-c*(1+d)) * X_{k+1_pred}\n        # which results in X_{k+1} = A_pc * X_k + B_pc * Z_k\n        \n        # Coefficients for the AR(1) form of the PC scheme\n        alpha_h = 1.0 - h * one_plus_delta\n        alpha_c = 1.0 - c * one_plus_delta\n        \n        A_pc = alpha_c * alpha_h\n        B_pc_sq = (alpha_c**2) * (2.0 * h)\n        \n        v_pc_numerator = B_pc_sq\n        v_pc_denominator = 1.0 - A_pc**2\n        \n        # Ensure stability by checking |A_pc|  1\n        if v_pc_denominator = 0:\n            # This case won't be hit with the given test values.\n            v_pc = float('inf')\n        else:\n            v_pc = v_pc_numerator / v_pc_denominator\n\n        # Absolute bias: |E[X^2] - 1| = |V_pc - 1|\n        bias_pc = abs(v_pc - 1.0)\n        \n        # Estimator variance: 2*V_pc^2/M\n        var_pc_estimator = (2.0 * v_pc**2) / M\n\n        results.extend([bias_em, var_em_estimator, bias_pc, var_pc_estimator])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3172952"}, {"introduction": "一个真正的分数函数是一个*保守*向量场，这意味着两点之间对数概率的变化与所走的路径无关。然而，一个用神经网络近似的分数函数可能无法完美满足这一性质。最后一个练习探讨了分数场中非保守（或“旋转”）分量的后果 [@problem_id:3172994]。通过沿不同路径对分数进行数值积分，你将直接衡量这种不完美如何导致路径依赖的结果，这是基于分数的模型中一个关键的误差来源。", "problem": "考虑 $\\mathbb{R}^2$ 上的一个二维密度 $p(\\mathbf{x})$ 和一个基于分数的生成模型，该模型产生一个参数化分数场 $s_\\theta(\\mathbf{x})$。该分数场旨在近似真实分数 $s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$。在过阻尼 Langevin 动力学中（这是一种用于采样的随机微分方程，SDE），连续时间更新为\n$$\n\\mathrm{d}\\mathbf{x}_t = \\tfrac{1}{2}s_\\theta(\\mathbf{x}_t)\\,\\mathrm{d}t + \\mathrm{d}\\mathbf{W}_t,\n$$\n其中 $\\mathbf{W}_t$ 是一个标准维纳过程。如果 $s_\\theta(\\mathbf{x})$ 等于真实的梯度场，那么根据线积分基本定理，差值 $\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)$ 可以计算为 $s_\\theta(\\mathbf{x})$ 在 $\\mathbf{x}_0$ 和 $\\mathbf{x}$ 之间的路径积分。与保守场（梯度场）的偏差可以通过此类线积分的路径依赖性来检测。\n\n你的任务是实现一个程序，该程序：\n- 定义一个科学上合理的目标分布 $p(\\mathbf{x})$，作为两个权重相等的二维（$d = 2$）高斯分布的混合。使用\n$$\np(\\mathbf{x}) = \\tfrac{1}{2}\\,\\mathcal{N}\\!\\left(\\mathbf{x}\\mid\\boldsymbol{\\mu}_1,\\boldsymbol{\\Sigma}_1\\right) + \\tfrac{1}{2}\\,\\mathcal{N}\\!\\left(\\mathbf{x}\\mid\\boldsymbol{\\mu}_2,\\boldsymbol{\\Sigma}_2\\right),\n$$\n其中 $\\boldsymbol{\\mu}_1 = [0,0]^\\top$, $\\boldsymbol{\\mu}_2 = [2,-1]^\\top$, $\\boldsymbol{\\Sigma}_1 = \\begin{bmatrix}1.0  0.3 \\\\ 0.3  0.5\\end{bmatrix}$，以及 $\\boldsymbol{\\Sigma}_2 = \\begin{bmatrix}0.9  -0.2 \\\\ -0.2  0.8\\end{bmatrix}$。\n- 使用 $s(\\mathbf{x}) = \\frac{\\nabla_{\\mathbf{x}} p(\\mathbf{x})}{p(\\mathbf{x})}$ 和恒等式 $\\nabla_{\\mathbf{x}} \\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu},\\boldsymbol{\\Sigma}) = -\\boldsymbol{\\Sigma}^{-1}(\\mathbf{x}-\\boldsymbol{\\mu})\\,\\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu},\\boldsymbol{\\Sigma})$，从第一性原理计算真实分数 $s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$。\n- 构造一个参数化分数场 $s_\\theta(\\mathbf{x})$，其中包含一个可控的非保守分量：\n$$\ns_\\theta(\\mathbf{x}) = s(\\mathbf{x}) + \\varepsilon\\,\\mathbf{R}(\\mathbf{x}),\n$$\n其中 $\\varepsilon \\ge 0$ 是一个标量参数，$\\mathbf{R}(\\mathbf{x})$ 是在 $d=2$ 中定义的旋转场，由下式定义\n$$\n\\mathbf{R}(\\mathbf{x}) = \\frac{\\mathbf{Q}\\,(\\mathbf{x} - \\mathbf{c})}{1 + \\lVert \\mathbf{x} - \\mathbf{c} \\rVert^2}, \\quad \\mathbf{Q} = \\begin{bmatrix}0  -1 \\\\ 1  0\\end{bmatrix}, \\quad \\mathbf{c} = [0.5,-0.5]^\\top.\n$$\n请注意，$\\mathbf{Q}$ 将向量旋转 $90^\\circ$；$\\mathbf{R}(\\mathbf{x})$ 具有非零旋度，因此不是任何标量势的梯度。\n- 通过沿共享端点的两条路径对 $s_\\theta(\\mathbf{x})$ 进行数值积分来估计 $\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)$：\n    1. 一条直线路径\n    $$\n    \\boldsymbol{\\gamma}_{\\text{straight}}(t) = \\mathbf{x}_0 + t\\,(\\mathbf{x} - \\mathbf{x}_0), \\quad t \\in [0,1],\n    $$\n    其导数为 $\\boldsymbol{\\gamma}'_{\\text{straight}}(t) = \\mathbf{x} - \\mathbf{x}_0$。\n    2. 一条带有正弦绕行的弯曲路径，该绕行垂直于位移：\n    $$\n    \\boldsymbol{\\gamma}_{\\text{curved}}(t) = \\mathbf{x}_0 + t\\,\\mathbf{d} + a\\,\\sin(\\pi t)\\,\\hat{\\mathbf{n}}, \\quad t \\in [0,1],\n    $$\n    其中 $\\mathbf{d} = \\mathbf{x} - \\mathbf{x}_0$，$\\hat{\\mathbf{n}} = \\frac{\\mathbf{Q}\\,\\mathbf{d}}{\\lVert \\mathbf{d} \\rVert}$ 是通过将 $\\mathbf{d}$ 旋转 $90^\\circ$ 得到的单位法向量，而 $a \\ge 0$ 控制绕行幅度。路径导数为\n    $$\n    \\boldsymbol{\\gamma}'_{\\text{curved}}(t) = \\mathbf{d} + a\\,\\pi\\,\\cos(\\pi t)\\,\\hat{\\mathbf{n}}.\n    $$\n- 使用具有 $N$ 个步长的 $t \\in [0,1]$ 的均匀离散化和复合梯形法则来近似线积分\n$$\nI_{\\text{path}} = \\int_{0}^{1} s_\\theta(\\boldsymbol{\\gamma}(t)) \\cdot \\boldsymbol{\\gamma}'(t)\\,\\mathrm{d}t.\n$$\n如果 $\\lVert \\mathbf{d} \\rVert = 0$，则两个积分都必须报告为 $0$，以满足零位移下的基本定理。\n\n然后，对于下面套件中的每个测试用例，计算两个量：\n- $D$，它量化了路径依赖性，从而量化了 $s_\\theta(\\mathbf{x})$ 的非保守性。\n$$\nD = \\left\\lvert I_{\\text{straight}} - I_{\\text{curved}} \\right\\rvert\n$$\n- $E$，它衡量了直线路径估计相对于真实对数密度差的绝对误差。\n$$\nE = \\left\\lvert I_{\\text{straight}} - \\left(\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)\\right) \\right\\rvert\n$$\n\n使用 $N = 4096$ 个离散化步长。为了在计算 $\\log p(\\mathbf{x})$ 时保持数值稳定性，请使用数学上可靠的 log-sum-exp 方法来合并混合分量。将每个报告的浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n- 用例 1：$\\mathbf{x}_0 = [0,0]^\\top$，$\\mathbf{x} = [2,1]^\\top$，$\\varepsilon = 0.0$， $a = 0.5$。\n- 用例 2：$\\mathbf{x}_0 = [0,0]^\\top$，$\\mathbf{x} = [2,1]^\\top$，$\\varepsilon = 0.05$，$a = 0.5$。\n- 用例 3：$\\mathbf{x}_0 = [0,0]^\\top$，$\\mathbf{x} = [2,1]^\\top$，$\\varepsilon = 0.2$，$a = 0.5$。\n- 用例 4（边界情况）：$\\mathbf{x}_0 = [1,-1]^\\top$，$\\mathbf{x} = [1,-1]^\\top$，$\\varepsilon = 0.25$，$a = 1.0$。\n- 用例 5（高曲率）：$\\mathbf{x}_0 = [0,-2]^\\top$，$\\mathbf{x} = [3,1]^\\top$，$\\varepsilon = 0.1$，$a = 2.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为列表的列表，每个内部列表对应一个测试用例并按顺序排列。每个内部列表必须是 $[D,E]$ 的形式，两个条目都四舍五入到 $6$ 位小数。例如：$[[d_1,e_1],[d_2,e_2],\\dots]$。", "solution": "该问题要求分析在基于分数的生成模型中使用的参数化分数场 $s_\\theta(\\mathbf{x})$。真实分数场 $s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$ 的一个关键性质是它是一个保守向量场，这意味着它在两点之间的线积分与路径无关。近似分数场 $s_\\theta(\\mathbf{x})$ 可能不是保守的，这会在像 Langevin 动力学这样的采样算法中引入误差。本练习量化了非保守扰动对分数线积分的影响。\n\n解决方案分几步进行：\n1.  定义目标概率密度 $p(\\mathbf{x})$，并推导其对数 $\\log p(\\mathbf{x})$ 和其真实分数 $s(\\mathbf{x})$ 的表达式。\n2.  定义非保守的参数化分数场 $s_\\theta(\\mathbf{x})$。\n3.  定义两条积分路径 $\\boldsymbol{\\gamma}_{\\text{straight}}(t)$ 和 $\\boldsymbol{\\gamma}_{\\text{curved}}(t)$ 及其导数。\n4.  使用复合梯形法则构建数值线积分。\n5.  定义度量 $D$（路径依赖性）和 $E$（估计误差）。\n\n**1. 目标密度和真实分数**\n\n目标密度是 $d=2$ 维的高斯混合模型 (GMM)：\n$$\np(\\mathbf{x}) = \\frac{1}{2}\\,\\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu}_1, \\boldsymbol{\\Sigma}_1) + \\frac{1}{2}\\,\\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu}_2, \\boldsymbol{\\Sigma}_2)\n$$\n参数为 $\\boldsymbol{\\mu}_1 = [0,0]^\\top$, $\\boldsymbol{\\mu}_2 = [2,-1]^\\top$, $\\boldsymbol{\\Sigma}_1 = \\begin{bmatrix}1.0  0.3 \\\\ 0.3  0.5\\end{bmatrix}$，以及 $\\boldsymbol{\\Sigma}_2 = \\begin{bmatrix}0.9  -0.2 \\\\ -0.2  0.8\\end{bmatrix}$。\n\n为了稳定地计算对数 $\\log p(\\mathbf{x})$，我们使用 log-sum-exp (LSE) 恒等式。令 $p_i(\\mathbf{x}) = \\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu}_i, \\boldsymbol{\\Sigma}_i)$，我们有：\n$$\n\\log p(\\mathbf{x}) = \\log\\left(\\frac{1}{2}\\left(e^{\\log p_1(\\mathbf{x})} + e^{\\log p_2(\\mathbf{x})}\\right)\\right) = -\\log(2) + \\text{LSE}(\\log p_1(\\mathbf{x}), \\log p_2(\\mathbf{x}))\n$$\n多元正态分布的对数密度由下式给出：\n$$\n\\log \\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu},\\boldsymbol{\\Sigma}) = -\\frac{d}{2}\\log(2\\pi) - \\frac{1}{2}\\log|\\det(\\boldsymbol{\\Sigma})| - \\frac{1}{2}(\\mathbf{x}-\\boldsymbol{\\mu})^\\top\\boldsymbol{\\Sigma}^{-1}(\\mathbf{x}-\\boldsymbol{\\mu})\n$$\n\n真实分数是对数密度的梯度，$s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$。使用链式法则和恒等式 $\\nabla_{\\mathbf{x}} p(\\mathbf{x}) = p(\\mathbf{x}) \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$：\n$$\ns(\\mathbf{x}) = \\frac{\\nabla_{\\mathbf{x}} p(\\mathbf{x})}{p(\\mathbf{x})} = \\frac{\\frac{1}{2}\\nabla_{\\mathbf{x}} p_1(\\mathbf{x}) + \\frac{1}{2}\\nabla_{\\mathbf{x}} p_2(\\mathbf{x})}{\\frac{1}{2} p_1(\\mathbf{x}) + \\frac{1}{2} p_2(\\mathbf{x})}\n$$\n使用提供的恒等式 $\\nabla_{\\mathbf{x}} p_i(\\mathbf{x}) = p_i(\\mathbf{x}) \\nabla_{\\mathbf{x}} \\log p_i(\\mathbf{x})$，其中 $\\nabla_{\\mathbf{x}} \\log p_i(\\mathbf{x}) = -\\boldsymbol{\\Sigma}_i^{-1}(\\mathbf{x}-\\boldsymbol{\\mu}_i) = s_i(\\mathbf{x})$，分数可以表示为各个分量分数的加权平均值：\n$$\ns(\\mathbf{x}) = \\frac{p_1(\\mathbf{x})s_1(\\mathbf{x}) + p_2(\\mathbf{x})s_2(\\mathbf{x})}{p_1(\\mathbf{x}) + p_2(\\mathbf{x})}\n$$\n通过提取 $\\log p_1(\\mathbf{x})$ 和 $\\log p_2(\\mathbf{x})$ 的最大值，可以使用 LSE 技巧稳定地计算此形式。\n\n**2. 参数化分数场**\n\n参数化分数场 $s_\\theta(\\mathbf{x})$ 是通过向真实分数添加非保守（旋转）分量来构造的：\n$$\ns_\\theta(\\mathbf{x}) = s(\\mathbf{x}) + \\varepsilon\\,\\mathbf{R}(\\mathbf{x})\n$$\n其中 $\\varepsilon \\ge 0$ 是控制非保守部分大小的标量。旋转场 $\\mathbf{R}(\\mathbf{x})$ 定义为：\n$$\n\\mathbf{R}(\\mathbf{x}) = \\frac{\\mathbf{Q}\\,(\\mathbf{x} - \\mathbf{c})}{1 + \\lVert \\mathbf{x} - \\mathbf{c} \\rVert^2}, \\quad \\text{with } \\mathbf{Q} = \\begin{bmatrix}0  -1 \\\\ 1  0\\end{bmatrix}, \\quad \\mathbf{c} = [0.5,-0.5]^\\top.\n$$\n矩阵 $\\mathbf{Q}$ 将二维向量旋转 $+90^\\circ$。$\\mathbf{R}(\\mathbf{x})$ 的旋度非零，证实了它不是一个梯度场。\n\n**3. 积分路径**\n\n我们沿着两条不同的路径计算 $s_\\theta(\\mathbf{x})$ 从起点 $\\mathbf{x}_0$ 到终点 $\\mathbf{x}$ 的线积分，两条路径都由 $t \\in [0,1]$ 参数化。\n1.  **直线路径**：一条直接的线段。\n    $$\n    \\boldsymbol{\\gamma}_{\\text{straight}}(t) = \\mathbf{x}_0 + t\\,(\\mathbf{x} - \\mathbf{x}_0) \\quad \\implies \\quad \\boldsymbol{\\gamma}'_{\\text{straight}}(t) = \\mathbf{x} - \\mathbf{x}_0\n    $$\n2.  **弯曲路径**：一条正弦绕行。令 $\\mathbf{d} = \\mathbf{x} - \\mathbf{x}_0$ 为位移向量，$\\hat{\\mathbf{n}} = \\mathbf{Q}\\,\\mathbf{d} / \\lVert \\mathbf{d} \\rVert$ 为正交单位向量。\n    $$\n    \\boldsymbol{\\gamma}_{\\text{curved}}(t) = \\mathbf{x}_0 + t\\,\\mathbf{d} + a\\,\\sin(\\pi t)\\,\\hat{\\mathbf{n}} \\quad \\implies \\quad \\boldsymbol{\\gamma}'_{\\text{curved}}(t) = \\mathbf{d} + a\\,\\pi\\,\\cos(\\pi t)\\,\\hat{\\mathbf{n}}\n    $$\n参数 $a \\ge 0$ 控制绕行的幅度。\n\n**4. 数值线积分**\n\n沿路径 $\\boldsymbol{\\gamma}$ 的线积分由 $I_{\\text{path}} = \\int_{\\boldsymbol{\\gamma}} s_\\theta(\\mathbf{x}) \\cdot \\mathrm{d}\\mathbf{x}$ 给出。使用参数化 $\\boldsymbol{\\gamma}(t)$，这变为：\n$$\nI_{\\text{path}} = \\int_{0}^{1} s_\\theta(\\boldsymbol{\\gamma}(t)) \\cdot \\boldsymbol{\\gamma}'(t)\\,\\mathrm{d}t\n$$\n该积分使用具有 $N=4096$ 个步长的复合梯形法则进行数值近似。令 $t_k = k/N$（对于 $k=0, 1, \\dots, N$），并令 $g(t) = s_\\theta(\\boldsymbol{\\gamma}(t)) \\cdot \\boldsymbol{\\gamma}'(t)$。积分近似为：\n$$\nI_{\\text{path}} \\approx \\frac{1}{N} \\left( \\frac{g(t_0) + g(t_N)}{2} + \\sum_{k=1}^{N-1} g(t_k) \\right)\n$$\n当 $\\mathbf{x}_0 = \\mathbf{x}$ 时会出现特殊情况，这意味着 $\\mathbf{d}=\\mathbf{0}$。在这种情况下，两条路径都是静止的，路径导数为零，并且两个积分 $I_{\\text{straight}}$ 和 $I_{\\text{curved}}$ 都定义为 $0$。\n\n**5. 误差度量**\n\n为每个测试用例计算两个度量：\n-   **路径依赖性 ($D$)**：沿两条路径的积分之间的绝对差。如果 $s_\\theta$ 是保守场，此值将为 $0$。非零值表示存在偏差。\n    $$\n    D = \\left\\lvert I_{\\text{straight}} - I_{\\text{curved}} \\right\\rvert\n    $$\n-   **估计误差 ($E$)**：直线路径积分与真实对数密度差之间的绝对误差。对于完全保守场（$\\varepsilon=0$），这反映了数值积分误差。对于 $\\varepsilon > 0$，它还包括来自非保守分量的误差。\n    $$\n    E = \\left\\lvert I_{\\text{straight}} - \\left(\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)\\right) \\right\\rvert\n    $$\n\n该程序使用 `numpy` 以矢量化方式实现这些步骤以提高效率，处理每个测试用例以计算并报告 $D$ 和 $E$ 的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes path-dependence and estimation error for a non-conservative score field.\n    \"\"\"\n    # Define problem constants\n    D_DIM = 2\n    MU1 = np.array([0.0, 0.0])\n    MU2 = np.array([2.0, -1.0])\n    SIGMA1 = np.array([[1.0, 0.3], [0.3, 0.5]])\n    SIGMA2 = np.array([[0.9, -0.2], [-0.2, 0.8]])\n    Q = np.array([[0.0, -1.0], [1.0, 0.0]])\n    C = np.array([0.5, -0.5])\n    N_STEPS = 4096\n\n    # Pre-compute matrix inverses and log-determinants\n    SIGMA1_INV = np.linalg.inv(SIGMA1)\n    SIGMA2_INV = np.linalg.inv(SIGMA2)\n    _, LOG_DET_SIGMA1 = np.linalg.slogdet(SIGMA1)\n    _, LOG_DET_SIGMA2 = np.linalg.slogdet(SIGMA2)\n    \n    LOG_PDF_CONST = -0.5 * D_DIM * np.log(2 * np.pi)\n\n    def log_pdf_gaussian_batch(x, mu, inv_sigma, log_det_sigma):\n        \"\"\"Computes log-PDF for a batch of points for a single Gaussian.\"\"\"\n        # x shape: (D_DIM, M)\n        # mu shape: (D_DIM,)\n        diff = x - mu[:, np.newaxis]  # shape (D_DIM, M)\n        mahalanobis = np.einsum('im,ij,jm->m', diff, inv_sigma, diff)\n        return LOG_PDF_CONST - 0.5 * log_det_sigma - 0.5 * mahalanobis\n\n    def log_pdf_gmm_batch(x):\n        \"\"\"Computes log-PDF for a batch of points for the GMM.\"\"\"\n        log_p1 = log_pdf_gaussian_batch(x, MU1, SIGMA1_INV, LOG_DET_SIGMA1)\n        log_p2 = log_pdf_gaussian_batch(x, MU2, SIGMA2_INV, LOG_DET_SIGMA2)\n        \n        max_log = np.maximum(log_p1, log_p2)\n        lse = max_log + np.log(np.exp(log_p1 - max_log) + np.exp(log_p2 - max_log))\n        \n        return -np.log(2) + lse\n\n    def true_score_batch(x):\n        \"\"\"Computes the true score field for a batch of points.\"\"\"\n        diff1 = x - MU1[:, np.newaxis]\n        diff2 = x - MU2[:, np.newaxis]\n        s1 = -SIGMA1_INV @ diff1\n        s2 = -SIGMA2_INV @ diff2\n        \n        log_p1 = log_pdf_gaussian_batch(x, MU1, SIGMA1_INV, LOG_DET_SIGMA1)\n        log_p2 = log_pdf_gaussian_batch(x, MU2, SIGMA2_INV, LOG_DET_SIGMA2)\n        \n        max_log = np.maximum(log_p1, log_p2)\n        exp1 = np.exp(log_p1 - max_log)\n        exp2 = np.exp(log_p2 - max_log)\n        \n        # Broadcasting for weighted average\n        score = (exp1[np.newaxis, :] * s1 + exp2[np.newaxis, :] * s2) / (exp1 + exp2)[np.newaxis, :]\n        return score\n\n    def rotational_field_batch(x):\n        \"\"\"Computes the rotational field component for a batch of points.\"\"\"\n        diff = x - C[:, np.newaxis]\n        norm_sq = np.sum(diff * diff, axis=0)\n        return (Q @ diff) / (1.0 + norm_sq)\n\n    def parametric_score_batch(x, epsilon):\n        \"\"\"Computes the perturbed parametric score field.\"\"\"\n        return true_score_batch(x) + epsilon * rotational_field_batch(x)\n\n    def compute_metrics(case):\n        \"\"\"Computes D and E for a single test case.\"\"\"\n        x0, x, epsilon, a = case\n        x0, x = np.array(x0), np.array(x)\n\n        d_vec = x - x0\n        d_norm = np.linalg.norm(d_vec)\n\n        if np.isclose(d_norm, 0):\n            return 0.0, 0.0\n\n        t = np.linspace(0, 1, N_STEPS + 1)\n\n        # Path 1: Straight\n        gamma_straight = x0[:, np.newaxis] + d_vec[:, np.newaxis] * t\n        gamma_prime_straight = np.tile(d_vec[:, np.newaxis], (1, len(t)))\n        \n        s_theta_straight = parametric_score_batch(gamma_straight, epsilon)\n        integrand_straight = np.einsum('ij,ij->j', s_theta_straight, gamma_prime_straight)\n        I_straight = np.trapz(integrand_straight, t)\n\n        # Path 2: Curved\n        n_hat = (Q @ d_vec) / d_norm\n        gamma_curved = (x0[:, np.newaxis] + d_vec[:, np.newaxis] * t +\n                        a * np.sin(np.pi * t) * n_hat[:, np.newaxis])\n        gamma_prime_curved = (d_vec[:, np.newaxis] +\n                              a * np.pi * np.cos(np.pi * t) * n_hat[:, np.newaxis])\n\n        s_theta_curved = parametric_score_batch(gamma_curved, epsilon)\n        integrand_curved = np.einsum('ij,ij->j', s_theta_curved, gamma_prime_curved)\n        I_curved = np.trapz(integrand_curved, t)\n\n        # True log-density difference\n        log_p_x = log_pdf_gmm_batch(x[:, np.newaxis])[0]\n        log_p_x0 = log_pdf_gmm_batch(x0[:, np.newaxis])[0]\n        true_diff = log_p_x - log_p_x0\n        \n        # Metrics D and E\n        D = np.abs(I_straight - I_curved)\n        E = np.abs(I_straight - true_diff)\n\n        return D, E\n\n    test_cases = [\n        ([0.0, 0.0], [2.0, 1.0], 0.0, 0.5),      # Case 1\n        ([0.0, 0.0], [2.0, 1.0], 0.05, 0.5),     # Case 2\n        ([0.0, 0.0], [2.0, 1.0], 0.2, 0.5),      # Case 3\n        ([1.0, -1.0], [1.0, -1.0], 0.25, 1.0),   # Case 4\n        ([0.0, -2.0], [3.0, 1.0], 0.1, 2.0),     # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        D_val, E_val = compute_metrics(case)\n        results.append(f\"[{D_val:.6f},{E_val:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3172994"}]}