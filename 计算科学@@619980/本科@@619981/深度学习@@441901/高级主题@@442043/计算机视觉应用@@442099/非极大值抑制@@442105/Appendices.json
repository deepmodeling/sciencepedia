{"hands_on_practices": [{"introduction": "非极大值抑制（NMS）的标准实现是一种贪心算法，它高效但并不总是能产出最优解。为了深刻理解其内在权衡，我们可以将 NMS 问题构建为一个整数线性规划（ILP）问题，从而找到理论上的最优解。通过这个练习 [@problem_id:3159494]，你将亲手实现贪心 NMS 和基于枚举的精确 ILP 解法，直观地比较两者在不同场景下的表现，并揭示贪心策略可能导致次优结果的具体情况。", "problem": "给定一组在二维平面内的轴对齐矩形边界框。每个框都有坐标和一个相关的非负置信度分数。目标是通过将其表述为约束满足问题，并利用整数线性规划（ILP）在小规模实例上精确求解，以及通过贪心选择过程，来实现非极大值抑制（NMS），然后比较两种方法的结果。\n\n定义与基础：\n- 对于一个坐标由元组 $(x_1,y_1,x_2,y_2)$ 表示的框，假设 $x_1  x_2$ 且 $y_1  y_2$。其面积为 $(x_2 - x_1)\\,(y_2 - y_1)$。\n- 两个框 $i$ 和 $j$ 之间的交并比（IoU）定义为它们的交集面积与并集面积之比。如果没有重叠，交集面积为 $0$，且 $\\mathrm{IoU}_{ij} = 0$。并集面积等于两个框的面积之和减去交集面积。所有的IoU值都是无量纲的。\n- 非极大值抑制（NMS）根据一个阈值 $t \\in [0,1]$ 来抑制重叠的框。在本问题中，使用以下规则：如果 $\\mathrm{IoU}_{ij} \\ge t$，则两个框 $i$ 和 $j$ 是互斥的。\n\n表述为ILP：\n- 为每个框 $i$ 引入二元决策变量 $x_i \\in \\{0,1\\}$，其中 $x_i = 1$ 表示选择该框，$x_i = 0$ 表示不选择。\n- 令 $s_i \\ge 0$ 表示框 $i$ 的置信度分数。\n- 对于每一对 $\\mathrm{IoU}_{ij} \\ge t$ 的框 $(i,j)$，施加约束 $x_i + x_j \\le 1$。\n- 目标：在满足上述约束的条件下，最大化 $\\sum_i s_i x_i$。\n- 由于实例规模很小，通过枚举所有满足约束的 $\\{x_i\\}$ 可行分配，并选择使目标函数最大化的分配，来精确求解ILP。如果总分出现平局，则选择已选索引的排序列表字典序最小的那个来打破平局。\n\n贪心NMS过程：\n- 按分数降序排列框。当分数相同时，按索引升序打破平局。\n- 遍历排序后的列表，如果一个框未被抑制，则选择它。选择框 $k$ 后，抑制所有满足 $\\mathrm{IoU}_{kj} \\ge t$ 的剩余框 $j$。\n- 输出是所选索引的升序排序列表。\n\n你的任务：\n- 实现两种方法：精确的ILP求解器（通过枚举）和贪心NMS。\n- 使用以下测试套件。框被指定为 $(x_1,y_1,x_2,y_2)$，所有分数均无单位。对于每个案例，索引都是从0开始的。\n- 对于每个测试用例，输出一个列表，其中包含：\n  1. 贪心法选择的索引，为一个升序整数列表。\n  2. ILP选择的索引，为一个升序整数列表（在最优解中采用字典序平局决胜）。\n  3. 一个布尔值，指示两个索引列表是否相同。\n  4. 贪心法总分，四舍五入到三位小数。\n  5. ILP总分，四舍五入到三位小数。\n\n测试套件：\n- 案例 A（理想情况，中度重叠）：阈值 $t = 0.3$；框与分数\n  - 索引 $0$：$(0.0, 0.0, 2.0, 2.0)$，分数 $s_0 = 0.90$\n  - 索引 $1$：$(0.5, 0.5, 2.5, 2.5)$，分数 $s_1 = 0.85$\n  - 索引 $2$：$(2.1, 0.0, 4.1, 2.0)$，分数 $s_2 = 0.70$\n  - 索引 $3$：$(0.0, 2.1, 2.0, 4.1)$，分数 $s_3 = 0.60$\n- 案例 B（因链式冲突导致的贪心次优解）：阈值 $t = 0.5$；框与分数\n  - 索引 $0$：$(0.0, 0.0, 2.0, 2.0)$，分数 $s_0 = 0.60$\n  - 索引 $1$：$(0.5, 0.0, 2.5, 2.0)$，分数 $s_1 = 0.95$\n  - 索引 $2$：$(1.0, 0.0, 3.0, 2.0)$，分数 $s_2 = 0.60$\n- 案例 C（边界条件 t = 0）：阈值 $t = 0.0$；框与分数\n  - 索引 $0$：$(0.0, 0.0, 1.0, 1.0)$，分数 $s_0 = 0.50$\n  - 索引 $1$：$(2.0, 0.0, 3.0, 1.0)$，分数 $s_1 = 0.70$\n  - 索引 $2$：$(4.0, 0.0, 5.0, 1.0)$，分数 $s_2 = 0.60$\n- 案例 D（边界条件 t = 1 且有相同框）：阈值 $t = 1.0$；框与分数\n  - 索引 $0$：$(0.0, 0.0, 1.0, 1.0)$，分数 $s_0 = 0.60$\n  - 索引 $1$：$(0.0, 0.0, 1.0, 1.0)$，分数 $s_1 = 0.59$\n  - 索引 $2$：$(2.0, 2.0, 3.0, 3.0)$，分数 $s_2 = 0.40$\n- 案例 E（两种策略中均出现平局）：阈值 $t = 0.5$；框与分数\n  - 索引 $0$：$(0.0, 0.0, 2.0, 2.0)$，分数 $s_0 = 0.80$\n  - 索引 $1$：$(0.5, 0.0, 2.5, 2.0)$，分数 $s_1 = 0.80$\n  - 索引 $2$：$(3.0, 0.0, 5.0, 2.0)$，分数 $s_2 = 0.10$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个元素。每个元素必须是以下形式的列表\n  $[G, O, B, S_G, S_O]$,\n  其中 $G$ 是贪心法索引列表，$O$ 是ILP索引列表，$B$ 是布尔相等指示符，$S_G$ 是四舍五入到三位小数的贪心法总分，$S_O$ 是四舍五入到三位小数的ILP总分。整个输出必须是单行，例如：\n  $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。", "solution": "所提出的问题要求实现并比较两种不同的非极大值抑制（NMS）方法：一种标准的贪心启发式算法和一种基于整数线性规划（ILP）公式的精确求解器。任务是将这两种方法应用于一系列测试用例，并报告所选的边界框、得到的总分以及两组结果之间的比较。\n\n首先，我们为该问题建立数学基础。一个边界框 $B_i$ 由其坐标 $(x_{i,1}, y_{i,1}, x_{i,2}, y_{i,2})$ 定义，题目已给出 $x_{i,1}  x_{i,2}$ 和 $y_{i,1}  y_{i,2}$。框 $B_i$ 的面积由下式给出：\n$$\n\\text{Area}(B_i) = (x_{i,2} - x_{i,1})(y_{i,2} - y_{i,1})\n$$\nNMS的核心度量是交并比（IoU），它量化了两个框 $B_i$ 和 $B_j$ 之间的重叠程度。交集面积根据重叠矩形计算：\n$$\n\\text{Area}(B_i \\cap B_j) = \\max(0, \\min(x_{i,2}, x_{j,2}) - \\max(x_{i,1}, x_{j,1})) \\cdot \\max(0, \\min(y_{i,2}, y_{j,2}) - \\max(y_{i,1}, y_{j,1}))\n$$\n并集面积源于容斥原理：\n$$\n\\text{Area}(B_i \\cup B_j) = \\text{Area}(B_i) + \\text{Area}(B_j) - \\text{Area}(B_i \\cap B_j)\n$$\n因此，IoU定义为以下比率：\n$$\n\\mathrm{IoU}_{ij} = \\frac{\\text{Area}(B_i \\cap B_j)}{\\text{Area}(B_i \\cup B_j)}\n$$\n如果并集面积为零（这意味着两个框的面积都为零，这在问题陈述中被排除了），则IoU取为 $0$。$\\mathrm{IoU}_{ij}$ 的值位于区间 $[0, 1]$ 内。\n\n要实现的第一个方法是贪心NMS算法。这是一种广泛使用的启发式方法，其操作如下：\n1.  创建一个包含所有候选框的列表，每个框都有一个相关的置信度分数 $s_i$ 和一个原始索引 $i$。\n2.  根据置信度分数按降序对此列表进行排序。如果分数出现平局，则将原始索引较小的框排在前面。\n3.  算法遍历排序后的列表。选择第一个框。然后，所有与所选框 $B_i$ 的IoU大于或等于指定阈值 $t$（即 $\\mathrm{IoU}_{ij} \\ge t$）的其他框 $B_j$ 都被标记为已抑制并从考虑中移除。\n4.  对排序列表中下一个可用的（未被抑制的）框重复此过程，直到所有框都已被选择或抑制。\n5.  最终输出是所选框索引的集合，按升序排序。\n\n第二个方法是基于整数线性规划（ILP）公式的精确解。这种方法保证了在满足重叠约束的条件下，选择的框能使总置信度分数最大化。其公式如下：\n-   对于每个框 $i$，我们引入一个二元决策变量 $x_i \\in \\{0, 1\\}$，其中 $x_i = 1$ 表示选择该框，否则 $x_i = 0$。\n-   目标是最大化所选框的分数之和：\n    $$\n    \\text{maximize} \\quad Z = \\sum_{i} s_i x_i\n    $$\n-   NMS规则通过一组约束来强制执行。对于每一对重叠度达到或超过阈值的框 $(i, j)$，即 $\\mathrm{IoU}_{ij} \\ge t$，我们施加约束，规定它们中最多只能选择一个：\n    $$\n    x_i + x_j \\le 1 \\quad \\forall (i, j) \\text{ such that } i  j \\text{ and } \\mathrm{IoU}_{ij} \\ge t\n    $$\n由于问题实例很小（最多4个框），这个ILP可以通过枚举变量 $\\{x_i\\}$ 的所有 $2^N$ 种可能分配来精确求解，其中 $N$ 是框的数量。对于每种分配，我们检查其是否可行（即满足所有约束）。在所有可行分配中，我们寻找产生最大目标值的那个。如果多个分配得到相同的最大分数，则通过选择其对应索引列表字典序最小的那个来打破平局。\n\n实现将包括用于计算IoU的辅助函数，以及用于贪心和ILP算法的专用函数。主程序将遍历提供的测试套件，执行两种算法，并按规定格式化结果，包括所选索引、总分以及所选索引集的布尔比较。分数将报告为四舍五入到三位小数的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the NMS problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"t\": 0.3,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.5, 2.5, 2.5],\n                [2.1, 0.0, 4.1, 2.0],\n                [0.0, 2.1, 2.0, 4.1]\n            ]),\n            \"scores\": np.array([0.90, 0.85, 0.70, 0.60])\n        },\n        {\n            \"t\": 0.5,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.0, 2.5, 2.0],\n                [1.0, 0.0, 3.0, 2.0]\n            ]),\n            \"scores\": np.array([0.60, 0.95, 0.60])\n        },\n        {\n            \"t\": 0.0,\n            \"boxes\": np.array([\n                [0.0, 0.0, 1.0, 1.0],\n                [2.0, 0.0, 3.0, 1.0],\n                [4.0, 0.0, 5.0, 1.0]\n            ]),\n            \"scores\": np.array([0.50, 0.70, 0.60])\n        },\n        {\n            \"t\": 1.0,\n            \"boxes\": np.array([\n                [0.0, 0.0, 1.0, 1.0],\n                [0.0, 0.0, 1.0, 1.0],\n                [2.0, 2.0, 3.0, 3.0]\n            ]),\n            \"scores\": np.array([0.60, 0.59, 0.40])\n        },\n        {\n            \"t\": 0.5,\n            \"boxes\": np.array([\n                [0.0, 0.0, 2.0, 2.0],\n                [0.5, 0.0, 2.5, 2.0],\n                [3.0, 0.0, 5.0, 2.0]\n            ]),\n            \"scores\": np.array([0.80, 0.80, 0.10])\n        }\n    ]\n\n    def calculate_iou(box1, box2):\n        \"\"\"Calculates Intersection over Union for two bounding boxes.\"\"\"\n        x1_1, y1_1, x2_1, y2_1 = box1\n        x1_2, y1_2, x2_2, y2_2 = box2\n\n        inter_x1 = max(x1_1, x1_2)\n        inter_y1 = max(y1_1, y1_2)\n        inter_x2 = min(x2_1, x2_2)\n        inter_y2 = min(y2_1, y2_2)\n\n        inter_w = max(0, inter_x2 - inter_x1)\n        inter_h = max(0, inter_y2 - inter_y1)\n        intersection_area = inter_w * inter_h\n\n        area1 = (x2_1 - x1_1) * (y2_1 - y1_1)\n        area2 = (x2_2 - x1_2) * (y2_2 - y1_2)\n        union_area = area1 + area2 - intersection_area\n\n        if union_area == 0:\n            return 0.0\n        return intersection_area / union_area\n\n    def greedy_nms(boxes, scores, threshold):\n        \"\"\"Performs greedy Non-Maximum Suppression.\"\"\"\n        indices = np.arange(len(scores))\n        \n        # Sort by score (desc) and then index (asc for tie-breaking)\n        sorted_indices = sorted(indices, key=lambda i: (-scores[i], i))\n        \n        selected_indices = []\n        suppressed = np.zeros(len(scores), dtype=bool)\n\n        for i in sorted_indices:\n            if not suppressed[i]:\n                selected_indices.append(i)\n                for j in sorted_indices:\n                    if i != j and not suppressed[j]:\n                        iou = calculate_iou(boxes[i], boxes[j])\n                        if iou = threshold:\n                            suppressed[j] = True\n        \n        return sorted(selected_indices)\n\n    def ilp_nms(boxes, scores, threshold):\n        \"\"\"Performs exact NMS via ILP formulation (solved by enumeration).\"\"\"\n        num_boxes = len(scores)\n        conflicts = []\n        for i in range(num_boxes):\n            for j in range(i + 1, num_boxes):\n                if calculate_iou(boxes[i], boxes[j]) = threshold:\n                    conflicts.append((i, j))\n\n        max_score = -1.0\n        best_selection = []\n\n        # Enumerate all 2^N subsets of boxes\n        for i in range(1  num_boxes):\n            current_selection_indices = []\n            for j in range(num_boxes):\n                if (i  j)  1:\n                    current_selection_indices.append(j)\n            \n            # Check feasibility\n            is_feasible = True\n            for c1, c2 in conflicts:\n                if c1 in current_selection_indices and c2 in current_selection_indices:\n                    is_feasible = False\n                    break\n            \n            if is_feasible:\n                current_score = np.sum(scores[current_selection_indices])\n                \n                if current_score  max_score:\n                    max_score = current_score\n                    best_selection = current_selection_indices\n                elif current_score == max_score:\n                    if not best_selection or current_selection_indices  best_selection:\n                        best_selection = current_selection_indices\n\n        return sorted(best_selection)\n\n    results = []\n    for case in test_cases:\n        t, boxes, scores = case[\"t\"], case[\"boxes\"], case[\"scores\"]\n        \n        # Greedy NMS\n        greedy_indices = greedy_nms(boxes, scores, t)\n        greedy_score = np.sum(scores[greedy_indices])\n\n        # ILP NMS\n        ilp_indices = ilp_nms(boxes, scores, t)\n        ilp_score = np.sum(scores[ilp_indices])\n\n        are_identical = (greedy_indices == ilp_indices)\n        \n        G_str = f\"[{','.join(map(str, greedy_indices))}]\"\n        O_str = f\"[{','.join(map(str, ilp_indices))}]\"\n        \n        # Format the result list for this case as a string\n        case_result_str = (\n            f\"[{G_str},\"\n            f\"{O_str},\"\n            f\"{str(are_identical).lower()},\"\n            f\"{greedy_score:.3f},\"\n            f\"{ilp_score:.3f}]\"\n        )\n        results.append(case_result_str)\n\n    # Print the final list of results\n    print(f\"[{','.join(results)}]\")\n\n# solve() # The platform will run the function.\n```", "id": "3159494"}, {"introduction": "在拥挤或遮挡场景中，标准的基于交并比（IoU）的 NMS 可能会错误地抑制掉一个得分较低但检测正确的小物体。这个练习 [@problem_id:3159508] 旨在解决这一缺陷，引导你从基本约束出发，推导出一个结合了 IoU 和“被抑制框的交集面积占比”（IoA）的新混合度量。通过这种方式，你将学会如何通过改进核心度量函数来增强 NMS 算法的鲁棒性，以更好地处理复杂的现实世界场景。", "problem": "现代的目标检测器会为每个对象输出多个边界框，并使用非极大值抑制来保留得分最高的检测结果，同时抑制与之重叠度高的其他检测结果。标准的重叠度量是交并比 (IoU)，对于两个轴对齐的矩形，其定义为其交集面积与并集面积之比。设 $\\operatorname{IoU}(B_{1},B_{2}) = \\frac{A(B_{1} \\cap B_{2})}{A(B_{1} \\cup B_{2})}$，其中 $A(\\cdot)$ 表示面积，$\\cap,\\cup$ 分别表示交集和并集。为处理抑制候选框中的不对称性，定义关于被指定抑制的框的交集与面积之比 (IoA) 为 $\\operatorname{IoA}_{\\mathrm{sup}}(B_{\\mathrm{sup}},B_{\\mathrm{keep}}) = \\frac{A(B_{\\mathrm{sup}} \\cap B_{\\mathrm{keep}})}{A(B_{\\mathrm{sup}})}$，该值衡量了待抑制的候选框被保留框覆盖的比例。\n\n考虑这样一种情况：一个小的真阳性框被一个置信度分数更高的大框部分重叠。为防止抑制这个小的真阳性框，您将构建一个依赖于 $\\operatorname{IoU}$ 和 $\\operatorname{IoA}_{\\mathrm{sup}}$ 的组合重叠度量 $M$。请根据以下源于这些量在非极大值抑制中所起作用的要求，推导出一个 $M(\\operatorname{IoU},\\operatorname{IoA}_{\\mathrm{sup}})$ 的显式闭式表达式：\n\n- 当待抑制的候选框完全被保留框覆盖时，用于抑制的有效重叠应消失为零：对于任何 $\\operatorname{IoU} \\in [0,1]$，$M(\\operatorname{IoU},1) = 0$。\n- 当待抑制的候选框与保留框不重叠时，组合重叠应简化为标准的 $\\operatorname{IoU}$：对于任何 $\\operatorname{IoU} \\in [0,1]$，$M(\\operatorname{IoU},0) = \\operatorname{IoU}$。\n- 对于固定的 $\\operatorname{IoA}_{\\mathrm{sup}}$，$M$ 应在 $\\operatorname{IoU}$ 上单调递增。\n- 对于固定的 $\\operatorname{IoU}$，$M$ 应在 $\\operatorname{IoA}_{\\mathrm{sup}}$ 上单调递减。\n- 在所有总次数最多为 $2$ 的关于 $\\operatorname{IoU}$ 和 $\\operatorname{IoA}_{\\mathrm{sup}}$ 的二元多项式中，选择满足上述约束的最简形式。\n\n然后，为下面这对检测结果计算您推导出的 $M$ 值，其中小框是待抑制的候选框，大框是待保留的框：\n- 小框 $B_{s}$：左下角坐标为 $(2,2)$，右上角坐标为 $(5,5)$。\n- 大框 $B_{\\ell}$：左下角坐标为 $(1,1)$，右上角坐标为 $(6,4)$。\n\n计算 $M(\\operatorname{IoU}(B_{s},B_{\\ell}), \\operatorname{IoA}_{\\mathrm{sup}}(B_{s},B_{\\ell}))$ 的数值，并将您的最终答案四舍五入到四位有效数字。最终答案必须是一个无单位的实数值。", "solution": "该问题被认为是有效的，因为它在深度学习领域有科学依据，问题设定良好，具有一组明确的约束条件，并以客观、精确的语言表述。所有必要信息均已提供，且内部没有矛盾。\n\n任务是首先推导组合重叠度量 $M(\\operatorname{IoU}, \\operatorname{IoA}_{\\mathrm{sup}})$ 的闭式表达式，然后为一对特定的边界框计算其值。\n\n设 $x = \\operatorname{IoU}$ 且 $y = \\operatorname{IoA}_{\\mathrm{sup}}$。我们正在寻找一个总次数最多为 $2$ 的最简二元多项式 $M(x, y)$，以满足给定约束。一个总次数为 $2$ 的一般多项式形式如下：\n$$M(x, y) = c_{00} + c_{10}x + c_{01}y + c_{20}x^2 + c_{11}xy + c_{02}y^2$$\n\n我们应用给定的约束来确定系数 $c_{ij}$。\n\n约束 2：对于任何 $x \\in [0,1]$，$M(x, 0) = x$。\n将 $y=0$ 代入多项式中得到：\n$$M(x, 0) = c_{00} + c_{10}x + c_{20}x^2$$\n为使此表达式恒等于 $x$， $x$ 的同次幂的系数必须匹配。这得出：\n$c_{00} = 0$， $c_{10} = 1$，以及 $c_{20} = 0$。\n多项式简化为：\n$$M(x, y) = x + c_{01}y + c_{11}xy + c_{02}y^2$$\n\n约束 1：对于任何 $x \\in [0,1]$，$M(x, 1) = 0$。\n将 $y=1$ 代入简化后的多项式中得到：\n$$M(x, 1) = x + c_{01}(1) + c_{11}x(1) + c_{02}(1)^2 = (1 + c_{11})x + (c_{01} + c_{02})$$\n为使此表达式对所有 $x$ 恒等于 $0$，系数必须为零：\n$1 + c_{11} = 0 \\implies c_{11} = -1$。\n$c_{01} + c_{02} = 0 \\implies c_{01} = -c_{02}$。\n多项式现在的形式为：\n$$M(x, y) = x - c_{02}y - xy + c_{02}y^2$$\n\n约束 5：选择最简形式。如果一个多项式项数更少或总次数更低，通常认为它更简单。当前形式的次数为 $2$。线性多项式（次数为 $1$）已被排除，因为它不能同时满足约束 1 和 2。当前多项式的最简形式可以通过将剩余的自由系数 $c_{02}$ 设置为最简单可能的值 $0$ 来获得。\n如果我们设 $c_{02} = 0$，那么 $c_{01} = -c_{02} = 0$。多项式变为：\n$$M(x, y) = x - xy = x(1 - y)$$\n这是一个总次数为 $2$ 的多项式。\n\n我们现在必须验证此形式是否满足其余的单调性约束。\n约束 3：对于固定的 $y$，$M$ 在 $x$ 上单调递增。\n我们计算关于 $x$ 的偏导数：\n$$\\frac{\\partial M}{\\partial x} = \\frac{\\partial}{\\partial x} (x(1-y)) = 1 - y$$\n由于 $y = \\operatorname{IoA}_{\\mathrm{sup}}$ 是面积之比，其值在范围 $[0, 1]$ 内。因此，$1 - y \\ge 0$，这确认了 $M$ 在 $x$ 上是单调非递减的。这满足了该约束。\n\n约束 4：对于固定的 $x$，$M$ 在 $y$ 上单调递减。\n我们计算关于 $y$ 的偏导数：\n$$\\frac{\\partial M}{\\partial y} = \\frac{\\partial}{\\partial y} (x(1-y)) = -x$$\n由于 $x = \\operatorname{IoU}$ 也是面积之比，其值在范围 $[0, 1]$ 内。因此，$-x \\le 0$，这确认了 $M$ 在 $y$ 上是单调非递增的。这满足了该约束。\n\n因此，满足所有约束的最简多项式为 $M(x, y) = x(1-y)$。用原始变量表示：\n$$M(\\operatorname{IoU}, \\operatorname{IoA}_{\\mathrm{sup}}) = \\operatorname{IoU} (1 - \\operatorname{IoA}_{\\mathrm{sup}})$$\n\n接下来，我们为给定的边界框计算此度量。\n要被抑制的小框是 $B_s$，其左下角坐标为 $(2,2)$，右上角坐标为 $(5,5)$。\n其宽度为 $w_s = 5 - 2 = 3$，高度为 $h_s = 5 - 2 = 3$。\n面积为 $A(B_s) = w_s \\times h_s = 3 \\times 3 = 9$。\n\n要保留的大框是 $B_\\ell$，其左下角坐标为 $(1,1)$，右上角坐标为 $(6,4)$。\n其宽度为 $w_\\ell = 6 - 1 = 5$，高度为 $h_\\ell = 4 - 1 = 3$。\n面积为 $A(B_\\ell) = w_\\ell \\times h_\\ell = 5 \\times 3 = 15$。\n\n我们计算交集面积 $A(B_s \\cap B_\\ell)$。交集矩形的坐标由以下公式给出：\n$x_{\\text{min,int}} = \\max(2, 1) = 2$\n$y_{\\text{min,int}} = \\max(2, 1) = 2$\n$x_{\\text{max,int}} = \\min(5, 6) = 5$\n$y_{\\text{max,int}} = \\min(5, 4) = 4$\n交集的宽度为 $w_{\\text{int}} = 5 - 2 = 3$。\n交集的高度为 $h_{\\text{int}} = 4 - 2 = 2$。\n交集的面积为 $A(B_s \\cap B_\\ell) = w_{\\text{int}} \\times h_{\\text{int}} = 3 \\times 2 = 6$。\n\n现在我们可以计算 $\\operatorname{IoU}$ 和 $\\operatorname{IoA}_{\\mathrm{sup}}$。\n并集的面积为 $A(B_s \\cup B_\\ell) = A(B_s) + A(B_\\ell) - A(B_s \\cap B_\\ell) = 9 + 15 - 6 = 18$。\n交并比为：\n$$\\operatorname{IoU}(B_s, B_\\ell) = \\frac{A(B_s \\cap B_\\ell)}{A(B_s \\cup B_\\ell)} = \\frac{6}{18} = \\frac{1}{3}$$\n抑制的候选框是 $B_s$，因此 $B_{\\mathrm{sup}} = B_s$。被抑制框的交集与面积之比为：\n$$\\operatorname{IoA}_{\\mathrm{sup}}(B_s, B_\\ell) = \\frac{A(B_s \\cap B_\\ell)}{A(B_s)} = \\frac{6}{9} = \\frac{2}{3}$$\n\n最后，我们将这些值代入我们推导出的 $M$ 表达式中：\n$$M\\left(\\frac{1}{3}, \\frac{2}{3}\\right) = \\frac{1}{3} \\left(1 - \\frac{2}{3}\\right) = \\frac{1}{3} \\left(\\frac{1}{3}\\right) = \\frac{1}{9}$$\n问题要求答案四舍五入到四位有效数字。\n$$\\frac{1}{9} \\approx 0.1111$$", "answer": "$$\\boxed{0.1111}$$", "id": "3159508"}, {"introduction": "“硬”抑制并非唯一选择，对于中等重叠的检测框，直接删除可能过于严苛。Soft-NMS 通过降低重叠框的分数而非完全移除，为保留正确的检测提供了可能。此练习 [@problem_id:3159559] 将指导你实现一种结合了硬抑制和软抑制的混合 NMS 方案，并让你体验一个关键的机器学习实践：通过网格搜索来优化算法的超参数（$t_l$ 和 $t_h$），以在验证集上最大化 F1 分数。", "problem": "您将获得一个用于目标检测的混合非极大值抑制（NMS）方案，该方案结合了对高重叠度的硬抑制和对中等重叠度的分数衰减。请构建一个完整的程序，为下述每个测试用例，搜索一个有限的阈值对网格，以选择能够最大化验证目标的最优阈值。\n\n定义与基础知识：\n- 对于两个由坐标 $[x_1,y_1,x_2,y_2]$ 给定左下角和右上角的轴对齐矩形，它们的交并比（IoU）定义为交集面积与并集面积之比。具体来说，对于框 $A$ 和 $B$，交集宽度为 $\\max(0,\\min(x_2^A,x_2^B)-\\max(x_1^A,x_1^B))$，交集高度为 $\\max(0,\\min(y_2^A,y_2^B)-\\max(y_1^A,y_1^B))$，交集面积是这两者的乘积，而并集面积是 $A$ 和 $B$ 的面积之和减去交集面积。IoU 是交集面积除以并集面积，约定当并集面积为零时，IoU 也为零。\n- 非极大值抑制（NMS）是一种后处理步骤，它通过基于成对的 IoU 和置信度分数来抑制冗余预测，从而保留预测边界框的一个子集。\n- 软非极大值抑制（Soft-NMS）根据一个加权函数，对与选定框重叠的框的分数进行衰减，而不是直接删除。\n- 在这个混合方案中，对于一个选定的“当前”框，任何其他 IoU 在区间 $[t_l,t_h)$ 内的框，其分数将乘以一个权重 $w(i)$；任何其他 IoU $\\ge t_h$ 的框，将通过将其分数设置为零来进行硬抑制。低于 $t_l$ 时，不应用任何更改。对于本问题，软衰减步骤使用线性加权函数 $w(i) = 1 - \\mathrm{IoU}$。\n\n需要实现的算法规范：\n- 混合 NMS 的输入：一组带有相关分数的预测框。通过重复选择当前分数最高的框（通过最小的原始索引来打破平局），然后根据以下规则更新其余框的分数，来迭代地处理它们：\n  - 如果 $\\mathrm{IoU} \\ge t_h$，将另一个框的分数设置为 $0$（硬抑制）。\n  - 否则，如果 $\\mathrm{IoU} \\in [t_l,t_h)$，将另一个框的分数设置为其当前分数乘以 $(1 - \\mathrm{IoU})$（软衰减）。\n  - 否则，分数保持不变。\n- 持续此过程，直到没有框的分数大于零。保留集是迭代过程中所有被选中的框的列表，每个框都带有其最终分数。然后，应用一个最终分数阈值 $s_{\\min}$，并丢弃任何最终分数小于 $s_{\\min}$ 的选定框。\n\n验证目标与匹配：\n- 为了评估，在 NMS 处理后的预测框和提供的真值框之间执行一对一贪婪匹配：按最终分数对预测框进行降序排序；对于该顺序中的每个预测框，如果其与当前未匹配的真值框中的最高 IoU 至少为匹配阈值 $\\tau_{\\mathrm{match}}$，则将其与之匹配。将匹配计为真阳性（TP），未匹配的预测计为假阳性（FP），未匹配的真值计为假阴性（FN）。F1分数的计算公式如下\n$$\n\\mathrm{F1} \\;=\\; \\frac{2 \\cdot \\mathrm{TP}}{2 \\cdot \\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN}}.\n$$\n- 最优阈值 $(t_l,t_h)$ 是在每个测试用例给定的有限搜索网格上使 F1 分数最大化的阈值。平局必须通过选择具有最大 $t_h$ 的配对来确定性地打破；如果仍然平局，则选择具有最小 $t_l$ 的配对。\n\n混合方案的数学术语回顾：\n- 对于每个选定的框 $b^\\star$，对于任何其他框 $b$，其当前分数为 $s(b)$，重叠度为 $o = \\mathrm{IoU}(b^\\star, b)$：\n  - 如果 $o \\ge t_h$，则设置 $s(b) \\leftarrow 0$。\n  - 否则，如果 $t_l \\le o  t_h$，则设置 $s(b) \\leftarrow s(b)\\cdot (1 - o)$。\n  - 否则，$s(b)$ 保持不变。\n- 在迭代直到没有正分数剩下之后，仅保留最终分数 $\\ge s_{\\min}$ 的选定框。\n\n您的程序必须实现混合 NMS，并为每个测试用例在 $(t_l,t_h)$ 上执行网格搜索。\n\n测试套件：\n对于每个测试用例，您将获得预测框和分数、真值框、分数阈值 $s_{\\min}$、IoU 匹配阈值 $\\tau_{\\mathrm{match}}$，以及 $t_l$ 和 $t_h$ 的离散候选集。\n\n- 测试用例 1（两个邻近对象、重复项以及一个中等重叠的大框）：\n  - 预测框（每个格式为 $[x_1,y_1,x_2,y_2]$）和分数：\n    - $[10,10,60,60]$，分数 $0.95$，\n    - $[12,12,58,58]$，分数 $0.90$，\n    - $[55,10,105,60]$，分数 $0.92$，\n    - $[57,12,103,58]$，分数 $0.85$，\n    - $[20,10,95,60]$，分数 $0.88$。\n  - 真值框：\n    - $[10,10,60,60]$,\n    - $[55,10,105,60]$。\n  - 分数阈值 $s_{\\min} = 0.50$，IoU 匹配阈值 $\\tau_{\\mathrm{match}} = 0.50$。\n  - 搜索网格：$t_l \\in \\{0.20,0.30,0.40\\}$，$t_h \\in \\{0.50,0.60,0.70,0.80\\}$，约束条件为 $t_l  t_h$。\n\n- 测试用例 2（IoU 等于阈值的边界条件）：\n  - 预测框和分数：\n    - $[10,10,30,30]$，分数 $0.95$，\n    - $[10,10,22,30]$，分数 $0.80$，\n    - $[10,10,22,20]$，分数 $0.70$。\n  - 真值框：\n    - $[10,10,30,30]$。\n  - 注意：$[10,10,30,30]$ 和 $[10,10,22,30]$ 之间的 $\\mathrm{IoU}$ 为 $0.60$，而 $[10,10,30,30]$ 和 $[10,10,22,20]$ 之间的 $\\mathrm{IoU}$ 为 $0.30$。\n  - 分数阈值 $s_{\\min} = 0.50$，IoU 匹配阈值 $\\tau_{\\mathrm{match}} = 0.50$。\n  - 搜索网格：$t_l \\in \\{0.30,0.40\\}$，$t_h \\in \\{0.60,0.70\\}$，约束条件为 $t_l  t_h$。\n\n- 测试用例 3（无重叠的预测；测试平局打破规则）：\n  - 预测框和分数：\n    - $[0,0,20,20]$，分数 $0.90$，\n    - $[40,0,60,20]$，分数 $0.85$，\n    - $[80,0,100,20]$，分数 $0.70$。\n  - 真值框：\n    - $[0,0,20,20]$,\n    - $[40,0,60,20]$。\n  - 分数阈值 $s_{\\min} = 0.50$，IoU 匹配阈值 $\\tau_{\\mathrm{match}} = 0.50$。\n  - 搜索网格：$t_l \\in \\{0.20,0.40\\}$，$t_h \\in \\{0.60,0.80\\}$，约束条件为 $t_l  t_h$。\n\n要求：\n- 完全按照规定实现混合 NMS 和验证评估，包括在区间 $[t_l,t_h)$ 上的线性权重 $w(i) = 1 - \\mathrm{IoU}$ 以及对 $\\mathrm{IoU} \\ge t_h$ 的硬抑制。\n- 对于每个测试用例，在给定的候选集上对 $(t_l,t_h)$ 进行网格搜索（遵守 $t_l  t_h$），找到使 F1 分数最大化的配对；通过选择最大的 $t_h$ 来打破平局，如果仍然平局，则选择最小的 $t_l$。\n- 最终输出格式：您的程序应生成单行输出，其中包含最优阈值对的列表，格式为包含两个浮点数的列表的列表，与测试用例顺序相同，每个浮点数四舍五入到三位小数，且没有多余的空格。例如：$[[0.400,0.800],[0.300,0.700],[0.200,0.800]]$。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它在科学上植根于目标检测的深度学习领域，其定义清晰一致，表述客观，问题设定良好。该任务要求实现一个指定的混合非极大值抑制（NMS）算法，在网格搜索程序中应用该算法以找到最优参数，并使用标准的 F1 分数指标评估结果。所有必需的数据、函数和评估标准均已提供，从而可以推导出唯一且可验证的解决方案。\n\n解决方案的步骤是首先按规定实现核心组件：交并比（IoU）计算、混合 NMS 算法和 F1 分数评估指标。然后将这些组件集成到一个网格搜索框架中，为每个提供的测试用例求解最优阈值对。\n\n**1. 交并比（IoU）**\n\n对于两个由坐标 $[x_1, y_1, x_2, y_2]$ 定义的轴对齐边界框 $A$ 和 $B$，IoU 是衡量它们相对重叠度的指标。它是它们的交集面积与并集面积之比。\n\n- 设框 $A$ 为 $[x_{1A}, y_{1A}, x_{2A}, y_{2A}]$，框 $B$ 为 $[x_{1B}, y_{1B}, x_{2B}, y_{2B}]$。\n- 交集矩形的坐标为：\n  - $x_{1, \\text{inter}} = \\max(x_{1A}, x_{1B})$\n  - $y_{1, \\text{inter}} = \\max(y_{1A}, y_{1B})$\n  - $x_{2, \\text{inter}} = \\min(x_{2A}, x_{2B})$\n  - $y_{2, \\text{inter}} = \\min(y_{2A}, y_{2B})$\n- 交集面积 $A_{\\text{inter}}$ 计算如下：\n$$\nA_{\\text{inter}} = \\max(0, x_{2, \\text{inter}} - x_{1, \\text{inter}}) \\cdot \\max(0, y_{2, \\text{inter}} - y_{1, \\text{inter}})\n$$\n- 每个框的面积为 $\\text{Area}(A) = (x_{2A} - x_{1A}) \\cdot (y_{2A} - y_{1A})$ 和 $\\text{Area}(B) = (x_{2B} - x_{1B}) \\cdot (y_{2B} - y_{1B})$。\n- 并集面积 $A_{\\text{union}}$ 由容斥原理给出：\n$$\nA_{\\text{union}} = \\text{Area}(A) + \\text{Area}(B) - A_{\\text{inter}}\n$$\n- 那么 IoU 为：\n$$\n\\mathrm{IoU}(A, B) = \\frac{A_{\\text{inter}}}{A_{\\text{union}}}\n$$\n处理了一个特殊情况，即 $A_{\\text{union}} = 0$，此时 $\\mathrm{IoU}$ 定义为 $0$。\n\n**2. 混合非极大值抑制（NMS）**\n\n指定的 NMS 算法是一个迭代过程，旨在修剪冗余的边界框预测。它处理一个初始预测列表，每个预测都有一个置信度分数。\n\n算法流程如下：\n1.  初始化一个保留框列表 $R$ 为空。设当前预测集为 $P$。保留原始分数和索引以供参考。\n2.  当 $P$ 中存在任何分数大于 $0$ 的框时，循环执行：\n    a. 从 $P$ 中选择当前分数最高的框 $b^\\star$。通过选择原始索引最小的框来打破平局。\n    b. 将 $b^\\star$ 添加到保留框列表 $R$ 中，并存储其被选中时的分数。在后续的选择步骤中不再考虑 $b^\\star$（例如，通过将其分数设置为非正值）。\n    c. 对于 $P$ 中剩下的每个其他框 $b_j$：\n        i. 计算重叠度 $o_j = \\mathrm{IoU}(b^\\star, b_j)$。\n        ii. 根据由阈值 $t_l$ 和 $t_h$ 控制的混合抑制规则更新分数 $s(b_j)$：\n           - 如果 $o_j \\ge t_h$：$s(b_j) \\leftarrow 0$ (硬抑制)。\n           - 否则，如果 $t_l \\le o_j  t_h$：$s(b_j) \\leftarrow s(b_j) \\cdot (1 - o_j)$ (软衰减)。\n           - 否则 ($o_j  t_l$)：分数 $s(b_j)$ 保持不变。\n3.  迭代过程结束后，对保留框列表 $R$ 应用最后一步筛选。丢弃 $R$ 中任何最终分数（即被选中时的分数）低于给定阈值 $s_{\\min}$ 的框。\n4.  输出是最终筛选后的保留框列表及其分数。\n\n**3. 验证目标：F1分数**\n\n对于给定的阈值对 $(t_l, t_h)$，NMS 算法的性能通过与一组真值框计算 F1 分数来评估。这涉及一个贪婪匹配过程：\n\n1.  将 NMS 输出的预测框集按其最终分数的降序排序。\n2.  执行一对一匹配。对于已排序列表中的每个预测框，我们找到与其具有最高 IoU 的真值框。\n3.  如果这个最高的 IoU 大于或等于匹配阈值 $\\tau_{\\mathrm{match}}$，并且所选的真值框尚未被匹配，则该配对被视为一次匹配（一个真阳性，TP）。预测框和真值框都标记为已匹配。\n4.  遍历所有预测框后：\n    - 真阳性（TP）是成功匹配的数量。\n    - 假阳性（FP）是未能匹配的预测框的数量。\n    - 假阴性（FN）是未能匹配的真值框的数量。\n5.  然后计算 F1 分数。如果 $\\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN} = 0$，则 F1 分数为 $1$。否则，如果 $2 \\cdot \\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN} = 0$，则 F1 分数为 $0$。在所有其他情况下：\n$$\n\\mathrm{F1} = \\frac{2 \\cdot \\mathrm{TP}}{2 \\cdot \\mathrm{TP} + \\mathrm{FP} + \\mathrm{FN}}\n$$\n\n**4. 网格搜索与优化**\n\n对于每个测试用例，目标是从给定的离散搜索网格中找到最优的阈值对 $(t_l, t_h)$。优化目标是最大化 F1 分数。搜索遍历网格中所有有效的 $(t_l, t_h)$ 对（其中 $t_l  t_h$）。选择产生最高 F1 分数的阈值对。\n\n应用一个确定性的平局打破规则：\n1.  如果多个阈值对产生相同的最大 F1 分数，则优先选择具有最大 $t_h$ 值的那个。\n2.  如果仍然存在平局（即，多个对共享相同的最大 F1 分数和相同的最大 $t_h$），则选择具有最小 $t_l$ 值的那个作为最终最优解。\n\n最终的程序实现了这些组件，并为每个测试用例执行网格搜索，以根据这些规范识别并报告最优的 $(t_l, t_h)$ 对。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving process for all test cases.\n    It defines test cases, runs the grid search for each, and prints the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"pred_boxes\": np.array([\n                [10, 10, 60, 60],\n                [12, 12, 58, 58],\n                [55, 10, 105, 60],\n                [57, 12, 103, 58],\n                [20, 10, 95, 60],\n            ]),\n            \"pred_scores\": np.array([0.95, 0.90, 0.92, 0.85, 0.88]),\n            \"gt_boxes\": np.array([\n                [10, 10, 60, 60],\n                [55, 10, 105, 60],\n            ]),\n            \"s_min\": 0.50,\n            \"tau_match\": 0.50,\n            \"tl_grid\": [0.20, 0.30, 0.40],\n            \"th_grid\": [0.50, 0.60, 0.70, 0.80],\n        },\n        {\n            \"pred_boxes\": np.array([\n                [10, 10, 30, 30],\n                [10, 10, 22, 30],\n                [10, 10, 22, 20],\n            ]),\n            \"pred_scores\": np.array([0.95, 0.80, 0.70]),\n            \"gt_boxes\": np.array([\n                [10, 10, 30, 30],\n            ]),\n            \"s_min\": 0.50,\n            \"tau_match\": 0.50,\n            \"tl_grid\": [0.30, 0.40],\n            \"th_grid\": [0.60, 0.70],\n        },\n        {\n            \"pred_boxes\": np.array([\n                [0, 0, 20, 20],\n                [40, 0, 60, 20],\n                [80, 0, 100, 20],\n            ]),\n            \"pred_scores\": np.array([0.90, 0.85, 0.70]),\n            \"gt_boxes\": np.array([\n                [0, 0, 20, 20],\n                [40, 0, 60, 20],\n            ]),\n            \"s_min\": 0.50,\n            \"tau_match\": 0.50,\n            \"tl_grid\": [0.20, 0.40],\n            \"th_grid\": [0.60, 0.80],\n        },\n    ]\n\n    all_optimal_pairs = []\n\n    for case in test_cases:\n        best_f1 = -1.0\n        best_tl = -1.0\n        best_th = -1.0\n\n        for t_h in case[\"th_grid\"]:\n            for t_l in case[\"tl_grid\"]:\n                if t_l = t_h:\n                    continue\n\n                # Run hybrid NMS\n                final_preds = hybrid_nms(\n                    case[\"pred_boxes\"], case[\"pred_scores\"],\n                    t_l, t_h, case[\"s_min\"]\n                )\n\n                # Evaluate F1 score\n                current_f1 = calculate_f1_score(\n                    final_preds, case[\"gt_boxes\"], case[\"tau_match\"]\n                )\n                \n                # Update best thresholds based on F1 and tie-breaking rules\n                if current_f1  best_f1:\n                    best_f1 = current_f1\n                    best_tl = t_l\n                    best_th = t_h\n                elif current_f1 == best_f1:\n                    if t_h  best_th:\n                        best_tl = t_l\n                        best_th = t_h\n                    elif t_h == best_th:\n                        if t_l  best_tl:\n                            best_tl = t_l\n        \n        all_optimal_pairs.append([best_tl, best_th])\n\n    # Format the final output string exactly as required\n    formatted_pairs = [f\"[{p[0]:.3f},{p[1]:.3f}]\" for p in all_optimal_pairs]\n    print(f\"[{','.join(formatted_pairs)}]\")\n\ndef calculate_iou(boxA, boxB):\n    \"\"\"Calculates Intersection over Union for two boxes.\"\"\"\n    xA = max(boxA[0], boxB[0])\n    yA = max(boxA[1], boxB[1])\n    xB = min(boxA[2], boxB[2])\n    yB = min(boxA[3], boxB[3])\n\n    inter_area = max(0, xB - xA) * max(0, yB - yA)\n    \n    boxA_area = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])\n    boxB_area = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])\n    \n    union_area = boxA_area + boxB_area - inter_area\n    \n    iou = inter_area / union_area if union_area  0 else 0.0\n    return iou\n\ndef hybrid_nms(boxes, scores, t_l, t_h, s_min):\n    \"\"\"\n    Implements the specified hybrid Non-Maximum Suppression algorithm.\n    \"\"\"\n    num_boxes = len(boxes)\n    current_scores = np.copy(scores)\n    original_indices = np.arange(num_boxes)\n    \n    selected_boxes_info = []\n\n    while np.any(current_scores  0):\n        # Find index of box with highest score.\n        max_score = -1\n        best_idx = -1\n        for i in range(num_boxes):\n            if current_scores[i]  max_score:\n                max_score = current_scores[i]\n                best_idx = i\n\n        best_box = boxes[best_idx]\n        \n        selected_boxes_info.append({\"box\": best_box, \"score\": max_score})\n        \n        # Mark the selected box as processed\n        current_scores[best_idx] = -1.0\n        \n        for i in range(num_boxes):\n            if current_scores[i] = 0:\n                continue\n            \n            iou = calculate_iou(best_box, boxes[i])\n            \n            if iou = t_h:\n                current_scores[i] = 0.0  # Hard suppression\n            elif t_l = iou  t_h:\n                current_scores[i] *= (1.0 - iou) # Soft attenuation\n\n    # Filter selected boxes by minimum score threshold\n    final_preds = [\n        p for p in selected_boxes_info if p[\"score\"] = s_min\n    ]\n    return final_preds\n\ndef calculate_f1_score(pred_boxes_info, gt_boxes, tau_match):\n    \"\"\"\n    Calculates the F1 score based on greedy matching between predictions and ground truth.\n    \"\"\"\n    num_preds = len(pred_boxes_info)\n    num_gts = len(gt_boxes)\n\n    if num_preds == 0 and num_gts == 0:\n        return 1.0\n\n    # Sort predictions by score in descending order\n    sorted_preds = sorted(pred_boxes_info, key=lambda x: x[\"score\"], reverse=True)\n    \n    gt_matched = [False] * num_gts\n    tp = 0\n    \n    for pred in sorted_preds:\n        best_iou = -1.0\n        best_gt_idx = -1\n        \n        for i in range(num_gts):\n            if not gt_matched[i]:\n                iou = calculate_iou(pred[\"box\"], gt_boxes[i])\n                if iou  best_iou:\n                    best_iou = iou\n                    best_gt_idx = i\n        \n        if best_gt_idx != -1 and best_iou = tau_match:\n            tp += 1\n            gt_matched[best_gt_idx] = True\n\n    fp = num_preds - tp\n    fn = num_gts - sum(gt_matched)\n    \n    denominator = 2 * tp + fp + fn\n    if denominator == 0:\n        return 1.0 if tp == 0 and fp == 0 and fn == 0 else 0.0\n\n    return (2 * tp) / denominator\n\n# Execute the main function\n# solve() # The platform will execute this.\n```", "id": "3159559"}]}