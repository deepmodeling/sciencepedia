{"hands_on_practices": [{"introduction": "神经网络面临的一个核心挑战是如何表示高频细节。本练习通过对一个简单的一维模式进行建模，探索了位置编码（positional encoding）这一关键技术，它使得多层感知机（MLP）能够学习复杂的信号。你将亲手发现采样率、编码能力和臭名昭著的混叠效应（aliasing effect）之间的相互作用，这是创建高保真神经表示的一个基础概念。[@problem_id:3136712]", "problem": "考虑一个任务：使用带有限制性位置编码 (Positional Encoding, PE) 的隐式神经表示 (Implicit Neural Representation, INR) 对一维带限信号进行建模。输入坐标 $x$ 位于区间 $[0,1)$ 内，角度必须以弧度处理。目标信号是一个由 $f_K(x) = \\cos(2\\pi K x)$ 定义的合成条纹图案，其中 $K$ 是一个整数频率，指定了单位区间内的周期数。INR 是在一个截断的傅里叶特征图上构建的线性模型，该特征图用作 PE。具体来说，对于选定的截止频率 $K_{\\text{cut}} \\in \\mathbb{N}$，PE 由以下特征向量定义\n$$\n\\phi_{K_{\\text{cut}}}(x) = \\left[1, \\cos(2\\pi \\cdot 1 \\cdot x), \\sin(2\\pi \\cdot 1 \\cdot x), \\ldots, \\cos(2\\pi \\cdot k \\cdot x), \\sin(2\\pi \\cdot k \\cdot x), \\ldots, \\cos(2\\pi \\cdot K_{\\text{cut}} \\cdot x), \\sin(2\\pi \\cdot K_{\\text{cut}} \\cdot x)\\right],\n$$\nINR 的预测值为\n$$\n\\hat{f}(x) = \\mathbf{w}^{\\top} \\phi_{K_{\\text{cut}}}(x),\n$$\n其中 $\\mathbf{w}$ 是通过最小化训练集上的平方误差得到的。\n\n训练集由 $N$ 个均匀间隔的样本 $x_n = \\frac{n}{N}$（$n = 0,1,\\ldots,N-1$）及其对应的目标值 $y_n = f_K(x_n)$ 组成。模型通过对这 $N$ 个样本进行线性最小二乘拟合。\n\n你的任务是构建一个玩具示例，以演示由于位置编码不足而导致的混叠现象，并使用此合成条纹图案来量化该现象。使用以下经过充分检验的理论基础进行推理：$[0,1)$ 上傅里叶级数的性质、通过截断傅里叶特征实现带限表示的概念，以及关于均匀采样序列的奈奎斯特采样观点。除了这些基本事实，不要假设任何特殊的恒等式；通过算法推导观察到的行为。\n\n对于下面的每个测试用例，你必须：\n- 使用指定的 $K_{\\text{cut}}$ 构建训练设计矩阵，通过最小二乘法拟合 $\\mathbf{w}$，并计算训练均方误差 (Mean Squared Error, MSE)，其定义为\n$$\n\\text{MSE}_{\\text{train}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\left(\\hat{f}(x_n) - f_K(x_n)\\right)^2.\n$$\n- 在一个由 $M$ 个点 $x_m = \\frac{m}{M}$（$m = 0,1,\\ldots,M-1$）组成的密集网格上评估拟合的模型，其中 $M$ 选为 2 的幂，并计算评估 MSE\n$$\n\\text{MSE}_{\\text{eval}} = \\frac{1}{M} \\sum_{m=0}^{M-1} \\left(\\hat{f}(x_m) - f_K(x_m)\\right)^2.\n$$\n- 通过对 $\\{\\hat{f}(x_m)\\}_{m=0}^{M-1}$ 应用快速傅里叶变换 (Fast Fourier Transform, FFT)，并选择使单边谱的幅度最大化的索引 $k^{\\star} \\in \\{1,2,\\ldots,\\lfloor M/2 \\rfloor\\}$，来估计拟合模型的主导频率。将 $k^{\\star}$ 报告为整数。\n\n使用以下参数值测试套件，其旨在涵盖该现象的不同方面：\n1. 理想情况：$(N, K, K_{\\text{cut}}) = (64, 4, 10)$。\n2. 目标频率超过 PE 截止频率，但在训练网格上可混叠到可表示频带内的情况：$(N, K, K_{\\text{cut}}) = (64, 60, 10)$。\n3. 目标频率超过 PE 截止频率且无法混叠到可表示频带内，导致低通近似的边缘情况：$(N, K, K_{\\text{cut}}) = (64, 53, 10)$。\n4. 训练网格奈奎斯特极限处的边界条件：$(N, K, K_{\\text{cut}}) = (64, 32, 32)$。\n\n将密集评估网格大小设置为 $M = 2048$。对于每个测试用例，生成三个量：$\\text{MSE}_{\\text{train}}$、$\\text{MSE}_{\\text{eval}}$ 和在密集网格上检测到的整数主导频率 $k^{\\star}$。将 MSE 值表示为四舍五入到六位小数的浮点数。不涉及物理单位；角度以弧度为单位。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试用例和指标排序如下：\n$$\n\\left[\\text{MSE}_{\\text{train}}^{(1)}, \\text{MSE}_{\\text{eval}}^{(1)}, k^{\\star (1)}, \\text{MSE}_{\\text{train}}^{(2)}, \\text{MSE}_{\\text{eval}}^{(2)}, k^{\\star (2)}, \\text{MSE}_{\\text{train}}^{(3)}, \\text{MSE}_{\\text{eval}}^{(3)}, k^{\\star (3)}, \\text{MSE}_{\\text{train}}^{(4)}, \\text{MSE}_{\\text{eval}}^{(4)}, k^{\\star (4)}\\right].\n$$\n所有量都必须由你的程序计算。不允许使用任何外部输入或文件。所有计算中角度都必须以弧度处理。", "solution": "用户的请求已经过评估且有效。该请求提出了一个在深度学习和信号处理领域内定义明确、有科学依据的问题，没有任何不一致或模糊之处。我们将继续提供完整的解决方案。\n\n该问题要求分析一种基于截断傅里叶特征图（也称为位置编码 PE）的隐式神经表示 (INR)。目标是通过在不同条件下将此模型拟合到简单正弦信号 $f_K(x) = \\cos(2\\pi K x)$，来演示混叠和其他表示瑕疵。INR 是一个线性模型 $\\hat{f}(x) = \\mathbf{w}^{\\top} \\phi_{K_{\\text{cut}}}(x)$，其中权重 $\\mathbf{w}$ 通过对一组 $N$ 个均匀样本进行线性最小二乘法来确定。\n\n分析的核心基于三个原则：\n1.  **表示能力**：PE $\\phi_{K_{\\text{cut}}}(x)$ 由最高频率为 $K_{\\text{cut}}$ 的正弦基函数组成。INR 作为这些基函数的线性组合，其固有频带被限制在 $[0, K_{\\text{cut}}]$ 范围内。它无法完美表示任何包含大于 $K_{\\text{cut}}$ 频率的信号。\n2.  **最小二乘投影**：最小二乘拟合过程通过将采样目标向量 $\\mathbf{y} = [y_0, \\ldots, y_{N-1}]^\\top$ 投影到由采样基向量（设计矩阵 $\\Phi$ 的列）张成的子空间上，来找到最优权重 $\\mathbf{w}$。当基向量在采样网格上正交时，解简化为对每个基向量的独立投影。\n3.  **采样与混叠**：根据奈奎斯特-香农采样定理，以单位区间 $N$ 个样本的速率对连续信号进行采样，只能明确地捕获最高为奈奎斯特频率 $N/2$ 的频率。频率为 $K > N/2$ 的信号在采样网格上会变得与一个较低频率的混叠信号无法区分。对于在 $x_n = n/N$ 处采样的纯余弦信号 $\\cos(2\\pi K x)$，其值 $\\cos(2\\pi K n/N)$ 与 $\\cos(2\\pi K' n/N)$ 的值相同，其中 $K'$ 是与 $\\pm K$ 模 $N$ 同余的最小幅值频率。即，$K' = \\min_{j \\in \\mathbb{Z}} |K - jN|$。\n\n我们现在将应用此框架来分析每个测试用例。对于所有情况，评估网格的大小为 $M=2048$。\n\n**情况 1: $(N, K, K_{\\text{cut}}) = (64, 4, 10)$**\n- **分析**：目标信号频率为 $K=4$，PE 截止频率为 $K_{\\text{cut}}=10$。由于 $K \\le K_{\\text{cut}}$，目标信号 $f_4(x) = \\cos(2\\pi \\cdot 4 \\cdot x)$ 可以由 PE 基直接表示。最小二乘拟合将为 $\\cos(2\\pi \\cdot 4 \\cdot x)$ 基函数确定正确的非零权重，而所有其他权重将接近于零。\n- **预测**：模型将完美重构目标信号。我们预计 $\\text{MSE}_{\\text{train}}$ 和 $\\text{MSE}_{\\text{eval}}$ 都将接近 $0$（在机器精度范围内）。拟合模型 $\\hat{f}(x)$ 在密集网格上的主导频率将是 $k^{\\star}=4$。\n\n**情况 2: $(N, K, K_{\\text{cut}}) = (64, 60, 10)$**\n- **分析**：目标频率 $K=60$ 远大于 PE 截止频率 $K_{\\text{cut}}=10$。然而，训练是在具有 $N=64$ 个样本的网格上进行的。奈奎斯特频率为 $N/2 = 32$。频率 $K=60$ 将会发生混叠。混叠后的频率为 $K' = |60 - 64| = 4$。在训练网格上，从 $f_{60}(x)$ 采样的值与从 $f_4(x)$ 采样的值完全相同：\n$$y_n = \\cos\\left(2\\pi \\cdot 60 \\cdot \\frac{n}{64}\\right) = \\cos\\left(2\\pi \\cdot (64-4) \\cdot \\frac{n}{64}\\right) = \\cos\\left(2\\pi n - 2\\pi \\cdot 4 \\cdot \\frac{n}{64}\\right) = \\cos\\left(2\\pi \\cdot 4 \\cdot \\frac{n}{64}\\right)$$\n因此，提供给最小二乘算法的数据看起来像是来自一个频率为 4 的信号。由于 $K'=4 \\le K_{\\text{cut}}=10$，模型将完美地拟合这个混叠信号。\n- **预测**：$\\text{MSE}_{\\text{train}}$ 将接近 $0$。学习到的模型将是 $\\hat{f}(x) \\approx \\cos(2\\pi \\cdot 4 \\cdot x)$。当在密集网格上评估时，这个低频模型将与真实的高频信号 $f_{60}(x) = \\cos(2\\pi \\cdot 60 \\cdot x)$ 进行比较。两者非常不同，因此 $\\text{MSE}_{\\text{eval}}$ 将会很大。其期望值约为 $\\int_0^1 (\\cos(2\\pi \\cdot 4x) - \\cos(2\\pi \\cdot 60x))^2 dx = \\int_0^1 \\cos^2(2\\pi \\cdot 4x) dx + \\int_0^1 \\cos^2(2\\pi \\cdot 60x) dx = \\frac{1}{2} + \\frac{1}{2} = 1$。在 $\\hat{f}(x)$ 中找到的主导频率将是混叠频率，因此 $k^{\\star}=4$。\n\n**情况 3: $(N, K, K_{\\text{cut}}) = (64, 53, 10)$**\n- **分析**：目标频率为 $K=53$，其中 $N=64$，$K_{\\text{cut}}=10$。在训练网格上的混叠频率是 $K' = |53-64| = 11$。因此，训练数据看起来像是来自一个频率为 11 的信号。然而，这个混叠频率 $K'=11$ *仍然大于* PE 截止频率 $K_{\\text{cut}}=10$。模型的基函数（频率为 $0, 1, \\ldots, 10$）无法表示它们正在被训练的频率为 11 的信号。离散傅里叶基函数在均匀网格上是正交的。对应于频率 11 的采样目标向量，与 PE 提供的所有基向量（频率 0 到 10）正交。因此，到这个基空间上的投影是零向量。\n- **预测**：最小二乘拟合将得到 $\\mathbf{w} \\approx \\mathbf{0}$，这意味着对所有 $x$ 都有 $\\hat{f}(x) \\approx 0$。训练 MSE 将是 $\\text{MSE}_{\\text{train}} = \\frac{1}{N}\\sum_{n=0}^{N-1}(0 - y_n)^2 = \\frac{1}{N}\\sum_{n=0}^{N-1}\\cos^2(2\\pi \\cdot 11 \\cdot n/N) \\approx \\frac{1}{2}$。类似地，$\\text{MSE}_{\\text{eval}} = \\frac{1}{M}\\sum_{m=0}^{M-1}(0-f_{53}(x_m))^2 \\approx \\frac{1}{2}\\int_0^1 \\cos^2(2\\pi \\cdot 53 x) dx = 0.5$。由于 $\\hat{f}(x)$ 是零函数，其 FFT 在任何地方都将为零。`argmax` 函数将返回搜索范围 $\\{1, \\ldots, \\lfloor M/2 \\rfloor\\}$ 的第一个索引，因此我们预计 $k^{\\star}=1$。\n\n**情况 4: $(N, K, K_{\\text{cut}}) = (64, 32, 32)$**\n- **分析**：目标频率 $K=32$ 正好是 $N=64$ 时的奈奎斯特频率。PE 截止频率为 $K_{\\text{cut}}=32$，因此基函数中包含了函数 $\\cos(2\\pi \\cdot 32 \\cdot x)$。在采样点 $x_n = n/64$ 处，目标值为 $y_n = \\cos(2\\pi \\cdot 32 \\cdot n/64) = \\cos(\\pi n) = (-1)^n$。这恰好是采样的奈奎斯特频率余弦基函数。需要注意的是，相应的正弦项 $\\sin(2\\pi \\cdot 32 \\cdot n/64) = \\sin(\\pi n)$ 对所有整数 $n$ 均为零，导致设计矩阵中出现一列零。这引入了秩亏损。然而，由于目标信号完全位于其余基向量的张成空间内，仍然可以实现完美拟合。`numpy.linalg.lstsq` 将正确找到解，该解会将 $\\cos(2\\pi \\cdot 32 \\cdot x)$ 项的权重设置为 1，并将所有其他权重设置为 0。\n- **预测**：模型将完美地表示目标。$\\text{MSE}_{\\text{train}}$ 和 $\\text{MSE}_{\\text{eval}}$ 都将接近 $0$。拟合模型 $\\hat{f}(x)=\\cos(2\\pi \\cdot 32 \\cdot x)$ 的主导频率将是 $k^{\\star}=32$。\n\n这些分析引出了最终答案中提供的实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of fitting a band-limited INR to a sinusoidal signal\n    under various conditions of sampling, signal frequency, and PE cutoff.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, K, K_cut)\n        (64, 4, 10),    # Happy path\n        (64, 60, 10),   # Aliasing into representable band\n        (64, 53, 10),   # Aliasing outside representable band\n        (64, 32, 32),   # Nyquist boundary case\n    ]\n    \n    # Dense evaluation grid size\n    M = 2048\n\n    all_results = []\n\n    for N, K, K_cut in test_cases:\n        # 1. Construct the training data\n        x_train = np.arange(N) / N\n        y_train = np.cos(2 * np.pi * K * x_train)\n        \n        # 2. Construct the Positional Encoding (PE) design matrix for training\n        num_features = 1 + 2 * K_cut\n        Phi_train = np.zeros((N, num_features))\n        \n        # DC component (frequency 0)\n        Phi_train[:, 0] = 1.0\n        \n        # Sinusoidal components (frequencies 1 to K_cut)\n        freqs = np.arange(1, K_cut + 1)\n        # Use broadcasting for efficient construction\n        cos_terms = np.cos(2 * np.pi * freqs[None, :] * x_train[:, None])\n        sin_terms = np.sin(2 * np.pi * freqs[None, :] * x_train[:, None])\n        \n        # Interleave cos and sin terms as per the problem definition\n        Phi_train[:, 1::2] = cos_terms\n        Phi_train[:, 2::2] = sin_terms\n        \n        # 3. Fit the model by solving the linear least squares problem\n        # w = (Phi^T Phi)^-1 Phi^T y\n        w = np.linalg.lstsq(Phi_train, y_train, rcond=None)[0]\n        \n        # 4. Compute the training MSE\n        y_hat_train = Phi_train @ w\n        mse_train = np.mean((y_hat_train - y_train) ** 2)\n        \n        # 5. Evaluate the fitted model on a dense grid\n        x_eval = np.arange(M) / M\n        y_eval_true = np.cos(2 * np.pi * K * x_eval)\n        \n        # Construct the PE design matrix for evaluation\n        Phi_eval = np.zeros((M, num_features))\n        Phi_eval[:, 0] = 1.0\n        cos_terms_eval = np.cos(2 * np.pi * freqs[None, :] * x_eval[:, None])\n        sin_terms_eval = np.sin(2 * np.pi * freqs[None, :] * x_eval[:, None])\n        Phi_eval[:, 1::2] = cos_terms_eval\n        Phi_eval[:, 2::2] = sin_terms_eval\n        \n        y_hat_eval = Phi_eval @ w\n        \n        # 6. Compute the evaluation MSE\n        mse_eval = np.mean((y_hat_eval - y_eval_true) ** 2)\n\n        # 7. Estimate the dominant frequency of the fitted model\n        # Apply FFT on the densely sampled predictions\n        fft_vals = np.fft.fft(y_hat_eval)\n        # Get magnitudes of the one-sided spectrum\n        fft_mags = np.abs(fft_vals)\n        \n        # Find the peak frequency index k* in {1, 2, ..., floor(M/2)}\n        # This corresponds to array indices 1 through M//2\n        search_range = fft_mags[1 : M//2 + 1]\n        # argmax returns 0-based index relative to the slice; add 1 for frequency\n        k_star = int(np.argmax(search_range) + 1)\n\n        # 8. Append results for the current test case\n        all_results.append(f\"{mse_train:.6f}\")\n        all_results.append(f\"{mse_eval:.6f}\")\n        all_results.append(str(k_star))\n\n    #\n    # Final print statement in the exact required format.\n    #\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3136712"}, {"introduction": "隐式表示将形状定义为一个连续函数的水平集，但我们如何将其可视化呢？本练习将让你通过应用一个阈值，将抽象的占用场（occupancy field）转变为一个具体的三维物体。通过分析生成形状的拓扑结构和几何特性，你将对单个学习到的函数如何能隐式地包含一系列潜在表面获得直观的理解。[@problem_id:3136800]", "problem": "给定一个由学习得到的占据场 $o_{\\theta}(\\mathbf{x})$ 表示的隐式二元曲面，该占据场定义在 $\\mathbb{R}^3$ 上。在阈值 $\\tau \\in (0,1)$ 下的隐式曲面是水平集 $\\{\\mathbf{x} \\in \\mathbb{R}^3 \\mid o_{\\theta}(\\mathbf{x}) = \\tau\\}$，其导出的实体是超水平集 $\\{\\mathbf{x} \\in \\mathbb{R}^3 \\mid o_{\\theta}(\\mathbf{x}) \\ge \\tau\\}$。您将研究改变阈值 $\\tau$ 如何影响在离散网格上恢复出的曲面的拓扑结构（连通分量的数量）和几何保真度（一种流形质量的代理指标）。您的程序必须从第一性原理出发构建 $o_{\\theta}(\\mathbf{x})$，并在一个固定的网格上评估所要求的指标，无需读取任何输入。\n\n从以下基本概念开始：\n- 隐式占据场是一个函数 $o_{\\theta} : \\mathbb{R}^3 \\to [0,1]$；在 $\\tau$ 处进行阈值处理，可将空间二元分类为占据和空闲。\n- 符号距离函数 (SDF) $s(\\mathbf{x})$ 在真实曲面上满足 $s(\\mathbf{x}) = 0$，在内部满足 $s(\\mathbf{x}) < 0$，在外部满足 $s(\\mathbf{x}) > 0$。\n- logistic sigmoid 函数为 $\\sigma(z) = \\dfrac{1}{1 + e^{-z}}$，logit 函数为 $\\operatorname{logit}(\\tau) = \\log\\!\\left(\\dfrac{\\tau}{1 - \\tau}\\right)$。它们互为反函数，即 $\\sigma(\\operatorname{logit}(\\tau)) = \\tau$ 和 $\\operatorname{logit}(\\sigma(z)) = z$。\n- 在具有 6-连通性的三维网格上，离散连通分量是一个占据体素的最大集合，其中集合内的任意两个体素都可以通过一条由面相邻的步长组成的路径相连。\n\n通过将 SDF 与 logistic link 函数和一个小的空间变化偏置复合来构建学习得到的占据场，以模拟学习中的不完美性。具体定义如下：\n$$\no_{\\theta}(\\mathbf{x}) \\;=\\; \\sigma\\!\\Big(-k \\, s(\\mathbf{x}) + b + n(\\mathbf{x})\\Big),\n$$\n其中刚度 $k \\in \\mathbb{R}_{>0}$，偏置 $b \\in \\mathbb{R}$。项 $n(\\mathbf{x})$ 通过以下方式模拟空间变化的拟合误差：\n$$\nn(\\mathbf{x}) \\;=\\; \\varepsilon \\,\\sin(\\omega x)\\,\\sin(\\omega y)\\,\\sin(\\omega z),\n$$\n其中 $\\varepsilon \\in \\mathbb{R}_{\\ge 0}$ 且 $\\omega \\in \\mathbb{R}_{>0}$。\n\n对 $s(\\mathbf{x})$ 使用两种形状族：\n- 单个球体，以原点为中心，半径为 $R$：$s(\\mathbf{x}) = \\|\\mathbf{x}\\|_2 - R$。\n- 两个相同半径的球体的并集，半径为 $R$，中心分别为 $\\mathbf{c}_1 = (-d/2,0,0)$ 和 $\\mathbf{c}_2 = (d/2,0,0)$：$s(\\mathbf{x}) = \\min\\!\\big(\\|\\mathbf{x}-\\mathbf{c}_1\\|_2 - R, \\|\\mathbf{x}-\\mathbf{c}_2\\|_2 - R\\big)$。\n\n忽略 $n(\\mathbf{x})$，设置 $o_{\\theta}(\\mathbf{x}) = \\tau$ 并对 logistic link 函数求逆，意味着 SDF 水平 $s(\\mathbf{x}) = \\delta(\\tau)$，其中 $\\delta(\\tau)$ 是一个依赖于 $\\tau$、$k$ 和 $b$ 的偏移量。您必须在解决方案中推导出此关系，并用它来为球体定义一个解析目标半径 $r^{\\star}(\\tau)$，即 $r^{\\star}(\\tau) = R + \\delta(\\tau)$（对于并集情况，使用相对于最近中心的半径）。这个 $r^{\\star}(\\tau)$ 提供了一个独立于采样的几何保真度参考。\n\n将域离散化为一个 $N \\times N \\times N$ 的规则网格，其中 $N = 64$，覆盖立方体 $[-1,1]^3$。对于下面指定的每个测试用例：\n- 在网格点上评估 $o_{\\theta}(\\mathbf{x})$。\n- 在 $\\tau$ 处进行阈值处理，使用超水平集条件获得二元占据体 $\\mathcal{V}_{\\tau}$。\n- 使用 6-连通性计算 $\\mathcal{V}_{\\tau}$ 的连通分量数 $C(\\tau)$。\n- 将边界体素识别为至少有一个面相邻邻居为非占据的占据体素；计算平均绝对径向偏差\n$$\nE(\\tau) \\;=\\; \\frac{1}{M}\\sum_{i=1}^{M}\\Big|\\|\\mathbf{p}_i - \\mathbf{c}(\\mathbf{p}_i)\\|_2 - r^{\\star}(\\tau)\\Big|,\n$$\n其中 $\\mathbf{p}_i$ 是第 $i$ 个边界体素中心的坐标，$\\mathbf{c}(\\mathbf{p}_i)$ 是最近的球心（对于单个球体，使用 $\\mathbf{0}$），$M$ 是边界体素的数量。如果 $M = 0$，则定义 $E(\\tau) = 0$。\n\n使用常数 $k = 16$、$b = 0$、$R = 0.35$、$\\omega = 12$ 以及双球体中心间距 $d = 0.8$。测试套件包含以下 5 个用例，每个用例由一个元组 $(\\text{shape}, \\varepsilon, \\tau)$ 描述，其中 $\\text{shape} \\in \\{1,2\\}$ 表示单个球体（1）或两个球体的并集（2）：\n- 用例 1: $(1, 0.0, 0.5)$\n- 用例 2: $(1, 0.12, 0.5)$\n- 用例 3: $(2, 0.0, 0.7)$\n- 用例 4: $(2, 0.0, 0.31)$\n- 用例 5: $(2, 0.05, 0.30)$\n\n您的程序必须：\n- 实现上述构造。\n- 对每个用例，计算 $C(\\tau)$（整数）和 $E(\\tau)$（浮点数）。\n- 将 $E(\\tau)$ 四舍五入到 4 位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，列表中的每个元素是表示单个用例结果的双元素列表 $[C(\\tau),E(\\tau)]$，所有内容都包含在方括号中。例如，包含三个用例的输出应类似于 $[[1,0.0123],[2,0.0456],[1,0.0034]]$，但需使用上述五个用例的计算值。", "solution": "该问题要求分析一个由学习得到的占据场 $o_{\\theta}(\\mathbf{x})$ 定义的隐式二元曲面。我们的任务是构建此场，在离散网格上对其进行评估，然后针对几个测试用例计算两个指标：连通分量的数量 $C(\\tau)$ 和几何保真度度量——平均绝对径向偏差 $E(\\tau)$，它们都是占据阈值 $\\tau$ 的函数。\n\n该问题定义明确，在隐式神经表示领域有科学依据，并为得到唯一的确定性解提供了所有必要的参数和定义。我们从原理推导和计算流程纲要开始。\n\n**1. 理论公式**\n\n问题的核心是占据场，定义为：\n$$\no_{\\theta}(\\mathbf{x}) \\;=\\; \\sigma\\!\\Big(-k \\, s(\\mathbf{x}) + b + n(\\mathbf{x})\\Big)\n$$\n其中 $\\sigma(z) = (1 + e^{-z})^{-1}$ 是 logistic sigmoid 函数，$s(\\mathbf{x})$ 是一个符号距离函数 (SDF)，$k$ 和 $b$ 是代表网络权重的标量参数，$n(\\mathbf{x})$ 是一个模拟学习中不完美性的空间变化噪声项。参数中选择 $-k \\, s(\\mathbf{x})$ 确保了物体内部的点（其中 $s(\\mathbf{x}) < 0$）映射到高占据值（接近 1），而外部的点（其中 $s(\\mathbf{x}) > 0$）映射到低占据值（接近 0）。\n\n问题要求推导出一个用于重建曲面的解析参考半径 $r^{\\star}(\\tau)$。这可以通过分析理想的无噪声情况（即 $n(\\mathbf{x}) = 0$）来找到。隐式曲面是水平集，其中 $o_{\\theta}(\\mathbf{x}) = \\tau$。\n$$\n\\sigma(-k \\, s(\\mathbf{x}) + b) = \\tau\n$$\n为了解出 $s(\\mathbf{x})$，我们将 sigmoid 函数的反函数——logit 函数 $\\operatorname{logit}(p) = \\log(p/(1-p))$ 应用于等式两边：\n$$\n\\operatorname{logit}(\\sigma(-k \\, s(\\mathbf{x}) + b)) = \\operatorname{logit}(\\tau)\n$$\n$$\n-k \\, s(\\mathbf{x}) + b = \\operatorname{logit}(\\tau)\n$$\n解出 $s(\\mathbf{x})$ 得到特定的 SDF 水平，我们将其表示为 $\\delta(\\tau)$，它对应于占据阈值 $\\tau$：\n$$\ns(\\mathbf{x}) = \\frac{b - \\operatorname{logit}(\\tau)}{k} = \\delta(\\tau)\n$$\n对于以原点为中心、半径为 $R$ 的单个球体，SDF 为 $s(\\mathbf{x}) = \\|\\mathbf{x}\\|_2 - R$。曲面方程变为：\n$$\n\\|\\mathbf{x}\\|_2 - R = \\delta(\\tau) \\quad \\implies \\quad \\|\\mathbf{x}\\|_2 = R + \\delta(\\tau)\n$$\n这描述了一个球体，其半径从 $R$ 偏移了 $\\delta(\\tau)$。这就定义了解析目标半径 $r^{\\star}(\\tau)$：\n$$\nr^{\\star}(\\tau) = R + \\delta(\\tau) = R + \\frac{b - \\operatorname{logit}(\\tau)}{k}\n$$\n对于两个球体的并集，这同一个 $r^{\\star}(\\tau)$ 表示每个球形分量的目标半径，从其各自的中心测量。\n\n**2. 算法实现**\n\n该问题通过离散化连续域并为每个测试用例应用一系列定义好的操作来计算求解。\n\n**步骤 1：域离散化**\n将连续域 $[-1, 1]^3$ 离散化为一个均匀的 $N \\times N \\times N$ 体素网格，其中 $N=64$。每个体素的中心 $(\\mathbf{p}_{ijk})$ 被用作评估函数的采样点。\n\n**步骤 2：生成占据体**\n对于每个由形状类型、噪声幅度 $\\varepsilon$ 和阈值 $\\tau$ 定义的测试用例，我们执行以下操作：\n- 在每个网格点上评估相应的 SDF $s(\\mathbf{x})$。对于形状 1，这是单个球体的 SDF。对于形状 2，这是两个球体并集的 SDF。\n- 在每个网格点上评估噪声场 $n(\\mathbf{x}) = \\varepsilon \\sin(\\omega x)\\sin(\\omega y)\\sin(\\omega z)$。\n- 使用给定公式在网格上计算完整的占据场 $o_{\\theta}(\\mathbf{x})$。\n- 通过对场进行阈值处理来生成二元占据体 $\\mathcal{V}_{\\tau}$：如果一个体素的占据值大于或等于 $\\tau$，则将其标记为占据（值 1），否则标记为非占据（值 0）。\n\n**步骤 3：拓扑分析 ($C(\\tau)$)**\n确定二元体积 $\\mathcal{V}_{\\tau}$ 中连通分量的数量 $C(\\tau)$。这是通过使用 3D 连通分量标记算法实现的。连通性定义为 6-连通性，意味着如果体素共享一个面，则认为它们是连通的。这通过使用 `scipy.ndimage.label` 函数和一个由 `scipy.ndimage.generate_binary_structure(3, 1)` 生成的结构化元素来实现。\n\n**步骤 4：几何保真度分析 ($E(\\tau)$)**\n预先计算的值 $r^{\\star}(\\tau)$ 作为基准真实半径。几何误差 $E(\\tau)$ 计算为边界体素的径向距离与此目标半径的平均绝对偏差。\n- **边界体素识别**：$\\mathcal{V}_{\\tau}$ 中的一个体素如果被占据且其 6 个面相邻邻居中至少有一个未被占据，则被认为是边界体素。一种计算上高效的方法是获取所有占据体素的集合，然后减去*内部*体素的集合。内部体素是指该体素本身及其所有 6-连通邻居都被占据的体素。这个集合可以通过使用二元腐蚀操作 (`scipy.ndimage.binary_erosion`) 和相同的 6-连通性结构化元素找到。\n- **误差计算**：对于每个已识别的边界体素中心 $\\mathbf{p}_i$：\n    1. 识别最近的球心 $\\mathbf{c}(\\mathbf{p}_i)$。对于单球体情况，这始终是原点 $\\mathbf{0}$。对于双球体情况，它是 $\\mathbf{p}_i$ 在欧氏距离上更接近的那个球心。\n    2. 计算径向距离 $r_i = \\|\\mathbf{p}_i - \\mathbf{c}(\\mathbf{p}_i)\\|_2$。\n    3. 计算与目标半径的绝对偏差 $|\\,r_i - r^{\\star}(\\tau)\\,|$。\n- 最终度量 $E(\\tau)$ 是所有 $M$ 个边界体素的这些偏差的算术平均值。如果没有边界体素（$M=0$），则定义 $E(\\tau)=0$。\n\n对所有五个测试用例重复此过程，并收集生成的 $[C(\\tau), E(\\tau)]$ 对，按指定格式输出。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label, generate_binary_structure, binary_erosion\n\ndef solve():\n    \"\"\"\n    Computes topological and geometric metrics for an implicit surface.\n    \"\"\"\n    # Define constants from the problem statement.\n    N = 64\n    k = 16.0\n    b = 0.0\n    R = 0.35\n    omega = 12.0\n    d = 0.8\n\n    # Set up the computational grid.\n    coords_1d = np.linspace(-1.0, 1.0, N)\n    grid_x, grid_y, grid_z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # Define the test cases.\n    test_cases = [\n        # (shape, epsilon, tau)\n        # shape=1: single sphere, shape=2: two spheres\n        (1, 0.0, 0.5),\n        (1, 0.12, 0.5),\n        (2, 0.0, 0.7),\n        (2, 0.0, 0.31),\n        (2, 0.05, 0.30)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        shape, epsilon, tau = case\n\n        # --- Step 1: Derive analytic target radius r_star ---\n        # Handle logit(tau) for tau near 0 or 1.\n        if tau == 0.0 or tau >= 1.0:\n            # According to the problem tau is in (0,1), but as a safeguard.\n            logit_tau = np.nan\n        else:\n            logit_tau = np.log(tau / (1.0 - tau))\n        \n        delta_tau = (b - logit_tau) / k\n        r_star = R + delta_tau\n\n        # --- Step 2: Evaluate the occupancy field on the grid ---\n        # SDF calculation\n        if shape == 1:\n            c1 = np.array([0.0, 0.0, 0.0])\n            centers = [c1]\n            s_xyz = np.sqrt(grid_x**2 + grid_y**2 + grid_z**2) - R\n        else:  # shape == 2\n            c1 = np.array([-d / 2, 0.0, 0.0])\n            c2 = np.array([d / 2, 0.0, 0.0])\n            centers = [c1, c2]\n            dist1 = np.sqrt((grid_x - c1[0])**2 + (grid_y - c1[1])**2 + (grid_z - c1[2])**2) - R\n            dist2 = np.sqrt((grid_x - c2[0])**2 + (grid_y - c2[1])**2 + (grid_z - c2[2])**2) - R\n            s_xyz = np.minimum(dist1, dist2)\n        \n        # Noise field\n        n_xyz = epsilon * np.sin(omega * grid_x) * np.sin(omega * grid_y) * np.sin(omega * grid_z)\n        \n        # Occupancy field (sigmoid)\n        z_arg = -k * s_xyz + b + n_xyz\n        o_xyz = 1.0 / (1.0 + np.exp(-z_arg))\n        \n        # Threshold to get the binary occupancy volume\n        occupancy_volume = o_xyz >= tau\n\n        # --- Step 3: Compute number of connected components C(tau) ---\n        if not np.any(occupancy_volume):\n            C_tau = 0\n        else:\n            # 6-connectivity for 3D\n            structure = generate_binary_structure(3, 1)\n            _, C_tau = label(occupancy_volume, structure=structure)\n\n        # --- Step 4: Compute mean absolute radial deviation E(tau) ---\n        # Identify boundary voxels using erosion\n        structure = generate_binary_structure(3, 1)\n        eroded_volume = binary_erosion(occupancy_volume, structure=structure)\n        boundary_voxels_mask = occupancy_volume  ~eroded_volume\n\n        boundary_indices = np.argwhere(boundary_voxels_mask)\n        M = len(boundary_indices)\n\n        if M == 0:\n            E_tau = 0.0\n        else:\n            # Convert voxel indices to world coordinates\n            boundary_coords = -1.0 + boundary_indices * (2.0 / (N - 1))\n            \n            total_abs_dev = 0.0\n            for p_i in boundary_coords:\n                # Find the nearest sphere center\n                if shape == 1:\n                    nearest_center = centers[0]\n                else:\n                    dist_to_c1 = np.linalg.norm(p_i - centers[0])\n                    dist_to_c2 = np.linalg.norm(p_i - centers[1])\n                    if dist_to_c1  dist_to_c2:\n                        nearest_center = centers[0]\n                    else:\n                        nearest_center = centers[1]\n                \n                # Calculate deviation for this boundary point\n                radial_dist = np.linalg.norm(p_i - nearest_center)\n                abs_dev = np.abs(radial_dist - r_star)\n                total_abs_dev += abs_dev\n            \n            E_tau = total_abs_dev / M\n        \n        # Store the results for the current case\n        results.append([C_tau, round(E_tau, 4)])\n\n    # Format the final output string.\n    # e.g., [[1,0.0123],[2,0.0456]]\n    result_str = \",\".join([f\"[{c},{e}]\" for c, e in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3136800"}, {"introduction": "神经渲染的质量不仅仅取决于模型架构，它还深度依赖于输入数据的质量。这个实践将抽象的模型与多视角摄影的物理世界联系起来。通过分析相机基线与重建误差之间的关系，你将学会构建简单的预测模型来指导数据采集，并理解三维重建中的基本权衡。[@problem_id:3136704]", "problem": "您正在研究相机基线对隐式神经表示（特别是一种神经辐射场，NeRF）重建质量的影响。目标是形式化地描述相机基线如何影响期望训练误差，并计算达到目标误差阈值所需的最小基线。您的程序必须拟合一条关联相机基线与重建误差的曲线，并使用该拟合曲线来推断几种测试场景下的最小基线要求。\n\n从针孔相机模型和多视图几何出发，使用以下基本且被广泛接受的事实作为您的推导基础：\n- 对于焦距为 $f$、基线为 $B$ 的双相机系统，某点的深度 $Z$ 与视差 $d$ 通过针孔关系式关联：$$Z = \\frac{f B}{d}.$$\n- 将微小的视差噪声 $\\sigma_d$ 通过上述关系式进行传播，会产生由下式决定的深度不确定性：$$\\sigma_Z = \\left|\\frac{\\partial Z}{\\partial d}\\right|\\sigma_d = \\frac{Z^2}{f B}\\,\\sigma_d.$$\n- 在神经辐射场 (NeRF) 这类隐式神经表示的训练中，光度误差（例如均方误差 MSE）会受到几何配准误差的影响。在小误差假设下，对适当的场景分布进行平均后，由沿射线的深度不确定性引起的期望光度误差贡献与 $\\sigma_Z$ 呈线性关系，同时由于模型偏差、遮挡、反射复杂性以及与几何无关的传感器噪声，会存在一个非零的误差下限。\n\n使用上述基础，并且不在问题陈述中引入任何捷径公式，推导期望重建误差 $E(B)$ 作为基线 $B$ 的函数的参数化函数形式，其中包含可从数据中拟合的未知非负参数。然后，给定在不同基线下测得的误差样本，拟合您模型的参数。最后，对于一个指定的目标误差阈值 $\\tau$，推断出最小基线 $B_{\\min}$，使得拟合模型预测 $E(B_{\\min}) \\le \\tau$。如果目标阈值比拟合的误差下限更严格，则该要求无法满足；在这种情况下，报告一个不可行的结果。\n\n所有基线必须以米为单位表示。所有误差值均为均方误差 (MSE) 且无单位。此问题不涉及角度，因此不需要角度单位。\n\n您的程序必须：\n- 从所提供的原理中推导出 $E(B)$ 的函数依赖关系。\n- 使用带参数非负约束的非线性最小二乘法来拟合未知参数。\n- 对每个测试用例，计算满足拟合模型参数不等式的最小基线 $$B_{\\min}$$（以米为单位）。\n- 如果目标阈值 $\\tau$ 因小于拟合的误差下限而无法实现，则输出一个表示不可行的结果。\n\n测试套件：\n为以下测试用例提供最小基线。每个测试用例包括相机基线和测量的误差：\n\n1. 理想情况：中等基线和可实现的目标：\n   - 基线（米）：$[0.05, 0.08, 0.12, 0.20, 0.30]$\n   - 测量误差（MSE）：$[0.134, 0.091, 0.066, 0.047, 0.036]$\n   - 目标阈值：$\\tau = 0.040$\n\n2. 近距离视图：小基线和宽松的目标：\n   - 基线（米）：$[0.02, 0.04, 0.06, 0.08]$\n   - 测量误差（MSE）：$[0.158, 0.086, 0.061, 0.046]$\n   - 目标阈值：$\\tau = 0.070$\n\n3. 较大基线接近误差下限，目标更严格：\n   - 基线（米）：$[0.10, 0.20, 0.40]$\n   - 测量误差（MSE）：$[0.061, 0.041, 0.031]$\n   - 目标阈值：$\\tau = 0.028$\n\n4. 极严格的目标，可能不可行：\n   - 基线（米）：$[0.10, 0.15, 0.25, 0.50]$\n   - 测量误差（MSE）：$[0.067, 0.052, 0.042, 0.034]$\n   - 目标阈值：$\\tau = 0.020$\n\n答案规范：\n- 对于每个测试用例，输出推断出的最小基线 $B_{\\min}$（以米为单位），四舍五入到三位有效数字。如果不可行，则输出浮点数 $+\\infty$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $$[B_{\\min,1}, B_{\\min,2}, B_{\\min,3}, B_{\\min,4}].$$", "solution": "此问题经评估有效。它在科学上基于多视图几何的原理，问题设定良好，目标明确，数据充分，且没有主观或含糊不清的语言。解法如下。\n\n### 误差模型的推导\n\n目标是推导期望重建误差 $E(B)$ 作为相机基线 $B$ 的函数形式。该推导基于所提供的原理。\n\n1.  **深度不确定性**：问题指出，深度不确定性 $\\sigma_Z$ 与相机基线 $B$、焦距 $f$、场景深度 $Z$ 和视差测量噪声 $\\sigma_d$ 通过以下公式相关：\n    $$ \\sigma_Z = \\frac{Z^2}{f B}\\,\\sigma_d $$\n    在这里，$B$ 是我们关注的变量。其他量（$Z$、$f$、$\\sigma_d$）取决于场景结构、相机内参和图像特征质量，但与基线 $B$ 无关。\n\n2.  **光度误差贡献**：问题假定期望光度误差 $E$ 由两个部分组成。\n    -   一个与几何相关的分量，我们称之为 $E_g$，它“在对适当的场景分布进行平均后，与 $\\sigma_Z$ 呈线性关系”。这可以表示为 $E_g \\propto \\sigma_Z$。引入一个正常数 $k$，我们得到 $E_g = k \\sigma_Z$。\n    -   一个误差下限，我们称之为 $C$，它“与几何无关”。因此，该项与基线 $B$ 无关。\n\n3.  **函数形式**：结合这些事实，总期望误差 $E(B)$ 是这两个分量的和：\n    $$ E(B) = E_g(B) + C $$\n    代入 $E_g$ 和 $\\sigma_Z$ 的表达式：\n    $$ E(B) = k \\left( \\frac{Z^2 \\sigma_d}{f B} \\right) + C $$\n    问题指明，这种关系“在对适当的场景分布进行平均后”成立。因此，我们可以将所有不依赖于 $B$ 的项聚合成一个单一的非负参数 $A$。\n    令 $A = \\langle k \\frac{Z^2 \\sigma_d}{f} \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示对场景和观测统计数据进行平均。由于 $k$、$Z^2$、$\\sigma_d$ 和 $f$ 都是非负量，因此所得参数 $A$ 也必须是非负的，即 $A \\ge 0$。误差下限 $C$ 作为一个均方误差，也必须是非负的，即 $C \\ge 0$。\n    这就得出了期望重建误差的最终参数化函数形式：\n    $$ E(B) = \\frac{A}{B} + C $$\n\n### 参数拟合\n\n对于每个测试用例，我们都有一组在相应基线 $B_i$ 下测得的误差 $E_i$。我们推导出的模型 $E(B) = \\frac{A}{B} + C$ 中的未知参数 $A$ 和 $C$ 必须根据这些数据来确定。我们使用非线性最小二乘法来找到最能拟合数据的 $A$ 和 $C$ 的值。这涉及最小化残差平方和 $S(A, C)$：\n$$ S(A, C) = \\sum_{i} \\left( E_i - \\left(\\frac{A}{B_i} + C\\right) \\right)^2 $$\n此优化在非负约束 $A \\ge 0$ 和 $C \\ge 0$ 的条件下进行。\n\n### 最小基线计算\n\n一旦为模型 $E(B) = \\frac{\\hat{A}}{B} + \\hat{C}$ 拟合出参数 $\\hat{A}$ 和 $\\hat{C}$，我们必须找到达到目标误差阈值 $\\tau$ 的最小基线 $B_{\\min}$。这是满足以下条件的最小 $B  0$：\n$$ E(B) \\le \\tau $$\n$$ \\frac{\\hat{A}}{B} + \\hat{C} \\le \\tau $$\n\n首先，我们分析可行性。对于 $\\hat{A}  0$ 的情况，函数 $E(B)$ 随 $B$ 的增加而单调递减。当 $B \\to \\infty$ 时，误差趋近于其可能的最小值，即误差下限 $\\hat{C}$。因此，如果目标阈值 $\\tau$ 小于这个下限（即 $\\tau  \\hat{C}$），则不可能满足条件。当 $\\tau = \\hat{C}$ 时，需要无限大的基线才能达到（对于 $\\hat{A}  0$）。因此，如果 $\\tau \\le \\hat{C}$，任务不可行，结果为 $B_{\\min} = +\\infty$。\n\n如果任务可行（$\\tau  \\hat{C}$），我们可以求解 $B_{\\min}$。为了找到*最小*基线，我们求解等式，因为任何更小的基线都会产生更高的误差：\n$$ \\frac{\\hat{A}}{B_{\\min}} + \\hat{C} = \\tau $$\n重新整理各项以求解 $B_{\\min}$：\n$$ \\frac{\\hat{A}}{B_{\\min}} = \\tau - \\hat{C} $$\n$$ B_{\\min} = \\frac{\\hat{A}}{\\tau - \\hat{C}} $$\n此公式将应用于每个测试用例，使用其专门拟合的参数 $\\hat{A}$ 和 $\\hat{C}$ 以及其目标 $\\tau$。每个用例的最终结果将四舍五入到三位有效数字。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Solves for the minimal baseline required to meet an error threshold for a NeRF reconstruction.\n    \n    The process involves:\n    1. Defining an error model E(B) = A/B + C based on first principles.\n    2. Fitting parameters A and C to measured data points (B_i, E_i) using nonlinear least squares.\n    3. Solving for the minimal baseline B_min such that E(B_min) = tau.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"baselines\": np.array([0.05, 0.08, 0.12, 0.20, 0.30]),\n            \"errors\": np.array([0.134, 0.091, 0.066, 0.047, 0.036]),\n            \"tau\": 0.040,\n        },\n        {\n            \"baselines\": np.array([0.02, 0.04, 0.06, 0.08]),\n            \"errors\": np.array([0.158, 0.086, 0.061, 0.046]),\n            \"tau\": 0.070,\n        },\n        {\n            \"baselines\": np.array([0.10, 0.20, 0.40]),\n            \"errors\": np.array([0.061, 0.041, 0.031]),\n            \"tau\": 0.028,\n        },\n        {\n            \"baselines\": np.array([0.10, 0.15, 0.25, 0.50]),\n            \"errors\": np.array([0.067, 0.052, 0.042, 0.034]),\n            \"tau\": 0.020,\n        },\n    ]\n\n    def error_model(B, A, C):\n        \"\"\" The derived functional form for error E as a function of baseline B. \"\"\"\n        return A / B + C\n\n    def format_to_3sf(value):\n        \"\"\" Rounds a float to three significant figures, handling infinity. \"\"\"\n        if np.isinf(value):\n            return float('inf')\n        if value == 0:\n            return 0.0\n        return float(f\"{value:.3g}\")\n\n    results = []\n    for case in test_cases:\n        baselines = case[\"baselines\"]\n        errors = case[\"errors\"]\n        tau = case[\"tau\"]\n\n        # Fit the model E(B) = A/B + C using nonlinear least squares\n        # with non-negativity constraints on A and C.\n        try:\n            popt, _ = curve_fit(\n                error_model,\n                baselines,\n                errors,\n                bounds=([0, 0], [np.inf, np.inf])\n            )\n        except RuntimeError:\n            # In case the fitting algorithm fails, which is unlikely for this model.\n            results.append(float('inf'))\n            continue\n            \n        A_fit, C_fit = popt\n\n        # Check for feasibility. If the target error is lower than or equal to\n        # the asymptotic error floor C, it's impossible to achieve.\n        if tau = C_fit:\n            B_min = float('inf')\n        else:\n            # If feasible, calculate the minimal baseline.\n            B_min = A_fit / (tau - C_fit)\n        \n        # Format result to 3 significant figures.\n        formatted_result = format_to_3sf(B_min)\n        results.append(formatted_result)\n\n    # Print the final output in the specified format. The `str` representation\n    # of float('inf') is 'inf', which is the required output.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3136704"}]}