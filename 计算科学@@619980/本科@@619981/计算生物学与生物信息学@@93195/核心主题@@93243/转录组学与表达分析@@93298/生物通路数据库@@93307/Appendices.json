{"hands_on_practices": [{"introduction": "生物通路不仅仅是基因和分子的静态地图，它们本质上是细胞新陈代谢经济的蓝图。这项练习将指导你执行一项基本任务：从通路数据库（如KEGG）中提取定量信息来计算生物合成过程的能量成本。通过追踪从前体到最终产物所需的 ATP 当量，你将学会如何将抽象的通路图转化为具体的、可衡量的代谢成本分析，这是理解细胞生理学和代谢工程的核心技能。", "problem": "一位研究人员使用京都基因与基因组百科全书 (KEGG) 的嘌呤代谢途径来计算一种细菌中从头合成鸟苷三磷酸 (GTP) 的能量成本。从5-磷酸核糖 (R5P) 开始，生物合成路线经过磷酸核糖焦磷酸 (PRPP)、次黄嘌呤核苷一磷酸 (IMP)、鸟苷一磷酸 (GMP)、鸟苷二磷酸 (GDP)，最终生成GTP。假设以下标准化学计量特征，与 KEGG 整理的细菌途径一致，并且所有激酶的磷酸供体均为三磷酸腺苷 (ATP)：\n\n- R5P 到 PRPP：PRPP 合成酶使用 ATP 生成一磷酸腺苷 (AMP)，计为 2 个 ATP 当量。\n- PRPP 到 IMP：需要 ATP 的步骤是甘氨酰胺核糖核苷酸 (GAR) 合成酶、甲酰甘氨脒核糖核苷酸 (FGAM) 合成酶、5-氨基咪唑核糖核苷酸 (AIR) 合成酶、$\\text{N}^5$-羧基氨基咪唑核糖核苷酸 ($\\text{N}^5$-CAIR) 合成酶和琥珀酰氨基咪唑甲酰胺核糖核苷酸 (SAICAR) 合成酶。这些步骤中的每一步都将 ATP 转化为二磷酸腺苷 (ADP)，计为 1 个 ATP 当量。\n- IMP 到 GMP：次黄嘌呤核苷一磷酸脱氢酶使用烟酰胺腺嘌呤二核苷酸 ($\\text{NAD}^+$)，无 ATP 成本；鸟苷一磷酸合成酶使用 ATP 生成 AMP，计为 2 个 ATP 当量。\n- GMP 到 GDP：鸟苷酸激酶将 ATP 转化为 ADP，计为 1 个 ATP 当量。\n- GDP 到 GTP：核苷二磷酸激酶将 ATP 转化为 ADP，计为 1 个 ATP 当量。\n\n将每次 ATP 到 ADP 的转化计为 1 个 ATP 当量，每次 ATP 到 AMP 的转化计为 2 个 ATP 当量。忽略无机焦磷酸酶的任何能量贡献以及四氢叶酸或 $\\text{NAD}^+$ 等辅因子的再生成本。在这些假设下，从 R5P 开始合成一个 GTP 分子需要的 ATP 当量总数是多少？以无单位的单个整数形式提供您的答案。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **过程：** 从5-磷酸核糖 (R5P) 从头合成鸟苷三磷酸 (GTP)。\n- **途径：** R5P $\\rightarrow$ PRPP $\\rightarrow$ IMP $\\rightarrow$ GMP $\\rightarrow$ GDP $\\rightarrow$ GTP。\n- **起始物质：** $1$ 个5-磷酸核糖 (R5P) 分子。\n- **最终产物：** $1$ 个鸟苷三磷酸 (GTP) 分子。\n- **成本定义：**\n    - 三磷酸腺苷 (ATP) 到二磷酸腺苷 (ADP) 的转化：$1$ 个ATP当量。\n    - ATP 到一磷酸腺苷 (AMP) 的转化：$2$ 个ATP当量。\n- **具体步骤成本：**\n    - **R5P 到 PRPP：** $1$ 个反应（PRPP合成酶）将 ATP 转化为 AMP，成本为 $2$ 个 ATP 当量。\n    - **PRPP 到 IMP：** $5$ 个不同的酶促步骤（GAR合成酶、FGAM合成酶、AIR合成酶、$\\text{N}^5$-CAIR合成酶、SAICAR合成酶），每个步骤都将 ATP 转化为 ADP，每步成本为 $1$ 个 ATP 当量。\n    - **IMP 到 GMP：** $1$ 个反应（GMP合成酶）将 ATP 转化为 AMP，成本为 $2$ 个 ATP 当量。另一个步骤（IMPDH）没有ATP成本。\n    - **GMP 到 GDP：** $1$ 个反应（鸟苷酸激酶）将 ATP 转化为 ADP，成本为 $1$ 个 ATP 当量。\n    - **GDP 到 GTP：** $1$ 个反应（核苷二磷酸激酶）将 ATP 转化为 ADP，成本为 $1$ 个 ATP 当量。\n- **排除项：** 忽略无机焦磷酸酶的能量贡献以及辅因子（例如 $\\text{NAD}^+$）的再生成本。\n\n**步骤2：使用提取的已知条件进行验证**\n根据既定标准对问题进行评估。\n- **科学依据：** 问题描述了典型的嘌呤从头合成途径，这是生物化学和计算生物学中的一个基本课题。所指定的酶、中间体以及计算 ATP 当量的惯例（其中 ATP $\\rightarrow$ AMP 成本为 $2$ 是因为 AMP 随后被磷酸化为 ADP）都是科学上合理且标准的。\n- **定义明确：** 问题提供了一个明确的起点 (R5P)、一个明确的终点 (GTP)，以及所有相关耗能步骤及其具体成本的详尽列表。问题明确，要求一个单一的可计算量。\n- **客观性：** 问题使用精确、客观的科学术语陈述。没有主观或隐喻的元素。\n\n**步骤3：结论和行动**\n问题被判定为**有效**。它在科学上是合理的，定义明确，客观，并包含唯一解所需的所有必要信息。可以开始求解过程。\n\n以三磷酸腺苷 (ATP) 当量计算的总能量成本是指定生物合成途径中每个阶段成本的总和。设 $C_{total}$ 为 ATP 当量的总数。我们可以将其表示为途径中每个部分成本的总和：\n\n$$\nC_{total} = C_{R5P \\rightarrow PRPP} + C_{PRPP \\rightarrow IMP} + C_{IMP \\rightarrow GMP} + C_{GMP \\rightarrow GDP} + C_{GDP \\rightarrow GTP}\n$$\n\n现在我们根据所提供的数据计算每个部分的成本。\n\n1.  **将 R5P 转化为 PRPP 的成本 ($C_{R5P \\rightarrow PRPP}$):**\n    从5-磷酸核糖 (R5P) 合成磷酸核糖焦磷酸 (PRPP) 的过程由 PRPP 合成酶催化。该反应将一个 ATP 分子转化为 AMP。根据问题陈述，这需要消耗 $2$ 个 ATP 当量。\n    $$\n    C_{R5P \\rightarrow PRPP} = 2\n    $$\n\n2.  **将 PRPP 转化为 IMP 的成本 ($C_{PRPP \\rightarrow IMP}$):**\n    该途径的这一部分涉及多个步骤。问题明确列出了五个需要 ATP 的酶促反应，每个反应都将 ATP 转化为 ADP。每次此类转化消耗 $1$ 个 ATP 当量。\n    - GAR合成酶：$1$ 个ATP当量。\n    - FGAM合成酶：$1$ 个ATP当量。\n    - AIR合成酶：$1$ 个ATP当量。\n    - $\\text{N}^5$-CAIR合成酶：$1$ 个ATP当量。\n    - SAICAR合成酶：$1$ 个ATP当量。\n    这一部分的总成本是这些单个成本的总和。\n    $$\n    C_{PRPP \\rightarrow IMP} = 1 + 1 + 1 + 1 + 1 = 5\n    $$\n\n3.  **将 IMP 转化为 GMP 的成本 ($C_{IMP \\rightarrow GMP}$):**\n    这一转化涉及两个酶促步骤。第一步由次黄嘌呤核苷一磷酸脱氢酶催化，使用 $\\text{NAD}^+$，没有相关的 ATP 成本。第二步由鸟苷一磷酸合成酶催化，将 ATP 转化为 AMP。这被定义为消耗 $2$ 个 ATP 当量。\n    $$\n    C_{IMP \\rightarrow GMP} = 2\n    $$\n\n4.  **将 GMP 转化为 GDP 的成本 ($C_{GMP \\rightarrow GDP}$):**\n    这一磷酸化过程由鸟苷酸激酶催化。该反应将一个 ATP 分子转化为 ADP，消耗 $1$ 个 ATP 当量。\n    $$\n    C_{GMP \\rightarrow GDP} = 1\n    $$\n\n5.  **将 GDP 转化为 GTP 的成本 ($C_{GDP \\rightarrow GTP}$):**\n    最后的磷酸化过程由核苷二磷酸激酶催化。该反应同样将一个 ATP 分子转化为 ADP，消耗 $1$ 个 ATP 当量。\n    $$\n    C_{GDP \\rightarrow GTP} = 1\n    $$\n\n最后，我们将所有部分的成本相加，得到总成本 $C_{total}$：\n$$\nC_{total} = 2 + 5 + 2 + 1 + 1\n$$\n$$\nC_{total} = 11\n$$\n因此，在给定的假设下，从 R5P 合成一个 GTP 分子总共需要 $11$ 个 ATP 当量。", "answer": "$$\\boxed{11}$$", "id": "2375344"}, {"introduction": "在学习了如何进行静态成本核算之后，我们现在将难度提升到模拟一个动态过程。这项练习要求你编写一个程序，追踪一个被标记的碳原子在糖酵解途径中的旅程，这模仿了现实世界中的同位素标记实验。通过将已知的酶促反应机理转化为算法逻辑，你将掌握原子映射 (atom mapping) 的核心概念，这对于理解详细的代谢转换和解释同位素示踪数据至关重要。", "problem": "要求您实现一个完整、可运行的程序，该程序根据 Kyoto Encyclopedia of Genes and Genomes (KEGG) 中整理的数据，对糖酵解途径的核心反应进行单原子示踪。目标是利用第一性原理的原子守恒和成熟的、反应特异性的原子映射，追踪一个从葡萄糖到丙酮酸的标记碳原子，并计算该标记原子在丙酮酸中的最终碳索引。\n\n基本原理：\n- 生物化学反应中的原子守恒指出，原子既不被创造也不被消灭；它们的身份可以在整个反应过程中被追踪。\n- 糖酵解将一个含有 $6$ 个碳原子的葡萄糖分子转化为两个各含有 $3$ 个碳原子的丙酮酸分子。\n- 早期的磷酸化和异构化步骤（葡萄糖到 6-磷酸葡萄糖到 6-磷酸果糖到 1,6-二磷酸果糖）不会破坏碳骨架；因此，随每个碳原子移动的骨架索引在这些步骤中得以保留。\n- Aldolase 在碳 $3$ 和碳 $4$ 之间裂解 1,6-二磷酸果糖，形成两种三碳糖：磷酸二羟丙酮 (DHAP) 接收对应于骨架位置 $1$ 到 $3$ 的片段，而 3-磷酸甘油醛 (GAP) 接收对应于骨架位置 $4$ 到 $6$ 的片段。\n- Triose Phosphate Isomerase (TPI) 通过交换末端碳原子，同时保持中心碳原子不变，将 DHAP 转化为 GAP，即，在三碳片段内的碳原子映射为 $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$。\n- 糖酵解的后半部分（GAP 到 1,3-二磷酸甘油酸到 3-磷酸甘油酸到 2-磷酸甘油酸到磷酸烯醇式丙酮酸到丙酮酸）保留了三碳骨架的顺序，因此从 GAP 碳索引到丙酮酸碳索引的映射是恒等映射：$1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n\n表示方法：\n- 用从 $1$ 到 $6$ 的有序索引表示葡萄糖碳骨架，这些索引随每个碳原子在途径中移动。\n- 对于 Aldolase 裂解，将两种三碳糖表示为独立的有序片段：DHAP 接收索引 $1,2,3$（来自葡萄糖位置 $1,2,3$），GAP 接收索引 $1,2,3$（来自葡萄糖位置 $4,5,6$）。\n- 对 DHAP 片段应用 TPI 映射 $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$，将其转换为 GAP 坐标。\n- 应用从 GAP 到丙酮酸的恒等映射：$1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n\n计算任务：\n- 实现一个函数，它接受一个整数 $g$ 代表葡萄糖中标记碳的索引（$g \\in \\{1,2,3,4,5,6\\}$），并返回该标记原子在其三碳糖分支生成的丙酮酸中的最终整数碳索引 $p \\in \\{1,2,3\\}$。如果 $g$ 不在有效范围内，则返回 $-1$。\n- 必须通过组合上述分步映射来计算该映射；不要在代码中未展示中间逻辑的情况下硬编码最终配对。\n- 该问题的输出不涉及物理单位。\n- 该问题不涉及角度。\n- 该问题不涉及百分比。\n\n测试套件：\n您的程序必须在以下标记葡萄糖位置上评估该函数：\n- 覆盖所有有效位置的正常路径：$[1,2,3,4,5,6]$。\n- 边缘情况：无效标签 $0$ 和 $7$。\n\n答案规格：\n- 对于每个输入标签 $g$，输出一个单一的整数结果：$p \\in \\{1,2,3\\}$，如果无效则为 $-1$。\n- 您的程序应该生成单行输出，其中包含按完整测试套件 $[1,2,3,4,5,6,0,7]$ 输入顺序排列的结果，结果为逗号分隔的列表，并用方括号括起来（例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$）。", "solution": "对问题陈述进行严格验证。\n\n步骤 1：提取已知条件\n- **目标**：根据 KEGG 的数据，实现一个程序，用于在糖酵解核心反应（葡萄糖到丙酮酸）中进行单原子示踪。\n- **基本原理**：\n    - 原子守恒。\n    - 糖酵解将一个 $6$ 碳的葡萄糖转化为两个 $3$ 碳的丙酮酸分子。\n    - 葡萄糖骨架在 fructose-$1,6$-bisphosphate (FBP) 之前保持完整。\n    - Aldolase 在碳 $3$ 和 $4$ 之间裂解 FBP。\n    - 磷酸二羟丙酮 (DHAP) 由 FBP 的碳 $1, 2, 3$ 形成。\n    - 3-磷酸甘油醛 (GAP) 由 FBP 的碳 $4, 5, 6$ 形成。\n    - Triose Phosphate Isomerase (TPI) 将 DHAP 转化为 GAP，在三碳片段内有特定的碳映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$。\n    - 糖酵解的后半部分（GAP 到丙酮酸）保留了碳骨架的顺序，采用恒等映射：$1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n- **表示方法**：\n    - 葡萄糖的碳原子索引为 $1$ 到 $6$。\n    - DHAP 片段从葡萄糖位置 $1, 2, 3$ 接收局部索引 $1, 2, 3$。\n    - GAP 片段从葡萄糖位置 $4, 5, 6$ 接收局部索引 $1, 2, 3$。\n    - TPI 映射应用于源自 DHAP 的片段。\n    - GAP 到丙酮酸的映射是恒等映射。\n- **计算任务**：\n    - 编写一个函数，它接受一个葡萄糖碳索引 $g \\in \\{1, 2, 3, 4, 5, 6\\}$，并返回相应的丙酮酸碳索引 $p \\in \\{1, 2, 3\\}$。\n    - 如果 $g$ 超出有效范围，则返回 $-1$。\n    - 实现必须组合分步映射。\n- **测试套件**：\n    - 输入标签：$[1, 2, 3, 4, 5, 6, 0, 7]$。\n- **输出格式**：\n    - 单行输出，包含用逗号分隔并用方括号括起来的整数结果列表。\n\n步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题。\n- **有科学依据**：该问题描述了一个简化但正确的糖酵解中碳原子命运的模型。Aldolase 裂解位点和 Triose Phosphate Isomerase 的作用是生物化学中的标准概念。所提供的原子映射是该代谢途径的公认教科书表示法。该问题牢固地基于科学原理。\n- **良构的**：该问题是良构的。它有一个明确定义的输入集 ($g \\in \\mathbb{Z}$)，一个指定的转换逻辑，以及一个精确定义的输出格式 ($p \\in \\{1, 2, 3\\}$ 或 $-1$)。对于每个有效的输入 $g$，所描述的转换序列都会产生一个独特的、有意义的结果。\n- **客观性**：问题使用客观的技术语言表述。没有主观或基于观点的陈述。原子映射的规则是明确且无歧义的。\n\n该问题没有任何无效性缺陷。它在科学上是合理的、可形式化的、完整的、可行的和结构良好的。\n\n步骤 3：结论与行动\n问题是**有效的**。将构建一个解决方案。\n\n解决方案推导\n任务是实现一个函数，我们称之为 $f(g)$，它将一个初始的葡萄糖碳索引 $g$ 映射到一个最终的丙酮酸碳索引 $p$。有效输入的域是 $g \\in \\{1, 2, 3, 4, 5, 6\\}$。对于此集合之外的任何 $g$，函数必须返回 $-1$。\n\n该途径由不同的阶段组成，每个阶段对应一个数学映射。我们将组合这些映射以找到最终结果。\n\n1.  **输入验证**：第一步是检查输入 $g$ 是否有效。\n    $$\n    f(g) = -1 \\quad \\text{if } g \\notin \\{1, 2, 3, 4, 5, 6\\}\n    $$\n\n2.  **Aldolase 裂解**：葡萄糖（$6$C）的衍生物，fructose-$1,6$-bisphosphate，被裂解成两个磷酸三碳糖（$3$C）。标记碳的命运取决于其初始位置。\n    - 如果 $g \\in \\{1, 2, 3\\}$，该原子成为磷酸二羟丙酮 (DHAP) 分子的一部分。在这个 $3$ 碳片段内的局部索引被保留。让我们将局部索引表示为 $i_{local}$。\n      $$\n      i_{local} = g \\quad \\text{for } g \\in \\{1, 2, 3\\}\n      $$\n    - 如果 $g \\in \\{4, 5, 6\\}$，该原子成为 3-磷酸甘油醛 (GAP) 分子的一部分。局部索引是相对于该片段的起始位置（葡萄糖的碳 $4$）。\n      $$\n      i_{local} = g - 3 \\quad \\text{for } g \\in \\{4, 5, 6\\}\n      $$\n\n3.  **Triose Phosphate Isomerase (TPI) 作用**：所有进入糖酵解后半部分的碳都必须是 GAP 的形式。由葡萄糖的碳 $1,2,3$ 形成的 DHAP 被异构化为 GAP。这一步涉及碳的重新排序。直接由葡萄糖的碳 $4,5,6$ 形成的 GAP 无需异构化即可继续进行。让我们将统一的 GAP 池中的索引定义为 $i_{GAP}$。\n    - 对于源自 DHAP 的原子 ($g \\in \\{1, 2, 3\\}$)，我们对其局部索引 $i_{local}$ 应用 TPI 映射 $M_{TPI}$：\n      $$\n      M_{TPI}(i) =\n      \\begin{cases}\n        3 & \\text{if } i = 1 \\\\\n        2 & \\text{if } i = 2 \\\\\n        1 & \\text{if } i = 3\n      \\end{cases}\n      $$\n      因此，对于 $g \\in \\{1, 2, 3\\}$，在生成的 GAP 分子中的索引是：\n      $$\n      i_{GAP} = M_{TPI}(i_{local}) = M_{TPI}(g)\n      $$\n    - 对于源自第一个 GAP 分子的原子 ($g \\in \\{4, 5, 6\\}$)，没有发生异构化。索引保持不变。\n      $$\n      i_{GAP} = i_{local} = g - 3\n      $$\n\n4.  **糖酵解后半段（GAP 到丙酮酸）**：从 GAP 到丙酮酸的最终反应序列保留了碳骨架的顺序。这对应于一个恒等映射，$M_{final}(i) = i$。因此，最终的丙酮酸碳索引 $p$ 等于索引 $i_{GAP}$。\n    $$\n    p = i_{GAP}\n    $$\n\n通过组合这些步骤，我们可以构建完整的函数 $f(g)$：\n- **情况 1**：$g \\in \\{1, 2, 3\\}$ (DHAP 分支)\n  $p = f(g) = M_{TPI}(g)$。这得出：\n  - $f(1) = M_{TPI}(1) = 3$\n  - $f(2) = M_{TPI}(2) = 2$\n  - $f(3) = M_{TPI}(3) = 1$\n- **情况 2**：$g \\in \\{4, 5, 6\\}$ (GAP 分支)\n  $p = f(g) = g - 3$。这得出：\n  - $f(4) = 4 - 3 = 1$\n  - $f(5) = 5 - 3 = 2$\n  - $f(6) = 6 - 3 = 3$\n\n实现将遵循这种基于情况的逻辑，它直接反映了所描述的生物化学途径的分支特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed or permitted.\n\ndef solve():\n    \"\"\"\n    Solves the glycolysis carbon tracing problem for a given test suite.\n    \"\"\"\n\n    def trace_carbon_atom(g: int) -> int:\n        \"\"\"\n        Traces a labeled carbon atom from glucose to pyruvate.\n\n        This function implements the stepwise atom mapping for the core glycolysis pathway\n        as described in the problem statement. The logic explicitly follows the fate\n        of the carbon atom through the key reaction steps.\n\n        Args:\n            g: The initial 1-based index of the labeled carbon atom in glucose.\n\n        Returns:\n            The final 1-based index of the labeled atom in a pyruvate molecule,\n            or -1 if the input glucose index is invalid.\n        \"\"\"\n        # Step 1: Input validation. Glucose has 6 carbons, indexed 1 through 6.\n        if not (1 <= g <= 6):\n            return -1\n\n        # Step 2: Aldolase cleavage of Fructose-1,6-bisphosphate.\n        # This step determines which triose phosphate receives the labeled carbon.\n        if 1 <= g <= 3:\n            # Carbons 1, 2, 3 of glucose form Dihydroxyacetone Phosphate (DHAP).\n            # The local index within the 3-carbon DHAP fragment is the same as g.\n            # E.g., glucose carbon 1 becomes DHAP carbon 1.\n            dhap_local_index = g\n\n            # Step 3: Triose Phosphate Isomerase (TPI) action on DHAP.\n            # DHAP is isomerized to Glyceraldehyde-3-Phosphate (GAP).\n            # The problem defines a specific atom mapping for this conversion:\n            # 1 -> 3, 2 -> 2, 3 -> 1.\n            tpi_map = {1: 3, 2: 2, 3: 1}\n            gap_index = tpi_map[dhap_local_index]\n\n        else:  # This branch handles g in {4, 5, 6}\n            # Carbons 4, 5, 6 of glucose form Glyceraldehyde-3-Phosphate (GAP) directly.\n            # The local index is relative to the start of this fragment (glucose carbon 4).\n            # E.g., glucose carbon 4 becomes GAP carbon 1.\n            gap_local_index = g - 3\n            gap_index = gap_local_index\n\n        # Step 4: Lower Glycolysis (GAP to Pyruvate).\n        # The carbon backbone is preserved from GAP to pyruvate.\n        # This is an identity mapping: 1 -> 1, 2 -> 2, 3 -> 3.\n        pyruvate_index = gap_index\n\n        return pyruvate_index\n\n    # Define the test cases from the problem statement.\n    # Happy path: [1, 2, 3, 4, 5, 6]\n    # Edge cases: [0, 7]\n    test_cases = [1, 2, 3, 4, 5, 6, 0, 7]\n\n    # Calculate the results for all test cases.\n    results = []\n    for glucose_label in test_cases:\n        result = trace_carbon_atom(glucose_label)\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    # Example: [3,2,1,1,2,3,-1,-1]\n    # np.array is used to satisfy the problem's library requirements, although a list would suffice.\n    result_array = np.array(results, dtype=int)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, result_array))}]\")\n\nsolve()\n```", "id": "2375342"}, {"introduction": "我们的最终练习将视角从单个反应或分子提升到整个网络的系统层面。在这里，你将学习把复杂的代谢超级通路抽象成一个图，并应用图论算法来识别其结构上的关键点。通过识别那些移除后会导致网络断裂的“瓶颈”酶，你将体验到系统生物学如何揭示潜在的药物靶点或代谢网络中的关键调控节点，从而展示了网络分析在生物学发现中的强大威力。", "problem": "给定一个代谢超通路的形式化抽象，该抽象与在京都基因与基因组百科全书 (KEGG) 和 Reactome通路数据库 (Reactome) 中捕获通路的方式一致。设该网络为一个有向、酶标记的反应图 $G = (V,R)$，其中 $V = \\{1,2,\\dots,N\\}$ 是一个有限的代谢物集合，而 $R \\subseteq V \\times V \\times \\mathbb{Z}$ 是一个有限的有向反应集合。每个反应都是一个三元组 $(u,v,e)$，表示一个由酶标识符 $e \\in \\mathbb{Z}$ 催化的、从代谢物 $u$ 到代谢物 $v$ 的有向转化。为了分析连通性，我们考虑其底层无向简单图 $G^\\ast = (V,E^\\ast)$，其定义如下：对于任意无序对 $\\{u,v\\} \\subseteq V$ 且 $u \\ne v$，无向边 $\\{u,v\\}$ 属于 $E^\\ast$ 当且仅当存在至少一个反应 $(u,v,e) \\in R$ 或 $(v,u,e) \\in R$。在 $E^\\ast$ 中，相同代谢物之间的多个反应和不同方向的反应被合并为一条无向边；然而，每条无向边 $\\{u,v\\}$ 都带有一个多重集，该多重集包含 $R$ 中 $u$ 和 $v$ 之间所有有向反应上的酶标识符。\n\n对于任意单个酶标识符 $x \\in \\mathbb{Z}$，定义去除该酶的反应集合 $R^{(-x)} = \\{(u,v,e) \\in R \\mid e \\ne x\\}$ 以及相应的底层无向简单图 $G^{\\ast(-x)} = (V,E^{\\ast(-x)})$，其中 $\\{u,v\\} \\in E^{\\ast(-x)}$ 当且仅当在 $R^{(-x)}$ 中 $u$ 和 $v$ 之间存在至少一个反应。设 $C(H)$ 表示无向图 $H$ 的连通分量数量。如果 $C(G^{\\ast(-x)}) > C(G^\\ast)$，则称酶标识符 $x$ 为一个瓶颈酶 (chokepoint)。\n\n任务：针对下方的每个测试用例，计算瓶颈酶的集合，并将其以严格递增顺序的整数列表形式输出。您的程序必须将所有给定测试用例的结果汇总到单行输出中，该输出包含一个由方括号括起来的逗号分隔列表（例如：$[ [a_1,a_2], [\\,], [b_1] ]$）。本问题不涉及物理单位。\n\n测试套件（每个反应都是一个三元组 $(u,v,e)$，其中 $u,v \\in \\{1,\\dots,N\\}$ 且酶标识符为 $e \\in \\mathbb{Z}$）：\n\n- 测试用例 1：\n  - $N = 5$。\n  - $R = \\{(1,2,10), (2,3,20), (3,2,21), (3,4,30), (4,5,40)\\}$.\n\n- 测试用例 2：\n  - $N = 4$。\n  - $R = \\{(1,2,1), (3,4,2)\\}$.\n\n- 测试用例 3：\n  - $N = 4$。\n  - $R = \\{(1,2,5), (2,3,6), (3,1,7), (1,4,8)\\}$.\n\n- 测试用例 4：\n  - $N = 6$。\n  - $R = \\{(1,2,11), (2,3,12), (3,1,13), (3,4,99), (4,5,99), (5,6,14)\\}$.\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，第 $i$ 个元素是测试用例 $i$ 的瓶颈酶标识符列表，按严格递增顺序排序。例如，一个有效的输出可能看起来像 $[[x_1,x_2],[y_1],[\\,],[z_1,z_2]]$。", "solution": "所呈现的问题是一个定义明确的计算网络分析练习，其基础是应用于生物信息学的图论形式化方法。该问题在科学上是合理的、客观的，并包含了唯一解所需的所有必要信息。我们将着手解决它。\n\n核心任务是在给定的代谢网络中识别“瓶颈酶”。所提供的定义是形式化且精确的：如果将酶 $x$ 从网络中移除，导致代谢的底层无向图表示中连通分量的数量增加，则该酶是一个瓶颈酶。这本质上是一个识别关键边或边集的问题，这些边或边集如同图论中的桥梁一样，连接着网络中原本不相连的部分。底层图中的一条边 $\\{u,v\\}$ 由催化代谢物 $u$ 和 $v$ 之间反应的所有酶的多重集来维持。只有当酶 $x$ 是负责 $u$ 和 $v$ 之间所有反应的*唯一*酶时，移除该酶才会切断它们之间的连接。\n\n解决这个问题的算法是演绎和系统化的。它包括以下步骤：\n\n1.  **建立基线连通性**：首先，我们必须描述网络的初始状态。我们构建完整的底层无向图，记为 $G^\\ast = (V, E^\\ast)$。顶点集合 $V$ 已给定为 $\\{1, 2, \\dots, N\\}$。如果在反应集合 $R$ 中存在至少一个连接代谢物 $u$ 和 $v$ （任一方向）的反应，则 $E^\\ast$ 中存在一条无向边 $\\{u,v\\}$。构建 $G^\\ast$ 后，我们计算其连通分量的数量 $C(G^\\ast)$。该值将作为我们进行连通性比较的基线参考。连通分量的计算是图论中的一个标准过程，通常使用图遍历算法（如深度优先搜索(DFS)或广度优先搜索(BFS)）来执行。\n\n2.  **迭代扰动与评估**：我们必须逐个测试每种酶的关键性。我们首先从给定的反应集合 $R$ 中识别出所有唯一的酶标识符。设该集合为 $\\mathcal{E}$。对于每个唯一的酶 $x \\in \\mathcal{E}$，我们模拟将其移除的过程。\n\n    a.  **构建扰动图**：我们定义一个新的反应集合 $R^{(-x)}$，它包含 $R$ 中除由酶 $x$ 催化的反应之外的所有反应。基于这个简化的反应集合，我们构建一个新的底层无向图 $G^{\\ast(-x)} = (V, E^{\\ast(-x)})$。当且仅当在 $R^{(-x)}$ 中 $u$ 和 $v$ 之间仍然存在至少一个反应时， $E^{\\ast(-x)}$ 中才存在边 $\\{u,v\\}$。\n\n    b.  **计算扰动后的连通性**：使用相同的连通分量计数算法，我们计算扰动图中的连通分量数量 $C(G^{\\ast(-x)})$。\n\n    c.  **识别瓶颈酶**：应用瓶颈酶的定义条件。如果扰动图中的连通分量数量严格大于原始图中的数量，即 $C(G^{\\ast(-x)}) > C(G^\\ast)$，则酶 $x$ 被归类为瓶颈酶。\n\n3.  **汇总并报告结果**：上一步中识别出的瓶颈酶将为每个测试用例收集起来。根据问题规范，这组酶标识符必须以严格递增的顺序排序并以列表形式呈现。\n\n在实现方面，图可以使用邻接表来表示。然而，考虑到指定的计算环境，更直接的方法是构建图的稀疏矩阵表示，并利用 `scipy.sparse.csgraph.connected_components` 函数。该函数能高效地确定由邻接矩阵表示的图的连通分量数量，从而简化步骤1和2b的实现。整体逻辑保持不变。对于每个测试用例，我们首先计算完整图的连通分量数，然后遍历每一种唯一的酶，重新计算缺少该酶催化反应的图的连通分量数，并通过比较数量来识别瓶颈酶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the chokepoint enzyme identification problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 5,\n            \"R\": [(1, 2, 10), (2, 3, 20), (3, 2, 21), (3, 4, 30), (4, 5, 40)]\n        },\n        # Test case 2\n        {\n            \"N\": 4,\n            \"R\": [(1, 2, 1), (3, 4, 2)]\n        },\n        # Test case 3\n        {\n            \"N\": 4,\n            \"R\": [(1, 2, 5), (2, 3, 6), (3, 1, 7), (1, 4, 8)]\n        },\n        # Test case 4\n        {\n            \"N\": 6,\n            \"R\": [(1, 2, 11), (2, 3, 12), (3, 1, 13), (3, 4, 99), (4, 5, 99), (5, 6, 14)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        R = case[\"R\"]\n        chokepoints = find_chokepoints(N, R)\n        results.append(chokepoints)\n\n    # The final print statement must follow the specified format exactly.\n    # The str() representation of a list in Python matches the required format\n    # for the inner lists, including spaces, e.g., '[10, 30, 40]'.\n    # The join function concatenates these string representations with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef count_components(num_nodes, reactions):\n    \"\"\"\n    Counts the number of connected components in the undirected graph\n    derived from a set of reactions.\n    \n    Args:\n        num_nodes (int): The number of metabolites (nodes) in the graph, N.\n        reactions (list): A list of reaction triples (u, v, e).\n\n    Returns:\n        int: The number of connected components.\n    \"\"\"\n    if not reactions:\n        return num_nodes\n\n    row_indices = []\n    col_indices = []\n\n    for u, v, _ in reactions:\n        # Using 0-based indexing for matrix\n        row_indices.append(u - 1)\n        col_indices.append(v - 1)\n\n    # An undirected graph's adjacency matrix is symmetric.\n    # We add edges in both directions.\n    full_row = row_indices + col_indices\n    full_col = col_indices + row_indices\n    data = np.ones(len(full_row), dtype=int)\n\n    # Create a compressed sparse row (CSR) matrix representation of the graph.\n    graph_matrix = csr_matrix((data, (full_row, full_col)), shape=(num_nodes, num_nodes))\n    \n    # Use SciPy to find connected components.\n    n_components, _ = connected_components(csgraph=graph_matrix, directed=False, return_labels=True)\n    \n    return n_components\n\ndef find_chokepoints(N, R):\n    \"\"\"\n    Identifies chokepoint enzymes for a given metabolic network.\n    \n    Args:\n        N (int): The number of metabolites.\n        R (list): The list of reactions.\n\n    Returns:\n        list: A sorted list of chokepoint enzyme identifiers.\n    \"\"\"\n    if not R:\n        return []\n\n    # Find the set of all unique enzyme identifiers\n    unique_enzymes = sorted(list(set(e for _, _, e in R)))\n\n    # Calculate the number of connected components in the original graph G*\n    base_components = count_components(N, R)\n\n    chokepoints = []\n    for enzyme_to_remove in unique_enzymes:\n        # Construct the enzyme-removed reaction set R^(-x)\n        r_removed = [(u, v, e) for u, v, e in R if e != enzyme_to_remove]\n        \n        # Calculate components in the perturbed graph G*(-x)\n        num_components_removed = count_components(N, r_removed)\n        \n        # Check the chokepoint condition\n        if num_components_removed > base_components:\n            chokepoints.append(enzyme_to_remove)\n            \n    return chokepoints\n\n# Execute the main function\nsolve()\n```", "id": "2375339"}]}