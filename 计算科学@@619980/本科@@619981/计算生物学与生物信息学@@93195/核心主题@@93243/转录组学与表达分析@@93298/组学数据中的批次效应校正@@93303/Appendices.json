{"hands_on_practices": [{"introduction": "处理批次效应最直接的方法之一，是在线性模型中将其作为一个已知变量。本次实践模拟了一个场景，其中批次效应是已知的、可加的，旨在为您提供使用此核心技术的实践经验。您将通过构建和求解一个回归模型来分离出批次效应，从而准确地估计出真实的生物学信号 [@problem_id:2374348]。", "problem": "给定一个受批次效应和生物信号影响的单特征组学测量的数学模型。对于每个样本索引 $i \\in \\{1,\\dots,n\\}$，令 $y_i$ 表示测量值，$x_i \\in \\{0,1\\}$ 表示一个二元生物学状况指示变量，并令 $\\mathrm{batch}(i) \\in \\{1,\\dots,B\\}$ 表示其所属批次。生成模型为\n$$\ny_i = \\mu + \\beta x_i + \\gamma_{\\mathrm{batch}(i)} + \\varepsilon_i,\n$$\n其中 $\\mu$ 是截距，$\\beta$ 是我们感兴趣的生物学效应大小，$\\gamma_b$是批次$b$的特定偏移量（带有参考约束$\\gamma_1 = 0$），而 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是独立的高斯噪声项。生物信号的强度被设定为比批次效应弱一个数量级，具体通过为代表性的批次差异选择 $|\\gamma_b - \\gamma_{b'}| \\approx 10|\\beta|$ 来强制实现。本问题陈述中的所有量均为无量纲。\n\n对于下方的每个测试用例，您必须完全按照规定构建数据集，并在线性模型\n$$\ny_i = \\theta_0 + \\theta_1 x_i + \\sum_{b=2}^{B} \\delta_b \\mathbb{1}\\{\\mathrm{batch}(i)=b\\} + \\eta_i,\n$$\n下计算能使残差平方和最小化的唯一系数 $\\hat{\\beta}$，其中 $\\mathbb{1}\\{\\cdot\\}$ 是指示函数，$(\\theta_0,\\theta_1,\\delta_2,\\dots,\\delta_B)$ 是自由参数。所报告的估计值必须是最小化子 $\\hat{\\theta}_1$，它作为生物效应 $\\beta$ 的批次校正后估计值。\n\n确保确定性的数据构建细节：\n- 对于每个批次 $b \\in \\{1,\\dots,B\\}$，给定样本数 $n_b$ 和该批次中 $x_i=1$ 的样本数 $k_b$。在每个批次内，通过放置 $k_b$ 个1，后跟 $(n_b - k_b)$ 个0来构建向量 $x$；按 $b$ 的递增顺序连接各批次。\n- 通过将 $\\gamma_{\\mathrm{batch}(i)}$ 分配给样本 $i$ 来构建批次偏移向量，其中 $\\gamma_1 = 0$ 且对于 $b \\ge 2$ 使用所提供的 $\\gamma_b$。\n- 每个测试都给定了截距 $\\mu$、生物学系数 $\\beta$ 和噪声标准差 $\\sigma$。\n- 使用为该测试用例指定的整数种子初始化的伪随机数生成器，从高斯分布 $\\mathcal{N}(0,\\sigma^2)$ 中独立抽取 $\\varepsilon_i$，并设定 $y_i = \\mu + \\beta x_i + \\gamma_{\\mathrm{batch}(i)} + \\varepsilon_i$。\n\n参数集测试套件：\n- 测试 $1$：\n  - 批次：$B=2$，其中 $(n_1,n_2)=(50,50)$。\n  - 生物学状况计数：$(k_1,k_2)=(25,25)$。\n  - 参数：$\\mu=7.0$, $\\beta=0.2$, $(\\gamma_1,\\gamma_2)=(0.0,2.0)$, $\\sigma=0.4$。\n  - 种子：$123$。\n- 测试 $2$：\n  - 批次：$B=2$，其中 $(n_1,n_2)=(40,60)$。\n  - 生物学状况计数：$(k_1,k_2)=(8,42)$。\n  - 参数：$\\mu=5.0$, $\\beta=0.2$, $(\\gamma_1,\\gamma_2)=(0.0,2.0)$, $\\sigma=0.5$。\n  - 种子：$456$。\n- 测试 $3$：\n  - 批次：$B=3$，其中 $(n_1,n_2,n_3)=(30,50,40)$。\n  - 生物学状况计数：$(k_1,k_2,k_3)=(10,25,15)$。\n  - 参数：$\\mu=10.0$, $\\beta=0.15$, $(\\gamma_1,\\gamma_2,\\gamma_3)=(0.0,1.5,-0.5)$, $\\sigma=0.6$。\n  - 种子：$789$。\n- 测试 $4$：\n  - 批次：$B=4$，其中 $(n_1,n_2,n_3,n_4)=(5,5,5,5)$。\n  - 生物学状况计数：$(k_1,k_2,k_3,k_4)=(2,3,2,3)$。\n  - 参数：$\\mu=3.0$, $\\beta=0.1$, $(\\gamma_1,\\gamma_2,\\gamma_3,\\gamma_4)=(0.0,1.0,-1.0,0.5)$, $\\sigma=0.2$。\n  - 种子：$2468$。\n\n要求：\n- 对每个测试，构建设计矩阵，其中包括一列全为1（截距）、一列用于 $x$，以及 $(B-1)$ 列用于批次 $b \\in \\{2,\\dots,B\\}$ 的指示变量。\n- 计算残差平方和的唯一最小化子 $\\hat{\\theta}$ 并报告 $\\hat{\\theta}_1$。\n- 您的程序应产一行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的结果与测试顺序相同，每个值都四舍五入到恰好六位小数（例如，$[0.123456,0.000000,1.500000,2.718282]$）。", "solution": "对所提出的问题陈述进行了严格的验证。\n\n步骤1：提取已知条件\n问题为样本 $i \\in \\{1,\\dots,n\\}$ 的组学数据 $y_i$ 提供了一个生成模型：\n$$\ny_i = \\mu + \\beta x_i + \\gamma_{\\mathrm{batch}(i)} + \\varepsilon_i\n$$\n其中：\n- $y_i$：测量值。\n- $x_i \\in \\{0,1\\}$：一个二元生物学状况指示变量。\n- $\\mathrm{batch}(i) \\in \\{1,\\dots,B\\}$：样本 $i$ 的批次归属。\n- $\\mu$：全局截距。\n- $\\beta$：生物学效应大小。\n- $\\gamma_b$：批次 $b$ 的特定偏移量，其中 $\\gamma_1 = 0$。\n- $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$：独立同分布的高斯噪声项。\n\n任务是通过拟合以下线性模型来估计 $\\beta$：\n$$\ny_i = \\theta_0 + \\theta_1 x_i + \\sum_{b=2}^{B} \\delta_b \\mathbb{1}\\{\\mathrm{batch}(i)=b\\} + \\eta_i\n$$\n并找到使残差平方和最小化的系数 $\\hat{\\theta}_1$。这里，$\\mathbb{1}\\{\\cdot\\}$ 是指示函数。待估计的参数是 $(\\theta_0, \\theta_1, \\delta_2, \\dots, \\delta_B)$。\n\n数据构建规则：\n- 对于每个批次 $b \\in \\{1,\\dots,B\\}$，样本数量为 $n_b$，其中 $x_i=1$ 的样本数量为 $k_b$。每个批次内的向量 $x$ 由 $k_b$ 个1后跟 $(n_b - k_b)$ 个0构成。完整的数据向量通过按 $b$ 的递增顺序连接各批次数据而形成。\n- 批次偏移向量使用给定的 $\\gamma_b$ 值构建。\n- 每个测试用例都提供了 $\\mu$、$\\beta$ 和 $\\sigma$。\n- 噪声向量 $\\varepsilon$ 是使用为每个测试用例指定的整数种子初始化的伪随机数生成器从 $\\mathcal{N}(0, \\sigma^2)$ 生成的。\n\n提供了四个测试用例，每个用例都具有特定的参数 $(B, \\{n_b\\}, \\{k_b\\}, \\mu, \\beta, \\{\\gamma_b\\}, \\sigma, \\mathrm{seed})$。\n\n步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题设置在组学数据批次效应校正的背景下，这是计算生物学和生物信息学中一个标准且关键的课题。使用线性模型来表示加性批次效应和生物信号，然后使用另一个线性模型（多元回归）来校正这些效应，是一种基础且被广泛接受的方法（例如，在ComBat算法中实现或作为直接回归）。该前提在科学上是合理的。\n2.  **良态性**：该问题要求解一个多元线性回归问题的普通最小二乘（OLS）解。当且仅当设计矩阵具有满列秩时，存在唯一解。设计矩阵由一个截距、生物学预测变量向量 $x$ 和 $B-1$ 个批次的虚拟变量组成。矩阵秩亏的情况会发生在某一列是其他列的线性组合时。例如，当生物学变量 $x$ 与批次成员身份完全混淆时（例如，一个批次中的所有样本都具有 $x=1$，而另一批次中的所有样本都具有 $x=0$）。对所提供的测试用例的审查证实，在每个案例中，每个批次都包含 $x_i=1$ 和 $x_i=0$ 的样本。这确保了生物学预测变量和批次指示变量之间不存在完全多重共线性。因此，所有测试用例的设计矩阵都将具有满列秩，从而保证了唯一解的存在。该问题是良态的（well-posed）。\n3.  **客观性**：该问题使用精确的数学符号和明确的算法指令来规定数据生成和分析。它不含任何主观论断。\n\n步骤3：结论与行动\n该问题是有效的。它具有科学依据，是良态的、客观的，并提供了一套完整、一致的规范。开始进行求解。\n\n该问题要求在一个多元线性回归模型中估计一个参数。该模型可以用矩阵形式表示为：\n$$\n\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\eta}\n$$\n其中 $\\mathbf{y}$ 是观测值的 $n \\times 1$ 向量，$\\mathbf{X}$ 是 $n \\times (2+B-1)$ 的设计矩阵，$\\boldsymbol{\\theta}$ 是待估计参数的 $(2+B-1) \\times 1$ 向量，$\\boldsymbol{\\eta}$ 是残差的 $n \\times 1$ 向量。参数向量为 $\\boldsymbol{\\theta} = [\\theta_0, \\theta_1, \\delta_2, \\dots, \\delta_B]^T$。\n\n目标是找到使残差平方和（SSR）最小的参数向量 $\\hat{\\boldsymbol{\\theta}}$，其中SSR由下式给出：\n$$\n\\mathrm{SSR}(\\boldsymbol{\\theta}) = \\sum_{i=1}^{n} \\eta_i^2 = \\boldsymbol{\\eta}^T\\boldsymbol{\\eta} = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta})^T (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta})\n$$\n这个最小化问题的解是普通最小二乘（OLS）估计量，可以通过求解正规方程组得到：\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\boldsymbol{\\theta} = \\mathbf{X}^T \\mathbf{y}\n$$\n假设矩阵 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的（我们已经确定对于给定的测试用例是如此），则唯一解为：\n$$\n\\hat{\\boldsymbol{\\theta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\n对于每个测试用例，流程如下：\n1.  构建总样本大小 $n = \\sum_{b=1}^{B} n_b$。\n2.  通过对 $b=1, \\dots, B$ 连接由 $k_b$ 个1和 $(n_b - k_b)$ 个0组成的块，来构建 $n \\times 1$ 的生物学状况向量 $\\mathbf{x}$。\n3.  构建 $n \\times 1$ 的批次分配向量，其中每个条目都标识了相应样本的批次。\n4.  使用提供的 $\\gamma_b$ 值和批次分配向量，构建 $n \\times 1$ 的真实批次效应向量 $\\boldsymbol{\\gamma}$。\n5.  使用给定的种子初始化一个伪随机数生成器。通过从 $\\mathcal{N}(0, \\sigma^2)$ 中抽样来生成 $n \\times 1$ 的噪声向量 $\\boldsymbol{\\varepsilon}$。\n6.  根据生成模型生成 $n \\times 1$ 的测量向量 $\\mathbf{y}$：$\\mathbf{y} = \\mu\\mathbf{1} + \\beta\\mathbf{x} + \\boldsymbol{\\gamma} + \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{1}$ 是一个全为1的向量。\n7.  构建 $n \\times (B+1)$ 的设计矩阵 $\\mathbf{X}$。\n    - 第一列是截距，一个 $n \\times 1$ 的全1向量。\n    - 第二列是生物学状况向量 $\\mathbf{x}$。\n    - 随后的 $B-1$ 列是批次 $2, \\dots, B$ 的指示（虚拟）变量。第 $j$ 个虚拟变量列（对于 $j \\in \\{2, \\dots, B\\}$）对于批次 $j$ 中的样本其值为1，否则为0。\n8.  求解 $\\hat{\\boldsymbol{\\theta}}$ 的 OLS 问题。在计算上，最好使用像 QR 分解这样的稳定数值方法来完成，该方法已在 NumPy 等库中通过 `linalg.lstsq` 函数实现。\n9.  所需的结果是所得向量 $\\hat{\\boldsymbol{\\theta}}$ 的第二个元素，它对应于生物学系数 $\\beta$ 的估计值 $\\hat{\\theta}_1$。\n\n此过程是确定性的，并将应用于每个测试用例以计算所需的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the OLS problem for batch effect correction across multiple test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test 1\n        {\n            \"B\": 2, \"n\": (50, 50), \"k\": (25, 25),\n            \"mu\": 7.0, \"beta\": 0.2, \"gamma\": (0.0, 2.0), \"sigma\": 0.4,\n            \"seed\": 123\n        },\n        # Test 2\n        {\n            \"B\": 2, \"n\": (40, 60), \"k\": (8, 42),\n            \"mu\": 5.0, \"beta\": 0.2, \"gamma\": (0.0, 2.0), \"sigma\": 0.5,\n            \"seed\": 456\n        },\n        # Test 3\n        {\n            \"B\": 3, \"n\": (30, 50, 40), \"k\": (10, 25, 15),\n            \"mu\": 10.0, \"beta\": 0.15, \"gamma\": (0.0, 1.5, -0.5), \"sigma\": 0.6,\n            \"seed\": 789\n        },\n        # Test 4\n        {\n            \"B\": 4, \"n\": (5, 5, 5, 5), \"k\": (2, 3, 2, 3),\n            \"mu\": 3.0, \"beta\": 0.1, \"gamma\": (0.0, 1.0, -1.0, 0.5), \"sigma\": 0.2,\n            \"seed\": 2468\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Extract parameters for the current test case\n        B = case[\"B\"]\n        n_b = case[\"n\"]\n        k_b = case[\"k\"]\n        mu = case[\"mu\"]\n        beta = case[\"beta\"]\n        gamma_params = case[\"gamma\"]\n        sigma = case[\"sigma\"]\n        seed = case[\"seed\"]\n\n        n_total = sum(n_b)\n\n        # 1. Construct data vectors: x, batch_ids, gamma_vec\n        x_parts = []\n        batch_id_parts = []\n        gamma_vec_parts = []\n\n        for b in range(B):\n            # Construct x vector part for batch b\n            x_b = np.concatenate([np.ones(k_b[b]), np.zeros(n_b[b] - k_b[b])])\n            x_parts.append(x_b)\n\n            # Construct batch_id part for batch b (1-indexed)\n            batch_id_parts.append(np.full(n_b[b], b + 1))\n\n            # Construct gamma vector part for batch b\n            gamma_b = np.full(n_b[b], gamma_params[b])\n            gamma_vec_parts.append(gamma_b)\n\n        x = np.concatenate(x_parts)\n        batch_ids = np.concatenate(batch_id_parts)\n        gamma_vec = np.concatenate(gamma_vec_parts)\n\n        # 2. Generate noise and the response variable y\n        rng = np.random.default_rng(seed)\n        epsilon = rng.normal(loc=0.0, scale=sigma, size=n_total)\n        y = mu + beta * x + gamma_vec + epsilon\n\n        # 3. Construct the design matrix X\n        # Column 1: Intercept\n        intercept_col = np.ones(n_total)\n        \n        # Column 2: Biological condition x\n        x_col = x\n        \n        # Columns 3 to B+1: Batch dummy variables for batches 2 to B\n        dummy_cols = []\n        if B > 1:\n            for b_idx in range(2, B + 1):\n                dummy_col = (batch_ids == b_idx).astype(float)\n                dummy_cols.append(dummy_col)\n        \n        design_matrix_cols = [intercept_col, x_col] + dummy_cols\n        X = np.column_stack(design_matrix_cols)\n\n        # 4. Solve the Ordinary Least Squares problem\n        # theta_hat = (X^T X)^-1 X^T y\n        # We use np.linalg.lstsq for numerical stability\n        theta_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # 5. Extract the estimated biological effect (theta_1_hat)\n        beta_hat = theta_hat[1]\n        \n        results.append(beta_hat)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2374348"}, {"introduction": "在组学数据中，批次效应并非总是可加的；它们也可能以乘法形式存在，从而缩放真实的生物学信号。本练习将引导您处理这种更复杂的情况，通过对数变换将乘法模型线性化，使其能够应用我们已经熟悉的线性模型框架进行校正。这个强大的技巧是在生物信息学中处理非加性效应和偏斜数据的基石 [@problem_id:2374360]。", "problem": "给定一个用于聚合组学强度的严格正值数据生成模型。对于批次索引 $i \\in \\{1,\\dots,B\\}$ 和特征索引 $j \\in \\{1,\\dots,F\\}$，观测值 $Y_{ij}$ 被建模为\n$$\nY_{ij} = \\alpha_i \\cdot \\beta_j \\cdot \\epsilon_{ij},\n$$\n其中 $\\alpha_i \\gt 0$ 是一个未知的批次特定的乘性效应，$\\beta_j \\gt 0$ 是一个未知的特征特定的乘性效应，而 $\\epsilon_{ij} \\gt 0$ 是一个乘性噪声因子。假设 $\\log \\epsilon_{ij}$ 具有零均值和有限方差，并且所有 $Y_{ij}$ 都是严格正值，因此自然对数是有定义的。\n\n定义一个批次效应校正策略如下。令 $L_{ij} = \\log Y_{ij}$。令 $(a_1,\\dots,a_B)$ 和 $(b_1,\\dots,b_F)$ 为求解以下约束最小二乘问题的实值参数\n$$\n\\min_{\\{a_i\\},\\{b_j\\}} \\; \\sum_{i=1}^{B} \\sum_{j=1}^{F} \\left(L_{ij} - a_i - b_j\\right)^2\n\\quad \\text{subject to} \\quad \\sum_{i=1}^{B} a_i = 0,\\;\\; \\sum_{j=1}^{F} b_j = 0.\n$$\n将 $\\exp(a_i)$ 解释为批次效应的估计（相差一个全局乘性常数），并将 $\\exp(b_j)$ 解释为特征效应的估计（相差一个全局乘性常数）。对观测值 $Y_{ij}$ 的批次效应校正由 $Z_{ij} = Y_{ij} \\cdot \\exp(-a_i)$ 给出，该校正对于共同的乘性缩放模糊性是不变的。\n\n为进行评估，将对数尺度下的估计效应与中心化的真实值进行比较。定义中心化的真实批次效应 $s_i = \\log \\alpha_i - \\frac{1}{B}\\sum_{k=1}^{B} \\log \\alpha_k$ 和中心化的真实特征效应 $t_j = \\log \\beta_j - \\frac{1}{F}\\sum_{\\ell=1}^{F} \\log \\beta_\\ell$。令 $\\widehat{a}_i$ 和 $\\widehat{b}_j$ 表示上述优化问题的解。对于每个数据集，计算单一汇总误差\n$$\nE = \\max\\!\\left\\{ \\max_{1 \\le i \\le B} \\left| \\widehat{a}_i - s_i \\right|,\\; \\max_{1 \\le j \\le F} \\left| \\widehat{b}_j - t_j \\right| \\right\\}.\n$$\n所有对数均为自然对数。不涉及物理单位；所有量均为无量纲。将每个 $E$ 报告为一个实数，四舍五入到小数点后六位。\n\n测试套件。对于下方的每个测试用例，都给定了 $B$、$F$ 以及 $(\\alpha_i)$、$(\\beta_j)$ 和 $(\\epsilon_{ij})$ 的显式数组。使用上述模型为所有索引构建 $Y_{ij}$，然后为该数据集计算 $E$。\n\n- 测试用例1（通用，无噪声）：\n  - $B = 3$, $F = 4$。\n  - $(\\alpha_i) = \\left[\\, 2.0,\\; 0.5,\\; 1.5 \\,\\right]$。\n  - $(\\beta_j) = \\left[\\, 10.0,\\; 5.0,\\; 20.0,\\; 8.0 \\,\\right]$。\n  - $(\\epsilon_{ij})$ 是所有条目均为 $1.0$ 的 $3 \\times 4$ 矩阵。\n\n- 测试用例2（通用，有轻微乘性噪声）：\n  - $B = 2$, $F = 5$。\n  - $(\\alpha_i) = \\left[\\, 3.0,\\; 0.25 \\,\\right]$。\n  - $(\\beta_j) = \\left[\\, 7.0,\\; 1.4,\\; 0.9,\\; 11.0,\\; 4.0 \\,\\right]$。\n  - $(\\epsilon_{ij})$ 是 $2 \\times 5$ 矩阵\n    $$\n    \\begin{bmatrix}\n    1.02 & 0.97 & 1.05 & 0.94 & 1.01 \\\\\n    0.98 & 1.03 & 0.95 & 1.06 & 0.99\n    \\end{bmatrix}.\n    $$\n\n- 测试用例3（无批次效应，无噪声）：\n  - $B = 3$, $F = 3$。\n  - $(\\alpha_i) = \\left[\\, 1.0,\\; 1.0,\\; 1.0 \\,\\right]$。\n  - $(\\beta_j) = \\left[\\, 3.0,\\; 9.0,\\; 0.6 \\,\\right]$。\n  - $(\\epsilon_{ij})$ 是所有条目均为 $1.0$ 的 $3 \\times 3$ 矩阵。\n\n- 测试用例4（单批次，无噪声）：\n  - $B = 1$, $F = 4$。\n  - $(\\alpha_i) = \\left[\\, 2.5 \\,\\right]$。\n  - $(\\beta_j) = \\left[\\, 0.5,\\; 5.0,\\; 1.25,\\; 10.0 \\,\\right]$。\n  - $(\\epsilon_{ij})$ 是所有条目均为 $1.0$ 的 $1 \\times 4$ 矩阵。\n\n- 测试用例5（单特征，跨批次有轻微噪声）：\n  - $B = 4$, $F = 1$。\n  - $(\\alpha_i) = \\left[\\, 1.2,\\; 0.8,\\; 2.0,\\; 0.5 \\,\\right]$。\n  - $(\\beta_j) = \\left[\\, 3.3 \\,\\right]$。\n  - $(\\epsilon_{ij})$ 是 $4 \\times 1$ 矩阵\n    $$\n    \\begin{bmatrix}\n    1.00 \\\\\n    0.95 \\\\\n    1.05 \\\\\n    1.00\n    \\end{bmatrix}.\n    $$\n\n程序要求。您的程序必须为每个测试用例，从提供的 $(\\alpha_i)$、$(\\beta_j)$ 和 $(\\epsilon_{ij})$ 构建 $Y_{ij}$，求解上述约束最小二乘问题以获得 $(\\widehat{a}_i)$ 和 $(\\widehat{b}_j)$，按定义计算 $E$，将 $E$ 四舍五入到小数点后六位，最后打印一行包含五个测试用例结果的字符串，该字符串为方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_k$ 是测试用例 $k$ 的四舍五入值。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于生物信息学中的标准统计方法，在数学上是适定的，并提供了所有必要信息，且以客观、无歧义的术语表述。不存在科学缺陷、矛盾或不适定结构。因此，我们可以着手推导解法。\n\n该问题要求基于一个源于组学数据乘性模型的约束最小二乘问题的解，来计算一个误差度量。该模型由下式给出：\n$$\nY_{ij} = \\alpha_i \\cdot \\beta_j \\cdot \\epsilon_{ij}\n$$\n其中 $Y_{ij} > 0$, $\\alpha_i > 0$, $\\beta_j > 0$, 且 $\\epsilon_{ij} > 0$。第一步是通过取自然对数来线性化模型：\n$$\nL_{ij} = \\log Y_{ij} = \\log \\alpha_i + \\log \\beta_j + \\log \\epsilon_{ij}\n$$\n这将乘性效应转换为加性分量。我们定义 $A_i = \\log \\alpha_i$, $B_j = \\log \\beta_j$, 以及 $E_{ij} = \\log \\epsilon_{ij}$。模型变为：\n$$\nL_{ij} = A_i + B_j + E_{ij}\n$$\n问题在于找到参数 $\\{a_i\\}_{i=1}^B$ 和 $\\{b_j\\}_{j=1}^F$ 来求解约束最小化问题：\n$$\n\\min_{\\{a_i\\},\\{b_j\\}} \\; S = \\sum_{i=1}^{B} \\sum_{j=1}^{F} \\left(L_{ij} - a_i - b_j\\right)^2\n\\quad \\text{subject to} \\quad \\sum_{i=1}^{B} a_i = 0 \\text{ and } \\sum_{j=1}^{F} b_j = 0.\n$$\n这是一个统计学中的标准问题，等价于一个没有显式截距项的双因素方差分析(ANOVA)分解，使用和为零约束来保证可识别性。我们可以使用拉格朗日乘子法来找到最优参数 $\\widehat{a}_i$ 和 $\\widehat{b}_j$。拉格朗日函数为：\n$$\n\\mathcal{L}(\\{a_i\\}, \\{b_j\\}, \\lambda_1, \\lambda_2) = \\sum_{i=1}^{B} \\sum_{j=1}^{F} (L_{ij} - a_i - b_j)^2 + \\lambda_1 \\sum_{i=1}^{B} a_i + \\lambda_2 \\sum_{j=1}^{F} b_j\n$$\n将关于 $a_k$ 和 $b_k$ 的偏导数设为零，可得到 Karush-Kuhn-Tucker (KKT) 条件：\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial a_k} = -2\\sum_{j=1}^{F} (L_{kj} - a_k - b_j) + \\lambda_1 = 0 \\quad \\implies \\quad \\sum_{j=1}^{F} L_{kj} - F a_k - \\sum_{j=1}^{F} b_j = \\frac{\\lambda_1}{2}\n$$\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial b_k} = -2\\sum_{i=1}^{B} (L_{ik} - a_i - b_k) + \\lambda_2 = 0 \\quad \\implies \\quad \\sum_{i=1}^{B} L_{ik} - \\sum_{i=1}^{B} a_i - B b_k = \\frac{\\lambda_2}{2}\n$$\n将约束 $\\sum a_i = 0$ 和 $\\sum b_j = 0$ 应用于这些方程，可将其简化为：\n$$\n\\sum_{j=1}^{F} L_{kj} - F a_k = \\frac{\\lambda_1}{2} \\quad \\implies \\quad a_k = \\frac{1}{F}\\sum_{j=1}^{F} L_{kj} - \\frac{\\lambda_1}{2F}\n$$\n$$\n\\sum_{i=1}^{B} L_{ik} - B b_k = \\frac{\\lambda_2}{2} \\quad \\implies \\quad b_k = \\frac{1}{B}\\sum_{i=1}^{B} L_{ik} - \\frac{\\lambda_2}{2B}\n$$\n我们将 $a_k$ 和 $b_k$ 的这些表达式代入约束方程，以确定拉格朗日乘子 $\\lambda_1$ 和 $\\lambda_2$。\n$$\n\\sum_{k=1}^{B} a_k = 0 \\implies \\sum_{k=1}^{B} \\left(\\frac{1}{F}\\sum_{j=1}^{F} L_{kj}\\right) - B\\frac{\\lambda_1}{2F} = 0 \\implies \\frac{1}{F}L_{..} = B\\frac{\\lambda_1}{2F} \\implies \\frac{\\lambda_1}{2} = \\frac{L_{..}}{B}\n$$\n$$\n\\sum_{k=1}^{F} b_k = 0 \\implies \\sum_{k=1}^{F} \\left(\\frac{1}{B}\\sum_{i=1}^{B} L_{ik}\\right) - F\\frac{\\lambda_2}{2B} = 0 \\implies \\frac{1}{B}L_{..} = F\\frac{\\lambda_2}{2B} \\implies \\frac{\\lambda_2}{2} = \\frac{L_{..}}{F}\n$$\n其中 $L_{..} = \\sum_{i=1}^{B}\\sum_{j=1}^{F} L_{ij}$ 是总和。我们引入样本均值：\n$\\bar{L}_{i.} = \\frac{1}{F}\\sum_{j=1}^{F} L_{ij}$（行均值），$\\bar{L}_{.j} = \\frac{1}{B}\\sum_{i=1}^{B} L_{ij}$（列均值），以及 $\\bar{L}_{..} = \\frac{1}{BF}\\sum_{i=1}^{B}\\sum_{j=1}^{F} L_{ij}$（总均值）。\n于是，估计量为：\n$$\n\\widehat{a}_i = \\bar{L}_{i.} - \\frac{1}{F}\\frac{L_{..}}{B} = \\bar{L}_{i.} - \\frac{BF\\bar{L}_{..}}{BF} = \\bar{L}_{i.} - \\bar{L}_{..}\n$$\n$$\n\\widehat{b}_j = \\bar{L}_{.j} - \\frac{1}{B}\\frac{L_{..}}{F} = \\bar{L}_{.j} - \\frac{BF\\bar{L}_{..}}{BF} = \\bar{L}_{.j} - \\bar{L}_{..}\n$$\n问题要求将这些估计量与中心化的真实效应进行比较，其定义为 $s_i = \\log \\alpha_i - \\frac{1}{B}\\sum_k \\log \\alpha_k = A_i - \\bar{A}$ 和 $t_j = \\log \\beta_j - \\frac{1}{F}\\sum_\\ell \\log \\beta_\\ell = B_j - \\bar{B}$。\n\n为了找到估计误差，我们将加性模型 $L_{ij} = A_i + B_j + E_{ij}$ 代入估计量的表达式中。\n$$\n\\bar{L}_{i.} = \\frac{1}{F}\\sum_{j=1}^{F}(A_i + B_j + E_{ij}) = A_i + \\bar{B} + \\bar{E}_{i.}\n$$\n$$\n\\bar{L}_{..} = \\frac{1}{BF}\\sum_{i=1}^{B}\\sum_{j=1}^{F}(A_i + B_j + E_{ij}) = \\bar{A} + \\bar{B} + \\bar{E}_{..}\n$$\n批次效应的估计量是：\n$$\n\\widehat{a}_i = \\bar{L}_{i.} - \\bar{L}_{..} = (A_i + \\bar{B} + \\bar{E}_{i.}) - (\\bar{A} + \\bar{B} + \\bar{E}_{..}) = (A_i - \\bar{A}) + (\\bar{E}_{i.} - \\bar{E}_{..})\n$$\n因此，批次效应估计的误差为：\n$$\n\\widehat{a}_i - s_i = (\\bar{E}_{i.} - \\bar{E}_{..})\n$$\n根据对称性，特征效应估计的误差为：\n$$\n\\widehat{b}_j - t_j = (\\bar{E}_{.j} - \\bar{E}_{..})\n$$\n汇总误差 $E$ 定义为这些估计误差的绝对值的最大值：\n$$\nE = \\max\\!\\left\\{ \\max_{1 \\le i \\le B} \\left| \\bar{E}_{i.} - \\bar{E}_{..} \\right|,\\; \\max_{1 \\le j \\le F} \\left| \\bar{E}_{.j} - \\bar{E}_{..} \\right| \\right\\}\n$$\n此推导表明，估计误差 $E$ 仅依赖于对数转换后的噪声值矩阵 $E_{ij} = \\log \\epsilon_{ij}$。真实效应 $\\alpha_i$ 和 $\\beta_j$ 完全不影响误差度量 $E$。\n\n对于测试用例1、3和4，噪声矩阵 $\\epsilon_{ij}$ 的所有条目均等于 $1.0$。因此，对于所有的 $i,j$，有 $E_{ij} = \\log(1.0) = 0$。在这种无噪声情景下，所有误差项均为零： $\\bar{E}_{i.}=0$, $\\bar{E}_{.j}=0$, $\\bar{E}_{..}=0$。因此，对于这些用例，汇总误差 $E$ 精确为$0$。\n\n对于测试用例2和5，噪声是不可忽略的。误差 $E$ 的计算必须首先计算矩阵 $E_{ij} = \\log\\epsilon_{ij}$，然后计算其行均值、列均值和总均值，最后根据 $E$ 的公式计算最大绝对偏差。所有测试用例的全部计算都可以基于这个简化公式来实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the batch effect correction problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general, noiseless)\n        {\n            \"B\": 3, \"F\": 4,\n            \"alpha\": [2.0, 0.5, 1.5],\n            \"beta\": [10.0, 5.0, 20.0, 8.0],\n            \"epsilon\": [[1.0] * 4] * 3,\n        },\n        # Test case 2 (general, with mild multiplicative noise)\n        {\n            \"B\": 2, \"F\": 5,\n            \"alpha\": [3.0, 0.25],\n            \"beta\": [7.0, 1.4, 0.9, 11.0, 4.0],\n            \"epsilon\": [\n                [1.02, 0.97, 1.05, 0.94, 1.01],\n                [0.98, 1.03, 0.95, 1.06, 0.99]\n            ],\n        },\n        # Test case 3 (no batch effect, noiseless)\n        {\n            \"B\": 3, \"F\": 3,\n            \"alpha\": [1.0, 1.0, 1.0],\n            \"beta\": [3.0, 9.0, 0.6],\n            \"epsilon\": [[1.0] * 3] * 3,\n        },\n        # Test case 4 (single batch, noiseless)\n        {\n            \"B\": 1, \"F\": 4,\n            \"alpha\": [2.5],\n            \"beta\": [0.5, 5.0, 1.25, 10.0],\n            \"epsilon\": [[1.0] * 4],\n        },\n        # Test case 5 (single feature, mild noise across batches)\n        {\n            \"B\": 4, \"F\": 1,\n            \"alpha\": [1.2, 0.8, 2.0, 0.5],\n            \"beta\": [3.3],\n            \"epsilon\": [\n                [1.00],\n                [0.95],\n                [1.05],\n                [1.00]\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # As derived in the solution, the error E depends only on the noise term epsilon.\n        # We do not need alpha, beta, B, or F, except to structure the epsilon matrix.\n        epsilon_matrix = np.array(case[\"epsilon\"])\n        \n        # log_epsilon_matrix is the matrix E_ij from the derivation.\n        log_epsilon_matrix = np.log(epsilon_matrix)\n        \n        # Calculate row means (E_i.), column means (E_.j), and grand mean (E_..)\n        grand_mean = np.mean(log_epsilon_matrix)\n        row_means = np.mean(log_epsilon_matrix, axis=1)\n        col_means = np.mean(log_epsilon_matrix, axis=0)\n        \n        # Calculate estimation errors for batch and feature effects.\n        # err_a corresponds to (a_hat_i - s_i)\n        err_a = row_means - grand_mean\n        # err_b corresponds to (b_hat_j - t_j)\n        err_b = col_means - grand_mean\n        \n        # Find the maximum absolute error for each set of effects.\n        # The size check handles potential empty arrays, although not expected here.\n        max_err_a = np.max(np.abs(err_a)) if err_a.size > 0 else 0.0\n        max_err_b = np.max(np.abs(err_b)) if err_b.size > 0 else 0.0\n        \n        # The total error E is the maximum of these two.\n        E = max(max_err_a, max_err_b)\n        \n        # Format the result to six decimal places as required.\n        results.append(f\"{E:.6f}\")\n\n    # Print the final result in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2374360"}, {"introduction": "在许多实际研究中，我们可能不知道确切的批次信息，或者存在未被测量的技术变量（即“潜变量”）。这个高级练习将带您进入批次校正的前沿领域，模拟一个您必须从数据本身推断和移除未知批次效应的场景。您将应用类似于替代变量分析(SVA)的方法，使用矩阵分解来估计这些潜在变异来源，从而在保留目标生物学信号的同时净化数据 [@problem_id:2374389]。", "problem": "给定一个用于组学表达数据的数学模型，其中包含未知的批次效应。设有一个数据矩阵 $X \\in \\mathbb{R}^{p \\times n}$，其中包含在 $n$ 个样本中测量的 $p$ 个特征（例如基因），一个已知的协变量设计矩阵 $C \\in \\mathbb{R}^{n \\times q}$（例如表型），一个未知的批次因子设计 $H \\in \\mathbb{R}^{n \\times k}$，以及相应的特征载荷 $B \\in \\mathbb{R}^{p \\times q}$ 和 $A \\in \\mathbb{R}^{p \\times k}$。数据由以下线性模型生成\n$$\nX \\;=\\; B C^\\top \\;+\\; A H^\\top \\;+\\; E,\n$$\n其中 $E \\in \\mathbb{R}^{p \\times n}$ 是均值为零的噪声。\n\n目标是仅根据 $X$ 和 $C$ 构建一个 $k_{\\text{est}}$ 维潜在批次子空间的估计量 $\\widehat{H} \\in \\mathbb{R}^{n \\times k_{\\text{est}}}$，并生成一个批次校正后的矩阵 $X_{\\text{corr}} \\in \\mathbb{R}^{p \\times n}$，该矩阵需移除未知批次子空间的线性效应，同时保留可归因于已知协变量 $C$ 的线性效应。将样本空间列张成的正交投影矩阵定义为\n$$\nP_Z \\;=\\; Z Z^+ \\in \\mathbb{R}^{n \\times n}, \\qquad M_Z \\;=\\; I_n - P_Z,\n$$\n对于任何 $Z \\in \\mathbb{R}^{n \\times r}$，其中 $Z^+$ 是 Moore–Penrose 伪逆，$I_n$ 是 $n \\times n$ 单位矩阵。对于两个矩阵 $Z_1 \\in \\mathbb{R}^{n \\times r_1}$ 和 $Z_2 \\in \\mathbb{R}^{n \\times r_2}$ 的联合列空间，将它们拼接为 $Q = [Z_1 \\; Z_2] \\in \\mathbb{R}^{n \\times (r_1 + r_2)}$，并使用 $P_Q = Q Q^+$，$M_Q = I_n - P_Q$。\n\n您的程序必须对下方的每个测试用例，纯粹用线性代数术语执行以下步骤：\n1. 给定 $X$ 和 $C$，选择一个 $k_{\\text{est}}$ 维潜在样本子空间的估计量 $\\widehat{H} \\in \\mathbb{R}^{n \\times k_{\\text{est}}}$，该估计量能在移除到 $C$ 的投影后，最大化残差矩阵中捕获的方差。形式上，令 $R = X M_C \\in \\mathbb{R}^{p \\times n}$。在所有具有标准正交列的 $n \\times k_{\\text{est}}$ 矩阵中，\n$$\n\\widehat{H} \\;=\\; \\arg\\max_{H' \\in \\mathbb{R}^{n \\times k_{\\text{est}}},\\, (H')^\\top H' = I_{k_{\\text{est}}}} \\; \\lVert R P_{H'} \\rVert_F^2,\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 是 Frobenius 范数。\n2. 构建校正后的数据矩阵\n$$\nX_{\\text{corr}} \\;=\\; X P_C \\;+\\; X M_Q,\n$$\n其中 $Q = [\\, C \\;\\; \\widehat{H} \\,] \\in \\mathbb{R}^{n \\times (q + k_{\\text{est}})}$。此操作移除了可归因于估计的潜在批次子空间的线性效应，同时保留了可归因于 $C$ 的效应。\n3. 为了进行评估，令 $H_{\\text{true}} \\in \\mathbb{R}^{n \\times k_{\\text{true}}}$ 表示在每个测试用例中用于生成 $X$ 的真实批次设计（当 $k_{\\text{true}} = 0$ 时，它可能包含零列）。计算校正后剩余的批次相关方差分数为\n$$\nf \\;=\\; \\frac{\\lVert X_{\\text{corr}} \\, P_{H_{\\text{true}}} \\rVert_F^2}{\\lVert X_{\\text{corr}} \\rVert_F^2}.\n$$\n当 $k_{\\text{true}} = 0$ 时，将 $P_{H_{\\text{true}}}$ 解释为 $n \\times n$ 的零矩阵，因此 $f = 0$。\n\n合成测试数据的构建是确定性的，并且在每个测试用例中都使用相同的过程。所有矩阵都是通过一个固定的伪随机流程生成的，该流程通过一个线性同余生成器（LCG）和 Box–Muller 变换将一个整数种子映射到独立的标准正态变量：\n- 均匀生成器：从一个整数状态 $x_0 = s$（给定的种子）开始，定义\n$$\nx_{t+1} \\;=\\; (a x_t + c) \\bmod m, \\quad u_{t+1} \\;=\\; \\frac{x_{t+1}}{m},\n$$\n常数为 $m = 2^{32}$，$a = 1664525$，$c = 1013904223$，生成 $u_{t} \\in [0,1)$。\n- 标准正态生成器：将连续的数对 $(u_1, u_2)$（其中 $u_1 \\in (0,1)$ 且 $u_2 \\in [0,1)$）转换为\n$$\nz_1 \\;=\\; \\sqrt{-2 \\ln u_1}\\, \\cos(2\\pi u_2), \\qquad z_2 \\;=\\; \\sqrt{-2 \\ln u_1}\\, \\sin(2\\pi u_2).\n$$\n如果 $u_1 = 0$，在应用变换前将其替换为 $u_1 = \\frac{1}{m}$。要生成一个形状为 $r \\times c$ 且其元素服从 $\\mathcal{N}(0,\\sigma^2)$ 分布的矩阵，需抽取 $r \\cdot c$ 个这样的 $z$ 值，将它们按行主序排列，然后乘以 $\\sigma$。\n\n每个测试用例的数据生成使用以下步骤和参数：\n- 给定整数 $p, n, q, k_{\\text{true}}$，以及非负标量 $\\sigma_B, \\sigma_A, \\sigma_E$：\n  - 从种子 $s_B$ 生成 $B \\in \\mathbb{R}^{p \\times q}$，标准差为 $\\sigma_B$（如果 $q = 0$，$B$ 为空矩阵）。\n  - 从种子 $s_A$ 生成 $A \\in \\mathbb{R}^{p \\times k_{\\text{true}}}$，标准差为 $\\sigma_A$（如果 $k_{\\text{true}} = 0$，$A$ 为空矩阵）。\n  - 从种子 $s_H$ 生成 $H_{\\text{true}} \\in \\mathbb{R}^{n \\times k_{\\text{true}}}$，标准差为 $1$（如果 $k_{\\text{true}} = 0$ 则忽略）。\n  - 从种子 $s_E$ 生成 $E \\in \\mathbb{R}^{p \\times n}$，标准差为 $\\sigma_E$。\n  - 根据每个测试用例确定性地定义 $C \\in \\mathbb{R}^{n \\times q}$。\n  - 构成 $X = B C^\\top + A H_{\\text{true}}^\\top + E$。\n- 在上述估计量步骤中使用指定的 $k_{\\text{est}}$。如果 $q = 0$ 或 $k_{\\text{est}} = 0$，则以自然方式解释涉及空矩阵的相应拼接和投影，即当 $Z$ 只有零列时，$P_Z$ 等于零矩阵。\n\n测试套件。对于每种情况，程序必须完全按照规定生成数据，并计算上面定义的标量 $f$：\n- 案例 1（一般情况）：\n  - 维度：$p = 60$, $n = 40$, $q = 1$, $k_{\\text{true}} = 2$, $k_{\\text{est}} = 2$。\n  - 种子：$s_B = 101$, $s_A = 202$, $s_H = 303$, $s_E = 404$。\n  - 尺度：$\\sigma_B = 1.0$, $\\sigma_A = 1.5$, $\\sigma_E = 0.3$。\n  - 协变量：$C \\in \\mathbb{R}^{40 \\times 1}$，其中当 $1 \\le j \\le 20$ 时 $C_{j,1}=0$，当 $21 \\le j \\le 40$ 时 $C_{j,1}=1$。\n- 案例 2（无批次；高估的潜在维度）：\n  - 维度：$p = 50$, $n = 30$, $q = 1$, $k_{\\text{true}} = 0$, $k_{\\text{est}} = 2$。\n  - 种子：$s_B = 505$, $s_E = 606$。\n  - 尺度：$\\sigma_B = 0.8$, $\\sigma_E = 0.4$。\n  - 协变量：$C \\in \\mathbb{R}^{30 \\times 1}$，其中当 $1 \\le j \\le 15$ 时 $C_{j,1}=0$，当 $16 \\le j \\le 30$ 时 $C_{j,1}=1$。\n- 案例 3（秩亏协变量；强批次效应）：\n  - 维度：$p = 80$, $n = 50$, $q = 2$, $k_{\\text{true}} = 1$, $k_{\\text{est}} = 1$。\n  - 种子：$s_B = 707$, $s_A = 808$, $s_H = 909$, $s_E = 100$。\n  - 尺度：$\\sigma_B = 0.5$, $\\sigma_A = 2.0$, $\\sigma_E = 0.2$。\n  - 协变量：$C \\in \\mathbb{R}^{50 \\times 2}$，其中 $C_{j,1} = \\frac{j}{50}$ 且 $C_{j,2} = 2 \\, C_{j,1}$（对于 $1 \\le j \\le 50$）。\n- 案例 4（无已知协变量；仅有批次效应和噪声）：\n  - 维度：$p = 40$, $n = 25$, $q = 0$, $k_{\\text{true}} = 2$, $k_{\\text{est}} = 2$。\n  - 种子：$s_A = 111$, $s_H = 222$, $s_E = 333$。\n  - 尺度：$\\sigma_A = 1.2$, $\\sigma_E = 0.5$。\n  - 协变量：$C$ 是一个 $25 \\times 0$ 的空矩阵。\n\n您的程序应生成单行输出，其中包含案例 1 到 4 的四个标量结果 $f$，以逗号分隔的列表形式，并用方括号括起来，按案例顺序排列。例如，输出格式必须与 $[r_1,r_2,r_3,r_4]$ 完全一样，其中每个 $r_i$ 是为案例 $i$ 计算的浮点数，不含额外的空格或文本。此问题不涉及任何物理单位，三角函数引入的任何角度都必须以弧度解释。", "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且计算上可行的。它描述了在高维数据中进行批次效应校正的标准流程，该流程基于线性模型和矩阵分解的原理。我们将着手对所需算法进行严谨的、分步的推导和实现。\n\n观测数据矩阵 $X \\in \\mathbb{R}^{p \\times n}$ 的模型由已知协变量效应、未知批次效应和噪声的线性组合给出：\n$$ X \\;=\\; B C^\\top \\;+\\; A H^\\top \\;+\\; E $$\n在此， $C \\in \\mathbb{R}^{n \\times q}$ 是已知的协变量设计矩阵，而 $H \\in \\mathbb{R}^{n \\times k_{\\text{true}}}$ 是未知的批次设计矩阵。我们的目标是估计 $H$ 的列空间，从 $X$ 中移除其影响，同时保留 $C$ 的列空间的影响。\n\n**步骤 1：估计潜在批次子空间**\n\n第一步是为潜在子空间构建一个估计量 $\\widehat{H} \\in \\mathbb{R}^{n \\times k_{\\text{est}}}$。其策略是首先移除已知协变量 $C$ 的线性效应，然后在剩余数据中识别出主要的变异方向。\n\n移除到 $C$ 的列空间的投影后的残差矩阵是 $R = X M_C$，其中 $M_C = I_n - P_C$ 且 $P_C = C C^+$ 是到 $C$ 的列空间的正交投影矩阵。此处，$C^+$ 表示 $C$ 的 Moore-Penrose 伪逆，它可以正确处理 $C$ 不是满列秩或具有零列（即 $q=0$）的情况。\n\n估计量 $\\widehat{H}$ 被定义为具有 $k_{\\text{est}}$ 个标准正交列的矩阵，该矩阵最大化了在 $R$ 中捕获的方差：\n$$ \\widehat{H} \\;=\\; \\arg\\max_{H' \\in \\mathbb{R}^{n \\times k_{\\text{est}}},\\, (H')^\\top H' = I_{k_{\\text{est}}}} \\; \\lVert R P_{H'} \\rVert_F^2 $$\n由于 $H'$ 的列是标准正交的，其伪逆是其转置，因此 $P_{H'} = H' (H')^+ = H' (H')^\\top$。目标函数可以使用属性 $\\lVert A \\rVert_F^2 = \\text{tr}(A^\\top A)$ 重写为：\n$$ \\lVert R H' (H')^\\top \\rVert_F^2 \\;=\\; \\text{tr}\\left(\\left(R H' (H')^\\top\\right)^\\top \\left(R H' (H')^\\top\\right)\\right) \\;=\\; \\text{tr}\\left(H' (H')^\\top R^\\top R H' (H')^\\top\\right) $$\n利用迹的循环特性和约束条件 $(H')^\\top H' = I_{k_{\\text{est}}}$，上式可简化为：\n$$ \\text{tr}\\left((H')^\\top R^\\top R H'\\right) $$\n这是一个线性代数中经典的迹最大化问题。其解是：最优矩阵 $\\widehat{H}$ 的列必须是与对称半正定矩阵 $S_R = R^\\top R \\in \\mathbb{R}^{n \\times n}$ 的 $k_{\\text{est}}$ 个最大特征值相对应的标准正交特征向量。此过程等同于对残差数据的样本维度执行主成分分析（PCA）。\n\n因此，计算过程如下：\n1. 通过基于 SVD 的伪逆计算 $P_C = C C^+$。如果 $q=0$，$C$ 是一个 $n \\times 0$ 矩阵， $P_C$ 会正确地计算为 $n \\times n$ 的零矩阵。\n2. 计算残差矩阵 $R = X (I_n - P_C)$。\n3. 构成样本 Gram 矩阵 $S_R = R^\\top R$。\n4. 对对称矩阵 $S_R$ 执行特征分解，以找到其特征值和特征向量。\n5. 从与最大的 $k_{\\text{est}}$ 个特征值相对应的 $k_{\\text{est}}$ 个特征向量构建 $\\widehat{H}$。如果 $k_{\\text{est}}=0$，$\\widehat{H}$ 是一个 $n \\times 0$ 的空矩阵。\n\n**步骤 2：构建校正后的数据矩阵**\n\n构建校正后的数据矩阵 $X_{\\text{corr}}$ 是为了在移除估计的批次效应的同时，保留与 $C$ 相关的信号。公式如下：\n$$ X_{\\text{corr}} \\;=\\; X P_C \\;+\\; X M_Q $$\n其中 $Q = [\\, C \\;\\; \\widehat{H} \\,]$ 是协变量矩阵和估计的批次因子矩阵的拼接，$M_Q = I_n - P_Q$ 是针对组合子空间的残差生成矩阵。\n\n该公式有明确的解释。项 $X P_C$ 是原始数据在协变量子空间上的投影，代表我们希望保留的数据部分。项 $X M_Q$ 是原始数据在与协变量和估计批次效应的组合空间正交的子空间上的投影。\n\n为了验证归因于 $C$ 的信号被保留，我们将 $X_{\\text{corr}}$ 投影回协变量子空间：\n$$ X_{\\text{corr}} P_C = (X P_C + X M_Q) P_C = X P_C P_C + X M_Q P_C $$\n由于 $P_C$ 是一个幂等投影矩阵，所以 $P_C P_C = P_C$。$C$ 的列空间是 $Q$ 的列空间的一个子空间，因此 $C$ 的列空间中的任何向量都是 $P_Q$ 的特征值为 1 的特征向量。这意味着投影 $P_Q$ 在 $C$ 的列空间上充当单位算子，因此 $P_Q P_C = P_C$。所以，乘积 $M_Q P_C = (I_n - P_Q) P_C = P_C - P_Q P_C = P_C - P_C$ 是零矩阵。\n由此得出 $X_{\\text{corr}} P_C = X P_C$。校正后数据在协变量子空间上的投影与原始数据相同，这证实了目标信号通过该变换得以保留。\n\n**步骤 3：评估批次效应的移除效果**\n\n校正的有效性通过校正后数据中剩余的批次相关方差分数来量化：\n$$ f \\;=\\; \\frac{\\lVert X_{\\text{corr}} \\, P_{H_{\\text{true}}} \\rVert_F^2}{\\lVert X_{\\text{corr}} \\rVert_F^2} $$\n这里，$H_{\\text{true}} \\in \\mathbb{R}^{n \\times k_{\\text{true}}}$ 是真实的批次设计矩阵。分子衡量的是校正后数据投影到真实批次子空间上的能量（Frobenius 范数的平方）。分母是校正后数据的总能量。接近 $0$ 的 $f$ 值表示成功移除了批次效应。如果 $k_{\\text{true}}=0$，则一开始就没有批次效应；在这种情况下，$P_{H_{\\text{true}}}$ 是零矩阵，这正确地得出 $f=0$。计算需要先计算投影矩阵 $P_{H_{\\text{true}}}$，然后计算 Frobenius 范数的平方。如果分母为零，这意味着 $X_{\\text{corr}}$ 是一个零矩阵，由于分子也必为零，该分数被视为 $0$。\n\n实现将遵循这些步骤，使用指定的确定性伪随机数生成器为每个案例合成测试数据。将使用来自 `numpy.linalg` 库的稳健数值线性代数例程进行伪逆和特征分解。", "answer": "```python\nimport numpy as np\n\nclass LCG:\n    \"\"\"A Linear Congruential Generator as specified in the problem.\"\"\"\n    def __init__(self, seed):\n        self.m = 2**32\n        self.a = 1664525\n        self.c = 1013904223\n        self.state = seed\n\n    def next_int(self):\n        \"\"\"Generate the next integer state.\"\"\"\n        self.state = (self.a * self.state + self.c) % self.m\n        return self.state\n\n    def next_uniform(self):\n        \"\"\"Generate a uniform random number in [0, 1).\"\"\"\n        return self.next_int() / self.m\n\ndef generate_normals_from_seed(seed, size, prng_class):\n    \"\"\"\n    Generates an array of standard normal random numbers from a seed\n    using the specified LCG and Box-Muller transform.\n    \"\"\"\n    rng = prng_class(seed)\n    normals = []\n    \n    # Pre-calculate constants to avoid recomputation in loop\n    pi_2 = 2.0 * np.pi\n    u1_min_val = 1.0 / rng.m\n\n    while len(normals) < size:\n        u1 = rng.next_uniform()\n        u2 = rng.next_uniform()\n\n        if u1 == 0.0:\n            u1 = u1_min_val  # Handle u1=0 as per problem description\n        \n        magnitude = np.sqrt(-2.0 * np.log(u1))\n        z1 = magnitude * np.cos(pi_2 * u2)\n        z2 = magnitude * np.sin(pi_2 * u2)\n        \n        normals.append(z1)\n        if len(normals) < size:\n            normals.append(z2)\n            \n    return np.array(normals[:size])\n\ndef generate_matrix(seed, p, n, sigma, prng_class):\n    \"\"\"Generates a matrix with entries from N(0, sigma^2).\"\"\"\n    if p == 0 or n == 0 or seed is None:\n        return np.empty((p, n))\n    num_elements = p * n\n    normals = generate_normals_from_seed(seed, num_elements, prng_class)\n    return normals.reshape((p, n)) * sigma\n\ndef projection_matrix(Z):\n    \"\"\"Computes the orthogonal projection matrix onto the column space of Z.\"\"\"\n    n, k = Z.shape\n    if k == 0:\n        return np.zeros((n, n))\n    # Use SVD-based Moore-Penrose pseudoinverse for numerical stability\n    Z_pinv = np.linalg.pinv(Z)\n    return Z @ Z_pinv\n\ndef solve():\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"p\": 60, \"n\": 40, \"q\": 1, \"k_true\": 2, \"k_est\": 2,\n            \"s_B\": 101, \"s_A\": 202, \"s_H\": 303, \"s_E\": 404,\n            \"sigma_B\": 1.0, \"sigma_A\": 1.5, \"sigma_E\": 0.3,\n            \"C_fn\": lambda n, q: np.vstack([np.zeros((n // 2, q)), np.ones((n - n // 2, q))])\n        },\n        # Case 2 (no batch; overestimated latent dimension)\n        {\n            \"p\": 50, \"n\": 30, \"q\": 1, \"k_true\": 0, \"k_est\": 2,\n            \"s_B\": 505, \"s_A\": None, \"s_H\": None, \"s_E\": 606,\n            \"sigma_B\": 0.8, \"sigma_A\": 0.0, \"sigma_E\": 0.4,\n            \"C_fn\": lambda n, q: np.vstack([np.zeros((n // 2, q)), np.ones((n - n // 2, q))])\n        },\n        # Case 3 (rank-deficient covariate; strong batch)\n        {\n            \"p\": 80, \"n\": 50, \"q\": 2, \"k_true\": 1, \"k_est\": 1,\n            \"s_B\": 707, \"s_A\": 808, \"s_H\": 909, \"s_E\": 100,\n            \"sigma_B\": 0.5, \"sigma_A\": 2.0, \"sigma_E\": 0.2,\n            \"C_fn\": lambda n, q: np.column_stack([ (np.arange(1, n + 1) / n), 2 * (np.arange(1, n + 1) / n) ])\n        },\n        # Case 4 (no known covariates; only batch and noise)\n        {\n            \"p\": 40, \"n\": 25, \"q\": 0, \"k_true\": 2, \"k_est\": 2,\n            \"s_B\": None, \"s_A\": 111, \"s_H\": 222, \"s_E\": 333,\n            \"sigma_B\": 0.0, \"sigma_A\": 1.2, \"sigma_E\": 0.5,\n            \"C_fn\": lambda n, q: np.empty((n, q))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p, n, q, k_true, k_est = case[\"p\"], case[\"n\"], case[\"q\"], case[\"k_true\"], case[\"k_est\"]\n        \n        # 1. Generate data\n        C = case[\"C_fn\"](n, q)\n        B = generate_matrix(case[\"s_B\"], p, q, case[\"sigma_B\"], LCG)\n        A = generate_matrix(case[\"s_A\"], p, k_true, case[\"sigma_A\"], LCG)\n        H_true = generate_matrix(case[\"s_H\"], n, k_true, 1.0, LCG)\n        E = generate_matrix(case[\"s_E\"], p, n, case[\"sigma_E\"], LCG)\n        \n        X = B @ C.T + A @ H_true.T + E\n        \n        # 2. Estimate latent batch subspace H_hat\n        I_n = np.identity(n)\n        P_C = projection_matrix(C)\n        M_C = I_n - P_C\n        R = X @ M_C\n        \n        if k_est > 0:\n            S_R = R.T @ R\n            eigvals, eigvecs = np.linalg.eigh(S_R)\n            top_k_indices = np.argsort(eigvals)[::-1][:k_est]\n            H_hat = eigvecs[:, top_k_indices]\n        else:\n            H_hat = np.empty((n, 0))\n\n        # 3. Form corrected data matrix X_corr\n        Q = np.hstack([C, H_hat])\n        P_Q = projection_matrix(Q)\n        M_Q = I_n - P_Q\n        \n        X_corr = X @ P_C + X @ M_Q\n\n        # 4. Evaluate batch variance fraction f\n        if k_true > 0:\n            P_H_true = projection_matrix(H_true)\n            numerator = np.linalg.norm(X_corr @ P_H_true)**2\n        else: # If k_true is 0, P_H_true is zero matrix, numerator is 0.\n            numerator = 0.0\n\n        denominator = np.linalg.norm(X_corr)**2\n\n        if denominator == 0.0:\n            f = 0.0 # If X_corr is zero, numerator must also be zero.\n        else:\n            f = numerator / denominator\n        \n        results.append(f)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2374389"}]}