{"hands_on_practices": [{"introduction": "理论联系实践是掌握复杂概念的最佳途径。为了深入理解基因集富集分析（Gene Set Enrichment Analysis, GSEA）的内在机制，我们将从一个简化的思想实验开始。通过分析一个仅含单个基因的基因集，我们可以剥离算法的复杂性，从而推导出一个清晰的富集分数（$ES$）解析表达式。这个练习旨在帮助你建立关于 GSEA 运行总和（running sum）如何随基因排序变化而变化的直观理解。[@problem_id:2393962]", "id": "2393962", "problem": "考虑将基因集富集分析（GSEA; Gene Set Enrichment Analysis）应用于一个基因排序列表。假设有一个包含$N$个不同基因的排序列表$\\mathcal{L}$，其排序从第$1$位（顶部）到第$N$位（底部）。假设基因集$\\mathcal{S}$只包含一个基因（因此$N_H = |\\mathcal{S}| = 1$），并且该基因在列表$\\mathcal{L}$中的排序位置为$k \\in \\{1,2,\\dots,N\\}$。使用指数为$p \\ge 0$的GSEA标准加权运行总和定义：当从$i=1$到$i=N$向下扫描列表时，将运行总和$R(i)$定义如下。如果排名第$i$的基因在$\\mathcal{S}$中，则$R(i)$增加$|r_i|^{p} / NR$，其中$NR = \\sum_{g \\in \\mathcal{S}} |r_g|^{p}$；如果它不在$\\mathcal{S}$中，则$R(i)$减少$1/(N - N_H)$。将富集分数$ES$定义为沿途遇到的运行总和的最大值，即，$ES = \\max_{1 \\le i \\le N} R(i)$。请将$ES$表示为仅包含$N$和$k$的封闭形式函数。无需进行数值计算或四舍五入，也无需报告单位。", "solution": "所述问题需要经过验证。\n\n**步骤1：提取已知条件**\n- 一个包含$N$个不同基因的排序列表$\\mathcal{L}$。排序从$1$到$N$。\n- 一个基因集$\\mathcal{S}$，其大小为$N_H = |\\mathcal{S}| = 1$。\n- $\\mathcal{S}$中的单个基因位于排序位置$k$处，其中 $k \\in \\{1, 2, \\dots, N\\}$。\n- GSEA指数为$p \\ge 0$。\n- 运行总和$R(i)$通过从$i=1$到$i=N$扫描计算得出。\n- 如果第$i$个基因在$\\mathcal{S}$中（一次“命中”），增量为$|r_i|^p / NR$。术语$r_i$表示排名第$i$的基因的相关性或度量值。\n- $NR$定义为$NR = \\sum_{g \\in \\mathcal{S}} |r_g|^p$。\n- 如果第$i$个基因不在$\\mathcal{S}$中（一次“未命中”），减量为$1/(N - N_H)$。\n- 富集分数是$ES = \\max_{1 \\le i \\le N} R(i)$。\n- 初始条件隐含为$R(0)=0$。\n\n**步骤2：使用已知条件进行验证**\n该问题具有科学依据，因为它基于已成熟的基因集富集分析（GSEA）方法。使用单个基因集（$N_H=1$）的设置是一种简化，使问题在分析上易于处理，但并未违反任何基本原则。该问题是适定的和客观的。\n\n关于相关值$r_i$的一个潜在歧义通过仔细检查定义得以解决。由于基因集$\\mathcal{S}$只包含一个基因，其排序为$k$，设其关联的度量值为$r_k$。那么归一化因子$NR$为$NR = \\sum_{g \\in \\mathcal{S}} |r_g|^p = |r_k|^p$。命中的增量（仅在步骤$i=k$时发生）计算为$|r_k|^p / NR = |r_k|^p / |r_k|^p = 1$。在度量值$r_k$非零的合理假设下，这对$p > 0$成立。对于$p=0$的情况，对应于未加权的GSEA统计量，增量为$|r_k|^0 / NR = 1 / \\sum_{g \\in \\mathcal{S}} |r_g|^0 = 1 / N_H = 1/1 = 1$。因此，对于任何$p \\ge 0$，命中时的增量恰好为$1$。\n\n未命中时的减量由$1/(N-N_H)$给出。当$N_H=1$时，这是$1/(N-1)$。如果$N=1$，该项是未定义的。但是，如果$N=1$，则$N_H=1$，并且“未命中”的集合为空。该问题隐含地假设$N > 1$以使减量步骤有意义，这是此类分析中的一个标准条件。因此，该问题被认为是自洽和一致的。\n\n**步骤3：结论与行动**\n问题有效。将推导解答。\n\n**解答推导**\n我们定义运行总和$R(i)$从$R(0)=0$开始。在每个步骤$j \\in \\{1, 2, \\dots, N\\}$中，运行总和的变化量为$\\Delta_j$。\n“命中”仅在排序位置$i=k$处发生。增量为$\\Delta_k = 1$。\n“未命中”在任何排序位置$i \\neq k$处发生。减量为$-\\frac{1}{N-N_H}$。由于$N_H=1$，减量为$-\\frac{1}{N-1}$。\n所以，如果$j=k$，则$\\Delta_j = 1$；如果$j \\neq k$，则$\\Delta_j = -\\frac{1}{N-1}$。\n\n步骤$i$处的运行总和由$R(i) = \\sum_{j=1}^{i} \\Delta_j$给出。我们根据$i$相对于$k$的值，分三种情况分析$R(i)$。\n\n情况1：$1 \\le i < k$。\n在此范围内，每一步都是“未命中”。\n$$R(i) = \\sum_{j=1}^{i} \\left(-\\frac{1}{N-1}\\right) = i \\left(-\\frac{1}{N-1}\\right) = -\\frac{i}{N-1}$$\n由于$i \\ge 1$且$N > 1$，此范围内的所有$R(i)$值均为负数。该函数随$i$严格递减。命中前一刻的值是$R(k-1) = -\\frac{k-1}{N-1}$。\n\n情况2：$i=k$。\n运行总和包括$k-1$次未命中和在步骤$k$处的一次命中。\n$$R(k) = R(k-1) + \\Delta_k = -\\frac{k-1}{N-1} + 1 = \\frac{-(k-1) + (N-1)}{N-1} = \\frac{N-k}{N-1}$$\n由于$1 \\le k \\le N$，我们有$0 \\le N-k \\le N-1$，因此$0 \\le R(k) \\le 1$。\n\n情况3：$k < i \\le N$。\n步骤$i$处的运行总和是步骤$k$处的总和加上从$k+1$到$i$所有步骤的减量。这样的步骤有$i-k$个，所有这些都是未命中。\n$$R(i) = R(k) + \\sum_{j=k+1}^{i} \\left(-\\frac{1}{N-1}\\right) = R(k) - \\frac{i-k}{N-1}$$\n代入$R(k)$的表达式：\n$$R(i) = \\frac{N-k}{N-1} - \\frac{i-k}{N-1} = \\frac{(N-k) - (i-k)}{N-1} = \\frac{N-i}{N-1}$$\n对于此范围$k < i \\le N$，随着$i$的增加，$N-i$减少，因此$R(i)$是$i$的严格递减函数。该数值序列从$R(k+1) = \\frac{N-(k+1)}{N-1}$开始，到$R(N) = \\frac{N-N}{N-1}=0$结束。\n\n为了找到富集分数，$ES = \\max_{1 \\le i \\le N} R(i)$，我们必须在$R(i)$的表达式中找到最大值。\n- 对于$1 \\le i < k$，$R(i) = -i/(N-1) < 0$。\n- 对于$i \\ge k$，当$i>k$时$R(i) = (N-i)/(N-1)$，且$R(k)=(N-k)/(N-1)$。由于$i>k$，则$N-i < N-k$，这意味着对于所有$i > k$（假设$N-1>0$），$R(i) < R(k)$。\n对于$i \\ge k$，$R(i)$的值序列为$R(k), R(k+1), \\dots, R(N)$，这是一个严格递减的序列。\n因此，在范围$i \\ge k$内的最大值是$R(k)$。\n由于当$i<k$时所有值都为负，且$R(k) \\ge 0$，因此在$1 \\le i \\le N$上的全局最大值必定是$R(k)$。\n\n因此，富集分数为：\n$$ES = R(k) = \\frac{N-k}{N-1}$$\n此表达式是仅依赖于$N$和$k$的封闭形式函数，符合要求。\n为了验证，如果该基因排名第一（$k=1$），则$ES = \\frac{N-1}{N-1} = 1$，这是可能的最大分数。如果该基因排名最后（$k=N$），则$ES = \\frac{N-N}{N-1} = 0$。在这种情况下，对于$i < N$，$R(i) = -i/(N-1)$，均为负值，而$R(N)=0$，因此最大值确实是$0$。结果是一致的。", "answer": "$$\\boxed{\\frac{N-k}{N-1}}$$"}, {"introduction": "在计算出富集分数后，我们必须评估其统计显著性。GSEA 通过置换检验（permutation testing）来生成一个零分布以评估观测到的 $ES$ 是否超出了偶然的范畴。然而，这种基于模拟的方法在统计精度上存在固有的局限性。本练习将引导你计算在给定置换次数下可能获得的最小非零 $p$ 值，这不仅是一个简单的计算，更揭示了所有基于置换的统计检验在分辨率上的一个根本性原理。[@problem_id:2393990]", "id": "2393990", "problem": "您正在使用基因集富集分析（GSEA）来分析一个差异表达实验。您通过将表型标签精确置换 $M = 10000$ 次，为富集得分生成了一个空分布。设 $b$ 表示对于一个给定的基因集，置换后的富集得分中其值至少与观测到的富集得分一样极端的得分数量。为避免在有限样本中出现概率估计为零的情况，您使用“加一”估计量来估计经验 $p$ 值：\n$$\n\\hat{p} \\;=\\; \\frac{b + 1}{M + 1}.\n$$\n假设使用此估计量，并且 $b$ 只能取非负整数值，那么当 $M = 10000$ 时，您能得到的 $\\hat{p}$ 的最小可能非零值是多少？请以精确分数形式表示您的答案，无需四舍五入。", "solution": "问题要求确定一个记为 $\\hat{p}$ 的估计经验 $p$ 值的最小可能非零值。该估计是在基因集富集分析（GSEA）的背景下，通过使用基于置换的空分布进行的。\n\n首先，我将对问题陈述进行验证。\n\n步骤1：提取已知条件。\n- 置换次数为 $M = 10000$。\n- 变量 $b$ 表示置换后的富集得分中其值至少与观测到的富集得分一样极端的得分数量。\n- 对 $b$ 的约束是它必须为非负整数，即 $b \\in \\{0, 1, 2, \\dots\\}$。\n- 经验 $p$ 值的估计量由公式 $\\hat{p} = \\frac{b + 1}{M + 1}$ 给出。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据。在生物信息学中，使用置换检验为富集得分生成空分布是一种标准且稳健的方法。所提供的估计量 $\\hat{p} = \\frac{b + 1}{M + 1}$ 是一种著名的技术，称为“加一”或拉普拉斯平滑规则，用于避免报告 $p$ 值为 $0$，而 $p$ 值为 $0$ 是有限抽样造成的一种人为结果。该问题提法得当，提供了所有必要信息，且没有矛盾。其语言客观明确。这是一个源于有效科学背景的直接数学问题。\n\n步骤3：结论与行动。\n该问题有效。我将继续进行解答。\n\n估计的 $p$ 值的表达式为\n$$\n\\hat{p} \\;=\\; \\frac{b + 1}{M + 1}\n$$\n我们已知置换次数为 $M = 10000$。将此值代入表达式可得：\n$$\n\\hat{p} \\;=\\; \\frac{b + 1}{10000 + 1} \\;=\\; \\frac{b + 1}{10001}\n$$\n问题陈述 $b$ 是一个非负整数。这意味着 $b$ 的可能取值集合为 $b \\in \\{0, 1, 2, 3, \\dots\\}$。\n\n题目要求我们找到 $\\hat{p}$ 的最小可能非零值。$\\hat{p}$ 的值是 $b$ 的函数。分母 $10001$ 是一个正常数。因此，为了最小化分数 $\\hat{p}$ 的值，我们必须最小化其分子 $b + 1$ 的值。\n\n当 $b$ 本身取最小值时，表达式 $b+1$ 也取最小值。根据问题的约束条件，非负整数 $b$ 的最小可能值为 $0$。\n\n让我们将 $b$ 的最小值代入 $\\hat{p}$ 的表达式中：\n当 $b = 0$ 时，\n$$\n\\hat{p}_{min} \\;=\\; \\frac{0 + 1}{10001} \\;=\\; \\frac{1}{10001}\n$$\n这个值 $\\frac{1}{10001}$ 显然非零。对于 $b$ 的任何其他允许值，例如 $b=1, 2, 3, \\dots$，分子 $b+1$ 都会更大。例如，如果 $b=1$, 那么 $\\hat{p} = \\frac{1+1}{10001} = \\frac{2}{10001}$。由于对于所有 $b > 0$ 的情况，都有 $\\frac{1}{10001} < \\frac{2}{10001}$ 等，因此为 $b=0$ 计算出的值确实是 $\\hat{p}$ 的最小可能值。\n\n问题要求答案以精确分数形式给出，而 $\\frac{1}{10001}$ 正是精确分数。", "answer": "$$\\boxed{\\frac{1}{10001}}$$"}, {"introduction": "现在，让我们将理论知识付诸实践，在一个综合性的编程任务中融会贯通。你将实现一个 GSEA 算法的变体，该算法引入了一种新颖的权重调整机制，以降低那些参与多个生物通路的“滥 promiscuous”基因的影响。这项挑战需要你将 GSEA 的数学框架精确地转化为功能代码，这将极大地巩固你对整个分析流程的全面掌握，并提升你解决实际生物信息学问题的能力。[@problem_id:2393970]", "id": "2393970", "problem": "给定一个长度为 $N$ 的基因排序列表，其排序分数为实值 $\\{r_{1}, r_{2}, \\ldots, r_{N}\\}$，一个索引子集 $S \\subseteq \\{1,2,\\ldots,N\\}$，表示一个候选基因集，以及一个正整数向量 $\\{d_{1}, d_{2}, \\ldots, d_{N}\\}$，其中 $d_{i}$ 是基因 $i$ 注释到的不同通路的数量。根据以下规则，定义一个修正的富集运行总和，该方法对出现在许多通路中的基因进行降权。\n\n设 $k = |S|$。对于参数 $p \\ge 0$ 和 $\\beta \\ge 0$，定义命中权重\n$$\nw_{i} =\n\\begin{cases}\n\\displaystyle \\frac{|r_{i}|^{p}}{d_{i}^{\\beta}}, & \\text{若 } i \\in S,\\\n$$6pt]\n0, & \\text{若 } i \\notin S,\n\\end{cases}\n\\quad\\text{且}\\quad\nW = \\sum_{i \\in S} w_{i}.\n$$\n对于 $k \\in \\{1,2,\\ldots,N-1\\}$，将未命中步长定义为 $a = \\dfrac{1}{N-k}$。运行总和 $\\{S_{j}\\}_{j=0}^{N}$ 定义为 $S_{0} = 0$，并且对于 $j = 1,2,\\ldots,N$，\n$$\nS_{j} =\n\\begin{cases}\nS_{j-1} + \\dfrac{w_{j}}{W}, & \\text{若 } j \\in S,\\\n$$6pt]\nS_{j-1} - a, & \\text{若 } j \\notin S.\n\\end{cases}\n$$\n将富集分数定义为有符号的极端偏差\n$$\n\\mathrm{ES} =\n\\begin{cases}\n\\max_{1 \\le j \\le N} S_{j}, & \\text{若 } \\left|\\max_{1 \\le j \\le N} S_{j}\\right| \\ge \\left|\\min_{1 \\le j \\le N} S_{j}\\right|,\\\n$$6pt]\n\\min_{1 \\le j \\le N} S_{j}, & \\text{其他情况}.\n\\end{cases}\n$$\n对于边界情况，如果 $k = 0$ 则定义 $\\mathrm{ES} = -1$，如果 $k = N$ 则定义 $\\mathrm{ES} = +1$。$S$ 中的所有索引都应解释为相对于排序顺序 $\\{r_{1}, \\ldots, r_{N}\\}$ 的基于1的位置。\n\n您的任务是实现一个程序，为以下每个测试用例计算 $\\mathrm{ES}$，并打印四舍五入到六位小数的结果。最终输出必须是一行，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例相同。不应打印任何额外文本。\n\n测试套件 (每个测试用例列出 $N$、序列 $\\{r_{i}\\}$、集合 $S$、度 $\\{d_{i}\\}$以及参数 $p$ 和 $\\beta$):\n\n- 测试用例 (1): $N = 10$; $\\{r_{i}\\} = [\\,5,4,3,2,1,-1,-2,-3,-4,-5\\,]$; $S = \\{\\,1,4,7\\,\\}$; $\\{d_{i}\\} = [\\,1,1,1,1,1,1,1,1,1,1\\,]$; $p = 0$; $\\beta = 0$。\n- 测试用例 (2): $N = 10$; $\\{r_{i}\\} = [\\,5,4,3,2,1,-1,-2,-3,-4,-5\\,]$; $S = \\{\\,1,4,7\\,\\}$; $\\{d_{i}\\} = [\\,1,1,1,10,1,1,1,1,1,1\\,]$; $p = 0$; $\\beta = 1$。\n- 测试用例 (3): $N = 10$; $\\{r_{i}\\} = [\\,5,4,3,2,1,-1,-2,-3,-4,-5\\,]$; $S = \\{\\,2,3,10\\,\\}$; $\\{d_{i}\\} = [\\,1,1,2,1,1,1,1,1,1,1\\,]$; $p = 1$; $\\beta = 1$。\n- 测试用例 (4): $N = 5$; $\\{r_{i}\\} = [\\,2,1,0,-1,-2\\,]$; $S = \\varnothing$; $\\{d_{i}\\} = [\\,1,1,1,1,1\\,]$; $p = 1$; $\\beta = 1$。\n- 测试用例 (5): $N = 6$; $\\{r_{i}\\} = [\\,6,5,4,3,2,1\\,]$; $S = \\{\\,1,2,3,4,5,6\\,\\}$; $\\{d_{i}\\} = [\\,1,1,1,1,1,1\\,]$; $p = 0$; $\\beta = 2$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个结果是对应测试用例的富集分数，并四舍五入到六位小数（例如，$[\\,0.123456,-0.500000,1.000000\\,]$）。角度和物理单位不适用于此问题。所有答案都必须表示为小数点后有六位数字的实数。", "solution": "所呈现的问题是基因集富集分析 (Gene Set Enrichment Analysis, GSEA) 的一个变体，这是生物信息学中一种计算方法，用于确定一个预定义的基因集在两种生物学状态之间是否显示出统计上显著的一致性差异。该问题具有科学依据、定义明确，并且为获得唯一解提供了所有必要的参数和公式。因此，它被认为是有效的。\n\n核心任务是为几个测试用例计算一个修正的富集分数 ($\\mathrm{ES}$)。计算过程如下：\n\n首先，我们处理两个边界条件。基因集的大小表示为 $k = |S|$，排序基因的总数为 $N$。\n- 如果基因集 $S$ 为空 ($k=0$)，则 $\\mathrm{ES}$ 定义为 $-1$。这代表最大负富集，因为该集合中没有任何基因出现在排序列表中。\n- 如果基因集 $S$ 包含所有基因 ($k=N$)，则 $\\mathrm{ES}$ 定义为 $+1$。这代表最大正富集。\n\n对于主要情况，即 $0 < k < N$，计算涉及构建一个运行总和。步骤如下：\n\n1.  **计算命中权重**：对于从 $1$ 到 $N$ 的排序列表中的每个基因 $i$，计算一个权重 $w_i$。问题规定 $S$ 中的索引是基于1的。如果基因 $i$ 在基因集 $S$ 中，其权重是其排序分数 $r_i$、其度 $d_i$（它所属的通路数量）以及两个非负参数 $p$ 和 $\\beta$ 的函数。公式为：\n    $$\n    w_{i} = \\frac{|r_{i}|^{p}}{d_{i}^{\\beta}}, \\quad \\text{若 } i \\in S\n    $$\n    参数 $p$ 控制排序分数的影响；更高的 $p$ 会给得分更高的基因更多权重。参数 $\\beta$ 对参与多个通路的“滥交”基因进行降权。如果基因 $i$ 不在集合 $S$ 中，其权重为零，即 $w_i=0$。需要注意的是，在实现中，必须将用于 $i \\in S$ 的基于1的索引映射到用于数组访问的基于0的索引。\n\n2.  **归一化权重**：然后对各个命中权重进行归一化。首先，我们计算集合 $S$ 中所有基因的权重之和：\n    $$\n    W = \\sum_{i \\in S} w_{i}\n    $$\n    如果 $W=0$（这可能在 $p > 0$ 且 $S$ 中所有基因的 $r_i=0$ 时发生），命中增量将是未定义的。然而，所提供的测试用例没有遇到这种情况。对于 $p=0$ 且假设 $0^0=1$，$w_i=1/d_i^\\beta$，因为 $d_i$ 是正整数，所以这总是正的。因此，可以保证 $W$ 是正数。\n\n3.  **定义步长**：运行总和在“命中”（基因在 $S$ 中）时增加，在“未命中”（基因不在 $S$ 中）时减少。\n    - 对于基因 $j \\in S$ 的**命中步长**是其归一化权重：$\\dfrac{w_{j}}{W}$。\n    - **未命中步长**是一个恒定的惩罚，计算为：$a = \\dfrac{1}{N-k}$，其中 $N-k$ 是不在集合 $S$ 中的基因数量。\n\n4.  **计算运行总和**：运行总和 $\\{S_j\\}_{j=0}^{N}$ 从 $S_0=0$ 开始。它对从 1 到 $N$ 的每个基因 $j$ 进行迭代更新：\n    $$\n    S_{j} =\n    \\begin{cases}\n    S_{j-1} + \\dfrac{w_{j}}{W}, & \\text{若 } j \\in S \\\\\n    S_{j-1} - a, & \\text{若 } j \\notin S\n    \\end{cases}\n    $$\n    这个过程生成一个数值序列 $S_1, S_2, \\ldots, S_N$。\n\n5.  **确定富集分数 ($\\mathrm{ES}$)**：$\\mathrm{ES}$ 是运行总和与零的最大偏差。它被定义为运行总和序列 $\\{S_j\\}_{j=1}^{N}$ 的有符号极值：\n    $$\n    \\mathrm{ES} =\n    \\begin{cases}\n    \\max_{1 \\le j \\le N} S_{j}, & \\text{若 } \\left|\\max_{1 \\le j \\le N} S_{j}\\right| \\ge \\left|\\min_{1 \\le j \\le N} S_{j}\\right| \\\\\n    \\min_{1 \\le j \\le N} S_{j}, & \\text{其他情况}\n    \\end{cases}\n    $$\n    这个值量化了基因集 $S$ 在整个基因排序列表的极端（顶部或底部）的过度表现程度。正的 $\\mathrm{ES}$ 表示在排序列表顶部的富集，而负的 $\\mathrm{ES}$ 表示在底部的富集。\n\n实现将遵循这些步骤，为每个提供的测试用例处理数据结构和索引转换（从基于1到基于0）。最终的数值结果将按规定四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_es(N, r, S, d, p, beta):\n    \"\"\"\n    Calculates the modified Enrichment Score (ES).\n\n    Args:\n        N (int): Total number of genes.\n        r (list or np.array): Real-valued ranking scores.\n        S (set): 1-based indices of genes in the candidate set.\n        d (list or np.array): Positive integer degrees for each gene.\n        p (float): Exponent for the ranking score.\n        beta (float): Exponent for the degree.\n\n    Returns:\n        float: The calculated Enrichment Score.\n    \"\"\"\n    k = len(S)\n\n    # Handle boundary cases\n    if k == 0:\n        return -1.0\n    if k == N:\n        return 1.0\n\n    # Convert to numpy arrays for vectorized operations\n    r = np.array(r, dtype=float)\n    d = np.array(d, dtype=float)\n\n    # Convert 1-based set S to 0-based indices for array access\n    S_0based = {idx - 1 for idx in S}\n\n    # Calculate weights for genes in the set S\n    weights = np.zeros(N)\n    for idx in S_0based:\n        # Note: np.power(0, 0) correctly evaluates to 1.\n        weights[idx] = (np.abs(r[idx])**p) / (d[idx]**beta)\n    \n    W = np.sum(weights)\n    \n    # If W is zero, hits have no contribution. This case is not specified\n    # but based on test cases, it is not expected.\n    if W == 0:\n        # Fallback logic assumes runningsum only decreases.\n        # This part is an assumption as it is not specified in the problem.\n        # But for the given test cases, W is never zero for 0 < k < N.\n        miss_step = 1.0 / (N - k)\n        return -N * miss_step\n        \n    hit_increments = weights / W\n    miss_decrement = 1.0 / (N - k)\n\n    running_sum = 0.0\n    running_sum_values = []\n\n    for j in range(N):\n        if j in S_0based:\n            running_sum += hit_increments[j]\n        else:\n            running_sum -= miss_decrement\n        running_sum_values.append(running_sum)\n    \n    max_dev = np.max(running_sum_values)\n    min_dev = np.min(running_sum_values)\n\n    if np.abs(max_dev) >= np.abs(min_dev):\n        return max_dev\n    else:\n        return min_dev\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test case (1): N, r, S, d, p, beta\n        (10, [5, 4, 3, 2, 1, -1, -2, -3, -4, -5], {1, 4, 7}, [1]*10, 0, 0),\n        # Test case (2)\n        (10, [5, 4, 3, 2, 1, -1, -2, -3, -4, -5], {1, 4, 7}, [1, 1, 1, 10, 1, 1, 1, 1, 1, 1], 0, 1),\n        # Test case (3)\n        (10, [5, 4, 3, 2, 1, -1, -2, -3, -4, -5], {2, 3, 10}, [1, 1, 2, 1, 1, 1, 1, 1, 1, 1], 1, 1),\n        # Test case (4)\n        (5, [2, 1, 0, -1, -2], set(), [1]*5, 1, 1),\n        # Test case (5)\n        (6, [6, 5, 4, 3, 2, 1], {1, 2, 3, 4, 5, 6}, [1]*6, 0, 2)\n    ]\n\n    results = []\n    for N, r, S, d, p, beta in test_cases:\n        es_score = calculate_es(N, r, S, d, p, beta)\n        results.append(f\"{es_score:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}