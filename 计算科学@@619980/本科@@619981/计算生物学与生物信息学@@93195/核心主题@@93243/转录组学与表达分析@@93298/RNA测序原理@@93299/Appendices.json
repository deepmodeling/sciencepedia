{"hands_on_practices": [{"introduction": "RNA测序量化的是转录本的相对丰度，而非绝对数量。本练习通过一个假设场景，阐释了这一事实的一个重要推论——“组分性伪影”（compositional artifact）。通过计算当一个基因被大规模过表达时，其他表达稳定的基因所表现出的表观变化，您将亲身体会到为何简单的总数归一化方法可能产生误导，并理解为何在差异表达分析中必须采用更先进的归一化策略。[@problem_id:2417849]", "problem": "一名实验者对两种条件（$A$ 和 $B$）进行RNA测序 (RNA-seq)，每个样本使用相同数量的细胞，且不使用外部对照或spike-in。每个文库被精确测序到 $100000$ 个比对上的读数。该实验产生的读数计数，在期望上，与文库中每个基因贡献的转录本分子比例成正比。实验者采用标准的总计数缩放归一化方法（每百万计数，CPM），即用每个基因的计数除以样本的总比对读数，从而比较相对丰度。\n\n考虑一个基因集，包含一个基因 $X$ 和另外 $990$ 个基因。每个细胞中真实的绝对转录本分子数如下：\n\n- 在条件 $A$ 中：基因 $X$ 有 $1000$ 个分子；其他 $990$ 个基因每个有 $100$ 个分子。\n- 在条件 $B$ 中：基因 $X$ 强烈过表达，有 $50000$ 个分子；其他 $990$ 个基因每个仍为 $100$ 个分子。\n\n假设测序过程按这些基础的转录本比例进行读数抽样，并忽略抽样方差。实验者使用 $B$ 和 $A$ 之间的CPM归一化值计算以2为底的倍数变化对数。\n\n在这种归一化方法下，对于任何一个未发生变化的其他基因（非 $X$），哪个选项最能描述其表观的以2为底的倍数变化对数，并说明原因？\n\nA. 对于大多数其他基因，约为 $-0.58$，因为在条件 $B$ 中，单个高丰度基因 $X$ 降低了所有未变化基因的相对比例，使得它们在总计数归一化下表现为下调。\n\nB. 对于大多数其他基因，约为 $0$，因为总计数归一化完全消除了单个基因过表达引起的组成效应。\n\nC. 对于大多数其他基因，约为 $+0.58$，因为条件 $B$ 中总RNA含量的大幅增加提高了所有归一化后的计数。\n\nD. 这取决于测序深度；将读数从 $100000$ 增加到 $200000$ 将使大多数其他基因在总计数归一化下的表观以2为底的倍数变化趋向于 $0$。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 实验：对两种条件 $A$ 和 $B$ 进行RNA测序。\n- 重复：问题描述了两个样本，每个条件一个。每个样本的细胞数相同。\n- 对照：未使用外部对照或spike-in。\n- 测序深度：每个文库被精确测序到 $100000$ 个比对上的读数。\n- 实验原理：读数计数，在期望上，与每个基因的转录本分子比例成正比。\n- 归一化：总计数缩放（每百万计数，CPM），定义为用每个基因的计数除以样本的总比对读数并进行缩放。\n- 基因集：一个基因 $X$ 和另外 $990$ 个基因。\n- 真实绝对丰度（分子数/细胞）：\n    - 条件 $A$：基因 $X$ 有 $1000$ 个分子。其他 $990$ 个基因每个有 $100$ 个分子。\n    - 条件 $B$：基因 $X$ 有 $50000$ 个分子。其他 $990$ 个基因每个有 $100$ 个分子。\n- 假设：\n    1. 测序按基础的转录本比例进行读数抽样。\n    2. 忽略抽样方差。\n- 问题：使用CPM归一化值，计算在比较条件 $B$ 和条件 $A$ 时，任何一个未变化基因的表观以2为底的倍数变化对数。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了组成型数据分析中的一个典型且根本性的问题，这是RNA-seq实验的特征。在总计数归一化下，一个高表达基因扭曲其他基因相对丰度的概念是生物信息学中一个公认的人为假象。其原理是科学合理的。\n- **良构性**：问题是良构的。它提供了所有必要的数值数据和一个清晰、无歧义的问题，可以通过直接计算得到唯一解。\n- **客观性**：问题以精确、客观的语言陈述，没有主观论断或含糊之处。\n\n**步骤3：结论与行动**\n问题陈述是有效的。这是一个标准的、尽管简化了的模型，用以说明转录组学中简单归一化方法的缺陷。我将继续推导解决方案。\n\n**推导**\n\n所述RNA-seq实验的核心先验假设是，比对到某个基因的读数数量与样本中其转录本的总数成正比。由于我们忽略抽样方差，我们将此比例关系视为精确关系。让我们将这 $990$ 个未变化基因集中的任意一个基因表示为基因 $Y$。\n\n1.  **计算每种条件下每个细胞的总转录本分子数：**\n    每个细胞的总分子数用作计算每个基因分子分数的的分母。\n    -   在条件 $A$ 中，总分子数 $T_A$ 为：\n        $$T_A = (\\text{molecules of } X) + (990 \\times \\text{molecules of other genes}) = 1000 + (990 \\times 100) = 1000 + 99000 = 100000 \\text{ molecules}$$\n    -   在条件 $B$ 中，总分子数 $T_B$ 为：\n        $$T_B = (\\text{molecules of } X) + (990 \\times \\text{molecules of other genes}) = 50000 + (990 \\times 100) = 50000 + 99000 = 149000 \\text{ molecules}$$\n\n2.  **计算基因 $Y$ 在每种条件下的预期读数计数：**\n    一个基因的预期读数计数是文库中总比对读数乘以该基因的分子分数。\n    -   在条件 $A$ 中，基因 $Y$ 的分子分数为 $f_{Y,A} = \\frac{100}{T_A} = \\frac{100}{100000}$。基因 $Y$ 的预期读数计数 $C_{Y,A}$ 是：\n        $$C_{Y,A} = (\\text{Total Reads}) \\times f_{Y,A} = 100000 \\times \\frac{100}{100000} = 100\n        $$\n    -   在条件 $B$ 中，基因 $Y$ 的分子分数为 $f_{Y,B} = \\frac{100}{T_B} = \\frac{100}{149000}$。基因 $Y$ 的预期读数计数 $C_{Y,B}$ 是：\n        $$C_{Y,B} = (\\text{Total Reads}) \\times f_{Y,B} = 100000 \\times \\frac{100}{149000} \\approx 67.114\n        $$\n\n3.  **计算CPM归一化值和倍数变化：**\n    CPM归一化公式为 $CPM = \\frac{\\text{Gene Count}}{\\text{Total Mapped Reads}} \\times 10^6$。我们需要计算基因 $Y$ 在条件 $B$ 和 $A$ 之间的CPM值的倍数变化。\n\n    -   $CPM_{Y,A} = \\frac{C_{Y,A}}{\\text{Total Reads}_A} \\times 10^6 = \\frac{100}{100000} \\times 10^6 = 1000$\n    -   $CPM_{Y,B} = \\frac{C_{Y,B}}{\\text{Total Reads}_B} \\times 10^6 = \\frac{100000 \\times \\frac{100}{149000}}{100000} \\times 10^6 = \\frac{100}{149000} \\times 10^6 \\approx 671.14$\n\n    归一化值的倍数变化（$FC$）是比率 $\\frac{CPM_{Y,B}}{CPM_{Y,A}}$。\n    $$FC = \\frac{CPM_{Y,B}}{CPM_{Y,A}} = \\frac{\\frac{100}{149000} \\times 10^6}{\\frac{100}{100000} \\times 10^6} = \\frac{100000}{149000} \\approx 0.67114$$\n    注意，缩放因子 $10^6$ 和相同的总比对读数会抵消，因此CPM值的倍数变化等同于原始计数的比率，而这又等同于基础分子分数的比率。\n\n4.  **计算以2为底的倍数变化对数：**\n    问题要求的是以2为底的倍数变化对数。\n    $$\\log_2(FC) = \\log_2\\left(\\frac{100000}{149000}\\right) \\approx \\log_2(0.67114)$$\n    $$\\log_2(FC) \\approx -0.5753$$\n    这个值约等于 $-0.58$。\n\n**逐项分析**\n\n-   **A. 对于大多数其他基因，约为 $-0.58$，因为在条件 $B$ 中，单个高丰度基因 $X$ 降低了所有未变化基因的相对比例，使得它们在总计数归一化下表现为下调。**\n    -   计算出的值 $\\approx -0.5753$ 与所述的约 $-0.58$ 的值相匹配。\n    -   所提供的理由完全正确。在条件 $B$ 中，基因 $X$ 转录本的大量增加夸大了用于计算相对丰度的分母（$T_B$）。因此，所有其他绝对分子数未变的基因的读数相对比例必然会减少。总计数归一化使这种扭曲持续存在，导致得出这些基因被下调的人为结论。\n    -   **结论：正确。**\n\n-   **B. 对于大多数其他基因，约为 $0$，因为总计数归一化完全消除了单个基因过表达引起的组成效应。**\n    -   计算显示了一个非零值。\n    -   这个理由根本上是错误的。总计数归一化（如CPM）是将这种组成性假象*引入*到最终报告值中的方法。它不能消除这种效应，反而对其很敏感。对这种假象具有鲁棒性的方法，如TMM或RLE，是基于大多数基因*没有*差异表达的假设，而总计数归一化没有使用这个假设。\n    -   **结论：不正确。**\n\n-   **C. 对于大多数其他基因，约为 $+0.58$，因为条件 $B$ 中总RNA含量的大幅增加提高了所有归一化后的计数。**\n    -   符号不正确。计算得出了一个负的对数倍数变化，表明表观下调。\n    -   这个理由是有缺陷的。虽然条件 $B$ 中的总RNA含量增加，但归一化后的计数是总数的*分数*。当分母（总RNA含量）增加而一个基因的分子（其自身的RNA含量）保持不变时，得到的分数会*减小*。\n    -   **结论：不正确。**\n\n-   **D. 这取决于测序深度；将读数从 $100000$ 增加到 $200000$ 将使大多数其他基因在总计数归一化下的表观以2为底的倍数变化趋向于 $0$。**\n    -   表观的对数倍数变化是由*相对分子分数*的比率决定的，而不是由绝对读数数量决定的。如推导所示，在计算CPM归一化值之间的倍数变化时，只要比较的两个样本的测序深度相同，总测序深度就是一个可以完全抵消的缩放因子。如果我们将两个样本的深度都从 $100000$ 改变为 $200000$，CPM值将保持不变，因此倍数变化也将保持不变。这是一个组成问题，而非测序深度问题。\n    -   **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2417849"}, {"introduction": "主成分分析（Principal Component Analysis, PCA）图和MA图是可视化和诊断高维RNA测序数据不可或缺的工具。本练习是一个思想实验，旨在通过预测一个常见错误——样本标签互换——的后果，来考察您对这些方法的根本理解。通过剖析这一错误如何分别影响无监督方法（PCA）和有监督的比较图（MA图），您将锻炼自己的数据解读和问题排查能力。[@problem_id:2417787]", "problem": "您进行了一项核糖核酸测序 (RNA-seq) 实验，其中包含对照组和处理组样本。在经过质量控制、标准化和标准的差异表达建模后，您生成了一张主成分分析 (PCA) 图用于探索性评估，以及一张 M-versus-A (MA) 图用于展示差异表达结果。之后您发现，在分析流程开始时，您不小心将对照组和处理组的样本标签互换了。假设不存在批次效应或混杂因素，并且测序深度和标准化是适当的，因此两组之间的主要生物学差异是变异的主要来源。哪项陈述最能描述在这种错误下，您预期在 PCA 图和 MA 图中看到的情况？\n\nA. PCA 图仍会显示样本清晰地分离成两个聚类，但注释会表明，原先认为是“对照组”的聚类实际上对应于真正的“处理组”，反之亦然；MA 图会呈现为沿水平轴的镜像，即在处理组中真正上调的基因现在会显示为以相似幅度下调，反之亦然。\n\nB. PCA 图将不会在两个已注释的组之间显示任何分离，因为标签互换破坏了聚类；而 MA 图将保持不变，因为它基于平均表达量而非标签。\n\nC. PCA 图将保留其聚类结构，但坐标轴会互换顺序；而 MA 图将在中心周围显示出更大的散布，但会保留倍数变化的原始方向。\n\nD. 由于标签互换，PCA 图将翻转主成分的符号；而 MA 图将向上平移一个恒定的偏移量，但哪些基因在中心线上方或下方的情况不会改变。", "solution": "第一项任务是严格验证问题陈述。\n\n**步骤1：提取已知条件**\n- **系统**：一项核糖核酸测序 (RNA-seq) 实验。\n- **分组**：对照组和处理组样本。\n- **分析步骤**：质量控制、标准化、标准的差异表达建模。\n- **可视化**：一张主成分分析 (PCA) 图和一张 M-versus-A (MA) 图。\n- **错误**：在分析开始时，‘对照组’和‘处理组’的样本标签被互换。\n- **假设**：\n    1. 无批次效应或混杂因素。\n    2. 测序深度和标准化是适当的。\n    3. 两组之间的生物学差异是变异的主要来源。\n- **问题**：描述在标签互换的错误下，PCA 图和 MA 图的预期外观。\n\n**步骤2：使用提取的已知条件进行验证**\n根据科学和逻辑原则对问题进行审视。\n- **科学依据**：该问题描述了生物信息学中的一个标准场景。RNA-seq、PCA 和 MA 图是分析基因表达数据的基本且成熟的方法。所描述的错误——互换样本标签——是数据分析流程中一种可能发生的常见人为失误。所涉及的原理来自统计学和计算生物学，并且完全合理。\n- **问题定义明确**：问题具体而明确。它要求在一系列简化但明确陈述的假设（例如，无混杂因素）下，一个已定义的错误对标准输出产生的确定性后果。基于这些假设，可以推导出一个唯一的、合乎逻辑的解决方案。\n- **客观性**：问题以精确、技术性的语言陈述，不含主观性或个人观点。诸如‘PCA 图’、‘MA 图’、‘上调’和‘下调’等术语在该领域具有标准的、正式的定义。\n\n问题陈述没有缺陷。它在科学上不是不合理的，也不是非形式化的、不完整的或定义不明确的。这是一个在计算生物学领域有效且表述良好的问题。\n\n**步骤3：结论与行动**\n该问题是**有效的**。我们可以继续进行解答。\n\n**解答的推导**\n\n我们必须根据 PCA 图和 MA 图各自的数学定义，分别分析标签互换对它们的影响。\n\n**1. 主成分分析 (PCA) 图**\nPCA 是一种无监督的降维技术。其目的是识别数据集中方差最大的方向，而不考虑数据点上任何预先存在的标签。\n\n设基因表达数据由一个维度为 $n \\times p$ 的矩阵 $\\mathbf{X}$ 表示，其中 $n$ 是样本数量，$p$ 是基因数量。每一行代表一个样本的基因表达谱。\n\nPCA 对 $\\mathbf{X}$ 的协方差（或相关）矩阵进行操作。主成分是该矩阵的特征向量。每个样本在 PCA 图中的坐标是其数据向量在这些特征向量上的投影。\n\n至关重要的是，整个计算过程——协方差矩阵、其特征向量（主成分）以及数据在这些主成分上的投影——仅依赖于数据矩阵 $\\mathbf{X}$。它不使用样本标签（‘对照组’或‘处理组’）。因此，互换标签对 PCA 图中数据点的位置**没有影响**。样本的几何排列得以保留。\n\n如果如问题所假设，主要的生物学差异是变异的主要来源，那么样本将在前几个主成分（很可能是 PC1）上形成两个不同的聚类。我们称这两个几何聚类为 $\\text{Cluster}_1$ 和 $\\text{Cluster}_2$。在正确的分析中，$\\text{Cluster}_1$ 会被注释为‘对照组’，$\\text{Cluster}_2$ 会被注释为‘处理组’（或反之）。在互换标签后，$\\text{Cluster}_1$ 中的点现在被错误地标记为‘处理组’，而 $\\text{Cluster}_2$ 中的点被错误地标记为‘对照组’。视觉上的聚类保持完全相同；只是注释被互换了。\n\n**2. M-versus-A (MA) 图**\nMA 图是用于可视化差异表达结果的工具。对于每个基因，它绘制两个量：\n- **M-值**（y轴），代表 log-倍数变化：\n$$M = \\log_2\\left(\\frac{\\text{处理组中的平均表达量}}{\\text{对照组中的平均表达量}}\\right)$$\n- **A-值**（x轴），代表平均 log 表达量：\n$$A = \\frac{1}{2} \\log_2(\\text{处理组中的平均表达量} \\times \\text{对照组中的平均表达量})$$\n\n设 $\\bar{E}_{\\text{treat}}$ 和 $\\bar{E}_{\\text{control}}$ 分别为某个给定基因在处理组和对照组中的真实平均表达量。正确的 M 和 A 值为：\n$$M_{\\text{correct}} = \\log_2(\\bar{E}_{\\text{treat}}) - \\log_2(\\bar{E}_{\\text{control}})$$\n$$A_{\\text{correct}} = \\frac{1}{2}(\\log_2(\\bar{E}_{\\text{treat}}) + \\log_2(\\bar{E}_{\\text{control}}))$$\n\n当标签被互换时，分析流程会将真正的对照组视为‘处理组’，而将真正的处理组视为‘对照组’。在这种错误下计算出的 M 和 A 值，我们称之为 $M_{\\text{mistake}}$ 和 $A_{\\text{mistake}}$，为：\n$$M_{\\text{mistake}} = \\log_2(\\bar{E}_{\\text{control}}) - \\log_2(\\bar{E}_{\\text{treat}}) = -(\\log_2(\\bar{E}_{\\text{treat}}) - \\log_2(\\bar{E}_{\\text{control}})) = -M_{\\text{correct}}$$\n$$A_{\\text{mistake}} = \\frac{1}{2}(\\log_2(\\bar{E}_{\\text{control}}) + \\log_2(\\bar{E}_{\\text{treat}})) = A_{\\text{correct}}$$\n\n这个推导表明，对于每个基因，A-值（x坐标）保持不变，而 M-值（y坐标）的符号被翻转。在几何上，这对应于整个图沿水平轴 $M=0$ 的反射。一个真正上调的基因（$M_{\\text{correct}} > 0$）现在会表现为以相同的幅度下调（$M_{\\text{mistake}} < 0$），反之亦然。\n\n**逐项分析选项**\n\n- **A.** “PCA 图仍会显示样本清晰地分离成两个聚类，但注释会表明，原先认为是“对照组”的聚类实际上对应于真正的“处理组”，反之亦然；MA 图会呈现为沿水平轴的镜像，即在处理组中真正上调的基因现在会显示为以相似幅度下调，反之亦然。”\n  - **PCA 部分**：这正确地描述了 PCA 作为一种无监督方法，会保留聚类结构，只有注释受到影响。\n  - **MA 部分**：这正确地描述了沿 $M=0$ 轴的镜像反射，其中 $M_{\\text{mistake}} = -M_{\\text{correct}}$。\n  - **结论**：**正确**。\n\n- **B.** “PCA 图将不会在两个已注释的组之间显示任何分离，因为标签互换破坏了聚类；而 MA 图将保持不变，因为它基于平均表达量而非标签。”\n  - **PCA 部分**：不正确。标签互换不影响像 PCA 这样的无监督方法中的数据位置或聚类。\n  - **MA 部分**：不正确。M-值是一个 log-比率，它根本上取决于哪个组是分子，哪个是分母。互换标签会使这个比率倒置。\n  - **结论**：**不正确**。\n\n- **C.** “PCA 图将保留其聚类结构，但坐标轴会互换顺序；而 MA 图将在中心周围显示出更大的散布，但会保留倍数变化的原始方向。”\n  - **PCA 部分**：不正确。主成分（坐标轴）由数据协方差决定，不受标签影响。它们的顺序不会改变。\n  - **MA 部分**：不正确。倍数变化的方向被翻转，而不是保留。没有理由预期“更大的散布”；这种变换是一种精确的镜像反射。\n  - **结论**：**不正确**。\n\n- **D.** “由于标签互换，PCA 图将翻转主成分的符号；而 MA 图将向上平移一个恒定的偏移量，但哪些基因在中心线上方或下方的情况不会改变。”\n  - **PCA 部分**：不正确。互换标签不影响从数据矩阵计算主成分的过程。虽然任何特征向量的符号是任意的，但标签互换不会导致系统性的符号翻转。\n  - **MA 部分**：不正确。该图是镜像反射（$M \\rightarrow -M$），而不是通过一个常量进行平移（$M \\rightarrow M+c$）。镜像反射绝对会改变哪些基因在中心线 $M=0$ 的上方或下方。\n  - **结论**：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2417787"}, {"introduction": "在真实的实验中，被称为“批次效应”（batch effects）的技术性变异往往会掩盖真实的生物学信号。这项进阶练习将指导您实现一种基于线性模型的、有原则的批次效应校正方法。通过将每个基因的表达量（$y_{g,i}$）精确地建模为生物学条件（$z_i$）和实验批次（$b_i$）的函数，您将学会如何估算并从计算上移除不必要的变异，这是进行稳健生物信息学分析的一项基本技能。[@problem_id:2417834]", "problem": "您的任务是，形式化并实现一种有原则的方法，以使用线性模型去除核糖核酸测序 (RNA-seq) 数据中的批次效应。考虑一个计数矩阵，其中基因由 $g \\in \\{1,\\dots,G\\}$ 索引，样本由 $i \\in \\{1,\\dots,N\\}$ 索引。设 $c_{g,i} \\in \\mathbb{N}_0$ 为样本 $i$ 中基因 $g$ 的观测原始读数计数。每个样本有两个二元协变量：一个生物学条件指示变量 $z_i \\in \\{0,1\\}$ 和一个批次指示变量 $b_i \\in \\{0,1\\}$。目标是在转换后表达量的线性模型中将批次效应建模为一个加性项，然后通过计算去除批次的贡献。\n\n根据第一性原理定义以下内容。\n\n1. 大小因子归一化 (Size-factor normalization)。对于每个样本 $i$，设文库大小为 $L_i = \\sum_{g=1}^G c_{g,i}$。大小因子 $s_i$ 定义为\n$$\ns_i = \\frac{L_i}{\\frac{1}{N}\\sum_{j=1}^N L_j}.\n$$\n2. 对数转换的归一化表达量 (Log-transformed normalized expression)。对于一个固定的伪计数 $c_0 > 0$，定义\n$$\ny_{g,i} = \\log_2\\Big(\\frac{c_{g,i}}{s_i} + c_0\\Big).\n$$\n使用 $c_0 = 1.0$。\n\n3. 每个基因的线性模型 (Linear model per gene)。对于每个基因 $g$，使用普通最小二乘法对所有样本 $i$ 的 $y_{g,i}$ 进行建模，其设计矩阵包含三列：截距、条件指示变量和批次指示变量。也就是说，对于每个 $g$，\n$$\ny_{g,i} = \\beta_{g,0} + \\beta_{g,\\text{cond}}\\; z_i + \\beta_{g,\\text{batch}}\\; b_i + \\varepsilon_{g,i},\n$$\n其中 $\\varepsilon_{g,i}$ 是零均值残差。通过最小化所有样本 $i \\in \\{1,\\dots,N\\}$ 的残差平方和来估计 $(\\beta_{g,0}, \\beta_{g,\\text{cond}}, \\beta_{g,\\text{batch}})$。\n\n4. 批次效应去除 (Batch-effect removal)。对于每个基因 $g$ 和样本 $i$，定义批次校正后的表达量\n$$\n\\tilde{y}_{g,i} = y_{g,i} - \\beta_{g,\\text{batch}}\\; b_i.\n$$\n\n5. 评估统计量 (Evaluation statistic)。对于每个基因 $g$ 以及每个条件水平 $z \\in \\{0,1\\}$，如果两个批次都至少有一个该条件的样本（即，至少存在一个 $i$ 使得 $z_i = z$ 且 $b_i = 0$，并至少存在一个 $i$ 使得 $z_i = z$ 且 $b_i = 1$），计算\n$$\nd_{g}(z) = \\Big(\\text{mean of } \\tilde{y}_{g,i} \\text{ over } i \\text{ with } z_i = z,\\, b_i = 1\\Big) - \\Big(\\text{mean of } \\tilde{y}_{g,i} \\text{ over } i \\text{ with } z_i = z,\\, b_i = 0\\Big).\n$$\n对于每个基因 $g$，定义\n$$\nD_g = \\max_{z \\in \\{0,1\\} \\text{ valid}} \\left| d_{g}(z) \\right|,\n$$\n其中，最大值是在上文所述的有效条件水平 $z$ 上取值。如果对于基因 $g$ 没有有效的条件水平，则定义 $D_g = 0$。\n\n对于下面的每个测试用例，计算评估统计量\n$$\nR = \\max_{g \\in \\{1,\\dots,G\\}} D_g,\n$$\n并报告保留到小数点后六位的 $R$ 值。\n\n测试套件。对于以下三个独立的测试用例，请严格实现上述定义。在每个用例中，$G$ 是基因数量（行），$N$ 是样本数量（列），计数矩阵是 $C = (c_{g,i})$，条件向量是 $(z_1,\\dots,z_N)$，批次向量是 $(b_1,\\dots,b_N)$。\n\n- 测试用例 1：\n  - $G = 3$, $N = 4$。\n  - 计数矩阵 $C$（行 $g=1,2,3$；列 $i=1,2,3,4$）：\n    $$\n    \\begin{bmatrix}\n    100 & 150 & 160 & 240 \\\\\n    80 & 160 & 128 & 256 \\\\\n    40 & 40 & 64 & 64\n    \\end{bmatrix}\n    $$\n  - 条件向量 $(z_1,z_2,z_3,z_4) = (0,1,0,1)$。\n  - 批次向量 $(b_1,b_2,b_3,b_4) = (0,0,1,1)$。\n\n- 测试用例 2：\n  - $G = 3$, $N = 4$。\n  - 计数矩阵 $C$：\n    $$\n    \\begin{bmatrix}\n    60 & 90 & 90 & 120 \\\\\n    30 & 30 & 30 & 60 \\\\\n    10 & 20 & 20 & 20\n    \\end{bmatrix}\n    $$\n  - 条件向量 $(z_1,z_2,z_3,z_4) = (0,1,1,0)$。\n  - 批次向量 $(b_1,b_2,b_3,b_4) = (0,0,0,1)$。\n\n- 测试用例 3：\n  - $G = 5$, $N = 4$。\n  - 计数矩阵 $C$：\n    $$\n    \\begin{bmatrix}\n    200 & 300 & 260 & 390 \\\\\n    500 & 750 & 500 & 750 \\\\\n    0 & 0 & 5 & 8 \\\\\n    1000 & 1500 & 1000 & 1500 \\\\\n    0 & 0 & 0 & 0\n    \\end{bmatrix}\n    $$\n  - 条件向量 $(z_1,z_2,z_3,z_4) = (0,0,1,1)$。\n  - 批次向量 $(b_1,b_2,b_3,b_4) = (0,1,0,1)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个测试用例的 $R$ 值（四舍五入后）的逗号分隔列表，并用方括号括起来。例如，一个可接受的输出格式是\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$\n所有数值输出必须是浮点数，并精确到小数点后六位。不应打印任何其他文本。", "solution": "该问题要求对一个从核糖核酸测序 (RNA-seq) 计数数据中去除批次效应的计算流程进行形式化和实现。该方法基于一个应用于经过对数转换和归一化的表达值的线性模型。然后使用一个已定义的统计指标来评估批次校正的效果。整个流程将按照指定步骤逐一执行。\n\n基本原理是将观测到的基因表达建模为多种效应的线性组合：一个基线表达水平（截距）、一个由目标生物学条件引起的效应，以及一个由实验批次引起的不良效应。通过使用普通最小二乘法 (OLS) 估计批次效应的大小，我们可以从数据中算术减去该分量，从而得到批次校正后的表达值。\n\n计算步骤如下：\n\n首先，我们处理不同样本间测序深度变化的这一技术性伪影。这是通过大小因子归一化来完成的。对于每个样本 $i$，文库大小 $L_i$ 计算为所有基因 $G$ 的读数计数总和：$L_i = \\sum_{g=1}^G c_{g,i}$。样本 $i$ 的大小因子，记为 $s_i$，是其文库大小与所有 $N$ 个样本的平均文库大小之比：\n$$\ns_i = \\frac{L_i}{\\frac{1}{N}\\sum_{j=1}^N L_j}\n$$\n用每个样本对应的大小因子 $s_i$ 对原始计数 $c_{g,i}$ 进行归一化，可将计数调整到一个共同的尺度上。\n\n其次，将归一化后的计数进行对数转换。此转换有两个目的：它能稳定方差，因为 RNA-seq 数据的方差通常取决于均值；它还将计数数据中固有的乘性关系转换为适合线性建模的加性框架。加入一个伪计数 $c_0 = 1.0$，以防止对零取对数，并缓和低表达基因的方差。对数转换后的表达量 $y_{g,i}$ 定义为：\n$$\ny_{g,i} = \\log_2\\Big(\\frac{c_{g,i}}{s_i} + c_0\\Big)\n$$\n\n第三，对于每个基因 $g$，对所有样本 $i=1, \\dots, N$ 的对数转换表达值 $y_{g,i}$ 拟合一个线性模型。该模型将 $y_{g,i}$ 对给定的协变量进行回归：一个截距项、二元条件指示变量 $z_i$ 和二元批次指示变量 $b_i$。模型为：\n$$\ny_{g,i} = \\beta_{g,0} + \\beta_{g,\\text{cond}}\\; z_i + \\beta_{g,\\text{batch}}\\; b_i + \\varepsilon_{g,i}\n$$\n在单个基因 $g$ 的矩阵表示法中，这是 $Y_g = X\\beta_g + \\varepsilon_g$，其中 $Y_g$ 是基因 $g$ 表达值的 $N \\times 1$ 向量，$X$ 是 $N \\times 3$ 的设计矩阵，其列分别为截距（全为1）、条件向量 $(z_1, \\dots, z_N)^T$ 和批次向量 $(b_1, \\dots, b_N)^T$。系数向量 $\\beta_g = (\\beta_{g,0}, \\beta_{g,\\text{cond}}, \\beta_{g,\\text{batch}})^T$ 使用普通最小二乘法 (OLS) 进行估计，该方法最小化残差平方和 $\\sum_i \\varepsilon_{g,i}^2$。如果设计矩阵 $X$ 具有满列秩，则 OLS 估计由 $\\hat{\\beta}_g = (X^T X)^{-1} X^T Y_g$ 给出。我们特别关注 $\\hat{\\beta}_{g,\\text{batch}}$，即基因 $g$ 的估计批次效应。\n\n第四，去除批次效应。对于每个基因 $g$ 和样本 $i$，通过从原始对数转换值中减去估计的批次分量，来计算批次校正后的表达值 $\\tilde{y}_{g,i}$：\n$$\n\\tilde{y}_{g,i} = y_{g,i} - \\hat{\\beta}_{g,\\text{batch}}\\; b_i\n$$\n此校正仅应用于属于批次 $b_i=1$ 的样本，有效地调整它们的表达水平以匹配批次 $b_i=0$ 的基线。\n\n第五，评估校正的成功与否。对于每个基因 $g$，我们测量按生物学条件分层后，批次间的残差均值表达差异。对于给定的条件水平 $z \\in \\{0,1\\}$，如果该条件下同时存在来自两个批次（$b_i=0$ 和 $b_i=1$）的样本，我们计算：\n$$\nd_{g}(z) = \\Big(\\text{mean}_{i: z_i=z, b_i=1} \\tilde{y}_{g,i}\\Big) - \\Big(\\text{mean}_{i: z_i=z, b_i=0} \\tilde{y}_{g,i}\\Big)\n$$\n有效的校正应导致 $d_g(z) \\approx 0$。统计量 $D_g$ 捕捉了基因 $g$ 在所有有效条件水平下的最坏情况残余批次效应：\n$$\nD_g = \\max_{z \\in \\{0,1\\} \\text{ valid}} \\left| d_{g}(z) \\right|\n$$\n如果没有可供比较的有效条件水平，则定义 $D_g$ 为 $0$。\n\n最后，给定数据集的总体评估统计量 $R$是这些基因统计量的最大值，代表校正后数据中存在的最大残余批次效应：\n$$\nR = \\max_{g \\in \\{1,\\dots,G\\}} D_g\n$$\n\n为求解每个给定测试用例的 $R$ 值，我们将完整地实现这一系列计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(C, z, b):\n    \"\"\"\n    Solves a single test case for batch effect removal and evaluation.\n\n    Args:\n        C (np.ndarray): Count matrix (G x N).\n        z (np.ndarray): Condition vector (N,).\n        b (np.ndarray): Batch vector (N,).\n\n    Returns:\n        float: The evaluation statistic R, rounded to 6 decimal places.\n    \"\"\"\n    G, N = C.shape\n    C = C.astype(np.float64)\n    z = z.astype(np.float64)\n    b = b.astype(np.float64)\n    c0 = 1.0\n\n    # Step 1: Size-factor normalization\n    L = C.sum(axis=0)\n    L_mean = L.mean()\n    s = L / L_mean\n\n    # Step 2: Log-transformed normalized expression\n    # Use np.divide and np.newaxis for broadcasting s across rows of C\n    y = np.log2(np.divide(C, s[np.newaxis, :]) + c0)\n\n    # Step 3: Linear model per gene\n    # Construct the design matrix X\n    X = np.vstack([np.ones(N), z, b]).T\n\n    # Check for collinearity. If not full rank, OLS is ill-defined.\n    # The problem statement guarantees full-rank designs for the test cases.\n    # if np.linalg.matrix_rank(X)  X.shape[1]:\n    #     raise ValueError(\"Design matrix is not full column rank.\")\n\n    # Fit the model for each gene to get beta_batch\n    beta_batch_g = np.zeros(G)\n    for g in range(G):\n        # np.linalg.lstsq returns a tuple; the first element is the solution vector\n        beta_hat, _, _, _ = np.linalg.lstsq(X, y[g, :], rcond=None)\n        beta_batch_g[g] = beta_hat[2]\n\n    # Step 4: Batch-effect removal\n    # Subtract beta_batch * b_i from each y_gi\n    # This can be done with broadcasting\n    y_tilde = y - beta_batch_g[:, np.newaxis] * b[np.newaxis, :]\n\n    # Step 5: Evaluation statistic\n    D_g = np.zeros(G)\n    for g in range(G):\n        d_g_z_abs = []\n        \n        # Check condition z=0\n        z0_b0_indices = np.where((z == 0)  (b == 0))[0]\n        z0_b1_indices = np.where((z == 0)  (b == 1))[0]\n        if len(z0_b0_indices) > 0 and len(z0_b1_indices) > 0:\n            mean_b1_z0 = np.mean(y_tilde[g, z0_b1_indices])\n            mean_b0_z0 = np.mean(y_tilde[g, z0_b0_indices])\n            d_g_0 = mean_b1_z0 - mean_b0_z0\n            d_g_z_abs.append(np.abs(d_g_0))\n            \n        # Check condition z=1\n        z1_b0_indices = np.where((z == 1)  (b == 0))[0]\n        z1_b1_indices = np.where((z == 1)  (b == 1))[0]\n        if len(z1_b0_indices) > 0 and len(z1_b1_indices) > 0:\n            mean_b1_z1 = np.mean(y_tilde[g, z1_b1_indices])\n            mean_b0_z1 = np.mean(y_tilde[g, z1_b0_indices])\n            d_g_1 = mean_b1_z1 - mean_b0_z1\n            d_g_z_abs.append(np.abs(d_g_1))\n\n        if len(d_g_z_abs) > 0:\n            D_g[g] = np.max(d_g_z_abs)\n        else:\n            D_g[g] = 0.0\n\n    # Final result R\n    R = np.max(D_g) if len(D_g) > 0 else 0.0\n    \n    return round(R, 6)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"C\": np.array([\n                [100, 150, 160, 240],\n                [80, 160, 128, 256],\n                [40, 40, 64, 64]\n            ]),\n            \"z\": np.array([0, 1, 0, 1]),\n            \"b\": np.array([0, 0, 1, 1])\n        },\n        # Test case 2\n        {\n            \"C\": np.array([\n                [60, 90, 90, 120],\n                [30, 30, 30, 60],\n                [10, 20, 20, 20]\n            ]),\n            \"z\": np.array([0, 1, 1, 0]),\n            \"b\": np.array([0, 0, 0, 1])\n        },\n        # Test case 3\n        {\n            \"C\": np.array([\n                [200, 300, 260, 390],\n                [500, 750, 500, 750],\n                [0, 0, 5, 8],\n                [1000, 1500, 1000, 1500],\n                [0, 0, 0, 0]\n            ]),\n            \"z\": np.array([0, 0, 1, 1]),\n            \"b\": np.array([0, 1, 0, 1])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"C\"], case[\"z\"], case[\"b\"])\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2417834"}]}