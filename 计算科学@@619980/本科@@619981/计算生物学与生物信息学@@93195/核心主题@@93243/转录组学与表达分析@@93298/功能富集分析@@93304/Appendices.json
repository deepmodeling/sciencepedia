{"hands_on_practices": [{"introduction": "让我们通过理解过表达分析 (Over-Representation Analysis, ORA) 的统计核心——超几何检验，来开启我们的动手实践之旅。本练习提供了一个具体的场景，让您能够亲手计算富集分析的 $p$-值，从而清晰地了解我们如何判断一个基因列表与一个通路之间的观测重叠是否具有统计学上的显著性。通过将此精确计算与置换检验的估计值进行比较，您还将深入理解理论模型与经验模拟方法之间的关系 [@problem_id:2392301]。", "problem": "在一项功能富集分析中，假设背景有 $N=100$ 个基因，一个生物通路包含 $n=10$ 个基因，查询基因列表的大小为 $k=5$。在一次实验中，观察到查询基因列表与该通路重叠的基因数量为 $x=3$。\n\n假设零假设为：查询基因列表是通过从 $N$ 个基因中无放回地均匀随机抽样 $k$ 个基因而形成的。\n\n使用组合计数的第一性原理，计算单边超几何 $p$ 值，该值定义为在零假设下，观测到至少 $x$ 个基因重叠的概率。另外，进行了一项基于置换的检验，通过从同一背景中生成 $m=10{,}000$ 个大小为 $k$ 的独立随机基因列表；在这些列表中，有 $h=61$ 个列表与该通路的重叠基因数至少为 $x$。\n\n计算超几何 $p$ 值与基于置换的 $p$ 值估计之间的绝对差。将最终答案以小数形式表示。将答案四舍五入到 $4$ 位有效数字。", "solution": "在尝试解答之前，对问题进行了严格的验证。\n\n步骤 1：提取已知条件\n问题提供了以下参数：\n- 背景中的基因总数：$N=100$。\n- 生物通路中的基因数（总体中的成功数）：$n=10$。\n- 查询基因列表的大小（样本量）：$k=5$。\n- 观测到的重叠数（样本中的成功数）：$x=3$。\n- 零假设：查询基因列表是从 $N$ 个基因的背景中无放回地抽取的，大小为 $k$ 的简单随机样本。\n- 单边超几何 $p$ 值的定义：观测到*至少* $x$ 个基因重叠的概率。\n- 置换检验中的置换次数：$m=10,000$。\n- 重叠数至少为 $x$ 的置换列表数量：$h=61$。\n\n步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n- **科学依据**：该问题描述了生物信息学中功能富集分析的一个典型场景。使用超几何分布来模拟无放回抽样，以及使用置换检验来经验性地估计显著性的概念，是该领域的基本和标准方法。该设置在科学和数学上是合理的。\n- **定义明确**：所需计算的所有必要参数（$N$、$n$、$k$、$x$、$m$、$h$）都已明确给出。所提出的问题——计算两种类型的 $p$ 值及其差异——是明确无误的，并能导向一个唯一的、可验证的数值解。\n- **客观性**：问题以精确、定量的术语表述，没有任何主观或有偏见的语言。\n\n该问题没有表现出任何缺陷，如科学上的不合理性、不完整性、矛盾或歧义。所提供的值对于一个模型问题是切合实际的。\n\n步骤 3：结论与行动\n问题被判定为**有效**。现在将提供完整的解答。\n\n第一个任务是使用第一性原理计算理论上的单边 $p$ 值。在零假设下，在随机选择的查询列表中发现的来自通路的基因数量 $X$ 服从超几何分布。从 $N$ 个背景基因中选择 $k$ 个基因的总方式数由二项式系数 $\\binom{N}{k}$ 给出。从大小为 $n$ 的通路中选择 $i$ 个基因，并从剩余的 $N-n$ 个基因中选择 $k-i$ 个基因的方式数为 $\\binom{n}{i}\\binom{N-n}{k-i}$。\n\n观测到恰好 $i$ 个重叠基因的概率质量函数为：\n$$ P(X=i) = \\frac{\\binom{n}{i} \\binom{N-n}{k-i}}{\\binom{N}{k}} $$\n问题要求计算单边 $p$ 值 $p_{\\text{hyper}}$，即观测到重叠数至少为 $x=3$ 的概率。由于查询列表的大小为 $k=5$，最大可能的重叠数为 $\\min(n, k) = \\min(10, 5) = 5$。\n因此，我们必须计算累积概率 $P(X \\ge 3)$。\n$$ p_{\\text{hyper}} = P(X \\ge 3) = P(X=3) + P(X=4) + P(X=5) = \\sum_{i=3}^{5} \\frac{\\binom{10}{i} \\binom{100-10}{5-i}}{\\binom{100}{5}} $$\n我们计算这个总和的各个组成部分。\n分母是大小为 $5$ 的可能查询基因列表的总数：\n$$ \\binom{N}{k} = \\binom{100}{5} = \\frac{100 \\times 99 \\times 98 \\times 97 \\times 96}{5 \\times 4 \\times 3 \\times 2 \\times 1} = 75,287,520 $$\n对于 $i=3, 4, 5$ 的分子是：\n- 对于 $i=3$：从通路中选择 $3$ 个基因，并从通路外选择 $2$ 个基因的方式数。\n$$ \\binom{10}{3} \\binom{90}{2} = \\left(\\frac{10 \\times 9 \\times 8}{3 \\times 2 \\times 1}\\right) \\left(\\frac{90 \\times 89}{2 \\times 1}\\right) = (120)(4005) = 480,600 $$\n- 对于 $i=4$：从通路中选择 $4$ 个基因，并从通路外选择 $1$ 个基因的方式数。\n$$ \\binom{10}{4} \\binom{90}{1} = \\left(\\frac{10 \\times 9 \\times 8 \\times 7}{4 \\times 3 \\times 2 \\times 1}\\right) (90) = (210)(90) = 18,900 $$\n- 对于 $i=5$：从通路中选择 $5$ 个基因，并从通路外选择 $0$ 个基因的方式数。\n$$ \\binom{10}{5} \\binom{90}{0} = \\left(\\frac{10 \\times 9 \\times 8 \\times 7 \\times 6}{5 \\times 4 \\times 3 \\times 2 \\times 1}\\right) (1) = (252)(1) = 252 $$\n有利结果（重叠数 $\\ge 3$）的总数是这些分子的总和：\n$$ 480,600 + 18,900 + 252 = 499,752 $$\n超几何 $p$ 值是有利结果总数与可能结果总数的比值：\n$$ p_{\\text{hyper}} = \\frac{499,752}{75,287,520} \\approx 0.006637653 $$\n第二个任务是计算基于置换的 $p$ 值估计 $p_{\\text{perm}}$。这是一个从模拟中得出的经验估计。它由达到或超过观测统计量的置换次数 $h$ 与总置换次数 $m$ 的比值给出。\n$$ p_{\\text{perm}} = \\frac{h}{m} = \\frac{61}{10,000} = 0.0061 $$\n最后，我们计算理论超几何 $p$ 值与基于置换的估计值之间的绝对差。\n$$ \\text{Difference} = | p_{\\text{hyper}} - p_{\\text{perm}} | = | 0.006637653... - 0.0061 | = 0.000537653... $$\n问题要求将此结果四舍五入到 $4$ 位有效数字。第一个有效数字是 $5$，后面跟着 $3$、$7$ 和 $6$。随后的数字是 $5$，所以我们将最后一位有效数字向上进位。\n$$ \\text{Difference} \\approx 0.0005377 $$", "answer": "$$\\boxed{0.0005377}$$", "id": "2392301"}, {"introduction": "熟悉了核心计算之后，让我们来探讨一个在实际分析中至关重要的方面：背景基因“全集”的选择。这个编程实践将向您展示一个看似微小的决定——在背景集中包含哪些基因——如何能够显著地改变您的结果的显著性，甚至可能导致假阳性或假阴性的结论。通过量化这一效应，您将培养出进行稳健生物信息学研究所需的批判性思维和严谨性 [@problem_id:2392318]。", "problem": "我们提供一个框架，用以量化在单侧超表示分析中，使用一个误设的基因“全体”如何改变富集显著性。考虑有限的基因集合，其中“全体”（universe）是指从中进行无放回抽样的基因集合，“术语”（term）是“全体”中定义了成功状态的一个子集，而“选定集”（selected set）是观测到的感兴趣的基因子集。对于一个给定的配置，令$N$为正确全体的大小，$K$为全体中被注释到该术语的基因数量，$n$为属于该全体的选定基因数量，$k$为选定基因中被注释到该术语的数量。将富集p值定义为：在有$K$个成功项可用的情况下，从$N$个基因中无放回地随机抽取$n$个基因，观测到至少$k$个成功项的概率。形式上，对于给定的$N$、$K$、$n$和$k$，富集p值为\n$$\np_{\\text{true}}(N,K,n,k) \\equiv \\sum_{i=k}^{\\min(n,K)} \\frac{\\binom{K}{i}\\binom{N-K}{n-i}}{\\binom{N}{n}}.\n$$\n现在假设使用了一个误设的“表达”全体，它只包括被认定为表达的基因。令$N'$为这个误设全体的大小，$K'$为这个误设全体中被注释到该术语的基因数量，$n'$为这个误设全体中的选定基因数量，$k'$为这个误设全体中被注释到该术语的选定基因数量。相应的富集p值为\n$$\np_{\\text{mis}}(N',K',n',k') \\equiv \\sum_{i=k'}^{\\min(n',K')} \\frac{\\binom{K'}{i}\\binom{N'-K'}{n'-i}}{\\binom{N'}{n'}}.\n$$\n对于下方的每个测试用例，计算这些p值之比的以10为底的对数，\n$$\nr \\equiv \\log_{10}\\!\\left(\\frac{p_{\\text{mis}}(N',K',n',k')}{p_{\\text{true}}(N,K,n,k)}\\right).\n$$\n正的$r$表示误设的全体产生了更大的p值（显著性更低），负的$r$表示产生了更小的p值（显著性更高），而$r=0$表示没有变化。将每个$r$值以十进制数的形式返回，并四舍五入到$6$位小数。\n\n参数值测试套件：\n- 用例 A：$N=20000$, $K=500$, $n=200$, $k=12$；$N'=12000$, $K'=320$, $n'=180$, $k'=10$。\n- 用例 B：$N=15000$, $K=600$, $n=100$, $k=0$；$N'=9000$, $K'=400$, $n'=80$, $k'=0$。\n- 用例 C：$N=18000$, $K=150$, $n=40$, $k=30$；$N'=11000$, $K'=120$, $n'=35$, $k'=28$。\n- 用例 D：$N=25000$, $K=60$, $n=20$, $k=20$；$N'=10000$, $K'=30$, $n'=12$, $k'=12$。\n- 用例 E：$N=12000$, $K=400$, $n=150$, $k=8$；$N'=12000$, $K'=400$, $n'=150$, $k'=8$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述用例顺序排列的结果，每个值都四舍五入到$6$位小数（例如 $[x_A,x_B,x_C,x_D,x_E]$，其中每个$x_\\cdot$都是一个十进制数）。", "solution": "问题陈述已经过验证，并被认为是有效的。它具有科学依据，定义明确且客观。该问题描述了计算生物学中的一个标准流程——超表示分析，并将其正确地构建为一个超几何检验。任务的核心是量化当背景基因集（“全体”）被更改时统计显著性的变化，这是生物信息学中一个已知且重要的问题。所有提供的参数都是一致且充分的，足以得到唯一解。因此，我们着手推导计算解决方案。\n\n基本原理是超几何概率分布。该分布对无放回抽样进行建模。给定一个大小为$N$、包含$K$个感兴趣项目（“成功项”）的总体，抽取一个大小为$n$、其中恰好包含$i$个成功项的样本的概率由概率质量函数（PMF）给出：\n$$\nP(X=i) = \\frac{\\binom{K}{i}\\binom{N-K}{n-i}}{\\binom{N}{n}}\n$$\n其中$X$是代表样本中成功项数量的随机变量。\n\n问题将富集p值定义为观测到至少$k$个成功项的概率。这对应于分布的尾部概率，也称为生存函数（SF）。它是通过对观测到$k, k+1, \\dots, \\min(n,K)$个成功项的概率求和来计算的：\n$$\np(N,K,n,k) = P(X \\ge k) = \\sum_{i=k}^{\\min(n,K)} P(X=i)\n$$\n这就是分别为“真实”和“误设”参数集定义的$p_{\\text{true}}$和$p_{\\text{mis}}$的值。\n\n对于所涉及的大数（例如$N=20000$），直接计算二项式系数$\\binom{a}{b}$在数值上不稳定，在计算上也不可行。正确的计算方法是使用一个库函数，该函数利用对数伽马函数来实现超几何分布的性质，以保证数值稳定性。\n\n生存函数$P(X \\ge k)$等价于$1 - P(X \\le k-1)$，即$SF(k-1)$。大多数科学计算库都提供此函数。我们将使用`scipy`库中的`scipy.stats.hypergeom.sf`。此函数的参数为：分位数$k-1$，总体大小$M$（我们的$N$），总体中成功项的总数$n$（我们的$K$），以及样本大小$N$（我们的$n$）。\n\n算法如下：\n1.  对于每个测试用例，我们都给定一个“真实”参数集$(N, K, n, k)$和一个“误设”参数集$(N', K', n', k')$。\n2.  使用对应于真实全体的参数，通过超几何生存函数计算真实情况的p值$p_{\\text{true}}$：`hypergeom.sf(k-1, M=N, n=K, N=n)`。\n3.  类似地，使用其对应的参数计算误设情况的p值$p_{\\text{mis}}$：`hypergeom.sf(k'-1, M=N', n=K', N=n')`。\n4.  目标是计算数量$r \\equiv \\log_{10}\\!\\left(\\frac{p_{\\text{mis}}}{p_{\\text{true}}}\\right)$。为保持数值精度，这可以计算为$\\log_{10}(p_{\\text{mis}}) - \\log_{10}(p_{\\text{true}})$。\n5.  有两个特殊情况值得注意。首先，对于用例B，其中$k=0$且$k'=0$，p值是所有可能结果的概率之和，因此必须为$1$。从而$p_{\\text{true}}=1$且$p_{\\text{mis}}=1$，导致$r=0$。生存函数`sf(k-1)`能正确处理这种情况，因为当$k=0$时，它计算的是`sf(-1)`，其定义为$1$。\n6.  其次，对于用例E，“真实”和“误设”的参数是相同的。因此，$p_{\\text{true}} = p_{\\text{mis}}$，比值为$1$，并且$r = \\log_{10}(1) = 0$。这可以作为对实现的一个简单检查。\n7.  每个用例的最终$r$值被四舍五入到6位小数，并以要求的列表格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import hypergeom\n\ndef solve():\n    \"\"\"\n    Computes the log-ratio of p-values from a mis-specified universe\n    in a hypergeometric test for over-representation analysis.\n    \"\"\"\n\n    # Test cases are defined as tuples of:\n    # (N, K, n, k, N', K', n', k')\n    test_cases = [\n        # Case A\n        (20000, 500, 200, 12, 12000, 320, 180, 10),\n        # Case B\n        (15000, 600, 100, 0, 9000, 400, 80, 0),\n        # Case C\n        (18000, 150, 40, 30, 11000, 120, 35, 28),\n        # Case D\n        (25000, 60, 20, 20, 10000, 30, 12, 12),\n        # Case E\n        (12000, 400, 150, 8, 12000, 400, 150, 8),\n    ]\n\n    def calculate_p_value(N, K, n, k):\n        \"\"\"\n        Calculates the p-value for over-representation using the\n        hypergeometric survival function.\n\n        Args:\n            N (int): Population size (universe).\n            K (int): Number of successes in population (term size).\n            n (int): Sample size (selected set size).\n            k (int): Number of successes in sample.\n\n        Returns:\n            float: The p-value, P(X >= k).\n        \"\"\"\n        # The probability P(X >= k) is calculated by the survival function (sf)\n        # evaluated at k-1.\n        # Parameters for scipy.stats.hypergeom:\n        # M: The total number of items (our N, universe size).\n        # n: The total number of type I items (our K, term size).\n        # N: The number of items drawn (our n, selected set size).\n        return hypergeom.sf(k - 1, M=N, n=K, N=n)\n\n    results = []\n    for case in test_cases:\n        N, K, n, k, N_prime, K_prime, n_prime, k_prime = case\n\n        # Calculate p-value for the correct universe\n        p_true = calculate_p_value(N, K, n, k)\n\n        # Calculate p-value for the mis-specified universe\n        p_mis = calculate_p_value(N_prime, K_prime, n_prime, k_prime)\n        \n        # Guard against zero p-values to avoid issues with log.\n        # Based on problem validation, p_true is non-zero for all test cases.\n        if p_true == 0.0 or p_mis == 0.0:\n            if p_true == p_mis: # Both are 0\n                r = 0.0 # Define log(0/0) as 0, indicating no relative change\n            elif p_mis == 0.0:\n                 r = -np.inf # Transition to zero p-value\n            else: # p_true is 0, p_mis is not\n                 r = np.inf # Transition from impossible to possible\n        else:\n            # Compute the base-10 logarithm of the ratio\n            r = np.log10(p_mis / p_true)\n\n        results.append(r)\n\n    # Format output as a list of strings, with each number rounded to 6 decimal places.\n    # The f-string formatting handles rounding as required.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2392318"}, {"introduction": "我们最后的实践将从静态计算转向动态模拟，帮助您对“统计显著性”的真正含义建立更深层次的直觉。在这个练习中，您将对一个富集的生物学信号进行建模，并逐步引入“噪音”，以探究信号在何种程度上会消失。这项练习 [@problem_id:2392264] 提供了一个强大的概念框架，帮助您思考数据中的信噪比，并理解研究发现的稳健性。", "problem": "给定一个基因全集，它被建模为一个大小为 $N$ 的有限集合；一个大小为 $M \\le N$ 的已知通路（基因集）；以及一个包含 $K$ 个选定基因（例如，差异基因）的集合，这些基因被认为在该通路中富集。在标准的超表示分析零模型下，选定集中观测到的通路基因数量（记为 $X$）遵循参数为 $(N, M, K)$ 的超几何分布。对于一个观测到的重叠数 $k$，其富集 $p$-值是上尾概率 $\\mathbb{P}(X \\ge k)$，其中 $X \\sim \\text{Hypergeometric}(N, M, K)$。这是用于超表示分析的 Fisher 精确检验 (FET) 推断的核心，该检验基于无放回抽样假设。在零假设下，期望的重叠数为 $\\mathbb{E}[X] = K \\cdot M / N$。\n\n您将通过以下方式模拟随机噪声对初始富集信号的影响。假设初始选定集包含 $k_0$ 个通路基因，且 $k_0$ 通常超过零假设期望值 $K M / N$。通过从基因全集中（无放回地）均匀随机抽取基因，来替换 $K$ 个选定基因中比例为 $f \\in [0,1]$ 的部分，从而引入随机噪声。在期望中，施加比例为 $f$ 的噪声后，通路重叠数 $k(f)$ 的演变如下：\n$$\nk(f) \\;=\\; (1 - f)\\,k_0 \\;+\\; f \\, K \\cdot \\frac{M}{N}.\n$$\n由于统计检验要求重叠数为整数，我们定义一个确定性代理变量\n$$\nk^\\star(f) \\;=\\; \\mathrm{round}\\!\\big(k(f)\\big),\n$$\n其中“round”表示使用标准规则四舍五入到最近的整数，即小数部分恰好为一半时，舍入到最近的偶数。对于每个 $f$，定义富集 $p$-值为\n$$\np(f) \\;=\\; \\mathbb{P}\\!\\big(X \\ge k^\\star(f)\\big), \\quad X \\sim \\text{Hypergeometric}(N, M, K).\n$$\n\n您的任务是，对每个测试用例，在固定的网格上确定一个最小的噪声比例 $f^\\star$，使得富集在 $\\alpha$ 水平下变得不显著，即：\n$$\nf^\\star \\;=\\; \\min \\left\\{ f \\in \\{0, \\Delta f, 2\\Delta f, \\dots, 1\\} \\;:\\; p(f) \\ge \\alpha \\right\\}.\n$$\n如果 $p(0) \\ge \\alpha$，则 $f^\\star = 0$。如果对于所有直至 $f=1$ 的网格值都有 $p(f) < \\alpha$，则报告 $f^\\star = 1$。\n\n实现一个完整的、可运行的程序，该程序：\n- 对于由步长 $\\Delta f$ 定义的每个网格值 $f$，使用超几何上尾概率 $\\mathbb{P}(X \\ge k^\\star(f))$ 计算 $p(f)$。\n- 返回满足非显著性标准 $p(f^\\star) \\ge \\alpha$ 的最小 $f^\\star$。\n- 将每个 $f^\\star$ 四舍五入并报告至恰好三位小数。\n- 生成单行输出，其中包含所有按顺序排列的结果，形式为方括号括起来的逗号分隔列表，例如 $[\\,0.125,0.003,1.000\\,]$。\n\n使用以下五个测试用例，每个用例指定为一个元组 $(N, M, K, k_0, \\alpha, \\Delta f)$:\n- $(20000, 300, 150, 60, 0.05, 0.01)$\n- $(20000, 300, 150, 2, 0.05, 0.01)$\n- $(500, 80, 40, 18, 0.01, 0.005)$\n- $(10000, 1000, 500, 120, 0.05, 0.02)$\n- $(100, 10, 10, 7, 0.001, 0.05)$\n\n所有输出必须是 $[0,1]$ 范围内的纯小数（而非百分比），并四舍五入到三位小数。程序应生成单行输出，包含以方括号括起来的逗号分隔列表形式的结果（例如，$[\\,0.125,0.003,1.000\\,]$）。", "solution": "该问题要求我们确定最小的噪声比例 $f^\\star$，该比例能使一个统计上显著的基因集富集变为不显著。这涉及到对富集信号的衰减过程进行建模，并反复应用统计检验来找到显著性消失的临界点。该过程基于生物信息学中的超表示分析 (ORA) 原理，该分析通过超几何分布进行统计建模。\n\n该问题的提法是有效的，因为它在科学上基于生物信息学中已建立的统计方法，在数学上是适定的（所有必要的参数和条件都已定义），并且是客观且可通过计算验证的。\n\n解决方案通过以下步骤制定：\n\n1.  **基因集超表示建模**\n    分析的基础是 Fisher 精确检验，该检验依赖于超几何分布。给定一个包含 $N$ 个基因的全集，一个包含其中 $M$ 个基因的特定通路，以及一个包含 $K$ 个基因的选定集，在选定集中观测到恰好 $x$ 个通路基因的概率由超几何概率质量函数 (PMF) 给出：\n    $$\n    \\mathbb{P}(X=x) = \\frac{\\binom{M}{x} \\binom{N-M}{K-x}}{\\binom{N}{K}}\n    $$\n    在这里，$X$ 是代表重叠基因数量的随机变量。分布的参数是总体大小 $N$、总体中成功状态的数量 $M$（通路中的基因数）以及抽样数量 $K$（选定基因数）。我们将其记为 $X \\sim \\text{Hypergeometric}(N, M, K)$。\n\n2.  **定义统计显著性**\n    对于观测到的 $k$ 个基因的重叠，通常通过计算上尾 $p$-值来评估其富集程度。这是在无关联的零假设下，观测到至少 $k$ 个基因重叠的概率。\n    $$\n    p = \\mathbb{P}(X \\ge k) = \\sum_{i=k}^{\\min(M,K)} \\mathbb{P}(X=i)\n    $$\n    这也被称为生存函数 (SF)，通常计算为 $1 - \\mathbb{P}(X \\le k-1)$。如果该 $p$-值小于预定义的显著性水平 $\\alpha$，则观测结果被认为是统计显著的。\n\n3.  **噪声引起的信号衰减建模**\n    问题引入了一个噪声模型，用于模拟初始富集信号的退化。从大小为 $K$ 的选定集中初始重叠的 $k_0$ 个基因开始，其中比例为 $f$ 的基因被从包含 $N$ 个基因的整个全集中均匀随机抽取的基因所替换。\n    经过这次替换后，选定集中通路基因的期望数量（记为 $k(f)$）可以表示为初始状态（$f=0$时）和完全随机化下的期望状态（$f=1$时）之间的线性插值。在一个大小为 $K$ 的随机集合中，通路基因的期望数量即为零假设期望值 $\\mathbb{E}[X] = K \\cdot M/N$。\n    - 未被替换的 $(1-f)K$ 个基因平均贡献 $(1-f)k_0$ 个通路基因（假设这 $k_0$ 个通路基因是从原始富集集中抽取的）。\n    - 新抽取的 $fK$ 个基因平均贡献 $fK \\cdot (M/N)$ 个通路基因。\n    问题陈述为合并这些效应后所得的重叠数提供了简化的期望公式：\n    $$\n    k(f) = (1 - f)k_0 + f \\frac{KM}{N}\n    $$\n    由于超几何检验要求重叠数为整数，我们通过将期望值 $k(f)$ 四舍五入到最近的整数来定义一个确定性整数代理变量 $k^\\star(f)$，其中小数部分为0.5时舍入到最近的偶数。\n    $$\n    k^\\star(f) = \\mathrm{round}(k(f))\n    $$\n    该舍入规则与 Python 3 及更高版本中的内置 `round()` 函数以及 `numpy.round()` 的行为一致。\n\n4.  **寻找 $f^\\star$ 的算法流程**\n    核心任务是从离散值网格 $\\{0, \\Delta f, 2\\Delta f, \\dots, 1\\}$ 中找到最小的噪声比例 $f^\\star$，使得富集 $p$-值不再显著，即 $p(f) \\ge \\alpha$。\n    对于每个测试用例 $(N, M, K, k_0, \\alpha, \\Delta f)$，算法如下：\n    a. 构建步长为 $\\Delta f$ 的噪声比例网格 $f \\in [0, 1]$。\n    b. 计算零假设下的期望重叠数：$E = K \\cdot M / N$。\n    c. 从 $f=0$ 开始，遍历 $f$ 的网格值。\n    d. 对每个 $f$：\n        i. 计算施加噪声后的期望重叠数：$k(f) = (1 - f)k_0 + f \\cdot E$。\n        ii. 确定整数重叠数：$k^\\star(f) = \\mathrm{int}(\\mathrm{round}(k(f)))$。\n        iii. 计算 $p$-值：$p(f) = \\mathbb{P}(X \\ge k^\\star(f))$，其中 $X \\sim \\text{Hypergeometric}(N, M, K)$。这可以使用超几何分布的生存函数计算：`scipy.stats.hypergeom.sf(k_star - 1, N, M, K)`。\n        iv. 检查显著性条件：如果 $p(f) \\ge \\alpha$，则已找到临界噪声比例。设置 $f^\\star = f$ 并终止对此测试用例的搜索。\n    e. 如果循环完成而所有 $f$ (包括 $f=1$) 都不满足条件，问题指定 $f^\\star=1$。这可以通过将 $f^\\star$ 初始化为 1 来处理。我们的实现将搜索整个网格，并在找到第一个合适的 $f$ 时中断。初始默认值 $f^\\star = 1.0$ 覆盖了条件始终未被满足的情况。\n\n    此流程系统地评估了统计显著性的衰减，并根据问题的定义正确地识别出所需的阈值 $f^\\star$。然后，每个测试用例的最终值被四舍五入到三位小数以供报告。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import hypergeom\n\ndef solve():\n    \"\"\"\n    Computes the smallest noise fraction f_star for which a gene set enrichment\n    signal becomes non-significant, for a series of test cases.\n    \"\"\"\n    # Test cases defined as (N, M, K, k_0, alpha, delta_f) tuples.\n    # N: universe size, M: pathway size, K: selected set size\n    # k_0: initial overlap, alpha: significance level, delta_f: noise grid step\n    test_cases = [\n        (20000, 300, 150, 60, 0.05, 0.01),\n        (20000, 300, 150, 2, 0.05, 0.01),\n        (500, 80, 40, 18, 0.01, 0.005),\n        (10000, 1000, 500, 120, 0.05, 0.02),\n        (100, 10, 10, 7, 0.001, 0.05)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, M, K, k_0, alpha, delta_f = case\n\n        # The number of steps for the grid, ensuring 1.0 is included.\n        # Add a small epsilon to avoid floating point inaccuracies with the division.\n        num_steps = int(1.0 / delta_f + 1e-9) + 1\n        f_grid = np.linspace(0.0, 1.0, num_steps)\n\n        # Expected overlap under the null hypothesis (random selection)\n        null_expectation = K * M / N\n        \n        # Initialize f_star to 1.0. This value will be used if the p-value\n        # remains below alpha for all f on the grid.\n        f_star = 1.0\n\n        for f in f_grid:\n            # Calculate the expected overlap k(f) after applying noise fraction f.\n            # This is a linear interpolation between the initial overlap k_0 and\n            # the null expectation.\n            k_f = (1.0 - f) * k_0 + f * null_expectation\n\n            # Round k(f) to the nearest integer, with halves rounded to the\n            # nearest even integer, as specified. np.round and then casting to int\n            # achieves this.\n            k_star = int(np.round(k_f))\n\n            # The p-value is the probability of observing k_star or more overlaps,\n            # which is the survival function (1 - CDF).\n            # hypergeom.sf(k-1, N, M, K) computes P(X >= k).\n            # scipy.stats.hypergeom takes parameters (M, n, k), which in our\n            # notation are (total population, number of type I items, number of draws)\n            # -> (N, M, K).\n            if k_star > min(M, K):\n                # If the required overlap is impossibly large, p-value is 0.\n                p_value = 0.0\n            else:\n                p_value = hypergeom.sf(k_star - 1, N, M, K)\n\n            # Check if the p-value meets or exceeds the significance threshold alpha.\n            # If so, we have found the smallest f on the grid that satisfies the\n            # condition.\n            if p_value >= alpha:\n                f_star = f\n                break\n        \n        results.append(f_star)\n\n    # Format the results as a list of strings, each rounded to 3 decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    \n    # Print the final output in the required single-line format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2392264"}]}