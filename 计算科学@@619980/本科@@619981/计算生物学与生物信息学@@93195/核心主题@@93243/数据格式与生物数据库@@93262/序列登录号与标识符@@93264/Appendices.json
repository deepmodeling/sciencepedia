{"hands_on_practices": [{"introduction": "在生物信息学中，我们经常需要处理来自不同数据库的标识符，每个数据库都有其独特的格式。为了自动化地验证和解析这些混合数据，我们需要一种强大的模式匹配工具。本练习 [@problem_id:2428411] 将引导你构建一个单一的正则表达式，它能同时识别并解析来自 GenBank、RefSeq、UniProt 和 PDB 的标识符，这是磨练数据处理精确性的基本功。", "problem": "一个生物信息学流程必须验证一个由假定序列标识符组成的混合数据流，并从每个有效标识符中提取两个字段：一个前导字母前缀和紧随其后的数字部分。该数据流可能包含来自以下任一数据库的标识符，一个标识符被视为有效，当且仅当它完全符合下列形式之一。\n\n- GenBank一级核苷酸登录号：一个大写字母后跟恰好五个数字，或两个大写字母后跟恰好六个数字。不允许版本后缀或其他修饰。\n- 美国国家生物技术信息中心 (NCBI) 参考序列 (RefSeq) 登录号：一个来自集合 {NM, NR, NP, NC, NG, NT, NW, XM, XR, XP, YP} 的双字母前缀，后跟一个下划线，再后跟一个或多个数字（登录号），以及一个可选的版本后缀（由一个点和一个或多个数字组成）。只有下划线前的双字母代码是前缀，数字部分是紧跟在下划线后的数字序列，不包括可选的版本部分。\n- 环球蛋白质资源库 (UniProt) 一级登录号（不包括异构体后缀）：一个六字符的字符串，由一个大写字母、一个数字、三个大写字母或数字以及最后一个数字组成；或一个十字符的字符串，由一个大写字母、一个数字和八个大写字母或数字组成。对于本问题，前缀定义为从开头到第一个数字（不含该数字）的连续大写字母，数字部分定义为紧跟该前缀之后的最大连续数字序列。\n- 蛋白质数据库 (PDB) 标识符：恰好四个字符，由一个数字后跟三个大写字母或数字组成。对于本问题，将前缀定义为空字符串，数字部分定义为第一个数字。\n\n您需要使用兼容Perl的正则表达式 (PCRE) 构建一个单一模式。当应用于候选字符串时，该模式能同时根据上述四种类别对其进行验证，并将两个字段捕获到在所有分支中名称一致的捕获组中：名为“prefix”的捕获组必须捕获上文定义的前缀，而名为“num”的捕获组必须捕获上文定义的数字部分。\n\n设计出这样一个正则表达式后，请将其概念性地（无需执行代码）应用于以下字符串列表。对于每个匹配的字符串，确定所捕获的数字部分的长度（以字符为单位），然后将这些长度相加。令所得总和为 $S$。请以纯整数形式报告 $S$ 的值。\n\n- M12345\n- AF123456\n- CP000001\n- AB12345\n- J012345\n- NM_000059.3\n- NP_123456\n- XR_98765.1\n- ZZ_123456\n- P12345\n- Q8N158\n- A0A023GPI8\n- B2R5Z7\n- 1ABC\n- 2C7A\n- A1BC\n- XP_1234\n- Q8N158-2\n- NR_001\n- YP_009724390.1\n\n答题形式：仅提供 $S$ 的数值。无需单位。不要进行四舍五入；根据定义，$S$ 是一个整数。", "solution": "问题陈述已经过严格审查，并被确定为有效。它具有科学依据、提法明确且客观。它为识别和解析四种特定的生物信息学序列标识符提供了一套清晰、自洽的规则。其中的定义虽然对某些类别而言比较特殊，但明确无误，有助于构建形式化的解决方案。\n\n任务是构建一个单一的兼容Perl的正则表达式 (PCRE)，以根据给定格式验证字符串，并提取两个命名为 `prefix` 和 `num` 的字段。随后，将此过程概念性地应用于所提供的候选字符串列表，以计算总和 $S$，$S$ 是从有效字符串中捕获的所有 `num` 字段的总长度。\n\n首先，我们设计正则表达式。整个模式必须匹配从开头 (`^`) 到结尾 (`$`) 的整个字符串，并且将由四个主要分支组成（每个数据库一个），通过 `|` 运算符连接。我们将使用命名捕获组 `(?<prefix>...)` 和 `(?<num>...)`。\n\n1.  **GenBank登录号**：格式为一个大写字母和五个数字 (`[A-Z]\\d{5}`) 或两个大写字母和六个数字 (`[A-Z]{2}\\d{6}`)。前缀是字母部分，数字部分是数字序列。这可以转化为以下两部分的分支：\n    `(?<prefix>[A-Z])(?<num>\\d{5})` 和 `(?<prefix>[A-Z]{2})(?<num>\\d{6})`。\n    GenBank的组合子模式是：\n    `(?:(?<prefix>[A-Z])(?<num>\\d{5})|(?<prefix>[A-Z]{2})(?<num>\\d{6}))`\n\n2.  **NCBI RefSeq登录号**：格式为一个特定的双字母前缀、一个下划线、一个或多个数字，以及一个可选的版本后缀。前缀是双字母代码，数字部分是下划线后的数字序列。允许的前缀是 `{NM, NR, NP, NC, NG, NT, NW, XM, XR, XP, YP}`。\n    RefSeq的子模式是：\n    `(?<prefix>NM|NR|NP|NC|NG|NT|NW|XM|XR|XP|YP)_(?<num>\\d+)(?:\\.\\d+)?`\n\n3.  **UniProt登录号**：格式为一个六字符字符串 `[A-Z]\\d[A-Z0-9]{3}\\d` 或一个十字符字符串 `[A-Z]\\d[A-Z0-9]{8}`。前缀被定义为前导的字母字符，数字部分是紧随其后的单个数字。\n    UniProt的子模式是：\n    `(?<prefix>[A-Z])(?<num>\\d)(?:[A-Z0-9]{3}\\d|[A-Z0-9]{8})`\n\n4.  **PDB标识符**：格式为一个四字符字符串 `\\d[A-Z0-9]{3}`。前缀被定义为空字符串，数字部分是前导数字。\n    PDB的子模式（捕获空前缀）是：\n    `(?<prefix>)(?<num>\\d)[A-Z0-9]{3}`\n\n将这四个子模式组合成一个单一的、带锚点的PCRE，得到最终表达式：\n`^(?:(?:(?<prefix>[A-Z])(?<num>\\d{5})|(?<prefix>[A-Z]{2})(?<num>\\d{6}))|(?<prefix>NM|NR|NP|NC|NG|NT|NW|XM|XR|XP|YP)_(?<num>\\d+)(?:\\.\\d+)?|(?<prefix>[A-Z])(?<num>\\d)(?:[A-Z0-9]{3}\\d|[A-Z0-9]{8})|(?<prefix>)(?<num>\\d)[A-Z0-9]{3})$`\n\n接下来，我们将这些规则应用于给定的字符串列表，并计算总和 $S$。对于每个字符串，我们确定其有效性，如果有效，则确定捕获的 `num` 部分的长度。\n\n1.  `M12345`：有效的GenBank (`[A-Z]\\d{5}`)。`num` = `12345`。长度 = $5$。\n2.  `AF123456`：有效的GenBank (`[A-Z]{2}\\d{6}`)。`num` = `123456`。长度 = $6$。\n3.  `CP000001`：有效的GenBank (`[A-Z]{2}\\d{6}`)。`num` = `000001`。长度 = $6$。\n4.  `AB12345`：无效。格式 `[A-Z]{2}\\d{5}` 不匹配任何规则。长度 = $0$。\n5.  `J012345`：无效。格式 `[A-Z]\\d{6}` 不匹配任何规则。长度 = $0$。\n6.  `NM_000059.3`：有效的RefSeq。`num` = `000059`。长度 = $6$。\n7.  `NP_123456`：有效的RefSeq。`num` = `123456`。长度 = $6$。\n8.  `XR_98765.1`：有效的RefSeq。`num` = `98765`。长度 = $5$。\n9.  `ZZ_123456`：无效。`ZZ` 不是允许的RefSeq前缀。长度 = $0$。\n10. `P12345`：有效的UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`)。`num` = `1`。长度 = $1$。\n11. `Q8N158`：有效的UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`)。`num` = `8`。长度 = $1$。\n12. `A0A023GPI8`：有效的UniProt (`[A-Z]\\d[A-Z0-9]{8}`)。`num` = `0`。长度 = $1$。\n13. `B2R5Z7`：有效的UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`)。`num` = `2`。长度 = $1$。\n14. `1ABC`：有效的PDB (`\\d[A-Z0-9]{3}`)。`num` = `1`。长度 = $1$。\n15. `2C7A`：有效的PDB (`\\d[A-Z0-9]{3}`)。`num` = `2`。长度 = $1$。\n16. `A1BC`：无效。不匹配任何规则。长度 = $0$。\n17. `XP_1234`：有效的RefSeq。`num` = `1234`。长度 = $4$。\n18. `Q8N158-2`：无效。字符串包含后缀 `-2`，任何规则都未涵盖，且模式是带锚点的。长度 = $0$。\n19. `NR_001`：有效的RefSeq。`num` = `001`。长度 = $3$。\n20. `YP_009724390.1`：有效的RefSeq。`num` = `009724390`。长度 = $9$。\n\n总和 $S$ 是这些长度之和：\n$S = 5 + 6 + 6 + 0 + 0 + 6 + 6 + 5 + 0 + 1 + 1 + 1 + 1 + 1 + 1 + 0 + 4 + 0 + 3 + 9$\n$S = (5+5) + (6+6+6+6) + (1+1+1+1+1+1) + 4 + 3 + 9$\n$S = 10 + 24 + 6 + 4 + 3 + 9$\n$S = 34 + 6 + 4 + 3 + 9$\n$S = 40 + 4 + 3 + 9$\n$S = 44 + 3 + 9$\n$S = 47 + 9 = 56$\n\n最终计算出的 $S$ 值为 $56$。", "answer": "$$\\boxed{56}$$", "id": "2428411"}, {"introduction": "真实世界的数据很少是完美的；从论文或实验记录中手动转录的登录号常常包含拼写错误（例如，'O' 和 '0' 混淆）。本练习 [@problem_id:2428373] 介绍了一种“模糊搜索”策略来应对这类问题。你将学习并应用一种加权的编辑距离算法，它通过计算字符串之间的“相似度”来智能地找出最可能的正确标识符，这在数据清洗和校正中是一项至关重要的技术。", "problem": "编写一个程序，为若干可能含有转录错误的查询字符串，从一个固定的候选集中选出最可能的规范序列登录标识符。在此设定中，一个登录标识符是一个由大写字母、数字及下划线和句点符号组成的字母表上的有限字符串。设有序候选集表示为 $S = (s_0, s_1, \\dots, s_{n-1})$，查询集表示为 $Q = (q_0, q_1, \\dots, q_{m-1})$。\n\n定义一个视觉易混淆字符对的对称集合 $H$ 为\n$$\nH = \\{(O,0),(I,1),(l,1),(S,5),(Z,2),(B,8),(G,6)\\},\n$$\n这些被解释为无序对，因此 $(a,b) \\in H$ 当且仅当 $(b,a) \\in H$。\n\n定义替换代价函数 $c: \\Sigma \\times \\Sigma \\to \\mathbb{R}_{\\ge 0}$ 为\n$$\nc(x,y) = \\begin{cases}\n0 & \\text{if } x=y,\\\\\n\\frac{1}{2} & \\text{if } \\{x,y\\} \\in H,\\\\\n1 & \\text{otherwise.}\n\\end{cases}\n$$\n定义两个字符串 $q$ 和 $s$ 之间的相异度 $d(q,s)$ 为：将 $q$ 转换为 $s$ 的所有单字符插入、删除和替换操作序列中的最小总代价。其中，每次插入的代价为 $1$，每次删除的代价为 $1$，而将字符 $x$ 替换为 $y$ 的代价为 $c(x,y)$。对于任何 $q$，按如下方式定义所选索引 $\\operatorname{idx}(q)$。计算所有 $i \\in \\{0,1,\\dots,n-1\\}$ 的 $d(q,s_i)$，找到最小值 $d_{\\min}(q) = \\min_i d(q,s_i)$，并设 $I(q)$ 为达到此最小值的索引集合，\n$$\nI(q) = \\{\\, i \\mid d(q,s_i) = d_{\\min}(q) \\,\\}.\n$$\n固定一个容差阈值 $T=2$。如果 $d_{\\min}(q) \\le T$，则将 $\\operatorname{idx}(q)$ 设为 $I(q)$ 中的最小索引（即 $I(q)$ 中不存在更小索引的那个唯一 $i$），否则将 $\\operatorname{idx}(q) = -1$。\n\n使用以下长度为 $n=10$ 的有序候选集 $S$（索引从 $0$ 开始）：\n- $s_0 = \\text{NM\\_000546.6}$\n- $s_1 = \\text{NP\\_000537.3}$\n- $s_2 = \\text{NC\\_000001.11}$\n- $s_3 = \\text{AY123456}$\n- $s_4 = \\text{ABO123456}$\n- $s_5 = \\text{GCF\\_000001405.39}$\n- $s_6 = \\text{ENST00000335137.4}$\n- $s_7 = \\text{XM\\_021893495.1}$\n- $s_8 = \\text{LRG\\_199}$\n- $s_9 = \\text{ENST00000335137.5}$\n\n在以下 $m=9$ 个查询字符串上评估您的程序：\n- $q_0 = \\text{AY123456}$\n- $q_1 = \\text{AB0123456}$\n- $q_2 = \\text{NM\\_000546.7}$\n- $q_3 = \\text{NC\\_00001.11}$\n- $q_4 = \\text{XM021893495.1}$\n- $q_5 = \\text{ENST00000335137.6}$\n- $q_6 = \\text{XYZ123}$\n- $q_7 = \\text{LRG\\_I99}$\n- $q_8 = \\text{NM0005466}$\n\n您的程序必须为每个 $j \\in \\{0,1,\\dots,8\\}$ 计算 $\\operatorname{idx}(q_j)$，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的整数列表形式的结果（例如，$[\\dots]$）。整个测试套件的最终输出是列表\n$$\n\\bigl[\\operatorname{idx}(q_0),\\operatorname{idx}(q_1),\\dots,\\operatorname{idx}(q_8)\\bigr].\n$$\n不涉及物理单位。不涉及角度。所有比例（如有）必须表示为实数，而非百分比。每个测试用例唯一允许的输出是如上所述的整数。", "solution": "所呈现的问题在科学上是合理的、适定的，并且包含了确定性解所需的所有必要信息。这是一个应用串论（计算机科学的一个子领域）中的问题，在生物信息学中有直接应用。因此，我们可以直接着手构建解决方案。\n\n核心任务是，对于每个查询字符串 $q$，从给定的候选集 $S$ 中识别出最可能的规范登录标识符 $s_i$。该选择基于相异度得分 $d(q,s)$ 和一个阈值标准。\n\n相异度 $d(q,s)$ 被定义为一种广义编辑距离，具体而言是带有自定义替换代价的 Levenshtein 距离。将字符串 $q$ 转换为字符串 $s$ 的代价，是一系列基本操作（插入、删除和替换）的最小代价总和。\n代价定义如下：\n-   删除单个字符：代价为 $1$。\n-   插入单个字符：代价为 $1$。\n-   将字符 $x$ 替换为字符 $y$：代价由函数 $c(x,y)$ 给出。\n\n替换代价函数 $c(x,y)$ 指定如下：\n$$\nc(x,y) = \\begin{cases}\n0 & \\text{if } x=y,\\\\\n\\frac{1}{2} & \\text{if } \\{x,y\\} \\in H,\\\\\n1 & \\text{otherwise.}\n\\end{cases}\n$$\n视觉易混淆字符对的集合 $H$ 由 $H = \\{(O,0),(I,1),(l,1),(S,5),(Z,2),(B,8),(G,6)\\}$ 给出。需要注意的是，问题将规范标识符的字母表定义为由大写字母、数字和符号 `_` 及 `.` 组成。包含小写字母的字符对 $(l,1)$ 的引入，是对替换代价函数定义域的一个形式上的扩展。由于所提供的查询字符串不包含小写字母，这个特定的字符对不会影响给定数据的输出结果，但一个稳健的实现必须能正确地解析这一定义。\n\n相异度 $d(q, s)$ 的计算是一个经典的动态规划问题，可使用 Wagner-Fischer 算法高效求解。设 $q$ 为长度为 $m$ 的字符串，$s$ 为长度为 $n$ 的字符串。我们构建一个大小为 $(m+1) \\times (n+1)$ 的矩阵 $D$，其中 $D_{i,j}$ 存储将前缀 $q[1\\dots i]$ 转换为前缀 $s[1\\dots j]$ 的最小代价。该矩阵根据以下递推关系填充：\n\n初始化：\n-   $D_{i,0} = i$ 对于 $i \\in [0, m]$（从 $q$ 中删除 $i$ 个字符的代价）。\n-   $D_{0,j} = j$ 对于 $j \\in [0, n]$（为形成 $s$ 而插入 $j$ 个字符的代价）。\n\n对于 $i > 0$ 和 $j > 0$ 的递推：\n$$\nD_{i,j} = \\min \\begin{cases}\nD_{i-1,j} + 1 & \\text{(deletion of } q_i\\text{)}\\\\\nD_{i,j-1} + 1 & \\text{(insertion of } s_j\\text{)}\\\\\nD_{i-1,j-1} + c(q_i, s_j) & \\text{(substitution of } q_i \\text{ with } s_j\\text{)}\n\\end{cases}\n$$\n最终的相异度 $d(q,s)$ 由值 $D_{m,n}$ 给出。\n\n对于每个查询字符串 $q_j \\in Q$，选择过程如下：\n$1$. 对于所有候选字符串 $s_i \\in S$（其中 $i \\in \\{0, 1, \\dots, n-1\\}$），计算相异度 $d(q_j, s_i)$。\n$2$. 确定最小相异度 $d_{\\min}(q_j) = \\min_{i} d(q_j, s_i)$。\n$3$. 识别出达到此最小值的索引集合：$I(q_j) = \\{\\, k \\mid d(q_j, s_k) = d_{\\min}(q_j) \\,\\}$。\n$4$. 应用阈值和决胜规则。给定阈值 $T=2$：\n    - 如果 $d_{\\min}(q_j) \\le T$，所选索引为 $\\operatorname{idx}(q_j) = \\min(I(q_j))$。通过在产生最小距离的索引中选择最小的那个来打破平局。\n    - 如果 $d_{\\min}(q_j) > T$，则未找到合适的候选者，索引设置为 $\\operatorname{idx}(q_j) = -1$。\n\n为每个查询字符串实现这个完整、无歧义的过程。将得出的索引收集到一个列表中以形成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sequence identifier matching problem.\n    \"\"\"\n    \n    # Define the candidate set S as specified in the problem statement.\n    s_candidates = [\n        \"NM_000546.6\",       # s0\n        \"NP_000537.3\",       # s1\n        \"NC_000001.11\",      # s2\n        \"AY123456\",          # s3\n        \"ABO123456\",         # s4\n        \"GCF_000001405.39\",  # s5\n        \"ENST00000335137.4\", # s6\n        \"XM_021893495.1\",    # s7\n        \"LRG_199\",           # s8\n        \"ENST00000335137.5\"  # s9\n    ]\n\n    # Define the query set Q as specified in the problem statement.\n    q_queries = [\n        \"AY123456\",          # q0\n        \"AB0123456\",         # q1\n        \"NM_000546.7\",       # q2\n        \"NC_00001.11\",       # q3\n        \"XM021893495.1\",     # q4\n        \"ENST00000335137.6\", # q5\n        \"XYZ123\",            # q6\n        \"LRG_I99\",           # q7\n        \"NM0005466\"          # q8\n    ]\n\n    # Define the set H of visually confusable character pairs.\n    # We use a set of frozensets for efficient, order-independent lookup.\n    H = {\n        frozenset({'O', '0'}), frozenset({'I', '1'}), frozenset({'l', '1'}),\n        frozenset({'S', '5'}), frozenset({'Z', '2'}), frozenset({'B', '8'}),\n        frozenset({'G', '6'})\n    }\n\n    # Define the tolerance threshold T.\n    T = 2.0\n\n    def substitution_cost(c1, c2):\n        \"\"\"\n        Calculates the substitution cost c(x, y) based on the problem definition.\n        \"\"\"\n        if c1 == c2:\n            return 0.0\n        if frozenset({c1, c2}) in H:\n            return 0.5\n        return 1.0\n\n    def dissimilarity(q_str, s_str):\n        \"\"\"\n        Calculates the dissimilarity d(q, s) using the Wagner-Fischer algorithm\n        with custom substitution costs.\n        \"\"\"\n        m, n = len(q_str), len(s_str)\n        \n        # Initialize the DP matrix using numpy for efficiency.\n        dp = np.zeros((m + 1, n + 1))\n\n        # Initialize first row and column (insertion/deletion costs).\n        for i in range(m + 1):\n            dp[i, 0] = i\n        for j in range(n + 1):\n            dp[0, j] = j\n\n        # Fill the DP matrix using the recurrence relation.\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                cost = substitution_cost(q_str[i-1], s_str[j-1])\n                dp[i, j] = min(dp[i-1, j] + 1,        # Deletion\n                               dp[i, j-1] + 1,        # Insertion\n                               dp[i-1, j-1] + cost)   # Substitution/Match\n        \n        return dp[m, n]\n\n    results = []\n    for q_str in q_queries:\n        distances = [dissimilarity(q_str, s_str) for s_str in s_candidates]\n        \n        d_min = min(distances)\n        \n        if d_min <= T:\n            # Find the smallest index i where d(q, s_i) == d_min.\n            # The problem guarantees I(q) is non-empty here.\n            # We iterate to find the first such index, which is the minimum.\n            best_idx = -1\n            for i, dist in enumerate(distances):\n                if dist == d_min:\n                    best_idx = i\n                    break\n            results.append(best_idx)\n        else:\n            results.append(-1)\n            \n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2428373"}, {"introduction": "处理单个标识符是一回事，但现代生物信息学常常需要我们以编程方式从 NCBI 这样的大型数据库中检索成千上万条序列。本练习 [@problem_id:2428408] 模拟了这一真实场景，要求你在遵守 API 请求频率和批量大小限制的前提下，规划一个最优的数据获取策略。这不仅是对标识符分类能力的考验，更是对系统性思维和资源管理效率的实际锻炼。", "problem": "给定一个字符串列表，这些字符串据称是美国国家生物技术信息中心 (NCBI) Entrez 工具 (E-utilities) 的序列登录号。您的任务是编写一个程序，对每个测试用例，将这些字符串分类为有效的核苷酸标识符（将发送至 Entrez 核苷酸核心数据库，表示为 “nuccore”）、有效的蛋白质标识符（将发送至 Entrez 蛋白质数据库）或无效标识符。然后，在标识符查询受速率限制和请求容量约束的情况下，计算完成所有必需请求所需的最短总时间。最后，报告指定的计数和计算出的最短时间。此过程不执行任何网络访问；这纯粹是一个基于输入和约束的逻辑调度计算。\n\n登录号分类规则必须遵循以下第一性原则规范：\n\n1. 字符串将完全按原样处理；去重操作区分大小写，并在任何其他步骤之前应用。去重后，每个唯一的字符串将被独立分类。\n2. 一个字符串是有效的 RefSeq 蛋白质登录号，当且仅当它匹配“前缀_主体.可选版本”模式，其中前缀是 $NP$、$XP$、$YP$ 或 $WP$ 之一；有一个下划线字符；主体由一个或多个数字 $0$–$9$ 组成；并且可能有一个可选的版本后缀，由一个点后跟一个或多个数字组成。形式上，它匹配正则表达式 `^(NP|XP|YP|WP)_\\d+(\\.\\d+)?$`，且所有字母均为大写。\n3. 一个字符串是有效的 RefSeq 核苷酸登录号，当且仅当它匹配“前缀_主体.可选版本”模式，其中前缀是 $NC$、$NG$、$NM$、$NR$、$NT$、$NW$、$NZ$、$XM$ 或 $XR$ 之一；有一个下划线字符；主体由一个或多个大写字母 $A$–$Z$ 和数字 $0$–$9$ 组成；并且可能有一个可选的版本后缀，由一个点后跟一个或多个数字组成。形式上，它匹配正则表达式 `^(NC|NG|NM|NR|NT|NW|NZ|XM|XR)_[A-Z0-9]+(\\.\\d+)?$`，且所有字母均为大写。\n4. 一个字符串是有效的 GenBank 蛋白质登录号，当且仅当它由恰好三个大写字母 $A$–$Z$、紧随其后的恰好五个数字 $0$–$9$ 组成，并且可选地带有一个由点后跟一个或多个数字组成的版本后缀。形式上，它匹配正则表达式 `^[A-Z]{3}\\d{5}(\\.\\d+)?$`。\n5. 一个字符串是有效的 GenBank 核苷酸登录号，当且仅当它由恰好两个大写字母 $A$–$Z$、紧随其后的恰好六个数字 $0$–$9$ 组成，并且可选地带有一个由点后跟一个或多个数字组成的版本后缀。形式上，它匹配正则表达式 `^[A-Z]{2}\\d{6}(\\.\\d+)?$`。\n6. 就本问题而言，任何不匹配上述任何规则的字符串都是无效的。纯数字的旧版 GenInfo 标识符 (GI) 格式或包含小写字母的字符串不符合上述规则，因此在此处被视为无效。\n\n查询模型和约束：\n\n- 去重和分类后，您将向 Entrez E-utilities 发出一组请求：发送到 nuccore 数据库的请求仅包含核苷酸登录号，发送到 protein 数据库的请求仅包含蛋白质登录号。\n- 每个请求最多可包含 $B$ 个发往单个数据库的唯一登录号，其中 $B$ 是请求容量（一个整数，$B \\ge 1$）。\n- 设 $n_{\\text{nuc}}$ 是唯一有效核苷酸登录号的数量，$n_{\\text{prot}}$ 是唯一有效蛋白质登录号的数量。所需请求数是满足 $q_{\\text{nuc}} \\cdot B \\ge n_{\\text{nuc}}$ 和 $q_{\\text{prot}} \\cdot B \\ge n_{\\text{prot}}$ 的最小整数 $q_{\\text{nuc}}$ 和 $q_{\\text{prot}}$。\n- 除速率限制外，请求是瞬时完成的；没有单次请求延迟，也没有超出下述速率限制的并发限制。\n- 两个数据库组合的全局请求速率上限为每秒 $R$ 个请求，$R \\gt 0$。此外，nuccore 数据库的请求速率上限为每秒 $r_{\\text{nuc}}$ 个请求，$r_{\\text{nuc}} \\gt 0$；protein 数据库的请求速率上限为每秒 $r_{\\text{prot}}$ 个请求，$r_{\\text{prot}} \\gt 0$。\n- 您可以在任何实数值时间点上安排请求，唯一的限制是不得超过由 $R$、$r_{\\text{nuc}}$ 和 $r_{\\text{prot}}$ 所隐含的瞬时速率。\n\n目标：\n\n- 在最优调度下，计算提交所有 $q_{\\text{nuc}} + q_{\\text{prot}}$ 个请求而不违反任何速率限制所需的最短总完成时间 $T^\\ast$（以秒为单位）。\n\n每个测试用例的报告要求：\n\n- 报告一个包含七个值的列表：\n  1) 整数 $n_{\\text{nuc}}$，\n  2) 整数 $n_{\\text{prot}}$，\n  3) 整数 $n_{\\text{invalid}}$（去重后唯一无效字符串的数量），\n  4) 整数 $q_{\\text{nuc}}$，\n  5) 整数 $q_{\\text{prot}}$，\n  6) 整数 $q_{\\text{tot}} = q_{\\text{nuc}} + q_{\\text{prot}}$，\n  7) 最短完成时间 $T^\\ast$，表示为四舍五入到恰好 $3$ 位小数的实数（以秒为单位）。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号内由逗号分隔的列表。每个测试用例的结果本身也应是按上述顺序排列的列表。例如，您的输出应类似于“[case1,case2,case3]”，其中每个“case$k$”是一个包含七个值的列表。\n\n测试套件：\n\n对于每个测试用例，输入包括一个登录号字符串列表以及参数 $B$、$R$、$r_{\\text{nuc}}$ 和 $r_{\\text{prot}}$。\n\n- 测试用例 A:\n  - 登录号: [\"NM_000546.6\", \"NP_000537.3\", \"AY123456.1\", \"AAA12345.1\", \"XR_002600.2\", \"WP_012345678.1\", \"AB123456\", \"ABC12345\", \"123456789\", \"nm_000546.6\"]\n  - $B = 3$, $R = 5$, $r_{\\text{nuc}} = 3$, $r_{\\text{prot}} = 2$.\n- 测试用例 B:\n  - 登录号: [\"NP_000001.1\",\"NP_000002.1\",\"NP_000003.1\",\"NP_000004.1\",\"NP_000005.1\",\"NP_000006.1\"]\n  - $B = 2$, $R = 10$, $r_{\\text{nuc}} = 3$, $r_{\\text{prot}} = 2$.\n- 测试用例 C:\n  - 登录号: [\"12345\", \"gi|1234|\", \"bad\", \"\"]\n  - $B = 10$, $R = 1$, $r_{\\text{nuc}} = 1$, $r_{\\text{prot}} = 1$.\n- 测试用例 D:\n  - 登录号: [\"NM_001200.1\", \"NM_001200.1\", \"NR_123456.7\", \"NR_123456.7\", \"AB123456\", \"AB123456\", \"NW_012345.1\", \"NZ_ABCD01000001.1\", \"XP_123456.1\"]\n  - $B = 2$, $R = 1$, $r_{\\text{nuc}} = 0.5$, $r_{\\text{prot}} = 1$.\n- 测试用例 E:\n  - 登录号: [\"ABC12345.1\",\"AB123456.2\",\"ABC123456\",\"XR_000001.2\",\"YP_009724390.1\",\"WP_000001234.1\",\"NT_113954.1\",\"NG_012345.1\"]\n  - $B = 4$, $R = 3$, $r_{\\text{nuc}} = 2$, $r_{\\text{prot}} = 2$.\n\n单位和舍入：\n\n- 以秒表示 $T^\\ast$，四舍五入到恰好 $3$ 位小数。\n\n您的程序必须精确实现上述定义，并为五个测试用例生成符合所描述确切格式的单行聚合输出。", "solution": "问题陈述已经过严格评估，被认为是有效的。这是一个定义明确、具有科学依据的计算问题，它自洽、一致且无歧义。任务是实现一个基于正则表达式的分类算法，并解决一个速率受限的调度优化问题。\n\n解决方法分为三个连续阶段：标识符分类、请求量化和最优时间计算。\n\n**第一阶段：标识符分类**\n\n首先，对输入的登录号字符串列表进行区分大小写的去重处理，以获得一组唯一的标识符。然后，根据作为正则表达式实现的严格规则层次结构对每个唯一标识符进行分类。这些模式被设计为互斥的。一个标识符被归类为有效核苷酸登录号、有效蛋白质登录号或无效。\n\n分类规则的正式定义如下：\n\n1.  一个字符串是有效的 **RefSeq 蛋白质** 登录号，如果它匹配正则表达式：\n    `^(NP|XP|YP|WP)_\\d+(\\.\\d+)?$`\n    该模式对应于一个来自集合 $\\{NP, XP, YP, WP\\}$ 的前缀、一个下划线、一串一个或多个数字以及一个可选的版本后缀。\n\n2.  一个字符串是有效的 **RefSeq 核苷酸** 登录号，如果它匹配：\n    `^(NC|NG|NM|NR|NT|NW|NZ|XM|XR)_[A-Z0-9]+(\\.\\d+)?$`\n    该模式包括一个来自集合 $\\{NC, NG, NM, NR, NT, NW, NZ, XM, XR\\}$ 的前缀、一个下划线、一串大写字母和/或数字以及一个可选的版本后缀。\n\n3.  一个字符串是有效的 **GenBank 蛋白质** 登录号，如果它匹配：\n    `^[A-Z]{3}\\d{5}(\\.\\d+)?$`\n    该模式由恰好三个大写字母、后跟五个数字和一个可选的版本后缀组成。\n\n4.  一个字符串是有效的 **GenBank 核苷酸** 登录号，如果它匹配：\n    `^[A-Z]{2}\\d{6}(\\.\\d+)?$`\n    该模式由恰好两个大写字母、后跟六个数字和一个可选的版本后缀组成。\n\n5.  任何不符合上述任何模式的字符串都被归类为 **无效**。这包括带有小写字母、规则中未指定的特殊字符或字母与数字长度组合不正确的字符串。\n\n然后统计唯一有效核苷酸登录号 ($n_{\\text{nuc}}$)、唯一有效蛋白质登录号 ($n_{\\text{prot}}$) 和唯一无效标识符 ($n_{\\text{invalid}}$) 的数量。\n\n**第二阶段：请求量化**\n\n每个数据库所需的总请求数由唯一标识符的数量和批处理容量 $B$ 决定。由于每个请求最多可容纳 $B$ 个标识符，请求数是不小于标识符数量除以 $B$ 的最小整数。这使用上取整函数计算。\n\n核苷酸请求数 $q_{\\text{nuc}}$ 为：\n$$\nq_{\\text{nuc}} = \\lceil \\frac{n_{\\text{nuc}}}{B} \\rceil\n$$\n蛋白质请求数 $q_{\\text{prot}}$ 为：\n$$\nq_{\\text{prot}} = \\lceil \\frac{n_{\\text{prot}}}{B} \\rceil\n$$\n总请求数就是 $q_{\\text{tot}} = q_{\\text{nuc}} + q_{\\text{prot}}$。对于 $n=0$ 的情况，请求数为 $0$。\n\n**第三阶段：最短完成时间计算**\n\n问题的核心是找到完成所有 $q_{\\text{nuc}} + q_{\\text{prot}}$ 个请求所需的最短时间 $T^\\ast$，同时要满足三个独立的速率限制。该问题可以建模为寻找满足以下条件的最小时间 $T$，这些条件源于这样一个事实：在时间 $T$ 内完成的某种类型请求的总数不能超过速率乘以 $T$。\n\n1.  **Nuccore 数据库约束**：要以每秒最多 $r_{\\text{nuc}}$ 个请求的速率完成 $q_{\\text{nuc}}$ 个请求，时间 $T$ 必须满足 $T \\cdot r_{\\text{nuc}} \\ge q_{\\text{nuc}}$。这给出了下界：\n    $$\n    T \\ge \\frac{q_{\\text{nuc}}}{r_{\\text{nuc}}}\n    $$\n2.  **蛋白质数据库约束**：类似地，对于 $q_{\\text{prot}}$ 个请求，速率为每秒 $r_{\\text{prot}}$ 个请求：\n    $$\n    T \\ge \\frac{q_{\\text{prot}}}{r_{\\text{prot}}}\n    $$\n3.  **全局约束**：总共 $q_{\\text{tot}} = q_{\\text{nuc}} + q_{\\text{prot}}$ 个请求必须在每秒最多 $R$ 个请求的组合速率下完成：\n    $$\n    T \\ge \\frac{q_{\\text{nuc}} + q_{\\text{prot}}}{R}\n    $$\n最短完成时间 $T^\\ast$ 是满足所有三个不等式的最小时间 $T$。因此，$T^\\ast$ 必须是这三个下界中的最大值，因为它代表了系统的瓶颈。\n$$\nT^\\ast = \\max\\left(\\frac{q_{\\text{nuc}}}{r_{\\text{nuc}}}, \\frac{q_{\\text{prot}}}{r_{\\text{prot}}}, \\frac{q_{\\text{nuc}} + q_{\\text{prot}}}{R}\\right)\n$$\n如果任何请求数（例如 $q_{\\text{nuc}}$）为零，其在 `max` 函数中对应的项为零。$T^\\ast$ 的最终值四舍五入到恰好 $3$ 位小数。\n\n每个测试用例的最终输出是一个有序列表，包含七个计算值：$n_{\\text{nuc}}$、$n_{\\text{prot}}$、$n_{\\text{invalid}}$、$q_{\\text{nuc}}$、$q_{\\text{prot}}$、$q_{\\text{tot}}$ 和舍入后的 $T^\\ast$。", "answer": "```python\nimport numpy as np\nimport re\n\ndef solve():\n    \"\"\"\n    Solves the NCBI accession classification and query scheduling problem\n    for a given suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"accessions\": [\"NM_000546.6\", \"NP_000537.3\", \"AY123456.1\", \"AAA12345.1\", \"XR_002600.2\", \"WP_012345678.1\", \"AB123456\", \"ABC12345\", \"123456789\", \"nm_000546.6\"],\n            \"B\": 3, \"R\": 5, \"r_nuc\": 3, \"r_prot\": 2\n        },\n        {\n            \"accessions\": [\"NP_000001.1\",\"NP_000002.1\",\"NP_000003.1\",\"NP_000004.1\",\"NP_000005.1\",\"NP_000006.1\"],\n            \"B\": 2, \"R\": 10, \"r_nuc\": 3, \"r_prot\": 2\n        },\n        {\n            \"accessions\": [\"12345\", \"gi|1234|\", \"bad\", \"\"],\n            \"B\": 10, \"R\": 1, \"r_nuc\": 1, \"r_prot\": 1\n        },\n        {\n            \"accessions\": [\"NM_001200.1\", \"NM_001200.1\", \"NR_123456.7\", \"NR_123456.7\", \"AB123456\", \"AB123456\", \"NW_012345.1\", \"NZ_ABCD01000001.1\", \"XP_123456.1\"],\n            \"B\": 2, \"R\": 1, \"r_nuc\": 0.5, \"r_prot\": 1\n        },\n        {\n            \"accessions\": [\"ABC12345.1\",\"AB123456.2\",\"ABC123456\",\"XR_000001.2\",\"YP_009724390.1\",\"WP_000001234.1\",\"NT_113954.1\",\"NG_012345.1\"],\n            \"B\": 4, \"R\": 3, \"r_nuc\": 2, \"r_prot\": 2\n        }\n    ]\n\n    # Pre-compile regular expressions for efficiency\n    refseq_prot_re = re.compile(r\"^(NP|XP|YP|WP)_\\d+(\\.\\d+)?$\")\n    refseq_nuc_re = re.compile(r\"^(NC|NG|NM|NR|NT|NW|NZ|XM|XR)_[A-Z0-9]+(\\.\\d+)?$\")\n    genbank_prot_re = re.compile(r\"^[A-Z]{3}\\d{5}(\\.\\d+)?$\")\n    genbank_nuc_re = re.compile(r\"^[A-Z]{2}\\d{6}(\\.\\d+)?$\")\n    \n    protein_res = [refseq_prot_re, genbank_prot_re]\n    nuc_res = [refseq_nuc_re, genbank_nuc_re]\n\n    all_results = []\n\n    for case in test_cases:\n        accessions = case[\"accessions\"]\n        B = case[\"B\"]\n        R = case[\"R\"]\n        r_nuc = case[\"r_nuc\"]\n        r_prot = case[\"r_prot\"]\n\n        # Step 1: De-duplication (case-sensitive)\n        unique_accessions = set(accessions)\n\n        # Step 2: Classification\n        n_nuc = 0\n        n_prot = 0\n        n_invalid = 0\n\n        for acc in unique_accessions:\n            is_prot = any(p_re.match(acc) for p_re in protein_res)\n            if is_prot:\n                n_prot += 1\n                continue\n            \n            is_nuc = any(n_re.match(acc) for n_re in nuc_res)\n            if is_nuc:\n                n_nuc += 1\n                continue\n            \n            n_invalid += 1\n\n        # Step 3: Request Quantification\n        q_nuc = int(np.ceil(n_nuc / B))\n        q_prot = int(np.ceil(n_prot / B))\n        q_tot = q_nuc + q_prot\n\n        # Step 4: Minimal Completion Time Calculation\n        # Handle division by zero for rates, though problem spec says > 0\n        time_nuc = (q_nuc / r_nuc) if r_nuc > 0 else float('inf') if q_nuc > 0 else 0\n        time_prot = (q_prot / r_prot) if r_prot > 0 else float('inf') if q_prot > 0 else 0\n        time_global = (q_tot / R) if R > 0 else float('inf') if q_tot > 0 else 0\n        \n        T_star = max(time_nuc, time_prot, time_global)\n\n        # Format T_star to exactly 3 decimal places\n        T_star_formatted = f\"{T_star:.3f}\"\n\n        # Assemble the results for the current case\n        result_list = [n_nuc, n_prot, n_invalid, q_nuc, q_prot, q_tot, float(T_star_formatted)]\n        all_results.append(result_list)\n        \n    # Final print statement must produce a single line in the required format\n    # The format is a string representation of a list of lists.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2428408"}]}