{"hands_on_practices": [{"introduction": "生物数据库的价值不仅在于其存储的数据量，更在于其数据的质量和不同数据库之间的可靠连接。一个常见的架构是使用主数据库存储原始实验数据，而辅助数据库则对这些数据进行整合、注释和提炼。本练习 [@problem_id:2373026] 将指导你如何将“数据完整性”这一抽象概念量化，通过建立一个评分系统 $S_{\\mathrm{integrity}}$ 来评估主数据库和辅助数据库之间交叉引用的质量。你将学习如何系统地考虑断裂链接和循环引用等常见问题，并将它们整合到一个统一的数学模型中。", "problem": "一级生物学数据库存储原始分子条目，而二级生物学数据库存储衍生的和经过整理的信息，两者通过交叉引用相互连接。考虑一个一级数据库 $\\mathcal{P}$ 和一个二级数据库 $\\mathcal{S}$。交叉引用是一个从 $\\mathcal{P}$ 中的条目指向 $\\mathcal{S}$ 中条目的有向链接。定义以下量：\n- $L$：记录在案的 $\\mathcal{P} \\to \\mathcal{S}$ 链接总数，\n- $B$：断开的 $\\mathcal{P} \\to \\mathcal{S}$ 链接数量，意味着 $\\mathcal{S}$ 中的目标登录号无法解析为一个现有的条目，\n- $V$：有效的 $\\mathcal{P} \\to \\mathcal{S}$ 链接数量，其中 $V=L-B$，\n- $K$：在 $V$ 个有效链接中，构成 $p \\to s \\to p$ 形式循环两步引用的链接数量，其中 $p \\in \\mathcal{P}$，$s \\in \\mathcal{S}$，且从 $s$ 的反向链接指向引用 $s$ 的同一个 $p$。\n\n你的任务是定义一个完整性得分 $S_{\\mathrm{integrity}}$，用于量化从 $\\mathcal{P}$ 到 $\\mathcal{S}$ 的交叉引用的质量，该得分需满足以下要求：\n1. 如果 $B=0$ 且 $K=0$，则 $S_{\\mathrm{integrity}}=1$。\n2. 由断开链接产生的惩罚项仅取决于分数 $B/L$，且与该分数值成线性关系。\n3. 由循环引用产生的惩罚项仅取决于分数 $K/V$，且与该分数值成线性关系。\n4. 这两个惩罚项是可加的，因此 $S_{\\mathrm{integrity}}=1 - a\\,(B/L) - b\\,(K/V)$，其中 $a$ 和 $b$ 为常数。\n5. 校准条件A：对于一个恰好有一半链接断开且没有循环引用的数据集，得分为 $S_{\\mathrm{integrity}}=0.70$。\n6. 校准条件B：对于一个没有断开链接且恰好有四分之一的有效链接构成循环两步引用的数据集，得分为 $S_{\\mathrm{integrity}}=0.85$。\n\n对于一个真实数据集，其数据为 $L=1240$，$B=160$ 和 $K=210$，请计算满足上述要求所隐含的 $S_{\\mathrm{integrity}}$。报告一个纯数字，四舍五入到四位有效数字。", "solution": "我们从给定的要求开始。得分必须采用以下形式\n$$\nS_{\\mathrm{integrity}} \\;=\\; 1 \\;-\\; a\\,\\frac{B}{L} \\;-\\; b\\,\\frac{K}{V},\n$$\n其中 $V=L-B$。常数 $a$ 和 $b$ 由校准条件确定。\n\n使用校准条件 A，其中恰好一半的链接是断开的，并且没有循环引用，我们有 $B/L = \\frac{1}{2}$ 和 $K/V=0$，得到\n$$\n0.70 \\;=\\; 1 \\;-\\; a \\cdot \\frac{1}{2} \\;-\\; b \\cdot 0 \\;=\\; 1 \\;-\\; \\frac{a}{2}.\n$$\n解出 $a$ 可得，\n$$\n\\frac{a}{2} \\;=\\; 1 - 0.70 \\;=\\; 0.30 \\;\\;\\Rightarrow\\;\\; a \\;=\\; 0.60.\n$$\n\n使用校准条件 B，其中没有断开的链接，且四分之一的有效链接是循环的，我们有 $B/L=0$ 和 $K/V=\\frac{1}{4}$，得到\n$$\n0.85 \\;=\\; 1 \\;-\\; a \\cdot 0 \\;-\\; b \\cdot \\frac{1}{4} \\;=\\; 1 \\;-\\; \\frac{b}{4}.\n$$\n解出 $b$ 可得，\n$$\n\\frac{b}{4} \\;=\\; 1 - 0.85 \\;=\\; 0.15 \\;\\;\\Rightarrow\\;\\; b \\;=\\; 0.60.\n$$\n\n因此得分公式变为\n$$\nS_{\\mathrm{integrity}} \\;=\\; 1 \\;-\\; 0.60\\,\\frac{B}{L} \\;-\\; 0.60\\,\\frac{K}{V}.\n$$\n\n对于给定的数据集，我们计算 $V$：\n$$\nV \\;=\\; L - B \\;=\\; 1240 - 160 \\;=\\; 1080.\n$$\n接着，计算这两个分数：\n$$\n\\frac{B}{L} \\;=\\; \\frac{160}{1240} \\;=\\; \\frac{16}{124} \\;=\\; \\frac{4}{31} \\;\\approx\\; 0.1290322581,\n$$\n$$\n\\frac{K}{V} \\;=\\; \\frac{210}{1080} \\;=\\; \\frac{21}{108} \\;=\\; \\frac{7}{36} \\;\\approx\\; 0.1944444444.\n$$\n计算惩罚项：\n$$\n0.60 \\cdot \\frac{B}{L} \\;\\approx\\; 0.60 \\cdot 0.1290322581 \\;=\\; 0.07741935486,\n$$\n$$\n0.60 \\cdot \\frac{K}{V} \\;\\approx\\; 0.60 \\cdot 0.1944444444 \\;=\\; 0.1166666667.\n$$\n惩罚项之和：\n$$\n0.07741935486 + 0.1166666667 \\;=\\; 0.1940860216.\n$$\n因此，\n$$\nS_{\\mathrm{integrity}} \\;=\\; 1 - 0.1940860216 \\;=\\; 0.8059139784.\n$$\n\n四舍五入到四位有效数字，结果是 $0.8059$。", "answer": "$$\\boxed{0.8059}$$", "id": "2373026"}, {"introduction": "在评估了数据库连接的静态质量后，我们转向一个同样重要的问题：数据的动态稳定性。科学知识在不断进步，这意味着数据库中的注释信息也会随时间更新。本练习 [@problem_id:2373028] 引入了一个精妙的概率模型，用于衡量数据库条目中注释的“半衰期” $T_{1/2}$。通过应用泊松过程来模拟注释的更新事件，你将学会如何定量分析一个数据库条目中的信息能保持多久的“新鲜度”，这对于依赖这些数据进行长期研究的用户至关重要。", "problem": "在生物数据库的架构中，一级数据库存储直接源于实验的存档记录，而二级数据库则通过聚合和分析一级来源的内容来整合、衍生或预测特征。考虑一个包含两类注释的条目：一部分比例 $f_{\\mathrm{pri}}$ 来自一级层面，另一部分比例 $f_{\\mathrm{sec}} = 1 - f_{\\mathrm{pri}}$ 来自二级层面。将每个注释的首次更新或修订时间建模为具有恒定风险率的齐次泊松过程中的一次独立到达。具体来说，每个一级层面注释以速率 $\\lambda_{\\mathrm{pri}}$（单位为 $\\mathrm{y}^{-1}$）更新，每个二级层面注释以速率 $\\lambda_{\\mathrm{sec}}$（单位为 $\\mathrm{y}^{-1}$）更新。假设该条目足够大，使得在任何时间 $t$，已更新注释的期望比例等于观测比例。\n\n将该条目的注释半衰期 $T_{1/2}$ 定义为最小的 $t \\ge 0$，使得其初始注释中到时间 $t$ 已被更新或修订的期望比例等于 $0.5$。\n\n给定 $f_{\\mathrm{pri}} = 0.6$，$\\lambda_{\\mathrm{pri}} = 1.1\\ \\mathrm{y}^{-1}$，以及 $\\lambda_{\\mathrm{sec}} = 0.35\\ \\mathrm{y}^{-1}$，计算 $T_{1/2}$。将你的答案四舍五入到4位有效数字。最终时间以年为单位表示。", "solution": "在速率恒为 $\\lambda$ 的齐次泊松过程中，首个事件发生的时间是一个服从指数分布的随机变量。设 $T$ 为单个注释首次更新前的时间。到时间 $t$ 该注释仍未更新的概率由生存函数 $S(t) = P(T > t) = \\exp(-\\lambda t)$ 给出。因此，到时间 $t$ 该注释已被更新的概率由累积分布函数（CDF）给出，$F(t) = P(T \\le t) = 1 - S(t) = 1 - \\exp(-\\lambda t)$。\n\n我们将此模型应用于数据库条目中存在的两类注释。\n对于单个一级层面注释，其在时间 $t$ 前被更新的概率是：\n$$P_{\\mathrm{pri, upd}}(t) = 1 - \\exp(-\\lambda_{\\mathrm{pri}} t)$$\n对于单个二级层面注释，其在时间 $t$ 前被更新的概率是：\n$$P_{\\mathrm{sec, upd}}(t) = 1 - \\exp(-\\lambda_{\\mathrm{sec}} t)$$\n\n问题陈述该数据库条目足够大，可以将已更新注释的期望比例与观测比例等同。这使我们能够计算已更新注释的总体期望比例，记为 $U(t)$，它是两类注释更新概率的加权平均值。权重是它们各自的比例 $f_{\\mathrm{pri}}$ 和 $f_{\\mathrm{sec}}$。\n$$U(t) = f_{\\mathrm{pri}} P_{\\mathrm{pri, upd}}(t) + f_{\\mathrm{sec}} P_{\\mathrm{sec, upd}}(t)$$\n代入概率的表达式，我们得到：\n$$U(t) = f_{\\mathrm{pri}} (1 - \\exp(-\\lambda_{\\mathrm{pri}} t)) + f_{\\mathrm{sec}} (1 - \\exp(-\\lambda_{\\mathrm{sec}} t))$$\n\n注释半衰期 $T_{1/2}$ 被定义为已更新注释的期望比例等于 $0.5$ 的时间。我们令 $U(T_{1/2}) = 0.5$ 并求解 $T_{1/2}$：\n$$0.5 = f_{\\mathrm{pri}} (1 - \\exp(-\\lambda_{\\mathrm{pri}} T_{1/2})) + f_{\\mathrm{sec}} (1 - \\exp(-\\lambda_{\\mathrm{sec}} T_{1/2}))$$\n\n我们已知这些值 $f_{\\mathrm{pri}} = 0.6$，$\\lambda_{\\mathrm{pri}} = 1.1\\ \\mathrm{y}^{-1}$，以及 $\\lambda_{\\mathrm{sec}} = 0.35\\ \\mathrm{y}^{-1}$。二级注释的比例是 $f_{\\mathrm{sec}} = 1 - f_{\\mathrm{pri}} = 1 - 0.6 = 0.4$。将这些值代入方程：\n$$0.5 = 0.6 (1 - \\exp(-1.1 T_{1/2})) + 0.4 (1 - \\exp(-0.35 T_{1/2}))$$\n让我们简化这个表达式。\n$$0.5 = 0.6 - 0.6 \\exp(-1.1 T_{1/2}) + 0.4 - 0.4 \\exp(-0.35 T_{1/2})$$\n$$0.5 = (0.6 + 0.4) - (0.6 \\exp(-1.1 T_{1/2}) + 0.4 \\exp(-0.35 T_{1/2}))$$\n$$0.5 = 1 - (0.6 \\exp(-1.1 T_{1/2}) + 0.4 \\exp(-0.35 T_{1/2}))$$\n整理各项，我们得到需要求解 $T_{1/2}$ 的方程：\n$$0.6 \\exp(-1.1 T_{1/2}) + 0.4 \\exp(-0.35 T_{1/2}) = 0.5$$\n\n这是一个超越方程，对于 $T_{1/2}$ 不存在直接的解析解。我们必须使用数值方法来求根。让我们定义一个函数 $g(t) = 0.6 \\exp(-1.1 t) + 0.4 \\exp(-0.35 t) - 0.5$。我们寻求使 $g(t) = 0$ 的 $t > 0$ 的值。\n\n函数 $g(t)$ 在 $t \\ge 0$ 上是连续且单调递减的，因为其导数 $g'(t) = -0.66 \\exp(-1.1 t) - 0.14 \\exp(-0.35 t)$ 始终为负。此外，$g(0) = 0.6 + 0.4 - 0.5 = 0.5$ 且 $\\lim_{t \\to \\infty} g(t) = -0.5$。根据介值定理，必然存在一个唯一的正根使得 $g(t) = 0$。\n\n使用数值求解器（例如牛顿-拉弗森法或二分法），我们找到方程的根。\n解得 $T_{1/2}$ 约等于 $0.94363$ 年。\n题目要求答案四舍五入到4位有效数字。\n$$T_{1/2} \\approx 0.9436\\ \\mathrm{years}$$\n这就是给定模型和参数下该条目的注释半衰期。", "answer": "$$\\boxed{0.9436}$$", "id": "2373028"}, {"introduction": "一个精心设计的数据库架构本身不是目的，其最终价值在于支持强大而高效的数据查询与分析。这个压轴实践 [@problem_id:2373039] 完美地诠释了这一点，它要求你将一个生态食物网抽象为图数据库模型。你将亲手实现一个算法，来查询这个层次分明的结构，从而找出与初级生产者相距特定“营养级”的生物。这个练习将抽象的架构概念（如主数据库的原始关系和辅助数据库的派生属性）转化为解决具体生物学问题的实用工具，让你深刻体会到良好架构在科学发现中的力量。", "problem": "给定一个生态生物学数据库的概念架构，该架构包含两个层次：一个主数据库和一个次级数据库。主数据库 (PD) 将直接的营养相互作用存储为有向图中的有向边，而次级数据库 (SD) 存储派生的注释，例如与初级生产者的营养距离。初级生产者是指不消耗任何其他生物体的生物体。目标是对次级数据库形式化一个查询：找到所有与任何初级生产者相距正好三个营养级的生物体，其中“营养级”定义为一个从资源（猎物）指向消费者（捕食者）方向的有向捕食链接。\n\n形式上，设食物网表示为一个有向图 $G=(V,E)$，其中 $V$ 是生物体标识符的有限集合，$E \\subseteq V \\times V$ 是一组有序对 $(u,v)$ 的集合，表示生物体 $u$ 被生物体 $v$ 直接消耗。设 $S \\subseteq V$ 是已识别的初级生产者的集合。对于 $s \\in S$ 和 $v \\in V$，如果从 $s$ 到 $v$ 存在有向路径，则定义 $d(s,v)$ 为从 $s$ 到 $v$ 的最短有向路径的长度（以有向边的数量计）；否则 $d(s,v)$ 未定义。对于一个生产者集合 $S$，将节点 $v$ 与生产者的营养距离定义为\n$$\n\\delta_S(v) = \\min_{s \\in S} d(s,v),\n$$\n前提是至少有一个 $d(s,v)$ 已定义。所期望的查询结果是集合\n$$\nD_3(S)=\\{\\, v \\in V \\mid \\delta_S(v)=3 \\,\\}。\n$$\n\n你的任务是编写一个完整的程序，对以下每个独立的测试用例，计算并返回 $D_3(S)$ 中生物体标识符的排序列表。\n\n解释和要求：\n- 每个测试用例提供一个有向边列表 $E$ 和一个初级生产者集合 $S$。\n- 有向边从资源指向消费者。单个捕食者可能有多个资源，并且可能存在循环。\n- 对于每个测试用例，计算集合 $D_3(S)$，该集合包含所有与生产者集合 $S$ 的最短有向距离等于 $3$ 的节点，并按升序输出节点标识符。\n- 如果 $D_3(S)$ 为空，则为该测试用例输出一个空列表。\n- 所有生物体标识符都是正整数，你必须输出整数，而不是字符串。\n\n测试套件：\n- 测试用例 1：\n  - $E_1 = \\{(1,2),(1,3),(2,4),(3,4),(4,5),(5,6),(2,7)\\}$\n  - $S_1 = \\{1\\}$\n- 测试用例 2：\n  - $E_2 = \\{(1,2),(2,3),(3,4),(8,9),(9,10),(10,11),(2,5),(5,6),(6,4)\\}$\n  - $S_2 = \\{1,8\\}$\n- 测试用例 3：\n  - $E_3 = \\{(1,2),(2,3),(3,2),(3,4),(4,5),(5,3)\\}$\n  - $S_3 = \\{1\\}$\n- 测试用例 4：\n  - $E_4 = \\{(1,2),(2,1)\\}$\n  - $S_4 = \\{1\\}$\n- 测试用例 5：\n  - $E_5 = \\{(1,2)\\}$\n  - $S_5 = \\{10\\}$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有五个测试用例的结果，形式为用方括号括起来的逗号分隔列表。此外部列表的每个元素都必须是对应测试用例的内部已排序（升序）的整数列表。例如，包含三个测试用例的输出可能看起来像 $[[1,4],[3],[]]$。", "solution": "我们如下形式化用于生态食物网的主、次级生物数据库的架构。主数据库 (PD) 保存原始的实体关系数据：生物体作为节点，直接的营养相互作用作为从资源到消费者的有向边。这自然地被建模为一个有向图 $G=(V,E)$，其中 $E \\subseteq V \\times V$。次级数据库 (SD) 从 PD 派生注释，例如与初级生产者的营养距离。从概念上讲，SD 存储由 $\\delta_S(v)=\\min_{s \\in S} d(s,v)$ 定义的函数 $\\delta_S: V \\to \\mathbb{N}$，其中 $d(s,v)$ 是在 $G$ 中从 $s$到 $v$ 的最短有向路径的长度。查询“与初级生产者相距正好三个营养级的生物体”被形式化为从 SD 中检索 $D_3(S)=\\{ v \\in V \\mid \\delta_S(v)=3\\}$。\n\n根据图论的第一性原理，在一个有向无权图中，从一个源集合 $S$ 到所有可达节点的最短路径长度（以边数计算）可以通过执行广度优先搜索 (BFS) 来获得，该搜索从距离为 $0$ 的整个集合 $S$ 开始。BFS 按路径长度的非递减顺序探索各层，节点首次被发现时就确定了其最短路径距离。因此，要计算 $D_3(S)$，只需执行以下操作：\n- 对所有 $s \\in S$ 初始化距离 $\\text{dist}(s)=0$，对其他情况则 $\\text{dist}(v)$ 未定义。\n- 使用队列按递增的距离分层遍历图，从节点 $u$ 传播到所有出邻居 $v$，并在尚未分配距离时设置 $\\text{dist}(v)=\\text{dist}(u)+1$。\n- 在距离超过 $3$ 时停止探索，因为最短距离大于 $3$ 的节点不能对 $D_3(S)$ 作出贡献。\n- 收集所有 $\\text{dist}(v)=3$ 的节点。\n\n因为 PD 提供的边 $(u,v)$ 是从资源指向消费者的，所以边的连续应用正好对应于连续的营养级。BFS 通过其性质自然地处理了循环和多个生产者的问题：一个节点首次被分配距离时，是通过来自 $S$ 中最近生产者的最短有向路径实现的；随后的更长替代路径将被忽略。\n\n我们现在通过分析有向可达性和路径长度来计算所提供测试套件的预期结果。\n\n- 测试用例 1：\n  - $E_1 = \\{(1,2),(1,3),(2,4),(3,4),(4,5),(5,6),(2,7)\\}$, $S_1=\\{1\\}$。\n  - 从 $1$ 出发，距离为 $1$ 的节点是 $\\{2,3\\}$。距离为 $2$ 的是 $\\{4,7\\}$。距离为 $3$ 的只有 $\\{5\\}$（通过 $1 \\to 2 \\to 4 \\to 5$ 或 $1 \\to 3 \\to 4 \\to 5$）。因此，按升序排列的 $D_3(S_1)$ 是 $[5]$。\n\n- 测试用例 2：\n  - $E_2 = \\{(1,2),(2,3),(3,4),(8,9),(9,10),(10,11),(2,5),(5,6),(6,4)\\}$, $S_2=\\{1,8\\}$。\n  - 从 $1$ 出发：距离为 $1$ 的是 $\\{2\\}$，距离为 $2$ 的是 $\\{3,5\\}$，距离为 $3$ 的是 $\\{4,6\\}$。从 $8$ 出发：距离为 $1$ 的是 $\\{9\\}$，距离为 $2$ 的是 $\\{10\\}$，距离为 $3$ 的是 $\\{11\\}$。与任一生产者距离恰好为 $3$ 的节点的并集为 $\\{4,6,11\\}$，所以 $D_3(S_2)=[4,6,11]$。\n\n- 测试用例 3：\n  - $E_3 = \\{(1,2),(2,3),(3,2),(3,4),(4,5),(5,3)\\}$, $S_3=\\{1\\}$。\n  - 在 $\\{2,3,5\\}$ 之间存在一个循环，但从 $1$ 出发的最短距离是：$\\text{dist}(2)=1$，$\\text{dist}(3)=2$，$\\text{dist}(4)=3$，$\\text{dist}(5)=4$。因此 $D_3(S_3)=[4]$。\n\n- 测试用例 4：\n  - $E_4 = \\{(1,2),(2,1)\\}$, $S_4=\\{1\\}$。\n  - $\\text{dist}(2)=1$，$\\text{dist}(1)=0$。没有节点的最短距离为 $3$，因为重新访问循环不会改变最短距离。因此 $D_3(S_4)=[\\,]$（空列表）。\n\n- 测试用例 5：\n  - $E_5 = \\{(1,2)\\}$, $S_5=\\{10\\}$。\n  - 在给定的图中，节点 $10$ 没有出边。没有节点可以从 $10$ 到达，所以 $D_3(S_5)=[\\,]$。\n\n从算法上讲，对于每个测试用例，为 $G$ 构建一个邻接表，从 $S$ 中的所有源点同时运行一个 BFS，分配最长为 $3$ 的最短距离，并收集距离恰好为 $3$ 的节点，按升序排序。最终输出是聚合了五个内部列表的外部列表，按规定打印在单行上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef nodes_at_exact_distance_three(edges, producers):\n    # Build adjacency list from edges (u -> v)\n    adj = {}\n    nodes = set()\n    for u, v in edges:\n        nodes.add(u)\n        nodes.add(v)\n        if u not in adj:\n            adj[u] = []\n        adj[u].append(v)\n    # Ensure producers appear in adjacency even if they have no outgoing edges\n    for s in producers:\n        if s not in adj:\n            adj[s] = []\n        nodes.add(s)\n\n    # Multi-source BFS up to depth 3\n    from collections import deque\n    dist = {}\n    q = deque()\n\n    # Initialize queue with all producers at distance 0\n    for s in producers:\n        if s not in dist:\n            dist[s] = 0\n            q.append(s)\n\n    # BFS\n    while q:\n        u = q.popleft()\n        du = dist[u]\n        if du == 3:\n            # Do not expand further from nodes already at depth 3\n            continue\n        for v in adj.get(u, []):\n            if v not in dist:\n                dist[v] = du + 1\n                # Only enqueue if we have not exceeded depth 3\n                if dist[v] <= 3:\n                    q.append(v)\n\n    # Collect nodes at exact distance 3\n    result = sorted([v for v, d in dist.items() if d == 3])\n    return result\n\ndef format_list_of_lists_no_spaces(lol):\n    # Formats e.g., [[5],[4,6,11],[4],[],[]] without spaces\n    inner = []\n    for lst in lol:\n        inner.append(\"[\" + \",\".join(str(x) for x in lst) + \"]\")\n    return \"[\" + \",\".join(inner) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"edges\": [(1,2),(1,3),(2,4),(3,4),(4,5),(5,6),(2,7)],\n            \"producers\": [1],\n        },\n        # Test case 2\n        {\n            \"edges\": [(1,2),(2,3),(3,4),(8,9),(9,10),(10,11),(2,5),(5,6),(6,4)],\n            \"producers\": [1,8],\n        },\n        # Test case 3\n        {\n            \"edges\": [(1,2),(2,3),(3,2),(3,4),(4,5),(5,3)],\n            \"producers\": [1],\n        },\n        # Test case 4\n        {\n            \"edges\": [(1,2),(2,1)],\n            \"producers\": [1],\n        },\n        # Test case 5\n        {\n            \"edges\": [(1,2)],\n            \"producers\": [10],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        edges = case[\"edges\"]\n        producers = case[\"producers\"]\n        result = nodes_at_exact_distance_three(edges, producers)\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_of_lists_no_spaces(results))\n\nsolve()\n```", "id": "2373039"}]}