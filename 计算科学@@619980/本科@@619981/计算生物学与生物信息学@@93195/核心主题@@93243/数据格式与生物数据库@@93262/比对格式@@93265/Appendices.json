{"hands_on_practices": [{"introduction": "CIGAR 字符串是 SAM/BAM 格式中描述比对细节的“地图”。本练习将通过一个具体的 CIGAR 字符串，带你实践如何解码其中的比对操作（如匹配 $M$、插入 $I$ 和缺失 $D$），并利用这些信息计算出测序读段（read）的原始长度。这是一项在数据质控和脚本编写中至关重要的基本技能。[@problem_id:2370597]", "problem": "在序列比对/图谱（SAM）格式及其二进制等价格式（BAM）中，每个比对都包含一个紧凑型特异性缺口比对报告（CIGAR）字符串，该字符串编码了比对操作的长度和类型。考虑 CIGAR 字符串 $15\\mathrm{M}5\\mathrm{I}10\\mathrm{M}5\\mathrm{D}15\\mathrm{M}$。$\\mathrm{M}$ 操作表示比对匹配或错配，同时消耗读段（read）和参考序列的核苷酸；$\\mathrm{I}$ 操作表示相对于参考序列的插入，仅消耗读段的核苷酸；$\\mathrm{D}$ 操作表示相对于参考序列的读段删除，仅消耗参考序列的核苷酸。每个操作之前的整数给出了该操作应用的核苷酸数量。假设不存在软剪切（$\\mathrm{S}$）或硬剪切（$\\mathrm{H}$）操作。\n\n当一个 DNA 读段（查询）序列与某个参考序列比对时，能够产生此 CIGAR 字符串的该读段的最小可能长度是多少（以核苷酸为单位）？请用一个整数表示你的答案。", "solution": "该问题要求根据给定的 CIGAR 字符串确定一个 DNA 读段（或查询序列）的长度。CIGAR 字符串是“紧凑型特异性缺口比对报告”的缩写，它提供了一种比对的简洁表示方法。查询序列的总长度是通过将所有消耗查询序列自身碱基的 CIGAR 操作的长度相加得到的。\n\n该问题为三种类型的操作提供了定义：\n- 操作 $\\mathrm{M}$（比对匹配或错配）同时消耗查询序列和参考序列的碱基。\n- 操作 $\\mathrm{I}$（相对于参考序列的插入）仅消耗查询序列的碱基。\n- 操作 $\\mathrm{D}$（相对于参考序列的查询序列中发生删除）仅消耗参考序列的碱基。\n\n问题陈述明确排除了剪切操作（$\\mathrm{S}$ 和 $\\mathrm{H}$）的存在。这是一个关键的简化，因为它意味着由 CIGAR 字符串描述的序列长度是明确无误的。因此，“最小可能长度”这一短语等同于参与比对的序列片段的唯一确定长度。\n\n提供的 CIGAR 字符串是 $15\\mathrm{M}5\\mathrm{I}10\\mathrm{M}5\\mathrm{D}15\\mathrm{M}$。设 $L_{\\text{read}}$ 为读段序列的长度（以核苷酸为单位）。我们必须通过解析 CIGAR 字符串并对消耗读段的每个部分的贡献求和来计算 $L_{\\text{read}}$。\n\n各部分的贡献如下：\n- 部分 $15\\mathrm{M}$ 对应于从读段中消耗的 $15$ 个碱基。\n- 部分 $5\\mathrm{I}$ 对应于从读段中消耗的 $5$ 个碱基。\n- 部分 $10\\mathrm{M}$ 对应于从读段中消耗的 $10$ 个碱基。\n- 部分 $5\\mathrm{D}$ 对应于读段中的一个删除。它消耗参考序列的碱基，因此对读段长度的贡献为 $0$ 个碱基。\n- 部分 $15\\mathrm{M}$ 对应于从读段中消耗的 $15$ 个碱基。\n\n为了求得总长度 $L_{\\text{read}}$，我们将这些值相加：\n$$L_{\\text{read}} = 15 + 5 + 10 + 0 + 15$$\n执行加法运算：\n$$L_{\\text{read}} = 20 + 10 + 15$$\n$$L_{\\text{read}} = 30 + 15$$\n$$L_{\\text{read}} = 45$$\n因此，产生给定 CIGAR 字符串的 DNA 读段的长度为 $45$ 个核苷酸。", "answer": "$$\\boxed{45}$$", "id": "2370597"}, {"introduction": "SAM/BAM 文件中的 $FLAG$ 字段是一个高度浓缩的比对属性摘要，通过二进制位来高效存储信息。这个思想实验将向你展示，$FLAG$ 字段中一个微小的比特位翻转，如何能彻底改变我们对测序数据的生物学解读，甚至产生“幽灵”结构变异信号。通过这个练习，你将深刻理解为何精确解读 $FLAG$ 字段对于发现真实的生物学信号和避免假阳性至关重要。[@problem_id:2370643]", "problem": "一个双末端全基因组测序数据集使用标准内向文库构型进行了比对，其中一个正确配对的片段具有读段 $1$ 映射到参考基因组的正向链，而读段 $2$ 映射到反向链（通常描述为“FR”文库）。比对器输出序列比对/图（SAM）标志，而二进制比对/图（BAM）格式也编码了相同的标志。SAM标志是一个按位编码的整数：每个属性由一个具有固定值的比特位表示，总标志值是所有适用比特位值的总和。请考虑大多数比对器和下游工具使用的以下核心定义：\n- 比特值 $1$：模板是双末端的。\n- 比特值 $2$：模板中的每个片段都根据比对器正确比对。\n- 比特值 $4$：该片段（读段）未映射。\n- 比特值 $8$：其配对片段未映射。\n- 比特值 $16$：该片段映射到反向互补链。\n- 比特值 $32$：其配对片段映射到反向互补链。\n- 比特值 $64$：这是模板中的第一个片段（读段 $1$）。\n- 比特值 $128$：这是模板中的第二个片段（读段 $2$）。\n\n你检查了一个读段对，其读段 $1$ 的SAM标志为 $99$，读段 $2$ 的SAM标志为 $147$。其映射坐标和插入片段大小是典型正确配对的特征。现在假设一个单位比特错误翻转了读段 $1$ 中表示“该片段是反向互补的”比特位的状态，而所有其他比特位和比对坐标保持不变。\n\n下列哪项最能概括读段 $1$ 标志中这一比特翻转可能导致的最重大的生物学解读变化？\n\nA. 该读段对可能会被重新解读为不一致的“倒位样”方向（两个读段都在反向链上），并可能在该位点附近产生一个假阳性的结构变异信号。\n\nB. 该读段对仍将被所有下游工具视作正确配对，因为映射位置和插入片段大小未变；方向比特位在实践中会被忽略。\n\nC. 这一变化只会影响重复标记，而不会影响生物学解读，因为重复标记仅依赖于映射起始位置和CIGAR字符串。\n\nD. 该读段将被视作未映射并从分析中移除，从而消除了对该读段对产生任何生物学误读的可能性。", "solution": "首先必须验证问题陈述的科学合理性、清晰度和完整性。\n\n步骤 1：提取已知条件\n- **测序文库：** 双末端，标准内向构型（$\\text{FR}$ 类型：读段 $1$ 在正向链，读段 $2$ 在反向链，定义为正确配对）。\n- **SAM/BAM 标志定义（按位）：**\n    - $1$：模板是双末端的。\n    - $2$：模板中的每个片段都根据比对器正确比对。\n    - $4$：该片段（读段）未映射。\n    - $8$：其配对片段未映射。\n    - $16$：该片段映射到反向互补链。\n    - $32$：其配对片段映射到反向互补链。\n    - $64$：这是模板中的第一个片段（读段 $1$）。\n    - $128$：这是模板中的第二个片段（读段 $2$）。\n- **初始状态：**\n    - 读段 $1$ 的 SAM 标志：$99$。\n    - 读段 $2$ 的 SAM 标志：$147$。\n    - 映射坐标和插入片段大小是典型正确配对的特征。\n- **扰动：**\n    - 一个单位比特错误翻转了读段 $1$ 中表示“该片段是反向互补的”（比特值 $16$）的比特位状态。\n    - 所有其他比特位和比对坐标保持不变。\n\n步骤 2：使用提取的已知条件进行验证\n该问题描述了计算生物学领域的一个场景，特别是与序列比对/图（SAM）和二进制比对/图（BAM）格式相关，这些格式在基因组学中是标准格式。\n\n- **科学依据充分：** SAM 标志的定义是正确的，并遵循官方规范。文库构型（$\\text{FR}$）、正确配对以及代表结构变异的不一致配对等概念是序列比对分析的基础。该场景在科学上是合理的。\n- **问题定义明确：** 该问题提供了一个清晰的初始状态（标志 $99$ 和 $147$）、一个精确的修改（特定的比特翻转），并要求找出最重要的后果。所有必要信息都已提供，足以推导出新状态并评估其影响。\n- **客观性：** 语言技术性强且精确。问题要求找出“最重要的变化”，在生物数据分析的背景下，这指的是对下游解读（如变异检测）影响最大的变化。这是一个客观的评估。\n\n该问题是自包含、一致的，并且基于已确立的生物信息学原理。假设的比特翻转是一个定义明确的操作，会导致数据表示发生可预测的变化，其后果可以被严格分析。\n\n步骤 3：结论与行动\n问题陈述有效。我将继续进行解答推导。\n\n**初始状态分析**\n\n首先，我们必须分解初始的 SAM 标志，以理解比对器所描述的读段对状态。标志值是所有为真属性的比特值之和。\n\n对于读段 $1$，标志为 $99$：\n$99 = 64 + 32 + 2 + 1$。\n解码如下：\n- $64$：这是第一个片段（读段 $1$）。\n- $32$：其配对片段（读段 $2$）映射到反向互补链。\n- $2$：该配对是正确比对的。\n- $1$：模板是双末端的。\n比特 $16$（该片段是反向互补的）未设置，因此读段 $1$ 在正向链上。这描述了读段 $1$ 在正向链，而其配对片段在反向链。\n\n对于读段 $2$，标志为 $147$：\n$147 = 128 + 16 + 2 + 1$。\n解码如下：\n- $128$：这是第二个片段（读段 $2$）。\n- $16$：该片段映射到反向互补链。\n- $2$：该配对是正确比对的。\n- $1$：模板是双末端的。\n比特 $32$（其配对片段是反向互补的）未设置，因此其配对片段（读段 $1$）在正向链上。这描述了读段 $2$ 在反向链，而其配对片段在正向链。\n\n这些标志（$99$ 和 $147$）的组合一致地描述了一个来自标准 $\\text{FR}$ 文库的“正确配对”：读段 $1$ 是正向的，读段 $2$ 是反向的，并且它们彼此朝向。两个标志中都存在的“正确比对”比特（$2$）证实了比对器的这一解读。\n\n**扰动分析**\n\n问题陈述，对于读段 $1$ 而言，表示“该片段是反向互补的”（值 $16$）的比特位被翻转了。\n读段 $1$ 的初始标志是 $99$。值为 $16$ 的比特位未被设置。在这种情况下，“翻转”意味着将该比特位设置为真。因此，读段 $1$ 的新标志是原始标志加上被翻转的比特位的值：\n读段 $1$ 的新标志 = $99 + 16 = 115$。\n\n**新状态分析**\n\n该读段对现在由读段 $1$ 的标志 $115$ 和读段 $2$ 的标志 $147$ 描述。让我们分析这个新状态对下游工具的意义，特别是对结构变异（SV）检测的意义。\n\n读段 $1$ 的新标志是 $115$：\n$115 = 64 + 32 + 16 + 2 + 1$。\n关键变化是由于比特 $16$ 的新出现：\n- $64$：这是读段 $1$。\n- $16$：该片段（读段 $1$）映射到反向互补链。\n- $32$：其配对片段（读段 $2$）映射到反向互补链。\n- （其他比特位 `1`、`2` 不变）。\n\n读段 $2$ 的标志仍为 $147$，表明它在反向链上。\n因此，基于单个方向标志的新解读是：\n- 读段 $1$ 在反向链上（由于标志 $115$ 中的比特 $16$）。\n- 读段 $2$ 在反向链上（由于标志 $147$ 中的比特 $16$）。\n\n该读段对的方向已从 $\\text{FR}$（正向-反向，`-> ... <-`）变为 $\\text{RR}$（反向-反向，`<- ... <-`）。这是一种不一致的读段对方向。在标准文库的背景下，$\\text{RR}$ 方向，即两个读段都映射到同一条链并指向相同方向，是基因组倒位的经典特征。这些读段位于倒位断点的一侧。\n\n因为问题指出这一变化是由技术错误（比特翻转）而非真实的生物学重排引起的，任何识别出这种 $\\text{RR}$ 模式的工具都将报告一个不存在的结构变异。这是一个假阳性检出，是生物学误读的一种严重形式。\n\n根据问题陈述，比特 `2`（“正确配对”）在标志中保持设置状态。一个简单的工具如果只选择比特 `2` 未设置的配对，可能会在不一致性分析中过滤掉这个读段对。然而，稳健的 SV 检测工具不仅仅依赖于“正确配对”标志。它们会基于基本标志（如 $16$ 和 $32$）和映射位置重新评估配对的几何构型（方向、插入片段大小）。这样的工具即使在比特 `2` 存在的情况下，也会将此配对识别为不一致，并将其标记为倒位的证据。\n\n**选项评估**\n\n**A. 该读段对可能会被重新解读为不一致的“倒位样”方向（两个读段都在反向链上），并可能在该位点附近产生一个假阳性的结构变异信号。**\n该陈述与我们的推导一致。比特翻转将读段 $1$ 的方向改变为反向，形成一个 $\\text{RR}$ 配对。这种方向是倒位的典型特征。由于该配对原本是正常的，这会导致一个假阳性的 SV 信号。这是一个在生物学解读上具有重大影响的变化。**正确**。\n\n**B. 该读段对仍将被所有下游工具视作正确配对，因为映射位置和插入片段大小未变；方向比特位在实践中会被忽略。**\n该陈述从根本上是错误的。方向比特位（$16$ 和 $32$）对于解读双末端数据至关重要，并且绝不会被下游工具忽略。它们是读段对几何构型的主要指标，对于 SV 检测、RNA-seq 分析和其他应用至关重要。根据定义，对于 $\\text{FR}$ 文库，$\\text{RR}$ 方向不是一个正确配对。**不正确**。\n\n**C. 这一变化只会影响重复标记，而不会影响生物学解读，因为重复标记仅依赖于映射起始位置和CIGAR字符串。**\n该陈述在两方面是错误的。首先，重复标记算法（如 Picard 的算法）确实会使用链信息来确定用于比较的正确的 5' 映射坐标，因此比特翻转会对其产生影响。更重要的是，声称这*仅仅*影响重复标记而对生物学解读没有影响是明显错误的。如前所述，这一变化为一个结构变异创造了一个强烈但虚假的信号，这对生物学解读有重大影响。**不正确**。\n\n**D. 该读段将被视作未映射并从分析中移除，从而消除了对该读段对产生任何生物学误读的可能性。**\n该陈述是错误的。表示“未映射”的比特标志是比特 $4$。问题明确指出只有比特 $16$ 被翻转。比特 $4$ 在原始标志（$99$）中未被设置，在新标志（$115$）中也未被设置。该读段仍然是映射状态。因此，它将被包含在下游分析中，并可能被误读。**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2370643"}, {"introduction": "将所有知识融会贯通，是掌握复杂技术的关键。本练习将模拟一个真实的生物信息学任务：将一种格式的原始比对数据转换为标准的 SAM 记录。你需要综合运用前面学到的知识，正确地生成 $FLAG$、$CIGAR$ 和 $POS$ 这三个核心字段，特别是处理那些棘手的边界情况，如比对两端的缺失。这项综合实践将巩固你对 SAM 格式精密规则的理解，为将来处理和开发生物信息学工具打下坚实基础。[@problem_id:2370602]", "problem": "您会获得一组源自基本局部比对搜索工具 (Basic Local Alignment Search Tool, BLAST) 的表格形式的比对结果，其中包含查询序列和参考序列的明确的、带空位的成对比对字符串，以及参考序列坐标和链方向。您的任务是将每条比对转换为序列比对/图谱 (Sequence Alignment/Map, SAM) 记录中的字段，这些字段对于验证比对几何形状是必需的：位标记 FLAG、最左侧参考位置 POS 和紧凑型 CIGAR 字符串。由于未提供序列和碱基质量，因此输出中不需要这些信息。二进制比对/图谱 (Binary Alignment/Map, BAM) 对 CIGAR 操作符使用标准的整数编码；您必须使用这些编码将生成的 CIGAR 编码为一个由“长度-操作符代码”对组成的列表。\n\n形式上，对于每条比对记录，您会获得：\n- 一个查询名称字符串 $qname$ 和一个参考名称字符串 $rname$。\n- 一个链指示符 $strand \\in \\{\"+\",\"-\"\\}$，表示查询序列与参考序列的比对方向。\n- 参考序列的起始和结束坐标 $r_{start}$ 和 $r_{end}$，它们是基于 1 的闭区间坐标，其跨度恰好等于带空位比对中参考序列符号的数量（即，参考序列比对字符串中非空位字符的数量），当 $strand = \"+\"$ 时 $r_{start} \\le r_{end}$，当 $strand = \"-\"$ 时 $r_{start} \\ge r_{end}$。\n- 两个等长字符串 $aln\\_q$ 和 $aln\\_r$，仅由字符 $\\{\"A\",\"C\",\"G\",\"T\",\"-\"\\}$ 组成，它们描述了带空位字符 $\"-\"$ 的比对后查询序列和参考序列，空位字符表示插入或缺失。\n\n您必须为每条比对生成以下 SAM 组件：\n- 整数形式的位标记 FLAG：如果 $strand = \"+\"$，则使用 $0$；如果 $strand = \"-\"$，则使用 $16$。所有其他位均未设置，因为这些是单端已比对的序列。\n- POS 字段，表示读段比对到参考序列上的最左侧 1-based 参考坐标。定义 $L = \\min(r_{start}, r_{end})$。通过从左到右扫描 $aln\\_q$ 和 $aln\\_r$ 来构建原始 CIGAR，并根据以下规则仅使用操作符 $M$、$I$ 和 $D$ 合并连续的操作：\n  - 如果 $aln\\_q[i] \\neq \"-\"$ 且 $aln\\_r[i] \\neq \"-\"$，则发出一个长度为 $1$ 的 $M$（比对匹配或错配；不区分匹配和错配）。\n  - 如果 $aln\\_q[i] = \"-\"$ 且 $aln\\_r[i] \\neq \"-\"$，则发出一个长度为 $1$ 的 $D$（相对于查询序列的缺失，消耗参考序列）。\n  - 如果 $aln\\_q[i] \\neq \"-\"$ 且 $aln\\_r[i] = \"-\"$，则发出一个长度为 $1$ 的 $I$（相对于参考序列的插入，消耗查询序列）。\n  - 不会出现 $aln\\_q[i] = \"-\"$ 且 $aln\\_r[i] = \"-\"$ 的情况。\n  - 将相邻的相同操作合并为具有总长度的单个运行。\n  构建此原始 CIGAR 运行列表后，移除所有前导和尾随的 $D$ 运行，因为有效的 SAM 比对不能以缺失开头或结尾。设 $d_{low}$ 为在第一个比对上的查询碱基之前，与比对的最左侧基因组坐标相邻的缺失所消耗的参考碱基数。按如下方式计算 $d_{low}$：\n  - 如果 $strand = \"+\"$，则 $d_{low}$ 是从开头移除的前导 $D$ 运行的长度（如果没有，则为 $0$）。\n  - 如果 $strand = \"-\"$，则 $d_{low}$ 是从末尾移除的尾随 $D$ 运行的长度（如果没有，则为 $0$）。\n  最后，设置 $POS = L + d_{low}$。\n- 经过上述修剪后，以运行长度形式表示的 CIGAR，仅使用 $M$、$I$ 和 $D$。对于输出，使用 BAM 操作符代码对此 CIGAR 进行编码：$M \\mapsto 0$、$I \\mapsto 1$、$D \\mapsto 2$。将 CIGAR 表示为 $[len,op]$ 对的列表，其中 $len$ 是正整数，$op \\in \\{0,1,2\\}$。\n\n假设映射质量不可用，如果需要，在 SAM 中会报告为 $MAPQ = 255$。由于未提供序列和碱基质量，$SEQ$ 和 $QUAL$ 不属于必需的输出部分。对于配对字段，假设是单端数据，因此在完整的 SAM 行中 $RNEXT = \"*\"$、$PNEXT = 0$、$TLEN = 0$；这些不会出现在必需的输出中。\n\n您必须实现一个程序，对于下面嵌入在程序中的固定测试套件，为每个测试用例生成一个包含三个元素的列表：整数 FLAG、整数 POS 和编码后的 CIGAR（一个使用上述操作符代码的 $[len,op]$ 对列表）。将所有测试用例的结果聚合到一个列表中，并在一行上以方括号括起来的逗号分隔列表形式打印，嵌套列表使用相同的方括号格式。不应打印任何其他文本。\n\n测试套件（每个测试用例是一个元组，字段顺序为 $(qname, rname, strand, r_{start}, r_{end}, aln\\_q, aln\\_r)$）：\n- 测试用例 1（正向链，相对于参考序列有一次插入）：\n  - $qname = \\text{\"read1\"}$, $rname = \\text{\"chr1\"}$, $strand = \\text{\"+\"}$, $r_{start} = 7$, $r_{end} = 11$, $aln\\_q = \\text{\"ACTGAC\"}$, $aln\\_r = \\text{\"ACT-AC\"}$。\n- 测试用例 2（反向链，相对于查询序列有一次缺失）：\n  - $qname = \\text{\"read2\"}$, $rname = \\text{\"chr2\"}$, $strand = \\text{\"-\"}$, $r_{start} = 100$, $r_{end} = 96$, $aln\\_q = \\text{\"A-CCT\"}$, $aln\\_r = \\text{\"AGCCT\"}$。\n- 测试用例 3（正向链，有前导缺失和尾随插入）：\n  - $qname = \\text{\"read3\"}$, $rname = \\text{\"chr3\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1000$, $r_{end} = 1004$, $aln\\_q = \\text{\"--ACGT\"}$, $aln\\_r = \\text{\"TTACG-\"}$。\n- 测试用例 4（反向链，在低坐标端有尾随缺失）：\n  - $qname = \\text{\"read4\"}$, $rname = \\text{\"chr4\"}$, $strand = \\text{\"-\"}$, $r_{start} = 500$, $r_{end} = 495$, $aln\\_q = \\text{\"AC-T--\"}$, $aln\\_r = \\text{\"ACCTGG\"}$。\n- 测试用例 5（正向链，仅有错配，无空位）：\n  - $qname = \\text{\"read5\"}$, $rname = \\text{\"chr5\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1$, $r_{end} = 3$, $aln\\_q = \\text{\"AGT\"}$, $aln\\_r = \\text{\"ACT\"}$。\n\n角度单位不适用。不涉及物理单位。所有输出均为整数或整数列表。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，例如 $[\\,[flag\\_1,POS\\_1,CIGAR\\_1],\\,[flag\\_2,POS\\_2,CIGAR\\_2],\\,\\dots\\,]$，其中每个 $CIGAR\\_i$ 本身是使用 BAM 操作符代码 $M \\mapsto 0$、$I \\mapsto 1$、$D \\mapsto 2$ 的 $[len,op]$ 对的列表。", "solution": "问题陈述具有科学依据、提法明确且客观。它提出了一个明确定义的算法任务，即将特定的表格比对格式转换为标准的序列比对/图谱（SAM）字段。所提供的输入、规则和测试用例是自成一体的，并与生物信息学中的既定原则相一致。因此，该问题是有效的，并将提供一个解决方案。\n\n将每个给定的比对记录转换为所需的 SAM 字段——位标记 $FLAG$、位置 $POS$ 和编码后的 $CIGAR$ 字符串——的过程分三个连续阶段执行。\n\n首先，确定位标记 $FLAG$。SAM 格式规范使用位标记来编码比对的属性。代表链的位是 $0x10$，即十进制的 $16$。根据问题描述，如果比对到正向链 ($strand = \\text{\"+\"}$)，则 $FLAG$ 设置为 $0$。如果比对到反向互补链 ($strand = \\text{\"-\"}$)，则 $FLAG$ 设置为 $16$。与配对、质量或补充状态相关的其他标记不予考虑，这与所提供的信息一致。\n\n其次，构建并编码 $CIGAR$ 字符串。$CIGAR$ 字符串提供了比对结构的紧凑表示。过程如下：\n$1$. 从左到右逐个字符地扫描比对字符串 $aln\\_q$ (查询) 和 $aln\\_r$ (参考)。\n$2$. 对每个位置 $i$，确定一个操作：如果 $aln\\_q[i]$ 和 $aln\\_r[i]$ 都是碱基，则为比对匹配/错配 ($M$)；如果 $aln\\_q[i]$ 是一个空位 ($\"-\"$)，则为从参考序列中删除 ($D$)；如果 $aln\\_r[i]$ 是一个空位 ($\"-\"$)，则为向参考序列中插入 ($I$)。两者都是空位的情况被禁止。\n$3$. 然后将这个单字符操作序列进行合并。连续的相同操作被合并成一个具有总长度的单一操作。例如，序列 $M, M, M$ 变为 $3M$。这会产生一个原始的运行长度编码的 $CIGAR$。\n$4$. 根据问题规范，有效的 SAM 比对不能以删除 ($D$) 开始或结束。因此，任何前导或尾随的 $D$ 操作运行都会从原始 $CIGAR$ 中被移除。这些被移除的运行长度被记录下来，用于后续计算 $POS$ 字段。\n$5$. 最后，将修剪后的 $CIGAR$ 字符串转换为其在 BAM 格式中使用的二进制表示。操作符 $M$、$I$ 和 $D$ 分别映射到整数代码 $0$、$1$ 和 $2$。最终的 $CIGAR$ 是一个由“长度-操作符代码”对（例如 $[len, op]$）组成的列表。\n\n第三，计算 $POS$ 字段。SAM 格式中的 $POS$ 字段指定了主比对的 1-based 最左侧映射位置。该计算严重依赖于链方向和任何被修剪的删除操作。\n$1$. 确定比对范围的最左侧基因组坐标 $L$ 为 $L = \\min(r_{start}, r_{end})$。请注意，对于正向链比对，$L = r_{start}$；对于反向链比对，$L = r_{end}$。\n$2$. 必须计算一个关键的调整因子 $d_{low}$。该因子说明了那些属于原始比对块，但因为对应于查询序列开始或末尾的删除而被从最终 $CIGAR$ 中修剪掉的参考碱基。$d_{low}$ 的定义取决于链方向：\n   - 对于正向链 ($strand = \\text{\"+\"}$) 比对，比对的“左”侧对应于 CIGAR 字符串的开始和低的基因组坐标。因此，$d_{low}$是被移除的前导 $D$ 运行的长度。\n   - 对于反向链 ($strand = \\text{\"-\"}$) 比对，比对的“左”侧（在基因组坐标中）对应于查询序列的末端，因此也对应于 CIGAR 字符串的末端。因此，$d_{low}$ 是被移除的尾随 $D$ 运行的长度。\n$3$. 最终的 $POS$ 值计算为 $POS = L + d_{low}$。这调整了起始位置，以计入被与查询序列第一个比对碱基相邻的修剪删除所消耗的参考碱基。\n\n作为示例，让我们将此过程应用于测试用例 3：\n- 输入：$strand = \\text{\"+\"}$，$r_{start} = 1000$，$r_{end} = 1004$，$aln\\_q = \\text{\"--ACGT\"}$，$aln\\_r = \\text{\"TTACG-\"}$。\n- $FLAG$：由于 $strand = \\text{\"+\"}$，$FLAG = 0$。\n- $CIGAR$ 生成：\n  - 扫描 $aln\\_q$和 $aln\\_r$ 得到操作序列 $[D, D, M, M, M, I]$。\n  - 合并结果得到原始 $CIGAR$：$2D3M1I$。\n  - 修剪前导/尾随的 $D$ 操作：前导的 $2D$ 被移除。得到的 $CIGAR$ 是 $3M1I$。\n  - 被移除的前导 $D$ 运行的长度是 $2$。\n  - 使用编码 $M \\mapsto 0、I \\mapsto 1$ 对 $3M1I$ 进行编码，得到 $[[3, 0], [1, 1]]$。\n- $POS$ 计算：\n  - $L = \\min(1000, 1004) = 1000$。\n  - $strand$ 是 $\\text{\"+\"}$，所以 $d_{low}$ 是被移除的前导 $D$ 运行的长度，即 $2$。\n  - $POS = L + d_{low} = 1000 + 2 = 1002$。\n- 测试用例 3 的最终结果：$[0, 1002, [[3, 0], [1, 1]]]$。\n\n这个严谨的、分步的过程将应用于每个测试用例，以生成最终所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Solves the problem of converting BLAST-like alignments to SAM fields.\n    \"\"\"\n    \n    # Test suite provided in the problem statement.\n    test_cases = [\n        # Case 1 (forward strand with an insertion relative to the reference):\n        (\"read1\", \"chr1\", \"+\", 7, 11, \"ACTGAC\", \"ACT-AC\"),\n        # Case 2 (reverse strand with a deletion relative to the query):\n        (\"read2\", \"chr2\", \"-\", 100, 96, \"A-CCT\", \"AGCCT\"),\n        # Case 3 (forward strand with leading deletions and a trailing insertion):\n        (\"read3\", \"chr3\", \"+\", 1000, 1004, \"--ACGT\", \"TTACG-\"),\n        # Case 4 (reverse strand with trailing deletions at the low-coordinate end):\n        (\"read4\", \"chr4\", \"-\", 500, 495, \"AC-T--\", \"ACCTGG\"),\n        # Case 5 (forward strand with mismatches only, no gaps):\n        (\"read5\", \"chr5\", \"+\", 1, 3, \"AGT\", \"ACT\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the test case tuple for clarity.\n        qname, rname, strand, r_start, r_end, aln_q, aln_r = case\n\n        # 1. Determine the bitwise FLAG\n        flag = 16 if strand == \"-\" else 0\n\n        # 2. Generate the raw CIGAR string\n        op_map = {'M': 0, 'I': 1, 'D': 2}\n        raw_ops = []\n        for q_char, r_char in zip(aln_q, aln_r):\n            if q_char != '-' and r_char != '-':\n                raw_ops.append('M')  # Match or Mismatch\n            elif q_char != '-' and r_char == '-':\n                raw_ops.append('I')  # Insertion to reference\n            elif q_char == '-' and r_char != '-':\n                raw_ops.append('D')  # Deletion from reference\n        \n        # Coalesce adjacent identical operations\n        if not raw_ops:\n            raw_cigar_list = []\n        else:\n            raw_cigar_list = []\n            current_op = raw_ops[0]\n            current_len = 1\n            for op in raw_ops[1:]:\n                if op == current_op:\n                    current_len += 1\n                else:\n                    raw_cigar_list.append([current_len, current_op])\n                    current_op = op\n                    current_len = 1\n            raw_cigar_list.append([current_len, current_op])\n        \n        # 3. Trim CIGAR and calculate POS\n        \n        # Record lengths of leading/trailing deletions before trimming\n        d_leading = 0\n        if raw_cigar_list and raw_cigar_list[0][1] == 'D':\n            d_leading = raw_cigar_list[0][0]\n        \n        d_trailing = 0\n        if raw_cigar_list and len(raw_cigar_list) > 1 and raw_cigar_list[-1][1] == 'D':\n            d_trailing = raw_cigar_list[-1][0]\n        elif raw_cigar_list and len(raw_cigar_list) == 1 and raw_cigar_list[0][1] == 'D':\n            d_trailing = raw_cigar_list[0][0]\n\n        # Trim leading 'D'\n        trimmed_cigar = list(raw_cigar_list) # Make a copy\n        if trimmed_cigar and trimmed_cigar[0][1] == 'D':\n            trimmed_cigar.pop(0)\n            \n        # Trim trailing 'D'\n        if trimmed_cigar and trimmed_cigar[-1][1] == 'D':\n            trimmed_cigar.pop(-1)\n\n        # Calculate d_low based on strand\n        d_low = 0\n        if strand == '+':\n            d_low = d_leading\n        elif strand == '-':\n            # For reverse strand, trailing deletions in the alignment string\n            # correspond to the low-coordinate end of the reference alignment.\n            d_low = d_trailing\n            \n        # Calculate the leftmost genomic coordinate L\n        L = min(r_start, r_end)\n        \n        # Final POS calculation\n        pos = L + d_low\n        \n        # 4. Encode the final CIGAR using BAM operator codes\n        encoded_cigar = [[length, op_map[op]] for length, op in trimmed_cigar]\n        \n        results.append([flag, pos, encoded_cigar])\n\n    # Final print statement in the exact required format.\n    # The default str() representation of lists includes spaces, which is\n    # consistent with the example format in the problem description.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2370602"}]}