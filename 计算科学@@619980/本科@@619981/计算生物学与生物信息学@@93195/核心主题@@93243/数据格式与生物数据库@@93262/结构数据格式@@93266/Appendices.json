{"hands_on_practices": [{"introduction": "在生物信息学中，数据的质量和一致性至关重要。蛋白质数据库（PDB）格式虽然强大，但也存在历史遗留的命名不一致问题。这个练习将引导你扮演“数据侦探”的角色，通过编写一个简单的验证器来识别和标记PDB文件中已弃用或不标准的残基名称。这项实践不仅能让你熟悉PDB文件的固定宽度格式，还能让你掌握根据受控词汇表进行数据验证的核心技能，这是确保生物数据分析可重复性和准确性的第一步。[@problem_id:2431200]", "problem": "您需要编写一个完整、可运行的程序，为蛋白质数据库（Protein Data Bank, PDB）的纯文本文件记录实现一个验证器。该验证器必须能够根据指定的受控词汇表，检测出已弃用的同义词或非标准的残基名称。您的程序必须严格按照下述规则执行，并处理本问题中定义的一组固定的测试用例。\n\n定义和字段布局：\n- 仅当记录名称（占据位置 $1$ 至 $6$，含边界，$1$ 为起始索引）为精确字符串 \"ATOM␣␣\" 或 \"HETATM\" 时，该记录才被处理。所有其他类型的记录都必须被忽略。\n- 残基名称字段占据位置 $18$ 至 $20$（含边界，$1$ 为起始索引）。如果某行长度小于位置 $20$，因此不包含完整的残基名称字段，则该行必须被忽略。\n- 一个残基名称 $x$ 被认为是标准的，当且仅当 $x \\in S$，$S$ 是规范的三字母氨基酸残基名称与水的集合：\n  $S = \\{$ALA, ARG, ASN, ASP, CYS, GLN, GLU, GLY, HIS, ILE, LEU, LYS, MET, PHE, PRO, SER, THR, TRP, TYR, VAL, HOH$\\}$。\n- 一个从已弃用同义词到规范残基名称的映射 $M$ 已被指定。任何残基名称 $x \\in \\mathrm{dom}(M)$ 都被视为已弃用的同义词，并且必须被标记。该映射为：\n  - WAT $\\mapsto$ HOH\n  - HID $\\mapsto$ HIS\n  - HIE $\\mapsto$ HIS\n  - HIP $\\mapsto$ HIS\n  - ASH $\\mapsto$ ASP\n  - GLH $\\mapsto$ GLU\n  - LYN $\\mapsto$ LYS\n  - CYX $\\mapsto$ CYS\n  - CYM $\\mapsto$ CYS\n- 一个残基名称 $x$ 被认为是非标准的，当且仅当 $x \\notin S$ 且 $x \\notin \\mathrm{dom}(M)$。\n\n计数规则：\n- 对于每个输入用例，定义 $c_{\\mathrm{deprecated}}$ 为残基名称在 $\\mathrm{dom}(M)$ 中的记录数量，定义 $c_{\\mathrm{nonstd}}$ 为残基名称既不在 $S$ 中也不在 $\\mathrm{dom}(M)$ 中的记录数量。\n- 只有类型为 \"ATOM␣␣\" 和 \"HETATM\" 的记录才计入这些数量，并且前提是它们包含完整的残基名称字段（即位置 $18$–$20$ 存在）。\n\n测试输入的合成：\n- 每个测试用例被指定为一个有序的三元组列表 $(r, x, m)$，其中 $r$ 是记录名称字符串，$x$ 是一个 3 个字母的大写残基名称字符串，$m \\in \\{0,1\\}$ 是一个二进制指示符。\n- 对于每个三元组 $(r, x, m)$，按如下方式合成单行文本：\n  1. 将 $r$ 左对齐放入位置 $1$–$6$（如果需要，右侧用空格填充）。\n  2. 用空格填充位置 $7$–$16$。\n  3. 在位置 $17$ 放置一个空格。\n  4. 如果 $m = 0$，将残基名称 $x$ 放入位置 $18$–$20$；如果 $m = 1$，则在位置 $20$ 之前截断该行，以使残基名称字段缺失。\n  5. 位置 $20$ 之后的任何字符都是无关紧要的，可以省略。\n- 整个测试用例的内容是这些合成行以换行符分隔拼接而成的。\n\n测试套件：\n- 用例 $1$： [(\"ATOM␣␣\",\"ALA\",$0$), (\"ATOM␣␣\",\"GLY\",$0$), (\"HETATM\",\"HOH\",$0$)]\n- 用例 $2$： [(\"HETATM\",\"WAT\",$0$), (\"HETATM\",\"WAT\",$0$), (\"ATOM␣␣\",\"HIS\",$0$)]\n- 用例 $3$： [(\"ATOM␣␣\",\"HIE\",$0$), (\"ATOM␣␣\",\"HID\",$0$), (\"HETATM\",\"ABC\",$0$), (\"ATOM␣␣\",\"LYN\",$0$)]\n- 用例 $4$： [(\"ATOM␣␣\",\"GLU\",$1$), (\"ATOM␣␣\",\"GLH\",$0$), (\"TER␣␣␣\",\"GLY\",$0$), (\"HETATM\",\"MSE\",$0$)]\n- 用例 $5$： [] (空用例)\n\n对于每个用例 $i$，计算如上定义的数对 $[c_{\\mathrm{deprecated}}^{(i)}, c_{\\mathrm{nonstd}}^{(i)}]$。\n\n最终输出格式：\n- 您的程序必须生成单行文本，其中包含一个类似 JSON 的结果列表表示，每个测试用例一个结果，按顺序排列，每个结果是该用例的一个双元素列表 $[c_{\\mathrm{deprecated}}, c_{\\mathrm{nonstd}}]$。\n- 例如，三个用例的输出应类似于 \"[[a,b],[c,d],[e,f]]\"，其中 $a,b,c,d,e,f$ 由整数替代，且无额外空格。", "solution": "问题陈述已经过严格验证，并被认定是合理的。它在科学上基于生物信息学的原理，特别是关于蛋白质数据库（PDB）文件格式的解析和验证。该问题提法恰当、客观且自成体系，为获得唯一且可验证的解提供了所有必要的定义、规则和数据。不存在逻辑矛盾、歧义或事实错误。因此，我们可以着手进行求解。\n\n任务是实现一个验证器，该验证器处理一系列模拟的 PDB 记录行，并根据提供的词汇表统计已弃用和非标准残基名称的出现次数。解决方案要求系统地应用一组已定义的规则。\n\n解决方案的核心是一个遍历一系列测试用例的算法。对于每个用例，它处理一个三元组列表 $(r, x, m)$，其中 $r$ 是记录名称，$x$ 是残基名称，$m$ 是一个指示记录是否被截断的二进制标志。\n\n首先，我们必须定义受控词汇表。标准残基名称的集合 $S$ 如下：\n$$ S = \\{\\text{ALA, ARG, ASN, ASP, CYS, GLN, GLU, GLY, HIS, ILE, LEU, LYS, MET, PHE, PRO, SER, THR, TRP, TYR, VAL, HOH}\\} $$\n已弃用同义词的映射 $M$ 也已指定：\n$$ M = \\{ \\text{WAT} \\mapsto \\text{HOH}, \\text{HID} \\mapsto \\text{HIS}, \\text{HIE} \\mapsto \\text{HIS}, \\text{HIP} \\mapsto \\text{HIS}, \\text{ASH} \\mapsto \\text{ASP}, \\text{GLH} \\mapsto \\text{GLU}, \\text{LYN} \\mapsto \\text{LYS}, \\text{CYX} \\mapsto \\text{CYS}, \\text{CYM} \\mapsto \\text{CYS} \\} $$\n由此映射，我们推导出已弃用残基名称的集合，即 $M$ 的定义域，记为 $\\mathrm{dom}(M)$。为了计算效率，$S$ 将被实现为集合数据结构，其成员资格测试的平均时间复杂度为 $O(1)$。映射 $M$ 将是一个字典或哈希映射，其定义域 $\\mathrm{dom}(M)$ 将从其键派生，同样构成一个集合以实现高效查找。\n\n对于每个测试用例，算法按以下步骤进行：\n1. 初始化两个计数器：$c_{\\mathrm{deprecated}} = 0$ 和 $c_{\\mathrm{nonstd}} = 0$。\n2. 对于测试用例中提供的每个三元组 $(r, x, m)$：\n    a. 首先，我们应用记录级别的过滤器。记录名称 $r$ 必须是精确字符串 `\"ATOM  \"` 或 `\"HETATM\"`。如果 $r$ 不匹配，则忽略该三元组，继续处理下一个。\n    b. 其次，我们检查完整性。问题规定短于位置 $20$ 的行将被忽略。二进制指示符 $m$ 合成了此规则：若 $m = 1$，则该行被视为截断，残基名称字段缺失。因此，如果 $m = 1$，该三元组也会被忽略。\n    c. 如果一个三元组通过了这两个过滤器（即，具有有效的记录名称且未被截断），则对其残基名称 $x$ 进行分类。\n    d. 分类逻辑如下：\n        i. 如果残基名称 $x$ 存在于已弃用名称的集合中，即 $x \\in \\mathrm{dom}(M)$，则计数器 $c_{\\mathrm{deprecated}}$ 增加 1。\n        ii. 如果 $x$ 不是已弃用的同义词，我们接着检查它是否为非标准。一个残基是非标准的，如果 $x \\notin S$ 且 $x \\notin \\mathrm{dom}(M)$。由于第一个条件（$x \\in \\mathrm{dom}(M)$）已经被评估过，此检查简化为：如果 $x \\notin S$，则计数器 $c_{\\mathrm{nonstd}}$ 增加 1。一个标准残基（$x \\in S$）不会导致计数器发生变化。\n3. 处理完给定用例的所有三元组后，记录得到的计数对 $[c_{\\mathrm{deprecated}}, c_{\\mathrm{nonstd}}]$。\n\n对所有指定的测试用例重复此过程。最后，将收集到的结果对列表格式化为单个字符串，即一个类似 JSON 的数组的数组，以满足问题指定的输出格式要求。这确保了为所提供的测试套件生成确定且正确的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# No external libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the PDB residue validator problem by processing a fixed suite of test cases.\n    \"\"\"\n    # Define the controlled vocabulary for standard and deprecated residue names.\n    # S is the set of canonical three-letter amino acid residue names plus water.\n    standard_residues = {\n        \"ALA\", \"ARG\", \"ASN\", \"ASP\", \"CYS\", \"GLN\", \"GLU\", \"GLY\", \"HIS\", \n        \"ILE\", \"LEU\", \"LYS\", \"MET\", \"PHE\", \"PRO\", \"SER\", \"THR\", \"TRP\", \n        \"TYR\", \"VAL\", \"HOH\"\n    }\n\n    # M is the mapping of deprecated synonyms to canonical residue names.\n    deprecated_map = {\n        \"WAT\": \"HOH\", \"HID\": \"HIS\", \"HIE\": \"HIS\", \"HIP\": \"HIS\",\n        \"ASH\": \"ASP\", \"GLH\": \"GLU\", \"LYN\": \"LYS\", \"CYX\": \"CYS\",\n        \"CYM\": \"CYS\"\n    }\n    # The domain of M is the set of deprecated residue names.\n    deprecated_residues = set(deprecated_map.keys())\n\n    # Define the test suite as specified in the problem statement.\n    # Each case is a list of triples (record_name, residue_name, is_truncated_flag).\n    test_cases = [\n        # Case 1\n        [(\"ATOM  \", \"ALA\", 0), (\"ATOM  \", \"GLY\", 0), (\"HETATM\", \"HOH\", 0)],\n        # Case 2\n        [(\"HETATM\", \"WAT\", 0), (\"HETATM\", \"WAT\", 0), (\"ATOM  \", \"HIS\", 0)],\n        # Case 3\n        [(\"ATOM  \", \"HIE\", 0), (\"ATOM  \", \"HID\", 0), (\"HETATM\", \"ABC\", 0), (\"ATOM  \", \"LYN\", 0)],\n        # Case 4\n        [(\"ATOM  \", \"GLU\", 1), (\"ATOM  \", \"GLH\", 0), (\"TER   \", \"GLY\", 0), (\"HETATM\", \"MSE\", 0)],\n        # Case 5 (empty case)\n        []\n    ]\n\n    # A list to store the results for each test case.\n    all_results = []\n\n    # Process each test case.\n    for case in test_cases:\n        c_deprecated = 0\n        c_nonstd = 0\n\n        # Process each record (triple) in the current case.\n        for record_name, residue_name, is_truncated in case:\n            # Rule: Only \"ATOM  \" and \"HETATM\" records are considered.\n            if record_name not in (\"ATOM  \", \"HETATM\"):\n                continue\n\n            # Rule: If the record is truncated (m=1), the residue name field is absent and the line is ignored.\n            if is_truncated == 1:\n                continue\n\n            # Classify the residue name.\n            if residue_name in deprecated_residues:\n                c_deprecated += 1\n            elif residue_name not in standard_residues:\n                # This covers the non-standard case, as the deprecated case is already handled.\n                # A name is non-standard if it's not in standard_residues AND not in deprecated_residues.\n                c_nonstd += 1\n\n        # Store the result pair for the current case.\n        all_results.append([c_deprecated, c_nonstd])\n\n    # Format the final output string exactly as required, without any extra whitespace.\n    # Example format: [[a,b],[c,d],[e,f]]\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2431200"}, {"introduction": "在上一个练习的基础上，我们从单行记录的验证深入到整个文件结构的完整性分析。PDB文件不仅仅是原子坐标的简单列表，它通过`TER`记录等来描述大分子的结构层次。此练习旨在验证`TER`记录是否被正确地用来分隔不同的蛋白质链，这是一个常见的格式完整性检查。通过解决这个问题，你将学会如何进行上下文相关的解析，理解记录之间的顺序关系，这是从原始数据中提取结构意义的关键一步。[@problem_id:2431238]", "problem": "您的任务是验证蛋白质数据库（PDB）格式记录中关于链终止标记的结构完整性。蛋白质数据库（PDB）的平面文件是一种固定列宽格式，其中像 ATOM 和 HETATM 等记录指定了属于聚合物链中残基的原子，而 TER 记录则表示链的末端。您必须使用的基本且经过充分测试的事实是：(i) PDB 格式是固定宽度的，链标识符存储在第 $22$ 列（一个字符，使用基于 $1$ 的索引）；(ii) TER 记录指定一个链的末端，使得 TER 前面最近的 ATOM 或 HETATM 记录属于被终止的链，而如果 TER 正确地分隔了链，则 TER 后面最近的 ATOM 或 HETATM 记录必须属于一个不同的链；(iii) ATOM 和 HETATM 记录与 TER 一样，在第 $22$ 列携带链标识符。\n\n当一个 TER 记录没有分隔开不同的链标识符时，就会出现我们所关心的格式异常。形式上，令最近的前导 ATOM 或 HETATM 记录的链标识符为 $c_{\\text{prev}}$，最近的后继 ATOM 或 HETATM 记录的链标识符为 $c_{\\text{next}}$。一个 TER 记录是异常的，当且仅当 $c_{\\text{prev}}$ 和 $c_{\\text{next}}$ 都存在且 $c_{\\text{prev}} = c_{\\text{next}}$。如果任何一侧缺失（例如，文件开头或文件末尾的 TER），则根据此标准不存在异常。\n\n您的程序必须使用这些核心定义，从第一性原理出发实现以下功能：\n\n- 解析每一行，并将其分类为 ATOM、HETATM、TER 或其他。只有 ATOM 和 HETATM 为定义 $c_{\\text{prev}}$ 和 $c_{\\text{next}}$ 提供链标识符。为此目的，请忽略其他记录类型。\n- 从 ATOM、HETATM 和 TER 记录的第 $22$ 列（使用基于 $1$ 的索引）提取链标识符。如果一行短于 $22$ 个字符，则将其链标识符视为空格字符。\n- 对于每个 TER 行，找到最近的前导和最近的后继 ATOM 或 HETATM 行。如果两者都存在且它们的链标识符相等，则该 TER 行是异常的，您必须报告它在该特定 PDB 文本中基于 $1$ 的行索引。\n\n设计您的算法，使其仅依赖于上述逻辑过程和在第 $22$ 列的固定列宽提取，从而可以在任何现代编程语言上运行。\n\n测试套件和要求输出：\n\n实现并使用以下五个 PDB 测试输入。这里列出的每个“记录”都是 PDB 文本中的单行。测试输入被抽象地定义为带有括号内链标识符的记录类型序列，以确保普遍适用性；您的实现应构建符合链标识符固定列宽要求的具体 PDB 格式行。所需的序列是：\n\n- 测试 $1$（正常情况）：ATOM(A), ATOM(A), TER, ATOM(B)。此 TER 将链 $A$ 与链 $B$ 分开，不应产生异常。\n- 测试 $2$（单一异常）：ATOM(A), TER, ATOM(A)。此 TER 未分隔不同链，因此是异常的。\n- 测试 $3$（混合 HETATM 和末端 TER）：ATOM(A), ATOM(A), TER, HETATM(B), TER, ATOM(B), TER。只有 HETATM(B) 和 ATOM(B) 之间的 TER 是异常的，因为它没有分隔不同的链；末尾的 TER 没有后继的 ATOM/HETATM，因此不是异常的。\n- 测试 $4$（空白链标识符）：ATOM(␠), TER, ATOM(␠)，其中 ␠ 表示一个空格。此 TER 未分隔不同链，因此是异常的。\n- 测试 $5$（连续 TER 和边界位置）：TER, ATOM(A), TER, TER, ATOM(B), TER, ATOM(B)。只有紧接在最后一个 ATOM(B) 前面的 TER 是异常的；开头的 TER 不是异常的，分隔 A 和 B 的 TER 是正确的。\n\n对于每个测试输入，您的程序必须返回该输入中异常 TER 记录的基于 $1$ 的行索引列表。将所有五个测试的结果汇总到一行输出中，格式完全如下：\n\n- 一行包含一个由五个列表组成的列表，每个测试一个，其中没有任何空格。例如，一个有效的输出格式看起来像 `\"[[],[2],[5],[2],[6]]\"`，其中每个内部列表包含递增的整数，空列表表示没有异常。\n\n不涉及物理单位或角度。所有索引都基于 $1$ 且必须是整数。\n\n您的最终交付成果必须是一个完整、可运行的程序，该程序为这些抽象测试定义构建具体的 PDB 格式行，应用检测算法，并以上述确切格式将汇总结果打印为单行。程序不得读取或写入任何文件，也不需要任何输入。", "solution": "所述问题是在计算生物信息学领域一个有效且定义明确的练习。它在科学上基于已建立的、严格的蛋白质数据库（PDB）文件格式规范，这是结构生物学中的一个客观标准。该问题是自包含的，提供了所有必要的定义和约束，最值得注意的是对异常 $\\text{TER}$ 记录的精确、形式化的定义。给定条件——即 PDB 格式的固定列宽特性、$\\text{ATOM}$、$\\text{HETATM}$ 和 $\\text{TER}$ 记录的功能，以及链标识符位于第 $22$ 列的位置——在事实上是正确的。任务是基于这些第一性原理实现一个验证算法，这是数据驱动的科学领域中的标准程序。问题表述清晰无歧义，没有科学或逻辑上的矛盾，适合于严谨的算法求解。\n\n目标是识别给定 PDB 格式文本中的异常 $\\text{TER}$ 记录。异常被明确定义为：一个 $\\text{TER}$ 记录是异常的，当且仅当其最近的前导 $\\text{ATOM}$ 或 $\\text{HETATM}$ 记录和最近的后继 $\\text{ATOM}$ 或 $\\text{HETATM}$ 记录都存在，并且共享相同的链标识符。令 $c_{\\text{prev}}$ 为最近的前导此类记录的链标识符，而 $c_{\\text{next}}$ 为最近的后继记录的链标识符。给定 $\\text{TER}$ 行存在异常的条件是 $c_{\\text{prev}}$ 和 $c_{\\text{next}}$ 都有定义且 $c_{\\text{prev}} = c_{\\text{next}}$。\n\n解决此问题的稳健算法设计为两个主要阶段，遵循关注点分离原则：数据整理后进行基于规则的验证。\n\n**第一阶段：数据整理和索引**\n\n初始步骤包括对输入文本进行单次遍历，以提取并索引所有与验证逻辑相关的记录。输入是一个行序列，我们逐一处理它们，同时记录基于 $1$ 的行索引。\n\n1.  编译一个列表来存储由 $\\text{ATOM}$ 和 $\\text{HETATM}$ 记录提供的上下文数据。对于遇到的每个此类记录，存储一个包含其基于 $1$ 的行索引和其链标识符（从第 $22$ 列提取）的元组。我们称之为 `atom_records` 列表。\n2.  编译第二个列表来存储所有 $\\text{TER}$ 记录的基于 $1$ 的行索引。这些是待验证的候选项。我们称之为 `ter_indices` 列表。\n\n这个预处理阶段有效地将原始文本转换为结构化数据，为下一阶段的逻辑分析做好准备。`atom_records` 列表将自然地按行索引排序，这一属性对高效搜索至关重要。\n\n**第二阶段：TER 记录的验证**\n\n利用第一阶段的结构化数据，每个 $\\text{TER}$ 记录都会根据已定义的异常条件进行验证。我们遍历 `ter_indices` 列表中的每个 `ter_index`。对于每个 `ter_index`，我们必须确定 $c_{\\text{prev}}$ 和 $c_{\\text{next}}$。\n\n1.  **查找 $c_{\\text{prev}}$**：我们在 `atom_records` 列表中搜索行索引严格小于当前 `ter_index` 的最大行索引的记录。如果不存在这样的记录（例如，如果 $\\text{TER}$ 记录是文件中的第一个记录，或者其前面只有其他 $\\text{TER}$ 记录），则 $c_{\\text{prev}}$ 被视为未定义。\n\n2.  **查找 $c_{\\text{next}}$**：我们在 `atom_records` 列表中搜索行索引严格大于当前 `ter_index` 的最小行索引的记录。如果不存在这样的记录（例如，$\\text{TER}$ 记录在文件末尾），则 $c_{\\text{next}}$ 被视为未定义。\n\n3.  **应用异常规则**：根据问题定义，当且仅当两次搜索都成功（即 $c_{\\text{prev}}$ 和 $c_{\\text{next}}$ 都有定义）且它们的链标识符相同时，才存在异常。如果满足此条件，则将 `ter_index` 记录为异常。\n\n对所有 `ter_indices` 重复此过程。对于给定的测试用例，最终输出是所有异常 `ter_index` 值的排序列表。\n\n为了高效实现对前导和后继记录的搜索，利用了 `atom_records` 列表的有序性。可以采用二分搜索算法，而不是对每个 $\\text{TER}$ 记录进行线性扫描。Python 库 `numpy`，特别是函数 `np.searchsorted`，提供了高度优化的二分搜索实现。给定一个 `ter_index`，`np.searchsorted` 可以在 $O(\\log N)$ 时间内，在 `atom_records` 行索引的排序数组中找到该索引的正确位置，其中 $N$ 是 $\\text{ATOM}$/$\\text{HETATM}$ 记录的数量。这使得可以立即识别前导和后继记录的索引，从而使整个算法非常高效。\n\n这整个两阶段过程被封装到一个函数中，该函数应用于五个指定的测试用例中的每一个。然后将结果汇总并格式化为所需的单行字符串输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation of PDB TER records for a suite of test cases.\n    It constructs the tests, processes each one, and prints the final aggregated result\n    in the specified compact format.\n    \"\"\"\n\n    def generate_pdb_line(rec_type, chain_id=' '):\n        \"\"\"\n        Generates a minimal, 22-character PDB-like line with the record type\n        and a chain identifier at column 22 (1-based index).\n\n        Args:\n            rec_type (str): The record type (e.g., 'ATOM', 'TER').\n            chain_id (str): The one-character chain identifier.\n\n        Returns:\n            str: A formatted PDB-like line.\n        \"\"\"\n        # The chain identifier is at column 22, which is index 21 (0-based).\n        # The format string ensures the record type is left-aligned in a 6-character field,\n        # followed by 15 spaces of padding, and then the chain ID.\n        return f\"{rec_type:6}{' ' * 15}{chain_id}\"\n\n    def find_anomalous_ters(abstract_records):\n        \"\"\"\n        Analyzes a sequence of abstract PDB records to find anomalous TER records.\n\n        An anomalous TER is one where the nearest preceding and succeeding ATOM/HETATM\n        records exist and have the same chain identifier.\n\n        Args:\n            abstract_records (list of tuple): A list where each tuple is (record_type, chain_id).\n\n        Returns:\n            list of int: A sorted list of 1-based line indices of anomalous TER records.\n        \"\"\"\n        \n        # Stage 1: Data Collation and Indexing\n        atom_hetatm_records = []\n        ter_indices = []\n        \n        for i, (rec_type, chain_id) in enumerate(abstract_records, 1):\n            if rec_type in ['ATOM', 'HETATM']:\n                # The problem statement states to use a space for chain ID if the line is too short.\n                # Here we ensure the chain_id from the test definition is handled.\n                current_chain = chain_id if chain_id is not None else ' '\n                atom_hetatm_records.append({'index': i, 'chain': current_chain})\n            elif rec_type == 'TER':\n                ter_indices.append(i)\n\n        if not atom_hetatm_records or not ter_indices:\n            return []\n\n        # Convert to NumPy arrays for efficient searching\n        atom_indices = np.array([rec['index'] for rec in atom_hetatm_records])\n        atom_chains = np.array([rec['chain'] for rec in atom_hetatm_records])\n        \n        anomalies = []\n        \n        # Stage 2: Validation of TER Records\n        for ter_index in ter_indices:\n            # Find the insertion point for ter_index in the sorted atom_indices array.\n            # 'left' side gives the index of the first element >= ter_index.\n            # The record before this point is the nearest preceding one.\n            preceding_pos = np.searchsorted(atom_indices, ter_index, side='left')\n            \n            # 'right' side gives the index of the first element > ter_index.\n            # This is the nearest succeeding record.\n            succeeding_pos = np.searchsorted(atom_indices, ter_index, side='right')\n            \n            # Check edge cases as per the problem definition: an anomaly requires\n            # BOTH preceding and succeeding records to exist.\n            if preceding_pos == 0:  # No preceding ATOM/HETATM found.\n                continue\n            if succeeding_pos == len(atom_indices):  # No succeeding ATOM/HETATM found.\n                continue\n\n            # Get the chain identifiers for the preceding and succeeding records.\n            # The index into atom_chains for the preceding record is preceding_pos - 1.\n            prev_chain = atom_chains[preceding_pos - 1]\n            # The index for the succeeding record is simply succeeding_pos.\n            next_chain = atom_chains[succeeding_pos]\n            \n            # Apply the anomaly rule.\n            if prev_chain == next_chain:\n                anomalies.append(ter_index)\n        \n        return sorted(anomalies)\n\n    # Define the abstract test suites from the problem description.\n    # A None for chain_id indicates a TER record where chain ID is not specified.\n    test_cases = [\n        # Test 1: ATOM(A), ATOM(A), TER, ATOM(B)\n        [('ATOM', 'A'), ('ATOM', 'A'), ('TER', None), ('ATOM', 'B')],\n        # Test 2: ATOM(A), TER, ATOM(A)\n        [('ATOM', 'A'), ('TER', None), ('ATOM', 'A')],\n        # Test 3: ATOM(A), ATOM(A), TER, HETATM(B), TER, ATOM(B), TER\n        [('ATOM', 'A'), ('ATOM', 'A'), ('TER', None), ('HETATM', 'B'), ('TER', None), ('ATOM', 'B'), ('TER', None)],\n        # Test 4: ATOM( ), TER, ATOM( )\n        [('ATOM', ' '), ('TER', None), ('ATOM', ' ')],\n        # Test 5: TER, ATOM(A), TER, TER, ATOM(B), TER, ATOM(B)\n        [('TER', None), ('ATOM', 'A'), ('TER', None), ('TER', None), ('ATOM', 'B'), ('TER', None), ('ATOM', 'B')]\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = find_anomalous_ters(case)\n        all_results.append(result)\n\n    # Format the final output string exactly as specified: a list of lists with no spaces.\n    # The default string representation of a list includes spaces, which must be removed.\n    output_str = f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2431238"}, {"introduction": "我们已经探讨了PDB文件的命名规范和结构完整性，但其真正的核心价值在于三维坐标数据。最后一个练习将带你进入结构生物学的空间维度，探索水分子在蛋白质结构中扮演的关键角色。你将学习如何识别那些作为“桥梁”连接不同蛋白质链的水分子，这是理解蛋白质复合物稳定性的一个重要方面。此任务要求你结合文件解析与几何计算，应用欧几里得距离公式 $d = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$，将静态的坐标数据转化为动态的生物学洞见。[@problem_id:2431199]", "problem": "您将获得符合蛋白质数据库 (PDB) 平面文件格式的文本片段，每个片段由以“ATOM”或“HETATM”开头的行组成。每一行编码一个原子。请按以下顺序解析每个原子行的字段（按空格分割）：记录名称、原子序列号、原子名称、残基名称、链标识符、残基序列号、以埃（Angstrom）为单位的笛卡尔坐标 $x$、$y$、$z$、占有率、温度因子和元素符号。仅将记录名称等于字符串字面量“ATOM”的行视作蛋白质原子。将记录名称等于字符串字面量“HETATM”且残基名称等于字符串字面量“HOH”的残基视作水分子。对于每个水残基，仅将原子名称等于字符串字面量“O”的原子视为该水的位置。\n\n定义两个坐标分别为 $(x_1,y_1,z_1)$ 和 $(x_2,y_2,z_2)$ （单位为埃）的原子之间的欧几里德距离为\n$$\nd\\big((x_1,y_1,z_1),(x_2,y_2,z_2)\\big)=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}.\n$$\n令非负实数 $r$（单位为埃）表示一个距离截断值。一个水残基在两条不同的蛋白质链之间充当桥梁，当且仅当存在两个不同的蛋白质链标识符 $c_1$ 和 $c_2$（$c_1\\neq c_2$），并且在链 $c_1$ 中至少存在一个蛋白质原子与该水氧原子的距离 $\\leq r$，同时在链 $c_2$ 中也至少存在一个蛋白质原子与该水氧原子的距离 $\\leq r$。对于下方的每个测试用例，您必须识别所有此类桥接水残基，并报告它们的残基序列号（作为整数），按升序排序。距离必须以埃为单位进行计算，并且截断值 $r$ 必须以包含等于的条件 $\\leq r$ 来应用。\n\n您的程序必须处理以下测试套件，其中每个测试用例是由一个 PDB 文本块和一个以埃为单位的截断值 $r$ 组成的对：\n\n- 测试用例 1:\n  - PDB:\n    ATOM      1  CA  ALA A   1       0.000   0.000   0.000  1.00 20.00           C\n    ATOM      2  CA  ALA B   1       6.000   0.000   0.000  1.00 20.00           C\n    HETATM  101  O   HOH W 101       3.000   0.000   0.000  1.00 10.00           O\n    HETATM  102  O   HOH W 102       0.000   3.100   0.000  1.00 10.00           O\n    HETATM  103  O   HOH W 103      20.000  20.000  20.000  1.00 10.00           O\n  - $r = 3.2$\n- 测试用例 2:\n  - PDB:\n    ATOM      1  CA  GLY A   1       0.000   0.000   0.000  1.00 20.00           C\n    ATOM      2  CA  GLY B   1       7.000   0.000   0.000  1.00 20.00           C\n    HETATM  201  O   HOH W 201       3.500   0.000   0.000  1.00 10.00           O\n    HETATM  202  O   HOH W 202       3.500   3.500   0.000  1.00 10.00           O\n  - $r = 3.5$\n- 测试用例 3:\n  - PDB:\n    ATOM      1  CA  LYS A   1       0.000   0.000   0.000  1.00 20.00           C\n    ATOM      2  CA  LYS B   1       0.000   6.000   0.000  1.00 20.00           C\n    ATOM      3  CA  LYS C   1      10.000   0.000   0.000  1.00 20.00           C\n    HETATM  301  O   HOH W 301       0.000   3.000   0.000  1.00 10.00           O\n    HETATM  302  O   HOH W 302       5.000   0.000   0.000  1.00 10.00           O\n    HETATM  303  O   HOH W 303      12.500   0.000   0.000  1.00 10.00           O\n  - $r = 5.0$\n- 测试用例 4:\n  - PDB:\n    ATOM      1  CA  SER A   1       0.000   0.000   0.000  1.00 20.00           C\n    ATOM      2  CA  SER B   1       8.000   0.000   0.000  1.00 20.00           C\n    HETATM  401  O   HOH W 401       2.500   0.000   0.000  1.00 10.00           O\n    HETATM  402  O   HOH W 402       4.000   0.000   0.000  1.00 10.00           O\n    HETATM  900  FE  HEM L   1       2.500   0.000   0.000  1.00 15.00           FE\n  - $r = 4.0$\n\n对于每个测试用例，要求的输出是一个整数列表，表示根据上述定义充当桥梁的所有水残基的残基序列号，按升序排序。您的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为这些列表的逗号分隔列表，用方括号括起来，不含空格。例如，一个有效的输出格式是 \"[[a,b],[c],[d,e,f],[]]\"，其中 $a$、$b$、$c$、$d$、$e$ 和 $f$ 均为整数。", "solution": "该问题将首先经过严格的验证过程。\n\n步骤1：提取已知信息\n\n- **输入数据**：一组符合蛋白质数据库（PDB）平面文件格式的文本片段。\n- **行类型**：每行以“ATOM”或“HETATM”开头。\n- **PDB行字段（以空格分隔）**：\n    1. 记录名称\n    2. 原子序列号\n    3. 原子名称\n    4. 残基名称\n    5. 链标识符\n    6. 残基序列号\n    7. 笛卡尔坐标 $x$ （单位：埃）\n    8. 笛卡尔坐标 $y$ （单位：埃）\n    9. 笛卡尔坐标 $z$ （单位：埃）\n    10. 占有率\n    11. 温度因子\n    12. 元素符号\n- **蛋白质原子定义**：记录名称为字符串字面量“ATOM”的行。\n- **水分子定义**：记录名称为“HETATM”且残基名称为“HOH”的残基。\n- **水位置定义**：对于一个水残基，其位置由原子名称为“O”的原子的坐标定义。\n- **距离度量**：两个原子（位于 $(x_1, y_1, z_1)$ 和 $(x_2, y_2, z_2)$）之间的欧几里德距离为 $d = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2 + (z_1-z_2)^2}$。\n- **距离截断值**：一个以埃为单位的非负实数 $r$。\n- **桥接水定义**：一个水残基充当桥梁，如果其氧原子与链 $c_1$ 中的至少一个蛋白质原子的距离小于或等于 $r$（$\\leq r$），并且也与另一条不同链 $c_2$（$c_1 \\neq c_2$）中的至少一个蛋白质原子的距离小于或等于 $r$。\n- **要求输出**：对于每个测试用例，输出一个由所有桥接水残基的残基序列号组成的整数列表，按升序排序。所有测试用例的最终输出是一个由这些列表组成的逗号分隔列表，包含在一对方括号内。\n- **测试套件**：提供了四个特定的测试用例，每个用例都包含一个 PDB 文本块和相应的截断值 $r$。\n\n步骤2：使用提取的已知信息进行验证\n\n- **科学依据**：该问题基于结构生物学和生物信息学的基本概念。PDB 格式是表示生物大分子三维结构的标准。水介导的蛋白质链间桥梁是蛋白质-蛋白质相互作用和蛋白质稳定性分析中的一个公认原则。欧几里德距离是在此背景下进行空间计算的标准度量。该问题在科学上是有效且现实的。\n- **良构的**：问题定义清晰。所有术语如“蛋白质原子”、“水分子”、“桥接水”和“距离”都有精确、无歧义的定义。输入数据已提供，预期的输出格式也已指定。对于任何给定的输入，这套规则都会导向一个单一的、确定性的结果。存在唯一解且可以计算得出。\n- **客观性**：问题陈述不含主观性语言、观点或推测。所有标准都基于客观、可量化的度量（记录名称、距离、计数）。\n- **完整性与一致性**：问题是自包含的。解决问题所需的所有信息都在陈述中提供，包括所有测试用例的数据和要使用的确切定义。所提供的规则中没有矛盾。例如，就划分为蛋白质与水而言，“ATOM”和“HETATM”记录的标准是互斥的。\n- **可行性与现实性**：坐标值和距离对于原子结构而言在物理上是合理的。计算任务直接明了，不需要不切实际的资源。\n- **结构性**：问题结构良好，不包含循环推理或同义反复。\n\n步骤3：结论与行动\n\n该问题是**有效的**。它具有科学依据，是良构的、客观的和自包含的。因此，将开发一个解决方案。\n\n该解决方案需要实现一个算法，根据给定规则处理每个测试用例。该算法可以按如下方式构建：\n\n1.  **数据解析与分离**：对每个测试用例，解析提供的多行 PDB 字符串。遍历每一行，通过空格分割以提取相关字段。根据记录名称和残基名称，对每个相关原子进行分类。\n    -   如果记录名称是“ATOM”，则将其链标识符（字段5）和坐标（字段7-9）存储为蛋白质原子。\n    -   如果记录名称是“HETATM”，残基名称是“HOH”，且原子名称是“O”，则将其残基序列号（字段6）和坐标（字段7-9）存储为水分子。\n    -   所有其他行（例如，`HEM`基团中的`FE`等其他`HETATM`类型）根据问题定义将被忽略。\n\n2.  **桥接逻辑**：对于每个识别出的水分子，判断其是否起到桥梁作用。\n    -   初始化一个空集合 `contacted_chains`，用于存储与当前水分子有紧密接触的蛋白质链的唯一标识符。\n    -   遍历所有前述的蛋白质原子。\n    -   对于每个蛋白质原子，计算其到当前水分子氧原子的欧几里德距离的平方。距离平方由 $d^2 = (x_w - x_p)^2 + (y_w - y_p)^2 + (z_w - z_p)^2$ 给出，其中 $(x_w, y_w, z_w)$是水的坐标，$(x_p, y_p, z_p)$ 是蛋白质原子的坐标。\n    -   比较 $d^2$ 与 $r^2$ 比计算平方根在计算上更高效。如果 $d^2 \\leq r^2$，则该蛋白质原子在距离截断值之内。\n    -   如果一个蛋白质原子在截断值之内，则将其链标识符添加到 `contacted_chains` 集合。使用集合可以自动处理唯一性。\n    -   在检查完所有蛋白质原子与当前水分子的关系后，检查 `contacted_chains` 集合的大小。\n    -   如果 `contacted_chains` 中的元素数量大于或等于 2，则该水分子桥接了至少两个不同的链，因此是一个“桥接水”。将其残基序列号添加到当前测试用例的结果列表中。\n\n3.  **最终处理**：遍历完一个测试用例中的所有水分子后，将收集到的桥接水残基序列号列表按升序排序。对套件中的所有测试用例重复此完整过程。\n\n4.  **输出格式化**：将所有测试用例的已排序残基号列表聚合成指定的最终结构：一个表示列表的列表的单一字符串。\n\n强烈建议使用 `numpy` 数组来存储坐标，因为它支持矢量化和高效的距离计算，这优于在简单的 Python 循环中执行计算，尤其对于较大数据集。对于一个给定的坐标向量为 $\\vec{v}_w$ 的水分子，以及一个包含 $N$ 个蛋白质原子的坐标矩阵 $\\mathbf{P}$（形状为 $N \\times 3$），可以通过将 $\\vec{v}_w$ 广播到 $\\mathbf{P}$ 的所有行并对坐标轴上的差值平方求和，在单次操作中计算出距离的平方。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bridging water identification problem for a suite of test cases.\n    \"\"\"\n    test_suite = [\n        {\n            \"pdb_text\": \"\"\"\nATOM      1  CA  ALA A   1       0.000   0.000   0.000  1.00 20.00           C\nATOM      2  CA  ALA B   1       6.000   0.000   0.000  1.00 20.00           C\nHETATM  101  O   HOH W 101       3.000   0.000   0.000  1.00 10.00           O\nHETATM  102  O   HOH W 102       0.000   3.100   0.000  1.00 10.00           O\nHETATM  103  O   HOH W 103      20.000  20.000  20.000  1.00 10.00           O\n\"\"\",\n            \"r\": 3.2\n        },\n        {\n            \"pdb_text\": \"\"\"\nATOM      1  CA  GLY A   1       0.000   0.000   0.000  1.00 20.00           C\nATOM      2  CA  GLY B   1       7.000   0.000   0.000  1.00 20.00           C\nHETATM  201  O   HOH W 201       3.500   0.000   0.000  1.00 10.00           O\nHETATM  202  O   HOH W 202       3.500   3.500   0.000  1.00 10.00           O\n\"\"\",\n            \"r\": 3.5\n        },\n        {\n            \"pdb_text\": \"\"\"\nATOM      1  CA  LYS A   1       0.000   0.000   0.000  1.00 20.00           C\nATOM      2  CA  LYS B   1       0.000   6.000   0.000  1.00 20.00           C\nATOM      3  CA  LYS C   1      10.000   0.000   0.000  1.00 20.00           C\nHETATM  301  O   HOH W 301       0.000   3.000   0.000  1.00 10.00           O\nHETATM  302  O   HOH W 302       5.000   0.000   0.000  1.00 10.00           O\nHETATM  303  O   HOH W 303      12.500   0.000   0.000  1.00 10.00           O\n\"\"\",\n            \"r\": 5.0\n        },\n        {\n            \"pdb_text\": \"\"\"\nATOM      1  CA  SER A   1       0.000   0.000   0.000  1.00 20.00           C\nATOM      2  CA  SER B   1       8.000   0.000   0.000  1.00 20.00           C\nHETATM  401  O   HOH W 401       2.500   0.000   0.000  1.00 10.00           O\nHETATM  402  O   HOH W 402       4.000   0.000   0.000  1.00 10.00           O\nHETATM  900  FE  HEM L   1       2.500   0.000   0.000  1.00 15.00           FE\n\"\"\",\n            \"r\": 4.0\n        }\n    ]\n\n    all_results = []\n\n    for case in test_suite:\n        pdb_text = case[\"pdb_text\"]\n        r = case[\"r\"]\n        r_squared = r**2\n\n        protein_atoms = [] # List of tuples: (chain_id, np.array([x, y, z]))\n        water_molecules = [] # List of tuples: (res_seq_num, np.array([x, y, z]))\n\n        lines = pdb_text.strip().split('\\n')\n        for line in lines:\n            fields = line.split()\n            record_name = fields[0]\n            \n            if record_name == \"ATOM\":\n                chain_id = fields[4]\n                coords = np.array([float(fields[6]), float(fields[7]), float(fields[8])])\n                protein_atoms.append((chain_id, coords))\n            elif record_name == \"HETATM\":\n                atom_name = fields[2]\n                res_name = fields[3]\n                if res_name == \"HOH\" and atom_name == \"O\":\n                    res_seq_num = int(fields[5])\n                    coords = np.array([float(fields[6]), float(fields[7]), float(fields[8])])\n                    water_molecules.append((res_seq_num, coords))\n\n        if not protein_atoms:\n            all_results.append([])\n            continue\n\n        protein_chain_ids = np.array([p[0] for p in protein_atoms])\n        protein_coords = np.array([p[1] for p in protein_atoms])\n\n        bridging_waters = []\n        for water_res_seq, water_coord in water_molecules:\n            # Calculate squared Euclidean distances from this water to all protein atoms\n            squared_distances = np.sum((protein_coords - water_coord)**2, axis=1)\n            \n            # Find which protein atoms are within the cutoff\n            contact_mask = squared_distances = r_squared\n            \n            # Get the unique chain IDs of the contacted protein atoms\n            contacted_chains = set(protein_chain_ids[contact_mask])\n            \n            # A water is a bridge if it contacts 2 or more distinct chains\n            if len(contacted_chains) >= 2:\n                bridging_waters.append(water_res_seq)\n        \n        bridging_waters.sort()\n        all_results.append(bridging_waters)\n\n    # Format the final output string\n    result_str = \",\".join([str(res).replace(\" \", \"\") for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2431199"}]}