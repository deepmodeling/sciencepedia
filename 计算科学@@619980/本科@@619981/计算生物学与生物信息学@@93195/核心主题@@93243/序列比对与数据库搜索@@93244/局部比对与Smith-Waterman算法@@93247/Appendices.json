{"hands_on_practices": [{"introduction": "虽然线性罚分模型是理解序列比对的一个很好的起点，但生物序列中的插入和缺失事件往往更适合用仿射空位罚分模型来描述，该模型对开启一个新空位的罚分高于延伸一个现有空位。这个练习将指导你实现一个更真实、更强大的Smith-Waterman算法版本，它使用三个动态规划矩阵来精确地对匹配、插入和删除事件进行建模。通过完成这个练习，你将把理论知识转化为一项核心的生物信息学编程技能 [@problem_id:2401701]。", "problem": "您需要实现一个局部序列比对算法，该算法遵循 Smith–Waterman 动态规划范式，并采用通过三个动态规划状态矩阵实现的仿射空位罚分模型。对于两个有限字母表上的输入字符串，状态定义如下：$M_{i,j}$ 表示在第一个字符串的位置 $i$ 和第二个字符串的位置 $j$ 结束，且字符 $x_i$ 和 $y_j$ 相互对齐（匹配或错配）的最优局部比对得分；$I_{x,i,j}$ 表示在位置 $i$ 和 $j$ 结束，且字符 $x_i$ 与空位对齐（即在序列 $y$ 中引入空位）的最优局部比对得分；$I_{y,i,j}$ 表示在位置 $i$ 和 $j$ 结束，且字符 $y_j$ 与空位对齐（即在序列 $x$ 中引入空位）的最优局部比对得分。\n\n该算法必须基于以下基本原理进行设计：\n- 动态规划（DP）的最优性原理：当一个问题表现出最优子结构时，该问题实例的最优解可以由其子问题的最优解构成。\n- 局部比对的定义：得分最高的一对子串的比对得分，其中比对计分在任何位置都不能低于 $0$，从而允许比对在局部重新开始。\n- 仿射空位模型：长度为 $L$ 的连续空位的罚分是 $g_o + L \\cdot g_e$，其中 $g_o$ 是空位开放罚分，$g_e$ 是每个符号的空位延伸罚分。当打开或延伸一个空位时，$g_o$ 和 $g_e$ 都为非负数，并从比对得分中减去。\n\n请实现一个程序，在给定成对的序列和标量计分参数的情况下，使用上述三状态仿射空位模型计算最优的 Smith–Waterman 局部比对得分。您的实现必须显式地维护三个状态矩阵 $M$、$I_x$ 和 $I_y$，并且必须通过允许任何状态在所有传入转移值为非正数时重置为 $0$ 来强制执行局部比对属性。假设使用一个简单的字符替换计分函数 $s(a,b)$，定义为：如果 $a=b$，则 $s(a,b) = s_{\\text{match}}$；如果 $a \\neq b$，则 $s(a,b) = s_{\\text{mismatch}}$。\n\n您的程序应处理以下五个案例的测试套件。每个案例由一对字符串以及参数 $s_{\\text{match}}$、$s_{\\text{mismatch}}$、$g_o$ 和 $g_e$ 指定：\n- 案例 1：$x = \\text{\"GATTACA\"}$, $y = \\text{\"GCATGCU\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$。\n- 案例 2：$x = \\text{\"\"}$, $y = \\text{\"\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$。\n- 案例 3：$x = \\text{\"\"}$, $y = \\text{\"ACGT\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$。\n- 案例 4：$x = \\text{\"AAAA\"}$, $y = \\text{\"TTTT\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$。\n- 案例 5：$x = \\text{\"AAAACCCCGGGG\"}$, $y = \\text{\"AAAAGGGG\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$。\n\n对于每个案例，要求的输出是在指定模型和参数下的单个最优局部比对得分（一个整数）。您的程序应生成单行输出，其中包含五个案例的结果，形式为用方括号括起来的逗号分隔列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。此问题不涉及物理单位。\n\n约束与说明：\n- 设字符串的长度分别为 $n$ 和 $m$，其中 $n \\ge 0$ 且 $m \\ge 0$。\n- 您的动态规划算法必须在 $\\mathcal{O}(n \\cdot m)$ 时间和 $\\mathcal{O}(n \\cdot m)$ 空间内运行。\n- 所有矩阵索引和中间值均为整数；返回所有位置和三种状态下的最大值。\n- 确保仿射空位罚分以 $g_o + L \\cdot g_e$ 的形式累积，用于长度为 $L$ 的空位，这与您推导的状态转移语义一致。", "solution": "该问题要求使用仿射空位罚分模型实现 Smith-Waterman 局部序列比对算法。该问题在科学上是合理的、定义明确的，并且基于计算生物学的基本原理。我将首先根据所述原理推导必要的动态规划递推关系。\n\n设两个序列为长度为 $n$ 的 $x = x_1x_2...x_n$ 和长度为 $m$ 的 $y = y_1y_2...y_m$。计分参数为 $s_{\\text{match}}$（字符匹配）、$s_{\\text{mismatch}}$（错配）、$g_o$（空位开放）和 $g_e$（空位延伸）。长度为 $L$ 的空位的罚分为 $g_o + L \\cdot g_e$。请注意，罚分是从得分中减去的。\n\n该算法的核心在于最优性原理。结束于位置 $i$ 和 $j$ 的比对的最优得分是根据较小子问题的最优得分计算的。仿射空位模型需要在动态规划网格的每个位置 $(i,j)$ 设置三个状态，对应于比对结束的三种可能方式：\n\n1.  $M_{i,j}$：以 $x_i$ 与 $y_j$ 对齐结束的最佳局部比对得分。\n2.  $I_{x,i,j}$：以 $x_i$ 与一个空位字符（'-'）对齐结束的最佳局部比对得分。\n3.  $I_{y,i,j}$：以一个空位字符（'-'）与 $y_j$ 对齐结束的最佳局部比对得分。\n\n比对的局部性是 Smith-Waterman 算法的一个关键特征，通过允许在任何位置开始新的比对来强制执行。这是通过确保动态规划矩阵中的得分永远不会低于 $0$ 来实现的。如果延伸到给定单元格的所有可能方式都导致非正得分，则该单元格的得分被设置为 $0$，标志着一个新的潜在局部比对的开始。\n\n我们将为每个状态构建一个 $(n+1) \\times (m+1)$ 的矩阵。索引 $i$ 的范围是从 $0$ 到 $n$，$j$ 的范围是从 $0$ 到 $m$。\n\n**初始化**\n对于局部比对，任何比对都可以在任何地方开始。因此，动态规划矩阵被初始化为开始新比对不产生任何成本。这对应于将所有三个矩阵的第一行和第一列都设置为 $0$。\n$$ M_{i,0} = I_{x,i,0} = I_{y,i,0} = 0 \\quad \\text{for } i \\in [0, n] $$\n$$ M_{0,j} = I_{x,0,j} = I_{y,0,j} = 0 \\quad \\text{for } j \\in [0, m] $$\n\n**递推关系**\n对于从 $1$ 到 $n$ 的 $i$ 和从 $1$ 到 $m$ 的 $j$，矩阵单元格按以下方式填充。设 $s(x_i, y_j)$ 为替换得分，若 $x_i = y_j$ 则为 $s_{\\text{match}}$，否则为 $s_{\\text{mismatch}}$。\n\n1.  **状态 $M_{i,j}$（匹配/错配状态）：**\n    以 $x_i$ 匹配 $y_j$ 结束的比对必须跟随一个在 $(i-1, j-1)$ 结束的比对。前一个状态可能是匹配/错配（$M_{i-1,j-1}$）、$y$ 中的空位（$I_{x,i-1,j-1}$）或 $x$ 中的空位（$I_{y,i-1,j-1}$）。我们取这些可能性的最大值，加上替换得分 $s(x_i, y_j)$，并应用局部比对条件。\n    $$ M_{i,j} = \\max\\left(0, \\ s(x_i, y_j) + \\max\\left(M_{i-1,j-1}, I_{x,i-1,j-1}, I_{y,i-1,j-1}\\right)\\right) $$\n\n2.  **状态 $I_{x,i,j}$（$y$ 中的空位 / $x$ 中的插入）：**\n    以 $x_i$ 对一个空位结束的比对必须延伸一个在 $(i-1, j)$ 结束的前一个比对。这可以通过两种方式发生：\n    a) 打开一个新空位：到 $(i-1, j)$ 为止的比对以匹配/错配结束（$M_{i-1,j}$）。打开一个长度为 $1$ 的空位的罚分是 $g_o + 1 \\cdot g_e$。\n    b) 延伸一个现有空位：到 $(i-1, j)$ 为止的比对已经以 $x_{i-1}$ 对一个空位结束（$I_{x,i-1,j}$）。延伸空位的罚分是 $g_e$。\n    递推关系结合了这些可能性，同样带有局部比对的重置为零条件。\n    $$ I_{x,i,j} = \\max\\left(0, \\max\\left(M_{i-1,j} - (g_o + g_e), \\ I_{x,i-1,j} - g_e\\right)\\right) $$\n\n3.  **状态 $I_{y,i,j}$（$x$ 中的空位 / $y$ 中的插入）：**\n    对称地，以 $y_j$ 对一个空位结束的比对必须延伸一个在 $(i, j-1)$ 结束的前一个比对。\n    a) 打开一个新空位：从状态 $M_{i,j-1}$ 开始，罚分为 $g_o + g_e$。\n    b) 延伸一个现有空位：从状态 $I_{y,i,j-1}$ 开始，罚分为 $g_e$。\n    递推关系是：\n    $$ I_{y,i,j} = \\max\\left(0, \\max\\left(M_{i,j-1} - (g_o + g_e), \\ I_{y,i,j-1} - g_e\\right)\\right) $$\n\n**最终得分**\n最优局部比对的得分是在所有位置 $(i,j)$ 的三个矩阵中找到的最大值。\n$$ \\text{Score} = \\max_{0 \\le i \\le n, \\ 0 \\le j \\le m} \\{M_{i,j}, I_{x,i,j}, I_{y,i,j}\\} $$\n\n此过程需要 $\\mathcal{O}(n \\cdot m)$ 时间，因为它需要填充三个大小为 $(n+1) \\times (m+1)$ 的矩阵，并且每个单元格的计算是常数时间操作。存储三个矩阵的空间复杂度也是 $\\mathcal{O}(n \\cdot m)$。接下来的实现将遵循此形式化推导。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    This program computes the optimal local alignment score for pairs of sequences\n    using the Smith-Waterman algorithm with an affine gap penalty.\n    \"\"\"\n\n    def smith_waterman_affine(x: str, y: str, s_match: int, s_mismatch: int, g_o: int, g_e: int) - int:\n        \"\"\"\n        Computes the Smith-Waterman local alignment score with an affine gap penalty.\n\n        Args:\n            x (str): The first sequence.\n            y (str): The second sequence.\n            s_match (int): The score for a character match.\n            s_mismatch (int): The score for a character mismatch (a penalty, so usually negative).\n            g_o (int): The gap opening penalty (non-negative).\n            g_e (int): The gap extension penalty (non-negative).\n\n        Returns:\n            int: The optimal local alignment score.\n        \"\"\"\n        n = len(x)\n        m = len(y)\n\n        # The three dynamic programming matrices for the states\n        # M: score ending in a match/mismatch\n        # Ix: score ending in a gap in y (insertion relative to x)\n        # Iy: score ending in a gap in x (insertion relative to y)\n        m_matrix = np.zeros((n + 1, m + 1), dtype=int)\n        ix_matrix = np.zeros((n + 1, m + 1), dtype=int)\n        iy_matrix = np.zeros((n + 1, m + 1), dtype=int)\n\n        max_score = 0\n        \n        # Penalty for opening a gap, combining g_o and the first g_e\n        gap_open_penalty = g_o + g_e\n        gap_extend_penalty = g_e\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                # Calculate substitution score for x[i-1] and y[j-1]\n                sub_score = s_match if x[i-1] == y[j-1] else s_mismatch\n\n                # Recurrence for M_i,j\n                prev_score_m = max(m_matrix[i-1, j-1], ix_matrix[i-1, j-1], iy_matrix[i-1, j-1])\n                m_matrix[i, j] = max(0, prev_score_m + sub_score)\n\n                # Recurrence for Ix_i,j (gap in y)\n                score_open_x = m_matrix[i-1, j] - gap_open_penalty\n                score_extend_x = ix_matrix[i-1, j] - gap_extend_penalty\n                ix_matrix[i, j] = max(0, score_open_x, score_extend_x)\n\n                # Recurrence for Iy_i,j (gap in x)\n                score_open_y = m_matrix[i, j-1] - gap_open_penalty\n                score_extend_y = iy_matrix[i, j-1] - gap_extend_penalty\n                iy_matrix[i, j] = max(0, score_open_y, score_extend_y)\n\n                # The optimal local score is the maximum found anywhere in the matrices\n                current_max = max(m_matrix[i, j], ix_matrix[i, j], iy_matrix[i, j])\n                if current_max  max_score:\n                    max_score = current_max\n        \n        return max_score\n\n    test_cases = [\n        # Case 1\n        {\"x\": \"GATTACA\", \"y\": \"GCATGCU\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 2\n        {\"x\": \"\", \"y\": \"\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 3\n        {\"x\": \"\", \"y\": \"ACGT\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 4\n        {\"x\": \"AAAA\", \"y\": \"TTTT\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 5\n        {\"x\": \"AAAACCCCGGGG\", \"y\": \"AAAAGGGG\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        score = smith_waterman_affine(\n            case[\"x\"],\n            case[\"y\"],\n            case[\"s_match\"],\n            case[\"s_mismatch\"],\n            case[\"g_o\"],\n            case[\"g_e\"]\n        )\n        results.append(score)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2401701"}, {"introduction": "许多重要的生物分子，如质粒和线粒体DNA，都具有环状拓扑结构。为线性序列设计的标准比对算法可能会错过跨越传统“末端”的关键比对区域。这个练习 [@problem_id:2401715] 挑战你跳出常规思维，将已知的Smith-Waterman算法应用于这种新颖的环状结构。你将学习如何通过一个巧妙的策略——将环状比对问题分解为一系列线性比对问题——来确保找到全局最优解。", "problem": "您的任务是设计并实现一个程序，用于计算可能存在于环状拓扑结构上的核苷酸序列的局部比对得分。设计必须严格从局部比对作为子串比对之优化的核心定义以及动态规划 (DP) 原则出发。目标是为每个提供的测试用例，在一个具有正匹配分、负错配分和负空位分（线性空位罚分）的计分系统下，计算出最大局部比对得分。您的程序必须将标准的局部比对公式推广到环状序列，其方法是在不损失最优性的前提下，将环状拓扑逻辑上归约为有限个线性情况的集合。\n\n使用的基本原理：\n- 两条序列的局部比对定义为，在所有连续子串对及其所有比对中，各位置得分之和的最大值，其中匹配得分，错配和空位罚分。\n- DP 原则指出，当一个问题表现出最优子结构和重叠子问题时，该问题的最优解可以由其子问题的最优解构建而成。\n\n要求与精确解释：\n- 对于一条线性序列，两条序列之间的局部比对得分，是在两条给定序列的任意连续子串对的所有比对中取得的最大值，其得分计算为各位置贡献之和：一个匹配贡献 $s_{\\text{match}}$，一个错配贡献 $s_{\\text{mismatch}}$，每个空位（插入或删除）贡献 $s_{\\text{gap}}$。局部比对得分永远不为负；如果所有比对都会产生负分，则正确得分为 $0$。\n- 对于一条环状序列，该序列的所有旋转都代表同一个分子。旋转定义为将前缀移至末尾，并保持顺序。任何跨越环状边界的局部比对都可以表示为序列适当旋转后的局部比对，而无需跨越任何末端。因此，要评估环状局部比对得分，只需考虑每个声明为环状的序列的所有旋转，并取所有此类旋转对的最大局部比对得分即可。\n- 计分使用线性空位罚分：每个空位对得分的贡献恰好为 $s_{\\text{gap}}$，与其长度无关。匹配和错配分别贡献 $s_{\\text{match}}$ 和 $s_{\\text{mismatch}}$。\n- 您只需为每个测试用例计算最优局部比对得分（一个整数）。无需回溯或比对字符串。\n\n测试套件：\n为以下各种情况计算最大局部比对得分。在每个元组中，字段为（序列 $1$，序列 $2$，is\\_circular\\_1，is\\_circular\\_2，$s_{\\text{match}}$，$s_{\\text{mismatch}}$，$s_{\\text{gap}}$）。布尔标志指示序列是应被视为环状（True）还是线性（False）。所有得分均为整数。\n\n- 情况 A: (\"ATGCAT\", \"CATATG\", True, False, $2$, $-1$, $-2$)。\n- 情况 B: (\"GATTACA\", \"TTACAGA\", True, True, $2$, $-1$, $-2$)。\n- 情况 C: (\"AAAA\", \"TTTT\", True, False, $2$, $-1$, $-2$)。\n- 情况 D: (\"ACGT\", \"AGT\", True, False, $3$, $-2$, $-2$)。\n- 情况 E: (\"AAAA\", \"AAAA\", True, True, $2$, $-1$, $-3$)。\n- 情况 F: (\"GCGT\", \"GCT\", False, False, $2$, $-1$, $-2$)。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述情况相同。例如，一个有效的输出行格式为“[rA,rB,rC,rD,rE,rF]”，其中每个 $r\\_$ 是一个整数得分。\n\n科学真实性与推导约束：\n- 从局部比对作为子串比对之优化的定义和 DP 原则出发。不要假设任何针对环状序列的特殊公式；相反，应证明为何旋转枚举能够覆盖环状拓扑的所有必要情况。\n- 确保所有计算均为整数值。不涉及物理单位。", "solution": "该问题要求计算两条核苷酸序列之间的最大局部比对得分，这些序列可能是线性的或环状的。这是一个优化问题，可以利用动态规划原理严格求解。解决方案分两个阶段制定：首先是针对线性序列的公式，即著名的 Smith-Waterman 算法；其次是将此公式逻辑上扩展到环状序列。\n\n两条序列 $S_1$ 和 $S_2$ 的局部比对定义为，对它们任意一对子串进行比对所能产生的最高可能得分。设 $S_1$ 的长度为 $m$，$S_2$ 的长度为 $n$。局部比对是子串 $S_1[i..j]$ 和 $S_2[k..l]$ 之间的比对，其中 $1 \\le i \\le j \\le m$ 且 $1 \\le k \\le l \\le n$。总的局部比对得分是在所有可能的子串选择中找到的最大得分。\n\n该问题具有最优子结构和重叠子问题，因此适合使用动态规划解法。我们定义一个矩阵 $H$，其中条目 $H(i, j)$ 表示结束于序列 $S_1$ 位置 $i$ 和序列 $S_2$ 位置 $j$ 的比对的最高得分。对于 $i  0$ 和 $j  0$， $H(i, j)$ 的递推关系考虑了将现有比对扩展以包含 $S_1[i]$ 和 $S_2[j]$ 的三种可能性：\n$1$. 将 $S_1[i]$ 与 $S_2[j]$ 对齐。得分为结束于 $H(i-1, j-1)$ 的最优比对得分加上新字符对的得分 $s(S_1[i], S_2[j])$。此项由 $H(i-1, j-1) + s(S_1[i], S_2[j])$ 给出，其中如果字符 $a$ 和 $b$ 相同，则 $s(a, b)$ 为 $s_{\\text{match}}$，否则为 $s_{\\text{mismatch}}$。\n$2$. 将 $S_1[i]$ 与一个空位对齐。得分为结束于 $H(i-1, j)$ 的最优比对得分加上空位罚分 $s_{\\text{gap}}$。此项为 $H(i-1, j) + s_{\\text{gap}}$。\n$3$. 将 $S_2[j]$ 与一个空位对齐。得分为结束于 $H(i, j-1)$ 的最优比对得分加上空位罚分 $s_{\\text{gap}}$。此项为 $H(i, j-1) + s_{\\text{gap}}$。\n\n局部比对的一个关键特征是比对可以从任何位置开始。这是通过允许在从某一点开始的所有比对扩展都导致负分时将得分重置为零来实现的。这种“重新开始”的可能性通过取上述三种情况与零的最大值来整合。\n因此，Smith-Waterman 算法的完整递推关系为：\n$$\nH(i, j) = \\max\n\\begin{cases}\n0 \\\\\nH(i-1, j-1) + s(S_1[i], S_2[j]) \\\\\nH(i-1, j) + s_{\\text{gap}} \\\\\nH(i, j-1) + s_{\\text{gap}}\n\\end{cases}\n$$\n动态规划矩阵的基础条件是，对于所有 $i \\in [0, m]$，$H(i, 0) = 0$；对于所有 $j \\in [0, n]$，$H(0, j) = 0$。这些条件反映了与空字符串的比对得分为零。\n\n线性序列 $S_1$ 和 $S_2$ 的最终局部比对得分不是在固定位置找到的，而是整个矩阵 $H$ 中的最大值：\n$$\n\\text{Score}(S_1, S_2) = \\max_{0 \\le i \\le m, 0 \\le j \\le n} H(i, j)\n$$\n\n对环状序列的扩展基于所提供的指令：“任何跨越环状边界的局部比对都可以表示为序列适当旋转后的局部比对，而无需跨越任何末端。”这一断言是根本正确的。局部比对涉及寻找最优子串。对于环状序列，一个“子串”可以环绕其线性字符串表示的常规定义末端。对于任何这样的“环绕”子串，都存在原始环状序列的一个旋转，在该旋转中，此子串表现为一个标准的、连续的、线性的片段。例如，在序列 $S = \\text{\"ABCDE\"}$ 中，环绕子串 `DEAB` 是旋转后序列 $S' = \\text{\"DEABC\"}$ 的一个线性子串。\n\n因此，要找到涉及一个或两个环状序列的最大局部比对得分，只需考虑序列所有可能旋转之间的所有可能的线性局部比对即可。\n设 $\\text{rot}(S)$ 为序列 $S$ 的所有唯一旋转的集合。如果序列 $S$ 是线性的，其旋转集合只包含其自身，即 $\\text{rot}(S) = \\{S\\}$。\n\n对于给定的测试用例 $(S_1, S_2, \\text{is\\_circular}_1, \\text{is\\_circular}_2, s_{\\text{match}}, s_{\\text{mismatch}}, s_{\\text{gap}})$，算法按以下步骤进行：\n$1$. 定义序列集 $R_1$ 和 $R_2$。如果 $\\text{is\\_circular}_1$ 为真，则 $R_1 = \\text{rot}(S_1)$；否则，$R_1 = \\{S_1\\}$。对 $S_2$ 也进行同样处理。\n$2$. 初始化一个用于存储最大得分的变量 $\\text{score}_{\\text{max}}$，其值为 $0$。\n$3$. 遍历 $R_1$ 中的每个序列 $S'_1$ 和 $R_2$ 中的每个序列 $S'_2$。\n$4$. 对于每对 $(S'_1, S'_2)$，使用如上所述的 Smith-Waterman 算法计算标准的线性局部比对得分。\n$5$. 使用目前找到的最大得分更新 $\\text{score}_{\\text{max}}$：$\\text{score}_{\\text{max}} = \\max(\\text{score}_{\\text{max}}, \\text{Score}(S'_1, S'_2))$。\n$6$. 在评估完所有对后，测试用例的最终结果是 $\\text{score}_{\\text{max}}$ 的值。\n\n这种对旋转的穷举枚举确保了所有可能的局部比对，包括那些跨越环状边界的比对，都被考虑到，从而得到全局最优分。所有计算均按规定使用整数算术进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the circular local alignment problem for a suite of test cases.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    # Each tuple: (seq1, seq2, is_circular_1, is_circular_2, s_match, s_mismatch, s_gap)\n    test_cases = [\n        (\"ATGCAT\", \"CATATG\", True, False, 2, -1, -2), # Case A\n        (\"GATTACA\", \"TTACAGA\", True, True, 2, -1, -2), # Case B\n        (\"AAAA\", \"TTTT\", True, False, 2, -1, -2),     # Case C\n        (\"ACGT\", \"AGT\", True, False, 3, -2, -2),      # Case D\n        (\"AAAA\", \"AAAA\", True, True, 2, -1, -3),     # Case E\n        (\"GCGT\", \"GCT\", False, False, 2, -1, -2),     # Case F\n    ]\n\n    results = []\n    for case in test_cases:\n        seq1, seq2, is_circ1, is_circ2, s_match, s_mismatch, s_gap = case\n        \n        # This function computes the local alignment score for two linear sequences\n        # using the Smith-Waterman algorithm.\n        def smith_waterman(s1, s2, match, mismatch, gap):\n            m, n = len(s1), len(s2)\n            # DP matrix H. H[i][j] is the score of the optimal alignment of a\n            # suffix of s1[0...i-1] and a suffix of s2[0...j-1].\n            H = np.zeros((m + 1, n + 1), dtype=int)\n            max_score = 0\n            \n            for i in range(1, m + 1):\n                for j in range(1, n + 1):\n                    # Score for matching or mismatching s1[i-1] and s2[j-1].\n                    similarity_score = match if s1[i-1] == s2[j-1] else mismatch\n                    match_mismatch_score = H[i-1, j-1] + similarity_score\n                    \n                    # Score for a gap in s1 (deletion)\n                    delete_score = H[i-1, j] + gap\n                    \n                    # Score for a gap in s2 (insertion)\n                    insert_score = H[i, j-1] + gap\n                    \n                    # The value of H[i,j] is the maximum of these possibilities,\n                    # or 0 if all are negative (starting a new local alignment).\n                    H[i, j] = max(0, match_mismatch_score, delete_score, insert_score)\n                    \n                    # Update the overall maximum score found so far.\n                    if H[i, j]  max_score:\n                        max_score = H[i, j]\n            \n            return int(max_score)\n\n        # Helper to generate all unique rotations of a sequence.\n        def get_rotations(seq):\n            if not seq:\n                return [\"\"]\n            return [seq[i:] + seq[:i] for i in range(len(seq))]\n\n        # Generate the sets of sequences to be compared, based on circularity.\n        rotations1 = get_rotations(seq1) if is_circ1 else [seq1]\n        rotations2 = get_rotations(seq2) if is_circ2 else [seq2]\n        \n        overall_max_score = 0\n        \n        # Iterate through all pairs of (rotated) sequences and find the max score.\n        for r1 in rotations1:\n            for r2 in rotations2:\n                current_score = smith_waterman(r1, r2, s_match, s_mismatch, s_gap)\n                if current_score  overall_max_score:\n                    overall_max_score = current_score\n        \n        results.append(overall_max_score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2401715"}, {"introduction": "Smith-Waterman算法保证能找到最优局部比对的分数，但在动态规划矩阵中，通常存在多条不同的路径可以达到这同一个最高分。仅仅报告其中任意一条比对路径可能会忽略其他同样有效的生物学可能性。这项进阶练习 [@problem_id:2401709] 要求你不仅仅是计算分数，而是通过修改回溯过程来识别并计数所有并列的最优比对。这个过程将极大地加深你对动态规划过程及其丰富内涵的理解。", "problem": "考虑两条基于脱氧核糖核酸 (DNA) 字母表的序列和一个局部比对计分方案。目标是从最优化原理出发进行推导，设计一个动态规划程序，该程序既能计算最优局部比对得分，并且关键地，通过修改回溯过程，在得分相等的路径上进行分支，来枚举所有同等最优的局部比对。您的程序必须实现此过程，并为每个提供的测试用例返回两个整数：最优局部比对得分和如下定义的同等最优局部比对的数量。请按规定将所有结果汇总到单行中。\n\n基本原理。请使用以下起点。序列 $A$ 和 $B$ 之间的一个局部比对，是指 $A$ 的一个连续子串与 $B$ 的一个连续子串的任意比对，其得分由一个替换函数和空位罚分决定，其中比对得分不允许低于 $0$；最优局部比对得分是所有此类比对中的最大值。根据动态规划 (DP) 的最优化原理，一个结束于某个单元格的最优比对的得分，仅取决于结束于其前驱单元格的最优子比对，以及用于扩展它们的直接操作。您必须基于此原理推导出递推关系，而不能假定任何快捷公式。\n\n计分模型。设 $A$ 和 $B$ 是长度分别为 $n$ 和 $m$ 的序列，其字母表为 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。定义替换得分函数 $\\sigma(x,y)$ 为：如果 $x=y$，则 $\\sigma(x,y)=s_{\\mathrm{match}}$；否则 $\\sigma(x,y)=s_{\\mathrm{mismatch}}$。对于插入单个空位符号，使用线性空位罚分 $g$。所有三个参数固定为 $s_{\\mathrm{match}}=+2$、$s_{\\mathrm{mismatch}}=-1$ 和 $g=-1$。\n\n处理得分并列的回溯与枚举。在局部比对的DP表 $H$ 中，对于每个单元格 $(i,j)$，您除了记录其得分外，还必须根据您推导出的递推关系，记录下得到该单元格值的前驱方向集合。当多个前驱产生相同的最大值时，所有这些方向都必须被记录下来。局部比对的回溯从 $H$ 中值等于全局最大值的任意单元格 $(i,j)$ 开始，通过重复移动到已记录的前驱方向来进行。当回溯到达值为 $0$ 的单元格时终止，该单元格标记了一个局部比对的起点；不要越过值为 $0$ 的单元格继续回溯。不同的回溯路径被视为不同的比对。如果全局最大值为 $0$，则将同等最优局部比对的数量定义为 $0$（即，忽略得分为 $0$ 的空比对）。\n\n要求的输出。对于每个测试用例，计算：\n- 最优局部比对得分（一个非负整数），以及\n- 在回溯过程中对所有得分并列的前驱方向进行完全分支，所得到的不同、同等最优局部比对的数量，该数量是所有具有全局最大值得分值的结束单元格的路径数之和。\n\n您的程序必须生成单行输出，其中包含测试套件的所有结果，形式为逗号分隔的列表，并用方括号括起，顺序为 $[\\text{score}_1,\\text{count}_1,\\text{score}_2,\\text{count}_2,\\dots]$。\n\n测试套件。使用以下五个测试用例；全部使用 $s_{\\mathrm{match}}=+2$，$s_{\\mathrm{mismatch}}=-1$ 和 $g=-1$：\n- 用例 1：$A=\\text{\"AA\"}$，$B=\\text{\"AA\"}$。\n- 用例 2：$A=\\text{\"AG\"}$，$B=\\text{\"GA\"}$。\n- 用例 3：$A=\\text{\"ACA\"}$，$B=\\text{\"AAA\"}$。\n- 用例 4：$A=\\text{\"C\"}$，$B=\\text{\"A\"}$。\n- 用例 5：$A=\\text{\"AAA\"}$，$B=\\text{\"AA\"}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。不涉及物理单位。所有输出必须是整数。", "solution": "该问题要求设计并实现一个动态规划程序，用以计算两条DNA序列的最优局部比对得分，并枚举所有不同的、同等最优的比对。推导过程必须从最优化原理出发。\n\n设两条序列分别为 $A = a_1a_2...a_n$ 和 $B = b_1b_2...b_m$，其长度分别为 $n$ 和 $m$。计分方案由匹配得分 $s_{\\mathrm{match}}=+2$、错配得分 $s_{\\mathrm{mismatch}}=-1$ 和线性空位罚分 $g=-1$ 定义。\n\n解决方案的基础是 Smith-Waterman 算法，该算法是动态规划在局部序列比对中的直接应用。最优化原理指出，一个最优解可以由其子问题的最优解构建而成。令 $H(i,j)$ 为结束于序列 $A$ 的位置 $i$ 和序列 $B$ 的位置 $j$ 的得分最高的局部比对的得分。一个结束于 $(i,j)$ 的比对可以通过以下三种方式之一形成：\n1. 通过比对字符 $a_i$ 和 $b_j$。其得分为结束于 $(i-1, j-1)$ 的最优比对得分与替换得分 $\\sigma(a_i, b_j)$ 之和。这得到 $H(i-1, j-1) + \\sigma(a_i, b_j)$。\n2. 通过将字符 $a_i$ 与一个空位进行比对。其得分为结束于 $(i-1, j)$ 的最优比对得分与空位罚分 $g$ 之和。这得到 $H(i-1, j) + g$。\n3. 通过将字符 $b_j$ 与一个空位进行比对。其得分为结束于 $(i, j-1)$ 的最优比对得分与空位罚分 $g$ 之和。这得到 $H(i, j-1) + g$。\n\n由于比对是局部的，它可以从任何位置开始。这通过在所有其他可能性得分均为负值时允许得分为 $0$ 来处理，从而有效地开始一个新的比对。综合这些情况， $H(i,j)$ 的递推关系为：\n$$\nH(i,j) = \\max \\left\\{\n    0, \\\\\n    H(i-1, j-1) + \\sigma(a_i, b_j), \\\\\n    H(i-1, j) + g, \\\\\n    H(i, j-1) + g\n\\right\\}\n$$\n其中 $1 \\leq i \\leq n$ 且 $1 \\leq j \\leq m$。DP 矩阵 $H$ 的维度为 $(n+1) \\times (m+1)$。边界条件是对于所有从 $0$ 到 $n$ 的 $i$， $H(i,0) = 0$，以及对于所有从 $0$ 到 $m$ 的 $j$，$H(0,j) = 0$。这些初始化确保比对可以从任何位置开始，而不会因末端空位而产生罚分。\n\n最优局部比对得分 $\\text{score}_{\\text{opt}}$ 是在矩阵 $H$ 中找到的最大值：\n$$\n\\text{score}_{\\text{opt}} = \\max_{0 \\le i \\le n, 0 \\le j \\le m} H(i,j)\n$$\n\n为了枚举所有同等最优的比对，我们必须对该程序进行扩展。首先，我们需要为每个单元格记录其得分的来源。我们定义一个与 $H$ 维度相同的指针结构 $P$。每个元素 $P(i,j)$ 将存储一个方向集合，对应于产生得分 $H(i,j)$ 的前驱。\n- 如果 $H(i,j) = H(i-1, j-1) + \\sigma(a_i, b_j)$，则将 `DIAGONAL` 方向添加到 $P(i,j)$。\n- 如果 $H(i,j) = H(i-1, j) + g$，则将 `UP` 方向添加到 $P(i,j)$。\n- 如果 $H(i,j) = H(i, j-1) + g$，则将 `LEFT` 方向添加到 $P(i,j)$。\n如果多个情况为 $H(i,j)$ 产生了相同的最大值，则所有对应的方向都会被记录。$H(i,j)=0$ 的情况对应于比对的开始，没有前驱。\n\n枚举过程如下：\n1. 识别出矩阵 $H$ 中所有满足 $H(i_{end}, j_{end}) = \\text{score}_{\\text{opt}}$ 的单元格 $(i_{end}, j_{end})$。这些是所有最优局部比对的终止点。\n2. 如果 $\\text{score}_{\\text{opt}} = 0$，根据问题定义，比对的数量为 $0$。\n3. 对于每个识别出的结束单元格，我们必须计算其回溯到得分为 $0$ 的单元格的不同路径数量。一条路径是从一个单元格到另一个单元格的一系列移动，遵循存储在 $P$ 中的方向。总比对数是源自所有这些最大得分单元格的路径数之和。\n\n为了在计算这些路径时避免因重复探索共享子路径而导致的指数级复杂性，我们采用另一种动态规划技术：记忆化 (memoization)。我们定义一个递归函数 $\\text{count\\_paths}(i, j)$，用以计算结束于单元格 $(i, j)$ 的不同路径数量。\n设 $C(i,j)$ 是从一个得分为 $0$ 的单元格到单元格 $(i,j)$、构成一个最优子比对的路径数量。\n$C(i,j)$ 的递推关系为：\n- **基本情况：** 如果 $H(i,j) = 0$，则 $C(i,j) = 1$。这表示从该点开始的一条路径。\n- **递归步骤：** 对于 $H(i,j)  0$，路径数是来自其在 $P(i,j)$ 中记录的所有前驱的路径数之和：\n  $$\n  C(i,j) = \\sum_{(i', j') \\in \\text{predecessors}(i,j)} C(i',j')\n  $$\n这可以实现为一个带有记忆化表的递归函数，用于存储 $C(i,j)$ 的结果以避免冗余计算。\n\n整体算法如下：\n1. 初始化一个 $(n+1) \\times (m+1)$ 的得分矩阵 $H$ 为零，以及一个同样大小、带有空集合/列表的指针结构 $P$。\n2. 通过从 $i=1...n$ 和 $j=1...m$ 迭代，应用递推关系并记录所有产生最大值的前驱方向，来填充 $H$ 和 $P$。\n3. 找到 $\\text{score}_{\\text{opt}} = \\max(H)$。\n4. 如果 $\\text{score}_{\\text{opt}} = 0$，返回 $(0, 0)$。\n5. 否则，找到所有满足 $H(i_{end}, j_{end}) = \\text{score}_{\\text{opt}}$ 的单元格 $(i_{end}, j_{end})$。\n6. 初始化一个用于路径计数的 $(n+1) \\times (m+1)$ 记忆化表。\n7. 初始化总比对计数为 $0$。对于每个 $(i_{end}, j_{end})$，使用递归、记忆化的函数计算 $\\text{count\\_paths}(i_{end}, j_{end})$，并将其结果加到总计数中。\n8. 返回序对 $(\\text{score}_{\\text{opt}}, \\text{total count})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the alignment problem for all test cases.\n    \"\"\"\n    \n    # scoring model is fixed for all test cases\n    s_match = 2\n    s_mismatch = -1\n    g = -1\n    \n    # Test suite from the problem statement\n    test_cases = [\n        (\"AA\", \"AA\"),        # Case 1\n        (\"AG\", \"GA\"),        # Case 2\n        (\"ACA\", \"AAA\"),      # Case 3\n        (\"C\", \"A\"),          # Case 4\n        (\"AAA\", \"AA\"),       # Case 5\n    ]\n    \n    all_results = []\n    for seq_a, seq_b in test_cases:\n        score, count = smith_waterman_enumerator(seq_a, seq_b, s_match, s_mismatch, g)\n        all_results.extend([score, count])\n        \n    # Format the final output string exactly as specified.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef smith_waterman_enumerator(seq_a, seq_b, s_match, s_mismatch, g):\n    \"\"\"\n    Computes the optimal local alignment score and enumerates all equally optimal alignments.\n\n    Args:\n        seq_a (str): The first sequence.\n        seq_b (str): The second sequence.\n        s_match (int): The score for a match.\n        s_mismatch (int): The score for a mismatch.\n        g (int): The linear gap penalty.\n\n    Returns:\n        tuple[int, int]: A tuple containing the optimal score and the number of optimal alignments.\n    \"\"\"\n    n = len(seq_a)\n    m = len(seq_b)\n\n    # DP score matrix H\n    H = np.zeros((n + 1, m + 1), dtype=int)\n    \n    # Pointer matrix P to store traceback directions for tied scores\n    P = [[[] for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Substitution score function\n    def sigma(char_a, char_b):\n        return s_match if char_a == char_b else s_mismatch\n\n    # Fill the DP matrices H and P\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            score_diag = H[i-1, j-1] + sigma(seq_a[i-1], seq_b[j-1])\n            score_up = H[i-1, j] + g\n            score_left = H[i, j-1] + g\n            \n            max_score = max(0, score_diag, score_up, score_left)\n            H[i, j] = max_score\n            \n            if max_score  0:\n                if max_score == score_diag:\n                    P[i][j].append('D') # Diagonal\n                if max_score == score_up:\n                    P[i][j].append('U') # Up\n                if max_score == score_left:\n                    P[i][j].append('L') # Left\n\n    # Find the optimal score and its location(s)\n    optimal_score = np.max(H)\n    \n    # Per problem statement, if max score is 0, count is 0\n    if optimal_score == 0:\n        return 0, 0\n    \n    max_indices = np.argwhere(H == optimal_score)\n    \n    # Memoization table for path counting, initialized with -1 (unvisited)\n    counts_memo = np.full((n + 1, m + 1), -1, dtype=int)\n\n    def count_paths(i, j):\n        \"\"\"Recursively count paths with memoization.\"\"\"\n        if counts_memo[i, j] != -1:\n            return counts_memo[i, j]\n        \n        # Base case: traceback terminates at a cell with score 0\n        if H[i, j] == 0:\n            return 1\n            \n        current_count = 0\n        for direction in P[i][j]:\n            if direction == 'D':\n                current_count += count_paths(i - 1, j - 1)\n            elif direction == 'U':\n                current_count += count_paths(i - 1, j)\n            elif direction == 'L':\n                current_count += count_paths(i, j - 1)\n        \n        counts_memo[i, j] = current_count\n        return current_count\n\n    total_alignments = 0\n    for idx_pair in max_indices:\n        i_end, j_end = idx_pair\n        total_alignments += count_paths(i_end, j_end)\n        \n    return int(optimal_score), total_alignments\n\nsolve()\n```", "id": "2401709"}]}