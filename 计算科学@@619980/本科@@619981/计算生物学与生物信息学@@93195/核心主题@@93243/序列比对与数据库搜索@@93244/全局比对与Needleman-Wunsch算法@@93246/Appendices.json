{"hands_on_practices": [{"introduction": "一个成功的序列比对不仅仅依赖于算法本身，更关键的是如何选择恰当的评分参数。这个练习提供了一个假设但极具启发性的场景：一个“简单”的评分方案在特定生物学背景下，其结果可能比一个“复杂”的方案更具相关性。通过这个思想实验，我们能练习如何批判性地思考评分矩阵和罚分如何共同作用，以突显我们希望比对所关注的特定序列特征，从而培养我们根据生物学问题选择合适工具的能力。[@problem_id:2395031]", "problem": "序列分析中的一个核心原则是，全局比对的生物学相关性取决于选择压力作用的对象：一些特征只有在精确的残基对齐时才被保守，而其他区域则可能容忍保守性替换。考虑两条肽序列 $X$ 和 $Y$，它们都含有整合素结合三肽基序 RGD，该基序通常受到强大的功能性约束，需要被精确保守。这两条序列是：\n\n- $X$: I L V I L V R G D I L\n- $Y$: I I L V I L V A R G D\n\n假设我们将使用带有线性空位模型的 Needleman–Wunsch 算法来计算全局比对。给出了两种可选的评分系统：\n\n- 一致性评分：如果 $a=b$，则 $s(a,b)=+1$；如果 $a\\neq b$，则 $s(a,b)=-1$；每个空位符号的线性空位罚分为 $g=-1$。\n- 一种类似 BLOSUM 的复杂替换方案 $s'(a,b)$，其线性空位罚分为 $g'=-6$，其定义在本文出现的残基子集上，如下所示：\n  - $s'(a,a)=+4$（精确匹配）。\n  - $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V}\\}$ 之间的保守性疏水替换得分为 $+3$：$s'(\\mathrm{I},\\mathrm{L})=s'(\\mathrm{L},\\mathrm{I})=s'(\\mathrm{I},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{I})=s'(\\mathrm{L},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{L})=+3$。\n  - 特定的非保守性配对：$s'(\\mathrm{R},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{R})=-3$，$s'(\\mathrm{D},\\mathrm{R})=s'(\\mathrm{R},\\mathrm{D})=-2$，$s'(\\mathrm{L},\\mathrm{D})=s'(\\mathrm{D},\\mathrm{L})=-3$。\n  - 中性配对：$s'(\\mathrm{G},\\mathrm{A})=s'(\\mathrm{A},\\mathrm{G})=0$，$s'(\\mathrm{I},\\mathrm{G})=s'(\\mathrm{G},\\mathrm{I})=0$。\n  - 任何其他未指定的错配得分为 $-1$。\n\n生物学背景。对于这两种蛋白质，已知 RGD 基序必须精确对齐（R 对 R，G 对 G，D 对 D）以保留整合素结合能力；疏水背景中的保守性替换通常可以被容忍，但并非功能上的决定性因素。因此，一个具有生物学相关性的全局比对是能够精确比对 RGD 三肽的比对，即使这需要在附近的低复杂度疏水区中引入空位。\n\n基本原理。在带线性空位模型的条件下，前缀 $X[1..i]$ 和 $Y[1..j]$ 的全局比对分数遵循 Needleman–Wunsch 动态规划递推式\n$$\nF(i,j) \\;=\\; \\max\\big\\{\\, F(i-1,j-1) + s(x_i,y_j),\\;\\; F(i-1,j)+g,\\;\\; F(i,j-1)+g \\,\\big\\}\n$$\n并经过适当的初始化，其中 $s$ 是替换得分，$g$ 是空位罚分（对于类似 BLOSUM 的方案，则相应地使用 $s'$ 和 $g'$）。一个最优的全局比对应于此动态规划中的一条最优路径。\n\n任务。在不构建完整动态规划表的情况下，根据递推式和评分定义进行推理，以确定每种评分方案在这两种自然的竞争比对结构中会偏好哪一种：\n- “无空位”比对，它将长的疏水性区块保持在对角线上对齐，并且不重新对齐 RGD 基序（导致基序偏移并大部分错配）。\n- “基序对齐”比对，它在疏水性区块内部引入空位以滑动序列，从而使 RGD 精确对齐。\n\n哪个陈述是正确的？\n\nA. 在使用一致性评分时，最优比对会引入2个空位来精确比对 RGD，并获得了比最好的无空位比对更高的分数；在使用空位罚分为 $g'=-6$ 的类似 BLOSUM 的方案时，最优比对避免了空位，保持了疏水性区块的对齐，并使 RGD 错位，因为这样能产生更高的分数。因此，一致性评分的比对更具生物学相关性。\n\nB. 两种评分方案都选择了相同的、精确比对 RGD 的最优比对；两种方案均未提供优势。\n\nC. 在使用一致性评分时，最优比对避免了空位并使 RGD 错位；在使用类似 BLOSUM 的方案时，最优比对精确地对齐了 RGD，即使必须引入空位。因此，类似 BLOSUM 的方案更具生物学相关性。\n\nD. 两种方案都无法区分 RGD 对齐和 RGD 错位的方案，因为在两种方案下它们的分数相同。", "solution": "首先将对问题陈述进行严格验证。\n\n### 步骤1：提取已知信息\n\n提供的信如下：\n- **序列 $X$**：$\\text{I L V I L V R G D I L}$ (长度 $N_X = 11$)\n- **序列 $Y$**：$\\text{I I L V I L V A R G D}$ (长度 $N_Y = 11$)\n- **算法**：带线性空位模型的 Needleman–Wunsch 全局比对。\n- **递推关系**：$F(i,j) = \\max\\{ F(i-1,j-1) + s(x_i,y_j), F(i-1,j)+g, F(i,j-1)+g \\}$。\n- **评分系统1（一致性）**：\n  - 替换得分：如果 $a=b$，则 $s(a,b)=+1$；如果 $a\\neq b$，则 $s(a,b)=-1$。\n  - 空位罚分：$g=-1$。\n- **评分系统2（类似 BLOSUM）**：\n  - 替换得分 $s'(a,b)$:\n    - $s'(a,a)=+4$（匹配）。\n    - $s'(\\mathrm{I},\\mathrm{L})=s'(\\mathrm{I},\\mathrm{V})=s'(\\mathrm{L},\\mathrm{V})=+3$（及其对称配对）。\n    - $s'(\\mathrm{R},\\mathrm{V})=-3$（及其对称配对）。\n    - $s'(\\mathrm{D},\\mathrm{R})=-2$（及其对称配对）。\n    - $s'(\\mathrm{L},\\mathrm{D})=-3$（及其对称配对）。\n    - $s'(\\mathrm{G},\\mathrm{A})=0$（及其对称配对）。\n    - $s'(\\mathrm{I},\\mathrm{G})=0$（及其对称配对）。\n    - 对于所有其他未指定的错配，$s'(a,b)=-1$。\n  - 空位罚分：$g'=-6$。\n- **竞争比对方案**：\n  1. **“无空位”比对**：一个没有空位的完全对角线比对。\n  2. **“基序对齐”比对**：一个通过引入空位来将 $X$ 的 $\\text{RGD}$ 基序与 $Y$ 的 $\\text{RGD}$ 基序对齐的比对。\n- **生物学背景**：如果 $\\text{RGD}$ 三肽被精确保守，则认为比对具有“生物学相关性”。\n\n### 步骤2：使用提取的已知信息进行验证\n\n该问题将根据既定原则进行验证。\n- **科学依据**：该问题是生物信息学中的一个标准练习，涉及用于全局序列比对的基本 Needleman-Wunsch 算法。评分方案，包括一个简化的一致性矩阵和一个类似 BLOSUM 的矩阵，都是标准工具。$\\text{RGD}$ 基序是一个经典的、有据可查的功能受约束的短线性基序的例子。该问题牢固地建立在成熟的计算生物学基础上。\n- **问题明确**：该问题提供了两个特定的序列、两个明确且完全定义的评分系统，以及两个清晰描述的竞争比对结构。任务是计算和比较这些比对的分数，这是一个确定性的、定义明确的数学过程。可以推导出唯一且有意义的答案。\n- **客观性**：该问题使用精确、客观的语言和定量数据（序列、分数）进行陈述。它不包含主观或基于意见的主张。\n\n该问题没有科学上不健全、不完整、矛盾或模糊等缺陷。序列长度相同（$11$），这简化了“无空位”的情况，但需要仔细构建“基序对齐”的情况，因为偏移必须通过相等数量的插入和删除来完成。这是全局比对问题的标准特征。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。现在将通过计算并比较两种指定比对结构在两种评分系统下的得分来推导解决方案。\n\n### 求解过程\n\n任务是确定两种评分方案各自偏好两种比对结构中的哪一种。我们必须首先明确地构建这两种比对。\n\n**比对1：“无空位”比对**\n由于序列 $X$ 和 $Y$ 的长度都为 $11$，无空位的全局比对是残基的直接逐列配对：\n$$\n\\begin{array}{lllllllllll}\nX: & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & \\text{R} & \\text{G} & \\text{D} & \\text{I} & \\text{L} \\\\\nY: & \\text{I} & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & \\text{A} & \\text{R} & \\text{G} & \\text{D}\n\\end{array}\n$$\n\n**比对2：“基序对齐”比对**\n基序 $\\text{RGD}$ 出现在 $X$ 的索引 $7-9$ 和 $Y$ 的索引 $9-11$ 处。为了对齐它们，需要2个位置的偏移。对于两个等长序列的全局比对，一个序列中的任何插入都必须由另一个序列中的插入来平衡。为了将 $X[7..9]$ 与 $Y[9..11]$ 对齐，前缀 $X[1..6]$（长度为6）必须与前缀 $Y[1..8]$（长度为8）对齐，这需要在 $X$ 中引入2个空位。后缀 $X[10..11]$（长度为2）必须与一个来自 $Y$ 的空后缀对齐，这需要在 $Y$ 中引入2个空位。由此产生的比对总共有4个空位，长度为13。\n$$\n\\begin{array}{lllllllllllll}\nX: & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & - & - & \\text{R} & \\text{G} & \\text{D} & \\text{I} & \\text{L} \\\\\nY: & \\text{I} & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & \\text{A} & \\text{R} & \\text{G} & \\text{D} & - & -\n\\end{array}\n$$\n\n我们现在计算每种比对在两种评分系统下的得分。\n\n**使用一致性评分（$s(a,b)=\\pm1, g=-1$）进行分析**\n\n- **比对1（无空位）的得分**：\n  我们计算匹配和错配的数量。\n  - 匹配：位置1处的 $(\\text{I},\\text{I})$。总计：1个匹配。\n  - 错配：所有其他10个位置。总计：10个错配。\n  - 得分 $= 1 \\times (+1) + 10 \\times (-1) = 1 - 10 = -9$。\n\n- **比对2（基序对齐）的得分**：\n  我们计算13个比对列中的匹配、错配和空位。\n  - 匹配：$(\\text{I},\\text{I})$, $(\\text{R},\\text{R})$, $(\\text{G},\\text{G})$, $(\\text{D},\\text{D})$。总计：4个匹配。\n  - 错配：$(\\text{L},\\text{I})$, $(\\text{V},\\text{L})$, $(\\text{I},\\text{V})$, $(\\text{L},\\text{I})$, $(\\text{V},\\text{L})$。总计：5个错配。\n  - 空位： $(-, \\text{V})$, $(-, \\text{A})$, $(\\text{I}, -)$, $(\\text{L}, -)$。总计：4个空位。\n  - 得分 $= 4 \\times (+1) + 5 \\times (-1) + 4 \\times (-1) = 4 - 5 - 4 = -5$。\n  \n  得分（无空位） = $-9$。得分（基序对齐） = $-5$。\n  由于 $-5 > -9$，一致性评分方案偏好基序对齐的结构。\n\n**使用类似 BLOSUM 的评分（$s'(a,b)$, $g'=-6$）进行分析**\n\n- **比对1（无空位）的得分**：\n  `I/I`: $s'(\\text{I},\\text{I})=+4$。\n  `L/I`: $s'(\\text{L},\\text{I})=+3$。\n  `V/L`: $s'(\\text{V},\\text{L})=+3$。\n  `I/V`: $s'(\\text{I},\\text{V})=+3$。\n  `L/I`: $s'(\\text{L},\\text{I})=+3$。\n  `V/L`: $s'(\\text{V},\\text{L})=+3$。\n  `R/V`: $s'(\\text{R},\\text{V})=-3$。\n  `G/A`: $s'(\\text{G},\\text{A})=0$。\n  `D/R`: $s'(\\text{D},\\text{R})=-2$。\n  `I/G`: $s'(\\text{I},\\text{G})=0$。\n  `L/D`: $s'(\\text{L},\\text{D})=-3$。\n  总分 $= (4+3+3+3+3+3) - 3 + 0 - 2 + 0 - 3 = 19 - 8 = +11$。\n\n- **比对2（基序对齐）的得分**：\n  该比对包含替换配对和4个空位。空位罚分非常严厉：$g'=-6$。\n  - 前缀 `ILVILV` 与 `IILVIL` 对齐，加上 `RGD` 与 `RGD` 对齐的替换得分: $s'(\\text{I},\\text{I}) + s'(\\text{L},\\text{I}) + s'(\\text{V},\\text{L}) + s'(\\text{I},\\text{V}) + s'(\\text{L},\\text{I}) + s'(\\text{V},\\text{L}) + s'(\\text{R},\\text{R}) + s'(\\text{G},\\text{G}) + s'(\\text{D},\\text{D}) = 4+3+3+3+3+3 + 4+4+4 = +31$。\n  - 4个空位的总罚分：$4 \\times g' = 4 \\times (-6) = -24$。\n  - 总分 = (替换得分) + (空位罚分) = $31 - 24 = +7$。\n\n- **比较**：得分（无空位） $=+11$。得分（基序对齐） $=+7$。\n  由于 $+11 > +7$，类似 BLOSUM 的方案偏好无空位比对。高额的空位罚分（$g'=-6$）使得引入空位的代价过高，即使是为了对齐高得分的 RGD 匹配也不例外。\n\n### 结论与选项评估\n\n- **一致性评分**：基序对齐结构（得分-5）优于无空位结构（得分-9）。\n- **类似 BLOSUM 评分**：无空位结构（得分+11）优于基序对齐结构（得分+7）。\n- **生物学相关性**：问题陈述指出，生物学相关性要求 $\\text{RGD}$ 基序对齐。因此，在这种特定情况下，一致性评分系统产生了更具生物学相关性的比对，而具有高空位罚分的类似 BLOSUM 方案则未能做到这一点。\n\n我们现在基于此分析评估给出的选项。\n\n- **A.** “在使用一致性评分时，最优比对会引入空位来精确比对 RGD，并获得了比最好的无空位比对更高的分数；在使用空位罚分为 $g'=-6$ 的类似 BLOSUM 的方案时，最优比对避免了空位，保持了疏水性区块的对齐，并使 RGD 错位，因为这样能产生更高的分数。因此，一致性评分的比对更具生物学相关性。”\n  该陈述与我们的发现完全一致。第一部分是正确的（一致性评分偏好基序对齐）。第二部分是正确的（类似BLOSUM评分偏好无空位）。关于生物学相关性的结论也根据问题的定义是正确的。此选项**正确**。\n\n- **B.** “两种评分方案都选择了相同的、精确比对 RGD 的最优比对；两种方案均未提供优势。”\n  这是错误的。两种方案偏好不同的比对结构。此选项**不正确**。\n\n- **C.** “在使用一致性评分时，最优比对避免了空位并使 RGD 错位；在使用类似 BLOSUM 的方案时，最优比对精确地对齐了 RGD，即使必须引入空位。因此，类似 BLOSUM 的方案更具生物学相关性。”\n  该陈述与我们对两种评分系统的发现完全相反。此选项**不正确**。\n\n- **D.** “两种方案都无法区分 RGD 对齐和 RGD 错位的方案，因为在两种方案下它们的分数相同。”\n  两种情况下的分数都不同（$-5 \\neq -9$ 且 $+7 \\neq +11$）。此选项**不正确**。\n\n唯一正确的陈述是 A。", "answer": "$$\\boxed{A}$$", "id": "2395031"}, {"introduction": "探索一个算法的极限是理解其本质的有效方法。这个练习引导我们思考一个反直觉的问题：如何修改 Needleman-Wunsch 算法来寻找两个序列间“最差”的全局比对？通过解决这个问题，我们不仅能更深刻地理解该算法作为一个灵活的优化框架的本质，还能巩固其在概率和对数几率（log-odds）评分框架下的理论基础，这对于解释比对分数的统计意义至关重要。[@problem_id:2395055]", "problem": "给定字母表 $\\Sigma$（例如，核苷酸或氨基酸）上的两个生物序列 $S$ 和 $T$。考虑使用加性评分方案的全局比对：当 $a,b \\in \\Sigma$ 时，每个比对的字符对 $(a,b)\\in\\Sigma\\cup\\{-\\}$ 贡献一个替换得分 $s(a,b)$；当一个字符与空格符号 $-$ 比对时，贡献一个罚分 $g(a,-)=g(-,a)$，不允许空格-空格比对。Needleman–Wunsch (NW) 算法利用全局比对的最优子结构，在 $S$ 和 $T$ 的所有比对中，找到一个能优化总比对得分 $S(\\mathcal{A})$ 的比对，该得分定义为所有比对列贡献的总和。假设 $s(a,b)$ 使匹配有利（例如 $s(a,a)>0$），而错配和空格不利（例如当 $a\\neq b$ 时 $s(a,b)<0$ 且 $g(a,-)<0$），因此标准做法是最大化 $S(\\mathcal{A})$。\n\n现要求您修改该过程，以在相同的加性模型下获得尽可能不相似的比对，即找到一个比对 $\\mathcal{A}_{\\mathrm{worst}}$，它在原始的 $s$ 和 $g$ 下最小化总得分，或者等价地，最大化不相似性。此外，在一个常见假设下，从生物学或信息论的角度解释得到的极值得分，该假设认为替换得分是从一个同源模型与一个背景模型对比得出的对数奇数比。\n\n哪个选项最准确地描述了正确的修改方法和有效的解释？\n\n- A. 将所有替换得分和罚分取反，得到 $s'(a,b)=-s(a,b)$ 和 $g'(a,-)=-g(a,-)$，然后运行标准的 Needleman–Wunsch (NW) 最大化算法来计算 $\\max_{\\mathcal{A}} \\sum s' + g'$，其结果等于 $-\\min_{\\mathcal{A}} \\sum s + g$。在对数奇数比评分 $s(a,b)=\\log \\frac{Q(a,b)}{P(a)P(b)}$ 以及罚分表示为插入-缺失模型的对数奇数比的情况下，所得的最大不相似性值等于对同源性的最优对数奇数比支持度的负值，并且可以解读为在该模型下反对 $S$ 和 $T$ 之间存在同源性的最强证据。\n- B. 保持得分不变，但将动态规划中的每一次最大化替换为最小化，以获得最差比对；对于任何评分方案，其结果目标都等于 Levenshtein 编辑距离，因此通常定义了一个满足三角不等式的度量。\n- C. 只对匹配得分 $s(a,a)$ 取反，而保持错配和罚分不变，然后用 Needleman–Wunsch (NW) 进行最大化；所得的值近似于 $S$ 和 $T$ 的氨基酸组成之间的 Kullback–Leibler 散度，从而量化了组成水平上的不相似性。\n- D. 保持原始得分并仍然执行最大化，但强制动态规划在每个递归步骤中选择局部最差的选项；所得的目标提供了 $S$ 和 $T$ 之间突变数量的一个上界，且该上界与评分参数的选择无关。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   两个生物序列 $S$ 和 $T$，定义在字母表 $\\Sigma$上。\n-   使用加性评分方案的全局比对。\n-   替换得分：$s(a,b)$，其中 $a,b \\in \\Sigma$。\n-   罚分：$g(a,-) = g(-,a)$，其中 $a \\in \\Sigma$，此处记为 $g$。为简单起见，我们假设罚分为常数，这是常见的做法，尽管该逻辑对仿射或其他方案也成立。\n-   比对 $\\mathcal{A}$ 的比对得分：$S(\\mathcal{A}) = \\sum_{\\text{列}} \\text{得分}(\\text{列})$。\n-   标准的 Needleman-Wunsch (NW) 算法最大化 $S(\\mathcal{A})$。\n-   评分方案的假定属性：\n    -   匹配是有利的：$s(a,a) > 0$。\n    -   错配是不利的：当 $a \\neq b$ 时 $s(a,b) < 0$。\n    -   空格是不利的：$g < 0$。\n-   主要目标：修改过程以找到一个使总得分最小化的比对 $\\mathcal{A}_{\\mathrm{worst}}$，即找到 $\\min_{\\mathcal{A}} S(\\mathcal{A})$。\n-   次要目标：在分数为对数奇数比的假设下，解释得到的极值得分，即 $s(a,b) = \\log \\frac{Q(a,b)}{P(a)P(b)}$，其中 $Q$ 是一个同源概率模型，$P$ 是一个背景概率模型。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题牢固地植根于计算生物学和生物信息学。它涉及广为人知的 Needleman-Wunsch 算法、加性评分方案及其作为对数奇数比分数的标准概率解释。所有概念都是该领域的基础。\n2.  **适定性：** 该问题是适定的。它要求对一个标准算法进行修改，以解决一个不同但相关的优化问题（最小化而非最大化），并对结果提供理论解释。目标明确且存在解决方案。\n3.  **客观性：** 语言正式、精确，没有主观或含糊的术语。\n4.  **一致性和完整性：** 问题陈述是自洽且内部一致的。它提供了构建解决方案所需的所有必要背景。\n\n### 步骤 3：结论和行动\n问题陈述有效。这是生物信息学理论中一个标准且表述良好的问题。我将继续推导解决方案并评估选项。\n\n### 解题推导\n\n目标是计算两个序列 $S$ 和 $T$ 之间可能的最小比对得分。设任意比对 $\\mathcal{A}$ 的得分为 $S(\\mathcal{A})$。我们寻求找到 $\\mathcal{A}_{\\mathrm{worst}}$ 使得 $S(\\mathcal{A}_{\\mathrm{worst}}) = \\min_{\\mathcal{A}} S(\\mathcal{A})$。\n\nNeedleman-Wunsch 算法是一种动态规划算法，旨在找到 $\\max_{\\mathcal{A}} S(\\mathcal{A})$。得分矩阵 $F(i,j)$ 的递推关系是：\n$$F(i,j) = \\max \\begin{cases} F(i-1, j-1) + s(S_i, T_j) & \\text{(对角移动)} \\\\ F(i-1, j) + g & \\text{(垂直移动，}T\\text{中有空格)} \\\\ F(i, j-1) + g & \\text{(水平移动，}S\\text{中有空格)} \\end{cases}$$\n最大得分即为 $F(|S|, |T|)$。\n\n为了找到最小得分，我们可以利用优化的一个基本性质：对于定义域 $X$ 上的任何函数 $f(x)$，以下恒等式成立：\n$$\\min_{x \\in X} f(x) = - \\max_{x \\in X} (-f(x))$$\n\n在我们的背景下，$x$ 是一个比对 $\\mathcal{A}$，$f(x)$ 是得分 $S(\\mathcal{A})$。让我们通过对原始得分取反来定义一个新的评分方案，$s'$ 和 $g'$：\n$$s'(a,b) = -s(a,b)$$\n$$g' = -g$$\n在这个新方案下，比对 $\\mathcal{A}$ 的得分 $S'(\\mathcal{A})$ 是：\n$$S'(\\mathcal{A}) = \\sum_{\\text{列 } c \\in \\mathcal{A}} \\text{score}'(c) = \\sum_{\\text{列 } c \\in \\mathcal{A}} (-\\text{score}(c)) = - \\left( \\sum_{\\text{列 } c \\in \\mathcal{A}} \\text{score}(c) \\right) = -S(\\mathcal{A})$$\n因此，在原始方案下找到最小得分，等价于在取反的方案下找到最大得分，然后将结果取反：\n$$\\min_{\\mathcal{A}} S(\\mathcal{A}) = - \\max_{\\mathcal{A}} (-S(\\mathcal{A})) = - \\max_{\\mathcal{A}} S'(\\mathcal{A})$$\n量 $\\max_{\\mathcal{A}} S'(\\mathcal{A})$ 可以使用标准的 Needleman-Wunsch 最大化算法和新的得分 $s'$ 和 $g'$ 来计算。这为找到最小比对得分提供了一个正确的过程。\n\n或者，可以直接修改递推关系，将最大化替换为最小化：\n$$F_{\\min}(i,j) = \\min \\begin{cases} F_{\\min}(i-1, j-1) + s(S_i, T_j) \\\\ F_{\\min}(i-1, j) + g \\\\ F_{\\min}(i, j-1) + g \\end{cases}$$\n结果 $F_{\\min}(|S|, |T|)$ 将直接得出 $\\min_{\\mathcal{A}} S(\\mathcal{A})$。这在算法上等同于取反方法。\n\n现在来解释。原始评分方案基于对数奇数比。比对的得分 $S(\\mathcal{A}) = \\sum \\log \\frac{P(\\text{列}|\\text{同源})}{P(\\text{列}|\\text{随机})}$ 是整个比对在同源模型与随机背景模型下的对数似然比。最优得分 $\\max_{\\mathcal{A}} S(\\mathcal{A})$ 代表了*支持*序列 $S$ 和 $T$ 之间同源性的最强可能证据。对称地，最小得分 $\\min_{\\mathcal{A}} S(\\mathcal{A})$ 代表了使同源性看起来最不可能的比对。因此，该得分可以被解释为在给定模型下*反对*同源性的最强证据，或最大不相似性的度量。\n\n### 逐项分析选项\n\n**A. 将所有替换得分和罚分取反，得到 $s'(a,b)=-s(a,b)$ 和 $g'(a,-)=-g(a,-)$，然后运行标准的 Needleman–Wunsch (NW) 最大化算法来计算 $\\max_{\\mathcal{A}} \\sum s' + g'$，其结果等于 $-\\min_{\\mathcal{A}} \\sum s + g$。在对数奇数比评分 $s(a,b) = \\log \\frac{Q(a,b)}{P(a)P(b)}$ 以及罚分表示为插入-缺失模型的对数奇数比的情况下，所得的最大不相似性值等于对同源性的最优对数奇数比支持度的负值，并且可以解读为在该模型下反对 $S$ 和 $T$ 之间存在同源性的最强证据。**\n\n-   **过程：** 所提出的过程是对所有得分取反，并使用标准的最大化算法。如上推导，这正确地计算了 $\\max_{\\mathcal{A}} S'(\\mathcal{A}) = -\\min_{\\mathcal{A}} S(\\mathcal{A})$。该过程的描述在数学上是合理的。\n-   **解释：**\n    1.  “……可以解读为反对同源性的最强证据……”：最小得分 $\\min_{\\mathcal{A}} S(\\mathcal{A})$ 确实是最差情况比对的对数似然比，代表了反对同源性的最强证据。这部分解释是正确的。\n    2.  “……所得的最大不相似性值等于对同源性的最优对数奇数比支持度的负值……”：这个陈述断言 $\\min_{\\mathcal{A}} S(\\mathcal{A}) = - \\max_{\\mathcal{A}} S(\\mathcal{A})$。这通常是错误的。所有可能比对的得分分布并非围绕零对称。例如，对于两个相关的序列，最大得分将是大的正数，而最小得分可能是非常大的负数，且 $|\\min S| \\gg |\\max S|$。因此，这部分解释是错误的。\n-   **结论：** 过程是正确的。定性解释是正确的且相关的。然而，它包含一个错误的特定定量声明。在给定的选择中，它是最合理的。\n\n**B. 保持得分不变，但将动态规划中的每一次最大化替换为最小化，以获得最差比对；对于任何评分方案，其结果目标都等于 Levenshtein 编辑距离，因此通常定义了一个满足三角不等式的度量。**\n\n-   **过程：** 如推导所示，在递推式中用 `min` 替换 `max` 是计算最小得分的有效方法。过程部分是正确的。\n-   **解释：** 解释完全错误。Levenshtein 距离对应于一种非常特定的评分方案（例如，错配罚分1，插入缺失罚分1，匹配得分0），用于计算编辑操作数。问题中描述的通用评分方案（$s(a,a)>0$ 等）不会产生 Levenshtein 距离。因此，声称结果是满足三角不等式的度量的说法没有根据，并且对于通用评分函数是不正确的。\n-   **结论：** 不正确。虽然过程有效，但解释存在根本性缺陷。\n\n**C. 只对匹配得分 $s(a,a)$ 取反，而保持错配和罚分不变，然后用 Needleman–Wunsch (NW) 进行最大化；所得的值近似于 $S$ 和 $T$ 的氨基酸组成之间的 Kullback–Leibler 散度，从而量化了组成水平上的不相似性。**\n\n-   **过程：** 仅对匹配得分取反的过程定义了一个新的目标函数，它不等同于最小化原始得分。例如，最小化 $A+B$ 并非通过最大化 $-A+B$ 来实现。这个过程不能解决所述问题。\n-   **解释：** 解释也是不正确的。一个比对得分，对字符顺序敏感，与氨基酸组成之间的 Kullback–Leibler 散度没有直接关系，后者是衡量频率分布差异的度量，对顺序不敏感。\n-   **结论：** 不正确。过程和解释都有缺陷。\n\n**D. 保持原始得分并仍然执行最大化，但强制动态规划在每个递归步骤中选择局部最差的选项；所得的目标提供了 $S$ 和 $T$ 之间突变数量的一个上界，且该上界与评分参数的选择无关。**\n\n-   **过程：** 这描述了对动态规划算法的一个无意义的修改。最优性原理是动态规划的基础，它要求在每一步做出相对于子问题最优解的最优选择。做出“局部最差”选择打破了这一原理，并不能保证找到任何全局最优解（无论是最大值还是最小值）。该过程定义不明确且不正确，无法解决问题。\n-   **解释：** 解释毫无根据。这种被破坏的算法的输出没有明确的意义。声称它提供了突变数量的上界并且与评分参数无关的说法，从表面上看就是错误的，因为该过程明确使用了得分。\n-   **结论：** 不正确。所提出的过程不是一个有效的算法，其解释也毫无意义。\n\n### 结论\n选项 A 提供了一个正确的算法过程。它的解释正确地指出了最小得分的意义，即作为反对同源性的最强证据。它包含一个不准确的定量陈述，但其总体描述远优于选项 B、C 和 D，后三者在过程、解释或两者上都存在根本性错误。因此，选项 A 是可用的最准确描述。", "answer": "$$\\boxed{A}$$", "id": "2395055"}, {"introduction": "这项综合性实践将理论付诸代码，是本章学习的顶点。它要求我们实现一个更真实、更强大的全局比对算法，该算法使用仿射罚分（affine gap penalty）模型，能更好地区分新开口的缺口（gap open）和延伸的缺口（gap extend）。更重要的是，练习的后半部分将我们置于真实科研场景中：使用统计学方法（$Z$-score）来评估比对分数的显著性，判断观测到的相似性究竟是源于生物学功能，还是仅仅是随机巧合。[@problem_id:2395091]", "problem": "给定两个由脱氧核糖核酸 (DNA) 字母表 $\\Sigma = \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 构成的有限字符串 $s$ 和 $t$。$s$ 和 $t$ 的一个比对是通过向 $s$ 和 $t$ 中插入空格符号 $-$（不重排原始符号）得到的，使得最终生成的字符串 $\\hat{s}$ 和 $\\hat{t}$ 长度相等（设为 $L$），并且对于每个 $k \\in \\{1,\\dots,L\\}$，$\\hat{s}_k$ 和 $\\hat{t}_k$ 中至少有一个字符属于 $\\Sigma$。一个比对的得分定义为替换得分与仿射空位罚分之和。替换得分由一个函数 $\\sigma: \\Sigma \\times \\Sigma \\to \\mathbb{R}$ 给出，定义为：如果 $x=y$，则 $\\sigma(x,y)=m$；如果 $x \\neq y$，则 $\\sigma(x,y)=u$。仿射空位罚分的定义是：在 $\\hat{s}$ 或 $\\hat{t}$ 中，每一个长度为 $l \\in \\mathbb{N}$ 的最大连续空格段都会产生一笔 $g_{\\text{open}} + g_{\\text{extend}} \\cdot l$ 的罚分。总比对得分是所有 $\\hat{s}_k, \\hat{t}_k \\in \\Sigma$ 位置上替换得分的总和，加上所有空格段罚分的总和。最优全局比对得分 $S^\\star(s,t)$ 是 $s$ 和 $t$ 所有可能比对中的最高得分。\n\n对于一个固定的字符串对 $(s,t)$，定义如下的随机化分析。固定一个正整数 $K$ 和一个非负整数种子 $z$。考虑 $K$ 个独立的随机字符串 $t^{(1)},\\dots,t^{(K)}$，每个字符串都是通过对 $t$ 的字符多重集应用一次均匀随机置换而得到的。此过程使用一个由 $z$ 确定性初始化的伪随机数生成器，以确保结果的可复现性。对于每个 $k \\in \\{1,\\dots,K\\}$，计算最优全局比对得分 $S^\\star\\!\\left(s,t^{(k)}\\right)$。令 $\\mu$ 表示算术平均值\n$$\n\\mu = \\frac{1}{K}\\sum_{k=1}^{K} S^\\star\\!\\left(s,t^{(k)}\\right),\n$$\n并令总体标准差为\n$$\n\\sigma_{\\text{pop}} = \\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\left(S^\\star\\!\\left(s,t^{(k)}\\right)-\\mu\\right)^2}.\n$$\n将原始字符串对的 $Z$-分数定义为\n$$\nZ=\\begin{cases}\n\\dfrac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}, & \\text{当 }\\sigma_{\\text{pop}} > 0 \\\\\n0, & \\text{当 }\\sigma_{\\text{pop}} = 0\n\\end{cases}\n$$\n\n您的任务是编写一个完整的程序，该程序需对下述每个指定的测试用例，根据以上定义并使用所提供的精确参数，计算四元组 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$。对于所有测试，请使用相同的评分方案，$m=2$，$u=-1$，$g_{\\text{open}}=-2$，以及 $g_{\\text{extend}}=-1$。对于每个测试，请使用指定的 $K$ 和种子 $z$ 来生成 $t$ 的 $K$ 个置换副本。\n\n测试套件：\n- 用例 1：$s=\\text{\"ACGTCG\"}$，$t=\\text{\"ACTCG\"}$，$K=200$，$z=314159$。\n- 用例 2：$s=\\text{\"AAAAAA\"}$，$t=\\text{\"AAA\"}$，$K=200$，$z=271828$。\n- 用例 3：$s=\\text{\"GATTACA\"}$，$t=\\text{\"GATTACA\"}$，$K=200$，$z=161803$。\n- 用例 4：$s=\\text{\"\"}$（空字符串），$t=\\text{\"ACGT\"}$，$K=200$，$z=42$。\n\n答案规格：\n- 对于每个用例，将 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$ 计算为一组实数。\n- 使用标准舍入规则将每个实数保留到 $6$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个由列表组成的列表，以逗号分隔。每个测试用例对应一个子列表，每个子列表按 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$ 的顺序排列，并用方括号括起来。例如，一个有效的输出格式为 $\\left[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],\\dots\\right]$，不含任何额外文本。", "solution": "问题陈述已通过验证。\n\n### 步骤 1：提取已知信息\n\n- **字符串**：两个有限字符串 $s$ 和 $t$，字母表为 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。\n- **比对定义**：向 $s$ 和 $t$ 中插入空格符号（$-$），形成长度相等的字符串 $\\hat{s}$ 和 $\\hat{t}$，长度为 $L$。在任意位置 $k$，$\\hat{s}_k$ 或 $\\hat{t}_k$ 中至少有一个不是空格。\n- **计分方案**：\n    - **替换得分**：若 $x=y$，$\\sigma(x,y)=m$；若 $x \\neq y$，$\\sigma(x,y)=u$。\n    - **仿射空位罚分**：一个长度为 $l$ 的最大连续空格段产生罚分 $g_{\\text{open}}+g_{\\text{extend}}\\cdot l$。\n    - **总得分**：替换得分与空位罚分之和。\n- **最优得分**：$S^\\star(s,t)$ 是可能的最大比对得分。\n- **随机化分析**：\n    - 一个固定的正整数 $K$ 和一个非负整数种子 $z$。\n    - 通过对 $t$ 的字符进行均匀随机置换，生成 $K$ 个随机字符串 $t^{(k)}$。\n    - **平均分**：$\\mu=\\frac{1}{K}\\sum_{k=1}^{K} S^\\star\\!\\left(s,t^{(k)}\\right)$。\n    - **总体标准差**：$\\sigma_{\\text{pop}}=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\left(S^\\star\\!\\left(s,t^{(k)}\\right)-\\mu\\right)^2}$。\n    - **Z-分数**：若 $\\sigma_{\\text{pop}}>0$，则 $Z=\\frac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}$；若 $\\sigma_{\\text{pop}}=0$，则 $Z=0$。\n- **任务参数**：\n    - **计分常数**：$m=2$，$u=-1$，$g_{\\text{open}}=-2$，$g_{\\text{extend}}=-1$。\n- **测试套件**：\n    - 用例 1：$s=\\text{\"ACGTCG\"}$，$t=\\text{\"ACTCG\"}$，$K=200$，$z=314159$。\n    - 用例 2：$s=\\text{\"AAAAAA\"}$，$t=\\text{\"AAA\"}$，$K=200$，$z=271828$。\n    - 用例 3：$s=\\text{\"GATTACA\"}$，$t=\\text{\"GATTACA\"}$，$K=200$，$z=161803$。\n    - 用例 4：$s=\\text{\"\"}$，$t=\\text{\"ACGT\"}$，$K=200$，$z=42$。\n- **输出规格**：对于每个测试用例，计算四元组 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$，每个值四舍五入到 6 位小数。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n- **科学依据**：该问题描述了使用仿射空位罚分模型计算最优全局比对得分的过程。这是生物信息学中一个标准的、基础性的问题，可以通过一个成熟的动态规划算法——Needleman-Wunsch 算法的一个变体来解决。后续使用 z-分数（通过与置换序列的背景分布进行比较计算得出）进行统计分析，是评估比对生物学显著性的标准方法。该问题在科学上是合理的。\n- **良态问题**：该问题是良态的。仿射空位罚分的动态规划算法能够给出一个唯一的最优得分。使用由特定种子初始化的确定性伪随机数生成器，确保了置换序列的生成是可复现的，从而为 $\\mu$、$\\sigma_{\\text{pop}}$ 和 $Z$ 得到唯一的一组值。\n- **客观性**：该问题在数学和算法上都给出了精确的定义。所有术语都有明确的定义，所有参数也都已提供。不存在主观性或模糊性。\n- **完整性与一致性**：该问题是自洽的。所有必要的数据，包括字符串、计分参数（$m, u, g_{\\text{open}}, g_{\\text{extend}}$）和统计参数（$K, z$），都为每个测试用例提供了。不存在矛盾。\n\n### 步骤 3：结论与行动\n该问题有效。它有科学根据，是良态的、客观且完整的。可以计算出确定的解。\n\n---\n\n### 解题思路\n\n解决此问题需要两个部分：首先，一个用于计算两条带有仿射空位罚分的序列之间最优全局比对得分的算法；其次，一个用于评估该得分显著性的统计框架。\n\n**1. 带仿射空位罚分的最优全局比对**\n\n最优比对得分 $S^\\star(s,t)$ 的计算是一个经典的动态规划问题。仿射空位罚分区分了打开一个空位（$g_{\\text{open}}$）和延伸一个空位（$g_{\\text{extend}}$），因此需要比简单的线性空位罚分模型更复杂的状态空间。我们使用三个大小为 $(|s|+1) \\times (|t|+1)$ 的动态规划矩阵：$M$、$I_x$ 和 $I_y$。设 $s_i$ 为 $s$ 的第 $i$ 个字符，$t_j$ 为 $t$ 的第 $j$ 个字符。\n\n对于 $i \\in \\{1,\\dots,|s|\\}$ 和 $j \\in \\{1,\\dots,|t|\\}$，这些矩阵定义如下：\n- $M(i,j)$：前缀 $s[1..i]$ 和 $t[1..j]$ 的最优比对得分，其中 $s_i$ 与 $t_j$ 对齐。\n- $I_x(i,j)$：前缀 $s[1..i]$ 和 $t[1..j]$ 的最优比对得分，其中 $s_i$ 与一个空位对齐。\n- $I_y(i,j)$：前缀 $s[1..i]$ 和 $t[1..j]$ 的最优比对得分，其中 $t_j$ 与一个空位对齐。\n\n这些矩阵使用以下递推关系进行填充：\n\n$$\nM(i,j) = \\sigma(s_i, t_j) + \\max \\begin{cases} M(i-1, j-1) \\\\ I_x(i-1, j-1) \\\\ I_y(i-1, j-1) \\end{cases}\n$$\n该递推关系表明，对齐字符 $s_i$ 和 $t_j$（得分为 $\\sigma(s_i, t_j)$）可以跟在一个以匹配/错配（$M$）、$t$ 中的空位（$I_x$）或 $s$ 中的空位（$I_y$）结尾的比对之后。\n\n$$\nI_x(i,j) = \\max \\begin{cases} M(i-1, j) + g_{\\text{open}} + g_{\\text{extend}} & \\text{（在 } t \\text{ 中打开空位）} \\\\ I_x(i-1, j) + g_{\\text{extend}} & \\text{（在 } t \\text{ 中延伸空位）} \\end{cases}\n$$\n这捕捉了将 $s_i$ 与空位对齐的得分。这个状态可以通过在 $t$ 中打开一个新空位（从一个以匹配/错配结尾的比对转移而来）或延伸 $t$ 中的一个现有空位来到达。\n\n$$\nI_y(i,j) = \\max \\begin{cases} M(i, j-1) + g_{\\text{open}} + g_{\\text{extend}} & \\text{（在 } s \\text{ 中打开空位）} \\\\ I_y(i, j-1) + g_{\\text{extend}} & \\text{（在 } s \\text{ 中延伸空位）} \\end{cases}\n$$\n这与 $I_x(i,j)$ 对称，表示将 $t_j$ 与空位对齐的得分。\n\n矩阵的初始化条件至关重要：\n- 基准情况：$M(0,0) = 0$。$M$ 矩阵第 0 行和第 0 列中的所有其他条目都设置为 $-\\infty$，以禁止以匹配/错配开始的比对。\n- 初始空位：将一个字符串的前缀与空字符串进行比对。\n  - 对于 $i > 0$，$I_x(i,0) = g_{\\text{open}} + i \\cdot g_{\\text{extend}}$。对于 $i=0$ 或 $j=0$ 的其他 $I_x(i,j)$ 均为 $-\\infty$。\n  - 对于 $j > 0$，$I_y(0,j) = g_{\\text{open}} + j \\cdot g_{\\text{extend}}$。对于 $i=0$ 或 $j=0$ 的其他 $I_y(i,j)$ 均为 $-\\infty$。\n\n填完矩阵后，对于长度为 $n = |s|$ 和 $m = |t|$ 的字符串 $s$ 和 $t$，其最优全局比对得分是三种可能的最终状态中的最大值：\n\n$$\nS^\\star(s,t) = \\max \\{ M(n,m), I_x(n,m), I_y(n,m) \\}\n$$\n\n给定的参数为 $m=2$，$u=-1$，$g_{\\text{open}}=-2$，以及 $g_{\\text{extend}}=-1$。\n\n**2. 统计显著性分析**\n\n为了评估得分 $S^\\star(s,t)$ 是否显著高，需要将其与一系列由 $s$ 和随机序列比对得到的得分的背景分布进行比较。这些随机序列 $t^{(k)}$（其中 $k=1,\\dots,K$）是通过对原始字符串 $t$ 的字符进行随机置换生成的。这保留了 $t$ 的长度和字符构成，这两者是比对得分的重要决定因素。对伪随机数生成器使用固定的种子 $z$ 可以确保此过程是确定性和可复现的。\n\n对于 $K$ 个置换后的字符串 $t^{(k)}$ 中的每一个，我们使用上述算法计算最优比对得分 $S^\\star(s,t^{(k)})$。从这 $K$ 个得分的集合中，我们计算两个统计量：\n\n- 算术平均值：$\\mu = \\frac{1}{K}\\sum_{k=1}^{K} S^\\star(s,t^{(k)})$。\n- 总体标准差：$\\sigma_{\\text{pop}} = \\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}(S^\\star(s,t^{(k)}) - \\mu)^2}$。\n\n最后，计算 z-分数 $Z$。它衡量了原始得分 $S^\\star(s,t)$ 与置换序列得分均值之间相差多少个标准差。\n\n$$\nZ=\\begin{cases}\n\\dfrac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}, & \\text{当 }\\sigma_{\\text{pop}} > 0, \\\\\n0, & \\text{当 }\\sigma_{\\text{pop}} = 0.\n\\end{cases}\n$$\n当所有置换序列产生完全相同的比对得分时，会出现 $\\sigma_{\\text{pop}}=0$ 的情况，这使得基于标准差的比较变得没有意义。\n\n程序将在一个函数中实现动态规划算法。该函数将对原始字符串对 $(s,t)$ 调用一次，然后对 $(s, t^{(k)})$ 调用 $K$ 次。收集结果以计算最终的四元组 $[[S^\\star(s,t), \\mu, \\sigma_{\\text{pop}}, Z]]$，其中每个元素都四舍五入到 6 位小数。", "answer": "```python\nimport numpy as np\n\ndef compute_optimal_score(s: str, t: str, match: float, mismatch: float, gap_open: float, gap_extend: float) -> float:\n    \"\"\"\n    Computes the optimal global alignment score with affine gap penalties.\n    \"\"\"\n    n = len(s)\n    m = len(t)\n    \n    if n == 0 and m == 0:\n        return 0.0\n    if n == 0:\n        return gap_open + m * gap_extend\n    if m == 0:\n        return gap_open + n * gap_extend\n\n    neg_inf = -np.inf\n\n    # Initialization of DP matrices\n    M = np.full((n + 1, m + 1), neg_inf, dtype=float)\n    Ix = np.full((n + 1, m + 1), neg_inf, dtype=float)\n    Iy = np.full((n + 1, m + 1), neg_inf, dtype=float)\n\n    M[0, 0] = 0.0\n\n    for i in range(1, n + 1):\n        Ix[i, 0] = gap_open + i * gap_extend\n    for j in range(1, m + 1):\n        Iy[0, j] = gap_open + j * gap_extend\n\n    # Fill DP matrices\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # Substitution score\n            sub_score = match if s[i-1] == t[j-1] else mismatch\n            \n            # M(i,j) - alignment ends with s[i-1] vs t[j-1]\n            prev_m = M[i-1, j-1]\n            prev_ix = Ix[i-1, j-1]\n            prev_iy = Iy[i-1, j-1]\n            M[i, j] = sub_score + max(prev_m, prev_ix, prev_iy)\n\n            # Ix(i,j) - alignment ends with s[i-1] vs gap\n            open_gap_x = M[i-1, j] + gap_open + gap_extend\n            extend_gap_x = Ix[i-1, j] + gap_extend\n            Ix[i, j] = max(open_gap_x, extend_gap_x)\n            \n            # Iy(i,j) - alignment ends with gap vs t[j-1]\n            open_gap_y = M[i, j-1] + gap_open + gap_extend\n            extend_gap_y = Iy[i, j-1] + gap_extend\n            Iy[i, j] = max(open_gap_y, extend_gap_y)\n\n    # Final score is the max of the three states at the bottom-right corner\n    final_score = max(M[n, m], Ix[n, m], Iy[n, m])\n    return final_score\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\"s\": \"ACGTCG\", \"t\": \"ACTCG\", \"K\": 200, \"z\": 314159},\n        {\"s\": \"AAAAAA\", \"t\": \"AAA\", \"K\": 200, \"z\": 271828},\n        {\"s\": \"GATTACA\", \"t\": \"GATTACA\", \"K\": 200, \"z\": 161803},\n        {\"s\": \"\", \"t\": \"ACGT\", \"K\": 200, \"z\": 42},\n    ]\n\n    # Scoring parameters\n    m_score = 2.0\n    u_score = -1.0\n    g_open = -2.0\n    g_extend = -1.0\n    \n    all_results = []\n\n    for case in test_cases:\n        s, t, K, z = case[\"s\"], case[\"t\"], case[\"K\"], case[\"z\"]\n\n        # 1. Compute score for the original pair (s, t)\n        original_score = compute_optimal_score(s, t, m_score, u_score, g_open, g_extend)\n\n        # 2. Generate K shuffled sequences and compute their scores\n        rng = np.random.default_rng(z)\n        t_chars = list(t)\n        shuffled_scores = []\n        if len(t_chars) > 0:\n            for _ in range(K):\n                shuffled_t_chars = rng.permutation(t_chars)\n                shuffled_t = \"\".join(shuffled_t_chars)\n                score = compute_optimal_score(s, shuffled_t, m_score, u_score, g_open, g_extend)\n                shuffled_scores.append(score)\n        else: # If t is empty, all \"shuffled\" versions are also empty\n             shuffled_scores = [original_score] * K\n\n\n        shuffled_scores = np.array(shuffled_scores)\n\n        # 3. Compute statistics\n        mu = np.mean(shuffled_scores)\n        sigma_pop = np.std(shuffled_scores, ddof=0) # Population standard deviation\n\n        # 4. Compute Z-score\n        if sigma_pop > 0:\n            z_score = (original_score - mu) / sigma_pop\n        else:\n            z_score = 0.0\n\n        # 5. Round results and append\n        rounded_results = [\n            round(original_score, 6),\n            round(mu, 6),\n            round(sigma_pop, 6),\n            round(z_score, 6)\n        ]\n        all_results.append(rounded_results)\n\n    # Format and print the final output\n    # e.g., [[-1.23, 2.34, 3.45, 4.56],[...]]\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2395091"}]}