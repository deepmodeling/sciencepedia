{"hands_on_practices": [{"introduction": "理解序列比对的第一步是掌握其评分机制。本练习将作为一个基础热身，通过一个简单的评分方案——包括对匹配、错配和缺口的指定分数——来评估一个给定的肽序列比对。通过手动计算总分，你将具体地理解这些基本元素是如何结合起来量化序列相似性的，为后续更复杂的模型打下坚实基础。[@problem_id:2136319]", "problem": "在生物信息学中，序列比对是一种用于比较两个或多个生物序列的基本方法。比对的质量通常通过一个评分系统来量化。考虑以下两个短肽序列的带空位比对，它们使用标准的单字母氨基酸代码表示。一个连字符（`-`）用于表示一个空位。\n\n序列1: `M A V L I S Q R T V K`\n序列2: `M G V L - S R Q T - K`\n\n采用一个简单的评分方案来评估此比对。规则如下：\n- 匹配，即一列中的氨基酸相同时，得分为 `+5`。\n- 错配，即一列中的氨基酸不同时，得分为 `-3`。\n- 空位，即一个氨基酸与一个空位字符（`-`）对齐时，产生 `-8` 的罚分。\n\n根据此评分方案，计算给定的双序列比对的总比对分数。", "solution": "要计算总比对分数，我们需要逐列分析比对，并根据提供的评分方案将每个位置的分数相加。\n\n给定的比对是：\n序列1: `M A V L I S Q R T V K`\n序列2: `M G V L - S R Q T - K`\n\n评分规则是：\n- 匹配分数 = `+5`\n- 错配分数 = `-3`\n- 空位罚分 = `-8`\n\n让我们遍历比对的11列，并确定每个位置的比对类型（匹配、错配或空位）。\n\n1.  位置1：`M` vs `M`。这是一个**匹配**。\n2.  位置2：`A` vs `G`。这是一个**错配**。\n3.  位置3：`V` vs `V`。这是一个**匹配**。\n4.  位置4：`L` vs `L`。这是一个**匹配**。\n5.  位置5：`I` vs `-`。这是一个**空位**。\n6.  位置6：`S` vs `S`。这是一个**匹配**。\n7.  位置7：`Q` vs `R`。这是一个**错配**。\n8.  位置8：`R` vs `Q`。这是一个**错配**。\n9.  位置9：`T` vs `T`。这是一个**匹配**。\n10. 位置10：`V` vs `-`。这是一个**空位**。\n11. 位置11：`K` vs `K`。这是一个**匹配**。\n\n接下来，我们统计匹配、错配和空位的总数。\n-   匹配数 = 6（在位置 1, 3, 4, 6, 9, 11）\n-   错配数 = 3（在位置 2, 7, 8）\n-   空位数 = 2（在位置 5, 10）\n\n现在，我们通过将不同类型的数量乘以它们各自的分数然后求和来计算总分。\n\n总分 = (匹配数 * 匹配分数) + (错配数 * 错配分数) + (空位数 * 空位罚分)\n\n代入数值：\n总分 = $(6 \\times 5) + (3 \\times (-3)) + (2 \\times (-8))$\n总分 = $30 - 9 - 16$\n总分 = $21 - 16$\n总分 = $5$\n\n因此，给定比对的总比对分数为5。", "answer": "$$\\boxed{5}$$", "id": "2136319"}, {"introduction": "匹配和错配的分数从何而来？这个练习将带你深入探讨现代评分矩阵（如 BLOSUM）的核心原理。你将使用一个简化的氨基酸字母表，根据经验观测数据计算对数奇比分（log-odds scores）。这个过程揭示了评分方案背后的统计学基础，即比较一个氨基酸替换在相关序列中发生的频率与在随机序列中偶然发生的频率，从而科学地量化进化关系。[@problem_id:2371031]", "problem": "给定一个简化的残基字母表，其中包含两个物理化学类别：疏水性（$\\mathrm{H}$）和极性（$\\mathrm{P}$）。从一个精选的同源蛋白质序列比对数据集中，在 $N$ 个比对位置上观察到以下有序比对对的计数：$\\mathrm{H}$–$\\mathrm{H}$ 对：$2800$，$ \\mathrm{H}$–$\\mathrm{P}$ 对：$1200$，$ \\mathrm{P}$–$\\mathrm{H}$ 对：$1200$，以及 $\\mathrm{P}$–$\\mathrm{P}$ 对：$4800$，其中 $N = 2800 + 1200 + 1200 + 4800$。另外，根据一个大型非冗余蛋白质数据库估计的背景组成给出 $\\Pr(\\mathrm{H}) = 0.40$ 和 $\\Pr(\\mathrm{P}) = 0.60$。\n\n根据定义，比对对 $(a,b)$ 的对数奇数替换分数（log-odds substitution score）为 $s(a,b) = \\ln\\!\\big(q_{ab} / (p_{a} p_{b})\\big)$，其中 $q_{ab}$ 是在同源比对中观察到有序比对对 $(a,b)$ 的联合概率，而 $p_{a}$ 是残基类别 $a$ 的背景概率。在计算中使用自然对数 $\\ln(\\cdot)$。\n\n计算对数奇数分数 $s(\\mathrm{H},\\mathrm{H})$、$s(\\mathrm{H},\\mathrm{P})$、$s(\\mathrm{P},\\mathrm{H})$ 和 $s(\\mathrm{P},\\mathrm{P})$。将最终数值分数按 $s(\\mathrm{H},\\mathrm{H})$、$s(\\mathrm{H},\\mathrm{P})$、$s(\\mathrm{P},\\mathrm{H})$、$s(\\mathrm{P},\\mathrm{P})$ 的顺序以单行矩阵的形式报告，并将每个条目四舍五入到四位有效数字。", "solution": "该问题要求计算一个简化的双字符字母表 {$\\mathrm{H}$, $\\mathrm{P}$} 的对数奇数替换分数，其中 $\\mathrm{H}$ 代表疏水性残基，$\\mathrm{P}$ 代表极性残基。\n\n首先，确定问题陈述的有效性。所有必要数据均已提供，定义清晰且为生物信息学领域的标准，问题在科学上是合理的并且是适定的。没有矛盾或含糊之处。\n\n一个残基比对对 $(a,b)$ 的对数奇数分数 $s(a,b)$ 定义为：\n$$s(a,b) = \\ln\\left( \\frac{q_{ab}}{p_{a} p_{b}} \\right)$$\n其中，$q_{ab}$ 是在同源序列比对中观察到有序对 $(a,b)$ 的目标频率，$p_a$ 和 $p_b$ 分别是在一个大型通用蛋白质数据库中观察到残基 $a$ 和 $b$ 的背景频率。\n\n给定的数据是：\n- 比对对的观察计数：\n  - $C(\\mathrm{H},\\mathrm{H}) = 2800$\n  - $C(\\mathrm{H},\\mathrm{P}) = 1200$\n  - $C(\\mathrm{P},\\mathrm{H}) = 1200$\n  - $C(\\mathrm{P},\\mathrm{P}) = 4800$\n- 背景概率：\n  - $p_{\\mathrm{H}} = 0.40$\n  - $p_{\\mathrm{P}} = 0.60$\n\n第一步是根据给定的计数计算比对位置的总数 $N$。\n$$N = C(\\mathrm{H},\\mathrm{H}) + C(\\mathrm{H},\\mathrm{P}) + C(\\mathrm{P},\\mathrm{H}) + C(\\mathrm{P},\\mathrm{P})$$\n$$N = 2800 + 1200 + 1200 + 4800 = 10000$$\n\n接下来，我们通过将每对的观察计数除以总位置数 $N$ 来计算目标频率 $q_{ab}$。\n$$q_{\\mathrm{HH}} = \\frac{C(\\mathrm{H},\\mathrm{H})}{N} = \\frac{2800}{10000} = 0.28$$\n$$q_{\\mathrm{HP}} = \\frac{C(\\mathrm{H},\\mathrm{P})}{N} = \\frac{1200}{10000} = 0.12$$\n$$q_{\\mathrm{PH}} = \\frac{C(\\mathrm{P},\\mathrm{H})}{N} = \\frac{1200}{10000} = 0.12$$\n$$q_{\\mathrm{PP}} = \\frac{C(\\mathrm{P},\\mathrm{P})}{N} = \\frac{4800}{10000} = 0.48$$\n\n现在，我们根据背景概率计算每对的期望频率 $p_a p_b$。这些代表了随机情况下预期的频率。\n$$p_{\\mathrm{H}} p_{\\mathrm{H}} = (0.40)(0.40) = 0.16$$\n$$p_{\\mathrm{H}} p_{\\mathrm{P}} = (0.40)(0.60) = 0.24$$\n$$p_{\\mathrm{P}} p_{\\mathrm{H}} = (0.60)(0.40) = 0.24$$\n$$p_{\\mathrm{P}} p_{\\mathrm{P}} = (0.60)(0.60) = 0.36$$\n\n在计算出所有分量后，我们可以确定每对的对数奇数分数。按照规定，使用自然对数 $\\ln(\\cdot)$。\n\n对于 H–H 对：\n$$s(\\mathrm{H},\\mathrm{H}) = \\ln\\left( \\frac{q_{\\mathrm{HH}}}{p_{\\mathrm{H}} p_{\\mathrm{H}}} \\right) = \\ln\\left( \\frac{0.28}{0.16} \\right) = \\ln(1.75)$$\n$$s(\\mathrm{H},\\mathrm{H}) \\approx 0.5596157...$$\n四舍五入到四位有效数字，$s(\\mathrm{H},\\mathrm{H}) \\approx 0.5596$。正分表示该配对在同源比对中出现的频率高于随机预期的频率，表明这是一种有利的替换。\n\n对于 H–P 对：\n$$s(\\mathrm{H},\\mathrm{P}) = \\ln\\left( \\frac{q_{\\mathrm{HP}}}{p_{\\mathrm{H}} p_{\\mathrm{P}}} \\right) = \\ln\\left( \\frac{0.12}{0.24} \\right) = \\ln(0.5)$$\n$$s(\\mathrm{H},\\mathrm{P}) \\approx -0.6931471...$$\n四舍五入到四位有效数字，$s(\\mathrm{H},\\mathrm{P}) \\approx -0.6931$。负分表示该配对是不利的。\n\n对于 P–H 对：\n$$s(\\mathrm{P},\\mathrm{H}) = \\ln\\left( \\frac{q_{\\mathrm{PH}}}{p_{\\mathrm{P}} p_{\\mathrm{H}}} \\right) = \\ln\\left( \\frac{0.12}{0.24} \\right) = \\ln(0.5)$$\n$$s(\\mathrm{P},\\mathrm{H}) \\approx -0.6931471...$$\n四舍五入到四位有效数字，$s(\\mathrm{P},\\mathrm{H}) \\approx -0.6931$。正如预期的那样，这与 $s(\\mathrm{H},\\mathrm{P})$ 相同，因为基础计数和背景概率是对称的。\n\n对于 P–P 对：\n$$s(\\mathrm{P},\\mathrm{P}) = \\ln\\left( \\frac{q_{\\mathrm{PP}}}{p_{\\mathrm{P}} p_{\\mathrm{P}}} \\right) = \\ln\\left( \\frac{0.48}{0.36} \\right) = \\ln\\left( \\frac{4}{3} \\right)$$\n$$s(\\mathrm{P},\\mathrm{P}) \\approx 0.2876820...$$\n四舍五入到四位有效数字，$s(\\mathrm{P},\\mathrm{P}) \\approx 0.2877$。这个正分表示这是一个有利的配对。\n\n计算出的分数，四舍五入到四位有效数字，分别为 $s(\\mathrm{H},\\mathrm{H}) = 0.5596$，$s(\\mathrm{H},\\mathrm{P}) = -0.6931$，$s(\\mathrm{P},\\mathrm{H}) = -0.6931$ 和 $s(\\mathrm{P},\\mathrm{P}) = 0.2877$。\n问题要求按此特定顺序将这些值以单行矩阵的形式报告。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.5596 & -0.6931 & -0.6931 & 0.2877\n\\end{pmatrix}\n}\n$$", "id": "2371031"}, {"introduction": "在真实的生物学情境中，插入和缺失（即缺口）在序列中的影响并非一成不变。本练习引入了一种更高级的评分模型：仿射缺口罚分（affine gap penalty），其成本会根据缺口所破坏的蛋白质二级结构（如α-螺旋或β-折叠）而变化。通过解决这个问题，你将探索如何将生物学背景知识整合到评分方案中，以创建出更精确、更能反映生物学现实的比对。[@problem_id:2371017]", "problem": "给定两条蛋白质序列，以及每个位置上使用字母表 $\\{H,E,C\\}$ 的预测二级结构的分类注释，其中 $H$ 表示α-螺旋，$E$ 表示β-折叠，$C$ 表示无规卷曲。将两条序列之间的全局比对定义为一个列的序列，每一列要么是一对残基 $(x_i,y_j)$，要么是一个残基与一个空位符号对齐。总比对分数是所有列的分数之和，每个列的分数由一个残基-残基替换贡献加上一个适用的空位贡献确定，具体如下。\n\n- 替换打分：对于任何一对残基 $(a,b)$，其替换贡献 $S(a,b)$ 定义为\n  - 如果 $a=b$，则 $S(a,b)=+2$。\n  - 如果 $a\\neq b$，则 $S(a,b)=-1$。\n- 带有二级结构依赖的仿射罚分的空位打分：对于比对中任意一个最大连续的 $k$ 列，其中一个序列有空位符号与另一序列的残基 $r_1,\\dots,r_k$ 对齐，其对应的预测二级结构为 $s_1,\\dots,s_k\\in\\{H,E,C\\}$，这 $k$ 个空位列对比对分数的总贡献为\n$$-\\bigl(g_o(s_1)+\\sum_{t=1}^{k} g_e(s_t)\\bigr).$$\n  此处，$g_o(s)$ 是结构 $s$ 的空位开放成本，$g_e(s)$ 是结构 $s$ 的空位延伸成本。成本参数为：\n  - $g_o(H)=6$，$g_e(H)=2$，\n  - $g_o(E)=9$，$g_e(E)=3$，\n  - $g_o(C)=4$，$g_e(C)=1$。\n\n给定此打分模型，对于下方的每个测试用例，计算最优全局比对分数，该分数定义为所有可能比对中的最大总比对分数。\n\n测试套件（每个用例指定一个序列及其等长的二级结构字符串）：\n- 用例 $1$：\n  - $x=$ \"ACDE\"，$x$ 的二级结构字符串：\"HEEC\"。\n  - $y=$ \"ACDF\"，$y$ 的二级结构字符串：\"HEEC\"。\n- 用例 $2$：\n  - $x=$ \"VVV\"，$x$ 的二级结构字符串：\"EEE\"。\n  - $y=$ \"VVVV\"，$y$ 的二级结构字符串：\"EEEE\"。\n- 用例 $3$：\n  - $x=$ \"ABCD\"，$x$ 的二级结构字符串：\"CCCC\"。\n  - $y=$ \"ABXCD\"，$y$ 的二级结构字符串：\"CCCCC\"。\n- 用例 $4$（与空序列的边界情况）：\n  - $x=$ \"\"，$x$ 的二级结构字符串：\"\"。\n  - $y=$ \"M\"，$y$ 的二级结构字符串：\"H\"。\n- 用例 $5$（混合结构以及具有不同结构的多次空位）：\n  - $x=$ \"ABC\"，$x$ 的二级结构字符串：\"HEC\"。\n  - $y=$ \"AXYBC\"，$y$ 的二级结构字符串：\"HCEEC\"。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的整数列表，用方括号括起来，按用例 $1$ 到 $5$ 的顺序排列，例如，“[score1,score2,score3,score4,score5]”。", "solution": "所提出的问题是计算两条蛋白质序列之间的最优全局比对分数，给定一个特定的打分模型，该模型将二级结构信息整合到一个仿射空位罚分方案中。这个问题是序列比对的一个明确定义的实例，这是计算生物学中的一个基本任务。它在科学上是合理的，内部是一致的，并包含了所有必要的信息。因此，这是一个有效的问题，可以用严谨的数学方法来解决。\n\n解决方案是使用动态规划，它提供了一种系统性的方法来探索所有可能比对的巨大空间，并找出一个具有最大分数的比对。特定的打分模型，即成本依赖于局部二级结构的仿射空位罚分，需要对经典的Needleman-Wunsch算法进行扩展。我们使用三个动态规划矩阵，分别表示为 $M$、$I_x$ 和 $I_y$。\n\n设两条序列为长度为 $m$ 的 $x = x_1x_2...x_m$ 和长度为 $n$ 的 $y = y_1y_2...y_n$。设它们对应的二级结构注释为 $ss_x$ 和 $ss_y$。DP矩阵的大小为 $(m+1) \\times (n+1)$。对于 $0 \\le i \\le m$ 和 $0 \\le j \\le n$，它们的条目定义如下：\n- $M(i, j)$: 前缀 $x_1...x_i$ 和 $y_1...y_j$ 比对的最大分数，其中最后一列是匹配或错配，即 $(x_i, y_j)$。\n- $I_x(i, j)$: $x_1...x_i$ 和 $y_1...y_j$ 比对的最大分数，其中最后一列是序列 $y$ 中的空位，即 $(x_i, -)$。\n- $I_y(i, j)$: $x_1...x_i$ 和 $y_1...y_j$ 比对的最大分数，其中最后一列是序列 $x$ 中的空位，即 $(-, y_j)$。\n\n打分基于一个替换矩阵 $S(a,b)$ 和结构依赖的空位成本 $g_o(s)$ 和 $g_e(s)$。\n- **替换分数**：如果 $a=b$，则 $S(a, b) = +2$；如果 $a \\neq b$，则 $S(a, b) = -1$。\n- **空位罚分**：与结构为 $s_1, ..., s_k$ 的残基相对的长度为 $k$ 的一个空位串的成本为 $g_o(s_1) + \\sum_{t=1}^{k} g_e(s_t)$。这个总成本将从比对分数中减去。\n\n定义DP矩阵条目的递推关系如下。对于 $1 \\le i \\le m$ 和 $1 \\le j \\le n$：\n\n1.  **匹配/错配矩阵 $M(i, j)$**：以 $(x_i, y_j)$ 结尾的比对必须跟随一个前缀 $x_1...x_{i-1}$ 和 $y_1...y_{j-1}$ 的子比对。这个子比对可能以匹配/错配（$M(i-1, j-1)$）、$x$ 中的空位（$I_y(i-1, j-1)$）或 $y$ 中的空位（$I_x(i-1, j-1)$）结尾。我们取这些可能性中的最大值，并加上比对 $x_i$ 和 $y_j$ 的分数。\n    $$M(i, j) = S(x_i, y_j) + \\max\\left(M(i-1, j-1), I_x(i-1, j-1), I_y(i-1, j-1)\\right)$$\n\n2.  **$y$中空位矩阵 $I_x(i, j)$**：以 $(x_i, -)$ 结尾的比对是通过扩展 $x_1...x_{i-1}$ 和 $y_1...y_j$ 的一个子比对形成的。这可以通过两种方式发生：\n    - **开放一个空位**：前一个子比对没有以 $y$ 中的空位结尾。这对应于状态 $M(i-1, j)$ 或 $I_y(i-1, j)$。产生的成本是为在 $x_i$ 对面开放一个新空位，根据问题的公式，成本为 $g_o(s) + g_e(s)$，其中 $s = ss_x[i-1]$。\n    - **延伸一个空位**：前一个子比对已经以 $y$ 中的空位结尾，对应于状态 $I_x(i-1, j)$。成本是将空位延伸一个位置，即 $g_e(s)$。\n    设 $s_{xi} = ss_x[i-1]$。递推关系为：\n    $$I_x(i, j) = \\max \\begin{cases} \\max\\left(M(i-1, j), I_y(i-1, j)\\right) - \\left(g_o(s_{xi}) + g_e(s_{xi})\\right) \\\\ I_x(i-1, j) - g_e(s_{xi}) \\end{cases}$$\n\n3.  **$x$中空位矩阵 $I_y(i, j)$**：对称地，对于以 $(-, y_j)$ 结尾的比对：\n    设 $s_{yj} = ss_y[j-1]$。递推关系为：\n    $$I_y(i, j) = \\max \\begin{cases} \\max\\left(M(i, j-1), I_x(i, j-1)\\right) - \\left(g_o(s_{yj}) + g_e(s_{yj})\\right) \\\\ I_y(i, j-1) - g_e(s_{yj}) \\end{cases}$$\n\n**初始化**：\nDP矩阵被初始化以处理比对网格的边界。\n- 比对两个空序列的分数为 $0$，所以 $M(0, 0) = 0$。所有其他条目被初始化为一个非常大的负数（概念上是 $-\\infty$），以确保它们除非被显式计算，否则不会被选为最大值。\n- $I_x(0,0)$ 和 $I_y(0,0)$ 必须是 $-\\infty$。\n- 第一行和第一列表示将一个序列的前缀与一个空序列进行比对。这对应于一连串的空位。\n- 对于 $i = 1, \\dots, m$：$x_1...x_i$ 与空序列的比对是一个长度为 $i$ 的空位。分数 $I_x(i, 0)$ 是累积的罚分。\n  $$I_x(i, 0) = -\\left( g_o(ss_x[0]) + \\sum_{k=1}^{i} g_e(ss_x[k-1]) \\right)$$\n  这可以迭代计算：$I_x(1, 0) = -(g_o(ss_x[0]) + g_e(ss_x[0]))$，对于 $i > 1$，$I_x(i, 0) = I_x(i-1, 0) - g_e(ss_x[i-1])$。\n- 对称地，对于 $j = 1, \\dots, n$：\n  $$I_y(0, j) = -\\left( g_o(ss_y[0]) + \\sum_{k=1}^{j} g_e(ss_y[k-1]) \\right)$$\n  迭代计算：$I_y(0, 1) = -(g_o(ss_y[0]) + g_e(ss_y[0]))$，对于 $j > 1$，$I_y(0, j) = I_y(0, j-1) - g_e(ss_y[j-1])$。\n- 对于 $i,j > 0$ 的所有 $M(i,0)$ 和 $M(0,j)$ 保持为 $-\\infty$，因为匹配需要两个序列都有非空前缀。\n\n**最终分数**：\n在为所有从 $1$ 到 $m$ 的 $i$ 和从 $1$ 到 $n$ 的 $j$ 填充完表格后，最优全局比对分数是对完整序列可实现的最大分数。比对可以以匹配/错配、$x$ 中的空位或 $y$ 中的空位结尾。因此，总的最优分数是：\n$$\\text{Score}_{\\text{optimal}} = \\max\\left(M(m, n), I_x(m, n), I_y(m, n)\\right)$$\n此过程保证在指定的打分模型下找到可能的最大分数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the alignment problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\"x\": \"ACDE\", \"ss_x\": \"HEEC\", \"y\": \"ACDF\", \"ss_y\": \"HEEC\"},\n        # Case 2\n        {\"x\": \"VVV\", \"ss_x\": \"EEE\", \"y\": \"VVVV\", \"ss_y\": \"EEEE\"},\n        # Case 3\n        {\"x\": \"ABCD\", \"ss_x\": \"CCCC\", \"y\": \"ABXCD\", \"ss_y\": \"CCCCC\"},\n        # Case 4\n        {\"x\": \"\", \"ss_x\": \"\", \"y\": \"M\", \"ss_y\": \"H\"},\n        # Case 5\n        {\"x\": \"ABC\", \"ss_x\": \"HEC\", \"y\": \"AXYBC\", \"ss_y\": \"HCEEC\"},\n    ]\n\n    results = []\n    for case in test_cases:\n        score = calculate_optimal_score(case['x'], case['ss_x'], case['y'], case['ss_y'])\n        results.append(score)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_optimal_score(x, ss_x, y, ss_y):\n    \"\"\"\n    Calculates the optimal global alignment score for two sequences using\n    a structure-dependent affine gap penalty model.\n    \"\"\"\n    m = len(x)\n    n = len(y)\n    \n    neg_inf = -10**9\n\n    # Substitution score function\n    def S(a, b):\n        return 2 if a == b else -1\n\n    # Gap penalty parameters\n    gap_costs = {\n        'H': {'o': 6, 'e': 2},\n        'E': {'o': 9, 'e': 3},\n        'C': {'o': 4, 'e': 1}\n    }\n\n    # Initialize DP matrices\n    M = np.full((m + 1, n + 1), neg_inf, dtype=np.int32)\n    Ix = np.full((m + 1, n + 1), neg_inf, dtype=np.int32)\n    Iy = np.full((m + 1, n + 1), neg_inf, dtype=np.int32)\n\n    M[0, 0] = 0\n\n    # Initialize first row and column (aligning with empty sequence)\n    # Gaps in y (alignment of x with empty)\n    for i in range(1, m + 1):\n        s = ss_x[i-1]\n        cost_e = gap_costs[s]['e']\n        if i == 1:\n            cost_o = gap_costs[s]['o']\n            Ix[i, 0] = -(cost_o + cost_e)\n        else:\n            Ix[i, 0] = Ix[i-1, 0] - cost_e\n\n    # Gaps in x (alignment of y with empty)\n    for j in range(1, n + 1):\n        s = ss_y[j-1]\n        cost_e = gap_costs[s]['e']\n        if j == 1:\n            cost_o = gap_costs[s]['o']\n            Iy[0, j] = -(cost_o + cost_e)\n        else:\n            Iy[0, j] = Iy[0, j-1] - cost_e\n            \n    # Fill DP matrices\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # M(i, j): match/mismatch\n            s_score = S(x[i-1], y[j-1])\n            prev_max = max(M[i-1, j-1], Ix[i-1, j-1], Iy[i-1, j-1])\n            if prev_max > neg_inf:\n                M[i, j] = s_score + prev_max\n\n            # Ix(i, j): gap in y\n            s_xi = ss_x[i-1]\n            cost_open_x = gap_costs[s_xi]['o'] + gap_costs[s_xi]['e']\n            cost_extend_x = gap_costs[s_xi]['e']\n\n            open_gap_x_score = max(M[i-1, j], Iy[i-1, j])\n            if open_gap_x_score > neg_inf:\n                open_gap_x_score -= cost_open_x\n            \n            extend_gap_x_score = Ix[i-1, j]\n            if extend_gap_x_score > neg_inf:\n                extend_gap_x_score -= cost_extend_x\n\n            Ix[i, j] = max(open_gap_x_score, extend_gap_x_score)\n\n            # Iy(i, j): gap in x\n            s_yj = ss_y[j-1]\n            cost_open_y = gap_costs[s_yj]['o'] + gap_costs[s_yj]['e']\n            cost_extend_y = gap_costs[s_yj]['e']\n            \n            open_gap_y_score = max(M[i, j-1], Ix[i, j-1])\n            if open_gap_y_score > neg_inf:\n                open_gap_y_score -= cost_open_y\n                \n            extend_gap_y_score = Iy[i, j-1]\n            if extend_gap_y_score > neg_inf:\n                extend_gap_y_score -= cost_extend_y\n\n            Iy[i, j] = max(open_gap_y_score, extend_gap_y_score)\n\n    final_score = max(M[m, n], Ix[m, n], Iy[m, n])\n    return int(final_score)\n\nsolve()\n```", "id": "2371017"}]}