{"hands_on_practices": [{"introduction": "要真正掌握带状比对算法，最好的方法莫过于亲自动手计算。这个练习将引导你手动填充一个带状动态规划矩阵，让你在实践中理解带状约束是如何在每一步限制计算范围和路径选择的。通过这个基础练习，你将对算法的核心机制建立起直观而深刻的认识 [@problem_id:2374044]。", "problem": "给定两个脱氧核糖核酸 (DNA) 序列，请使用动态规划 (DP) 计算带状全局比对，然后执行回溯以确定最优路径。在标准的全局比对框架 (Needleman–Wunsch (NW)) 下，使用线性空位罚分进行计算，但将计算限制在具有固定半带宽的对角带内。使用以下数据和定义。\n\n- 序列：$S = \\text{GACT}$，长度 $m = 4$；$T = \\text{GAT}$，长度 $n = 3$。\n- 计分方案：匹配 $= +2$，错配 $= -1$，空位 $= -2$。\n- 带状约束：仅允许满足 $|i - j| \\le w$ 的 DP 单元格 $(i,j)$，其中带半带宽为 $w = 1$。任何需要进入 $|i - j| > w$ 单元格的转移都是不允许的，并被视为得分为 $-\\infty$。\n- 初始化遵循全局比对的定义：将一个非空前缀与空字符串对齐的成本是字母数乘以空位罚分，但这仅适用于位于带内的单元格。具体而言，设置 $D(0,0) = 0$。对于任何 $i \\ge 1$，如果 $|i - 0| \\le w$，则 $D(i,0) = i \\times (-2)$；对于任何 $j \\ge 1$，如果 $|0 - j| \\le w$，则 $D(0,j) = j \\times (-2)$。任何带外的边界单元格都是不允许的。\n\n任务：\n1. 使用全局比对最优子结构原理，在带状约束下手动填写所有允许的 DP 单元格 $D(i,j)$（仅考虑从允许的前驱单元格进行的对角、向上和向左的转移）。\n2. 在带内执行回溯，以确定一条从 $(i,j) = (m,n)$ 到 $(0,0)$ 的最优带状全局比对路径。\n3. 使用您完成的 DP 表和回溯结果，陈述最优带状全局比对分数 $D(m,n)$。\n\n仅报告最终的最优带状全局比对分数作为您的答案。无需四舍五入，且无单位。您的最终答案必须是一个实数值。", "solution": "问题陈述已经过严格评估，并被认为是有效的。它在科学上基于生物信息学的既定原则，特别是用于全局序列比对的 Needleman-Wunsch 算法，并增加了标准的带状约束。该问题是良构的，提供了所有必要的参数：两个序列 $S$ 和 $T$、它们的长度 $m$ 和 $n$、一个完整的计分方案（匹配、错配、空位罚分），以及关于带半带宽 $w$ 和初始化条件的精确定义。目标清晰且可形式化。因此，我们开始进行解答。\n\n我们的目标是计算两个 DNA 序列 $S = \\text{GACT}$（长度 $m=4$）和 $T = \\text{GAT}$（长度 $n=3$）的带状全局比对的最优分数。动态规划 (DP) 表，记为 $D$，其维度为 $(m+1) \\times (n+1)$，即 $5 \\times 4$。索引 $i$ 的范围从 $0$到 $4$，对应于 $S$ 的前缀；索引 $j$ 的范围从 $0$ 到 $3$，对应于 $T$ 的前缀。\n\n计算被限制在由约束 $|i - j| \\le w$ 定义的带内，其中半带宽 $w=1$。任何不满足此条件的单元格 $(i,j)$ 都被视为不可访问，相当于得分为 $-\\infty$。\n\n计分方案为：匹配得分 $s_{match} = +2$，错配得分 $s_{mismatch} = -1$，以及线性空位罚分 $g = -2$。\n\n带内单元格 $D(i,j)$ 的递推关系源自标准的 Needleman-Wunsch 算法：\n$$\nD(i,j) = \\max\n\\begin{cases}\nD(i-1, j-1) + \\text{score}(S_i, T_j) & \\text{(来自对角)} \\\\\nD(i-1, j) + g & \\text{(来自上方)} \\\\\nD(i, j-1) + g & \\text{(来自左方)}\n\\end{cases}\n$$\n其中，如果 $S_i = T_j$，则 $\\text{score}(S_i, T_j)$ 为 $s_{match}$，否则为 $s_{mismatch}$。任何位于带外的前驱单元格为这个最大化过程提供的分数为 $-\\infty$，从而有效地禁止了来自该单元格的转移。\n\n**步骤 1：初始化**\n根据题目要求，$D(0,0) = 0$。对于第一行和第一列，我们初始化位于带内的单元格：\n- 对于 $i \\ge 1$，$D(i,0) = i \\times g$ 如果 $|i-0| \\le w=1$。这仅对 $i=1$ 成立。因此，$D(1,0) = 1 \\times (-2) = -2$。单元格 $(2,0)$ 在带外，因为 $|2-0| > 1$。\n- 对于 $j \\ge 1$，$D(0,j) = j \\times g$ 如果 $|0-j| \\le w=1$。这仅对 $j=1$ 成立。因此，$D(0,1) = 1 \\times (-2) = -2$。单元格 $(0,2)$ 在带外，因为 $|0-2| > 1$。\n所有其他边界单元格都在带外，不进行计算。\n\n初始化单元格总结（X 表示带外）：\n- $D(0,0)=0$\n- $D(1,0)=-2$\n- $D(0,1)=-2$\n- $D(i,j) = X$ 对于 $(i,j) \\in \\{(2,0), (3,0), (4,0), (0,2), (0,3)\\}$\n\n**步骤 2：填充 DP 表**\n我们按照尊重数据依赖性的顺序（例如，逐行或逐列）计算剩余可访问单元格的分数。\n\n- **单元格 (1,1)：** $|1-1|=0 \\le 1$。\n$S_1=\\text{'G'}, T_1=\\text{'G'}$ (匹配)。\n$D(1,1) = \\max(D(0,0)+s_{match}, D(0,1)+g, D(1,0)+g) = \\max(0+2, -2-2, -2-2) = 2$。\n\n- **单元格 (1,2)：** $|1-2|=1 \\le 1$。\n$S_1=\\text{'G'}, T_2=\\text{'A'}$ (错配)。前驱单元格 $(0,2)$ 在带外。\n$D(1,2) = \\max(D(0,1)+s_{mismatch}, D(1,1)+g) = \\max(-2-1, 2-2) = 0$。\n\n- **单元格 (2,1)：** $|2-1|=1 \\le 1$。\n$S_2=\\text{'A'}, T_1=\\text{'G'}$ (错配)。前驱单元格 $(2,0)$ 在带外。\n$D(2,1) = \\max(D(1,0)+s_{mismatch}, D(1,1)+g) = \\max(-2-1, 2-2) = 0$。\n\n- **单元格 (2,2)：** $|2-2|=0 \\le 1$。\n$S_2=\\text{'A'}, T_2=\\text{'A'}$ (匹配)。\n$D(2,2) = \\max(D(1,1)+s_{match}, D(1,2)+g, D(2,1)+g) = \\max(2+2, 0-2, 0-2) = 4$。\n\n- **单元格 (2,3)：** $|2-3|=1 \\le 1$。\n$S_2=\\text{'A'}, T_3=\\text{'T'}$ (错配)。前驱单元格 $(1,3)$ 在带外。\n$D(2,3) = \\max(D(1,2)+s_{mismatch}, D(2,2)+g) = \\max(0-1, 4-2) = 2$。\n\n- **单元格 (3,2)：** $|3-2|=1 \\le 1$。\n$S_3=\\text{'C'}, T_2=\\text{'A'}$ (错配)。前驱单元格 $(3,1)$ 在带外。\n$D(3,2) = \\max(D(2,1)+s_{mismatch}, D(2,2)+g) = \\max(0-1, 4-2) = 2$。\n\n- **单元格 (3,3)：** $|3-3|=0 \\le 1$。\n$S_3=\\text{'C'}, T_3=\\text{'T'}$ (错配)。\n$D(3,3) = \\max(D(2,2)+s_{mismatch}, D(2,3)+g, D(3,2)+g) = \\max(4-1, 2-2, 2-2) = 3$。\n\n- **单元格 (4,3)：** $|4-3|=1 \\le 1$。这是最终的单元格 $D(m,n)$。\n$S_4=\\text{'T'}, T_3=\\text{'T'}$ (匹配)。前驱单元格 $(4,2)$ 在带外。\n$D(4,3) = \\max(D(3,2)+s_{match}, D(3,3)+g) = \\max(2+2, 3-2) = 4$。\n\n**步骤 3：回溯与最终分数**\n计算出的 DP 矩阵如下所示，仅显示可访问的单元格：\n$$\n\\begin{array}{c|cccc}\nD & \\epsilon & \\text{G} & \\text{A} & \\text{T} \\\\\n\\hline\n\\epsilon & 0 & -2 & X & X \\\\\n\\text{G} & -2 & 2 & 0 & X \\\\\n\\text{A} & X & 0 & 4 & 2 \\\\\n\\text{C} & X & X & 2 & 3 \\\\\n\\text{T} & X & X & X & 4 \\\\\n\\end{array}\n$$\n带状全局比对的最优分数是右下角可访问单元格 $D(m,n) = D(4,3)$ 中的值。根据我们的计算，这个分数是 $4$。\n\n从 $D(4,3)$ 开始的回溯证实了此分数。值 $D(4,3)=4$ 是从对角前驱 $D(3,2)$ 获得的，对应于将 $S_4=\\text{'T'}$ 与 $T_3=\\text{'T'}$ 比对。值 $D(3,2)=2$ 来自“上方”的前驱 $D(2,2)$，对应于将 $S_3=\\text{'C'}$ 与一个空位比对。值 $D(2,2)=4$ 来自对角前驱 $D(1,1)$，对应于将 $S_2=\\text{'A'}$ 与 $T_2=\\text{'A'}$ 比对。最后，$D(1,1)=2$ 来自对角前驱 $D(0,0)=0$，对应于将 $S_1=\\text{'G'}$ 与 $T_1=\\text{'G'}$ 比对。这得出了以下比对结果：\nS: G A C T\nT: G A - T\n得分为 $(+2) + (+2) + (-2) + (+2) = 4$，与结果一致。\n\n最终的最优带状全局比对分数为 $D(4,3)$。", "answer": "$$\\boxed{4}$$", "id": "2374044"}, {"introduction": "在掌握了带状比对的基本操作后，一个关键问题随之而来：我们应该如何选择合适的带宽？这个练习将挑战你思考带宽 $k$ 与最优比对路径之间的内在联系。通过分析特定序列的结构，你将学会如何确定保证找到最优解所需的最小带宽，从而深刻理解在计算速度和比对灵敏度之间的权衡 [@problem_id:2373995]。", "problem": "两个脱氧核糖核酸 (DNA) 序列将使用带仿射空位罚分的 Needleman–Wunsch (NW) 算法进行全局比对。设序列 $S$ 为\nAAAAAACCCCCCTTTTTTGGGGGG\n设序列 $T$ 为\nAAAAAACCCCCCGGGGGG。\n计分方案如下：匹配得 $+1$ 分，错配得 $-2$ 分，空位开放罚 $-2$ 分，空位延伸罚 $-1$ 分。在仿射罚分下，一个长度为 $\\ell$ 的连续空位的分数为 $-2-(\\ell-1)\\cdot 1$。\n\n考虑一种动态规划 (DP) 解法的带状实现，该实现将计算限制在满足 $\\lvert i-j\\rvert \\leq k$ 的单元格 $(i,j)$ 内，其中 $i$ 是序列 $S$ 的位置索引（从 $0$ 到 $n$），$j$ 是序列 $T$ 的位置索引（从 $0$ 到 $m$）。确定最小的非负整数带状半宽度 $k_{\\min}$，使得带状算法能保证在给定的计分方案下，为这两个序列找到真正的最优全局比对分数。\n\n请以单个整数形式提供最终答案。无需四舍五入。", "solution": "该问题要求确定 Needleman-Wunsch 算法的带状实现的最小非负整数带状半宽度，记作 $k_{\\min}$。这个 $k_{\\min}$ 必须足够大，以保证在仿射空位罚分模型下，能够为两个特定的 DNA 序列 $S$ 和 $T$ 找到真正的最优全局比对分数。\n\n首先，我们必须将给定的信息形式化。\n序列如下：\n$S = \\text{AAAAAACCCCCCTTTTTTGGGGGG}$\n$T = \\text{AAAAAACCCCCCGGGGGG}$\n序列 $S$ 的长度为 $n=24$。序列 $T$ 的长度为 $m=18$。\n\n计分方案如下：\n- 匹配分数：$s_{\\text{match}} = +1$\n- 错配分数：$s_{\\text{mismatch}} = -2$\n- 空位开放罚分：$g_{\\text{open}} = -2$\n- 空位延伸罚分：$g_{\\text{extend}} = -1$\n\n一个长度为 $\\ell$ 的连续空位产生的总罚分为 $G(\\ell) = g_{\\text{open}} + (\\ell-1)g_{\\text{extend}} = -2 - (\\ell-1)$。\n\n带状比对算法将动态规划计算限制在 DP 矩阵中满足条件 $|i-j| \\leq k$ 的一个带状区域的单元格 $(i,j)$ 内，其中 $i$ 是序列 $S$ 的索引（从 $0$ 到 $n$），$j$ 是序列 $T$ 的索引（从 $0$ 到 $m$）。当且仅当最优比对的整个路径都位于该带状区域内时，该算法才能保证找到最优比对。因此，所需的最小半宽度 $k_{\\min}$ 是构成最优比对路径的所有单元格 $(i,j)$ 中 $|i-j|$ 的最大值。\n\n因此，我们的任务是确定 $S$ 和 $T$ 的最优全局比对，然后计算其在 DP 矩阵中对应路径上 $|i-j|$ 的最大值。\n\n让我们分析一下序列的结构。\n序列 $S$ 由四个含有六个相同核苷酸的区块组成：\n$S = S_1 S_2 S_3 S_4$，其中 $S_1=\\text{A}_6$，$S_2=\\text{C}_6$，$S_3=\\text{T}_6$，$S_4=\\text{G}_6$。\n序列 $T$ 由三个含有六个相同核苷酸的区块组成：\n$T = T_1 T_2 T_3$，其中 $T_1=\\text{A}_6$，$T_2=\\text{C}_6$，$T_3=\\text{G}_6$。\n\n最优比对将通过尽可能比对相同的区块来最大化总分。区块 $S_1$ 和 $T_1$、$S_2$ 和 $T_2$ 以及 $S_4$ 和 $T_3$ 是相同的。序列 $S$ 中的区块 $S_3 = \\text{TTTTTT}$ 在序列 $T$ 中没有同源对应部分。\n\n最优比对策略是直观清晰的：\n1. 将 $S_1S_2$ 与 $T_1T_2$ 进行比对。这是 $\\text{AAAAAACCCCCC}$ 与 $\\text{AAAAAACCCCCC}$ 的比对，包含 12 个匹配。这部分的分数为 $12 \\times s_{\\text{match}} = 12 \\times 1 = 12$。\n2. 处理区块 $S_3 = \\text{TTTTTT}$。它可以与 $T$ 中的一个空位比对，或者与 $T$ 中的下一个区块 $T_3 = \\text{GGGGGG}$ 错配。\n   - 选项 A：将 $S_3$ 与序列 $T$ 中长度为 $\\ell=6$ 的空位比对。由此得到的分数是空位罚分 $G(6) = -2 - (6-1) \\times 1 = -7$。\n   - 选项 B：将 $S_3$ 与 $T_3$ 比对。这将导致 6 个错配（`T` vs `G`）。分数为 $6 \\times s_{\\text{mismatch}} = 6 \\times (-2) = -12$。\n   由于 $-7 > -12$，将 $S_3$ 与空位比对是该片段的最优选择。\n3. 将剩余的区块 $S_4 = \\text{GGGGGG}$ 与 $T_3 = \\text{GGGGGG}$ 比对。此比对提供了 6 个匹配，分数为 $6 \\times s_{\\text{match}} = 6 \\times 1 = 6$。\n\n最终的最优比对是：\n$S$: AAAAAACCCCCCTTTTTTGGGGGG\n$T$: AAAAAACCCCC------GGGGGG\n\n此比对的总分是 $12 + (-7) + 6 = 11$。任何其他比对都会引入错配或次优的空位，从而导致分数更低。例如，打断完美匹配的区块会将匹配分数（$+1$）替换为错配（$-2$）或空位（开放罚 -2 分）分数，这显然是次优的。\n\n现在我们必须在大小为 $(n+1) \\times (m+1) = 25 \\times 19$ 的 DP 矩阵中追踪这个最优比对的路径。索引为 $i \\in [0, 24]$ 和 $j \\in [0, 18]$。路径从 $(0,0)$ 开始，到 $(24,18)$ 结束。\n\n1.  前 12 个字符（$\\text{AAAAAACCCCCC}$）的比对是完美匹配。这对应于 DP 矩阵中的 12 个对角线步骤。路径从 $(0,0)$ 延伸到 $(12,12)$。对于此段路径上的任何单元格 $(i,j)$，都有 $i=j$，所以 $|i-j|=0$。\n\n2.  将来自 $S$ 的 $\\text{TTTTTT}$ 与 $T$ 中的空位进行比对，对应于 DP 矩阵中的 6 个垂直步骤（因为我们消耗了 $S$ 中的字符，但没有消耗 $T$ 中的字符）。路径从 $(12,12)$ 延伸到 $(18,12)$。对于此段路径上的任何单元格 $(i,j)$，$j=12$ 而 $i$ 的范围从 13 到 18。$|i-j|$ 的值为 $|i-12|$。该值从 $|13-12|=1$ 增加到在单元格 $(18,12)$ 处的最大值 $|18-12|=6$。\n\n3.  最后 6 个字符（$\\text{GGGGGG}$）的比对是另一个完美匹配。这对应于 6 个对角线步骤。路径从 $(18,12)$ 延伸到 $(24,18)$。对于此段路径上的任何单元格 $(i,j)$，索引之间的关系是 $j = i-6$。这是因为对于每一步 $d \\in \\{1, \\dots, 6\\}$，单元格是 $(18+d, 12+d)$。差值为 $(18+d)-(12+d)=6$。因此，对于这整个片段，都有 $|i-j| = |6| = 6$。\n\n综合这三个片段，路径上 $|i-j|$ 的值首先是 $0$，然后从 $1$ 增加到 $6$，最后保持在 $6$。因此，在整个最优路径上遇到的 $|i-j|$ 的最大值为 $6$。\n\n为保证带状比对算法能找到这条最优路径，带状半宽度 $k$ 必须至少为这个最大值。\n$$k_{\\min} = \\max_{(i,j) \\in \\text{optimal path}} |i-j| = 6$$\n因此，最小的非负整数带状半宽度是 $6$。", "answer": "$$\\boxed{6}$$", "id": "2373995"}, {"introduction": "我们使用带状比对的根本目的是为了提升效率。在理解了算法的机制和关键参数后，是时候从量化的角度来审视其性能优势了。这个练习将引导你推导在给定的序列长度 $n$ 和半带宽 $w$ 下，算法需要计算的单元格确切数量。这将帮助你建立对带状比对算法复杂度的精确认识，并从根本上理解其为何是一种高效的优化策略 [@problem_id:2374058]。", "problem": "考虑一个用于两条脱氧核糖核酸 (DNA) 序列的带状全局比对算法，该算法使用动态规划 (DP)。设 $S$ 和 $T$ 是两条基于字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的序列，每条序列的长度为 $n$，其中 $n$ 是一个正整数。DP 矩阵有 $(n+1)$ 行和 $(n+1)$ 列，索引范围从 $(0,0)$ 到 $(n,n)$。该带状算法仅当 $|i - j| \\leq w$ 时才计算单元格 $(i,j)$，其中 $w$ 是一个满足 $0 \\leq w \\leq n$ 的整数半带宽。假设计算算法所计算的任何单个单元格（包括带内的边界单元格）的成本为单位时间。\n\n您必须根据带状 DP 的定义，在所有序列对和评分方案的最坏情况下（这些情况使得最优全局比对路径完全保持在从 $(0,0)$ 到 $(n,n)$ 的带状区域内），确定所计算的 DP 单元格的确切数量，并将其表示为 $n$ 和 $w$ 的函数。此外，构建一个显式的序列对 $S$ 和 $T$ 以及一个评分方案，该方案具有匹配奖励 $+a$、错配罚分 $-b$ 和缺口罚分 $-g$（其中 $a,b,g$ 是正实数），该方案能够强制产生这种最坏情况行为，即最优路径在所有行中都保持在带状区域内，并在矩阵边界允许的任何地方都使用全部允许的带宽。\n\n作为最终答案，请给出一个单一的闭式解析表达式，该表达式给出所计算的 DP 单元格的确切数量，作为 $n$ 和 $w$ 的函数。不要提供任何中间步骤。答案无需四舍五入，也不应包含任何单位。", "solution": "首先必须对问题陈述进行严格验证。\n\n步骤1：提取已知条件\n- 算法：通过动态规划 (DP) 实现的带状全局比对。\n- 序列：$S$ 和 $T$，两条基于字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的 DNA 序列。\n- 长度：两条序列的长度均为 $n$，$n$ 是一个正整数。\n- DP 矩阵：大小为 $(n+1) \\times (n+1)$，索引 $(i,j)$ 从 $(0,0)$ 到 $(n,n)$。\n- 带状条件：当且仅当 $|i - j| \\leq w$ 时，计算单元格 $(i,j)$。\n- 半带宽：$w$ 是一个满足 $0 \\leq w \\leq n$ 的整数。\n- 成本：每个计算单元格的成本为单位时间。\n- 目标1：求出计算的 DP 单元格的确切数量，作为 $n$ 和 $w$ 的函数。\n- 目标2：构建一个序列 $S, T$ 和评分方案 ($+a, -b, -g$) 的显式示例，以展示所述的最坏情况路径行为。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它涉及对成熟的用于序列比对的带状动态规划算法的分析。它是客观且定义明确的。主要任务是一个定义明确的组合计数问题。变量 $n$ 和 $w$ 以及单元格计算的条件都以数学精度进行了陈述。没有矛盾之处。$0 \\le w \\le n$ 的取值与该算法的典型应用领域一致。构建示例的次要任务也是有效的；对于任何给定的比对路径，已知可以构建序列和评分方案，使得该路径成为最优路径。最优路径保持在带状区域内的条件是带状算法找到真正全局最优解的前提，包含此条件不构成缺陷。\n\n步骤3：结论与行动\n该问题被判定为有效。我们将着手推导解决方案。\n\n问题要求计算算法所计算的 DP 单元格 $(i,j)$ 的总数。根据问题陈述，这些单元格恰好是满足以下条件的单元格：\n$1.$ $0 \\le i \\le n$\n$2.$ $0 \\le j \\le n$\n$3.$ $|i - j| \\le w$\n\n这是一个在二维网格的指定区域内对整数点进行计数的问题。我们可以通过对 DP 矩阵中落在带状区域内的每条对角线上的贡献单元格数量求和来解决这个问题。\n\n一条对角线由差值 $k = i - j$ 的恒定值定义。条件 $|i - j| \\le w$ 等价于 $|-k| \\le w$，即 $|k| \\le w$。这意味着我们必须考虑总共 $2w+1$ 条对角线，其中 $k \\in \\{-w, -w+1, \\ldots, 0, \\ldots, w-1, w\\}$。\n\n对于由 $k$ 指定的每条对角线，我们必须计算位于其上并且同时在网格边界 $0 \\le i \\le n$ 和 $0 \\le j \\le n$ 内的单元格 $(i,j)$ 的数量。将 $j = i - k$ 代入 $j$ 的边界条件，我们得到 $0 \\le i-k \\le n$，这意味着 $k \\le i \\le n+k$。结合条件 $0 \\le i \\le n$，索引 $i$ 的有效范围是 $\\max(0, k) \\le i \\le \\min(n, n+k)$。\n因此，对角线 $k$ 上的单元格数量，记作 $N_k$，为 $\\min(n, n+k) - \\max(0, k) + 1$。\n\n我们根据 $k$ 的符号分两种情况进行分析：\n情况1：$k \\ge 0$。由于 $w \\le n$，我们有 $k \\le n$。 $i$ 的范围变为 $k \\le i \\le n$。单元格数量为 $N_k = n - k + 1$。这适用于 $k = 0, 1, \\ldots, w$。\n情况2：$k < 0$。 $i$ 的范围变为 $0 \\le i \\le n+k$。单元格数量为 $N_k = (n+k) - 0 + 1 = n+k+1$。这适用于 $k = -1, -2, \\ldots, -w$。\n\n计算的单元格总数 $N$ 是所有有效 $k$ 的 $N_k$ 的总和：\n$$N = \\sum_{k=-w}^{w} N_k = \\sum_{k=-w}^{-1} (n+k+1) + \\sum_{k=0}^{w} (n-k+1)$$\n\n我们分别计算这两个和。第二个和是：\n$$\\sum_{k=0}^{w} (n-k+1) = (n+1)\\sum_{k=0}^{w} 1 - \\sum_{k=0}^{w} k = (w+1)(n+1) - \\frac{w(w+1)}{2}$$\n这计算了主对角线及其上方的 $w$ 条对角线上的单元格。\n\n对于第一个和，我们改变求和索引。令 $m = -k$。当 $k$ 从 $-w$ 取到 $-1$ 时，$m$ 从 $w$ 取到 $1$：\n$$\\sum_{k=-w}^{-1} (n+k+1) = \\sum_{m=1}^{w} (n-m+1)$$\n这个和计算了主对角线下方的 $w$ 条对角线上的单元格。该表达式与前一部分中从 $k=1$ 到 $w$ 的求和相同。\n$$\\sum_{m=1}^{w} (n-m+1) = \\sum_{k=1}^{w} (n-k+1) = \\left(\\sum_{k=0}^{w} (n-k+1)\\right) - (n-0+1) = \\left((w+1)(n+1) - \\frac{w(w+1)}{2}\\right) - (n+1)$$\n\n合并这两个和：\n$$N = \\left( (w+1)(n+1) - \\frac{w(w+1)}{2} \\right) + \\left( (w+1)(n+1) - \\frac{w(w+1)}{2} - (n+1) \\right)$$\n$$N = 2(w+1)(n+1) - w(w+1) - (n+1)$$\n$$N = (2w+2-1)(n+1) - w(w+1)$$\n$$N = (2w+1)(n+1) - w(w+1)$$\n\n这就是计算的单元格的确切数量。这个表达式可以用边界条件进行验证。\n- 对于 $w=0$，带状区域为主对角线。$N = (1)(n+1) - 0 = n+1$，这是正确的。\n- 对于 $w=n$，带状区域覆盖整个矩阵。$N = (2n+1)(n+1) - n(n+1) = (2n+1-n)(n+1) = (n+1)(n+1) = (n+1)^2$，这也是正确的。\n\n构建将比对路径强制推向带状边缘 $|i-j|=w$ 的序列是可能的，方法是创建具有不匹配的交替块的序列，从而强制进行带缺口的比对，并选择一个评分方案，其中错配相对于缺口的罚分非常高（例如，$b \\gg g$）。例如，设 $S = (\\text{A}^w \\text{C}^w)^k \\text{A}^{n \\pmod{2w}}$ 和 $T = (\\text{C}^w \\text{A}^w)^k \\text{C}^{n \\pmod{2w}}$，对于 $n=2wk+ (n \\pmod{2w})$。在一个评分方案中，如果错配罚分 $-b$ 的绝对值远大于缺口罚分 $-g$，则最优路径将倾向于引入 $w$ 个缺口的块来比对匹配的块（例如，$\\text{C}^w$与$\\text{C}^w$），从而将路径强制推向坐标 $(i,j)$ 满足 $|i-j|=w$ 的位置。这证明了问题第二部分的可行性。但是，最终答案只需要单元格计数的解析表达式。", "answer": "$$\\boxed{(2w+1)(n+1) - w(w+1)}$$", "id": "2374058"}]}