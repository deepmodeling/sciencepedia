{"hands_on_practices": [{"introduction": "FASTA 算法的速度源于其第一步——快速查找短而完全相同的“单词”匹配。这一步通过使用一个查找表来索引查询序列中所有单词的位置，从而变得高效。本练习旨在帮助您理解 FASTA 第一阶段背后的基本数据结构，通过计算其内存占用，您将具体地体会到算法参数（如单词长度 $k$）如何直接影响计算资源的需求。[@problem_id:2435282]", "problem": "在用于数据库搜索的 FASTA 算法中，其查询索引步骤会构建一个直接寻址查找表。该表将一个大小为 $A$ 的有限字母表中所有可能长度为 $k$ 的连续词（即 $k$-元组）一一映射到一个固定大小的记录上。假设该查找表采用以下模型：它是一个完全分配的数组，为每个可能的 $k$-元组都设有一个条目，每个条目精确存储 $b$ 字节（例如，一个指针或偏移量），且不进行压缩、池化或惰性分配。无论查询内容如何，该表的构建方式都完全相同。仅使用这些假设和基本计数原理，确定该查找表的期望总内存使用量，并表示为关于 $A$、$k$ 和 $b$ 的闭式函数。以字节为单位表示你的最终答案。无需四舍五入，最终结果必须是单一的解析表达式。", "solution": "经评估，该问题陈述有效。它具有科学依据，定义明确且客观。它描述了直接寻址查找表（计算机科学中的一种基本数据结构）在 FASTA 算法背景下的一个简化但有效的模型。求解所需的所有参数——字母表大小 $A$、词长 $k$ 以及每个条目的内存大小 $b$——都已明确给出。该问题是基本计数原理的直接应用。\n\n目标是确定查找表的总内存使用量。对于一个完全分配的类数组数据结构，其所需的总内存 $M$ 等于总条目数 $N$ 与每个条目所需内存（给定为 $b$ 字节）的乘积。\n\n$$M = N \\times b$$\n\n问题陈述指出，每个条目的内存是固定大小的 $b$ 字节。\n\n问题的核心是确定查找表中的总条目数 $N$。问题明确指出，该表为由大小为 $A$ 的字母表构成的“每个可能的 $k$-元组”都设有一个条目。一个 $k$-元组是一个长度为 $k$ 的连续词。\n\n我们可以运用基本计数原理中的乘法法则来确定唯一 $k$-元组的数量。一个长度为 $k$ 的词由 $k$ 个位置组成。对于每个位置，都可以从字母表中选择 $A$ 个可能的字符。由于每个位置的选择独立于所有其他位置的选择，因此唯一词的总数是 $k$ 个位置上选择数量的乘积。\n\n$$N = \\underbrace{A \\times A \\times \\dots \\times A}_{k \\text{ times}}$$\n\n此乘积等价于 $A$ 的 $k$ 次方。\n\n$$N = A^{k}$$\n\n问题陈述要求的是期望总内存使用量。然而，所提供的模型是确定性的。该表是“完全分配”的，并且其构建方式“无论查询内容如何都完全相同”。这意味着表的大小是固定的，不依赖于任何随机变量或特定的输入查询序列。因此，期望内存使用量就是其实际计算出的内存使用量。\n\n将条目数 $N$ 的表达式代入总内存 $M$ 的方程，我们得到最终的表达式。\n\n$$M = A^{k} \\times b$$\n\n根据 $b$ 的定义，单位是字节。查找表总内存使用量的最终表达式是关于给定参数 $A$、$k$ 和 $b$ 的闭式函数。", "answer": "$$\\boxed{b A^{k}}$$", "id": "2435282"}, {"introduction": "在识别出初始的单词匹配（种子）后，FASTA 会将它们分组到“对角线”上并进行评分，以找出最有希望进行更详细比对的区域。这其中存在一个关键的权衡：既要足够敏感以发现真实匹配，又不能被随机噪声所淹没。这个编程实践将挑战您实现这一关键过滤阶段的简化模型，通过将算法逻辑转化为代码，您将对评分阈值（$\\tau$）和邻近参数（$\\delta$）等参数如何控制灵敏度与计算成本之间的平衡，获得深刻的实践理解。[@problem_id:2435286]", "problem": "构建一个完整、可运行的程序，该程序在下述理想化但数学上精确的设定下，模拟了在快速比对搜索工具 (Fast Alignment Search Tool, FASTA) 中，初始对角线得分（记为 $init1$）阈值与必须存储和连接的对角线数量之间的权衡。所有计算都是纯符号和组合的，不涉及物理单位。\n\n定义与设定：\n\n- 设核苷酸字母表为 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。序列是 $\\Sigma$ 上的一个有限字符串。\n- 设查询序列为 $Q$，其长度为 $L_Q$，使用从零开始的索引 $i\\in\\{0,1,\\dots,L_Q-1\\}$。设主题（数据库）序列为 $S$，其长度为 $L_S$，使用从零开始的索引 $j\\in\\{0,1,\\dots,L_S-1\\}$。\n- 固定一个词长 $k\\in\\mathbb{Z}_{\\ge 1}$。一个 $k$-mer 是任意长度为 $k$ 的连续子串。对于任意 $i\\in\\{0,1,\\dots,L_Q-k\\}$ 和 $j\\in\\{0,1,\\dots,L_S-k\\}$，当且仅当 $k$-mer 完全相等时，即 $Q[i:i+k]=S[j:j+k]$，在配对 $(i,j)$ 处出现一个种子 (seed)。\n- 定义对角线偏移量 $d=i-j$。对于一个固定的对角线 $d\\in\\mathbb{Z}$，令 $M_d=\\{i\\in\\{0,1,\\dots,L_Q-k\\}\\mid \\exists j \\text{ with } j=i-d \\text{ and } 0\\le j\\le L_S-k \\text{ such that } Q[i:i+k]=S[j:j+k]\\}$ 为在对角线 $d$ 上参与形成种子的查询索引集合。令 $|M_d|$ 表示其基数。\n- 固定一个种子奖励 $s_m\\in\\mathbb{Z}_{\\ge 1}$。定义初始对角线得分为 $init1(d)=s_m\\cdot |M_d|$。\n- 给定一个阈值 $\\tau\\in\\mathbb{Z}_{\\ge 0}$，保留（存储）的对角线集合为 $D_{\\tau}=\\{d\\in\\mathbb{Z}\\mid init1(d)\\ge \\tau\\}$，且存储的对角线数量为 $|D_{\\tau}|$。\n- 固定一个邻近参数 $\\delta\\in\\mathbb{Z}_{\\ge 0}$。对于每个保留的对角线 $d\\in D_{\\tau}$，将其集合 $M_d$ 的元素按升序排序为 $i_1<i_2<\\dots<i_{t_d}$。定义由对角线 $d$ 贡献的连接操作数为 $J_d=\\left|\\{\\ell\\in\\{1,2,\\dots,t_d-1\\}\\mid i_{\\ell+1}-i_\\ell\\le \\delta\\}\\right|$。总连接数为 $J=\\sum_{d\\in D_{\\tau}}J_d$。\n- 对于每个测试用例，给定一个真实同源对角线集合 $D^\\star\\subset\\mathbb{Z}$，该集合编码了已知同源区域的比对位置。定义布尔值 $B$，当且仅当 $D^\\star\\subseteq D_{\\tau}$ 时为 $\\text{True}$，否则为 $\\text{False}$。\n\n对于每个测试用例，您的程序必须计算并返回三元组 $[|D_{\\tau}|,J,B]$。\n\n测试套件：\n\n使用以下三个测试用例。在所有情况下，索引都从零开始，对角线偏移量为 $d=i-j$。\n\n- 测试用例 1（代表性用例）：\n  - $Q=$ \"ACGTGACCTGATCGTACGTA\" （因此 $L_Q=20$）。\n  - $S=$ \"TTTT\" + $Q$ + \"CCCC\" （因此 $L_S=28$）。\n  - $k=4$, $s_m=1$, $\\tau=8$, $\\delta=5$。\n  - 真实同源对角线集合 $D^\\star=\\{-4\\}$。\n- 测试用例 2（高阈值边界，无任何内容被保留）：\n  - 与测试用例 1 中的 $Q$ 和 $S$ 相同。\n  - $k=4$, $s_m=1$, $\\tau=18$, $\\delta=5$。\n  - $D^\\star=\\{-4\\}$。\n- 测试用例 3（不同对角线上的多个同源块）：\n  - 令 $A=$ \"ACGTCGATGCTAGTCA\" 且 $B=$ \"TGACCTGATCGTAGCA\"。\n  - $Q=$ $A$ + \"GGGG\" + $B$ （因此 $L_Q=36$）。\n  - $S=$ \"TT\" + $A$ + \"TTTTTT\" + $B$ + \"CC\" （因此 $L_S=42$）。\n  - $k=4$, $s_m=1$, $\\tau=10$, $\\delta=5$。\n  - 块 $A$ 在偏移量 $d=-2$ 处对齐，块 $B$ 在偏移量 $d=-4$ 处对齐，因此 $D^\\star=\\{-2,-4\\}$。\n\n要求的最终输出格式：\n\n- 您的程序必须按上述顺处理三个测试用例，并生成单行输出，其中包含结果列表，每个测试用例一个结果，每个结果是该测试的列表 $[|D_{\\tau}|,J,B]$。该行必须是外层列表的单个字符串表示，内层列表以逗号分隔，例如，\"[[a,b,True],[c,d,False],[e,f,True]]\"，其中 $a,b,c,d,e,f$ 的位置是实际计算出的整数和布尔值。", "solution": "问题陈述是对 FASTA 算法初始阶段简化模型的一个有效、适定且有科学依据的表述。它提供了一套清晰、客观和完整的定义与参数，用以计算灵敏度（保留真实同源对角线）与计算成本（存储的对角线数量和连接操作数）之间的权衡。所有术语都经过严格定义，测试用例的数据是自包含且一致的。因此，我将着手提供一个完整的解决方案。\n\n该解决方案通过实现一个严格遵循问题陈述中所提供定义的计算过程来构建。该算法针对每个测试用例执行，以计算所需的三元组 $[|D_{\\tau}|, J, B]$。整个过程分为四个主要的逻辑步骤。\n\n首先，我们必须识别出长度为 $L_Q$ 的查询序列 $Q$ 和长度为 $L_S$ 的主题序列 $S$ 之间的所有种子匹配。一个种子是 $Q$ 中的一个 $k$-mer 与 $S$ 中的一个 $k$-mer 之间的完美匹配。为高效完成此任务，我们首先建立一个查找表（哈希映射或字典），将主题序列 $S$ 中出现的每个唯一 $k$-mer 映射到其起始索引 $j$ 的列表。然后，我们遍历查询序列 $Q$，提取从索引 $i \\in \\{0, 1, \\dots, L_Q - k\\}$ 开始的每个 $k$-mer。对于每个查询 $k$-mer，我们使用查找表找到 $S$ 中所有匹配的 $k$-mer。对于在 $i$ 处开始的查询 $k$-mer 和在 $j$ 处开始的主题 $k$-mer 之间找到的每个匹配，我们计算对角线偏移量 $d = i - j$。我们填充一个主要的数据结构，一个以对角线偏移量 $d$ 为键、以对该对角线贡献种子的查询索引 $i$ 的列表为值的映射。这个结构代表了集合的集合 $\\{M_d\\}_{d\\in\\mathbb{Z}}$。\n\n其次，在构建了 `diagonal_matches` 映射后，我们计算每条对角线的初始得分，并根据阈值 $\\tau$ 对其进行筛选。对于每条至少有一个种子的对角线 $d$，其得分为 $init1(d) = s_m \\cdot |M_d|$，其中 $|M_d|$ 是该对角线上的种子数，$s_m$ 是种子奖励。然后我们形成保留的对角线集合 $D_{\\tau} = \\{d \\in \\mathbb{Z} \\mid init1(d) \\ge \\tau\\}$。我们输出的第一个部分是该集合的基数 $|D_{\\tau}|$。\n\n第三，我们计算总连接操作数 $J$。此计算仅对集合 $D_{\\tau}$ 中保留的对角线执行。对于每个这样的对角线 $d \\in D_{\\tau}$，我们检索其贡献的查询索引列表 $M_d$。该列表必须按升序排序以分析邻近性：$i_1 < i_2 < \\dots < i_{t_d}$，其中 $t_d = |M_d|$。单条对角线的连接数 $J_d$ 是差值在邻近参数 $\\delta$ 之内的相邻索引对 $(i_\\ell, i_{\\ell+1})$ 的数量，即 $i_{\\ell+1} - i_\\ell \\le \\delta$。总连接数 $J$ 是在所有保留对角线上对这些计数求和的结果：$J = \\sum_{d \\in D_{\\tau}} J_d$。这是我们输出的第二个部分。\n\n第四，我们对已知的同源区域进行验证检查。问题提供了一组真实同源对角线 $D^\\star$。我们必须确定我们的筛选过程是否成功保留了所有这些关键的对角线。这通过检查 $D^\\star$ 是否是我们计算出的保留集合 $D_{\\tau}$ 的子集来形式化。如果 $D^\\star \\subseteq D_{\\tau}$，则布尔变量 $B$ 设置为 True，否则设置为 False。这个布尔值是我们输出三元组的第三个也是最后一个部分。\n\n通过对每个给定的测试用例执行这四个步骤，我们可以为每个用例生成所需的输出列表 $[|D_{\\tau}|, J, B]$，并按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the FASTA trade-off problem for all test cases.\n    \"\"\"\n\n    def compute_fasta_metrics(Q, S, k, s_m, tau, delta, D_star):\n        \"\"\"\n        Computes the required metrics for a single FASTA test case.\n\n        Args:\n            Q (str): The query sequence.\n            S (str): The subject sequence.\n            k (int): The k-mer length.\n            s_m (int): The seed reward.\n            tau (int): The initial diagonal score threshold.\n            delta (int): The proximity parameter for joining.\n            D_star (list): The list of true homologous diagonals.\n\n        Returns:\n            list: A list containing [|D_tau|, J, B].\n        \"\"\"\n        L_Q = len(Q)\n        L_S = len(S)\n\n        # Step 1: Find all seeds and populate diagonal_matches.\n        # Create a lookup table for k-mer positions in the subject sequence S.\n        kmer_positions_s = defaultdict(list)\n        if L_S >= k:\n            for j in range(L_S - k + 1):\n                kmer = S[j : j + k]\n                kmer_positions_s[kmer].append(j)\n\n        # Find matches by iterating through k-mers in the query sequence Q.\n        diagonal_matches = defaultdict(list)\n        if L_Q >= k:\n            for i in range(L_Q - k + 1):\n                kmer = Q[i : i + k]\n                if kmer in kmer_positions_s:\n                    for j in kmer_positions_s[kmer]:\n                        d = i - j\n                        diagonal_matches[d].append(i)\n\n        # Step 2: Compute initial scores and filter diagonals.\n        D_tau = set()\n        retained_matches = {}\n        for d, M_d in diagonal_matches.items():\n            init1_score = s_m * len(M_d)\n            if init1_score >= tau:\n                D_tau.add(d)\n                retained_matches[d] = M_d\n        \n        num_stored_diagonals = len(D_tau)\n\n        # Step 3: Calculate total number of joins (J).\n        total_joins = 0\n        for d in D_tau:\n            M_d = retained_matches[d]\n            M_d.sort()  # Ensure indices are sorted for proximity check.\n            \n            joins_d = 0\n            if len(M_d) > 1:\n                for idx in range(len(M_d) - 1):\n                    if M_d[idx + 1] - M_d[idx] = delta:\n                        joins_d += 1\n            total_joins += joins_d\n\n        # Step 4: Check for homologous diagonals.\n        D_star_set = set(D_star)\n        B = D_star_set.issubset(D_tau)\n\n        return [num_stored_diagonals, total_joins, B]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Q\": \"ACGTGACCTGATCGTACGTA\",\n            \"S\": \"TTTTACGTGACCTGATCGTACGTACCCC\",\n            \"k\": 4, \"s_m\": 1, \"tau\": 8, \"delta\": 5,\n            \"D_star\": [-4]\n        },\n        {\n            \"Q\": \"ACGTGACCTGATCGTACGTA\",\n            \"S\": \"TTTTACGTGACCTGATCGTACGTACCCC\",\n            \"k\": 4, \"s_m\": 1, \"tau\": 18, \"delta\": 5,\n            \"D_star\": [-4]\n        },\n        {\n            \"A\": \"ACGTCGATGCTAGTCA\",\n            \"B_seq\": \"TGACCTGATCGTAGCA\",\n            \"Q\": \"ACGTCGATGCTAGTCA\" + \"GGGG\" + \"TGACCTGATCGTAGCA\",\n            \"S\": \"TT\" + \"ACGTCGATGCTAGTCA\" + \"TTTTTT\" + \"TGACCTGATCGTAGCA\" + \"CC\",\n            \"k\": 4, \"s_m\": 1, \"tau\": 10, \"delta\": 5,\n            \"D_star\": [-2, -4]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_fasta_metrics(\n            case[\"Q\"], case[\"S\"], case[\"k\"], case[\"s_m\"], \n            case[\"tau\"], case[\"delta\"], case[\"D_star\"]\n        )\n        results.append(result)\n\n    # Convert results to a string representation for the final output.\n    # The boolean True/False needs to be capitalized as per Python's str() behavior.\n    result_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(result_str)\n\nsolve()\n```", "id": "2435286"}, {"introduction": "序列比对背后的统计模型通常假定序列是随机且组成均匀的。然而，真实的生物序列，例如高度重复的卫星DNA，会极大地违反这些假设。本练习要求您分析这些违反对 FASTA 算法性能造成的实际影响，通过比较其在重复性查询与复杂性查询上的表现，您将培养出对算法局限性以及数据特征在生物信息学分析中重要性的批判性思维能力。[@problem_id:2435283]", "problem": "您正在使用 FAST-All (FASTA) 算法比较两个等长的脱氧核糖核酸 (DNA) 查询序列，其长度记为 $L$。该算法用于核苷酸-核苷酸数据库搜索，具有固定的字长 $k$ 且不进行低复杂度屏蔽。查询序列 $Q_{1}$ 是一个高度重复的卫星DNA序列，由周期为 $r$ (其中 $r \\ll L$) 的短基序的串联重复组成。查询序列 $Q_{2}$ 是一个蛋白质编码外显子，具有相当的碱基组成和长度 $L$，但缺乏长的低复杂度区域。目标数据库的总长度为 $N \\gg L$，并包含典型的基因组序列混合物。假设 FASTA 的初始种子步骤基于 $k$-元组的精确匹配，并且仅对由这些种子支持的对角线进行延伸和重新评分。\n\n从基本原理出发，两个独立的、组成均匀的、长度分别为 $L$ 和 $M$ 的随机DNA序列之间精确匹配的 $k$-元组的期望数量约为 $(L-k+1)(M-k+1)\\cdot 4^{-k}$，其中 $4^{-k}$ 是在四字母字母表上随机选择的两个 $k$-聚体相同的概率。相比之下，具有强周期性（例如串联重复）的序列所含的不同 $k$-聚体数量远少于相同长度的高复杂度序列，因此它与许多不相关的数据库片段共享相同 $k$-聚体的频率远高于 $4^{-k}$ 基准所预测的。\n\n在这些设置下，哪个选项最能描述 FASTA 对 $Q_{1}$ 与 $Q_{2}$ 的比较性能预期会有何不同？\n\nA. 对于 $Q_{1}$，共享 $k$-元组的过度丰富相对于 $4^{-k}$ 的期望值，会大大增加初始种子的数量，在延伸后产生许多伪高分对角线；这降低了特异性并增加了运行时间。对于 $Q_{2}$，较高的序列复杂度产生的种子数量更接近 $(L-k+1)\\cdot N \\cdot 4^{-k}$，从而提高了特异性和统计可靠性。\n\nB. 对于 $Q_{1}$，串联重复中的冗余减少了不同 $k$-元组的数量，从而减少了初始种子的数量，使搜索更快、更具特异性。对于 $Q_{2}$，密码子结构使种子匹配倍增，减慢了搜索速度并降低了相对于 $Q_{1}$ 的特异性。\n\nC. FASTA 的 Karlin–Altschul 统计完全校正了组成和周期性效应，因此当 $L$ 和 $k$ 固定时，$Q_{1}$ 和 $Q_{2}$ 的速度、种子数量和特异性基本相同。\n\nD. $Q_{1}$ 对整个数据库中的真正同源性产生比 $Q_{2}$ 更高的灵敏度，因为重复保证了在许多目标中存在长的局部比对；因此，在匹配的 $E$-值阈值下，FASTA 为 $Q_{1}$ 报告的假阳性将少于 $Q_{2}$。\n\n选择唯一最佳答案。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知信息\n- 两个等长（长度为 $L$）的脱氧核糖核酸 (DNA) 查询序列 $Q_{1}$ 和 $Q_{2}$。\n- 算法是用于核苷酸-核苷酸数据库搜索的 FAST-All (FASTA)。\n- 字长为固定值 $k$。\n- 不进行低复杂度屏蔽。\n- 查询序列 $Q_{1}$ 是一个高度重复的卫星DNA序列，包含周期为 $r$（其中 $r \\ll L$）的短基序的串联重复。\n- 查询序列 $Q_{2}$ 是一个蛋白质编码外显子，具有相当的碱基组成和长度 $L$，但缺乏长的低复杂度区域。\n- 目标数据库的总长度为 $N$，其中 $N \\gg L$，代表了典型的基因组序列混合物。\n- 种子步骤依赖于 $k$-元组的精确匹配。\n- 延伸和重新评分仅在有种子支持的对角线上执行。\n- 背景信息：两个独立的、随机的、长度分别为 $L$ 和 $M$ 的DNA序列之间精确匹配的 $k$-元组的期望数量约为 $(L-k+1)(M-k+1) \\cdot 4^{-k}$。\n- 背景信息：重复序列比随机概率 $4^{-k}$ 所表明的，含有更少种类的 $k$-聚体，并且更频繁地与不相关的数据库片段共享这些 $k$-聚体。\n\n### 步骤 2：使用提取的已知信息进行验证\n1.  **科学依据充分**：该问题在计算生物学和生物信息学领域有坚实的理论基础。FASTA 算法、$k$-元组种子、序列复杂度（重复性与非重复性）以及序列比较的统计基础都是基本且被正确描述的概念。\n2.  **问题定义明确**：该问题定义明确。它提出了一个清晰的场景，比较了两种不同类型的查询序列，并要求预测一个标准算法在性能上的预期差异。所提供的信息足以根据 FASTA 算法的原理推导出一个唯一的、有意义的答案。\n3.  **客观性**：语言是客观的，并使用了该领域的标准、精确术语（例如，“$k$-元组”、“串联重复”、“特异性”）。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。它在科学上是合理的、定义明确且客观的。我将继续进行解题推导。\n\n### 推导\n问题的核心在于理解序列复杂度对 FASTA 算法种子阶段的影响。\n\n1.  **查询序列分析**：\n    -   查询序列 $Q_{1}$ 是一个低复杂度序列。由于它由周期为 $r$ 的短基序的串联重复组成，其包含的不同 $k$-聚体（长度为 $k$ 的词）的数量非常少。如果 $k$ 在 $r$ 的数量级或更大，不同 $k$-聚体的数量约等于 $r$。这少数几种不同的 $k$-聚体在 $Q_{1}$ 中多次出现。\n    -   查询序列 $Q_{2}$ 是一个高复杂度序列。作为一个典型的蛋白质编码外显子，它缺乏简单的重复。它包含的不同 $k$-聚体的数量将很大，接近可能的最大值 $L-k+1$。\n\n2.  **FASTA 种子步骤**：\n    -   FASTA 的第一步是识别查询序列与数据库序列之间所有共同的 $k$-元组。这些匹配被称为种子。\n    -   对于查询序列 $Q_{1}$，它的小集合的不同 $k$-聚体将在整个长度为 $N$ 的数据库中被搜索。仅凭随机机会，每个特定的 $k$-聚体预计在数据库中出现约 $N \\cdot 4^{-k}$ 次。由于 $Q_{1}$ 由少数几种 $k$-聚体的大量副本组成，种子的总数（或命中数）将被极大地夸大。对于 $Q_1$ 中少数几种不同的 $k$-聚体中的每一种，假设它在 $Q_1$ 中出现 $C_i$ 次，它将在数据库中找到所有的随机出现。初始匹配的总数将是巨大的，远超随机查询的期望值，即约 $(L-k+1) \\cdot N \\cdot 4^{-k}$。这是一种种子的“过度丰富”。\n    -   对于查询序列 $Q_{2}$，它的大量不同 $k$-聚体的行为更像一个随机序列。找到的种子数量将更接近于两个随机序列的统计期望值 $(L-k+1)(N-k+1) \\cdot 4^{-k}$。\n\n3.  **FASTA 延伸和评分步骤**：\n    -   FASTA 接下来会测试这些种子所在的对角线。它试图将它们延伸成更长、得分更高的比对。\n    -   对于查询序列 $Q_{1}$，绝大多数种子都是伪匹配，是由查询序列的重复性而非真正的生物学同源性造成的。算法将耗费大量的计算资源（运行时间）来尝试延伸这些无数的伪种子。这个过程会产生大量短的、无意义的比对，这些比对本质上是噪音。这损害了搜索的*特异性*，因为数据库中许多不相关的序列可能仅仅因为偶然共享了一些重复元素而显示出统计上看似显著的分数。\n    -   对于查询序列 $Q_{2}$，种子的数量是可控的。这些种子更有可能代表真正的局部相似性区域。算法可以有效地延伸这些种子，并且得到的高分比对更有可能是具有生物学意义的。对这些分数的统计评估更可靠，因为查询序列没有严重违反 Karlin-Altschul 统计背后的随机模型假设。这导致了更高的特异性和更可靠的搜索。\n\n### 逐项分析\n\n**A. 对于 $Q_{1}$，共享 $k$-元组的过度丰富相对于 $4^{-k}$ 的期望值，会大大增加初始种子的数量，在延伸后产生许多伪高分对角线；这降低了特异性并增加了运行时间。对于 $Q_{2}$，较高的序列复杂度产生的种子数量更接近 $(L-k+1)\\cdot N \\cdot 4^{-k}$，从而提高了特异性和统计可靠性。**\n-   对 $Q_{1}$ 的描述是正确的。重复性导致种子数量的膨胀。这些种子是伪匹配，导致许多不反映同源性的比对，从而降低了特异性。处理这些大量的伪种子增加了计算运行时间。虽然得到的比对可能不都是“高分”的，但它们数量众多且是伪匹配，这才是关键点。\n-   对 $Q_{2}$ 的描述也是正确的。其复杂度导致种子数量与随机序列的统计期望一致。这提高了特异性（更少的假阳性）和结果的统计可靠性。\n-   结论：**正确**。此选项准确地抓住了基本的权衡关系。\n\n**B. 对于 $Q_{1}$，串联重复中的冗余减少了不同 $k$-元组的数量，从而减少了初始种子的数量，使搜索更快、更具特异性。对于 $Q_{2}$，密码子结构使种子匹配倍增，减慢了搜索速度并降低了相对于 $Q_{1}$ 的特异性。**\n-   对 $Q_{1}$ 的逻辑是有缺陷的。虽然*不同* $k$-元组的数量减少了，但初始种子的总数（总命中数）却被大规模地*增加*了，因为少数几种不同的 $k$-元组在查询序列中多次出现，并在数据库中播下大量匹配。因此，搜索变得更慢、特异性更低，而不是更快、更具特异性。\n-   关于 $Q_2$ 和密码子结构的陈述没有根据。与简单串联重复效应相比，密码子结构本身并不会以一种有问题的方式 “倍增” 种子匹配。\n-   结论：**不正确**。\n\n**C. FASTA 的 Karlin–Altschul 统计完全校正了组成和周期性效应，因此当 $L$ 和 $k$ 固定时，$Q_{1}$ 和 $Q_{2}$ 的速度、种子数量和特异性基本相同。**\n-   这是对 Karlin-Altschul 统计的根本性误解。这些统计数据适用于*比对*被找到*之后*的*分数*。它们不影响或“校正”之前的算法步骤，如初始播种和对角线延伸。实际的性能问题——运行时间和需要处理的伪种子数量——并没有被这个统计模型解决。问题明确指出低复杂度屏蔽是关闭的，而这正是在算法层面处理此类周期性效应的主要机制。\n-   结论：**不正确**。\n\n**D. $Q_{1}$ 对整个数据库中的真正同源性产生比 $Q_{2}$ 更高的灵敏度，因为重复保证了在许多目标中存在长的局部比对；因此，在匹配的 $E$-值阈值下，FASTA 为 $Q_{1}$ 报告的假阳性将少于 $Q_{2}$。**\n-   这个陈述在多个方面都是不正确的。首先，$Q_{1}$ 主要对其他重复区域敏感，而这些区域可能属于也可能不属于一个更大的“真正同源”区域。由于噪音的存在，它对非重复性同源物的灵敏度甚至可能降低。其次，它将报告*更少*假阳性的说法与实际情况恰恰相反。$Q_{1}$ 的重复性是假阳性（伪比对）的主要来源。在任何给定的 $E$-值阈值下，人们会预期 $Q_{1}$ 的伪命中数远多于 $Q_{2}$。\n-   结论：**不正确**。\n\n基于严谨的分析，选项 A 是唯一正确描述 FASTA 算法在此场景下行为的选项。", "answer": "$$\\boxed{A}$$", "id": "2435283"}]}