{"hands_on_practices": [{"introduction": "序列相似性真的可以与序列一致性为零共存吗？这个实践练习通过要求你构建一个反直觉的例子来直接探讨这个核心问题。通过实现标准的Smith-Waterman局部比对算法，你将探索BLOSUM62等替换矩阵如何通过为生化性质相似的氨基酸（即使它们不相同）分配正分值，来捕捉超越简单匹配的生物学相关性 [@problem_id:2428720]。这个练习突显了相似性是比一致性更细致、更能反映生物功能的度量标准。", "problem": "您必须从第一性原理出发，编写一个完整的程序，该程序构建由用于表示氨基酸的大写英文字母组成的蛋白质序列对，并在指定的局部比对评分模型下，评估以下属性是否能够被满足：两个序列之间的 Smith–Waterman (SW) 局部比对具有严格为正的最优得分，同时比对区域内的同一性等于十进制数 $0$。您的程序必须实现带有线性罚分的 Smith–Waterman 动态规划递推关系。下文的定义和评估规则必须被严格遵守。\n\n定义。设 $X = x_1 x_2 \\dots x_n$ 和 $Y = y_1 y_2 \\dots y_m$ 是定义在指定有限字母表上的两个序列。评分函数 $s(\\cdot,\\cdot)$ 为任何比对的字母对分配一个整数相似性得分。大小为 $d \\ge 0$ 的线性罚分，对引入的每个空位字符减去 $d$。Smith–Waterman 动态规划矩阵 $H \\in \\mathbb{Z}^{(n+1)\\times(m+1)}$ 由基本条件 $H_{0,j} = 0$（对所有 $j \\in \\{0,1,\\dots,m\\}$）和 $H_{i,0} = 0$（对所有 $i \\in \\{0,1,\\dots,n\\}$），以及对所有 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$ 的递推关系定义：\n$$\nH_{i,j} \\;=\\; \\max\\Big\\{\\, 0,\\; H_{i-1,j-1} + s(x_i,y_j),\\; H_{i-1,j} - d,\\; H_{i,j-1} - d \\,\\Big\\}.\n$$\n最优 Smith–Waterman 局部比对得分是 $S^\\star(X,Y) = \\max_{0 \\le i \\le n,\\; 0 \\le j \\le m} H_{i,j}$。一个最优比对区域是通过一个有效的回溯路径恢复的任何比对，该路径从达到最大值 $S^\\star(X,Y)$ 的单元格 $(i^\\star,j^\\star)$ 开始，并在每一步选择一个实现该 $\\max$ 值的先行单元格，直到达到值为 $0$ 的单元格为止。将比对列定义为回溯路径上与对角移动相对应的位置；每一次对角移动都将 $X$ 中的一个字母与 $Y$ 中的一个字母进行比对。设 $L$ 为比对列的总数（即，对角移动的次数）。将比对区域内的同一性定义为\n$$\n\\mathrm{Id}(X,Y) \\;=\\; \n\\begin{cases}\n\\frac{M}{L}, & \\text{if } L > 0,\\\\\n0, & \\text{if } L = 0,\n\\end{cases}\n$$\n其中 $M$ 是 $L$ 次对角移动中，两个字母相同的比对列的数量。同一性必须表示为区间 $[0,1]$ 内的一个十进制数，并且在本任务中必须等于十进制数 $0$。\n\n评分模型。您的程序必须处理以下评分模型，每个模型构成一个测试用例。对于每个测试用例，您可以构建任何满足所述字母表约束和任何附加长度约束的序列。您对每个测试用例的输出必须是一个布尔值，当且仅当您构建的序列 $X$ 和 $Y$ 满足 $S^\\star(X,Y) > 0$ 和 $\\mathrm{Id}(X,Y) = 0$ 时，该布尔值为真，否则为假。\n\n- 测试用例 1（理想情况，疏水性相似）。字母表限制为氨基酸 $\\{ \\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M} \\}$。使用 Blocks Substitution Matrix $62$ (BLOSUM$62$) 评分作为这个 $4 \\times 4$ 子集的分数，其中 $s(a,b)$ 指定如下：\n  $s(\\mathrm{I},\\mathrm{I}) = 4$, $s(\\mathrm{I},\\mathrm{L}) = 2$, $s(\\mathrm{I},\\mathrm{V}) = 3$, $s(\\mathrm{I},\\mathrm{M}) = 1$；\n  $s(\\mathrm{L},\\mathrm{I}) = 2$, $s(\\mathrm{L},\\mathrm{L}) = 4$, $s(\\mathrm{L},\\mathrm{V}) = 1$, $s(\\mathrm{L},\\mathrm{M}) = 2$；\n  $s(\\mathrm{V},\\mathrm{I}) = 3$, $s(\\mathrm{V},\\mathrm{L}) = 1$, $s(\\mathrm{V},\\mathrm{V}) = 4$, $s(\\mathrm{V},\\mathrm{M}) = 1$；\n  $s(\\mathrm{M},\\mathrm{I}) = 1$, $s(\\mathrm{M},\\mathrm{L}) = 2$, $s(\\mathrm{M},\\mathrm{V}) = 1$, $s(\\mathrm{M},\\mathrm{M}) = 5$。\n  使用线性罚分 $d = 5$。除了 $n \\ge 1$ 和 $m \\ge 1$ 之外，没有长度约束。\n\n- 测试用例 2（边界长度，零罚分）。与测试用例 1 相同的 BLOSUM$62$ 子集和字母表，但使用线性罚分 $d = 0$。强制执行边界条件 $n = 1$ 和 $m = 1$。\n\n- 测试用例 3（仅基于同一性评分下的不可能情况）。使用完整的大写氨基酸字母表。使用一个匹配/错配评分模型，定义为：如果 $a=b$，则 $s(a,b) = 2$；如果 $a \\ne b$，则 $s(a,b) = -1$。使用线性罚分 $d = 2$。除了 $n \\ge 1$ 和 $m \\ge 1$ 之外，没有长度约束。\n\n您的任务。对于每个测试用例 $t \\in \\{1,2,3\\}$，构建任何符合该测试用例所述字母表和长度约束的序列对 $(X_t,Y_t)$，并使用上述定义评估 $S^\\star(X_t,Y_t)$ 和 $\\mathrm{Id}(X_t,Y_t)$。您的程序必须生成单行输出，其中包含一个用方括号括起来的、长度为 $3$ 的逗号分隔列表形式的结果，其中第 $t$ 个元素是一个布尔值，当且仅当 $S^\\star(X_t,Y_t) > 0$ 和 $\\mathrm{Id}(X_t,Y_t) = 0$ 同时成立时为真，否则为假。例如，您的程序必须打印一行形式为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$ 的内容。\n\n您必须实现和评估的测试套件摘要：\n- 测试 1：在 $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V},\\mathrm{M}\\}$ 上的 BLOSUM$62$ 子集， $d=5$。\n- 测试 2：在 $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V},\\mathrm{M}\\}$ 上的 BLOSUM$62$ 子集，$d=0$ 且 $n=m=1$。\n- 测试 3：在氨基酸字母表上，匹配得分为 $+2$，错配得分为 $-1$，$d=2$。\n\n所有答案均无单位。同一性必须作为 $[0,1]$ 区间内的十进制数处理。您的单行输出必须严格是所指定的布尔值列表，不得包含任何额外的字符或行。", "solution": "在尝试任何解决方案之前，对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n\n从问题陈述中逐字提取已知条件：\n-   **序列**：$X = x_1 x_2 \\dots x_n$ 和 $Y = y_1 y_2 \\dots y_m$。\n-   **评分函数**：$s(\\cdot,\\cdot)$ 分配一个整数得分。\n-   **线性罚分**：大小为 $d \\ge 0$。\n-   **Smith-Waterman (SW) 矩阵**：$H \\in \\mathbb{Z}^{(n+1)\\times(m+1)}$。\n-   **基本条件**：对于所有 $j \\in \\{0,1,\\dots,m\\}$，$H_{0,j} = 0$；对于所有 $i \\in \\{0,1,\\dots,n\\}$，$H_{i,0} = 0$。\n-   **SW 递推关系**：对于所有 $i \\in \\{1,\\dots,n\\}$ 和 $j \\in \\{1,\\dots,m\\}$：\n    $$\n    H_{i,j} \\;=\\; \\max\\Big\\{\\, 0,\\; H_{i-1,j-1} + s(x_i,y_j),\\; H_{i-1,j} - d,\\; H_{i,j-1} - d \\,\\Big\\}.\n    $$\n-   **最优得分**：$S^\\star(X,Y) = \\max_{0 \\le i \\le n,\\; 0 \\le j \\le m} H_{i,j}$。\n-   **回溯**：从得分为 $S^\\star$ 的单元格 $(i^\\star,j^\\star)$ 开始，到得分为 $0$ 的单元格结束。\n-   **比对列**：回溯路径上的对角移动。$L$ 是其总数。\n-   **同一性**：\n    $$\n    \\mathrm{Id}(X,Y) \\;=\\; \n    \\begin{cases}\n    \\frac{M}{L}, & \\text{if } L > 0,\\\\\n    0, & \\text{if } L = 0,\n    \\end{cases}\n    $$\n    其中 $M$ 是 $L$ 个比对列中相同字母对的数量。\n-   **待评估的属性**：是否存在序列 $X$、 $Y$，使得 $S^\\star(X,Y) > 0$ 且 $\\mathrm{Id}(X,Y)$ 等于十进制数 $0$。\n\n-   **测试用例 1**：字母表 $\\{\\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M}\\}$，BLOSUM$62$ 子集分数按规定，罚分 $d=5$，长度约束 $n \\ge 1, m \\ge 1$。\n-   **测试用例 2**：与用例 1 相同的字母表和评分，罚分 $d=0$，长度约束 $n=1, m=1$。\n-   **测试用例 3**：完整大写氨基酸字母表，评分 $s(a,b) = 2$（若 $a=b$）和 $s(a,b)=-1$（若 $a \\ne b$），罚分 $d=2$，长度约束 $n \\ge 1, m \\ge 1$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题基于 Smith-Waterman 算法，这是生物信息学的一个基本概念。所提供的评分模型（BLOSUM 矩阵、匹配/错配方案）和线性罚分都是标准的。所提供的定义在数学上和算法上都是正确的。该问题是合理的。\n-   **问题的适定性**：该问题被构建为三个独立的测试用例，每个用例都有完全指定的参数。对于每个用例，它都要求判断是否存在满足精确定义属性的序列。这是一个具有确定布尔答案（真或假）的适定问题。\n-   **客观性**：该问题以客观、正式的语言陈述，没有歧义或主观论断。\n\n该问题没有表现出任何诸如科学上不合理、不完整、矛盾或结构不适定等缺陷。\n\n### 步骤 3：结论与行动\n\n该问题有效。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n核心任务是针对三种评分模型中的每一种，确定是否可能构建两个序列 $X$ 和 $Y$，使其同时满足两个条件：\n$1$. 最优局部比对得分 $S^\\star(X,Y)$ 严格为正。\n$2$. 最优局部比对的同一性 $\\mathrm{Id}(X,Y)$ 精确为 $0$。\n\n条件 $\\mathrm{Id}(X,Y) = 0$ 意味着在最优局部比对区域内，没有匹配的字符。为了使这个条件有意义，比对长度 $L$（回溯中的对角移动次数）必须大于 $0$，这又意味着匹配数 $M$ 必须为 $0$。如果 $L=0$，则比对为空，其得分为 $0$，违反了 $S^\\star > 0$ 的条件。因此，我们寻求一个至少有一次对角移动（$L \\ge 1$）的比对路径，其中所有此类移动都是错配。\n\n局部比对的得分由其构成操作（匹配、错配和空位）的得分总和决定。要使 $S^\\star > 0$，必须存在一个从得分 $0$ 开始并累积为正总分的比对路径。\n\n**测试用例 1：BLOSUM$62$ 子集, $d=5$**\n\n字母表为 $\\{\\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M}\\}$。所提供的评分矩阵为这些相似的疏水性氨基酸之间的替换指定了正分。例如，异亮氨酸 (I) 与缬氨酸 (V) 比对的得分是 $s(\\mathrm{I},\\mathrm{V}) = 3$。让我们构建最简单的非平凡序列：$X = \\text{\"I\"}$ 和 $Y = \\text{\"V\"}$。这里，$n=1, m=1$。\n\nSmith-Waterman 矩阵 $H$ 的大小为 $2 \\times 2$。唯一需要计算的非平凡条目是 $H_{1,1}$：\n$$H_{1,1} = \\max\\{0, H_{0,0} + s(\\text{'I'},\\text{'V'}), H_{0,1} - 5, H_{1,0} - 5\\}$$\n$$H_{1,1} = \\max\\{0, 0 + 3, 0 - 5, 0 - 5\\} = \\max\\{0, 3, -5, -5\\} = 3$$\n最优得分为 $S^\\star = 3$，大于 $0$。\n为了找到同一性，我们从单元格 $(1,1)$ 开始回溯。得分 $3$ 是从对角先行单元格 $H_{0,0}$ 获得的。这构成了一次对角移动，所以 $L=1$。比对是 $\\text{'I'}$ 与 $\\text{'V'}$。由于它们不同，匹配数 $M=0$。\n同一性为 $\\mathrm{Id} = M/L = 0/1 = 0$。\n两个条件（$S^\\star > 0$ 和 $\\mathrm{Id}=0$）都得到了满足。因此，对于此用例，该属性是可满足的。答案是 `True`。\n\n**测试用例 2：BLOSUM$62$ 子集, $d=0, n=m=1$**\n\n此用例使用与用例 1 相同的评分，但罚分为零，且有严格的长度限制 $n=1$ 和 $m=1$。用例 1 的逻辑可以直接应用。我们再次选择 $X = \\text{\"I\"}$ 和 $Y = \\text{\"V\"}$。\n得分计算如下：\n$$H_{1,1} = \\max\\{0, H_{0,0} + s(\\text{'I'},\\text{'V'}), H_{0,1} - 0, H_{1,0} - 0\\}$$\n$$H_{1,1} = \\max\\{0, 0 + 3, 0 - 0, 0 - 0\\} = \\max\\{0, 3, 0, 0\\} = 3$$\n最优得分为 $S^\\star = 3 > 0$。比对包含一次错配，因此 $L=1, M=0$，且 $\\mathrm{Id}=0$。两个条件都得到了满足。答案是 `True`。\n\n**测试用例 3：仅基于同一性的评分, $d=2$**\n\n评分模型为 $s(a,a) = 2$（匹配）和 $s(a,b) = -1$（当 $a \\ne b$ 时，错配）。罚分为 $d=2$。\n要实现 $\\mathrm{Id}=0$，比对路径必须完全由错配和空位组成。\n让我们分析在这种比对中每种可能移动的得分贡献：\n-   一次错配贡献得分为 $-1$。\n-   一个空位（插入或删除）贡献得分为 $-d = -2$。\n\n任何从得分 $0$ 开始、由这些操作序列组成的比对路径都会累积一个总分。设路径有 $k_d$ 次错配和 $k_g$ 个空位。为了使同一性按规定定义且比对非空，我们需要 $L = k_d > 0$。此比对路径的总分为：\n$$\\text{Score} = k_d \\times (-1) + k_g \\times (-2) = -k_d - 2k_g$$\n由于 $k_d \\ge 1$ 和 $k_g \\ge 0$，该得分始终严格为负（例如，$\\le -1$）。\nSmith-Waterman 递推关系是 $H_{i,j} = \\max\\{0, \\dots\\}$。这意味着如果扩展任何现有比对或开始新比对的得分为负，则结果单元格值 $H_{i,j}$ 将被设置为 $0$。一个仅由错配和空位组成的比对将始终产生非正的得分路径。因此，整个矩阵中的最大得分 $S^\\star$ 永远不可能是严格为正的。它将是 $0$。\n因此，在此评分模型下，不可能同时满足 $S^\\star > 0$ 和 $\\mathrm{Id}=0$。该属性不可满足。答案是 `False`。\n\n**算法实现**\n\n解决方案用 Python 实现。一个函数 `run_sw_and_evaluate` 封装了单个测试用例的逻辑。它构建指定的序列、评分函数和罚分。然后它调用一个 `smith_waterman` 函数，该函数使用 `numpy` 作为动态规划矩阵，从第一性原理实现该算法。此函数计算最优得分 $S^\\star$，如果 $S^\\star > 0$，则执行回溯以计算比对同一性 $\\mathrm{Id}$。主函数 `solve` 遍历三个测试用例，为每个用例调用 `run_sw_and_evaluate`，并将结果布尔值附加到列表中。最后，它按指定格式打印该列表。为测试用例 1 和 2 选择的序列是简单的序列对，展示了正的错配分数，如上所述。对于测试用例 3，使用了一个简单的错配对，这正确地产生了 $0$ 的分数，导致结果为 `False`，与不可能性的证明相符。", "answer": "```python\nimport numpy as np\n\ndef smith_waterman(X: str, Y: str, score_func, d: int):\n    \"\"\"\n    Implements the Smith-Waterman algorithm from first principles.\n\n    Args:\n        X: The first sequence.\n        Y: The second sequence.\n        score_func: A function s(a, b) that returns the score of aligning characters a and b.\n        d: The linear gap penalty (a positive integer).\n\n    Returns:\n        A tuple (max_score, identity) where max_score is the optimal local\n        alignment score and identity is the fraction of matches in the\n        optimal alignment.\n    \"\"\"\n    n = len(X)\n    m = len(Y)\n    H = np.zeros((n + 1, m + 1), dtype=int)\n    \n    max_score = 0\n    max_pos = (0, 0)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            match_score = H[i - 1, j - 1] + score_func(X[i - 1], Y[j - 1])\n            delete_score = H[i - 1, j] - d\n            insert_score = H[i, j - 1] - d\n            \n            H[i, j] = max(0, match_score, delete_score, insert_score)\n\n            if H[i, j] > max_score:\n                max_score = H[i, j]\n                max_pos = (i, j)\n\n    if max_score == 0:\n        return 0, 0.0\n\n    # Traceback to calculate identity\n    i, j = max_pos\n    L, M = 0, 0\n    \n    while H[i, j] > 0:\n        current_score = H[i, j]\n        \n        # Check diagonal predecessor\n        if i > 0 and j > 0 and current_score == H[i - 1, j - 1] + score_func(X[i - 1], Y[j - 1]):\n            L += 1\n            if X[i - 1] == Y[j - 1]:\n                M += 1\n            i, j = i - 1, j - 1\n        # Check up predecessor (gap in Y)\n        elif i > 0 and current_score == H[i - 1, j] - d:\n            i -= 1\n        # Check left predecessor (gap in X)\n        elif j > 0 and current_score == H[i, j - 1] - d:\n            j -= 1\n        else:\n            # Should not be reached if traceback starts from a cell > 0.\n            # This indicates the alignment started at this cell.\n            break\n            \n    identity = M / L if L > 0 else 0.0\n    return max_score, identity\n\ndef solve():\n    \"\"\"\n    Defines and runs the three test cases specified in the problem.\n    \"\"\"\n    \n    # Test Case 1: BLOSUM62 subset, d=5\n    blosum62_subset = {\n        'I': {'I': 4, 'L': 2, 'V': 3, 'M': 1},\n        'L': {'I': 2, 'L': 4, 'V': 1, 'M': 2},\n        'V': {'I': 3, 'V': 4, 'L': 1, 'M': 1},\n        'M': {'I': 1, 'L': 2, 'V': 1, 'M': 5}\n    }\n    score_func_1 = lambda a, b: blosum62_subset[a][b]\n    # We choose two different amino acids with a positive substitution score.\n    X1, Y1 = \"I\", \"V\" \n    d1 = 5\n    \n    # Test Case 2: BLOSUM62 subset, d=0, n=m=1\n    score_func_2 = score_func_1\n    X2, Y2 = \"I\", \"V\"\n    d2 = 0\n\n    # Test Case 3: Match/mismatch, d=2\n    score_func_3 = lambda a, b: 2 if a == b else -1\n    # We choose any two different amino acids to form a mismatch.\n    X3, Y3 = \"A\", \"R\"\n    d3 = 2\n    \n    test_cases = [\n        (X1, Y1, score_func_1, d1),\n        (X2, Y2, score_func_2, d2),\n        (X3, Y3, score_func_3, d3),\n    ]\n\n    results = []\n    for X, Y, score_func, d in test_cases:\n        s_star, identity = smith_waterman(X, Y, score_func, d)\n        condition_met = (s_star > 0 and identity == 0.0)\n        results.append(condition_met)\n    \n    # Python's str(bool) produces \"True\" and \"False\".\n    # The problem asks for a boolean, and this is the standard representation.\n    # The example [result_1, ...] suggests a comma-separated list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2428720"}, {"introduction": "在理解了相似性不同于一致性之后，下一个问题是：我们如何量化这种差异？本练习旨在通过一个目标导向的计算任务来深化你的理解。你将扮演一个蛋白质工程师的角色，任务是通过最少的“保守替换”来精确地将一个比对的BLOSUM62相似性得分提高一个特定值 [@problem_id:2428699]。这项实践不仅强化了不同氨基酸替换对总相似性得分贡献不同的概念，还锻炼了你应用贪心策略来解决优化问题的能力。", "problem": "两条蛋白质序列在长度为 $L=200$ 的区域上进行无空位比对。该比对的序列一致性为 $0.70$，意味着在比对上的位置中，恰有 $0.70L$ 的位置含有相同的氨基酸，而其余位置则为非相同的氨基酸。相似性使用 BLOSUM62 替换矩阵进行量化，总相似性得分定义为整个比对中各位置 BLOSUM62 得分的总和。在此，一个保守替换定义为一个 BLOSUM62 得分为正值的非相同氨基酸对。你只能在非相同位置引入氨基酸的改变；相同位置必须保持不变。\n\n对于非相同位置，假设如下：\n- 一部分非相同位置（假设有足够多的此类位置）目前每个位置贡献的 BLOSUM62 得分为 $-1$。\n- 在每个这样的位置上，你可以在其中一条序列中进行恰好一次氨基酸改变，使得最终的比对氨基酸对变为以下具有指定 BLOSUM62 得分的保守对之一：R–K ($2$)、D–E ($2$)、N–D ($1$)、S–T ($1$)、F–Y ($3$)、I–L ($2$)、V–I ($3$)、A–S ($1$)。\n- 任何位置都不能被改变成相同的氨基酸对；只有上面列出的保守非相同对才是允许的改变结果。\n\n忽略任何空位罚分（因为没有空位），需要进行的最少保守替换次数是多少，才能使比对的总 BLOSUM62 相似性得分增加 $50$ 分？请以单个整数形式提供你的答案，不带单位。不要四舍五入。", "solution": "该问题要求确定，为了将蛋白质比对的总 BLOSUM62 相似性得分提高一个指定数值，所需的最少保守替换次数。我们首先将给定的参数形式化。\n\n比对的总长度为 $L=200$ 个氨基酸位置。序列一致性为 $I=0.70$。因此，相同氨基酸的位置数量为 $N_{id} = I \\times L = 0.70 \\times 200 = 140$。从而，非相同氨基酸的位置数量为 $N_{non-id} = L - N_{id} = 200 - 140 = 60$。\n\n替换在这些非相同位置的一个子集上进行。题目规定，这些特定位置最初每个贡献的 BLOSUM62 得分为 $S_{initial} = -1$。在这样一个位置上进行一次替换会改变氨基酸对，从而产生一个新的、为正值的 BLOSUM62 得分 $S_{final}$。单次替换带来的总得分增加量，记为 $\\Delta S$，是最终得分与初始得分之差：\n$$\n\\Delta S = S_{final} - S_{initial}\n$$\n问题提供了一系列允许的保守替换及其对应的最终 BLOSUM62 得分。我们必须计算每种允许的改变所带来的得分增加量 $\\Delta S$。每个被修改位置的初始得分为 $S_{initial} = -1$。可能的最终得分 $S_{final}$ 有：\n\\begin{enumerate}\n    \\item 对于氨基酸对 F–Y 或 V–I，$S_{final} = 3$。得分增加量为 $\\Delta S_1 = 3 - (-1) = 4$。\n    \\item 对于氨基酸对 R–K、D–E 或 I–L，$S_{final} = 2$。得分增加量为 $\\Delta S_2 = 2 - (-1) = 3$。\n    \\item 对于氨基酸对 N–D、S–T 或 A–S，$S_{final} = 1$。得分增加量为 $\\Delta S_3 = 1 - (-1) = 2$。\n\\end{enumerate}\n因此，每次替换可能带来的得分增加量集合为 $\\{4, 3, 2\\}$。\n\n目标是找到为实现总得分增加 $\\Delta S_{total} = 50$ 所需的最少替换次数，我们称之为 $n_{min}$。为了使替换次数最少，我们必须采用贪心策略。这意味着我们进行的每一次替换，都应该选择能产生最大可能得分增加的替换。单次替换可获得的最大得分增加量是 $\\max(\\Delta S) = 4$。\n\n设 $n$ 为执行的替换次数。如果我们只使用最有效的替换（产生 $\\Delta S = 4$ 的得分增加），总得分增加量将是 $4n$。为了达到 $50$ 的目标增加量，我们必须满足不等式：\n$$\n4n \\ge 50\n$$\n解出 $n$：\n$$\nn \\ge \\frac{50}{4}\n$$\n$$\nn \\ge 12.5\n$$\n由于替换次数 $n$ 必须是整数，因此最少替换次数是大于或等于 $12.5$ 的最小整数。这可以通过对该值取上确界（ceiling）得到：\n$$\nn_{min} = \\lceil 12.5 \\rceil = 13\n$$\n因此，最少需要 $13$ 次替换。我们必须验证，使用 $13$ 次替换是否可以恰好实现 $50$ 的总得分增加，因为可用的得分增量是离散的。设 $n_4$、$n_3$ 和 $n_2$ 分别是得分增加量为 $4$、$3$ 和 $2$ 的替换次数。我们需要找到非负整数 $n_4, n_3, n_2$ 使得：\n$$\nn_4 + n_3 + n_2 = 13\n$$\n并且\n$$\n4n_4 + 3n_3 + 2n_2 = 50\n$$\n这是一个线性丢番图方程组。一个简单的解可以通过最大化使用最高价值的替换（即 $n_4$）来找到。如果我们进行 $12$ 次 $\\Delta S = 4$ 的替换，得分增加量为 $12 \\times 4 = 48$。我们还需要 $50 - 48 = 2$ 的额外得分增加。这可以通过一次产生 $\\Delta S = 2$ 的替换来实现。\n这对应于一个解：$n_4 = 12$，$n_3 = 0$，$n_2 = 1$。\n总替换次数为 $12 + 0 + 1 = 13$。\n总得分增加量为 $(12 \\times 4) + (0 \\times 3) + (1 \\times 2) = 48 + 2 = 50$。\n这证实了用 $13$ 次替换可以达到恰好 $50$ 分的目标得分增加。问题陈述“假设有足够多的此类位置”，这意味着我们至少有 $13$ 个初始得分为 $-1$ 的非相同位置可供修改。根据假设，这个条件是满足的。\n\n因此，所需的最少替换次数为 $13$ 次。", "answer": "$$\\boxed{13}$$", "id": "2428699"}, {"introduction": "现在，让我们将分析提升到综合应用的层面：如何在一个固定的序列一致性预算下，设计出相似性最大化的序列？这个问题模拟了蛋白质设计中的一个常见挑战，即在保持部分关键残基不变的同时，优化其他位置以获得期望的性质。通过解决这个问题，你将学会一种贪心算法策略，即计算并比较每个位置上“保持一致”与“最佳突变”所带来的得分优势，从而做出最优选择 [@problem_id:2428729]。这个练习将让你深刻体会到如何策略性地利用替换矩阵中的信息来进行序列工程。", "problem": "给定一个由标准 $20$ 种氨基酸 $\\{ \\mathrm{A}, \\mathrm{R}, \\mathrm{N}, \\mathrm{D}, \\mathrm{C}, \\mathrm{Q}, \\mathrm{E}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{L}, \\mathrm{K}, \\mathrm{M}, \\mathrm{F}, \\mathrm{P}, \\mathrm{S}, \\mathrm{T}, \\mathrm{W}, \\mathrm{Y}, \\mathrm{V} \\}$ 组成的参考蛋白质序列。设参考序列为 $S = (a_1, a_2, \\dots, a_n)$，其长度为 $n$，其中 $n$ 为偶数。考虑构建一个同样长度的新蛋白质序列 $T = (b_1, b_2, \\dots, b_n)$，使得其与参考序列完全相同的位置恰好为一半，即，恰好有 $n/2$ 个索引 $i$ 满足 $b_i = a_i$。序列中无插入或删除。块替换矩阵（BLOcks SUbstitution Matrix, BLOSUM62）为任意一对氨基酸 $x$ 和 $y$ 定义了一个替换得分 $s(x,y)$。序列间的总相似性得分为各位置得分的总和：\n$$\n\\text{Score}(S,T) = \\sum_{i=1}^{n} s(a_i, b_i).\n$$\n您的任务是，对于每个给定的参考序列 $S$，使用标准的 BLOSUM62 替换得分，并允许在不相同的位置选择任意氨基酸，计算在所有与 $S$ 有恰好 $n/2$ 个位置相同的序列 $T$ 中，$\\text{Score}(S,T)$ 的最大可能值。所有序列均基于 $20$ 种标准氨基酸，不含模糊字符。不允许有空位，所有比较都是逐位进行的。\n\n测试套件：\n- 用例 1（通用重复残基）：$S = \\text{\"AAAAAA\"}$。\n- 用例 2（具有高对角线得分的通用重复残基）：$S = \\text{\"WWWWWW\"}$。\n- 用例 3（具有中性非对角线得分的通用重复残基）：$S = \\text{\"GGGG\"}$。\n- 用例 4（探索逐位权衡的交替残基）：$S = \\text{\"ACACACAC\"}$。\n- 用例 5（边界长度）：$S = \\text{\"AA\"}$。\n\n对于每个测试用例，计算一个单一整数：任何满足恰好有 $n/2$ 个一致位置的序列 $T$ 所能达到的 $\\text{Score}(S,T)$ 的最大值。您的程序应生成一行输出，其中包含一个以逗号分隔的列表，并用方括号括起来的结果（例如，`[x1,x2,x3,x4,x5]`），其顺序与上述测试套件相同。此问题不涉及物理单位。相同位置的比例必须精确表示为一半，即 $n/2$ 或 $0.5$ 的位置，而不是百分比。", "solution": "该问题本质上是计算生物学领域的一个约束优化问题。我们需要寻找一个给定参考蛋白质序列 $S$ 与一个相同长度的目标序列 $T$ 之间的最大相似性得分，其特定约束条件是 $T$ 中恰好有一半的位置与 $S$ 中的位置相同。\n\n设参考序列为 $S = (a_1, a_2, \\dots, a_n)$，其长度为偶数 $n$，氨基酸字母表为 $20$ 种标准氨基酸。我们寻求构建一个序列 $T = (b_1, b_2, \\dots, b_n)$，以最大化总相似性得分，该得分定义为：\n$$\n\\text{Score}(S,T) = \\sum_{i=1}^{n} s(a_i, b_i)\n$$\n其中 $s(x,y)$ 是由 BLOSUM62 矩阵给出的替换得分。\n\n$T$ 的构建受一个关键约束：$b_i = a_i$ 的位置数量必须恰好为 $n/2$。让我们将序列索引集 $\\{1, 2, \\dots, n\\}$ 划分为两个不相交的子集：\n1. 相同位置集合，$I = \\{i \\mid b_i = a_i\\}$，其基数为 $|I| = n/2$。\n2. 突变位置集合，$M = \\{i \\mid b_i \\neq a_i\\}$，其基数为 $|M| = n/2$。\n\n总得分可以分解为在这两个集合上的和：\n$$\n\\text{Score}(S,T) = \\sum_{i \\in I} s(a_i, a_i) + \\sum_{i \\in M} s(a_i, b_i)\n$$\n\n为了最大化这个总分，我们必须为划分 $(I, M)$ 和所有 $i \\in M$ 的特定氨基酸 $b_i$ 做出最优选择。$b_i$（对于 $i \\in M$）的选择彼此独立，也与划分无关。对于任何被指定为突变位点的位置 $i$（即 $i \\in M$），其得分贡献 $s(a_i, b_i)$ 通过选择与 $a_i$ 具有最高替换得分的氨基酸 $b_i$（其中 $b_i \\neq a_i$）来最大化。\n\n让我们为参考序列 $S$ 中的每个位置 $i$ 定义两个量：\n1. **一致性得分** (identity score), $\\delta_{id}(i)$，是如果位置 $i$ 被选择为相同时的得分贡献。这即是 BLOSUM62 矩阵中对应氨基酸 $a_i$ 的对角线元素：\n    $$\n    \\delta_{id}(i) = s(a_i, a_i)\n    $$\n2. **最大突变得分** (maximum mutation score), $\\delta_{mut}(i)$，是如果位置 $i$ 被选择为突变位点时的最大可能得分贡献。这可以通过在 BLOSUM62 矩阵中找到对应氨基酸 $a_i$ 的最大非对角线得分来得到：\n    $$\n    \\delta_{mut}(i) = \\max_{x \\in \\mathcal{A}, x \\neq a_i} s(a_i, x)\n    $$\n    其中 $\\mathcal{A}$ 是 $20$ 种标准氨基酸的集合。\n\n有了这些定义，对于固定的划分 $(I, M)$，可实现的最大得分为：\n$$\n\\text{Score}_{max}(I, M) = \\sum_{i \\in I} \\delta_{id}(i) + \\sum_{i \\in M} \\delta_{mut}(i)\n$$\n\n我们的任务现在简化为找到一个最优划分 $(I, M)$ 來最大化这个和。我们可以重新组织表达式，以分离依赖于划分选择的项。由于 $I \\cup M = \\{1, \\dots, n\\}$ 且 $I \\cap M = \\emptyset$，我们可以写出 $\\sum_{i \\in M} \\delta_{mut}(i) = \\sum_{j=1}^{n} \\delta_{mut}(j) - \\sum_{j \\in I} \\delta_{mut}(j)$。将其代入得分方程得到：\n$$\n\\text{Score}_{max}(I) = \\sum_{i \\in I} \\delta_{id}(i) + \\left( \\sum_{j=1}^{n} \\delta_{mut}(j) - \\sum_{j \\in I} \\delta_{mut}(j) \\right)\n$$\n$$\n\\text{Score}_{max}(I) = \\left( \\sum_{j=1}^{n} \\delta_{mut}(j) \\right) + \\sum_{i \\in I} (\\delta_{id}(i) - \\delta_{mut}(i))\n$$\n\n第一项 $\\sum_{j=1}^{n} \\delta_{mut}(j)$ 对于给定的参考序列 $S$ 是一个常数；它不依赖于集合 $I$ 的选择。因此，要最大化总分，我们必须最大化第二项。让我们将每个位置 $i$ 的**一致性优势** (identity advantage) 定义为：\n$$\n\\Delta_i = \\delta_{id}(i) - \\delta_{mut}(i)\n$$\n这个量 $\\Delta_i$ 表示选择位置 $i$ 成为一致性位点（$i \\in I$）而非最优突变位点（$i \\in M$）所获得的得分净增益。\n\n问题现在是选择一个大小为 $n/2$ 的集合 $I$，使得 $\\sum_{i \\in I} \\Delta_i$ 最大化。这是一个经典的选择问题。最优策略是贪心策略：计算所有位置 $i=1, \\dots, n$ 的优势 $\\Delta_i$，然后选择具有最大优势值的 $n/2$ 个位置来组成集合 $I$。\n\n算法如下：\n1. 对于给定的参考序列 $S = (a_1, \\dots, a_n)$，使用标准的 BLOSUM62 矩阵，为 $20$ 种标准氨基酸中的每一种 $a$ 预先计算并存储 $\\delta_{id}(a)$ 和 $\\delta_{mut}(a)$ 的值。\n2. 对每个位置 $i \\in \\{1, \\dots, n\\}$，确定其氨基酸 $a_i$ 并检索其对应的值 $\\delta_{id}(a_i)$ 和 $\\delta_{mut}(a_i)$。\n3. 计算突变得分列表 $M_{scores} = [\\delta_{mut}(a_1), \\dots, \\delta_{mut}(a_n)]$ 和优势列表 $\\text{Advantages} = [\\Delta_1, \\dots, \\Delta_n]$，其中 $\\Delta_i = \\delta_{id}(a_i) - \\delta_{mut}(a_i)$。\n4. 将 `Advantages` 列表按降序排序。\n5. 最大总分是所有最大突变得分之和，再加上前 $n/2$ 个优势值之和：\n    $$\n    \\text{Score}_{max} = \\left( \\sum_{i=1}^{n} \\delta_{mut}(a_i) \\right) + \\left( \\sum_{j=1}^{n/2} \\text{sorted\\_Advantages}_j \\right)\n    $$\n此方法能够得出精确的最大分，因为各个位置的得分贡献是可加的，并且它们的优化是解耦的，从而允许对一致性集合 $I$ 进行贪心选择。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein sequence scoring problem based on a greedy optimization strategy.\n    \n    The problem is to maximize the BLOSUM62 score of a sequence T against a \n    reference sequence S, where T has exactly n/2 identical residues to S.\n\n    The logic is as follows:\n    1. For each position in S, we can either keep it identical or mutate it.\n    2. The score for an identical position `i` is `s(a_i, a_i)`.\n    3. The best possible score for a mutated position `i` is `max(s(a_i, x))` for all `x != a_i`.\n    4. The \"advantage\" of keeping a position identical is the difference: \n       `s(a_i, a_i) - max(s(a_i, x))`.\n    5. To maximize the total score, we should choose the `n/2` positions with the highest\n       \"advantage\" to be identical. The rest will be optimally mutated.\n    6. The final score is the sum of scores from the chosen identical positions and the\n       optimally mutated positions. This is equivalent to summing all optimal mutation\n       scores and adding the sum of the top `n/2` advantages.\n    \"\"\"\n\n    # The canonical 20 amino acids as per the problem.\n    # The order must match the BLOSUM62 matrix below.\n    AA_ORDER = 'ARNDCQEGHILKMFPSTWYV'\n    \n    # Standard BLOSUM62 substitution matrix for the 20 amino acids.\n    # Source: NCBI\n    BLOSUM62 = np.array([\n        # A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V\n        [ 4,-1,-2,-2, 0,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0], # A\n        [-1, 5, 0,-2,-3, 1, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3], # R\n        [-2, 0, 6, 1,-3, 0, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3], # N\n        [-2,-2, 1, 6,-3, 0, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3], # D\n        [ 0,-3,-3,-3, 9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1], # C\n        [-1, 1, 0, 0,-3, 5, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2], # Q\n        [-1, 0, 0, 2,-4, 2, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2], # E\n        [ 0,-2, 0,-1,-3,-2,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3], # G\n        [-2, 0, 1,-1,-3, 0, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3], # H\n        [-1,-3,-3,-3,-1,-3,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3], # I\n        [-1,-2,-3,-4,-1,-2,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1], # L\n        [-1, 2, 0,-1,-3, 1, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2], # K\n        [-1,-1,-2,-3,-1, 0,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1], # M\n        [-2,-3,-3,-3,-2,-3,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1], # F\n        [-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2], # P\n        [ 1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2], # S\n        [ 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0], # T\n        [-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3], # W\n        [-2,-2,-2,-3,-2,-1,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1], # Y\n        [ 0,-3,-3,-3,-1,-2,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4]  # V\n    ])\n    \n    # Map amino acid characters to their index in the matrix\n    AA_MAP = {aa: i for i, aa in enumerate(AA_ORDER)}\n\n    # Pre-calculate identity scores and max mutation scores for each amino acid\n    delta_cache = {}\n    for aa, idx in AA_MAP.items():\n        row = BLOSUM62[idx]\n        delta_id = row[idx]\n        # Max mutation score is the max of the row excluding the identity score\n        delta_mut = np.max(np.delete(row, idx))\n        delta_cache[aa] = (delta_id, delta_mut)\n\n    test_cases = [\n        \"AAAAAA\",     # Case 1\n        \"WWWWWW\",     # Case 2\n        \"GGGG\",       # Case 3\n        \"ACACACAC\",   # Case 4\n        \"AA\"          # Case 5\n    ]\n\n    results = []\n    for seq in test_cases:\n        n = len(seq)\n        num_identities = n // 2\n        \n        advantages = []\n        mut_scores_sum = 0\n        \n        for aa_char in seq:\n            delta_id, delta_mut = delta_cache[aa_char]\n            advantage = delta_id - delta_mut\n            advantages.append(advantage)\n            mut_scores_sum += delta_mut\n            \n        # Sort advantages in descending order to find the top n/2\n        advantages.sort(reverse=True)\n        \n        # The total score is the sum of all optimal mutation scores plus the sum of the\n        # advantages for the positions we choose to keep identical.\n        top_advantages_sum = sum(advantages[:num_identities])\n        \n        max_score = mut_scores_sum + top_advantages_sum\n        results.append(max_score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428729"}]}