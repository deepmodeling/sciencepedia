{"hands_on_practices": [{"introduction": "为了实现快速搜索，BLAST 首先寻找简短而精确的“种子”匹配。但这些种子仅凭机缘巧合出现的频率有多高？这个初始练习将为此基本问题提供一个定量分析框架，通过推导随机种子匹配的概率，你将具体理解为何较短的种子会导致更多的随机命中，以及为何统计过滤是必不可少的。[@problem_id:2396864]", "problem": "考虑在诸如基本局部比对搜索工具（BLAST）等工具中使用的种子-扩展启发式数据库搜索算法。一个查询包含一个固定的、长度为 $W$ 的连续种子词，该种子词基于一个大小为 $k$ 的字母表。将目标数据库建模为一条长度为 $N$ 的长序列，其中字符是独立同分布的，每个字符都从 $k$ 个字母中均匀随机抽取。假设对于数据库中每个可能的起始位置，种子词是否在该位置精确匹配都可以被视为一次独立的伯努利试验。在此模型下，推导出一个关于 $W$、$k$ 和 $N$ 的闭式解析表达式，用于表示数据库中至少包含一次种子词精确出现的概率。请以单个解析表达式的形式给出您的答案。不要包含任何单位。", "solution": "首先必须严格验证问题陈述。\n\n步骤 1：提取已知条件。\n- 一个查询包含一个长度为 $W$ 的连续种子词。\n- 字母表大小为 $k$。\n- 目标数据库是一条长度为 $N$ 的序列。\n- 数据库中的字符是独立同分布（i.i.d.）的，每个字符都从 $k$ 个字母中均匀随机抽取。\n- 对于数据库中每个可能的起始位置，精确种子词匹配事件被视为一次独立的伯努利试验。\n- 目标是推导出一个关于 $W$、$k$ 和 $N$ 的闭式解析表达式，用于表示数据库中至少出现一次精确种子词的概率。\n\n步骤 2：使用提取的已知条件进行验证。\n该问题具有科学依据，因为它采用了生物信息学算法入门分析中使用的标准概率模型。将在不同起始位置的匹配事件视为独立的伯努利试验这一假设是对现实情况的显著简化——在真实序列中，重叠的潜在匹配并非相互独立——然而，问题明确指示我们使用此模型。因此，这是给定理论框架的一个特性，而非问题陈述本身的缺陷。该问题提法明确、客观，并包含在指定模型内获得唯一解所需的充分信息。该问题可进行数学形式化，且无矛盾或逻辑谬误。\n\n结论：问题有效。我们将继续推导解答。\n\n我们感兴趣的事件是数据库中至少出现一次精确的种子词。我们将此事件记为 $A$。计算其互补事件（记为 $A^c$）的概率通常更为简单，该事件指数据库中*不*存在任何精确的种子词出现。根据互补事件的概率法则，有 $P(A) = 1 - P(A^c)$。\n\n首先，我们必须确定在数据库中单个特定起始位置上发生精确匹配的概率。我们将起始位置为 $i$ 的这一事件记为 $E_i$。种子词的长度为 $W$。要在位置 $i$ 发生精确匹配，数据库中位置 $i$ 的字符必须与种子词的第一个字符匹配，位置 $i+1$ 的字符必须与第二个字符匹配，以此类推，直到位置 $i+W-1$。\n\n问题陈述指出，数据库中的字符是从一个大小为 $k$ 的字母表中均匀抽取的。因此，数据库中任意单个字符与种子词中某个特定字符匹配的概率是 $\\frac{1}{k}$。由于数据库中的字符也是独立同分布的，因此一个长度为 $W$ 的特定字符序列连续出现的概率是它们各自概率的乘积。因此，在任何单个给定起始位置发生精确匹配的概率（我们称此概率为 $p$）是：\n$$p = \\left(\\frac{1}{k}\\right)^W = k^{-W}$$\n\n这是单次伯努利试验中“成功”的概率。“失败”的概率，即在给定位置上不发生匹配的概率，是 $1-p$。\n$$1-p = 1 - k^{-W}$$\n\n接下来，我们必须确定种子词在数据库中可能的起始位置的数量。数据库的长度为 $N$，种子词的长度为 $W$。我们假设 $N \\ge W$，否则不可能发生匹配。第一个可能的起始位置在索引 $1$ 处（跨越数据库字符 $1$ 至 $W$）。最后一个可能的起始位置在索引 $N-W+1$ 处（跨越字符 $N-W+1$ 至 $N$）。因此，总共有 $M$ 个可能的起始位置，其中：\n$$M = (N - W + 1) - 1 + 1 = N - W + 1$$\n\n问题明确指出，我们将这 $M$ 个可能的匹配事件视为独立的伯努利试验。$A^c$ 事件——即整个数据库中不出现任何精确匹配——等价于在所有 $M$ 次独立试验中均观察到失败的事件。这个复合事件的概率是各次独立失败事件概率的乘积：\n$$P(A^c) = (1 - p)^M = \\left(1 - k^{-W}\\right)^{N-W+1}$$\n\n最后，将此结果代入互补概率公式，即可求得至少存在一次精确匹配的概率 $P(A)$：\n$$P(A) = 1 - P(A^c) = 1 - \\left(1 - k^{-W}\\right)^{N-W+1}$$\n\n此表达式即为所求概率关于给定参数 $W$、$k$ 和 $N$ 的闭式解析解。", "answer": "$$\n\\boxed{1 - \\left(1 - k^{-W}\\right)^{N-W+1}}\n$$", "id": "2396864"}, {"introduction": "一旦找到种子命中并进行延伸，我们会得到一个比对得分。这个分数有意义吗，还是可能偶然产生？本实践将带你进入 BLAST 统计引擎的核心，你将根据 Karlin-Altschul 理论重新推导关键参数 $\\lambda$。这个练习将统计显著性这一抽象概念与基于给定评分矩阵的具体计算联系起来，让你更深刻地体会 E 值的确定方式。[@problem_id:2396829]", "problem": "考虑在独立同分布 (i.i.d.) 背景模型下脱氧核糖核酸 (DNA) 字母的随机比对，其碱基频率均一，即 $p_{A}=p_{C}=p_{G}=p_{T}=\\frac{1}{4}$。设配对评分方案为：若 $a=b$ (匹配)，则 $s(a,b)=+1$；若 $a \\neq b$ (错配)，则 $s(a,b)=-3$。在 Karlin–Altschul 无空位局部比对统计框架中，参数 $\\lambda$ 被定义为满足以下方程的唯一正实数：\n$$\n\\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp\\!\\big(\\lambda\\, s(a,b)\\big) \\;=\\; 1.\n$$\n仅使用此定义以及所述的模型和评分方案，确定 $\\lambda$ 的数值。将您的答案四舍五入至 $4$ 位有效数字。将最终结果表示为一个无单位的无量纲数。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n步骤 1：提取给定条件\n问题陈述中提供的明确信息如下：\n- 模型：独立同分布 (i.i.d.) 背景模型下的 DNA 字母随机比对。\n- 碱基频率：$p_{A}=p_{C}=p_{G}=p_{T}=\\frac{1}{4}$。\n- 配对评分方案：若 $a=b$ (匹配)，则 $s(a,b)=+1$；若 $a \\neq b$ (错配)，则 $s(a,b)=-3$。\n- $\\lambda$ 的定义：满足方程\n$$ \\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\n的唯一正实数。\n- 要求：确定 $\\lambda$ 的数值，四舍五入至 $4$ 位有效数字。\n\n步骤 2：使用提取的给定条件进行验证\n根据有效性标准对问题进行评估。\n- **有科学依据：** 该问题基于基础的 Karlin-Altschul 统计理论，该理论是现代生物信息学的一个关键组成部分，特别是对于像 BLAST 这样的工具。所提供的方程是该背景下参数 $\\lambda$ 的核心定义。所用模型和评分方案是用于说明的标准示例。该问题具有科学合理性。\n- **适定性：** 该问题提供了一个定义明确的方程，并要求一个唯一的正实数解。Karlin 和 Altschul 的理论保证，当且仅当期望得分 $E[s(a,b)]$ 为负时，存在这样一个唯一的正 $\\lambda$。让我们计算这个值。任何特定配对 $(a,b)$ 的概率是 $p_a p_b = (\\frac{1}{4})(\\frac{1}{4}) = \\frac{1}{16}$。有 $4$ 种可能的匹配和 $12$ 种可能的错配。期望得分为：\n$$ E[s(a,b)] = \\sum_{a,b} p_a p_b s(a,b) = (4 \\times \\frac{1}{16} \\times (+1)) + (12 \\times \\frac{1}{16} \\times (-3)) = \\frac{4}{16} - \\frac{36}{16} = -\\frac{32}{16} = -2 $$\n由于 $E[s(a,b)] = -2 < 0$，因此存在一个唯一的正 $\\lambda$ 解。该问题是适定的。\n- **客观性：** 该问题使用精确的数学语言和定义进行陈述，没有任何主观性或模糊性。\n\n步骤 3：结论与行动\n该问题是有效的，因为它有科学依据、适定、客观且自洽。因此，将推导求解。\n\n$\\lambda$ 的定义方程为：\n$$ \\sum_{a \\in \\{A,C,G,T\\}} \\sum_{b \\in \\{A,C,G,T\\}} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\n所有可能的字母对 $(a,b)$ 的集合可以划分为两个不相交的集合：匹配 ($a=b$) 和错配 ($a \\neq b$)。求和可以相应地拆分为：\n$$ \\sum_{a=b} p_{a} p_{b} \\exp(\\lambda s(a,b)) + \\sum_{a \\neq b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 1 $$\nDNA 字母表有 $4$ 个字母。因此，有 $4$ 种可能的匹配对 (A,A)、(C,C)、(G,G)、(T,T) 和 $4 \\times 4 - 4 = 12$ 种可能的错配对。\n概率是均一的，所以对于任何配对 $(a,b)$，$p_a p_b = \\frac{1}{4} \\times \\frac{1}{4} = \\frac{1}{16}$。\n对于匹配，分数为 $s(a,b) = +1$。第一个求和项变为：\n$$ \\sum_{a=b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 4 \\times \\left( \\frac{1}{16} \\exp(\\lambda \\cdot 1) \\right) = \\frac{4}{16} \\exp(\\lambda) = \\frac{1}{4} \\exp(\\lambda) $$\n对于错配，分数为 $s(a,b) = -3$。第二个求和项变为：\n$$ \\sum_{a \\neq b} p_{a} p_{b} \\exp(\\lambda s(a,b)) = 12 \\times \\left( \\frac{1}{16} \\exp(\\lambda \\cdot (-3)) \\right) = \\frac{12}{16} \\exp(-3\\lambda) = \\frac{3}{4} \\exp(-3\\lambda) $$\n将这些表达式代回主方程，得到：\n$$ \\frac{1}{4} \\exp(\\lambda) + \\frac{3}{4} \\exp(-3\\lambda) = 1 $$\n为了求解 $\\lambda$，我们可以将整个方程乘以 $4$：\n$$ \\exp(\\lambda) + 3 \\exp(-3\\lambda) = 4 $$\n令 $x = \\exp(\\lambda)$。因为我们寻求正的 $\\lambda$，所以必须有 $x > 1$。该方程转换为关于 $x$ 的代数方程：\n$$ x + 3x^{-3} = 4 $$\n两边乘以 $x^3$ (非零) 以消除负指数，得到一个多项式方程：\n$$ x^4 + 3 = 4x^3 $$\n整理成标准形式：\n$$ x^4 - 4x^3 + 3 = 0 $$\n我们寻求这个四次多项式的根。根据有理根定理，任何有理根都必须是常数项 $3$ 的因数。可能的有理根是 $\\pm 1$ 和 $\\pm 3$。\n测试 $x=1$：\n$$ (1)^4 - 4(1)^3 + 3 = 1 - 4 + 3 = 0 $$\n所以，$x=1$ 是一个根。这对应于 $\\lambda = \\ln(1) = 0$，这是在 $\\sum p_a p_b = 1$ 时始终存在的平凡解。我们感兴趣的是 $\\lambda$ 的唯一*正*解，它对应于 $x > 1$。\n由于 $x=1$ 是一个根，所以 $(x-1)$ 是该多项式的一个因式。我们进行多项式除法：\n$$ \\frac{x^4 - 4x^3 + 3}{x-1} = x^3 - 3x^2 - 3x - 3 $$\n因此，方程变为：\n$$ (x-1)(x^3 - 3x^2 - 3x - 3) = 0 $$\n非平凡根是以下三次方程的解：\n$$ P(x) = x^3 - 3x^2 - 3x - 3 = 0 $$\n该方程没有简单的有理根。我们必须通过数值方法找到相关的根。让我们分析函数 $P(x)$ 来定位我们寻求的根。我们发现 $P(3) = (3)^3 - 3(3)^2 - 3(3) - 3 = 27 - 27 - 9 - 3 = -12$ 且 $P(4) = (4)^3 - 3(4)^2 - 3(4) - 3 = 64 - 48 - 12 - 3 = 1$。\n由于 $P(3) < 0$ 且 $P(4) > 0$，并且 $P(x)$ 是连续的，所以在 $3$ 和 $4$ 之间存在一个根。由于这个根大于 $1$，它将给出所要求的正 $\\lambda$。使用数值方法，例如牛顿法或计算求解器，我们找到根约为：\n$$ x \\approx 3.9526368 $$\n现在，我们使用关系式 $x = \\exp(\\lambda)$ 求解 $\\lambda$：\n$$ \\lambda = \\ln(x) = \\ln(3.9526368) $$\n$$ \\lambda \\approx 1.374333 $$\n问题要求答案四舍五入至 $4$ 位有效数字。前四位有效数字是 $1, 3, 7, 4$。随后的数字是 $3$，所以我们向下舍入。\n$$ \\lambda \\approx 1.374 $$\n这就是所要求的数值。", "answer": "$$\n\\boxed{1.374}\n$$", "id": "2396829"}, {"introduction": "启发式算法是捷径，而每条捷径都有其权衡。BLAST 的“种子-延伸”方法虽然快速，但不能保证找到每一个最佳比对。这项编程挑战将让你亲自探索这种权衡，你需要设计一个序列对，它拥有一个高分比对，但对于类似 BLAST 的种子启发式算法却是“隐形”的。成功解决这个问题将阐明定义启发式搜索的核心妥协——速度与灵敏度之间的权衡。[@problem_id:2396847]", "problem": "您必须编写一个完整、可运行的程序，该程序能针对每组指定的参数，计算出一个不被简化的基于词的种子启发式算法检测到的高分局部比对所需的最小比对长度。\n\n定义。考虑两条基于字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 的脱氧核糖核酸 (DNA) 序列。设 $X$ 和 $Y$ 为两条序列，它们子串之间的局部比对采用 Smith–Waterman 方案和仿射空位罚分模型进行打分：一次匹配贡献 $+m$，一次错配贡献 $-\\mu$，一个长度为 $\\ell$ 的连续空位贡献罚分 $-(g + e \\cdot (\\ell - 1))$，其中 $m > 0$, $\\mu \\ge 0$, $g \\ge 0$, 且 $e \\ge 0$。最优局部比对分数 $S^{\\star}(X,Y)$ 是 $X$ 和 $Y$ 子串之间所有局部比对的最高分数。\n\n启发式检测规则。模拟一种类似于 Basic Local Alignment Search Tool (BLAST)、具有固定词长 $w \\in \\mathbb{N}$ 的基于词的种子启发式算法。当且仅当 $X$ 和 $Y$ 之间的最优局部比对包含至少一段长度不小于 $w$ 的连续匹配时，该启发式算法被认为检测到了序列对 $(X,Y)$。如果启发式算法未检测到一对序列 $(X,Y)$，即其最优局部比对中没有出现长度不小于 $w$ 的连续匹配，则该序列对是反种子的（anti-seed）。\n\n任务。对于一个给定的参数集 $(w,m,\\mu,g,e,S_{\\min})$，定义 $L^{\\ast}$ 为在所有满足以下条件的序列对 $(X,Y)$ 中，可能达到的最小比对列数（计算所有比对列，无论是匹配、错配还是空位）：\n- 最优局部比对分数满足 $S^{\\star}(X,Y) \\ge S_{\\min}$，且\n- 该序列对 $(X,Y)$ 在上述启发式规则下是反种子的。\n\n若不存在这样的序列对，则定义 $L^{\\ast} = -1$。\n\n您的程序必须为以下每个参数集计算 $L^{\\ast}$，并按顺序输出结果序列：\n\n- 案例 1：$w=3$, $m=2$, $\\mu=1$, $g=5$, $e=1$, $S_{\\min}=10$。\n- 案例 2：$w=4$, $m=2$, $\\mu=1$, $g=5$, $e=1$, $S_{\\min}=3$。\n- 案例 3：$w=5$, $m=1$, $\\mu=5$, $g=10$, $e=2$, $S_{\\min}=5$。\n- 案例 4：$w=6$, $m=2$, $\\mu=3$, $g=8$, $e=1$, $S_{\\min}=31$。\n- 案例 5：$w=2$, $m=2$, $\\mu=1$, $g=5$, $e=1$, $S_{\\min}=5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是按给定顺序排列的案例 $i$ 的整数 $L^{\\ast}$ 值；如果该案例不存在这样的序列对，则为 $-1$。不应打印任何额外文本。", "solution": "问题要求在比对是“反种子的”这一约束条件下，达到至少为 $S_{\\min}$ 的局部比对分数所需的最小比对长度 $L^{\\ast}$。一个反种子比对是指其中任意连续匹配区的长度都严格小于给定词长 $w$ 的比对。\n\n首先，我们必须正确理解问题陈述，特别是“$X$ 和 $Y$ 之间的最优局部比对”是反种子的这一条件。一种朴素的解释是，我们需要设计序列 $X$ 和 $Y$，然后验证我们构建的反种子比对确实是所有可能的局部比对（包括那些可能包含长度 $\\ge w$ 的匹配区的比对）中得分最高的。这个验证是一项艰巨的任务。然而，如果我们认识到可以通过这样一种方式来构造序列 $X$ 和 $Y$：即不可能产生任何包含 $w$ 个或更多匹配区的比对，那么问题就变得易于处理了。例如，如果我们从诸如 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的字母表中构造序列 $X$ 和 $Y$，使得其中没有长度为 $w$ 的子串是同聚物（例如 $\\mathrm{A}^w$），那么就不可能形成一个包含 $w$ 个相同字符连续匹配的比对。通过适当地选择不匹配的字符，我们可以确保我们设计的反种子比对，在构造上，就是针对这些特定序列的最优比对。因此，问题简化为找到一个能达到目标分数 $S_{\\min}$ 的、可实现的反种子比对的最小长度。\n\n这是一个经典的动态规划问题。我们旨在寻找最小长度 $L$，使得该长度的反种子比对的最大可能分数（我们称之为 $S_{\\text{max}}(L)$）满足 $S_{\\text{max}}(L) \\ge S_{\\min}$。我们可以为 $i=1, 2, 3, \\dots$ 迭代计算 $S_{\\text{max}}(i)$，并在第一个满足分数要求的 $i$ 处停止。\n\n为了构建动态规划，我们必须区分以匹配列结尾的比对和以非匹配列（一个“中断符”，breaker）结尾的比对。这是因为一个新的匹配区只能在一个中断符之后开始。让我们为动态规划定义两种状态：\n1. $S_M(i)$：长度为 $i$ 且以匹配结尾的反种子比对的最大分数。\n2. $S_B(i)$：长度为 $i$ 且以中断符（错配或空位列）结尾的反种子比对的最大分数。\n\n长度为 $i$ 的比对的总体最高分则是 $dp[i] = \\max(S_M(i), S_B(i))$。我们初始化 $dp[0] = 0$，代表一个长度为零、分数为零的比对，这可以被视为以“中断符”状态结束，因此 $S_B(0)=0$。所有其他动态规划表的条目都初始化为 $-\\infty$。\n\n对于 $i > 0$ 的递推关系如下：\n\n1.  计算 $S_M(i)$：一个长度为 $i$ 且以匹配结尾的比对，必须由一个长度为 $i-k$ 且以中断符结尾的前置比对，后接一段 $k$ 个匹配组成。反种子约束规定 $1 \\le k < w$。\n    $$S_M(i) = \\max_{1 \\le k < w, i \\ge k} \\{ S_B(i-k) + k \\cdot m \\}$$\n\n2.  计算 $S_B(i)$：一个长度为 $i$ 且以中断符结尾的比对可以通过多种方式形成。它可以是一个长度为 $i-1$ 的比对后接一个错配，或者一个长度为 $i-\\ell$ 的比对后接一个长度为 $\\ell$ 的空位。\n    - 如果它以一个错配（长度为 $1$，分数为 $-\\mu$）结尾：分数为 $dp[i-1] - \\mu$。\n    - 如果它以一个空位结尾：这更复杂一些。一个在位置 $i$ 结束的长度为 $\\ell$ 的空位，会为长度为 $i-\\ell$ 的比对分数加上 $-(g + e(\\ell-1))$ 的罚分。为了高效地处理这个问题，我们引入一个辅助 DP 状态 $S_{\\text{GapEnd}}(i)$，表示长度为 $i$ 且以空位列结尾的比对的最大分数。这可以通过递推式 $S_{\\text{GapEnd}}(i) = \\max(dp[i-1] - g, S_{\\text{GapEnd}}(i-1) - e)$ 计算，该递推式考虑了开启一个新空位或扩展一个现有空位。\n    结合以上情况，$S_B(i)$ 的递推式为：\n    $$S_B(i) = \\max(dp[i-1] - \\mu, S_{\\text{GapEnd}}(i))$$\n\n我们从 $i=1, 2, \\dots$ 开始迭代长度，直到一个合理的最大长度 $L_{\\text{max}}$。对每个 $i$，我们计算 $S_{\\text{GapEnd}}(i)$、$S_B(i)$、$S_M(i)$，并最终计算出 $dp[i]$。第一个使 $dp[i] \\ge S_{\\min}$ 成立的 $i$ 值就是我们的最小长度 $L^{\\ast}$。\n\n如果 $S_{\\min}$ 无法达到，则会出现一种特殊情况。这种情况发生在最大可能分数小于 $S_{\\min}$ 时。最高的分数密度是通过将 $w-1$ 个匹配的运行段与最有效（罚分最低）的中断符组合来实现的。如果这种最优重复单元的分数贡献非正，并且单个最大匹配运行段的分数 $(w-1)m$ 小于 $S_{\\min}$，那么目标分数就永远无法达到。这个条件 $\\left( (w-1)m < S_{\\min} \\right) \\land \\left( (w-1)m - \\min(\\mu,g) \\le 0 \\right)$，是一个强有力的指标，表明不存在解，此时 $L^{\\ast} = -1$。我们的动态规划会自然地处理这种情况，因为分数 $dp[i]$ 将无法增长到 $S_{\\min}$。如果循环在没有找到解的情况下完成，结果就是 $-1$。\n\n最终算法如下：\n对每个参数集：\n1.  执行对平凡不存在情况的检查。\n2.  初始化 DP 数组 $dp$、$S_M$、$S_B$ 和 $S_{\\text{GapEnd}}$。设置 $dp[0]=0$ 和 $S_B[0]=0$。\n3.  从 $1$ 到 $L_{\\text{max}}$ 迭代 $i$。在每一步中，使用递推式计算 $S_{\\text{GapEnd}}(i)$、$S_B(i)$、$S_M(i)$和 $dp[i]$。\n4.  如果 $dp[i] \\ge S_{\\min}$，则 $L^{\\ast}=i$；终止并返回 $i$。\n5.  如果循环结束，则未找到解；返回 $-1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (w, m, mu, g, e, S_min)\n        (3, 2, 1, 5, 1, 10),\n        (4, 2, 1, 5, 1, 3),\n        (5, 1, 5, 10, 2, 5),\n        (6, 2, 3, 8, 1, 31),\n        (2, 2, 1, 5, 1, 5),\n    ]\n\n    results = []\n    for params in test_cases:\n        w, m, mu, g, e, S_min = params\n        result = compute_l_star(w, m, mu, g, e, S_min)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_l_star(w, m, mu, g, e, S_min):\n    \"\"\"\n    Computes the minimal alignment length L* for a given parameter set.\n    \"\"\"\n    if S_min = 0:\n        return 0\n\n    # If w=1, no match runs are allowed (max length is 1).\n    # If S_min > 0, it's impossible to achieve with only non-positive scores\n    # from mismatches/gaps.\n    if w == 1:\n        return -1\n    \n    # A necessary condition for a solution to exist when S_min > (w-1)*m\n    # is that it must be possible to increase the score by adding blocks.\n    # The most score-efficient repeating unit is a run of w-1 matches\n    # followed by the best single-column breaker (mismatch or gap of 1).\n    # If this unit's score contribution is not positive, S_min is unreachable.\n    max_score_single_block = (w - 1) * m\n    best_breaker_penalty = min(mu, g)\n    if max_score_single_block  S_min and (max_score_single_block - best_breaker_penalty) = 0:\n        # A more thorough check would also consider longer gaps, but this covers most cases.\n        # If (w-1)m - g = 0, then (w-1)m - (g+e(l-1)) = 0 for l>1.\n        return -1\n\n    # Set a sufficiently large max length to search.\n    L_max = 500\n    neg_inf = -1e18 # Use a large negative number for -infinity\n\n    # dp[i] = max score for an anti-seed alignment of length i\n    dp = np.full(L_max + 1, neg_inf, dtype=np.float64)\n    # S_M[i] = max score for length i, ending in a Match\n    S_M = np.full(L_max + 1, neg_inf, dtype=np.float64)  \n    # S_B[i] = max score for length i, ending in a Breaker (Mismatch/Gap)\n    S_B = np.full(L_max + 1, neg_inf, dtype=np.float64)  \n    # S_GapEnd[i] = max score for length i, ending in a Gap\n    S_GapEnd = np.full(L_max + 1, neg_inf, dtype=np.float64)\n\n    # Base case: alignment of length 0 has score 0 and ends in a \"breaker\" state.\n    dp[0] = 0.0\n    S_B[0] = 0.0\n\n    for i in range(1, L_max + 1):\n        # Max score ending in a gap: from opening a new gap or extending an old one.\n        gap_open_score = dp[i-1] - g\n        gap_extend_score = S_GapEnd[i-1] - e\n        S_GapEnd[i] = max(gap_open_score, gap_extend_score)\n\n        # Max score ending in a breaker: from adding a mismatch or ending in a gap.\n        mismatch_score = dp[i-1] - mu\n        S_B[i] = max(mismatch_score, S_GapEnd[i])\n        \n        # Max score ending in a match: add a run of k matches after a breaker.\n        max_sm_score = neg_inf\n        for k in range(1, w):\n            if i >= k:\n                prev_score = S_B[i-k]\n                if prev_score > neg_inf:\n                   current_sm_score = prev_score + k * m\n                   if current_sm_score > max_sm_score:\n                       max_sm_score = current_sm_score\n        S_M[i] = max_sm_score\n\n        # Overall max score is the maximum of the substates.\n        dp[i] = max(S_M[i], S_B[i])\n\n        if dp[i] >= S_min:\n            return i\n            \n    return -1\n\nsolve()\n```", "id": "2396847"}]}