{"hands_on_practices": [{"introduction": "在序列分析中，掩蔽低复杂度区域并非一个没有代价的操作，它必然伴随着信息丢失。这个练习将指导你运用信息论中的核心概念——自信息（self-information），来精确量化从软掩蔽（soft-masking）转换为硬掩蔽（hard-masking）过程中的信息损失。通过完成这项实践 [@problem_id:2390141]，你将深刻理解在过滤序列以减少统计噪音时，我们所付出的信息代价，并学会如何以定量的方式来评估这一过程。", "problem": "给定脱氧核糖核酸（deoxyribonucleic acid）序列，其中软掩蔽区域由小写字母表示，未掩蔽位置由大写字母表示，两种情况均仅使用字母表 {A, C, G, T}。序列的硬掩蔽版本通过将每个小写字符替换为大写字母 N，并保持每个大写字符 A、C、G 或 T 不变来获得。设核苷酸 A、C、G、T 的背景分布由概率 $p_A, p_C, p_G, p_T$ 指定，其中 $p_A + p_C + p_G + p_T = 1$ 且每个 $p_X \\in (0,1)$。\n\n对于长度为 $n$ 的序列 $s$，在给定的背景分布下，符号 $x \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的自信息定义为 $I(x) = -\\log_2 p_x$。原始序列的总信息定义为\n$$\nI(s) = \\sum_{i=1}^{n} I\\big(x_i\\big),\n$$\n其中 $x_i$ 是 $s$ 中位置 $i$ 处字符的大写形式。将 $s$ 转换为其硬掩蔽版本所导致的信息损失（以比特为单位）定义为\n$$\nL(s) = \\sum_{i \\in \\mathcal{M}} I\\big(x_i\\big),\n$$\n其中 $\\mathcal{M}$ 是 $s$ 中包含小写字母的索引集合（即在硬掩蔽序列中变为N的位置）。换句话说，每个软掩蔽位置贡献了其在给定背景模型下实际核苷酸身份的自信息损失。$I(\\cdot)$、$I(s)$ 和 $L(s)$ 的单位是比特（bits）。\n\n您的任务是编写一个完整的程序，对下面的每个测试用例，将给定的软掩蔽序列转换为硬掩蔽序列（通过将小写 a, c, g, t 替换为 N），并计算信息损失 $L(s)$，以比特表示，并四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n1. 序列： \"ACgtACgt\", 背景概率： $(p_A, p_C, p_G, p_T) = (0.25, 0.25, 0.25, 0.25)$。\n2. 序列： \"aCgTaCgT\", 背景概率： $(p_A, p_C, p_G, p_T) = (0.10, 0.20, 0.30, 0.40)$。\n3. 序列： \"acgt\", 背景概率： $(p_A, p_C, p_G, p_T) = (0.25, 0.25, 0.25, 0.25)$。\n4. 序列： \"ACGTACGT\", 背景概率： $(p_A, p_C, p_G, p_T) = (0.25, 0.25, 0.25, 0.25)$。\n5. 序列： \"aaCCggTT\", 背景概率： $(p_A, p_C, p_G, p_T) = (0.70, 0.10, 0.10, 0.10)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试用例的顺序相同。列表的每个元素必须是等于 $L(s)$（以比特为单位）的浮点数，并四舍五入到恰好 $6$ 位小数。例如：\"[x1,x2,x3,x4,x5]\"。", "solution": "问题陈述已经过严格验证。\n\n已知条件如下：\n1. 一组包含大写（`A`、`C`、`G`、`T`）和小写（`a`、`c`、`g`、`t`）字符的DNA序列。小写字母表示软掩蔽区域。\n2. 一种硬掩蔽的规程，其中小写字母被替换为 `N`。\n3. 每个序列的背景概率分布 $(p_A, p_C, p_G, p_T)$，其中 $p_X \\in (0,1)$ 且 $\\sum p_X = 1$。\n4. 一个核苷酸 $x \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的自信息定义为 $I(x) = -\\log_2 p_x$。\n5. 硬掩蔽时的信息损失 $L(s)$ 的定义是软掩蔽区域中核苷酸的自信息之和：$L(s) = \\sum_{i \\in \\mathcal{M}} I(x_i)$，其中 $\\mathcal{M}$ 是小写字符的索引集合，$x_i$ 是索引 $i$ 处字符的大写等效形式。\n6. 一个包含五个测试用例的测试套件，每个用例都有一个序列和一个概率分布。\n7. 要求计算每个用例的 $L(s)$，四舍五入到六位小数，并概念上执行硬掩蔽转换。\n\n根据所需标准对问题进行验证：\n1. **科学依据**：该问题基于生物信息学和信息论中标准的、成熟的概念。序列掩蔽是处理重复或低复杂度区域的常用技术。应用自信息来量化掩蔽时的数据损失是信息论原理的有效和直接的应用。该问题在科学上是合理的。\n2. **适定性**：该问题以数学精度进行了规定。所有必要的输入（序列、概率）都已提供。定义清晰明确，所需的计算也得到了清楚的描述。每个测试用例都存在唯一的解，并且可以通过算法确定。该问题是适定的。\n3. **客观性**：该问题以正式的、定量的术语陈述，没有任何主观性或意见。该问题是客观的。\n\n结论：该问题是有效的。将提供一个完整且论证充分的解决方案。\n\n任务是计算当一个软掩蔽的DNA序列被转换为硬掩蔽表示时发生的信息损失。这种损失使用信息论的原理进行量化。\n\n软掩蔽序列使用小写字母来表示低复杂度或重复区域。虽然核苷酸的身份是已知的，但它被标记为对于某些分析而言不太可靠或不太重要。硬掩蔽是一个更严格的数据缩减步骤，其中这些核苷酸被一个通用符号 `N` 替换，完全掩盖了它们原始的身份。信息损失是在此过程中丢弃的信息量，以比特为单位度量。\n\n基本量是核苷酸 $x$ 的自信息（或称意外度），由 $I(x) = -\\log_2 p_x$ 给出。这衡量了在一个背景模型下观察到核苷酸 $x$ 的信息含量，其中 $x$ 以概率 $p_x$ 出现。一个稀有的核苷酸（低 $p_x$）具有高自信息，而一个常见的核苷酸（高 $p_x$）则具有低自信息。\n\n对于序列 $s$，其总信息损失表示为 $L(s)$，是所有被软掩蔽的核苷酸的自信息之和。设 $s = s_1s_2...s_n$ 为长度是 $n$ 的序列。设 $\\mathcal{M}$ 是使得 $s_i$ 为小写字母的索引 $i$ 的集合。设 $x_i$ 为 $s_i$ 的大写版本。信息损失精确地是：\n$$\nL(s) = \\sum_{i \\in \\mathcal{M}} I(x_i) = \\sum_{i \\in \\mathcal{M}} (-\\log_2 p_{x_i})\n$$\n\n解决该问题的算法如下：\n1. 对于每个给定的测试用例，包含一个序列 $s$ 和一个概率映射 $\\{p_A, p_C, p_G, p_T\\}$。\n2. 初始化一个变量 `total_loss` 为 $0.0$。\n3. 遍历序列 $s$ 中的每个字符 $c$。\n4. 检查 $c$ 是否为小写字母。\n5. 如果是，将 $c$ 转换为其大写等效形式 $x$。从给定的分布中找到相应的概率 $p_x$。\n6. 计算自信息 $-\\log_2 p_x$ 并将其加到 `total_loss` 中。\n7. 遍历完整个序列后，`total_loss` 的最终值即为信息损失 $L(s)$。\n8. 该值必须格式化为六位小数。\n\n作为一个说明性示例，让我们考虑测试用例2：\n- 序列 $s = \\text{\"aCgTaCgT\"}$。\n- 背景概率： $p_A = 0.10, p_C = 0.20, p_G = 0.30, p_T = 0.40$。\n\n软掩蔽位置包含字符 `a`、`g`、`a`、`g`。相应的大写核苷酸是 `A`、`G`、`A`、`G`。信息损失是这四个核苷酸的自信息之和。\n$$\nL(s) = I(\\text{A}) + I(\\text{G}) + I(\\text{A}) + I(\\text{G}) = 2 \\cdot I(\\text{A}) + 2 \\cdot I(\\text{G})\n$$\n使用所提供的概率：\n$$\nI(\\text{A}) = -\\log_2(p_A) = -\\log_2(0.10)\n$$\n$$\nI(\\text{G}) = -\\log_2(p_G) = -\\log_2(0.30)\n$$\n总损失是：\n$$\nL(s) = 2 \\cdot (-\\log_2(0.10)) + 2 \\cdot (-\\log_2(0.30))\n$$\n使用换底公式 $\\log_2(x) = \\frac{\\ln(x)}{\\ln(2)}$：\n$$\n-\\log_2(0.10) \\approx -(-3.321928) \\approx 3.321928 \\text{ 比特}\n$$\n$$\n-\\log_2(0.30) \\approx -(-1.736966) \\approx 1.736966 \\text{ 比特}\n$$\n因此，总信息损失是：\n$$\nL(s) \\approx 2 \\cdot (3.321928) + 2 \\cdot (1.736966) = 6.643856 + 3.473932 = 10.117788 \\text{ 比特}\n$$\n四舍五入到六位小数，结果是 10.117788。相应的硬掩蔽序列将是 `\"NCGNCNGT\"`，但最终输出只需要数值损失值。对所有测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the information loss problem for a suite of test cases.\n    For each case, it computes the information loss incurred when converting a\n    soft-masked DNA sequence to a hard-masked one.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sequence, probability_dict)\n    test_cases = [\n        (\n            \"ACgtACgt\",\n            {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}\n        ),\n        (\n            \"aCgTaCgT\",\n            {'A': 0.10, 'C': 0.20, 'G': 0.30, 'T': 0.40}\n        ),\n        (\n            \"acgt\",\n            {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}\n        ),\n        (\n            \"ACGTACGT\",\n            {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}\n        ),\n        (\n            \"aaCCggTT\",\n            {'A': 0.70, 'C': 0.10, 'G': 0.10, 'T': 0.10}\n        ),\n    ]\n\n    results = []\n    for seq, probs in test_cases:\n        information_loss = 0.0\n        \n        # This part conceptually builds the hard-masked sequence,\n        # but is not strictly needed for the final output value.\n        # hard_masked_seq_list = []\n\n        # Iterate through each character of the sequence.\n        for char in seq:\n            # Check if the character is lowercase (soft-masked).\n            if 'a' <= char <= 'z':\n                # This is a soft-masked position.\n                nucleotide = char.upper()\n                \n                # Get the background probability of this nucleotide.\n                p = probs[nucleotide]\n                \n                # Calculate self-information I(x) = -log2(p) and add to total loss.\n                if p > 0:\n                    information_loss -= np.log2(p)\n\n                # For hard-masking, this position becomes 'N'.\n                # hard_masked_seq_list.append('N')\n            # else:\n                # Unmasked characters remain unchanged.\n                # hard_masked_seq_list.append(char)\n        \n        # The hard-masked sequence would be: \"\".join(hard_masked_seq_list)\n        \n        results.append(f\"{information_loss:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2390141"}, {"introduction": "现实世界中的低复杂度区域检测算法远比单一阈值的滤波器要精妙。本练习将引导你从头开始实现著名 SEG 算法的一个简化版本，它的核心在于一个巧妙的双阈值系统：一个用于触发（trigger）的低阈值 $H(s) \\le \\tau_1$ 和一个用于延伸（extension）的较高阈值 $H(s) \\le \\tau_2$。通过实现这项练习 [@problem_id:2390180]，你将亲身体验生物信息学工具如何通过这种机制在灵敏度（sensitivity）和特异性（specificity）之间取得平衡，从而实现对信号的稳健检测。", "problem": "您将实现 SEG (Segment) 算法的一种简化的、自包含的变体，用于检测蛋白质序列中的低复杂度区域。该实现必须依赖于基本原理：通过香农信息和滑动窗口分析来衡量的局部成分变异性。您的程序将使用固定的氨基酸字母表大小和窗口长度参数，以及一个双阈值触发-延伸机制。程序必须能直接运行，并为提供的测试套件打印结果。\n\n基本原理与定义：\n- 将蛋白质序列视为一个字符串 $S$，其构建于大小为 $A = 20$ 的标准氨基酸字母表 $\\mathcal{A}$ 之上。令 $|S| = L$ 表示序列的长度。\n- 对于固定的窗口长度 $W$，定义有效窗口起始索引的集合为 $s \\in \\{0, 1, \\dots, L - W\\}$。起始于 $s$ 的窗口覆盖索引为 $\\{s, s+1, \\dots, s+W-1\\}$ 的残基。\n- 对于每个窗口，令 $c_i(s)$ 为起始于 $s$ 的窗口中氨基酸 $i \\in \\{1,\\dots,A\\}$ 的计数。定义经验频率 $p_i(s) = c_i(s)/W$。该窗口的香农熵为\n$$\nH(s) = -\\sum_{i=1}^{A} p_i(s)\\,\\log_2 p_i(s),\n$$\n约定 $0\\log_2 0 = 0$。此 $H(s)$ 的取值范围是 $0 \\le H(s) \\le \\log_2 W$，并且随着窗口成分变得更加单一或重复，其值会减小。\n- 简化的 SEG 逻辑使用两个阈值 $\\tau_1$（触发）和 $\\tau_2$（延伸），且 $\\tau_1 \\le \\tau_2$。如果 $H(s) \\le \\tau_1$，则窗口索引 $s$ 是一个触发点。如果对于所有 $s \\in [a,b]$ 都有 $H(s) \\le \\tau_2$，则一个最大连续窗口索引块 $[a,b]$ 是可延伸的。一个低复杂度区域由任何满足以下条件的最大块 $[a,b]$ 形成：该块包含至少一个触发索引 $t \\in [a,b]$（因此 $H(t) \\le \\tau_1$），并且无法在不违反 $H \\le \\tau_2$ 的情况下向左或向右进一步延伸。\n- 将窗口映射到残基：任何连续的窗口块 $[a,b]$ 都映射到一个单一的连续残基区间 $[r_{\\min}, r_{\\max}] = [a, b+W-1]$。被屏蔽的残基索引集合是所有合格块对应区间的并集。在枚举索引之前，必须将重叠的残基区间合并为单个区间。\n\n算法任务：\n- 输入是隐式的：您的代码必须使用标准的 $20$ 种氨基酸的字母表 $\\mathcal{A}$，使用以 2 为底的对数计算 $H(s)$，并应用如上定义的双阈值触发-延伸方案。\n- 边界情况：如果 $L < W$，则没有有效的窗口，因此被屏蔽的集合为空。如果没有 $H(s)$ 低于 $\\tau_1$，即使某些 $H(s) \\le \\tau_2$，也不报告任何区域。\n- 每个测试用例的输出是在合并重叠区间并取所有合格块的并集之后，排序后的被屏蔽残基索引列表（从零开始）。如果没有残基被屏蔽，则输出空列表。\n\n测试套件：\n使用以下固定的测试用例，每个用例由 $(S, W, \\tau_1, \\tau_2)$ 定义：\n- 测试用例 1：$S =$ \"ACDEFGHIKLMAAAAAAAAAAACDEFGHIKLM\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$。\n- 测试用例 2：$S =$ \"ACDEFGHIKLMNPQRSTVWY\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$。\n- 测试用例 3：$S =$ \"AAAAACCCCC\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$。\n- 测试用例 4：$S =$ \"AAAAAAAAAAAACDEFGHIKLMN\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$。\n- 测试用例 5：$S =$ \"ACDEFGHIKLMKKKKKKKKKKCDEFGHIKLMAAAAAAAA\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$。\n\n要求与限制：\n- 在计数 $c_i(s)$ 时，仅使用大小为 $A=20$ 的标准氨基酸字母表 $\\mathcal{A}$；计数时忽略任何不在 $\\mathcal{A}$ 中的字符，但所提供的序列仅使用标准氨基酸。\n- 使用以 2 为底的对数计算 $H(s)$，并使用实数算术进行计算。\n- 在构建低复杂度区域时，识别满足 $H(s) \\le \\tau_2$ 并且包含至少一个 $H(t) \\le \\tau_1$ 的触发点 $t$ 的最大连续窗口块 $[a,b]$。每个这样的块映射到一个残基区间 $[a, b+W-1]$。合并重叠的残基区间，并以排序后的索引列表形式输出其并集。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、逗号分隔的列表形式的结果，该列表的每个元素本身是对应测试用例的、用方括号括起来的、逗号分隔的被屏蔽的从零开始的索引列表，且不含任何空格。例如，如果两个测试用例产生的被屏蔽索引分别为 $[0,1]$ 和 $[]$，则单行输出应为 \"[[0,1],[]]\"。", "solution": "我们从一个基本原理出发：局部序列的复杂度可以通过香农熵来捕捉，这是信息论中一个经过充分检验的不确定性度量。对于一个大小为 $A$ 的字母表上的离散分布 $(p_1,\\dots,p_A)$，香农熵定义为\n$$\nH = -\\sum_{i=1}^{A} p_i \\log_2 p_i,\n$$\n约定 $0\\log_2 0 = 0$。在生物序列的窗口中，$p_i$ 是窗口中观测到的残基类型 $i$ 的经验比例。重复性或成分有偏的窗口具有较低的 $H$ 值，而成分多样的窗口则趋向于较高的 $H$ 值，如果长度为 $W$ 的窗口中最多有 $W$ 个不同符号均匀出现，其 $H$ 值最高可达 $\\log_2 W$。\n\nSEG 的核心机制是一个双阈值决策，用以稳定区域检测：当一个窗口的复杂度 $H(s)$ 足够低时，一个较低的触发阈值 $\\tau_1$ 开始进行屏蔽；而一个较高的延伸阈值 $\\tau_2$ 则允许该区域扩展通过中等低复杂度的窗口，而不会频繁地开启和关闭。这种类似滞后效应的设计可以防止当局部波动发生在单一阈值附近时检测结果出现碎片化。\n\n算法推导：\n1. 表示在标准氨基酸字母表 $\\mathcal{A}$ 上的序列 $S$，其中 $A = 20$。令 $|S| = L$。\n2. 固定窗口长度 $W$。有效的窗口起始点为 $s \\in \\{0,1,\\dots,L-W\\}$。对于每个 $s$，计算在索引 $\\{s,\\dots,s+W-1\\}$ 范围内 $i \\in \\{1,\\dots,A\\}$ 的计数 $c_i(s)$。定义 $p_i(s) = c_i(s)/W$。\n3. 使用以下公式计算每个窗口的熵：\n$$\nH(s) = -\\sum_{i=1}^{A} p_i(s)\\log_2 p_i(s).\n$$\n只有 $p_i(s) > 0$ 的项对结果有贡献。\n4. 识别所有最大连续的窗口索引块 $[a,b]$，使得对于所有 $s \\in [a,b]$ 都有 $H(s) \\le \\tau_2$，并且存在至少一个触发索引 $t \\in [a,b]$ 满足 $H(t) \\le \\tau_1$。最大性意味着我们无法在不违反 $H \\le \\tau_2$ 或超出范围的情况下将 $[a,b]$ 延伸至 $[a-1,b]$ 或 $[a,b+1]$。\n5. 将每个窗口块 $[a,b]$ 映射到相应的残基区间 $[r_{\\min}, r_{\\max}] = [a, b + W - 1]$。这是因为在窗口集合 $\\{[s, s+W-1] : s \\in [a,b]\\}$ 上的并集恰好是从最小的起始点 $a$ 到最大的结束点 $b+W-1$ 的区间。形式上，对于任何 $x \\in [a, b+W-1]$，存在一个 $s \\in [a,b]$ 使得 $x \\in [s, s+W-1]$，这证明了集合的相等性。\n6. 合并所有合格块的重叠或相邻的残基区间，形成它们的并集。将结果集合枚举为排序后的从零开始的索引列表，以获得该序列的屏蔽区域。\n7. 边界情况：如果 $L < W$，则没有有效的窗口，结果为空集。\n\n为何这些阈值是合适的：\n- 对于 $W = 12$，可能的最大熵受限于 $\\log_2 W \\approx 3.585$。选择 $\\tau_1 = 1.8$ 和 $\\tau_2 = 2.2$ 将触发阈值设置在远低于典型高复杂度窗口的位置，而延伸阈值则对中等变异性提供了一定的容忍度。由一两种残基主导的窗口其 $H(s)$ 将舒适地低于 $\\tau_1$，确保可靠的触发。包含许多不同残基的窗口其 $H(s)$ 将高于 $\\tau_2$，从而防止错误的延伸。\n\n计算考量：\n- 一个朴素的逐窗口计数方法每个窗口的时间复杂度是 $\\mathcal{O}(A W)$，在整个序列上则是 $\\mathcal{O}(A W (L-W+1))$。对于所提供的小型测试用例，这种方法既高效又清晰。通过滑动更新进行优化是可能的，但非必需。\n- 区间合并可以在 $\\mathcal{O}(K \\log K)$ 时间内实现，其中 $K$ 是区间数量，在这里 $K$ 很小。\n\n应用于测试套件：\n- 测试用例 1 包含一个内部连续的多个 A 残基；跨越此区域的窗口具有较低的 $H(s)$ 并满足 $H(s) \\le \\tau_1$，从而触发屏蔽并进行延伸，直到两侧的 $H(s) > \\tau_2$ 为止，在内部产生一个连续的被屏蔽片段。\n- 测试用例 2 将不同的氨基酸广泛分布；窗口中的熵接近 $\\log_2 12$，超过了 $\\tau_2$，因此没有窗口满足触发条件，结果为空。\n- 测试用例 3 的 $L < W$，因此不存在窗口，结果为空。\n- 测试用例 4 在起始位置放置了一个低复杂度区域；最早的窗口具有非常低的 $H(s)$ 并触发屏蔽，然后随着 $H(s)$ 增加，延伸停止。\n- 测试用例 5 包含两个分离的低复杂度片段（一段 K 残基和一段 A 残基），在合并每个片段内的窗口后，产生两个被屏蔽的区间。\n\n最终程序为每个窗口计算 $H(s)$，通过双阈值机制识别块，将其映射到残基区间，合并重叠部分，并为每个测试用例打印被屏蔽的索引列表。输出是代表所有测试用例的嵌套列表的一行，不含空格，如规范所示。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom typing import List, Tuple\n\nAA_ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"\nAA_INDEX = {aa: i for i, aa in enumerate(AA_ALPHABET)}\nA = 20  # size of amino acid alphabet\n\ndef shannon_entropy_window(window: str, W: int) -> float:\n    # Count only standard amino acids\n    counts = [0] * A\n    for ch in window:\n        idx = AA_INDEX.get(ch, None)\n        if idx is not None:\n            counts[idx] += 1\n    H = 0.0\n    for c in counts:\n        if c > 0:\n            p = c / W\n            H -= p * math.log2(p)\n    return H\n\ndef compute_window_entropies(S: str, W: int) -> List[float]:\n    L = len(S)\n    if L < W:\n        return []\n    Hs = []\n    for s in range(L - W + 1):\n        win = S[s:s+W]\n        Hs.append(shannon_entropy_window(win, W))\n    return Hs\n\ndef find_blocks(Hs: List[float], tau1: float, tau2: float) -> List[Tuple[int, int]]:\n    blocks = []\n    n = len(Hs)\n    s = 0\n    while s < n:\n        if Hs[s] <= tau2:\n            a = s\n            has_trigger = (Hs[s] <= tau1)\n            s += 1\n            while s < n and Hs[s] <= tau2:\n                if Hs[s] <= tau1:\n                    has_trigger = True\n                s += 1\n            b = s - 1\n            if has_trigger:\n                blocks.append((a, b))\n        else:\n            s += 1\n    return blocks\n\ndef merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    if not intervals:\n        return []\n    intervals.sort()\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start <= last_end + 1:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n\ndef blocks_to_residue_intervals(blocks: List[Tuple[int, int]], W: int) -> List[Tuple[int, int]]:\n    # Each window-block [a,b] maps to residue interval [a, b+W-1]\n    res_intervals = [(a, b + W - 1) for (a, b) in blocks]\n    return merge_intervals(res_intervals)\n\ndef intervals_to_indices(intervals: List[Tuple[int, int]]) -> List[int]:\n    indices = []\n    for a, b in intervals:\n        indices.extend(range(a, b + 1))\n    return indices\n\ndef seg_mask_indices(S: str, W: int, tau1: float, tau2: float) -> List[int]:\n    L = len(S)\n    if L < W:\n        return []\n    Hs = compute_window_entropies(S, W)\n    blocks = find_blocks(Hs, tau1, tau2)\n    residue_intervals = blocks_to_residue_intervals(blocks, W)\n    indices = intervals_to_indices(residue_intervals)\n    return indices\n\ndef serialize_no_spaces(obj) -> str:\n    # Serialize lists of ints (possibly nested) with no spaces\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(serialize_no_spaces(x) for x in obj) + \"]\"\n    elif isinstance(obj, bool):\n        return \"true\" if obj else \"false\"\n    elif isinstance(obj, (int, float)):\n        # For floats, ensure a consistent representation (not used here)\n        return str(obj)\n    else:\n        # Fallback for other simple types\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case: (S, W, tau1, tau2)\n        (\"ACDEFGHIKLMAAAAAAAAAAACDEFGHIKLM\", 12, 1.8, 2.2),\n        (\"ACDEFGHIKLMNPQRSTVWY\", 12, 1.8, 2.2),\n        (\"AAAAACCCCC\", 12, 1.8, 2.2),\n        (\"AAAAAAAAAAAACDEFGHIKLMN\", 12, 1.8, 2.2),\n        (\"ACDEFGHIKLMKKKKKKKKKKCDEFGHIKLMAAAAAAAA\", 12, 1.8, 2.2),\n    ]\n\n    results = []\n    for S, W, tau1, tau2 in test_cases:\n        masked = seg_mask_indices(S, W, tau1, tau2)\n        results.append(masked)\n\n    # Final print statement in the exact required format (no spaces).\n    print(serialize_no_spaces(results))\n\nsolve()\n```", "id": "2390180"}, {"introduction": "对算法进行严格的测试和基准评估是计算生物学中不可或缺的一环。这项高级实践 [@problem_id:2390167] 挑战你构建一个能够生成复杂度可调的合成 DNA 序列的程序。通过创建一个从完全随机到高度重复的序列谱，并用香农熵滤波器对其进行分析，你将学会如何系统地评估一个算法在不同数据特性下的表现，这对于开发和验证新的生物信息学工具至关重要。", "problem": "您的任务是形式化并实现一个可生成具有可调复杂度水平的合成脱氧核糖核酸 (DNA) 序列的、有原则的生成器，并量化一个简单的低复杂度区域 (LCR) 过滤器对所生成序列的响应。其目的是为计算生物学和生物信息学领域中过滤低复杂度区域创建一个可复现的基准测试。您的程序必须使用一个与控制重复性的参数相关联的概率模型来生成序列，然后使用滑动窗口香农熵过滤器对这些序列进行评估。\n\n基本定义与要求：\n- 考虑核苷酸字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。DNA 序列是基于此字母表、长度为 $L$ 的字符串。\n- 低复杂度区域 (LCR) 过滤器将基于香农熵。对于任何具有经验碱基频率 $\\{p_{\\mathrm{A}},p_{\\mathrm{C}},p_{\\mathrm{G}},p_{\\mathrm{T}}\\}$ 的窗口，其香农熵 $H$（单位为比特）定义为\n$$\nH \\equiv - \\sum_{b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} p_b \\log_2 p_b,\n$$\n约定当 $p_b=0$ 时，该项对总和的贡献为 $0$。对于 4 种核苷酸的均匀分布，每个窗口的最大熵为 2 比特。\n- 如果存在至少一个覆盖某个位置的窗口，其熵 $H < \\tau$，则该位置被视为被屏蔽 (masked)，其中 $\\tau$ 是用户指定的熵阈值（单位为比特）。被屏蔽位置的比例定义为被屏蔽的索引数量除以 $L$，并且必须以 $[0,1]$ 区间内的小数形式报告。\n- 窗口按如下方式提取。如果 $L \\ge w$，则从序列的起始位置到结束位置，以步长 $1$ 滑动一个长度为 $w$ 的窗口，产生 $(L-w+1)$ 个窗口。如果 $L < w$，则定义一个包含整个序列（长度为 $L$）的单一窗口。每个窗口的平均熵是以这种方式评估的所有窗口的熵 $H$ 的算术平均值。\n\n具有可调复杂度的序列生成器：\n- 设 $\\lambda \\in [0,1]$ 为重复性参数。生成器是一个混合模型，在每个位置的层面上，混合了一个确定性重复基序源和一个均匀独立同分布 (i.i.d.) 源。\n- 固定一个整数基序长度 $m \\ge 1$。首先，通过从 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 中独立均匀地抽取每个核苷酸，来采样一个长度为 $m$ 的基序 $M$。然后，对于每个位置 $i \\in \\{0,1,\\dots,L-1\\}$：\n    - 以概率 $\\lambda$ 输出 $M[i \\bmod m]$。\n    - 以概率 $(1-\\lambda)$ 输出一个从 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 中抽取的 i.i.d. 均匀核苷酸。\n- 直观解释：$\\lambda = 0$ 产生一个最大程度随机的 i.i.d. 均匀序列，而 $\\lambda = 1$ 产生一个由 $M$ 决定的近乎完美的重复序列（除了 $M$ 的初始采样过程）。\n- 为确保可复现性，所有随机抽取（基序采样和 i.i.d. 生成）都必须使用在程序开始时设置为 $s=12345$ 的固定伪随机数生成器种子来执行，并且在不同测试用例之间不得重新设定种子。\n\n您必须实现的内容：\n- 实现上述的生成器。\n- 实现上述定义的滑动窗口香农熵计算和屏蔽规则。\n- 对每个测试用例，生成序列并计算：\n    1. 每个窗口的平均香农熵（单位为比特）。\n    2. 被屏蔽位置的比例（$[0,1]$ 区间内的小数）。\n- 将这两个量均四舍五入到小数点后 4 位。\n\n测试套件：\n您的程序必须按顺序运行以下测试用例。每个用例是一个元组 $(L,\\lambda,m,w,\\tau)$：\n- Case $1$: $(500, 0.0, 3, 50, 1.5)$\n- Case $2$: $(500, 1.0, 2, 50, 1.5)$\n- Case $3$: $(500, 0.5, 3, 50, 1.5)$\n- Case $4$: $(257, 0.8, 7, 25, 1.2)$\n- Case $5$: $(120, 0.3, 1, 10, 1.8)$\n- Case $6$: $(1, 1.0, 1, 1, 0.1)$\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个长度为 6 的列表。每个元素是形式为 $[E,F]$ 的列表，其中 $E$ 是对应测试用例的每个窗口的平均熵（四舍五入到 4 位小数），$F$ 是被屏蔽位置的比例（四舍五入到 4 位小数）。\n- 输出必须是严格遵循以下格式的单行文本：\n\"[ [E1,F1],[E2,F2],...,[E6,F6] ]\"\n- 数值必须四舍五入到 4 位小数。比例必须是 $[0,1]$ 区间内的小数。\n\n科学依据与约束：\n- 使用所述的香non熵定义和经验碱基频率。这是一个标准的、经过充分检验的度量，它与序列的复杂度相关。\n- 使用所述的混合生成器来实现一个基于概率论和信息论的、可调的复杂度谱系。\n- 确保所有计算在数值上是稳定的，并且在逻辑上与上述定义一致。", "solution": "所提出的问题是计算序列分析领域一个定义明确的练习。它具有科学依据，没有矛盾之处，并且所有术语都得到了清晰的定义。我们将着手进行其形式化求解。目标是构建一个可生成具有可调复杂度的脱氧核糖核酸 (DNA) 序列的合成数据生成器，并测量一个标准的低复杂度区域 (LCR) 过滤器对此的响应。\n\n首先，我们来解决序列生成过程。DNA 序列是一个定义在字母表 $\\mathcal{A} = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 上、长度为 $L$ 的字符串。生成器是一个由参数 $\\lambda \\in [0, 1]$ 控制的概率混合模型。该参数决定了是从一个周期性的、确定性的源抽取核苷酸，还是从一个独立同分布 (i.i.d.) 的均匀随机源中抽取的概率。\n\n生成序列的算法如下：\n1. 使用一个固定的整数种子 $s = 12345$ 来初始化一个伪随机数生成器 (RNG)。这确保了结果的可复现性。\n2. 生成一个给定整数长度 $m \\ge 1$ 的基序序列 $M$。$M$ 中的每个核苷酸都是从 $\\mathcal{A}$ 中独立且均匀地采样得到的。\n3. 逐个位置地构建长度为 $L$ 的最终序列 $S$。对于每个索引 $i \\in \\{0, 1, \\dots, L-1\\}$：\n    a. 从 $[0, 1)$ 上的均匀分布中抽取一个随机变量 $u$。\n    b. 如果 $u < \\lambda$，序列中位置 $i$ 的核苷酸 $S[i]$ 被赋予来自基序的值：$S[i] \\leftarrow M[i \\bmod m]$。这是确定性部分。\n    c. 如果 $u \\ge \\lambda$，核苷酸 $S[i]$ 被赋予一个从 $\\mathcal{A}$ 中独立均匀采样的新值。这是 i.i.d. 随机部分。\n\n$\\lambda = 0$ 会产生一个纯粹的 i.i.d. 序列，表现出最大的复杂度。相反，$\\lambda = 1$ 会生成一个作为基序 $M$ 完美重复的序列，代表最小的复杂度。介于 0 和 1 之间的 $\\lambda$ 值则在这两个极端之间进行插值。\n\n接下来，我们使用香农熵来形式化 LCR 分析方法。对于任何子序列（一个窗口），我们首先计算四种核苷酸的经验频率。设一个长度为 $W_{\\text{len}}$ 的窗口包含碱基 $b \\in \\mathcal{A}$ 的出现次数为 $n_b$。其经验概率（或频率）为 $p_b = n_b / W_{\\text{len}}$。该窗口的香农熵 $H$（以比特为单位）由以下公式给出：\n$$\nH = - \\sum_{b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} p_b \\log_2 p_b\n$$\n按照惯例，任何 $p_b = 0$ 的项其值为 0，因为 $\\lim_{p \\to 0^+} p \\log_2 p = 0$。对于此字母表，可能的最大熵为 $H_{\\text{max}} = \\log_2(4) = 2$ 比特，对应于所有 $b$ 的 $p_b = 1/4$ 的均匀分布。接近 0 的低熵值表示缺乏多样性，即低复杂度。\n\n对完整序列 $S$ 的分析是通过滑动窗口方法进行的。一个窗口是长度为 $w$ 的子序列。\n- 如果序列长度 $L$ 大于或等于窗口长度 $w$ ($L \\ge w$)，我们以步长 1 滑动窗口。这将产生一组 $N_{\\text{win}} = L - w + 1$ 个重叠的窗口。第 $j$ 个窗口（对于 $j \\in \\{0, 1, \\dots, L-w\\}$）对应于子序列 $S[j \\dots j+w-1]$。\n- 如果 $L < w$，则在包含整个序列 $S$ 的单个窗口上进行分析。在这种情况下，$N_{\\text{win}} = 1$。\n\n对于 $N_{\\text{win}}$ 个窗口中的每一个，我们计算其香农熵 $H_j$。然后导出两个度量指标：\n1. 每个窗口的平均香农熵 $\\bar{H}$，是各个窗口熵的算术平均值：\n$$\n\\bar{H} = \\frac{1}{N_{\\text{win}}} \\sum_{j=0}^{N_{\\text{win}}-1} H_j\n$$\n2. 被屏蔽位置的比例 $F$。如果序列 $S$ 中的一个位置 $i$ 属于至少一个熵 $H_j$ 低于指定阈值 $\\tau$ 的窗口，则该位置被定义为“被屏蔽 (masked)”。设 $W_j$ 是第 $j$ 个窗口所覆盖的索引集合。如果存在一个 $j$ 使得 $i \\in W_j$ 且 $H_j < \\tau$，则位置 $i$ 被屏蔽。比例 $F$ 是唯一的被屏蔽位置的总数除以总序列长度 $L$。\n\n为实现这一点，我们创建一个长度为 $L$、初始值为 `False` 的布尔数组 `is_masked`。对于从索引 $j_{start}$ 开始、长度为 $w'$ 的每个窗口 $j$，如果其熵 $H_j < \\tau$，我们将索引从 $j_{start}$ 到 $j_{start} + w' - 1$ 的 `is_masked` 值设为 `True`。最终的比例是这个布尔数组的和除以 $L$。\n\n实现将处理每个测试用例 $(L, \\lambda, m, w, \\tau)$，首先根据概率模型生成序列，然后计算窗口熵，最后计算 $\\bar{H}$ 和 $F$。所有随机操作将使用以指定种子 $s=12345$ 初始化的单一、持久的 RNG 实例。$\\bar{H}$ 和 $F$ 的最终数值结果必须四舍五入到小数点后 4 位。\n\n这整个过程在算法上是明确的，在计算上是可行的，为所述问题提供了一个正确且可复现的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import entropy as shannon_entropy\n\ndef solve():\n    \"\"\"\n    Generates synthetic DNA sequences with tunable complexity and analyzes them\n    with a Shannon entropy-based low-complexity region (LCR) filter.\n    \"\"\"\n    # Initialize the pseudorandom number generator with a fixed seed for reproducibility.\n    # This RNG instance will be used for all random operations across all test cases.\n    RNG = np.random.default_rng(seed=12345)\n    \n    # Define the DNA nucleotide alphabet.\n    ALPHABET = np.array(['A', 'C', 'G', 'T'])\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, lambda, m, w, tau)\n    test_cases = [\n        (500, 0.0, 3, 50, 1.5),\n        (500, 1.0, 2, 50, 1.5),\n        (500, 0.5, 3, 50, 1.5),\n        (257, 0.8, 7, 25, 1.2),\n        (120, 0.3, 1, 10, 1.8),\n        (1, 1.0, 1, 1, 0.1),\n    ]\n\n    final_results = []\n    \n    for L, lambda_param, m, w, tau in test_cases:\n        # 1. Sequence Generation\n        \n        # Generate the random motif M of length m.\n        motif = RNG.choice(ALPHABET, size=m)\n\n        # Generate the sequence of length L using the mixture model.\n        sequence = np.empty(L, dtype='<U1')\n        random_draws = RNG.random(size=L)\n        random_bases = RNG.choice(ALPHABET, size=L)\n        for i in range(L):\n            if random_draws[i] < lambda_param:\n                sequence[i] = motif[i % m]\n            else:\n                sequence[i] = random_bases[i]\n        \n        # 2. LCR Analysis: Windowing and Entropy Calculation\n\n        # Extract windows from the sequence.\n        windows = []\n        if L >= w:\n            num_windows = L - w + 1\n            for i in range(num_windows):\n                windows.append(sequence[i:i+w])\n        else:  # L < w\n            num_windows = 1\n            windows.append(sequence)\n\n        # Calculate Shannon entropy for each window.\n        window_entropies = []\n        for win in windows:\n            if len(win) == 0:\n                # This case should not occur with L >= 1.\n                H = 0.0\n            else:\n                # Count base occurrences and compute frequencies.\n                _, counts = np.unique(win, return_counts=True)\n                # scipy.stats.entropy requires a probability distribution.\n                # If a window contains only a subset of ALPHABET, we need to map counts correctly.\n                base_counts = {base: 0 for base in ALPHABET}\n                win_bases, win_counts = np.unique(win, return_counts=True)\n                for base, count in zip(win_bases, win_counts):\n                    base_counts[base] = count\n                \n                probs = np.array(list(base_counts.values())) / len(win)\n                H = shannon_entropy(probs, base=2)\n            \n            window_entropies.append(H)\n        \n        # Calculate the average per-window entropy.\n        avg_entropy = np.mean(window_entropies) if window_entropies else 0.0\n\n        # 3. Masking based on Entropy Threshold\n\n        # Initialize a boolean array to track masked positions.\n        masked_positions = np.zeros(L, dtype=bool)\n        \n        # Determine which sequence positions are masked.\n        if L >= w:\n            window_indices = range(L - w + 1)\n            window_length = w\n        else:\n            window_indices = [0]\n            window_length = L\n\n        for i, H in zip(window_indices, window_entropies):\n            if H < tau:\n                masked_positions[i : i + window_length] = True\n        \n        # Calculate the fraction of masked positions.\n        masked_fraction = np.sum(masked_positions) / L if L > 0 else 0.0\n\n        # Append rounded results for the current test case.\n        rounded_avg_entropy = round(avg_entropy, 4)\n        rounded_masked_fraction = round(masked_fraction, 4)\n        final_results.append([rounded_avg_entropy, rounded_masked_fraction])\n\n    # 4. Final Output Formatting\n    # Construct the output string exactly as specified.\n    result_str = \",\".join([f\"[{E},{F}]\" for E, F in final_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2390167"}]}