{"hands_on_practices": [{"introduction": "理论的生命力在于实践。要真正掌握间隔种子的威力，第一步就是将其核心算法付诸实现。本练习将指导您将一个基于特定模式的DNA片段转化为一个唯一的数值哈希值。这个过程是所有基于种子比对策略的基石，它要求您将一个精确的数学定义（[@problem_id:2441094]）转化为高效、准确的计算程序，这是生物信息学中最基础也是最重要的计算任务之一。", "problem": "给定脱氧核糖核酸（DNA）字母表 $\\{A,C,G,T\\}$ 上的间隔种子哈希的形式化定义。一个间隔种子模式是一个长度为 $L$ 的二进制字符串 $s$，其中至少包含一个 $1$；$s$ 中 $1$ 符号的数量是词长参数 $w$。对于长度为 $n \\geq L$ 的DNA字符串 $x$，考虑其每个长度为 $L$ 的连续子串（窗口）$x[i\\,..\\,i+L-1]$，其中 $i \\in \\{0,1,\\dots,n-L\\}$。定义关心位置的索引集合为 $P = \\{j \\in \\{0,1,\\dots,L-1\\} \\mid s[j] = 1\\}$，并按严格递增顺序列出为 $P = (p_0,p_1,\\dots,p_{w-1})$。定义一个符号到数字的映射 $\\phi:\\{A,C,G,T\\} \\to \\{0,1,2,3\\}$，具体为 $\\phi(A)=0$、$\\phi(C)=1$、$\\phi(G)=2$、$\\phi(T)=3$。一个窗口 $x[i\\,..\\,i+L-1]$ 关于 $s$ 的间隔种子哈希是一个4进制整数\n$$\nH_s\\big(x[i\\,..\\,i+L-1]\\big) \\;=\\; \\sum_{t=0}^{w-1} \\phi\\big(x[i+p_t]\\big)\\cdot 4^{\\,w-1-t}.\n$$\n所有字符串将仅包含字母 $A$、$C$、$G$ 和 $T$。所有索引均为从0开始计数。所有算术运算均在整数上进行。\n\n任务：实现一个程序，对下面的每个测试用例，使用上述定义，按 $i$ 递增的顺序计算每个窗口 $x[i\\,..\\,i+L-1]$ 的间隔种子哈希值 $H_s$ 列表。\n\n测试套件：\n- 情况1（一般情况）：$s=\\text{\"10101\"}$（因此 $L=5$），$x=\\text{\"ACGTACGTAC\"}$（因此 $n=10$）。\n- 情况2（大量不关心位置）：$s=\\text{\"100000010000001\"}$（因此 $L=15$），$x=\\text{\"ACGTACGTACGTACGTACGT\"}$（因此 $n=20$）。\n- 情况3（单个关心位置，边界情况）：$s=\\text{\"0001000\"}$（因此 $L=7$），$x=\\text{\"TTACGGAAC\"}$（因此 $n=9$）。\n- 情况4（全为关心位置，密集种子）：$s=\\text{\"1111\"}$（因此 $L=4$），$x=\\text{\"AGCTAG\"}$（因此 $n=6$）。\n\n对于每种情况，要求的结果是整数列表 $[H_s(x[0\\,..\\,L-1]), H_s(x[1\\,..\\,L]), \\dots, H_s(x[n-L\\,..\\,n-1])]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果本身必须是一个用方括号括起来、由逗号分隔且不含空格的整数列表。例如，一个有效的输出结构是“[[a,b],[c,d],[e,f,g],[h]]”，其中 $a,b,c,d,e,f,g,h$ 是按规定计算出的整数。输出行中不允许有额外的文本或空白字符。", "solution": "该问题陈述已经过验证，被认为是有效的。它具有科学依据、提法明确且客观。它为间隔种子哈希函数（计算生物学中的一个标准概念）提供了一个形式化、完整且一致的定义。任务是实现此函数并将其应用于一组给定的测试用例。可以系统地构建一个分步解决方案。\n\n目标是计算一个较长的、长度为 $n$ 的DNA序列 $x$ 中，每个长度为 $L$ 的可能连续子串（窗口）的间隔种子哈希值 $H_s$。这个过程是确定性的，可以分解为以下步骤。\n\n首先，必须处理间隔种子模式 $s$。模式的长度表示为 $L$。从 $s$ 中，我们必须识别出*关心位置*的集合 $P$，即模式字符串 $s$ 中字符为 '1' 的、从0开始计数的索引。这些索引被收集到一个有序列表 $P = (p_0, p_1, \\dots, p_{w-1})$ 中，其中索引按严格递增顺序排序。关心位置的数量 $w = |P|$ 是种子的词长。\n\n第二，所提供的符号到数字的映射 $\\phi:\\{A,C,G,T\\} \\to \\{0,1,2,3\\}$ 定义为 $\\phi(A)=0$、$\\phi(C)=1$、$\\phi(G)=2$ 和 $\\phi(T)=3$。此映射将相关的DNA字符转换为其数值表示。\n\n第三，我们遍历DNA序列 $x$。序列 $x$ 的长度为 $n$。窗口是长度为 $L$ 的子串。第一个窗口是 $x[0\\,..\\,L-1]$，第二个是 $x[1\\,..\\,L]$，以此类推，直到最后一个可能的窗口 $x[n-L\\,..\\,n-1]$。遍历过程针对窗口的起始索引 $i$ 进行，其中 $i \\in \\{0, 1, \\dots, n-L\\}$。\n\n对于每个从索引 $i$ 开始的窗口，我们计算哈希值 $H_s\\big(x[i\\,..\\,i+L-1]\\big)$。提供的定义是：\n$$\nH_s\\big(x[i\\,..\\,i+L-1]\\big) \\;=\\; \\sum_{t=0}^{w-1} \\phi\\big(x[i+p_t]\\big)\\cdot 4^{\\,w-1-t}\n$$\n这个公式表示一个4进制整数的构造。这个数的“数位”是值 $\\phi\\big(x[i+p_t]\\big)$，对应于当前窗口内关心位置上的字符。字符串 $x$ 中绝对索引为 $i+p_t$ 的字符对应于种子模式的第 $t$ 个关心位置，其中 $t$ 的范围从 $0$ 到 $w-1$。项 $4^{w-1-t}$ 为4进制系统中的每个数位提供了正确的位置权重。\n\n一个计算上高效的方法是使用 Horner 法来计算这个总和。我们可以将哈希值 $H$ 初始化为 $0$。然后，对于从 $0$ 到 $w-1$ 的每个 $t$，我们使用以下规则更新哈希值：\n$$\nH_{\\text{new}} = H_{\\text{old}} \\cdot 4 + \\phi\\big(x[i+p_t]\\big)\n$$\n这个迭代过程避免了在每一步中显式计算 $4$ 的幂。为清晰起见，我们将其展开。\n对于 $t=0$：$H = \\phi\\big(x[i+p_0]\\big)$。\n对于 $t=1$：$H = \\big(\\phi\\big(x[i+p_0]\\big)\\big) \\cdot 4 + \\phi\\big(x[i+p_1]\\big)$。\n对于 $t=2$：$H = \\big(\\phi\\big(x[i+p_0]\\big) \\cdot 4 + \\phi\\big(x[i+p_1]\\big)\\big) \\cdot 4 + \\phi\\big(x[i+p_2]\\big) = \\phi\\big(x[i+p_0]\\big) \\cdot 4^2 + \\phi\\big(x[i+p_1]\\big) \\cdot 4^1 + \\phi\\big(x[i+p_2]\\big) \\cdot 4^0$。\n这表明迭代更新正确地计算了指定的求和。\n\n对从 $i=0$ 到 $i=n-L$ 的每个窗口执行这整个过程。将得到的整数哈希值按其对应窗口索引 $i$ 的顺序收集到一个列表中。然后对问题陈述中提供的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to drive the solution. It defines the test cases and computes\n    the spaced-seed hashes for each, then prints the results in the specified format.\n    \"\"\"\n    \n    # Define the symbol-to-digit mapping phi\n    phi = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        (\"10101\", \"ACGTACGTAC\"),\n        # Case 2 (large number of do-not-care positions)\n        (\"100000010000001\", \"ACGTACGTACGTACGTACGT\"),\n        # Case 3 (single care position, boundary case)\n        (\"0001000\", \"TTACGGAAC\"),\n        # Case 4 (all care positions, dense seed)\n        (\"1111\", \"AGCTAG\"),\n    ]\n\n    all_results = []\n    for s, x in test_cases:\n        hashes = calculate_spaced_seed_hashes(s, x, phi)\n        all_results.append(hashes)\n    \n    # Format the final output according to the problem specification.\n    # e.g., \"[[r1_1,r1_2],[r2_1,r2_2,r2_3]]\"\n    formatted_results = []\n    for result_list in all_results:\n        # Convert each integer list to a comma-separated string without spaces.\n        formatted_list = f\"[{','.join(map(str, result_list))}]\"\n        formatted_results.append(formatted_list)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\ndef calculate_spaced_seed_hashes(s, x, phi):\n    \"\"\"\n    Computes the list of spaced-seed hash values for a given seed pattern and DNA string.\n\n    Args:\n        s (str): The spaced seed pattern (binary string).\n        x (str): The DNA sequence.\n        phi (dict): The symbol-to-digit mapping.\n\n    Returns:\n        list[int]: A list of calculated hash values for each window.\n    \"\"\"\n    L = len(s)\n    n = len(x)\n    \n    # Determine the care positions and the word size w\n    care_positions = [j for j, char in enumerate(s) if char == '1']\n    w = len(care_positions)\n    \n    # Check for the edge case where the seed has no care positions, although\n    # the problem statement guarantees at least one '1'.\n    if w == 0:\n        return [0] * (n - L + 1) if n >= L else []\n\n    hash_results = []\n    \n    # Iterate through all possible windows in the DNA sequence x\n    for i in range(n - L + 1):\n        # For each window, compute the spaced-seed hash\n        current_hash = 0\n        \n        # Iteratively build the base-4 hash value\n        # This is equivalent to Horner's method for polynomial evaluation\n        # and avoids costly exponentiation inside the loop.\n        for p_t in care_positions:\n            # Get the character at the care position within the current window\n            char_at_pos = x[i + p_t]\n            # Map character to its digit value\n            digit = phi[char_at_pos]\n            # Update hash: H = H * 4 + digit\n            current_hash = current_hash * 4 + digit\n            \n        hash_results.append(current_hash)\n        \n    return hash_results\n\nsolve()\n```", "id": "2441094"}, {"introduction": "在掌握了哈希算法之后，生物信息学工程师必须面对一个现实问题：算法在真实世界中的可行性如何？本练习将挑战您进行一次“信封背面”式的计算，估算为整个人类基因组（长度 $L = 3.2 \\times 10^9$）构建一个完整的间隔种子索引所需的内存空间。完成这项任务，您将能更好地理解理论概念（如权重 $W$ 和跨度 $S$）如何直接影响大规模数据处理的硬件成本和工程设计（[@problem_id:2441116]），这项技能对于设计任何高效的生物信息学工具都至关重要。", "problem": "您正在为单倍体人类参考基因组构建一个间隔种子索引，以支持种子-延伸比对。间隔种子由一个跨度为 $S$、权重为 $W$ 的二进制掩码定义，该掩码在一个长度为 $S$ 个核苷酸的窗口内选择 $W$ 个信息位。对于本问题，该掩码的权重为 $W=12$，跨度为 $S=18$。待构建的索引是一个直接寻址哈希索引，其规格如下：\n\n- 单倍体人类基因组的长度为 $L=3.2\\times 10^{9}$ 个碱基。假设基因组中没有任何不明确的核苷酸 ($N$)。\n- 对于从 $1$ 到 $L-S+1$ 的每个基因组偏移量 $t$，在窗口 $[t, t+S-1]$ 处提取由该掩码定义的间隔种子。仅考虑正链。\n- 每个间隔种子由 $2W$ 位（每个核苷酸两位）编码，总共产生 $4^{W}$ 个可能的键。\n- 该索引由两个数组组成：\n  1. 一个主直接寻址数组，长度为 $4^{W}$，以种子的 $2W$ 位编码为键。对于每个键，存储两个无符号32位整数：该键在位置数组中的起始偏移量和位置计数。不存储其他元数据。\n  2. 一个位置数组，每个有效窗口包含一个无符号32位整数，用于存储每次间隔种子出现的基因组起始坐标 $t$。条目按键分组连续排列（键的顺序任意）。\n- 忽略操作系统或内存分配器带来的任何内存开销；仅计算这些数组的原始字节大小。\n- 使用吉字节（Gigabyte）的十进制定义（1 吉字节 (GB) $=10^{9}$ 字节）。\n\n在这些假设下，存储完整索引所需的总内存是多少（以吉字节为单位）？将您的答案四舍五入到三位有效数字。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 间隔种子掩码跨度：$S=18$\n- 间隔种子掩码权重：$W=12$\n- 单倍体人类基因组长度：$L=3.2 \\times 10^{9}$ 个碱基\n- 核苷酸编码：每个核苷酸 $2$ 位\n- 种子键编码：$2W$ 位\n- 可能的总键数：$4^{W}$\n- 索引结构：\n    1. 主直接寻址数组：\n        - 长度：$4^{W}$\n        - 条目内容：两个无符号32位整数\n    2. 位置数组：\n        - 内容：每个有效窗口一个无符号32位整数\n        - 有效窗口：对于从 $1$ 到 $L-S+1$ 的基因组偏移量 $t$\n- 数据类型：无符号32位整数\n- 内存开销（操作系统，分配器）：忽略\n- 单位定义：$1$ 吉字节 (GB) $= 10^9$ 字节\n- 输出要求：总内存，以GB为单位，四舍五入到三位有效数字。\n\n**第2步：使用提取的已知条件进行验证**\n根据指定标准对问题进行评估。\n- **科学依据**：该问题描述了间隔种子索引的构建，这是生物信息学中用于序列比对的一种基本且广泛使用的数据结构。给定的参数（$L, S, W$）对于索引人类基因组是切合实际的。其概念是合理的。\n- **提法恰当**：该问题规定明确。提供了计算构成索引的两个数组大小所需的所有必要参数和定义。存在唯一的数值解。\n- **客观性**：语言精确且定量。没有主观或模棱两可的陈述。\n- **完整性和一致性**：该问题是自洽的。数据类型（无符号32位整数）足以存储所需信息；一个32位整数可以存储高达 $2^{32}-1 \\approx 4.29 \\times 10^9$ 的值，这大于最大基因组偏移量 $L-S+1 \\approx 3.2 \\times 10^9$。约束条件是一致的。\n\n**第3步：结论与行动**\n该问题是有效的。它具有科学合理性、提法恰当且完整。将推导解答。\n\n所需总内存，记为 $M_{\\text{total}}$，是主直接寻址数组所需内存 $M_{\\text{primary}}$ 与位置数组所需内存 $M_{\\text{pos}}$ 的总和。\n$$M_{\\text{total}} = M_{\\text{primary}} + M_{\\text{pos}}$$\n\n首先，我们计算主直接寻址数组的大小 $M_{\\text{primary}}$。\n该数组由所有可能的间隔种子键索引。可能的键数 $N_{\\text{keys}}$ 由种子权重 $W$ 决定。对于包含4个核苷酸的字母表和权重 $W$，不同键的数量为：\n$$N_{\\text{keys}} = 4^{W}$$\n给定 $W=12$：\n$$N_{\\text{keys}} = 4^{12} = (2^2)^{12} = 2^{24} = 16,777,216$$\n该数组中的每个条目包含两个无符号32位整数。一个无符号32位整数占用32位，即 $\\frac{32}{8} = 4$ 字节。因此，每个条目的大小为 $2 \\times 4 = 8$ 字节。\n主数组的总大小是条目数乘以每个条目的大小：\n$$M_{\\text{primary}} = N_{\\text{keys}} \\times (\\text{一个条目的大小})$$\n$$M_{\\text{primary}} = 16,777,216 \\times 8 \\text{ 字节} = 134,217,728 \\text{ 字节}$$\n\n接下来，我们计算位置数组的大小 $M_{\\text{pos}}$。\n该数组为基因组中的每个有效窗口存储一个条目。有效窗口的数量 $N_{\\text{windows}}$ 对应于长度为 $L$ 的基因组内，跨度为 $S$ 的种子的可能起始位置 $t$ 的数量。起始位置的范围从 $t=1$ 到 $t=L-S+1$。\n$$N_{\\text{windows}} = (L-S+1) - 1 + 1 = L-S+1$$\n代入给定值 $L=3.2 \\times 10^9$ 和 $S=18$：\n$$N_{\\text{windows}} = 3.2 \\times 10^9 - 18 + 1 = 3.2 \\times 10^9 - 17$$\n$$N_{\\text{windows}} = 3,200,000,000 - 17 = 3,199,999,983$$\n位置数组中的每个条目是一个无符号32位整数，即4字节。\n位置数组的总大小是窗口数乘以每个条目的大小：\n$$M_{\\text{pos}} = N_{\\text{windows}} \\times (\\text{一个条目的大小})$$\n$$M_{\\text{pos}} = (3.2 \\times 10^9 - 17) \\times 4 \\text{ 字节}$$\n$$M_{\\text{pos}} = 3,199,999,983 \\times 4 \\text{ 字节} = 12,799,999,932 \\text{ 字节}$$\n\n现在，我们通过将两个数组的大小相加来计算总内存需求：\n$$M_{\\text{total}} = M_{\\text{primary}} + M_{\\text{pos}}$$\n$$M_{\\text{total}} = 134,217,728 \\text{ 字节} + 12,799,999,932 \\text{ 字节}$$\n$$M_{\\text{total}} = 12,934,217,660 \\text{ 字节}$$\n\n问题要求答案以吉字节（GB）为单位，使用定义 $1 \\text{ GB} = 10^9 \\text{ 字节}$。\n$$M_{\\text{total}} (\\text{以GB计}) = \\frac{12,934,217,660}{10^9} = 12.934217660 \\text{ GB}$$\n\n最后，我们将结果四舍五入到三位有效数字。该数字是 $12.9342...$。前三位有效数字是 $1$、$2$和$9$。第四位有效数字是$3$，小于$5$，因此我们向下舍入。\n$$M_{\\text{total}} (\\text{以GB计}) \\approx 12.9$$", "answer": "$$\\boxed{12.9}$$", "id": "2441116"}, {"introduction": "标准的间隔种子将所有匹配位置同等对待，但这并非总是最优策略。本练习将引导您探索一个更精妙的概念——加权间隔种子，其中某些位置的匹配对总分数的贡献大于其他位置，从而提供了更高的灵活性和特异性。您不仅需要实现其在两条序列上的经验得分 ($S_i$) 计算，还需要深入其背后的概率论，计算其理论命中概率 $P_{\\text{hit}}$（[@problem_id:2441141]）。这个练习完美地连接了算法实现与统计评估，展现了如何通过更复杂的模型来优化序列比对的灵敏度。", "problem": "给定用于为两条脱氧核糖核酸（DNA）序列在字母表 $\\{A,C,G,T\\}$ 上的短无空位比对打分的加权间隔种子的形式化概念。一个长度为 $m$ 的加权间隔种子由一个非负整数权重向量 $\\mathbf{w} = (w_0,w_1,\\dots,w_{m-1})$ 定义。对于两条等长为 $n$ 的序列 $Q$ 和 $T$，以及每个偏移量 $i \\in \\{0,1,\\dots,n-m\\}$，定义种子得分为\n$$\nS_i = \\sum_{j=0}^{m-1} w_j \\cdot \\mathbf{1}\\{Q_{i+j} = T_{i+j}\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，且等号表示字符字面相等。如果对于给定的阈值 $\\tau$，有 $S_i \\ge \\tau$，则偏移量为 $i$ 的窗口被称为一次命中（hit）。词长参数是总和 $\\sum_{j=0}^{m-1} w_j$，对于每个 $w_j = 1$ 的连续未加权种子，该值等于 $m$。\n\n此外，在一个独立同分布模型下，其中每个位置 $j$ 以概率 $p \\in (0,1)$ 匹配，定义随机变量 $X_j \\in \\{0,1\\}$，其中 $\\Pr[X_j=1]=p$ 且 $\\Pr[X_j=0]=1-p$，并设\n$$\nS = \\sum_{j=0}^{m-1} w_j X_j.\n$$\n理论命中概率为 $\\Pr[S \\ge \\tau]$。\n\n您的任务是实现一个程序，为每个指定的测试案例计算：\n- 满足 $S_i \\ge \\tau$ 的偏移量 $i$ 的整数计数 $H$。\n- 整数最大得分 $M = \\max_{0 \\le i \\le n-m} S_i$。\n- 浮点数值 $P_{\\text{hit}} = \\Pr[S \\ge \\tau]$。\n\n所有计算必须严格遵循上述定义。测试集如下；每个测试案例指定 $(\\mathbf{w}, \\tau, Q, T, p)$，其中 $\\mathbf{w}$ 被编码为一串数字（每个数字 $d$ 表示权重 $w_j = d$），$\\tau$ 是一个整数阈值，$Q$ 和 $T$ 是等长的大写 DNA 字符串，$p$ 是开区间 $(0,1)$ 内的一个实数。\n\n测试集：\n1. 案例 A：$\\mathbf{w} = \\text{\"2101\"}$ (因此 $m=4$)，$\\tau = 3$，$Q = \\text{\"ACGTACGTAC\"}$，$T = \\text{\"ACGTTCGTAA\"}$，$p = 0.25$。\n2. 案例 B：$\\mathbf{w} = \\text{\"11111\"}$ (因此 $m=5$)，$\\tau = 5$，$Q = \\text{\"AAAAAACCCC\"}$，$T = \\text{\"AAAAGACCCC\"}$，$p = 0.25$。\n3. 案例 C：$\\mathbf{w} = \\text{\"0000\"}$ (因此 $m=4$)，$\\tau = 0$，$Q = \\text{\"ACGTAC\"}$，$T = \\text{\"TGCAAC\"}$，$p = 0.25$。\n\n要求的最终输出格式：您的程序应生成一个单行，其中包含一个逐测试案例的结果列表，每个结果是一个列表 $[H,M,P_{\\text{hit}}]$，且最外层列表按顺序包含所有案例。该行必须不含任何空白字符，且格式应严格为\n$[\\![H_1,M_1,P_{\\text{hit},1}],[H_2,M_2,P_{\\text{hit},2}],\\dots]$，\n例如，对于两个案例，格式为 $[[1,5,0.25],[0,3,0.5]]$。所有整数必须以十进制数字打印，所有实数必须以小数表示法打印。", "solution": "所提出的问题是有效的。它在计算生物学和概率论方面有科学依据，定义精确，数据完整，问题表述清晰，并且要求为多个测试案例计算三个不同的量：命中计数 $H$、最大得分 $M$ 和理论命中概率 $P_{\\text{hit}}$。解决方案是通过直接应用所提供的定义得出的。\n\n计算分为两个部分：基于序列得分的确定性计算和理论命中概率的概率性计算。\n\n**1. 命中计数 ($H$) 和最大得分 ($M$) 的计算**\n\n数量 $H$ 和 $M$ 是通过将种子得分公式应用于给定的序列 $Q$ 和 $T$ 来确定的。序列的长度为 $n$，加权间隔种子 $\\mathbf{w}$ 的长度为 $m$。\n\n对于由偏移量 $i$ 索引的每个可能的比对窗口，其得分 $S_i$ 定义为：\n$$\nS_i = \\sum_{j=0}^{m-1} w_j \\cdot \\mathbf{1}\\{Q_{i+j} = T_{i+j}\\}\n$$\n偏移量 $i$ 的范围从 $0$ 到 $n-m$，覆盖了长度为 $m$ 的种子在长度为 $n$ 的序列内的所有可能的起始位置。对于每个偏移量 $i$，通过从 $j=0$ 到 $m-1$ 迭代，比较字符 $Q_{i+j}$ 和 $T_{i+j}$，如果它们匹配，则累加相应的权重 $w_j$ 来计算得分 $S_i$。\n\n在为所有有效偏移量 $i \\in \\{0, 1, \\dots, n-m\\}$ 计算得分 $S_i$ 后，我们得到一个得分列表。\n- 命中计数 $H$ 是此列表中大于或等于给定阈值 $\\tau$ 的得分 $S_i$ 的总数。这是一个简单的计数操作。\n- 最大得分 $M$ 是得分列表中的最大值。这可以通过标准的查找最大值算法找到。如果不存在窗口（即 $n<m$），这将是未定义的，但所有测试案例都满足 $n \\ge m$。\n\n这个过程是确定性的，通过遍历有效偏移量并应用给定公式来实现。\n\n**2. 理论命中概率 ($P_{\\text{hit}}$) 的计算**\n\n理论命中概率 $P_{\\text{hit}} = \\Pr[S \\ge \\tau]$ 是从序列匹配的概率模型中导出的。得分被建模为一个随机变量 $S = \\sum_{j=0}^{m-1} w_j X_j$，其中每个 $X_j$ 是一个独立的伯努利随机变量，且 $\\Pr[X_j=1]=p$ 和 $\\Pr[X_j=0]=1-p$。数量 $S$ 是加权的、独立的、同分布的伯努利随机变量之和。\n\n为了计算 $\\Pr[S \\ge \\tau]$，我们必须首先确定 $S$ 的概率质量函数 (PMF)，即对于所有可能的得分值 $s$ 的 $\\Pr[S=s]$。由于权重 $w_j$ 是非负整数，总得分 $S$ 也将是一个整数。最大可能得分为 $\\sum_{j=0}^{m-1} w_j$。\n\n采用动态规划方法来计算此 PMF。设 $P_k(s)$ 表示使用前 $k$ 个权重的部分得分总和 $\\sum_{j=0}^{k-1} w_j X_j$ 等于 $s$ 的概率。\n基本情况是 $k=0$，此时和为空，得分为 $0$ 的概率为 $1$。因此，$P_0(0) = 1$ 且当 $s \\neq 0$ 时 $P_0(s) = 0$。\n\n对于 $k > 0$，我们可以基于 $P_{k-1}$ 推导出 $P_k(s)$ 的递推关系：\n$$\nP_k(s) = P_{k-1}(s) \\cdot \\Pr[X_{k-1}=0] + P_{k-1}(s-w_{k-1}) \\cdot \\Pr[X_{k-1}=1]\n$$\n代入 $X_{k-1}$ 的概率：\n$$\nP_k(s) = P_{k-1}(s) \\cdot (1-p) + P_{k-1}(s-w_{k-1}) \\cdot p\n$$\n这个关系成立，因为使用前 $k$ 个权重得到得分 $s$ 有两种互斥的方式：\n1. 使用前 $k-1$ 个权重的得分已经是 $s$，且第 $k$ 个位置不匹配 ($X_{k-1}=0$)。\n2. 使用前 $k-1$ 个权重的得分是 $s-w_{k-1}$，且第 $k$ 个位置匹配 ($X_{k-1}=1$)，从而将 $w_{k-1}$ 加到得分上。\n\n这个动态规划通过维护一个表示 PMF 的数组来实现。该数组为基本情况进行初始化，并针对从 $j=0$ 到 $m-1$ 的每个权重 $w_j$ 进行迭代更新。经过 $m$ 次迭代，该数组持有总得分 $S$ 的最终 PMF。设这个最终的 PMF 为 $P_m(s)$。\n\n那么，所需的概率 $P_{\\text{hit}}$ 是所有大于或等于 $\\tau$ 的得分的概率之和：\n$$\nP_{\\text{hit}} = \\Pr[S \\ge \\tau] = \\sum_{s=\\tau}^{\\infty} P_m(s) = \\sum_{s=\\tau}^{\\sum w_j} P_m(s)\n$$\n这个求和是在最终的概率分布数组上执行的。\n\n**特殊情况：**\n- 如果所有权重 $w_j=1$，变量 $S$ 服从二项分布 $B(m,p)$。概率 $\\Pr[S \\ge \\tau]$ 可以使用二项分布的 PMF $\\Pr[S=k] = \\binom{m}{k}p^k(1-p)^{m-k}$ 来计算。\n- 如果所有权重 $w_j=0$，得分 $S$ 确定性地为 $0$。因此，$\\Pr[S=0]=1$。所以，如果 $\\tau \\le 0$，$\\Pr[S \\ge \\tau]$ 为 $1$；如果 $\\tau > 0$，则为 $0$。\n\n所提供的实现使用了通用的动态规划方法，因为它能正确处理所有情况，包括这些特殊情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom typing import List, Tuple\n\ndef solve():\n    \"\"\"\n    Main function to solve the given problem for all test cases.\n    It calculates the hit count (H), maximum score (M), and theoretical\n    hit probability (P_hit) for each case and prints the results in the\n    specified format.\n    \"\"\"\n\n    # Each test case specifies (w, tau, Q, T, p)\n    # w is a string of digits, tau is an integer, Q and T are DNA strings,\n    # p is a float probability.\n    test_cases: List[Tuple[str, int, str, str, float]] = [\n        # Case A\n        (\"2101\", 3, \"ACGTACGTAC\", \"ACGTTCGTAA\", 0.25),\n        # Case B\n        (\"11111\", 5, \"AAAAAACCCC\", \"AAAAGACCCC\", 0.25),\n        # Case C\n        (\"0000\", 0, \"ACGTAC\", \"TGCAAC\", 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        w_str, tau, Q, T, p = case\n        \n        # Parse weight string into a list of integers\n        w = [int(digit) for digit in w_str]\n        \n        # Calculate H and M\n        h, m = calculate_h_and_m(w, tau, Q, T)\n        \n        # Calculate P_hit\n        p_hit = calculate_p_hit(w, tau, p)\n        \n        results.append((h, m, p_hit))\n\n    # Format the final output string exactly as required, with no whitespace.\n    result_strings = [f\"[{h},{m},{p}]\" for h, m, p in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\ndef calculate_h_and_m(w: List[int], tau: int, Q: str, T: str) -> Tuple[int, int]:\n    \"\"\"\n    Calculates the hit count H and maximum score M.\n\n    Args:\n        w: The vector of integer weights.\n        tau: The integer score threshold for a hit.\n        Q: The first DNA sequence string.\n        T: The second DNA sequence string.\n\n    Returns:\n        A tuple (H, M) containing the hit count and maximum score.\n    \"\"\"\n    m = len(w)\n    n = len(Q)\n    \n    if n < m:\n        # No possible alignment windows\n        return 0, 0\n\n    scores = []\n    for i in range(n - m + 1):\n        current_score = 0\n        for j in range(m):\n            if Q[i+j] == T[i+j]:\n                current_score += w[j]\n        scores.append(current_score)\n    \n    H = sum(1 for s in scores if s >= tau)\n    M = max(scores) if scores else 0\n    \n    return H, M\n\ndef calculate_p_hit(w: List[int], tau: int, p: float) -> float:\n    \"\"\"\n    Calculates the theoretical hit probability P_hit = Pr[S >= tau].\n\n    This is done using dynamic programming to find the probability mass function\n    of the score S, which is a sum of weighted independent Bernoulli variables.\n\n    Args:\n        w: The vector of integer weights.\n        tau: The integer score threshold.\n        p: The probability of a match at any given position.\n\n    Returns:\n        The float value of P_hit.\n    \"\"\"\n    max_score = sum(w)\n    \n    # dp[s] will store the probability of achieving a score of exactly s.\n    dp = np.zeros(max_score + 1, dtype=np.float64)\n    dp[0] = 1.0\n\n    for weight in w:\n        if weight == 0:\n            # A weight of 0 does not change the score distribution.\n            continue\n        \n        # To avoid modifying dp while using its old values, we can iterate\n        # backwards or use a temporary array. Vectorized numpy is clean.\n        # old_dp = dp.copy()\n        # dp = old_dp * (1 - p)\n        # for s in range(max_score - weight + 1):\n        #     dp[s + weight] += old_dp[s] * p\n        \n        # A more efficient vectorized update:\n        # P_new(s) = P_old(s)*(1-p) + P_old(s-w)*p\n        dp_with_match = np.zeros_like(dp)\n        dp_with_match[weight:] = dp[:-weight] * p\n        dp = dp * (1 - p) + dp_with_match\n        \n    # P_hit is the sum of probabilities for all scores >= tau.\n    if tau > max_score:\n        return 0.0\n    \n    p_hit = np.sum(dp[tau:])\n    return p_hit\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2441141"}]}