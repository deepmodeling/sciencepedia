{"hands_on_practices": [{"introduction": "掌握了理论知识后，最好的学习方法就是动手实践。第一个练习将带你入门仿射空位罚分的核心计算。仿射空位罚分模型是序列比对的基石，因为它能更真实地模拟生物进化事件——一个大的缺失或插入事件（开启空位）比多个孤立的小事件（延伸空位）可能性更高。通过这个练习，你将熟练掌握如何为一个给定的比对计算总分，这是理解更复杂的动态规划算法如何评估和选择最优比对的第一步。[@problem_id:2136038]", "problem": "在生物信息学中，序列比对是比较蛋白质或核苷酸序列以识别相似性区域的一种基本方法。给定比对的质量通过一个数值分数来量化，该分数根据序列之间的匹配、错配和空位计算得出。一种特别常见的空位罚分模型是仿射空位罚分模型，该模型区分了打开一个空位的罚分和延伸它的罚分。\n\n考虑以下两条短肽序列 `PEPTIDE X` 和 `PEPTIDE Y` 的特定比对：\n\n`PEPTIDE X: VDLMSETKRG`\n`PEPTIDE Y: VDL-----RG`\n\n总比对分数是通过将每对垂直对齐的氨基酸的替换分数相加，再加上任何存在的空位的罚分来确定的。本任务的评分系统定义如下：\n\n1.  **替换分数**：将 `PEPTIDE X` 中的一个氨基酸与 `PEPTIDE Y` 中的相同氨基酸进行比对的分数如下表所示。\n    *   S(V,V) = 4\n    *   S(D,D) = 6\n    *   S(L,L) = 4\n    *   S(R,R) = 5\n    *   S(G,G) = 6\n\n2.  **仿射空位罚分**：引入一个空位将使用仿射模型进行罚分，参数如下：\n    *   空位起始罚分：-11\n    *   空位延伸罚分：-1\n\n计算上述特定比对的总比对分数。最终答案应为一个整数。", "solution": "我们分析给定的比对：\nPEPTIDE X: V D L M S E T K R G\nPEPTIDE Y: V D L - - - - - R G\n\n垂直对齐的配对是：\n- 匹配：$(V,V)$, $(D,D)$, $(L,L)$, $(R,R)$, $(G,G)$。\n- PEPTIDE Y 中有一个长度为 $k=5$ 的连续空位，与 PEPTIDE X 中的 $M,S,E,T,K$ 比对。\n\n替换分数的贡献是给定相同配对分数的总和：\n$$\nS_{\\text{sub}} = S(V,V) + S(D,D) + S(L,L) + S(R,R) + S(G,G)\n= 4 + 6 + 4 + 5 + 6 = 25.\n$$\n\n使用仿射空位罚分模型，一个长度为 $k$ 的连续空位的罚分为：\n$$\nG_{\\text{gap}} = \\text{gap\\_open} + (k-1)\\,\\text{gap\\_extend}.\n$$\n当 $\\text{gap\\_open} = -11$，$\\text{gap\\_extend} = -1$ 且 $k=5$ 时，我们得到：\n$$\nG_{\\text{gap}} = -11 + (5-1)(-1) = -11 - 4 = -15.\n$$\n\n因此，总比对分数是：\n$$\nS_{\\text{total}} = S_{\\text{sub}} + G_{\\text{gap}} = 25 + (-15) = 10.\n$$", "answer": "$$\\boxed{10}$$", "id": "2136038"}, {"introduction": "仅仅会计算分数是不够的，更重要的是理解空位罚分参数背后的“经济学”权衡。这个练习是一个思想实验，旨在让你深入思考空位罚分在比对决策中的关键作用。在序列比对中，算法总是在“接受一个错配”和“引入一个空位以获得后续更好的匹配”之间做出选择。通过确定引入空位变得“划算”的罚分阈值，你将能够更深刻地体会到，空位罚分参数的设定是怎样直接影响最终比对结果的形态和生物学意义的。[@problem_id:2392977]", "problem": "考虑在仿射空位罚分模型下，对两个特定且等长的核苷酸序列进行全局比对。比对得分定义为所有比对列上字符-字符对的替换得分与任何连续空位块的空位成本之和。替换得分为：一个匹配贡献$+2$，一个错配贡献$-1$。对于任何长度为$\\ell$的空位块，仿射空位成本为$g_{open} + g_{ext} \\times (\\ell - 1)$，其中$g_{open} \\ge 0$是空位开放罚分，$g_{ext} = 1$是除第一个字符外每增加一个空位字符的空位延伸罚分。\n\n已知对于这两个长度为$n = 12$的序列，禁止空位的最佳可能全局比对（即逐位无空位比对）正好得到$m_{0} = 6$个匹配和$n - m_{0} = 6$个错配。如果比对允许在任一序列中包含至多一个长度为$\\ell = 1$的连续空位块，则存在一种单空位比对的放置方式，能产生恰好$m_{1} = 10$个匹配和$(n - 1) - m_{1} = 1$个错配（注意，其中一个比对列是字符-空位对）。\n\n确定空位开放罚分$g_{open}$的最大值（与替换得分使用相同的计分单位），使得存在一个包含至少一个空位的最优全局比对；等价地，确定阈值$g_{open}^{*}$，使得当且仅当$g_{open} \\le g_{open}^{*}$时，单空位比对的得分大于或等于最佳无空位比对的得分。请以单个数字形式给出答案，无需四舍五入。", "solution": "目标是找到空位开放罚分的阈值$g^{*}_{open}$，使得对于任何$g_{open} \\le g^{*}_{open}$，最优比对得分由一个包含至少一个空位的比对实现。这意味着我们必须找到有空位比对的得分$S_{gap}$大于或等于无空位比对的得分$S_{nogap}$的条件。\n\n首先，我们计算最佳可能无空位比对的得分$S_{nogap}$。根据问题陈述，该比对有$m_{0} = 6$个匹配和$n - m_{0} = 12 - 6 = 6$个错配。得分计算如下：\n$$S_{nogap} = (\\text{匹配数} \\times \\text{匹配得分}) + (\\text{错配数} \\times \\text{错配得分})$$\n$$S_{nogap} = m_{0} \\times (+2) + (n - m_{0}) \\times (-1)$$\n代入给定值：\n$$S_{nogap} = 6 \\times 2 + 6 \\times (-1) = 12 - 6 = 6$$\n\n接下来，我们计算包含一个空位的指定比对的得分$S_{gap}$。该比对有一个长度为$\\ell = 1$的连续空位块。它产生了$m_{1} = 10$个匹配和$(n - 1) - m_{1} = (12 - 1) - 10 = 1$个错配。因此，该比对由10个匹配列、1个错配列和1个包含空位的列组成。\n\n得分$S_{gap}$是匹配和错配得分的总和，减去空位的成本。\n来自匹配和错配的贡献为：\n$$S_{substitutions} = m_{1} \\times (+2) + ((n - 1) - m_{1}) \\times (-1)$$\n$$S_{substitutions} = 10 \\times 2 + 1 \\times (-1) = 20 - 1 = 19$$\n\n空位块的成本$C(\\ell)$由仿射空位罚分模型确定：\n$$C(\\ell) = g_{open} + g_{ext} \\times (\\ell - 1)$$\n对于此比对，空位长度为$\\ell = 1$，延伸罚分为$g_{ext} = 1$。\n$$C(1) = g_{open} + 1 \\times (1 - 1) = g_{open} + 0 = g_{open}$$\n这个成本从得分中减去。因此，有空位比对的总得分为：\n$$S_{gap} = S_{substitutions} - C(1) = 19 - g_{open}$$\n\n如果有空位比对的得分大于或等于无空位比对的得分，则它是更优的或同等最优的：\n$$S_{gap} \\ge S_{nogap}$$\n代入得分的表达式：\n$$19 - g_{open} \\ge 6$$\n\n我们现在解这个关于$g_{open}$的不等式：\n$$19 - 6 \\ge g_{open}$$\n$$13 \\ge g_{open}$$\n这表明，当且仅当$g_{open} \\le 13$时，单空位比对的得分将大于或等于无空位比对的得分。问题要求的是使此条件成立的$g_{open}$的最大值。该阈值即为$g_{open}^{*}$。\n\n因此，最大值为$g_{open}^{*} = 13$。对于任何$g_{open} > 13$，引入空位的罚分过高，无空位比对将是严格最优的。对于$g_{open} \\le 13$，包含至少一个空位的比对是其中一个最优解。", "answer": "$$\\boxed{13}$$", "id": "2392977"}, {"introduction": "线性和仿射模型是空位罚分中最常见的两种，但它们远非全部。为了应对更复杂的生物学场景，研究人员提出了各种广义空位罚分函数。这个高级练习将挑战你为一种对数形式的空位罚分 $p(k) = a \\ln(k) + b$ 设计并实现一个动态规划算法。这个任务要求你不能再简单套用经典的 Needleman-Wunsch 或 Gotoh 算法，而是需要从第一性原理出发，推导出新的递推关系。完成这个编程挑战，将证明你不仅理解了空位罚分的原理，更具备了将理论推广到新问题并付诸实践的能力。[@problem_id:2392987]", "problem": "给定两个在有限字母表上的有限长度字符串，以及一个全局配对序列比对的评分模型。在此模型中，总分是比对符号对的替换得分之和，再减去对每个连续空位区段施加一次的罚分。一个长度为 $k$ 的连续空位会产生形式为 $p(k) = a \\ln(k) + b$ 的罚分，其中 $\\ln(\\cdot)$ 是自然对数，$a \\ge 0$，$b \\ge 0$，且 $k$ 是一个正整数。对于任何比对的符号对 $(x,y)$，替换得分 $s(x,y) = \\begin{cases} +2 & \\text{如果 } x=y \\\\ -1 & \\text{如果 } x \\ne y \\end{cases}$。比对是全局性的：每个字符串中的每个位置都必须要么与另一字符串中的某个位置比对，要么被包含在一个空位中。空位罚分只对每个最大的连续空位段施加一次，而不是对每个单独的空位字符施加。\n\n将最优全局比对得分 $S(X,Y;a,b)$ 定义为在上述规则下，对于序列 $X$ 和 $Y$ 以及参数 $a$ 和 $b$ 所能获得的最大可能总分。对于其中一个字符串为空的特殊情况，比对仅由一个连续空位组成，其长度等于非空字符串的长度，得分为相应空位罚分的负值。\n\n请开发一个程序，对下面指定的每个测试用例，使用所述模型计算 $S(X,Y;a,b)$。使用自然对数计算 $\\ln(\\cdot)$，除了标准的双精度浮点运算外，不要对 $\\pi$ 或任何其他常数进行近似。将每个最终得分四舍五入到小数点后恰好 $6$ 位。\n\n测试套件（每个元组为 $(X,Y,a,b)$）：\n- $\\left(\"A\",\"A\",\\,1.0,\\,2.0\\right)$\n- $\\left(\"A\",\"G\",\\,1.0,\\,2.0\\right)$\n- $\\left(\"AAAA\",\"A\",\\,1.0,\\,2.0\\right)$\n- $\\left(\"AAAA\",\"GGGG\",\\,1.0,\\,2.0\\right)$\n- $\\left(\"\",\"\",\\,1.0,\\,2.0\\right)$\n- $\\left(\"AAAA\",\"GGGG\",\\,1.0,\\,0.1\\right)$\n- $\\left(\"\",\"AC\",\\,0.5,\\,1.0\\right)$\n\n你的程序应该生成一行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。第 $i$ 个元素必须是按给定顺序的第 $i$ 个测试用例的四舍五入得分。例如，格式必须严格为 $[r_1,r_2,\\dots,r_7]$ 的形式，其中每个 $r_i$ 是一个四舍五入到小数点后 $6$ 位实数，并且当且仅当值为负时才包含前导负号。输出中不允许有额外的空白或字符。此问题不涉及任何物理单位，如果隐含出现任何角度，均无关紧要。", "solution": "该问题陈述是计算生物学中一个有效且定义明确的优化问题。它要求在一种包含非标准通用空位罚分函数的特定评分模型下，计算两个序列的最优全局比对得分。长度为 $k$ 的空位的罚分函数为 $p(k) = a \\ln(k) + b$，当 $a \\ge 0$ 时这是一个凹函数。像 Needleman-Wunsch（用于线性空位）或 Gotoh（用于仿射空位）这样的标准高效算法依赖于空位成本的加性性质，而这里的情况并非如此。因此，需要一种更通用的动态规划方法。\n\n设 $X = x_1x_2...x_m$ 和 $Y = y_1y_2...y_n$ 为两个序列。我们定义 $S(i,j)$ 为前缀 $X[1..i]$ 和 $Y[1..j]$ 全局比对的最大得分。目标是计算 $S(m,n)$。\n\n$S(i,j)$ 的值是通过考虑前缀 $X[1..i]$ 和 $Y[1..j]$ 的最优比对可以结束的所有可能方式来确定的。比对的末端有三种互斥且穷尽的情况：\n1.  字符 $x_i$ 和 $y_j$ 相互比对。这种情况下的得分是较短前缀 $X[1..i-1]$ 和 $Y[1..j-1]$ 最优比对的得分 $S(i-1, j-1)$，加上替换得分 $s(x_i, y_j)$。\n2.  比对以序列 $Y$ 中的一个最大连续空位结束。这意味着对于某个 $k \\ge 1$，字符块 $X[i-k+1 .. i]$ 与 $k$ 个空位字符比对。这个空位段之前是前缀 $X[1..i-k]$ 和 $Y[1..j]$ 的最优比对。因此，总分是 $S(i-k, j)$ 减去长度为 $k$ 的空位的罚分 $p(k)$。我们必须考虑所有可能的空位长度 $k$（从 $1$ 到 $i$），并取最大得分。\n3.  同理，比对以序列 $X$ 中的一个最大连续空位结束。对于某个 $k \\ge 1$，字符块 $Y[j-k+1 .. j]$ 与 $k$ 个空位字符比对。这之前是前缀 $X[1..i]$ 和 $Y[1..j-k]$ 的最优比对。得分为 $S(i, j-k) - p(k)$。我们必须在所有可能的空位长度 $k$（从 $1$ 到 $j$）中取最大值。\n\n综合这些情况，$S(i,j)$ 的递归关系是：\n$$\nS(i,j) = \\max \\begin{cases}\nS(i-1, j-1) + s(x_i, y_j) \\\\\n\\max_{1 \\le k \\le i} \\{ S(i-k, j) - p(k) \\} \\\\\n\\max_{1 \\le k \\le j} \\{ S(i, j-k) - p(k) \\}\n\\end{cases}\n$$\n其中空位罚分为 $p(k) = a \\ln(k) + b$，替换得分为 $s(x,y) = +2$（匹配，$x=y$）和 $s(x,y) = -1$（错配，$x \\ne y$）。\n\n递归的基准情况处理涉及空序列的比对：\n-   $S(0,0) = 0$：两个空字符串的比对得分为零。\n-   $S(i,0) = -p(i) = -(a \\ln(i) + b)$，对于 $i > 0$：非空序列 $X[1..i]$ 与空序列的比对包含一个长度为 $i$ 的单一空位。\n-   $S(0,j) = -p(j) = -(a \\ln(j) + b)$，对于 $j > 0$：同样，将空序列与 $Y[1..j]$ 比对会产生一个长度为 $j$ 的单一空位。\n\n我们可以通过构建一个大小为 $(m+1) \\times (n+1)$ 的动态规划表，从基准情况开始，迭代填充表格直至 $S(m,n)$，来求解这个递归关系。这个朴素算法的时间复杂度是 $O(mn(m+n))$，对于测试套件中指定的小序列长度，这在计算上是可行的。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the global sequence alignment problem for a set of test cases\n    using a dynamic programming approach with a general gap penalty function.\n    \"\"\"\n\n    test_cases = [\n        (\"A\", \"A\", 1.0, 2.0),\n        (\"A\", \"G\", 1.0, 2.0),\n        (\"AAAA\", \"A\", 1.0, 2.0),\n        (\"AAAA\", \"GGGG\", 1.0, 2.0),\n        (\"\", \"\", 1.0, 2.0),\n        (\"AAAA\", \"GGGG\", 1.0, 0.1),\n        (\"\", \"AC\", 0.5, 1.0),\n    ]\n\n    results = []\n    for X, Y, a, b in test_cases:\n        score = calculate_alignment_score(X, Y, a, b)\n        results.append(f\"{score:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_alignment_score(X: str, Y: str, a: float, b: float) -> float:\n    \"\"\"\n    Calculates the optimal global alignment score for two sequences X and Y\n    with a gap penalty p(k) = a*ln(k) + b.\n    \"\"\"\n    m = len(X)\n    n = len(Y)\n\n    # Substitution score function\n    def s(char1: str, char2: str) -> int:\n        return 2 if char1 == char2 else -1\n\n    # Gap penalty function\n    def p(k: int) -> float:\n        if k <= 0:\n            # A gap of non-positive length is not meaningful.\n            # In maximization, this should be prevented by returning a large penalty.\n            return float('inf')\n        return a * math.log(k) + b\n\n    # DP table S[i][j] stores the optimal score for X[:i] and Y[:j]\n    S = np.full((m + 1, n + 1), -np.inf, dtype=float)\n\n    # Base case: alignment of two empty strings\n    S[0, 0] = 0\n\n    # Base cases: alignment with an empty string\n    for i in range(1, m + 1):\n        S[i, 0] = -p(i)\n    for j in range(1, n + 1):\n        S[0, j] = -p(j)\n\n    # Fill the DP table using the recurrence relation\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Case 1: Align X[i-1] with Y[j-1]\n            match_score = S[i-1, j-1] + s(X[i-1], Y[j-1])\n\n            # Case 2: Align X[i-1] with a gap (part of a gap in Y)\n            # This is the end of a gap of length k in Y.\n            gap_in_Y_scores = [S[i-k, j] - p(k) for k in range(1, i + 1)]\n            max_gap_in_Y = max(gap_in_Y_scores) if gap_in_Y_scores else -np.inf\n\n            # Case 3: Align Y[j-1] with a gap (part of a gap in X)\n            # This is the end of a gap of length k in X.\n            gap_in_X_scores = [S[i, j-k] - p(k) for k in range(1, j + 1)]\n            max_gap_in_X = max(gap_in_X_scores) if gap_in_X_scores else -np.inf\n\n            S[i, j] = max(match_score, max_gap_in_Y, max_gap_in_X)\n\n    return S[m, n]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2392987"}]}