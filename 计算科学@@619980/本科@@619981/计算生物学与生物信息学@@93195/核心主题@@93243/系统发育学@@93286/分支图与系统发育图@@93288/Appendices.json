{"hands_on_practices": [{"introduction": "乍一看，系统发育树的视觉布局似乎传达了重要信息。然而，树枝的旋转并不会改变物种间的进化关系。这个练习将帮助你穿过视觉表象，专注于系统发育树的核心信息——分支模式或拓扑结构，它定义了物种间的姐妹群关系。通过比较两个表面上不同但可能在拓扑上等价的树，你将学会如何准确地解读进化历史。[@problem_id:2311348]", "problem": "一位外空生物学家正在研究一颗遥远行星上新发现的五个外星物种的演化历史。我们称它们为物种V、W、X、Y和Z。两位不同的研究生使用相同的遗传数据集，但使用不同的可视化软件，生成了对该系统发育树的两种文本描述。你的任务是判断他们关于演化关系的结论是相同还是不同。\n\n**树1描述：**\n该树以物种Z为外群作为根，这意味着它与所有其他物种的亲缘关系最远。剩下的四个物种形成一个单系群，该单系群分裂成两个主分支。第一个分支导向物种Y。第二个分支导向一个包含物种V、W和X的较小群体。在这个较小的群体中，物种X是包含物种V和物种W（它们是彼此亲缘关系最近的物种）的分支的姐妹类群。\n\n**树2描述：**\n该树以物种Z为外群作为根。导向其他四个物种的谱系立即分裂成两个分支。第一个分支由物种V、W和X组成。第二个分支仅包含物种Y。在第一个分支中，物种V和物种W是姐妹类群，并且与任何其他物种相比，这对姐妹类群与物种X共享一个更晚近的共同祖先。\n\n以下哪个陈述正确地评估了这两棵树？\n\nA. 这两棵树代表了不同的演化历史，因为物种Y和(V, W, X)分支的位置互换了。\n\nB. 这两棵树代表了不同的演化历史，因为在树1中，物种Y似乎比物种X更“高等”，而在树2中它们的关系不明确。\n\nC. 这两棵树代表了相同的演化历史，因为两者的姐妹群关系模式是相同的。\n\nD. 这两棵树代表了相同的演化历史，但这仅仅是因为物种Z在两者中都是外群。不同的外群会使它们不等价。\n\nE. 如果没有看到代表演化时间的分支长度，就不可能确定它们的历史是相同还是不同。", "solution": "我们首先解释标准的系统发育术语。一棵有外群的有根树意味着树根位于导向外群的分支上，而所有其他类群构成内群。一个分支（单系群）包括一个祖先及其所有后代。姐妹类群共享一个直接的共同祖先。两棵有根树代表相同的演化历史，当且仅当它们的姐妹群关系和嵌套分支（拓扑结构）的集合是相同的。\n\n解析树1：\n- 以Z为外群作为根意味着Z是内群 $\\{V,W,X,Y\\}$ 的姐妹群。\n- 内群分裂成两个主分支：一个是单独的 $Y$ ，另一个是分支 $\\{V,W,X\\}$。\n- 在 $\\{V,W,X\\}$ 内部, $X$ 是包含 $V$ 和 $W$ 的分支的姐妹群，而 $V$ 和 $W$ 是姐妹类群。\n- 因此，层级化的姐妹关系是：\n  $$ (V,W) \\text{ are sisters}, \\quad X \\text{ is sister to } (V,W), \\quad Y \\text{ is sister to } (X,(V,W)). $$\n\n解析树2：\n- 以Z为外群作为根意味着Z是内群 $\\{V,W,X,Y\\}$ 的姐妹群。\n- 内群立即分裂成两个分支：$\\{V,W,X\\}$ 和 $\\{Y\\}$，因此 $Y$ 是分支 $\\{V,W,X\\}$ 的姐妹群。\n- 在 $\\{V,W,X\\}$ 内部，$V$ 和 $W$ 是姐妹类群，并且这对姐妹类群与 $X$ 共享的共同祖先比与任何其他物种的共同祖先都更晚近；这等价于，$X$ 是 $(V,W)$ 的姐妹群。\n- 因此，层级化的姐妹关系是相同的：\n  $$ (V,W) \\text{ are sisters}, \\quad X \\text{ is sister to } (V,W), \\quad Y \\text{ is sister to } (X,(V,W)). $$\n\n比较：\n- 两棵树在以Z为外群的情况下，在 $\\{V,W,X,Y\\}$ 上具有相同的有根拓扑结构。\n- 因此，两种描述中的姐妹群关系模式是相同的。\n- 选项评估：\n  - A 不正确：两种描述都没有交换位置；两者都将 $Y$ 置于分支 $\\{V,W,X\\}$ 的姐妹群位置。\n  - B 不正确：不存在更“高等”的排序；两者都指定了 $Y$ 和 $X$ 之间相同的拓扑结构。\n  - C 正确：姐妹群关系完全匹配。\n  - D 不正确：等价性是由于拓扑结构相同，而不仅仅是共享外群。\n  - E 不正确：评估拓扑等价性不需要分支长度。\n\n因此，正确选项是C。", "answer": "$$\\boxed{C}$$", "id": "2311348"}, {"introduction": "对于任何一组物种，我们都可以构建出许多可能的进化树。那么，我们如何确定哪一棵树最能代表它们的进化历史呢？最大简约法是回答这个问题的一种经典方法。该原则主张，最可信的进化树是需要最少进化变化（例如，DNA序列中的核苷酸替换）来解释我们观察到的数据的那一棵。这个练习让你亲手计算不同拓扑结构的简约性得分，从而深入理解如何应用这个强大的推断原则。[@problem_id:2378551]", "problem": "下文给出了一个包含 $4$ 个分类单元和 $5$ 个位点的脱氧核糖核酸（DNA）序列比对。假设每个位点都遵循最大简约性原则独立进化，其中一棵树的简约性得分定义为：为解释在叶节点上观察到的状态，所有分支上所需发生的性状状态变化的最小总数，并对所有位点求和。这些分类单元是 $\\mathrm{T}_1$、$\\mathrm{T}_2$、$\\mathrm{T}_3$ 和 $\\mathrm{T}_4$。每个位点观察到的核苷酸状态如下：\n- 位点 $1$：$\\mathrm{T}_1=A$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=G$, $\\mathrm{T}_4=G$。\n- 位点 $2$：$\\mathrm{T}_1=C$, $\\mathrm{T}_2=T$, $\\mathrm{T}_3=C$, $\\mathrm{T}_4=T$。\n- 位点 $3$：$\\mathrm{T}_1=G$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=A$, $\\mathrm{T}_4=G$。\n- 位点 $4$：$\\mathrm{T}_1=A$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=A$, $\\mathrm{T}_4=A$。\n- 位点 $5$：$\\mathrm{T}_1=A$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=C$, $\\mathrm{T}_4=G$。\n\n考虑这 $4$ 个分类单元可能存在的三种无根二叉树拓扑结构，它们分别对应于双分组合 $\\big((\\mathrm{T}_1,\\mathrm{T}_2),(\\mathrm{T}_3,\\mathrm{T}_4)\\big)$、$\\big((\\mathrm{T}_1,\\mathrm{T}_3),(\\mathrm{T}_2,\\mathrm{T}_4)\\big)$ 和 $\\big((\\mathrm{T}_1,\\mathrm{T}_4),(\\mathrm{T}_2,\\mathrm{T}_3)\\big)$。对于每种拓扑结构，通过将每个位点所需的状态变化的最小数量相加来计算总简约性得分。然后，将这 $3$ 个总简约性得分中的最小值作为一个整数作为您的最终答案报告。不包含任何单位。无需四舍五入。", "solution": "该问题要求使用最大简约性准则来评估树的拓扑结构。目标是为 $4$ 个分类单元 $(\\mathrm{T}_1, \\mathrm{T}_2, \\mathrm{T}_3, \\mathrm{T}_4)$ 的 $3$ 种可能的无根二叉树拓扑结构分别计算总简约性得分，并找出最小得分。这三种拓扑结构由以下双分组合定义：\n$T_1: ((\\mathrm{T}_1, \\mathrm{T}_2), (\\mathrm{T}_3, \\mathrm{T}_4))$\n$T_2: ((\\mathrm{T}_1, \\mathrm{T}_3), (\\mathrm{T}_2, \\mathrm{T}_4))$\n$T_3: ((\\mathrm{T}_1, \\mathrm{T}_4), (\\mathrm{T}_2, \\mathrm{T}_3))$\n\n一个拓扑结构的总简约性得分是独立计算的 $5$ 个位点得分的总和。单个位点的得分是解释树的叶节点上观察到的性状状态所需的核苷酸替换的最小数量。设 $S_i(\\mathcal{T})$ 表示位点 $i$ 在拓扑结构 $\\mathcal{T}$ 上的简约性得分。拓扑结构 $\\mathcal{T}$ 的总得分为 $S_{total}(\\mathcal{T}) = \\sum_{i=1}^{5} S_i(\\mathcal{T})$。\n\n位点 $1$：性状状态为 $(\\mathrm{T}_1, \\mathrm{T}_2, \\mathrm{T}_3, \\mathrm{T}_4) = (A, A, G, G)$。\n对于拓扑结构 $T_1$，双分组合为 $((\\mathrm{T}_1, \\mathrm{T}_2), (\\mathrm{T}_3, \\mathrm{T}_4))$，将状态分组为 $((A,A), (G,G))$。这需要在连接两组的中心分支上进行一次替换。因此，$S_1(T_1) = 1$。\n对于拓扑结构 $T_2$，双分组合为 $((\\mathrm{T}_1, \\mathrm{T}_3), (\\mathrm{T}_2, \\mathrm{T}_4))$，将状态分组为 $((A,G), (A,G))$。每个组需要一次替换，最小总变化数为 $2$。$S_1(T_2) = 2$。\n对于拓扑结构 $T_3$，双分组合为 $((\\mathrm{T}_1, \\mathrm{T}_4), (\\mathrm{T}_2, \\mathrm{T}_3))$，将状态分组为 $((A,G), (A,G))$。同样需要 $2$ 次替换。$S_1(T_3) = 2$。\n位点 $1$ 的得分：$(1, 2, 2)$。\n\n位点 $2$：性状状态为 $(C, T, C, T)$。\n对于 $T_1$，分组为 $((C,T), (C,T))$。每个组需要一次替换。总计：$S_2(T_1) = 2$。\n对于 $T_2$，分组为 $((C,C), (T,T))$。这需要在中心分支上进行一次替换。总计：$S_2(T_2) = 1$。\n对于 $T_3$，分组为 $((C,T), (T,C))$。每个组需要一次替换。总计：$S_2(T_3) = 2$。\n位点 $2$ 的得分：$(2, 1, 2)$。\n\n位点 $3$：性状状态为 $(G, A, A, G)$。\n对于 $T_1$，分组为 $((G,A), (A,G))$。每个组需要一次替换。总计：$S_3(T_1) = 2$。\n对于 $T_2$，分组为 $((G,A), (A,G))$。每个组需要一次替换。总计：$S_3(T_2) = 2$。\n对于 $T_3$，分组为 $((G,G), (A,A))$。这需要在中心分支上进行一次替换。总计：$S_3(T_3) = 1$。\n位点 $3$ 的得分：$(2, 2, 1)$。\n\n位点 $4$：性状状态为 $(A, A, A, A)$。\n这是一个恒定位点。任何拓扑结构都不需要替换。\n$S_4(T_1) = S_4(T_2) = S_4(T_3) = 0$。\n位点 $4$ 的得分：$(0, 0, 0)$。\n\n位点 $5$：性状状态为 $(A, A, C, G)$。\n该位点有三种不同的状态，形式为 $(X, X, Y, Z)$，这种位点不是简约性信息位点，即它对所有拓扑结构都产生相同的得分。对于任意拓扑，最小变化数都是 $2$。\n$S_5(T_1) = 2$。\n$S_5(T_2) = 2$。\n$S_5(T_3) = 2$。\n位点 $5$ 的得分：$(2, 2, 2)$。\n\n现在，通过将所有 $5$ 个位点的得分相加，计算每种拓扑结构的总简约性得分。\n\n$T_1$ 的总得分：\n$S_{total}(T_1) = S_1(T_1) + S_2(T_1) + S_3(T_1) + S_4(T_1) + S_5(T_1) = 1 + 2 + 2 + 0 + 2 = 7$。\n\n$T_2$ 的总得分：\n$S_{total}(T_2) = S_1(T_2) + S_2(T_2) + S_3(T_2) + S_4(T_2) + S_5(T_2) = 2 + 1 + 2 + 0 + 2 = 7$。\n\n$T_3$ 的总得分：\n$S_{total}(T_3) = S_1(T_3) + S_2(T_3) + S_3(T_3) + S_4(T_3) + S_5(T_3) = 2 + 2 + 1 + 0 + 2 = 7$。\n\n三种拓扑结构的总简约性得分均为 $7$。根据给定的数据，所有三种拓扑结构都具有同等的简约性。简约性信息位点（$1$、$2$ 和 $3$）各自支持一种不同的拓扑结构，导致了平局。\n\n问题要求报告这三个得分中的最小值。\n最小得分是 $\\min(7, 7, 7) = 7$。", "answer": "$$\\boxed{7}$$", "id": "2378551"}, {"introduction": "基因的进化故事并不总是与物种的进化故事完全一致。一个基因谱系内的分歧可能由物种形成事件引起，也可能源于基因在共同祖先中的复制。这个练习将引导你进入一个被称为“树调和”（tree reconciliation）的强大应用，通过比较基因树和物种树来区分这两种事件。通过实现调和算法的核心逻辑，你将学会如何从系统发育不一致的模式中推断出基因复制和物种形成等关键的进化事件，从而更深入地洞察基因组的演化过程。[@problem_id:2378555]", "problem": "给定两个有根的严格二叉分支图：一个叶集为 $\\Sigma_S$ 的物种树 $S$ 和一个叶集为 $\\Sigma_G$ 的基因树 $G$。每个基因叶节点 $g \\in \\Sigma_G$ 通过一个给定的函数 $m : \\Sigma_G \\to \\Sigma_S$ 映射到一个物种叶节点。对于物种树 $S$ 中的任意两个节点 $x$ 和 $y$，将其最近公共祖先 (LCA) 定义为 $\\mathrm{LCA}_S(x,y)$。定义从基因树 $G$ 的节点到物种树 $S$ 的节点的协配映射 $M$：如果 $g$ 是 $G$ 的一个叶节点，则 $M(g)=m(g)$；对于 $G$ 中任何一个拥有子节点 $u$ 和 $v$ 的内部节点 $g$，定义 $M(g) = \\mathrm{LCA}_S\\!\\big(M(u), M(v)\\big)$。如果 $M(g)=M(u)$ 或 $M(g)=M(v)$，则 $G$ 的内部节点 $g$ 被标记为基因重复 (duplication)；否则，它被标记为物种形成 (speciation)。\n\n你的任务是编写一个完整的程序，对每个测试用例，使用上述规则将 $G$ 的每个内部节点标记为基因重复或物种形成，并以后序（左子树、右子树、然后是节点）返回一个布尔值列表，其中布尔值 $\\mathrm{True}$ 表示基因重复，布尔值 $\\mathrm{False}$ 表示物种形成。后序由 $G$ 的 Newick 表示法所蕴含的从左到右的顺序决定。如果 $G$ 没有内部节点，则返回一个空列表。所有树都以不带分支长度的 Newick 格式提供。映射 $m$ 以键值对集合的形式明确提供。最终程序不得读取输入，必须使用内嵌的测试套件。\n\n共有 $4$ 个测试用例。在每个用例中，物种树 $S$、基因树 $G$ 和映射 $m$ 的规定如下：\n\n- 测试用例 1：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"((ax,bz),(cw,dx));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"bz\"} \\mapsto \\text{\"B\"},\\, \\text{\"cw\"} \\mapsto \\text{\"C\"},\\, \\text{\"dx\"} \\mapsto \\text{\"D\"}\\,\\}$\n\n- 测试用例 2：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"(((ax,ay),bz),(cw,dx));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"ay\"} \\mapsto \\text{\"A\"},\\, \\text{\"bz\"} \\mapsto \\text{\"B\"},\\, \\text{\"cw\"} \\mapsto \\text{\"C\"},\\, \\text{\"dx\"} \\mapsto \\text{\"D\"}\\,\\}$\n\n- 测试用例 3：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"((ax,ay),(az,aw));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"ay\"} \\mapsto \\text{\"A\"},\\, \\text{\"az\"} \\mapsto \\text{\"A\"},\\, \\text{\"aw\"} \\mapsto \\text{\"A\"}\\,\\}$\n\n- 测试用例 4：\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"ax;\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"}\\,\\}$\n\n你的程序应处理这 $4$ 个测试用例，并生成单行输出。该输出包含一个用方括号括起来的逗号分隔列表，其中每个元素是对应一个测试用例的后序布尔标签列表。例如，一个有效的输出格式是 $\\text{\"[[False,True],[True],[False,False,True],[]]\"}$。不涉及任何物理单位或角度单位。所有布尔输出必须表示为编程语言的规范布尔字面量。每个测试用例的答案必须是一个布尔值列表，最终输出必须是这些列表的列表，并严格按照指定格式打印在单行上。", "solution": "所呈现的问题是计算生物学中的一个经典算法任务：将基因树与物种树进行协配，以推断演化事件。所描述的方法是标准的最近公共祖先 (LCA) 协配，这是一种简约模型，用于解释基因谱系与其所属的生物体谱系之间的不一致。解决方案需要实现几个不同但相关的算法，我们将逐步构建这些算法。\n\n解决方案的逻辑结构如下：\n1.  将物种树 $S$ 和基因树 $G$ 的 Newick 字符串表示解析为计算树数据结构。\n2.  预处理物种树 $S$，以便能高效计算其中任意两个节点的最近公共祖先 ($\\mathrm{LCA}_S$) 。\n3.  以后序遍历基因树 $G$，应用协配映射 $M$ 来确定每个内部节点处的事件（基因重复或物种形成）。\n\n下面我们详细说明每个步骤。\n\n树可以用基于节点的结构来表示，其中每个节点对象存储对其父节点和子节点的引用。节点也可以有名称，这对于叶节点至关重要。为此我们定义一个 `Node` 类。子节点存储在一个有序列表中，以保留 Newick 格式指定的从左到右的拓扑结构。在严格二叉树中，一个内部节点正好有 $2$ 个子节点，而叶节点有 $0$ 个。\n\n必须将 Newick 格式的字符串解析成这种 `Node` 结构。递归下降解析器非常适合这项工作。给定一个子树的 Newick 字符串，解析器按如下方式操作：\n- 如果字符串不以 `(` 开头，它表示一个叶节点。此时创建一个新的 `Node`，并以该字符串作为其名称。\n- 如果字符串的形式是 `(left,right)`，它表示一个内部节点。此时创建一个新的 `Node`。根据分隔两个主要子树的逗号，将字符串分割成 `left` 和 `right` 部分。这需要通过平衡括号检查来找到正确的分割逗号。然后对 `left` 和 `right` 子字符串递归调用解析器以生成子树。生成的子节点被附加到当前节点的子节点列表中，并保留指定的顺序。\n\n解析物种树 $S$ 后，我们增强其结构以支持高效的 LCA 查询。这通过遍历树一次为每个节点建立 `parent` 指针来实现。有了父指针，物种树 $S$ 中两个节点 $n_1$ 和 $n_2$ 的 $\\mathrm{LCA}_S(n_1, n_2)$ 可以这样找到：首先将 $n_1$ 的所有祖先（包括 $n_1$ 自身）收集到一个集合中。然后，从 $n_2$ 开始向上遍历，直到遇到一个存在于该集合中的节点。找到的第一个这样的公共祖先就是 $\\mathrm{LCA}_S(n_1, n_2)$。\n\n解决方案的核心是协配算法，我们将其实现为一个递归函数，称之为 $ReconcileAndLabel(g\\_node, \\dots)$。该函数遍历基因树 $G$，并在每个节点上执行三个操作：计算该节点在协配映射 $M$ 下在物种树 $S$ 中的像，如果该节点是内部节点则对其进行分类，并返回其在 $S$ 中的映射。遍历顺序是后序（左子节点、右子节点、节点），这是递归的自然结果。\n\n函数 $ReconcileAndLabel$ 定义如下：\n- **输入**：基因树 $G$ 中的一个节点 $g$。\n- **输出**：节点 $g$ 映射到的物种树 $S$ 中的节点 $s \\in S$，即 $s = M(g)$。作为副作用，它会填充一个内部节点的布尔标签列表。\n\n**基本情况**：如果输入节点 $g$ 是一个叶节点（即有 $0$ 个子节点），其映射 $M(g)$ 由函数 $m$ 给出。我们查找 $m(g.name)$ 以获取相应物种叶节点的名称，然后在我们已解析的物种树 $S$ 中找到该叶节点的 `Node` 对象。返回此 `Node` 对象。\n\n**递归步骤**：如果输入节点 $g$ 是一个拥有子节点 $u$ 和 $v$ 的内部节点（在严格二叉树中，它们将是 $g.children[0]$ 和 $g.children[1]$），算法按以下步骤进行：\n1.  对左子节点 $u$ 递归调用该函数：$s_u = ReconcileAndLabel(u, \\dots)$。\n2.  对右子节点 $v$ 递归调用该函数：$s_v = ReconcileAndLabel(v, \\dots)$。\n3.  通过找到其子节点映射的 LCA 来计算当前节点 $g$ 的映射：$s_g = M(g) = \\mathrm{LCA}_S(s_u, s_v)$。\n4.  对节点 $g$ 处的事件进行分类。根据定义，如果 $M(g) = M(u)$ 或 $M(g) = M(v)$，则 $g$ 代表一个基因重复事件。在我们的实现中，这对应于检查节点对象 $s_g$ 是否与 $s_u$ 或 $s_v$ 完全相同。如果此条件成立，则事件为基因重复（$\\mathrm{True}$）。否则，为物种形成（$\\mathrm{False}$）。\n5.  节点 $g$ 的这个布尔标签被追加到一个全局结果列表中。由于此步骤在对子节点的递归调用完成后发生，所以标签是以后序序列收集的。\n6.  该函数返回物种树节点 $s_g$。\n\n主过程初始化一个空列表用于存放标签，然后对基因树 $G$ 的根节点调用 $ReconcileAndLabel$。如果基因树只包含一个节点（根即叶），则它没有内部节点，按要求返回一个空列表。否则，填充好的标签列表就是给定测试用例的结果。对每个提供的测试用例重复这整个过程。", "answer": "```python\nimport numpy as np\n\n# Note: The problem environment specifies numpy and scipy as available,\n# but they are not required for this particular algorithmic problem.\n# We include the numpy import to adhere to the specified environment setup.\n\nclass Node:\n    \"\"\"Represents a node in a tree.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        self.parent = None\n        self.children = []\n\n    def __repr__(self):\n        return f\"Node({self.name or 'internal'})\"\n\ndef parse_newick(newick_str: str) -> Node:\n    \"\"\"\n    Parses a Newick format string into a tree of Node objects.\n    Assumes strictly binary trees for internal nodes, but handles single-node trees.\n    \"\"\"\n    clean_str = newick_str.strip()\n    if clean_str.endswith(';'):\n        clean_str = clean_str[:-1]\n\n    if '(' not in clean_str:\n        # It's a single leaf node tree, e.g., \"ax\"\n        return Node(name=clean_str)\n\n    # Use a stack-based approach for robustness\n    stack = []\n    current_node = None\n    i = 0\n    while i < len(clean_str):\n        char = clean_str[i]\n        if char == '(':\n            new_node = Node()\n            if current_node:\n                current_node.children.append(new_node)\n            stack.append(new_node)\n            current_node = new_node\n        elif char == ',':\n            # Move from left sibling to parent, ready for right sibling\n            current_node = stack[-1]\n        elif char == ')':\n            # Finished with children of node on stack, pop it\n            current_node = stack.pop()\n        elif char not in ' ;':\n            # It's a name\n            name_start = i\n            while i + 1 < len(clean_str) and clean_str[i+1] not in ',)':\n                i += 1\n            name = clean_str[name_start:i+1]\n            leaf_node = Node(name=name)\n            if current_node:\n                current_node.children.append(leaf_node)\n        i += 1\n\n    return current_node or Node(name=clean_str) # Handles single node \"(A);\" case too\n\ndef add_parents(node: Node, parent: Node = None):\n    \"\"\"Recursively adds parent pointers to all nodes in a tree.\"\"\"\n    node.parent = parent\n    for child in node.children:\n        add_parents(child, node)\n\ndef collect_leaves(node: Node, leaf_map: dict):\n    \"\"\"Recursively collects leaf nodes into a dictionary mapping name to node.\"\"\"\n    if not node.children:\n        if node.name:\n            leaf_map[node.name] = node\n    else:\n        for child in node.children:\n            collect_leaves(child, leaf_map)\n\ndef get_lca(node1: Node, node2: Node) -> Node:\n    \"\"\"Finds the Least Common Ancestor of two nodes in a tree with parent pointers.\"\"\"\n    path_to_root1 = set()\n    curr = node1\n    while curr:\n        path_to_root1.add(curr)\n        curr = curr.parent\n    \n    curr = node2\n    while curr:\n        if curr in path_to_root1:\n            return curr\n        curr = curr.parent\n    # Should not be reached in a valid tree with common root\n    raise ValueError(\"Nodes do not share a common ancestor.\")\n\ndef reconcile_and_label(g_node: Node, s_leaf_map: dict, m_mapping: dict, labels: list) -> Node:\n    \"\"\"\n    Recursively traverses the gene tree, computes the reconciliation map,\n    labels internal nodes, and returns the mapped species tree node.\n    \"\"\"\n    if not g_node.children:  # Base case: g_node is a leaf\n        species_leaf_name = m_mapping[g_node.name]\n        return s_leaf_map[species_leaf_name]\n\n    # Recursive step: g_node is internal. Process children first (postorder).\n    # Newick order corresponds to children[0] (left) and children[1] (right).\n    s_map_left = reconcile_and_label(g_node.children[0], s_leaf_map, m_mapping, labels)\n    s_map_right = reconcile_and_label(g_node.children[1], s_leaf_map, m_mapping, labels)\n\n    # Compute mapping for the current node g\n    s_map_lca = get_lca(s_map_left, s_map_right)\n\n    # Classify event and record the label\n    # The check must be by object identity (is), not by value (==).\n    is_duplication = (s_map_lca is s_map_left) or (s_map_lca is s_map_right)\n    labels.append(is_duplication)\n    \n    return s_map_lca\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        (\n            \"((A,B),(C,D));\",\n            \"((ax,bz),(cw,dx));\",\n            {\"ax\": \"A\", \"bz\": \"B\", \"cw\": \"C\", \"dx\": \"D\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"(((ax,ay),bz),(cw,dx));\",\n            {\"ax\": \"A\", \"ay\": \"A\", \"bz\": \"B\", \"cw\": \"C\", \"dx\": \"D\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"((ax,ay),(az,aw));\",\n            {\"ax\": \"A\", \"ay\": \"A\", \"az\": \"A\", \"aw\": \"A\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"ax;\",\n            {\"ax\": \"A\"}\n        ),\n    ]\n\n    all_results = []\n    for s_newick, g_newick, m_mapping in test_cases:\n        # 1. Prepare the species tree\n        s_root = parse_newick(s_newick)\n        add_parents(s_root)\n        s_leaf_map = {}\n        collect_leaves(s_root, s_leaf_map)\n\n        # 2. Prepare the gene tree\n        g_root = parse_newick(g_newick)\n        \n        # 3. Handle edge case of a single-node gene tree\n        if not g_root.children:\n            all_results.append([])\n            continue\n        \n        # 4. Reconcile and get postorder labels\n        labels = []\n        reconcile_and_label(g_root, s_leaf_map, m_mapping, labels)\n        all_results.append(labels)\n\n    # 5. Format and print the final output as a string representation of a list of lists.\n    # The string representation of a Python list of booleans matches the required format.\n    formatted_results = ','.join(map(str, all_results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2378555"}]}