{"hands_on_practices": [{"introduction": "分子钟假说的核心思想是，在恒定的进化速率下，遗传距离与时间成正比。对于在同一时间点采样的所有物种，这一假设有一个直接的几何推论：它们到其共同祖先的进化路径长度应该完全相等，这一特性被称为“超度量性”(ultrametricity)。本练习将指导你编写一个程序来检验系统发育树是否满足这一基本属性，这是验证严格分子钟假设的第一个也是最关键的计算步骤。[@problem_id:2435884]", "problem": "您的任务是验证严格分子钟假说，该假说应用于以 Newick 格式表示且带有枝长的有根系统发育树。在严格分子钟假说下，如果所有分类单元都是同时采样的，那么从根节点到任何叶尖节点所累积的每个位点的预期替换数是相等的。这是因为每个位点的瞬时替换率（用 $r$ 表示）被假定在所有时间和谱系中都是恒定的，并且在此类树中，枝长代表每个位点的预期替换数，该值与流逝的时间成正比。因此，在一棵现存叶尖节点为同时代的有根树中，每条从根到叶尖的路径长度都应该相等（在数值容差范围内）。\n\n基本原理：\n- 在一个替换过程遵循时间齐次泊松过程、每个位点替换速率恒为 $r$ 的情况下，长度为 $t$ 的时间间隔内的预期替换数为 $r t$。在一棵叶尖节点同时代的有根树中，从根到每个叶尖所流逝的时间是相同的（设为 $T$），因此沿任一根到叶尖路径的总预期替换数为 $r T$。由于枝长编码了每个位点的预期替换数，对于一棵遵循严格分子钟的树，所有根到叶尖路径的枝长之和应该相等。\n\n本任务的定义：\n- 一个 Newick 格式的有根带权重树定义了一组带标签的叶节点（叶尖），并且每条边都带有一个非负长度，该长度等于该边上每个位点的预期替换数。\n- 对每个叶节点 $i$，设 $L_i$ 为其总根到叶尖长度，定义为从根节点到该叶节点的唯一路径上所有枝长的总和。\n- 给定一个非负容差 $\\epsilon$，如果 $\\max_i L_i - \\min_i L_i \\le \\epsilon$，则该树被称为超度量树。\n- 如果树不是超度量的，定义根到叶尖长度的中位数 $\\tilde{L}$ 为 $\\{L_i\\}$ 的中位数。最不符合分子钟的谱系是其绝对偏差 $|L_i - \\tilde{L}|$ 最大的叶尖。如果出现平局，选择标签字典序最小的谱系。\n- 为了使输出无需字符串即可进行机器检查，请按如下方式为叶节点定义一个索引映射：列出所有叶节点标签，按字典升序排序，并按顺序分配索引 $0,1,2,\\dots$。报告最不符合分子钟的谱系的索引。如果树是超度量的，则报告谱系索引为 $-1$，偏差为 $0.0$。\n\n您的程序必须：\n- 将带有枝长的有根 Newick 树字符串解析为一种内部表示。输入字符串将是语法有效的 Newick 格式，并且始终是有根的。您必须正确处理多歧点（度大于 $2$ 的节点）、叶节点和内部节点，它们都可能带有标签。所有枝长都是非负实数，并且所有叶节点都有标签。\n- 计算所有根到叶尖的长度 $\\{L_i\\}$。\n- 使用容差 $\\epsilon$ 判断树的超度量性。\n- 如果是非超度量树，则按照上述定义识别最不符合分子钟的谱系，并计算其最大绝对偏差 $d^\\star = \\max_i |L_i - \\tilde{L}|$。\n- 对于每个测试用例，输出一个三元组 $[u,k,d]$，其中 $u$ 是一个指示超度量性的布尔值，$k$ 是如上定义的整数谱系索引，$d$ 是浮点数 $d^\\star$。如果 $u$ 为真，则输出 $k=-1$ 和 $d=0.0$。使用标准四舍五入将 $d$ 保留到 $6$ 位小数。\n\n角度单位不适用。枝长单位是“每个位点的预期替换数”。输出是如上所述的无单位数值数据。\n\n测试套件：\n使用以下测试用例，每个用例指定为一个元组 $(\\text{Newick}, \\epsilon)$。\n- 案例 1 (严格超度量，平衡二叉树):\n  - Newick: $((A:0.1,B:0.1):0.2,C:0.3);$\n  - $\\epsilon = 10^{-9}$\n- 案例 2 (非超度量，一个谱系更长):\n  - Newick: $((A:0.1,B:0.2):0.2,C:0.3);$\n  - $\\epsilon = 10^{-6}$\n- 案例 3 (在容差范围内的近似超度量):\n  - Newick: $((A:0.1,B:0.1):0.2,C:0.3000004);$\n  - $\\epsilon = 5\\times 10^{-7}$\n- 案例 4 (单叶尖有根树):\n  - Newick: $(A:0.5);$\n  - $\\epsilon = 10^{-9}$\n- 案例 5 (有根多歧点，一个叶尖稍长):\n  - Newick: $(A:0.2,B:0.2,C:0.21,D:0.2);$\n  - $\\epsilon = 0.005$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。列表中的每个元素按上述顺序对应一个测试用例的结果。每个测试用例的结果本身必须是 $[u,k,d]$ 形式的列表。例如，包含两个假设案例的输出看起来像 `[[True,-1,0.0],[False,1,0.123456]]`。", "solution": "这个问题是适定的、有科学依据且客观的。它基于分子钟假说（进化生物学中的一个基本概念）提出了一个清晰的计算任务。所有术语，如 Newick 格式、根到叶尖长度和超度量性，都得到了精确定义。输入、预期输出和评估标准（包括平局打破规则）都被明确规定，没有歧义。因此，该问题是有效的，可以构建一个解决方案。\n\n该解决方案通过遵循一系列逻辑步骤来实现：\n1.  **树解析**：代表有根系统发育树的 Newick 格式字符串必须被解析为合适的内存数据结构。这里采用了一种递归下降的解析策略。树使用一个 `Node` 类来表示，其中每个实例存储其名称（如果有的话）、通向它的枝的长度，以及对其父节点和子节点的引用。解析器首先分割根节点的子节点，然后递归调用一个函数来解析每个子节点的子树字符串。这种方法能正确处理嵌套结构和多歧点。\n\n2.  **根到叶尖长度计算**：树被解析后，需要计算每个叶节点 $i$ 的根到叶尖距离 $L_i$。这通过从树的根节点开始进行深度优先遍历来实现。函数 `_get_root_to_tip_lengths` 递归地遍历树，累加每条路径上的枝长之和。当到达一个叶节点时，其名称和总路径长度被存储下来。结果是树中所有叶节点的 $(name_i, L_i)$ 序对的集合。\n\n3.  **超度量性测试**：分子钟假说意味着，在一棵具有同时代叶尖的、完美的分子钟树中，所有根到叶尖的路径长度应该相等。此属性被称为超度量性。为了测试这一点，我们计算最大和最小根到叶尖长度之差，即 $\\max_i L_i - \\min_i L_i$。如果该差值小于或等于给定的容差 $\\epsilon$，则该树被认为是超度量的。在这种情况下，根据问题规范，结果被记录为超度量树（$u=\\text{True}$），谱系索引为 $k=-1$，偏差为 $d=0.0$。\n\n4.  **非超度量分析**：如果树未通过超度量性测试（$\\max_i L_i - \\min_i L_i > \\epsilon$），它将被声明为非超度量树（$u=\\text{False}$）。根据问题定义，我们必须识别出最不符合分子钟的谱系。这涉及以下步骤：\n    a.  从所有 $\\{L_i\\}$ 的集合中计算出根到叶尖长度的中位数 $\\tilde{L}$。使用 `numpy.median` 函数进行此计算，该函数能正确处理奇数和偶数个元素的情况。\n    b.  对每个叶节点 $i$，计算其路径长度与中位数的绝对偏差：$|L_i - \\tilde{L}|$。\n    c.  找出这些偏差中的最大值 $d^\\star = \\max_i |L_i - \\tilde{L}|$。该值使用 Python 内置的 `round()` 函数四舍五入到 6 位小数，对应于输出值 $d$。\n    d.  识别与该最大偏差对应的谱系。如果出现平局（多个谱系表现出相同的最大偏差），问题规定了平局打破规则：选择标签字典序最小的谱系。\n    e.  最后，必须确定所识别谱系的索引 $k$。通过对所有叶节点标签进行字典序排序并分配索引 $0, 1, 2, \\dots$ 来创建一个索引映射。所选谱系标签在此排序列表中的索引即为值 $k$。\n\n5.  **输出生成**：为每个测试用例生成一个三元组 $[u,k,d]$。这些三元组被收集到一个列表中。最终输出是一个表示这些结果三元组列表的单个字符串，其格式严格按照规定，例如 `[[True,-1,0.0],[False,1,0.100000]]`。", "answer": "```python\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in a phylogenetic tree.\"\"\"\n    def __init__(self, name=\"\", length=0.0):\n        self.name = name\n        self.length = length  # Branch length from parent to this node\n        self.parent = None\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\ndef _split_newick_children(s: str) -> list[str]:\n    \"\"\"Splits a Newick string section into its top-level children.\"\"\"\n    if not s:\n        return []\n    children = []\n    paren_level = 0\n    start = 0\n    for i, char in enumerate(s):\n        if char == '(':\n            paren_level += 1\n        elif char == ')':\n            paren_level -= 1\n        elif char == ',' and paren_level == 0:\n            children.append(s[start:i])\n            start = i + 1\n    children.append(s[start:])\n    return children\n\ndef _parse_newick_string(s: str) -> Node:\n    \"\"\"Recursively parses a Newick string component into a Node object.\"\"\"\n    s = s.strip()\n    \n    # Check for internal node syntax (e.g., (...)label:length)\n    if s.startswith('(') and s.endswith(')'):\n        # This is a special case of a whole subtree being passed without label/length\n        content = s[1:-1]\n        node = Node()\n        children_strings = _split_newick_children(content)\n        for child_s in children_strings:\n            child_node = _parse_newick_string(child_s)\n            node.add_child(child_node)\n        return node\n    \n    label_part = \"\"\n    length_part = \"\"\n    content = \"\"\n\n    last_paren = s.rfind(')')\n    if last_paren != -1: # Internal node\n        content = s[1:last_paren]\n        label_len_part = s[last_paren+1:]\n        if ':' in label_len_part:\n            label_part, length_part = label_len_part.split(':', 1)\n        else:\n            label_part = label_len_part\n    else: # Leaf node\n        if ':' in s:\n            label_part, length_part = s.split(':', 1)\n        else:\n            label_part = s\n    \n    name = label_part.strip()\n    length = float(length_part) if length_part else 0.0\n    \n    node = Node(name=name, length=length)\n\n    if last_paren != -1: # If internal, parse its children\n        children_strings = _split_newick_children(content)\n        for child_s in children_strings:\n            child_node = _parse_newick_string(child_s)\n            node.add_child(child_node)\n            \n    return node\n\ndef parse_newick(newick_str: str) -> Node:\n    \"\"\"Parses a full Newick string into a tree of Node objects.\"\"\"\n    if newick_str.endswith(';'):\n        newick_str = newick_str[:-1]\n    \n    root = _parse_newick_string(newick_str)\n    return root\n\ndef _get_root_to_tip_lengths(node: Node, current_length: float, lengths: dict):\n    \"\"\"Recursively traverses the tree to calculate all root-to-tip lengths.\"\"\"\n    path_len = current_length + node.length\n\n    if not node.children:  # It's a leaf\n        if node.name:\n            lengths[node.name] = path_len\n        return\n\n    for child in node.children:\n        _get_root_to_tip_lengths(child, path_len, lengths)\n\ndef process_tree(newick_str: str, epsilon: float) -> list:\n    \"\"\"Processes a single tree to check for ultrametricity and non-clock-like lineages.\"\"\"\n    root = parse_newick(newick_str)\n    \n    leaf_lengths = {}\n    _get_root_to_tip_lengths(root, 0.0, leaf_lengths)\n    \n    if not leaf_lengths:\n        return [True, -1, 0.0]\n\n    lengths = list(leaf_lengths.values())\n    max_len = max(lengths)\n    min_len = min(lengths)\n\n    if max_len - min_len <= epsilon:\n        return [True, -1, 0.0]\n    else: # Not ultrametric\n        u = False\n        median_l = np.median(lengths)\n        \n        deviations = {name: abs(length - median_l) for name, length in leaf_lengths.items()}\n        \n        max_deviation = -1.0\n        for dev in deviations.values():\n            if dev > max_deviation:\n                max_deviation = dev\n        \n        # Tie-breaking: find all candidates with max deviation, then choose lexicographically smallest name\n        candidates = []\n        # Use a small tolerance for floating point comparison\n        for name, dev in deviations.items():\n            if abs(dev - max_deviation) < 1e-12:\n                candidates.append(name)\n        \n        chosen_lineage = sorted(candidates)[0]\n        \n        sorted_labels = sorted(leaf_lengths.keys())\n        k = sorted_labels.index(chosen_lineage)\n        \n        d = round(max_deviation, 6)\n        \n        return [u, k, d]\n\n\ndef solve():\n    \"\"\"Main function to run the test suite and format the output.\"\"\"\n    test_cases = [\n        (\"((A:0.1,B:0.1):0.2,C:0.3);\", 1e-9),\n        (\"((A:0.1,B:0.2):0.2,C:0.3);\", 1e-6),\n        (\"((A:0.1,B:0.1):0.2,C:0.3000004);\", 5e-7),\n        (\"(A:0.5);\", 1e-9),\n        (\"(A:0.2,B:0.2,C:0.21,D:0.2);\", 0.005)\n    ]\n\n    results = []\n    for newick_str, epsilon in test_cases:\n        result = process_tree(newick_str, epsilon)\n        results.append(result)\n\n    formatted_results = []\n    for res in results:\n        u, k, d = res\n        # Manual formatting to match problem example (no spaces, Python bool literals)\n        formatted_results.append(f\"[{u},{k},{d:.6f}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2435884"}, {"introduction": "在真实的生物学数据中，由于抽样误差和其他随机因素，我们很少能观察到完美的超度量树。因此，我们需要一个统计框架来判断观测到的速率差异是显著的还是仅仅是随机波动。本练习将引导你实现一个相对速率检验(relative rate test)，通过比较两个内群谱系相对于一个外群的进化距离来检验速率一致性。你将使用对碱基组成偏差具有鲁棒性的对数行列式距离(log-determinant distance)，并采用非参数自举法(bootstrap)来评估其统计显著性，从而掌握一套更为严谨和实用的分子钟检验技术。[@problem_id:2435873]", "problem": "给你一个由分类单元 $A$、$B$ 和一个外类群 $O$ 表示的三元组，连同对齐的位点模式计数，这些计数对每个测试用例都被汇总为两个联合列联表：一个用于配对 $(A,O)$ 的 $4 \\times 4$ 矩阵 $C_{AO}$ 和一个用于配对 $(B,O)$ 的 $4 \\times 4$ 矩阵 $C_{BO}$。行对应于配对中第一个分类单元的核苷酸 $\\{A,C,G,T\\}$，列对应于第二个分类单元的核苷酸 $\\{A,C,G,T\\}$。每个条目都是一个非负整数计数。假设位点在任意时间同质、平稳但其他方面不受限制的核苷酸连续时间马尔可夫替换过程（通用马尔可夫模型）下独立演化。设 $\\epsilon>0$ 表示一个固定的伪计数，在形成概率之前将其添加到每个单元格中，以避免对零单元格进行对数运算时出现未定义的情况。设 $\\alpha \\in (0,1)$ 表示显著性水平，$B \\in \\mathbb{N}$ 表示自助法重复次数，$s \\in \\mathbb{N}$ 表示随机种子。\n\n将配对 $(X,O)$ 的经验联合概率矩阵定义为\n$$\n\\hat{P}_{XO} \\;=\\; \\frac{C_{XO} + \\epsilon \\mathbf{1}_{4 \\times 4}}{\\sum_{i=1}^{4}\\sum_{j=1}^{4}\\left(C_{XO}[i,j] + \\epsilon\\right)},\n$$\n其中 $\\mathbf{1}_{4 \\times 4}$ 是 $4 \\times 4$ 的全一矩阵。定义边际频率向量\n$$\n\\hat{p}_X(i) \\;=\\; \\sum_{j=1}^{4} \\hat{P}_{XO}[i,j], \\quad \\hat{p}_O(j) \\;=\\; \\sum_{i=1}^{4} \\hat{P}_{XO}[i,j].\n$$\n将 $X$ 和 $O$ 之间的平行线性（对数行列式）路径长度定义为\n$$\nd_{\\mathrm{PL}}(X,O) \\;=\\; -\\ln \\det\\!\\left(\\hat{P}_{XO}\\right) \\;+\\; \\frac{1}{2}\\,\\ln\\!\\left(\\prod_{i=1}^{4} \\hat{p}_X(i)\\right) \\;+\\; \\frac{1}{2}\\,\\ln\\!\\left(\\prod_{j=1}^{4} \\hat{p}_O(j)\\right).\n$$\n相对于 $O$ 的内类群对 $(A,B)$ 的严格分子钟的零假设为 $H_0: d_{\\mathrm{PL}}(A,O) = d_{\\mathrm{PL}}(B,O)$。考虑检验统计量\n$$\n\\Delta \\;=\\; d_{\\mathrm{PL}}(A,O) - d_{\\mathrm{PL}}(B,O).\n$$\n\n通过对位点进行非参数自助法来估计 $\\Delta$ 的抽样变异性，如下所示：对于每个具有观测计数 $C_{XO}$ 和总位点数 $n_{XO}=\\sum_{i,j}C_{XO}[i,j]$ 的配对 $(X,O)$，形成经验位点模式分布\n$$\n\\tilde{P}_{XO} \\;=\\; \\frac{C_{XO}}{n_{XO}}.\n$$\n对于 $b=1,\\dots,B$，独立地为 $(A,O)$ 和 $(B,O)$ 抽取自助法重复计数 $\\widetilde{C}_{XO}^{(b)} \\sim \\mathrm{Multinomial}\\!\\left(n_{XO}, \\mathrm{vec}\\!\\left(\\tilde{P}_{XO}\\right)\\right)$，其中 $\\mathrm{vec}$ 表示向量化为 $16$ 个类别。对于每次自助法重复，通过在 $d_{\\mathrm{PL}}$ 的定义中用 $\\widetilde{C}_{XO}^{(b)}$ 替换 $C_{XO}$（包括相同的 $\\epsilon$ 伪计数）来计算 $\\Delta^{(b)}$，并估计自助法标准差\n$$\n\\hat{\\sigma} \\;=\\; \\sqrt{\\frac{1}{B-1}\\sum_{b=1}^{B} \\left(\\Delta^{(b)} - \\overline{\\Delta}\\right)^2}, \\quad \\overline{\\Delta} \\;=\\; \\frac{1}{B}\\sum_{b=1}^{B}\\Delta^{(b)}.\n$$\n使用大样本正态近似构建标准化统计量 $Z = \\Delta / \\hat{\\sigma}$，并且如果 $|Z| \\ge z_{1-\\alpha/2}$，则在水平 $\\alpha$ 上拒绝 $H_0$，其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$-分位数。不涉及角度。不涉及物理单位。\n\n你的任务是实现一个程序，对于以下每个测试用例，返回一个布尔值，指示 $H_0$ 是否被拒绝（$\\mathrm{True}$）或未被拒绝（$\\mathrm{False}$）。该程序必须使用自然对数和上述的精确定义。自助法必须使用给定的 $B$ 和随机种子 $s$ 以保证可复现性。最终输出必须是单行，包含所有用例的结果，形式为方括号括起来的逗号分隔列表；每个条目必须是 $\\mathrm{True}$ 或 $\\mathrm{False}$。\n\n测试套件：\n\n- 用例 $1$（平衡，类时钟）：\n  - $C_{AO} = \\begin{bmatrix}\n  220 & 10 & 10 & 10\\\\\n  10 & 220 & 10 & 10\\\\\n  10 & 10 & 220 & 10\\\\\n  10 & 10 & 10 & 220\n  \\end{bmatrix}$,\n    $C_{BO} = \\begin{bmatrix}\n  220 & 10 & 10 & 10\\\\\n  10 & 220 & 10 & 10\\\\\n  10 & 10 & 220 & 10\\\\\n  10 & 10 & 10 & 220\n  \\end{bmatrix}$,\n    $\\epsilon = 0.5$, $B = 2000$, $\\alpha = 0.05$, $s = 7$.\n\n- 用例 $2$（$A$ 速率加速）：\n  - $C_{AO} = \\begin{bmatrix}\n  150 & 20 & 20 & 20\\\\\n  20 & 150 & 20 & 20\\\\\n  20 & 20 & 150 & 20\\\\\n  20 & 20 & 20 & 150\n  \\end{bmatrix}$,\n    $C_{BO} = \\begin{bmatrix}\n  240 & 5 & 5 & 5\\\\\n  5 & 240 & 5 & 5\\\\\n  5 & 5 & 240 & 5\\\\\n  5 & 5 & 5 & 240\n  \\end{bmatrix}$,\n    $\\epsilon = 0.5$, $B = 2000$, $\\alpha = 0.05$, $s = 13$.\n\n- 用例 $3$（边界：与外类群几乎相同）：\n  - $C_{AO} = \\begin{bmatrix}\n  250 & 0 & 0 & 0\\\\\n  0 & 250 & 0 & 0\\\\\n  0 & 0 & 250 & 0\\\\\n  0 & 0 & 0 & 250\n  \\end{bmatrix}$,\n    $C_{BO} = \\begin{bmatrix}\n  250 & 0 & 0 & 0\\\\\n  0 & 250 & 0 & 0\\\\\n  0 & 0 & 250 & 0\\\\\n  0 & 0 & 0 & 250\n  \\end{bmatrix}$,\n    $\\epsilon = 0.5$, $B = 2000$, $\\alpha = 0.05$, $s = 17$.\n\n- 用例 $4$（小样本，成分有偏，类时钟）：\n  - $C_{AO} = \\begin{bmatrix}\n  35 & 3 & 1 & 1\\\\\n  1 & 7 & 1 & 1\\\\\n  1 & 1 & 4 & 0\\\\\n  1 & 0 & 0 & 3\n  \\end{bmatrix}$,\n    $C_{BO} = \\begin{bmatrix}\n  3 & 0 & 1 & 1\\\\\n  0 & 3 & 1 & 1\\\\\n  1 & 1 & 20 & 3\\\\\n  1 & 1 & 3 & 20\n  \\end{bmatrix}$,\n    $\\epsilon = 0.5$, $B = 2000$, $\\alpha = 0.05$, $s = 19$.\n\n最终输出格式：你的程序应该生成单行输出，包含四个布尔结果，以方括号括起来的逗号分隔列表形式，按上述用例的顺序排列，例如 $[\\mathrm{False},\\mathrm{True},\\mathrm{False},\\mathrm{False}]$。", "solution": "该问题已经过验证，被认为是科学上合理、表述清晰且客观的。它提出了一种计算生物学中的标准统计程序，用于使用对数行列式距离检验分子钟假说。所有必要的数据、参数和定义都已提供，构成了一个完整且无矛盾的规范。因此，我们着手进行求解。\n\n基本任务是为零假设 $H_0: d_{\\mathrm{PL}}(A,O) = d_{\\mathrm{PL}}(B,O)$ 实现一个假说检验，其中 $d_{\\mathrm{PL}}$ 是平行线性距离，这是一种对核苷酸序列中的成分偏倚具有稳健性的演化差异度量。该检验比较分类单元 $A$ 到外类群 $O$ 的演化距离与分类单元 $B$ 到同一外类群 $O$ 的距离。这些距离之间的显著差异是反对导致 $A$ 和 $B$ 的谱系具有恒定演化速率（严格分子钟）的证据。\n\n过程如下：\n\n首先，对于给定的一对分类单元（我们通常表示为 $(X,O)$），其观测到的联合计数矩阵为 $4 \\times 4$ 维的 $C_{XO}$，我们计算平行线性距离。将一个小的正伪计数 $\\epsilon$ 添加到 $C_{XO}$ 的每个单元格中。这种做法称为加性平滑，它通过防止出现零概率（这会导致未定义的对数）来确保所有后续的概率量都有明确定义。然后将所得矩阵归一化，形成经验联合概率矩阵 $\\hat{P}_{XO}$：\n$$\n\\hat{P}_{XO} \\;=\\; \\frac{C_{XO} + \\epsilon \\mathbf{1}_{4 \\times 4}}{N_{XO}},\n$$\n其中 $\\mathbf{1}_{4 \\times 4}$ 是 $4 \\times 4$ 的全一矩阵，而 $N_{XO} = \\sum_{i=1}^{4}\\sum_{j=1}^{4}\\left(C_{XO}[i,j] + \\epsilon\\right)$ 是归一化常数。从 $\\hat{P}_{XO}$ 我们导出分类单元 $X$ 和外类群 $O$ 的边际核苷酸频率向量：\n$$\n\\hat{p}_X(i) \\;=\\; \\sum_{j=1}^{4} \\hat{P}_{XO}[i,j] \\quad \\text{和} \\quad \\hat{p}_O(j) \\;=\\; \\sum_{i=1}^{4} \\hat{P}_{XO}[i,j].\n$$\n然后使用以下公式计算平行线性距离（也称为对数行列式距离）：\n$$\nd_{\\mathrm{PL}}(X,O) \\;=\\; -\\ln \\det(\\hat{P}_{XO}) \\;+\\; \\frac{1}{2}\\sum_{i=1}^{4}\\ln(\\hat{p}_X(i)) \\;+\\; \\frac{1}{2}\\sum_{j=1}^{4}\\ln(\\hat{p}_O(j)).\n$$\n这种使用对数求和的公式，比问题陈述中指定的计算小数乘积的对数在数值上更稳定，但数学上是等价的。\n\n分子钟假说的检验统计量是到外类群的两个距离之差：\n$$\n\\Delta \\;=\\; d_{\\mathrm{PL}}(A,O) - d_{\\mathrm{PL}}(B,O).\n$$\n$\\Delta$ 的值接近于零与分子钟假说一致，意味着 $A$ 和 $B$ 的谱系自其分化以来以相似的速率累积了替换。\n\n为了评估观测值 $\\Delta$ 的统计显著性，我们必须估计其抽样方差。问题指定了一种非参数自助法。这种统计技术涉及从观测数据中重抽样以模拟新的数据集。对于每对 $(X,O)$，我们首先确定对齐位点的总数 $n_{XO} = \\sum_{i,j} C_{XO}[i,j]$，以及 16 种可能的位点模式（核苷酸对）的经验分布 $\\tilde{P}_{XO} = C_{XO} / n_{XO}$。对于 $B$ 次自助法重复中的每一次，我们通过从参数为 $(n_{XO}, \\mathrm{vec}(\\tilde{P}_{XO}))$ 的多项分布中抽取 $n_{XO}$ 个样本来生成一个新的计数矩阵 $\\widetilde{C}_{XO}^{(b)}$。这个过程模拟了从原始序列比对中有放回地重抽样列（位点）。这对 $(A,O)$ 和 $(B,O)$ 配对是独立完成的。\n\n对于从 1 到 $B$ 的每次自助法重复 $b$，我们将上述整个距离计算过程应用于自助法计数矩阵 $\\widetilde{C}_{AO}^{(b)}$ 和 $\\widetilde{C}_{BO}^{(b)}$，以计算检验统计量的自助法版本 $\\Delta^{(b)}$。在这些计算中使用了相同的伪计数 $\\epsilon$。\n\n$B$ 个自助法统计量集合 $\\{\\Delta^{(b)}\\}_{b=1}^{B}$ 构成了 $\\Delta$ 的一个经验抽样分布。从这个分布中，我们计算样本标准差，它作为我们对 $\\Delta$ 标准误的估计：\n$$\n\\hat{\\sigma} \\;=\\; \\sqrt{\\frac{1}{B-1}\\sum_{b=1}^{B} \\left(\\Delta^{(b)} - \\overline{\\Delta}\\right)^2},\n$$\n其中 $\\overline{\\Delta}$ 是自助法统计量的算术平均值。\n\n最后，假设对于大样本量，$\\Delta$ 近似服从正态分布（中心极限定理的结果），我们构建一个标准化的检验统计量 $Z = \\Delta / \\hat{\\sigma}$。这个 $Z$ 分数衡量了观测到的 $\\Delta$ 与零相差多少个标准误。如果观测到的 $Z$ 分数的绝对值达到或超过临界值 $z_{1-\\alpha/2}$，则在显著性水平 $\\alpha$ 上拒绝零假设 $H_0$，其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$-分位数。也就是说，如果 $|Z| \\ge z_{1-\\alpha/2}$，我们拒绝 $H_0$。\n\n该算法用 Python 实现，利用 `numpy` 库进行数值线性代数和统计计算，并使用 `scipy.stats` 模块获取标准正态分布所需的分位数。对于每个测试用例，随机数生成器都用指定的种子 $s$ 进行初始化，以确保自助法程序的完全可复现性。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef calculate_dpl(C, epsilon):\n    \"\"\"\n    Calculates the paralinear (log-determinant) distance for a given count matrix.\n    \n    Args:\n        C (np.ndarray): A 4x4 matrix of site-pattern counts.\n        epsilon (float): A positive pseudocount.\n        \n    Returns:\n        float: The paralinear distance d_PL(X,O).\n    \"\"\"\n    C = np.asarray(C, dtype=np.float64)\n    \n    # Add pseudocount and normalize to get the empirical joint probability matrix\n    total_sum = C.sum() + epsilon * C.size\n    P_hat = (C + epsilon) / total_sum\n    \n    # Use slogdet for numerical stability. The determinant of P_hat should be positive.\n    sign, log_det_P = np.linalg.slogdet(P_hat)\n    if sign <= 0:\n        # This is not expected with a positive pseudocount on diagonally-dominant-like matrices.\n        # It would indicate a serious numerical issue or an invalid matrix.\n        # Returning infinity would lead to rejection if this path is taken.\n        return np.inf\n\n    # Calculate marginal frequency vectors\n    p_X = P_hat.sum(axis=1)\n    p_O = P_hat.sum(axis=0)\n    \n    # Calculate sum of logs of marginals\n    log_prod_pX = np.log(p_X).sum()\n    log_prod_pO = np.log(p_O).sum()\n    \n    # Calculate paralinear distance as per the formula\n    d_pl = -log_det_P + 0.5 * log_prod_pX + 0.5 * log_prod_pO\n    \n    return d_pl\n\ndef perform_clock_test(C_AO, C_BO, epsilon, B, alpha, s):\n    \"\"\"\n    Performs the molecular clock test for a triplet of taxa (A, B, O).\n\n    Args:\n        C_AO (np.ndarray): Count matrix for pair (A, O).\n        C_BO (np.ndarray): Count matrix for pair (B, O).\n        epsilon (float): Pseudocount.\n        B (int): Number of bootstrap replicates.\n        alpha (float): Significance level.\n        s (int): Random seed.\n        \n    Returns:\n        bool: True if the null hypothesis is rejected, False otherwise.\n    \"\"\"\n    # Initialize a random number generator with the specified seed for reproducibility\n    rng = np.random.default_rng(s)\n\n    C_AO = np.asarray(C_AO, dtype=np.float64)\n    C_BO = np.asarray(C_BO, dtype=np.float64)\n\n    # Calculate the observed test statistic Delta\n    d_pl_AO_obs = calculate_dpl(C_AO, epsilon)\n    d_pl_BO_obs = calculate_dpl(C_BO, epsilon)\n    delta_obs = d_pl_AO_obs - d_pl_BO_obs\n\n    # Prepare for nonparametric bootstrap\n    n_AO = int(C_AO.sum())\n    p_tilde_AO = C_AO.flatten() / n_AO if n_AO > 0 else np.full(16, 1/16)\n    \n    n_BO = int(C_BO.sum())\n    p_tilde_BO = C_BO.flatten() / n_BO if n_BO > 0 else np.full(16, 1/16)\n\n    # Perform bootstrap resampling\n    delta_bootstraps = np.zeros(B)\n    for b in range(B):\n        # Generate bootstrap replicate counts for AO and BO\n        C_boot_AO_flat = rng.multinomial(n_AO, p_tilde_AO)\n        C_boot_AO = C_boot_AO_flat.reshape((4, 4))\n        \n        C_boot_BO_flat = rng.multinomial(n_BO, p_tilde_BO)\n        C_boot_BO = C_boot_BO_flat.reshape((4, 4))\n        \n        # Compute d_PL for the bootstrap replicate\n        d_pl_AO_boot = calculate_dpl(C_boot_AO, epsilon)\n        d_pl_BO_boot = calculate_dpl(C_boot_BO, epsilon)\n        \n        delta_bootstraps[b] = d_pl_AO_boot - d_pl_BO_boot\n\n    # Calculate the bootstrap standard deviation of Delta\n    sigma_hat = np.std(delta_bootstraps, ddof=1)\n    \n    # Handle the case where standard deviation is effectively zero\n    if sigma_hat < 1e-12:\n        return np.abs(delta_obs) > 1e-12\n\n    # Calculate the standardized Z-statistic\n    Z = delta_obs / sigma_hat\n    \n    # Find the critical value from the standard normal distribution\n    z_crit = norm.ppf(1.0 - alpha / 2.0)\n    \n    # Reject H0 if |Z| is greater than or equal to the critical value\n    rejection = np.abs(Z) >= z_crit\n    \n    return bool(rejection)\n\ndef solve():\n    \"\"\"\n    Defines the test cases and runs the clock test for each, printing the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"C_AO\": np.array([\n                [220, 10, 10, 10], [10, 220, 10, 10], \n                [10, 10, 220, 10], [10, 10, 10, 220]\n            ]),\n            \"C_BO\": np.array([\n                [220, 10, 10, 10], [10, 220, 10, 10], \n                [10, 10, 220, 10], [10, 10, 10, 220]\n            ]),\n            \"epsilon\": 0.5, \"B\": 2000, \"alpha\": 0.05, \"s\": 7\n        },\n        {\n            \"C_AO\": np.array([\n                [150, 20, 20, 20], [20, 150, 20, 20], \n                [20, 20, 150, 20], [20, 20, 20, 150]\n            ]),\n            \"C_BO\": np.array([\n                [240, 5, 5, 5], [5, 240, 5, 5], \n                [5, 5, 240, 5], [5, 5, 5, 240]\n            ]),\n            \"epsilon\": 0.5, \"B\": 2000, \"alpha\": 0.05, \"s\": 13\n        },\n        {\n            \"C_AO\": np.array([\n                [250, 0, 0, 0], [0, 250, 0, 0], \n                [0, 0, 250, 0], [0, 0, 0, 250]\n            ]),\n            \"C_BO\": np.array([\n                [250, 0, 0, 0], [0, 250, 0, 0], \n                [0, 0, 250, 0], [0, 0, 0, 250]\n            ]),\n            \"epsilon\": 0.5, \"B\": 2000, \"alpha\": 0.05, \"s\": 17\n        },\n        {\n            \"C_AO\": np.array([\n                [35, 3, 1, 1], [1, 7, 1, 1], \n                [1, 1, 4, 0], [1, 0, 0, 3]\n            ]),\n            \"C_BO\": np.array([\n                [3, 0, 1, 1], [0, 3, 1, 1], \n                [1, 1, 20, 3], [1, 1, 3, 20]\n            ]),\n            \"epsilon\": 0.5, \"B\": 2000, \"alpha\": 0.05, \"s\": 19\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = perform_clock_test(\n            case[\"C_AO\"], case[\"C_BO\"], case[\"epsilon\"], \n            case[\"B\"], case[\"alpha\"], case[\"s\"]\n        )\n        results.append(str(result))\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2435873"}, {"introduction": "当严格分子钟假设被统计检验拒绝时，我们并不会就此止步，而是转向更灵活的“宽松分子钟”(relaxed clock)模型，这些模型允许进化速率在系统发育树的不同谱系间发生变化。本综合练习将带你深入探索一种常见的宽松钟模型，其中进化速率在相邻分支上是自相关的，遵循几何布朗运动。你将亲手模拟在给定树上速率演化的过程，并基于模拟数据推导出模型参数的最大似然估计，从而从第一性原理出发，深刻理解现代分子钟分析软件背后的高级建模思想。[@problem_id:2435895]", "problem": "您的任务是实现一个完整、可运行的程序。该程序在一个宽松分子钟和自相关速率模型下，于一棵固定的有根树上模拟替换速率的演化，然后直接从第一性原理出发，恢复生成这些数据的参数。该模型是沿着每个分支的速率对数所遵循的、带有线性漂移的几何布朗运动。具体而言，设节点 $v$ 处的瞬时替换速率为 $r_{v}$。定义对数速率为 $x_{v} = \\log r_{v}$。对于任意一个从父节点 $p$ 到子节点 $c$、时长为 $t$ 的分支，其条件演化由下式给出\n$$\nx_{c} \\mid x_{p} \\sim \\mathcal{N}\\left(x_{p} + \\delta \\, t,\\ \\sigma^{2} \\, t\\right),\n$$\n其中 $\\delta$ 是漂移参数（单位：对数速率/单位时间），$\\sigma^{2}$ 是扩散方差（单位：对数速率的平方/单位时间）。该过程从根节点开始，其初始值为 $x_{\\text{root}} = \\mu_{0}$，其中 $\\mu_{0}$ 是一个给定的常数，并非待估计的参数。在给定父节点状态的条件下，不同分支间的抽样是条件独立的。\n\n请使用以下包含节点索引和分支时长的固定有根树。根节点为节点 $0$。每个元组的格式为 $(\\text{父节点}, \\text{子节点}, \\text{时间})$：\n- $(0, 1, 1.0)$\n- $(1, 3, 0.7)$\n- $(1, 4, 0.4)$\n- $(0, 2, 0.5)$\n- $(2, 5, 0.6)$\n- $(5, 6, 0.9)$\n- $(5, 7, 0.3)$\n\n所有时间都以任意但一致的单位计量；不需要进行单位转换。共有 $8$ 个节点和 $7$ 个分支。\n\n您的程序必须：\n- 对于每个测试用例，使用指定的参数 $(\\delta, \\sigma^{2}, \\mu_{0})$ 在树的所有节点上模拟一次对数速率 $x_{v}$ 的实现。模拟过程必须是可复现的：对第一个测试用例，使用种子 $42$ 初始化伪随机数生成器；对于索引为 $i$（从 $0$ 开始）的测试用例，使用种子 $42 + i$。\n- 从模拟数据中，通过将观测数据视为树中所有分支 $e$ 的父子节点对数速率差 $\\Delta_{e} = x_{c} - x_{p}$ 及其相应分支时长 $t_{e}$ 的集合，来恢复漂移参数 $\\delta$ 和方差参数 $\\sigma^{2}$。恢复的值必须是在上述模型下能最佳解释模拟差异的参数，并以实数形式表示。\n\n测试套件：\n- 用例 1：$(\\delta, \\sigma^{2}, \\mu_{0}) = (0.0,\\ 0.2,\\ 0.0)$\n- 用例 2：$(\\delta, \\sigma^{2}, \\mu_{0}) = (-0.3,\\ 0.5,\\ -0.357)$\n- 用例 3：$(\\delta, \\sigma^{2}, \\mu_{0}) = (0.2,\\ 0.01,\\ 0.0)$\n\n输出规范：\n- 对于每个测试用例，以列表 $[\\widehat{\\delta}, \\widehat{\\sigma^{2}}]$ 的形式输出恢复的漂移和方差，每个值四舍五入到 $6$ 位小数。\n- 将所有测试用例的结果聚合到打印至标准输出的单行中，其格式为用方括号括起来的逗号分隔列表，其中每个元素本身就是一个双元素列表，例如：$[[a_{1},b_{1}],[a_{2},b_{2}],[a_{3},b_{3}]]$。\n- 最终输出必须是严格符合此格式的单行，除了有效的逗号分隔和括号所必需的字符外，不应包含任何多余的字符或空白。\n\n不提供外部输入；所有参数、树结构和测试套件都在程序中固定。最终答案必须是按规定格式化的实值浮点数，输出中无需包含单位。", "solution": "用户提供的问题是有效的。它在计算生物学领域有科学依据，具体涉及分子演化模型。该问题是良定的，提供了生成模型的完整描述、固定的数据集结构（一棵系统发育树），以及明确的任务：从模型中模拟数据，然后使用从第一性原理推导出的统计估计程序来恢复模型参数。问题陈述客观、精确，且不含任何矛盾或含糊之处。\n\n该问题分两个阶段解决：首先，在给定的系统发育树上模拟替换速率的演化；其次，从模拟数据中估计模型参数。\n\n**1. 速率演化的模拟**\n\n该模型描述了在一棵有根树的各个分支上，替换速率的对数 $x_v = \\log r_v$ 的演化过程。该演化遵循带漂移的几何布朗运动。对于连接父节点 $p$ 和子节点 $c$、时长为 $t$ 的任意分支，子节点的对数速率 $x_c$ 条件依赖于父节点的对数速率 $x_p$，其关系如下：\n$$\nx_{c} \\mid x_{p} \\sim \\mathcal{N}\\left(x_{p} + \\delta t,\\ \\sigma^{2} t\\right)\n$$\n此处，$\\delta$ 表示单位时间内的对数速率漂移，$\\sigma^2$ 是单位时间内的扩散过程方差。这意味着 $x_c$ 的值可以通过从指定的正态分布中抽样生成。一个随机变量 $Y \\sim \\mathcal{N}(\\mu, \\sigma_{\\text{var}}^2)$可以表示为 $Y = \\mu + \\sqrt{\\sigma_{\\text{var}}^2} \\cdot Z$，其中 $Z \\sim \\mathcal{N}(0, 1)$ 是一个标准正态变量。将此应用于我们的模型，我们得到生成方程：\n$$\nx_c = (x_p + \\delta t) + \\sqrt{\\sigma^2 t} \\cdot Z = x_p + \\delta t + \\sigma \\sqrt{t} \\cdot Z\n$$\n模拟过程通过遍历树来进行，从根节点（节点 $0$）开始。根节点的初始对数速率给定为 $x_{\\text{root}} = x_0 = \\mu_0$。所有其他节点 $v$ 的 $x_v$ 值被依次计算。由于树的结构是固定的，并以从父到子的有向边列表形式提供，我们可以在知道父节点对数速率后，计算每个子节点的对数速率。该过程需要一个伪随机数生成器来为 $Z$ 抽样。为保证可复现性，对于第 $i$ 个测试用例（$i$ 从 0 开始索引），生成器的种子被设为 $42+i$。\n\n指定的树有 $8$ 个节点（编号 $0$ 到 $7$）和 $7$ 个分支：\n- $(0, 1, 1.0)$、$(1, 3, 0.7)$、$(1, 4, 0.4)$、$(0, 2, 0.5)$、$(2, 5, 0.6)$、$(5, 6, 0.9)$、$(5, 7, 0.3)$\n模拟算法如下：\n1. 对于给定的测试用例 $(\\delta, \\sigma^2, \\mu_0)$ 和种子，初始化一个大小为 $8$ 的对数速率数组 `x_values`。\n2. 设置根节点的对数速率：`x_values[0]` $= \\mu_0$。\n3. 遍历分支列表 $(p, c, t)$。对于每个分支：\n   a. 获取父节点的对数速率，$x_p =$ `x_values[p]`。\n   b. 从 $\\mathcal{N}(0, 1)$ 中抽取一个样本 $Z$。\n   c. 计算子节点的对数速率：$x_c = x_p + \\delta t + \\sigma \\sqrt{t} \\cdot Z$。\n   d. 存储该值：`x_values[c]` $= x_c$。\n处理完所有 $7$ 个分支后，`x_values` 数组就包含了一次该过程在树上的完整实现。\n\n**2. 从模拟数据中进行参数估计**\n\n问题的第二部分是从模拟的对数速率 $\\{x_v\\}$ 中恢复参数 $\\delta$ 和 $\\sigma^2$。问题规定，估计应基于父子节点对数速率差 $\\Delta_e = x_c - x_p$ 及其相应分支时长 $t_e$ 的集合。\n\n从生成模型可知，这个差值的分布为：\n$$\n\\Delta_e = x_c - x_p \\sim \\mathcal{N}(\\delta t_e, \\sigma^2 t_e)\n$$\n我们的任务是找到能最好地解释观测数据的参数。这通过最大似然估计（MLE）来实现。在给定父节点值的条件下，每个分支的抽样是条件独立的。因此，观测到所有 $N=7$ 个分支上的差值集合 $\\{\\Delta_e\\}$ 的总似然是各个概率密度的乘积：\n$$\nL(\\delta, \\sigma^2 \\mid \\{\\Delta_e, t_e\\}) = \\prod_{e=1}^{N} \\frac{1}{\\sqrt{2\\pi \\sigma^2 t_e}} \\exp\\left(-\\frac{(\\Delta_e - \\delta t_e)^2}{2\\sigma^2 t_e}\\right)\n$$\n最大化对数似然 $\\ell = \\log L$ 更为方便：\n$$\n\\ell(\\delta, \\sigma^2) = \\sum_{e=1}^{N} \\left[ -\\frac{1}{2}\\log(2\\pi) - \\frac{1}{2}\\log(\\sigma^2) - \\frac{1}{2}\\log(t_e) - \\frac{(\\Delta_e - \\delta t_e)^2}{2\\sigma^2 t_e} \\right]\n$$\n$$\n\\ell(\\delta, \\sigma^2) = C - \\frac{N}{2}\\log(\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\delta t_e)^2}{t_e}\n$$\n其中 $C$ 包含不依赖于 $\\delta$ 或 $\\sigma^2$ 的项。\n\n为求得 $\\delta$ 的最大似然估计（MLE）$\\widehat{\\delta}$，我们将 $\\ell$ 对 $\\delta$ 求偏导数并令其为零：\n$$\n\\frac{\\partial \\ell}{\\partial \\delta} = - \\frac{1}{2\\sigma^2} \\sum_{e=1}^{N} \\frac{2(\\Delta_e - \\delta t_e)(-t_e)}{t_e} = \\frac{1}{\\sigma^2} \\sum_{e=1}^{N} (\\Delta_e - \\delta t_e) = 0\n$$\n$$\n\\sum_{e=1}^{N} \\Delta_e - \\widehat{\\delta} \\sum_{e=1}^{N} t_e = 0 \\implies \\widehat{\\delta} = \\frac{\\sum_{e=1}^{N} \\Delta_e}{\\sum_{e=1}^{N} t_e}\n$$\n$\\delta$ 的估计量是所有分支的总对数速率变化量除以所有分支的总时长。\n\n为求得 $\\sigma^2$ 的最大似然估计 $\\widehat{\\sigma^2}$，我们将 $\\ell$ 对 $\\sigma^2$ 求偏导数并令其为零，同时用 $\\widehat{\\delta}$ 替代 $\\delta$：\n$$\n\\frac{\\partial \\ell}{\\partial \\sigma^2} = -\\frac{N}{2\\sigma^2} + \\frac{1}{2(\\sigma^2)^2} \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\widehat{\\delta} t_e)^2}{t_e} = 0\n$$\n$$\n-N\\sigma^2 + \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\widehat{\\delta} t_e)^2}{t_e} = 0 \\implies \\widehat{\\sigma^2} = \\frac{1}{N} \\sum_{e=1}^{N} \\frac{(\\Delta_e - \\widehat{\\delta} t_e)^2}{t_e}\n$$\n这是加权残差平方的样本均值，其中分支 $e$ 的残差为 $(\\Delta_e - \\widehat{\\delta} t_e)$，权重为 $1/t_e$。\n\n实现过程将首先为每个测试用例执行模拟以生成 `x_values`，然后应用这些推导出的公式，从模拟数据中计算出 $\\widehat{\\delta}$ 和 $\\widehat{\\sigma^2}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates rate evolution on a fixed tree and recovers the model parameters.\n    \"\"\"\n    \n    # Define the fixed tree structure as a list of (parent, child, time) tuples.\n    # The tree has 8 nodes (0-7) and 7 branches. Node 0 is the root.\n    branches = [\n        (0, 1, 1.0),\n        (1, 3, 0.7),\n        (1, 4, 0.4),\n        (0, 2, 0.5),\n        (2, 5, 0.6),\n        (5, 6, 0.9),\n        (5, 7, 0.3),\n    ]\n    num_nodes = 8\n    num_branches = len(branches)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta, sigma_squared, mu_0)\n    test_cases = [\n        (0.0, 0.2, 0.0),\n        (-0.3, 0.5, -0.357),\n        (0.2, 0.01, 0.0),\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        delta, sigma_sq, mu_0 = case\n        \n        # --- 1. Simulation Phase ---\n        \n        # Initialize the pseudo-random number generator with the specified seed for reproducibility.\n        seed = 42 + i\n        rng = np.random.default_rng(seed)\n        \n        # Array to store the simulated log-rates at each node.\n        x_values = np.zeros(num_nodes)\n        \n        # Set the log-rate at the root.\n        x_values[0] = mu_0\n        \n        # The standard deviation parameter is the square root of the variance.\n        sigma = np.sqrt(sigma_sq)\n        \n        # Traverse the tree and simulate the log-rate for each child node.\n        for p, c, t in branches:\n            # Parent's log-rate\n            x_p = x_values[p]\n            \n            # Draw from a standard normal distribution N(0, 1).\n            Z = rng.normal(0, 1)\n            \n            # Calculate the child's log-rate using the model's generative equation.\n            # x_c = x_p + delta*t + sigma*sqrt(t)*Z\n            x_c = x_p + delta * t + sigma * np.sqrt(t) * Z\n            \n            # Store the child's log-rate.\n            x_values[c] = x_c\n\n        # --- 2. Parameter Recovery Phase ---\n        \n        # Calculate the log-rate differences (Delta_e) and branch durations (t_e).\n        delta_e_list = []\n        t_e_list = []\n        for p, c, t in branches:\n            delta_e_list.append(x_values[c] - x_values[p])\n            t_e_list.append(t)\n            \n        # Calculate the MLE for delta (drift).\n        # delta_hat = (sum of Delta_e) / (sum of t_e)\n        sum_delta_e = np.sum(delta_e_list)\n        sum_t_e = np.sum(t_e_list)\n        delta_hat = sum_delta_e / sum_t_e\n        \n        # Calculate the MLE for sigma^2 (variance).\n        # sigma_sq_hat = (1/N) * sum[ (Delta_e - delta_hat * t_e)^2 / t_e ]\n        ssr = 0.0\n        for delta_e, t_e in zip(delta_e_list, t_e_list):\n            residual = delta_e - delta_hat * t_e\n            ssr += (residual ** 2) / t_e\n        \n        sigma_sq_hat = ssr / num_branches\n        \n        # Store the recovered parameters for this test case.\n        results.append([delta_hat, sigma_sq_hat])\n\n    # --- 3. Final Output Formatting ---\n    \n    # Build the final output string in the exact required format.\n    # Example: [[a1,b1],[a2,b2],[a3,b3]]\n    output_parts = []\n    for res in results:\n        # Format each number to 6 decimal places.\n        d_hat_str = f\"{res[0]:.6f}\"\n        s_sq_hat_str = f\"{res[1]:.6f}\"\n        inner_part = f\"[{d_hat_str},{s_sq_hat_str}]\"\n        output_parts.append(inner_part)\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2435895"}]}