{"hands_on_practices": [{"introduction": "理解一个算法的最好方法就是亲手执行一遍。这个练习提供了一个具体的数据集，让你实践非加权配对平均法 (UPGMA) 的每一步。这个实践将帮助你掌握通过迭代聚类和距离计算来构建一个有根超度量树的核心技能，包括如何处理计算过程中可能出现的平局情况。[@problem_id:2385869]", "problem": "考虑四个分类单元 $A$、$B$、$C$ 和 $D$，其成对差异性 $d(i,j)$ 由以下对称矩阵给出（行和列的顺序为 $A,B,C,D$）：\n$$\nD \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 1 & \\frac{8}{5} \\\\\n1 & 0 & \\frac{26}{5} & \\frac{17}{5} \\\\\n1 & \\frac{26}{5} & 0 & \\frac{22}{5} \\\\\n\\frac{8}{5} & \\frac{17}{5} & \\frac{22}{5} & 0\n\\end{pmatrix}.\n$$\n使用非加权对群算术平均法 (Unweighted Pair Group Method with Arithmetic Mean, UPGMA) 构建一棵有根超度量系统发育树。在任何步骤中，当两个或多个簇间距离相等且为最小值时，通过选择其分类单元标签按字母顺序构成字典序最小的有序对来打破平局（例如，选择 $(A,B)$ 而不是 $(A,C)$）。使用此规则，计算最终生成的树中分类单元 $B$ 和 $C$ 之间的超度量距离。请以精确数值的形式给出答案，不带单位。", "solution": "该问题要求使用非加权对群算术平均法 (UPGMA) 算法，根据给定的成对差异性矩阵 $D$，为四个分类单元 $A$、$B$、$C$ 和 $D$ 构建一棵有根超度量系统发育树。最终目标是计算所得树中分类单元 $B$ 和 $C$ 之间的超度量距离。\n\nUPGMA 算法是一种层次凝聚聚类方法。其步骤如下：\n1. 初始化，将 $n$ 个分类单元中的每一个都视为一个独立的簇。\n2. 迭代地找到具有最小差异性 $d(u,v)$ 的一对簇，记为 $u$ 和 $v$。\n3. 将 $u$ 和 $v$ 合并成一个新的簇 $(uv)$。在树中创建一个新节点来表示这次合并，并将其置于高度 $h_{(uv)} = \\frac{d(u,v)}{2}$ 处。连接此新节点与 $u$、$v$ 节点的分支的长度经过设定，以确保从根到任意叶节点的总路径长度保持恒定。\n4. 新的复合簇 $(uv)$ 到任何其他簇 $k$ 的距离按以下加权平均计算：\n$$ d((uv), k) = \\frac{|u|d(u,k) + |v|d(v,k)}{|u| + |v|} $$\n其中 $|u|$ 和 $|v|$ 分别是簇 $u$ 和 $v$ 中分类单元的数量（基数）。\n5. 重复此过程，直到只剩下一个簇，该簇代表树的根。\n\n在最终生成的树中，两个分类单元 $i$ 和 $j$ 之间的超度量距离 $d_{tree}(i,j)$ 定义为其最近共同祖先 (MRCA) 高度（记为 $h_{MRCA(i,j)}$）的两倍：\n$$ d_{tree}(i,j) = 2 \\times h_{MRCA(i,j)} $$\n\n我们现在将此过程应用于所提供的数据。\n\n**初始步骤：**\n初始簇为 $\\{A\\}$, $\\{B\\}$, $\\{C\\}$, 和 $\\{D\\}$，每个簇的基数都为 $1$。给定的对称差异性矩阵为：\n$$\nD_0 \\;=\\;\n\\begin{pmatrix}\n0 & 1 & 1 & \\frac{8}{5} \\\\\n1 & 0 & \\frac{26}{5} & \\frac{17}{5} \\\\\n1 & \\frac{26}{5} & 0 & \\frac{22}{5} \\\\\n\\frac{8}{5} & \\frac{17}{5} & \\frac{22}{5} & 0\n\\end{pmatrix}\n$$\n行和列对应于分类单元，顺序为 $A, B, C, D$。\n\n**迭代 1：**\n我们找出 $D_0$ 中的最小非零距离。其值为 $1$，它出现在两对中：$d(A,B) = 1$ 和 $d(A,C) = 1$。问题提供了打破平局的规则：选择其分类单元标签构成字典序最小的有序对。比较 $(A,B)$ 和 $(A,C)$，我们确定 $(A,B)$ 的字典序更小。因此，我们将簇 $\\{A\\}$ 和 $\\{B\\}$ 合并成一个新簇 $(AB)$。\n\n新簇的基数为 $|(AB)| = |A| + |B| = 1 + 1 = 2$。\n代表这次合并的节点的高度是 $h_{(AB)} = \\frac{d(A,B)}{2} = \\frac{1}{2}$。\n\n接下来，我们更新距离矩阵。计算从新簇 $(AB)$ 到剩余簇 $\\{C\\}$ 和 $\\{D\\}$ 的距离：\n$$ d((AB), C) = \\frac{|A|d(A,C) + |B|d(B,C)}{|A|+|B|} = \\frac{1 \\cdot 1 + 1 \\cdot \\frac{26}{5}}{1+1} = \\frac{1 + \\frac{26}{5}}{2} = \\frac{\\frac{31}{5}}{2} = \\frac{31}{10} $$\n$$ d((AB), D) = \\frac{|A|d(A,D) + |B|d(B,D)}{|A|+|B|} = \\frac{1 \\cdot \\frac{8}{5} + 1 \\cdot \\frac{17}{5}}{1+1} = \\frac{\\frac{25}{5}}{2} = \\frac{5}{2} $$\n新的簇集是 $\\{(AB), C, D\\}$。更新后的距离矩阵 $D_1$ 是：\n$$ D_1 =\n\\begin{pmatrix}\n & (AB) & C & D \\\\\n(AB) & 0 & \\frac{31}{10} & \\frac{5}{2} \\\\\nC & \\frac{31}{10} & 0 & \\frac{22}{5} \\\\\nD & \\frac{5}{2} & \\frac{22}{5} & 0\n\\end{pmatrix}\n$$\n\n**迭代 2：**\n我们找出 $D_1$ 中的最小非零距离。这些距离是 $\\frac{31}{10} = 3.1$、$\\frac{5}{2} = 2.5$ 和 $\\frac{22}{5} = 4.4$。最小值是 $d((AB), D) = \\frac{5}{2}$。我们将簇 $(AB)$ 和 $\\{D\\}$ 合并成一个新簇 $((AB)D)$。\n\n基数为 $|((AB)D)| = |(AB)| + |D| = 2 + 1 = 3$。\n这个新节点的高度是 $h_{((AB)D)} = \\frac{d((AB),D)}{2} = \\frac{5/2}{2} = \\frac{5}{4}$。\n\n我们计算从 $((AB)D)$ 到唯一剩下的簇 $\\{C\\}$ 的距离：\n$$ d(((AB)D), C) = \\frac{|(AB)|d((AB),C) + |D|d(D,C)}{|(AB)|+|D|} = \\frac{2 \\cdot \\frac{31}{10} + 1 \\cdot \\frac{22}{5}}{2+1} = \\frac{\\frac{31}{5} + \\frac{22}{5}}{3} = \\frac{\\frac{53}{5}}{3} = \\frac{53}{15} $$\n\n**迭代 3：**\n最后剩下的两个簇是 $\\{((AB)D)\\}$ 和 $\\{C\\}$。我们将它们合并，形成树的根。\n根节点的高度是 $h_{root} = \\frac{d(((AB)D),C)}{2} = \\frac{53/15}{2} = \\frac{53}{30}$。\n\n树的最终拓扑结构是 $(((A,B),D),C)$。我们需要找到分类单元 $B$ 和 $C$ 之间的超度量距离。这需要确定它们的最近共同祖先。\n- 从叶节点 $B$ 开始的谱系上升到节点 $(AB)$，然后到节点 $((AB)D)$，最后到根节点。\n- 从叶节点 $C$ 开始的谱系直接上升到根节点。\n因此，$B$ 和 $C$ 的最近共同祖先是树的根。\n\n这个最近共同祖先的高度就是根节点的高度，$h_{root} = \\frac{53}{30}$。\n在最终生成的树中，$B$ 和 $C$ 之间的超度量距离计算如下：\n$$ d_{tree}(B, C) = 2 \\times h_{MRCA(B,C)} = 2 \\times h_{root} = 2 \\times \\frac{53}{30} = \\frac{53}{15} $$\n这就是所要求的精确数值。", "answer": "$$\\boxed{\\frac{53}{15}}$$", "id": "2385869"}, {"introduction": "掌握了单个算法的机制后，理解不同方法在相同条件下的行为差异至关重要。这个思想实验探讨了数据中的冗余信息（即重复的分类单元）对 UPGMA 和邻接法 (NJ) 两种算法的影响。通过这个练习，你将发现它们底层准则的关键差异，并理解算法设计的选择如何影响最终的树拓扑结构。[@problem_id:2385846]", "problem": "在基于距离的系统发育重建中，假设您有一个关于一组分类单元的对称相异性矩阵，其中两个分类单元（称它们为 $x$ 和 $x'$）是完全重复的，即 $d_{xx'}=0$ 并且对于每个其他分类单元 $k$，都有 $d_{xk}=d_{x'k}$。考虑在该矩阵上运行非加权对群算术平均法 (UPGMA) 和邻接法 (NJ) 算法。\n\n哪个陈述最能描述包含重复分类单元 $x'$ 对所生成树的影响？\n\nA. 在UPGMA下，$x$ 和 $x'$ 将立即形成一个枝长为 $0$ 的簇，并且在将该长度为 $0$ 的“樱桃”结构收缩为单个末端后，非重复分类单元间的其余有根拓扑结构和节点高度与移除 $x'$ 的情况相同；在NJ下，添加 $x'$ 可以通过 $Q$ 准则改变聚合顺序，因此可以改变非重复分类单元间的无根拓扑结构，尽管 $x$ 和 $x'$ 最终将通过长度为 $0$ 的枝连接到它们的共同父节点上。\n\nB. 在UPGMA和NJ下，$x$ 和 $x'$ 都将作为一个长度为 $0$ 的“樱桃”结构连接，并且它们的存在不会改变拓扑的任何其他部分；非重复分类单元上的树对于添加 $x'$ 是不变的。\n\nC. 在UPGMA下，添加 $x'$ 通常会改变簇间平均值，因此可以改变非重复分类单元间的拓扑结构；在NJ下，$Q$ 准则仅使用成对距离，因此对于添加 $x'$ 是不变的。\n\nD. 在NJ中，$x$ 和 $x'$ 必须是第一对被连接的，因为 $d_{xx'}=0$ 保证了最小的 $Q$ 值；在UPGMA中，根据其他距离，它们可能是也可能不是第一对被连接的。", "solution": "该问题要求分析两种基于距离的系统发育树构建算法——UPGMA和邻接法(NJ)——在处理包含两个相同分类单元的距离矩阵时的行为。\n\n设分类单元集合为 $S$。设两个重复的分类单元为 $x$ 和 $x'$，它们是 $S$ 中的元素。这些重复单元的属性由给定的对称相异性矩阵 $D$ 定义，其元素为 $d_{ij}$：\n1.  重复单元之间的距离为零：$d_{xx'} = 0$。由于距离是非负的，这是可能的最小距离。\n2.  重复单元与任何其他分类单元 $k$ 的距离相等：对于每个 $k \\in S \\setminus \\{x, x'\\}$，我们有 $d_{xk} = d_{x'k}$。\n\n现在我们将分析在已包含分类单元 $x$ 的前提下，加入分类单元 $x'$ 对UPGMA和NJ的建树过程的影响。\n\n**对UPGMA（非加权对群算术平均法）的分析**\n\nUPGMA是一种凝聚式层次聚类算法。在每一步中，它执行以下操作：\n1.  找到距离 $d(C_i, C_j)$ 最小的一对簇 $(C_i, C_j)$。最初，每个分类单元自成一簇。\n2.  将这对簇合并成一个新的簇 $C_u = C_i \\cup C_j$。\n3.  将连接 $C_i$ 和 $C_j$ 的节点放置在高度为 $d(C_i, C_j) / 2$ 的位置。\n4.  通过计算新簇 $C_u$ 到所有其他簇 $C_k$ 的距离来更新距离矩阵。簇间距离的计算公式是算术平均值：\n    $$d(C_u, C_k) = \\frac{1}{|C_u| |C_k|} \\sum_{a \\in C_u, b \\in C_k} d_{ab}$$\n\n让我们追踪UPGMA在给定矩阵上的第一步。该算法在整个矩阵中搜索最小距离。我们已知 $d_{xx'} = 0$。由于所有距离都是非负的，$d_{ij} \\ge 0$，因此距离 $d_{xx'}$ 保证是矩阵中的一个最小值。因此，在第一步中，UPGMA必须连接对 $(x, x')$。\n\n一个新的簇（我们称之为 $u$）形成了，其中 $u = \\{x, x'\\}$。连接 $x$ 和 $x'$ 的节点被放置在高度为 $d_{xx'} / 2 = 0 / 2 = 0$ 的位置。连接此父节点到叶节点 $x$ 和 $x'$ 的分支长度都将为 $0$。这种结构是一个“零长度樱桃”结构。\n\n接下来，算法更新距离矩阵。簇 $u$ 取代了 $x$ 和 $x'$。从 $u$ 到任何其他分类单元（簇）$k$ 的距离计算如下：\n$$d(u, k) = d(\\{x, x'\\}, \\{k\\}) = \\frac{1}{2 \\cdot 1} (d_{xk} + d_{x'k})$$\n根据问题陈述，我们知道 $d_{xk} = d_{x'k}$。将此代入方程，得到：\n$$d(u, k) = \\frac{1}{2} (d_{xk} + d_{xk}) = d_{xk}$$\n这是一个关键结果。包含簇 $u$ 和其余分类单元的新距离矩阵，与我们只从分类单元 $x$ 开始而从未包含 $x'$ 的距离矩阵在数值上完全相同。任何两个分类单元 $i, j \\in S \\setminus \\{x, x'\\}$ 之间的距离保持不变，并且任何此类分类单元 $k$ 到新簇 $u$ 的距离与其原始到 $x$ 的距离完全相同。\n\n因此，UPGMA算法的所有后续步骤将以与在排除了 $x'$ 的较小数据集上完全相同的方式进行。最终的有根拓扑结构和其他所有节点的高度将是相同的。最终的树只会在单个分类单元 $x$ 原本所在的位置上多出一个由 $x$ 和 $x'$ 组成的零长度“樱桃”结构。\n\n**对邻接法 (NJ) 的分析**\n\nNJ也是一种凝聚式算法，但它使用不同的准则来选择要连接的对。它的目标是找到总枝长最小的树。在每一步中，对于当前包含 $n$ 个分类单元的集合，它计算 $Q$ 矩阵，其中：\n$$Q_{ij} = (n-2)d_{ij} - r_i - r_j$$\n而 $r_i = \\sum_{k=1}^n d_{ik}$ 是从分类单元 $i$ 到所有其他分类单元的距离之和。该算法连接使 $Q_{ij}$ 最小化的对 $(i, j)$。\n\n让我们分析添加重复分类单元 $x'$ 的影响。设 $S'$ 是不含 $x'$ 的分类单元集合，而 $S = S' \\cup \\{x'\\}$ 是完整集合。设 $S'$ 中分类单元的数量为 $n'$，而 $S$ 中分类单元的数量为 $n = n'+1$。\n\n考虑对来自 $S' \\setminus \\{x\\}$ 的任何一对非重复分类单元 $(i, j)$ 进行 $Q$ 矩阵计算。\n在没有 $x'$ 的情况下，准则为 $Q'_{ij} = (n'-2)d_{ij} - r'_i - r'_j$，其中 $r'_i = \\sum_{k \\in S'} d_{ik}$。\n当添加 $x'$ 时，准则变为 $Q_{ij} = (n-2)d_{ij} - r_i - r_j$。分类单元 $i$ 的新距离总和为：\n$$r_i = \\sum_{k \\in S} d_{ik} = \\left(\\sum_{k \\in S'} d_{ik}\\right) + d_{ix'} = r'_i + d_{ix}$$\n（因为 $d_{ix'} = d_{ix}$）。\n那么新的 $Q$ 值为：\n$$Q_{ij} = ((n'+1)-2)d_{ij} - (r'_i + d_{ix}) - (r'_j + d_{jx}) = (n'-1)d_{ij} - (r'_i + d_{ix}) - (r'_j + d_{jx})$$\n$Q$ 值的变化量为：\n$$Q_{ij} - Q'_{ij} = [(n'-1)d_{ij} - r'_i - r'_j - d_{ix} - d_{jx}] - [(n'-2)d_{ij} - r'_i - r'_j]$$\n$$Q_{ij} - Q'_{ij} = d_{ij} - d_{ix} - d_{jx}$$\n这个差值 $d_{ij} - d_{ix} - d_{jx}$ 对于所有对 $(i, j)$ 来说不是一个常数。对于另一对 $(i, l)$，差值将是 $d_{il} - d_{ix} - d_{lx}$。由于该值与具体配对有关，非重复分类单元的 $Q$ 值的相对顺序可能会改变。使 $Q'$ 最小化的对可能不会使 $Q$ 最小化。因此，添加重复分类单元 $x'$ 可以改变聚合的顺序，从而改变非重复分类单元之间的无根拓扑结构。\n\n此外，与UPGMA不同，NJ不保证在第一步就连接对 $(x, x')$。其准则是最小化 $Q_{ij}$，而不是 $d_{ij}$。尽管 $d_{xx'} = 0$ 使得 $Q_{xx'}$ 的第一项为零，但另一对 $(i, j)$ 可能有更负的 $Q$ 值。例如，对于一组四个分类单元 $\\{x, x', a, b\\}$，其距离为 $d_{xx'}=0, d_{xa}=d_{x'a}=2, d_{xb}=d_{x'b}=2, d_{ab}=10$，我们发现 $Q_{xa}$ 是 $Q$ 矩阵中的最小值，而不是 $Q_{xx'}$。\n\n然而，无论对 $(x, x')$ 最终在何时被连接以形成一个新节点 $u$，从 $u$ 到 $x$ 和 $x'$ 的枝长都会被计算。从 $u$ 到 $x$ 的枝长由以下公式给出：\n$$L_{xu} = \\frac{1}{2}d_{xx'} + \\frac{1}{2(n-2)} (r_x - r_{x'})$$\n鉴于 $d_{xx'} = 0$ 且对于所有 $k$ 都有 $d_{xk} = d_{x'k}$，可得出 $r_x = \\sum_k d_{xk} = \\sum_k d_{x'k} = r_{x'}$。因此，第二项也为零。\n$$L_{xu} = 0 + 0 = 0$$\n另一条枝长为 $L_{x'u} = d_{xx'} - L_{xu} = 0 - 0 = 0$。所以，无论它们何时被连接，$x$ 和 $x'$ 都将在最终的NJ树中形成一个零长度的“樱桃”结构。\n\n**评估选项**\n\n*   **A. 在UPGMA下，$x$ 和 $x'$ 将立即形成一个枝长为 $0$ 的簇，并且在将该长度为 $0$ 的“樱桃”结构收缩为单个末端后，非重复分类单元间的其余有根拓扑结构和节点高度与移除 $x'$ 的情况相同；在NJ下，添加 $x'$ 可以通过 $Q$ 准则改变聚合顺序，因此可以改变非重复分类单元间的无根拓扑结构，尽管 $x$ 和 $x'$ 最终将通过长度为 $0$ 的枝连接到它们的共同父节点上。**\n    该陈述准确地反映了我们对UPGMA和NJ的推导。对UPGMA的分析表明，$(x, x')$ 必须在第一步连接，且后续拓扑结构不变。对NJ的分析表明，由于对 $Q$ 准则的非均匀影响，拓扑结构可能改变，并且 $(x, x')$ 将形成零长度“樱桃”结构。该陈述是 **正确的**。\n\n*   **B. 在UPGMA和NJ下，$x$ 和 $x'$ 都将作为一个长度为 $0$ 的“樱桃”结构连接，并且它们的存在不会改变拓扑的任何其他部分；非重复分类单元上的树对于添加 $x'$ 是不变的。**\n    该陈述是错误的，因为如对NJ的分析所示，重复分类单元 $x'$ 的存在可以改变非重复分类单元的树的拓扑结构。关于NJ不变性的说法是错误的。该陈述是 **不正确的**。\n\n*   **C. 在UPGMA下，添加 $x'$ 通常会改变簇间平均值，因此可以改变非重复分类单元间的拓扑结构；在NJ下，$Q$ 准则仅使用成对距离，因此对于添加 $x'$ 是不变的。**\n    该陈述的两个主张都是错误的。对于UPGMA，非重复分类单元的拓扑结构不会改变。对于NJ，$Q$ 准则不是不变的，因为它依赖于到所有分类单元的距离总和（$r_i$），而这个总和会受添加 $x'$ 的影响。该陈述是 **不正确的**。\n\n*   **D. 在NJ中，$x$ 和 $x'$ 必须是第一对被连接的，因为 $d_{xx'}=0$ 保证了最小的 $Q$ 值；在UPGMA中，根据其他距离，它们可能是也可能不是第一对被连接的。**\n    这个陈述颠倒了事实。在UPGMA中，对 $(x, x')$ *必须*首先被连接，因为 $d_{xx'}=0$ 是最小距离。在NJ中，准则是最小化 $Q_{ij}$，我们用一个反例证明了 $(x, x')$ 不一定是第一对被连接的。该陈述是 **不正确的**。\n\n基于详细分析，只有选项A对两种算法的行为提供了科学上正确的描述。", "answer": "$$\\boxed{A}$$", "id": "2385846"}, {"introduction": "构建系统发育树是一回事，但我们如何判断结果是否可靠呢？这在很大程度上取决于距离数据本身是否“像一棵树”。这个高级练习引入了四点条件，这是可加性 ($additivity$) 的数学检验标准，它决定了距离矩阵是否能被一棵树完美地表示。你将学习量化一个矩阵与可加性的偏差，并识别出导致这种偏差最主要的分类单元，这是真实世界数据分析中的一项关键技能。[@problem_id:2385833]", "problem": "给定一组对角线为零的对称距离矩阵。每个矩阵表示一组由 $0,1,\\dots,n-1$ 索引的分类单元之间的成对距离。如果存在一个加权树，其叶到叶的路径长度与矩阵 $D$ 的条目相匹配，则称矩阵 $D\\in\\mathbb{R}^{n\\times n}$ 是可加的（additive）。可加性的一个基本表征使用了四点条件：对于任意四个不同的分类单元 $a,b,c,d$，定义三个和\n$$\ns_1 = D_{a,b} + D_{c,d},\\quad s_2 = D_{a,c} + D_{b,d},\\quad s_3 = D_{a,d} + D_{b,c}.\n$$\n对于一个严格可加的矩阵，对每个无序四元组 $\\{a,b,c,d\\}$，$\\{s_1,s_2,s_3\\}$ 中的两个最大值是相等的。为了量化与可加性的偏差，定义无序四元组 $\\{a,b,c,d\\}$ 的四元组偏离度为\n$$\nv(\\{a,b,c,d\\};D) \\;=\\; \\max\\{s_1,s_2,s_3\\} \\;-\\; \\text{second\\_largest}\\{s_1,s_2,s_3\\}.\n$$\n定义总可加性偏差\n$$\nV(D) \\;=\\; \\sum_{\\{a,b,c,d\\}\\subset\\{0,\\dots,n-1\\}} v(\\{a,b,c,d\\};D),\n$$\n并约定当 $n<4$ 时（不存在四元组），$V(D)=0$。对于任意分类单元索引 $i\\in\\{0,\\dots,n-1\\}$，令 $D^{(-i)}$ 表示从 $D$ 中移除第 $i$ 行和第 $i$ 列得到的主子矩阵。定义移除分类单元 $i$ 后可加性的改善值为\n$$\n\\Delta_i(D) \\;=\\; V(D) \\;-\\; V\\!\\left(D^{(-i)}\\right).\n$$\n你的任务是，对于每个给定的测试矩阵 $D$，输出使 $\\Delta_i(D)$ 最大化的索引 $i^\\star$。如果出现平局（多个 $i$ 达到相同的最大值 $\\Delta_i(D)$），则输出其中最小的索引。所有索引都是从0开始的整数。\n\n测试套件（每个矩阵都是对角线为零的对称矩阵；条目为实数）：\n\n1) 矩阵 $D^{(1)}\\in\\mathbb{R}^{4\\times 4}$：\n$$\nD^{(1)} \\;=\\; \\begin{bmatrix}\n0 & 2.5 & 6.0 & 4.5 \\\\\n2.5 & 0 & 6.5 & 5.0 \\\\\n6.0 & 6.5 & 0 & 2.5 \\\\\n4.5 & 5.0 & 2.5 & 0\n\\end{bmatrix}.\n$$\n\n2) 矩阵 $D^{(2)}\\in\\mathbb{R}^{5\\times 5}$：\n从分类单元 $\\{0,1,2,3,4\\}$ 上的一个可加树度量开始，其成对距离为\n$d_{0,1}=3.0$, $d_{0,2}=4.5$, $d_{0,3}=5.0$, $d_{0,4}=5.25$, $d_{1,2}=5.5$, $d_{1,3}=6.0$, $d_{1,4}=6.25$, $d_{2,3}=3.5$, $d_{2,4}=3.75$, $d_{3,4}=2.25$, 然后仅对涉及分类单元 4 的距离进行扰动，通过添加不同的偏移量：$d_{0,4}$ 加 $+0.6$，$d_{1,4}$ 加 $+0.1$，$d_{2,4}$ 加 $+0.9$，$d_{3,4}$ 加 $+0.2$。得到的矩阵是\n$$\nD^{(2)} \\;=\\; \\begin{bmatrix}\n0 & 3.0 & 4.5 & 5.0 & 5.85 \\\\\n3.0 & 0 & 5.5 & 6.0 & 6.35 \\\\\n4.5 & 5.5 & 0 & 3.5 & 4.65 \\\\\n5.0 & 6.0 & 3.5 & 0 & 2.45 \\\\\n5.85 & 6.35 & 4.65 & 2.45 & 0\n\\end{bmatrix}.\n$$\n\n3) 矩阵 $D^{(3)}\\in\\mathbb{R}^{5\\times 5}$（$D^{(2)}$ 背后的未扰动可加矩阵）：\n$$\nD^{(3)} \\;=\\; \\begin{bmatrix}\n0 & 3.0 & 4.5 & 5.0 & 5.25 \\\\\n3.0 & 0 & 5.5 & 6.0 & 6.25 \\\\\n4.5 & 5.5 & 0 & 3.5 & 3.75 \\\\\n5.0 & 6.0 & 3.5 & 0 & 2.25 \\\\\n5.25 & 6.25 & 3.75 & 2.25 & 0\n\\end{bmatrix}.\n$$\n\n4) 矩阵 $D^{(4)}\\in\\mathbb{R}^{3\\times 3}$：\n$$\nD^{(4)} \\;=\\; \\begin{bmatrix}\n0 & 2 & 3 \\\\\n2 & 0 & 4 \\\\\n3 & 4 & 0\n\\end{bmatrix}.\n$$\n\n要求的输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试套件的顺序相同，例如 $[i_1,i_2,i_3,i_4]$，其中每个 $i_k$ 是为 $D^{(k)}$ 选择的索引。", "solution": "所呈现的问题是计算系统发育学中一个明确定义的练习，具体涉及距离矩阵的分析。我们的目标是确定从数据集中移除哪个分类单元后，能最大程度地改善距离矩阵的可加性。可加性是一个关键属性，因为它是距离矩阵能够被系统发育树完美表示的充要条件。\n\n与可加性的偏差使用四点条件进行量化。对于任意一组四个不同的分类单元，索引为 $\\{a, b, c, d\\}$，我们计算三个距离和：\n$$s_1 = D_{a,b} + D_{c,d}$$\n$$s_2 = D_{a,c} + D_{b,d}$$\n$$s_3 = D_{a,d} + D_{b,c}$$\n一个矩阵 $D$ 是可加的，当且仅当对于每个这样的四元组，这三个和中的两个相等且大于第三个。单个四元组对该条件的偏离由四元组偏离度来衡量：\n$$v(\\{a,b,c,d\\};D) = \\max\\{s_1,s_2,s_3\\} - \\text{second\\_largest}\\{s_1,s_2,s_3\\}$$\n对于整个大小为 $n \\times n$ 的矩阵 $D$，总可加性偏差是所有可能的分类单元四元组的这些偏离度之和：\n$$V(D) = \\sum_{\\{a,b,c,d\\} \\subseteq \\{0, \\dots, n-1\\}} v(\\{a,b,c,d\\};D)$$\n按照惯例，如果分类单元的数量 $n$ 小于 4，则不存在四元组，因此 $V(D) = 0$。\n\n任务是找到移除后能最大化可加性改善值的分类单元 $i^\\star$。对于一个分类单元 $i$，这个改善值定义为：\n$$\\Delta_i(D) = V(D) - V\\left(D^{(-i)}\\right)$$\n其中 $D^{(-i)}$ 是从 $D$ 中移除第 $i$ 行和第 $i$ 列得到的主子矩阵。\n\n一种朴素的方法是首先通过遍历所有 $\\binom{n}{4}$ 个四元组来计算 $V(D)$，然后对每个分类单元 $i$，通过遍历较小矩阵的所有 $\\binom{n-1}{4}$ 个四元组来计算 $V(D^{(-i)})$。这导致总体计算复杂度为 $O(n^5)$，效率低下。\n\n更深入的分析揭示了一个重要的简化。$\\Delta_i(D)$ 的定义可以重写为：\n$$\\Delta_i(D) = \\left( \\sum_{\\{a,b,c,d\\} \\subseteq \\{0, \\dots, n-1\\}} v(\\{a,b,c,d\\};D) \\right) - \\left( \\sum_{\\{a',b',c',d'\\} \\subseteq \\{0, \\dots, n-1\\} \\setminus \\{i\\}} v(\\{a',b',c',d'\\};D) \\right)$$\n第二个和是遍及所有*不*包含分类单元 $i$ 的四元组。第一个和是遍及*所有*四元组。这两个和之间的差值恰好是所有*确实*包含分类单元 $i$ 的四元组的偏离度之和。因此，我们得到了一个更直接的表达式：\n$$\\Delta_i(D) = \\sum_{\\{j,k,l\\} \\subseteq \\{0, \\dots, n-1\\} \\setminus \\{i\\}} v(\\{i,j,k,l\\};D)$$\n这个公式表明，改善值 $\\Delta_i(D)$ 只是所有涉及分类单元 $i$ 的四元组的偏离度之和。这是合乎逻辑的：移除一个分类单元会移除所有与之相关的误差贡献。\n\n这一见解提供了一个复杂度为 $O(n^4)$ 的更优算法。\n\n算法如下：\n1. 对于一个给定的 $n \\times n$ 距离矩阵 $D$，如果 $n < 4$，问题是平凡的。$V(D)=0$ 并且对于任意 $i$，$V(D^{(-i)})=0$。因此，对所有 $i$，$\\Delta_i(D)=0$。根据平局规则选择最小索引，所以我们选择 $i^\\star=0$。\n\n2. 如果 $n \\ge 4$，我们为每个分类单元 $i \\in \\{0, \\dots, n-1\\}$ 计算 $\\Delta_i(D)$。\n   a. 对于每个 $i$，初始化一个和，$\\text{current\\_delta} = 0$。\n   b. 遍历来自集合 $\\{0, \\dots, n-1\\} \\setminus \\{i\\}$ 的所有唯一的无序索引三元组 $\\{j, k, l\\}$。\n   c. 对于每个这样的三元组，构成四元组 $\\{i, j, k, l\\}$ 并计算其偏离度 $v(\\{i,j,k,l\\}; D)$。\n   d. 将此偏离度加到 $\\text{current\\_delta}$ 上。\n   e. 遍历完所有三元组后，最终的和即为 $\\Delta_i(D)$。\n\n3. 计算出所有 $\\Delta_i(D)$ 值的列表后，我们找到最大值。\n\n4. 最终答案 $i^\\star$ 是产生该最大 $\\Delta_i(D)$ 的最小索引 $i$。\n\n这种基于原理的精炼方法既正确又计算高效，我们将用它来解决给定测试矩阵的问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    The main logic is encapsulated in the find_optimal_index function,\n    which is called for each test matrix.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0.0, 2.5, 6.0, 4.5],\n            [2.5, 0.0, 6.5, 5.0],\n            [6.0, 6.5, 0.0, 2.5],\n            [4.5, 5.0, 2.5, 0.0]\n        ]),\n        np.array([\n            [0.0, 3.0, 4.5, 5.0, 5.85],\n            [3.0, 0.0, 5.5, 6.0, 6.35],\n            [4.5, 5.5, 0.0, 3.5, 4.65],\n            [5.0, 6.0, 3.5, 0.0, 2.45],\n            [5.85, 6.35, 4.65, 2.45, 0.0]\n        ]),\n        np.array([\n            [0.0, 3.0, 4.5, 5.0, 5.25],\n            [3.0, 0.0, 5.5, 6.0, 6.25],\n            [4.5, 5.5, 0.0, 3.5, 3.75],\n            [5.0, 6.0, 3.5, 0.0, 2.25],\n            [5.25, 6.25, 3.75, 2.25, 0.0]\n        ]),\n        np.array([\n            [0.0, 2.0, 3.0],\n            [2.0, 0.0, 4.0],\n            [3.0, 4.0, 0.0]\n        ])\n    ]\n\n    def find_optimal_index(D: np.ndarray) -> int:\n        \"\"\"\n        Calculates the index i* that maximizes the improvement in additivity Delta_i(D).\n        \n        Args:\n            D: A symmetric distance matrix with a zero diagonal.\n        \n        Returns:\n            The smallest index i* maximizing Delta_i(D).\n        \"\"\"\n        n = D.shape[0]\n\n        # By convention, for n < 4, V(D) = 0.\n        # Removing any taxon results in a matrix with n-1 < 4 taxa, so V(D^(-i)) = 0.\n        # Thus, Delta_i(D) = 0 for all i.\n        # The tie-breaking rule requires the smallest index, which is 0.\n        if n < 4:\n            return 0\n\n        deltas = []\n        all_indices = list(range(n))\n\n        # Calculate Delta_i for each taxon i.\n        # Delta_i is the sum of violations for all quartets containing taxon i.\n        for i in range(n):\n            current_delta_i = 0.0\n            other_indices = all_indices[:i] + all_indices[i+1:]\n\n            # Iterate over all unique triplets {j, k, l} from the remaining taxa.\n            for triplet in combinations(other_indices, 3):\n                j, k, l = triplet\n                \n                # The quartet is {i, j, k, l}.\n                # Calculate the three sums for the four-point condition.\n                s1 = D[i, j] + D[k, l]\n                s2 = D[i, k] + D[j, l]\n                s3 = D[i, l] + D[j, k]\n                \n                # Calculate the quartet violation.\n                sums = sorted([s1, s2, s3])\n                violation = sums[2] - sums[1]  # max - second_largest\n                current_delta_i += violation\n            \n            deltas.append(current_delta_i)\n\n        # np.argmax returns the first occurrence of the maximum value,\n        # which satisfies the tie-breaking rule (output the smallest index).\n        return np.argmax(deltas)\n\n    results = []\n    for D in test_cases:\n        result = find_optimal_index(D)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2385833"}]}