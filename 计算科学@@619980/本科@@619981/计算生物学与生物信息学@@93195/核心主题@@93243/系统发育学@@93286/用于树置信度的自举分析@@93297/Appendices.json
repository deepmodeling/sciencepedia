{"hands_on_practices": [{"introduction": "在我们能够解释自举值之前，必须先理解它们是如何从底层数据中生成的。第一个实践练习将带您回到第一性原理，要求您为一个简单的四分类群系统量化单个高度信息化的位点对自举支持率的确切影响。通过解决这个假设性场景 [@problem_id:2377065]，您将为重采样过程如何将位点模式转化为统计置信度量建立一个具体的直觉。", "problem": "给定一个系统发育场景，其中包含 $4$ 个标记为 $A$、$B$、$C$ 和 $D$ 的分类单元的脱氧核糖核酸（DNA）序列比对。目标是精确量化将一个信息量很高的位点替换为不确定字符 $N$（意为“未知核苷酸”）如何改变分支 $\\{A,B\\}$ 的非参数自举支持度。您的程序必须计算替换 $N$ 前后分支 $\\{A,B\\}$ 的支持度，并报告支持度的下降值。计算必须基于自举重采样和四元组推断的基本原理，且结果必须以小数（而非百分比）表示。\n\n基本依据和定义：\n- 一个 DNA 序列比对是一个矩阵，有 $4$ 行（分类单元）和 $L$ 列（位点）。每个条目是 $\\{A,C,G,T,N\\}$ 中的一个。\n- 一个自举重复是通过从原始比对中有放回地抽样 $L$ 列形成的。此抽样在所有位置上是独立同分布的，每次抽样时，每个原始列被选中的概率为 $1/L$。\n- 对于任何重复比对，将分类单元 $X$ 和 $Y$ 之间的成对 p-距离 $d(X,Y)$ 定义为 $X$ 和 $Y$ 不同的位点数（在 $L$ 个抽样列中）所占的比例，忽略任何一个分类单元为 $N$ 的位点。如果一对分类单元在忽略 $N$ 后没有有效的位点，则设 $d(X,Y)=0$。\n- 对于任何重复中的四元组 $\\{A,B,C,D\\}$，通过严格的四点条件推断无根分裂：当且仅当\n$$\nd(A,B) + d(C,D) \\lt \\min\\big(d(A,C)+d(B,D),\\ d(A,D)+d(B,C)\\big)\n$$\n时，选择分裂 $\\{A,B\\}|\\{C,D\\}$。\n如果最小值不是严格取得的（即存在任何相等情况），则视该重复为不支持 $\\{A,B\\}$。\n- 分支 $\\{A,B\\}$ 的自举支持度是指其推断出的分裂为 $\\{A,B\\}|\\{C,D\\}$ 的自举重复所占的比例。在此问题中，您必须计算所提供的比对在重采样方案下所隐含的精确值，而不是渐近置信度或启发式分数。\n\n位点操作规则：\n- “将一个位点替换为 $N$”是指：选择一个指定的列索引，并将该列中所有 $4$ 个分类单元的字符替换为 $N$。所有其他列保持不变。\n\n任务要求：\n- 对于每个测试用例，计算分支 $\\{A,B\\}$ 的两个支持度：在将指定列替换为 $N$ 之前和之后（根据测试用例的规定，替换集可以是一列或多列）。然后计算下降值\n$$\n\\Delta = \\text{支持度}_{\\text{替换前}} - \\text{支持度}_{\\text{替换后}},\n$$\n以 $[0,1]$ 区间内的小数表示。报告每个 $\\Delta$ 值，并精确到小数点后 $3$ 位。\n- 重要约束：以下所有测试用例的构造方式是，每个位点要么在所有分类单元中是恒定的，要么是 $\\{A,B\\}$ 对 $\\{C,D\\}$ 的形式为 $A/A$ 对 $G/G$ 的简约性信息位点（没有其他信息模式出现），并且最初没有 $N$ 符号。在这些条件下，一个自举重复支持 $\\{A,B\\}$ 当且仅当至少有一个这样的信息位点在该重复中被至少抽样到一次。您的程序必须使用与上述定义普遍一致的正确逻辑。\n\n测试套件：\n- 测试用例 1（带有一个决定性位点的理想路径）：\n  - 分类单元：$A,B,C,D$。\n  - 比对长度 $L=20$。\n  - 比对：所有位点在所有分类单元中均为 $A$，但在列索引 $3$（从零开始）处除外，该处 $A$ 和 $B$ 为 $A$，$C$ 和 $D$ 为 $G$。\n  - 替换：将列索引 $3$ 处的所有分类单元替换为 $N$。\n- 测试用例 2（带有多个决定性位点的稳健信号）：\n  - 分类单元：$A,B,C,D$。\n  - 比对长度 $L=40$。\n  - 比对：所有位点在所有分类单元中均为 $A$，但在 $10$ 个列索引 $\\{1,5,9,13,17,21,25,29,33,37\\}$（从零开始）处除外，这些地方 $A$ 和 $B$ 为 $A$，$C$ 和 $D$ 为 $G$。\n  - 替换：仅将列索引 $1$ 处的所有分类单元替换为 $N$。\n- 测试用例 3（带单个位点的边界情况）：\n  - 分类单元：$A,B,C,D$。\n  - 比对长度 $L=1$。\n  - 比对：在列索引 $0$ 处，$A$ 和 $B$ 为 $A$，$C$ 和 $D$ 为 $G$。\n  - 替换：将列索引 $0$ 处的所有分类单元替换为 $N$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的下降值 $\\Delta$，按顺序排列，形式为用方括号括起来的、以逗号分隔的列表。每个值必须精确到小数点后 $3$ 位。例如，可接受的格式是\n\"[0.123,0.456,0.789]\"。", "solution": "该问题陈述已经过严格验证，被认为是科学上可靠、定义明确且客观的。它提出了一个标准的、尽管是简化的系统发育推断场景，为推导出唯一的、可验证的解决方案提供了所有必要的定义和数据。该问题是有效的，将按其陈述进行求解。\n\n问题的核心是计算分支的自举支持度，即一个自举重复满足给定拓扑条件的概率。分析需要从基本原理进行推导。\n\n首先，我们形式化一个重复支持分裂 $\\{A,B\\}|\\{C,D\\}$ 的条件。问题规定，当且仅当严格的四点条件得到满足时，才存在这种支持：\n$$\nd(A,B) + d(C,D) < \\min\\big(d(A,C)+d(B,D),\\ d(A,D)+d(B,C)\\big)\n$$\n其中 $d(X,Y)$ 是成对 p-距离。问题受限于以下约束：原始比对中的所有位点要么在所有四个分类单元中是恒定的，要么是对于分裂 $\\{A,B\\}|\\{C,D\\}$ 是简约性信息的。\n\n让我们分析在一个长度为 $L$ 的自举重复中，每种位点类型对成对距离的贡献。\n一个自举重复是通过从原始比对中有放回地抽样 $L$ 列形成的。假设一个给定的重复包含 $k_I$ 个信息位点、$k_C$ 个恒定位点和 $k_N$ 个所有字符均为 $N$ 的位点。抽样位点的总数是 $L=k_I + k_C + k_N$。\n\np-距离 $d(X,Y)$ 定义为不同位点所占的比例，忽略任何一个分类单元为 'N' 的位点。\n对于任何类型为 $(c,c,c,c)$（恒定）或 $(X,X,Y,Y)$（对 $\\{A,B\\}|\\{C,D\\}$ 是信息的）的位点，所有字符都来自 $\\{A,C,G,T\\}$。对于类型为 $(N,N,N,N)$ 的位点，在所有距离计算中都将被忽略。\n因此，用于计算任何成对距离 $d(X,Y)$ 的有效位点数为 $L_{\\text{valid}} = k_I + k_C$。\n\n如果 $L_{\\text{valid}} = 0$，这当且仅当一个重复完全由所有分类单元均为 $N$ 的列组成时发生，则所有成对距离都定义为 $0$。支持条件变为 $0 < \\min(0,0)$，这是不成立的。这样的重复不提供任何支持。\n\n如果 $L_{\\text{valid}} > 0$：\n- 对于分类单元 $A$ 和 $B$，它们的序列在所有信息位点和恒定位点上都是相同的。差异数为 $0$。因此，$d(A,B) = 0/L_{\\text{valid}} = 0$。\n- 类似地，对于分类单元 $C$ 和 $D$，它们的序列是相同的。因此，$d(C,D) = 0$。\n- 不等式左侧为 $d(A,B) + d(C,D) = 0$。\n\n- 对于分类单元 $A$ 和 $C$，它们的序列在恒定位点上相同，但在所有 $k_I$ 个信息位点上不同。差异数为 $k_I$。因此，$d(A,C) = k_I / L_{\\text{valid}}$。\n- 根据信息模式的对称性，$d(B,D) = d(A,D) = d(B,C) = k_I / L_{\\text{valid}}$。\n- 不等式右侧为 $\\min(2k_I/L_{\\text{valid}}, 2k_I/L_{\\text{valid}}) = 2k_I/L_{\\text{valid}}$。\n\n支持度的四点条件变为 $0 < 2k_I/L_{\\text{valid}}$。此不等式当且仅当 $k_I > 0$ 时成立。因此，一个自举重复支持分支 $\\{A,B\\}$ 当且仅当它包含至少一个信息位点。这验证了问题陈述中的断言。\n\n现在，任务简化为一个概率计算问题。设 $L$ 为比对中的总位点数，$I$ 为信息位点数。剩下的 $L-I$ 个位点是非信息位点（恒定或全为 $N$）。\n单次抽样中抽到非信息位点的概率为 $p_{\\text{non-I}} = (L-I)/L$。\n由于一个自举重复由 $L$ 次独立抽样组成，所有 $L$ 个抽样位点都是非信息位点的概率是：\n$$\nP(\\text{无支持}) = \\left(\\frac{L-I}{L}\\right)^L\n$$\n自举支持度是互补事件的概率，即至少抽样到一个信息位点：\n$$\n\\text{支持度}(L, I) = 1 - P(\\text{无支持}) = 1 - \\left(\\frac{L-I}{L}\\right)^L\n$$\n此公式提供了精确的支持度值。我们将其应用于每个测试用例。\n\n测试用例 1：\n- 比对长度 $L=20$。\n- 替换前：在列索引 $3$ 处有一个信息位点。因此，$I_{\\text{替换前}} = 1$。\n  $\\text{支持度}_{\\text{替换前}} = 1 - \\left(\\frac{20-1}{20}\\right)^{20} = 1 - (0.95)^{20}$。\n- 替换后：信息位点被替换为 $N$，变为非信息位点。因此，$I_{\\text{替换后}} = 0$。\n  $\\text{支持度}_{\\text{替换后}} = 1 - \\left(\\frac{20-0}{20}\\right)^{20} = 1 - 1^{20} = 0$。\n- 支持度下降值：$\\Delta_1 = \\text{支持度}_{\\text{替换前}} - \\text{支持度}_{\\text{替换后}} = 1 - (0.95)^{20} \\approx 0.641514$。\n\n测试用例 2：\n- 比对长度 $L=40$。\n- 替换前：有 $10$ 个信息位点。因此，$I_{\\text{替换前}} = 10$。\n  $\\text{支持度}_{\\text{替换前}} = 1 - \\left(\\frac{40-10}{40}\\right)^{40} = 1 - (0.75)^{40}$。\n- 替换后：其中一个信息位点被替换为 $N$。还剩下 $9$ 个信息位点。因此，$I_{\\text{替换后}} = 9$。\n  $\\text{支持度}_{\\text{替换后}} = 1 - \\left(\\frac{40-9}{40}\\right)^{40} = 1 - (0.775)^{40}$。\n- 支持度下降值：$\\Delta_2 = \\left(1 - (0.75)^{40}\\right) - \\left(1 - (0.775)^{40}\\right) = (0.775)^{40} - (0.75)^{40} \\approx 0.0000119$。\n\n测试用例 3：\n- 比对长度 $L=1$。\n- 替换前：单个位点是信息位点。因此，$I_{\\text{替换前}} = 1$。\n  $\\text{支持度}_{\\text{替换前}} = 1 - \\left(\\frac{1-1}{1}\\right)^1 = 1 - 0^1 = 1$。\n- 替换后：单个信息位点被移除。因此，$I_{\\text{替换后}} = 0$。\n  $\\text{支持度}_{\\text{替换后}} = 1 - \\left(\\frac{1-0}{1}\\right)^1 = 1 - 1^1 = 0$。\n- 支持度下降值：$\\Delta_3 = 1 - 0 = 1$。\n\n最终结果是这些 $\\Delta$ 值，四舍五入到小数点后 $3$ 位。\n$\\Delta_1 \\approx 0.642$\n$\\Delta_2 \\approx 0.000$\n$\\Delta_3 = 1.000$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the drop in bootstrap support for the clade {A,B} for three test cases.\n    The support is calculated based on the exact probability of sampling at least one \n    informative site in a bootstrap replicate.\n    \"\"\"\n\n    def calculate_support(L, I):\n        \"\"\"\n        Calculates the exact bootstrap support.\n\n        Args:\n            L (int): The total number of sites in the alignment.\n            I (int): The number of informative sites for the clade of interest.\n\n        Returns:\n            float: The bootstrap support value, a probability in [0, 1].\n        \"\"\"\n        if L <= 0:\n            return 0.0\n        if I <= 0:\n            return 0.0\n\n        # The probability of not sampling an informative site in a single draw.\n        prob_non_informative_draw = (L - I) / L\n        \n        # The probability of not sampling any informative site in L draws.\n        prob_no_support = np.power(prob_non_informative_draw, L)\n        \n        # The support is the complementary probability.\n        return 1.0 - prob_no_support\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (L, I_before, I_after)\n    test_cases = [\n        # Test Case 1: L=20, 1 informative site, which is then removed.\n        (20, 1, 0),\n        # Test Case 2: L=40, 10 informative sites, 1 of which is removed.\n        (40, 10, 9),\n        # Test Case 3: L=1, 1 informative site, which is then removed.\n        (1, 1, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, I_before, I_after = case\n        \n        support_before = calculate_support(L, I_before)\n        support_after = calculate_support(L, I_after)\n        \n        delta = support_before - support_after\n        results.append(delta)\n\n    # Format the results as specified: a list of strings rounded to 3 decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2377065"}, {"introduction": "系统发育学中一个常见的问题是：“我的分析返回了一棵完全解析的‘最佳’树，为什么我还需要进行自举分析？”这个练习通过呈现一个最大似然树明确，但自举共有树却完全未解析的案例，为这个问题提供了有力的答案。通过构建和分析这样一个数据集 [@problem_id:2377058]，您将发现自举分析如何作为一个关键的诊断工具，揭示一个看似“最佳”的解决方案是否建立在薄弱或冲突的证据之上。", "problem": "要求您通过计算构建并验证一个包含四个分类单元的小型多序列比对。对于该比对，在 Jukes-Cantor (JC) 模型下推断出的最大似然 (ML) 树是完全解析的（二叉树），但其非参数自举多数决一致树却是一个完全未解析的星状树（没有任何内部类群划分达到严格多数阈值）。\n\n您的程序必须从基本原理出发实现以下内容。\n\n1) 用作基础的基本定义：\n- 系统发育的非参数自举法 (Nonparametric bootstrap for phylogenies) 通过有放回地重抽样比对列来创建多个重复比对（每个重复比对的长度与原始比对相同），然后在每个重复比对上推断一棵树。某个内部类群划分在所有重复比对中出现的频率，是其抽样支持度的一个估计量。\n- 最大似然 (Maximum Likelihood, ML)：给定一个固定的树拓扑和一个替换模型，枝长会使观测到的比对的似然性最大化。在所有候选拓扑中，ML 树是那个具有最高优化似然值的拓扑。\n- Jukes-Cantor (JC) 模型：对于一个长度为 $t$（单位为每个位点的预期替换数）的分支，以及任意一对核苷酸 $i$ 和 $j$，在速率为 $1$ 的 JC 模型下，其转移概率为\n$$\nP_{ij}(t) =\n\\begin{cases}\n\\frac{1}{4} + \\frac{3}{4} e^{-\\frac{4}{3} t}, & i=j, \\\\\n\\frac{1}{4} - \\frac{1}{4} e^{-\\frac{4}{3} t}, & i\\neq j.\n\\end{cases}\n$$\n稳态分布是均匀的，对于所有 $i$, $\\pi_i = \\frac{1}{4}$。\n- Felsenstein 剪枝算法：对于一棵有根树和一个具有观测到的叶节点状态的位点，该位点的似然值为\n$$\n\\mathcal{L}_{\\text{site}} = \\sum_{r\\in\\{A,C,G,T\\}} \\pi_r \\prod_{c \\in \\text{children(root)}} \\left( \\sum_{k} P_{rk}(t_{rc}) \\, L_c(k) \\right),\n$$\n其中 $L_c(k)$ 是在父节点状态为 $k$ 的条件下，子节点 $c$ 处的局部似然值；而在一个观测状态为 $s$ 的叶节点处，我们设定 $L_{\\text{leaf}}(k)=\\mathbb{I}[k=s]$。时间可逆性确保了该似然值与根的任意放置位置无关。\n\n2) 数据集设计空间与决策规则：\n- 考虑四个分类单元，记为 $A$、$B$、$C$ 和 $D$。将范围限制在三种完全解析的无根二叉拓扑上，它们由其唯一的内部类群划分表示：\n  - $T_1$: $(A,B)\\mid(C,D)$,\n  - $T_2$: $(A,C)\\mid(B,D)$,\n  - $T_3$: $(A,D)\\mid(B,C)$.\n- 构建一个仅由简约性信息位点模式组成的比对，这些模式在 JC 模型下强烈且对称地支持以下类群划分中的一种：\n  - 支持 $T_1$ 的模式：$A=A$, $B=A$, $C=G$, $D=G$（编码为状态 $[0,0,2,2]$），\n  - 支持 $T_2$ 的模式：$A=A$, $C=A$, $B=G$, $D=G$（编码为 $[0,2,0,2]$），\n  - 支持 $T_3$ 的模式：$A=A$, $D=A$, $B=G$, $C=G$（编码为 $[0,2,2,0]$）。\n- 设该比对由这三种模式的计数 $(c_1,c_2,c_3)$ 决定。记 $L=c_1+c_2+c_3$。\n- 对于完整数据集，通过枚举三种拓扑 $T_1$、$T_2$ 和 $T_3$，优化它们的枝长，并选择具有最大优化对数似然值的拓扑，来计算 JC 模型下的 ML 树。如果只有一个拓扑严格地使优化对数似然值达到最大，则该树是“完全解析的”。\n- 对于自举分析，通过从原始比对中有放回地抽样 $L$ 列来获得重复比对。每个自举重复通过相同的 JC-ML 过程从 $\\{T_1,T_2,T_3\\}$ 中选择一个 ML 拓扑。在严格阈值 $0.5$ 下的多数决一致树包含任何其在各重复中的选择频率严格大于 $0.5$ 的类群划分。如果没有类群划分满足此条件，则一致树为星状树（完全未解析）。\n\n3) 精确评估自举选择频率：\n- 设类别概率为 $p_i = c_i/L$（其中 $i\\in\\{1,2,3\\}$）。一个自举重复中三种信息性类别的计数 $(k_1,k_2,k_3)$ 服从三项分布：\n$$\n\\Pr[k_1,k_2,k_3] = \\frac{L!}{k_1!\\,k_2!\\,k_3!} \\, p_1^{k_1} p_2^{k_2} p_3^{k_3}, \\quad k_1+k_2+k_3=L, \\; k_i\\ge 0.\n$$\n- 假定一个重复样本的拓扑决策取决于 $k_1,k_2,k_3$ 中的最大值（这与在 JC 模型下，对于受限模式的 ML 结果相匹配）。按固定的 $(T_1,T_2,T_3)$ 顺序以字典序打破平局，即，如果 $k_1\\ge k_2$ 且 $k_1\\ge k_3$，则选择 $T_1$；否则，如果 $k_2>k_1$ 且 $k_2\\ge k_3$，则选择 $T_2$；否则选择 $T_3$。\n- 拓扑 $T_i$ 的精确选择概率是通过对 $(k_1,k_2,k_3)$ 空间中所有根据此规则选择 $T_i$ 的区域进行三项概率求和得到的。您必须通过枚举精确计算这些概率，而不能通过蒙特卡罗方法。\n\n4) 您必须计算和报告的内容：\n- 您将获得一个小的 $(m,\\delta)$ 参数测试套件，它们定义了 $(c_1,c_2,c_3)=(m+\\delta,\\,m,\\,m)$。对于每个测试用例，您必须：\n  - 按描述构建比对。\n  - 使用 Felsenstein 剪枝算法，通过 JC 模型进行枝长优化，计算完整数据集上的 ML 拓扑。\n  - 通过三项式枚举和上述字典序平局打破规则，计算精确的自举选择概率 $(P_1,P_2,P_3)$。\n  - 判断严格多数决自举一致树是否为星状树，即 $\\max(P_1,P_2,P_3) \\le 0.5$ 是否成立。\n  - 对每个测试用例，输出一个布尔值，表示两个条件是否同时成立：完整数据的 ML 树是完全解析的，并且自举严格多数决一致树是星状树。\n\n5) 测试套件：\n使用以下测试用例，它们分别测试了一个平衡但有偏的“理想路径”、一个强偏的“非星状”边界情况，以及一个短比对的边缘情况：\n- Case $1$: $(m,\\delta)=(10,1)$, so $(c_1,c_2,c_3)=(11,10,10)$.\n- Case $2$: $(m,\\delta)=(10,20)$, so $(c_1,c_2,c_3)=(30,10,10)$.\n- Case $3$: $(m,\\delta)=(3,1)$, so $(c_1,c_2,c_3)=(4,3,3)$.\n\n6) 最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来并以逗号分隔的结果列表（例如 `[result1,result2,result3]`），每个结果是按测试用例顺序排列的布尔值。不应打印任何其他文本。不涉及角度，也没有物理单位。所有阈值都必须视为纯小数（例如，$0.5$）。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于分子系统发育学原理，特别是最大似然（ML）推断和非参数自举法。该问题提法明确，提供了无歧义的定义、如 Jukes-Cantor (JC) 模型这样的显式模型，以及具有确定输入和输出的清晰计算任务。所有术语都是客观且精确指定的。没有矛盾、缺失数据或不科学的前提。对于给定的参数，计算任务是可行的。\n\n目标是针对特定的多序列比对，确定是否同时满足两个条件：\n$1$. 从完整比对估计的 ML 树是完全解析的。\n$2$. 来自非参数自举分析的严格多数决一致树是一个完全未解析的星状拓扑。\n\n解决方案通过实现问题陈述所要求的逻辑来推进。问题提供了一个关键的简化：无论是对完整数据集还是对任何自举重复样本，ML 拓扑都由确定三种指定的简约性信息位点模式中哪一种计数最高来决定。据称这是在 JC 模型下问题对称构造的结果，并允许我们绕过使用 Felsenstein 剪枝算法进行显式枝长优化的计算密集型步骤。\n\n设三种位点模式的计数为 $(c_1, c_2, c_3)$，分别对应于对拓扑 $T_1$、$T_2$ 和 $T_3$ 的支持。位点总数为 $L = c_1 + c_2 + c_3$。测试用例的形式为 $(c_1, c_2, c_3) = (m+\\delta, m, m)$，其中 $\\delta > 0$。\n\n首先，我们验证完整数据 ML 树“完全解析”的条件。如果一个拓扑唯一地使对数似然值最大化，则它是完全解析的。根据问题的简化，ML 拓扑对应于最大计数的那个。对于给定的测试用例，$c_1 = m+\\delta$ 严格大于 $c_2 = m$ 和 $c_3 = m$。因此，拓扑 $T_1$ 是唯一的 ML 选择。第一个条件——ML 树是完全解析的——对于所有提供的测试用例都满足。\n\n其次，我们评估自举一致树。如果没有拓扑在超过 50% 的自举重复样本中被选中，则一致树为星状树。这需要计算每个拓扑的精确选择概率 $P_1, P_2, P_3$。\n\n一个自举重复是通过从原始比对中有放回地抽样 $L$ 个位点生成的。重复样本中三种模式的计数，记为 $(k_1, k_2, k_3)$，服从三项分布，其中 $k_1+k_2+k_3=L$。观察到特定计数集的概率由概率质量函数给出：\n$$ \\Pr[k_1, k_2, k_3] = \\frac{L!}{k_1!\\,k_2!\\,k_3!} p_1^{k_1} p_2^{k_2} p_3^{k_3} $$\n其中 $p_i = c_i/L$ 是原始比对中各种模式的比例。\n\n对于一个计数为 $(k_1, k_2, k_3)$ 的重复样本，所选择的拓扑由以下规则确定，该规则包含一个字典序平局打破机制：\n- 如果 $k_1 \\ge k_2$ 且 $k_1 \\ge k_3$，则选择 $T_1$。\n- 如果 $k_2 > k_1$ 且 $k_2 \\ge k_3$，则选择 $T_2$。\n- 否则选择 $T_3$。\n\n拓扑 $T_i$ 的总选择概率（记为 $P_i$）是通过对所有导致选择 $T_i$ 的元组 $(k_1, k_2, k_3)$ 的 $\\Pr[k_1, k_2, k_3]$ 进行求和得到的。我们通过枚举 $L$ 的所有可能的整数划分 $(k_1, k_2, k_3)$ 来计算这些概率。为保证数值稳定性，计算使用对数进行。三项概率的对数为：\n$$ \\ln(\\Pr[k_1, k_2, k_3]) = \\ln(\\Gamma(L+1)) - \\sum_{i=1}^{3} \\ln(\\Gamma(k_i+1)) + \\sum_{i=1}^{3} k_i \\ln(p_i) $$\n其中 $\\Gamma$ 是伽玛函数，且 $\\ln(\\Gamma(n+1)) = \\ln(n!)$。\n\n计算出 $P_1, P_2$ 和 $P_3$ 后，我们检查星状一致树的条件：$\\max(P_1, P_2, P_3) \\le 0.5$。\n\n每个测试用例的最终布尔结果是这两个条件的逻辑与。由于第一个条件对于给定的测试用例总是为真，结果简化为自举一致树是否为星状树。对每个指定的 $(m,\\delta)$ 对执行此计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Constructs and verifies alignments for which the ML tree is resolved\n    but the bootstrap majority-rule consensus is a star.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 1),  # Case 1: (m,d)=(10,1) -> (c1,c2,c3)=(11,10,10)\n        (10, 20), # Case 2: (m,d)=(10,20) -> (c1,c2,c3)=(30,10,10)\n        (3, 1),   # Case 3: (m,d)=(3,1) -> (c1,c2,c3)=(4,3,3)\n    ]\n\n    results = []\n    for m, delta in test_cases:\n        # Full-data ML tree resolution check\n        # Counts are (m+delta, m, m). Since delta > 0, c1 is strictly maximal.\n        # The problem states this implies the ML topology is T1 and thus resolved.\n        ml_tree_is_resolved = True\n\n        # Bootstrap consensus check\n        c1, c2, c3 = m + delta, m, m\n        L = c1 + c2 + c3\n        \n        # Proportions of each site pattern\n        p1, p2, p3 = c1 / L, c2 / L, c3 / L\n\n        # Pre-compute logs for efficiency in the loops\n        log_L_fact = gammaln(L + 1)\n        # Note: All test cases have c_i > 0, so p_i > 0. No need to handle log(0).\n        log_p1 = np.log(p1)\n        log_p2 = np.log(p2)\n        log_p3 = np.log(p3)\n\n        # Probabilities for selecting T1, T2, T3\n        P = np.zeros(3)\n\n        # Enumerate all possible bootstrap replicate compositions (k1, k2, k3)\n        for k1 in range(L + 1):\n            for k2 in range(L - k1 + 1):\n                k3 = L - k1 - k2\n\n                # Calculate the trinomial probability for the composition (k1, k2, k3)\n                log_prob = (log_L_fact - gammaln(k1 + 1) - gammaln(k2 + 1) - gammaln(k3 + 1) +\n                            k1 * log_p1 + k2 * log_p2 + k3 * log_p3)\n                prob = np.exp(log_prob)\n\n                # Apply the specified topology selection rule with tie-breaking\n                if k1 >= k2 and k1 >= k3:\n                    P[0] += prob  # T1 is selected\n                elif k2 > k1 and k2 >= k3:\n                    P[1] += prob  # T2 is selected\n                else:\n                    P[2] += prob  # T3 is selected\n\n        # Check if the consensus is a star (no split has > 50% support)\n        is_star_consensus = np.max(P) <= 0.5\n\n        # The final result is the conjunction of the two conditions\n        results.append(ml_tree_is_resolved and is_star_consensus)\n\n    # Final print statement in the exact required format.\n    # The boolean values are automatically converted to \"True\" or \"False\" strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2377058"}, {"introduction": "高的自举支持率（例如，$>95\\%$）通常被认为是支持一个演化支的强有力证据。然而，情况并非总是如此。本练习将引导您了解一个被称为“自举天堂”的经典假象，即在没有任何冲突信号的情况下，极少数的信息位点也能产生具有误导性的高支持率。通过模拟这一现象 [@problem_id:2377030]，您将获得必要的批判性视角，以避免过度解读高支持率，并能更好地评估数据中证据的真实数量。", "problem": "本题要求您研究系统发育推断中一种被称为“自举天堂”（bootstrap paradise）的现象，该现象指极低的噪声和极少的信息位点却可能产生具有误导性的高自举支持率。您将在包含四个标记为 $A$、$B$、$C$ 和 $D$ 的分类单元的设定下，并以逐个位点的方式使用最大简约法准则进行研究。本问题的基本依据如下：\n\n- 一个位点是简约性信息位点（对于四个分类单元而言），当且仅当它在这些分类单元间表现出相同状态的 $2-2$ 分裂。这样的位点恰好支持三种可能的无根分枝之一：$A B \\mid C D$、$A C \\mid B D$ 或 $A D \\mid B C$。\n- 对于四个分类单元的最大简约法，一个包含 $N$ 个位点的比对，如果所有简约性信息位点都是 $2-2$ 类型，那么一个拓扑结构的总简约性分数仅因支持该拓扑结构的此类位点的数量而异。非信息位点（恒定位点或单一模式位点）对所有拓扑结构的贡献相同，因此不影响哪个拓扑结构能使总分最小化。\n\n自举重抽样定义如下：\n\n- 通过从原始的 $N$ 个比对列中有放回地抽样 $N$ 次，得到一个非参数自举重复样本。\n- 对于每个重复样本，计算三种无根拓扑结构中哪一种使简约性分数最小。如果存在唯一的最小化拓扑结构，则记录所选的拓扑结构；如果出现平局（包括未抽到任何简约性信息位点的情况），则将该重复样本视为无法解析，不计为支持任何特定拓扑结构。\n\n您将在位点类别的层面上模拟比对，而不是具体的核苷酸。每个长度为 $N$ 的比对由以下部分组成：\n- $m_{\\text{corr}}$ 个支持焦点分枝 $A B \\mid C D$ 的简约性信息列，\n- $m_{\\text{conf}}$ 个支持冲突分枝 $A C \\mid B D$ 的简约性信息列，\n- $m_{\\text{oth}}$ 个支持剩余分枝 $A D \\mid B C$ 的简约性信息列，\n- 以及 $N - m_{\\text{corr}} - m_{\\text{conf}} - m_{\\text{oth}}$ 个非信息列。\n\n在一个大小为 $N$ 的自举重复样本中，这四种位点类别的抽样计数向量服从多项分布，其参数为 $\\left(\\frac{m_{\\text{corr}}}{N}, \\frac{m_{\\text{conf}}}{N}, \\frac{m_{\\text{oth}}}{N}, 1 - \\frac{m_{\\text{corr}} + m_{\\text{conf}} + m_{\\text{oth}}}{N}\\right)$。令 $X_{\\text{corr}}$、$X_{\\text{conf}}$ 和 $X_{\\text{oth}}$ 为三个信息类别的抽样计数。在最大简约法下，所选的拓扑结构是其计数在 $\\left\\{X_{\\text{corr}}, X_{\\text{conf}}, X_{\\text{oth}}\\right\\}$ 中严格为最大值的那个。如果最大值不唯一，则该重复样本无法解析。\n\n您的任务是编写一个可运行的完整程序，该程序：\n- 为提高效率，使用多项分布实现所述的自举过程。\n- 对每个测试用例使用相同数量 $B$ 的自举重复样本（每个重复样本的重抽样大小为 $N$）。\n- 计算焦点分枝 $A B \\mid C D$ 的自举支持率，即 $X_{\\text{corr}}$ 严格大于 $X_{\\text{conf}}$ 和 $X_{\\text{oth}}$ 的自举重复样本所占的比例。\n\n重要细节和约束：\n- 将支持率表示为小数比例（而非百分比），四舍五入到小数点后恰好 $6$ 位。\n- 每个测试用例使用固定的伪随机种子，以确保结果的确定性。\n- 每个自举重复样本的重抽样大小必须恰好为 $N$。\n- 如果 $m_{\\text{corr}} + m_{\\text{conf}} + m_{\\text{oth}} = 0$，则没有任何重复样本可以支持任何拓扑结构；支持率必须为 $0.0$。\n\n测试套件：\n- 对以下四个参数集中的每一个，使用 $B = 20000$ 个自举重复样本，并使用指定的种子：\n    1. $N = 100$, $m_{\\text{corr}} = 4$, $m_{\\text{conf}} = 0$, $m_{\\text{oth}} = 0$, 种子 $= 1$。\n    2. $N = 100$, $m_{\\text{corr}} = 0$, $m_{\\text{conf}} = 0$, $m_{\\text{oth}} = 0$, 种子 $= 2$。\n    3. $N = 100$, $m_{\\text{corr}} = 5$, $m_{\\text{conf}} = 1$, $m_{\\text{oth}} = 0$, 种子 $= 3$。\n    4. $N = 100$, $m_{\\text{corr}} = 3$, $m_{\\text{conf}} = 3$, $m_{\\text{oth}} = 0$, 种子 $= 4$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的四个自举支持率，以逗号分隔并用方括号括起。每个支持率必须打印为小数比例，四舍五入到小数点后恰好 $6$ 位。例如：$[0.981684,0.000000,0.951000,0.487000]$（仅为示例；请勿硬编码数值）。\n\n您的实现必须是自包含的，不得读取输入或写入任何文件。它必须完全按照上述规定为每个测试用例使用固定的伪随机种子。唯一允许使用的库是 Python 标准库和指定的数值计算库。", "solution": "我们从第一性原理出发，将“自举天堂”机制形式化，并推导出一个与四分类单元最大简约法和非参数自举法相一致的算法。\n\n基本定义和事实：\n- 对于四个分类单元，一个简约性信息位点是指表现出相同状态的 $2-2$ 模式的位点；这样的位点恰好支持三种无根分枝之一：$A B \\mid C D$、$A C \\mid B D$ 或 $A D \\mid B C$。\n- 对于四个分类单元，当所有信息位点都是 $2-2$ 类型时，最大简约法选择比对中受最多 $2-2$ 位点支持的拓扑结构。非信息位点（恒定位点或单一模式位点）不影响哪个拓扑结构具有最小的总变异数，因为它们对所有拓扑结构的贡献是均等的。\n- 在非参数自举法中，我们从一个长度为 $N$ 的比对中有放回地抽样 $N$ 列以形成一个重复样本，并使用相同的准则对该重复样本推断最优拓扑结构。将此过程重复 $B$ 次，可得到一个推断拓扑结构的分布。\n\n在类别层面上对重抽样进行建模：\n- 假设比对有 $N$ 列，由 $m_{\\text{corr}}$ 个支持 $A B \\mid C D$ 的列，$m_{\\text{conf}}$ 个支持 $A C \\mid B D$ 的列，$m_{\\text{oth}}$ 个支持 $A D \\mid B C$ 的列，以及 $N - m_{\\text{corr}} - m_{\\text{conf}} - m_{\\text{oth}}$ 个非信息列组成。\n- 在单个自举重复样本（大小为 $N$）中，四个类别的计数向量服从多项分布：\n$$\n(X_{\\text{corr}}, X_{\\text{conf}}, X_{\\text{oth}}, X_{\\text{non}}) \\sim \\mathrm{Multinomial}\\!\\left(N;\\ \\frac{m_{\\text{corr}}}{N},\\ \\frac{m_{\\text{conf}}}{N},\\ \\frac{m_{\\text{oth}}}{N},\\ 1 - \\frac{m_{\\text{corr}} + m_{\\text{conf}} + m_{\\text{oth}}}{N}\\right).\n$$\n- 在最大简约法下，推断的拓扑结构由 $\\{X_{\\text{corr}}, X_{\\text{conf}}, X_{\\text{oth}}\\}$ 中的严格最大值决定。如果最大值由多个计数同时达到（包括它们都为零的情况），则该重复样本无法解析，不支持任何单一拓扑结构。\n\n因此，焦点分枝 $A B \\mid C D$ 的自举支持率为\n$$\n\\hat{s} \\;=\\; \\frac{1}{B} \\sum_{b=1}^{B} \\mathbf{1}\\!\\left( X_{\\text{corr}}^{(b)} > \\max\\{X_{\\text{conf}}^{(b)}, X_{\\text{oth}}^{(b)}\\} \\right),\n$$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数，上标 $(b)$ 是自举重复样本的索引。\n\n“自举天堂”现象为何会发生：\n- 考虑 $m_{\\text{conf}} = 0$ 和 $m_{\\text{oth}} = 0$ 的情况。此时，一个重复样本不支持 $A B \\mid C D$ 的唯一方式是没有抽到任何支持 $A B \\mid C D$ 的信息列，即 $X_{\\text{corr}} = 0$。因为 $N$ 次抽样中的每一次抽到 $m_{\\text{corr}}$ 个信息列之一的概率是 $m_{\\text{corr}}/N$，所以某个特定信息列未被抽中的概率是 $(1 - 1/N)^{N} \\approx e^{-1}$，而 $m_{\\text{corr}}$ 个信息列中没有任何一个被抽中的概率近似为 $(1 - m_{\\text{corr}}/N)^{N} \\approx e^{-m_{\\text{corr}}}$。因此，\n$$\n\\mathbb{E}[\\hat{s}] \\approx 1 - e^{-m_{\\text{corr}}}.\n$$\n即使对于非常小的 $m_{\\text{corr}}$，这个值也可能具有误导性地接近于 1：当 $m_{\\text{corr}} = 4$ 时，$1 - e^{-4} \\approx 0.981684$，当 $m_{\\text{corr}} = 5$ 时，$1 - e^{-5} \\approx 0.993262$。这说明了尽管数据中固有的信息量很弱，但极少数一致的信息位点在几乎没有噪声的情况下，可以产生非常高的自举支持率。\n\n算法设计：\n- 对于每个测试用例 $(N, m_{\\text{corr}}, m_{\\text{conf}}, m_{\\text{oth}}, B, \\text{seed})$：\n    1. 使用指定的种子设置伪随机数生成器，以确保可复现性。\n    2. 定义类别概率 $p_{\\text{corr}} = m_{\\text{corr}}/N$, $p_{\\text{conf}} = m_{\\text{conf}}/N$, $p_{\\text{oth}} = m_{\\text{oth}}/N$, $p_{\\text{non}} = 1 - p_{\\text{corr}} - p_{\\text{conf}} - p_{\\text{oth}}$。\n    3. 从多项分布 $\\mathrm{Multinomial}(N, [p_{\\text{corr}}, p_{\\text{conf}}, p_{\\text{oth}}, p_{\\text{non}}])$ 中抽取 $B$ 个独立的重复样本。\n    4. 对于每个重复样本，计算 $X_{\\text{corr}}$ 是否严格大于 $X_{\\text{conf}}$ 和 $X_{\\text{oth}}$；如果是，则计为对 $A B \\mid C D$ 的一次支持。\n    5. 计算支持性重复样本的比例，作为自举支持率 $\\hat{s}$。\n    6. 将 $\\hat{s}$ 四舍五入到小数点后恰好 $6$ 位。\n\n计算方面的考量：\n- 使用数值计算库可以对多项分布的抽样进行向量化，即使在 $B = 20000$ 和 $N = 100$ 的情况下，也能使模拟高效进行。\n- 由于向量化操作，每个测试用例的时间复杂度为 $O(B)$，且常数因子很小；临时存储抽样结果的内存复杂度为 $O(B)$，对于给定的规模来说是适中的。\n\n测试套件的解读和预期：\n- 用例 1（$N = 100$, $m_{\\text{corr}} = 4$, 无冲突）：根据上述近似，预期的支持率接近 $1 - e^{-4} \\approx 0.981684$，这展示了“自举天堂”现象。\n- 用例 2（$N = 100$, 无信息位点）：不可能有任何支持；支持率必须为 $0.000000$。\n- 用例 3（$N = 100$, $m_{\\text{corr}} = 5$, $m_{\\text{conf}} = 1$）：噪声极低；大多数重复样本将有 $X_{\\text{corr}} > X_{\\text{conf}}$，支持率会很高（接近但略低于无冲突情况下的近似值）。\n- 用例 4（$N = 100$, $m_{\\text{corr}} = 3$, $m_{\\text{conf}} = 3$）：两种竞争性分枝的计数在平均上是平衡的；支持率将接近 $0.5$，但会因 $X_{\\text{corr}} = X_{\\text{conf}}$ 的平局概率而降低，这些平局被视为无法解析。\n\n最终的程序精确地实现了这个算法，使用了指定的种子，并将四个支持率打印在单行中，以方括号括起，用逗号分隔，每个值都四舍五入到小数点后 6 位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bootstrap_support(N: int, m_corr: int, m_conf: int, m_oth: int, B: int, seed: int) -> float:\n    \"\"\"\n    Compute bootstrap support for the AB|CD split under maximum parsimony\n    given counts of site categories, using multinomial resampling.\n\n    Parameters:\n        N      : alignment length (number of columns)\n        m_corr : number of AB|CD-informative columns (supports focal split)\n        m_conf : number of AC|BD-informative columns (conflicting split)\n        m_oth  : number of AD|BC-informative columns (other split)\n        B      : number of bootstrap replicates\n        seed   : RNG seed for reproducibility\n\n    Returns:\n        support proportion as a float (not percentage)\n    \"\"\"\n    # Category probabilities for multinomial sampling\n    p_corr = m_corr / N\n    p_conf = m_conf / N\n    p_oth = m_oth / N\n    p_non = 1.0 - (p_corr + p_conf + p_oth)\n    # Guard for numerical drift\n    if p_non < 0:\n        raise ValueError(\"Sum of informative sites exceeds N.\")\n    pvals = np.array([p_corr, p_conf, p_oth, p_non], dtype=float)\n\n    rng = np.random.default_rng(seed)\n    # Draw B multinomial samples: shape (B, 4)\n    counts = rng.multinomial(n=N, pvals=pvals, size=B)\n    # Extract counts for the three informative categories\n    X_corr = counts[:, 0]\n    X_conf = counts[:, 1]\n    X_oth = counts[:, 2]\n\n    # Determine unique maximum among the three categories\n    # Compute maximum and count how many attain it\n    max_vals = np.maximum.reduce([X_corr, X_conf, X_oth])\n    is_max_corr = (X_corr == max_vals)\n    is_max_conf = (X_conf == max_vals)\n    is_max_oth = (X_oth == max_vals)\n    # Count of categories attaining the maximum per replicate\n    max_ties = (is_max_corr.astype(int) +\n                is_max_conf.astype(int) +\n                is_max_oth.astype(int))\n\n    # Unique winner mask (no ties)\n    unique_winner = (max_ties == 1)\n    # Among unique winners, check if AB|CD (corr) is the winner\n    support_mask = unique_winner & is_max_corr\n\n    support = support_mask.mean()\n    return float(support)\n\ndef solve():\n    # Define the test cases from the problem statement: (N, m_corr, m_conf, m_oth, B, seed)\n    B = 20000\n    test_cases = [\n        (100, 4, 0, 0, B, 1),  # Bootstrap paradise: few informative, no noise\n        (100, 0, 0, 0, B, 2),  # Boundary: no informative sites\n        (100, 5, 1, 0, B, 3),  # Very low noise\n        (100, 3, 3, 0, B, 4),  # Balanced conflicting signal\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m_corr, m_conf, m_oth, B_rep, seed = case\n        val = bootstrap_support(N, m_corr, m_conf, m_oth, B_rep, seed)\n        results.append(f\"{val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2377030"}]}