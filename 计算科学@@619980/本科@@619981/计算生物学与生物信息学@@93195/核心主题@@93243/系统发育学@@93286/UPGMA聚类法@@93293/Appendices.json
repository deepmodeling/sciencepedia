{"hands_on_practices": [{"introduction": "要真正掌握一种算法，最好的方法莫过于亲手实现它。本练习将指导你从基本原理出发，一步步构建 UPGMA 算法。你将处理一个源自蛋白质结构比对的距离矩阵，这是一个在生物信息学中非常实际的应用场景，通过这个过程，你将对 UPGMA 的操作流程和核心逻辑建立起坚实而直观的理解 [@problem_id:2439017]。", "problem": "给定您三个对称的成对非相似性矩阵，这些矩阵源自蛋白质结构之间的均方根偏差 (RMSD) 值。RMSD 是一种以埃 (Å) 为单位的非负非相似性度量。请实现非加权组平均法 (UPGMA)，这是一种凝聚式、有根的层次聚类方法，它假设一个恒定速率（超度量）模型，通过构建一个超度量树来将蛋白质分组为结构家族。您的程序必须计算完整的合并序列，并为每次合并报告被合并的两个簇的索引、它们合并时的共表型高度（以 Å 为单位），以及新形成的簇的大小。\n\n需使用的基本依据和规则：\n- 从非相似性矩阵的定义开始：一个对称矩阵 $D$，其元素满足 $d(i,j) \\ge 0$，$d(i,i) = 0$ 以及 $d(i,j) = d(j,i)$，编码了项目间的成对非相似性。\n- 在每次迭代中，选择具有最小簇间非相似性的两个活跃簇并将它们合并。\n- 新的合并簇与任何剩余簇之间的距离必须定义为其成员之间所有成对距离的算术平均值。\n- 合并的共表型高度定义为两个簇在合并时刻非相似性的一半，以埃表示。\n- 确定性要求：\n  - 最小簇间非相似性的相等情况必须通过选择字典序中最小的有序标签对来解决。\n  - $n$ 个独立蛋白质的初始标签为 $0,1,\\dots,n-1$。\n  - 每次创建新簇时，从 $n$ 开始按递增顺序为其分配下一个未使用的整数标签。\n  - 报告合并时，始终按升序排列两个标签。\n- 将每次合并报告为一个包含四个数字的列表 $[a,b,h,s]$，其中 $a$ 和 $b$ 是被合并簇的标签且 $a<b$，$h$ 是以埃为单位的共表型高度（一个浮点数），$s$ 是新形成的簇的大小（原始蛋白质的数量）（一个整数）。\n\n测试套件（所有非相似性均以埃为单位）：\n- 情况 A（一般情况，$n=5$）：\n  - 矩阵 $D_A$ 的元素：\n    - $d(0,1)=1.2$, $d(0,2)=2.8$, $d(0,3)=2.6$, $d(0,4)=4.0$\n    - $d(1,2)=3.0$, $d(1,3)=2.7$, $d(1,4)=3.9$\n    - $d(2,3)=0.9$, $d(2,4)=3.7$\n    - $d(3,4)=3.8$\n    - 对角线元素 $d(i,i)=0$，对称性 $d(i,j)=d(j,i)$。\n- 情况 B（边界情况，$n=2$）：\n  - 矩阵 $D_B$：\n    - $d(0,1)=1.8$，其中 $d(0,0)=d(1,1)=0$，对称。\n- 情况 C（边缘情况：最小距离相等，$n=4$）：\n  - 矩阵 $D_C$ 的元素：\n    - $d(0,1)=1.0$, $d(2,3)=1.0$\n    - $d(0,2)=2.0$, $d(0,3)=2.2$, $d(1,2)=2.2$, $d(1,3)=2.0$\n    - 对角线元素 $d(i,i)=0$，对称性 $d(i,j)=d(j,i)$。\n\n每种情况所需的输出：\n- 一个合并列表，每个合并的格式为 $[a,b,h,s]$，其中 $h$ 以埃为单位，$s$ 为整数。对于一个包含 $n$ 个项目的情况，输出必须恰好包含 $n-1$ 次合并。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个情况的结果，形式为一个用方括号括起来的逗号分隔列表（例如，$[result_A,result_B,result_C]$），其中每个 $result_\\cdot$ 是相应情况的合并列表。所有数字都必须是不带单位注释的纯数字；高度被理解为以埃为单位。\n\n您的程序必须根据上述基本定义实现 UPGMA 过程；问题陈述中不应引用任何快捷公式。最终答案必须按所述方式呈现，并且必须完全由上述测试套件确定。", "solution": "该问题陈述在科学上是合理的，定义明确，并为非加权组平均法 (UPGMA) 算法提供了完整、无歧义的规范。其验证成功，我将继续提供完整的解决方案。\n\nUPGMA 算法是一种凝聚式层次聚类方法。它从将 $n$ 个项目各自视为一个簇开始。在每一步中，两个最接近的簇被合并成一个新的、更大的簇。这个过程不断重复，直到只剩下一个包含所有 $n$ 个项目的簇。结果是一个有根二叉树，或称树状图，其中的分支长度代表演化或结构距离。UPGMA 假设一个超度量属性，意味着所有叶节点（原始项目）与根节点的距离相等，这对应于一个恒定的变化率（系统发育学中的分子钟假说，或在此指均匀的结构分化）。\n\n该算法的核心包括以下步骤：\n$1$. **初始化**：从 $n$ 个簇开始，每个簇包含一个初始项目。簇的大小为 $|C_i| = 1$，对于 $i \\in \\{0, 1, ..., n-1\\}$。这些初始簇之间的非相似性由输入矩阵 $D$ 给出，其中 $d(i, j)$ 是项目 $i$ 和项目 $j$ 之间的非相似性。\n$2$. **迭代**：重复 $n-1$ 个步骤：\n    a. **寻找最近对**：识别具有最小非相似性 $d(i, j)$ 的活跃簇对 $(i, j)$。问题指定了一个相等情况处理规则：如果多个对共享相同的最小非相似性，则选择其标签 $(a, b)$ 满足 $a < b$ 且在字典序中最靠前的那个对。\n    b. **合并**：将选定的簇 $C_i$ 和 $C_j$ 合并成一个新簇 $C_u$。新簇被分配一个新标签，从 $n$ 开始，每次合并递增。\n    c. **计算高度**：在树状图中代表该合并的节点被放置在共表型高度 $h = d(i, j) / 2$ 处。\n    d. **更新距离**：新簇 $C_u$ 与任何其他现有簇 $C_k$ 之间的非相似性，是根据它们构成成员之间的非相似性算术平均值来计算的。这等效于预先存在的簇间距离的加权平均值：\n    $$d(u, k) = \\frac{|C_i| d(i, k) + |C_j| d(j, k)}{|C_i| + |C_j|}$$\n    e. **更新状态**：原始簇 $C_i$ 和 $C_j$ 从活跃簇集合中移除，新簇 $C_u$ 被加入。新簇的大小为 $|C_u| = |C_i| + |C_j|$。\n$3$. **终止**：当只剩下一个簇时，算法终止。\n\n每次合并所需的输出是一个列表 $[a, b, h, s]$，其中 $a$ 和 $b$ 是被合并簇的标签 ($a < b$)，$h$ 是以埃 (\\AA) 为单位的共表型高度，$s$ 是新簇的大小。\n\n以下是将此过程分步应用于所提供测试用例的过程。\n\n### 情况 A：$n=5$\n初始簇为 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}$，每个大小为 $1$。活跃标签：$\\{0, 1, 2, 3, 4\\}$。下一个标签：$5$。\n距离矩阵 $D_A$:\n$$\n\\begin{pmatrix}\n0.0 & 1.2 & 2.8 & 2.6 & 4.0 \\\\\n1.2 & 0.0 & 3.0 & 2.7 & 3.9 \\\\\n2.8 & 3.0 & 0.0 & 0.9 & 3.7 \\\\\n2.6 & 2.7 & 0.9 & 0.0 & 3.8 \\\\\n4.0 & 3.9 & 3.7 & 3.8 & 0.0\n\\end{pmatrix}\n$$\n\n**第 1 步：**\n- 最小非相似性为 $d(2, 3) = 0.9$。该对是唯一的。\n- 将簇 $2$ 和 $3$ 合并为新簇 $5$。\n- 共表型高度 $h = 0.9 / 2 = 0.45$。新大小 $s = 1+1=2$。\n- 合并记录：$[2, 3, 0.45, 2]$。\n- 更新到簇 $5$ 的距离：\n  - $d(5, 0) = (1 \\cdot d(2, 0) + 1 \\cdot d(3, 0)) / 2 = (2.8 + 2.6) / 2 = 2.7$。\n  - $d(5, 1) = (1 \\cdot d(2, 1) + 1 \\cdot d(3, 1)) / 2 = (3.0 + 2.7) / 2 = 2.85$。\n  - $d(5, 4) = (1 \\cdot d(2, 4) + 1 \\cdot d(3, 4)) / 2 = (3.7 + 3.8) / 2 = 3.75$。\n- 活跃标签：$\\{0, 1, 4, 5\\}$。大小：$|C_0|=1, |C_1|=1, |C_4|=1, |C_5|=2$。\n\n**第 2 步：**\n- 活跃簇的非相似性：$d(0, 1) = 1.2$, $d(0, 4) = 4.0$, $d(0, 5) = 2.7$, $d(1, 4) = 3.9$, $d(1, 5) = 2.85$, $d(4, 5) = 3.75$。\n- 最小值为 $d(0, 1) = 1.2$。\n- 将簇 $0$ 和 $1$ 合并为新簇 $6$。\n- 共表型高度 $h = 1.2 / 2 = 0.6$。新大小 $s = 1+1=2$。\n- 合并记录：$[0, 1, 0.6, 2]$。\n- 更新到簇 $6$ 的距离：\n  - $d(6, 4) = (1 \\cdot d(0, 4) + 1 \\cdot d(1, 4)) / 2 = (4.0 + 3.9) / 2 = 3.95$。\n  - $d(6, 5) = (1 \\cdot d(0, 5) + 1 \\cdot d(1, 5)) / 2 = (2.7 + 2.85) / 2 = 2.775$。\n- 活跃标签：$\\{4, 5, 6\\}$。大小：$|C_4|=1, |C_5|=2, |C_6|=2$。\n\n**第 3 步：**\n- 活跃簇的非相似性：$d(4, 5) = 3.75$, $d(4, 6) = 3.95$, $d(5, 6) = 2.775$。\n- 最小值为 $d(5, 6) = 2.775$。\n- 将簇 $5$ 和 $6$ 合并为新簇 $7$。\n- 共表型高度 $h = 2.775 / 2 = 1.3875$。新大小 $s = 2+2=4$。\n- 合并记录：$[5, 6, 1.3875, 4]$。\n- 更新到簇 $7$ 的距离：\n  - $d(7, 4) = (|C_5| \\cdot d(5, 4) + |C_6| \\cdot d(6, 4)) / (|C_5|+|C_6|) = (2 \\cdot 3.75 + 2 \\cdot 3.95) / 4 = 15.4 / 4 = 3.85$。\n- 活跃标签：$\\{4, 7\\}$。大小：$|C_4|=1, |C_7|=4$。\n\n**第 4 步：**\n- 只剩下一对：$(4, 7)$。非相似性 $d(4, 7) = 3.85$。\n- 将簇 $4$ 和 $7$ 合并为新簇 $8$。\n- 共表型高度 $h = 3.85 / 2 = 1.925$。新大小 $s = 1+4=5$。\n- 合并记录：$[4, 7, 1.925, 5]$。\n- 算法终止。\n\n情况 A 的结果：$[[2, 3, 0.45, 2], [0, 1, 0.6, 2], [5, 6, 1.3875, 4], [4, 7, 1.925, 5]]$\n\n### 情况 B：$n=2$\n初始簇 $\\{0\\}, \\{1\\}$。活跃标签：$\\{0, 1\\}$。\n距离矩阵 $D_B$：$d(0, 1)=1.8$。\n\n**第 1 步：**\n- 只有一对 $(0, 1)$ 存在。\n- 将簇 $0$ 和 $1$ 合并为新簇 $2$。\n- 共表型高度 $h = 1.8 / 2 = 0.9$。新大小 $s = 1+1=2$。\n- 合并记录：$[0, 1, 0.9, 2]$。\n- 算法终止。\n\n情况 B 的结果：$[[0, 1, 0.9, 2]]$\n\n### 情况 C：$n=4$\n初始簇 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}$。活跃标签：$\\{0, 1, 2, 3\\}$。下一个标签：$4$。\n距离矩阵 $D_C$:\n$$\n\\begin{pmatrix}\n0.0 & 1.0 & 2.0 & 2.2 \\\\\n1.0 & 0.0 & 2.2 & 2.0 \\\\\n2.0 & 2.2 & 0.0 & 1.0 \\\\\n2.2 & 2.0 & 1.0 & 0.0\n\\end{pmatrix}\n$$\n\n**第 1 步：**\n- 最小非相似性为 $1.0$，出现于两对：$(0, 1)$ 和 $(2, 3)$。\n- 应用相等情况处理规则，标签对 $(0, 1)$ 在字典序上小于 $(2, 3)$。\n- 将簇 $0$ 和 $1$ 合并为新簇 $4$。\n- 共表型高度 $h = 1.0 / 2 = 0.5$。新大小 $s = 1+1=2$。\n- 合并记录：$[0, 1, 0.5, 2]$。\n- 更新到簇 $4$ 的距离：\n  - $d(4, 2) = (1 \\cdot d(0, 2) + 1 \\cdot d(1, 2)) / 2 = (2.0 + 2.2) / 2 = 2.1$。\n  - $d(4, 3) = (1 \\cdot d(0, 3) + 1 \\cdot d(1, 3)) / 2 = (2.2 + 2.0) / 2 = 2.1$。\n- 活跃标签：$\\{2, 3, 4\\}$。大小：$|C_2|=1, |C_3|=1, |C_4|=2$。\n\n**第 2 步：**\n- 活跃簇的非相似性：$d(2, 3) = 1.0$, $d(2, 4) = 2.1$, $d(3, 4) = 2.1$。\n- 最小值为 $d(2, 3) = 1.0$。\n- 将簇 $2$ 和 $3$ 合并为新簇 $5$。\n- 共表型高度 $h = 1.0 / 2 = 0.5$。新大小 $s = 1+1=2$。\n- 合并记录：$[2, 3, 0.5, 2]$。\n- 更新到簇 $5$ 的距离：\n  - $d(5, 4) = (1 \\cdot d(2, 4) + 1 \\cdot d(3, 4)) / 2 = (2.1 + 2.1) / 2 = 2.1$。\n- 活跃标签：$\\{4, 5\\}$。大小：$|C_4|=2, |C_5|=2$。\n\n**第 3 步：**\n- 只剩下一对：$(4, 5)$。非相似性 $d(4, 5) = 2.1$。\n- 将簇 $4$ 和 $5$ 合并为新簇 $6$。\n- 共表型高度 $h = 2.1 / 2 = 1.05$。新大小 $s = 2+2=4$。\n- 合并记录：$[4, 5, 1.05, 4]$。\n- 算法终止。\n\n情况 C 的结果：$[[0, 1, 0.5, 2], [2, 3, 0.5, 2], [4, 5, 1.05, 4]]$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef upgma(D):\n    \"\"\"\n    Implements the UPGMA algorithm based on fundamental definitions.\n\n    Args:\n        D (np.ndarray): A symmetric n x n dissimilarity matrix.\n\n    Returns:\n        list: A list of n-1 merge events. Each event is a list\n              [label1, label2, height, size].\n    \"\"\"\n    n = D.shape[0]\n    if n = 1:\n        return []\n\n    # Initialize active clusters, their sizes, and the distance matrix representation\n    active_labels = set(range(n))\n    cluster_sizes = {i: 1 for i in range(n)}\n    # Using a dictionary for the distance matrix allows for\n    # easy addition and removal of clusters by label.\n    dist_matrix = {i: {j: D[i, j] for j in range(n)} for i in range(n)}\n    \n    next_label = n\n    merges = []\n\n    # There will be exactly n-1 merges\n    for _ in range(n - 1):\n        # Find the pair of active clusters with the minimum dissimilarity\n        min_dist = float('inf')\n        best_pair = None\n        \n        # To enforce the lexicographical tie-breaking rule, we must iterate\n        # through pairs of labels in a sorted, deterministic order.\n        sorted_labels = sorted(list(active_labels))\n        for i in range(len(sorted_labels)):\n            for j in range(i + 1, len(sorted_labels)):\n                label1 = sorted_labels[i]\n                label2 = sorted_labels[j]\n                \n                d = dist_matrix[label1][label2]\n                if d  min_dist:\n                    min_dist = d\n                    best_pair = (label1, label2)\n                # Tie-breaking rule from problem statement: choose lexicographically\n                # smallest ordered pair of labels. This is automatically handled\n                # by iterating through sorted_labels and only updating on strict\n                # improvement, but an explicit check makes it robust.\n                # However, the problem C requires a tie to be broken by (0,1) vs (2,3),\n                # which means we must compare the pairs themselves.\n                elif d == min_dist:\n                    if best_pair is None or (label1, label2)  best_pair:\n                        best_pair = (label1, label2)\n        \n        a, b = best_pair\n        \n        # Record the merge event\n        height = min_dist / 2.0\n        size_a = cluster_sizes[a]\n        size_b = cluster_sizes[b]\n        new_size = size_a + size_b\n        merges.append([a, b, height, new_size])\n        \n        # Create the new cluster\n        new_label = next_label\n        \n        # Calculate distances from the new cluster to all other active clusters\n        # using the fundamental UPGMA formula.\n        new_distances = {}\n        for k in active_labels:\n            if k != a and k != b:\n                # Distances are symmetric, no need to check order\n                dist_ak = dist_matrix[a][k]\n                dist_bk = dist_matrix[b][k]\n                new_dist = (size_a * dist_ak + size_b * dist_bk) / (size_a + size_b)\n                new_distances[k] = new_dist\n        \n        # Update the set of active clusters\n        active_labels.remove(a)\n        active_labels.remove(b)\n        \n        # Update the distance matrix representation: remove old clusters\n        del dist_matrix[a]\n        del dist_matrix[b]\n        for k in dist_matrix:\n            del dist_matrix[k][a]\n            del dist_matrix[k][b]\n\n        # Add the new cluster to the distance matrix\n        dist_matrix[new_label] = new_distances\n        for k, d_val in new_distances.items():\n            dist_matrix[k][new_label] = d_val\n        dist_matrix[new_label][new_label] = 0.0\n\n        # Update cluster metadata\n        active_labels.add(new_label)\n        cluster_sizes[new_label] = new_size\n        next_label += 1\n        \n    return merges\n\ndef format_result(data):\n    \"\"\"\n    Custom JSON-like formatter to produce output without spaces.\n    \"\"\"\n    if isinstance(data, list):\n        return f\"[{','.join(format_result(item) for item in data)}]\"\n    if isinstance(data, float):\n        # Format float to remove trailing .0 and handle precision as default\n        return f\"{data:.16f}\".rstrip('0').rstrip('.') if '.' in f\"{data:.16f}\" else f\"{data}\"\n    return str(data)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general, n=5)\n        np.array([\n            [0.0, 1.2, 2.8, 2.6, 4.0],\n            [1.2, 0.0, 3.0, 2.7, 3.9],\n            [2.8, 3.0, 0.0, 0.9, 3.7],\n            [2.6, 2.7, 0.9, 0.0, 3.8],\n            [4.0, 3.9, 3.7, 3.8, 0.0]\n        ]),\n        # Case B (boundary, n=2)\n        np.array([\n            [0.0, 1.8],\n            [1.8, 0.0]\n        ]),\n        # Case C (edge: ties in minimal distances, n=4)\n        np.array([\n            [0.0, 1.0, 2.0, 2.2],\n            [1.0, 0.0, 2.2, 2.0],\n            [2.0, 2.2, 0.0, 1.0],\n            [2.2, 2.0, 1.0, 0.0]\n        ])\n    ]\n\n    results = []\n    for D in test_cases:\n        result = upgma(D)\n        results.append(result)\n\n    # The final print statement produces a single line in the exact required format.\n    # The default str() for lists includes spaces, which is not desired.\n    # json.dumps provides a compact representation.\n    # Use separators=(',',':') to match the required output format exactly.\n    print(json.dumps(results, separators=(',', ':')))\n\nsolve()\n```", "id": "2439017"}, {"introduction": "构建了 UPGMA 树之后，一个关键的科学问题是：这棵树在多大程度上真实地反映了原始数据？本练习将引导你探索“扭曲度”这一概念，即 UPGMA 强制施加的超度量约束与原始距离之间的差异。通过计算共表型距离 (cophenetic distance) 并量化其与原始距离的偏差，你将学会评估模型与数据的拟合优度，这是任何数据科学家都必须具备的批判性思维能力 [@problem_id:2438994]。", "problem": "要求您设计并实现一个算法程序，该程序使用非加权对组平均法（UPGMA）从给定的对称成对距离矩阵中重构一棵超度量树，并量化非超度量输入矩阵如何在推断的枝长中引起畸变。目标是从第一性原理出发，从度量空间和超度量空间的基本定义以及定义UPGMA的聚类平均规则开始，而不依赖任何预封装的黑箱程序。\n\n用作基本依据的定义：\n- 有限分类单元集合上的距离矩阵是一个函数 $d : X \\times X \\to \\mathbb{R}_{\\ge 0}$，该函数是对称的，对所有 $x \\in X$ 满足 $d(x,x) = 0$，并且对所有 $x,y,z \\in X$ 满足三角不等式 $d(x,z) \\le d(x,y) + d(y,z)$。\n- 超度量是一种距离函数，除了上述性质外，还满足强三角不等式：对于 $X$ 中的所有 $x,y,z$，在 $d(x,y)$、$d(x,z)$ 和 $d(y,z)$ 中，两个最大的值相等。\n- 非加权对组平均法（UPGMA）通过迭代地将两个最近的聚类进行聚类，并将其合并节点的高度设为它们聚类间距离的一半来构建一棵有根超度量树。设 $C_{i}$ 和 $C_{j}$ 是两个大小分别为 $|C_{i}|$ 和 $|C_{j}|$ 的聚类，它们在距离 $D(C_{i},C_{j})$ 处合并。新节点的高度为 $h = D(C_{i},C_{j})/2$，对于任何其他聚类 $C_{k}$，新距离通过算术平均值更新\n$$\nD(C_{i}\\cup C_{j}, C_{k}) \\;=\\; \\frac{|C_{i}| \\, D(C_{i},C_{k}) + |C_{j}| \\, D(C_{j},C_{k})}{|C_{i}| + |C_{j}|}.\n$$\n- 由一棵超度量树导出的共表型距离是成对距离 $u(x,y)$，它等于构建的树中 $x$ 和 $y$ 的最近共同祖先高度的两倍。等价地，在 UPGMA 方法中，如果 $x \\in C_{i}$ 和 $y \\in C_{j}$ 首次在距离 $D(C_{i},C_{j})$ 处合并，则 $u(x,y) = D(C_{i},C_{j})$。\n- 定义一个枝长畸变指数，作为原始距离与 UPGMA 树的共表型距离之间的平均绝对偏差：\n$$\n\\Delta \\;=\\; \\frac{2}{n(n-1)} \\sum_{1 \\le i  j \\le n} \\left| d(i,j) - u(i,j) \\right|\n$$\n其中 $n$ 是分类单元的数量，求和是对所有无序对进行的。\n\n您的程序必须：\n- 从第一性原理出发实现 UPGMA，使用上述的算术平均更新规则，并在每次合并时为该合并所连接的所有叶节点交叉对分配 $u(i,j)$。如果最小聚类间距离出现相等的情况，则通过在当前工作顺序中选择字典序最小的聚类索引对（即，选择最小的 $i$ 然后是最小的 $j  i$）来确定性地打破平局。\n- 对于下面的每个测试用例，计算共表型距离矩阵 $u(\\cdot,\\cdot)$，然后计算上面定义的 $\\Delta$，并将其作为四舍五入到 $6$ 位小数的浮点数返回。\n\n测试套件（矩阵按分类单元顺序列出，所有值均为无单位距离）：\n- 测试用例 $1$（明确地是非超度量的，$5$ 个分类单元）：\n$$\nD_{1} \\;=\\;\n\\begin{pmatrix}\n0  4  6  6  7 \\\\\n4  0  8  8  9 \\\\\n6  8  0  4  7 \\\\\n6  8  4  0  7 \\\\\n7  9  7  7  0 \\\\\n\\end{pmatrix}.\n$$\n- 测试用例 $2$（超度量的，$4$ 个分类单元）：\n$$\nD_{2} \\;=\\;\n\\begin{pmatrix}\n0  2  6  6 \\\\\n2  0  6  6 \\\\\n6  6  0  3 \\\\\n6  6  3  0 \\\\\n\\end{pmatrix}.\n$$\n- 测试用例 $3$（平局边界，$3$ 个分类单元，所有距离相等）：\n$$\nD_{3} \\;=\\;\n\\begin{pmatrix}\n0  4  4 \\\\\n4  0  4 \\\\\n4  4  0 \\\\\n\\end{pmatrix}.\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果列表，按顺序排列，形式为用方括号括起来的逗号分隔列表，每个值都精确到小数点后 $6$ 位。例如，输出必须是\n$[x_{1},x_{2},x_{3}]$\n的形式，其中每个 $x_{k}$ 是一个渲染为小数点后恰好 $6$ 位数字的浮点数。", "solution": "我们从超度量的定义开始：有限集 $X$ 上的距离函数 $d$ 是超度量的，如果对于所有 $x,y,z \\in X$，$d(x,y)$、$d(x,z)$ 和 $d(y,z)$ 中两个最大的值相等。非加权对组平均法（UPGMA）通过迭代地合并最近的聚类对，并使用算术平均值来定义与新形成聚类的距离，从而构建一棵有根超度量树。该方法假设存在分子钟样条件（相等的演化速率），因此所有叶节点都在相同的高度结束，故即使输入不是超度量的，输出也是超度量的。\n\n从第一性原理出发的算法设计：\n- 将每个分类单元初始化为高度为 $0$ 的单例聚类。维护一个活跃聚类的集合，每个聚类包含其原始成员的索引和大小。\n- 在每次迭代中，找到使聚类间距离 $D(C_{i}, C_{j})$ 最小化的不同聚类对 $(C_{i}, C_{j})$。如果存在相等情况，通过索引的字典序确定性地打破平局，以确保可复现性。\n- 创建一个新聚类 $C_{u} = C_{i} \\cup C_{j}$。对于每一对满足 $x \\in C_{i}$ 和 $y \\in C_{j}$ 的 $(x,y)$，指定共表型距离 $u(x,y) = D(C_{i},C_{j})$。\n- 对于每个剩余的聚类 $C_{k}$，通过算术平均值更新聚类间距离：\n$$\nD(C_{u},C_{k}) \\;=\\; \\frac{|C_{i}| \\, D(C_{i},C_{k}) + |C_{j}| \\, D(C_{j},C_{k})}{|C_{i}|+|C_{j}|}.\n$$\n- 从活跃集合中移除 $C_{i}$ 和 $C_{j}$，并加入 $C_{u}$。重复此过程，直到只剩下一个聚类。\n- 完整的共表型矩阵 $u(\\cdot,\\cdot)$ 是通过在每个合并步骤中按所述方式填充条目而组合而成的。\n\n对于每个具有 $n$ 个分类单元的测试用例，定义畸变指数\n$$\n\\Delta \\;=\\; \\frac{2}{n(n-1)} \\sum_{1 \\le i  j \\le n} \\left| d(i,j) - u(i,j) \\right|.\n$$\n这量化了原始成对距离与 UPGMA 树所蕴含的超度量距离之间的平均绝对偏差。\n\n测试套件的手动分析：\n\n- **测试用例 1**：\n矩阵 $D_{1}$ 是非超度量的。我们将严格遵循带字典序平局打破规则的 UPGMA 算法。\n    - **第1步**: 最小距离为 $4$，存在于对 $(0,1)$ 和 $(2,3)$。根据字典序规则，选择 $(0,1)$。合并 $\\{0\\}$ 和 $\\{1\\}$ 为聚类 $C_5$。$u(0,1) = 4$。活跃聚类为 $\\{2\\}, \\{3\\}, \\{4\\}, C_5$。\n    - **第2步**: 更新距离。$d(C_5, 2)=(6+8)/2=7$，$d(C_5, 3)=(6+8)/2=7$，$d(C_5, 4)=(7+9)/2=8$。当前距离中最小的是 $d(2,3)=4$。合并 $\\{2\\}$ 和 $\\{3\\}$ 为 $C_6$。$u(2,3) = 4$。活跃聚类为 $\\{4\\}, C_5, C_6$。\n    - **第3步**: 更新距离。$d(C_5, C_6)=(d(C_5,2)+d(C_5,3))/2=(7+7)/2=7$。$d(C_6, 4)=(d(2,4)+d(3,4))/2=(7+7)/2=7$。$d(C_5, 4)=8$。最小距离为 $7$，存在于对 $(C_5, C_6)$ 和 $(C_6, \\{4\\})$。聚类标签为 4, 5, 6。平局对为 $(4,6)$ 和 $(5,6)$。字典序最小的是 $(4,6)$。合并 $\\{4\\}$ 和 $C_6$ 为 $C_7$。$u(4,2)=7, u(4,3)=7$。活跃聚类为 $C_5, C_7$。\n    - **第4步**: 更新距离。$d(C_5, C_7) = (|C_6| d(C_5, C_6) + |\\{4\\}| d(C_5, 4)) / (|C_6|+|\\{4\\}|) = (2 \\cdot 7 + 1 \\cdot 8) / 3 = 22/3$。合并 $C_5$ 和 $C_7$。所有剩余未定义的 $u(i,j)$ 都设为 $22/3$。\n    - **计算偏差**:\n      $u(0,1)=4, u(2,3)=4, u(2,4)=7, u(3,4)=7$。\n      $u(0,2)=u(0,3)=u(0,4)=u(1,2)=u(1,3)=u(1,4)=22/3 \\approx 7.333$。\n      绝对偏差 $|d-u|$ 之和为：\n      $|4-4|+|4-4|+|6-22/3|+|6-22/3|+|7-22/3|+|8-22/3|+|8-22/3|+|9-22/3|+|7-7|+|7-7| = 0+0+4/3+4/3+1/3+2/3+2/3+5/3+0+0 = 18/3 = 6$。\n      $\\Delta_{1} = 6.0 / \\binom{5}{2} = 6.0 / 10 = 0.6$。\n\n- **测试用例 2**：\n矩阵 $D_{2}$ 是超度量的。对于超度量输入，UPGMA 会精确重构距离，因此 $u(i,j) = d(i,j)$ 对所有 $i,j$ 成立。因此，畸变指数 $\\Delta_{2} = 0.0$。\n\n- **测试用例 3**：\n矩阵 $D_{3}$ 也是超度量的（所有非零距离相等）。同样，UPGMA 会得到 $u(i,j) = d(i,j)$，因此 $\\Delta_{3} = 0.0$。\n\n因此，畸变指数四舍五入到六位小数为 $[0.600000, 0.000000, 0.000000]$。测试用例 $1$ 中的非超度量输入迫使 UPGMA 压缩和扩展某些分类单元间的距离以拟合超度量结构，从而产生非零的平均绝对偏差，而测试用例 $2$ 和 $3$ 中的超度量输入则如该方法的假设所预期的那样，产生零畸变。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef upgma_cophenetic(dist_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute the UPGMA cophenetic distance matrix for a given symmetric distance matrix.\n    Tie-breaking: choose the lexicographically smallest pair of cluster IDs.\n    \n    Parameters:\n        dist_matrix: numpy array of shape (n, n), symmetric with zeros on the diagonal.\n    Returns:\n        cophenetic_matrix: numpy array of shape (n, n) with ultrametric cophenetic distances.\n    \"\"\"\n    n = dist_matrix.shape[0]\n    \n    # Store clusters by their ID. Initially, 0 to n-1.\n    clusters = {i: {'leaves': {i}, 'size': 1} for i in range(n)}\n    \n    # Use a dictionary for distances, keyed by cluster IDs.\n    D = {i: {j: dist_matrix[i, j] for j in range(n)} for i in range(n)}\n    \n    # The set of currently active cluster IDs.\n    active_clusters = set(range(n))\n    \n    next_cluster_id = n\n    cophenetic_matrix = np.zeros((n, n), dtype=float)\n\n    while len(active_clusters) > 1:\n        min_dist = float('inf')\n        best_pair = None\n        \n        # Iterate through sorted active cluster IDs to find the lexicographically smallest pair.\n        sorted_active_ids = sorted(list(active_clusters))\n        for i in range(len(sorted_active_ids)):\n            for j in range(i + 1, len(sorted_active_ids)):\n                id1, id2 = sorted_active_ids[i], sorted_active_ids[j]\n                d = D[id1][id2]\n                if d  min_dist:\n                    min_dist = d\n                    best_pair = (id1, id2)\n                elif d == min_dist:\n                    # Explicit tie-breaking on cluster ID pair\n                    if best_pair is None or (id1, id2)  best_pair:\n                        best_pair = (id1, id2)\n        \n        id_a, id_b = best_pair\n        \n        # Fill cophenetic distances for all pairs between the two merged clusters\n        leaves_a = clusters[id_a]['leaves']\n        leaves_b = clusters[id_b]['leaves']\n        for leaf_a in leaves_a:\n            for leaf_b in leaves_b:\n                cophenetic_matrix[leaf_a, leaf_b] = min_dist\n                cophenetic_matrix[leaf_b, leaf_a] = min_dist\n\n        # Create the new cluster\n        new_id = next_cluster_id\n        size_a = clusters[id_a]['size']\n        size_b = clusters[id_b]['size']\n        \n        clusters[new_id] = {\n            'leaves': leaves_a.union(leaves_b),\n            'size': size_a + size_b\n        }\n        \n        # Calculate new distances from the merged cluster to others\n        new_distances = {}\n        for other_id in active_clusters:\n            if other_id != id_a and other_id != id_b:\n                dist_a_other = D[id_a][other_id]\n                dist_b_other = D[id_b][other_id]\n                new_dist = (size_a * dist_a_other + size_b * dist_b_other) / (size_a + size_b)\n                new_distances[other_id] = new_dist\n        \n        # Update the distance dictionary and active clusters\n        active_clusters.remove(id_a)\n        active_clusters.remove(id_b)\n        \n        del D[id_a]\n        del D[id_b]\n        for k in D:\n            del D[k][id_a]\n            del D[k][id_b]\n\n        D[new_id] = new_distances\n        for k, d_val in new_distances.items():\n            D[k][new_id] = d_val\n        D[new_id][new_id] = 0.0\n\n        active_clusters.add(new_id)\n        next_cluster_id += 1\n\n    return cophenetic_matrix\n\ndef mean_absolute_distortion(original: np.ndarray, cophenetic: np.ndarray) -> float:\n    n = original.shape[0]\n    total_abs_dev = np.sum(np.abs(original - cophenetic))\n    # Each pair is counted twice (d(i,j) and d(j,i)), and diagonal is 0.\n    num_pairs = n * (n - 1)\n    return total_abs_dev / num_pairs if num_pairs > 0 else 0.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    D1 = np.array([\n        [0., 4., 6., 6., 7.],\n        [4., 0., 8., 8., 9.],\n        [6., 8., 0., 4., 7.],\n        [6., 8., 4., 0., 7.],\n        [7., 9., 7., 7., 0.]\n    ], dtype=float)\n\n    D2 = np.array([\n        [0., 2., 6., 6.],\n        [2., 0., 6., 6.],\n        [6., 6., 0., 3.],\n        [6., 6., 3., 0.]\n    ], dtype=float)\n\n    D3 = np.array([\n        [0., 4., 4.],\n        [4., 0., 4.],\n        [4., 4., 0.]\n    ], dtype=float)\n\n    test_cases = [D1, D2, D3]\n\n    results = []\n    for D in test_cases:\n        U = upgma_cophenetic(D)\n        # The problem defines the sum over unique pairs i  j, so we divide by n(n-1)/2\n        n = D.shape[0]\n        count = n * (n - 1) / 2\n        sum_abs_dev = np.sum(np.abs(np.triu(D - U, k=1)))\n        mae = sum_abs_dev / count if count > 0 else 0.0\n        results.append(f\"{mae:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2438994"}, {"introduction": "真正的理解不仅在于应用，更在于能够创造性地修改和分析方法。这个高级练习将挑战你像算法开发者一样思考，将 UPGMA 核心的算术平均更新规则替换为几何平均。通过推导、实现并比较这两种方法的差异，你将深入洞察算法设计的核心——一个基础假设的改变如何深刻影响最终的树拓扑及其数学特性 [@problem_id:2439048]。", "problem": "要求您在小规模的固定测试实例上，实现并比较非加权类平均法（Unweighted Pair Group Method with Arithmetic Mean, UPGMA）层次聚类方法的两种变体。您的比较必须从类间非相似度和均值聚合的基础定义推导得出，且不得依赖任何记忆的公式。仅使用从第一性原理出发的逻辑推导。\n\n基本依据和定义：\n- 设 $D \\in \\mathbb{R}^{n \\times n}$ 为一个对称非相似度矩阵，对所有 $i$ 满足 $D[i,i] = 0$，且对于 $i \\neq j$ 具有严格为正的非对角线元素 $D[i,j] \\in \\mathbb{R}_{0}$。UPGMA方法通过迭代地合并当前非相似度最小的一对类 $(A,B)$ 来构建一个有根的、超度量的树状图。\n- 对于任意两个基数为 $|X|$ 和 $|Y|$ 的非空不相交类簇 $X$ 和 $Y$，算术平均类间距离是 $X$ 中元素与 $Y$ 中元素之间所有成对非相似度的均值，即多重集 $\\{ D[x,y] \\mid x \\in X, y \\in Y \\}$ 的平均值。类似地，几何平均类间距离是同一多重集的几何平均值。这些定义在聚类的每个阶段都适用，用于计算新形成的类与任何其他现有类之间的非相似度。您必须推导出这些定义如何导出一个仅依赖于已有的类间非相似度和类的大小、而无需枚举单个元素的递归更新公式。\n- 在每次合并类 $A$ 和 $B$ 时，分配给新内部节点的高度是 $A$ 和 $B$ 合并时非相似度的一半。这种构造在叶节点集合上导出一个超度量，其中，两个叶节点之间的共表型距离（cophenetic distance）定义为其最近共同祖先（least common ancestor）高度的两倍。\n\n任务：\n1) 仅根据上述定义，为UPGMA算术平均变体推导一个闭式递归更新公式，用于计算新类 $C = A \\cup B$ 与任何其他现存类 $Z$ 之间的距离。该公式需用 $|A|$、$|B|$、当前 $A$ 与 $Z$ 之间的距离、$B$ 与 $Z$ 之间的距离以及类的大小 $|Z|$ 来表示。您的更新公式中不得枚举 $A$、$B$ 或 $Z$ 的单个元素。\n2) 类似地，为UPGMA几何平均变体推导一个闭式递归更新公式，该公式需与上面给出的几何平均定义一致，且仅依赖于 $|A|$、$|B|$、当前 $A$ 与 $Z$ 之间的距离、$B$ 与 $Z$ 之间的距离以及类的大小 $|Z|$。确保您的推导仅使用对严格正实数有效的对数和几何平均的性质。\n3) 实现这两种变体，使得在每次迭代中您：\n   - 选择使当前距离最小化的不同类的无序对 $(i,j)$，并采用确定性的决胜规则（tie-break）：如果有多对类在容差 $\\varepsilon = 10^{-12}$ 内达到相同的最小值，则选择字典序最小的索引对 $(i,j)$，其中 $i  j$ 且类标识符为整数。\n   - 创建一个新类，其标识符等于下一个未使用的整数，其叶节点集是合并类的叶节点集的并集，其高度是合并时非相似度的一半。\n   - 使用相应的推导出的更新规则，更新到所有其他类的距离。\n4) 对于生成的每棵树，计算：\n   - 合并高度的序列。\n   - 一个布尔值，报告合并高度序列在容差 $\\varepsilon = 10^{-12}$ 内是否非递减。\n   - 根高度（最后一次合并的高度）。\n   - 拓扑结构，表示为合并的有序列表，其中每次合并记录为两个被合并的叶索引集的有序对，每个集合表示为叶索引的排序列表，并且合并中的两个列表按字典序排序以使该对规范化。\n   - 共表型距离矩阵（针对索引为 $0$ 到 $n-1$ 的叶节点），其中一对叶节点的条目等于该对首次合并时高度的两倍。\n\nUPGMA算术平均法与几何平均法之间的影响度量：\n- 对于每个测试实例，计算：\n  - 一个布尔值，指示两种拓扑结构（作为有序合并序列）是否相同。\n  - 一个布尔值，指示UPGMA算术平均法的合并高度是否非递减。\n  - 一个布尔值，指示UPGMA几何平均法的合并高度是否非递减。\n  - UPGMA算术平均法的根高度，四舍五入到 $6$ 位小数。\n  - UPGMA几何平均法的根高度，四舍五入到 $6$ 位小数。\n  - 两个共表型距离矩阵之差的Frobenius范数（欧几里得矩阵范数），四舍五入到 $6$ 位小数。\n\n角度或物理单位不适用。所有距离都是无量纲的实数。\n\n测试套件和决胜规则：\n- 使用以下三个对称非相似度矩阵，叶索引按行/列顺序为 $0,1,2,\\dots$，且非对角线元素严格为正。\n  - 测试用例 $1$ ($n=4$):\n    $$\n    D^{(1)} =\n    \\begin{pmatrix}\n    0  0.1  0.7  0.75 \\\\\n    0.1  0  0.72  0.78 \\\\\n    0.7  0.72  0  0.12 \\\\\n    0.75  0.78  0.12  0\n    \\end{pmatrix}.\n    $$\n  - 测试用例 $2$ ($n=5$):\n    $$\n    D^{(2)} =\n    \\begin{pmatrix}\n    0  0.2  0.21  1.6  1.6 \\\\\n    0.2  0  4.0  1.6  1.6 \\\\\n    0.21  4.0  0  1.5  1.5 \\\\\n    1.6  1.6  1.5  0  0.3 \\\\\n    1.6  1.6  1.5  0.3  0\n    \\end{pmatrix}.\n    $$\n  - 测试用例 $3$ ($n=4$):\n    $$\n    D^{(3)} =\n    \\begin{pmatrix}\n    0  1.0  1.0  1.0 \\\\\n    1.0  0  1.0  1.000001 \\\\\n    1.0  1.0  0  1.000002 \\\\\n    1.0  1.000001  1.000002  0\n    \\end{pmatrix}.\n    $$\n- 在每个选择步骤中，使用容差 $\\varepsilon = 10^{-12}$ 进行平局检测，并根据类标识符对 $(i,j)$（其中 $ij$）的字典序来打破平局。\n\n最终输出格式：\n- 您的程序必须生成单行输出，该输出包含一个长度为 $3$ 的Python风格列表（每个条目对应一个测试用例），其中每个条目是一个长度为 $6$ 的列表，按顺序包含：\n  $[\\text{相同拓扑结构}, \\text{算术法单调性}, \\text{几何法单调性}, \\text{算术法根高度}, \\text{几何法根高度}, \\text{共表型L2范数}]$。\n- 布尔值必须是Python布尔值（即 $True$ 或 $False$）。浮点数必须按规定四舍五入到 $6$ 位小数。输出必须只有一行，例如：\n  $[[\\dots],[\\dots],[\\dots]]$.", "solution": "问题陈述已解析和验证。所有给定条件均已提取，问题被确认为具有科学依据、适定、客观且完整。这是一个计算生物学中标准的、尽管详细的算法问题，没有任何概念或事实上的缺陷。因此，有必要提供一个解决方案。\n\n问题的核心在于，针对非加权类平均法（Unweighted Pair Group Method with Arithmetic Mean, UPGMA）算法的两种变体，推导并实现用于定义类间非相似度的递归更新规则，其中一个变体基于算术平均，另一个基于几何平均。\n\n### 1. UPGMA算术平均法更新规则的推导\n\n设两个不相交的类 $A$ 和 $B$ 合并成一个新类 $C = A \\cup B$。设 $Z$ 是与 $C$ 不相交的任何其他现有类。$C$ 和 $Z$ 之间的非相似度，记为 $d_{AM}(C, Z)$，定义为其构成元素之间所有成对非相似度的算术平均值。\n根据定义：\n$$\nd_{AM}(C, Z) = d_{AM}(A \\cup B, Z) = \\frac{1}{|C| |Z|} \\sum_{c \\in C} \\sum_{z \\in Z} D[c, z]\n$$\n其中 $|C| = |A| + |B|$，$D[c, z]$ 是叶元素 $c$ 和 $z$ 之间的初始非相似度。\n\n由于 $C$ 是 $A$ 和 $B$ 的不相交并集，求和可以分解为：\n$$\n\\sum_{c \\in C} \\sum_{z \\in Z} D[c, z] = \\sum_{a \\in A} \\sum_{z \\in Z} D[a, z] + \\sum_{b \\in B} \\sum_{z \\in Z} D[b, z]\n$$\n\n根据类间算术平均距离的定义，对于当前的非相似度 $d_{AM}(A, Z)$ 和 $d_{AM}(B, Z)$，我们有以下恒等式：\n$$\n\\sum_{a \\in A} \\sum_{z \\in Z} D[a, z] = |A| |Z| \\cdot d_{AM}(A, Z)\n$$\n$$\n\\sum_{b \\in B} \\sum_{z \\in Z} D[b, z] = |B| |Z| \\cdot d_{AM}(B, Z)\n$$\n\n将这些代入 $d_{AM}(C, Z)$ 的表达式中：\n$$\nd_{AM}(C, Z) = \\frac{1}{(|A| + |B|) |Z|} \\left( |A| |Z| \\cdot d_{AM}(A, Z) + |B| |Z| \\cdot d_{AM}(B, Z) \\right)\n$$\n\n$|Z|$ 项代表外部类的基数，并且很明显，它可以从表达式中消去。这是“非加权”类平均法的一个决定性特征，因为更新独立于未参与合并的类的属性。最终得到的闭式递归更新公式是：\n$$\nd_{AM}(A \\cup B, Z) = \\frac{|A| \\cdot d_{AM}(A, Z) + |B| \\cdot d_{AM}(B, Z)}{|A| + |B|}\n$$\n该公式表明，新的非相似度是先前非相似度的加权算术平均值，其权重与合并类的大小成正比。\n\n### 2. UPGMA几何平均法更新规则的推导\n\n类似地，我们推导几何平均变体的更新规则。非相似度 $d_{GM}(C, Z)$ 定义为成对非相似度的几何平均值。问题规定初始矩阵 $D$ 的所有非对角线元素都严格为正，这确保了几何平均值是良定义且为正的。\n根据定义：\n$$\nd_{GM}(C, Z) = d_{GM}(A \\cup B, Z) = \\left( \\prod_{c \\in C} \\prod_{z \\in Z} D[c, z] \\right)^{\\frac{1}{|C| |Z|}}\n$$\n和之前一样，我们对不相交并集 $C = A \\cup B$ 上的乘积进行分解：\n$$\n\\prod_{c \\in C} \\prod_{z \\in Z} D[c, z] = \\left( \\prod_{a \\in A} \\prod_{z \\in Z} D[a, z] \\right) \\cdot \\left( \\prod_{b \\in B} \\prod_{z \\in Z} D[b, z] \\right)\n$$\n根据几何平均距离的定义，我们有：\n$$\n\\prod_{a \\in A} \\prod_{z \\in Z} D[a, z] = \\left( d_{GM}(A, Z) \\right)^{|A| |Z|}\n$$\n$$\n\\prod_{b \\in B} \\prod_{z \\in Z} D[b, z] = \\left( d_{GM}(B, Z) \\right)^{|B| |Z|}\n$$\n将这些代入 $d_{GM}(C, Z)$ 的表达式中：\n$$\nd_{GM}(C, Z) = \\left( \\left( d_{GM}(A, Z) \\right)^{|A| |Z|} \\cdot \\left( d_{GM}(B, Z) \\right)^{|B| |Z|} \\right)^{\\frac{1}{(|A| + |B|) |Z|}}\n$$\n使用指数性质 $(x^p y^q)^r = x^{pr} y^{qr}$，我们简化得到：\n$$\nd_{GM}(C, Z) = \\left( d_{GM}(A, Z) \\right)^{\\frac{|A| |Z|}{(|A| + |B|) |Z|}} \\cdot \\left( d_{GM}(B, Z) \\right)^{\\frac{|B| |Z|}{(|A| + |B|) |Z|}}\n$$\n$|Z|$ 项被消去，得到递归更新规则：\n$$\nd_{GM}(A \\cup B, Z) = \\left( d_{GM}(A, Z) \\right)^{\\frac{|A|}{|A| + |B|}} \\cdot \\left( d_{GM}(B, Z) \\right)^{\\frac{|B|}{|A| + |B|}}\n$$\n这是一个加权几何平均。为了计算稳定性，特别是在有许多类的情况下，使用对数更优越。对两边取自然对数：\n$$\n\\ln \\left( d_{GM}(A \\cup B, Z) \\right) = \\frac{|A|}{|A| + |B|} \\ln \\left( d_{GM}(A, Z) \\right) + \\frac{|B|}{|A| + |B|} \\ln \\left( d_{GM}(B, Z) \\right)\n$$\n这表明，在对数空间中，几何平均变体的更新规则在形式上与线性空间中的算术平均变体相同。\n\n### 3. 算法实现与分析\n\n实现遵循基于所推导更新规则的标准凝聚式聚类方案。\n1.  **初始化**：从 $n$ 个单例类开始，每个类对应一个叶节点。初始类间距离由输入矩阵 $D$ 给出。必须维护一个活动类的记录。\n2.  **迭代**：算法进行 $n-1$ 步。在每一步中：\n    a.  **选择**：找出具有最小非相似度 $d(A, B)$ 的一对不同活动类 $(A, B)$。问题指定了一个严格的确定性决胜规则：如果多对类共享最小距离（在容差 $\\varepsilon = 10^{-12}$ 内），则选择字典序最小的索引对 $(i, j)$，其中 $i  j$。\n    b.  **合并**：将选定的类 $A$ 和 $B$ 合并成一个新类 $C$。记录合并事件，包括叶节点集和合并高度，定义为 $h = d(A, B)/2$。按步骤排序的合并事件列表定义了树的拓扑结构。\n    c.  **距离更新**：使用相应的推导出的递归公式计算从新类 $C$ 到每个其他活动类 $Z$ 的非相似度。\n    d.  **共表型距离**：来自 $A$ 的任何叶节点与来自 $B$ 的任何叶节点之间的共表型距离是它们的合并非相似度 $d(A, B)$。该值记录在共表型距离矩阵中。\n3.  **终止**：经过 $n-1$ 次合并后，只剩下一个包含所有叶节点的类（根），过程终止。\n\n最终分析涉及比较两种UPGMA变体的输出。标准（算术平均）UPGMA 的一个关键理论特性是它总能生成一棵超度量树，这意味着合并高度序列必须是非递减的。问题要求对两种变体的这一特性进行经验验证。几何平均变体不保证生成超度量树，任何偏离非递减合并高度的情况都表明违反了超度量不等式。两个所得共表型矩阵之差的Frobenius范数提供了一个定量度量，衡量两种聚类方法在它们施加于数据上的超度量距离方面的差异程度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_upgma(D_orig, method='arithmetic'):\n    \"\"\"\n    Performs UPGMA clustering on a distance matrix.\n\n    Args:\n        D_orig (np.ndarray): A symmetric dissimilarity matrix.\n        method (str): 'arithmetic' or 'geometric'.\n\n    Returns:\n        tuple: A tuple containing:\n            - topology (list): The sequence of merges as sorted leaf sets.\n            - is_monotonic (bool): Whether merge heights were non-decreasing.\n            - root_height (float): The height of the root node.\n            - cophen_matrix (np.ndarray): The cophenetic distance matrix.\n    \"\"\"\n    n = D_orig.shape[0]\n    epsilon = 1e-12\n\n    # In geometric mode, work with log-distances for stability\n    if method == 'geometric':\n        # Add a small value to diagonal to avoid log(0) for matrix operations\n        D_work = np.log(D_orig + np.eye(n))\n    else:\n        D_work = D_orig.copy()\n\n    # clusters[i] = {'size': int, 'leaves': set}\n    clusters = {i: {'size': 1, 'leaves': {i}} for i in range(n)}\n    \n    # Use a dictionary for distances for easy manipulation with non-contiguous IDs\n    dist_dict = {i: {j: D_work[i, j] for j in range(n)} for i in range(n)}\n    \n    active_cluster_ids = set(range(n))\n    next_cluster_id = n\n\n    merge_heights = []\n    topology = []\n    cophen_matrix = np.zeros((n, n))\n\n    for _ in range(n - 1):\n        min_dist = np.inf\n        best_pair = None\n\n        active_list_sorted = sorted(list(active_cluster_ids))\n        for i in range(len(active_list_sorted)):\n            for j in range(i + 1, len(active_list_sorted)):\n                u, v = active_list_sorted[i], active_list_sorted[j]\n                d = dist_dict[u][v]\n                \n                if d  min_dist - epsilon:\n                    min_dist = d\n                    best_pair = (u, v)\n                elif abs(d - min_dist) = epsilon:\n                    if best_pair is None or (u, v)  best_pair:\n                        best_pair = (u, v)\n        \n        A_id, B_id = best_pair\n        \n        # d_merge is in linear space for both methods\n        d_merge = np.exp(min_dist) if method == 'geometric' else min_dist\n        h_merge = d_merge / 2.0\n        merge_heights.append(h_merge)\n        \n        # Create new cluster\n        C_id = next_cluster_id\n        size_A = clusters[A_id]['size']\n        size_B = clusters[B_id]['size']\n        leaves_A = clusters[A_id]['leaves']\n        leaves_B = clusters[B_id]['leaves']\n        \n        new_leaves = leaves_A.union(leaves_B)\n        clusters[C_id] = {'size': size_A + size_B, 'leaves': new_leaves}\n\n        # Record topology\n        list_A = sorted(list(leaves_A))\n        list_B = sorted(list(leaves_B))\n        # Canonical representation of the merge pair\n        topology.append(tuple(sorted((tuple(list_A), tuple(list_B)))))\n\n        # Update cophenetic matrix\n        for la in leaves_A:\n            for lb in leaves_B:\n                cophen_matrix[la, lb] = cophen_matrix[lb, la] = d_merge\n\n        # Calculate distances from new cluster to all other active clusters\n        new_distances = {}\n        for Z_id in active_cluster_ids:\n            if Z_id != A_id and Z_id != B_id:\n                d_AZ = dist_dict[A_id][Z_id]\n                d_BZ = dist_dict[B_id][Z_id]\n                \n                # Formula is the same for both methods (one in linear, one in log space)\n                d_CZ = (size_A * d_AZ + size_B * d_BZ) / (size_A + size_B)\n                new_distances[Z_id] = d_CZ\n        \n        # Update state: remove old clusters, add new one\n        active_cluster_ids.remove(A_id)\n        active_cluster_ids.remove(B_id)\n        active_cluster_ids.add(C_id)\n\n        del dist_dict[A_id]\n        del dist_dict[B_id]\n        for k in dist_dict:\n            del dist_dict[k][A_id]\n            del dist_dict[k][B_id]\n        \n        dist_dict[C_id] = new_distances\n        for k, d_val in new_distances.items():\n            dist_dict[k][C_id] = d_val\n        dist_dict[C_id][C_id] = 0.0\n\n        next_cluster_id += 1\n\n    is_monotonic = all(merge_heights[i] = merge_heights[i+1] + epsilon for i in range(len(merge_heights) - 1))\n    root_height = merge_heights[-1] if merge_heights else 0.0\n\n    return topology, is_monotonic, root_height, cophen_matrix\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        np.array([\n            [0, 0.1, 0.7, 0.75],\n            [0.1, 0, 0.72, 0.78],\n            [0.7, 0.72, 0, 0.12],\n            [0.75, 0.78, 0.12, 0]\n        ]),\n        np.array([\n            [0, 0.2, 0.21, 1.6, 1.6],\n            [0.2, 0, 4.0, 1.6, 1.6],\n            [0.21, 4.0, 0, 1.5, 1.5],\n            [1.6, 1.6, 1.5, 0, 0.3],\n            [1.6, 1.6, 1.5, 0.3, 0]\n        ]),\n        np.array([\n            [0, 1.0, 1.0, 1.0],\n            [1.0, 0, 1.0, 1.000001],\n            [1.0, 1.0, 0, 1.000002],\n            [1.0, 1.000001, 1.000002, 0]\n        ])\n    ]\n\n    all_results = []\n    for D in test_cases:\n        topo_a, mono_a, root_a, cophen_a = run_upgma(D, 'arithmetic')\n        topo_g, mono_g, root_g, cophen_g = run_upgma(D, 'geometric')\n\n        same_topology = (topo_a == topo_g)\n        frobenius_norm = np.linalg.norm(cophen_a - cophen_g, 'fro')\n\n        result_for_case = [\n            same_topology,\n            mono_a,\n            mono_g,\n            round(root_a, 6),\n            round(root_g, 6),\n            round(frobenius_norm, 6)\n        ]\n        all_results.append(result_for_case)\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2439048"}]}