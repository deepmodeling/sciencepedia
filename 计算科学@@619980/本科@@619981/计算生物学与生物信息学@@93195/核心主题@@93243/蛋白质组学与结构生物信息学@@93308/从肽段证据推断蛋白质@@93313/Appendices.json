{"hands_on_practices": [{"introduction": "在蛋白质鉴定中，并非所有的肽段证据都具有同等的价值。独特肽段（unique peptide）为特定蛋白质的存在提供了强有力的支持，而共享肽段（shared peptide）则带来了歧义。这个练习将指导你如何构建一个加权分数，该分数结合了来自这两种肽段的证据，并考虑了每次肽段谱图匹配（PSM）的可靠性，这是评估蛋白质鉴定结果可信度的核心技能 [@problem_id:2420429]。", "problem": "一个蛋白质鉴定工作流程会产生肽段-谱图匹配 (PSMs)，每个匹配都被赋予一个分数，该分数被解释为相应肽段-谱图匹配是正确的后验概率。如果一个肽段只映射到一种蛋白质，则称其为该蛋白质的唯一肽段；如果它映射到多种蛋白质，则称其为共享肽段。设 $S_i \\in [0,1]$ 表示肽段 $i$ 的后验概率，设 $m_i \\in \\{2,3,\\dots\\}$ 表示共享肽段 $i$ 映射到的不同蛋白质的数量。考虑一个由两个不相交的肽段集合支持的蛋白质 $P$：大小为 $N_u$ 的唯一肽段集合 $U(P)$ 和大小为 $N_s$ 的共享肽段集合 $S(P)$。\n\n在以下模型假设下：(i) 每个 $S_i$ 是肽段 $i$ 被正确鉴定的后验概率，(ii) 在给定蛋白质存在的情况下，肽段证据是条件独立的，以及 (iii) 在没有额外信息的情况下，一个共享肽段的证据贡献在其 $m_i$ 个母蛋白之间平均分配，定义一个蛋白质质量分数 $Q(P)$，其值为支持蛋白质 $P$ 的正确鉴定肽段的期望有效计数，其中唯一肽段的权重为 $\\alpha$，共享肽段贡献的权重为 $\\beta$。\n\n对于一个特定的蛋白质 $P$，观测数据如下：\n- 唯一肽段：三个肽段，其 $S$ 值分别为 $0.97$、$0.82$ 和 $0.74$。\n- 共享肽段：三个肽段，其 $S$ 值和多重性分别为 $(0.91, m=2)$、$(0.88, m=3)$ 和 $(0.65, m=5)$。\n\n设 $\\alpha=1$ 和 $\\beta=0.6$。使用您基于上述假设定义的函数计算 $Q(P)$。将 $Q(P)$ 报告为一个无单位的十进制数，并四舍五入到四位有效数字。", "solution": "该问题要求根据提供的肽段证据和模型假设，定义并计算蛋白质质量分数 $Q(P)$。该分数被定义为支持蛋白质 $P$ 的正确鉴定肽段的期望有效计数，其中唯一肽段和共享肽段具有指定的权重。\n\n首先，我们对 $Q(P)$ 的定义进行形式化。设 $X_i$ 是一个伯努利指示变量，如果肽段 $i$ 被正确鉴定，则 $X_i=1$，否则 $X_i=0$。根据假设 (i)，后验概率 $S_i$ 是正确鉴定的概率，因此 $P(X_i=1) = S_i$。该变量的期望值为 $E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = S_i$。\n\n对于集合 $U(P)$ 中的一个唯一肽段 $i$，其全部证据都支持蛋白质 $P$。单个唯一肽段贡献的期望计数为 $E[X_i] = S_i$。\n\n对于集合 $S(P)$ 中映射到 $m_j$ 个蛋白质的一个共享肽段 $j$，假设 (iii) 指出其证据贡献在所有母蛋白之间平均分配。因此，肽段 $j$ 对蛋白质 $P$ 的有效贡献是 $\\frac{X_j}{m_j}$。单个共享肽段贡献的期望有效计数为 $E\\left[\\frac{X_j}{m_j}\\right] = \\frac{1}{m_j}E[X_j] = \\frac{S_j}{m_j}$。\n\n总的蛋白质质量分数 $Q(P)$ 是所有支持肽段的期望计数的加权和。题目指定了唯一肽段的权重为 $\\alpha$，共享肽段贡献的权重为 $\\beta$。根据肽段证据的条件独立性（假设 (ii)），我们可以对期望值求和。因此，分数 $Q(P)$ 定义为：\n$$\nQ(P) = \\alpha \\sum_{i \\in U(P)} S_i + \\beta \\sum_{j \\in S(P)} \\frac{S_j}{m_j}\n$$\n\n现在，我们将蛋白质 $P$ 的给定数据代入此方程。\n唯一肽段集合 $U(P)$ 有三个成员，其后验概率 $S_i$ 分别为：$0.97$、$0.82$ 和 $0.74$。\n共享肽段集合 $S(P)$ 有三个成员，其后验概率 $S_j$ 和多重性 $m_j$ 分别为：$(0.91, m=2)$、$(0.88, m=3)$ 和 $(0.65, m=5)$。\n给定的权重为 $\\alpha = 1$ 和 $\\beta = 0.6$。\n\n首先，我们计算唯一肽段的后验概率之和：\n$$\n\\sum_{i \\in U(P)} S_i = 0.97 + 0.82 + 0.74 = 2.53\n$$\n\n接下来，我们计算共享肽段分摊的贡献之和：\n$$\n\\sum_{j \\in S(P)} \\frac{S_j}{m_j} = \\frac{0.91}{2} + \\frac{0.88}{3} + \\frac{0.65}{5}\n$$\n我们计算每一项：\n$$\n\\frac{0.91}{2} = 0.455\n$$\n$$\n\\frac{0.88}{3} \\approx 0.29333...\n$$\n$$\n\\frac{0.65}{5} = 0.130\n$$\n总和为：\n$$\n\\sum_{j \\in S(P)} \\frac{S_j}{m_j} = 0.455 + 0.29333... + 0.130 \\approx 0.87833...\n$$\n为了保持精度，我们可以用分数表示这个和：\n$$\n\\frac{91}{200} + \\frac{88}{300} + \\frac{13}{100} = \\frac{273}{600} + \\frac{176}{600} + \\frac{78}{600} = \\frac{273 + 176 + 78}{600} = \\frac{527}{600}\n$$\n\n现在，我们使用权重 $\\alpha=1$ 和 $\\beta=0.6$ 来组合成最终分数 $Q(P)$：\n$$\nQ(P) = (1) \\cdot (2.53) + (0.6) \\cdot \\left(\\frac{527}{600}\\right)\n$$\n$$\nQ(P) = 2.53 + \\left(\\frac{6}{10}\\right) \\cdot \\left(\\frac{527}{600}\\right) = 2.53 + \\frac{527}{1000}\n$$\n$$\nQ(P) = 2.53 + 0.527 = 3.057\n$$\n\n题目要求结果四舍五入到四位有效数字。计算出的值 $3.057$ 已经恰好是四位有效数字。因此，无需进一步四舍五入。", "answer": "$$\\boxed{3.057}$$", "id": "2420429"}, {"introduction": "共享肽段的挑战源于不同蛋白质之间的序列同源性。这项动手编程练习让你能亲手模拟这一过程，通过执行“计算机内”（*in silico*）的胰蛋白酶酶切来生成理论肽段。你将通过计算一个蛋白质的“推断模糊性分数”，将抽象的共享肽段问题与具体的蛋白质序列数据联系起来 [@problem_id:2420453]。", "problem": "本任务要求您在一个严格定义的蛋白水解模型下，基于共享的理论肽段，计算蛋白质推断的模糊度定量指标。对于一个查询蛋白质，其推断模糊度评分定义为：在相同的酶切参数下，其自身产生的不同理论肽段中，同时也能由指定数据库中至少一个其他蛋白质产生的那部分肽段所占的比例。\n\n形式上，设氨基酸字母表为代表 $20$ 种标准氨基酸的大写字母集合：$\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{K}, \\mathrm{L}, \\mathrm{M}, \\mathrm{N}, \\mathrm{P}, \\mathrm{Q}, \\mathrm{R}, \\mathrm{S}, \\mathrm{T}, \\mathrm{V}, \\mathrm{W}, \\mathrm{Y} \\}$。每个蛋白质是该字母表上的一个有限序列。酶切遵循完全特异性的胰蛋白酶规则：在任何 $\\mathrm{K}$ 或 $\\mathrm{R}$ 残基之后立即发生切割，除非该残基后紧跟着 $\\mathrm{P}$。酶切位点将一个蛋白质序列分割成一个有序的连续片段列表。对于一个非负整数 $m$（最大错切数），一个蛋白质的理论肽段集合是指由 $1$ 到 $m+1$ 个连续片段串联构成的所有肽段的集合，并筛选出长度在闭区间 $[L_{\\min}, L_{\\max}]$ 内的肽段。肽段的独特性由精确的字符串相等来判断。\n\n对于一个查询蛋白质序列 $S$ 和一个蛋白质数据库 $D$（其中每个蛋白质都有一个唯一的标识符和序列），定义 $P(S; m, L_{\\min}, L_{\\max})$ 为在上述规则下 $S$ 的不同理论肽段的集合。定义 $P(D; m, L_{\\min}, L_{\\max})$ 为数据库 $D$ 中所有蛋白质在相同参数下各自的不同理论肽段的并集。一个来自 $P(S; m, L_{\\min}, L_{\\max})$ 的肽段如果也存在于 $P(D; m, L_{\\min}, L_{\\max})$ 中，则被认为是共享的。推断模糊度评分的公式为：\n$$\nA(S, D; m, L_{\\min}, L_{\\max}) =\n\\begin{cases}\n0, & \\text{if } |P(S; m, L_{\\min}, L_{\\max})| = 0, \\\\\n\\dfrac{|\\{ p \\in P(S; m, L_{\\min}, L_{\\max}) \\,:\\, p \\in P(D; m, L_{\\min}, L_{\\max}) \\}|}{|P(S; m, L_{\\min}, L_{\\max})|}, & \\text{otherwise.}\n\\end{cases}\n$$\n所有比率必须表示为十进制数，而非百分比。\n\n您的程序必须精确实现此定义，并为下面指定的每个测试用例计算 $A(S, D; m, L_{\\min}, L_{\\max})$。一个测试用例的数据库 $D$ 不包含查询蛋白质本身。\n\n请使用以下测试套件。每个测试用例由一个元组指定，包含：一个查询标识符、一个查询序列、一个由 $(\\text{id}, \\text{sequence})$ 对组成的数据库蛋白质列表、最大错切数 $m$、最小肽段长度 $L_{\\min}$ 和最大肽段长度 $L_{\\max}$。所有标识符都是任意字符串；只有序列会影响计算。\n\n- 测试用例 1:\n  - 查询: $(\\text{\"Q1\"}, \\text{\"ACDEKFGHIKLMNRPSTVWY\"})$\n  - 数据库 $D$: $[(\\text{\"B\"}, \\text{\"ACDEKAAAMK\"}), (\\text{\"C\"}, \\text{\"MFGHIKTTT\"}), (\\text{\"E\"}, \\text{\"KKKK\"})]$\n  - 参数: $m = 0$, $L_{\\min} = 5$, $L_{\\max} = 30$\n\n- 测试用例 2:\n  - 查询: $(\\text{\"Q2\"}, \\text{\"TTTTT\"})$\n  - 数据库 $D$: $[(\\text{\"A\"}, \\text{\"ACDEKFGHIKLMNRPSTVWY}), (\\text{\"B\"}, \\text{\"ACDEKAAAMK\"}), (\\text{\"C\"}, \\text{\"MFGHIKTTT\"})]$\n  - 参数: $m = 0$, $L_{\\min} = 5$, $L_{\\max} = 30$\n\n- 测试用例 3:\n  - 查询: $(\\text{\"Q3\"}, \\text{\"LMNRPSTVWY\"})$\n  - 数据库 $D$: $[(\\text{\"A\"}, \\text{\"ACDEKFGHIKLMNRPSTVWY\"})]$\n  - 参数: $m = 0$, $L_{\\min} = 5$, $L_{\\max} = 30$\n\n- 测试用例 4:\n  - 查询: $(\\text{\"Q4\"}, \\text{\"AK\"})$\n  - 数据库 $D$: $[(\\text{\"X\"}, \\text{\"ACACAC\"}), (\\text{\"Y\"}, \\text{\"RPRP\"})]$\n  - 参数: $m = 0$, $L_{\\min} = 6$, $L_{\\max} = 7$\n\n- 测试用例 5:\n  - 查询: $(\\text{\"Q5\"}, \\text{\"PEPTKALRGLY\"})$\n  - 数据库 $D$: $[(\\text{\"J\"}, \\text{\"PEPTKALRQQQ\"})]$\n  - 参数: $m = 1$, $L_{\\min} = 4$, $L_{\\max} = 50$\n\n您的程序应生成单行输出，其中包含按顺序排列的测试用例 1 到 5 的结果，形式为一个逗号分隔的十进制数列表，每个数字都四舍五入到小数点后恰好 $6$ 位，并用方括号括起来。例如，格式必须与 $[\\text{r1},\\text{r2},\\text{r3},\\text{r4},\\text{r5}]$ 完全一样，其中每个 $\\text{r}i$ 是一个小数点后有恰好 $6$ 位数字的十进制数。", "solution": "所述问题具有科学依据、定义明确且客观。它为蛋白质推断任务提供了一个简化但标准的模型，该模型在计算蛋白质组学中得到应用。定义精确，参数明确，目标清晰。不存在逻辑矛盾、信息缺失或伪科学假设。因此，构建一个严谨的解决方案是可能的，并且我们将着手构建。\n\n任务是计算一个查询蛋白质的推断模糊度评分。该评分量化了源自查询蛋白质的肽段在其他蛋白质的背景数据库中出现的程度。这个问题的核心在于根据蛋白质序列，通过精确的算法生成理论肽段集。\n\n该过程分为两个主要部分：首先，在指定参数下为给定的蛋白质序列生成理论肽段；其次，利用这些肽段集计算模糊度评分。\n\n首先，让我们形式化计算机模拟酶切过程。一个蛋白质，表示为氨基酸字母表上的一个字符序列，被一种蛋白水解酶（此处为胰蛋白酶）切割。给定的规则是一个标准近似：在赖氨酸（$\\mathrm{K}$）或精氨酸（$\\mathrm{R}$）残基的C-末端发生切割，除非该残基紧随一个脯氨酸（$\\mathrm{P}$）。此规则将蛋白质序列分割成一个有序的基本片段列表。对于一个序列 $S$，设酶切位点在索引 $c_1, c_2, \\ldots, c_k$ 处。包括序列的起始（$0$）和结束（$|S|$），我们定义切割点集合为 $\\{0, c_1, c_2, \\ldots, c_k, |S|\\}$。基本片段是相邻切割点之间的子字符串。设这个片段的有序列表为 $(s_1, s_2, \\ldots, s_{k+1})$。\n\n参数 $m$，即最大错切数，允许不完全的酶切。一个有 $j$ 次错切的肽段是由 $j+1$ 个连续的基本片段串联形成的。我们的模型考虑具有 $0, 1, \\ldots, m$ 次错切的肽段。因此，一个候选肽段是形如 $s_i s_{i+1} \\ldots s_{i+j}$ 的串联，其中 $1 \\le i \\le k+1$ 且 $0 \\le j \\le m$，使得 $i+j \\le k+1$。\n\n最后，每个候选肽段 $p$ 都要经过长度筛选。只有当其长度 $|p|$ 落在闭区间 $[L_{\\min}, L_{\\max}]$ 内时，它才被认为是一个有效的理论肽段。对于一个序列 $S$ 和参数 $(m, L_{\\min}, L_{\\max})$，所有这样有效且不同的肽段的集合表示为 $P(S; m, L_{\\min}, L_{\\max})$。\n\n生成该集合的算法如下：\n1.  对于给定的蛋白质序列，识别所有发生酶切的索引 $i$，即 `sequence[i]` 是 $\\mathrm{K}$ 或 $\\mathrm{R}$，且 `sequence[i+1]` 不是 $\\mathrm{P}$。\n2.  使用这些酶切位点将蛋白质序列分割成一个有序的基本肽段（对应于零次错切的片段）列表。\n3.  生成这个片段列表的所有可能的连续子序列，其长度从 $1$ 到 $m+1$。\n4.  对于每个这样的片段子序列，将它们串联起来形成一个候选肽段字符串。\n5.  如果候选肽段的长度在 $L_{\\min}$ 和 $L_{\\max}$（含）之间，则将其添加到一个集合数据结构中以确保唯一性。\n6.  最终结果就是这个唯一肽段的集合。\n\n建立了肽段生成函数后，我们就可以计算模糊度评分 $A(S, D; m, L_{\\min}, L_{\\max})$。设 $P_S = P(S; m, L_{\\min}, L_{\\max})$ 为查询蛋白质 $S$ 的肽段集，设 $P_D = \\bigcup_{S' \\in D} P(S'; m, L_{\\min}, L_{\\max})$ 为数据库 $D$ 中所有蛋白质的所有肽段的集合。\n\n共享肽段的集合是这两个集合的交集，$P_S \\cap P_D$。模糊度评分定义为共享肽段数量与查询肽段总数之比：\n$$\nA(S, D; m, L_{\\min}, L_{\\max}) = \\frac{|P_S \\cap P_D|}{|P_S|}\n$$\n当查询肽段集为空时，定义了一个特殊情况：如果 $|P_S| = 0$，则评分 $A=0$。这是避免除以零的必要条件。\n\n实现将严格遵循这一描述的逻辑。对于每个测试用例，将为查询蛋白质和数据库中的每个条目生成肽段集。然后将根据公式中相应集合的基数之比来计算模糊度评分，并按要求进行格式化。", "answer": "```python\nimport numpy as np\n\ndef get_peptides(sequence: str, m: int, l_min: int, l_max: int) -> set[str]:\n    \"\"\"\n    Computes the set of theoretical peptides for a given protein sequence.\n\n    Args:\n        sequence: The amino acid sequence of the protein.\n        m: The maximum number of missed cleavages.\n        l_min: The minimum length of a valid peptide.\n        l_max: The maximum length of a valid peptide.\n\n    Returns:\n        A set of distinct theoretical peptide strings.\n    \"\"\"\n    if not sequence:\n        return set()\n\n    cut_indices = [0]\n    for i in range(len(sequence) - 1):\n        if sequence[i] in ('K', 'R') and sequence[i+1] != 'P':\n            cut_indices.append(i + 1)\n    cut_indices.append(len(sequence))\n\n    segments = []\n    for i in range(len(cut_indices) - 1):\n        start, end = cut_indices[i], cut_indices[i+1]\n        segments.append(sequence[start:end])\n\n    peptides = set()\n    num_segments_total = len(segments)\n    \n    # Iterate through number of segments to join (from 1 to m+1)\n    for k in range(1, m + 2):\n        if k > num_segments_total:\n            break\n        # Iterate through starting positions for segment groups\n        for i in range(num_segments_total - k + 1):\n            peptide_candidate = \"\".join(segments[i : i+k])\n            if l_min <= len(peptide_candidate) <= l_max:\n                peptides.add(peptide_candidate)\n                \n    return peptides\n\ndef solve():\n    \"\"\"\n    Solves the protein inference ambiguity problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        (\n            \"Q1\", \"ACDEKFGHIKLMNRPSTVWY\",\n            [(\"B\", \"ACDEKAAAMK\"), (\"C\", \"MFGHIKTTT\"), (\"E\", \"KKKK\")],\n            0, 5, 30\n        ),\n        # Test Case 2\n        (\n            \"Q2\", \"TTTTT\",\n            [(\"A\", \"ACDEKFGHIKLMNRPSTVWY\"), (\"B\", \"ACDEKAAAMK\"), (\"C\", \"MFGHIKTTT\")],\n            0, 5, 30\n        ),\n        # Test Case 3\n        (\n            \"Q3\", \"LMNRPSTVWY\",\n            [(\"A\", \"ACDEKFGHIKLMNRPSTVWY\")],\n            0, 5, 30\n        ),\n        # Test Case 4\n        (\n            \"Q4\", \"AK\",\n            [(\"X\", \"ACACAC\"), (\"Y\", \"RPRP\")],\n            0, 6, 7\n        ),\n        # Test Case 5\n        (\n            \"Q5\", \"PEPTKALRGLY\",\n            [(\"J\", \"PEPTKALRQQQ\")],\n            1, 4, 50\n        )\n    ]\n\n    results = []\n    for _, query_seq, db_proteins, m, l_min, l_max in test_cases:\n        # Generate peptides for the query protein\n        query_peptides = get_peptides(query_seq, m, l_min, l_max)\n        \n        # If no query peptides, score is 0\n        if not query_peptides:\n            results.append(0.0)\n            continue\n            \n        # Generate peptides for all proteins in the database\n        db_peptides = set()\n        for _, db_seq in db_proteins:\n            peps = get_peptides(db_seq, m, l_min, l_max)\n            db_peptides.update(peps)\n            \n        # Find shared peptides\n        shared_peptides = query_peptides.intersection(db_peptides)\n        \n        # Calculate ambiguity score\n        score = len(shared_peptides) / len(query_peptides)\n        results.append(score)\n\n    # Format and print the final output\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2420453"}, {"introduction": "虽然简约原则（奥卡姆剃刀）是进行蛋白质推断时一个直观的出发点，但它有时可能是一种过度简化。本练习通过一个概率模型来探讨一个经典场景：一个共享肽段虽然可以被一个蛋白质“解释”，但它是否仍然为另一个蛋白质提供了残余证据？这个练习突出了概率框架相比于简单规则所能捕捉到的精妙之处 [@problem_id:2420450]。", "problem": "在一个自下而上的蛋白质组学蛋白质推断场景中，考虑蛋白质 $A$ 和 $B$ 以及两个观测到的肽段：一个唯一映射到 $A$ 的肽段 $u$，以及一个由 $A$ 和 $B$ 共享的肽段 $x$。假设肽段检测遵循以下生成模型。对于任何存在的蛋白质，其每个组成肽段被独立检测到的概率为 $t$。对于任何不存在的蛋白质，任何特定的肽段被错误检测到的概率为 $f$。$A$ 和 $B$ 的存在是先验独立的，且 $P(A \\text{ present}) = P(B \\text{ present}) = 0.5$。给定其母蛋白质存在或不存在，不同肽段的检测事件是条件独立的。如果一个肽段由多个存在的蛋白质共享，只要至少有一个母蛋白质引发了对它的检测事件，它就会被检测到。在此模型下，对于共享肽段 $x$，其检测概率为 $P(x \\text{ detected} \\mid \\text{only } A \\text{ present}) = t$，$P(x \\text{ detected} \\mid \\text{only } B \\text{ present}) = t$，$P(x \\text{ detected} \\mid A \\text{ and } B \\text{ present}) = 1 - (1 - t)^2$，以及 $P(x \\text{ detected} \\mid \\text{neither present}) = f$。假设 $t = 0.6$ 且 $f = 0.01$。您观测到 $u$ 和 $x$ 都被检测到。根据严格的简约性解释，由于存在唯一肽段 $u$，共享肽段 $x$ 将被归因于 $A$，而不会计入 $B$。根据上述指定的概率模型，考虑条件似然比\n$$L = \\frac{P(x \\text{ detected} \\mid B \\text{ present},\\, u \\text{ detected})}{P(x \\text{ detected} \\mid B \\text{ absent},\\, u \\text{ detected})}.$$\n哪个选项最能描述 $L$ 的值以及在观测到 $u$ 后，$x$ 对 $B$ 的证据作用？\n\nA. $L \\approx 1.42$，因此即使在简约性原则下 $u$ 的存在使得 $x$ 可以被 $A$ 解释，$x$ 仍然为 $B$ 提供了正向的残余证据。\n\nB. $L \\approx 1.00$，因此一旦观测到 $u$，$x$ 就没有为 $B$ 提供残余证据了。\n\nC. $L \\approx 0.84$，因此一旦观测到 $u$，$x$ 就为 $B$ 提供了负向证据。\n\nD. $L \\approx 2.00$，因此无论是否存在 $u$，$x$ 都强烈支持 $B$。", "solution": "用户要求我严格验证并解决一个与蛋白质组学中蛋白质推断相关的问题。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n-   **蛋白质：** $A$ 和 $B$。\n-   **肽段：** $u$（蛋白质 $A$ 的唯一肽段），$x$（蛋白质 $A$ 和 $B$ 的共享肽段）。\n-   **观测结果：** 肽段 $u$ 被检测到（事件 $D_u$），肽段 $x$ 被检测到（事件 $D_x$）。\n-   **模型参数：**\n    -   从存在的蛋白质中检测到肽段的概率：$t = 0.6$。\n    -   从不存在的蛋白质中错误检测到肽段的概率：$f = 0.01$。\n-   **先验概率：**\n    -   $P(A \\text{ present}) = 0.5$。令 $A_p$ 表示“$A$ 存在”，$A_a$ 表示“$A$ 不存在”。因此，$P(A_p) = 0.5$ 且 $P(A_a) = 0.5$。\n    -   $P(B \\text{ present}) = 0.5$。令 $B_p$ 表示“$B$ 存在”，$B_a$ 表示“$B$ 不存在”。因此，$P(B_p) = 0.5$ 且 $P(B_a) = 0.5$。\n    -   $A$ 和 $B$ 的存在是先验独立事件。\n-   **检测模型：**\n    -   在给定其母蛋白质存在/不存在的情况下，肽段检测是条件独立的。\n    -   对于唯一肽段 $u$：$P(D_u \\mid A_p) = t$, $P(D_u \\mid A_a) = f$。\n    -   对于共享肽段 $x$：\n        -   $P(D_x \\mid A_p, B_a) = t$\n        -   $P(D_x \\mid A_a, B_p) = t$\n        -   $P(D_x \\mid A_p, B_p) = 1 - (1-t)^2$\n        -   $P(D_x \\mid A_a, B_a) = f$\n-   **待计算量：** 条件似然比 $L = \\frac{P(D_x \\mid B_p, D_u)}{P(D_x \\mid B_a, D_u)}$。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n1.  **科学依据：** 该问题描述了一个简化的生成概率模型，这是计算蛋白质组学中用于蛋白质推断的标准且科学有效的方法。唯一/共享肽段、检测概率和错误检测等概念是该领域的基础。\n2.  **适定性：** 该问题在数学上是适定的。所有必需的概率、参数和独立性假设都已明确陈述。目标量 $L$ 定义清晰，可以根据给定条件唯一计算出来。\n3.  **客观性：** 该问题以精确、客观的数学语言陈述。对“严格简约性”的引用起到了概念对比的作用，并未给概率计算引入主观性。\n4.  **无缺陷：** 该问题不违反科学原理，不不完整或自相矛盾，也不是不适定的。参数值是合理的。\n\n**第 3 步：结论与行动**\n\n问题陈述是 **有效的**。开始求解。\n\n### 求解推导\n\n待计算的量是条件似然比 $L$：\n$$L = \\frac{P(D_x \\mid B_p, D_u)}{P(D_x \\mid B_a, D_u)}$$\n使用条件概率的定义，$P(C \\mid D) = P(C, D) / P(D)$，我们可以重写分子和分母：\n$$P(D_x \\mid B_p, D_u) = \\frac{P(D_x, D_u, B_p)}{P(D_u, B_p)} = \\frac{P(D_x, D_u \\mid B_p) P(B_p)}{P(D_u \\mid B_p) P(B_p)} = \\frac{P(D_x, D_u \\mid B_p)}{P(D_u \\mid B_p)}$$\n$$P(D_x \\mid B_a, D_u) = \\frac{P(D_x, D_u, B_a)}{P(D_u, B_a)} = \\frac{P(D_x, D_u \\mid B_a) P(B_a)}{P(D_u \\mid B_a) P(B_a)} = \\frac{P(D_x, D_u \\mid B_a)}{P(D_u \\mid B_a)}$$\n让我们分析 $i \\in \\{p, a\\}$ 时的项 $P(D_u \\mid B_i)$。由于肽段 $u$ 的检测只取决于蛋白质 $A$ 的状态，并且 $A$ 和 $B$ 的状态是先验独立的，因此 $B$ 的状态不影响检测到 $u$ 的概率。形式上，我们对蛋白质 $A$ 的状态进行边缘化：\n$$P(D_u \\mid B_p) = P(D_u \\mid A_p, B_p)P(A_p \\mid B_p) + P(D_u \\mid A_a, B_p)P(A_a \\mid B_p)$$\n由于独立性，$P(A_p \\mid B_p) = P(A_p)=0.5$ 且 $P(A_a \\mid B_p)=P(A_a)=0.5$。此外，$P(D_u \\mid A_i, B_j) = P(D_u \\mid A_i)$。\n$$P(D_u \\mid B_p) = P(D_u \\mid A_p)P(A_p) + P(D_u \\mid A_a)P(A_a) = t \\cdot 0.5 + f \\cdot 0.5 = 0.5(t+f)$$\n$P(D_u \\mid B_a)$ 的计算是相同的，因此 $P(D_u \\mid B_p) = P(D_u \\mid B_a)$。这证实了这些项将在 $L$ 的表达式中抵消：\n$$L = \\frac{P(D_x, D_u \\mid B_p)}{P(D_u \\mid B_p)} \\cdot \\frac{P(D_u \\mid B_a)}{P(D_x, D_u \\mid B_a)} = \\frac{P(D_x, D_u \\mid B_p)}{P(D_x, D_u \\mid B_a)}$$\n现在，我们通过对蛋白质 $A$ 的状态进行边缘化来计算这个简化比率的分子和分母。\n\n**分子：$P(D_x, D_u \\mid B_p)$**\n$$P(D_x, D_u \\mid B_p) = P(D_x, D_u \\mid A_p, B_p) P(A_p) + P(D_x, D_u \\mid A_a, B_p) P(A_a)$$\n在给定蛋白质状态的情况下，$u$ 和 $x$ 的检测是独立事件。\n$$P(D_x, D_u \\mid B_p) = [P(D_x \\mid A_p, B_p) P(D_u \\mid A_p, B_p)] P(A_p) + [P(D_x \\mid A_a, B_p) P(D_u \\mid A_a, B_p)] P(A_a)$$\n$$P(D_x, D_u \\mid B_p) = [(1-(1-t)^2) \\cdot t] \\cdot 0.5 + [t \\cdot f] \\cdot 0.5$$\n$$P(D_x, D_u \\mid B_p) = 0.5 [t(1-(1-t)^2) + tf] = 0.5t[1-(1-t)^2 + f]$$\n\n**分母：$P(D_x, D_u \\mid B_a)$**\n$$P(D_x, D_u \\mid B_a) = P(D_x, D_u \\mid A_p, B_a) P(A_p) + P(D_x, D_u \\mid A_a, B_a) P(A_a)$$\n$$P(D_x, D_u \\mid B_a) = [P(D_x \\mid A_p, B_a) P(D_u \\mid A_p, B_a)] P(A_p) + [P(D_x \\mid A_a, B_a) P(D_u \\mid A_a, B_a)] P(A_a)$$\n$$P(D_x, D_u \\mid B_a) = [t \\cdot t] \\cdot 0.5 + [f \\cdot f] \\cdot 0.5 = 0.5(t^2+f^2)$$\n\n**L 的最终表达式**\n$$L = \\frac{0.5t[1-(1-t)^2 + f]}{0.5(t^2+f^2)} = \\frac{t[1-(1-t)^2 + f]}{t^2+f^2}$$\n\n**数值计算**\n给定 $t = 0.6$ 和 $f = 0.01$。\n-   $1 - t = 1 - 0.6 = 0.4$\n-   $(1-t)^2 = (0.4)^2 = 0.16$\n-   $1 - (1-t)^2 = 1 - 0.16 = 0.84$\n-   $t^2 = (0.6)^2 = 0.36$\n-   $f^2 = (0.01)^2 = 0.0001$\n\n将这些值代入 $L$ 的表达式中：\n$$L = \\frac{0.6 [0.84 + 0.01]}{0.36 + 0.0001} = \\frac{0.6 \\cdot 0.85}{0.3601} = \\frac{0.51}{0.3601} \\approx 1.41627$$\n四舍五入到小数点后两位，$L \\approx 1.42$。\n\n**解释**\n似然比 $L$ 大于 1。用贝叶斯术语来说，$B$ 存在的后验几率是通过将先验几率乘以似然比来更新的。\n$$ \\frac{P(B_p \\mid D_x, D_u)}{P(B_a \\mid D_x, D_u)} = L \\cdot \\frac{P(B_p \\mid D_u)}{P(B_a \\mid D_u)} $$\n由于 $A$ 和 $B$ 是独立的，且 $u$ 是 $A$ 的唯一肽段，观测到 $D_u$ 并不改变对 $B$ 的信念，所以 $\\frac{P(B_p \\mid D_u)}{P(B_a \\mid D_u)} = \\frac{P(B_p)}{P(B_a)} = 1$。\n因此，$\\frac{P(B_p \\mid D_x, D_u)}{P(B_a \\mid D_x, D_u)} = L \\approx 1.42$。\n由于 $L > 1$，观测到共享肽段 $x$ 增加了蛋白质 $B$ 存在的几率，即使是在观测到蛋白质 $A$ 的唯一肽段 $u$ 之后。这意味着 $x$ 为 $B$ 提供了正向的“残余”证据。这与严格的简约性原则形成对比，后者会将 $x$ 完全归因于 $A$，并得出结论认为在这种情况下 $x$ 不为 $B$ 提供任何证据（意味着 $L=1$）。\n\n### 逐项分析\n\n**A. $L \\approx 1.42$，因此即使在简约性原则下 $u$ 的存在使得 $x$ 可以被 $A$ 解释，$x$ 仍然为 $B$ 提供了正向的残余证据。**\n我们的计算得出 $L \\approx 1.42$。其解释是，由于 $L > 1$，$x$ 为 $B$ 提供了正向证据，即使在 $D_u$ 的背景下也是如此。这被正确地称为“残余证据”，并与简约性原则进行了准确的对比。此选项是 **正确的**。\n\n**B. $L \\approx 1.00$，因此一旦观测到 $u$，$x$ 就没有为 $B$ 提供残余证据了。**\n我们的计算显示 $L \\approx 1.42$，而不是 $1.00$。如果 $L$ 等于 $1.00$，解释将是正确的，但数值是错误的。概率模型表明简约性原则是一种过度简化。此选项是 **不正确的**。\n\n**C. $L \\approx 0.84$，因此一旦观测到 $u$，$x$ 就为 $B$ 提供了负向证据。**\n我们的计算显示 $L \\approx 1.42$，而不是 $0.84$。$L < 1$ 的值将意味着负向证据（一种“解释掉”效应，其强度足以对 $B$ 产生惩罚），但这里情况并非如此。此选项是 **不正确的**。\n\n**D. $L \\approx 2.00$，因此无论是否存在 $u$，$x$ 都强烈支持 $B$。**\n我们的计算显示 $L \\approx 1.42$，而不是 $2.00$。此外，“无论是否存在 $u$”的说法是错误的。$L$ 的整个计算都是以观测到 $D_u$ 为条件的。事实上，通过观测到 $u$，$x$ 为 $B$ 提供的证据反而*减少*了。此选项是 **不正确的**。", "answer": "$$\\boxed{A}$$", "id": "2420450"}]}