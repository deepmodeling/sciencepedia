{"hands_on_practices": [{"introduction": "将生物学中对蛋白质基序（motif）的描述性定义，转化为精确的计算搜索模式，是生物信息学的一项基本功。正则表达式（regular expressions）为此提供了强有力的工具，它不仅能匹配精确的氨基酸序列，还能灵活地定义保守残基之间的可变间隔区。本练习将带你实践如何为两种重要的功能基序——C2H2锌指和RING指——构建搜索模式，并从一个序列集合中筛选出同时包含这两种基序的蛋白质，这模拟了在蛋白质组范围内寻找具有特定多功能组合的候选蛋白质的真实场景。[@problem_id:2420143]", "problem": "您必须编写一个完整、可运行的程序。该程序针对一组固定的人类候选蛋白质一级结构（基于标准氨基酸字母表），识别出哪些序列同时包含至少一次以下两种定义结构域的基序模式：一种脱氧核糖核酸（DNA）结合型$C_2H_2$锌指基序，以及一种 E3 泛素连接酶“真正有趣新基因”（RING）指基序。基序的存在纯粹定义为存在一个满足下述位置约束的连续子序列。字母表为 $\\Sigma = \\{ \\text{A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y, X} \\}$，其中 $\\text{X}$ 表示一个未知残基，它只能作为通用符号出现，并被视为在通配符位置上匹配任何单个残基；它不满足明确要求特定残基的位置。以下是形式化规范。\n\n模式的数学定义：给定一个序列 $S \\in \\Sigma^*$ 和一个描述为符号与有界通配符串联的模式，如果存在一个索引 $i$ 和一个长度 $L$，使得子串 $S[i\\,..\\,i+L-1]$ 与一个由字面残基和形如 $\\text{any}^{k}$ 的通配符块串联而成的字符串完全相等，则存在匹配。其中 $k$ 是一个非负整数，$\\text{any}$ 表示来自 $\\Sigma$ 的任何单个符号。字面位置必须匹配确切的残基符号，而通配符位置可以匹配 $\\Sigma$ 中的任何残基符号。\n\n基序定义：\n- DNA 结合 $C_2H_2$ 锌指基序（此处简称为 C2H2）：一个字面 $\\text{C}$，后跟 $k_1$ 个任意残基（$k_1 \\in \\{2,3,4\\}$），再跟一个字面 $\\text{C}$，然后是恰好 $12$ 个任意残基，接着一个字面 $\\text{H}$，然后是 $k_2$ 个任意残基（$k_2 \\in \\{3,4,5\\}$），最后是一个字面 $\\text{H}$。形式上，表示为 $\\text{C} \\cdot \\text{any}^{k_1} \\cdot \\text{C} \\cdot \\text{any}^{12} \\cdot \\text{H} \\cdot \\text{any}^{k_2} \\cdot \\text{H}$。\n- E3 泛素连接酶 RING 指基序（此处简称为 RING）：一个字面 $\\text{C}$，后跟恰好 $2$ 个任意残基，再跟一个字面 $\\text{C}$，后跟 $n_1$ 个任意残基（$n_1 \\in [9,39]$），再跟一个字面 $\\text{C}$，后跟 $n_2$ 个任意残基（$n_2 \\in [1,3]$），再跟一个字面 $\\text{H}$，后跟 $n_3$ 个任意残基（$n_3 \\in [2,3]$），再跟一个字面 $\\text{C}$，后跟恰好 $2$ 个任意残基，再跟一个字面 $\\text{C}$，后跟 $n_4$ 个任意残基（$n_4 \\in [4,48]$），再跟一个字面 $\\text{C}$，后跟恰好 $2$ 个任意残基，最后是一个字面 $\\text{C}$。形式上，表示为 $\\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_1} \\cdot \\text{C} \\cdot \\text{any}^{n_2} \\cdot \\text{H} \\cdot \\text{any}^{n_3} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_4} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C}$。\n\n给定一个固定的候选蛋白质序列列表 $S_0, S_1, \\dots, S_8$，每个序列关联一个从零开始的索引。请精确地构建以下可重用构建块：\n- 定义 $Z_{\\min} =$ \"CAACAAAAAAAAAAAAHAAAH\"，它实例化了 C2H2 基序，其中 $k_1 = 2$ 且 $k_2 = 3$，即 $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{3} \\cdot \\text{H}$。\n- 定义 $Z_{\\max} =$ \"CAAAACAAAAAAAAAAAAHAAAAAH\"，它实例化了 C2H2 基序，其中 $k_1 = 4$ 且 $k_2 = 5$，即 $\\text{C} \\cdot \\text{A}^{4} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{5} \\cdot \\text{H}$。\n- 定义 $Z_{\\mathrm{exact}} =$ \"CAAACAAAAAAAAAAAAHAAAAH\"，它实例化了 C2H2 基序，其中 $k_1 = 3$ 且 $k_2 = 4$，即 $\\text{C} \\cdot \\text{A}^{3} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{4} \\cdot \\text{H}$。\n- 定义 $R_{\\min} =$ \"CAACAAAAAAAAACAHAACAACAAAACAAC\"，它实例化了 RING 基序，其中 $n_1 = 9$、$n_2 = 1$、$n_3 = 2$ 且 $n_4 = 4$，即 $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{9} \\cdot \\text{C} \\cdot \\text{A}^{1} \\cdot \\text{H} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{4} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C}$。\n- 定义 $R_{\\max}$ 为由 $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{39} \\cdot \\text{C} \\cdot \\text{A}^{3} \\cdot \\text{H} \\cdot \\text{A}^{3} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{48} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C}$ 构建的字符串（长度为 $107$）。\n- 定义 $Z_{\\mathrm{X}}$ 为字符串 $\\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{12} \\cdot \\text{H} \\cdot \\text{X}^{3} \\cdot \\text{H}$。\n- 定义 $R_{\\mathrm{X}}$ 为字符串 $\\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{9} \\cdot \\text{C} \\cdot \\text{X}^{1} \\cdot \\text{H} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{4} \\cdot \\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C}$。\n\n现在按如下方式定义索引 $i \\in \\{0,1,2,3,4,5,6,7,8\\}$ 的序列 $S_i$：\n- $S_0 =$ 重复 $10$ 次 \"M\"，后跟 $Z_{\\min}$，后跟重复 $5$ 次 \"G\"，后跟 $R_{\\min}$，后跟重复 $3$ 次 \"T\"。\n- $S_1 =$ 重复 $5$ 次 \"M\"，后跟 $Z_{\\max}$，后跟重复 $5$ 次 \"Q\"。\n- $S_2 =$ 重复 $5$ 次 \"V\"，后跟 $R_{\\min}$，后跟重复 $5$ 次 \"P\"。\n- $S_3 =$ 字面字符串 \"MKTLLILVVAAAAGGG\"。\n- $S_4 =$ 重复 $4$ 次 \"S\"，后跟 $Z_{\\max}$，后跟重复 $5$ 次 \"N\"，后跟 $R_{\\max}$，后跟重复 $4$ 次 \"E\"。\n- $S_5 =$ 从 $Z_{\\min}$ 获得的字符串，将其最后的字面 $\\text{H}$ 替换为 $\\text{K}$（因此最后一个位置不再是 $\\text{H}$），后跟重复 $3$ 次 \"G\"，后跟 $R_{\\min}$。\n- $S_6 =$ $Z_{\\mathrm{X}}$ 后跟 \"GG\"，后跟 $R_{\\mathrm{X}}$。\n- $S_7 =$ $R_{\\min}$ 紧接着 $Z_{\\min}$。\n- $S_8 =$ 重复 $3$ 次 \"D\"，后跟 $Z_{\\mathrm{exact}}$，后跟重复 $3$ 次 \"P\"，后跟 $R_{\\min}$，后跟重复 $3$ 次 \"K\"。\n\n模式参数化测试套件：\n- 测试用例 1：C2H2 基序，其中 $k_1 \\in \\{2,3,4\\}$，$\\text{C}$ 和 $\\text{H}$ 之间恰好有 $12$ 个任意残基，且 $k_2 \\in \\{3,4,5\\}$；RING 基序，其中 $n_1 \\in [9,39]$，$n_2 \\in [1,3]$，$n_3 \\in [2,3]$ 且 $n_4 \\in [4,48]$。\n- 测试用例 2：C2H2 基序与测试用例 1 相同；RING 基序收紧为 $n_1 \\in [9,12]$ 和 $n_4 \\in [4,12]$，而 $n_2 \\in [1,3]$ 和 $n_3 \\in [2,3]$ 保持不变。\n- 测试用例 3：C2H2 基序收紧为 $k_1 = 3$ 和 $k_2 = 4$，第二个 $\\text{C}$ 和第一个 $\\text{H}$ 之间恰好有 $12$ 个任意残基；RING 基序与测试用例 1 相同。\n\n对于每个测试用例 $t \\in \\{1,2,3\\}$，确定索引集合 $I_t \\subseteq \\{0,1,\\dots,8\\}$，使得 $S_i$ 至少包含一个匹配测试用例 $t$ 指定的 C2H2 基序的子串，并且至少包含一个匹配测试用例 $t$ 指定的 RING 基序的子串。您的程序必须输出一行，其中包含三个结果，这些结果聚合成一个不含空格的整数列表的列表，顺序为 $[I_1, I_2, I_3]$，其中每个 $I_t$ 表示为一个由从零开始的索引组成的严格递增列表。例如，一个有效的输出格式看起来像 \"[[a_1,a_2],[b_1],[c_1,c_2,c_3]]\"，其中 $a_j$、$b_j$ 和 $c_j$ 是整数。不应打印任何其他文本。", "solution": "所提出的问题是生物信息学中的一个标准练习，特别是在序列分析和基序识别领域。它在计算上是适定的，在科学上是合理的。任务是从一组给定的蛋白质一级结构中，根据变化的参数约束，识别出那些包含两种不同基序实例（一个 C$_2$H$_2$ 锌指和一个 RING 指）的序列。\n\n解决这个问题的基本原理是字符串中的模式匹配。鉴于基序是由特定氨基酸残基序列与可变长度的任意残基片段交错定义的，最直接且计算效率最高的方法是使用正则表达式。正则表达式是一种用于指定搜索模式的形式化语言，它直接适用于所提供的定义。\n\n该方法分三个阶段实施。\n\n首先，以编程方式构建输入。九个蛋白质序列（表示为 $S_0$ 到 $S_8$）通过连接所提供的字面字符串和预定义的构建块（$Z_{\\min}$、$Z_{\\max}$ 等）来精确合成，正如描述的那样。此步骤是简单的字符串操作。\n\n其次，制定参数化的模式匹配函数。需要两个核心函数：一个用于 C$_2$H$_2$ 基序，一个用于 RING 基序。\nC$_2$H$_2$ 基序定义为 $\\text{C} \\cdot \\text{any}^{k_1} \\cdot \\text{C} \\cdot \\text{any}^{12} \\cdot \\text{H} \\cdot \\text{any}^{k_2} \\cdot \\text{H}$。这可以转换为 `C.{k1_min,k1_max}C.{12}H.{k2_min,k2_max}H` 形式的正则表达式模式，其中 $\\{k_1\\_{\\min}, k_1\\_{\\max}\\}$ 和 $\\{k_2\\_{\\min}, k_2\\_{\\max}\\}$ 定义了通配符片段长度的闭区间整数范围。符号 `.` 是一个匹配任何单个字符的通配符，它正确地模拟了字母表 $\\Sigma$ 上的 `any` 符号，包括特殊残基 $\\text{X}$。模式中的字面字符 `C` 和 `H` 只会匹配它们自身，从而正确地强制执行指定的保守残基。\n\n同样，RING 指基序，形式上是 $\\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_1} \\cdot \\text{C} \\cdot \\text{any}^{n_2} \\cdot \\text{H} \\cdot \\text{any}^{n_3} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_4} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C}$，被转换为正则表达式 `C..C.{n1_min,n1_max}C.{n2_min,n2_max}H.{n3_min,n3_max}C..C.{n4_min,n4_max}C..C`。参数 $n_1, n_2, n_3, n_4$ 作为每个测试用例的范围提供。\n\n第三，针对测试用例系统地评估每个序列。一个主过程会遍历三个指定的测试用例。对于每个测试用例，它使用相应的参数范围 $k_1, k_2, n_1, n_2, n_3, n_4$ 配置正则表达式模式。然后，它遍历 $i \\in \\{0, \\ldots, 8\\}$ 的每个序列 $S_i$。对于一个给定的测试用例，要使一个序列被视为匹配，对 C$_2$H$_2$ 模式的搜索 *和* 对 RING 模式的搜索都必须成功。对于每个测试用例，收集所有满足此双重条件的序列的索引 $i$。\n\n最终输出是这些索引集的聚合，以所要求的列表的列表格式呈现。整个过程是正则表达式匹配和逻辑合取的确定性应用，从而产生唯一且正确的解决方案。", "answer": "```python\nimport re\nimport numpy as np  # numpy is specified as available but not used.\n# scipy is specified as available but not used.\n\ndef solve():\n    \"\"\"\n    Solves the protein motif identification problem by:\n    1. Constructing the target protein sequences from given building blocks.\n    2. Defining the parameter sets for three test cases.\n    3. Implementing helper functions to generate regular expressions for\n       C2H2 and RING motifs based on variable length parameters.\n    4. Iterating through each test case and each sequence, checking for the\n       presence of both required motifs.\n    5. Collecting and printing the indices of matching sequences in the\n       specified format.\n    \"\"\"\n\n    # Define reusable building blocks for sequences\n    Z_min = \"CAACAAAAAAAAAAAAHAAAH\"\n    Z_max = \"CAAAACAAAAAAAAAAAAHAAAAAH\"\n    Z_exact = \"CAAACAAAAAAAAAAAAHAAAAH\"\n    R_min = \"CAACAAAAAAAAACAHAACAACAAAACAAC\"\n    R_max = (\n        \"C\" + \"A\" * 2 + \"C\" + \"A\" * 39 + \"C\" + \"A\" * 3 + \"H\" + \"A\" * 3 +\n        \"C\" + \"A\" * 2 + \"C\" + \"A\" * 48 + \"C\" + \"A\" * 2 + \"C\"\n    )\n    Z_X = \"C\" + \"X\" * 2 + \"C\" + \"X\" * 12 + \"H\" + \"X\" * 3 + \"H\"\n    R_X = (\n        \"C\" + \"X\" * 2 + \"C\" + \"X\" * 9 + \"C\" + \"X\" * 1 + \"H\" + \"X\" * 2 +\n        \"C\" + \"X\" * 2 + \"C\" + \"X\" * 4 + \"C\" + \"X\" * 2 + \"C\"\n    )\n\n    # Define the list of candidate protein sequences S_0 to S_8\n    sequences = [\n        \"M\" * 10 + Z_min + \"G\" * 5 + R_min + \"T\" * 3,  # S_0\n        \"M\" * 5 + Z_max + \"Q\" * 5,                      # S_1\n        \"V\" * 5 + R_min + \"P\" * 5,                      # S_2\n        \"MKTLLILVVAAAAGGG\",                             # S_3\n        \"S\" * 4 + Z_max + \"N\" * 5 + R_max + \"E\" * 4,    # S_4\n        Z_min[:-1] + \"K\" + \"G\" * 3 + R_min,             # S_5\n        Z_X + \"GG\" + R_X,                               # S_6\n        R_min + Z_min,                                  # S_7\n        \"D\" * 3 + Z_exact + \"P\" * 3 + R_min + \"K\" * 3,  # S_8\n    ]\n\n    # Define the parameters for the three test cases\n    test_cases = [\n        {\n            \"c2h2\": {\"k1_range\": (2, 4), \"k2_range\": (3, 5)},\n            \"ring\": {\"n1_range\": (9, 39), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 48)},\n        },\n        {\n            \"c2h2\": {\"k1_range\": (2, 4), \"k2_range\": (3, 5)},\n            \"ring\": {\"n1_range\": (9, 12), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 12)},\n        },\n        {\n            \"c2h2\": {\"k1_range\": (3, 3), \"k2_range\": (4, 4)},\n            \"ring\": {\"n1_range\": (9, 39), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 48)},\n        },\n    ]\n\n    # Helper function to generate a regular expression for the C2H2 motif\n    def make_c2h2_regex(k1_range, k2_range):\n        pattern = f\"C.{{{k1_range[0]},{k1_range[1]}}}C.{{12}}H.{{{k2_range[0]},{k2_range[1]}}}H\"\n        return re.compile(pattern)\n\n    # Helper function to generate a regular expression for the RING motif\n    def make_ring_regex(n1_range, n2_range, n3_range, n4_range):\n        pattern = (\n            f\"C..C.{{{n1_range[0]},{n1_range[1]}}}C.{{{n2_range[0]},{n2_range[1]}}}\"\n            f\"H.{{{n3_range[0]},{n3_range[1]}}}C..C.{{{n4_range[0]},{n4_range[1]}}}C..C\"\n        )\n        return re.compile(pattern)\n\n    all_results = []\n    # Process each test case\n    for case_params in test_cases:\n        c2h2_regex = make_c2h2_regex(**case_params[\"c2h2\"])\n        ring_regex = make_ring_regex(**case_params[\"ring\"])\n        \n        current_case_indices = []\n        # Check each sequence against the current test case's motifs\n        for i, seq in enumerate(sequences):\n            has_c2h2 = c2h2_regex.search(seq) is not None\n            has_ring = ring_regex.search(seq) is not None\n            \n            # A sequence passes if it contains at least one of each motif\n            if has_c2h2 and has_ring:\n                current_case_indices.append(i)\n        \n        all_results.append(current_case_indices)\n\n    # Format the final output string as specified: [[a,b],[c,d,e],[f]]\n    # This construction avoids any spaces in the output.\n    result_str = \"[\" + \",\".join(f\"[{','.join(map(str, r))}]\" for r in all_results) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```", "id": "2420143"}, {"introduction": "一个完整的功能结构域通常由多个在空间上邻近、但在序列上被特定长度间隔区隔开的保守基序共同构成。更有趣的是，关键位点（如活性中心）的单个氨基酸突变，就可能使整个结构域丧失功能，形成所谓的“伪结构域”（pseudo-domain）。本练习将让你通过寻找一个典型的激酶结构域指纹——由三个具有严格间隔约束的基序组成的“三联体”——来深入理解这一概念，并学习如何通过检查关键残基来区分有潜在功能的“规范结构域”和可能已失活的“伪结构域”。[@problem_id:2420098]", "problem": "给定一项计算任务，该任务基于以下观察：许多酶促蛋白结构域拥有高度保守的活性位点基序。特别是，蛋白激酶经典地表现出三个保守的短基序，它们沿着一级序列以特征性的间距依次出现：一个位于 $\\beta3$ 链附近的含赖氨酸的基序，一个带有天冬氨酸的催化环基序，以及一个以天冬氨酸开始的激活环基序。您将检测遵守这些保守残基的规范结构域，并识别那些保留了基序背景和间距但在一个或多个关键残基上发生变异的伪结构域。\n\n形式化\n\n- 设 $\\Sigma$ 是 20 种标准氨基酸单字母代码的集合。蛋白质序列是一个从位置 0 开始索引的有限字符串 $S \\in \\Sigma^\\ast$。\n- 定义三个基序字符串：\n  - $M_1 = \\text{\"VAIK\"}$，\n  - $M_2 = \\text{\"HRD\"}$，\n  - $M_3 = \\text{\"DFG\"}$。\n- 定义基序长度 $\\ell_1 = 4$， $\\ell_2 = 3$， $\\ell_3 = 3$。\n- 定义一个有效三联体出现必须同时满足的间隙长度约束：\n  - $g_{12}^{\\min} = 50$， $g_{12}^{\\max} = 70$，\n  - $g_{23}^{\\min} = 20$， $g_{23}^{\\max} = 30$。\n- 对于在起始索引 $p_i$ 处出现的任何 $M_i$（其中 $0 \\le p_i \\le |S| - \\ell_i$），间隙定义为\n  $$g_{12} = p_2 - (p_1 + \\ell_1), \\quad g_{23} = p_3 - (p_2 + \\ell_2)。$$\n  一个有效的有序三联体满足 $p_1  p_2  p_3$ 以及\n  $$g_{12}^{\\min} \\le g_{12} \\le g_{12}^{\\max}, \\quad g_{23}^{\\min} \\le g_{23} \\le g_{23}^{\\max}。$$\n- 关键残基在每个基序内的特定位置定义：\n  - 在 $M_1$ 中，位置 4 的残基（赖氨酸，$\\text{\"K\"}$）是关键的。\n  - 在 $M_2$ 中，位置 3 的残基（天冬氨酸，$\\text{\"D\"}$）是关键的。\n  - 在 $M_3$ 中，位置 1 的残基（天冬氨酸，$\\text{\"D\"}$）是关键的。\n- 定义松弛基序 $M_1^\\ast, M_2^\\ast, M_3^\\ast$，仅将关键位置替换为可匹配任何残基的通配符，所有非关键位置保持不变：\n  - $M_1^\\ast = \\text{\"VAI?\"}$，\n  - $M_2^\\ast = \\text{\"HR?\"}$，\n  - $M_3^\\ast = \\text{\"?FG\"}$。\n- 如果在 S 中存在至少一个与 $M_1, M_2, M_3$ 精确匹配的有效有序三联体（使用上述定义的间隙），则存在一个规范结构域。\n- 如果在 S 中存在至少一个与松弛基序 $M_1^\\ast, M_2^\\ast, M_3^\\ast$ 匹配的有效有序三联体，该三联体满足相同的间隙约束，并且其中至少一个关键残基与其规范身份不同（即，在 $M_1, M_2, M_3$ 中相应关键位置的残基不全等于 $\\text{\"K\"}, \\text{\"D\"}, \\text{\"D\"}$），则存在一个伪结构域。规范结构域不得计为伪结构域。\n\n测试套件的表示法\n\n- 对于任何字符 $X \\in \\Sigma$ 和整数 $n \\ge 0$，令 $X^n$ 表示由字符 $X$ 重复 $n$ 次组成的字符串。\n- 字符串的连接通过简单的并列表示。\n\n测试套件\n\n您必须评估以下五个序列。每个序列都使用重复表示法和简单连接来指定。所有重复都使用字符 $\\text{\"A\"}$。\n\n- $S_1 = \\text{\"A\"}^{10}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{50}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{5}.$\n- $S_2 = \\text{\"A\"}^{8}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{60}\\ \\text{\"HRN\"}\\ \\text{\"A\"}^{25}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{4}.$\n- $S_3 = \\text{\"A\"}^{12}\\ \\text{\"VAIR\"}\\ \\text{\"A\"}^{55}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{7}.$\n- $S_4 = \\text{\"A\"}^{9}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{10}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{30}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{6}.$\n- $S_5 = \\text{\"A\"}^{6}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{52}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{80}\\ \\text{\"VAIR\"}\\ \\text{\"A\"}^{60}\\ \\text{\"HRN\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{3}.$\n\n答案规范\n\n- 对于每个序列 $S_k$，您必须确定两个布尔值：\n  - 根据上述定义，$S_k$ 中是否存在规范结构域；\n  - 根据上述定义，$S_k$ 中是否存在伪结构域。\n- 您的程序必须按 $S_1, S_2, S_3, S_4, S_5$ 的确切顺序处理这五个序列，并生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个序列，将结果对输出为 $\\text{\"[True,False]\"}$、$\\text{\"[False,True]\"}$ 等形式的二元素列表，使用布尔字面量 $\\text{True}$ 和 $\\text{False}$。\n- 具体来说，最终输出必须是表示包含五个对的列表的单行字符串：$\\text{\"[[b_{11},b_{12}],[b_{21},b_{22}],[b_{31},b_{32}],[b_{41},b_{42}],[b_{51},b_{52}]]\"}$，其中每个 $b_{ij}$ 是如上定义的布尔值。\n\n您的程序必须是一个完整的、可运行的程序，无需任何用户输入或外部文件即可执行这些计算。", "solution": "该问题已经过严格验证，被认为是有效的。它在科学上基于计算生物学的原理，特别是通过保守序列基序来识别蛋白质结构域。该问题定义明确，所有参数、约束和目标都具有足够的数学和算法精确性。不存在逻辑矛盾、事实错误或关键歧义。因此，可以推导出解决方案。\n\n任务是确定给定蛋白质序列 $S$ 中是否存在“规范”和“伪”激酶结构域。这些是通过存在由受约束的间隙长度分隔的特定基序的三联体来定义的。\n\n基本方法是在序列中对有效的基序三联体进行组合搜索。该算法分三个阶段进行：\n\n1.  **基序实例识别**：首先，我们必须识别三个基序的所有潜在位置。问题定义了三个规范基序，$M_1 = \\text{\"VAIK\"}$，$M_2 = \\text{\"HRD\"}$ 和 $M_3 = \\text{\"DFG\"}$。它还定义了它们的松弛版本，$M_1^\\ast = \\text{\"VAI?\"}$，$M_2^\\ast = \\text{\"HR?\"}$ 和 $M_3^\\ast = \\text{\"?FG\"}$，其中通配符“?”可以匹配字母表 $\\Sigma$ 中的任何氨基酸。我们将对输入序列 $S$ 进行三次独立的线性扫描，以找到 $M_1^\\ast$、$M_2^\\ast$ 和 $M_3^\\ast$ 的所有出现。对于每个匹配，我们记录其起始位置 $p_i$ 和在关键位置找到的特定氨基酸。设 $\\mathcal{P}_1$、$\\mathcal{P}_2$ 和 $\\mathcal{P}_3$ 为这些发现的集合，其中每个元素都是一个由零基起始索引和关键残基组成的对 $(p_i, c_i)$。\n\n2.  **三联体枚举与验证**：然后我们通过从每个集合中取一个元素来枚举所有可能的基序实例三联体：$(p_1, c_1) \\in \\mathcal{P}_1$，$(p_2, c_2) \\in \\mathcal{P}_2$ 和 $(p_3, c_3) \\in \\mathcal{P}_3$。对于每个候选的基序出现三联体，我们必须根据两组约束对其进行验证：\n    *   **顺序约束**：基序必须沿序列以正确的顺序出现，即 $p_1  p_2  p_3$。\n    *   **间隙长度约束**：分隔基序的残基数量必须在指定范围内。间隙定义为 $g_{12} = p_2 - (p_1 + \\ell_1)$ 和 $g_{23} = p_3 - (p_2 + \\ell_2)$，其中基序长度为 $\\ell_1 = 4$，$\\ell_2 = 3$ 和 $\\ell_3 = 3$。约束条件是 $g_{12}^{\\min} \\le g_{12} \\le g_{12}^{\\max}$ 和 $g_{23}^{\\min} \\le g_{23} \\le g_{23}^{\\max}$，给定值为 $g_{12}^{\\min} = 50$， $g_{12}^{\\max} = 70$， $g_{23}^{\\min} = 20$ 和 $g_{23}^{\\max} = 30$。\n    任何未能满足所有这些条件的三联体都将被丢弃。\n\n3.  **结构域分类**：满足所有顺序和间隙约束的基序实例三联体被视为“有效三联体”。每个有效三联体随后根据其关键残基 $(c_1, c_2, c_3)$ 进行分类。对于 $M_1$，$M_2$ 和 $M_3$，其规范关键残基分别为 'K'、'D' 和 'D'。\n    *   一个有效三联体是**规范的**，当且仅当 $c_1 = \\text{'K'}$，$c_2 = \\text{'D'}$ 且 $c_3 = \\text{'D'}$。\n    *   如果一个有效三联体不是规范的，则它是**伪的**。这意味着其至少一个关键残基偏离了规范身份。\n\n最后，我们确定整个序列 $S$ 的属性。如果找到了至少一个规范三联体，则存在规范结构域。如果找到了至少一个伪三联体，则存在伪结构域。一个序列可能同时包含两者、只包含其一或两者皆无。两个布尔标志 `has_canonical` 和 `has_pseudo` 初始化为 false，并在找到相应类型三联体的第一个实例时设置为 true。序列 $S$ 的最终输出是这两个布尔值的对。对所提供的五个测试序列中的每一个重复整个过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein domain identification problem for a suite of test sequences.\n    \"\"\"\n\n    def generate_sequence(parts):\n        \"\"\"\n        Generates a full protein sequence string from a compact specification.\n        Example part: ('A', 10) for \"AAAAAAAAAA\", or ('VAIK', 1) for \"VAIK\".\n        \"\"\"\n        return \"\".join([char * count for char, count in parts])\n\n    def find_relaxed_matches(sequence, prefix, suffix, length, critical_offset_from_start):\n        \"\"\"\n        Finds all occurrences of a relaxed motif in a sequence.\n        A relaxed motif is defined by a prefix, a suffix, and a total length.\n        The single character between the prefix and suffix is the critical residue.\n        \n        Args:\n            sequence (str): The protein sequence to search.\n            prefix (str): The fixed prefix of the motif.\n            suffix (str): The fixed suffix of the motif.\n            length (int): The total length of the motif.\n            critical_offset_from_start (int): The 0-based index of the critical residue.\n            \n        Returns:\n            list: A list of tuples, where each tuple is (start_index, critical_residue).\n        \"\"\"\n        matches = []\n        len_prefix = len(prefix)\n        len_suffix = len(suffix)\n        \n        if len_prefix + len_suffix != length - 1:\n            raise ValueError(\"Prefix and suffix lengths do not match total length.\")\n\n        for i in range(len(sequence) - length + 1):\n            if sequence[i : i + len_prefix] == prefix and \\\n               sequence[i + length - len_suffix : i + length] == suffix:\n                critical_char = sequence[i + critical_offset_from_start]\n                matches.append((i, critical_char))\n        return matches\n\n    # Test cases defined using the compact notation from the problem statement.\n    test_specs = [\n        # S1\n        [('A', 10), ('VAIK', 1), ('A', 50), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 5)],\n        # S2\n        [('A', 8), ('VAIK', 1), ('A', 60), ('HRN', 1), ('A', 25), ('DFG', 1), ('A', 4)],\n        # S3\n        [('A', 12), ('VAIR', 1), ('A', 55), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 7)],\n        # S4\n        [('A', 9), ('VAIK', 1), ('A', 10), ('HRD', 1), ('A', 30), ('DFG', 1), ('A', 6)],\n        # S5\n        [('A', 6), ('VAIK', 1), ('A', 52), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 80), \n         ('VAIR', 1), ('A', 60), ('HRN', 1), ('A', 20), ('DFG', 1), ('A', 3)]\n    ]\n\n    sequences = [generate_sequence(spec) for spec in test_specs]\n    \n    # Problem constants\n    l1, l2 = 4, 3\n    g12_min, g12_max = 50, 70\n    g23_min, g23_max = 20, 30\n    crit1_char, crit2_char, crit3_char = 'K', 'D', 'D'\n\n    all_results = []\n\n    for S in sequences:\n        # Find all occurrences of the three relaxed motifs\n        # M1* = \"VAI?\", critical residue at 0-based index 3\n        matches1 = find_relaxed_matches(S, prefix=\"VAI\", suffix=\"\", length=4, critical_offset_from_start=3)\n        # M2* = \"HR?\", critical residue at 0-based index 2\n        matches2 = find_relaxed_matches(S, prefix=\"HR\", suffix=\"\", length=3, critical_offset_from_start=2)\n        # M3* = \"?FG\", critical residue at 0-based index 0\n        matches3 = find_relaxed_matches(S, prefix=\"\", suffix=\"FG\", length=3, critical_offset_from_start=0)\n\n        has_canonical = False\n        has_pseudo = False\n\n        # Iterate through all combinations of found motifs to find valid triplets\n        for p1, c1 in matches1:\n            for p2, c2 in matches2:\n                # Enforce order constraint p1  p2\n                if p1 = p2:\n                    continue\n                \n                # Check gap constraint g12\n                g12 = p2 - (p1 + l1)\n                if not (g12_min = g12 = g12_max):\n                    continue\n\n                for p3, c3 in matches3:\n                    # Enforce order constraint p2  p3\n                    if p2 = p3:\n                        continue\n                    \n                    # Check gap constraint g23\n                    g23 = p3 - (p2 + l2)\n                    if not (g23_min = g23 = g23_max):\n                        continue\n\n                    # At this point, a valid triplet (p1, p2, p3) has been found.\n                    # Now, classify it based on critical residues.\n                    is_canonical_triplet = (c1 == crit1_char and c2 == crit2_char and c3 == crit3_char)\n\n                    if is_canonical_triplet:\n                        has_canonical = True\n                    else:\n                        has_pseudo = True\n        \n        all_results.append([has_canonical, has_pseudo])\n\n    # Format the final output string exactly as specified.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2420098"}, {"introduction": "当序列模式的变异性很高，包含不定的插入和缺失时，正则表达式等确定性方法便会捉襟见肘。此时，我们需要更强大的概率模型——轮廓隐马尔可夫模型（profile HMM）。HMM不仅能为每个位置的氨基酸偏好建模，还能对序列中可能出现的插入和缺失进行概率打分，从而为一个序列是否属于某个蛋白质家族提供一个统计上更鲁棒的评估。本练习将通过一个简化的病毒RNA聚合酶核心结构域的HMM，引导你实现一个类Viterbi算法的核心逻辑，计算序列与模型匹配的对数奇比分（log-odds score），从而亲身体验像HMMER这样的专业工具背后的基本原理。[@problem_id:2420110]", "problem": "您将获得一个简化的、完全指定的轮廓隐马尔可夫模型 (HMM)，该模型用于病毒RNA依赖性RNA聚合酶的保守掌状结构域核心，并专注于三个标志性基序。该模型用于判断蛋白质序列是否包含与此结构域一致的局部子序列。目标是为每个提供的序列计算，是否存在一个连续子序列，其相对于均匀背景的对数几率得分至少达到指定的阈值。\n\n字母表与背景模型：\n- 氨基酸字母表是包含 $20$ 个标准大写字母的集合 $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{K}, \\mathrm{L}, \\mathrm{M}, \\mathrm{N}, \\mathrm{P}, \\mathrm{Q}, \\mathrm{R}, \\mathrm{S}, \\mathrm{T}, \\mathrm{V}, \\mathrm{W}, \\mathrm{Y} \\}$。\n- 此外，符号 $\\mathrm{X}$ 表示一个未知残基，其发射概率必须与背景相同。\n- 背景模型是一个独立同分布过程，对于 $20$ 字母表中的每个字母，其概率为 $1/20$。对于 $\\mathrm{X}$，也使用 $1/20$。\n- 所有对数必须是自然对数。\n\nHMM结构：\n- HMM具有以下发射状态：$\\mathrm{MA1}, \\mathrm{MA2}, \\mathrm{MA3}, \\mathrm{MA4}, \\mathrm{MA5}, \\mathrm{IA}, \\mathrm{MB1}, \\mathrm{MB2}, \\mathrm{MB3}, \\mathrm{MB4}, \\mathrm{IB}, \\mathrm{MC1}, \\mathrm{MC2}, \\mathrm{MC3}$。\n- HMM在发射 $\\mathrm{MA1}$ 之前进入，并在发射 $\\mathrm{MC3}$ 后立即退出。在发射过程中没有非发射状态；开始和结束是隐式的。\n- 允许的转移及其概率：\n  - $\\mathrm{MA1} \\to \\mathrm{MA2}$，概率为 $1$。\n  - $\\mathrm{MA2} \\to \\mathrm{MA3}$，概率为 $1$。\n  - $\\mathrm{MA3} \\to \\mathrm{MA4}$，概率为 $1$。\n  - $\\mathrm{MA4} \\to \\mathrm{MA5}$，概率为 $1$。\n  - $\\mathrm{MA5} \\to \\mathrm{MB1}$，概率为 $0.7$。\n  - $\\mathrm{MA5} \\to \\mathrm{IA}$，概率为 $0.3$。\n  - $\\mathrm{IA} \\to \\mathrm{IA}$，概率为 $0.8$。\n  - $\\mathrm{IA} \\to \\mathrm{MB1}$，概率为 $0.2$。\n  - $\\mathrm{MB1} \\to \\mathrm{MB2}$，概率为 $1$。\n  - $\\mathrm{MB2} \\to \\mathrm{MB3}$，概率为 $1$。\n  - $\\mathrm{MB3} \\to \\mathrm{MB4}$，概率为 $1$。\n  - $\\mathrm{MB4} \\to \\mathrm{MC1}$，概率为 $0.7$。\n  - $\\mathrm{MB4} \\to \\mathrm{IB}$，概率为 $0.3$。\n  - $\\mathrm{IB} \\to \\mathrm{IB}$，概率为 $0.8$。\n  - $\\mathrm{IB} \\to \\mathrm{MC1}$，概率为 $0.2$。\n  - $\\mathrm{MC1} \\to \\mathrm{MC2}$，概率为 $1$。\n  - $\\mathrm{MC2} \\to \\mathrm{MC3}$，概率为 $1$。\n- 任何未列出的转移都是不允许的（概率为 $0$）。\n\n发射：\n- 对于状态 $\\mathrm{MA1}$、$\\mathrm{MB1}$、$\\mathrm{MC1}$、$\\mathrm{MC2}$ 和 $\\mathrm{MC3}$，预期会有一个共有残基。发射概率为：\n  - 如果观察到的残基等于共有字母，则发射概率为 $0.9$。\n  - 如果观察到的残基是字母表中其他 $19$ 个字母之一且不等于共有字母，则发射概率为 $0.1/19$。\n  - 如果观察到的残基是 $\\mathrm{X}$，则发射概率为 $1/20$。\n- 共有字母为：\n  - $\\mathrm{MA1}$ 预期为 $\\mathrm{D}$。\n  - $\\mathrm{MB1}$ 预期为 $\\mathrm{G}$。\n  - $\\mathrm{MC1}$ 预期为 $\\mathrm{G}$。\n  - $\\mathrm{MC2}$ 预期为 $\\mathrm{D}$。\n  - $\\mathrm{MC3}$ 预期为 $\\mathrm{D}$。\n- 对于所有其他发射状态 $\\mathrm{MA2}, \\mathrm{MA3}, \\mathrm{MA4}, \\mathrm{MA5}, \\mathrm{MB2}, \\mathrm{MB3}, \\mathrm{MB4}, \\mathrm{IA}, \\mathrm{IB}$，发射分布在字母表上是均匀的，即对于 $20$ 个字母中的任何一个，概率为 $1/20$。对于 $\\mathrm{X}$，也使用 $1/20$。\n\n评分与决策规则：\n- 对于一个给定的蛋白质序列，考虑其每个连续子序列。对于任何长度为 $L$ 的子序列，令 $P_{\\mathrm{HMM}}$ 表示由任何从 $\\mathrm{MA1}$ 开始、在 $\\mathrm{MC3}$ 结束、精确发射 $L$ 个残基并遵守上述所有转移约束和发射概率的有效路径生成该子序列的最大概率。令 $P_{\\mathrm{BG}}$ 表示在均匀独立模型下该相同子序列的背景概率，即 $P_{\\mathrm{BG}} = (1/20)^L$。\n- 将该子序列的对数几率得分定义为\n$$\n\\mathrm{LLR} = \\ln P_{\\mathrm{HMM}} - \\ln P_{\\mathrm{BG}}。\n$$\n- 对于该序列，将其最终得分定义为所有连续子序列中的最大 $\\mathrm{LLR}$。\n- 使用阈值 $T = 5.0$。如果最大 $\\mathrm{LLR} \\ge T$，则将该序列分类为包含该结构域（布尔值 $\\mathrm{True}$）；否则分类为不包含该结构域（布尔值 $\\mathrm{False}$）。\n\n测试套件：\n- 使用以下蛋白质序列（字符串）的有序列表。字母表受前述限制，任何 $\\mathrm{X}$ 表示一个未知残基，需按规定处理。\n  - 案例 $1$：$\\mathrm{DAAAAGAAAGDD}$\n  - 案例 $2$：$\\mathrm{MTRNAVDPQMDKSTADGAAAGDDQL}$\n  - 案例 $3$：$\\mathrm{ACFLKPNRTSVYHMIQLKTAACFLKPNR}$\n  - 案例 $4$：$\\mathrm{DAAAADVVVVVLLLLLPPPPPSSSSSTTTTTGAAAVVVVVLLLLLPPPPPSSSSSTTTTTGDD}$\n  - 案例 $5$：$\\mathrm{XAAAADGAAAGDX}$\n  - 案例 $6$：$\\mathrm{DGGD}$\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，顺序与测试套件相同。每个结果必须是布尔值，渲染为 $\\mathrm{True}$ 或 $\\mathrm{False}$，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$。", "solution": "该问题要求根据一个代表保守蛋白质结构域的简化轮廓隐马尔可夫模型（HMM）来验证蛋白质序列。任务是确定每个序列中是否存在任何连续子序列，其对数几率得分至少达到给定阈值 $T = 5.0$。该得分是通过比较子序列由HMM生成的最大概率 $P_{\\mathrm{HMM}}$ 与其在均匀背景模型下的概率 $P_{\\mathrm{BG}}$ 来计算的。\n\n首先，我们将问题形式化。对于长度为 $L$ 的子序列 $S'$，其对数几率得分 LLR 由下式给出：\n$$ \\mathrm{LLR} = \\ln P_{\\mathrm{HMM}}(S') - \\ln P_{\\mathrm{BG}}(S') $$\n背景模型是均匀的，所以 $P_{\\mathrm{BG}}(S') = (1/20)^L$。其对数为 $\\ln P_{\\mathrm{BG}}(S') = L \\ln(1/20) = -L \\ln(20)$。\nHMM概率 $P_{\\mathrm{HMM}}(S')$ 是在所有从状态 $\\mathrm{MA1}$ 开始到状态 $\\mathrm{MC3}$ 结束、长度为 $L$ 的可能路径 $\\pi$ 上的最大概率：\n$$ P_{\\mathrm{HMM}}(S') = \\max_{\\pi: \\pi_0=\\mathrm{MA1}, \\pi_{L-1}=\\mathrm{MC3}} \\left( \\prod_{k=0}^{L-1} P_{\\text{emission}}(S'_k | \\pi_k) \\prod_{k=0}^{L-2} P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) $$\n将这些代入LLR方程并利用对数的性质，我们得到：\n$$ \\mathrm{LLR} = \\max_{\\pi} \\left( \\sum_{k=0}^{L-1} \\ln P_{\\text{emission}}(S'_k | \\pi_k) + \\sum_{k=0}^{L-2} \\ln P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) + L \\ln(20) $$\n这可以重排为对数几率发射得分和对数转移概率的总和：\n$$ \\mathrm{LLR} = \\max_{\\pi} \\left( \\sum_{k=0}^{L-1} \\left( \\ln P_{\\text{emission}}(S'_k | \\pi_k) + \\ln(20) \\right) + \\sum_{k=0}^{L-2} \\ln P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) $$\n令残基 $c$ 在状态 $k$ 的对数几率发射得分为 $E(c, k) = \\ln(P_{\\text{emission}}(c | k) \\times 20)$，对数转移概率为 $T(j, k) = \\ln P_{\\text{transition}}(k | j)$。问题是在输入蛋白质的所有连续子序列中找到最大的LLR。\n\n遍历所有子序列的暴力方法在计算上是不可行的。一个更高效的解决方案利用动态规划，具体来说是一种为局部比对检测而修改的类Viterbi算法。我们定义一个DP表 $V[i][k]$，用于存储任何以状态 $k$ 结束、并已发射输入序列 $S$ 的第 $i$ 个残基的路径的最大对数几率得分。比对的“局部”性质通过允许在序列的任何位置开始新的比对来处理，这对应于在起始状态 $\\mathrm{MA1}$ 中初始化一条路径。\n\nHMM的状态从 $0$ 到 $13$ 进行索引。设状态集为 $\\mathcal{K} = \\{ \\mathrm{MA1}, \\dots, \\mathrm{MC3} \\}$。DP表 $V$ 的维度为 $N \\times |\\mathcal{K}|$，其中 $N$ 是序列 $S=S_0S_1...S_{N-1}$ 的长度。\n\n递推关系如下：\n对于初始状态 $\\mathrm{MA1}$，比对可以在任何位置 $i$ 开始：\n$$ V[i][\\mathrm{MA1}] = E(S_i, \\mathrm{MA1}) $$\n对于任何其他状态 $k \\in \\mathcal{K} \\setminus \\{\\mathrm{MA1}\\}$，得分是根据其前驱状态在上一位置 $i-1$ 的得分计算的：\n$$ V[i][k] = E(S_i, k) + \\max_{j \\in \\text{Pred}(k)} \\left( V[i-1][j] + T(j, k) \\right) \\quad \\text{for } i > 0 $$\n其中 $\\text{Pred}(k)$ 是可以转移到状态 $k$ 的状态集合。对于 $i=0$，$V[0][k] = -\\infty$ for $k \\ne \\mathrm{MA1}$，因为任何路径都必须从 $\\mathrm{MA1}$ 开始。\n\n对数几率发射得分 $E(c, k)$ 是预先计算的：\n- 对于共有状态 ($\\mathrm{MA1}, \\mathrm{MB1}, \\mathrm{MC1}, \\mathrm{MC2}, \\mathrm{MC3}$):\n  - 匹配：$\\ln(0.9 \\times 20) = \\ln(18) \\approx 2.8904$\n  - 错配：$\\ln((0.1/19) \\times 20) = \\ln(2/19) \\approx -2.2513$\n  - 未知 ('$\\mathrm{X}$'): $\\ln((1/20) \\times 20) = \\ln(1) = 0$\n- 对于均匀状态（所有其他状态）:\n  - 任何残基：$\\ln((1/20) \\times 20) = \\ln(1) = 0$\n\n对数转移概率 $T(j, k)$ 也是预先计算的：\n- $P=1 \\implies T = \\ln(1) = 0$\n- $P=0.8 \\implies T = \\ln(0.8) \\approx -0.2231$\n- $P=0.7 \\implies T = \\ln(0.7) \\approx -0.3567$\n- $P=0.3 \\implies T = \\ln(0.3) \\approx -1.2040$\n- $P=0.2 \\implies T = \\ln(0.2) \\approx -1.6094$\n\n算法通过从 $i=0$ 到 $N-1$ 遍历序列来填充DP表 $V$。在每个位置 $i$，我们计算所有状态 $k$ 的 $V[i][k]$。问题规定，结构域的有效路径必须在状态 $\\mathrm{MC3}$ 结束。因此，在计算完位置 $i$ 的所有得分后，我们用 $V[i][\\mathrm{MC3}]$ 的值更新一个运行中的最大得分 $\\mathrm{LLR}_{\\max}$。\n$$ \\mathrm{LLR}_{\\max} = \\max_{i \\in [0, N-1]} V[i][\\mathrm{MC3}] $$\n最初，$\\mathrm{LLR}_{\\max}$ 被设置为 $-\\infty$。在遍历整个序列后，将最终的 $\\mathrm{LLR}_{\\max}$ 与阈值 $T=5.0$ 进行比较。如果 $LLR_{\\max} \\ge T$，则该序列被分类为包含该结构域 (True)；否则，不包含 (False)。此过程应用于测试套件中的每个序列。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein domain identification problem using a Viterbi-like algorithm.\n    \"\"\"\n    \n    # Define problem parameters\n    THRESHOLD = 5.0\n    ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"\n    STATES = [\n        \"MA1\", \"MA2\", \"MA3\", \"MA4\", \"MA5\", \"IA\", \n        \"MB1\", \"MB2\", \"MB3\", \"MB4\", \"IB\", \n        \"MC1\", \"MC2\", \"MC3\"\n    ]\n    CONSENSUS_SPEC = {\n        'MA1': 'D', 'MB1': 'G', 'MC1': 'G', 'MC2': 'D', 'MC3': 'D'\n    }\n    \n    TRANSITIONS = [\n        ('MA1', 'MA2', 1.0), ('MA2', 'MA3', 1.0), ('MA3', 'MA4', 1.0), ('MA4', 'MA5', 1.0),\n        ('MA5', 'MB1', 0.7), ('MA5', 'IA', 0.3),\n        ('IA', 'IA', 0.8), ('IA', 'MB1', 0.2),\n        ('MB1', 'MB2', 1.0), ('MB2', 'MB3', 1.0), ('MB3', 'MB4', 1.0),\n        ('MB4', 'MC1', 0.7), ('MB4', 'IB', 0.3),\n        ('IB', 'IB', 0.8), ('IB', 'MC1', 0.2),\n        ('MC1', 'MC2', 1.0), ('MC2', 'MC3', 1.0),\n    ]\n\n    # Pre-computation\n    # 1. Mappings\n    state_map = {name: i for i, name in enumerate(STATES)}\n    num_states = len(STATES)\n    char_map = {c: i for i, c in enumerate(ALPHABET)}\n    char_map['X'] = 20\n    \n    # 2. Log-odds emission scores\n    log_emission_scores = np.full((num_states, 21), 0.0) # Default is uniform, log-odds = 0\n    for state_name, cons_char in CONSENSUS_SPEC.items():\n        state_idx = state_map[state_name]\n        cons_char_idx = char_map[cons_char]\n        for char_code in range(21):\n            if char_code == 20: # 'X'\n                log_emission_scores[state_idx, char_code] = 0.0\n            elif char_code == cons_char_idx:\n                log_emission_scores[state_idx, char_code] = np.log(0.9 * 20) # Match\n            else:\n                log_emission_scores[state_idx, char_code] = np.log((0.1 / 19) * 20) # Mismatch\n\n    # 3. Log-transition probabilities and predecessor structure\n    predecessors = {i: [] for i in range(num_states)}\n    for from_s, to_s, prob in TRANSITIONS:\n        log_prob = np.log(prob)\n        predecessors[state_map[to_s]].append((state_map[from_s], log_prob))\n\n    test_cases = [\n        \"DAAAAGAAAGDD\",\n        \"MTRNAVDPQMDKSTADGAAAGDDQL\",\n        \"ACFLKPNRTSVYHMIQLKTAACFLKPNR\",\n        \"DAAAADVVVVVLLLLLPPPPPSSSSSTTTTTGAAAVVVVVLLLLLPPPPPSSSSSTTTTTGDD\",\n        \"XAAAADGAAAGDX\",\n        \"DGGD\",\n    ]\n\n    results = []\n    \n    s_idx_ma1 = state_map['MA1']\n    s_idx_mc3 = state_map['MC3']\n\n    for seq in test_cases:\n        seq_len = len(seq)\n        if seq_len == 0:\n            results.append(False)\n            continue\n\n        V = np.full((seq_len, num_states), -np.inf)\n        max_llr = -np.inf\n\n        for i in range(seq_len):\n            char_idx = char_map.get(seq[i])\n\n            # Recurrence for MA1 (start of a local alignment)\n            V[i, s_idx_ma1] = log_emission_scores[s_idx_ma1, char_idx]\n            \n            # Recurrence for other states\n            if i  0:\n                for k in range(num_states):\n                    if k == s_idx_ma1: continue \n                    \n                    max_prev_score = -np.inf\n                    if predecessors[k]:\n                        for pred_idx, log_trans_prob in predecessors[k]:\n                            score = V[i-1, pred_idx] + log_trans_prob\n                            if score  max_prev_score:\n                                max_prev_score = score\n                    \n                    if max_prev_score  -np.inf:\n                         V[i, k] = max_prev_score + log_emission_scores[k, char_idx]\n            \n            # Check for new max score at the final state\n            if V[i, s_idx_mc3]  max_llr:\n                max_llr = V[i, s_idx_mc3]\n\n        results.append(max_llr = THRESHOLD)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2420110"}]}