{"hands_on_practices": [{"introduction": "在运行任何肽谱匹配分析之前，最关键的第一步是正确地配置我们的搜索参数，以反映实验设计的具体细节。本练习模拟了一个在定量蛋白质组学中常见的场景——使用细胞培养中氨基酸稳定同位素标记（SILAC）技术。通过解决这个问题 ([@problem_id:2433525])，你将学会区分“固定修饰”和“可变修饰”的设置，并理解这一选择如何直接影响搜索空间以及我们能否成功鉴定出不同实验组的肽段。", "problem": "您正在通过串联质谱 (MS/MS) 分析一个经过胰蛋白酶消化的蛋白质组（在赖氨酸和精氨酸之后进行切割，但脯氨酸之前的位点不切割）。该实验使用细胞培养中氨基酸稳定同位素标记 (SILAC) 技术，其中一个细胞群体在轻型培养基中生长，另一个细胞群体在含有 $^{13}\\mathrm{C}_{6}{}^{15}\\mathrm{N}_{4}$-精氨酸 的重型培养基中生长，这导致每个掺入的精氨酸残基质量增加 $+10.008$ 道尔顿 (Da)。在进行液相色谱-质谱联用分析之前，将两种细胞群体以 $1\\!:\\!1$ 的比例混合，因此数据包含肽段的轻型和重型两种版本。您将执行数据库搜索以进行肽段-谱图匹配。\n\n假设蛋氨酸 (Methionine) 上的标准可变氧化修饰和半胱氨酸 (Cysteine) 上的固定碳酰胺甲基化修饰已经配置好。实验中没有使用赖氨酸标记。为了在本次实验中正确处理 SILAC 标记，对您的搜索参数进行哪项单一更改最为合适？\n\nA. 在精氨酸残基上添加 $+10.008$ Da 作为可变修饰。\n\nB. 在精氨酸残基上添加 $+10.008$ Da 作为固定修饰，并在肽段 N 端添加其作为可变修饰。\n\nC. 不添加任何修饰；而是增加母离子质量容差以涵盖 $+10.008$ Da 的质量偏移。\n\nD. 在赖氨酸和精氨酸残基上都添加 $+10.008$ Da 作为可变修饰，因为胰蛋白酶会在这两种氨基酸之后进行切割。", "solution": "必须首先验证问题陈述的科学合理性、清晰度和完整性。\n\n**步骤 1：提取已知条件**\n- **分析技术**：串联质谱 (MS/MS)。\n- **酶切**：胰蛋白酶 (Trypsin)，在赖氨酸 (K) 和精氨酸 (R) 的 C 端进行切割，除非其后是脯氨酸 (P)。\n- **标记方法**：细胞培养中氨基酸稳定同位素标记 (SILAC)。\n- **实验组**：两个细胞群体，一个“轻型”和一个“重型”。\n- **重同位素**：$^{13}\\mathrm{C}_{6}{}^{15}\\mathrm{N}_{4}$-精氨酸。\n- **重标记的质量偏移**：每个精氨酸 (R) 残基 $+10.008$ 道尔顿 (Da)。\n- **样品组成**：分析前轻型和重型群体以 $1:1$ 比例混合。\n- **数据内容**：数据中同时存在对应于轻型和重型肽段的谱图。\n- **分析目标**：执行数据库搜索以进行肽段-谱图匹配 (PSM)。\n- **预设搜索参数**：\n    - 可变修饰：蛋氨酸 (Methionine) 的氧化。\n    - 固定修饰：半胱氨酸 (Cysteine) 的碳酰胺甲基化。\n- **明确条件**：未使用赖氨酸标记。\n- **问题**：确定最合适的单一搜索参数更改，以处理指定的 SILAC 标记。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题描述了一个使用 SILAC 的标准定量蛋白质组学实验。\n- **科学依据**：所述原理是合理的。SILAC 是一种广泛使用的代谢标记技术。为 $^{13}\\mathrm{C}_{6}{}^{15}\\mathrm{N}_{4}$-精氨酸 提供的质量偏移 ($+10.008$ Da) 是实践中使用的正确名义质量差（精确的单同位素质量差为 $6 \\times (\\text{mass}(^{13}\\mathrm{C}) - \\text{mass}(^{12}\\mathrm{C})) + 4 \\times (\\text{mass}(^{15}\\mathrm{N}) - \\text{mass}(^{14}\\mathrm{N})) \\approx 10.00827$ Da）。对胰蛋白酶特异性的描述是正确的。混合细胞群体并进行 LC-MS/MS 的整体工作流程是标准方法。\n- **问题的适定性**：这个问题是适定的。它要求为明确定义的实验设置提供最佳的搜索参数配置。对于这种情况，存在一个标准的、计算上公认的“最佳实践”，从而得出一个唯一且有意义的答案。\n- **客观性**：该问题使用生物信息学和蛋白质组学领域常见的精确、客观和技术性语言进行陈述。没有模糊性或主观性。\n\n**步骤 3：结论与行动**\n问题陈述在科学上是有效的、适定的且无歧义的。我将继续进行解答。\n\n**解题推导**\n数据库搜索的目标是将实验得到的 MS/MS 谱图与数据库中的理论肽段序列进行匹配。在此实验中，样品包含来自两个细胞群体的蛋白质组的 $1:1$ 混合物。\n1.  **轻型群体**：所有蛋白质均由天然丰度的同位素组成。一个含精氨酸的肽段具有“轻”质量 $M_{light}$。\n2.  **重型群体**：所有蛋白质中的所有精氨酸残基都已被重同位素变体 $^{13}\\mathrm{C}_{6}{}^{15}\\mathrm{N}_{4}$-精氨酸 替代。一个含有 $n$ 个精氨酸残基的肽段将具有“重”质量 $M_{heavy} = M_{light} + n \\times 10.008$ Da。\n\n由于样品是混合物，质谱仪将测量每个含精氨酸肽段的轻型和重型版本的母离子和碎片离子。因此，数据库搜索软件必须配置为搜索这两种可能性。\n\n我们必须考虑搜索软件中的修饰类型：\n-   **固定修饰** (fixed modification) 告知软件指定氨基酸的*每一个*实例都带修饰。如果我们将 $+10.008$ Da 的质量偏移在精氨酸上设置为固定修饰，软件将仅搜索重型肽段。这将导致无法鉴定出任何来自轻型群体的肽段，而这部分肽段占样品的一半。这种方法是错误的。\n-   **可变修饰** (variable modification) （或潜在修饰）告知软件要同时考虑两种可能性：氨基酸可能未被修饰，也可能已被修饰。当软件考虑来自数据库的理论肽段时，它将计算该可变修饰所有组合的理论碎片质量。对于含有一个精氨酸的肽段，它将搜索未修饰（轻型）形式和已修饰（重型）形式。对于含有两个精氨酸的肽段，它将搜索具有零个、一个或两个修饰的形式。这种搜索策略正确地覆盖了样品中存在的生物学上相关的形式：完全轻型（零修饰）和完全重型（所有精氨酸均被修饰）。\n\n因此，配置搜索最合适的方法是将 $+10.008$ Da 的质量偏移定义为**精氨酸上的可变修饰**。\n\n**选项评估**\n\n**A. 在精氨酸残基上添加 $+10.008$ Da 作为可变修饰。**\n此配置允许搜索引擎测试理论肽段中每个精氨酸残基上是否存在重标记。这使得从轻型群体（其中精氨酸上不会发现修饰）和重型群体（其中所有精氨酸都将被发现带有修饰）中鉴定肽段成为可能。这是分析此类 SILAC 数据的标准且正确的程序。\n**结论：正确。**\n\n**B. 在精氨酸残基上添加 $+10.008$ Da 作为固定修饰，并在肽段 N 端添加其作为可变修饰。**\n将精氨酸修饰设置为*固定*修饰是根本错误的，因为它会排除对轻型肽段的鉴定。样品明确是轻型和重型细胞的 $1:1$ 混合物。此外，标记是在蛋白质合成过程中掺入精氨酸残基的，而不是在翻译后或通过化学方法添加到肽段 N 端的。对于此实验设计，N 端修饰是不相关的，并且在事实上是错误的。\n**结论：错误。**\n\n**C. 不添加任何修饰；而是增加母离子质量容差以涵盖 $+10.008$ Da 的质量偏移。**\n母离子质量容差是一个窄窗口（通常在百万分率，即 ppm，范围内），用于将高精度的实验母离子质量与理论质量进行匹配。与典型的容差相比，$+10.008$ Da 的质量偏移是巨大的。对于质量为 $1200$ Da 的肽段，此偏移对应于 $(10.008 / 1200) \\times 10^6 \\approx 8340$ ppm。将容差扩大到如此程度将导致每个实验谱图与大量不相关的肽段匹配，从而导致模糊性和假阳性率的爆炸式增长。其结果将毫无意义。特定的修饰必须作为离散的质量偏移来处理，而不是通过降低质量精度来处理。\n**结论：错误。**\n\n**D. 在赖氨酸和精氨酸残基上都添加 $+10.008$ Da 作为可变修饰，因为胰蛋白酶会在这两种氨基酸之后进行切割。**\n问题陈述明确指出重标记是 $^{13}\\mathrm{C}_{6}{}^{15}\\mathrm{N}_{4}$-**精氨酸**，并且关键地指出 **“未使用赖氨酸标记”**。因此，指示软件搜索赖氨酸上的修饰与已知的实验事实相悖。虽然胰蛋白酶的切割特异性与这两种氨基酸都有关，但同位素标记并非如此。这样做会不必要地增加搜索空间和复杂性，并且对于给定的设置来说，在事实上是错误的。\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2433525"}, {"introduction": "肽谱匹配的核心是评分函数——一种量化理论肽段与观测质谱图匹配优良程度的算法。这个动手实践将引导你从第一性原理出发，构建一个完整的评分函数 ([@problem_id:2413479])。你将学习如何通过一个有原则的数学变换（如对数优势比），将预测的肽键断裂概率 $q_i$ 转化为可加的证据权重，并结合观测到的峰强度 $I_\\ell$ 来进行加权，最终得到总分。通过亲手编写这个核心引擎，你将不再把分析软件看作一个“黑箱”，而是深刻理解一个肽谱匹配分数背后真正的含义。", "problem": "您的任务是设计并实现一种肽谱匹配得分函数，该函数根据相应肽键的预测碎裂概率，对理论肽段碎裂与观测到的串联质谱之间的共享峰进行加权。目标是从肽段碎裂和质谱学的核心定义出发，并从第一性原理推导出一个加性评分函数，该函数将每个肽键的碎裂概率转换为每个匹配的理论碎片离子的加性证据贡献。您的实现必须反映从肽键层面概率到加性得分的有原则的转换，并且必须以科学上合理的方式整合观测到的峰强度。\n\n请使用以下在计算蛋白质组学和质谱学中标准的基本依据和约束：\n- 长度为 $L$ 的肽段有 $L-1$ 个肽键。在肽键索引 $i \\in \\{1,\\dots,L-1\\}$ 处的断裂会产生一个 $b_i$ 型的前缀离子和一个 $y_{L-i}$ 型的后缀离子。对于单电荷离子，使用单同位素质量计算单同位素质荷比。\n- 对于肽段序列 $P = (a_1 a_2 \\dots a_L)$，其氨基酸单同位素质量为 $m(a_k)$（单位为道尔顿），定义单电荷 $b$ 离子质量为\n$$\nm(b_i) = \\left(\\sum_{k=1}^{i} m(a_k)\\right) + m_p,\n$$\n定义单电荷 $y$ 离子质量为\n$$\nm(y_j) = \\left(\\sum_{k=L-j+1}^{L} m(a_k)\\right) + m_{\\mathrm{H_2O}} + m_p,\n$$\n其中 $m_p$ 是质子质量，$m_{\\mathrm{H_2O}}$ 是水的质量。所有 $m/z$ 值均以道尔顿为单位处理，所有强度均为无物理单位的正实数。\n- 一个观测到的串联质谱被建模为一个有限的峰集合 $\\{(x_\\ell, I_\\ell)\\}_{\\ell=1}^N$，其中每个 $x_\\ell$ 是一个以道尔顿为单位的 $m/z$ 值，每个 $I_\\ell$ 是一个正强度。如果 $|x - m_{\\mathrm{th}}| \\le \\tau$，则认为理论离子质量 $m_{\\mathrm{th}}$ 与观测峰 $(x,I)$ 匹配，其中 $\\tau$ 是给定的非负容差（单位为道尔顿）。如果同一理论离子在容差范围内有多个观测峰，则选择绝对误差 $|x - m_{\\mathrm{th}}|$ 最小的那个；如果绝对误差完全相同，则选择强度较大的那个。每个观测峰最多只能与一个理论离子匹配。为保证确定性，按理论离子的理论 $m/z$ 升序处理。\n- 每个肽键 $i$ 都被赋予一个预测的碎裂概率 $q_i \\in [0,1]$，该概率量化了肽键 $i$ 在仪器中发生碎裂的可能性。您的评分函数必须将这些概率转换为每个匹配的理论离子的加性证据权重，该权重取决于 $q_i$ 和匹配的观测强度。如果 $q_i$ 等于 $0$ 或 $1$，您的实现必须在进行任何转换之前通过将其裁剪到闭区间 $[\\varepsilon,1-\\varepsilon]$（其中 $\\varepsilon = 10^{-6}$）来避免无穷大。\n\n您必须满足的基于原则的设计要求：\n- 肽谱对的得分必须是所有匹配的理论离子的加性总和。未匹配的离子或未匹配的峰不得有任何贡献。\n- 由肽键 $i$ 产生的匹配离子的贡献必须是 $q_i$ 的严格递增函数，并且必须与通过加法组合跨离子的独立证据片段的方式相一致。从 $q_i$ 到加性贡献的映射必须根据概率和统计的第一性原理推导得出，使用的变换必须因其能够以加法方式组合独立证据而具备合理性。\n- 观测峰强度必须以一种由噪声或变异性模型证明其合理性的方式来调节匹配的贡献，并且必须对所有强度统一乘以一个公共正因子进行重新缩放时保持不变。为确保数值稳定性和有界动态范围，在将强度用于贡献函数之前，通过总离子流 $\\sum_{\\ell=1}^{N} I_\\ell$ 对强度进行归一化；然后对归一化强度应用一个凹的、单调的变换，以有原则的方式降低极大峰的权重。\n\n需实现的算法规则：\n- 使用下面指定的氨基酸质量和常数，计算所有单电荷 $b$ 离子和 $y$ 离子的理论质量。\n- 使用上述容差规则和平局打破约定，生成与观测谱图的匹配。确保每个观测峰最多只使用一次。\n- 对于与肽键索引 $i$ 相关联的每个匹配，使用该肽键的概率 $q_i$ 结合匹配峰的归一化强度的凹的、单调的函数来计算其贡献。将所有贡献相加，得到肽谱对的最终得分。如果没有匹配，得分必须为 $0$。\n\n需使用的常数和氨基酸单同位素质量（单位：道尔顿）：\n- 质子质量 $m_p = 1.007276$。\n- 水质量 $m_{\\mathrm{H_2O}} = 18.010565$。\n- $20$ 种标准氨基酸的单同位素残基质量 $m(a)$：\n  - $A: 71.03711$, $R: 156.10111$, $N: 114.04293$, $D: 115.02694$, $C: 103.00919$, $E: 129.04259$, $Q: 128.05858$, $G: 57.02146$, $H: 137.05891$, $I: 113.08406$, $L: 113.08406$, $K: 128.09496$, $M: 131.04049$, $F: 147.06841$, $P: 97.05276$, $S: 87.03203$, $T: 101.04768$, $W: 186.07931$, $Y: 163.06333$, $V: 99.06841$。\n\n需实现和评估的测试套件：\n- 案例 1 (一般情况):\n  - 肽段: $P_1 = \\mathrm{PEPTIDE}$，其 $q = [0.2, 0.6, 0.85, 0.3, 0.75, 0.5]$。\n  - 容差 $\\tau = 0.5$ 道尔顿。\n  - 观测质谱峰 $(x,I)$（单位：道尔顿）:\n    - $(324.20, 1500)$, $(574.10, 300)$, $(538.787126, 800)$, $(263.40, 1200)$, $(200.0, 100)$, $(700.0, 50)$, $(98.060036, 400)$, $(703.310461, 600)$。\n- 案例 2 (概率极值和边界匹配):\n  - 肽段: $P_2 = \\mathrm{AAAA}$，其 $q = [0.01, 0.99, 1.0]$。\n  - 容差 $\\tau = 0.3$ 道尔顿。\n  - 观测质谱峰:\n    - $(72.0445, 100)$, $(161.392061, 500)$, $(214.6, 250)$, $(400.0, 1000)$。\n- 案例 3 (无共享峰):\n  - 肽段: $P_3 = \\mathrm{MASS}$，其 $q = [0.4, 0.4, 0.4]$。\n  - 容差 $\\tau = 0.4$ 道尔顿。\n  - 观测质谱峰:\n    - $(50.0, 100)$, $(100.0, 200)$, $(150.0, 300)$, $(1000.0, 400)$。\n- 案例 4 (容差边界和等距平局打破):\n  - 肽段: $P_4 = \\mathrm{GAS}$，其 $q = [0.5, 0.9]$。\n  - 容差 $\\tau = 0.25$ 道尔顿。\n  - 观测质谱峰:\n    - $(129.315846, 100)$, $(128.815846, 200)$, $(106.199871, 120)$, $(300.0, 50)$, $(90.0, 80)$。\n\n要求的最终输出格式：\n- 您的程序必须按给定顺序计算四个案例的得分，并打印一行包含四个得分的 Python 风格列表，以十进制数表示，不含任何额外文本。例如，打印\n$$\n[\\text{score}_1,\\text{score}_2,\\text{score}_3,\\text{score}_4]\n$$\n于一行。得分必须是实数。所有内部计算必须使用道尔顿作为 $m/z$ 和容差的单位。除了 Python 对浮点数的默认字符串转换外，不要对数字进行四舍五入或格式化。\n\n附加说明：\n- 仅在单电荷近似下处理串联质谱 (MS/MS)。\n- 算法必须是自包含的，不应要求任何用户输入或外部文件。", "solution": "该问题要求基于质谱学和统计证据的基本原理，设计并实现一个肽谱匹配得分函数。问题陈述经确认为科学上可靠、定义明确、客观且完整。它提供了所有必要的数据、常数以及清晰、确定性的实现规则。因此，可以构建一个有效的解决方案。\n\n核心任务是推导出一个加性评分函数，该函数将每个肽键的碎裂概率和观测到的峰强度转换为肽谱匹配 (PSM) 的总分。此推导将按规定基于第一性原理。\n\n**1. 评分函数的理论基础**\n\n评分函数必须对匹配的离子是加性的。这表明每个匹配的贡献应代表一个独立的证据片段，并且这些片段通过求和来组合。在概率论和信息论中，对数是实现从乘法系统（独立事件的概率）到加法系统（信息或证据）转换的自然工具。\n\n**1.1. 来自碎裂概率的证据**\n\n每个肽键 $i$ 都与一个预测的碎裂概率 $q_i \\in [0,1]$ 相关联。一个对应于肽键 $i$ 断裂产生的碎片的匹配，可以看作是一个概率事件的积极结果。为了将概率 $q_i$ 转换为加性的证据度量，我们采用对数优势比，也称为 logit 函数。概率为 $q_i$ 的事件的优势比是 $\\frac{q_i}{1-q_i}$。对数优势比为：\n\n$$ E_i = \\log\\left(\\frac{q_i}{1-q_i}\\right) $$\n\n此变换将概率 $q_i \\in (0,1)$ 映射到整个实数轴 $(-\\infty, \\infty)$。它随 $q_i$ 严格递增，意味着更高的碎裂概率会正确地产生更大的证据得分。当 $q_i = 0.5$（优势比相等）时，证据得分为 $E_i = \\log(1) = 0$。大于 $0.5$ 的概率产生正证据，而小于 $0.5$ 的概率产生负证据。这符合直觉上的要求，即如果一个匹配被预测为更可能发生，那么它就更显著。\n\n为了处理 $q_i=0$ 或 $q_i=1$ 的边界情况（这会导致 $\\log(0)$ 或除以零），问题要求将概率裁剪到区间 $[\\varepsilon, 1-\\varepsilon]$，其中 $\\varepsilon = 10^{-6}$。因此，我们使用裁剪后的概率 $q'_i = \\max(\\varepsilon, \\min(q_i, 1-\\varepsilon))$ 来计算证据。\n\n**1.2. 通过峰强度进行加权**\n\n观测谱图中匹配峰的强度提供了相应离子丰度的信息。通常，强度更高的峰构成了该离子存在的更强证据。评分函数必须以下列方式整合强度：\n1.  对所有强度进行全局重新缩放时保持不变。\n2.  对强度极高的峰能有合理的处理。\n\n为实现尺度不变性，我们将每个峰的强度 $I_\\ell$ 通过谱图的总离子流 (TIC) 进行归一化，总离子流是所有观测峰强度的总和，即 $\\sum_{k=1}^{N} I_k$。归一化强度为 $I'_\\ell = I_\\ell / (\\sum_{k=1}^{N} I_k)$。\n\n为解决第二点，我们对归一化强度应用一个凹的、单调的函数。这是谱图分析中的常见做法，用以降低极强峰的影响，因为这些峰可能过大，并且其大小可能不反映证据的线性成比例增加。一个在物理和统计上都有合理依据的选择是平方根函数 $f(I'_\\ell) = \\sqrt{I'_\\ell}$。此函数是凹的，对于正强度是严格递增的，并且常用于计数过程数据的方差稳定化，而质谱强度可以看作是这类数据的近似。\n\n**1.3. 组合评分函数**\n\n我们将来自概率的证据和来自强度的权重组合成每个匹配的单一贡献。由强度导出的权重调节由概率导出的证据得分。对于一个由肽键 $i$ 断裂产生、并与强度为 $I_\\ell$ 的观测峰 $\\ell$ 相对应的匹配理论离子，其对总分的贡献为：\n\n$$ S_{\\text{match}}(i, \\ell) = \\sqrt{\\frac{I_\\ell}{\\sum_{k=1}^{N} I_k}} \\times \\log\\left(\\frac{q'_i}{1-q'_i}\\right) $$\n\nPSM 的总分是理论谱图与观测谱图之间找到的所有唯一的、有效的匹配的贡献之和：\n\n$$ \\text{Score} = \\sum_{\\text{所有有效的匹配 }(i, \\ell)} S_{\\text{match}}(i, \\ell) $$\n\n如果没有找到匹配，则得分为一个空和，即 $0$。\n\n**2. 算法实现**\n\n为给定的肽段、其肽键碎裂概率和观测谱图计算此分数的算法流程如下：\n\n**步骤 1：初始化**\n存储提供的 $20$ 种标准氨基酸的单同位素质量、质子质量 $m_p = 1.007276 \\text{ Da}$ 和水质量 $m_{\\mathrm{H_2O}} = 18.010565 \\text{ Da}$。对于每个测试用例，解析肽段序列 $P$、碎裂概率列表 $q$、容差 $\\tau$ 和观测峰列表 $\\{(x_\\ell, I_\\ell)\\}$。计算总离子流 TIC $= \\sum_\\ell I_\\ell$。\n\n**步骤 2：生成理论谱图**\n对于给定的长度为 $L$ 的肽段 $P = (a_1 a_2 \\dots a_L)$：\n-   生成所有单电荷前缀离子（$b$ 离子）。对于每个肽键索引 $i \\in \\{1, \\dots, L-1\\}$， $b_i$ 离子的质量计算如下：\n    $$ m(b_i) = \\left(\\sum_{k=1}^{i} m(a_k)\\right) + m_p $$\n-   生成所有单电荷后缀离子（$y$ 离子）。对于每个长度为 $j \\in \\{1, \\dots, L-1\\}$ 的后缀，对应于在肽键 $i=L-j$ 处的断裂， $y_j$ 离子的质量计算如下：\n    $$ m(y_j) = \\left(\\sum_{k=L-j+1}^{L} m(a_k)\\right) + m_{\\mathrm{H_2O}} + m_p $$\n-   将这些理论离子存储为元组列表，每个元组包含其质量、类型（例如 '$b$'）、离子编号（例如 $i$ 或 $j$）以及相关的肽键索引。对于 $b_i$ 离子，肽键索引为 $i$。对于 $y_j$ 离子，肽键索引为 $L-j$。\n\n**步骤 3：将理论离子与观测峰进行匹配**\n这是一个必须确定性地执行的关键步骤。\n-   将理论离子列表按其 $m/z$ 值的升序排序。\n-   维护一个记录哪些观测峰已被匹配的记录，例如，使用一个布尔数组 `used_peaks`。\n-   遍历排序后的理论离子。对于每个质量为 $m_{\\text{th}}$ 的理论离子：\n    1.  找出所有在指定质量容差内的可用（尚未使用）的观测峰 $(x_\\ell, I_\\ell)$，即满足 $|x_\\ell - m_{\\text{th}}| \\le \\tau$。\n    2.  如果不存在这样的峰，则继续处理下一个理论离子。\n    3.  如果存在一个或多个候选峰，根据指定的平局打破规则选择最佳匹配：\n        a.  选择绝对质量误差 $|x_\\ell - m_{\\text{th}}|$ 最小的峰。\n        b.  如果多个峰具有相同的最小质量误差，则选择强度 $I_\\ell$ 最高的那个。\n    4.  一旦确定了最佳匹配峰，将其标记为已使用，以确保它不会被再次匹配。\n    5.  这个匹配对（理论离子和观测峰）将对总分做出贡献。\n\n**步骤 4：分数计算**\n-   将总分初始化为 $0.0$。\n-   对于在步骤 3 中找到的每个匹配：\n    1.  确定与该理论离子相关联的肽键索引 $i$。\n    2.  从输入列表中检索相应的碎裂概率 $q_{i-1}$（假设列表使用从 0 开始的索引）。\n    3.  裁剪概率：$q'_{i-1} = \\max(\\varepsilon, \\min(q_{i-1}, 1-\\varepsilon))$，其中 $\\varepsilon=10^{-6}$。\n    4.  计算对数优势比证据：$E = \\log(q'_{i-1} / (1-q'_{i-1}))$。\n    5.  设匹配的观测峰为 $(x_\\ell, I_\\ell)$。计算强度权重：$W = \\sqrt{I_\\ell / \\text{TIC}}$。\n    6.  计算此匹配的贡献：$S_{match} = W \\times E$。\n    7.  将此贡献加到总分上。\n- 在遍历完所有理论离子后，累积的总分即为该 PSM 的最终结果。\n然后对所有提供的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes peptide-spectrum matching scores for a set of test cases\n    based on a derived scoring function.\n    \"\"\"\n\n    # Monoisotopic masses and constants in Daltons (Da)\n    PROTON_MASS = 1.007276\n    WATER_MASS = 18.010565\n    AMINO_ACID_MASSES = {\n        'A': 71.03711, 'R': 156.10111, 'N': 114.04293, 'D': 115.02694,\n        'C': 103.00919, 'E': 129.04259, 'Q': 128.05858, 'G': 57.02146,\n        'H': 137.05891, 'I': 113.08406, 'L': 113.08406, 'K': 128.09496,\n        'M': 131.04049, 'F': 147.06841, 'P': 97.05276, 'S': 87.03203,\n        'T': 101.04768, 'W': 186.07931, 'Y': 163.06333, 'V': 99.06841,\n    }\n    EPSILON = 1e-6\n\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"peptide\": \"PEPTIDE\",\n            \"q\": [0.2, 0.6, 0.85, 0.3, 0.75, 0.5],\n            \"tau\": 0.5,\n            \"spectrum\": [\n                (324.20, 1500), (574.10, 300), (538.787126, 800),\n                (263.40, 1200), (200.0, 100), (700.0, 50),\n                (98.060036, 400), (703.310461, 600)\n            ],\n        },\n        # Case 2 (probability extremes and boundary match)\n        {\n            \"peptide\": \"AAAA\",\n            \"q\": [0.01, 0.99, 1.0],\n            \"tau\": 0.3,\n            \"spectrum\": [\n                (72.0445, 100), (161.392061, 500),\n                (214.6, 250), (400.0, 1000)\n            ],\n        },\n        # Case 3 (no shared peaks)\n        {\n            \"peptide\": \"MASS\",\n            \"q\": [0.4, 0.4, 0.4],\n            \"tau\": 0.4,\n            \"spectrum\": [\n                (50.0, 100), (100.0, 200),\n                (150.0, 300), (1000.0, 400)\n            ],\n        },\n        # Case 4 (tolerance boundary and equidistant tie-breaking)\n        {\n            \"peptide\": \"GAS\",\n            \"q\": [0.5, 0.9],\n            \"tau\": 0.25,\n            \"spectrum\": [\n                (129.315846, 100), (128.815846, 200), (106.199871, 120),\n                (300.0, 50), (90.0, 80)\n            ],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        peptide = case[\"peptide\"]\n        q_probs = case[\"q\"]\n        tolerance = case[\"tau\"]\n        observed_spectrum = case[\"spectrum\"]\n        \n        L = len(peptide)\n        \n        # --- Step 1: Generate theoretical ions ---\n        theoretical_ions = []\n        \n        # Calculate b-ions\n        prefix_mass = 0.0\n        for i in range(L - 1):\n            prefix_mass += AMINO_ACID_MASSES[peptide[i]]\n            b_ion_mass = prefix_mass + PROTON_MASS\n            # bond_idx is 1-based\n            theoretical_ions.append({'mass': b_ion_mass, 'type': 'b', 'num': i + 1, 'bond_idx': i + 1})\n\n        # Calculate y-ions\n        suffix_mass = 0.0\n        for i in range(L - 1):\n            j = i + 1 # y-ion number (y1, y2, ...)\n            suffix_mass += AMINO_ACID_MASSES[peptide[L - 1 - i]]\n            y_ion_mass = suffix_mass + WATER_MASS + PROTON_MASS\n            # bond_idx is 1-based\n            theoretical_ions.append({'mass': y_ion_mass, 'type': 'y', 'num': j, 'bond_idx': L - j})\n            \n        theoretical_ions.sort(key=lambda x: x['mass'])\n\n        # --- Step 2: Match theoretical ions to observed peaks ---\n        total_score = 0.0\n        \n        if not observed_spectrum:\n            results.append(total_score)\n            continue\n            \n        tic = sum(p[1] for p in observed_spectrum)\n        if tic == 0:\n            results.append(0.0)\n            continue\n            \n        used_peak_indices = [False] * len(observed_spectrum)\n        \n        for th_ion in theoretical_ions:\n            candidates = []\n            for i, obs_peak in enumerate(observed_spectrum):\n                if used_peak_indices[i]:\n                    continue\n                \n                mass_error = abs(obs_peak[0] - th_ion['mass'])\n                if mass_error = tolerance:\n                    candidates.append({\n                        'peak_idx': i,\n                        'mass_error': mass_error,\n                        'intensity': obs_peak[1]\n                    })\n            \n            if not candidates:\n                continue\n            \n            # Tie-breaking logic\n            min_error = min(c['mass_error'] for c in candidates)\n            \n            best_candidates = [c for c in candidates if abs(c['mass_error'] - min_error)  1e-9]\n\n            best_match = max(best_candidates, key=lambda c: c['intensity'])\n\n            # --- Step 3: Calculate score contribution ---\n            \n            # Mark peak as used\n            used_peak_indices[best_match['peak_idx']] = True\n            \n            # Get fragmentation probability (q is 0-indexed, bond_idx is 1-indexed)\n            bond_idx = th_ion['bond_idx']\n            q_val = q_probs[bond_idx - 1]\n            \n            # Clip probability to avoid infinities\n            if q_val == 0.0 or q_val == 1.0:\n                 q_val = np.clip(q_val, EPSILON, 1.0 - EPSILON)\n\n            # Calculate log-odds\n            log_odds = np.log(q_val / (1.0 - q_val))\n            \n            # Calculate intensity weight\n            intensity = best_match['intensity']\n            intensity_weight = np.sqrt(intensity / tic)\n            \n            # Add contribution to total score\n            total_score += intensity_weight * log_odds\n            \n        results.append(total_score)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413479"}, {"introduction": "从数据库搜索中获得一长串高分匹配列表并非分析的终点；我们必须评估其中有多少是真实的发现，又有多少可能仅仅是随机匹配。本练习将带你亲手实践在蛋白质组学中用于统计验证的基石方法——靶标-诱饵策略（target-decoy approach）。你将为一个给定的肽谱匹配列表手动计算其在不同分数阈值下的假发现率（$\\widehat{\\mathrm{FDR}}$），并进一步推导出每个匹配的 $q$-值 ([@problem_id:2520864])。这项实践让你清晰地了解我们是如何对每一次鉴定进行质量控制，并最终在可接受的错误率（例如1% FDR）下，报告一个可靠的肽段发现列表。", "problem": "一个临床微生物学实验室使用串联质谱法对细菌裂解物进行肽段鉴定。搜索结果是根据一个串联的目标-诱饵数据库生成的，每个谱图只保留一个最佳的肽段-谱图匹配（PSM）。该实验室使用目标-诱饵方法来估计假发现率（FDR），并采用以下经过充分检验的定义。\n\n设 $s$ 为一个分数阈值。令 $T(s)$ 表示分数 $\\ge s$ 的目标PSM数量，令 $D(s)$ 表示分数 $\\ge s$ 的诱饵PSM数量。在阈值 $s$ 处的估计假发现率定义为\n$$\n\\widehat{\\mathrm{FDR}}(s) \\equiv \\frac{D(s)}{T(s)}.\n$$\n对于分数为 $x$ 的一个PSM，其 $q$ 值定义为所有会包含该PSM的阈值中所对应的最小估计假发现率：\n$$\nq(x) \\equiv \\min_{s \\le x} \\widehat{\\mathrm{FDR}}(s).\n$$\n\n给定一个实验中的 $16$ 个PSM列表，已按分数严格降序排列（分数越高越好）。每个条目显示了其排名、分数以及它是匹配了目标（$T$）数据库还是诱饵（$D$）数据库：\n\n- 排名 $1$：分数 $98$，标签 $T$\n- 排名 $2$：分数 $96$，标签 $T$\n- 排名 $3$：分数 $94$，标签 $T$\n- 排名 $4$：分数 $93$，标签 $D$\n- 排名 $5$：分数 $92$，标签 $T$\n- 排名 $6$：分数 $90$，标签 $T$\n- 排名 $7$：分数 $89$，标签 $D$\n- 排名 $8$：分数 $88$，标签 $T$\n- 排名 $9$：分数 $86$，标签 $T$\n- 排名 $10$：分数 $85$，标签 $T$\n- 排名 $11$：分数 $84$，标签 $D$\n- 排名 $12$：分数 $83$，标签 $T$\n- 排名 $13$：分数 $82$，标签 $T$\n- 排名 $14$：分数 $81$，标签 $D$\n- 排名 $15$：分数 $80$，标签 $T$\n- 排名 $16$：分数 $79$，标签 $T$\n\n假设没有分数并列的情况。根据上述定义计算所有PSM的 $q$ 值，然后确定其 $q$ 值 $\\le 0.01$ (即，在 $0.01$ 的全局假发现率下被接受) 的目标肽段鉴定的数量。仅将此数字作为您的最终答案报告。最终答案表示为一个没有单位的整数。除了精确的整数计数外，不需要进行任何取整。", "solution": "问题陈述经过验证，被认为是有效的。它在科学上基于蛋白质组学中假发现率估计的标准原则，特别是目标-诱饵方法。该问题定义明确，为得到唯一解提供了所有必要的数据和无歧义的定义。它是客观的，没有任何逻辑或事实上的不一致。因此，我将开始解答。\n\n问题要求我们确定在 $0.01$ 的全局假发现率下被接受的目标肽段-谱图匹配（PSM）的数量。这等同于找出 $q$ 值小于或等于 $0.01$ 的目标PSM的数量。\n\n给定数据包含一个 $16$ 个PSM的列表，按分数严格降序排列。设此列表中第 $i$ 个PSM的特征为其分数 $x_i$ 和标签 $l_i \\in \\{T, D\\}$，其中 $i = 1, 2, \\ldots, 16$。\n\n提供的定义如下：\n$1$. 在分数阈值 $s$ 处的估计假发现率 $\\widehat{\\mathrm{FDR}}(s)$ 由下式给出\n$$\n\\widehat{\\mathrm{FDR}}(s) = \\frac{D(s)}{T(s)}\n$$\n其中 $D(s)$ 是分数 $\\ge s$ 的诱饵PSM数量， $T(s)$ 是分数 $\\ge s$ 的目标PSM数量。\n\n$2$. 分数为 $x$ 的PSM的 $q$ 值定义为\n$$\nq(x) = \\min_{s \\le x} \\widehat{\\mathrm{FDR}}(s)\n$$\n\n由于PSM列表是按分数降序排列的（$x_1  x_2  \\ldots  x_{16}$），对于列表中任意给定的分数 $x_i$，分数 $\\ge x_i$ 的PSM集合即为排名从 $1$ 到 $i$ 的那些PSM。我们定义 $D_i$ 和 $T_i$ 分别为截至排名 $i$ 的诱饵和目标PSM的累积数量。\n$$\nD_i = |\\{j \\le i \\mid l_j = D\\}|\n$$\n$$\nT_i = |\\{j \\le i \\mid l_j = T\\}|\n$$\n因此，在分数阈值 $s=x_i$ 处的估计FDR是 $\\widehat{\\mathrm{FDR}}(x_i) = D_i / T_i$。\n\n分数为 $x_i$ 的PSM的 $q$ 值是所有小于或等于 $x_i$ 的阈值所对应的FDR中的最小值。鉴于分数的离散性，这对应于排名在 $i$ 或更低的所有PSM的FDR值中的最小值。\n$$\nq(x_i) = \\min_{k \\ge i} \\widehat{\\mathrm{FDR}}(x_k) = \\min_{k \\ge i} \\frac{D_k}{T_k}\n$$\n这个性质意味着 $q$ 值序列 $q(x_i)$ 随着排名 $i$ 的增加（以及分数 $x_i$ 的减少）必须是单调不减的。\n\n现在我们为每个PSM计算必要的值。首先，我们列表计算累积数量 $D_i$ 和 $T_i$，然后计算每个排名 $i=1, \\dots, 16$ 的 $\\widehat{\\mathrm{FDR}}(x_i)$。\n\n对于 $i=1$: $D_1=0$, $T_1=1$。 $\\widehat{\\mathrm{FDR}}(x_1) = \\frac{0}{1}=0$。\n对于 $i=2$: $D_2=0$, $T_2=2$。 $\\widehat{\\mathrm{FDR}}(x_2) = \\frac{0}{2}=0$。\n对于 $i=3$: $D_3=0$, $T_3=3$。 $\\widehat{\\mathrm{FDR}}(x_3) = \\frac{0}{3}=0$。\n对于 $i=4$: $D_4=1$, $T_4=3$。 $\\widehat{\\mathrm{FDR}}(x_4) = \\frac{1}{3}$。\n对于 $i=5$: $D_5=1$, $T_5=4$。 $\\widehat{\\mathrm{FDR}}(x_5) = \\frac{1}{4}$。\n对于 $i=6$: $D_6=1$, $T_6=5$。 $\\widehat{\\mathrm{FDR}}(x_6) = \\frac{1}{5}$。\n对于 $i=7$: $D_7=2$, $T_7=5$。 $\\widehat{\\mathrm{FDR}}(x_7) = \\frac{2}{5}$。\n对于 $i=8$: $D_8=2$, $T_8=6$。 $\\widehat{\\mathrm{FDR}}(x_8) = \\frac{2}{6} = \\frac{1}{3}$。\n对于 $i=9$: $D_9=2$, $T_9=7$。 $\\widehat{\\mathrm{FDR}}(x_9) = \\frac{2}{7}$。\n对于 $i=10$: $D_{10}=2$, $T_{10}=8$。 $\\widehat{\\mathrm{FDR}}(x_{10}) = \\frac{2}{8} = \\frac{1}{4}$。\n对于 $i=11$: $D_{11}=3$, $T_{11}=8$。 $\\widehat{\\mathrm{FDR}}(x_{11}) = \\frac{3}{8}$。\n对于 $i=12$: $D_{12}=3$, $T_{12}=9$。 $\\widehat{\\mathrm{FDR}}(x_{12}) = \\frac{3}{9} = \\frac{1}{3}$。\n对于 $i=13$: $D_{13}=3$, $T_{13}=10$。 $\\widehat{\\mathrm{FDR}}(x_{13}) = \\frac{3}{10}$。\n对于 $i=14$: $D_{14}=4$, $T_{14}=10$。 $\\widehat{\\mathrm{FDR}}(x_{14}) = \\frac{4}{10} = \\frac{2}{5}$。\n对于 $i=15$: $D_{15}=4$, $T_{15}=11$。 $\\widehat{\\mathrm{FDR}}(x_{15}) = \\frac{4}{11}$。\n对于 $i=16$: $D_{16}=4$, $T_{16}=12$。 $\\widehat{\\mathrm{FDR}}(x_{16}) = \\frac{4}{12} = \\frac{1}{3}$。\n\n接下来，我们通过从列表末尾（排名16）开始向上计算 $\\widehat{\\mathrm{FDR}}$ 值的累积最小值来得到 $q$ 值。\n$q(x_{16}) = \\widehat{\\mathrm{FDR}}(x_{16}) = \\frac{1}{3}$。\n$q(x_{15}) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_{15}), q(x_{16})\\right) = \\min\\left(\\frac{4}{11}, \\frac{1}{3}\\right) = \\frac{1}{3}$。\n$q(x_{14}) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_{14}), q(x_{15})\\right) = \\min\\left(\\frac{2}{5}, \\frac{1}{3}\\right) = \\frac{1}{3}$。\n$q(x_{13}) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_{13}), q(x_{14})\\right) = \\min\\left(\\frac{3}{10}, \\frac{1}{3}\\right) = \\frac{3}{10}$。\n$q(x_{12}) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_{12}), q(x_{13})\\right) = \\min\\left(\\frac{1}{3}, \\frac{3}{10}\\right) = \\frac{3}{10}$。\n$q(x_{11}) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_{11}), q(x_{12})\\right) = \\min\\left(\\frac{3}{8}, \\frac{3}{10}\\right) = \\frac{3}{10}$。\n$q(x_{10}) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_{10}), q(x_{11})\\right) = \\min\\left(\\frac{1}{4}, \\frac{3}{10}\\right) = \\frac{1}{4}$。\n$q(x_9) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_9), q(x_{10})\\right) = \\min\\left(\\frac{2}{7}, \\frac{1}{4}\\right) = \\frac{1}{4}$。\n$q(x_8) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_8), q(x_9)\\right) = \\min\\left(\\frac{1}{3}, \\frac{1}{4}\\right) = \\frac{1}{4}$。\n$q(x_7) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_7), q(x_8)\\right) = \\min\\left(\\frac{2}{5}, \\frac{1}{4}\\right) = \\frac{1}{4}$。\n$q(x_6) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_6), q(x_7)\\right) = \\min\\left(\\frac{1}{5}, \\frac{1}{4}\\right) = \\frac{1}{5}$。\n$q(x_5) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_5), q(x_6)\\right) = \\min\\left(\\frac{1}{4}, \\frac{1}{5}\\right) = \\frac{1}{5}$。\n$q(x_4) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_4), q(x_5)\\right) = \\min\\left(\\frac{1}{3}, \\frac{1}{5}\\right) = \\frac{1}{5}$。\n$q(x_3) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_3), q(x_4)\\right) = \\min\\left(0, \\frac{1}{5}\\right) = 0$。\n$q(x_2) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_2), q(x_3)\\right) = \\min\\left(0, 0\\right) = 0$。\n$q(x_1) = \\min\\left(\\widehat{\\mathrm{FDR}}(x_1), q(x_2)\\right) = \\min\\left(0, 0\\right) = 0$。\n\n最后，我们找出所有的目标PSM（$l_i=T$）并检查它们的 $q$ 值是否满足 $q(x_i) \\le 0.01$。目标PSM位于排名 $1, 2, 3, 5, 6, 8, 9, 10, 12, 13, 15, 16$。\n\n- 排名 $1$ (T): $q(x_1) = 0$。因为 $0 \\le 0.01$，此PSM被接受。\n- 排名 $2$ (T): $q(x_2) = 0$。因为 $0 \\le 0.01$，此PSM被接受。\n- 排名 $3$ (T): $q(x_3) = 0$。因为 $0 \\le 0.01$，此PSM被接受。\n- 排名 $5$ (T): $q(x_5) = \\frac{1}{5} = 0.2$。因为 $0.2  0.01$，此PSM被拒绝。\n- 排名 $6$ (T): $q(x_6) = \\frac{1}{5} = 0.2$。因为 $0.2  0.01$，此PSM被拒绝。\n\n由于 $q$ 值随着排名的增加而单调不减，因此后续排名在 $8, 9, 10, \\ldots$ 的所有目标PSM的 $q$ 值也将大于 $0.01$。例如， $q(x_8) = 1/4 = 0.25  0.01$。因此，没有更多的目标PSM会被接受。\n\n$q$ 值 $\\le 0.01$ 的目标肽段鉴定数量就是被接受的PSM的数量。这个数量是 $3$。", "answer": "$$\n\\boxed{3}\n$$", "id": "2520864"}]}