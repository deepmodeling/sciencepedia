{"hands_on_practices": [{"introduction": "在蛋白质组学中，区分质量极其相近的翻译后修饰（PTM）是一项关键挑战，例如赖氨酸上的三甲基化和乙酰化。尽管这两种修饰赋予蛋白质不同的生物学功能，但它们的质量差异极小，对质谱仪的分辨能力提出了极高的要求。这项练习将引导你通过计算，确定区分这两种同量异位（isobaric）修饰所需的理论最低分辨率 $R$，从而让你亲身体会到高分辨率质谱在现代蛋白质组学研究中不可或缺的作用 [@problem_id:2416842]。", "problem": "一个肽段的中性单同位素质量为 $M_0 = 1500.0000$ Da。考虑在一个赖氨酸残基上的两种可能的翻译后修饰 (PTM)：三甲基化和乙酰化。对于添加到肽骨架上的净质量转移，三甲基化使用元素组成 $C_3H_6$，乙酰化使用元素组成 $C_2H_2O$。两种修饰的前体离子都在高分辨率质谱仪中以电荷态 $z=2$ 的双质子化形式被观测到。假设单同位素原子质量为 $m(\\mathrm{C}) = 12.000000$，$m(\\mathrm{H}) = 1.00782503223$，$m(\\mathrm{N}) = 14.00307400443$，$m(\\mathrm{O}) = 15.99491461957$，以及质子质量为 $m_p = 1.00727646688$（单位均为道尔顿）。使用质谱学中在半峰全宽 (FWHM) 处的常规分辨率定义，并在两个单同位素前体峰的平均 $m/z$ 处进行评估。\n\n在这些条件下，区分乙酰化和三甲基化前体所需的理论最小分辨率 $R$ 是多少？将答案四舍五入至四位有效数字。将 $R$ 报告为一个无量纲数。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 未修饰肽段的中性单同位素质量：$M_0 = 1500.0000$ Da。\n- 翻译后修饰1 (PTM1)：三甲基化，其净质量转移对应于元素组成 $C_3H_6$。\n- 翻译后修饰2 (PTM2)：乙酰化，其净质量转移对应于元素组成 $C_2H_2O$。\n- 前体离子的电荷态：$z=2$。\n- 单同位素原子质量：\n  - $m(\\mathrm{C}) = 12.000000$ Da\n  - $m(\\mathrm{H}) = 1.00782503223$ Da\n  - $m(\\mathrm{N}) = 14.00307400443$ Da\n  - $m(\\mathrm{O}) = 15.99491461957$ Da\n- 质子质量：$m_p = 1.00727646688$ Da。\n- 分辨率的定义：$R = \\frac{m}{(\\Delta m)_{\\text{FWHM}}}$，其中 $(\\Delta m)_{\\text{FWHM}}$ 是质荷比为 $m$ 的峰的半峰全宽。\n- $R$ 的评估点：两个单同位素前体峰的平均 $m/z$。\n- 目标：确定区分这两个前体离子所需的最小分辨率 $R$。\n\n**步骤2：使用已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了高分辨率蛋白质组学质谱中的一个标准计算。提供的原子质量是单同位素的正确值。赖氨酸上三甲基化和乙酰化的质量转移定义在化学上是正确的。该问题提供了计算唯一、有意义解所需的所有必要信息。问题中没有矛盾、歧义或事实错误。\n\n**步骤3：结论与行动**\n该问题有效。将推导解答。\n\n任务是求出区分两个同位素不同的前体离子所需的最小理论分辨率 $R$。两个峰恰好被分辨的判据是，它们的质荷比之差 $\\Delta(m/z)$ 等于峰的半峰全宽 (FWHM)，记为 $(\\Delta m)_{\\text{FWHM}}$。\n$$(\\Delta m)_{\\text{FWHM}} = \\Delta(m/z)$$\n分辨率定义为 $R = \\frac{m}{(\\Delta m)_{\\text{FWHM}}}$。问题指定应在两个峰的平均质荷比 $(m/z)_{\\text{avg}}$ 处评估 $R$。\n因此，所需的最小分辨率由下式给出：\n$$R = \\frac{(m/z)_{\\text{avg}}}{\\Delta(m/z)}$$\n\n首先，我们根据每种 PTM 的元素组成计算其质量转移 $\\Delta M$。\n对于三甲基化 ($PTM_1$)：\n$$\\Delta M_{tri} = 3 \\times m(\\mathrm{C}) + 6 \\times m(\\mathrm{H})$$\n$$\\Delta M_{tri} = 3 \\times 12.000000 + 6 \\times 1.00782503223 = 36.000000 + 6.04695019338 = 42.04695019338 \\text{ Da}$$\n对于乙酰化 ($PTM_2$)：\n$$\\Delta M_{ac} = 2 \\times m(\\mathrm{C}) + 2 \\times m(\\mathrm{H}) + 1 \\times m(\\mathrm{O})$$\n$$\\Delta M_{ac} = 2 \\times 12.000000 + 2 \\times 1.00782503223 + 15.99491461957 = 24.000000 + 2.01565006446 + 15.99491461957 = 42.01056468403 \\text{ Da}$$\n\n接下来，我们确定两种修饰肽段的中性单同位素质量 $M_{tri}$ 和 $M_{ac}$。\n$$M_{tri} = M_0 + \\Delta M_{tri} = 1500.0000 + 42.04695019338 = 1542.04695019338 \\text{ Da}$$\n$$M_{ac} = M_0 + \\Delta M_{ac} = 1500.0000 + 42.01056468403 = 1542.01056468403 \\text{ Da}$$\n\n对于一个中性质量为 $M$、电荷态为 $z$、质子质量为 $m_p$ 的离子，其质荷比 $m/z$ 由下式给出：\n$$(m/z) = \\frac{M + z \\cdot m_p}{z} = \\frac{M}{z} + m_p$$\n两种物质之间的 $m/z$ 差异为：\n$$\\Delta(m/z) = (m/z)_{tri} - (m/z)_{ac} = \\left(\\frac{M_{tri}}{z} + m_p\\right) - \\left(\\frac{M_{ac}}{z} + m_p\\right) = \\frac{M_{tri} - M_{ac}}{z}$$\n中性质量的差异为：\n$$M_{tri} - M_{ac} = \\Delta M_{tri} - \\Delta M_{ac} = 42.04695019338 - 42.01056468403 = 0.03638550935 \\text{ Da}$$\n当 $z=2$ 时，$m/z$ 的差异为：\n$$\\Delta(m/z) = \\frac{0.03638550935}{2} = 0.018192754675$$\n\n现在，我们计算平均质荷比 $(m/z)_{\\text{avg}}$。\n$$(m/z)_{\\text{avg}} = \\frac{(m/z)_{tri} + (m/z)_{ac}}{2} = \\frac{1}{2} \\left[ \\left(\\frac{M_{tri}}{z} + m_p\\right) + \\left(\\frac{M_{ac}}{z} + m_p\\right) \\right] = \\frac{M_{tri} + M_{ac}}{2z} + m_p$$\n平均中性质量为：\n$$M_{avg} = \\frac{M_{tri} + M_{ac}}{2} = \\frac{1542.04695019338 + 1542.01056468403}{2} = 1542.028757438705 \\text{ Da}$$\n平均 $m/z$ 为：\n$$(m/z)_{\\text{avg}} = \\frac{1542.028757438705}{2} + 1.00727646688 = 771.0143787193525 + 1.00727646688 = 772.02165518623$$\n\n最后，我们计算所需的最小分辨率 $R$。\n$$R = \\frac{(m/z)_{\\text{avg}}}{\\Delta(m/z)} = \\frac{772.02165518623}{0.018192754675} \\approx 42436.0029$$\n问题要求将答案四舍五入至四位有效数字。\n$$R \\approx 42440$$\n用标准科学记数法表示，此为 $4.244 \\times 10^4$。", "answer": "$$\\boxed{4.244 \\times 10^{4}}$$", "id": "2416842"}, {"introduction": "蛋白质组学数据分析不仅是解读质谱图，更是对整个液相色谱-质谱联用（LC-MS）实验过程的理解。在分析完整蛋白质（top-down proteomics）时，我们常会观察到一些较小的蛋白质物种，它们可能是在细胞内真实存在的截短蛋白质，也可能是在质谱仪中产生的伪影（例如，源内裂解的碎片）。这个练习是一个思想实验，旨在挑战你仅利用已采集的数据，设计一种计算策略，通过分析色谱洗脱行为来区分这两种来源迥异的信号，从而深刻理解多维数据在确保生物学发现准确性中的核心价值 [@problem_id:2416811]。", "problem": "您正在分析来自液相色谱-质谱 (LC–MS) 自上而下蛋白质组学实验的数据，在该实验中，完整的蛋白质 (蛋白形式) 经过色谱分离后被电离并进行质谱分析。在此类实验中，质谱图中观察到的较小蛋白质物质可能源于两种不同的来源：(i) 电离后在气相中产生的碎片（例如，通过源内碎裂或在串联采集中产生），或 (ii) 在分离前于细胞内发生生物学截断的真实蛋白形式。您只能对已采集的数据进行计算分析，不能更改任何仪器设置或进行额外实验。您的目标是区分气相碎片与真实的截断蛋白形式。\n\n哪种方法最能利用分离和离子形成的基本特性，在一个现实的计算工作流程中区分这两种情况？\n\nA. 在色谱维度上构建特征水平的共洗脱和协方差分析，将那些质量在质量精度范围内恰好是某个较大质量蛋白形式的N端或C端前缀/后缀的特征联系起来，并将满足以下两个条件的较小特征归类为气相碎片：(i) 与较大质量的特征共洗脱（具有相同的峰顶和强相关的提取离子色谱图 (XICs)），以及 (ii) 缺乏独立的色谱峰。\n\nB. 将所有观察到的末端与已知蛋白酶基序和预测的信号肽切割位点的蛋白质组数据库进行比对，并将任何与基序匹配的截断归类为生物学来源，而不考虑其保留行为或与共洗脱特征的关系。\n\nC. 比较同位素包络的形状和偏度；气相碎片可以被识别，因为它们的同位素分布会系统性地偏离相同元素组成所预期的理论多项式模式。\n\nD. 仅使用电荷态分布；气相碎片总是比质量相似的真实截断蛋白形式少携带至少$1$个电荷，因此较低的平均电荷明确地指示了其气相来源。\n\nE. 仅依赖较小物质的串联质谱；气相碎片不会产生提供序列信息的碎片离子（例如，$b/y$ 或 $c/z$ 离子），而真实的截断蛋白形式则能可靠地产生这些离子。\n\n选择唯一的最佳选项。", "solution": "问题陈述提出了计算蛋白质组学中一项标准但关键的任务：区分真实的、生物学上截断的蛋白形式与质谱分析过程中产生的伪影气相碎片。核心约束是，这种区分必须在现有的液相色谱-质谱 (LC–MS) 数据上以计算方式进行。\n\n### 问题验证\n\n首先，我将验证问题陈述本身。\n\n**步骤1：提取已知条件**\n- **技术：** 用于自上而下蛋白质组学的液相色谱-质谱 (LC–MS)。\n- **过程：** 完整的蛋白形式经过色谱分离，然后被电离并通过质谱仪进行分析。\n- **观察：** 检测到较小的蛋白质物质。\n- **较小物质的假定来源：**\n    - (i) 电离后产生的气相碎片（例如，源内碎裂、串联采集）。\n    - (ii) 分析前样品中存在的、真实的、生物学截断的蛋白形式。\n- **约束：** 分析必须纯粹使用已采集的数据进行计算。不允许进行进一步的实验。\n- **目标：** 以计算方式区分来源 (i) 和来源 (ii)。\n- **问题：** 确定利用分离和离子形成基本原理的最佳方法。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于分析化学和生物化学的原理。在自上而下蛋白质组学中，源内/气相碎片和生物学截断的蛋白形式同时存在是一个有据可查的现实。区分它们是该领域数据分析工作流程中的一个重要课题。该问题在科学上是合理的。\n- **适定性：** 这是一个适定问题。它提出了一个明确的目标和一组现实的约束条件。它要求找到“最佳”方法，这意味着需要基于潜在的物理和化学原理进行比较分析，从而得出一个可确定的答案。\n- **客观性：** 其语言技术性强、精确且没有主观性。诸如“蛋白形式”、“共洗脱”、“源内碎裂”和“串联采集”等术语都是该学科内的标准术语，并有严格的定义。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它在科学上是合理的、适定的和客观的。它描述了生物信息学和计算质谱学中一个重要且相关的挑战。我现在将对各选项进行全面的推导和分析。\n\n### 解题推导\n\n能够区分这两种物质的基本原理在于它们所经历的事件序列。\n1.  **真实的截断蛋白形式：** 这些是独立的分子实体，在样品注入LC系统*之前*就已存在。它们根据自身独特的理化性质（例如，大小、疏水性）进行色谱分离。因此，一个真实的截断蛋白形式将在其特有的保留时间从色谱柱中洗脱出来，产生一个独特的色谱峰。这个保留时间几乎肯定会与它可能衍生自的全长蛋白质的保留时间不同。\n2.  **气相碎片：** 这些物质在原始样品中不存在。它们是在电离*之后*，在质谱仪内部产生的。它们由一个已经从色谱柱中洗脱出来的、更大的、完整的前体蛋白形式形成。因此，气相碎片在时间上的出现严格依赖于其前体离子的存在。它不能有自己独立的色谱图，因为它从未经历过分离。它只会在其前体被检测到时才被检测到。\n\n因此，最可靠和最根本的区分特征是色谱洗脱图谱。一个真实的蛋白形式有自己的峰；而一个气相碎片的信号仅仅是其前体峰的一个“影子”。一个稳健的计算方法必须利用这种时间关系。\n\n### 逐项分析\n\n**A. 在色谱维度上构建特征水平的共洗脱和协方差分析，将那些质量在质量精度范围内恰好是某个较大质量蛋白形式的N端或C端前缀/后缀的特征联系起来，并将满足以下两个条件的较小特征归类为气相碎片：(i) 与较大质量的特征共洗脱（具有相同的峰顶和强相关的提取离子色谱图 (XICs)），以及 (ii) 缺乏独立的色谱峰。**\n\n该方法直接将上述推导出的基本原理付诸实践。\n- 它通过检查较小质量是否为较大质量的子序列（“N端或C端前缀/后缀”）来正确建立潜在的化学关系。这是碎片的一个必要条件。\n- 然后，它测试关键的时间关系。“共洗脱”、“相同的峰顶”和“强相关的XICs”是将碎片是前体伪影这一概念进行数学形式化的表达。如果小物质是较大物质的气相碎片，那么它在任何时间点的丰度必须与同一时间点前体的丰度成正比。这会导致完全相关的XICs。\n- “缺乏独立的色谱峰”这一条件正确地指出了该物质没有经历自己的分离过程。\n\n此方法逻辑性强，物理上合理，并代表了解决此问题的最先进的计算方法。\n\n**结论：正确。**\n\n**B. 将所有观察到的末端与已知蛋白酶基序和预测的信号肽切割位点的蛋白质组数据库进行比对，并将任何与基序匹配的截断归类为生物学来源，而不考虑其保留行为或与共洗脱特征的关系。**\n\n此方法存在缺陷且不可靠。\n- 其主要弊病在于“不考虑保留行为”。色谱分离提供了数据中最明确的证据，忽略它是一个严重的错误。一个与前体完美共洗脱的物质几乎可以肯定是气相碎片，即使其质量偶然对应于一个已知的蛋白酶切割位点。\n- 该方法基于不完整的知识。蛋白酶特异性数据库并不详尽，许多生物学加工事件尚未被表征或由非特异性降解引起。这会导致假阴性（漏掉真实的生物学形式）。\n- 相反，许多蛋白酶基序很简单，增加了偶然匹配的概率，这将导致假阳性（将气相碎片归类为生物学来源）。\n\n**结论：错误。**\n\n**C. 比较同位素包络的形状和偏度；气相碎片可以被识别，因为它们的同位素分布会系统性地偏离相同元素组成所预期的理论多项式模式。**\n\n这个前提在科学上是错误的。离子的同位素分布是其元素组成和稳定同位素自然丰度的函数。通过断裂共价键（例如，源内碎裂）产生碎片的过程不会改变该碎片内原子的同位素组成。一个具有给定元素式的碎片，无论其来源如何，都将表现出与任何其他具有相同元素式的分子相同的理论同位素分布。不存在可以作为碎裂特征的“系统性偏离”的物理基础。\n\n**结论：错误。**\n\n**D. 仅使用电荷态分布；气相碎片总是比质量相似的真实截断蛋白形式少携带至少 $1$ 个电荷，因此较低的平均电荷明确地指示了其气相来源。**\n\n这个陈述在事实上是错误的，并且代表了对电喷雾电离 (ESI) 和碎裂过程的误解。\n- 离子在ESI中获得的电荷量取决于其构象和可用的带电位点数量。两种质量和组成相似的物质，一个是碎片，另一个是真实的截断形式，预计会具有非常相似的电荷态分布。\n- 声称碎片“总是”少携带至少 $1$ 个电荷是毫无根据的。事实上，人们可以提出相反的论点：如果一个高电荷的前体发生碎裂，产生的碎片可能会相对于其现在更小的质量保留大量的电荷，与单独电离的相同质量的蛋白形式相比，可能导致*更高*的平均电荷态。这种关系是复杂的，并非“明确的”。\n\n**结论：错误。**\n\n**E. 仅依赖较小物质的串联质谱；气相碎片不会产生提供序列信息的碎片离子（例如，$b/y$ 或 $c/z$ 离子），而真实的截断蛋白形式则能可靠地产生这些离子。**\n\n这个陈述是根本性错误的。离子在碰撞激活（或其他方法）下碎裂的能力是其化学结构和电荷的内在属性，而不是其来源历史。\n- 一个气相碎片只是一个较小的肽/蛋白质离子。如果将其分离出来并进行额外阶段的碎裂 (MS$^3$)，它将像任何其他相同序列的肽一样，产生提供序列信息的离子（例如，$b/y$ 离子）。\n- 此外，问题陈述本身就指出，“串联采集”期间的碎裂是所述物质的来源之一。串联质谱 (Tandem MS) 正是用于产生提供序列信息的离子的技术。因此，根据定义，这些气相碎片中的一些本身*就是*提供序列信息的离子（$b/y$、$c/z$ 等）。\n\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2416811"}, {"introduction": "理想的质谱分析一次只处理一种分子，但现实中，两种或多种肽段可能因色谱分离不完全而同时进入质谱仪并被一同碎裂，产生所谓的“嵌合质谱图”（chimeric spectrum）。这种混合信号使得后续的序列鉴定变得异常困难。本练习将这一复杂的信号拆解问题抽象为一个经典的线性代数问题，要求你设计并实现一个算法，将观测到的混合谱图分解为其组成成分的线性组合，并估算各自的丰度 $(\\hat{c}_1, \\hat{c}_2)$。通过这个实践，你将学会如何运用计算方法来“净化”复杂的实验数据，这是计算蛋白质组学中的一项高级且实用的技能 [@problem_id:2416809]。", "problem": "当两个肽前体共分离并共碎裂时，会产生串联质谱（MS/MS）嵌合谱，从而生成一个由两个基础肽谱叠加而成的单一观测谱图。设观测谱图在一个以汤姆孙（Th）为单位的固定质心化质荷比网格上表示为一个非负列向量 $\\mathbf{y} \\in \\mathbb{R}_{\\ge 0}^{N}$，两个肽特异性的非负模板谱图为列向量 $\\mathbf{a}_1, \\mathbf{a}_2 \\in \\mathbb{R}_{\\ge 0}^{N}$，其元素编码了在相同的 $N$ 个质荷比区间上的相对强度。假设在所考虑的窗口内，每个肽的同位素包络都可以由其提供的模板很好地近似，并且共洗脱意味着单次扫描的观测值可以被建模为一个线性组合\n$$\n\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 + \\boldsymbol{\\varepsilon},\n$$\n其中 $c_1 \\ge 0$ 和 $c_2 \\ge 0$ 是待估计的未知肽丰度，$\\boldsymbol{\\varepsilon}$ 是一个可能为零的加性残差向量。您必须设计一个程序，在给定 $(\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{y})$ 的情况下，返回能最小化残差的欧几里得范数平方的非负对 $(\\hat{c}_1, \\hat{c}_2)$，即：\n$$\n(\\hat{c}_1, \\hat{c}_2) = \\arg\\min_{c_1 \\ge 0,\\, c_2 \\ge 0} \\left\\| \\mathbf{y} - c_1 \\mathbf{a}_1 - c_2 \\mathbf{a}_2 \\right\\|_2^2.\n$$\n所有强度单位均为任意但一致的单位，质荷比单位为汤姆孙（Th）。输出 $(\\hat{c}_1, \\hat{c}_2)$ 是无量纲的标量。\n\n测试套件。对于下方的每个测试用例，$N$ 以及向量 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{y}$ 都被明确指定。您的程序必须为每个用例计算 $(\\hat{c}_1, \\hat{c}_2)$。\n\n- 测试用例 1（不相交的同位素包络；无残差）：\n  - $N = 6$.\n  - $\\mathbf{a}_1 = [\\,0.6,\\,0.3,\\,0.1,\\,0,\\,0,\\,0\\,]^{\\top}$.\n  - $\\mathbf{a}_2 = [\\,0,\\,0,\\,0,\\,0.5,\\,0.33,\\,0.17\\,]^{\\top}$.\n  - 真实丰度：$c_1 = 1.0$, $c_2 = 0.8$.\n  - $\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 = [\\,0.6,\\,0.3,\\,0.1,\\,0.4,\\,0.264,\\,0.136\\,]^{\\top}$.\n\n- 测试用例 2（部分重叠的同位素包络；无残差）：\n  - $N = 6$.\n  - $\\mathbf{a}_1 = [\\,0,\\,0.6,\\,0.3,\\,0.1,\\,0,\\,0\\,]^{\\top}$.\n  - $\\mathbf{a}_2 = [\\,0,\\,0,\\,0.5,\\,0.33,\\,0.17,\\,0\\,]^{\\top}$.\n  - 真实丰度：$c_1 = 1.2$, $c_2 = 0.7$.\n  - $\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 = [\\,0,\\,0.72,\\,0.71,\\,0.351,\\,0.119,\\,0\\,]^{\\top}$.\n\n- 测试用例 3（近乎共线的模板；无残差）：\n  - $N = 3$.\n  - $\\mathbf{a}_1 = [\\,0.5,\\,0.3,\\,0.2\\,]^{\\top}$.\n  - $\\mathbf{a}_2 = [\\,0.52,\\,0.31,\\,0.17\\,]^{\\top}$.\n  - 真实丰度：$c_1 = 0.9$, $c_2 = 0.9$.\n  - $\\mathbf{y} = c_1 \\mathbf{a}_1 + c_2 \\mathbf{a}_2 = [\\,0.918,\\,0.549,\\,0.333\\,]^{\\top}$.\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个嵌套列表，每个内部列表为对应测试用例的 $[\\,\\hat{c}_1, \\hat{c}_2\\,]$，每个浮点数四舍五入到恰好六位小数，并按测试用例 1、2 和 3 的顺序排列。例如，输出必须具有以下形式\n$$\n[\\,[\\,x_{1,1},x_{1,2}\\,],\\,[\\,x_{2,1},x_{2,2}\\,],\\,[\\,x_{3,1},x_{3,2}\\,]\\,],\n$$\n其中每个 $x_{i,j}$ 是小数点后恰好有六位数字的十进制表示。", "solution": "该问题要求确定非负丰度 $(\\hat{c}_1, \\hat{c}_2)$，以两个模板谱图 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 的线性组合来最好地解释观测到的嵌合质谱 $\\mathbf{y}$。目标是最小化残差向量的欧几里得范数平方，该问题可表述为以下优化问题：\n$$\n(\\hat{c}_1, \\hat{c}_2) = \\arg\\min_{c_1 \\ge 0,\\, c_2 \\ge 0} \\left\\| \\mathbf{y} - c_1 \\mathbf{a}_1 - c_2 \\mathbf{a}_2 \\right\\|_2^2.\n$$\n这个问题可以用矩阵代数更紧凑地表达。设模板谱图 $\\mathbf{a}_1 \\in \\mathbb{R}_{\\ge 0}^{N}$ 和 $\\mathbf{a}_2 \\in \\mathbb{R}_{\\ge 0}^{N}$ 是一个 $N \\times 2$ 矩阵 $A$ 的列，未知丰度是向量 $\\mathbf{c} = [c_1, c_2]^{\\top} \\in \\mathbb{R}_{\\ge 0}^{2}$ 的元素。那么问题就是求解向量 $\\hat{\\mathbf{c}}$：\n$$\n\\hat{\\mathbf{c}} = \\arg\\min_{\\mathbf{c} \\ge \\mathbf{0}} \\left\\| \\mathbf{y} - A\\mathbf{c} \\right\\|_2^2.\n$$\n这是一个标准的非负最小二乘（NNLS）问题。目标函数 $f(\\mathbf{c}) = \\left\\| \\mathbf{y} - A\\mathbf{c} \\right\\|_2^2$ 是关于 $\\mathbf{c}$ 的凸二次函数，由约束 $\\mathbf{c} \\ge \\mathbf{0}$（即 $c_1 \\ge 0$ 和 $c_2 \\ge 0$）定义的可行域是一个凸集。因此，这是一个凸优化问题，保证了任何局部最小值也是全局最小值。如果 $A$ 的列是线性无关的，则解是唯一的。\n\n虽然可以通过分析约束优化的 Karush-Kuhn-Tucker (KKT) 条件来推导解，但这通常不简单。一种更实用、更稳健的方法是采用迭代数值算法。由 Lawson 和 Hanson 发展的活动集方法是解决 NNLS 问题的经典且广泛使用的算法。其工作原理是通过迭代将 $\\mathbf{c}$ 中的变量划分为“活动集”（系数固定为零）和“被动集”（系数允许为正），在每一步对被动集求解一个无约束最小二乘问题，并更新集合，直到满足 KKT 条件。\n\n该实现将利用标准的科学计算库，这些库为 NNLS 问题提供了稳健的求解器。具体来说，Python 中 SciPy 库的 `scipy.optimize.nnls` 函数实现了上述的活动集算法。\n\n对于每个测试用例，求解过程如下：\n1.  定义输入向量 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{y}$。\n2.  通过将 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 作为列来构建矩阵 $A$。\n3.  以 $A$ 和 $\\mathbf{y}$ 为参数调用 `scipy.optimize.nnls` 函数。\n4.  该函数返回最优非负系数向量 $\\hat{\\mathbf{c}} = [\\hat{c}_1, \\hat{c}_2]^{\\top}$。\n\n需要注意的是，对于所有提供的测试用例，观测谱图 $\\mathbf{y}$ 都是由具有正系数的模板精确线性组合而成，且没有加性噪声（$\\boldsymbol{\\varepsilon} = \\mathbf{0}$）。对于这种无噪声的情况，当真实解位于可行域的内部时（即 $c_1 > 0, c_2 > 0$），NNLS 解与无约束的普通最小二乘（OLS）解 $\\hat{\\mathbf{c}} = (A^{\\top}A)^{-1}A^{\\top}\\mathbf{y}$ 一致。因此，该算法预期能够精确地恢复真实丰度。使用通用的 NNLS 求解器可确保该方法论的正确性，并能适用于涉及测量噪声或某个组分可能缺失的更真实场景。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Solves for the non-negative abundances of two peptides in chimeric mass spectra\n    for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"a1\": np.array([0.6, 0.3, 0.1, 0.0, 0.0, 0.0]),\n            \"a2\": np.array([0.0, 0.0, 0.0, 0.5, 0.33, 0.17]),\n            \"y\": np.array([0.6, 0.3, 0.1, 0.4, 0.264, 0.136]),\n        },\n        {\n            \"a1\": np.array([0.0, 0.6, 0.3, 0.1, 0.0, 0.0]),\n            \"a2\": np.array([0.0, 0.0, 0.5, 0.33, 0.17, 0.0]),\n            \"y\": np.array([0.0, 0.72, 0.71, 0.351, 0.119, 0.0]),\n        },\n        {\n            \"a1\": np.array([0.5, 0.3, 0.2]),\n            \"a2\": np.array([0.52, 0.31, 0.17]),\n            \"y\": np.array([0.918, 0.549, 0.333]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        a1 = case[\"a1\"]\n        a2 = case[\"a2\"]\n        y = case[\"y\"]\n\n        # Construct the matrix A from template vectors a1 and a2\n        A = np.stack([a1, a2], axis=1)\n\n        # Solve the Non-Negative Least Squares problem: argmin_c ||Ac - y||_2^2 for c >= 0\n        c, _ = nnls(A, y)\n        results.append(list(c))\n\n    # Format the results into the required string format.\n    # Each float must be represented with exactly six decimal places.\n    # The final format is a nested list string representation, e.g., [[c1,c2],[c1,c2],...].\n    formatted_pairs = []\n    for pair in results:\n        formatted_pair_str = [f\"{val:.6f}\" for val in pair]\n        formatted_pairs.append(f\"[{','.join(formatted_pair_str)}]\")\n    \n    final_output = f\"[{','.join(formatted_pairs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2416809"}]}