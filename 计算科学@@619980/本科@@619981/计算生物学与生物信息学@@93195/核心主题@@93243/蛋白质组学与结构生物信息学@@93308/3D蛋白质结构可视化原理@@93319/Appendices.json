{"hands_on_practices": [{"introduction": "本练习聚焦于蛋白质结构的一个基本方面：肽键的几何构型。你将学习如何通过精确的数学定义来实现二面角计算，从而在计算上区分罕见的顺式（*cis*）构象和常见的反式（*trans*）构象，这对于验证和分析高分辨率蛋白质模型是一项关键技能。[@problem_id:2416436]", "problem": "给定一个数学规范，用于根据围绕肽键的主链二面角，将蛋白质主链中的肽键分类为顺式（cis）或非顺式。考虑一个连接残基 $i$ 和残基 $i+1$ 的肽键。设四个三维点分别是残基 $i$ 的α-碳原子（$\\mathrm{C}_\\alpha(i)$）、残基 $i$ 的羰基碳（$\\mathrm{C}(i)$）、残基 $i+1$ 的酰胺氮（$\\mathrm{N}(i+1)$）以及残基 $i+1$ 的α-碳原子（$\\mathrm{C}_\\alpha(i+1)$）。将这四个点分别记为 $P_1$、$P_2$、$P_3$ 和 $P_4$，其坐标位于 $\\mathbb{R}^3$ 空间。围绕肽键 $\\mathrm{C}(i)-\\mathrm{N}(i+1)$ 的主链二面角定义为两个平面 $(P_1,P_2,P_3)$ 和 $(P_2,P_3,P_4)$ 之间的有符号角 $\\omega$，其计算方法从第一性原理推导如下。\n\n设键矢量为\n$$\n\\mathbf{b}_0 = P_2 - P_1,\\quad \\mathbf{b}_1 = P_3 - P_2,\\quad \\mathbf{b}_2 = P_4 - P_3.\n$$\n设\n$$\n\\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1,\\quad \\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2,\\quad \\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert},\\quad \\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1.\n$$\n则有符号二面角 $\\omega$ 为\n$$\n\\omega = \\operatorname{atan2}\\!\\left(\\mathbf{m}_1 \\cdot \\mathbf{n}_2,\\ \\mathbf{n}_1 \\cdot \\mathbf{n}_2\\right),\n$$\n该函数返回弧度制下的主值，范围在 $(-\\pi,\\pi]$ 内。\n\n一个肽键被分类为顺式，当且仅当其二面角 $\\omega$ 的主值满足\n$$\n\\lvert \\omega \\rvert \\le \\tau,\n$$\n其中容差为 $\\tau = \\pi/6$ 弧度。在评估该不等式时，使用 $\\epsilon = 10^{-9}$ 弧度的数值比较容差。\n\n您的任务是编写一个完整、可运行的程序，该程序针对下面指定的每个测试用例，识别出哪些肽键是顺式的，并返回该测试用例中这些顺式肽键的从零开始的索引列表。角度必须以弧度处理。\n\n为了使测试用例具体且自包含，无需外部文件，每个测试用例中的肽键都由一对角度 $(\\theta_1,\\theta_2)$ 间接给出。这对角度参数化了一个与 x 轴对齐的规范四点构造。对于每对 $(\\theta_1,\\theta_2)$，构造如下四个点\n$$\nP_1 = (-1,\\ \\cos\\theta_1,\\ \\sin\\theta_1),\\quad\nP_2 = (0,\\ 0,\\ 0),\\quad\nP_3 = (1,\\ 0,\\ 0),\\quad\nP_4 = (2,\\ \\cos\\theta_2,\\ \\sin\\theta_2),\n$$\n所有坐标均以任意长度单位表示。此构造产生的肽键二面角 $\\omega = \\theta_1 - \\theta_2$，其主值可通过上述 $\\operatorname{atan2}$ 表达式获得。\n\n测试套件（每行为一个测试用例；每个测试用例是一个 $(\\theta_1,\\theta_2)$ 对的列表；所有角度均为弧度）：\n\n- 测试用例 $1$：$[(1.234,\\ 1.234)]$。\n- 测试用例 $2$：$[(1.234,\\ 1.834)]$。\n- 测试用例 $3$：$[(0.0,\\ \\pi - 0.01),\\ (2.5,\\ 2.5 + 2\\pi - 0.1),\\ (0.0,\\ -\\pi/6)]$。\n- 测试用例 $4$：$[]$（无肽键）。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个方括号括起来的列表，包含相应测试用例中顺式肽键的从零开始的索引。例如，如果第一个测试用例在索引 $0$ 处有一个顺式肽键，第二个没有，第三个在索引 $1$ 和 $2$ 处有顺式肽键，第四个没有，则输出必须严格为\n$[[0],[],[1,2],[]]$。", "solution": "所提供的问题陈述已经过验证，并被认定为有效。它有科学依据，提法明确，客观且内部一致。它基于结构生物学和矢量数学的既定原则，提出了一个清晰的计算任务。现在我将提供一个完整的解决方案。\n\n该问题要求根据主链二面角 $\\omega$ 的值将肽键分类为“顺式”。一个肽键由四个原子坐标定义：$P_1 = \\mathrm{C}_\\alpha(i)$、$P_2 = \\mathrm{C}(i)$、$P_3 = \\mathrm{N}(i+1)$ 和 $P_4 = \\mathrm{C}_\\alpha(i+1)$，其中 $i$ 是残基索引。\n\n二面角 $\\omega$ 定义为包含点 $(P_1, P_2, P_3)$ 的平面与包含点 $(P_2, P_3, P_4)$ 的平面之间的有符号角。其计算使用矢量代数来规定。设键矢量定义如下：\n$$\n\\mathbf{b}_0 = P_2 - P_1,\\quad \\mathbf{b}_1 = P_3 - P_2,\\quad \\mathbf{b}_2 = P_4 - P_3\n$$\n这两个平面的法向量由定义它们的键矢量的叉积给出：\n$$\n\\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1 \\\\\n\\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2\n$$\n这两个平面间的无符号角就是这两个法向量之间的夹角。为了确定角度的符号，需要在第一个平面中建立一个参考方向。问题使用矢量 $\\mathbf{m}_1$ 来定义此方向：\n$$\n\\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert} \\\\\n\\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1\n$$\n然后使用双参数反正切函数 $\\operatorname{atan2}$ 计算有符号角 $\\omega$，该函数能正确地将结果映射到 $(-\\pi, \\pi]$ 弧度的区间内：\n$$\n\\omega = \\operatorname{atan2}\\!\\left(\\mathbf{m}_1 \\cdot \\mathbf{n}_2,\\ \\mathbf{n}_1 \\cdot \\mathbf{n}_2\\right)\n$$\n如果一个肽键的二面角 $\\omega$ 满足条件 $|\\omega| \\le \\tau$，则将其分类为顺式，其中角度容差为 $\\tau = \\pi/6$ 弧度。涉及浮点数的数值计算必须考虑到潜在的精度误差，因此我们使用给定的数值容差 $\\epsilon = 10^{-9}$ 弧度，将该不等式评估为 $|\\omega| \\le \\tau + \\epsilon$。\n\n该问题提供了一种特定的、参数化的构造方法来生成测试用例，从而避免了对外部数据文件的需求。对于给定的一对角度 $(\\theta_1, \\theta_2)$，这四个点的构造如下：\n$$\nP_1 = (-1,\\ \\cos\\theta_1,\\ \\sin\\theta_1) \\\\\nP_2 = (0,\\ 0,\\ 0) \\\\\nP_3 = (1,\\ 0,\\ 0) \\\\\nP_4 = (2,\\ \\cos\\theta_2,\\ \\sin\\theta_2)\n$$\n在实现解决方案之前，我们必须验证问题中的论断，即此构造方法得出的 $\\omega$ 是 $\\theta_1 - \\theta_2$ 的主值。我们进行如下推导。\n\n首先，我们根据给定的点计算键矢量：\n$$ \\mathbf{b}_0 = P_2 - P_1 = (0,0,0) - (-1, \\cos\\theta_1, \\sin\\theta_1) = (1, -\\cos\\theta_1, -\\sin\\theta_1) $$\n$$ \\mathbf{b}_1 = P_3 - P_2 = (1,0,0) - (0,0,0) = (1, 0, 0) $$\n$$ \\mathbf{b}_2 = P_4 - P_3 = (2, \\cos\\theta_2, \\sin\\theta_2) - (1,0,0) = (1, \\cos\\theta_2, \\sin\\theta_2) $$\n接下来，我们计算法向量：\n$$ \\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1 = (1, -\\cos\\theta_1, -\\sin\\theta_1) \\times (1, 0, 0) = (0, -\\sin\\theta_1, \\cos\\theta_1) $$\n$$ \\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2 = (1, 0, 0) \\times (1, \\cos\\theta_2, \\sin\\theta_2) = (0, -\\sin\\theta_2, \\cos\\theta_2) $$\n然后我们计算点积 $\\mathbf{n}_1 \\cdot \\mathbf{n}_2$，它将作为 $\\operatorname{atan2}$ 的第二个参数：\n$$ \\mathbf{n}_1 \\cdot \\mathbf{n}_2 = (0)(0) + (-\\sin\\theta_1)(-\\sin\\theta_2) + (\\cos\\theta_1)(\\cos\\theta_2) = \\cos\\theta_1\\cos\\theta_2 + \\sin\\theta_1\\sin\\theta_2 = \\cos(\\theta_1 - \\theta_2) $$\n对于 $\\operatorname{atan2}$ 的第一个参数，我们需要 $\\mathbf{m}_1 \\cdot \\mathbf{n}_2$。首先，我们求 $\\mathbf{m}_1$：\n$$ \\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert} = \\frac{(1,0,0)}{\\sqrt{1^2+0^2+0^2}} = (1, 0, 0) $$\n$$ \\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1 = (0, -\\sin\\theta_1, \\cos\\theta_1) \\times (1, 0, 0) = (0, \\cos\\theta_1, \\sin\\theta_1) $$\n现在，我们计算点积 $\\mathbf{m}_1 \\cdot \\mathbf{n}_2$：\n$$ \\mathbf{m}_1 \\cdot \\mathbf{n}_2 = (0)(0) + (\\cos\\theta_1)(-\\sin\\theta_2) + (\\sin\\theta_1)(\\cos\\theta_2) = \\sin\\theta_1\\cos\\theta_2 - \\cos\\theta_1\\sin\\theta_2 = \\sin(\\theta_1 - \\theta_2) $$\n将这些结果代入 $\\omega$ 的公式中：\n$$ \\omega = \\operatorname{atan2}(\\sin(\\theta_1 - \\theta_2), \\cos(\\theta_1 - \\theta_2)) $$\n这证实了对于所提供的测试用例构造，$\\omega$ 精确地是角度差 $\\theta_1 - \\theta_2$ 的主值，且被归约到 $(-\\pi, \\pi]$ 区间内。这个简洁的简化使我们能够对特定的测试用例绕过完整的矢量计算，而采用更直接的计算方法。\n\n算法如下：\n对于每个测试用例（一个 $(\\theta_1, \\theta_2)$ 对的列表）：\n1. 初始化一个空列表，用于存储顺式肽键的从零开始的索引。\n2. 对于列表中索引为 $i$ 的每对 $(\\theta_1, \\theta_2)$：\n    a. 计算角度差 $\\Delta\\theta = \\theta_1 - \\theta_2$。\n    b. 计算此差值的主值 $\\omega = \\operatorname{atan2}(\\sin(\\Delta\\theta), \\cos(\\Delta\\theta))$。\n    c. 检查是否满足顺式条件：$|\\omega| \\le \\pi/6 + 10^{-9}$。\n    d. 如果条件为真，则将索引 $i$ 添加到顺式肽键索引列表中。\n3. 处理完所有对后，当前测试用例的索引列表即告完成。对所有测试用例重复此过程。\n4. 最后，将收集到的结果按照问题指定的要求格式化为单个字符串。\n此过程是确定性的，并直接实现了经过验证的问题定义。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the peptide bond classification problem for a given suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple represents a (theta1, theta2) pair in radians.\n    test_cases = [\n        # Test case 1\n        [(1.234, 1.234)],\n        # Test case 2\n        [(1.234, 1.834)],\n        # Test case 3\n        [(0.0, np.pi - 0.01), (2.5, 2.5 + 2 * np.pi - 0.1), (0.0, -np.pi / 6)],\n        # Test case 4\n        [],\n    ]\n\n    # Define constants from the problem\n    tau = np.pi / 6.0  # Cis/trans boundary angle tolerance\n    epsilon = 1e-9      # Numerical comparison tolerance\n\n    all_results = []\n\n    for case in test_cases:\n        cis_indices = []\n        for i, (theta1, theta2) in enumerate(case):\n            # As derived, for the special case geometry, the dihedral angle omega\n            # is the principal value of (theta1 - theta2).\n            delta_theta = theta1 - theta2\n            \n            # The use of np.arctan2(np.sin(x), np.cos(x)) correctly computes the\n            # principal value of an angle x in the range (-pi, pi].\n            omega = np.arctan2(np.sin(delta_theta), np.cos(delta_theta))\n            \n            # A peptide bond is cis if |omega| <= tau.\n            # We use the numerical tolerance epsilon for the comparison.\n            if abs(omega) <= tau + epsilon:\n                cis_indices.append(i)\n        \n        all_results.append(cis_indices)\n\n    # Format the final output string precisely as required: [[...],[...],...]\n    # A list comprehension and f-strings are used to avoid spaces in the output.\n    results_str = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n\n```", "id": "2416436"}, {"introduction": "在超越局部几何构型后，本实践将探索如何识别并可视化那些定义蛋白质整体折叠的三级结构相互作用。你将通过空间距离和序列分离度筛选残基对来实现一个接触图（contact map），并学习将相互作用的强度映射到例如透明度这样的视觉属性上。[@problem_id:2416453]", "problem": "给定代表玩具蛋白质片段主链C-alpha位置的简短三维残基坐标集。“接触图”由残基索引 $i$ 和 $j$ 的坐标 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和 $\\mathbf{r}_j \\in \\mathbb{R}^3$ 在三维空间中的欧几里得距离定义。设欧几里得距离为 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2$。当且仅当以下两个条件同时成立时，一对 $(i,j)$ 被视为一个接触，并可视化为连接 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的线段：(1) 序列间隔满足 $|i-j| \\ge s_{\\min}$，以及 (2) 空间间隔满足 $d_{ij} \\le d_{\\mathrm{thr}}$。对于每个包含的接触，通过 $\\alpha_{ij} = \\max\\{0, 1 - d_{ij}/d_{\\mathrm{thr}}\\}$ 定义一个无单位的半透明度值 (alpha)，该值将较短的距离映射到较高的不透明度，并将等于阈值 $d_{\\mathrm{thr}}$ 的距离映射到零不透明度。坐标以埃 (Å) 为单位给出，所有距离 $d_{ij}$ 和 $d_{\\mathrm{thr}}$ 均以埃 (Å) 为单位，而 $\\alpha_{ij}$ 是无单位的。\n\n如果某个残基坐标缺失，则必须忽略涉及该残基的任何配对。报告时，使用从1开始的残基索引。对于下方的每个测试用例，计算接触对的集合、它们的 $\\alpha_{ij}$ 值，并为每个测试生成以下输出：\n- 接触对的整数数量，\n- 所有 $\\alpha_{ij}$ 值的浮点数总和，四舍五入到三位小数，\n- 所包含的残基索引对列表，形式为双整数列表 $[i,j]$ 的列表，其中 $i<j$，按升序字典序排列。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，且不含空白字符。每个元素对应一个测试用例，其本身是包含上述三个输出的列表，并按给定顺序排列。例如，整体结构必须是“[[n1,sum1,[[i,j],...]], [n2,sum2,[]], [n3,sum3,[[i,j],...]]]”的形式，但用实际计算值代替占位符。\n\n测试套件：\n- 测试用例A (类螺旋片段)：残基坐标，单位为埃 (Å)\n  - $\\mathbf{r}_1 = (2.300000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (-0.399391, 2.265058, 1.500000)$\n  - $\\mathbf{r}_3 = (-2.161293, -0.786646, 3.000000)$\n  - $\\mathbf{r}_4 = (1.150000, -1.991858, 4.500000)$\n  - $\\mathbf{r}_5 = (1.761902, 1.478411, 6.000000)$\n  - $\\mathbf{r}_6 = (-1.761902, 1.478411, 7.500000)$\n  - 参数：$d_{\\mathrm{thr}} = 8.000000$ Å, $s_{\\min} = 3$。\n- 测试用例B (伸展片段)：残基坐标，单位为埃 (Å)\n  - $\\mathbf{r}_1 = (0.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (3.800000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_3 = (7.600000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_4 = (11.400000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_5 = (15.200000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_6 = (19.000000, 0.000000, 0.000000)$\n  - 参数：$d_{\\mathrm{thr}} = 6.000000$ Å, $s_{\\min} = 2$。\n- 测试用例C (存在缺失坐标)：残基坐标，单位为埃 (Å)\n  - $\\mathbf{r}_1 = (0.000000, 0.000000, 0.000000)$\n  - $\\mathbfr_2 = (4.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_3$ 缺失\n  - $\\mathbf{r}_4 = (0.000000, 4.000000, 0.000000)$\n  - $\\mathbf{r}_5 = (3.000000, 3.000000, 0.000000)$\n  - 参数：$d_{\\mathrm{thr}} = 5.000000$ Å, $s_{\\min} = 2$。\n\n此任务中不使用角度单位。所有最终数值答案均为无单位或以埃 (Å) 为单位（如指定），但您的程序的单行输出必须只包含数字和列表（如所述），不含单位符号、空白字符和附加文本。仅将每个测试的 $\\alpha_{ij}$ 值总和四舍五入到三位小数；在决定是否包含时不要对中间距离进行四舍五入。", "solution": "问题陈述已经过严格验证，并被认定为有效。它具有科学依据，定义明确，且没有矛盾、歧义或事实错误。该问题构成了基于结构生物信息学基本原理的明确定义的计算任务。因此，解决方案通过直接实现指定的算法来进行。\n\n问题的核心是识别和表征蛋白质残基之间的“接触”，这些残基由其C-alpha坐标 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 表示。只有当两个条件同时满足时，具有从1开始的索引 $i$ 和 $j$ 的两个残基之间才会建立接触。\n\n首先，由索引的绝对差定义的序列间隔必须满足最小阈值 $s_{\\min}$。这表示为：\n$$|i-j| \\ge s_{\\min}$$\n这个条件排除了在聚合物链中彼此靠近的残基之间的接触，从而将分析重点放在三级结构相互作用上。按照惯例，我们只考虑 $i < j$ 的配对，因此条件简化为 $j-i \\ge s_{\\min}$。\n\n其次，定义为其坐标之间的欧几里得距离 $d_{ij}$ 的空间间隔，不得超过指定的距离阈值 $d_{\\mathrm{thr}}$。距离计算如下：\n$$d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2 = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2}$$\n条件是：\n$$d_{ij} \\le d_{\\mathrm{thr}}$$\n\n对于满足这两个条件的每一对 $(i, j)$，都会计算一个无单位的半透明度值 $\\alpha_{ij}$。该值被设计为与距离成反比，为更近的接触分配更高的不透明度（更低的透明度）。其公式为：\n$$\\alpha_{ij} = \\max\\{0, 1 - d_{ij}/d_{\\mathrm{thr}}\\}$$\n由于接触条件 $d_{ij} \\le d_{\\mathrm{thr}}$ 确保了 $d_{ij}/d_{\\mathrm{thr}} \\le 1$，因此表达式简化为 $\\alpha_{ij} = 1 - d_{ij}/d_{\\mathrm{thr}}$。\n\n为解决每个测试用例，算法流程如下：\n\n1. 初始化一个用于存放接触对的空列表，以及一个用于累加 $\\alpha$ 值的运行总和，初始值为 $0.0$。\n2. 遍历所有唯一的残基索引对 $(i, j)$，使得 $1 \\le i < j \\le N$，其中 $N$ 是残基总数。\n3. 对于每一对 $(i, j)$：\n   a. 验证残基 $i$ 和残基 $j$ 的坐标都存在。如果任一坐标缺失，则根据问题规范，丢弃该配对。\n   b. 检查序列间隔条件 $j-i \\ge s_{\\min}$ 是否满足。如果不满足，则丢弃该配对。\n   c. 如果序列间隔足够大，则计算欧几里得距离 $d_{ij}$。\n   d. 检查空间距离条件 $d_{ij} \\le d_{\\mathrm{thr}}$ 是否满足。如果不满足，则丢弃该配对。\n   e. 如果两个条件都满足，则该配对是一个接触。计算 $\\alpha_{ij} = 1 - d_{ij}/d_{\\mathrm{thr}}$ 的值并加到运行总和中。将配对 $[i, j]$ 添加到接触列表中。\n4. 在评估完所有配对后，对结果进行汇总：\n   a. 接触总数是接触列表中的最终配对数。\n   b. $\\alpha$ 值的总和四舍五入到三位小数。\n   c. 由于嵌套循环的性质（$i$ 从 $1$ 到 $N-1$，$j$ 从 $i+1$ 到 $N$），接触对列表已经按升序字典序排序。\n5. 将这三个汇总结果——计数、四舍五入后的总和以及配对列表——根据问题中指定的严格“无空白字符”规则格式化为单个字符串。\n\n该流程是确定性的，将为每个测试用例生成唯一且可验证的结果。实现利用 `numpy` 库进行高效和精确的向量计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_result(result_tuple):\n    \"\"\"Formats a single test case result into the required string format.\"\"\"\n    n, s, pairs = result_tuple\n    # Round the sum of alphas to three decimal places.\n    s_rounded = round(s, 3)\n    \n    # Format pairs as a string list \"[i,j]\"\n    pairs_str_list = [f\"[{p[0]},{p[1]}]\" for p in pairs]\n    # Join pairs into a single string \"[[i,j],[k,l],...]\"\n    pairs_str = f\"[{','.join(pairs_str_list)}]\"\n    \n    # Format the final result for the test case as \"[n,s,pairs_str]\"\n    return f\"[{n},{s_rounded},{pairs_str}]\"\n\ndef process_case(coords, d_thr, s_min):\n    \"\"\"Processes a single test case.\"\"\"\n    contact_pairs = []\n    alpha_sum = 0.0\n    num_residues = len(coords)\n\n    # Iterate over all unique pairs of residues (i, j) with i < j\n    for i in range(num_residues):\n        for j in range(i + 1, num_residues):\n            # Residue indices are 1-based\n            res_idx_i = i + 1\n            res_idx_j = j + 1\n\n            # Ignore pairs involving a missing coordinate\n            if coords[i] is None or coords[j] is None:\n                continue\n\n            # 1. Check sequence separation\n            if (res_idx_j - res_idx_i) >= s_min:\n                # 2. Calculate Euclidean distance\n                dist = np.linalg.norm(coords[i] - coords[j])\n\n                # 3. Check spatial separation\n                if dist <= d_thr:\n                    # This is a contact\n                    contact_pairs.append([res_idx_i, res_idx_j])\n                    \n                    # Calculate alpha value\n                    alpha = 1.0 - (dist / d_thr)\n                    alpha_sum += alpha\n    \n    num_contacts = len(contact_pairs)\n    \n    return (num_contacts, alpha_sum, contact_pairs)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the processing, and print the final output.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"coords\": [\n                np.array([2.300000, 0.000000, 0.000000]),\n                np.array([-0.399391, 2.265058, 1.500000]),\n                np.array([-2.161293, -0.786646, 3.000000]),\n                np.array([1.150000, -1.991858, 4.500000]),\n                np.array([1.761902, 1.478411, 6.000000]),\n                np.array([-1.761902, 1.478411, 7.500000])\n            ],\n            \"d_thr\": 8.0,\n            \"s_min\": 3\n        },\n        # Test case B\n        {\n            \"coords\": [\n                np.array([0.000000, 0.000000, 0.000000]),\n                np.array([3.800000, 0.000000, 0.000000]),\n                np.array([7.600000, 0.000000, 0.000000]),\n                np.array([11.400000, 0.000000, 0.000000]),\n                np.array([15.200000, 0.000000, 0.000000]),\n                np.array([19.000000, 0.000000, 0.000000])\n            ],\n            \"d_thr\": 6.0,\n            \"s_min\": 2\n        },\n        # Test case C\n        {\n            \"coords\": [\n                np.array([0.000000, 0.000000, 0.000000]),\n                np.array([4.000000, 0.000000, 0.000000]),\n                None,  # Missing coordinate for residue 3\n                np.array([0.000000, 4.000000, 0.000000]),\n                np.array([3.000000, 3.000000, 0.000000])\n            ],\n            \"d_thr\": 5.0,\n            \"s_min\": 2\n        }\n    ]\n\n    formatted_results = []\n    for case in test_cases:\n        result_tuple = process_case(case[\"coords\"], case[\"d_thr\"], case[\"s_min\"])\n        formatted_results.append(format_result(result_tuple))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2416453"}, {"introduction": "结构可视化的真正力量在于整合不同类型的数据。这最后一个练习将引导你完成生物信息学中的一个核心任务：将多重序列比对得到的序列保守性信息映射到三维蛋白质结构上。通过学习计算香农熵（Shannon entropy）和识别可变区域，你将看到结构与进化信息如何共同揭示对蛋白质功能的深刻见解。[@problem_id:2416426]", "problem": "编写一个程序，将以下可视化原则形式化：为了只可视化蛋白质在多序列比对（MSA）中不保守的原子，必须根据MSA计算列式保守性得分，识别哪些比对位置是可变的，将这些位置映射回所选参考序列中的残基索引，然后在三维空间中选择相应的原子。在本问题中，将每个残基视为由其α-碳原子（Cα）表示，该原子具有给定的三维坐标（单位为埃）。你的任务是为每个提供的测试用例计算被选中原子的数量以及通过回旋半径测量的其位置的空间分布。将选中的原子数量报告为整数，回旋半径报告为以埃为单位、四舍五入到三位小数的浮点数。\n\n基本定义与使用规则：\n- 多序列比对（MSA）：一个MSA是一组长度相等的已比对蛋白质序列，其中空位字符用 $-$ 表示，字母取自 $20$ 种标准氨基酸的单字母代码。将已比对的参考序列视为MSA的一部分。\n- 列频率与香农熵：对于每个比对列 $j$，设非空位氨基酸的多重集为 $X_j$。令 $n_j$ 为 $X_j$ 中非空位字符的数量。对于 $X_j$ 中观察到的每种氨基酸类型 $a$，定义经验频率 $p(a) = \\frac{\\text{count of }a}{n_j}$。该列的香农熵为\n$$\nH_j = -\\sum_{a \\in X_j^\\ast} p(a)\\,\\ln p(a),\n$$\n其中 $X_j^\\ast$ 是列 $j$ 中存在的不同氨基酸的集合，$\\ln$ 是自然对数。定义最大可能熵 $H_{\\max} = \\ln 20$。归一化熵为\n$$\n\\widehat{H}_j = \\frac{H_j}{H_{\\max}}。\n$$\n- 非保守（可变）判据：给定一个阈值 $\\tau$ 且 $0 \\le \\tau \\le 1$，当且仅当 $\\widehat{H}_j \\ge \\tau$ 时，列 $j$ 被认为是可变的。\n- 从比对列到参考残基的映射：从左到右扫描已比对的参考序列。维持一个初始化为 $-1$ 的残基索引 $k$。对于每个列位置 $j$，如果已比对的参考字符是空位 $-$，则该列不映射到任何残基索引。否则，将 $k$ 递增 $k \\leftarrow k+1$，并将列 $j$ 映射到未比对的参考序列的残基索引 $k$。未比对的参考序列长度为 $L$，其Cα坐标以 $L$ 个三维向量的形式提供，单位为埃。\n- 原子选择与几何结构：被选中的原子集合是其比对列根据上述判据为可变的参考残基的Cα坐标集合。如果选中的集合为空，则定义回旋半径为 $0$。否则，如果有 $N$ 个选中的原子，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，定义质心（质量相等）为 $\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$，回旋半径为\n$$\nR_g = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2},\n$$\n其中 $\\lVert \\cdot \\rVert$ 表示欧几里得范数。距离单位为埃。报告 $R_g$ 时四舍五入到三位小数。\n\n你的程序必须将这些步骤应用于以下测试套件。每个测试用例提供：未比对的参考序列、其Cα坐标、已比对的参考序列、其余的已比对序列以及阈值 $\\tau$。\n\n测试用例 1（无变量映射的理想路径）：\n- 参考序列（未比对）：ACDEG\n- Cα坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0),(11.4,0.0,0.0),(15.2,0.0,0.0)\\big]$\n- 已比对的参考序列：A-CDEG-\n- 其他已比对序列：AFC-EG-, A-CDE--\n- 阈值 $\\tau$：$0.5$\n\n测试用例 2（较低阈值捕获的中等变异性）：\n- 参考序列（未比对）：HIKLM\n- Cα坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.5,0.0),(7.6,1.0,0.0),(11.4,1.5,0.0),(15.2,2.0,0.0)\\big]$\n- 已比对的参考序列：HIKLM-\n- 其他已比对序列：HIKQM-, HFKLM-\n- 阈值 $\\tau$：$0.2$\n\n测试用例 3（包含空位和多个变量映射的四序列MSA）：\n- 参考序列（未比对）：NPQR\n- Cα坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0),(11.4,0.0,0.0)\\big]$\n- 已比对的参考序列：-NP-QR\n- 其他已比对序列：ANP-ER, -NP-QR, -NS-QR\n- 阈值 $\\tau$：$0.18$\n\n测试用例 4（单可变残基的边界情况）：\n- 参考序列（未比对）：WXY\n- Cα坐标（埃）：$\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0)\\big]$\n- 已比对的参考序列：W-XY\n- 其他已比对序列：W-XY, F-XY\n- 阈值 $\\tau$：$0.2$\n\n每个测试用例的所需输出：\n- 一个包含两个元素的列表 $[N, R_g]$，其中 $N$ 是选中原子的整数数量，$R_g$ 是以埃为单位、四舍五入到三位小数的回旋半径。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表，每个测试用例报告为 $[N,R_g]$，且无空格。例如，格式应类似于 $[[2,1.234],[0,0.000],[3,5.678],[1,0.000]]$（这仅是格式示例，不是正确的数值答案）。\n\n角度单位不适用。所有距离必须以埃为单位进行解释和报告。答案是按指定格式聚合的纯数字。", "solution": "所提出的问题是计算生物学中一个定义明确且具有科学依据的练习，特别是在序列进化背景下分析蛋白质结构。它要求应用标准原则：使用香农熵量化序列变异性，在比对和未比对的序列表示之间进行映射，以及计算一个基本的结构参数——回旋半径。该问题是有效的，因为它是自包含的、逻辑一致的，并且基于已建立的形式化体系。我将对每个测试用例进行逐步求解。\n\n问题的核心在于执行一个已定义的算法。让我们将这些步骤形式化。\n首先，对于给定的多序列比对（MSA），我们必须分析每一列 $j$。一列中的非空位字符集表示为 $X_j$。该多重集的大小为 $n_j$。如果 $n_j > 0$，我们确定唯一的氨基酸类型集合 $X_j^\\ast$。对于每种类型 $a \\in X_j^\\ast$，我们计算其频率 $p(a)$。该列的香农熵为 $H_j = -\\sum_{a \\in X_j^\\ast} p(a)\\,\\ln p(a)$。这通过包含 $20$ 种氨基酸的字母表的最大可能熵 $H_{\\max} = \\ln 20$ 进行归一化，得到 $\\widehat{H}_j = H_j / H_{\\max}$。如果 $\\widehat{H}_j$ 大于或等于给定的阈值 $\\tau$，则列 $j$ 被视为“可变”的。\n\n其次，我们将这些可变的列映射到未比对的参考序列的残基。我们遍历已比对的参考序列。残基索引的计数器 $k$ 初始化为 $-1$。对于每一列 $j$，如果已比对的参考序列中的字符是氨基酸，我们递增 $k$。此列 $j$ 对应于残基 $k$。如果该列被确定为可变的，则残基 $k$ 被选中。\n\n第三，我们收集 $N$ 个被选中残基的三维坐标 $\\{\\mathbf{r}_i\\}_{i=1}^N$。选中原子的数量是 $N$。如果 $N=0$，回旋半径 $R_g$ 定义为 $0$。如果 $N > 0$，我们首先计算质心 $\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$。然后，回旋半径计算为 $R_g = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2}$，其中 $\\lVert \\cdot \\rVert$ 是欧几里得范数。\n\n最大熵的值为 $H_{\\max} = \\ln(20) \\approx 2.99573$。\n\n**测试用例 1**\n- 已比对的参考序列：`A-CDEG-`\n- 其他序列：`AFC-EG-`, `A-CDE--`\n- 阈值 $\\tau = 0.5$\nMSA包含 $3$ 个序列。比对长度为 $7$。\n- 列 0 (`A,A,A`): $n_0=3$, $X_0^\\ast=\\{\\text{A}\\}$, $p(A)=1$。$H_0 = 0$。$\\widehat{H}_0=0 < 0.5$。\n- 列 1 (`-,F,-`): $n_1=1$, $X_1^\\ast=\\{\\text{F}\\}$, $p(F)=1$。$H_1 = 0$。$\\widehat{H}_1=0 < 0.5$。\n- 列 2 (`C,C,C`): $H_2=0$。$\\widehat{H}_2=0 < 0.5$。\n- 列 3 (`D,-,D`): $n_3=2$, $X_3^\\ast=\\{\\text{D}\\}$, $p(D)=1$。$H_3 = 0$。$\\widehat{H}_3=0 < 0.5$。\n- 列 4 (`E,E,E`): $H_4=0$。$\\widehat{H}_4=0 < 0.5$。\n- 列 5 (`G,G,-`): $n_5=2$, $X_5^\\ast=\\{\\text{G}\\}$, $p(G)=1$。$H_5=0$。$\\widehat{H}_5=0 < 0.5$。\n- 列 6 (`-,-,-`): $n_6=0$。$H_6 = 0$。$\\widehat{H}_6=0 < 0.5$。\n没有列满足变异性判据 $\\widehat{H}_j \\ge 0.5$。因此，没有残基被选中。\n选中原子数 $N=0$。回旋半径 $R_g=0.000$。\n结果：$[0, 0.000]$\n\n**测试用例 2**\n- 已比对的参考序列：`HIKLM-`\n- 其他序列：`HIKQM-`, `HFKLM-`\n- 阈值 $\\tau = 0.2$\n- 列 0 (`H,H,H`): $H_0=0$。$\\widehat{H}_0 = 0 < 0.2$。\n- 列 1 (`I,I,F`): $n_1=3$, $X_1^\\ast=\\{\\text{I},\\text{F}\\}$, $p(I)=2/3$, $p(F)=1/3$。$H_1 = -(\\frac{2}{3}\\ln\\frac{2}{3} + \\frac{1}{3}\\ln\\frac{1}{3}) \\approx 0.6365$。$\\widehat{H}_1 \\approx 0.6365/2.99573 \\approx 0.2125$。由于 $0.2125 \\ge 0.2$，此列是可变的。\n- 列 2 (`K,K,K`): $H_2=0$。$\\widehat{H}_2 = 0 < 0.2$。\n- 列 3 (`L,Q,L`): $n_3=3$, $X_3^\\ast=\\{\\text{L},\\text{Q}\\}$, $p(L)=2/3$, $p(Q)=1/3$。$H_3=H_1 \\approx 0.6365$。$\\widehat{H}_3 \\approx 0.2125 \\ge 0.2$。此列是可变的。\n- 列 4 (`M,M,M`): $H_4=0$。$\\widehat{H}_4 = 0 < 0.2$。\n- 列 5 (`-,-,-`): $H_5=0$。$\\widehat{H}_5 = 0 < 0.2$。\n可变的列是 $j=1$ 和 $j=3$。\n映射到参考残基 (`HIKLM-`)：\n- 列 0 (`H`) 映射到残基 $0$。不可变。\n- 列 1 (`I`) 映射到残基 $1$。可变。选中。\n- 列 2 (`K`) 映射到残基 $2$。不可变。\n- 列 3 (`L`) 映射到残基 $3$。可变。选中。\n- 列 4 (`M`) 映射到残基 $4$。不可变。\n选中了两个残基：残基 $1$ 和残基 $3$。$N=2$。对应的坐标是 $\\mathbf{r}_1=(3.8, 0.5, 0.0)$ 和 $\\mathbf{r}_3=(11.4, 1.5, 0.0)$。\n质心：$\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{2}(\\mathbf{r}_1 + \\mathbf{r}_3) = (7.6, 1.0, 0.0)$。\n与 $\\mathbf{r}_{\\mathrm{cm}}$ 的距离平方：\n$\\lVert \\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = \\lVert (3.8-7.6, 0.5-1.0, 0.0) \\rVert^2 = (-3.8)^2 + (-0.5)^2 = 14.44 + 0.25 = 14.69$。\n$\\lVert \\mathbf{r}_3 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = \\lVert (11.4-7.6, 1.5-1.0, 0.0) \\rVert^2 = (3.8)^2 + (0.5)^2 = 14.44 + 0.25 = 14.69$。\n$R_g = \\sqrt{\\frac{1}{2}(14.69 + 14.69)} = \\sqrt{14.69} \\approx 3.83275$。四舍五入到三位小数，$R_g=3.833$。\n结果：$[2, 3.833]$\n\n**测试用例 3**\n- 已比对的参考序列：`-NP-QR`\n- 其他序列：`ANP-ER`, `-NP-QR`, `-NS-QR`\n- 阈值 $\\tau = 0.18$\nMSA有 $4$ 个序列。\n- 列 0 (`-,A,-,-`): $H_0=0$。$\\widehat{H}_0 = 0 < 0.18$。\n- 列 1 (`N,N,N,N`): $H_1=0$。$\\widehat{H}_1=0 < 0.18$。\n- 列 2 (`P,P,P,S`): $n_2=4$, $X_2^\\ast=\\{\\text{P},\\text{S}\\}$, $p(P)=3/4$, $p(S)=1/4$。$H_2 = -(\\frac{3}{4}\\ln\\frac{3}{4} + \\frac{1}{4}\\ln\\frac{1}{4}) \\approx 0.5623$。$\\widehat{H}_2 \\approx 0.5623/2.99573 \\approx 0.1877$。由于 $0.1877 \\ge 0.18$，此列是可变的。\n- 列 3 (`-,-,-,-`): $H_3=0$。$\\widehat{H}_3=0 < 0.18$。\n- 列 4 (`Q,E,Q,Q`): $n_4=4$, $X_4^\\ast=\\{\\text{Q},\\text{E}\\}$, $p(Q)=3/4$, $p(E)=1/4$。$H_4=H_2 \\approx 0.5623$。$\\widehat{H}_4 \\approx 0.1877 \\ge 0.18$。此列是可变的。\n- 列 5 (`R,R,R,R`): $H_5=0$。$\\widehat{H}_5=0 < 0.18$。\n可变的列是 $j=2$ 和 $j=4$。\n映射到参考残基 (`-NP-QR`)：\n- 列 1 (`N`) 映射到残基 $0$。\n- 列 2 (`P`) 映射到残基 $1$。可变。选中。\n- 列 4 (`Q`) 映射到残基 $2$。可变。选中。\n- 列 5 (`R`) 映射到残基 $3$。\n选中了两个残基：残基 $1$ 和残基 $2$。$N=2$。坐标是 $\\mathbf{r}_1=(3.8, 0.0, 0.0)$ 和 $\\mathbf{r}_2=(7.6, 0.0, 0.0)$。\n$\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{2}(\\mathbf{r}_1 + \\mathbf{r}_2) = (5.7, 0.0, 0.0)$。\n$\\lVert \\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = (3.8-5.7)^2 = (-1.9)^2 = 3.61$。\n$\\lVert \\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = (7.6-5.7)^2 = (1.9)^2 = 3.61$。\n$R_g = \\sqrt{\\frac{1}{2}(3.61 + 3.61)} = \\sqrt{3.61} = 1.9$。四舍五入结果：$1.900$。\n结果：$[2, 1.900]$\n\n**测试用例 4**\n- 已比对的参考序列：`W-XY`\n- 其他序列：`W-XY`, `F-XY`\n- 阈值 $\\tau = 0.2$\n- 列 0 (`W,W,F`): $n_0=3$, $X_0^\\ast=\\{\\text{W},\\text{F}\\}$, $p(W)=2/3$, $p(F)=1/3$。$H_0 \\approx 0.6365$。$\\widehat{H}_0 \\approx 0.2125 \\ge 0.2$。可变。\n- 列 1 (`-,-,-`): $H_1=0$。$\\widehat{H}_1=0 < 0.2$。\n- 列 2 (`X,X,X`): $H_2=0$。$\\widehat{H}_2=0 < 0.2$。\n- 列 3 (`Y,Y,Y`): $H_3=0$。$\\widehat{H}_3=0 < 0.2$。\n只有列 $j=0$ 是可变的。\n映射到参考残基 (`W-XY`)：\n- 列 0 (`W`) 映射到残基 $0$。可变。选中。\n- 列 2 (`X`) 映射到残基 $1$。\n- 列 3 (`Y`) 映射到残基 $2$。\n选中了一个残基：残基 $0$。$N=1$。坐标为 $\\mathbf{r}_0=(0.0, 0.0, 0.0)$。\n对于 $N=1$，质心就是点本身，所以偏差为零。因此，$R_g=0$。\n结果：$[1, 0.000]$\n\n结果最终总结：\n- 用例 1: $[0, 0.000]$\n- 用例 2: $[2, 3.833]$\n- 用例 3: $[2, 1.900]$\n- 用例 4: $[1, 0.000]$\n这些结果将被格式化为所需的最终输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted output.\n    \"\"\"\n    # Foundational constant H_max = ln(20)\n    H_MAX = math.log(20)\n\n    test_cases = [\n        {\n            \"ref_unaligned\": \"ACDEG\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], [7.6, 0.0, 0.0],\n                [11.4, 0.0, 0.0], [15.2, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"A-CDEG-\",\n            \"other_aligned\": [\"AFC-EG-\", \"A-CDE--\"],\n            \"tau\": 0.5\n        },\n        {\n            \"ref_unaligned\": \"HIKLM\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.5, 0.0], [7.6, 1.0, 0.0],\n                [11.4, 1.5, 0.0], [15.2, 2.0, 0.0]\n            ]),\n            \"ref_aligned\": \"HIKLM-\",\n            \"other_aligned\": [\"HIKQM-\", \"HFKLM-\"],\n            \"tau\": 0.2\n        },\n        {\n            \"ref_unaligned\": \"NPQR\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], \n                [7.6, 0.0, 0.0], [11.4, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"-NP-QR\",\n            \"other_aligned\": [\"ANP-ER\", \"-NP-QR\", \"-NS-QR\"],\n            \"tau\": 0.18\n        },\n        {\n            \"ref_unaligned\": \"WXY\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], [7.6, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"W-XY\",\n            \"other_aligned\": [\"W-XY\", \"F-XY\"],\n            \"tau\": 0.2\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        coords = case[\"coords\"]\n        ref_aligned = case[\"ref_aligned\"]\n        other_aligned = case[\"other_aligned\"]\n        tau = case[\"tau\"]\n\n        # Step 1: Form the full MSA and analyze columns\n        msa = [ref_aligned] + other_aligned\n        aligned_len = len(ref_aligned)\n        \n        variable_columns = set()\n        for j in range(aligned_len):\n            column = [seq[j] for seq in msa]\n            non_gap_residues = [res for res in column if res != '-']\n            \n            n_j = len(non_gap_residues)\n            if n_j == 0:\n                h_j_norm = 0.0\n            else:\n                counts = Counter(non_gap_residues)\n                h_j = 0.0\n                for count in counts.values():\n                    p_a = count / n_j\n                    if p_a > 0:\n                        h_j -= p_a * math.log(p_a)\n                \n                h_j_norm = h_j / H_MAX\n            \n            if h_j_norm >= tau:\n                variable_columns.add(j)\n\n        # Step 2: Map columns to reference residues and identify variable ones\n        variable_residue_indices = []\n        residue_idx = -1\n        for j, char in enumerate(ref_aligned):\n            if char != '-':\n                residue_idx += 1\n                if j in variable_columns:\n                    variable_residue_indices.append(residue_idx)\n\n        # Step 3: Select atoms and compute geometry\n        selected_coords = coords[variable_residue_indices]\n        N = len(selected_coords)\n\n        if N == 0:\n            Rg = 0.0\n        else:\n            # Handle N=1 case; Rg is 0\n            if N == 1:\n                Rg = 0.0\n            else: # N > 1\n                center_of_mass = np.mean(selected_coords, axis=0)\n                # Correct calculation for Radius of Gyration\n                # Rg = sqrt( (1/N) * sum_i( ||r_i - r_cm||^2 ) )\n                # ||v||^2 is sum(v_j^2)\n                squared_distances = np.sum((selected_coords - center_of_mass)**2, axis=1)\n                Rg = np.sqrt(np.mean(squared_distances))\n\n        results.append(f\"[{N},{Rg:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416426"}]}