{"hands_on_practices": [{"introduction": "在蛋白质组学工作流程中，第一步是通过质谱（MS1）扫描来识别待分析的肽段前体离子。这个练习将带你实践一个核心技能：如何从测得的质荷比（$m/z$）和电荷态（$z$）反推出肽段的原始中性质量。掌握这一基本计算是解读任何质谱数据、开启后续序列鉴定之旅的起点 [@problem_id:2140873]。", "problem": "在一次自下而上蛋白质组学实验中，一个纯化的蛋白质被酶解成更小的肽段。然后使用电喷雾电离串联质谱仪对这些肽段进行分析。在初始的全扫描中，检测到一个与其中一个肽段相对应的离子，作为前体离子。观测到该前体离子的质荷比 ($m/z$) 为 451.2。进一步的分析表明，该离子带有 +2 的电荷态。在这类分析中，电荷是通过向中性肽分子中添加质子而产生的。已知一个质子的单同位素质量为 $1.007 \\text{ Da}$，请计算完整肽段的中性单同位素质量。\n\n以道尔顿 (Da) 为单位表示您的答案，并四舍五入到四位有效数字。", "solution": "对于电喷雾质子化，观测到的质荷比满足\n$$\n\\frac{m}{z}=\\frac{M+z \\cdot m_{p}}{z}= \\frac{M}{z}+m_{p},\n$$\n其中，$M$ 是肽段的中性单同位素质量，$z$ 是电荷态，$m_{p}$ 是质子的单同位素质量。求解 $M$ 可得\n$$\nM=z\\left(\\frac{m}{z}-m_{p}\\right).\n$$\n代入 $z=2$，$\\frac{m}{z}=451.2$ 和 $m_{p}=1.007$：\n$$\nM=2\\left(451.2-1.007\\right)=2\\cdot 450.193=900.386.\n$$\n四舍五入到四位有效数字，得到 $M=900.4 \\text{ Da}$。", "answer": "$$\\boxed{900.4}$$", "id": "2140873"}, {"introduction": "确定了前体离子的质量后，下一步是通过串联质谱（MS/MS）将其破碎，以获取序列信息。此练习专注于从一个已知的肽段序列中计算出特定碎片离子（例如 $b$ 型离子）的理论 $m/z$ 值 [@problem_id:2140831]。这项计算是连接肽段序列与其碎片质谱图的桥梁，也是构建理论谱图库用于数据库搜索识别未知肽段的基础。", "problem": "在一个蛋白质组学实验室中，一位研究人员正在使用串联质谱（MS）分析一个短肽。MS的第一阶段（MS1）表明该肽的氨基酸组成为 A、P、G。随后使用碰撞诱导解离（CID）进行分析以确定其精确序列。按照惯例，肽序列的书写方向是从N-末端到C-末端。在MS/MS谱图中观察到的主要碎片之一是 $b$ 离子，这是一种包含N-末端的碎片。\n\n假设该肽序列被确定为丙氨酸-脯氨酸-甘氨酸三肽（APG），请计算其 $b_2$ 碎片离子的理论质荷比（$m/z$）。该离子带单个正电荷（$z=1$）。\n\n在计算中使用以下单同位素质量：\n- 丙氨酸（A）的残基质量：$71.03711 \\text{ Da}$\n- 脯氨酸（P）的残基质量：$97.05276 \\text{ Da}$\n- 甘氨酸（G）的残基质量：$57.02146 \\text{ Da}$\n- 质子（$H^+$）的质量：$1.00728 \\text{ Da}$\n\n将您的最终 $m/z$ 比值答案四舍五入至五位有效数字。", "solution": "一个 $b$ 离子包含N-末端的残基。对于一个给定了残基质量（已扣除水的质量）的肽，带有电荷 $z$ 的 $b_{n}$ 离子的单同位素质量是前 $n$ 个残基质量的总和，再加上携带电荷的质子的质量。因此，对于 $z=1$ 的情况，\n$$\nm(b_{n})=\\sum_{i=1}^{n} m_{\\text{residue},i} + m_{\\mathrm{H}^{+}}, \\quad \\text{and} \\quad \\frac{m}{z}=\\frac{m(b_{n})}{1}=m(b_{n}).\n$$\n对于 APG，$b_{2}$ 离子对应于残基 A 和 P，因此\n$$\nm(b_{2}) = m_{\\mathrm{A}} + m_{\\mathrm{P}} + m_{\\mathrm{H}^{+}}.\n$$\n代入给定的单同位素质量值，\n$$\nm(b_{2}) = 71.03711 + 97.05276 + 1.00728 = (71.03711 + 97.05276) + 1.00728\n$$\n$$\n71.03711 + 97.05276 = 168.08987\n$$\n$$\nm(b_{2}) = 168.08987 + 1.00728 = 169.09715.\n$$\n当 $z=1$ 时，$m/z$ 值等于这个质量。四舍五入到五位有效数字得到 $169.10$。", "answer": "$$\\boxed{169.10}$$", "id": "2140831"}, {"introduction": "在现代蛋白质组学中，序列鉴定是一个高度自动化的计算过程。这个高级练习将引导你实现一个简化的交叉相关（cross-correlation）评分函数，这正是著名的 X-Corr 等算法的核心思想 [@problem_id:2433489]。通过比较理论谱图和实验谱图，你将亲身体验如何量化匹配的优劣，并理解现代蛋白质鉴定搜索引擎是如何在海量数据中准确地找到目标肽段的。", "problem": "给定一个简化的互相关评分函数的定义，用于在通过串联质谱（MS/MS, tandem mass spectrometry）进行肽序列测定的背景下，比较理论串联质谱与实验串联质谱。目标是计算一个扣除背景的互相关分数，该分数旨在强调理论碎片离子位置与实验信号之间的一致性，同时减少共同噪声模式的贡献。每个质荷比（$m/z$, mass-to-charge ratio）都应以道尔顿/基本电荷（$\\text{Da/e}$）为单位进行解释。强度是无量纲的非负数。\n\n设实验谱是有限的配对集合 $\\{($m/z_j, I_j$)\\}$，其中 $m/z_j \\in \\mathbb{R}_{\\ge 0}$ 的单位是 $\\text{Da/e}$，且 $I_j \\in \\mathbb{R}_{\\ge 0}$。设理论谱是有限的 $m/z$ 位置集合 $\\{t_k\\}$，其中 $t_k \\in \\mathbb{R}_{\\ge 0}$ 的单位是 $\\text{Da/e}$。使用以下定义来构建分箱向量并计算分数。\n\n- 使用 $\\Delta m = 1\\,\\text{Da/e}$ 的箱宽（bin width）和取整函数 $\\rho(x) = \\lfloor x + 0.5 \\rfloor$ 将每个 $m/z$ 映射到一个整数箱索引（bin index）。\n- 设最大箱索引为 $M = \\max\\big(\\{\\rho(m/z_j)\\} \\cup \\{\\rho(t_k)\\}\\big) + L$，其中 $L$ 是下面定义的偏移窗口大小。\n- 通过为每个整数箱 $i \\in \\{0,1,\\dots,M\\}$ 设置以下值来构建实验向量 $\\mathbf{E} \\in \\mathbb{R}^{M+1}$，\n$$\nE_i = \\max\\{ I_j \\,:\\, \\rho(m/z_j) = i \\}\n$$\n并约定 $\\max(\\varnothing) = 0$。\n- 通过为每个整数箱 $i \\in \\{0,1,\\dots,M\\}$ 设置以下值来构建理论向量 $\\mathbf{T} \\in \\mathbb{R}^{M+1}$，\n$$\nT_i = \\begin{cases}\n1, & \\text{if there exists } t_k \\text{ with } \\rho(t_k) = i, \\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\n- 对于任何整数偏移 $s$，将偏移 $s$ 处的互相关定义为\n$$\nC(s) = \\sum_{i=0}^{M} E_i \\, T_{i - s},\n$$\n其中，当 $i - s \\notin \\{0,1,\\dots,M\\}$ 时，$T_{i - s} = 0$。\n- 对于一个固定的非负整数窗口大小 $L$，将扣除背景的互相关分数定义为\n$$\n\\text{XCorr} = C(0) - \\frac{1}{2L}\\sum_{\\substack{s=-L \\\\ s \\ne 0}}^{L} C(s).\n$$\n\n请实现一个程序，为下方的每个测试用例计算 $\\text{XCorr}$。计算时，使用 $L = 2$ 和 $\\Delta m = 1\\,\\text{Da/e}$，并按照指定使用取整函数 $\\rho(x) = \\lfloor x + 0.5 \\rfloor$。所有的 $m/z$ 值的单位均为 $\\text{Da/e}$。对于每个测试用例，将分数输出为四舍五入到 $6$ 位小数的实数。\n\n测试套件：\n\n- 测试用例 1（包含信号和噪声的一般情况）：\n  - 理论 $m/z$ 列表: $[147.113,\\,260.159,\\,373.206,\\,486.253]$。\n  - 实验峰 ($m/z, I$):\n    $[(147.11,\\,50.0),\\,(260.16,\\,40.0),\\,(373.21,\\,45.0),\\,(486.25,\\,35.0),\\,(105.0,\\,5.0),\\,(212.0,\\,8.0),\\,(333.0,\\,6.0),\\,(444.0,\\,7.0),\\,(555.0,\\,9.0)]$。\n- 测试用例 2（几乎没有或完全没有对齐）：\n  - 理论 $m/z$ 列表: $[147.113,\\,260.159,\\,373.206,\\,486.253]$。\n  - 实验峰 ($m/z, I$):\n    $[(120.0,\\,20.0),\\,(240.0,\\,15.0),\\,(360.0,\\,12.0),\\,(480.0,\\,10.0),\\,(600.0,\\,5.0)]$。\n- 测试用例 3（空理论谱，边界条件）：\n  - 理论 $m/z$ 列表: $[]$。\n  - 实验峰 ($m/z, I$):\n    $[(150.0,\\,10.0),\\,(300.0,\\,10.0),\\,(450.0,\\,10.0)]$。\n- 测试用例 4（空实验谱，边界条件）：\n  - 理论 $m/z$ 列表: $[200.0,\\,400.0,\\,600.0]$。\n  - 实验峰 ($m/z, I$): $[]$。\n\n您的程序应生成单行输出，其中包含按上述测试用例顺序排列的四个分数。输出格式为一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 都四舍五入到 $6$ 位小数。因为该输出是由强度计算出的分数，所以它没有物理单位。", "solution": "问题陈述已经过严格评估，并被确定为有效。它具有科学依据，提法明确，且客观公正。它清晰、形式化地定义了一个简化的互相关评分函数 $\\text{XCorr}$，该函数用于肽识别中串联质谱的计算分析。所有必需的参数、定义和测试数据均已提供，从而可以得出一个唯一且可验证的解。我们将着手提供一个完整的、有理有据的解决方案。\n\n目标是计算 $\\text{XCorr}$ 分数，该分数用于量化理论肽段碎裂谱与实验串联质谱之间的匹配质量。该方法基于离散互相关，并包含一个背景扣除步骤，旨在减少噪声并增强真实匹配的信号。\n\n计算过程包括以下几个阶段：\n\n1.  **谱图离散化**：连续的质荷比（$m/z$）数据必须转换为离散格式。这是通过分箱（binning）实现的。给定箱宽 $\\Delta m = 1\\,\\text{Da/e}$，每个 $m/z$ 值 $x$ 通过取整函数 $\\rho(x) = \\lfloor x + 0.5 \\rfloor$ 映射到一个整数箱索引 $i$。该函数将实数四舍五入到最近的整数，其中 .5 向上取整。\n\n2.  **向量表示**：将两个谱图转换为数值向量 $\\mathbf{E}$（实验）和 $\\mathbf{T}$（理论），它们基于一个从 $0$ 到 $M$ 的共同离散箱索引域。最大索引 $M$ 定义为 $M = \\max\\big(\\{\\rho(m/z_j)\\} \\cup \\{\\rho(t_k)\\}\\big) + L$，其中 $\\{\\rho(m/z_j)\\}$ 和 $\\{\\rho(t_k)\\}$ 分别是来自实验谱和理论谱的分箱索引集合，而 $L$ 是给定的整数偏移窗口大小。这确保了向量足够大，可以容纳所有谱峰以及所有高达 $\\pm L$ 的必需偏移。\n\n    -   **实验向量 $\\mathbf{E}$** 存储强度信息。对于每个箱 $i \\in \\{0, 1, \\dots, M\\}$，$E_i$ 的值是落入该箱的所有实验峰的最大强度。如果没有谱峰映射到箱 $i$，则根据约定 $\\max(\\varnothing) = 0$，有 $E_i = 0$。此步骤有效地处理了原始谱图数据，在每个标称质量单位中保留了最显著的信号。\n\n    -   **理论向量 $\\mathbf{T}$** 是预期碎片离子质量的二元表示。对于每个箱 $i \\in \\{0, 1, \\dots, M\\}$，如果至少有一个理论 $m/z$ 值 $t_k$ 映射到箱 $i$，则 $T_i$ 的值设为 $1$。否则，$T_i$ 为 $0$。这将理论谱理想化为一个“谱棍图”（stick plot），其中只考虑在给定标称质量处是否存在谱峰，而不考虑其强度。\n\n3.  **互相关计算**：该方法的核心是计算两个向量在一系列整数偏移 $s$ 下的互相关函数 $C(s)$。该函数定义为：\n    $$\n    C(s) = \\sum_{i=0}^{M} E_i \\, T_{i - s}\n    $$\n    在此，如果索引 $i-s$ 超出有效范围 $[0, M]$，则 $T_{i-s}$ 被理解为 $0$。此操作将理论向量 $\\mathbf{T}$ 相对于实验向量 $\\mathbf{E}$ 滑动一个偏移量 $s$ 并计算其点积。\n\n    -   在偏移 $s=0$ 时，$C(0) = \\sum_{i=0}^{M} E_i T_i$ 衡量了实验强度与预期谱峰位置之间的直接重叠。$C(0)$ 的高值表明初始对齐良好。\n\n    -   对于偏移 $s \\ne 0$，$C(s)$ 衡量了在偏移位置上的相关性。这些值共同构成一个背景或噪声分布。在非零偏移处的显著相关性可能表明存在系统性噪声或随机对齐，这些都应与真实信号区分开来。\n\n4.  **扣除背景的分数 ($\\text{XCorr}$)**：最终分数通过从零偏移相关性中减去背景相关的平均值来计算。公式为：\n    $$\n    \\text{XCorr} = C(0) - \\frac{1}{2L}\\sum_{\\substack{s=-L \\\\ s \\ne 0}}^{L} C(s)\n    $$\n    在此，求和遍及从 $-L$ 到 $L$ 的所有整数偏移（不包括 $s=0$）。共有 $2L$ 个这样的项。通过减去这些“偏离中心”的相关性的平均值，该分数会对主对齐和偏移对齐中共同存在的任何特征进行惩罚。这提高了分数的特异性，使其对可能与理论模式偶然相关的噪声更具鲁棒性。在本问题中，给定 $L=2$。\n\n该实现将为每个提供的测试用例系统地遵循这些步骤。互相关 $C(s)$ 可以使用提供此常见信号处理操作的优化算法的标准数值库来高效计算。每个测试用例的最终结果将按要求四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cross-correlation problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case with signal and noise)\n        {\n            \"theoretical_mz\": [147.113, 260.159, 373.206, 486.253],\n            \"experimental_peaks\": [\n                (147.11, 50.0), (260.16, 40.0), (373.21, 45.0), (486.25, 35.0),\n                (105.0, 5.0), (212.0, 8.0), (333.0, 6.0), (444.0, 7.0), (555.0, 9.0)\n            ],\n        },\n        # Test case 2 (little or no alignment)\n        {\n            \"theoretical_mz\": [147.113, 260.159, 373.206, 486.253],\n            \"experimental_peaks\": [\n                (120.0, 20.0), (240.0, 15.0), (360.0, 12.0),\n                (480.0, 10.0), (600.0, 5.0)\n            ],\n        },\n        # Test case 3 (empty theoretical spectrum)\n        {\n            \"theoretical_mz\": [],\n            \"experimental_peaks\": [\n                (150.0, 10.0), (300.0, 10.0), (450.0, 10.0)\n            ],\n        },\n        # Test case 4 (empty experimental spectrum)\n        {\n            \"theoretical_mz\": [200.0, 400.0, 600.0],\n            \"experimental_peaks\": [],\n        },\n    ]\n\n    L = 2\n    results = []\n    \n    for case in test_cases:\n        score = compute_xcorr(\n            case[\"theoretical_mz\"],\n            case[\"experimental_peaks\"],\n            L\n        )\n        results.append(f\"{score:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\ndef compute_xcorr(theoretical_mz, experimental_peaks, L):\n    \"\"\"\n    Computes the background-subtracted cross-correlation score (XCorr).\n\n    Args:\n        theoretical_mz (list): A list of theoretical m/z values.\n        experimental_peaks (list): A list of (m/z, intensity) tuples.\n        L (int): The shift window size.\n\n    Returns:\n        float: The computed XCorr score.\n    \"\"\"\n    \n    # 1. Discretization of Spectra using rounding rho(x) = floor(x + 0.5)\n    def rho(x):\n        return int(x + 0.5)\n\n    rho_t_bins = {rho(mz) for mz in theoretical_mz}\n    \n    exp_bins_map = {}\n    for mz, intensity in experimental_peaks:\n        bin_idx = rho(mz)\n        # E_i is the max intensity in a bin\n        exp_bins_map[bin_idx] = max(exp_bins_map.get(bin_idx, 0.0), intensity)\n    rho_e_bins = set(exp_bins_map.keys())\n\n    # 2. Vector Representation\n    all_binned_values = rho_t_bins.union(rho_e_bins)\n    \n    # Handle empty spectra cases gracefully by providing a default to max()\n    max_bin_val = max(all_binned_values, default=-1)\n    \n    M = max_bin_val + L\n    vec_size = M + 1\n    \n    if vec_size <= 0: # If both spectra are empty and L is small\n        return 0.0\n\n    E = np.zeros(vec_size)\n    T = np.zeros(vec_size)\n\n    for bin_idx, intensity in exp_bins_map.items():\n        if bin_idx <= M:\n            E[bin_idx] = intensity\n    \n    for bin_idx in rho_t_bins:\n        if bin_idx <= M:\n            T[bin_idx] = 1.0\n\n    # 3. Cross-Correlation Calculation\n    # C(s) = sum_i E[i] * T[i-s]\n    # np.correlate(E, T, mode='full')[k] = sum_n E[n+k] * T[n]\n    # Let lag k = s in problem, then C(s) is sum_i E[i] * T[i-s].\n    # Let m = i-s, so i = m+s. C(s) = sum_m E[m+s] * T[m].\n    # So C(s) from problem corresponds to NumPy correlate with lag k=s, with E as first arg.\n    # The output of np.correlate has length 2*vec_size-1.\n    # The zero-lag (s=0) is at index vec_size - 1.\n    # Lag s is at index (vec_size - 1) + s.\n    \n    correlation = np.correlate(E, T, mode='full')\n    zero_lag_idx = vec_size - 1\n    \n    C0 = correlation[zero_lag_idx]\n    \n    # 4. Background-Subtracted Score\n    background_sum = 0.0\n    for s in range(1, L + 1):\n        background_sum += correlation[zero_lag_idx + s] # C(s)\n        background_sum += correlation[zero_lag_idx - s] # C(-s)\n    \n    if 2 * L > 0:\n        avg_background = background_sum / (2 * L)\n        xcorr = C0 - avg_background\n    else: # Avoid division by zero if L=0\n        xcorr = C0\n        \n    return xcorr\n\nsolve()\n```", "id": "2433489"}]}