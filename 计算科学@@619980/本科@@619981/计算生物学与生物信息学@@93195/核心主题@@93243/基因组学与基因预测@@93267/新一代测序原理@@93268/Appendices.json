{"hands_on_practices": [{"introduction": "在启动任何下一代测序（NGS）项目之前，一个关键的初始步骤是估算将产生的数据量。这个练习将指导你完成一个典型的全基因组测序场景的“信封背面”计算，让你能够根据测序深度、读长和基因组大小等核心参数，预测原始数据的存储需求 [@problem_id:2417496]。掌握这项技能对于项目规划、预算制定和计算资源管理至关重要。", "problem": "一个全基因组测序实验，对大小为 $3.2\\times 10^{9}$ 个碱基对的单倍体人类基因组进行 $30\\times$ 深度测序。该实验使用 $150$ 碱基对的双末端读段，并在一个输出原始读段为 FASTQ (Fast All-in-one Sequence with Quality) 文本格式的平台上进行。假设如下：\n\n- 覆盖深度定义为测序总碱基数除以单倍体基因组大小。\n- 每个读段长度为 $L=150$ 个碱基，并以一个四行的 FASTQ 记录表示：一个以字符 $@$ 开头的标题行；一个由 $L$ 个核苷酸字符组成的序列行；一个以字符 $+$ 开头且不含其他注释的加号行；以及一个由 $L$ 个美国信息交换标准代码 (ASCII) 字符组成的质量行，用于编码每个碱基的质量得分。\n- 所有字符均为单字节 ASCII，并且每行以一个 $1$ 字节的换行符结尾。\n- 每个读段的标题行在换行符前恰好包含 $40$ 个 ASCII 字符（包括开头的 $@$）。\n- FASTQ 文件是未压缩的。\n- 使用千兆字节的十进制定义，其中 $1$ 千兆字节 = $10^{9}$ 字节。\n\n估算整个实验生成的总数据量，以千兆字节为单位。将您的答案四舍五入到三位有效数字，并以千兆字节表示。", "solution": "对问题进行验证。\n\n从问题陈述中逐字提取的已知条件：\n- 单倍体人类基因组大小: $G = 3.2 \\times 10^9$ base pairs\n- 目标覆盖深度: $C = 30\\times$\n- 读段长度: $L = 150$ base pairs\n- 读段类型: paired-end\n- 输出格式: FASTQ\n- FASTQ记录结构:\n    - 标题行: $40$ 个字符 (包括 $@$) + $1$ 个换行符\n    - 序列行: $L$ 个字符 + $1$ 个换行符\n    - 加号行: $1$ 个字符 ($+$) + $1$ 个换行符\n    - 质量行: $L$ 个字符 + $1$ 个换行符\n- 字符编码: single-byte ASCII\n- 行终止符: $1$ byte newline\n- 文件格式: uncompressed\n- 单位换算: $1$ gigabyte = $10^9$ bytes\n- 要求精度: 将最终答案四舍五入到三位有效数字\n\n验证结论：\n该问题具有科学依据、提法明确且客观。它描述了一个标准的全基因组测序生物信息学场景。所提供的参数，如基因组大小 ($G$)、覆盖深度 ($C$) 和读段长度 ($L$)，对于人类测序项目是符合实际的。对 FASTQ 格式的描述是准确的，足以进行计算。该问题是自洽、一致的，并且需要一个直接、可形式化的计算。因此，该问题被认定为有效，并将提供解答。\n\n目标是计算测序实验生成的总数据量，以千兆字节为单位。\n\n首先，我们计算测序的总碱基数，记为 $B_{total}$。该值是基因组大小 $G = 3.2 \\times 10^9$ base pairs 与覆盖深度 $C = 30$ 的乘积。\n$$B_{total} = G \\times C$$\n代入给定值：\n$$B_{total} = (3.2 \\times 10^9) \\times 30 = 9.6 \\times 10^{10} \\text{ bases}$$\n\n接下来，我们确定单个读段的总数，记为 $N_{reads}$。由于每个读段的长度为 $L = 150$ 个碱基，读段总数是测序总碱基数除以单个读段的长度。\n$$N_{reads} = \\frac{B_{total}}{L}$$\n代入 $B_{total}$ 和 $L$ 的值：\n$$N_{reads} = \\frac{9.6 \\times 10^{10}}{150} = \\frac{96 \\times 10^9}{150} = 0.64 \\times 10^9 = 6.4 \\times 10^8 \\text{ reads}$$\n每个读段对应一条 FASTQ 记录。因此，总共有 $6.4 \\times 10^8$ 条 FASTQ 记录。\n\n现在，我们计算单条 FASTQ 记录的大小 $S_{read}$（以字节为单位）。问题指明，所有字符都是单字节ASCII（每个字符 $1$ 字节），每行以一个换行符（$1$ 字节）结尾。FASTQ 记录由 $4$ 行组成：\n1.  标题行：该行在换行符前包含 $40$ 个字符。总大小为 $40 \\text{ bytes} + 1 \\text{ byte} = 41 \\text{ bytes}$。\n2.  序列行：该行包含 $L = 150$ 个核苷酸字符。总大小为 $150 \\text{ bytes} + 1 \\text{ byte} = 151 \\text{ bytes}$。\n3.  加号行：该行包含单个字符 `$+$`。总大小为 $1 \\text{ byte} + 1 \\text{ byte} = 2 \\text{ bytes}$。\n4.  质量行：该行包含 $L = 150$ 个质量得分字符。总大小为 $150 \\text{ bytes} + 1 \\text{ byte} = 151 \\text{ bytes}$。\n\n一条 FASTQ 记录的总大小是这四行大小的总和：\n$$S_{read} = 41 + 151 + 2 + 151 = 345 \\text{ bytes}$$\n\n生成的总数据量 $S_{total}$ 是读段总数 $N_{reads}$ 与单条读段记录大小 $S_{read}$ 的乘积。\n$$S_{total} = N_{reads} \\times S_{read}$$\n代入计算出的值：\n$$S_{total} = (6.4 \\times 10^8) \\times 345 = 2208 \\times 10^8 = 2.208 \\times 10^{11} \\text{ bytes}$$\n\n最后，我们使用给定的换算因子 $1 \\text{ GB} = 10^9 \\text{ bytes}$，将总大小从字节转换为千兆字节 (GB)。\n$$S_{total, \\text{GB}} = \\frac{S_{total}}{10^9} = \\frac{2.208 \\times 10^{11}}{10^9} = 2.208 \\times 10^2 = 220.8 \\text{ GB}$$\n\n问题要求将答案四舍五入到三位有效数字。将数值 $220.8$ 四舍五入到三位有效数字是 $221$。", "answer": "$$\\boxed{221}$$", "id": "2417496"}, {"introduction": "为了提高测序通量和成本效益，研究人员通常会将多个样本混合（即“多路复用”）并在一次运行中进行测序。这个过程依赖于为每个样本分配独特的DNA条形码，以便在数据分析时能够准确地将读段分离回其原始样本。本练习挑战你应用编码理论中的基本概念——汉明距离（Hamming distance），来设计一组能够容忍测序错误的健壮条形码 [@problem_id:2417498]，这揭示了计算设计原则在确保NGS实验数据完整性中的核心作用。", "problem": "您的任务是在替换错误模型下，为多重下一代测序 (NGS) 的解复用构建条形码集。设核苷酸字母表为有限集 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，其大小 $\\lvert \\Sigma \\rvert = 4$。对于一个整数长度 $L \\ge 1$，一个条形码是任意字符串 $x \\in \\Sigma^{L}$。对于两个条形码 $x,y \\in \\Sigma^{L}$，它们的汉明距离定义为\n$$\nH(x,y) = \\lvert \\{ i \\in \\{1,\\dots,L\\} \\,:\\, x_i \\ne y_i \\} \\rvert.\n$$\n一个大小为 $\\lvert S \\rvert = N$ 的条形码集 $S \\subseteq \\Sigma^{L}$ 具有最小距离\n$$\n\\delta(S) = \\min_{\\substack{x,y \\in S \\\\ x \\ne y}} H(x,y).\n$$\n给定整数 $L$、$N$ 和 $d$，一个有效的集合必须满足 $\\delta(S) \\ge d$。在解复用过程中的单碱基替换错误模型下，至少为 $d=3$ 的最小汉明距离足以容忍每个读长（read）发生一次替换错误。\n\n对于下面测试套件中的每个测试用例 $(L,N,d)$，构建任意一个满足 $\\delta(S) \\ge d$ 的条形码集 $S \\subseteq \\Sigma^{L}$，并报告在约束条件 $\\lvert S \\rvert \\le N$ 下实际达到的集合大小（一个整数）$\\lvert S \\rvert$。如果没有任何一对不同的条形码能满足所需的距离，当 $N \\ge 1$ 时，您可以输出 $\\lvert S \\rvert = 1$（因为单元素集没有违反条件的元素对）；当 $N=0$ 时，输出 $\\lvert S \\rvert = 0$。\n\n测试套件：\n- 用例 A（与 NGS 解复用相关的正常路径）：$(L,N,d) = (10,8,3)$。\n- 用例 B（紧凑的小实例可行性）：$(L,N,d) = (2,4,2)$。\n- 用例 C（受字母表限制的边界情况）：$(L,N,d) = (1,5,1)$。\n- 用例 D（低于字母表容量的大型可行请求）：$(L,N,d) = (3,20,1)$。\n- 用例 E（距离超过长度；重要的边缘用例）：$(L,N,d) = (3,2,4)$。\n\n您的程序必须为每个用例计算出如上定义的整数 $\\lvert S \\rvert$。\n\n最终输出格式：您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[a,b,c,d,e]\"）。结果必须按照测试用例 A 到 E 的顺序排列，并且每个结果都必须是整数。", "solution": "所述问题在科学上是合理的、提法明确且内部一致。它解决了下一代测序 (NGS) 实验设计中的一个基本任务：为样本多路复用构建条形码集。核苷酸字母表 $\\Sigma$、长度为 $L$ 的字符串形式的条形码、汉明距离 $H(x,y)$ 以及集合的最小距离 $\\delta(S)$ 等概念，在编码理论及其在生物信息学中的应用中都是标准概念。该问题是有效的，并且允许采用直接的构造性解法。\n\n任务是为给定的参数 $(L, N, d)$ 构建一个条形码集 $S \\subseteq \\Sigma^L$，其中 $L$ 是条形码长度，$d$ 是要求的最小汉明距离，$N$ 是集合的最大期望大小。我们需要报告所构建集合的实际大小 $\\lvert S \\rvert$，其中 $\\lvert S \\rvert \\le N$。问题允许构建*任意*一个这样的集合。这为我们采用确定性的贪心算法提供了自由度。\n\n所提出的算法如下：\n1. 为条形码初始化一个空集 $S = \\emptyset$。字母表为 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$，我们可以将其数值表示为 $\\{0, 1, 2, 3\\}$。\n2. 系统地生成所有长度为 $L$ 的可能条形码。共有 $4^L$ 个这样的条形码。采用固定的字典序生成顺序可确保可复现性。\n3. 对于每个候选条形码 $x$，检查它是否可以被添加到集合 $S$ 中。如果满足以下两个条件，则可以添加：\n    a. 集合的当前大小小于目标大小，即 $\\lvert S \\rvert < N$。\n    b. $x$ 与 $S$ 中已有的每个条形码 $y$ 的汉明距离至少为 $d$，即对于所有 $y \\in S$ 都有 $H(x,y) \\ge d$。\n4. 如果两个条件都满足，则将 $x$ 添加到 $S$ 中。\n5. 继续这个过程，直到集合 $S$ 达到大小 $N$，或者所有 $4^L$ 个潜在的条形码都已被评估完毕。\n6. 最终的大小 $\\lvert S \\rvert$ 即为给定的 $(L, N, d)$ 的结果。\n\n这种贪心策略保证能生成一个满足指定标准的有效集合。在整个构建过程中，显式约束 $\\lvert S \\rvert \\le N$ 都得到了遵守。\n\n特定约束和测试用例分析：\n- 对于任何 $N=0$ 的测试用例，唯一可能的集合是空集，因此 $\\lvert S \\rvert = 0$。\n- 对于最小距离 $d$ 大于条形码长度 $L$ 的情况（例如，用例 E $(L,N,d) = (3,2,4)$），不可能找到两个不同的条形码 $x, y$ 满足 $H(x,y) \\ge d$，因为最大可能的汉明距离是 $L$。问题陈述正确地为这种情况提供了一条规则：如果 $N \\ge 1$，大小为 $\\lvert S \\rvert=1$ 的集合是一个有效输出，因为单元素集没有不同的元素对，因此空洞地（vacuously）满足任何最小距离条件。我们的贪心算法会自然地处理这种情况：它会添加第一个有效的条形码，之后无法再添加任何其他条形码。由于在检查 $N=0$ 之后，所有此类测试用例中都有 $N \\ge 1$，因此结果将为 $1$。\n- 对于最小距离为 $d=1$ 的情况（例如，用例 C 和 D），条件 $H(x,y) \\ge 1$ 仅仅要求集合中的所有条形码都是唯一的。问题于是简化为从总共 $4^L$ 个可用的条形码中，选择最多 $N$ 个不同的条形码。因此，这种集合的最大大小为 $\\min(N, 4^L)$。\n- 对于用例 C，$(L,N,d) = (1,5,1)$，条形码总数为 $4^1 = 4$。期望的大小是 $N=5$。因此，可实现的最大大小是 $\\min(5, 4) = 4$。\n- 对于用例 D，$(L,N,d) = (3,20,1)$，条形码总数为 $4^3 = 64$。期望的大小是 $N=20$。因此，可实现的最大大小是 $\\min(20, 64) = 20$。\n\n具体实现将使用 NumPy 整数数组来表示条形码。所有可能条形码的生成将由 `itertools.product` 处理，而汉明距离的计算则通过使用 NumPy 中的向量化比较和求和来高效执行。该算法将应用于每个测试用例，以生成最终的结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Constructs barcode sets for given parameters and reports their sizes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (L, N, d) where:\n    # L: barcode length\n    # N: maximum desired set size\n    # d: minimum Hamming distance\n    test_cases = [\n        (10, 8, 3),   # Case A: Standard NGS application\n        (2, 4, 2),    # Case B: Small, tight instance\n        (1, 5, 1),    # Case C: Alphabet-limited case\n        (3, 20, 1),   # Case D: Large feasible request\n        (3, 2, 4),    # Case E: Impossible distance requirement\n    ]\n\n    results = []\n    \n    # Process each test case\n    for L, N, d in test_cases:\n        # If the maximum desired size is 0, the set must be empty.\n        if N == 0:\n            results.append(0)\n            continue\n\n        # If the required minimum distance d is greater than the barcode length L,\n        # no two distinct barcodes can satisfy the condition.\n        # As per the problem, if N >= 1, a set of size 1 is a valid result.\n        if d > L:\n            results.append(1)\n            continue\n\n        # Use a greedy algorithm to construct the barcode set.\n        barcode_set = []\n        \n        # The alphabet size is 4 (e.g., {A, C, G, T}).\n        # We represent nucleotides as integers {0, 1, 2, 3}.\n        alphabet_size = 4\n        \n        # Create an iterator that generates all possible barcodes of length L.\n        all_barcodes_iter = itertools.product(range(alphabet_size), repeat=L)\n\n        for bc_tuple in all_barcodes_iter:\n            # Stop if the set has reached the desired size N.\n            if len(barcode_set) == N:\n                break\n            \n            # Represent the candidate barcode as a NumPy array for efficient computation.\n            candidate_bc = np.array(bc_tuple, dtype=np.uint8)\n            \n            is_valid_to_add = True\n            # Check the candidate against all barcodes already in the set.\n            for existing_bc in barcode_set:\n                # Calculate the Hamming distance.\n                distance = np.sum(candidate_bc != existing_bc)\n                \n                # If the distance is less than the required minimum, the candidate is invalid.\n                if distance < d:\n                    is_valid_to_add = False\n                    break\n            \n            # If the candidate is valid, add it to the set.\n            if is_valid_to_add:\n                barcode_set.append(candidate_bc)\n                \n        # The result for this case is the size of the constructed set.\n        results.append(len(barcode_set))\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2417498"}, {"introduction": "在对测序数据进行处理和拼接后，我们得到一个草图基因组，但其质量如何？本练习将向你介绍一个评估基因组拼接连续性的关键指标：NG50。通过计算一个假设的拼接结果的NG50值 [@problem_id:2417502]，你将学会如何量化和解释拼接项目的成功程度，这是解读和比较不同基因组拼接结果的一项基本技能。", "problem": "一个源自新一代测序技术 (NGS) 的基因组组装草图包含长度为 $\\{100, 50, 20, 5, 5\\}$ 千碱基对 (kbp) 的重叠群（contigs）。估计的单倍体基因组大小为 $150$ 千碱基对 (kbp)。NG50 统计量的定义如下：给定一个估计的基因组大小 $G$，将所有重叠群按长度非递增排序，并从最长到最短计算其累加和；NG50 是指累加和首次等于或超过 $\\frac{1}{2}G$ 时的重叠群长度 $L$。请计算此组装的 NG50。答案以千碱基对 (kbp) 为单位表示。在你的解答中不要使用任何百分号。", "solution": "对问题陈述进行验证。\n\n逐字提取已知条件：\n1.  一组重叠群长度：$\\{100, 50, 20, 5, 5\\}$ 千碱基对 (kbp)。\n2.  估计的单倍体基因组大小：$150$ 千碱基对 (kbp)。\n3.  NG50的定义：给定一个估计的基因组大小 $G$，将所有重叠群按长度非递增排序，并从最长到最短计算其累加和；NG50 是指累加和首次等于或超过 $\\frac{1}{2}G$ 时的重叠群长度 $L$。\n\n验证结论：\n问题是有效的。它具有科学依据，因为它涉及计算NG50统计量，这是生物信息学中用于评估基因组组装连续性的一个标准且定义明確的度量。该问题提法恰当，提供了得出唯一解所需的所有必要数据和清晰无歧义的定义。所提供的数据是自洽且符合实际的。该问题是客观的，没有任何逻辑或事实上的缺陷。\n\n我们开始进行解答。\n\n任务是为一个给定的基因组组装草图计算NG50统计量。\n给定的重叠群长度集合为 $C = \\{100, 50, 20, 5, 5\\}$，单位为千碱基对 (kbp)。\n估计的单倍体基因组大小为 $G = 150$ kbp。\n\nNG50的定义要求我们找到一个重叠群长度 $L$，它使得重叠群长度的累加和达到或超过估计基因组大小的一半。为此，必须将重叠群按长度降序排列进行计算。\n\n首先，我们计算目标累加长度，即估计基因组大小的一半：\n$$\n\\text{目标累加和} = \\frac{1}{2} G = \\frac{1}{2} \\times 150 \\text{ kbp} = 75 \\text{ kbp}\n$$\n\n接下来，我们将给定的重叠群长度按非递增（降序）顺序排序。所提供的列表已经是排好序的：\n$L = [100, 50, 20, 5, 5]$。\n\n现在，我们从最长的重叠群开始计算这些长度的累加和，并在每一步检查该和是否达到或超过了 $75$ kbp的目标。\n\n设 $l_i$ 为排序后列表中第 $i$ 个重叠群的长度。\n设 $S_k$ 为前 $k$ 个重叠群的长度累加和，$S_k = \\sum_{i=1}^{k} l_i$。我们要寻找满足 $S_k \\ge 75$ kbp 的最小整数 $k$。那么 NG50 就是第 $k$ 个重叠群的长度 $l_k$。\n\n步骤1：考虑第一个（最长的）重叠群。\n其长度为 $l_1 = 100$ kbp。\n累加和为 $S_1 = l_1 = 100$ kbp。\n\n我们检查累加和是否满足条件：\n$S_1 \\ge 75$ kbp 是否成立？\n$100 \\ge 75$。是的，条件满足。\n\n由于第一个重叠群就满足了条件，因此计算过程在此停止。索引 $k$ 为 $1$。NG50统计量被定义为这个特定重叠群的长度 $l_k$，也就是 $l_1$。\n\n因此，此组装的NG50是第一个重叠群的长度。\n$$\n\\text{NG50} = l_1 = 100 \\text{ kbp}\n$$\n问题要求答案以千碱基对表示。计算出的值为 $100$。", "answer": "$$\n\\boxed{100}\n$$", "id": "2417502"}]}