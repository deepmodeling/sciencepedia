{"hands_on_practices": [{"introduction": "真正掌握一个算法的最好方法之一就是亲手进行一次完整的计算。这个练习将带领我们为“轮廓HMM”（profile HMM）手动执行维特比算法，这是生物信息学中为蛋白质家族建模的关键工具。通过手动填充动态规划表，我们将为给定的蛋白质序列找到最可能的比对路径，并直观地理解算法如何处理匹配、插入和删除 [@problem_id:2436882]。", "problem": "一个用于蛋白质家族的轮廓隐马尔可夫模型 (HMM) 长度为 $2$，具有标准的轮廓拓扑结构，包括开始 ($B$)、匹配 ($M_{1}, M_{2}$)、插入 ($I_{0}, I_{1}, I_{2}$)、删除 ($D_{1}, D_{2}$) 和结束 ($E$) 状态。氨基酸字母表为 $\\{A, C, D\\}$。删除状态不发射任何符号。插入和匹配状态根据下面指定的概率进行发射。所有未明确列出的转移概率均为 $0$。\n\n非零转移概率：\n- $B \\to M_{1}: \\; \\frac{3}{4}$, $B \\to D_{1}: \\; \\frac{1}{4}$, $B \\to I_{0}: \\; 0$.\n- $I_{0} \\to I_{0}: \\; \\frac{1}{2}$, $I_{0} \\to M_{1}: \\; \\frac{1}{2}$, $I_{0} \\to D_{1}: \\; 0$.\n- $M_{1} \\to M_{2}: \\; \\frac{4}{5}$, $M_{1} \\to I_{1}: \\; \\frac{1}{10}$, $M_{1} \\to D_{2}: \\; \\frac{1}{10}$.\n- $D_{1} \\to M_{2}: \\; \\frac{1}{2}$, $D_{1} \\to D_{2}: \\; \\frac{1}{2}$, $D_{1} \\to I_{1}: \\; 0$.\n- $I_{1} \\to I_{1}: \\; \\frac{1}{2}$, $I_{1} \\to M_{2}: \\; \\frac{1}{2}$, $I_{1} \\to D_{2}: \\; 0$.\n- $M_{2} \\to E: \\; \\frac{9}{10}$, $M_{2} \\to I_{2}: \\; \\frac{1}{10}$.\n- $D_{2} \\to E: \\; 1$.\n- $I_{2} \\to I_{2}: \\; \\frac{1}{2}$, $I_{2} \\to E: \\; \\frac{1}{2}$.\n\n发射概率：\n- 在 $M_{1}$ 中：$P(A)=\\frac{1}{2}$, $P(C)=\\frac{1}{3}$, $P(D)=\\frac{1}{6}$。\n- 在 $M_{2}$ 中：$P(A)=\\frac{1}{5}$, $P(C)=\\frac{1}{5}$, $P(D)=\\frac{3}{5}$。\n- 在 $I_{0}, I_{1}, I_{2}$ 中：均匀分布，$P(A)=P(C)=P(D)=\\frac{1}{3}$。\n\n考虑蛋白质序列 $X = A\\,D\\,A$。应用维特比解码来确定通过该模型发射 $X$ 的单一最可能状态路径，以及 $X$ 与该模型的两个匹配列的相应带空位比对。然后计算该维特比路径概率的自然对数 $\\ln$。\n\n最终答案只给出 $\\ln(\\text{维特比路径概率})$ 的数值。将您的答案四舍五入到四位有效数字。", "solution": "问题要求找到给定序列 $X = A\\,D\\,A$ 通过一个指定的轮廓隐马尔可夫模型 (HMM) 的最可能状态路径（维特比路径），然后计算此路径概率的自然对数。该解将使用维特比算法推导得出，这是一种用于此任务的动态规划方法。\n\n设给定序列为 $X = x_1x_2x_3$，其中 $x_1=A$，$x_2=D$，$x_3=A$。序列长度为 $N=3$。HMM 的长度为 $L=2$。模型的状态包括开始状态 $B$、匹配状态 $M_1, M_2$、插入状态 $I_0, I_1, I_2$、删除状态 $D_1, D_2$ 和结束状态 $E$。\n\n维特比算法的核心是计算 $v_k(i)$，即生成长度为 $i$ 的序列前缀 $x_1...x_i$ 且结束于状态 $k$ 的最可能路径的概率。我们还将维护回溯指针以重构路径。\n\n轮廓 HMM 的递推关系如下，其中 $a_{k,l}$ 是从状态 $k$ 到状态 $l$ 的转移概率，$e_k(c)$ 是从状态 $k$ 发射字符 $c$ 的发射概率：\n对于匹配状态 $M_j$，$j \\in \\{1, 2\\}$：\n$$v_{M_j}(i) = e_{M_j}(x_i) \\cdot \\max \\begin{cases} v_{M_{j-1}}(i-1) \\cdot a_{M_{j-1}, M_j} \\\\ v_{I_{j-1}}(i-1) \\cdot a_{I_{j-1}, M_j} \\\\ v_{D_{j-1}}(i-1) \\cdot a_{D_{j-1}, M_j} \\end{cases}$$\n对于插入状态 $I_j$，$j \\in \\{0, 1, 2\\}$：\n$$v_{I_j}(i) = e_{I_j}(x_i) \\cdot \\max \\begin{cases} v_{M_j}(i-1) \\cdot a_{M_j, I_j} \\\\ v_{I_j}(i-1) \\cdot a_{I_j, I_j} \\end{cases}$$\n对于删除状态 $D_j$，$j \\in \\{1, 2\\}$：\n$$v_{D_j}(i) = \\max \\begin{cases} v_{M_{j-1}}(i) \\cdot a_{M_{j-1}, D_j} \\\\ v_{D_{j-1}}(i) \\cdot a_{D_{j-1}, D_j} \\end{cases}$$\n对于 $M$ 和 $D$ 状态，当 $j=1$ 时，通过考虑开始状态 $B$ 来处理索引 $j-1$。对于 $I_j$，其前驱状态是 $M_j$ 或 $I_j$ 本身。状态 $I_0$ 是一个特例。\n\n一个关键的观察是状态 $I_0$ 是不可达的。唯一指定进入 $I_0$ 的转移是来自其自身 ($I_0 \\to I_0$)。从开始状态 $B$ 到 $I_0$ 的转移概率为 $0$。没有其他状态转移到 $I_0$。因此，任何涉及状态 $I_0$ 的路径其概率都为 $0$，我们可以忽略此状态。\n\n我们现在为 $v_k(i)$ 构建动态规划表。\n\n**初始化 ($i=0$):**\n此步骤对应于不发射任何字符的路径。我们从概率为 $1$ 的开始状态 $B$ 出发。路径接着可以移动到不发射符号的删除状态。\n$v_{D_1}(0) = a_{B,D_1} = \\frac{1}{4}$。回溯指针指向 $B$。\n$v_{D_2}(0) = v_{D_1}(0) \\cdot a_{D_1,D_2} = \\frac{1}{4} \\cdot \\frac{1}{2} = \\frac{1}{8}$。回溯指针指向 $D_1(0)$。\n所有其他状态的 $v_k(0)$ 均为 $0$，因为它们是发射状态。\n\n**迭代 1 ($i=1$, $x_1=A$):**\n我们计算发射第一个字符 $A$ 的路径的概率。\n$v_{M_1}(1) = e_{M_1}(A) \\cdot a_{B,M_1} = \\frac{1}{2} \\cdot \\frac{3}{4} = \\frac{3}{8}$。回溯指针：$B$。\n$v_{M_2}(1) = e_{M_2}(A) \\cdot (v_{D_1}(0) \\cdot a_{D_1,M_2}) = \\frac{1}{5} \\cdot (\\frac{1}{4} \\cdot \\frac{1}{2}) = \\frac{1}{40}$。回溯指针：$D_1(0)$。\n插入状态的概率为 $0$，因为它们必须从前一步 ($i=0$) 的某个状态进入，而在 $i=0$ 时没有发射状态具有非零概率。\n$v_{I_1}(1) = 0$, $v_{I_2}(1) = 0$.\n在发射一个字符后结束于删除状态的概率：\n$v_{D_2}(1) = v_{M_1}(1) \\cdot a_{M_1,D_2} = \\frac{3}{8} \\cdot \\frac{1}{10} = \\frac{3}{80}$。回溯指针：$M_1(1)$。\n$D_1$ 只能从 $B$ 到达，这不涉及发射，所以对于 $i>0$，$v_{D_1}(i)=0$。\n\n**迭代 2 ($i=2$, $x_2=D$):**\n我们计算发射前两个字符 $A,D$ 的路径的概率。\n$v_{M_1}(2) = 0$，因为在第一个字符之后，$M_1$ 只能从 $I_0$ 到达，而 $I_0$ 是不可达的。\n$v_{I_1}(2) = e_{I_1}(D) \\cdot \\max \\{ v_{M_1}(1) \\cdot a_{M_1,I_1}, v_{I_1}(1) \\cdot a_{I_1,I_1} \\} = \\frac{1}{3} \\cdot \\max\\{\\frac{3}{8} \\cdot \\frac{1}{10}, 0 \\} = \\frac{1}{80}$。回溯指针：$M_1(1)$。\n$v_{M_2}(2) = e_{M_2}(D) \\cdot \\max \\{ v_{M_1}(1) \\cdot a_{M_1,M_2}, v_{I_1}(1) \\cdot a_{I_1,M_2} \\} = \\frac{3}{5} \\cdot \\max \\{ \\frac{3}{8} \\cdot \\frac{4}{5}, 0 \\} = \\frac{3}{5} \\cdot \\frac{3}{10} = \\frac{9}{50}$。回溯指针：$M_1(1)$。\n$v_{I_2}(2) = e_{I_2}(D) \\cdot \\max \\{ v_{M_2}(1) \\cdot a_{M_2,I_2}, v_{I_2}(1) \\cdot a_{I_2,I_2} \\} = \\frac{1}{3} \\cdot \\max \\{ \\frac{1}{40} \\cdot \\frac{1}{10}, 0 \\} = \\frac{1}{1200}$。回溯指针：$M_2(1)$。\n对于 $i=2$ 时的删除状态：$v_{D_1}(2)=0$，$v_{D_2}(2)=0$。\n\n**迭代 3 ($i=3$, $x_3=A$):**\n我们计算发射完整序列 $A,D,A$ 的路径的概率。\n$v_{M_1}(3) = 0$。\n$v_{I_1}(3) = e_{I_1}(A) \\cdot (v_{I_1}(2) \\cdot a_{I_1,I_1}) = \\frac{1}{3} \\cdot (\\frac{1}{80} \\cdot \\frac{1}{2}) = \\frac{1}{480}$。回溯指针：$I_1(2)$。\n$v_{M_2}(3) = e_{M_2}(A) \\cdot (v_{I_1}(2) \\cdot a_{I_1,M_2}) = \\frac{1}{5} \\cdot (\\frac{1}{80} \\cdot \\frac{1}{2}) = \\frac{1}{800}$。回溯指针：$I_1(2)$。\n$v_{I_2}(3) = e_{I_2}(A) \\cdot \\max \\{ v_{M_2}(2) \\cdot a_{M_2,I_2}, v_{I_2}(2) \\cdot a_{I_2,I_2} \\} = \\frac{1}{3} \\cdot \\max\\{\\frac{9}{50} \\cdot \\frac{1}{10}, \\frac{1}{1200} \\cdot \\frac{1}{2}\\} = \\frac{1}{3} \\cdot \\max\\{\\frac{9}{500}, \\frac{1}{2400}\\} = \\frac{1}{3} \\cdot \\frac{9}{500} = \\frac{3}{500}$。回溯指针：$M_2(2)$。\n对于 $i=3$ 时的删除状态：$v_{D_1}(3)=0$，$v_{D_2}(3)=0$。\n\n**终止：**\n最可能路径的概率 $P^*$，可以通过考虑从 $i=3$ 时的最终状态到结束状态 $E$ 的转移来找到。\n$$P^* = \\max \\begin{cases} v_{M_2}(3) \\cdot a_{M_2,E} \\\\ v_{D_2}(3) \\cdot a_{D_2,E} \\\\ v_{I_2}(3) \\cdot a_{I_2,E} \\end{cases}$$\n$v_{D_2}(3) = 0$，所以我们比较另外两项。\n结束于 $M_2$ 的路径：$v_{M_2}(3) \\cdot a_{M_2,E} = \\frac{1}{800} \\cdot \\frac{9}{10} = \\frac{9}{8000}$。\n结束于 $I_2$ 的路径：$v_{I_2}(3) \\cdot a_{I_2,E} = \\frac{3}{500} \\cdot \\frac{1}{2} = \\frac{3}{1000} = \\frac{24}{8000}$。\n最大概率是 $\\frac{3}{1000}$，由结束于状态 $I_2$ 的路径达到。维特比路径概率为 $P^* = \\frac{3}{1000}$。\n\n通过从 $i=3$ 时的状态 $I_2$ 回溯指针：\n- $i=3$ 时的状态是 $I_2$，它来自 $i=2$ 时的 $M_2$。\n- $i=2$ 时的状态是 $M_2$，它来自 $i=1$ 时的 $M_1$。\n- $i=1$ 时的状态是 $M_1$，它来自开始状态 $B$。\n单一最可能状态路径是 $\\pi^* = (B, M_1, M_2, I_2, E)$。此路径从 $M_1$ 发射 $x_1=A$，从 $M_2$ 发射 $x_2=D$，从 $I_2$ 发射 $x_3=A$。\n序列 $X$ 与模型匹配列的带空位比对如下：\n模型列： $1, 2$\n序列：    $A, D, A$\n序列字符 $A$ 与匹配列 $1$ 对齐，$D$ 与匹配列 $2$ 对齐，最后的 $A$ 对应于列 $2$ 之后的一次插入。\n\n问题要求计算维特比路径概率的自然对数，并四舍五入到四位有效数字。\n$P^* = \\frac{3}{1000} = 0.003$。\n$$\\ln(P^*) = \\ln(0.003) = \\ln(3) - \\ln(1000) \\approx 1.098612 - 6.907755 \\approx -5.809143$$\n将此值四舍五入到四位有效数字得到 $-5.809$。", "answer": "$$\\boxed{-5.809}$$", "id": "2436882"}, {"introduction": "现实世界中的生物学数据很少是完美的，常常包含缺失或模糊的观测值。这个实践练习提出了一个挑战：修改维特比算法来处理这些不完整的数据。通过学习如何为缺失的观测数据正确地进行边缘化处理，我们将掌握如何调整动态规划的核心逻辑，这是将理论模型应用于实际问题的关键一步 [@problem_id:2436943]。", "problem": "给定一个离散的隐马尔可夫模型 (HMM)，其状态空间和发射字母表均为有限集。这种模型在计算生物学中常用于序列标注任务，例如基因查找。该HMM由以下几个部分定义：状态上的初始状态分布 $\\boldsymbol{\\pi}$、一个状态转移矩阵 $\\mathbf{A}$ 和一个发射概率矩阵 $\\mathbf{B}$。在时间 $t$ 的状态为 $S_t \\in \\{0,1,\\dots,N-1\\}$，在时间 $t$ 观测到的符号为 $Y_t \\in \\{0,1,\\dots,M-1\\}$。根据马尔可夫和条件独立性假设，其联合分布可分解为\n$$\nP(S_{1:T}, Y_{1:T}) \\;=\\; \\pi_{S_1}\\,\\prod_{t=2}^{T} A_{S_{t-1},S_t} \\;\\prod_{t=1}^{T} B_{S_t, Y_t},\n$$\n其中 $T$ 是序列长度。在许多生物学场景中，某些观测数据会缺失，例如由于测序覆盖率低或碱基判读不明确。我们将缺失的观测数据用哨兵值 $-1$ 表示，对于这样的时间点，我们通过对所有可能的符号进行边际化来定义其发射贡献：\n$$\n\\text{如果 } Y_t = -1,\\quad \\text{使用因子 } \\sum_{x=0}^{M-1} B_{S_t, x}。\n$$\n\n您的任务是实现一个程序，该程序在最大后验 (MAP) 准则下，通过选择一个最可能的状态路径 $\\hat{s}_{1:T}$ 来执行解码，\n$$\n\\hat{s}_{1:T} \\in \\arg\\max_{s_{1:T}} P(S_{1:T} = s_{1:T} \\mid Y_{1:T} = y_{1:T}),\n$$\n这等同于最大化联合概率 $P(S_{1:T} = s_{1:T}, Y_{1:T} = y_{1:T})$，因为观测数据的边际似然相对于路径是恒定的。您的实现必须在对数空间中使用动态规划以确保数值稳定性，并且必须通过在指定时间点对发射字母表进行正确的边际化来处理缺失的观测数据。所有对数都必须是自然对数。\n\n请使用以下具体的HMM和测试套件。字母表是脱氧核糖核酸 (DNA) 的核苷酸，通过 $\\{0 \\mapsto \\text{A},\\, 1 \\mapsto \\text{C},\\, 2 \\mapsto \\text{G},\\, 3 \\mapsto \\text{T}\\}$ 映射为整数。该模型有 $N=2$ 个状态，标记为 $0$ 和 $1$，其初始分布、转移和发射由以下给出：\n- 初始分布 $\\boldsymbol{\\pi} = [\\,0.6,\\, 0.4\\,]$。\n- 转移矩阵\n$$\n\\mathbf{A} \\;=\\;\n\\begin{bmatrix}\n0.9 & 0.1 \\\\\n0.2 & 0.8\n\\end{bmatrix}.\n$$\n- 发射矩阵\n$$\n\\mathbf{B} \\;=\\;\n\\begin{bmatrix}\n0.30 & 0.20 & 0.20 & 0.30 \\\\\n0.15 & 0.35 & 0.35 & 0.15\n\\end{bmatrix},\n$$\n其中第 $i$ 行给出对于 $x \\in \\{0,1,2,3\\}$ 的 $P(Y_t = x \\mid S_t = i)$。\n\n实现满足以下条件的解码算法：\n- 仅基于上述HMM定义和独立性假设，使用动态规划来最大化状态路径的后验概率。\n- 在对数空间中工作。\n- 对于一个观测到的符号 $y_t \\in \\{0,1,2,3\\}$，使用发射对数因子 $\\log B_{i,y_t}$。\n- 对于一个缺失的符号 $y_t = -1$，对每个状态 $i$ 使用发射对数因子 $\\log\\left(\\sum_{x=0}^{3} B_{i,x}\\right)$，这对应于对未观测到的符号进行边际化。\n\n您的程序必须将此解码器应用于以下观测序列的测试套件（每个序列是一个整数列表，其中 $-1$ 表示缺失的观测）：\n- 测试 1 (正常路径，无缺失值)：$[\\,0,\\,1,\\,2,\\,3,\\,1\\,]$。\n- 测试 2 (间歇性缺失值)：$[\\,0,\\, -1,\\, 2,\\, -1,\\, 3\\,]$。\n- 测试 3 (全部缺失)：$[\\, -1,\\, -1,\\, -1,\\, -1\\,]$。\n- 测试 4 (边界情况，单个缺失值)：$[\\, -1\\,]$。\n- 测试 5 (边界情况，单个观测值)：$[\\, 3\\,]$。\n\n每个测试用例所需的输出是解码出的最可能状态序列，形式为一个长度为 $T$ 的整数列表。您的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个元素本身就是一个解码后的路径列表。例如，输出格式必须与以下完全一样：\n[ [s11,s12,...,s1T1], [s21,s22,...], [s31,...], [s41], [s51] ]\n其中每个 $s_{ij}$ 是一个整数状态索引。不得打印任何额外文本。此问题不涉及任何物理单位、角度或百分比，因此输出中不应包含这些内容。程序必须完全自包含，并且不得读取任何输入。", "solution": "首先对问题进行验证。\n\n步骤 1：提取已知条件\n-   一个隐马尔可夫模型 (HMM)，具有 $N$ 个状态 $S_t \\in \\{0, 1, \\dots, N-1\\}$ 和 $M$ 个发射符号 $Y_t \\in \\{0, 1, \\dots, M-1\\}$。\n-   初始状态分布：$\\boldsymbol{\\pi}$，一个包含 $N$ 个元素的向量。\n-   状态转移矩阵：$\\mathbf{A}$，一个 $N \\times N$ 矩阵，其中 $A_{ij} = P(S_t = j \\mid S_{t-1} = i)$。\n-   发射概率矩阵：$\\mathbf{B}$，一个 $N \\times M$ 矩阵，其中 $B_{ix} = P(Y_t = x \\mid S_t = i)$。\n-   联合概率分布：$P(S_{1:T}, Y_{1:T}) = \\pi_{S_1} \\prod_{t=2}^{T} A_{S_{t-1},S_t} \\prod_{t=1}^{T} B_{S_t, Y_t}$。\n-   缺失观测：由值 $-1$ 表示。\n-   缺失观测的处理：对于 $Y_t = -1$，发射因子为 $\\sum_{x=0}^{M-1} B_{S_t, x}$。\n-   任务：通过最大化后验概率 $P(S_{1:T} \\mid Y_{1:T})$ 来找到最可能的状态路径 $\\hat{s}_{1:T}$，这等同于最大化联合概率 $P(S_{1:T}, Y_{1:T})$。\n-   约束：实现必须在对数空间（自然对数）中使用动态规划。\n-   发射的对数因子：对于观测到的符号 $y_t$，使用 $\\log B_{i,y_t}$。对于缺失的符号 $y_t = -1$，使用 $\\log\\left(\\sum_{x=0}^{M-1} B_{i,x}\\right)$。\n-   HMM 参数：\n    -   $N=2$ 个状态，$M=4$ 个符号 (A, C, G, T 映射到 $0, 1, 2, 3$)。\n    -   $\\boldsymbol{\\pi} = [\\,0.6,\\, 0.4\\,]$。\n    -   $\\mathbf{A} = \\begin{bmatrix} 0.9 & 0.1 \\\\ 0.2 & 0.8 \\end{bmatrix}$。\n    -   $\\mathbf{B} = \\begin{bmatrix} 0.30 & 0.20 & 0.20 & 0.30 \\\\ 0.15 & 0.35 & 0.35 & 0.15 \\end{bmatrix}$。\n-   测试用例：\n    1.  $[\\,0,\\,1,\\,2,\\,3,\\,1\\,]$\n    2.  $[\\,0,\\, -1,\\, 2,\\, -1,\\, 3\\,]$\n    3.  $[\\, -1,\\, -1,\\, -1,\\, -1\\,]$\n    4.  $[\\, -1\\,]$\n    5.  $[\\, 3\\,]$\n-   输出格式：表示整数列表的列表的单行字符串，例如 `[ [s11,...], [s21,...] ]`。\n\n步骤 2：使用提取的已知条件进行验证\n对问题陈述进行有效性分析。\n-   **科学上合理**：该问题基于标准的隐马尔可夫模型框架和用于解码的维特比算法。这是计算生物学、生物信息学和信号处理中的一个基础且广泛使用的方法。通过对可能的发射进行边际化来处理缺失数据的指定方法是一种统计上合理且标准的方法。该问题在科学上是有效的。\n-   **良构性**：该问题要求找到唯一的、最可能的状态路径。维特比算法是一个确定性的过程，保证能找到这样的路径。所有必要的参数（$\\boldsymbol{\\pi}, \\mathbf{A}, \\mathbf{B}$）和条件都已提供，使得问题自包含且可解。\n-   **客观性**：该问题以精确的数学和算法术语陈述，没有任何主观或模棱两可的语言。\n\n该问题没有表现出任何诸如科学上不合理、不完整、矛盾或不可行之类的缺陷。参数是有效的概率，维度也是一致的。\n\n步骤 3：结论与行动\n该问题有效。将提供一个解决方案。\n\n任务是给定一个观测序列 $y_{1:T} = (y_1, \\dots, y_T)$，找到最可能的隐状态序列 $\\hat{s}_{1:T} = (\\hat{s}_1, \\dots, \\hat{s}_T)$。这通过最大化联合概率 $P(s_{1:T}, y_{1:T})$ 来实现。由于该概率的乘积形式，对于长序列，直接计算容易发生数值下溢。因此，我们使用对数概率。目标变为：\n$$\n\\hat{s}_{1:T} = \\arg\\max_{s_{1:T}} \\left( \\log \\pi_{s_1} + \\sum_{t=2}^{T} \\log A_{s_{t-1},s_t} + \\sum_{t=1}^{T} \\log P(y_t \\mid s_t) \\right)\n$$\n这个优化问题具有最优子结构，可以使用动态规划，特别是维特比算法来高效求解。我们定义一个递归量 $\\delta_t(i)$，它是在给定前 $t$ 个观测的情况下，任何长度为 $t$ 且结束于状态 $i$ 的状态路径的最大对数概率：\n$$\n\\delta_t(i) = \\max_{s_{1:t-1}} \\log P(s_1, \\dots, s_{t-1}, s_t=i, y_1, \\dots, y_t)\n$$\n为了能够重构路径，我们还在一个表 $\\psi_t(i)$ 中存储回溯指针，该表记录了在时间 $t$ 结束于状态 $i$ 的路径的最可能前驱状态。\n\n该算法分三个阶段进行：初始化、递归和回溯。\n\n**1. 初始化 ($t=1$)**\n对于每个状态 $i \\in \\{0, \\dots, N-1\\}$，初始对数概率是初始概率 $\\pi_i$ 的对数与给定状态 $i$ 时第一个观测 $y_1$ 的对数概率之和。\n$$\n\\delta_1(i) = \\log \\pi_i + \\log P(y_1 \\mid s_1=i)\n$$\n观测对数概率项 $\\log P(y_t \\mid s_t=i)$ 定义为：\n$$\n\\log P(y_t \\mid s_t=i) =\n\\begin{cases}\n    \\log B_{i, y_t} & \\text{如果 } y_t \\neq -1 \\\\\n    \\log \\left( \\sum_{x=0}^{M-1} B_{i,x} \\right) & \\text{如果 } y_t = -1\n\\end{cases}\n$$\n对于给定的发射矩阵 $\\mathbf{B}$，每一行之和为 $1.0$，因为它是一个有效的概率分布。因此，对于缺失的观测 ($y_t = -1$)，对于任何状态 $i$，项 $\\sum_{x=0}^{M-1} B_{i,x} = 1$，其对数为 $\\log(1) = 0$。这意味着缺失的观测没有提供偏向任何一个状态的证据，决策完全依赖于转移概率和初始概率。\n\n回溯指针表 $\\psi_1(i)$ 无需设置，因为它是路径的起点。\n\n**2. 递归 ($t=2, \\dots, T$)**\n对于每个后续的时间步 $t$ 和每个状态 $j \\in \\{0, \\dots, N-1\\}$，我们通过从时间 $t-1$ 延伸最可能的路径来计算 $\\delta_t(j)$。在时间 $t$ 到达状态 $j$ 的路径必须来自时间 $t-1$ 的某个状态 $i$。我们对所有可能的前驱状态 $i$ 进行最大化：\n$$\n\\delta_t(j) = \\left( \\max_{i=0,\\dots,N-1} \\left( \\delta_{t-1}(i) + \\log A_{ij} \\right) \\right) + \\log P(y_t \\mid s_t=j)\n$$\n在时间 $t$ 状态 $j$ 的回溯指针存储了达到这个最大值的前驱状态 $i$：\n$$\n\\psi_t(j) = \\arg\\max_{i=0,\\dots,N-1} \\left( \\delta_{t-1}(i) + \\log A_{ij} \\right)\n$$\n这个过程对所有时间步直到 $T$ 重复进行，填充大小为 $T \\times N$ 的 $\\delta$ 和 $\\psi$ 表。\n\n**3. 终止和路径回溯**\n在前向传递完成后，唯一最可能路径的对数概率是 $\\delta$ 表最后一列中的最大值：\n$$\n\\log P(\\hat{s}_{1:T}, y_{1:T}) = \\max_{i=0,\\dots,N-1} \\delta_T(i)\n$$\n最优路径的最终状态是达到此最大值的状态：\n$$\n\\hat{s}_T = \\arg\\max_{i=0,\\dots,N-1} \\delta_T(i)\n$$\n路径的其余部分通过使用存储在 $\\psi$ 表中的指针从这个最终状态开始回溯来恢复：\n$$\n\\hat{s}_{t-1} = \\psi_t(\\hat{s}_t) \\quad \\text{对于 } t = T, T-1, \\dots, 2\n$$\n这个过程得出了完整的最可能状态序列 $\\hat{s}_{1:T}$。实现将把此算法应用于每个提供的测试用例。", "answer": "[[0, 1, 1, 0, 1], [0, 0, 1, 1, 0], [0, 0, 0, 0], [0], [0]]", "id": "2436943"}, {"introduction": "标准的算法实现通常依赖于简化的模型假设，但真实的HMM，特别是轮廓HMM，可能包含复杂的结构，例如由不产生观测的“沉默”状态（如删除状态）组成的循环。这个思想实验探讨了一个关键的设计挑战：当模型包含这类循环时，如何保证维特比算法能够正确终止并返回精确结果。这个练习促使我们像算法设计者一样思考，运用图论概念来构建更鲁棒的实现 [@problem_id:2436893]。", "problem": "您正在实现维特比算法，用于在隐马尔可夫模型 (HMM) 中解码最可能的状态路径。该 HMM 用于通过 profile 模型进行蛋白质结构域检测。该模型包含一个静默状态（非发射状态）的子集，这些状态可以相互转移，并可能形成有向循环（例如，删除状态链）。所有转移概率都是有效的，即每个状态的出向转移概率之和为 $1$，并且每个单独的转移概率都在 $[0,1]$ 区间内。您在对数空间中工作，因此转移概率被映射为 $\\le 0$ 的对数权重。如果静默状态可以被无限次地重访，一个沿着静默转移重复进行松弛直到没有变化被观察到的朴素实现可能会无法终止。\n\n哪一种单一策略既能 (i) 保证对于任何具有循环静默状态转移的此类模型的解码能够终止，又能 (ii) 保持原始模型下的精确最大概率维特比解码？\n\nA. 为每个静默转移添加一个小的惩罚项 $\\epsilon>0$（即从每个对数权重中减去 $\\epsilon$），使得任何静默循环都具有严格为负的总对数权重，然后运行常规的维特比算法。\n\nB. 通过将每个强连通分量收缩成一个单一的元状态来预处理静默状态子图，在每个分量内计算其入口和出口点之间的最佳纯静默连接值（由于循环对数权重 $\\le 0$，所以不需要循环），从而获得一个关于静默元状态的有向无环图，然后在每个观测位置，通过对静默转移进行一次拓扑排序的单次遍历来运行维特比算法。\n\nC. 对连续的静默转移次数施加一个硬性上限 $K$（选择一个较大的固定值 $K$），并中止任何试图超过 $K$ 次连续静默转移的路径。\n\nD. 在解码之前，从模型中移除所有静默到静默的转移，只留下从静默到发射或从发射到静默的转移。\n\nE. 在维特比算法执行期间，每当一条部分路径试图重新进入一个已经存在于该部分路径当前堆栈上的静默状态时，就剪除该更新并继续，从而使得在同一部分路径中，没有静默状态会被访问两次。", "solution": "问题陈述提出了一个关于隐马尔可夫模型 (HMM) 中维特比算法实现的问题，该 HMM 包含静默（非发射）状态。其中一个关键挑战是，这些静默状态之间存在的有向循环可能导致算法不终止。任务是找出一个策略，该策略既能解决这个不终止问题，又能保持维特比解码的精确性。\n\n首先，我们必须验证问题陈述。\n\n**步骤 1：提取已知条件**\n- **算法**：用于 HMM 解码的维特比算法。\n- **模型**：用于蛋白质结构域检测的 Profile HMM。\n- **状态**：包含一个静默（非发射）状态的子集。\n- **转移**：静默状态可以转移到其他静默状态，可能形成有向循环。\n- **概率**：所有转移概率都是有效的，即对于任何状态，出向转移概率之和为 $1$，并且每个单独的概率 $p$ 满足 $0 \\le p \\le 1$。\n- **计算空间**：计算在对数空间中进行。转移概率 $p$ 被映射为对数权重 $\\log(p) \\le 0$。\n- **问题**：对于静默转移的朴素迭代松弛方法可能因循环而无法终止，导致静默状态被无限重访。\n- **目标**：找到一个单一策略，既能保证解码过程的终止，又能保持原始模型的精确最大概率维特比路径。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在计算生物学和生物信息学领域有充分的依据。Profile HMM、静默状态（例如删除状态）、维特比算法以及对数概率的使用都是标准组成部分。静默状态间的循环问题是 HMM 软件（例如 HMMER、SAM）中一个已知且重要的实现细节。\n- **良构性**：这个问题是良构的。它描述了一个特定的算法病症——因循环导致的不终止——并寻求一个满足两个清晰、客观标准（保证终止和精确性）的解决方案。\n- **一致性和完整性**：问题陈述是自洽的。对数权重 $\\le 0$ 这一事实直接源于转移概率 $\\le 1$。不终止问题特别是在总对数权重为 $0$ 的循环（即所有构成转移的概率都为 $1$）中出现，这在 HMM 中是一个有效（尽管可能是边界）的情况。所给的设定足以评估所有提出的策略。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。它在科学上是合理的、良构的且内部一致的。我们可以继续推导解决方案并评估所提供的选项。\n\n对于状态 $k$ 和观测索引 $i$，维特比算法的核心是计算在观测到前缀 $x_1...x_i$ 后，以状态 $k$ 结束的路径的最大对数概率。这被表示为 $v_k(i)$。对于一个发射状态 $k$，其递推关系为：\n$$v_k(i) = \\log e_k(x_i) + \\max_{j} \\left( v_j(i-1) + \\log a_{jk} \\right)$$\n其中 $a_{jk}$ 是从状态 $j$ 到状态 $k$ 的转移概率，而 $e_k(x_i)$ 是发射概率。\n\n对于一个静默状态 $s$，没有观测被消耗。因此，更新必须相对于*相同*观测索引 $i$ 处的其他状态概率来计算。设 $v_s(i)$ 为处理完观测 $x_i$ *之后* 到达静默状态 $s$ 的维特比得分。该得分由那些其得分已在索引 $i-1$（如果是发射状态）或索引 $i$（如果是静默状态）上被最终确定的状态的转移决定。\n$$v_s(i) = \\max \\left( \\max_{j \\in \\text{emitting}} \\left(v_j(i-1) + \\log a_{js} \\right), \\max_{s' \\in \\text{silent}} \\left( v_{s'}(i) + \\log a_{s's} \\right) \\right)$$\n右侧项 $v_{s'}(i)$ 的存在表明在索引 $i$ 处，静默状态之间存在一个依赖系统。如果静默到静默的转移图包含循环，这就变成了一个必须求解的方程组。这等价于在静默状态子图中寻找最长路径，其中初始路径得分由前一个维特比列（索引 $i-1$）的转移提供。\n\n由于所有转移对数权重 $\\log(a_{s's})$ 都是非正的（$\\le 0$），该子图中的任何循环都具有非正的总权重。一个朴素的迭代松弛只有在存在总权重为 $0$ 的循环时才会无法终止。一个正确的算法必须能处理这种情况。\n\n现在我们评估每个选项。\n\n**A. 为每个静默转移添加一个小的惩罚项 $\\epsilon>0$（即从每个对数权重中减去 $\\epsilon$），使得任何静默循环都具有严格为负的总对数权重，然后运行常规的维特比算法。**\n该策略确保了静默状态子图中的每个循环都具有严格为负的对数权重。一种基于松弛的方法（如 Bellman-Ford 算法，它解决了无正权重循环图中的最长路径问题）现在就能保证终止。因此，条件 (i)，即终止性，得到满足。\n然而，这种方法修改了 HMM 的参数。通过从对数权重中减去 $\\epsilon$，我们实际上是将原始概率乘以了 $e^{-\\epsilon} < 1$。得到的维特比路径是对于*修改后*的模型是最优的，但对于*原始*模型不一定是最优的。这将比原始模型更重地惩罚具有许多静默到静默转移的路径，可能改变最优路径。因此，该策略不满足条件 (ii)，即保持精确解码。\n**结论：不正确。**\n\n**B. 通过将每个强连通分量收缩成一个单一的元状态来预处理静默状态子图，在每个分量内计算其入口和出口点之间的最佳纯静默连接值（由于循环对数权重 $\\le 0$，所以不需要循环），从而获得一个关于静默元状态的有向无环图，然后在每个观测位置，通过对静默转移进行一次拓扑排序的单次遍历来运行维特比算法。**\n该策略基于一个合理的图论分解。\n1.  静默到静默的转移图被分解为其强连通分量 (SCCs)。根据定义，SCCs 构成的图是一个有向无环图 (DAG)。\n2.  在每个 SCC 内部，我们必须找到从任何具有来自 SCC 外部的入边（“入口点”）的节点到任何具有指向 SCC 外部的出边（“出口点”）的节点的最大权重路径。因为所有循环权重都是非正的，所以 SCC 中任意两点之间的最长路径是良定义的，并且可以通过所有对最短路径算法（例如，适用于最长路径的 Floyd-Warshall 算法）或通过从每个入口点运行单源算法来找到。这能正确计算出遍历 SCC 内任何片段的最大对数概率。“不需要任何循环”这一陈述在选项的措辞上略有不精确；最佳路径的计算隐含地考虑了所有可能的路径，包括带循环的路径，但最优路径本身不会遍历负权重循环，而遍历零权重循环也不会改善得分。核心思想是最佳路径得分是可计算的。\n3.  原始的静默状态子图（带有循环）被一个由元状态（即 SCC）和单个状态组成的等效 DAG 结构所取代。\n4.  在每个维特比步骤 $i$ 中，静默状态的得分可以通过根据这个新 DAG 的拓扑排序进行单次遍历来计算。这保证了算法的终止。\n该过程是精确的。它将通过静默状态子图的所有可能路径（包括循环路径）的净效应，正确地总结为 DAG 中的等效直接转移。修改后的 DAG 结构中的最大概率路径与原始模型中的最大概率路径完全对应。两个条件 (i) 和 (ii) 都得到满足。这是理论上正确且在实践中被实现的解决方案。\n**结论：正确。**\n\n**C. 对连续的静默转移次数施加一个硬性上限 $K$（选择一个较大的固定值 $K$），并中止任何试图超过 $K$ 次连续静默转移的路径。**\n该策略保证了终止，因为通过静默状态的路径长度不会超过 $K$。然而，这是一种临时的启发式方法。真正的最大概率路径可能需要一个长于 $K$ 的静默状态序列（例如，为了模拟蛋白质序列中的长删除）。通过施加任意的上限，算法可能无法找到真正的最优路径。这违反了条件 (ii)。\n**结论：不正确。**\n\n**D. 在解码之前，从模型中移除所有静默到静默的转移，只留下从静默到发射或从发射到静默的转移。**\n此修改将静默状态图简化为一组孤立的节点，从而轻易地打破所有循环并保证终止。然而，这是对 HMM 的剧烈且不正确的修改。例如，在 profile HMM 中，删除状态链（$D_k \\to D_{k+1}$）对于建模多个残基的删除至关重要。移除这些转移会使模型无法表示此类生物学事件，从而从根本上改变其语义。这未能保持原始解码，因此违反了条件 (ii)。\n**结论：不正确。**\n\n**E. 在维特比算法执行期间，每当一条部分路径试图重新进入一个已经存在于该部分路径当前堆栈上的静默状态时，就剪除该更新并继续，从而使得在同一部分路径中，没有静默状态会被访问两次。**\n该策略强制要求任何通过静默状态的路径都必须是*简单路径*（无重复顶点）。这保证了终止，因为任何简单路径的长度都受静默状态数量的限制。然而，这在一般情况下是不正确的。在具有非正权重循环的图中，两个节点之间的最长路径不一定是简单路径。如果存在总对数权重为 $0$ 的循环，最优路径可能会遍历它。例如，一条路径可以进入一个 SCC，遍历一个零权重循环，然后退出。该策略会错误地禁止此类路径。选项 B 正确地处理了这种情况，通过计算最佳路径成本（这可能涉及遍历此类循环），而此选项则错误地剪除了有效的、且可能是最优的路径片段。这违反了条件 (ii)。\n**结论：不正确。**\n\n总之，只有策略 B 提供了一个既能在算法上保证终止，又能在形式上被证明与在原始、未修改模型上运行维特比算法产生完全相同结果的解决方案。", "answer": "$$\\boxed{B}$$", "id": "2436893"}]}