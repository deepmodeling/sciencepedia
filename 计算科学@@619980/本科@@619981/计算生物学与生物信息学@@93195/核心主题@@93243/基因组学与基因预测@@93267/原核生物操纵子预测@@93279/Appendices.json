{"hands_on_practices": [{"introduction": "操纵子预测的核心挑战在于如何整合多种不完美的生物学证据。本练习将指导您构建一个朴素贝叶斯分类器，这是一种强大且直观的概率模型，用于区分真正的操纵子基因对和仅仅是相邻的基因。通过结合基因间距离 $d$、功能关联性 $r$ 和保守性 $c$ 等多种特征，您将亲身体验如何将生物学直觉转化为一个可执行的计算模型 [@problem_id:2410831]。", "problem": "一个原核基因组包含许多位于同一条链上的相邻基因对，其转录组织方式尚不明确。一个基因对可能是一个真正的操纵子（一个单一转录单元，从脱氧核糖核酸 (DNA) 上的多个编码序列产生一个多顺反子核糖核酸 (RNA)），或者可能仅仅是两个独立转录单元的保守同线性邻接。考虑以下形式化的二元分类问题。对于每一个保守的、共方向的基因对，定义类别标签 $Y \\in \\{0,1\\}$，其中 $Y=1$ 表示一个真正的操纵子对，$Y=0$ 表示两个独立的转录单元。\n\n每个基因对由一个特征向量 $X=(d,r,p,t,c)$ 表示，其分量如下：\n- $d \\in \\mathbb{Z}$ 是以碱基对 (bp) 为单位测量的基因间距离，其中正值 $d$ 表示存在间隙，负值 $d$ 表示存在重叠。距离以 bp 为单位提供；请勿进行任何单位转换。\n- $r \\in (0,1)$ 是两个基因之间的实值功能相关性得分。\n- $p \\in \\{0,1\\}$ 表示在两个基因之间是否存在 ($p=1$) 或不存在 ($p=0$) 预测的内部启动子基序。\n- $t \\in (0,1)$ 是为基因间区域计算的实值内源性终止子得分。\n- $c \\in \\{0,1,2,\\dots,20\\}$ 是在 $20$ 个参考基因组中，邻接性和共方向性得到保守的基因组数量。\n\n假设 $(X,Y)$ 的生成模型和先验如下：\n- 先验类别概率 $P(Y=1)=0.5$ 和 $P(Y=0)=0.5$。\n- 给定类别下特征的条件独立性，即 $P(X \\mid Y)=P(d\\mid Y)\\,P(r\\mid Y)\\,P(p\\mid Y)\\,P(t\\mid Y)\\,P(c\\mid Y)$。\n- 基因间距离：对于 $Y=1$，$d \\sim \\mathcal{N}(\\mu_1,\\sigma_1^2)$，其中 $\\mu_1=20$ 且 $\\sigma_1=35$；对于 $Y=0$，$d \\sim \\mathcal{N}(\\mu_0,\\sigma_0^2)$，其中 $\\mu_0=220$ 且 $\\sigma_0=90$。\n- 功能相关性：对于 $Y=1$，$r \\sim \\mathrm{Beta}(\\alpha_{r1},\\beta_{r1})$，其中 $\\alpha_{r1}=5$ 且 $\\beta_{r1}=2$；对于 $Y=0$，$r \\sim \\mathrm{Beta}(\\alpha_{r0},\\beta_{r0})$，其中 $\\alpha_{r0}=2$ 且 $\\beta_{r0}=5$。\n- 内部启动子基序：对于 $Y=1$，$p \\sim \\mathrm{Bernoulli}(\\pi_{p1})$，其中 $\\pi_{p1}=0.1$；对于 $Y=0$，$p \\sim \\mathrm{Bernoulli}(\\pi_{p0})$，其中 $\\pi_{p0}=0.7$。\n- 终止子得分：对于 $Y=1$，$t \\sim \\mathrm{Beta}(\\alpha_{t1},\\beta_{t1})$，其中 $\\alpha_{t1}=1.5$ 且 $\\beta_{t1}=5$；对于 $Y=0$，$t \\sim \\mathrm{Beta}(\\alpha_{t0},\\beta_{t0})$，其中 $\\alpha_{t0}=3.5$ 且 $\\beta_{t0}=2$。\n- 保守邻接计数：对于 $Y=1$，$c \\sim \\mathrm{Binomial}(n,\\pi_{c1})$，其中 $n=20$ 且 $\\pi_{c1}=0.6$；对于 $Y=0$，$c \\sim \\mathrm{Binomial}(n,\\pi_{c0})$，其中 $n=20$ 且 $\\pi_{c0}=0.2$。\n\n对于每个提供的测试用例特征向量 $X$，您的程序必须计算上述模型所隐含的后验概率 $P(Y=1\\mid X)$ 和 $P(Y=0\\mid X)$，并返回由下式定义的预测类别 $\\hat{Y}$：\n$$\n\\hat{Y}=\\begin{cases}\n1 & \\text{if } P(Y=1\\mid X)\\ge 0.5,\\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\n\n测试套件（每个元组为 $(d,r,p,t,c)$，其中 $d$ 的单位是碱基对，$r$ 和 $t$ 是在 $(0,1)$ 范围内的无量纲值，$p$ 在 $\\{0,1\\}$ 中取值，$c$ 是一个整数计数）：\n- 案例 $1$：$(12,\\,0.85,\\,0,\\,0.12,\\,15)$\n- 案例 $2$：$(310,\\,0.18,\\,1,\\,0.74,\\,3)$\n- 案例 $3$：$(75,\\,0.55,\\,0,\\,0.35,\\,9)$\n- 案例 $4$：$(-4,\\,0.40,\\,1,\\,0.80,\\,5)$\n- 案例 $5$：$(180,\\,0.92,\\,0,\\,0.05,\\,16)$\n- 案例 $6$：$(0,\\,0.01,\\,0,\\,0.99,\\,0)$\n\n您的程序应生成一行输出，其中包含案例 1 到 6 的六个整数预测，按顺序排列，并以逗号分隔的列表形式用方括号括起来，例如 $[y_1,y_2,y_3,y_4,y_5,y_6]$。每个 $y_i$ 唯一可接受的输出是整数 0 或 1；输出中不需要包含任何物理单位。", "solution": "所呈现的问题是一个针对原核基因对的二元分类任务。需要确定一个基因对是构成一个真正的操纵子（由类别标签 $Y=1$ 表示），还是两个独立的转录单元（由类别标签 $Y=0$ 表示）。此分类将使用一个基于所提供生成模型的朴素贝叶斯分类器来执行。\n\n首先，评估问题陈述的有效性。\n\n**步骤 1：提取的已知条件**\n- **类别标签**：$Y \\in \\{0, 1\\}$，其中 $Y=1$ 代表操纵子对，$Y=0$ 代表独立单元。\n- **特征向量**：$X=(d,r,p,t,c)$。\n- **特征定义**：\n    - $d \\in \\mathbb{Z}$：基因间距离，单位为碱基对 (bp)。\n    - $r \\in (0,1)$：功能相关性得分。\n    - $p \\in \\{0,1\\}$：内部启动子的存在 ($1$) 或不存在 ($0$)。\n    - $t \\in (0,1)$：内源性终止子得分。\n    - $c \\in \\{0,1,2,\\dots,20\\}$：在 $20$ 个参考基因组中保守邻接的数量。\n- **模型假设**：\n    - **先验概率**：$P(Y=1)=0.5$ 和 $P(Y=0)=0.5$。\n    - **条件独立性**：$P(X \\mid Y)=P(d\\mid Y)\\,P(r\\mid Y)\\,P(p\\mid Y)\\,P(t\\mid Y)\\,P(c\\mid Y)$。\n- **类别 $Y=1$ (操纵子) 的条件分布**：\n    - $d \\mid Y=1 \\sim \\mathcal{N}(\\mu_1=20, \\sigma_1^2=35^2)$。\n    - $r \\mid Y=1 \\sim \\mathrm{Beta}(\\alpha_{r1}=5, \\beta_{r1}=2)$。\n    - $p \\mid Y=1 \\sim \\mathrm{Bernoulli}(\\pi_{p1}=0.1)$。\n    - $t \\mid Y=1 \\sim \\mathrm{Beta}(\\alpha_{t1}=1.5, \\beta_{t1}=5)$。\n    - $c \\mid Y=1 \\sim \\mathrm{Binomial}(n=20, \\pi_{c1}=0.6)$。\n- **类别 $Y=0$ (独立单元) 的条件分布**：\n    - $d \\mid Y=0 \\sim \\mathcal{N}(\\mu_0=220, \\sigma_0^2=90^2)$。\n    - $r \\mid Y=0 \\sim \\mathrm{Beta}(\\alpha_{r0}=2, \\beta_{r0}=5)$。\n    - $p \\mid Y=0 \\sim \\mathrm{Bernoulli}(\\pi_{p0}=0.7)$。\n    - $t \\mid Y=0 \\sim \\mathrm{Beta}(\\alpha_{t0}=3.5, \\beta_{t0}=2)$。\n    - $c \\mid Y=0 \\sim \\mathrm{Binomial}(n=20, \\pi_{c0}=0.2)$。\n- **分类规则**：\n$$\n\\hat{Y}=\\begin{cases}\n1 & \\text{if } P(Y=1\\mid X)\\ge 0.5,\\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\n- **测试套件**：\n    - 案例 $1$：$(12,\\,0.85,\\,0,\\,0.12,\\,15)$\n    - 案例 $2$：$(310,\\,0.18,\\,1,\\,0.74,\\,3)$\n    - 案例 $3$：$(75,\\,0.55,\\,0,\\,0.35,\\,9)$\n    - 案例 $4$：$(-4,\\,0.40,\\,1,\\,0.80,\\,5)$\n    - 案例 $5$：$(180,\\,0.92,\\,0,\\,0.05,\\,16)$\n    - 案例 $6$：$(0,\\,0.01,\\,0,\\,0.99,\\,0)$\n\n**步骤 2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n- **科学依据**：该问题设置在计算生物学领域，涉及操纵子预测，这是生物信息学中的一个标准课题。所选的特征——基因间距离、功能相关性、启动子和终止子信号以及系统发育保守性——都是已确立且具有生物学相关性的操纵子结构预测因子。所选的概率分布（正态分布、贝塔分布、伯努利分布、二项分布）是对相应特征的恰当模型。参数化反映了已知的生物学趋势（例如，操纵子基因距离近、功能相关，且缺乏内部启动子/终止子）。该问题在科学上是合理的。\n- **良构性**：该问题被构建为一个标准的贝叶斯分类任务。所有必要的输入、参数和清晰明确的分类规则都已提供。对于每个测试用例，都存在一个唯一、稳定且有意义的解，并且可以计算出来。\n- **客观性**：该问题使用精确的数学和生物学术语陈述。它不含主观、模糊或基于意见的语言。\n\n**步骤 3：结论与行动**\n该问题是有效的。它在科学上合理，问题良构且客观。没有矛盾、信息缺失或其他使其不合格的缺陷。将制定一个完整的解决方案。\n\n**解题推导**\n\n目标是将一个给定的基因对（由其特征向量 $X=(d,r,p,t,c)$ 表示）分类到两个类别之一，$Y=1$（操纵子）或 $Y=0$（独立单元）。我们的任务是实现一个朴素贝叶斯分类器。\n\n决策规则是，如果后验概率 $P(Y=1 \\mid X)$ 大于或等于 0.5，则预测 $\\hat{Y}=1$。使用贝叶斯定理，后验概率为：\n$$ P(Y=1 \\mid X) = \\frac{P(X \\mid Y=1) P(Y=1)}{P(X)} $$\n其中证据 $P(X)$ 由全概率定律给出：\n$$ P(X) = P(X \\mid Y=1) P(Y=1) + P(X \\mid Y=0) P(Y=0) $$\n决策规则 $P(Y=1 \\mid X) \\ge 0.5$ 可以重写为：\n$$ \\frac{P(X \\mid Y=1) P(Y=1)}{P(X \\mid Y=1) P(Y=1) + P(X \\mid Y=0) P(Y=0)} \\ge 0.5 $$\n鉴于先验概率相等 $P(Y=1) = P(Y=0) = 0.5$，这可以简化为对类条件似然的比较：\n$$ P(X \\mid Y=1) \\ge P(X \\mid Y=0) $$\n根据特征条件独立性的假设，对于类别 $Y=k$（其中 $k \\in \\{0, 1\\}$）的似然是各个特征概率的乘积：\n$$ P(X \\mid Y=k) = P(d \\mid Y=k) \\cdot P(r \\mid Y=k) \\cdot P(p \\mid Y=k) \\cdot P(t \\mid Y=k) \\cdot P(c \\mid Y=k) $$\n为了避免多个小概率相乘导致的数值下溢，在计算上更优越的方法是处理对数概率之和。决策规则等同于比较对数似然：\n$$ \\log P(X \\mid Y=1) \\ge \\log P(X \\mid Y=0) $$\n类别 $k$ 的总对数似然为：\n$$ \\mathcal{L}_k = \\log P(X \\mid Y=k) = \\log P(d \\mid Y=k) + \\log P(r \\mid Y=k) + \\log P(p \\mid Y=k) + \\log P(t \\mid Y=k) + \\log P(c \\mid Y=k) $$\n我们必须为每个测试用例计算 $\\mathcal{L}_1$ 和 $\\mathcal{L}_0$，如果 $\\mathcal{L}_1 \\ge \\mathcal{L}_0$，则预测 $\\hat{Y}=1$，否则预测 $\\hat{Y}=0$。所需的概率密度/质量函数如下：\n- **针对 $d$ 的正态分布**：$d \\sim \\mathcal{N}(\\mu_k, \\sigma_k^2)$ 的对数概率密度函数 (log-PDF) 是 $\\log f(d; \\mu_k, \\sigma_k^2)$。\n- **针对 $r$ 和 $t$ 的贝塔分布**：变量 $x \\sim \\mathrm{Beta}(\\alpha_{xk}, \\beta_{xk})$ 的对数概率密度函数 (log-PDF) 是 $\\log f(x; \\alpha_{xk}, \\beta_{xk})$。\n- **针对 $p$ 的伯努利分布**：$p \\sim \\mathrm{Bernoulli}(\\pi_{pk})$ 的对数概率质量函数 (log-PMF) 是 $\\log P(p; \\pi_{pk})$。\n- **针对 $c$ 的二项分布**：$c \\sim \\mathrm{Binomial}(n, \\pi_{ck})$ 的对数概率质量函数 (log-PMF) 是 $\\log P(c; n, \\pi_{ck})$。\n\n对于每个测试用例 $X_i=(d_i, r_i, p_i, t_i, c_i)$，我们计算：\n$$ \\mathcal{L}_{1,i} = \\log P(d=d_i \\mid Y=1) + \\log P(r=r_i \\mid Y=1) + \\log P(p=p_i \\mid Y=1) + \\log P(t=t_i \\mid Y=1) + \\log P(c=c_i \\mid Y=1) $$\n$$ \\mathcal{L}_{0,i} = \\log P(d=d_i \\mid Y=0) + \\log P(r=r_i \\mid Y=0) + \\log P(p=p_i \\mid Y=0) + \\log P(t=t_i \\mid Y=0) + \\log P(c=c_i \\mid Y=0) $$\n那么测试用例 $i$ 的预测为：\n$$ \\hat{Y}_i = \\begin{cases} 1 & \\text{if } \\mathcal{L}_{1,i} \\ge \\mathcal{L}_{0,i} \\\\ 0 & \\text{otherwise} \\end{cases} $$\n最终的实现将把此逻辑应用于提供的测试套件。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, beta, bernoulli, binom\n\ndef solve():\n    \"\"\"\n    Solves the operon prediction problem using a Naive Bayes classifier.\n    \"\"\"\n\n    # Define the parameters of the generative model for each class.\n    # Class Y=1 (operon)\n    params_1 = {\n        'd': {'loc': 20, 'scale': 35},      # Normal(mu, sigma)\n        'r': {'a': 5, 'b': 2},            # Beta(a, b)\n        'p': {'p': 0.1},                  # Bernoulli(p)\n        't': {'a': 1.5, 'b': 5},            # Beta(a, b)\n        'c': {'n': 20, 'p': 0.6}           # Binomial(n, p)\n    }\n\n    # Class Y=0 (separate transcription units)\n    params_0 = {\n        'd': {'loc': 220, 'scale': 90},     # Normal(mu, sigma)\n        'r': {'a': 2, 'b': 5},            # Beta(a, b)\n        'p': {'p': 0.7},                  # Bernoulli(p)\n        't': {'a': 3.5, 'b': 2},            # Beta(a, b)\n        'c': {'n': 20, 'p': 0.2}           # Binomial(n, p)\n    }\n\n    # Test cases: (d, r, p, t, c)\n    test_cases = [\n        (12, 0.85, 0, 0.12, 15),\n        (310, 0.18, 1, 0.74, 3),\n        (75, 0.55, 0, 0.35, 9),\n        (-4, 0.40, 1, 0.80, 5),\n        (180, 0.92, 0, 0.05, 16),\n        (0, 0.01, 0, 0.99, 0)\n    ]\n\n    results = []\n    for case in test_cases:\n        d, r, p, t, c = case\n\n        # Calculate the log-likelihood for class Y=1\n        log_likelihood_1 = (\n            norm.logpdf(d, **params_1['d']) +\n            beta.logpdf(r, **params_1['r']) +\n            bernoulli.logpmf(p, **params_1['p']) +\n            beta.logpdf(t, **params_1['t']) +\n            binom.logpmf(c, **params_1['c'])\n        )\n\n        # Calculate the log-likelihood for class Y=0\n        log_likelihood_0 = (\n            norm.logpdf(d, **params_0['d']) +\n            beta.logpdf(r, **params_0['r']) +\n            bernoulli.logpmf(p, **params_0['p']) +\n            beta.logpdf(t, **params_0['t']) +\n            binom.logpmf(c, **params_0['c'])\n        )\n\n        # Classify based on the comparison of log-likelihoods.\n        # This is equivalent to comparing posterior probabilities since priors are equal.\n        prediction = 1 if log_likelihood_1 >= log_likelihood_0 else 0\n        results.append(prediction)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2410831"}, {"introduction": "虽然通用特征在操纵子预测中很有用，但某些特殊的基因组结构——例如基因重叠——提供了特别强烈的信号。本练习专注于这一重要情况，并引入了一个逻辑回归模型来精确量化重叠基因属于同一操纵子的概率 $P(O=1 \\mid L, F)$。您将学习如何根据重叠长度 $L$ 和读码框偏移 $F$ 来校准和应用一个专门的模型，从而深化对复杂生物信号建模的理解 [@problem_id:2410891]。", "problem": "给定一个概率模型，用于估计在原核基因组中，同一条链上的两个相邻基因属于同一个操纵子的概率，该概率以负的基因间距离（IGD）为条件，其中负的IGD值表示基因重叠。令以核苷酸为单位的重叠长度用 $L$ 表示，定义为 $L = -\\mathrm{IGD}$，其中 $\\mathrm{IGD} < 0$。令阅读框偏移用 $r \\in \\{0,1,2\\}$ 表示，其定义为下游基因相对于上游基因的编码框差异模3。定义框型指示符 $F$：如果 $r=0$ （同框重叠），则 $F=1$；否则（移码重叠）$F=0$。\n\n该模型假定，这两个基因位于同一操纵子中的概率，记为 $P(O=1 \\mid L, F)$，服从一个logistic形式，\n$$\nP(O=1 \\mid L, F) \\;=\\; \\sigma\\!\\big(\\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F\\big),\n$$\n其中 $\\sigma(x) = \\dfrac{1}{1+e^{-x}}$，并且 $\\theta_0,\\theta_1,\\theta_2,\\theta_3$ 是实值参数。等价地，几率满足\n$$\n\\frac{P(O=1 \\mid L,F)}{1 - P(O=1 \\mid L,F)} \\;=\\; \\exp\\!\\big(\\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F\\big).\n$$\n\n参数将根据下面给出的四个规范约束进行校准。所有数值量均为无量纲的概率或几率乘数：\n1. 在重叠长度 $L=1$ 时的基线移码情形：$P(O=1 \\mid L=1, F=0) = p_{\\mathrm{fs},1}$，其中 $p_{\\mathrm{fs},1} = 0.2$。\n2. 移码重叠的每核苷酸几率乘性变化为 $k_{\\mathrm{fs}} = 1.04$，这意味着对于 $F=0$ 的情况，$L$ 每增加一个单位，长度为 $L$ 时的几率就乘以 $k_{\\mathrm{fs}}$。\n3. 在 $L=1$ 时的同框优势是一个几率比 $\\rho_1 = 3.0$，此比值是相对于 $L=1$ 时的移码重叠而言的，即 $\\dfrac{\\text{odds}(L=1,F=1)}{\\text{odds}(L=1,F=0)} = \\rho_1$。\n4. 同框重叠的每核苷酸几率乘性变化为 $k_{\\mathrm{if}} = 1.12$，这意味着对于 $F=1$ 的情况，$L$ 每增加一个单位，长度为 $L$ 时的几率就乘以 $k_{\\mathrm{if}}$。\n\n根据这些约束，参数必须满足\n$$\n\\theta_1 = \\ln k_{\\mathrm{fs}}, \\quad\n\\theta_0 = \\ln\\!\\left(\\frac{p_{\\mathrm{fs},1}}{1 - p_{\\mathrm{fs},1}}\\right) - \\theta_1, \\quad\n\\theta_3 = \\ln k_{\\mathrm{if}} - \\theta_1, \\quad\n\\theta_2 = \\ln \\rho_1 - \\theta_3.\n$$\n\n您的任务是实现一个程序，它能：\n- 对于每个 $\\mathrm{IGD} < 0$ 的测试用例，计算 $L = -\\mathrm{IGD}$（单位为核苷酸）。\n- 如果 $r = 0$，计算 $F=1$，否则计算 $F=0$。\n- 使用校准后的参数 $\\theta_0, \\theta_1, \\theta_2, \\theta_3$ 为每个测试用例计算 $P(O=1 \\mid L,F)$。\n- 将每个得到的概率四舍五入到六位小数。\n\n请使用以下的 $(\\mathrm{IGD}, r)$ 对测试套件，其中 $\\mathrm{IGD}$ 的单位是核苷酸，而 $r$ 是无量纲的：\n- 用例1: $\\mathrm{IGD} = -1$, $r = 1$。\n- 用例2: $\\mathrm{IGD} = -1$, $r = 0$。\n- 用例3: $\\mathrm{IGD} = -4$, $r = 1$。\n- 用例4: $\\mathrm{IGD} = -4$, $r = 0$。\n- 用例5: $\\mathrm{IGD} = -25$, $r = 0$。\n- 用例6: $\\mathrm{IGD} = -25$, $r = 2$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6]”），其中每个“result”是对应于上述测试用例（并按相同顺序排列）的四舍五入后的概率 $P(O=1 \\mid L,F)$。输出结果是无量纲的浮点数，四舍五入到六位小数。", "solution": "我们使用一个以重叠长度和框型为条件的 logistic 模型，来形式化两个具有负基因间距离的相邻基因位于同一操纵子内的概率。设基因间距离（IGD）为同一条链上，上游开放阅读框（ORF）的末端与下游ORF的起始点之间的核苷酸距离，负值表示重叠。定义 $L = -\\mathrm{IGD}$，因此 $L \\in \\mathbb{Z}_{>0}$ 是以核苷酸为单位的重叠长度。定义阅读框偏移 $r \\in \\{0,1,2\\}$，以及框型指示符 $F$：如果 $r=0$ (同框)，则 $F=1$；否则 (移码)，$F=0$。\n\n该 logistic 模型为\n$$\nP(O=1 \\mid L,F) = \\sigma\\!\\big(\\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F\\big), \\quad \\sigma(x)=\\frac{1}{1+e^{-x}}.\n$$\n等价地，对数几率（logit）是特征 $L$、$F$ 和 $L F$ 的线性函数。为了从第一性原理确定参数，我们将给定的校准约束编码为关于几率的关系。设 $p_{\\mathrm{fs},1}$ 为移码重叠在 $L=1$ 时的基线概率，$k_{\\mathrm{fs}}$ 为移码重叠的每核苷酸几率乘数。那么对于 $F=0$，\n$$\n\\log\\frac{P}{1-P} = \\theta_0 + \\theta_1 L \\quad \\Rightarrow \\quad \\theta_1 = \\ln k_{\\mathrm{fs}}, \\;\\; \\theta_0 + \\theta_1 \\cdot 1 = \\ln\\!\\left(\\frac{p_{\\mathrm{fs},1}}{1-p_{\\mathrm{fs},1}}\\right),\n$$\n所以\n$$\n\\theta_1 = \\ln k_{\\mathrm{fs}}, \\quad \\theta_0 = \\ln\\!\\left(\\frac{p_{\\mathrm{fs},1}}{1-p_{\\mathrm{fs},1}}\\right) - \\theta_1.\n$$\n对于同框重叠，每核苷酸几率乘数为 $k_{\\mathrm{if}}$，且在 $L=1$ 时的同框优势是相对于 $L=1$ 时移码重叠的几率比 $\\rho_1$。对于 $F=1$，我们有\n$$\n\\log\\frac{P}{1-P} = (\\theta_0 + \\theta_2) + (\\theta_1 + \\theta_3) L,\n$$\n因此，每核苷酸乘数条件意味着 $\\theta_1 + \\theta_3 = \\ln k_{\\mathrm{if}}$，即\n$$\n\\theta_3 = \\ln k_{\\mathrm{if}} - \\ln k_{\\mathrm{fs}}.\n$$\n$L=1$ 时的几率比为\n$$\n\\rho_1 = \\frac{\\exp\\big(\\theta_0 + \\theta_1 \\cdot 1 + \\theta_2 + \\theta_3 \\cdot 1\\big)}{\\exp\\big(\\theta_0 + \\theta_1 \\cdot 1\\big)} = \\exp(\\theta_2 + \\theta_3),\n$$\n因此\n$$\n\\theta_2 = \\ln \\rho_1 - \\theta_3.\n$$\n\n使用提供的数值 $p_{\\mathrm{fs},1} = 0.2$、$k_{\\mathrm{fs}} = 1.04$、$\\rho_1 = 3.0$ 和 $k_{\\mathrm{if}} = 1.12$，我们得到\n$$\n\\theta_1 = \\ln(1.04), \\quad\n\\theta_0 = \\ln\\!\\left(\\frac{0.2}{0.8}\\right) - \\ln(1.04), \\quad\n\\theta_3 = \\ln(1.12) - \\ln(1.04), \\quad\n\\theta_2 = \\ln(3.0) - \\theta_3.\n$$\n这些常数完全指定了该模型。\n\n对于每个测试用例 $(\\mathrm{IGD}, r)$，计算 $L = -\\mathrm{IGD}$ 且若 $r=0$ 则 $F=1$ 否则 $F=0$。然后计算对数几率 $z = \\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F$，将其转换为几率 $o = e^{z}$，最后通过 $P = \\dfrac{o}{1+o}$ 得到概率。将每个 $P$ 四舍五入到六位小数。\n\n将此过程应用于六个指定的测试用例，会产生六个无量纲的概率，它们对应于校准模型下的操纵子成员概率，并按相同顺序报告，格式化为单行上的单个列表。在给定校准的情况下，该计算是确定性的，并且不需要外部数据。程序将精确执行这些步骤，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np  # Allowed library; not strictly required but imported per environment spec.\n\ndef sigmoid(x: float) -> float:\n    # Numerically stable logistic function for moderate x.\n    if x >= 0:\n        z = math.exp(-x)\n        return 1.0 / (1.0 + z)\n    else:\n        z = math.exp(x)\n        return z / (1.0 + z)\n\ndef calibrate_parameters(p_fs1: float, k_fs: float, rho1: float, k_if: float):\n    \"\"\"\n    Compute theta0, theta1, theta2, theta3 from the calibration constraints:\n    theta1 = ln(k_fs)\n    theta0 = ln(p_fs1/(1-p_fs1)) - theta1\n    theta3 = ln(k_if) - theta1\n    theta2 = ln(rho1) - theta3\n    \"\"\"\n    theta1 = math.log(k_fs)\n    # avoid division by zero (not applicable here because p_fs1 in (0,1))\n    odds_fs1 = p_fs1 / (1.0 - p_fs1)\n    theta0 = math.log(odds_fs1) - theta1\n    theta3 = math.log(k_if) - theta1\n    theta2 = math.log(rho1) - theta3\n    return theta0, theta1, theta2, theta3\n\ndef operon_probability(igd: int, r: int, thetas):\n    \"\"\"\n    Compute P(O=1 | L, F) where L = -IGD (IGD < 0), F = 1 if r % 3 == 0 else 0.\n    \"\"\"\n    theta0, theta1, theta2, theta3 = thetas\n    if igd >= 0:\n        raise ValueError(\"IGD must be negative for overlaps\")\n    L = -int(igd)\n    F = 1 if (r % 3 == 0) else 0\n    z = theta0 + theta1 * L + theta2 * F + theta3 * L * F\n    p = sigmoid(z)\n    return p\n\ndef solve():\n    # Calibration constants\n    p_fs1 = 0.2     # Baseline probability at L=1 for frameshift overlaps\n    k_fs  = 1.04    # Per-nucleotide odds multiplier for frameshift overlaps\n    rho1  = 3.0     # Odds ratio (in-frame vs frameshift) at L=1\n    k_if  = 1.12    # Per-nucleotide odds multiplier for in-frame overlaps\n\n    # Calibrate model parameters\n    thetas = calibrate_parameters(p_fs1, k_fs, rho1, k_if)\n\n    # Define the test cases from the problem statement: (IGD, r)\n    test_cases = [\n        (-1, 1),   # Case 1\n        (-1, 0),   # Case 2\n        (-4, 1),   # Case 3\n        (-4, 0),   # Case 4\n        (-25, 0),  # Case 5\n        (-25, 2),  # Case 6\n    ]\n\n    results = []\n    for igd, r in test_cases:\n        p = operon_probability(igd, r, thetas)\n        # Round to six decimal places as required\n        p_rounded = float(f\"{p:.6f}\")\n        results.append(p_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```", "id": "2410891"}, {"introduction": "从简单的规则到精密的概率模型是生物信息学发展的常见路径。本练习将引导您完成这一过程：首先，您将分析一个基于距离阈值 $T$ 的简单预测器的局限性，并识别其产生的假阳性 ($\\mathrm{FP}$) 和假阴性 ($\\mathrm{FN}$)。然后，您将构建一个更强大的朴素贝叶斯分类器，并采用留一法交叉验证进行严谨的性能评估，从而完整地体验模型构建、评估和改进的全周期 [@problem_id:2410867]。", "problem": "给定您一个二元分类任务，该任务为原核生物基因组中连续基因间的操纵子邻近性预测建模。目标是分析一个简单的基于距离的操纵子预测器（作为流行的基于规则的操纵子预测器的代表）所产生的假阳性和假阴性，并实现一种基于概率论和生物学上合理的特征建模的、有原則的算法改进。\n\n从以下基本基础开始：分子生物学的中心法则指出，DNA被转录成RNA，在原核生物中，多个基因可以作为一个称为操纵子的单一转录单元被共转录；因此，同一操纵子内的相邻基因往往位于同一DNA链上，并由短的基因间距离分隔。经验性研究表明，同一操纵子内的相邻基因通常表现出协同表达，这可以通过跨多个条件下的Pearson相关系数（PCC）来捕捉。根据概率论，Bayes定理将后验概率、先验概率和似然联系起来，即$P(Y \\mid X) \\propto P(X \\mid Y) P(Y)$，并且，在条件独立性假设下，$P(X \\mid Y) = \\prod_{k} P(X_k \\mid Y)$。\n\n任务规范：\n- 每个相邻基因对的特征定义如下：\n  - $S \\in \\{0,1\\}$: 同一链指示符，如果两个基因在同一DNA链上，则$S=1$，否则$S=0$（无单位）。\n  - $d \\in \\mathbb{Z}$: 以碱基对（bp）为单位的基因间距离，其中负值表示重叠（以bp计）。\n  - $r \\in (-1,1)$: 跨多个条件的表达谱的Pearson相关系数（PCC）（无单位）。\n  - $y \\in \\{0,1\\}$: 真实标签，其中$y=1$表示该基因对在同一操纵子内，否则$y=0$（无单位）。\n- 基准预测器：当且仅当$S=1$且$d \\le T$时，预测$\\hat{y}=1$，否则预测$\\hat{y}=0$，其中$T$是一个以碱基对（bp）为单位的指定阈值。\n- 改进的预测器：使用Bayes定理推导决策规则，并采用以下生成模型假设：\n  - 对$r$应用Fisher $z$变换：$z = \\operatorname{atanh}(r)$。\n  - 以类别$y \\in \\{0,1\\}$为条件，并假设条件独立：\n    - $d \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(d)}, (\\sigma_{y}^{(d)})^2)$，\n    - $z \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(z)}, (\\sigma_{y}^{(z)})^2)$，\n    - $S \\mid y \\sim \\operatorname{Bernoulli}(\\theta_y)$，\n    - 类别先验为$\\pi_y = P(y)$。\n  - 估计协议必须是留一法：对于每个测试对$i$，仅使用其余的$n-1$个基因对来估计所有参数$\\{\\mu_{y}^{(d)}, \\sigma_{y}^{(d)}, \\mu_{y}^{(z)}, \\sigma_{y}^{(z)}, \\theta_y, \\pi_y\\}$。对高斯参数使用最大似然估计，对伯努利参数和类别先验使用加性（Laplace）平滑，采用强度为$\\alpha$的对称Beta先验，即$\\theta_y = \\dfrac{k + \\alpha}{m + 2\\alpha}$，其中$k$是y类样本中$S=1$的计数，$m$是y类样本的数量，所有这些都在$n-1$个基因对上计算。对$\\pi_y$使用相同的方案和类别计数。通过根据需要为每个方差估计值加上一个小的$\\varepsilon$来强制方差为严格正数。\n  - 如果后验概率$P(y=1 \\mid S,d,z)$超过$0.5$，则预测$\\hat{y}=1$，否则预测$\\hat{y}=0$。\n\n数据集（测试套件）：\n- 您必须精确使用以下$n=16$个相邻基因对，每个基因对以$(S, d, r, y)$的形式提供，其中$d$的单位为碱基对（bp），$r$无单位：\n  - 案例 1: $(1, -5, 0.85, 1)$\n  - 案例 2: $(1, 10, 0.80, 1)$\n  - 案例 3: $(1, 30, 0.75, 1)$\n  - 案例 4: $(1, 55, 0.88, 1)$\n  - 案例 5: $(1, 95, 0.90, 1)$\n  - 案例 6: $(1, 0, 0.70, 1)$\n  - 案例 7: $(1, 40, 0.65, 1)$\n  - 案例 8: $(1, 20, 0.60, 1)$\n  - 案例 9: $(1, 15, 0.10, 0)$\n  - 案例 10: $(0, 20, 0.05, 0)$\n  - 案例 11: $(1, 150, 0.20, 0)$\n  - 案例 12: $(0, -10, -0.05, 0)$\n  - 案例 13: $(1, 300, 0.40, 0)$\n  - 案例 14: $(0, 80, 0.30, 0)$\n  - 案例 15: $(1, 5, 0.00, 0)$\n  - 案例 16: $(0, 400, 0.20, 0)$\n\n评估和输出：\n- 对于基准预测器，评估在三个阈值下的假阳性和假阴性：$T \\in \\{20, 60, 120\\}$（单位为bp）。对于每个阈值$T$，计算：\n  - $\\mathrm{FP}(T)$: $y=0$且$\\hat{y}=1$的基因对数量，\n  - $\\mathrm{FN}(T)$: $y=1$且$\\hat{y}=0$的基因对数量。\n- 对于改进的预测器，使用对称平滑强度$\\alpha = 0.5$和方差下限$\\varepsilon = 10^{-6}$的留一法参数估计协议，计算：\n  - $\\mathrm{FP}_{\\mathrm{imp}}$: $y=0$且$\\hat{y}=1$的基因对数量，\n  - $\\mathrm{FN}_{\\mathrm{imp}}$: $y=1$且$\\hat{y}=0$的基因对数量。\n- 要求的最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按以下顺序排列：\n  - $[\\mathrm{FP}(20), \\mathrm{FN}(20), \\mathrm{FP}(60), \\mathrm{FN}(60), \\mathrm{FP}(120), \\mathrm{FN}(120), \\mathrm{FP}_{\\mathrm{imp}}, \\mathrm{FN}_{\\mathrm{imp}}]$。\n- 单位：基因间距离$d$和阈值$T$的单位是碱基对（bp）。所有其他量均为无单位。输出本身由整数组成，不得包含单位。\n\n设计约束：\n- 普适性：基于上述定义和假设，以纯粹的数学和算法术语来构建您的解决方案。\n- 科学真实性：数据和建模假设反映了真实的操縱子生物学；$S$、$d$和$r$如上定义，其中$r$严格介于$-1$和$1$之间。\n- 测试套件和覆盖范围：三个阈值$T \\in \\{20, 60, 120\\}$在严格到宽松的距離截斷值范围内检验基准预测器的行为。數據包括邊緣案例，例如负$d$（重叠）、相反链（$S=0$）、非操纵子对的小的同向链距离（具有挑战性的假阳性），以及操纵子对的长距离（具有挑战性的假阴性）。", "solution": "该问题陈述已经过严格验证，并被认为是有效的。它在科学上基于分子生物学和概率论的原理，其定义和数据完整且一致，问题阐述良好，并且表述客观。我们将继续进行解答。\n\n任务是实现并评估两种用于基因对之间操纵子邻近性的预测器。第一种是基于简单规则的基准预测器，第二种是基于朴素贝叶斯分类器的改进预测器。\n\n首先，我们分析基准预测器。预测规则定义为：当且仅当基因对位于同一DNA链（$S=1$）且基因间距离$d$小于或等于阈值$T$（单位为碱基对，bp）时，预测$\\hat{y}=1$。否则，预测为$\\hat{y}=0$。我们针对三个阈值$T \\in \\{20, 60, 120\\}$评估此规则。对于每个阈值，我们必须计算假阳性（$\\mathrm{FP}(T)$）的数量，即非操纵子对（$y=0$）被错误分类为操纵子对（$\\hat{y}=1$），以及假阴性（$\\mathrm{FN}(T)$）的数量，即操纵子对（$y=1$）被错误分类为非操纵子对（$\\hat{y}=0$）。\n\n所提供的数据集包含$n=16$个基因对，其中8个是操纵子对（$y=1$），8个是非操纵子对（$y=0$）。所有8个操纵子对都具有$S=1$。\n\n对于$T=20$ bp:\n预测为阳性的条件是$S=1$且$d \\le 20$。\n- 操纵子对（$y=1$）：案例3（$d=30$）、案例4（$d=55$）、案例5（$d=95$）和案例7（$d=40$）的$d > 20$。它们被错误分类，导致$\\mathrm{FN}(20)=4$。\n- 非操縱子對（$y=0$）：案例9（$S=1, d=15$）和案例15（$S=1, d=5$）滿足條件。它們被錯誤分類，導致$\\mathrm{FP}(20)=2$。\n\n对于$T=60$ bp:\n预测为阳性的条件是$S=1$且$d \\le 60$。\n- 操縱子對（$y=1$）：只有案例5（$d=95$）的$d > 60$。它被錯誤分類，導致$\\mathrm{FN}(60)=1$。\n- 非操縱子對（$y=0$）：案例9（$S=1, d=15$）和案例15（$S=1, d=5$）繼續滿足條件。它們被錯誤分類，導致$\\mathrm{FP}(60)=2$。\n\n对于$T=120$ bp:\n预测为阳性的条件是$S=1$且$d \\le 120$。\n- 操縱子對（$y=1$）：所有操縱子對的$d \\le 95$，因此都被正确分类。这导致$\\mathrm{FN}(120)=0$。\n- 非操縱子對（$y=0$）：案例9（$S=1, d=15$）和案例15（$S=1, d=5$）仍然被错误分类。这导致$\\mathrm{FP}(120)=2$。\n\n基准预测器展示了一个经典的权衡：增加距离阈值$T$会减少假阴性，但代价是未能解决根本性的假阳性问题，这些假阳性是由那些在DNA链和距离上模仿操纵子对、但在其他生物信号（如表达协调性）上不相似的非操纵子对引起的。\n\n接下来，我们构建改进的预测器，即一个朴素贝叶斯分类器。该模型引入了一个额外的特征，即Pearson相关系数$r$，并使用概率框架进行决策。决策规则是如果后驗概率$P(y=1 \\mid S, d, r)$大于0.5，则预测$\\hat{y}=1$。\n\n該模型基於Bayes定理：$P(y \\mid X) \\propto P(X \\mid y)P(y)$，其中$X$表示特征向量。在朴素的条件独立性假设下，类条件似然为$P(X \\mid y) = P(S \\mid y)P(d \\mid y)P(z \\mid y)$，其中$z = \\operatorname{atanh}(r)$是Fisher变换后的相关性。\n\n决策规则$P(y=1 \\mid X) > P(y=0 \\mid X)$等价于比较未归一化的后验概率，$P(X \\mid y=1)P(y=1) > P(X \\mid y=0)P(y=0)$。为了数值稳定性，我们比较对数后验得分：\n$$ \\log P(y=1|X) > \\log P(y=0|X) $$\n其中，类别$y \\in \\{0, 1\\}$的对数后验由下式给出：\n$$ \\log S_y = \\log \\pi_y + \\log P(S \\mid y) + \\log P(d \\mid y) + \\log P(z \\mid y) $$\n各组成部分建模如下：\n- 类别先验$\\pi_y = P(y)$。\n- $S \\mid y \\sim \\operatorname{Bernoulli}(\\theta_y)$，所以其对数似然为$S \\log \\theta_y + (1-S) \\log(1-\\theta_y)$。\n- $d \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(d)}, (\\sigma_{y}^{(d)})^2)$，其对数似然为$-\\frac{1}{2} \\log\\left(2\\pi (\\sigma_{y}^{(d)})^2\\right) - \\frac{(d - \\mu_{y}^{(d)})^2}{2(\\sigma_{y}^{(d)})^2}$。\n- $z \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(z)}, (\\sigma_{y}^{(z)})^2)$，其对数似然为$-\\frac{1}{2} \\log\\left(2\\pi (\\sigma_{y}^{(z)})^2\\right) - \\frac{(z - \\mu_{y}^{(z)})^2}{2(\\sigma_{y}^{(z)})^2}$。\n\n参数估计使用留一法（LOO）协议进行。对于$n=16$个基因对中的每一个，它被作为测试案例剔除，模型参数从剩余的$n-1=15$个基因对中估计。令$n_y$为类别$y$中训练样本的数量，且$n_{\\text{train}} = n_0+n_1 = 15$。\n- 先验概率$\\pi_y$和伯努利参数$\\theta_y$使用加性（Laplace）平滑估计，$\\alpha=0.5$。\n    - $\\pi_y = \\dfrac{n_y + \\alpha}{n_{\\text{train}} + 2\\alpha} = \\dfrac{n_y + 0.5}{15 + 1.0} = \\dfrac{n_y + 0.5}{16}$。\n    - $\\theta_y = P(S=1 \\mid y) = \\dfrac{k_y + \\alpha}{n_y + 2\\alpha} = \\dfrac{k_y + 0.5}{n_y + 1.0}$，其中$k_y$是类别$y$中$S=1$样本的计数。\n- 高斯参数使用训练数据上对每个类别y的最大似然估计（MLE）进行估计：\n    - 均值：$\\mu_y^{(f)} = \\frac{1}{n_y} \\sum_{i=1}^{n_y} f_i$ 对于特征$f \\in \\{d, z\\}$。\n    - 方差：$(\\sigma_y^{(f)})^2 = \\left(\\frac{1}{n_y} \\sum_{i=1}^{n_y} (f_i - \\mu_y^{(f)})^2\\right) + \\varepsilon$，其中问题指定添加$\\varepsilon=10^{-6}$以确保严格为正。\n\n對於每個被剔除的測試案例，我們使用從相應訓練集派生的参数计算对数后验得分$\\log S_1$和$\\log S_0$。如果$\\log S_1 > \\log S_0$，则预测为$\\hat{y}=1$，否则为$\\hat{y}=0$。通过在LOO过程的所有16次迭代中将这些预测与真实标签进行比较，我们累积$\\mathrm{FP}_{\\mathrm{imp}}$和$\\mathrm{FN}_{\\mathrm{imp}}$的总数。\n\n此程序的实现（如最终答案代码中详述）将得出完成评估所需的计数。最终结果向量是两种预测器性能指标的汇总。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the operon prediction problem by implementing and evaluating\n    a baseline predictor and an improved Naive Bayes classifier.\n    \"\"\"\n    # Define the dataset as provided in the problem statement.\n    # Each tuple is (S, d, r, y).\n    data_raw = [\n        (1, -5, 0.85, 1), (1, 10, 0.80, 1), (1, 30, 0.75, 1), (1, 55, 0.88, 1),\n        (1, 95, 0.90, 1), (1, 0, 0.70, 1), (1, 40, 0.65, 1), (1, 20, 0.60, 1),\n        (1, 15, 0.10, 0), (0, 20, 0.05, 0), (1, 150, 0.20, 0), (0, -10, -0.05, 0),\n        (1, 300, 0.40, 0), (0, 80, 0.30, 0), (1, 5, 0.00, 0), (0, 400, 0.20, 0)\n    ]\n    \n    # Use a structured numpy array for clear feature access.\n    # The Fisher z-transform is pre-calculated for all data points.\n    data = np.array(\n        [(s, d, r, np.arctanh(r), y) for s, d, r, y in data_raw],\n        dtype=[('S', 'i4'), ('d', 'i4'), ('r', 'f8'), ('z', 'f8'), ('y', 'i4')]\n    )\n    \n    n_total = len(data)\n    results = []\n\n    # --- Part 1: Baseline Predictor Evaluation ---\n    thresholds_T = [20, 60, 120]\n    for T in thresholds_T:\n        FP_T, FN_T = 0, 0\n        for i in range(n_total):\n            sample = data[i]\n            y_true = sample['y']\n            \n            # Baseline prediction rule: y_hat = 1 iff S=1 and d <= T\n            y_pred = 1 if sample['S'] == 1 and sample['d'] <= T else 0\n            \n            if y_pred == 1 and y_true == 0:\n                FP_T += 1\n            if y_pred == 0 and y_true == 1:\n                FN_T += 1\n        results.extend([FP_T, FN_T])\n\n    # --- Part 2: Improved Naive Bayes Predictor Evaluation ---\n    FP_imp, FN_imp = 0, 0\n    alpha = 0.5  # Smoothing parameter\n    epsilon = 1e-6 # Variance floor\n    \n    # Leave-one-out cross-validation loop\n    for i in range(n_total):\n        test_sample = data[i]\n        train_samples = np.delete(data, i, axis=0)\n        \n        # Separate training data by class\n        train_1 = train_samples[train_samples['y'] == 1]\n        train_0 = train_samples[train_samples['y'] == 0]\n        \n        n_train = len(train_samples)\n        n1 = len(train_1)\n        n0 = len(train_0)\n        \n        # --- Parameter Estimation from Training Data ---\n        \n        # 1. Class priors (pi_y) with Laplace smoothing\n        pi_1 = (n1 + alpha) / (n_train + 2 * alpha)\n        pi_0 = (n0 + alpha) / (n_train + 2 * alpha)\n        \n        # 2. Bernoulli parameters (theta_y) for feature S with Laplace smoothing\n        k1_s = np.sum(train_1['S'])\n        theta_1 = (k1_s + alpha) / (n1 + 2 * alpha)\n        \n        k0_s = np.sum(train_0['S'])\n        theta_0 = (k0_s + alpha) / (n0 + 2 * alpha)\n\n        # 3. Gaussian parameters (mu, sigma^2) for features d and z\n        # Class y=1\n        mu1_d = np.mean(train_1['d'])\n        var1_d = np.var(train_1['d']) + epsilon\n        mu1_z = np.mean(train_1['z'])\n        var1_z = np.var(train_1['z']) + epsilon\n        \n        # Class y=0\n        mu0_d = np.mean(train_0['d'])\n        var0_d = np.var(train_0['d']) + epsilon\n        mu0_z = np.mean(train_0['z'])\n        var0_z = np.var(train_0['z']) + epsilon\n        \n        # --- Prediction on Test Sample ---\n        # Calculate log posterior scores for each class\n        \n        # Log Priors\n        log_prior_1 = np.log(pi_1)\n        log_prior_0 = np.log(pi_0)\n        \n        # Log Likelihood for S\n        s_test = test_sample['S']\n        log_p_S_1 = s_test * np.log(theta_1) + (1 - s_test) * np.log(1 - theta_1)\n        log_p_S_0 = s_test * np.log(theta_0) + (1 - s_test) * np.log(1 - theta_0)\n        \n        # Log Likelihood for d\n        d_test = test_sample['d']\n        log_p_d_1 = norm.logpdf(d_test, loc=mu1_d, scale=np.sqrt(var1_d))\n        log_p_d_0 = norm.logpdf(d_test, loc=mu0_d, scale=np.sqrt(var0_d))\n        \n        # Log Likelihood for z\n        z_test = test_sample['z']\n        log_p_z_1 = norm.logpdf(z_test, loc=mu1_z, scale=np.sqrt(var1_z))\n        log_p_z_0 = norm.logpdf(z_test, loc=mu0_z, scale=np.sqrt(var0_z))\n        \n        # Total log posterior scores\n        log_score_1 = log_prior_1 + log_p_S_1 + log_p_d_1 + log_p_z_1\n        log_score_0 = log_prior_0 + log_p_S_0 + log_p_d_0 + log_p_z_0\n        \n        # Prediction\n        y_pred = 1 if log_score_1 > log_score_0 else 0\n        y_true = test_sample['y']\n        \n        if y_pred == 1 and y_true == 0:\n            FP_imp += 1\n        if y_pred == 0 and y_true == 1:\n            FN_imp += 1\n\n    results.extend([FP_imp, FN_imp])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2410867"}]}