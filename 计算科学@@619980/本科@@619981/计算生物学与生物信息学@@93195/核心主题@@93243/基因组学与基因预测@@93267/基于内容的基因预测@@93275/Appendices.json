{"hands_on_practices": [{"introduction": "密码子适应指数（CAI）是衡量基因表达水平和预测基因功能的一个关键指标。这个练习旨在通过一个涉及不确定碱基的序列，让你计算 CAI 可能的取值范围，从而加深你对 CAI 计算方式的理解。通过确定最大和最小可能的 CAI 值，你将直观地看到单个密码子的选择如何通过几何平均影响整个序列的适应性分数。[@problem_id:2381997]", "problem": "一个固定阅读框中的基因组片段，使用密码子适应指数（CAI）来分析其密码子使用偏好性。根据定义，对于一个固定阅读框中长度为 $L$ 个密码子的编码序列，其CAI是其密码子相对适应性权重 $w_{c}$ 的几何平均值：\n$$\\mathrm{CAI}=\\left(\\prod_{i=1}^{L} w_{c_i}\\right)^{1/L}.$$\n每个 $w_{c}$ 是一个在区间 $(0,1]$ 内的无量纲相对适应性权重，它是相对于一个固定的参考集定义的。考虑DNA序列（阅读框从第一个碱基开始）：\nATGGCNCGNTTNCCN\n其中模糊字符 $\\mathrm{N}$ 表示 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 中的任意一个核苷酸，且每个位置上的选择是独立的。该阅读框将此序列划分为 $L=5$ 个密码子：$\\mathrm{ATG}$、$\\mathrm{GCN}$、$\\mathrm{CGN}$、$\\mathrm{TTN}$、$\\mathrm{CCN}$。根据构造，在当前阅读框中，由这些模糊位置可能产生的所有密码子都不是终止密码子。\n\n在此阅读框中可能出现的所有密码子的相对适应性权重 $w_{c}$ 如下：\n- $w(\\mathrm{ATG})=1$。\n- 对于 $\\mathrm{GCN}$：$w(\\mathrm{GCA})=0.2$, $w(\\mathrm{GCC})=1$, $w(\\mathrm{GCG})=0.7$, $w(\\mathrm{GCT})=0.4$。\n- 对于 $\\mathrm{CGN}$：$w(\\mathrm{CGA})=0.1$, $w(\\mathrm{CGC})=1$, $w(\\mathrm{CGG})=0.8$, $w(\\mathrm{CGT})=0.6$。\n- 对于 $\\mathrm{TTN}$：$w(\\mathrm{TTA})=0.05$, $w(\\mathrm{TTC})=1$, $w(\\mathrm{TTG})=0.1$, $w(\\mathrm{TTT})=0.5$。\n- 对于 $\\mathrm{CCN}$：$w(\\mathrm{CCA})=0.3$, $w(\\mathrm{CCC})=1$, $w(\\mathrm{CCG})=0.9$, $w(\\mathrm{CCT})=0.6$。\n\n在遵循固定阅读框的前提下，对于 $\\mathrm{N}$ 到核苷酸的所有可能赋值，确定此序列可能的最大和最小CAI值。以有序对（最小值，最大值）的形式报告你的答案。将你的答案四舍五入到四位有效数字。CAI是无量纲的；不要包含单位。", "solution": "所提出的问题定义明确，并基于计算生物学的原理。我们将直接进行求解。\n\n对于一个长度为 $L$ 个密码子的编码序列，其密码子适应指数（CAI）定义为其组成密码子相对适应性权重 $w_{c_i}$ 的几何平均值：\n$$ \\mathrm{CAI} = \\left(\\prod_{i=1}^{L} w_{c_i}\\right)^{1/L} $$\n给定的DNA序列是 $\\mathrm{ATGGCNCGNTTNCCN}$。阅读框从第一个碱基开始，该序列被划分为 $L=5$ 个密码子：\n$c_1 = \\mathrm{ATG}$, $c_2 = \\mathrm{GCN}$, $c_3 = \\mathrm{CGN}$, $c_4 = \\mathrm{TTN}$, $c_5 = \\mathrm{CCN}$。\n\n第一个密码子的权重为 $w(\\mathrm{ATG})=1$。这是一个恒定因子。后续的密码子包含模糊核苷酸 $\\mathrm{N}$，它可以是 $\\mathrm{A}$、$\\mathrm{C}$、$\\mathrm{G}$ 或 $\\mathrm{T}$ 中的任意一个。在每个模糊位置上对 $\\mathrm{N}$ 的选择是独立的。\n因此，CAI的表达式为：\n$$ \\mathrm{CAI} = \\left( w(\\mathrm{ATG}) \\cdot w(\\mathrm{GCN}) \\cdot w(\\mathrm{CGN}) \\cdot w(\\mathrm{TTN}) \\cdot w(\\mathrm{CCN}) \\right)^{1/5} $$\n$$ \\mathrm{CAI} = \\left( 1 \\cdot w(\\mathrm{GCN}) \\cdot w(\\mathrm{CGN}) \\cdot w(\\mathrm{TTN}) \\cdot w(\\mathrm{CCN}) \\right)^{1/5} $$\n函数 $f(x) = x^{1/5}$ 对于正自变量 $x$ 是一个严格递增函数。由于所有给定的权重 $w_c$ 都在区间 $(0, 1]$ 内，它们的乘积也将是一个正数。因此，要找到CAI的可能最小值和最大值，我们必须找到权重乘积 $\\prod_{i=1}^{5} w_{c_i}$ 的最小值和最大值。\n由于每个 `N` 的核苷酸选择是独立的，总乘积可以通过选择使每个单独权重最大化的密码子序列来最大化，并通过选择使每个单独权重最小化的密码子序列来最小化。\n\n首先，我们来确定可能的最大CAI值。这需要我们为每个 `N` 选择核苷酸，以使得相应的密码子权重最大。我们检查为每个模糊密码子家族提供的权重：\n- 对于 $c_2 = \\mathrm{GCN}$：可用权重为 $w(\\mathrm{GCA})=0.2$, $w(\\mathrm{GCC})=1$, $w(\\mathrm{GCG})=0.7$, 和 $w(\\mathrm{GCT})=0.4$。最大权重是 $w_{\\max}(\\mathrm{GCN}) = 1$。\n- 对于 $c_3 = \\mathrm{CGN}$：可用权重为 $w(\\mathrm{CGA})=0.1$, $w(\\mathrm{CGC})=1$, $w(\\mathrm{CGG})=0.8$, 和 $w(\\mathrm{CGT})=0.6$。最大权重是 $w_{\\max}(\\mathrm{CGN}) = 1$。\n- 对于 $c_4 = \\mathrm{TTN}$：可用权重为 $w(\\mathrm{TTA})=0.05$, $w(\\mathrm{TTC})=1$, $w(\\mathrm{TTG})=0.1$, 和 $w(\\mathrm{TTT})=0.5$。最大权重是 $w_{\\max}(\\mathrm{TTN}) = 1$。\n- 对于 $c_5 = \\mathrm{CCN}$：可用权重为 $w(\\mathrm{CCA})=0.3$, $w(\\mathrm{CCC})=1$, $w(\\mathrm{CCG})=0.9$, 和 $w(\\mathrm{CCT})=0.6$。最大权重是 $w_{\\max}(\\mathrm{CCN}) = 1$。\n\n最大可能权重的乘积是：\n$$ P_{\\max} = w(\\mathrm{ATG}) \\cdot w_{\\max}(\\mathrm{GCN}) \\cdot w_{\\max}(\\mathrm{CGN}) \\cdot w_{\\max}(\\mathrm{TTN}) \\cdot w_{\\max}(\\mathrm{CCN}) $$\n$$ P_{\\max} = 1 \\cdot 1 \\cdot 1 \\cdot 1 \\cdot 1 = 1 $$\n最大CAI值是该乘积的五次方根：\n$$ \\mathrm{CAI}_{\\max} = (1)^{1/5} = 1 $$\n由于问题要求四舍五入到四位有效数字，最大值为 $1.000$。\n\n接下来，我们确定可能的最小CAI值。这需要为每个 `N` 选择能得到最小密码子权重的核苷酸。\n- 对于 $c_2 = \\mathrm{GCN}$：最小权重是 $w_{\\min}(\\mathrm{GCN}) = \\min\\{0.2, 1, 0.7, 0.4\\} = 0.2$。\n- 对于 $c_3 = \\mathrm{CGN}$：最小权重是 $w_{\\min}(\\mathrm{CGN}) = \\min\\{0.1, 1, 0.8, 0.6\\} = 0.1$。\n- 对于 $c_4 = \\mathrm{TTN}$：最小权重是 $w_{\\min}(\\mathrm{TTN}) = \\min\\{0.05, 1, 0.1, 0.5\\} = 0.05$。\n- 对于 $c_5 = \\mathrm{CCN}$：最小权重是 $w_{\\min}(\\mathrm{CCN}) = \\min\\{0.3, 1, 0.9, 0.6\\} = 0.3$。\n\n最小可能权重的乘积是：\n$$ P_{\\min} = w(\\mathrm{ATG}) \\cdot w_{\\min}(\\mathrm{GCN}) \\cdot w_{\\min}(\\mathrm{CGN}) \\cdot w_{\\min}(\\mathrm{TTN}) \\cdot w_{\\min}(\\mathrm{CCN}) $$\n$$ P_{\\min} = 1 \\cdot 0.2 \\cdot 0.1 \\cdot 0.05 \\cdot 0.3 $$\n$$ P_{\\min} = 0.02 \\cdot 0.05 \\cdot 0.3 = 0.001 \\cdot 0.3 = 0.0003 $$\n最小CAI值是该乘积的五次方根：\n$$ \\mathrm{CAI}_{\\min} = (0.0003)^{1/5} $$\n为了找到数值，我们计算：\n$$ \\mathrm{CAI}_{\\min} = (3 \\times 10^{-4})^{1/5} \\approx 0.19743286 $$\n四舍五入到四位有效数字，最小值为 $0.1974$。\n\n问题要求提供（最小值，最大值）的CAI值有序对。该有序对是 $(0.1974, 1.000)$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.1974 & 1.000 \\end{pmatrix}}\n$$", "id": "2381997"}, {"introduction": "在掌握了 CAI 的计算之后，让我们更进一步，从分析转向设计。这项练习要求你逆向工程一个 DNA 序列，它不仅能编码给定的氨基酸序列，其 CAI 值还要尽可能接近一个特定目标。这个任务模拟了合成生物学中常见的密码子优化问题，能让你在实践中体验如何平衡蛋白质功能和基因表达效率。[@problem_id:2381987]", "problem": "给定一个固定的目标密码子适应指数 (CAI) 值 $v=0.7$。对于一个由长度为 $L$ 的氨基酸序列表示的蛋白质片段，其DNA编码序列是由密码子连接而成的，每个氨基酸对应一个密码子。这些密码子取自标准遗传密码，但仅限于下文列出的密码子及其权重。每个密码子 $c$ 都有一个在区间 $(0,1]$ 内的相对适应性权重 $w(c)$。对于一个编码序列 $S=c_1c_2\\ldots c_L$，密码子适应指数定义为其几何平均值\n$$\n\\mathrm{CAI}(S)=\\left(\\prod_{i=1}^{L} w(c_i)\\right)^{1/L}.\n$$\n您的任务是，为每个给定的氨基酸序列，确定一个能编码该氨基酸序列的DNA编码序列 $S$，并使绝对差 $|\\mathrm{CAI}(S)-v|$ 最小。如果多个序列达到相同的最小绝对差，则优先选择满足 $\\mathrm{CAI}(S)\\le v$ 的序列，而不是 $\\mathrm{CAI}(S)>v$ 的序列。如果仍然存在平局，则在常规字母顺序 $A<C<G<T$ 下，选择字典序最小的DNA序列。下面提供的所有权重都严格为正，并且您只能对每种氨基酸使用所列出的密码子。\n\n密码子（DNA字母表）的相对适应性权重 $w(c)$ 针对测试集中出现的氨基酸指定如下：\n- 丙氨酸 ($\\mathrm{A}$): GCT ($0.35$), GCC ($1.0$), GCA ($0.25$), GCG ($0.5$).\n- 甘氨酸 ($\\mathrm{G}$): GGT ($0.3$), GGC ($1.0$), GGA ($0.2$), GGG ($0.5$).\n- 亮氨酸 ($\\mathrm{L}$): TTA ($0.2$), TTG ($0.3$), CTT ($0.25$), CTC ($0.5$), CTA ($0.1$), CTG ($1.0$).\n- 丝氨酸 ($\\mathrm{S}$): TCT ($0.4$), TCC ($0.6$), TCA ($0.3$), TCG ($1.0$), AGT ($0.2$), AGC ($0.8$).\n- 苏氨酸 ($\\mathrm{T}$): ACT ($0.4$), ACC ($1.0$), ACA ($0.3$), ACG ($0.7$).\n- 赖氨酸 ($\\mathrm{K}$): AAA ($0.6$), AAG ($1.0$).\n- 异亮氨酸 ($\\mathrm{I}$): ATT ($0.85$), ATC ($1.0$), ATA ($0.1$).\n- 精氨酸 ($\\mathrm{R}$): CGT ($0.7$), CGC ($1.0$), CGA ($0.1$), CGG ($0.2$), AGA ($0.05$), AGG ($0.05$).\n- 甲硫氨酸 ($\\mathrm{M}$): ATG ($1.0$).\n- 色氨酸 ($\\mathrm{W}$): TGG ($1.0$).\n\n测试集：\n- 案例 $1$：氨基酸序列 \"MKT\"。\n- 案例 $2$：氨基酸序列 \"GAS\"。\n- 案例 $3$：氨基酸序列 \"ILRW\"。\n- 案例 $4$：氨基酸序列 \"MWM\"。\n\n对于每个案例，仅报告您所选的最优编码序列的CAI值，该值需四舍五入为小数点后恰好 $6$ 位的小数。所有案例均使用固定目标值 $v=0.7$。您的程序应生成单行输出，其中包含案例1至4的结果，格式为用方括号括起来的逗号分隔列表。例如：“[r1,r2,r3,r4]”。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于分子生物学原理，特别是密码子使用偏好，并且在数学上是适定（well-posed）的。所有必要的数据和约束都已提供，不存在矛盾。我们将着手提供一个正式的解决方案。\n\n问题要求我们为给定长度为 $L$ 的氨基酸序列找到一个DNA编码序列 $S$，使得其密码子适应指数 $\\mathrm{CAI}(S)$ 尽可能接近目标值 $v=0.7$。$\\mathrm{CAI}$ 定义为构成序列的密码子 $c_i$ 的相对适应性权重 $w(c_i)$ 的几何平均值：\n$$\n\\mathrm{CAI}(S) = \\left( \\prod_{i=1}^{L} w(c_i) \\right)^{1/L}\n$$\n主要目标是最小化绝对差 $|\\mathrm{CAI}(S) - v|$。对于多个序列产生相同最小差的情况，指定了一套打破平局的规则。\n\n这是一个组合优化问题。对于一个氨基酸序列 $a_1 a_2 \\ldots a_L$，设每个氨基酸 $a_i$ 的同义密码子数量为 $n_i$。那么编码该蛋白质片段的可能DNA序列总数为乘积 $\\prod_{i=1}^L n_i$。我们必须在这个离散空间中搜索最优解。\n\n让我们评估每个测试案例的搜索空间大小，以确定穷举法的可行性。\n- 案例 $1$ (\"MKT\", $L=3$)：甲硫氨酸(M)有1种选择，赖氨酸(K)有2种选择，苏氨酸(T)有4种选择。序列总数为 $1 \\times 2 \\times 4 = 8$。\n- 案例 $2$ (\"GAS\", $L=3$)：甘氨酸(G)有4种选择，丙氨酸(A)有4种选择，丝氨酸(S)有6种选择。总数为 $4 \\times 4 \\times 6 = 96$。\n- 案例 $3$ (\"ILRW\", $L=4$)：异亮氨酸(I)有3种选择，亮氨酸(L)有6种选择，精氨酸(R)有6种选择，色氨酸(W)有1种选择。总数为 $3 \\times 6 \\times 6 \\times 1 = 108$。\n- 案例 $4$ (\"MWM\", $L=3$)：M有1种选择，W有1种选择，M有1种选择。仅有 $1 \\times 1 \\times 1 = 1$ 种可能的序列。\n\n在所有案例中，候选序列的数量都很小，这使得暴力枚举在计算上是微不足道的，在算法上是合理的。方法如下：\n1.  为给定的氨基酸序列生成所有可能的DNA编码序列。这可以通过对氨基酸序列中每个位置可用密码子集合进行笛卡尔积运算来完成。\n2.  对于每个生成的序列 $S = c_1 c_2 \\ldots c_L$，计算其 $\\mathrm{CAI}(S)$。这包括计算权重乘积 $P = \\prod_{i=1}^L w(c_i)$，然后取 $L$ 次方根，$\\mathrm{CAI}(S) = P^{1/L}$。\n3.  通过按层级顺序应用指定标准来确定最优序列。\n\n选择标准如下：\n1.  最小化 $|\\mathrm{CAI}(S) - v|$，其中 $v=0.7$。\n2.  如果在标准1上存在平局，则优先选择 $\\mathrm{CAI}(S) \\le v$ 的序列。\n3.  如果仍然存在平局，则选择字典序最小的DNA序列 $S$。\n\n实现这种多级优化的一个稳健方法是对所有候选解进行排序。对于每个由其DNA序列 $S$ 和计算出的 $\\mathrm{CAI}$ 值表示的候选解，我们可以构建一个复合排序键。一个合适的键是元组：\n$$\n\\left( |\\mathrm{CAI}(S) - v|, (\\mathrm{CAI}(S) > v), S \\right)\n$$\n按升序对这些元组的列表进行排序，会将最优解置于最前面。其逻辑如下：\n- 主排序依据是 $|\\mathrm{CAI}(S) - v|$，这解决了主要目标。\n- 对于第一个元素的平局，使用第二个元素，即布尔值 $(\\mathrm{CAI}(S) > v)$。在计算中，`False` 被视为 $0$，`True` 被视为 $1$。因此，$\\mathrm{CAI}(S) \\le v$ 的解（布尔值为 `False`）将排在 $\\mathrm{CAI}(S) > v$ 的解（布尔值为 `True`）之前，从而满足第二个标准。\n- 如果两个解的前两个元素都相同，则使用第三个元素，即序列字符串 $S$ 本身进行比较。标准的字典序字符串比较将确定字母顺序最小的序列，从而满足第三个标准。\n\n因此，要实现的算法如下：\n对于每个氨基酸序列：\n1.  构建所有可能的编码序列及其相应 $\\mathrm{CAI}$ 值的列表。\n2.  使用上面定义的复合键对此列表进行排序。\n3.  排序后列表的第一个元素即为最优解。\n4.  提取该最优解的 $\\mathrm{CAI}$ 值，将其四舍五入到所需精度（小数点后 $6$ 位），并报告该值。\n\n此过程保证能根据问题规则找到唯一的的最优解。对于精氨酸 (R) 的特殊情况，它有两个权重同为 $w=0.05$ 的密码子 (AGA, AGG)，如果它们是其他方面相同的最优候选序列的一部分，对 $S$ 的字典序平局决胜规则将确保做出唯一的选择。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Validates and solves the codon adaptation index optimization problem.\n    \"\"\"\n    # The target Codon Adaptation Index (CAI) value.\n    v = 0.7\n\n    # Relative adaptiveness weights w(c) for codons, sorted lexicographically by codon.\n    codon_data = {\n        'A': sorted([('GCT', 0.35), ('GCC', 1.0), ('GCA', 0.25), ('GCG', 0.5)]),\n        'G': sorted([('GGT', 0.3), ('GGC', 1.0), ('GGA', 0.2), ('GGG', 0.5)]),\n        'L': sorted([('TTA', 0.2), ('TTG', 0.3), ('CTT', 0.25), ('CTC', 0.5), ('CTA', 0.1), ('CTG', 1.0)]),\n        'S': sorted([('TCT', 0.4), ('TCC', 0.6), ('TCA', 0.3), ('TCG', 1.0), ('AGT', 0.2), ('AGC', 0.8)]),\n        'T': sorted([('ACT', 0.4), ('ACC', 1.0), ('ACA', 0.3), ('ACG', 0.7)]),\n        'K': sorted([('AAA', 0.6), ('AAG', 1.0)]),\n        'I': sorted([('ATT', 0.85), ('ATC', 1.0), ('ATA', 0.1)]),\n        'R': sorted([('CGT', 0.7), ('CGC', 1.0), ('CGA', 0.1), ('CGG', 0.2), ('AGA', 0.05), ('AGG', 0.05)]),\n        'M': sorted([('ATG', 1.0)]),\n        'W': sorted([('TGG', 1.0)]),\n    }\n\n    # Test suite of amino acid sequences.\n    test_cases = [\n        \"MKT\",\n        \"GAS\",\n        \"ILRW\",\n        \"MWM\",\n    ]\n\n    results = []\n    for aa_seq in test_cases:\n        L = len(aa_seq)\n        \n        # Get codon options for each position in the amino acid sequence.\n        # Each option is a tuple of (codon_string, weight).\n        codon_options_per_position = [codon_data[aa] for aa in aa_seq]\n\n        # Generate all possible combinations of codon choices.\n        # itertools.product generates the Cartesian product of input iterables.\n        all_codon_combinations = itertools.product(*codon_options_per_position)\n        \n        candidate_solutions = []\n        for combo in all_codon_combinations:\n            # combo is a tuple of (codon, weight) pairs, e.g., (('ATG', 1.0), ('AAG', 1.0), ...)\n            \n            # Construct the full DNA sequence string.\n            sequence_str = \"\".join([c[0] for c in combo])\n            \n            # Extract weights for CAI calculation.\n            weights = [c[1] for c in combo]\n            \n            # Calculate the product of weights.\n            prod_weights = np.prod(weights)\n            \n            # Calculate the Codon Adaptation Index (CAI).\n            cai = prod_weights**(1.0 / L)\n            \n            candidate_solutions.append({'seq': sequence_str, 'cai': cai})\n        \n        # Sort candidates to find the optimal one based on the hierarchical criteria.\n        # The sort key is a tuple: (abs_difference, preference_for_cai=v, lexicographical_order).\n        # Python's tuple sorting handles the priorities correctly.\n        # (cai > v) is a boolean; False  True, so cai=v is preferred in ties.\n        optimal_solution = sorted(\n            candidate_solutions, \n            key=lambda s: (abs(s['cai'] - v), s['cai'] > v, s['seq'])\n        )[0]\n        \n        # Format the result to 6 decimal places.\n        results.append(f\"{optimal_solution['cai']:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2381987"}, {"introduction": "基于内容的基因预测算法依赖于编码区和非编码区之间统计特征的差异。这项高级练习将挑战你对这些算法工作原理的深入理解，要求你构建一个“假阳性”序列。你需要设计一个不含起始密码子的非编码 DNA 序列，但其密码子频率却能“欺骗”一个简化的分类器，使其误判为基因，这突显了在真实基因预测中综合多种证据的重要性。[@problem_id:2382027]", "problem": "本文为您提供一个简化的、基于密码子使用偏好的内容基因预测场景。在此场景中，一个基因发现分类器仅使用一个包含$64$个元素的“基因”模型密码子概率向量，以及第二个包含$64$个元素的“背景”模型密码子概率向量。对于固定的阅读框和窗口长度，该分类器将序列视为一个非重叠密码子袋，并使用自然对数比较观察到的密码子计数在这两个模型下的可能性。脱氧核糖核酸（DNA）以称为密码子的三联体形式读取，因此在一个固定阅读框内，长度为 $L$ 的窗口包含 $\\lfloor L/3 \\rfloor$ 个密码子。在此场景中，起始密码子是 $\\text{ATG}$。开放阅读框（ORF）是指一段连续的、无终止密码子的框内密码子序列；然而，在本问题中，我们将使用下面定义的最小化非编码代理约束。\n\n基本依据与数据：\n- 该分类器是一个基于 $64$ 种密码子的多项式模型。它在阅读框 $0$（从索引 $0$ 开始）中评估窗口，并使用对数似然差比较这两个模型。对数似然比（LLR）使用自然对数计算，并且是无量纲的。\n- 基因模型的$64$种密码子概率 $\\mathbf{P}$ 按如下方式生成。设单核苷酸权重为 $w(\\text{A}) = 0.15$，$w(\\text{C}) = 0.35$，$w(\\text{G}) = 0.35$，$w(\\text{T}) = 0.15$。对于任何密码子 $\\text{X}_1\\text{X}_2\\text{X}_3$，赋予一个未归一化权重 $W(\\text{X}_1\\text{X}_2\\text{X}_3) = w(\\text{X}_1)\\, w(\\text{X}_2)\\, w(\\text{X}_3)$。对于三个终止密码子 $\\{\\text{TAA}, \\text{TAG}, \\text{TGA}\\}$，将其未归一化权重乘以一个终止密码子缩放因子 $s_{\\text{gene}} = 10^{-3}$，以反映编码区强烈避免内部终止密码子。然后将所有$64$个权重归一化，使其总和为$1$，从而得到 $\\mathbf{P}$。\n- 每个背景模型 $\\mathbf{Q}$ 都以类似方式从其自身的单核苷酸权重 $v(\\cdot)$ 生成，但终止密码子缩放因子为 $s_{\\text{bg}} = 1$（不对终止密码子进行特殊抑制），然后归一化为$64$种密码子的概率分布。\n\n本问题的非编码约束：\n- 如果一个构建的DNA序列在阅读框 $0$ 中不包含任何框内起始密码子 $\\text{ATG}$，则该序列被认为是非编码的。此代理约束仅用于本练习，并非生物学上对非编码的全面定义。\n\n分类规则：\n- 对于一个长度为 $L$ 的窗口，分类器在阅读框 $0$ 中对密码子进行计数，并使用多项式似然和自然对数计算基因模型 $\\mathbf{P}$ 与背景模型 $\\mathbf{Q}$ 之间的对数似然差。如果计算出的 LLR 超过给定阈值 $\\tau$，分类器则声明为“基因”。\n\n您的任务：\n- 构建一个长度为 $L = 1000$ 个核苷酸的DNA序列，该序列需满足上述非编码约束，并且对于下面测试套件中指定的每个背景模型，都会被分类器错误地分类为基因（即其LLR超过阈值）。分类器仅使用阅读框 $0$，并忽略任何不能构成完整密码子的末尾核苷酸；您必须只计算从位置 $0$ 开始的 $\\lfloor L/3 \\rfloor = 333$ 个完整密码子。\n- 您可以以任何方式构建序列，只要它遵守非编码约束并与上述定义自洽。在所有计算中使用自然对数。不涉及任何角度或物理单位。任何比例都必须表示为小数。\n\n测试套件：\n- 使用如上所述的基因模型 $\\mathbf{P}$，其中 $w(\\text{A}) = 0.15$，$w(\\text{C}) = 0.35$，$w(\\text{G}) = 0.35$，$w(\\text{T}) = 0.15$，以及 $s_{\\text{gene}} = 10^{-3}$。\n- 提供三个背景案例，每个案例都有其自己的单核苷酸权重 $v(\\cdot)$ 和阈值 $\\tau$：\n  1. 案例 1：$v_1(\\text{A}) = 0.25$，$v_1(\\text{C}) = 0.25$，$v_1(\\text{G}) = 0.25$，$v_1(\\text{T}) = 0.25$，阈值 $\\tau_1 = 60.0$。\n  2. 案例 2：$v_2(\\text{A}) = 0.18$，$v_2(\\text{C}) = 0.32$，$v_2(\\text{G}) = 0.32$，$v_2(\\text{T}) = 0.18$，阈值 $\\tau_2 = 7.0$。\n  3. 案例 3：$v_3(\\text{A}) = 0.40$，$v_3(\\text{C}) = 0.10$，$v_3(\\text{G}) = 0.10$，$v_3(\\text{T}) = 0.40$，阈值 $\\tau_3 = 400.0$。\n\n需遵守的实现细节：\n- 阅读框：始终使用阅读框 $0$。\n- 窗口长度：$L=1000$，因此从头开始精确计数 $333$ 个密码子，并忽略任何剩余的末尾核苷酸。\n- 对于任何内部数据结构，密码子的排序可按字典序进行，即在每个位置上 $\\text{A}  \\text{C}  \\text{G}  \\text{T}$。\n- 所有似然计算必须使用自然对数。\n- 您的构建必须确保在这 $333$ 个密码子中，框内密码子 $\\text{ATG}$ 永不出现（非编码代理约束）。\n- 终止密码子为 $\\{\\text{TAA}, \\text{TAG}, \\text{TGA}\\}$。\n\n要求的程序输出：\n- 对于上述列出的三个背景案例，评估您构建的单一序列是否在满足非编码约束的同时被错误地分类为基因。对于每个案例 $k \\in \\{1,2,3\\}$，输出一个布尔值，当且仅当以下两个条件同时成立时该值为真：(i) 针对背景 $\\mathbf{Q}_k$ 计算的 LLR 超过 $\\tau_k$，以及 (ii) 阅读框 $0$ 的密码子列表中不包含 $\\text{ATG}$。\n- 您的程序应生成单行输出，其中包含以方括号括起来的逗号分隔列表形式的结果（例如，\"[True,False,True]\"）。\n\n您的解决方案必须是一个完整的、可运行的程序，该程序执行构建和指定的三项评估，并精确地按要求格式打印一行。", "solution": "用户提供了一个问题陈述，在尝试解决之前需要进行验证。\n\n### 步骤1：提取给定信息\n- **任务：** 构建一个长度为 $L=1000$ 的单一DNA序列，该序列需满足“非编码”约束，并被三个不同的背景模型的分类器错误地分类为“基因”。\n- **序列属性：**\n    - 长度 $L = 1000$ 个核苷酸。\n    - 在阅读框 $0$ 中使用 $N = \\lfloor L/3 \\rfloor = 333$ 个非重叠密码子。\n    - 非编码约束：不包含框内起始密码子 $\\text{ATG}$。\n- **分类器模型：**\n    - **基因模型 ($\\mathbf{P}$):** 基于单核苷酸权重 $w(\\text{A}) = 0.15$，$w(\\text{C}) = 0.35$，$w(\\text{G}) = 0.35$，$w(\\text{T}) = 0.15$。计算未归一化的密码子权重 $W(\\text{X}_1\\text{X}_2\\text{X}_3) = w(\\text{X}_1)w(\\text{X}_2)w(\\text{X}_3)$。终止密码子 $\\{\\text{TAA}, \\text{TAG}, \\text{TGA}\\}$ 的权重乘以 $s_{\\text{gene}} = 10^{-3}$。将得到的 $64$ 个权重归一化，使其总和为 $1$。\n    - **背景模型 ($\\mathbf{Q}_k$):** 以类似方式从特定的核苷酸权重 $v_k(\\cdot)$ 生成，但终止密码子缩放因子为 $s_{\\text{bg}} = 1$。\n- **分类规则：**\n    - 如果一个序列的对数似然比（LLR）超过阈值 $\\tau$，则将其分类为“基因”。\n    - 对于一个密码子计数为 $\\{n_i\\}_{i=1}^{64}$ 的序列，针对背景模型 $k$ 的 LLR 为 $LLR_k = \\sum_{i=1}^{64} n_i \\log \\frac{P_i}{Q_{i,k}}$。\n- **测试套件：**\n    - **案例 1：** $v_1(\\text{A,C,G,T}) = 0.25$，$\\tau_1 = 60.0$。\n    - **案例 2：** $v_2(\\text{A,T}) = 0.18$，$v_2(\\text{C,G}) = 0.32$，$\\tau_2 = 7.0$。\n    - **案例 3：** $v_3(\\text{A,T}) = 0.40$，$v_3(\\text{C,G}) = 0.10$，$\\tau_3 = 400.0$。\n- **输出要求：** 对于每个案例 $k$，提供一个布尔值，指示所构建的单一序列是否同时满足 LLR$_k  \\tau_k$ 和非编码约束。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估：\n- **科学性：** 问题使用了简化的但标准的内容基因发现的表述，采用了密码子频率、多项式模型和对数似然比等生物信息学的核心概念。将“非编码”规则明确限定为本问题的代理约束，在方法论上是合理的。问题具有科学有效性。\n- **良构性：** 问题要求构建一个满足多个约束的序列。这是一个约束满足或优化问题。可以系统地搜索解决方案，解的存在性决定了结果。目标和约束都经过了数学定义，使得问题成为一个良构问题。\n- **客观性：** 问题通过精确的数值数据、定义和规则进行规定，没有歧义或主观语言。\n\n该问题陈述是自包含的、一致的且科学合理的。它通过了所有验证检查。\n\n### 步骤3：结论与行动\n问题是有效的。将提供一个合理的解决方案。\n\n### 解决方案\n目标是构建一个长度为 $L=1000$ 的单一DNA序列，该序列能同时被三个不同的分类器错误地分类为基因。这要求序列满足非编码约束（无框内 $\\text{ATG}$ 密码子），同时其对数似然比（LLR）在每种背景模型下都超过指定的阈值。\n\n对于包含 $N=333$ 个密码子且各类密码子计数为 $\\{n_i\\}$ 的序列，其 LLR 计算公式为：\n$$LLR_k = \\sum_{i=1}^{64} n_i \\log\\left(\\frac{P_i}{Q_{i,k}}\\right)$$\n其中 $\\mathbf{P}$ 是基因模型概率向量，$\\mathbf{Q}_k$ 是第 $k$ 个背景模型的概率向量。\n\n我们必须找到一组密码子计数 $\\{n_i\\}$，使得 $\\sum n_i = 333$，$n_{\\text{ATG}} = 0$，并且以下三个不等式成立：\n$1$. $LLR_1  \\tau_1 = 60.0$\n$2$. $LLR_2  \\tau_2 = 7.0$\n$3$. $LLR_3  \\tau_3 = 400.0$\n\n为了最大化LLR，我们应优先使用那些对数比率项 $\\log(P_i/Q_{i,k})$ 大且为正的密码子。由于这必须对所有三种情况都成立，一个有效且简单的策略是用单一类型的密码子 $c^*$ 重复 $N=333$ 次来构建序列。这个选择将 LLR 计算简化为：\n$$LLR_k = N \\times \\log\\left(\\frac{P(c^*)}{Q_k(c^*)}\\right)$$\n通过选择一个密码子 $c^* \\neq \\text{ATG}$，即可满足非编码约束。\n\n因此，任务简化为找到一个密码子 $c^* \\neq \\text{ATG}$，它能满足以下三个条件：\n$1$. $333 \\times \\log(P(c^*)/Q_1(c^*))  60.0$\n$2$. $333 \\times \\log(P(c^*)/Q_2(c^*))  7.0$\n$3$. $333 \\times \\log(P(c^*)/Q_3(c^*))  400.0$\n\n算法如下：\n1.  **生成概率模型：** 为四种模型（基因 $\\mathbf{P}$ 和背景 $\\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{Q}_3$）中的每一种，生成相应的 $64$ 元素概率向量。具体做法是：首先根据其组成核苷酸权重的乘积计算每个密码子的未归一化权重，应用适当的终止密码子缩放因子（$\\mathbf{P}$ 为 $s_{\\text{gene}}=10^{-3}$，所有 $\\mathbf{Q}_k$ 为 $s_{\\text{bg}}=1$），然后将 $64$ 个权重归一化，使它们的总和为 $1$。\n2.  **搜索最优密码子：** 遍历除 $\\text{ATG}$ 之外的所有 $63$ 个密码子。对于每个候选密码子，计算如果序列完全由该密码子组成，它将在所有三个测试案例中产生的 LLR。如果找到一个满足所有三个阈值条件的密码子，则选择它作为我们的构建密码子 $c^*$。\n3.  **密码子选择分析：** 基因模型对鸟嘌呤（G）和胞嘧啶（C）有很强的偏好，其权重为 $w(\\text{C})=w(\\text{G})=0.35$。相比之下，背景模型要么是均匀的（案例1：$v_1=0.25$），要么对G/C的偏好较弱（案例2：$v_2(\\text{C,G})=0.32$），要么强烈偏好于G/C之外的碱基（案例3：$v_3(\\text{C,G})=0.10$）。因此，富含GC的密码子，如 $\\text{CGC}$，是 $c^*$ 的绝佳候选者，因为它们在基因模型 $\\mathbf{P}$ 下的概率很高，但在所有三个背景模型 $\\mathbf{Q}_k$ 下的概率相对较低，从而最大化了比率 $P/Q_k$。\n4.  **验证与评估：** 详细计算证实密码子 $\\text{CGC}$ 满足所有条件。\n    - $P(\\text{CGC}) \\approx 0.0437$\n    - $Q_1(\\text{CGC}) = 0.015625$, $Q_2(\\text{CGC}) = 0.032768$, $Q_3(\\text{CGC}) = 0.001$\n    - $LLR_1 = 333 \\times \\log(0.0437/0.015625) \\approx 342.5  60.0$\n    - $LLR_2 = 333 \\times \\log(0.0437/0.032768) \\approx 95.9  7.0$\n    - $LLR_3 = 333 \\times \\log(0.0437/0.001) \\approx 1257.9  400.0$\n由于存在一个有效的构建密码子 $c^*$（例如 $\\text{CGC}$），可以构建一个序列（例如，通过重复 $\\text{CGC}$ $333$ 次并附加一个核苷酸以达到长度 $1000$）。这个单一序列满足非编码约束，并且在所有三种情况下都被错误地分类为基因。因此，每个案例的布尔评估结果都必须为真。\n\n提供的代码通过首先确定一个合适的密码子，然后正式评估由它构建的序列是否满足条件，从而实现了这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a DNA sequence that is misclassified as a gene under three different\n    background models, while adhering to a non-coding constraint, and evaluates the\n    outcomes.\n    \"\"\"\n\n    # Define problem parameters and test cases.\n    L = 1000\n    N_codons = L // 3\n    s_gene = 1e-3\n    s_bg = 1.0\n\n    gene_model_weights = {'A': 0.15, 'C': 0.35, 'G': 0.35, 'T': 0.15}\n\n    test_cases = [\n        {'v': {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}, 'tau': 60.0},\n        {'v': {'A': 0.18, 'C': 0.32, 'G': 0.32, 'T': 0.18}, 'tau': 7.0},\n        {'v': {'A': 0.40, 'C': 0.10, 'G': 0.10, 'T': 0.40}, 'tau': 400.0}\n    ]\n\n    bases = ['A', 'C', 'G', 'T']\n    codons = [b1 + b2 + b3 for b1 in bases for b2 in bases for b3 in bases]\n    stop_codons = {'TAA', 'TAG', 'TGA'}\n    atg_codon = 'ATG'\n    atg_index = codons.index(atg_codon)\n\n    def get_codon_probs(nuc_weights, stop_scale):\n        \"\"\"\n        Generates a 64-element codon probability vector from nucleotide weights.\n        \"\"\"\n        unnorm_w = np.zeros(64)\n        for i, codon in enumerate(codons):\n            w = nuc_weights[codon[0]] * nuc_weights[codon[1]] * nuc_weights[codon[2]]\n            if codon in stop_codons:\n                w *= stop_scale\n            unnorm_w[i] = w\n        # Handle case where sum is zero to avoid division by zero, though not expected here.\n        norm_sum = np.sum(unnorm_w)\n        if norm_sum == 0:\n            return np.full(64, 1/64)\n        return unnorm_w / norm_sum\n\n    # Generate gene and background models.\n    P = get_codon_probs(gene_model_weights, s_gene)\n    background_models = []\n    for case in test_cases:\n        Q = get_codon_probs(case['v'], s_bg)\n        background_models.append({'Q': Q, 'tau': case['tau']})\n\n    # Strategy: Find a single codon to construct the sequence that satisfies all constraints.\n    construction_codon_idx = -1\n    for i in range(len(codons)):\n        if i == atg_index:\n            continue\n\n        # Check if P[i] or any Q[i] is zero to avoid log(0) errors.\n        if P[i] == 0 or any(model['Q'][i] == 0 for model in background_models):\n            continue\n\n        # Check if this codon satisfies all three threshold conditions simultaneously.\n        all_conditions_met = True\n        for model in background_models:\n            llr = N_codons * (np.log(P[i]) - np.log(model['Q'][i]))\n            if llr = model['tau']:\n                all_conditions_met = False\n                break\n        \n        if all_conditions_met:\n            construction_codon_idx = i\n            break\n\n    # Evaluate the constructed sequence against the test cases.\n    # The constructed sequence consists of N_codons repetitions of `construction_codon_idx`.\n    # This sequence by definition satisfies the non-coding constraint.\n    results = []\n    if construction_codon_idx != -1:\n        # A sequence could be constructed, so we evaluate it.\n        for model in background_models:\n            llr = N_codons * (np.log(P[construction_codon_idx]) - np.log(model['Q'][construction_codon_idx]))\n            \n            # Condition 1: LLR exceeds threshold.\n            is_misclassified = llr > model['tau']\n            # Condition 2: No in-frame ATG. This is true by construction.\n            has_no_atg = True\n            \n            results.append(is_misclassified and has_no_atg)\n    else:\n        # No such sequence could be constructed using the single-codon strategy.\n        # This implies failure to satisfy the \"misclassified\" condition for all cases.\n        results = [False, False, False]\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b), results))}]\")\n\nsolve()\n```", "id": "2382027"}]}