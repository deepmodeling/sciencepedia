{"hands_on_practices": [{"introduction": "计算基因发现的第一步是在原始DNA序列中识别出所有可能的开放阅读框（ORF）。这项实践将指导你从头开始编写一个程序来完成这一基本任务。通过这个过程，你将巩固对阅读框、起始密码子、终止密码子以及序列操作等核心概念的理解。[@problem_id:2435536]", "problem": "您的任务是编写一个完整的程序，对一组脱氧核糖核酸 (DNA) 重叠群（contig），识别所有长度（以密码子为单位）超过给定阈值的开放阅读框 (ORF)。此处，一个 ORF 采用标准遗传密码定义，指一个最大的框内区间，该区间始于一个规范的起始密码子，并终止于同一条链下游的第一个框内终止密码子。程序必须搜索每个重叠群的所有六个阅读框（$+1$、$ +2$、$ +3$、$ -1$、$ -2$、$ -3$）。\n\n使用的基本原理和定义：\n- 分子生物学的中心法则：DNA 转录为核糖核酸 (RNA)，再翻译为蛋白质；翻译作用于密码子，密码子是连续的核苷酸三联体。\n- 根据标准遗传密码，存在三种终止密码子：TAA、TAG 和 TGA。规范的起始密码子是 ATG。\n- 一个阅读框由 DNA 链上模 $3$ 的相位偏移所定义。每条链有三个阅读框，因此当同时考虑正向链和反向互补链时，总共有六个阅读框。\n- DNA 字符串的反向互补序列通过反转字符串并互补每个核苷酸（$A \\leftrightarrow T, C \\leftrightarrow G$）来获得，这反映了反向平行、互补的碱基配对原则。\n\n您必须基于以下原则推导算法：\n- 在每条链上，以 $3$ 个核苷酸为步长扫描每个阅读框。每当遇到起始密码子 ATG 时，在同一阅读框中寻找下游的第一个框内终止密码子（TAA、TAG 或 TGA）。如果在重叠群末端之前不存在框内终止密码子，则该起始密码子不会产生可报告的 ORF。\n- 设重叠群长度为 $L$。对于在正向链上发现的 ORF，其起始核苷酸索引为 $s$（ATG 中 A 的索引），终止密码子起始索引为 $t$（终止密码子第一个碱基的索引），则该 ORF 的核苷酸区间为 $[s, t+3)$（一个半开区间）。ORF 的密码子长度（不包括末端的终止密码子）为 $(t - s)/3 - 1$。\n- 对于在反向互补链上发现的 ORF，其反向互补坐标为 $[s_{\\mathrm{rc}}, t_{\\mathrm{rc}}+3)$，使用 $s_{\\mathrm{orig}} = L - (t_{\\mathrm{rc}}+3)$ 和 $t_{\\mathrm{orig}} = L - s_{\\mathrm{rc}}$ 将其映射到原始重叠群坐标。所有情况下都应报告原始重叠群上的坐标。\n- 一个 ORF 当且仅当其密码子长度严格大于给定的阈值 $N$（即，长度 $> N$）时，才被包含在输出中。报告的长度不包括末端的终止密码子。\n\n将每个 ORF 表示为一个包含四个整数的列表 $[f, s, e, \\ell]$，其中：\n- $f$ 是阅读框标识符：$+1$、$ +2$、$ +3$ 分别对应于正向链上偏移量为 $0$、$ 1$、$ 2$ 的阅读框；$-1$、$ -2$、$ -3$ 分别对应于反向互补序列上偏移量为 $0$、$ 1$、$ 2$ 的阅读框。\n- $s$ 是原始重叠群上基于 $0$ 的起始索引（含）。\n- $e$ 是原始重叠群上基于 $0$ 的结束索引（不含），即紧跟在终止密码子之后的索引。\n- $\\ell$ 是 ORF 的密码子长度，不包括末端的终止密码子。\n\n排序规则：对于每个重叠群，按 $s$ 升序、然后按 $e$ 升序、最后按 $f$ 升序对 ORF 进行排序。\n\n假设与约束：\n- 所有重叠群均为大写字符串，由字母表 {A, C, G, T} 构成。不出现模糊符号。\n- 仅使用标准遗传密码，以 ATG 为唯一起始密码子，以 TAA、TAG、TGA 为终止密码子。\n- 坐标必须以原始重叠群上基于 $0$ 的半开区间 $[s,e)$ 的形式报告。\n\n测试套件：\n您的程序必须为以下四个测试用例计算结果。每个测试用例是一个序对 $(\\text{contig}, N)$。\n\n- 测试用例 1（包含正向和反向阅读框的正常路径）：\n  - 重叠群：\"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\"\n  - 阈值 $N = 2$\n- 测试用例 2（边界条件：一个 ORF 的长度恰好为 $N$ 必须被排除，同时存在一个更长的 ORF）：\n  - 重叠群：\"GGGATGAAATAGGGATGCCACCCTAA\"\n  - 阈值 $N = 1$\n- 测试用例 3（边缘情况：序列中无起始密码子）：\n  - 重叠群：\"CCCTTTGGGCCCTAGTAA\"\n  - 阈值 $N = 0$\n- 测试用例 4（边缘情况：有起始密码子但在序列末端前无框内终止密码子；不报告不完整的 ORF）：\n  - 重叠群：\"GGGATGCCCCCCCCGGG\"\n  - 阈值 $N = 0$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。\n- 每个测试用例的结果必须是按规定排序的 ORF 记录列表 $[f,s,e,\\ell]$。顶层输出是这些各测试用例结果列表的列表。\n- 输出不得包含任何空白字符。例如，一个有效的形式是 \"[[...],[...],[],[]]\"。\n\n您的程序必须是自包含的，且不得读取任何输入。它必须计算上述四个测试用例的结果，并打印出所要求的单行内容。", "solution": "所提出的问题是生物信息学中的一个标准练习，具体属于序列分析领域。它要求在给定的脱氧核糖核酸 (DNA) 重叠群中识别开放阅读框 (ORF)。该问题具有科学依据，定义明确，并提供了一套完整的、无歧义的定义和约束。因此，该问题是有效的，可以构建解决方案。\n\n其基本原理是将核苷酸序列翻译成氨基酸序列，这一过程由遗传密码所支配。翻译在特定的阅读框中进行，阅读框是将序列划分为连续、不重叠的核苷酸三联体（称为密码子）的方式。一个 ORF 代表一个潜在的蛋白质编码基因，定义为以起始密码子开始并以同一阅读框中的终止密码子结束的序列。由于 DNA 是具有反向平行链的双链分子，我们必须总共分析六个阅读框：三个在正向链上，三个在反向互补链上。\n\n该算法旨在系统地检查每个给定重叠群的全部六个阅读框。\n\n**步骤 1：链与阅读框的迭代**\n该过程必须应用于正向链及其反向互补链。反向互补序列的生成方式是：首先反转 DNA 序列，然后将每个核苷酸替换为其互补碱基（$A \\leftrightarrow T$, $C \\leftrightarrow G$）。对于每条链，存在三个阅读框，由第一个密码子的起始位置决定。这些阅读框分别从序列的索引 $0$、$1$ 和 $2$ 开始。我们将用阅读框标识符 $+1, +2, +3$ 表示正向链的阅读框，用 $-1, -2, -3$ 表示反向互补链的阅读框。\n\n**步骤 2：在单链上识别 ORF**\n对于给定的链（正向或反向互补）和特定的阅读框（偏移量 $i \\in \\{0, 1, 2\\}$），算法会扫描序列以寻找 ORF。扫描从阅读框的偏移量开始，以密码子为单位（即以 $3$ 个核苷酸为步长）进行。\n\n单个阅读框的处理过程如下：\n1.  以满足 $s \\equiv i \\pmod 3$ 的起始索引 $s$ 遍历序列。\n2.  在每个位置 $s$ 上，检查密码子 `dna[s:s+3]` 是否为规范的起始密码子 `ATG`。\n3.  如果在索引 $s$ 处找到起始密码子，则从位置 $s+3$ 开始进行后续搜索，以找到第一个框内终止密码子（`TAA`、`TAG` 或 `TGA`）。此搜索也以 $3$ 为步长进行。\n4.  如果在索引 $t$ 处找到终止密码子，这就定义了一个 ORF。问题陈述将此 ORF 的密码子长度（不包括终止密码子）定义为 $\\ell = (t-s)/3 - 1$。由于对于框内终止密码子，$(t-s)$ 保证是 $3$ 的倍数，因此可以使用整数除法。\n5.  仅当其长度 $\\ell$ 严格大于给定的阈值 $N$ 时，此 ORF 才被视为可报告的有效 ORF。\n6.  如果在序列末尾之前没有找到框内终止密码子，则索引 $s$ 处的起始密码子不会启动一个完整的 ORF，因此不会为其报告任何信息。\n7.  为寻找下一个起始密码子而进行的扫描会从当前起始密码子紧随其后的位置（即 $s+3$）恢复，以确保找到所有潜在的 ORF。问题将 ORF 定义为“最大的框内区间”，我们将其解释为从一个给定的起始密码子到在该阅读框中遇到的第一个终止密码子之间的区间。\n\n**步骤 3：反向互补链的坐标转换**\n在反向互补链上找到的 ORF，其坐标必须映射回原始正向链的坐标系。设原始重叠群的长度为 $L$。如果在反向互补链上找到一个 ORF，其起始索引为 $s_{rc}$，终止密码子的起始索引为 $t_{rc}$，则其核苷酸区间为 $[s_{rc}, t_{rc}+3)$。原始重叠群上的相应区间由链的反向平行特性推导得出。原始重叠群上的起始坐标为 $s_{orig} = L - (t_{rc}+3)$，不含边界的结束坐标为 $e_{orig} = L - s_{rc}$。\n\n**步骤 4：记录的制定与排序**\n每个有效的 ORF 被记录为一个包含四个整数的列表：$[f, s, e, \\ell]$。在此， $f$ 是阅读框标识符（$+1, +2, +3, -1, -2, -3$），$s$ 是原始重叠群上基于 $0$ 的起始索引，$e$ 是基于 $0$ 的不含边界的结束索引，$\\ell$ 是计算出的密码子长度。在识别出一个重叠群的所有 ORF 后，对结果列表进行排序。指定的排序标准为：主要按起始位置 $s$ 升序，次要按结束位置 $e$ 升序，最后按阅读框标识符 $f$ 升序。\n\n这种结构化的方法确保了对所有六个阅读框进行详尽的搜索，并根据问题的严格要求对所有识别出的 ORF 进行正确的筛选、格式化和排序，从而得出确定且正确的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the ORF finding problem for the predefined test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\", 2),\n        (\"GGGATGAAATAGGGATGCCACCCTAA\", 1),\n        (\"CCCTTTGGGCCCTAGTAA\", 0),\n        (\"GGGATGCCCCCCCCGGG\", 0),\n    ]\n\n    results = []\n    for contig, n_threshold in test_cases:\n        results.append(find_all_orfs(contig, n_threshold))\n\n    # Final print statement in the exact required format.\n    # The string representation of a list includes spaces, which must be removed.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef find_all_orfs(contig, n_threshold):\n    \"\"\"\n    Finds all ORFs in a given contig that are longer than a specified threshold.\n    Searches all six reading frames.\n\n    Args:\n        contig (str): The DNA sequence.\n        n_threshold (int): The minimum number of codons (exclusive of stop)\n                           for an ORF to be reported. Length must be > threshold.\n    \n    Returns:\n        list: A sorted list of ORF records. Each record is [frame, start, end, length].\n    \"\"\"\n    stop_codons = {\"TAA\", \"TAG\", \"TGA\"}\n    start_codon = \"ATG\"\n    all_orfs = []\n    L = len(contig)\n\n    # Process forward strand (+1, +2, +3 frames)\n    for offset in range(3):\n        frame_id = offset + 1\n        # Iterate through the sequence in steps of 3 for the current frame\n        for s in range(offset, L - 5, 3):\n            if contig[s:s+3] == start_codon:\n                # Found a start codon, now search for the first in-frame stop codon\n                for t in range(s + 3, L - 2, 3):\n                    if contig[t:t+3] in stop_codons:\n                        # ORF found, calculate length and check against threshold\n                        length = (t - s) // 3 - 1\n                        if length > n_threshold:\n                            e = t + 3\n                            all_orfs.append([frame_id, s, e, length])\n                        # Break inner loop as we only care about the first stop\n                        break\n\n    # Process reverse-complement strand (-1, -2, -3 frames)\n    # The translation map for complementing DNA\n    complement_map = str.maketrans(\"ATCG\", \"TAGC\")\n    rc_contig = contig.translate(complement_map)[::-1]\n    \n    for offset in range(3):\n        frame_id = -(offset + 1)\n        for s_rc in range(offset, L - 5, 3):\n            if rc_contig[s_rc:s_rc+3] == start_codon:\n                for t_rc in range(s_rc + 3, L - 2, 3):\n                    if rc_contig[t_rc:t_rc+3] in stop_codons:\n                        length = (t_rc - s_rc) // 3 - 1\n                        if length > n_threshold:\n                            # Map coordinates from reverse-complement to original\n                            s_orig = L - (t_rc + 3)\n                            e_orig = L - s_rc\n                            all_orfs.append([frame_id, s_orig, e_orig, length])\n                        break\n\n    # Sort the collected ORFs according to the specified rule: s, then e, then f\n    # In the list [f, s, e, l], these correspond to indices 0, 1, 2\n    all_orfs.sort(key=lambda orf: (orf[1], orf[2], orf[0]))\n\n    return all_orfs\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2435536"}, {"introduction": "仅仅识别出所有ORF是不够的，因为随机序列中也可能偶然出现ORF。为了区分真正的基因，我们可以利用密码子使用偏好等生物学信号。这项练习引入了密码子适应指数（CAI）这一重要指标，并要求你实现它来对候选ORF进行评分和排序，从而将你的技能从简单的识别提升到定量的评估。[@problem_id:2410622]", "problem": "给定一个由字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 组成的脱氧核糖核酸 (DNA) 字符串和一组参数。在某个链和读框上，一个候选的开放阅读框 (ORF) 被定义为任何以规范起始密码子 $\\text{ATG}$ 开始，并在同一链和读框上遇到的第一个框内终止密码子（$\\{\\text{TAA},\\text{TAG},\\text{TGA}\\}$ 之一）处结束的最大子串。该 ORF 的有义密码子序列是指从起始密码子（含）到终止密码子（不含）之间的密码子列表（也就是说，终止密码子不包括在有义密码子列表中）。对于长度为 $N$ 的 DNA，您必须考虑所有六个阅读框：正向链上的三个读框（偏移量为 $0, 1, 2$，对应于读框 $+1, +2, +3$）和反向互补链上的三个读框（反向互补链上的偏移量为 $0, 1, 2$，对应于读框 $-1, -2, -3$）。对于反向互补链上由反向互补坐标中的半开区间 $[s',e')$ 定义的任何 ORF，其在正向链坐标系中的半开区间为 $[N-e',\\,N-s')$。\n\n对于任何长度为 $n \\ge 1$ 的有义密码子序列 $(c_1,c_2,\\ldots,c_n)$，密码子适应指数 (CAI) 定义为\n$$\n\\mathrm{CAI}(c_1,\\ldots,c_n)\\;=\\;\\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n}\n$$\n其中 $w(c)$ 是与密码子 $c$ 关联的非负权重，该权重源自一个固定的同义密码子偏好性参考集。对于本问题，您必须使用以下固定的密码子权重函数 $w(\\cdot)$（仅适用于有义密码子；终止密码子从不用于乘积计算）：\n- 丙氨酸 (Alanine): $w(\\text{GCT})=1.0$, $w(\\text{GCC})=0.9$, $w(\\text{GCA})=0.8$, $w(\\text{GCG})=0.7$。\n- 缬氨酸 (Valine): $w(\\text{GTT})=1.0$, $w(\\text{GTC})=0.9$, $w(\\text{GTA})=0.7$, $w(\\text{GTG})=0.6$。\n- 甘氨酸 (Glycine): $w(\\text{GGT})=1.0$, $w(\\text{GGC})=0.8$, $w(\\text{GGA})=0.7$, $w(\\text{GGG})=0.6$。\n- 脯氨酸 (Proline): $w(\\text{CCT})=1.0$, $w(\\text{CCC})=0.9$, $w(\\text{CCA})=0.8$, $w(\\text{CCG})=0.7$。\n- 苏氨酸 (Threonine): $w(\\text{ACT})=1.0$, $w(\\text{ACC})=0.9$, $w(\\text{ACA})=0.8$, $w(\\text{ACG})=0.7$。\n- 赖氨酸 (Lysine): $w(\\text{AAA})=1.0$, $w(\\text{AAG})=0.6$。\n- 谷氨酸 (Glutamate): $w(\\text{GAA})=1.0$, $w(\\text{GAG})=0.5$。\n- 精氨酸 (Arginine): $w(\\text{CGT})=1.0$, $w(\\text{CGC})=0.9$, $w(\\text{CGA})=0.6$, $w(\\text{CGG})=0.6$, $w(\\text{AGA})=0.5$, $w(\\text{AGG})=0.5$。\n- 苯丙氨酸 (Phenylalanine): $w(\\text{TTC})=1.0$, $w(\\text{TTT})=0.8$。\n- 异亮氨酸 (Isoleucine): $w(\\text{ATT})=1.0$, $w(\\text{ATC})=0.9$, $w(\\text{ATA})=0.5$。\n- 亮氨酸 (Leucine): $w(\\text{CTG})=1.0$, $w(\\text{CTT})=0.8$, $w(\\text{CTC})=0.7$, $w(\\text{CTA})=0.5$, $w(\\text{TTG})=0.6$, $w(\\text{TTA})=0.4$。\n- 丝氨酸 (Serine): $w(\\text{TCT})=1.0$, $w(\\text{TCC})=0.9$, $w(\\text{TCA})=0.8$, $w(\\text{TCG})=0.7$, $w(\\text{AGT})=0.6$, $w(\\text{AGC})=0.6$。\n- 天冬酰胺 (Asparagine): $w(\\text{AAT})=1.0$, $w(\\text{AAC})=0.9$。\n- 天冬氨酸 (Aspartate): $w(\\text{GAT})=1.0$, $w(\\text{GAC})=0.9$。\n- 谷氨酰胺 (Glutamine): $w(\\text{CAA})=1.0$, $w(\\text{CAG})=0.8$。\n- 组氨酸 (Histidine): $w(\\text{CAT})=1.0$, $w(\\text{CAC})=0.9$。\n- 酪氨酸 (Tyrosine): $w(\\text{TAC})=1.0$, $w(\\text{TAT})=0.9$。\n- 半胱氨酸 (Cysteine): $w(\\text{TGC})=1.0$, $w(\\text{TGT})=0.9$。\n- 甲硫氨酸 (Methionine): $w(\\text{ATG})=1.0$。\n- 色氨酸 (Tryptophan): $w(\\text{TGG})=1.0$。\n\n如果一个 ORF 中的任何有义密码子在上述列表中没有定义的权重，则该 ORF 被视为不合格，必须丢弃。定义 ORF 的有义密码子长度为 $n$，即不包括终止密码子的有义密码子数量。一个 ORF 是可接受的，当且仅当 $n \\ge L_{\\min}$，其中 $L_{\\min}$ 是以密码子为单位的给定最小长度阈值。\n\n您的程序必须对每个测试用例，枚举所有六个读框中的所有可接受 ORF，计算它们的 $\\mathrm{CAI}$，并按顺序应用以下确定性平局决胜规则来选择单个“最佳”ORF：\n- 最高的 $\\mathrm{CAI}$ 值。\n- 若平局，则取最大的有义密码子长度 $n$。\n- 若仍平局，则取最小的正向链起始坐标 $s$（从零开始计数）。\n- 若仍平局，则根据顺序 $+1 \\prec +2 \\prec +3 \\prec -1 \\prec -2 \\prec -3$ 取最小的读框排序。\n\n对于选定的 ORF，报告：\n- 读框，为 $\\{+1,+2,+3,-1,-2,-3\\}$ 中的一个整数，\n- ORF 在核苷酸单位下的半开区间 $[s,e)$ 的正向链起始坐标 $s$（从零开始计数），\n- 同一区间的正向链结束坐标 $e$（不包含），\n- $\\mathrm{CAI}$ 值，四舍五入到小数点后恰好 $4$ 位。\n\n如果在某个测试用例中不存在可接受的 ORF，则对该用例输出整数 $-1$。\n\n测试套件：\n为您的程序提供以下测试用例，每个用例为一对 $(\\text{DNA}, L_{\\min})$，其中 $L_{\\min}$ 的单位是密码子：\n- 用例 1：$(\\text{ATGGCTGTTGGTCCTACTAAAGAACGTTTCATTTAAGCCGCCGCCATGGCGGTGGGGCCGACGAAGGAGCGGTTTATCTAG}, L_{\\min}=8)$\n- 用例 2：$(\\text{TTAAGGACCAACAGCCATATGAAATGA}, L_{\\min}=5)$\n- 用例 3：$(\\text{GGGGCCCCAAAATTTT}, L_{\\min}=3)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个用例的结果，结果是用逗号分隔的列表，并用方括号括起来。每个结果要么是整数 $-1$，要么是包含四个元素的列表 $[\\text{frame}, s, e, \\mathrm{CAI}]$，其中 $\\mathrm{CAI}$ 显示为小数点后恰好 $4$ 位。例如，一个语法上有效的输出看起来像这样：$[[1,0,90,0.7123],[-2,5,41,0.6431],-1]$。不应打印任何额外的空白或文本。", "solution": "用户提供了一个计算生物学问题，要求根据一系列标准在给定的 DNA 序列中找到最优的开放阅读框 (ORF)。解决这个问题的步骤如下：问题陈述的验证、算法的开发和实现。\n\n### 问题验证\n\n已根据指定标准对问题陈述进行评估：\n1.  **已知条件提取**：所有数据和定义均已提取。这包括 DNA 字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$、起始密码子 $\\text{ATG}$、终止密码子 $\\{\\text{TAA},\\text{TAG},\\text{TGA}\\}$、六个阅读框（三个正向，三个反向互补）、反向链的坐标映射、密码子适应指数 (CAI) 的公式、一个包含全部 $61$ 个密码子权重的完整表格、可接受 ORF 的定义（$n \\ge L_{\\min}$）以及用于选择最佳 ORF 的确定性平局决胜规则。\n2.  **科学依据**：该问题在分子生物学和计算生物学的既定原理上基础扎实。ORF 查找、六框翻译、起始/终止密码子以及 CAI 都是标准概念。该问题在科学上是合理的。\n3.  **适定性与客观性**：该问题是适定的。所有术语都经过了数学上的精确定义。目标函数 (CAI) 和平局决胜规则明确无误，确保存在唯一解。语言客观，没有主观性陈述。\n4.  **完整性与一致性**：该问题是自包含的，提供了所有必要信息。提供的密码子权重列表涵盖了所有 $61$ 个有义密码子，使系统完整。定义或约束中没有矛盾。\n\n**结论**：问题有效。可以构建一个合理的解决方案。\n\n### 算法解决方案\n\n任务的核心是系统地枚举所有六个阅读框中的所有可接受 ORF，计算它们的属性，然后根据多级排序标准选择最佳的一个。\n\n**1. 六框翻译与 ORF 识别**\n\n长度为 $N$ 的 DNA 序列有六个阅读框。三个在正向链上，三个在反向互补链上。\n-   **正向读框 (+1, +2, +3)**：这些对应于分别从偏移量 $0, 1, 2$ 开始读取 DNA 序列。\n-   **反向读框 (-1, -2, -3)**：这些对应于读取 DNA 序列的反向互补链，同样具有偏移量 $0, 1, 2$。这些读框表示为 $-1, -2, -3$。\n\n对于六个读框中的每一个，我们必须识别所有候选 ORF。候选 ORF 是一个以密码子 $\\text{ATG}$ 开始并以第一个框内终止密码子（$\\text{TAA}$, $\\text{TAG}$, 或 $\\text{TGA}$）结束的最大序列。这意味着，对于给定读框中每一次出现的 $\\text{ATG}$ 密码子，我们必须在同一读框中向下游扫描以找到第一个终止密码子。这个过程必须对找到的每一个 $\\text{ATG}$ 重复进行，因为 ORF 可能是嵌套的。\n\n**2. ORF 可接受性与属性计算**\n\n对于找到的每个候选 ORF，我们确定其属性：\n-   **有义密码子序列与长度 ($n$)**：这是从 $\\text{ATG}$ 开始到终止密码子（不含）的密码子序列。其长度 $n$ 是这些密码子的数量。如果一个 ORF 的有义密码子长度 $n$ 大于或等于给定的最小阈值 $L_{\\min}$，则该 ORF 被视为**可接受的**。\n-   **密码子适应指数 (CAI)**：对于一个有义密码子为 $(c_1, c_2, \\ldots, c_n)$ 的可接受 ORF，其 CAI 是其权重 $w(c_i)$ 的几何平均值：\n    $$\n    \\mathrm{CAI} = \\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n}\n    $$\n    为了确保数值稳定性，特别是对于长 ORF，其权重的乘积可能导致浮点数下溢，计算上最好使用对数：\n    $$\n    \\ln(\\mathrm{CAI}) = \\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i)) \\implies \\mathrm{CAI} = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i))\\right)\n    $$\n-   **坐标与读框**：ORF 的起始 ($s$) 和结束 ($e$) 坐标必须以正向链、从零开始的坐标系报告。对于正向链上从索引 $s_{fwd}$ 开始并以索引 $j_{fwd}$ 处的终止密码子结束的 ORF，其区间为 $[s, e) = [s_{fwd}, j_{fwd}+3)$。对于在反向互补序列上找到的区间为 $[s', e')$ 的 ORF，其在正向链上的坐标由转换 $[s, e) = [N-e', N-s')$ 给出。读框是 $\\{+1, +2, +3, -1, -2, -3\\}$ 中的一个。\n\n**3. 最佳 ORF 的选择**\n\n收集来自所有六个读框的所有可接受 ORF。如果没有找到可接受的 ORF，则该测试用例的处理终止，结果为 $-1$。否则，使用指定的平局决胜层次结构对收集到的 ORF 进行排序，以找到唯一的最佳 ORF：\n1.  **最高 CAI 值**：按 CAI 降序排序。\n2.  **最大有义密码子长度 $n$**：若 CAI 相同，则按 $n$ 降序排序。\n3.  **最小正向链起始坐标 $s$**：若仍平局，则按 $s$ 升序排序。\n4.  **最小读框排序**：作为最终的平局决胜规则，按指定的顺序排序：$+1 \\prec +2 \\prec +3 \\prec -1 \\prec -2 \\prec -3$。这可以通过将读框映射到整数排名 $\\{+1:0, +2:1, \\ldots, -3:5\\}$ 并按排名的升序排序来实现。\n\n经过此多级排序后排在第一位的 ORF 即为“最佳” ORF。然后报告其属性（读框、 $s$、 $e$ 和四舍五入到四位小数的 CAI）。这个系统化的程序保证了能够按照问题陈述的定义，识别出唯一的、最优的 ORF。", "answer": "```python\nimport numpy as np\nimport math\n\n# Fixed parameters and definitions from the problem statement\nCODON_WEIGHTS = {\n    'GCT': 1.0, 'GCC': 0.9, 'GCA': 0.8, 'GCG': 0.7,  # Alanine\n    'GTT': 1.0, 'GTC': 0.9, 'GTA': 0.7, 'GTG': 0.6,  # Valine\n    'GGT': 1.0, 'GGC': 0.8, 'GGA': 0.7, 'GGG': 0.6,  # Glycine\n    'CCT': 1.0, 'CCC': 0.9, 'CCA': 0.8, 'CCG': 0.7,  # Proline\n    'ACT': 1.0, 'ACC': 0.9, 'ACA': 0.8, 'ACG': 0.7,  # Threonine\n    'AAA': 1.0, 'AAG': 0.6,                           # Lysine\n    'GAA': 1.0, 'GAG': 0.5,                           # Glutamate\n    'CGT': 1.0, 'CGC': 0.9, 'CGA': 0.6, 'CGG': 0.6, 'AGA': 0.5, 'AGG': 0.5,  # Arginine\n    'TTC': 1.0, 'TTT': 0.8,                           # Phenylalanine\n    'ATT': 1.0, 'ATC': 0.9, 'ATA': 0.5,               # Isoleucine\n    'CTG': 1.0, 'CTT': 0.8, 'CTC': 0.7, 'CTA': 0.5, 'TTG': 0.6, 'TTA': 0.4,  # Leucine\n    'TCT': 1.0, 'TCC': 0.9, 'TCA': 0.8, 'TCG': 0.7, 'AGT': 0.6, 'AGC': 0.6,  # Serine\n    'AAT': 1.0, 'AAC': 0.9,                           # Asparagine\n    'GAT': 1.0, 'GAC': 0.9,                           # Aspartate\n    'CAA': 1.0, 'CAG': 0.8,                           # Glutamine\n    'CAT': 1.0, 'CAC': 0.9,                           # Histidine\n    'TAC': 1.0, 'TAT': 0.9,                           # Tyrosine\n    'TGC': 1.0, 'TGT': 0.9,                           # Cysteine\n    'ATG': 1.0,                                       # Methionine\n    'TGG': 1.0,                                       # Tryptophan\n}\nSTART_CODON = 'ATG'\nSTOP_CODONS = {'TAA', 'TAG', 'TGA'}\nFRAME_RANKS = {1: 0, 2: 1, 3: 2, -1: 3, -2: 4, -3: 5}\nCOMPLEMENT_DNA = str.maketrans('ATCG', 'TAGC')\n\ndef get_reverse_complement(dna_seq):\n    \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n    return dna_seq.translate(COMPLEMENT_DNA)[::-1]\n\ndef process_case(dna_seq, L_min):\n    \"\"\"Finds the best ORF for a given DNA sequence and minimum length.\"\"\"\n    admissible_orfs = []\n    N = len(dna_seq)\n\n    # Process both forward and reverse-complement strands\n    for strand_type in ['forward', 'reverse']:\n        seq = dna_seq if strand_type == 'forward' else get_reverse_complement(dna_seq)\n        \n        # Iterate through the three reading frames for the current strand\n        for frame_offset in range(3):\n            # Scan for all potential start codons within the current frame\n            for i in range(frame_offset, len(seq) - 2, 3):\n                if seq[i:i+3] == START_CODON:\n                    start_pos_in_strand = i\n                    sense_codons = []\n                    \n                    # Find the first in-frame stop codon after the start\n                    for j in range(start_pos_in_strand, len(seq) - 2, 3):\n                        codon = seq[j:j+3]\n                        if codon in STOP_CODONS:\n                            # ORF is defined, check for admissibility\n                            n = len(sense_codons)\n                            if n >= L_min:\n                                # Calculate CAI using logarithms for numerical stability\n                                weights = [CODON_WEIGHTS[c] for c in sense_codons]\n                                if 0 in weights:\n                                    cai = 0.0\n                                else:\n                                    cai = np.exp(np.mean(np.log(weights)))\n                                \n                                # Determine frame number and forward-strand coordinates\n                                if strand_type == 'forward':\n                                    frame = frame_offset + 1\n                                    s = start_pos_in_strand\n                                    e = j + 3\n                                else:  # reverse strand\n                                    frame = -(frame_offset + 1)\n                                    s_prime = start_pos_in_strand\n                                    e_prime = j + 3\n                                    s = N - e_prime\n                                    e = N - s_prime\n                                \n                                frame_rank = FRAME_RANKS[frame]\n                                \n                                admissible_orfs.append({\n                                    'cai': cai, 'n': n, 's': s,\n                                    'frame_rank': frame_rank, 'frame': frame, 'e': e\n                                })\n                            \n                            # Break inner loop since we found the first stop codon\n                            break\n                        \n                        sense_codons.append(codon)\n\n    if not admissible_orfs:\n        return -1\n\n    # Sort ORFs based on the specified tie-breaking rules\n    admissible_orfs.sort(key=lambda o: (-o['cai'], -o['n'], o['s'], o['frame_rank']))\n    \n    best_orf = admissible_orfs[0]\n    return [best_orf['frame'], best_orf['s'], best_orf['e'], best_orf['cai']]\n\ndef to_string_repr(item):\n    \"\"\"Formats an ORF result list or integer into the required string format.\"\"\"\n    if isinstance(item, int):\n        return str(item)\n    frame, s, e, cai = item\n    return f\"[{frame},{s},{e},{cai:.4f}]\"\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        (\n            \"ATGGCTGTTGGTCCTACTAAAGAACGTTTCATTTAA\" + \n            \"GCCGCCGCC\" +\n            \"ATGGCGGTGGGGCCGACGAAGGAGCGGTTTATCTAG\",\n            8\n        ),\n        (\n            \"TTAAGGACCAACAGCCATATGAAATGA\",\n            5\n        ),\n        (\n            \"GGGGCCCCAAAATTTT\",\n            3\n        ),\n    ]\n\n    results = [process_case(dna, l_min) for dna, l_min in test_cases]\n    output_strings = [to_string_repr(res) for res in results]\n    \n    print(f\"[{','.join(output_strings)}]\")\n\nsolve()\n```", "id": "2410622"}, {"introduction": "现在，让我们进入一个更高级的领域：机器学习。现代基因预测工具会综合多种证据（即特征）来做出判断。这项实践提供了一个简化但功能强大的示例，你将基于ORF的长度、GC含量和密码子偏好等特征，构建一个分类器来区分真正的基因和非编码ORF。[@problem_id:2410602]", "problem": "给定候选开放阅读框（ORF）的标记数据，以判断每个 ORF 是否为真实的蛋白质编码基因。每个候选 ORF 由一个特征向量 $x \\in \\mathbb{R}^3$ 表示，其坐标顺序为 $x = (L, G, C)$，其中 $L$ 是以核苷酸为单位的 ORF 长度（单位：核苷酸），$G$ 是鸟嘌呤-胞嘧啶（GC）含量，表示为 $[0,1]$ 区间内的小数（无单位），而 $C$ 是密码子使用偏好性得分，表示为 $[0,1]$ 区间内的小数（无单位），例如密码子适应指数（CAI）。目标标签 $y \\in \\{0,1\\}$ 表示该 ORF 是否被认为是真实基因（$y=1$）或不是（$y=0$）。\n\n您的任务是使用下方的训练集，学习一个确定性二元分类器，该分类器仅基于训练数据和问题的数学结构，将任何特征向量 $x$ 映射到一个预测标签 $\\hat{y} \\in \\{0,1\\}$。然后，您必须将学习到的分类器应用于提供的测试集，并以指定的精确格式输出所有测试用例的预测标签。\n\n包含 $16$ 个带标签样本 $(x_i, y_i)$ 的训练集：\n- $((900,\\,0.50,\\,0.82),\\,1)$\n- $((1200,\\,0.55,\\,0.88),\\,1)$\n- $((1500,\\,0.60,\\,0.92),\\,1)$\n- $((750,\\,0.48,\\,0.75),\\,1)$\n- $((1000,\\,0.40,\\,0.80),\\,1)$\n- $((1800,\\,0.65,\\,0.85),\\,1)$\n- $((600,\\,0.52,\\,0.86),\\,1)$\n- $((90,\\,0.45,\\,0.30),\\,0)$\n- $((150,\\,0.70,\\,0.28),\\,0)$\n- $((210,\\,0.35,\\,0.33),\\,0)$\n- $((300,\\,0.50,\\,0.40),\\,0)$\n- $((240,\\,0.62,\\,0.36),\\,0)$\n- $((420,\\,0.55,\\,0.38),\\,0)$\n- $((900,\\,0.55,\\,0.34),\\,0)$\n- $((360,\\,0.42,\\,0.45),\\,0)$\n- $((120,\\,0.60,\\,0.60),\\,0)$\n\n包含 $8$ 个待分类的无标签样本 $x_j$ 的测试集：\n- $(1200,\\,0.65,\\,0.90)$\n- $(90,\\,0.45,\\,0.31)$\n- $(1500,\\,0.42,\\,0.35)$\n- $(300,\\,0.50,\\,0.50)$\n- $(1800,\\,0.30,\\,0.70)$\n- $(450,\\,0.60,\\,0.62)$\n- $(720,\\,0.50,\\,0.80)$\n- $(960,\\,0.58,\\,0.55)$\n\n所有 GC 含量和密码子使用偏好性值必须视为小数（例如，对于 $50$ 百分比，使用 $0.50$）。ORF 长度必须以核苷酸为单位。不提供其他输入。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含 $8$ 个测试用例的预测标签，格式为逗号分隔的整数列表，并用方括号括起，无空格。例如，包含八个预测的输出必须具有 $[a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8]$ 的确切形式，其中每个 $a_j \\in \\{0,1\\}$。\n\n设计要求：\n- 学习到的分类器必须完全由给定的训练数据确定，并且必须是确定性的。\n- 解决方案必须基于数学规范，能够通用地实现，且不依赖于任何特定的编程语言。\n- 除了将长度视为核苷酸单位，并将另外两个特征视为无单位的分数外，没有需要转换的物理单位。\n- 每个测试用例的答案是 $\\{0,1\\}$ 中的一个整数，最终输出将这些答案聚合成如上所述的单个列表。", "solution": "首先将对所提供的问题进行科学性和逻辑完整性验证。\n\n步骤 1：提取给定信息\n问题提供了以下信息：\n- 特征向量：$x \\in \\mathbb{R}^3$，坐标为 $x = (L, G, C)$。\n- $L$：ORF 长度，单位为核苷酸。\n- $G$：鸟嘌呤-胞嘧啶（GC）含量，一个在 $[0,1]$ 区间内的无单位分数。\n- $C$：密码子使用偏好性得分，一个在 $[0,1]$ 区间内的无单位分数。\n- 目标标签：$y \\in \\{0,1\\}$，其中 $y=1$ 表示真实基因，$y=0$ 表示非真实基因。\n- 一个包含 $16$ 个带标签样本 $(x_i, y_i)$ 的训练集：\n  - 对于 $y=1$：$((900,0.50,0.82),1)$, $((1200,0.55,0.88),1)$, $((1500,0.60,0.92),1)$, $((750,0.48,0.75),1)$, $((1000,0.40,0.80),1)$, $((1800,0.65,0.85),1)$, $((600,0.52,0.86),1)$。\n  - 对于 $y=0$：$((90,0.45,0.30),0)$, $((150,0.70,0.28),0)$, $((210,0.35,0.33),0)$, $((300,0.50,0.40),0)$, $((240,0.62,0.36),0)$, $((420,0.55,0.38),0)$, $((900,0.55,0.34),0)$, $((360,0.42,0.45),0)$, $((120,0.60,0.60),0)$。\n- 一个包含 $8$ 个待分类的无标签样本 $x_j$ 的测试集：$(1200,0.65,0.90)$, $(90,0.45,0.31)$, $(1500,0.42,0.35)$, $(300,0.50,0.50)$, $(1800,0.30,0.70)$, $(450,0.60,0.62)$, $(720,0.50,0.80)$, $(960,0.58,0.55)$。\n- 设计要求：分类器必须是确定性的，并且完全由所提供的训练数据和问题的数学结构决定。\n\n步骤 2：使用提取的给定信息进行验证\n根据所需标准评估该问题。\n- **科学依据**：该问题描述了生物信息学中一个标准的二元分类任务——区分蛋白质编码的开放阅读框（ORF）和非编码的开放阅读框。所使用的特征——长度（$L$）、GC 含量（$G$）和密码子使用偏好性（$C$）——是用于此目的的经典且广泛应用的特征。为这些特征提供的数值在现实的生物学范围内。该问题具有科学合理性。\n- **适定性**：该问题提供了一个完整的训练数据集和一个测试数据集，目标明确。分类器必须“完全由给定的训练数据和数学结构确定”这一约束指导了模型的选择。这意味着应使用一个简单、经典的、其参数可从数据中唯一推导出的模型，而不是任意选择一个具有可调超参数的复杂模型。这种结构引导问题走向一个唯一的解决方案，例如一个基于线性可分性的方案。\n- **客观性**：该问题使用精确的数值数据以及对特征和标签的清晰、明确的定义来陈述。它不含主观性语言。\n\n该问题未违反任何无效性标准。它是一个定义明确、自成体系且具有科学相关性的分类问题。\n\n步骤 3：结论与行动\n该问题是**有效的**。将构建一个解决方案。\n\n解决方案：\n任务是基于所提供的训练数据，为 ORF 分类构建一个确定性二元分类器 $\\hat{y} = f(x)$。特征空间是三维的，由长度（$L$）、GC 含量（$G$）和密码子使用偏好性（$C$）构成。在连续特征空间中，最基本的分类方法是找到一个分离超平面。线性分类器的形式为 $\\text{sign}(\\mathbf{w} \\cdot \\mathbf{x} + b)$，其中 $\\mathbf{w}$ 是一个权重向量，$b$ 是一个偏置项。\n\n要求分类器“完全由…数学结构确定”的指令表明，我们应该寻找与训练数据一致的最简单的决策规则。我们首先检查两类样本中每个特征的分布情况。\n\n设 $S_1$ 为标签 $y=1$ 的训练样本集， $S_0$ 为标签 $y=0$ 的训练样本集。\n\n1. ORF 长度（$L$）分析：\n- 对于 $y=1$：$L \\in \\{600, 750, 900, 1000, 1200, 1500, 1800\\}$。范围是 $[600, 1800]$。\n- 对于 $y=0$：$L \\in \\{90, 120, 150, 210, 240, 300, 360, 420, 900\\}$。范围是 $[90, 900]$。\n$L$ 的范围重叠。例如，$L=900$ 这个值在两类中都出现了。因此，仅凭对 $L$ 设置一个简单的阈值无法完美地区分这两类。\n\n2. GC 含量（$G$）分析：\n- 对于 $y=1$：$G \\in \\{0.40, 0.48, 0.50, 0.52, 0.55, 0.60, 0.65\\}$。范围是 $[0.40, 0.65]$。\n- 对于 $y=0$：$G \\in \\{0.35, 0.42, 0.45, 0.50, 0.55, 0.60, 0.62, 0.70\\}$。范围是 $[0.35, 0.70]$。\n$G$ 的范围也显示出显著的重叠。仅凭对 $G$ 设置一个简单的阈值是不够的。\n\n3. 密码子使用偏好性（$C$）分析：\n- 对于 $y=1$：$C \\in \\{0.75, 0.80, 0.82, 0.85, 0.86, 0.88, 0.92\\}$。范围是 $[0.75, 0.92]$。\n- 对于 $y=0$：$C \\in \\{0.28, 0.30, 0.33, 0.34, 0.36, 0.38, 0.40, 0.45, 0.60\\}$。范围是 $[0.28, 0.60]$。\n特征 $C$ 的范围是不相交的。所有 $y=1$ 的样本都有 $C \\ge 0.75$，而所有 $y=0$ 的样本都有 $C \\le 0.60$。这意味着训练数据仅沿 $C$ 轴就是线性可分的。\n\n特征 $C$ 在区间 $(0.60, 0.75)$ 上存在一个分离间隙。这一观察结果允许我们构建一个简单而强大的确定性分类器。最稳健的单特征分类器将决策边界置于分离间隙的中点。对于沿单个坐标轴可分的数据，此选择等同于硬间隔支持向量机（SVM）产生的解。支持向量将是 $S_0$ 中具有最大 $C$ 值的实例和 $S_1$ 中具有最小 $C$ 值的实例。\n- $y=0$ 的最大 $C$ 值：$C_{\\max,0} = 0.60$。\n- $y=1$ 的最小 $C$ 值：$C_{\\min,1} = 0.75$。\n\n因此，决策阈值 $T$ 被唯一地确定为此间隙的中点：\n$$T = \\frac{C_{\\max,0} + C_{\\min,1}}{2} = \\frac{0.60 + 0.75}{2} = \\frac{1.35}{2} = 0.675$$\n\n由此产生的分类规则是：\n对于给定的特征向量 $x=(L, G, C)$，预测标签 $\\hat{y}$ 为：\n$$ \\hat{y} = \\begin{cases} 1 & \\text{if } C > 0.675 \\\\ 0 & \\text{if } C \\le 0.675 \\end{cases} $$\n该分类器是确定性的，其构建仅使用了训练数据，并且基于为线性可分问题寻找最大间隔分离器的基本数学原理。\n\n现在我们将这个学习到的分类器应用于提供的测试集。\n\n1.  $x_1 = (1200, 0.65, 0.90)$：$C = 0.90$。由于 $0.90 > 0.675$，因此 $\\hat{y}_1 = 1$。\n2.  $x_2 = (90, 0.45, 0.31)$：$C = 0.31$。由于 $0.31 \\le 0.675$，因此 $\\hat{y}_2 = 0$。\n3.  $x_3 = (1500, 0.42, 0.35)$：$C = 0.35$。由于 $0.35 \\le 0.675$，因此 $\\hat{y}_3 = 0$。\n4.  $x_4 = (300, 0.50, 0.50)$：$C = 0.50$。由于 $0.50 \\le 0.675$，因此 $\\hat{y}_4 = 0$。\n5.  $x_5 = (1800, 0.30, 0.70)$：$C = 0.70$。由于 $0.70 > 0.675$，因此 $\\hat{y}_5 = 1$。\n6.  $x_6 = (450, 0.60, 0.62)$：$C = 0.62$。由于 $0.62 \\le 0.675$，因此 $\\hat{y}_6 = 0$。\n7.  $x_7 = (720, 0.50, 0.80)$：$C = 0.80$。由于 $0.80 > 0.675$，因此 $\\hat{y}_7 = 1$。\n8.  $x_8 = (960, 0.58, 0.55)$：$C = 0.55$。由于 $0.55 \\le 0.675$，因此 $\\hat{y}_8 = 0$。\n\n最终的预测标签序列是 $[1, 0, 0, 0, 1, 0, 1, 0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ORF classification problem by applying a deterministic classifier\n    derived from the training data.\n    \"\"\"\n    \n    # The test suite consists of 8 feature vectors, each with components\n    # (L, G, C) representing ORF length, GC content, and codon usage bias.\n    test_cases = [\n        (1200, 0.65, 0.90),\n        (90, 0.45, 0.31),\n        (1500, 0.42, 0.35),\n        (300, 0.50, 0.50),\n        (1800, 0.30, 0.70),\n        (450, 0.60, 0.62),\n        (720, 0.50, 0.80),\n        (960, 0.58, 0.55),\n    ]\n\n    # From the analysis of the training data, the codon usage bias feature 'C'\n    # provides a perfect linear separation between the two classes (y=0 and y=1).\n    #\n    # Max 'C' for class 0: 0.60\n    # Min 'C' for class 1: 0.75\n    #\n    # The deterministic decision boundary is set at the midpoint of the gap,\n    # which corresponds to the maximum-margin separating hyperplane.\n    threshold = (0.60 + 0.75) / 2.0  # This equals 0.675\n\n    results = []\n    for case in test_cases:\n        # The feature vector is (L, G, C). We only need C for classification.\n        # The third element in the tuple (index 2) is the C value.\n        codon_usage_bias = case[2]\n        \n        # Apply the classification rule:\n        # Predict 1 (real gene) if C > threshold, otherwise predict 0.\n        prediction = 1 if codon_usage_bias > threshold else 0\n        results.append(prediction)\n\n    # Format the final output as a comma-separated list of integers\n    # enclosed in square brackets, with no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2410602"}]}