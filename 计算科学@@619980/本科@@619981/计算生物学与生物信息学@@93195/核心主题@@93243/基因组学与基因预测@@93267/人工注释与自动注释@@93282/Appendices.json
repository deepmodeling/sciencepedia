{"hands_on_practices": [{"introduction": "当自动化工具与人类专家给出的注释发生冲突时，我们该如何决策？本练习将引导你运用一个强大的概率框架来解决这类分歧[@problem_id:2383771]。你将通过应用贝叶斯定理，并考虑每个信息源已知的可靠性（即灵敏度$s_j$和特异性$t_j$），来计算一个基因最可能具备的真实功能，从而在矛盾的数据中做出合乎逻辑的判断。", "problem": "一个基因家族正在被研究其二元分子功能，该功能被建模为一个潜变量 $T \\in \\{0,1\\}$，其中 $T=1$ 表示给定基因确实具有该功能，而 $T=0$ 表示不具有。两个注释源提供了观测标签：一个人工审编源 $C$ 和一个自动化流程 $A$。每个观测标签表示为 $L_C \\in \\{0,1,\\varnothing\\}$ 和 $L_A \\in \\{0,1,\\varnothing\\}$，其中 $1$ 表示该功能被标注为存在，$0$ 表示被标注为不存在，而 $\\varnothing$ 表示该来源缺少注释。\n\n假设以下生成属性成立：\n- 从该家族中随机选择的一个基因确实具有该功能的先验概率为 $P(T=1)=p$，且 $P(T=0)=1-p$，其中 $p \\in [0,1]$ 是给定的。\n- 对于来源 $j \\in \\{C,A\\}$，定义灵敏度 $s_j = P(L_j=1 \\mid T=1)$ 和特异度 $t_j = P(L_j=0 \\mid T=0)$，其中 $s_j \\in [0,1]$ 和 $t_j \\in [0,1]$。因此，$P(L_j=0 \\mid T=1)=1-s_j$ 且 $P(L_j=1 \\mid T=0)=1-t_j$。\n- 在给定 $T$ 的条件下，观测标签 $L_C$ 和 $L_A$ 是独立的。\n- 如果 $L_j=\\varnothing$，它不提供任何信息，意味着为了似然计算的目的，$P(L_j=\\varnothing \\mid T=1)=P(L_j=\\varnothing \\mid T=0)=1$。\n\n对于下方的每个测试用例，给定一个参数元组 $(p,s_C,t_C,s_A,t_A,L_C,L_A)$。对于每个元组，计算后验概率 $P(T=1 \\mid L_C, L_A)$，并将其报告为四舍五入到六位小数的小数。\n\n测试套件（每个项目是一个元组 $(p,s_C,t_C,s_A,t_A,L_C,L_A)$，其中 $L_C,L_A \\in \\{0,1,\\varnothing\\}$）：\n- 案例 1: $(0.3, 0.95, 0.98, 0.85, 0.9, 1, 0)$\n- 案例 2: $(0.3, 0.95, 0.98, 0.85, 0.9, 1, 1)$\n- 案例 3: $(0.3, 0.95, 0.98, 0.85, 0.9, 0, 0)$\n- 案例 4: $(0.3, 0.95, 0.98, 0.85, 0.9, \\varnothing, 1)$\n- 案例 5: $(0.3, 0.95, 0.98, 0.5, 0.5, 1, 0)$\n- 案例 6: $(0.6, 1.0, 1.0, 0.85, 0.9, 0, 1)$\n- 案例 7: $(0.42, 0.9, 0.9, 0.8, 0.8, \\varnothing, \\varnothing)$\n\n您的程序必须生成单行输出，其中包含一个含有 $7$ 个浮点数的列表，每个浮点数是对应案例计算出的 $P(T=1 \\mid L_C, L_A)$，顺序与测试套件中的顺序相同。所需格式为单行：\n\"[x1,x2,x3,x4,x5,x6,x7]\"\n其中每个 $x_k$ 都四舍五入到六位小数，并以小数形式书写（不含百分号）。", "solution": "问题陈述已经过评估并被确定为有效。这是一个贝叶斯统计推断中的适定性问题，基于既定的概率论原理。所有参数和条件都得到了明确定义，且前提具有科学合理性和一致性。因此，我们可以着手求解。\n\n该问题要求计算后验概率 $P(T=1 \\mid L_C, L_A)$，它表示在给定来自审编源 ($L_C$) 和自动源 ($L_A$) 的观测注释的情况下，一个基因确实具有该功能 ($T=1$) 的概率。我们将为此使用贝叶斯定理。\n\n贝叶斯定理阐明：\n$$\nP(T=1 \\mid L_C, L_A) = \\frac{P(L_C, L_A \\mid T=1) P(T=1)}{P(L_C, L_A)}\n$$\n\n项 $P(T=1)$ 是先验概率，给定为 $p$。项 $P(L_C, L_A \\mid T=1)$ 是在基因确实具有功能的条件下，观测到证据 $(L_C, L_A)$ 的似然。分母 $P(L_C, L_A)$ 是观测到该证据的全概率，也称为边缘似然。它可以使用全概率公式展开：\n$$\nP(L_C, L_A) = P(L_C, L_A \\mid T=1) P(T=1) + P(L_C, L_A \\mid T=0) P(T=0)\n$$\n\n问题陈述指出，在给定真实状态 $T$ 的条件下，观测值 $L_C$ 和 $L_A$ 是独立的。这使我们能够将联合似然分解为各个似然的乘积：\n$$\nP(L_C, L_A \\mid T) = P(L_C \\mid T) P(L_A \\mid T)\n$$\n\n让我们将给定 $T=1$ 时证据的似然定义为 $\\mathcal{L}_1$，给定 $T=0$ 时定义为 $\\mathcal{L}_0$：\n$$\n\\mathcal{L}_1 = P(L_C \\mid T=1) P(L_A \\mid T=1)\n$$\n$$\n\\mathcal{L}_0 = P(L_C \\mid T=0) P(L_A \\mid T=0)\n$$\n\n将这些代入贝叶斯定理表达式，并回顾 $P(T=1)=p$ 和 $P(T=0)=1-p$，我们得到后验概率的通用公式：\n$$\nP(T=1 \\mid L_C, L_A) = \\frac{\\mathcal{L}_1 \\cdot p}{\\mathcal{L}_1 \\cdot p + \\mathcal{L}_0 \\cdot (1-p)}\n$$\n\n对于一个来源 $j \\in \\{C, A\\}$，单个似然因子 $P(L_j \\mid T)$ 取决于观测标签 $L_j \\in \\{0, 1, \\varnothing\\}$ 以及该来源的性能指标，即灵敏度 ($s_j$) 和特异度 ($t_j$)。条件概率定义如下：\n- 如果标签为 $1$ (功能存在):\n  - $P(L_j=1 \\mid T=1) = s_j$ (灵敏度)\n  - $P(L_j=1 \\mid T=0) = 1 - t_j$ (假阳性率)\n- 如果标签为 $0$ (功能不存在):\n  - $P(L_j=0 \\mid T=1) = 1 - s_j$ (假阴性率)\n  - $P(L_j=0 \\mid T=0) = t_j$ (特异度)\n- 如果标签为 $\\varnothing$ (缺失):\n  - $P(L_j=\\varnothing \\mid T=1) = 1$\n  - $P(L_j=\\varnothing \\mid T=0) = 1$\n  根据问题的规定，缺失标签对似然的贡献因子为 $1$，实际上不提供任何信息并简化了计算，这是一个有效的建模选择。\n\n因此，解决方案是对该框架的系统性应用。对于每个测试用例，我们将：\n1. 识别参数 $(p, s_C, t_C, s_A, t_A)$ 和观测值 $(L_C, L_A)$。\n2. 使用上述定义确定四个独立的似然因子：$P(L_C \\mid T=1)$、 $P(L_C \\mid T=0)$、 $P(L_A \\mid T=1)$ 和 $P(L_A \\mid T=0)$。\n3. 计算联合似然 $\\mathcal{L}_1$ 和 $\\mathcal{L}_0$。\n4. 将这些值代入最终的后验概率公式。\n5. 如果分母 $\\mathcal{L}_1 \\cdot p + \\mathcal{L}_0 \\cdot (1-p)$ 的计算结果为零，则意味着在模型下观测到的证据是不可能的。在这种情况下，后验概率在数学上没有定义。然而，对测试用例的分析表明这种情况不会发生。例如，如果分子 $\\mathcal{L}_1 \\cdot p$ 为零，只要分母不为零，后验概率就为零。这种情况发生在案例6中，其中一个完美的分类器提供了反对 $T=1$ 的确定性证据。\n6. 每个案例的最终结果四舍五入到六位小数。\n\n此程序为每个指定的测试用例提供了严谨且唯一的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the posterior probability P(T=1 | L_C, L_A) for a series of test cases.\n    \"\"\"\n    # The value None is used to represent the missing annotation symbol Ø.\n    test_cases = [\n        (0.3, 0.95, 0.98, 0.85, 0.9, 1, 0),\n        (0.3, 0.95, 0.98, 0.85, 0.9, 1, 1),\n        (0.3, 0.95, 0.98, 0.85, 0.9, 0, 0),\n        (0.3, 0.95, 0.98, 0.85, 0.9, None, 1),\n        (0.3, 0.95, 0.98, 0.5, 0.5, 1, 0),\n        (0.6, 1.0, 1.0, 0.85, 0.9, 0, 1),\n        (0.42, 0.9, 0.9, 0.8, 0.8, None, None),\n    ]\n\n    results = []\n    for case in test_cases:\n        p, s_C, t_C, s_A, t_A, L_C, L_A = case\n\n        # Helper function to compute the likelihood factors P(L|T=1) and P(L|T=0)\n        # for a single evidence source.\n        def get_likelihood_factors(label, sensitivity, specificity):\n            if label == 1:\n                # P(L=1|T=1), P(L=1|T=0)\n                return sensitivity, 1 - specificity\n            elif label == 0:\n                # P(L=0|T=1), P(L=0|T=0)\n                return 1 - sensitivity, specificity\n            elif label is None: # Corresponds to Ø\n                # P(L=Ø|T=1), P(L=Ø|T=0)\n                # A missing label contributes no information.\n                return 1.0, 1.0\n            else:\n                # This case should not be reached with the given test data.\n                raise ValueError(\"Invalid label value\")\n\n        # Get likelihood factors for both curated (C) and automated (A) sources\n        lik_C_t1, lik_C_t0 = get_likelihood_factors(L_C, s_C, t_C)\n        lik_A_t1, lik_A_t0 = get_likelihood_factors(L_A, s_A, t_A)\n\n        # Compute the joint likelihoods L1 = P(evidence|T=1) and L0 = P(evidence|T=0)\n        # based on the conditional independence assumption.\n        L_1 = lik_C_t1 * lik_A_t1\n        L_0 = lik_C_t0 * lik_A_t0\n\n        # Calculate the numerator of Bayes' theorem: P(evidence|T=1) * P(T=1)\n        numerator = L_1 * p\n\n        # Calculate the denominator (marginal likelihood): P(evidence)\n        # P(evidence) = P(evidence|T=1)P(T=1) + P(evidence|T=0)P(T=0)\n        denominator = numerator + L_0 * (1 - p)\n\n        # Compute the posterior probability P(T=1|evidence)\n        if denominator == 0:\n            # This case occurs if the evidence is impossible under the model.\n            # If the denominator is 0, the numerator must also be 0, as it is one of\n            # the non-negative terms in the sum. The posterior could be considered\n            # undefined (0/0), but in the context of probabilities, if evidence is\n            # absolutely impossible, we can assign it a probability of 0.\n            # For Case 6, L_1 is 0, so numerator is 0, and posterior is 0.\n            posterior_prob = 0.0\n        else:\n            posterior_prob = numerator / denominator\n        \n        # Round the result to six decimal places\n        results.append(round(posterior_prob, 6))\n\n    # Format the output as specified in the problem statement.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2383771"}, {"introduction": "有些注释不仅在统计上不太可能，甚至在生物学上是荒谬的。本练习将展示如何运用基本的生物学原理，特别是进化中的简约性原则，来进行“合理性检查”[@problem_id:2383796]。你将设计一个算法，通过判断一个新注释（例如，人类进行光合作用）是否会在物种进化树上引入过多不必要的演化事件，来识别那些违背进化逻辑的注释，从而提供一种强大的、基于生物学背景的错误检测方法。", "problem": "一个自动化注释流程将一个人类蛋白质赋予了“叶绿素生物合成”的功能字符串。请设计并实现一个基于系统发育的健全性检查算法，该算法仅使用一个有根物种树上的、经审编的功能存在集，以及在该树上最小化状态变化的简约性原则，来标记此类功能分配为不合理。\n\n使用的基本事实：共同祖先演化意味着性状和基因功能沿物种树遗传；分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质）约束了基因功能映射到生物体能力；简约性（奥卡姆剃刀）原则假定，在多种演化重构方案中，状态变化最少的方案更优。不应假设任何其他专门公式。\n\n数学形式化：让有根树表示为 $T$，其叶节点由物种名称标记。对于一个生物学功能 $f$，让 $P_f \\subseteq L(T)$ 表示经专家审编已知的、拥有功能 $f$ 的叶节点集合。通过将 $P_f$ 中的叶节点分配为状态 $1$，将所有其他叶节点分配为状态 $0$，在 $L(T)$ 上定义一个二元性状。对于任何此类分配，让 $C(P_f)$ 表示在 Fitch 简约法下解释 $T$ 上观察到的状态所需的状态变化（获得或丢失）的最小次数。对于一个声称物种 $q \\in L(T)$ 具有功能 $f$ 的提议注释，定义系统发育不一致性分数为\n$$D(q,f) = C\\big(P_f \\cup \\{q\\}\\big) - C(P_f).$$\n直观地说，$D(q,f)$ 是为了容纳该声明，树必须承受的额外变化次数。健全性检查规则是：当且仅当 $D(q,f) \\ge \\tau$ (阈值 $\\tau = 1$) 时，将该注释标记为不合理。\n\n您的任务：实现一个完整的程序，给定树 $T$、几个功能的经审编存在集 $P_f$ 以及一个查询注释列表 $(q,f)$，该程序通过 Fitch 简约法计算 $D(q,f)$，并根据上述规则为每个查询返回一个布尔标记。\n\n树拓扑 $T$（有根，从父节点指向子节点，没有子节点的为叶节点）：\n\n- “根” (root) 的子节点是“细菌” (bacteria)、“古菌” (archaea)、“真核生物” (eukaryota)。\n- “细菌” (bacteria) 的子节点是 \"cyanobacteria\"、“e_coli”。\n- “古菌” (archaea) 的子节点是 \"methanoarchaea\"。\n- “真核生物” (eukaryota) 的子节点是 \"opisthokonta\"、“archaeplastida”、“excavata”。\n- \"opisthokonta\" 的子节点是 \"human\"、“mouse”、“yeast”。\n- \"archaeplastida\" 的子节点是 \"arabidopsis\"。\n- \"excavata\" 的子节点是 \"euglena\"。\n\n经审编的存在集 $P_f$：\n\n- 对于功能 \"chlorophyll_biosynthesis\": $P_{\\mathrm{chlorophyll\\_biosynthesis}} = \\{\\text{\"arabidopsis\"}, \\text{\"cyanobacteria\"}, \\text{\"euglena\"}\\}$。\n- 对于功能 \"photosystem_II\": $P_{\\mathrm{photosystem\\_II}} = \\{\\text{\"arabidopsis\"}, \\text{\"cyanobacteria\"}, \\text{\"euglena\"}\\}$。\n- 对于功能 \"heme_biosynthesis\": $P_{\\mathrm{heme\\_biosynthesis}} = \\{\\text{\"human\"}, \\text{\"yeast\"}, \\text{\"arabidopsis\"}, \\text{\"e_coli\"}\\}$。\n- 对于功能 \"methanogenesis\": $P_{\\mathrm{methanogenesis}} = \\{\\text{\"methanoarchaea\"}\\}$。\n\n实现要求：\n\n- 使用标准的 Fitch 简约法算法在树 $T$ 上为二元性状计算 $C(\\cdot)$，允许存在多分叉内部节点。如果叶节点在 $P_f$ 中，其状态为 $\\{1\\}$，否则为 $\\{0\\}$。对于一个具有子节点状态集 $S_1, S_2, \\dots, S_k$ 的内部节点，通过重复应用以下规则来组合它们：如果当前累加器 $A$ 与下一个 $S_i$ 相交，则设置 $A \\leftarrow A \\cap S_i$；否则设置 $A \\leftarrow A \\cup S_i$ 并将变化计数加 $1$。在所有内部节点上聚合的总变化计数等于 $C(\\cdot)$。\n- 对于每个查询 $(q,f)$，按上述定义计算 $D(q,f)$，并在 $D(q,f) \\ge \\tau$（其中 $\\tau = 1$）时标记为不合理。\n\n测试用例：使用以下有序查询列表；您的程序必须为每个查询计算一个布尔值，以指示其是否被标记为不合理。\n\n- $(\\text{\"human\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"arabidopsis\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"cyanobacteria\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"human\"}, \\text{\"heme_biosynthesis\"})$\n- $(\\text{\"yeast\"}, \\text{\"methanogenesis\"})$\n- $(\\text{\"euglena\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"human\"}, \\text{\"photosystem_II\"})$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，不含空格，顺序与测试用例相同（例如，$[\\text{True},\\text{False},\\dots]$）。", "solution": "问题陈述经过严格验证，并被认定为有效。它在科学上植根于演化生物学和生物信息学的原理，问题阐述清晰，具有明确的数学形式化，并且语言客观。为得出唯一解所需的所有数据和定义均已提供。该问题是将系统发育比较方法直接且形式化地应用于生物学注释质量控制这一实际任务。\n\n目标是设计并实现一种算法，作为自动化蛋白质功能注释的健全性检查。此检查的核心是简约性原则，这是系统发育学中的一个基本概念，它指出首选的演化情景是需要最少状态变化（例如，功能的获得或丢失）的情景。我们的任务是为一个提议的注释（即物种 $q$ 拥有功能 $f$）计算一个“系统发育不一致性分数”，表示为 $D(q, f)$。\n\n该分数定义为：\n$$D(q,f) = C\\big(P_f \\cup \\{q\\}\\big) - C(P_f)$$\n此处，$P_f$ 是经专家审编已知的具有功能 $f$ 的物种集合。术语 $C(S)$ 代表给定存在集 $S$ 的简约性分数，这是在物种树 $T$ 上解释该功能在叶节点间分布所需的最少演化变化次数（从状态 $0$ 到 $1$ 或从 $1$ 到 $0$）。如果此分数达到或超过阈值 $\\tau = 1$，则提议的注释 $(q,f)$ 会被标记为不合理。$D(q,f) \\ge 1$ 的分数意味着容纳新注释需要在树上至少增加一次额外的演化事件，从而增加了其复杂性并降低了其简约性。\n\n简约性分数 $C(\\cdot)$ 的计算是使用 Fitch 简约法算法完成的。该算法在概念上分两遍遍历树 $T$，但为了计算分数，只需要第一遍（上行遍历）即可。算法过程如下：\n\n1.  **状态初始化：** 在树的叶节点 $L(T)$ 上定义一个二元性状。对于给定的存在集 $S$，如果叶节点 $l \\in L(T)$ 属于 $S$，则为其分配状态集 $\\{1\\}$，否则分配 $\\{0\\}$。\n\n2.  **上行遍历（后序遍历）：** 算法从叶节点向根节点遍历树。对于每个具有子节点 $v_1, v_2, \\dots, v_k$ 的内部节点 $u$，我们计算其假设状态集 $S_u$ 以及在通往其子节点的枝上发生的变化次数 $c_u$。\n    *   子节点的状态集 $S_{v_1}, S_{v_2}, \\dots, S_{v_k}$ 是通过递归确定的。\n    *   通过遍历子状态集来计算状态集 $S_u$ 和变化计数 $c_u$。我们初始化一个累加器集 $A = S_{v_1}$ 和一个局部变化计数 $c_u = 0$。\n    *   对于每个后续的子节点 $v_i$（从 $i=2$ 到 $k$）：\n        *   如果交集 $A \\cap S_{v_i}$ 非空，则将累加器更新为此交集：$A \\leftarrow A \\cap S_{v_i}$。这代表从父节点 $u$ 继承的共享状态。\n        *   如果交集 $A \\cap S_{v_i}$ 为空，则将累加器更新为并集 $A \\leftarrow A \\cup S_{v_i}$，并增加变化计数：$c_u \\leftarrow c_u + 1$。这表示在所涉及的某个分支上发生了必要的状态变化（趋同或丢失）。\n    *   节点 $u$ 的最终状态集是 $A$ 的最终值，而节点 $u$ 处的成本是 $c_u$ 的最终值。\n\n3.  **总简约性分数：** 总简约性分数 $C(S)$ 是树中所有内部节点的变化计数之和：\n    $$C(S) = \\sum_{u \\in \\text{InternalNodes}(T)} c_u$$\n\n为了实现该解决方案，首先将提供的树拓扑表示为有向图，例如，使用一个将父节点映射到其子节点列表的字典。然后设计一个递归函数来执行后序遍历，在从叶节点到根节点的过程中计算状态集和变化计数。\n\n对于测试用例中的每个查询 $(q,f)$：\n1.  使用经审编的存在集 $P_f$ 计算基线简约性分数 $C(P_f)$。\n2.  如果查询物种 $q$ 已经存在于 $P_f$ 中，则 $P_f \\cup \\{q\\} = P_f$，这意味着 $C(P_f \\cup \\{q\\}) = C(P_f)$。因此，$D(q,f) = 0$，该注释不会被标记。\n3.  如果 $q \\notin P_f$，则形成一个新的存在集 $P'_f = P_f \\cup \\{q\\}$。\n4.  为这个新集合计算简约性分数 $C(P'_f)$。\n5.  计算不一致性分数 $D(q,f) = C(P'_f) - C(P_f)$。\n6.  将结果与阈值 $\\tau=1$ 进行比较。如果 $D(q,f) \\ge 1$，查询被标记为不合理（布尔值 `True`），否则标记为合理（布尔值 `False`）。\n\n将此过程应用于提供的测试用例中的每个查询，以生成最终输出。", "answer": "```python\nimport numpy as np\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Solves the phylogenetic sanity-check problem.\n    \"\"\"\n    \n    # Define the species tree topology as a parent-to-children dictionary.\n    TREE = {\n        \"root\": [\"bacteria\", \"archaea\", \"eukaryota\"],\n        \"bacteria\": [\"cyanobacteria\", \"e_coli\"],\n        \"archaea\": [\"methanoarchaea\"],\n        \"eukaryota\": [\"opisthokonta\", \"archaeplastida\", \"excavata\"],\n        \"opisthokonta\": [\"human\", \"mouse\", \"yeast\"],\n        \"archaeplastida\": [\"arabidopsis\"],\n        \"excavata\": [\"euglena\"],\n    }\n    \n    # Identify all nodes and leaf nodes from the tree structure.\n    all_nodes = set(TREE.keys())\n    for children in TREE.values():\n        all_nodes.update(children)\n    LEAVES = all_nodes - set(TREE.keys())\n\n    # Define the curated presence sets for each function.\n    CURATED_SETS = {\n        \"chlorophyll_biosynthesis\": {\"arabidopsis\", \"cyanobacteria\", \"euglena\"},\n        \"photosystem_II\": {\"arabidopsis\", \"cyanobacteria\", \"euglena\"},\n        \"heme_biosynthesis\": {\"human\", \"yeast\", \"arabidopsis\", \"e_coli\"},\n        \"methanogenesis\": {\"methanoarchaea\"},\n    }\n\n    # Define the test suite of queries (species, function).\n    QUERIES = [\n        (\"human\", \"chlorophyll_biosynthesis\"),\n        (\"arabidopsis\", \"chlorophyll_biosynthesis\"),\n        (\"cyanobacteria\", \"chlorophyll_biosynthesis\"),\n        (\"human\", \"heme_biosynthesis\"),\n        (\"yeast\", \"methanogenesis\"),\n        (\"euglena\", \"chlorophyll_biosynthesis\"),\n        (\"human\", \"photosystem_II\"),\n    ]\n\n    def fitch_parsimony_score(presence_set):\n        \"\"\"\n        Calculates the total Fitch parsimony score for a given presence set.\n        \n        Args:\n            presence_set (frozenset): A set of leaf names that possess the function (state 1).\n        \n        Returns:\n            int: The minimum number of state changes on the tree.\n        \"\"\"\n        \n        # Memoization to avoid recomputing for the same node and presence set.\n        @lru_cache(maxsize=None)\n        def post_order_traversal(node, p_set):\n            \"\"\"\n            Performs a post-order traversal to compute state sets and change counts.\n\n            Args:\n                node (str): The current node name.\n                p_set (frozenset): The presence set for this calculation.\n            \n            Returns:\n                tuple[set, int]: A tuple containing the state set for the node and the\n                                 cumulative change count for the subtree rooted at this node.\n            \"\"\"\n            # Base Case: Leaf node\n            if node in LEAVES:\n                state_set = {1} if node in p_set else {0}\n                return state_set, 0\n\n            # Recursive Step: Internal node\n            children = TREE.get(node, [])\n            if not children: # Should not happen for internal nodes\n                return set(), 0\n\n            # Get state sets and costs from all children\n            child_results = [post_order_traversal(child, p_set) for child in children]\n            \n            # Initialize accumulator and total cost for this subtree\n            # Start with the first child\n            running_state_set, total_subtree_cost = child_results[0]\n            # Make a copy to modify\n            running_state_set = set(running_state_set)\n            \n            # The change count at this specific node\n            node_cost = 0\n\n            # Sequentially merge the rest of the children\n            for i in range(1, len(child_results)):\n                child_state_set, child_cost = child_results[i]\n                total_subtree_cost += child_cost\n                \n                intersection = running_state_set.intersection(child_state_set)\n                \n                if intersection:\n                    running_state_set = intersection\n                else:\n                    running_state_set.update(child_state_set)\n                    node_cost += 1\n            \n            total_subtree_cost += node_cost\n            return running_state_set, total_subtree_cost\n\n        # Start the traversal from the root node.\n        # The presence_set is converted to a frozenset to be hashable for lru_cache.\n        _, total_cost = post_order_traversal(\"root\", frozenset(presence_set))\n        return total_cost\n\n    results = []\n    tau = 1\n\n    for q, f in QUERIES:\n        p_f = CURATED_SETS[f]\n        \n        # If the queried species is already in the curated set, the score change is 0.\n        if q in p_f:\n            d_qf = 0\n        else:\n            # Calculate score without the query\n            c_pf = fitch_parsimony_score(p_f)\n            \n            # Calculate score with the query\n            p_f_union_q = p_f.union({q})\n            c_pf_union_q = fitch_parsimony_score(p_f_union_q)\n            \n            d_qf = c_pf_union_q - c_pf\n        \n        # Flag as implausible if the score change is >= tau\n        is_implausible = d_qf >= tau\n        results.append(is_implausible)\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2383796"}]}