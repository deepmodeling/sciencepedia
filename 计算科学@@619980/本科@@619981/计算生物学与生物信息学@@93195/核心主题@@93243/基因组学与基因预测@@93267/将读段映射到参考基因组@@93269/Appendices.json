{"hands_on_practices": [{"introduction": "在将测序读段（reads）比对到参考基因组之前，一个关键的步骤是质量控制和数据清理。真实的测序样本常常混合有来自其他物种（如细菌）的DNA，我们称之为“污染”。使用$k$-mer计数是一种高效的、无需比对的预处理方法，可以在昂贵的比对步骤之前快速筛选出这些污染读段。这项实践将指导你构建一个实用的过滤器，利用$k$-mer特征来识别并标记潜在的污染序列[@problem_id:2425285]。", "problem": "你的任务是设计一个预映射过滤器，通过使用固定长度子串计数（也称为 $k$-mer 计数）来检测并移除源自已知污染生物的测序读段。处理的序列是基于字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 以及可能包含歧义符号 $\\mathrm{N}$ 的脱氧核糖核酸（DNA）序列。基本方法如下：一个 $k$-mer 是 DNA 字符串中任意长度为 $k$ 的连续子串；DNA 字符串的反向互补序列是通过反转字符串并将每个 $\\mathrm{A}$ 替换为 $\\mathrm{T}$、每个 $\\mathrm{T}$ 替换为 $\\mathrm{A}$、每个 $\\mathrm{C}$ 替换为 $\\mathrm{G}$、每个 $\\mathrm{G}$ 替换为 $\\mathrm{C}$ 而形成的。一个 $k$-mer 的规范形式定义为该 $k$-mer 与其反向互补序列中字典序较小的那一个，其中字典序使用 $\\mathrm{A}<\\mathrm{C}<\\mathrm{G}<\\mathrm{T}$ 的顺序。对于给定的 $k$，污染特征是在污染参考序列中观察到的所有规范 $k$-mer 的集合。\n\n设计一个程序，对每个读段根据以下规则判断是否将其分类为污染：\n- 通过从污染参考序列字符串 $S_c$ 中提取所有规范 $k$-mer 来构建污染特征集 $D_k$。\n- 对于一个读段 $R$，在 $R$ 上滑动一个长度为 $k$ 的窗口。任何包含 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 之外符号的窗口都是无效的，必须从分子和分母中排除。设 $n_k$ 为 $R$ 中有效窗口的数量（即有效 $k$-mer 的数量），并设 $c_k$ 为这些有效窗口中其规范 $k$-mer 存在于 $D_k$ 中的数量。\n- 当 $n_k>0$ 时，计算匹配率 $r_k = c_k / n_k$。如果 $n_k=0$，则无需进一步计算，直接将该读段定义为非污染。\n- 给定一个以小数表示的阈值 $\\tau$（$0 \\le \\tau \\le 1$），当且仅当 $r_k \\ge \\tau$ 时，将该读段分类为污染。\n\n所有计算都纯粹基于字符串，不涉及物理单位。独立处理每个重叠窗口；也就是说，计数时应考虑其在读段内出现的次数（multiplicity），而不是将其视为唯一的 $k$-mer。\n\n测试套件：\n- 使用以下固定的污染参考序列字符串 $S_c$：“ACGTTGCAACGTTGCA”，其长度为 $16$。\n- 对于每个测试用例 $i$，你会得到一个元组 $(R_i, k_i, \\tau_i)$，包含一个读段字符串 $R_i$、一个整数 $k_i$ 和一个以小数表示的实数阈值 $\\tau_i$。你的程序必须独立评估每个用例，并使用 $S_c$ 为该用例构建 $D_{k_i}$。\n\n测试用例如下：\n1. $R_1=$ \"TTGCAACGTTG\", $k_1 = 4$, $\\tau_1 = 0.6$.\n2. $R_2=$ \"ACGTTGCATTT\", $k_2 = 4$, $\\tau_2 = 0.625$.\n3. $R_3=$ \"AAAAACCCCC\", $k_3 = 4$, $\\tau_3 = 0.5$.\n4. $R_4=$ \"GTTGCAACGT\", $k_4 = 4$, $\\tau_4 = 0.9$.\n5. $R_5=$ \"ACGTNNNNACGT\", $k_5 = 4$, $\\tau_5 = 1.0$.\n6. $R_6=$ \"ACGT\", $k_6 = 5$, $\\tau_6 = 0.5$.\n7. $R_7=$ \"ACGTACGTACGT\", $k_7 = 4$, $\\tau_7 = 0.3$.\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含按顺序排列的 7 个测试用例的布尔结果列表，如果读段被分类为污染，则对应条目为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 该行必须格式化为用方括号括起来的逗号分隔列表，不含空格，例如：“[True,False,...]”。\n\n你的程序必须是一个完整、可运行的实现，能够为每个测试用例从 $S_c$ 构建 $D_{k}$，应用上述决策规则，并按规定格式输出所有用例的结果。", "solution": "该问题定义明确，在生物信息学领域具有坚实的科学基础。它描述了一种基于 $k$-mer 内容过滤测序读段的标准方法，这是基因组分析中移除污染的一个常见预处理步骤。问题陈述是完整的，提供了所有必要的定义、数据和一个清晰的确定性算法。因此，可以构建一个解决方案。\n\n其核心原理是通过比较测序读段 $R$ 和污染参考基因组 $S_c$ 各自的固定长度为 $k$ 的组成子串（即 $k$-mer）来量化它们之间的相似性。由于 DNA 是双链的，一个读段可能源自任意一条链。为了解决这个问题，我们不直接处理 $k$-mer，而是使用它们的规范形式。\n\n一个 $k$-mer 的规范形式被定义为该 $k$-mer 本身与其反向互补序列中字典序较小的那一个，其中标准的字典序为 $\\mathrm{A}<\\mathrm{C}<\\mathrm{G}<\\mathrm{T}$。反向互补序列通过反转序列并将每个碱基替换为其沃森-克里克配对碱基（$\\mathrm{A} \\leftrightarrow \\mathrm{T}$, $\\mathrm{C} \\leftrightarrow \\mathrm{G}$）得到。这种规范化确保了一个 $k$-mer 及其反向互补序列被视为一个单一实体，从而忽略了其来源链。\n\n该算法主要分为两个阶段：特征生成和读段分类。\n\n1.  **特征生成**：首先，我们为给定的整数 $k$ 构建一个污染特征，记为 $D_k$。该特征是在污染参考序列字符串 $S_c$ 中找到的所有唯一的规范 $k$-mer 的集合。我们在 $S_c$ 上滑动一个长度为 $k$ 的窗口，对于每个产生的 $k$-mer，我们计算其规范形式并将其添加到一个集合数据结构中。使用集合在计算上是高效的，其成员资格查询的平均时间复杂度为 $O(1)$。问题指定了一个固定的 $S_c$ 为“ACGTTGCAACGTTGCA”，其长度为 $16$。对于每个具有特定 $k_i$ 的测试用例，相应的特征 $D_{k_i}$ 将从这个 $S_c$ 构建。\n\n2.  **读段分类**：对于每个测试用例，使用给定的阈值 $\\tau_i$ 根据特征 $D_{k_i}$ 对读段 $R_i$ 进行评估。流程如下：\n    a. 我们在读段 $R_i$ 上滑动一个长度为 $k_i$ 的窗口。\n    b. 每个窗口（或 $k$-mer）首先需要被验证。只有当一个窗口完全由字母表 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 中的符号组成时，它才被认为是有效的。包含如 $\\mathrm{N}$ 等歧义符号的窗口是无效的，将被忽略。我们统计有效窗口的总数，即 $n_{k_i}$。\n    c. 如果 $n_{k_i} = 0$（当读段长度小于 $k_i$ 或不包含任何有效窗口时会发生这种情况），该读段立即被分类为非污染。\n    d. 对于每个有效窗口，我们计算其规范 $k$-mer。然后我们检查这个规范形式是否存在于污染特征集 $D_{k_i}$ 中。我们统计这类匹配的总数，记为 $c_{k_i}$。问题要求计数时考虑重复出现，这意味着读段中每次出现的匹配 $k$-mer 都会计入总数。\n    e. 匹配率 $r_{k_i}$ 计算为读段中也在污染特征中找到的有效 $k$-mer 的比例：$r_{k_i} = c_{k_i} / n_{k_i}$。\n    f. 最后，根据阈值 $\\tau_i$ 做出决定。当且仅当读段的匹配率大于或等于该阈值时，它被分类为污染：$r_{k_i} \\ge \\tau_i$。\n\n实现将包括用于计算序列的反向互补序列和规范形式的辅助函数，一个用于构建污染特征集的函数，以及一个主分类函数，该函数协调这些步骤以根据指定规则评估每个读段。所有测试用例的结果将被收集并格式化为布尔值列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries outside the Python standard library are permitted.\n\n# Define helper functions at the top level for clarity.\n\n# Create a translation table for complementing DNA bases.\nCOMPLEMENT_MAP = str.maketrans('ACGT', 'TGCA')\nVALID_BASES = {'A', 'C', 'G', 'T'}\n\ndef reverse_complement(seq: str) -> str:\n    \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n    return seq.translate(COMPLEMENT_MAP)[::-1]\n\ndef canonical_form(kmer: str) -> str:\n    \"\"\"Computes the canonical form of a k-mer.\"\"\"\n    rev_comp = reverse_complement(kmer)\n    return min(kmer, rev_comp)\n\ndef build_contaminant_signature(s_c: str, k: int) -> set:\n    \"\"\"Builds the set of canonical k-mers from a reference string.\"\"\"\n    signature = set()\n    if len(s_c) < k:\n        return signature\n    for i in range(len(s_c) - k + 1):\n        kmer = s_c[i:i+k]\n        # Assuming the contaminant reference string S_c contains only valid bases.\n        signature.add(canonical_form(kmer))\n    return signature\n\ndef classify_read(read: str, k: int, tau: float, contaminant_signature: set) -> bool:\n    \"\"\"Classifies a read as contaminant based on k-mer matching.\"\"\"\n    if len(read) < k:\n        return False\n\n    n_k = 0  # Count of valid k-mers in the read\n    c_k = 0  # Count of valid k-mers found in the contaminant signature\n\n    for i in range(len(read) - k + 1):\n        window = read[i:i+k]\n        \n        # A window is valid if it contains only symbols {A,C,G,T}.\n        is_valid = all(char in VALID_BASES for char in window)\n        \n        if is_valid:\n            n_k += 1\n            canonical_kmer = canonical_form(window)\n            if canonical_kmer in contaminant_signature:\n                c_k += 1\n    \n    # If no valid k-mers, classify as non-contaminant.\n    if n_k == 0:\n        return False\n    \n    # Compute match ratio and compare with the threshold.\n    ratio = c_k / n_k\n    return ratio >= tau\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the fixed contaminant reference string from the problem.\n    s_c = \"ACGTTGCAACGTTGCA\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"TTGCAACGTTG\", 4, 0.6),\n        (\"ACGTTGCATTT\", 4, 0.625),\n        (\"AAAAACCCCC\", 4, 0.5),\n        (\"GTTGCAACGT\", 4, 0.9),\n        (\"ACGTNNNNACGT\", 4, 1.0),\n        (\"ACGT\", 5, 0.5),\n        (\"ACGTACGTACGT\", 4, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        read_str, k, tau = case\n        \n        # Build the contaminant signature for the given k.\n        signature = build_contaminant_signature(s_c, k)\n        \n        # Classify the read and store the result.\n        is_contaminant = classify_read(read_str, k, tau, signature)\n        results.append(is_contaminant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2425285"}, {"introduction": "标准的读段比对算法是为经典的四字母DNA字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 设计的，但许多前沿的生物学研究需要我们打破常规。亚硫酸盐测序是表观遗传学研究中的一项关键技术，它通过化学修饰改变了DNA序列，未甲基化的胞嘧啶（C）会被读取为胸腺嘧啶（T）。这项实践将挑战你调整比对算法的核心组件——种子匹配（seeding）策略——以适应这种非标准的序列数据，从而能够准确地定位经过亚硫酸盐处理的读段[@problem_id:2425351]。", "problem": "考虑一个有限字母表 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 和一个参考字符串 $R \\in \\Sigma^{*}$，它代表一段脱氧核糖核酸（DNA）。在亚硫酸氢盐处理的DNA测序中，测序链上未甲基化的胞嘧啶会转换成胸腺嘧啶，等价地，通过反向互补来看，相对链上的鸟嘌呤在处理后对应于腺嘌呤。我们定义两个符号简化函数来捕捉这种化学反应作为等价保持映射：\n- $\\varphi_{\\mathrm{fwd}} : \\Sigma \\to \\Sigma$ 由 $\\varphi_{\\mathrm{fwd}}(\\text{C}) = \\text{T}$ 给出，并且对于所有 $x \\in \\{\\text{A}, \\text{G}, \\text{T}\\}$，$\\varphi_{\\mathrm{fwd}}(x) = x$。\n- $\\varphi_{\\mathrm{rev}} : \\Sigma \\to \\Sigma$ 由 $\\varphi_{\\mathrm{rev}}(\\text{G}) = \\text{A}$ 给出，并且对于所有 $x \\in \\{\\text{A}, \\text{C}, \\text{T}\\}$，$\\varphi_{\\mathrm{rev}}(x) = x$。\n\n设 $\\rho : \\Sigma^{*} \\to \\Sigma^{*}$ 表示反向互补，其定义为首先对每个字符应用互补映射 $\\text{A} \\leftrightarrow \\text{T}$ 和 $\\text{C} \\leftrightarrow \\text{G}$，然后反转字符串。\n\n固定一个种子长度 $k \\in \\mathbb{N}$ 且 $k \\ge 1$。对于任何字符串 $S \\in \\Sigma^{*}$ 和任何索引 $i$（$0 \\le i \\le |S| - k$），用 $S[i{:}i{+}k]$ 表示其连续的长度为 $k$ 的子字符串。对于一个读段 $Q \\in \\Sigma^{*}$，我们将其相对于 $R$ 的亚硫酸氢盐稳健的种子候选集定义为所有满足 $0 \\le i \\le |R| - k$ 的索引 $i$ 的集合，其中存在一个种子位置 $j$（$0 \\le j \\le |Q| - k$），使得以下两个条件之一成立：\n- $\\varphi_{\\mathrm{fwd}}\\big(Q[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{fwd}}\\big(R[i{:}i{+}k]\\big)$，或\n- $\\varphi_{\\mathrm{rev}}\\big(\\rho(Q)[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{rev}}\\big(R[i{:}i{+}k]\\big)$。\n如果 $|Q| < k$，则候选集为空。所有索引都应报告为从0开始的整数。\n\n你的任务是，对于固定的 $R$ 和 $k$，为每个给定的读段 $Q$ 计算其亚硫酸氢盐稳健的种子候选集中的、从0开始的起始索引的排序（升序）去重列表，该集合根据上述定义得出。\n\n测试套件和参数：\n- 参考字符串 $R = \\text{\"AGCCGTTAGCGTTCACCGTAGC\"}$。\n- 种子长度 $k = 4$。\n- 读段，按顺序：\n  1. $Q_1 = \\text{\"TTGT\"}$。\n  2. $Q_2 = \\text{\"AAAT\"}$。\n  3. $Q_3 = \\text{\"AT\"}$。\n  4. $Q_4 = \\text{\"AGTTTT\"}$。\n  5. $Q_5 = \\text{\"TAGT\"}$。\n  6. $Q_6 = \\text{\"GGGG\"}$。\n\n答案规格：\n- 对于上面列表中的每个读段 $Q_m$（按相同顺序），计算相应的已排序的、从0开始的去重索引列表。\n- 你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身也是一个用括号括起来的逗号分隔的整数列表。例如，格式为 $[\\,[i_{1,1},\\dots,i_{1,a_1}],\\,[i_{2,1},\\dots],\\dots\\,]$。具体来说，测试套件的输出必须是这种格式的单行文本，不包含任何额外文字。", "solution": "问题陈述经过验证，被认为是科学上合理的、定义明确且客观的。它基于计算生物学中已确立的原理，特别是用于读段比对的亚硫酸氢盐测序模拟。所有术语都经过了正式定义，该任务是一个直接、无歧义的算法挑战。因此，我们着手提供解决方案。\n\n该问题要求我们在参考DNA字符串 $R$ 中找到一组起始位置，这些位置是给定读段 $Q$ 的潜在比对位点。这是基于一种特殊的、长度为 $k$ 的短子字符串（称为种子或 $k$-mers）的匹配。匹配规则旨在解释由亚硫酸氢盐处理引起的化学转化，该转化将未甲基化的胞嘧啶（C）转换为胸腺嘧啶（T）。这对正向链及其反向互补链上的匹配都有影响。\n\n我们的算法方法包括两个主要阶段：对参考字符串 $R$ 的预处理阶段，以及对每个读段 $Q$ 的查询阶段。这种设计是高效的，因为它避免了在处理多个读段时对静态参考字符串进行冗余计算。\n\n首先，我们必须将给定的转换形式化。\n字母表为 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$。\n正向转换 $\\varphi_{\\mathrm{fwd}} : \\Sigma^* \\to \\Sigma^*$ 模拟了正向链上的 $C \\to T$ 转换。它的定义是对字符串中的每个字符应用规则 $\\varphi_{\\mathrm{fwd}}(\\text{C}) = \\text{T}$，而其他字符保持不变。\n反向转换 $\\varphi_{\\mathrm{rev}} : \\Sigma^* \\to \\Sigma^*$ 模拟了反向互补链上的等效变化。正向链上一个未甲基化的 $C$ 对应于反向互补链上的一个鸟嘌呤（$G$）。测序时，这个 $C$ 显示为 $T$，其互补碱基是腺嘌呤（$A$）。因此，反向互补链上原始的 $G$ 实际上变成了 $A$。这通过规则 $\\varphi_{\\mathrm{rev}}(\\text{G}) = \\text{A}$ 来捕捉，并逐字符应用。\n反向互补操作 $\\rho : \\Sigma^* \\to \\Sigma^*$ 包括对每个碱基进行互补（$\\text{A} \\leftrightarrow \\text{T}$, $\\text{C} \\leftrightarrow \\text{G}$），然后反转得到的字符串。\n\n读段 $Q$ 相对于参考 $R$ 的候选集是 $R$ 中所有索引 $i$（$0 \\le i \\le |R|-k$）的集合，对于这些索引，存在一个从 $i$ 开始的 $R$ 的种子与一个 $Q$ 的种子在这些转换下匹配。具体来说，要包含索引 $i$，必须存在某个起始于 $Q$ 中索引 $j$（$0 \\le j \\le |Q|-k$）的种子，使得以下条件之一成立：\n1.  正向链匹配：$\\varphi_{\\mathrm{fwd}}\\big(Q[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{fwd}}\\big(R[i{:}i{+}k]\\big)$\n2.  反向互补链匹配：$\\varphi_{\\mathrm{rev}}\\big(\\rho(Q)[j{:}j{+}k]\\big) = \\varphi_{\\mathrm{rev}}\\big(R[i{:}i{+}k]\\big)$\n\n**阶段1：预处理参考字符串 $R$**\n\n为了加速匹配索引的搜索，我们首先处理来自参考字符串 $R = \\text{\"AGCCGTTAGCGTTCACCGTAGC\"}$（$k=4$）的所有 $k$-mers。我们生成两个查找表（哈希表或字典），将转换后的 $k$-mers 映射到它们在 $R$ 中原始的、从0开始的起始索引列表。\n\n设 $N_R = |R| = 22$。我们遍历所有可能的起始索引 $i$，从 $0$ 到 $N_R - k = 18$。对于每个索引 $i$，我们提取 $k$-mer $S_i = R[i:i+k]$。\n1.  我们计算正向转换后的 $k$-mer，$S'_i = \\varphi_{\\mathrm{fwd}}(S_i)$，并存储映射 $S'_i \\to i$。我们构建一个字典 `fwd_map`，其中的键是转换后的 $k$-mers，值是索引列表。\n2.  同样地，我们计算反向转换后的 $k$-mer，$S''_i = \\varphi_{\\mathrm{rev}}(S_i)$，并构建第二个字典 `rev_map` 来存储映射 $S''_i \\to i$。\n\n这个预处理步骤只执行一次。\n\n**阶段2：使用读段进行查询**\n\n对于提供的测试套件中的每个读段 $Q$，我们执行以下步骤来找到其索引候选集。\n\n1.  初始化一个空集合 `candidate_indices`，用于收集来自 $R$ 的唯一匹配索引。\n2.  首先处理一个简单情况：如果读段长度 $|Q|$ 小于种子长度 $k$，则无法形成 $k$-mers，根据问题定义，候选集为空。\n3.  **正向链搜索**：我们遍历所有可能的起始索引 $j$，从 $0$ 到 $|Q|-k$。对于每个索引 $j$，我们提取种子 $q_j = Q[j:j+k]$。我们使用 $\\varphi_{\\mathrm{fwd}}$ 转换这个种子得到 $q'_j = \\varphi_{\\mathrm{fwd}}(q_j)$。然后我们在我们预先计算的 `fwd_map` 中查找 $q'_j$。如果找到匹配项，我们将 `fwd_map[q'_j]` 中的所有索引添加到我们的 `candidate_indices` 集合中。\n4.  **反向互补链搜索**：我们首先计算整个读段的反向互补，$Q_{rc} = \\rho(Q)$。然后，我们遍历所有可能的起始索引 $j$，从 $0$ 到 $|Q_{rc}|-k$，提取每个种子 $q_{rc,j} = Q_{rc}[j:j+k]$。我们使用 $\\varphi_{\\mathrm{rev}}$ 转换这个种子得到 $q''_{rc,j} = \\varphi_{\\mathrm{rev}}(q_{rc,j})$。我们在我们的 `rev_map` 中查找 $q''_{rc,j}$。如果找到匹配项，我们将 `rev_map[q''_{rc,j}]` 中的所有索引添加到 `candidate_indices` 集合中。\n5.  **最终处理**：在考虑了读段及其反向互补的所有种子后，`candidate_indices` 集合包含了 $R$ 中所有唯一的匹配索引。我们将此集合转换为列表并按升序排序，以满足输出规格。\n\n对测试套件中的每个读段重复此过程。最终输出是每个读段的已排序索引列表的集合，并按指定格式化。使用哈希表使得步骤3和4中的搜索非常高效，每次查找的平均时间复杂度为 $O(1)$。", "answer": "```python\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the bisulfite-robust seeding problem.\n    This function implements the logic described in the solution, including\n    preprocessing the reference and then querying for each read.\n    \"\"\"\n    # Problem parameters and test suite\n    R = \"AGCCGTTAGCGTTCACCGTAGC\"\n    k = 4\n    reads = [\n        \"TTGT\",\n        \"AAAT\",\n        \"AT\",\n        \"AGTTTT\",\n        \"TAGT\",\n        \"GGGG\",\n    ]\n\n    # --- Helper Functions ---\n\n    def phi_fwd(s):\n        \"\"\"Applies the forward transformation (C -> T).\"\"\"\n        return s.replace('C', 'T')\n\n    def phi_rev(s):\n        \"\"\"Applies the reverse transformation (G -> A).\"\"\"\n        return s.replace('G', 'A')\n\n    def reverse_complement(s):\n        \"\"\"Computes the reverse complement of a DNA string.\"\"\"\n        comp_map = str.maketrans('AGCT', 'TCGA')\n        return s.translate(comp_map)[::-1]\n\n    # --- Phase 1: Preprocessing the Reference R ---\n\n    fwd_ref_map = collections.defaultdict(list)\n    rev_ref_map = collections.defaultdict(list)\n\n    if len(R) >= k:\n        for i in range(len(R) - k + 1):\n            kmer = R[i : i + k]\n            \n            # Map for forward strand matches\n            fwd_transformed_kmer = phi_fwd(kmer)\n            fwd_ref_map[fwd_transformed_kmer].append(i)\n            \n            # Map for reverse complement strand matches\n            rev_transformed_kmer = phi_rev(kmer)\n            rev_ref_map[rev_transformed_kmer].append(i)\n\n    # --- Phase 2: Processing each read Q ---\n\n    all_results = []\n    for q_str in reads:\n        candidate_indices = set()\n\n        # Handle case where read is shorter than seed length\n        if len(q_str) < k:\n            all_results.append([])\n            continue\n\n        # Condition 1: Forward strand check\n        for j in range(len(q_str) - k + 1):\n            q_kmer = q_str[j : j + k]\n            fwd_transformed_q_kmer = phi_fwd(q_kmer)\n            if fwd_transformed_q_kmer in fwd_ref_map:\n                candidate_indices.update(fwd_ref_map[fwd_transformed_q_kmer])\n        \n        # Condition 2: Reverse complement strand check\n        rc_q_str = reverse_complement(q_str)\n        for j in range(len(rc_q_str) - k + 1):\n            rc_q_kmer = rc_q_str[j : j + k]\n            rev_transformed_rc_q_kmer = phi_rev(rc_q_kmer)\n            if rev_transformed_rc_q_kmer in rev_ref_map:\n                candidate_indices.update(rev_ref_map[rev_transformed_rc_q_kmer])\n\n        all_results.append(sorted(list(candidate_indices)))\n\n    # --- Final Output Formatting ---\n    \n    # Format each inner list to \"[i1,i2,...]\" without spaces\n    inner_strs = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    \n    # Join the inner list strings into the final format \"[[...],[...]]\"\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2425351"}, {"introduction": "成功将一个读段比对到基因组上只是第一步，解读比对结果的可靠性同样至关重要。一个看似完美的比对（无错配）并不意味着它就是唯一且正确的位置，尤其当读段序列本身是低复杂度或重复的时。这项练习通过一个思想实验，探讨了比对模糊性的核心问题，并引入了比对质量值（MAPQ）这一关键的概率性指标，帮助你理解比对得分与比对置信度之间的根本区别[@problem_id:2425337]。", "problem": "一条长度为 $L$ 的单端DNA测序读段是周期性低复杂度字符串 $r=\\texttt{ATAT}\\dots$ (交替的 $\\texttt{A}$ 和 $\\texttt{T}$)，它与一个参考基因组中的多个位点以零错配的方式比对。假设当存在得分相同的比对结果时，读段比对器会在不使用关于位点独特性的外部先验信息的情况下，报告其中一个得分最高的比对结果。忽略测序错误。定位质量 (MAPQ) 定义为 $\\mathrm{MAPQ}=-10\\log_{10} P_{\\text{err}}$，其中 $P_{\\text{err}}$ 是报告的比对位置不正确的概率。\n\n这条读段是否应该获得一个高的MAPQ分数？请选择使用概率论证正确解释答案的选项。\n\nA. 是的。完美匹配意味着 $P_{\\text{err}}=0$，所以 $\\mathrm{MAPQ}$ 应该是最大的。\n\nB. 不是。如果对于 $r$ 有 $k$ 个同样好的基因组定位，而比对器报告了其中一个，那么 $P_{\\text{err}}=1-\\frac{1}{k}$，所以 $\\mathrm{MAPQ}=-10\\log_{10}\\!\\left(1-\\frac{1}{k}\\right)$，当 $k\\gg 1$ 时这个值很小。\n\nC. 是的。在测序错误可忽略的情况下， $P_{\\text{err}}\\approx 4^{-L}$，所以对于中等大小的 $L$，$\\mathrm{MAPQ}$ 会很高。\n\nD. 这只取决于 $L$。任何 $L\\ge 30$ 的完美匹配都应该获得 $\\mathrm{MAPQ}\\ge 30$，无论基因组的重复性如何。\n\nE. 不是。低复杂度读段本身具有更高的单位碱基错误率，即使序列完美匹配，这也会增加 $P_{\\text{err}}$。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤1：提取已知条件**\n- 测序读段是长度为 $L$ 的单端读段。\n- 读段序列是 $r=\\texttt{ATAT}\\dots$，一个周期性低复杂度字符串。\n- 读段与参考基因组中的多个位点以零错配的方式比对。\n- 当存在得分相同的比对结果时，比对器报告其中一个得分最高的。\n- 比对器不使用外部先验信息。\n- 测序错误被忽略。\n- 定位质量定义为 $\\mathrm{MAPQ}=-10\\log_{10} P_{\\text{err}}$。\n- $P_{\\text{err}}$ 是报告的比对位置不正确的概率。\n- 问题是这条读段是否应该获得一个高的 $\\mathrm{MAPQ}$ 分数，并用概率论证来解释。\n\n**步骤2：使用已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了生物信息学中一个常见且基本的情景：重复序列的定位。定位质量 ($\\mathrm{MAPQ}$) 的定义是标准的，正如在SAM/BAM等格式中使用的那样。诸如忽略测序错误和比对器在比对结果得分相同情况下的行为等假设都已明确说明，以便将问题简化为其核心的概率性质。该问题是自洽的，没有矛盾或歧义。\n\n**步骤3：判断与行动**\n问题有效。可以从所提供的信息中推导出严谨的解决方案。\n\n**解题推导**\n定位质量 $\\mathrm{MAPQ}$ 是衡量报告的比对位置即为读段来源的真实位置这一置信度的指标。其定义为 $\\mathrm{MAPQ}=-10\\log_{10} P_{\\text{err}}$，其中 $P_{\\text{err}}$ 是指定位不正确的概率。\n\n问题陈述读段 $r$ 与“多个位点”以零错配的方式比对。让我们将这些同样完美的比对位置的数量表示为 $k$。因为是“多个”位点，我们知道 $k > 1$。\n\n鉴于所有 $k$ 个比对都是完美的（零错配），并且问题指示我们忽略测序错误，这 $k$ 个位置中的每一个都是该读段同样可能的来源。比对器在没有任何其他信息或先验知识的情况下，没有理由偏好其中任何一个位置。因此，任何特定位点 $i$（其中 $i \\in \\{1, 2, \\dots, k\\}$）是读段真实来源的概率为 $\\frac{1}{k}$。\n\n比对器报告这 $k$ 个位置中的一个。我们称报告的位置为 $L_{rep}$。这个报告的位置是正确位置的概率为：\n$$ P(\\text{correct}) = P(L_{rep} \\text{ is true origin}) = \\frac{1}{k} $$\n错误概率 $P_{\\text{err}}$ 是报告的位置*不是*真实来源的概率。这是 $P(\\text{correct})$ 的补集：\n$$ P_{\\text{err}} = 1 - P(\\text{correct}) = 1 - \\frac{1}{k} = \\frac{k-1}{k} $$\n现在，我们可以计算 $\\mathrm{MAPQ}$ 分数：\n$$ \\mathrm{MAPQ} = -10\\log_{10} P_{\\text{err}} = -10\\log_{10}\\left(1 - \\frac{1}{k}\\right) $$\n让我们分析这个表达式。由于读段比对到多个位点，因此 $k \\ge 2$。\n- 如果 $k=2$，$P_{\\text{err}} = 1 - \\frac{1}{2} = 0.5$。$\\mathrm{MAPQ} = -10\\log_{10}(0.5) \\approx -10(-0.301) \\approx 3$。\n- 如果 $k=10$，$P_{\\text{err}} = 1 - \\frac{1}{10} = 0.9$。$\\mathrm{MAPQ} = -10\\log_{10}(0.9) \\approx -10(-0.046) \\approx 0.46$。\n- 当 $k \\to \\infty$ 时，$P_{\\text{err}} \\to 1$，并且 $\\mathrm{MAPQ} \\to 0$。\n\n在所有 $k>1$ 的情况下，$\\mathrm{MAPQ}$ 分数都是一个小的正数。$\\mathrm{MAPQ}$ 为 $3$ 对应 $50\\%$ 的错误几率，这是一个极低的置信度。一个接近 $0$ 的 $\\mathrm{MAPQ}$ 分数表示几乎可以肯定定位是错误的（或者更准确地说，报告的比对结果是从大量同样好的候选中任意选择的）。因此，一个能定位到多个位置的低复杂度读段不应该获得高的 $\\mathrm{MAPQ}$ 分数。\n\n**逐项分析**\n\nA. 是的。完美匹配意味着 $P_{\\text{err}}=0$，所以 $\\mathrm{MAPQ}$ 应该是最大的。\n这个说法不正确。一个完美匹配并不意味着唯一匹配。问题的核心在于存在多个完美匹配。存在多个同样好的比对（$k>1$）意味着单个报告的比对是正确的概率为 $\\frac{1}{k} < 1$，因此 $P_{\\text{err}} = 1 - \\frac{1}{k} > 0$。完美匹配意味着 $P_{\\text{err}}=0$ 的前提是错误的。**不正确**。\n\nB. 不是。如果对于 $r$ 有 $k$ 个同样好的基因组定位，而比对器报告了其中一个，那么 $P_{\\text{err}}=1-\\frac{1}{k}$，所以 $\\mathrm{MAPQ}=-10\\log_{10}\\!\\left(1-\\frac{1}{k}\\right)$，当 $k\\gg 1$ 时这个值很小。\n这个说法准确地反映了上面的概率推理。它正确地指出，有 $k$ 个同样好的定位时，单个报告的比对的错误概率是 $1 - \\frac{1}{k}$。它正确地计算了由此产生的 $\\mathrm{MAPQ}$，并正确地得出结论，即这个值很小，特别是当重复次数很多时（$k\\gg 1$）。最终答案“不是”也与推导一致。**正确**。\n\nC. 是的。在测序错误可忽略的情况下， $P_{\\text{err}}\\approx 4^{-L}$，所以对于中等大小的 $L$，$\\mathrm{MAPQ}$ 会很高。\n这个说法不正确。值 $4^{-L}$ 代表在一个随机位置偶然出现一个特定长度为 $L$ 的序列的概率，这是在假设核苷酸独立同分布且频率相等模型下的情况。这是一个随机匹配概率的模型，而不是经验定位错误概率 $P_{\\text{err}}$。$P_{\\text{err}}$ 必须根据在给定参考基因组中找到的实际高质量比对位点的数量来计算。问题明确指出存在多个这样的位点，而这个选项忽略了这一点。**不正确**。\n\nD. 这只取决于 $L$。任何 $L\\ge 30$ 的完美匹配都应该获得 $\\mathrm{MAPQ}\\ge 30$，无论基因组的重复性如何。\n这个说法不正确。$\\mathrm{MAPQ}$ 根本上取决于定位的独特性，而不仅仅是读段长度 $L$。一个非常长的读段（例如，$L=500$）如果由重复的二核苷酸 $\\texttt{AT}$ 组成，仍然可能在一个大的真核生物基因组中定位到数千个位置。在这种情况下，$k$ 会非常大，$P_{\\text{err}}$ 会接近 $1$，而 $\\mathrm{MAPQ}$ 会接近 $0$。声称 $\\mathrm{MAPQ}$ 很高而不管重复性如何，这直接与其定义相矛盾。**不正确**。\n\nE. 不是。低复杂度读段本身具有更高的单位碱基错误率，即使序列完美匹配，这也会增加 $P_{\\text{err}}$。\n这个说法在问题的背景下是不正确的。问题明确指示我们“忽略测序错误”。因此，引入一个基于内在错误率的论点违反了问题的前提。此外，其逻辑是混乱的：如果序列完美匹配，意味着在比对中没有观察到错误，因此，根据给定的比对结果来计算 $P_{\\text{err}}$ 时，推测潜在的错误率是无关的。**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2425337"}]}