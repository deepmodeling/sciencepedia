{"hands_on_practices": [{"introduction": "本练习将指导你从头开始构建一个基于规则的 tRNA 基因查找器。通过将 tRNA 分子保守的“三叶草”二级结构特征（例如，受体臂和反密码子环）转化为具体的算法步骤，你将掌握将生物学知识转化为计算解决方案的核心技能。这个过程不仅能加深你对 tRNA 结构的理解，还能让你通过计算精确率 ($precision$) 和召回率 ($recall$) 等指标，学习如何评估生物信息学工具的性能 [@problem_id:2438434]。", "problem": "你的任务是实现一个完整、可运行的程序，给定一个由合成脱氧核糖核酸（DNA）序列组成的小型固定测试套件，该程序需要执行基于规则的转运RNA（tRNA）基因预测，并将其性能与一个由 transfer RNA scan - Search Engine (tRNAscan-SE) 提供的基线进行比较。程序必须以单一、指定的输出格式报告两种方法在每个测试用例上的精确率和召回率。\n\n解决方案必须基于以下基本原理和广泛接受的生物学事实：\n- 分子生物学的中心法则指出，遗传信息从DNA流向核糖核酸（RNA），再到蛋白质。转运RNA（tRNA）基因编码结构化的RNA分子，这些分子折叠成具有保守特征的三叶草结构，包括在 $5^{\\prime}$ 和 $3^{\\prime}$ 末端之间进行碱基配对的接受臂、一个大小近似固定的环的反密码子臂，以及一个 T$\\Psi$C环基序，其在DNA水平上的基序通常表现为三核苷酸 \"TTC\"。\n- 经典的 Watson–Crick 碱基配对在DNA中是 $A$–$T$ 和 $C$–$G$，而RNA中的摆动配对通常涉及 $G$–$U$；为了适应在DNA中的启发式检测，我们在结构检查期间将允许 $G$–$T$ 作为一种额外的可容忍配对。\n\n你的程序必须实现一个简单的、基于规则的tRNA基因查找器，它会扫描一个DNA字符串，并基于以下三个启发式特征提出候选基因区间：\n1) 反密码子发夹：检测一个发夹结构，其茎长度为 $s = 5$ 个核苷酸，环绕一个长度为 $\\ell = 7$ 个核苷酸的环。两个茎在配对规则 $\\{A\\text{–}T, T\\text{–}A, C\\text{–}G, G\\text{–}C, G\\text{–}T, T\\text{–}G\\}$ 下必须是反向互补的，最多允许 $m_s = 1$ 个错配。\n2) T$\\Psi$C环DNA基序：要求基序 \"TTC\" 出现在候选窗口的最后 $d = 20$ 个核苷酸内（即在窗口末端的上游）。\n3) 接受臂：在候选窗口内，要求最初的 $a = 7$ 个核苷酸和最后的 $a = 7$ 个核苷酸（或者如果 \"CCA\" 出现在窗口的最末尾，则为紧邻 \"CCA\" 前面的7个核苷酸）在相同的配对规则下是反向互补的，最多允许 $m_a = 1$ 个错配。\n\n候选窗口必须根据每个检测到的发夹按如下方式形成：如果左茎起始于索引 $i_{\\ell}$，右茎结束于索引 $i_{r}$（末端不含），则定义一个窗口 $[i_{\\ell} - w,\\, i_{r} + w)$，并裁剪至序列边界，其中 $w = 25$。丢弃长度在 $[60, 100]$ 个核苷酸范围之外的候选窗口。如果多个候选窗口有大量重叠，则通过将 Jaccard 重叠度大于 $0.8$ 的任意 زوج 合并为其并集区间来进行去重。\n\n在评估时，将每个预测区间视为一个索引集合，并使用 Jaccard 重叠度\n$$\nJ(I_p, I_t) \\;=\\; \\frac{|I_p \\cap I_t|}{|I_p \\cup I_t|}\n$$\n来将预测区间 $I_p$ 与真实区间 $I_t$ 进行匹配。如果一个预测与任何尚未匹配的真实区间的匹配度 $J \\ge \\tau$（其中 $\\tau = 0.5$），则该预测计为一个真阳性。否则，它是一个假阳性。任何未被任何预测匹配的真实区间都是一个假阴性。定义标准的计数：真阳性（$\\mathrm{TP}$）、假阳性（$\\mathrm{FP}$）和假阴性（$\\mathrm{FN}$）。精确率和召回率则为：\n$$\n\\text{precision} \\;=\\; \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}, \\qquad\n\\text{recall} \\;=\\; \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}.\n$$\n使用此惯例：如果 $\\mathrm{TP} + \\mathrm{FP} = 0$，则精确率定义为 $1.0$；如果 $\\mathrm{TP} + \\mathrm{FN} = 0$，则召回率定义为 $1.0$。\n\n坐标是基于零的半开区间 $[s,e)$，其中 $s$ 是起始索引，$e$ 是最后一个索引之后的位置，这与标准编程中的字符串切片一致。\n\n你的程序必须为每个测试用例计算你实现的基于规则的查找器的精确率和召回率，以及归因于 transfer RNA scan - Search Engine (tRNAscan-SE) 的给定基线预测的精确率和召回率。所有字符串操作都基于DNA字母表 $\\{A, C, G, T\\}$。不涉及任何物理单位。\n\n测试套件（三个序列），每个提供以下内容：\n- DNA 序列字符串。\n- tRNA 基因的真实区间，以 $[s,e)$ 的列表形式表示。\n- 基线区间（归因于 tRNAscan-SE），以 $[s,e)$ 的列表形式表示。\n\n请精确使用以下序列和注释：\n\n案例1（常规顺利路径）：\n- 序列：\n\"TTGACCGTTTGACCGTTTGACCGTTTGACCGTTTGACCGTGCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGTTCGAATGCTAAGCCCA\" + \"GATCGATCGAGATCGATCGAGATCGATCGA\"\n- 真实值：[[40, 116]]。\n- 基线 (tRNAscan-SE)：[[40, 116]]。\n\n案例2（边界条件：基因位于起始位置，无编码的CCA，缺失具有挑战性的T环基序）：\n- 序列：\n\"GCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGAAAGAATGCTAAGC\" + \"GCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGT\"\n- 真实值：[[0, 73]]。\n- 基线 (tRNAscan-SE)：[[0, 73]]。\n\n案例3（边缘情况：无真实tRNA，存在一个类似tRNA的诱饵基序）：\n- 序列：\n\"AACCGGTTAACCGGTTAACC\" + \"ATGCCGAAAGGGGATCGACCGTATGAATTTTACGGATCGAATCGAAAGCAGTAGGTTCGAATTCGGCATCCA\" + \"GATCGATCGATCGATCGATCGATC\"\n- 真实值：[]。\n- 基线 (tRNAscan-SE)：[]。\n\n程序输出规范：\n- 对于案例1、2、3中的每一个，按顺序计算四个浮点数，并四舍五入到恰好三位小数：你的方法的精确率、你的方法的召回率、基线的精确率和基线的召回率。\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[\\text{P}_{1}, \\text{R}_{1}, \\text{P}^{\\mathrm{base}}_{1}, \\text{R}^{\\mathrm{base}}_{1}, \\text{P}_{2}, \\text{R}_{2}, \\text{P}^{\\mathrm{base}}_{2}, \\text{R}^{\\mathrm{base}}_{2}, \\text{P}_{3}, \\text{R}_{3}, \\text{P}^{\\mathrm{base}}_{3}, \\text{R}^{\\mathrm{base}}_{3}]$。\n\n输出中的所有数字都是无单位的实数，表示为四舍五入到小数点后三位的十进制字符串。不得打印任何额外文本。", "solution": "所提出的问题是生物信息学领域中一个明确定义的任务，特别是在基于规则的转运RNA（tRNA）基因预测领域。目标是实现一个特定的、简化的算法，用于在合成DNA序列中识别tRNA基因，并根据给定的真实值和基线预测集来评估其性能。\n\n### 问题验证\n\n问题陈述已经过验证，并被认为是**有效的**。验证过程的详细分解如下。\n\n**步骤1：提取已知条件**\n所有参数、定义和数据均从问题陈述中逐字提取：\n- **启发式特征**：\n    1.  反密码子发夹：茎长度 $s=5$，环长度 $\\ell=7$，茎中最多允许 $m_s=1$ 个错配。\n    2.  T$\\Psi$C环基序：DNA序列“TTC”必须出现在候选窗口的最后 $d=20$ 个核苷酸内。\n    3.  接受臂：由窗口的第一个和最后一个 $a=7$ 个核苷酸组成，最多允许 $m_a=1$ 个错配。如果窗口以“CCA”结尾，则适用特殊条件。\n- **配对规则**：Watson-Crick配对（$A$–$T$, $C$–$G$）加上类摆动配对（$G$–$T$）。\n- **候选生成**：围绕一个发夹结构形成一个 $[i_{\\ell} - w, i_{r} + w)$（其中 $w=25$）的窗口，筛选长度在 $[60, 100]$ 范围内的窗口，并在Jaccard重叠度超过 $0.8$ 时进行去重。\n- **评估**：性能通过精确率和召回率来衡量，其中匹配由Jaccard重叠度阈值 $\\tau = 0.5$ 确定。如果精确率和召回率各自的分母为零，则它们被定义为 $1.0$。\n- **数据**：提供了三个测试用例，每个用例都包含一个DNA序列、真实值区间和基线预测区间。\n\n**步骤2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估：\n- **有科学依据**：是。该问题使用了一个简化的、但在生物学上合理的tRNA二级结构（三叶草）模型及其保守特征。基于模式匹配和启发式方法的算法途径是生物信息学中的标准技术。\n- **定义明确**：是。算法规则以完整、明确的参数指定。输入已提供，期望的输出格式也很精确。可以推导出唯一的解决方案。\n- **客观的**：是。问题以精确、量化的术语陈述，不含主观性。\n\n**潜在矛盾分析**：\n仔细检查发现，在某些测试用例中提供的真实值注释不满足要实现的搜索规则。例如：\n- 在案例1中，真实值基因 $[40, 116)$ 未通过指定的接受臂互补性规则（允许最多 $m_a=1$ 个错配，但实际有4个错配）。\n- 在案例2中，真实值基因 $[0, 73)$ 未通过T$\\Psi$C环基序规则，因为在所需区域内缺少“TTC”序列。\n\n这不是一个使问题无效的缺陷。相反，这被解释为问题设计的一个刻意特点。任务不是创建一个能完美重新发现“真实”注释的算法，而是精确地实现指定的规则集，然后评估其性能。这种差异凸显了简单的启发式模型相对于更复杂的现实（或像tRNAscan-SE这样更复杂的预测工具）的局限性，这是一个宝贵的科学教训。该问题仍然是一个一致的、可解决的挑战。\n\n**步骤3：结论与行动**\n问题是**有效的**。解决方案将按规定继续实现该算法。\n\n### 算法解决方案设计\n\n该解决方案被实现为一个系统化的流水线，将提供的规则转化为不同的计算步骤。\n\n1.  **基本数据结构与规则**：\n    -   核苷酸配对规则 $\\{A\\text{–}T, T\\text{–}A, C\\text{–}G, G\\text{–}C, G\\text{–}T, T\\text{–}G\\}$ 被编码到一个查找结构中，以便高效访问。\n    -   定义了一个辅助函数 `count_mismatches(seq1, seq2_rev)`，用于根据这些配对规则量化两个茎序列之间的互补性。\n\n2.  **步骤1：反密码子发夹检测**：\n    程序扫描整个DNA序列以寻找潜在的反密码子发夹。发夹被定义为一个长度为 $s+\\ell+s = 5+7+5 = 17$ 个核苷酸的结构。对于每个这种长度的子序列，将其前 $5$ 个核苷酸（左茎）与后 $5$ 个核苷酸（右茎）的反向序列进行比较。如果错配数小于或等于 $m_s=1$，则记录该发夹的起始和结束位置。\n\n3.  **步骤2：候选窗口生成与初步筛选**：\n    对于每个检测到的有效发夹，提议一个更宽的候选窗口。如果发夹位于 $[i_{\\ell}, i_{r})$，则初始窗口定义为 $[i_{\\ell} - w, i_{r} + w)$，其中 $w=25$。这些坐标会被裁剪至DNA序列的边界。检查每个结果窗口的长度，只保留长度在 $[60, 100]$ 范围内的窗口进行进一步处理。\n\n4.  **步骤3：候选去重**：\n    为了处理冗余、重叠的候选，执行去重步骤。这被建模为一个图问题。每个候选窗口是一个节点，如果任意两个节点的Jaccard重叠度大于 $0.8$，则在它们之间画一条边。然后识别该图的连通分量。单个分量内的所有候选窗口被合并成一个超区间，该区间由该分量中所有区间的最小起始坐标和最大结束坐标定义。这样就产生了一组非冗余的候选区域。\n\n5.  **步骤4：最终基于特征的筛选**：\n    合并后的候选窗口将接受最后两个启发式检查：\n    - **T$\\Psi$C环基序**：在每个候选序列的最后 $d=20$ 个核苷酸中搜索是否存在“TTC”基序。如果基序不存在，则丢弃该候选。\n    - **接受臂**：将前 $a=7$ 个核苷酸与后 $a=7$ 个核苷酸进行反向互补性比较。特殊情况处理以“CCA”结尾的窗口，其中 $3^{\\prime}$ 茎取自紧邻“CCA”之前的 $7$ 个核苷酸。如果错配数 $m_a$ 超过 $1$，则丢弃该候选。\n\n6.  **步骤5：性能评估**：\n    将基于规则的查找器产生的最终预测区间集和提供的基线区间集分别与真实值进行评估。\n    - 计算真阳性（$\\mathrm{TP}$）、假阳性（$\\mathrm{FP}$）和假阴性（$\\mathrm{FN}$）。如果一个预测与一个真实区间的Jaccard重叠度至少为 $\\tau=0.5$，则它们匹配。为了确保最优的一对一映射，采用了一种贪心匹配策略，其中预测区间和真实区间的配对按其Jaccard分数的降序进行匹配。\n    - 计算精确率（$\\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$）和召回率（$\\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}$）。问题规定，如果一个指标的分母为 $0$，则其值为 $1.0$。\n\n整个过程应用于三个测试用例中的每一个，每个案例产生的四个性能指标（实现的查找器和基线的精确率与召回率）被收集并格式化以用于最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a rule-based tRNA gene finder and evaluates its performance\n    against a baseline on a fixed test suite.\n    \"\"\"\n\n    # -- Constants from problem statement --\n    S_STEM = 5\n    L_LOOP = 7\n    M_S_MISMATCH = 1\n    D_TLOOP = 20\n    A_STEM = 7\n    M_A_MISMATCH = 1\n    W_EXTEND = 25\n    MIN_LEN = 60\n    MAX_LEN = 100\n    JACCARD_MERGE_THRESH = 0.8\n    JACCARD_EVAL_THRESH = 0.5\n    \n    # -- Base pairing rules as specified --\n    PAIRS = {\n        ('A', 'T'), ('T', 'A'),\n        ('C', 'G'), ('G', 'C'),\n        ('G', 'T'), ('T', 'G')\n    }\n\n    def is_complementary(n1, n2):\n        \"\"\"Checks if two nucleotides are complementary.\"\"\"\n        return (n1, n2) in PAIRS\n\n    def count_mismatches(seq1, seq2_rev):\n        \"\"\"Counts mismatches between a sequence and a reversed sequence.\"\"\"\n        mismatches = 0\n        for n1, n2 in zip(seq1, seq2_rev):\n            if not is_complementary(n1, n2):\n                mismatches += 1\n        return mismatches\n\n    def jaccard_overlap(interval1, interval2):\n        \"\"\"Calculates Jaccard overlap between two [start, end) intervals.\"\"\"\n        s1, e1 = interval1\n        s2, e2 = interval2\n        \n        intersection_start = max(s1, s2)\n        intersection_end = min(e1, e2)\n        \n        intersection_size = max(0, intersection_end - intersection_start)\n            \n        union_size = (e1 - s1) + (e2 - s2) - intersection_size\n        \n        if union_size == 0:\n            return 1.0 if intersection_size > 0 else 0.0\n        \n        return intersection_size / union_size\n\n    def evaluate_predictions(predicted, true_intervals):\n        \"\"\"Calculates precision and recall.\"\"\"\n        # Handle cases with empty sets as per problem definition\n        if not true_intervals:\n            # TP=0, FN=0 -> Recall = 1.0\n            # If nothing predicted, FP=0 -> Precision = 1.0\n            # If something predicted, FP > 0 -> Precision = 0.0\n            return 1.0 if not predicted else 0.0, 1.0\n        if not predicted: # True intervals exist, but no predictions\n            # TP=0, FP=0 -> Precision = 1.0\n            # TP=0, FN>0 -> Recall = 0.0\n            return 1.0, 0.0\n\n        n_pred = len(predicted)\n        n_true = len(true_intervals)\n        \n        # Greedily find best matches to solve assignment problem\n        potential_matches = []\n        for i, p_interval in enumerate(predicted):\n            for j, t_interval in enumerate(true_intervals):\n                j_score = jaccard_overlap(p_interval, t_interval)\n                if j_score >= JACCARD_EVAL_THRESH:\n                    potential_matches.append((j_score, i, j))\n        \n        potential_matches.sort(key=lambda x: x[0], reverse=True)\n        \n        matched_preds = set()\n        matched_trues = set()\n        tp = 0\n        \n        for _, p_idx, t_idx in potential_matches:\n            if p_idx not in matched_preds and t_idx not in matched_trues:\n                tp += 1\n                matched_preds.add(p_idx)\n                matched_trues.add(t_idx)\n\n        fp = n_pred - tp\n        fn = n_true - tp\n        \n        precision = 1.0 if (tp + fp) == 0 else tp / (tp + fp)\n        recall = 1.0 if (tp + fn) == 0 else tp / (tp + fn)\n        \n        return precision, recall\n\n    def run_finder(sequence):\n        \"\"\"Executes the full tRNA finding algorithm.\"\"\"\n        seq_len = len(sequence)\n        \n        # 1. Anticodon hairpin detection\n        hairpins = []\n        hairpin_len = S_STEM + L_LOOP + S_STEM\n        for i in range(seq_len - hairpin_len + 1):\n            left_stem = sequence[i : i + S_STEM]\n            right_stem_rev = sequence[i + S_STEM + L_LOOP : i + hairpin_len][::-1]\n            \n            if count_mismatches(left_stem, right_stem_rev) = M_S_MISMATCH:\n                hairpins.append((i, i + hairpin_len))\n\n        # 2. Candidate window formation and length filtering\n        candidates = []\n        for start_pos, end_pos in hairpins:\n            win_start = max(0, start_pos - W_EXTEND)\n            win_end = min(seq_len, end_pos + W_EXTEND)\n            \n            if MIN_LEN = (win_end - win_start) = MAX_LEN:\n                candidates.append([win_start, win_end])\n        \n        if not candidates:\n            return []\n        \n        # 3. Deduplication via connected components\n        num_candidates = len(candidates)\n        adj = [[] for _ in range(num_candidates)]\n        for i in range(num_candidates):\n            for j in range(i + 1, num_candidates):\n                if jaccard_overlap(candidates[i], candidates[j]) > JACCARD_MERGE_THRESH:\n                    adj[i].append(j)\n                    adj[j].append(i)\n        \n        visited = [False] * num_candidates\n        dedup_candidates = []\n        for i in range(num_candidates):\n            if not visited[i]:\n                component_indices = []\n                q = [i]\n                visited[i] = True\n                head = 0\n                while head  len(q):\n                    u = q[head]; head += 1\n                    component_indices.append(u)\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                \n                min_start = min(candidates[k][0] for k in component_indices)\n                max_end = max(candidates[k][1] for k in component_indices)\n                dedup_candidates.append([min_start, max_end])\n\n        # 4. Final filtering based on features\n        final_predictions = []\n        for start, end in dedup_candidates:\n            # T-loop motif filter\n            t_loop_search_region = sequence[max(start, end - D_TLOOP):end]\n            if \"TTC\" not in t_loop_search_region:\n                continue\n            \n            # Acceptor stem filter\n            window_slice = sequence[start:end]\n            if len(window_slice)  A_STEM * 2:\n                continue\n\n            stem5_prime = window_slice[:A_STEM]\n            \n            if window_slice.endswith(\"CCA\"):\n                stem3_prime_start_in_slice = len(window_slice) - 3 - A_STEM\n                stem3_prime_end_in_slice = len(window_slice) - 3\n                if stem3_prime_start_in_slice  0: continue\n                stem3_prime = window_slice[stem3_prime_start_in_slice:stem3_prime_end_in_slice]\n            else:\n                stem3_prime = window_slice[-A_STEM:]\n            \n            stem3_prime_rev = stem3_prime[::-1]\n            if len(stem5_prime) != len(stem3_prime_rev): continue\n\n            if count_mismatches(stem5_prime, stem3_prime_rev) = M_A_MISMATCH:\n                final_predictions.append([start, end])\n                \n        return final_predictions\n\n    # -- Test Suite Definition --\n    test_cases = [\n        {\n            \"seq\": \"TTGACCGTTTGACCGTTTGACCGTTTGACCGTTTGACCGTGCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGTTCGAATGCTAAGCCCAGATCGATCGAGATCGATCGAGATCGATCGA\",\n            \"true\": [[40, 116]],\n            \"base\": [[40, 116]]\n        },\n        {\n            \"seq\": \"GCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGAAAGAATGCTAAGCGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGT\",\n            \"true\": [[0, 73]],\n            \"base\": [[0, 73]]\n        },\n        {\n            \"seq\": \"AACCGGTTAACCGGTTAACCATGCCGAAAGGGGATCGACCGTATGAATTTTACGGATCGAATCGAAAGCAGTAGGTTCGAATTCGGCATCCAGATCGATCGATCGATCGATC\",\n            \"true\": [],\n            \"base\": []\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        my_predictions = run_finder(case[\"seq\"])\n        \n        my_prec, my_rec = evaluate_predictions(my_predictions, case[\"true\"])\n        base_prec, base_rec = evaluate_predictions(case[\"base\"], case[\"true\"])\n        \n        all_results.extend([my_prec, my_rec, base_prec, base_rec])\n\n    formatted_results = [f\"{x:.3f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2438434"}, {"introduction": "在识别出 tRNA 结构之后，一个更深层次的问题是：是什么使得这些结构能够稳定存在？本练习通过一个简化的热力学模型，让你亲手计算 RNA 发夹环结构的折叠自由能 $\\Delta E$。你将分析单个核苷酸多态性 (SNP) 如何通过影响碱基配对或破坏稳定的基序 (motif) 来改变结构的稳定性，从而深刻理解 RNA 结构背后的物理化学原理 [@problem_id:2438407]。", "problem": "给定一个简化的、自洽的热力学模型，用于近似计算转移核糖核酸（tRNA）发夹结构的D-茎和D-环亚结构的折叠自由能，其灵感来源于 `RNAfold` 等折叠预测器所使用的能量函数。考虑一个由左臂、一个环和一个右臂组成的发夹结构。设左臂是长度为 $k$ 的核苷酸序列，环是长度为 $L \\geq 3$ 的核苷酸序列，右臂是长度为 $k$ 的核苷酸序列。碱基配对按位置发生，形式为 $(\\text{left}[i], \\text{right}[k+1-i])$，其中 $i \\in \\{1,\\dots,k\\}$，索引是基于1的。单核苷酸多态性（SNP）是指在环区的指定（基于1的）位置上，恰好一个核苷酸发生改变。\n\n将总折叠自由能 $E$（单位：千卡/摩尔）定义为\n$$\nE = \\sum_{i=1}^{k} e_{\\text{pair}}\\big(\\text{left}[i], \\text{right}[k+1-i]\\big) + e_{\\text{loop}}(\\text{loop}) + e_{\\text{terminal}}\\big(\\text{left}[k], \\text{right}[1]\\big),\n$$\n其中：\n- $e_{\\text{pair}}(x,y)$ 是碱基对的贡献，其值如下（单位均为千卡/摩尔）：\n  - $e_{\\text{pair}}(\\text{G},\\text{C}) = -3.0$, $e_{\\text{pair}}(\\text{C},\\text{G}) = -3.0$,\n  - $e_{\\text{pair}}(\\text{A},\\text{U}) = -2.0$, $e_{\\text{pair}}(\\text{U},\\text{A}) = -2.0$,\n  - $e_{\\text{pair}}(\\text{G},\\text{U}) = -1.0$, $e_{\\text{pair}}(\\text{U},\\text{G}) = -1.0$,\n  - 对于任何其他碱基对 $e_{\\text{pair}}(x,y) = +5.0$.\n- $e_{\\text{loop}}(\\text{loop})$ 是环起始罚分加上对稳定四核苷酸环基序的任何序列依赖性奖励：\n  $$\n  e_{\\text{loop}}(\\text{loop}) = a + b \\cdot L + c_{\\text{motif}}(\\text{loop}),\n  $$\n  其中 $a = 3.0$ 且 $b = 0.4$（单位均为千卡/摩尔），并且\n  $$\n  c_{\\text{motif}}(\\text{loop}) =\n  \\begin{cases}\n  -2.0,  \\text{若 } L = 4 \\text{ 且环匹配 GNRA 基序 (}\\text{G}\\ \\text{N}\\ \\text{R}\\ \\text{A}\\text{) 或 UNCG 基序 (}\\text{U}\\ \\text{N}\\ \\text{C}\\ \\text{G}\\text{)}, \\\\\n  0.0,  \\text{其他情况}.\n  \\end{cases}\n  $$\n  此处，$\\text{N}$ 表示 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{U}\\}$ 中的任意核苷酸，$\\text{R}$ 表示 $\\{\\text{A}, \\text{G}\\}$ 中的任意嘌呤。\n- $e_{\\text{terminal}}(x,y)$ 是基于闭合碱基对 $(\\text{left}[k], \\text{right}[1])$ 施加的末端闭合罚分：\n  $$\n  e_{\\text{terminal}}(x,y) =\n  \\begin{cases}\n  +0.5,  \\text{若 } (x,y) \\in \\{(\\text{A},\\text{U}),(\\text{U},\\text{A}),(\\text{G},\\text{U}),(\\text{U},\\text{G})\\}, \\\\\n  0.0,  \\text{其他情况}.\n  \\end{cases}\n  $$\n\n对于每种情况，设野生型序列由 $(\\text{left}, \\text{loop}, \\text{right})$ 定义，突变型序列与之完全相同，仅在环区的指定位置有一个单核苷酸变化。对每种情况，计算折叠自由能的变化\n$$\n\\Delta E = E_{\\text{mut}} - E_{\\text{wt}},\n$$\n单位为千卡/摩尔。报告的 $\\Delta E$ 值需四舍五入到恰好3位小数。以千卡/摩尔为单位作答。\n\n您的程序必须硬编码以下测试套件，并按指定顺序计算结果：\n\n- 情况1（顺利路径；破坏一个稳定的四核苷酸环）：\n  - left = \"GGG\"，loop = \"GAAA\"，right = \"CCC\"，SNP 位置 = $3$，突变核苷酸 = \"C\"。\n- 情况2（形成一个稳定的四核苷酸环）：\n  - left = \"GCG\"，loop = \"GAUA\"，right = \"CGC\"，SNP 位置 = $3$，突变核苷酸 = \"A\"。\n- 情况3（边界环长度且无变化）：\n  - left = \"GCGC\"，loop = \"AUG\"，right = \"GCGC\"，SNP 位置 = $2$，突变核苷酸 = \"U\"。\n- 情况4（存在末端AU罚分；无基序变化）：\n  - left = \"GCA\"，loop = \"CCAUUG\"，right = \"UGC\"，SNP 位置 = $4$，突变核苷酸 = \"G\"。\n\n您的程序应产生单行输出，其中包含一个方括号括起来的、以逗号分隔的结果列表，顺序与上述情况一致，例如：“[x1,x2,x3,x4]”。每个 $x_i$ 必须是格式化为恰好3位小数的浮点数。不允许有任何额外输出。", "solution": "该问题要求计算一个模型RNA发夹结构因其环区发生单核苷酸多态性（SNP）而引起的折叠自由能变化 $\\Delta E$。总自由能 $E$ 由三个不同部分的贡献之和给出：\n$$\nE = E_{\\text{stem}} + E_{\\text{loop}} + E_{\\text{terminal}}\n$$\n其中\n$$\nE_{\\text{stem}} = \\sum_{i=1}^{k} e_{\\text{pair}}\\big(\\text{left}[i], \\text{right}[k+1-i]\\big)\n$$\n$$\nE_{\\text{loop}} = e_{\\text{loop}}(\\text{loop}) = a + b \\cdot L + c_{\\text{motif}}(\\text{loop})\n$$\n$$\nE_{\\text{terminal}} = e_{\\text{terminal}}\\big(\\text{left}[k], \\text{right}[1]\\big)\n$$\n自由能变化 $\\Delta E$ 定义为突变型能量与野生型能量之差：\n$$\n\\Delta E = E_{\\text{mut}} - E_{\\text{wt}}\n$$\n我们可以将其表示为：\n$$\n\\Delta E = (E_{\\text{stem,mut}} + E_{\\text{loop,mut}} + E_{\\text{terminal,mut}}) - (E_{\\text{stem,wt}} + E_{\\text{loop,wt}} + E_{\\text{terminal,wt}})\n$$\n首先必须做出一个关键的观察。问题陈述SNP是“在环区中恰好一个核苷酸的改变”。这意味着对于野生型和突变型结构，其茎区的左臂和右臂序列是相同的。这对计算有深远的影响。\n\n1.  茎能量项 $E_{\\text{stem}}$ 仅是 `left` 和 `right` 臂序列的函数。由于这些序列保持不变，因此 $E_{\\text{stem,mut}} = E_{\\text{stem,wt}}$。\n2.  末端罚分 $E_{\\text{terminal}}$ 是闭合碱基对 $(\\text{left}[k], \\text{right}[1])$ 的函数，而该碱基对是未改变的茎区的一部分。因此，$E_{\\text{terminal,mut}} = E_{\\text{terminal,wt}}$。\n\n通过代入这些等式，$\\Delta E$ 的表达式显著简化：\n$$\n\\Delta E = (E_{\\text{stem,wt}} + E_{\\text{loop,mut}} + E_{\\text{terminal,wt}}) - (E_{\\text{stem,wt}} + E_{\\text{loop,wt}} + E_{\\text{terminal,wt}})\n$$\n$$\n\\Delta E = E_{\\text{loop,mut}} - E_{\\text{loop,wt}}\n$$\n现在，我们来研究环能量项 $e_{\\text{loop}}(\\text{loop}) = a + b \\cdot L + c_{\\text{motif}}(\\text{loop})$。SNP是一种替换，它不改变环的长度 $L$。因此，$L_{\\text{mut}} = L_{\\text{wt}} = L$。参数 $a=3.0$ 和 $b=0.4$ 是常数。这导致了进一步的简化：\n$$\n\\Delta E = (a + b \\cdot L + c_{\\text{motif}}(\\text{loop}_{\\text{mut}})) - (a + b \\cdot L + c_{\\text{motif}}(\\text{loop}_{\\text{wt}}))\n$$\n$a$ 和 $b \\cdot L$ 项相互抵消，只剩下基序依赖性贡献的差异：\n$$\n\\Delta E = c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) - c_{\\text{motif}}(\\text{loop}_{\\text{wt}})\n$$\n因此，计算被简化为评估野生型和突变型环的 $c_{\\text{motif}}$ 项。如果环的长度 $L=4$ 且匹配一个 GNRA 或 UNCG 基序，则 $c_{\\text{motif}}$ 的值为 $-2.0 \\text{ kcal/mol}$，否则为 $0.0 \\text{ kcal/mol}$。我们现在使用这个简化公式来分析每种情况。\n\n**情况1：**\n- 野生型环：$\\text{loop}_{\\text{wt}} = \\text{\"GAAA\"}$。长度为 $L=4$。此序列匹配GNRA基序，其中 $\\text{N} = \\text{A}$ 且 $\\text{R} = \\text{A}$。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = -2.0$。\n- 突变型环：位置3的SNP将环变为 $\\text{loop}_{\\text{mut}} = \\text{\"GACA\"}$。长度仍为 $L=4$。此序列不匹配GNRA基序，因为第三个碱基‘C’不是嘌呤（$\\text{R} \\in \\{\\text{A}, \\text{G}\\}$）。它也不匹配UNCG基序。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = 0.0$。\n- 能量变化：$\\Delta E = 0.0 - (-2.0) = +2.0 \\text{ kcal/mol}$。\n\n**情况2：**\n- 野生型环：$\\text{loop}_{\\text{wt}} = \\text{\"GAUA\"}$。长度为 $L=4$。这不匹配GNRA基序，因为第三个碱基‘U’不是嘌呤。它也不匹配UNCG基序。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = 0.0$。\n- 突变型环：位置3的SNP将环变为 $\\text{loop}_{\\text{mut}} = \\text{\"GAAA\"}$。如情况1中所证，这是一个有效的GNRA基序。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = -2.0$。\n- 能量变化：$\\Delta E = -2.0 - 0.0 = -2.0 \\text{ kcal/mol}$。\n\n**情况3：**\n- 野生型环：$\\text{loop}_{\\text{wt}} = \\text{\"AUG\"}$。长度为 $L=3$。特殊的基序贡献仅适用于 $L=4$。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = 0.0$。\n- 突变型环：位置2的SNP将环变为 $\\text{loop}_{\\text{mut}} = \\text{\"UUG\"}$。长度仍为 $L=3$。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = 0.0$。\n- 能量变化：$\\Delta E = 0.0 - 0.0 = 0.0 \\text{ kcal/mol}$。\n\n**情况4：**\n- 野生型环：$\\text{loop}_{\\text{wt}} = \\text{\"CCAUUG\"}$。长度为 $L=6$。特殊的基序贡献仅适用于 $L=4$。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = 0.0$。\n- 突变型环：位置4的SNP将环变为 $\\text{loop}_{\\text{mut}} = \\text{\"CCAGUG\"}$。长度仍为 $L=6$。因此，$c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = 0.0$。\n- 能量变化：$\\Delta E = 0.0 - 0.0 = 0.0 \\text{ kcal/mol}$。\n\n这就完成了对所有指定测试用例的分析。结果直接源自所提供能量模型的基本结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the change in folding free energy (Delta E) for a series of\n    RNA hairpin mutants based on a simplified thermodynamic model.\n    \"\"\"\n\n    def calculate_c_motif(loop: str) -> float:\n        \"\"\"\n        Calculates the motif-dependent energy contribution (c_motif).\n        \n        Args:\n            loop: The nucleotide sequence of the loop.\n        \n        Returns:\n            The energy contribution in kcal/mol, which is -2.0 for stable\n            tetraloops (GNRA, UNCG) and 0.0 otherwise.\n        \"\"\"\n        L = len(loop)\n        if L != 4:\n            return 0.0\n        \n        # Check for GNRA motif: G-N-R-A, where N is any base and R is a purine (A or G).\n        if loop[0] == 'G' and loop[2] in ('A', 'G') and loop[3] == 'A':\n            return -2.0\n            \n        # Check for UNCG motif: U-N-C-G, where N is any base.\n        if loop[0] == 'U' and loop[2] == 'C' and loop[3] == 'G':\n            return -2.0\n            \n        return 0.0\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (left_arm, loop, right_arm, snp_position_1_based, mutant_nucleotide)\n    test_cases = [\n        (\"GGG\", \"GAAA\", \"CCC\", 3, \"C\"),      # Case 1\n        (\"GCG\", \"GAUA\", \"CGC\", 3, \"A\"),      # Case 2\n        (\"GCGC\", \"AUG\", \"GCGC\", 2, \"U\"),     # Case 3\n        (\"GCA\", \"CCAUUG\", \"UGC\", 4, \"G\"),    # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case.\n        # The left and right arms are not needed due to the analytical simplification.\n        _, wt_loop, _, snp_pos, mut_nuc = case\n        \n        # The change in energy simplifies to the difference in the c_motif term,\n        # as the stem and basic loop penalty terms cancel out.\n        # Delta E = c_motif(mutant) - c_motif(wild-type)\n        \n        # Calculate c_motif for the wild-type loop.\n        c_motif_wt = calculate_c_motif(wt_loop)\n\n        # Generate the mutant loop sequence by applying the SNP.\n        # Convert 1-based SNP position to 0-based index for Python string manipulation.\n        mut_pos_0_based = snp_pos - 1\n        mut_loop_list = list(wt_loop)\n        mut_loop_list[mut_pos_0_based] = mut_nuc\n        mut_loop = \"\".join(mut_loop_list)\n        \n        # Calculate c_motif for the mutant loop.\n        c_motif_mut = calculate_c_motif(mut_loop)\n        \n        # Calculate the final change in free energy.\n        delta_e = c_motif_mut - c_motif_wt\n        \n        # Format the result to exactly 3 decimal places and append to the list.\n        results.append(f\"{delta_e:.3f}\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2438407"}, {"introduction": "生物世界充满了例外，tRNA 基因也不例外。某些物种含有“重排 tRNA 基因”（permuted tRNA gene），其 $5^{\\prime}$ 和 $3^{\\prime}$ 两半在基因组中位置互换。本练习将挑战你设计一种算法，通过对序列进行循环重排 (circular permutation) 这种巧妙的计算技巧来检测这些非典型的基因结构。解决这个问题将让你体会到生物信息学研究不仅需要遵循普遍规律，还必须具备识别和处理特殊情况的灵活性 [@problem_id:2438454]。", "problem": "要求您仅使用序列水平的信息，来形式化并实现一个针对置换转移RNA (tRNA) 基因的检测器。在一些古菌和少数细菌中，置换tRNA基因的编码方式是，其$3^{\\prime}$半段在基因组中位于$5^{\\prime}$半段之前，且两半段由一个短的连接子分隔。经过转录和加工后，这两半段会重新排序，以产生一个能折叠成典型苜蓿叶二级结构的tRNA。您必须设计一种方法，在给定一条DNA序列时，根据一个简化的、有原则的模型，判断该序列更符合一个置换tRNA基因，还是一个标准（非置换）tRNA基因。\n\n从以下基本原理和经过充分检验的事实出发：\n- 分子生物学中心法则指出，DNA被转录成RNA，RNA可以通过碱基配对折叠形成功能性结构；tRNA是一种结构化的RNA，具有保守的茎和环。\n- 核酸中的沃森-克里克碱基配对规则是：在DNA中，腺嘌呤与胸腺嘧啶配对（在RNA中，腺嘌呤与尿嘧啶配对），胞嘧啶与鸟嘌呤配对。这里我们仅限于DNA，其标准配对为：A–T和C–G。\n- 在标准tRNA中，接受茎由$5^{\\prime}$和$3^{\\prime}$末端之间的碱基配对形成，通常包含约$7$个连续的标准碱基对。反密码子茎通常包含约$5$个碱基对，位于反密码子环的两侧。\n\n您将使用这些事实来构建一个基于以下简化数学模型的检测算法：\n- 一个长度为$n$，由字母表$\\{A,C,G,T\\}$组成的DNA序列$s$被称为类tRNA (tRNA-like)，当且仅当同时满足两个条件。\n  1. 接受茎条件：存在非负整数$t$和$u$，满足$0 \\le t \\le g$，$0 \\le u \\le g$，以及一个整数$k_{\\mathrm{acc}}$，使得$k_{\\mathrm{acc}}$-mer前缀$s[t \\dots t + k_{\\mathrm{acc}} - 1]$和$k_{\\mathrm{acc}}$-mer后缀$s[n - u - k_{\\mathrm{acc}} \\dots n - u - 1]$在反平行方向排列时，能形成至少$k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$个沃森-克里克碱基对。形式上，令$\\operatorname{wc}(x,y)$在$x$和$y$是沃森-克里克互补碱基对时为$1$，否则为$0$，则分数\n  $$ S_{\\mathrm{acc}}(s,t,u) = \\sum_{i=0}^{k_{\\mathrm{acc}}-1} \\operatorname{wc}\\!\\Big(s[t+i],\\, s[n - u - 1 - i]\\Big) $$\n  必须对于在界限内的某组$t$和$u$满足$S_{\\mathrm{acc}}(s,t,u) \\ge k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$。\n  2. 反密码子茎条件：存在整数$i$和$\\ell$，满足$0 \\le i$，$\\, \\ell_{\\min} \\le \\ell \\le \\ell_{\\max}$，且$i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} \\le n$，使得两个$k_{\\mathrm{anti}}$-mer子序列$s[i \\dots i + k_{\\mathrm{anti}} - 1]$和$s[i + k_{\\mathrm{anti}} + \\ell \\dots i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} - 1]$在反平行方向上能形成至少$k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$个沃森-克里克碱基对。相应的分数为\n  $$ S_{\\mathrm{anti}}(s,i,\\ell) = \\sum_{j=0}^{k_{\\mathrm{anti}}-1} \\operatorname{wc}\\!\\Big(s[i+j],\\, s[i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} - 1 - j]\\Big), $$\n  该分数必须对于在界限内的某组$i$和$\\ell$满足$S_{\\mathrm{anti}}(s,i,\\ell) \\ge k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$。\n- 序列$s$经过$p$个位置的旋转，记为$R_p(s)$，是指对于任意整数$p$（$0 \\le p  n$），形成的序列$s[p] s[p+1] \\dots s[n-1] s[0] s[1] \\dots s[p-1]$。\n- 一条DNA序列$s$被判定为置换tRNA基因，当且仅当存在一个旋转$R_p(s)$（$1 \\le p \\le n-1$），在上述模型下是类tRNA的，而未旋转的序列$R_0(s)=s$不是类tRNA的。这编码了这样一种概念：一个环状置换的排序能揭示出一种标准的类tRNA组织结构，而给定的原始顺序则不具备。\n\n使用以下固定的参数值：\n- $k_{\\mathrm{acc}} = 7$, $m_{\\mathrm{acc}} = 1$, 以及剪切边界$g = 2$,\n- $k_{\\mathrm{anti}} = 5$, $m_{\\mathrm{anti}} = 1$, 反密码子环长度边界为$\\ell_{\\min} = 5$和$\\ell_{\\max} = 9$。\n此外，仅考虑长度$n$满足$35 \\le n \\le 100$的序列进行类tRNA评估；超出此范围的序列应归类为非置换。\n\n您的任务\n- 实现一个程序，对每个提供的测试序列，输出一个布尔值，指示该序列是否根据上述模型和参数被判定为置换tRNA基因。\n- 沃森-克里克互补规则必须仅使用标准的DNA配对，即A–T和C–G。\n- 算法必须是通用的，不得依赖于任何针对某一特定测试序列的硬编码坐标。\n\n测试套件\n用以下5条DNA序列（由A, C, G, T组成的字符串）评估您的程序。它们是为检验决策逻辑而特意构建的。\n\n1. S1: GCGATTCTTTAGCAAGGTGTCATGAACCTTCCGTTTGAATCGC\n2. S2: CATGAACCTTCCGTTTGAATCGCATGCGATTCTTTAGCAAGGTGT\n3. S3: ACGTCGATGACAGTCAGTACGATCGATCGTACGAGTCTAAGCTAGTC\n4. S4: ACGTACGTACGT\n5. S5: CATGAACCTTCCGTTTGAATCGTATGCGATTCTTTAGCAAGGTGT\n\n解释说明\n- 根据此模型，S1是一个标准的类tRNA结构。\n- S2和S5是一个类tRNA结构的环状置换变体，由一个长度为2的短连接子分隔，其中S5在接受茎配对中相对于理想情况还恰好包含一个错配。\n- S3是一个通用的非类tRNA序列。\n- S4太短，不予考虑。\n\n最终输出格式\n您的程序应生成一行输出，其中包含一个逗号分隔的布尔值列表，并用方括号括起来。例如，三个案例的输出可能看起来像[True,False,True]。请对上述五个序列按顺序应用此确切格式，生成一个长度为5的列表。", "solution": "问题陈述已经过严格验证。它在科学上基于分子生物学的原理，特别是转移RNA (tRNA) 的结构和基因组织。所提供的模型是一个简化但数学上精确且适定的抽象，适合进行算法实现。所有参数和约束都已明确定义，使得问题自成一体，没有矛盾或歧义。因此，不仅可能，而且必须给出一个形式化的解决方案。\n\n任务是实现一个分类器，用于判断给定的DNA序列$s$是否代表一个置换tRNA基因。根据提供的模型，一个序列$s$被归类为置换tRNA，当且仅当：\n$1$. 其长度$n$在闭区间$[35, 100]$之内。\n$2$. 原始序列$s = R_0(s)$不是“类tRNA (tRNA-like)”的。\n$3$. 存在至少一个非平凡的环状置换$R_p(s)$（对于$p \\in \\{1, \\dots, n-1\\}$），该置换是“类tRNA”的。\n\n问题的核心因此是构建一个函数，该函数可以测试任意序列是否是“类tRNA”的。一个序列被定义为类tRNA，需要同时满足两个结构性条件：接受茎条件和反密码子茎条件。因此，解决方案以模块化、层次化的方式设计。\n\n首先，我们定义一个布尔函数$\\operatorname{wc}(b_1, b_2)$，如果碱基$b_1, b_2 \\in \\{ \\text{A, C, G, T} \\}$构成一个标准的沃森-克里克对（A-T或C-G），则返回$1$，否则返回$0$。\n\n接下来，我们形式化接受茎条件的算法。一个长度为$n$的序列$s$满足此条件，如果存在整数$t$和$u$，使得$0 \\le t \\le g$和$0 \\le u \\le g$，并且其分数$S_{\\mathrm{acc}}(s,t,u) \\ge k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$。参数是固定的：接受茎长度$k_{\\mathrm{acc}}=7$，最大错配数$m_{\\mathrm{acc}}=1$，最大末端剪切长度$g=2$。因此，所需的分数阈值为$7-1=6$。算法必须系统地检查搜索空间$\\{0, 1, 2\\} \\times \\{0, 1, 2\\}$中所有可能的$(t,u)$对。对于每一对，计算分数：\n$$ S_{\\mathrm{acc}}(s,t,u) = \\sum_{i=0}^{k_{\\mathrm{acc}}-1} \\operatorname{wc}\\!\\Big(s[t+i],\\, s[n - u - 1 - i]\\Big) $$\n如果任何一对$(t,u)$产生的分数至少为$6$，则该条件满足。\n\n然后，我们形式化反密码子茎条件的算法。一个序列$s$满足此条件，如果存在整数$i$和$\\ell$，满足$0 \\le i$, $\\ell_{\\min} \\le \\ell \\le \\ell_{\\max}$，且$i + 2k_{\\mathrm{anti}} + \\ell \\le n$，其分数$S_{\\mathrm{anti}}(s,i,\\ell) \\ge k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$。参数是固定的：反密码子茎长度$k_{\\mathrm{anti}}=5$，最大错配数$m_{\\mathrm{anti}}=1$，环长度边界$\\ell_{\\min}=5, \\ell_{\\max}=9$。所需的分数阈值为$5-1=4$。算法必须执行一个嵌套搜索。外层循环遍历可能的环长度$\\ell \\in \\{5, 6, 7, 8, 9\\}$。内层循环遍历茎-环结构所有可能的起始位置$i$，从$i=0$到最大可能值$n - (2k_{\\mathrm{anti}} + \\ell)$。对于每一对$(i, \\ell)$，计算分数：\n$$ S_{\\mathrm{anti}}(s,i,\\ell) = \\sum_{j=0}^{k_{\\mathrm{anti}}-1} \\operatorname{wc}\\!\\Big(s[i+j],\\, s[i + 2k_{\\mathrm{anti}} + \\ell - 1 - j]\\Big) $$\n如果任何一对$(i, \\ell)$产生的分数至少为$4$，则该条件满足。\n\n有了这两个组件函数，我们定义一个函数`is_tRNA_like(seq)`。当且仅当`seq`同时满足接受茎和反密码子茎条件时，该函数返回真。\n\n最后，对于给定序列$s$（长度为$n$）的主分类算法如下：\n$1$. 检查是否$35 \\le n \\le 100$。如果不是，该序列立即被归类为非置换tRNA，结果为假。\n$2$. 评估`is_tRNA_like(s)`。如果为真，则该序列是一个标准的类tRNA结构，根据定义不是置换的。结果为假。\n$3$. 通过为每个$p$（从$1$到$n-1$）创建$R_p(s) = s[p:]s[:p]$来遍历所有非平凡的环状置换。对每个置换后的序列$R_p(s)$，评估`is_tRNA_like(R_p(s))`。\n$4$. 如果对于任何$p$，此评估为真，意味着在置换后揭示了一个类tRNA结构。序列$s$被归类为置换tRNA基因，结果为真。搜索可以终止。\n$5$. 如果循环完成而没有找到任何这样的置换，则该序列不是置换tRNA基因，结果为假。\n\n对该形式化模型的系统性应用为所述问题提供了一个确定性的、科学上合理的解决方案。实现将由一组直接反映此逻辑结构的函数组成。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the permuted tRNA gene detection problem based on the provided formal model.\n    \"\"\"\n\n    def wc_pair(b1, b2):\n        \"\"\"Checks for Watson-Crick base pairing (A-T, C-G).\"\"\"\n        pairs = {('A', 'T'), ('T', 'A'), ('C', 'G'), ('G', 'C')}\n        return (b1, b2) in pairs\n\n    def has_acceptor_stem(seq, k_acc, m_acc, g):\n        \"\"\"\n        Checks for the presence of a valid acceptor stem according to the model.\n        A score of at least k_acc - m_acc is required for some t, u in [0, g].\n        \"\"\"\n        n = len(seq)\n        threshold = k_acc - m_acc\n        if n  k_acc: \n            return False\n\n        for t in range(g + 1):\n            for u in range(g + 1):\n                # Ensure substrings are within bounds\n                if t + k_acc > n or n - u - k_acc  0:\n                    continue\n                \n                score = 0\n                for i in range(k_acc):\n                    base1 = seq[t + i]\n                    base2 = seq[n - u - 1 - i]\n                    if wc_pair(base1, base2):\n                        score += 1\n                \n                if score >= threshold:\n                    return True\n        return False\n\n    def has_anticodon_stem(seq, k_anti, m_anti, l_min, l_max):\n        \"\"\"\n        Checks for the presence of a valid anticodon stem according to the model.\n        A score of at least k_anti - m_anti is required for some i and l.\n        \"\"\"\n        n = len(seq)\n        threshold = k_anti - m_anti\n\n        for l in range(l_min, l_max + 1):\n            structure_len = 2 * k_anti + l\n            if n  structure_len:\n                continue\n            \n            max_i = n - structure_len\n            for i in range(max_i + 1):\n                score = 0\n                for j in range(k_anti):\n                    base1 = seq[i + j]\n                    base2 = seq[i + structure_len - 1 - j]\n                    if wc_pair(base1, base2):\n                        score += 1\n                \n                if score >= threshold:\n                    return True\n        return False\n\n    def is_tRNA_like(seq, params):\n        \"\"\"\n        Checks if a sequence is tRNA-like, meaning it satisfies both the\n        acceptor stem and anticodon stem conditions.\n        \"\"\"\n        # Unpack parameters from the dictionary\n        k_acc, m_acc, g = params['acceptor']\n        k_anti, m_anti, l_min, l_max = params['anticodon']\n\n        # Both conditions must hold simultaneously\n        return (has_acceptor_stem(seq, k_acc, m_acc, g) and\n                has_anticodon_stem(seq, k_anti, m_anti, l_min, l_max))\n\n    def is_permuted_tRNA(s, params):\n        \"\"\"\n        Determines if a sequence 's' is a permuted tRNA gene. This is true iff\n        's' is not tRNA-like, but at least one of its circular permutations is.\n        \"\"\"\n        n = len(s)\n        min_len, max_len = params['length_bounds']\n\n        if not (min_len = n = max_len):\n            return False\n\n        # The unrotated sequence must NOT be tRNA-like\n        if is_tRNA_like(s, params):\n            return False\n\n        # At least one non-trivial rotation must be tRNA-like\n        for p in range(1, n):\n            rotated_s = s[p:] + s[:p]\n            if is_tRNA_like(rotated_s, params):\n                return True\n        \n        return False\n\n    # Define all model parameters from the problem statement in a dictionary\n    params = {\n        'acceptor': (7, 1, 2),          # (k_acc, m_acc, g)\n        'anticodon': (5, 1, 5, 9),      # (k_anti, m_anti, l_min, l_max)\n        'length_bounds': (35, 100)\n    }\n\n    # The test suite provided in the problem statement\n    test_cases = [\n        \"GCGATTCTTTAGCAAGGTGTCATGAACCTTCCGTTTGAATCGC\",      # S1\n        \"CATGAACCTTCCGTTTGAATCGCATGCGATTCTTTAGCAAGGTGT\",      # S2\n        \"ACGTCGATGACAGTCAGTACGATCGATCGTACGAGTCTAAGCTAGTC\",  # S3\n        \"ACGTACGTACGT\",                                     # S4\n        \"CATGAACCTTCCGTTTGAATCGTATGCGATTCTTTAGCAAGGTGT\"       # S5\n    ]\n\n    results = []\n    for s in test_cases:\n        # Apply the classification logic to each test case\n        result = is_permuted_tRNA(s, params)\n        results.append(result)\n\n    # Format the final output as a single-line string: `[bool1,bool2,...]`\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "2438454"}]}