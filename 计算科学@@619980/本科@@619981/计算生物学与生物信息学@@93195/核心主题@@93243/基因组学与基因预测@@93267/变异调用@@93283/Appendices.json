{"hands_on_practices": [{"introduction": "变异检出的核心在于区分真实的基因变异信号与测序错误或技术噪音。等位基因平衡（Allele Balance），即支持变异的读段（reads）所占的比例，是评估候选变异可信度的关键指标之一。这个练习将挑战你超越简单的比例计算，运用概率模型来权衡证据，尤其是在面临拷贝数变异（CNV）等复杂生物学情景时，这有助于你建立变异检出背后的核心统计直觉。[@problem_id:2439432]", "problem": "一项对种系样本进行的全基因组短读长测序实验报告称，在某个位点上发现了一个候选的单核苷酸多态性 (SNP)，该位点的总深度为 $n = 50$，其中有 $k = 45$ 条读数支持备选等位基因，因此等位基因平衡 $AB = k/n = 0.9$。假设每个碱基的测序错误率为 $\\epsilon = 0.01$，比对无偏，且各读数之间相互独立。支持备选等位基因的读数的期望比例由潜在的等位基因拷贝数比例和测序错误共同决定：如果由于拷贝数变异 (CNV)，该位点存在 $a$ 个备选等位基因拷贝和 $r$ 个参考等位基因拷贝，则真实的备选等位基因比例为 $p = a/(a+r)$，而一条读数支持备选碱基的概率为 $p_{\\mathrm{eff}} = p(1-\\epsilon) + (1-p)\\epsilon$。该样本为种系样本，且已知该位点的总拷贝数在 $\\{1,2,3,4\\}$ 集合内。\n\n在这些假设下，哪种解释与观测到的等位基因平衡 $AB = 0.9$ 最为一致？\n\nA. 二倍体区域（无 CNV）中的一个真实纯合备选变异，即 $a = 2, r = 0$。\n\nB. 总拷贝数为 $3$ 的区域中的一个杂合变异，其中 $a = 2, r = 1$。\n\nC. 总拷贝数为 $4$ 的区域中的一个杂合变异，其中 $a = 3, r = 1$。\n\nD. 不存在真实变异；$k = 45$ 条备选读数完全由随机测序错误（错误率为 $\\epsilon = 0.01$）引起。\n\n请选择唯一的最佳选项。", "solution": "该问题陈述已经过验证，被认为是科学上合理的、定义明确的、客观的且自洽的。所提供的数据是现实的，足以进行严谨的分析。我们现在开始解答。\n\n任务是确定在四个提出的情景中，哪一个与实验观测到的“总测序深度 $n=50$ 中有 $k=45$ 条读数支持备选等位基因”这一结果最为一致。因此，观测到的等位基因平衡为 $AB = k/n = 45/50 = 0.9$。一致性需要从统计学意义上进行评估，这意味着我们必须找出在哪种情景下，观测到的数据最可能发生，即具有最高似然度。\n\n支持备选等位基因的读数数量 $k$ 可以被建模为一个服从二项分布的随机变量，$k \\sim \\mathrm{Binomial}(n, p_{\\mathrm{eff}})$，其中 $p_{\\mathrm{eff}}$ 是单条读数支持备选等位基因的有效概率。在 $n$ 条读数的样本中观测到 $k$ 条备选读数的似然度由二项分布的概率质量函数给出：\n$$L(p_{\\mathrm{eff}} | k, n) = P(k | n, p_{\\mathrm{eff}}) = \\binom{n}{k} (p_{\\mathrm{eff}})^k (1-p_{\\mathrm{eff}})^{n-k}$$\n由于项 $\\binom{n}{k} = \\binom{50}{45}$ 对所有情景都是一个常数，我们只需要比较每个选项的 $(p_{\\mathrm{eff}})^k (1-p_{\\mathrm{eff}})^{n-k}$ 的值即可。为了数值稳定性和方便起见，比较对数似然度通常更简单。需要最大化的项与对数似然度成正比：\n$$\\ln(L) \\propto k \\ln(p_{\\mathrm{eff}}) + (n-k) \\ln(1 - p_{\\mathrm{eff}})$$\n代入观测值 $k=45$ 和 $n=50$，我们计算该表达式：\n$$45 \\ln(p_{\\mathrm{eff}}) + 5 \\ln(1 - p_{\\mathrm{eff}})$$\n$p_{\\mathrm{eff}}$ 的值取决于真实的潜在等位基因比例 $p = a/(a+r)$ 和测序错误率 $\\epsilon = 0.01$，根据给定的公式：\n$$p_{\\mathrm{eff}} = p(1-\\epsilon) + (1-p)\\epsilon$$\n我们现在将为四个选项中的每一个计算 $p_{\\mathrm{eff}}$ 和相应的对数似然项。\n\n**选项 A：二倍体区域（无 CNV）中的一个真实纯合备选变异，即 $a = 2, r = 0$。**\n在这种情景下，真实的备选等位基因比例是 $p = a/(a+r) = 2/(2+0) = 1$。\n观测到备选等位基因的有效概率是：\n$$p_{\\mathrm{eff,A}} = 1(1-0.01) + (1-1)(0.01) = 1(0.99) + 0(0.01) = 0.99$$\n对数似然项为：\n$$\\ln(L_A) \\propto 45 \\ln(0.99) + 5 \\ln(1-0.99) = 45 \\ln(0.99) + 5 \\ln(0.01)$$\n$$\\ln(L_A) \\propto 45(-0.01005) + 5(-4.60517) = -0.45225 - 23.02585 = -23.4781$$\n观测到的等位基因平衡 $0.9$ 与期望的 $0.99$ 有偏差。如果测序到参考等位基因的概率仅为 $1-p_{\\mathrm{eff,A}} = 0.01$，那么观测到 5 条支持参考等位基因的读数是极不可能的。\n\n**选项 B：总拷贝数为 $3$ 的区域中的一个杂合变异，其中 $a = 2, r = 1$。**\n这里，真实的备选等位基因比例是 $p = a/(a+r) = 2/(2+1) = 2/3$。\n观测到备选等位基因的有效概率是：\n$$p_{\\mathrm{eff,B}} = \\frac{2}{3}(1-0.01) + \\left(1-\\frac{2}{3}\\right)(0.01) = \\frac{2}{3}(0.99) + \\frac{1}{3}(0.01) = \\frac{1.98 + 0.01}{3} = \\frac{1.99}{3} \\approx 0.6633$$\n对数似然项为：\n$$\\ln(L_B) \\propto 45 \\ln\\left(\\frac{1.99}{3}\\right) + 5 \\ln\\left(1-\\frac{1.99}{3}\\right) = 45 \\ln\\left(\\frac{1.99}{3}\\right) + 5 \\ln\\left(\\frac{1.01}{3}\\right)$$\n$$\\ln(L_B) \\propto 45(-0.41050) + 5(-1.08864) = -18.4725 - 5.4432 = -23.9157$$\n这个对数似然值比选项 A 的更低（负得更多），表明它与数据的一致性更差。\n\n**选项 C：总拷贝数为 $4$ 的区域中的一个杂合变异，其中 $a = 3, r = 1$。**\n真实的备选等位基因比例是 $p = a/(a+r) = 3/(3+1) = 3/4 = 0.75$。\n观测到备选等位基因的有效概率是：\n$$p_{\\mathrm{eff,C}} = \\frac{3}{4}(1-0.01) + \\left(1-\\frac{3}{4}\\right)(0.01) = 0.75(0.99) + 0.25(0.01) = 0.7425 + 0.0025 = 0.745$$\n对数似然项为：\n$$\\ln(L_C) \\propto 45 \\ln(0.745) + 5 \\ln(1-0.745) = 45 \\ln(0.745) + 5 \\ln(0.255)$$\n$$\\ln(L_C) \\propto 45(-0.29440) + 5(-1.36649) = -13.2480 - 6.83245 = -20.08045$$\n这个对数似然值是目前为止所有考虑选项中最高的（负得最少）。粗略的分析可能会偏向选项 A，因为其期望的等位基因平衡（$0.99$）在算术上比选项 C 的（$0.745$）更接近观测值 $0.9$。然而，这是不正确的。二项似然函数 $L(p) \\propto p^{45}(1-p)^5$ 在其最大值点 $p=0.9$ 附近是高度不对称的。由于 $(1-p)^5$ 项的存在，对于 $p>0.9$ 的偏差惩罚要严重得多。观测到 5 条期望概率为 $0.01$（选项 A）的类型的读数，远比观测到 45 条期望概率为 $0.745$（选项 C）的类型的读数更不可能。\n\n**选项 D：不存在真实变异。**\n这意味着基因型为纯合参考型。假设在一个二倍体区域（$a=0, r=2$），真实的备选等位基因比例是 $p = 0/(0+2) = 0$。\n观测到备选等位基因的有效概率完全来自于测序错误：\n$$p_{\\mathrm{eff,D}} = 0(1-0.01) + (1-0)(0.01) = 0.01$$\n对数似然项为：\n$$\\ln(L_D) \\propto 45 \\ln(0.01) + 5 \\ln(0.99)$$\n$$\\ln(L_D) \\propto 45(-4.60517) + 5(-0.01005) = -207.23265 - 0.05025 = -207.2829$$\n这个对数似然值极低，表明当备选读数预期仅由错误产生时，观测到 45 条这样的读数几乎是不可能的。这是迄今为止最不合理的情景，差距非常大。\n\n**结论：**\n比较所有选项的对数似然项：\n- 选项 A: $-23.4781$\n- 选项 B: $-23.9157$\n- 选项 C: $-20.08045$\n- 选项 D: $-207.2829$\n\n最高的对数似然值对应于选项 C。因此，与观测数据最一致的解释是：在一个总拷贝数为 4 的区域中存在一个杂合变异，该变异有三个备选等位基因拷贝和一个参考等位基因拷贝。\n\n**各选项评判：**\n- A：**不正确**。虽然期望的等位基因平衡 $0.99$ 看起来与观测值 $0.9$ 很接近，但在该模型下观测到 5 条参考读数的似然度极低，使其比选项 C 更不合理。\n- B：**不正确**。约 $0.663$ 的期望等位基因平衡与观测值相差甚远，其对应的似然度也低于选项 A 和 C。\n- C：**正确**。在给定选项中，此情景使观测数据的似然度最大化。统计证据强烈支持此解释而非其他解释。\n- D：**不正确**。观测到 45 条备选读数无法仅用随机测序错误来合理解释。此情景的似然度小到可以忽略不计。", "answer": "$$\\boxed{C}$$", "id": "2439432"}, {"introduction": "在检出变异之后，下一步是评估其质量并过滤掉潜在的假阳性结果。生物信息学流程通常依赖于一系列质量指标，例如由深度标准化的质量值（QualByDepth, $QD$）。本练习旨在培养你的批判性思维，通过分析一个边缘案例，揭示这类指标的局限性，并强调了为何在解读质量分数时必须考虑测序深度等上下文信息，从而避免盲目过滤掉真实的变异。[@problem_id:2439414]", "problem": "一个实验室使用硬过滤规则，移除任何 QualByDepth (QD) 注释值低于一个固定阈值的已检出变异。QualByDepth (QD) 定义为 Phred 量表上的变异置信度除以该位点上未经过滤的测序深度，即 $QD = QUAL / DP$ ，其中 $QUAL$ 是 Phred 量表的变异置信度，而 $DP$ 是未经过滤的测序深度。Phred 量表的定义为 $Q = -10 \\log_{10} p$，其中 $p$ 是检出错误的概率。该实验室设置了一个硬过滤条件，以移除 $QD < 2.0$ 的变异。考虑以下四种情景。在每种情景中，假设变异检出软件和比对软件都已正确配置，且测序读段的碱基质量和比对质量均为现代短读长测序的典型值。选择最能例证“基于低 $QD$ 值进行过滤会移除一个真阳性变异”这一边界情况的选项。\n\nA. 对一个已知的胚系杂合单核苷酸多态性 (SNP) 进行靶向扩增子测序。该位点被极深地捕获，未经过滤的深度为 $DP = 4000$。变异检出软件在内部进行降采样以限制用于基因型似然性计算的证据，基于一个有效的读段子集产生变异置信度 $QUAL = 350$。在非重复、高质量的读段中，等位基因平衡情况与杂合子一致，并且正交验证证实该 SNP 是真实的。\n\nB. 以约 $30\\times$ 的典型测序深度进行全基因组测序。一个胚系杂合 SNP 的未经过滤深度为 $DP = 30$，变异置信度为 $QUAL = 200$，备择等位基因频率接近 $0.5$。独立验证证实该 SNP 是真实的。\n\nC. 进行具有中等测序深度变异性的全外显子组测序。一个胚系杂合插入/缺失 (indel) 检出结果由未经过滤的深度 $DP = 8$ 支持，其变异置信度为 $QUAL = 30$，且两条链上的等位基因计数均衡。独立的长读长测序证实该 indel 是真实的。\n\nD. 一个低复杂性区域中的短同聚物区域显示出一个明显的 indel，其未经过滤的深度为 $DP = 120$，但变异置信度为 $QUAL = 20$。该信号出现在跨不同批次处理的许多无亲缘关系的样本中，表明这是一个复发性的测序或比对假象，而非一个真实的生物学变异。\n\n哪个选项最符合“基于低 $QD$ 值的过滤会移除一个真阳性变异”的边界情况？\n\n答案选项：\n- A\n\n- B\n\n- C\n\n- D", "solution": "该问题要求从四个选项中找出一个特定情景，该情景最能例证一个真阳性变异被低的 QualByDepth (QD) 阈值错误地滤除的边界情况。过滤标准定义为移除任何 $QD < 2.0$ 的变异。QualByDepth 指标本身定义为 Phred 量表的变异置信度 ($QUAL$) 与未经过滤的测序深度 ($DP$) 的比率，即 $QD = QUAL / DP$。真阳性是指一个生物学上真实存在且被变异检出软件正确识别的变异。因此，任务是找到描述一个已被证实的真实变异的选项，而该变异计算出的 $QD$ 值低于 $2.0$ 的阈值，从而导致其被错误地移除。\n\n让我们有条理地分析每种情景。\n\n首先，我们明确过滤规则：如果 $QD < 2.0$，则变异被移除。\n\n选项 A：对一个已知的胚系杂合单核苷酸多态性 (SNP) 进行靶向扩增子测序。\n- 已知条件：未经过滤的深度为 $DP = 4000$。变异置信度因内部降采样而受限，为 $QUAL = 350$。该变异被证实为真阳性（“正交验证证实该 SNP 是真实的”）。\n- $QD$的计算：\n$$QD = \\frac{QUAL}{DP} = \\frac{350}{4000} = \\frac{35}{400} = \\frac{7}{80} = 0.0875$$\n- 评估：计算出的 $QD$ 值为 $0.0875$。由于 $0.0875 < 2.0$，这个变异将被硬过滤规则移除。问题明确指出这是一个真阳性变异。该情景代表了 $QD$ 指标的一个经典失效模式。在测序深度极高的区域（例如由扩增子测序产生的区域），分母 $DP$ 会变得非常大。即使绝对变异置信度 $QUAL$ 极高（$QUAL$ 为 $350$ 对应于一个可忽略不计的错误概率 $10^{-35}$），$QD$ 比率也可能被人为地压低。变异检出软件通常会在这种高深度区域对读段进行降采样以保持计算可行性，这会限制可达到的最大 $QUAL$ 分数。受限的 $QUAL$ 和极大的 $DP$ 相结合，导致了低的 $QD$ 值，从而引起对高置信度、真阳性检出的错误拒绝。这种情况精确匹配了对 $QD$ 过滤有问题的边界情况的描述。\n- 结论：**正确**。该选项完美地例证了基于低 $QD$ 值的过滤移除了一个真阳性变异的边界情况。\n\n选项 B：典型覆盖深度的全基因组测序。\n- 已知条件：未经过滤的深度为 $DP = 30$。变异置信度为 $QUAL = 200$。该变异是一个已证实的真阳性 SNP。\n- $QD$的计算：\n$$QD = \\frac{QUAL}{DP} = \\frac{200}{30} \\approx 6.67$$\n- 评估：计算出的 $QD$ 值约为 $6.67$。由于 $6.67 > 2.0$，这个变异*不会*被过滤器移除。该情景描述了一个被过滤器正确通过的高质量真阳性变异。它没有例证过滤器的失效。\n- 结论：**不正确**。\n\n选项 C：中等覆盖深度的全外显子组测序。\n- 已知条件：未经过滤的深度为 $DP = 8$。变异置信度为 $QUAL = 30$。该变异是一个已证实的真阳性 indel。\n- $QD$的计算：\n$$QD = \\frac{QUAL}{DP} = \\frac{30}{8} = 3.75$$\n- 评估：计算出的 $QD$ 值为 $3.75$。由于 $3.75 > 2.0$，这个变异*不会*被过滤器移除。虽然深度较低，但置信度相对于深度而言足够高，从而产生了一个良好的 $QD$ 分数。这是一个被过滤器正确通过的真阳性检出的例子。\n- 结论：**不正确**。\n\n选项 D：一个低复杂性区域中的明显 indel。\n- 已知条件：未经过滤的深度为 $DP = 120$。变异置信度为 $QUAL = 20$。问题文本指出，该信号是“一个复发性的测序或比对假象，而非一个真实的生物学变异”。这意味着它是一个假阳性。\n- 主要目标是找到一个*真阳性*被过滤的例子。由于此情景描述的是一个可能的*假阳性*，因此无论 $QD$ 值如何，它都不可能是正确答案。\n- 为了完整起见，我们计算 $QD$：\n$$QD = \\frac{QUAL}{DP} = \\frac{20}{120} = \\frac{1}{6} \\approx 0.167$$\n- 评估：计算出的 $QD$ 约为 $0.167$。由于 $0.167 < 2.0$，该变异将被过滤。然而，由于该变异被描述为一个假象（假阳性），它的移除代表了过滤策略的*成功*，而不是失败。相对于 $120$ 这样可观的深度，其 $QUAL$ 分数仅为 $20$，这正是 $QD$ 指标旨在检测和滤除的那种低质量信号。\n- 结论：**不正确**。\n\n总结：只有情景 A 描述了一个已证实的真阳性变异被 $QD < 2.0$ 规则滤除的情况。这是由于在极高测序深度的边界情况下，$QD$ 计算过程中产生的一种假象所致，而这也是这种特定过滤指标的一个已知局限性。", "answer": "$$\\boxed{A}$$", "id": "2439414"}, {"introduction": "评估的范围可以从单个变异的质量扩展到整个变异检出流程的整体性能。在开发或比较生物信息学工具时，通过与“金标准”或“真集”（truth set）进行基准比较是一种标准做法。这个动手实践将指导你实现精确率（Precision, $P$）和召回率（Recall, $R$）这两个通用性能指标的计算，这是任何方法开发者评估其算法性能所必须掌握的基本技能。[@problem_id:2439428]", "problem": "您会得到一项正式评估任务，以一个可信变异集为基准，对两个变异检出流程进行基准测试。变异包括单核苷酸多态性和插入缺失多态性。每个变异表示为一个包含四个字段的元组：染色体字符串、作为正整数的基因组坐标、参考等位基因字符串和备选等位基因字符串。在此任务中，可信集被视为真实基准。您必须根据精确匹配标准，为每个流程计算精确率和召回率。精确匹配意味着染色体字符串相同，基因组坐标相同，以及参考和备选等位基因字符串相同。\n\n令真实集表示为有限集 $T$，流程检出集表示为有限集 $C$。定义真阳性集为 $TP = C \\cap T$，假阳性集为 $FP = C \\setminus T$，假阴性集为 $FN = T \\setminus C$。精确率 $P$ 和召回率 $R$ 定义如下：\n$$\nP =\n\\begin{cases}\n\\dfrac{|TP|}{|TP| + |FP|}, & \\text{if } |TP| + |FP| > 0 \\\\\n1, & \\text{if } |TP| + |FP| = 0\n\\end{cases}\n\\qquad\nR =\n\\begin{cases}\n\\dfrac{|TP|}{|TP| + |FN|}, & \\text{if } |TP| + |FN| > 0 \\\\\n1, & \\text{if } |TP| + |FN| = 0\n\\end{cases}\n$$\n所有计数 $|\\cdot|$ 都是有限集的基数。这些定义应分别应用于每个测试用例和每个流程。所有报告值必须是四舍五入到三位小数的小数。不涉及物理单位。所有小数必须以十进制数报告。\n\n评估标准：\n- 对于染色体、参考和备选等位基因字段，所有比较均视为精确字符串相等；对于基因组坐标字段，视为精确整数相等。\n- 忽略基因型、单体型分型及任何其他注释；仅由四个字段的变异身份决定匹配。\n- 提供的所有变异都位于基准区域内，并且符合评估条件。\n\n您将评估以下测试套件。对于每个测试用例 $i \\in \\{1,2,3\\}$，您会得到一个真实集 $T_i$、一个流程 $A$ 的检出集 $C^{(A)}_i$ 和一个流程 $B$ 的检出集 $C^{(B)}_i$。每个变异都写作一个四元组 $(\\text{chrom}, \\text{pos}, \\text{ref}, \\text{alt})$，其中 $\\text{pos}$ 是一个正整数。这些集合是：\n\n- 测试用例 $1$:\n$$\n\\begin{aligned}\nT_1 &= \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 200, \\text{T}, \\text{TA}),\\; (\\text{chr1}, 300, \\text{CT}, \\text{C}) \\} \\\\\nC^{(A)}_1 &= \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 200, \\text{T}, \\text{TA}),\\; (\\text{chr1}, 250, \\text{G}, \\text{C}) \\} \\\\\nC^{(B)}_1 &= \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 300, \\text{CT}, \\text{C}),\\; (\\text{chr1}, 400, \\text{A}, \\text{AT}) \\}\n\\end{aligned}\n$$\n\n- 测试用例 $2$:\n$$\n\\begin{aligned}\nT_2 &= \\{ (\\text{chr2}, 1000, \\text{G}, \\text{A}),\\; (\\text{chr2}, 1001, \\text{C}, \\text{CG}) \\} \\\\\nC^{(A)}_2 &= \\varnothing \\\\\nC^{(B)}_2 &= \\{ (\\text{chr2}, 1500, \\text{T}, \\text{G}) \\}\n\\end{aligned}\n$$\n\n- 测试用例 $3$:\n$$\n\\begin{aligned}\nT_3 &= \\varnothing \\\\\nC^{(A)}_3 &= \\varnothing \\\\\nC^{(B)}_3 &= \\{ (\\text{chr3}, 10, \\text{A}, \\text{G}),\\; (\\text{chr3}, 20, \\text{T}, \\text{TA}) \\}\n\\end{aligned}\n$$\n\n您的任务是编写一个程序，对于每个测试用例 $i$，使用上述定义计算流程 $A$ 应用于 $(C^{(A)}_i, T_i)$ 和流程 $B$ 应用于 $(C^{(B)}_i, T_i)$ 时的精确率和召回率。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个按以下精确顺序排列的小数列表\n$$\n[ P^{(A)}_1, R^{(A)}_1, P^{(B)}_1, R^{(B)}_1, P^{(A)}_2, R^{(A)}_2, P^{(B)}_2, R^{(B)}_2, P^{(A)}_3, R^{(A)}_3, P^{(B)}_3, R^{(B)}_3 ].\n$$\n- 每个小数必须四舍五入到三位小数。\n- 列表必须用方括号括起来，值之间用逗号分隔，不得有任何额外文本。", "solution": "该问题要求计算两个变异检出流程在三个测试用例中的精确率和召回率。问题定义明确，有科学依据，并为获得唯一解提供了所有必要的数据和公式。这是生物信息学性能评估中的一个标准练习。我们开始解题。\n\n基本任务是将一个流程生成的变异检出集（表示为检出集 $C$）与一个真实基准变异集（真实集 $T$）进行比较。两者都是变异的有限集，其中每个变異是一个四元组 $(\\text{chrom}, \\text{pos}, \\text{ref}, \\text{alt})$。要求精确匹配。\n\n核心指标源于三个集合的基数：\n1.  真阳性（$TP$）：流程正确识别的变异。这是集合的交集 $TP = C \\cap T$。\n2.  假阳性（$FP$）：流程错误检出但不在真实集中的变异。这是集合的差集 $FP = C \\setminus T$。\n3.  假阴性（$FN$）：流程未能识别的真实变异。这是集合的差集 $FN = T \\setminus C$。\n\n问题将精确率($P$)和召回率($R$)定义为：\n$$\nP =\n\\begin{cases}\n\\dfrac{|TP|}{|TP| + |FP|}, & \\text{if } |TP| + |FP| > 0 \\\\\n1, & \\text{if } |TP| + |FP| = 0\n\\end{cases}\n\\qquad\nR =\n\\begin{cases}\n\\dfrac{|TP|}{|TP| + |FN|}, & \\text{if } |TP| + |FN| > 0 \\\\\n1, & \\text{if } |TP| + |FN| = 0\n\\end{cases}\n$$\n注意， $|TP| + |FP| = |C|$ 且 $|TP| + |FN| = |T|$。特殊情况处理了检出集或真实集为空的场景。我们将对每个案例严格应用这些定义。\n\n**测试用例 1**\n\n真实集: $T_1 = \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 200, \\text{T}, \\text{TA}),\\; (\\text{chr1}, 300, \\text{CT}, \\text{C}) \\}$。基数为 $|T_1| = 3$。\n\n流程 A: $C^{(A)}_1 = \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 200, \\text{T}, \\text{TA}),\\; (\\text{chr1}, 250, \\text{G}, \\text{C}) \\}$，所以 $|C^{(A)}_1| = 3$。\n-   $TP^{(A)}_1 = C^{(A)}_1 \\cap T_1 = \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 200, \\text{T}, \\text{TA}) \\}$。因此，$|TP^{(A)}_1| = 2$。\n-   $FP^{(A)}_1 = C^{(A)}_1 \\setminus T_1 = \\{ (\\text{chr1}, 250, \\text{G}, \\text{C}) \\}$。因此，$|FP^{(A)}_1| = 1$。\n-   $FN^{(A)}_1 = T_1 \\setminus C^{(A)}_1 = \\{ (\\text{chr1}, 300, \\text{CT}, \\text{C}) \\}$。因此，$|FN^{(A)}_1| = 1$。\n-   精确率 $P^{(A)}_1 = \\frac{|TP^{(A)}_1|}{|TP^{(A)}_1| + |FP^{(A)}_1|} = \\frac{2}{2+1} = \\frac{2}{3} \\approx 0.667$。\n-   召回率 $R^{(A)}_1 = \\frac{|TP^{(A)}_1|}{|TP^{(A)}_1| + |FN^{(A)}_1|} = \\frac{2}{2+1} = \\frac{2}{3} \\approx 0.667$。\n\n流程 B: $C^{(B)}_1 = \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 300, \\text{CT}, \\text{C}),\\; (\\text{chr1}, 400, \\text{A}, \\text{AT}) \\}$，所以 $|C^{(B)}_1| = 3$。\n-   $TP^{(B)}_1 = C^{(B)}_1 \\cap T_1 = \\{ (\\text{chr1}, 100, \\text{A}, \\text{G}),\\; (\\text{chr1}, 300, \\text{CT}, \\text{C}) \\}$。因此，$|TP^{(B)}_1| = 2$。\n-   $FP^{(B)}_1 = C^{(B)}_1 \\setminus T_1 = \\{ (\\text{chr1}, 400, \\text{A}, \\text{AT}) \\}$。因此，$|FP^{(B)}_1| = 1$。\n-   $FN^{(B)}_1 = T_1 \\setminus C^{(B)}_1 = \\{ (\\text{chr1}, 200, \\text{T}, \\text{TA}) \\}$。因此，$|FN^{(B)}_1| = 1$。\n-   精确率 $P^{(B)}_1 = \\frac{|TP^{(B)}_1|}{|TP^{(B)}_1| + |FP^{(B)}_1|} = \\frac{2}{2+1} = \\frac{2}{3} \\approx 0.667$。\n-   召回率 $R^{(B)}_1 = \\frac{|TP^{(B)}_1|}{|TP^{(B)}_1| + |FN^{(B)}_1|} = \\frac{2}{2+1} = \\frac{2}{3} \\approx 0.667$。\n\n**测试用例 2**\n\n真实集: $T_2 = \\{ (\\text{chr2}, 1000, \\text{G}, \\text{A}),\\; (\\text{chr2}, 1001, \\text{C}, \\text{CG}) \\}$。基数为 $|T_2| = 2$。\n\n流程 A: $C^{(A)}_2 = \\varnothing$，所以 $|C^{(A)}_2| = 0$。\n-   $|TP^{(A)}_2| = 0$, $|FP^{(A)}_2| = 0$。\n-   $FN^{(A)}_2 = T_2 \\setminus \\varnothing = T_2$。因此，$|FN^{(A)}_2| = 2$。\n-   精确率: $|TP^{(A)}_2| + |FP^{(A)}_2| = 0$。根据定义，$P^{(A)}_2 = 1.000$。\n-   召回率: $R^{(A)}_2 = \\frac{|TP^{(A)}_2|}{|TP^{(A)}_2| + |FN^{(A)}_2|} = \\frac{0}{0+2} = 0.000$。\n\n流程 B: $C^{(B)}_2 = \\{ (\\text{chr2}, 1500, \\text{T}, \\text{G}) \\}$，所以 $|C^{(B)}_2| = 1$。\n-   $TP^{(B)}_2 = C^{(B)}_2 \\cap T_2 = \\varnothing$。因此，$|TP^{(B)}_2| = 0$。\n-   $FP^{(B)}_2 = C^{(B)}_2 \\setminus T_2 = C^{(B)}_2$。因此，$|FP^{(B)}_2| = 1$。\n-   $FN^{(B)}_2 = T_2 \\setminus C^{(B)}_2 = T_2$。因此，$|FN^{(B)}_2| = 2$。\n-   精确率 $P^{(B)}_2 = \\frac{|TP^{(B)}_2|}{|TP^{(B)}_2| + |FP^{(B)}_2|} = \\frac{0}{0+1} = 0.000$。\n-   召回率 $R^{(B)}_2 = \\frac{|TP^{(B)}_2|}{|TP^{(B)}_2| + |FN^{(B)}_2|} = \\frac{0}{0+2} = 0.000$。\n\n**测试用例 3**\n\n真实集: $T_3 = \\varnothing$。基数为 $|T_3| = 0$。\n\n流程 A: $C^{(A)}_3 = \\varnothing$，所以 $|C^{(A)}_3| = 0$。\n-   $|TP^{(A)}_3| = 0$, $|FP^{(A)}_3| = 0$, $|FN^{(A)}_3| = 0$。\n-   精确率: $|TP^{(A)}_3| + |FP^{(A)}_3| = 0$。根据定义，$P^{(A)}_3 = 1.000$。\n-   召回率: $|TP^{(A)}_3| + |FN^{(A)}_3| = 0$。根据定义，$R^{(A)}_3 = 1.000$。\n这反映了完美的性能：没有检出任何变异，且预期中也没有变异。\n\n流程 B: $C^{(B)}_3 = \\{ (\\text{chr3}, 10, \\text{A}, \\text{G}),\\; (\\text{chr3}, 20, \\text{T}, \\text{TA}) \\}$，所以 $|C^{(B)}_3| = 2$。\n-   $TP^{(B)}_3 = C^{(B)}_3 \\cap T_3 = \\varnothing$。因此，$|TP^{(B)}_3| = 0$。\n-   $FP^{(B)}_3 = C^{(B)}_3 \\setminus T_3 = C^{(B)}_3$。因此，$|FP^{(B)}_3| = 2$。\n-   $FN^{(B)}_3 = T_3 \\setminus C^{(B)}_3 = \\varnothing$。因此，$|FN^{(B)}_3| = 0$。\n-   精确率 $P^{(B)}_3 = \\frac{|TP^{(B)}_3|}{|TP^{(B)}_3| + |FP^{(B)}_3|} = \\frac{0}{0+2} = 0.000$。\n-   召回率: $|TP^{(B)}_3| + |FN^{(B)}_3| = 0$。根据定义，$R^{(B)}_3 = 1.000$。\n召回率是完美的，因为没有需要检出的真实变异（$FN = 0$）。\n\n**结果摘要**\n合并后并四舍五入到三位小数的结果如下：\n-   $P^{(A)}_1 = 0.667$, $R^{(A)}_1 = 0.667$\n-   $P^{(B)}_1 = 0.667$, $R^{(B)}_1 = 0.667$\n-   $P^{(A)}_2 = 1.000$, $R^{(A)}_2 = 0.000$\n-   $P^{(B)}_2 = 0.000$, $R^{(B)}_2 = 0.000$\n-   $P^{(A)}_3 = 1.000$, $R^{(A)}_3 = 1.000$\n-   $P^{(B)}_3 = 0.000$, $R^{(B)}_3 = 1.000$\n\n这些值将被组合成一个单独的列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the variant calling evaluation problem by calculating precision\n    and recall for given test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each variant is a tuple (chrom, pos, ref, alt).\n    # Each test case is a tuple (truth_set, call_set_A, call_set_B).\n    test_cases = [\n        # Test Case 1\n        (\n            {('chr1', 100, 'A', 'G'), ('chr1', 200, 'T', 'TA'), ('chr1', 300, 'CT', 'C')},\n            {('chr1', 100, 'A', 'G'), ('chr1', 200, 'T', 'TA'), ('chr1', 250, 'G', 'C')},\n            {('chr1', 100, 'A', 'G'), ('chr1', 300, 'CT', 'C'), ('chr1', 400, 'A', 'AT')}\n        ),\n        # Test Case 2\n        (\n            {('chr2', 1000, 'G', 'A'), ('chr2', 1001, 'C', 'CG')},\n            set(),\n            {('chr2', 1500, 'T', 'G')}\n        ),\n        # Test Case 3\n        (\n            set(),\n            set(),\n            {('chr3', 10, 'A', 'G'), ('chr3', 20, 'T', 'TA')}\n        )\n    ]\n\n    def calculate_metrics(call_set, truth_set):\n        \"\"\"\n        Calculates precision and recall based on the provided formulae.\n\n        Args:\n            call_set (set): A set of variant tuples from a pipeline.\n            truth_set (set): A set of ground-truth variant tuples.\n\n        Returns:\n            tuple: A tuple containing (precision, recall).\n        \"\"\"\n        # Calculate cardinalities of TP, FP, FN sets using set operations.\n        # True Positives: intersection of call set and truth set.\n        tp_set = call_set.intersection(truth_set)\n        tp = len(tp_set)\n\n        # False Positives: variants in call set but not in truth set.\n        fp_set = call_set.difference(truth_set)\n        fp = len(fp_set)\n\n        # False Negatives: variants in truth set but not in call set.\n        fn_set = truth_set.difference(call_set)\n        fn = len(fn_set)\n\n        # Calculate Precision\n        # Denominator is |TP| + |FP|, which is equal to |C|.\n        p_denominator = tp + fp\n        if p_denominator == 0:\n            precision = 1.0\n        else:\n            precision = tp / p_denominator\n\n        # Calculate Recall\n        # Denominator is |TP| + |FN|, which is equal to |T|.\n        r_denominator = tp + fn\n        if r_denominator == 0:\n            recall = 1.0\n        else:\n            recall = tp / r_denominator\n            \n        return (precision, recall)\n\n    results = []\n    # Iterate through each test case and calculate metrics for both pipelines.\n    for truth_set, call_set_A, call_set_B in test_cases:\n        # Pipeline A\n        p_A, r_A = calculate_metrics(call_set_A, truth_set)\n        results.extend([p_A, r_A])\n        \n        # Pipeline B\n        p_B, r_B = calculate_metrics(call_set_B, truth_set)\n        results.extend([p_B, r_B])\n\n    # Format the results to three decimal places as required.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2439428"}]}