{"hands_on_practices": [{"introduction": "在基因组学研究中，序列“嵌合体”等技术性假象是一个常见的挑战。本练习 [@problem_id:2418778] 将通过一个精心设计的思想实验，向您展示渐进式比对方法对初始引导树的依赖性如何成为其关键弱点。通过解决这个难题，您将亲身体会到算法的“贪婪”本质是如何将引导树的错误传播到最终的多序列比对结果中的。", "problem": "给定五个长度为 $12$ 的 DNA 序列，它们由字母表 $\\{A,C,G,T\\}$ 构成。其中四个序列 $S_1,\\;S_2,\\;S_3,\\;S_4$ 来自两个进化支：$S_1,\\;S_2$ 来自进化支 $X$，$S_3,\\;S_4$ 来自进化支 $Y$。第五个序列 $C$ 是一个嵌合体结构，由 $S_1$ 的前半部分（位置 $1$ 到 $6$）和 $S_3$ 的后半部分（位置 $7$ 到 $12$）拼接而成。这些序列是：\n- $S_1 = \\text{AAAAAACCCCCC}$\n- $S_2 = \\text{AAAAATCCCCCC}$\n- $S_3 = \\text{GGGGGGTTTTTT}$\n- $S_4 = \\text{GGGGTGTTTTTT}$\n- $C = \\text{AAAAAATTTTTT}$\n\n将使用非加权配对群算术平均法 (UPGMA) 来构建一个指导树，该方法基于成对距离 $d(i,j)$，定义为 $d(i,j)=1-\\text{pid}(i,j)$，其中 $\\text{pid}(i,j)$ 是序列 $i$ 和 $j$ 在逐位无间隙比较中相同字符的比例（这是合理的，因为所有序列长度均为 $12$ 且不考虑插入缺失）。然后，将根据这个 UPGMA 指导树，通过先对齐序列再对齐轮廓（profile）的方式，构建一个渐进式多序列比对 (MSA)，过程中不进行任何迭代优化或事后重新比对。\n\n哪个选项最能描述添加嵌合序列 $C$ 对 UPGMA 指导树拓扑结构以及下游渐进式多序列比对的影响？\n\nA. UPGMA 首先聚类 $(S_1,S_2)$ 和 $(S_3,S_4)$，然后将 $C$ 附加到 $(S_3,S_4)$ 簇，最后再与 $(S_1,S_2)$ 合并。因此，渐进式比对会将 $(C,S_3,S_4)$ 的轮廓与 $(S_1,S_2)$ 的轮廓进行比对，从而使得 $(C,S_3,S_4)$ 富含 $T$ 的后半部分被迫与 $(S_1,S_2)$ 富含 $C$ 的后半部分对齐，而富含 $G$ 的前半部分则与富含 $A$ 的前半部分对齐，这混合了不相关的片段，并降低了前后两半部分的比对准确性。\n\nB. UPGMA 将 $C$ 放置在根部，作为与所有其他序列等距的外群，使得渐进式比对相对于不含 $C$ 的比对实际上没有变化。\n\nC. UPGMA 首先将 $C$ 与 $S_1$ 聚类，然后将这对序列与 $S_2$ 合并形成进化支 $X$，由于 $C$ 与 $S_1$ 共享前半部分，从而防止了干扰；最终的 MSA 在前后两半部分都保持最优。\n\nD. UPGMA 首先将 $S_1$ 和 $S_3$ 聚类，因为 $C$ 桥接了它们并降低了它们的估计距离；尽管这在指导树中混合了不同的进化支，但渐进式比对器会通过迭代优化进行补偿以恢复正确的 MSA。", "solution": "首先将对所提供的问题进行科学性和逻辑完整性验证。\n\n### 步骤 1：提取已知信息\n问题提供了以下信息：\n-   一组五个长度为 $L=12$ 的 DNA 序列：$S_1, S_2, S_3, S_4, C$。\n-   序列定义：\n    -   $S_1 = \\text{AAAAAACCCCCC}$\n    -   $S_2 = \\text{AAAAATCCCCCC}$\n    -   $S_3 = \\text{GGGGGGTTTTTT}$\n    -   $S_4 = \\text{GGGGTGTTTTTT}$\n    -   $C = \\text{AAAAAATTTTTT}$\n-   进化支关联：$(S_1, S_2)$ 属于进化支 $X$；$(S_3, S_4)$ 属于进化支 $Y$。\n-   $C$ 的嵌合来源：它由 $S_1$ 的前 $6$ 个位置和 $S_3$ 的后 $6$ 个位置构成。这个定义与所提供的 $C$ 序列一致。\n-   聚类算法：非加权配对群算术平均法 (UPGMA)。\n-   距离度量：$d(i,j) = 1 - \\text{pid}(i,j)$，其中 $\\text{pid}(i,j)$ 是相同位点的比例。鉴于所有序列的长度均为 $L=12$ 且无间隙，这等同于 $d(i,j) = m(i,j)/12$，其中 $m(i,j)$ 是序列 $i$ 和 $j$ 之间的错配数。\n-   比对程序：基于 UPGMA 指导树的渐进式多序列比对。\n-   约束：不使用迭代优化或事后重新比对。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据标准科学准则对问题陈述进行评估：\n-   **科学性**：该问题植根于生物信息学的基本概念，即序列比对、距离计算、系统发育树构建 (UPGMA) 以及嵌合序列的混淆效应。所有方法和定义都是该领域的标准。\n-   **适定性**：该问题是适定的。提供的序列和算法（具有指定距离度量的 UPGMA）足以生成唯一的指导树和可预测的比对结果。问题要求描述这一结果。\n-   **客观性**：问题陈述客观、精确，没有歧义或主观因素。\n-   **内部一致性**：对嵌合序列 $C$ 的文字描述与明确提供的序列数据一致。所有数据和条件都是自洽的。\n\n### 步骤 3：结论与行动\n问题有效。可以推导出严谨的解决方案。\n\n### 解决方案的推导\n\n解决方案需要两个主要步骤：1) 构建 UPGMA 指导树，以及 2) 分析由此产生的渐进式多序列比对 (MSA)。\n\n**步骤 1：UPGMA 树的构建**\n\n首先，我们必须计算成对距离矩阵 $D$。距离为 $d(i,j) = m(i,j)/12$。\n\n错配数 $m(i,j)$ 如下：\n-   $m(S_1, S_2) = 1$（在位置 $6$ 处错配）\n-   $m(S_3, S_4) = 1$（在位置 $6$ 处错配）\n-   $m(S_1, S_3) = 12$\n-   $m(S_1, S_4) = 12$\n-   $m(S_2, S_3) = 12$\n-   $m(S_2, S_4) = 12$\n-   $m(S_1, C) = m(\\text{AAAAAACCCCCC}, \\text{AAAAAATTTTTT}) = 7$（在位置 $6$ 和位置 $7$-$12$ 处错配）\n-   $m(S_2, C) = m(\\text{AAAAATCCCCCC}, \\text{AAAAAATTTTTT}) = 6$（在位置 $7$-$12$ 处错配）\n-   $m(S_3, C) = m(\\text{GGGGGGTTTTTT}, \\text{AAAAAATTTTTT}) = 6$（在位置 $1$-$6$ 处错配）\n-   $m(S_4, C) = m(\\text{GGGGTGTTTTTT}, \\text{AAAAAATTTTTT}) = 6$（在位置 $1$-$5$ 和位置 $6$ 处错配）\n\n距离矩阵 $D$ 是（错配矩阵的 $1/12$）：\n$$\nD = \\begin{pmatrix}\n & S_1 & S_2 & S_3 & S_4 & C \\\\\nS_1 & 0 & 1/12 & 12/12 & 12/12 & 7/12 \\\\\nS_2 & 1/12 & 0 & 12/12 & 12/12 & 6/12 \\\\\nS_3 & 12/12 & 12/12 & 0 & 1/12 & 6/12 \\\\\nS_4 & 12/12 & 12/12 & 1/12 & 0 & 6/12 \\\\\nC & 7/12 & 6/12 & 6/12 & 6/12 & 0\n\\end{pmatrix}\n$$\n\n现在，我们应用 UPGMA 算法：\n\n-   **迭代 1**：最小的非零距离是 $d(S_1, S_2) = 1/12$ 和 $d(S_3, S_4) = 1/12$。我们可以合并这两对。\n    -   聚类 $U_X = (S_1, S_2)$。\n    -   聚类 $U_Y = (S_3, S_4)$。\n    问题简化为找到 $\\{U_X, U_Y, C\\}$ 的聚类方式。我们需要计算这三个实体之间的距离。\n\n-   **迭代 2**：我们计算新簇与剩余序列 $C$ 之间的距离。UPGMA 距离是算术平均值。\n    -   $d(C, U_X) = \\frac{d(C, S_1) + d(C, S_2)}{2} = \\frac{7/12 + 6/12}{2} = \\frac{13/12}{2} = 13/24$。\n    -   $d(C, U_Y) = \\frac{d(C, S_3) + d(C, S_4)}{2} = \\frac{6/12 + 6/12}{2} = \\frac{12/12}{2} = 1/2 = 12/24$。\n    -   原始非嵌合簇之间的距离是：\n        $d(U_X, U_Y) = \\frac{d(S_1,S_3)+d(S_1,S_4)+d(S_2,S_3)+d(S_2,S_4)}{4} = \\frac{1+1+1+1}{4} = 1 = 24/24$。\n\n-   **迭代 3**：我们比较距离 $\\{d(C, U_X), d(C, U_Y), d(U_X, U_Y)\\}$。\n    -   $d(C, U_Y) = 12/24$\n    -   $d(C, U_X) = 13/24$\n    -   $d(U_X, U_Y) = 24/24$\n    最小距离是 $d(C, U_Y) = 12/24$。因此，UPGMA 将 $C$ 与簇 $U_Y = (S_3, S_4)$ 合并。这创建了一个新簇 $U_{YC} = ((S_3, S_4), C)$。\n\n-   **迭代 4**：最后一步是将簇 $U_X$ 与簇 $U_{YC}$ 合并。\n\n最终的 UPGMA 指导树拓扑结构是 $((S_1, S_2), ((S_3, S_4), C))$。\n\n**步骤 2：渐进式比对分析**\n\n渐进式 MSA 程序将遵循指导树的分支顺序：\n1.  对齐 $S_1$ 和 $S_2$ 以创建轮廓 $P_{12}$。这两个序列高度相似，从而产生一个代表进化支 $X$ 的高质量轮廓。\n2.  对齐 $S_3$ 和 $S_4$ 以创建轮廓 $P_{34}$。这两个序列也高度相似，从而产生一个代表进化支 $Y$ 的高质量轮廓。\n3.  将轮廓 $P_{34}$ 与序列 $C$ 对齐以创建轮廓 $P_{C34}$。错误就是在这里引入的。\n    -   $P_{34}$ 的前半部分富含 G（$\\text{GGGG(G/T)G}$）。$C$ 的前半部分富含 A（$\\text{AAAAAA}$）。\n    -   $P_{34}$ 和 $C$ 的后半部分都富含 T（$\\text{TTTTTT}$）。\n    -   轮廓 $P_{C34}$ 变成了一个混合体：其前半部分是 G 和 A 的复合体，而后半部分则纯粹是 T。\n4.  将轮廓 $P_{12}$ 与轮廓 $P_{C34}$ 对齐。这是最后的比对步骤。\n    -   $P_{12}$ 的前半部分富含 A（$\\text{AAAA(A/T)A}$）。它将与 $P_{C34}$ 的混合 A/G 前半部分对齐。这迫使来自进化支 $Y$ 的富含 G 的序列与来自进化支 $X$ 的富含 A 的序列对齐。\n    -   $P_{12}$ 的后半部分富含 C（$\\text{CCCCCC}$）。它将与 $P_{C34}$ 的富含 T 的后半部分对齐。这迫使进化支 $X$ 的富含 C 的片段与进化支 $Y$ 和 $C$ 的富含 T 的片段对齐。\n\n嵌合序列 $C$ 在非同源区域之间起到了人为桥梁的作用。由于它与进化支 $Y$ 的平均距离稍小，它被错误地分组。这导致指导树从根本上错误地表示了进化历史，从而使渐进式比对算法产生了一个生物学上不正确的 MSA，其中序列的前后两半部分都被错误比对。\n\n### 选项评估\n\n-   **A. UPGMA 首先聚类 $(S_1,S_2)$ 和 $(S_3,S_4)$，然后将 $C$ 附加到 $(S_3,S_4)$ 簇，最后再与 $(S_1,S_2)$ 合并。因此，渐进式比对会将 $(C,S_3,S_4)$ 的轮廓与 $(S_1,S_2)$ 的轮廓进行比对，从而使得 $(C,S_3,S_4)$ 富含 $T$ 的后半部分被迫与 $(S_1,S_2)$ 富含 $C$ 的后半部分对齐，而富含 $G$ 的前半部分则与富含 $A$ 的前半部分对齐，这混合了不相关的片段，并降低了前后两半部分的比对准确性。**\n    -   对 UPGMA 树拓扑结构的描述与上文推导的完全一致。\n    -   对渐进式比对后果的描述也是正确的。关键的最后一步是对齐 $(C,S_3,S_4)$ 轮廓和 $(S_1,S_2)$ 轮廓。后半部分被迫对齐（`T`s vs `C`s）的陈述是准确的。前半部分被迫对齐的描述也是正确的；虽然 $(C,S_3,S_4)$ 的轮廓是 G 和 A 的混合体，但“富含 G 的前半部分”可以理解为指进化支 $Y$ 序列的贡献，这些序列是富含 G 的。这种措辞正确地抓住了错配的本质：迫使进化支 $Y$ 的前半部分与进化支 $X$ 的前半部分对齐。混合不相关片段并降低准确性的结论是合理的。\n    -   **结论：正确。**\n\n-   **B. UPGMA 将 $C$ 放置在根部，作为与所有其他序列等距的外群，使得渐进式比对相对于不含 $C$ 的比对实际上没有变化。**\n    -   我们的计算表明 $d(C, U_Y) < d(C, U_X)$，所以 $C$ 与其他簇并非等距。它被明确地与 $(S_3, S_4)$ 组放在一起，而不是作为一个通用的外群。\n    -   **结论：不正确。**\n\n-   **C. UPGMA 首先将 $C$ 与 $S_1$ 聚类，然后将这对序列与 $S_2$ 合并形成进化支 $X$，由于 $C$ 与 $S_1$ 共享前半部分，从而防止了干扰；最终的 MSA 在前后两半部分都保持最优。**\n    -   初始的最小距离是 $d(S_1, S_2) = 1/12$ 和 $d(S_3, S_4) = 1/12$，这两个值都小于 $d(C, S_1) = 7/12$。因此，UPGMA 不会首先将 $C$ 与 $S_1$ 聚类。UPGMA 在计算距离时考虑整个序列，而不仅仅是半个序列。\n    -   **结论：不正确。**\n\n-   **D. UPGMA 首先将 $S_1$ 和 $S_3$ 聚类，因为 $C$ 桥接了它们并降低了它们的估计距离；尽管这在指导树中混合了不同的进化支，但渐进式比对器会通过迭代优化进行补偿以恢复正确的 MSA。**\n    -   距离 $d(S_1, S_3) = 1$ 是可能的最大距离；它们将是最后被聚类的序列。$C$ 的存在不会改变其他序列之间计算的成对距离。\n    -   问题明确禁止使用迭代优化。\n    -   **结论：不正确。**\n\n唯一正确描述了 UPGMA 过程及其后果的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "2418778"}, {"introduction": "上一个练习揭示了简单渐进式比对的潜在缺陷，这自然引出了一个问题：我们能否修正这些早期阶段犯下的错误？本练习 [@problem_id:2418797] 探讨了像 MUSCLE 这样的现代比对算法背后的核心思想——“迭代优化”。您将通过分析不同类型的序列数据集，培养一种直觉，以判断何时以及为何需要这种强大的技术来获得准确的比对结果。", "problem": "您正在比较两种作用于相同输入的多序列比对策略：(i) 一种标准渐进式多序列比对方法，该方法根据成对比对距离构建引导树，并沿着该树执行一次序列-序列和谱-谱比对，之后不进行任何修改，以及 (ii) 一种带有迭代优化的方法，如 Multiple Sequence Comparison by Log-Expectation (MUSCLE)，该方法重复地将当前引导树分割成子树，并重新比对生成的谱以优化评分目标。假设在所有情况下都使用氨基酸字母表，并进行全局共线性比对。相对于初始的渐进式比对，哪个序列集最有可能在经过迭代优化后，其比对准确性得到显著提升？请选择唯一一个选项。\n\nA. 一组包含 $4$ 个蛋白质序列，所有序列都以相同的顺序共享两个保守基序（motif），这些基序被不同长度和组成的低复杂度插入序列隔开：\n- s1: HVDLNNNNNNNNNNNNWRTK\n- s2: HVDLWRTK\n- s3: HVDLQQQQQQQQQQWRTK\n- s4: HVDLSSSSSSSSSSSSSSWRTK\n\nB. 一组包含 $4$ 个高度相似、长度相同的蛋白质序列，它们之间仅有单个替换的差异：\n- t1: MKTALV\n- t2: MKTALM\n- t3: MKTAIV\n- t4: MKTALV\n\nC. 一组包含 $4$ 个蛋白质序列，其中两个保守结构域在不同序列中以不同顺序出现（推测为结构域重排）：\n- u1: HVDLAAAAWRTK\n- u2: WRTKAAA AHVDL\n- u3: HVDLAAA AAWRTK\n- u4: WRTKAAAAHVDL\n\nD. 一组包含 $4$ 个蛋白质序列，其主要特征是长的低复杂度序列，仅共享一个非常短的核心：\n- v1: NNNNNNNNNNNHHHNNNNNNNNN\n- v2: QQQQQQQQQQQHHHQQQQQQQQQ\n- v3: SSSSSSSSSSSHHHSSSSSSSSS\n- v4: NNNQQQSSSHHHNNNQQQSSS", "solution": "用户要求分析两种多序列比对（MSA）策略，并评估给定的四个序列集中，哪一个最能从更高级的策略中受益。\n\n首先，我将验证问题陈述的有效性。\n\n### 第1步：提取已知条件\n- **策略1（渐进式MSA）：** 使用一种标准的渐进式MSA方法。它首先根据成对比对距离构建一个引导树。然后，沿着引导树进行一次序列-序列和谱-谱比对。之后不再进行修改。这是一种“贪心”算法。\n- **策略2（迭代优化）：** 使用一种带有迭代优化的MSA方法，类似于 MUSCLE (Multiple Sequence Comparison by Log-Expectation)。该方法重复地将引导树分割成子树，并重新比对生成的谱以优化评分目标。\n- **约束条件：** 所有比对都使用氨基酸字母表，并且是全局、共线性的。\n- **问题：** 确定与策略1（初始渐进式比对）相比，使用策略2（迭代优化）时，哪个给定的序列集最有可能在比对准确性上显示出显著的提升。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题在计算生物学领域有坚实的理论基础。渐进式比对（例如Clustal系列）和迭代优化（例如MUSCLE、MAFFT）是解决NP难的多序列比对问题的两种最基本和广泛使用的启发式方法。引导树、谱-谱比对、评分目标以及全局/共线性比对等概念都是标准且定义明确的。该问题在科学上是合理的。\n2.  **问题的适定性：** 该问题要求找出一种特定算法（迭代优化）相对于另一种算法（简单渐进式比对）的改进“最有可能”是“显著”的场景。这构建了一个适定问题(well-posed problem)，可以通过分析迭代优化旨在纠正的渐进式比对的已知失败模式来回答。可以从这些原理中得出一个唯一且有意义的答案。\n3.  **客观性：** 问题陈述是客观的，并使用了该领域的精确术语。它不包含主观或基于观点的论断。\n4.  **完整性：** 该问题提供了足够的信息来推断算法的行为。标准渐进式比对的“贪心”性质与迭代优化的纠正性质之间的对比已明确建立。\n\n### 第3步：结论与行动\n问题陈述是有效的。它提出了一个关于不同MSA算法基于输入序列特征的性能的标准概念性问题。我将继续进行解答。\n\n### 基于原理的推导\n标准渐进式比对方法（策略1）的核心弱点是其贪心性质。该过程依赖于根据初始成对序列距离构建的引导树。比对过程从树的叶节点向根节点进行。一旦一组序列被比对形成一个谱（profile），在该比对中引入的任何空位都会被固定下来，无法在后续阶段进行修改。这通常被概括为“一次空位，永久空位”（once a gap, always a gap）的原则。如果初始的引导树不正确，或者早期的比对步骤存在歧义且被错误地解决，这些错误将不可逆地在整个过程中传播，导致最终得到一个次优的比对结果。\n\n迭代优化（策略2）正是为了克服这一局限性而设计的。它从一个初始比对（通常由快速的渐进式方法生成）开始，然后尝试改进它。通过系统地或随机地将比对分割成两个子比对（基于引导树的划分），并重新比对这些子比对，它探索了不同的比对配置。如果一个新的配置能带来更好的整体目标得分（例如，更高的“配对得分总和”），那么这个配置就会被接受。这个过程会不断重复，直到找不到进一步的改进为止。\n\n因此，迭代优化带来的“显著提升”最有可能发生在以下情况：\n1.  由于引导树不准确，初始的渐进式比对很可能是不正确的。\n2.  正确的比对（在比对得分上）显著优于不正确的比对，这为优化过程提供了一个强烈的信号，使其朝着正确的方向进行优化。\n3.  序列的性质是共线性的，符合比对算法的底层模型。\n\n现在我将根据这些标准分析每个选项。\n\n### 逐项分析\n\n**A. 一组包含 $4$ 个蛋白质序列，所有序列都以相同的顺序共享两个保守基序（motif），这些基序被不同长度和组成的低复杂度插入序列隔开。**\n序列如下：\n- `s1`: `HVDLNNNNNNNNNNNNWRTK`\n- `s2`: `HVDLWRTK`\n- `s3`: `HVDLQQQQQQQQQQWRTK`\n- `s4`: `HVDLSSSSSSSSSSSSSSWRTK`\n\n在这一组中，保守基序`HVDL`和`WRTK`提供了强烈的同源信号。然而，长的、可变的、低复杂度的插入序列的存在使得成对距离的计算变得困难。任意两个序列之间的比对得分会受到比对不同长度区域所需的大量空位罚分，或比对不同低复杂度重复序列的低替换得分的严重影响。这很容易导致对进化距离的错误估计，从而产生不正确的引导树。例如，算法可能会在将`s1`和`s4`与较短序列配对之前，错误地将它们先配对。基于这样一个错误引导树的贪心渐进式比对很可能会错误地比对其中一个保守基序。由于这些基序本身很重要，一个正确的比对会比不正确的比对得分高得多。迭代优化过程通过尝试不同的划分，有很高的概率找到这个得分更高的比对，从而纠正初始错误。这个场景是迭代优化表现出色的典型例子。\n\n**结论：正确。**这个序列集很有可能导致引导树不正确和初始比对次优，而迭代优化可以纠正这个问题，带来显著的提升。\n\n**B. 一组包含 $4$ 个高度相似、长度相同的蛋白质序列，它们之间仅有单个替换的差异。**\n序列如下：\n- `t1`: `MKTALV`\n- `t2`: `MKTALM`\n- `t3`: `MKTAIV`\n- `t4`: `MKTALV`\n\n这些序列是高度同源的，它们的比对非常简单。成对距离将准确地反映它们之间的亲近关系，从而生成一个稳定且正确的引导树。初始的渐进式比对几乎肯定会产生最优结果，因为没有空位或歧义需要解决。迭代优化没有重大的错误需要纠正。因此，比对准确性的提升将是微不足道的或为零。\n\n**结论：错误。**对于初始比对已经最优的高度相似序列，迭代优化几乎没有任何优势。\n\n**C. 一组包含 $4$ 个蛋白质序列，其中两个保守结构域在不同序列中以不同顺序出现（推测为结构域重排）。**\n序列如下：\n- `u1`: `HVDLAAAAWRTK`\n- `u2`: `WRTKAAAAHVDL`\n- `u3`: `HVDLAAAAAWRTK`\n- `u4`: `WRTKAAAAHVDL`\n\n这组序列表现出结构域重组（domain shuffling），这是一种非共线性形式。问题明确指出，两种比对策略都假设进行**全局共线性比对**。这个数据集违反了这一假设。全局比对算法将彻底失败，因为它会试图将线性的、端到端的比对强加到非线性的数据上。无论使用哪种策略，得到的比对结果在生物学上都将是无意义的。迭代优化在同样的共线性假设下运行，无法修复模型与数据之间的这种根本性不匹配。它只能寻找一个得分稍高但仍然不正确的全局比对。它无法识别或解决结构域重排问题。因此，在*生物学相关*的准确性上不可能有“显著的提升”。\n\n**结论：错误。**问题在于非共线性，这超出了指定算法的处理范围。迭代优化无法修复此类错误。\n\n**D. 一组包含 $4$ 个蛋白质序列，其主要特征是长的低复杂度序列，仅共享一个非常短的核心。**\n序列如下：\n- `v1`: `NNNNNNNNNNN`HHH`NNNNNNNNN`\n- `v2`: `QQQQQQQQQQQ`HHH`QQQQQQQQQ`\n- `v3`: `SSSSSSSSSSS`HHH`SSSSSSSSS`\n- `v4`: `NNNQQQSSS`HHH`NNNQQQSSS`\n\n与选项A类似，初始的引导树很可能是不正确的。然而，情况更为严重。唯一真正的同源信号是微小的`HHH`基序。迭代优化过程旨在优化的整体比对得分将完全由长的、非同源的、低复杂度的侧翼区域的比对决定。正确比对`3`个残基的`HHH`核心可能只会对总分产生微不足道的提升，这种提升可能会淹没在对侧翼区域评分的噪声中。优化算法甚至可能不会“看到”这一改进足够显著而加以追求，或者它可能会收敛到一个局部最优解，其中侧翼区域比对得“更好”，但核心仍然不正确。与选项A相比（其中保守区域要长得多，总共有$8$个残基，并提供更强的信号），选项D中获得显著、有针对性的改进的潜力要低得多。信噪比极差。\n\n**结论：错误。**虽然初始比对可能很差，但与非同源区域相比，同源信号太弱，迭代优化无法可靠地发挥作用并产生目标得分的*显著*提升。选项A为优化提供了更有利的条件。", "answer": "$$\\boxed{A}$$", "id": "2418797"}, {"introduction": "在探讨了核心概念与挑战之后，检验理解程度的最终方式是亲手构建这个工具。这最后一个练习 [@problem_id:2418810] 将指导您从零开始，实现一个基础的渐进式比对算法。这个编程任务将引导树和谱-谱比对（profile-profile alignment）等抽象概念与动态规划及数据结构等具体实践联系起来，从而彻底揭开其工作原理的神秘面纱。", "problem": "给定一个脱氧核糖核酸 (DNA) 核苷酸的有限字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 和一个不属于 $\\Sigma$ 的空位符 $-$。设两两替换计分函数 $S:\\left(\\Sigma \\cup \\{-\\}\\right)\\times\\left(\\Sigma \\cup \\{-\\}\\right)\\to\\mathbb{Z}$ 由以下规则定义：\n- 对于任意 $a \\in \\Sigma$，$S(a,a) = +1$。\n- 对于任意不同的 $a,b \\in \\Sigma$ 且 $a \\neq b$，$S(a,b) = -1$。\n- 对于任意 $a \\in \\Sigma$，$S(a,-) = S(-,a) = \\gamma$ 且 $\\gamma = -2$。\n- $S(-,-) = 0$。\n\n给定一棵有根的、完全二叉引导树，其叶节点由一组序列标识符进行单射标记，并且每个叶节点标签都映射到 $\\Sigma$ 上的一个有限字符串（可能为空字符串），多序列比对的定义如下。对于每个具有左子节点和右子节点的内部节点，通过在全局比对模型下最大化所有跨序列组（一个序列来自左子比对，另一个来自右子比对）的序列对基于 $S$ 的两两得分总和，来合并其两个子比对，从而形成一个合并比对。该模型允许在将一个序列组与另一个序列组的某一列进行比对时，为其中一方插入完全由空位组成的列。当比对两个现有列时，其对总分的贡献是所有有序对 $(x,y)$ 的 $S(x,y)$ 之和，其中 $x$ 是来自左列的一个字符（可能是从先前合并中继承的空位），$y$ 是来自右列的一个字符（也可能是从先前合并中继承的空位）。当将一列与为另一序列组插入的空位列进行比对时，其贡献是该非空位列中所有字符 $x$ 的 $S(x,-)$ 之和。根节点的比对即为最终的多序列比对。\n\n为确保在存在多个最优解时的确定性，在每个内部节点的全局比对中应用以下平局打破顺序：优先选择将一列与另一列比对，其次是将一列与右侧序列组的空位列比对，最后是将左侧序列组的空位列与右侧序列组的列比对。\n\n对于任意得到的包含 $N$ 个序列且比对后长度均为 $L$ 的多序列比对 $\\mathcal{A}$，其配对得分总和 (Sum-of-Pairs, SP) 分数定义为\n$$\n\\mathrm{SP}(\\mathcal{A}) \\;=\\; \\sum_{1 \\leq i < j \\leq N} \\;\\sum_{k=1}^{L} \\; S\\!\\left(\\mathcal{A}_{i,k}, \\mathcal{A}_{j,k}\\right),\n$$\n其中 $\\mathcal{A}_{i,k}$ 表示第 $i$ 个序列在第 $k$ 个比对位置上的字符（属于 $\\Sigma \\cup \\{-\\}$）。\n\n您的任务是编写一个完整的程序，根据每个引导树及其关联序列构建所导出的多序列比对，然后计算最终比对的 SP 分数。请使用上文给出的确切的 $S$ 和 $\\gamma$ 值。树以基于叶节点标签的完全括号化的二元表达式形式指定。树中提到的所有叶节点都有一个对应的序列。\n\n测试套件。对于下方的每个测试用例，程序必须计算最终多序列比对的 SP 分数：\n\n- 测试用例 1：\n  - 序列：\n    - $s1 \\mapsto$ \"ACGT\"\n    - $s2 \\mapsto$ \"ACCT\"\n    - $s3 \\mapsto$ \"AGGT\"\n  - 引导树：$\\big((s1,s2),s3\\big)$\n\n- 测试用例 2：\n  - 序列：\n    - $t1 \\mapsto$ \"GATTACA\"\n    - $t2 \\mapsto$ \"GACTATA\"\n    - $t3 \\mapsto$ \"GACTACA\"\n  - 引导树：$\\big((t1,t2),t3\\big)$\n\n- 测试用例 3：\n  - 序列：\n    - $x1 \\mapsto$ \"AAA\"\n    - $x2 \\mapsto$ \"AAAA\"\n  - 引导树：$\\big(x1,x2\\big)$\n\n- 测试用例 4（包含空序列的边界情况）：\n  - 序列：\n    - $e1 \\mapsto$ \"\" (空字符串)\n    - $e2 \\mapsto$ \"AAA\"\n  - 引导树：$\\big(e1,e2\\big)$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），第 $i$ 个条目是按上文所列顺序的第 $i$ 个测试用例的 SP 分数（一个整数）。所有值都是无单位的整数。", "solution": "问题陈述已经过分析，被认为是有效的。它具有科学依据，定义明确，客观且内部一致。它描述了计算生物学中的一个标准算法——渐进式多序列比对——并且所有参数、过程以及平局打破规则都得到了明确的规定。因此，我们可以着手解决问题。\n\n任务是计算通过给定二叉树指导的渐进式策略构建的多序列比对的配对得分总和 (SP) 分数。该过程涉及对引导树进行递归的、自底向上的遍历。在每个内部节点，其两个子节点对应的比对会通过一个称为 profile-profile 比对的过程进行比对。树根节点的最终比对随后使用 SP 分数指标进行评估。\n\n解决方案的基本组成部分如下：\n1.  一种解析括号化引导树结构的方法。\n2.  一个遍历树并在每个内部节点执行比对的递归函数。\n3.  一个基于动态规划的 profile-profile 比对算法，它构成了渐进式比对过程的核心。\n4.  一个计算根比对最终 SP 分数的函数。\n\n我们按照规定定义计分函数 $S:\\left(\\Sigma \\cup \\{-\\}\\right)\\times\\left(\\Sigma \\cup \\{-\\}\\right)\\to\\mathbb{Z}$，其中 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$：\n-   对于任意 $a \\in \\Sigma$，$S(a,a) = +1$。\n-   对于任意不同的 $a,b \\in \\Sigma$，$S(a,b) = -1$。\n-   对于任意 $a \\in \\Sigma$，$S(a,-) = S(-,a) = \\gamma = -2$。\n-   $S(-,-) = 0$。\n\n一个 profile，即一个序列子集的现有比对，可以表示为一组长度一致的比对后序列。设左侧 profile $\\mathcal{A}_1$ 包含 $N_1$ 个长度为 $L_1$ 的序列，右侧 profile $\\mathcal{A}_2$ 包含 $N_2$ 个长度为 $L_2$ 的序列。profile-profile 比对的目标是通过向 $\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 中插入空位列来生成一个新的、包含所有 $N_1+N_2$ 个序列的合并比对，并最大化一个预定义的得分。\n\n$\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 之间的比对是使用一种动态规划算法完成的，该算法类似于用于两序列比对的 Needleman-Wunsch 算法。我们构建一个大小为 $(L_1+1) \\times (L_2+1)$ 的动态规划矩阵 $M$，其中 $M_{i,j}$ 存储了 $\\mathcal{A}_1$ 长度为 $i$ 的前缀（即前 $i$ 列）与 $\\mathcal{A}_2$ 长度为 $j$ 的前缀进行比对所能得到的最大得分。\n\n比对两个 profile 列，或一个 profile 列与一个空位列的得分必须被定义。问题陈述指出，该得分是所有跨 profile 序列对的得分之和。\n-   **列-列得分**：将 $\\mathcal{A}_1$ 的第 $i$ 列与 $\\mathcal{A}_2$ 的第 $j$ 列进行比对的得分，记为 $\\text{score}_{\\text{col-col}}(i,j)$，由下式给出：\n    $$ \\text{score}_{\\text{col-col}}(i,j) = \\sum_{p=1}^{N_1} \\sum_{q=1}^{N_2} S\\left((\\mathcal{A}_1)_{p,i}, (\\mathcal{A}_2)_{q,j}\\right) $$\n    其中 $(\\mathcal{A}_k)_{r,c}$ 是比对 $\\mathcal{A}_k$ 中第 $r$ 个序列在第 $c$ 列的字符。\n-   **列-空位得分**：将一个列与一个空位列进行比对的得分，是为被插入空位的 profile 中的每个序列计算的空位罚分之和。\n    -   将 $\\mathcal{A}_1$ 的第 $i$ 列与空位（为 $\\mathcal{A}_2$ 中的所有 $N_2$ 个序列）进行比对：\n        $$ \\text{score}_{\\text{gap-R}}(i) = \\sum_{p=1}^{N_1} N_2 \\cdot S\\left((\\mathcal{A}_1)_{p,i}, -\\right) $$\n    -   将 $\\mathcal{A}_2$ 的第 $j$ 列与空位（为 $\\mathcal{A}_1$ 中的所有 $N_1$ 个序列）进行比对：\n        $$ \\text{score}_{\\text{gap-L}}(j) = \\sum_{q=1}^{N_2} N_1 \\cdot S\\left(-, (\\mathcal{A}_2)_{q,j}\\right) $$\n\nDP 矩阵 $M$ 的填充方式如下：\n-   **初始化**：\n    $$ M_{0,0} = 0 $$\n    $$ M_{i,0} = M_{i-1,0} + \\text{score}_{\\text{gap-R}}(i) \\quad \\text{对于 } i \\in [1, L_1] $$\n    $$ M_{0,j} = M_{0,j-1} + \\text{score}_{\\text{gap-L}}(j) \\quad \\text{对于 } j \\in [1, L_2] $$\n-   **递推关系**：对于 $i \\in [1, L_1]$ 和 $j \\in [1, L_2]$，$M_{i,j}$ 的计算基于以下三种可能性：\n    1.  将 $\\mathcal{A}_1$ 的第 $i$ 列与 $\\mathcal{A}_2$ 的第 $j$ 列比对（对角移动）：$S_{\\text{diag}} = M_{i-1, j-1} + \\text{score}_{\\text{col-col}}(i,j)$。\n    2.  将 $\\mathcal{A}_1$ 的第 $i$ 列与一个空位列比对（向下移动）：$S_{\\text{down}} = M_{i-1, j} + \\text{score}_{\\text{gap-R}}(i)$。\n    3.  将 $\\mathcal{A}_2$ 的第 $j$ 列与一个空位列比对（向右移动）：$S_{\\text{right}} = M_{i, j-1} + \\text{score}_{\\text{gap-L}}(j)$。\n\n    $$ M_{i,j} = \\max(S_{\\text{diag}}, S_{\\text{down}}, S_{\\text{right}}) $$\n\n为了确保结果的确定性，应用了平局打破规则。问题指定了偏好顺序：(1) 列-列比对，(2) 左侧 profile 的列与空位比对，(3) 右侧 profile 的列与空位比对。这对应于在 DP 矩阵中优先选择对角移动，然后是向下移动，最后是向右移动。在构建 $M$ 的同时构建一个回溯矩阵 $T$ 来存储最优选择。\n\n一旦矩阵 $M$ 被填充完毕，就通过使用存储在 $T$ 中的选择，从 $M_{L_1,L_2}$ 回溯到 $M_{0,0}$ 来重建最优比对。回溯中的每一步都对应于构建新合并比对的一列。\n\n在引导树的根节点处完成整个渐进式比对过程后，会得到一个包含 $N$ 个序列、长度为 $L$ 的最终多序列比对 $\\mathcal{A}$。其配对得分总和 (SP) 分数按规定计算如下：\n$$ \\mathrm{SP}(\\mathcal{A}) = \\sum_{1 \\leq i < j \\leq N} \\sum_{k=1}^{L} S(\\mathcal{A}_{i,k}, \\mathcal{A}_{j,k}) $$\n该分数可以通过遍历所有序列对并对它们的两两比对得分求和来计算，或者等效地，通过遍历每一列，计算该列内所有字符对的得分总和，然后将这些列得分相加来计算。\n\n整体算法的实现首先是将引导树解析为一个嵌套结构。然后，一个递归函数遍历该结构，在每个内部节点执行 profile-profile 比对并返回合并后的 profile。递归的基线条件是叶节点，即单个序列。在根节点的递归最终结果是完整的多序列比对，然后计算其 SP 分数。", "answer": "```python\nimport numpy as np\nimport sys\nfrom collections import defaultdict\n\n# Set a higher recursion limit for deep trees, although not strictly necessary for test cases.\nsys.setrecursionlimit(2000)\n\n_S_SCORES = None\n_GAMMA = -2\n\ndef S(c1, c2):\n    \"\"\"Computes the substitution score S(c1, c2).\"\"\"\n    global _S_SCORES\n    if _S_SCORES is None:\n        _S_SCORES = defaultdict(lambda: defaultdict(int))\n        alphabet = ['A', 'C', 'G', 'T']\n        for char1 in alphabet:\n            for char2 in alphabet:\n                _S_SCORES[char1][char2] = 1 if char1 == char2 else -1\n            _S_SCORES[char1]['-'] = _GAMMA\n            _S_SCORES['-'][char1] = _GAMMA\n        _S_SCORES['-']['-'] = 0\n    return _S_SCORES[c1][c2]\n\ndef parse_tree(expr):\n    \"\"\"\n    Parses a Newick-like tree string into a nested tuple structure.\n    Example: '((s1,s2),s3)' -> (('s1', 's2'), 's3')\n    \"\"\"\n    expr = expr.strip()\n    if expr.startswith('(') and expr.endswith(')'):\n        expr = expr[1:-1]\n        balance = 0\n        split_index = -1\n        for i, char in enumerate(expr):\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            elif char == ',' and balance == 0:\n                split_index = i\n                break\n        \n        if split_index != -1:\n            left = expr[:split_index]\n            right = expr[split_index+1:]\n            return (parse_tree(left), parse_tree(right))\n    return expr\n\ndef progressive_align(node, sequences):\n    \"\"\"\n    Recursively performs progressive alignment based on the guide tree.\n    `node`: a node from the parsed tree structure.\n    `sequences`: a dict mapping sequence IDs to sequences.\n    \n    Returns a profile (dict mapping seq_id to aligned sequence).\n    \"\"\"\n    if isinstance(node, str):  # Leaf node\n        return {node: sequences[node]}\n    \n    left_child, right_child = node\n    \n    left_profile = progressive_align(left_child, sequences)\n    right_profile = progressive_align(right_child, sequences)\n    \n    return profile_profile_align(left_profile, right_profile)\n\ndef profile_profile_align(prof1, prof2):\n    \"\"\"\n    Aligns two profiles using dynamic programming.\n    Profiles are dicts of {seq_id: aligned_sequence}.\n    \"\"\"\n    if not prof1: return prof2\n    if not prof2: return prof1\n\n    seqs1 = list(prof1.values())\n    seqs2 = list(prof2.values())\n\n    len1 = len(seqs1[0]) if seqs1 else 0\n    len2 = len(seqs2[0]) if seqs2 else 0\n    n1, n2 = len(seqs1), len(seqs2)\n\n    dp_matrix = np.zeros((len1 + 1, len2 + 1))\n    # 1: diag, 2: down (gap in prof2), 3: right (gap in prof1)\n    traceback_matrix = np.zeros((len1 + 1, len2 + 1), dtype=int)\n\n    # Calculate column-gap scores\n    prof1_cols = list(zip(*seqs1))\n    prof2_cols = list(zip(*seqs2))\n\n    gap_scores1 = np.array([sum(S(c, '-') for c in col) * n2 for col in prof1_cols])\n    gap_scores2 = np.array([sum(S(c, '-') for c in col) * n1 for col in prof2_cols])\n\n    # Initialize DP matrix\n    for i in range(1, len1 + 1):\n        dp_matrix[i, 0] = dp_matrix[i - 1, 0] + gap_scores1[i - 1]\n        traceback_matrix[i, 0] = 2\n    for j in range(1, len2 + 1):\n        dp_matrix[0, j] = dp_matrix[0, j - 1] + gap_scores2[j - 1]\n        traceback_matrix[0, j] = 3\n\n    # Fill DP matrix\n    for i in range(1, len1 + 1):\n        col1 = prof1_cols[i - 1]\n        for j in range(1, len2 + 1):\n            col2 = prof2_cols[j - 1]\n            \n            match_score = sum(S(c1, c2) for c1 in col1 for c2 in col2)\n            \n            s_diag = dp_matrix[i - 1, j - 1] + match_score\n            s_down = dp_matrix[i - 1, j] + gap_scores1[i - 1]\n            s_right = dp_matrix[i, j - 1] + gap_scores2[j - 1]\n            \n            scores = [s_diag, s_down, s_right]\n            max_score = max(scores)\n            \n            # Apply tie-breaking: diag > down > right\n            if max_score == s_diag:\n                dp_matrix[i, j] = s_diag\n                traceback_matrix[i, j] = 1\n            elif max_score == s_down:\n                dp_matrix[i, j] = s_down\n                traceback_matrix[i, j] = 2\n            else: # max_score == s_right\n                dp_matrix[i, j] = s_right\n                traceback_matrix[i, j] = 3\n    \n    # Traceback\n    merged_profile = {seq_id: [] for seq_id in list(prof1.keys()) + list(prof2.keys())}\n    i, j = len1, len2\n    \n    while i > 0 or j > 0:\n        move = traceback_matrix[i, j]\n        if move == 1:  # Diag\n            for k, seq_id in enumerate(prof1.keys()):\n                merged_profile[seq_id].append(seqs1[k][i-1])\n            for k, seq_id in enumerate(prof2.keys()):\n                merged_profile[seq_id].append(seqs2[k][j-1])\n            i -= 1\n            j -= 1\n        elif move == 2:  # Down\n            for k, seq_id in enumerate(prof1.keys()):\n                merged_profile[seq_id].append(seqs1[k][i-1])\n            for seq_id in prof2.keys():\n                merged_profile[seq_id].append('-')\n            i -= 1\n        elif move == 3:  # Right\n            for seq_id in prof1.keys():\n                merged_profile[seq_id].append('-')\n            for k, seq_id in enumerate(prof2.keys()):\n                merged_profile[seq_id].append(seqs2[k][j-1])\n            j -= 1\n            \n    final_merged = {seq_id: \"\".join(reversed(chars)) for seq_id, chars in merged_profile.items()}\n    return final_merged\n\ndef calculate_sp_score(alignment):\n    \"\"\"Calculates the Sum-of-Pairs score for a given final alignment.\"\"\"\n    if not alignment or len(alignment) < 2:\n        return 0\n    \n    seq_ids = list(alignment.keys())\n    sequences = list(alignment.values())\n    \n    num_seqs = len(sequences)\n    if num_seqs == 0: return 0\n    \n    aln_len = len(sequences[0])\n    if aln_len == 0: return 0\n    \n    total_score = 0\n    # Sum of scores over columns\n    for k in range(aln_len):\n        col_score = 0\n        column = [sequences[i][k] for i in range(num_seqs)]\n        for i in range(num_seqs):\n            for j in range(i + 1, num_seqs):\n                col_score += S(column[i], column[j])\n        total_score += col_score\n        \n    return total_score\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        {\n            \"sequences\": {\"s1\": \"ACGT\", \"s2\": \"ACCT\", \"s3\": \"AGGT\"},\n            \"tree\": \"((s1,s2),s3)\"\n        },\n        {\n            \"sequences\": {\"t1\": \"GATTACA\", \"t2\": \"GACTATA\", \"t3\": \"GACTACA\"},\n            \"tree\": \"((t1,t2),t3)\"\n        },\n        {\n            \"sequences\": {\"x1\": \"AAA\", \"x2\": \"AAAA\"},\n            \"tree\": \"(x1,x2)\"\n        },\n        {\n            \"sequences\": {\"e1\": \"\", \"e2\": \"AAA\"},\n            \"tree\": \"(e1,e2)\"\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        sequences = case[\"sequences\"]\n        tree_expr = case[\"tree\"]\n        \n        parsed_tree = parse_tree(tree_expr)\n        final_alignment = progressive_align(parsed_tree, sequences)\n        sp_score = calculate_sp_score(final_alignment)\n        \n        results.append(int(sp_score))\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2418810"}]}