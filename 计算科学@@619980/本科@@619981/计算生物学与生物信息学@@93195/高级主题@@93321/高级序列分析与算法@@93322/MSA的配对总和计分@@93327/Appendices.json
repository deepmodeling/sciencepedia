{"hands_on_practices": [{"introduction": "要真正掌握配对总和（Sum-of-Pairs, SP）分数，最好的方法就是亲自动手计算。这个练习将从一个最基本但极具启发性的场景开始：一个由多个完全相同的序列组成的多序列比对。通过推导这种情况下的SP分数，你将能直观地理解序列数量 $k$ 如何通过组合数 $\\binom{k}{2}$ 影响总分，并为分析更复杂的比对奠定坚实的基础。[@problem_id:2432594]", "problem": "考虑一个包含 $k$ 条序列的多序列比对 (MSA)，其中多序列比对 (MSA) 是指将序列排列成 $L$ 个比对列。设这些序列是单个序列 $X = x_{1} x_{2} \\dots x_{L}$ 的 $k$ 个相同副本，该序列基于字母表 $\\Sigma$，并假设该比对是无空位的，因此这 $k$ 个相同副本按列堆叠。设配对评分函数为 $s : \\left(\\Sigma \\cup \\{-\\}\\right) \\times \\left(\\Sigma \\cup \\{-\\}\\right) \\to \\mathbb{R}$，其中 $-$ 表示空位符号，并假设 $s$ 在其定义域内的所有参数上都有定义。\n\n一个MSA的配对总分 (sum-of-pairs score) 定义为\n$$\n\\mathrm{SP} = \\sum_{1 \\le i < j \\le k} \\sum_{c=1}^{L} s\\!\\left(A_{i,c}, A_{j,c}\\right),\n$$\n其中 $A_{i,c}$ 表示比对矩阵中第 $i$ 行、第 $c$ 列的字符。\n\n对于上述由 $k$ 个 $X$ 的相同副本组成的无空位 MSA，请将配对总分表示为一个闭式解析表达式，该表达式包含 $k$、$L$、序列字符 $x_{1},\\dots,x_{L}$ 以及评分函数 $s$。请提供精确表达式；不需要数值近似或四舍五入。", "solution": "所述问题是有效的。它在科学上基于计算生物学的原理，特别是多序列比对的评估，并且在数学上是适定的。所有术语都已明确定义，并提供了足够的信息来推导出一个唯一的解析解。\n\n问题要求计算一个由 $k$ 个相同、无空位序列组成的多序列比对 (MSA) 的配对总分 ($\\mathrm{SP}$) 。设其唯一的底层序列为 $X = x_{1} x_{2} \\dots x_{L}$，其中 $L$ 是序列长度，每个字符 $x_{c}$ 属于字母表 $\\Sigma$。该 MSA 表示为一个大小为 $k \\times L$ 的矩阵 $A$。由于所有序列都相同且无空位比对，因此在任意给定行 $i$ 和列 $c$ 的字符（表示为 $A_{i,c}$）就是序列 $X$ 中的字符 $x_{c}$。也就是说，对于所有的 $i \\in \\{1, \\dots, k\\}$ 和 $c \\in \\{1, \\dots, L\\}$，我们有：\n$$\nA_{i,c} = x_{c}\n$$\n配对总分定义为对所有不同序列对的配对得分进行求和，再对所有比对列进行求和。其公式如下：\n$$\n\\mathrm{SP} = \\sum_{1 \\le i < j \\le k} \\sum_{c=1}^{L} s(A_{i,c}, A_{j,c})\n$$\n其中 $s$ 是配对评分函数。\n\n我们将 $A_{i,c}$ 的值代入此定义中。由于对于任意一对行 $i$ 和 $j$，都有 $A_{i,c} = x_{c}$ 和 $A_{j,c} = x_{c}$，因此评分项变为 $s(x_{c}, x_{c})$。\n$$\n\\mathrm{SP} = \\sum_{1 \\le i < j \\le k} \\sum_{c=1}^{L} s(x_{c}, x_{c})\n$$\n注意到项 $s(x_{c}, x_{c})$ 只依赖于列索引 $c$，而不依赖于行索引 $i$ 和 $j$。对于有限和，求和的顺序可以交换。因此，我们可以将表达式重写为：\n$$\n\\mathrm{SP} = \\sum_{c=1}^{L} \\sum_{1 \\le i < j \\le k} s(x_{c}, x_{c})\n$$\n对于固定的列 $c$，项 $s(x_{c}, x_{c})$ 相对于关于索引 $i$ 和 $j$ 的内层求和是一个常数。因此，我们可以将其从内层求和中提取出来：\n$$\n\\mathrm{SP} = \\sum_{c=1}^{L} \\left( s(x_{c}, x_{c}) \\sum_{1 \\le i < j \\le k} 1 \\right)\n$$\n内层求和 $\\sum_{1 \\le i < j \\le k} 1$ 计算的是从总共 $k$ 行中选取不同行对 $(i, j)$ 的数量。这是一个标准的组合问题，即从一个包含 $k$ 个元素的集合中选取 2 个元素，其结果由二项式系数 $\\binom{k}{2}$ 给出。\n$$\n\\sum_{1 \\le i < j \\le k} 1 = \\binom{k}{2} = \\frac{k(k-1)}{2}\n$$\n将此结果代回到 $\\mathrm{SP}$ 得分的表达式中：\n$$\n\\mathrm{SP} = \\sum_{c=1}^{L} s(x_{c}, x_{c}) \\frac{k(k-1)}{2}\n$$\n项 $\\frac{k(k-1)}{2}$ 相对于关于列 $c$ 的求和是一个常数。我们可以将此项从整个求和中提取出来：\n$$\n\\mathrm{SP} = \\frac{k(k-1)}{2} \\sum_{c=1}^{L} s(x_{c}, x_{c})\n$$\n这就是由一个序列 $X$ 的 $k$ 个相同、无空位副本组成的 MSA 的配对总分的最终闭式表达式。根据要求，它用序列数量 $k$、评分函数 $s$ 和序列字符 $x_{1}, \\dots, x_{L}$ 来表示。长度 $L$ 以求和上限的形式隐含在表达式中。", "answer": "$$\n\\boxed{\\frac{k(k-1)}{2} \\sum_{c=1}^{L} s(x_{c}, x_{c})}\n$$", "id": "2432594"}, {"introduction": "在真实世界的生物序列比对中，比对列很少是完全一致的。这个练习将挑战你处理一个更贴近现实的场景：一个包含两种不同氨基酸残基（丙氨酸和甘氨酸）的列。要解决这个问题，你需要运用组合学原理，将所有的配对分成不同类型（如同类配对和异类配对）并分别计数，这正是分析真实比对数据时所需的核心技能。[@problem_id:2432583]", "problem": "考虑一个由 $k$ 条同源蛋白质序列组成的多序列比对（MSA）中的单个比对列，其中 $k$ 是一个正偶数。该列恰好包含 $k/2$ 个丙氨酸（$\\mathrm{A}$）残基和 $k/2$ 个甘氨酸（$\\mathrm{G}$）残基，没有间隙字符。一列的配对加和（SP）得分定义为，在该列中，对所有无序序列对 $i<j$ 的残基 $x_{i}$ 和 $x_{j}$ 应用替换评分函数 $S(x_{i},x_{j})$ 后求和。假设 $S$ 是对称的，并记 $S(\\mathrm{A},\\mathrm{A})=s_{AA}$，$S(\\mathrm{G},\\mathrm{G})=s_{GG}$，以及 $S(\\mathrm{A},\\mathrm{G})=S(\\mathrm{G},\\mathrm{A})=s_{AG}$。推导该列 SP 得分的闭式表达式，以 $k$、$s_{AA}$、$s_{GG}$ 和 $s_{AG}$ 为函数。请以单个简化的解析表达式形式给出最终答案。无需进行四舍五入。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件。\n- 考虑一个包含 $k$ 条序列的多序列比对（MSA）。\n- $k$ 是一个正偶数。\n- 分析单个比对列。\n- 该列包含 $k/2$ 个丙氨酸（$\\mathrm{A}$）残基。\n- 该列包含 $k/2$ 个甘氨酸（$\\mathrm{G}$）残基。\n- 该列中没有间隙字符。\n- 配对加和（SP）得分定义为，对所有无序序列对 $i<j$ 的得分 $S(x_i, x_j)$ 求和，其中 $x_i$ 和 $x_j$ 是序列 $i$ 和 $j$ 在该列中的残基。\n- 替换评分函数 $S$ 是对称的。\n- 得分给定为 $S(\\mathrm{A},\\mathrm{A}) = s_{AA}$，$S(\\mathrm{G},\\mathrm{G}) = s_{GG}$，以及 $S(\\mathrm{A},\\mathrm{G}) = s_{AG}$。\n\n步骤 2：使用提取的已知条件进行验证。\n- **科学依据**：该问题基于标准的配对加和评分法，这是计算生物学中评估多序列比对质量的一个基本概念。其设定是一个简化但现实的场景。\n- **良构性**：该问题是自洽的，并提供了推导唯一解所需的所有信息。比对列的构成被精确指定，评分函数已定义，目标是找到一个闭式表达式。$k$ 是偶数的条件确保了 $k/2$ 是一个整数，使得问题具有一致性。\n- **客观性**：该问题以精确的数学语言陈述，没有任何主观性或模糊性。\n\n步骤 3：结论与行动。\n该问题被认为是有效的，因为它具有科学依据、良构、客观，并且不违反任何无效标准。将推导解答。\n\n该问题要求计算多序列比对中单个列的配对加和（SP）得分。该比对包含 $k$ 条序列。序列总数是一个偶数。所考虑的列包含 $n_A = k/2$ 个丙氨酸残基和 $n_G = k/2$ 个甘氨酸残基。\n\nSP 得分是比对中所有不同序列对的得分之和。此类配对的总数由二项式系数 $\\binom{k}{2}$ 给出。\n该列中的残基对可以划分为三种类型：丙氨酸-丙氨酸（$\\mathrm{A}$, $\\mathrm{A}$）、甘氨酸-甘氨酸（$\\mathrm{G}$, $\\mathrm{G}$）和丙氨酸-甘氨酸（$\\mathrm{A}$, $\\mathrm{G}$）。总 SP 得分是每种类型配对贡献的得分之和。\n\n$SP_{总分} = (\\text{A-A 配对数}) \\times s_{AA} + (\\text{G-G 配对数}) \\times s_{GG} + (\\text{A-G 配对数}) \\times s_{AG}$\n\n现在我们必须确定每种类型配对的数量。\n\n1.  丙氨酸-丙氨酸配对数：\n    该列中有 $n_A = k/2$ 个丙氨酸残基。选择两个不同丙氨酸残基的无序对的方法数由二项式系数 $\\binom{n_A}{2}$ 给出。\n    $$ \\text{A-A 配对数} = \\binom{k/2}{2} $$\n    二项式系数 $\\binom{n}{r}$ 定义为 $\\frac{n!}{r!(n-r)!}$。对于 $r=2$，这简化为 $\\frac{n(n-1)}{2}$。\n    $$ \\binom{k/2}{2} = \\frac{(k/2)(k/2 - 1)}{2} = \\frac{(k/2)(\\frac{k-2}{2})}{2} = \\frac{k(k-2)}{8} $$\n\n2.  甘氨酸-甘氨酸配对数：\n    类似地，有 $n_G = k/2$ 个甘氨酸残基。选择两个不同甘氨酸残基的无序对的方法数是 $\\binom{n_G}{2}$。\n    $$ \\text{G-G 配对数} = \\binom{k/2}{2} = \\frac{k(k-2)}{8} $$\n\n3.  丙氨酸-甘氨酸配对数：\n    为了形成一个丙氨酸-甘氨酸配对，我们必须从 $n_A = k/2$ 个可用的丙氨酸中选择一个丙氨酸残基，并从 $n_G = k/2$ 个可用的甘氨酸中选择一个甘氨酸残基。这样做的方法数是每种选择数量的乘积。\n    $$ \\text{A-G 配对数} = n_A \\times n_G = (k/2) \\times (k/2) = \\frac{k^2}{4} $$\n    由于评分函数 $S$ 是对称的，$S(\\mathrm{A},\\mathrm{G}) = S(\\mathrm{G},\\mathrm{A})$，我们不需要区分顺序。\n\n现在，我们将这些数量代回到总 SP 得分的表达式中。令总得分为 $\\Sigma$。\n$$ \\Sigma = \\left(\\frac{k(k-2)}{8}\\right) s_{AA} + \\left(\\frac{k(k-2)}{8}\\right) s_{GG} + \\left(\\frac{k^2}{4}\\right) s_{AG} $$\n\n该表达式可以通过提取公因式来简化。我们可以从前两项中提取因子 $\\frac{k(k-2)}{8}$。\n$$ \\Sigma = \\frac{k(k-2)}{8} (s_{AA} + s_{GG}) + \\frac{k^2}{4} s_{AG} $$\n\n这是该列 SP 得分作为 $k$、$s_{AA}$、$s_{GG}$ 和 $s_{AG}$ 的函数的最终闭式表达式。推导过程完整且逻辑严谨。", "answer": "$$\n\\boxed{\\frac{k(k-2)}{8} (s_{AA} + s_{GG}) + \\frac{k^2}{4} s_{AG}}\n$$", "id": "2432583"}, {"introduction": "理解了SP分数的数学原理后，下一步就是将其转化为可执行的计算过程。本练习将指导你从理论走向实践，要求你为一个给定的多序列比对编写计算SP分数的算法。这不仅是对你公式理解能力的检验，更是对算法思维和计算效率分析能力的锻炼，是连接理论知识和实际生物信息学应用的关键桥梁。[@problem_id:2432587]", "problem": "现为您提供多序列比对（Multiple Sequence Alignment, MSA）的配对总和（Sum-of-Pairs, SP）评分的形式化定义。设有 $k$ 条长度均为 $L$ 的已对齐序列，表示为一个字符串数组 $A = (A_1,\\dots,A_k)$。其中，每个 $A_i$ 的长度为 $L$，其字符集由大写字母和间隙符（gap character）$\"-\"$ 组成。$A$ 的配对总和（SP）分数 $S$ 定义为\n$$\nS \\;=\\; \\sum_{c=1}^{L} \\sum_{1 \\le i < j \\le k} s\\!\\left(A_{i,c}, A_{j,c}\\right),\n$$\n其中 $A_{i,c}$ 表示序列 $i$ 第 $c$ 列的符号，而逐列配对评分函数 $s(\\cdot,\\cdot)$ 定义如下：\n- $s(x,y)=+1$，若 $x=y$ 且 $x \\ne \"-\"$，\n- $s(x,y)=-1$，若 $x \\ne y$ 且 $x \\ne \"-\"$ 且 $y \\ne \"-\"\"$，\n- $s(x,y)=-2$，若 $x$ 或 $y$ 中仅有一个为 $\"-\"$，\n- $s(x,y)=0$，若 $x=y=\"-\"$。\n\n对于下方测试套件中提供的每个 MSA 实例，请确定两个整数：\n- 如上定义的 SP 分数 $S$。\n- 遍历所有列的无序符号对总数，该值等于在每一列中考虑的所有不同无序索引对 $\\{i,j\\}$（其中 $1 \\le i < j \\le k$）的数量，再对全部 $L$ 列进行聚合。\n\n您的程序必须为每个测试用例计算这两个整数，并生成单行输出，其中包含所有按顺序排列的结果，格式为用方括号括起来的逗号分隔列表。对于每个测试用例，输出必须按给定顺序先列出 SP 分数 $S$，然后是该用例的无序对计数。因此，如果有 $n$ 个测试用例，输出行必须总共包含 $2n$ 个整数，格式示例为 $[r_1,r_2,\\dots,r_{2n}]$。\n\n程序无需读取任何输入；所有测试数据都已嵌入程序中。本问题不涉及物理单位。\n\n测试套件：\n- 测试用例 $1$（包含匹配、错配和间隙的一般情况）：$k=3$，$L=5$，\n  $$\n  \\begin{aligned}\n  A_1 &= \\text{\"A-CGT\"},\\\\\n  A_2 &= \\text{\"ATCG-\"},\\\\\n  A_3 &= \\text{\"AT-GT\"}.\n  \\end{aligned}\n  $$\n- 测试用例 $2$（所有序列相同，无间隙）：$k=4$，$L=4$，\n  $$\n  \\begin{aligned}\n  A_1 &= \\text{\"ACGT\"},\\\\\n  A_2 &= \\text{\"ACGT\"},\\\\\n  A_3 &= \\text{\"ACGT\"},\\\\\n  A_4 &= \\text{\"ACGT\"}.\n  \\end{aligned}\n  $$\n- 测试用例 $3$（全为间隙的比对）：$k=3$，$L=4$，\n  $$\n  \\begin{aligned}\n  A_1 &= \\text{\"----\"},\\\\\n  A_2 &= \\text{\"----\"},\\\\\n  A_3 &= \\text{\"----\"}.\n  \\end{aligned}\n  $$\n- 测试用例 $4$（两个序列，有匹配和错配，无间隙）：$k=2$，$L=6$，\n  $$\n  \\begin{aligned}\n  A_1 &= \\text{\"ACGTAC\"},\\\\\n  A_2 &= \\text{\"TCATGC\"}.\n  \\end{aligned}\n  $$\n- 测试用例 $5$（大量间隙和重复字母）：$k=5$，$L=3$，\n  $$\n  \\begin{aligned}\n  A_1 &= \\text{\"A-G\"},\\\\\n  A_2 &= \\text{\"--G\"},\\\\\n  A_3 &= \\text{\"A--\"},\\\\\n  A_4 &= \\text{\"A-G\"},\\\\\n  A_5 &= \\text{\"---\"}.\n  \\end{aligned}\n  $$\n\n您的程序应生成一个单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$）。每个配对 $(S,\\text{pair\\_count})$ 必须按照上面给出的测试用例的精确顺序附加。", "solution": "此问题要求根据指定的评分函数，计算一个多序列比对（MSA）的配对总和（SP）分数，并同时计算整个比对中所考虑的无序符号对的总数。根据定义，对于 $k$ 个长度为 $L$ 的序列，SP 分数是\n$$\nS \\;=\\; \\sum_{c=1}^{L} \\sum_{1 \\le i < j \\le k} s\\!\\left(A_{i,c}, A_{j,c}\\right),\n$$\n其中 $s(\\cdot,\\cdot)$ 如前所述。该定义纯粹是逐列和成对的：在每一列 $c$，考虑所有无序索引对 $\\{i,j\\}$（$1 \\le i < j \\le k$），将函数 $s$ 应用于该列的两个符号，然后求和。\n\n整个比对中所考虑的无序符号对总数，是每列的无序索引对数量在 $L$ 列上的聚合。对于给定的一列，无序对的数量是二项式系数\n$$\n\\binom{k}{2} \\;=\\; \\frac{k(k-1)}{2}.\n$$\n在 $L$ 列上进行聚合可得\n$$\nU \\;=\\; L \\cdot \\binom{k}{2} \\;=\\; L \\cdot \\frac{k(k-1)}{2}.\n$$\n这个 $U$ 也恰好是通过直接枚举方法（即访问每一列的每一个无序对）所执行的配对评估的总次数。\n\n一个直接的算法遵循该定义：\n- 对从 $1$ 到 $L$ 的每一列 $c$，\n  - 对每个无序对 $(i,j)$（其中 $1 \\le i < j \\le k$），\n    - 将 $s\\!\\left(A_{i,c}, A_{j,c}\\right)$ 累加到运行总和中。\n\n这种直接枚举法的时间复杂度主要由遍历 $L$ 列和每列 $\\binom{k}{2}$ 个无序序列对的嵌套循环所决定，因此\n$$\nT(L,k) \\in \\Theta\\!\\left(L \\cdot \\binom{k}{2}\\right) \\;=\\; \\Theta\\!\\left(L \\cdot k^2\\right).\n$$\n除了输入存储外，空间复杂度为 $O(1)$ 的辅助空间，因为只需要维护一个运行总和。\n\n现在为测试套件计算所要求的输出。\n\n测试用例 1：$k=3$，$L=5$，序列 $A_1=\\text{\"A-CGT\"}$，$A_2=\\text{\"ATCG-\"}$，$A_3=\\text{\"AT-GT\"}$。\n- 第 1 列：$(\\text{A},\\text{A},\\text{A})$ 产生三个匹配：$+1+1+1=+3$。\n- 第 2 列：$(\\text{-},\\text{T},\\text{T})$ 产生两个间隙-字母对和一个匹配：$-2-2+1=-3$。\n- 第 3 列：$(\\text{C},\\text{C},\\text{-})$ 产生一个匹配和两个间隙-字母对：$+1-2-2=-3$。\n- 第 4 列：$(\\text{G},\\text{G},\\text{G})$ 产生三个匹配：$+3$。\n- 第 5 列：$(\\text{T},\\text{-},\\text{T})$ 产生两个间隙-字母对和一个匹配：$-3$。\n总分 $S = +3-3-3+3-3 = -3$。无序对计数 $U = L \\cdot \\binom{k}{2} = 5 \\cdot 3 = 15$。\n\n测试用例 2：$k=4$，$L=4$，所有序列相同且无间隙。每一列有 $\\binom{4}{2}=6$ 个相同字母对，每个得分+1。因此 $S = 4 \\cdot 6 \\cdot (+1) = 24$。无序对计数 $U = 4 \\cdot 6 = 24$。\n\n测试用例 3：$k=3$，$L=4$，每一列的所有符号都是间隙。每一对都是间隙-间隙对，得分为 0。因此 $S = 0$。无序对计数 $U = 4 \\cdot \\binom{3}{2} = 4 \\cdot 3 = 12$。\n\n测试用例 4：$k=2$，$L=6$，序列 $A_1=\\text{\"ACGTAC\"}$，$A_2=\\text{\"TCATGC\"}$。每列只有一个无序对。\n- 逐列配对：$(\\text{A},\\text{T})=-1$, $(\\text{C},\\text{C})=+1$, $(\\text{G},\\text{A})=-1$, $(\\text{T},\\text{T})=+1$, $(\\text{A},\\text{G})=-1$, $(\\text{C},\\text{C})=+1$。\n总分 $S = -1+1-1+1-1+1 = 0$。无序对计数 $U = 6 \\cdot \\binom{2}{2} = 6 \\cdot 1 = 6$。\n\n测试用例 5：$k=5$，$L=3$，序列 $A_1=\\text{\"A-G\"}$，$A_2=\\text{\"--G\"}$，$A_3=\\text{\"A--\"}$，$A_4=\\text{\"A-G\"}$，$A_5=\\text{\"---\"}$。\n- 第 1 列：符号 $(\\text{A},\\text{-},\\text{A},\\text{A},\\text{-})$ 有三个字母 $\\text{A}$ 和两个间隙。字母-字母对贡献 $+ \\binom{3}{2} = +3$，字母-间隙对贡献 $3 \\cdot 2 \\cdot (-2) = -12$，间隙-间隙对贡献 $0$。该列总分 $-9$。\n- 第 2 列：全为间隙，总分 $0$。\n- 第 3 列：符号 $(\\text{G},\\text{G},\\text{-},\\text{G},\\text{-})$ 有三个字母 $\\text{G}$ 和两个间隙，与第 1 列情况相同，总分 $-9$。\n总分 $S = -9 + 0 - 9 = -18$。无序对计数 $U = 3 \\cdot \\binom{5}{2} = 3 \\cdot 10 = 30$。\n\n因此，所要求的单行输出，按顺序依次列出每个测试用例的 $(S,U)$，结果为\n$$\n[-3,15,24,24,0,12,0,6,-18,30].\n$$\n此程序可以通过直接应用定义来计算每个 $S$，并通过计算每列的无序对数量来计算每个 $U$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sp_pair_score(x: str, y: str) -> int:\n    \"\"\"\n    Scoring function s(x,y):\n    - +1 if x == y and x != '-'\n    - -1 if x != y and x != '-' and y != '-'\n    - -2 if exactly one of x or y is '-'\n    -  0 if x == y == '-'\n    \"\"\"\n    if x == '-' and y == '-':\n        return 0\n    if x == '-' or y == '-':\n        return -2\n    if x == y:\n        return +1\n    return -1\n\ndef sp_score(msa):\n    \"\"\"\n    Compute Sum-of-Pairs (SP) score for an MSA given as a list of equal-length strings.\n    \"\"\"\n    k = len(msa)\n    if k == 0:\n        return 0\n    L = len(msa[0])\n    # Sanity: ensure all sequences have the same length\n    for s in msa:\n        if len(s) != L:\n            raise ValueError(\"All sequences must have equal length.\")\n    total = 0\n    # For each column, sum over all unordered pairs of sequences\n    for c in range(L):\n        # collect column symbols\n        col = [msa[i][c] for i in range(k)]\n        # sum over unordered pairs\n        for i in range(k):\n            xi = col[i]\n            for j in range(i + 1, k):\n                total += sp_pair_score(xi, col[j])\n    return total\n\ndef unordered_pair_count(k: int, L: int) -> int:\n    \"\"\"\n    Total number of unordered index pairs per column aggregated over all columns: L * C(k,2)\n    \"\"\"\n    return L * (k * (k - 1) // 2)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (msa_list, k, L)\n    test_cases = [\n        ([\"A-CGT\", \"ATCG-\", \"AT-GT\"], 3, 5),  # Test case 1\n        ([\"ACGT\", \"ACGT\", \"ACGT\", \"ACGT\"], 4, 4),  # Test case 2\n        ([\"----\", \"----\", \"----\"], 3, 4),  # Test case 3\n        ([\"ACGTAC\", \"TCATGC\"], 2, 6),  # Test case 4\n        ([\"A-G\", \"--G\", \"A--\", \"A-G\", \"---\"], 5, 3),  # Test case 5\n    ]\n\n    results = []\n    for msa, k, L in test_cases:\n        # Compute SP score\n        s = sp_score(msa)\n        # Compute unordered pair count\n        u = unordered_pair_count(k, L)\n        results.append(s)\n        results.append(u)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2432587"}]}