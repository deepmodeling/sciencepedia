{"hands_on_practices": [{"introduction": "多序列比对算法的核心是优化一个目标函数，通常是基于替换矩阵的配对加和（Sum-of-Pairs, $SP$）得分。本练习将引入一种源于信息论的替代方案——香农熵 ($H(c)$)，它通过衡量比对列的混乱程度来评估比对质量，更低的熵值意味着更高的保守性。你将通过计算一个假想的迭代步骤前后比对的总熵变，来亲手实践如何使用不同于传统的视角量化比对的“优劣” [@problem_id:2400615]。", "problem": "在多序列比对 (MSA) 的迭代优化中，一个优化步骤用逐列的 Shannon 熵目标取代了通常的替换矩阵列得分。对于一列 $c$，设符号的经验分布为 $\\{p_{x}(c)\\}_{x \\in \\{A,C,G,T\\}}$，该分布通过该列中各个符号的计数除以序列总数计算得出。将列熵定义为\n$$H(c) = -\\sum_{x \\in \\{A,C,G,T\\}} p_{x}(c)\\,\\log_{2}\\!\\big(p_{x}(c)\\big),$$\n约定当 $p_{x}(c)=0$ 时，该项的贡献为 $0$（即 $\\lim_{p \\to 0^{+}} p \\log_{2} p = 0$）。一个比对的全局目标是所有列熵的总和，\n$$J = \\sum_{c} H(c),$$\n以比特为单位。\n\n考虑一个包含10个序列、跨越3列的比对，在进行单次优化移动前后的情况。各列中的符号计数如下：\n\n精炼前：\n- 第1列：(A: 7, C: 3, G: 0, T: 0)\n- 第2列：(A: 4, C: 4, G: 2, T: 0)\n- 第3列：(A: 5, C: 0, G: 5, T: 0)\n\n精炼后：\n- 第1'列：(A: 10, C: 0, G: 0, T: 0)\n- 第2'列：(A: 3, C: 3, G: 4, T: 0)\n- 第3'列：(A: 3, C: 2, G: 5, T: 0)\n\n计算基于熵的目标的净变化量，\n$$\\Delta J \\equiv J_{\\text{after}} - J_{\\text{before}},$$\n并将您的最终数值答案以比特表示。将答案四舍五入到四位有效数字。", "solution": "本题要求计算在一次优化移动之后，多序列比对 (MSA) 中基于 Shannon 熵的目标函数所产生的净变化量。目标函数 $J$ 是比对中每一列熵的总和。\n\n一列 $c$ 的 Shannon 熵定义为：\n$$H(c) = -\\sum_{x \\in \\{A,C,G,T\\}} p_{x}(c)\\,\\log_{2}\\!\\left(p_{x}(c)\\right)$$\n其中 $p_{x}(c)$ 是符号 $x$ 在列 $c$ 中的经验频率。频率根据给定的符号计数和序列总数（$N=10$）计算得出。对于列中计数值为 $n_x$ 的符号，其频率为 $p_x(c) = \\frac{n_x}{N}$。此处应用了 $0 \\log_2 0 = 0$ 的约定。\n\n总目标函数是所有列的总和：\n$$J = \\sum_{c} H(c)$$\n我们必须计算优化前后的目标值，分别记为 $J_{\\text{before}}$ 和 $J_{\\text{after}}$，然后求出它们的差值 $\\Delta J = J_{\\text{after}} - J_{\\text{before}}$。\n\n首先，我们计算优化前的目标函数 $J_{\\text{before}}$。该比对包含3列。\n\n对于第1列，计数为 (A: 7, C: 3, G: 0, T: 0)：\n频率为 $p_A(1) = \\frac{7}{10} = 0.7$ 和 $p_C(1) = \\frac{3}{10} = 0.3$。\n$$H(C_1) = -\\left(0.7 \\log_{2}(0.7) + 0.3 \\log_{2}(0.3)\\right) \\approx - (0.7 \\times (-0.51457)) - (0.3 \\times (-1.73697)) \\approx 0.36020 + 0.52109 \\approx 0.88129 \\text{ 比特}$$\n\n对于第2列，计数为 (A: 4, C: 4, G: 2, T: 0)：\n频率为 $p_A(2) = \\frac{4}{10} = 0.4$，$p_C(2) = \\frac{4}{10} = 0.4$ 和 $p_G(2) = \\frac{2}{10} = 0.2$。\n$$H(C_2) = -\\left(2 \\times 0.4 \\log_{2}(0.4) + 0.2 \\log_{2}(0.2)\\right) \\approx - (0.8 \\times (-1.32193)) - (0.2 \\times (-2.32193)) \\approx 1.05754 + 0.46439 \\approx 1.52193 \\text{ 比特}$$\n\n对于第3列，计数为 (A: 5, C: 0, G: 5, T: 0)：\n频率为 $p_A(3) = \\frac{5}{10} = 0.5$ 和 $p_G(3) = \\frac{5}{10} = 0.5$。\n$$H(C_3) = -\\left(2 \\times 0.5 \\log_{2}(0.5)\\right) = - (1 \\times (-1)) = 1 \\text{ 比特}$$\n\n优化前的总目标值为：\n$$J_{\\text{before}} = H(C_1) + H(C_2) + H(C_3) \\approx 0.88129 + 1.52193 + 1.0 = 3.40322 \\text{ 比特}$$\n\n接着，我们计算优化后的目标函数 $J_{\\text{after}}$。\n\n对于第1'列，计数为 (A: 10, C: 0, G: 0, T: 0)：\n频率为 $p_A(1') = \\frac{10}{10} = 1$。这是一个完全保守列。\n$$H(C'_1) = -(1 \\log_{2}(1)) = 0 \\text{ 比特}$$\n\n对于第2'列，计数为 (A: 3, C: 3, G: 4, T: 0)：\n频率为 $p_A(2') = \\frac{3}{10} = 0.3$, $p_C(2') = \\frac{3}{10} = 0.3$ 和 $p_G(2') = \\frac{4}{10} = 0.4$。\n$$H(C'_2) = -\\left(2 \\times 0.3 \\log_{2}(0.3) + 0.4 \\log_{2}(0.4)\\right) \\approx - (0.6 \\times (-1.73697)) - (0.4 \\times (-1.32193)) \\approx 1.04218 + 0.52877 \\approx 1.57095 \\text{ 比特}$$\n\n对于第3'列，计数为 (A: 3, C: 2, G: 5, T: 0)：\n频率为 $p_A(3') = \\frac{3}{10} = 0.3$，$p_C(3') = \\frac{2}{10} = 0.2$ 和 $p_G(3') = \\frac{5}{10} = 0.5$。\n$$H(C'_3) = -\\left(0.3 \\log_{2}(0.3) + 0.2 \\log_{2}(0.2) + 0.5 \\log_{2}(0.5)\\right) \\approx - (0.3 \\times (-1.73697)) - (0.2 \\times (-2.32193)) - (0.5 \\times (-1)) \\approx 0.52109 + 0.46439 + 0.5 \\approx 1.48548 \\text{ 比特}$$\n\n优化后的总目标值为：\n$$J_{\\text{after}} = H(C'_1) + H(C'_2) + H(C'_3) \\approx 0 + 1.57095 + 1.48548 = 3.05643 \\text{ 比特}$$\n\n最后，计算目标值的净变化量：\n$$\\Delta J = J_{\\text{after}} - J_{\\text{before}} \\approx 3.05643 - 3.40322 = -0.34679 \\text{ 比特}$$\n负值表明比对的总熵减小了，根据这个特定的目标函数，这对应于比对的改进（因为较低的熵意味着更少的无序性或更高的保守性）。\n\n题目要求答案四舍五入到四位有效数字。\n$$\\Delta J \\approx -0.3468$$", "answer": "$$\\boxed{-0.3468}$$", "id": "2400615"}, {"introduction": "虽然优化是关键，但我们必须批判性地审视我们优化的目标——一个更高的序列相似性得分（如 $SP$ 分数）是否总能保证一个生物学上更“好”的比对？本练习将探讨一个“欺骗性”的基准测试场景，在该场景中，一个经过优化的比对方案虽然获得了更高的 $SP$ 分数，但从结构角度（通过一个类均方根偏差 $\\text{RMSD}$ 的指标衡量）来看其质量反而下降了。这个思想实验强调了序列优化与获得生物学意义上真实比对之间的重要区别 [@problem_id:2400632]。", "problem": "你的任务是为多序列比对（MSA）的迭代优化设计并评估一个具有欺骗性的有利基准测试。其目的在于表明，优化配对总和（SP）序列得分可能会产生在 SP 目标上数值更优，但在结构意义上（通过从共享嵌入空间中的坐标计算出的类均方根偏差（RMSD）准则衡量）却更差的比对。你必须实现一个完整的程序，该程序接受一个固定的测试套件（如下所提供），为每个测试用例计算“基线”比对和“精化”比对的 SP 得分和类 RMSD 得分，然后报告该测试用例是否表现出欺骗性改进（具体定义见下文）。程序必须将所有测试用例的结果在单行上以指定格式聚合为单个列表输出。\n\n基本概念：\n- 多序列比对（MSA）将 $m$ 条序列排列成一个可能包含空位的列矩阵，从而使进化上或功能上对应的残基能够对齐在同一列。\n- 配对总和（SP）得分是 MSA 优化中常用的目标函数：它是对所有列，将配对评分函数应用于该列中所有同时拥有残基（而非空位）的无序序列对，然后将得分求和的结果。\n- 对于坐标 $\\mathbf{x},\\mathbf{y}\\in\\mathbb{R}^d$，$\\mathbb{R}^d$ 中的欧几里得距离为 $\\lVert \\mathbf{x}-\\mathbf{y}\\rVert_2=\\sqrt{\\sum_{k=1}^{d}(x_k-y_k)^2}$。\n- 两个坐标集之间的均方根偏差（RMSD）是衡量结构相似性的标准方法，可以表示为配对点之间欧几里得距离平方的均值的平方根。\n\n你的任务：\n1) 实现一个使用基于一致性评分的 SP 得分。设序列数量为 $m$，比对有 $L$ 列，并用 $A_{j,p}$ 表示序列 $p\\in\\{1,\\dots,m\\}$ 在列 $j\\in\\{1,\\dots,L\\}$ 中的残基字符（如果不是空位），否则表示为空位。定义一个配对一致性评分函数 $s(a,b)$，当 $a=b$ 且二者都不是空位字符时，$s(a,b)=1$，否则 $s(a,b)=0$。SP 得分计算公式为\n$$\n\\mathrm{SP}=\\sum_{j=1}^{L}\\sum_{1\\le p<q\\le m} s\\!\\left(A_{j,p},A_{j,q}\\right).\n$$\n\n2) 实现一个类 RMSD 评估，该评估使用共享坐标系中提供的每个残基的坐标。对于给定的比对，对于每一列 $j$ 和每一对无序序列 $(p,q)$，如果它们在该列的条目都是来自序列 $p$ 和 $q$ 的残基（非空位），其原始残基索引分别为 $i_p$ 和 $i_q$，则取其坐标 $\\mathbf{x}^{(p)}_{i_p}\\in\\mathbb{R}^d$ 和 $\\mathbf{x}^{(q)}_{i_q}\\in\\mathbb{R}^d$，并累加平方距离 $\\lVert \\mathbf{x}^{(p)}_{i_p}-\\mathbf{x}^{(q)}_{i_q}\\rVert_2^2$。设 $N_{\\text{pairs}}$ 是整个比对中此类残基-残基对的总数。定义\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{N_{\\text{pairs}}}\\sum \\lVert \\mathbf{x}^{(p)}_{i_p}-\\mathbf{x}^{(q)}_{i_q}\\rVert_2^2},\n$$\n其中求和项遍历了所有列以及每列中所有的无序残基-残基对。你可以假设对于所有给定的测试用例，$N_{\\text{pairs}}>0$。\n\n3) 欺骗性改进的判定条件。对于同一测试用例，给定一个具有 $(\\mathrm{SP}_{\\mathrm{base}}, \\mathrm{RMSD}_{\\mathrm{base}})$ 的基线比对和一个具有 $(\\mathrm{SP}_{\\mathrm{ref}}, \\mathrm{RMSD}_{\\mathrm{ref}})$ 的精化比对，当且仅当同时满足以下两个条件时，判定该测试用例为欺骗性的：\n$$\n\\mathrm{SP}_{\\mathrm{ref}} > \\mathrm{SP}_{\\mathrm{base}}\n\\quad\\text{且}\\quad\n\\mathrm{RMSD}_{\\mathrm{ref}} > \\mathrm{RMSD}_{\\mathrm{base}}.\n$$\n否则，该测试用例不具有欺骗性。\n\n你的程序必须实现的表示细节：\n- 每个测试用例提供 $m$ 条序列（作为字符串）以及每条序列 $p$ 对应的坐标数组 $\\left(\\mathbf{x}^{(p)}_0,\\dots,\\mathbf{x}^{(p)}_{n_p-1}\\right)$，其中 $n_p$ 是序列长度。所有坐标都位于共享的欧几里得空间 $\\mathbb{R}^d$ 中。在提供的测试中，$d=1$，坐标是一维位置。\n- 每个比对（基线和精化）表示为一个列的列表。一列是一个长度为 $m$ 的列表，其中条目 $p$ 要么是该列中序列 $p$ 的残基索引 $i_p\\in\\{0,\\dots,n_p-1\\}$，要么是特殊值 $-1$，表示该列中序列 $p$ 的位置是一个空位。\n- 你的实现必须确保在计算 SP 和 RMSD 时，只有非空位条目参与计算，特别地，空位绝不构成配对。\n\n你必须硬编码并评估的测试套件：\n- 测试用例 $1$（设计为欺骗性的）：\n  - 序列（$m=3$）：\n    - $S_1=$ \"AXAXAX\"，坐标为 $[0, 1, 2, 3, 4, 5]$ in $\\mathbb{R}^1$。\n    - $S_2=$ \"XAXAXA\"，坐标为 $[0, 1, 2, 3, 4, 5]$ in $\\mathbb{R}^1$。\n    - $S_3=$ \"XXXXXX\"，坐标为 $[0, 1, 2, 3, 4, 5]$ in $\\mathbb{R}^1$。\n  - 基线比对（按索引；$6$ 列）：\n    - $[[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4], [5, 5, 5]]$。\n  - 精化比对（寻求SP；$9$ 列）：\n    - $[[0, 1, -1], [2, 3, -1], [4, 5, -1], [1, 0, 0], [3, 2, 1], [5, 4, 2], [-1, -1, 3], [-1, -1, 4], [-1, -1, 5]]$。\n\n- 测试用例 $2$（非欺骗性改进）：\n  - 序列（$m=3$）：\n    - $S_1=$ \"ABCD\"，坐标为 $[0, 1, 2, 3]$。\n    - $S_2=$ \"ABXD\"，坐标为 $[0, 1, 2, 3]$。\n    - $S_3=$ \"ABCD\"，坐标为 $[0, 1, 2, 3]$。\n  - 基线比对（$4$ 列；中间错位）：\n    - $[[0, 0, 0], [1, 1, 1], [2, 3, 2], [3, 2, 3]]$。\n  - 精化比对（按索引；$4$ 列）：\n    - $[[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]]$。\n\n- 测试用例 $3$（无变化）：\n  - 序列（$m=3$）：\n    - $S_1=$ \"ABC\"，坐标为 $[0, 1, 2]$。\n    - $S_2=$ \"ABC\"，坐标为 $[0, 1, 2]$。\n    - $S_3=$ \"ABC\"，坐标为 $[0, 1, 2]$。\n  - 基线比对（$3$ 列）：\n    - $[[0, 0, 0], [1, 1, 1], [2, 2, 2]]$。\n  - 精化比对（与基线相同）：\n    - $[[0, 0, 0], [1, 1, 1], [2, 2, 2]]$。\n\n- 测试用例 $4$（SP 减小但 RMSD 改善；非欺骗性）：\n  - 序列（$m=3$）：\n    - $S_1=$ \"AX\"，坐标为 $[0, 1]$。\n    - $S_2=$ \"XA\"，坐标为 $[0, 1]$。\n    - $S_3=$ \"XX\"，坐标为 $[0, 1]$。\n  - 基线比对（寻求SP；$3$ 列）：\n    - $[[0, 1, -1], [1, 0, 0], [-1, -1, 1]]$。\n  - 精化比对（按索引；$2$ 列）：\n    - $[[0, 0, 0], [1, 1, 1]]$。\n\n输出内容：\n- 对于每个测试用例 $t\\in\\{1,2,3,4\\}$，计算 $\\mathrm{SP}_{\\mathrm{base}}^{(t)}$、$\\mathrm{RMSD}_{\\mathrm{base}}^{(t)}$、$\\mathrm{SP}_{\\mathrm{ref}}^{(t)}$ 和 $\\mathrm{RMSD}_{\\mathrm{ref}}^{(t)}$，然后计算一个布尔值 $B^{(t)}$，该值为真的条件是当且仅当 $\\mathrm{SP}_{\\mathrm{ref}}^{(t)} > \\mathrm{SP}_{\\mathrm{base}}^{(t)}$ 且 $\\mathrm{RMSD}_{\\mathrm{ref}}^{(t)} > \\mathrm{RMSD}_{\\mathrm{base}}^{(t)}$。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[\\text{True},\\text{False},\\text{True},\\text{False}]$。\n\n角度单位和物理单位在此不适用。所有输出均为布尔值。", "solution": "所述问题是有效的。它在科学上基于计算生物学，特别是多序列比对（MSA）的既定原则。配对总和（SP）得分和均方根偏差（RMSD）的定义在数学上是精确且内部一致的。该问题是适定的，为计算每个测试用例的唯一且可验证的结果提供了所有必要数据，包括序列、坐标和比对结构。其目标是实现这些定义的度量标准和一个指定的“欺骗性改进”判定条件，这是一个清晰且可形式化的计算任务。问题中没有矛盾、歧义或违反科学事实的主张。\n\n问题的核心是为给定的多序列比对实现两个评估函数：一个基于序列一致性（SP得分），另一个基于给定嵌入中残基的空间邻近性（类RMSD得分）。\n\n首先，我们将 SP 得分的计算形式化。假设有 $m$ 条序列，比对包含 $L$ 列。比对矩阵中的一个条目 $A_{j,p}$ 表示序列 $p \\in \\{1, \\ldots, m\\}$ 在列 $j \\in \\{1, \\ldots, L\\}$ 中的字符。该条目可以是残基或空位。评分函数 $s(a, b)$ 定义为：如果字符 $a$ 和 $b$ 相同且都不是空位，则为 $1$；否则为 $0$。总 SP 得分是该列中所有唯一序列对的得分在所有列上的总和：\n$$\n\\mathrm{SP} = \\sum_{j=1}^{L} \\sum_{1 \\le p < q \\le m} s(A_{j,p}, A_{j,q})\n$$\n\n其次，我们将类 RMSD 得分形式化。对于每条序列 $p$，我们都有一组对应每个残基 $i$ 的坐标 $\\{\\mathbf{x}_i^{(p)}\\}$。比对以映射形式提供：对于每列 $j$ 和序列 $p$，我们有一个来自序列 $p$ 的残基在该列的索引 $i_p$，或者一个特殊值（例如-1）表示空位。对于每列 $j$，我们识别出在该列中都具有残基（非空位）的所有序列对 $(p,q)$。对于每个这样的对，我们找到它们原始的残基索引 $i_p$ 和 $i_q$ 及其对应的坐标 $\\mathbf{x}_{i_p}^{(p)}$ 和 $\\mathbf{x}_{i_q}^{(q)}$。计算这些坐标之间的平方欧几里得距离 $\\lVert \\mathbf{x}_{i_p}^{(p)} - \\mathbf{x}_{i_q}^{(q)} \\rVert_2^2$。在所有列中的所有此类对上计算这些平方距离的总和。然后，该总和由总配对数 $N_{\\text{pairs}}$ 进行归一化，并取平方根：\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{N_{\\text{pairs}}} \\sum_{\\text{所有配对}} \\lVert \\mathbf{x}_{i_p}^{(p)} - \\mathbf{x}_{i_q}^{(q)} \\rVert_2^2}\n$$\n求和遍历了所有列以及每列中的所有唯一非空位残基对。对于给定的问题，坐标位于 $\\mathbb{R}^1$ 中，因此平方欧几里得距离简化为 $(x_{i_p}^{(p)} - x_{i_q}^{(q)})^2$。\n\n最后，如果从基线比对转到精化比对时，SP 得分增加而 RMSD 得分也增加，则判定该测试用例存在“欺骗性改进”。也就是说，对于一个具有得分 $(\\mathrm{SP}_{\\mathrm{base}}, \\mathrm{RMSD}_{\\mathrm{base}})$ 的基线比对和一个具有得分 $(\\mathrm{SP}_{\\mathrm{ref}}, \\mathrm{RMSD}_{\\mathrm{ref}})$ 的精化比对，欺骗的条件是：\n$$\n\\mathrm{SP}_{\\mathrm{ref}} > \\mathrm{SP}_{\\mathrm{base}} \\quad \\text{且} \\quad \\mathrm{RMSD}_{\\mathrm{ref}} > \\mathrm{RMSD}_{\\mathrm{base}}\n$$\n\n解决该问题的步骤如下：\n1. 对于提供的 4 个测试用例中的每一个，都有两种比对：基线比对和精化比对。\n2. 对每种比对，我们实现一个函数来遍历每一列。在列内，它遍历所有唯一的序列对。\n3. 如果一个配对中的两条序列在当前列中都有残基（非空位），则继续。\n4. 对于 SP 得分，我们使用给定的索引检索残基字符并检查它们是否相同。如果相同，SP 累加器加 1。\n5. 对于 RMSD 得分，我们检索与残基索引对应的坐标。这些坐标之间的平方距离被加到平方距离的运行总和中。此类配对的计数器 $N_{\\text{pairs}}$ 也递增。\n6. 处理完所有列后，最终的 SP 得分是总累加值。最终的 RMSD 是通过将平方距离总和除以 $N_{\\text{pairs}}$ 并取平方根计算得出。对一个测试用例的基线比对和精化比对都计算这两个值 $(\\mathrm{SP}, \\mathrm{RMSD})$。\n7. 使用欺骗性改进的判定条件比较这两对得分 $(\\mathrm{SP}_{\\mathrm{base}}, \\mathrm{RMSD}_{\\mathrm{base}})$ 和 $(\\mathrm{SP}_{\\mathrm{ref}}, \\mathrm{RMSD}_{\\mathrm{ref}})$。存储得到的布尔值。\n8. 对所有测试用例重复此过程，并报告最终的布尔值列表。\n\n我们以测试用例1为例进行说明。\n序列：$S_1=$ \"AXAXAX\", $S_2=$ \"XAXAXA\", $S_3=$ \"XXXXXX\"。所有序列的坐标都是 $[0, 1, 2, 3, 4, 5]$。\n基线比对：$[[0, 0, 0], \\dots, [5, 5, 5]]$。这是一个无空位的比对。\n在任何列 $j$ 中，残基都是 $S_1[j]$, $S_2[j]$ 和 $S_3[j]$。坐标都是 $j$。\n对于 $j=0$：残基为 'A', 'X', 'X'。配对有 ('A','X'), ('A','X'), ('X','X')。只有最后一对匹配。SP 贡献为 $1$。坐标都是 $0$，所以平方距离是 $0$。\n对于 $j=1$：残基为 'X', 'A', 'X'。配对有 ('X','A'), ('X', 'X'), ('A', 'X')。只有中间一对匹配。SP 贡献为 $1$。坐标都是 $1$，所以平方距离是 $0$。\n这种模式在所有 6 列中重复。\n因此，$\\mathrm{SP}_{\\mathrm{base}} = 6 \\times 1 = 6$。\n平方距离的总和为 $0$，所以 $\\mathrm{RMSD}_{\\mathrm{base}} = 0$。\n\n精化比对：$[[0, 1, -1], [2, 3, -1], \\dots, [-1, -1, 5]]$。\n第 0 列：$S_1[0]=$'A', $S_2[1]=$'A'。一个配对，它们匹配。SP 贡献为 $1$。坐标是 $0$ 和 $1$。平方距离是 $(0-1)^2=1$。$N_{\\text{pairs}}$ 贡献为 $1$。\n第 3 列：$S_1[1]=$'X', $S_2[0]=$'X', $S_3[0]=$'X'。三个配对，全部匹配。SP 贡献为 $3$。坐标是 $1, 0, 0$。平方距离：$(1-0)^2 + (1-0)^2 + (0-0)^2 = 2$。$N_{\\text{pairs}}$ 贡献为 $3$。\n对所有列进行汇总，我们得到 $\\mathrm{SP}_{\\mathrm{ref}} = 12$ 和 $\\mathrm{RMSD}_{\\mathrm{ref}} = \\sqrt{25/12} \\approx 1.443$。\n比较得分：$\\mathrm{SP}_{\\mathrm{ref}}=12 > \\mathrm{SP}_{\\mathrm{base}}=6$ (True) 且 $\\mathrm{RMSD}_{\\mathrm{ref}} \\approx 1.443 > \\mathrm{RMSD}_{\\mathrm{base}}=0$ (True)。两个条件都成立，所以测试用例1的结果是 True。\n\n对所有四个用例执行此逻辑，即可得到最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the deceptive MSA benchmark problem by calculating SP and RMSD-like scores\n    for baseline and refined alignments for a fixed suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"sequences\": [\"AXAXAX\", \"XAXAXA\", \"XXXXXX\"],\n            \"coords\": [[0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5]],\n            \"baseline_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4], [5, 5, 5]],\n            \"refined_align\": [[0, 1, -1], [2, 3, -1], [4, 5, -1], [1, 0, 0], [3, 2, 1], [5, 4, 2], [-1, -1, 3], [-1, -1, 4], [-1, -1, 5]],\n        },\n        {\n            \"sequences\": [\"ABCD\", \"ABXD\", \"ABCD\"],\n            \"coords\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"baseline_align\": [[0, 0, 0], [1, 1, 1], [2, 3, 2], [3, 2, 3]],\n            \"refined_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]],\n        },\n        {\n            \"sequences\": [\"ABC\", \"ABC\", \"ABC\"],\n            \"coords\": [[0, 1, 2], [0, 1, 2], [0, 1, 2]],\n            \"baseline_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2]],\n            \"refined_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2]],\n        },\n        {\n            \"sequences\": [\"AX\", \"XA\", \"XX\"],\n            \"coords\": [[0, 1], [0, 1], [0, 1]],\n            \"baseline_align\": [[0, 1, -1], [1, 0, 0], [-1, -1, 1]],\n            \"refined_align\": [[0, 0, 0], [1, 1, 1]],\n        },\n    ]\n\n    def evaluate_alignment(sequences, coords, alignment):\n        \"\"\"\n        Computes the SP score and RMSD-like score for a given alignment.\n        \"\"\"\n        num_seqs = len(sequences)\n        total_sp_score = 0\n        total_sq_dist = 0.0\n        num_pairs = 0\n\n        for column in alignment:\n            # Collect active residues in the current column\n            active_residues = []\n            for seq_idx in range(num_seqs):\n                res_idx = column[seq_idx]\n                if res_idx != -1:\n                    char = sequences[seq_idx][res_idx]\n                    coord = coords[seq_idx][res_idx]\n                    active_residues.append({'char': char, 'coord': coord})\n            \n            # Process all unique pairs of active residues\n            num_active = len(active_residues)\n            if num_active > 1:\n                for i in range(num_active):\n                    for j in range(i + 1, num_active):\n                        res1 = active_residues[i]\n                        res2 = active_residues[j]\n\n                        # SP score contribution\n                        if res1['char'] == res2['char']:\n                            total_sp_score += 1\n                        \n                        # RMSD-like score contribution\n                        # Since coordinates are 1D, squared Euclidean distance is (c1-c2)^2\n                        dist_sq = (res1['coord'] - res2['coord'])**2\n                        total_sq_dist += dist_sq\n                        num_pairs += 1\n\n        if num_pairs == 0:\n            # As per problem, guaranteed N_pairs > 0, but handle defensively.\n            rmsd_score = 0.0\n        else:\n            rmsd_score = np.sqrt(total_sq_dist / num_pairs)\n            \n        return total_sp_score, rmsd_score\n\n    results = []\n    for case in test_cases:\n        sp_base, rmsd_base = evaluate_alignment(case[\"sequences\"], case[\"coords\"], case[\"baseline_align\"])\n        sp_ref, rmsd_ref = evaluate_alignment(case[\"sequences\"], case[\"coords\"], case[\"refined_align\"])\n\n        is_deceptive = (sp_ref > sp_base) and (rmsd_ref > rmsd_base)\n        results.append(is_deceptive)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400632"}, {"introduction": "现在，你将从分析转向构建，将之前学到的概念融会贯通。这项实践挑战你搭建一个简化的多序列比对迭代优化流程。你将首先实现一个渐进式比对算法，然后为其增加一个“留一法”的迭代优化层，该层会根据 $SP$ 分数不断尝试改进比对结果。最后，你将使用自己开发的工具来研究一个实际问题：迭代优化过程如何影响低复杂度区域，并量化这些区域是否被虚假地拉伸或压缩 [@problem_id:2400635]。", "problem": "要求您设计并实现一个简化的多序列比对（MSA）程序，该程序包含一个迭代优化阶段，并用它来量化低复杂度区域在优化过程中的处理情况：它们是保持正确比对，还是在最终比对中发生伪扩张或收缩。您的程序必须为每个测试用例计算一个整数索引，该索引衡量经过迭代优化后，指定的低复杂度块相对于一个稳健的目标长度所发生的扩张或收缩。\n\n需要使用的基本和核心定义：\n- 目标是配对总和（SP）比对得分。给定一个由$N$个序列组成的MSA，每个序列表示为有限字母表和空位上的字符串，SP得分是所有$\\binom{N}{2}$个无序序列对的配对全局比对得分之和，该配对全局比对得分由比对列诱导产生。\n- 使用仿射空位罚分的配对全局比对得分由一个替换得分$s(a,b)$（用于比对的字母$a$和$b$）和一个罚分模型定义，该模型为新开一个连续空位段指定成本$g_o$，为将现有连续空位段延长一列指定成本$g_e$。字母-字母比对的得分是$s(a,b)$。在一对序列之间，长度为$\\ell$的连续空位段的得分成本是$g_o + (\\ell - 1)\\,g_e$。\n- 低复杂度区域是每个原始序列中索引的一个连续区间，该区域富含重复序列（例如，同聚物）。对于每个序列$i$，您将获得一个包含0-based索引的区间$[L_i, R_i]$（含端点），该区间指定了原始未比对序列中的此区域。\n\n需要实现的算法任务（基于原则的设计，而非简单照搬）：\n1. 使用动态规划计算渐进式MSA：\n   - 以第一个序列作为初始构型（profile）。\n   - 通过将其与当前构型进行全局比对，按顺序添加其余每个序列。该比对使用从仿射空位模型和SP目标推导出的动态规划递推式。将构型表示为列的有序列表。\n   - 将残基$r$与构型列$C$比对时，使用SP贡献$\\sum_{x \\in C, x \\neq \\text{gap}} s(r,x)$。\n   - 将输入序列中的空位与构型列$C$比对时，仿射空位罚分按$C$中非空位残基的数量进行缩放：开放成本为$|C^\\ast|\\,g_o$，延伸成本为$|C^\\ast|\\,g_e$，其中$|C^\\ast|$表示$C$中非空位的残基数量。\n   - 将残基$r$与插入到构型中的空位列（即，在所有现有构型序列中均为-的新列）比对时，使用按当前构型大小$P$缩放的仿射空位罚分：开放成本为$P\\,g_o$，延伸成本为$P\\,g_e$。\n   - 递推式必须使用三个仿射空位状态来模拟匹配/错配、序列中的空位和构型中的空位，并且必须设置为产生全局比对。\n2. 实现迭代优化：\n   - 给定一个包含$N$个序列的初始MSA，将SP得分定义为所有$\\binom{N}{2}$个序列对的得分总和，该得分使用仿射空位模型，根据比对列直接计算，其中每个配对的空位开放罚分为$g_o$，延伸罚分为$g_e$。\n   - 执行留一法（leave-one-out）优化循环：依次对每个序列，将其从MSA中移除，合并所有变为空位的列，使用上述动态规划规则将移除的序列与剩余$N-1$个序列的构型进行全局重新比对，并计算新完整MSA的SP得分。当且仅当重新比对严格增加了SP得分时，才接受它。重复此过程，直到完整的一轮没有带来任何改进，或达到固定的最大迭代次数。\n3. 量化低复杂度跨度畸变：\n   - 迭代优化后，对于每个序列$i$，追踪其低复杂度区间$[L_i, R_i]$内的原始位置对应于哪些MSA列。\n   - 设$C_i$为包含从序列$i$的区间$[L_i, R_i]$中提取的字符的MSA列索引集合。设$C = \\bigcup_{i=1}^N C_i$。将比对跨度长度定义为$\\operatorname{span}(C) = \\max(C) - \\min(C) + 1$。\n   - 将目标长度定义为测试用例中$N$个序列的真实区域长度$\\ell_i = R_i - L_i + 1$的中位数。由于测试套件中的$N$是奇数，中位数是一个整数。将扩张指数定义为\n     $$E = \\operatorname{span}(C) - \\operatorname{median}(\\{\\ell_i\\}).$$\n     正的$E$表示扩张，负的$E$表示收缩，$E=0$表示无净畸变。\n\n全局使用的评分模型：\n- 字母评分：仅对字母而言，$s(a,b) = \\begin{cases} +1  \\text{if } a=b \\\\ -1  \\text{if } a \\neq b \\end{cases}$。\n- 仿射空位罚分：$g_o = -2$ 用于空位开放，$g_e = -1$ 用于空位延伸。\n\n停止规则和参数：\n- 使用最多$10$轮优化（每轮尝试重新比对每个序列一次），如果一整轮没有带来SP得分的提高，也应提前停止。\n\n您必须嵌入在程序中的测试套件的输入规范：\n- 没有外部输入。硬编码以下三个测试用例。每个用例是一个元组，包含一个序列列表和一个低复杂度区间$[L_i, R_i]$（含端点，每个原始未比对序列的索引为0-based，长度与所示字符串一致）的列表。\n\n测试套件：\n- 用例$1$（理想情况；低复杂度区域长度相同）：\n  - 序列：[\"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\"]\n  - 低复杂度区间：[(4,8), (4,8), (4,8)]。\n- 用例$2$（低复杂度区域内单序列插入）：\n  - 序列：[\"CCCCAAAAAGGGG\", \"CCCCAAAAAAGGGG\", \"CCCCAAAAAGGGG\"]\n  - 低复杂度区间：[(4,8), (4,9), (4,8)]。\n- 用例$3$（边界条件；区域在序列起始处）：\n  - 序列：[\"AAAAACCCC\", \"AAAAACCCC\", \"AAAAACCCC\"]\n  - 低复杂度区间：[(0,4), (0,4), (0,4)]。\n\n要求的输出：\n- 对于三个用例中的每一个，在迭代优化停止后，计算如上定义的扩张指数$E$。\n- 您的程序应生成单行输出，其中包含按顺序排列的三个整数，格式为逗号分隔的列表并用方括号括起（例如，\"[0,1,0]\"）。\n\n角度单位和物理单位不适用。所有数值答案必须为整数。最终打印输出必须是指定列表格式的单行，不含空格。", "solution": "所提供的问题陈述是计算生物学领域中一个明确定义的任务，特别是在多序列比对（MSA）领域。它要求设计并实现一个基于渐进式比对和迭代优化的简化MSA算法，并使用该算法来衡量低复杂度区域的比对畸变。\n\n该问题的有效性验证如下：\n- **科学严谨性**：所呈现的概念是生物信息学的基础。配对总和（SP）得分是MSA的标准目标函数。使用动态规划将序列与构型进行比对的渐进式比对方法是像Clustal这样的经典工具的基础。迭代优化是一种广泛使用的启发式方法，用于改进初始比对，并被现代比对工具如MAFFT和Muscle所采用。仿射空位罚分模型是序列比对的标准模型。该问题在科学上是合理的。\n- **良构性**（Well-Posedness）：所有的算法步骤、参数和目标函数都得到了明确无误的定义。评分参数（$s(a,b)$、$g_o$、$g_e$）、用于构型比对的动态规划递推关系、迭代优化过程（留一法、接受条件为得分严格增加、停止标准）以及最终的扩张指数度量（$E$）都得到了精确的规定。输入数据是自包含且一致的。\n- **客观性**：语言是技术性的，不含主观或推测性陈述。\n\n因此，该问题被认定为**有效**，解决方案如下所述。该解决方案遵循指定的算法原则进行设计。\n\n### 基于原则的 MSA 程序设计\n\n该解决方案包括三个主要组成部分，每个部分都是基于序列分析中的既定原则设计的。\n\n**1. 通过构型-序列动态规划进行渐进式比对**\n\n初始的多序列比对是渐进式构建的。这是一种通过顺序添加序列来构建MSA的启发式方法。该方法的核心是将一个新加入的序列与一个代表所有先前已添加序列比对的“构型”（profile）进行比对。\n\n假设一个长度为$m$的序列$S$要与一个包含$N_P$个序列、长度（列数）为$n$的构型$P$进行比对。我们使用基于仿射空位罚分模型的动态规划方法。长度为$\\ell$的空位的成本为$g_o + (\\ell-1)g_e$，这意味着一个长度为1的空位（开放空位）成本为$g_o$，将其延长一个位置的成本为$g_e$。使用三个矩阵来存储得分，代表比对构型第$j$列与序列第$i$个位置的三种可能状态：\n- $M(i,j)$：将残基$S[i-1]$与构型列$P_{j-1}$比对的得分。\n- $I_S(i,j)$：将残基$S[i-1]$与插入到构型中的一个空位比对的得分。\n- $I_P(i,j)$：将序列$S$中的一个空位与构型列$P_{j-1}$比对的得分。\n\n将一个残基$r$与一个构型列$C$比对的得分是配对总和得分：$s_{prof}(r, C) = \\sum_{x \\in C, x \\neq \\text{gap}} s(r,x)$。空位罚分根据构型中的序列数量或列中的残基数量进行缩放，以反映SP目标。设$|C^*|$为列$C$中非空位字符的数量，设$N_P$为构型中的序列数量。\n\n递推关系如下：\n$$\nM(i,j) = s_{prof}(S[i-1], P_{j-1}) + \\max \\begin{cases} M(i-1, j-1) \\\\ I_S(i-1, j-1) \\\\ I_P(i-1, j-1) \\end{cases}\n$$\n$$\nI_S(i,j) = \\max \\begin{cases} M(i-1, j) + N_P \\cdot g_o \\\\ I_S(i-1, j) + N_P \\cdot g_e \\end{cases}\n$$\n$$\nI_P(i,j) = \\max \\begin{cases} M(i, j-1) + |P_{j-1}^*| \\cdot g_o \\\\ I_P(i, j-1) + |P_{j-1}^*| \\cdot g_e \\end{cases}\n$$\n全局比对得分是$M(m,n)$、$I_S(m,n)$和$I_P(m,n)$中的最大值。比对本身通过从这个最终单元格回溯来重建。\n\n**2. 迭代优化**\n\n渐进式比对是贪婪的，可能导致次优解。迭代优化尝试通过重复地重新比对序列子集来改进这个初始比对。所指定的“留一法”策略是一种常用方法。\n\n对于当前MSA中的每个序列$S_k$：\na. 移除$S_k$。\nb. 剩下的$N-1$个序列形成一个子比对。移除所有现在只包含空位的列。\nc. 将这个子比对视为一个固定的构型，并使用上述构型-序列DP算法将$S_k$与它重新进行全局比对。\nd. 形成一个新的完整MSA。计算其总SP得分。MSA的SP得分是所有$\\binom{N}{2}$对序列的配对总和得分。配对得分是根据MSA的列计算的，对每个检测到的连续空位段应用仿射空位罚分$g_o$和$g_e$。\ne. 如果新的SP得分严格大于前一个MSA的得分，则接受新的比对。\n\n这个过程对所有序列重复一遍，称为一“轮”（pass）。如果完整的一轮没有带来得分的提高，或者达到了最多10轮的上限，则程序终止。这是在SP得分景观上的一种爬山算法。\n\n**3. 低复杂度区域跨度分析**\n\n最后一步是量化比对过程如何影响指定的低复杂度区域（LCR）的跨度。\na. 对于每个序列$S_i$，其原始LCR由一个区间$[L_i, R_i]$定义。获得最终MSA后，我们识别出包含来自该原始区间的残基的比对列集合$C_i$。\nb. 这些集合的并集 $C = \\bigcup_i C_i$ 代表了最终MSA中被任何LCR的任何部分占据的所有列。\nc. 这个并集的跨度 $\\operatorname{span}(C) = \\max(C) - \\min(C) + 1$ 给出了LCR在比对空间中的总宽度。\nd. 将这个跨度与一个参考长度进行比较，该参考长度定义为原始LCR长度$\\ell_i = R_i - L_i + 1$的中位数。扩张指数为$E = \\operatorname{span}(C) - \\operatorname{median}(\\{\\ell_i\\})$。\ne. 正的$E$表示比对过程扩大了该区域，很可能是通过插入空位。负的$E$表示收缩。$E=0$表示对齐的跨度与原始中位数长度相匹配。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the MSA and refinement pipeline on specified test cases.\n    \"\"\"\n    \n    # --- Scoring Parameters ---\n    s_match = 1\n    s_mismatch = -1\n    g_o = -2\n    g_e = -1\n    \n    # --- Refinement Parameters ---\n    max_refinement_passes = 10\n\n    def s(a, b):\n        \"\"\"Substitution score.\"\"\"\n        if a == '-' or b == '-':\n            return 0 # Gaps vs gaps not scored in substitution matrix\n        return s_match if a == b else s_mismatch\n\n    def calculate_sp_score(msa):\n        \"\"\"\n        Calculates the Sum-of-Pairs score for a given MSA using an affine gap model.\n        The score for a gap run of length l is g_o + (l-1)*g_e.\n        \"\"\"\n        if not msa or len(msa)  2:\n            return 0\n        \n        num_seqs = len(msa)\n        alignment_len = len(msa[0])\n        total_sp_score = 0\n\n        for i in range(num_seqs):\n            for j in range(i + 1, num_seqs):\n                seq1 = msa[i]\n                seq2 = msa[j]\n                pair_score = 0\n                \n                # Substitution scores\n                for k in range(alignment_len):\n                    pair_score += s(seq1[k], seq2[k])\n\n                # Gap penalties\n                in_gap1, in_gap2 = False, False\n                for k in range(alignment_len):\n                    c1, c2 = seq1[k], seq2[k]\n                    is_gap1 = c1 == '-' and c2 != '-'\n                    is_gap2 = c2 == '-' and c1 != '-'\n                    \n                    if is_gap1:\n                        pair_score += g_e if in_gap1 else g_o\n                    if is_gap2:\n                        pair_score += g_e if in_gap2 else g_o\n\n                    in_gap1 = is_gap1\n                    in_gap2 = is_gap2\n                \n                total_sp_score += pair_score\n                \n        return total_sp_score\n\n    def align_sequence_to_profile(seq_to_add, profile_msa, insertion_idx=None):\n        \"\"\"\n        Aligns a sequence to a profile represented by an MSA using dynamic programming.\n        Returns the new MSA.\n        \"\"\"\n        if not profile_msa:\n            return [seq_to_add]\n\n        N_P = len(profile_msa)\n        m, n = len(seq_to_add), len(profile_msa[0])\n\n        # --- DP tables initialization ---\n        neg_inf = -np.inf\n        M = np.full((m + 1, n + 1), neg_inf)\n        I_S = np.full((m + 1, n + 1), neg_inf) # Gap in profile\n        I_P = np.full((m + 1, n + 1), neg_inf) # Gap in sequence\n        \n        # Pointers for backtracking\n        ptr_M = np.zeros((m + 1, n + 1), dtype=int)\n        ptr_I_S = np.zeros((m + 1, n + 1), dtype=int)\n        ptr_I_P = np.zeros((m + 1, n + 1), dtype=int)\n        \n        M[0, 0] = 0\n\n        # Precompute profile stats\n        profile_cols = list(zip(*profile_msa))\n        col_non_gap_counts = [sum(1 for char in col if char != '-') for col in profile_cols]\n\n        # --- Initialization of first row/column ---\n        for i in range(1, m + 1):\n            I_S[i, 0] = N_P * g_o + (i - 1) * N_P * g_e\n        for j in range(1, n + 1):\n            cost_open = col_non_gap_counts[j - 1] * g_o\n            cost_extend = col_non_gap_counts[j - 1] * g_e\n            I_P[0, j] = I_P[0, j - 1] + cost_extend if j > 1 else cost_open\n\n        # --- DP Fill ---\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # State M (match)\n                s_prof = sum(s(seq_to_add[i - 1], char) for char in profile_cols[j - 1] if char != '-')\n                scores_to_M = [M[i - 1, j - 1], I_S[i - 1, j - 1], I_P[i - 1, j - 1]]\n                best_prev_M_idx = np.argmax(scores_to_M)\n                M[i, j] = s_prof + scores_to_M[best_prev_M_idx]\n                ptr_M[i, j] = best_prev_M_idx # 0:M, 1:I_S, 2:I_P\n\n                # State I_S (gap in profile)\n                open_cost_S = N_P * g_o\n                extend_cost_S = N_P * g_e\n                scores_to_I_S = [M[i - 1, j] + open_cost_S, I_S[i - 1, j] + extend_cost_S]\n                best_prev_I_S_idx = np.argmax(scores_to_I_S)\n                I_S[i, j] = scores_to_I_S[best_prev_I_S_idx]\n                ptr_I_S[i, j] = best_prev_I_S_idx # 0:M, 1:I_S\n\n                # State I_P (gap in sequence)\n                open_cost_P = col_non_gap_counts[j - 1] * g_o\n                extend_cost_P = col_non_gap_counts[j - 1] * g_e\n                scores_to_I_P = [M[i, j-1] + open_cost_P, I_P[i, j - 1] + extend_cost_P]\n                best_prev_I_P_idx = np.argmax(scores_to_I_P)\n                I_P[i, j] = scores_to_I_P[best_prev_I_P_idx]\n                ptr_I_P[i, j] = best_prev_I_P_idx # 0:M, 1:I_P\n\n        # --- Backtracking ---\n        aligned_seq = []\n        aligned_profile = []\n        i, j = m, n\n        \n        final_scores = [M[m, n], I_S[m, n], I_P[m, n]]\n        state = np.argmax(final_scores)\n\n        while i > 0 or j > 0:\n            if state == 0: # M\n                aligned_seq.append(seq_to_add[i - 1])\n                aligned_profile.append(profile_cols[j - 1])\n                prev_state = ptr_M[i, j]\n                i -= 1\n                j -= 1\n                state = prev_state\n            elif state == 1: # I_S (gap in profile)\n                aligned_seq.append(seq_to_add[i - 1])\n                aligned_profile.append(['-'] * N_P)\n                prev_state = ptr_I_S[i, j]\n                i -= 1\n                state = 0 if prev_state == 0 else 1\n            else: # I_P (gap in sequence)\n                aligned_seq.append('-')\n                aligned_profile.append(profile_cols[j-1])\n                prev_state = ptr_I_P[i, j]\n                j -= 1\n                state = 0 if prev_state == 0 else 2\n        \n        aligned_seq.reverse()\n        aligned_profile.reverse()\n\n        new_msa = [''.join(row) for row in zip(*aligned_profile)]\n        new_msa.append(''.join(aligned_seq))\n        \n        if insertion_idx is not None:\n             # Reorder to original position for refinement\n            reordered_msa = [None] * (len(new_msa))\n            current = 0\n            for k in range(len(new_msa)):\n                if k == insertion_idx:\n                    reordered_msa[k] = new_msa[-1]\n                else:\n                    reordered_msa[k] = new_msa[current]\n                    current += 1\n            return reordered_msa\n\n        return new_msa\n\n    def run_case(sequences, lcr_intervals):\n        \"\"\"Runs the full pipeline for a single test case.\"\"\"\n        \n        # 1. Initial Progressive Alignment\n        current_msa = [sequences[0]]\n        for i in range(1, len(sequences)):\n            current_msa = align_sequence_to_profile(sequences[i], current_msa)\n        \n        current_score = calculate_sp_score(current_msa)\n\n        # 2. Iterative Refinement\n        for _ in range(max_refinement_passes):\n            improved_in_pass = False\n            for i in range(len(sequences)):\n                seq_to_realign = sequences[i]\n                \n                # Create sub-MSA for profile\n                sub_msa_rows = [row for k, row in enumerate(current_msa) if k != i]\n                \n                # Collapse all-gap columns\n                if sub_msa_rows:\n                    cols_to_keep = [\n                        idx for idx, col in enumerate(zip(*sub_msa_rows))\n                        if any(char != '-' for char in col)\n                    ]\n                    sub_msa = [''.join(c for i_char, c in enumerate(row) if i_char in cols_to_keep) for row in sub_msa_rows]\n                else:\n                    sub_msa = []\n\n                candidate_msa = align_sequence_to_profile(seq_to_realign, sub_msa, insertion_idx=i)\n                candidate_score = calculate_sp_score(candidate_msa)\n                \n                if candidate_score > current_score:\n                    current_msa = candidate_msa\n                    current_score = candidate_score\n                    improved_in_pass = True\n            \n            if not improved_in_pass:\n                break\n        \n        final_msa = current_msa\n        \n        # 3. Quantify Span Distortion\n        lcr_columns = set()\n        num_seqs = len(sequences)\n\n        for i in range(num_seqs):\n            l_i, r_i = lcr_intervals[i]\n            orig_idx = -1\n            for j, char in enumerate(final_msa[i]):\n                if char != '-':\n                    orig_idx += 1\n                    if l_i = orig_idx = r_i:\n                        lcr_columns.add(j)\n        \n        if not lcr_columns:\n            span_c = 0\n        else:\n            span_c = max(lcr_columns) - min(lcr_columns) + 1\n            \n        region_lengths = [r - l + 1 for l, r in lcr_intervals]\n        median_length = int(np.median(region_lengths)) # N is odd, so median is integer\n        \n        expansion_index = span_c - median_length\n        return expansion_index\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1\n        (\n            [\"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\"],\n            [(4, 8), (4, 8), (4, 8)]\n        ),\n        # Case 2\n        (\n            [\"CCCCAAAAAGGGG\", \"CCCCAAAAAAGGGG\", \"CCCCAAAAAGGGG\"],\n            [(4, 8), (4, 9), (4, 8)]\n        ),\n        # Case 3\n        (\n            [\"AAAAACCCC\", \"AAAAACCCC\", \"AAAAACCCC\"],\n            [(0, 4), (0, 4), (0, 4)]\n        )\n    ]\n\n    results = []\n    for case_sequences, case_intervals in test_cases:\n        result = run_case(case_sequences, case_intervals)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400635"}]}