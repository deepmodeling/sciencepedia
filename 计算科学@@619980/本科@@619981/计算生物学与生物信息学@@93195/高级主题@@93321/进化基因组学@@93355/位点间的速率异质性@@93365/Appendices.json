{"hands_on_practices": [{"introduction": "要真正理解系统发育模型是如何工作的，最有效的方法就是亲自动手实践其核心的数学引擎：剪枝算法（pruning algorithm）。第一个练习 [@problem_id:2747174] 聚焦于该算法中的一个基本步骤。通过手动计算一个父节点的“部分似然性”（partial likelihood），你将精确地看到特定位点的速率 $r$ 是如何改变转移概率，并最终对总似然性做出贡献的，从而为理解这一关键过程建立坚实的直觉。", "problem": "考虑一个在二叉系统发育树上，根据 Jukes–Cantor 1969 (JC69) 核苷酸替换模型演化的单个位点。假设一个内部节点 $v$ 有两个子节点 $c_{1}$ 和 $c_{2}$，它们通过等长 $t = 0.2$ 的边相连（单位为每个位点的期望替换数）。假设位点间的速率异质性通过一个具有相对速率的有限类别混合模型来建模，并且该位点属于相对速率为 $r = 1.5$ 的类别。对于 JC69 模型，沿着长度为 $t$ 的边的转移概率由以下公式给出：\n$$\nP_{xy}(t) \\;=\\; \\frac{1}{4} \\;+\\; \\left(\\delta_{xy} - \\frac{1}{4}\\right)\\exp\\!\\left(-\\frac{4t}{3}\\right),\n$$\n其中 $\\delta_{xy}$ 是克罗内克 delta 符号。对于一个相对速率 $r$，有效分支长度会按 $r$ 进行缩放，即用 $rt$ 代替 $t$。\n\n假设在子节点处，根据此位点和类别评估的局部似然向量为：\n$$\n\\boldsymbol{L}^{(1)} \\;=\\; \\big(L^{(1)}_{A},L^{(1)}_{C},L^{(1)}_{G},L^{(1)}_{T}\\big) \\;=\\; (0.8,\\,0.1,\\,0.05,\\,0.05),\n$$\n$$\n\\boldsymbol{L}^{(2)} \\;=\\; \\big(L^{(2)}_{A},L^{(2)}_{C},L^{(2)}_{G},L^{(2)}_{T}\\big) \\;=\\; (0.2,\\,0.3,\\,0.4,\\,0.1),\n$$\n核苷酸顺序为 $(A,C,G,T)$。\n\n使用针对核苷酸的连续时间齐次马尔可夫链的剪枝递归算法，\n$$\nL_{v}(x) \\;=\\; \\prod_{i=1}^{2}\\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{xy}(rt)\\,L^{(i)}_{y}\\right),\n$$\n数值计算父节点的局部似然 $L_{v}(A)$。将最终答案四舍五入至六位有效数字。以纯数字形式表示答案，不带单位。", "solution": "问题陈述经评估有效。它在科学上基于分子系统发育学原理，问题定义明确、客观且内部一致。所有用以计算唯一、有意义解的必要数据和公式均已提供。因此，我们可以继续进行计算。\n\n目标是根据内部节点 $v$ 的两个子节点 $c_{1}$ 和 $c_{2}$ 的局部似然，计算该内部节点的局部似然 $L_{v}(A)$。节点 $v$ 的状态被指定为核苷酸 $A$。\n\n提供的剪枝递归公式为：\n$$\nL_{v}(x) \\;=\\; \\prod_{i=1}^{2}\\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{xy}(rt)\\,L^{(i)}_{y}\\right)\n$$\n对于特定状态 $x=A$，该公式变为：\n$$\nL_{v}(A) \\;=\\; \\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(1)}_{y}\\right) \\times \\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(2)}_{y}\\right)\n$$\n我们将乘积中的两项表示为 $S_{1}$ 和 $S_{2}$：\n$$\nS_{1} \\;=\\; \\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(1)}_{y}\n$$\n$$\nS_{2} \\;=\\; \\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(2)}_{y}\n$$\n因此，$L_{v}(A) = S_{1} \\times S_{2}$。\n\n首先，我们计算有效分支长度。给定的分支长度为 $t = 0.2$，特定位点的相对速率为 $r = 1.5$。因此，有效分支长度为：\n$$\nt_{\\text{eff}} \\;=\\; rt \\;=\\; 1.5 \\times 0.2 \\;=\\; 0.3\n$$\n接下来，我们确定在此有效分支长度下，Jukes-Cantor (JC69) 模型的转移概率。通用公式为：\n$$\nP_{xy}(t_{\\text{eff}}) \\;=\\; \\frac{1}{4} \\;+\\; \\left(\\delta_{xy} - \\frac{1}{4}\\right)\\exp\\!\\left(-\\frac{4t_{\\text{eff}}}{3}\\right)\n$$\n其中 $\\delta_{xy}$ 是克罗内克 delta 符号。我们关心的是从状态 $A$ 到状态 $y \\in \\{A,C,G,T\\}$ 的转移。\n\n指数函数的参数为：\n$$\n-\\frac{4t_{\\text{eff}}}{3} \\;=\\; -\\frac{4 \\times 0.3}{3} \\;=\\; -0.4\n$$\n对于从 $A$ 到 $A$ 的转移（匹配），$\\delta_{AA} = 1$：\n$$\nP_{AA}(0.3) \\;=\\; \\frac{1}{4} \\;+\\; \\left(1 - \\frac{1}{4}\\right)\\exp(-0.4) \\;=\\; 0.25 \\;+\\; 0.75\\exp(-0.4)\n$$\n对于从 $A$ 到任何其他核苷酸 $y \\in \\{C,G,T\\}$ 的转移（错配），$\\delta_{Ay} = 0$：\n$$\nP_{Ay}(0.3) \\;=\\; \\frac{1}{4} \\;+\\; \\left(0 - \\frac{1}{4}\\right)\\exp(-0.4) \\;=\\; 0.25 \\;-\\; 0.25\\exp(-0.4)\n$$\n我们记 $P_{A \\to A} = P_{AA}(0.3)$ 以及对于 $y \\ne A$ 有 $P_{A \\to \\text{mismatch}} = P_{Ay}(0.3)$。\n\n现在我们计算 $S_{1}$ 和 $S_{2}$。子节点 $c_{1}$ 的局部似然向量为 $\\boldsymbol{L}^{(1)} = (0.8,\\,0.1,\\,0.05,\\,0.05)$。\n$$\nS_{1} \\;=\\; P_{AA}(0.3)L^{(1)}_{A} \\;+\\; P_{AC}(0.3)L^{(1)}_{C} \\;+\\; P_{AG}(0.3)L^{(1)}_{G} \\;+\\; P_{AT}(0.3)L^{(1)}_{T}\n$$\n$$\nS_{1} \\;=\\; P_{A \\to A} \\cdot L^{(1)}_{A} \\;+\\; P_{A \\to \\text{mismatch}} \\cdot (L^{(1)}_{C} + L^{(1)}_{G} + L^{(1)}_{T})\n$$\n代入数值：\n$L^{(1)}_{A} = 0.8$ 且 $L^{(1)}_{C} + L^{(1)}_{G} + L^{(1)}_{T} = 0.1 + 0.05 + 0.05 = 0.2$。\n$$\nS_{1} \\;=\\; \\left(0.25 + 0.75\\exp(-0.4)\\right) \\times 0.8 \\;+\\; \\left(0.25 - 0.25\\exp(-0.4)\\right) \\times 0.2\n$$\n$$\nS_{1} \\;=\\; 0.2 + 0.6\\exp(-0.4) \\;+\\; 0.05 - 0.05\\exp(-0.4)\n$$\n$$\nS_{1} \\;=\\; 0.25 \\;+\\; 0.55\\exp(-0.4)\n$$\n子节点 $c_{2}$ 的局部似然向量为 $\\boldsymbol{L}^{(2)} = (0.2,\\,0.3,\\,0.4,\\,0.1)$。\n$$\nS_{2} \\;=\\; P_{A \\to A} \\cdot L^{(2)}_{A} \\;+\\; P_{A \\to \\text{mismatch}} \\cdot (L^{(2)}_{C} + L^{(2)}_{G} + L^{(2)}_{T})\n$$\n代入数值：\n$L^{(2)}_{A} = 0.2$ 且 $L^{(2)}_{C} + L^{(2)}_{G} + L^{(2)}_{T} = 0.3 + 0.4 + 0.1 = 0.8$。\n$$\nS_{2} \\;=\\; \\left(0.25 + 0.75\\exp(-0.4)\\right) \\times 0.2 \\;+\\; \\left(0.25 - 0.25\\exp(-0.4)\\right) \\times 0.8\n$$\n$$\nS_{2} \\;=\\; 0.05 + 0.15\\exp(-0.4) \\;+\\; 0.2 - 0.2\\exp(-0.4)\n$$\n$$\nS_{2} \\;=\\; 0.25 \\;-\\; 0.05\\exp(-0.4)\n$$\n现在，我们计算最终的局部似然 $L_{v}(A) = S_{1} \\times S_{2}$：\n$$\nL_{v}(A) \\;=\\; \\left(0.25 + 0.55\\exp(-0.4)\\right) \\times \\left(0.25 - 0.05\\exp(-0.4)\\right)\n$$\n展开这个乘积：\n$$\nL_{v}(A) \\;=\\; 0.25^{2} \\;-\\; 0.25 \\times 0.05\\exp(-0.4) \\;+\\; 0.55\\exp(-0.4) \\times 0.25 \\;-\\; 0.55\\exp(-0.4) \\times 0.05\\exp(-0.4)\n$$\n$$\nL_{v}(A) \\;=\\; 0.0625 \\;+\\; \\left(0.1375 - 0.0125\\right)\\exp(-0.4) \\;-\\; 0.0275\\exp(-0.8)\n$$\n$$\nL_{v}(A) \\;=\\; 0.0625 \\;+\\; 0.125\\exp(-0.4) \\;-\\; 0.0275\\exp(-0.8)\n$$\n我们现在代入指数项的数值。\n$$\n\\exp(-0.4) \\approx 0.6703200458\n$$\n$$\n\\exp(-0.8) \\approx 0.4493289641\n$$\n将这些值代入 $L_{v}(A)$ 的表达式中：\n$$\nL_{v}(A) \\approx 0.0625 \\;+\\; 0.125 \\times 0.6703200458 \\;-\\; 0.0275 \\times 0.4493289641\n$$\n$$\nL_{v}(A) \\approx 0.0625 \\;+\\; 0.0837900057 \\;-\\; 0.0123565465\n$$\n$$\nL_{v}(A) \\approx 0.1462900057 \\;-\\; 0.0123565465\n$$\n$$\nL_{v}(A) \\approx 0.1339334592\n$$\n题目要求将答案四舍五入到六位有效数字。前六位有效数字是 $1, 3, 3, 9, 3, 3$。第七位数字是 $4$，小于 $5$，所以我们向下舍入。\n$$\nL_{v}(A) \\approx 0.133933\n$$", "answer": "$$\n\\boxed{0.133933}\n$$", "id": "2747174"}, {"introduction": "在掌握了单个位点的计算之后，我们现在将视野放大，看看在速率异质性模型下，整个数据集是如何生成的。这个练习 [@problem_id:2747214] 将指导你实现一个算法，在JC69+$\\Gamma$ 模型下模拟序列在进化树上的演化过程。这是一种“生成式”的方法，它能让你深刻洞察形状参数 $\\alpha$ 如何决定不同位点间的演化速率差异，以及这些速率又是如何共同塑造出最终序列中的替换模式。", "problem": "您需要实现一个完整且可复现的算法，该算法使用 Jukes–Cantor 1969 (JC69) 模型，在具有均值为 1 的位点间 gamma 分布速率异质性（记为 JC69+$\\Gamma$）的条件下，模拟固定有根树下的 DNA 序列演化，然后验证位点速率的实现分布。实现必须遵循连续时间马尔可夫链的构建方法。\n\n从以下基础开始：\n- 一个在有限状态空间上的连续时间马尔可夫链，其瞬时速率矩阵为 $Q$，沿着长度为 $t$ 的分支演化，其跃迁概率矩阵为 $P(t) = \\exp(Qt)$，其中 $\\exp$ 表示矩阵指数。\n- JC69 模型的稳态碱基频率相等，即对于 $i \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，$\\pi_i = 1/4$。其瞬时速率矩阵 $Q$ 满足：当 $i \\neq j$ 时，$Q_{ij} = \\mu$；当 $i = j$ 时，$Q_{ii} = -3\\mu$。经过缩放以使平均替换速率为 $1$，即 $\\sum_i \\pi_i (-Q_{ii}) = 1$，这意味着 $\\mu = 1/3$。\n- 在 JC69 模型下，沿时间 $t$ 的跃迁概率有一个闭式解：当 $i=j$ 时，$P_{ii}(t) = 1/4 + 3/4 \\exp(-4t/3)$；当 $i \\neq j$ 时，$P_{ij}(t) = 1/4 - 1/4 \\exp(-4t/3)$。\n- 对于位点间 gamma 分布的速率异质性，位点特异性速率 $r$ 从一个 Gamma 分布中抽取，其形状参数为 $\\alpha$，尺度参数为 $\\theta$，使得均值为 $1$，即 $\\mathbb{E}[r] = \\alpha \\theta = 1$。设置 $\\theta = 1/\\alpha$，则 $\\operatorname{Var}(r) = \\alpha \\theta^2 = 1/\\alpha$。\n\n算法规范：\n- 设状态空间为 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，编码为 $\\{0,1,2,3\\}$。\n- 对于每个位点 $s \\in \\{1,\\dots,S\\}$，从 $\\text{Gamma}(\\alpha, \\theta)$（其中 $\\theta = 1/\\alpha$）分布中抽取一个速率 $r_s$。\n- 对每个位点独立地，通过从稳态分布 $(1/4,1/4,1/4,1/4)$ 中抽样来分配根节点的状态。\n- 对于每个有向边 $(u \\to v)$（分支长度为 $t_{uv}$）和一个给定的位点速率 $r_s$，通过从根据有效时间 $r_s t_{uv}$ 计算出的 JC69 跃迁矩阵 $P(r_s t_{uv})$ 的相应行中抽样，将状态从父节点 $u$ 传播到子节点 $v$。\n- 对于任何长度为 $t=0$ 的分支，强制 $P(0)$ 等于单位矩阵，因此子节点必须以概率 $1$ 继承父节点的状态。\n\n树与参数：\n- 使用一个有根树，其节点集为 $\\{0,1,2,3,4\\}$，根节点为 $0$，有向边为 $(0 \\to 1)$（长度 $t_{01} = 0.1$），$(1 \\to 2)$（长度 $t_{12} = 0.3$），$(1 \\to 3)$（长度 $t_{13} = 0.3$），以及 $(0 \\to 4)$（长度 $t_{04} = 0.2$）。叶节点为 $\\{2,3,4\\}$。所有分支长度均以平均速率为 $1$ 时每个位点的期望替换数来衡量。\n- 为确保可复现性，对所有随机抽样使用固定的伪随机数生成器种子 $20231105$。\n\n实现速率分布的验证：\n- 给定 $S$ 个抽取的速率 $\\{r_s\\}_{s=1}^S$，计算样本均值 $\\bar r = \\frac{1}{S}\\sum_{s=1}^S r_s$ 和无偏样本方差 $s^2 = \\frac{1}{S-1}\\sum_{s=1}^S (r_s - \\bar r)^2$。\n- 对于给定的 $\\alpha$，将 $\\bar r$ 与理论均值 $1$ 进行比较，将 $s^2$ 与理论方差 $1/\\alpha$ 进行比较，使用绝对误差容限 $\\varepsilon_{\\text{mean}}$ 和 $\\varepsilon_{\\text{var}}$。\n- 此外，通过检查以下条件来验证 JC69 跃迁矩阵的构建：对于任意正速率 $r$ 和时间 $t$，$P(rt)$ 的每一行之和在小的容限内为 $1$；并且 $P(0)$ 在小的容限内为单位矩阵。\n\n您的程序必须实现上述算法，并生成一行输出，将以下测试套件的结果聚合为一个用方括号括起来的逗号分隔列表：\n\n- 测试 1（速率验证，高异质性）：$\\alpha = 0.5$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.01$，$\\varepsilon_{\\text{var}} = 0.05$。输出一个布尔值，指示 $|\\bar r - 1| \\le 0.01$ 和 $|s^2 - 2.0| \\le 0.05$ 是否同时成立。\n- 测试 2（速率验证，低异质性）：$\\alpha = 5.0$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.005$，$\\varepsilon_{\\text{var}} = 0.01$。输出一个布尔值，指示 $|\\bar r - 1| \\le 0.005$ 和 $|s^2 - 0.2| \\le 0.01$ 是否同时成立。\n- 测试 3（跃迁矩阵的随机性）：对于 $N = 25$ 个独立抽取的对 $(r,t)$（其中 $r$ 在 $[0,3]$ 上均匀分布，$t$ 在 $[0,2]$ 上均匀分布），计算 $P(rt)$ 并检查行和与 $1$ 的最大绝对偏差是否最多为 $\\varepsilon_{\\text{row}} = 10^{-12}$。输出一个布尔值，指示这是否对所有 $N$ 次抽取都成立。\n- 测试 4（零长度分支的单位性）：对于 $N = 25$ 个独立抽取的速率 $r$（在 $[0,3]$ 上均匀分布），检查 $P(0)$ 是否等于单位矩阵，最大逐项绝对偏差最多为 $\\varepsilon_{\\text{id}} = 10^{-12}$。输出一个布尔值，指示这是否对所有 $N$ 次抽取都成立。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的四个测试用例的布尔结果，格式为用方括号括起来的逗号分隔列表（例如，`[true,false,true,true]`，但使用 Python 布尔值格式）。不应产生任何其他输出。", "solution": "我们根据连续时间马尔可夫链的第一性原理以及 Jukes–Cantor 1969 (JC69) 模型和 Gamma 分布的性质来设计算法和验证。\n\n1. JC69 速率矩阵缩放与跃迁概率：\n   - 在 JC69 中，瞬时速率矩阵 $Q$ 的非对角线元素为 $Q_{ij} = \\mu$（当 $i \\neq j$ 时），对角线元素为 $Q_{ii} = -3\\mu$。稳态分布是均匀的，即 $\\pi = (1/4,1/4,1/4,1/4)$。\n   - 稳态下的平均替换速率为 $\\sum_{i=1}^4 \\pi_i (-Q_{ii}) = \\sum_{i=1}^4 (1/4) \\cdot 3\\mu = 3\\mu$。为强制单位时间内的平均速率为 $1$ 次替换，我们设置 $3\\mu = 1$，因此 $\\mu = 1/3$。\n   - 跃迁概率矩阵 $P(t) = \\exp(Qt)$ 在 JC69 模型下有闭式解：\n     - 当 $i=j$ 时，$P_{ii}(t) = 1/4 + 3/4 \\exp(-4t/3)$。\n     - 当 $i \\neq j$ 时，$P_{ij}(t) = 1/4 - 1/4 \\exp(-4t/3)$。\n     这源于 $Q$ 的谱分解，其中有一个特征值为 $0$（对应特征向量 $\\mathbf{1}$），以及在正交子空间上的三个相同的特征值 $-4\\mu t$，由此得出所述表达式。\n\n2. 通过 Gamma 分布实现的位点间速率异质性：\n   - 设 $r$ 表示位点特异性相对速率。为模拟异质性，我们从 $r \\sim \\text{Gamma}(\\alpha, \\theta)$ 中抽样，其中形状参数为 $\\alpha$，尺度参数为 $\\theta$。\n   - 我们选择 $\\theta = 1/\\alpha$，使得 $\\mathbb{E}[r] = \\alpha \\theta = \\alpha \\cdot (1/\\alpha) = 1$，即平均速率为 1。\n   - 方差为 $\\operatorname{Var}(r) = \\alpha \\theta^2 = \\alpha \\cdot (1/\\alpha^2) = 1/\\alpha$，这是验证的关键理论目标。\n\n3. 沿树的逐位点连续时间马尔可夫链演化：\n   - 对于每个位点 $s \\in \\{1,\\dots,S\\}$：\n     - 从 $\\text{Gamma}(\\alpha, 1/\\alpha)$ 中抽取速率 $r_s$。\n     - 从 $\\pi = (1/4,1/4,1/4,1/4)$ 中抽取根状态。\n     - 对于每个长度为 $t_{uv}$ 的分支 $(u \\to v)$，计算有效时间 $\\tau_{uv,s} = r_s t_{uv}$ 并使用上述闭式解形成 JC69 跃迁矩阵 $P(\\tau_{uv,s})$。然后，根据 $P(\\tau_{uv,s})$ 中由父节点状态索引的行所给出的分类分布，对子节点 $v$ 的状态进行抽样。\n   - 此过程与连续时间马尔可夫链的时间变换性质一致：将每个分支上的时间缩放 $r_s$ 倍等效于将生成元缩放 $r_s$ 倍，这正是使用位点特异性速率的效果。\n\n4. 实现速率分布的验证：\n   - 给定抽取的速率 $\\{r_s\\}$，计算样本均值 $\\bar r = \\frac{1}{S}\\sum_{s=1}^{S} r_s$ 和无偏样本方差 $s^2 = \\frac{1}{S-1}\\sum_{s=1}^{S} (r_s - \\bar r)^2$。\n   - 对于指定的 $\\alpha$，将 $\\bar r$ 与理论均值 $1$ 进行比较，将 $s^2$ 与理论方差 $1/\\alpha$ 进行比较。我们指定绝对误差容限 $\\varepsilon_{\\text{mean}}$ 和 $\\varepsilon_{\\text{var}}$，并要求 $|\\bar r - 1| \\le \\varepsilon_{\\text{mean}}$ 和 $|s^2 - 1/\\alpha| \\le \\varepsilon_{\\text{var}}$ 通过。\n   - 额外的算法验证可加强正确性：\n     - 随机性：对于任意 $r \\ge 0$ 和 $t \\ge 0$，计算出的 $P(rt)$ 的行和必须为 $1$。由于闭式解的构造强制 $P_{ii}(t) = 1/4 + 3/4 \\exp(-4rt/3)$ 且当 $i \\neq j$ 时 $P_{ij}(t) = 1/4 - 1/4 \\exp(-4rt/3)$，因此在精确算术中，每行之和恰好为 $(1/4 + 3/4 e) + 3(1/4 - 1/4 e) = 1$。在浮点数算术中，我们要求偏差不超过一个小的容限 $\\varepsilon_{\\text{row}}$。\n     - 零长度分支的单位性：对于任何速率 $r$，$P(r \\cdot 0) = P(0)$ 必须等于单位矩阵，即 $\\exp(Q \\cdot 0) = I$。从闭式解来看，代入 $t=0$ 得到 $\\exp(-4 \\cdot 0/3) = 1$，因此 $P_{ii}(0) = 1/4 + 3/4 \\cdot 1 = 1$ 且当 $i \\neq j$ 时 $P_{ij}(0) = 1/4 - 1/4 \\cdot 1 = 0$。我们在容限 $\\varepsilon_{\\text{id}}$ 内检查这一点。\n\n5. 测试套件设计与输出：\n   - 测试 1：$\\alpha = 0.5$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.01$，$\\varepsilon_{\\text{var}} = 0.05$。理论方差为 $1/\\alpha = 2.0$。输出一个布尔值的通过/失败。\n   - 测试 2：$\\alpha = 5.0$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.005$，$\\varepsilon_{\\text{var}} = 0.01$。理论方差为 $1/\\alpha = 0.2$。输出一个布尔值的通过/失败。\n   - 测试 3：抽取 $N = 25$ 对 $(r,t)$，其中 $r \\sim \\text{Uniform}[0,3]$ 且 $t \\sim \\text{Uniform}[0,2]$。对每一对，计算 $P(rt)$ 并检查行和与 $1$ 的最大绝对偏差是否最多为 $\\varepsilon_{\\text{row}} = 10^{-12}$。输出一个布尔值，指示所有抽样是否都通过。\n   - 测试 4：抽取 $N = 25$ 个速率 $r \\sim \\text{Uniform}[0,3]$ 并验证 $P(0)$ 在 $\\varepsilon_{\\text{id}} = 10^{-12}$ 内等于单位矩阵。输出一个布尔值，指示所有抽样是否都通过。\n\n实现说明：\n- 使用固定的伪随机数种子 $20231105$ 使结果具有确定性。\n- 在序列模拟例程中使用给定的有根树及其分支长度；虽然分布验证不需要模拟序列，但序列模拟函数必须按照描述实现，以反映算法。\n- 最终程序必须打印单行，其中包含四个用方括号括起来并用逗号分隔的布尔结果，不得有其他文本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Fixed RNG for reproducibility as mandated by the problem statement.\nRNG = np.random.default_rng(20231105)\n\n# State mapping: 0,1,2,3 correspond to A,C,G,T (any consistent mapping suffices for JC69).\nNUM_STATES = 4\n\ndef draw_gamma_rates(n_sites: int, alpha: float, rng: np.random.Generator) -> np.ndarray:\n    \"\"\"\n    Draw n_sites rates from Gamma(shape=alpha, scale=1/alpha) so that E[r]=1 and Var[r]=1/alpha.\n    \"\"\"\n    scale = 1.0 / alpha\n    return rng.gamma(shape=alpha, scale=scale, size=n_sites)\n\ndef jc69_transition_matrix(effective_time: float) -> np.ndarray:\n    \"\"\"\n    Construct the JC69 transition matrix P(t) at time 'effective_time' = r * t.\n    JC69 scaling uses mu=1/3 so that average rate is 1, giving exponent -4 t / 3.\n    \"\"\"\n    e = np.exp(-4.0 * effective_time / 3.0)\n    P = np.full((NUM_STATES, NUM_STATES), 0.25 - 0.25 * e, dtype=float)\n    # Set diagonal entries\n    diag_val = 0.25 + 0.75 * e\n    for i in range(NUM_STATES):\n        P[i, i] = diag_val\n    return P\n\ndef simulate_sequences_on_tree(n_sites: int,\n                               alpha: float,\n                               edges: list[tuple[int, int, float]],\n                               root: int,\n                               rng: np.random.Generator) -> dict[int, np.ndarray]:\n    \"\"\"\n    Simulate sequences under JC69+Gamma on a rooted directed tree.\n    edges: list of (parent, child, branch_length) with branch lengths in expected substitutions/site.\n    Returns a dictionary mapping node -> sequence array of length n_sites with states in {0,1,2,3}.\n    \"\"\"\n    # Prepare adjacency and topological order from root.\n    children = {}\n    parents = {}\n    nodes = set([root])\n    for u, v, t in edges:\n        children.setdefault(u, []).append((v, t))\n        parents[v] = u\n        nodes.add(u); nodes.add(v)\n    # Derive a topological order (BFS from root suffices as edges are directed away from root).\n    topo_order = []\n    queue = [root]\n    visited = set()\n    while queue:\n        u = queue.pop(0)\n        if u in visited:\n            continue\n        visited.add(u)\n        topo_order.append(u)\n        for (v, _) in children.get(u, []):\n            queue.append(v)\n\n    # Draw site-specific rates.\n    rates = draw_gamma_rates(n_sites, alpha, rng)\n\n    # Initialize sequences per node.\n    seqs = {node: np.empty(n_sites, dtype=np.int8) for node in nodes}\n\n    # Root states sampled from stationary distribution (uniform over 4 states).\n    seqs[root] = rng.integers(low=0, high=NUM_STATES, size=n_sites, endpoint=False, dtype=np.int8)\n\n    # Propagate down the tree per site.\n    for u in topo_order:\n        for (v, t) in children.get(u, []):\n            parent_states = seqs[u]\n            child_states = np.empty(n_sites, dtype=np.int8)\n            if t == 0.0:\n                # Identity transition: child copies parent.\n                child_states[:] = parent_states\n            else:\n                # For each site, compute P(r*t) and sample child state conditional on parent state.\n                # To keep memory low, process in chunks.\n                chunk = 4096\n                for start in range(0, n_sites, chunk):\n                    end = min(start + chunk, n_sites)\n                    parent_chunk = parent_states[start:end]\n                    rates_chunk = rates[start:end]\n                    # For each site in chunk, compute P and sample.\n                    for idx in range(end - start):\n                        tau = rates_chunk[idx] * t\n                        P = jc69_transition_matrix(tau)\n                        p_row = P[parent_chunk[idx], :]\n                        # Sample according to probabilities in p_row.\n                        # Use choice with p; ensure numerical stability by normalizing.\n                        p_row = p_row / p_row.sum()\n                        child_states[start + idx] = rng.choice(NUM_STATES, p=p_row)\n            seqs[v] = child_states\n    return seqs\n\ndef sample_mean_and_unbiased_variance(x: np.ndarray) -> tuple[float, float]:\n    \"\"\"\n    Return sample mean and unbiased sample variance (denominator n-1).\n    \"\"\"\n    mean = float(np.mean(x))\n    # Unbiased sample variance\n    var = float(np.var(x, ddof=1))\n    return mean, var\n\ndef test_rate_validation(alpha: float, n_sites: int, tol_mean: float, tol_var: float, rng: np.random.Generator) -> bool:\n    \"\"\"\n    Draw rates and validate that sample mean and sample variance match 1 and 1/alpha within tolerances.\n    \"\"\"\n    rates = draw_gamma_rates(n_sites, alpha, rng)\n    mean, var = sample_mean_and_unbiased_variance(rates)\n    target_mean = 1.0\n    target_var = 1.0 / alpha\n    return (abs(mean - target_mean) <= tol_mean) and (abs(var - target_var) <= tol_var)\n\ndef test_stochasticity_row_sums(n_trials: int, tol_row: float, rng: np.random.Generator) -> bool:\n    \"\"\"\n    Randomly draw rates and times, compute P(r*t), and check row sums within tolerance.\n    \"\"\"\n    max_dev = 0.0\n    for _ in range(n_trials):\n        r = rng.uniform(0.0, 3.0)\n        t = rng.uniform(0.0, 2.0)\n        P = jc69_transition_matrix(r * t)\n        row_sums = P.sum(axis=1)\n        dev = float(np.max(np.abs(row_sums - 1.0)))\n        if dev > max_dev:\n            max_dev = dev\n        if dev > tol_row:\n            return False\n    return True\n\ndef test_identity_zero_branch(n_trials: int, tol_id: float, rng: np.random.Generator) -> bool:\n    \"\"\"\n    For random rates, check that P(0) equals identity within tolerance.\n    \"\"\"\n    I = np.eye(NUM_STATES)\n    for _ in range(n_trials):\n        _ = rng.uniform(0.0, 3.0)  # rate r (unused because t=0 forces tau=0)\n        P0 = jc69_transition_matrix(0.0)\n        if np.max(np.abs(P0 - I)) > tol_id:\n            return False\n    return True\n\ndef solve():\n    results = []\n\n    # Test 1: alpha=0.5, n_sites=200000, tol_mean=0.01, tol_var=0.05\n    res1 = test_rate_validation(alpha=0.5, n_sites=200000, tol_mean=0.01, tol_var=0.05, rng=RNG)\n    results.append(res1)\n\n    # Test 2: alpha=5.0, n_sites=200000, tol_mean=0.005, tol_var=0.01\n    res2 = test_rate_validation(alpha=5.0, n_sites=200000, tol_mean=0.005, tol_var=0.01, rng=RNG)\n    results.append(res2)\n\n    # Test 3: stochasticity of transition matrices, N=25, tol_row=1e-12\n    res3 = test_stochasticity_row_sums(n_trials=25, tol_row=1e-12, rng=RNG)\n    results.append(res3)\n\n    # Test 4: identity at zero branch length, N=25, tol_id=1e-12\n    res4 = test_identity_zero_branch(n_trials=25, tol_id=1e-12, rng=RNG)\n    results.append(res4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Implement the tree structure and simulation functions as required by the problem statement.\n# Although not directly used in the tests above (which focus on rate validation and matrix checks),\n# the following demonstrates the sequence simulation algorithm on the specified rooted tree.\ndef _demo_sequence_simulation():\n    # Rooted tree as specified: nodes {0,1,2,3,4}, root=0, edges with lengths.\n    root = 0\n    edges = [\n        (0, 1, 0.1),\n        (1, 2, 0.3),\n        (1, 3, 0.3),\n        (0, 4, 0.2),\n    ]\n    # Simulate a small alignment to verify procedure (not printed).\n    _ = simulate_sequences_on_tree(n_sites=10, alpha=0.5, edges=edges, root=root, rng=RNG)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2747214"}, {"introduction": "在真实的生物学研究中，我们通常从数据出发，需要推断产生这些数据的演化过程，而其中至关重要的一步就是选择一个合适的演化模型。最后一个动手实践 [@problem_id:2424572] 让你扮演分析师的角色，使用赤池信息准则（AIC）和贝叶斯信息准则（BIC）来比较不同的核酸替换模型，包括那些考虑了速率异质性的模型。你将学会如何在模型的拟合优度与复杂性之间进行权衡，从而做出有原则的选择——这是现代统计生物学中的一项基本技能。", "problem": "给定一个针对 DNA 序列比对的固定无根系统发育树拓扑和分支长度，以及五个嵌套的时间可逆核苷酸替换模型：Jukes–Cantor (JC)、Hasegawa–Kishino–Yano (HKY)、带伽马分布位点速率异质性的 HKY (HKY+$\\Gamma$)、通用时间可逆模型 (GTR)，以及带伽马分布位点速率异质性和不变位点比例的 GTR (GTR+$\\Gamma$+I)。数据字母表大小为 $4$ (A, C, G, T)。用于近似伽马分布的离散类别数量是预先固定的。模型复杂度仅计算替换过程参数；树拓扑、分支长度和固定的伽马速率类别数量不计入其中。\n\n用于参数计数的模型定义：\n- JC：所有碱基频率相等，所有交换率相等。\n- HKY：区分转换/颠换速率比和自由的稳态碱基频率。\n- GTR：完全通用的时间可逆交换率和自由的稳态碱基频率。\n- $\\Gamma$：由带有一个自由形状参数 $\\alpha$ 的伽马分布建模的连续位点速率异质性。\n- I：一个自由的不变位点比例 $p_I$。\n\n使用以下模型编码：\n- $0$: JC\n- $1$: HKY\n- $2$: HKY+$\\Gamma$\n- $3$: GTR\n- $4$: GTR+$\\Gamma$+I\n\n对于下方的每个数据集，给定比对长度 $n$（位点数）和在同一固定树上，五个模型（按模型代码顺序 $0,1,2,3,4$）分别获得的最大化自然对数似然值 $\\ln \\mathcal{L}$。您必须基于第一性原理，为每个数据集确定哪个模型最小化赤池信息准则 (AIC)，哪个模型最小化贝叶斯信息准则 (BIC)。如果某个准則值出现精确相等的情况，选择自由替换过程参数 $k$ 较少的模型；如果 $k$ 也相等，则选择模型代码较小的模型。\n\n测试套件（比对长度 $n$ 和模型 $0$ 到 $4$ 的对数似然向量 $(\\ln \\mathcal{L}_0,\\ln \\mathcal{L}_1,\\ln \\mathcal{L}_2,\\ln \\mathcal{L}_3,\\ln \\mathcal{L}_4)$）：\n- 数据集 $1$：$n = 500$, $( -1650.0,\\ -1585.0,\\ -1568.0,\\ -1565.0,\\ -1560.5 )$。\n- 数据集 $2$：$n = 50$, $( -540.0,\\ -505.0,\\ -500.0,\\ -499.2,\\ -493.0 )$。\n- 数据集 $3$：$n = 200$, $( -700.0,\\ -650.0,\\ -650.0,\\ -649.5,\\ -649.5 )$。\n- 数据集 $4$：$n = 10$, $( -120.0,\\ -120.0,\\ -120.0,\\ -120.0,\\ -120.0 )$。\n\n您的程序必须：\n- 基于第一性原理，根据一个 $4$-状态字母表，为每个模型推断出自由替换过程参数的数量 $k$。这需要考虑稳态碱基频率概率之和为 $1$ 的约束，以及时间可逆模型中总体速率尺度不可识别的约束。当存在 $\\Gamma$ 时，为伽马形状参数 $\\alpha$ 计 $1$ 个参数；当存在 I 时，为不变位点比例 $p_I$ 计 $1$ 个参数。\n- 对每个数据集，计算最小化 AIC 的模型代码和最小化 BIC 的模型代码。\n- 应用指定的平局打破规则。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个列表中的 $8$ 个整数，按顺序对应于数据集 $1$ 到 $4$ 的结果，并且每个数据集首先报告最小化 AIC 的模型代码，然后报告最小化 BIC 的模型代码。该行必须是一个逗号分隔的列表，用方括号括起来，不含空格，例如 $[a_1,b_1,a_2,b_2,a_3,b_3,a_4,b_4]$，其中 $a_i$ 是数据集 $i$ 的 AIC 最小化模型代码，$b_i$ 是数据集 $i$ 的 BIC 最小化模型代码。", "solution": "我们从第一性原理出发。对于一个 $4$-状态字母表上的时间可逆核苷酸替换模型，自由参数来自三个来源：可逆速率矩阵的交换率参数、稳态碱基频率，以及任何位点速率异质性参数，如伽马形状参数 $\\alpha$ 或不变位点比例 $p_I$。\n\n稳态碱基频率：有 $4$ 个频率，其和为 $1$，因此当碱基频率自由时，产生 $4-1=3$ 个自由参数。在 JC 模型中，碱基频率被约束为相等，贡献 $0$ 个自由参数。\n\n交换率：对于一个 $4$ 状态上的完全通用时间可逆速率矩阵 (GTR)，有 $\\binom{4}{2}=6$ 个交换率，但一个总体速率尺度因子是不可识别的（它可以被吸收到分支长度中），剩下 $6-1=5$ 个自由交换率参数。在 HKY 模型中，有两个交换率类别（转换与颠换），但同样的可识别性约束移除了总体尺度，剩下 $2-1=1$ 个自由交换率参数（转换/颠换速率比）。在 JC 模型中，所有交换率都被约束为相等，贡献 $0$ 个自由参数。\n\n伽马位点速率异质性：用于跨位点速率异质性的连续伽马分布在存在时贡献一个自由形状参数 $\\alpha$。用于近似伽马分布的离散类别数量是固定的，不改变模型复杂度。不变位点： proportion $p_I$ 存在时是一个单一的自由参数。\n\n因此，每个模型的自由替换过程参数数量 $k$ 为：\n- JC: $k = 0 \\ (\\text{无自由碱基频率，无自由交换率，无异质性参数})$。\n- HKY: $k = 4 \\ (\\text{1 交换率} + \\text{3 碱基频率})$。\n- HKY+$\\Gamma$: $k = 4 + 1 \\ (\\alpha) = 5$。\n- GTR: $k = 8 \\ (\\text{5 交换率} + \\text{3 碱基频率})$。\n- GTR+$\\Gamma$+I: $k = 8 + 1 \\ (\\alpha) + 1 \\ (p_I) = 10$。\n\n信息准则的定义，用最大化自然对数似然值 $\\ln \\mathcal{L}$ 和自由参数数量 $k$ 表示为：\n- 赤池信息准则 (Akaike Information Criterion): $\\mathrm{AIC} = 2k - 2 \\ln \\mathcal{L}$。\n- 贝叶斯信息准则 (Bayesian Information Criterion): $\\mathrm{BIC} = k \\ln n - 2 \\ln \\mathcal{L}$，其中 $n$ 是独立观测的数量（此处为位点数）。\n\n对于每个数据集，我们使用给定的 $\\ln \\mathcal{L}$ 值和 $n$ 为所有五个模型计算 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$，并选择准则值最小的模型，通过较小的 $k$ 打破平局，然后通过较小的模型代码打破平局。\n\n计算结果：\n\n数据集 $1$：$n=500$, $\\ln n \\approx 6.2146081$。\n- JC: $k=0$, $-2\\ln \\mathcal{L} = 3300.0$; $\\mathrm{AIC}=3300.0$, $\\mathrm{BIC}=3300.0$。\n- HKY: $k=4$, $-2\\ln \\mathcal{L} = 3170.0$; $\\mathrm{AIC}=3178.0$, $\\mathrm{BIC}\\approx 3170.0 + 4 \\times 6.2146081 \\approx 3194.858$。\n- HKY+$\\Gamma$: $k=5$, $-2\\ln \\mathcal{L} = 3136.0$; $\\mathrm{AIC}=3146.0$, $\\mathrm{BIC}\\approx 3167.073$。\n- GTR: $k=8$, $-2\\ln \\mathcal{L} = 3130.0$; $\\mathrm{AIC}=3146.0$, $\\mathrm{BIC}\\approx 3179.717$。\n- GTR+$\\Gamma$+I: $k=10$, $-2\\ln \\mathcal{L} = 3121.0$; $\\mathrm{AIC}=3141.0$, $\\mathrm{BIC}\\approx 3183.146$。\n最小 $\\mathrm{AIC}$ 是 GTR+$\\Gamma$+I (代码 $4$)。在 AIC 为 $3146.0$ 的平局中，HKY+$\\Gamma$ ($k=5$) 优于 GTR ($k=8$)；然而，GTR+$\\Gamma$+I 的 AIC 更低，为 $3141.0$。最小 $\\mathrm{BIC}$ 是 HKY+$\\Gamma$ (代码 $2$)。\n\n数据集 $2$：$n=50$, $\\ln n \\approx 3.9120230$。\n- JC: $k=0$, $-2\\ln \\mathcal{L} = 1080.0$; $\\mathrm{AIC}=1080.0$, $\\mathrm{BIC}=1080.0$。\n- HKY: $k=4$, $-2\\ln \\mathcal{L} = 1010.0$; $\\mathrm{AIC}=1018.0$, $\\mathrm{BIC}\\approx 1025.648$。\n- HKY+$\\Gamma$: $k=5$, $-2\\ln \\mathcal{L} = 1000.0$; $\\mathrm{AIC}=1010.0$, $\\mathrm{BIC}\\approx 1019.560$。\n- GTR: $k=8$, $-2\\ln \\mathcal{L} = 998.4$; $\\mathrm{AIC}=1014.4$, $\\mathrm{BIC}\\approx 1029.696$。\n- GTR+$\\Gamma$+I: $k=10$, $-2\\ln \\mathcal{L} = 986.0$; $\\mathrm{AIC}=1006.0$, $\\mathrm{BIC}\\approx 1025.120$。\n最小 $\\mathrm{AIC}$ 是 GTR+$\\Gamma$+I (代码 $4$)。最小 $\\mathrm{BIC}$ 是 HKY+$\\Gamma$ (代码 $2$)。\n\n数据集 $3$：$n=200$, $\\ln n \\approx 5.2983174$。\n- JC: $k=0$, $-2\\ln \\mathcal{L} = 1400.0$; $\\mathrm{AIC}=1400.0$, $\\mathrm{BIC}=1400.0$。\n- HKY: $k=4$, $-2\\ln \\mathcal{L} = 1300.0$; $\\mathrm{AIC}=1308.0$, $\\mathrm{BIC}\\approx 1321.192$。\n- HKY+$\\Gamma$: $k=5$, $-2\\ln \\mathcal{L} = 1300.0$; $\\mathrm{AIC}=1310.0$, $\\mathrm{BIC}\\approx 1326.492$。\n- GTR: $k=8$, $-2\\ln \\mathcal{L} = 1299.0$; $\\mathrm{AIC}=1315.0$, $\\mathrm{BIC}\\approx 1341.386$。\n- GTR+$\\Gamma$+I: $k=10$, $-2\\ln \\mathcal{L} = 1299.0$; $\\mathrm{AIC}=1319.0$, $\\mathrm{BIC}\\approx 1351.983$。\n最小 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$ 都是 HKY (代码 $1$)。\n\n数据集 $4$：$n=10$, $\\ln n \\approx 2.3025851$；所有 $\\ln \\mathcal{L} = -120.0$，所以对所有模型 $-2 \\ln \\mathcal{L} = 240.0$。\n- JC: $k=0$; $\\mathrm{AIC}=240.0$, $\\mathrm{BIC}=240.0$。\n- HKY: $k=4$; $\\mathrm{AIC}=248.0$, $\\mathrm{BIC}\\approx 249.210$。\n- HKY+$\\Gamma$: $k=5$; $\\mathrm{AIC}=250.0$, $\\mathrm{BIC}\\approx 251.513$。\n- GTR: $k=8$; $\\mathrm{AIC}=256.0$, $\\mathrm{BIC}\\approx 258.421$。\n- GTR+$\\Gamma$+I: $k=10$; $\\mathrm{AIC}=260.0$, $\\mathrm{BIC}\\approx 263.026$。\n最小 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$ 都是 JC (代码 $0$)。\n\n因此，所需的输出是包含 $8$ 个整数的扁平列表：\n$[4,2,4,2,1,1,0,0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_free_parameters(model_code: int) -> int:\n    \"\"\"\n    Compute the number of free substitution-process parameters k for a 4-state\n    time-reversible nucleotide model, excluding topology/branch lengths and\n    the fixed number of gamma categories.\n\n    Model codes:\n      0: JC\n      1: HKY\n      2: HKY+Gamma\n      3: GTR\n      4: GTR+Gamma+I\n    \"\"\"\n    # Base frequency degrees of freedom: 3 when free, 0 for JC (equal)\n    if model_code == 0:\n        basefreq_df = 0  # JC has equal base frequencies\n        exch_df = 0      # JC has all exchangeabilities equal\n        gamma_shape = 0\n        pinv = 0\n    elif model_code == 1:\n        basefreq_df = 3  # HKY: free base frequencies\n        exch_df = 1      # HKY: transitions vs transversions, minus overall scale\n        gamma_shape = 0\n        pinv = 0\n    elif model_code == 2:\n        basefreq_df = 3\n        exch_df = 1\n        gamma_shape = 1  # Gamma shape alpha\n        pinv = 0\n    elif model_code == 3:\n        basefreq_df = 3\n        exch_df = 5      # GTR: 6 exchangeabilities minus one overall scale\n        gamma_shape = 0\n        pinv = 0\n    elif model_code == 4:\n        basefreq_df = 3\n        exch_df = 5\n        gamma_shape = 1\n        pinv = 1         # Proportion invariant sites\n    else:\n        raise ValueError(\"Unknown model code\")\n    return basefreq_df + exch_df + gamma_shape + pinv\n\ndef aic(k: int, logL: float) -> float:\n    return 2.0 * k - 2.0 * logL\n\ndef bic(k: int, logL: float, n: int) -> float:\n    return k * float(np.log(n)) - 2.0 * logL\n\ndef select_min(values, ks, tol=1e-9):\n    \"\"\"\n    Select the index of the minimal value with tie-breaking:\n    1) smaller k (model complexity), 2) smaller index.\n    tol allows treating near-equalities as ties.\n    \"\"\"\n    best_idx = None\n    best_val = None\n    best_k = None\n    for idx, (v, k) in enumerate(zip(values, ks)):\n        if best_idx is None:\n            best_idx = idx\n            best_val = v\n            best_k = k\n            continue\n        # If new value is clearly smaller\n        if v  best_val - tol:\n            best_idx = idx\n            best_val = v\n            best_k = k\n        # If values are tied (within tolerance)\n        elif abs(v - best_val) = tol:\n            if k  best_k: # Tie-break with k\n                best_idx = idx\n                best_val = v\n                best_k = k\n            elif k == best_k and idx  best_idx: # Tie-break with index\n                best_idx = idx\n                best_val = v\n                best_k = k\n    return best_idx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each entry: (n, [logL_model0, logL_model1, logL_model2, logL_model3, logL_model4])\n    test_cases = [\n        (500, [-1650.0, -1585.0, -1568.0, -1565.0, -1560.5]),\n        (50,  [-540.0,  -505.0,  -500.0,  -499.2,  -493.0]),\n        (200, [-700.0,  -650.0,  -650.0,  -649.5,  -649.5]),\n        (10,  [-120.0,  -120.0,  -120.0,  -120.0,  -120.0]),\n    ]\n\n    model_codes = [0, 1, 2, 3, 4]\n    ks = [count_free_parameters(m) for m in model_codes]\n\n    results = []\n    for n, logLs in test_cases:\n        aics = [aic(ks[i], logLs[i]) for i in range(5)]\n        bics = [bic(ks[i], logLs[i], n) for i in range(5)]\n        \n        # In problem 3, logL for HKY and HKY+G are equal, and GTR and GTR+G+I are equal.\n        # The provided logL values might be rounded. A small tolerance is prudent.\n        # However, the problem says \"精确相等的情况\" (exact tie), so we should use tol=0.\n        best_aic_model = select_min(aics, ks, tol=0.0)\n        best_bic_model = select_min(bics, ks, tol=0.0)\n        results.append(best_aic_model)\n        results.append(best_bic_model)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424572"}]}