{"hands_on_practices": [{"introduction": "要掌握任何定量指标，第一步都是亲手计算它。本练习将引导你完成这一基本过程。通过一个具体的基因序列和预先计算好的密码子相对适应性权重（$w$），你将有机会一步步计算密码子适应指数（CAI），并深入理解其核心——几何平均数的应用及其对翻译效率评估的重要性。[@problem_id:2843211]", "problem": "在原核生物基因组中，密码子使用模式反映了对翻译效率和准确性的选择，其理论基础是分子生物学中心法则和遗传密码的简并性。在许多细菌中，高表达基因表现出对同义密码子的偏好性使用，这些密码子与细胞内丰富的转移核糖核酸（tRNA）种类相匹配。这一观察启发了一种定量指标的建立，用于衡量一个基因的密码子组成与一个高表达基因参考集的匹配程度。密码子适应指数（CAI）是根据从参考集中推导出的密码子特异性相对适应度值构建的。其中，每个密码子的相对适应度可以通过多种方法获得，例如，将其相对同义密码子使用频率（RSCU）除以其同义密码子中的最大RSCU值进行归一化。\n\n现给定一个信使核糖核酸（mRNA）编码序列（+1阅读框），它属于一个推定的开放阅读框，以一个经典起始密码子开始，并以一个终止密码子结束（为完整起见，显示了终止密码子，但其不计入CAI评分）。该编码序列以 $5'$ 到 $3'$ 方向书写，如下所示：\nAUG GCU GCU GAA GAA UUU UUC CGU CGC AGA UGG GCG AAG UAA\n\n一个该生物的高表达基因参考集已被用于计算上述序列中出现的密码子的特异性相对适应度权重 $w(\\text{codon})$。这些权重如下：\n- 甲硫氨酸 (AUG): $1.00$。\n- 丙氨酸 (GCU): $0.35$；丙氨酸 (GCG): $0.80$。\n- 谷氨酸 (GAA): $0.65$。\n- 苯丙氨酸 (UUU): $0.55$；苯丙氨酸 (UUC): $1.00$。\n- 精氨酸 (CGU): $0.40$；精氨酸 (CGC): $0.95$；精氨酸 (AGA): $0.85$。\n- 色氨酸 (UGG): $1.00$。\n- 赖氨酸 (AAG): $1.00$。\n\n任务：\n1. 从遗传密码的简并性和高表达基因中密码子使用偏好性的基本观察出发，提供一个研究生水平的关于密码子适应指数（CAI）的精确定义。该定义需解释其如何从密码子特异性相对适应度值构建，并论证为何使用经长度归一化的乘法聚合而非加法聚合。\n2. 仅使用起始密码子和末端终止密码子之间的密码子（不包括终止密码子本身），根据上文所述的标准构建方法计算该开放阅读框的CAI值。计算时，将单密码子氨基酸（甲硫氨酸和色氨酸）的权重设为1。将最终数值结果四舍五入至四位有效数字。CAI是无量纲的，请以纯数形式报告。", "solution": "所给出的问题陈述具有科学依据、提法得当且客观。它基于分子遗传学和生物信息学的既定原则，特别是中心法则、遗传密码的简并性以及密码子使用偏好性的概念。所提供的数据——一段信使核糖核酸（mRNA）序列和一组密码子特异性相对适应度权重——对于完成所需计算是充分且一致的。任务定义清晰且可形式化。因此，该问题是有效的，将提供解答。\n\n问题包含两个任务：首先，提供密码子适应指数（CAI）的正式定义；其次，为给定序列计算其值。\n\n任务1：密码子适应指数（CAI）的定义\n\n密码子适应指数（CAI）的理论基础源于分子生物学的一些基本观察。遗传密码是简并的，这意味着大多数氨基酸由一个以上的密码子编码，这些密码子被称为同义密码子。经验观察表明，尤其是在快速分裂的微生物中，同义密码子的使用频率并不相等。这种现象被称为密码子使用偏好性。一个得到大量证据支持的主流假说是，这种偏好性是自然选择作用于优化翻译效率和准确性的结果。必须高水平表达的基因，例如核糖体蛋白或糖酵解酶的基因，表现出强烈的偏好，倾向于使用一个特定的“最优”密码子子集。这些最优密码子被细胞中最丰富的转移核糖核酸（tRNA）种类所识别，从而促进了快速而高效的多肽链延伸。\n\n基于这些原则，CAI是一个定量指标，旨在评估一个基因在多大程度上利用了这些偏好密码子。它在“翻译选择是塑造密码子使用模式的主导力量”这一假设下，预测基因的表达水平。较高的CAI值表明一个基因可能高表达。\n\nCAI的构建过程如下：\n\n1.  为特定生物定义一个高表达基因的参考集。该集合被假定代表了该生物的“最优”密码子用法。\n\n2.  从此参考集中，计算每个密码子 $c$ 的相对适应度 $w_c$。对于给定的氨基酸，参考集中使用最频繁的密码子被赋予1.0的相对适应度。该氨基酸的任何其他同义密码子 $c_i$ 的相对适应度是其使用频率 $f_i$ 与最常用密码子频率 $f_{\\text{max}}$ 的比率。\n    $$w_{c_i} = \\frac{f_i}{f_{\\text{max}}}$$\n    对于仅由一个密码子编码的氨基酸（由`AUG`编码的甲硫氨酸和由`UGG`编码的色氨酸），不存在密码子选择，其相对适应度被定义为1.0。\n\n3.  对于一个长度为 $L$ 个密码子（不包括终止密码子）的给定基因，其CAI值计算为其编码序列中每个密码子相对适应度值的几何平均数。若 $w_k$ 是基因中第 $k$ 个密码子的相对适应度，则CAI由以下公式给出：\n    $$ \\text{CAI} = \\left( \\prod_{k=1}^{L} w_k \\right)^{\\frac{1}{L}} $$\n    这也可以等效地使用对数表示，这种方式在数值计算上通常更稳定：\n    $$ \\text{CAI} = \\exp\\left( \\frac{1}{L} \\sum_{k=1}^{L} \\ln(w_k) \\right) $$\n\n使用乘法聚合（几何平均数）而非加法聚合（算术平均数）是CAI的一个关键特征。蛋白质合成是一个顺序过程，每个密码子按序翻译。合成的整体速率可能受限于最慢的步骤，即翻译具有最低适应度（即被最稀有的tRNA识别）的密码子。算术平均数会掩盖这种“瓶颈”效应，因为几个高度优化的密码子在数值上可以弥补一个非常差的密码子。然而，几何平均数对低值高度敏感。单个相对适应度接近于零的密码子会将整个CAI值推向零，从而正确反映单个限速步骤对整体翻译效率的巨大负面影响。\n\n任务2：CAI的计算\n\n给定的mRNA序列为 $5'$-`AUG GCU GCU GAA GAA UUU UUC CGU CGC AGA UGG GCG AAG UAA`-$3'$。问题要求计算时排除终止密码子（`UAA`）。因此，待评分的编码序列从起始密码子`AUG`开始，到`AAG`结束。待评分序列的总长度为 $L = 13$ 个密码子。\n\n根据所提供的信息，密码子序列及其对应的相对适应度权重 $w_k$ 如下：\n1.  密码子 1: `AUG`, $w_1 = 1.00$\n2.  密码子 2: `GCU`, $w_2 = 0.35$\n3.  密码子 3: `GCU`, $w_3 = 0.35$\n4.  密码子 4: `GAA`, $w_4 = 0.65$\n5.  密码子 5: `GAA`, $w_5 = 0.65$\n6.  密码子 6: `UUU`, $w_6 = 0.55$\n7.  密码子 7: `UUC`, $w_7 = 1.00$\n8.  密码子 8: `CGU`, $w_8 = 0.40$\n9.  密码子 9: `CGC`, $w_9 = 0.95$\n10. 密码子 10: `AGA`, $w_{10} = 0.85$\n11. 密码子 11: `UGG`, $w_{11} = 1.00$\n12. 密码子 12: `GCG`, $w_{12} = 0.80$\n13. 密码子 13: `AAG`, $w_{13} = 1.00$\n\nCAI是这13个权重的几何平均数：\n$$ \\text{CAI} = \\left( w_1 \\times w_2 \\times w_3 \\times \\dots \\times w_{13} \\right)^{\\frac{1}{13}} $$\n首先，我们计算权重的乘积：\n$$ \\prod_{k=1}^{13} w_k = (1.00) \\times (0.35) \\times (0.35) \\times (0.65) \\times (0.65) \\times (0.55) \\times (1.00) \\times (0.40) \\times (0.95) \\times (0.85) \\times (1.00) \\times (0.80) \\times (1.00) $$\n$$ \\prod_{k=1}^{13} w_k = (0.35)^2 \\times (0.65)^2 \\times 0.55 \\times 0.40 \\times 0.95 \\times 0.85 \\times 0.80 $$\n$$ \\prod_{k=1}^{13} w_k = (0.1225) \\times (0.4225) \\times (0.55) \\times (0.40) \\times (0.95) \\times (0.85) \\times (0.80) $$\n$$ \\prod_{k=1}^{13} w_k = 0.007355600375 $$\n现在，我们计算该乘积的13次方根：\n$$ \\text{CAI} = (0.007355600375)^{\\frac{1}{13}} $$\n$$ \\text{CAI} \\approx 0.68532408 $$\n问题要求将答案四舍五入至四位有效数字。\n$$ \\text{CAI} \\approx 0.6853 $$\n这个值介于0和1之间，表示在特定生物体的翻译机制背景下，该基因具有中等水平的密码子适应度。", "answer": "$$\\boxed{0.6853}$$", "id": "2843211"}, {"introduction": "在计算了 CAI 之后，一个自然而然的下一步是利用它来主动优化基因。这个练习将你置于合成生物学家的角色，面对一个实际挑战：如何通过一次同义突变，最大限度地提高一个基因的预测表达水平？解决这个问题不仅需要你理解 CAI 的计算公式，更需要你运用算法思维来寻找最优的密码子替换策略。[@problem_id:2380006]", "problem": "你的任务是计算密码子适应性指数 (CAI)，并为每个提供的基因确定能导致 CAI 增长幅度最大的单个同义密码子替换。密码子适应性指数是一个源于一组高表达基因参考集中的密码子使用偏好性的度量。它基于分子生物学中心法则的以下基本概念：脱氧核糖核酸 (DNA) 通过三联体密码子翻译成蛋白质，每个密码子指定一个氨基酸；多个密码子可以编码相同的氨基酸，并且在特定生物体或条件下它们的使用可能存在偏好性。\n\n定义和约束：\n- 令一个编码 DNA 序列为一个由字母表 $\\{A,C,G,T\\}$ 组成的字符串，其长度可被 $3$ 整除，并被划分为 $n$ 个密码子。假设使用标准遗传密码，且序列内部没有终止密码子。\n- 对于每种氨基酸，一个参考密码子使用表为每个有义密码子 $c$ 指定一个非负参考值 $f(c)$，该值与该密码子在高表达基因中的使用频率成正比。\n- 对于每种氨基酸 $a$，令 $\\mathcal{S}(a)$ 为其同义有义密码子集合。定义一个密码子 $c \\in \\mathcal{S}(a)$ 的相对适应性权重 $w(c)$ 为 $w(c) = f(c) / \\max\\{f(c') : c' \\in \\mathcal{S}(a)\\}$。根据定义，对于只有一个密码子的氨基酸，$w(c) = 1$。\n- 一个由密码子 $(c_1, c_2, \\dots, c_n)$ 组成的基因的密码子适应性指数 (CAI) 是其相对适应性权重的几何平均值，即在所有位置 $i \\in \\{1,\\dots,n\\}$ 上 $w(c_i)$ 的乘积的 $n$ 次方根。\n- 此处定义的单个密码子改变是指，将基因中的一个密码子更改为该位置氨基酸的另一个同义密码子（从而保持编码的氨基酸序列不变）。你可以选择任何同义密码子作为替换（不限于单核苷酸突变）。\n- 如果没有任何同义替换能增加 CAI，则该基因所需的结果为 $0$，因为你可以选择不作任何改变。\n\n任务：\n- 以以上定义为基础，实现一个程序，为每个给定的基因计算通过在基因中任意位置进行一次同义密码子替换可获得的 CAI 最大增量。仅使用下面提供的参考密码子使用表。忽略标准遗传密码映射之外的起始和终止密码子特殊情况；严格根据基因中所有密码子的 $w(c)$ 值计算 CAI。\n\n参考密码子使用表 $f(c)$（假设的生物体，标准遗传密码，仅有义密码子）。对于每种氨基酸，其同义密码子集合内的 $f(c)$ 值与其使用频率成正比：\n- 苯丙氨酸 (F): $TTT \\mapsto 0.3$, $TTC \\mapsto 0.7$.\n- 亮氨酸 (L): $TTA \\mapsto 0.05$, $TTG \\mapsto 0.1$, $CTT \\mapsto 0.1$, $CTC \\mapsto 0.2$, $CTA \\mapsto 0.05$, $CTG \\mapsto 0.5$.\n- 异亮氨酸 (I): $ATT \\mapsto 0.35$, $ATC \\mapsto 0.6$, $ATA \\mapsto 0.05$.\n- 甲硫氨酸 (M): $ATG \\mapsto 1.0$.\n- 缬氨酸 (V): $GTT \\mapsto 0.2$, $GTC \\mapsto 0.25$, $GTA \\mapsto 0.05$, $GTG \\mapsto 0.5$.\n- 丝氨酸 (S): $TCT \\mapsto 0.15$, $TCC \\mapsto 0.3$, $TCA \\mapsto 0.04$, $TCG \\mapsto 0.1$, $AGT \\mapsto 0.06$, $AGC \\mapsto 0.35$.\n- 脯氨酸 (P): $CCT \\mapsto 0.2$, $CCC \\mapsto 0.2$, $CCA \\mapsto 0.1$, $CCG \\mapsto 0.5$.\n- 苏氨酸 (T): $ACT \\mapsto 0.2$, $ACC \\mapsto 0.55$, $ACA \\mapsto 0.1$, $ACG \\mapsto 0.15$.\n- 丙氨酸 (A): $GCT \\mapsto 0.2$, $GCC \\mapsto 0.5$, $GCA \\mapsto 0.1$, $GCG \\mapsto 0.2$.\n- 酪氨酸 (Y): $TAT \\mapsto 0.3$, $TAC \\mapsto 0.7$.\n- 组氨酸 (H): $CAT \\mapsto 0.3$, $CAC \\mapsto 0.7$.\n- 谷氨酰胺 (Q): $CAA \\mapsto 0.3$, $CAG \\mapsto 0.7$.\n- 天冬酰胺 (N): $AAT \\mapsto 0.3$, $AAC \\mapsto 0.7$.\n- 赖氨酸 (K): $AAA \\mapsto 0.4$, $AAG \\mapsto 0.6$.\n- 天冬氨酸 (D): $GAT \\mapsto 0.4$, $GAC \\mapsto 0.6$.\n- 谷氨酸 (E): $GAA \\mapsto 0.6$, $GAG \\mapsto 0.4$.\n- 半胱氨酸 (C): $TGT \\mapsto 0.35$, $TGC \\mapsto 0.65$.\n- 色氨酸 (W): $TGG \\mapsto 1.0$.\n- 精氨酸 (R): $CGT \\mapsto 0.35$, $CGC \\mapsto 0.4$, $CGA \\mapsto 0.1$, $CGG \\mapsto 0.1$, $AGA \\mapsto 0.03$, $AGG \\mapsto 0.02$.\n- 甘氨酸 (G): $GGT \\mapsto 0.3$, $GGC \\mapsto 0.45$, $GGA \\mapsto 0.15$, $GGG \\mapsto 0.1$.\n\n测试套件：\n为以下每个基因计算所需的量（通过一次同义密码子改变可实现的 CAI 最大增量）。所有序列均使用标准遗传密码，只含有义密码子，且长度可被 $3$ 整除。\n- 基因 1：$ATGAGGATATTATCAGAAGGTGTTAAACAT$.\n- 基因 2：$ATGCTGCGCAGCATCGTGCCGGCC$.\n- 基因 3：$ATGTGGATGTGGATGTGG$.\n\n输出规格：\n- 对于每个基因，输出一个实数，该数值等于通过一次同义密码子替换可实现的 CAI 最大增量（如果无法增加则为 $0$），四舍五入到小数点后六位。\n- 你的程序应产生单行输出，包含三个基因的结果，以逗号分隔的列表形式，并用方括号括起来，中间没有空格。例如，格式必须与 $[x_1,x_2,x_3]$ 完全一样，其中每个 $x_i$ 是一个小数点后有六位的小数。\n- 此计算不涉及物理单位。不要使用百分号；报告小数。\n\n注：\n- 你必须为有义密码子实现标准遗传密码映射。\n- 你的实现必须是通用的，能够处理任何使用所提供参考表的有效输入基因。", "solution": "该问题要求计算给定基因序列的密码子适应性指数 (CAI) 可通过单次同义密码子替换实现的最大可能增量。该问题具有科学依据，定义明确，并为确定性解提供了所有必要信息。\n\n首先，我们将给出的定义形式化。一个基因是由 $n$ 个密码子组成的序列，即 $(c_1, c_2, \\dots, c_n)$。对于编码氨基酸 $a$ 的每个密码子 $c$，其相对适应性权重 $w(c)$ 定义为：\n$$ w(c) = \\frac{f(c)}{\\max\\{f(c') : c' \\in \\mathcal{S}(a)\\}} $$\n其中 $\\mathcal{S}(a)$ 是氨基酸 $a$ 的同义密码子集合，$f(c)$ 是一个参考频率值。根据此定义，对于任何氨基酸，至少存在一个“最优”密码子 $c_{\\text{opt}}$，其 $w(c_{\\text{opt}}) = 1$。对于所有其他同义密码子 $c'$，$w(c') \\le 1$。对于只有一个密码子的氨基酸（甲硫氨酸，色氨酸），其权重定义为 $1$。\n\n该基因的密码子适应性指数 (CAI) 是这些权重的几何平均值：\n$$ \\text{CAI} = \\left( \\prod_{i=1}^{n} w(c_i) \\right)^{1/n} $$\n为了数值稳定性，最好使用对数进行计算：\n$$ \\ln(\\text{CAI}) = \\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i)) \\implies \\text{CAI} = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i))\\right) $$\n\n我们的目标是找到最大增量 $\\Delta\\text{CAI}_{\\max}$，该增量是通过在某个位置 $j \\in \\{1, \\dots, n\\}$ 将一个密码子 $c_j$ 更改为其同义密码子 $c_s \\in \\mathcal{S}(a_j)$ 而产生的，其中 $a_j$ 是由 $c_j$ 编码的氨基酸。\n\n令初始指数为 $\\text{CAI}_{\\text{initial}}$。如果我们将密码子 $c_j$ 替换为 $c_s$，则新指数 $\\text{CAI}_{\\text{new}}$ 由下式给出：\n$$ \\text{CAI}_{\\text{new}} = \\left( w(c_1) \\cdot \\dots \\cdot w(c_{j-1}) \\cdot w(c_s) \\cdot w(c_{j+1}) \\cdot \\dots \\cdot w(c_n) \\right)^{1/n} $$\n我们可以用初始 CAI 来表示它。权重的乘积改变了一个因子 $w(c_s)/w(c_j)$。\n$$ \\prod_{i=1, i \\ne j}^{n} w(c_i) \\cdot w(c_s) = \\left(\\prod_{i=1}^{n} w(c_i)\\right) \\cdot \\frac{w(c_s)}{w(c_j)} $$\n对两边取 $n$ 次方根，得到：\n$$ \\text{CAI}_{\\text{new}} = \\left(\\left(\\prod_{i=1}^{n} w(c_i)\\right) \\cdot \\frac{w(c_s)}{w(c_j)}\\right)^{1/n} = \\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n} \\cdot \\left(\\frac{w(c_s)}{w(c_j)}\\right)^{1/n} = \\text{CAI}_{\\text{initial}} \\cdot \\left(\\frac{w(c_s)}{w(c_j)}\\right)^{1/n} $$\nCAI 的增量为 $\\Delta\\text{CAI} = \\text{CAI}_{\\text{new}} - \\text{CAI}_{\\text{initial}} = \\text{CAI}_{\\text{initial}} \\left[ \\left(\\frac{w(c_s)}{w(c_j)}\\right)^{1/n} - 1 \\right]$。\n\n为了最大化此增量，我们必须最大化项 $\\left(w(c_s)/w(c_j)\\right)^{1/n}$。由于对于给定的基因，$n$ 是一个正常量，这等价于最大化比率 $w(c_s)/w(c_j)$。这必须在所有可能的位置 $j$ 和该位置上所有可能的同义替换 $c_s$ 中进行。\n\n让我们分析一下最大化逻辑。对于任何给定的位置 $j$，密码子 $c_j$ 及其权重 $w(c_j)$ 是固定的。我们希望选择一个能最大化 $w(c_s)$ 的同义密码子 $c_s$。如前所述，任何 $w(c)$ 的最大可能值为 $1$，这是由该氨基酸的最优密码子 $c_{\\text{opt}}$ 实现的。因此，对于任何位置 $j$，最佳的替换是将 $c_j$ 替换为 $c_{\\text{opt}}$，使得新权重 $w(c_s) = 1$。由此得到的比率为 $1/w(c_j)$。\n\n现在我们必须选择能给出整体最大增量的位置 $j$。这意味着我们必须找到能最大化比率 $1/w(c_j)$ 的位置 $j$。这等价于找到具有最小权重 $w(c_j)$ 的位置 $j$。\n\n令 $w_{\\min} = \\min_{i=1, \\dots, n} \\{w(c_i)\\}$。这个最小权重对应于序列中适应性最差的密码子。通过用其权重为 $1$ 的最优同义对应物替换该密码子，我们实现了单次替换所能达到的最大 CAI。\n\n因此，算法如下：\n1.  **预计算**：\n    a. 基于标准遗传密码，构建从 $61$ 个有义密码子到其对应氨基酸的映射。\n    b. 使用提供的 $f(c)$ 值表，为每个氨基酸 $a$ 找到最大频率值 $\\max\\{f(c') : c' \\in \\mathcal{S}(a)\\}$。\n    c. 计算并存储每个有义密码子的相对适应性权重 $w(c)$。\n\n2.  **逐个基因计算**：对于每个输入基因序列：\n    a. 将基因解析为其 $n$ 个密码子序列 $(c_1, \\dots, c_n)$。\n    b. 使用预计算的表创建相应的权重列表 $(w(c_1), \\dots, w(c_n))$。\n    c. 在此列表中找到最小权重 $w_{\\min}$。\n    d. 如果 $w_{\\min} \\ge 1.0$，则每个密码子都已是最优的或属于单密码子家族。没有同义替换可以增加 CAI。结果为 $0.0$。\n    e. 如果 $w_{\\min} < 1.0$，则可能存在增量。首先，计算基因的初始 CAI，即 $\\text{CAI}_{\\text{initial}}$。\n    f. 通过一次替换可实现的最大 CAI 为 $\\text{CAI}_{\\text{final}} = \\text{CAI}_{\\text{initial}} \\cdot (1/w_{\\min})^{1/n}$。\n    g. 最大增量为差值：$\\Delta\\text{CAI}_{\\max} = \\text{CAI}_{\\text{final}} - \\text{CAI}_{\\text{initial}}$。\n\n这个优化的算法避免了为每种可能的突变重新计算完整的 CAI，因此非常高效。它能识别出影响最大的单个替换并计算其效果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum CAI increase for a list of genes.\n    \"\"\"\n    # Define the reference codon usage table f(c)\n    f_table = {\n        'TTT': 0.3, 'TTC': 0.7, 'TTA': 0.05, 'TTG': 0.1, 'CTT': 0.1, 'CTC': 0.2, 'CTA': 0.05, 'CTG': 0.5,\n        'ATT': 0.35, 'ATC': 0.6, 'ATA': 0.05, 'ATG': 1.0, 'GTT': 0.2, 'GTC': 0.25, 'GTA': 0.05, 'GTG': 0.5,\n        'TCT': 0.15, 'TCC': 0.3, 'TCA': 0.04, 'TCG': 0.1, 'AGT': 0.06, 'AGC': 0.35, 'CCT': 0.2, 'CCC': 0.2,\n        'CCA': 0.1, 'CCG': 0.5, 'ACT': 0.2, 'ACC': 0.55, 'ACA': 0.1, 'ACG': 0.15, 'GCT': 0.2, 'GCC': 0.5,\n        'GCA': 0.1, 'GCG': 0.2, 'TAT': 0.3, 'TAC': 0.7, 'CAT': 0.3, 'CAC': 0.7, 'CAA': 0.3, 'CAG': 0.7,\n        'AAT': 0.3, 'AAC': 0.7, 'AAA': 0.4, 'AAG': 0.6, 'GAT': 0.4, 'GAC': 0.6, 'GAA': 0.6, 'GAG': 0.4,\n        'TGT': 0.35, 'TGC': 0.65, 'TGG': 1.0, 'CGT': 0.35, 'CGC': 0.4, 'CGA': 0.1, 'CGG': 0.1,\n        'AGA': 0.03, 'AGG': 0.02, 'GGT': 0.3, 'GGC': 0.45, 'GGA': 0.15, 'GGG': 0.1\n    }\n\n    # Standard genetic code for sense codons\n    genetic_code = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M', 'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'AGT': 'S', 'AGC': 'S', 'CCT': 'P', 'CCC': 'P',\n        'CCA': 'P', 'CCG': 'P', 'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'GCT': 'A', 'GCC': 'A',\n        'GCA': 'A', 'GCG': 'A', 'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K', 'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'TGT': 'C', 'TGC': 'C', 'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AGA': 'R', 'AGG': 'R', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    # Pre-computation step 1: Group codons by amino acid\n    synonymous_codons = {}\n    for codon, aa in genetic_code.items():\n        if aa not in synonymous_codons:\n            synonymous_codons[aa] = []\n        synonymous_codons[aa].append(codon)\n\n    # Pre-computation step 2: Find max f(c) for each amino acid\n    max_f_table = {}\n    for aa, codons in synonymous_codons.items():\n        max_f = 0.0\n        for codon in codons:\n            if codon in f_table:\n                max_f = max(max_f, f_table[codon])\n        max_f_table[aa] = max_f\n\n    # Pre-computation step 3: Calculate w(c) for all codons\n    w_table = {}\n    for codon, aa in genetic_code.items():\n        max_f = max_f_table[aa]\n        if max_f > 0:\n            w_table[codon] = f_table[codon] / max_f\n        else: # Should not happen for sense codons with f_table data\n            w_table[codon] = 1.0\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"ATGAGGATATTATCAGAAGGTGTTAAACAT\",\n        \"ATGCTGCGCAGCATCGTGCCGGCC\",\n        \"ATGTGGATGTGGATGTGG\",\n    ]\n\n    results = []\n    for gene_seq in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        n = len(gene_seq) // 3\n        if n == 0:\n            results.append(f\"{0.0:.6f}\")\n            continue\n            \n        codons = [gene_seq[i:i+3] for i in range(0, len(gene_seq), 3)]\n        \n        weights = [w_table[c] for c in codons]\n        w_min = min(weights)\n        \n        # If w_min is 1.0 or greater, no improvement is possible.\n        if w_min >= 1.0:\n            result = 0.0\n        else:\n            # Calculate initial CAI using numerically stable log-exp method\n            log_weights = np.log(weights)\n            log_cai_initial = np.mean(log_weights)\n            cai_initial = np.exp(log_cai_initial)\n\n            # Calculate the increase from the single best substitution\n            #\n            # CAI_final = CAI_initial * (1/w_min)^(1/n)\n            # Increase = CAI_final - CAI_initial = CAI_initial * ( (1/w_min)^(1/n) - 1 )\n            \n            increase = cai_initial * (np.power(1.0 / w_min, 1.0 / n) - 1.0)\n            result = increase\n            \n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2380006"}, {"introduction": "掌握了 CAI 的计算和优化之后，我们可以进一步探索其理论边界，从而加深理解。本练习鼓励你进行更抽象的思考：对于一个氨基酸序列固定的基因，其 CAI 的理论最大值和最小值是多少？通过推导这些边界，你将能够更清晰地认识到密码子的选择是如何决定最终 CAI 分数的，并巩固对该指数数学特性的理解。[@problem_id:2379978]", "problem": "在某个生物体中，一条编码序列仅使用有义密码子来编码一个蛋白质，其长度为 $L$ 个密码子。设氨基酸组成为 $\\{n_{a}\\}_{a \\in \\mathcal{A}}$，其中 $\\mathcal{A}$ 是存在的氨基酸集合，$n_{a}$ 是氨基酸 $a$ 在蛋白质中出现的次数，且 $\\sum_{a \\in \\mathcal{A}} n_{a} = L$。该生物体的参考密码子使用频率为编码氨基酸 $a$ 的每个有义密码子 $c$ 定义了一个相对适应性权重 $w_{c}$ ，由下式给出：\n$$\nw_{c} \\;=\\; \\frac{\\mathrm{RSCU}(c)}{\\max_{c' \\in S_{a}} \\mathrm{RSCU}(c')},\n$$\n其中 $S_{a}$ 是氨基酸 $a$ 的同义密码子集合，$\\mathrm{RSCU}$ 表示相对同义密码子使用度 (Relative Synonymous Codon Usage)。根据该定义，对于每个氨基酸 $a$，$0 < w_{c} \\leq 1$ 且 $\\max_{c \\in S_{a}} w_{c} = 1$。密码子序列为 $(c_{1},\\dots,c_{L})$ 的编码序列的密码子适应指数 (Codon Adaptation Index, CAI) 定义为其 $w$ 权重的几何平均值，\n$$\n\\mathrm{CAI} \\;=\\; \\left(\\prod_{i=1}^{L} w_{c_{i}}\\right)^{1/L}.\n$$\n假设除了翻译成指定的氨基酸组成 $\\{n_{a}\\}_{a \\in \\mathcal{A}}$ 外没有其他约束，请以闭合形式确定，在所有能翻译成该组成的所有可能编码序列中，$\\mathrm{CAI}$ 的理论最小值和最大值。使用 $L$、计数 $\\{n_{a}\\}$ 和权重 $\\{w_{c}\\}$ 来表示你的答案。提供精确表达式；无需四舍五入。将这两个值一起作为最终答案报告。", "solution": "所述问题具有科学依据、是良定的且客观的。它基于计算生物学的标准定义，并包含推导唯一解所需的所有必要信息。因此，该问题是有效的，我们可以着手解决它。\n\n目标是确定对于一个长度为 $L$ 个密码子、具有指定氨基酸组成 $\\{n_a\\}_{a \\in \\mathcal{A}}$ 的编码序列，其密码子适应指数 ($\\mathrm{CAI}$) 的理论最小值和最大值。$\\mathrm{CAI}$ 定义为其组成密码子的相对适应性权重 $w_c$ 的几何平均值：\n$$ \\mathrm{CAI} = \\left(\\prod_{i=1}^{L} w_{c_{i}}\\right)^{1/L} $$\n该序列必须编码一个蛋白质，其中每种氨基酸 $a \\in \\mathcal{A}$ 出现 $n_a$ 次，且 $\\sum_{a \\in \\mathcal{A}} n_a = L$。\n\n最大化或最小化 $\\mathrm{CAI}$ 等价于最大化或最小化权重的总乘积 $W = \\prod_{i=1}^{L} w_{c_{i}}$，因为函数 $f(x) = x^{1/L}$ 在 $x > 0$ 时是单调递增的。乘积 $W$ 可以通过根据密码子所编码的氨基酸进行分组来分解。对于每个氨基酸 $a \\in \\mathcal{A}$，序列中有 $n_a$ 个密码子必须从其同义密码子集合 $S_a$ 中选择。总乘积 $W$ 可以写成：\n$$ W = \\prod_{a \\in \\mathcal{A}} \\left( \\prod_{j=1}^{n_a} w_{c_{a,j}} \\right) $$\n其中 $c_{a,j}$ 是为氨基酸 $a$ 选择的第 $j$ 个密码子，且 $c_{a,j} \\in S_a$。\n\n对某一特定氨基酸 $a$ 的密码子的选择，独立于对任何其他氨基酸 $b \\neq a$ 的密码子的选择。因此，为了找到总乘积 $W$ 的最大值或最小值，我们可以独立地最大化或最小化来自每种氨基酸的贡献，我们将其记作 $W_a$：\n$$ W_a = \\prod_{j=1}^{n_a} w_{c_{a,j}} $$\n\n**最大 CAI**\n\n为了最大化总乘积 $W$，我们必须为所有 $a \\in \\mathcal{A}$ 最大化每一项 $W_a$。为了最大化 $W_a$，我们必须从集合 $S_a$ 中为氨基酸 $a$ 选择 $n_a$ 个密码子，使得它们的权重 $w_c$ 最大化。\n\n根据问题定义，对于任何氨基酸 $a$，其同义密码子的权重满足 $0 < w_c \\le 1$。此外，对于每个 $a$，存在至少一个密码子，我们称之为 $c_a^{\\text{opt}} \\in S_a$，其权重是最大的：\n$$ \\max_{c \\in S_a} w_c = 1 $$\n为了最大化 $W_a$，我们必须为氨基酸 $a$ 的 $n_a$ 次出现中的每一次都选择这个最优密码子 $c_a^{\\text{opt}}$。来自氨基酸 $a$ 对乘积的贡献则为：\n$$ W_{a, \\text{max}} = \\prod_{j=1}^{n_a} 1 = 1^{n_a} = 1 $$\n最大总乘积 $W_{\\text{max}}$ 是这些最大贡献在蛋白质中所有氨基酸上的乘积：\n$$ W_{\\text{max}} = \\prod_{a \\in \\mathcal{A}} W_{a, \\text{max}} = \\prod_{a \\in \\mathcal{A}} 1 = 1 $$\n因此，可能的最大 $\\mathrm{CAI}$ 为：\n$$ \\mathrm{CAI}_{\\text{max}} = (W_{\\text{max}})^{1/L} = (1)^{1/L} = 1 $$\n\n**最小 CAI**\n\n为了最小化总乘积 $W$，我们必须为所有 $a \\in \\mathcal{A}$ 最小化每一项 $W_a$。为了最小化 $W_a$，我们必须从集合 $S_a$ 中为氨基酸 $a$ 选择 $n_a$ 个密码子，使得它们的权重 $w_c$ 最小化。\n\n对于每个氨基酸 $a$，我们将其同义密码子中的最小权重定义为 $w_{a, \\text{min}}$：\n$$ w_{a, \\text{min}} = \\min_{c \\in S_a} w_c $$\n为了最小化 $W_a$，我们必须为氨基酸 $a$ 的所有 $n_a$ 次出现都选择对应于这个最小权重 $w_{a, \\text{min}}$ 的密码子。来自氨基酸 $a$ 对乘积的最小贡献为：\n$$ W_{a, \\text{min}} = \\prod_{j=1}^{n_a} w_{a, \\text{min}} = (w_{a, \\text{min}})^{n_a} $$\n对于只有一种密码子的氨基酸（例如，甲硫氨酸、色氨酸），集合 $S_a$ 只包含一个元素。对于这样的氨基酸，$\\min_{c \\in S_a} w_c = \\max_{c \\in S_a} w_c = 1$，所以它对最小乘积的贡献是 $1^{n_a}=1$，这是正确的，因为没有选择的余地。\n\n最小总乘积 $W_{\\text{min}}$ 是这些最小贡献在蛋白质中所有氨基酸上的乘积：\n$$ W_{\\text{min}} = \\prod_{a \\in \\mathcal{A}} W_{a, \\text{min}} = \\prod_{a \\in \\mathcal{A}} (w_{a, \\text{min}})^{n_a} = \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} $$\n因此，可能的最小 $\\mathrm{CAI}$ 为：\n$$ \\mathrm{CAI}_{\\text{min}} = (W_{\\text{min}})^{1/L} = \\left( \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} \\right)^{1/L} $$\n此表达式使用指定的参数以闭合形式提供了理论上的最小 $\\mathrm{CAI}$。\n\n总之，$\\mathrm{CAI}$ 的理论最小值和最大值是：\n-   $\\mathrm{CAI}_{\\text{min}} = \\left( \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} \\right)^{1/L}$\n-   $\\mathrm{CAI}_{\\text{max}} = 1$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left( \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} \\right)^{\\frac{1}{L}} & 1\n\\end{pmatrix}\n}\n$$", "id": "2379978"}]}