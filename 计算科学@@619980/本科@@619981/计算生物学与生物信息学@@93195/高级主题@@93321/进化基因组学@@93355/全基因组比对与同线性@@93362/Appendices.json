{"hands_on_practices": [{"introduction": "当我们在两个基因组之间发现一个相似区域时，我们如何判断这是一个有意义的发现还是仅仅是随机产生的巧合？本练习将指导你计算一个同线性区块的统计显著性。通过在一个简单的零假设模型下推导 $p$ 值，你将学习评估基因组比对结果背后的基本原则 [@problem_id:2440822]。", "problem": "在以下零假设模型下，生成两个长度均为 $N$ 个核苷酸的基因组：在每个位置上，每个基因组独立地从字母表 $\\{A, C, G, T\\}$ 中均匀随机抽取一个核苷酸。仅考虑正向方向（忽略反向互补和倒位）。对于任何一对起始索引 $(i, j)$，其中 $1 \\leq i \\leq N - L + 1$ 且 $1 \\leq j \\leq N - L + 1$，从每个基因组中各取一个长度为 $L$ 的连续子串，形成一个子串对，并计算它们的汉明距离（Hamming distance），汉明距离定义为核苷酸不同的位置数量。定义一个长度为 $L$ 的“同线性区块”（syntenic block）为任意一个这样的正向子串对。设 $k$ 为一个整数，满足 $0 \\leq k \\leq L$。\n\n在所述的零假设模型下，并额外假设与不同起始索引对 $(i, j)$ 相关联的事件是独立的，请推导一个封闭形式的解析表达式，用于计算在两个基因组之间的某处，观测到至少一个长度为 $L$ 且汉明距离至多为 $k$ 的同线性区块的概率值（p-value）。你的最终答案必须是一个仅包含 $N$、$L$ 和 $k$ 的单一表达式。不要代入数值。请将最终答案表示为一个封闭形式的解析表达式。无需单位。", "solution": "首先对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- 两个长度均为 $N$ 个核苷酸的基因组。\n- 零假设模型：在每个位置上，每个基因组独立地从字母表 $\\{A, C, G, T\\}$ 中均匀随机抽取一个核苷酸。\n- 仅考虑正向方向。\n- 从起始索引 $(i, j)$（其中 $1 \\leq i \\leq N - L + 1$ 且 $1 \\leq j \\leq N - L + 1$）形成一对长度为 $L$ 的连续子串。\n- 两个子串之间的汉明距离是核苷酸不同的位置数量。\n- 一个“同线性区块”是一对长度为 $L$ 的正向子串。\n- 给定一个整数 $k$，满足 $0 \\leq k \\leq L$。\n- 假设与不同起始索引对 $(i, j)$ 相关联的事件是独立的。\n- 目标是推导一个封闭形式的解析表达式，用于计算观测到至少一个长度为 $L$ 且汉明距离至多为 $k$ 的同线性区块的 p 值。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题是生物信息学和计算统计学中一个定义明确的标准练习。它在科学上基于序列比对和零假设模型下的统计显著性检验原理。该零假设模型虽然是对生物现实的简化，但其定义清晰且在数学上是可处理的。汉明距离、核苷酸均匀分布和 p 值的概念都是标准概念。问题陈述提供了所有必要的信息和定义。一个关键假设被明确陈述，即不同区块对的事件是独立的，虽然这对于重叠区块在生物学上不现实，但该假设使问题可解且内部一致。问题没有矛盾、歧义或事实错误。该问题是可形式化的，并且与其指定领域直接相关。\n\n**第 3 步：结论与行动**\n问题被认定为有效。将推导解答。\n\n问题要求计算观测到至少一个长度为 $L$ 且汉明距离至多为 $k$ 的同线性区块对的概率。这是一个经典的“至少一次成功”问题，最有效的解法是计算其互补事件的概率——即*不存在*这样的区块对——然后用 $1$ 减去这个概率。\n\n设 $P_{hit}$ 为单个随机选择的长度为 $L$ 的同线性区块对的汉明距离 $H \\leq k$ 的概率。设 $M$ 为两个基因组之间可以形成的所有此类区块对的总数。问题陈述说明每个区块对的事件是独立的。因此，所有 $M$ 个区块对都不满足该标准（即，所有的汉明距离 $H > k$）的概率是 $(1 - P_{hit})^M$。我们寻求的 p 值是至少有一次命中的概率，即：\n$$ p\\text{-value} = 1 - (1 - P_{hit})^M $$\n\n我们现在必须确定 $P_{hit}$ 和 $M$ 的表达式。\n\n首先，我们来确定 $M$，即同线性区块对的总数。第一个基因组的长度为 $N$。一个长度为 $L$ 的区块的可能起始位置是 $i=1, 2, \\dots, N-L+1$。这样的起始位置有 $N-L+1$ 个。同样，第二个基因组中长度为 $L$ 的区块的起始位置数量也是 $N-L+1$。由于第一个基因组的任何区块都可以与第二个基因组的任何区块配对，所以总的配对数量是：\n$$ M = (N-L+1) \\times (N-L+1) = (N-L+1)^2 $$\n这假设 $N \\geq L$，这是一个长度为 $L$ 的区块存在的必要条件。\n\n接下来，我们确定 $P_{hit}$。这是对于单个区块对，其汉明距离 $H$ 小于或等于 $k$ 的概率。汉明距离是错配的数量。我们可以用二项分布来对此建模。我们首先计算单个位置上发生错配的概率。\n\n字母表是 $\\Sigma = \\{A, C, G, T\\}$，所以其大小为 $|\\Sigma| = 4$。在零假设模型下，每个位置的每个核苷酸都是独立且均匀随机抽取的。任何特定核苷酸（例如 'A'）的概率是 $p_A = p_C = p_G = p_T = \\frac{1}{4}$。\n在给定位置上匹配的概率是两条序列具有相同核苷酸的概率。根据独立性：\n$$ P(\\text{match}) = \\sum_{n \\in \\Sigma} P(\\text{nuc}_1 = n \\text{ and } \\text{nuc}_2 = n) = \\sum_{n \\in \\Sigma} P(\\text{nuc}_1 = n) P(\\text{nuc}_2 = n) $$\n$$ P(\\text{match}) = 4 \\times \\left(\\frac{1}{4} \\times \\frac{1}{4}\\right) = 4 \\times \\frac{1}{16} = \\frac{1}{4} $$\n设 $p_m = P(\\text{match}) = \\frac{1}{4}$。因此，错配的概率 $p_{mm}$ 是：\n$$ p_{mm} = 1 - p_m = 1 - \\frac{1}{4} = \\frac{3}{4} $$\n一个区块对的长度为 $L$。这 $L$ 个位置中的每一个都可以被视为一次独立的伯努利试验，其中“成功”定义为一次错配。汉明距离 $H$ 是这 $L$ 次试验中错配的总数。因此，$H$ 服从参数为 $L$ 和 $p_{mm}$ 的二项分布：\n$$ H \\sim \\text{Binomial}(L, p_{mm}) $$\n观测到恰好 $d$ 次错配的概率由二项分布的概率质量函数给出：\n$$ P(H=d) = \\binom{L}{d} (p_{mm})^d (1-p_{mm})^{L-d} = \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} $$\n概率 $P_{hit}$ 是汉明距离至多为 $k$ 的概率，即累积概率 $P(H \\leq k)$。这可以通过对 $d=0, 1, \\dots, k$ 的概率求和得到：\n$$ P_{hit} = P(H \\leq k) = \\sum_{d=0}^{k} P(H=d) = \\sum_{d=0}^{k} \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} $$\n\n现在，我们将 $M$ 和 $P_{hit}$ 的表达式代回到我们最初的 p 值公式中。\n$$ p\\text{-value} = 1 - (1 - P_{hit})^M = 1 - \\left(1 - \\sum_{d=0}^{k} \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} \\right)^{(N-L+1)^2} $$\n这个表达式就是用给定参数 $N$、$L$ 和 $k$ 表示的封闭形式解。请注意，该求和是二项随机变量累积分布函数的标准表示，在此上下文中被认为是封闭形式。", "answer": "$$\n\\boxed{1 - \\left(1 - \\sum_{d=0}^{k} \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} \\right)^{(N-L+1)^2}}\n$$", "id": "2440822"}, {"introduction": "标准的比对算法假定序列是线性的，但许多基因组（如细菌基因组）是环状的。这个实践挑战你调整经典的全局比对方法，以正确比对环状基因组。你将发现一个任意的起始点会如何产生假象，以及如何通过系统性地探索所有可能的旋转来克服这个问题 [@problem_id:2440877]。", "problem": "给定两个代表环状细菌基因组的脱氧核糖核酸 (DNA) 序列。每个序列都是字母表 $\\Sigma=\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 上的有限字符串。一个环状基因组没有特定的起始位置，因此字符串的任何一种旋转都代表同一个环状分子。对于一个长度为 $|X|=n$ 的字符串 $X$，定义其旋转 $k$ 个位置为 $R_k(X)=X[k\\,..\\,n-1] \\,\\Vert\\, X[0\\,..\\,k-1]$，其中 $k$ 为满足 $0 \\le k < n$ 的任意整数，$\\Vert$ 表示拼接，索引使用基于0的半开区间。\n\n定义两个字符串 $U$ 和 $V$ 之间的全局比对得分 $F(U,V)$ 为在一种加性评分方案下的最优得分，该方案具有以下参数：一次匹配贡献 $+2$，一次错配贡献 $-1$，每个空位符贡献 $-2$（线性空位罚分）。比对必须消耗两个字符串的所有字符（全局比对）。形式上，令 $g=-2$ 为空位得分，并令\n$$\ns(a,b)=\n\\begin{cases}\n+2 & \\text{若 } a=b,\\\\\n-1 & \\text{若 } a\\ne b.\n\\end{cases}\n$$\n那么，$F(U,V)$ 是在 $U$ 和 $V$ 的所有全局比对中，比对上的字母对的 $s(\\cdot,\\cdot)$ 得分之和，再加上每个空位符的 $g$ 得分，这个总和的最大值。\n\n为避免任意线性化起点产生的人为影响，定义环状全局比对得分为\n$$\nC(X,Y)=\\max_{0 \\le k < |X|} F\\big(R_k(X),\\,Y\\big),\n$$\n该得分通过对 $X$ 的所有旋转进行优化，同时对 $Y$ 进行线性比对。假设 $|X|\\ge 1$ 且 $|Y|\\ge 1$。\n\n你的任务是编写一个程序，为下面的每个测试用例，根据上述评分方案计算整数 $C(X,Y)$。不考虑任何其他解释（例如反向互补方向）；只允许正向的旋转。\n\n测试集（每个测试用例是一个有序对 $(X,Y)$）：\n- 测试 $1$：$X=\\text{\"ATGC\"}$, $Y=\\text{\"GCAT\"}$。\n- 测试 $2$：$X=\\text{\"AAAAC\"}$, $Y=\\text{\"AAAA\"}$。\n- 测试 $3$：$X=\\text{\"TTTTCCCC\"}$, $Y=\\text{\"CCCCTTTT\"}$。\n- 测试 $4$：$X=\\text{\"AAAA\"}$, $Y=\\text{\"TTTT\"}$。\n- 测试 $5$：$X=\\text{\"G\"}$, $Y=\\text{\"GG\"}$。\n\n最终输出格式：你的程序应生成单行输出，其中按顺序包含测试1到5的结果，格式为用方括号括起来的逗号分隔列表，例如 $[\\text{结果}_1,\\text{结果}_2,\\text{结果}_3,\\text{结果}_4,\\text{结果}_5]$。每个 $\\text{结果}_i$ 必须是一个整数。", "solution": "所述问题是有效的。它在科学上基于生物信息学的既定原则，特别是全局序列比对。此外，该问题陈述清晰，所有必要的参数和定义都已明确给出。不存在逻辑矛盾、事实错误或主观因素。任务是计算环状全局比对得分，这是标准全局比对问题的一个直接扩展，尽管计算量较大。\n\n该问题要求计算环状全局比对得分 $C(X,Y)$，其定义为 $C(X,Y)=\\max_{0 \\le k < |X|} F\\big(R_k(X),\\,Y\\big)$。该计算由两个主要部分组成：首先，计算两个线性序列 $U$ 和 $V$ 之间的全局比对得分 $F(U,V)$；其次，在序列 $X$ 的所有可能旋转中，将该得分最大化。\n\n全局比对得分 $F(U,V)$ 使用 Needleman-Wunsch 算法确定，这是一种动态规划方法。设两个序列分别为长度为 $m$ 的 $U$ 和长度为 $n$ 的 $V$。我们构建一个大小为 $(m+1) \\times (n+1)$ 的动态规划矩阵 $M$。矩阵项 $M_{i,j}$ 存储前缀 $U[0..i-1]$ 和 $V[0..j-1]$ 的最优比对得分。\n\n评分参数已给出：匹配得分 $s_{\\text{match}} = +2$，错配得分 $s_{\\text{mismatch}} = -1$，以及每个空位符的线性空位罚分 $g = -2$。比对两个字符 $a$ 和 $b$ 的得分表示为 $s(a,b)$。\n\n矩阵 $M$ 的填充方式如下：\n\n1.  **初始化**：初始化第一行和第一列，以表示前缀与空位的比对。\n    $$M_{0,0} = 0$$\n    $$M_{i,0} = i \\cdot g \\quad \\text{对于 } 1 \\le i \\le m$$\n    $$M_{0,j} = j \\cdot g \\quad \\text{对于 } 1 \\le j \\le n$$\n\n2.  **递推关系**：对于从 $1$ 到 $m$ 的 $i$ 和从 $1$ 到 $n$ 的 $j$，通过取以下三种可能性的最大值来计算 $M_{i,j}$ 的值：\n    -   比对字符 $U[i-1]$ 和 $V[j-1]$：得分为 $M_{i-1,j-1} + s(U[i-1], V[j-1])$。\n    -   将 $U[i-1]$ 与一个空位对齐：得分为 $M_{i-1,j} + g$。\n    -   将 $V[j-1]$ 与一个空位对齐：得分为 $M_{i,j-1} + g$。\n\n    形式上，递推关系为：\n    $$M_{i,j} = \\max \\begin{cases} M_{i-1,j-1} + s(U[i-1], V[j-1]) \\\\ M_{i-1,j} + g \\\\ M_{i,j-1} + g \\end{cases}$$\n\n全局比对得分 $F(U,V)$ 是矩阵右下角的值 $M_{m,n}$。\n\n为了找到环状全局比对得分 $C(X,Y)$，我们必须对 $X$ 的每一次旋转都执行此计算。设 $|X| = n_x$。$X$ 旋转 $k$ 个位置（其中 $0 \\le k < n_x$）得到的字符串是 $R_k(X) = X[k\\,..\\,n_x-1] \\Vert X[0\\,..\\,k-1]$。我们为每个 $k$ 计算全局比对得分 $F(R_k(X), Y)$。最终得分 $C(X,Y)$ 是从这组得分中获得的最大值。\n\n$$C(X,Y) = \\max \\left\\{ F(R_0(X), Y), F(R_1(X), Y), \\dots, F(R_{n_x-1}(X), Y) \\right\\}$$\n\n以测试1为例：$X=\\text{\"ATGC\"}$，$Y=\\text{\"GCAT\"}$。此处， $|X|=4$。我们必须检查4次旋转。\n-   当 $k=0$ 时，$R_0(X) = \\text{\"ATGC\"}$。我们计算 $F(\\text{\"ATGC\"}, \\text{\"GCAT\"})$。由于没有字符在相同位置上匹配，该比对的得分会很低。\n-   当 $k=1$ 时，$R_1(X) = \\text{\"TGCA\"}$。我们计算 $F(\\text{\"TGCA\"}, \\text{\"GCAT\"})$。这同样会得到一个低分。\n-   当 $k=2$ 时，$R_2(X) = \\text{\"GCAT\"}$。我们计算 $F(\\text{\"GCAT\"}, \\text{\"GCAT\"})$。这是一个完美匹配。比对如下：\n    ```\n    GCAT\n    GCAT\n    ```\n    得分为4次匹配的总和：$4 \\times (+2) = 8$。\n-   当 $k=3$ 时，$R_3(X) = \\text{\"CATG\"}$。我们计算 $F(\\text{\"CATG\"}, \\text{\"GCAT\"})$，同样得到一个低分。\n\n在所有旋转中找到的最高分是 $8$。因此，$C(\\text{\"ATGC\"}, \\text{\"GCAT\"}) = 8$。\n\n将此过程系统地应用于所有提供的测试用例，以推导出它们各自的解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef global_alignment_score(seq1: str, seq2: str, match_score: int, mismatch_score: int, gap_score: int) -> int:\n    \"\"\"\n    Computes the global alignment score of two sequences using the Needleman-Wunsch algorithm.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n        match_score: The score for a match.\n        mismatch_score: The score for a mismatch.\n        gap_score: The score for a gap (linear).\n\n    Returns:\n        The optimal global alignment score as an integer.\n    \"\"\"\n    m = len(seq1)\n    n = len(seq2)\n\n    # Initialize the dynamic programming table\n    dp_table = np.zeros((m + 1, n + 1), dtype=int)\n\n    # Initialize the first row and column\n    for i in range(1, m + 1):\n        dp_table[i, 0] = i * gap_score\n    for j in range(1, n + 1):\n        dp_table[0, j] = j * gap_score\n\n    # Fill the rest of the table using the recurrence relation\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Score for aligning seq1[i-1] and seq2[j-1]\n            if seq1[i-1] == seq2[j-1]:\n                match_mismatch = match_score\n            else:\n                match_mismatch = mismatch_score\n            \n            score_diag = dp_table[i-1, j-1] + match_mismatch\n            score_up = dp_table[i-1, j] + gap_score\n            score_left = dp_table[i, j-1] + gap_score\n            \n            dp_table[i, j] = max(score_diag, score_up, score_left)\n\n    return dp_table[m, n]\n\ndef solve():\n    \"\"\"\n    Solves the circular-global alignment problem for a suite of test cases.\n    \"\"\"\n    # Define the scoring scheme from the problem statement.\n    MATCH = 2\n    MISMATCH = -1\n    GAP = -2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"ATGC\", \"GCAT\"),        # Test 1\n        (\"AAAAC\", \"AAAA\"),       # Test 2\n        (\"TTTTCCCC\", \"CCCCTTTT\"),# Test 3\n        (\"AAAA\", \"TTTT\"),        # Test 4\n        (\"G\", \"GG\"),             # Test 5\n    ]\n\n    results = []\n    for x_seq, y_seq in test_cases:\n        len_x = len(x_seq)\n        \n        # Problem statement guarantees |X| >= 1\n        if len_x == 0:\n            # This case is not expected based on problem constraints but is handled for robustness.\n            score = len(y_seq) * GAP\n            results.append(score)\n            continue\n            \n        max_score = -float('inf')\n\n        # Iterate through all rotations of the circular genome X\n        for k in range(len_x):\n            rotated_x = x_seq[k:] + x_seq[:k]\n            \n            # Compute global alignment score for the current rotation against Y\n            current_score = global_alignment_score(rotated_x, y_seq, MATCH, MISMATCH, GAP)\n            \n            # Update the maximum score\n            if current_score > max_score:\n                max_score = current_score\n        \n        results.append(int(max_score))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440877"}, {"introduction": "真实的基因组学研究很少像比较两个单倍体序列那样简单。这个问题提出了一个现实场景：将一个单倍体病原体的基因组与其二倍体植物宿主的基因组进行比对。你需要从战略上思考如何处理杂合性、重复元件，并区分等位基因拷贝和真正的基因重复，从而从执行单个算法提升到设计一个稳健的生物信息学分析流程 [@problem_id:2440880]。", "problem": "给定一个高质量的单倍体真菌病原体基因组组装，其总大小为 $S_{\\mathrm{fungus}} = 42\\,\\text{Mb}$，以及其植物宿主的一个高质量基因组组装。该植物组装代表一个二倍体 ($2n$) 个体，由两套重叠群（contig）组成：一套主单倍型集 $P_1$ 和一套备用单倍型集 $P_2$，每套都几乎覆盖了整个基因组。该植物基因组的估计杂合度 $h \\approx 1.0\\%$，散在重复序列含量 $r \\approx 55\\%$，片段重复占组装长度的比例不到 $5\\%$。您的任务是构建真菌和植物之间的全基因组范围的同线性区块，这些区块将用于量化基因顺序的保守性，并识别谱系特异性的重复和重排。具体来说，交付成果必须 (i) 避免将 $P_1$ 和 $P_2$ 中的等位基因拷贝计为旁系同源重复，(ii) 对重复序列具有稳健性，以及 (iii) 在单倍体和二倍体基因组之间适当时提供 $1$-to-$1$ 的共线性锚点。\n\n以下哪种策略在所述约束条件下最适合构建这些同线性区块？\n\nA. 对植物基因组中的转座子和简单重复序列进行软屏蔽或硬屏蔽，使用能够容忍大约 $h$ 的分歧度的参数，将真菌组装分别与 $P_1$ 和 $P_2$ 进行全基因组比对，在每个单倍型上计算局部比对的共线性链，然后，对于每个真菌位点 $x$，在 $\\{P_1,P_2\\}$ 中（使用互惠最佳或得分优势标准）选择单个得分最高的链来合并等位基因匹配；最后，从保留的链中构建 $1$-to-$1$ 的同线性区块，并将剩余的 $1$-to-$k$（$k \\ge 2$）映射视为候选的旁系同源重复。\n\nB. 将 $P_1$ 和 $P_2$ 合并成一个单一的嵌合共有序列（例如，通过对齐的重叠群进行多数投票）以减少冗余，将真菌基因组与这个合并后的植物参考序列比对一次，并将真菌位点在植物内的任何次要比对解释为旁系同源。\n\nC. 使用短读长比对工具将真菌的短读长序列映射到二倍体植物组装上，鉴定单核苷酸多态性（SNPs），并通过将两个物种间SNP密度低的長區間鉴定为同线性区，将SNP密度高的区间鉴定为重排区，来推断同线性关系。\n\nD. 在计算机中复制真菌基因组以创建一个大小为 $2 \\times S_{\\mathrm{fungus}}$ 的伪二倍体参考序列，仅将此复制的真菌参考序列与主单倍型 $P_1$ 进行比对，并将与每个植物位点最佳比对的两个真菌拷贝解释为代表两个植物单倍型；使用这些比对来定义同线性。\n\nE. 将分析仅限于预测的编码序列：将真菌蛋白质组与植物蛋白质组进行比对，通过互惠最佳匹配定义直系同源基因，并仅根据直系同源基因的顺序推断同线性，忽略非编码区、基因间区以及基因组坐标上的共线性约束。", "solution": "目标是根据全基因组比对和二倍体条件下同线性分析的基本原理，推导出一个策略。同线性（Synteny）被定义为基因组之间基因顺序的保守性或直系同源位点的共线性（collinearity）。在单倍体和二倍体组装之间进行全基因组比对会引入一个典型的复杂问题：对于二倍体植物中的每个真正的直系同源位点，可能存在两个等位基因拷贝，一个在单倍型 $P_1$ 上，一个在单倍型 $P_2$ 上，它们的序列差异约为杂合率 $h \\approx 1.0\\%$。如果我们将一个单倍体查询序列与两个单倍型进行比对，每个真菌位点 $x$ 可能会产生两个高质量的比对，分别与 $P_1$ 的一致性为 $I_1(x)$，与 $P_2$ 的一致性为 $I_2(x)$。这些匹配是等位基因的，而不是旁系同源的。一个有原则的同线性构建方法必须 (i) 防止重复序列产生虚假的局部比对和链，通常通过屏蔽重复序列或使用能识别重复序列的种子匹配（repeat-aware seeding）来实现；(ii) 允许序列分歧达到大约 $h$，以便两个等位基因都能被比对上；(iii) 在构建 $1$-to-$1$ 的同线性区块之前，通过为每个真菌位点选择至多一个植物单倍型靶标来合并等位基因冗余。\n\n形式上，设 $\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 分别为在重复序列屏蔽后，真菌基因组与 $P_1$ 和 $P_2$ 之间的局部比对集合。设 $\\mathcal{C}_1$ 和 $\\mathcal{C}_2$ 是通过对一致的局部比对集合进行加性得分 $S = \\sum_{i} w_i$ 最大化而在每个单倍型上计算出的共线性链，其中权重 $w_i$ 由匹配长度和一致性导出。对于每个真菌位点 $x$，将跨单倍型的最佳链定义为 $C^\\ast(x) = \\arg\\max\\{S(C) : C \\in \\mathcal{C}_1 \\cup \\mathcal{C}_2 \\text{ covering } x\\}$。仅保留 $C^\\ast(x)$，将两个等位基因靶标合并为一个代表性映射，并可选择性地强制执行互惠性，以确保所选的植物区间不会被另一个不同的真菌位点更好地解释。在这次合并之后，可以对链进行筛选以移除重叠部分，并将其转换为 $1$-to-$1$ 的同线性区块。在跨单倍型合并后，任何仍然具有 $1$-to-$k$（$k \\ge 2$）映射的真菌位点，都是因真实重复而非等位性所导致的候选旁系同源基因。\n\n在此框架下，我们可以评估各个选项：\n\nA. 此选项明确地包含了三个必要原则。首先，它通过屏蔽转座子来控制由重复序列驱动的噪声，这在重复序列含量 $r \\approx 55\\%$ 时至关重要。其次，它分别对 $P_1$ 和 $P_2$ 进行全基因组比对，参数容忍度约为 $h \\approx 1.0\\%$ 的分歧，确保两个等位基因都能匹配。第三，它通过在各单倍型之间为每个真菌位点选择一个得分最高的链 $C^\\ast(x)$ 来合并等位基因冗余，并使用互惠最佳或优势标准，以避免将 $P_1$ 和 $P_2$ 中的等位基因拷贝重复计算。最后，它从保留的链中构建 $1$-to-$1$ 的同线性区块，并将剩余的 $1$-to-$k$（$k \\ge 2$）映射标记为候选的旁系同源。这直接满足了(i)、(ii)和(iii)的要求，是合适的策略。结论 — 正确。\n\nB. 通过多数投票将 $P_1$ 和 $P_2$ 合并成一个单一的嵌合共有序列，会破坏单倍型特异性的连锁相位，并产生可引入人为断点和错配的嵌合序列。与这样的嵌合序列进行比对，可能将分歧的等位基因合并到单个轨迹上，并导致对真菌的次要比对被误解为旁系同源，这违反了避免将等位基因计为旁系同源的要求。它还有可能掩盖结构性杂合。结论 — 错误。\n\nC. 将真菌短读长序列映射到植物基因组，并使用单核苷酸多态性（SNP）密度来定义同线性，会混淆物种内变异（植物内部的杂合性）与物种间分歧。物种间的SNP密度并不是共线性的一个有原则的代理指标，并且对于基因组结构不同的物种，短读长映射不能作为全基因组比对的合适替代品。这种方法不会产生 $1$-to-$1$ 的共线性锚点，并且忽略了等位基因合并的要求。结论 — 错误。\n\nD. 在计算机中复制真菌基因组并不能模拟植物的等位性。仅将复制的真菌参考序列与 $P_1$ 比对，无法捕捉 $P_2$ 上的等位基因变异。此外，将与单个植物位点比对的两个真菌拷贝解释为代表植物单倍型，颠倒了真实的生物学关系，并将查询序列中的重复与目标序列中的等位性混为一谈。这种方法未能解决重复序列问题，也无法产生一个有效的 $1$-to-$1$ 同线性框架。结论 — 错误。\n\nE. 仅限于编码序列和互惠最佳蛋白质匹配可以找到直系同源基因，但丢弃了非编码区和基因间区的共线性，而这对稳健的同线性分析很重要，并且这种方法对注释质量和基因移动高度敏感。它也没有明确解决跨 $P_1$ 和 $P_2$ 的等位基因合并问题。因此，它无法满足在全基因组范围内产生 $1$-to-$1$ 共线性锚点，以及在重复序列背景下稳健地区分等位性与旁系同源性的要求。结论 — 错误。\n\n因此，在所述约束条件下，最合适的策略是选项A中所描述的，即具备单倍型识别、重复序列控制和跨单倍型等位基因合并能力的全基因组比对方法。", "answer": "$$\\boxed{A}$$", "id": "2440880"}]}