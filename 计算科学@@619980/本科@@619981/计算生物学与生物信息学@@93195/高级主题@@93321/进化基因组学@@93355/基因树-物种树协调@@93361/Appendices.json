{"hands_on_practices": [{"introduction": "基因树与物种树的调和分析遵循简约性原则，旨在以最少的演化事件来解释观察到的演化历史。第一个练习为此提供了坚实的基础，将调和过程简化为其核心：计算基因重复和丢失事件。通过求解解释给定基因拷贝数所需的最小事件数，您将亲身体验到更复杂调和算法背后的基本计算原理。[@problem_id:2394119]", "problem": "考虑一个基因家族沿着一个有根二叉物种树 $\\left(A,B\\right)$ 演化，其中 $A$ 和 $B$ 是仅有的现存物种。假设该基因家族在标准的复制-丢失（DL）模型下演化，并满足以下条件：(i) 一次基因复制事件使其所在谱系的拷贝数增加 $1$，(ii) 一次基因丢失事件使其所在谱系移除一个拷贝，(iii) 不存在水平基因转移和不完全谱系分选，并且 (iv) 该家族在 $A$ 和 $B$ 的最近共同祖先中以单个拷贝的形式存在。您观察到一个基因树，其叶节点通过序列标签映射到物种：三个叶节点来自物种 $A$，一个叶节点来自物种 $B$（即，在 $A$ 中有 $3$ 个现存拷贝，在 $B$ 中有 $1$ 个现存拷贝）。该基因树的内部拓扑结构未指定。在所有与这些观察结果和DL模型一致的协调方案中，确定解释所观察到的现存拷贝数所需的最小基因复制事件数 $d$ 和最小基因丢失事件数 $\\ell$。以两个整数 $d$ 和 $\\ell$ 的形式报告您的答案。无需四舍五入。", "solution": "所述问题定义明确，并基于计算生物学的标准原理。我们可以进行形式化的求解。\n\n设 $S$ 为有根二叉物种树。$S$ 的叶节点是现存物种 $A$ 和 $B$。设 $R$ 表示 $S$ 的根，即 $A$ 和 $B$ 的最近共同祖先（LCA）。因此，该物种树的结构由根 $R$ 及从其分出的两个分支指定，一个分支通向叶节点 $A$，另一个通向叶节点 $B$。\n\n我们已知此基因家族在现存物种中的拷贝数：$c(A) = 3$ 和 $c(B) = 1$。该基因家族的演化遵循复制-丢失（DL）模型，没有水平基因转移。问题陈述该基因家族“在 $A$ 和 $B$ 的最近共同祖先中以单个拷贝的形式存在”。这为拷贝数的演化设定了根部条件。一个关键步骤是通过考虑在节点 $R$ 发生物种形成时存在的基因拷贝数，来确定最简约的情景。\n\n设 $k$ 为在物种形成事件发生前，祖先物种 $R$ 中存在的基因拷贝数。单个祖先基因的初始条件意味着，从一个拷贝的初始状态（在 $R$ 的某个祖先处）达到 $k$ 个拷贝，在通向 $R$ 的分支上至少需要 $\\max(0, k-1)$ 次复制事件和 $\\max(0, 1-k)$ 次丢失事件。由于我们寻求最小事件数，我们可以假设 $k \\ge 1$，因此达到 $k$ 个拷贝的代价是 $k-1$ 次复制。\n\n在节点 $R$ 的物种形成事件中，所有 $k$ 个基因拷贝都被传递给两个子谱系。因此，通向物种 $A$ 的谱系以 $k$ 个拷贝开始，通向物种 $B$ 的谱系也以 $k$ 个拷贝开始。\n\n现在我们分析每个分支上为匹配叶节点处观察到的拷贝数所需的事件数量。在单个谱系上，将拷贝数从起始值 $c_{start}$ 变为结束值 $c_{end}$ 所需的最小事件数为 $|c_{end} - c_{start}|$。这包括 $\\max(0, c_{end} - c_{start})$ 次复制和 $\\max(0, c_{start} - c_{end})$ 次丢失。\n\n对于通向 $A$ 的谱系：\n拷贝数从 $k$ 变为 $c(A) = 3$。\n复制次数为 $d_A(k) = \\max(0, 3-k)$。\n丢失次数为 $\\ell_A(k) = \\max(0, k-3)$。\n\n对于通向 $B$ 的谱系：\n拷贝数从 $k$ 变为 $c(B) = 1$。\n复制次数为 $d_B(k) = \\max(0, 1-k)$。\n丢失次数为 $\\ell_B(k) = \\max(0, k-1)$。\n\n对于在物种形成时给定的拷贝数 $k$，总的复制次数 $d(k)$ 和丢失次数 $\\ell(k)$ 是根分支上和子分支上事件的总和：\n$$d(k) = (k-1) + d_A(k) + d_B(k) = (k-1) + \\max(0, 3-k) + \\max(0, 1-k)$$\n$$\\ell(k) = \\ell_A(k) + \\ell_B(k) = \\max(0, k-3) + \\max(0, k-1)$$\n这里假设 $k \\ge 1$。\n\n我们必须找到使总事件数 $d(k) + \\ell(k)$ 最小化的 $k$ 值。让我们对 $k \\ge 1$ 的小整数值进行评估：\n\n情况 $k=1$：\n$d(1) = (1-1) + \\max(0, 3-1) + \\max(0, 1-1) = 0 + 2 + 0 = 2$。\n$\\ell(1) = \\max(0, 1-3) + \\max(0, 1-1) = 0 + 0 = 0$。\n总事件数为 $d(1) + \\ell(1) = 2$。\n\n情况 $k=2$：\n$d(2) = (2-1) + \\max(0, 3-2) + \\max(0, 1-2) = 1 + 1 + 0 = 2$。\n$\\ell(2) = \\max(0, 2-3) + \\max(0, 2-1) = 0 + 1 = 1$。\n总事件数为 $d(2) + \\ell(2) = 3$。\n\n情况 $k=3$：\n$d(3) = (3-1) + \\max(0, 3-3) + \\max(0, 1-3) = 2 + 0 + 0 = 2$。\n$\\ell(3) = \\max(0, 3-3) + \\max(0, 3-1) = 0 + 2 = 2$。\n总事件数为 $d(3) + \\ell(3) = 4$。\n\n对于 $k > 3$：\n$d(k) = (k-1) + 0 + 0 = k-1$。\n$\\ell(k) = (k-3) + (k-1) = 2k-4$。\n总事件数 $d(k) + \\ell(k) = 3k-5$，这是一个关于 $k$ 的增函数。\n\n比较总事件数，最小值在 $k=1$ 时取得，总共为 $2$ 个事件。这个最简约的情景对应于在物种形成节点 $R$ 处恰好有一个基因拷贝，这与对问题陈述最直接的解释是一致的。\n\n对于这个最优情景（$k=1$），所需的复制和丢失次数为：\n最小复制次数 $d = d(1) = 2$。\n最小丢失次数 $\\ell = \\ell(1) = 0$。\n\n这个结果对应于以下演化历史：根节点 $R$ 处的单个基因拷贝被传递给 $A$ 和 $B$ 的谱系。在通向 $B$ 的谱系中，没有事件发生。在通向 $A$ 的谱系中，发生了两次复制事件，使拷贝数从 $1$ 增加到 $3$。", "answer": "$$\\boxed{\\begin{pmatrix} 2 & 0 \\end{pmatrix}}$$", "id": "2394119"}, {"introduction": "虽然基因重复和丢失解释了大部分基因家族的演化，但生命之树的形态也受到物种间基因直接转移的影响。这个思想实验探讨了包含水平基因转移（Horizontal Gene Transfer, HGT）的调和算法如何解释一个特定的复杂情景。通过追溯一个转移基因的历史，您将学会区分不同类型的同源关系，例如直系同源（orthology）和异源同源（xenology），这对于准确的演化推断至关重要。[@problem_id:2405916]", "problem": "一个水平基因转移 (HGT) 事件在时间 $t_0$ 将一个基因从供体谱系 $\\mathcal{D}$ 转移到受体谱系 $\\mathcal{R}$。紧接着 (在时间 $t_0 + \\varepsilon$)，物种 $\\mathcal{R}$ 经历一次物种形成，产生了两个后代物种 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$。假设在 HGT 之前，受体谱系 $\\mathcal{R}$ 没有该基因的同源基因，并且在 HGT 和物种形成事件之后，没有发生额外的基因重复或基因丢失。因此，现今的样本包括一个来自 $\\mathcal{D}$ 的基因拷贝（在 $\\mathcal{D}$ 内部垂直遗传）以及在 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 中各一个的基因拷贝（从转移的拷贝遗传而来）。应用一个允许基因重复、转移和丢失 (DTL) 的模型进行基因树-物种树调和。\n\n哪种解释最能描述调和算法如何围绕这些事件将基因树映射到物种树，以及它如何对三个采样基因拷贝之间的两两关系进行分类？\n\nA. 该算法将在 $\\mathcal{R}$ 物种形成之前解释为 $\\mathcal{R}$ 内部的一次基因重复，随后垂直遗传到 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 中；它将 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的拷贝分类为种内旁系同源基因，并将两者都视为 $\\mathcal{D}$ 拷贝的直系同源基因。\n\nB. 该算法解释为一次从 $\\mathcal{D}$ 到 $\\mathcal{R}$ 的转移，随后 $\\mathcal{R}$ 发生物种形成事件，将转移的谱系垂直地分裂到 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 中；它将 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的拷贝分类为互为直系同源基因，并将每个都分类为 $\\mathcal{D}$ 拷贝的异源同源基因。\n\nC. 该算法解释为不完全谱系分选，没有重复、转移或丢失；它将所有三个拷贝（$\\mathcal{D}$, $\\mathcal{R}_1$, $\\mathcal{R}_2$）分类为相互的直系同源基因。\n\nD. 该算法解释为 $\\mathcal{D}$ 中的一次物种形成被 $\\mathcal{R}$ 中的一次重复所镜像，随后发生协同进化；它将 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的拷贝分类为互为异源同源基因，并将两者都视为 $\\mathcal{D}$ 拷贝的直系同源基因。", "solution": "在进行解答之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 事件1：一次水平基因转移 (HGT) 将一个基因从供体谱系 $\\mathcal{D}$ 转移到受体谱系 $\\mathcal{R}$。\n- HGT时间：$t_0$。\n- 事件2：物种 $\\mathcal{R}$ 发生物种形成，产生后代物种 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$。\n- 物种形成时间：$t_0 + \\varepsilon$，其中 $\\varepsilon$ 是一个无穷小的正时长。\n- 初始条件：在时间 $t_0$ 的 HGT 之前，谱系 $\\mathcal{R}$ 没有该基因的同源基因。\n- 约束条件：在这些事件之后，没有发生额外的基因重复或基因丢失。\n- 采样数据：一个来自 $\\mathcal{D}$ 的基因拷贝，一个来自 $\\mathcal{R}_1$，一个来自 $\\mathcal{R}_2$。\n- 分析方法：在重复、转移、丢失 (DTL) 模型下进行基因树-物种树调和。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在计算生物学和系统基因组学中有充分的理论基础。它描述了一个涉及水平基因转移 (HGT) 和物种形成的经典进化场景，并要求通过标准的 DTL 调和算法对其进行解释。直系同源、旁系同源、异源同源和 DTL 模型的概念是该领域的基础。\n- **适定性**：该问题是适定的。它提供了一个清晰、明确的“基准真相”进化历史，并要求一个标准算法模型（DTL 调和）给出确定性输出。约束条件（之前无同源基因，之后无事件）确保了唯一的解释。\n- **客观性**：语言技术性强、精确且客观。\n\n**步骤3：结论与行动**\n问题陈述被认定为有效。它在科学上是合理的、自洽的且适定的。将推导解决方案。\n\n**推导**\n\n重复-转移-丢失 (DTL) 调和模型旨在通过假设最少数量的基因重复、水平基因转移和基因丢失事件来解释基因树和物种树之间的不一致性。让我们追溯三个采样基因拷贝的历史——分别设它们为来自物种 $\\mathcal{D}$, $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的 $g_{\\mathcal{D}}$, $g_{\\mathcal{R}_1}$ 和 $g_{\\mathcal{R}_2}$。\n\n$1$. **HGT 事件**：问题明确指出，在时间 $t_0$，一个基因从谱系 $\\mathcal{D}$ 转移到谱系 $\\mathcal{R}$。在 DTL 调和中，此事件被识别为一次水平转移，因为基因树将显示 $g_{\\mathcal{R}_1}$ 和 $g_{\\mathcal{R}_2}$ 的祖先从 $\\mathcal{D}$ 谱系内部发出分支，这是一种与物种树不一致的拓扑结构，除非援引一次转移事件。\n\n$2$. **物种形成事件**：转移之后，在时间 $t_0 + \\varepsilon$，受体物种 $\\mathcal{R}$ 物种形成，产生 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$。$\\mathcal{R}$ 新获得的基因通过垂直遗传传递给两个后代物种。因此，导致 $g_{\\mathcal{R}_1}$ 和 $g_{\\mathcal{R}_2}$ 的基因谱系之间的分化是由其宿主生物的物种形成引起的。\n\n$3$. **同源关系的分类**：任意两个同源基因之间的关系分类取决于其祖先拷贝的最近共同进化事件。\n- **直系同源基因 (Orthologs)**：存在于不同物种中的基因，它们起源于这些物种最近共同祖先中的单个祖先基因。它们的分化是物种形成事件的结果。在我们的案例中，$g_{\\mathcal{R}_1}$ 和 $g_{\\mathcal{R}_2}$ 的最近共同祖先存在于物种 $\\mathcal{R}$ 中，这两个基因拷贝的分化正是因为物种 $\\mathcal{R}$ 分裂成了 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$。因此，$g_{\\mathcal{R}_1}$ 和 $g_{\\mathcal{R}_2}$ 是**直系同源基因**。\n- **旁系同源基因 (Paralogs)**：通过基因重复事件相关的基因。由于问题陈述没有发生重复，因此不存在这种关系。\n- **异源同源基因 (Xenologs)**：存在于不同物种中的基因，其中至少一个基因的历史自其最近共同祖先以来涉及一次HGT事件。此问题中整个基因家族的共同祖先存在于 HGT 之前。导致 $g_{\\mathcal{D}}$ 的谱系是垂直进化的，而导致 $g_{\\mathcal{R}_1}$ 和 $g_{\\mathcal{R}_2}$ 的谱系是由一次从 $\\mathcal{D}$ 谱系发生的 HGT 所引发的。因此，$g_{\\mathcal{D}}$ 和 $g_{\\mathcal{R}_1}$ 之间的关系是**异源同源关系 (xenology)**。同样，$g_{\\mathcal{D}}$ 和 $g_{\\mathcal{R}_2}$ 之间的关系也是**异源同源关系**。\n\n总之，DTL 调和算法将映射一个从 $\\mathcal{D}$ 到 $\\mathcal{R}$ 的 HGT 事件，随后是在 $\\mathcal{R}$ 分裂成 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的节点处发生的一个物种形成事件。这导致 ($g_{\\mathcal{R}_1}$, $g_{\\mathcal{R}_2}$) 被分类为直系同源基因，而 ($g_{\\mathcal{D}}$, $g_{\\mathcal{R}_1}$) 和 ($g_{\\mathcal{D}}$, $g_{\\mathcal{R}_2}$) 被分类为异源同源基因。\n\n**逐项分析**\n\n**A. 该算法将在 $\\mathcal{R}$ 物种形成之前解释为 $\\mathcal{R}$ 内部的一次基因重复，随后垂直遗传到 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 中；它将 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的拷贝分类为种内旁系同源基因，并将两者都视为 $\\mathcal{D}$ 拷贝的直系同源基因。**\n这是不正确的。当基因分化先于物种分化时，DTL 算法会推断出一次重复。在这里，基因分化（$\\mathcal{R}$ 中的基因分裂成 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 中的拷贝）与物种分化是同时发生的。这是调和中物种形成事件的定义。因此，$\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 中的拷贝是直系同源基因，而不是旁系同源基因。与 $\\mathcal{D}$ 中基因的关系涉及一次 HGT，因此是异源同源关系，而非直系同源关系。**结论：不正确。**\n\n**B. 该算法解释为一次从 $\\mathcal{D}$ 到 $\\mathcal{R}$ 的转移，随后 $\\mathcal{R}$ 发生物种形成事件，将转移的谱系垂直地分裂到 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 中；它将 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的拷贝分类为互为直系同源基因，并将每个都分类为 $\\mathcal{D}$ 拷贝的异源同源基因。**\n这是正确的。该解释正确地识别了事件的顺序：一次从 $\\mathcal{D}$到 $\\mathcal{R}$ 的转移，随后是 $\\mathcal{R}$ 的物种形成。分类也是正确的。由于宿主物种形成导致的基因分化使它们成为直系同源基因。$\\mathcal{R}$ 分支基因历史中的 HGT 事件使它们相对于 $\\mathcal{D}$ 基因成为异源同源基因。这一描述与推导出的结果完全相符。**结论：正确。**\n\n**C. 该算法解释为不完全谱系分选，没有重复、转移或丢失；它将所有三个拷贝（$\\mathcal{D}$, $\\mathcal{R}_1$, $\\mathcal{R}_2$）分类为相互的直系同源基因。**\n这是不正确的。DTL 调和模型明确地考虑重复、转移和丢失。它不主要对不完全谱系分选 (ILS) 进行建模，后者通常由基于溯祖理论的模型处理。在给定一个基因出现在一个它先前不存在的远缘谱系中的场景下，DTL 模型最简约的解释是 HGT，而不是 ILS。此外，将所有三个分类为“相互的直系同源基因”是不正确的，因为与 $\\mathcal{D}$ 基因的关系是异源同源关系。**结论：不正确。**\n\n**D. 该算法解释为 $\\mathcal{D}$ 中的一次物种形成被 $\\mathcal{R}$ 中的一次重复所镜像，随后发生协同进化；它将 $\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的拷贝分类为互为异源同源基因，并将两者都视为 $\\mathcal{D}$ 拷贝的直系同源基因。**\n这是不正确的。“$\\mathcal{D}$ 中的物种形成被 $\\mathcal{R}$ 中的重复所镜像”和“协同进化”等术语不属于标准 DTL 调和框架的一部分，也没有描述给定的事件。其分类是根本错误的：$\\mathcal{R}_1$ 和 $\\mathcal{R}_2$ 的拷贝是互为直系同源基因，而不是异源同源基因。与 $\\mathcal{D}$ 拷贝的关系是异源同源关系，而非直系同源关系。**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "2405916"}, {"introduction": "在实际应用中，从序列数据推断出的基因树通常不是完全解析的，它们可能包含具有多个后代的节点（即多分体结构, polytomy），这代表了演化关系的不确定性。这个进阶练习将挑战您从概念理解走向计算实践。您将开发一个算法来寻找多分体结构的最简约解析方案，从而学习调和方法如何系统性地处理不确定性，以重建一个可信的演化历史。[@problem_id:2394108]", "problem": "您的任务是根据复制-丢失简约模型，将一个有根基因树与一个有根二元物种树进行调和。该基因树中恰好有一个节点是具有 $k$ 个子节点 ($k>2$) 的多岐点，而基因树的所有其他内部节点都是严格二元的。基因树的叶节点通过一个已知的满射映射到物种树中的物种。您的目标是找到该多岐点的一种二元解析，以最小化调和成本。\n\n从以下基本定义开始，这些定义在计算生物学和生物信息学中是标准定义：\n\n- 有根基因树 $G$ 和有根物种树 $S$ 是边从根节点定向发出的树，其内部节点至少有两个子节点，叶节点没有子节点，且物种树 $S$ 是严格二元的。\n- 每个基因叶节点通过一个已知的映射 $\\sigma$ 映射到一个唯一的物种叶节点。\n- 最近公共祖先（LCA）映射为每个基因节点 $u$ 分配一个物种节点 $s(u)$，该节点定义为 $u$ 的所有后代基因叶节点的物种标签在 $S$ 中的最近公共祖先。\n- 一个具有子节点 $v_1$ 和 $v_2$ 的基因内部节点 $u$，如果 $s(u)=s(v_1)$ 或 $s(u)=s(v_2)$，则被归类为复制事件；否则被归类为物种形成事件。\n- 每条基因边 $(u\\to v)$ 都嵌入到 $S$ 中从 $s(u)$到 $s(v)$ 的唯一向下路径上（这是明确定义的，因为在LCA映射下，$s(v)$ 始终是 $s(u)$ 的后代）。此路径上贡献的丢失数等于基因谱系缺失的中间物种分支数，即该路径上物种树的边数，不包括进入 $s(v)$ 的最后一条边。如果以边数计算的路径长度为 $\\mathrm{dist}_S\\!\\left(s(u),s(v)\\right)$，则由 $(u\\to v)$ 贡献的丢失计数为 $\\max\\!\\left\\{0,\\mathrm{dist}_S\\!\\left(s(u),s(v)\\right)-1\\right\\}$。\n- 调和的复制-丢失成本是所有内部基因节点 $u$ 的复制指示符与 $u$ 的两条子边上引发的丢失数之和的总和。\n\n您必须编写一个程序，在给定固定的物种树 $S$ 和一个包含唯一具有 $k>2$ 个子节点的多岐点 $P$ 的基因树 $G$ 的情况下，评估该多岐点的所有二元精化，并返回在LCA映射下可能的最小复制-丢失成本。$G$ 的其余部分是固定的且是二元的，这些固定部分不能以任何方式被修改。成本是单位权重的：每次复制贡献 1，每次丢失贡献 1。\n\n您的程序必须实现以下直接从定义中推导出的内容：\n- 对于任何具有子节点 $v_1$ 和 $v_2$ 的二元基因节点 $u$，计算 $s(u)=\\mathrm{LCA}_S\\!\\big(s(v_1),s(v_2)\\big)$。\n- $u$ 处的复制指示符为 $\\mathbf{1}\\!\\left[s(u)=s(v_1)\\ \\lor\\ s(u)=s(v_2)\\right]$。\n- 在 $u$ 处贡献的丢失数为\n$$\n\\max\\!\\left\\{0,\\mathrm{dist}_S\\!\\left(s(u),s(v_1)\\right)-1\\right\\}+\\max\\!\\left\\{0,\\mathrm{dist}_S\\!\\left(s(u),s(v_2)\\right)-1\\right\\}。\n$$\n- 总成本是所有内部基因节点的复制指示符和丢失数之和。当多岐点被解析为二元树时，将这些规则应用于每个内部基因节点，即可计算出最终的全二元基因树的成本。\n\n测试套件。使用以下三个测试用例，每个用例都由一个Newick格式的物种树和一个基因树描述指定。该基因树的唯一多岐点在根节点。除了多岐点外，任何指定的二元子树都是固定的，不得更改。所有基因叶节点都用其映射的物种叶节点进行了标注。\n\n- 测试用例 1（理想情况，$k=3$）：\n  - 物种树 $S_1$: $((A,B),(C,D));$\n  - 基因树 $G_1$：根节点为多岐点，其子节点为 $[a{:}A]$、$[b{:}B]$、$[c{:}C]$。\n- 测试用例 2（成本可达零的边界情况，$k=3$）：\n  - 物种树 $S_2$: $(((A,B),C),D);$\n  - 基因树 $G_2$：根节点为多岐点，其子节点为 $[a{:}A]$、$[b{:}B]$、$[c{:}C]$。\n- 测试用例 3（包含非叶子节点子树作为子代的边缘情况，$k=3$）：\n  - 物种树 $S_3$: $((A,B),(C,D));$\n  - 基因树 $G_3$：根节点为多岐点，其子节点为 $[a{:}A]$、$[Y=(b{:}B,c{:}C)]$、$[d{:}D]$，其中 $Y$ 是一个固定的二元基因子树，其两个叶节点分别映射到 $B$ 和 $C$。\n\n要求输出。您的程序应生成单行输出，其中包含按顺序排列的每个测试用例的最小调和成本（整数），并聚合为方括号内的逗号分隔列表。例如，输出必须采用 $[x_1,x_2,x_3]$ 的形式，其中每个 $x_i$ 是测试用例 $i$ 的最小整数成本。输出行中不允许有额外的空白或文本。\n\n此任务不涉及物理单位或角度。所有要求的数值答案均为整数，因此不需要四舍五-入或单位转换。", "solution": "该问题陈述了一个计算生物学中的场景，涉及基因树 $G$ 与物种树 $S$ 的调和。基因树 $G$ 具有特定的结构：除了一个具有 $k > 2$ 个子节点的多岐点 $P$ 外，它完全是二元的。任务是确定此多岐点的二元解析，以产生最小的总复制-丢失调和成本。\n\n首先对问题进行验证。\n**已知条件提取**：\n- 一个有根的、严格二元的物种树 $S$。\n- 一个有根基因树 $G$，带有一个度为 $k > 2$ 的单一多岐点 $P$；所有其他内部节点都是二元的。\n- 一个从基因叶节点到物种叶节点的满射叶节点映射 $\\sigma$。\n- LCA映射 $s(u) = \\mathrm{LCA}_S(\\{\\sigma(l) \\mid l \\text{ 是 } u \\text{ 的一个叶节点后代}\\})$。\n- 一个具有子节点 $v_1, v_2$ 的内部基因节点 $u$，如果 $s(u)=s(v_1)$ 或 $s(u)=s(v_2)$，则为复制事件；此事件对总成本贡献 1。\n- 基因边 $(u \\to v)$ 导致 $\\max\\{0, \\mathrm{dist}_S(s(u), s(v)) - 1\\}$ 次丢失，每次丢失对总成本贡献 1。$\\mathrm{dist}_S$ 是路径长度（边数）。\n- 总成本是整个基因树上所有复制事件和丢失事件的总和。\n- 目标是找到多岐点 $P$ 的一个二元解析，以最小化此总成本。$G$ 中任何预先存在的二元子树的成本是固定的。\n\n**验证结论**：\n该问题具有科学依据，定义明确且客观。它精确地描述了系统发育学中使用的标准复制-丢失简约模型。所有术语都是标准的，其定义也正确。输入是充分且一致的，足以确保存在唯一解。因此，该问题被判定为 **有效**。\n\n**解法推导**：\n\n完全解析后的基因树的总调和成本由两部分成本之和构成：(1) 来自多岐点的子节点中任何预先存在的二元子树的固定成本，以及 (2) 通过解析多岐点本身产生的可变成本。我们的目标是最小化总成本，这等同于最小化可变成本，因为固定成本是恒定的。\n\n设多岐点 $P$ 的子节点集合为 $\\mathcal{C} = \\{g_1, g_2, \\dots, g_k\\}$。该多岐点的任何二元解析都会产生一个以 $\\mathcal{C}$ 为叶节点、包含 $k-1$ 个新创建的内部节点的有根二元树。解析的成本是在这 $k-1$ 个新节点上计算的调和成本之和。\n\n该问题可以使用动态规划解决。设 $A \\subseteq \\mathcal{C}$ 是多岐点子节点的一个子集。我们将 $C(A)$ 定义为由 $A$ 中元素构成单个有根二元树的最小成本。我们的目标是计算 $C(\\mathcal{C})$。\n\n对于任何子集 $A \\subseteq \\mathcal{C}$，基于它构建的任何二元树的根（称之为 $u_A$），无论树的拓扑结构如何，都将具有相同的物种映射。这是因为 $s(u_A)$ 由其后代子树中所有叶节点的完整集合决定，而这些叶节点正是 $A$ 中子树的基因叶节点。我们定义 $s[A] = \\mathrm{LCA}_S(\\{s(g) \\mid g \\in A\\})$。\n\n我们递推的基例是单元集合：\n$$C(\\{g_i\\}) = 0 \\quad \\text{for each } g_i \\in \\mathcal{C}$$\n因为单个节点不会产生任何成本。\n\n对于任何大小 $|A| \\ge 2$ 的子集 $A \\subseteq \\mathcal{C}$，以 $u_A$ 为根的二元树必须通过将 $A$ 划分为两个非空的、不相交的子集 $A_1$ 和 $A_2$ (即 $A=A_1 \\cup A_2, A_1 \\cap A_2 = \\emptyset$) 来形成。根节点 $u_A$ 将有两个子节点，它们分别是 $A_1$ 和 $A_2$ 最优子解析的根，我们称之为 $u_{A_1}$ 和 $u_{A_2}$。此特定划分的总成本是子问题最优成本之和，再加上在新根节点 $u_A$ 处产生的额外成本：\n$$C(A_1) + C(A_2) + \\Delta C(u_A, u_{A_1}, u_{A_2})$$\n在节点 $u_A$ 处的成本 $\\Delta C$ 是其复制指示符与其出边上的丢失数之和：\n$$ \\Delta C = \\mathbf{1}[s[A]=s[A_1] \\lor s[A]=s[A_2]] + \\max\\{0, \\mathrm{dist}_S(s[A], s[A_1]) - 1\\} + \\max\\{0, \\mathrm{dist}_S(s[A], s[A_2]) - 1\\} $$\n注意，根据LCA的性质，$s[A] = \\mathrm{LCA}_S(s[A_1], s[A_2])$。而且，在物种树 $S$ 中，$s[A_1]$ 和 $s[A_2]$ 始终是 $s[A]$ 的后代（或与之相等），因此距离函数 $\\mathrm{dist}_S$ 被明确定义为从祖先到后代的路径长度。\n\n为了找到子集 $A$ 的最小成本，我们必须检查 $A$所有可能的二分划：\n$$ C(A) = \\min_{\\substack{A_1 \\cup A_2 = A \\\\ A_1, A_2 \\neq \\emptyset, A_1 \\cap A_2 = \\emptyset}} \\left\\{ C(A_1) + C(A_2) + \\Delta C \\right\\} $$\n\n算法流程如下：\n1.  **预处理**：\n    a. 对多岐点的每个子节点 $g_i \\in \\mathcal{C}$，确定其物种映射 $s(g_i)$。如果 $g_i$ 是映射到物种 $X$ 的叶节点，则 $s(g_i)$ 是 $S$ 中的叶节点 $X$。如果 $g_i$ 是一个预先存在的二元子树，其映射 $s(g_i)$ 是其所有叶节点的物种映射的LCA。\n    b. 计算任何此类固定子树的调和成本。这是总成本的固定组成部分。\n    c. 为物种树 $S$ 预先计算数据结构，以便高效计算LCA和距离。具体来说，对于 $S$ 中的任意两个节点，我们需要它们的LCA和路径距离。为每个节点存储父节点指针和深度就足够了。对于祖先 $u$ 和后代 $v$，$\\mathrm{dist}_S(u, v)$ 就是 $\\text{depth}(v) - \\text{depth}(u)$。\n\n2.  **动态规划**：\n    a. 初始化一个表 `dp[subset]` 来存储每个 $A \\subseteq \\mathcal{C}$ 的 $C(A)$。\n    b. 初始化一个表 `s_map[subset]` 来存储 $s[A]$。\n    c. 设置基例：对于每个单元集 $\\{g_i\\}$，`dp[{g_i}]`$=0$ 且 `s_map[{g_i}]`$=s(g_i)$。\n    d. 从 $2$ 到 $k$ 遍历子集大小 $m$。对于每个大小为 $m$ 的子集 $A$：\n        i. 计算并存储 $s[A] = \\mathrm{LCA}_S(\\{s(g) \\mid g \\in A\\})$。\n        ii. 遍历 $A$ 到 $A_1$ 和 $A_2$ 的所有非平凡划分。\n        iii. 对于每个划分，使用递推关系计算总成本，并用找到的最小值更新 `dp[A]`。\n\n3.  **最终结果**：解析多岐点的最小成本是 `dp[C]`。总的最小调和成本是此值加上来自任何固定子树的成本总和。\n\n将实现此算法以解决所提供的测试用例。使用位掩码来表示子集提供了一种实现DP表和遍历子集及其划分的高效方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the standard library or specified ones are permitted.\nimport collections\nfrom itertools import chain, combinations\n\nclass Node:\n    \"\"\"A simple class for representing tree nodes.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        self.children = []\n        self.parent = None\n        self.depth = 0\n\ndef parse_newick_recursive(s):\n    \"\"\"Recursively parses a Newick string component.\"\"\"\n    s = s.strip()\n    # Find the main label if it exists (e.g., from '(A,B)label')\n    if s.endswith(';'):\n        s = s[:-1]\n    \n    label_start = s.rfind(')')\n    name = None\n    if label_start != -1 and label_start < len(s) - 1:\n        name = s[label_start+1:]\n        s = s[:label_start+1]\n\n    if s.startswith('(') and s.endswith(')'):\n        # Internal node\n        node = Node(name=name)\n        content = s[1:-1]\n        \n        balance = 0\n        split_indices = [-1]\n        for i, char in enumerate(content):\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            elif char == ',' and balance == 0:\n                split_indices.append(i)\n        \n        split_indices.append(len(content))\n        \n        for i in range(len(split_indices) - 1):\n            child_str = content[split_indices[i]+1:split_indices[i+1]]\n            child_node = parse_newick_recursive(child_str)\n            node.children.append(child_node)\n        return node\n    else:\n        # Leaf node\n        return Node(name=s)\n\ndef build_tree_properties(root):\n    \"\"\"Traverses tree to set parent pointers, depths, and builds a name->node map.\"\"\"\n    name_to_node = {}\n    q = collections.deque([(root, 0, None)])\n    nodes_in_order = []\n    \n    while q:\n        node, depth, parent = q.popleft()\n        node.depth = depth\n        node.parent = parent\n        nodes_in_order.append(node)\n        if node.name:\n            name_to_node[node.name] = node\n        \n        for child in node.children:\n            q.append((child, depth + 1, node))\n            \n    return name_to_node, nodes_in_order\n\ndef get_path_to_root(node):\n    \"\"\"Returns the path from a node to the root.\"\"\"\n    path = []\n    curr = node\n    while curr is not None:\n        path.append(curr)\n        curr = curr.parent\n    return path\n\ndef get_lca(node1, node2):\n    \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n    path1 = get_path_to_root(node1)\n    path2_nodes = {n for n in get_path_to_root(node2)}\n    for node in path1:\n        if node in path2_nodes:\n            return node\n    return None # Should not happen in a rooted tree\n\ndef get_dist(ancestor, descendant):\n    \"\"\"Calculates distance from an ancestor to a descendant.\"\"\"\n    return descendant.depth - ancestor.depth\n\ndef solve():\n    \"\"\"Main function to solve the problem for all test cases.\"\"\"\n\n    test_cases = [\n        {\n            \"s_tree_str\": \"((A,B),(C,D));\",\n            \"g_children_desc\": [\n                {\"type\": \"leaf\", \"species\": \"A\"},\n                {\"type\": \"leaf\", \"species\": \"B\"},\n                {\"type\": \"leaf\", \"species\": \"C\"}\n            ]\n        },\n        {\n            \"s_tree_str\": \"(((A,B),C),D);\",\n            \"g_children_desc\": [\n                {\"type\": \"leaf\", \"species\": \"A\"},\n                {\"type\": \"leaf\", \"species\": \"B\"},\n                {\"type\": \"leaf\", \"species\": \"C\"}\n            ]\n        },\n        {\n            \"s_tree_str\": \"((A,B),(C,D));\",\n            \"g_children_desc\": [\n                {\"type\": \"leaf\", \"species\": \"A\"},\n                {\"type\": \"subtree\", \"leaves\": [\"B\", \"C\"]},\n                {\"type\": \"leaf\", \"species\": \"D\"}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_root = parse_newick_recursive(case[\"s_tree_str\"])\n        s_name_to_node, _ = build_tree_properties(s_root)\n\n        g_children = []\n        fixed_cost = 0\n\n        # Process gene tree composition\n        for i, desc in enumerate(case[\"g_children_desc\"]):\n            if desc[\"type\"] == \"leaf\":\n                s_node = s_name_to_node[desc[\"species\"]]\n                g_children.append({\"id\": i, \"s_map_node\": s_node})\n            elif desc[\"type\"] == \"subtree\":\n                leaf_nodes = [s_name_to_node[sp] for sp in desc[\"leaves\"]]\n                \n                #\n                # Calculate properties of the fixed subtree\n                #\n                # 1. LCA mapping of the subtree's root\n                subtree_lca = leaf_nodes[0]\n                for j in range(1, len(leaf_nodes)):\n                    subtree_lca = get_lca(subtree_lca, leaf_nodes[j])\n                \n                g_children.append({\"id\": i, \"s_map_node\": subtree_lca})\n\n                # 2. Reconciliation cost of the fixed subtree.\n                # All test cases have subtrees with 2 leaves.\n                # Cost is at the single internal node of the subtree.\n                u, v_1_node, v_2_node = subtree_lca, leaf_nodes[0], leaf_nodes[1]\n                \n                dup = 1 if u == v_1_node or u == v_2_node else 0\n                loss1 = max(0, get_dist(u, v_1_node) - 1)\n                loss2 = max(0, get_dist(u, v_2_node) - 1)\n                fixed_cost += dup + loss1 + loss2\n\n        k = len(g_children)\n        dp = {}  # Using dict for sparse bitmask representation\n        s_map = {}\n\n        # DP Initialization (subsets of size 1)\n        for i in range(k):\n            mask = 1 << i\n            dp[mask] = 0\n            s_map[mask] = g_children[i][\"s_map_node\"]\n\n        # DP for subsets of size > 1\n        for m in range(2, k + 1):\n            for subset_indices in combinations(range(k), m):\n                mask = 0\n                for i in subset_indices:\n                    mask |= (1 << i)\n\n                # Compute LCA map for the current subset\n                current_nodes = [g_children[i][\"s_map_node\"] for i in subset_indices]\n                subset_lca = current_nodes[0]\n                for i in range(1, len(current_nodes)):\n                    subset_lca = get_lca(subset_lca, current_nodes[i])\n                s_map[mask] = subset_lca\n\n                min_cost = float('inf')\n\n                # Iterate through non-trivial partitions\n                # Generate submasks of the current mask\n                for i in range(1, 1 << m):\n                    submask_indices_relative = [idx for idx, bit in enumerate(bin(i)[2:].zfill(m)) if bit == '1']\n                    # Skip full set and empty set\n                    if not submask_indices_relative or len(submask_indices_relative) == m:\n                        continue\n\n                    mask1 = 0\n                    for rel_idx in submask_indices_relative:\n                        mask1 |= (1 << subset_indices[rel_idx])\n\n                    mask2 = mask ^ mask1\n                    \n                    # To avoid double counting A|B and B|A partitions\n                    if mask1 > mask2:\n                        continue\n\n                    s1 = s_map[mask1]\n                    s2 = s_map[mask2]\n                    s_top = s_map[mask]\n\n                    dup_cost = 1 if s_top == s1 or s_top == s2 else 0\n                    loss_cost1 = max(0, get_dist(s_top, s1) - 1)\n                    loss_cost2 = max(0, get_dist(s_top, s2) - 1)\n                    \n                    delta_cost = dup_cost + loss_cost1 + loss_cost2\n                    \n                    current_partition_cost = dp[mask1] + dp[mask2] + delta_cost\n                    min_cost = min(min_cost, current_partition_cost)\n                \n                dp[mask] = min_cost\n        \n        final_mask = (1 << k) - 1\n        min_polytomy_cost = dp[final_mask]\n        total_cost = min_polytomy_cost + fixed_cost\n        results.append(total_cost)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2394108"}]}