{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是亲手实践。这个练习将带你完成一个基础但至关重要的计算任务：根据给定的序列比对数据，计算基因的 $dN/dS$ 值。通过这个过程，你将加深对非同义替换率 ($dN$) 和同义替换率 ($dS$) 定义的理解，并直观地感受如何用一个简单的比值来量化作用在核心功能基因上的强大选择压力。[@problem_id:1918396]", "problem": "一位进化生物学家正在研究 `dnaE` 基因的进化，该基因编码 DNA 聚合酶 III 的 α 亚基，这是一种对细菌染色体复制至关重要的酶。该生物学家获取并比对了来自两个近缘细菌物种的 `dnaE` 基因序列。蛋白质编码区的比对结果显示出若干核苷酸差异。\n\n为了评估该基因所受的选择压力，该生物学家统计了可能因突变而改变氨基酸序列的位点数量（非同义位点），以及突变后不会改变氨基酸序列的位点数量（同义位点）。他们还统计了实际观察到的、导致氨基酸改变的核苷酸差异数量（非同义替换），以及不导致氨基酸改变的核苷酸差异数量（同义替换）。\n\n非同义替换率，记为 $dN$，其计算方法为观察到的非同义替换数除以非同义位点总数。同义替换率 $dS$，其计算方法为观察到的同义替换数除以同义位点总数。这两个速率的比值 $dN/dS$ 是一个衡量选择压力的有力指标。\n\n对 `dnaE` 基因比对的分析得到了以下数据：\n- 非同义位点总数，$N$：2580\n- 同义位点总数，$S$：840\n- 观察到的非同义替换数，$N_d$：22\n- 观察到的同义替换数，$S_d$：147\n\n基于这些数据，计算 `dnaE` 基因的 $dN/dS$ 比值。将您的答案表示为一个实数，并四舍五入到三位有效数字。", "solution": "我们已知非同义位点和同义位点的总数 $N$ 和 $S$，以及观察到的非同义替换数和同义替换数 $N_{d}$ 和 $S_{d}$。根据定义，\n$$\ndN=\\frac{N_{d}}{N},\\qquad dS=\\frac{S_{d}}{S}.\n$$\n因此，该比值为\n$$\n\\frac{dN}{dS}=\\frac{\\frac{N_{d}}{N}}{\\frac{S_{d}}{S}}=\\frac{N_{d}S}{NS_{d}}.\n$$\n代入给定值，\n$$\n\\frac{dN}{dS}=\\frac{22\\cdot 840}{2580\\cdot 147}.\n$$\n化简：\n$$\n\\frac{22\\cdot 840}{2580\\cdot 147}=\\frac{18480}{379260}=\\frac{44}{903}.\n$$\n计算其小数近似值，并四舍五入到三位有效数字：\n$$\n\\frac{44}{903}\\approx 0.0487.\n$$", "answer": "$$\\boxed{0.0487}$$", "id": "1918396"}, {"introduction": "从手动计算到自动化分析是生物信息学家的日常工作。这个编程练习将挑战你将 $dN/dS$ 的计算逻辑转化为可执行的代码，从而彻底揭开其背后算法的神秘面纱。你不仅需要实现核心的计数方法，还要处理一个在真实世界研究中至关重要的复杂情况——遗传密码并非完全通用。通过为标准遗传密码和线粒体遗传密码编写代码，你将对生物信息学工具的内在细节有更深刻的体会。[@problem_id:2386342]", "problem": "你必须编写一个完整、可运行的程序。对于几对比对好的蛋白质编码DNA序列和一种指定的遗传密码，该程序需要计算非同义替换率与同义替换率之比（记为dN/dS）。每条序列由字母表 {A, C, G, T} 中的大写字符组成，其长度是 $3$ 的倍数，并且是框内比对好的（无插入或缺失），因此对应的密码子占据相同的位置。最终程序必须生成单行输出，其中包含所有给定测试用例的结果，格式见下文规定。\n\n定义与假设：\n\n- 设遗传密码为一种映射，它将 $64$ 种可能的密码子（即 {A, C, G, T} 上的三联体）中的每一种映射到一个氨基酸或特殊符号“终止”（Stop）。本题将使用两种遗传密码：\n\n  1. 标准核基因遗传密码：使用常规映射，其中 TAA、TAG 和 TGA 为“终止”密码子，所有其他密码子的映射与经典标准密码一致。\n\n  2. 脊椎动物线粒体遗传密码：与标准核基因遗传密码相同，但以下密码子除外：\n     - ATA 映射为 Met（甲硫氨酸），而非 Ile（异亮氨酸）。\n     - TGA 映射为 Trp（色氨酸），而非“终止”。\n     - AGA 映射为“终止”，而非 Arg（精氨酸）。\n     - AGG 映射为“终止”，而非 Arg（精氨酸）。\n\n- 对于一个在特定遗传密码下编码某个有义氨基酸（非“终止”）的密码子 $c$，将在位置 $p \\in \\{0,1,2\\}$ 的单核苷酸邻居集合定义为：将位置 $p$ 上的核苷酸替换为其他三种核苷酸之一所得到的 $3$ 个密码子。设 $S_p(c)$ 为这些邻居密码子中在该遗传密码下同样为有义密码子（即，非“终止”）的子集，并设 $s_p(c)$ 为 $S_p(c)$ 中与 $c$ 编码相同氨基酸的密码子数量。定义位置 $p$ 的同义位点贡献为：\n  $$ \\sigma_p(c) = \\begin{cases}\n  \\dfrac{s_p(c)}{|S_p(c)|}, & \\text{if } |S_p(c)| > 0 \\\\\n  0, & \\text{if } |S_p(c)| = 0\n  \\end{cases} $$\n  以及位置 $p$ 的非同义位点贡献为：\n  $$ \\nu_p(c) = \\begin{cases}\n  \\dfrac{|S_p(c)| - s_p(c)}{|S_p(c)|}, & \\text{if } |S_p(c)| > 0 \\\\\n  0, & \\text{if } |S_p(c)| = 0\n  \\end{cases} $$\n  密码子 $c$ 的同义位点数为 $ \\Sigma(c) = \\sigma_0(c) + \\sigma_1(c) + \\sigma_2(c) $，非同义位点数为 $ N\\Sigma(c) = \\nu_0(c) + \\nu_1(c) + \\nu_2(c) $。\n\n- 对于一对已比对序列，在密码子索引为 $i$、密码子分别为 $c_1$ 和 $c_2$ 的位置，在选定的遗传密码下，将该位置的同义和非同义位点贡献定义为平均值：\n  $$ \\Sigma_i = \\dfrac{\\Sigma(c_1) + \\Sigma(c_2)}{2}, \\quad N\\Sigma_i = \\dfrac{N\\Sigma(c_1) + N\\Sigma(c_2)}{2}. $$\n  这对序列的总同义位点数 $S$ 和总非同义位点数 $N$ 分别是 $ S = \\sum_i \\Sigma_i $ 和 $ N = \\sum_i N\\Sigma_i $。\n\n- 对于在相同索引处的密码子 $c_1$ 和 $c_2$ 之间观测到的差异，令汉明距离为它们之间核苷酸不同的位置数。如果汉明距离为 $1$ 且 $c_1$ 和 $c_2$ 在所选遗传密码下都是有义密码子，则：\n  - 如果 $c_1$ 和 $c_2$ 编码相同的氨基酸，则计为一次同义差异。\n  - 否则，计为一次非同义差异。\n  如果汉明距离为 $0$，则不计差异。如果汉明距离为 $2$ 或 $3$，则在计算观测差异时忽略该密码子对。设同义差异总数为 $S_d$，非同义差异总数为 $N_d$。\n\n- 定义速率：\n  $$ d_S = \\begin{cases}\n  \\dfrac{S_d}{S}, & \\text{if } S > 0 \\\\\n  0, & \\text{if } S = 0\n  \\end{cases}, \\quad\n  d_N = \\begin{cases}\n  \\dfrac{N_d}{N}, & \\text{if } N > 0 \\\\\n  0, & \\text{if } N = 0\n  \\end{cases}. $$\n  定义比率 $R = d_N / d_S$，并遵循以下约定：\n  - 若 $d_S = 0$ 且 $d_N = 0$，则设 $R = 0$。\n  - 若 $d_S = 0$ 且 $d_N > 0$，则设 $R = +\\infty$。\n\n输入以测试套件的形式嵌入程序中。你必须使用以下测试套件：\n\n- 测试用例 1：标准核基因遗传密码；序列对：\n  - 序列 A: \"ATAGCTTTC\"\n  - 序列 B: \"ATGGCTTTT\"\n\n- 测试用例 2：脊椎动物线粒体遗传密码；序列对：\n  - 序列 A: \"ATAGCTTTC\"\n  - 序列 B: \"ATGGCTTTT\"\n\n- 测试用例 3：标准核基因遗传密码；序列对：\n  - 序列 A: \"ATGTGGATG\"\n  - 序列 B: \"TGGTGGATG\"\n\n- 测试用例 4：脊椎动物线粒体遗传密码；序列对：\n  - 序列 A: \"GCTAAA\"\n  - 序列 B: \"TGCGGG\"\n\n所有序列在其指定的遗传密码下都是有效的编码序列。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。\n- 每个结果都必须是一个实数，打印时小数点后保留恰好 $6$ 位数字。但若值为 $+\\infty$，则必须打印为 \"inf\"。", "solution": "该问题要求针对成对的已比对DNA序列，计算非同义与同义替换率之比，记为 $d_N/d_S$。所用方法是 Nei-Gojobori 方法（1986）的一个简化变体。该问题定义明确，有科学依据，并提供了完整的算法规范。因此，该问题是有效的，可以构建解决方案。\n\n解决方案通过遵循结构化的、基于原则的方法来实现。问题的核心在于量化同义和非同义替换的潜力，并将其与两条序列之间观测到的此类替换数量进行比较。\n\n首先，我们必须根据两种指定的遗传密码——标准核基因遗传密码和脊椎动物线粒体遗传密码——建立从密码子到氨基酸的映射。这些密码被表示为查找表，将 $64$ 种可能的密码子中的每一种映射到一个氨基酸或一个“终止”信号。\n\n下一步是量化每个密码子发生替换的进化潜力。对于任何给定的有义密码子 $c$ ，我们分析所有可能的单核苷酸突变的后果。问题为密码子 $c$ 定义了同义和非同义位点贡献，它们分别代表导致同义或非同义突变的潜在单核苷酸变化的比例。\n\n对于一个密码子 $c$ 和一个位置 $p \\in \\{0, 1, 2\\}$，我们考虑在该位置通过单个核苷酸变化可以产生的三种密码子。设 $S_p(c)$ 是这些邻居中同样为有义密码子的集合。设 $s_p(c)$ 是 $S_p(c)$ 中与 $c$ 编码相同氨基酸的密码子数量。此位置的同义位点贡献定义为：\n$$ \\sigma_p(c) = \\begin{cases} \\dfrac{s_p(c)}{|S_p(c)|}, & \\text{if } |S_p(c)| > 0 \\\\ 0, & \\text{if } |S_p(c)| = 0 \\end{cases} $$\n而非同义位点贡献为：\n$$ \\nu_p(c) = 1 - \\sigma_p(c) = \\begin{cases} \\dfrac{|S_p(c)| - s_p(c)}{|S_p(c)|}, & \\text{if } |S_p(c)| > 0 \\\\ 0, & \\text{if } |S_p(c)| = 0 \\end{cases} $$\n密码子 $c$ 的总同义位点数 $\\Sigma(c)$ 和总非同义位点数 $N\\Sigma(c)$ 是这三位置上贡献的总和：\n$$ \\Sigma(c) = \\sum_{p=0}^{2} \\sigma_p(c) $$\n$$ N\\Sigma(c) = \\sum_{p=0}^{2} \\nu_p(c) $$\n注意，根据定义，$\\Sigma(c) + N\\Sigma(c)$ 是从密码子 $c$ 出发、能产生另一个有义密码子的可能单核苷酸变化数除以 $3$（如果没有终止密码子邻居），但当存在终止密码子邻居时，公式会更复杂。$\\Sigma(c) + N\\Sigma(c)$ 的总和等于 $|S_p(c)| > 0$ 的位置 $p$ 的数量。该总和总是一个从 $0$ 到 $3$ 的整数。\n\n为优化计算，我们针对两种遗传密码，为所有 $64$ 个密码子预先计算 $\\Sigma(c)$ 和 $N\\Sigma(c)$。这样就创建了两个全面的查找表。\n\n利用这些预先计算好的值，我们处理每一对已比对的序列。序列被分割成对应的密码子。对于给定位置 $i$ 的每一对密码子 $(c_1, c_2)$：\n$1$. 计算整个序列比对的同义位点总数（$S$）和非同义位点总数（$N$）。它们是所有密码子位置 $i$ 的总和：\n$$ S = \\sum_i \\Sigma_i = \\sum_i \\frac{\\Sigma(c_1) + \\Sigma(c_2)}{2} $$\n$$ N = \\sum_i N\\Sigma_i = \\sum_i \\frac{N\\Sigma(c_1) + N\\Sigma(c_2)}{2} $$\n这种平均处理考虑了两个密码子之间的进化路径是双向的这一事实。此计算对所有密码子对执行，无论它们是否不同。\n\n$2$. 统计观测到的同义差异数（$S_d$）和非同义差异数（$N_d$）。根据问题的规则，我们只考虑相差一个核苷酸（汉明距离为 $1$）的密码子对 $(c_1, c_2)$。如果 `aa($c_1$)` 与 `aa($c_2$)` 相同，则该差异被计为同义差异（$S_d$ 增加）。否则，计为非同义差异（$N_d$ 增加）。汉明距离为 $0$、$2$ 或 $3$ 的密码子对不计入这些统计。\n\n最后，通过将观测到的差异数除以位点总数进行归一化，计算出同义替换率（$d_S$）和非同义替换率（$d_N$）：\n$$ d_S = \\begin{cases} \\dfrac{S_d}{S}, & \\text{if } S > 0 \\\\ 0, & \\text{if } S = 0 \\end{cases} $$\n$$ d_N = \\begin{cases} \\dfrac{N_d}{N}, & \\text{if } N > 0 \\\\ 0, & \\text{if } N = 0 \\end{cases} $$\n然后计算所求的比率 $R = d_N / d_S$。问题对 $d_S = 0$ 的情况规定了处理约定：\n- 若 $d_S = 0$ 且 $d_N = 0$，则 $R = 0$。\n- 若 $d_S = 0$ 且 $d_N > 0$，则 $R = +\\infty$。\n\n该算法在一个 Python 程序中实现。该程序定义了遗传密码，预先计算了位点贡献，根据上述逻辑处理每个测试用例，并按照指定格式输出最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the dN/dS problem for the given test cases.\n    It encapsulates all logic for calculating the ratio of nonsynonymous to\n    synonymous substitution rates.\n    \"\"\"\n\n    def get_genetic_codes():\n        \"\"\"\n        Returns two genetic code dictionaries: standard and vertebrate mitochondrial.\n        \"\"\"\n        bases = 'TCAG'\n        codons = [b1 + b2 + b3 for b1 in bases for b2 in bases for b3 in bases]\n        amino_acids = 'FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG'\n        \n        standard_code = dict(zip(codons, amino_acids))\n        \n        mito_code = standard_code.copy()\n        mito_code['ATA'] = 'M'  # Isoleucine -> Methionine\n        mito_code['TGA'] = 'W'  # Stop -> Tryptophan\n        mito_code['AGA'] = '*'  # Arginine -> Stop\n        mito_code['AGG'] = '*'  # Arginine -> Stop\n        \n        return {\n            \"Standard Nuclear Genetic Code\": standard_code,\n            \"Vertebrate Mitochondrial Genetic Code\": mito_code\n        }\n\n    def precompute_site_contributions(genetic_code):\n        \"\"\"\n        Pre-computes and caches the synonymous (Sigma) and nonsynonymous (N_sigma)\n        site counts for every codon in a given genetic code.\n        \"\"\"\n        bases = ['A', 'C', 'G', 'T']\n        contributions = {}\n        codons = [''.join([b1, b2, b3]) for b1 in bases for b2 in bases for b3 in bases]\n\n        for codon_str in codons:\n            if genetic_code.get(codon_str, '*') == '*':\n                contributions[codon_str] = (0.0, 0.0)\n                continue\n\n            codon_list = list(codon_str)\n            original_aa = genetic_code[codon_str]\n            \n            total_syn_sites = 0.0\n            total_nonsyn_sites = 0.0\n\n            for p in range(3):  # Iterate through positions 0, 1, 2\n                neighbors = []\n                original_base = codon_list[p]\n                \n                for base in bases:\n                    if base != original_base:\n                        new_codon_list = codon_list[:]\n                        new_codon_list[p] = base\n                        neighbors.append(\"\".join(new_codon_list))\n                \n                sense_neighbors = [c for c in neighbors if genetic_code.get(c) != '*']\n                \n                if not sense_neighbors:\n                    sigma_p = 0.0\n                    nu_p = 0.0\n                else:\n                    syn_neighbors_count = sum(1 for c in sense_neighbors if genetic_code[c] == original_aa)\n                    num_sense_neighbors = len(sense_neighbors)\n                    \n                    sigma_p = syn_neighbors_count / num_sense_neighbors\n                    nu_p = (num_sense_neighbors - syn_neighbors_count) / num_sense_neighbors\n\n                total_syn_sites += sigma_p\n                total_nonsyn_sites += nu_p\n            \n            contributions[codon_str] = (total_syn_sites, total_nonsyn_sites)\n        \n        return contributions\n\n    def calculate_dn_ds(seq1, seq2, genetic_code, site_contributions):\n        \"\"\"\n        Calculates dN/dS for a pair of aligned sequences.\n        \"\"\"\n        num_codons = len(seq1) // 3\n        \n        S_total = 0.0\n        N_total = 0.0\n        Sd = 0\n        Nd = 0\n\n        for i in range(num_codons):\n            c1 = seq1[i*3 : i*3+3]\n            c2 = seq2[i*3 : i*3+3]\n\n            # Calculate total potential sites S and N\n            sigma_c1, n_sigma_c1 = site_contributions[c1]\n            sigma_c2, n_sigma_c2 = site_contributions[c2]\n\n            S_total += (sigma_c1 + sigma_c2) / 2.0\n            N_total += (n_sigma_c1 + n_sigma_c2) / 2.0\n            \n            # Calculate observed differences Sd and Nd\n            hamming_dist = sum(1 for j in range(3) if c1[j] != c2[j])\n            \n            if hamming_dist == 1:\n                aa1 = genetic_code[c1]\n                aa2 = genetic_code[c2]\n                if aa1 == aa2:\n                    Sd += 1\n                else:\n                    Nd += 1\n\n        dS = (Sd / S_total) if S_total > 0 else 0.0\n        dN = (Nd / N_total) if N_total > 0 else 0.0\n        \n        if dS == 0:\n            if dN == 0:\n                return 0.0\n            else:\n                return float('inf')\n        \n        return dN / dS\n\n    # --- Main Execution Logic ---\n    \n    test_cases = [\n        {\n            \"name\": \"Test case 1\",\n            \"code_name\": \"Standard Nuclear Genetic Code\",\n            \"seq_pair\": (\"ATAGCTTTC\", \"ATGGCTTTT\")\n        },\n        {\n            \"name\": \"Test case 2\",\n            \"code_name\": \"Vertebrate Mitochondrial Genetic Code\",\n            \"seq_pair\": (\"ATAGCTTTC\", \"ATGGCTTTT\")\n        },\n        {\n            \"name\": \"Test case 3\",\n            \"code_name\": \"Standard Nuclear Genetic Code\",\n            \"seq_pair\": (\"ATGTGGATG\", \"TGGTGGATG\")\n        },\n        {\n            \"name\": \"Test case 4\",\n            \"code_name\": \"Vertebrate Mitochondrial Genetic Code\",\n            \"seq_pair\": (\"GCTAAA\", \"TGCGGG\")\n        }\n    ]\n\n    genetic_codes = get_genetic_codes()\n    \n    # Precompute contributions for both genetic codes\n    contributions_cache = {\n        name: precompute_site_contributions(code)\n        for name, code in genetic_codes.items()\n    }\n\n    results = []\n    for case in test_cases:\n        seq1, seq2 = case[\"seq_pair\"]\n        code_name = case[\"code_name\"]\n        \n        genetic_code = genetic_codes[code_name]\n        site_contributions = contributions_cache[code_name]\n        \n        result = calculate_dn_ds(seq1, seq2, genetic_code, site_contributions)\n        results.append(result)\n\n    # Format output\n    formatted_results = []\n    for r in results:\n        if r == float('inf'):\n            formatted_results.append(\"inf\")\n        else:\n            formatted_results.append(f\"{r:.6f}\")\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2386342"}, {"introduction": "计算出 $dN/dS$ 值只是第一步，更关键的能力在于如何解读它。真实的生物演化故事往往是复杂的，一个基因的不同部分可能承受着截然不同的选择压力。这个练习将你置于一个常见的研究场景中：一个基因在整体上表现出纯化选择的迹象（$dN/dS < 1$），但其内部却存在着正选择的“热点”区域。通过分析这种情况，你将学会超越单一的平均值，领会更复杂的演化模型在揭示局部适应性演化中的强大作用。[@problem_id:2386401]", "problem": "您正在分析一个由 $n$ 个长度为 $L$ 个密码子的直系同源蛋白质编码序列构成的比对。使用单比率密码子模型（即全基因范围内非同义与同义替换率之比为单一值），基因范围内的非同义与同义替换率之比 $d_N/d_S$（也记作 $\\omega$）的最大似然（ML）估计值为 $\\overline{\\omega}=0.32$。一个允许 $\\omega$ 值在位点间存在异质性的位点特异性模型，识别出了一部分密码子，其后验均值 $\\omega_i>1$ 且具有高支持度，而大多数密码子的后验均值 $\\omega_i<1$。根据这些结果，哪种（或哪些）解释最为恰当？请选择所有适用项。\n\nA. 该模式表明，大多数密码子受到纯化选择（$\\omega<1$），少数密码子受到多样化正选择（$\\omega>1$）；较低的全基因平均值反映了纯化选择在各位点上的主导地位，这与存在少数正选择密码子的情况并不矛盾。\n\nB. 这个结果在算术上是不可能的：只要有任何一个密码子的 $\\omega>1$，那么全基因的平均值就必须超过 $1$，因此位点特异性推断很可能是一种假象。\n\nC. 该基因整体上处于正选择之下，但是由于许多位点上存在密码子使用偏好，导致同义替换率（$d_S$）降低，从而人为地将平均 $\\omega$ 值降低到 $1$ 以下；较低的 $\\overline{\\omega}$ 是由较低的 $d_S$ 而非选择驱动的。\n\nD. 该观察结果表明平衡选择作用于整个基因，维持了多个等位基因，从而降低了 $d_N$ 相对于 $d_S$ 的比率；这种全基因范围的平衡选择解释了为何在普遍存在选择的情况下 $\\overline{\\omega}<1$。\n\nE. 该发现与集中在特定密码子上的阵发性或谱系特异性正选择相符，即在这些密码子处只有部分分支或特定背景下才会经历 $\\omega>1$；分支位点分析可能捕捉到这一点，并且如果正选择的范围或频率有限，那么全基因的 $\\overline{\\omega}<1$ 是符合预期的。", "solution": "在尝试任何解答之前，必须首先严格验证问题陈述的科学性和逻辑完整性。\n\n### 问题验证\n\n**步骤1：提取已知信息**\n-   一个由 $n$ 个直系同源蛋白质编码序列构成的比对。\n-   序列长度为 $L$ 个密码子。\n-   单比率密码子模型得出的全基因非同义与同义替换率之比 $d_N/d_S \\equiv \\omega$ 的最大似然（ML）估计值。\n-   全基因的估计值为 $\\overline{\\omega} = 0.32$。\n-   应用了一个允许 $\\omega$ 值在位点间存在异质性的位点特异性模型。\n-   该位点特异性模型识别出了一部分密码子，其后验均值 $\\omega_i > 1$ 且具有高统计支持度。\n-   大多数密码子的后验均值为 $\\omega_i < 1$。\n-   问题是要求从这些发现中找出最恰当的解释。\n\n**步骤2：使用提取的已知信息进行验证**\n-   **科学依据充分：** 该问题牢固地建立在分子进化的标准理论框架之上，该框架用于检测作用于蛋白质编码基因的选择压力。$d_N/d_S$ 比率（$\\omega$）、单比率模型（例如 PAML 中的 M0 模型）和位点特异性模型（例如 PAML 中的 M1/M2、M7/M8 模型）等概念是计算生物学和生物信息学领域的核心。所呈现的情景——一个较低的全基因平均值 $\\overline{\\omega}$ 与少数正选择位点的统计证据同时出现——是分子适应性经验研究中常见且经典的发现。$\\overline{\\omega} = 0.32$ 这个值是一个现实的值，表明整体上存在纯化选择。\n-   **问题定义明确：** 问题陈述清晰。它提供了一组来自标准生物信息学分析的结果，并要求从一系列可能性中选择其解释。在分子进化理论的框架内，保证了正确解释的存在。\n-   **客观性：** 问题陈述使用精确、客观和技术性的语言，没有任何主观性或模糊性。\n\n**步骤3：结论与行动**\n问题陈述在科学上是合理的，定义明确且客观。它描述了分子进化分析中的一个典型情景。因此，该问题是**有效的**，并将推导出完整的解答。\n\n### 解答推导\n\n问题的核心在于理解不同的密码子进化模型如何总结选择压力。比率 $\\omega = d_N/d_S$ 量化了作用于蛋白质编码基因的选择模式和强度，其中 $d_N$ 是非同义替换率，而 $d_S$ 是同义替换率。\n-   $\\omega < 1$：纯化（负）选择，清除有害的氨基酸变化。\n-   $\\omega = 1$：中性进化，氨基酸变化既不被偏好也不被排斥。\n-   $\\omega > 1$：正（多样化）选择，偏好并迅速固定有利的氨基酸变化。\n\n**单比率模型** 假设选择压力在所有密码子位点和系统发育树的所有进化谱系中都是均匀的。它估计一个单一的全基因平均 $\\omega$ 值，我们记为 $\\overline{\\omega}$。给定的值 $\\overline{\\omega} = 0.32$ 清楚地表明，平均而言，该基因处于强烈的纯化选择之下，因为非同义替换的发生速率仅为同义（并被假定为中性）替换速率的 $32\\%$。\n\n**位点特异性模型** 放宽了选择压力均匀的假设，允许 $\\omega$ 在不同密码子位点间变化。大多数密码子的 $\\omega_i < 1$ 而少数密码子的 $\\omega_i > 1$ 这一发现揭示了一幅更复杂的进化图景。它表明，虽然蛋白质的大部分结构和功能是保守的（因此，大多数位点处于纯化选择之下），但少数位点正在经历适应性进化。\n\n来自单比率模型的全基因平均值 $\\overline{\\omega}$ 实际上是各位点特异性 $\\omega_i$ 值的加权平均值。如果大部分位点处于强纯化选择之下（例如，$\\omega_i \\approx 0$），而只有一小部分位点处于正选择之下（例如，$\\omega_i > 1$），那么最终的平均值 $\\overline{\\omega}$ 几乎肯定会小于 $1$。因此，这两个模型的发现不是矛盾的，而是互补的。位点特异性模型提供了更高的分辨率，揭示了被全基因平均值所掩盖的局部适应性。\n\n现在，我们来评估每个选项。\n\n**A. 该模式表明，大多数密码子受到纯化选择（$\\omega<1$），少数密码子受到多样化正选择（$\\omega>1$）；较低的全基因平均值反映了纯化选择在各位点上的主导地位，这与存在少数正选择密码子的情况并不矛盾。**\n这个陈述是对情况的精确和准确描述。位点特异性模型的结果直接说明了大多数密码子的 $\\omega_i < 1$，而少数密码子的 $\\omega_i > 1$。关于较低的 $\\overline{\\omega}$ 是一个被大量纯化选择位点所主导的平均值的解释，在算术上和生物学上都是正确的。这是该领域的标准解释。\n**结论：正确。**\n\n**B. 这个结果在算术上是不可能的：只要有任何一个密码子的 $\\omega>1$，那么全基因的平均值就必须超过 $1$，因此位点特异性推断很可能是一种假象。**\n这个陈述基于一个基本的数学错误。一组数的平均值并不因为其中一个数大于 $1$ 就必须大于 $1$。例如，考虑一个有 $100$ 个位点的简化基因。如果 $99$ 个位点的 $\\omega_i = 0.2$，而 $1$ 个位点的 $\\omega_i = 5$，那么平均 $\\omega$ 大约是 $(99 \\times 0.2 + 1 \\times 5) / 100 = (19.8 + 5) / 100 = 0.248$，远低于 $1$。该选项的前提是错误的。\n**结论：错误。**\n\n**C. 该基因整体上处于正选择之下，但是由于许多位点上存在密码子使用偏好，导致同义替换率（$d_S$）降低，从而人为地将平均 $\\omega$ 值降低到 $1$ 以下；较低的 $\\overline{\\omega}$ 是由较低的 $d_S$ 而非选择驱动的。**\n这个陈述的推理有缺陷。密码子使用偏好，即某些同义密码子更受青睐，会导致对非偏好同义密码子的纯化选择。这会*降低*同义替换率 $d_S$。根据公式 $\\omega = d_N/d_S$，分母 $d_S$ 的减小会导致计算出的 $\\omega$ 比率*增加*，而不是减少。因此，强烈的密码子使用偏好会抬高 $\\omega$ 值，使得观察到 $\\omega < 1$ 成为非同义替换层面纯化选择的一个更强烈的信号。该选项的结论与预期相反。此外，“整体上处于正选择之下”的说法直接与主要数据点 $\\overline{\\omega} = 0.32$ 相矛盾。\n**结论：错误。**\n\n**D. 该观察结果表明平衡选择作用于整个基因，维持了多个等位基因，从而降低了 $d_N$ 相对于 $d_S$ 的比率；这种全基因范围的平衡选择解释了为何在普遍存在选择的情况下 $\\overline{\\omega}<1$。**\n这个选项混淆了不同的选择模式。正选择的标志（$\\omega > 1$）指的是多样化选择，它促进新的有利突变的快速固定。相比之下，平衡选择是在一个群体中长期维持一个位点上的多个等位基因。标准的 $d_N/d_S$ 框架测量的是不同谱系间的替换率，它不是检测平衡选择的主要工具，尽管长期的平衡选择可以留下复杂的印记。关于平衡选择“降低了 $d_N$ 相对于 $d_S$ 的比率”这一说法通常不成立；通过维持等位基因多样性，它可以增加多态性，但其对基于分歧度的 $d_N$ 的影响并非简单的降低。问题描述的是多样化选择（某些位点的 $\\omega_i > 1$），这与平衡选择是不同的。\n**结论：错误。**\n\n**E. 该发现与集中在特定密码子上的阵发性或谱系特异性正选择相符，即在这些密码子处只有部分分支或特定背景下才会经历 $\\omega>1$；分支位点分析可能捕捉到这一点，并且如果正选择的范围或频率有限，那么全基因的 $\\overline{\\omega}<1$ 是符合预期的。**\n这个陈述提供了一个复杂而有效的解释。位点特异性模型计算的是每个位点在整个系统发育树所有分支上的平均 $\\omega$ 参数。正选择是阵发性的——作用强烈但仅发生在特定谱系上（例如，在基因复制后或为应对新病原体时）——这是合理且非常常见的。在这种情况下，位点模型会检测到该位点有一个升高的平均 $\\omega_i$ 值，该值可能 >1。然而，由于选择压力在整个树上不是恒定的，所有分支和所有位点的平均值（$\\overline{\\omega}$）将保持较低水平。这正确地指出了仅使用位点模型的局限性，并正确地提出**分支位点模型**将是检验这一更具体假设的合适工具。这种解释与给定的数据完全一致。\n**结论：正确。**\n\n总而言之，选项A和E提供了对结果的恰当且互补的解释。选项A给出了直接的解释，而选项E提供了一个关于所观察到的正选择的时间动态的更细致的假设。两者都是有效的。", "answer": "$$\\boxed{AE}$$", "id": "2386401"}]}