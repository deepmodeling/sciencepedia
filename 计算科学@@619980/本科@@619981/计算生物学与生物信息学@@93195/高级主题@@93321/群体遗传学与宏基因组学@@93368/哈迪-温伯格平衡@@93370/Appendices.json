{"hands_on_practices": [{"introduction": "哈代-温伯格平衡原理为我们提供了一个基准模型，用于理解种群中等位基因和基因型频率的动态。第一个练习将引导你完成一个基础但至关重要的计算。通过使用一个假设的兰花种群的观测数据，你将学习如何从基因型计数中估计等位基因频率，并利用这些频率来预测下一代在哈代-温伯格平衡下的预期杂合子频率 [@problem_id:1852915]。这个实践旨在巩固你将理论模型应用于实际观测数据的核心能力。", "problem": "一个保育生物学家团队正在监测一个大型、与世隔绝的珍稀天空花瓣兰花（*Orchis caelestis*）种群。该物种的花色由一个具有两个等位基因的单一基因决定，这两个等位基因表现为不完全显性。蓝色花瓣的等位基因用 $C^B$ 表示，白色花瓣的等位基因用 $C^W$ 表示。基因型为 $C^B C^B$ 的植株开蓝色花，基因型为 $C^W C^W$ 的植株开白色花，杂合子植株（$C^B C^W$）开浅蓝色花。\n\n在最近的一次野外调查中，生物学家们统计了每种表型的植株数量。他们的普查数据显示：\n- 721 株蓝色花植株\n- 438 株浅蓝色花植株\n- 71 株白色花植株\n\n假设该种群符合Hardy-Weinberg平衡的条件（即随机交配，且没有突变、选择、基因流或遗传漂变），计算下一代中杂合子个体的预期频率。报告你的答案，保留三位有效数字。", "solution": "设 $p$ 为等位基因 $C^{B}$ 的频率，$q$ 为等位基因 $C^{W}$ 的频率，且 $p+q=1$。在Hardy-Weinberg平衡下，基因型频率分别为：$C^{B}C^{B}$（蓝色）为 $p^{2}$，$C^{B}C^{W}$（浅蓝色）为 $2pq$，$C^{W}C^{W}$（白色）为 $q^{2}$。\n\n根据普查数据：\n- $N_{BB}=721$ (蓝色花)\n- $N_{BW}=438$ (浅蓝色花)\n- $N_{WW}=71$ (白色花)\n- 总个体数 $N=N_{BB}+N_{BW}+N_{WW}=721+438+71=1230$。\n\n等位基因频率根据基因型计数计算如下：\n$$\np = \\text{freq}(C^B) = \\frac{2 \\times N_{BB} + N_{BW}}{2N} = \\frac{2\\times 721+438}{2\\times 1230}=\\frac{1880}{2460}=\\frac{94}{123}\n$$\n$$\nq = \\text{freq}(C^W) = 1-p = 1-\\frac{94}{123}=\\frac{29}{123}\n$$\n在Hardy-Weinberg平衡下，下一代中杂合子的预期频率为 $2pq$：\n$$\n\\text{预期杂合子频率} = 2pq = 2 \\times \\left(\\frac{94}{123}\\right) \\times \\left(\\frac{29}{123}\\right) = \\frac{5452}{15129} \\approx 0.360367\\ldots\n$$\n保留三位有效数字，得到 $0.360$。", "answer": "$$\\boxed{0.360}$$", "id": "1852915"}, {"introduction": "在能够计算哈代-温伯格平衡下的期望频率之后，下一步自然是检验真实世界的种群是否符合这一理论模型。本练习介绍卡方($\\chi^2$)拟合优度检验，这是一种强大的统计工具，用于量化观测基因型计数与期望值之间的偏差 [@problem_id:2396513]。通过分解总的 $\\chi^2$ 统计量，你将学会识别哪个基因型对偏离平衡的贡献最大，从而获得对潜在进化力量或数据质量问题的更深刻洞察。", "problem": "在一个由 $n$ 个二倍体个体组成的队列中，对一个双等位基因的常染色体基因座进行了基因分型。观测到的基因型计数为 $O_{AA}=150$、$O_{Aa}=300$ 和 $O_{aa}=50$，因此 $n=500$。在哈迪-温伯格平衡 (HWE) 的零假设下，使用该样本估计等位基因 $A$ 的频率，然后计算出相应的期望基因型计数。使用基于这些期望计数的哈迪-温伯格平衡的卡方 ($\\chi^{2}$) 拟合优度检验框架，计算每个基因型 $g\\in\\{AA,Aa,aa\\}$ 的贡献值 $\\left(O_{g}-E_{g}\\right)^{2}/E_{g}$，并确定最大的单个贡献值。只报告这个最大单基因型贡献值的数值。将您的答案四舍五入到三位有效数字。", "solution": "第一步：根据观测数据估计等位基因频率。\n总样本量 $n = O_{AA} + O_{Aa} + O_{aa} = 150 + 300 + 50 = 500$。\n等位基因 $A$ 的频率 $\\hat{p}$ 的计算方法为：\n$$ \\hat{p} = \\frac{2 \\times O_{AA} + O_{Aa}}{2n} = \\frac{2 \\times 150 + 300}{2 \\times 500} = \\frac{600}{1000} = 0.6 $$\n等位基因 $a$ 的频率 $\\hat{q}$ 为 $1 - \\hat{p} = 1 - 0.6 = 0.4$。\n\n第二步：在哈迪-温伯格平衡的零假设下计算期望的基因型计数。\n$E_{AA} = n \\times \\hat{p}^2 = 500 \\times (0.6)^2 = 500 \\times 0.36 = 180$。\n$E_{Aa} = n \\times 2\\hat{p}\\hat{q} = 500 \\times 2 \\times 0.6 \\times 0.4 = 500 \\times 0.48 = 240$。\n$E_{aa} = n \\times \\hat{q}^2 = 500 \\times (0.4)^2 = 500 \\times 0.16 = 80$。\n\n第三步：计算每个基因型对卡方统计量的贡献值 $\\frac{(O_{g}-E_{g})^{2}}{E_{g}}$。\n对于基因型 $AA$：\n$$ \\frac{(150 - 180)^2}{180} = \\frac{(-30)^2}{180} = \\frac{900}{180} = 5 $$\n对于基因型 $Aa$：\n$$ \\frac{(300 - 240)^2}{240} = \\frac{(60)^2}{240} = \\frac{3600}{240} = 15 $$\n对于基因型 $aa$：\n$$ \\frac{(50 - 80)^2}{80} = \\frac{(-30)^2}{80} = \\frac{900}{80} = 11.25 $$\n\n第四步：确定最大的单个贡献值。\n三个贡献值分别为 $5$、$15$ 和 $11.25$。其中最大的是 $15$。根据题目要求，将答案表示为三位有效数字，得到 $15.0$。", "answer": "$$\\boxed{15.0}$$", "id": "2396513"}, {"introduction": "任何统计检验都有其适用范围和局限性，卡方检验也不例外。最后的这个实践将带你进入计算生物学的核心领域——通过模拟来探索统计方法的稳健性。你需要编写一个程序来模拟在完美的哈代-温伯格平衡条件下生成的基因型数据，并量化在小样本量或稀有等位基因存在时，卡方检验产生假阳性结果的频率[@problem_id:2396474]。这个练习不仅能加深你对哈代-温伯格原理的理解，更能培养你批判性地评估统计工具并在实践中审慎使用它们的能力。", "problem": "你的任务是实现一个完整、可执行的程序，用以模拟在哈迪-温伯格平衡 (Hardy–Weinberg equilibrium, HWE) 下的基因型数据，并量化小样本量与大样本卡方近似法结合时，如何仅因概率而产生统计上显著但错误的偏差。模拟的核心必须遵循第一原理：理想的随机交配，无选择、突变、迁移或近亲繁殖，并精确计算等位基因频率与基因型计数。目标是在 HWE 完全成立的零假设下，计算经验假阳性率。\n\n基础原理：\n- 在一个二倍体生物中，对于一个双等位基因座，若在随机交配下，真实等位基因-$A$ 的频率为 $p$，且 $q = 1 - p$，则基因型概率由 $(p + q)^2$ 的二项式展开给出，分别为 $AA$ 的 $p^2$、$Aa$ 的 $2pq$ 和 $aa$ 的 $q^2$。\n- 卡方拟合优度检验比较观测计数与期望计数。当等位基因频率是从数据中估计时，适当的自由度为 $1$。\n\n你的程序必须：\n- 在指定的真实等位基因-$A$ 频率 $p$ 下，模拟 $n$ 个二倍体个体的 $R$ 个重复样本，这些样本需符合精确的 HWE。\n- 在每次重复中，根据观测到的基因型计数计算样本等位基因-$A$ 的频率 $\\hat{p}$，在 $\\hat{p}$ 的基础上计算 HWE 下的期望基因型计数，计算自由度为 $1$ 的皮尔逊卡方统计量，并使用卡方生存函数计算相关的 $p$-value。\n- 记录每次重复是否为假阳性。假阳性定义为：即使数据是在真实 HWE 条件下生成的，其 $p$-value 仍然严格小于名义显著水平 $\\alpha$ 的事件。\n- 对于每个测试案例，返回在 $R$ 次重复中假阳性的比例（一个在 $[0,1]$ 区间内的小数）。\n\n数学规格：\n- 对于一组观测基因型计数为 $(O_{AA}, O_{Aa}, O_{aa})$ 且总和为 $n$ 的重复样本，计算样本等位基因-$A$ 的频率 $\\hat{p} = \\dfrac{2 O_{AA} + O_{Aa}}{2n}$ 以及 $\\hat{q} = 1 - \\hat{p}$。\n- 在 $\\hat{p}$ 的基础上计算 HWE 下的期望计数：$E_{AA} = n \\hat{p}^2$、$E_{Aa} = n \\cdot 2 \\hat{p} \\hat{q}$、$E_{aa} = n \\hat{q}^2$。\n- 计算皮尔逊卡方统计量\n\n$$\nX^2 \\;=\\; \\sum_{g \\in \\{AA, Aa, aa\\}} \\frac{(O_g - E_g)^2}{E_g}.\n$$\n\n- 计算 $p$-value 为 $P(\\chi^2_{1} \\ge X^2)$，其中 $\\chi^2_{1}$ 表示一个自由度为 $1$ 的卡方随机变量。\n\n实现要求：\n- 所有随机数生成必须使用提供的整数种子，以确保可重现性。\n- HWE 下的基因型抽样必须直接从一个多项分布中进行，其类别概率分别对应 $(AA, Aa, aa)$ 的 $p^2$、$2p(1-p)$ 和 $(1-p)^2$。\n- 每个测试案例的最终答案必须表示为 $[0,1]$ 区间内的小数，并四舍五入至小数点后恰好四位。请勿使用百分比符号。\n\n测试套件：\n为以下参数集实现模拟。每个测试案例都是一个元组 $(n, p, \\alpha, R, \\text{seed})$。\n- 案例 A：$(n = 20, p = 0.5, \\alpha = 0.05, R = 50000, \\text{seed} = 314159)$。\n- 案例 B：$(n = 50, p = 0.05, \\alpha = 0.05, R = 100000, \\text{seed} = 271828)$。\n- 案例 C：$(n = 200, p = 0.5, \\alpha = 0.05, R = 50000, \\text{seed} = 161803)$。\n- 案例 D：$(n = 1000, p = 0.5, \\alpha = 0.05, R = 50000, \\text{seed} = 141421)$。\n\n输出规格：\n- 你的程序应产生单行输出，其中包含一个以方括号包围的逗号分隔列表，列表中的结果顺序与上述测试案例相同。每个条目必须是四舍五入到小数点后恰好四位的浮点数。例如，包含四个结果的输出应类似于 $[0.0612,0.0840,0.0504,0.0489]$。\n\n关于覆盖范围与边界案例的说明：\n- 案例 A 探讨了小样本行为，围绕着期望计数至少为 $5$ 的常见建议。\n- 案例 B 探讨了稀有等位基因的情况，在这种情况下，小的期望计数可能会在卡方近似下提高假阳性率。\n- 案例 C 和 D 探讨了较大的 $n$，说明随着 $n$ 的增加，在理想的零假设下，假阳性率应趋近于名义值 $\\alpha$。\n- 不涉及任何物理单位。所有数值答案必须是指定格式的小数。", "solution": "任务是执行一个蒙特卡洛模拟，以估算在哈迪-温伯格平衡条件下，皮尔逊卡方检验的实际第一类错误率（即假阳性率）。零假设 $H_0$ 是群体处于HWE状态。模拟通过设计生成了 $H_0$ 为真的数据。因此，任何对 $H_0$ 的拒绝都是第一类错误。在大量重复中，此类拒绝的比例为该错误率提供了一个经验估计。理论上，只有当卡方检验的假设得到满足时（即每个基因型的期望计数足够大），该比率才会接近名义显著水平 $\\alpha$。\n\n每个测试案例的算法流程如下：\n\n1.  **初始化**：使用指定的 `seed` 初始化随机数生成器，以确保结果的可复现性。\n\n2.  **数据生成**：对于 $R$ 次重复中的每一次，生成一个包含 $n$ 个个体的随机样本。在真实等位基因A的频率为 $p$ 的HWE条件下，基因型 $\\{AA, Aa, aa\\}$ 的概率为 $\\{p^2, 2p(1-p), (1-p)^2\\}$。样本中这些基因型的计数 $(O_{AA}, O_{Aa}, O_{aa})$ 服从多项分布。\n\n3.  **参数估计**：对于每次重复，从样本数据中估计等位基因A的频率 $\\hat{p}$：\n    $$\n    \\hat{p} = \\frac{2 \\cdot O_{AA} + O_{Aa}}{2n}\n    $$\n\n4.  **计算期望计数**：基于估计的等位基因频率 $\\hat{p}$，计算在HWE零假设下的期望基因型计数：\n    $$\n    E_{AA} = n \\hat{p}^2, \\quad E_{Aa} = n \\cdot 2\\hat{p}(1-\\hat{p}), \\quad E_{aa} = n(1-\\hat{p})^2\n    $$\n\n5.  **卡方统计量计算**：为每次重复计算皮尔逊卡方统计量 $X^2$，它衡量观测计数与期望计数之间的差异：\n    $$\n    X^2 = \\sum_{g \\in \\{AA, Aa, aa\\}} \\frac{(O_g - E_g)^2}{E_g}\n    $$\n    当期望计数 $E_g$ 为0时，对应的项被定义为0，以避免除零错误。\n\n6.  **P-value的确定**：当等位基因频率是从数据中估计时，$X^2$ 统计量渐近服从自由度为1的卡方分布。$p$-value 使用 $\\chi^2_1$ 分布的生存函数（SF）计算：\n    $$\n    p\\text{-value} = P(\\chi^2_{df=1} \\ge X^2)\n    $$\n\n7.  **假阳性率**：如果 $p\\text{-value} < \\alpha$，则拒绝零假设。由于我们知道零假设为真，这种拒绝是一个假阳性。计算所有 $R$ 次重复中的假阳性总数，经验假阳性率即为：\n    $$\n    \\text{比率} = \\frac{\\text{假阳性数量}}{R}\n    $$\n该实现将利用 `numpy` 库进行高效的向量化计算，并使用 `scipy.stats.chi2` 进行统计计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Simulates genotype data under Hardy-Weinberg equilibrium (HWE) to\n    calculate the empirical false positive rate of the chi-square test.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, p, alpha, R, seed)\n        (20, 0.5, 0.05, 50000, 314159),   # Case A\n        (50, 0.05, 0.05, 100000, 271828), # Case B\n        (200, 0.5, 0.05, 50000, 161803),  # Case C\n        (1000, 0.5, 0.05, 50000, 141421), # Case D\n    ]\n\n    results = []\n    \n    for n, p, alpha, R, seed in test_cases:\n        # 1. Initialization\n        # Set the seed for reproducible random number generation.\n        rng = np.random.default_rng(seed)\n        \n        # 2. Data Generation\n        # Define HWE genotype probabilities: p^2 for AA, 2pq for Aa, q^2 for aa.\n        q = 1.0 - p\n        hwe_probs = np.array([p**2, 2*p*q, q**2])\n        \n        # Generate R replicate samples of size n from the multinomial distribution.\n        # observed_counts will be an (R, 3) NumPy array.\n        observed_counts = rng.multinomial(n, hwe_probs, size=R)\n        \n        # 3. Parameter Estimation\n        # Calculate the sample allele-A frequency (p_hat) for each replicate.\n        # O_AA is in column 0, O_Aa is in column 1.\n        p_hat = (2 * observed_counts[:, 0] + observed_counts[:, 1]) / (2 * n)\n        q_hat = 1.0 - p_hat\n        \n        # 4. Calculation of Expected Counts\n        # Calculate expected counts under HWE using the estimated p_hat.\n        E_AA = n * p_hat**2\n        E_Aa = n * 2 * p_hat * q_hat\n        E_aa = n * q_hat**2\n        \n        expected_counts = np.stack([E_AA, E_Aa, E_aa], axis=1)\n        \n        # 5. Chi-Square Statistic Calculation\n        # Compute the chi-square statistic for each replicate.\n        # Handle the case where expected_counts can be zero to avoid division by zero.\n        # If E_g is 0, then O_g must also be 0, and the term (O_g-E_g)^2/E_g is 0.\n        diff_sq = (observed_counts - expected_counts)**2\n        \n        # Initialize terms to zero.\n        terms = np.zeros_like(diff_sq)\n        \n        # Create a mask to avoid division by zero.\n        # This is the correct way to handle the sum: only divide where expected > 0.\n        mask = expected_counts > 0\n        terms[mask] = diff_sq[mask] / expected_counts[mask]\n        \n        # Sum the terms over the three genotypes for each replicate.\n        chi2_stat = np.sum(terms, axis=1)\n        \n        # 6. P-Value Determination\n        # Calculate the p-value from the chi-square survival function with df=1.\n        # The degrees of freedom is 1 (3 categories - 1 constraint - 1 estimated param).\n        p_values = chi2.sf(chi2_stat, df=1)\n        \n        # 7. False Positive Rate\n        # Count how many p-values are less than the significance level alpha.\n        false_positives_count = np.sum(p_values < alpha)\n        \n        # The empirical false positive rate is the fraction of false positives.\n        fp_rate = false_positives_count / R\n        \n        # Store the result.\n        results.append(fp_rate)\n\n    # Format the final results to exactly four decimal places.\n    formatted_results = [f\"{r:.4f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2396474"}]}