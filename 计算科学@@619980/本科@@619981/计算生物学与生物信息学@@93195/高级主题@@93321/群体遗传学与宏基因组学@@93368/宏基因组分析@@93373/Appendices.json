{"hands_on_practices": [{"introduction": "在宏基因组学分析中，原始测序读数并不总是直接反映微生物的真实丰度。一个典型的例子是16S rRNA基因扩增子测序，不同物种基因组中的16S rRNA基因拷贝数差异巨大，从而导致读数产生偏差。本练习将引导你通过一个计算实例，学习如何校正这种拷贝数变异，将观察到的读数转换为更准确的细胞丰度估计，这是计算$\\alpha$多样性等下游分析前至关重要的预处理步骤。[@problem_id:2405533]", "problem": "在一个包含四个细菌分类单元的单样本16S核糖体核糖核酸（rRNA）扩增子数据集中，对于分类单元$i$，设观测到的读数为$n_i$，每个基因组的16S rRNA操纵子拷贝数为$c_i$。假设一个抽样模型，其中预期的读数满足$n_i \\propto a_i \\, c_i$，而$a_i$是分类单元$i$的真实细胞丰度。定义一个应用于每个分类单元的乘法校正因子$f_i$，在将观测读数$n_i$转换为相对丰度之前应用该因子，目标是在所述模型下，得到的相对丰度与$a_i$成正比。使用您选择的$f_i$和以下数据，计算校正后组成的Shannon多样性指数$H'$，其中$H' = -\\sum_{i=1}^{4} p_i \\ln p_i$，$p_i$是校正后的相对丰度，$\\ln$是自然对数。\n\n样本包含：\n- 分类单元 $1$：观测读数 $n_1 = 4800$，16S拷贝数 $c_1 = 1$。\n- 分类单元 $2$：观测读数 $n_2 = 3200$，16S拷贝数 $c_2 = 2$。\n- 分类单元 $3$：观测读数 $n_3 = 1600$，16S拷贝数 $c_3 = 4$。\n- 分类单元 $4$：观测读数 $n_4 = 400$，16S拷贝数 $c_4 = 8$。\n\n使用自然对数（单位为奈特）报告$H'$。将最终数值答案四舍五入到四位有效数字。最终方框内的答案不应包含单位。", "solution": "首先必须验证问题陈述的科学合理性、完整性和客观性。\n\n**步骤1：提取已知条件**\n- 系统由一个包含4个细菌分类单元的单一样本组成。\n- 分类单元$i$的观测读数为$n_i$。\n- 分类单元$i$的16S rRNA操纵子拷贝数为$c_i$。\n- 分类单元$i$的真实细胞丰度为$a_i$。\n- 给定一个抽样模型：$n_i \\propto a_i \\, c_i$。\n- 将一个乘法校正因子$f_i$应用于$n_i$以获得校正后的读数，$n'_i = f_i n_i$。\n- 校正的目标是使得到的校正后读数与真实细胞丰度成正比：$n'_i \\propto a_i$。\n- Shannon多样性指数定义为$H' = -\\sum_{i=1}^{4} p_i \\ln p_i$，其中$p_i$是校正后的相对丰度。\n- 提供的数据如下：\n  - 分类单元1：$n_1 = 4800$，$c_1 = 1$。\n  - 分类单元2：$n_2 = 3200$，$c_2 = 2$。\n  - 分类单元3：$n_3 = 1600$，$c_3 = 4$。\n  - 分类单元4：$n_4 = 400$，$c_4 = 8$。\n- $H'$的最终答案需使用自然对数计算，并四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于16S rRNA基因扩增子测序分析中一个标准且公认的问题：由操纵子拷贝数变化引入的偏差。模型 $n_i \\propto a_i \\, c_i$ 是对这种偏差的一个简化但基本正确的表示。校正方法和Shannon多样性指数的使用是计算生物学和微生物生态学中的标准程序。该问题是科学合理的。\n- **问题适定：** 该问题提供了得出唯一解所需的所有必要数据和定义。选择校正因子$f_i$的指令受到“结果丰度必须与$a_i$成正比”这一条件的约束，这唯一地确定了$f_i$的函数形式。\n- **客观性：** 问题陈述使用了精确、定量且无偏见的语言。\n\n**步骤3：结论与行动**\n该问题被认为是有效的，因为它是科学合理的、问题适定的、客观的和完整的。将推导解答。\n\n**求解过程**\n问题要求我们在校正16S rRNA基因拷贝数变异后，计算一个细菌群落的Shannon多样性指数$H'$。\n\n首先，我们必须确定校正因子$f_i$的形式。\n观测读数的模型以比例关系给出：\n$$n_i \\propto a_i \\, c_i$$\n我们可以用一个比例常数$k$将其表示为一个方程，该常数被假定在样本中的所有分类单元中是统一的：\n$$n_i = k \\, a_i \\, c_i$$\n校正后的读数$n'_i$，是通过将一个乘法因子$f_i$应用于观测读数$n_i$得到的：\n$$n'_i = f_i \\, n_i$$\n代入$n_i$的表达式，我们得到：\n$$n'_i = f_i \\, (k \\, a_i \\, c_i)$$\n问题要求这些校正后的读数与真实细胞丰度$a_i$成正比：\n$$n'_i \\propto a_i$$\n为了使这个比例关系成立，在$n'_i$的表达式中乘以$a_i$的项必须对所有分类单元都是常数。即：\n$$f_i \\, k \\, c_i = \\text{常数}$$\n因为$k$已经是一个常数，这可以简化为：\n$$f_i \\, c_i = \\text{常数}$$\n这意味着校正因子$f_i$必须与拷贝数$c_i$成反比：\n$$f_i \\propto \\frac{1}{c_i}$$\n对校正因子最简单、最直接的选择是将其设置为拷贝数的倒数。任何其他选择，例如对于某个常数$\\lambda$，$f_i = \\lambda/c_i$，都会导致校正后的读数$n'_i$被$\\lambda$缩放，但这个缩放因子在计算相对丰度时会被抵消。因此，我们选择：\n$$f_i = \\frac{1}{c_i}$$\n现在与真实细胞丰度$a_i$成正比的校正后读数$n'_i$计算如下：\n$$n'_i = \\frac{n_i}{c_i}$$\n使用所提供的数据：\n- 对于分类单元1：$n'_1 = \\frac{n_1}{c_1} = \\frac{4800}{1} = 4800$\n- 对于分类单元2：$n'_2 = \\frac{n_2}{c_2} = \\frac{3200}{2} = 1600$\n- 对于分类单元3：$n'_3 = \\frac{n_3}{c_3} = \\frac{1600}{4} = 400$\n- 对于分类单元4：$n'_4 = \\frac{n_4}{c_4} = \\frac{400}{8} = 50$\n\n接下来，我们通过对各个校正后读数求和来计算总校正读数$N'$：\n$$N' = \\sum_{i=1}^{4} n'_i = 4800 + 1600 + 400 + 50 = 6850$$\n然后，通过将每个校正后读数$n'_i$除以总校正读数$N'$来计算校正后的相对丰度$p_i$：\n$$p_i = \\frac{n'_i}{N'}$$\n- $p_1 = \\frac{4800}{6850} = \\frac{480}{685} = \\frac{96}{137}$\n- $p_2 = \\frac{1600}{6850} = \\frac{160}{685} = \\frac{32}{137}$\n- $p_3 = \\frac{400}{6850} = \\frac{40}{685} = \\frac{8}{137}$\n- $p_4 = \\frac{50}{6850} = \\frac{5}{685} = \\frac{1}{137}$\n我们验证相对丰度之和为$1$：$\\frac{96+32+8+1}{137} = \\frac{137}{137} = 1$。\n\n最后，我们使用公式$H' = -\\sum_{i=1}^{4} p_i \\ln p_i$计算Shannon多样性指数$H'$：\n$$H' = -\\left( p_1 \\ln p_1 + p_2 \\ln p_2 + p_3 \\ln p_3 + p_4 \\ln p_4 \\right)$$\n代入$p_i$的值：\n$$H' = -\\left( \\frac{96}{137} \\ln\\left(\\frac{96}{137}\\right) + \\frac{32}{137} \\ln\\left(\\frac{32}{137}\\right) + \\frac{8}{137} \\ln\\left(\\frac{8}{137}\\right) + \\frac{1}{137} \\ln\\left(\\frac{1}{137}\\right) \\right)$$\n现在我们对这个表达式进行数值计算：\n- $\\frac{96}{137} \\ln\\left(\\frac{96}{137}\\right) \\approx (0.70073) \\times (-0.35567) \\approx -0.249214$\n- $\\frac{32}{137} \\ln\\left(\\frac{32}{137}\\right) \\approx (0.23358) \\times (-1.45424) \\approx -0.339714$\n- $\\frac{8}{137} \\ln\\left(\\frac{8}{137}\\right) \\approx (0.05839) \\times (-2.84055) \\approx -0.165859$\n- $\\frac{1}{137} \\ln\\left(\\frac{1}{137}\\right) \\approx (0.00730) \\times (-4.91998) \\approx -0.035915$\n\n将这些项相加：\n$$\\sum p_i \\ln p_i \\approx -0.249214 - 0.339714 - 0.165859 - 0.035915 = -0.790702$$\n因此，Shannon多样性指数为：\n$$H' = -(-0.790702) = 0.790702$$\n按照要求将结果四舍五入到四位有效数字，我们得到$0.7907$。", "answer": "$$\n\\boxed{0.7907}\n$$", "id": "2405533"}, {"introduction": "在理解微生物生态系统时，比较不同样本之间的群落构成差异（即$\\beta$多样性）与分析单个样本内的多样性（$\\alpha$多样性）同样重要。Bray-Curtis相异度是生态学中量化群落间组成差异最经典的指标之一，它同时考虑了物种的存在/缺失和丰度信息。通过编写代码实现Bray-Curtis相异度的计算，你将亲身体验该指标如何捕捉从完全相同到完全不同的群落结构，并理解为何它在宏基因组学研究中如此常用。[@problem_id:2405539]", "problem": "给定两个非负整数值的群落丰度向量，它们代表通过16S核糖体核糖核酸（rRNA）基因扩增子测序或鸟枪法宏基因组测序获得的特定分类单元的读数计数。对于两个群落，其丰度向量为 $\\mathbf{x} = (x_1, x_2, \\dots, x_K)$ 和 $\\mathbf{y} = (y_1, y_2, \\dots, y_K)$，这两个向量是基于包含 $K$ 个分类单元的相同有序列表定义的，其Bray–Curtis相异度 $D_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y})$ 定义如下：\n$$\nD_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y}) = \\frac{\\sum_{i=1}^{K} \\lvert x_i - y_i \\rvert}{\\sum_{i=1}^{K} (x_i + y_i)} \\, .\n$$\n该值为无量纲量，当分母不为零时，其值落在闭区间 $[0,1]$ 内。\n\n请编写一个完整的程序，根据上述定义，为下列每一对测试群落计算Bray–Curtis相异度。对于每一对，其群落向量均基于相同的固定分类单元顺序指定。所有条目均为非负整数，代表读数计数。\n\n测试集（每个项目为一对 $(\\mathbf{x}, \\mathbf{y})$）：\n- 情况A（一般情况）：$\\mathbf{x} = (12, 3, 0, 5)$ 和 $\\mathbf{y} = (10, 5, 0, 3)$。\n- 情况B（相同群落）：$\\mathbf{x} = (7, 0, 4)$ 和 $\\mathbf{y} = (7, 0, 4)$。\n- 情况C（分类单元组成不相交）：$\\mathbf{x} = (0, 9, 0, 0)$ 和 $\\mathbf{y} = (0, 0, 0, 9)$。\n- 情况D（一个群落无观测读数，而另一个有）：$\\mathbf{x} = (0, 0, 0)$ 和 $\\mathbf{y} = (5, 0, 0)$。\n- 情况E（超高丰度的共享生物体占主导）：$\\mathbf{x} = (10000, 1, 1, 1)$ 和 $\\mathbf{y} = (10000, 0, 2, 1)$。\n\n对于每种情况，请精确计算给定的 $D_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y})$。如果分母 $\\sum_{i=1}^{K} (x_i + y_i)$ 等于 $0$，则相异度未定义；所提供的测试用例均不属于这种未定义的情形。\n\n最终输出格式：您的程序应生成单行输出，其中按顺序包含情况A至E的结果，结果为精确到 $6$ 位小数的十进制数，并以逗号分隔列表的形式聚合在方括号内。例如，输出必须形如 $[a,b,c,d,e]$，其中 $a$、$b$、$c$、$d$ 和 $e$ 分别是情况A、B、C、D和E的四舍五入值，不含任何额外文本。", "solution": "问题陈述已经过验证，被认为是可解决的。它具有科学依据、提法明确且客观。它要求将计算生物学中一个标准的、定义明确的公式——Bray-Curtis相异度，直接应用于几个明确的测试用例。我们开始进行计算。\n\n两个群落丰度向量 $\\mathbf{x} = (x_1, x_2, \\dots, x_K)$ 和 $\\mathbf{y} = (y_1, y_2, \\dots, y_K)$ 之间的Bray-Curtis相异度 $D_{\\mathrm{BC}}$ 定义为：\n$$\nD_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y}) = \\frac{\\sum_{i=1}^{K} \\lvert x_i - y_i \\rvert}{\\sum_{i=1}^{K} (x_i + y_i)}\n$$\n该度量量化了两个样本之间在组成上的相异性。值为 $0$ 表示组成相同，值为 $1$ 表示没有共享的分类单元。我们现在将为每个指定情况计算该值。\n\n情况A：一般情况\n给定 $\\mathbf{x} = (12, 3, 0, 5)$ 和 $\\mathbf{y} = (10, 5, 0, 3)$。\n分子中绝对差之和为：\n$$\n\\sum_{i=1}^{4} \\lvert x_i - y_i \\rvert = \\lvert 12 - 10 \\rvert + \\lvert 3 - 5 \\rvert + \\lvert 0 - 0 \\rvert + \\lvert 5 - 3 \\rvert = 2 + 2 + 0 + 2 = 6\n$$\n分母中丰度之和为：\n$$\n\\sum_{i=1}^{4} (x_i + y_i) = (12 + 10) + (3 + 5) + (0 + 0) + (5 + 3) = 22 + 8 + 0 + 8 = 38\n$$\n相异度为：\n$$\nD_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y}) = \\frac{6}{38} \\approx 0.1578947...\n$$\n\n情况B：相同群落\n给定 $\\mathbf{x} = (7, 0, 4)$ 和 $\\mathbf{y} = (7, 0, 4)$。\n分子为：\n$$\n\\sum_{i=1}^{3} \\lvert x_i - y_i \\rvert = \\lvert 7 - 7 \\rvert + \\lvert 0 - 0 \\rvert + \\lvert 4 - 4 \\rvert = 0 + 0 + 0 = 0\n$$\n由于分子为 $0$ 且分母非零，相异度为 $0$。\n$$\nD_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y}) = 0\n$$\n\n情况C：组成不相交\n给定 $\\mathbf{x} = (0, 9, 0, 0)$ 和 $\\mathbf{y} = (0, 0, 0, 9)$。\n分子为：\n$$\n\\sum_{i=1}^{4} \\lvert x_i - y_i \\rvert = \\lvert 0 - 0 \\rvert + \\lvert 9 - 0 \\rvert + \\lvert 0 - 0 \\rvert + \\lvert 0 - 9 \\rvert = 0 + 9 + 0 + 9 = 18\n$$\n分母为：\n$$\n\\sum_{i=1}^{4} (x_i + y_i) = (0 + 0) + (9 + 0) + (0 + 0) + (0 + 9) = 0 + 9 + 0 + 9 = 18\n$$\n相异度为：\n$$\nD_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y}) = \\frac{18}{18} = 1\n$$\n\n情况D：一个空群落\n给定 $\\mathbf{x} = (0, 0, 0)$ 和 $\\mathbf{y} = (5, 0, 0)$。请注意，$\\mathbf{x}$ 并非一个真正的空群落，因为它是与含有分类单元的 $\\mathbf{y}$ 进行比较的；更确切地说，对于所有正在考虑的分类单元，$\\mathbf{x}$ 的观测计数均为零。\n分子为：\n$$\n\\sum_{i=1}^{3} \\lvert x_i - y_i \\rvert = \\lvert 0 - 5 \\rvert + \\lvert 0 - 0 \\rvert + \\lvert 0 - 0 \\rvert = 5 + 0 + 0 = 5\n$$\n分母为：\n$$\n\\sum_{i=1}^{3} (x_i + y_i) = (0 + 5) + (0 + 0) + (0 + 0) = 5 + 0 + 0 = 5\n$$\n相异度为：\n$$\nD_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y}) = \\frac{5}{5} = 1\n$$\n\n情况E：超高丰度的共享生物体\n给定 $\\mathbf{x} = (10000, 1, 1, 1)$ 和 $\\mathbf{y} = (10000, 0, 2, 1)$。\n分子为：\n$$\n\\sum_{i=1}^{4} \\lvert x_i - y_i \\rvert = \\lvert 10000 - 10000 \\rvert + \\lvert 1 - 0 \\rvert + \\lvert 1 - 2 \\rvert + \\lvert 1 - 1 \\rvert = 0 + 1 + 1 + 0 = 2\n$$\n分母为：\n$$\n\\sum_{i=1}^{4} (x_i + y_i) = (10000 + 10000) + (1 + 0) + (1 + 2) + (1 + 1) = 20000 + 1 + 3 + 2 = 20006\n$$\n相异度为：\n$$\nD_{\\mathrm{BC}}(\\mathbf{x}, \\mathbf{y}) = \\frac{2}{20006} = \\frac{1}{10003} \\approx 0.00009997...\n$$\n\n最终结果按要求四舍五入到 $6$ 位小数，如下所示：\n- 情况A: $0.157895$\n- 情况B: $0.000000$\n- 情况C: $1.000000$\n- 情况D: $1.000000$\n- 情况E: $0.000100$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Bray-Curtis dissimilarity for a test suite of community abundance vectors.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple containing two NumPy arrays (x, y).\n    test_cases = [\n        # Case A: General case\n        (np.array([12, 3, 0, 5]), np.array([10, 5, 0, 3])),\n        # Case B: Identical communities\n        (np.array([7, 0, 4]), np.array([7, 0, 4])),\n        # Case C: Disjoint composition\n        (np.array([0, 9, 0, 0]), np.array([0, 0, 0, 9])),\n        # Case D: One community with no observed reads\n        (np.array([0, 0, 0]), np.array([5, 0, 0])),\n        # Case E: Hyper-abundant shared organism\n        (np.array([10000, 1, 1, 1]), np.array([10000, 0, 2, 1])),\n    ]\n\n    results = []\n    for x, y in test_cases:\n        # The Bray-Curtis dissimilarity is defined as:\n        # D_BC(x, y) = sum(|x_i - y_i|) / sum(x_i + y_i)\n\n        # Calculate the numerator: sum of absolute differences between corresponding elements.\n        numerator = np.sum(np.abs(x - y))\n\n        # Calculate the denominator: sum of all elements in both vectors.\n        denominator = np.sum(x + y)\n\n        # Calculate the dissimilarity. The problem guarantees the denominator is non-zero.\n        if denominator == 0:\n            # This case is stated not to occur in the test suite.\n            # If it did, the dissimilarity would be undefined.\n            # We would handle it here, perhaps by appending a specific value like 'nan'.\n            # For this problem, we assume bray_curtis is always calculable.\n            # A common convention is to define it as 0, but we follow the problem.\n            bray_curtis = 0.0\n        else:\n            bray_curtis = numerator / denominator\n        \n        results.append(bray_curtis)\n\n    # Format the results to exactly 6 decimal places, as specified.\n    # The \"{:.6f}\".format() method ensures rounding and padding with zeros.\n    formatted_results = [\"{:.6f}\".format(r) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2405539"}, {"introduction": "宏基因组学分析的魅力在于能够揭示复杂的生物互作关系，其中病毒与宿主的相互作用网络是研究热点。本练习将带你进入一个高级应用场景：通过整合CRISPR间隔子匹配（宿主免疫系统的“记忆”）和密码子使用偏好性分析（病毒对宿主翻译机制的适应）这两种独立的生物学证据，来预测一个未知病毒的宿主。这个实践不仅能巩固你的编程和算法实现能力，更能让你体验如何将不同的数据信号融合成一个统一的预测模型，解决前沿的生物学问题。[@problem_id:2405543]", "problem": "给定一个简化的、自包含的框架，用于通过结合成簇规律间隔短回文重复序列 (Clustered Regularly Interspaced Short Palindromic Repeats, CRISPR) 的间隔序列匹配和密码子使用偏好性分析，从肠道鸟枪法宏基因组数据集中预测新的病毒 contig 最有可能的原核宿主。你的任务是实现一个程序，根据这两种证据类型为每个候选宿主计算宿主得分，并为每个测试 contig 选择综合得分最高的宿主。\n\n基本原理与定义：\n- CRISPR 生物学：原核宿主将源自移动遗传元件（例如病毒）的短间隔序列整合到 CRISPR 阵列中。宿主的间隔序列与病毒 contig 之间的强间隔序列-原间隔序列匹配为宿主-病毒相互作用提供了证据。\n- 密码子使用偏好性：不同的宿主在所有可能的脱氧核糖核酸 (deoxyribonucleic acid, DNA) 密码子集合中表现出特征性的密码子使用分布。感染宿主的病毒通常表现出与该宿主更相似的密码子使用情况。密码子使用情况可以用一个包含 $64$ 种可能 DNA 密码子的集合上的频率向量来表示。\n- 汉明距离：对于两个等长为 $L$ 的字符串 $x$ 和 $y$，汉明距离为 $d_{\\mathrm{H}}(x,y) = \\left|\\left\\{ i \\in \\{1,\\dots,L\\} : x_i \\neq y_i \\right\\}\\right|$。\n- 反向互补序列：对于一个 DNA 字符串 $s \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}^L$，其反向互补序列 $\\mathrm{rc}(s)$ 是将 $s$ 反转并进行碱基互补（$\\mathrm{A}\\leftrightarrow\\mathrm{T}$ 和 $\\mathrm{C}\\leftrightarrow\\mathrm{G}$）后得到的序列。\n- 余弦相似度：对于非负向量 $u, v \\in \\mathbb{R}^{64}$，余弦相似度为 $\\cos(u,v) = \\dfrac{u \\cdot v}{\\|u\\|_2 \\, \\|v\\|_2}$，其中点号表示欧几里得内积，$\\|\\cdot\\|_2$ 表示欧几里得范数。\n\n需实现的评分模型：\n1) 宿主 $h$ 的 CRISPR 证据：\n   - 设宿主 $h$ 的间隔序列集合为 $S_h = \\{ s^{(h)}_1, \\dots, s^{(h)}_{n_h} \\}$，其中间隔序列 $s^{(h)}_j$ 的长度为 $L_j$。\n   - 对于病毒 contig 字符串 $C$ 和给定的最大错配阈值 $m_{\\max}$，定义间隔序列 $s$ 与 $C$ 的最佳错配数为\n     $$m^*(s,C) = \\min\\left\\{ \\min_{w \\in \\mathcal{W}(C, L)} d_{\\mathrm{H}}(s,w), \\; \\min_{w \\in \\mathcal{W}(C, L)} d_{\\mathrm{H}}(\\mathrm{rc}(s),w) \\right\\}$$\n     其中 $\\mathcal{W}(C, L)$ 是 $C$ 的所有长度为 $L$ 的窗口的多重集。\n   - 间隔序列 $s$ 的贡献为\n     $$ \\phi(s,C) = \\begin{cases} \\frac{L - m^*(s,C)}{L}, & \\text{若 } m^*(s,C) \\le m_{\\max} \\\\ 0, & \\text{其他情况} \\end{cases} $$\n   - 宿主 $h$ 的 CRISPR 证据分数是平均间隔序列贡献\n     $$ E_h(C) = \\begin{cases} \\frac{1}{n_h} \\sum_{j=1}^{n_h} \\phi\\left(s^{(h)}_j, C\\right), & \\text{若 } n_h \\ge 1 \\\\ 0, & \\text{若 } n_h = 0 \\end{cases} $$\n\n2) 宿主 $h$ 的密码子使用相似性：\n   - 对于一个长度可被 $3$ 整除的编码 DNA 序列 $X$，定义其在所有 DNA 三联体（按字典序排列）上的密码子计数向量 $c(X) \\in \\mathbb{N}^{64}$。通过下式定义频率向量 $f(X) \\in [0,1]^{64}$：\n     $$f(X) = \\frac{c(X)}{\\sum_{i=1}^{64} c_i(X)}.$$\n   - 对于宿主编码序列为 $H_h$ 的宿主 $h$ 和病毒开放阅读框 (open reading frame, ORF) 序列 $V$，计算\n     $$U_h(V) = \\cos\\left(f(H_h), f(V)\\right) = \\frac{f(H_h) \\cdot f(V)}{\\|f(H_h)\\|_2 \\, \\|f(V)\\|_2}.$$\n\n3) 综合分数和预测：\n   - 给定非负权重 $w_C$ 和 $w_U$，且 $w_C + w_U = 1$，定义\n     $$T_h(C,V) = w_C \\, E_h(C) + w_U \\, U_h(V).$$\n   - 预测宿主为使 $T_h(C,V)$ 最大化的索引 $h$。如果 $T_h$ 出现完全平局，则选择最小的那个索引。\n\n使用的参数值：\n- 候选宿主数量：$3$ 个，索引为 $0,1,2$。\n- 最大错配阈值：$m_{\\max} = 1$。\n- 权重：$w_C = 0.7$，$w_U = 0.3$。\n- 宿主 CRISPR 间隔序列：\n  - 宿主 $0$：$S_0 = \\{\\texttt{ATGCTTACGA}, \\texttt{TTTATATAAA}\\}$。\n  - 宿主 $1$：$S_1 = \\{\\texttt{GCGCCGCGGC}, \\texttt{CCGGGCGGCC}\\}$。\n  - 宿主 $2$：$S_2 = \\{\\}$ (无间隔序列)。\n- 宿主编码 DNA 序列 $H_h$ 是通过将以下密码子模式重复 $30$ 次构建的（按顺序连接三联体，然后重复连接成的块）：\n  - 宿主 $0$ 模式：[TTT, TTA, TAT, ATA, ATT, AAA, AAT]。\n  - 宿主 $1$ 模式：[GCG, GGC, CCG, CGC, GCC, CCC, GGG]。\n  - 宿主 $2$ 模式：[CTG, GAT, ATG, ACC, TCC, GTA, GTT]。\n\n测试套件：\n提供四个病毒测试用例。每个测试用例 $i$ 提供一个 contig 字符串 $C_i$ 和一个病毒 ORF 序列 $V_i$，该序列通过将一个密码子模式重复 $5$ 次定义，其构建方式与宿主序列类似。\n- 测试 $1$（理想情况；宿主 $0$ 有强 CRISPR 证据）：\n  - $C_1 =$ 字符串 \"GGGATGCTTACGATTTACGCCGTA\"。\n  - $V_1$ 模式：[TTT, TTA, TAT, ATA, ATT, AAA, AAT]。\n- 测试 $2$（错配边界情况；CRISPR 证据平局，密码子使用偏向宿主 1）：\n  - $C_2 =$ 字符串 \"AAAGCGCCGCGGATTGTTTTATATCAAACCC\"。\n  - $V_2$ 模式：[GCG, GGC, CCG, CGC, GCC, CCC, GGG]。\n- 测试 $3$（无 CRISPR 匹配；完全依赖密码子使用；偏向宿主 2）：\n  - $C_3 =$ 字符串 \"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\"。\n  - $V_3$ 模式：[CTG, GAT, ATG, ACC, TCC, GTA, GTT]。\n- 测试 $4$（边缘案例交互；宿主 0 的一个错配 CRISPR 与宿主 1 的强密码子使用偏好性对比；权重有利于 CRISPR）：\n  - $C_4 =$ 字符串 \"TTTATGCTTACGGAAA\"。\n  - $V_4$ 模式：[GCG, GGC, CCG, CGC, GCC, CCC, GGG]。\n\n要求的最终输出格式：\n- 你的程序必须生成一行输出，其中包含对 $4$ 个测试的预测结果，形式为单个方括号内用逗号分隔的整数列表，不含空格。例如，输出必须看起来像“[0,1,2,0]”，但使用的是你的程序计算出的实际结果。\n\n注意：\n- 所有 DNA 均为大写，并使用来自 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 的碱基。\n- 在计算密码子使用情况时，将序列视为已处于读码框内且长度可被 $3$ 整除；不要对终止密码子进行特殊翻译或过滤。使用所有观察到的三联体构成 $f(X)$。\n- 对于 CRISPR 匹配，扫描 contig 的所有窗口，以匹配正向间隔序列及其反向互补序列。\n- 你的程序中报告的所有量都必须根据所提供的定义计算得出；不要硬编码预期答案。", "solution": "所述问题是有效的。它在科学上基于宏基因组分析的原理，特别是使用 CRISPR-间隔序列同源性和密码子使用偏好性进行宿主-病毒关联。该问题是适定的，提供了计算每个测试用例唯一解所需的所有必要定义、参数和数据。目标定义明确，评分模型在数学上是合理的，没有歧义。我们将着手构建解决方案。\n\n核心任务是通过最大化复合分数 $T_h$ 来确定给定病毒 contig 最有可能的宿主。对于每个候选宿主 $h \\in \\{0, 1, 2\\}$，该分数是两个组成部分的加权平均：一个 CRISPR 证据分数 $E_h(C)$ 和一个密码子使用相似性分数 $U_h(V)$。总分定义为：\n$$T_h(C,V) = w_C \\, E_h(C) + w_U \\, U_h(V)$$\n问题指定权重为 $w_C = 0.7$ 和 $w_U = 0.3$。\n\n首先，我们解决 CRISPR 证据分数 $E_h(C)$ 的计算。该分数反映了过去相互作用的直接物理证据。其计算涉及几个步骤：\n1. 对于属于宿主 $h$ 的每个长度为 $L$ 的间隔序列 $s$，我们必须在病毒 contig $C$ 中找到其最佳匹配。此搜索必须同时考虑间隔序列的正向 $s$ 及其反向互补序列 $\\mathrm{rc}(s)$。反向互补序列是通过反转序列字符串并将每个核苷酸替换为其沃森-克里克碱基对（$\\mathrm{A} \\leftrightarrow \\mathrm{T}$，$\\mathrm{C} \\leftrightarrow \\mathrm{G}$）来形成的。\n2. 匹配的质量与汉明距离 $d_{\\mathrm{H}}(x,y)$ 成反比，汉明距离计算两个等长字符串 $x$ 和 $y$ 在不同位置上的字符数。\n3. 对于给定的间隔序列 $s$，我们通过扫描 contig $C$ 的所有长度为 $L$ 的窗口，并找到与 $s$ 和 $\\mathrm{rc}(s)$ 的最小汉明距离，来计算最佳错配数 $m^*(s,C)$。\n$$m^*(s,C) = \\min\\left\\{ \\min_{w \\in \\mathcal{W}(C, L)} d_{\\mathrm{H}}(s,w), \\; \\min_{w \\in \\mathcal{W}(C, L)} d_{\\mathrm{H}}(\\mathrm{rc}(s),w) \\right\\}$$\n其中 $\\mathcal{W}(C, L)$ 表示 $C$ 的所有长度为 $L$ 的子串的多重集。\n4. 一个显著的匹配被定义为 $m^*(s,C)$ 小于或等于指定阈值 $m_{\\max} = 1$ 的匹配。这样一个间隔序列的贡献 $\\phi(s,C)$ 是一个反映匹配质量的归一化分数：\n$$\\phi(s,C) = \\begin{cases}\n \\dfrac{L - m^*(s,C)}{L}, & \\text{若 } m^*(s,C) \\le m_{\\max} \\\\\n 0, & \\text{其他情况。}\n \\end{cases}$$\n完美匹配（$m^* = 0$）贡献为 $1$，有 $1$ 个错配的匹配贡献为 $(L-1)/L$，任何错配超过 $m_{\\max}$ 的匹配贡献为 $0$。\n5. 宿主 $h$ 的最终 CRISPR 证据分数 $E_h(C)$ 是其所有间隔序列贡献的算术平均值。如果一个宿主没有间隔序列（$n_h = 0$），其分数为 $0$。\n$$E_h(C) = \\begin{cases}\n \\dfrac{1}{n_h} \\sum_{j=1}^{n_h} \\phi\\!\\left(s^{(h)}_j, C\\right), & \\text{若 } n_h \\ge 1 \\\\\n 0, & \\text{若 } n_h = 0。\n \\end{cases}$$\n\n其次，我们实现密码子使用相似性分数 $U_h(V)$。这个分数基于病毒的密码子使用倾向于适应其宿主的密码子使用的原理。\n1. 我们建立一个包含所有 $64$ 个 DNA 密码子的固定有序基（例如，从 `AAA` 到 `TTT` 的字典序）。\n2. 对于任何编码序列 $X$（宿主的串联 CDS $H_h$ 或病毒 ORF $V$），我们计算一个 64 维的密码子频率向量 $f(X)$。这是通过首先计算 $X$ 中 64 个密码子中每个密码子的出现次数以获得计数向量 $c(X)$，然后通过密码子总数对该向量进行归一化来实现的：\n$$f(X) = \\frac{c(X)}{\\sum_{i=1}^{64} c_i(X)}$$\n我们根据提供的模式为每个宿主的编码物质预先计算这些频率向量 $f(H_h)$。\n3. 相似性分数 $U_h(V)$ 随后计算为宿主频率向量 $f(H_h)$ 和病毒频率向量 $f(V)$ 之间的余弦相似度：\n$$U_h(V) = \\cos\\!\\left(f(H_h), f(V)\\right) = \\frac{f(H_h) \\cdot f(V)}{\\|f(H_h)\\|_2 \\, \\|f(V)\\|_2}$$\n该分数范围从 $0$（没有共同的密码子）到 $1$（频率分布完全相同）。\n\n最后，对于每个病毒测试用例 $(C_i, V_i)$，我们计算总分 $T_0, T_1, T_2$。预测的宿主是产生最大分数的索引 $h$，即 $\\arg\\max_h T_h(C_i, V_i)$。在出现完全平局的情况下，问题指定选择最小的宿主索引，这个规则可以由标准的 `argmax` 实现自然处理。程序将对所有 $4$ 个测试用例执行此完整流程，并报告最终的预测结果。", "answer": "```python\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Computes host predictions for novel viral contigs based on CRISPR and codon usage.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    NUM_HOSTS = 3\n    M_MAX = 1\n    W_C = 0.7\n    W_U = 0.3\n\n    HOST_SPACERS = {\n        0: ['ATGCTTACGA', 'TTTATATAAA'],\n        1: ['GCGCCGCGGC', 'CCGGGCGGCC'],\n        2: []\n    }\n\n    HOST_PATTERNS = {\n        0: ['TTT', 'TTA', 'TAT', 'ATA', 'ATT', 'AAA', 'AAT'],\n        1: ['GCG', 'GGC', 'CCG', 'CGC', 'GCC', 'CCC', 'GGG'],\n        2: ['CTG', 'GAT', 'ATG', 'ACC', 'TCC', 'GTA', 'GTT']\n    }\n\n    TEST_CASES = [\n        {\n            \"C\": \"GGGATGCTTACGATTTACGCCGTA\",\n            \"V_pattern\": ['TTT', 'TTA', 'TAT', 'ATA', 'ATT', 'AAA', 'AAT']\n        },\n        {\n            \"C\": \"AAAGCGCCGCGGATTGTTTTATATCAAACCC\",\n            \"V_pattern\": ['GCG', 'GGC', 'CCG', 'CGC', 'GCC', 'CCC', 'GGG']\n        },\n        {\n            \"C\": \"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\",\n            \"V_pattern\": ['CTG', 'GAT', 'ATG', 'ACC', 'TCC', 'GTA', 'GTT']\n        },\n        {\n            \"C\": \"TTTATGCTTACGGAAA\",\n            \"V_pattern\": ['GCG', 'GGC', 'CCG', 'CGC', 'GCC', 'CCC', 'GGG']\n        }\n    ]\n\n    # --- Helper Functions ---\n    def reverse_complement(dna_seq):\n        complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        return \"\".join(complement_map[base] for base in reversed(dna_seq))\n\n    def hamming_distance(s1, s2):\n        return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\n    # --- Scoring Functions ---\n    def compute_crispr_score(contig, spacers):\n        if not spacers:\n            return 0.0\n\n        total_phi = 0.0\n        for spacer in spacers:\n            L = len(spacer)\n            if L > len(contig):\n                continue\n\n            rc_spacer = reverse_complement(spacer)\n            \n            min_dist_s = L + 1\n            min_dist_rc = L + 1\n\n            for i in range(len(contig) - L + 1):\n                window = contig[i:i+L]\n                min_dist_s = min(min_dist_s, hamming_distance(spacer, window))\n                min_dist_rc = min(min_dist_rc, hamming_distance(rc_spacer, window))\n\n            m_star = min(min_dist_s, min_dist_rc)\n            \n            phi = 0.0\n            if m_star <= M_MAX:\n                phi = (L - m_star) / L\n            total_phi += phi\n        \n        return total_phi / len(spacers)\n\n    def get_codon_freq_vector(sequence, codon_map):\n        counts = np.zeros(64, dtype=float)\n        num_codons = len(sequence) // 3\n        if num_codons == 0:\n            return counts\n\n        for i in range(num_codons):\n            codon = sequence[i*3:(i+1)*3]\n            if codon in codon_map:\n                counts[codon_map[codon]] += 1\n        \n        return counts / num_codons\n\n    def compute_codon_usage_score(vec1, vec2):\n        norm1 = np.linalg.norm(vec1)\n        norm2 = np.linalg.norm(vec2)\n        if norm1 == 0 or norm2 == 0:\n            return 0.0\n        return np.dot(vec1, vec2) / (norm1 * norm2)\n\n    # --- Main Logic ---\n\n    # Pre-compute host data\n    codons = [''.join(p) for p in product('ACGT', repeat=3)]\n    codon_map = {codon: i for i, codon in enumerate(codons)}\n    \n    host_sequences = {h: ''.join(p) * 30 for h, p in HOST_PATTERNS.items()}\n    host_freq_vectors = {\n        h: get_codon_freq_vector(seq, codon_map) for h, seq in host_sequences.items()\n    }\n\n    results = []\n    for test in TEST_CASES:\n        contig = test[\"C\"]\n        viral_seq = ''.join(test[\"V_pattern\"]) * 5\n        viral_freq_vector = get_codon_freq_vector(viral_seq, codon_map)\n\n        host_total_scores = []\n        for h in range(NUM_HOSTS):\n            e_h = compute_crispr_score(contig, HOST_SPACERS[h])\n            u_h = compute_codon_usage_score(host_freq_vectors[h], viral_freq_vector)\n            t_h = W_C * e_h + W_U * u_h\n            host_total_scores.append(t_h)\n            \n        prediction = np.argmax(host_total_scores)\n        results.append(prediction)\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2405543"}]}