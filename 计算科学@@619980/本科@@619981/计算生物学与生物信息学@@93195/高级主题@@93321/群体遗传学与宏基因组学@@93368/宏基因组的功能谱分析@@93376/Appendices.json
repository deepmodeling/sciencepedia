{"hands_on_practices": [{"introduction": "在我们依赖宏基因组数据进行功能分析之前，首先必须认识到那些可能扭曲我们观察结果的潜在陷阱。本练习通过一个假设场景，揭示了在解读功能谱时必须考虑的几个关键偏见，例如基因拷贝数变异、质粒的存在以及DNA提取效率的差异。理解这些偏见是进行严谨科学分析、确保结论可靠性的关键第一步。[@problem_id:2392677]", "problem": "在鸟枪法宏基因组功能谱分析中，短读长从提取的脱氧核糖核酸（DNA）池中被采样，然后比对到基因家族以估计其丰度。考虑一个包含两种细菌物种（记为 $S_1$ 和 $S_2$）的群落，它们的细胞数量相等，均为 $N_1 = N_2 = 10^6$ 个细胞。这两个物种都携带一个基因家族 $g$，该基因家族编码一种与抗生素耐药性相关的特定酶。在 $S_1$ 中，$g$ 存在于染色体上，每个细胞有 $c_{1g} = 1$ 个拷贝。在 $S_2$ 中，$g$ 在染色体上有 $c_{2g} = 3$ 个拷贝，此外还存在于一个质粒上，平均每个细胞有 $h_{2g} = 8$ 个拷贝。由于细胞壁特性的不同，这两个物种的DNA提取效率也不同：$S_1$ 的提取效率为 $e_1 = 0.5$，$S_2$ 的提取效率为 $e_2 = 1.0$。假设读长长度固定，DNA随机片段化，并且读长从提取的DNA池中近似均匀地采样。设基因 $g$ 的长度为 $L_g$ 个核苷酸，并假设在此场景中，两个分类单元中的基因长度相同。\n\n功能谱分析中一个常见的简化假设是，测序数据中基因家族 $g$ 的丰度与携带 $g$ 的生物体的丰度成正比。基于鸟枪法测序的第一性原理和上述设定，当此假设应用于真实的宏基因组时，以下哪些陈述正确地指出了该假设引入的偏差？\n\nA. 即使细胞数量相同，每个细胞携带更多 $g$ 基因拷贝（包括染色体上或染色体外元件上的拷贝）的生物体，看起来也会比携带较少拷贝的等量生物体更丰富。\n\nB. 即使在每个细胞的拷贝数和提取效率相等的情况下，物种间的基因组大小差异会系统性地导致更多读长比对到拥有更大基因组的物种中的基因 $g$ 上，从而高估这些物种的丰度。\n\nC. DNA提取或细胞裂解效率的差异性使得读长计数与细胞计数脱钩，因此，与更难裂解的生物体相比，每个细胞能产出更多可提取DNA的生物体，根据基因 $g$ 的丰度来看会显得更丰富。\n\nD. 如果基因 $g$ 位于高拷贝质粒或其他可移动遗传元件上，其读长丰度相对于宿主的细胞丰度可能会被夸大（虚高），当这些读长被归因于该宿主时，会导致对宿主生物丰度的过高估计。\n\nE. 如果不按基因长度进行归一化，较长的 $g$ 基因实例会为每个细胞产生更多的读长，因此，即使细胞数量相等，携带较长 $g$ 等位基因的生物体也会显得比携带较短 $g$ 等位基因的生物体更丰富。\n\n选择所有适用项。", "solution": "必须首先验证问题陈述的科学合理性、一致性和清晰度。\n\n步骤1：提取已知条件。\n-   群落组成：两个物种，$S_1$ 和 $S_2$。\n-   细胞数量：$N_1 = 10^6$ 个细胞，$N_2 = 10^6$ 个细胞。\n-   目标基因：$g$，长度为 $L_g$（在两个物种中相同）。\n-   $S_1$ 中的基因拷贝数：$c_{1g} = 1$（染色体），未提及质粒拷贝，因此质粒拷贝数 $h_{1g} = 0$。每个细胞的总拷贝数：$C_{1g} = c_{1g} + h_{1g} = 1$。\n-   $S_2$ 中的基因拷贝数：$c_{2g} = 3$（染色体），$h_{2g} = 8$（质粒）。每个细胞的总拷贝数：$C_{2g} = c_{2g} + h_{2g} = 3 + 8 = 11$。\n-   DNA提取效率：$S_1$ 为 $e_1 = 0.5$，$S_2$ 为 $e_2 = 1.0$。\n-   测序假设：固定的读长长度，随机片段化，从提取的DNA中均匀采样。\n-   待检验的核心假设：“测序数据中基因家族 $g$ 的丰度与携带 $g$ 的生物体的丰度成正比。”\n-   问题：基于第一性原理和所提供的设定，找出正确描述此假设在应用于真实宏基因组时所引入偏差的陈述。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据。所描述的场景是一个标准模型，用于解释鸟枪法宏基因组学中的常见偏差，例如基因拷贝数、质粒丰度和DNA提取效率的差异。问题提法得当，提供了一个清晰的问题以及足够、一致的数据来分析其基本原理。术语是计算生物学和生物信息学的标准术语。问题是客观的，不含非科学性论断。\n\n步骤3：判断与行动。\n问题有效。我将继续进行推导和求解。\n\n鸟枪法测序的基本原理是，在随机采样的假设下，源自特定DNA序列的读长数量与该序列在提取的DNA池中存在的总长度成正比。\n\n设 $R_{ig}$ 是源自物种 $S_i$ 且比对到基因 $g$ 的读长数量。\n在初始群落中，来自物种 $S_i$ 的基因 $g$ 的总长度是细胞数量（$N_i$）、每个细胞中基因 $g$ 的拷贝数（$C_{ig}$）和基因长度（$L_{ig}$）的乘积。\n提取过程的效率为 $e_i$。因此，在*提取的DNA池*中，来自物种 $S_i$ 的基因 $g$ 的总长度与 $e_i N_i C_{ig} L_{ig}$ 成正比。\n\n因此，读长数量 $R_{ig}$ 与该量成正比：\n$$ R_{ig} \\propto e_i N_i C_{ig} L_{ig} $$\n简化假设指出，读长丰度与生物体丰度成正比。在我们的案例中，这意味着来自 $S_2$ 和 $S_1$ 的读长比率应等于其细胞数量的比率：\n$$ \\frac{R_{2g}}{R_{1g}} \\stackrel{?}{=} \\frac{N_2}{N_1} $$\n鉴于 $N_1=N_2=10^6$，该假设意味着我们应该得到 $R_{2g} / R_{1g} = 1$。\n\n现在，让我们根据第一性原理计算这个比率：\n$$ \\frac{R_{2g}}{R_{1g}} = \\frac{e_2 N_2 C_{2g} L_{2g}}{e_1 N_1 C_{1g} L_{1g}} $$\n已知条件为 $N_1 = N_2 = 10^6$，$e_1 = 0.5$，$e_2 = 1.0$，$L_{1g} = L_{2g} = L_g$，$C_{1g} = 1$ 以及 $C_{2g} = 11$。\n代入这些值：\n$$ \\frac{R_{2g}}{R_{1g}} = \\frac{(1.0) \\cdot (10^6) \\cdot (11) \\cdot L_g}{(0.5) \\cdot (10^6) \\cdot (1) \\cdot L_g} = \\frac{11}{0.5} = 22 $$\n实际的读长比率为 $22$，这与简化假设预测的比率 $1$ 有显著差异。导致这种差异的因素就是我们所要讨论的偏差。我们的模型表明，即使细胞数量（$N_i$）相同，这些偏差也源于提取效率（$e_i$）、每个细胞的基因拷贝数（$C_{ig}$）以及潜在的基因长度（$L_{ig}$）的差异。\n\n现在，我们评估每个陈述。\n\nA. **即使细胞数量相同，每个细胞携带更多 $g$ 基因拷贝（包括染色体上或染色体外元件上的拷贝）的生物体，看起来也会比携带较少拷贝的等量生物体更丰富。**\n我们的模型显示 $R_{ig}$ 与每个细胞的拷贝数 $C_{ig}$ 成正比。在问题中，$S_2$ 有 $C_{2g}=11$ 个拷贝，而 $S_1$ 只有 $C_{1g}=1$ 个拷贝。即使 $N_1=N_2$，这个11倍的拷贝数差异直接导致了22倍的读长差异。因此，$S_2$ 中较高的拷贝数使其基于基因 $g$ 的读长看起来更丰富。该陈述是对这种偏差的正确描述。\n结论：**正确**。\n\nB. **即使在每个细胞的拷贝数和提取效率相等的情况下，物种间的基因组大小差异会系统性地导致更多读长比对到拥有更大基因组的物种中的基因 $g$ 上，从而高估这些物种的丰度。**\n这个陈述是错误的。一个基因的读长数量与它在样本中*总*DNA中所占的比例成正比。设 $G_i$ 是物种 $i$ 的基因组大小。提取的DNA池中的DNA总量与 $\\sum_j e_j N_j G_j$ 成正比。在具有更大基因组 $G_i$ 的物种中，一个单拷贝基因占其基因组总DNA的比例更小。因此，在细胞数量相同的情况下，基因组更大的物种会为该基因贡献*更少*的读长，而不是更多。该基因的信号被更大的基因组稀释了。这个陈述提出了相反的效果。\n结论：**错误**。\n\nC. **DNA提取或细胞裂解效率的差异性使得读长计数与细胞计数脱钩，因此，与更难裂解的生物体相比，每个细胞能产出更多可提取DNA的生物体，根据基因 $g$ 的丰度来看会显得更丰富。**\n我们的模型显示 $R_{ig}$ 与提取效率 $e_i$ 成正比。在问题中，$S_2$ 的提取效率是 $S_1$ 的两倍（$e_2 = 1.0$ 对比 $e_1 = 0.5$）。这为最终22的读长比率贡献了一个2倍的因子。更容易裂解（更高的$e_i$）的生物体，相对于其实际细胞数量，在测序数据中会被过度代表。该陈述准确地描述了这种偏差。\n结论：**正确**。\n\nD. **如果基因 $g$ 位于高拷贝质粒或其他可移动遗传元件上，其读长丰度相对于宿主的细胞丰度可能会被夸大（虚高），当这些读长被归因于该宿主时，会导致对宿主生物丰度的过高估计。**\n这是陈述A中所述偏差的一个具体且非常重要的例子。在问题中，物种 $S_2$ 中的基因 $g$ 在质粒上有 $h_{2g}=8$ 个拷贝，这对其总拷贝数 $C_{2g}=11$ 有显著贡献。这个高拷贝质粒“夸大”了基因 $g$ 的丰度，远远超出了一个染色体基因的预期。如果使用这些读长来推断物种 $S_2$ 的丰度，将会发生过高估计。该陈述是正确的。\n结论：**正确**。\n\nE. **如果不按基因长度进行归一化，较长的 $g$ 基因实例会为每个细胞产生更多的读长，因此，即使细胞数量相等，携带较长 $g$ 等位基因的生物体也会显得比携带较短 $g$ 等位基因的生物体更丰富。**\n我们的模型显示 $R_{ig} \\propto L_{ig}$。更长的基因为随机DNA片段化和测序提供了更大的靶标。因此，在其他条件相同的情况下，一个基因的较长版本会产生更多的读长。如果不通过归一化（例如，像在 RPKM 或 TPM 计算中那样）对此进行校正，携带较长等位基因的生物体将显得更丰富。问题询问的是在“真实的宏基因组”中的偏差，其中直系同源基因的长度可能会有所不同。虽然为了简化，问题的具体场景设定了 $L_{1g}=L_{2g}$，但该陈述中描述的原理是鸟枪法测序中的一个基本偏差。\n结论：**正确**。", "answer": "$$\\boxed{ACDE}$$", "id": "2392677"}, {"introduction": "在认识到各种偏见的存在后，下一步是学习如何量化地校正它们。本练习提供了一个具体的计算任务，要求您校正因微生物群落间平均基因组大小不同而引入的偏差。通过这个实践，您将掌握一种核心的归一化方法，以确保在比较不同样本的功能潜力时，所得结论是公平且准确的，从而将概念性认识转化为应用的定量技能。[@problem_id:2392656]", "problem": "对两个复杂的微生物群落进行鸟枪法测序，以比较由单个直系同源基因编码的特定代谢功能的丰度。群落 A 以细菌为主，平均基因组大小为 $\\bar{G_A}$；群落 B 以古菌为主，平均基因组大小为 $\\bar{G_B}$。假设鸟枪法测序读段从总群落 DNA 中被均匀采样，使得映射到任何特征的读段的预期比例与该特征在群落中的总核苷酸长度成正比。所关注的功能由一个在两个群落中长度均为保守值 $L$ 的单一基因编码，并且两个数据集中每个碱基的可映射性和读段长度均相同。设 $p_A$ 和 $p_B$ 分别表示该功能在群落 A 和群落 B 中每个基因组的预期平均拷贝数。\n\n测序结果如下：\n- 群落 A：经过质量过滤的总读段数 $N_A = 6.0 \\times 10^{7}$，映射到该功能的读段数 $n_A = 9.0 \\times 10^{4}$，平均基因组大小 $\\bar{G_A} = 4.8 \\times 10^{6}$ 碱基对。\n- 群落 B：经过质量过滤的总读段数 $N_B = 4.0 \\times 10^{7}$，映射到该功能的读段数 $n_B = 4.0 \\times 10^{4}$，平均基因组大小 $\\bar{G_B} = 2.3 \\times 10^{6}$ 碱基对。\n\n在所述假设下，计算两个群落之间每个基因组功能丰度的经基因组大小校正的倍数变化，该值定义为比率 $p_A / p_B$。将最终答案表示为一个无单位的实数，并四舍五入到四位有效数字。", "solution": "设 $r_A$ 和 $r_B$ 分别为在群落 A 和群落 B 中观测到的映射到该功能的读段比例。根据定义，\n$$\nr_A = \\frac{n_A}{N_A}, \\quad r_B = \\frac{n_B}{N_B}.\n$$\n在从总群落 DNA 均匀采样的条件下，映射到该功能的读段的预期比例等于该功能在整个群落中的总核苷酸长度除以群落中所有基因组的总核苷酸长度。如果该功能的保守基因长度为 $L$ 且每个基因组的预期平均拷贝数为 $p$，那么对于一个包含 $M$ 个基因组且平均基因组大小为 $\\bar{G}$ 的群落，该功能的总核苷酸长度为 $M \\cdot p \\cdot L$，群落的总核苷酸长度为 $M \\cdot \\bar{G}$。因此，预期的读段比例为\n$$\nr = \\frac{M \\cdot p \\cdot L}{M \\cdot \\bar{G}} = \\frac{p \\cdot L}{\\bar{G}}.\n$$\n求解 $p$ 可得\n$$\np = r \\cdot \\frac{\\bar{G}}{L}.\n$$\n将此应用于两个群落，每个基因组丰度的倍数变化为\n$$\n\\frac{p_A}{p_B} = \\frac{r_A \\cdot \\frac{\\bar{G_A}}{L}}{r_B \\cdot \\frac{\\bar{G_B}}{L}} = \\frac{r_A}{r_B} \\cdot \\frac{\\bar{G_A}}{\\bar{G_B}}.\n$$\n根据数据计算 $r_A$ 和 $r_B$：\n$$\nr_A = \\frac{9.0 \\times 10^{4}}{6.0 \\times 10^{7}} = 1.5 \\times 10^{-3}, \\quad r_B = \\frac{4.0 \\times 10^{4}}{4.0 \\times 10^{7}} = 1.0 \\times 10^{-3}.\n$$\n计算平均基因组大小的比率：\n$$\n\\frac{\\bar{G_A}}{\\bar{G_B}} = \\frac{4.8 \\times 10^{6}}{2.3 \\times 10^{6}} = \\frac{4.8}{2.3} \\approx 2.0869565\\ldots\n$$\n因此，\n$$\n\\frac{p_A}{p_B} = \\left(\\frac{1.5 \\times 10^{-3}}{1.0 \\times 10^{-3}}\\right) \\cdot \\left(\\frac{4.8 \\times 10^{6}}{2.3 \\times 10^{6}}\\right) = 1.5 \\times 2.0869565\\ldots \\approx 3.1304347\\ldots\n$$\n四舍五入到四位有效数字，得到 $3.130$。", "answer": "$$\\boxed{3.130}$$", "id": "2392656"}, {"introduction": "最后的这个动手实践将我们之前学到的概念和技能整合成一个完整的数据分析流程。您将从头开始设计并实现一个计算流程，用于处理原始的基因读数计数，校正宿主DNA污染，执行标准的长度和测序深度归一化，并最终将基因丰度聚合成有意义的通路（pathway）功能谱。这个练习模拟了一个真实的生物信息学分析任务，让您全面体验从原始数据到生物学洞见的完整过程。[@problem_id:2392678]", "problem": "您将处理一个简化的数学模型，该模型用于对一个被已知宿主生物DNA污染的微生物群落进行鸟枪法宏基因组测序的功能谱分析。其科学背景遵循分子生物学的中心法则（DNA到RNA到蛋白质）以及宏基因组学中广泛使用的基于计数的分析方法：测序读段源自基因组DNA，比对到参考基因家族上，并进行长度归一化以获得适用于下游功能汇总的组分丰度。您的任务是推导、实现并评估一个稳健的流程，当宿主生物已知时，该流程能够校正观测到的基因家族计数中的宿主污染。\n\n基本定义和假设：\n- 假设存在 $G$ 个基因家族，索引为 $g \\in \\{1,\\dots,G\\}$，以及 $P$ 条功能通路，索引为 $p \\in \\{1,\\dots,P\\}$。设 $\\mathbf{W} \\in \\{0,1\\}^{P \\times G}$ 为通往基因家族的二元成员关系矩阵，其中，如果基因家族 $g$ 参与通路 $p$，则条目 $W_{p,g} = 1$，否则 $W_{p,g} = 0$。一个基因家族可能参与多条通路。\n- 设 $\\mathbf{L} \\in \\mathbb{R}_{>0}^G$ 表示基因家族的长度，单位为碱基对 (bp)。假设基因家族 $g$ 的长度为 $L_g$ bp。\n- 设 $N$ 为测序读段总数，$c \\in [0,1]$ 为宿主污染比例（以小数表示）。因此，源自宿主的预期读段数为 $cN$，源自微生物的预期读段数为 $(1-c)N$。\n- 设 $\\mathbf{y} \\in \\mathbb{N}_0^G$ 为经过一个未主动排除宿主读段的初步比对程序后，比对到每个基因家族的观测读段计数。\n- 设 $\\mathbf{m} \\in [0,1]^G$ 编码了对于已知宿主生物，一个源自宿主的读段（错误地）比对到用于计算 $\\mathbf{y}$ 的目录中基因家族 $g$ 的单读段概率。$\\mathbf{m}$ 的条目之和不必为 $1$，因为一个宿主读段可能无法比对到目录中的任何基因家族；它们代表了比对到所建模的基因家族的边际概率。\n\n基于第一性原理，使用以下推理来设计一个用于微生物专属基因家族计数的稳健估计器，并推导功能谱：\n- 可加性和非负性：对于每个 $g$，观测计数 $y_g$ 是一个非负的微生物信号与一个非负的宿主诱导比对信号之和。读段是离散事件；通常的做法是用独立的泊松分布来模拟读段计数，其速率由潜在的基因组内容、长度和可比对性决定。\n- 全期望定律：给定宿主比例 $c$、总读段数 $N$ 以及宿主比对概率 $\\mathbf{m}$，将 $cN \\cdot m_g$ 视为比对到基因家族 $g$ 的宿主读段的期望数是合理的。使用此期望构建一个满足非负性的、经过污染校正的微生物专属计数估计器。\n- 长度归一化和组分缩放：使用以千碱基为单位的长度将校正后的计数转换为每千碱基读段数 (RPK)，然后缩放为每百万转录本（或标签）数 (TPM)，以获得基因家族的组分构成。\n- 带重叠的通路聚合：为避免重复计算参与多个通路的基因家族，在求和之前，将每个基因家族的 TPM 值平均分配给其所属的所有通路。\n- 多样性总结：使用吉尼-辛普森多样性指数总结每个通路的组分构成，该指数定义为 $1 - \\sum_{p=1}^{P} \\pi_p^2$，其中 $\\pi_p$ 是归一化后总和为 $1$ 的通路级组分。\n\n您的程序必须严格按照以下顺序实现这些步骤：\n1) 使用上述信息计算每个基因家族的、经过宿主校正的微生物专属计数的估计值，并强制要求校正后的计数不为负。\n2) 通过除以以千碱基为单位的基因长度，将校正后的计数转换为 RPK。\n3) 通过除以所有 RPK 值的总和并乘以 $10^6$，将 RPK 转换为 TPM。\n4) 对每个基因家族 $g$，计算其通路成员计数 $d_g = \\sum_{p=1}^{P} W_{p,g}$。将 $g$ 的 TPM 值平均分配给其所属的所有通路；也就是说，为每个此类通路贡献 $\\frac{\\mathrm{TPM}_g}{d_g}$。如果某个 $g$ 的 $d_g = 0$，则它对所有通路的贡献均为零。\n5) 将得到的通路丰度归一化为一个概率向量 $\\boldsymbol{\\pi}$（通过除以它们的总和），并计算吉尼-辛普森多样性 $1 - \\sum_{p=1}^{P} \\pi_p^2$（以小数表示）。\n\n测试套件：\n在所有测试用例中，使用 $G = 5$ 个基因家族和 $P = 3$ 条通路，以及相同的 $\\mathbf{L}$ 和 $\\mathbf{W}$。\n- 基因长度 (bp)：$\\mathbf{L} = [1000, 1500, 800, 1200, 500]$。\n- 通路映射矩阵的行对应于通路 $p=1,2,3$，列对应于基因家族 $g=1,\\dots,5$：\n  - 通路 1：$[1, 1, 0, 0, 0]$。\n  - 通路 2：$[0, 0, 1, 0, 1]$。\n  - 通路 3：$[0, 1, 0, 1, 1]$。\n因此，基因家族 2 属于两条通路，基因家族 5 属于两条通路；其余的各属于一条通路。\n\n对于每个测试用例，元组为 $(N, c, \\mathbf{y}, \\mathbf{m})$：\n- 情况 A (理想路径)：$N = 100000$, $c = 0.2$, $\\mathbf{y} = [8000, 6000, 2000, 3000, 1000]$, $\\mathbf{m} = [0.12, 0.05, 0.02, 0.01, 0.0]$。\n- 情况 B (零污染)：$N = 100000$, $c = 0.0$, $\\mathbf{y} = [8000, 6000, 2000, 3000, 1000]$, $\\mathbf{m} = [0.12, 0.05, 0.02, 0.01, 0.0]$。\n- 情况 C (高污染但仍具信息量)：$N = 100000$, $c = 0.6$, $\\mathbf{y} = [8000, 6000, 2000, 3000, 1000]$, $\\mathbf{m} = [0.12, 0.05, 0.02, 0.01, 0.0]$。\n- 情况 D (极端污染且在零处发生截断)：$N = 100000$, $c = 0.95$, $\\mathbf{y} = [8000, 6000, 2000, 3000, 1000]$, $\\mathbf{m} = [0.12, 0.05, 0.02, 0.01, 0.0]$。\n\n角度单位不适用。所要求的输出中不包含物理单位。\n\n您需要提供的输出：\n- 对于每个测试用例，计算单一的标量吉尼-辛普森多样性值，以小数表示。\n- 您的程序应生成单行输出，其中包含四个结果，按 A、B、C、D 的顺序排列，以逗号分隔，并用方括号括起。每个值必须四舍五入到小数点后六位。示例格式：\"[0.123456,0.234567,0.345678,0.456789]\"。", "solution": "所陈述的问题在科学上是合理的，在数学上是适定的，并且没有矛盾或歧义。它概述了一个用于宏基因组学功能谱分析的简化但标准的工作流程，专门解决了宿主DNA污染这一常见问题。该问题提供了构建确定性计算流程所需的所有数据和定义。我们将严格遵循所提供的模型，按照规定的操作顺序推导解决方案。\n\n假设有 $G$ 个基因家族和 $P$ 条通路。提供的数据包括：总读段数 $N$；宿主污染比例 $c$；比对到每个基因家族的观测、未校正的读段计数 $\\mathbf{y} \\in \\mathbb{N}_0^G$；源自宿主的读段错误地比对到微生物基因家族的单读段概率 $\\mathbf{m} \\in [0,1]^G$；以碱基对为单位的基因家族长度 $\\mathbf{L} \\in \\mathbb{R}_{>0}^G$；以及通路到基因的成员关系矩阵 $\\mathbf{W} \\in \\{0,1\\}^{P \\times G}$。\n\n目标是计算一个单一标量，即校正和聚合后的通路功能谱的吉尼-辛普森多样性指数。步骤如下：\n\n**步骤 1：微生物专属基因计数的估计**\n\n对于一个基因家族 $g$，其观测读段计数（表示为 $y_g$）被建模为来自微生物群落的读段与来自宿主基因组的错误比对的加和。源自宿主并比对到基因家族 $g$ 的预期读段数是宿主来源的总读段数 $cN$ 与单读段比对概率 $m_g$ 的乘积。\n\n基因家族 $g$ 的预期宿主计数：\n$$ E[\\text{host counts}_g] = c \\cdot N \\cdot m_g $$\n\n真实微生物专属计数（我们表示为 $\\mathbf{y'}$）的估计器，是通过从观测计数 $y_g$ 中减去此预期宿主贡献而获得的。由于读段计数不能为负，我们通过取差值与零的最大值来强制执行非负性约束。对于每个基因家族 $g \\in \\{1, \\dots, G\\}$，校正后的微生物计数 $y'_g$ 为：\n$$ y'_g = \\max(0, y_g - c \\cdot N \\cdot m_g) $$\n\n**步骤 2：转换为每千碱基读段数 (RPK)**\n\n为了考虑到较长的基因更有可能被测序这一事实，校正后的计数 $\\mathbf{y'}$ 必须按基因长度进行归一化。长度 $\\mathbf{L}$ 以碱基对 (bp) 给出，但标准的 RPK 单位要求长度以千碱基 (kb) 为单位。基因 $g$ 以千碱基为单位的长度是 $L_g^{\\text{kb}} = L_g / 1000$。\n\n基因家族 $g$ 的 RPK 值（我们表示为 $r_g$）计算如下：\n$$ r_g = \\frac{y'_g}{L_g / 1000} $$\n如果 $y'_g=0$，那么 $r_g=0$。由于问题指定 $L_g > 0$，此处无需担心除以零的问题。\n\n**步骤 3：转换为每百万转录本数 (TPM)**\n\nRPK 值对基因长度进行了归一化，但未考虑测序深度，因此不适合用于跨样本比较组分。TPM 归一化通过将 RPK 值缩放到一个共同的总和（通常为 $10^6$）来解决此问题。首先，我们计算所有基因家族的 RPK 值之和：\n$$ S_{\\text{RPK}} = \\sum_{k=1}^{G} r_k $$\n然后，基因家族 $g$ 的 TPM 值（表示为 $t_g$）为：\n$$ t_g = \\left( \\frac{r_g}{S_{\\text{RPK}}} \\right) \\cdot 10^6 $$\n如果 $S_{\\text{RPK}} = 0$（这当且仅当所有校正计数 $y'_g$ 均为零时发生），那么所有的 $t_g$ 也都为零。TPM 值的集合 $\\mathbf{t} = [t_1, \\dots, t_G]$ 代表基因家族的组分丰度，其中 $\\sum_{g=1}^{G} t_g = 10^6$。\n\n**步骤 4：将基因家族丰度聚合到通路中**\n\n功能分析需要将基因层面的信息聚合到生物通路层面。一个基因家族 $g$ 可能属于多个通路。为防止重复计算其贡献，其丰度 $t_g$ 被平均分配到它所属的所有通路中。首先，我们通过对成员关系矩阵 $\\mathbf{W}$ 的相应列求和，来确定每个基因家族 $g$ 的通路成员计数 $d_g$：\n$$ d_g = \\sum_{p=1}^{P} W_{p,g} $$\n通路 $p$ 的丰度（表示为 $A_p$）是其所有成员基因家族贡献的总和。如果 $d_g > 0$，基因 $g$ 为其所在的每个通路贡献 $t_g/d_g$。如果 $d_g=0$，则其贡献为零。\n$$ A_p = \\sum_{g=1}^{G} W_{p,g} \\cdot \\frac{t_g}{d_g} \\quad (\\text{约定 } \\frac{t_g}{0} = 0) $$\n这将产生一个通路丰度向量 $\\mathbf{A} = [A_1, \\dots, A_P]$。该方法的一个特性是，总通路丰度等于总基因家族丰度：$\\sum_{p=1}^{P} A_p = \\sum_{g=1}^{G} t_g = 10^6$。\n\n**步骤 5：吉尼-辛普森多样性指数的计算**\n\n最后，我们使用一个多样性指数来总结所得通路功能谱的结构。我们首先将通路丰度 $\\mathbf{A}$ 归一化为一个概率分布 $\\boldsymbol{\\pi}$，其中每个元素 $\\pi_p$ 代表通路 $p$ 的相对丰度：\n$$ \\pi_p = \\frac{A_p}{\\sum_{k=1}^{P} A_k} $$\n如果 $\\sum_{k=1}^{P} A_k = 0$，我们定义对所有 $p$ 都有 $\\pi_p = 0$。\n\n然后计算吉尼-辛普森指数 $D$。它被定义为 1 减去辛普森指数，辛普森指数是指从群体中随机抽取的两个实体属于同一类型的概率。\n$$ D = 1 - \\sum_{p=1}^{P} \\pi_p^2 $$\n$D$ 的值范围从 $0$（一个只含有一条通路的群落）到 $1 - 1/P$（一个完全均匀的群落）。如果所有的 $\\pi_p=0$，则平方和为 $0$，$D=1$。这个标量值是每个测试用例的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the metagenomic functional profiling problem for a series of test cases.\n    \"\"\"\n    # Define the fixed parameters for all test cases.\n    # Gene lengths in base pairs (bp)\n    L_bp = np.array([1000, 1500, 800, 1200, 500], dtype=np.float64)\n    # Pathway-to-gene-family membership matrix (P x G)\n    W = np.array([\n        [1, 1, 0, 0, 0],  # Pathway 1\n        [0, 0, 1, 0, 1],  # Pathway 2\n        [0, 1, 0, 1, 1],  # Pathway 3\n    ], dtype=np.float64)\n\n    # Define the test cases as a list of tuples (N, c, y, m).\n    test_cases = [\n        # Case A: Happy path\n        (100000, 0.2, [8000, 6000, 2000, 3000, 1000], [0.12, 0.05, 0.02, 0.01, 0.0]),\n        # Case B: Zero contamination\n        (100000, 0.0, [8000, 6000, 2000, 3000, 1000], [0.12, 0.05, 0.02, 0.01, 0.0]),\n        # Case C: High contamination\n        (100000, 0.6, [8000, 6000, 2000, 3000, 1000], [0.12, 0.05, 0.02, 0.01, 0.0]),\n        # Case D: Extreme contamination with clipping\n        (100000, 0.95, [8000, 6000, 2000, 3000, 1000], [0.12, 0.05, 0.02, 0.01, 0.0]),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, c, y_obs, m = case\n        y_obs = np.array(y_obs, dtype=np.float64)\n        m = np.array(m, dtype=np.float64)\n\n        # Step 1: Compute host-corrected estimate of microbial-only counts.\n        expected_host_counts = c * N * m\n        corrected_counts = np.maximum(0, y_obs - expected_host_counts)\n\n        # Step 2: Convert corrected counts to RPK (Reads Per Kilobase).\n        L_kb = L_bp / 1000.0\n        # This division is safe since L_bp > 0 is a given.\n        rpk = corrected_counts / L_kb\n\n        # Step 3: Convert RPK to TPM (Transcripts Per Million).\n        sum_rpk = np.sum(rpk)\n        if sum_rpk == 0:\n            tpm = np.zeros_like(rpk)\n        else:\n            tpm = (rpk / sum_rpk) * 1e6\n\n        # Step 4: Aggregate TPMs into pathway abundances.\n        # d_g: pathway membership count for each gene family g.\n        pathway_membership_counts = np.sum(W, axis=0)\n        \n        # Calculate contribution of each gene's TPM to a single pathway.\n        # This handles division by zero for genes not in any pathway (d_g=0).\n        with np.errstate(divide='ignore', invalid='ignore'):\n            tpm_contribution_per_pathway = tpm / pathway_membership_counts\n        \n        # Set contribution to 0 if pathway_membership_counts was 0.\n        tpm_contribution_per_pathway[np.isinf(tpm_contribution_per_pathway)] = 0\n        tpm_contribution_per_pathway[np.isnan(tpm_contribution_per_pathway)] = 0\n        \n        # Matrix multiplication aggregates contributions into pathways.\n        pathway_abundances = W @ tpm_contribution_per_pathway\n\n        # Step 5: Normalize pathway abundances and compute Gini-Simpson diversity.\n        sum_pathway_abundances = np.sum(pathway_abundances)\n        if sum_pathway_abundances == 0:\n            # If no functions detected, diversity is ill-defined.\n            # A community with no members can be seen as maximally diverse, or the index is 1.\n            # 1 - sum(0^2) = 1.\n            diversity = 1.0\n        else:\n            pi = pathway_abundances / sum_pathway_abundances\n            diversity = 1.0 - np.sum(pi**2)\n            \n        results.append(diversity)\n\n    # Format the results into the required string format.\n    # Each value is rounded to six digits after the decimal point.\n    output_str = f\"[{','.join(f'{r:.6f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2392678"}]}