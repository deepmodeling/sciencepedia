{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解源于实践。本节将通过一系列动手练习，带你深入泛基因组图的世界。让我们从一个基本但至关重要的任务开始：在图中寻找特定的路径。这个练习将模拟一个常见的生物学问题：如何识别出所有不包含某个已知有害等位基因（deleterious allele）的单倍型（haplotype）。通过解决这个问题[@problem_id:2412152]，你将练习图的遍历算法，并学会如何通过修改图结构来处理路径约束，这是分析泛基因组变异的一项基本技能。", "problem": "考虑一个有限有向图，该图在等位基因状态层面上代表一个泛基因组图，建模为有序对 $\\left(G = (V,E)\\right)$，其中 $V$ 是一个有限的节点集合，$E \\subseteq V \\times V$ 是一个有向边集合。每个节点 $v \\in V$ 都被标记为一个唯一的正整数。对于一个源节点 $S \\in V$、一个汇点 $T \\in V$ 以及一个有害等位基因节点 $F \\in \\mathbb{Z}_{>0}$（其可能属于也可能不属于 $V$），从 $S$ 到 $T$ 的一条有向路径是一个有限的节点序列 $(v_0, v_1, \\dots, v_k)$，满足 $k \\in \\mathbb{Z}_{\\ge 0}$，$v_0 = S$，$v_k = T$，并且对于所有的 $i \\in \\{0,1,\\dots,k-1\\}$ 都有 $(v_i, v_{i+1}) \\in E$。如果序列中的所有节点两两不同，则该路径为简单路径。如果节点 $F$ 未出现在序列中的任何位置，则该路径避开有害等位基因。若 $S = F$ 或 $T = F$，则有效路径集定义为空集。\n\n对于下方的每个测试用例，计算从 $S$ 到 $T$ 避开 $F$ 的简单有向路径的数量。您的程序必须评估所有测试用例，并生成一行输出，其中包含每个测试用例的计数值，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$[a,b,c]$，其中 $a$、$b$、$c$ 是整数）。\n\n使用以下测试套件：\n\n- 测试用例 1：\n  - $V = \\{1,2,3,4,5,6\\}$\n  - $E = \\{(1,2),(1,3),(2,4),(3,4),(4,5),(2,5),(3,6),(5,6)\\}$\n  - $S = 1$, $T = 6$, $F = 3$\n\n- 测试用例 2：\n  - $V = \\{1,2,3,4\\}$\n  - $E = \\{(1,2),(2,3),(3,4),(1,3),(2,4)\\}$\n  - $S = 1$, $T = 4$, $F = 5$\n\n- 测试用例 3：\n  - $V = \\{1,2,3\\}$\n  - $E = \\{(1,2),(2,3)\\}$\n  - $S = 1$, $T = 3$, $F = 1$\n\n- 测试用例 4：\n  - $V = \\{1,2,3\\}$\n  - $E = \\{(1,2)\\}$\n  - $S = 1$, $T = 3$, $F = 2$\n\n- 测试用例 5：\n  - $V = \\{1,2,3,4\\}$\n  - $E = \\{(1,2),(2,3),(3,2),(3,4),(2,4),(1,3)\\}$\n  - $S = 1$, $T = 4$, $F = 2$\n\n您的程序应生成一行输出，其中包含按测试用例顺序排列的结果，格式为一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4,x_5]$）。不应打印任何额外的文本或格式。", "solution": "问题陈述经评估后被认为是有效的。这是一个在计算图论中定义明确且具有科学依据的问题，具体涉及有向图中的路径枚举，而有向图是泛基因组分析的标准模型。所有术语都有定义，且为每个测试用例提供的数据是完整和一致的。\n\n任务是计算在给定有向图 $G=(V, E)$ 中，从源节点 $S$ 到汇点 $T$ 的简单有向路径的数量，并附加约束条件：路径必须避开指定的有害等位基因节点 $F$。\n\n首先，我们处理所提供的明确条件：如果源节点 $S$ 或汇点 $T$ 与禁止节点 $F$ 相同，则有效路径集为空，因此计数为 $0$。\n设 $N(S, T, F)$ 为有效路径的数量。该条件可正式表述为：\n$$\n\\text{If } S=F \\text{ or } T=F, \\text{ then } N(S, T, F) = 0.\n$$\n这可作为在尝试任何路径查找之前的初步检查。\n\n对于所有其他 $S \\neq F$ 且 $T \\neq F$ 的情况，寻找避开特定节点 $F$ 的路径问题，最有效的方法是通过修改图本身来解决。我们从原始图 $G=(V,E)$ 构建一个新图 $G'=(V', E')$。如果禁止节点 $F$ 不是顶点集 $V$ 的元素（即 $F \\notin V$），则 $G$ 中的任何路径都不可能包含 $F$。在这种情况下，我们用于搜索的图 $G'$ 与 $G$ 相同。然而，如果 $F \\in V$，我们必须移除节点 $F$ 及其所有关联边。新的顶点集为 $V' = V \\setminus \\{F\\}$，新的边集 $E'$ 为\n$$\nE' = \\{ (u,v) \\in E \\mid u \\neq F \\text{ and } v \\neq F \\}.\n$$\n因此，问题被简化为在新图 $G'$ 中寻找从 $S$ 到 $T$ 的简单路径数量。由于已确定 $S \\neq F$ 且 $T \\neq F$，因此可以保证 $S$ 和 $T$ 都存在于新的顶点集 $V'$ 中。\n\n在可能包含环的通用有向图中计算简单路径是一个计算上困难的问题（它是 $\\#P$-完全的）。对于测试套件中提供的小规模图，递归回溯算法（实际上是一种深度优先搜索，即 DFS）是一种可行且正确的方法。该算法从源节点系统地探索路径，确保在任何单条路径中没有节点被访问超过一次。\n\n该算法围绕一个递归函数构建，我们将其命名为 $\\text{count\\_paths}(u, \\text{visited})$，其中 $u$ 是遍历中的当前节点，$\\text{visited}$ 是一个集合，包含了从 $S$ 到 $u$ 的当前路径中已经包含的节点。\n\n算法步骤如下：\n1.  使用邻接表来表示图 $G'$，该邻接表将每个节点映射到其邻居节点的列表。\n2.  定义递归函数 $\\text{count\\_paths}(u, \\text{visited})$：\n    a. 递归的基准情形：如果当前节点 $u$ 是目标节点 $T$，则找到了一条完整的简单路径。返回 $1$。\n    b. 初始化一个局部路径计数器变量 `count` 为 $0$。\n    c. 将当前节点 $u$ 添加到 `visited` 集合中，以防止在当前路径中重复访问它，从而避免环路。\n    d. 对于 $G'$ 邻接表中 $u$ 的每个邻居 $v$：\n        i. 如果 $v$ 未被访问过（即 $v \\notin \\text{visited}$），则进行递归调用：`count = count + count_paths(v, visited)`。\n    e. 在探索完所有从 $u$ 延伸的路径后，执行回溯：将 $u$ 从 `visited` 集合中移除。这一步至关重要，因为它允许 $u$ 成为从搜索的不同分支发起的其他简单路径的一部分。\n    f. 返回总计 `count`。\n3.  主过程通过调用 $\\text{count\\_paths}(S, \\emptyset)$ 来启动，从源节点 $S$ 开始搜索，并使用一个空的已访问节点集合。\n\n让我们将此方法应用于每个测试用例。\n\n**测试用例 1**：\n$V = \\{1,2,3,4,5,6\\}$，$E = \\{(1,2),(1,3),(2,4),(3,4),(4,5),(2,5),(3,6),(5,6)\\}$，$S = 1$，$T = 6$，$F = 3$。\n节点 $F=3$ 被移除。图 $G'$ 的顶点集为 $V'=\\{1,2,4,5,6\\}$，边集为 $E'=\\{(1,2),(2,4),(4,5),(2,5),(5,6)\\}$。我们计算从 $1$ 到 $6$ 的简单路径：\n- 路径 1：$1 \\to 2 \\to 4 \\to 5 \\to 6$\n- 路径 2：$1 \\to 2 \\to 5 \\to 6$\n路径总数为 $2$。\n\n**测试用例 2**：\n$V = \\{1,2,3,4\\}$，$E = \\{(1,2),(2,3),(3,4),(1,3),(2,4)\\}$，$S = 1$，$T = 4$，$F = 5$。\n节点 $F=5$ 不在 $V$ 中，因此图保持不变。我们计算从 $1$ 到 $4$ 的简单路径：\n- 路径 1：$1 \\to 2 \\to 3 \\to 4$\n- 路径 2：$1 \\to 2 \\to 4$\n- 路径 3：$1 \\to 3 \\to 4$\n路径总数为 $3$。\n\n**测试用例 3**：\n$V = \\{1,2,3\\}$，$E = \\{(1,2),(2,3)\\}$，$S = 1$，$T = 3$，$F = 1$。\n由于 $S=F$，有效路径数量定义为 $0$。\n\n**测试用例 4**：\n$V = \\{1,2,3\\}$，$E = \\{(1,2)\\}$，$S = 1$，$T = 3$，$F = 2$。\n节点 $F=2$ 被移除。边 $(1,2)$ 被删除。生成的图没有边。从 $1$ 到 $3$ 没有路径。计数为 $0$。\n\n**测试用例 5**：\n$V = \\{1,2,3,4\\}$，$E = \\{(1,2),(2,3),(3,2),(3,4),(2,4),(1,3)\\}$，$S = 1$，$T = 4$，$F = 2$。\n节点 $F=2$ 及其所有关联边被移除。图 $G'$ 的顶点集为 $V'=\\{1,3,4\\}$，边集为 $E'=\\{(1,3),(3,4)\\}$。从 $1$ 到 $4$ 只有一条简单路径：\n- 路径 1：$1 \\to 3 \\to 4$\n路径总数为 $1$。\n\n最终的结果序列是 $[2, 3, 0, 0, 1]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the pangenome graph path counting problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'V': {1, 2, 3, 4, 5, 6}, 'E': {(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5), (3, 6), (5, 6)}, 'S': 1, 'T': 6, 'F': 3},\n        # Test case 2\n        {'V': {1, 2, 3, 4}, 'E': {(1, 2), (2, 3), (3, 4), (1, 3), (2, 4)}, 'S': 1, 'T': 4, 'F': 5},\n        # Test case 3\n        {'V': {1, 2, 3}, 'E': {(1, 2), (2, 3)}, 'S': 1, 'T': 3, 'F': 1},\n        # Test case 4\n        {'V': {1, 2, 3}, 'E': {(1, 2)}, 'S': 1, 'T': 3, 'F': 2},\n        # Test case 5\n        {'V': {1, 2, 3, 4}, 'E': {(1, 2), (2, 3), (3, 2), (3, 4), (2, 4), (1, 3)}, 'S': 1, 'T': 4, 'F': 2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        V, E, S, T, F = case['V'], case['E'], case['S'], case['T'], case['F']\n        \n        # Per problem definition, if S or T is the forbidden node F, the path count is 0.\n        if S == F or T == F:\n            results.append(0)\n            continue\n        \n        # Build the adjacency list for the graph, filtering out the forbidden node F.\n        # Nodes that are not F are included in the adjacency list keys.\n        adj = {v: [] for v in V if v != F}\n        \n        # Edges are added only if neither endpoint is the forbidden node F.\n        for u, v in E:\n            if u != F and v != F:\n                # Ensure start node u is in the graph (in case it had no outgoing edges).\n                if u in adj:\n                    adj[u].append(v)\n\n        # Recursive function to count simple paths using Depth-First Search with backtracking.\n        def count_simple_paths(u, target, visited):\n            \"\"\"\n            Counts simple paths from node u to target.\n            \n            Args:\n                u: The current node in the path.\n                target: The destination node.\n                visited: A set of nodes in the current path to ensure simplicity.\n            \n            Returns:\n                The number of simple paths from u to target.\n            \"\"\"\n            # Base case: If the current node is the target, a valid simple path is found.\n            if u == target:\n                return 1\n            \n            # Mark the current node as visited for the current path exploration.\n            visited.add(u)\n            \n            path_count = 0\n            \n            # If the current node is in the graph (it could have been isolated after removing F)\n            if u in adj:\n                # Recur for all unvisited neighbors.\n                for v in adj[u]:\n                    if v not in visited:\n                        path_count += count_simple_paths(v, target, visited)\n            \n            # Backtrack: Un-mark the current node as visited to allow it to be part of other paths.\n            visited.remove(u)\n            \n            return path_count\n\n        # The set of visited nodes is initially empty for the start of the search.\n        # It's passed by reference and modified during recursion.\n        initial_visited = set()\n        \n        # Start the recursive count from the source node S.\n        count = count_simple_paths(S, T, initial_visited)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412152"}, {"introduction": "在能够筛选路径之后，下一步自然是找出‘最佳’路径。泛基因组图通常需要被‘扁平化’（flatten）为单一的线性参考序列，以便于下游分析。这个练习要求你根据每个节点的支持分数（support score）$S$，找到总分最高的路径。通过解决这个问题[@problem_id:2412184]，你将应用动态规划（dynamic programming）这一强大技术在有向无环图（DAG）上寻找最优路径，这是处理许多泛基因组问题的核心算法。", "problem": "给定一个有限有向无环图 (DAG)，该图表示一个基因组变异区域。每个顶点（节点）对应一个由字母表 $\\{A,C,G,T\\}$ 上的字符串标记的DNA片段，并且每个顶点 $i$ 都有一个非负实值支持权重 $w_i \\in \\mathbb{R}_{\\ge 0}$。一条有向边 $(u,v)$ 表示在一次有效遍历中，顶点 $v$ 的DNA片段可以紧跟在顶点 $u$ 的DNA片段之后。一条有效路径是指从指定的起始顶点 $s$ 到指定的结束顶点 $t$ 的任意有向路径。该区域的扁平化线性参考序列定义为沿某条 $s \\to t$ 路径拼接所有DNA字符串而成的序列，该路径能使总支持分数 $S$ 最大化，其中\n$$\nS = \\sum_{i \\in P} w_i,\n$$\n且 $P$ 是所选路径上按顺序排列的顶点集合。如果多条 $s \\to t$ 路径达到相同的最大 $S$，则选择其拼接后的DNA字符串在序关系 $A \\prec C \\prec G \\prec T$ 下字典序最小的那条路径来打破平局。如果仍然存在平局，则选择其顶点索引序列在整数自然序下字典序最小的那条路径。\n\n您的任务是实现一个程序，该程序针对以下每个测试用例，根据上述规则计算从 $s$ 到 $t$ 的最大支持度扁平化路径，并返回两项内容：最大总支持分数 $S$ 和通过映射 $A \\mapsto 0$、$C \\mapsto 1$、$G \\mapsto 2$、$T \\mapsto 3$ 进行整数编码的扁平化DNA字符串。\n\n保证所有图都是有向无环图。所有DNA标签仅由 $\\{A,C,G,T\\}$ 中的字符组成。所有权重都是 $\\mathbb{R}_{\\ge 0}$ 中的实数。在每个测试用例中，至少存在一条有效的 $s \\to t$ 路径。本问题不涉及物理单位。\n\n对于每个测试用例，您的程序必须输出一个列表，其中第一个元素是四舍五入到恰好三位小数的最大支持分数 $S$，其后是按上述规定进行整数编码的扁平化DNA字符串。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，结果为方括号内由逗号分隔的列表。每个测试用例贡献一个如上所述的方括号列表。例如，最终格式为\n$[ [S_1,\\ell_{1,1},\\ell_{1,2},\\dots], [S_2,\\ell_{2,1},\\dots], \\dots ]$，\n其中每个 $S_k$ 四舍五入到恰好三位小数，且每个 $\\ell_{k,j} \\in \\{0,1,2,3\\}$。\n\n测试套件：\n- 测试用例 $1$ (通用分支情况)：\n  - 带DNA标签和权重的顶点：\n    - $1$: 标签 $A$, $w_1 = 1.0$\n    - $2$: 标签 $G$, $w_2 = 2.0$\n    - $3$: 标签 $C$, $w_3 = 1.5$\n    - $4$: 标签 $T$, $w_4 = 3.0$\n    - $5$: 标签 $G$, $w_5 = 2.5$\n    - $6$: 标签 $A$, $w_6 = 0.5$\n  - 有向边： $(1,2)$, $(1,3)$, $(2,4)$, $(3,4)$, $(4,6)$, $(2,5)$, $(5,6)$\n  - 起始点 $s = 1$，结束点 $t = 6$\n- 测试用例 $2$ (由DNA字符串的字典序打破平局)：\n  - 带DNA标签和权重的顶点：\n    - $1$: 标签 $A$, $w_1 = 1.0$\n    - $2$: 标签 $C$, $w_2 = 2.0$\n    - $3$: 标签 $G$, $w_3 = 2.0$\n    - $4$: 标签 $A$, $w_4 = 0.3$\n  - 有向边： $(1,2)$, $(2,4)$, $(1,3)$, $(3,4)$\n  - 起始点 $s = 1$，结束点 $t = 4$\n- 测试用例 $3$ (DNA字符串平局后，由顶点索引序列打破)：\n  - 带DNA标签和权重的顶点：\n    - $1$: 标签 $A$, $w_1 = 1.0$\n    - $2$: 标签 $G$, $w_2 = 1.0$\n    - $3$: 标签 $G$, $w_3 = 1.0$\n    - $4$: 标签 $A$, $w_4 = 1.0$\n  - 有向边： $(1,2)$, $(2,4)$, $(1,3)$, $(3,4)$\n  - 起始点 $s = 1$，结束点 $t = 4$\n- 测试用例 $4$ ($s = t$ 的边界情况)：\n  - 带DNA标签和权重的顶点：\n    - $1$: 标签 $T$, $w_1 = 2.2$\n  - 有向边：无\n  - 起始点 $s = 1$，结束点 $t = 1$\n\n最终输出格式：\n- 精确生成一行：\n  - 该行必须是聚合所有测试用例结果的单个方括号列表。\n  - 每个测试用例的结果是一个方括号列表，其第一个元素是四舍五入到恰好三位小数的最大支持分数 $S$，其后是使用 $A \\mapsto 0$、$C \\mapsto 1$、$G \\mapsto 2$、$T \\mapsto 3$ 进行整数编码的扁平化DNA字符串。\n  - 输出中不得有空格。\n  - 示例格式（非实际答案）：$[[3.125,0,1,2],[2.000,3]]$。", "solution": "问题陈述已经过分析，并被确定为有效。该问题具有科学依据，定义明确，客观，并包含推导出唯一解所需的所有必要信息。该问题是有向无环图 (DAG) 上最长路径问题的一个变体，其目标函数包含用于打破平局的多层标准。此类问题在计算生物学中是基础性的，用于分析泛基因组中的序列变异。\n\n由于图是 DAG，该问题是可解的。图中没有环，因此允许在顶点的拓扑排序上使用动态规划。最优性原理适用：到达顶点 $v$ 的最优路径必定是通过扩展到达其某个前驱节点的最优路径而形成的。\n\n算法流程如下。首先，我们必须对图的顶点进行拓扑排序。这提供了一个顶点的线性排序，使得对于每条有向边 $(u,v)$，顶点 $u$ 在排序中都位于顶点 $v$ 之前。这种排序确保了当我们在计算到达顶点 $v$ 的最优路径时，到达其所有前驱节点的最优路径都已经被计算出来了。\n\n我们为图中的每个顶点 $v$ 定义一个动态规划状态。该状态必须封装层次化优化准则所需的所有信息。设 $dp[v]$ 为一个元组 $(S_v, D_v, P_v)$，表示从起始顶点 $s$ 到 $v$ 的最优路径，其中：\n- $S_v$ 是路径的最大总支持分数。\n- $D_v$ 是路径拼接后的DNA序列，在所有分数为 $S_v$ 的路径中，该序列必须是字典序最小的。\n- $P_v$ 是路径的顶点索引序列，在所有分数为 $S_v$ 且DNA序列为 $D_v$ 的路径中，该序列必须是字典序最小的。\n\n算法通过设置起始顶点 $s$ 的状态来初始化。从 $s$ 到 $s$ 的路径仅包含顶点 $s$ 本身。因此，$dp[s]$ 被设置为 $(w_s, L_s, [s])$，其中 $w_s$ 是顶点 $s$ 的权重，$L_s$ 是其DNA标签（编码为整数序列），$[s]$ 是仅含单个顶点的路径。对于所有其他顶点 $v \\neq s$，其状态被初始化为一个表示不可达的值，例如分数为 $-\\infty$。由于所有权重 $w_i$ 都是非负的，任何负分都可以达到此目的。\n\n算法的核心是 $dp$ 状态的迭代更新。我们按照预先计算好的拓扑顺序处理每个顶点 $u$。对于每条出边 $(u,v)$，我们通过扩展到达 $u$ 的最优路径来构建一条到达 $v$ 的候选路径。该候选路径具有以下属性：\n- 分数：$S_{u \\to v} = S_u + w_v$\n- DNA序列：$D_{u \\to v} = D_u \\cdot L_v$ (拼接)\n- 顶点路径：$P_{u \\to v} = P_u \\cdot [v]$ (拼接)\n\n然后将这个候选路径元组 $(S_{u \\to v}, D_{u \\to v}, P_{u \\to v})$ 与存储在 $dp[v]$ 中的当前最优路径进行比较。如果一条新路径的分数更高，或者分数相等但其DNA序列的字典序更小，或者分数和DNA序列都相等但其顶点路径的字典序更小，则该新路径被认为是更优的。\n\n为了高效地实现这种比较，我们可以比较形式为 $(-S, D, P)$ 的元组。对此类元组进行标准的字典序比较将正确地确定最优路径，因为最小化 $-S$ 等同于最大化 $S$，而后续元素 $D$ 和 $P$ 会按要求进行最小化比较。\n\n在按拓扑顺序遍历所有顶点后，指定结束顶点 $t$ 的状态 $dp[t]$ 将包含对应于全局最优 $s \\to t$ 路径的元组。然后从该元组中提取最终结果，将分数 $S_t$ 四舍五入到三位小数，并以整数编码形式呈现DNA序列 $D_t$。\n整个过程如下：\n1.  解析图结构、顶点标签和权重。\n2.  对顶点进行拓扑排序。Kahn 算法是一个标准选择。\n3.  初始化一个 $dp$ 表，设置起始顶点 $s$ 的条目，并将所有其他条目标记为未访问。\n4.  按拓扑顺序遍历顶点。对于每个顶点 $u$，遍历其邻居 $v$，如果找到了经过 $u$ 的更优路径，则更新 $dp[v]$。\n5.  迭代完成后，$dp[t]$ 条目中即包含解决方案。按规定格式化并返回。\n这个严谨、分步的过程保证了能根据问题的准则得到正确、唯一的解。", "answer": "```python\nimport numpy as np\nimport scipy\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the pangenome graph pathfinding problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": {\n                1: {\"label\": \"A\", \"weight\": 1.0}, 2: {\"label\": \"G\", \"weight\": 2.0},\n                3: {\"label\": \"C\", \"weight\": 1.5}, 4: {\"label\": \"T\", \"weight\": 3.0},\n                5: {\"label\": \"G\", \"weight\": 2.5}, 6: {\"label\": \"A\", \"weight\": 0.5},\n            },\n            \"edges\": [(1, 2), (1, 3), (2, 4), (3, 4), (4, 6), (2, 5), (5, 6)],\n            \"s\": 1, \"t\": 6,\n        },\n        {\n            \"nodes\": {\n                1: {\"label\": \"A\", \"weight\": 1.0}, 2: {\"label\": \"C\", \"weight\": 2.0},\n                3: {\"label\": \"G\", \"weight\": 2.0}, 4: {\"label\": \"A\", \"weight\": 0.3},\n            },\n            \"edges\": [(1, 2), (2, 4), (1, 3), (3, 4)],\n            \"s\": 1, \"t\": 4,\n        },\n        {\n            \"nodes\": {\n                1: {\"label\": \"A\", \"weight\": 1.0}, 2: {\"label\": \"G\", \"weight\": 1.0},\n                3: {\"label\": \"G\", \"weight\": 1.0}, 4: {\"label\": \"A\", \"weight\": 1.0},\n            },\n            \"edges\": [(1, 2), (2, 4), (1, 3), (3, 4)],\n            \"s\": 1, \"t\": 4,\n        },\n        {\n            \"nodes\": {\n                1: {\"label\": \"T\", \"weight\": 2.2},\n            },\n            \"edges\": [],\n            \"s\": 1, \"t\": 1,\n        },\n    ]\n\n    dna_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    \n    final_results = []\n    \n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        edges = case[\"edges\"]\n        start_node = case[\"s\"]\n        end_node = case[\"t\"]\n        \n        adj = collections.defaultdict(list)\n        in_degree = collections.defaultdict(int)\n        \n        for u, v in edges:\n            adj[u].append(v)\n            in_degree[v] += 1\n            if u not in in_degree:\n                in_degree[u] = 0\n\n        # Topological sort (Kahn's algorithm)\n        queue = collections.deque([node for node in nodes if in_degree[node] == 0])\n        topo_order = []\n        while queue:\n            u = queue.popleft()\n            topo_order.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n\n        # Dynamic programming\n        # dp[node] = (score, dna_sequence_list, vertex_path_list)\n        dp = {node: (-1.0, [], []) for node in nodes}\n\n        # Initialization for the start node\n        start_label = nodes[start_node][\"label\"]\n        start_dna_list = [dna_map[c] for c in start_label]\n        dp[start_node] = (nodes[start_node][\"weight\"], start_dna_list, [start_node])\n        \n        for u in topo_order:\n            if dp[u][0] < 0.0:  # Node u is not reachable from start_node\n                continue\n            \n            score_u, dna_u, path_u = dp[u]\n            \n            for v in adj[u]:\n                weight_v = nodes[v][\"weight\"]\n                label_v = nodes[v][\"label\"]\n                dna_v_list = [dna_map[c] for c in label_v]\n                \n                new_score = score_u + weight_v\n                new_dna = dna_u + dna_v_list\n                new_path = path_u + [v]\n\n                # Get current best for v\n                best_score_v, best_dna_v, best_path_v = dp[v]\n\n                # We maximize score, but minimize DNA and path for ties.\n                # This is equivalent to lexicographically minimizing (-score, dna, path).\n                if best_score_v < 0.0 or \\\n                   (-new_score, new_dna, new_path) < (-best_score_v, best_dna_v, best_path_v):\n                    dp[v] = (new_score, new_dna, new_path)\n    \n        final_score, final_dna, _ = dp[end_node]\n        \n        # Format result string manually to avoid spaces\n        result_str_list = [f\"{final_score:.3f}\"] + [str(d) for d in final_dna]\n        result_str = f\"[{','.join(result_str_list)}]\"\n        final_results.append(result_str)\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "2412184"}]}