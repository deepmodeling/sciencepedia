{"hands_on_practices": [{"introduction": "孟德尔的分离定律和自由组合定律为遗传学提供了优雅的数学预测。然而，在真实的遗传杂交实验中，观测到的后代比例很少会与理想的孟德尔比例（如 $1:2:1$ 或 $9:3:3:1$）完全吻合。本练习将指导你应用卡方（$\\chi^2$）检验，这是一个至关重要的统计工具，用于客观地判断观测数据与理论预期的偏差是否源于随机波动，还是暗示了背后可能存在着更复杂的生物学现象。通过这个实践，你将掌握一项在遗传数据质量控制和分析中的核心技能。[@problem_id:2403843]", "problem": "给定一组来自对照杂交后代的独立遗传基因座。对于每个基因座，我们使用高通量测序对后代进行基因分型，并统计了各类基因型的观测计数。假设基因座为双等位基因，且基因型判定为共显性（因此基因型类别可被明确区分）。根据经典孟德尔遗传定律，对于特定的杂交设计，预期的基因型比例由分离定律和配子随机结合决定。\n\n对于每个测试用例，您必须在指定的显著性水平下，判断某基因座的观测计数是否与所声明的杂交设计的孟德尔分离定律相符。形式上，对于一个有 $k$ 个基因型类别的基因座，设观测计数为向量 $\\mathbf{O}=(O_1,\\dots,O_k)$，总数为 $N=\\sum_{i=1}^k O_i$；设杂交设计下的预期孟德尔比例为 $\\mathbf{p}=(p_1,\\dots,p_k)$，其中 $\\sum_{i=1}^k p_i=1$ 且对于所有 $i$ 都有 $p_i > 0$。原假设是数据来自概率为 $\\mathbf{p}$ 的分类分布。您的程序必须为每个测试用例判断是否在显著性水平 $\\alpha$ 下拒绝原假设。\n\n支持的杂交设计及其预期基因型比例：\n- 杂交设计字符串 \"F2\" 表示由两个纯合亲本进行 $F_2$ 代杂交，涉及一个双等位基因座和共显性基因分型。预期的基因型比例向量（按 $AA$，$Aa$，$aa$ 的顺序）是 $\\left(\\tfrac{1}{4},\\tfrac{1}{2},\\tfrac{1}{4}\\right)$。\n- 杂交设计字符串 \"BACKCROSS\" 表示将一个杂合子与一个隐性纯合子进行回交，涉及一个双等位基因座和共显性基因分型。预期的基因型比例向量（按 $Aa$，$aa$ 的顺序）是 $\\left(\\tfrac{1}{2},\\tfrac{1}{2}\\right)$。\n\n解释与输出编码：\n- 对每个测试用例，返回如下定义的整数决策代码 $d$：如果孟德尔分离的原假设在显著性水平 $\\alpha$ 下被拒绝，则 $d=1$；如果原假设未被拒绝，则 $d=0$；如果测试无效（因为观测类别计数向量的长度与声明的杂交设计的预期比例向量的长度不匹配，或因为 $N=0$），则 $d=-1$。\n\n您的程序必须硬编码并使用以下测试套件。每个测试用例是一个包含三个元素的元组：杂交设计字符串、按该杂交指定顺序排列的各基因型类别的观测非负整数计数列表，以及显著性水平 $\\alpha$（以小数形式表示）：\n- 测试用例 1：杂交 \"F2\"，观测计数 $[20,40,20]$，$\\alpha=0.05$。\n- 测试用例 2：杂交 \"F2\"，观测计数 $[10,60,10]$，$\\alpha=0.05$。\n- 测试用例 3：杂交 \"BACKCROSS\"，观测计数 $[35,45]$，$\\alpha=0.05$。\n- 测试用例 4：杂交 \"BACKCROSS\"，观测计数 $[0,40]$，$\\alpha=0.01$。\n- 测试用例 5：杂交 \"F2\"，观测计数 $[0,4,0]$，$\\alpha=0.05$。\n- 测试用例 6：杂交 \"F2\"，观测计数 $[50,50]$，$\\alpha=0.05$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[1,0,1]”），结果顺序与上述测试用例的顺序一致。列表中的元素必须是如上定义的决策代码 $d$。\n\n所有数值答案均无单位。角度单位不适用。显著性水平必须以小数形式提供和解释，而不是百分号。最终输出必须是指定格式的单行文本。不要读取任何输入；仅使用此处提供的测试套件。", "solution": "所述问题已经过严格验证，并被证实是有效的。它在科学上基于孟德尔遗传学和统计假设检验的原理，问题是适定的，其表述客观且明确。因此，我们将提供一个完整的解决方案。\n\n任务是评估遗传杂交中的观测基因型计数是否符合孟德尔定律预测的预期比例。这是一个经典的拟合优度问题，其标准统计工具是 Pearson 卡方（$\\chi^2$）检验。\n\n其核心原理是量化观测数据与特定原假设下预期数据之间的差异。原假设（记为 $H_0$）是指，观测计数源于一个分类分布，其概率由给定杂交设计的孟德尔模型指定。\n\n对于每个测试用例，我们得到一组观测计数 $\\mathbf{O} = (O_1, O_2, \\dots, O_k)$，其中 $k$ 是基因型类别的数量。总观测数为 $N = \\sum_{i=1}^k O_i$。原假设 $H_0$ 提供了一个预期比例向量 $\\mathbf{p} = (p_1, p_2, \\dots, p_k)$，其中 $\\sum_{i=1}^k p_i = 1$ 且每个 $p_i > 0$。\n\n首先，我们对每个测试用例进行必要的初步验证。如果满足以下两个条件之一，则该测试用例被视为无效，并赋予代码 $d = -1$：\n$1$. 观测类别的数量（即向量 $\\mathbf{O}$ 的长度）与指定杂交设计的预期类别数量（即向量 $\\mathbf{p}$ 的长度）不匹配。对于 `$F_2$` 杂交，我们预期有 $k=3$ 个类别（$AA, Aa, aa$）。对于 `BACKCROSS`，我们预期有 $k=2$ 个类别（$Aa, aa$）。\n$2$. 观测到的后代总数为零，即 $N=0$。没有数据，统计检验就毫无意义。\n\n如果测试用例有效，我们继续进行。我们计算原假设下每个类别的期望计数 $\\mathbf{E}$：\n$$ E_i = N \\times p_i $$\nPearson 的 $\\chi^2$ 检验统计量衡量观测计数与期望计数之间的归一化平方偏差：\n$$ \\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i} $$\n更大的 $\\chi^2$ 值表示与孟德尔模型的偏差更大，因此提供了更强的反对 $H_0$ 的证据。\n\n在原假设下，这个 $\\chi^2$ 统计量近似服从自由度为 $\\nu = k-1$ 的卡方分布。自由度的数量是类别数减一，因为总计数 $N$ 是固定的。\n\n为了做出决策，我们将计算出的 $\\chi^2$ 值与该分布进行比较。这通过计算 p 值来完成，p 值是在 $H_0$ 为真的前提下，观测到至少与我们计算出的检验统计量一样极端的统计量的概率。\n$$ \\text{p-value} = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{calculated}}) $$\n最终决策是通过将 p 值与预先指定的显著性水平 $\\alpha$ 进行比较来做出的：\n- 如果 p 值 < $\\alpha$，我们拒绝原假设 $H_0$。观测数据在 $\\alpha$ 显著性水平上与孟德尔模型在统计上不一致。决策代码为 $d=1$。\n- 如果 p 值  $\\alpha$，我们不拒绝原假设 $H_0$。没有足够的统计证据得出数据偏离孟德尔模型的结论。决策代码为 $d=0$。\n\n必须注意，卡方分布是一种近似，当期望计数 $E_i$ 足够大时（例如，$E_i \\ge 5$），其结果最为准确。问题陈述不要求我们基于此条件将测试判为无效，因此无论期望计数的大小如何，我们都将按形式化定义执行计算。\n\n算法如下：\n$1$. 对于每个由杂交设计、观测计数 $\\mathbf{O}$ 和显著性水平 $\\alpha$ 定义的测试用例，检索相应的预期比例 $\\mathbf{p}$。\n$2$. 验证测试用例。如果 `len(O)` $\\neq$ `len(p)` 或 $\\sum O_i = 0$，则结果为 $d=-1$。\n$3$. 如果用例有效，则计算总计数 $N = \\sum O_i$。\n$4$. 计算期望计数向量 $\\mathbf{E} = N \\times \\mathbf{p}$。\n$5$. 使用自由度为 $\\nu = k-1$ 的卡方分布，计算 $\\chi^2$ 统计量及其对应的 p 值。\n$6$. 将 p 值与 $\\alpha$ 进行比较，以确定决策代码是 $d=1$ 还是 $d=0$。\n$7$. 收集所有测试用例的决策代码，并按要求格式化。此过程将使用数值库来实现，以确保精度和效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Validates and solves a suite of genetic cross problems using the chi-squared test.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (cross_design, observed_counts, alpha)\n        (\"F2\", [20, 40, 20], 0.05),\n        (\"F2\", [10, 60, 10], 0.05),\n        (\"BACKCROSS\", [35, 45], 0.05),\n        (\"BACKCROSS\", [0, 40], 0.01),\n        (\"F2\", [0, 4, 0], 0.05),\n        (\"F2\", [50, 50], 0.05),\n    ]\n\n    # Define the expected genotype proportions for the supported cross designs.\n    mendelian_proportions = {\n        \"F2\": np.array([0.25, 0.5, 0.25]),\n        \"BACKCROSS\": np.array([0.5, 0.5])\n    }\n\n    results = []\n    for cross_design, observed_counts, alpha in test_cases:\n        # Step 1: Retrieve expected proportions for the cross design.\n        expected_proportions = mendelian_proportions[cross_design]\n\n        # Step 2: Validate the test case.\n        # Check for mismatch in the number of genotype categories.\n        if len(observed_counts) != len(expected_proportions):\n            results.append(-1)\n            continue\n        \n        # Calculate the total number of offspring.\n        N = sum(observed_counts)\n        \n        # Check if the total count is zero.\n        if N == 0:\n            results.append(-1)\n            continue\n\n        # Step 3: Calculate expected counts.\n        # The observed counts are converted to a NumPy array for vectorized operations.\n        observed_counts_np = np.array(observed_counts)\n        expected_counts = N * expected_proportions\n        \n        # Step 4: Perform Pearson's chi-squared goodness-of-fit test.\n        # The scipy.stats.chisquare function computes the statistic and the p-value.\n        # The degrees of freedom are calculated by the function as k-1.\n        chi2_statistic, p_value = stats.chisquare(f_obs=observed_counts_np, f_exp=expected_counts)\n        \n        # Step 5: Make a decision based on the p-value and significance level alpha.\n        if p_value  alpha:\n            # Reject the null hypothesis.\n            decision_code = 1\n        else:\n            # Do not reject the null hypothesis.\n            decision_code = 0\n            \n        results.append(decision_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403843"}, {"introduction": "在掌握了如何检验数据是否符合经典模型后，我们将更进一步：当生物学过程偏离理想状态时，如何从机理上构建一个预测模型。减数分裂是孟德尔遗传的细胞学基础，但这个过程并非完美无瑕；染色体不分离事件是导致非整倍体（如唐氏综合征）的主要原因。本练习将带领你将减数分裂中不同阶段（MI vs. MII）的出错机制，转化为一个精确的概率模型，从而能够量化非整倍体后代的预期频率。[@problem_id:2403845]", "problem": "你需要编写一个确定性程序，该程序模拟因减数分裂不分离而导致的孟德尔分离定律偏差，并计算在单个目标染色体上为非整倍体的合子的预期比例。建模假设基于标准的减数分裂机制和基本概率论，如下所示。\n\n1. 每个亲本通过减数分裂为目标染色体进行配子发生。减数分裂有两个阶段：减数第一次分裂 (MI) 和减数第二次分裂 (MII)。不分离是指在任一阶段染色体未能正确分离。对于每个亲本，给定两个概率：在一次特定的减数分裂中，目标染色体发生 MI 不分离的概率，记为 $p_I$；以及发生 MII 不分离的概率，记为 $p_{II}$。假设 $p_I \\ge 0$，$p_{II} \\ge 0$，且 $p_I + p_{II} \\le 1$，并且在目标染色体的任何一次减数分裂中，正常分离、MI 不分离或 MII 不分离这三种互斥结果中恰好发生一种。\n\n2. 每次减数分裂中目标染色体的机制性结果如下，忽略目标基因座上的交叉互换，并视所有四个减数分裂后产物（配子）在受精中被使用的可能性均等。\n   - 正常分离：所有四个配子都是单倍体，仅含一个目标染色体拷贝。\n   - MI 不分离：同源染色体在 MI 中未能分离，经过 MII 后，产生两个不含拷贝的配子（对目标染色体为零体）和两个含有两个拷贝的配子（对目标染色体为二体）。\n   - MII 不分离：姐妹染色单体在 MII 中未能分离，产生一个不含拷贝的配子、两个含有一个拷贝的配子和一个含有两个拷贝的目标染色体的配子。\n\n3. 合子是由每个亲本各提供一个配子随机结合而形成的，此过程相互独立。将合子的目标染色体拷贝数定义为两个亲本配子所携带的拷贝数之和。根据本题的定义，非整倍体合子是指其总拷贝数不等于 $2$ 的合子。也就是说，总拷贝数为 $0$、$1$、$3$ 或 $4$ 被认为是非整倍体，而总数为 $2$ 个拷贝则被认为是整倍体，即使这两个拷贝都来自同一个亲本。\n\n4. 对于每个指定的参数集，你必须根据以上假设计算非整倍体合子的预期比例（概率）。你的计算必须相对于指定的概率是精确的，不得使用随机模拟。\n\n5. 你的程序必须硬编码并评估以下包含五个案例的测试套件。在每个案例中，元组提供 $(p_I^{(1)}, p_{II}^{(1)}, p_I^{(2)}, p_{II}^{(2)})$，其中上标 $(1)$ 和 $(2)$ 分别表示第一个和第二个亲本。\n   - 案例 1 (基准孟德尔遗传): $p_I^{(1)} = 0.0$, $p_{II}^{(1)} = 0.0$, $p_I^{(2)} = 0.0$, $p_{II}^{(2)} = 0.0$。\n   - 案例 2 (一个亲本总是 MII 不分离): $p_I^{(1)} = 0.0$, $p_{II}^{(1)} = 1.0$, $p_I^{(2)} = 0.0$, $p_{II}^{(2)} = 0.0$。\n   - 案例 3 (两个亲本总是 MI 不分离): $p_I^{(1)} = 1.0$, $p_{II}^{(1)} = 0.0$, $p_I^{(2)} = 1.0$, $p_{II}^{(2)} = 0.0$。\n   - 案例 4 (中等、不对称的概率): $p_I^{(1)} = 0.01$, $p_{II}^{(1)} = 0.02$, $p_I^{(2)} = 0.03$, $p_{II}^{(2)} = 0.04$。\n   - 案例 5 (一个亲本总是异常，且为混合阶段不分离): $p_I^{(1)} = 0.0$, $p_{II}^{(1)} = 0.0$, $p_I^{(2)} = 0.5$, $p_{II}^{(2)} = 0.5$。\n\n6. 输出规格：\n   - 对于每个案例，计算目标染色体非整倍体合子的预期概率，结果为 $[0,1]$ 范围内的实数，四舍五入到六位小数。\n   - 你的程序应生成单行输出，其中包含五个案例的结果，按顺序排列，形如逗号分隔的列表并用方括号括起，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个四舍五入到六位小数的浮点数。不应打印任何其他文本。\n\n你的解法必须从上述关于减数分裂的机制性事实和基本概率论（独立性和全概率定律）出发，且不得假定任何预先推导的简便公式。不涉及物理单位。不使用角度和百分比。该任务纯属概率组合问题，必须根据给定参数精确求解。", "solution": "问题陈述经过验证，被认为是有效的。它具有科学依据、问题明确且客观。所提供的假设是一个标准的、简化的减数分裂不分离模型，参数一致且完整。该任务是概率论在生物过程中的直接应用，这在计算生物学中是一个可解且有意义的问题。\n\n目标是为单个目标染色体计算合子为非整倍体的概率 $P(\\text{aneuploid})$。非整倍体被定义为合子的总染色体拷贝数不等于 $2$。一个更直接的方法是首先计算互补事件，即整倍体（拷贝数等于 $2$）的概率，记为 $P(\\text{euploid})$，然后利用关系 $P(\\text{aneuploid}) = 1 - P(\\text{euploid})$。\n\n合子是由来自亲本1的一个配子和来自亲本2的一个配子结合而成。设 $C_1$ 和 $C_2$ 分别是代表来自亲本1和亲本2的配子中目标染色体拷贝数的随机变量。如果总拷贝数为 $2$，即 $C_1 + C_2 = 2$，则合子是整倍体。配子的可能拷贝数为 $0$、$1$ 或 $2$。导致整倍体合子的 $(C_1, C_2)$ 组合是 $(0, 2)$、$(1, 1)$ 和 $(2, 0)$。\n\n由于来自每个亲本的配子是独立选择的，整倍体合子的概率是这些互斥组合的概率之和：\n$$P(\\text{euploid}) = P(C_1=0, C_2=2) + P(C_1=1, C_2=1) + P(C_1=2, C_2=0)$$\n$$P(\\text{euploid}) = P(C_1=0)P(C_2=2) + P(C_1=1)P(C_2=1) + P(C_1=2)P(C_2=0)$$\n\n这将问题简化为确定每个亲本的配子拷贝数的概率分布。设 $g_k^{(j)} = P(C_j=k)$ 为来自亲本 $j$ 的配子有 $k$ 个染色体拷贝的概率，其中 $j \\in \\{1, 2\\}$ 且 $k \\in \\{0, 1, 2\\}$。则整倍体概率为：\n$$P(\\text{euploid}) = g_0^{(1)}g_2^{(2)} + g_1^{(1)}g_1^{(2)} + g_2^{(1)}g_0^{(2)}$$\n\n我们为具有给定的减数分裂错误概率的通用亲本 $j$ 推导配子分布 $g_k^{(j)}$：$p_I^{(j)}$ 为减数第一次分裂 (MI) 不分离的概率，$p_{II}^{(j)}$ 为减数第二次分裂 (MII) 不分离的概率。问题陈述了任何一次减数分裂的三个互斥结果：\n1. 正常分离，概率为 $p_N^{(j)} = 1 - p_I^{(j)} - p_{II}^{(j)}$。\n2. MI 不分离，概率为 $p_I^{(j)}$。\n3. MII 不分离，概率为 $p_{II}^{(j)}$。\n\n我们使用全概率定律，以减数分裂事件的类型为条件：\n$$g_k^{(j)} = P(C_j=k) = \\sum_{\\text{event}} P(C_j=k | \\text{event}) P(\\text{event})$$\n\n给定一个减数分裂事件，配子拷贝数的条件概率源于问题的机制性描述。假设所有四个减数分裂产物形成配子的可能性均等。\n- **正常分离**：所有 $4$ 个结果配子都是单倍体（$1$ 个拷贝）。\n  条件概率为：$P(C_j=1 | \\text{Normal}) = 1$，$P(C_j=0 | \\text{Normal}) = 0$，$P(C_j=2 | \\text{Normal}) = 0$。\n- **MI 不分离**：产生 $2$ 个零体（$0$ 个拷贝）和 $2$ 个二体（$2$ 个拷贝）的配子。\n  条件概率为：$P(C_j=0 | \\text{MI-NDJ}) = 2/4 = 0.5$，$P(C_j=1 | \\text{MI-NDJ}) = 0$，$P(C_j=2 | \\text{MI-NDJ}) = 2/4 = 0.5$。\n- **MII 不分离**：产生 $1$ 个零体（$0$ 个拷贝），$2$ 个单倍体（$1$ 个拷贝）和 $1$ 个二体（$2$ 个拷贝）的配子。\n  条件概率为：$P(C_j=0 | \\text{MII-NDJ}) = 1/4 = 0.25$，$P(C_j=1 | \\text{MII-NDJ}) = 2/4 = 0.5$，$P(C_j=2 | \\text{MII-NDJ}) = 1/4 = 0.25$。\n\n现在，我们使用全概率定律为每个配子拷贝数 $k$ 组合这些：\n\n$g_0^{(j)} = P(C_j=0) = P(C_j=0|\\text{Normal})p_N^{(j)} + P(C_j=0|\\text{MI-NDJ})p_I^{(j)} + P(C_j=0|\\text{MII-NDJ})p_{II}^{(j)}$\n$g_0^{(j)} = (0) \\cdot (1 - p_I^{(j)} - p_{II}^{(j)}) + (0.5) \\cdot p_I^{(j)} + (0.25) \\cdot p_{II}^{(j)} = 0.5 p_I^{(j)} + 0.25 p_{II}^{(j)}$\n\n$g_1^{(j)} = P(C_j=1) = P(C_j=1|\\text{Normal})p_N^{(j)} + P(C_j=1|\\text{MI-NDJ})p_I^{(j)} + P(C_j=1|\\text{MII-NDJ})p_{II}^{(j)}$\n$g_1^{(j)} = (1) \\cdot (1 - p_I^{(j)} - p_{II}^{(j)}) + (0) \\cdot p_I^{(j)} + (0.5) \\cdot p_{II}^{(j)} = 1 - p_I^{(j)} - 0.5 p_{II}^{(j)}$\n\n$g_2^{(j)} = P(C_j=2) = P(C_j=2|\\text{Normal})p_N^{(j)} + P(C_j=2|\\text{MI-NDJ})p_I^{(j)} + P(C_j=2|\\text{MII-NDJ})p_{II}^{(j)}$\n$g_2^{(j)} = (0) \\cdot (1 - p_I^{(j)} - p_{II}^{(j)}) + (0.5) \\cdot p_I^{(j)} + (0.25) \\cdot p_{II}^{(j)} = 0.5 p_I^{(j)} + 0.25 p_{II}^{(j)}$\n\n总体算法如下：\n1. 对于五个测试案例中的每一个，取输入参数 $(p_I^{(1)}, p_{II}^{(1)}, p_I^{(2)}, p_{II}^{(2)})$。\n2. 对于每个亲本 $j \\in \\{1, 2\\}$，使用上述公式计算配子拷贝数概率 $g_0^{(j)}$，$g_1^{(j)}$ 和 $g_2^{(j)}$。\n3. 计算整倍体合子的概率：$P(\\text{euploid}) = g_0^{(1)}g_2^{(2)} + g_1^{(1)}g_1^{(2)} + g_2^{(1)}g_0^{(2)}$。\n4. 计算非整倍体合子的最终概率：$P(\\text{aneuploid}) = 1 - P(\\text{euploid})$。\n5. 按要求将结果四舍五入到六位小数。\n\n此过程被实施以计算给定测试套件所需的所有概率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are necessary for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the meiotic non-disjunction problem by calculating the probability of\n    aneuploidy for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (p_I_parent1, p_II_parent1, p_I_parent2, p_II_parent2)\n    test_cases = [\n        (0.0, 0.0, 0.0, 0.0),  # Case 1: Baseline Mendelian\n        (0.0, 1.0, 0.0, 0.0),  # Case 2: One parent always MII non-disjunction\n        (1.0, 0.0, 1.0, 0.0),  # Case 3: Both parents always MI non-disjunction\n        (0.01, 0.02, 0.03, 0.04),  # Case 4: Moderate, asymmetric rates\n        (0.0, 0.0, 0.5, 0.5)   # Case 5: One parent always abnormal (mixed)\n    ]\n\n    results = []\n    for case in test_cases:\n        p_I1, p_II1, p_I2, p_II2 = case\n        \n        # This function encapsulates the core logic derived from first principles.\n        prob_aneuploidy = calculate_aneuploidy_prob(p_I1, p_II1, p_I2, p_II2)\n        results.append(prob_aneuploidy)\n\n    # Format the final output string as specified.\n    # Each result is formatted to six decimal places.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\ndef get_gamete_distribution(p_I, p_II):\n    \"\"\"\n    Calculates the probability distribution of gamete copy numbers (0, 1, or 2)\n    for a single parent based on non-disjunction probabilities.\n\n    Args:\n        p_I (float): Probability of Meiosis I non-disjunction.\n        p_II (float): Probability of Meiosis II non-disjunction.\n\n    Returns:\n        tuple: A tuple (g0, g1, g2) where gi is the probability of a gamete\n               having i copies of the chromosome.\n    \"\"\"\n    \n    # Probability of a gamete with 0 copies (nullisomic)\n    # This arises from MI-NDJ (yields 2/4 nullisomic) or MII-NDJ (yields 1/4 nullisomic).\n    g0 = 0.5 * p_I + 0.25 * p_II\n    \n    # Probability of a gamete with 2 copies (disomic)\n    # This also arises from MI-NDJ (yields 2/4 disomic) or MII-NDJ (yields 1/4 disomic).\n    g2 = 0.5 * p_I + 0.25 * p_II\n\n    # Probability of a gamete with 1 copy (haploid)\n    # This arises from normal meiosis (yields 4/4 haploid) or MII-NDJ (yields 2/4 haploid).\n    # It is most easily calculated as 1 minus the other probabilities.\n    # The direct derivation is: (1 - p_I - p_II) * 1.0 + p_II * 0.5 = 1 - p_I - 0.5 * p_II.\n    g1 = 1.0 - g0 - g2\n\n    return (g0, g1, g2)\n\ndef calculate_aneuploidy_prob(p_I1, p_II1, p_I2, p_II2):\n    \"\"\"\n    Computes the total probability of an aneuploid zygote.\n\n    Args:\n        p_I1, p_II1 (float): Non-disjunction rates for parent 1.\n        p_I2, p_II2 (float): Non-disjunction rates for parent 2.\n\n    Returns:\n        float: The probability of aneuploidy.\n    \"\"\"\n    # Get the gamete copy number distributions for each parent.\n    dist1 = get_gamete_distribution(p_I1, p_II1)\n    dist2 = get_gamete_distribution(p_I2, p_II2)\n    \n    g0_1, g1_1, g2_1 = dist1\n    g0_2, g1_2, g2_2 = dist2\n\n    # A zygote is euploid if the sum of chromosome copies is 2.\n    # The independent events leading to a euploid zygote are:\n    # - Parent 1 contributes 0, Parent 2 contributes 2\n    # - Parent 1 contributes 1, Parent 2 contributes 1\n    # - Parent 1 contributes 2, Parent 2 contributes 0\n    prob_euploid = (g0_1 * g2_2) + (g1_1 * g1_2) + (g2_1 * g0_2)\n    \n    # The probability of aneuploidy is the complement of euploidy.\n    prob_aneuploid = 1.0 - prob_euploid\n    \n    return prob_aneuploid\n\nsolve()\n```", "id": "2403845"}, {"introduction": "最后一个练习将我们的计算实践推向了更复杂的领域：通过模拟涌现现象来理解发育遗传学。三花猫（Calico cat）美丽的斑纹并非由一个简单的基因直接决定，而是雌性哺乳动物细胞中X染色体随机失活这一微观事件，在发育过程中“涌现”出的宏观图案。本练习将指导你构建一个基于细胞自动机的空间模型，在二维网格上模拟克隆性增殖，直观地再现从随机的细胞决策到复杂组织模式的形成过程。[@problem_id:2403838]", "problem": "您的任务是通过构建一个在离散组织上随机X染色体失活的数学模型，来形式化并模拟家猫橘色基因座上杂合子雌性符合孟德尔遗传的X连锁镶嵌现象。\n\n考虑一个大小为 $N \\times N$ 的方形网格，由整数坐标 $(i,j)$ 索引，其中 $i \\in \\{0,1,\\dots,N-1\\}$ 且 $j \\in \\{0,1,\\dots,N-1\\}$。每个网格点代表观察时的一个体细胞。使用一个以给定非负整数种子 $r$ 初始化的伪随机数生成器 (PRNG)，从 $N^2$ 个网格点中无放回地均匀随机选择一组 $M$ 个不同的创始位点 $\\{s_k\\}_{k=1}^M$。每个创始位点 $s_k$ 独立地将其两条X染色体中的一条失活，使得活跃的X染色体在一个X连锁基因座上编码橘色或非橘色色素。将创始位点的表达状态记作 $S_k \\in \\{0,1\\}$，其中 $S_k=1$ 表示橘色表达，$S_k=0$ 表示非橘色表达。随机变量 $S_k$ 在各 $k$ 之间独立地服从参数为 $p \\in [0,1]$ 的伯努利分布($\\mathrm{Bernoulli}(p)$)。\n\n按如下方式对克隆扩张进行几何建模。对于任意网格点 $u=(i,j)$ 和任意创始位点 $s_k=(x_k,y_k)$，定义曼哈顿距离\n$$\nd_1(u,s_k) = |i-x_k| + |j-y_k|.\n$$\n对于每个网格点 $u$，将其分配给在 $k \\in \\{1,\\dots,M\\}$ 中使 $d_1(u,s_k)$ 最小化的创始位点的索引集合中的一个。如果存在唯一的最小化子，则选择它。如果存在多个最小化子，则使用以种子 $r$ 初始化的同一个PRNG（并从其所有先前使用的状态继续），在这些最小化子中均匀随机地选择一个。令 $f(u) \\in \\{1,\\dots,M\\}$ 表示为 $u$ 选择的创始位点索引。那么，$u$ 处的表达状态为 $G(u) = S_{f(u)} \\in \\{0,1\\}$。将这些状态收集到一个 $N \\times N$ 的网格 $G$ 中，其中 $G_{ij} = G((i,j))$。\n\n对于下面测试套件中给出的每组参数 $(N,M,p,r)$，计算以下四个量化输出：\n\n1) 橘色部分比例 $F$，定义为\n$$\nF = \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} G_{ij}.\n$$\n报告 $F$ 值，四舍五入到6位小数。\n\n2) 橘色斑块数量 $C$，定义为在顶点集 $\\{(i,j) \\mid G_{ij}=1\\}$ 上的诱导子图中，使用4-邻域邻接关系（当且仅当两个位点的坐标在一个维度上相差恰好为1，而在另一维度上相等时，它们是相邻的）的连通分量数量。报告 $C$ 为一个整数。\n\n3) 平均橘色斑块面积 $A$，定义为\n$$\nA = \n\\begin{cases}\n\\frac{1}{C}\\sum_{c=1}^{C} |P_c|,  \\text{if } C \\ge 1,\\\\\n0,  \\text{if } C=0,\n\\end{cases}\n$$\n其中 $P_c$ 是属于第 $c$ 个橘色连通分量的网格点集合， $|P_c|$ 是其基数。报告 $A$ 值，四舍五入到6位小数。\n\n4) 界面长度 $L$，定义为在4-邻域邻接关系下，状态不同的相邻网格点之间的边数：\n$$\nL = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-2} \\mathbf{1}[G_{i,j} \\ne G_{i,j+1}] \\;+\\; \\sum_{i=0}^{N-2}\\sum_{j=0}^{N-1} \\mathbf{1}[G_{i,j} \\ne G_{i+1,j}],\n$$\n报告为一个整数。\n\n所有随机性必须使用指定的、以给定种子 $r$ 初始化的PRNG生成，并按顺序首先用于抽样创始位点位置，然后抽样创始位点状态，最后在将网格点分配给创始位点时解决任何距离平局问题。\n\n测试套件。严格按照以下顺序使用以下参数集：\n- 情况 1: $(N,M,p,r) = (8,5,0.5,42)$。\n- 情况 2: $(N,M,p,r) = (1,1,0.5,7)$。\n- 情况 3: $(N,M,p,r) = (10,1,0.5,123)$。\n- 情况 4: $(N,M,p,r) = (12,30,0.8,314159)$。\n- 情况 5: $(N,M,p,r) = (6,36,0.3,271828)$。\n\n最终输出格式。您的程序应产生单行输出，其中包含按顺序排列的每个情况的结果记录列表，无空格。每条记录是该情况的列表 $[F,C,A,L]$。因此，整个输出必须是形如\n$[[F_1,C_1,A_1,L_1],[F_2,C_2,A_2,L_2],\\dots,[F_5,C_5,A_5,L_5]]$\n的单行，其中 $F_k$ 和 $A_k$ 四舍五入到6位小数， $C_k$ 和 $L_k$ 为整数。", "solution": "其生物学基础是X连锁基因座上的孟德尔分离定律与雌性哺乳动物中随机X染色体失活相结合。一个基因型为 $X^O X^B$ 的杂合子雌性在一个X连锁色素基因座上携带两个等位基因：一个橘色等位基因和一个非橘色等位基因。在早期胚胎发生过程中，随机的X染色体失活导致每个体细胞谱系失活一条X染色体，从而在该谱系中固定了活跃的等位基因。可观察到的镶嵌体是表达橘色或非橘色色素的克隆在空间上的混合。这个过程可以抽象为占据空间的独立创始谱系，并为每个谱系分配一个表达状态。\n\n我们将其形式化如下。考虑一个 $N \\times N$ 的离散网格，代表被细胞占据的位点。设 $\\{s_k\\}_{k=1}^M$ 为使用一个固定种子 $r$ 的伪随机数生成器（PRNG）从 $N^2$ 个网格点中无放回均匀随机放置的 $M$ 个创始位点。每个创始位点 $k$ 被赋予一个独立的表达状态 $S_k \\in \\{0,1\\}$，服从分布 $\\mathrm{Bernoulli}(p)$，其中 $S_k=1$ 表示橘色等位基因活跃（橘色表达），$S_k=0$ 表示非橘色等位基因活跃（非橘色表达）。这模拟了孟德尔杂合状态与随机X染色体失活的结合，其中 $p$ 允许存在可能的偏移。\n\n为了将创始位点映射到所有网格点，我们为任意位点 $u=(i,j)$ 和创始位点 $s_k=(x_k,y_k)$ 定义曼哈顿距离\n$$\nd_1(u,s_k) = |i-x_k| + |j-y_k|.\n$$\n这在 $L_1$ 度量下产生了一个类沃罗诺伊划分：每个位点 $u$ 被分配给一个在 $k \\in \\{1,\\dots,M\\}$ 中使 $d_1(u,s_k)$ 最小化的创始位点的索引集合中的一个。如果最小化子是唯一的，则选择它；如果有多个最小化子，则使用同一个PRNG（从其当前状态继续，从而使所有随机性都由单个种子 $r$ 全局耦合）随机选择一个。用 $f(u)$ 表示被选中的创始位点索引。那么 $u$ 处的表达状态为 $G(u) = S_{f(u)}$，产生一个网格 $G \\in \\{0,1\\}^{N \\times N}$，其中 $G_{ij} = G((i,j))$。\n\n根据 $G$ 计算四个所需输出：\n\n1) 橘色部分比例为\n$$\nF = \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} G_{ij}.\n$$\n这是表达橘色的位点的经验比例。在给定随机创始位点和状态的条件下，其期望值为 $\\mathbb{E}[F]=p$，但有限尺寸的几何形状和决胜局机制会引入围绕 $p$ 的采样变异性。报告的值必须四舍五入到6位小数。\n\n2) 橘色斑块数量 $C$ 是在使用4-邻域邻接关系的诱导子图 $\\{(i,j) : G_{ij}=1\\}$ 中的连通分量数量。这通过扫描网格并对 $G_{ij}=1$ 的位点执行广度优先或深度优先搜索来计算，标记已访问的位点以避免重复计数。每当发现一个未访问的橘色位点时，便开始一个新的分量，并访问所有可通过4-邻域移动到达的橘色位点；此类开始的总数等于 $C$。\n\n3) 平均橘色斑块面积 $A$ 为\n$$\nA = \n\\begin{cases}\n\\frac{1}{C}\\sum_{c=1}^{C} |P_c|,  C \\ge 1,\\\\\n0,  C=0,\n\\end{cases}\n$$\n其中 $P_c$ 是第 $c$ 个橘色连通分量中的网格点集合。因为这些分量构成了橘色位点的划分，所以 $\\sum_{c=1}^{C} |P_c| = \\sum_{i,j} G_{ij}$，因此当 $C \\ge 1$ 时，$A$ 等于橘色位点的总数除以 $C$，当没有橘色位点时等于 $0$。报告的值必须四舍五入到6位小数。\n\n4) 界面长度 $L$ 是在4-邻域邻接关系下，状态不同的相邻位点对的数量。为避免重复计数，分别对水平差异和垂直差异求和：\n$$\nL = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-2} \\mathbf{1}[G_{i,j} \\ne G_{i,j+1}] \\;+\\; \\sum_{i=0}^{N-2}\\sum_{j=0}^{N-1} \\mathbf{1}[G_{i,j} \\ne G_{i+1,j}],\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。这将得到一个整数。\n\n带种子 $r$ 的PRNG按顺序在三个地方被一致地使用：抽样 $M$ 个创始位点（无放回），抽样 $M$ 个独立的创始位点状态 $S_k \\sim \\mathrm{Bernoulli}(p)$，以及在将位点分配给创始位点时解决任何距离平局问题。这对每种情况都完全确定了 $G$ 和输出。最终程序必须输出单行，包含5条记录，每种测试情况一条，每条记录为 $[F,C,A,L]$，其中 $F$ 和 $A$ 四舍五入到6位小数， $C$ 和 $L$ 为整数，无空格，并按照测试套件中指定的顺序排列。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sample_founders(N, M, rng):\n    # Sample M distinct lattice indices from N*N sites\n    total = N * N\n    flat_indices = rng.choice(total, size=M, replace=False)\n    rows = flat_indices // N\n    cols = flat_indices % N\n    founders = np.stack([rows, cols], axis=1)  # shape (M, 2)\n    return founders\n\ndef sample_founder_states(M, p, rng):\n    # Bernoulli(p) for each founder: True for orange (1), False for non-orange (0)\n    return rng.random(M)  p\n\ndef assign_sites_to_founders(N, founders, rng):\n    # For each site, compute Manhattan distances to all founders and choose minimizer\n    M = founders.shape[0]\n    assigned = np.empty((N, N), dtype=np.int32)\n    # Pre-extract founder coords for vectorized distance computation per cell\n    f_rows = founders[:, 0]\n    f_cols = founders[:, 1]\n    for i in range(N):\n        for j in range(N):\n            # Manhattan distances to all founders\n            dists = np.abs(f_rows - i) + np.abs(f_cols - j)\n            min_dist = dists.min()\n            candidates = np.flatnonzero(dists == min_dist)\n            if candidates.size == 1:\n                assigned[i, j] = candidates[0]\n            else:\n                # Randomly choose among ties\n                assigned[i, j] = rng.choice(candidates)\n    return assigned\n\ndef count_orange_components_and_sizes(grid):\n    # grid: boolean or 0/1 array of shape (N, N)\n    N = grid.shape[0]\n    visited = np.zeros_like(grid, dtype=bool)\n    comp_sizes = []\n    # 4-neighbor directions\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i, j] and not visited[i, j]:\n                # Start BFS\n                stack = [(i, j)]\n                visited[i, j] = True\n                size = 0\n                while stack:\n                    r, c = stack.pop()\n                    size += 1\n                    for dr, dc in dirs:\n                        rr, cc = r + dr, c + dc\n                        if 0 = rr  N and 0 = cc  N:\n                            if grid[rr, cc] and not visited[rr, cc]:\n                                visited[rr, cc] = True\n                                stack.append((rr, cc))\n                comp_sizes.append(size)\n    return len(comp_sizes), comp_sizes\n\ndef interface_length(grid):\n    # Count horizontal and vertical interfaces where neighbors differ\n    horiz = np.sum(grid[:, :-1] != grid[:, 1:])\n    vert = np.sum(grid[:-1, :] != grid[1:, :])\n    return int(horiz + vert)\n\ndef run_case(N, M, p, r):\n    rng = np.random.default_rng(r)\n    founders = sample_founders(N, M, rng)\n    founder_states = sample_founder_states(M, p, rng)\n    assigned = assign_sites_to_founders(N, founders, rng)\n    grid = founder_states[assigned].astype(np.int8)  # 1 for orange, 0 for non-orange\n\n    total_cells = N * N\n    orange_count = int(grid.sum())\n    F = orange_count / total_cells\n\n    C, sizes = count_orange_components_and_sizes(grid.astype(bool))\n    if C  0:\n        A = orange_count / C\n    else:\n        A = 0.0\n\n    L = interface_length(grid)\n\n    # Round floats to 6 decimal places for output formatting\n    F = round(F + 0.0, 6)\n    A = round(A + 0.0, 6)\n\n    return (F, C, A, L)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, M, p, r)\n    test_cases = [\n        (8, 5, 0.5, 42),\n        (1, 1, 0.5, 7),\n        (10, 1, 0.5, 123),\n        (12, 30, 0.8, 314159),\n        (6, 36, 0.3, 271828),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, p, r = case\n        F, C, A, L = run_case(N, M, p, r)\n        results.append((F, C, A, L))\n\n    # Build exact output string with no spaces, floats with 6 decimals\n    record_strs = []\n    for F, C, A, L in results:\n        # Ensure fixed 6 decimal places for floats\n        record_strs.append(f\"[{F:.6f},{C},{A:.6f},{L}]\")\n    output = \"[\" + \",\".join(record_strs) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2403838"}]}