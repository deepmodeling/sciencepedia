{"hands_on_practices": [{"introduction": "在深入研究复杂的宏基因组组装算法之前，理解其理论基础至关重要。这个练习通过一个理想化的思想实验，探讨了在无测序错误和无重复序列的完美条件下，组装一个基因组所需的最小测序读段数量。通过推导基因组长度 $G$、读段长度 $L$ 和所需读段数之间的关系，你将对测序覆盖度和重叠连接这两个核心概念建立起坚实的直观理解 [@problem_id:2405190]。", "problem": "一个长度为 $1 \\times 10^{6}$ 个碱基对（bp）的单线性DNA基因组将由无错误的测序读长组装而成，每个读长的长度固定为 $L$ bp。假设基因组在读长间出现的任何重叠长度上都不包含由重复序列引起的歧义（因此任何观察到的序列重叠都能唯一确定邻接关系），并且组装目标是产生一个跨越整个 $1 \\times 10^{6}$ bp的连续序列。要实现这一目标，理论上需要的最少读长数量是多少？请用一个关于 $L$ 的封闭形式符号表达式来表示你的答案。请提供精确表达式作为最终答案；无需四舍五入。", "solution": "在尝试解答之前，首先对问题陈述进行验证。\n\n首先，我逐字提取已知条件：\n- 基因组类型：单线性DNA基因组。\n- 基因组长度：$G = 1 \\times 10^{6}$ 碱基对（bp）。\n- 读长长度：$L$ bp（固定）。\n- 读长质量：无错误。\n- 组装条件：无重复序列引起的歧义；任何观察到的序列重叠都能唯一确定邻接关系。\n- 组装目标：产生一个跨越整个 $1 \\times 10^{6}$ bp的连续序列。\n- 问题：长度为 $L$ 的读长的理论最少数量。\n- 答案格式：关于 $L$ 的封闭形式符号表达式。\n\n接下来，我根据所需标准验证这些已知条件。\n1.  **科学依据：** 该问题是基因组学中的一个经典理论问题，涉及基因组组装的最低要求。基因组长度、读长长度、重叠和连续性等概念是计算生物学的基础。该问题在科学上是合理的。\n2.  **适定性：** 问题要求“理论最少”数量的读长，这意味着读长的排列是理想化的、最优的。所给条件（无错误读长、无重复序列）是此类理论问题的标准简化，确保了唯一且有意义的解的存在。该问题是适定的。\n3.  **客观性：** 问题陈述使用了精确的量化语言，没有主观性或歧义。\n4.  **完整性：** 问题提供了推导理论最少读长数量所需的所有信息（$G$ 和 $L$）。它是自足的。\n5.  **可行性：** 尽管真实的基因组组装是一个随机过程（鸟枪法测序），并因错误和重复序列而变得复杂，但此问题探讨的是确定性的下限，这是一个有效且有用的理论构造。\n\n结论是该问题有效。它是生物信息学理论中一个定义明确的练习。我将继续推导解答。\n\n设基因组的长度为 $G$，其中 $G = 1 \\times 10^{6}$ bp。设每个读长的长度为 $L$。读长的数量为 $N$。我们旨在找到 $N$ 的最小可能整数值，记为 $N_{min}$。\n\n为了成功地组装成一个覆盖整个基因组的单一连续序列（contig），必须满足两个条件：\n1.  **覆盖度：** 从 $1$ 到 $G$ 的每一个碱基对都必须被至少一个读长所包含。\n2.  **连通性：** 读长集合必须在重叠图中形成一个单一的连通分量，这意味着它们可以按顺序排列，使得每个读长都与下一个读长重叠。\n\n为了找到最小读长数量 $N_{min}$，我们必须以最有效的方式排列读长。这意味着在保持组装连通性的同时，每个读长必须贡献尽可能多的新的、先前未覆盖的序列长度。这可以通过最小化序列中相邻读长之间的重叠来实现。\n\n问题陈述断言“任何观察到的序列重叠都能唯一确定邻接关系”。这是一条关键信息。它意味着即使是最小可能的重叠也足以可靠地连接两个读长。在碱基对的离散序列中，可能的最小重叠是一个碱基对。设这个最小重叠为 $o_{min} = 1$ bp。\n\n让我们构建读长的最优平铺方式。第一个读长 $R_1$ 覆盖了基因组中长度为 $L$ 的一个片段。为了最大化下一个读长 $R_2$ 所覆盖的总长度，我们将其放置在与 $R_1$ 恰好重叠 $o_{min} = 1$ bp 的位置。这样做，$R_2$ 将总覆盖长度延伸了 $L - o_{min} = L - 1$ 个碱基对。\n\n按照这个逻辑，第一个读长覆盖了 $L$ 个碱基对。随后的每一个 $N-1$ 个读长都将连续序列（contig）额外延伸 $L-1$ 个碱基对。因此，以这种最优配置排列的 $N$ 个读长所覆盖的总长度 $C(N)$ 为：\n$$C(N) = L + (N-1)(L-1)$$\n\n为了使组装完成，这个总覆盖长度必须至少等于整个基因组的长度 $G$。\n$$L + (N-1)(L-1) \\ge G$$\n\n我们现在对这个不等式求解 $N$。只有当 $L>1$ 时，问题的提法才有意义，因为长度为 $L=1$ 的读长无法形成重叠来创建连续序列（contig）。因此，我们假设 $L > 1$，这意味着 $L-1 > 0$。\n$$(N-1)(L-1) \\ge G-L$$\n$$N-1 \\ge \\frac{G-L}{L-1}$$\n$$N \\ge 1 + \\frac{G-L}{L-1}$$\n简化右侧：\n$$N \\ge \\frac{L-1}{L-1} + \\frac{G-L}{L-1} = \\frac{(L-1) + (G-L)}{L-1} = \\frac{G-1}{L-1}$$\n所以，我们得到条件 $N \\ge \\frac{G-1}{L-1}$。由于 $N$ 必须是一个整数（因为它是读长的计数），最小读长数量 $N_{min}$ 是满足此不等式的最小整数。这由向上取整函数（ceiling function）给出：\n$$N_{min} = \\left\\lceil \\frac{G-1}{L-1} \\right\\rceil$$\n问题指定了基因组长度 $G = 1 \\times 10^6$。代入此值，得到关于 $L$ 的最终表达式：\n$$N_{min} = \\left\\lceil \\frac{1 \\times 10^{6} - 1}{L-1} \\right\\rceil$$\n这就是所需的理论最少读长数量。", "answer": "$$\\boxed{\\left\\lceil \\frac{10^{6} - 1}{L - 1} \\right\\rceil}$$", "id": "2405190"}, {"introduction": "基因组组装的初步产物通常是离散的重叠群（contigs）。为了构建更完整的基因组草图，我们需要将这些片段连接起来，这个过程称为“脚手架构建”（scaffolding）。此练习将指导你实现一个核心的脚手架构建算法，学习如何利用双端测序读段（paired-end reads）的配对信息来推断重叠群之间的顺序和方向，并将它们组织成一个加权图 [@problem_id:2405168]。这是从零散片段到接近完整基因组的关键一步。", "problem": "给定一个有限的拼接体（contig）集合和一个有限的、位于拼接体末端的双末端（PE）读段映射（read mapping）集合。将支架（scaffold）推断问题建模为一个简单的无向加权图。设拼接体集合为 $C=\\{1,2,\\dots,n\\}$，其中每个元素是一个整数标识符。设双末端读段映射集合为 $P$，其中每个元素是一个有序6元组 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$，其组成部分如下：$c_1\\in C$，$c_2\\in C$，$e_1\\in\\{\\mathrm{L},\\mathrm{R}\\}$，$e_2\\in\\{\\mathrm{L},\\mathrm{R}\\}$，$s_1\\in\\{+,-\\}$，以及 $s_2\\in\\{+,-\\}$。符号 $\\mathrm{L}$ 表示拼接体的左端，$\\mathrm{R}$ 表示拼接体的右端；符号 $+$ 和 $-$ 分别表示相对于拼接体参考链的正向和反向读段方向。假设双末端测序采用标准的内向片段方向模型（通常称为FR）：当一个读段对的一个配对读段以正向方向映射到一个右端，而另一个配对读段以反向方向映射到一个左端时，这两个不同的拼接体之间就产生了一个有效的连接。形式上，一个读段对 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$ 支持一个连接，当且仅当 $c_1\\neq c_2$ 并且 $(e_1=\\mathrm{R}\\wedge s_1=+ \\wedge e_2=\\mathrm{L}\\wedge s_2=-)$ 或 $(e_1=\\mathrm{L}\\wedge s_1=- \\wedge e_2=\\mathrm{R}\\wedge s_2=+)$ 成立。\n\n定义支架图 $G=(V,E)$，其中 $V=C$。对于每个无序对 $\\{u,v\\}$（其中 $u,v\\in C$ 且 $u\\neq v$），将边权重 $w(u,v)$ 定义为 $P$ 中根据上述规则支持 $u$ 和 $v$ 之间连接的读段对的数量。给定一个非负整数阈值参数 $\\tau$，当且仅当 $w(u,v)\\ge \\tau$ 时，在 $u$ 和 $v$ 之间添加一条无向边到 $E$ 中。$G$ 的输出表示必须是一个三元组列表，其中每个三元组是列表 $[u,v,w(u,v)]$ 且满足 $u<v$，并且该三元组集合按 $(u,v)$ 的升序字典序排序。\n\n你的任务是编写一个程序，为以下每个测试用例构建相应的支架图，并为每个用例输出指定格式的、已排序的边三元组列表。将所有测试用例的结果按测试用例顺序汇总到一个列表中。\n\n测试用例 $1$：\n- 拼接体：$C=\\{1,2,3\\}$。\n- 阈值：$\\tau=2$。\n- 双末端映射 $P$ 以以下 $6$-元组形式给出：\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,1,\\mathrm{R},+\\rangle$,\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{L},+,2,\\mathrm{R},-\\rangle$,\n  $\\langle 1,\\mathrm{R},+,3,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{R},+,1,\\mathrm{L},-\\rangle$.\n\n测试用例 $2$：\n- 拼接体：$C=\\{1,2\\}$。\n- 阈值：$\\tau=1$。\n- 双末端映射 $P$：\n  $\\langle 1,\\mathrm{L},+,2,\\mathrm{R},-\\rangle$,\n  $\\langle 1,\\mathrm{R},+,1,\\mathrm{L},-\\rangle$.\n\n测试用例 $3$：\n- 拼接体：$C=\\{1,2,3,4\\}$。\n- 阈值：$\\tau=1$。\n- 双末端映射 $P$：\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,1,\\mathrm{R},+\\rangle$,\n  $\\langle 2,\\mathrm{R},+,3,\\mathrm{L},-\\rangle$,\n  $\\langle 4,\\mathrm{L},-,3,\\mathrm{R},+\\rangle$,\n  $\\langle 3,\\mathrm{R},+,4,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{R},+,4,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{L},+,3,\\mathrm{R},-\\rangle$,\n  $\\langle 3,\\mathrm{R},+,3,\\mathrm{L},-\\rangle$.\n\n测试用例 $4$：\n- 拼接体：$C=\\{1,2,3\\}$。\n- 阈值：$\\tau=3$。\n- 双末端映射 $P$：\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,1,\\mathrm{R},+\\rangle$,\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{L},+,2,\\mathrm{R},-\\rangle$,\n  $\\langle 3,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,3,\\mathrm{R},+\\rangle$.\n\n最终输出格式：你的程序应该生成单行输出，包含一个长度为 $4$ 的列表，其中第 $i$ 个元素是测试用例 $i$ 的边三元组 $[u,v,w]$ 列表，按 $(u,v)$ 排序。整行必须是一个由方括号括起来的列表，元素之间用逗号分隔，例如 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。输出中的所有标识符都是整数；不要打印任何字符串、单位或额外的文本。", "solution": "该问题是有效的。它以生物信息学（具体来说是基因组组装）的原理为科学依据，并且定义清晰、客观，问题本身是适定的。\n\n目标是根据一组拼接体 $C$ 和双末端读段映射 $P$ 来构建一个支架图 $G=(V, E)$。图的顶点 $V$ 就是拼接体本身。边 $E$ 及其对应的权重是通过根据指定的生物学模型分析双末端读段数据来确定的。\n\n构建此图的算法流程概述如下：\n\n1.  **边权重的初始化**：该图是无向的，因此对于来自集合 $C=\\{1, 2, \\dots, n\\}$ 的每一对不同的拼接体无序对 $\\{u, v\\}$，我们需要计算一个相关联的权重 $w(u,v)$。完成此任务的合适数据结构是关联数组（或字典），它将边的规范表示（例如一个有序元组 $(\\min(u,v), \\max(u,v))$）映射到其整数权重。所有潜在的权重都隐式地初始化为 $0$。\n\n2.  **处理双末端映射**：我们遍历集合 $P$ 中提供的每个双末端读段映射 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$。对于每个映射，我们必须确定它是否构成了两个不同拼接体之间的有效连接。\n\n3.  **连接支持的验证**：如果一个读段对遵循标准的内向片段方向模型（也称为FR模型），则它为支架连接提供了证据。问题对此条件进行了精确的形式化。一个读段对 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$ 支持拼接体 $c_1$ 和 $c_2$ 之间的连接，当且仅当满足两个标准：\n    a. 拼接体必须是不同的，即 $c_1 \\neq c_2$。同一拼接体内的映射在支架构建中被忽略。\n    b. 映射配置必须匹配两种对称模式之一：\n        i.  $(e_1=\\mathrm{R} \\wedge s_1=+ \\wedge e_2=\\mathrm{L} \\wedge s_2=-)$：一个配对读段以正向方向映射到拼接体 $c_1$ 的右端，另一个配对读段以反向方向映射到拼接体 $c_2$ 的左端。\n        ii. $(e_1=\\mathrm{L} \\wedge s_1=- \\wedge e_2=\\mathrm{R} \\wedge s_2=+)$：对称情况，一个配对读段映射到 $c_1$ 的左端（反向），另一个映射到 $c_2$ 的右端（正向）。\n    从物理上讲，这些模式表明拼接体 $c_1$ 和 $c_2$ 在源基因组中是相邻的，其中一个的右端与另一个的左端临近。\n\n4.  **权重累加**：如果一个读段映射被验证为支持拼接体 $c_1$ 和 $c_2$ 之间的连接，我们就增加与这对拼接体关联的权重。使用规范表示，我们更新权重 $w(\\min(c_1, c_2), \\max(c_1, c_2))$。对 $P$ 中的所有映射重复此过程，汇总每个潜在连接的总证据。\n\n5.  **通过阈值化构建图**：处理完所有映射后，我们得到了一套完整的原始边权重。图 $G$ 的最终边集合 $E$ 由给定的非负整数阈值 $\\tau$ 决定。一条边 $\\{u, v\\}$ 被包含在 $E$ 中，当且仅当其累加权重 $w(u, v) \\ge \\tau$。此步骤会滤除证据不足的连接，只保留那些由大量读段对支持的连接。\n\n6.  **输出生成**：图的最终表示要求是一个三元组列表 $[u, v, w(u,v)]$，其中 $u < v$。此列表必须根据对 $(u, v)$ 按升序字典序排序。这可以通过遍历我们的权重字典的键（这些键已经是规范的并且可以排序），根据阈值 $\\tau$ 进行筛选，并按指定格式化结果边来实现。然后，将所有测试用例的结果汇总到一个列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the scaffold graph construction problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"C\": {1, 2, 3}, \"tau\": 2, \"P\": [\n                (1, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 1, 'R', '+'),\n                (1, 'R', '+', 2, 'L', '-'),\n                (1, 'L', '+', 2, 'R', '-'),\n                (1, 'R', '+', 3, 'L', '-'),\n                (1, 'R', '+', 1, 'L', '-')\n            ]\n        },\n        {\n            \"C\": {1, 2}, \"tau\": 1, \"P\": [\n                (1, 'L', '+', 2, 'R', '-'),\n                (1, 'R', '+', 1, 'L', '-')\n            ]\n        },\n        {\n            \"C\": {1, 2, 3, 4}, \"tau\": 1, \"P\": [\n                (1, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 1, 'R', '+'),\n                (2, 'R', '+', 3, 'L', '-'),\n                (4, 'L', '-', 3, 'R', '+'),\n                (3, 'R', '+', 4, 'L', '-'),\n                (2, 'R', '+', 4, 'L', '-'),\n                (1, 'L', '+', 3, 'R', '-'),\n                (3, 'R', '+', 3, 'L', '-')\n            ]\n        },\n        {\n            \"C\": {1, 2, 3}, \"tau\": 3, \"P\": [\n                (1, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 1, 'R', '+'),\n                (1, 'R', '+', 2, 'L', '-'),\n                (1, 'L', '+', 2, 'R', '-'),\n                (3, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 3, 'R', '+')\n            ]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        tau = case[\"tau\"]\n        mappings = case[\"P\"]\n        weights = collections.defaultdict(int)\n\n        for mapping in mappings:\n            c1, e1, s1, c2, e2, s2 = mapping\n            \n            if c1 == c2:\n                continue\n\n            # A read pair supports a linkage if it follows the standard FR orientation model:\n            # one read on the Right(+) end of a contig, the other on the Left(-) end of another.\n            # The problem statement defines this with two symmetric cases for the tuple representation.\n            if (e1 == 'R' and s1 == '+' and e2 == 'L' and s2 == '-') or \\\n               (e1 == 'L' and s1 == '-' and e2 == 'R' and s2 == '+'):\n                u, v = min(c1, c2), max(c1, c2)\n                weights[(u, v)] += 1\n\n        # Filter edges by threshold and sort\n        edge_list = []\n        # Sort keys for lexicographical order\n        sorted_keys = sorted(weights.keys())\n        \n        for u, v in sorted_keys:\n            w = weights[(u, v)]\n            if w >= tau:\n                edge_list.append([u, v, w])\n        \n        all_results.append(edge_list)\n\n    # Format the final output string to be completely space-free within lists.\n    outer_parts = []\n    for case_result in all_results:\n        inner_parts = []\n        for triple in case_result:\n            inner_parts.append(f\"[{triple[0]},{triple[1]},{triple[2]}]\")\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_string = f\"[{','.join(outer_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2405168"}, {"introduction": "获得长序列的脚手架（scaffold）并不意味着组装工作的结束，保证其准确性同样重要。这个实践练习聚焦于一个常见且严重的组装错误——嵌合体（chimera）。你将开发一个定量指标，通过分析序列上 $k$-mer 组成和测序覆盖深度的局部一致性来识别潜在的嵌合序列，这能帮助你培养对组装结果的批判性思维，并掌握检测组装错误的关键技术 [@problem_id:2405143]。", "problem": "您的任务是定义并计算一个定量指标，通过联合评估连续组装序列 (contig) 的 $k$-mer 组成和其全长的测序覆盖度的一致性，来衡量该序列是否可能为嵌合体。将一个 contig 视作一个定义在脱氧核糖核酸 (DNA) 字母表 $\\{A,C,G,T\\}$ 上的字符串 $S$，其长度为 $L$，由位置 $1,2,\\dots,L$ 索引。还有一个非负的逐碱基覆盖度向量 $D \\in \\mathbb{R}_{\\ge 0}^L$，其分量 $D_j$ 表示位置 $j$ 的覆盖度。\n\n对于给定的正整数窗口长度 $W$ 和正整数 $k$-mer 长度 $k$（字母表大小 $|\\Sigma|=4$），定义如下：\n1. 将 contig 划分为 $M=\\left\\lfloor \\frac{L}{W} \\right\\rfloor$ 个长度相等且不重叠的窗口 $W$：窗口 $i$ 覆盖位置 $((i-1)W+1)$ 到 $(iW)$，其中 $i \\in \\{1,2,\\dots,M\\}$。如果 $M<2$，按照约定将最终得分定义为 $0$。\n2. 对于每个窗口 $i$，定义 $k$-mer 计数函数 $c_i: \\Sigma^k \\to \\mathbb{N}_0$ 为每个精确的 $k$-mer （步长为 $1$）完全包含在该窗口内的出现次数。设 $N_i=\\max\\{W-k+1,0\\}$ 为当 $W \\ge k$ 时每个窗口中 $k$-mer 的位置数（否则为 $0$）。通过 $p_i(w)=\\frac{c_i(w)}{\\max\\{N_i,1\\}}$（对于每个 $w \\in \\Sigma^k$）定义归一化 $k$-mer 频率向量 $p_i \\in \\mathbb{R}^{4^k}$。\n3. 定义相邻窗口 $i$ 和 $(i+1)$ 之间的组成不一致性为欧几里得距离\n$$\nd_i=\\left\\|p_i-p_{i+1}\\right\\|_2=\\sqrt{\\sum_{w \\in \\Sigma^k}\\left(p_i(w)-p_{i+1}(w)\\right)^2}.\n$$\n使用分布的界 $\\max d_i=\\sqrt{2}$ 对此进行归一化，并定义平均归一化组成不一致性\n$$\nI_{\\mathrm{comp}}=\\frac{1}{M-1}\\sum_{i=1}^{M-1}\\frac{d_i}{\\sqrt{2}}.\n$$\n4. 定义窗口 $i$ 内的平均覆盖度为\n$$\n\\bar{c}_i=\\frac{1}{W}\\sum_{j=(i-1)W+1}^{iW} D_j.\n$$\n定义相邻窗口 $i$ 和 $(i+1)$ 之间的相对覆盖度不一致性为\n$$\nr_i=\n\\begin{cases}\n0, & \\text{if }\\bar{c}_i+\\bar{c}_{i+1}=0,\\\\[4pt]\n\\frac{\\left|\\bar{c}_{i+1}-\\bar{c}_i\\right|}{\\bar{c}_{i+1}+\\bar{c}_i}, & \\text{otherwise.}\n\\end{cases}\n$$\n定义平均覆盖度不一致性\n$$\nI_{\\mathrm{cov}}=\\frac{1}{M-1}\\sum_{i=1}^{M-1} r_i.\n$$\n5. 定义嵌合度得分为凸组合\n$$\n\\mathrm{Score}=\\alpha I_{\\mathrm{comp}}+(1-\\alpha)I_{\\mathrm{cov}},\n$$\n其中 $\\alpha=\\frac{1}{2}$。\n\n为以下每个测试用例计算嵌合度得分。对于每个用例，除非另有说明，使用 $k=3$，窗口长度 $W=30$，如上所述的非重叠窗口，以及 $\\alpha=\\frac{1}{2}$。所有序列都基于字母表 $\\{A,C,G,T\\}$，所有覆盖度都是非负实数值。请完全按照规定构造序列和覆盖度向量：\n\n- 测试用例1（平衡的组成和均匀的覆盖度）：\n  - 长度 $L_1=120$。\n  - 序列 $S_1$：无限周期字符串 $\\text{\"ACGTACGT}\\dots\\text{\"}$ 的前 $L_1$ 个符号。\n  - 覆盖度 $D^{(1)}$：对于所有 $j \\in \\{1,\\dots,L_1\\}$，$D^{(1)}_j=30$。\n\n- 测试用例2（在中点处有组成和覆盖度的变化）：\n  - 长度 $L_2=120$。\n  - 序列 $S_2$：位置 $1$ 到 $60$ 是无限周期字符串 $\\text{\"GCGCGC}\\dots\\text{\"}$ 的前 $60$ 个符号；位置 $61$ 到 $120$ 是无限周期字符串 $\\text{\"ATATAT}\\dots\\text{\"}$ 的前 $60$ 个符号。\n  - 覆盖度 $D^{(2)}$：对于 $j \\in \\{1,\\dots,60\\}$，$D^{(2)}_j=40$；对于 $j \\in \\{61,\\dots,120\\}$，$D^{(2)}_j=10$。\n\n- 测试用例3（短 contig，少于两个窗口）：\n  - 长度 $L_3=20$。\n  - 序列 $S_3$：无限周期字符串 $\\text{\"ACGTACGT}\\dots\\text{\"}$ 的前 $L_3$ 个符号。\n  - 覆盖度 $D^{(3)}$：对于所有 $j \\in \\{1,\\dots,L_3\\}$，$D^{(3)}_j=20$。\n\n- 测试用例4（两个窗口的组成相同，覆盖度略有不同）：\n  - 长度 $L_4=60$。\n  - 序列 $S_4$：位置 $1$ 到 $30$ 是无限周期字符串 $\\text{\"ACGTACGT}\\dots\\text{\"}$ 的前 $30$ 个符号；位置 $31$ 到 $60$ 是同一个无限周期字符串的前 $30$ 个符号。\n  - 覆盖度 $D^{(4)}$：对于 $j \\in \\{1,\\dots,30\\}$，$D^{(4)}_j=20$；对于 $j \\in \\{31,\\dots,60\\}$，$D^{(4)}_j=22$。\n\n- 测试用例5（三个窗口，中间窗口的组成发生变化，覆盖度均匀）：\n  - 长度 $L_5=90$。\n  - 序列 $S_5$：位置 $1$ 到 $30$ 是无限周期字符串 $\\text{\"ATATAT}\\dots\\text{\"}$ 的前 $30$ 个符号；位置 $31$ 到 $60$ 是无限周期字符串 $\\text{\"GCGCGC}\\dots\\text{\"}$ 的前 $30$ 个符号；位置 $61$ 到 $90$ 是无限周期字符串 $\\text{\"ATATAT}\\dots\\text{\"}$ 的前 $30$ 个符号。\n  - 覆盖度 $D^{(5)}$：对于所有 $j \\in \\{1,\\dots,90\\}$，$D^{(5)}_j=30$。\n\n您的程序必须为每个测试用例计算嵌合度得分，并生成单行输出，其中包含一个用方括号括起来的、按测试用例精确顺序排列的逗号分隔实数列表。每个实数必须使用标准四舍五入到 $6$ 位小数。因此，最终输出必须是以下形式\n$[\\text{score}_1,\\text{score}_2,\\text{score}_3,\\text{score}_4,\\text{score}_5]$，\n其中每个 $\\text{score}_i$ 都四舍五入到 $6$ 位小数。", "solution": "该问题陈述具有科学依据，在数学上是适定的，并且内部一致。它提供了一套完整的定义、参数和测试用例，用于计算 DNA contig 的确定性嵌合度得分。所定义的指标通过量化序列组成和测序覆盖度的不连续性，为在宏基因组组装中识别嵌合序列提供了一种合理的方法。因此，该问题被认为是有效的。\n\n解决方案涉及对所提供公式的直接实现。对于每个测试用例，我们使用指定的参数计算嵌合度得分：$k$-mer 长度 $k=3$，窗口大小 $W=30$，以及凸组合权重 $\\alpha=\\frac{1}{2}$。\n\n算法的核心如下：\n$1$. 长度为 $L$ 的 contig 被划分为 $M=\\lfloor L/W \\rfloor$ 个非重叠窗口。根据定义，如果 $M < 2$，则得分为 $0$。\n$2$. 对于每个窗口 $i \\in \\{1, \\dots, M\\}$，我们计算一个归一化的 $k$-mer 频率向量 $p_i$ 和平均覆盖度 $\\bar{c}_i$。向量 $p_i$ 有 $4^k = 4^3 = 64$ 个分量。一个窗口中的 $k$-mer 数量是 $N_i = W-k+1 = 30-3+1 = 28$。\n$3$. 然后我们计算相邻窗口 $i$ 和 $i+1$ 之间的两种不一致性，其中 $i \\in \\{1, \\dots, M-1\\}$：\n    a. 组成不一致性：$d_i = \\|p_i - p_{i+1}\\|_2$。\n    b. 相对覆盖度不一致性：$r_i = \\frac{|\\bar{c}_{i+1}-\\bar{c}_i|}{\\bar{c}_{i+1}+\\bar{c}_i}$，如果 $\\bar{c}_i+\\bar{c}_{i+1}=0$ 则 $r_i=0$。\n$4$. 对所有 $M-1$ 个窗口转换进行平均，得到 $I_{\\mathrm{comp}} = \\frac{1}{M-1}\\sum_{i=1}^{M-1}\\frac{d_i}{\\sqrt{2}}$ 和 $I_{\\mathrm{cov}} = \\frac{1}{M-1}\\sum_{i=1}^{M-1}r_i$。\n$5$. 最终得分是一个加权和：$\\mathrm{Score} = \\alpha I_{\\mathrm{comp}} + (1-\\alpha)I_{\\mathrm{cov}}$。\n\n我们现在将此过程应用于每个测试用例。\n\n**测试用例 1:**\n- Contig 长度 $L_1=120$，窗口大小 $W=30$，因此我们有 $M = \\lfloor 120/30 \\rfloor = 4$ 个窗口。\n- 序列 $S_1$ 是 \"ACGT\" 的重复。每个窗口是其他窗口的循环移位。对于 $k$-mer \"ACG\"、\"CGT\"、\"GTA\" 和 \"TAC\"，在每个包含 28 个总 $k$-mer 的窗口中，它们的出现次数均为 7。所有其他 $k$-mer 的计数为 0。\n- 因此，所有窗口的归一化 $k$-mer 频率向量都相同：$p_1 = p_2 = p_3 = p_4$。这些向量中的每一个都有 4 个非零分量，每个分量的值为 $7/28 = 1/4$。\n- 组成不一致性为 $d_i = \\|p_i - p_{i+1}\\|_2 = 0$，其中 $i=1, 2, 3$。这得到 $I_{\\mathrm{comp}} = 0$。\n- 覆盖度 $D^{(1)}_j = 30$ 是均匀的。每个窗口的平均覆盖度为 $\\bar{c}_i = 30$。\n- 相对覆盖度不一致性对所有 $i$ 均为 $r_i = 0$。这得到 $I_{\\mathrm{cov}} = 0$。\n- 最终得分为 $\\mathrm{Score}_1 = \\frac{1}{2}(0) + \\frac{1}{2}(0) = 0$。\n\n**测试用例 2:**\n- Contig 长度 $L_2=120$，$W=30$，得到 $M=4$ 个窗口。\n- 窗口 1 和 2 由序列 \"GCGCGC...\" 组成，而窗口 3 和 4 由 \"ATATAT...\" 组成。\n- 对于窗口 1 和 2，唯一非零的 $k$-mer 频率是 \"GCG\" 和 \"CGC\"，每个频率为 $14/28 = 1/2$。因此 $p_1=p_2$。\n- 对于窗口 3 和 4，唯一非零的频率是 \"ATA\" 和 \"TAT\"，每个频率为 $14/28 = 1/2$。因此 $p_3=p_4$。\n- 组成不一致性为：\n    - $d_1 = \\|p_1-p_2\\|_2 = 0$。\n    - $d_2 = \\|p_2-p_3\\|_2 = \\sqrt{(1/2)^2 + (1/2)^2 + (-1/2)^2 + (-1/2)^2} = \\sqrt{4 \\cdot (1/4)} = 1$。$k$-mer 集合是不相交的。\n    - $d_3 = \\|p_3-p_4\\|_2 = 0$。\n- $I_{\\mathrm{comp}} = \\frac{1}{4-1} (\\frac{d_1}{\\sqrt{2}} + \\frac{d_2}{\\sqrt{2}} + \\frac{d_3}{\\sqrt{2}}) = \\frac{1}{3} (0 + \\frac{1}{\\sqrt{2}} + 0) = \\frac{1}{3\\sqrt{2}}$。\n- 覆盖度：$\\bar{c}_1 = \\bar{c}_2 = 40$ 且 $\\bar{c}_3 = \\bar{c}_4 = 10$。\n- 相对覆盖度不一致性为：\n    - $r_1 = \\frac{|40-40|}{40+40} = 0$。\n    - $r_2 = \\frac{|10-40|}{10+40} = \\frac{30}{50} = \\frac{3}{5}$。\n    - $r_3 = \\frac{|10-10|}{10+10} = 0$。\n- $I_{\\mathrm{cov}} = \\frac{1}{3} (0 + \\frac{3}{5} + 0) = \\frac{1}{5}$。\n- 最终得分为 $\\mathrm{Score}_2 = \\frac{1}{2} I_{\\mathrm{comp}} + \\frac{1}{2} I_{\\mathrm{cov}} = \\frac{1}{2}(\\frac{1}{3\\sqrt{2}}) + \\frac{1}{2}(\\frac{1}{5}) = \\frac{1}{6\\sqrt{2}} + \\frac{1}{10} \\approx 0.217851$。\n\n**测试用例 3:**\n- Contig 长度 $L_3=20$，$W=30$。窗口数量为 $M = \\lfloor 20/30 \\rfloor = 0$。\n- 根据问题定义，如果 $M < 2$，则得分为 $0$。\n- 因此，$\\mathrm{Score}_3 = 0$。\n\n**测试用例 4:**\n- Contig 长度 $L_4=60$，$W=30$，得到 $M = \\lfloor 60/30 \\rfloor = 2$ 个窗口。\n- 两个窗口中的序列完全相同（30个字符的 \"ACGT...\"）。这与测试用例 1 中的窗口相同。因此，$p_1 = p_2$。\n- 组成不一致性为 $d_1 = \\|p_1-p_2\\|_2 = 0$，得到 $I_{\\mathrm{comp}} = \\frac{1}{2-1}\\frac{0}{\\sqrt{2}}=0$。\n- 平均覆盖度为 $\\bar{c}_1=20$ 和 $\\bar{c}_2=22$。\n- 相对覆盖度不一致性为 $r_1 = \\frac{|22-20|}{22+20} = \\frac{2}{42} = \\frac{1}{21}$。\n- $I_{\\mathrm{cov}} = \\frac{1}{2-1} r_1 = \\frac{1}{21}$。\n- 最终得分为 $\\mathrm{Score}_4 = \\frac{1}{2}(0) + \\frac{1}{2}(\\frac{1}{21}) = \\frac{1}{42} \\approx 0.023810$。\n\n**测试用例 5:**\n- Contig 长度 $L_5=90$，$W=30$，得到 $M = 3$ 个窗口。\n- 窗口 1: \"ATATAT...\"，窗口 2: \"GCGCGC...\"，窗口 3: \"ATATAT...\"。\n- 从测试用例 2 中我们知道 \"ATATAT...\" ($p_1, p_3$) 的 $k$-mer 谱与 \"GCGCGC...\" ($p_2$) 的不相交。\n- 因此，$p_1=p_3$。\n- 组成不一致性为：\n    - $d_1 = \\|p_1-p_2\\|_2 = 1$。\n    - $d_2 = \\|p_2-p_3\\|_2 = \\|p_2-p_1\\|_2 = 1$。\n- $I_{\\mathrm{comp}} = \\frac{1}{3-1} (\\frac{d_1}{\\sqrt{2}} + \\frac{d_2}{\\sqrt{2}}) = \\frac{1}{2} (\\frac{1}{\\sqrt{2}} + \\frac{1}{\\sqrt{2}}) = \\frac{1}{\\sqrt{2}}$。\n- 覆盖度是均匀的，$\\bar{c}_1 = \\bar{c}_2 = \\bar{c}_3 = 30$。\n- 所有相对覆盖度不一致性均为 $r_i=0$，所以 $I_{\\mathrm{cov}} = 0$。\n- 最终得分为 $\\mathrm{Score}_5 = \\frac{1}{2}(\\frac{1}{\\sqrt{2}}) + \\frac{1}{2}(0) = \\frac{1}{2\\sqrt{2}} \\approx 0.353553$。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef compute_chimericity_score(S, D, L, k, W, alpha):\n    \"\"\"\n    Computes the chimericity score for a contig based on k-mer composition and coverage.\n    \"\"\"\n    M = L // W\n    if M < 2:\n        return 0.0\n\n    kmer_positions = max(W - k + 1, 0)\n    # The denominator for k-mer frequencies, as per the problem statement\n    # p_i(w) = c_i(w) / max(N_i, 1) where N_i = W-k+1\n    kmer_freq_denominator = float(max(kmer_positions, 1))\n\n    alphabet = 'ACGT'\n    all_kmers = sorted([''.join(p) for p in itertools.product(alphabet, repeat=k)])\n    kmer_to_idx = {kmer: i for i, kmer in enumerate(all_kmers)}\n    num_total_kmers = len(all_kmers)\n\n    window_p_vectors = []\n    window_mean_coverages = []\n\n    for i in range(M):\n        start_idx = i * W\n        end_idx = start_idx + W\n        \n        window_seq = S[start_idx:end_idx]\n        \n        # Calculate k-mer frequency vector p_i\n        counts = np.zeros(num_total_kmers, dtype=float)\n        if kmer_positions > 0:\n            for j in range(kmer_positions):\n                kmer = window_seq[j:j+k]\n                # In case of non-standard characters, though the problem restricts to ACGT\n                if kmer in kmer_to_idx:\n                    counts[kmer_to_idx[kmer]] += 1\n        \n        p_vector = counts / kmer_freq_denominator\n        window_p_vectors.append(p_vector)\n        \n        # Calculate mean coverage c_i\n        window_cov_data = D[start_idx:end_idx]\n        mean_cov = np.mean(window_cov_data)\n        window_mean_coverages.append(mean_cov)\n        \n    total_comp_inconsistency = 0.0\n    total_cov_inconsistency = 0.0\n    \n    for i in range(M - 1):\n        # Composition inconsistency\n        p_i = window_p_vectors[i]\n        p_i_plus_1 = window_p_vectors[i+1]\n        d_i = np.linalg.norm(p_i - p_i_plus_1)\n        total_comp_inconsistency += d_i / np.sqrt(2.0)\n        \n        # Coverage inconsistency\n        c_i = window_mean_coverages[i]\n        c_i_plus_1 = window_mean_coverages[i+1]\n        c_sum = c_i + c_i_plus_1\n        if c_sum == 0.0:\n            r_i = 0.0\n        else:\n            r_i = np.abs(c_i_plus_1 - c_i) / c_sum\n        total_cov_inconsistency += r_i\n    \n    I_comp = total_comp_inconsistency / (M - 1)\n    I_cov = total_cov_inconsistency / (M - 1)\n    \n    score = alpha * I_comp + (1 - alpha) * I_cov\n    return score\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute scores.\n    \"\"\"\n    k = 3\n    W = 30\n    alpha = 0.5\n\n    # Test case 1\n    L1 = 120\n    S1 = ('ACGT' * (L1 // 4 + 1))[:L1]\n    D1 = np.full(L1, 30.0)\n    \n    # Test case 2\n    L2 = 120\n    S2_part1 = ('GC' * (60 // 2 + 1))[:60]\n    S2_part2 = ('AT' * (60 // 2 + 1))[:60]\n    S2 = S2_part1 + S2_part2\n    D2 = np.concatenate([np.full(60, 40.0), np.full(60, 10.0)])\n    \n    # Test case 3\n    L3 = 20\n    S3 = ('ACGT' * (L3 // 4 + 1))[:L3]\n    D3 = np.full(L3, 20.0)\n    \n    # Test case 4\n    L4 = 60\n    S4_part = ('ACGT' * (30 // 4 + 2))[:30] # +2 ensures enough length\n    S4 = S4_part + S4_part\n    D4 = np.concatenate([np.full(30, 20.0), np.full(30, 22.0)])\n    \n    # Test case 5\n    L5 = 90\n    S5_part_AT = ('AT' * (30 // 2 + 1))[:30]\n    S5_part_GC = ('GC' * (30 // 2 + 1))[:30]\n    S5 = S5_part_AT + S5_part_GC + S5_part_AT\n    D5 = np.full(L5, 30.0)\n    \n    test_cases = [\n        (S1, D1, L1, k, W, alpha),\n        (S2, D2, L2, k, W, alpha),\n        (S3, D3, L3, k, W, alpha),\n        (S4, D4, L4, k, W, alpha),\n        (S5, D5, L5, k, W, alpha),\n    ]\n\n    results = []\n    for params in test_cases:\n        score = compute_chimericity_score(*params)\n        results.append(score)\n    \n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2405143"}]}