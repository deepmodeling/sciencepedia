{"hands_on_practices": [{"introduction": "连锁不平衡的一个关键结果是，在群体中观察到的单倍型数量远少于理论上可能的数量。这个练习将通过一个直接的计算来量化这种差异，帮助您理解为何单倍型块这一概念如此重要。通过比较理论最大值和实际观测值，您将直观地感受到连锁不平衡如何塑造基因组的结构。[@problem_id:2401363]", "problem": "一个单倍型区块（haplotype block）被定义为一个基因组片段，在该片段内重组率足够低，以至于通常只观察到有限数量的单倍型构型。考虑一个包含 $k$ 个双等位基因单核苷酸多态性（SNP）的单倍型区块。一个单倍型是在单个染色体上，跨越这 $k$ 个位点观察到的等位基因的有序序列。在一个由 $N=500$ 个无亲缘关系的二倍体个体（因此有 $2N=1000$ 个单倍型）组成的定相样本中，您观察到 $H_{\\text{obs}}=14$ 个不同的单倍型，这些单倍型跨越一个包含 $k=8$ 个双等位基因SNP的区块。\n\n仅使用关于计算二元字母表上不同序列的第一性原理，确定在一个包含 $k$ 个双等位基因SNP的区块中，理论上可能的不同单倍型的最大数量 $H_{\\max}$，并针对给定的 $k=8$ 的区块，计算实现比例 $f = H_{\\text{obs}} / H_{\\max}$。请将 $f$ 表示为小数（而非百分比），并将您的最终答案四舍五入到 $4$ 位有效数字。", "solution": "首先将验证问题陈述的科学合理性、自洽性和清晰度。\n\n第一步：提取已知条件。\n- 一个单倍型区块包含 $k$ 个双等位基因单核苷酸多态性（SNP）。\n- 一个单倍型是跨越这 $k$ 个位点的等位基因的有序序列。\n- 二倍体个体样本量：$N=500$。\n- 样本中的单倍型总数：$2N=1000$。\n- 观察到的不同单倍型的数量：$H_{\\text{obs}}=14$。\n- 所考虑的特定区块中的SNP数量：$k=8$。\n- 理论上可能的不同单倍型的最大数量的定义：$H_{\\max}$。\n- 实现比例的定义：$f = H_{\\text{obs}} / H_{\\max}$。\n- $f$ 的最终答案必须是四舍五入到 $4$ 位有效数字的小数。\n\n第二步：使用提取的已知条件进行验证。\n该问题在科学上基于群体遗传学和生物信息学的原理。单倍型区块、SNP和连锁不平衡等概念是这些领域的基础。该问题是适定的，提供了计算所需量所需的所有必要信息。术语“双等位基因”有精确的含义：每个SNP位点可以呈现两种可能的等位基因之一。问题是客观的，没有歧义。关于样本量 $N=500$ 的数据是关于从中获得观察数据 $H_{\\text{obs}}$ 的研究的背景信息；计算单倍型的*理论最大*数量 $H_{\\max}$ 并不需要它，因为 $H_{\\max}$ 仅取决于多态性位点的数量 $k$。该问题是有效的。\n\n第三步：判断与行动。\n该问题是有效的。将提供解答。\n\n问题要求计算包含 $k$ 个双等位基因SNP的区块的理论最大不同单倍型数量 $H_{\\max}$，然后计算一个特定情况下的实现比例 $f$。推导必须从组合数学的第一性原理出发。\n\n在此背景下，一个单倍型是一个长度为 $k$ 的有序序列。序列中的每个位置代表一个双等位基因SNP。“双等位基因”这个术语意味着在 $k$ 个位置中的每一个位置，都恰好有两种可能的状态（等位基因）。我们可以抽象地将这两种状态表示为例如 $0$ 和 $1$。\n\n因此，确定最大不同单倍型数量的问题，在数学上等同于确定长度为 $k$ 的唯一二进制字符串的数量。\n\n对于第一个SNP位点，有 $2$ 种可能的等位基因。\n对于第二个SNP位点，也有 $2$ 种可能的等位基因，与第一个位点的选择无关。\n这种模式对所有 $k$ 个位点都成立。\n\n根据基本计数原理（乘法法则），不同序列的总数是每个位置上选择数的乘积。\n$$ H_{\\max} = \\underbrace{2 \\times 2 \\times \\cdots \\times 2}_{k \\text{ 次}} $$\n这表示为：\n$$ H_{\\max} = 2^k $$\n\n问题给出了SNP数量的具体值，$k=8$。我们将此值代入推导出的 $H_{\\max}$ 公式中：\n$$ H_{\\max} = 2^8 $$\n计算很简单：\n$$ 2^8 = 256 $$\n因此，在一个包含 $8$ 个双等位基因SNP的区块中，理论上存在 $256$ 种可能的不同单倍型。\n\n接下来，我们被要求计算实现比例 $f$，定义为观察到的不同单倍型数量 $H_{\\text{obs}}$ 与理论最大值 $H_{\\max}$ 的比率。\n$$ f = \\frac{H_{\\text{obs}}}{H_{\\max}} $$\n问题陈述中提到，在样本中观察到 $H_{\\text{obs}} = 14$ 个不同的单倍型。将 $H_{\\text{obs}}$ 的已知值和计算出的 $H_{\\max}$ 值代入：\n$$ f = \\frac{14}{256} $$\n为了得到最终的小数值，我们进行除法运算：\n$$ f = 0.0546875 $$\n问题要求将此结果四舍五入到 $4$ 位有效数字。第一个有效数字是第一个非零数字，即 $5$。其后的三个有效数字是 $4$、$6$和$8$。第五个有效数字是 $7$。由于 $7 \\ge 5$，我们必须将第四个有效数字（即 $8$）向上取整。因此，$8$ 变为 $9$。\n\n最终四舍五入的值是 $0.05469$。这个值代表了在群体样本中实际观察到的单倍型组合占所有可能组合的比例，这是衡量单倍型区块内连锁不平衡强度的常用指标。一个小的 $f$ 值表明重组受到了抑制，导致只有一小部分可能的单倍型在群体中持续存在。", "answer": "$$\n\\boxed{0.05469}\n$$", "id": "2401363"}, {"introduction": "理解了单倍型块的存在意义后，下一步自然是学习如何从基因数据中识别它们。本练习将介绍经典的“四配子法则”（Four-Gamete Rule），这是一种基于重组历史来定义单倍型块边界的有效方法。通过从零开始实现这个算法，您将把一个理论规则转变为一个实用的生物信息学工具，用于划分基因组区域。[@problem_id:2401326]", "problem": "实现一个程序，该程序给定一组连续基因座的已定相双等位基因单倍型数据，使用四配子规则将这些基因座划分为候选单倍型块。该程序必须从基本原理开始编写，不得依赖于预先构建的群体遗传学库。算法基础应从单倍型、重组以及无限位点模型下的四配子规则的核心定义出发，不使用任何快捷公式。数据以一个整数矩阵表示，其中行是单倍型，列是基因座。每个条目都在集合 $\\{0,1\\}$ 中，用于表示观测到的等位基因，并可选地使用 $-1$ 表示缺失值。一个块被定义为一个最大的连续基因座集合，满足该块内的任何一对基因座，在所有观测到的单倍型中（忽略在任一基因座上存在缺失数据的行）都不会展现出全部四种双等位基因组合。任务是实现一个贪心的从左到右算法，以产生对这些块的最粗粒度划分。\n\n定义和约束：\n- 一个单倍型矩阵 $H$ 的形状为 $n \\times m$，其中有 $n \\ge 1$ 个单倍型（行）和 $m \\ge 1$ 个基因座（列）。矩阵元素属于 $\\{0,1\\}$ 或缺失符号 $-1$。\n- 对于两个基因座 $i$ 和 $j$，遍历所有行 $r \\in \\{0,\\dots,n-1\\}$ 来枚举观测到的等位基因对 $(H_{r,i}, H_{r,j})$，忽略任何一个值为 $-1$ 的行。如果观测到的配对集合等于 $\\{(0,0),(0,1),(1,0),(1,1)\\}$，则称基因座 $i$ 和 $j$ 表现出四种配子（在无限位点模型下，这是历史重组或复发突变的证据）。\n- 一个有效块是一个最大的连续索引范围 $[s,e]$，满足 $0 \\le s \\le e \\le m-1$，并且对于任意满足 $s \\le i  j \\le e$ 的配对 $(i,j)$，其观测到的配对不包含全部四种配子。\n- 贪心划分算法必须从左到右扫描基因座，通过尝试添加下一个基因座来扩展当前块。如果添加基因座 $j$ 会与块中已有的某个基因座 $i$ 形成具有四种配子的配对 $(i,j)$，则当前块在 $j-1$ 处结束，并从 $j$ 开始一个新块。持续此过程，直到所有基因座都被分配到块中。结果必须是表示为索引区间 $[s,e]$ 的块列表，使用基于0的闭区间索引。\n\n输入将作为测试套件嵌入到程序中：\n- 缺失数据符号 $-1$ 必须严格按照规定使用。\n- 所有索引都是基于0的，并且是闭区间。\n- 测试矩阵按行列出；每个内部列表代表一行（一个单倍型）。\n\n测试套件（五个案例）：\n1. 案例 T$1$（无四配子证据，单个块）：\n   - $H_1$ 是 $4 \\times 4$ 矩阵：\n     - 第 $0$ 行：$[0,0,0,0]$\n     - 第 $1$ 行：$[1,1,1,1]$\n     - 第 $2$ 行：$[0,0,0,0]$\n     - 第 $3$ 行：$[1,1,1,1]$\n   - 预计产生一个跨越索引 $[0,3]$ 的单个块。\n\n2. 案例 T$2$（扩展时因出现四配子而产生一个内边界）：\n   - $H_2$ 是 $6 \\times 5$ 矩阵：\n     - 第 $0$ 行：$[0,0,0,0,0]$\n     - 第 $1$ 行：$[0,0,0,1,1]$\n     - 第 $2$ 行：$[1,1,1,0,0]$\n     - 第 $3$ 行：$[1,1,1,1,1]$\n     - 第 $4$ 行：$[0,0,0,0,0]$\n     - 第 $5$ 行：$[1,1,1,1,1]$\n   - 添加索引为 $3$ 的基因座会与之前的基因座产生全部四种配子，从而在索引 $2$ 和 $3$ 之间创建一个边界。第二个块跨越索引 $[3,4]$。\n\n3. 案例 T$3$（缺失数据阻止了四配子检测，形成更大的块）：\n   - $H_3$ 是 $6 \\times 4$ 矩阵：\n     - 第 $0$ 行：$[0,0,0,0]$\n     - 第 $1$ 行：$[0,0,0,1]$\n     - 第 $2$ 行：$[1,1,1,0]$\n     - 第 $3$ 行：$[1,1,1,-1]$\n     - 第 $4$ 行：$[0,0,0,0]$\n     - 第 $5$ 行：$[1,1,1,-1]$\n   - 由于最后一列存在缺失值 $-1$，任何配对都未观测到全部四种配子，因此得到单个块 $[0,3]$。\n\n4. 案例 T$4$（每次尝试扩展都触发边界，形成单基因座块）：\n   - $H_4$ 是 $4 \\times 5$ 矩阵：\n     - 第 $0$ 行：$[0,0,0,0,0]$\n     - 第 $1$ 行：$[0,1,0,1,0]$\n     - 第 $2$ 行：$[1,0,1,0,1]$\n     - 第 $3$ 行：$[1,1,1,1,1]$\n   - 交替的模式确保在尝试扩展时，相邻基因座之间会出现四种配子，从而产生多个块 $[0,0]$, $[1,1]$, $[2,2]$, $[3,3]$, $[4,4]$。\n\n5. 案例 T$5$（块内的单态基因座）：\n   - $H_5$ 是 $6 \\times 5$ 矩阵：\n     - 第 $0$ 行：$[0,0,0,0,0]$\n     - 第 $1$ 行：$[0,0,0,0,0]$\n     - 第 $2$ 行：$[1,1,1,0,1]$\n     - 第 $3$ 行：$[1,1,1,0,1]$\n     - 第 $4$ 行：$[0,0,0,0,0]$\n     - 第 $5$ 行：$[1,1,1,0,1]$\n   - 第四列是等位基因为 $0$ 的单态基因座，所有其他列都完全一致，因此形成单个块 $[0,4]$。\n\n最终输出格式：\n- 对于每个测试案例，将块区间列表输出为一个由包含两个整数的列表 $[s,e]$ 组成的列表。\n- 将五个案例的结果按 T$1$, T$2$, T$3$, T$4$, T$5$ 的顺序汇总到一个顶层列表中。\n- 您的程序应生成单行输出，其中包含此汇总结果，格式为方括号内由逗号分隔的列表，且不含空格，例如：$[[[0,3]],[[0,2],[3,4]],\\dots]$。\n- 每个 $s$ 和 $e$ 都必须是基于0的闭区间索引。\n\n程序必须使用指定的算法计算这些划分，并精确打印一行符合上述格式的输出。不涉及物理单位或角度单位。如果需要（此处不需要），请将任何分数或比例表示为小数。", "solution": "该问题陈述已经过严格验证，并被认定为有效。它具有科学依据，提法明确，客观且内部一致。它基于群体遗传学和生物信息学的既定原则，提出了一个清晰的计算任务。因此，我们可以着手解决。\n\n该问题要求实现一个贪心算法，将一组遗传基因座划分为单倍型块。划分的标准是四配子规则，这是一个源自突变的无限位点模型的基本概念。\n\n首先，我们必须将基础科学原理形式化。无限位点模型假定，每一次新突变都发生在染色体上的一个独特位点，该位点在抽样群体的历史上从未经历过突变。考虑两个双等位基因座，位于位置 $i$ 和 $j$，其等位基因为 $\\{0,1\\}$。如果在观测到的单倍型的进化历史中，这两个基因座之间没有发生过重组，那么四种可能的双基因座配子——$(0,0)$, $(0,1)$, $(1,0)$, 和 $(1,1)$——中最多只能存在三种。第四种配子的出现只能通过基因座之间的重组事件或其中一个位点的复发突变来解释，而后者是无限位点模型所不允许的。因此，所有四种配子的存在，被称为“四配子对”，是基因座之间至少发生过一次历史性重组事件的强有力证据。\n\n算法的核心是检测此条件的函数。设输入的单倍型数据由一个大小为 $n \\times m$ 的矩阵 $H$ 表示，其中 $n$ 是单倍型数量， $m$ 是基因座数量。一个条目 $H_{r,k}$ 表示单倍型 $r$ 在基因座 $k$ 上的等位基因，其中 $k \\in \\{0, \\dots, m-1\\}$ 且 $r \\in \\{0, \\dots, n-1\\}$。等位基因属于 $\\{0,1\\}$，-1 表示缺失数据。\n\n为确定两个基因座 $i$ 和 $j$ 是否构成一个四配子对，我们执行以下检查：\n1. 初始化一个空集合 $S_{i,j}$，用于存储唯一的、有效的等位基因对。\n2. 遍历从 $0$ 到 $n-1$ 的每个单倍型 $r$。\n3. 对于每个单倍型 $r$，考虑其等位基因对 $(H_{r,i}, H_{r,j})$。\n4. 如果 $H_{r,i} = -1$ 或 $H_{r,j} = -1$，则该配对包含缺失数据，必须被忽略。\n5. 如果配对有效，则将其添加到集合 $S_{i,j}$ 中。\n6. 在遍历完所有 $n$ 个单倍型后，当且仅当集合 $S_{i,j}$ 等于 $\\{(0,0), (0,1), (1,0), (1,1)\\}$ 时，四配子对的测试为阳性。对于双等位基因数据，这等同于检查集合的基数 $|S_{i,j}|$ 是否等于 $4$。\n\n建立了这个测试之后，我们就可以按照规定构建贪心块划分算法。该算法从左到右遍历基因座，尽可能地扩展一个块。\n\n设 $m$ 是基因座总数，索引从 $0$ 到 $m-1$。\n1. 初始化一个空列表 $\\mathcal{B}$，用于存储结果块划分。\n2. 初始化当前块的起始索引 $s$ 为 $0$。\n3. 使用一个预期的基因座索引 $j$ 从 $1$ 遍历到 $m-1$。对于每个 $j$，我们测试基因座 $j$ 是否可以被包含在从索引 $s$ 开始的当前块中。\n4. 为执行此测试，我们必须检查基因座 $j$ 与已在当前块中的每个基因座 $i$ 之间是否存在四配子违规，其中 $i$ 的范围从 $s$ 到 $j-1$。\n5. 如果在此范围内的任何一对基因座 $(i,j)$ 的四配子测试为阳性，则发生违规。\n6. 如果对于某个基因座 $i \\in [s, j-1]$ 发现了违规：\n   a. 当前块被最终确定。其区间为 $[s, j-1]$。此区间被添加到列表 $\\mathcal{B}$ 中。\n   b. 必须从当前基因座 $j$ 开始一个新块。起始索引 $s$ 更新为 $j$。\n   c. 对其他基因座 $i$ 的内部检查被终止，算法继续处理下一个预期的基因座 $j+1$。\n7. 如果遍历所有 $i \\in [s, j-1]$ 的内部循环完成而没有发现任何四配子违规，则基因座 $j$ 成功添加到当前块。然后算法继续评估下一个基因座 $j+1$，而不改变块的起始点 $s$。\n8. 当关于 $j$ 的主循环完成后，必须将从当前 $s$ 值开始并延伸到最后一个基因座 $m-1$ 的最终块最终确定并添加到 $\\mathcal{B}$ 中。其区间为 $[s, m-1]$。\n\n这个确定性的贪心过程为任何给定的单倍型矩阵 $H$ 产生一个唯一的、将基因座划分为连续块的划分。每个块在某种意义上是最大的，即它不能在不违反四配子规则的情况下向右进一步扩展。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the block partitioning algorithm.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case T1\n        [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]],\n        # Case T2\n        [[0, 0, 0, 0, 0], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]],\n        # Case T3\n        [[0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0], [1, 1, 1, -1], [0, 0, 0, 0], [1, 1, 1, -1]],\n        # Case T4\n        [[0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]],\n        # Case T5\n        [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1]],\n    ]\n\n    def check_four_gametes(locus1_col, locus2_col):\n        \"\"\"\n        Checks if two loci exhibit all four gametic types.\n        Missing data (-1) are ignored.\n        \n        Args:\n            locus1_col (np.ndarray): A 1D array representing allele data for the first locus.\n            locus2_col (np.ndarray): A 1D array representing allele data for the second locus.\n        \n        Returns:\n            bool: True if four gametes are observed, False otherwise.\n        \"\"\"\n        observed_pairs = set()\n        for i in range(len(locus1_col)):\n            allele1 = locus1_col[i]\n            allele2 = locus2_col[i]\n            \n            # Ignore haplotypes with missing data at either locus\n            if allele1 != -1 and allele2 != -1:\n                observed_pairs.add((allele1, allele2))\n        \n        # The condition is met if the number of unique pairs is exactly 4\n        return len(observed_pairs) == 4\n\n    def find_blocks(haplotype_matrix):\n        \"\"\"\n        Partitions loci into blocks using the greedy Four-Gamete Rule algorithm.\n        \n        Args:\n            haplotype_matrix (list of lists): The input matrix of haplotypes.\n            \n        Returns:\n            list of lists: A list of [start, end] intervals for each block.\n        \"\"\"\n        H = np.array(haplotype_matrix, dtype=np.int8)\n        _n_haplotypes, n_loci = H.shape\n\n        if n_loci == 0:\n            return []\n        if n_loci == 1:\n            return [[0, 0]]\n\n        blocks = []\n        block_start = 0\n\n        # Iterate through loci to decide where blocks end\n        for j in range(1, n_loci):\n            violation_found = False\n            # Check current locus j against all previous loci in the current block\n            for i in range(block_start, j):\n                if check_four_gametes(H[:, i], H[:, j]):\n                    # Violation found, end the current block here\n                    blocks.append([block_start, j - 1])\n                    # Start a new block at the current locus\n                    block_start = j\n                    violation_found = True\n                    break\n            if violation_found:\n                continue\n        \n        # Add the last block, which extends to the end of the loci\n        blocks.append([block_start, n_loci - 1])\n        \n        return blocks\n\n    results = []\n    for case in test_cases:\n        result = find_blocks(case)\n        results.append(result)\n\n    # Final print statement in the exact required format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2401326"}, {"introduction": "除了识别单倍型块的边界，量化特定变异之间的关联强度对于基因组关联研究（GWAS）等应用至关重要。本练习聚焦于最常用的连锁不平衡度量 $r^2$，要求您编写程序来完成一项真实的生物信息学任务。您将学习如何解析标准的VCF（变异检出格式）文件，并计算 $r^2$ 值来寻找与目标变异紧密相关的“LD伙伴”。[@problem_id:2401344]", "problem": "你的任务是编写一个完整的程序，该程序对每个提供的代表单个染色体的变异调用格式（Variant Call Format, VCF）文本，识别出指定目标变异的所有“连锁不平衡（Linkage Disequilibrium, LD）伙伴”。如果一个变异与目标变异在二倍体个体中的备用等位基因计数的皮尔逊相关系数平方值（记为 $r^2$）严格超过给定的阈值 $\\tau$，则该变异被视为目标的 LD 伙伴。所有计算必须基于下文指定的第一性原理，并且所有输出必须符合本说明末尾定义的格式。\n\n定义。考虑一个包含 $S$ 个二倍体个体的集合，以及一条染色体上的 $M$ 个双等位基因单核苷酸变异的集合。对于变异 $j \\in \\{1,\\dots,M\\}$ 和个体 $s \\in \\{1,\\dots,S\\}$，设 VCF 文件中 GT 字段的基因型调用为标准形式之一：$0/0$、$0/1$、$1/0$、$1/1$、$0|0$、$0|1$、$1|0$、$1|1$，或缺失（例如 $./.$）。定义备用等位基因计数\n$$\nx^{(j)}_s \\in \\{0,1,2\\}\n$$\n为变异 $j$ 和个体 $s$ 的基因型调用中备用等位基因的数量，其中缺失的基因型被视为未定义。对于一对变异 $(j,k)$，将在两个变异上基因型均非缺失的个体集合定义为\n$$\n\\mathcal{I}_{jk} = \\{ s \\in \\{1,\\dots,S\\} \\mid x^{(j)}_s \\text{ 和 } x^{(k)}_s \\text{ 均已定义} \\},\n$$\n并令\n$$\nn_{jk} = |\\mathcal{I}_{jk}|.\n$$\n如果 $n_{jk}  2$，则 $(j,k)$ 的 $r^2$ 未定义。否则，定义群体均值\n$$\n\\mu_j = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} x^{(j)}_s, \\qquad \\mu_k = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} x^{(k)}_s,\n$$\n群体方差\n$$\n\\sigma_j^2 = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(j)}_s - \\mu_j\\right)^2, \\qquad \\sigma_k^2 = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(k)}_s - \\mu_k\\right)^2,\n$$\n以及群体协方差\n$$\n\\operatorname{Cov}_{jk} = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(j)}_s - \\mu_j\\right)\\left(x^{(k)}_s - \\mu_k\\right).\n$$\n如果 $\\sigma_j^2 = 0$ 或 $\\sigma_k^2 = 0$，则 $(j,k)$ 的 $r^2$ 未定义。否则，定义皮尔逊相关性\n$$\nr_{jk} = \\frac{\\operatorname{Cov}_{jk}}{\\sqrt{\\sigma_j^2 \\sigma_k^2}}\n$$\n以及连锁不平衡度量\n$$\nr_{jk}^2 = \\left(r_{jk}\\right)^2.\n$$\n固定一个目标变异索引 $t$ 和一个阈值 $\\tau \\in (0,1)$。一个变异 $j \\neq t$ 是 $t$ 的 LD 伙伴，当且仅当 $r_{tj}^2  \\tau$。$r_{tj}^2$ 未定义的变异对不是 LD 伙伴。\n\n输入表示。每个测试用例包含：\n- 一个用于选择行的染色体标识符（字符串）。\n- 一个 VCF 文本，其标题行以字段 CHROM、POS、ID、REF、ALT、QUAL、FILTER、INFO、FORMAT 开头，后跟 $S$ 个样本列。只有 FORMAT 中的 GT 子字段是相关的。所有变异都是双等位基因的，并且一个测试用例中的所有行都属于同一条染色体。\n- 一个目标变异位置（给定染色体上的一个整数碱基对坐标）。\n- 一个阈值 $\\tau$，以 $(0,1)$ 区间内的小数形式给出。\n\n你的程序必须使用下面测试套件中提供的 VCF 文本和参数作为其内部数据，并且不得需要任何用户输入或外部文件。\n\n测试套件。共有三个测试用例。对于每个用例，请使用指定的染色体字符串、目标位置、阈值 $\\tau = 0.8$ 以及提供的 VCF 内容。\n\n测试用例 A:\n- 染色体: \"1\"\n- 目标位置: 200\n- 阈值: $0.8$\n- VCF 行:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3 S4\"\n  - \"1 100 rs100 A G . . . GT 0/0 0/1 1/1 0/1\"\n  - \"1 200 rs200 A G . . . GT 0/0 0/1 1/1 0/1\"\n  - \"1 300 rs300 A G . . . GT 0/0 0/0 1/1 1/1\"\n\n测试用例 B:\n- 染色体: \"1\"\n- 目标位置: 1000\n- 阈值: $0.8$\n- VCF 行:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3 S4 S5 S6\"\n  - \"1 1000 rs1000 A G . . . GT 0/0 0/1 1/1 0/1 0/0 1/1\"\n  - \"1 1010 rs1010 A G . . . GT 0/0 0/1 1/1 0/1 0/0 1/1\"\n  - \"1 1020 rs1020 A G . . . GT 0/0 0/0 0/0 0/0 0/0 0/0\"\n  - \"1 1030 rs1030 A G . . . GT 0/0 ./. 1/1 ./. 0/0 ./.\"\n  - \"1 1040 rs1040 A G . . . GT 0/0 0/0 1/1 1/1 0/0 1/1\"\n\n测试用例 C:\n- 染色体: \"2\"\n- 目标位置: 5000\n- 阈值: $0.8$\n- VCF 行:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3\"\n  - \"2 5000 rs5000 A G . . . GT 0/0 0/0 0/0\"\n  - \"2 5010 rs5010 A G . . . GT 0/0 1/1 0/1\"\n  - \"2 5020 rs5020 A G . . . GT 0/1 1/1 0/0\"\n\n输出规范。对每个测试用例，输出一个按位置升序排列的排序列表，其中包含作为目标 LD 伙伴的所有变异位置。将三个测试用例的列表聚合到单行输出中，格式化为方括号括起来的逗号分隔列表，不含空格，例如 \"[[a,b],[c],[]]\"。内部列表中的元素必须是整数。你的程序应该生成单行输出，其中仅包含此格式的聚合结果。", "solution": "该问题是有效的。它在群体遗传学方面有科学依据，在数学上定义明确，并且为提供完整解法提供了所有必要的数据和定义。\n\n目标是从变异调用格式 (VCF) 数据中，为指定的目标变异识别出“连锁不平衡 (LD) 伙伴”。一个变异 $j$ 是目标变异 $t$ 的 LD 伙伴，如果根据它们在二倍体个体群体中的备用等位基因计数计算出的皮尔逊相关系数平方值 $r_{tj}^2$ 超过了给定的阈值 $\\tau$。解法必须基于问题陈述中定义的第一性原理推导得出。\n\n算法流程分为三个主要阶段：数据解析与准备、$r^2$ 统计量的计算、以及结果的识别与格式化。\n\n首先，我们必须为每个测试用例解析提供的 VCF 文本。VCF 格式表示遗传变异。就我们的目的而言，我们关心的是双等位基因单核苷酸变异。关键信息位于 `POS`（位置）列以及 `FORMAT` 和样本列中的 `GT`（基因型）子字段。我们遍历 VCF 文本的每个非标题行。对于每个变异，我们记录其染色体位置（一个整数）。基因型调用，如 `$0/0$`、`$0/1$`、`$1/0$` 和 `$1/1$`，必须转换为数值形式的备用等位基因计数 $x_s^{(j)} \\in \\{0, 1, 2\\}$。具体来说，`$0/0$` 和 `$0|0$` 映射为 $0$，$0/1$`、`$1/0$`、`$0|1$` 和 `$1|0$` 映射为 $1$，而 `$1/1$` 和 `$1|1$` 映射为 $2$。缺失的基因型（表示为 `$./.$`）被视为未定义，并用一个特殊值（如 `np.nan`）来表示，以方便数值计算。此过程会产生一组位置向量和一个对应的维度为 $M \\times S$ 的基因型矩阵，其中 $M$ 是变异数量，$S$ 是个体数量。\n\n问题的核心是正确计算目标变异 $t$ 与每个其他候选变异 $j$ 之间的 $r^2$ 统计量。计算必须严格遵循所提供的定义。对于任何一对变异 $(t, j)$，我们首先确定在两个变异上都有基因型数据的个体集合 $\\mathcal{I}_{tj}$。令 $n_{tj} = |\\mathcal{I}_{tj}|$。问题规定，如果 $n_{tj}  2$，$r_{tj}^2$ 则未定义。在这种情况下，该变异对将被舍弃。\n\n如果 $n_{tj} \\ge 2$，我们继续仅使用来自 $\\mathcal{I}_{tj}$ 中个体的数据来计算必要的统计量。设过滤后的等位基因计数向量为 $\\mathbf{x}^{(t)}$ 和 $\\mathbf{x}^{(j)}$。群体均值计算如下：\n$$\n\\mu_t = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} x^{(t)}_s, \\qquad \\mu_j = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} x^{(j)}_s\n$$\n群体方差为：\n$$\n\\sigma_t^2 = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(t)}_s - \\mu_t\\right)^2, \\qquad \\sigma_j^2 = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(j)}_s - \\mu_j\\right)^2\n$$\n如果一个变异在所考虑的子群体 $\\mathcal{I}_{tj}$ 中是单态的（即所有个体具有相同的等位基因计数），就会出现一个关键的边界情况。在这种情况下，方差为零。问题指出，如果 $\\sigma_t^2 = 0$ 或 $\\sigma_j^2 = 0$，$r_{tj}^2$ 就未定义，并且该变异对不被考虑为 LD 伙伴。\n\n如果两个方差都非零，我们计算群体协方差：\n$$\n\\operatorname{Cov}_{tj} = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(t)}_s - \\mu_t\\right)\\left(x^{(j)}_s - \\mu_j\\right)\n$$\n最后，皮尔逊相关系数的平方计算如下：\n$$\nr_{tj}^2 = \\left( \\frac{\\operatorname{Cov}_{tj}}{\\sqrt{\\sigma_t^2 \\sigma_j^2}} \\right)^2 = \\frac{(\\operatorname{Cov}_{tj})^2}{\\sigma_t^2 \\sigma_j^2}\n$$\n对目标变异 $t$ 和每个其他变异 $j \\neq t$ 执行此计算。如果计算出的 $r_{tj}^2$ 是一个有效数字且 $r_{tj}^2  \\tau$（其中 $\\tau$ 是给定的阈值），那么变异 $j$ 就是 $t$ 的一个 LD 伙伴。变异 $j$ 的位置被添加到当前测试用例的结果列表中。\n\n整体算法流程如下：\n1.  初始化一个空列表，用于存储所有测试用例的最终结果。\n2.  对每个测试用例，解析 VCF 文本，创建从变异位置到其在所有样本中的等位基因计数向量的映射。\n3.  识别与给定目标位置对应的目标变异的等位基因计数向量。\n4.  遍历所有其他变异。对于每个候选变异：\n    a. 应用成对删除（pairwise deletion）处理缺失数据，为目标和候选变异创建过滤后的向量。\n    b. 检查有效性条件：$n_{tj} \\ge 2$, $\\sigma_t^2  0$ 和 $\\sigma_j^2  0$。\n    c. 如果有效，则使用群体统计公式计算 $r_{tj}^2$。\n    d. 如果 $r_{tj}^2  \\tau$，则将候选变异的位置添加到当前测试用例的临时列表中。\n5.  检查完一个测试用例的所有候选变异后，将 LD 伙伴位置列表按升序排序。\n6.  将此排序后的列表追加到主结果列表中。\n7.  处理完所有测试用例后，按照规定将聚合结果格式化为单个嵌套列表字符串，例如 `[[pos1,pos2],[pos3],[]]`，并输出此字符串。这确保了符合严格的输出格式要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linkage disequilibrium buddy problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"chrom\": \"1\",\n            \"target_pos\": 200,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\tS4\n1\t100\trs100\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\n1\t200\trs200\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\n1\t300\trs300\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t1/1\t1/1\n\"\"\"\n        },\n        {\n            \"chrom\": \"1\",\n            \"target_pos\": 1000,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\tS4\tS5\tS6\n1\t1000\trs1000\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\t0/0\t1/1\n1\t1010\trs1010\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\t0/0\t1/1\n1\t1020\trs1020\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t0/0\t0/0\t0/0\t0/0\n1\t1030\trs1030\tA\tG\t.\t.\t.\tGT\t0/0\t./.\t1/1\t./.\t0/0\t./.\n1\t1040\trs1040\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t1/1\t1/1\t0/0\t1/1\n\"\"\"\n        },\n        {\n            \"chrom\": \"2\",\n            \"target_pos\": 5000,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\n2\t5000\trs5000\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t0/0\n2\t5010\trs5010\tA\tG\t.\t.\t.\tGT\t0/0\t1/1\t0/1\n2\t5020\trs5020\tA\tG\t.\t.\t.\tGT\t0/1\t1/1\t0/0\n\"\"\"\n        }\n    ]\n\n    aggregated_results = []\n    \n    for case in test_cases:\n        vcf_text = case[\"vcf_text\"]\n        target_pos = case[\"target_pos\"]\n        tau = case[\"tau\"]\n\n        # Parse VCF text\n        positions = []\n        genotypes_list = []\n        lines = vcf_text.strip().split('\\n')\n        \n        header_line = \"\"\n        data_lines = []\n        for line in lines:\n            if line.startswith('#CHROM'):\n                header_line = line\n            elif not line.startswith('##'):\n                data_lines.append(line)\n\n        header_fields = header_line.split('\\t')\n        format_col_idx = header_fields.index('FORMAT')\n        sample_cols_start_idx = format_col_idx + 1\n\n        for line in data_lines:\n            parts = line.split('\\t')\n            positions.append(int(parts[1]))\n            \n            format_str = parts[format_col_idx]\n            try:\n                gt_subfield_idx = format_str.split(':').index('GT')\n            except ValueError:\n                # This case implies GT field is missing, which is a malformed VCF for this problem.\n                # We assume valid VCFs as per problem context.\n                continue\n\n            allele_counts = []\n            for sample_gt_field in parts[sample_cols_start_idx:]:\n                gt_str = sample_gt_field.split(':')[gt_subfield_idx]\n                \n                if gt_str in ('0/0', '0|0'):\n                    allele_counts.append(0)\n                elif gt_str in ('0/1', '1/0', '0|1', '1|0'):\n                    allele_counts.append(1)\n                elif gt_str in ('1/1', '1|1'):\n                    allele_counts.append(2)\n                else: # Missing, e.g., './.'\n                    allele_counts.append(np.nan)\n            \n            genotypes_list.append(allele_counts)\n        \n        genotypes = np.array(genotypes_list, dtype=float)\n\n        # Identify target variant\n        try:\n            target_idx = positions.index(target_pos)\n        except ValueError:\n            aggregated_results.append([])\n            continue # Target not found, no buddies\n\n        target_vec = genotypes[target_idx, :]\n        \n        ld_buddies = []\n\n        # Find LD buddies\n        for j in range(len(positions)):\n            if j == target_idx:\n                continue\n            \n            candidate_pos = positions[j]\n            candidate_vec = genotypes[j, :]\n\n            # Filter for individuals with non-missing genotypes for both variants\n            valid_indices = ~np.isnan(target_vec)  ~np.isnan(candidate_vec)\n            \n            x_t_j_valid = target_vec[valid_indices]\n            x_k_j_valid = candidate_vec[valid_indices]\n            \n            n_jk = len(x_t_j_valid)\n\n            if n_jk  2:\n                continue\n\n            var_t = np.var(x_t_j_valid) # ddof=0 is default for population variance\n            var_k = np.var(x_k_j_valid)\n\n            if var_t == 0 or var_k == 0:\n                continue\n\n            # Calculate population covariance\n            # np.cov with ddof=0 ensures population covariance calculation\n            cov_matrix = np.cov(x_t_j_valid, x_k_j_valid, ddof=0)\n            cov_tk = cov_matrix[0, 1]\n\n            r_squared = (cov_tk ** 2) / (var_t * var_k)\n            \n            # Since floating point arithmetic can sometimes result in values slightly > 1.0, clip it.\n            # e.g. for identical vectors.\n            if r_squared > 1.0:\n                r_squared = 1.0\n\n            if r_squared > tau:\n                ld_buddies.append(candidate_pos)\n\n        ld_buddies.sort()\n        aggregated_results.append(ld_buddies)\n\n    # Format and print the final output\n    inner_lists_str = [f\"[{','.join(map(str, lst))}]\" for lst in aggregated_results]\n    print(f\"[{','.join(inner_lists_str)}]\")\n\nsolve()\n```", "id": "2401344"}]}