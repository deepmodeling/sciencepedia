{"hands_on_practices": [{"introduction": "在深入分析之前，评估ChIP-seq数据的质量是至关重要的一步。一个成功的实验应该在预期的信号区域（峰）中显示出测序读段的显著富集，而不是在已知的噪声或假象区域（黑名单区域）中。这项练习将引导你实现一个基本的质量控制指标 $Q$ [@problem_id:2397933]，通过计算峰中读段与黑名单区域中读段的比率，来量化信号与噪声的对比，这是任何ChIP-seq分析流程的关键第一步。", "problem": "给定一份针对组蛋白修饰染色质免疫沉淀后测序 (ChIP-seq) 实验的质量控制的数学形式化描述。基因组被建模为一条长度为 $L$ 个碱基对 (bp) 的一维坐标轴，所有坐标均为整数。每个比对上的读段 (read) 表示为一个半开基因组区间 $[s_i, e_i)$，其中 $0 \\le s_i < e_i \\le L$。候选峰 (peak) 表示为一个由半开区间组成的有限集合 $\\{P_j\\}$，公共黑名单区域则表示为另一个由半开区间组成的有限集合 $\\{B_k\\}$。所有区间的单位都为碱基对。\n\n定义读段 $i$ 与区间集合 $S$ 相交的指示条件如下：读段 $i$ 与 $S$ 相交，当且仅当在半开语义下，区间 $[s_i, e_i)$ 与 $S$ 中所有区间的并集的交集长度非零。也就是说，\n$$\n\\max(s_i, a) < \\min(e_i, b)\n$$\n对于集合 $S$ 中至少一个区间 $[a,b)$ 成立。对于每个集合（峰或黑名单），无论一个读段与该集合内的多少个区间相交，它最多只被计数一次。同时与峰和黑名单相交的读段，在两者的计数中都会被计入。\n\n设 $R_{\\mathrm{peaks}}$ 为与至少一个峰区间相交的读段数量，设 $R_{\\mathrm{blacklist}}$ 为与至少一个黑名单区间相交的读段数量。对于给定的伪计数 $\\epsilon > 0$，定义质量控制指标\n$$\nQ \\;=\\; \\frac{R_{\\mathrm{peaks}} + \\epsilon}{R_{\\mathrm{blacklist}} + \\epsilon}.\n$$\n该比率量化了峰中读段富集程度 (RiP) 相对于公共黑名单区域中读段的富集程度，并通过伪计数进行了稳定化处理。\n\n您的任务是为以下每个测试用例计算 $Q$。所有用例均使用相同的伪计数 $\\epsilon = 0.5$。所有坐标均为以碱基对为单位的整数，所有区间均为半开区间 $[x,y)$。\n\n测试套件（每个用例提供 $L$、读段列表、峰列表和黑名单区间列表）：\n- 用例 $1$：\n  - $L = 1000$, $\\epsilon = 0.5$。\n  - 读段: $[(90,110),(140,170),(180,210),(300,320),(405,415),(495,505),(800,820),(850,870),(880,920),(0,10)]$。\n  - 峰: $[(100,200),(400,500)]$。\n  - 黑名单: $[(150,160),(800,900)]$。\n- 用例 $2$：\n  - $L = 1000$, $\\epsilon = 0.5$。\n  - 读段: $[(110,115),(150,160),(90,95),(300,310)]$。\n  - 峰: $[(100,200)]$。\n  - 黑名单: $[(600,700)]$。\n- 用例 $3$：\n  - $L = 1000$, $\\epsilon = 0.5$。\n  - 读段: $[(805,815),(810,830),(200,210)]$。\n  - 峰: $[(400,450)]$。\n  - 黑名单: $[(800,820)]$。\n- 用例 $4$ (半开语义下的边界条件)：\n  - $L = 500$, $\\epsilon = 0.5$。\n  - 读段: $[(80,100),(200,220),(199,200),(250,260),(150,200)]$。\n  - 峰: $[(100,200)]$。\n  - 黑名单: $[(200,250)]$。\n- 用例 $5$ (与峰和黑名单均有重叠，包含重复的读段)：\n  - $L = 1000$, $\\epsilon = 0.5$。\n  - 读段: $[(240,260),(620,630),(610,615),(660,670),(0,50),(295,305),(620,630)]$。\n  - 峰: $[(100,300),(600,650)]$。\n  - 黑名单: $[(250,350),(620,700)]$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用例1到5的 $Q$ 值结果，按顺序排列，以逗号分隔，并用方括号括起来。每个 $Q$ 值必须四舍五入到恰好6位小数。例如，包含三个值的输出应如下所示：$[0.500000,1.250000,2.000000]$。", "solution": "该问题要求为一系列染色质免疫沉淀后测序 (ChIP-seq) 实验计算质量控制指标 $Q$。该指标定义为指定峰区域中的读段计数与黑名单区域中读段计数的比率，并通过伪计数 $\\epsilon$ 进行稳定化。\n\n其基本几何对象是一维半开区间 $[s, e)$，代表基因组上的位置。给定一个读段集合 $\\{[s_i, e_i)\\}$、一个峰区间集合 $\\{P_j\\}$ 和一个黑名单区间集合 $\\{B_k\\}$。问题为读段区间与区间集合的相交提供了精确的定义。一个读段 $[s_i, e_i)$ 被认为与区间集合 $S$ 相交，如果存在至少一个区间 $[a, b) \\in S$，使得它们的交集长度非零。该条件被正式表述为 $\\max(s_i, a) < \\min(e_i, b)$。\n\n我们的目标是为每个测试用例计算两个量：\n$1$. $R_{\\mathrm{peaks}}$，即与峰区间集合 $\\{P_j\\}$ 相交的读段总数。\n$2$. $R_{\\mathrm{blacklist}}$，即与黑名单区间集合 $\\{B_k\\}$ 相交的读段总数。\n\n如果一个读段与给定集合中的至少一个区间相交，则被计数。无论它与该集合内的多少个区间重叠，它对该集合的计数仅贡献一次。如果一个读段同时与峰集合中的一个区间和黑名单集合中的一个区间相交，它将对 $R_{\\mathrm{peaks}}$ 和 $R_{\\mathrm{blacklist}}$ 的计数都有贡献。\n\n然后使用以下公式计算质量控制指标 $Q$：\n$$\nQ = \\frac{R_{\\mathrm{peaks}} + \\epsilon}{R_{\\mathrm{blacklist}} + \\epsilon}\n$$\n对于所有测试用例，给定的伪计数为 $\\epsilon = 0.5$。\n\n算法流程如下：\n对于每个测试用例：\n初始化计数 $R_{\\mathrm{peaks}} = 0$ 和 $R_{\\mathrm{blacklist}} = 0$。\n遍历读段列表中的每个读段区间 $[s_i, e_i)$。\n对当前读段，我们执行两个独立的检查：\n首先，我们检查与峰集合的相交情况。我们遍历每个峰区间 $[p_s, p_e) \\in \\{P_j\\}$。如果对于任何一个峰区间，条件 $\\max(s_i, p_s) < \\min(e_i, p_e)$ 满足，则该读段与峰集合相交。我们将 $R_{\\mathrm{peaks}}$ 加 1，并停止对该读段与其它峰区间的检查。\n其次，我们检查与黑名单集合的相交情况。我们遍历每个黑名单区间 $[b_s, b_e) \\in \\{B_k\\}$。如果对于任何一个黑名单区间，条件 $\\max(s_i, b_s) < \\min(e_i, b_e)$ 满足，则该读段与黑名单集合相交。我们将 $R_{\\mathrm{blacklist}}$ 加 1，并停止对该读段与其它黑名单区间的检查。\n遍历完所有读段后，我们使用最终的计数 $R_{\\mathrm{peaks}}$ 和 $R_{\\mathrm{blacklist}}$，根据给定的公式计算 $Q$。\n\n我们将此流程应用于每个测试用例。\n\n用例 $1$：$R_{\\mathrm{peaks}} = 5$, $R_{\\mathrm{blacklist}} = 4$。\n$$Q = \\frac{5 + 0.5}{4 + 0.5} = \\frac{5.5}{4.5} \\approx 1.222222$$\n\n用例 $2$：$R_{\\mathrm{peaks}} = 2$, $R_{\\mathrm{blacklist}} = 0$。\n$$Q = \\frac{2 + 0.5}{0 + 0.5} = \\frac{2.5}{0.5} = 5.0$$\n\n用例 $3$：$R_{\\mathrm{peaks}} = 0$, $R_{\\mathrm{blacklist}} = 2$。\n$$Q = \\frac{0 + 0.5}{2 + 0.5} = \\frac{0.5}{2.5} = 0.2$$\n\n用例 $4$：$R_{\\mathrm{peaks}} = 2$, $R_{\\mathrm{blacklist}} = 1$。在这里，半开区间的定义至关重要。例如，读段 $[80, 100)$ 与峰 $[100, 200)$ 不相交，因为 $\\max(80, 100) = 100$ 并且 $\\min(100, 200) = 100$，而条件 $100 < 100$ 不成立。\n$$Q = \\frac{2 + 0.5}{1 + 0.5} = \\frac{2.5}{1.5} \\approx 1.666667$$\n\n用例 $5$：$R_{\\mathrm{peaks}} = 5$, $R_{\\mathrm{blacklist}} = 5$。读段列表包含一个重复的条目 $(620, 630)$，它被视为两个独立的读段，并都根据规则进行处理。该读段的两个实例都与峰集合和黑名单集合相交。\n$$Q = \\frac{5 + 0.5}{5 + 0.5} = \\frac{5.5}{5.5} = 1.0$$\n\n最终结果被收集并按规定格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the ChIP-seq quality control metric Q for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 1000,\n            \"reads\": [(90, 110), (140, 170), (180, 210), (300, 320), (405, 415), (495, 505), (800, 820), (850, 870), (880, 920), (0, 10)],\n            \"peaks\": [(100, 200), (400, 500)],\n            \"blacklist\": [(150, 160), (800, 900)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(110, 115), (150, 160), (90, 95), (300, 310)],\n            \"peaks\": [(100, 200)],\n            \"blacklist\": [(600, 700)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(805, 815), (810, 830), (200, 210)],\n            \"peaks\": [(400, 450)],\n            \"blacklist\": [(800, 820)],\n        },\n        {\n            \"L\": 500,\n            \"reads\": [(80, 100), (200, 220), (199, 200), (250, 260), (150, 200)],\n            \"peaks\": [(100, 200)],\n            \"blacklist\": [(200, 250)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(240, 260), (620, 630), (610, 615), (660, 670), (0, 50), (295, 305), (620, 630)],\n            \"peaks\": [(100, 300), (600, 650)],\n            \"blacklist\": [(250, 350), (620, 700)],\n        },\n    ]\n\n    epsilon = 0.5\n    results = []\n\n    def intersects_set(read_interval, interval_set):\n        \"\"\"\n        Checks if a read interval intersects with any interval in a given set.\n        Intersection of [s, e) and [a, b) is non-empty if max(s, a) < min(e, b).\n        \"\"\"\n        s_i, e_i = read_interval\n        for a_j, b_j in interval_set:\n            if max(s_i, a_j) < min(e_i, b_j):\n                return True\n        return False\n\n    for case in test_cases:\n        reads = case[\"reads\"]\n        peaks = case[\"peaks\"]\n        blacklist = case[\"blacklist\"]\n\n        r_peaks = 0\n        r_blacklist = 0\n\n        for read in reads:\n            # Check for intersection with peaks\n            if intersects_set(read, peaks):\n                r_peaks += 1\n            \n            # Check for intersection with blacklist\n            if intersects_set(read, blacklist):\n                r_blacklist += 1\n        \n        # Calculate the quality metric Q\n        Q = (r_peaks + epsilon) / (r_blacklist + epsilon)\n        results.append(f\"{Q:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2397933"}, {"introduction": "确认数据质量后，下一步是精确识别组蛋白修饰富集的基因组区域，这一过程称为“峰识别”（peak calling）。我们可以使用泊松分布来模拟随机背景读段的分布，其均值为 $\\mu = \\lambda_0 w$；当某个区域的观测读段数显著超过背景期望时，该区域就被识别为峰。这项实践通过让你从零开始构建一个简化版的峰识别器[@problem_id:2397925]，揭示了其核心算法的神秘面纱，你将学习如何应用统计模型和多重检验校正来严格定义显著富集。", "problem": "您的任务是设计并实现一个简单的峰值检出程序（peak caller），用于处理染色质免疫沉淀-DNA测序（ChIP-seq）的read堆积数据。该程序通过将沿基因组区间的read出现建模为均匀泊松点过程。其科学依据是均匀泊松点过程的定义：在不相交区间内的事件计数是独立的，且任何长度为 $w$ 的区间内的计数遵循泊松分布，其均值为 $\\lambda w$，其中 $\\lambda$ 是单位长度的恒定事件率。在此背景下，根据无富集的零假设模型，ChIP-seq的read被理想化为沿长度为 $L$ 的基因组片段上的均匀泊松点过程事件，其背景率为每个碱基对 $\\lambda_0$ 个read。一个宽度为 $w$ 个碱基对的扫描窗口所产生的read计数，其零分布为均值 $\\mu = \\lambda_0 w$ 的泊松分布。为了检测富集，需将每个窗口中观测到的计数值与此零分布进行比较，使用单侧尾概率计算观测到至少为测量计数值的概率，然后使用Benjamini–Hochberg升阶程序对所有测试窗口的错误发现率（FDR）进行控制。\n\n您的任务是编写一个完整的程序，该程序能够：\n- 接受每个测试用例在代码中定义的内部常量：一个read位置列表（整数，以碱基对为单位，从 $0$ 到 $L-1$ 测量），基因组区间长度 $L$（单位：碱基对），窗口宽度 $w$（单位：碱基对），扫描步长 $s$（单位：碱基对），背景率 $\\lambda_0$（单位：每个碱基对的read数），以及目标FDR水平 $q$（以小数形式，而非百分比）。\n- 扫描起始位置为 $t \\in \\{0, s, 2s, \\ldots\\}$ 的窗口 $[t, t+w)$，并约束 $t + w \\le L$。\n- 对每个窗口内的read进行计数，在均值为 $\\mu = \\lambda_0 w$ 的泊松零分布下，计算“观测计数至少为测量计数”这一事件的单侧尾概率，并对该测试用例中所有扫描窗口在目标水平 $q$ 下应用Benjamini–Hochberg升阶程序。\n- 针对每个测试用例，返回经过多重检验校正后被判定为显著的窗口起始坐标列表（单位：碱基对）。该列表必须按基因组坐标升序排序。\n\n科学与算法约束：\n- 使用均匀泊松点过程作为背景read出现的零假设模型，其恒定率为 $\\lambda_0$；在宽度为 $w$ 的窗口中，零假设下的计数分布为均值 $\\mu = \\lambda_0 w$ 的泊松分布。\n- 每个窗口使用单侧富集检验，该检验评估在泊松零分布下观测到至少为测量计数的尾概率。\n- 使用Benjamini–Hochberg升阶程序在水平 $q$ 下控制错误发现率，该程序应用于一个测试用例中的所有窗口。\n- 位置以碱基对为单位进行测量；以整数形式报告窗口起始坐标（单位：碱基对）。\n\n要在您的程序中实现的测试套件（每个都是独立的测试用例）：\n- 案例 A（仅背景；预计无峰值）：$L = 1000$， $w = 100$， $s = 100$， $\\lambda_0 = 0.01$ 每个碱基对的read数， $q = 0.1$， read位置 $[50, 250, 750]$。预期行为：无显著窗口。\n- 案例 B（一个明确的内部峰值）：$L = 1000$， $w = 100$， $s = 100$， $\\lambda_0 = 0.01$ 每个碱基对的read数， $q = 0.1$， read位置 $[20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]$。预期行为：起始于 $400$ 碱基对的窗口是显著的。\n- 案例 C（末端的边界峰值）：$L = 500$， $w = 100$， $s = 100$， $\\lambda_0 = 0.01$ 每个碱基对的read数， $q = 0.05$， read位置 $[401, 402, 415, 420, 430, 440, 450, 460, 480]$。预期行为：起始于 $400$ 碱基对的窗口是显著的。\n- 案例 D（多个中等峰值；多重检验相互作用）：$L = 800$， $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ 每个碱基对的read数， $q = 0.1$, read位置 $[110, 115, 120, 130, 180, 505, 510, 530, 540, 590]$。预期行为：起始于 $100$ 和 $500$ 碱基对的窗口是显著的。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有四个案例的结果，格式为一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个整数列表，代表相应案例的显著窗口起始坐标。例如，一个有效的格式是 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不含任何额外文本。所有坐标必须是整数形式的碱基对（bp）。", "solution": "我们的任务是设计一个计算流程，用于识别染色质免疫沉淀测序（ChIP-seq）数据中的信号富集区域。这是计算基因组学中的一个经典问题，被称为“峰值检出（peak calling）”。所给的问题陈述在科学上是合理的，在算法上是明确定义的，它基于已确立的生物统计学原理。因此，它是有效的，我们着手构建解决方案。\n\n其基本前提是使用一个随机过程来模拟测序read的背景分布。在没有特异性蛋白质-脱氧核糖核酸（DNA）结合的零假设下，假定read在整个基因组中是随机分布的。均匀泊松点过程为这种随机背景提供了一个简单而强大的零模型。\n\n我们方法的核心包括三个阶段：首先，对基因组进行分区并量化read计数；其次，根据零模型评估观测计数的统计显著性；第三，对在整个基因组上进行的多重检验进行校正。\n\n首先，我们处理基因组分块（tiling）和read计数的任务。使用宽度为 $w$、步长为 $s$ 的滑动窗口扫描长度为 $L$ 的基因组区间。这些窗口的起始坐标由集合 $\\{t_i = i \\cdot s \\mid i \\in \\mathbb{Z}_{\\ge 0}, i \\cdot s + w \\le L\\}$ 给出。窗口的总数，也就是统计检验的总数，是 $M = \\lfloor \\frac{L-w}{s} \\rfloor + 1$。对于每个跨越基因组区间 $[t_i, t_i+w)$ 的窗口 $i$，我们统计其位置落在此区间内的观测read数，记为 $k_i$。\n\n其次，我们制定用于富集度检验的统计方法。零假设 $H_0$ 指出，read的出现遵循一个均匀泊松过程，其恒定率为每个碱基对 $\\lambda_0$ 个read。因此，任何宽度为 $w$ 的窗口中的read数 $X$ 遵循一个泊松分布，其均值参数为 $\\mu = \\lambda_0 w$。其概率质量函数为 $P(X=k | H_0) = \\frac{e^{-\\mu}\\mu^k}{k!}$。为了检验富集，我们为每个窗口 $i$ 计算一个单侧p值。这个p值是在零分布下观测到至少为 $k_i$ 的read计数的概率。这对应于泊松分布的生存函数（或互补累积分布函数）：\n$$p_i = P(X \\ge k_i) = \\sum_{j=k_i}^{\\infty} \\frac{e^{-\\mu}\\mu^j}{j!} = 1 - \\sum_{j=0}^{k_i-1} \\frac{e^{-\\mu}\\mu^j}{j!}$$\n一个小的p值表明，在随机背景的假设下，观测到的计数值 $k_i$ 异常高，从而为反对该特定窗口的零假设提供了证据。\n\n第三，我们必须解决多重假设检验问题。由于我们对每个窗口都进行一次检验，总共进行了 $M$ 次独立或相关的检验，使用一个朴素的p值阈值（例如 $p \\le 0.05$）会增加假阳性发现的比例。为了控制这一点，我们采用Benjamini–Hochberg (BH) 程序，将错误发现率（FDR）控制在指定的水平 $q$。FDR是被错误拒绝的零假设占所有被拒绝的零假设的预期比例。BH程序如下：\n1.  收集所有 $M$ 个 p 值，$\\{p_1, p_2, \\ldots, p_M\\}$。\n2.  将这些 p 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(M)}$。\n3.  找到最大的整数秩 $k$，使得第 $k$ 个有序p值满足条件：\n    $p_{(k)} \\le \\frac{k}{M}q$\n4.  如果存在这样的 $k$，我们拒绝与 p 值 $p_{(1)}, p_{(2)}, \\ldots, p_{(k)}$ 相对应的所有窗口的零假设。这些窗口被宣布为“显著的”。\n5.  如果不存在这样的 $k$（即，$p_{(1)} > \\frac{1}{M}q$），则不拒绝任何零假设，也没有窗口被宣布为显著的。\n\n该程序保证，对于独立的检验，预期的FDR小于或等于 $q$。最终的输出是所有被此程序识别为显著的窗口的起始坐标 $t_i$ 的排序列表。\n\n因此，算法实现将系统地执行以下步骤：\n1.  根据 $L$、$w$ 和 $s$ 生成所有窗口的起始坐标。\n2.  对每个窗口，高效地统计其边界内的read数。初始时对read位置进行排序，可使用二分查找实现快速计数。\n3.  计算泊松参数 $\\mu = \\lambda_0 w$。\n4.  对于每个窗口计数 $k_i$，使用泊松($\\mu$)分布的生存函数计算相应的p值。\n5.  对所有p值的集合应用Benjamini-Hochberg程序，以识别显著发现的子集。\n6.  返回显著窗口的起始坐标，按升序排序。\n这为所提出的问题提供了一个严谨而完整的框架。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run the ChIP-seq peak calling analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (background only; no peaks expected)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [50, 250, 750]\n        },\n        # Case B (one clear internal peak)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]\n        },\n        # Case C (boundary peak at the end)\n        {\n            \"L\": 500, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.05,\n            \"read_positions\": [401, 402, 415, 420, 430, 440, 450, 460, 480]\n        },\n        # Case D (multiple moderate peaks; multiple-testing interaction)\n        {\n            \"L\": 800, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [110, 115, 120, 130, 180, 505, 510, 530, 540, 590]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        w = case[\"w\"]\n        s = case[\"s\"]\n        lambda_0 = case[\"lambda_0\"]\n        q = case[\"q\"]\n        read_positions = np.array(sorted(case[\"read_positions\"]))\n\n        # Step 1: Generate window starts and count reads\n        window_starts = np.arange(0, L - w + 1, s, dtype=int)\n        \n        # Efficiently count reads in each window using pre-sorted positions\n        window_counts = np.zeros_like(window_starts, dtype=int)\n        for i, start in enumerate(window_starts):\n            end = start + w\n            left_idx = np.searchsorted(read_positions, start, side='left')\n            right_idx = np.searchsorted(read_positions, end, side='left')\n            window_counts[i] = right_idx - left_idx\n        \n        # Step 2: Calculate p-values based on Poisson null model\n        mu = lambda_0 * w\n        \n        # Calculate p-value: P(X >= k) = 1 - P(X <= k-1). \n        # This is the survival function (sf).\n        # We use k-1 because sf(k, mu) calculates P(X > k). So sf(k-1, mu) is P(X > k-1) = P(X >= k).\n        # For k=0, k-1=-1. scipy.stats.poisson.sf handle this correctly and return 1.0.\n        p_values = poisson.sf(window_counts - 1, mu)\n        \n        # Step 3: Apply Benjamini-Hochberg procedure\n        num_tests = len(p_values)\n        significant_windows = []\n\n        if num_tests > 0:\n            # Get original indices sorted by p-value\n            sorted_indices = np.argsort(p_values)\n            sorted_p_values = p_values[sorted_indices]\n            \n            # Calculate BH thresholds\n            ranks = np.arange(1, num_tests + 1)\n            bh_thresholds = (ranks / num_tests) * q\n            \n            # Find p-values that are below the BH threshold\n            significant_mask = sorted_p_values <= bh_thresholds\n            \n            if np.any(significant_mask):\n                # Find the largest rank k for which p_(k) <= (k/m)*q\n                max_significant_rank_idx = np.where(significant_mask)[0][-1]\n                \n                # All hypotheses up to this rank are rejected\n                significant_original_indices = sorted_indices[:max_significant_rank_idx + 1]\n                \n                # Get the window start coordinates for the significant windows\n                significant_starts = window_starts[significant_original_indices]\n                significant_windows = sorted(significant_starts.tolist())\n\n        results.append(significant_windows)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list is what's needed for the inner elements.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397925"}, {"introduction": "当我们获得了不同组蛋白修饰的峰列表后，就可以进行整合分析，以揭示复杂的调控模式。一个典型的例子是“二价启动子”，它同时被激活型修饰H3K4me3和抑制型修饰H3K27me3所标记，是发育生物学中的关键调控元件。这项练习将展示整合分析的力量[@problem_id:2397930]，通过结合两个不同实验的峰数据，你将能够识别出这种具有重要生物学意义的特征，并初步理解多层表观遗传信息如何协同作用以调控基因表达。", "problem": "给定两种组蛋白修饰——组蛋白H3赖氨酸4三甲基化 (H3K4me3) 和组蛋白H3赖氨酸27三甲基化 (H3K27me3)——的染色质免疫沉淀后测序 (ChIP-seq) peak检出结果的抽象表示，以及单条染色体上的一系列启动子区间。每个区间在以碱基对为单位的整数坐标轴上表示为一个半开区间 $[s,e)$，其中 $s$ 和 $e$ 是整数且 $s &lt; e$。区间 $[s,e)$ 的长度为 $e - s$ 碱基对。两个区间之间的重叠长度定义为它们共享的整数位置的数量；根据半开区间的约定，如果两个区间仅在边界点接触（例如 $[100,200)$ 和 $[200,300)$），它们的重叠长度为 $0$。\n\n一个启动子被定义为双价的，当且仅当存在至少一个H3K4me3 peak，其与该启动子的重叠长度大于或等于给定的阈值 $t_{4}$（单位为碱基对），并且存在至少一个H3K27me3 peak，其与该启动子的重叠长度大于或等于给定的阈值 $t_{27}$（单位为碱基对）。重叠标准独立地应用于每个peak；对于给定的修饰，不要合并或累加来自多个peak的重叠长度。如果某一修饰的peak列表为空，则没有启动子能满足该修饰的存在性条件。\n\n对于下方的每个测试用例，您必须计算双价启动子的数量。所有坐标均为以碱基对为单位的整数，所有阈值 $t_{4}$ 和 $t_{27}$ 均为以碱基对为单位的非负整数。所有结果都以整数计数表示。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[a,b,c]$），列表中的每个条目按所列顺序对应相应测试用例的双价启动子数量。\n\n测试套件：\n\n- 测试用例 $1$（一般情况）：\n  - 启动子 (ID, $[s,e)$)：$(1,[1000,1500))$, $(2,[2000,2300))$, $(3,[3000,3300))$。\n  - H3K4me3 peaks $[s,e)$：$[1100,1400)$, $[1950,2100)$, $[3100,3120)$, $[5000,5100)$。\n  - H3K27me3 peaks $[s,e)$：$[1200,1600)$, $[2250,2350)$, $[3150,3290)$。\n  - 阈值：$t_{4} = 100$, $t_{27} = 100$。\n- 测试用例 $2$（边界接触和最小正重叠）：\n  - 启动子 (ID, $[s,e)$)：$(1,[100,200))$, $(2,[400,500))$, $(3,[700,800))$。\n  - H3K4me3 peaks $[s,e)$：$[200,300)$, $[350,400)$, $[700,701)$。\n  - H3K27me3 peaks $[s,e)$：$[50,100)$, $[500,600)$, $[799,900)$。\n  - 阈值：$t_{4} = 1$, $t_{27} = 1$。\n- 测试用例 $3$（每种修饰有多个peak，各peak的阈值不累加）：\n  - 启动子 (ID, $[s,e)$)：$(1,[1000,1100))$, $(2,[2000,2100))$, $(3,[3000,3100))$。\n  - H3K4me3 peaks $[s,e)$：$[950,980)$, $[1070,1120)$, $[1990,2060)$, $[2900,3000)$, $[3000,3050)$。\n  - H3K27me3 peaks $[s,e)$：$[1005,1050)$, $[2090,2150)$, $[2050,2105)$, $[3050,3100)$。\n  - 阈值：$t_{4} = 50$, $t_{27} = 50$。\n- 测试用例 $4$（peak列表为空的边界情况）：\n  - 启动子 (ID, $[s,e)$)：$(1,[100,200))$, $(2,[300,400))$。\n  - H3K4me3 peaks $[s,e)$：空列表。\n  - H3K27me3 peaks $[s,e)$：$[500,600)$。\n  - 阈值：$t_{4} = 0$, $t_{27} = 0$。\n- 测试用例 $5$（当peak存在时，零阈值允许非重叠）：\n  - 启动子 (ID, $[s,e)$)：$(1,[100,200))$。\n  - H3K4me3 peaks $[s,e)$：$[0,50)$。\n  - H3K27me3 peaks $[s,e)$：$[500,600)$。\n  - 阈值：$t_{4} = 0$, $t_{27} = 0$。\n\n您的程序必须对每个测试用例，根据所述规则和阈值，确定性地计算满足双价定义的启动子ID的整数数量，然后按顺序输出一个与五个测试用例相对应的精确格式的单行结果 $[a,b,c,d,e]$。", "solution": "问题陈述已经过严格验证，被认为是有效的。它以计算基因组学原理为科学基础，在数学上是适定的，并使用客观、无歧义的语言表述。确定性求解所需的所有数据和定义均已提供。\n\n问题的核心是根据一系列涉及基因组区间重叠的精确标准，识别并计数“双价启动子”。一个启动子被定义为双价的，如果它同时满足两个独立的条件：一个与组蛋白修饰H3K4me3有关，另一个与H3K27me3有关。\n\n设一个启动子区间表示为 $P = [s_p, e_p)$，一个（任意修饰的）peak区间表示为 $K = [s_k, e_k)$。这两个半开区间之间的重叠长度 $L_{overlap}$ 是它们交集的长度，计算公式如下：\n$$L_{overlap}(P, K) = \\max(0, \\min(e_p, e_k) - \\max(s_p, s_k))$$\n该公式正确计算了两个区间共享的整数位置的数量。使用 $\\max(0, \\dots)$ 确保了不重叠的区间的重叠长度为 $0$。\n\n根据所提供的定义，一个启动子 $P$ 是双价的，当且仅当以下两个逻辑条件都得到满足：\n$1.$ 存在至少一个来自所提供的H3K4me3 peak列表的peak $K_4$，其与启动子 $P$ 的重叠长度大于或等于指定的阈值 $t_4$。形式上：\n$$\\exists K_4 \\in \\{\\text{H3K4me3 peaks}\\} \\text{ such that } L_{overlap}(P, K_4) \\ge t_4$$\n$2.$ 存在至少一个来自所提供的H3K27me3 peak列表的peak $K_{27}$，其与启动子 $P$ 的重叠长度大于或等于指定的阈值 $t_{27}$。形式上：\n$$\\exists K_{27} \\in \\{\\text{H3K27me3 peaks}\\} \\text{ such that } L_{overlap}(P, K_{27}) \\ge t_{27}$$\n\n问题明确指出，这些条件是针对每个peak独立评估的。来自同一修饰的多个peak的重叠长度不应被累加。\n\n解决此问题的算法是该定义的直接实现：首先，我们将一个双价启动子计数器初始化为 $0$。然后，我们遍历给定列表中的每个启动子。对于每个启动子，我们必须验证这两个存在性条件。\n\n为验证给定启动子的H3K4me3条件，我们首先检查H3K4me3 peak列表是否为空。如果为空，则存在性条件无法满足，该启动子不可能是双价的。如果列表不为空，我们遍历每个H3K4me3 peak，计算其与启动子的重叠长度，并将其与阈值 $t_4$ 进行比较。如果我们找到任何满足条件 $L_{overlap} \\ge t_4$ 的peak，则该启动子的H3K4me3条件即告满足，我们可以立即停止检查此启动子的其他H3K4me3 peak。\n\n如果H3K4me3条件得到满足，我们以类似的方式继续验证H3K27me3条件。我们检查H3K27me3 peak列表是否为空。如果不为空，我们遍历这些peak，计算它们与启动子的重叠，直到找到一个满足 $L_{overlap} \\ge t_{27}$ 的peak。如果找到这样的peak，则H3K27me3条件也得到满足。\n\n一个启动子当且仅当H3K4me3和H3K27me3两个条件都成功验证时，才被计为双价。对所有启动子重复此过程，计数器的最终值即为该测试用例的结果。\n\n当阈值为零时会出现一种特殊情况，例如 $t_4 = 0$。由于重叠长度 $L_{overlap}$ 根据定义始终为非负值 ($L_{overlap} \\ge 0$)，因此对于任何一对区间，条件 $L_{overlap} \\ge 0$ 始终为真。因此，对于 $0$ 阈值，当且仅当其对应的peak列表不为空时，该修饰的存在性条件才算满足。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bivalent promoter counting problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"promoters\": [(1000, 1500), (2000, 2300), (3000, 3300)],\n            \"h3k4me3_peaks\": [(1100, 1400), (1950, 2100), (3100, 3120), (5000, 5100)],\n            \"h3k27me3_peaks\": [(1200, 1600), (2250, 2350), (3150, 3290)],\n            \"t4\": 100,\n            \"t27\": 100,\n        },\n        # Test case 2 (boundary-touching and minimal positive overlaps)\n        {\n            \"promoters\": [(100, 200), (400, 500), (700, 800)],\n            \"h3k4me3_peaks\": [(200, 300), (350, 400), (700, 701)],\n            \"h3k27me3_peaks\": [(50, 100), (500, 600), (799, 900)],\n            \"t4\": 1,\n            \"t27\": 1,\n        },\n        # Test case 3 (multiple peaks per modification, per-peak thresholds not summed)\n        {\n            \"promoters\": [(1000, 1100), (2000, 2100), (3000, 3100)],\n            \"h3k4me3_peaks\": [(950, 980), (1070, 1120), (1990, 2060), (2900, 3000), (3000, 3050)],\n            \"h3k27me3_peaks\": [(1005, 1050), (2090, 2150), (2050, 2105), (3050, 3100)],\n            \"t4\": 50,\n            \"t27\": 50,\n        },\n        # Test case 4 (empty peak list edge case)\n        {\n            \"promoters\": [(100, 200), (300, 400)],\n            \"h3k4me3_peaks\": [],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n        # Test case 5 (zero thresholds admit non-overlaps when peaks exist)\n        {\n            \"promoters\": [(100, 200)],\n            \"h3k4me3_peaks\": [(0, 50)],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n    ]\n\n    def calculate_overlap(interval1, interval2):\n        \"\"\"\n        Calculates the overlap length between two half-open intervals [s, e).\n        \n        Args:\n            interval1 (tuple): A tuple (start, end) for the first interval.\n            interval2 (tuple): A tuple (start, end) for the second interval.\n            \n        Returns:\n            int: The non-negative integer overlap length.\n        \"\"\"\n        s1, e1 = interval1\n        s2, e2 = interval2\n        \n        overlap_start = max(s1, s2)\n        overlap_end = min(e1, e2)\n        \n        return max(0, overlap_end - overlap_start)\n\n    def analyze_case(promoters, h3k4me3_peaks, h3k27me3_peaks, t4, t27):\n        \"\"\"\n        Counts the number of bivalent promoters for a single test case.\n        \"\"\"\n        bivalent_promoter_count = 0\n\n        for p_interval in promoters:\n            # Check for H3K4me3 mark\n            has_h3k4me3_mark = False\n            if h3k4me3_peaks:\n                for k4_peak in h3k4me3_peaks:\n                    if calculate_overlap(p_interval, k4_peak) >= t4:\n                        has_h3k4me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n            \n            # If K4 condition fails, the promoter cannot be bivalent. Continue to next promoter.\n            if not has_h3k4me3_mark:\n                continue\n\n            # Check for H3K27me3 mark\n            has_h3k27me3_mark = False\n            if h3k27me3_peaks:\n                for k27_peak in h3k27me3_peaks:\n                    if calculate_overlap(p_interval, k27_peak) >= t27:\n                        has_h3k27me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n\n            # If both conditions are met, increment the counter\n            if has_h3k4me3_mark and has_h3k27me3_mark:\n                bivalent_promoter_count += 1\n                \n        return bivalent_promoter_count\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(\n            case[\"promoters\"],\n            case[\"h3k4me3_peaks\"],\n            case[\"h3k27me3_peaks\"],\n            case[\"t4\"],\n            case[\"t27\"]\n        )\n        results.append(result)\n\n    # Final output must be a single line in the specified format [a,b,c,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397930"}]}