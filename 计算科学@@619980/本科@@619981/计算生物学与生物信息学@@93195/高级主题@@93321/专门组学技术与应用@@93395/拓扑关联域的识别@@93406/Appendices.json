{"hands_on_practices": [{"introduction": "在我们分析数据之前，必须先了解数据是如何产生的。Hi-C实验依赖限制性内切酶来切割DNA，而酶的选择直接决定了我们最终接触图谱的理论分辨率。这个练习 [@problem_id:2437228] 将引导你像实验科学家一样思考，权衡更高分辨率与测序成本之间的利弊，从而做出明智的实验设计决策。", "problem": "一个实验室计划在同一种哺乳动物细胞系上进行两次原位高通量染色体构象捕获 (Hi-C) 实验，以识别拓扑关联结构域 (TAD) 的边界。在实验 X 中，他们使用一种能识别 $k=4$ 个核苷酸位点的限制性内切酶（一种“4碱基切割酶”）；在实验 Y 中，他们使用一种能识别 $k=6$ 个核苷酸位点的限制性内切酶（一种“6碱基切割酶”）。两次实验都使用相同的文库制备方案、相同数量的唯一比对上的读对（$N = 5 \\times 10^8$ 次接触）以及相当的重复率。基因组大小约为 $G = 3 \\times 10^9$ 碱基对 (bp)。该研究小组将使用一种绝缘分数法来识别TAD边界，该方法在对称窗口内聚合接触，并寻找局部绝缘信号的极小值。\n\n请从核酸序列统计学和Hi-C接触采样的基本原理出发，论述限制性内切酶的选择如何影响TAD边界定位可达到的分辨率和准确性。作为初步近似，假设碱基是独立同分布的，每个核苷酸出现的概率相等；识别位点之间的期望间距与其出现概率成反比；边界检测需要在每个基因组区间内有足够的接触密度。以下哪个/哪些陈述最为准确？\n\nA. 使用4碱基切割酶提高了边界定位的潜在精度，因为平均限制性片段长度更短，从而在边界附近产生更密集的接触采样；然而，与6碱基切割酶相比，要实现更精细的区间识别而不产生过多噪音，需要更高的每碱基对测序深度。\n\nB. 使用6碱基切割酶提高了边界分辨率，因为更长的片段能更有效地跨越边界，即使在相同的测序深度下也能产生更尖锐的绝缘分数极小值。\n\nC. 限制性内切酶的选择对边界分辨率没有实际影响，因为TAD是在兆碱基尺度上定义的，对限制性片段的大小不敏感。\n\nD. 在相同的测序深度下，6碱基切割酶通常会比4碱基切割酶在基因组上产生更均一的覆盖度，因此能得到更准确的边界位置。\n\nE. 如果边界附近的识别位点稀疏，6碱基切割酶可能会错过狭窄的边界特征，导致识别出的边界位置偏向最近的可用限制性位点，与4碱基切割酶相比，这实际上拓宽了边界的估计范围。\n\n选择所有适用的选项。", "solution": "问题陈述具有科学依据，提法得当，并包含足够的信息以进行严谨的分析。它描述了染色体构象捕获领域一个标准的实验设计选择，并就其后果提出了一个有效的问题。所提供的参数和假设对于基于第一性原理的评估是合理的。因此，该问题是有效的，并将推导出解决方案。\n\n问题的核心是比较使用识别 $k=4$ 核苷酸位点的限制性内切酶（“4碱基切割酶”）的高通量染色体构象捕获（Hi-C）实验与使用识别 $k=6$ 位点的酶（“6碱基切割酶”）的实验。\n\n根据序列统计学的基本原理，假设序列是独立同分布（i.i.d.）的，且各核苷酸出现的概率相等（$P(A) = P(C) = P(G) = P(T) = 1/4$），那么找到一个特定的 $k$-mer 识别位点的概率 $P_k$ 为：\n$$P_k = \\left(\\frac{1}{4}\\right)^k$$\n位点之间的期望距离，即平均限制性片段长度 $L_k$，是该概率的倒数。\n\n对于实验 X（“4碱基切割酶”）：\n$$k = 4$$\n$$P_4 = \\left(\\frac{1}{4}\\right)^4 = \\frac{1}{256}$$\n$$L_4 = \\frac{1}{P_4} = 256 \\text{ bp}$$\n\n对于实验 Y（“6碱基切割酶”）：\n$$k = 6$$\n$$P_6 = \\left(\\frac{1}{4}\\right)^6 = \\frac{1}{4096}$$\n$$L_6 = \\frac{1}{P_6} = 4096 \\text{ bp}$$\n\n在大小为 $G \\approx 3 \\times 10^9$ bp的基因组中，限制性位点的数量约为 $G/L_k$。\n-   对于“4碱基切割酶”： $N_{sites,4} \\approx (3 \\times 10^9) / 256 \\approx 1.17 \\times 10^7$ 个位点。\n-   对于“6碱基切割酶”： $N_{sites,6} \\approx (3 \\times 10^9) / 4096 \\approx 7.3 \\times 10^5$ 个位点。\n\n评估这些实验的基本原则如下：\n1.  **分辨率极限**：Hi-C实验的最终空间分辨率受限于限制性位点的密度。接触是在两个片段之间检测到的。因此，接触的位置只能解析到所涉片段的水平。较短的片段可以更精确地定位相互作用的端点。\n2.  **采样密度**：两次实验具有相同总数的读对，$N = 5 \\times 10^8$。这些读对分布在所有可能的限制性片段对之间。“4碱基切割酶”实验产生数量多得多的片段，这意味着这 $N$ 个读对是从一个大得多的潜在相互作用池中采样的。\n3.  **覆盖均一性**：来自“4碱基切割酶”的更密集的限制性位点集提供了更均一的全基因组覆盖。而来自“6碱基切割酶”的稀疏位点集可能导致大的基因组区域没有酶切位点，从而产生“盲点”和非均一的覆盖。\n4.  **信噪比**：对于固定的基因组区间大小，每个区间内的读数是一个关键因素。要实现高分辨率，必须使用小的区间。在总读数 $N$ 固定的情况下，较小的区间将包含较少的读数，从而增加了统计噪音。\n\n基于这些原则，我们评估每个陈述。\n\n**A. 使用4碱基切割酶提高了边界定位的潜在精度，因为平均限制性片段长度更短，从而在边界附近产生更密集的接触采样；然而，与6碱基切割酶相比，要实现更精细的区间识别而不产生过多噪音，需要更高的每碱基对测序深度。**\n-   陈述的第一部分是正确的，即“4碱基切割酶”因其片段更短（$L_4 \\approx 256$ bp）而提高了潜在精度。较短的片段在映射相互作用位置时充当了更精细的“标尺”。从字面意义上讲，这产生了更密集的采样：相互作用的潜在锚点彼此更近。\n-   第二部分讨论了其中的权衡关系。为了利用这种更高的潜在精度，必须使用更小的基因组区间来分析数据。在总读数 $N$ 固定的情况下，更小的区间意味着每个区间的计数更少，这会降低信噪比。为了在这些更精细的区间中填充统计上显著数量的接触，将需要成比例增加的总读数（即更高的测序深度）。这是基于测序的基因组学分析中一个典型的分辨率与深度的权衡。\n-   结论：**正确**。\n\n**B. 使用6碱基切割酶提高了边界分辨率，因为更长的片段能更有效地跨越边界，即使在相同的测序深度下也能产生更尖锐的绝缘分数极小值。**\n-   该陈述声称“6碱基切割酶”*提高*了分辨率。这在根本上是错误的。分辨率与可解析的最小特征的大小成反比。“6碱基切割酶”产生的较大片段（$L_6 \\approx 4096$ bp）提供了对基因组更粗粒度的视图，因此与“4碱基切割酶”相比，其理论分辨率是*降低*的。\n-   “更长的片段能更有效地跨越边界”这一推理是具有误导性的。绝缘分数的目的是检测*跨越*边界的相互作用的减少。单个片段可能跨越边界这一事实是模糊性的来源，而不是一个终止于该片段的性质，因此会模糊边界的表观位置。\n-   因此，“6碱基切割酶”会产生*更宽*而非更尖锐的绝缘分数极小值，因为信号是在更长的片段长度上平均的。\n-   结论：**错误**。\n\n**C. 限制性内切酶的选择对边界分辨率没有实际影响，因为TAD是在兆碱基尺度上定义的，对限制性片段的大小不敏感。**\n-   尽管拓扑关联结构域（TADs）是大型结构，通常在数百千碱基到兆碱基的范围内，但它们的边界通常是尖锐、清晰界定的区域。对这些边界的精确定位是一个关键目标，并且已知与特定的基因组元件（如 CTCF 结合位点）相关。\n-   “4碱基切割酶”（$256$ bp）和“6碱基切割酶”（$4096$ bp）之间的平均片段长度差异达一个数量级。当试图精确定位一个可能只有几千碱基宽的边界区域时，这种差异是高度相关的。因此，酶的选择对边界定位的精度有显著的实际影响。\n-   结论：**错误**。\n\n**D. 在相同的测序深度下，6碱基切割酶通常会比4碱基切割酶在基因组上产生更均一的覆盖度，因此能得到更准确的边界位置。**\n-   该陈述声称“6碱基切割酶”提供更均一的覆盖。这与实际情况恰恰相反。“4碱基切割酶”的位点大约每 $256$ bp 出现一次，而“6碱基切割酶”的位点每 $4096$ bp 出现一次。“6碱基切割酶”位点更稀疏的分布意味着存在不含任何限制性位点的大段基因组区域的概率要高得多。这导致了空隙和高度不均一的覆盖。“4碱基切割酶”提供了对基因组更均匀得多的采样。\n-   由于更均一覆盖的前提是错误的，因此其关于边界位置更准确的结论是没有依据且不正确的。有偏倚的、不均一的覆盖会导致结果的准确性降低，而非提高。\n-   结论：**错误**。\n\n**E. 如果边界附近的识别位点稀疏，6碱基切割酶可能会错过狭窄的边界特征，导致识别出的边界位置偏向最近的可用限制性位点，与4碱基切割酶相比，这实际上拓宽了边界的估计范围。**\n-   该陈述正确地指出了使用切割频率低的酶的一个关键问题。如果一个真实的生物学边界位于远离任何“6碱基切割酶”识别位点的区域，Hi-C实验将根本无法检测到精确起源于该边界的相互作用。\n-   被检测到的相互作用将被锚定在边界两侧最近的可用限制性位点上。例如，如果这些位点相距 $5$ kb，那么绝缘分数的极小值将反映的是这些相距较远的片段之间的相互作用下降，而不是在真实边界处的下降。这会导致识别出的边界位置发生错位，并将信号弥散到可用位点之间的整个区域。\n-   而“4碱基切割酶”由于其位点密集，更有可能在非常靠近真实边界的地方拥有位点，从而允许更准确、更精确（即更窄）的边界识别。\n-   结论：**正确**。", "answer": "$$\\boxed{AE}$$", "id": "2437228"}, {"introduction": "拥有接触图谱后，我们需要一个形式化的方法来识别TAD。像隐马尔可夫模型（HMM）这样的概率模型为此提供了一个强大的框架，它能将基因组模拟为一系列产生可观测数据（如绝缘分数）的隐藏状态（例如“结构域”或“边界”）。这个编程练习 [@problem_id:2437210] 将让你亲手实现Viterbi算法来解码一个简化的TAD识别HMM，从而在实践中掌握一个核心的生物信息学算法，并加深对如何用概率模型表示生物学特征的理解。", "problem": "给定一个形式化概率模型，用于将染色体一维分割为与拓扑关联结构域（TADs）相关的区域。该模型是一个隐马尔可夫模型（HMM），具有三个代表片段类型的隐藏状态：结构域、边界和结构域间区。设位置 $t$ 处的隐藏状态为 $z_t \\in \\{0,1,2\\}$，其中映射关系为：结构域 $\\rightarrow$ $0$，边界 $\\rightarrow$ $1$，结构域间区 $\\rightarrow$ $2$。设位置 $t$ 处的观测数据为单个实数 $x_t \\in \\mathbb{R}$，表示从染色体接触矩阵中派生出的归一化汇总统计量；该统计量是无量纲的，没有物理单位。该HMM由以下几个部分定义：\n\n- 在状态 $\\{0,1,2\\}$ 上的初始状态分布 $\\boldsymbol{\\pi}$：\n  - $\\pi_0 = 0.6$\n  - $\\pi_1 = 0.1$\n  - $\\pi_2 = 0.3$\n\n- 状态转移概率矩阵 $\\mathbf{A}$，其中 $A_{ij} = \\Pr(z_t=j \\mid z_{t-1}=i)$，对于 $i,j \\in \\{0,1,2\\}$：\n  - 从状态 $0$：$A_{00} = 0.80$, $A_{01} = 0.10$, $A_{02} = 0.10$\n  - 从状态 $1$：$A_{10} = 0.45$, $A_{11} = 0.10$, $A_{12} = 0.45$\n  - 从状态 $2$：$A_{20} = 0.10$, $A_{21} = 0.10$, $A_{22} = 0.80$\n\n- 发射分布：对于每个状态 $s \\in \\{0,1,2\\}$，观测值 $x_t$ 根据均值为 $\\mu_s$、方差为 $\\sigma_s^2$ 的单变量正态（高斯）分布生成，在给定 $z_t$ 的条件下，各 $t$ 之间相互独立：\n  - 对于状态 $0$（结构域）：$\\mu_0 = 0.8$, $\\sigma_0^2 = 0.25$\n  - 对于状态 $1$（边界）：$\\mu_1 = 2.0$, $\\sigma_1^2 = 0.25$\n  - 对于状态 $2$（结构域间区）：$\\mu_2 = 0.0$, $\\sigma_2^2 = 0.25$\n\n给定一个观测序列 $\\mathbf{x} = (x_1, x_2, \\dots, x_T)$，目标是找到状态序列 $\\mathbf{z}^\\star = (z_1, z_2, \\dots, z_T)$，使其在指定的HMM下最大化联合概率 $\\Pr(\\mathbf{z}, \\mathbf{x})$。如果多个状态序列达到相同的最大 $\\Pr(\\mathbf{z}, \\mathbf{x})$ 值，您必须通过在最大化过程中的每个位置 $t$ 选择达到最大值的最小状态索引（在 $\\{0,1,2\\}$ 中）来确定性地打破平局。\n\n您的任务是编写一个程序，对于下面的每个测试用例，返回最大化状态序列 $\\mathbf{z}^\\star$ 作为整数列表，使用状态索引映射：结构域 $\\rightarrow$ $0$，边界 $\\rightarrow$ $1$，结构域间区 $\\rightarrow$ $2$。\n\n测试套件（每个测试用例都是一个实值观测值列表，无量纲）：\n\n- 测试用例 $1$：$\\left[0.9,\\, 0.7,\\, 0.8,\\, 1.9,\\, 2.2,\\, 0.2,\\, 0.1,\\, 0.0\\right]$\n- 测试用例 $2$：$\\left[2.1\\right]$\n- 测试用例 $3$：$\\left[0.1,\\, 0.0,\\, 0.9,\\, 0.8,\\, 0.7,\\, 0.2\\right]$\n- 测试用例 $4$：$\\left[0.75,\\, 0.85,\\, 0.95,\\, 0.05,\\, -0.1,\\, 0.0,\\, 1.8,\\, 2.1,\\, 1.9,\\, 0.6\\right]$\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，并用方括号括起来。其中每个元素是对应测试用例的推断状态索引列表，顺序与上面列出的一致。例如，打印的行应类似于“[[a1,a2,...],[b1,...],[c1,...],[d1,...]]”，其中每个符号都是 $\\{0,1,2\\}$ 中的整数。\n\n每个测试用例的答案必须是一个整数列表。不涉及物理单位，除了标准的整数表示外，不需要进行四舍五入。", "solution": "在尝试给出解决方案之前，将根据所需标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n问题为用于染色体分割的隐马尔可夫模型（HMM）提供了完整的规范。明确的给定信息如下：\n-   **隐藏状态**：一组三个隐藏状态，$z_t \\in \\{0, 1, 2\\}$，对应于片段类型：结构域（$0$）、边界（$1$）和结构域间区（$2$）。\n-   **观测值**：一系列无量纲的实值标量 $x_t \\in \\mathbb{R}$。\n-   **初始状态分布 $\\boldsymbol{\\pi}$**：一个定义第一个状态概率的向量，$\\Pr(z_1=i) = \\pi_i$。\n    -   $\\pi_0 = 0.6$\n    -   $\\pi_1 = 0.1$\n    -   $\\pi_2 = 0.3$\n-   **状态转移概率矩阵 $\\mathbf{A}$**：一个矩阵，其中 $A_{ij} = \\Pr(z_t=j \\mid z_{t-1}=i)$。\n    -   $A_{0,*} = [0.80, 0.10, 0.10]$\n    -   $A_{1,*} = [0.45, 0.10, 0.45]$\n    -   $A_{2,*} = [0.10, 0.10, 0.80]$\n-   **发射分布**：对于每个状态 $s \\in \\{0, 1, 2\\}$，观测值 $x_t$ 从正态分布 $\\mathcal{N}(\\mu_s, \\sigma_s^2)$ 中抽取。\n    -   状态 $0$（结构域）：$\\mu_0 = 0.8$, $\\sigma_0^2 = 0.25$\n    -   状态 $1$（边界）：$\\mu_1 = 2.0$, $\\sigma_1^2 = 0.25$\n    -   状态 $2$（结构域间区）：$\\mu_2 = 0.0$, $\\sigma_2^2 = 0.25$\n-   **目标**：找到状态序列 $\\mathbf{z}^\\star = (z_1, z_2, \\dots, z_T)$，以最大化联合概率 $\\Pr(\\mathbf{z}, \\mathbf{x})$。\n-   **平局打破规则**：当最大值不唯一时，必须选择索引最小的状态（$0 < 1 < 2$）。\n-   **测试套件**：提供了四个特定的观测序列用于评估。\n-   **输出格式**：一个单行字符串，表示一个整数列表的列表，不含空格。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n根据验证标准对问题进行评估。\n-   **科学性**：该问题具有坚实的科学基础。隐马尔可夫模型是生物信息学中用于序列分析的强大标准工具，包括像TAD识别这样的表观遗传学和染色质结构研究。所提出的模型是此类系统的简化但概念上合理的表示。所有参数都是物理上合理的无量纲量或概率。\n-   **适定性**：该问题是适定的。它要求在完全指定的HMM下，给定一个观测序列，找出最可能的隐藏状态序列。这是计算统计学中的一个经典问题，保证存在唯一且稳定的解。明确的平局打破规则消除了任何歧义。\n-   **客观性**：该问题是客观的。它使用精确的数学语言和形式化定义，没有主观解释的余地。\n-   **缺陷清单**：该问题未表现出任何列出的缺陷。它科学合理、可形式化、完整、一致、现实且可通过算法验证。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。将提供一个严谨的解决方案。\n\n### 解决方案\n\n该问题要求在指定的隐马尔可夫模型中，给定一个观测序列 $\\mathbf{x} = (x_1, \\dots, x_T)$，找到最可能的隐藏状态序列 $\\mathbf{z}^\\star = (z_1, \\dots, z_T)$。这等同于找到最大化联合概率 $\\Pr(\\mathbf{z}, \\mathbf{x})$ 的序列 $\\mathbf{z}$。为避免数值下溢，标准做法是最大化该概率的对数：\n$$ \\mathbf{z}^\\star = \\arg\\max_{\\mathbf{z}} \\Pr(\\mathbf{z}, \\mathbf{x}) = \\arg\\max_{\\mathbf{z}} \\log \\Pr(\\mathbf{z}, \\mathbf{x}) $$\n特定路径 $\\mathbf{z}=(z_1, \\dots, z_T)$ 的联合对数概率由下式给出：\n$$ \\log \\Pr(\\mathbf{z}, \\mathbf{x}) = \\log \\pi_{z_1} + \\sum_{t=2}^{T} \\log A_{z_{t-1}, z_t} + \\sum_{t=1}^{T} \\log p(x_t | z_t) $$\n其中 $\\pi_{z_1}$ 是状态 $z_1$ 的初始概率，$A_{z_{t-1}, z_t}$ 是从状态 $z_{t-1}$ 到 $z_t$ 的转移概率，而 $p(x_t | z_t)$ 是在给定状态 $z_t$ 下观测到 $x_t$ 的发射概率。\n\n完成此任务的权威算法是**Viterbi算法**，这是一种动态规划方法。它通过迭代构建路径来高效地计算最可能的状态序列。我们定义 $v_t(j)$ 为在观测到 $(x_1, \\dots, x_t)$ 的情况下，任何以状态 $j$ 结尾的长度为 $t$ 的状态序列的最大对数概率。\n\n该算法分四步进行：\n\n**1. 初始化 ($t=1$)**\n对于每个状态 $j \\in \\{0, 1, 2\\}$，我们计算初始对数概率。这是初始概率的对数与第一个观测值 $x_1$ 的发射概率的对数之和。\n$$ v_1(j) = \\log \\pi_j + \\log p(x_1 | z_1=j) $$\n发射概率 $p(x|z=j)$ 服从正态分布 $\\mathcal{N}(\\mu_j, \\sigma_j^2)$。其对数概率密度函数为：\n$$ \\log p(x | z=j) = -\\frac{(x - \\mu_j)^2}{2\\sigma_j^2} - \\frac{1}{2}\\log(2\\pi\\sigma_j^2) $$\n\n**2. 递归 ($t=2, \\dots, T$)**\n对于每个后续时间步 $t$ 和每个状态 $j \\in \\{0, 1, 2\\}$，我们找到从上一步最有可能转移到状态 $j$ 的路径。对数概率 $v_t(j)$ 是截至时间 $t-1$ 的最佳路径的对数概率，加上转移概率的对数，再加上当前观测值 $x_t$ 的发射概率的对数。\n$$ v_t(j) = \\log p(x_t | z_t=j) + \\max_{i \\in \\{0,1,2\\}} \\left( v_{t-1}(i) + \\log A_{ij} \\right) $$\n为了之后能重建路径，我们还必须存储达到该最大值的状态 $i$。设其为 $\\text{ptr}_t(j)$：\n$$ \\text{ptr}_t(j) = \\arg\\max_{i \\in \\{0,1,2\\}} \\left( v_{t-1}(i) + \\log A_{ij} \\right) $$\n问题的平局打破规则（选择最小的状态索引）由标准的 `argmax` 函数处理，该函数返回最大值的第一个索引。\n\n**3. 终止**\n在计算完直至最终时间步 $T$ 的概率网格后，最终位置的最优状态 $z_T^\\star$ 是具有最高总对数概率的状态：\n$$ z_T^\\star = \\arg\\max_{j \\in \\{0,1,2\\}} v_T(j) $$\n同样，平局打破规则适用。\n\n**4. 路径回溯**\n最可能的状态序列 $\\mathbf{z}^\\star$ 通过从 $z_T^\\star$ 开始，使用存储的指针向后回溯来重建：\n$$ z_{t-1}^\\star = \\text{ptr}_t(z_t^\\star) \\quad \\text{for } t = T, T-1, \\dots, 2 $$\n此过程产生问题陈述所要求的唯一最优状态序列。实现将精确遵循此逻辑，对所有概率计算使用数值对数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the HMM decoding problem for the given test cases using the Viterbi algorithm.\n    \"\"\"\n    \n    # HMM parameters as specified in the problem\n    pi = np.array([0.6, 0.1, 0.3])\n    A = np.array([\n        [0.80, 0.10, 0.10],\n        [0.45, 0.10, 0.45],\n        [0.10, 0.10, 0.80]\n    ])\n    mus = np.array([0.8, 2.0, 0.0])\n    # The problem provides variance (sigma^2), scipy.stats.norm requires standard deviation (sigma)\n    sigmas_sq = np.array([0.25, 0.25, 0.25])\n    sigmas = np.sqrt(sigmas_sq)\n    \n    # Convert probabilities to log-space to prevent underflow and for numerical stability\n    log_pi = np.log(pi)\n    log_A = np.log(A)\n    \n    n_states = len(pi)\n\n    def viterbi(obs_seq):\n        \"\"\"\n        Implements the Viterbi algorithm to find the most likely state sequence.\n\n        Args:\n            obs_seq (list or np.ndarray): The sequence of observations.\n\n        Returns:\n            list: The most likely sequence of state indices.\n        \"\"\"\n        T = len(obs_seq)\n        if T == 0:\n            return []\n\n        # viterbi_trellis[t, j] stores the max log-prob of a path ending in state j at time t\n        viterbi_trellis = np.zeros((T, n_states))\n        # backpointers[t, j] stores the best previous state that leads to state j at time t\n        backpointers = np.zeros((T, n_states), dtype=int)\n\n        # 1. Initialization Step (t=0)\n        log_emissions_t0 = np.array([norm.logpdf(obs_seq[0], loc=mu, scale=sigma) \n                                     for mu, sigma in zip(mus, sigmas)])\n        viterbi_trellis[0, :] = log_pi + log_emissions_t0\n\n        # 2. Recursion Step (t=1 to T-1)\n        for t in range(1, T):\n            log_emissions_t = np.array([norm.logpdf(obs_seq[t], loc=mu, scale=sigma) \n                                        for mu, sigma in zip(mus, sigmas)])\n            \n            # Vectorized computation for all current states j\n            # scores[i, j] = viterbi_trellis[t-1, i] + log_A[i, j]\n            scores = viterbi_trellis[t-1, :].reshape(-1, 1) + log_A\n            \n            # For each current state j, find the best previous state i.\n            # np.argmax correctly implements the tie-breaking rule (smallest index first).\n            viterbi_trellis[t, :] = np.max(scores, axis=0) + log_emissions_t\n            backpointers[t, :] = np.argmax(scores, axis=0)\n        \n        # 3. Termination Step\n        # Find the best final state. np.argmax handles tie-breaking.\n        best_last_state = np.argmax(viterbi_trellis[T-1, :])\n\n        # 4. Backtracking Step\n        path = [best_last_state]\n        current_state = best_last_state\n        for t in range(T - 1, 0, -1):\n            current_state = backpointers[t, current_state]\n            path.insert(0, current_state)\n            \n        return path\n\n    test_cases = [\n        [0.9, 0.7, 0.8, 1.9, 2.2, 0.2, 0.1, 0.0],\n        [2.1],\n        [0.1, 0.0, 0.9, 0.8, 0.7, 0.2],\n        [0.75, 0.85, 0.95, 0.05, -0.1, 0.0, 1.8, 2.1, 1.9, 0.6]\n    ]\n\n    results = []\n    for case in test_cases:\n        result_path = viterbi(case)\n        results.append(result_path)\n\n    # Format the output string as specified: [[...],[...],...] with no spaces\n    outer_parts = []\n    for res_list in results:\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        outer_parts.append(inner_str)\n    final_output = '[' + ','.join(outer_parts) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2437210"}, {"introduction": "任何TAD识别算法都会输出一组预测的结构域。但是，即使在一个完全随机的基因组中，有多少这样的结构域会纯粹因为偶然性而出现呢？这个问题 [@problem_id:2437207] 探讨了统计显著性和多重检验的核心概念。通过计算在零假设下预期的假阳性数量，你将学会如何区分真实的生物学信号和统计噪声，这是解读任何大规模基因组分析结果都必须具备的关键技能。", "problem": "考虑一个来自高通量染色体构象捕获 (Hi-C) 的染色体片段，该片段已被分箱成一个接触矩阵，其中距离依赖性衰减已通过标准的观测值/期望值归一化方法移除，因此，在没有结构域结构的零假设下，与给定基因组距离一致的任何接触子集的期望值均为 1。一个拓扑关联结构域 (TAD) 识别程序在总共 $B=200$ 个 bin 内，评估每个长度介于 $L_{\\min}=5$ 和 $L_{\\max}=20$ (含) 之间的连续 bin 区间。对于每个候选区间，该识别程序都会执行一个有效的统计检验来检测区间内的接触富集情况，当零假设为真时，其 $p$ 值在 $[0,1]$ 上均匀分布。如果一个区间的 $p$ 值小于固定的单区间显著性阈值 $\\alpha=0.01$，该识别程序就将其声明为一个 TAD。\n\n假设该 Hi-C 矩阵是由一个完全随机的聚合物模型生成的，没有真实的结构域结构。在这些条件下，确定该识别程序将会声明为 TAD 的区间的期望数量。将您的答案四舍五入到四位有效数字。以纯数字（计数）形式报告您的答案，不带任何单位。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件\n-   该系统是一个由包含 $B = 200$ 个 bin 的 Hi-C 接触矩阵表示的染色体片段。\n-   该矩阵已经过归一化（观测值/期望值），因此在没有结构域结构的零假设下，接触的期望值为 1。\n-   一个 TAD 识别程序会评估所有长度为 $L$ (其中 $L_{\\min} \\le L \\le L_{\\max}$，$L_{\\min} = 5$，$L_{\\max} = 20$) 的连续 bin 区间。\n-   对每个候选区间进行一次统计检验，在零假设下，其 $p$ 值在区间 $[0,1]$ 上均匀分布。\n-   如果一个区间的 $p$ 值小于显著性阈值 $\\alpha = 0.01$，则该区间被声明为一个 TAD。\n-   假设该系统遵循一个没有真实结构域结构的随机聚合物模型，这意味着零假设对所有检验都成立。\n-   目标是求出被声明为 TAD 的区间的期望数量。\n-   最终答案应四舍五入到四位有效数字。\n\n步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题基于计算生物学和生物信息学中分析 Hi-C 数据的标准实践。Hi-C 接触矩阵、观测值/期望值归一化、拓扑关联结构域 (TAD)、p 值和零假设等概念都是基础性的，并且描述正确。在零假设下 p 值呈均匀分布的假设是一个有效统计检验的定义性属性。\n-   **适定性：** 这是一个适定问题。它提供了所有必要的参数（$B$、$L_{\\min}$、$L_{\\max}$、$\\alpha$）和一个明确的目标。问题清晰无歧义，并有一个唯一可计算的解。\n-   **客观性：** 问题以精确、客观的语言陈述，没有任何主观论断或含糊之处。\n\n步骤 3：结论与行动\n该问题有效，因为它具有科学性、适定性和客观性。将提供解答。\n\n任务是计算在全局零假设下，假阳性 TAD 发现的期望数量。该期望值是所执行的统计检验总数与单个检验显著的概率的乘积。\n\n首先，我们必须确定 TAD 识别程序评估的候选区间总数 $N$。该识别程序会检查范围 $[L_{\\min}, L_{\\max}]$ 内每个长度 $L$ 的所有连续区间。对于一个有 $B$ 个 bin 的染色体，给定长度 $L$ 的可能连续区间数量为 $B - L + 1$。\n检验的区间总数 $N$ 是从 $L_{\\min} = 5$ 到 $L_{\\max} = 20$ 的每个长度的区间数量之和。\n$$N = \\sum_{L=L_{\\min}}^{L_{\\max}} (B - L + 1)$$\n代入给定值 $B = 200$，$L_{\\min} = 5$ 和 $L_{\\max} = 20$：\n$$N = \\sum_{L=5}^{20} (200 - L + 1) = \\sum_{L=5}^{20} (201 - L)$$\n这是一个等差数列的和。求和中的项数是 $k = L_{\\max} - L_{\\min} + 1 = 20 - 5 + 1 = 16$。\n该数列的首项（当 $L=5$ 时）是 $a_1 = 201 - 5 = 196$。\n该数列的末项（当 $L=20$ 时）是 $a_k = 201 - 20 = 181$。\n等差数列的和由 $S_k = \\frac{k}{2}(a_1 + a_k)$ 给出。\n$$N = \\frac{16}{2} (196 + 181) = 8 \\cdot (377) = 3016$$\n因此，总共执行了 $N=3016$ 次统计检验。\n\n接下来，我们考虑单个检验导致 TAD 判定的概率。设随机变量 $P_i$ 表示第 $i$ 次检验的 $p$ 值，其中 $i \\in \\{1, 2, \\dots, N\\}$。问题陈述，在零假设下（假设对整个矩阵成立），$p$ 值在区间 $[0,1]$ 上均匀分布。\n$$P_i \\sim U(0,1)$$\n如果一个区间的 $p$ 值小于显著性阈值 $\\alpha = 0.01$，则该区间被声明为一个 TAD。对于单个检验，此事件的概率为：\n$$\\mathbb{P}(P_i < \\alpha) = \\int_0^\\alpha 1 \\,dx = \\alpha = 0.01$$\n这是单个检验犯第一类错误的概率。\n\n设 $X_i$ 为一个指示随机变量，表示第 $i$ 个区间是否被声明为 TAD。如果 $P_i < \\alpha$，则 $X_i = 1$，否则 $X_i = 0$。\n这个指示随机变量的期望值为：\n$$E[X_i] = 1 \\cdot \\mathbb{P}(X_i = 1) + 0 \\cdot \\mathbb{P}(X_i = 0) = \\mathbb{P}(P_i < \\alpha) = \\alpha$$\n被声明为 TAD 的区间总数是所有检验的这些指示随机变量之和：$Y = \\sum_{i=1}^{N} X_i$。\n我们需要求出被声明为 TAD 的期望数量，即 $E[Y]$。\n\n根据期望的线性性质，随机变量之和的期望等于它们各自期望之和。无论这些变量是否独立，此性质都成立。在这个问题中，重叠的区间会导致相关的检验统计量，但这不影响期望值的计算。\n$$E[Y] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i]$$\n由于对所有的 $i=1, \\dots, N$ 都有 $E[X_i] = \\alpha$：\n$$E[Y] = \\sum_{i=1}^{N} \\alpha = N \\cdot \\alpha$$\n代入计算出的 $N$ 值和给定的 $\\alpha$ 值：\n$$E[Y] = 3016 \\cdot 0.01 = 30.16$$\n问题要求答案四舍五入到四位有效数字。计算出的值 $30.16$ 已经包含四位有效数字。因此，无需进一步四舍五入。该值代表了将此 TAD 识别程序应用于一个零假设数据集时假阳性的期望数量。", "answer": "$$\\boxed{30.16}$$", "id": "2437207"}]}