{"hands_on_practices": [{"introduction": "在我们深入研究复杂的计算算法之前，首先理解矩阵平衡的核心数学原理至关重要。本练习将剥离大规模基因组矩阵和迭代算法的复杂性，让您通过手工求解一个简单的 $3 \\times 3$ 系统。通过这种方式，您将对归一化方法所要解决的非线性方程组建立具体直观的认识，并体会到为何唯一解并非总是显而易见的。[@problem_id:2397239]", "problem": "高通量染色体构象捕获 (Hi-C) 接触图谱是一个对称矩阵，其元素代表基因组位点之间的相互作用计数。一个常见的归一化目标是通过对角缩放来平衡接触矩阵，使得缩放后矩阵的所有行（并因此根据对称性，所有列）具有相同的和。考虑以下大小为 $3 \\times 3$ 的对称 Hi-C 接触子矩阵：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n1 & 1 & 0 \\\\\n1 & 2 & 1 \\\\\n0 & 1 & 1\n\\end{pmatrix}.\n$$\n设 $D = \\mathrm{diag}(x_1, x_2, x_3)$，其中 $x_1, x_2, x_3 \\in \\mathbb{R}_{>0}$，并定义缩放后的矩阵 $B = D A D$。确定唯一的正对角缩放因子 $x_1, x_2, x_3$，使得 $B$ 的每一行之和都等于 $1$，即：\n$$\n\\sum_{j=1}^{3} B_{ij} \\;=\\; 1 \\quad \\text{for each } i \\in \\{1,2,3\\}.\n$$\n请以单行矩阵 $\\begin{pmatrix} x_1 & x_2 & x_3 \\end{pmatrix}$ 的形式给出您的最终答案，答案需为精确形式（无近似，无四舍五入）。", "solution": "所述问题具有科学依据、是良定的且客观的。它描述了一种在计算生物学中用于分析 Hi-C 数据的标准矩阵平衡方法。所提供的矩阵是一个有效的、对称的、非负的、不可约的矩阵，已知其存在唯一的正对角缩放解。因此，该问题是有效的，我们可以继续进行求解。\n\n问题要求找到一个对角矩阵 $D = \\mathrm{diag}(x_1, x_2, x_3)$，其中 $x_1, x_2, x_3 > 0$，使得缩放后的矩阵 $B = DAD$ 的所有行和都等于 1。给定矩阵为\n$$\nA =\n\\begin{pmatrix}\n1 & 1 & 0 \\\\\n1 & 2 & 1 \\\\\n0 & 1 & 1\n\\end{pmatrix}\n$$\n缩放后的矩阵 $B$ 计算为 $B = DAD$。其元素 $B_{ij}$ 由公式 $B_{ij} = x_i A_{ij} x_j$ 给出。\n$$\nB =\n\\begin{pmatrix}\nx_1 & 0 & 0 \\\\\n0 & x_2 & 0 \\\\\n0 & 0 & x_3\n\\end{pmatrix}\n\\begin{pmatrix}\n1 & 1 & 0 \\\\\n1 & 2 & 1 \\\\\n0 & 1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 & 0 & 0 \\\\\n0 & x_2 & 0 \\\\\n0 & 0 & x_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\cdot x_1 x_1 & 1 \\cdot x_1 x_2 & 0 \\cdot x_1 x_3 \\\\\n1 \\cdot x_2 x_1 & 2 \\cdot x_2 x_2 & 1 \\cdot x_2 x_3 \\\\\n0 \\cdot x_3 x_1 & 1 \\cdot x_3 x_2 & 1 \\cdot x_3 x_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nx_1^2 & x_1 x_2 & 0 \\\\\nx_1 x_2 & 2x_2^2 & x_2 x_3 \\\\\n0 & x_2 x_3 & x_3^2\n\\end{pmatrix}\n$$\n$B$ 的所有行和都等于 1 的条件，即对 $i \\in \\{1, 2, 3\\}$ 都有 $\\sum_{j=1}^{3} B_{ij} = 1$，产生以下非线性方程组：\n$$\n\\begin{cases}\n    x_1^2 + x_1 x_2 = 1 & (1) \\\\\n    x_1 x_2 + 2x_2^2 + x_2 x_3 = 1 & (2) \\\\\n    x_2 x_3 + x_3^2 = 1 & (3)\n\\end{cases}\n$$\n我们必须解此方程组，求出正实数 $x_1, x_2, x_3$。\n从方程 $(1)$，我们可以提出因子 $x_1$：\n$$\nx_1(x_1 + x_2) = 1\n$$\n由于 $x_1 > 0$，我们可以表示为 $x_1 + x_2 = \\frac{1}{x_1}$，从而得到 $x_2 = \\frac{1}{x_1} - x_1 = \\frac{1-x_1^2}{x_1}$。\n为使 $x_2$ 为正，必须有 $1-x_1^2 > 0$，这意味着 $0 < x_1 < 1$。\n\n类似地，从方程 $(3)$，我们提出因子 $x_3$：\n$$\nx_3(x_2 + x_3) = 1\n$$\n由于 $x_3 > 0$，我们有 $x_2 + x_3 = \\frac{1}{x_3}$，从而得到 $x_2 = \\frac{1}{x_3} - x_3 = \\frac{1-x_3^2}{x_3}$。\n为使 $x_2$ 为正，必须有 $1-x_3^2 > 0$，这意味着 $0 < x_3 < 1$。\n\n通过令 $x_2$ 的两个表达式相等，我们得到了 $x_1$ 和 $x_3$ 之间的一个关键关系：\n$$\n\\frac{1}{x_1} - x_1 = \\frac{1}{x_3} - x_3\n$$\n$$\n\\frac{1}{x_1} - \\frac{1}{x_3} = x_1 - x_3\n$$\n$$\n\\frac{x_3 - x_1}{x_1 x_3} = -(x_3 - x_1)\n$$\n这个方程有两个可能的解。\n情况 1：$x_3 - x_1 = 0$，即 $x_1 = x_3$。\n情况 2：如果 $x_3 - x_1 \\neq 0$，我们可以将方程两边同除以 $(x_3 - x_1)$，得到 $\\frac{1}{x_1 x_3} = -1$，即 $x_1 x_3 = -1$。这是不可能的，因为问题指明 $x_1$ 和 $x_3$ 必须是正实数。\n因此，唯一有效的可能性是 $x_1 = x_3$。\n\n我们现在将 $x_3 = x_1$ 代入原方程组。方程 $(3)$ 变得与方程 $(1)$ 相同。方程 $(2)$ 简化为：\n$$\nx_1 x_2 + 2x_2^2 + x_2 x_1 = 1\n$$\n$$\n2x_1 x_2 + 2x_2^2 = 1\n$$\n$$\n2x_2(x_1 + x_2) = 1\n$$\n我们现在得到一个由两个方程组成的简化方程组：\n$$\n\\begin{cases}\n    x_1(x_1 + x_2) = 1 & (A) \\\\\n    2x_2(x_1 + x_2) = 1 & (B)\n\\end{cases}\n$$\n由于等号右边都等于 $1$，我们可以令等号左边相等：\n$$\nx_1(x_1 + x_2) = 2x_2(x_1 + x_2)\n$$\n由于 $x_1 > 0$ 且 $x_2 > 0$，项 $(x_1 + x_2)$ 严格为正。我们可以用它来除方程两边而不失一般性：\n$$\nx_1 = 2x_2\n$$\n现在将此关系代入方程 $(A)$：\n$$\n(2x_2)(2x_2 + x_2) = 1\n$$\n$$\n(2x_2)(3x_2) = 1\n$$\n$$\n6x_2^2 = 1\n$$\n$$\nx_2^2 = \\frac{1}{6}\n$$\n由于 $x_2 > 0$，我们取正平方根：\n$$\nx_2 = \\sqrt{\\frac{1}{6}} = \\frac{1}{\\sqrt{6}} = \\frac{\\sqrt{6}}{6}\n$$\n使用我们推导出的关系，我们求得 $x_1$ 和 $x_3$：\n$$\nx_1 = 2x_2 = 2 \\left( \\frac{\\sqrt{6}}{6} \\right) = \\frac{2\\sqrt{6}}{6} = \\frac{\\sqrt{6}}{3}\n$$\n并且由于 $x_3 = x_1$：\n$$\nx_3 = \\frac{\\sqrt{6}}{3}\n$$\n因此，唯一的正对角缩放因子是 $x_1 = \\frac{\\sqrt{6}}{3}$，$x_2 = \\frac{\\sqrt{6}}{6}$ 和 $x_3 = \\frac{\\sqrt{6}}{3}$。这些值满足约束条件和原方程组。最终答案必须以单行矩阵的形式呈现。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sqrt{6}}{3} & \\frac{\\sqrt{6}}{6} & \\frac{\\sqrt{6}}{3}\n\\end{pmatrix}\n}\n$$", "id": "2397239"}, {"introduction": "从解析解推演到更贴近现实的场景，我们需要为更大的矩阵编写迭代算法。本实践聚焦于 Hi-C 分析中的一个关键现实挑战：处理低质量或覆盖率不足的数据区域。您将亲手实现一个迭代平衡算法，并用它来量化排除不同基因组区域的选择对最终偏好校正结果的影响，从而学会评估分析流程的稳健性。[@problem_id:2397206]", "problem": "您的任务是评估在高通量染色体构象捕获 (Hi-C) 接触图谱的背景下，矩阵平衡对于初始排除行和列选择的敏感性。设 $A \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 是一个非负项的对称矩阵，表示 $n$ 个基因组区间之间的接触计数。对于一个初始排除集 $B \\subseteq \\{1,2,\\ldots,n\\}$，定义一个缩放向量 $x \\in \\mathbb{R}_{\\ge 0}^{n}$，使得对于所有 $i \\in B$ 有 $x_i = 0$，对于所有 $i \\notin B$ 有 $x_i > 0$。设平衡后的矩阵为 $N = \\mathrm{diag}(x) \\, A \\, \\mathrm{diag}(x)$。平衡条件要求对于每个 $i \\notin B$ 均满足：\n$$\n\\sum_{j \\notin B} N_{ij} = \\sum_{j \\notin B} x_i \\, A_{ij} \\, x_j = 1.\n$$\n假设对于下面提供的矩阵和指定的排除集，存在满足上述约束条件的唯一向量 $x$。\n\n对于同一矩阵 $A$，两个初始排除集 $B^{(1)}$ 和 $B^{(2)}$ 之间的敏感性定义为，在保留索引的交集上，相应缩放向量之间的平均绝对差。更精确地说，设 $x^{(1)}$ 和 $x^{(2)}$ 分别是从 $B^{(1)}$ 和 $B^{(2)}$ 获得的缩放向量，并设 $S = \\{ i \\mid i \\notin B^{(1)}, \\, i \\notin B^{(2)} \\}$。敏感性为\n$$\n\\Delta(A,B^{(1)},B^{(2)}) \\;=\\; \\frac{1}{|S|} \\sum_{i \\in S} \\left| x^{(1)}_i - x^{(2)}_i \\right|.\n$$\n您的程序必须为下面测试套件中的每个测试用例计算 $\\Delta(A,B^{(1)},B^{(2)})$。\n\n该测试套件包含两个具有近对角线富集的类 Hi-C 对称接触矩阵和五对排除集。索引是基于1的。矩阵如下：\n$$\nA^{(1)} \\;=\\; \\begin{bmatrix}\n10 & 6 & 3 & 1 & 0.5 \\\\\n6 & 9 & 5 & 2 & 1 \\\\\n3 & 5 & 8 & 4 & 2 \\\\\n1 & 2 & 4 & 7 & 3 \\\\\n0.5 & 1 & 2 & 3 & 6\n\\end{bmatrix},\n\\qquad\nA^{(2)} \\;=\\; \\begin{bmatrix}\n20 & 10 & 5 & 2 & 1 \\\\\n10 & 18 & 7 & 3 & 1.5 \\\\\n5 & 7 & 15 & 6 & 2 \\\\\n2 & 3 & 6 & 12 & 4 \\\\\n1 & 1.5 & 2 & 4 & 10\n\\end{bmatrix}.\n$$\n请为以下五种情况计算 $\\Delta(A,B^{(1)},B^{(2)})$：\n- 情况 1: $A = A^{(1)}$, $B^{(1)} = \\varnothing$, $B^{(2)} = \\varnothing$。\n- 情况 2: $A = A^{(1)}$, $B^{(1)} = \\varnothing$, $B^{(2)} = \\{5\\}$。\n- 情况 3: $A = A^{(1)}$, $B^{(1)} = \\{1\\}$, $B^{(2)} = \\{5\\}$。\n- 情况 4: $A = A^{(2)}$, $B^{(1)} = \\varnothing$, $B^{(2)} = \\{3\\}$。\n- 情况 5: $A = A^{(2)}$, $B^{(1)} = \\{2,4\\}$, $B^{(2)} = \\{2,5\\}$。\n\n您的程序必须生成单行输出，其中包含五个结果，形式为方括号括起来的逗号分隔列表，顺序与上述情况一致，每个值四舍五入到 $6$ 位小数，即 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是情况 $k$ 的 $\\Delta(A,B^{(1)},B^{(2)})$。不涉及物理单位。", "solution": "所提出的问题是计算生物学中一个明确定义的任务，具体涉及 Hi-C 接触图谱的归一化。在进行求解之前，需要对问题陈述进行验证。\n\n**问题验证**\n\n**步骤1：提取的已知条件**\n- 输入一个非负项的对称矩阵 $A \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$。\n- 一个基于1的索引的初始排除集 $B \\subseteq \\{1, 2, \\ldots, n\\}$。\n- 一个缩放向量 $x \\in \\mathbb{R}_{\\ge 0}^{n}$，其中对于 $i \\in B$ 有 $x_i = 0$，对于 $i \\notin B$ 有 $x_i > 0$。\n- 一个平衡后的矩阵 $N = \\mathrm{diag}(x) \\, A \\, \\mathrm{diag}(x)$。\n- 对每个 $i \\notin B$ 的平衡条件：$\\sum_{j \\notin B} N_{ij} = \\sum_{j \\notin B} x_i \\, A_{ij} \\, x_j = 1$。\n- 一个假设，即对于给定的矩阵和排除集，存在唯一的缩放向量 $x$。\n- 一个矩阵 $A$ 的两个排除集 $B^{(1)}$ 和 $B^{(2)}$ 之间的敏感性度量：$\\Delta(A,B^{(1)},B^{(2)}) = \\frac{1}{|S|} \\sum_{i \\in S} | x^{(1)}_i - x^{(2)}_i |$，其中 $x^{(1)}$ 和 $x^{(2)}$ 是 $B^{(1)}$ 和 $B^{(2)}$ 的缩放向量，且 $S = \\{ i \\mid i \\notin B^{(1)}, \\, i \\notin B^{(2)} \\}$。\n- 提供了两个特定矩阵 $A^{(1)}$ 和 $A^{(2)}$。\n- 给出了针对这些矩阵的五组指定排除集的测试用例。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了矩阵平衡，这是 Hi-C 数据分析中为消除实验偏差而采取的一个标准且关键的步骤。指定的平衡条件是 Knight-Ruiz (KR) 平衡法的一种形式，这是该领域一个成熟的算法。该公式具有科学合理性。\n- **良构性**：问题陈述断言了解向量 $x$ 的存在性和唯一性。对于与 Hi-C 数据相关的矩阵类别（非负、对称，且通常不可约），此性质成立。因此，该问题在数学上是良构的。\n- **客观和完整**：所有术语都以数学精度进行了定义。输入数据和测试用例已完全指定。该问题是客观且自足的。\n\n**步骤3：结论与行动**\n问题陈述被认为是有效的。它具有科学依据，在数学上是良构的，并且是完整的。现在将推导并实现一个解决方案。\n\n**解法推导**\n\n核心任务是为给定的对称矩阵 $A$ 和排除集 $B$ 确定缩放向量 $x$。令 $I = \\{1, 2, \\ldots, n\\} \\setminus B$ 表示保留索引的集合。平衡条件，限制在这些索引上，为：\n$$\nx_i \\sum_{j \\in I} A_{ij} x_j = 1 \\quad \\forall i \\in I.\n$$\n这构成了一个关于 $x$ 的正分量的非线性方程组。设 $y$ 是由 $i \\in I$ 的元素 $x_i$ 组成的向量，设 $A_I$ 是通过选择索引在 $I$ 中的行和列从 $A$ 中形成的子矩阵。该系统可以写为：\n$$\ny_k \\left( \\sum_{l} (A_I)_{kl} y_l \\right) = 1\n$$\n对于 $y$ 的每个分量 $y_k$。这种结构提示我们可以使用不动点迭代法。我们可以重新整理方程来定义一个映射 $F(y)$：\n$$\ny_k = \\frac{1}{\\sum_{l} (A_I)_{kl} y_l} \\equiv F(y)_k.\n$$\n解 $y$ 是该映射的一个不动点，即 $y = F(y)$。这引出以下迭代算法：\n1. 将保留索引的缩放向量 $y^{(0)}$ 初始化，所有元素均设为1。\n2. 对于每次迭代 $k = 0, 1, 2, \\ldots$，使用更新规则计算下一个近似值 $y^{(k+1)}$：\n   $$\n   y^{(k+1)} = F(y^{(k)}).\n   $$\n   按分量计算，即 $y_i^{(k+1)} = 1 / \\sum_{j} (A_I)_{ij} y_j^{(k)}$。\n3. 迭代持续进行，直到连续向量之间的变化可以忽略不计，例如，当差值的无穷范数 $\\|y^{(k+1)} - y^{(k)}\\|_\\infty$ 小于预设的容差 $\\epsilon$ 时。问题对唯一解的保证确保了此过程会收敛。\n\n计算敏感性 $\\Delta(A, B^{(1)}, B^{(2)})$ 的整体流程如下：\n1. 对于排除集 $B^{(1)}$，对矩阵 $A$ 应用迭代算法，找到对应的缩放向量 $x^{(1)}$。对于 $B^{(1)}$ 中的索引，$x^{(1)}$ 的分量为零。\n2. 对排除集 $B^{(2)}$ 重复此过程，找到向量 $x^{(2)}$。\n3. 识别公共保留索引集 $S = \\{ i \\mid i \\notin B^{(1)}, i \\notin B^{(2)} \\}$。\n4. 通过计算所有索引 $i \\in S$ 的绝对差 $|x^{(1)}_i - x^{(2)}_i|$ 的平均值来计算敏感性。\n\n该方法论是系统化且计算高效的。它将被用于实现以解决所提供的测试用例。问题陈述中使用的基于1的索引，在像使用 NumPy 的 Python 这样的编程环境中实现时，需要小心地转换为基于0的索引。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_scaling_vector(A, B_one_based, tol=1e-12, max_iter=2000):\n    \"\"\"\n    Computes the scaling vector x for a given matrix A and exclusion set B.\n    \n    The balancing condition is that for the submatrix of retained indices A_I,\n    diag(x_I) @ A_I @ x_I = 1 (vector of ones). This is solved iteratively.\n    \"\"\"\n    n = A.shape[0]\n    # Convert 1-based exclusion set to 0-based list of retained indices\n    I_zero_based = [i for i in range(n) if (i + 1) not in B_one_based]\n    \n    # If all indices are excluded, return a zero vector.\n    if not I_zero_based:\n        return np.zeros(n)\n        \n    # Extract the submatrix corresponding to retained indices.\n    A_sub = A[np.ix_(I_zero_based, I_zero_based)]\n    m = len(I_zero_based)\n    \n    # Initialize the scaling vector for the subproblem.\n    y = np.ones(m, dtype=float)\n    \n    # Iteratively solve for y using the fixed-point method.\n    for _ in range(max_iter):\n        y_prev = y\n        c = A_sub @ y\n        \n        # Guard against division by zero, though not expected for the given problem.\n        # The input matrices are positive, so for positive y, c will be positive.\n        if np.any(c == 0):\n           c[c == 0] = 1e-20\n\n        y = 1.0 / c\n        \n        # Check for convergence using the infinity norm.\n        if np.linalg.norm(y - y_prev, ord=np.inf) < tol:\n            break\n            \n    # Construct the full scaling vector x.\n    x = np.zeros(n, dtype=float)\n    x[I_zero_based] = y\n    \n    return x\n\ndef compute_delta(A, B1_one_based, B2_one_based):\n    \"\"\"\n    Computes the sensitivity between two exclusion sets B1 and B2 for matrix A.\n    \"\"\"\n    # Compute the scaling vectors for each exclusion set.\n    x1 = get_scaling_vector(A, B1_one_based)\n    x2 = get_scaling_vector(A, B2_one_based)\n    \n    n = A.shape[0]\n    U_one_based = set(range(1, n + 1))\n    \n    # Determine the set of common retained indices.\n    I1 = U_one_based - B1_one_based\n    I2 = U_one_based - B2_one_based\n    S_one_based = I1.intersection(I2)\n    \n    # If the intersection is empty, the mean difference is 0.\n    if not S_one_based:\n        return 0.0\n        \n    # Convert to 0-based indices for numpy array access.\n    S_zero_based = [s - 1 for s in S_one_based]\n    \n    # Compute the mean absolute difference over the common indices.\n    abs_diff = np.abs(x1[S_zero_based] - x2[S_zero_based])\n    delta = np.mean(abs_diff)\n    \n    return delta\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [10, 6, 3, 1, 0.5],\n        [6, 9, 5, 2, 1],\n        [3, 5, 8, 4, 2],\n        [1, 2, 4, 7, 3],\n        [0.5, 1, 2, 3, 6]\n    ], dtype=float)\n    \n    A2 = np.array([\n        [20, 10, 5, 2, 1],\n        [10, 18, 7, 3, 1.5],\n        [5, 7, 15, 6, 2],\n        [2, 3, 6, 12, 4],\n        [1, 1.5, 2, 4, 10]\n    ], dtype=float)\n\n    test_cases = [\n        (A1, set(), set()),             # Case 1\n        (A1, set(), {5}),               # Case 2\n        (A1, {1}, {5}),                 # Case 3\n        (A2, set(), {3}),               # Case 4\n        (A2, {2, 4}, {2, 5})            # Case 5\n    ]\n\n    results = []\n    for A, B1, B2 in test_cases:\n        result = compute_delta(A, B1, B2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2397206"}, {"introduction": "本练习将我们的视野拓宽到一种替代性的归一化方法——序列组分归一化 (Sequential Component Normalization, SCN)，并探讨一个关键的生物学问题。您将探索在全基因组尺度上进行归一化与按染色体逐一归一化之间的权衡。通过分析染色体间相互作用如何影响染色体内部的偏好向量，您将学会评估不同归一化策略对生物学结论的潜在影响。[@problem_id:2397211]", "problem": "您的任务是，在“高通量染色体构象捕获 (Hi-C)”的背景下，形式化并量化移除所有染色体间相互作用对“序贯成分归一化 (SCN)”所估计的染色体内偏置向量的影响。设一个接触图谱由一个对称非负矩阵 $M \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 表示。基因组被划分为两个染色体，大小分别为 $n_1$ 和 $n_2$，使得 $n = n_1 + n_2$，矩阵 $M$ 也相应地进行分块：\n$$\nM = \\begin{bmatrix}\nA & E \\\\\nE^\\top & B\n\\end{bmatrix},\n$$\n其中 $A \\in \\mathbb{R}_{\\ge 0}^{n_1 \\times n_1}$ 和 $B \\in \\mathbb{R}_{\\ge 0}^{n_2 \\times n_2}$ 分别编码染色体 1 和染色体 2 的染色体内相互作用，而 $E \\in \\mathbb{R}_{\\ge 0}^{n_1 \\times n_2}$ 编码染色体间相互作用。\n\n序贯成分归一化 (SCN) 定义如下。我们寻找一个正缩放向量 $b \\in \\mathbb{R}_{>0}^n$，使得对角缩放后的接触图谱\n$$\nN = D(b) \\, M \\, D(b)\n$$\n的所有行的欧几里得范数都等于 $1$，其中 $D(b)$ 表示对角线上为 $b$ 的对角矩阵。一个迭代过程从 $b^{(0)} = \\mathbf{1}$ 开始，并应用不动点更新\n$$\nb^{(t+1)}_i \\leftarrow \\frac{b^{(t)}_i}{\\sqrt{\\max\\left(\\left\\| \\left(D\\!\\left(b^{(t)}\\right) \\, M \\, D\\!\\left(b^{(t)}\\right)\\right)_{i,\\cdot} \\right\\|_2, \\varepsilon \\right)}}\n\\quad \\text{for all } i \\in \\{1,\\dots,n\\},\n$$\n其中使用一个小的 $\\varepsilon > 0$ 仅用于避免对全零行进行除零操作。此更新重复进行，直到收敛到一个不动点 $b^\\star$，我们称之为 $M$ 的 SCN 偏置向量。\n\n此处定义染色体 $k \\in \\{1,2\\}$ 的染色体内偏置向量为 $b^\\star$ 中仅限于属于染色体 $k$ 的索引的子向量。考虑两种计算偏置向量的方法：\n- 全局情况：为完整矩阵 $M$ 计算 $b^\\star$。\n- 仅含染色体内相互作用的情况：为通过移除所有染色体间相互作用得到的矩阵 $\\tilde{M}$ 计算 $\\tilde{b}^\\star$，即\n$$\n\\tilde{M} = \\begin{bmatrix}\nA & 0 \\\\\n0 & B\n\\end{bmatrix}.\n$$\n\n您的任务是实现 SCN 过程，以计算和比较在全局情况和仅含染色体内相互作用情况下获得的染色体内偏置向量。通过报告每个染色体在两种情景下相应偏置子向量之间的欧几里得距离，来量化移除染色体间相互作用的影响。具体来说，对于染色体 1 定义，\n$$\nd_1 = \\left\\| \\left(b^\\star\\right)_{1:n_1} - \\left(\\tilde{b}^\\star\\right)_{1:n_1} \\right\\|_2,\n$$\n以及，对于染色体 2 定义，\n$$\nd_2 = \\left\\| \\left(b^\\star\\right)_{n_1+1:n} - \\left(\\tilde{b}^\\star\\right)_{n_1+1:n} \\right\\|_2.\n$$\n\n请将您的推导和实现建立在以下基本事实和定义之上：\n- 接触图谱是一个对称非负矩阵，源于基因组位点之间邻近连接事件的计数，可以如上文所述由 $M$ 建模。\n- 对角合同变换 $N = D(b) M D(b)$ 保持对称性和非负性，且 $N$ 的行范数根据 $b$ 中的缩放而改变。\n- 当 $M$ 是块对角矩阵时，SCN 迭代在各个块之间解耦，因为 $b_i$ 的每次更新仅依赖于相应块内的条目。\n\n使用以下确定性测试套件，其中 $n_1 = 3$ 和 $n_2 = 2$：\n- 染色体内块\n$$\nA = \\begin{bmatrix}\n3.0 & 1.0 & 0.5 \\\\\n1.0 & 2.0 & 0.25 \\\\\n0.5 & 0.25 & 1.5\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n2.0 & 0.3 \\\\\n0.3 & 1.8\n\\end{bmatrix}.\n$$\n- 染色体间块参数化\n$$\nE(\\alpha) = \\alpha \\, u v^\\top, \\quad\nu = \\begin{bmatrix} 0.8 \\\\ 1.0 \\\\ 1.2 \\end{bmatrix}, \\quad\nv = \\begin{bmatrix} 0.7 \\\\ 1.1 \\end{bmatrix}.\n$$\n- 组装\n$$\nM(\\alpha) = \\begin{bmatrix}\nA & E(\\alpha) \\\\\nE(\\alpha)^\\top & B\n\\end{bmatrix}, \\quad\n\\tilde{M} = \\begin{bmatrix}\nA & 0 \\\\\n0 & B\n\\end{bmatrix}.\n$$\n- 对 $\\alpha \\in \\{ 0.0, 0.2, 1.0 \\}$ 这三个值，评估距离 $(d_1, d_2)$。\n\n角度单位和物理单位不适用于此问题。所有数值答案必须以浮点数形式报告。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，结果顺序为 $[d_1(\\alpha{=}0.0), d_2(\\alpha{=}0.0), d_1(\\alpha{=}0.2), d_2(\\alpha{=}0.2), d_1(\\alpha{=}1.0), d_2(\\alpha{=}1.0)]$，每个浮点数格式化为恰好 $12$ 位小数，例如 $[0.000000000000,0.000000000000,0.012345678901,0.098765432109,0.123456000000,0.654321000000]$。", "solution": "该问题定义明确且科学上合理，解决了计算基因组学中一个关于 Hi-C 接触图谱归一化的相关问题。任务是使用序贯成分归一化 (SCN) 算法，量化染色体间相互作用对染色体内偏置估计的影响。\n\nSCN 算法是一个迭代过程，旨在为给定的对称非负接触矩阵 $M \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 找到一个正缩放向量 $b \\in \\mathbb{R}_{>0}^n$。其目标是获得一个归一化矩阵 $N = D(b) \\, M \\, D(b)$，其中每一行的欧几里得范数都等于 1。矩阵 $D(b)$ 是一个对角线上为向量 $b$ 的对角矩阵。向量 $b$ 的每个元素 $b_i$ 的迭代更新规则如下：\n$$\nb^{(t+1)}_i \\leftarrow \\frac{b^{(t)}_i}{\\sqrt{\\max\\left(\\left\\| \\left(N^{(t)}\\right)_{i,\\cdot} \\right\\|_2, \\varepsilon \\right)}}, \\quad \\text{where } N^{(t)} = D(b^{(t)}) \\, M \\, D(b^{(t)})\n$$\n小的正常数 $\\varepsilon$ 通过防止除以零或对零取平方根来确保数值稳定性。该更新规则构成了一个不动点迭代。如果迭代收敛于向量 $b^\\star$，则它满足以下条件：对于每一行 $i$，归一化矩阵 $D(b^\\star) M D(b^\\star)$ 中相应行的欧几里得范数为 1，即 $\\left\\| (D(b^\\star) M D(b^\\star))_{i,\\cdot} \\right\\|_2 = 1$。$N^{(t)}$ 的第 $i$ 行的 L2-范数可以明确写为：\n$$\n\\left\\| (N^{(t)})_{i,\\cdot} \\right\\|_2 = \\sqrt{\\sum_{j=1}^n \\left( N^{(t)}_{ij} \\right)^2} = \\sqrt{\\sum_{j=1}^n \\left( b_i^{(t)} M_{ij} b_j^{(t)} \\right)^2} = b_i^{(t)} \\sqrt{\\sum_{j=1}^n \\left( M_{ij} b_j^{(t)} \\right)^2}\n$$\n因为 $b^{(t)}$ 的所有元素都是正的。这个公式指导了 SCN 算法的实现，该算法从初始向量 $b^{(0)} = \\mathbf{1}$（全为 1 的向量）开始，并持续进行，直到连续迭代之间的变化量 $\\|b^{(t+1)} - b^{(t)}\\|_2$ 小于指定的容差。\n\n该问题要求对一个划分为两个大小为 $n_1$ 和 $n_2$ 染色体的接触矩阵，比较两种情景：\n1.  **仅含染色体内相互作用的情况**：为块对角矩阵 $\\tilde{M} = \\begin{bmatrix} A & 0 \\\\ 0 & B \\end{bmatrix}$ 计算偏置向量，记为 $\\tilde{b}^\\star$。在这里，$A$ 和 $B$ 代表染色体内相互作用，而染色体间相互作用块 $E$ 被设为零。由于 $\\tilde{M}$ 的块对角结构，偏置向量前 $n_1$ 个分量的 SCN 更新仅依赖于矩阵 $A$，而其余 $n_2$ 个分量的更新仅依赖于 $B$。因此，问题解耦了。染色体 1 的偏置子向量 $(\\tilde{b}^\\star)_{1:n_1}$ 可以通过单独对矩阵 $A$ 应用 SCN 算法找到。类似地，$(\\tilde{b}^\\star)_{n_1+1:n}$ 是通过对矩阵 $B$ 应用 SCN 获得的。这提供了一个基准，代表了不考虑染色体间效应时估计的偏置。\n\n2.  **全局情况**：为完整接触矩阵 $M(\\alpha) = \\begin{bmatrix} A & E(\\alpha) \\\\ E(\\alpha)^\\top & B \\end{bmatrix}$ 计算偏置向量，记为 $b^\\star$，其中 $E(\\alpha) = \\alpha \\, u v^\\top$ 通过标量 $\\alpha$ 参数化了染色体间相互作用的强度。当 $\\alpha > 0$ 时，矩阵 $M(\\alpha)$ 不是块对角的。由于矩阵是完全连接的，任何分量 $b_i$ 的 SCN 更新都将依赖于两个染色体上的所有其他分量 $b_j$。这意味着两个染色体的偏置估计是耦合的。\n\n实现将按以下步骤进行：\n首先，我们通过分别在矩阵 $A$ 和 $B$ 上运行 SCN 算法，来计算基准的仅含染色体内相互作用的偏置子向量。设这些向量为 $\\tilde{b}^\\star_A$ 和 $\\tilde{b}^\\star_B$。\n其次，对于每个指定的 $\\alpha \\in \\{ 0.0, 0.2, 1.0 \\}$ 值，我们构建全局矩阵 $M(\\alpha)$。然后，我们在 $M(\\alpha)$ 上运行 SCN 算法，以找到全局偏置向量 $b^\\star(\\alpha)$。\n第三，我们将 $b^\\star(\\alpha)$ 划分为其染色体分量 $(b^\\star(\\alpha))_{1:n_1}$ 和 $(b^\\star(\\alpha))_{n_1+1:n}$。\n最后，我们计算欧几里得距离 $d_1(\\alpha)$ 和 $d_2(\\alpha)$ 以量化与基准的偏差：\n$$\nd_1(\\alpha) = \\left\\| (b^\\star(\\alpha))_{1:n_1} - \\tilde{b}^\\star_A \\right\\|_2\n$$\n$$\nd_2(\\alpha) = \\left\\| (b^\\star(\\alpha))_{n_1+1:n} - \\tilde{b}^\\star_B \\right\\|_2\n$$\n作为一个关键的合理性检查，对于 $\\alpha = 0.0$，我们有 $M(0.0) = \\tilde{M}$，这意味着 $b^\\star(0.0)$ 必须与连接后的向量 $[\\tilde{b}^\\star_A, \\tilde{b}^\\star_B]$ 相同。因此，$d_1(0.0)$ 和 $d_2(0.0)$ 都必须为零。对于 $\\alpha > 0$ 计算出的非零距离将衡量考虑染色体间相互作用所引入的扰动大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef scn(M, max_iter=2000, tol=1e-15, epsilon=1e-25):\n    \"\"\"\n    Performs Sequential Component Normalization (SCN) on a symmetric, non-negative matrix M.\n\n    Args:\n        M (np.ndarray): The input contact matrix.\n        max_iter (int): Maximum number of iterations.\n        tol (float): Convergence tolerance.\n        epsilon (float): Small constant to avoid division by zero.\n\n    Returns:\n        np.ndarray: The computed bias vector.\n    \"\"\"\n    n = M.shape[0]\n    b = np.ones(n, dtype=np.float64)\n\n    for _ in range(max_iter):\n        b_old = b.copy()\n\n        # Vectorized calculation of row norms of D(b) @ M @ D(b)\n        # The L2-norm of the i-th row is b_i * sqrt(sum_j (M_ij * b_j)^2)\n        \n        # M_b_ij = M_ij * b_j. b is broadcasted across rows.\n        M_b = M * b\n        \n        # M_b_sq_ij = (M_ij * b_j)^2\n        M_b_sq = np.square(M_b)\n        \n        # sum_sq_i = sum_j (M_ij * b_j)^2\n        sum_sq = M_b_sq.sum(axis=1)\n        \n        # row_norms_i = b_i * sqrt(sum_sq_i)\n        row_norms = b * np.sqrt(sum_sq)\n        \n        # Update rule from the problem statement: b_new = b_old / sqrt(row_norm)\n        b = b / np.sqrt(np.maximum(row_norms, epsilon))\n        \n        # Check for convergence\n        if np.linalg.norm(b - b_old) < tol:\n            break\n            \n    return b\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing and comparing bias vectors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'n1': 3,\n        'n2': 2,\n        'A': np.array([\n            [3.0, 1.0, 0.5],\n            [1.0, 2.0, 0.25],\n            [0.5, 0.25, 1.5]\n        ], dtype=np.float64),\n        'B': np.array([\n            [2.0, 0.3],\n            [0.3, 1.8]\n        ], dtype=np.float64),\n        'u': np.array([0.8, 1.0, 1.2], dtype=np.float64).reshape(3, 1),\n        'v': np.array([0.7, 1.1], dtype=np.float64).reshape(2, 1),\n        'alphas': [0.0, 0.2, 1.0]\n    }\n\n    n1 = test_cases['n1']\n    A = test_cases['A']\n    B = test_cases['B']\n    u = test_cases['u']\n    v = test_cases['v']\n    alphas = test_cases['alphas']\n\n    # --- Intra-only case ---\n    # Since tilde_M is block-diagonal, the problem decouples.\n    # We compute bias vectors for A and B separately.\n    b_tilde_A = scn(A)\n    b_tilde_B = scn(B)\n\n    results = []\n    for alpha in alphas:\n        # --- Global case ---\n        # Construct the inter-chromosomal block E(alpha)\n        E_alpha = alpha * (u @ v.T)\n        \n        # Assemble the full matrix M(alpha)\n        M_alpha = np.block([\n            [A, E_alpha],\n            [E_alpha.T, B]\n        ])\n        \n        # Compute the global bias vector b_star for M(alpha)\n        b_star = scn(M_alpha)\n        \n        # Extract subvectors corresponding to each chromosome\n        b_star_1 = b_star[0:n1]\n        b_star_2 = b_star[n1:]\n        \n        # Calculate the Euclidean distance between global and intra-only bias vectors\n        d1 = np.linalg.norm(b_star_1 - b_tilde_A)\n        d2 = np.linalg.norm(b_star_2 - b_tilde_B)\n        \n        results.append(d1)\n        results.append(d2)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2397211"}]}