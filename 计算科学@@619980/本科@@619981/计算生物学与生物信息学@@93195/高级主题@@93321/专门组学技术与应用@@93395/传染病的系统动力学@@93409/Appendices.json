{"hands_on_practices": [{"introduction": "第一个练习是一个基础性的计算。它旨在教会你如何将系统发育动力学模型（如出生-死亡天际线图）的直接输出参数，转化为关键的流行病学指标——有效再生数（$R_e$）。通过这个练习，你将巩固对谱系“出生”与“死亡”速率和流行病传播指标之间数学关系的理解[@problem_id:2742387]。", "problem": "一个直接传播的RNA病毒，在持续时间分别为 $\\Delta_1$、$\\Delta_2$ 和 $\\Delta_3$（单位：天）的三个连续区间内，采用分段常数（天际线）参数化，通过带抽样的生灭过程进行建模。在每个区间内，每个传染性谱系的传播速率为 $\\lambda_i$，因恢复或传染性终止而变为非传染性的速率为 $\\delta$（假设在所有区间内为常数），带移除的抽样以速率 $\\psi_i$ 发生（即谱系一旦被抽样，就不再具有传染性）。因此，在区间 $i$ 内的总移除速率为 $\\delta + \\psi_i$。区间 $i$ 内的有效再生数定义为一个典型传染性谱系在变为非传染性之前产生的二次感染的期望数，即 $R_{e,i} = \\lambda_i / (\\delta + \\psi_i)$。区间 $i$ 内的净分化（谱系增长）速率为 $r_i = \\lambda_i - (\\delta + \\psi_i)$。天际线输出还报告了在区间 $i$ 中，一个移除事件是抽样事件的概率，记为 $p_i$，其满足 $p_i = \\psi_i / (\\delta + \\psi_i)$。\n\n给定以下经验估计量：\n- 恒定的变为非传染性速率 $\\delta = 0.25$ 每天。\n- 区间持续时间：$\\Delta_1 = 20$ 天，$\\Delta_2 = 30$ 天，$\\Delta_3 = 25$ 天。\n- 净分化速率：$r_1 = 0.10$ 每天，$r_2 = -0.05$ 每天，$r_3 = 0.02$ 每天。\n- 移除事件中的抽样概率：$p_1 = 0.20$，$p_2 = 0.50$，$p_3 = 0.33$。\n\n假设所有量在各自的区间内是分段常数，并且该过程可由所述的带抽样的生灭模型很好地近似。将总观测窗口 $T = \\Delta_1 + \\Delta_2 + \\Delta_3$ 上的时间平均有效再生数定义为\n$$\\bar{R}_e \\equiv \\frac{1}{T} \\int_0^T R_e(t)\\,dt,$$\n其中在区间 $i$ 内 $R_e(t)$ 等于 $R_{e,i}$。\n\n仅使用上述定义和给定数据计算 $\\bar{R}_e$。将最终答案表示为无量纲数，并四舍五入到四位有效数字。", "solution": "问题陈述已经过验证，被认为是可接受的。这是一个系统发育动力学中的良定问题，基于标准的带抽样的生灭模型。所提供的定义是一致的，数据也足以计算出唯一解。\n\n目标是计算总观测窗口 $T$ 上的时间平均有效再生数 $\\bar{R}_e$。提供的定义是：\n$$\n\\bar{R}_e \\equiv \\frac{1}{T} \\int_0^T R_e(t)\\,dt\n$$\n观测窗口的总持续时间是 $T = \\Delta_1 + \\Delta_2 + \\Delta_3$。给定区间持续时间 $\\Delta_1 = 20$ 天，$\\Delta_2 = 30$ 天，$\\Delta_3 = 25$ 天，总持续时间是：\n$$\nT = 20 + 30 + 25 = 75 \\text{ 天}\n$$\n由于有效再生数 $R_e(t)$ 是分段常数，在区间 $i$ 的持续时间 $\\Delta_i$ 内 $R_e(t) = R_{e,i}$，因此该积分可以表示为加权和：\n$$\n\\bar{R}_e = \\frac{1}{T} \\left( \\Delta_1 R_{e,1} + \\Delta_2 R_{e,2} + \\Delta_3 R_{e,3} \\right)\n$$\n为了计算 $\\bar{R}_e$，我们必须首先确定每个区间 $i \\in \\{1, 2, 3\\}$ 的 $R_{e,i}$ 值。问题提供了以下定义：\n1. 净分化速率: $r_i = \\lambda_i - (\\delta + \\psi_i)$\n2. 有效再生数: $R_{e,i} = \\frac{\\lambda_i}{\\delta + \\psi_i}$\n3. 抽样概率: $p_i = \\frac{\\psi_i}{\\delta + \\psi_i}$\n\n根据定义(1)，我们可以将传播速率 $\\lambda_i$ 表示为 $\\lambda_i = r_i + \\delta + \\psi_i$。将此代入 $R_{e,i}$ 的定义(2)得到：\n$$\nR_{e,i} = \\frac{r_i + \\delta + \\psi_i}{\\delta + \\psi_i} = \\frac{r_i}{\\delta + \\psi_i} + 1\n$$\n$R_{e,i}$ 的这个表达式取决于总移除速率 $\\delta + \\psi_i$。使用定义(3)，这一项可以与给定的参数 $\\delta$ 和 $p_i$ 联系起来。具体来说，我们可以写出：\n$$\n1 - p_i = 1 - \\frac{\\psi_i}{\\delta + \\psi_i} = \\frac{(\\delta + \\psi_i) - \\psi_i}{\\delta + \\psi_i} = \\frac{\\delta}{\\delta + \\psi_i}\n$$\n重新整理这个方程，可以得到总移除速率的直接表达式：\n$$\n\\delta + \\psi_i = \\frac{\\delta}{1 - p_i}\n$$\n现在，我们将此结果代回到我们关于 $R_{e,i}$ 的表达式中：\n$$\nR_{e,i} = \\frac{r_i}{\\left(\\frac{\\delta}{1 - p_i}\\right)} + 1 = \\frac{r_i (1 - p_i)}{\\delta} + 1\n$$\n这个最终方程允许我们使用问题陈述中提供的量：$r_i$、$p_i$ 和常数 $\\delta = 0.25$ 每天，来直接计算 $R_{e,i}$。\n\n我们现在计算三个区间中每个区间的 $R_{e,i}$。\n\n对于区间 1：\n给定 $r_1 = 0.10$ 和 $p_1 = 0.20$。\n$$\nR_{e,1} = \\frac{r_1 (1 - p_1)}{\\delta} + 1 = \\frac{0.10 \\times (1 - 0.20)}{0.25} + 1 = \\frac{0.10 \\times 0.80}{0.25} + 1 = \\frac{0.08}{0.25} + 1 = 0.32 + 1 = 1.32\n$$\n\n对于区间 2：\n给定 $r_2 = -0.05$ 和 $p_2 = 0.50$。\n$$\nR_{e,2} = \\frac{r_2 (1 - p_2)}{\\delta} + 1 = \\frac{-0.05 \\times (1 - 0.50)}{0.25} + 1 = \\frac{-0.05 \\times 0.50}{0.25} + 1 = \\frac{-0.025}{0.25} + 1 = -0.10 + 1 = 0.90\n$$\n\n对于区间 3：\n给定 $r_3 = 0.02$ 和 $p_3 = 0.33$。\n$$\nR_{e,3} = \\frac{r_3 (1 - p_3)}{\\delta} + 1 = \\frac{0.02 \\times (1 - 0.33)}{0.25} + 1 = \\frac{0.02 \\times 0.67}{0.25} + 1 = \\frac{0.0134}{0.25} + 1 = 0.0536 + 1 = 1.0536\n$$\n\n在计算出 $R_{e,1}$、$R_{e,2}$ 和 $R_{e,3}$ 的值之后，我们现在可以计算时间平均有效再生数 $\\bar{R}_e$：\n$$\n\\bar{R}_e = \\frac{1}{75} \\left( (\\Delta_1 R_{e,1}) + (\\Delta_2 R_{e,2}) + (\\Delta_3 R_{e,3}) \\right)\n$$\n$$\n\\bar{R}_e = \\frac{1}{75} \\left( (20 \\times 1.32) + (30 \\times 0.90) + (25 \\times 1.0536) \\right)\n$$\n$$\n\\bar{R}_e = \\frac{1}{75} \\left( 26.4 + 27.0 + 26.34 \\right)\n$$\n$$\n\\bar{R}_e = \\frac{79.74}{75} = 1.0632\n$$\n问题要求将最终答案四舍五入到四位有效数字。计算值为 $1.0632$。将其四舍五入到四位有效数字得到 $1.063$。", "answer": "$$\n\\boxed{1.063}\n$$", "id": "2742387"}, {"introduction": "在之前练习的基础上，本次实践将从静态计算转向动态估计。你将亲手实现并比较两种独立的方法来追踪疫情的传播轨迹：一种使用病毒基因组数据（系统发育树），另一种使用传统的流行病学数据（病例数）。这种强大的对比凸显了基因组监测与公共卫生监测的互补性，并让你通过动手实践掌握系统发育动力学中的核心计算技术[@problem_id:2414531]。", "problem": "给定一个基于传染病系统发育动力学的计算任务：在一个生死过程下，根据一个时间标度系统发育树推断病毒的有效再生数 $R_e(t)$，并将其与通过更新方程从病例发病率数据中得出的估计值进行比较。目标是通过将基本过程定义与算法估计器相联系，来检验从第一性原理出发的推理能力。\n\n仅使用以下基本依据：\n- 一个生死过程，其每个谱系的出生率为 $\\lambda(t)$，每个谱系的移除率为 $\\delta(t)$（包括所有终止传播的过程，例如康复和伴随移除的抽样）。在恒定的 $\\delta$ 下，期望寿命为 $1/\\delta$，一个谱系在其生命周期内产生的期望传播事件数为 $\\lambda/\\delta$。\n- 净分化（或流行病增长）率定义为 $r(t) = \\lambda(t) - \\delta(t)$。\n- 穿时谱系函数 $L(t)$，它计算在重建的系统发育树中于时间 $t$ 存在的谱系数量。在一个短窗口内近似指数增长的情况下，$\\log L(t)$ 关于时间的局部斜率近似于瞬时净增长率。\n- 具有已知代际时间分布 $w(\\tau)$ 的发病率更新方程：时间 $t$ 的期望发病率满足 $I(t) = \\int_{0}^{\\infty} R_e(t)\\, I(t-\\tau)\\, w(\\tau)\\, d\\tau$。在时间步长为 $\\Delta t$ 的离散时间中，这变成与一个离散核的卷积。\n\n你的程序必须：\n1.  从一个重建的、时间标度的系统发育树（在规则时间网格上由一个穿时谱系阶跃函数概括，单位时间步长为一天）中，通过在宽度为 $2w$ 天的对称窗口内对 $\\log L(t)$ 进行中心有限差分，来估计一个分段连续的净增长率 $r(t)$。其中 $w$ 是一个正整数，时间以天为单位。对于每个测试用例，在平均传染期 $D$（以天为单位）为常数的假设下，使用此结果推断 $R_e(t)$。所有时间单位均为天；所有中间和最终的内部计算都必须统一以天为单位表示。\n2.  从通过离散时间更新过程生成的病例发病率数据 $I(t)$（具有给定的代际时间分布 $w_s$，即在 $s \\in \\{1,2,\\dots,K\\}$ 天上的概率质量函数），使用 Cori 估计器计算瞬时有效再生数。该估计器在分母非零时使用 $R_e(t) = I(t) / \\sum_{s=1}^{K} I(t-s) w_s$。本问题不使用角度，因此不需要角度单位。\n3.  通过计算基于系统发育树的估计值和基于病例的估计值之间的均方根误差 (RMSE)，在一个公共评估窗口上比较 $R_e(t)$ 的两个轨迹。RMSE 必须是一个浮点数。\n\n实现要求：\n- 在以天为单位的网格上，由一个给定的分段恒定净增长率 $r(t)$ 驱动一个期望指数增长模型，从而确定性地构建源自系统发育树的 $L(t)$。从 $L(0)=1$ 个谱系开始，通过 $L_{\\mathrm{exp}}(t+1) = L_{\\mathrm{exp}}(t)\\,\\exp(r(t))$ 演化期望谱系计数 $L_{\\mathrm{exp}}(t)$，然后通过取 $L_{\\mathrm{exp}}(t)$ 的非递减整数下限来形成整数穿时谱系曲线 $L(t)$，并保证在任何时候谱系数量最少为 1。通过在窗口 $[t-w, t+w]$ 上以步长 $\\Delta t = 1$ 天对 $\\log L(t)$ 进行中心有限差分来估计 $r(t)$。\n- 从更新方程 $I(t) = R_e(t) \\sum_{s=1}^{\\min(K,t)} I(t-s) w_s$ 确定性地生成病例发病率 $I(t)$，初始种子为 $I(0)=1$ 例病例，其中用于生成 $I(t)$ 的“真实”$R_e(t)$ 是由该测试用例给定的分段 $r(t)$ 和 $D$ 所隐含的。代际时间分布 $w_s$ 必须构建为一个离散化的伽马分布，其形状参数为 $\\alpha$，尺度参数为 $\\beta$（均值为 $\\alpha\\beta$），通过在单位天的时间格中的概率质量进行离散化：对于 $s \\in \\{1,\\dots,K\\}$，$w_s = F(s) - F(s-1)$，其中 $F$ 是具有给定参数的连续伽马分布的累积分布函数，并进行归一化以使 $\\sum_{s=1}^{K} w_s = 1$。所有的时间和分布参数均以天为单位。\n- 对于每个测试用例，在评估索引集 $t \\in \\{t_{\\min}, \\dots, t_{\\max}\\}$ 上计算基于系统发育树的 $R_e(t)$ 与基于病例的 $R_e(t)$ 之间的 RMSE，其中 $t_{\\min} = \\max\\{K, w\\}$，$t_{\\max} = T - 1 - w$，$T$ 是时间序列的总天数。仅包括两个估计值都为有限实数的时间点。\n\n测试套件：\n对于每个测试用例 $i \\in \\{1,2,3\\}$，程序必须使用以下参数。所有时间单位为天，所有速率单位为每天。分段净增长率 $r(t)$ 由分段 $(t_{\\mathrm{start}}, t_{\\mathrm{end}}, r)$ 定义，包含 $t_{\\mathrm{start}}$ 但不包含 $t_{\\mathrm{end}}$，其中 $t \\in \\{0,1,\\dots,T-1\\}$。\n- 测试用例 1：\n  - 总时长 $T = 60$。\n  - 传染期 $D = 5$。\n  - 平滑半窗口 $w = 3$。\n  - 代际时间伽马分布参数 $\\alpha = 2.0$，$\\beta = 2.5$（均值 = 5），在 $K=15$ 天处截断。\n  - 净增长率分段：$(0,20,0.15)$, $(20,40,0.05)$, $(40,60,0.01)$。\n- 测试用例 2：\n  - 总时长 $T = 80$。\n  - 传染期 $D = 7$。\n  - 平滑半窗口 $w = 5$。\n  - 代际时间伽马分布参数 $\\alpha = 2.0$，$\\beta = 3.5$（均值 = 7），在 $K=20$ 天处截断。\n  - 净增长率分段：$(0,40,0.00)$, $(40,80,0.01)$。\n- 测试用例 3：\n  - 总时长 $T = 45$。\n  - 传染期 $D = 4$。\n  - 平滑半窗口 $w = 4$。\n  - 代际时间伽马分布参数 $\\alpha = 2.0$，$\\beta = 2.0$（均值 = 4），在 $K=12$ 天处截断。\n  - 净增长率分段：$(0,45,0.03)$。\n\n需统一应用于所有测试用例的假设：\n- 将移除视为与变为非传染性同义，并假设抽样伴随移除；使用一个恒定的平均传染期 $D$（因此在每个测试中移除率实际上是恒定的）。\n- 始终使用 $\\Delta t = 1$ 天作为离散时间步长。\n- 在生成病例数据和从病例数据中进行估计时，使用相同的伽马代际时间分布。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试用例 1、2 和 3 的 RMSE 值，按顺序排列。每个值都需四舍五入到恰好六位小数，并以逗号分隔的列表形式用方括号括起来。例如，输出必须类似 $[x_1,x_2,x_3]$，其中 $x_i$ 是四舍五入到六位小数的浮点数，且无附加文本。", "solution": "所提出的问题是一个定义明确的计算系统发育动力学练习，要求比较流行病有效再生数 $R_e(t)$ 的两个不同估计器。第一个估计值源自系统发育的生死过程，第二个源自流行病学病例发病率数据的更新方程。该问题具有科学依据、内部一致，并为获得唯一的、可验证的解决方案提供了所有必要的参数和定义。因此，我将进行严谨的、分步的推导和算法设计。\n\n分析基于两个基本模型：用于系统发育的生死过程和用于流行病的更新方程。关键的智力步骤是在它们之间建立一个正式的桥梁。\n\n**1. 理论基础：连接系统发育动力学与流行病学**\n\n一个时间标度的系统发育树可以被建模为一个生死过程，其中谱系以速率 $\\lambda(t)$ 分支（出生），并以速率 $\\delta(t)$ 被移除（死亡或抽样）。净分化率，即谱系数量的净增长率，定义为：\n$$r(t) = \\lambda(t) - \\delta(t)$$\n在流行病学中，有效再生数 $R_e(t)$ 是指在时间 $t$ 单个感染者引起的平均新感染数量。在平均传染期 $D$ 恒定的假设下，移除率 $\\delta$ 是恒定的，等于该时期的倒数，即 $\\delta = 1/D$。量 $R_e(t)$ 等价于一个谱系在其生命周期内引起的期望传播次数，即出生率与移除率之比：\n$$R_e(t) = \\frac{\\lambda(t)}{\\delta(t)}$$\n通过将 $\\lambda(t) = r(t) + \\delta(t)$ 代入 $R_e(t)$ 的表达式，并使用 $\\delta = 1/D$，我们推导出关键的桥接方程：\n$$R_e(t) = \\frac{r(t) + \\delta}{\\delta} = \\frac{r(t)}{1/D} + 1 = D \\cdot r(t) + 1$$\n这个方程允许在系统发育动力学增长率 $r(t)$ 和流行病学再生数 $R_e(t)$ 之间进行直接转换。这个“真实”的 $R_e(t)$ 将被用来生成合成的发病率数据。\n\n**2. 基于系统发育树的 $R_e(t)$ 估计**\n\n第一个任务是从系统发育重建中估计 $R_e(t)$，该重建由穿时谱系 (LTT) 函数 $L(t)$ 概括。\n\n_步骤 2.1：合成 LTT 数据的生成_\n我们首先从给定的分段恒定增长率 $r(t)$ 生成一条合成的 LTT 曲线。从单个谱系 $L_{\\mathrm{exp}}(0) = 1$ 开始，在离散时间步长 $\\Delta t = 1$ 天下，期望谱系数量按以下方式演化：\n$$L_{\\mathrm{exp}}(t+1) = L_{\\mathrm{exp}}(t) \\cdot \\exp(r(t))$$\n为了创建一条更真实的、整数值且非递减的 LTT 曲线 $L(t)$，我们取期望值的下取整，并确保其永不递减：\n$$L(0) = \\max(1, \\lfloor L_{\\mathrm{exp}}(0) \\rfloor)$$\n$$L(t) = \\max(L(t-1), \\lfloor L_{\\mathrm{exp}}(t) \\rfloor) \\quad \\text{对于 } t > 0$$\n\n_步骤 2.2：$r(t)$ 和 $R_e(t)$ 的估计_\n从生成的 $L(t)$ 曲线中，我们估计增长率 $r_{\\text{est}}(t)$。LTT 的对数 $\\log L(t)$ 近似以速率 $r(t)$ 线性增长。我们可以使用导数的中心有限差分近似，在半宽度为 $w$ 的对称窗口上估计这个速率：\n$$r_{\\text{est}}(t) \\approx \\frac{\\log L(t+w) - \\log L(t-w)}{2w}$$\n该估计器对时间 $t$在区间 $[w, T-1-w]$ 内有效，其中 $T$ 是总时长。使用桥接方程，基于系统发育树的再生数估计值为：\n$$R_{e, \\text{phylo}}(t) = D \\cdot r_{\\text{est}}(t) + 1$$\n\n**3. 基于发病率的 $R_e(t)$ 估计**\n\n第二个任务是使用基于更新方程的方法，从每日病例发病率数据 $I(t)$ 中估计 $R_e(t)$。\n\n_步骤 3.1：合成发病率数据的生成_\n首先，我们需要一个代际时间分布，即相继感染之间的时间的概率分布。这通过离散化具有给定形状参数 $\\alpha$ 和尺度参数 $\\beta$ 的伽马分布来构建。对于每一天 $s \\in \\{1, \\dots, K\\}$ 的概率质量 $w_s$ 是累积分布函数 (CDF) $F(\\cdot)$ 在该日边界处的差值，然后进行归一化：\n$$w_s' = F(s; \\alpha, \\beta) - F(s-1; \\alpha, \\beta)$$\n$$w_s = \\frac{w_s'}{\\sum_{j=1}^{K} w_j'}$$\n以 $I(0)=1$ 为初始种子，使用离散更新方程确定性地生成发病率曲线 $I(t)$，该过程由第 1 节中推导出的真实 $R_e(t)$ 驱动：\n$$I(t) = R_e(t) \\sum_{s=1}^{\\min(K, t)} I(t-s) w_s$$\n\n_步骤 3.2：$R_e(t)$ 的估计_\n为了从生成的发病率数据中估计再生数，我们使用 Cori 估计器，它对更新方程进行求逆。对于任何时间 $t \\geq K$，估计值为：\n$$R_{e, \\text{case}}(t) = \\frac{I(t)}{\\sum_{s=1}^{K} I(t-s) w_s}$$\n分母代表了过去感染的所有个体在时间 $t$ 可能贡献于新感染的总传染性。\n\n**4. 定量比较**\n\n最后，通过计算两个估计器各自 $R_e(t)$ 轨迹之间的均方根误差 (RMSE) 来对它们进行比较。比较在一个公共评估窗口 $[t_{\\min}, t_{\\max}]$ 上进行，其中 $t_{\\min} = \\max(K, w)$ 且 $t_{\\max} = T-1-w$。这确保了两个估计值都有定义，并且已经超越了初始边界效应。RMSE 由下式给出：\n$$\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{t=t_{\\min}}^{t_{\\max}} \\left( R_{e, \\text{phylo}}(t) - R_{e, \\text{case}}(t) \\right)^2}$$\n其中 $N = t_{\\max} - t_{\\min} + 1$ 是评估窗口中的点数。该指标为两种独立估计方法之间的平均差异提供了一个稳健的度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import gamma\n\ndef run_test_case(T, D, w, alpha, beta, K, r_segments):\n    \"\"\"\n    Runs a single test case for estimating Re(t) and computing RMSE.\n    \n    This function implements the full pipeline:\n    1. Generates \"true\" r(t) and Re(t).\n    2. Generates phylogenetic L(t) data and estimates Re_phylo(t).\n    3. Generates incidence I(t) data and estimates Re_case(t).\n    4. Computes the RMSE between the two estimates over the valid window.\n    \"\"\"\n    # Step 1: Define \"true\" dynamics from problem-specified piecewise rates.\n    r_true = np.zeros(T)\n    for start, end, rate in r_segments:\n        r_true[start:end] = rate\n    \n    # The \"true\" Re(t) is derived from r(t) using the formula Re(t) = D*r(t) + 1.\n    Re_true = D * r_true + 1\n\n    # Step 2: Phylogeny-based estimation.\n    # 2a. Generate lineage-through-time (LTT) data L(t).\n    L_exp = np.zeros(T)\n    L_exp[0] = 1.0\n    for t in range(T - 1):\n        L_exp[t + 1] = L_exp[t] * np.exp(r_true[t])\n    \n    L = np.zeros(T, dtype=np.int64)\n    L[0] = max(1, int(np.floor(L_exp[0])))\n    for t in range(1, T):\n        L[t] = max(L[t - 1], int(np.floor(L_exp[t])))\n        \n    # 2b. Estimate r_est(t) from L(t) and then compute Re_phylo(t).\n    Re_phylo = np.full(T, np.nan)\n    # The centered finite difference is calculated over a 2w window.\n    for t in range(w, T - w):\n        # L(t) is guaranteed to be >= 1, so log argument is positive.\n        log_L_t_plus_w = np.log(L[t + w])\n        log_L_t_minus_w = np.log(L[t - w])\n        r_est_t = (log_L_t_plus_w - log_L_t_minus_w) / (2 * w)\n        Re_phylo[t] = D * r_est_t + 1\n\n    # Step 3: Incidence-based estimation.\n    # 3a. Construct the discretized Gamma generation time distribution w_s.\n    s_vals = np.arange(1, K + 1)\n    w_s_unnormalized = gamma.cdf(s_vals, a=alpha, scale=beta) - gamma.cdf(s_vals - 1, a=alpha, scale=beta)\n    w_s = w_s_unnormalized / np.sum(w_s_unnormalized)\n\n    # 3b. Generate case incidence data I(t) using the renewal equation.\n    I = np.zeros(T)\n    I[0] = 1.0\n    for t in range(1, T):\n        limit = min(K, t)\n        # The sum is over past infections, weighted by the generation time PMF.\n        # w_s is 1-indexed (s=1..K), so array is 0-indexed.\n        sum_val = sum(I[t - s] * w_s[s - 1] for s in range(1, limit + 1))\n        I[t] = Re_true[t] * sum_val\n    \n    # 3c. Estimate Re_case(t) using the Cori estimator.\n    Re_case = np.full(T, np.nan)\n    # The denominator is a convolution of past incidence with reversed w_s.\n    for t in range(K, T):\n      denominator = np.dot(I[t - K : t], w_s[::-1])\n      if denominator > 1e-12: # Avoid division by small numbers.\n          Re_case[t] = I[t] / denominator\n          \n    # Step 4: Compare estimates and calculate RMSE.\n    t_min = max(K, w)\n    t_max = T - 1 - w\n\n    # Extract the slices of the Re estimates over the common evaluation window.\n    phylo_slice = Re_phylo[t_min : t_max + 1]\n    case_slice = Re_case[t_min : t_max + 1]\n    \n    # Filter for finite values, although not expected in these test cases.\n    valid_indices = np.isfinite(phylo_slice) & np.isfinite(case_slice)\n    phylo_valid = phylo_slice[valid_indices]\n    case_valid = case_slice[valid_indices]\n    \n    if len(phylo_valid) == 0:\n        return 0.0 # Should not happen with valid test cases.\n    \n    squared_errors = (phylo_valid - case_valid) ** 2\n    rmse = np.sqrt(np.mean(squared_errors))\n    \n    return rmse\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": 60, \"D\": 5, \"w\": 3, \"alpha\": 2.0, \"beta\": 2.5, \"K\": 15,\n            \"r_segments\": [(0, 20, 0.15), (20, 40, 0.05), (40, 60, 0.01)]\n        },\n        {\n            \"T\": 80, \"D\": 7, \"w\": 5, \"alpha\": 2.0, \"beta\": 3.5, \"K\": 20,\n            \"r_segments\": [(0, 40, 0.00), (40, 80, 0.01)]\n        },\n        {\n            \"T\": 45, \"D\": 4, \"w\": 4, \"alpha\": 2.0, \"beta\": 2.0, \"K\": 12,\n            \"r_segments\": [(0, 45, 0.03)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(**case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2414531"}, {"introduction": "当我们能够估算平均传播率（$R_e$）后，一个更精细的问题随之而来：病毒的传播是均匀的，还是由少数“超级传播者”驱动的？最后一个练习是一个思想实验，它将挑战你将传播异质性与系统发育树的拓扑形状联系起来。理解这种联系对于设计有效的公共卫生干预措施至关重要，因为针对不同传播模式的控制策略可能大相径庭[@problem_id:2414547]。", "problem": "您正在比较在相似的宿主种群和相似的公共卫生条件下暴发的两种相同病毒。在这两次疫情中，每个原发病例的平均继发感染数相同，但该数值的离散度不同。具体来说，假设每个原发病例的继发感染数服从负二项分布，其平均基本再生数为 $R_0$，离散参数为 $k$，因此方差为 $R_0 + R_0^2/k$。疫情 $\\mathcal{S}$ 的 $R_0$ 与疫情 $\\mathcal{H}$ 相等，但 $k_{\\mathcal{S}} \\ll 1$（超级传播，高方差），而疫情 $\\mathcal{H}$ 的 $k_{\\mathcal{H}} \\to \\infty$（近似泊松分布，同质传播）。在相同的日历时间窗口内，采用相似的抽样方案（随时间推移，抽样概率 $\\rho$ 恒定），从每次疫情中抽取 $n$ 个病毒基因组，并使用相同的严格分子钟（速率为 $\\mu$）重建时间标度的系统发育树。\n\n仅使用分支过程和溯祖理论的第一性原理，推断子代分布的异质性如何影响重建的传播系统发育树的形状。在期望中保持 $R_0$、$\\mu$、$n$、$\\rho$ 和抽样时间窗口固定的情况下，哪一组定性的树形特征最能强烈地表明观察到的树来自于疫情 $\\mathcal{S}$ 而非疫情 $\\mathcal{H}$？\n\nA. 拓扑不平衡性显著更高（例如，像Colless指数或Sackin指数这样的指标值更大），内部枝长方差更大，且在某些内部节点附近出现非常短的节间簇，以及更多的梯状子树，而在相同的时钟速率和抽样时间下，平均根到叶尖距离保持可比。\n\nB. 拓扑不平衡性较低，树中内部枝长持续时间更均匀，拓扑结构更接近平衡的Yule树。\n\nC. 在相同的时钟速率和抽样时间下，平均根到叶尖距离系统性地更短，因为超级传播压缩了树高。\n\nD. 纯粹由于超级传播，即使当 $R_0$、$\\mu$、$n$、$\\rho$ 和抽样时间窗口相同时，同期叶尖之间的平均成对遗传距离也更大。", "solution": "该问题陈述具有科学依据、提问得当且客观。它基于流行病学和溯祖理论的既定原则，为比较同质与异质疾病传播的系统发育动力学后果提供了一个有效的理论框架。所使用的所有参数和模型都是计算生物学领域的标准。我现在将进行解答。\n\n问题的核心在于理解继发感染数（子代分布）的统计分布如何塑造病原体种群的谱系。该谱系由从抽样的病毒基因组重建的时间标度的系统发育树表示。流行病学过程（一种时间正向的分支过程）与系统发育树（通过时间反向的溯祖过程推断）之间的联系是根本性的。\n\n设单个感染者引起的继发感染数为随机变量 $X$。问题陈述指出，这服从负二项分布，均值为 $E[X] = R_0$，方差为 $\\text{Var}(X) = \\sigma^2 = R_0 + R_0^2/k$。参数 $k$ 是离散参数。\n\n在分支过程的溯祖理论中，任意一对谱系发生溯祖合并（找到共同祖先）的速率与有效种群大小 $N_e$ 成反比。有效种群大小本身又与子代分布的方差 $\\sigma^2$ 成反比。具体来说，一对谱系的溯祖合并速率与 $\\sigma^2 / N(t)$ 成正比，其中 $N(t)$ 是时间 $t$ 的感染个体数。对于给定的普查种群大小 $N(t)$，子代数量的方差越大，有效种群大小就越小，从而溯祖合并速率就越高。\n\n我们来分析这两种情况：\n\n1.  **疫情 $\\mathcal{H}$（同质传播）：**\n    离散参数 $k_{\\mathcal{H}} \\to \\infty$。在此极限下，负二项分布收敛于泊松分布。子代分布的方差变为 $\\sigma^2_{\\mathcal{H}} = \\lim_{k \\to \\infty} (R_0 + R_0^2/k) = R_0$。这种情况代表了一个过程，其中每个感染者传播病毒的倾向大致相同。在时间上向后追溯祖先，任何两个谱系在特定亲代中溯祖合并的概率在所有可能的亲子传播事件中相对均匀。这导致了一个更规律、更平衡的溯祖过程，类似于Yule（纯出生）过程。由此产生的系统发育树预期在拓扑上是平衡的，内部枝长（节间持续时间）的长度更为均匀。\n\n2.  **疫情 $\\mathcal{S}$（超级传播）：**\n    离散参数 $k_{\\mathcal{S}} \\ll 1$。子代分布的方差为 $\\sigma^2_{\\mathcal{S}} = R_0 + R_0^2/k_{\\mathcal{S}}$。由于 $k_{\\mathcal{S}}$ 很小，项 $R_0^2/k_{\\mathcal{S}}$ 很大，因此方差 $\\sigma^2_{\\mathcal{S}}$ 远大于均值 $R_0$。这对应于一种情况，即大多数个体引起的继发感染很少或没有，而一小部分“超级传播者”引起了大量的继发感染。\n    与疫情 $\\mathcal{H}$ 相比，这种高方差 $\\sigma^2_{\\mathcal{S}}$ 导致了更高的溯祖合并速率。这对树的形状有两个主要影响：\n    *   **拓扑不平衡性：** 一次超级传播事件，即一个个体感染了许多其他个体，对应于系统发育树中的一个单一节点，该节点是许多抽样谱系的直接祖先。这会产生高度不对称的、“星状”或“梳状”模式。在这些超级传播者节点处，许多谱系几乎同时（在时间上向后看）发生溯祖合并。这导致了高度不平衡的树拓扑，这可以通过诸如Colless指数或Sackin指数等不平衡性指数的大值来量化。\n    *   **枝长分布：** 源自超级传播者的谱系近乎同时的溯祖合并，导致了一簇非常短的内部枝（节间）。相比之下，连接这些主要传播簇（追溯到主要超级传播事件之前的祖先）的枝条可能非常长。这导致了内部枝长分布的高方差。\n\n现在，我们评估每个选项：\n\n**A. 拓扑不平衡性显著更高（例如，像Colless指数或Sackin指数这样的指标值更大），内部枝长方差更大，且在某些内部节点附近出现非常短的节间簇，以及更多的梯状子树，而在相同的时钟速率和抽样时间下，平均根到叶尖距离保持可比。**\n该选项准确描述了上述推导出的超级传播的后果。\n*   “拓扑不平衡性显著更高...像Colless指数或Sackin指数这样的指标值更大”：正确。这是超级传播事件产生星状节点的直接结果。\n*   “内部枝长方差更大，且出现非常短的节间簇”：正确。这反映了传播簇内的快速溯祖合并与簇间较长的溯祖合并等待时间的对比。\n*   “更多的梯状子树”：正确。这是对不平衡拓扑的另一种描述。\n*   “平均根到叶尖距离保持可比”：这是一个合理的陈述。虽然 $\\mathcal{S}$ 中更高的溯祖合并率会倾向于缩短总的最近共同祖先时间（TMRCA），但最主要和最显著的特征是拓扑和枝长的特征。疫情的总时间尺度主要由增长率（与 $R_0$ 相关）和观察持续时间决定，这两者在两次疫情中是相同的。因此，将根到叶尖的距离视为“可比”，同时强调形状上的深刻变化，是描述最强信号的适当方式。\n该选项中呈现的特征集合为超级传播驱动的疫情提供了强大而全面的指纹。\n结论：**正确**。\n\n**B. 拓扑不平衡性较低，树中内部枝长持续时间更均匀，拓扑结构更接近平衡的Yule树。**\n这个选项描述了同质传播疫情 $\\mathcal{H}$ 的预期系统发育树。它与超级传播疫情 $\\mathcal{S}$ 的预期情况相反。\n结论：**不正确**。\n\n**C. 在相同的时钟速率和抽样时间下，平均根到叶尖距离系统性地更短，因为超级传播压缩了树高。**\n这个推理并非完全错误。如前所述，较高的方差 $\\sigma^2_{\\mathcal{S}}$ 增加了溯祖合并速率，这确实倾向于减少样本的TMRCA，从而缩短树高和平均根到叶尖的距离。然而，这个选项不完整。它只关注单一指标（平均根到叶尖距离），而忽略了更具戏剧性和特征性的拓扑和枝长分布特征。问题要求的是“最能强烈地表明”疫情 $\\mathcal{S}$ 的“一组定性的树形特征”。选项A提供了更丰富、更稳健的一组此类特征。虽然C是一个可能的结果，但与A中的特征相比，它不是最具决定性的特征。\n结论：**不正确**。\n\n**D. 纯粹由于超级传播，即使当 $R_0$、$\\mu$、$n$、$\\rho$ 和抽样时间窗口相同时，同期叶尖之间的平均成对遗传距离也更大。**\n平均成对遗传距离与所有叶尖对的平均最近共同祖先时间 $(\\overline{T_2})$ 成正比。更高的溯祖合并速率是疫情 $\\mathcal{S}$ 的特征，这意味着谱系能更快地（即在更近的过去）找到共同祖先。这导致成对的平均TMRCA*更小*，因此平均成对遗传距离*更小*，而不是更大。这一陈述的说法与理论预期相反。\n结论：**不正确**。\n\n综上所述，选项A提供了最准确、最全面的定性特征集，用以区分来自超级传播疫情的系统发育树。", "answer": "$$\\boxed{A}$$", "id": "2414547"}]}