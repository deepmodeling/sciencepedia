{"hands_on_practices": [{"introduction": "ATAC-seq 产生的一个关键数据特征是测序片段的长度分布。该分布通常表现出周期性，反映了 DNA 被包裹在核小体周围的方式：短片段（小于约 100 bp）通常来自无核小体的开放染色质区域，而较长的片段则对应于包裹了一个、两个或多个核小体的 DNA。这个练习将指导您建立一个贝叶斯分类器，利用片段长度分布这一基本特征来区分不同生物学样本（如健康组织和肿瘤组织），这是 ATAC-seq 数据质量控制和初步分析中的一项基本技能 [@problem_id:2378288]。", "problem": "您会收到来自转座酶可及性染色质测序分析（Assay for Transposase-Accessible Chromatin using sequencing, ATAC-seq）的多个样本的离散片段长度直方图。每个直方图由一系列非负整数计数组成，这些计数分布在以碱基对为单位、具有指定边界的连续片段长度区间（bin）中。假设存在以下生成模型和分类目标。\n\n1. 片段长度被建模为连续变量 $\\ell$（单位：碱基对），其类条件概率密度由对应于亚核小体和核小体片段的高斯分量混合而成。对于每个类别 $C \\in \\{\\mathrm{H}, \\mathrm{T}\\}$，其未归一化的密度函数为\n$$\nf_C(\\ell) \\;=\\; \\sum_{k=1}^{4} w_{C,k} \\cdot \\phi(\\ell \\mid \\mu_k, \\sigma_{C,k}),\n$$\n其中 $\\phi(\\ell \\mid \\mu, \\sigma)$ 是均值为 $\\mu$、标准差为 $\\sigma$ 的高斯密度函数。各分量的均值固定为\n$$\n\\mu_1 = 75,\\quad \\mu_2 = 180,\\quad \\mu_3 = 360,\\quad \\mu_4 = 540,\n$$\n单位均为碱基对。特定于类别的混合权重和标准差如下：\n$$\n(w_{\\mathrm{H},1}, w_{\\mathrm{H},2}, w_{\\mathrm{H},3}, w_{\\mathrm{H},4}) = (0.25, 0.45, 0.22, 0.08),\n$$\n$$\n(\\sigma_{\\mathrm{H},1}, \\sigma_{\\mathrm{H},2}, \\sigma_{\\mathrm{H},3}, \\sigma_{\\mathrm{H},4}) = (20, 15, 20, 25),\n$$\n$$\n(w_{\\mathrm{T},1}, w_{\\mathrm{T},2}, w_{\\mathrm{T},3}, w_{\\mathrm{T},4}) = (0.50, 0.35, 0.12, 0.03),\n$$\n$$\n(\\sigma_{\\mathrm{T},1}, \\sigma_{\\mathrm{T},2}, \\sigma_{\\mathrm{T},3}, \\sigma_{\\mathrm{T},4}) = (25, 25, 35, 45),\n$$\n所有 $\\sigma$ 值的单位均为碱基对。类别标签 $\\mathrm{H}$ 代表健康组织，$\\mathrm{T}$ 代表快速分裂的肿瘤组织。\n\n2. 设片段长度区间边界（单位：碱基对）为有序列表\n$$\n[\\,0,\\; 100,\\; 150,\\; 200,\\; 250,\\; 300,\\; 400,\\; 500,\\; 700,\\; 1000\\,].\n$$\n对于类别 $C$，通过在第 $i$ 个区间上对密度函数 $f_C$ 进行积分，并在所有区间上进行归一化，定义第 $i$ 个区间的离散概率 $p_{C,i}$，使得所有概率之和为 $1$：\n$$\np_{C,i} \\;=\\; \\frac{\\displaystyle \\int_{b_i}^{b_{i+1}} f_C(\\ell)\\, d\\ell}{\\displaystyle \\sum_{j=1}^{9} \\int_{b_j}^{b_{j+1}} f_C(\\ell)\\, d\\ell},\n$$\n其中 $[b_i, b_{i+1})$ 是第 $i$ 个区间，$i = 1,\\dots,9$。\n\n3. 对于一个给定的样本，其总计数为 $N$，在 9 个区间上的计数向量为 $\\mathbf{c} = (c_1,\\dots,c_9)$。假设在给定类别 $C$ 的条件下，这些计数服从参数为 $N$ 和 $(p_{C,1},\\dots,p_{C,9})$ 的多项分布。\n\n4. 假设类别先验概率相等，$P(\\mathrm{H}) = P(\\mathrm{T}) = 1/2$。对于每个样本，根据此模型选择使其后验概率最大化的类别标签。\n\n测试套件。使用以下四个测试用例，每个用例都指定为上述定义的 9 个区间上的计数向量。所有片段长度均以碱基对为单位，所有计数均为整数。\n\n- 案例 1（类健康，中等深度，总计数 20000）：$[\\,1600,\\;2000,\\;6800,\\;1200,\\;1000,\\;4400,\\;800,\\;1800,\\;400\\,]$。\n- 案例 2（类肿瘤，中等深度，总计数 20000）：$[\\,4000,\\;4400,\\;5000,\\;1400,\\;1400,\\;2400,\\;600,\\;600,\\;200\\,]$。\n- 案例 3（模糊，中等深度，总计数 20000）：$[\\,3000,\\;3200,\\;5400,\\;1400,\\;1400,\\;3200,\\;1000,\\;1200,\\;200\\,]$。\n- 案例 4（类健康，低深度，总计数 100）：$[\\,0,\\;5,\\;40,\\;0,\\;0,\\;30,\\;0,\\;20,\\;5\\,]$。\n\n输出要求。对于每个案例，您的程序必须输出一个布尔值，以指示样本被分类为健康组织 ($\\mathrm{H}$) 还是快速分裂的肿瘤组织 ($\\mathrm{T}$)。使用布尔值 `True` 代表健康，布尔值 `False` 代表肿瘤。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$[\\,\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}\\,]$）。不得打印任何额外文本。所有长度必须以碱基对为单位处理，输出中不要求使用其他物理单位。", "solution": "该问题要求根据片段长度直方图，将 ATAC-seq 样本分为健康（$\\mathrm{H}$）或肿瘤（$\\mathrm{T}$）两个类别之一。这是一个贝叶斯分类问题。目标是对于一个给定的片段计数向量 $\\mathbf{c} = (c_1, \\dots, c_9)$，确定哪个类别 $C \\in \\{\\mathrm{H}, \\mathrm{T}\\}$ 能使后验概率 $P(C \\mid \\mathbf{c})$ 最大化。\n\n根据贝叶斯定理，后验概率由下式给出：\n$$\nP(C \\mid \\mathbf{c}) = \\frac{P(\\mathbf{c} \\mid C) P(C)}{P(\\mathbf{c})}\n$$\n为了最大化 $P(C \\mid \\mathbf{c})$，我们需要比较 $P(\\mathrm{H} \\mid \\mathbf{c})$ 和 $P(\\mathrm{T} \\mid \\mathbf{c})$。$P(\\mathbf{c})$ 项是一个归一化常数，对于两个类别是相同的，因此在比较时可以忽略。问题陈述，类别先验概率相等，$P(\\mathrm{H}) = P(\\mathrm{T}) = 1/2$。因此，最大化后验概率等价于最大化类条件似然 $P(\\mathbf{c} \\mid C)$。决策规则是：如果 $P(\\mathbf{c} \\mid \\mathrm{H}) > P(\\mathbf{c} \\mid \\mathrm{T})$，则选择类别 $\\mathrm{H}$，否则选择类别 $\\mathrm{T}$。\n\n问题陈述，在给定类别 $C$ 和总计数 $N = \\sum_{i=1}^{9} c_i$ 的条件下，计数向量 $\\mathbf{c}$ 服从参数为 $N$ 和概率向量 $\\mathbf{p}_C = (p_{C,1}, \\dots, p_{C,9})$ 的多项分布。似然由多项分布的概率质量函数给出：\n$$\nP(\\mathbf{c} \\mid C) = \\frac{N!}{c_1! c_2! \\dots c_9!} \\prod_{i=1}^{9} p_{C,i}^{c_i}\n$$\n多项系数 $\\frac{N!}{\\prod_{i=1}^{9} c_i!}$ 对于两个类别也是相同的，在比较中可以忽略。因此，决策基于比较乘积项 $\\prod_{i=1}^{9} p_{C,i}^{c_i}$。为避免多个小概率相乘导致的数值下溢，比较对数似然在计算上更稳定。决策规则变为：如果 $\\mathcal{L}(\\mathrm{H}) > \\mathcal{L}(\\mathrm{T})$，则选择类别 $\\mathrm{H}$，其中类别 $C$ 的对数似然的相关部分为：\n$$\n\\mathcal{L}(C) = \\log\\left(\\prod_{i=1}^{9} p_{C,i}^{c_i}\\right) = \\sum_{i=1}^{9} c_i \\log p_{C,i}\n$$\n因此，问题的核心是计算区间概率向量 $\\mathbf{p}_\\mathrm{H}$ 和 $\\mathbf{p}_\\mathrm{T}$。\n\n问题基于片段长度 $\\ell$ 的连续生成模型来定义这些概率。对于每个类别 $C$，未归一化的密度函数 $f_C(\\ell)$ 是 4 个高斯分量的混合：\n$$\nf_C(\\ell) = \\sum_{k=1}^{4} w_{C,k} \\cdot \\phi(\\ell \\mid \\mu_k, \\sigma_{C,k})\n$$\n其中 $\\phi(\\ell \\mid \\mu, \\sigma)$ 是均值为 $\\mu$、标准差为 $\\sigma$ 的高斯分布的概率密度函数（PDF）。第 $i$ 个区间 $[b_i, b_{i+1})$ 的区间概率 $p_{C,i}$ 是通过在该区间上对 $f_C(\\ell)$ 进行积分，然后用所有 9 个指定区间上的积分总和进行归一化得到的。\n\n首先，我们计算每个区间 $i$ 和类别 $C$ 的未归一化概率质量，记为 $I_{C,i}$：\n$$\nI_{C,i} = \\int_{b_i}^{b_{i+1}} f_C(\\ell)\\, d\\ell = \\int_{b_i}^{b_{i+1}} \\sum_{k=1}^{4} w_{C,k} \\cdot \\phi(\\ell \\mid \\mu_k, \\sigma_{C,k})\\, d\\ell\n$$\n根据积分的线性性质，可得：\n$$\nI_{C,i} = \\sum_{k=1}^{4} w_{C,k} \\int_{b_i}^{b_{i+1}} \\phi(\\ell \\mid \\mu_k, \\sigma_{C,k})\\, d\\ell\n$$\n高斯 PDF 在一个区间上的积分可以用其累积分布函数（CDF）$\\Phi(\\ell \\mid \\mu, \\sigma)$ 来表示。具体来说，$\\int_{a}^{b} \\phi(\\ell \\mid \\mu, \\sigma)\\,d\\ell = \\Phi(b \\mid \\mu, \\sigma) - \\Phi(a \\mid \\mu, \\sigma)$。高斯 CDF 可以通过标准正态 CDF $\\Phi_{std}(z) = \\Phi(z|0,1)$ 计算，即 $\\Phi(\\ell \\mid \\mu, \\sigma) = \\Phi_{std}((\\ell-\\mu)/\\sigma)$。标准正态 CDF 与误差函数 $\\operatorname{erf}(x)$ 的关系为 $\\Phi_{std}(z) = \\frac{1}{2}(1 + \\operatorname{erf}(z/\\sqrt{2}))$。\n因此，对于每个高斯分量 $k$ 和区间 $i$：\n$$\n\\int_{b_i}^{b_{i+1}} \\phi(\\ell \\mid \\mu_k, \\sigma_{C,k})\\,d\\ell = \\Phi\\left(\\frac{b_{i+1}-\\mu_k}{\\sigma_{C,k}}\\right) - \\Phi\\left(\\frac{b_i-\\mu_k}{\\sigma_{C,k}}\\right)\n$$\n在计算完所有 $i=1,\\dots,9$ 的 $I_{C,i}$ 后，我们计算在所考虑范围 $[b_1, b_{10}) = [0, 1000)$ 内的总未归一化质量：\n$$\nS_C = \\sum_{j=1}^{9} I_{C,j} = \\int_{0}^{1000} f_C(\\ell)\\, d\\ell\n$$\n最终的区间概率通过归一化得到：\n$$\np_{C,i} = \\frac{I_{C,i}}{S_C}\n$$\n对类别 $\\mathrm{H}$ 和类别 $\\mathrm{T}$ 都执行此过程，以获得概率向量 $\\mathbf{p}_\\mathrm{H}$ 和 $\\mathbf{p}_\\mathrm{T}$。\n\n完整的算法如下：\n1. 定义模型参数：均值 $\\mu_k$、权重 $w_{C,k}$、标准差 $\\sigma_{C,k}$ (对于 $C \\in \\{\\mathrm{H}, \\mathrm{T}\\}$) 以及区间边界 $b_i$。\n2. 通过在 9 个区间上对混合密度 $f_\\mathrm{H}(\\ell)$ 进行积分并对结果进行归一化，计算概率向量 $\\mathbf{p}_\\mathrm{H}$。\n3. 类似地，使用 $f_\\mathrm{T}(\\ell)$ 计算概率向量 $\\mathbf{p}_\\mathrm{T}$。\n4. 对于由计数向量 $\\mathbf{c} = (c_1, \\dots, c_9)$ 给出的每个测试用例：\n    a. 计算类别 $\\mathrm{H}$ 的对数似然得分：$\\mathcal{L}(\\mathrm{H}) = \\sum_{i=1}^{9} c_i \\log p_{\\mathrm{H},i}$。\n    b. 计算类别 $\\mathrm{T}$ 的对数似然得分：$\\mathcal{L}(\\mathrm{T}) = \\sum_{i=1}^{9} c_i \\log p_{\\mathrm{T},i}$。\n    c. 比较得分。如果 $\\mathcal{L}(\\mathrm{H}) > \\mathcal{L}(\\mathrm{T})$，样本被分类为健康（$\\mathrm{H}$），用布尔值 `True` 表示。否则，它被分类为肿瘤（$\\mathrm{T}$），用 `False` 表示。\n5. 收集所有测试用例的布尔结果，并按要求格式化。\n将实施此过程以解决给定测试用例的问题。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the ATAC-seq sample classification problem.\n    \"\"\"\n\n    # 1. Define model parameters as given in the problem statement.\n    \n    # Fragment-length bin edges in base pairs\n    bin_edges = np.array([0, 100, 150, 200, 250, 300, 400, 500, 700, 1000], dtype=np.float64)\n\n    # Gaussian component means (fixed for both classes)\n    means = np.array([75, 180, 360, 540], dtype=np.float64)\n\n    # Class H (Healthy) parameters\n    weights_H = np.array([0.25, 0.45, 0.22, 0.08], dtype=np.float64)\n    std_devs_H = np.array([20, 15, 20, 25], dtype=np.float64)\n\n    # Class T (Tumor) parameters\n    weights_T = np.array([0.50, 0.35, 0.12, 0.03], dtype=np.float64)\n    std_devs_T = np.array([25, 25, 35, 45], dtype=np.float64)\n\n    # Test cases: count vectors\n    test_cases = [\n        np.array([1600, 2000, 6800, 1200, 1000, 4400, 800, 1800, 400]), # Case 1\n        np.array([4000, 4400, 5000, 1400, 1400, 2400, 600, 600, 200]), # Case 2\n        np.array([3000, 3200, 5400, 1400, 1400, 3200, 1000, 1200, 200]), # Case 3\n        np.array([0, 5, 40, 0, 0, 30, 0, 20, 5]),                     # Case 4\n    ]\n\n    def standard_normal_cdf(x):\n        \"\"\"\n        Computes the standard normal CDF using the error function erf.\n        Phi(z) = 0.5 * (1 + erf(z / sqrt(2)))\n        \"\"\"\n        return 0.5 * (1.0 + erf(x / np.sqrt(2.0)))\n\n    def calculate_bin_probabilities(weights, std_devs, means, bin_edges):\n        \"\"\"\n        Calculates the multinomial probability vector for a given class.\n        \n        Args:\n            weights (np.ndarray): Mixture weights for the class.\n            std_devs (np.ndarray): Standard deviations for the class.\n            means (np.ndarray): Component means.\n            bin_edges (np.ndarray): Edges of the fragment length bins.\n\n        Returns:\n            np.ndarray: A vector of bin probabilities.\n        \"\"\"\n        num_bins = len(bin_edges) - 1\n        unnormalized_probs = np.zeros(num_bins, dtype=np.float64)\n\n        for i in range(num_bins):\n            b_low = bin_edges[i]\n            b_high = bin_edges[i+1]\n            bin_integral = 0.0\n            \n            for k in range(len(means)):\n                mu_k = means[k]\n                sigma_k = std_devs[k]\n                w_k = weights[k]\n\n                # Integral of Gaussian PDF over [b_low, b_high]\n                # is CDF(b_high) - CDF(b_low)\n                z_high = (b_high - mu_k) / sigma_k\n                z_low = (b_low - mu_k) / sigma_k\n                \n                component_integral = standard_normal_cdf(z_high) - standard_normal_cdf(z_low)\n                \n                bin_integral += w_k * component_integral\n            \n            unnormalized_probs[i] = bin_integral\n\n        # Normalize probabilities to sum to 1 over the specified bins\n        total_prob_mass = np.sum(unnormalized_probs)\n        if total_prob_mass > 0:\n            return unnormalized_probs / total_prob_mass\n        else:\n            # This case should not happen with the given positive parameters\n            return unnormalized_probs\n\n    # 2. Calculate the probability vectors p_H and p_T\n    p_H = calculate_bin_probabilities(weights_H, std_devs_H, means, bin_edges)\n    p_T = calculate_bin_probabilities(weights_T, std_devs_T, means, bin_edges)\n\n    # 3. Classify each test case\n    results = []\n    for counts in test_cases:\n        # Using np.log1p on probabilities could be safer for very small probs near 0,\n        # but here they are integrals of positive functions over non-zero intervals,\n        # so they should be robustly > 0.\n        # Handle cases where counts[i] == 0, where `counts * log(p)` would be `0 * -inf = nan`.\n        # We can use np.where to ensure the term is 0.\n        log_likelihood_H = np.sum(counts * np.where(p_H > 0, np.log(p_H), -np.inf))\n        log_likelihood_T = np.sum(counts * np.where(p_T > 0, np.log(p_T), -np.inf))\n        \n        # Classify as Healthy (H) if its log-likelihood is greater.\n        is_healthy = log_likelihood_H > log_likelihood_T\n        results.append(is_healthy)\n\n    # 4. Print the final output in the required format\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "2378288"}, {"introduction": "在从宏观上理解了样本特性之后，我们可以进一步沿着基因组坐标，在微观尺度上解读 ATAC-seq 数据。染色质的状态并非一成不变，而是沿着基因组动态变化的，形成不同的结构域，如开放区域、核小体阵列或异染色质。本练习将引导您应用隐马尔可夫模型（Hidden Markov Model, HMM），这是一种强大的序列分析工具，根据 ATAC-seq 的局部特征（如片段密度和长度）将基因组自动分割为不同的染色质状态。通过这个练习，您将学会如何从原始信号中生成基因组范围内的染色质结构图谱 [@problem_id:2378334]。", "problem": "给定一个简化的生成模型，用于描述沿一维基因组坐标系的转座酶可及性染色质测序(Assay for Transposase-Accessible Chromatin using sequencing, ATAC-seq)片段特征。目标是使用隐马尔可夫模型(HMM)，根据在每个基因组位置观察到的两个特征——以碱基对为单位的片段长度和局部片段密度（固定宽度窗口内的计数），将基因组分割为离散的染色质可及性状态。三个隐状态分别是：开放染色质、核小体阵列染色质和闭合染色质。每个状态会发射一个由一对值组成的观测值：片段长度（以碱基对为单位）和计数值（无量纲）。您的任务是实现Viterbi解码算法，在给定固定的HMM参数下，根据一个观测序列推断出最可能的隐状态序列。\n\n请从隐马尔可夫模型的核心定义出发，并假设在给定每个位置的隐状态的条件下，观测值是条件独立生成的。假设片段长度由高斯（正态）分布建模，计数值由泊松分布建模，并且在给定隐状态的条件下，这两个特征是独立的，因此联合发射概率是这两个分布的乘积。在您的设计中，请仅使用高斯密度函数和泊松概率质量函数的定义，以及用于状态转移的马尔可夫性质，来推导所需的动态规划递推关系。不要使用任何外部训练或参数估计；所有模型参数都在下方提供。\n\n模型规格：\n- 隐状态：开放染色质、核小体阵列染色质、闭合染色质，分别索引为 $0$、$1$ 和 $2$。\n- 初始状态概率：$\\pi = \\left[\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}\\right]$。\n- 状态转移矩阵 $A$（行代表当前状态，列代表下一个状态）：\n  - 从状态 $0$：转移到 $0$ 的概率为 $0.96$，转移到 $1$ 的概率为 $0.02$，转移到 $2$ 的概率为 $0.02$。\n  - 从状态 $1$：转移到 $0$ 的概率为 $0.02$，转移到 $1$ 的概率为 $0.96$，转移到 $2$ 的概率为 $0.02$。\n  - 从状态 $2$：转移到 $0$ 的概率为 $0.02$，转移到 $1$ 的概率为 $0.02$，转移到 $2$ 的概率为 $0.96$。\n- 每个状态 $s \\in \\{0,1,2\\}$ 的发射参数：\n  - 片段长度 $x$（以碱基对为单位）服从均值为 $\\mu_s$、标准差为 $\\sigma_s$ 的正态分布：\n    - 状态 $0$：$\\mu_0 = 50$，$\\sigma_0 = 15$。\n    - 状态 $1$：$\\mu_1 = 200$，$\\sigma_1 = 25$。\n    - 状态 $2$：$\\mu_2 = 300$，$\\sigma_2 = 40$。\n  - 计数值 $k$ 服从率参数为 $\\lambda_s$ 的泊松分布：\n    - 状态 $0$：$\\lambda_0 = 8$。\n    - 状态 $1$：$\\lambda_1 = 3$。\n    - 状态 $2$：$\\lambda_2 = 0.3$。\n- 给定隐状态下的特征条件独立性：对于给定状态 $s$，观测值 $(x,k)$ 的联合发射密度为 $p(x,k \\mid s) = p_{\\text{Normal}}(x \\mid \\mu_s,\\sigma_s) \\cdot p_{\\text{Poisson}}(k \\mid \\lambda_s)$。\n\n测试套件：\n- 测试用例 1（正常路径，长度 8；片段长度以碱基对为单位，计数值无量纲）：\n  - 观测值：$[(55, 9), (48, 7), (60, 8), (195, 3), (210, 4), (185, 3), (330, 0), (345, 1)]$。\n- 测试用例 2（边界条件，长度 1）：\n  - 观测值：$[(52, 8)]$。\n- 测试用例 3（转移行为，长度 5）：\n  - 观测值：$[(50, 8), (62, 7), (70, 6), (205, 4), (198, 3)]$。\n\n您的程序必须：\n- 为上述参数的给定HMM，仅使用正态密度函数、泊松概率质量函数的定义以及马尔可夫性质，在对数空间中实现数值稳定的Viterbi解码。\n- 将每个观测序列解码为最可能的状态序列，使用状态索引 $0$ 代表开放(accessible)，$1$ 代表核小体阵列(nucleosome-array)，$2$ 代表闭合(inaccessible)。\n- 生成单行输出，其中包含所有测试用例的已解码状态序列，格式为方括号括起来的、以逗号分隔的列表的列表。例如，格式必须像 $[\\,[s_{1,1}, s_{1,2}, \\dots],\\,[s_{2,1}, \\dots],\\,[s_{3,1}, \\dots]\\,]$，其中 $s_{i,j}$ 是整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个方括号括起来的、以逗号分隔的列表形式的结果，其中每个测试用例表示为一个整数列表，且不包含任何附加文本。例如：$[[0,0,1],[1],[2,2,2]]$。\n\n所有片段长度必须解释为碱基对，计数值无量纲，概率也无量纲。最终输出是代表状态索引的无量纲整数。", "solution": "所提出的问题是隐马尔可夫模型(HMM)的一个典型应用，即把一个观测序列分割成一个生成该序列的隐状态序列。具体来说，我们必须根据一个简化的ATAC-seq实验的一系列观测值，找到最可能的染色质可及性状态序列。完成此任务的合适算法是Viterbi算法，它通过动态规划找到这个最可能的状态序列。对数值稳定性的要求规定了所有计算都必须在对数空间中执行，以防止因许多小概率值相乘而导致的算术下溢。\n\n首先，我们将指定的隐马尔可夫模型的组成部分形式化。\n设隐状态集合为 $S = \\{s_0, s_1, s_2\\}$，分别对应于‘开放’(accessible)、‘核小体阵列’(nucleosome-array)和‘闭合’(inaccessible)染色质，由 $i, j \\in \\{0, 1, 2\\}$ 索引。\n观测序列为 $O = (o_1, o_2, \\ldots, o_T)$，其中 $T$ 是序列的长度。每个观测值 $o_t$ 是一个数对 $(x_t, k_t)$，其中 $x_t$ 是片段长度，$k_t$ 是局部片段计数。\n\nHMM由以下参数定义：\n1.  **初始状态概率 ($\\pi$)**：系统在初始时刻处于状态 $s_i$ 的概率为 $\\pi_i = P(q_1 = s_i)$。问题指定了一个均匀的初始分布：$\\pi = [\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3}]$。在对数空间中，对于所有 $i$，$\\log(\\pi_i) = -\\log(3)$。\n\n2.  **状态转移概率 ($A$)**：从状态 $s_i$ 转移到状态 $s_j$ 的概率为 $A_{ij} = P(q_{t+1} = s_j | q_t = s_i)$。给定的转移矩阵是：\n    $$\n    A = \\begin{pmatrix} 0.96 & 0.02 & 0.02 \\\\ 0.02 & 0.96 & 0.02 \\\\ 0.02 & 0.02 & 0.96 \\end{pmatrix}\n    $$\n    我们将使用对数概率矩阵 $\\log(A_{ij})$ 进行计算。\n\n3.  **发射概率 ($b$)**：当系统处于状态 $s_j$ 时，观测到 $o_t = (x_t, k_t)$ 的概率为 $b_j(o_t) = P(o_t | q_t = s_j)$。问题指出，给定状态，片段长度 $x_t$ 和计数值 $k_t$ 是条件独立的。因此，联合发射概率是各自概率的乘积：\n    $$\n    b_j(o_t) = P(x_t | q_t=s_j) \\cdot P(k_t | q_t=s_j)\n    $$\n    片段长度 $x_t$ 由正态（高斯）分布 $p_{\\text{Normal}}(x_t | \\mu_j, \\sigma_j)$ 建模，计数值 $k_t$ 由泊松分布 $p_{\\text{Poisson}}(k_t | \\lambda_j)$ 建模。这些参数是依赖于状态的：\n    -   状态 $s_0$：$\\mu_0 = 50$，$\\sigma_0 = 15$，$\\lambda_0 = 8$。\n    -   状态 $s_1$：$\\mu_1 = 200$，$\\sigma_1 = 25$，$\\lambda_1 = 3$。\n    -   状态 $s_2$：$\\mu_2 = 300$，$\\sigma_2 = 40$，$\\lambda_2 = 0.3$。\n\n发射概率的对数是两个分布的对数概率之和：\n$$\n\\log(b_j(x_t, k_t)) = \\log(p_{\\text{Normal}}(x_t | \\mu_j, \\sigma_j)) + \\log(p_{\\text{Poisson}}(k_t | \\lambda_j))\n$$\n正态分布的对数概率密度函数是：\n$$\n\\log(p_{\\text{Normal}}(x | \\mu, \\sigma)) = -\\log(\\sigma\\sqrt{2\\pi}) - \\frac{(x - \\mu)^2}{2\\sigma^2} = -\\log(\\sigma) - \\frac{1}{2}\\log(2\\pi) - \\frac{(x - \\mu)^2}{2\\sigma^2}\n$$\n泊松分布的对数概率质量函数是：\n$$\n\\log(p_{\\text{Poisson}}(k | \\lambda)) = \\log\\left(\\frac{\\lambda^k e^{-\\lambda}}{k!}\\right) = k\\log(\\lambda) - \\lambda - \\log(k!)\n$$\n其中 $\\log(k!)$ 项在数值上计算为 $\\log(\\Gamma(k+1))$，$\\Gamma$ 是伽马函数。\n\nViterbi算法通过在状态-时间网格中寻找一条能使联合概率 $P(O, Q)$ 最大化的路径来找到最可能的状态序列 $Q^* = (q_1^*, q_2^*, \\ldots, q_T^*)$。在对数空间中，这等同于最大化对数概率之和。我们定义两个动态规划表：\n-   $V_t(j)$：长度为 $t$ 且结束于状态 $s_j$ 的最可能状态序列的对数概率。\n-   $\\psi_t(j)$：回溯指针，它存储了在时间 $t$ 结束于状态 $s_j$ 的路径的最可能前驱状态的索引。\n\n该算法分三步进行：\n1.  **初始化 ($t=1$)**：对每个状态 $j \\in \\{0, 1, 2\\}$，我们计算第一个观测值的对数概率：\n    $$\n    V_1(j) = \\log(\\pi_j) + \\log(b_j(o_1))\n    $$\n    第一步不需要回溯指针 $\\psi_1(j)$，可以初始化为 $0$。\n\n2.  **递推 ($t=2, \\ldots, T$)**：我们遍历每个时间步和每个状态，从时间 $t-1$ 延伸最可能的路径。对每个状态 $j \\in \\{0, 1, 2\\}$：\n    $$\n    V_t(j) = \\log(b_j(o_t)) + \\max_{i \\in \\{0,1,2\\}} \\left( V_{t-1}(i) + \\log(A_{ij}) \\right)\n    $$\n    $$\n    \\psi_t(j) = \\arg\\max_{i \\in \\{0,1,2\\}} \\left( V_{t-1}(i) + \\log(A_{ij}) \\right)\n    $$\n    此处，$\\max$ 函数内的求和对应于概率的乘法：$P(\\text{path to } i) \\cdot P(\\text{transition } i \\to j)$。最大化操作找到了在时间 $t$ 引导至状态 $j$ 的那条最可能的路径。\n\n3.  **终止与路径回溯**：在完成直至时间 $T$ 的表格计算后，最优路径的对数概率为 $P^* = \\max_{j \\in \\{0,1,2\\}} (V_T(j))$。路径的最终状态是：\n    $$\n    q_T^* = \\arg\\max_{j \\in \\{0,1,2\\}} (V_T(j))\n    $$\n    然后我们从这个最终状态回溯以重构整个路径。对于 $t = T-1$ 递减到 $1$：\n    $$\n    q_t^* = \\psi_{t+1}(q_{t+1}^*)\n    $$\n    这样就得到了最优状态序列 $Q^* = (q_1^*, \\ldots, q_T^*)$。对提供的每个测试用例都执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Implements the Viterbi algorithm in log-space to decode HMM state sequences\n    for chromatin accessibility from ATAC-seq features.\n    \"\"\"\n    # HMM parameters defined in the problem statement.\n    # States: 0: accessible, 1: nucleosome-array, 2: inaccessible\n    \n    # Initial probabilities (log-space)\n    pi = np.array([1/3, 1/3, 1/3])\n    log_pi = np.log(pi)\n\n    # Transition matrix (log-space)\n    A = np.array([\n        [0.96, 0.02, 0.02],\n        [0.02, 0.96, 0.02],\n        [0.02, 0.02, 0.96]\n    ])\n    log_A = np.log(A)\n\n    # Emission parameters\n    mus = np.array([50.0, 200.0, 300.0])      # Means for Gaussian (fragment length)\n    sigmas = np.array([15.0, 25.0, 40.0])    # Stds for Gaussian\n    lambdas = np.array([8.0, 3.0, 0.3])      # Rates for Poisson (counts)\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Test case 1 (happy path, length 8)\n        [(55, 9), (48, 7), (60, 8), (195, 3), (210, 4), (185, 3), (330, 0), (345, 1)],\n        # Test case 2 (boundary condition, length 1)\n        [(52, 8)],\n        # Test case 3 (transition behavior, length 5)\n        [(50, 8), (62, 7), (70, 6), (205, 4), (198, 3)]\n    ]\n\n    def log_emission_prob(obs, state_idx):\n        \"\"\"\n        Calculates the log-probability of an observation given a state.\n        The observation is a tuple (fragment_length, count).\n        \"\"\"\n        x, k = obs\n        \n        # Log-PDF of Normal distribution for fragment length x\n        mu = mus[state_idx]\n        sigma = sigmas[state_idx]\n        log_p_normal = -np.log(sigma) - 0.5 * np.log(2 * np.pi) - ((x - mu)**2) / (2 * sigma**2)\n        \n        # Log-PMF of Poisson distribution for count k\n        lambda_ = lambdas[state_idx]\n        # Use gammaln(k + 1) for log(k!) which is numerically stable\n        log_p_poisson = k * np.log(lambda_) - lambda_ - gammaln(k + 1)\n        \n        return log_p_normal + log_p_poisson\n\n    results = []\n    for observations in test_cases:\n        T = len(observations)\n        N = len(pi)  # Number of states\n        \n        # Dynamic programming tables\n        # Viterbi table V stores log-probabilities\n        V = np.zeros((T, N))\n        # Backpointer table psi stores the previous state index\n        psi = np.zeros((T, N), dtype=int)\n        \n        # Initialization step (t=0)\n        for j in range(N):\n            V[0, j] = log_pi[j] + log_emission_prob(observations[0], j)\n        \n        # Recursion step (t=1 to T-1)\n        for t in range(1, T):\n            for j in range(N):\n                # Calculate the log-probabilities of reaching state j from any previous state i\n                prev_log_probs = V[t-1, :] + log_A[:, j]\n                \n                # Find the maximum log-probability and the originating state\n                max_log_prob = np.max(prev_log_probs)\n                argmax_state = np.argmax(prev_log_probs)\n                \n                # Update tables with the maximum probability and backpointer\n                V[t, j] = max_log_prob + log_emission_prob(observations[t], j)\n                psi[t, j] = argmax_state\n        \n        # Termination and Backtracking\n        path = np.zeros(T, dtype=int)\n        \n        # Find the last state of the most likely path\n        path[T-1] = np.argmax(V[T-1, :])\n        \n        # Backtrack to reconstruct the full path\n        for t in range(T-2, -1, -1):\n            path[t] = psi[t+1, path[t+1]]\n            \n        results.append(path.tolist())\n\n    # Format the final output to match the specified format \"[[i,j,...],[k,...]]\"\n    output_str = '[' + ','.join(str(r) for r in results) + ']'\n    final_output_str = output_str.replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n\n```", "id": "2378334"}, {"introduction": "为了更深入地理解基因调控，我们需要将染色质可及性信息与 DNA 序列信息相结合，以预测**特定**功能事件，例如转录因子（TF）的结合。TF 的结合既需要开放的染色质环境，也依赖于 DNA 序列中是否存在特定的结合基序（motif）。这个实践将模拟一个简化的双分支神经网络，它同时处理 ATAC-seq 信号和 DNA 序列，以预测 TF 的结合概率。通过这个练习，您将亲身体验现代深度学习模型在调控基因组学中整合多维数据的基本原理 [@problem_id:2378286]。", "problem": "您将获得一个用于转录因子 (TF) 结合的双分支预测模型的形式化描述，该模型使用转座酶可及性染色质测序 (ATAC-seq) 数据。该模型对一个固定长度的基因组位点进行操作，并结合了一个序列基序检测器和一个可及性峰值检测器。任务是根据下文的数学规范，为一组固定的输入计算预测的 TF 结合概率，并以单一的、指定的格式输出结果。\n\n输入与编码。设位点长度为 $L=8$。DNA 序列是一个长度为 $L$ 的字符串，其字母表为 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。它被编码为一个 one-hot 矩阵 $S \\in \\{0,1\\}^{L \\times 4}$，使用的列顺序为 $(\\text{A},\\text{C},\\text{G},\\text{T})$。具体来说，如果位置 $i$ 处的碱基是 $\\text{A}$，则 $S_{i,0}=1$ 且 $S_{i,1}=S_{i,2}=S_{i,3}=0$，对于 $\\text{C},\\text{G},\\text{T}$ 也类似。ATAC-seq 信号是一个实值向量 $A \\in \\mathbb{R}_{\\ge 0}^{L}$，其条目为非负数，代表无单位的归一化可及性值。\n\nDNA 分支（基序检测器）。定义一个对 one-hot 序列进行的单滤波器一维卷积，滤波器长度为 $k_d=4$，无偏置。滤波器权重张量由一个位置相关矩阵 $W_d \\in \\mathbb{R}^{4 \\times 4}$ 表示，其中行 $j \\in \\{0,1,2,3\\}$ 对应于卷积核位置 $j$，列对应于碱基顺序 $(\\text{A},\\text{C},\\text{G},\\text{T})$。$W_d$ 的条目如下：\n- 对于 $j=0$: $(-1,-1,-1,2)$，\n- 对于 $j=1$: $(-1,-1,2,-1)$，\n- 对于 $j=2$: $(-1,2,-1,-1)$，\n- 对于 $j=3$: $(2,-1,-1,-1)$。\n对于每个有效的起始索引 $i \\in \\{0,1,\\dots,L-k_d\\}$，计算激活前得分\n$$\nu_d(i) \\;=\\; \\sum_{j=0}^{k_d-1} \\sum_{b=0}^{3} W_d[j,b] \\, S_{i+j,b}.\n$$\n通过 $f_d(i)=\\max\\{0,u_d(i)\\}$ 定义整流后的特征图，并通过 $h_d = \\max_{i} f_d(i)$ 定义池化后的 DNA 特征。\n\nATAC 分支（峰值检测器）。定义一个对 ATAC-seq 信号进行的单滤波器一维卷积，滤波器长度为 $k_a=3$，无偏置。滤波器权重向量为 $w_a = (-0.5,\\,1.0,\\,-0.5) \\in \\mathbb{R}^{3}$。对于每个有效的起始索引 $i \\in \\{0,1,\\dots,L-k_a\\}$，计算\n$$\nu_a(i) \\;=\\; \\sum_{j=0}^{k_a-1} w_a[j] \\, A_{i+j}.\n$$\n通过 $f_a(i)=\\max\\{0,u_a(i)\\}$ 定义整流后的特征图，并通过 $h_a = \\max_{i} f_a(i)$ 定义池化后的 ATAC 特征。\n\n输出层（结合概率）。通过一个线性形式将池化后的特征组合起来，其权重为 $w_d=0.6$，$w_a=0.4$，偏置为 $b=-2.0$，以获得 logit\n$$\nz \\;=\\; w_d \\, h_d \\;+\\; w_a \\, h_a \\;+\\; b \\;=\\; 0.6\\,h_d \\;+\\; 0.4\\,h_a \\;-\\; 2.0.\n$$\n使用 logistic 函数将 logit 映射为概率\n$$\n\\hat{p} \\;=\\; \\sigma(z) \\;=\\; \\frac{1}{1+\\exp(-z)}.\n$$\n所有概率必须以小数形式报告，并四舍五入到恰好 $6$ 位小数。\n\n测试套件。对于以下每个案例，使用 $L=8$ 并根据上述定义计算 $\\hat{p}$。\n- 案例 1：序列 $\\text{\"AACTGCAA\"}$；ATAC 向量 $[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- 案例 2：序列 $\\text{\"AACTGCAA\"}$；ATAC 向量 $[\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1\\,]$。\n- 案例 3：序列 $\\text{\"AAAAAAAA\"}$；ATAC 向量 $[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- 案例 4：序列 $\\text{\"CCCCCCCC\"}$；ATAC 向量 $[\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$。\n- 案例 5：序列 $\\text{\"ATGTAAAA\"}$；ATAC 向量 $[\\,1.0,\\,2.0,\\,3.0,\\,3.0,\\,3.0,\\,2.0,\\,1.0,\\,1.0\\,]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含从案例 1 到案例 5 的 5 个结果，形式为一个用方括号括起来的逗号分隔列表，每个值都四舍五入到恰好 6 位小数（例如，$[x_1,x_2,x_3,x_4,x_5]$）。", "solution": "该问题要求为五个不同的测试案例计算预测的 TF 结合概率 $\\hat{p}$。模型由两个并行分支组成——一个处理 DNA 序列，另一个处理 ATAC-seq 信号——随后是一个整合它们输出的输出层。\n\n模型由以下参数定义：\n- 位点长度：$L=8$。\n- DNA 分支卷积滤波器长度：$k_d=4$。\n- ATAC 分支卷积滤波器长度：$k_a=3$。\n- DNA 滤波器权重，$W_d \\in \\mathbb{R}^{4 \\times 4}$，其中列对应于碱基 $(\\text{A},\\text{C},\\text{G},\\text{T})$：\n$$W_d = \\begin{pmatrix} -1 & -1 & -1 & 2 \\\\ -1 & -1 & 2 & -1 \\\\ -1 & 2 & -1 & -1 \\\\ 2 & -1 & -1 & -1 \\end{pmatrix}$$\n- ATAC 滤波器权重，$w_a \\in \\mathbb{R}^{3}$: $w_a = (-0.5, 1.0, -0.5)$。\n- 输出层权重：$w_d=0.6$ 用于 DNA 分支特征，$w_a=0.4$ 用于 ATAC 分支特征，以及一个偏置 $b=-2.0$。\n\n计算分三个阶段进行：DNA 分支、ATAC 分支和输出层。\n\n**1. DNA 分支（基序检测器）**\n该分支处理一个 one-hot 编码的 DNA 序列 $S \\in \\{0,1\\}^{L \\times 4}$。应用一个带滤波器 $W_d$ 的一维卷积。对于每个起始位置 $i \\in \\{0, \\dots, L-k_d\\}$，激活前得分计算如下：\n$$u_d(i) \\;=\\; \\sum_{j=0}^{k_d-1} \\sum_{b=0}^{3} W_d[j,b] \\, S_{i+j,b}$$\n这实际上是一个滑动窗口操作，对于序列的每个窗口，我们将该窗口中存在的碱基所对应的滤波器权重相加。让我们将位置 $k$ 处的碱基表示为 $\\text{seq}[k]$。得分为 $u_d(i) = \\sum_{j=0}^{k_d-1} W_d[j, \\text{base\\_map}(\\text{seq}[i+j])]$，其中 $\\text{base\\_map}$ 将碱基字符转换为其对应的列索引 $(\\text{A}\\to0, \\text{C}\\to1, \\text{G}\\to2, \\text{T}\\to3)$。应用一个整流线性单元 (ReLU) 激活 $f_d(i)=\\max\\{0,u_d(i)\\}$，然后对所有位置进行最大池化，以生成最终的 DNA 特征 $h_d = \\max_{i} f_d(i)$。\n\n**2. ATAC 分支（峰值检测器）**\n该分支处理 ATAC-seq 信号向量 $A \\in \\mathbb{R}_{\\ge 0}^{L}$。应用一个带滤波器 $w_a$ 的一维卷积。对于每个起始位置 $i \\in \\{0, \\dots, L-k_a\\}$，激活前得分为：\n$$u_a(i) \\;=\\; \\sum_{j=0}^{k_a-1} w_a[j] \\, A_{i+j}$$\n此操作是滤波器 $w_a$ 与 $A$ 的子向量之间的滑动点积。与 DNA 分支类似，应用一个 ReLU 激活 $f_a(i)=\\max\\{0,u_a(i)\\}$，然后进行最大池化以获得最终的 ATAC 特征 $h_a = \\max_{i} f_a(i)$。\n\n**3. 输出层（结合概率）**\n来自两个分支的特征 $h_d$ 和 $h_a$ 被线性组合以产生一个 logit 得分，$z$：\n$$z \\;=\\; 0.6\\,h_d \\;+\\; 0.4\\,h_a \\;-\\; 2.0$$\n然后使用 logistic (sigmoid) 函数将此 logit 转换为概率 $\\hat{p}$：\n$$\\hat{p} \\;=\\; \\sigma(z) \\;=\\; \\frac{1}{1+\\exp(-z)}$$\n\n现在我们将此过程应用于五个测试案例中的每一个。\n\n**案例 1：**\n- 序列：$\\text{\"AACTGCAA\"}$，ATAC：$[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- DNA 分支：卷积窗口为 $\\text{AACT}, \\text{ACTG}, \\text{CTGC}, \\text{TGCA}, \\text{GCAA}$。对于 $i \\in \\{0, \\dots, 4\\}$，激活前得分 $u_d(i)$ 为 $[-1, -4, -4, 8, -1]$。经过 ReLU 后，特征图为 $f_d = [0, 0, 0, 8, 0]$。最大池化得到 $h_d=8$。\n- ATAC 分支：对于 $i \\in \\{0, \\dots, 5\\}$，激活前得分 $u_a(i)$ 为 $[-2.35, 0.4, 4.0, 0.4, -2.35, -0.05]$。经过 ReLU 后，特征图为 $f_a = [0, 0.4, 4.0, 0.4, 0, 0]$。最大池化得到 $h_a=4.0$。\n- 输出：$z = 0.6(8) + 0.4(4.0) - 2.0 = 4.8 + 1.6 - 2.0 = 4.4$。$\\hat{p} = \\sigma(4.4) \\approx 0.987870$。\n\n**案例 2：**\n- 序列：$\\text{\"AACTGCAA\"}$，ATAC：$[\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1\\,]$。\n- DNA 分支：与案例 1 相同，所以 $h_d=8$。\n- ATAC 分支：平坦的 ATAC 信号导致所有 $i \\in \\{0, \\dots, 5\\}$ 的激活前得分 $u_a(i)=0$，因为 $\\sum w_a[j] = -0.5+1.0-0.5=0$。因此，$h_a=0$。\n- 输出：$z = 0.6(8) + 0.4(0) - 2.0 = 4.8 - 2.0 = 2.8$。$\\hat{p} = \\sigma(2.8) \\approx 0.942676$。\n\n**案例 3：**\n- 序列：$\\text{\"AAAAAAAA\"}$，ATAC：$[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- DNA 分支：所有卷积窗口都是 $\\text{AAAA}$。激活前得分对于所有 $i$ 均为 $u_d(i) = -1-1-1+2 = -1$。经过 ReLU 后，所有特征值均为 $0$，所以 $h_d=0$。\n- ATAC 分支：与案例 1 相同，所以 $h_a=4.0$。\n- 输出：$z = 0.6(0) + 0.4(4.0) - 2.0 = 1.6 - 2.0 = -0.4$。$\\hat{p} = \\sigma(-0.4) \\approx 0.401312$。\n\n**案例 4：**\n- 序列：$\\text{\"CCCCCCCC\"}$，ATAC：$[\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$。\n- DNA 分支：所有卷积窗口都是 $\\text{CCCC}$。激活前得分对于所有 $i$ 均为 $u_d(i) = -1-1+2-1 = -1$。经过 ReLU 后，所有特征值均为 $0$，所以 $h_d=0$。\n- ATAC 分支：零值的 ATAC 信号导致所有 $i$ 的激活前得分 $u_a(i)=0$。因此，$h_a=0$。\n- 输出：$z = 0.6(0) + 0.4(0) - 2.0 = -2.0$。$\\hat{p} = \\sigma(-2.0) \\approx 0.119203$。\n\n**案例 5：**\n- 序列：$\\text{\"ATGTAAAA\"}$，ATAC：$[\\,1.0,\\,2.0,\\,3.0,\\,3.0,\\,3.0,\\,2.0,\\,1.0,\\,1.0\\,]$。\n- DNA 分支：卷积窗口为 $\\text{ATGT}, \\text{TGTA}, \\text{GTAA}, \\text{TAAA}, \\text{AAAA}$。激活前得分为 $u_d = [-4, 5, -1, 2, -1]$。经过 ReLU 后，$f_d = [0, 5, 0, 2, 0]$。最大池化得到 $h_d=5$。\n- ATAC 分支：激活前得分为 $u_a = [0, 0.5, 0, 0.5, 0, -0.5]$。经过 ReLU 后，$f_a = [0, 0.5, 0, 0.5, 0, 0]$。最大池化得到 $h_a=0.5$。\n- 输出：$z = 0.6(5) + 0.4(0.5) - 2.0 = 3.0 + 0.2 - 2.0 = 1.2$。$\\hat{p} = \\sigma(1.2) \\approx 0.768525$。\n\n最终的概率，四舍五入到 6 位小数，是：\n- 案例 1: $0.987870$\n- 案例 2: $0.942676$\n- 案例 3: $0.401312$\n- 案例 4: $0.119203$\n- 案例 5: $0.768525$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the TF-binding probabilities for a set of test cases\n    based on the specified two-branch predictive model.\n    \"\"\"\n\n    # --- Model Parameters ---\n    L = 8\n    \n    # DNA Branch Parameters\n    k_d = 4\n    W_d = np.array([\n        [-1, -1, -1, 2],  # j=0, for (A, C, G, T)\n        [-1, -1, 2, -1],  # j=1\n        [-1, 2, -1, -1],  # j=2\n        [2, -1, -1, -1]   # j=3\n    ])\n    base_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # ATAC Branch Parameters\n    k_a = 3\n    w_a_filter = np.array([-0.5, 1.0, -0.5])\n\n    # Output Layer Parameters\n    w_d_out = 0.6\n    w_a_out = 0.4\n    b_out = -2.0\n\n    # --- Test Suite ---\n    test_cases = [\n        (\"AACTGCAA\", [0.1, 0.2, 5.0, 9.0, 5.0, 0.2, 0.1, 0.1]),\n        (\"AACTGCAA\", [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]),\n        (\"AAAAAAAA\", [0.1, 0.2, 5.0, 9.0, 5.0, 0.2, 0.1, 0.1]),\n        (\"CCCCCCCC\", [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),\n        (\"ATGTAAAA\", [1.0, 2.0, 3.0, 3.0, 3.0, 2.0, 1.0, 1.0]),\n    ]\n\n    results = []\n\n    for seq, atac_signal in test_cases:\n        # --- DNA Branch Computation ---\n        u_d = []\n        num_dna_windows = L - k_d + 1\n        for i in range(num_dna_windows):\n            window_seq = seq[i : i + k_d]\n            score = 0\n            for j in range(k_d):\n                base = window_seq[j]\n                base_idx = base_map[base]\n                score += W_d[j, base_idx]\n            u_d.append(score)\n        \n        f_d = np.maximum(0, np.array(u_d))\n        h_d = np.max(f_d)\n\n        # --- ATAC Branch Computation ---\n        atac_signal_np = np.array(atac_signal)\n        u_a = []\n        num_atac_windows = L - k_a + 1\n        for i in range(num_atac_windows):\n            window_atac = atac_signal_np[i : i + k_a]\n            score = np.dot(window_atac, w_a_filter)\n            u_a.append(score)\n\n        f_a = np.maximum(0, np.array(u_a))\n        h_a = np.max(f_a) if len(f_a) > 0 else 0\n\n        # --- Output Layer Computation ---\n        z = w_d_out * h_d + w_a_out * h_a + b_out\n        p_hat = 1 / (1 + np.exp(-z))\n        \n        # Format result and append\n        results.append(f\"{p_hat:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2378286"}]}