{"hands_on_practices": [{"introduction": "与古DNA打交道的第一步是确认其真实性，而特征性损伤模式是关键证据。本练习将指导您编写一个程序，以从简化的比对数据中提取用于生成错配图谱的原始数据 [@problem_id:2372718]。通过亲手实践，您将学会如何量化古DNA最显著的信号——在DNA片段末端升高的胞嘧啶（C）到胸腺嘧啶（T）的替换，这是古基因组学分析中的一项基本技能。", "problem": "您需要实现一个程序，该程序根据简化的、完全比对的读段来计算古脱氧核糖核酸（DNA）分析中错配图谱的原始数据，这些数据适用于模拟古DNA损伤。在一个典型的二进制比对/图谱（BAM）文件中，读段与参考基因组之间的错配被用来量化替换频率，这些频率是读段 $5'$ 端和 $3'$ 端距离的函数。对于此问题，您将获得简化的比对记录，以代替实际的BAM文件。每个比对记录包含三个字段：一个读段核苷酸字符串，一个等长的参考核苷酸字符串，以及一个链指示符。只表示匹配和错配；没有缺口、插入或删除。\n\n定义：\n- 每个碱基是 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$中的一个。\n- 链是 $\\texttt{'+'}$ 或 $\\texttt{'-'}$。对于 $\\texttt{'+'}$ 链， $5'$ 端在索引 $0$ 处；对于 $\\texttt{'-'}$ 链， $5'$ 端在索引 $L-1$ 处，其中 $L$ 是读段长度。对于 $\\texttt{'+'}$ 链， $3'$ 端在索引 $L-1$ 处；对于 $\\texttt{'-'}$ 链， $3'$ 端在索引 $0$ 处。\n- 对于一个比对位置索引 $i$，$0 \\le i \\le L-1$，定义其与 $5'$ 端的距离为：对于 $\\texttt{'+'}$ 链，$d_{5} = i$；对于 $\\texttt{'-'}$ 链，$d_{5} = L-1-i$。定义其与 $3'$ 端的距离为：对于 $\\texttt{'+'}$ 链，$d_{3} = L-1-i$；对于 $\\texttt{'-'}$ 链，$d_{3} = i$。\n- 一个替换类型是一个有序对 $\\text{X}\\to\\text{Y}$，其中 $\\text{X},\\text{Y}\\in\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 且 $\\text{X}\\ne\\text{Y}$，解释为在同一比对位置上的参考碱基 $\\text{X}$ 和读段碱基 $\\text{Y}$。\n- 对于与 $5'$ 端（或 $3'$ 端）的每个距离 $d$，设 $N_{5}(d)$ （或 $N_{3}(d)$）为所有读段中与该端距离等于 $d$ 且读段和参考碱基都在 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 中的比对位置的总数。对于一个特定的替换类型 $\\text{X}\\to\\text{Y}$，设 $C^{\\text{X}\\to\\text{Y}}_{5}(d)$ （或 $C^{\\text{X}\\to\\text{Y}}_{3}(d)$）为在距离 $d$ 处表现出该替换的此类位置的数量。定义在与 $5'$ 端距离为 $d$ 处 $\\text{X}\\to\\text{Y}$ 的频率为 $f^{\\text{X}\\to\\text{Y}}_{5}(d) = C^{\\text{X}\\to\\text{Y}}_{5}(d) / N_{5}(d)$，类似地，$f^{\\text{X}\\to\\text{Y}}_{3}(d) = C^{\\text{X}\\to\\text{Y}}_{3}(d) / N_{3}(d)$。如果 $N_{5}(d) = 0$ （或 $N_{3}(d) = 0$），则定义 $f^{\\text{X}\\to\\text{Y}}_{5}(d) = 0$ （或 $f^{\\text{X}\\to\\text{Y}}_{3}(d) = 0$）。\n- 在与某一端给定距离 $d$ 处的总错配频率是所有 $\\text{X}\\ne\\text{Y}$ 的 $f^{\\text{X}\\to\\text{Y}}_{\\cdot}(d)$ 的总和，其中 $\\cdot$ 表示 $5$ 或 $3$。\n\n您的程序必须根据提供的比对记录测试套件，计算所有12种可能的替换类型的错配频率，这些频率是如上定义的 $d_{5}$ 和 $d_{3}$ 的函数。然后，对于每个测试用例，提取下面描述的特定标量值，并将所有结果打印在单行中。\n\n测试套件（三个独立的数据集），其中每个比对记录是一个三元组 $(\\text{读段}, \\text{参考}, \\text{链})$：\n\n- 测试用例 1（在末端附近有错配的一般情况）：\n  1. $(\\text{TAGTC}, \\text{CAGTC}, \\texttt{'+'})$\n  2. $(\\text{GGCCT}, \\text{GGCCC}, \\texttt{'-'})$\n  3. $(\\text{ATCGA}, \\text{ATCGG}, \\texttt{'+'})$\n  4. $(\\text{ATTTA}, \\text{GTTTA}, \\texttt{'-'})$\n\n- 测试用例 2（在较大距离处没有覆盖的边界条件）：\n  1. $(\\text{CAGT}, \\text{CAGT}, \\texttt{'+'})$\n  2. $(\\text{TGCA}, \\text{TGCA}, \\texttt{'-'})$\n\n- 测试用例 3（没有错配的边缘情况）：\n  1. $(\\text{ACGT}, \\text{ACGT}, \\texttt{'+'})$\n  2. $(\\text{GGGG}, \\text{GGGG}, \\texttt{'-'})$\n\n需要计算和报告的输出，按此确切顺序列出，作为实数：\n- 来自测试用例 1：\n  1. $f^{\\text{C}\\to\\text{T}}_{5}(0)$。\n  2. $f^{\\text{G}\\to\\text{A}}_{3}(0)$。\n  3. 在 $5'$ 端距离 0 处的总错配频率，即 $\\sum_{\\text{X}\\ne\\text{Y}} f^{\\text{X}\\to\\text{Y}}_{5}(0)$。\n\n- 来自测试用例 2：\n  4. $f^{\\text{C}\\to\\text{T}}_{5}(10)$。\n\n- 来自测试用例 3：\n  5. 在 $5'$ 端距离 0 处的总错配频率。\n  6. $f^{\\text{G}\\to\\text{A}}_{3}(0)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{结果}_{1},\\text{结果}_{2},\\dots]$）。不涉及物理单位。所有数值必须以十进制数输出。如果分母 $N_{5}(d)$ 或 $N_{3}(d)$ 等于 $0$，根据定义，相应的频率必须报告为 $0$。", "solution": "该问题陈述已经过严格验证，并被确定是合理的。这是一个在计算生物学领域中定义明确、有科学依据的问题，具体涉及古DNA损伤模式的分析。所有定义在数学上都是精确的，提供的数据是一致的，目标是明确的。任务是形式化并实现一个标准算法，用于从简化的比对数据中量化核苷酸错配频率。\n\n该解决方案通过一个系统性的、两阶段的计算过程来实现。第一阶段涉及从原始比对数据中聚合计数。第二阶段根据这些聚合的计数计算所需的频率。\n\n**1. 用于计数聚合的数据结构**\n\n为了高效地存储必要的计数，我们采用了两个主要的数据结构，一个用于 $5'$ 端，一个用于 $3'$ 端。每个结构都是一个字典，将整数距离 $d$ 映射到一个聚合数据记录。该记录包含两个部分：\n- 一个标量整数 $N(d)$，表示在距相应末端距离为 $d$ 处观察到的核苷酸位置总数。\n- 一个 $4 \\times 4$ 矩阵 $C(d)$，其中条目 $C_{\\text{X},\\text{Y}}(d)$ 存储在距离 $d$ 处观察到从参考碱基 $\\text{X}$ 到读段碱基 $\\text{Y}$ 的替换次数。对于此矩阵表示，碱基 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 映射到索引 $\\{0, 1, 2, 3\\}$。\n\n我们将这些结构表示为 $\\mathcal{D}_5$ 和 $\\mathcal{D}_3$。因此，对于与 $5'$ 端的距离 $d$，相应的条目是 $\\mathcal{D}_5[d] = (N_5(d), C_5(d))$。\n\n**2. 算法流程**\n\n**阶段 1：聚合计数**\n算法遍历每个提供的比对记录，这是一个（读段序列、参考序列、链）的三元组。对于比对中的每个位置 $i$（从 $0$ 到 $L-1$，其中 $L$ 是读段长度），执行以下步骤：\n1. 根据位置 $i$ 和链的方向计算与 $5'$ 和 $3'$ 端的距离 $d_5$ 和 $d_3$。\n   - 对于 $\\texttt{'+'}$ 链读段：$d_5 = i$ 且 $d_3 = L-1-i$。\n   - 对于 $\\texttt{'-'}$ 链读段：$d_5 = L-1-i$ 且 $d_3 = i$。\n2. 为计算出的距离递增总碱基计数：$N_5(d_5) \\mathrel{+}= 1$ 和 $N_3(d_3) \\mathrel{+}= 1$。\n3. 比较位置 $i$ 处的参考碱基 $\\text{X}$ 和读段碱基 $\\text{Y}$。如果它们不同（$\\text{X} \\neq \\text{Y}$），则表示一次替换。矩阵 $C_5(d_5)$ 和 $C_3(d_3)$ 中相应的替换计数器会递增。具体来说，$C_{5, \\text{X},\\text{Y}}(d_5) \\mathrel{+}= 1$ 和 $C_{3, \\text{X},\\text{Y}}(d_3) \\mathrel{+}= 1$。\n\n遍历所有读段的所有位置后，字典 $\\mathcal{D}_5$ 和 $\\mathcal{D}_3$ 包含了计算频率所需的完整聚合计数。\n\n**阶段 2：计算频率**\n有了聚合的计数，任何指定的频率都可以直接根据其定义进行计算。\n- 在与 $5'$ 端距离为 $d$ 处，特定替换 $\\text{X}\\to\\text{Y}$ 的频率由以下公式给出：\n  $$f^{\\text{X}\\to\\text{Y}}_{5}(d) = \\frac{C_{5, \\text{X},\\text{Y}}(d)}{N_5(d)}$$\n  类似的公式适用于 $3'$ 端。根据规定，如果 $N_5(d) = 0$ （或 $N_3(d)=0$），则频率定义为 $0$。\n- 在距离 $d$ 处的总错配频率是该距离处所有单个替换频率的总和：\n  $$\\sum_{\\text{X}\\ne\\text{Y}} f^{\\text{X}\\to\\text{Y}}_{5}(d) = \\frac{\\sum_{\\text{X}\\ne\\text{Y}} C_{5, \\text{X},\\text{Y}}(d)}{N_5(d)}$$\n  这相当于在距离 $d$ 处观察到的错配总数除以在同一距离处观察到的碱基总数。\n\n**测试用例 1 的计算示例**\n让我们从测试用例 1 中计算第一个所需值 $f^{\\text{C}\\to\\text{T}}_{5}(0)$。\n相关距离为 $d_5=0$。我们必须首先找到 $N_5(0)$ 和 $C_{5, \\text{C},\\text{T}}(0)$。我们检查 4 个读段中每一个对该距离的贡献。\n- 读段 1：$(\\text{TAGTC}, \\text{CAGTC}, \\texttt{'+'})$。链是 $\\texttt{'+'}$，所以 $d_5=0$ 对应索引 $i=0$。在 $i=0$ 处，我们有 ref='C', read='T'，这是一次 $\\text{C}\\to\\text{T}$ 替换。\n- 读段 2：$(\\text{GGCCT}, \\text{GGCCC}, \\texttt{'-'})$。链是 $\\texttt{'-'}$，所以 $d_5=0$ 对应索引 $i=L-1=4$。在 $i=4$ 处，我们有 ref='C', read='T'，这是一次 $\\text{C}\\to\\text{T}$ 替换。\n- 读段 3：$(\\text{ATCGA}, \\text{ATCGG}, \\texttt{'+'})$。链是 $\\texttt{'+'}$，$d_5=0$ 对应 $i=0$。在 $i=0$ 处，我们有 ref='A', read='A'，这是一个匹配。\n- 读段 4：$(\\text{ATTTA}, \\text{GTTTA}, \\texttt{'-'})$。链是 $\\texttt{'-'}$，$d_5=0$ 对应 $i=L-1=4$。在 $i=4$ 处，我们有 ref='A', read='A'，这是一个匹配。\n\n根据此分析：\n- 在距离 $d_5=0$ 处的位置总数为 $N_5(0) = 4$。\n- 在此距离处的 $\\text{C}\\to\\text{T}$ 替换总数为 $C_{5, \\text{C},\\text{T}}(0) = 2$。\n\n因此，频率为：\n$$f^{\\text{C}\\to\\text{T}}_{5}(0) = \\frac{C_{5, \\text{C},\\text{T}}(0)}{N_5(0)} = \\frac{2}{4} = 0.5$$\n\n其他所需值是通过将相同的严格程序应用于相应的测试用例和参数来计算的。这种有原则的方法确保了正确性和可重复性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the ancient DNA damage modeling problem by computing misincorporation frequencies.\n    \"\"\"\n    \n    BASE_TO_IDX = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    def compute_counts(records):\n        \"\"\"\n        Aggregates base and substitution counts from alignment records.\n\n        Args:\n            records: A list of tuples, where each tuple is (read_str, ref_str, strand_char).\n\n        Returns:\n            A tuple of two dictionaries (counts_5, counts_3).\n            Each dictionary maps distance `d` to a tuple `(N, C)`, where `N` is the\n            total base count and `C` is a 4x4 numpy array of substitution counts.\n        \"\"\"\n        counts_5 = defaultdict(lambda: [0, np.zeros((4, 4), dtype=int)])\n        counts_3 = defaultdict(lambda: [0, np.zeros((4, 4), dtype=int)])\n\n        for read, ref, strand in records:\n            read_len = len(read)\n            for i in range(read_len):\n                if strand == '+':\n                    d5 = i\n                    d3 = read_len - 1 - i\n                else:  # strand == '-'\n                    d5 = read_len - 1 - i\n                    d3 = i\n\n                ref_base = ref[i]\n                read_base = read[i]\n\n                # Update 5-prime counts\n                counts_5[d5][0] += 1\n                if ref_base != read_base:\n                    ref_idx = BASE_TO_IDX[ref_base]\n                    read_idx = BASE_TO_IDX[read_base]\n                    counts_5[d5][1][ref_idx, read_idx] += 1\n\n                # Update 3-prime counts\n                counts_3[d3][0] += 1\n                if ref_base != read_base:\n                    ref_idx = BASE_TO_IDX[ref_base]\n                    read_idx = BASE_TO_IDX[read_base]\n                    counts_3[d3][1][ref_idx, read_idx] += 1\n        \n        return dict(counts_5), dict(counts_3)\n\n    test_cases = [\n        # Test case 1\n        [\n            ('TAGTC', 'CAGTC', '+'),\n            ('GGCCT', 'GGCCC', '-'),\n            ('ATCGA', 'ATCGG', '+'),\n            ('ATTTA', 'GTTTA', '-')\n        ],\n        # Test case 2\n        [\n            ('CAGT', 'CAGT', '+'),\n            ('TGCA', 'TGCA', '-')\n        ],\n        # Test case 3\n        [\n            ('ACGT', 'ACGT', '+'),\n            ('GGGG', 'GGGG', '-')\n        ]\n    ]\n\n    results = []\n\n    # Process Test Case 1\n    counts_5_1, counts_3_1 = compute_counts(test_cases[0])\n    \n    # 1. f_C->T_5(0) for test case 1\n    n5_d0, c5_d0 = counts_5_1.get(0, (0, None))\n    if n5_d0 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['C'], BASE_TO_IDX['T']\n        res1 = c5_d0[ref_idx, read_idx] / n5_d0\n    else:\n        res1 = 0.0\n    results.append(res1)\n    \n    # 2. f_G->A_3(0) for test case 1\n    n3_d0, c3_d0 = counts_3_1.get(0, (0, None))\n    if n3_d0 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['G'], BASE_TO_IDX['A']\n        res2 = c3_d0[ref_idx, read_idx] / n3_d0\n    else:\n        res2 = 0.0\n    results.append(res2)\n\n    # 3. Total mismatch frequency at 5' distance 0 for test case 1\n    if n5_d0 > 0:\n        total_mismatches = c5_d0.sum()\n        res3 = total_mismatches / n5_d0\n    else:\n        res3 = 0.0\n    results.append(res3)\n\n    # Process Test Case 2\n    counts_5_2, _ = compute_counts(test_cases[1])\n    \n    # 4. f_C->T_5(10) for test case 2\n    n5_d10, c5_d10 = counts_5_2.get(10, (0, None))\n    if n5_d10 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['C'], BASE_TO_IDX['T']\n        res4 = c5_d10[ref_idx, read_idx] / n5_d10\n    else:\n        res4 = 0.0\n    results.append(res4)\n\n    # Process Test Case 3\n    counts_5_3, counts_3_3 = compute_counts(test_cases[2])\n    \n    # 5. Total mismatch frequency at 5' distance 0 for test case 3\n    n5_d0_3, c5_d0_3 = counts_5_3.get(0, (0, None))\n    if n5_d0_3 > 0:\n        total_mismatches_3 = c5_d0_3.sum()\n        res5 = total_mismatches_3 / n5_d0_3\n    else:\n        res5 = 0.0\n    results.append(res5)\n\n    # 6. f_G->A_3(0) for test case 3\n    n3_d0_3, c3_d0_3 = counts_3_3.get(0, (0, None))\n    if n3_d0_3 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['G'], BASE_TO_IDX['A']\n        res6 = c3_d0_3[ref_idx, read_idx] / n3_d0_3\n    else:\n        res6 = 0.0\n    results.append(res6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.1f}' for r in results)}]\")\n\nsolve()\n```", "id": "2372718"}, {"introduction": "在量化损伤之后，理解其如何系统性地影响分析结果至关重要。本练习通过一个概率模型，探讨了“参考偏见”这一关键问题，即携带损伤的DNA片段在比对到参考基因组时会产生偏差，从而导致对等位基因频率的错误估计 [@problem_id:2372729]。通过这个模拟，您将深入理解损伤与生物信息学流程的相互作用，并学会批判性地评估数据分析中可能存在的潜在偏差。", "problem": "要求您形式化并实现一个最小的、基于第一性原理的概率模型，该模型需捕捉因古DNA损伤而在单一脱氧核糖核酸（DNA）多态性位点上产生的参考序列比对偏好。设祖先胞嘧啶等位基因的真实群体频率为 $f_{\\mathrm{C}} \\in [0,1]$，则胸腺嘧啶的频率为 $1 - f_{\\mathrm{C}}$。每个覆盖该位点的测序读段源自携带C的染色体的概率为 $f_{\\mathrm{C}}$，源自携带T的染色体的概率为 $1 - f_{\\mathrm{C}}$。损伤被建模为胞嘧啶脱氨：如果原始等位基因是C，观测到的碱基以概率 $p_{\\mathrm{d}} \\in [0,1]$ 翻转为T，并以概率 $1 - p_{\\mathrm{d}}$ 保持为C。源自T的读段不受此损伤模型影响。假设没有其他测序错误。根据参考偏好保留机制，在与参考基因组比对后，读段会被保留：在此位点，给定参考等位基因 $R \\in \\{\\mathrm{C},\\mathrm{T}\\}$。如果读段在此位点的观测碱基与 $R$ 相等，则它以概率 $s_{\\mathrm{match}} \\in [0,1]$ 被保留；如果不相等，则以概率 $s_{\\mathrm{mismatch}} \\in [0,1]$ 被保留。在此模型下，所有读段的行为都是独立的。\n\n您的任务是，对以下的每一组参数，计算基于生成过程期望的两个量：(i) 在比对上的读段中，C的预期观测比例，记作 $p_{\\mathrm{obsC}}$，以及 (ii) 由损伤和比对引起的对真实C频率的低估值，定义为 $\\Delta = p_{\\mathrm{obsC}} - f_{\\mathrm{C}}$。将 $p_{\\mathrm{obsC}}$ 和 $\\Delta$ 均以小数形式（而非百分比）报告，并四舍五入至小数点后六位。\n\n测试套组（每个案例为 $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}})$）：\n-   案例 A: $(0.6, 0.25, \\mathrm{T}, 0.95, 0.70)$。\n-   案例 B: $(0.6, 0.0, \\mathrm{T}, 0.90, 0.90)$。\n-   案例 C: $(0.4, 0.30, \\mathrm{T}, 0.90, 0.90)$。\n-   案例 D: $(0.6, 0.25, \\mathrm{C}, 0.95, 0.70)$。\n-   案例 E: $(0.7, 1.0, \\mathrm{T}, 0.95, 0.70)$。\n\n最终输出格式：您的程序应产生单行输出，包含一个方括号括起来的逗号分隔列表。列表中的每个元素是针对相应测试案例（按A、B、C、D、E的顺序）的双元素列表 $[p_{\\mathrm{obsC}}, \\Delta]$。例如，一个有效的输出格式为 $[[x_{A},y_{A}],[x_{B},y_{B}],[x_{C},y_{C}],[x_{D},y_{D}],[x_{E},y_{E}]]$，其中每个 $x_{i},y_{i}$ 都四舍五入到小数点后六位。", "solution": "在尝试任何解答之前，首先对所述问题进行验证。\n\n逐字提取已知条件：\n-   祖先胞嘧啶等位基因的真实群体频率：$f_{\\mathrm{C}} \\in [0,1]$。\n-   胸腺嘧啶等位基因的真实群体频率：$1 - f_{\\mathrm{C}}$。\n-   读段源自携带C的染色体的概率：$f_{\\mathrm{C}}$。\n-   读段源自携带T的染色体的概率：$1 - f_{\\mathrm{C}}$。\n-   胞嘧啶脱氨概率（C变为T）：$p_{\\mathrm{d}} \\in [0,1]$。\n-   多态性位点的参考等位基因：$R \\in \\{\\mathrm{C},\\mathrm{T}\\}$。\n-   观测碱基与参考等位基因匹配的读段的保留概率：$s_{\\mathrm{match}} \\in [0,1]$。\n-   观测碱基与参考等位基因不匹配的读段的保留概率：$s_{\\mathrm{mismatch}} \\in [0,1]$。\n-   所有读段均独立。\n-   需要计算的量：\n    1.  比对上的读段中C的预期观测比例：$p_{\\mathrm{obsC}}$。\n    2.  对真实C频率的低估值：$\\Delta = p_{\\mathrm{obsC}} - f_{\\mathrm{C}}$。\n-   测试案例：\n    -   案例 A: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.6, 0.25, \\mathrm{T}, 0.95, 0.70)$。\n    -   案例 B: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.6, 0.0, \\mathrm{T}, 0.90, 0.90)$。\n    -   案例 C: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.4, 0.30, \\mathrm{T}, 0.90, 0.90)$。\n    -   案例 D: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.6, 0.25, \\mathrm{C}, 0.95, 0.70)$。\n    -   案例 E: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.7, 1.0, \\mathrm{T}, 0.95, 0.70)$。\n\n验证结论：\n问题有效。其科学基础在于群体遗传学和分子生物学的原理，具体模拟了古DNA损伤（胞嘧啶脱氨）和测序假象（参考偏好）。问题定义良好、客观、自洽，且可进行数学形式化。所有参数均已定义并提供。该问题未违反任何指定的无效标准。我们可以继续推导解答。\n\n解答推导：\n我们关心的量 $p_{\\mathrm{obsC}}$ 是在所有成功比对到参考基因组的读段中，胞嘧啶碱基的预期比例。这是一个条件概率：在一个读段经过比对被保留的条件下，观测到其为C的概率。\n\n让我们为单个随机选取的测序读段定义以下事件：\n-   $A_C$：真实的原始等位基因是胞嘧啶 ($\\mathrm{C}$)。$P(A_C) = f_{\\mathrm{C}}$。\n-   $A_T$：真实的原始等位基因是胸腺嘧啶 ($\\mathrm{T}$)。$P(A_T) = 1 - f_{\\mathrm{C}}$。\n-   $O_C$：读段中观测到的碱基是 $\\mathrm{C}$。\n-   $O_T$：读段中观测到的碱基是 $\\mathrm{T}$。\n-   $S$：读段在比对步骤后被保留（即存活）。\n\n我们旨在计算 $p_{\\mathrm{obsC}} = P(O_C | S)$。根据条件概率的定义，此为：\n$$p_{\\mathrm{obsC}} = \\frac{P(O_C \\cap S)}{P(S)}$$\n分子是读段被观测为 $\\mathrm{C}$ 且被保留的联合概率。分母是读段被保留的总概率。我们将使用全概率定律，以真实等位基因为条件来计算这两项。\n\n首先，我们定义一个保留概率函数 $s(B, R)$，其中 $B$ 是观测碱基，$R$ 是参考等位基因。\n$$\ns(B, R) =\n\\begin{cases}\ns_{\\mathrm{match}} & \\text{若 } B = R \\\\\ns_{\\mathrm{mismatch}} & \\text{若 } B \\neq R\n\\end{cases}\n$$\n\n接下来，我们计算在真实等位基因条件下，观测和存活的联合概率：\n1.  如果真实等位基因是 $\\mathrm{C}$ (事件 $A_C$)：\n    -   碱基以概率 $1 - p_{\\mathrm{d}}$ 被观测为 $\\mathrm{C}$。其保留概率为 $s(\\mathrm{C}, R)$。\n    -   碱基因脱氨而以概率 $p_{\\mathrm{d}}$ 被观测为 $\\mathrm{T}$。其保留概率为 $s(\\mathrm{T}, R)$。\n    -   因此，$P(O_C \\cap S | A_C) = (1 - p_{\\mathrm{d}}) \\cdot s(\\mathrm{C}, R)$。\n    -   在真实等位基因是 $\\mathrm{C}$ 的条件下，总存活概率为 $P(S | A_C) = (1 - p_{\\mathrm{d}}) \\cdot s(\\mathrm{C}, R) + p_{\\mathrm{d}} \\cdot s(\\mathrm{T}, R)$。\n\n2.  如果真实等位基因是 T (事件 $A_T$)：\n    -   碱基总是（概率为 $1$）被观测为 $\\mathrm{T}$。其保留概率为 $s(\\mathrm{T}, R)$。\n    -   因此，$P(O_C \\cap S | A_T) = 0$，因为在此模型中，真实的 $\\mathrm{T}$ 不可能被观测为 $\\mathrm{C}$。\n    -   在真实等位基因是 $\\mathrm{T}$ 的条件下，总存活概率为 $P(S | A_T) = 1 \\cdot s(\\mathrm{T}, R) = s(\\mathrm{T}, R)$。\n\n现在我们可以计算无条件概率 $P(O_C \\cap S)$ 和 $P(S)$：\n观测到一个 $\\mathrm{C}$ 且读段被保留的概率是：\n$$P(O_C \\cap S) = P(O_C \\cap S | A_C)P(A_C) + P(O_C \\cap S | A_T)P(A_T)$$\n$$P(O_C \\cap S) = [(1 - p_{\\mathrm{d}})s(\\mathrm{C}, R)] f_{\\mathrm{C}} + [0](1 - f_{\\mathrm{C}}) = f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s(\\mathrm{C}, R)$$\n\n一个读段被保留的总概率是：\n$$P(S) = P(S | A_C)P(A_C) + P(S | A_T)P(A_T)$$\n$$P(S) = [ (1 - p_{\\mathrm{d}})s(\\mathrm{C}, R) + p_{\\mathrm{d}}s(\\mathrm{T}, R) ] f_{\\mathrm{C}} + [s(\\mathrm{T}, R)](1 - f_{\\mathrm{C}})$$\n\n综合这些，$\\mathrm{C}$ 的预期观测比例是：\n$$p_{\\mathrm{obsC}} = \\frac{f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s(\\mathrm{C}, R)}{[ (1 - p_{\\mathrm{d}})s(\\mathrm{C}, R) + p_{\\mathrm{d}}s(\\mathrm{T}, R) ] f_{\\mathrm{C}} + s(\\mathrm{T}, R)(1 - f_{\\mathrm{C}})}$$\n\n这个通用公式现在针对两种可能的参考等位基因 $R \\in \\{\\mathrm{C},\\mathrm{T}\\}$ 进行特化。\n\n情况 1：参考等位基因是 $\\mathrm{T}$ ($R=\\mathrm{T}$)\n此处，$s(\\mathrm{C}, \\mathrm{T}) = s_{\\mathrm{mismatch}}$ 且 $s(\\mathrm{T}, \\mathrm{T}) = s_{\\mathrm{match}}$。\n$$p_{\\mathrm{obsC}} = \\frac{f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s_{\\mathrm{mismatch}}}{[ (1 - p_{\\mathrm{d}})s_{\\mathrm{mismatch}} + p_{\\mathrm{d}}s_{\\mathrm{match}} ] f_{\\mathrm{C}} + s_{\\mathrm{match}} (1 - f_{\\mathrm{C}})}$$\n\n情况 2：参考等位基因是 $\\mathrm{C}$ ($R=\\mathrm{C}$)\n此处，$s(\\mathrm{C}, \\mathrm{C}) = s_{\\mathrm{match}}$ 且 $s(\\mathrm{T}, \\mathrm{C}) = s_{\\mathrm{mismatch}}$。\n$$p_{\\mathrm{obsC}} = \\frac{f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s_{\\mathrm{match}}}{[ (1 - p_{\\mathrm{d}})s_{\\mathrm{match}} + p_{\\mathrm{d}}s_{\\mathrm{mismatch}} ] f_{\\mathrm{C}} + s_{\\mathrm{mismatch}} (1 - f_{\\mathrm{C}})}$$\n\n对于每个测试案例，使用适当的公式计算 $p_{\\mathrm{obsC}}$。然后，低估值 $\\Delta$ 计算为 $\\Delta = p_{\\mathrm{obsC}} - f_{\\mathrm{C}}$。结果按要求四舍五入至小数点后六位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ancient DNA damage modeling problem for a series of test cases.\n    \"\"\"\n\n    # Test suite (each case is (f_C, p_d, R, s_match, s_mismatch))\n    test_cases = [\n        # Case A\n        (0.6, 0.25, 'T', 0.95, 0.70),\n        # Case B\n        (0.6, 0.0, 'T', 0.90, 0.90),\n        # Case C\n        (0.4, 0.30, 'T', 0.90, 0.90),\n        # Case D\n        (0.6, 0.25, 'C', 0.95, 0.70),\n        # Case E\n        (0.7, 1.0, 'T', 0.95, 0.70),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        f_C, p_d, R, s_match, s_mismatch = case\n\n        # Assign retention probabilities based on the reference allele\n        if R == 'C':\n            s_C_R = s_match\n            s_T_R = s_mismatch\n        elif R == 'T':\n            s_C_R = s_mismatch\n            s_T_R = s_match\n        else:\n            # This case should not occur based on problem description\n            continue\n            \n        # Calculate the numerator of the p_obsC formula: P(O_C and S)\n        # This is the probability that a read comes from a true C, is observed as C, and is retained.\n        numerator = f_C * (1 - p_d) * s_C_R\n\n        # Calculate the denominator of the p_obsC formula: P(S)\n        # This is the total probability that any read is retained.\n        # It's the sum of probabilities of retention for reads from true C and true T chromosomes.\n        prob_S_from_C = ((1 - p_d) * s_C_R + p_d * s_T_R) * f_C\n        prob_S_from_T = s_T_R * (1 - f_C)\n        denominator = prob_S_from_C + prob_S_from_T\n\n        # Calculate the expected observed fraction of C among aligned reads\n        if denominator == 0:\n            # This would only occur if no reads can be retained, e.g., s_match=s_mismatch=0.\n            # In this scenario, p_obsC is undefined, but for computational purposes, we can set it to 0.\n            p_obsC = 0.0\n        else:\n            p_obsC = numerator / denominator\n        \n        # Calculate the underestimation of the C frequency\n        delta = p_obsC - f_C\n\n        # Round results to six decimal places\n        p_obsC_rounded = round(p_obsC, 6)\n        delta_rounded = round(delta, 6)\n\n        all_results.append([p_obsC_rounded, delta_rounded])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is converted to a string,\n    # and all whitespace is removed to match the specified format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2372729"}, {"introduction": "分析古DNA的最终目标不仅是识别问题，更是构建能克服这些问题的方法。本练习将介绍一种强大的策略：将我们对损伤的认知直接整合到统计模型中 [@problem_id:2372702]。您将基于贝叶斯原理，实现一个简化的“损伤感知”共识序列调用器，该调用器在推断真实DNA序列时，能同时考虑测序错误率 $\\epsilon$ 和特定的胞嘧啶脱氨损伤率 $\\delta$。这提供了一个进入现代古基因组学概率建模世界的绝佳实践。", "problem": "实现一个基于简单生成模型的、能识别损伤的古代脱氧核糖核酸（aDNA）共有序列调用器。在单个基因组位置，给定四种核苷酸（腺嘌呤、胞嘧啶、鸟嘌呤和胸腺嘧啶）的观测读取计数（按此顺序），以及两个参数：一个基准测序错误率和一个固定的胞嘧啶到胸腺嘧啶的损伤率。假设如下：\n\n- 该位置的真实碱基（表示为 $B \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$）是未知的，且具有均匀先验概率 $P(B=\\mathrm{A})=P(B=\\mathrm{C})=P(B=\\mathrm{G})=P(B=\\mathrm{T})=\\frac{1}{4}$。\n- 在给定 $B$ 的条件下，所有读取中的观测碱基调用是从一个分类分布中抽取的独立同分布样本，该分布具有特定于碱基的发射概率。\n- 设基准测序错误率为 $\\epsilon \\in [0,1)$，固定的胞嘧啶到胸腺嘧啶损伤率为 $\\delta \\in [0,1-\\epsilon]$。\n- 对于 $B \\neq \\mathrm{C}$，发射概率为：正确碱基的发射概率为 $1-\\epsilon$，其他三种错误碱基的发射概率各为 $\\epsilon/3$。\n- 对于 $B=\\mathrm{C}$，损伤将报告为 $\\mathrm{T}$ 的概率从 $\\epsilon/3$ 增加到 $\\delta+\\epsilon/3$，同时降低正确发射 $\\mathrm{C}$ 的概率，以使总概率为 $1$。因此，对于 $B=\\mathrm{C}$：$P(\\mathrm{C}|\\mathrm{C})=1-(\\epsilon+\\delta)$，$P(\\mathrm{T}|\\mathrm{C})=\\delta+\\epsilon/3$，以及 $P(\\mathrm{A}|\\mathrm{C})=P(\\mathrm{G}|\\mathrm{C})=\\epsilon/3$。\n\n给定观测计数 $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$，将候选真实碱基 $b$ 下的数据似然视为一个多项式模型，其参数由 $b$ 对应的发射概率决定。使用均匀先验并通过贝叶斯法则计算 $b \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的后验概率 $P(B=b \\mid \\mathbf{c}, \\epsilon, \\delta)$。共有序列调用即为最大化此后验概率的碱基 $b$。如果出现精确相等的情况（后验概率值在 $10^{-12}$ 的绝对容差内相等），则根据映射 $\\mathrm{A} \\mapsto 0$、$\\mathrm{C} \\mapsto 1$、$\\mathrm{G} \\mapsto 2$、$\\mathrm{T} \\mapsto 3$ 选择索引最小的碱基。\n\n您的程序必须从头开始实现此模型，并为每个测试用例输出：\n- 使用上述映射的共有序列调用索引（整数），以及\n- 该调用碱基的后验概率（四舍五入到 $6$ 位小数的十进制数）。\n\n如果总读取计数为零，即 $c_{\\mathrm{A}}+c_{\\mathrm{C}}+c_{\\mathrm{G}}+c_{\\mathrm{T}}=0$，则后验概率是均匀的，每个碱基的后验概率均为 $1/4$；应用上述的平局打破规则。\n\n测试套件：\n使用以下测试用例，每个用例指定为 $\\left(\\mathbf{c}, \\epsilon, \\delta\\right)$，其中 $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$。\n\n1. $\\left((2,8,1,5),\\, 0.01,\\, 0.20\\right)$\n2. $\\left((0,0,0,0),\\, 0.01,\\, 0.20\\right)$\n3. $\\left((0,0,0,10),\\, 0.01,\\, 0.30\\right)$\n4. $\\left((0,3,0,7),\\, 0.01,\\, 0.25\\right)$\n5. $\\left((1,1,1,1),\\, 0.01,\\, 0.20\\right)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，并保持上述顺序。每个条目必须是一个双元素列表，形式为 $\\left[\\text{call\\_index}, \\text{posterior\\_rounded}\\right]$，其中 $\\text{call\\_index}$ 是一个整数，$\\text{posterior\\_rounded}$ 是一个四舍五入到 $6$ 位小数的十进制数。整个输出必须是一个用方括号括起来的、以逗号分隔的列表，例如：$[[0,0.500000],[3,0.875000],\\dots]$。", "solution": "我们将问题转化为一个有原则的概率推断任务。设观测计数为 $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$，总计数为 $N=c_{\\mathrm{A}}+c_{\\mathrm{C}}+c_{\\mathrm{G}}+c_{\\mathrm{T}}$。设基准测序错误率为 $\\epsilon \\in [0,1)$，固定的胞嘧啶到胸腺嘧啶损伤率为 $\\delta \\in [0,1-\\epsilon]$。真实碱基 $B$ 具有均匀先验概率 $P(B=b)=\\frac{1}{4}$，对于所有 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。\n\n根据模型：\n- 对于 $b \\in \\{\\mathrm{A},\\mathrm{G},\\mathrm{T}\\}$，发射概率为\n$$\nP(\\mathrm{A}\\mid b)=\\begin{cases}\n1-\\epsilon & \\text{if } b=\\mathrm{A}\\\\\n\\epsilon/3 & \\text{if } b\\neq \\mathrm{A}\n\\end{cases},\\quad\nP(\\mathrm{C}\\mid b)=\\begin{cases}\n1-\\epsilon & \\text{if } b=\\mathrm{C}\\\\\n\\epsilon/3 & \\text{if } b\\neq \\mathrm{C}\n\\end{cases},\n$$\n对于 $\\mathrm{G}$ 和 $\\mathrm{T}$ 也类似，正确碱基的概率为 $1-\\epsilon$，每个错误碱基的概率为 $\\epsilon/3$。\n- 对于 $b=\\mathrm{C}$，损伤修改了两个条目：\n$$\nP(\\mathrm{C}\\mid \\mathrm{C})=1-(\\epsilon+\\delta),\\quad\nP(\\mathrm{T}\\mid \\mathrm{C})=\\delta+\\epsilon/3,\\quad\nP(\\mathrm{A}\\mid \\mathrm{C})=\\epsilon/3,\\quad\nP(\\mathrm{G}\\mid \\mathrm{C})=\\epsilon/3.\n$$\n根据构造，如果 $\\delta \\in [0,1-\\epsilon]$，这些概率是非负的，并且总和为 $1$。\n\n给定 $b$，观测到 $\\mathbf{c}$ 的似然是多项式的：\n$$\n\\mathcal{L}(\\mathbf{c} \\mid B=b) \\propto \\prod_{x \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} P(x\\mid b)^{c_x}.\n$$\n多项式系数不依赖于 $b$，在后验比率中被抵消。由于使用均匀先验，未归一化的后验概率与似然成正比。因此，\n$$\nP(B=b \\mid \\mathbf{c},\\epsilon,\\delta) = \\frac{\\prod_{x} P(x\\mid b)^{c_x}}{\\sum_{b' \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} \\prod_{x} P(x\\mid b')^{c_x}}.\n$$\n为了数值稳定性和处理极小的概率，在对数空间中计算是有利的，利用了对于 $p>0$ 的事实 $\\log\\left(\\prod_x p_x^{c_x}\\right) = \\sum_x c_x \\log p_x$。定义\n$$\n\\ell(b) = \\sum_{x \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} c_x \\log P(x\\mid b).\n$$\n然后使用 log-sum-exp 恒等式进行归一化：\n$$\nP(B=b \\mid \\mathbf{c},\\epsilon,\\delta) = \\frac{\\exp\\left(\\ell(b) - m\\right)}{\\sum_{b'} \\exp\\left(\\ell(b') - m\\right)},\\quad \\text{其中 } m=\\max_{b'} \\ell(b').\n$$\n特殊情况：如果 $N=0$，则每个 $\\ell(b)=0$（空和），因此每个后验概率都是 $1/4$。对于共有序列调用，选择 $b^\\star \\in \\arg\\max_b P(B=b \\mid \\mathbf{c},\\epsilon,\\delta)$。如果多个碱基在 $10^{-12}$ 的绝对容差内打平，则根据映射 $\\mathrm{A} \\mapsto 0$、$\\mathrm{C} \\mapsto 1$、$\\mathrm{G} \\mapsto 2$、$\\mathrm{T} \\mapsto 3$ 选择索引最小的碱基。报告 $b^\\star$ 的索引及其对应的后验概率，四舍五入到 $6$ 位小数。\n\n将此过程应用于每个测试用例，可得出与指定的、能识别损伤的生成模型一致的确定性共有序列索引和后验概率，其中损伤特别增加了相对于基准测序错误的 $\\mathrm{C} \\to \\mathrm{T}$ 观测值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Mapping: A->0, C->1, G->2, T->3\nBASES = ['A', 'C', 'G', 'T']\n\ndef emission_probs_for_base(base_index: int, eps: float, delta: float) -> np.ndarray:\n    \"\"\"\n    Construct emission probabilities P(x | B = base_index) for x in {A,C,G,T}\n    under the simplified damage model:\n      - For B != C: correct base with 1 - eps; each incorrect base eps / 3\n      - For B == C: P(C|C) = 1 - (eps + delta)\n                     P(T|C) = delta + eps/3\n                     P(A|C) = P(G|C) = eps/3\n    \"\"\"\n    p = np.full(4, eps / 3.0, dtype=float)\n    if base_index == 1:  # C\n        p[1] = 1.0 - (eps + delta)\n        p[3] = delta + eps / 3.0\n    else:\n        p[base_index] = 1.0 - eps\n    return p\n\ndef log_likelihood(counts: np.ndarray, p: np.ndarray) -> float:\n    \"\"\"\n    Compute sum_i counts[i] * log(p[i]), returning -inf if any probability is zero where count > 0.\n    \"\"\"\n    # Handle zero probabilities explicitly\n    with np.errstate(divide='ignore'):\n        logs = np.log(p)\n    # If p[i] == 0 and counts[i] > 0, the term is -inf.\n    mask_positive_counts = counts > 0\n    if np.any((p == 0.0) & mask_positive_counts):\n        return -np.inf\n    return float(np.dot(counts[mask_positive_counts], logs[mask_positive_counts]))\n\ndef posterior_and_call(counts: np.ndarray, eps: float, delta: float, tol: float = 1e-12):\n    \"\"\"\n    Compute posterior over bases and return (call_index, posterior_of_call).\n    Tie-breaks by smallest index within absolute tolerance 'tol'.\n    \"\"\"\n    lls = []\n    for b in range(4):\n        p = emission_probs_for_base(b, eps, delta)\n        ll = log_likelihood(counts, p)\n        lls.append(ll)\n    lls = np.array(lls, dtype=float)\n\n    # Normalize using log-sum-exp\n    m = np.max(lls)\n    with np.errstate(over='ignore', under='ignore'):\n        w = np.exp(lls - m)\n    Z = float(np.sum(w))\n    post = w / Z if Z > 0.0 else np.full(4, 0.25)  # Fallback shouldn't trigger unless all -inf; N=0 handled naturally\n\n    # Determine call with tie-breaking\n    max_post = float(np.max(post))\n    candidate_indices = np.where(np.abs(post - max_post) <= tol)[0]\n    call_index = int(np.min(candidate_indices))\n\n    return call_index, float(post[call_index])\n\ndef format_results_list(results):\n    \"\"\"\n    Format results as a single-line string: [[idx,posterior],...]\n    with posterior rounded to 6 decimal places.\n    \"\"\"\n    parts = []\n    for idx, post in results:\n        parts.append(f\"[{idx},{format(round(post + 0.0, 6), '.6f')}]\")\n    return \"[\" + \",\".join(parts) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (counts[A,C,G,T], epsilon, delta)\n    test_cases = [\n        ((2, 8, 1, 5), 0.01, 0.20),\n        ((0, 0, 0, 0), 0.01, 0.20),\n        ((0, 0, 0, 10), 0.01, 0.30),\n        ((0, 3, 0, 7), 0.01, 0.25),\n        ((1, 1, 1, 1), 0.01, 0.20),\n    ]\n\n    results = []\n    for counts_tuple, eps, delta in test_cases:\n        counts = np.array(counts_tuple, dtype=float)\n        call_idx, post_call = posterior_and_call(counts, eps, delta, tol=1e-12)\n        results.append((call_idx, post_call))\n\n    # Final print statement in the exact required format.\n    print(format_results_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2372702"}]}