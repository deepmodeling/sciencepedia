{"hands_on_practices": [{"introduction": "单细胞RNA测序数据的一个显著特点是其高度的稀疏性，这意味着数据矩阵中存在大量的零值。这个练习旨在帮助你区分真正的生物学零表达（基因确实未表达）和技术性脱落（基因已表达但未被检测到）。通过构建一个基于基因总表达量 $c_j$ 和细胞总表达量 $r_i$ 的简单概率模型[@problem_id:2429844]，你将学习如何量化一个零值的“意外程度” $D_{ij}$，从而深入理解单细胞数据分析中的一个核心挑战。", "problem": "考虑一个单细胞RNA测序 (scRNA-seq) 实验，其结果可总结为一个非负整数计数矩阵 $Y \\in \\mathbb{N}_0^{C \\times G}$，其中 $C$ 是细胞数量，$G$ 是基因数量。每个条目 $Y_{ij}$ 表示观测到的细胞 $i$ 和基因 $j$ 的分子计数。$Y$ 中的零值可能源于真实的生物性表达缺失，也可能源于技术性脱落。仅使用 $Y$，定义一个作用于零值条目的实值度量，用以在一个受 $Y$ 的边际和约束的可分离强度模型下，量化一个观测到的零值有多么“出人意料”。\n\n令 $r_i = \\sum_{j=1}^{G} Y_{ij}$ 表示细胞 $i$ 的总计数，$c_j = \\sum_{i=1}^{C} Y_{ij}$ 表示基因 $j$ 的总计数，以及 $T = \\sum_{i=1}^{C}\\sum_{j=1}^{G} Y_{ij}$ 表示总计数。通过下式定义一个非负强度矩阵 $\\Lambda = (\\lambda_{ij})$：\n$$\n\\lambda_{ij} =\n\\begin{cases}\n\\dfrac{r_i \\, c_j}{T}, & \\text{若 } T > 0, \\\\[6pt]\n0, & \\text{若 } T = 0,\n\\end{cases}\n$$\n从而使得 $\\Lambda$ 的行和与列和在总体上与 $Y$ 的相匹配。对于任何观测值为零 $Y_{ij} = 0$ 的位置 $(i,j)$，定义其脱落意外分数 (dropout-surprise score)：\n$$\nD_{ij} = 1 - e^{-\\lambda_{ij}},\n$$\n而对于 $Y_{ij} \\neq 0$ 的位置，$D_{ij}$ 未定义。对于给定的阈值 $\\tau \\in [0,1]$，如果 $D_{ij} \\ge \\tau$，则将零值条目 $(i,j)$ 分类为疑似脱落 (dropout-suspect)；否则，分类为与真实生物性零值一致。对于任何矩阵 $Y$，定义分类分数 (classification fraction)：\n$$\nF(Y,\\tau) = \n\\begin{cases}\n\\dfrac{\\#\\{(i,j): Y_{ij}=0 \\text{ 且 } D_{ij} \\ge \\tau\\}}{\\#\\{(i,j): Y_{ij}=0\\}}, & \\text{若 } \\#\\{(i,j): Y_{ij}=0\\} > 0, \\\\[6pt]\n0, & \\text{若 } \\#\\{(i,j): Y_{ij}=0\\} = 0,\n\\end{cases}\n$$\n其中 $\\#\\{\\cdot\\}$ 表示集合中元素的数量。\n\n测试套件。你的程序必须为以下每个 $(Y,\\tau)$ 对计算 $F(Y,\\tau)$：\n\n- 情况1：\n$Y^{(1)} = \\begin{bmatrix}\n3 & 0 & 0\\\\\n0 & 5 & 1\\\\\n0 & 0 & 2\n\\end{bmatrix}$, $\\tau^{(1)} = 0.5$。\n\n- 情况2：\n$Y^{(2)} = \\begin{bmatrix}\n0 & 0 & 0\\\\\n4 & 0 & 0\n\\end{bmatrix}$, $\\tau^{(2)} = 0.2$。\n\n- 情况3：\n$Y^{(3)} = \\begin{bmatrix}\n10 & 2 & 0 & 0\\\\\n0 & 0 & 0 & 20\n\\end{bmatrix}$, $\\tau^{(3)} = 0.9$。\n\n- 情况4：\n$Y^{(4)} = \\begin{bmatrix}\n0 & 0\\\\\n0 & 0\n\\end{bmatrix}$, $\\tau^{(4)} = 0.0$。\n\n- 情况5：\n$Y^{(5)} = \\begin{bmatrix}\n1 & 2\\\\\n3 & 4\n\\end{bmatrix}$, $\\tau^{(5)} = 0.5$。\n\n最终输出格式。你的程序应生成单行输出，其中包含按上述情况顺序排列的结果，格式为用方括号括起来的逗号分隔的十进制数列表，每个数都四舍五入到 $6$ 位小数。例如，一个包含五个结果的输出应形如 $[a_1,a_2,a_3,a_4,a_5]$，其中每个 $a_k$ 是一个四舍五入到 $6$ 位小数的十进制数。", "solution": "问题陈述是有效的。它提出了一个定义明确的计算任务，该任务基于一个在单细胞RNA测序 (scRNA-seq) 数据分析中使用的简化但科学上合理的模型。该模型旨在区分基因表达计数矩阵中的生物性零值和技术性零值。所有的定义、变量和公式都给得清晰明确，并且问题是自洽的、数学上一致且客观陈述的。我们将着手进行求解。\n\n问题的核心是为五个给定的计数矩阵 $Y$ 和阈值 $\\tau$ 对计算分类分数 $F(Y, \\tau)$。分数 $F(Y, \\tau)$ 定义为“疑似脱落”零值条目数与矩阵 $Y$ 中零值条目总数的比率。如果一个位于位置 $(i,j)$ 的零值的脱落意外分数 $D_{ij}$ 大于或等于 $\\tau$，则该零值被视为疑似脱落。\n\n计算过程如下。首先，我们计算矩阵 $Y$ 的边际和。令 $Y \\in \\mathbb{N}_0^{C \\times G}$ 为计数矩阵，有 $C$ 个细胞和 $G$ 个基因。\n行和（每个细胞的总计数）是 $r_i = \\sum_{j=1}^{G} Y_{ij}$，其中 $i=1, \\dots, C$。\n列和（每个基因的总计数）是 $c_j = \\sum_{i=1}^{C} Y_{ij}$，其中 $j=1, \\dots, G$。\n总计数是 $T = \\sum_{i=1}^{C} \\sum_{j=1}^{G} Y_{ij}$。\n\n每个条目 $(i,j)$ 的强度 $\\lambda_{ij}$ 是基于这些边际和计算的，它代表了一个独立性模型下的期望计数：\n$$\n\\lambda_{ij} = \\frac{r_i \\, c_j}{T} \\quad (\\text{若 } T > 0), \\quad \\text{以及} \\quad \\lambda_{ij} = 0 \\quad (\\text{若 } T=0).\n$$\n对于每个观测计数为零 ($Y_{ij}=0$) 的位置 $(i,j)$，其脱落意外分数由下式给出：\n$$\nD_{ij} = 1 - e^{-\\lambda_{ij}}.\n$$\n这个分数可以被解释为，在一个速率为 $\\lambda_{ij}$ 的泊松 (Poisson) 模型下观测到非零计数的概率。一个高的分数表明期望观测到非零计数，从而使得观测到的零值显得“出人意料”。\n\n最后，分类分数为：\n$$\nF(Y, \\tau) = \\frac{\\#\\{(i,j) \\mid Y_{ij}=0 \\text{ 且 } D_{ij} \\ge \\tau\\}}{\\#\\{(i,j) \\mid Y_{ij}=0\\}},\n$$\n对不存在零值 ($F=0$) 或分母为零的情况进行了特殊处理。\n\n现在我们将此过程应用于每个测试用例。\n\n**情况1：**\n$Y^{(1)} = \\begin{bmatrix} 3 & 0 & 0\\\\ 0 & 5 & 1\\\\ 0 & 0 & 2 \\end{bmatrix}$，$\\tau^{(1)} = 0.5$。\n1.  行和：$r_1=3$, $r_2=6$, $r_3=2$。\n2.  列和：$c_1=3$, $c_2=5$, $c_3=3$。\n3.  总计数：$T=11$。\n4.  在位置 $(1,2), (1,3), (2,1), (3,1), (3,2)$ 处有 $5$ 个零（使用 $1$ 基索引）。\n5.  我们为每个零计算 $D_{ij}$：\n    -   $Y_{12}=0$：$\\lambda_{12} = \\frac{r_1 c_2}{T} = \\frac{3 \\times 5}{11} \\approx 1.3636$。$D_{12} = 1 - e^{-1.3636} \\approx 0.7443$。由于 $0.7443 \\ge 0.5$，这是一个疑似脱落的零。\n    -   $Y_{13}=0$：$\\lambda_{13} = \\frac{r_1 c_3}{T} = \\frac{3 \\times 3}{11} \\approx 0.8182$。$D_{13} = 1 - e^{-0.8182} \\approx 0.5588$。由于 $0.5588 \\ge 0.5$，这是一个疑似脱落的零。\n    -   $Y_{21}=0$：$\\lambda_{21} = \\frac{r_2 c_1}{T} = \\frac{6 \\times 3}{11} \\approx 1.6364$。$D_{21} = 1 - e^{-1.6364} \\approx 0.8053$。由于 $0.8053 \\ge 0.5$，这是一个疑似脱落的零。\n    -   $Y_{31}=0$：$\\lambda_{31} = \\frac{r_3 c_1}{T} = \\frac{2 \\times 3}{11} \\approx 0.5455$。$D_{31} = 1 - e^{-0.5455} \\approx 0.4204$。由于 $0.4204 < 0.5$，这不是一个疑似脱落的零。\n    -   $Y_{32}=0$：$\\lambda_{32} = \\frac{r_3 c_2}{T} = \\frac{2 \\times 5}{11} \\approx 0.9091$。$D_{32} = 1 - e^{-0.9091} \\approx 0.5971$。由于 $0.5971 \\ge 0.5$，这是一个疑似脱落的零。\n6.  在总共 $5$ 个零中，有 $4$ 个是疑似脱落的。\n    $F(Y^{(1)}, \\tau^{(1)}) = \\frac{4}{5} = 0.8$。\n\n**情况2：**\n$Y^{(2)} = \\begin{bmatrix} 0 & 0 & 0\\\\ 4 & 0 & 0 \\end{bmatrix}$，$\\tau^{(2)} = 0.2$。\n1.  行和：$r_1=0$, $r_2=4$。\n2.  列和：$c_1=4$, $c_2=0$, $c_3=0$。\n3.  总计数：$T=4$。\n4.  有 $5$ 个零。对于任何零值条目 $(i,j)$，要么 $r_i=0$，要么 $c_j=0$（或两者都为零）。\n5.  这意味着对于所有零值条目，$\\lambda_{ij} = \\frac{r_i c_j}{T} = 0$。\n6.  因此，对于所有五个零，都有 $D_{ij} = 1 - e^{-0} = 0$。\n7.  判断为疑似脱落的条件是 $D_{ij} \\ge 0.2$，即 $0 \\ge 0.2$。这对所有零都不成立。\n8.  疑似脱落的零的数量是 $0$。\n    $F(Y^{(2)}, \\tau^{(2)}) = \\frac{0}{5} = 0.0$。\n\n**情况3：**\n$Y^{(3)} = \\begin{bmatrix} 10 & 2 & 0 & 0\\\\ 0 & 0 & 0 & 20 \\end{bmatrix}$，$\\tau^{(3)} = 0.9$。\n1.  行和：$r_1=12$, $r_2=20$。\n2.  列和：$c_1=10$, $c_2=2$, $c_3=0$, $c_4=20$。\n3.  总计数：$T=32$。\n4.  在位置 $(1,3), (1,4), (2,1), (2,2), (2,3)$ 处有 $5$ 个零。\n5.  我们为每个零计算 $D_{ij}$：\n    -   $Y_{13}=0$：$c_3=0 \\implies \\lambda_{13}=0 \\implies D_{13}=0$。非疑似，因为 $0 < 0.9$。\n    -   $Y_{14}=0$：$\\lambda_{14} = \\frac{12 \\times 20}{32} = 7.5$。$D_{14} = 1 - e^{-7.5} \\approx 0.9995$。疑似，因为 $0.9995 \\ge 0.9$。\n    -   $Y_{21}=0$：$\\lambda_{21} = \\frac{20 \\times 10}{32} = 6.25$。$D_{21} = 1 - e^{-6.25} \\approx 0.9981$。疑似，因为 $0.9981 \\ge 0.9$。\n    -   $Y_{22}=0$：$\\lambda_{22} = \\frac{20 \\times 2}{32} = 1.25$。$D_{22} = 1 - e^{-1.25} \\approx 0.7135$。非疑似，因为 $0.7135 < 0.9$。\n    -   $Y_{23}=0$：$c_3=0 \\implies \\lambda_{23}=0 \\implies D_{23}=0$。非疑似，因为 $0 < 0.9$。\n6.  在 $5$ 个零中有 $2$ 个是疑似脱落的。\n    $F(Y^{(3)}, \\tau^{(3)}) = \\frac{2}{5} = 0.4$。\n\n**情况4：**\n$Y^{(4)} = \\begin{bmatrix} 0 & 0\\\\ 0 & 0 \\end{bmatrix}$，$\\tau^{(4)} = 0.0$。\n1.  所有条目都为零。因此，$r_1=0, r_2=0$, $c_1=0, c_2=0$ 且 $T=0$。\n2.  根据定义，若 $T=0$，则对所有 $(i,j)$ 都有 $\\lambda_{ij}=0$。\n3.  因此，对所有条目都有 $D_{ij} = 1 - e^{-0} = 0$。\n4.  有 $4$ 个零值条目。判断为疑似脱落的条件是 $D_{ij} \\ge \\tau^{(4)}$，即 $0 \\ge 0.0$。\n5.  这个条件对所有 $4$ 个零值条目都成立。\n6.  疑似脱落的零的数量是 $4$。\n    $F(Y^{(4)}, \\tau^{(4)}) = \\frac{4}{4} = 1.0$。\n\n**情况5：**\n$Y^{(5)} = \\begin{bmatrix} 1 & 2\\\\ 3 & 4 \\end{bmatrix}$，$\\tau^{(5)} = 0.5$。\n1.  矩阵 $Y^{(5)}$ 不含零值条目。\n2.  根据问题定义，如果 $\\#\\{(i,j): Y_{ij}=0\\} = 0$，则 $F(Y, \\tau) = 0$。\n3.  因此，$F(Y^{(5)}, \\tau^{(5)}) = 0.0$。\n\n结果总结：\n-   $F(Y^{(1)}, \\tau^{(1)}) = 0.8$\n-   $F(Y^{(2)}, \\tau^{(2)}) = 0.0$\n-   $F(Y^{(3)}, \\tau^{(3)}) = 0.4$\n-   $F(Y^{(4)}, \\tau^{(4)}) = 1.0$\n-   $F(Y^{(5)}, \\tau^{(5)}) = 0.0$", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the classification fraction F(Y, tau) for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        (np.array([[3, 0, 0], [0, 5, 1], [0, 0, 2]]), 0.5),\n        (np.array([[0, 0, 0], [4, 0, 0]]), 0.2),\n        (np.array([[10, 2, 0, 0], [0, 0, 0, 20]]), 0.9),\n        (np.array([[0, 0], [0, 0]]), 0.0),\n        (np.array([[1, 2], [3, 4]]), 0.5)\n    ]\n\n    def calculate_F(Y, tau):\n        \"\"\"\n        Calculates the classification fraction for a single (Y, tau) pair.\n        \n        Args:\n            Y (np.ndarray): The count matrix.\n            tau (float): The threshold.\n\n        Returns:\n            float: The classification fraction F(Y, tau).\n        \"\"\"\n        # Ensure Y is float for calculations to prevent potential integer division issues\n        Y = Y.astype(float)\n        \n        # Denominator of F(Y, tau): total number of zeros\n        num_zeros = Y.size - np.count_nonzero(Y)\n\n        if num_zeros == 0:\n            return 0.0\n\n        # Calculate grand total T\n        T = np.sum(Y)\n\n        # Handle special case where T=0\n        if T == 0:\n            # If T=0, all Y_ij=0, so all lambda_ij=0, and all D_ij=0.\n            # The condition for being suspect is D_ij >= tau, which is 0 >= tau.\n            # This is only true if tau is 0 or negative.\n            if tau <= 0.0:\n                return 1.0  # All zeros are suspect\n            else:\n                return 0.0  # No zeros are suspect\n\n        # Calculate row and column sums\n        r = np.sum(Y, axis=1)\n        c = np.sum(Y, axis=0)\n        \n        # Numerator of F(Y, tau): number of suspect zeros\n        num_suspect = 0\n        \n        rows, cols = Y.shape\n        # Iterate through the matrix to find zeros and evaluate them\n        for i in range(rows):\n            for j in range(cols):\n                if Y[i, j] == 0:\n                    # Calculate lambda_ij for the zero entry\n                    lambda_ij = (r[i] * c[j]) / T\n                    \n                    # Calculate dropout-surprise score D_ij\n                    D_ij = 1.0 - np.exp(-lambda_ij)\n                    \n                    # Check if the zero is dropout-suspect\n                    if D_ij >= tau:\n                        num_suspect += 1\n                        \n        return num_suspect / num_zeros\n\n    results = []\n    for Y_case, tau_case in test_cases:\n        result = calculate_F(Y_case, tau_case)\n        results.append(f\"{result:.6f}\")\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2429844"}, {"introduction": "在处理来自不同实验批次的单细胞数据时，一个常见的障碍是批次效应，它可能掩盖真实的生物学差异。本实践将指导你处理这一挑战，通过一个简化的模型将批次效应视为在低维空间中的一个已知平移向量 $\\mathbf{s}_b$。你将学习如何通过移除这些技术性偏差来校正细胞簇的质心，并使用图论的方法来合并那些本应属于同一生物学类型的细胞簇[@problem_id:2429786]，这是进行大规模数据整合的一项关键技能。", "problem": "给定一个形式化描述，说明已知的加性批次效应如何在单细胞RNA测序 (scRNA-seq) 中人为地分裂生物学上相同的细胞簇。经过归一化和降维等标准预处理后，假设每个观测到的细胞簇在低维空间中由一个质心向量表示，并且每个批次都贡献一个已知的加性偏移向量。具体来说，假设有 $B$ 个批次，由 $b \\in \\{1,\\dots,B\\}$ 索引。对于每个批次 $b$，给定一个已知的批次效应向量 $\\mathbf{s}_b \\in \\mathbb{R}^d$。每个观测到的细胞簇 $i$ 关联一个批次索引 $b(i)$ 和一个观测质心 $\\mathbf{m}_i \\in \\mathbb{R}^d$。批次校正后的质心定义为\n$$\n\\mathbf{c}_i \\;=\\; \\mathbf{m}_i \\;-\\; \\mathbf{s}_{b(i)} \\, .\n$$\n如果两个细胞簇 $i$ 和 $j$ 满足 $b(i) \\neq b(j)$ 且 $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau$，则认为它们是直接兼容的，其中 $\\tau \\in \\mathbb{R}_{\\ge 0}$ 是给定的容差。定义一个无向图，其顶点是各个细胞簇，边连接所有直接兼容的对。合并后的组定义为此图的连通分量。你的任务是，对下面的每个独立测试用例，计算合并后组的总数（即连通分量的数量）。\n\n重要提示：\n- 距离 $\\lVert \\cdot \\rVert_2$ 是 $\\mathbb{R}^d$ 中的标准欧几里得范数。\n- 仅允许来自不同批次的细胞簇之间存在边，即仅当 $b(i) \\neq b(j)$ 时。\n- 容差 $\\tau$ 的应用是包含边界的：如果 $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 = \\tau$，则 $i$ 和 $j$ 之间有一条边连接。\n- 每个测试用例的最终结果是一个整数：连通分量的数量。\n\n测试套件：\n- 测试用例 1：\n  - 维度 $d = 2$。\n  - 批次 $B = 2$，其中 $\\mathbf{s}_1 = [\\,1,\\,0\\,]$ 且 $\\mathbf{s}_2 = [\\,-1,\\,0\\,]$。\n  - 容差 $\\tau = 0.2$。\n  - 观测到的细胞簇：\n    - 批次 1: $\\mathbf{m}_{A} = [\\,5,\\,0\\,]$, $\\mathbf{m}_{C} = [\\,1,\\,10\\,]$。\n    - 批次 2: $\\mathbf{m}_{B} = [\\,3,\\,0\\,]$, $\\mathbf{m}_{D} = [\\,-1,\\,10.15\\,]$。\n\n- 测试用例 2：\n  - 维度 $d = 2$。\n  - 批次 $B = 3$，其中 $\\mathbf{s}_1 = [\\,0,\\,0\\,]$, $\\mathbf{s}_2 = [\\,0.5,\\,0\\,]$, $\\mathbf{s}_3 = [\\,1.0,\\,0\\,]$。\n  - 容差 $\\tau = 1.0$。\n  - 观测到的细胞簇：\n    - 批次 1: $\\mathbf{m}_{A} = [\\,0,\\,0\\,]$, $\\mathbf{m}_{D} = [\\,100,\\,100\\,]$。\n    - 批次 2: $\\mathbf{m}_{B} = [\\,1.5,\\,0\\,]$, $\\mathbf{m}_{E} = [\\,-100,\\,-100\\,]$。\n    - 批次 3: $\\mathbf{m}_{C} = [\\,3.0,\\,0\\,]$。\n\n- 测试用例 3：\n  - 维度 $d = 3$。\n  - 批次 $B = 2$，其中 $\\mathbf{s}_1 = [\\,0.2,\\,-0.1,\\,0.0\\,]$ 且 $\\mathbf{s}_2 = [\\,-0.2,\\,0.1,\\,0.0\\,]$。\n  - 容差 $\\tau = 0.0$。\n  - 观测到的细胞簇：\n    - 批次 1: $\\mathbf{m}_{X} = [\\,1.2,\\,0.9,\\,3.0\\,]$, $\\mathbf{m}_{Z} = [\\,10.2,\\,-4.1,\\,0.0\\,]$。\n    - 批次 2: $\\mathbf{m}_{Y} = [\\,0.8,\\,1.1,\\,3.0\\,]$, $\\mathbf{m}_{W} = [\\,9.8,\\,-3.9,\\,0.05\\,]$。\n\n你的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表，例如 $[\\,r_1,r_2,r_3\\,]$，其中每个 $r_k$ 是测试用例 $k$ 的合并后组数的整数值。", "solution": "所提出的问题是计算生物学中一个有效且定义明确的练习，具体涉及单细胞RNA测序 (scRNA-seq) 数据分析中批次效应校正的原理。该问题有科学依据，数学上精确，且算法上可解。因此，本文将给出一个完整的解决方案。\n\n其基本目标是识别并合并那些生物学上相同，但由于称为批次效应的技术伪影而显得不同的细胞簇。问题将此场景形式化，并提供了一个清晰的数据重整合流程。解决方案根据既定原则，分三个逻辑步骤进行。\n\n首先，我们应用**加性批次校正**原则。假设实验批次 $b$ 的效应是在特征空间中对数据点产生的统一、加性位移。这由一个已知的偏移向量 $\\mathbf{s}_b \\in \\mathbb{R}^d$ 表示。来自批次 $b(i)$ 的一个观测细胞簇 $i$，由其质心 $\\mathbf{m}_i$ 表示，其真实的生物学位置 $\\mathbf{c}_i$ 被这种效应所扭曲。为了校正这一点，我们减去相应的偏移向量，得到批次校正后的质心：\n$$\n\\mathbf{c}_i = \\mathbf{m}_i - \\mathbf{s}_{b(i)}\n$$\n此操作旨在将来自不同批次的生物学上等价的细胞簇的质心，对齐到一个公共的、校正过的坐标系中。\n\n其次，我们采用一个**基于图的框架来定义**细胞簇之间的**关系**。这些细胞簇被视为一个无向图中的顶点。两个顶点之间的边表示相应的细胞簇是兼容可合并的。兼容性的准则被严格定义如下：\n1.  细胞簇必须源自不同的批次，即 $b(i) \\neq b(j)$。这是一个关键约束，因为目标是跨批次合并，而不是在批次内部合并（批次内部的簇假定是生物学上不同的）。\n2.  它们批次校正后的质心之间的欧几里得距离必须在给定的容差 $\\tau \\ge 0$ 范围内。这在数学上表示为：\n    $$\n    \\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau\n    $$\n    这个条件形式化了这样一个概念：如果两个细胞簇在生物学上是相同的，那么它们校正后的质心在特征空间中应该彼此非常接近。\n\n第三，最终的**合并组被识别为此兼容性图的连通分量**。一个连通分量是一个极大子图，其中任意两个顶点都通过路径相互连接。这个定义自然地将所有直接或间接兼容的细胞簇分在一组。因此，这样合并后组的总数等于图中连通分量的数量。\n\n为了计算这个数量，我们实现一个标准的图算法。对每个测试用例，我们执行以下步骤：\n1.  对每个观测到的细胞簇 $i$，计算其校正后的质心 $\\mathbf{c}_i$。\n2.  构建图的邻接表示（例如，邻接矩阵或邻接表），图有 $N$ 个顶点，其中 $N$ 是细胞簇的总数。遍历所有唯一的细胞簇对 $(i, j)$。\n3.  如果 $b(i) \\neq b(j)$ 且 $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau$，则在顶点 $i$ 和 $j$ 之间添加一条边。\n4.  利用图遍历算法，如深度优先搜索 (DFS) 或广度优先搜索 (BFS)，来计算连通分量的数量。或者，也可以使用专门的库函数，例如 `scipy.sparse.csgraph.connected_components`，来完成此任务。\n\n我们现在将此程序应用于每个测试用例。\n\n**测试用例 1：**\n- 批次: $B=2$。细胞簇: $A, C$ 在批次 1 中； $B, D$ 在批次 2 中。$\\tau = 0.2$。\n- 批次偏移: $\\mathbf{s}_1 = [1, 0]$, $\\mathbf{s}_2 = [-1, 0]$。\n- 观测质心: $\\mathbf{m}_A = [5, 0]$, $\\mathbf{m}_C = [1, 10]$, $\\mathbf{m}_B = [3, 0]$, $\\mathbf{m}_D = [-1, 10.15]$。\n- 校正后的质心:\n  - $\\mathbf{c}_A = \\mathbf{m}_A - \\mathbf{s}_1 = [5, 0] - [1, 0] = [4, 0]$。\n  - $\\mathbf{c}_C = \\mathbf{m}_C - \\mathbf{s}_1 = [1, 10] - [1, 0] = [0, 10]$。\n  - $\\mathbf{c}_B = \\mathbf{m}_B - \\mathbf{s}_2 = [3, 0] - [-1, 0] = [4, 0]$。\n  - $\\mathbf{c}_D = \\mathbf{m}_D - \\mathbf{s}_2 = [-1, 10.15] - [-1, 0] = [0, 10.15]$。\n- 兼容性检查 (在批次 1 和 2 之间):\n  - $\\lVert \\mathbf{c}_A - \\mathbf{c}_B \\rVert_2 = \\lVert [4, 0] - [4, 0] \\rVert_2 = 0 \\le 0.2$。边 $(A, B)$ 存在。\n  - $\\lVert \\mathbf{c}_C - \\mathbf{c}_D \\rVert_2 = \\lVert [0, 10] - [0, 10.15] \\rVert_2 = 0.15 \\le 0.2$。边 $(C, D)$ 存在。\n  - 所有其他跨批次距离都很大。\n- 该图有两个连通分量: $\\{A, B\\}$ 和 $\\{C, D\\}$。合并后的组数为 $2$。\n\n**测试用例 2：**\n- 批次: $B=3$。细胞簇: $A, D$ 在批次 1 中； $B, E$ 在批次 2 中； $C$ 在批次 3 中。$\\tau = 1.0$。\n- 批次偏移: $\\mathbf{s}_1 = [0, 0]$, $\\mathbf{s}_2 = [0.5, 0]$, $\\mathbf{s}_3 = [1.0, 0]$。\n- 校正后的质心:\n  - $\\mathbf{c}_A = [0, 0] - [0, 0] = [0, 0]$。\n  - $\\mathbf{c}_D = [100, 100]$。\n  - $\\mathbf{c}_B = [1.5, 0] - [0.5, 0] = [1.0, 0]$。\n  - $\\mathbf{c}_E = [-100, -100] - [0.5, 0] = [-100.5, -100]$。\n  - $\\mathbf{c}_C = [3.0, 0] - [1.0, 0] = [2.0, 0]$。\n- 兼容性检查:\n  - $\\lVert \\mathbf{c}_A - \\mathbf{c}_B \\rVert_2 = \\lVert [0, 0] - [1.0, 0] \\rVert_2 = 1.0 \\le 1.0$。边 $(A, B)$ 存在。\n  - $\\lVert \\mathbf{c}_B - \\mathbf{c}_C \\rVert_2 = \\lVert [1.0, 0] - [2.0, 0] \\rVert_2 = 1.0 \\le 1.0$。边 $(B, C)$ 存在。\n  - 与 $D$ 和 $E$ 之间的距离很大。\n- 该图有一个连通分量 $\\{A, B, C\\}$ 和两个孤立顶点 $\\{D\\}$ 和 $\\{E\\}$。合并后的组数为 $3$。\n\n**测试用例 3：**\n- 批次: $B=2$。细胞簇: $X, Z$ 在批次 1 中； $Y, W$ 在批次 2 中。$\\tau = 0.0$。\n- 批次偏移: $\\mathbf{s}_1 = [0.2, -0.1, 0.0]$, $\\mathbf{s}_2 = [-0.2, 0.1, 0.0]$。\n- 校正后的质心:\n  - $\\mathbf{c}_X = [1.2, 0.9, 3.0] - [0.2, -0.1, 0.0] = [1.0, 1.0, 3.0]$。\n  - $\\mathbf{c}_Z = [10.2, -4.1, 0.0] - [0.2, -0.1, 0.0] = [10.0, -4.0, 0.0]$。\n  - $\\mathbf{c}_Y = [0.8, 1.1, 3.0] - [-0.2, 0.1, 0.0] = [1.0, 1.0, 3.0]$。\n  - $\\mathbf{c}_W = [9.8, -3.9, 0.05] - [-0.2, 0.1, 0.0] = [10.0, -4.0, 0.05]$。\n- 兼容性检查 (当 $\\tau=0.0$ 时，距离必须恰好为 $0$):\n  - $\\mathbf{c}_X$ 与 $\\mathbf{c}_Y$ 相同，所以 $\\lVert \\mathbf{c}_X - \\mathbf{c}_Y \\rVert_2 = 0 \\le 0.0$。边 $(X, Y)$ 存在。\n  - 没有其他对具有相同的校正后质心。\n- 该图有一个连通分量 $\\{X, Y\\}$ 和两个孤立顶点 $\\{Z\\}$ 和 $\\{W\\}$。合并后的组数为 $3$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the cluster merging problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"batch_shifts\": {1: np.array([1.0, 0.0]), 2: np.array([-1.0, 0.0])},\n            \"tau\": 0.2,\n            \"clusters\": [\n                {'m': np.array([5.0, 0.0]), 'b': 1},\n                {'m': np.array([1.0, 10.0]), 'b': 1},\n                {'m': np.array([3.0, 0.0]), 'b': 2},\n                {'m': np.array([-1.0, 10.15]), 'b': 2},\n            ],\n        },\n        # Test Case 2\n        {\n            \"batch_shifts\": {\n                1: np.array([0.0, 0.0]),\n                2: np.array([0.5, 0.0]),\n                3: np.array([1.0, 0.0]),\n            },\n            \"tau\": 1.0,\n            \"clusters\": [\n                {'m': np.array([0.0, 0.0]), 'b': 1},\n                {'m': np.array([100.0, 100.0]), 'b': 1},\n                {'m': np.array([1.5, 0.0]), 'b': 2},\n                {'m': np.array([-100.0, -100.0]), 'b': 2},\n                {'m': np.array([3.0, 0.0]), 'b': 3},\n            ],\n        },\n        # Test Case 3\n        {\n            \"batch_shifts\": {\n                1: np.array([0.2, -0.1, 0.0]),\n                2: np.array([-0.2, 0.1, 0.0]),\n            },\n            \"tau\": 0.0,\n            \"clusters\": [\n                {'m': np.array([1.2, 0.9, 3.0]), 'b': 1},\n                {'m': np.array([10.2, -4.1, 0.0]), 'b': 1},\n                {'m': np.array([0.8, 1.1, 3.0]), 'b': 2},\n                {'m': np.array([9.8, -3.9, 0.05]), 'b': 2},\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        clusters_data = case[\"clusters\"]\n        batch_shifts = case[\"batch_shifts\"]\n        tau = case[\"tau\"]\n        num_clusters = len(clusters_data)\n\n        # Step 1: Compute batch-corrected centroids\n        corrected_centroids = []\n        for i in range(num_clusters):\n            m_i = clusters_data[i]['m']\n            b_i = clusters_data[i]['b']\n            s_i = batch_shifts[b_i]\n            c_i = m_i - s_i\n            corrected_centroids.append(c_i)\n\n        # Step 2: Build the adjacency matrix for the compatibility graph\n        adjacency_matrix = np.zeros((num_clusters, num_clusters), dtype=int)\n        for i in range(num_clusters):\n            for j in range(i + 1, num_clusters):\n                # Condition 1: Must be from different batches\n                b_i = clusters_data[i]['b']\n                b_j = clusters_data[j]['b']\n                if b_i == b_j:\n                    continue\n\n                # Condition 2: Distance between corrected centroids is within tolerance\n                c_i = corrected_centroids[i]\n                c_j = corrected_centroids[j]\n                distance = np.linalg.norm(c_i - c_j)\n\n                if distance <= tau:\n                    adjacency_matrix[i, j] = 1\n                    adjacency_matrix[j, i] = 1\n\n        # Step 3: Count the number of connected components\n        n_components, _ = connected_components(\n            csgraph=adjacency_matrix, directed=False, return_labels=True\n        )\n        results.append(n_components)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2429786"}, {"introduction": "成功将细胞分群后，下一步是解读这些细胞簇的生物学意义，而鉴定标记基因是实现这一目标的核心。本练习将教你如何使用受试者工作特征曲线下面积（Area Under the ROC Curve, AUROC）这一强大的统计工具，来量化每个基因区分特定细胞簇与其他细胞的能力。通过为候选基因计算 $AUROC$ 值并进行排序[@problem_id:2429791]，你将掌握从聚类结果中提取生物学洞见的关键分析方法。", "problem": "您将获得来自单细胞RNA测序(scRNA-seq)的多个基因在单个细胞中的表达量测量值，以及每个细胞的聚类成员关系的二元指示符。将每个基因在所有细胞中的表达量视为一个数值分数，用于将目标聚类与所有其他细胞区分开。使用受试者工作特征(ROC)曲线下面积(AUROC)来评估每个基因的表达量将目标聚类与其余细胞分开的程度。受试者工作特征(ROC)是根据真阳性率和假阳性率定义的，此时判别阈值在所有可能的分数值上变化。ROC曲线下面积(AUROC)是从正类中均匀抽取的得分超过从负类中均匀抽取的得分的概率，平局情况贡献二分之一。形式上，对于一个给定基因，其在细胞 $i \\in \\{1,\\dots,N\\}$ 上的得分为 $s_i$，其聚类成员关系由二元标签 $y_i \\in \\{0,1\\}$ 指示，定义\n$$\n\\mathrm{AUROC} \\;=\\; \\frac{1}{n_1\\, n_0}\\sum_{\\substack{i:\\, y_i=1}}\\sum_{\\substack{j:\\, y_j=0}}\\left(\\mathbf{1}\\{s_i > s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\}\\right),\n$$\n其中 $n_1 = \\sum_i y_i$ 是正类（聚类内）细胞的数量，$n_0 = N - n_1$ 是负类（聚类外）细胞的数量，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n对于下面的每个测试用例，您将获得：\n- 一个二元聚类标签向量 $y \\in \\{0,1\\}^N$，其中两个类别都存在（即 $0 < \\sum_i y_i < N$），以及\n- 一个细胞-基因得分矩阵 $X \\in \\mathbb{R}^{N \\times G}$，其中第 $g$ 列包含基因索引为 $g$ 在所有 $N$ 个细胞中的得分 $s_i$。\n\n您在每个测试用例中的任务是：\n1. 根据上述定义，为每个基因 $g \\in \\{0,\\dots,G-1\\}$ 计算AUROC。在您最终报告的数字中，将每个AUROC值四舍五入到6位小数。\n2. 按AUROC降序生成基因索引的排序。如果两个或多个基因的AUROC值完全相同，则按基因索引升序打破平局（即，较小的索引排在前面）。\n\n测试套件：\n- 测试用例 $1$：\n  - $y = [\\,1,1,1,0,0,0,0,0\\,]$。\n  - $X$ 有 $N=8$ 行（细胞）和 $G=5$ 列（基因），其中每一行按顺序为 $[g_0,g_1,g_2,g_3,g_4]$ 列出得分：\n    - 第 $0$ 行：$[\\,6,1,0,2,3\\,]$\n    - 第 $1$ 行：$[\\,4,0,1,2,1\\,]$\n    - 第 $2$ 行：$[\\,5,1,0,2,2\\,]$\n    - 第 $3$ 行：$[\\,2,1,3,2,2\\,]$\n    - 第 $4$ 行：$[\\,1,0,2,2,1\\,]$\n    - 第 $5$ 行：$[\\,0,1,4,2,2\\,]$\n    - 第 $6$ 行：$[\\,1,0,1,2,0\\,]$\n    - 第 $7$ 行：$[\\,2,1,2,2,3\\,]$\n- 测试用例 $2$：\n  - $y = [\\,0,0,1,0\\,]$。\n  - $X$ 有 $N=4$ 行和 $G=4$ 列，行为 $[g_0,g_1,g_2,g_3]$：\n    - 第 $0$ 行：$[\\,1,5,3,2\\,]$\n    - 第 $1$ 行：$[\\,2,4,3,5\\,]$\n    - 第 $2$ 行：$[\\,5,1,3,5\\,]$\n    - 第 $3$ 行：$[\\,2,4,3,5\\,]$\n- 测试用例 $3$：\n  - $y = [\\,1,1,1,1,1,0,0\\,]$。\n  - $X$ 有 $N=7$ 行和 $G=3$ 列，行为 $[g_0,g_1,g_2]$：\n    - 第 $0$ 行：$[\\,3,0,0\\,]$\n    - 第 $1$ 行：$[\\,0,1,2\\,]$\n    - 第 $2$ 行：$[\\,2,0,0\\,]$\n    - 第 $3$ 行：$[\\,0,0,1\\,]$\n    - 第 $4$ 行：$[\\,1,1,1\\,]$\n    - 第 $5$ 行：$[\\,0,3,1\\,]$\n    - 第 $6$ 行：$[\\,0,2,0\\,]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例结果的一个列表。对于每个测试用例，输出一个包含两个元素的列表：第一个元素是基因 $[0,1,\\dots,G-1]$ 的AUROC值列表，四舍五入到6位小数；第二个元素是如上所述的排序后的基因索引列表。因此，总输出应为单行，表示一个包含三个元素（对应三个测试用例）的列表，其中每个元素本身就是一个双元素列表。元素必须聚合成单行文本，并用方括号括起来。例如，形状应类似于 $[\\,[\\,[\\dots],[\\dots]\\,],\\,[\\,[\\dots],[\\dots]\\,],\\,[\\,[\\dots],[\\dots]\\,]\\,]$。该问题不涉及物理单位或角度。所有数值输出必须是根据上下文要求的实数或整数，其中AUROC值报告为四舍五入到6位的小数。", "solution": "所提出的问题是有效的。它在科学上基于生物信息学和统计学的原理，特别是关于单细胞RNA测序(scRNA-seq)数据的分析。任务是根据基因作为指定细胞聚类的标记物的效用对其进行评估和排序。此评估的度量标准是受试者工作特征曲线下面积(AUROC)，这是一个标准的非参数度量，用于衡量评分系统区分两个类别的能力。该问题为AUROC提供了精确的数学定义，所有必需的输入数据（$y$，聚类标签，以及$X$，基因表达矩阵），以及关于期望输出的明确指令，包括平局打破规则。这是一个适定的问题，没有缺失信息、矛盾或歧义。\n\n问题的核心是计算每个基因的AUROC，它作为其判别能力的得分。提供的公式是：\n$$\n\\mathrm{AUROC} \\;=\\; \\frac{1}{n_1\\, n_0}\\sum_{\\substack{i:\\, y_i=1}}\\sum_{\\substack{j:\\, y_j=0}}\\left(\\mathbf{1}\\{s_i > s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\}\\right)\n$$\n其中 $s_i$ 是给定基因在所有 $N$ 个细胞中的表达得分，$y_i$ 是指示目标聚类成员关系（$y_i=1$）与所有其他细胞（$y_i=0$）的二元标签。术语 $n_1$ 和 $n_0$ 分别代表目标聚类内和聚类外的细胞数量。此公式对应于从正类（聚类）中随机选择的一个细胞的基因表达得分高于从负类（聚类外）中随机选择的一个细胞的基因表达得分的概率，平局贡献值为 $\\frac{1}{2}$。\n\n解题步骤如下：\n1. 对于每个测试用例，我们都得到了一个标签向量 $y$ 和一个得分矩阵 $X$。\n2. 我们遍历每个基因 $g$，它对应于矩阵 $X$ 中的一列。让这一列的得分向量为 $s$。\n3. 使用标签向量 $y$，我们将 $s$ 中的得分划分为两个集合：$S_1 = \\{s_i \\mid y_i=1\\}$，即目标聚类内细胞的得分集合，以及 $S_0 = \\{s_j \\mid y_j=0\\}$，即聚类外细胞的得分集合。令它们各自的大小为 $n_1 = |S_1|$ 和 $n_0 = |S_0|$。问题保证 $n_1 > 0$ 和 $n_0 > 0$。\n4. 然后我们计算AUROC公式的分子，也就是配对比较的总和。对于 $S_1$ 中的每个得分 $s_i$，我们将其与 $S_0$ 中的每个得分 $s_j$进行比较。\n    - 如果 $s_i > s_j$，我们将 $1$ 加到一个累加和中。\n    - 如果 $s_i = s_j$，我们将 $0.5$ 加到累加和中。\n    - 如果 $s_i < s_j$，我们加 $0$。\n5. 在所有配对都比较完毕后，将总和除以总配对数，即乘积 $n_1 n_0$。这就得出了基因 $g$ 的AUROC。\n6. 对所有 $G$ 个基因重复此过程，得到一个包含 $G$ 个AUROC值的列表。根据规定，每个值都四舍五入到6位小数。\n7. 最后，我们必须对基因进行排序。主要排序标准是AUROC值，按降序排列。更高的AUROC表示更好的分离度，因此具有更高值的基因排在最前面。次要标准用于打破平局：如果两个或更多基因具有完全相同的AUROC值，则索引较小的基因排名更高。我们通过根据一个键对基因索引进行排序来实现这一点，该键结合了负AUROC值（用于降序）和基因索引（用于升序）。\n\n该步骤将应用于提供的每个测试用例。然后将结果聚合到为最终输出指定的嵌套列表结构中。实现将利用 `numpy` 库进行高效的向量化操作，特别是对于可以通过广播完成的配对比较。\n\n例如，对于给定的基因，如果 `s_pos` 是来自正类的得分数组，而 `s_neg` 是来自负类的得分数组，则可以高效地计算总分。通过将 `s_pos` 重塑为形状为 ($n_1$, $1$) 的列向量，并将 `s_neg` 保持为形状为 ($1$, $n_0$) 的行向量，`numpy` 的广播规则将创建一个 $n_1 \\times n_0$ 的配对比较矩阵。正类得分大于负类得分的总和是 `np.sum(s_pos[:, np.newaxis] > s_neg)`，而平局的总和是 `np.sum(s_pos[:, np.newaxis] == s_neg)`。这避免了在Python中使用显式的、更慢的嵌套循环。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AUROC gene ranking problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"y\": np.array([1, 1, 1, 0, 0, 0, 0, 0]),\n            \"X\": np.array([\n                [6, 1, 0, 2, 3],\n                [4, 0, 1, 2, 1],\n                [5, 1, 0, 2, 2],\n                [2, 1, 3, 2, 2],\n                [1, 0, 2, 2, 1],\n                [0, 1, 4, 2, 2],\n                [1, 0, 1, 2, 0],\n                [2, 1, 2, 2, 3],\n            ])\n        },\n        {\n            \"y\": np.array([0, 0, 1, 0]),\n            \"X\": np.array([\n                [1, 5, 3, 2],\n                [2, 4, 3, 5],\n                [5, 1, 3, 5],\n                [2, 4, 3, 5],\n            ])\n        },\n        {\n            \"y\": np.array([1, 1, 1, 1, 1, 0, 0]),\n            \"X\": np.array([\n                [3, 0, 0],\n                [0, 1, 2],\n                [2, 0, 0],\n                [0, 0, 1],\n                [1, 1, 1],\n                [0, 3, 1],\n                [0, 2, 0],\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        y = case[\"y\"]\n        X = case[\"X\"]\n        \n        N, G = X.shape\n        \n        y_bool = y.astype(bool)\n        s_pos_all = X[y_bool, :]\n        s_neg_all = X[~y_bool, :]\n        \n        n1 = s_pos_all.shape[0]\n        n0 = s_neg_all.shape[0]\n        \n        if n1 == 0 or n0 == 0:\n            continue\n            \n        aurocs = []\n        for g in range(G):\n            s_pos = s_pos_all[:, g]\n            s_neg = s_neg_all[:, g]\n            \n            # Using broadcasting for efficient pairwise comparison\n            gt_sum = np.sum(s_pos[:, np.newaxis] > s_neg)\n            eq_sum = np.sum(s_pos[:, np.newaxis] == s_neg)\n            \n            comparison_sum = gt_sum + 0.5 * eq_sum\n            auroc = comparison_sum / (n1 * n0)\n            aurocs.append(auroc)\n            \n        rounded_aurocs = [round(a, 6) for a in aurocs]\n        \n        # Rank genes: descending AUROC, ascending gene index for ties\n        gene_indices = list(range(G))\n        ranked_indices = sorted(gene_indices, key=lambda i: (-rounded_aurocs[i], i))\n        \n        all_results.append([rounded_aurocs, ranked_indices])\n\n    # Format output to a compact, single-line string representation of the list\n    # with no spaces.\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2429791"}]}