{"hands_on_practices": [{"introduction": "理论通过实践才得以升华。为了掌握从头预测的核心思想，让我们从一个基础但极具启发性的练习开始。晶格模型通过将复杂的蛋白质结构简化为二维或三维网格上的路径，使我们能够探索蛋白质折叠的基本物理原理。这项实践要求你从零开始，构建一个包含疏水性、极性以及带电残基的扩展晶格模型（HPNC模型），并将疏水效应和静电相互作用等关键驱动力转化为一个可计算的能量函数。通过对一个短肽链的所有可能构象和序列进行彻底的穷举搜索，你将亲身体验构象空间的概念，并学习如何在其中找到能量最低的稳定结构。[@problem_id:2369976]", "problem": "你的任务是形式化并实现一个二维（$2$D）疏水-极性（HP）蛋白质晶格模型的扩展，该模型扩展为一个包含带电残基的四字母表模型，记为疏水（Hydrophobic）、极性（Polar）、带负电（Negative）、带正电（Cationic）(HPNC)。目标是搜寻一个短多肽序列和一个在方形晶格上的自回避$2$D构象，它们共同达到最小的加性接触能量，同时包含至少一个盐桥。此处，盐桥被定义为一个非连续的最近邻晶格接触，该接触发生在带负电残基和带正电残基之间。\n\n请从适用于从头算蛋白质结构预测中使用的晶格蛋白质模型的第一性原理出发。基本依据必须是以下事实，不使用任何简化公式：\n- 蛋白质可以被抽象为晶格上的自回避行走，其中每个残基占据一个晶格位点，且连续的残基在晶格上是相邻的。只有非连续的最近邻残基对才被视为接触相互作用。\n- 疏水效应促使疏水残基在接触时产生有利的吸引力，这通过为疏水-疏水接触设定一个负的接触能量贡献来建模。\n- 带电残基之间的静电相互作用促使异性电荷接触具有有利能量，而同性电荷接触具有不利能量。在一个以晶格间距为单位长度的粗粒度晶格模型中，可以通过为异性电荷设置一个恒定的负贡献和为同性电荷设置一个恒定的正贡献来近似这种相互作用，此贡献仅应用于最近邻的非连续接触。\n- 可加性假设：总能量是所有非连续接触残基对的成对接触能量的总和。\n\n你的程序必须实现以下精确的模型和搜索协议。\n- 残基类型是一个包含$4$个字母的字母表：疏水（$\\mathrm{H}$）、极性（$\\mathrm{P}$）、带负电（$\\mathrm{N}$）和带正电（$\\mathrm{C}$）。序列是基于此字母表的一个长度为$L$的字符串。\n- 构象是在二维方形晶格上长度为$L$的自回避行走，坐标在$\\mathbb{Z}^2$中，表示为一个晶格坐标列表$\\left[(x_0,y_0),(x_1,y_1),\\dots,(x_{L-1},y_{L-1})\\right]$，步长为单位长度且无重复坐标。为了避免冗余的对称性，固定$(x_0,y_0)=(0,0)$和$(x_1,y_1)=(1,0)$。\n- 将构象的接触集$\\mathcal{C}$定义为所有满足$0 \\le i < j \\le L-1$的无序索引对$(i,j)$，使得$|i-j| \\ge 2$且$(x_i,y_i)$和$(x_j,y_j)$之间的曼哈顿距离等于$1$。\n- 将残基类型$a$和$b$的成对接触能量函数$\\varepsilon(a,b)$定义如下，使用每个测试用例提供的参数$e_{\\mathrm{HH}}$、$e_{\\mathrm{NC}}$和$e_{\\mathrm{like}}$。设$\\mathrm{H}=0$、$\\mathrm{P}=1$、$\\mathrm{N}=2$、$\\mathrm{C}=3$用于编码。则：\n  - $\\varepsilon(\\mathrm{H},\\mathrm{H})=\\varepsilon(0,0)=e_{\\mathrm{HH}}$。\n  - $\\varepsilon(\\mathrm{N},\\mathrm{C})=\\varepsilon(2,3)=\\varepsilon(\\mathrm{C},\\mathrm{N})=\\varepsilon(3,2)=e_{\\mathrm{NC}}$。\n  - $\\varepsilon(\\mathrm{N},\\mathrm{N})=\\varepsilon(2,2)=e_{\\mathrm{like}}$ 且 $\\varepsilon(\\mathrm{C},\\mathrm{C})=\\varepsilon(3,3)=e_{\\mathrm{like}}$。\n  - 所有其他残基对的$\\varepsilon(a,b)=0$。\n- 对于一个序列$\\{t_i\\}_{i=0}^{L-1}$和一个具有接触集$\\mathcal{C}$的构象，总能量为\n  $$E=\\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon\\left(t_i,t_j\\right).$$\n- 盐桥计数为\n  $$S=\\left|\\left\\{(i,j)\\in\\mathcal{C}\\;:\\;\\{t_i,t_j\\}=\\{\\mathrm{N},\\mathrm{C}\\}\\right\\}\\right|.$$\n- 一个解必须至少有一个盐桥，即$S \\ge 1$。\n\n搜索目标和决胜规则：\n- 在所有长度为$L$的HPNC字母表序列和所有如上定义的有效构象中，找到在$S \\ge 1$的约束下最小化$E$的（序列-构象）对。\n- 如果有多个（序列-构象）对达到相同的最小$E$，选择$S$最大的那个。\n- 如果仍然存在平局，在编码$\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$下，选择字典序最小的序列，从左到右比较整数列表。\n- 如果仍然存在平局，选择其展平坐标列表$\\left[x_0,y_0,x_1,y_1,\\dots,x_{L-1},y_{L-1}\\right]$字典序最小的构象。\n\n序列编码和输出表示：\n- 将序列编码为一个包含$L$个整数的列表，这些整数在$\\{0,1,2,3\\}$中，分别对应于$\\mathrm{H},\\mathrm{P},\\mathrm{N},\\mathrm{C}$。\n- 将构象编码为一个包含$L$个坐标对的列表，每个坐标对是一个包含两个整数$\\left[x_i,y_i\\right]$的列表。\n\n你的程序必须执行穷举搜索，以保证通过以下方式为下面这些小型测试用例找到精确的最优解：\n- 枚举所有在方形晶格上长度为$L$且具有上述锚定的自回避行走。\n- 枚举所有基于大小为4的字母表的长度为$L$的序列。\n- 为每一对（序列-构象）精确计算$E$和$S$，并应用目标和决胜规则。\n\n测试套件：\n- 案例A（理想路径）：$L=6$，$e_{\\mathrm{HH}}=-1.0$，$e_{\\mathrm{NC}}=-2.0$，$e_{\\mathrm{like}}=+0.5$。\n- 案例B（盐桥主导）：$L=7$，$e_{\\mathrm{HH}}=0.0$，$e_{\\mathrm{NC}}=-2.5$，$e_{\\mathrm{like}}=+0.5$。\n- 案例C（强同性电荷排斥）：$L=6$，$e_{\\mathrm{HH}}=-0.5$，$e_{\\mathrm{NC}}=-1.0$，$e_{\\mathrm{like}}=+1.0$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含用方括号括起来的、以逗号分隔的结果列表，其中每个结果对应一个测试用例，顺序与上面列出的一致。\n- 每个结果都必须是$[E_{\\min},S_{\\mathrm{best}},\\mathrm{seq},\\mathrm{coords}]$形式的列表，其中$E_{\\min}$是四舍五入到三位小数的最小能量（作为实数），$S_{\\mathrm{best}}$是所选解的盐桥计数（作为整数），$\\mathrm{seq}$是编码为$\\{0,1,2,3\\}$中整数列表的所选序列，$\\mathrm{coords}$是编码为指定坐标对列表的所选构象。\n- 因此，最终输出必须是包含诸如$[\\mathrm{r}_\\mathrm{A},\\mathrm{r}_\\mathrm{B},\\mathrm{r}_\\mathrm{C}]$内容的单行，其中每个$\\mathrm{r}_\\mathrm{X}$是对应案例的上述格式的列表。不要打印任何其他文本。", "solution": "所呈现的问题是在计算蛋白质结构预测框架内的一个约束优化任务。它要求形式化并实现一个四字母疏水-极性-带负电-带正电（HPNC）晶格模型。其目标是找到一个多肽序列及其在二维（$2$D）方形晶格上的相应自回避构象，二者共同作用，在结构必须包含至少一个盐桥的约束下，达到最小可能的加性接触能量。盐桥被定义为带负电（$\\mathrm{N}$）和带正电（$\\mathrm{C}$）残基之间的非共价接触。\n\n该问题定义明確，科学上植根于粗粒度蛋白质模型的原理，并为确定唯一解提供了所有必要的定义和参数。该模型是经典疏水-极性（HP）模型的扩展，引入了静电效应，这是该领域的标准方法。鉴于指定的序列长度较小（$L=6$ 和 $L=7$），对完整的构象和序列空间进行穷举搜索在计算上是可行的，并且是保证找到由分层目标函数定义的真正全局最优解的唯一方法。\n\n因此，解决方案被设计为一个穷举搜索算法，该算法系统地探索所有有效的序列-构象对，对其进行评估，并根据指定的标准识别最优对。该算法按以下步骤进行：\n\n首先，我们必须生成所有可能的分子实体的整个空间。这个空间是所有唯一的有效构象集合与所有长度为 $L$ 的可能序列集合的笛卡尔积。\n\n构象是 $2$D 方形晶格上长度为 $L$ 的自回避行走。为生成所有此类构象，我们采用递归回溯（深度优先搜索）算法。行走被锚定，前两个残基的坐标为 $(x_0,y_0)=(0,0)$ 和 $(x_1,y_1)=(1,0)$，以消除平凡的旋转和平移对称性。递归过程一次扩展一个残基的行走，探索所有四个基本方向，同时确保新的晶格位点未被占据。当完成长度为 $L$ 的行走时，便将其添加到我们的有效构象列表中。\n\n序列是字母表 $\\{\\mathrm{H}, \\mathrm{P}, \\mathrm{N}, \\mathrm{C}\\}$ 上长度为 $L$ 的字符串，我们将其编码为整数 $\\{0, 1, 2, 3\\}$。序列总数为 $4^L$。这些序列被系统地生成，以确保考虑到每一种可能的序列。这可以通过遍历所有以 4 为基数的 $L$ 位数来实现。\n\n对于每个构象和序列对，我们必须计算其总能量 $E$ 和盐桥数 $S$。此评估分两步执行。\n1. 给定一个构象，我们首先确定其接触集 $\\mathcal{C}$。一个接触是一个无序的残基索引对 $(i,j)$，使得这些残基在序列中不相邻（$|i-j| \\ge 2$），但在晶格上占据相邻位点。邻接性通过检查其坐标之间的曼哈顿距离是否等于 $1$ 来确定。\n2. 利用接触集 $\\mathcal{C}$ 和序列 $\\{t_i\\}_{i=0}^{L-1}$，我们计算总能量 $E$ 和盐桥数 $S$。总能量是成对相互作用能量的总和，$E = \\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon(t_i, t_j)$。能量函数 $\\varepsilon(a,b)$ 由问题参数 $e_{\\mathrm{HH}}$、$e_{\\mathrm{NC}}$ 和 $e_{\\mathrm{like}}$ 定义，并且仅对 $\\mathrm{H}-\\mathrm{H}$、$\\mathrm{N}-\\mathrm{C}$、$\\mathrm{N}-\\mathrm{N}$ 和 $\\mathrm{C}-\\mathrm{C}$ 接触非零。盐桥数 $S$ 是 $\\mathcal{C}$ 中残基类型为 $\\{\\mathrm{N}, \\mathrm{C}\\}$ 的接触数量。\n\n最后，我们确定最优解。搜索必须遵守一个严格的、四级的决胜规则。我们力求：\n1. 最小化总能量 $E$。\n2. 对于给定的最小 $E$，最大化盐桥数 $S$。\n3. 对于给定的 $E$ 和 $S$，选择字典序最小的序列（使用整数编码）。\n4. 作为最终的决胜规则，选择其展平坐标列表字典序最小的构象。\n\n这种分层优化是通过在整个穷举搜索过程中维护一个单一的“迄今为止最优”解来实现的。每个新的有效候选解（即 $S \\ge 1$ 的解）都与当前的最佳解进行比较。如果一个候选解对应的目标元组在字典序上小于当前最佳解的元组，则该候选解被认为是“更优”的。对于一个由序列 $\\mathbf{t}$ 和构象 $\\mathbf{x}$ 组成的候选解，其目标元组被构建为 $(E, -S, \\mathbf{t}, \\mathbf{x}_{\\text{flat}})$，其中 $\\mathbf{t}$ 是整数编码的残基类型的元组，$\\mathbf{x}_{\\text{flat}}$ 是展平的坐标元组。$S$ 的否定正确地将最大化 $S$ 的问题转化为最小化问题，从而适应字典序比较框架。通过遍历所有序列-构象对并应用此比较，该算法保证能够收敛到问题陈述所定义的唯一最优解。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef generate_conformations(L):\n    \"\"\"\n    Generates all self-avoiding walks of length L on a 2D square lattice,\n    anchored at (0,0) and (1,0).\n    \"\"\"\n    if L < 2:\n        return []\n\n    # Anchored start as specified\n    path = [(0, 0), (1, 0)]\n    if L == 2:\n        return [tuple(path)]\n    \n    visited = set(path)\n    conformations = []\n    \n    def extend_walk(current_path, visited_sites):\n        if len(current_path) == L:\n            conformations.append(tuple(current_path))\n            return\n            \n        last_x, last_y = current_path[-1]\n        # Possible moves: North, South, East, West\n        moves = [(last_x, last_y + 1), (last_x, last_y - 1), (last_x + 1, last_y), (last_x - 1, last_y)]\n        \n        for next_pos in moves:\n            if next_pos not in visited_sites:\n                current_path.append(next_pos)\n                visited_sites.add(next_pos)\n                extend_walk(current_path, visited_sites)\n                visited_sites.remove(next_pos) # Backtrack\n                current_path.pop()\n\n    extend_walk(path, visited)\n    return conformations\n\ndef find_contacts(conf, L):\n    \"\"\"\n    Finds all non-consecutive nearest-neighbor contacts for a given conformation.\n    \"\"\"\n    contacts = []\n    for i in range(L - 1):\n        for j in range(i + 2, L):\n            xi, yi = conf[i]\n            xj, yj = conf[j]\n            if abs(xi - xj) + abs(yi - yj) == 1:\n                contacts.append((i, j))\n    return contacts\n\ndef make_energy_matrix(e_HH, e_NC, e_like):\n    \"\"\"\n    Creates the 4x4 pairwise energy matrix.\n    Encoding: H=0, P=1, N=2, C=3\n    \"\"\"\n    energy_matrix = np.zeros((4, 4), dtype=float)\n    energy_matrix[0, 0] = e_HH\n    energy_matrix[2, 3] = e_NC\n    energy_matrix[3, 2] = e_NC\n    energy_matrix[2, 2] = e_like\n    energy_matrix[3, 3] = e_like\n    return energy_matrix\n\ndef evaluate(seq, contacts, energy_matrix):\n    \"\"\"\n    Calculates total energy E and salt bridge count S for a sequence and its contacts.\n    \"\"\"\n    E = 0.0\n    S = 0\n    N_type, C_type = 2, 3\n    \n    for i, j in contacts:\n        type1, type2 = seq[i], seq[j]\n        E += energy_matrix[type1, type2]\n        if (type1 == N_type and type2 == C_type) or (type1 == C_type and type2 == N_type):\n            S += 1\n    return E, S\n\ndef find_optimal_structure(L, e_HH, e_NC, e_like):\n    \"\"\"\n    Performs the exhaustive search for the optimal sequence and conformation.\n    \"\"\"\n    energy_matrix = make_energy_matrix(e_HH, e_NC, e_like)\n    \n    all_conformations = generate_conformations(L)\n    \n    best_result_tuple = (float('inf'),)\n    best_solution_details = None\n\n    # Pre-calculate contacts for each conformation\n    conf_contacts = {conf: find_contacts(conf, L) for conf in all_conformations}\n    \n    # Iterate through all sequences and conformations to find the optimum\n    for seq in itertools.product(range(4), repeat=L):\n        seq_tuple = tuple(seq)\n        for conf in all_conformations:\n            contacts = conf_contacts[conf]\n            E, S = evaluate(seq_tuple, contacts, energy_matrix)\n\n            if S < 1:\n                continue\n\n            conf_flat_tuple = tuple(coord for pair in conf for coord in pair)\n            current_result_tuple = (E, -S, seq_tuple, conf_flat_tuple)\n\n            if best_solution_details is None or current_result_tuple < best_result_tuple:\n                best_result_tuple = current_result_tuple\n                best_solution_details = (E, S, seq_tuple, conf)\n    \n    E, S, seq, conf = best_solution_details\n    return E, S, list(seq), [list(c) for c in conf]\n\ndef format_result_list(res_list):\n    \"\"\"\n    Formats the final result list for one test case into the required string format.\n    \"\"\"\n    E, S, seq, coords = res_list\n    E_str = f\"{E:.3f}\"\n    seq_str = str(seq).replace(\" \", \"\")\n    coords_str = str(coords).replace(\" \", \"\")\n    return f\"[{E_str},{S},{seq_str},{coords_str}]\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (L, e_HH, e_NC, e_like)\n        (6, -1.0, -2.0, 0.5),  # Case A\n        (7, 0.0, -2.5, 0.5),  # Case B\n        (6, -0.5, -1.0, 1.0),  # Case C\n    ]\n    \n    results = []\n    for L, e_HH, e_NC, e_like in test_cases:\n        E_min, S_best, seq, coords = find_optimal_structure(L, e_HH, e_NC, e_like)\n        results.append([E_min, S_best, seq, coords])\n    \n    final_output_str_parts = [format_result_list(res) for res in results]\n    final_output = f\"[{','.join(final_output_str_parts)}]\"\n    print(final_output)\n\n# Execute the solver\nsolve()\n```", "id": "2369976"}, {"introduction": "虽然穷举搜索对于理解基本原理很有帮助，但对于真实长度的蛋白质来说，其构象空间的巨大规模使得这种方法变得不切实际。为了应对这一挑战，科学家们开发了更智能的采样策略，其中最成功的之一是基于片段的组装方法，例如Rosetta软件所采用的策略。这项“思想实验”式的练习将引导你深入思考采样方法的核心作用。通过分析一个假设情景——即使用一个与目标蛋白质结构类型完全不匹配的片段库进行折叠预测——你将揭示采样偏差如何深刻地影响甚至决定预测的成败。这个练习强调了，在蒙特卡洛搜索中，一个精心设计的“移动”集合对于有效探索构象空间并最终找到天然结构是何等重要。[@problem_id:2381444]", "problem": "在Rosetta框架内的基于片段的蛋白质结构预测中，从已知结构中提取的短主链片段（通常是$3$-mers和$9$-mers）在一个由打分函数引导的蒙特卡洛（MC）搜索过程中被插入到一个演化中的模型中。考虑一个目标蛋白的假设性从头折叠运行，该蛋白的天然结构是全-$\\beta$结构。由于一个错误，片段库完全由一个全-$\\alpha$蛋白的非冗余集合构建而成，因此片段的$\\phi$和$\\psi$二面角分布主要占据α-螺旋区域。所有其他参数（温度方案、移动频率以及低分辨率和全原子阶段的打分函数）都是标准的。以下哪种结果最有可能发生？\n\nA. 搜索将强烈偏向于$\\alpha$-螺旋构象；它将很少采样到形成$\\beta$-折叠所必需的伸展的$\\beta$-链几何构型；结果，诱饵结构将集中在螺旋拓扑结构中，与类天然的$\\beta$折叠相比，其全原子和低分辨率得分都相对较差，并且该运行过程将表现出向低均方根偏差（RMSD）模型收敛性差。\n\nB. Rosetta全原子打分函数包含明确的$\\beta$-折叠氢键项，这将迫使片段插入的螺旋解旋并重排成$\\beta$-折叠，因此搜索仍能高效地找到正确的折叠，其收敛性与使用匹配的片段库时相似。\n\nC. 因为片段很短（$3$-mers和$9$-mers），其二级结构内容是无关紧要的；只要有足够的蒙特卡洛步数，采样实际上仍然是无偏的，并且能够以不受影响的效率达到正确的$\\beta$拓扑结构。\n\nD. 由于$\\alpha$和$\\beta$区域的$\\phi$和$\\psi$二面角限制不同，移动集变得无效，导致频繁的违规并被确定性地拒绝；因此，马尔可夫链无法继续进行，模拟会提前终止。", "solution": "对问题陈述进行了严格评估，认定其有效。它描述了计算蛋白质结构预测领域中一个科学上可信的场景，该场景设定良好、客观且自成体系。该问题关注在蒙特卡洛搜索中使用构象偏向的移动集所产生的可预测结果，这是该领域的标准课题。\n\n该问题描述了一个使用Rosetta框架的*从头*蛋白质折叠模拟。在这种方法中，构象空间通过蒙特卡洛（MC）搜索进行探索。一种关键的移动类型是插入主链二面角片段，这些片段通常长度为3和9个残基（$3$-mers和$9$-mers），从一个已知蛋白质结构的库中提取。一个移动是否被接受，由打分函数和Metropolis准则决定。\n\n问题的核心在于模拟中两个组成部分之间的冲突：\n1.  **采样偏向：** 片段库完全由全-$\\alpha$蛋白构建。这意味着可用片段的二面角（$\\phi$, $\\psi$）将主要位于拉曼钱德兰图的$\\alpha$-螺旋区域（大约$\\phi \\approx -60^\\circ$，$\\psi \\approx -40^\\circ$）。因此，对主链构象进行显著改变的主要方法被严重偏向于产生和维持$\\alpha$-螺旋二级结构。\n2.  **目标结构：** 目标蛋白的天然结构是全-$\\beta$结构。这意味着其构成残基应采用位于拉曼钱德兰图$\\beta$-链区域的二面角（大约$\\phi \\approx -120^\\circ$，$\\psi \\approx +135^\\circ$）。对于该蛋白质，由Rosetta打分函数定义的能量景观的全局最小值对应于这个全-$\\beta$折叠。\n\n模拟的结果由这种有偏采样和能量景观之间的相互作用决定。MC搜索将按以下方式进行：\n- 片段插入移动将持续提出具有$\\alpha$-螺旋特征的局部构象。这将非常有效地采样螺旋拓扑结构。\n- 搜索将无法有效地采样伸展的$\\beta$-链构象，因为所需的$(\\phi, \\psi)$角系统性地缺失于片段库提供的移动集中。虽然存在其他的小扰动移动（`small`和`shear`），但在实际的模拟时间尺度上，它们不足以使构象从一个紧凑的螺旋球状结构转变为一个伸展的$\\beta$-折叠拓扑结构。\n- 生成的构象（“诱饵结构”）因此将主要是螺旋结构。\n- Rosetta打分函数（包括低分辨率和全原子）旨在识别天然折叠的能量优势。对于一个全-$\\beta$蛋白，打分函数将正确地为天然的$\\beta$-折叠拓扑结构赋予比任何非天然的螺旋排列低得多（更好）的能量。采样的螺旋诱饵结构将缺乏稳定天然$\\beta$-折叠的特定长程氢键网络和三级结构堆积，导致高（差）分。\n- 模拟将无法收敛。能量-RMSD图将不会显示出典型的漏斗形状，即最低能量的结构与天然态的均方根偏差（RMSD）很低。取而代之的是，搜索找到的最低能量结构将是具有高RMSD的非天然螺旋紧凑态。\n\n基于此理解，我们评估给出的选项：\n\n**A. 搜索将强烈偏向于$\\alpha$-螺旋构象；它将很少采样到形成$\\beta$-折叠所必需的伸展的$\\beta$-链几何构型；结果，诱饵结构将集中在螺旋拓扑结构中，与类天然的$\\beta$折叠相比，其全原子和低分辨率得分都相对较差，并且该运行过程将表现出向低均方根偏差（RMSD）模型收敛性差。**\n这一陈述是对预期结果的精确和准确描述。采样受到片段库的偏向，无法进入构象空间的正确区域。由此产生的诱饵结构是非天然的，因此得分很差。整体预测失败，表现为无法收敛到低RMSD的结构。\n**结论：正确。**\n\n**B. Rosetta全原子打分函数包含明确的$\\beta$-折叠氢键项，这将迫使片段插入的螺旋解旋并重排成$\\beta$-折叠，因此搜索仍能高效地找到正确的折叠，其收敛性与使用匹配的片段库时相似。**\n这一陈述是错误的。打分函数是评估构象的；它不能“强迫”构象跨越巨大的动力学能垒进行重排。模拟通过可用移动定义的路径来探索构象空间。如果移动没有导向正确的折叠，仅靠打分函数是无法弥补的。低分辨率搜索将为全原子阶段产生糟糕的起始模型，而全原子精修使用局部扰动，无法将整个蛋白质的拓扑结构从全-$\\alpha$转换为全-$\\beta$。声称能“高效地”找到正确折叠且具有“相似的收敛性”是错误的。\n**结论：错误。**\n\n**C. 因为片段很短（$3$-mers和$9$-mers），其二级结构内容是无关紧要的；只要有足够的蒙特卡洛步数，采样实际上仍然是无偏的，并且能够以不受影响的效率达到正确的$\\beta$拓扑结构。**\n这一陈述有根本性的缺陷。编码在片段中的局部二级结构信息正是使用它们的原因。它极大地加速了对类天然局部构象的搜索。声称其内容“无关紧要”与基于片段组装的整个原则背道而驰。虽然理论上无限长的MC运行可以采样到任何状态，但在实践中，强烈的偏向使得在任何可行的模拟时间内采样到正确折叠的概率小到可以忽略不计。采样并非“实际上无偏”；它是严重偏向的，效率将急剧下降到完全失败的程度。\n**结论：错误。**\n\n**D. 由于$\\alpha$和$\\beta$区域的$\\phi$和$\\psi$二面角限制不同，移动集变得无效，导致频繁的违规并被确定性地拒绝；因此，马尔可夫链无法继续进行，模拟会提前终止。**\n这种说法误解了Rosetta算法。二面角没有硬性的“无效”限制会导致确定性的拒绝和模拟终止。一个导致不利二面角（例如，在拉曼钱德兰图的禁区内）的提议移动，会从相应的打分项（例如`rama`）中获得高能量惩罚。这使得该移动在Metropolis准则下被接受的可能性极低，但这是一个概率性的，而非确定性的过程。马尔可夫链会继续进行，但它被困在了构象空间的一个非生产性区域。模拟不会终止。\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2381444"}, {"introduction": "在我们了解了采样偏差的强大影响后，一个自然的问题是：我们能否在没有片段库这类强先验知识的情况下，有效地搜索复杂的连续能量景观？元启发式算法（Metaheuristic algorithms）为此提供了强有力的解决方案。这项高级实践将指导你实现一种受自然启发的算法——蚁群优化（Ant Colony Optimization, ACO），用于寻找蛋白质的低能构象。通过为更真实的离散模型（具有连续的二面角自由度）设计和实施这一搜索策略，你将学习如何利用算法的“记忆”（信息素）和“启发式信息”来智能地引导搜索过程，从而在巨大且崎岖的能量地貌中逐步逼近全局最优解。[@problem_id:2369960]", "problem": "给定一个三维空间中多肽骨架的粗粒化内坐标模型。考虑一个由 $N$ 个α-碳原子组成的链，这些原子通过固定的键长 $b$ 和固定的键角 $\\theta$ 连接。其内部自由度是骨架的二面角 $\\{\\phi_i\\}$，其中 $i \\in \\{3,4,\\dots,N-1\\}$，即第三个原子之后每新增一个原子就对应一个二面角。该链的构建方式如下。将前三个原子置于\n$p_0 = (0,0,0)$，$p_1 = (b,0,0)$，$p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$。对于 $i \\ge 3$，给定 $p_{i-3}, p_{i-2}, p_{i-1}$ 和一个二面角 $\\phi_i \\in [-\\pi,\\pi)$，定义单位向量 $u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}$ 和 $v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$，法向量 $n = \\frac{v \\times u}{\\|v \\times u\\|}$，以及 $m = u \\times n$。然后将 $p_i$ 置于\n$$\np_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right).\n$$\n\n定义由二面角 $\\Phi = (\\phi_3,\\dots,\\phi_{N-1})$ 指定的构象的总能量（以约化单位表示）为\n$$\nE(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi),\n$$\n其中扭转项为\n$$\nE_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right),\n$$\n非键合项是位于非相邻原子之间的Lennard-Jones势\n$$\nE_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right],\n$$\n其中 $r_{ij} = \\|p_i - p_j\\|$。长度单位使用埃（Å），角度单位使用弧度，能量单位使用与 $\\varepsilon$ 相同的约化单位。\n\n考虑一个基于离散记忆的关于二面角的概率性构建过程。对于每个二面角索引 $k \\in \\{3,4,\\dots,N-1\\}$，将定义域 $[-\\pi,\\pi)$ 离散化为 $B$ 个等宽的区间，其中心为 $\\{\\varphi_{k,b}\\}_{b=1}^B$。维护一个非负记忆矩阵（“信息素”记忆）$T \\in \\mathbb{R}_{\\ge 0}^{(N-3)\\times B}$，其条目为 $T_{k,b}$，并统一初始化为 $T_{k,b} = \\tau_0$。通过以下公式为每个区间定义一个启发式权重：\n$$\n\\eta_{k,b} = \\exp\\left(-\\frac{k_t\\left(1 + \\cos(3\\varphi_{k,b})\\right)}{T_h}\\right),\n$$\n其中温度 $T_h > 0$。对于参数 $\\alpha > 0$ 和 $\\beta \\ge 0$，将在二面角索引 $k$ 处选择区间 $b$ 的概率定义为\n$$\n\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k,b}^{\\alpha}\\,\\eta_{k,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k,b'}^{\\alpha}\\,\\eta_{k,b'}^{\\beta}}.\n$$\n一次迭代包括通过对每个二面角索引 $k$ 的乘积分布进行独立抽样，为每个二面角选择一个区间，从而生成 $M$ 个完整的角度序列 $\\Phi$；然后为每个序列计算 $E(\\Phi)$，选出该次迭代中能量最低的单个样本，其能量为 $E^\\star$；接着以蒸发率 $\\rho \\in (0,1)$ 和在选定的区间 $\\{b_k^\\star\\}$ 处的秩为1的沉积来更新记忆：\n$$\nT_{k,b} \\leftarrow (1-\\rho) T_{k,b} \\quad \\text{for all } k,b,\n$$\n$$\nT_{k,b_k^\\star} \\leftarrow T_{k,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right) \\quad \\text{for all } k,\n$$\n之后，使用 $\\tau_{\\min} > 0$ 和 $\\tau_{\\max} > \\tau_{\\min}$ 将 $T_{k,b}$ 钳位在 $T_{k,b} \\leftarrow \\min\\{\\tau_{\\max}, \\max\\{\\tau_{\\min}, T_{k,b}\\}\\}$。重复 $I$ 次迭代，并返回在所有样本和所有迭代中遇到的最低能量。\n\n所有运行均使用以下固定的物理和能量常数：\n- 键长 $b = 3.8$ Å。\n- 键角 $\\theta = 111.5^\\circ$（在计算中使用弧度；$\\theta \\approx 1.946$）。\n- Lennard–Jones参数 $\\varepsilon = 0.1$ 和 $\\sigma = 4.0$（单位为Å）。\n- 扭转刚度 $k_t = 0.1$。\n- 启发式温度 $T_h = 1.0$。\n- 沉积强度 $Q = 1.0$ 和沉积温度 $T_d = 1.0$。\n- 信息素初始化 $\\tau_0 = 1.0$，下限 $\\tau_{\\min} = 10^{-6}$，上限 $\\tau_{\\max} = 100.0$。\n\n你的任务是实现上述过程，并在以下测试集上执行它。对于每个测试案例，使用一个以给定种子初始化的独立伪随机数生成器，并报告找到的最佳（最低）能量 $E$。将每个答案表示为四舍五入到三位小数的浮点数。\n\n测试集（角度单位为弧度，长度单位为Å，能量单位使用与 $\\varepsilon$ 相同的单位）：\n- 案例 A（通用）：$N = 8$, $M = 25$, $I = 40$, $B = 36$, $\\alpha = 1.0$, $\\beta = 2.0$, $\\rho = 0.1$, 随机种子 $s = 1234$。\n- 案例 B（边界长度）：$N = 4$, $M = 16$, $I = 25$, $B = 24$, $\\alpha = 1.0$, $\\beta = 1.0$, $\\rho = 0.3$, 随机种子 $s = 202$。\n- 案例 C（不同平衡）：$N = 10$, $M = 20$, $I = 30$, $B = 24$, $\\alpha = 1.5$, $\\beta = 1.0$, $\\rho = 0.2$, 随机种子 $s = 999$。\n\n最终输出格式：你的程序应生成一行输出，其中包含案例 A、B 和 C 的结果，形式为方括号内以逗号分隔的列表，例如，\"[x_A,x_B,x_C]\"。每个 $x$ 必须是如上指定的四舍五入后的浮点值，不含任何附加文本。", "solution": "问题陈述已经过验证，被认定为有效。这是一个计算结构生物学领域中定义明确的问题，具体是使用粗粒化模型进行*从头*蛋白质结构预测。所有物理参数、数学公式和算法定义均已提供，它们在科学上是合理的，并且内部一致。该问题是一个标准的能量最小化任务，所指定的元启发式算法，即蚁群优化（ACO）的一种变体，是一种合适的方法。不需要 `scipy` 库，因为`numpy` 提供了所有必要的功能。\n\n该解决方案通过遵循指定步骤来实现。问题的核心是找到最小化总能量函数 $E(\\Phi)$ 的二面角集合 $\\Phi = (\\phi_3, \\dots, \\phi_{N-1})$。\n\n**1. 链几何构建**\n\n$N$ 个原子的三维坐标，表示为 $\\{p_i\\}_{i=0}^{N-1}$，是顺序生成的。前三个原子 $p_0$, $p_1$ 和 $p_2$ 在 $xy$ 平面上建立一个初始参考系：\n$$p_0 = (0,0,0)$$\n$$p_1 = (b,0,0)$$\n$$p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$$\n这里，$b$ 是固定的键长，$\\theta$ 是固定的键角。对于随后的每个原子 $p_i$ ($i \\ge 3$)，其位置由前三个原子（$p_{i-3}, p_{i-2}, p_{i-1}$）的位置和一个单一的内部自由度，即二面角 $\\phi_i$ 决定。\n\n$p_i$ 的构建基于定义一个局部坐标系。令 $u$ 为沿键 $p_{i-2} \\to p_{i-1}$ 的单位向量，令 $v$ 为沿键 $p_{i-3} \\to p_{i-2}$ 的单位向量。\n$$u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}, \\quad v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$$\n包含这两个键的平面的法向量 $n$ 由它们的叉积给出，$n = \\text{normalize}(v \\times u)$。第三个向量 $m = u \\times n$ 构成一个右手正交基 $\\{u, m, n\\}$。然后，新原子 $p_i$ 的位置相对于 $p_{i-1}$ 放置，使得新键向量 $p_i - p_{i-1}$ 的长度为 $b$，与向量 $p_{i-1}-p_{i-2}$ 成 $\\pi-\\theta$ 角（从而保持键角 $\\theta$），其在垂直于 $u$ 的平面上的投影由二面角 $\\phi_i$ 旋转。这由给定的公式捕获：\n$$p_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right)$$\n这种几何构建是分子建模中的一种标准方法，通常被称为自然延伸参考系（NeRF）或类似的内坐标构建算法。\n\n**2. 能量函数**\n\n由二面角集合 $\\Phi$ 指定的给定构象的势能是两项之和：一个扭转项和一个非键合相互作用项。\n$$E(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi)$$\n扭转能 $E_{\\text{tors}}$ 考虑了绕骨架键旋转的能量壁垒：\n$$E_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right)$$\n项 $k_t$ 表示扭转弹簧的刚度。$3\\phi_i$ 的依赖性模拟了类烷烃链中常见的三重旋转对称性。\n\n非键合能 $E_{\\text{nb}}$ 模拟了在链中不相邻的原子之间的范德华相互作用。它使用Lennard-Jones 12-6势计算：\n$$E_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right]$$\n这里，$r_{ij}$ 是原子 $p_i$ 和 $p_j$ 之间的欧几里得距离。参数 $\\varepsilon$ 和 $\\sigma$ 分别定义了势阱的深度和位置。条件 $j-i > 2$ 正确地排除了键合邻居（1,2对，如 $i, i+1$）和键角邻居（1,3对，如 $i, i+2$），这些相互作用已通过固定的键长和键角约束隐式处理。\n\n**3. 蚁群优化（ACO）算法**\n\n能量景观的高维和非凸性质使得寻找全局最小值成为一项不平凡的任务。该问题指定了一种基于ACO元启发式算法的随机优化算法。\n\n首先，每个二面角的连续域 $[-\\pi, \\pi)$ 被离散化为 $B$ 个区间。寻找最优构象的任务因此转变为寻找最佳的区间序列。\n\n该算法进行 $I$ 次迭代。在每次迭代中，构建 $M$ 个候选解（蚂蚁）。每只蚂蚁通过对每个二面角 $\\phi_k$（$k=3, \\dots, N-1$）进行概率性选择，来构建一个完整的二面角序列 $\\Phi$。为二面角 $k$ 选择区间 $b$ 的概率是两个组成部分的函数：\n- **信息素轨迹 ($\\tau$)**：一个记忆矩阵 $T$ 存储了基于过去成功解决方案的为每个二面角选择每个区间的“期望性”。条目 $T_{k,b}$ 对应于二面角 $k$ 的区间 $b$ 的信息素水平。\n- **启发式信息 ($\\eta$)**：此项提供关于选择质量的*先验*知识，与搜索历史无关。在这里，它基于二面角的局部扭转能：$\\eta_{k,b} = \\exp\\left(-\\frac{E_{\\text{tors}}(\\varphi_{k,b})}{T_h}\\right)$。能量较低的选择具有较高的启发式值。\n\n为第 $k$ 个二面角（对应矩阵行 $k-3$）选择区间 $b$ 的概率由下式给出：\n$$\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k-3,b}^{\\alpha}\\,\\eta_{k-3,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k-3,b'}^{\\alpha}\\,\\eta_{k-3,b'}^{\\beta}}$$\n参数 $\\alpha$ 和 $\\beta$ 控制信息素轨迹与启发式信息的相对影响。\n\n在构建了 $M$ 个解决方案并评估了它们的能量后，使用该迭代中能量为 $E^\\star$ 的单个最佳解决方案来更新信息素矩阵。更新有两个阶段：\n1. **蒸发**：所有信息素轨迹都均匀地乘以一个因子 $(1-\\rho)$，其中 $\\rho \\in (0,1)$ 是蒸发率。这可以防止过早收敛。\n$$T_{k,b} \\leftarrow (1-\\rho) T_{k,b}$$\n2. **沉积**：对应于迭代中最佳解决方案 $\\{b_k^\\star\\}$ 中所做选择的轨迹得到加强。沉积的信息素量与能量 $E^\\star$ 成反比。\n$$T_{k-3,b_k^\\star} \\leftarrow T_{k-3,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right)$$\n最后，信息素值被钳位在 $\\tau_{\\min}$ 和 $\\tau_{\\max}$ 之间以确保稳定性。在连续的迭代中，这整个过程引导搜索朝向构象空间中有希望的区域。在所有蚂蚁和所有迭代中找到的最低能量将作为最终结果报告。\n\n**4. 实现策略**\n\n所描述的算法使用`numpy`库在Python中实现，以进行高效的数值和向量运算。一个主函数为给定的参数集 $(N, M, I, B, \\alpha, \\beta, \\rho, s)$ 协调整个模拟过程。\n- 一个辅助函数 `build_chain` 接受一个二面角序列，并根据几何构建规则生成原子坐标 $\\{p_i\\}$。\n- 第二个辅助函数 `calculate_energy` 接受原子坐标和二面角来计算总能量 $E(\\Phi)$。`numpy`的向量化操作用于加速求和和势能计算。\n- 主ACO循环管理状态，包括信息素矩阵 $T$ 和全局找到的最佳能量。它使用一个`numpy.random.Generator`实例，用种子进行初始化以保证可复现性，来执行二面角区间的概率性采样。\n代码的结构是首先定义所有常量，然后是辅助函数，最后是主模拟驱动程序，该驱动程序会根据指定为每个测试案例调用。", "answer": "```python\nimport numpy as np\n\n# Fixed physical and energetic constants\nBOND_LENGTH = 3.8  # b in Å\nBOND_ANGLE_DEG = 111.5\nBOND_ANGLE_RAD = np.deg2rad(BOND_ANGLE_DEG)  # theta in radians\nEPSILON = 0.1      # ε\nSIGMA = 4.0        # σ in Å\nKT = 0.1           # k_t\nT_H = 1.0          # T_h (Heuristic temperature)\nQ = 1.0            # Deposition strength\nT_D = 1.0          # Deposition temperature\nTAU_0 = 1.0        # Pheromone initialization\nTAU_MIN = 1e-6     # Pheromone floor\nTAU_MAX = 100.0    # Pheromone cap\n\ndef build_chain(dihedrals, N, b, theta):\n    \"\"\"Constructs the atomic coordinates for a given chain length and dihedrals.\"\"\"\n    if N == 0:\n        return np.array([])\n    \n    positions = np.zeros((N, 3))\n    if N > 1:\n        positions[1] = np.array([b, 0.0, 0.0])\n    if N > 2:\n        positions[2] = np.array([\n            b + b * np.cos(theta),\n            b * np.sin(theta),\n            0.0\n        ])\n\n    for i in range(3, N):\n        p_im1, p_im2, p_im3 = positions[i-1], positions[i-2], positions[i-3]\n        \n        # Define local frame vectors\n        u_vec = p_im1 - p_im2\n        u = u_vec / np.linalg.norm(u_vec)\n        \n        v_vec = p_im2 - p_im3\n        v = v_vec / np.linalg.norm(v_vec)\n        \n        cross_vu = np.cross(v, u)\n        n = cross_vu / np.linalg.norm(cross_vu)\n        \n        m = np.cross(u, n)\n        \n        phi_i = dihedrals[i - 3]\n        cos_phi = np.cos(phi_i)\n        sin_phi = np.sin(phi_i)\n\n        # Construct new atom position using the provided formula\n        new_bond_vector = -np.cos(theta) * u + np.sin(theta) * (cos_phi * m + sin_phi * n)\n        positions[i] = p_im1 + b * new_bond_vector\n        \n    return positions\n\ndef calculate_energy(positions, dihedrals, N, kt, eps, sigma):\n    \"\"\"Calculates the total energy of a conformation.\"\"\"\n    \n    # 1. Torsional energy\n    if dihedrals:\n        cos3_phi = np.cos(3 * np.array(dihedrals))\n        e_tors = kt * np.sum(1 + cos3_phi)\n    else:\n        e_tors = 0.0\n\n    # 2. Non-bonded Lennard-Jones energy\n    e_nb = 0.0\n    for i in range(N):\n        for j in range(i + 3, N):  # Condition j - i > 2\n            dist_sq = np.sum((positions[i] - positions[j])**2)\n            dist = np.sqrt(dist_sq)\n            \n            if dist > 0:\n                sigma_over_r = sigma / dist\n                sigma_over_r6 = sigma_over_r**6\n                sigma_over_r12 = sigma_over_r6**2\n                e_nb += 4 * eps * (sigma_over_r12 - sigma_over_r6)\n    \n    return e_tors + e_nb\n\ndef run_simulation(N, M, I, B, alpha, beta, rho, seed):\n    \"\"\"Runs the full ACO simulation for one test case.\"\"\"\n    \n    rng = np.random.default_rng(seed)\n    num_dihedrals = N - 3\n\n    if num_dihedrals <= 0:\n        # Fixed geometry, only possible LJ energy. \n        # For N<=3, no pair satisfies j-i>2, so energy is 0.\n        return 0.0\n    \n    # Discretize dihedral space\n    bin_width = 2 * np.pi / B\n    dihedral_bins = np.linspace(-np.pi + bin_width / 2, np.pi - bin_width / 2, B)\n\n    # Initialize pheromone matrix T\n    pheromone = np.full((num_dihedrals, B), TAU_0)\n    \n    # Pre-calculate heuristic matrix eta\n    torsional_heuristic_term = KT * (1 + np.cos(3 * dihedral_bins))\n    heuristic = np.exp(-torsional_heuristic_term / T_H)\n    \n    best_energy_global = float('inf')\n\n    for iteration in range(I):\n        iteration_samples = []\n        \n        # M ants construct solutions\n        for _ in range(M):\n            chosen_dihedrals = []\n            chosen_bin_indices = []\n            \n            for k in range(num_dihedrals):\n                probs = (pheromone[k] ** alpha) * (heuristic ** beta)\n                if np.sum(probs) > 0:\n                    probs /= np.sum(probs)\n                else: # Fallback to uniform if all probabilities are zero\n                    probs = np.ones(B) / B\n\n                chosen_bin_idx = rng.choice(B, p=probs)\n                chosen_bin_indices.append(chosen_bin_idx)\n                chosen_dihedrals.append(dihedral_bins[chosen_bin_idx])\n\n            # Evaluate the constructed conformation\n            positions = build_chain(chosen_dihedrals, N, BOND_LENGTH, BOND_ANGLE_RAD)\n            energy = calculate_energy(positions, chosen_dihedrals, N, KT, EPSILON, SIGMA)\n            \n            iteration_samples.append({'dihedrals': chosen_dihedrals, 'bins': chosen_bin_indices, 'energy': energy})\n\n        # Find best ant of the iteration\n        best_sample = min(iteration_samples, key=lambda x: x['energy'])\n        e_star = best_sample['energy']\n        \n        # Update global best energy\n        if e_star < best_energy_global:\n            best_energy_global = e_star\n\n        # Update pheromone trails\n        # 1. Evaporation\n        pheromone *= (1 - rho)\n\n        # 2. Deposition\n        deposition_amount = Q * np.exp(-e_star / T_D)\n        best_bins = best_sample['bins']\n        for k in range(num_dihedrals):\n            pheromone[k, best_bins[k]] += deposition_amount\n\n        # 3. Clamping\n        np.clip(pheromone, TAU_MIN, TAU_MAX, out=pheromone)\n\n    return best_energy_global\n\ndef solve():\n    \"\"\"Main solver function to run test cases.\"\"\"\n    \n    test_cases = [\n        # Case A: (N, M, I, B, alpha, beta, rho, seed)\n        (8, 25, 40, 36, 1.0, 2.0, 0.1, 1234),\n        # Case B\n        (4, 16, 25, 24, 1.0, 1.0, 0.3, 202),\n        # Case C\n        (10, 20, 30, 24, 1.5, 1.0, 0.2, 999),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, I, B, alpha, beta, rho, seed = case\n        best_energy = run_simulation(N, M, I, B, alpha, beta, rho, seed)\n        results.append(f\"{best_energy:.3f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2369960"}]}