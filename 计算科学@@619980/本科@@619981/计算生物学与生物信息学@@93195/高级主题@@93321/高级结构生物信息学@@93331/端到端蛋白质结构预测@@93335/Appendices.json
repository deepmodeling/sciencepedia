{"hands_on_practices": [{"introduction": "探索端到端模型的行为，一个有效方法是使用非标准输入来“探测”其预测逻辑。这个关于嵌合蛋白的思维实验，旨在检验您对多重序列比对（MSA）驱动的模型如何从进化信息中推断结构约束的直观理解。通过思考模型将如何处理一个由两个不相关蛋白片段拼接而成的序列，您可以更深入地理解这些复杂系统预测能力的来源和局限性 [@problem_id:2387803]。", "problem": "一个集成了多序列比对(MSA)和模板搜索的端到端蛋白质结构预测器，会生成一个三维原子模型以及置信度诊断信息，包括逐残基置信度分数（例如，预测的局部距离差异检验(pLDDT)）和一个预测对齐误差(PAE)矩阵。考虑以下输入：一个单链嵌合氨基酸序列 $S$，它是由一个可溶性蛋白 $X$ 的 N 端 $L_X/2$ 个残基与一个不相关的可溶性蛋白 $Y$ 的 C 端 $L_Y/2$ 个残基直接连接构成，中间没有任何设计的连接子。假设每个片段（即，许多与 $X$ 的 N 端一半相似的序列，以及许多与 $Y$ 的 C 端一半相似的序列）都分别存在天然的同源序列，但是没有天然序列在单链中同时包含这两个片段。这两个来源蛋白 $X$ 和 $Y$ 在进化上不相关，并且在自然界中不发生相互作用。\n\n当 $S$ 被提交给这样的端到端预测器时，最可能出现哪种结果？\n\nA. 模型生成一个单一的、紧凑的新型折叠，其中来自两半的残基紧密混合；报告整个链上一致的高逐残基置信度和一致低的PAE，因为端到端架构强制执行全局一致性。\n\nB. 模型产生两个分别对应于每一半的类结构域单元，具有高的逐残基置信度和低的域内PAE，但域间PAE高且相对取向任意；连接处的残基可能具有与柔性连接子一致的低置信度。\n\nC. 模型拒绝给出任何预测，因为没有MSA能跨越整个嵌合体长度，并且模板搜索也未返回任何全长匹配项。\n\nD. 模型自动将 $S$ 分割成两条独立的多肽链并输出两个独立的结构，忽略了连接处的共价连续性。\n\nE. 模型预测两半都完全无序，整个序列的逐残基置信度都很低，因为该嵌合序列没有天然的进化历史。", "solution": "首先必须确定问题陈述的有效性。\n\n**步骤 1：提取已知条件**\n-   输入序列：一个单链嵌合氨基酸序列 $S$。\n-   序列组成：$S$ 是由一个可溶性蛋白 $X$ 的 N 端 $L_X/2$ 个残基与一个不相关的可溶性蛋白 $Y$ 的 C 端 $L_Y/2$ 个残基连接而成。\n-   连接方式：片段直接相连，无设计好的连接子。\n-   进化信息：每个片段（$X$ 的一半和 $Y$ 的一半）分别存在同源序列。没有天然序列在单链中同时包含这两个片段。\n-   来源蛋白：$X$ 和 $Y$ 在进化上不相关，且在自然界中不发生相互作用。\n-   预测器模型：一个使用多序列比对(MSA)和模板搜索的端到端蛋白质结构预测器。\n-   预测器输出：一个三维原子模型，一个逐残基置信度分数（例如pLDDT），以及一个预测对齐误差(PAE)矩阵。\n-   问题：将 $S$ 提交给这个预测器最可能的结果是什么？\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题陈述具有科学依据、提法明确且客观。\n-   **科学依据**：该场景描述了蛋白质生物信息学中的一个标准计算实验。所提及的工具和概念——端到端预测器（如AlphaFold2或RoseTTAFold）、MSA、模板搜索、pLDDT和PAE——都是蛋白质结构预测领域中已确立的核心概念。构建嵌合蛋白是一种常见的做法。\n-   **提法明确**：问题定义清晰，有特定的输入（$S$）和特定的计算系统（预测器）。它要求的是“最可能的结果”，这个结果基于这些深度学习模型的已知架构和功能，有一个确定性的答案。\n-   **客观性**：所用术语在该领域内是精确和标准的。没有歧义或主观框架。\n\n该问题是有效的，因为它不符合任何无效标准。这是一个关于一类已知计算算法行为的，表述良好的问题。\n\n**步骤 3：推导解答**\n问题的核心在于理解最先进的结构预测器如何处理一个人造的嵌合序列。这些预测器在很大程度上依赖于从MSA中提取的共进化信息。\n\n1.  **MSA构建**：对于嵌合序列 $S$，MSA搜索工具会找到大量与前半部分（$X$ 片段）比对良好的同源序列，以及另外大量与后半部分（$Y$ 片段）比对良好的序列。然而，如题所述，没有天然序列能够跨越 $S$ 的全长进行比对。最终得到的MSA本质上将是“块对角”的：\n    -   N端一半的密集比对块。\n    -   C端一半的密集比对块。\n    -   连接两个块的信息非常稀疏或根本没有。\n    这意味着模型可以*在* $X$ 片段内部和*在* $Y$ 片段内部提取到强的共进化信号（指示残基-残基接触），但无法在它们*之间*提取到这种信号。\n\n2.  **信息处理和结构预测**：预测器的神经网络（通常是基于注意力机制的架构）会处理这个MSA。\n    -   **域内结构**：强的域内共进化信号为模型提供了足够的信息，使其能够将嵌合体的每一半精确地折叠成其类似天然的构象。因此，我们预期会形成两个与 $X$ 和 $Y$ 片段相对应的、结构明确的结构域。\n    -   **域间排布**：由于两个片段之间缺乏共进化信号，模型没有信息来约束它们的相对取向。蛋白质 $X$ 和 $Y$ 不相关且不相互作用，因此不存在进化压力来形成任何特定的界面。模型没有被训练在缺乏证据的情况下创造新的相互作用。因此，这两个域的相对位置和取向将是任意且不确定的。\n\n3.  **置信度指标**：模型会报告其自身的置信度，这反映了它所能获得的信息。\n    -   **pLDDT (逐残基置信度)**：该分数衡量对局部原子环境的置信度。对于深埋在每个折叠域内部的残基，由于MSA提供了丰富的信息，pLDDT会很高（通常 $> 90$）。在人为的连接处，序列上下文被打破，局部环境是非天然的。模型可能会对这少数几个残基报告较低的置信度（例如，pLDDT $< 70$），这与一个柔性或无序的区域相符。\n    -   **PAE (预测对齐误差)**：该矩阵对于理解结构域关系至关重要。对于长度为 $L = L_X/2 + L_Y/2$ 的序列 $S$，其PAE图谱将显示：\n        -   **低PAE**（深色块）：对于残基对 $(i, j)$，如果 $i$和 $j$ 都位于第一个结构域内 ($1 \\le i, j \\le L_X/2$)，或者都位于第二个结构域内 ($L_X/2 < i, j \\le L$)，则PAE值低。这表明对每个结构域的内部结构有高置信度。\n        -   **高PAE**（浅色块）：对于残基对 $(i, j)$，如果 $i$ 位于第一个结构域内 ($1 \\le i \\le L_X/2$) 而 $j$ 位于第二个结构域内 ($L_X/2 < j \\le L$)，则PAE值高。这表明对两个结构域的相对位置关系置信度低。\n\n这一详细分析预测了模型会形成两个独立的、折叠良好的结构域，它们的相对取向不确定，并且这一点会被模型的置信度指标准确地报告出来。\n\n**步骤 4：逐项分析选项**\n\nA. 模型生成一个单一的、紧凑的新型折叠，其中来自两半的残基紧密混合；报告整个链上一致的高逐残基置信度和一致低的PAE，因为端到端架构强制执行全局一致性。\n**不正确**。模型不会在没有来自MSA或模板的证据的情况下凭空创造相互作用。PAE不会一致地低；在对应于域间位置的非对角块中，PAE会很高，反映了缺乏关于它们相对位置的信息。\n\nB. 模型产生两个分别对应于每一半的类结构域单元，具有高的逐残基置信度和低的域内PAE，但域间PAE高且相对取向任意；连接处的残基可能具有与柔性连接子一致的低置信度。\n**正确**。该选项准确地描述了上面推导出的预期结果。它正确地预测了两个结构域的形成、pLDDT高低置信度的模式，以及PAE矩阵的块状结构，这反映了域内折叠的高置信度和域间排布的不确定性。\n\nC. 模型拒绝给出任何预测，因为没有MSA能跨越整个嵌合体长度，并且模板搜索也未返回任何全长匹配项。\n**不正确**。现代预测器是稳健的，被设计用来处理不完整的信息。序列部分区域存在强信号足以让模型继续运行并生成结构，并通过置信度分数来表达其不确定性，而不是完全失败。\n\nD. 模型自动将 $S$ 分割成两条独立的多肽链并输出两个独立的结构，忽略了连接处的共价连续性。\n**不正确**。输入是一个单一的连续序列，模型会尊重这种共价拓扑结构。它将生成一个单一的多肽链结构。结构域之间缺乏约束是它们预测的空间关系的一个属性，而不是一级序列的断裂。\n\nE. 模型预测两半都完全无序，整个序列的逐残基置信度都很低，因为该嵌合序列没有天然的进化历史。\n**不正确**。虽然整个嵌合体是人造的，但其组成部分有明确的进化历史，并且作为可溶性蛋白的一部分，很可能是结构化的。预测器将利用每个部分可用的强大MSA信息来预测它们为折叠的结构域。因此，大多数残基的置信度会很高，而不是整体都很低。", "answer": "$$\\boxed{B}$$", "id": "2387803"}, {"introduction": "在建立了概念性理解后，精确的量化评估变得至关重要。本实践练习侧重于评估许多现代模型直接输出的关键数据——主链扭转角。您将学习如何计算环形平均绝对误差（circular mean absolute error, cMAE），这是一种专为周期性数据（如角度）设计的评估指标，并处理蛋白质序列中可能出现的模糊氨基酸代码，从而掌握评估模型预测精度的实用技能 [@problem_id:2387766]。", "problem": "给你一个用于端到端蛋白质结构预测设置的正式评估任务，该设置输出以弧度为单位的每个残基的骨架扭转角。考虑由标准$20$种典型氨基酸以及模糊码 $B$、$Z$ 和 $X$ 组成的序列，其中 $B$ 表示 $D$ 或 $N$，$Z$ 表示 $E$ 或 $Q$，$X$ 表示任意典型氨基酸。对于每个测试用例，你将获得一个可能包含模糊码的输入序列、一个与之对应的仅包含典型氨基酸且与模糊码一致的已解析真实序列、一个预测扭转角向量（以弧度为单位）以及一个真实扭转角向量（以弧度为单位）。\n\n对于长度为 $L$ 的序列，将预测角 $p_i$ 和真实角 $g_i$ 之间的循环绝对偏差定义为\n$$\nd_i \\;=\\; \\min_{k \\in \\mathbb{Z}} \\left| p_i - g_i + 2k\\pi \\right| \\;,\n$$\n这是单位圆上的测地距离，其值总是在 $[0,\\pi]$ 区间内。设 $U$ 为输入序列中具有明确典型氨基酸的位置索引集合，设 $A$ 为输入序列中具有模糊码 $\\{B,Z,X\\}$ 的位置索引集合。定义以下三个评估量：\n- 所有位置上的总体循环平均绝对误差 (cMAE)：\n$$\n\\mathrm{MAE}_{\\mathrm{all}} \\;=\\; \\frac{1}{L} \\sum_{i=1}^{L} d_i \\;.\n$$\n- 仅限明确氨基酸的 cMAE：\n$$\n\\mathrm{MAE}_{\\mathrm{unamb}} \\;=\\; \\frac{1}{|U|} \\sum_{i \\in U} d_i \\;,\n$$\n约定如果 $|U| = 0$，则 $\\mathrm{MAE}_{\\mathrm{unamb}} = +\\infty$。\n- 仅限模糊氨基酸的 cMAE：\n$$\n\\mathrm{MAE}_{\\mathrm{amb}} \\;=\\; \\frac{1}{|A|} \\sum_{i \\in A} d_i \\;,\n$$\n约定如果 $|A| = 0$，则 $\\mathrm{MAE}_{\\mathrm{amb}} = +\\infty$。\n\n所有角度必须以弧度处理。最终数值结果必须四舍五入到恰好 $6$ 位小数。如果所需的平均值没有元素，则输出正无穷大，文本表示为 $inf$。\n\n测试套件（每个用例指定：带模糊码的输入序列、已解析的真实序列、预测角 $p_i$（弧度）和真实角 $g_i$（弧度））：\n- 用例 $1$：\n  - 输入序列：$A\\,C\\,B\\,X\\,Z$\n  - 已解析的真实序列：$A\\,C\\,N\\,L\\,Q$（与 $B \\rightarrow N$、$X \\rightarrow L$、$Z \\rightarrow Q$ 一致）\n  - 预测角：$[\\,0.6,\\,-2.5,\\,-3.0,\\,3.10,\\,-1.7\\,]$\n  - 真实角：$[\\,0.5,\\,-1.0,\\,2.9,\\,-3.10,\\,1.2\\,]$\n- 用例 $2$：\n  - 输入序列：$A\\,C\\,D\\,E$\n  - 已解析的真实序列：$A\\,C\\,D\\,E$\n  - 预测角：$[\\, -\\pi + 0.01,\\; \\pi - 0.01,\\; \\pi,\\; -2.141592653589793 \\,]$\n  - 真实角：$[\\, \\pi - 0.01,\\; -\\pi + 0.01,\\; 0.0,\\; 1.0 \\,]$\n- 用例 $3$：\n  - 输入序列：$B\\,X\\,Z\\,B$\n  - 已解析的真实序列：$D\\,A\\,Q\\,N$（与 $B \\rightarrow D,N$、$X \\rightarrow A$、$Z \\rightarrow Q$ 一致）\n  - 预测角：$[\\,0.1,\\,-3.0,\\,3.0,\\,-1.6\\,]$\n  - 真实角：$[\\,0.0,\\,2.5,\\,-2.8,\\,1.5\\,]$\n\n对于每个用例，你的程序必须计算如上定义的三元组 $[\\,\\mathrm{MAE}_{\\mathrm{all}},\\mathrm{MAE}_{\\mathrm{unamb}},\\mathrm{MAE}_{\\mathrm{amb}}\\,]$。最终输出必须是包含所有用例的这些三元组列表的单行文本，每个浮点值四舍五入到恰好 $6$ 位小数，正无穷大打印为 $inf$。例如，一个语法上有效的最终行看起来像：\n[ [a11,a12,a13], [a21,a22,a23], [a31,a32,a33] ],\n但除了列表分隔符自动产生的空格外，不应有其他空格，此问题要求的确切格式为：\n\"[[case1_triple],[case2_triple],[case3_triple]]\"。", "solution": "所提出的问题是计算生物模型评估领域中一个明确定义的任务，特别针对蛋白质结构预测。我将首先验证问题陈述，然后提供一个全面的解决方案。\n\n### 问题验证\n\n我对问题陈述进行了严格的分析。\n\n#### 步骤 1：提取已知条件\n\n- **领域**：端到端蛋白质结构预测。\n- **字母表**：$20$ 种典型氨基酸加上模糊码 $B \\in \\{D, N\\}$、$Z \\in \\{E, Q\\}$ 和 $X$（任意典型氨基酸）。\n- **每个测试用例的输入**：一个可能包含模糊码的输入序列（长度为 $L$）、一个已解析的真实序列、一个预测扭转角向量 $p_i$（弧度）和一个真实扭转角向量 $g_i$（弧度）。\n- **主要度量标准**：循环绝对偏差，$d_i = \\min_{k \\in \\mathbb{Z}} | p_i - g_i + 2k\\pi |$，其中 $d_i \\in [0, \\pi]$。\n- **索引集**：$U$ 代表输入序列中的明确位置，$A$ 代表输入序列中的模糊位置。\n- **评估量**：\n    1.  总体 cMAE：$\\mathrm{MAE}_{\\mathrm{all}} = \\frac{1}{L} \\sum_{i=1}^{L} d_i$。\n    2.  仅限明确氨基酸的 cMAE：$\\mathrm{MAE}_{\\mathrm{unamb}} = \\frac{1}{|U|} \\sum_{i \\in U} d_i$。如果 $|U|=0$，则 $\\mathrm{MAE}_{\\mathrm{unamb}} = +\\infty$。\n    3.  仅限模糊氨基酸的 cMAE：$\\mathrm{MAE}_{\\mathrm{amb}} = \\frac{1}{|A|} \\sum_{i \\in A} d_i$。如果 $|A|=0$，则 $\\mathrm{MAE}_{\\mathrm{amb}} = +\\infty$。\n- **输出格式**：对于每个用例，一个三元组 $[\\mathrm{MAE}_{\\mathrm{all}}, \\mathrm{MAE}_{\\mathrm{unamb}}, \\mathrm{MAE}_{\\mathrm{amb}}]$。浮点值必须四舍五入到 $6$ 位小数。正无穷大表示为 `inf`。最终输出是这些三元组的列表。\n- **给定的测试用例**：指定了三个不同的测试用例，包含所有必要的输入。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n根据所需标准对问题进行评估：\n- **科学依据**：该问题正属于生物信息学领域。使用扭转角表示蛋白质骨架以及使用循环统计（如循环平均绝对误差）进行评估是标准且公认的方法。\n- **适定性**：该问题以数学精度进行了规定。所有术语都有明确定义，包括度量标准的公式和边界情况（除以零）的处理。输入是完整的，可以为每个测试用例计算出唯一的解。\n- **客观性**：问题陈述没有主观语言、推测或含糊之处。它呈现的是一个纯粹形式化的、可计算的任务。\n\n该问题没有任何无效性缺陷。它在数学上是合理的、可形式化的、完整的和可验证的。\n\n#### 步骤 3：结论与行动\n\n该问题是**有效的**。将开发一个解决方案。\n\n### 解决方案推导\n\n问题的核心是基于循环绝对偏差 $d_i$ 计算三个平均绝对误差度量。\n\n#### 步骤 1：计算循环绝对偏差 ($d_i$)\n\n定义 $d_i = \\min_{k \\in \\mathbb{Z}} | p_i - g_i + 2k\\pi |$ 表示圆上两个角度之间的最短距离。设原始差值为 $\\Delta_i = p_i - g_i$。任务是找到与 $\\Delta_i$ 等效且位于区间 $[-\\pi, \\pi]$ 内的角度。设此归一化角度为 $\\Delta_i^{\\prime}$。那么循环距离就是 $d_i = |\\Delta_i^{\\prime}|$。\n\n一种计算 $\\Delta_i^{\\prime}$ 的数值稳健方法是先将角度平移 $\\pi$，计算其相对于 $2\\pi$ 的余数，然后再平移回来。这将角度映射到区间 $[-\\pi, \\pi)$。\n$$\n\\Delta_i^{\\prime} = ((\\Delta_i + \\pi) \\pmod{2\\pi}) - \\pi\n$$\n因此，循环偏差向量 $d$ 可以通过预测角和真实角向量 $p$ 和 $g$ 计算得出：\n$$\nd_i = |((p_i - g_i + \\pi) \\pmod{2\\pi}) - \\pi|\n$$\n为了效率，此操作可以向量化。\n\n#### 步骤 2：识别明确和模糊集合\n\n对于每个长度为 $L$ 的序列，我们识别属于集合 $U$（明确）和 $A$（模糊）的索引。模糊氨基酸码的集合已给出，为 $\\{B, Z, X\\}$。我们从 $i=1$ 迭代到 $L$。如果输入序列中位置 $i$ 的氨基酸是 $\\{B, Z, X\\}$ 中的一个，则 $i \\in A$。否则，$i \\in U$。\n\n#### 步骤 3：计算 cMAE 度量\n\n- **总体 cMAE ($\\mathrm{MAE}_{\\mathrm{all}}$)**：这是所有 $i=1, \\dots, L$ 的 $d_i$ 值的算术平均值。\n$$\n\\mathrm{MAE}_{\\mathrm{all}} = \\frac{1}{L} \\sum_{i=1}^{L} d_i\n$$\n\n- **仅限明确氨基酸的 cMAE ($\\mathrm{MAE}_{\\mathrm{unamb}}$)**：这是索引 $i \\in U$ 的 $d_i$ 的算术平均值。如果集合 $U$ 为空 ($|U|=0$)，则该值定义为正无穷大。\n$$\n\\mathrm{MAE}_{\\mathrm{unamb}} =\n\\begin{cases}\n    \\frac{1}{|U|} \\sum_{i \\in U} d_i & \\text{if } |U| > 0 \\\\\n    +\\infty & \\text{if } |U| = 0\n\\end{cases}\n$$\n\n- **仅限模糊氨基酸的 cMAE ($\\mathrm{MAE}_{\\mathrm{amb}}$)**：这是索引 $i \\in A$ 的 $d_i$ 的算术平均值。如果集合 $A$ 为空 ($|A|=0$)，则该值定义为正无穷大。\n$$\n\\mathrm{MAE}_{\\mathrm{amb}} =\n\\begin{cases}\n    \\frac{1}{|A|} \\sum_{i \\in A} d_i & \\text{if } |A| > 0 \\\\\n    +\\infty & \\text{if } |A| = 0\n\\end{cases}\n$$\n\n#### 步骤 4：对测试用例执行计算\n\n将该程序应用于每个测试用例。\n\n**用例 1：**\n- 输入序列：$A\\,C\\,B\\,X\\,Z$。长度 $L=5$。\n- 明确索引 $U=\\{1, 2\\}$， $|U|=2$。模糊索引 $A=\\{3, 4, 5\\}$， $|A|=3$。\n- $p = [0.6, -2.5, -3.0, 3.10, -1.7]$。\n- $g = [0.5, -1.0, 2.9, -3.10, 1.2]$。\n- $\\Delta = p - g = [0.1, -1.5, -5.9, 6.2, -2.9]$。\n- $d = [0.1, 1.5, 0.383185..., 0.083185..., 2.9]$。\n- $\\mathrm{MAE}_{\\mathrm{all}} = \\frac{1}{5}(0.1 + 1.5 + 0.383185 + 0.083185 + 2.9) = 0.993274$。\n- $\\mathrm{MAE}_{\\mathrm{unamb}} = \\frac{1}{2}(0.1 + 1.5) = 0.8$。\n- $\\mathrm{MAE}_{\\mathrm{amb}} = \\frac{1}{3}(0.383185 + 0.083185 + 2.9) \\approx 1.122124$。\n- 结果：$[0.993274, 0.800000, 1.122124]$。\n\n**用例 2：**\n- 输入序列：$A\\,C\\,D\\,E$。长度 $L=4$。\n- 明确索引 $U=\\{1, 2, 3, 4\\}$， $|U|=4$。模糊索引 $A=\\emptyset$， $|A|=0$。\n- $p = [-\\pi + 0.01, \\pi - 0.01, \\pi, -2.141592653589793]$。\n- $g = [\\pi - 0.01, -\\pi + 0.01, 0.0, 1.0]$。\n- $\\Delta = p - g = [-2\\pi+0.02, 2\\pi-0.02, \\pi, -3.14159265... \\approx -\\pi]$。\n- $d = [0.02, 0.02, \\pi, \\pi]$。\n- $\\mathrm{MAE}_{\\mathrm{all}} = \\frac{1}{4}(0.02 + 0.02 + \\pi + \\pi) = \\frac{0.04 + 2\\pi}{4} = 0.01 + \\frac{\\pi}{2} \\approx 1.580796$。\n- $\\mathrm{MAE}_{\\mathrm{unamb}} = \\mathrm{MAE}_{\\mathrm{all}} \\approx 1.580796$。\n- $\\mathrm{MAE}_{\\mathrm{amb}} = +\\infty$，因为 $|A|=0$。\n- 结果：$[1.580796, 1.580796, \\text{inf}]$。\n\n**用例 3：**\n- 输入序列：$B\\,X\\,Z\\,B$。长度 $L=4$。\n- 明确索引 $U=\\emptyset$, $|U|=0$。模糊索引 $A=\\{1, 2, 3, 4\\}$, $|A|=4$。\n- $p = [0.1, -3.0, 3.0, -1.6]$。\n- $g = [0.0, 2.5, -2.8, 1.5]$。\n- $\\Delta = p - g = [0.1, -5.5, 5.8, -3.1]$。\n- $d = [0.1, 0.783185..., 0.483185..., 3.1]$。\n- $\\mathrm{MAE}_{\\mathrm{all}} = \\frac{1}{4}(0.1 + 0.783185 + 0.483185 + 3.1) \\approx 1.116593$。\n- $\\mathrm{MAE}_{\\mathrm{unamb}} = +\\infty$，因为 $|U|=0$。\n- $\\mathrm{MAE}_{\\mathrm{amb}} = \\mathrm{MAE}_{\\mathrm{all}} \\approx 1.116593$。\n- 结果：$[1.116593, \\text{inf}, 1.116593]$。\n\n最终结果必须格式化为 $6$ 位小数，并以指定的列表的列表格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes circular mean absolute error (cMAE) metrics for protein \n    torsion angle predictions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"input_seq\": \"ACBXZ\",\n            \"pred_angles\": [0.6, -2.5, -3.0, 3.10, -1.7],\n            \"true_angles\": [0.5, -1.0, 2.9, -3.10, 1.2],\n        },\n        {\n            \"input_seq\": \"ACDE\",\n            \"pred_angles\": [-np.pi + 0.01, np.pi - 0.01, np.pi, -2.141592653589793],\n            \"true_angles\": [np.pi - 0.01, -np.pi + 0.01, 0.0, 1.0],\n        },\n        {\n            \"input_seq\": \"BXZB\",\n            \"pred_angles\": [0.1, -3.0, 3.0, -1.6],\n            \"true_angles\": [0.0, 2.5, -2.8, 1.5],\n        }\n    ]\n\n    results_list = []\n    ambiguous_codes = {'B', 'Z', 'X'}\n\n    for case in test_cases:\n        input_seq = case[\"input_seq\"]\n        p = np.array(case[\"pred_angles\"], dtype=np.float64)\n        g = np.array(case[\"true_angles\"], dtype=np.float64)\n\n        # Step 1: Compute circular absolute deviations (d_i)\n        # The difference p_i - g_i is mapped to [-pi, pi) and then abs() is taken.\n        # This gives the shortest angle (geodesic distance) in [0, pi].\n        delta = p - g\n        d_i = np.abs((delta + np.pi) % (2 * np.pi) - np.pi)\n\n        # Step 2: Identify unambiguous and ambiguous indices\n        unamb_indices = [i for i, aa in enumerate(input_seq) if aa not in ambiguous_codes]\n        amb_indices = [i for i, aa in enumerate(input_seq) if aa in ambiguous_codes]\n\n        # Step 3: Calculate the three cMAE metrics\n        # MAE_all\n        mae_all = np.mean(d_i)\n\n        # MAE_unamb\n        if len(unamb_indices) > 0:\n            mae_unamb = np.mean(d_i[unamb_indices])\n        else:\n            mae_unamb = float('inf')\n\n        # MAE_amb\n        if len(amb_indices) > 0:\n            mae_amb = np.mean(d_i[amb_indices])\n        else:\n            mae_amb = float('inf')\n\n        results_list.append([mae_all, mae_unamb, mae_amb])\n\n    # Format the final output string as specified.\n    def format_val(v):\n        if v == float('inf'):\n            return 'inf'\n        return f'{v:.6f}'\n\n    case_strings = []\n    for result_triple in results_list:\n        formatted_triple = [format_val(v) for v in result_triple]\n        case_strings.append(f\"[{','.join(formatted_triple)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2387766"}, {"introduction": "从评估一维的角度数据，我们现在转向评估完整的三维坐标。均方根偏差（Root-Mean-Square Deviation, RMSD）是比较蛋白质三维结构的金标准。这项高级练习要求您实现一个稳健的 RMSD 计算方法，并将其应用于一个引人入胜的生物学案例——变构蛋白，这种蛋白可以稳定地折叠成两种或多种截然不同的构象。这不仅考验您的编程和算法能力，也促使您思考当“正确答案”不止一个时，如何科学地评估预测的准确性 [@problem_id:2387752]。", "problem": "您将对一个端到端蛋白质结构预测模型在变构蛋白质上进行一项正式评估任务。一个变构蛋白质可以采取两种不同的稳定折叠。对于一个给定的预测三维坐标集 $\\mathbf{P} \\in \\mathbb{R}^{N \\times 3}$（每行代表一个残基，解释为α-碳坐标）以及同一序列的两个天然折叠 $\\mathbf{A} \\in \\mathbb{R}^{N \\times 3}$ 和 $\\mathbf{B} \\in \\mathbb{R}^{N \\times 3}$，我们将 $\\mathbf{P}$ 与一个天然折叠 $\\mathbf{X} \\in \\{\\mathbf{A}, \\mathbf{B}\\}$ 之间的均方根偏差 (RMSD) 定义为对 $\\mathbf{P}$ 进行所有真刚体变换后所能得到的最小值：\n$$\n\\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X}) \\triangleq \\min_{\\mathbf{R},\\,\\mathbf{t}} \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{R}\\,\\mathbf{p}_i + \\mathbf{t} - \\mathbf{x}_i \\right\\|_2^2}\n$$\n其中要求 $\\mathbf{R} \\in \\mathrm{SO}(3)$（三维空间中的特殊正交旋转群，即 $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ 且 $\\det(\\mathbf{R}) = 1$）且 $\\mathbf{t} \\in \\mathbb{R}^3$。此处，$\\mathbf{p}_i$和$\\mathbf{x}_i$分别表示$\\mathbf{P}$和$\\mathbf{X}$的第$i$行。将变构评估得分定义为\n$$\ns(\\mathbf{P}; \\mathbf{A}, \\mathbf{B}) \\triangleq \\min\\left( \\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{A}), \\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{B}) \\right).\n$$\n设接受阈值为 $\\tau = 1.0$ 埃 (Å)。如果 $s(\\mathbf{P}; \\mathbf{A}, \\mathbf{B}) \\le \\tau$，则认为对该变构蛋白质的预测是正确的。所有 RMSD 值必须以 Å 为单位表示，并在最终输出中四舍五入到三位小数。\n\n测试套件。对于每个测试用例 $k \\in \\{1,2,3\\}$，给定一个序列长度 $N_k$ 和两个天然折叠 $\\mathbf{A}^{(k)}$ 和 $\\mathbf{B}^{(k)}$。您必须按照上述定义，评估一个指定的预测结构 $\\mathbf{P}^{(k)}$ 与 $\\mathbf{A}^{(k)}$ 和 $\\mathbf{B}^{(k)}$ 的匹配程度。下文出现的角度以弧度为单位。\n\n- 测试用例 1（理想情况；预测结果与第一个折叠在刚体变换下匹配）：\n  - $N_1 = 5$。\n  - $\\mathbf{A}^{(1)}$ 的各行为\n    $$\n    (0,0,0),\\ (3.8,0,0),\\ (7.6,0,0),\\ (11.4,0,0),\\ (15.2,0,0).\n    $$\n  - 定义 $\\delta \\triangleq \\frac{3.8}{\\sqrt{2}}$。$\\mathbf{B}^{(1)}$ 的各行为\n    $$\n    (0,0,0),\\ (\\delta,\\delta,0),\\ (2\\delta,0,0),\\ (3\\delta,\\delta,0),\\ (4\\delta,0,0).\n    $$\n  - 设 $\\theta = \\pi/6$ 且 $\\mathbf{t}^{(1)} = (1.1,-2.3,0.5)$。令 $\\mathbf{R}_z(\\theta)$ 表示绕 $z$ 轴旋转 $\\theta$ 角度的旋转，其矩阵为\n    $$\n    \\mathbf{R}_z(\\theta) = \\begin{bmatrix}\n    \\cos\\theta & -\\sin\\theta & 0\\\\\n    \\sin\\theta & \\cos\\theta & 0\\\\\n    0 & 0 & 1\n    \\end{bmatrix}.\n    $$\n    预测结果为\n    $$\n    \\mathbf{P}^{(1)} = \\mathbf{A}^{(1)} \\mathbf{R}_z(\\theta)^{\\top} + \\mathbf{1}\\, (\\mathbf{t}^{(1)})^{\\top},\n    $$\n    其中 $\\mathbf{1} \\in \\mathbb{R}^{N_1 \\times 1}$ 是全为1的列向量，加法是逐行进行的。\n\n- 测试用例 2（预测结果与第二个折叠在刚体变换下匹配）：\n  - $N_2 = 6$。\n  - $\\mathbf{A}^{(2)}$ 的各行为\n    $$\n    (0,0,0),\\ (0,3.8,0),\\ (0,7.6,0),\\ (0,11.4,0),\\ (0,15.2,0),\\ (0,19.0,0).\n    $$\n  - $\\mathbf{B}^{(2)}$ 的各行为\n    $$\n    (0,0,0),\\ (3.8,0,0),\\ (7.6,0,0),\\ (7.6,3.8,0),\\ (7.6,7.6,0),\\ (7.6,11.4,0).\n    $$\n  - 设 $\\phi = -\\pi/3$ 且 $\\mathbf{t}^{(2)} = (0.2,-0.5,1.0)$。预测结果为\n    $$\n    \\mathbf{P}^{(2)} = \\mathbf{B}^{(2)} \\mathbf{R}_z(\\phi)^{\\top} + \\mathbf{1}\\, (\\mathbf{t}^{(2)})^{\\top}.\n    $$\n\n- 测试用例 3（边缘情况；一个无法通过真旋转匹配的镜像预测）：\n  - $N_3 = 5$。\n  - 通过对以下长度为 $3.8$ 的步长向量进行累加和来构造 $\\mathbf{A}^{(3)}$：\n    $$\n    \\mathbf{s}_1 = \\left(3.8\\cos\\left(\\frac{\\pi}{3}\\right),\\ 3.8\\sin\\left(\\frac{\\pi}{3}\\right),\\ 0\\right),\n    $$\n    $$\n    \\mathbf{s}_2 = \\left(\\sqrt{3.8^2-1.0^2}\\cos\\left(-\\frac{\\pi}{3}\\right),\\ \\sqrt{3.8^2-1.0^2}\\sin\\left(-\\frac{\\pi}{3}\\right),\\ 1.0\\right),\n    $$\n    $$\n    \\mathbf{s}_3 = \\left(\\sqrt{3.8^2-0.7^2}\\cos\\left(\\frac{\\pi}{9}\\right),\\ \\sqrt{3.8^2-0.7^2}\\sin\\left(\\frac{\\pi}{9}\\right),\\ -0.7\\right),\n    $$\n    $$\n    \\mathbf{s}_4 = \\left(\\sqrt{3.8^2-0.9^2}\\cos\\left(-\\frac{13\\pi}{18}\\right),\\ \\sqrt{3.8^2-0.9^2}\\sin\\left(-\\frac{13\\pi}{18}\\right),\\ 0.9\\right).\n    $$\n    设第一行为 $(0,0,0)$，后续每一行是 $(0,0,0)$ 与前 $j$ 个步长向量之和，其中 $j \\in \\{1,2,3,4\\}$。因此 $\\mathbf{A}^{(3)}$ 有 5 行。\n  - 设 $\\mathbf{B}^{(3)}$ 与测试用例 1 中的 $\\mathbf{B}^{(1)}$ 相同（重用 $\\delta$）。\n  - 定义反射矩阵\n    $$\n    \\mathbf{F} = \\mathrm{diag}(-1,\\,1,\\,1),\n    $$\n    该矩阵将 $x$ 坐标关于 $yz$ 平面镜像为 $-x$。预测结果为\n    $$\n    \\mathbf{P}^{(3)} = \\mathbf{A}^{(3)} \\mathbf{F}^{\\top}.\n    $$\n\n对于每个测试用例 $k$，计算\n- $r_A^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{A}^{(k)})$，\n- $r_B^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{B}^{(k)})$，\n- $r^{(k)} = \\min(r_A^{(k)}, r_B^{(k)})$，\n- $m^{(k)} = 1$ 如果 $r_A^{(k)} \\le r_B^{(k)}$，否则 $m^{(k)} = 2$，\n- $c^{(k)} = \\text{True}$ 如果 $r^{(k)} \\le \\tau$，否则 $c^{(k)} = \\text{False}$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含三个测试用例的结果，表现为一个逗号分隔的三元组列表，不含空格，并用方括号括起来。每个三元组必须为 $[r^{(k)},m^{(k)},c^{(k)}]$ 的形式，其中 $r^{(k)}$ 是以 Å 为单位并四舍五入到三位小数的最小 RMSD，$m^{(k)}$ 是整数折叠索引 1 或 2，$c^{(k)}$ 是一个布尔值。例如，输出必须类似如下形式\n$$\n\\big[ [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot] \\big]\n$$\n但需使用实际计算出的值，不含多余空格，且数值按指定格式排版。", "solution": "该问题陈述已经过验证，并被确定为计算结构生物学领域中一个定义明确、有科学依据的任务。它为获得一个唯一且可验证的解提供了所有必要的定义和数据。该问题要求实现一个标准算法，用以计算两组三维坐标之间的均方根偏差 (RMSD)，并应用该算法来评估一个蛋白质结构预测相对于一个变构蛋白质的两种可能的天然折叠。\n\n问题的核心是计算 $\\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X})$，它被定义为对预测结构 $\\mathbf{P}$ 进行所有可能的刚体变换后所能得到的最小 RMSD。一次刚体变换包括一次旋转 $\\mathbf{R}$ 和一次平移 $\\mathbf{t}$。该最小化问题由下式给出：\n$$\n\\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X}) = \\min_{\\mathbf{R} \\in \\mathrm{SO}(3), \\mathbf{t} \\in \\mathbb{R}^3} \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| (\\mathbf{R}\\,\\mathbf{p}_i + \\mathbf{t}) - \\mathbf{x}_i \\right\\|_2^2}\n$$\n这是一个结构比对中的经典问题，其解法可使用 Kabsch 算法或基于奇异值分解 (SVD) 的数值等效方法求得。该过程包括以下步骤：\n\n1.  **坐标中心化**：可以证明，最优平移 $\\mathbf{t}$ 会将旋转后的点集 $\\mathbf{R}\\mathbf{P}$ 的质心与参考点集 $\\mathbf{X}$ 的质心相重合。因此，第一步是平移两个坐标集，使它们的质心都位于原点。设 $\\mathbf{P}$ 和 $\\mathbf{X}$ 为 $N \\times 3$ 的坐标矩阵。质心计算如下：\n    $$\n    \\bar{\\mathbf{p}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{p}_i, \\quad \\bar{\\mathbf{x}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{x}_i\n    $$\n    然后，通过从每个点中减去各自的质心，得到中心化后的坐标矩阵 $\\mathbf{P}'$ 和 $\\mathbf{X}'$：\n    $$\n    \\mathbf{p}'_i = \\mathbf{p}_i - \\bar{\\mathbf{p}}, \\quad \\mathbf{x}'_i = \\mathbf{x}_i - \\bar{\\mathbf{x}}\n    $$\n    中心化之后，问题简化为寻找一个最优旋转 $\\mathbf{R}$，以最小化 $\\mathbf{P}'$ 的变换点与 $\\mathbf{X}'$ 的点之间的距离。\n\n2.  **协方差矩阵**：最优旋转可通过考虑中心化坐标的协方差矩阵来找到。对于表示为 $N \\times 3$ 矩阵（其中每行为一个点）的点集，其 $3 \\times 3$ 协方差矩阵 $\\mathbf{H}$ 计算如下：\n    $$\n    \\mathbf{H} = (\\mathbf{P}')^{\\top} \\mathbf{X}'\n    $$\n\n3.  **奇异值分解 (SVD)**：我们对协方差矩阵 $\\mathbf{H}$ 进行 SVD 分解：\n    $$\n    \\mathbf{H} = \\mathbf{U} \\mathbf{\\Sigma} \\mathbf{V}^{\\top}\n    $$\n    此处，$\\mathbf{U}$ 和 $\\mathbf{V}$ 是 $3 \\times 3$ 的正交矩阵，$\\mathbf{\\Sigma}$ 是一个包含奇异值的 $3 \\times 3$ 对角矩阵。\n\n4.  **最优旋转矩阵**：最大化重叠（从而最小化 RMSD）的最优旋转矩阵 $\\mathbf{R}$ 由下式给出：\n    $$\n    \\mathbf{R} = \\mathbf{V} \\mathbf{U}^{\\top}\n    $$\n\n5.  **反射处理**：问题规定旋转 $\\mathbf{R}$ 必须是真旋转，即它必须属于特殊正交群 $\\mathrm{SO}(3)$，这要求其行列式为 $+1$。上述计算出的矩阵 $\\mathbf{R}$ 的行列式可能为 $-1$。这种情况发生在一个坐标集是另一个坐标集的镜像（对映异构体）时。为确保得到真旋转，我们检查其行列式：\n    $$\n    d = \\det(\\mathbf{R}) = \\det(\\mathbf{V} \\mathbf{U}^{\\top})\n    $$\n    如果 $d = -1$，则最优变换是一个反射。为了找到最佳的*真*旋转，我们必须修正 $\\mathbf{R}$。标准方法是反转与最小奇异值对应的旋转分量。这通过在计算 $\\mathbf{R}$ 之前翻转 $\\mathbf{V}$ 的最后一列的符号来实现：\n    $$\n    \\text{如果 } \\det(\\mathbf{V} \\mathbf{U}^{\\top}) = -1, \\text{ 则设置 } \\mathbf{R} = \\mathbf{V} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix} \\mathbf{U}^{\\top}\n    $$\n    此修正保证了 $\\det(\\mathbf{R}) = +1$，并给出了在 $\\mathrm{SO}(3)$ 内的最优解。这一检查对于测试用例 3 至关重要，因为在该用例中，预测的结构是天然折叠的一个明确的镜像。\n\n6.  **RMSD 计算**：找到最优真旋转 $\\mathbf{R}$ 后，对 $\\mathbf{P}'$ 的坐标进行旋转，并使用中心化坐标计算 RMSD：\n    $$\n    \\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X}) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{p}'_i \\mathbf{R} - \\mathbf{x}'_i \\right\\|_2^2}\n    $$\n    注意，对于行向量 $\\mathbf{p}'_i$，旋转操作表示为 $\\mathbf{p}'_i \\mathbf{R}$。\n\n对于每个测试用例 $k \\in \\{1,2,3\\}$，此过程应用两次：第一次用于计算 $r_A^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{A}^{(k)})$，第二次用于计算 $r_B^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{B}^{(k)})$。然后根据这两个 RMSD 值和接受阈值 $\\tau = 1.0$ 来确定变构得分 $r^{(k)}$、匹配的折叠索引 $m^{(k)}$ 以及正确性标志 $c^{(k)}$。\n\n对于测试用例 1 和 2，预测结构 $\\mathbf{P}^{(k)}$ 是通过对其中一个天然折叠（分别为 $\\mathbf{A}^{(1)}$ 和 $\\mathbf{B}^{(2)}$）应用真刚体变换而构建的。因此，与该特定折叠计算出的 RMSD 预计在数值上为零，变构得分 $r^{(k)}$ 将为 $0.000$。\n\n对于测试用例 3，$\\mathbf{P}^{(3)}$ 是 $\\mathbf{A}^{(3)}$ 的一个镜像。计算 $\\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(3)}, \\mathbf{A}^{(3)})$ 时将触发反射处理步骤，导致一个非零的 RMSD，因为真旋转无法将一个结构完美地叠加到其镜像上。最终得分将取决于两个非零 RMSD 值 $r_A^{(3)}$ 和 $r_B^{(3)}$ 中哪一个更小。", "answer": "```python\nimport numpy as np\n\ndef calculate_rmsd(P, X):\n    \"\"\"\n    Calculates the Root-Mean-Square Deviation (RMSD) between two sets of\n    3D coordinates P and X, minimized over rigid-body transformations.\n\n    This function implements the Kabsch algorithm.\n\n    Args:\n        P (np.ndarray): An N x 3 matrix of coordinates to be aligned.\n        X (np.ndarray): An N x 3 matrix of reference coordinates.\n\n    Returns:\n        float: The RMSD value in the same units as the input coordinates.\n    \"\"\"\n    # Number of points\n    N = P.shape[0]\n\n    # 1. Center the coordinate sets\n    centroid_P = np.mean(P, axis=0)\n    centroid_X = np.mean(X, axis=0)\n    P_centered = P - centroid_P\n    X_centered = X - centroid_X\n\n    # 2. Compute the covariance matrix H = P_centered.T @ X_centered\n    H = P_centered.T @ X_centered\n\n    # 3. Singular Value Decomposition\n    U, S, Vt = np.linalg.svd(H)\n\n    # 4. Compute the optimal rotation matrix R\n    R = Vt.T @ U.T\n\n    # 5. Handle reflection case (det(R)  0)\n    if np.linalg.det(R)  0:\n        # Flip the sign of the column of V corresponding to the smallest singular value\n        Vt_corrected = Vt.copy()\n        Vt_corrected[-1, :] *= -1\n        R = Vt_corrected.T @ U.T\n\n    # 6. Apply rotation to P_centered\n    # For row vectors, the transformation is P @ R.T\n    P_rotated = P_centered @ R\n\n    # 7. Calculate RMSD\n    diff = P_rotated - X_centered\n    rmsd = np.sqrt(np.sum(diff**2) / N)\n\n    return rmsd\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating predicted structures against native folds\n    for three test cases.\n    \"\"\"\n    tau = 1.0\n    results = []\n\n    # --- Test Case 1 ---\n    N1 = 5\n    A1 = np.array([[3.8 * i, 0, 0] for i in range(N1)], dtype=float)\n\n    delta = 3.8 / np.sqrt(2)\n    B1 = np.array([\n        [0.0, 0.0, 0.0],\n        [delta, delta, 0.0],\n        [2 * delta, 0.0, 0.0],\n        [3 * delta, delta, 0.0],\n        [4 * delta, 0.0, 0.0]\n    ], dtype=float)\n    \n    theta = np.pi / 6\n    t1 = np.array([1.1, -2.3, 0.5])\n    Rz1 = np.array([\n        [np.cos(theta), -np.sin(theta), 0],\n        [np.sin(theta), np.cos(theta), 0],\n        [0, 0, 1]\n    ])\n    P1 = A1 @ Rz1.T + t1\n\n    rA1 = calculate_rmsd(P1, A1)\n    rB1 = calculate_rmsd(P1, B1)\n    \n    if rA1 = rB1:\n        r1, m1 = rA1, 1\n    else:\n        r1, m1 = rB1, 2\n    c1 = r1 = tau\n    # The f-string representation of a boolean is \"True\" or \"False\", which is required.\n    results.append(f\"[{r1:.3f},{m1},{str(c1)}]\")\n\n    # --- Test Case 2 ---\n    N2 = 6\n    A2 = np.array([[0, 3.8 * i, 0] for i in range(N2)], dtype=float)\n    B2 = np.array([\n        [0.0, 0.0, 0.0],\n        [3.8, 0.0, 0.0],\n        [7.6, 0.0, 0.0],\n        [7.6, 3.8, 0.0],\n        [7.6, 7.6, 0.0],\n        [7.6, 11.4, 0.0]\n    ], dtype=float)\n    \n    phi = -np.pi / 3\n    t2 = np.array([0.2, -0.5, 1.0])\n    Rz2 = np.array([\n        [np.cos(phi), -np.sin(phi), 0],\n        [np.sin(phi), np.cos(phi), 0],\n        [0, 0, 1]\n    ])\n    P2 = B2 @ Rz2.T + t2\n    \n    rA2 = calculate_rmsd(P2, A2)\n    rB2 = calculate_rmsd(P2, B2)\n\n    if rA2 = rB2:\n        r2, m2 = rA2, 1\n    else:\n        r2, m2 = rB2, 2\n    c2 = r2 = tau\n    results.append(f\"[{r2:.3f},{m2},{str(c2)}]\")\n\n    # --- Test Case 3 ---\n    N3 = 5\n    s_vecs = []\n    # s1\n    s_vecs.append(np.array([3.8 * np.cos(np.pi/3), 3.8 * np.sin(np.pi/3), 0.0]))\n    # s2\n    len_s2 = np.sqrt(3.8**2 - 1.0**2)\n    s_vecs.append(np.array([len_s2 * np.cos(-np.pi/3), len_s2 * np.sin(-np.pi/3), 1.0]))\n    # s3\n    len_s3 = np.sqrt(3.8**2 - 0.7**2)\n    s_vecs.append(np.array([len_s3 * np.cos(np.pi/9), len_s3 * np.sin(np.pi/9), -0.7]))\n    # s4\n    len_s4 = np.sqrt(3.8**2 - 0.9**2)\n    s_vecs.append(np.array([len_s4 * np.cos(-13*np.pi/18), len_s4 * np.sin(-13*np.pi/18), 0.9]))\n    \n    A3_coords = [np.zeros(3)]\n    current_pos = np.zeros(3)\n    for vec in s_vecs:\n        current_pos = current_pos + vec\n        A3_coords.append(current_pos)\n    A3 = np.array(A3_coords)\n    \n    # B3 re-uses B1 geometry but with N=5. B1 already has N=5.\n    B3 = B1\n    \n    F = np.diag([-1., 1., 1.])\n    P3 = A3 @ F\n    \n    rA3 = calculate_rmsd(P3, A3)\n    rB3 = calculate_rmsd(P3, B3)\n\n    if rA3 = rB3:\n        r3, m3 = rA3, 1\n    else:\n        r3, m3 = rB3, 2\n    c3 = r3 = tau\n    results.append(f\"[{r3:.3f},{m3},{str(c3)}]\")\n    \n    # Final print statement\n    # Convert booleans to lowercase 'true'/'false' as per standard JSON/Python bool string representation\n    final_string = f\"[{','.join(results)}]\"\n    print(final_string.replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```", "id": "2387752"}]}