{"hands_on_practices": [{"introduction": "我们的第一个实践练习将指导您实现一个基础的折叠识别评分函数。您将学习如何基于疏水性原则，量化一个序列与一个结构的“契合度”。这项练习 [@problem_id:2391514] 通过创建一个简单的能量函数来实施这一原则，该函数会奖励有利的残基布局（例如将疏水残基埋藏在核心）并惩罚不利的布局。通过完成这个练习，您将获得将核心生物物理概念转化为计算模型的实践经验。", "problem": "给定一个固定长度的穿线评估设置，该设置根据已知的溶剂暴露倾向性，对氨基酸残基在结构模板上的放置进行评分。目标是为每个测试用例计算一个单一的“负穿线分数”，使得放置在表面暴露位置的亲水性残基产生更有利（更负）的贡献，而放置在包埋位置的亲水性残基则产生惩罚（正贡献）。疏水性残基产生相反的模式。最终分数是所有位置分数的总和，不考虑任何间隙或插入。\n\n定义和设置：\n- 设序列长度为 $n \\in \\mathbb{N}$，由位置 $i \\in \\{1,\\dots,n\\}$ 索引。\n- 结构模板为每个位置 $i$ 提供一个溶剂暴露值 $e_i \\in [0,1]$，其中 $e_i = 1$ 表示完全表面暴露，$e_i = 0$ 表示完全包埋。\n- 设 $\\mathcal{A}$ 为20种标准氨基酸的集合。定义亲水性子集 $\\mathcal{H} = \\{ \\mathrm{D}, \\mathrm{E}, \\mathrm{K}, \\mathrm{R}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{H}, \\mathrm{S}, \\mathrm{T}, \\mathrm{Y} \\}$，并将 $\\mathcal{A} \\setminus \\mathcal{H}$ 中的所有残基视为疏水性。任何不在 $\\mathcal{A}$ 中的残基在其位置上的贡献为零。\n- 定义亲水性指示符 $h(a)$，如果 $a \\in \\mathcal{H}$ 则 $h(a) = 1$，如果 $a \\in \\mathcal{A} \\setminus \\mathcal{H}$ 则 $h(a) = 0$。对于 $a \\notin \\mathcal{A}$，将其在每个位置上的贡献设置为零。\n- 使用两个正数权重：$\\lambda_{h} = 2$ 和 $\\lambda_{hp} = 1$。\n- 对于位置 $i$ 处暴露值为 $e_i$ 的残基 $a_i$，其单位位置分数为\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;+\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(2 e_i - 1).\n$$\n- 总负穿线分数为\n$$\nS = \\sum_{i=1}^{n} s_i.\n$$\n根据该构造，如果 $h(a_i) = 1$ 且 $e_i$ 值较大，则 $s_i$ 为负（有利）；而如果 $h(a_i) = 1$ 且 $e_i$ 值较小，则 $s_i$ 为正（惩罚）。相反地，如果 $h(a_i) = 0$（疏水性）且 $e_i$ 值较小（包埋），则 $s_i$ 为负（有利）；而如果 $e_i$ 值较大（表面），则 $s_i$ 为正（惩罚）。\n\n任务：\n- 实现一个程序，为以下每个测试用例计算 $S$。在每个案例中，序列长度等于暴露值的数量。暴露值为无单位量，且属于 $[0,1]$ 区间。\n\n测试套件：\n- 案例1：序列 = \"DEKR\"，暴露值 = $[1.0, 0.8, 0.2, 0.2]$。\n- 案例2：序列 = \"VVIL\"，暴露值 = $[0.1, 0.3, 0.8, 1.0]$。\n- 案例3：序列 = \"DKVA\"，暴露值 = $[1.0, 0.2, 0.8, 0.2]$。\n- 案例4：序列 = \"AXZX\"，暴露值 = $[1.0, 0.0, 1.0, 0.0]$。\n- 案例5：序列 = \"STYW\"，暴露值 = $[0.5, 0.5, 0.5, 0.5]$。\n\n要求：\n- 为每个案例精确计算上述定义的总分 $S$。如果任何残基不在 $\\mathcal{A}$ 中，则无论 $e_i$ 为何值，其在该位置的贡献都定义为 $0$。\n- 生成单行输出，其中包含一个列表，列表内含5个按案例顺序排列的总分。每个分数必须是十进制（浮点）值，并四舍五入到小数点后恰好三位。该列表必须用方括号括起来，并包含用逗号分隔且无空格的值。例如，一个包含三个值的输出必须看起来像 $[x_1,x_2,x_3]$，其中每个 $x_j$ 在小数点后都有恰好三位数字。", "solution": "该问题陈述已经过严格验证，被认为是具有科学依据、良置且客观的。它为蛋白质折叠识别——一个计算生物学中的有效课题——提供了一个简化但连贯的模型。所有参数、函数和测试用例都得到了明确且一致的定义，从而允许得出唯一且可验证的解。因此，我们可以进行推导。\n\n目标是为五个给定的测试用例计算总负穿线分数 $S$。该分数评估蛋白质序列 $a_1 a_2 \\dots a_n$ 对于一个由一系列溶剂暴露值 $e_1, e_2, \\dots, e_n$ 定义的结构模板的适应性。\n\n分数定义为单位位置分数的总和，$S = \\sum_{i=1}^{n} s_i$。对于位置 $i$ 处暴露值为 $e_i$ 的残基 $a_i$，其单位位置分数 $s_i$ 由下式给出：\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;+\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(2 e_i - 1)\n$$\n其中 $h(a_i)$ 是亲水性指示符，如果 $a_i$ 是亲水性的，则 $h(a_i) = 1$，如果 $a_i$ 是疏水性的，则 $h(a_i) = 0$。权重给定为 $\\lambda_h = 2$ 和 $\\lambda_{hp} = 1$。对于任何不属于20种标准氨基酸（$\\mathcal{A}$）的残基 $a_i$，其贡献 $s_i$ 被规定为 $0$。\n\n我们可以通过注意到 $(2e_i - 1) = -(1 - 2e_i)$ 来简化 $s_i$ 的表达式。将此代入公式可得：\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;-\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(1 - 2 e_i)\n$$\n将项 $(1 - 2e_i)$ 因子分解出来：\n$$\ns_i = (1 - 2e_i) \\left[ \\lambda_h h(a_i) - \\lambda_{hp}(1 - h(a_i)) \\right]\n$$\n对于 $a_i \\in \\mathcal{A}$ 的两种残基类型，可以对该表达式进行求值：\n1.  如果残基 $a_i$ 是亲水性的（$a_i \\in \\mathcal{H}$），则 $h(a_i) = 1$。方括号中的项变为 $\\lambda_h \\cdot 1 - \\lambda_{hp}(1-1) = \\lambda_h$。分数为 $s_i = \\lambda_h (1 - 2e_i) = 2(1 - 2e_i)$。\n2.  如果残基 $a_i$ 是疏水性的（$a_i \\in \\mathcal{A} \\setminus \\mathcal{H}$），则 $h(a_i) = 0$。方括号中的项变为 $\\lambda_h \\cdot 0 - \\lambda_{hp}(1-0) = -\\lambda_{hp}$。分数为 $s_i = -\\lambda_{hp}(1 - 2e_i) = \\lambda_{hp}(2e_i - 1) = 1(2e_i - 1)$。\n\n我们现在将应用这些简化公式来计算每个测试用例的总分 $S$。亲水性集合为 $\\mathcal{H} = \\{ \\mathrm{D}, \\mathrm{E}, \\mathrm{K}, \\mathrm{R}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{H}, \\mathrm{S}, \\mathrm{T}, \\mathrm{Y} \\}$。\n\n**案例1：** 序列 = \"DEKR\"，暴露值 = $[1.0, 0.8, 0.2, 0.2]$\n所有残基均为亲水性。\n$s_1(\\mathrm{D}, e_1=1.0) = 2(1 - 2 \\cdot 1.0) = 2(-1) = -2.0$\n$s_2(\\mathrm{E}, e_2=0.8) = 2(1 - 2 \\cdot 0.8) = 2(-0.6) = -1.2$\n$s_3(\\mathrm{K}, e_3=0.2) = 2(1 - 2 \\cdot 0.2) = 2(0.6) = 1.2$\n$s_4(\\mathrm{R}, e_4=0.2) = 2(1 - 2 \\cdot 0.2) = 2(0.6) = 1.2$\n总分 $S_1 = -2.0 - 1.2 + 1.2 + 1.2 = -0.8$。\n\n**案例2：** 序列 = \"VVIL\"，暴露值 = $[0.1, 0.3, 0.8, 1.0]$\n所有残基均为疏水性。\n$s_1(\\mathrm{V}, e_1=0.1) = (2 \\cdot 0.1 - 1) = -0.8$\n$s_2(\\mathrm{V}, e_2=0.3) = (2 \\cdot 0.3 - 1) = -0.4$\n$s_3(\\mathrm{I}, e_3=0.8) = (2 \\cdot 0.8 - 1) = 0.6$\n$s_4(\\mathrm{L}, e_4=1.0) = (2 \\cdot 1.0 - 1) = 1.0$\n总分 $S_2 = -0.8 - 0.4 + 0.6 + 1.0 = 0.4$。\n\n**案例3：** 序列 = \"DKVA\"，暴露值 = $[1.0, 0.2, 0.8, 0.2]$\n残基 D、K 为亲水性；V、A 为疏水性。\n$s_1(\\mathrm{D}, e_1=1.0) = 2(1 - 2 \\cdot 1.0) = -2.0$\n$s_2(\\mathrm{K}, e_2=0.2) = 2(1 - 2 \\cdot 0.2) = 1.2$\n$s_3(\\mathrm{V}, e_3=0.8) = (2 \\cdot 0.8 - 1) = 0.6$\n$s_4(\\mathrm{A}, e_4=0.2) = (2 \\cdot 0.2 - 1) = -0.6$\n总分 $S_3 = -2.0 + 1.2 + 0.6 - 0.6 = -0.8$。\n\n**案例4：** 序列 = \"AXZX\"，暴露值 = $[1.0, 0.0, 1.0, 0.0]$\n残基 A 为疏水性。残基 X 和 Z 不在标准集合 $\\mathcal{A}$ 中。\n$s_1(\\mathrm{A}, e_1=1.0) = (2 \\cdot 1.0 - 1) = 1.0$\n$s_2(\\mathrm{X}, e_2=0.0) = 0$ (非标准)\n$s_3(\\mathrm{Z}, e_3=1.0) = 0$ (非标准)\n$s_4(\\mathrm{X}, e_4=0.0) = 0$ (非标准)\n总分 $S_4 = 1.0 + 0 + 0 + 0 = 1.0$。\n\n**案例5：** 序列 = \"STYW\"，暴露值 = $[0.5, 0.5, 0.5, 0.5]$\n残基 S、T、Y 为亲水性；W 为疏水性。所有位置的暴露值均为 $e_i=0.5$。\n$s_1(\\mathrm{S}, e_1=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_2(\\mathrm{T}, e_2=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_3(\\mathrm{Y}, e_3=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_4(\\mathrm{W}, e_4=0.5) = (2 \\cdot 0.5 - 1) = 0$\n总分 $S_5 = 0 + 0 + 0 + 0 = 0.0$。这是预料之中的，因为 $e_i=0.5$ 的暴露值代表一个中性环境，对任何一种残基类型都没有能量上的偏好。\n\n结果总结：\n$S_1 = -0.8$\n$S_2 = 0.4$\n$S_3 = -0.8$\n$S_4 = 1.0$\n$S_5 = 0.0$\n\n这些结果将被格式化为小数点后三位，用于最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the negative threading score for a set of protein sequences\n    based on a simplified solvent exposure model.\n    \"\"\"\n\n    # Define problem parameters as per the statement.\n    lambda_h = 2.0\n    lambda_hp = 1.0\n    hydrophilic_residues = {'D', 'E', 'K', 'R', 'N', 'Q', 'H', 'S', 'T', 'Y'}\n    standard_amino_acids = {\n        'A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L',\n        'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y'\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"DEKR\", [1.0, 0.8, 0.2, 0.2]),\n        (\"VVIL\", [0.1, 0.3, 0.8, 1.0]),\n        (\"DKVA\", [1.0, 0.2, 0.8, 0.2]),\n        (\"AXZX\", [1.0, 0.0, 1.0, 0.0]),\n        (\"STYW\", [0.5, 0.5, 0.5, 0.5])\n    ]\n\n    results = []\n    # Iterate through each test case to calculate its total score.\n    for sequence, exposures in test_cases:\n        total_score = 0.0\n        # Iterate through each position in the sequence.\n        for i, residue in enumerate(sequence):\n            # The contribution is zero for non-standard amino acids.\n            if residue not in standard_amino_acids:\n                s_i = 0.0\n            else:\n                e_i = exposures[i]\n                is_hydrophilic = residue in hydrophilic_residues\n                \n                # Apply the appropriate scoring formula based on hydrophilicity.\n                if is_hydrophilic:\n                    # s_i = lambda_h * (1 - 2*e_i) for hydrophilic residues.\n                    s_i = lambda_h * (1.0 - 2.0 * e_i)\n                else:  # The residue is hydrophobic.\n                    # s_i = lambda_hp * (2*e_i - 1) for hydrophobic residues.\n                    s_i = lambda_hp * (2.0 * e_i - 1.0)\n            \n            total_score += s_i\n            \n        results.append(total_score)\n\n    # Format the results to exactly three decimal places as required.\n    formatted_results = [f\"{score:.3f}\" for score in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2391514"}, {"introduction": "在评分函数概念的基础上，我们的下一个练习引入了一种基于特定二级结构不相容性的惩罚项。您将实现一条规则，该规则考虑了氨基酸脯氨酸（Proline）独特的结构特性。脯氨酸独特的环状结构限制了其主链的二面角，使其成为一个“α螺旋破坏者”，因此很少出现在 $\\alpha$ 螺旋的内部。这项练习 [@problem_id:2391554] 通过在评分函数中增加一个惩罚项来模拟这一公认的立体化学约束，这展示了穿线方法如何通过整合蛋白质结构的详细、基于规则的知识来得到改进。", "problem": "这是一个简化的穿线（threading）场景：一个查询氨基酸序列被无空位地比对到一个固定的蛋白质模板上，该模板已由预测的二级结构状态进行标注。模板是一个由字母表 {\"H\", \"E\", \"C\"} 构成的字符串，其中 \"H\" 表示一个 $\\alpha$-螺旋位置，\"E\" 表示一个 $\\beta$-折叠位置，\"C\" 表示一个无规卷曲位置。查询序列是一个由标准的 $20$ 种氨基酸单字母代码构成的字符串。穿线通过一个整数偏移量 $k$ 来指定，意味着查询序列的第一个残基比对到索引为 $k$ 的模板位置，并且通常情况下，索引为 $j$ 的查询残基比对到索引为 $k+j$ 的模板位置。所有索引都从 0 开始。你必须定义一个评分函数，该函数会对查询序列中的脯氨酸残基（\"P\"）被穿入模板中 $\\alpha$-螺旋片段内部的情况进行惩罚。\n\n定义：\n- 螺旋片段是模板中 \"H\" 字符的最大连续序列。如果这样一个片段跨越了模板中从索引 $a$ 到 $b$（含）的位置，其长度为 $L=b-a+1$。\n- 在一个螺旋片段内，使用基于 1 且局部于该片段的索引方式，将模板位置 $i$ 的局部螺旋索引定义为 $j=i-a+1$。如果一个模板位置满足 $1<j<L$，则称其位于螺旋内部。\n- 设 $\\lambda>0$ 为一个给定的标量惩罚权重。对于给定的查询序列、模板、偏移量和 $\\lambda$，总分 $S$ 定义为\n$$\nS \\;=\\; \\lambda \\cdot \\left|\\left\\{\\, j \\;\\middle|\\; \\text{the query residue at index } j \\text{ is \"P\", the aligned template position } k+j \\text{ is \"H\", and that \"H\" position is interior in its helix segment} \\,\\right\\}\\right|.\n$$\n也就是说，分数等于 $\\lambda$ 乘以“脯氨酸被放置在如上定义的螺旋片段内部”的比对位置的数量。其他任何布局都对分数没有贡献。\n\n任务：\n- 编写一个程序，为每个提供的测试用例精确计算所定义的得分 $S$。\n\n测试套件：\n给出以下 $6$ 个测试用例的结果。每个测试用例是一个元组，包含（查询序列字符串，模板字符串，偏移量 $k$，惩罚值 $\\lambda$）：\n\n- 测试用例 1：\n  - 查询序列：\"AAPPA\"\n  - 模板：\"CCCHHHHHHCCC\"\n  - 偏移量 $k=3$\n  - 惩罚值 $\\lambda=5$\n- 测试用例 2：\n  - 查询序列：\"PAAAA\"\n  - 模板：\"CCCHHHHHHCCC\"\n  - 偏移量 $k=3$\n  - 惩罚值 $\\lambda=7$\n- 测试用例 3：\n  - 查询序列：\"PP\"\n  - 模板：\"CECECECECE\"\n  - 偏移量 $k=2$\n  - 惩罚值 $\\lambda=11$\n- 测试用例 4：\n  - 查询序列：\"PPP\"\n  - 模板：\"HHCHHHCHHH\"\n  - 偏移量 $k=3$\n  - 惩罚值 $\\lambda=9$\n- 测试用例 5：\n  - 查询序列：\"P\"\n  - 模板：\"HHCCCC\"\n  - 偏移量 $k=0$\n  - 惩罚值 $\\lambda=4$\n- 测试用例 6：\n  - 查询序列：\"APAPAP\"\n  - 模板：\"CCCHHHHCCCC\"\n  - 偏移量 $k=2$\n  - 惩罚值 $\\lambda=4$\n\n最终输出格式：\n你的程序应该生成单行输出，其中包含 6 个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来（例如，\"[result1,result2,result3,result4,result5,result6]\"）。每个结果必须是对应测试用例的得分 $S$ 的整数值，顺序与上面列出的一致。", "solution": "所述问题是有效的。它在科学上基于蛋白质立体化学的原理，在数学上是适定的，并且以客观、明确的方式呈现。这是一个折叠识别（或穿线）能量函数中某个组成部分的简化但正确的表述。我们将进行形式化的求解。\n\n该问题要求计算一个惩罚分数 $S$，该分数是基于将一个查询氨基酸序列比对到一个蛋白质模板结构上而得出的。其建模的基本原理是脯氨酸残基与 $\\alpha$-螺旋内部的结构不相容性。脯氨酸独特的环状侧链中，其侧链与主链的氨基氮原子形成一个环状结构，这施加了严格的构象限制。这些限制使其无法满足维持稳定 $\\alpha$-螺旋氢键模式所需的理想主链二面角（$\\phi \\approx -57^\\circ$, $\\psi \\approx -47^\\circ$）。因此，脯氨酸残基扮演着“螺旋破坏者”的角色，并优先位于螺旋的末端，而不是其稳定核心内部。\n\n评分函数 $S$ 定义为：\n$$\nS \\;=\\; \\lambda \\cdot \\left|\\left\\{\\, j \\;\\middle|\\; \\text{the query residue at index } j \\text{ is \"P\", the aligned template position } k+j \\text{ is \"H\", and that \"H\" position is interior in its helix segment} \\,\\right\\}\\right|\n$$\n其中 $j$ 是查询序列中基于 0 的索引，$k$ 是比对偏移量，$\\lambda$ 是一个正的惩罚权重。\n\n解决方案需要一个两步的算法方法：\n\n1.  **预处理模板以识别内部螺旋位置**：\n    首先，我们必须识别出模板中所有符合“位于 $\\alpha$-螺旋片段内部”条件的位点。一个 $\\alpha$-螺旋片段是 \"H\" 字符的最大连续序列。这样一个片段中的位置 $i$ 如果不位于片段的两端，则其为内部位置。这可以用一个简单的局部条件来表示：一个模板位置 $i$ 是内部螺旋位置，当且仅当索引为 $i-1$、$i$ 和 $i+1$ 的模板字符都是 'H'。这个条件对于任何长度 $L \\le 2$ 的螺旋以及任何长度 $L \\ge 3$ 的螺旋的两个末端位置自然不成立。我们可以预先计算一个与模板字符串 $T$ 等长的布尔数组，称之为 $I_{interior}$。对于模板中的每个位置 $i$（$0 \\le i < |T|$），如果 $1 \\le i < |T|-1$ 且 $T[i-1] = \\text{'H'}$、$T[i] = \\text{'H'}$ 和 $T[i+1] = \\text{'H'}$，我们就将 $I_{interior}[i]$ 设为真；否则，$I_{interior}[i]$ 为假。这个预处理过程需要对模板字符串进行单次遍历。\n\n2.  **评估比对得分**：\n    预处理模板后，我们为给定的查询序列 $Q$、偏移量 $k$ 和惩罚值 $\\lambda$ 计算得分。我们遍历查询序列，索引 $j$ 从 $0$ 到 $|Q|-1$。对于每个残基 $Q[j]$：\n    a. 我们检查该残基是否为脯氨酸，即 $Q[j] = \\text{'P'}$。\n    b. 如果是脯氨酸，我们确定其在模板中比对位置的索引，即 $t_{idx} = k + j$。\n    c. 我们必须确保此索引有效，即 $0 \\le t_{idx} < |T|$。\n    d. 然后我们通过查阅预先计算的数组来检查该比对位置是否对应于一个内部螺旋位置：$I_{interior}[t_{idx}]$。\n    e. 如果所有条件都满足，我们将计数器 $N_p$ 加一。\n\n    遍历完整个查询序列后，最终得分 $S$ 是累积计数 $N_p$ 与惩罚权重 $\\lambda$ 的乘积：$S = \\lambda \\cdot N_p$。\n\n我们现在将此算法应用于每个测试用例。\n\n- **测试用例 1**：$Q$=`\"AAPPA\"`, $T$=`\"CCCHHHHHHCCC\"`, $k=3$, $\\lambda=5$。\n  - 螺旋片段 (`\"HHHHHH\"`) 跨越索引 3 到 8。内部位置是 4, 5, 6, 7。\n  - `j=2`：`Q[2]` 是 'P'。比对到模板索引 $k+j = 3+2=5$。位置 5 是一个内部螺旋位置。惩罚计数变为 1。\n  - `j=3`：`Q[3]` 是 'P'。比对到模板索引 $k+j = 3+3=6$。位置 6 是一个内部螺旋位置。惩罚计数变为 2。\n  - 总计数 $N_p=2$。得分 $S = 5 \\cdot 2 = 10$。\n\n- **测试用例 2**：$Q$=`\"PAAAA\"`, $T$=`\"CCCHHHHHHCCC\"`, $k=3$, $\\lambda=7$。\n  - 内部螺旋位置是 4, 5, 6, 7。\n  - `j=0`：`Q[0]` 是 'P'。比对到模板索引 $k+j = 3+0=3$。位置 3 是螺旋的起始位置，不是内部。\n  - 总计数 $N_p=0$。得分 $S = 7 \\cdot 0 = 0$。\n\n- **测试用例 3**：$Q$=`\"PP\"`, $T$=`\"CECECECECE\"`, $k=2$, $\\lambda=11$。\n  - 模板中没有 'H' 字符。不存在内部螺旋位置。\n  - 总计数 $N_p=0$。得分 $S = 11 \\cdot 0 = 0$。\n\n- **测试用例 4**：$Q$=`\"PPP\"`, $T$=`\"HHCHHHCHHH\"`, $k=3$, $\\lambda=9$。\n  - 模板中有两个长度为 3 的螺旋片段（\"HHH\"），分别从索引 3 和 7 开始。内部位置是索引 4 和索引 8。\n  - `j=0`：`Q[0]` 是 'P'。比对到 $k+j=3$。不是内部。\n  - `j=1`：`Q[1]` 是 'P'。比对到 $k+j=4$。位置 4 是一个内部螺旋位置。惩罚计数变为 1。\n  - `j=2`：`Q[2]` 是 'P'。比对到 $k+j=5$。不是内部。\n  - 总计数 $N_p=1$。得分 $S = 9 \\cdot 1 = 9$。\n\n- **测试用例 5**：$Q$=`\"P\"`, $T$=`\"HHCCCC\"`, $k=0$, $\\lambda=4$。\n  - 螺旋片段 (\"HH\") 的长度为 2。它没有内部位置。\n  - `j=0`：`Q[0]` 是 'P'。比对到 $k+j=0$。不是内部。\n  - 总计数 $N_p=0$。得分 $S = 4 \\cdot 0 = 0$。\n\n- **测试用例 6**：$Q$=`\"APAPAP\"`, $T$=`\"CCCHHHHCCCC\"`, $k=2$, $\\lambda=4$。\n  - 螺旋片段 (\"HHHH\") 跨越索引 3 到 6。内部位置是 4, 5。\n  - `j=1`：`Q[1]` 是 'P'。比对到 $k+j=2+1=3$。不是内部。\n  - `j=3`：`Q[3]` 是 'P'。比对到 $k+j=2+3=5$。位置 5 是一个内部螺旋位置。惩罚计数变为 1。\n  - `j=5`：`Q[5]` 是 'P'。比对到 $k+j=2+5=7$。模板位置 7 是 'C'，不是 'H'。\n  - 总计数 $N_p=1$。得分 $S = 4 \\cdot 1 = 4$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_score(query: str, template: str, k: int, lambda_val: int) -> int:\n    \"\"\"\n    Computes the threading score based on penalties for proline in helix interiors.\n\n    Args:\n        query: The amino acid query sequence.\n        template: The secondary structure template string.\n        k: The alignment offset.\n        lambda_val: The penalty weight.\n\n    Returns:\n        The total score S.\n    \"\"\"\n    len_template = len(template)\n    len_query = len(query)\n\n    # Step 1: Pre-compute the interior helix positions.\n    # A position 'i' is interior to a helix if the template characters at i-1, i, and i+1 are all 'H'.\n    # This implicitly handles helices of length < 3 having no interior.\n    is_interior_helix = [False] * len_template\n    for i in range(1, len_template - 1):\n        if template[i-1] == 'H' and template[i] == 'H' and template[i+1] == 'H':\n            is_interior_helix[i] = True\n\n    # Step 2: Iterate through the alignment and count penalties.\n    penalty_count = 0\n    for j in range(len_query):\n        # The query residue at index j is aligned to the template at k+j.\n        template_idx = k + j\n\n        # We only score positions that are validly aligned within the template.\n        if 0 <= template_idx < len_template:\n            # Condition 1: The query residue is Proline ('P').\n            if query[j] == 'P':\n                # Condition 2: The aligned template position is an interior helix position.\n                if is_interior_helix[template_idx]:\n                    penalty_count += 1\n    \n    # Step 3: Calculate the final score.\n    # The score is the penalty weight multiplied by the count of penalized positions.\n    score = lambda_val * penalty_count\n    return int(score)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the entire test suite and prints the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (query sequence, template string, offset k, penalty lambda)\n        (\"AAPPA\", \"CCCHHHHHHCCC\", 3, 5),\n        (\"PAAAA\", \"CCCHHHHHHCCC\", 3, 7),\n        (\"PP\", \"CECECECECE\", 2, 11),\n        (\"PPP\", \"HHCHHHCHHH\", 3, 9),\n        (\"P\", \"HHCCCC\", 0, 4),\n        (\"APAPAP\", \"CCCHHHHCCCC\", 2, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        query, template, k, lambda_val = case\n        result = calculate_score(query, template, k, lambda_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391554"}, {"introduction": "我们最后的实践练习提出了一个综合性的挑战：使用动态规划设计一个完整的穿线算法。这个练习解决了将序列与一个可能包含缺失数据或链断裂的模板进行比对的真实世界问题，这种情况在实验结构中很常见。许多折叠识别方法的核心是一种序列比对算法，它能将查询序列最佳地映射到模板的结构上。这项练习 [@problem_id:2391490] 要求您实现一个带有自定义、位置依赖的仿射空位罚分方案的动态规划算法，这对于处理碎片化的结构模板至关重要。", "problem": "设计并实现一个程序，该程序给定一个查询氨基酸序列和一个源自蛋白质数据库（PDB）文件、可能包含缺失残基和链断裂的模板，计算在精确定义的计分模型下的最大全局穿线得分。程序必须计算每个测试用例的结果，并按如下规定将它们聚合到单个输出行中。\n\n公式化。设氨基酸字母表为一个有限集，记作 $\\mathcal{A}$。查询序列是一个有限字符串 $Q = q_1 q_2 \\dots q_n$，其中 $q_i \\in \\mathcal{A}$。模板以以下形式给出：一个原始字符串 $T^{\\mathrm{orig}} = t^{\\mathrm{orig}}_1 t^{\\mathrm{orig}}_2 \\dots t^{\\mathrm{orig}}_m$，其中 $t^{\\mathrm{orig}}_j \\in \\mathcal{A}$；一个存在掩码 $U = (u_1, u_2, \\dots, u_m)$，其中 $u_j \\in \\{0,1\\}$，指示位置 $j$ 处的残基是否在结构中被观察到（$u_j = 1$）或缺失（$u_j = 0$）；以及一个链断裂集合 $B \\subseteq \\{1,2,\\dots,m-1\\}$，其中 $j \\in B$ 表示在原始索引的位置 $j$ 和 $j+1$ 之间存在一个共价链断裂。\n\n定义观察到的索引集 $J = \\{ j \\in \\{1,2,\\dots,m\\} : u_j = 1 \\}$，其自然递增顺序为 $j_1 < j_2 < \\dots < j_{m'}$。用于穿线的有效模板序列是 $T = t_1 t_2 \\dots t_{m'}$，其中 $t_\\ell = t^{\\mathrm{orig}}_{j_\\ell}$。在有效模板上定义一个断裂指示符如下：对于每个 $\\ell \\in \\{1,2,\\dots,m'-1\\}$，当且仅当 $j_{\\ell+1} = j_\\ell + 1$ 且 $j_\\ell \\in B$ 时，在 $t_\\ell$ 和 $t_{\\ell+1}$ 之间放置一个断裂。这将 $T$ 划分为由断裂分隔的连续片段。令 $\\mathrm{segstart}(\\ell)$ 为指示位置 $\\ell$ 是 $T$ 中一个片段的起始位置的指示符；根据定义，$\\mathrm{segstart}(1) = 1$，且对于 $\\ell \\ge 2$，如果 $t_{\\ell-1}$ 和 $t_\\ell$ 之间有断裂，则 $\\mathrm{segstart}(\\ell) = 1$，否则 $\\mathrm{segstart}(\\ell) = 0$。\n\n$Q$ 和 $T$ 之间的比对是一种全局比对，它将 $Q$ 中的每个字符和 $T$ 中的每个字符与另一个字符串中的字符（匹配或错配）或一个空位进行配对，并保持顺序。一个比对的总分定义为以下组成部分之和：\n- 替换得分：对于每个比对上的对 $(q_i, t_\\ell)$，加上 $\\sigma(q_i,t_\\ell)$，其中\n  $\n  \\sigma(a,b) =\n  \\begin{cases}\n  +2, & \\text{如果 } a=b,\\\\\n  -1, & \\text{如果 } a\\ne b.\n  \\end{cases}\n  $\n- 插入罚分（模板中的空位，即 $Q$ 中的未配对字符）：对于 $Q$ 中每个长度为 $L \\ge 1$ 的连续未配对字符的最大连续段，加上罚分 $-(o_I + (L-1)e_I)$，其中 $o_I = 3$ 且 $e_I = 1$。\n- 删除罚分（序列中的空位，即 $T$ 中的未配对位置）：考虑在单个片段内，$T$ 中每个连续未配对位置的最大连续段。对于一个从模板位置 $\\ell$ 开始、长度为 $K \\ge 1$ 的连续段，加上罚分 $-(o_D^{\\mathrm{eff}}(\\ell) + (K-1)e_D)$，其中 $e_D = 1$ 且\n  $\n  o_D^{\\mathrm{eff}}(\\ell) =\n  \\begin{cases}\n  0, & \\text{如果 } \\mathrm{segstart}(\\ell) = 1,\\\\\n  3, & \\text{如果 } \\mathrm{segstart}(\\ell) = 0.\n  \\end{cases}\n  $\n  如果一个删除跨越多个片段，它将被分解为多个独立的连续段，每个片段内一个，并且上述罚分规则独立地应用于每个连续段。跨链断裂的替换得分没有其他修改。原始模板中所有缺失的残基（$u_j = 0$）都从 $T$ 中排除，并且不计入得分或罚分。\n\n目标。对于每个测试用例，计算在遵循上述规则的情况下，$Q$ 与有效模板 $T$ 之间所有全局比对的最大可能总分。\n\n测试套件。使用以下六个测试用例。在每个用例中，字母表为大写英文字母，数据如下：\n- 情况 1：$Q = \\text{\"ACDE\"}$；$T^{\\mathrm{orig}} = \\text{\"ACDE\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\varnothing$。\n- 情况 2：$Q = \\text{\"ADE\"}$；$T^{\\mathrm{orig}} = \\text{\"ACDE\"}$；$U = [\\,1,0,1,1\\,]$；$B = \\varnothing$。\n- 情况 3：$Q = \\text{\"ABD\"}$；$T^{\\mathrm{orig}} = \\text{\"ABCD\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\{\\,2\\,\\}$。\n- 情况 4：$Q = \\text{\"AAA\"}$；$T^{\\mathrm{orig}} = \\text{\"TTTT\"}$；$U = [\\,0,0,0,0\\,]$；$B = \\varnothing$。\n- 情况 5：$Q = \\text{\"AD\"}$；$T^{\\mathrm{orig}} = \\text{\"ABCD\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\varnothing$。\n- 情况 6：$Q = \\text{\"AD\"}$；$T^{\\mathrm{orig}} = \\text{\"ABCD\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\{\\,1\\,\\}$。\n\n答案类型。对于每个测试用例，答案是等于最大得分的单个整数。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，按情况 1 到 6 的顺序排列，不含空格，例如 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$。", "solution": "该问题要求计算一个查询氨基酸序列与一个结构模板的最大全局穿线得分。该模板可能包含缺失的残基和链断裂。这是带有仿射空位罚分的经典全局序列比对问题的一个变体，可以使用动态规划高效地解决。特定的计分模型为删除罚分引入了一条新颖的规则，该规则依赖于从链断裂派生出的模板分段结构。\n\n解决方案分为两个主要阶段：首先，预处理模板以派生其有效序列和片段信息；其次，应用一个自定义的动态规划算法来找到最优比对得分。\n\n**1. 模板预处理**\n\n设查询序列为 $Q$，长度为 $n$；原始模板序列为 $T^{\\mathrm{orig}}$，长度为 $m$。\n首先，我们构建有效模板序列 $T$。该序列仅由结构中存在的残基组成，如存在掩码 $U=(u_1, \\dots, u_m)$ 所示。\n原始模板中观察到的残基的索引集为 $J = \\{j \\in \\{1,\\dots,m\\} : u_j=1\\}$。设这些索引按递增顺序为 $j_1 < j_2 < \\dots < j_{m'}$。\n有效模板 $T$ 则是长度为 $m'$ 的字符串 $t_1 t_2 \\dots t_{m'}$，其中 $t_\\ell = t^{\\mathrm{orig}}_{j_\\ell}$。\n\n接下来，我们在 $T$ 内部识别片段边界。如果有效模板位置 $t_\\ell$ 和 $t_{\\ell+1}$ 对应的原始索引是相邻的（$j_{\\ell+1} = j_\\ell + 1$），并且在该原始位置指定了断裂（$j_\\ell \\in B$），那么我们定义在它们之间存在一个链断裂。\n我们定义一个长度为 $m'$ 的指示符数组 $\\mathrm{segstart}$。对于每个位置 $\\ell \\in \\{1, \\dots, m'\\}$，如果 $t_\\ell$ 是一个片段的第一个残基，则 $\\mathrm{segstart}(\\ell) = 1$，否则为 $0$。根据定义，$\\mathrm{segstart}(1)=1$。对于 $\\ell > 1$，如果 $t_{\\ell-1}$ 和 $t_\\ell$ 之间有断裂，则 $\\mathrm{segstart}(\\ell)=1$。\n\n这个片段信息对于计算删除罚分至关重要。在 $T$ 中从位置 $\\ell$ 开始的删除的开口罚分，记作 $o_D^{\\mathrm{eff}}(\\ell)$，定义如下：\n$$\no_D^{\\mathrm{eff}}(\\ell) =\n\\begin{cases}\n0, & \\text{如果 } \\mathrm{segstart}(\\ell) = 1, \\\\\n3, & \\text{如果 } \\mathrm{segstart}(\\ell) = 0.\n\\end{cases}\n$$\n删除的延伸罚分 $e_D$ 是一个常数 $1$。\n\n**2. 动态规划公式化**\n\n该问题可以使用类似于 Gotoh 算法（用于处理仿射空位罚分）的动态规划方法解决。我们使用三个大小为 $(n+1) \\times (m'+1)$ 的矩阵（或表），分别为 $M$、$I$ 和 $D$。这些表中每个条目 $(i, j)$ 存储了前缀 $Q[1..i]$ 和 $T[1..j]$ 在不同结尾条件下的最优比对得分：\n- $M(i,j)$: $q_i$ 与 $t_j$ 比对（匹配或错配）的比对得分。\n- $I(i,j)$: $q_i$ 与一个空位比对（向 $T$ 中插入）的比对得分。\n- $D(i,j)$: $t_j$ 与一个空位比对（从 $T$ 中删除）的比对得分。\n\n计分常数为：替换得分 $\\sigma(a,b)$ 在匹配时为 $+2$，错配时为 $-1$；插入罚分 $o_I=3, e_I=1$；以及删除罚分 $e_D=1$ 与位置依赖的 $o_D^{\\mathrm{eff}}(\\ell)$。\n\n**初始化：**\n假设全局比对从空前缀开始，对表进行初始化。\n- $M(0,0) = 0$。所有表中所有其他条目初始化为 $-\\infty$。\n- 第一列（$j=0$）：这对应于将前缀 $Q[1..i]$ 与空模板进行比对，即连续 $i$ 次插入。\n  $$ I(i,0) = -(o_I + (i-1)e_I) \\quad \\text{对于 } i \\ge 1. $$\n- 第一行（$i=0$）：这对应于将前缀 $T[1..j]$ 与空查询进行比对，即一系列删除。得分根据片段结构进行累积。\n  $$ D(0,j) = D(0,j-1) - \\begin{cases} o_D^{\\mathrm{eff}}(j) & \\text{如果 } \\mathrm{segstart}(j)=1 \\\\ e_D & \\text{如果 } \\mathrm{segstart}(j)=0 \\end{cases} \\quad \\text{对于 } j \\ge 1, $$\n  以 $D(0,0)=0$ 为基础。\n\n**递推关系：**\n对于 $i$ 从 $1$ 到 $n$ 和 $j$ 从 $1$ 到 $m'$，我们填充这些表：\n- **匹配/错配矩阵 $M$**：以 $(q_i, t_j)$ 结尾的比对必须跟在对前缀 $Q[1..i-1]$ 和 $T[1..j-1]$ 的比对之后。\n  $$ M(i,j) = \\sigma(q_i, t_j) + \\max\\{M(i-1,j-1), I(i-1,j-1), D(i-1,j-1)\\} $$\n- **插入矩阵 $I$**：以在 $q_i$ 处的插入结尾的比对可以开始一个新的插入连续段，也可以扩展一个现有的。\n  $$ I(i,j) = \\max \\begin{cases} M(i-1,j) - o_I, \\\\ D(i-1,j) - o_I, \\\\ I(i-1,j) - e_I \\end{cases} $$\n- **删除矩阵 $D$**：这是自定义部分。对 $t_j$ 的删除可以开始一个新的连续段或扩展一个，但只有当 $t_j$ 不在片段的开头时，才允许从 $D(i,j-1)$ 到 $D(i,j)$ 的扩展。其递推关系如下：\n  - 如果 $\\mathrm{segstart}(j)=1$（片段起始）：\n    $$ D(i,j) = \\max\\{M(i,j-1), I(i,j-1)\\} - o_D^{\\mathrm{eff}}(j) $$\n  - 如果 $\\mathrm{segstart}(j)=0$（片段内部）：\n    $$ D(i,j) = \\max \\begin{cases} \\max\\{M(i,j-1), I(i,j-1)\\} - o_D^{\\mathrm{eff}}(j) \\\\ D(i,j-1) - e_D \\end{cases} $$\n\n**最终得分：**\n填充所有表后，完整序列 $Q$ 和 $T$ 的最大全局比对得分是最后一个单元格 $(n, m')$ 中的最大值。\n$$ \\text{得分} = \\max\\{M(n,m'), I(n,m'), D(n,m')\\} $$\n这种系统性的计算确保我们能根据指定的规则，在所有可能的全局比对中找到最大得分。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the protein threading problem for all test cases.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    SIGMA_MATCH = 2\n    SIGMA_MISMATCH = -1\n    O_I = 3\n    E_I = 1\n    O_D = 3\n    E_D = 1\n    \n    def _solve_case(Q, T_orig, U, B):\n        \"\"\"\n        Computes the maximum global threading score for a single test case.\n        \"\"\"\n        n = len(Q)\n\n        # Step 1: Construct the effective template T and associated data.\n        T_list = []\n        orig_indices = []\n        for j, char in enumerate(T_orig):\n            if U[j] == 1:\n                T_list.append(char)\n                # Store original indices (1-based) for break checking.\n                orig_indices.append(j + 1)\n        \n        T = \"\".join(T_list)\n        m_prime = len(T)\n\n        # Handle edge case of an empty effective template.\n        if m_prime == 0:\n            if n == 0:\n                return 0\n            # If the template is empty, the score is the penalty for inserting the entire query.\n            return -(O_I + (n - 1) * E_I)\n\n        # Step 2: Compute segstart and o_D_eff arrays for the effective template.\n        segstart = np.zeros(m_prime, dtype=int)\n        if m_prime > 0:\n            segstart[0] = 1\n        \n        # Convert B to a set for efficient lookup.\n        B_set = set(B)\n        for l in range(m_prime - 1):\n            j_l = orig_indices[l]\n            j_l_plus_1 = orig_indices[l+1]\n            if j_l_plus_1 == j_l + 1 and j_l in B_set:\n                segstart[l + 1] = 1\n                \n        o_D_eff = np.full(m_prime, O_D)\n        for l in range(m_prime):\n            if segstart[l] == 1:\n                o_D_eff[l] = 0\n\n        # Step 3: Initialize DP tables M, I, D.\n        M = np.full((n + 1, m_prime + 1), -np.inf)\n        I = np.full((n + 1, m_prime + 1), -np.inf)\n        D = np.full((n + 1, m_prime + 1), -np.inf)\n\n        M[0, 0] = 0\n\n        # Step 4: Initialize the first row and column of the tables.\n        \n        # First column (aligning Q prefix to gaps).\n        if n > 0:\n          I[1, 0] = -O_I\n          for i in range(2, n + 1):\n              I[i, 0] = I[i - 1, 0] - E_I\n\n        # First row (aligning T prefix to gaps).\n        if m_prime > 0:\n            D[0, 1] = -o_D_eff[0]\n            for j in range(2, m_prime + 1):\n                if segstart[j - 1] == 1: # New segment, new deletion run.\n                    D[0, j] = D[0, j - 1] - o_D_eff[j - 1]\n                else: # Extend deletion run within the same segment.\n                    D[0, j] = D[0, j - 1] - E_D\n\n        # Step 5: Fill DP tables using recurrences.\n        for i in range(1, n + 1):\n            for j in range(1, m_prime + 1):\n                # i,j in DP table correspond to Q[i-1], T[j-1].\n                \n                # M(i,j): Match/Mismatch state\n                subst_score = SIGMA_MATCH if Q[i - 1] == T[j - 1] else SIGMA_MISMATCH\n                prev_score = max(M[i - 1, j - 1], I[i - 1, j - 1], D[i - 1, j - 1])\n                if prev_score > -np.inf:\n                    M[i, j] = subst_score + prev_score\n\n                # I(i,j): Insertion state (gap in T)\n                open_ins_score = max(M[i - 1, j], D[i - 1, j]) - O_I\n                extend_ins_score = I[i - 1, j] - E_I\n                I[i, j] = max(open_ins_score, extend_ins_score)\n\n                # D(i,j): Deletion state (gap in Q)\n                open_del_penalty = o_D_eff[j-1]\n                open_del_score = max(M[i, j-1], I[i, j-1]) - open_del_penalty\n\n                if segstart[j-1] == 1: # Cannot extend deletion across a segment break.\n                    D[i,j] = open_del_score\n                else:\n                    extend_del_score = D[i, j-1] - E_D\n                    D[i,j] = max(open_del_score, extend_del_score)\n\n        # Step 6: The final score is the max of the three states at the bottom-right corner.\n        final_score = max(M[n, m_prime], I[n, m_prime], D[n, m_prime])\n        \n        return int(round(final_score))\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"Q\": \"ACDE\", \"T_orig\": \"ACDE\", \"U\": [1, 1, 1, 1], \"B\": []},\n        {\"Q\": \"ADE\", \"T_orig\": \"ACDE\", \"U\": [1, 0, 1, 1], \"B\": []},\n        {\"Q\": \"ABD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": [2]},\n        {\"Q\": \"AAA\", \"T_orig\": \"TTTT\", \"U\": [0, 0, 0, 0], \"B\": []},\n        {\"Q\": \"AD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": []},\n        {\"Q\": \"AD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": [1]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        score = _solve_case(**case)\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391490"}]}