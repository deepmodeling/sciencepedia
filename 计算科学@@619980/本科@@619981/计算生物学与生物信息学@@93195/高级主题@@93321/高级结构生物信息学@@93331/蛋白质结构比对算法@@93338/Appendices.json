{"hands_on_practices": [{"introduction": "结构比对算法是强大的工具，但它们真正“看到”的相似性是什么？第一个练习是一个思想实验，旨在探究结构比较的基本原则。通过在这个假设场景中比对两种结构完全不同的蛋白质——一个β-桶状蛋白和一个全α螺旋蛋白——你将探索为何深层的结构相似性比大小或整体形状上的表面相似性更有意义，以及像 DALI 和 CE 这样的算法是如何被设计来检测这种相似性的 [@problem_id:2421900]。", "problem": "给定两个通过实验确定的、长度相当（即残基数量大致相同）、折叠良好且结构完整的蛋白质结构。蛋白质 X 是一个跨膜 $\\beta$-桶状膜蛋白，蛋白质 Y 是一个可溶的全-$\\alpha$ 螺旋蛋白。您尝试使用距离矩阵比对（DALI）和组合扩展（CE）来比对 X 和 Y。DALI 通过比较三维（$3$D）空间中分子内的残基-残基距离模式来识别相似的空间排列，而 CE 则通过在保持片段序列顺序的几何叠加下，延伸短的、局部相似的片段对来构建比对。两种方法都会报告一个基于叠加核心的长度和几何质量的统计显著性度量。以下哪个陈述最能描述这些比对的预期结果？\n\nA. DALI 和 CE 都可能会返回一个统计上不显著的匹配，其特征是只有短的局域比对片段、高的均方根偏差（RMSD）和低的显著性分数，因为 $\\beta$-桶和全-$\\alpha$ 螺旋蛋白的整体折叠和接触模式有着根本的不同。\n\nB. DALI 会因为蛋白质长度相似而自信地比对大多数残基，从而产生高的显著性分数，而 CE 会失败，因为它需要匹配的二级结构类型。\n\nC. CE 会因为两种蛋白质都很紧凑且体积相似而产生显著的比对，而 DALI 不会，因为它忽略了绝对几何形状，仅使用序列信息。\n\nD. 两种方法都会产生显著的比对，因为 $\\beta$-桶和 $\\alpha$-螺旋束的圆柱形堆积使其残基-残基距离矩阵在全局水平上实际上是等效的。", "solution": "首先必须对问题陈述进行严格验证。\n\n**步骤 1：提取已知条件**\n- 两个蛋白质结构，标记为 $X$ 和 $Y$，是通过实验确定的、折叠良好且结构完整的。\n- 它们的长度相当（残基数量大致相同）。\n- 蛋白质 $X$ 是一个跨膜 $\\beta$-桶状膜蛋白。\n- 蛋白质 $Y$ 是一个可溶的全-$\\alpha$ 螺旋蛋白。\n- 比对算法：距离矩阵比对（DALI）和组合扩展（CE）。\n- DALI 机制：比较三维（$3$D）空间中的分子内残基-残基距离模式。\n- CE 机制：通过延伸短的、局部相似的片段对来构建比对，同时保持序列顺序。\n- 算法输出：基于比对长度和几何质量（例如，均方根偏差，RMSD）的统计显著性度量。\n- 问题：预测使用 DALI 和 CE 比对 $X$ 和 $Y$ 的结果。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。所描述的结构——一个跨膜 $\\beta$-桶和一个可溶的全-$\\alpha$ 螺旋蛋白——代表了两种截然不同且已被公认的主要蛋白质折叠类别。DALI 和 CE 这两种算法是计算结构生物学中的基础方法，其简化描述在本质上是准确的。该问题基于蛋白质结构和比对理论的既定原则，建立了一个清晰、可检验的思想实验。其中没有违反物理定律、逻辑矛盾或含糊不清之处。该问题是适定且客观的。\n\n**步骤 3：结论与行动**\n问题陈述有效。我将继续推导解决方案。\n\n**推导**\n\n这个问题的核心在于理解两种指定蛋白质结构之间的根本结构差异，以及 DALI 和 CE 算法如何解释这些差异。\n\n1.  **结构差异性：**\n    - 蛋白质 $X$ 是一个 $\\beta$-桶，由排列成圆柱形片层的 $\\beta$-折叠链组成。其结构通过相邻链之间规则、广泛的主链氢键网络来稳定。在局部，多肽链处于伸展构象。由此产生的分子内距离矩阵具有特定的模式：相邻链上 C$_\\alpha$ 原子之间的距离很短，以及由桶状几何结构决定的长程、周期性相关性。\n    - 蛋白质 $Y$ 是一个全-$\\alpha$ 蛋白，由 $\\alpha$-螺旋堆积而成。其结构主要通过堆积螺旋表面侧链之间的疏水相互作用来稳定。在局部，多肽链处于紧密的螺旋构象（每圈 $3.6$ 个残基）。该蛋白质的距离矩阵反映了螺旋的紧密堆积，其特征是在相互作用的螺旋面上残基之间的距离很短。\n    - 结论：局部几何（伸展的 $\\beta$-链 vs. 卷曲的 $\\alpha$-螺旋）和全局拓扑（氢键连接的片层 vs. 疏水堆积的螺旋）在根本上是不可调和地不同的。整体形状上的表面相似性（例如，两者可能都是大致的圆柱形）并不意味着结构同源性。\n\n2.  **算法行为：**\n    - **DALI：** 该算法比较两种蛋白质的距离矩阵。对于一个有 $N$ 个残基的蛋白质，其距离矩阵 $D$ 是一个 $N \\times N$ 矩阵，其中元素 $D_{ij}$ 是残基 $i$ 和残基 $j$（通常是它们的 C$_\\alpha$ 原子）之间的欧几里得距离。DALI 旨在寻找两个距离矩阵的行/列子集之间的最大相似映射。鉴于 $\\beta$-桶和全-$\\alpha$ 束在内部堆积和二级结构上的巨大差异，它们各自的距离矩阵不会共享任何显著的大尺度模式。任何识别出的相似性都将是微小的、偶然的，并且在结构上没有意义。这将导致非常短的比对、少数叠加原子的均方根偏差（RMSD）很高，因此分数很低且统计上不显著（例如，Z-score 接近或低于 $2.0$）。\n    - **CE：** 该算法通过寻找“比对片段对”（AFPs）来运作，这些 AFPs 是来自每个蛋白质的、具有相似局部几何形状的短的、序列上连续的片段对（通常长度为 $8$）。相似性是通过能否以低 RMSD 叠加这些片段来衡量的。从几何上看，将一个伸展的 $\\beta$-链片段与一个卷曲的 $\\alpha$-螺旋片段叠加并获得低 RMSD 是不可能的。它们的主链原子坐标完全不同。因此，CE 算法将在其初始步骤失败；它将找不到足够数量的种子 AFPs 来构建更长、连贯的比对路径。最终的比对（如果能报告的话）将是微不足道的，可能只包含非结构化环区中的几个残基，并且在统计上是不显著的。\n\n总之，这两种算法都是为了检测三维折叠结构的相似性而设计的。由于 $X$ 和 $Y$ 的结构截然不同，预计这两种方法都会失败，并报告缺乏显著的结构相似性。\n\n**逐项分析**\n\nA. DALI 和 CE 都可能会返回一个统计上不显著的匹配，其特征是只有短的局域比对片段、高的均方根偏差（RMSD）和低的显著性分数，因为 $\\beta$-桶和全-$\\alpha$ 螺旋蛋白的整体折叠和接触模式有着根本的不同。\n- **分析：** 该陈述与上述推导完全一致。它正确地指出两种算法都会失败，正确地描述了不良比对的特征（长度短、RMSD 高、分数低），并给出了正确的根本原因：折叠和接触模式的根本不同。\n- **结论：** **正确**。\n\nB. DALI 会因为蛋白质长度相似而自信地比对大多数残基，从而产生高的显著性分数，而 CE 会失败，因为它需要匹配的二级结构类型。\n- **分析：** 这是不正确的。DALI 基于内部距离模式的相似性进行比对，而不是蛋白质长度。长度相似并不意味着结构相似。DALI 会成功的这个前提是错误的。虽然 CE 确实会失败，但该选项的主要论断是错误的。\n- **结论：** **不正确**。\n\nC. CE 会因为两种蛋白质都很紧凑且体积相似而产生显著的比对，而 DALI 不会，因为它忽略了绝对几何形状，仅使用序列信息。\n- **分析：** 这在两方面都是不正确的。首先，CE 不会产生显著的比对；它的操作基于局部几何形状，而这两种蛋白质的局部几何形状不同，而不是基于紧凑性或体积等宏观特征。其次，对 DALI 的描述完全是错误的。DALI是一种基于结构而非序列的比对方法。它使用的距离矩阵是三维几何的直接表示。\n- **结论：** **不正确**。\n\nD. 两种方法都会产生显著的比对，因为 $\\beta$-桶和 $\\alpha$-螺旋束的圆柱形堆积使其残基-残基距离矩阵在全局水平上实际上是等效的。\n- **分析：** 这是不正确的。由于粗略的全局形状相似性而认为距离矩阵“实际上是等效的”这一前提是错误的。由 $\\beta$-链氢键与 $\\alpha$-螺旋堆积所定义的内部接触模式大相径庭，而算法分析的正是这些详细的模式。全局轮廓的表面相似性不足以产生显著的比对。\n- **结论：** **不正确**。", "answer": "$$\\boxed{A}$$", "id": "2421900"}, {"introduction": "在确定了算法寻找的“目标”之后，我们现在深入研究它们“如何”寻找。下一个练习提出了一个引人入胜的谜题：将一个蛋白质与其自身的镜像（或称对映异构体）进行比对。这个假设性的场景是一个强大的诊断工具，它揭示了不同算法哲学之间的关键区别。你将发现为什么像 DALI 这样基于距离矩阵的方法会认为这对结构是相同的，而像 CE 这样基于坐标叠加的方法却会认为毫无相似性，从而突显出手性（chirality）在结构比对中的关键作用 [@problem_id:2421915]。", "problem": "给定一个蛋白质结构，其表示为一组三维原子坐标 $\\{ \\mathbf{x}_i \\}_{i=1}^{N}$，以及它的对映异构体（镜像）。该对映异构体通过对所有坐标进行镜像反射得到，即 $\\mathbf{x}'_i = \\mathbf{M}\\,\\mathbf{x}_i$，其中 $\\mathbf{M}$ 是一个正交矩阵，满足 $\\mathbf{M}^\\top \\mathbf{M} = \\mathbf{I}$ 且 $\\det(\\mathbf{M}) = -1$。考虑使用两种广泛应用的结构比对算法——距离矩阵比对（DALI）和组合延伸（CE），将原始结构与其镜像进行比对。假设在标准实现中，坐标空间中的刚体叠合仅限于正常旋转和平移，这意味着用于叠合的变换包含一个正交旋转 $\\mathbf{R}$（满足 $\\det(\\mathbf{R}) = +1$）和一个平移 $\\mathbf{t}$，并且在叠合过程中不允许进行镜像反射。同时假设 DALI 的评分主要基于分子内距离模式的相似性，而 CE 的评分则由已比对片段对的坐标叠合驱动，这些片段对被延伸成一条全局路径。\n\n在这些假设下，当将蛋白质与其自身的对映异构体进行比对时，您预期会得到什么样的比对分数？哪个陈述最能描述这一情况？\n\nA. DALI 和 CE 都会给出接近最高的相似性分数，因为任何刚性运动（包括镜像反射）都保持所有配对距离，因此两种方法都对手性不敏感。\n\nB. DALI 会给出与自身比对相当的高分，而 CE 会给出低分，因为 DALI 比较的是对镜像反射不变的分子内距离矩阵，而 CE 需要一个正常旋转来叠合坐标，无法解决手性反转问题。\n\nC. DALI 会给出低分，而 CE 会给出高分，因为 DALI 在其基于距离的评分中会惩罚手性反转，而 CE 仅依赖于对镜像反射不变的配对距离。\n\nD. DALI 和 CE 都会给出低分，因为在它们的标准评分模型下，手性差异阻碍了任何有意义的几何匹配。", "solution": "首先应验证问题陈述的科学合理性、一致性和完整性。\n\n**步骤 1：提取已知条件**\n- 原始蛋白质结构坐标：三维空间中的 $\\{ \\mathbf{x}_i \\}_{i=1}^{N}$。\n- 对映异构体（镜像）坐标：$\\{ \\mathbf{x}'_i \\}_{i=1}^{N}$，其中 $\\mathbf{x}'_i = \\mathbf{M}\\,\\mathbf{x}_i$。\n- 镜像反射矩阵 $\\mathbf{M}$：一个正交矩阵，满足 $\\mathbf{M}^\\top \\mathbf{M} = \\mathbf{I}$ 且行列式为 $\\det(\\mathbf{M}) = -1$。\n- 比对算法：距离矩阵比对（DALI）和组合延伸（CE）。\n- 叠合约束：用于叠合的变换是由正常旋转 $\\mathbf{R}$（其中 $\\det(\\mathbf{R}) = +1$）和平移 $\\mathbf{t}$ 组成的刚体运动。在叠合步骤中不允许进行镜像反射。\n- DALI 评分原则：主要基于分子内距离模式的相似性。\n- CE 评分原则：由已比对的片段对（AFPs）的坐标叠合驱动，这些片段对被延伸成一条全局比对路径。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题陈述具有科学依据。蛋白质坐标、对映异构体、正常与非正常旋转（$\\det(\\mathbf{R}) = +1$ vs $\\det(\\mathbf{M}) = -1$）以及 DALI 和 CE 算法的基本工作原理等概念的描述是正确的，并且是计算结构生物学领域的标准知识。该问题是适定的，基于一组自洽的前提提出了一个清晰的问题。它客观且避免了歧义。所有推导逻辑结论所需的信息都已提供。\n\n**步骤 3：结论与行动**\n问题陈述有效。我将继续推导解决方案。\n\n**推导过程**\n\n核心任务是预测 DALI 和 CE 在将蛋白质结构与其对映异构体进行比对时的比对分数。关键在于分析每种算法的基本操作如何与一个物体及其镜像之间的几何关系相互作用。\n\n**DALI 的分析**\n根据描述，DALI 算法的评分基于分子内距离模式的相似性。这意味着它比较第一个蛋白质的距离矩阵和第二个蛋白质的距离矩阵。\n设原始结构为 $A$，其原子坐标为 $\\{ \\mathbf{x}_i \\}$。结构 $A$ 中任意两个原子 $i$ 和 $j$ 之间的距离平方由下式给出：\n$$ d_{ij}^2 = \\| \\mathbf{x}_i - \\mathbf{x}_j \\|^2 $$\n设对映异构体结构为 $B$，其原子坐标为 $\\{ \\mathbf{x}'_i \\}$，其中 $\\mathbf{x}'_i = \\mathbf{M}\\,\\mathbf{x}_i$。结构 $B$ 中相应原子 $i$ 和 $j$ 之间的距离平方为：\n$$ (d'_{ij})^2 = \\| \\mathbf{x}'_i - \\mathbf{x}'_j \\|^2 = \\| \\mathbf{M}\\,\\mathbf{x}_i - \\mathbf{M}\\,\\mathbf{x}_j \\|^2 $$\n利用矩阵乘法的分配律，我们得到：\n$$ (d'_{ij})^2 = \\| \\mathbf{M}(\\mathbf{x}_i - \\mathbf{x}_j) \\|^2 $$\n任何正交矩阵 $\\mathbf{M}$（包括旋转和镜像反射）的一个基本性质是它保持向量的欧几里得范数。这可以证明如下：\n$$ \\| \\mathbf{M}\\mathbf{v} \\|^2 = (\\mathbf{M}\\mathbf{v})^\\top (\\mathbf{M}\\mathbf{v}) = \\mathbf{v}^\\top \\mathbf{M}^\\top \\mathbf{M} \\mathbf{v} = \\mathbf{v}^\\top \\mathbf{I} \\mathbf{v} = \\mathbf{v}^\\top \\mathbf{v} = \\| \\mathbf{v} \\|^2 $$\n将此性质应用于我们的距离计算：\n$$ (d'_{ij})^2 = \\| \\mathbf{x}_i - \\mathbf{x}_j \\|^2 = d_{ij}^2 $$\n这证明了对于所有原子对 $(i,j)$，对映异构体中的距离 $d'_{ij}$ 与原始结构中的距离 $d_{ij}$ 完全相同。因此，对映异构体的分子内距离矩阵与原始结构的距离矩阵是相同的。由于 DALI 的分数是基于比较这些距离矩阵得出的，它将找到一个完美的匹配。最终得到的分数将是最高的，与自身比对得到的分数相当。\n\n**CE 的分析**\n根据描述，CE 算法由坐标叠合驱动，通过寻找一个刚体变换（正常旋转 $\\mathbf{R}$，平移 $\\mathbf{t}$）来最小化比对原子间的均方根偏差（RMSD）。问题明确指出，只允许行列式为 $\\det(\\mathbf{R}) = +1$ 的正常旋转。\n一个物体与其不可叠合的镜像被称为手性的。根据定义，一个手性物体不能仅通过正常旋转和平移就与其镜像重合。\n在数学上，我们试图找到一个变换 $(\\mathbf{R}, \\mathbf{t})$ 且 $\\det(\\mathbf{R})=+1$，使得 $\\mathbf{R}\\mathbf{x}'_i + \\mathbf{t}$ 尽可能接近 $\\mathbf{x}_i$。\n代入 $\\mathbf{x}'_i = \\mathbf{M}\\,\\mathbf{x}_i$，我们试图找到 $(\\mathbf{R}, \\mathbf{t})$ 使得：\n$$ \\mathbf{x}_i \\approx \\mathbf{R}(\\mathbf{M}\\,\\mathbf{x}_i) + \\mathbf{t} $$\n对于一个好的全局比对，平移分量对于方向部分可以忽略不计，从而得到条件 $\\mathbf{I} \\approx \\mathbf{R}\\mathbf{M}$。这意味着 $\\mathbf{R} \\approx \\mathbf{M}^{-1}$。\n让我们检查一下行列式。\n$$ \\det(\\mathbf{R}\\mathbf{M}) = \\det(\\mathbf{R}) \\det(\\mathbf{M}) $$\n根据问题陈述，$\\det(\\mathbf{R})=+1$（正常旋转）并且 $\\det(\\mathbf{M})=-1$（镜像反射，一种非正常旋转）。\n$$ \\det(\\mathbf{R}\\mathbf{M}) = (+1) \\times (-1) = -1 $$\n然而，为了使叠合成功，我们需要 $\\mathbf{R}\\mathbf{M} \\approx \\mathbf{I}$，这就要求 $\\det(\\mathbf{R}\\mathbf{M}) \\approx \\det(\\mathbf{I}) = +1$。\n在 $-1$ 和 $+1$ 之间存在一个根本性的矛盾。从数学上讲，不可能找到一个正常旋转 $\\mathbf{R}$ 来抵消镜像反射 $\\mathbf{M}$ 的效果。因此，CE 将无法找到坐标集的全局叠合。它找到的任何比对都将局限于非常小的、非手性的片段，或者会有一个非常高的 RMSD。无论哪种情况，CE 的分数都会非常低，表明没有显著的结构相似性。\n\n**结论**\n- DALI 将报告一个高的相似性分数，因为它操作的是距离矩阵，而距离矩阵对镜像反射是不变的。\n- CE 将报告一个差的相似性分数，因为它尝试使用仅包含正常旋转的直接坐标叠合，而这无法调和结构与其对映异构体之间的手性差异。\n\n**逐项分析**\n\n**A. DALI 和 CE 都会给出接近最高的相似性分数，因为任何刚性运动（包括镜像反射）都保持所有配对距离，因此两种方法都对手性不敏感。**\n这个陈述是错误的。虽然“镜像反射保持所有配对距离”这个前提是正确的，但“两种方法都对手性不敏感”的结论是错误的。CE 的分数关键性地依赖于使用正常旋转来叠合坐标的能力，而这对手性是敏感的。\n\n**B. DALI 会给出与自身比对相当的高分，而 CE 会给出低分，因为 DALI 比较的是对镜像反射不变的分子内距离矩阵，而 CE 需要一个正常旋转来叠合坐标，无法解决手性反转问题。**\n这个陈述是正确的。它精确地反映了推导出的结论。DALI 基于距离的方法对手性不敏感，导致高分。CE 的坐标叠合方法在正常旋转的约束下无法克服手性差异，导致低分。\n\n**C. DALI 会给出低分，而 CE 会给出高分，因为 DALI 在其基于距离的评分中会惩罚手性反转，而 CE 仅依赖于对镜像反射不变的配对距离。**\n这个陈述是错误的。它颠倒了两种算法的作用和机制。DALI 看不到手性，因此也无法惩罚手性。CE 并非仅依赖配对距离，它依赖于直接的坐标叠合。\n\n**D. DALI 和 CE 都会给出低分，因为在它们的标准评分模型下，手性差异阻碍了任何有意义的几何匹配。**\n这个陈述是错误的。它正确地指出了 CE 面临的问题（“有意义的几何匹配”被阻止了），但错误地将同样的结论应用于 DALI。DALI 的“匹配”是在距离空间中进行的，而不是坐标空间，因此不受手性差异的影响。", "answer": "$$\\boxed{B}$$", "id": "2421915"}, {"introduction": "最后的这个实践将你从概念性的谜题引向动手实践的编程，让你能够将所学到的原理转化为代码。你将构建简化的评分函数，以模拟 DALI 独立于序列顺序的距离比较核心逻辑，以及 CE 依赖于序列顺序的几何比较。通过将你的代码应用于一个假设的“打乱顺序”的蛋白质链，你将具体展示这两种方法为何以及如何在结构相似性上得出截然不同的结论，从而巩固你对它们算法细微差异的理解 [@problem_id:2421910]。", "problem": "你的任务是构建并评估一对最小的三维点序列，该序列对模拟蛋白质骨架的位置，以对比结构生物信息学中广泛使用的两种结构相似性概念：以距离矩阵比对（DALI）为代表的距离矩阵概念，以及以组合延伸（CE）为代表的几何与顺序概念。目标是将这些概念形式化为作用于有序点集上的精确、纯数学泛函，并展示一个距离矩阵相似性高而几何与顺序相似性低的案例。\n\n形式上，设一个蛋白质构象由$\\mathbb{R}^3$中的一个包含$n$个点的有序列表表示：$X = (x_1,\\dots,x_n)$和$Y = (y_1,\\dots,y_n)$，其中$x_i,y_i \\in \\mathbb{R}^3$。你将评估$X$和$Y$之间的两个相似性得分：\n\n1. 一个基于距离矩阵的相似性得分$S_D$，该得分在指定的双射$f:\\{1,\\dots,n\\}\\to\\{1,\\dots,n\\}$下计算，代表不一定保持顺序的残基到残基的对应关系。定义如下：\n$$\nm = \\frac{n(n-1)}{2},\\quad\nR = \\sqrt{\\frac{1}{m}\\sum_{1\\le i<j\\le n}\\left(\\lVert x_i - x_j\\rVert_2 - \\lVert y_{f(i)} - y_{f(j)}\\rVert_2\\right)^2},\\quad\nS_D = \\frac{1}{1+R}.\n$$\n更大的$S_D$值表示在对应关系$f$下，整套链内距离具有更好的一致性。\n\n2. 一个保持几何与顺序的相似性得分$S_C$，它在恒等对应关系下（即，$X$中的索引$i$对应于$Y$中的索引$i$）比较连续的键矢量，以反映序列路径的一致性。为$i=1,\\dots,n-1$定义键矢量如下：\n$$\nv_i = x_{i+1}-x_i,\\qquad w_i = y_{i+1}-y_i,\n$$\n以及平均余弦相似度：\n$$\nS_C = \\frac{1}{n-1}\\sum_{i=1}^{n-1}\\frac{v_i\\cdot w_i}{\\lVert v_i\\rVert_2\\,\\lVert w_i\\rVert_2}.\n$$\n更大的$S_C$值表示在顺序保持的情况下，沿链的局部几何方向具有更强的一致性。\n\n分类规则。给定阈值$\\tau_D$和$\\tau_C$，当且仅当$S_D\\ge \\tau_D$且$S_C\\le \\tau_C$时，我们称点对$(X,Y)$表现出“基于距离的高相似性和基于几何的低相似性”。对于此问题，使用$\\tau_D = 0.96$和$\\tau_C = 0.20$。\n\n测试套件。使用以下三个测试用例，每个用例都由$X$、$Y$以及（对于基于距离的得分）其显式双射$f$完全指定。所有坐标都以三元组$(a,b,c)$的形式给出，其中$a,b,c\\in\\mathbb{R}$。\n\n通用参考构象$X$（其中$n=6$）：\n- $x_1=(0, 0, 0)$\n- $x_2=(1, 0, 0)$\n- $x_3=(2, 0, 0)$\n- $x_4=(2, 1, 0)$\n- $x_5=(2, 2, 0)$\n- $x_6=(2, 2, 1)$\n\n案例A（乱序；在非恒等对应关系下精确保留距离）：\n- $Y^{(A)}$是通过索引序列$(4, 2, 6, 1, 5, 3)$对$X$重新排序得到的，即：\n  - $y^{(A)}_1=x_4$, $y^{(A)}_2=x_2$, $y^{(A)}_3=x_6$, $y^{(A)}_4=x_1$, $y^{(A)}_5=x_5$, $y^{(A)}_6=x_3$。\n- 用于$S_D$的双射$f^{(A)}$是该重排序的逆，即$f^{(A)}(1)=4, f^{(A)}(2)=2, f^{(A)}(3)=6, f^{(A)}(4)=1, f^{(A)}(5)=5, f^{(A)}(6)=3$。\n\n案例B（恒等；顺序保留）：\n- $Y^{(B)}=X$。\n- $f^{(B)}$是恒等映射$f^{(B)}(i)=i$，对于所有$i\\in\\{1,\\dots,6\\}$。\n\n案例C（带小扰动的乱序）：\n- 从$Y^{(A)}$开始，为每个$y^{(A)}_k$添加以下确定性扰动$\\delta_k$以获得$y^{(C)}_k = y^{(A)}_k + \\delta_k$：\n  - $\\delta_1=(0.01, -0.01, 0.00)$\n  - $\\delta_2=(-0.01, 0.00, 0.01)$\n  - $\\delta_3=(0.00, 0.01, -0.01)$\n  - $\\delta_4=(0.01, 0.00, 0.00)$\n  - $\\delta_5=(0.00, -0.01, 0.01)$\n  - $\\delta_6=(-0.01, 0.01, 0.00)$\n- 用于$S_D$的双射$f^{(C)}$与案例A中相同：$f^{(C)}(1)=4, f^{(C)}(2)=2, f^{(C)}(3)=6, f^{(C)}(4)=1, f^{(C)}(5)=5, f^{(C)}(6)=3$。\n\n角度单位说明。所有通过$S_C$中的余弦而隐式产生的角度，作为角度的余弦值，是无量纲的；不需要表示出角度，也不需要显式单位。\n\n最终输出规范。你的程序必须按照A、B、C的顺序，使用上述定义以及$\\tau_D=0.96$和$\\tau_C=0.20$，计算这三个案例的分类布尔值。生成单行输出，其中包含三个布尔结果，格式为逗号分隔的列表并用方括号括起，例如：“[True,False,True]”。", "solution": "所述问题是有效的。它在科学上基于计算结构生物学的原理，特别是蛋白质比对算法。这是一个适定问题，提供了得出唯一解所需的所有数学定义、数据和约束。其语言客观而精确。因此，我将给出完整的解答。\n\n问题要求构建并评估三对点序列$(X, Y^{(A)})$、$(X, Y^{(B)})$和$(X, Y^{(C)})$，以对比两种不同的结构相似性概念。参考构象$X$是$\\mathbb{R}^3$中一个包含$n=6$个点的有序集合：\n$$\n\\begin{align*}\nx_1&=(0, 0, 0) & x_2&=(1, 0, 0) & x_3&=(2, 0, 0) \\\\\nx_4&=(2, 1, 0) & x_5&=(2, 2, 0) & x_6&=(2, 2, 1)\n\\end{align*}\n$$\n定义了两个相似性得分。第一个，$S_D$，代表距离矩阵相似性，它对点的顺序不敏感。它基于在给定双射$f$下分子内距离的均方根偏差：\n$$\nS_D = \\frac{1}{1+R}, \\quad \\text{where} \\quad R = \\sqrt{\\frac{1}{m}\\sum_{1\\le i<j\\le n}\\left(\\lVert x_i - x_j\\rVert_2 - \\lVert y_{f(i)} - y_{f(j)}\\rVert_2\\right)^2}\n$$\n唯一对的数量为 $m = \\frac{n(n-1)}{2} = \\frac{6 \\cdot (6-1)}{2} = 15$.\n\n第二个得分，$S_C$，代表几何与顺序相似性，它对序列顺序敏感。它是对应键矢量的平均余弦相似度：\n$$\nS_C = \\frac{1}{n-1}\\sum_{i=1}^{n-1}\\frac{v_i\\cdot w_i}{\\lVert v_i\\rVert_2\\,\\lVert w_i\\rVert_2}, \\quad \\text{where} \\quad v_i = x_{i+1}-x_i, \\quad w_i = y_{i+1}-y_i\n$$\n一对构象$(X,Y)$在$S_D \\ge \\tau_D$且$S_C \\le \\tau_C$时被分类为具有“基于距离的高相似性和基于几何的低相似性”，其中阈值为$\\tau_D = 0.96$和$\\tau_C = 0.20$.\n\n我们分析所提供的三个案例。\n\n**案例A：乱序**\n构象$Y^{(A)}$是$X$中点的排列：$y^{(A)}_1=x_4$, $y^{(A)}_2=x_2$, $y^{(A)}_3=x_6$, $y^{(A)}_4=x_1$, $y^{(A)}_5=x_5$, $y^{(A)}_6=x_3$。为$S_D$指定的双射是$f^{(A)}$：\n$f^{(A)}(1)=4, f^{(A)}(2)=2, f^{(A)}(3)=6, f^{(A)}(4)=1, f^{(A)}(5)=5, f^{(A)}(6)=3$。\n\n$S_D^{(A)}$的计算：\n双射$f^{(A)}$的构造方式使得对于每个索引$i$，点$y^{(A)}_{f^{(A)}(i)}$都与点$x_i$相同。例如，$y^{(A)}_{f^{(A)}(1)} = y^{(A)}_4 = x_1$。这对所有$i \\in \\{1,\\dots,6\\}$都成立。因此，对于任何索引对$(i,j)$，距离$\\lVert y^{(A)}_{f^{(A)}(i)} - y^{(A)}_{f^{(A)}(j)}\\rVert_2$等于$\\lVert x_i - x_j\\rVert_2$。$R$的求和项总是零：\n$$\n\\left(\\lVert x_i - x_j\\rVert_2 - \\lVert x_i - x_j\\rVert_2\\right)^2 = 0\n$$\n这导致$R = 0$, 因此 $S_D^{(A)} = \\frac{1}{1+0} = 1$.\n\n$S_C^{(A)}$的计算：\n$X$的键矢量为$v_1=(1, 0, 0)$, $v_2=(1, 0, 0)$, $v_3=(0, 1, 0)$, $v_4=(0, 1, 0)$, 和 $v_5=(0, 0, 1)$，它们的范数都为1。$Y^{(A)}$的键矢量为：\n$w^{(A)}_1 = y^{(A)}_2 - y^{(A)}_1 = x_2 - x_4 = (-1, -1, 0)$\n$w^{(A)}_2 = y^{(A)}_3 - y^{(A)}_2 = x_6 - x_2 = (1, 2, 1)$\n$w^{(A)}_3 = y^{(A)}_4 - y^{(A)}_3 = x_1 - x_6 = (-2, -2, -1)$\n$w^{(A)}_4 = y^{(A)}_5 - y^{(A)}_4 = x_5 - x_1 = (2, 2, 0)$\n$w^{(A)}_5 = y^{(A)}_6 - y^{(A)}_5 = x_3 - x_5 = (0, -2, 0)$\n余弦相似度之和为：\n$\\sum \\cos(\\theta_i) = \\frac{-1}{\\sqrt{2}} + \\frac{1}{\\sqrt{6}} - \\frac{2}{3} + \\frac{2}{\\sqrt{8}} + 0 = \\frac{1}{\\sqrt{6}} - \\frac{2}{3}$。\n所以，$S_C^{(A)} = \\frac{1}{5}(\\frac{1}{\\sqrt{6}} - \\frac{2}{3}) \\approx -0.0517$。\n\n分类（案例A）：\n$S_D^{(A)} = 1 \\ge 0.96$（真）和$S_C^{(A)} \\approx -0.0517 \\le 0.20$（真）。分类为**真**。\n\n**案例B：恒等**\n这里，$Y^{(B)} = X$且$f^{(B)}$是恒等映射，$f^{(B)}(i)=i$。\n$S_D^{(B)}$的计算：\n由于$Y^{(B)}=X$且$f^{(B)}(i)=i$，我们有$\\lVert y^{(B)}_{f(i)} - y^{(B)}_{f(j)}\\rVert_2 = \\lVert x_i - x_j\\rVert_2$。因此，$R=0$且$S_D^{(B)} = 1$。\n\n$S_C^{(B)}$的计算：\n由于对所有i，$y_i = x_i$，键矢量是相同的：$w_i = v_i$。每个片段的余弦相似度为$\\frac{v_i \\cdot v_i}{\\lVert v_i \\rVert^2} = 1$。\n因此，$S_C^{(B)} = \\frac{1}{5} \\sum_{i=1}^5 1 = 1$.\n\n分类（案例B）：\n$S_D^{(B)} = 1 \\ge 0.96$（真）和$S_C^{(B)} = 1 \\le 0.20$（假）。分类为**假**。\n\n**案例C：带扰动的乱序**\n构象$Y^{(C)}$由$Y^{(A)}$加上小的确定性扰动$\\delta_k$得到。双射$f^{(C)}$与$f^{(A)}$相同。\n$S_D^{(C)}$的计算：\n被比较的点是$x_i$和$y^{(C)}_{f^{(C)}(i)} = y^{(A)}_{f^{(A)}(i)} + \\delta_{f^{(A)}(i)} = x_i + \\delta_{f^{(A)}(i)}$。距离$\\lVert y^{(C)}_{f(i)} - y^{(C)}_{f(j)}\\rVert_2$将与$\\lVert x_i - x_j\\rVert_2$略有不同。需要进行完整的数值计算。这得到$R \\approx 0.02700$, 所以 $S_D^{(C)} = 1 / (1 + R) \\approx 1 / 1.02700 \\approx 0.97371$。\n\n$S_C^{(C)}$的计算：\n键矢量$w_i^{(C)}$是$w_i^{(A)}$的扰动：$w_i^{(C)} = w_i^{(A)} + (\\delta_{i+1} - \\delta_i)$。由于扰动很小，矢量的方向仅被轻微改变。我们预期$S_C^{(C)}$接近于$S_C^{(A)}$。数值计算得出$S_C^{(C)} \\approx -0.05584$.\n\n分类（案例C）：\n$S_D^{(C)} \\approx 0.97371 \\ge 0.96$（真）。\n$S_C^{(C)} \\approx -0.05584 \\le 0.20$（真）。分类为**真**。\n\n总之，案例A和案例C都满足条件，表明基于距离的相似性可以很高，而基于顺序的相似性可以很低。代表相同结构的案例B，在两种度量下都具有高相似性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Computes and classifies structural similarity for three test cases\n    based on two different scoring functions.\n    \"\"\"\n    # Common reference conformation X (n=6)\n    X = np.array([\n        [0.0, 0.0, 0.0],  # x1\n        [1.0, 0.0, 0.0],  # x2\n        [2.0, 0.0, 0.0],  # x3\n        [2.0, 1.0, 0.0],  # x4\n        [2.0, 2.0, 0.0],  # x5\n        [2.0, 2.0, 1.0]   # x6\n    ])\n\n    # Classification thresholds\n    tau_D = 0.96\n    tau_C = 0.20\n\n    # Test cases specifications\n    test_cases_spec = {\n        'A': {\n            'reorder_indices': np.array([3, 1, 5, 0, 4, 2]),  # 0-based: (4,2,6,1,5,3)\n            'bijection': np.array([3, 1, 5, 0, 4, 2]),      # 0-based: f(1)=4, f(2)=2, ...\n            'perturbations': np.zeros((6, 3))\n        },\n        'B': {\n            'reorder_indices': np.arange(6),              # Identity\n            'bijection': np.arange(6),                      # Identity\n            'perturbations': np.zeros((6, 3))\n        },\n        'C': {\n            'reorder_indices': np.array([3, 1, 5, 0, 4, 2]), # Same as A\n            'bijection': np.array([3, 1, 5, 0, 4, 2]),     # Same as A\n            'perturbations': np.array([\n                [0.01, -0.01, 0.00],  # delta_1\n                [-0.01, 0.00, 0.01],  # delta_2\n                [0.00, 0.01, -0.01],  # delta_3\n                [0.01, 0.00, 0.00],  # delta_4\n                [0.00, -0.01, 0.01],  # delta_5\n                [-0.01, 0.01, 0.00]   # delta_6\n            ])\n        }\n    }\n\n    results = []\n\n    for case_id in ['A', 'B', 'C']:\n        spec = test_cases_spec[case_id]\n        \n        # Construct conformation Y\n        Y = X[spec['reorder_indices']] + spec['perturbations']\n        \n        # --- Calculate S_D ---\n        n = X.shape[0]\n        m = n * (n - 1) / 2\n        f = spec['bijection']\n        \n        sum_sq_diff = 0.0\n        # Iterate over all unique pairs (i, j) with 0 = i  j  n\n        for i, j in combinations(range(n), 2):\n            dist_x = np.linalg.norm(X[i] - X[j])\n            dist_y = np.linalg.norm(Y[f[i]] - Y[f[j]])\n            sum_sq_diff += (dist_x - dist_y)**2\n            \n        R = np.sqrt(sum_sq_diff / m)\n        S_D = 1.0 / (1.0 + R)\n        \n        # --- Calculate S_C ---\n        v = np.diff(X, axis=0) # Bond vectors for X\n        w = np.diff(Y, axis=0) # Bond vectors for Y\n        \n        v_norms = np.linalg.norm(v, axis=1)\n        w_norms = np.linalg.norm(w, axis=1)\n        \n        # Dot products of corresponding bond vectors\n        dot_products = np.sum(v * w, axis=1)\n        \n        # Cosine similarities\n        # Handle potential division by zero, though not expected in this problem\n        denominators = v_norms * w_norms\n        cosine_sims = np.divide(dot_products, denominators, out=np.zeros_like(dot_products), where=denominators!=0)\n        \n        S_C = np.mean(cosine_sims)\n        \n        # --- Classification ---\n        classification = (S_D >= tau_D) and (S_C = tau_C)\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2421910"}]}