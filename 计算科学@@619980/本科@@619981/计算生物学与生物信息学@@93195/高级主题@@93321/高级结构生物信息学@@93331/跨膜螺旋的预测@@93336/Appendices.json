{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。第一个练习将引导你实现一个核心的跨膜螺旋预测算法。我们将蛋白质序列视为一种数字信号，利用信号处理中的卷积方法，设计一个滤波器来识别疏水性区域。这个练习 [@problem_id:2415771] 不仅能让你掌握将生物学问题转化为计算任务的思维方式，还能让你亲手实现一个经典的基于疏水性滑动窗口的预测器。", "problem": "给定一个由标准 $20$ 字母表构成的有限氨基酸序列，要求您通过将序列建模为实值离散信号并应用形状匹配评分规则，来预测序列中跨膜 (TM) 螺旋的位置。每个氨基酸 $a$ 使用 Kyte–Doolittle (KD) 标度映射到一个实值亲水性指数 $h(a)$。使用的 KD 值定义如下：$h(\\mathrm{I}) = 4.5$，$h(\\mathrm{V}) = 4.2$，$h(\\mathrm{L}) = 3.8$，$h(\\mathrm{F}) = 2.8$，$h(\\mathrm{C}) = 2.5$，$h(\\mathrm{M}) = 1.9$，$h(\\mathrm{A}) = 1.8$，$h(\\mathrm{G}) = -0.4$，$h(\\mathrm{T}) = -0.7$，$h(\\mathrm{S}) = -0.8$，$h(\\mathrm{W}) = -0.9$，$h(\\mathrm{Y}) = -1.3$，$h(\\mathrm{P}) = -1.6$，$h(\\mathrm{H}) = -3.2$，$h(\\mathrm{E}) = -3.5$，$h(\\mathrm{Q}) = -3.5$，$h(\\mathrm{D}) = -3.5$，$h(\\mathrm{N}) = -3.5$，$h(\\mathrm{K}) = -3.9$，$h(\\mathrm{R}) = -4.5$。\n\n设氨基酸序列为 $x[0], x[1], \\dots, x[N-1]$，其中整数 $N \\ge 1$。定义亲水性信号 $H[n] = h(x[n])$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。设 $L$ 为一个正奇数窗口长度，并由升余弦 (Hann) 分布定义一个长度为 $L$ 的非负对称核 $K[j]$：\n$$\nW[j] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi j}{L-1}\\right), \\quad j = 0,1,\\dots,L-1,\n$$\n归一化至单位和，\n$$\nK[j] = \\frac{W[j]}{\\sum_{m=0}^{L-1} W[m]}, \\quad j = 0,1,\\dots,L-1.\n$$\n对每个有效位置 $i \\in \\{0,1,\\dots,N-L\\}$ 定义加窗亲水性得分：\n$$\nS[i] = \\sum_{j=0}^{L-1} K[j] \\, H[i+j].\n$$\n给定阈值 $\\theta \\in \\mathbb{R}$，定义超过阈值的窗口起始点集合：\n$$\n\\mathcal{I} = \\{\\, i \\in \\{0,1,\\dots,N-L\\} \\mid S[i] \\ge \\theta \\,\\}.\n$$\n将 $\\mathcal{I}$ 划分为索引空间中的最大连续区间。对于每个具有最小索引 $i_{\\min}$ 和最大索引 $i_{\\max}$ 的区间，将预测的 TM 螺旋片段定义为包含性残基索引区间 $[i_{\\min}, \\, i_{\\max} + L - 1]$。在所有这些区间集合中，丢弃任何长度（定义为 $1 + \\text{end} - \\text{start}$）小于最小长度 $L_{\\min} \\in \\mathbb{N}$ 的区间。最终预测的 TM 螺旋集合是剩余区间的汇集，每个区间表示为一对整数 $[\\text{start}, \\text{end}]$，采用从零开始的索引和包含性端点。\n\n在所有计算中使用以下固定参数：窗口长度 $L = 19$，阈值 $\\theta = 1.6$，以及最小长度 $L_{\\min} = 17$。\n\n测试套件。对于下面的每个序列，根据上述定义计算预测的 TM 螺旋片段。\n\n-   案例 1：$x = \\text{\"MKTLLLVLALLAVVVVVVVVVVVVVVVAGGQ\"}$。\n-   案例 2：$x = \\text{\"LLLLLLLLLLLLLLLLLLLLNNNNNKKQ\"}$。\n-   案例 3：$x = \\text{\"NNNNNKKQLLLLLLLLLLLLLLLLLLL\"}$。\n-   案例 4：$x = \\text{\"GSDNSTQEKHPRYTNQDSKE\"}$。\n-   案例 5：$x = \\text{\"AAAAALLLLLLLLLLLLLLLAAAAAAKKKKKLLLLLLLLLLLLLLLLAAAAA\"}$。\n-   案例 6：$x = \\text{\"ACDEFGHIK\"}$。\n\n答案规格。对于每个案例，输出必须是区间 $[\\text{start},\\text{end}]$ 的列表，其中 $\\text{start}$ 和 $\\text{end}$ 都是整数。如果没有预测到 TM 螺旋，则该案例输出空列表 $[\\,]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。第 $k$ 个元素对应于案例 $k$，并且其本身必须是如上指定的区间列表，例如，对于两个预测的螺旋，格式为 $[[0,18],[25,43]]$，如果没有，则为 $[]$。不涉及角度，也不需要物理单位。所有索引都必须使用从零开始的索引和包含性端点来报告。最终打印的行必须具有 $[r_1,r_2,\\dots,r_6]$ 的形式，其中每个 $r_k$ 是案例 $k$ 的区间列表。", "solution": "用户提交了一个关于预测氨基酸序列中跨膜螺旋的问题。在继续之前，我将首先验证问题陈述的科学严谨性和清晰度。\n\n### 步骤 1：提取给定条件\n-   **氨基酸亲水性**：$20$ 种标准氨基酸中的每一种 $a$ 都被映射到一个 Kyte-Doolittle 亲水性指数 $h(a)$。具体数值已提供。\n-   **输入**：一个长度为 $N \\ge 1$ 的氨基酸序列 $x[0], x[1], \\dots, x[N-1]$。\n-   **信号生成**：该序列被转换为一个亲水性信号 $H[n] = h(x[n])$。\n-   **核定义**：为 $j \\in \\{0, 1, \\dots, L-1\\}$ 定义了一个长度为 $L$ 的归一化 Hann 窗核 $K[j]$。\n    -   升余弦分布：$W[j] = \\frac{1}{2} - \\frac{1}{2}\\cos\\left(\\frac{2\\pi j}{L-1}\\right)$。\n    -   归一化：$K[j] = W[j] / \\sum_{m=0}^{L-1} W[m]$。\n-   **评分**：通过将信号 $H$ 与核 $K$ 进行卷积，为每个有效起始位置 $i \\in \\{0, 1, \\dots, N-L\\}$ 计算一个加窗得分 $S[i]$：$S[i] = \\sum_{j=0}^{L-1} K[j] H[i+j]$。\n-   **阈值处理**：形成一个窗口索引集合 $\\mathcal{I}$，其中得分超过阈值 $\\theta$：$\\mathcal{I} = \\{ i \\mid S[i] \\ge \\theta \\}$。\n-   **螺旋定义**：集合 $\\mathcal{I}$ 被划分为最大连续区间。每个区间，其最小索引为 $i_{\\min}$，最大索引为 $i_{\\max}$，定义一个预测的螺旋区间为 $[i_{\\min}, i_{\\max} + L - 1]$。\n-   **筛选**：如果预测的螺旋长度 $1 + \\text{end} - \\text{start}$ 小于最小长度 $L_{\\min}$，则将其丢弃。\n-   **参数**：问题指定了固定参数：窗口长度 $L = 19$，阈值 $\\theta = 1.6$，以及最小螺旋长度 $L_{\\min} = 17$。\n-   **测试案例**：提供了六个特定的氨基酸序列用于分析。\n-   **输出规格**：对于每个案例，报告一个零索引、包含性端点的整数区间 $[\\text{start}, \\text{end}]$ 的列表。最终输出必须是包含这些结果列表的单行。\n\n### 步骤 2：使用提取的给定条件进行验证\n-   **科学上合理的**：该方法是生物信息学中用于识别跨膜结构域的一种成熟技术。它基于跨膜螺旋主要由疏水性氨基酸组成的原理。Kyte-Doolittle 标度是亲水性的标准度量，而使用滑动窗口（特别是 Hann 窗口）进行平滑是标准的信号处理技术。该方法在科学上是有效的。\n-   **定义明确的 (Well-Posed)**：该问题以数学精度进行表述。所有参数和程序都明确定义，确保对于任何给定的输入序列都可以计算出唯一且稳定的解。\n-   **客观的**：问题陈述客观，没有歧义或主观论断。定义的算法是确定性的。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。它在科学上是合理的、定义明确的且客观的。我现在将继续提供一个完整的解决方案。\n\n### 算法解决方案\n该任务是实现一个信号处理流程，以检测蛋白质序列中的疏水区域，这些区域是跨膜 (TM) 螺旋的特征。该算法分几个不同阶段进行。\n\n1.  **信号转换**：初始输入，即一个符号化的氨基酸序列，被转换为一个实值离散信号。这是通过将长度为 $N$ 的输入序列中的每个氨基酸 $x[n]$ 映射到其相应的 Kyte-Doolittle 亲水性指数 $h(x[n])$ 来实现的，从而产生数值信号 $H[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。正值表示疏水性，而负值表示亲水性。\n\n2.  **基于核的平滑**：跨膜螺旋是延伸的结构，通常跨越 $17$ 到 $25$ 个残基。为了识别这些区域，必须对局部亲水性值进行平均。这是通过将亲水性信号 $H$ 与一个平滑核 $K$ 进行卷积来实现的。问题指定了 $L=19$ 个残基的窗口长度，这与 TM 螺旋的典型长度相匹配。核函数来源于一个 Hann 窗口分布，由下式给出\n    $$\n    W[j] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi j}{L-1}\\right), \\quad j = 0,1,\\dots,L-1.\n    $$\n    这个窗函数给予窗口中心的残基更多的权重，而给予边缘残基较少的权重。核 $K[j]$ 被归一化以使其和为一，即 $\\sum_{j=0}^{L-1} K[j] = 1$，方法是将 $W[j]$ 除以总和 $\\sum_{m=0}^{L-1} W[m] = (L-1)/2$。对于 $L=19$，这个总和是 $9$。然后，在每个窗口的起始位置 $i$ 处的平滑亲水性得分计算如下：\n    $$\n    S[i] = \\sum_{j=0}^{L-1} K[j] H[i+j].\n    $$\n    此操作对所有有效的窗口位置 $i \\in \\{0, 1, \\dots, N-L\\}$ 执行。在计算上，这是信号 $H$ 与核 $K$ 的离散卷积，其中核 $K$ 是对称的 ($K[j] = K[L-1-j]$)。\n\n3.  **疏水核心的识别**：得分 $S[i]$ 表示从索引 $i$ 开始的长度为 $L$ 的窗口的平均疏水性。高分表示可能存在一个 TM 螺旋片段。通过应用阈值 $\\theta=1.6$ 来识别这些片段。所有满足 $S[i] \\ge \\theta$ 的窗口起始索引 $i$ 都被收集到一个集合 $\\mathcal{I}$ 中。\n\n4.  **螺旋边界的界定**：集合 $\\mathcal{I}$ 包含了所有被认为足够疏水的窗口的起始索引。可以推断，这些窗口的连续延伸属于单个 TM 螺旋。因此，$\\mathcal{I}$ 被划分为最大连续的索引区间。对于每个区间，我们确定其最小和最大索引 $i_{\\min}$ 和 $i_{\\max}$。这个区间表示一个疏水核心区域，从残基 $i_{\\min}$ 延伸到残基 $i_{\\max} + L - 1$。预测的螺旋的起始点是区间中第一个窗口的起始点 ($i_{\\min}$)，螺旋的结束点是区间中最后一个窗口的结束点 ($i_{\\max} + L - 1$)。\n\n5.  **长度筛选**：从生物物理学角度看，一个 TM 螺旋必须具有一定的最小长度才能跨越细胞膜。该问题通过指定一个最小长度 $L_{\\min}=17$ 来施加此约束。任何长度为 $1 + \\text{end} - \\text{start} < L_{\\min}$ 的预测螺旋区间 $[\\text{start}, \\text{end}]$ 都被作为生物学上不合理的而被丢弃。\n\n最终输出是所有满足长度约束的预测螺旋区间的集合。下面的 Python 代码实现了这个完整的程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Predicts transmembrane helices in amino acid sequences based on a\n    hydropathy scoring algorithm.\n    \"\"\"\n    # Define the Kyte-Doolittle hydropathy scale.\n    KD_SCALE = {\n        'I': 4.5, 'V': 4.2, 'L': 3.8, 'F': 2.8, 'C': 2.5,\n        'M': 1.9, 'A': 1.8, 'G': -0.4, 'T': -0.7, 'S': -0.8,\n        'W': -0.9, 'Y': -1.3, 'P': -1.6, 'H': -3.2, 'E': -3.5,\n        'Q': -3.5, 'D': -3.5, 'N': -3.5, 'K': -3.9, 'R': -4.5\n    }\n    \n    # Define fixed parameters from the problem statement.\n    L = 19       # Window length\n    THETA = 1.6  # Hydropathy score threshold\n    L_MIN = 17   # Minimal helix length\n\n    # Pre-compute the normalized Hann window kernel.\n    # The sum of Hann window weights W[j] is exactly (L-1)/2.\n    W = np.hanning(L)\n    K = W / ((L - 1) / 2.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"MKTLLLVLALLAVVVVVVVVVVVVVVVAGGQ\",\n        \"LLLLLLLLLLLLLLLLLLLLNNNNNKKQ\",\n        \"NNNNNKKQLLLLLLLLLLLLLLLLLLL\",\n        \"GSDNSTQEKHPRYTNQDSKE\",\n        \"AAAAALLLLLLLLLLLLLLLAAAAAAKKKKKLLLLLLLLLLLLLLLLAAAAA\",\n        \"ACDEFGHIK\",\n    ]\n\n    all_results = []\n    for seq in test_cases:\n        N = len(seq)\n\n        # If the sequence is shorter than the window length, no analysis is possible.\n        if N < L:\n            all_results.append([])\n            continue\n\n        # 1. Convert the amino acid sequence to a hydropathy signal H.\n        H = np.array([KD_SCALE[aa] for aa in seq])\n\n        # 2. Calculate the windowed hydropathy score S by convolving H with K.\n        # The specified kernel K is symmetric, so cross-correlation is equivalent to convolution.\n        # numpy.convolve with mode='valid' computes the required sum S[i].\n        S = np.convolve(H, K, mode='valid')\n\n        # 3. Find all window start indices where the score is above the threshold.\n        above_threshold_indices = np.where(S >= THETA)[0]\n\n        if len(above_threshold_indices) == 0:\n            all_results.append([])\n            continue\n\n        # 4. Partition the indices into maximal contiguous runs.\n        # This is done by splitting the array where the difference between adjacent elements is > 1.\n        runs = np.split(above_threshold_indices, np.where(np.diff(above_threshold_indices) > 1)[0] + 1)\n\n        predicted_helices = []\n        for run in runs:\n            if len(run) == 0:\n                continue\n\n            # 5. Define the helix interval from the run's start and end indices.\n            i_min = run[0]\n            i_max = run[-1]\n            \n            start_res = i_min\n            end_res = i_max + L - 1\n\n            # 6. Filter out helices that are shorter than the minimum length.\n            length = end_res - start_res + 1\n            if length >= L_MIN:\n                predicted_helices.append([int(start_res), int(end_res)])\n        \n        all_results.append(predicted_helices)\n\n    # Format the final results into the specified single-line string format.\n    # Example: [[[0,18],[25,43]],[],...]\n    formatted_results = []\n    for res_list in all_results:\n        if not res_list:\n            formatted_results.append(\"[]\")\n        else:\n            intervals_str = \",\".join([f\"[{s},{e}]\" for s, e in res_list])\n            formatted_results.append(f\"[{intervals_str}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2415771"}, {"introduction": "滑动窗口方法虽然直观，但它忽略了蛋白质拓扑结构的“语法”——例如，一个跨膜螺旋通常连接着胞内和胞外环区。为了捕捉这种上下文关系，我们引入了更强大的概率模型：隐马尔可夫模型 (HMM)。在这个练习 [@problem_id:2415723] 中，你将通过实现经典的维特比 (Viterbi) 算法，为给定的氨基酸序列解码出最可能的功能区域（胞内、跨膜或胞外）路径，从而深入理解 HMM 在生物序列分析中的强大能力。", "problem": "给定一个蛋白质序列的概率模型，该模型具有三个隐状态，分别代表相对于脂质双分子层的拓朴区域：胞质区 (in)、跨膜螺旋区 (helix) 和胞外区 (out)。该模型是一个三状态隐马尔可夫模型 (HMM)，其定义如下。\n\n- 隐状态集：$\\mathcal{S}=\\{S_{\\text{in}},S_{\\text{helix}},S_{\\text{out}}\\}$，其中 $S_{\\text{in}}$ 的索引为 $0$， $S_{\\text{helix}}$ 的索引为 $1$， $S_{\\text{out}}$ 的索引为 $2$。\n- 观测字母表由标准氨基酸衍生而来，通过将其分为三类：疏水性、极性不带电和带电。\n  - 疏水性类别 $\\mathcal{H}=\\{\\text{A},\\text{V},\\text{L},\\text{I},\\text{F},\\text{M},\\text{W},\\text{Y},\\text{C}\\}$\n  - 极性类别 $\\mathcal{P}=\\{\\text{S},\\text{T},\\text{N},\\text{Q},\\text{G},\\text{P},\\text{H}\\}$\n  - 带电类别 $\\mathcal{C}=\\{\\text{D},\\text{E},\\text{K},\\text{R}\\}$\n  对于任何作为氨基酸的观测符号 $o_t$，它会根据上述集合映射到三个类别 $\\{\\mathcal{H},\\mathcal{P},\\mathcal{C}\\}$ 之一。如果 $o_t\\in\\mathcal{H}$，其类别索引记为 $0$；如果 $o_t\\in\\mathcal{P}$，索引为 $1$；如果 $o_t\\in\\mathcal{C}$，索引为 $2$。\n- 初始状态分布 $\\boldsymbol{\\pi}=[\\pi_0,\\pi_1,\\pi_2]$，其中\n  - $\\pi_0=0.45$, $\\pi_1=0.10$, $\\pi_2=0.45$。\n- 状态转移概率矩阵 $\\mathbf{A}=[a_{ij}]$，各行之和为 $1$：\n  - 从 $S_{\\text{in}}$ (行索引 $0$)：$a_{00}=0.94$, $a_{01}=0.05$, $a_{02}=0.01$。\n  - 从 $S_{\\text{helix}}$ (行索引 $1$)：$a_{10}=0.015$, $a_{11}=0.97$, $a_{12}=0.015$。\n  - 从 $S_{\\text{out}}$ (行索引 $2$)：$a_{20}=0.01$, $a_{21}=0.05$, $a_{22}=0.94$。\n- 对于每个状态 $i\\in\\{0,1,2\\}$ 和类别 $\\kappa\\in\\{0,1,2\\}$ (类别索引 $0$ 代表 $\\mathcal{H}$，$1$ 代表 $\\mathcal{P}$，$2$ 代表 $\\mathcal{C}$) 的发射概率 $\\mathbf{B}=[b_{i\\kappa}]$：\n  - 对于 $S_{\\text{in}}$ (行索引 $0$)：$b_{0,0}=0.25$, $b_{0,1}=0.45$, $b_{0,2}=0.30$。\n  - 对于 $S_{\\text{helix}}$ (行索引 $1$)：$b_{1,0}=0.80$, $b_{1,1}=0.15$, $b_{1,2}=0.05$。\n  - 对于 $S_{\\text{out}}$ (行索引 $2$)：$b_{2,0}=0.25$, $b_{2,1}=0.50$, $b_{2,2}=0.25$。\n\n给定一个观测到的氨基酸序列 $O=(o_1,o_2,\\dots,o_T)$，定义一个隐状态路径 $S=(s_1,s_2,\\dots,s_T)$，其中每个 $s_t\\in\\{0,1,2\\}$。在该模型下，一个路径和观测序列的联合概率为\n$$\nP(S,O)=\\pi_{s_1}\\,b_{s_1,\\kappa(o_1)}\\prod_{t=2}^{T} a_{s_{t-1},s_t}\\,b_{s_t,\\kappa(o_t)},\n$$\n其中 $\\kappa(o_t)\\in\\{0,1,2\\}$ 是如上定义的 $o_t$ 的类别索引。您的任务是，对于每个提供的测试序列，找到一个路径 $S^\\star$，使 $P(S,O)$ 在所有可能相同长度的状态序列中最大化：\n$$\nS^\\star=\\arg\\max_{S\\in\\{0,1,2\\}^T} P(S,O).\n$$\n如果出现平局，选择在状态索引序列的排序 $0<1<2$ 下具有最小字典序的路径。\n\n测试套件：\n- 序列 1：MSTNQGQKKSATAVLILLLLFIL\n- 序列 2：AVLLIIFWLIMVW\n- 序列 3：SSNGQTPHST\n- 序列 4：DEKRRDEK\n- 序列 5：K\n- 序列 6：LAKLAKLAKLAK\n\n所有序列都使用标准的单字母氨基酸代码，并需使用上面给出的集合 $\\mathcal{H}$、$\\mathcal{P}$ 和 $\\mathcal{C}$ 映射到相应类别。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含所有六个序列的结果。结果是一个由方括号括起来的逗号分隔列表，其中每个结果本身也是一个由方括号括起来的逗号分隔的整数列表。例如，对于长度为 $3$、$2$ 和 $4$ 的三个序列，一个有效的输出格式为 [[0,1,1],[1,1],[2,2,2,2]]。输出行中不得包含任何空格。", "solution": "该问题已经过验证。\n\n### 步骤 1：使用提取的给定信息进行验证\n- **科学合理性**：该问题描述了一个标准的三状态隐马尔可夫模型 (HMM)，这是生物信息学中一种广泛使用且科学上成熟的方法，用于预测如跨膜结构域等蛋白质特征。参数具有生物学上的合理性：螺旋区富含疏水性残基，具有很高的自转移概率，且拓扑区域之间的转移频率较低。\n- **定义明确性**：任务是找到最可能的隐状态路径，这是一个可通过维特比算法解决的经典问题。该问题定义明确，并且指定的平局打破规则确保了唯一解的存在。\n- **客观性**：问题是用精确的数学和概率术语定义的。所有参数都已用数值指定。目标是一个明确的优化问题。\n\n### 步骤 2：结论与行动\n该问题没有科学谬误、模糊性或矛盾之处。提供了获得唯一解所需的所有数据和条件。将开发一个解决方案。\n\n**基于原理的解决方案**\n该问题要求为给定的观测序列 $O$ 找到最可能的隐状态序列 $S^\\star$。这是一个使用维特比算法（一种动态规划方法）解决的典型问题。由于概率的重复乘法可能导致数值下溢，标准做法是使用对数概率。目标函数变为找到使 $\\log P(S,O)$ 最大化的路径 $S$：\n$$\n\\log P(S,O) = \\log\\pi_{s_1} + \\log b_{s_1,\\kappa(o_1)} + \\sum_{t=2}^{T} \\left( \\log a_{s_{t-1},s_t} + \\log b_{s_t,\\kappa(o_t)} \\right)\n$$\n标准的维特比算法可以高效地找到最大概率，但通常使用回溯过程从后向前重构路径。这使得执行指定的字典序平局打破规则变得复杂，因为该规则要求从头到尾比较路径。\n\n为了正确实现平局打破规则，我们必须修改算法，以前向方式构建和比较路径前缀。在每一步中，除了存储最大对数概率外，我们还必须存储相应的字典序最小的路径前缀。\n\n设状态数为 $K=3$，观测序列长度为 $T$。我们定义一个动态规划表，其中时间步 $t$ ($1 \\le t \\le T$) 和状态 $j$ ($0 \\le j < K$) 的每个条目存储一个对：$(\\delta_t(j), \\mathbf{P}_t(j))$。\n- $\\delta_t(j)$ 是任何长度为 $t$ 且在状态 $j$ 结束的路径的最大对数概率。\n- $\\mathbf{P}_t(j)$ 是对应的状态序列 $(s_1, s_2, \\dots, s_t=j)$，它必须是在所有长度为 $t$、以状态 $j$ 结束且对数概率为 $\\delta_t(j)$ 的路径中字典序最小的那个。\n\n算法流程如下：\n\n**1. 初始化 ($t=1$)**\n对于每个状态 $j \\in \\{0, 1, 2\\}$，我们计算第一个观测 $o_1$ 的对数概率。路径就是 $[j]$。\n$$\n\\delta_1(j) = \\log\\pi_j + \\log b_{j,\\kappa(o_1)}\n$$\n$$\n\\mathbf{P}_1(j) = [j]\n$$\n\n**2. 递归 ($t=2, \\dots, T$)**\n对于每个状态 $j \\in \\{0, 1, 2\\}$，我们找到延伸到状态 $j$ 的最佳前驱状态 $i^\\star$。这涉及一个两阶段比较：\n首先，找到从任何前一状态 $i$ 到达时间 $t$ 状态 $j$ 的路径可能的最大对数概率：\n$$\nL_{max} = \\max_{i \\in \\{0, 1, 2\\}} \\left( \\delta_{t-1}(i) + \\log a_{ij} \\right)\n$$\n其次，识别所有能够达到此最大概率的前一状态。设此集合为 $I_{best}$。\n$$\nI_{best} = \\{i \\mid \\delta_{t-1}(i) + \\log a_{ij} \\approx L_{max} \\}\n$$\n我们使用近似相等来处理潜在的浮点不精确性。从此集合中，我们选择其路径前缀 $\\mathbf{P}_{t-1}(i)$ 在字典序上最小的状态 $i^\\star$。\n$$\ni^\\star = \\arg\\min_{i \\in I_{best}} \\mathbf{P}_{t-1}(i) \\quad (\\text{字典序比较})\n$$\n确定 $i^\\star$ 后，我们更新时间 $t$ 和状态 $j$ 的动态规划表：\n$$\n\\delta_t(j) = L_{max} + \\log b_{j,\\kappa(o_t)}\n$$\n$$\n\\mathbf{P}_t(j) = \\mathbf{P}_{t-1}(i^\\star) \\, \\oplus \\, [j] \\quad (\\text{其中 } \\oplus \\text{ 表示列表连接})\n$$\n\n**3. 终止**\n在完成直到 $t=T$ 的前向递归后，我们确定最终的最佳路径。我们对最终状态应用同样的两阶段比较：\n首先，找到所有长度为 $T$ 的路径中的最大对数概率：\n$$\n\\delta_{final} = \\max_{j \\in \\{0, 1, 2\\}} \\delta_T(j)\n$$\n其次，识别所有达到此概率的最终状态 $J_{best}$：\n$$\nJ_{best} = \\{ j \\mid \\delta_T(j) \\approx \\delta_{final} \\}\n$$\n最优路径 $S^\\star$ 是在那些以 $J_{best}$ 中状态结束的路径中字典序最小的那个：\n$$\nS^\\star = \\arg\\min_{j \\in J_{best}} \\mathbf{P}_T(j) \\quad (\\text{字典序比较})\n$$\n这种改进的前向传递维特比算法能正确找到最可能的路径，同时严格遵守指定的字典序平局打破规则。由于需要存储和比较路径，其计算复杂性高于标准算法，但对于本问题的约束是必要的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the HMM Viterbi problem for multiple sequences with a lexicographical tie-breaker.\n    \"\"\"\n    \n    # Define model parameters\n    pi = np.array([0.45, 0.10, 0.45])\n    log_pi = np.log(pi)\n\n    A = np.array([\n        [0.94, 0.05, 0.01],\n        [0.015, 0.97, 0.015],\n        [0.01, 0.05, 0.94]\n    ])\n    log_A = np.log(A)\n\n    B = np.array([\n        [0.25, 0.45, 0.30], # in\n        [0.80, 0.15, 0.05], # helix\n        [0.25, 0.50, 0.25]  # out\n    ])\n    log_B = np.log(B)\n    \n    # Amino acid to category mapping\n    H_cat = {'A', 'V', 'L', 'I', 'F', 'M', 'W', 'Y', 'C'}\n    P_cat = {'S', 'T', 'N', 'Q', 'G', 'P', 'H'}\n    C_cat = {'D', 'E', 'K', 'R'}\n\n    def aa_to_category(aa):\n        if aa in H_cat: return 0\n        if aa in P_cat: return 1\n        if aa in C_cat: return 2\n        raise ValueError(f\"Unknown amino acid: {aa}\")\n\n    test_sequences = [\n        \"MSTNQGQKKSATAVLILLLLFIL\",\n        \"AVLLIIFWLIMVW\",\n        \"SSNGQTPHST\",\n        \"DEKRRDEK\",\n        \"K\",\n        \"LAKLAKLAKLAK\"\n    ]\n\n    def find_best_path(seq):\n        \"\"\"\n        Implements the modified forward Viterbi algorithm with lexicographical tie-breaking.\n        \"\"\"\n        if not seq:\n            return []\n        \n        obs_cats = [aa_to_category(aa) for aa in seq]\n        T = len(obs_cats)\n        K = 3  # Number of states\n\n        # DP tables\n        # delta[t][j]: max log-prob for path of length t+1 ending in state j\n        # paths[t][j]: the corresponding lexicographically smallest path\n        delta = np.full((T, K), -np.inf)\n        paths = [[[] for _ in range(K)] for _ in range(T)]\n\n        # Initialization (t=0)\n        o1_cat = obs_cats[0]\n        for j in range(K):\n            delta[0, j] = log_pi[j] + log_B[j, o1_cat]\n            paths[0][j] = [j]\n\n        # Recursion (t=1 to T-1)\n        for t in range(1, T):\n            ot_cat = obs_cats[t]\n            for j in range(K):\n                # Find best previous state i\n                candidate_log_probs = delta[t-1, :] + log_A[:, j]\n                max_log_prob = np.max(candidate_log_probs)\n                \n                # Get all states i that achieve this max_log_prob\n                best_prev_indices = [\n                    i for i, p in enumerate(candidate_log_probs) if np.isclose(p, max_log_prob)\n                ]\n                \n                # Tie-break using lexicographical path comparison\n                i_star = best_prev_indices[0]\n                best_path_prefix = paths[t-1][i_star]\n                \n                for idx in range(1, len(best_prev_indices)):\n                    i_candidate = best_prev_indices[idx]\n                    # Python's list comparison is lexicographical\n                    if paths[t-1][i_candidate] < best_path_prefix:\n                        best_path_prefix = paths[t-1][i_candidate]\n                        i_star = i_candidate\n\n                # Update DP tables\n                delta[t, j] = max_log_prob + log_B[j, ot_cat]\n                paths[t][j] = paths[t-1][i_star] + [j]\n\n        # Termination\n        final_log_probs = delta[T-1, :]\n        max_final_log_prob = np.max(final_log_probs)\n\n        best_final_indices = [\n            j for j, p in enumerate(final_log_probs) if np.isclose(p, max_final_log_prob)\n        ]\n\n        # Tie-break using lexicographical path comparison for the full path\n        best_path = paths[T-1][best_final_indices[0]]\n        for idx in range(1, len(best_final_indices)):\n            j_candidate = best_final_indices[idx]\n            if paths[T-1][j_candidate] < best_path:\n                best_path = paths[T-1][j_candidate]\n        \n        return best_path\n\n    results = []\n    for seq in test_sequences:\n        path = find_best_path(seq)\n        results.append(f\"[{','.join(map(str, path))}]\")\n    \n    # Print the final result in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2415723"}, {"introduction": "一个模型的真正价值不仅在于它何时成功，更在于我们是否理解它的局限性。这个高级练习 [@problem_id:2415695] 是对你所构建模型的一次“压力测试”。你将使用一个为 $\\alpha$ 螺旋设计的 HMM 来分析一个具有不同结构特征（例如，类似 $\\beta$ 桶的交替模式）的序列。通过分析模型在这种“非预期”输入下给出的预测结果，你将深刻洞察到模型内在的偏好和假设，这是成为一名严谨的计算生物学家的关键一步。", "problem": "一个跨膜螺旋（TM）预测模型被形式化为一个离散隐马尔可夫模型（HMM），其中隐藏状态代表生物学区域：内环、螺旋和外环。您将评估这个以螺旋为导向的模型在被迫解释包含类似β-桶状交替模式的氨基酸序列时的行为。目标是通过计算给定模型下每条序列最可能的隐藏状态路径的特定、明确定义的统计数据，来量化模型的偏好。\n\n模型定义。设隐藏状态集为 $S=\\{I,H,O\\}$，分别对应内环 $I$、跨膜螺旋 $H$ 和外环 $O$。初始分布为 $\\pi(I)=1$ 以及 $\\pi(H)=\\pi(O)=0$。状态转移矩阵 $A=(a_{uv})_{u,v\\in S}$ 由下式给出\n$$\na_{II}=0.95,\\;\\;a_{IH}=0.05,\\;\\;a_{IO}=0,\\quad\na_{HH}=0.95,\\;\\;a_{HO}=0.05,\\;\\;a_{HI}=0,\\quad\na_{OO}=0.95,\\;\\;a_{OI}=0.05,\\;\\;a_{OH}=0.\n$$\n这施加了大约 $1/(1-0.95)=20$ 个残基的预期螺旋长度，并强制执行一个 $I\\to H\\to O\\to I$ 的循环。\n\n发射概率是根据每个氨基酸 $r\\in\\mathcal{A}$ 的 Kyte–Doolittle 亲水性标度 $h(r)$ 定义的，其中 $\\mathcal{A}$ 是标准的20个字母的氨基酸字母表 $\\mathcal{A}=\\{\\text{A},\\text{C},\\text{D},\\text{E},\\text{F},\\text{G},\\text{H},\\text{I},\\text{K},\\text{L},\\text{M},\\text{N},\\text{P},\\text{Q},\\text{R},\\text{S},\\text{T},\\text{V},\\text{W},\\text{Y}\\}$。亲水性值如下：\n$$\nh(\\text{I})=4.5,\\;h(\\text{V})=4.2,\\;h(\\text{L})=3.8,\\;h(\\text{F})=2.8,\\;h(\\text{C})=2.5,\\;h(\\text{M})=1.9,\\;h(\\text{A})=1.8,\\;h(\\text{G})=-0.4,\\\\\nh(\\text{T})=-0.7,\\;h(\\text{S})=-0.8,\\;h(\\text{W})=-0.9,\\;h(\\text{Y})=-1.3,\\;h(\\text{P})=-1.6,\\;h(\\text{H})=-3.2,\\;h(\\text{E})=-3.5,\\\\\nh(\\text{Q})=-3.5,\\;h(\\text{D})=-3.5,\\;h(\\text{N})=-3.5,\\;h(\\text{K})=-3.9,\\;h(\\text{R})=-4.5.\n$$\n设 $\\lambda=0.5$。发射分布由玻尔兹曼型（Boltzmann-type）权重定义，该权重倾向于螺旋中的疏水残基，而不倾向于环中的疏水残基：\n$$\nb_H(r)=\\frac{\\exp(\\lambda\\,h(r))}{Z_H},\\qquad b_I(r)=b_O(r)=\\frac{\\exp(-\\lambda\\,h(r))}{Z_L},\n$$\n其中 $Z_H=\\sum_{a\\in\\mathcal{A}}\\exp(\\lambda\\,h(a))$ 和 $Z_L=\\sum_{a\\in\\mathcal{A}}\\exp(-\\lambda\\,h(a))$ 确保了归一化。\n\n对于一个观测到的氨基酸序列 $x_{1:L}\\in\\mathcal{A}^L$，将最可能的状态路径 $\\hat{q}_{1:L}\\in S^L$ 定义为在 $\\pi$、$A$ 和发射分布 $b_s(\\cdot)$ 下，使联合概率 $\\Pr(q_{1:L},x_{1:L})$ 最大化的任何序列。从 $\\hat{q}_{1:L}$ 计算以下统计数据：\n- $N_H$：螺旋片段的数量，定义为 $\\hat{q}_{1:L}$ 中状态 $H$ 的最大连续出现的次数。\n- $L_{\\max}$：最长螺旋片段的长度（以残基为单位）。\n- $f_{\\text{charged}\\to H}$：被分配到状态 $H$ 的带电残基的比例（以小数表示），其中带电残基为 $\\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\}$。如果序列不含带电残基，按约定此比例定义为 $0$。\n- $\\ell$：每个残基的平均对数联合概率，定义为 $\\ell=\\frac{1}{L}\\log \\Pr(\\hat{q}_{1:L},x_{1:L})$，使用自然对数。\n\n测试集。对以下四个序列评估上述统计数据：\n- 案例 $1$ (螺旋片段): $x^{(1)}=\\text{\"MKK\"}+\\text{\"L\"}^{30}+\\text{\"A\"}^{5}+\\text{\"KK\"}$。\n- 案例 $2$ (类似β-桶状的交替模式): $x^{(2)}=(\\text{\"VT\"})^{60}$。\n- 案例 $3$ (类似高溶解性): $x^{(3)}=(\\text{\"DEKQNST\"})^{20}$。\n- 案例 $4$ (接近螺旋长度先验的短疏水区段): $x^{(4)}=\\text{\"N\"}^{7}+\\text{\"L\"}^{12}+\\text{\"N\"}^{7}+\\text{\"L\"}^{8}+\\text{\"N\"}^{7}$。\n\n答案规格。对于每个案例 $i\\in\\{1,2,3,4\\}$，您的程序必须输出列表 $[N_H^{(i)},L_{\\max}^{(i)},f_{\\text{charged}\\to H}^{(i)},\\ell^{(i)}]$，其中实值量 $f_{\\text{charged}\\to H}^{(i)}$ 和 $\\ell^{(i)}$ 需四舍五入到小数点后三位。您的程序应生成单行输出，其中包含按案例1到4的顺序排列的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个案例的结果本身也是一个由方括号括起来的逗号分隔列表。例如，两个假设案例的输出看起来像这样：$[[1,20,0.125,-1.234],[0,0,0.000,-2.718]]$。\n\n最终输出必须严格遵守此格式，并包含如上所述的恰好四个案例的摘要。", "solution": "该问题要求对给定隐马尔可夫模型（HMM）在几个氨基酸序列上进行分析。解决方案涉及使用维特比（Viterbi）算法为每个序列找到最可能的隐藏状态路径，然后根据此路径计算一组指定的统计数据。\n\nHMM的定义如下：\n- 一组包含3个隐藏状态的集合，$S=\\{I, H, O\\}$，分别对应内环、跨膜螺旋和外环。\n- 一个初始状态分布 $\\pi$，其中 $\\pi(I)=1$ 且 $\\pi(H)=\\pi(O)=0$。\n- 一个状态转移矩阵 $A=(a_{uv})$。\n- 一组发射分布 $b_s(r)$，适用于每个状态 $s \\in S$ 和氨基酸 $r \\in \\mathcal{A}$。\n\n维特比（Viterbi）算法是寻找最可能隐藏状态序列 $\\hat{q}_{1:L} = (\\hat{q}_1, ..., \\hat{q}_L)$ 的标准方法，该序列能够产生给定的观测序列 $x_{1:L} = (x_1, ..., x_L)$。此路径使联合概率 $\\Pr(q_{1:L}, x_{1:L})$ 最大化。该算法通过动态规划工作，并且为了防止长序列出现数值下溢，计算在对数空间中进行。\n\n首先，我们以对数形式预计算必要的参数。\n\n**1. 对数空间中的HMM参数**\n\n发射概率由下式给出：\n$$b_H(r)=\\frac{\\exp(\\lambda\\,h(r))}{Z_H}, \\quad b_I(r)=b_O(r)=\\frac{\\exp(-\\lambda\\,h(r))}{Z_L}$$\n其中 $\\lambda=0.5$。归一化常数 $Z_H$ 和 $Z_L$ 是对字母表 $\\mathcal{A}$ 中所有20种氨基酸的求和：\n$$Z_H=\\sum_{a\\in\\mathcal{A}}\\exp(\\lambda\\,h(a)), \\qquad Z_L=\\sum_{a\\in\\mathcal{A}}\\exp(-\\lambda\\,h(a))$$\n使用提供的亲水性值 $h(r)$，这些常数计算得出 $Z_H \\approx 53.0031$ 和 $Z_L \\approx 35.1311$。\n\n对数发射概率为：\n$$\\log b_H(r) = \\lambda h(r) - \\log Z_H$$\n$$\\log b_I(r) = \\log b_O(r) = -\\lambda h(r) - \\log Z_L$$\n\n对数转移概率 $\\log a_{uv}$ 从给定的矩阵 $A$ 计算得出。概率为 $0$ 的转移具有 $-\\infty$ 的对数概率。\n$$\n\\log A =\\begin{pmatrix}\n\\log(0.95) & \\log(0.05) & -\\infty \\\\\n-\\infty & \\log(0.95) & \\log(0.05) \\\\\n\\log(0.05) & -\\infty & \\log(0.95)\n\\end{pmatrix}\n\\approx\n\\begin{pmatrix}\n-0.0513 & -2.9957 & -\\infty \\\\\n-\\infty & -0.0513 & -2.9957 \\\\\n-2.9957 & -\\infty & -0.0513\n\\end{pmatrix}\n$$\n\n初始对数概率为 $\\log \\pi = (\\log(1), \\log(0), \\log(0)) = (0, -\\infty, -\\infty)$。\n\n**2. 维特比算法**\n\n设 $V_t(s)$ 为任何长度为 $t$、以状态 $s \\in S$ 结尾并发出前缀 $x_{1:t}$ 的路径的最大对数概率。我们还维护一个回溯指针矩阵 $ptr_t(s)$ 来重构路径。\n\n- **初始化 ($t=1$)：**对于每个状态 $s \\in S$，\n$$V_1(s) = \\log \\pi(s) + \\log b_s(x_1)$$\n鉴于初始分布，这简化为 $V_1(I) = \\log b_I(x_1)$ 以及 $V_1(H) = V_1(O) = -\\infty$。\n\n- **递推 ($t=2, \\dots, L$)：**对于每个状态 $s \\in S$，\n$$V_t(s) = \\log b_s(x_t) + \\max_{u \\in S} \\{ V_{t-1}(u) + \\log a_{us} \\}$$\n$$ptr_t(s) = \\arg\\max_{u \\in S} \\{ V_{t-1}(u) + \\log a_{us} \\}$$\n\n- **终止：**最可能路径的对数概率是维特比矩阵最后一列中的最大概率：\n$$\\log \\Pr(\\hat{q}_{1:L}, x_{1:L}) = \\max_{s \\in S} \\{ V_L(s) \\}$$\n路径的最终状态是：\n$$\\hat{q}_L = \\arg\\max_{s \\in S} \\{ V_L(s) \\}$$\n\n- **路径回溯：**路径的其余部分通过从末端回溯指针找到：\n$$\\hat{q}_t = ptr_{t+1}(\\hat{q}_{t+1}) \\quad \\text{for } t = L-1, \\dots, 1$$\n\n**3. 所需统计数据的计算**\n\n一旦确定了最优路径 $\\hat{q}_{1:L}$，就为每个序列计算以下四个统计数据：\n\n- $N_H$：螺旋片段的数量。通过计算路径 $\\hat{q}_{1:L}$ 中状态 $H$ 的最大连续块的数量来计算。\n- $L_{\\max}$：最长螺旋片段的长度。这是路径 $\\hat{q}_{1:L}$ 中任何状态 $H$ 连续块的最大长度。如果不存在 $H$ 状态，则为 $0$。\n- $f_{\\text{charged}\\to H}$：被分配到状态 $H$ 的带电残基（$\\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\}$）的比例。计算方式如下：\n$$f_{\\text{charged}\\to H} = \\frac{|\\{ i \\mid x_i \\in \\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\} \\text{ and } \\hat{q}_i=H\\}|}{|\\{ i \\mid x_i \\in \\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\}\\}|}$$\n如果分母为 $0$，则该比例定义为 $0$。\n- $\\ell$：每个残基的平均对数联合概率，计算方式如下：\n$$\\ell = \\frac{1}{L} \\max_{s \\in S} \\{ V_L(s) \\}$$\n\n通过实现维特比算法和统计计算程序，我们处理4个测试序列中的每一个，以获得最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the HMM Viterbi path and statistics problem.\n    \"\"\"\n    \n    # 1. Model Definition\n    states = ['I', 'H', 'O']\n    state_map = {s: i for i, s in enumerate(states)}\n\n    # Hydropathy scale\n    h_vals = {\n        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,\n        'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,\n        'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,\n        'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2\n    }\n    amino_acids = sorted(h_vals.keys())\n    aa_map = {aa: i for i, aa in enumerate(amino_acids)}\n\n    lambda_val = 0.5\n    \n    # Emission probabilities\n    Z_H = sum(np.exp(lambda_val * val) for val in h_vals.values())\n    Z_L = sum(np.exp(-lambda_val * val) for val in h_vals.values())\n\n    log_emissions = np.zeros((len(amino_acids), len(states)))\n    for aa, i in aa_map.items():\n        h = h_vals[aa]\n        log_emissions[i, state_map['I']] = -lambda_val * h - np.log(Z_L)\n        log_emissions[i, state_map['H']] =  lambda_val * h - np.log(Z_H)\n        log_emissions[i, state_map['O']] = -lambda_val * h - np.log(Z_L)\n\n    # Transition probabilities\n    # I->I: 0.95, I->H: 0.05\n    # H->H: 0.95, H->O: 0.05\n    # O->O: 0.95, O->I: 0.05\n    log_transitions = np.full((len(states), len(states)), -np.inf)\n    log_transitions[state_map['I'], state_map['I']] = np.log(0.95)\n    log_transitions[state_map['I'], state_map['H']] = np.log(0.05)\n    log_transitions[state_map['H'], state_map['H']] = np.log(0.95)\n    log_transitions[state_map['H'], state_map['O']] = np.log(0.05)\n    log_transitions[state_map['O'], state_map['O']] = np.log(0.95)\n    log_transitions[state_map['O'], state_map['I']] = np.log(0.05)\n\n    # Initial probabilities\n    log_initial = np.array([np.log(1.0), -np.inf, -np.inf])\n\n    # 2. Viterbi Algorithm Implementation\n    def viterbi(sequence):\n        L = len(sequence)\n        num_states = len(states)\n        \n        V = np.full((L, num_states), -np.inf)\n        ptr = np.zeros((L, num_states), dtype=int)\n\n        # Initialization\n        first_aa_idx = aa_map[sequence[0]]\n        V[0, :] = log_initial + log_emissions[first_aa_idx, :]\n\n        # Recurrence\n        for t in range(1, L):\n            aa_idx = aa_map[sequence[t]]\n            for s in range(num_states):\n                prev_V = V[t - 1, :] + log_transitions[:, s]\n                V[t, s] = np.max(prev_V) + log_emissions[aa_idx, s]\n                ptr[t, s] = np.argmax(prev_V)\n        \n        # Termination\n        log_prob = np.max(V[L - 1, :])\n        path = np.zeros(L, dtype=int)\n        path[L - 1] = np.argmax(V[L - 1, :])\n        \n        # Backtracking\n        for t in range(L - 2, -1, -1):\n            path[t] = ptr[t + 1, path[t + 1]]\n            \n        return [states[i] for i in path], log_prob\n\n    # 3. Statistics Calculation\n    def calculate_stats(sequence, path, log_prob):\n        L = len(sequence)\n        \n        # N_H: Number of helix segments\n        N_H = 0\n        in_helix = False\n        for state in path:\n            if state == 'H' and not in_helix:\n                N_H += 1\n                in_helix = True\n            elif state != 'H':\n                in_helix = False\n\n        # L_max: Length of longest helix segment\n        L_max = 0\n        current_len = 0\n        for state in path:\n            if state == 'H':\n                current_len += 1\n            else:\n                L_max = max(L_max, current_len)\n                current_len = 0\n        L_max = max(L_max, current_len)\n\n        # f_charged_to_H: Fraction of charged residues in H state\n        charged_aas = {'D', 'E', 'K', 'R', 'H'}\n        total_charged = 0\n        charged_in_H = 0\n        for i, aa in enumerate(sequence):\n            if aa in charged_aas:\n                total_charged += 1\n                if path[i] == 'H':\n                    charged_in_H += 1\n        \n        f_charged_to_H = 0.0 if total_charged == 0 else charged_in_H / total_charged\n        \n        # l: Average log joint probability per residue\n        l = log_prob / L if L > 0 else 0.0\n        \n        return [N_H, L_max, round(f_charged_to_H, 3), round(l, 3)]\n\n    # 4. Test Suite\n    test_cases = [\n        \"MKK\" + \"L\" * 30 + \"A\" * 5 + \"KK\",\n        (\"VT\") * 60,\n        (\"DEKQNST\") * 20,\n        \"N\" * 7 + \"L\" * 12 + \"N\" * 7 + \"L\" * 8 + \"N\" * 7\n    ]\n    \n    all_results = []\n    for seq in test_cases:\n        path, log_p = viterbi(seq)\n        stats = calculate_stats(seq, path, log_p)\n        all_results.append(stats)\n        \n    # Format the final output string\n    case_strings = []\n    for result in all_results:\n        # Format floats to 3 decimal places\n        f_charged_str = f\"{result[2]:.3f}\"\n        l_str = f\"{result[3]:.3f}\"\n        case_strings.append(f\"[{result[0]},{result[1]},{f_charged_str},{l_str}]\")\n\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "2415695"}]}