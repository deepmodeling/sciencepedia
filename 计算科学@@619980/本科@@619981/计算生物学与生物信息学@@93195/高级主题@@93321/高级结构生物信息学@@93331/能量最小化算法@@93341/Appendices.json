{"hands_on_practices": [{"introduction": "我们的实践探索始于实现和比较两种基础的梯度优化算法：最速下降法（Steepest Descent）和共轭梯度法（Conjugate Gradient）。这个练习使用了一个简化的二次型能量模型，该模型是许多复杂分子力场的基础，旨在揭示算法设计对收敛速度的关键影响 [@problem_id:2388054]。通过观察它们在不同条件数（模拟各向异性分子运动）的系统上的显著性能差异，您将深刻体会到为何共轭梯度法等高级方法是计算生物学中不可或缺的工具。", "problem": "您的任务是设计并实现一个程序，该程序针对一系列严格凸的二次分子力学能量模型，比较两种经典的能量最小化方法——最速下降法（SD）和共轭梯度法（CG）——在从指定的初始构型开始最小化能量时的迭代次数。待最小化的能量是二次近似 $$E(\\mathbf{x})=\\tfrac{1}{2}\\,\\mathbf{x}^{\\mathsf{T}}\\mathbf{H}\\,\\mathbf{x},$$ 其中 $\\mathbf{x}\\in\\mathbb{R}^{n}$ 是相对于参考构象的笛卡尔位移，$\\mathbf{H}\\in\\mathbb{R}^{n\\times n}$ 是一个对称正定矩阵（Hessian 矩阵）。其梯度为 $\\nabla E(\\mathbf{x})=\\mathbf{H}\\,\\mathbf{x}$。两种方法之间的收敛速度比较必须通过满足指定停止准则所需的迭代次数来量化。\n\n定义和要求：\n- 设停止准则为：梯度欧几里得范数满足 $$\\lVert\\nabla E(\\mathbf{x}_{k})\\rVert_{2}\\leq \\tau\\,\\lVert\\nabla E(\\mathbf{x}_{0})\\rVert_{2},$$ 的第一个迭代索引 $k$，其中容差 $\\tau=10^{-8}$，初始状态 $\\mathbf{x}_{0}$ 定义如下。\n- 一次迭代定义为：沿当前搜索方向对 $\\mathbf{x}$ 进行一次更新，并沿该方向进行精确线搜索。对于最速下降法和共轭梯度法，第 $k$ 次迭代的步长 $\\alpha_{k}$ 是一元函数 $E(\\mathbf{x}_{k}+\\alpha\\,\\mathbf{p}_{k})$ 关于 $\\alpha\\in\\mathbb{R}$ 的唯一最小化子，其中 $\\mathbf{p}_{k}$ 是第 $k$ 次迭代时与具体方法相关的搜索方向。\n- 对于最速下降法，每次迭代的搜索方向为 $\\mathbf{p}_{k}=-\\nabla E(\\mathbf{x}_{k})$。\n- 对于共轭梯度法，搜索方向是相互 $\\mathbf{H}$-共轭的。\n\n测试套件（四个测试用例）：\n对于每个测试用例，Hessian 矩阵都是对角矩阵 $\\mathbf{H}=\\operatorname{diag}(\\lambda_{1},\\dots,\\lambda_{n})$，其元素遵循一个设定了条件数 $\\kappa$ 的几何级数：\n$$\\lambda_{i}=\\exp\\!\\Big(\\ln(\\kappa)\\cdot\\frac{i-1}{n-1}\\Big),\\quad i\\in\\{1,\\dots,n\\},$$\n使得 $\\lambda_{1}=1$ 且 $\\lambda_{n}=\\kappa$。初始状态按分量定义为\n$$x_{0,i}=\\sin(i),\\quad i\\in\\{1,\\dots,n\\},$$\n其中正弦函数以弧度为单位进行计算。所有用例的停止容差均为 $\\tau=10^{-8}$。具体的测试用例如下：\n- 用例 $1$（类螺旋，高度各向异性曲率）：$n=60$，$\\kappa=1000$。\n- 用例 $2$（类球状，中等各向异性曲率）：$n=60$，$\\kappa=10$。\n- 用例 $3$（边界情况，已达到最小化）：$n=60$，$\\kappa=50$，且 $\\mathbf{x}_{0}=\\mathbf{0}$。\n- 用例 $4$（小的良态实例）：$n=5$，$\\kappa=50$。\n\n对于每个测试用例，您的程序必须计算：\n- 最速下降法的整数迭代次数，记为 $I_{\\mathrm{SD}}$；\n- 共轭梯度法的整数迭代次数，记为 $I_{\\mathrm{CG}}$；以及\n- 整数差值 $D=I_{\\mathrm{SD}}-I_{\\mathrm{CG}}$。\n\n如果在初始状态下就满足了停止准则，则相应的迭代次数必须为 $0$。对于共轭梯度法，您不得超过 $n$ 次迭代。对于最速下降法，您不得超过 $100000$ 次迭代的安全上限；如果达到该上限时仍未满足停止准则（对于上述参数，这种情况不应发生），则返回该上限作为迭代次数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其顺序为\n$$[I_{\\mathrm{SD}}^{(1)},\\,I_{\\mathrm{CG}}^{(1)},\\,D^{(1)},\\,I_{\\mathrm{SD}}^{(2)},\\,I_{\\mathrm{CG}}^{(2)},\\,D^{(2)},\\,I_{\\mathrm{SD}}^{(3)},\\,I_{\\mathrm{CG}}^{(3)},\\,D^{(3)},\\,I_{\\mathrm{SD}}^{(4)},\\,I_{\\mathrm{CG}}^{(4)},\\,D^{(4)}],$$\n其中上标 $(j)$ 指的是测试用例 $j\\in\\{1,2,3,4\\}$。不得打印任何其他文本。", "solution": "问题陈述经过验证，被认为是科学上可靠、适定且客观的。它提出了一个标准的数值优化任务：使用两种经典的迭代方法——最速下降法（SD）和共轭梯度法（CG）来最小化一个严格凸的二次函数。所有参数、定义和条件都以足够的精度被指定，从而可以得到一个唯一且有意义的解。因此，该问题是有效的。\n\n数学问题是找到二次能量函数 $E(\\mathbf{x}): \\mathbb{R}^n \\to \\mathbb{R}$ 的最小值，其定义为：\n$$\nE(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^{\\mathsf{T}}\\mathbf{H}\\,\\mathbf{x}\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^n$ 表示笛卡尔位移，$\\mathbf{H} \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定（SPD）的 Hessian 矩阵。$\\mathbf{H}$ 的正定性确保了 $E(\\mathbf{x})$ 是严格凸的，并在 $\\mathbf{x} = \\mathbf{0}$ 处有唯一的全局最小值。优化算法所需的能量函数梯度由下式给出：\n$$\n\\nabla E(\\mathbf{x}) = \\mathbf{g}(\\mathbf{x}) = \\mathbf{H}\\mathbf{x}\n$$\n两种优化方法都从一个初始点 $\\mathbf{x}_0$ 开始，并生成一个点序列 $\\{\\mathbf{x}_k\\}$，该序列迭代地逼近最小值。更新规则的一般形式为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k$，其中 $\\mathbf{p}_k$ 是搜索方向，$\\alpha_k$ 是步长。问题指定了精确线搜索，这意味着选择 $\\alpha_k$ 以最小化关于 $\\alpha$ 的函数 $E(\\mathbf{x}_k + \\alpha \\mathbf{p}_k)$。对于给定的二次能量函数，这个最优步长有一个解析解：\n$$\n\\alpha_k = \\underset{\\alpha \\in \\mathbb{R}}{\\arg\\min}\\, E(\\mathbf{x}_k + \\alpha \\mathbf{p}_k) = -\\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbfp_k}{\\mathbf{p}_k^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_k}\n$$\n其中 $\\mathbf{g}_k = \\nabla E(\\mathbf{x}_k)$。\n\n最速下降法（SD）在每一步都采用负梯度作为其搜索方向：\n$$\n\\mathbf{p}_k = -\\mathbf{g}_k\n$$\n将此代入 $\\alpha_k$ 的公式，得到 SD 特定的步长：\n$$\n\\alpha_k^{\\mathrm{SD}} = -\\frac{\\mathbf{g}_k^{\\mathsf{T}}(-\\mathbf{g}_k)}{(-\\mathbf{g}_k)^{\\mathsf{T}}\\mathbf{H}(-\\mathbf{g}_k)} = \\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k}{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{H}\\mathbf{g}_k}\n$$\nSD 算法通过迭代更新位置 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\alpha_k^{\\mathrm{SD}}\\mathbf{g}_k$ 来进行。众所周知，随着 Hessian 矩阵条件数 $\\kappa(\\mathbf{H})$ 的增加，其收敛速度会显著下降，导致其走向最小值的路径呈现出典型的“之”字形。\n\n共轭梯度法（CG）通过选择 $\\mathbf{H}$-共轭（即对于 $i \\neq j$ 有 $\\mathbf{p}_i^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_j = 0$）的搜索方向来改进 SD 方法。这可以防止沿相同方向重复进行最小化。搜索方向在每次迭代时更新：\n$$\n\\mathbf{p}_k = -\\mathbf{g}_k + \\beta_k \\mathbf{p}_{k-1}\n$$\n且 $\\mathbf{p}_0 = -\\mathbf{g}_0$。$\\beta_k$ 的一个常见选择是 Fletcher-Reeves 公式：\n$$\n\\beta_k = \\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k}{\\mathbf{g}_{k-1}^{\\mathsf{T}}\\mathbf{g}_{k-1}}\n$$\n对于具有精确线搜索的严格凸二次函数，此选择与其他选择（如 Polak-Ribière）等价。精确线搜索的一个关键性质是，新的梯度 $\\mathbf{g}_k$ 与前一个搜索方向 $\\mathbf{p}_{k-1}$ 正交，因此 $\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{p}_{k-1} = 0$。利用这一点，CG 步长公式的分子可以简化为：\n$$\n\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{p}_k = \\mathbf{g}_k^{\\mathsf{T}}(-\\mathbf{g}_k + \\beta_k \\mathbf{p}_{k-1}) = -\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k\n$$\n因此，CG 的步长可以计算为：\n$$\n\\alpha_k^{\\mathrm{CG}} = \\frac{\\mathbf{g}_k^{\\mathsf{T}}\\mathbf{g}_k}{\\mathbf{p}_k^{\\mathsf{T}}\\mathbf{H}\\mathbf{p}_k}\n$$\nCG 方法有一个显著的特性：在精确算术中，它保证在至多 $n$ 次迭代内找到二次函数的精确最小值。\n\n两种方法的停止准则都是当梯度的欧几里得范数降至一个相对容差以下时：\n$$\n\\lVert\\mathbf{g}_k\\rVert_2 \\leq \\tau \\lVert\\mathbf{g}_0\\rVert_2\n$$\n其中 $\\mathbf{g}_k = \\nabla E(\\mathbf{x}_k)$ 且 $\\tau=10^{-8}$。从 $\\mathbf{x}_k$ 到 $\\mathbf{x}_{k+1}$ 的一次更新计为一次迭代。如果在 $\\mathbf{x}_0$ 处就满足条件，则迭代次数为 $0$。\n\n测试用例指定了一个对角 Hessian 矩阵 $\\mathbf{H} = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$，这极大地将矩阵-向量乘积 $\\mathbf{H}\\mathbf{v}$ 简化为逐元素乘积。特征值 $\\lambda_i$ 的构造是为了固定条件数 $\\kappa = \\lambda_n/\\lambda_1 = \\kappa/1 = \\kappa$。实现将利用这种对角结构来提高效率。$\\mathbf{x}_0 = \\mathbf{0}$ 的情况作为基准情况处理，由于系统已处于最小值，因此迭代次数为 $0$。\n\n我们将提供一个程序，它实现了这两种算法，将它们应用于指定的测试用例，并计算所需的迭代次数 $I_{\\mathrm{SD}}$、$I_{\\mathrm{CG}}$ 及其差值 $D$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef steepest_descent(h_diag, x0, tau, max_iter):\n    \"\"\"\n    Minimizes a quadratic form using the Steepest Descent method.\n    \"\"\"\n    x = x0.copy()\n    g = h_diag * x\n    g0_norm = np.linalg.norm(g)\n\n    # If already at the minimum, iterations = 0.\n    if g0_norm == 0:\n        return 0\n\n    threshold = tau * g0_norm\n\n    for i in range(1, max_iter + 1):\n        g_dot_g = np.dot(g, g)\n        \n        # Calculate alpha_k = (g_k^T * g_k) / (g_k^T * H * g_k)\n        # H is diagonal, so g_k^T * H * g_k = g_k^T * (h_diag * g_k)\n        g_H_g = np.dot(g, h_diag * g)\n        \n        # Avoid division by zero if gradient is effectively zero\n        if g_H_g == 0:\n            return i - 1\n\n        alpha = g_dot_g / g_H_g\n        \n        # Update position: x_{k+1} = x_k - alpha_k * g_k\n        x -= alpha * g\n        \n        # Update gradient for next iteration\n        g = h_diag * x\n        \n        if np.linalg.norm(g) = threshold:\n            return i\n            \n    return max_iter\n\ndef conjugate_gradient(h_diag, x0, tau, n):\n    \"\"\"\n    Minimizes a quadratic form using the Conjugate Gradient method.\n    \"\"\"\n    x = x0.copy()\n    g = h_diag * x\n    g0_norm = np.linalg.norm(g)\n    \n    # If already at the minimum, iterations = 0.\n    if g0_norm == 0:\n        return 0\n\n    threshold = tau * g0_norm\n    \n    p = -g\n    g_sq_norm = np.dot(g, g)\n\n    # CG is guaranteed to converge in at most n iterations for quadratics in exact arithmetic.\n    for i in range(1, n + 1):\n        # Calculate p_k^T * H * p_k\n        p_H_p = np.dot(p, h_diag * p)\n        \n        # Avoid division by zero\n        if p_H_p == 0:\n            # This can happen if p becomes zero, meaning we have likely converged\n            return i - 1\n\n        # alpha_k = (g_k^T * g_k) / (p_k^T * H * p_k)\n        alpha = g_sq_norm / p_H_p\n        \n        # Update position: x_{k+1} = x_k + alpha_k * p_k\n        x += alpha * p\n        \n        # Efficient gradient update: g_{k+1} = g_k + alpha_k * H * p_k\n        g += alpha * (h_diag * p)\n\n        if np.linalg.norm(g) = threshold:\n            return i\n\n        g_new_sq_norm = np.dot(g, g)\n        beta = g_new_sq_norm / g_sq_norm\n        \n        # Update search direction: p_{k+1} = -g_{k+1} + beta_{k+1} * p_k\n        p = -g + beta * p\n        g_sq_norm = g_new_sq_norm\n        \n    return n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (n, kappa)\n        (60, 1000.0),  # Case 1\n        (60, 10.0),    # Case 2\n        (60, 50.0),    # Case 3\n        (5, 50.0),     # Case 4\n    ]\n\n    tau = 1e-8\n    sd_max_iter = 100000\n    \n    results = []\n\n    for i, (n, kappa) in enumerate(test_cases):\n        # Construct Hessian diagonal entries\n        if n == 1:\n            # Special case to avoid division by zero in the formula for lambda_i\n            h_diag = np.array([kappa])\n        else:\n            indices = np.arange(n, dtype=float)\n            h_diag = np.exp(np.log(kappa) * indices / (n - 1))\n        \n        # Construct initial state x0\n        # Case 3 has a special x0\n        if i == 2:  # 0-indexed case 3\n            x0 = np.zeros(n)\n        else:\n            # i from 1 to n for sin(i)\n            indices_for_sin = np.arange(1, n + 1)\n            x0 = np.sin(indices_for_sin)\n\n        # Run both algorithms\n        i_sd = steepest_descent(h_diag, x0, tau, sd_max_iter)\n        i_cg = conjugate_gradient(h_diag, x0, tau, n)\n        \n        difference = i_sd - i_cg\n        \n        results.extend([i_sd, i_cg, difference])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2388054"}, {"introduction": "接下来，我们从平滑的能量景观转向离散的点格模型世界，这是研究聚合物和蛋白质折叠的有力工具。您将实现 Metropolis 蒙特卡洛算法，以在一个二维点格上寻找一个简单疏水链的低能量构象 [@problem_id:2388039]。这项实践将锻炼您在随机模拟、设计基于规则的移动集以及应用 Metropolis 准则来探索广阔构象空间并逃离局部能量陷阱方面的技能。", "problem": "考虑一个长度为 $N=5$ 的疏水聚合物链，它嵌入在一个边长为 $L$ 且具有周期性边界条件（一个环面）的二维方格晶格上。该聚合物由 $N$ 个不可区分的单体组成，占据 $N$ 个不同的晶格位点，并满足连通性约束（即连续的单体之间处于单位晶格距离，曼哈顿距离为 $1$）和自回避约束（即没有两个单体占据同一个位点）。所有单体都是疏水的，相互作用能定义如下。对于一个构象，其单体坐标为 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$，其中每个 $\\mathbf{r}_i$ 是一个由整数坐标 $(x_i,y_i)$ 表示的晶格位点，且 $x_i \\in \\{0,1,\\dots,L-1\\}$，$y_i \\in \\{0,1,\\dots,L-1\\}$。我们将非成键最近邻接触数 $C$ 定义为满足 $|i-j|1$ 且 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 之间的环面晶格距离恰好为 $1$ 的无序对 $\\{i,j\\}$ 的基数。计算两个位点 $(x,y)$ 和 $(x',y')$ 之间的环面晶格距离时，首先计算最小环绕坐标差 $\\Delta x = \\min\\{|x-x'|, L - |x-x'|\\}$ 和 $\\Delta y = \\min\\{|y-y'|, L - |y-y'|\\}$。当 $(\\Delta x=1,\\Delta y=0)$ 或 $(\\Delta x=0,\\Delta y=1)$ 时，这两个位点被定义为最近邻。能量由下式给出：\n$$\nE(\\{\\mathbf{r}_i\\}) = -\\varepsilon \\, C,\n$$\n其中 $\\varepsilon0$ 是一个固定的能量标度。在全文中，我们使用 $\\varepsilon=1$ 和玻尔兹曼常数 $k_{\\mathrm{B}}=1$，因此能量和温度都采用无量纲单位。\n\n对于每个测试用例，初始构象被确定性地指定为占据以下位点的直线水平链：\n$$\n\\mathbf{r}_i = (i \\bmod L,\\, 0), \\quad i \\in \\{0,1,2,3,4\\},\n$$\n对于所有 $L \\ge 5$，该构象都满足连通性和自回避约束。时间演化通过离散的尝试来进行，这些尝试在保持连通性和自回避的同时改变构象。在每次尝试中，会提出一个局域移动，该移动修改一个末端单体或一个内部单体的位置，但必须保持其与链上直接邻居的单位键长。如果提议的构象违反了自回避约束，则该移动被拒绝。否则，计算能量变化 $\\Delta E$，并以下列概率接受该移动：\n$$\np_{\\mathrm{acc}} = \n\\begin{cases}\n1,  \\text{if } \\Delta E \\le 0,\\\\\n\\exp(-\\Delta E/T),  \\text{if } \\Delta E  0,\n\\end{cases}\n$$\n其中 $T$ 是该测试用例的温度。如果 $T=0$，则将接受规则解释为只接受 $\\Delta E \\le 0$ 的移动。在所有访问过的构象（包括初始构象）中，持续记录遇到的最小能量。在指定的尝试次数 $M$ 之后，将找到的最小能量（以 $\\varepsilon$ 为单位）作为一个整数报告。\n\n假设每次尝试时采用以下具体的局域移动。以相等的概率选择两种移动类型之一：\n- 末端移动：以相等的概率选择一个末端单体（即索引为 $0$ 或 $N-1$）。假设其唯一的成键邻居分别是单体 $1$ 或 $N-2$。提议将所选的末端单体移动到其成键邻居的某个最近邻（在环面意义下）的空晶格位点上，该位点从所有可用位点中均匀随机选择。如果不存在这样的位点，则此次尝试为一次拒绝。\n- 拐角翻转：从索引为 $i \\in \\{1,2,3\\}$ 的内部单体中均匀随机选择一个。如果从 $\\mathbf{r}_i$ 到其成键邻居 $\\mathbf{r}_{i-1}$ 和 $\\mathbf{r}_{i+1}$ 的向量是环面上的正交单位晶格向量（即，在最小环绕坐标下，一个是 $(\\pm 1, 0)$，另一个是 $(0,\\pm 1)$），则提议将单体 $i$ 移动到同时是 $\\mathbf{r}_{i-1}$ 和 $\\mathbf{r}_{i+1}$ 最近邻的唯一另一个晶格位点，即 $\\mathbf{r}'_i = \\mathbf{r}_i + (\\mathbf{r}_{i-1} - \\mathbf{r}_i) + (\\mathbf{r}_{i+1} - \\mathbf{r}_i)$，该计算使用最小环绕位移，然后模 $L$ 约化到 $\\{0,1,\\dots,L-1\\}^2$ 范围内。如果该位点已被另一个单体占据，则此次尝试为一次拒绝。\n\n请实现上述精确定义的动力学过程并追踪最小能量。对于下面的每个测试用例，从指定的初始构象开始，运行恰好 $M$ 次独立的移动尝试，并使用指定的伪随机种子来初始化一个伪随机数生成器，以确保测试中提议的移动序列是确定性的。所有测试用例的所需输出是单行文本，其中包含找到的最小能量列表，按测试用例的指定顺序，格式为用方括号括起来的逗号分隔列表。\n\n使用以下测试套件，每个测试用例以元组 $(L,M,T,\\text{seed})$ 的形式给出，所有值按相同顺序书写：\n- 测试 A (常规探索): $(L,M,T,\\text{seed}) = (\\,6,\\,100000,\\,0.8,\\,20231102\\,)$.\n- 测试 B (无移动的边界条件): $(L,M,T,\\text{seed}) = (\\,5,\\,0,\\,0.5,\\,1\\,)$.\n- 测试 C (高温探索): $(L,M,T,\\text{seed}) = (\\,6,\\,30000,\\,5.0,\\,777\\,)$.\n- 测试 D (低温有限探索): $(L,M,T,\\text{seed}) = (\\,6,\\,5000,\\,0.2,\\,424242\\,)$.\n\n你的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，例如 $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$。请将能量以 $\\varepsilon$ 为单位，作为整数报告。", "solution": "该问题要求为一个在二维环面晶格上的自回避聚合物链实现一个梅特罗波利斯蒙特卡洛模拟。目标是为几个测试用例，在固定数量的模拟步数内，找到遇到的最小能量。该问题定义明确，科学上合理，并且计算上可行。这是计算统计物理中的一个标准问题，常用于模拟聚合物折叠。\n\n系统状态是一个由 $N=5$ 个单体组成的单条聚合物链。构象由单体坐标集 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 描述，其中每个 $\\mathbf{r}_i=(x_i, y_i)$ 是一个大小为 $L \\times L$ 且具有周期性边界条件的方格晶格上的位点。坐标是整数，$x_i, y_i \\in \\{0, 1, \\dots, L-1\\}$。链必须满足两个约束：连通性，即连续的单体 $\\mathbf{r}_i$ 和 $\\mathbf{r}_{i+1}$ 是晶格上的最近邻；以及自回避，即对于 $i \\neq j$ 有 $\\mathbf{r}_i \\neq \\mathbf{r}_j$。\n\n给定构象的能量由非成键单体之间的有利接触数量定义。具体来说，$E = -\\varepsilon C$，其中 $\\varepsilon=1$ 是能量单位，而 $C$ 是非成键最近邻接触的数量。如果一对单体 $\\{i,j\\}$ 的序列间隔大于一（即 $|i-j|  1$），并且它们在环面晶格上的空间距离恰好为 1，则它们形成一个非成键接触。两个位点 $\\mathbf{r}=(x,y)$ 和 $\\mathbf{r}'=(x',y')$ 之间的环面曼哈顿距离由 $\\min(|x-x'|, L - |x-x'|) + \\min(|y-y'|, L-|y-y'|)$ 给出。\n\n该模拟通过梅特罗波利斯-哈斯廷斯算法进行。从指定的初始构象开始，执行一系列共 $M$ 次的移动尝试。在每次尝试中，通过对当前构象应用一个局域移动来提议一个新的构象。该移动根据能量变化 $\\Delta E$ 和系统温度 $T$ 被接受或拒绝。接受概率由 $p_{\\mathrm{acc}} = \\min\\{1, \\exp(-\\Delta E/T)\\}$ 给出。对于 $T=0$ 的特殊情况，只接受不增加能量的移动（$\\Delta E \\le 0$）。在整个模拟过程中，会追踪遇到的最小能量。\n\n局域移动集被精确定义，包含两种类型的移动，在每次尝试中以相等的概率选择其中一种：\n1.  **末端移动**：选择链的两个末端单体之一（索引 $0$ 或 $N-1$）。为其提议一个新位置，该位置从其在链上成键邻居的空最近邻位点中均匀随机选择。如果不存在这样的空位点，则移动尝试被拒绝。\n2.  **拐角翻转**：选择一个内部单体 $i \\in \\{1, \\dots, N-2\\}$。如果其成键邻居 $\\mathbf{r}_{i-1}$ 和 $\\mathbf{r}_{i+1}$ 在其周围形成一个 $90$ 度角（即最小位移向量 $\\mathbf{r}_{i-1}-\\mathbf{r}_i$ 和 $\\mathbf{r}_{i+1}-\\mathbf{r}_i$ 是正交单位向量），则提议移动到所形成的 $2 \\times 2$ 正方形的第四个角。新位置是 $\\mathbf{r}'_i = \\mathbf{r}_{i-1} + \\mathbf{r}_{i+1} - \\mathbf{r}_i$，所有坐标都以 $L$ 为模。如果这个目标位点已被另一个单体占据，则移动尝试被拒绝。\n\n实现将直接遵循这些规范。对于每个测试用例，使用给定的参数 $(L, M, T, \\text{seed})$ 初始化一个模拟。初始构象是直线水平链 $\\mathbf{r}_i = (i,0)$，其中 $i \\in \\{0, \\dots, 4\\}$。一个用指定值作为种子的梅森旋转伪随机数生成器，确保了每次运行时系统的确定性演化。构象的能量通过遍历所有非成键对来计算。为了提高效率，在模拟过程中，能量变化 $\\Delta E$ 是通过仅考虑被移动的单个单体的接触来局域计算的。程序将为每个测试用例执行模拟，并报告找到的最小能量，格式如前所述。对于 $M=0$ 的测试用例，不进行任何移动尝试，报告的最小能量就是初始构象的能量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polymer folding problem by running Monte Carlo simulations\n    for a given set of test cases.\n    \"\"\"\n\n    class PolymerSimulation:\n        \"\"\"\n        A class to encapsulate the state and methods for a single\n        polymer Monte Carlo simulation.\n        \"\"\"\n        def __init__(self, L, M, T, seed):\n            self.L = L\n            self.N = 5\n            self.M = M\n            self.T = T\n            self.rng = np.random.default_rng(seed)\n            \n            # Initial conformation: r_i = (i mod L, 0)\n            self.positions = np.array([[i % self.L, 0] for i in range(self.N)], dtype=np.int32)\n            \n            self.energy = self._calculate_total_energy()\n            self.min_energy = self.energy\n\n        def _get_toroidal_displacement(self, p1, p2):\n            \"\"\"Returns the minimal displacement vector from p2 to p1 on the torus.\"\"\"\n            disp = p1 - p2\n            if disp[0] > self.L / 2:\n                disp[0] -= self.L\n            elif disp[0]  -self.L / 2:\n                disp[0] += self.L\n            \n            if disp[1] > self.L / 2:\n                disp[1] -= self.L\n            elif disp[1]  -self.L / 2:\n                disp[1] += self.L\n            return disp\n\n        def _toroidal_manhattan_dist(self, p1, p2):\n            \"\"\"Calculates the Manhattan distance on the torus.\"\"\"\n            disp = np.abs(p1 - p2)\n            dx = min(disp[0], self.L - disp[0])\n            dy = min(disp[1], self.L - disp[1])\n            return dx + dy\n\n        def _calculate_total_energy(self):\n            \"\"\"Calculates the total energy of the current conformation.\"\"\"\n            contacts = 0\n            for i in range(self.N):\n                for j in range(i + 2, self.N):  # |i-j| > 1\n                    if self._toroidal_manhattan_dist(self.positions[i], self.positions[j]) == 1:\n                        contacts += 1\n            return -contacts\n\n        def _calculate_energy_change(self, moved_idx, new_pos):\n            \"\"\"Calculates the energy change resulting from moving a single monomer.\"\"\"\n            old_pos = self.positions[moved_idx]\n            old_contacts = 0\n            new_contacts = 0\n            \n            for i in range(self.N):\n                if i == moved_idx or abs(i - moved_idx) = 1:\n                    continue\n                \n                p_other = self.positions[i]\n                if self._toroidal_manhattan_dist(old_pos, p_other) == 1:\n                    old_contacts += 1\n                if self._toroidal_manhattan_dist(new_pos, p_other) == 1:\n                    new_contacts += 1\n\n            delta_C = new_contacts - old_contacts\n            # Energy E = -eps * C with eps=1\n            return -delta_C\n\n        def run(self):\n            \"\"\"Runs the Monte Carlo simulation for M steps.\"\"\"\n            if self.M == 0:\n                return self.min_energy\n\n            for _ in range(self.M):\n                current_occupied = {tuple(p) for p in self.positions}\n                proposal = None\n\n                # Choose move family: End move or Corner flip\n                if self.rng.random()  0.5:\n                    # Propose an End Move\n                    moved_idx = 0 if self.rng.random()  0.5 else self.N - 1\n                    neighbor_idx = 1 if moved_idx == 0 else self.N - 2\n                    neighbor_pos = self.positions[neighbor_idx]\n                    \n                    available_sites = []\n                    for move in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                        site = (neighbor_pos + move) % self.L\n                        if tuple(site) not in current_occupied:\n                            available_sites.append(site)\n                    \n                    if available_sites:\n                        new_pos_coord = self.rng.choice(available_sites, axis=0)\n                        proposal = (moved_idx, new_pos_coord)\n                else:\n                    # Propose a Corner Flip\n                    moved_idx = self.rng.choice([1, 2, 3])\n                    pos_i = self.positions[moved_idx]\n                    pos_prev = self.positions[moved_idx - 1]\n                    pos_next = self.positions[moved_idx + 1]\n                    \n                    disp_prev = self._get_toroidal_displacement(pos_prev, pos_i)\n                    disp_next = self._get_toroidal_displacement(pos_next, pos_i)\n                    \n                    is_corner = (np.sum(np.abs(disp_prev)) == 1 and\n                                 np.sum(np.abs(disp_next)) == 1 and\n                                 np.dot(disp_prev, disp_next) == 0)\n                    \n                    if is_corner:\n                        new_pos = (pos_i + disp_prev + disp_next) % self.L\n                        if tuple(new_pos) not in current_occupied:\n                            proposal = (moved_idx, new_pos)\n\n                if proposal is None:\n                    continue # Attempt rejected\n\n                moved_idx, new_pos = proposal\n                \n                delta_E = self._calculate_energy_change(moved_idx, new_pos)\n                \n                accept = False\n                if self.T == 0:\n                    if delta_E = 0:\n                        accept = True\n                else:\n                    if delta_E = 0 or self.rng.random()  np.exp(-delta_E / self.T):\n                        accept = True\n                \n                if accept:\n                    self.positions[moved_idx] = new_pos\n                    self.energy += delta_E\n                    self.min_energy = min(self.min_energy, self.energy)\n            \n            return self.min_energy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, M, T, seed)\n        (6, 100000, 0.8, 20231102),\n        (5, 0, 0.5, 1),\n        (6, 30000, 5.0, 777),\n        (6, 5000, 0.2, 424242),\n    ]\n\n    results = []\n    for L, M, T, seed in test_cases:\n        sim = PolymerSimulation(L, M, T, seed)\n        min_e = sim.run()\n        results.append(int(min_e))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2388039"}, {"introduction": "我们最后的实践将介绍一种截然不同但同样强大的能量最小化方法：动态规划。我们将通过实现一个算法来解决 RNA 二级结构预测的经典问题，该算法寻找一个不断增长的 RNA 链的最小自由能（MFE）结构，从而模拟共转录折叠过程 [@problem_id:2388076]。这个练习展示了如何为具有最优子结构特性的问题找到确保的全局最优解，这是生物信息学算法设计的基石之一。", "problem": "您的任务是设计并实现一个程序，该程序在简化的能量模型下模拟共转录核糖核酸（RNA）的折叠过程。此过程通过一次添加一个核苷酸，并在每一步对结构进行重新最小化的方式进行。其核心计算任务是针对RNA二级结构的能量最小化，该问题以纯数学术语进行表述，并通过一个基于第一性原理设计的算法来解决。\n\n您必须依赖的基本原理包括：(i) RNA的经典碱基配对规则，(ii) 作为动态规划（DP）基础的最优性原理，以及 (iii) 在简化的二级结构模型中，自由能对独立结构组件的可加性。您的程序应实现这些原理，而不应引入任何非基于这些原理推导的、针对特定问题的公式。\n\n考虑一个长度为 $L$ 的RNA一级序列 $S = (S_1, S_2, \\dots, S_L)$，其中每个 $S_i \\in \\{\\text{A}, \\text{U}, \\text{G}, \\text{C}\\}$。二级结构是一个索引对的集合 $X \\subset \\{(i,j) \\mid 1 \\le i  j \\le L\\}$，并遵循以下约束条件：\n- 每个索引最多出现在一个配对中。\n- 结构是无交叉的：对于任意 $(i,j) \\in X$ 和 $(k,\\ell) \\in X$，其中 $i  k$，如果 $k  j$，则 $\\ell  j$。\n- 只允许经典配对：$(\\text{A}, \\text{U})$, $(\\text{U}, \\text{A})$, $(\\text{G}, \\text{C})$, $(\\text{C}, \\text{G})$。\n- 强制执行最小发夹环长度约束 $h \\in \\mathbb{Z}_{\\ge 0}$：如果 $j - i - 1  h$，则禁止形成配对 $(i,j)$。\n\n在简化模型下，二级结构 $X$ 的能量定义为\n$$\nE(X) \\;=\\; \\sum_{(i,j) \\in X} e_p \\;+\\; \\sum_{\\substack{(i,j) \\in X\\$i+1,j-1) \\in X}} e_s,\n$$\n其中，$e_p \\in \\mathbb{R}$ 是每对碱基的能量，$e_s \\in \\mathbb{R}$ 是为每个相邻的堆积对 $(i,j)$ 和 $(i+1,j-1)$ 增加一次的堆积能量。我们采用惯例，$e_p  0$ 且 $e_s \\le 0$，并且未配对的核苷酸贡献的能量为 $0$。\n\n对于每个前缀长度 $t \\in \\{1,2,\\dots,L\\}$，将在索引 $\\{1,\\dots,t\\}$ 上的所有有效结构的最小自由能（MFE）定义为\n$$\nM(t) \\;=\\; \\min\\{\\, E(X) \\mid X \\text{ is a valid structure on } \\{1,\\dots,t\\}\\,\\}.\n$$\n共转录折叠通过计算序列 $\\big(M(1), M(2), \\dots, M(L)\\big)$ 来建模，在每一步 $t$，新附加的核苷酸可以形成或断开配对，以便在满足上述约束条件的情况下使能量最小化。\n\n您的任务是：\n- 根据最优性原理和上述约束条件，推导出一个计算所有 $t \\in \\{1,\\dots,L\\}$ 的 $M(t)$ 的算法方案。\n- 实现一个正确且高效的程序，对于下方的每个测试用例，输出列表 $\\big(M(1), M(2), \\dots, M(L)\\big)$，并将所有值四舍五入到一位小数。\n\n测试套件。对于每个测试用例，您将获得一个序列 $S$、一个每对碱基能量 $e_p$、一个堆积能量 $e_s$ 和一个最小发夹环长度 $h$。对于所有用例，仅使用如上定义的经典配对。\n- 测试用例 1：$S=\\text{\"GCGC\"}$，$e_p=-1.0$，$e_s=-0.5$，$h=0$。\n- 测试用例 2：$S=\\text{\"AUGC\"}$，$e_p=-1.0$，$e_s=-0.5$，$h=3$。\n- 测试用例 3：$S=\\text{\"AUAU\"}$，$e_p=-1.0$，$e_s=-0.2$，$h=0$。\n- 测试用例 4：$S=\\text{\"AAAAAA\"}$，$e_p=-1.0$，$e_s=-0.5$，$h=0$。\n- 测试用例 5：$S=\\text{\"GCGC\"}$，$e_p=-1.0$，$e_s=-0.5$，$h=1$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，不含空格，并用方括号括起来。每个内部列表必须按顺序包含该测试用例的 $L$ 个四舍五入后的值 $M(1),\\dots,M(L)$。例如，格式必须类似于 $[\\,[m_{1,1},\\dots,m_{1,L_1}],[m_{2,1},\\dots,m_{2,L_2}],\\dots\\,]$，并且必须精确地打印为 \"[[...],[...],...]\"。将每个能量值四舍五入到一位小数。此问题不涉及物理单位或角度单位。", "solution": "所提出的问题是一个合理的、设定明确的科学问题，其基础是计算生物学的原理，并且可以通过严谨的算法设计来解决。它要求推导并实现一个动态规划（DP）算法，用于在简化能量模型下模拟RNA序列的共转录折叠。\n\n核心任务是计算给定RNA序列 $S$ 的所有前缀的最小自由能（MFE）。令 $S_{i \\dots j}$ 表示从索引 $i$ 到 $j$ 的子序列。长度为 $t$ 的前缀 $S_{1 \\dots t}$ 的MFE记为 $M(t)$。该值对应于整个子序列 $S_{1 \\dots t}$ 的MFE，我们可以通过解决寻找任意子序列 $S_{i \\dots j}$ 的MFE这一通用问题来找到它。\n\n最优性原理指出，一个问题的最优解包含其子问题的最优解。这是动态规划的基础。一个无交叉的RNA二级结构可以分解为更小的、独立的子结构，这使得基于DP的解决方案成为可能。所提供的能量函数 $E(X) = \\sum_{(i,j) \\in X} e_p + \\sum_{\\text{stacks}} e_s$ 是局部的和可加的，满足DP的要求。\n\n我们定义两个耦合的DP表：\n$1$. $W(i, j)$：子序列 $S_{i \\dots j}$ 上任何有效二级结构的最小自由能。\n$2$. $V(i, j)$：子序列 $S_{i \\dots j}$ 上任何有效二级结构的最小自由能，但带有明确的约束条件，即端点 $i$ 和 $j$ 形成一个碱基对。\n\n这些表中的值是针对长度递增的子序列计算的。最终所需量 $M(t)$ 由前缀 $S_{1 \\dots t}$ 的 $W(1, t)$ 给出。\n\n递推关系是通过考虑子序列 $S_{i \\dots j}$ 边界处核苷酸所有可能的结构状态推导出来的。\n\n**$W(i, j)$的递推关系**\n\n为计算 $W(i, j)$，我们考虑索引 $j$ 处核苷酸的两种互斥情况：\n$1$. **$j$ 未配对**：在这种情况下，核苷酸 $S_j$ 不贡献能量。子序列 $S_{i \\dots j}$ 的MFE与子序列 $S_{i \\dots j-1}$ 的MFE相同。因此能量为 $W(i, j-1)$。\n$2$. **$j$ 与 $k$ 配对**：核苷酸 $S_j$ 与某个核苷酸 $S_k$（其中 $i \\le k  j$）形成配对。由于无交叉约束，配对 $(k, j)$ 将子序列 $S_{i \\dots j}$ 划分为两个独立区域：外部区域 $S_{i \\dots k-1}$ 和由该配对闭合的区域 $S_{k+1 \\dots j-1}$。总能量是外部区域的MFE（即 $W(i, k-1)$）与由配对 $(k,j)$ 闭合的结构的MFE（即 $V(k, j)$）之和。我们必须对所有可能的配对伙伴 $k$ 进行最小化。\n\n结合这些情况，我们得到 $W(i, j)$ 的递推关系：\n$$\nW(i, j) = \\min \\left( W(i, j-1), \\quad \\min_{i \\le k  j, \\text{ valid pair } (k,j)} \\left\\{ W(i, k-1) + V(k, j) \\right\\} \\right)\n$$\n如果 $S_k$ 和 $S_j$ 是经典互补碱基，并且满足环长度约束 $j-k-1 \\ge h$，则配对 $(k,j)$ 是有效的。基本情况是 $W(i, i-1) = 0$（对于空子序列）和 $W(i, i) = 0$。\n\n**$V(i, j)$的递推关系**\n\n为了计算 $V(i, j)$，我们假设配对 $(i,j)$ 已经形成。如果 $(i,j)$ 不是一个有效的配对（非经典配对或 $j-i-1  h$），则 $V(i, j) = \\infty$。否则，总能量是配对 $(i,j)$ 本身的能量与内部区域 $S_{i+1 \\dots j-1}$ 的MFE之和。配对 $(i,j)$ 贡献能量 $e_p$。内部区域的结构可以是以下之一：\n$1$. **发夹环**：内部区域 $S_{i+1 \\dots j-1}$ 完全未配对。其能量贡献为 $0$。\n$2$. **堆积对**：配对 $(i, j)$ 堆积在相邻的配对 $(i+1, j-1)$ 之上。这种结构是一个配对 $(i,j)$ 包裹着一个更小的子结构，而这个子结构本身由配对 $(i+1, j-1)$ 闭合。其能量贡献是堆积能量 $e_s$ 加上由 $(i+1, j-1)$ 闭合的结构的MFE，即 $V(i+1, j-1)$。\n$3$. **多分支环**：内部区域 $S_{i+1 \\dots j-1}$ 分解为两个或多个独立的子结构。对于一个简单的分叉，该区域在某个索引 $k$（$i+1 \\le k  j-1$）处分裂成 $S_{i+1 \\dots k}$ 和 $S_{k+1 \\dots j-1}$ 上的两个独立子问题。MFE是 $W(i+1, k) + W(k+1, j-1)$ 之和。我们对所有可能的分裂点 $k$ 进行最小化。\n\n因此，$V(i,j)$ 的递推关系是：\n$$\nV(i, j) = e_p + \\min \\left( E_{\\text{hairpin}}, E_{\\text{stack}}, E_{\\text{multi}} \\right)\n$$\n其中：\n- $E_{\\text{hairpin}} = 0$\n- $E_{\\text{stack}} = e_s + V(i+1, j-1)$\n- $E_{\\text{multi}} = \\min_{i+1 \\le k  j-1} \\{W(i+1, k) + W(k+1, j-1)\\}$\n\n这些递推关系定义了一个完整的DP算法。为了模拟共转录折叠，我们迭代地应用此算法。对于每个前缀长度 $t = 1, \\dots, L$，我们求解序列 $S_{1 \\dots t}$ 的MFE，即 $W(1, t)$。这涉及到为 $S_{1 \\dots t}$ 内的所有子序列计算DP表 $W$ 和 $V$。每个测试用例的结果是这些MFE值的序列，$(M(1), M(2), \\dots, M(L))$。所提供的解决方案通过为每个前缀长度从头重新计算MFE来实现这一点。鉴于测试套件中的序列长度较小，这种 $O(L^4)$ 的方法在计算上是可行的且是正确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constant for infinity\nINF = np.inf\n\ndef get_canonical_pairs():\n    \"\"\"Returns a set of canonical RNA base pairs.\"\"\"\n    return {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G')}\n\ndef compute_mfe_for_prefix(S_prefix, ep, es, h, canonical_pairs):\n    \"\"\"\n    Computes the Minimum Free Energy (MFE) for a given RNA sequence prefix.\n\n    This function implements a dynamic programming algorithm based on the Zuker-Stankiewicz\n    model, simplified according to the problem statement.\n    \"\"\"\n    N = len(S_prefix)\n    if N == 0:\n        return 0.0\n\n    # W[i][j]: MFE for any valid structure on subsequence S[i...j]\n    W = np.full((N, N), 0.0)\n    # V[i][j]: MFE for a structure on S[i...j] that is CLOSED by pair (i,j)\n    V = np.full((N, N), INF)\n\n    # d is the length of the subsequence minus 1.\n    for d in range(1, N):\n        for i in range(N - d):\n            j = i + d\n\n            # --- Calculate V[i][j] ---\n            if (S_prefix[i], S_prefix[j]) in canonical_pairs and (j - i - 1 >= h):\n                # Hairpin loop: region i+1...j-1 is unpaired.\n                e_hairpin = 0.0\n\n                # Stacked pair: pair (i,j) stacks on (i+1,j-1)\n                e_stack = es + V[i+1][j-1] if d > 1 else INF\n\n                # Multiloop (bifurcation): internal region i+1...j-1 splits\n                e_multi = INF\n                for k in range(i + 1, j - 1):\n                    e_multi = min(e_multi, W[i+1][k] + W[k+1][j-1])\n                \n                V[i][j] = ep + min(e_hairpin, e_stack, e_multi)\n\n            # --- Calculate W[i][j] ---\n            # Case 1: j is unpaired\n            e_unpaired = W[i][j-1]\n\n            # Case 2: j is paired with some k  j\n            e_paired = INF\n            for k in range(i, j):\n                # The pair (k,j) must satisfy the min loop length\n                if V[k][j] != INF:\n                    energy_prefix = W[i][k-1] if k > i else 0.0\n                    e_paired = min(e_paired, energy_prefix + V[k][j])\n            \n            W[i][j] = min(e_unpaired, e_paired)\n    \n    return W[0][N-1] if N > 0 else 0.0\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"S\": \"GCGC\", \"ep\": -1.0, \"es\": -0.5, \"h\": 0},\n        {\"S\": \"AUGC\", \"ep\": -1.0, \"es\": -0.5, \"h\": 3},\n        {\"S\": \"AUAU\", \"ep\": -1.0, \"es\": -0.2, \"h\": 0},\n        {\"S\": \"AAAAAA\", \"ep\": -1.0, \"es\": -0.5, \"h\": 0},\n        {\"S\": \"GCGC\", \"ep\": -1.0, \"es\": -0.5, \"h\": 1},\n    ]\n\n    canonical_pairs = get_canonical_pairs()\n    all_results = []\n\n    for case in test_cases:\n        S, ep, es, h = case[\"S\"], case[\"ep\"], case[\"es\"], case[\"h\"]\n        L = len(S)\n        m_sequence = []\n        for t in range(1, L + 1):\n            prefix = S[:t]\n            mfe = compute_mfe_for_prefix(prefix, ep, es, h, canonical_pairs)\n            m_sequence.append(round(mfe, 1))\n        all_results.append(m_sequence)\n\n    # Format the final output according to problem specifications.\n    # The output is a comma-separated list of lists, with no spaces.\n    inner_lists_str = [f\"[{','.join(map(str, sublist))}]\" for sublist in all_results]\n    print(f\"[{','.join(inner_lists_str)}]\")\n\nsolve()\n```", "id": "2388076"}]}