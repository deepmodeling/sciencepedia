{"hands_on_practices": [{"introduction": "分子对接的核心挑战之一是处理配体的构象灵活性。这个练习将通过一个简单的计算，帮助你直观地理解构象搜索空间的巨大规模。通过计算一个具有多个可旋转键的配体的可能构象总数，你将体会到为何穷举搜索在现实中往往是不可行的，从而理解高效搜索算法的重要性。[@problem_id:2407471]", "problem": "要使用系统构象搜索，将一个小分子配体对接到一个刚性蛋白质的结合位点中。该配体拥有 $10$ 个独立的可旋转单键。对于每个这样的键，实验数据表明存在恰好 $3$ 个不同的、能量上稳定的旋转异构态，这些状态完全覆盖了该键的低能扭转势能面。假设：\n- 不同键的旋转异构态是相互独立的，\n- 每个键的 $3$ 个状态是互斥且穷尽的，\n- 立体化学对称性不会减少可区分的内构象的数量。\n\n在这些假设下，系统性内部搜索会枚举这 $10$ 个键上旋转异构态的所有不同分配。这次搜索生成的不同内构象的总数是多少？\n\n请以单个精确整数形式给出答案，不带单位，无需四舍五入。", "solution": "在尝试任何解答之前，应先验证问题的有效性。\n\n首先，我将从问题陈述中提取给定信息。\n1. 一个小分子配体有若干独立的可旋转单键，数量为 $N = 10$。\n2. 对于每个键，有若干不同的、能量上稳定的旋转异构态，数量为 $k = 3$。\n3. 不同键的旋转异构态是相互独立的。\n4. 每个键的 $k=3$ 个状态是互斥且穷尽的。\n5. 立体化学对称性不会减少可区分的内构象的数量。\n\n接下来，我将基于这些给定信息验证问题的有效性。\n该问题具有科学依据。可旋转键、离散旋转异构态和构象搜索等概念是计算化学和结构生物学中的基本原理，特别是在分子对接领域。独立性和离散状态空间的假设是系统搜索算法中使用的标准简化，旨在使组合问题变得易于处理。\n该问题是适定的。它提供了计算单一、明确答案所需的所有数据（$N=10$，$k=3$）和一组清晰的约束条件（键的独立性）。没有缺失或矛盾的信息。\n问题是客观的。语言精确，没有主观或推测性内容。\n\n结论是该问题有效。这是一个将组合原理直接应用于计算生物学中一个明确定义的模型的问题。\n\n解题过程如下。\n问题要求计算一个配体的不同内构象的总数。一个特定的内构象由对 $10$ 个独立可旋转键中的每一个键分配一个唯一的旋转异构态来定义。\n设可旋转键的数量为 $N$。根据问题陈述，我们有 $N = 10$。\n设每个键可用的旋转异构态数量为 $k$。问题陈述为 $k = 3$。\n问题明确指出，对任何一个给定键的旋转异构态的选择独立于对所有其他键的选择。\n\n这是一个经典的组合问题，可以使用乘法法则来解决。如果有 $k_1$ 种方法进行第一次选择，$k_2$ 种方法进行第二次选择，以此类推，直到有 $k_N$ 种方法进行第 $N$ 次选择，并且这些选择是相互独立的，那么进行这 $N$ 次选择序列的总方法数是乘积 $k_1 \\times k_2 \\times \\dots \\times k_N$。\n\n在这个具体问题中，“选择”指的是为 $N$ 个键中的每一个选择旋转异构态。\n对于第一个键，有 $k=3$ 种可能的状态。\n对于第二个键，也有 $k=3$ 种可能的状态。\n...\n对于第 $N$ 个（即第 $10$ 个）键，有 $k=3$ 种可能的状态。\n\n设 $C_{\\text{total}}$ 为不同内构象的总数。根据乘法法则，$C_{\\text{total}}$ 是 $N$ 个键每个键状态数的乘积：\n$$C_{\\text{total}} = \\underbrace{k \\times k \\times \\dots \\times k}_{N \\text{ times}}$$\n这可以表示为指数形式：\n$$C_{\\text{total}} = k^{N}$$\n代入给定值，$N = 10$ 和 $k = 3$：\n$$C_{\\text{total}} = 3^{10}$$\n我们现在计算其数值。\n$$3^2 = 9$$\n$$3^4 = (3^2)^2 = 9^2 = 81$$\n$$3^5 = 3^4 \\times 3 = 81 \\times 3 = 243$$\n$$3^{10} = (3^5)^2 = 243^2$$\n计算 $243$ 的平方：\n$$243 \\times 243 = 59049$$\n因此，通过系统搜索生成的不同内构象的总数为 $59049$。关于立体化学对称性不减少计数的假设证实了我们不需要对对称性进行任何校正，所以这个结果就是最终答案。", "answer": "$$\\boxed{59049}$$", "id": "2407471"}, {"introduction": "理解了搜索空间的挑战后，下一步是具体了解搜索算法如何工作。本练习将对接过程抽象为一个二维网格上的“玩具模型”，让你亲手操作一个简化的系统性搜索。通过在一个能量场中手动放置一个简单的“L”形配体，并计算所有有效构象的能量，你将直观地掌握网格搜索算法如何通过枚举和评分来确定最佳对接姿态。[@problem_id:2407435]", "problem": "考虑一个基于离散网格的分子对接玩具模型，该模型抽象了一个受体腔和一个小配体。受体定义在一个 $5 \\times 5$ 的整数网格单元上，行索引 $i \\in \\{1,2,3,4,5\\}$ 向下递增，列索引 $j \\in \\{1,2,3,4,5\\}$ 向右递增。受体腔仅由中心的 $3 \\times 3$ 个单元格组成，其索引为 $i \\in \\{2,3,4\\}$ 和 $j \\in \\{2,3,4\\}$。所有其他单元格都是刚性的、不可穿透的墙壁，配体的任何部分都不能占据。一个标量受体场 $E(i,j)$（每个被占据单元格的无量纲对接能量贡献）仅在受体腔单元格上定义，如下所示：\n$E(2,2) = -1$，$E(2,3) = -3$，$E(2,4) = 0$，$E(3,2) = -4$，$E(3,3) = -5$，$E(3,4) = -1$，$E(4,2) = 0$，$E(4,3) = -2$，$E(4,4) = -1$。\n\n配体是一个刚性的 $L$形三格骨牌，呈角形配置，占据 $3$ 个单位网格单元。在其正则体坐标系中，其占据的坐标为 $\\{(0,0),(1,0),(0,1)\\}$。允许进行 $0^{\\circ}$、$90^{\\circ}$、$180^{\\circ}$ 和 $270^{\\circ}$ 的刚性旋转以及整数平移。一个放置是有效的，当且仅当经过旋转和平移后，配体所占据的所有单元格都完全位于受体腔单元格 $\\{2,3,4\\} \\times \\{2,3,4\\}$ 内；禁止与墙壁有任何重叠。对于任何有效的放置，若其占据的受体单元格为 $\\{(i_{1},j_{1}),(i_{2},j_{2}),(i_{3},j_{3})\\}$，则总对接能量为\n$$U \\;=\\; \\sum_{k=1}^{3} E(i_{k},j_{k}).$$\n在所有有效放置（所有能使配体完全保持在受体腔内的旋转和平移）中，确定 $U$ 的最小可能值。最终答案以无单位的整数表示，无需四舍五入。", "solution": "该问题要求计算一个刚性L形三格骨牌配体在指定受体腔内的最小总对接能量 $U$。这是一个离散优化问题，需要对配体所有可能的有效放置进行系统性搜索。一个放置由一次平移和一次旋转定义。搜索空间是有限的，由一组允许的整数平移和四种离散旋转组成。\n\n首先，我们必须验证问题陈述的有效性。\n已知条件如下：\n- 一个 $5 \\times 5$ 的网格，索引为 $i, j \\in \\{1,2,3,4,5\\}$。\n- 一个由单元格索引 $\\mathcal{C} = \\{(i,j) \\mid i \\in \\{2,3,4\\}, j \\in \\{2,3,4\\}\\}$ 定义的受体腔。\n- 在受体腔单元格上定义的无量纲能量场 $E(i,j)$：\n$$\nE(i,j) = \n\\begin{pmatrix}\n-1 & -3 & 0 \\\\\n-4 & -5 & -1 \\\\\n0 & -2 & -1\n\\end{pmatrix}\n$$\n其中 $i,j$ 对应于索引 $\\{2,3,4\\} \\times \\{2,3,4\\}$。例如，$E(2,2) = -1$ 且 $E(3,3) = -5$。\n- 一个占据 $3$ 个单元格的刚性L形三格骨牌配体。其在其局部坐标系中的正则构型由 $\\{(0,0),(1,0),(0,1)\\}$ 给出。\n- 允许的变换为 $R \\in \\{0^\\circ, 90^\\circ, 180^\\circ, 270^\\circ\\}$ 的旋转和平移。\n- 如果配体的所有三个单元格都位于受体腔 $\\mathcal{C}$ 内，则该放置有效。\n- 有效放置的总对接能量为 $U = \\sum_{k=1}^{3} E(i_{k},j_{k})$。\n目标是找到所有有效放置中的 $\\min(U)$。\n\n问题是有效的。这是一个计算生物学领域中适定的、有科学依据的玩具问题，代表了一个简化的对接情景。所有信息都已提供，且没有矛盾之处。我们开始着手解决。\n\n解决方法是枚举配体所有可能的有效放置，计算每种放置的能量 $U$，并找出最小值。一个放置由四种旋转中的一种以及将配体定位在受体腔内的一次平移来定义。我们可以相对于一个锚点 $(i,j)$ 来定义旋转后配体的形状，然后确定哪些锚点可以得到有效的放置。\n\n设锚点 $(i,j)$ 为配体体坐标系中对应 $(0,0)$ 坐标的单元格。\n\n情况1：旋转 $R = 0^\\circ$\n配体占据单元格 $\\{(i,j), (i+1,j), (i,j+1)\\}$。为使此放置有效，必须有 $\\{i, i+1\\} \\subset \\{2,3,4\\}$ 且 $\\{j, j+1\\} \\subset \\{2,3,4\\}$。这将锚点限制在 $i \\in \\{2,3\\}$ 和 $j \\in \\{2,3\\}$。共有 $4$ 种这样的有效放置。\n- 锚点 $(2,2)$：单元格为 $\\{(2,2), (3,2), (2,3)\\}$。$U = E(2,2) + E(3,2) + E(2,3) = (-1) + (-4) + (-3) = -8$。\n- 锚点 $(2,3)$：单元格为 $\\{(2,3), (3,3), (2,4)\\}$。$U = E(2,3) + E(3,3) + E(2,4) = (-3) + (-5) + 0 = -8$。\n- 锚点 $(3,2)$：单元格为 $\\{(3,2), (4,2), (3,3)\\}$。$U = E(3,2) + E(4,2) + E(3,3) = (-4) + 0 + (-5) = -9$。\n- 锚点 $(3,3)$：单元格为 $\\{(3,3), (4,3), (3,4)\\}$。$U = E(3,3) + E(4,3) + E(3,4) = (-5) + (-2) + (-1) = -8$。\n此朝向的最低能量为 $-9$。\n\n情况2：旋转 $R = 90^\\circ$ (顺时针)\n配体形状变为 $\\{(i,j), (i+1,j), (i,j-1)\\}$。为保证有效性，必须有 $\\{i, i+1\\} \\subset \\{2,3,4\\}$ 且 $\\{j-1, j\\} \\subset \\{2,3,4\\}$。这将锚点限制在 $i \\in \\{2,3\\}$ 和 $j \\in \\{3,4\\}$。共有 $4$ 种这样的有效放置。\n- 锚点 $(2,3)$：单元格为 $\\{(2,3), (3,3), (2,2)\\}$。$U = E(2,3) + E(3,3) + E(2,2) = (-3) + (-5) + (-1) = -9$。\n- 锚点 $(2,4)$：单元格为 $\\{(2,4), (3,4), (2,3)\\}$。$U = E(2,4) + E(3,4) + E(2,3) = 0 + (-1) + (-3) = -4$。\n- 锚点 $(3,3)$：单元格为 $\\{(3,3), (4,3), (3,2)\\}$。$U = E(3,3) + E(4,3) + E(3,2) = (-5) + (-2) + (-4) = -11$。\n- 锚点 $(3,4)$：单元格为 $\\{(3,4), (4,4), (3,3)\\}$。$U = E(3,4) + E(4,4) + E(3,3) = (-1) + (-1) + (-5) = -7$。\n此朝向的最低能量为 $-11$。\n\n情况3：旋转 $R = 180^\\circ$\n配体形状变为 $\\{(i,j), (i-1,j), (i,j-1)\\}$。为保证有效性，必须有 $\\{i-1, i\\} \\subset \\{2,3,4\\}$ 且 $\\{j-1, j\\} \\subset \\{2,3,4\\}$。这将锚点限制在 $i \\in \\{3,4\\}$ 和 $j \\in \\{3,4\\}$。共有 $4$ 种这样的有效放置。\n- 锚点 $(3,3)$：单元格为 $\\{(3,3), (2,3), (3,2)\\}$。$U = E(3,3) + E(2,3) + E(3,2) = (-5) + (-3) + (-4) = -12$。\n- 锚点 $(3,4)$：单元格为 $\\{(3,4), (2,4), (3,3)\\}$。$U = E(3,4) + E(2,4) + E(3,3) = (-1) + 0 + (-5) = -6$。\n- 锚点 $(4,3)$：单元格为 $\\{(4,3), (3,3), (4,2)\\}$。$U = E(4,3) + E(3,3) + E(4,2) = (-2) + (-5) + 0 = -7$。\n- 锚点 $(4,4)$：单元格为 $\\{(4,4), (3,4), (4,3)\\}$。$U = E(4,4) + E(3,4) + E(4,3) = (-1) + (-1) + (-2) = -4$。\n此朝向的最低能量为 $-12$。\n\n情况4：旋转 $R = 270^\\circ$ (顺时针)\n配体形状变为 $\\{(i,j), (i-1,j), (i,j+1)\\}$。为保证有效性，必须有 $\\{i-1, i\\} \\subset \\{2,3,4\\}$ 且 $\\{j, j+1\\} \\subset \\{2,3,4\\}$。这将锚点限制在 $i \\in \\{3,4\\}$ 和 $j \\in \\{2,3\\}$。共有 $4$ 种这样的有效放置。\n- 锚点 $(3,2)$：单元格为 $\\{(3,2), (2,2), (3,3)\\}$。$U = E(3,2) + E(2,2) + E(3,3) = (-4) + (-1) + (-5) = -10$。\n- 锚点 $(3,3)$：单元格为 $\\{(3,3), (2,3), (3,4)\\}$。$U = E(3,3) + E(2,3) + E(3,4) = (-5) + (-3) + (-1) = -9$。\n- 锚点 $(4,2)$：单元格为 $\\{(4,2), (3,2), (4,3)\\}$。$U = E(4,2) + E(3,2) + E(4,3) = 0 + (-4) + (-2) = -6$。\n- 锚点 $(4,3)$：单元格为 $\\{(4,3), (3,3), (4,4)\\}$。$U = E(4,3) + E(3,3) + E(4,4) = (-2) + (-5) + (-1) = -8$。\n此朝向的最低能量为 $-10$。\n\n比较所有四个朝向的最低能量：$\\min\\{-9, -11, -12, -10\\}$。全局最低能量为 $-12$。这对应于配体旋转 $180^\\circ$ 并将锚点置于 $(3,3)$ 的情况，此时配体占据单元格 $(3,3)$、$(2,3)$ 和 $(3,2)$，这些单元格组合起来具有最有利的能量贡献。", "answer": "$$\\boxed{-12}$$", "id": "2407435"}, {"introduction": "从概念模拟走向实际编程，是掌握任何计算方法的关键一步。这个实践任务要求你编写代码，实现一个简化的三维网格搜索算法，并使用经典的Lennard-Jones势能函数 $V(\\mathbf{r})$ 来评估配体与蛋白质之间的相互作用。通过这个练习，你将把能量计算、参数混合规则以及空间碰撞检测等核心概念转化为可执行的程序，从而深化对分子对接算法内部工作机制的理解。[@problem_id:2407466]", "problem": "给定一个在三维（$3$D）欧几里得空间中的有限蛋白质原子坐标集，每个原子都带有 Lennard-Jones (LJ) 参数，以及一个具有自身 LJ 参数的单原子配体。对于任何候选配体位置 $\\mathbf{r} \\in \\mathbb{R}^3$，配体-蛋白质相互作用能定义为遵循 Lorentz-Berthelot 混合规则的成对 LJ 势能之和。设蛋白质有 $N$ 个原子，由 $i \\in \\{1,\\dots,N\\}$ 索引，位于固定位置 $\\mathbf{R}_i \\in \\mathbb{R}^3$，每个原子都具有参数 $\\epsilon_i > 0$ 和 $\\sigma_i > 0$。配体具有参数 $\\epsilon_L > 0$ 和 $\\sigma_L > 0$。对于给定的蛋白质原子 $i$，混合参数定义为\n$$\n\\epsilon_{iL} \\;=\\; \\sqrt{\\epsilon_i \\,\\epsilon_L},\\qquad\n\\sigma_{iL} \\;=\\; \\frac{\\sigma_i + \\sigma_L}{2}.\n$$\n对于配体位置 $\\mathbf{r}$，其与原子 $i$ 的距离为 $r_i \\;=\\; \\|\\mathbf{r}-\\mathbf{R}_i\\|_2$，成对 LJ 势能为\n$$\nV_{iL}(r_i) \\;=\\; 4\\,\\epsilon_{iL}\\left[\\left(\\frac{\\sigma_{iL}}{r_i}\\right)^{12} - \\left(\\frac{\\sigma_{iL}}{r_i}\\right)^{6}\\right],\n$$\n总能量为\n$$\nV(\\mathbf{r}) \\;=\\; \\sum_{i=1}^{N} V_{iL}\\!\\left(\\|\\mathbf{r}-\\mathbf{R}_i\\|_2\\right).\n$$\n定义一个空间位阻碰撞因子 $\\beta \\in (0,1)$，如果存在任何 $i$ 使得 $r_i < \\beta\\,\\sigma_{iL}$，则声明候选位置 $\\mathbf{r}$ 无效；否则 $\\mathbf{r}$ 是有效的。考虑一个矩形网格域\n$$\n\\mathcal{G} \\;=\\; \\left\\{(x,y,z)\\;:\\; x = x_{\\min} + k_x h,\\; y = y_{\\min} + k_y h,\\; z = z_{\\min} + k_z h,\\;\nk_x,k_y,k_z \\in \\mathbb{Z},\\; x \\le x_{\\max},\\; y \\le y_{\\max},\\; z \\le z_{\\max}\\right\\},\n$$\n其中 $h>0$ 是网格间距，边界 $[x_{\\min},x_{\\max}]$, $[y_{\\min},y_{\\max}]$, $[z_{\\min},z_{\\max}]$ 是与笛卡尔坐标轴对齐的闭区间。令 $\\mathcal{G}_{\\text{valid}} \\subseteq \\mathcal{G}$ 为有效点的子集。定义\n$$\nE^\\star \\;=\\; \\min_{\\mathbf{r} \\in \\mathcal{G}_{\\text{valid}}} V(\\mathbf{r}),\n$$\n约定如果 $\\mathcal{G}_{\\text{valid}} = \\emptyset$，则 $E^\\star = +\\infty$。所有能量必须以 Lennard-Jones 约化能量单位表示，最终数值答案必须四舍五入到 $6$ 位小数。\n\n您的任务是为以下每个测试用例计算 $E^\\star$。每个测试用例都指定了蛋白质原子、其 LJ 参数、配体的 LJ 参数、网格边界、网格间距和空间位阻碰撞因子。当一个区间的端点相等时（例如，$z_{\\min}=z_{\\max}$），网格在该轴上仅包含该单一坐标。最终要求的程序输出是单行文本，其中包含所有测试用例按顺序得出的 $E^\\star$ 值，格式为一个包含在方括号内的逗号分隔列表，例如 $[e_1,e_2,\\dots]$，其中每个 $e_j$ 是一个四舍五入到 $6$ 位小数的浮点数。\n\n测试套件：\n\n- 测试用例 $1$：\n  - 蛋白质（$N=1$）：位置 $\\mathbf{R}_1 = (0,0,0)$，参数 $\\epsilon_1 = 0.2$, $\\sigma_1 = 3.5$。\n  - 配体：$\\epsilon_L = 0.1$, $\\sigma_L = 3.0$。\n  - 网格：$x,y,z \\in [-5,5]$，间距 $h=1.0$。\n  - 空间位阻碰撞因子：$\\beta = 0.8$。\n\n- 测试用例 $2$：\n  - 蛋白质（$N=2$）：位置 $\\mathbf{R}_1 = (-2,0,0)$, $\\mathbf{R}_2 = (2,0,0)$，参数 $\\epsilon_1 = 0.2$, $\\sigma_1 = 3.5$, $\\epsilon_2 = 0.2$, $\\sigma_2 = 3.5$。\n  - 配体：$\\epsilon_L = 0.1$, $\\sigma_L = 3.0$。\n  - 网格：$x,y,z \\in [-3,3]$，间距 $h=1.0$。\n  - 空间位阻碰撞因子：$\\beta = 0.8$。\n\n- 测试用例 $3$：\n  - 蛋白质（$N=3$）：位置 $\\mathbf{R}_1 = (0,0,0)$, $\\mathbf{R}_2 = (4,0,0)$, $\\mathbf{R}_3 = (0,4,0)$，参数 $\\epsilon_1 = 0.15$, $\\sigma_1 = 3.2$；$\\epsilon_2 = 0.25$, $\\sigma_2 = 3.6$；$\\epsilon_3 = 0.30$, $\\sigma_3 = 3.0$。\n  - 配体：$\\epsilon_L = 0.2$, $\\sigma_L = 3.4$。\n  - 网格：$x,y \\in [-1,5]$，$z \\in [0,0]$，间距 $h=1.0$。\n  - 空间位阻碰撞因子：$\\beta = 0.85$。\n\n- 测试用例 $4$：\n  - 蛋白质（$N=1$）：位置 $\\mathbf{R}_1 = (1,1,1)$，参数 $\\epsilon_1 = 0.2$, $\\sigma_1 = 3.0$。\n  - 配体：$\\epsilon_L = 0.05$, $\\sigma_L = 2.5$。\n  - 网格：$x,y,z \\in [0,2]$，间距 $h=1.0$。\n  - 空间位阻碰撞因子：$\\beta = 0.75$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含按测试用例 $1$、测试用例 $2$、测试用例 $3$、测试用例 $4$ 顺序排列的结果，格式为方括号内以逗号分隔的列表。每个条目必须是四舍五入到 $6$ 位小数的浮点数，例如 $[-0.123456,-0.234567,-0.345678,-0.456789]$。", "solution": "问题陈述已经过分析并被认为是有效的。它在科学上基于分子力学的原理，特别是 Lennard-Jones 势能，并且被良好地表述为一个离散优化问题。所有定义、参数和约束都得到了明确的提供，使得问题自成一体且可解。任务是在一个有限点集上找到势能函数的最小值，这保证了解的存在性。\n\n问题要求计算一个单原子配体在固定蛋白质结构周围的指定离散位置网格 $\\mathcal{G}$ 上的最小相互作用能 $E^\\star$。解决方案是通过对网格中所有点进行系统的暴力搜索来找到的。每个测试用例的方法如下。\n\n首先，必须构建搜索域，即一个矩形网格 $\\mathcal{G}$。该网格由每个笛卡尔坐标轴上的最小和最大坐标 $[x_{\\min}, x_{\\max}]$, $[y_{\\min}, y_{\\max}]$, $[z_{\\min}, z_{\\max}]$ 以及一个均匀的网格间距 $h > 0$ 定义。网格点集合 $\\mathbf{r} = (x,y,z)$ 由下式给出：\n$$\n\\mathcal{G} = \\left\\{ (x_{\\min} + k_x h, y_{\\min} + k_y h, z_{\\min} + k_z h) \\;\\middle|\\; k_x, k_y, k_z \\in \\mathbb{Z}_{\\ge 0};\\; x \\le x_{\\max}, y \\le y_{\\max}, z \\le z_{\\max} \\right\\}.\n$$\n算法必须生成此有限集中的所有点。\n\n其次，对于每个网格点 $\\mathbf{r} \\in \\mathcal{G}$，我们必须确定它是否是配体的一个有效位置。如果一个位置与 $N$ 个蛋白质原子中的任何一个发生空间位阻碰撞，则该位置被声明为无效。根据问题定义，如果配体与蛋白质原子 $i$ 之间的距离 $r_i = \\|\\mathbf{r} - \\mathbf{R}_i\\|_2$ 小于一个指定的阈值，则发生碰撞。该阈值由因子 $\\beta \\in (0,1)$ 和混合 Lennard-Jones 半径参数 $\\sigma_{iL}$ 定义。一个位置 $\\mathbf{r}$ 是有效的，当且仅当对于所有蛋白质原子 $i \\in \\{1, \\dots, N\\}$，都满足条件\n$$\nr_i \\ge \\beta \\sigma_{iL}\n$$。\n混合参数 $\\sigma_{iL}$ 由 Lorentz-Berthelot 混合规则确定：\n$$\n\\sigma_{iL} = \\frac{\\sigma_i + \\sigma_L}{2},\n$$\n其中 $\\sigma_i$ 和 $\\sigma_L$ 分别是蛋白质原子 $i$ 和配体的 Lennard-Jones 半径。如果一个网格点被发现无效，则将其丢弃，不再进一步考虑。\n\n第三，对于每个有效网格点 $\\mathbf{r} \\in \\mathcal{G}_{\\text{valid}}$，必须计算总相互作用能 $V(\\mathbf{r})$。这个总能量是配体与每个蛋白质原子之间成对 Lennard-Jones 势能的总和：\n$$\nV(\\mathbf{r}) = \\sum_{i=1}^{N} V_{iL}(r_i),\n$$\n其中 $r_i = \\|\\mathbf{r} - \\mathbf{R}_i\\|_2$。成对势能 $V_{iL}$ 由标准的 $12$-$6$ Lennard-Jones 形式给出：\n$$\nV_{iL}(r_i) = 4 \\epsilon_{iL} \\left[ \\left(\\frac{\\sigma_{iL}}{r_i}\\right)^{12} - \\left(\\frac{\\sigma_{iL}}{r_i}\\right)^{6} \\right].\n$$\n混合能量参数 $\\epsilon_{iL}$ 也使用 Lorentz-Berthelot 混合规则计算：\n$$\n\\epsilon_{iL} = \\sqrt{\\epsilon_i \\epsilon_L},\n$$\n其中 $\\epsilon_i$ 和 $\\epsilon_L$ 是蛋白质原子 $i$ 和配体的势阱深度参数。\n\n最后，目标量 $E^\\star$ 是能量函数 $V(\\mathbf{r})$ 在所有有效网格点集合 $\\mathcal{G}_{\\text{valid}}$ 上的全局最小值：\n$$\nE^\\star = \\min_{\\mathbf{r} \\in \\mathcal{G}_{\\text{valid}}} V(\\mathbf{r}).\n$$\n为了找到这个最小值，首先将一个变量 $E_{\\min}$ 初始化为正无穷大 ($+\\infty$)。然后，遍历所有网格点。如果一个点是有效的，则计算其能量并与 $E_{\\min}$ 比较。如果新计算的能量更低，则更新 $E_{\\min}$。在处理完所有网格点之后，$E_{\\min}$ 的最终值即为所求结果 $E^\\star$。如果有效点集 $\\mathcal{G}_{\\text{valid}}$ 为空，则不执行能量计算，根据问题的约定，结果保持为 $E^\\star = +\\infty$。最终数值四舍五入到 $6$ 位小数。\n\n对每个测试用例实施此程序，以获得所需的最小能量值集合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular docking grid search problem for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"protein_atoms\": [(np.array([0.0, 0.0, 0.0]), 0.2, 3.5)],\n            \"ligand\": (0.1, 3.0),\n            \"grid_bounds\": ([-5.0, 5.0], [-5.0, 5.0], [-5.0, 5.0]),\n            \"h\": 1.0,\n            \"beta\": 0.8\n        },\n        {\n            \"protein_atoms\": [\n                (np.array([-2.0, 0.0, 0.0]), 0.2, 3.5),\n                (np.array([2.0, 0.0, 0.0]), 0.2, 3.5),\n            ],\n            \"ligand\": (0.1, 3.0),\n            \"grid_bounds\": ([-3.0, 3.0], [-3.0, 3.0], [-3.0, 3.0]),\n            \"h\": 1.0,\n            \"beta\": 0.8\n        },\n        {\n            \"protein_atoms\": [\n                (np.array([0.0, 0.0, 0.0]), 0.15, 3.2),\n                (np.array([4.0, 0.0, 0.0]), 0.25, 3.6),\n                (np.array([0.0, 4.0, 0.0]), 0.30, 3.0),\n            ],\n            \"ligand\": (0.2, 3.4),\n            \"grid_bounds\": ([-1.0, 5.0], [-1.0, 5.0], [0.0, 0.0]),\n            \"h\": 1.0,\n            \"beta\": 0.85\n        },\n        {\n            \"protein_atoms\": [(np.array([1.0, 1.0, 1.0]), 0.2, 3.0)],\n            \"ligand\": (0.05, 2.5),\n            \"grid_bounds\": ([0.0, 2.0], [0.0, 2.0], [0.0, 2.0]),\n            \"h\": 1.0,\n            \"beta\": 0.75\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        protein_atoms_data = case[\"protein_atoms\"]\n        eps_L, sig_L = case[\"ligand\"]\n        (x_min, x_max), (y_min, y_max), (z_min, z_max) = case[\"grid_bounds\"]\n        h = case[\"h\"]\n        beta = case[\"beta\"]\n\n        # Generate grid coordinates\n        # Use a small tolerance in arange to include the endpoint robustly\n        x_coords = np.arange(x_min, x_max + h/2, h)\n        y_coords = np.arange(y_min, y_max + h/2, h)\n        z_coords = np.arange(z_min, z_max + h/2, h)\n\n        # Create all grid points\n        grid_points = np.stack(np.meshgrid(x_coords, y_coords, z_coords, indexing='ij'), axis=-1).reshape(-1, 3)\n\n        # Pre-calculate mixed parameters and clash distances\n        mixed_params = []\n        for R_i, eps_i, sig_i in protein_atoms_data:\n            eps_iL = np.sqrt(eps_i * eps_L)\n            sig_iL = (sig_i + sig_L) / 2.0\n            clash_dist = beta * sig_iL\n            mixed_params.append({\n                \"R_i\": R_i,\n                \"eps_iL\": eps_iL,\n                \"sig_iL\": sig_iL,\n                \"clash_dist\": clash_dist\n            })\n\n        min_total_energy = np.inf\n\n        for r_ligand in grid_points:\n            total_energy = 0.0\n            is_valid = True\n            for params in mixed_params:\n                R_i = params[\"R_i\"]\n                eps_iL = params[\"eps_iL\"]\n                sig_iL = params[\"sig_iL\"]\n                clash_dist = params[\"clash_dist\"]\n\n                dist = np.linalg.norm(r_ligand - R_i)\n\n                # Steric clash check\n                if dist  clash_dist:\n                    is_valid = False\n                    break\n                \n                # Although clash check prevents d=0 for beta>0, it's good practice.\n                if dist == 0.0:\n                    is_valid = False\n                    break\n\n                ratio = sig_iL / dist\n                ratio6 = ratio**6\n                ratio12 = ratio6**2\n                pairwise_energy = 4.0 * eps_iL * (ratio12 - ratio6)\n                total_energy += pairwise_energy\n            \n            if is_valid:\n                min_total_energy = min(min_total_energy, total_energy)\n        \n        results.append(min_total_energy)\n\n    # Format the final output string as specified.\n    formatted_results = []\n    for res in results:\n        if np.isfinite(res):\n            formatted_results.append(f\"{res:.6f}\")\n        else:\n            # Handle the case of positive infinity\n            formatted_results.append('inf')\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2407466"}]}