{"hands_on_practices": [{"introduction": "药效团模型可以从靶蛋白的结构中推导出来，这一过程被称为受体引导或基于结构的药效团建模。其核心思想是使用虚拟化学探针探测结合位点，并识别相互作用最有利的位置，这些氢键、疏水相互作用等“热点”共同定义了药效团特征。这项练习将引导您将静电作用和范德华力等基本物理原理转化为一个具体的计算模型，从而亲手实践这一过程，深刻理解蛋白活性位点如何决定配体的结合需求 [@problem_id:2440150]。", "problem": "给定三维受体结合位点的描述，该描述由具有位置（单位：埃）、元素类型和部分电荷（无量纲）的原子组成。您的任务是通过识别三种探针类型（氢键供体 (D)、氢键受体 (A) 和疏水基团 (H)）的空间热点，来构建一个受体引导的药效团。此处，一个受体引导的药效团特征被定义为虚拟探针与受体在基于物理原理的相互作用下形成的局部能量最小值。您必须实现一个基于网格的评估方法，并为每种探针类型返回一个小的、多样化的局部最小值集合，以代表关键的相互作用点。所有最终报告的坐标必须以埃为单位表示，并四舍五入到三位小数。\n\n使用的基本原理和假设：\n- 静电相互作用遵循库仑定律：电荷间的相互作用取决于电荷的乘积和分离距离的逆幂。在非均匀介质中，使用距离依赖的介电常数是一种常见的近似方法。请使用与分离距离成正比的距离依赖介电常数，以获得静电能与分离距离的平方反比关系。\n- 短程空间位阻排斥由范德华 (vdW) 相互作用的排斥部分来描述。通过分离距离的纯排斥性十二次方反比来近似这种排斥作用。\n- 疏水效应可以通过非极性碳原子周围空间上衰减的占据偏好来近似。对于疏水探针，将其建模为以碳原子为中心的球对称高斯势阱。\n\n基于这些原理，构建一个类型为 $T \\in \\{\\mathrm{D}, \\mathrm{A}, \\mathrm{H}\\}$ 的探针在位置 $\\mathbf{x}$ 处与位于位置 $\\mathbf{r}_i$、带有电荷 $q_i$ 的受体原子（索引为 $i$）之间的相互作用能：\n- 为保证短程数值稳定性，令 $r_i(\\mathbf{x}) = \\max\\{ \\lVert \\mathbf{x} - \\mathbf{r}_i \\rVert_2, r_{\\mathrm{soft}} \\}$。\n- 静电项：$E_{\\mathrm{elec}}(\\mathbf{x}) = \\sum_i \\dfrac{q_T \\, q_i}{r_i(\\mathbf{x})^2}$，其中 $q_T$ 是探针的有效电荷：$q_{\\mathrm{D}} = +0.4$，$q_{\\mathrm{A}} = -0.4$，$q_{\\mathrm{H}} = 0.0$（无量纲）。\n- 空间排斥项：$E_{\\mathrm{rep}}(\\mathbf{x}) = \\sum_i \\dfrac{k_{\\mathrm{rep}}}{r_i(\\mathbf{x})^{12}}$，其中 $k_{\\mathrm{rep}} = 0.01$。\n- 疏水项（仅适用于疏水探针 $T = \\mathrm{H}$，且仅来源于碳原子）：$E_{\\mathrm{hyd}}(\\mathbf{x}) = - \\sum_{i \\in \\mathrm{carbons}} k_{\\mathrm{hyd}} \\, \\exp\\!\\left(-\\dfrac{r_i(\\mathbf{x})^2}{\\sigma^2}\\right)$，其中 $k_{\\mathrm{hyd}} = 0.3$ 且 $\\sigma = 2.0$。\n- 探针 $T$ 的总能量：$E_T(\\mathbf{x}) = E_{\\mathrm{elec}}(\\mathbf{x}) + E_{\\mathrm{rep}}(\\mathbf{x}) + 1_{T=\\mathrm{H}} \\, E_{\\mathrm{hyd}}(\\mathbf{x})$。\n\n数值参数和单位：\n- 设置 $r_{\\mathrm{soft}} = 0.5$ 埃。\n- 所有能量均以任意能量单位 (A.U.) 表示。您不得转换单位。\n- 网格间距为 $\\Delta = 1.0$ 埃。\n\n局部最小值的定义和选择：\n- 在一个三维网格上评估 $E_T(\\mathbf{x})$，该网格覆盖每个测试用例定义的轴对齐边界框。\n- 如果一个网格点的值严格小于其在 $3 \\times 3 \\times 3$ 立方体中除自身外的所有相邻点的值（即三维空间中的 26 个直接相邻点；对于边界点，仅与界内的相邻点比较），则该点为局部最小值。\n- 对于每种探针类型 $T$，按能量对所有局部最小值进行升序排名。\n- 通过空间聚类实现多样化：遍历排名后的最小值（从最优到最差），仅当一个候选最小值与同一类型 $T$ 的所有先前已接受的最小值之间的欧几里得距离至少为 $r_{\\mathrm{cluster}} = 1.0$ 埃时，才保留该候选者。\n- 每个测试用例的每种探针类型最多保留 $K = 3$ 个最小值，但需满足能量截断条件 $E_T(\\mathbf{x}) < E_{\\mathrm{cut},T}$，其中 $E_{\\mathrm{cut},\\mathrm{D}} = -0.03$，$E_{\\mathrm{cut},\\mathrm{A}} = -0.03$，$E_{\\mathrm{cut},\\mathrm{H}} = -0.08$ (A.U.)。\n- 报告每种探针类型所保留的最小值的坐标。\n\n测试套件（三个用例）。在每个用例中，坐标单位为埃，电荷无量纲：\n- 用例 1:\n  - 受体原子:\n    - 氧 ($\\mathrm{O}$): 位置 $(0.0, 0.0, 0.0)$, $q = -0.5$。\n    - 氮 ($\\mathrm{N}$): 位置 $(3.0, 0.0, 0.0)$, $q = +0.3$。\n    - 碳 ($\\mathrm{C}$): 位置 $(0.0, 3.0, 0.0)$, $q = 0.0$。\n    - 碳 ($\\mathrm{C}$): 位置 $(0.0, -3.0, 0.0)$, $q = 0.0$。\n  - 网格边界框: 中心 $(0.0, 0.0, 0.0)$，各轴半范围 $4.0$，间距 $\\Delta = 1.0$。\n- 用例 2:\n  - 受体原子:\n    - 氧 ($\\mathrm{O}$): 位置 $(-2.0, -2.0, 0.0)$, $q = -0.4$。\n    - 氧 ($\\mathrm{O}$): 位置 $(2.0, 2.0, 0.0)$, $q = -0.4$。\n    - 氮 ($\\mathrm{N}$): 位置 $(-2.0, 2.0, 0.0)$, $q = +0.3$。\n    - 碳 ($\\mathrm{C}$): 位置 $(0.0, 0.0, 2.0)$, $q = 0.0$。\n  - 网格边界框: 中心 $(0.0, 0.0, 0.0)$，各轴半范围 $3.0$，间距 $\\Delta = 1.0$。\n- 用例 3:\n  - 受体原子:\n    - 碳 ($\\mathrm{C}$): 位置 $(-1.5, 0.0, 0.0)$, $q = 0.0$。\n    - 碳 ($\\mathrm{C}$): 位置 $(1.5, 0.0, 0.0)$, $q = 0.0$。\n    - 碳 ($\\mathrm{C}$): 位置 $(0.0, 2.0, 0.0)$, $q = 0.0$。\n  - 网格边界框: 中心 $(0.0, 0.0, 0.0)$，各轴半范围 $3.0$，间距 $\\Delta = 1.0$。\n\n程序要求：\n- 根据上述基本原理实现能量模型，在指定网格上进行评估，按定义检测和选择局部最小值，并应用聚类和截断。\n- 对每个测试用例，生成一个包含三个列表的有序列表 $[\\mathrm{D}, \\mathrm{A}, \\mathrm{H}]$，其中每个列表是对应探针类型所选出的最小值的坐标，形式为三维点 $[x, y, z]$（单位：埃），并四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含所有三个测试用例的结果。结果应为用方括号括起来的逗号分隔列表。具体来说：一个长度为三的列表，其中每个元素本身是该测试用例的 $[\\mathrm{D}, \\mathrm{A}, \\mathrm{H}]$ 三元组。每个坐标必须四舍五入到三位小数并以埃为单位表示。所需形状示例（非实际值）：\n  - $[[[\\cdot,\\cdot,\\cdot],\\ldots],[[\\cdot,\\cdot,\\cdot],\\ldots],[[\\cdot,\\cdot,\\cdot],\\ldots]], \\ldots$ （对应三个用例）\n- 最终输出必须为单行，不含任何额外文本。所有报告的坐标必须四舍五入到三位小数（单位：埃）。", "solution": "问题陈述已经过严格验证，在科学上是合理的，在计算上是适定的。它提出了计算药物设计中的一个明确定义的任务，特别是受体引导药效团的生成。所用的物理模型虽然经过简化，但基于成熟的分子力学原理。所有必要的参数和算法步骤均已提供，使得问题明确且可解。我们着手进行解答。\n\n问题的核心是在受体的结合位点内，为三种类型的化学探针——氢键供体 ($D$)、氢键受体 ($A$) 和疏水基团 ($H$)——识别能量上有利的位置。这些有利位置，或称“热点”，被定义为势能面上的局部最小值。解决方案通过一个多步计算过程构建。\n\n### 1. 势能函数\n\n类型为 $T \\in \\{D, A, H\\}$ 的虚拟探针在位置 $\\mathbf{x}$ 处与受体原子之间的相互作用由势能函数 $E_T(\\mathbf{x})$ 建模。该函数是静电项、空间排斥项以及（对于疏水探针）疏水相互作用项的总和。设受体由索引为 $i$、位于位置 $\\mathbf{r}_i$ 并带有部分电荷 $q_i$ 的原子组成。探针与原子 $i$ 之间的距离由 $d_i(\\mathbf{x}) = \\lVert \\mathbf{x} - \\mathbf{r}_i \\rVert_2$ 给出。为防止在分离距离趋近于零时出现数值不稳定性，使用了一个软化距离 $r_i(\\mathbf{x})$：\n$$\nr_i(\\mathbf{x}) = \\max \\{ d_i(\\mathbf{x}), r_{\\mathrm{soft}} \\}\n$$\n其中软化参数为 $r_{\\mathrm{soft}} = 0.5$ 埃。\n\n总能量 $E_T(\\mathbf{x})$ 定义为：\n$$\nE_T(\\mathbf{x}) = E_{\\mathrm{elec}}(\\mathbf{x}) + E_{\\mathrm{rep}}(\\mathbf{x}) + \\delta_{TH} \\, E_{\\mathrm{hyd}}(\\mathbf{x})\n$$\n其中 $\\delta_{TH}$ 是克罗内克 delta，如果探针类型 $T$ 为 $H$，则其值为 $1$，否则为 $0$。\n\n**1.1. 静电能 ($E_{\\mathrm{elec}}$)**\n该项模拟库仑相互作用。问题指定了距离依赖的介电常数，这导致能量与分离距离呈平方反比关系。探针具有有效电荷 $q_T$。\n$$\nE_{\\mathrm{elec}}(\\mathbf{x}) = \\sum_i \\frac{q_T \\, q_i}{r_i(\\mathbf{x})^2}\n$$\n探针电荷定义为 $q_D = +0.4$，$q_A = -0.4$ 和 $q_H = 0.0$。\n\n**1.2. 空间排斥能 ($E_{\\mathrm{rep}}$)**\n该项模拟电子云之间的强短程排斥作用，这是泡利不相容原理的结果。它通过十二次方反比定律来近似，这是 Lennard-Jones 势的一个标准组成部分。\n$$\nE_{\\mathrm{rep}}(\\mathbf{x}) = \\sum_i \\frac{k_{\\mathrm{rep}}}{r_i(\\mathbf{x})^{12}}\n$$\n排斥强度常数给定为 $k_{\\mathrm{rep}} = 0.01$。\n\n**1.3. 疏水能 ($E_{\\mathrm{hyd}}$)**\n该项特定于疏水探针 ($T=H$)，用于模拟非极性基团聚集在一起以最大限度地减少对溶剂氢键网络的破坏的趋势（此处为隐式建模）。该相互作用是吸引性的，并被建模为以受体的非极性碳原子为中心的高斯势阱的总和。\n$$\nE_{\\mathrm{hyd}}(\\mathbf{x}) = - \\sum_{i \\in \\text{carbons}} k_{\\mathrm{hyd}} \\exp\\left(-\\frac{r_i(\\mathbf{x})^2}{\\sigma^2}\\right)\n$$\n该势的参数为强度 $k_{\\mathrm{hyd}} = 0.3$ 和空间范围 $\\sigma = 2.0$ 埃。\n\n### 2. 基于网格的评估\n\n为了进行计算分析，连续的势能面被离散化。对于每个测试用例，在指定的轴对齐边界框内生成一个三维点网格。网格间距是均匀的，$\\Delta = 1.0$ 埃。对于每种探针类型 $T$，在每个网格点 $\\mathbf{x}$ 处计算能量 $E_T(\\mathbfx)$，从而得到一个三维能量值数组，我们称之为能量网格。\n\n### 3. 局部最小值的识别\n\n如果一个网格点的能量值严格小于其所有直接相邻点的能量值，则该点被识别为局部最小值。对于网格内部的点，存在 $3^3 - 1 = 26$ 个这样的相邻点。对于位于网格边界、面或角上的点，仅与位于网格内的相邻点进行比较。算法遍历能量网格上的每个点并执行这些比较，以编制所有局部最小值的列表，并存储它们的网格坐标和相应的能量值。\n\n### 4. 最小值的选择与多样化\n\n必须对原始的局部最小值集合进行筛选，以产生一个小的、多样化的、代表最重要相互作用热点的集合。对于每种探针类型，这是通过一个连续的四步过程来完成的。\n\n**4.1. 能量截断：** 能量不够低的最小值将被丢弃。只有当候选最小值在位置 $\\mathbf{x}$ 处的能量 $E_T(\\mathbf{x})$ 低于特定类型的阈值时，才会被保留：\n$$\nE_T(\\mathbf{x}) < E_{\\mathrm{cut},T}\n$$\n截断值给定为 $E_{\\mathrm{cut},D} = -0.03$，$E_{\\mathrm{cut},A} = -0.03$ 和 $E_{\\mathrm{cut},H} = -0.08$（任意能量单位）。\n\n**4.2. 排名：** 将幸存的最小值按照能量值升序排序，从最有利到最不利。\n\n**4.3. 空间聚类：** 为确保药效团特征集的多样性，应用空间聚类程序。算法遍历已排序的最小值列表。第一个最小值（能量最低者）总是被接受。后续的最小值只有当其位置与该探针类型所有先前已接受的最小值之间的距离至少为 $r_{\\mathrm{cluster}} = 1.0$ 埃时才被接受。这可以防止从同一口袋或相互作用区域选择多个冗余的最小值。\n\n**4.4. 最终选择：** 此过程持续进行，直到每种探针类型最多接受 $K=3$ 个多样化的、低能量的最小值。每种探针类型的最终输出是这些选定最小值的坐标列表。如果满足所有标准的最小值少于 $K$ 个，则列表会相应地变短。坐标以埃为单位报告，并四舍五入到三位小数。\n\n将此完整过程系统地应用于问题陈述中提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the pharmacophore generation for all test cases.\n    \"\"\"\n    \n    # Define physical and numerical parameters\n    PROBE_CHARGES = {'D': 0.4, 'A': -0.4, 'H': 0.0}\n    K_REP = 0.01\n    K_HYD = 0.3\n    SIGMA_HYD = 2.0\n    R_SOFT = 0.5\n    R_CLUSTER = 1.0\n    K_MAX_MINIMA = 3\n    ENERGY_CUTOFFS = {'D': -0.03, 'A': -0.03, 'H': -0.08}\n    PROBE_TYPES = ['D', 'A', 'H']\n\n    # Define the test cases from the problem statement.\n    # Each case: {atoms: [(pos, charge, type)], grid: (center, half_extent, spacing)}\n    test_cases = [\n        {\n            \"atoms\": [\n                (np.array([0.0, 0.0, 0.0]), -0.5, 'O'),\n                (np.array([3.0, 0.0, 0.0]), 0.3, 'N'),\n                (np.array([0.0, 3.0, 0.0]), 0.0, 'C'),\n                (np.array([0.0, -3.0, 0.0]), 0.0, 'C'),\n            ],\n            \"grid\": {\"center\": np.array([0.0, 0.0, 0.0]), \"half_extent\": 4.0, \"spacing\": 1.0},\n        },\n        {\n            \"atoms\": [\n                (np.array([-2.0, -2.0, 0.0]), -0.4, 'O'),\n                (np.array([2.0, 2.0, 0.0]), -0.4, 'O'),\n                (np.array([-2.0, 2.0, 0.0]), 0.3, 'N'),\n                (np.array([0.0, 0.0, 2.0]), 0.0, 'C'),\n            ],\n            \"grid\": {\"center\": np.array([0.0, 0.0, 0.0]), \"half_extent\": 3.0, \"spacing\": 1.0},\n        },\n        {\n            \"atoms\": [\n                (np.array([-1.5, 0.0, 0.0]), 0.0, 'C'),\n                (np.array([1.5, 0.0, 0.0]), 0.0, 'C'),\n                (np.array([0.0, 2.0, 0.0]), 0.0, 'C'),\n            ],\n            \"grid\": {\"center\": np.array([0.0, 0.0, 0.0]), \"half_extent\": 3.0, \"spacing\": 1.0},\n        },\n    ]\n\n    def calculate_energy(probe_pos, probe_type, atoms):\n        \"\"\"Calculates the interaction energy for a probe at a given position.\"\"\"\n        probe_charge = PROBE_CHARGES[probe_type]\n        e_elec, e_rep, e_hyd = 0.0, 0.0, 0.0\n\n        for atom_pos, atom_charge, atom_type in atoms:\n            dist = np.linalg.norm(probe_pos - atom_pos)\n            r = max(dist, R_SOFT)\n            \n            # Electrostatic term\n            e_elec += (probe_charge * atom_charge) / (r ** 2)\n            \n            # Repulsion term\n            e_rep += K_REP / (r ** 12)\n            \n            # Hydrophobic term\n            if probe_type == 'H' and atom_type == 'C':\n                e_hyd -= K_HYD * np.exp(-(r ** 2) / (SIGMA_HYD ** 2))\n                \n        return e_elec + e_rep + e_hyd\n\n    def solve_case(case):\n        \"\"\"Solves a single test case.\"\"\"\n        atoms = case[\"atoms\"]\n        center = case[\"grid\"][\"center\"]\n        half_extent = case[\"grid\"][\"half_extent\"]\n        spacing = case[\"grid\"][\"spacing\"]\n\n        # Generate grid coordinates\n        axis_coords = np.arange(center[0] - half_extent, center[0] + half_extent + spacing / 2, spacing)\n        grid_x, grid_y, grid_z = np.meshgrid(axis_coords, axis_coords, axis_coords, indexing='ij')\n        grid_shape = grid_x.shape\n        grid_points = np.stack([grid_x, grid_y, grid_z], axis=-1)\n\n        case_results = []\n        for probe_type in PROBE_TYPES:\n            # Calculate energy on the grid\n            energy_grid = np.zeros(grid_shape)\n            for i in range(grid_shape[0]):\n                for j in range(grid_shape[1]):\n                    for k in range(grid_shape[2]):\n                        probe_pos = grid_points[i, j, k]\n                        energy_grid[i, j, k] = calculate_energy(probe_pos, probe_type, atoms)\n\n            # Find local minima\n            local_minima = []\n            for i in range(grid_shape[0]):\n                for j in range(grid_shape[1]):\n                    for k in range(grid_shape[2]):\n                        val = energy_grid[i, j, k]\n                        is_min = True\n                        for di in [-1, 0, 1]:\n                            for dj in [-1, 0, 1]:\n                                for dk in [-1, 0, 1]:\n                                    if di == 0 and dj == 0 and dk == 0:\n                                        continue\n                                    ni, nj, nk = i + di, j + dj, k + dk\n                                    if 0 <= ni < grid_shape[0] and 0 <= nj < grid_shape[1] and 0 <= nk < grid_shape[2]:\n                                        if energy_grid[ni, nj, nk] <= val:\n                                            is_min = False\n                                            break\n                                if not is_min: break\n                            if not is_min: break\n                        if is_min:\n                            local_minima.append({\n                                'coord': grid_points[i, j, k],\n                                'energy': val\n                            })\n            \n            # Filter, sort, and diversify minima\n            # 1. Energy cutoff\n            filtered_minima = [m for m in local_minima if m['energy'] < ENERGY_CUTOFFS[probe_type]]\n            \n            # 2. Sort by energy\n            sorted_minima = sorted(filtered_minima, key=lambda m: m['energy'])\n            \n            # 3. Diversify by clustering and limit to K\n            accepted_minima_coords = []\n            for minimum in sorted_minima:\n                if len(accepted_minima_coords) >= K_MAX_MINIMA:\n                    break\n                \n                is_distant_enough = True\n                for accepted_coord in accepted_minima_coords:\n                    if np.linalg.norm(minimum['coord'] - accepted_coord) < R_CLUSTER:\n                        is_distant_enough = False\n                        break\n                \n                if is_distant_enough:\n                    accepted_minima_coords.append(minimum['coord'])\n\n            case_results.append(accepted_minima_coords)\n\n        return case_results\n\n    # Process all test cases\n    all_results = [solve_case(case) for case in test_cases]\n\n    # Format the final output string\n    def format_point(p):\n        return f\"[{p[0]:.3f},{p[1]:.3f},{p[2]:.3f}]\"\n\n    def format_point_list(pl):\n        return f\"[{','.join(format_point(p) for p in pl)}]\"\n\n    def format_case_result(cr):\n        # cr is [D_points, A_points, H_points]\n        return f\"[{format_point_list(cr[0])},{format_point_list(cr[1])},{format_point_list(cr[2])}]\"\n\n    final_output_str = f\"[{','.join(format_case_result(r) for r in all_results)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2440150"}, {"introduction": "在药物发现中，我们常常会得到多个药效团模型，它们可能源于不同的活性配体。为了创建一个更普适、更稳健的模型，我们需要将它们进行整合。此练习的核心任务是在三维空间中对齐两个药效团模型，以找到它们共通特征的最大集合，并构建一个共识模型 [@problem_id:2414196]。通过完成这项练习，您将掌握一种基本的生物信息学算法，并理解如何从有限的数据中进行归纳，这对于药效团的实际应用至关重要。", "problem": "您将获得两个基于配体的药效团，每个药效团表示为一个有限的特征集合。每个特征是一个元组，由一个类别特征类型、一个三维坐标及其关联的容差半径组成。形式上，一个基于配体的药效团是一个集合 $F = \\{(t_i, \\mathbf{x}_i, r_i)\\}_{i=1}^{n}$，其中 $t_i$ 是从一个固定的有限词汇表中提取的类别特征类型（例如，氢键受体、氢键供体、疏水性、芳香环、可正离子化、可负离子化），$\\mathbf{x}_i \\in \\mathbb{R}^3$ 是三维空间中的一个点，而 $r_i \\in \\mathbb{R}_{>0}$ 是一个容差半径（所有长度单位均为埃）。我们假设两个药效团之间的刚体叠合是一种形式为 $\\mathbf{x} \\mapsto R \\mathbf{x} + \\mathbf{t}$ 的变换，其中 $R \\in \\mathbb{R}^{3 \\times 3}$ 是一个 $\\det(R) = 1$ 的正交矩阵，$\\mathbf{t} \\in \\mathbb{R}^3$。两个特征 $(t_i, \\mathbf{x}_i, r_i)$ 和 $(t_j, \\mathbf{y}_j, s_j)$ 被认为是一对匹配，当且仅当 $t_i = t_j$ 且 $\\|\\mathbf{x}_i - \\mathbf{y}_j\\|_2 \\le r_i + s_j + \\varepsilon$，其中 $\\varepsilon \\ge 0$ 是一个全局松弛参数。一个共有药效团由匹配对构成，每个匹配对创建一个共有特征。在此问题中，您只需输出您的算法所产生的匹配对数量（即共有特征的数量）。\n\n从以下基本原理出发：\n- $\\mathbb{R}^3$ 中的欧几里得范数，即 $\\|\\mathbf{x}\\|_2 = \\sqrt{x_1^2 + x_2^2 + x_3^2}$。\n- 刚体变换的定义，包括旋转 $R \\in \\mathrm{SO}(3)$ 和平移 $\\mathbf{t} \\in \\mathbb{R}^3$。\n- 两个配对点集之间的最小二乘最优刚体叠合可以通过最小化残差平方和来找到，并通过对协方差矩阵进行奇异值分解（即 Kabsch 算法）来求解，该算法源自正交 Procrustes 方法。\n- 两个集合间的一一匹配是若干不相交对的选择；在满足阈值的边中，按距离递增进行贪心选择，可以得到在该约束下的一个极大匹配。\n\n设计并实现一个算法，通过以下步骤将两个输入的药效团合并为一个共有药效团：\n- 计算初始刚体叠合：计算两个药效团共有的特征类型集合。如果至少有 $2$ 种共有类型，则对每种共有类型，计算其在每个药效团中的特征质心，然后计算使这些按类型对应的质心对齐的最小二乘最优刚体变换。否则，初始时使用单位变换。\n- 迭代优化叠合：给定当前变换，对第二个药效团进行变换，并构建所有潜在匹配的集合，这些匹配是类型相同且满足阈值 $\\|\\mathbf{x}_i - \\mathbf{y}_j\\|_2 \\le r_i + s_j + \\varepsilon$ 的特征对。通过按距离递增的贪心策略选择一个一一匹配集合（平局根据类型和索引确定性地打破）。使用 Kabsch 算法，基于匹配对的坐标（对第二个药效团使用变换前的坐标）重新计算最优刚体变换，并进行迭代，直到匹配集合不再变化或达到一个固定的较小迭代上限。\n- 对每个测试用例，输出最终迭代产生的匹配对数量。由于输出的是一个计数，因此不需要物理单位。\n\n测试套件。每个测试用例是一个三元组 $(P, Q, \\varepsilon)$，其中 $P$ 和 $Q$ 是以特征列表形式给出的药效团，特征形式为 $(\\text{类型}, \\mathbf{x}, r)$，其中 $\\mathbf{x}$ 是一个以埃为单位的三维点，$r$ 是一个以埃为单位的半径。使用以下五个测试用例：\n\n- 测试用例 1 (理想情况；多种共有类型，刚体变换带少量噪声，预期有多个匹配)：\n  - $P_1 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.6), (\\text{HBD}, \\left(2, 0, 0\\right), 0.6), (\\text{HYD}, \\left(0, 2, 0\\right), 0.6)]$\n  - $Q_1 = [(\\text{HBA}, \\left(5.02, -3.01, 1.0\\right), 0.6), (\\text{HBD}, \\left(4.97, -1.0, 1.01\\right), 0.6), (\\text{HYD}, \\left(3.01, -2.98, 0.98\\right), 0.6)]$\n  - $\\varepsilon_1 = 0.2$\n- 测试用例 2 (部分重叠；一个药效团中缺少某些类型，预期部分匹配而非全部)：\n  - $P_2 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.5), (\\text{HBD}, \\left(2, 0, 0\\right), 0.5), (\\text{HYD}, \\left(0, 2, 0\\right), 0.7), (\\text{ARO}, \\left(1, 1, 0\\right), 0.8)]$\n  - $Q_2 = [(\\text{HBA}, \\left(1.01, 0.98, 0\\right), 0.5), (\\text{HBD}, \\left(-1.0, 1.03, 0\\right), 0.5)]$\n  - $\\varepsilon_2 = 0.2$\n- 测试用例 3 (无共有类型；预期无匹配)：\n  - $P_3 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.5), (\\text{HBD}, \\left(1, 0, 0\\right), 0.5)]$\n  - $Q_3 = [(\\text{HYD}, \\left(10, 10, 0\\right), 0.5), (\\text{ARO}, \\left(11, 10, 0\\right), 0.5)]$\n  - $\\varepsilon_3 = 0.2$\n- 测试用例 4 (边界条件；一种共有类型，距离恰好在阈值上，包含等号的不等式必须算作匹配)：\n  - $P_4 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.5)]$\n  - $Q_4 = [(\\text{HBA}, \\left(1.0, 0, 0\\right), 0.4)]$\n  - $\\varepsilon_4 = 0.1$\n- 测试用例 5 (一对一约束；一个药效团中某类型特征的数量多于另一个；贪心选择应选择最近的，并使其他特征不被匹配)：\n  - $P_5 = [(\\text{HYD}, \\left(0, 0, 0\\right), 0.5), (\\text{HYD}, \\left(0.6, 0, 0\\right), 0.5)]$\n  - $Q_5 = [(\\text{HYD}, \\left(0.2, 0, 0\\right), 0.5)]$\n  - $\\varepsilon_5 = 0.1$\n\n您的程序必须实现上述算法，并为每个测试用例计算最终迭代找到的匹配对数量。您的程序应生成单行输出，包含由方括号括起来的、以逗号分隔的五个结果（例如，$[a, b, c, d, e]$）。每个测试用例的最终答案要求为整数。不应打印任何其他文本。", "solution": "所提供的问题陈述是有效的。它在科学上基于计算结构生物学和生物信息学的原理，特别是在药效团建模领域。该问题是适定的，为叠合并融合两个药效团提供了一个清晰、确定性的算法。语言客观且无歧义。给定的数据和要求的变换在物理和数学上都是合理的。\n\n任务是设计并实现一个算法，计算两个药效团 $P$ 和 $Q$ 之间匹配特征的数量。一个药效团被定义为一个特征集合 $F = \\{(t_i, \\mathbf{x}_i, r_i)\\}_{i=1}^{n}$，其中 $t_i$ 是特征类型，$\\mathbf{x}_i \\in \\mathbb{R}^3$ 是其空间坐标，$r_i$ 是容差半径。该算法涉及对应用于第二个药效团 $Q$ 的刚体叠合进行迭代优化，该叠合由一个旋转 $R \\in \\mathrm{SO}(3)$ 和一个平移 $\\mathbf{t} \\in \\mathbb{R}^3$ 组成。\n\n该方法论设计基于几个核心原则：\n\n1.  叠加与叠合原则：基本假设是，代表结合到同一靶标的配体的两个药效团在三维空间中应该是可叠加的。最优叠加是通过一个刚体变换 $\\mathbf{y} \\mapsto R\\mathbf{y} + \\mathbf{t}$ 来找到的，该变换最小化了相应特征之间的距离。问题指定使用 Kabsch 算法，该算法为两组配对点集之间的最小二乘最优刚体变换提供了解析解。给定两组各有 $N$ 个对应点的集合，表示为 $3 \\times N$ 矩阵 $P_{pts}$ 和 $Q_{pts}$，该算法首先通过减去各自的质心 $\\mathbf{p}_c$ 和 $\\mathbf{q}_c$ 来将点集中心化：\n    $$P'_{pts} = P_{pts} - \\mathbf{p}_c$$\n    $$Q'_{pts} = Q_{pts} - \\mathbf{q}_c$$\n    协方差矩阵 $H$ 计算为 $H = Q'_{pts} (P'_{pts})^T$。然后对 $H$ 进行奇异值分解 (SVD)，$H = U\\Sigma V^T$。最优旋转矩阵则为 $R = VU^T$。如果 $\\det(R) = -1$，则应用一个特殊校正以确保 $R$ 是一个纯旋转。随后，平移向量被确定为 $\\mathbf{t} = \\mathbf{p}_c - R\\mathbf{q}_c$。\n\n2.  特征保守原则：一个有意义的叠合必须尊重特征的化学性质。因此，来自药效团 $P$ 的一个特征 $(t_i, \\mathbf{x}_i, r_i)$ 只能与来自药效团 $Q$ 的一个特征 $(t_j, \\mathbf{y}_j, s_j)$ 匹配，前提是它们属于同一类型，即 $t_i = t_j$。\n\n3.  迭代优化原则：最优叠合依赖于知道特征之间的正确对应关系，但建立对应关系又需要一个良好的叠合。这个“鸡生蛋、蛋生鸡”的问题通过一个迭代过程来解决：\n    a.  基于一个粗粒度的对应关系——即共有特征类型的质心——来计算一个初始叠合。如果共有的特征类型少于两种，则使用单位变换作为起点。\n    b.  给定一个当前叠合 $(R, \\mathbf{t})$，变换药效团 $Q$ 的坐标。\n    c.  在 $P$ 和变换后的 $Q$ 之间建立一组新的一一特征匹配。这通过首先识别所有满足类型相同条件 ($t_i = t_j$) 和距离阈值 $\\|\\mathbf{x}_i - (R\\mathbf{y}_j + \\mathbf{t})\\|_2 \\le r_i + s_j + \\varepsilon$（其中 $\\varepsilon$ 是一个全局松弛参数）的潜在对来完成。从这些潜在对中，通过优先选择距离最小的对，贪心地选出一个一一匹配。\n    d.  使用 Kabsch 算法，基于新匹配特征对的原始坐标，计算一个新的、改进的叠合 $(R', \\mathbf{t}')$。\n    e.  重复此过程，直到匹配对集合在迭代之间不再变化（表明已收敛），或达到固定的迭代次数上限。\n\n4.  简约原则（贪心选择）：找到全局最优的一一匹配是一个复杂的分配问题。该算法采用了一种贪心启发式策略，该策略计算高效且在实践中行之有效。通过将所有潜在匹配按距离递增排序，并依次选择它们，同时遵守一一对应约束，该算法优先考虑了最近、最可信的配对。这个确定性的过程，加上指定的平局打破规则，确保了解决方案的唯一性。\n\n最终输出是收敛时匹配集合的基数，它代表了共有药效团的大小。实现将精确遵循这些步骤来解决提供的测试用例。", "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Use a namedtuple for features for clarity.\nFeature = namedtuple('Feature', ['type', 'coord', 'radius'])\n# Mapping for feature types to ensure deterministic sorting for tie-breaking.\nTYPE_MAP = {'HBA': 0, 'HBD': 1, 'HYD': 2, 'ARO': 3, 'PI': 4, 'NI': 5}\n# Maximum number of iterations for the refinement loop.\nMAX_ITERATIONS = 20\n\ndef kabsch_algorithm(P, Q):\n    \"\"\"\n    Computes the optimal rigid transformation (rotation R, translation t)\n    to align point set Q to point set P using the Kabsch algorithm.\n    Points are represented as column vectors.\n    :param P: A 3xN numpy array of N points in the reference set.\n    :param Q: A 3xN numpy array of N points in the mobile set.\n    :return: A tuple (R, t) where R is a 3x3 rotation matrix and t is a 3x1\n             translation vector. The transformation is: p_new = R @ p_old + t.\n    \"\"\"\n    if P.shape[1] == 0:\n        return np.identity(3), np.zeros((3, 1))\n\n    # 1. Center the point sets\n    p_cen = np.mean(P, axis=1, keepdims=True)\n    q_cen = np.mean(Q, axis=1, keepdims=True)\n    P_centered = P - p_cen\n    Q_centered = Q - q_cen\n\n    # 2. Compute covariance matrix\n    H = Q_centered @ P_centered.T\n\n    # 3. SVD\n    U, _, Vt = np.linalg.svd(H)\n\n    # 4. Compute rotation matrix\n    R = Vt.T @ U.T\n\n    # 5. Handle reflection case\n    if np.linalg.det(R) < 0:\n        Vt[2, :] *= -1\n        R = Vt.T @ U.T\n\n    # 6. Compute translation vector\n    t = p_cen - R @ q_cen\n    \n    return R, t\n\ndef solve_pharmacophore_alignment(p_pharma, q_pharma, epsilon):\n    \"\"\"\n    Merges two pharmacophores and returns the number of matched features.\n    \"\"\"\n    # 1. Initial Alignment\n    p_types = {feat.type: [] for feat in p_pharma}\n    q_types = {feat.type: [] for feat in q_pharma}\n    for feat in p_pharma:\n        p_types[feat.type].append(feat.coord)\n    for feat in q_pharma:\n        q_types[feat.type].append(feat.coord)\n    \n    shared_types = sorted(list(set(p_types.keys()) & set(q_types.keys())))\n    \n    R = np.identity(3)\n    t = np.zeros((3, 1))\n\n    if len(shared_types) >= 2:\n        p_centroids = np.array([np.mean(p_types[stype], axis=0) for stype in shared_types]).T\n        q_centroids = np.array([np.mean(q_types[stype], axis=0) for stype in shared_types]).T\n        R, t = kabsch_algorithm(p_centroids, q_centroids)\n\n    # 2. Iterative Refinement\n    last_matched_indices = None\n    \n    for _ in range(MAX_ITERATIONS):\n        q_pharma_transformed = []\n        for feat in q_pharma:\n            coord_col = feat.coord.reshape(3, 1)\n            new_coord = (R @ coord_col + t).reshape(3)\n            q_pharma_transformed.append(Feature(feat.type, new_coord, feat.radius))\n            \n        potential_matches = []\n        for p_idx, p_feat in enumerate(p_pharma):\n            for q_idx, q_feat_trans in enumerate(q_pharma_transformed):\n                if p_feat.type == q_feat_trans.type:\n                    dist = np.linalg.norm(p_feat.coord - q_feat_trans.coord)\n                    threshold = p_feat.radius + q_feat_trans.radius + epsilon\n                    if dist <= threshold:\n                        potential_matches.append((dist, TYPE_MAP[p_feat.type], p_idx, q_idx))\n        \n        potential_matches.sort()\n        \n        current_matched_indices = []\n        used_p, used_q = set(), set()\n        for _, _, p_idx, q_idx in potential_matches:\n            if p_idx not in used_p and q_idx not in used_q:\n                current_matched_indices.append((p_idx, q_idx))\n                used_p.add(p_idx)\n                used_q.add(q_idx)\n        \n        current_matched_indices.sort()\n        \n        if current_matched_indices == last_matched_indices:\n            break\n        \n        last_matched_indices = current_matched_indices\n        \n        if not current_matched_indices:\n            R, t = np.identity(3), np.zeros((3, 1))\n            continue\n            \n        p_matched_coords = np.array([p_pharma[p_idx].coord for p_idx, _ in current_matched_indices]).T\n        q_matched_coords = np.array([q_pharma[q_idx].coord for _, q_idx in current_matched_indices]).T\n        \n        R, t = kabsch_algorithm(p_matched_coords, q_matched_coords)\n        \n    return len(last_matched_indices) if last_matched_indices is not None else 0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ([('HBA', (0, 0, 0), 0.6), ('HBD', (2, 0, 0), 0.6), ('HYD', (0, 2, 0), 0.6)],\n         [('HBA', (5.02, -3.01, 1.0), 0.6), ('HBD', (4.97, -1.0, 1.01), 0.6), ('HYD', (3.01, -2.98, 0.98), 0.6)],\n         0.2),\n        # Test case 2\n        ([('HBA', (0, 0, 0), 0.5), ('HBD', (2, 0, 0), 0.5), ('HYD', (0, 2, 0), 0.7), ('ARO', (1, 1, 0), 0.8)],\n         [('HBA', (1.01, 0.98, 0), 0.5), ('HBD', (-1.0, 1.03, 0), 0.5)],\n         0.2),\n        # Test case 3\n        ([('HBA', (0, 0, 0), 0.5), ('HBD', (1, 0, 0), 0.5)],\n         [('HYD', (10, 10, 0), 0.5), ('ARO', (11, 10, 0), 0.5)],\n         0.2),\n        # Test case 4\n        ([('HBA', (0, 0, 0), 0.5)],\n         [('HBA', (1.0, 0, 0), 0.4)],\n         0.1),\n        # Test case 5\n        ([('HYD', (0, 0, 0), 0.5), ('HYD', (0.6, 0, 0), 0.5)],\n         [('HYD', (0.2, 0, 0), 0.5)],\n         0.1)\n    ]\n\n    results = []\n    for p_raw, q_raw, epsilon in test_cases:\n        p_pharma = [Feature(t, np.array(x), r) for t, x, r in p_raw]\n        q_pharma = [Feature(t, np.array(x), r) for t, x, r in q_raw]\n        num_matches = solve_pharmacophore_alignment(p_pharma, q_pharma, epsilon)\n        results.append(num_matches)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2414196"}, {"introduction": "在一个药效团模型中，并非所有特征对生物活性的贡献都同等重要。简单的几何模型将所有特征视为二元的（存在或缺失），而更强大的方法是根据特征区分活性与非活性分子的能力来对其进行加权。这项练习引入了一个贝叶斯统计框架，用于计算每个药效团特征的重要性权重，您将学习如何利用特征在活性与非活性数据集中的出现频率来推导量化其预测能力的对数优势比（log-odds ratio）[@problem_id:2414221]。这项实践将简单的几何建模与现代机器学习联系起来，教授了一种优化和量化药效团模型的强大方法。", "problem": "一个小分子的药效团模型由一组固定的二元特征表示，索引为 $j \\in \\{1,\\dots,d\\}$，其中每个特征编码了配体中是否存在一个药效团元素（例如，某个位置的氢键供体）。一个数据集包含被标记为活性或非活性的配体。对于每个特征 $j$，令 $x_{j} \\in \\{0,1\\}$ 表示配体中是否存在该特征，并令 $y \\in \\{0,1\\}$ 表示类别标签，其中 $y=1$ 表示活性，$y=0$ 表示非活性。假设使用以下概率模型：以 $y=c \\in \\{0,1\\}$ 为条件，对每个特征 $j$，$x_{j} \\mid y=c \\sim \\mathrm{Bernoulli}(\\theta^{(c)}_{j})$，其中参数 $\\theta^{(c)}_{j}$ 是未知的，并且在 $j$ 和 $c$ 之间是独立的。假设独立的Beta先验 $\\theta^{(c)}_{j} \\sim \\mathrm{Beta}(\\alpha,\\beta)$，其固定的超参数 $\\alpha>0$ 和 $\\beta>0$ 对所有 $j$ 和 $c$ 共享。对于每个特征 $j$，类别 $c$ 的训练数据被总结为总共 $N^{(c)}$ 个配体，以及其中 $x_{j}=1$ 的 $n^{(c)}_{j}$ 个配体。\n\n将特征 $j$ 的重要性权重定义为\n$$\nw_{j} \\equiv \\log\\left(\\frac{\\mathrm{odds}\\!\\left(\\mathbb{E}[\\theta^{(1)}_{j} \\mid \\text{data}]\\right)}{\\mathrm{odds}\\!\\left(\\mathbb{E}[\\theta^{(0)}_{j} \\mid \\text{data}]\\right)}\\right),\n$$\n其中对于任何 $p \\in (0,1)$，$\\mathrm{odds}(p) \\equiv \\dfrac{p}{1-p}$，并且 $\\mathbb{E}[\\theta^{(c)}_{j} \\mid \\text{data}]$ 表示在给定上述模型、先验和汇总计数的情况下，$\\theta^{(c)}_{j}$ 的后验均值。所有对数均为自然对数。一个测试用例的输出是按特征顺序排列的列表 $[w_{1},\\dots,w_{d}]$。\n\n为以下每个测试用例计算 $[w_{1},\\dots,w_{d}]$。对于每个用例，您将获得活性配体数量 $N^{(1)}$、非活性配体数量 $N^{(0)}$、活性配体计数的向量 $[n^{(1)}_{1},\\dots,n^{(1)}_{d}]$、非活性配体计数的向量 $[n^{(0)}_{1},\\dots,n^{(0)}_{d}]$，以及共享的Beta先验超参数 $(\\alpha,\\beta)$。\n\n测试套件：\n-用例 $1$：$N^{(1)}=10$，$N^{(0)}=12$，$[n^{(1)}_{j}]_{j=1}^{4} = [6,2,8,0]$，$[n^{(0)}_{j}]_{j=1}^{4} = [1,5,6,0]$，$(\\alpha,\\beta)=(0.5,0.5)$。\n-用例 $2$：$N^{(1)}=3$，$N^{(0)}=20$，$[n^{(1)}_{j}]_{j=1}^{3} = [0,3,0]$，$[n^{(0)}_{j}]_{j=1}^{3} = [10,0,1]$，$(\\alpha,\\beta)=(0.5,0.5)$。\n-用例 $3$：$N^{(1)}=50$，$N^{(0)}=50$，$[n^{(1)}_{j}]_{j=1}^{4} = [25,50,0,1]$，$[n^{(0)}_{j}]_{j=1}^{4} = [25,50,0,2]$，$(\\alpha,\\beta)=(1.0,1.0)$。\n-用例 $4$：$N^{(1)}=1$，$N^{(0)}=1$，$[n^{(1)}_{j}]_{j=1}^{2} = [1,0]$，$[n^{(0)}_{j}]_{j=1}^{2} = [0,1]$，$(\\alpha,\\beta)=(2.0,3.0)$。\n\n答案规格：\n-对于每个测试用例，计算如上定义的以自然对数为单位的向量 $[w_{1},\\dots,w_{d}]$。\n-将每个 $w_{j}$ 四舍五入到6位小数。\n-您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是该测试用例的方括号括起来的逗号分隔列表。例如，整体结构必须是 $[[r_{1,1},\\dots,r_{1,d_{1}}],[r_{2,1},\\dots,r_{2,d_{2}}],\\dots]$ 且不含空格，其中 $r_{k,\\ell}$ 表示用例 $k$ 中特征 $\\ell$ 的四舍五入值。", "solution": "问题陈述已经过验证，被认为是可接受的。它提出了一个应用于计算生物学（特别是在药效团分析背景下）的贝叶斯统计建模中的标准、适定问题。所有必要的信息均已提供，前提具有科学合理性，且没有矛盾或含糊之处。我们可以继续进行求解。\n\n该问题要求计算特征重要性权重 $w_{j}$，其定义为某个特征在活性分子与非活性分子中存在的后验平均概率的比值（odds ratio）的对数。该模型是一个朴素贝叶斯分类器，其特征服从伯努利分布，伯努利分布的参数具有Beta分布的先验。\n\n我们首先对单个参数 $\\theta^{(c)}_{j}$ 进行贝叶斯推断的形式化，该参数是类别为 $c \\in \\{0, 1\\}$ 的配体中特征 $j$ 存在（$x_j=1$）的概率。\n\n参数 $\\theta^{(c)}_{j}$ 的先验分布是具有超参数 $\\alpha$ 和 $\\beta$ 的Beta分布：\n$$\n\\theta^{(c)}_{j} \\sim \\mathrm{Beta}(\\alpha, \\beta)\n$$\n其概率密度函数（PDF）正比于：\n$$\np(\\theta^{(c)}_{j}) \\propto (\\theta^{(c)}_{j})^{\\alpha-1} (1 - \\theta^{(c)}_{j})^{\\beta-1}\n$$\n\n对于特征 $j$ 和类别 $c$ 的数据包含 $N^{(c)}$ 个配体，其中 $n^{(c)}_{j}$ 个配体具有该特征（$x_j=1$），而 $N^{(c)} - n^{(c)}_{j}$ 个配体不具有该特征（$x_j=0$）。假设配体是独立同分布的，在 $N^{(c)}$ 次试验中观察到 $n^{(c)}_{j}$ 次成功的似然遵循二项分布。$\\theta^{(c)}_{j}$ 的似然函数为：\n$$\nL(\\text{data} \\mid \\theta^{(c)}_{j}) = P(n^{(c)}_{j} \\mid N^{(c)}, \\theta^{(c)}_{j}) \\propto (\\theta^{(c)}_{j})^{n^{(c)}_{j}} (1 - \\theta^{(c)}_{j})^{N^{(c)} - n^{(c)}_{j}}\n$$\n\n根据贝叶斯定理，$\\theta^{(c)}_{j}$ 的后验分布正比于先验和似然的乘积：\n$$\np(\\theta^{(c)}_{j} \\mid \\text{data}) \\propto p(\\theta^{(c)}_{j}) \\cdot L(\\text{data} \\mid \\theta^{(c)}_{j})\n$$\n$$\np(\\theta^{(c)}_{j} \\mid \\text{data}) \\propto \\left((\\theta^{(c)}_{j})^{\\alpha-1} (1 - \\theta^{(c)}_{j})^{\\beta-1}\\right) \\cdot \\left((\\theta^{(c)}_{j})^{n^{(c)}_{j}} (1 - \\theta^{(c)}_{j})^{N^{(c)} - n^{(c)}_{j}}\\right)\n$$\n合并各项，我们得到：\n$$\np(\\theta^{(c)}_{j} \\mid \\text{data}) \\propto (\\theta^{(c)}_{j})^{n^{(c)}_{j} + \\alpha - 1} (1 - \\theta^{(c)}_{j})^{N^{(c)} - n^{(c)}_{j} + \\beta - 1}\n$$\n此表达式是Beta分布的核。这证明了Beta先验与伯努利/二项似然的共轭性。因此，后验分布为：\n$$\n\\theta^{(c)}_{j} \\mid \\text{data} \\sim \\mathrm{Beta}(\\alpha', \\beta')\n$$\n其中后验超参数 $\\alpha'$ 和 $\\beta'$ 为：\n$$\n\\alpha' = n^{(c)}_{j} + \\alpha\n$$\n$$\n\\beta' = N^{(c)} - n^{(c)}_{j} + \\beta\n$$\n\n问题要求计算后验均值 $\\mathbb{E}[\\theta^{(c)}_{j} \\mid \\text{data}]$。对于一个随机变量 $X \\sim \\mathrm{Beta}(a,b)$，其期望为 $\\mathbb{E}[X] = \\frac{a}{a+b}$。将此应用于我们的后验分布，我们得到 $\\theta^{(c)}_{j}$ 的后验均值：\n$$\n\\hat{\\theta}^{(c)}_{j} \\equiv \\mathbb{E}[\\theta^{(c)}_{j} \\mid \\text{data}] = \\frac{\\alpha'}{\\alpha' + \\beta'} = \\frac{n^{(c)}_{j} + \\alpha}{(n^{(c)}_{j} + \\alpha) + (N^{(c)} - n^{(c)}_{j} + \\beta)} = \\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} + \\alpha + \\beta}\n$$\n\n接下来，我们计算这个后验平均概率的比值（odds）。比值函数定义为 $\\mathrm{odds}(p) = \\frac{p}{1-p}$。\n对于 $\\hat{\\theta}^{(c)}_{j}$，我们有：\n$$\n1 - \\hat{\\theta}^{(c)}_{j} = 1 - \\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} + \\alpha + \\beta} = \\frac{(N^{(c)} + \\alpha + \\beta) - (n^{(c)}_{j} + \\alpha)}{N^{(c)} + \\alpha + \\beta} = \\frac{N^{(c)} - n^{(c)}_{j} + \\beta}{N^{(c)} + \\alpha + \\beta}\n$$\n因此，比值（odds）为：\n$$\n\\mathrm{odds}(\\hat{\\theta}^{(c)}_{j}) = \\frac{\\hat{\\theta}^{(c)}_{j}}{1 - \\hat{\\theta}^{(c)}_{j}} = \\frac{\\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} + \\alpha + \\beta}}{\\frac{N^{(c)} - n^{(c)}_{j} + \\beta}{N^{(c)} + \\alpha + \\beta}} = \\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} - n^{(c)}_{j} + \\beta}\n$$\n\n最后，我们将此表达式代入重要性权重 $w_{j}$ 的定义中：\n$$\nw_{j} = \\log\\left(\\frac{\\mathrm{odds}(\\hat{\\theta}^{(1)}_{j})}{\\mathrm{odds}(\\hat{\\theta}^{(0)}_{j})}\\right) = \\log\\left( \\frac{\\frac{n^{(1)}_{j} + \\alpha}{N^{(1)} - n^{(1)}_{j} + \\beta}}{\\frac{n^{(0)}_{j} + \\alpha}{N^{(0)} - n^{(0)}_{j} + \\beta}} \\right)\n$$\n利用对数的性质 $\\log(\\frac{A}{B}) = \\log(A) - \\log(B)$，这可以写成：\n$$\nw_{j} = \\log\\left(\\frac{n^{(1)}_{j} + \\alpha}{N^{(1)} - n^{(1)}_{j} + \\beta}\\right) - \\log\\left(\\frac{n^{(0)}_{j} + \\alpha}{N^{(0)} - n^{(0)}_{j} + \\beta}\\right)\n$$\n这是计算每个特征 $j$ 权重的最终运算公式。现在将此公式应用于每个给定的测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacophore feature weighting problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N1': 10, 'N0': 12, 'n1': np.array([6, 2, 8, 0]), 'n0': np.array([1, 5, 6, 0]), 'alpha': 0.5, 'beta': 0.5},\n        {'N1': 3, 'N0': 20, 'n1': np.array([0, 3, 0]), 'n0': np.array([10, 0, 1]), 'alpha': 0.5, 'beta': 0.5},\n        {'N1': 50, 'N0': 50, 'n1': np.array([25, 50, 0, 1]), 'n0': np.array([25, 50, 0, 2]), 'alpha': 1.0, 'beta': 1.0},\n        {'N1': 1, 'N0': 1, 'n1': np.array([1, 0]), 'n0': np.array([0, 1]), 'alpha': 2.0, 'beta': 3.0}\n    ]\n\n    # A helper function to compute weights for a single case.\n    def compute_weights(N1, N0, n1_vec, n0_vec, alpha, beta):\n        \"\"\"\n        Computes the importance weights w_j for a single test case.\n        \n        The formula for w_j is:\n        w_j = log(odds(E[theta_j^1|data])) - log(odds(E[theta_j^0|data]))\n            = log((n1_j + alpha) / (N1 - n1_j + beta)) - log((n0_j + alpha) / (N0 - n0_j + beta))\n        \n        Args:\n            N1 (int): Number of active ligands.\n            N0 (int): Number of inactive ligands.\n            n1_vec (np.ndarray): Counts of feature presence for active ligands.\n            n0_vec (np.ndarray): Counts of feature presence for inactive ligands.\n            alpha (float): Beta prior hyperparameter.\n            beta (float): Beta prior hyperparameter.\n        \n        Returns:\n            np.ndarray: An array of computed weights w_j.\n        \"\"\"\n        # Posterior odds for the active class (c=1)\n        odds1 = (n1_vec + alpha) / (N1 - n1_vec + beta)\n        \n        # Posterior odds for the inactive class (c=0)\n        odds0 = (n0_vec + alpha) / (N0 - n0_vec + beta)\n        \n        # Compute the log-odds ratio, which is the feature weight w_j\n        weights = np.log(odds1) - np.log(odds0)\n        \n        return weights\n\n    all_results_str = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        N1 = case['N1']\n        N0 = case['N0']\n        n1_vec = case['n1']\n        n0_vec = case['n0']\n        alpha = case['alpha']\n        beta = case['beta']\n\n        # Calculate the weights for the current case\n        weights = compute_weights(N1, N0, n1_vec, n0_vec, alpha, beta)\n        \n        # Format the results for the current case to 6 decimal places\n        case_result_str = f\"[{','.join([f'{w:.6f}' for w in weights])}]\"\n        \n        all_results_str.append(case_result_str)\n\n    # Combine all case results into the final specified format\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    # Print the final result string\n    print(final_output)\n\nsolve()\n```", "id": "2414221"}]}