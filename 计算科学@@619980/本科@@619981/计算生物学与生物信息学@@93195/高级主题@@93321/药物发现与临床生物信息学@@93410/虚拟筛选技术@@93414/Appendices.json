{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。本节的第一个练习将指导你从零开始构建一个典型的多阶段虚拟筛选流程 [@problem_id:2440164]。你将亲手实现一个从快速的二维相似性搜索，到基于三维几何的药效团过滤，再到最终的柔性对接打分的完整筛选漏斗。这个练习旨在让你掌握虚拟筛选的核心策略——如何通过分层过滤，在庞大的化合物库中高效地发现潜在的候选药物。", "problem": "请实现一个完整的三阶段连续筛选流程，该流程与虚拟筛选实践一致：首先是$2\\text{D}$相似性搜索，然后是$3\\text{D}$药效团过滤器，最后是柔性对接阶段。您的程序必须是基于以下定义和规则的确定性实现，并且必须处理一个固定的参数集测试套件。所有距离必须以埃（$\\AA$）为单位，所有角度必须以弧度表示。\n\n请从以下基本依据和核心定义开始。\n\n1. $2\\text{D}$相似性即集合相似性。将每个分子和查询表示为一个编码了分子亚结构的固定长度二进制指纹向量。设$A$和$B$为两个二进制指纹，它们被解释为比特位为$1$的索引集合。Tanimoto系数（对于二进制指纹，也称为Jaccard指数）定义为\n$$\nT(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|} \\;=\\; \\frac{c}{a + b - c},\n$$\n其中$a = |A|$，$b = |B|$，且$c = |A \\cap B|$。如果$T(A,B) \\ge \\tau_{\\mathrm{sim}}$，则一个分子通过$2\\text{D}$过滤器，其中$\\tau_{\\mathrm{sim}}$是一个给定的相似性阈值。\n\n2. $3\\text{D}$药效团即几何距离约束。一个药效团模板由一个有序的特征类型三元组及其目标配对距离指定。在本问题中，每个分子提供三个标记为$\\mathrm{DON}$（氢键供体）、$\\mathrm{ACC}$（氢键受体）和$\\mathrm{HYD}$（疏水基团）的特征点，每个点都有一个以$\\AA$为单位的三维坐标。设$d_{XY}$表示特征$X$和$Y$之间的欧几里得距离。给定目标距离$\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$和一个以$\\AA$为单位的非负容差$\\delta$，一个分子当且仅当满足以下条件时才能通过$3\\text{D}$药效团过滤器：\n$$\n|d_{\\mathrm{DA}} - d^{\\star}_{\\mathrm{DA}}| \\le \\delta,\\quad\n|d_{\\mathrm{DH}} - d^{\\star}_{\\mathrm{DH}}| \\le \\delta,\\quad\n|d_{\\mathrm{AH}} - d^{\\star}_{\\mathrm{AH}}| \\le \\delta.\n$$\n\n3. 柔性对接即通过离散内旋转最小化一个类能量得分。对于每个通过前两个阶段的分子，考虑一个具有以下组件的简化对接设置：\n- 位于固定坐标$S_{\\mathrm{DON}}$、$S_{\\mathrm{ACC}}$和$S_{\\mathrm{HYD}}$（单位为$\\AA$）的刚性受体相互作用位点。配体的$\\mathrm{DON}$特征是锚点，对于所有候选构象，该锚点都会被平移到$S_{\\mathrm{DON}}$。\n- 通过围绕穿过锚点$S_{\\mathrm{DON}}$的$z$轴的旋转来模拟单一的内部分子柔性。设$\\theta \\in \\Theta$是一个离散的旋转角度集合。对于每个$\\theta$，使用标准的$xy$平面旋转，围绕锚点旋转配体的$\\mathrm{ACC}$和$\\mathrm{HYD}$特征坐标。\n- 一个由各向同性高斯项之和定义的吸引能：\n$$\nE_{\\mathrm{attr}}(\\theta) \\;=\\; -\\,w_{\\mathrm{ACC}} \\exp\\!\\Big(\\!-\\frac{\\|R_{\\theta}(P_{\\mathrm{ACC}}-P_{\\mathrm{DON}}) + S_{\\mathrm{DON}} - S_{\\mathrm{ACC}}\\|^2}{2\\sigma^2}\\Big) \\;-\\; w_{\\mathrm{HYD}} \\exp\\!\\Big(\\!-\\frac{\\|R_{\\theta}(P_{\\mathrm{HYD}}-P_{\\mathrm{DON}}) + S_{\\mathrm{DON}} - S_{\\mathrm{HYD}}\\|^2}{2\\sigma^2}\\Big),\n$$\n其中$P_{\\mathrm{DON}}$、$P_{\\mathrm{ACC}}$和$P_{\\mathrm{HYD}}$是分子的原始特征坐标，$R_{\\theta}$是绕$z$轴旋转角度$\\theta$的旋转操作，$\\sigma > 0$是以$\\AA$为单位的长度尺度，$w_{\\mathrm{ACC}}, w_{\\mathrm{HYD}} > 0$是权重。\n- 空间位阻碰撞惩罚。给定一个中心为$C$、半径为$R_{\\mathrm{clash}}$（单位为$\\AA$）的排斥球，如果任何变换后的特征点严格位于球内，则对该$\\theta$的能量增加一个$+\\lambda_{\\mathrm{clash}}$的惩罚：\n$$\nE_{\\mathrm{clash}}(\\theta) \\;=\\; \n\\begin{cases}\n\\lambda_{\\mathrm{clash}}, & \\text{如果存在任何 } \\|Q(\\theta) - C\\| \\lt R_{\\mathrm{clash}},\\\\\n0, & \\text{否则},\n\\end{cases}\n$$\n其中$Q(\\theta)$遍历在角度$\\theta$下$\\mathrm{DON}$、$\\mathrm{ACC}$和$\\mathrm{HYD}$的变换后位置。总能量为\n$$\nE(\\theta) \\;=\\; E_{\\mathrm{attr}}(\\theta) \\;+\\; E_{\\mathrm{clash}}(\\theta).\n$$\n将一个分子的对接得分定义为$E(\\theta)$在$\\theta \\in \\Theta$上的最小值。更低（更负）的值表示更好的对接。\n\n筛选流程按顺序进行：应用$2\\text{D}$过滤器，然后是$3\\text{D}$药效团过滤器，接着为每个剩余的分子计算对接得分，并选择对接得分最低的分子。如果出现平分，选择索引最小的分子。\n\n您必须在一个固定的库和一个固定的查询上实现此筛选流程，并在下面描述的三个参数集测试套件下进行评估。对于每个参数集，您的程序必须根据上述规则输出所选分子的索引（作为一个整数），或者如果没有分子通过所有阶段最终存活，则输出$-1$。最终的程序输出必须是包含所有三个结果的单行，格式为逗号分隔的列表并用方括号括起。\n\n使用以下固定的库和查询数据。\n\n- 长度为$8$的查询指纹$F_q$：$[1,1,0,1,0,1,0,0]$。\n\n- 包含4个分子的库，索引从$0$到$3$：\n    - 分子$0$：\n        - 指纹$F_0 = [1,1,0,1,0,1,0,0]$。\n        - 特征（单位$\\AA$）：$P_{\\mathrm{DON}}=(0,0,0)$，$P_{\\mathrm{ACC}}=(3,0,0)$，$P_{\\mathrm{HYD}}=(0,4,0)$。\n    - 分子$1$：\n        - 指纹$F_1 = [1,0,1,1,0,0,1,0]$。\n        - 特征（单位$\\AA$）：$P_{\\mathrm{DON}}=(0,0,0)$，$P_{\\mathrm{ACC}}=(2.0,1.0,0)$，$P_{\\mathrm{HYD}}=(-1.0,3.5,0)$。\n    - 分子$2$：\n        - 指纹$F_2 = [0,1,0,1,1,0,0,1]$。\n        - 特征（单位$\\AA$）：$P_{\\mathrm{DON}}=(0,0,0)$，$P_{\\mathrm{ACC}}=(2.5,0.2,0)$，$P_{\\mathrm{HYD}}=(-0.5,4.2,0)$。\n    - 分子$3$：\n        - 指纹$F_3 = [0,0,0,1,0,1,0,1]$。\n        - 特征（单位$\\AA$）：$P_{\\mathrm{DON}}=(0,0,0)$，$P_{\\mathrm{ACC}}=(2.7,0,0)$，$P_{\\mathrm{HYD}}=(0,4.1,0)$。\n\n- 受体相互作用位点（单位$\\AA$）：$S_{\\mathrm{DON}}=(0,0,0)$，$S_{\\mathrm{ACC}}=(5,0,0)$，$S_{\\mathrm{HYD}}=(0,5,0)$。\n\n- 所有测试用例共用的对接参数，除非另有说明：高斯长度尺度$\\sigma=1.5\\,\\AA$，权重$w_{\\mathrm{ACC}}=1.0$，$w_{\\mathrm{HYD}}=0.8$，排斥球中心$C=(1.0,1.0,0.0)$，排斥半径$R_{\\mathrm{clash}}=1.0\\,\\AA$，惩罚$\\lambda_{\\mathrm{clash}}=50.0$，以及旋转角度集合$\\Theta$包含$24$个在$[0,2\\pi)$内均匀间隔的值。\n\n将测试套件实现为三个参数集，每个参数集指定$2\\text{D}$相似性阈值$\\tau_{\\mathrm{sim}}$、药效团目标距离$\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$（单位$\\AA$），以及药效团容差$\\delta$（单位$\\AA$）：\n- 测试用例$1$（理想路径）：$\\tau_{\\mathrm{sim}}=0.5$，$\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(3.0,4.0,5.0)$，$\\delta=0.3$。\n- 测试用例$2$（$2\\text{D}$相似性的边界包含情况）：$\\tau_{\\mathrm{sim}}=0.4$，$\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(3.0,4.0,5.0)$，$\\delta=0.3$。\n- 测试用例$3$（边缘情况，因严格的$3\\text{D}$模板而无存活分子）：$\\tau_{\\mathrm{sim}}=0.3$，$\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(2.4,2.4,2.4)$，$\\delta=0.05$。\n\n程序要求和输出格式：\n- 您的程序必须严格按照定义实现三阶段筛选流程。\n- 对于每个测试用例，计算通过所有过滤器的分子中，单个得分最佳分子的索引（从零开始）。如果该测试用例中没有分子存活，则输出$-1$。\n- 您的程序应产生单行输出，其中包含结果，格式为逗号分隔的列表并用方括号括起，例如$[r_1,r_2,r_3]$，其中每个$r_i$是测试用例$i$的整数结果。", "solution": "该问题陈述是一个有效且定义明确的计算练习，其基础是生物信息学和计算化学中的虚拟筛选原理。它是自包含的，提供了所有必要的数据、参数和数学定义。该分阶段流程模拟了一个真实（尽管简化）的筛选流程，从计算量较小的方法（$2\\text{D}$相似性）逐步过渡到计算量较大的方法（$3\\text{D}$对接）。目标是实现这个确定性流程，并为一组给定的测试参数报告最优分子的索引，如果没有任何分子通过过滤器，则报告-1。该问题在科学上是一致的，在数学上是明确的。\n\n解决方案通过遵循规定的三阶段流程来实现。\n\n阶段1：$2\\text{D}$相似性搜索\n\n此阶段根据分子与查询分子的结构相似性进行筛选，该相似性使用二进制指纹进行量化。指纹是一个由0和1组成的向量，表示特定亚结构的存在与否。两个分子（由其指纹集$A$和$B$表示）之间的相似性使用Tanimoto系数$T(A,B)$进行计算。该系数定义为集合交集的大小除以其并集的大小：\n$$\nT(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}\n$$\n问题提供了一个等效的计算公式：$T(A,B) = \\frac{c}{a + b - c}$，其中$a = |A|$，$b = |B|$，且$c = |A \\cap B|$。如果一个指纹为$F_{mol}$的分子与查询指纹$F_q$的Tanimoto系数达到或超过给定的阈值$\\tau_{\\mathrm{sim}}$，则该分子通过此过滤器：\n$$\nT(F_{mol}, F_q) \\ge \\tau_{\\mathrm{sim}}\n$$\n\n阶段2：$3\\text{D}$药效团过滤\n\n通过第一阶段的分子随后将接受基于$3\\text{D}$药效团模型的几何过滤器筛选。药效团表示分子识别所需的关键特征的空间排列。在此问题中，该模型包含三个特征——一个氢键供体（$\\mathrm{DON}$）、一个受体（$\\mathrm{ACC}$）和一个疏水基团（$\\mathrm{HYD}$）——以及它们之间的一组目标距离$\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$。如果一个分子，其自身的内部特征距离为$\\big(d_{\\mathrm{DA}}, d_{\\mathrm{DH}}, d_{\\mathrm{AH}}\\big)$，其每个内部距离与相应目标距离的差值都在指定的容差$\\delta$范围内，则该分子被视为匹配。也就是说，必须同时满足以下三个条件：\n$$\n|d_{\\mathrm{DA}} - d^{\\star}_{\\mathrm{DA}}| \\le \\delta \\\\\n|d_{\\mathrm{DH}} - d^{\\star}_{\\mathrm{DH}}| \\le \\delta \\\\\n|d_{\\mathrm{AH}} - d^{\\star}_{\\mathrm{AH}}| \\le \\delta\n$$\n距离$d_{XY}$是分子内特征$X$和$Y$坐标之间的标准欧几里得距离。\n\n阶段3：柔性对接与评分\n\n最后一个阶段评估剩余分子与一个刚性受体模型的结合情况。这个简化的对接协议涉及单一的内部分子柔性自由度和一个类能量评分函数。\n\n- **构象生成**：为每个分子生成一组构象。分子的$\\mathrm{DON}$特征被指定为锚点，并被平移至受体相应的位点$S_{\\mathrm{DON}}$。分子的其余部分随后围绕穿过此锚点的$z$轴旋转。旋转在离散的角度集合$\\Theta$上进行采样，该集合包含$[0, 2\\pi)$范围内的24个均匀间隔值。对于每个角度$\\theta \\in \\Theta$，$\\mathrm{ACC}$和$\\mathrm{HYD}$特征的坐标被变换。如果点$P_X$是分子原始坐标系中的一个特征坐标，那么在将锚点$P_{DON}$移动到$S_{DON}$并旋转后，其变换后的坐标$Q_X(\\theta)$为：\n  $$\n  Q_X(\\theta) = R_{\\theta}(P_X - P_{\\mathrm{DON}}) + S_{\\mathrm{DON}}\n  $$\n  其中$R_{\\theta}$是绕$z$轴旋转角度$\\theta$的标准$3\\text{D}$旋转矩阵。\n\n- **评分函数**：每个构象的拟合优度通过一个总能量得分$E(\\theta)$来评估，该得分是一个吸引项$E_{\\mathrm{attr}}(\\theta)$和一个空间位阻碰撞惩罚项$E_{\\mathrm{clash}}(\\theta)$的和。\n\n  吸引能被建模为负高斯函数的和，用以奖励配体特征（$\\mathrm{ACC}$、$\\mathrm{HYD}$）与它们各自的受体位点（$S_{\\mathrm{ACC}}$、$S_{\\mathrm{HYD}}$）之间的接近程度：\n  $$\n  E_{\\mathrm{attr}}(\\theta) = -w_{\\mathrm{ACC}} \\exp\\left(-\\frac{\\|Q_{\\mathrm{ACC}}(\\theta) - S_{\\mathrm{ACC}}\\|^2}{2\\sigma^2}\\right) - w_{\\mathrm{HYD}} \\exp\\left(-\\frac{\\|Q_{\\mathrm{HYD}}(\\theta) - S_{\\mathrm{HYD}}\\|^2}{2\\sigma^2}\\right)\n  $$\n  这里，$w_X$是正常数权重，$\\sigma$是定义势阱宽度的长度尺度。\n\n  如果任何变换后的特征点$Q_X(\\theta)$穿透一个以$C$为中心、半径为$R_{\\mathrm{clash}}$的球体所定义的排斥体积，则施加空间位阻碰撞惩罚。如果对于任何特征$X \\in \\{\\mathrm{DON, ACC, HYD}\\}$，有$\\|Q_X(\\theta) - C\\| < R_{\\mathrm{clash}}$，则一个大的正惩罚项$\\lambda_{\\mathrm{clash}}$将被加到该角度$\\theta$的能量中。否则，惩罚为$0$。\n  $$\n  E(\\theta) = E_{\\mathrm{attr}}(\\theta) + E_{\\mathrm{clash}}(\\theta)\n  $$\n\n- **对接得分**：一个分子的最终对接得分是在所有采样旋转中找到的最低能量构象：\n  $$\n  \\text{Score} = \\min_{\\theta \\in \\Theta} E(\\theta)\n  $$\n\n最终选择\n\n对每个测试用例，该流程被顺序执行。从通过所有三个阶段的分子集合中，对接得分最低（负值最大）的分子被选为获胜者。如果有两个或更多分子的最低得分相同，则选择原始索引较小（从$0$到$3$）的那个。如果没有分子在整个流程中存活下来，结果报告为$-1$。对所有三个提供的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs the three-stage virtual screening cascade for the given test cases.\n    \"\"\"\n    \n    # --- Fixed Data and Parameters ---\n    \n    # Query fingerprint\n    F_Q = np.array([1, 1, 0, 1, 0, 1, 0, 0], dtype=int)\n\n    # Library of molecules\n    MOLECULES = [\n        {\n            \"id\": 0,\n            \"fp\": np.array([1, 1, 0, 1, 0, 1, 0, 0], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([3.0, 0.0, 0.0]),\n                \"HYD\": np.array([0.0, 4.0, 0.0]),\n            },\n        },\n        {\n            \"id\": 1,\n            \"fp\": np.array([1, 0, 1, 1, 0, 0, 1, 0], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.0, 1.0, 0.0]),\n                \"HYD\": np.array([-1.0, 3.5, 0.0]),\n            },\n        },\n        {\n            \"id\": 2,\n            \"fp\": np.array([0, 1, 0, 1, 1, 0, 0, 1], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.5, 0.2, 0.0]),\n                \"HYD\": np.array([-0.5, 4.2, 0.0]),\n            },\n        },\n        {\n            \"id\": 3,\n            \"fp\": np.array([0, 0, 0, 1, 0, 1, 0, 1], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.7, 0.0, 0.0]),\n                \"HYD\": np.array([0.0, 4.1, 0.0]),\n            },\n        },\n    ]\n\n    # Receptor and common docking parameters\n    RECEPTOR_SITES = {\n        \"DON\": np.array([0.0, 0.0, 0.0]),\n        \"ACC\": np.array([5.0, 0.0, 0.0]),\n        \"HYD\": np.array([0.0, 5.0, 0.0]),\n    }\n    DOCKING_PARAMS = {\n        \"sigma\": 1.5,\n        \"w_acc\": 1.0,\n        \"w_hyd\": 0.8,\n        \"clash_C\": np.array([1.0, 1.0, 0.0]),\n        \"clash_R\": 1.0,\n        \"clash_lambda\": 50.0,\n        \"angles\": np.linspace(0, 2 * np.pi, 24, endpoint=False),\n    }\n\n    # Test suite parameter sets\n    test_cases = [\n        # (tau_sim, (d_DA_star, d_DH_star, d_AH_star), delta)\n        (0.5, (3.0, 4.0, 5.0), 0.3),  # Test case 1\n        (0.4, (3.0, 4.0, 5.0), 0.3),  # Test case 2\n        (0.3, (2.4, 2.4, 2.4), 0.05), # Test case 3\n    ]\n\n    # --- Helper Functions ---\n    def tanimoto_coeff(fp_a, fp_b):\n        a = np.sum(fp_a)\n        b = np.sum(fp_b)\n        c = np.sum(np.logical_and(fp_a, fp_b))\n        if a + b - c == 0:\n            return 1.0\n        return c / (a + b - c)\n\n    def internal_distances(coords):\n        d_da = np.linalg.norm(coords[\"ACC\"] - coords[\"DON\"])\n        d_dh = np.linalg.norm(coords[\"HYD\"] - coords[\"DON\"])\n        d_ah = np.linalg.norm(coords[\"ACC\"] - coords[\"HYD\"])\n        return (d_da, d_dh, d_ah)\n\n    def docking_score(molecule, receptor_sites, params):\n        p_don = molecule[\"coords\"][\"DON\"]\n        p_acc = molecule[\"coords\"][\"ACC\"]\n        p_hyd = molecule[\"coords\"][\"HYD\"]\n\n        s_don = receptor_sites[\"DON\"]\n        s_acc = receptor_sites[\"ACC\"]\n        s_hyd = receptor_sites[\"HYD\"]\n\n        v_acc = p_acc - p_don\n        v_hyd = p_hyd - p_don\n\n        min_energy = float('inf')\n\n        for theta in params[\"angles\"]:\n            # 2D rotation matrix for rotation about z-axis\n            cos_t, sin_t = np.cos(theta), np.sin(theta)\n            \n            # Rotated relative vectors\n            rot_v_acc = np.array([v_acc[0] * cos_t - v_acc[1] * sin_t, v_acc[0] * sin_t + v_acc[1] * cos_t, v_acc[2]])\n            rot_v_hyd = np.array([v_hyd[0] * cos_t - v_hyd[1] * sin_t, v_hyd[0] * sin_t + v_hyd[1] * cos_t, v_hyd[2]])\n\n            # Transformed absolute coordinates\n            q_don = s_don\n            q_acc = rot_v_acc + s_don\n            q_hyd = rot_v_hyd + s_don\n            \n            # Attraction energy\n            dist_sq_acc = np.sum((q_acc - s_acc)**2)\n            dist_sq_hyd = np.sum((q_hyd - s_hyd)**2)\n            energy_attr = -params[\"w_acc\"] * np.exp(-dist_sq_acc / (2 * params[\"sigma\"]**2)) \\\n                          -params[\"w_hyd\"] * np.exp(-dist_sq_hyd / (2 * params[\"sigma\"]**2))\n\n            # Clash penalty\n            energy_clash = 0.0\n            clash_R_sq = params[\"clash_R\"]**2\n            clash_points = [q_don, q_acc, q_hyd]\n            for point in clash_points:\n                if np.sum((point - params[\"clash_C\"])**2) < clash_R_sq:\n                    energy_clash = params[\"clash_lambda\"]\n                    break\n            \n            total_energy = energy_attr + energy_clash\n            if total_energy < min_energy:\n                min_energy = total_energy\n        \n        return min_energy\n\n    # --- Main Cascade Logic ---\n    results = []\n    \n    # Pre-calculate molecule properties that don't depend on test case parameters\n    for mol in MOLECULES:\n        mol['tanimoto'] = tanimoto_coeff(mol['fp'], F_Q)\n        mol['distances'] = internal_distances(mol['coords'])\n\n    for case in test_cases:\n        tau_sim, d_star, delta = case\n        d_star_da, d_star_dh, d_star_ah = d_star\n\n        # Stage 1: 2D Similarity Filter\n        survivors_1 = []\n        for mol in MOLECULES:\n            if mol['tanimoto'] >= tau_sim:\n                survivors_1.append(mol)\n\n        # Stage 2: 3D Pharmacophore Filter\n        survivors_2 = []\n        for mol in survivors_1:\n            d_da, d_dh, d_ah = mol['distances']\n            if (abs(d_da - d_star_da) <= delta and\n                abs(d_dh - d_star_dh) <= delta and\n                abs(d_ah - d_star_ah) <= delta):\n                survivors_2.append(mol)\n        \n        # Stage 3: Docking and Selection\n        if not survivors_2:\n            results.append(-1)\n            continue\n            \n        best_score = float('inf')\n        best_mol_idx = -1\n\n        for mol in survivors_2:\n            score = docking_score(mol, RECEPTOR_SITES, DOCKING_PARAMS)\n            if score < best_score:\n                best_score = score\n                best_mol_idx = mol[\"id\"]\n        \n        results.append(best_mol_idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440164"}, {"introduction": "建立筛选流程后，下一步是评估其表现。这个练习将带你进入虚拟筛选的验证阶段，通过编程实现业界标准的方法来量化和比较筛选结果的质量 [@problem_id:2440123]。你将计算并比较基于实验解析结构（X射线晶体结构）和计算模型（同源模建结构）的筛选表现，涉及的关键指标包括受试者工作特征曲线下面积（$AUC$）、早期富集因子（$EF_{f}$）和Jaccard指数（$J^{(K)}$）。通过这个实践，你将学会如何用数据来评判一个虚拟筛选模型的好坏，这是药物发现项目中至关重要的一环。", "problem": "给定针对同一靶点蛋白的同一配体集的两次虚拟筛选的结果：一次使用X射线晶体结构，另一次使用高质量同源模型。对于每次筛选，每个配体都有一个实值对接分数，分数越低表示预测的结合能力越强。此外，还为每个配体提供了一个二元活性标签，其中 $1$ 表示经实验证实的活性分子，而 $0$ 表示非活性分子。您必须使用以下定义来量化和比较两次筛选的排序质量。\n\n设配体索引集为 $\\{0,1,\\dots,N-1\\}$。设 $y(j) \\in \\{0,1\\}$ 为配体 $j$ 的真实活性标签，其中活性分子索引集为 $A = \\{ j \\mid y(j) = 1 \\}$，非活性分子索引集为 $I = \\{ j \\mid y(j) = 0 \\}$。设 $s_{C}(j)$ 为X射线晶体结构筛选的对接分数，$s_{H}(j)$ 为同源模型筛选的对接分数。分数越低越好。\n\n对于给定模型 $M \\in \\{C,H\\}$ 及其分数 $s_{M}(j)$，定义如下：\n1. 受试者工作特征（ROC）曲线下面积（AUC）：\n   $$\\mathrm{AUC}(M) = \\frac{1}{|A|\\cdot|I|} \\sum_{a \\in A} \\sum_{i \\in I} \\phi\\big(s_{M}(a), s_{M}(i)\\big),$$\n   其中\n   $$\\phi(x,y) = \\begin{cases}\n   1 & \\text{若 } x < y,\\\\\n   \\tfrac{1}{2} & \\text{若 } x = y,\\\\\n   0 & \\text{若 } x > y,\n   \\end{cases}$$\n   这反映了随机选择的活性分子具有比随机选择的非活性分子更好（即更低）分数的概率，其中平局贡献值为 $\\tfrac{1}{2}$。\n\n2. 在比例 $f \\in (0,1]$ 下的早期富集因子：\n   - 设 $T = f \\cdot N$（在下方的测试套件中假定为整数）。按 $s_{M}(j)$ 升序对配体进行排序。如果在选择边界处出现平局，则优先选择较小的索引以打破平局，从而确保恰好选择 $T$ 个配体。\n   - 设 $\\mathrm{TP}_{f}(M)$ 为这些排名最高的 $T$ 个配体中的活性分子数量。设 $|A|$ 为活性分子的总数。\n   - 定义\n     $$\\mathrm{EF}_{f}(M) = \\frac{\\mathrm{TP}_{f}(M)}{f \\cdot |A|}.$$\n\n3. 两个模型间排名前 $K$ 的配体集的 Jaccard 指数：\n   - 对于每个模型，通过选取分数最小的 $K$ 个配体（平局时优先选择较小的索引以获得恰好 $K$ 个配体）来构成排名前 $K$ 的集合。\n   - 设 $S_{C}^{(K)}$ 和 $S_{H}^{(K)}$ 为这两个集合。定义\n     $$J^{(K)} = \\frac{\\left| S_{C}^{(K)} \\cap S_{H}^{(K)} \\right|}{\\left| S_{C}^{(K)} \\cup S_{H}^{(K)} \\right|}.$$\n\n对于下方的每个测试用例，计算五元组\n$$\\left[ \\mathrm{AUC}(C),\\ \\mathrm{AUC}(H),\\ \\mathrm{EF}_{f}(C),\\ \\mathrm{EF}_{f}(H),\\ J^{(K)} \\right],$$\n所有值均四舍五入至 $6$ 位小数。\n\n测试套件（每个用例指定了 $N$、两个分数列表、活性标签、比例 $f$ 和整数 $K$）：\n\n- 用例1：\n  - $N = 12$\n  - $s_{C} = [-9.8,\\ -7.3,\\ -10.5,\\ -6.8,\\ -8.1,\\ -9.1,\\ -7.0,\\ -8.7,\\ -6.5,\\ -10.2,\\ -7.9,\\ -8.3]$\n  - $s_{H} = [-9.0,\\ -7.5,\\ -9.8,\\ -7.2,\\ -8.4,\\ -8.9,\\ -7.1,\\ -8.5,\\ -6.8,\\ -9.7,\\ -7.6,\\ -8.0]$\n  - $y = [1,\\ 0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0,\\ 0,\\ 0,\\ 1,\\ 0,\\ 0]$\n  - $f = 0.25$\n  - $K = 5$\n\n- 用例2：\n  - $N = 10$\n  - $s_{C} = [-11.0,\\ -10.5,\\ -10.2,\\ -9.8,\\ -8.0,\\ -7.9,\\ -7.5,\\ -7.2,\\ -7.0,\\ -6.8]$\n  - $s_{H} = [-7.5,\\ -7.4,\\ -7.3,\\ -7.2,\\ -10.0,\\ -9.8,\\ -9.5,\\ -9.2,\\ -9.0,\\ -8.8]$\n  - $y = [1,\\ 1,\\ 1,\\ 1,\\ 0,\\ 0,\\ 0,\\ 0,\\ 0,\\ 0]$\n  - $f = 0.2$\n  - $K = 3$\n\n- 用例3：\n  - $N = 8$\n  - $s_{C} = [-8.0,\\ -9.0,\\ -8.0,\\ -9.0,\\ -8.0,\\ -8.0,\\ -9.0,\\ -8.0]$\n  - $s_{H} = [-8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5]$\n  - $y = [0,\\ 1,\\ 0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0]$\n  - $f = 0.5$\n  - $K = 4$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由各用例结果组成的列表，每个用例的结果是上述的五元组，所有值均四舍五入至 $6$ 位小数。该单行必须是一个不含任何空格的有效的列表之列表（list-of-lists）。例如：$[[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],\\dots]$，其中每个 $x_{ij}$ 是一个小数点后恰好有 $6$ 位数字的小数。", "solution": "问题陈述已经过严格评估，并被认为是有效的。它在计算药物发现领域具有科学依据，提法得当，具有精确的数学定义和明确的测试用例，并且其表述是客观的。所有必要的数据、条件和约束都已提供，不存在逻辑矛盾或歧义。因此，我将着手推导解决方案。\n\n任务是使用三个不同的度量指标——受试者工作特征曲线下面积（$\\mathrm{AUC}$）、早期富集因子（$\\mathrm{EF}_f$）和 Jaccard 指数（$J^{(K)}$）——来评估和比较两种虚拟筛选模型（一个基于X射线晶体结构（$C$），另一个基于同源模型（$H$））的性能。解决方案需要系统性地实现这些指标的算法，并严格遵守指定的平局打破规则。\n\n设所有 $N$ 个配体的集合由索引 $j \\in \\{0, 1, \\dots, N-1\\}$ 标识。对于每个配体 $j$，我们给定一个二元活性标签 $y(j)$ 和两个对接分数 $s_C(j)$ 和 $s_H(j)$。\n\n首先，我们根据活性标签定义辅助集：活性配体集 $A = \\{j \\mid y(j) = 1\\}$ 和非活性配体集 $I = \\{j \\mid y(j) = 0\\}$，其基数分别为 $|A|$ 和 $|I|$。\n\n计算每个所需量的算法方法如下：\n\n1.  **受试者工作特征曲线下面积（$\\mathrm{AUC}(M)$）**\n\n模型 $M \\in \\{C, H\\}$ 的 $\\mathrm{AUC}$ 是衡量其将活性配体排在非活性配体之前的能力的指标。所提供的公式是 Mann-Whitney U 检验统计量的直接实现，它等价于 $\\mathrm{AUC}$：\n$$\n\\mathrm{AUC}(M) = \\frac{1}{|A|\\cdot|I|} \\sum_{a \\in A} \\sum_{i \\in I} \\phi\\big(s_{M}(a), s_{M}(i)\\big)\n$$\n其中函数 $\\phi(x, y)$ 在 $x < y$ 时取值为 $1$，在 $x = y$ 时取值为 $\\frac{1}{2}$，在 $x > y$ 时取值为 $0$。这对应于随机选择的活性配体比随机选择的非活性配体具有更好（更低）分数的概率。\n\n算法是该公式的直接实现：\n- 将分数 $s_M$ 分为两组：活性分数 $\\{s_M(a) \\mid a \\in A\\}$ 和非活性分数 $\\{s_M(i) \\mid i \\in I\\}$。\n- 初始化一个总和 $\\Sigma_\\phi = 0$。\n- 对于每个活性分数 $s_M(a)$，遍历所有非活性分数 $s_M(i)$，并将 $\\phi(s_M(a), s_M(i))$ 的值加到总和 $\\Sigma_\\phi$ 中。\n- 最终的 $\\mathrm{AUC}(M)$ 计算为 $\\frac{\\Sigma_\\phi}{|A| \\cdot |I|}$。此计算必须对模型 $C$ 和 $H$ 都执行。\n\n2.  **早期富集因子（$\\mathrm{EF}_{f}(M)$）**\n\n$\\mathrm{EF}_f$ 指标量化了在排序列表的得分最高的前 $f$ 部分中发现了多少活性配体，并与随机选择进行比较。\n$$\n\\mathrm{EF}_{f}(M) = \\frac{\\mathrm{TP}_{f}(M)}{f \\cdot |A|}\n$$\n此计算的关键在于正确地对配体进行排序。问题指定配体应按分数 $s_M(j)$ 升序排列，平局时优先选择较小的配体索引 $j$ 以打破平局。\n\n算法流程如下：\n- 对于给定模型 $M$，为所有配体 $j \\in \\{0, \\dots, N-1\\}$ 创建一个元组列表 $(s_M(j), j)$。\n- 对此列表进行稳定排序，首先按分数（升序），然后按索引（升序）。这正确地实现了指定的平局打破规则。\n- 确定要选择的配体数量 $T = f \\cdot N$。题目已说明这是一个整数。\n- 从排序后的列表中选择前 $T$ 个配体。\n- 统计真阳性（true positives）的数量 $\\mathrm{TP}_f(M)$，即在这个排名前 $T$ 的集合中活性配体（其中 $y(j)=1$）的数量。\n- 使用上述公式计算富集因子。分母 $f \\cdot |A|$ 代表在随机选择 $T$ 个配体时期望得到的活性配体数量。\n\n3.  **Jaccard 指数（$J^{(K)}$）**\n\nJaccard 指数衡量由两个模型 $C$ 和 $H$ 预测的排名前 $K$ 的配体集之间的相似性。\n$$\nJ^{(K)} = \\frac{\\left| S_{C}^{(K)} \\cap S_{H}^{(K)} \\right|}{\\left| S_{C}^{(K)} \\cup S_{H}^{(K)} \\right|}\n$$\n排名前 $K$ 的集合 $S_C^{(K)}$ 和 $S_H^{(K)}$ 使用与富集因子相同的排序和平局打破程序来构建。\n\n算法是：\n- 对于模型 $C$，生成配体的排序列表，并选择排名前 $K$ 的配体的索引以构成集合 $S_C^{(K)}$。\n- 对模型 $H$ 重复此过程以构成集合 $S_H^{(K)}$。\n- 计算这两个集合交集的基数 $|S_C^{(K)} \\cap S_H^{(K)}|$。\n- 计算这两个集合并集的基数 $|S_C^{(K)} \\cup S_H^{(K)}|$。请注意 $|S_C^{(K)} \\cup S_H^{(K)}| = |S_C^{(K)}| + |S_H^{(K)}| - |S_C^{(K)} \\cap S_H^{(K)}| = 2K - |S_C^{(K)} \\cap S_H^{(K)}|$。\n- Jaccard 指数是这两个基数的比率。\n\n对于每个测试用例，将这三种算法应用于所提供的数据，以计算五个所需的值：$\\mathrm{AUC}(C)$、$\\mathrm{AUC}(H)$、$\\mathrm{EF}_f(C)$、$\\mathrm{EF}_f(H)$ 和 $J^{(K)}$。然后将结果四舍五入到 $6$ 位小数，并按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_top_n_indices(scores: np.ndarray, n: int) -> list[int]:\n    \"\"\"\n    Ranks ligands by score (ascending) and index (ascending for ties)\n    and returns the indices of the top n ligands.\n    \"\"\"\n    N = len(scores)\n    # Create pairs of (score, index) for sorting.\n    indexed_scores = sorted([(scores[j], j) for j in range(N)])\n    # Extract indices from the top n sorted pairs.\n    top_indices = [index for score, index in indexed_scores[:n]]\n    return top_indices\n\ndef calculate_auc(scores: np.ndarray, y: np.ndarray) -> float:\n    \"\"\"\n    Calculates the Area Under the ROC Curve (AUC).\n    \"\"\"\n    active_indices = np.where(y == 1)[0]\n    inactive_indices = np.where(y == 0)[0]\n\n    num_actives = len(active_indices)\n    num_inactives = len(inactive_indices)\n\n    if num_actives == 0 or num_inactives == 0:\n        return 0.5  # Per convention, AUC is 0.5 if one class is missing.\n\n    active_scores = scores[active_indices]\n    inactive_scores = scores[inactive_indices]\n\n    # Vectorized comparison\n    # Reshape for broadcasting: active_scores (num_actives, 1), inactive_scores (1, num_inactives)\n    # Resulting comparison matrices have shape (num_actives, num_inactives)\n    less_than_count = np.sum(active_scores[:, np.newaxis] < inactive_scores)\n    equal_to_count = np.sum(active_scores[:, np.newaxis] == inactive_scores)\n\n    phi_sum = less_than_count + 0.5 * equal_to_count\n    \n    auc = phi_sum / (num_actives * num_inactives)\n    return auc\n\ndef calculate_ef(scores: np.ndarray, y: np.ndarray, f: float) -> float:\n    \"\"\"\n    Calculates the Early Enrichment Factor at fraction f.\n    \"\"\"\n    N = len(y)\n    num_actives_total = np.sum(y)\n    \n    if num_actives_total == 0:\n        return 0.0 # No actives to enrich.\n\n    T = int(f * N)\n    if T == 0:\n        return 0.0\n\n    top_indices = get_top_n_indices(scores, T)\n    \n    # Count true positives in the top T ligands\n    tp_f = np.sum(y[top_indices])\n    \n    # Denominator is the expected number of actives in a random selection of size T\n    ef = tp_f / (f * num_actives_total)\n    return ef\n\ndef calculate_jaccard(scores_c: np.ndarray, scores_h: np.ndarray, k: int) -> float:\n    \"\"\"\n    Calculates the Jaccard index between the top-K sets of two models.\n    \"\"\"\n    if k == 0:\n        return 1.0 if len(scores_c) == 0 else 0.0\n\n    top_k_indices_c = get_top_n_indices(scores_c, k)\n    top_k_indices_h = get_top_n_indices(scores_h, k)\n\n    set_c = set(top_k_indices_c)\n    set_h = set(top_k_indices_h)\n    \n    intersection_size = len(set_c.intersection(set_h))\n    union_size = len(set_c.union(set_h))\n\n    if union_size == 0:\n        return 1.0 # By convention, Jaccard of two empty sets is 1.\n\n    jaccard = intersection_size / union_size\n    return jaccard\n\ndef process_case(s_c: list, s_h: list, y_labels: list, f: float, k: int) -> list[float]:\n    \"\"\"\n    Processes a single test case and computes all required metrics.\n    \"\"\"\n    s_c_np = np.array(s_c)\n    s_h_np = np.array(s_h)\n    y_np = np.array(y_labels)\n\n    auc_c = calculate_auc(s_c_np, y_np)\n    auc_h = calculate_auc(s_h_np, y_np)\n\n    ef_c = calculate_ef(s_c_np, y_np, f)\n    ef_h = calculate_ef(s_h_np, y_np, f)\n    \n    jaccard_k = calculate_jaccard(s_c_np, s_h_np, k)\n\n    return [auc_c, auc_h, ef_c, ef_h, jaccard_k]\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the calculations, and prints the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 12,\n            \"s_C\": [-9.8, -7.3, -10.5, -6.8, -8.1, -9.1, -7.0, -8.7, -6.5, -10.2, -7.9, -8.3],\n            \"s_H\": [-9.0, -7.5, -9.8, -7.2, -8.4, -8.9, -7.1, -8.5, -6.8, -9.7, -7.6, -8.0],\n            \"y\": [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n            \"f\": 0.25,\n            \"K\": 5\n        },\n        {\n            \"N\": 10,\n            \"s_C\": [-11.0, -10.5, -10.2, -9.8, -8.0, -7.9, -7.5, -7.2, -7.0, -6.8],\n            \"s_H\": [-7.5, -7.4, -7.3, -7.2, -10.0, -9.8, -9.5, -9.2, -9.0, -8.8],\n            \"y\": [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n            \"f\": 0.2,\n            \"K\": 3\n        },\n        {\n            \"N\": 8,\n            \"s_C\": [-8.0, -9.0, -8.0, -9.0, -8.0, -8.0, -9.0, -8.0],\n            \"s_H\": [-8.5, -8.5, -8.5, -8.5, -8.5, -8.5, -8.5, -8.5],\n            \"y\": [0, 1, 0, 1, 0, 0, 1, 0],\n            \"f\": 0.5,\n            \"K\": 4\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result_tuple = process_case(case[\"s_C\"], case[\"s_H\"], case[\"y\"], case[\"f\"], case[\"K\"])\n        all_results.append(result_tuple)\n    \n    # Manually construct the output string to match the required format without spaces.\n    formatted_results = []\n    for res_tuple in all_results:\n        # Format each float to 6 decimal places and join into a string like \"[x.xxxxxx,y.yyyyyy,...]\"\n        formatted_tuple_str = f\"[{','.join([f'{v:.6f}' for v in res_tuple])}]\"\n        formatted_results.append(formatted_tuple_str)\n    \n    # Join the individual case strings into the final list-of-lists format \"[[...],[...]]\"\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2440123"}]}