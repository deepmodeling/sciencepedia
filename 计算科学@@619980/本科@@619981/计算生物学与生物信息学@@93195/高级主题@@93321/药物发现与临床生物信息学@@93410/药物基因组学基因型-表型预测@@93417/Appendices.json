{"hands_on_practices": [{"introduction": "药物基因组学的核心挑战之一是区分不同的治疗结果，例如无效反应与药物不良反应（$ADR$）。本练习将指导您构建一个贝叶斯分类器来解决这一问题，该模型基于明确的概率假设。通过这个实践，您将学会如何整合不同类型的生物标记物（如基因型和连续的酶活性得分）的证据，以根据后验概率最大化原则做出预测 [@problem_id:2413852]。这是理解生成模型和在生物医学背景下进行概率推理的关键一步。", "problem": "您将执行一个形式化的药物基因组学基因型-表型分类任务，以区分对药物的无效反应和药物不良反应 (ADR)，当两种临床结局都导致治疗中止时。考虑一个二元类变量 $Y \\in \\{0,1\\}$，其中 $Y=0$ 表示无效反应，$Y=1$ 表示药物不良反应 (ADR)。对于每个个体，您观察到一个由以下部分组成的特征向量 $X=(g_{\\mathrm{HLA}}, g_T, a)$：一个人类白细胞抗原 (HLA) 风险等位基因指示符 $g_{\\mathrm{HLA}} \\in \\{0,1\\}$，一个转运蛋白功能丧失指示符 $g_T \\in \\{0,1\\}$，以及一个归一化的酶活性分数 $a \\in \\mathbb{R}_{\\ge 0}$。假设遵循以下生成模型和概率假设。\n\n1. 类别先验概率：$P(Y=0)=\\tfrac{1}{2}$ 和 $P(Y=1)=\\tfrac{1}{2}$。\n\n2. 给定类别下特征的条件独立性：对于任何 $x=(g_{\\mathrm{HLA}}, g_T, a)$ 和 $y \\in \\{0,1\\}$，\n$$\np(x \\mid y) \\;=\\; p(g_{\\mathrm{HLA}} \\mid y)\\; p(g_T \\mid y)\\; f(a \\mid y).\n$$\n\n3. 对于人类白细胞抗原 (HLA) 风险等位基因指示符，\n$$\nP(g_{\\mathrm{HLA}}=1 \\mid Y=1) = 0.7,\\quad P(g_{\\mathrm{HLA}}=1 \\mid Y=0) = 0.05,\n$$\n且对于 $y \\in \\{0,1\\}$，$P(g_{\\mathrm{HLA}}=0 \\mid y) = 1 - P(g_{\\mathrm{HLA}}=1 \\mid y)$。\n\n4. 对于转运蛋白功能丧失指示符，\n$$\nP(g_T=1 \\mid Y=0) = 0.6,\\quad P(g_T=1 \\mid Y=1) = 0.2,\n$$\n且对于 $y \\in \\{0,1\\}$，$P(g_T=0 \\mid y) = 1 - P(g_T=1 \\mid y)$。\n\n5. 对于酶活性分数，假设其服从类条件高斯密度分布，参数如下\n$$\na \\mid Y=0 \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2), \\quad \\mu_0 = 0.2,\\ \\sigma_0 = 0.1,\n$$\n$$\na \\mid Y=1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2), \\quad \\mu_1 = 1.0,\\ \\sigma_1 = 0.2,\n$$\n其密度为\n$$\nf(a \\mid y) \\;=\\; \\frac{1}{\\sigma_y \\sqrt{2\\pi}} \\exp\\!\\left( -\\frac{(a - \\mu_y)^2}{2 \\sigma_y^2} \\right), \\quad y \\in \\{0,1\\}。\n$$\n\n您的任务是构建一个分类器，对于每个观测值 $x=(g_{\\mathrm{HLA}}, g_T, a)$，选择能使后验概率 $P(Y=y \\mid X=x)$ 在上述定义模型下最大化的类别 $\\hat{y} \\in \\{0,1\\}$。如果出现概率完全相等的情况，您必须预测为药物不良反应 (ADR) 类别，即选择 $\\hat{y}=1$。\n\n测试集。请使用以下五个观测值，每个都以有序三元组 $(g_{\\mathrm{HLA}}, g_T, a)$ 的形式给出：\n1. $(1, 0, 0.9)$\n2. $(0, 1, 0.1)$\n3. $(0, 0, 0.5)$\n4. $(0, 1, 0.0)$\n5. $(1, 1, 0.05)$\n\n最终输出格式。您的程序应生成单行输出，其中包含对五个观测值的预测类别，形式为方括号内用逗号分隔的整数列表，顺序与上述列表相同。例如，要求的格式是 $[c_1,c_2,c_3,c_4,c_5]$，其中每个 $c_i \\in \\{0,1\\}$ 是对测试用例 $i$ 的预测类别。不涉及单位，也不需要百分比。输出必须只有一行，不得包含任何额外的字符或文本。", "solution": "题目陈述已经过验证。\n\n第 1 步：提取已知条件。\n- 类别变量：$Y \\in \\{0,1\\}$，其中 $Y=0$ 代表无效反应，$Y=1$ 代表药物不良反应 (ADR)。\n- 特征向量：$X=(g_{\\mathrm{HLA}}, g_T, a)$，其中 $g_{\\mathrm{HLA}} \\in \\{0,1\\}$，$g_T \\in \\{0,1\\}$，且 $a \\in \\mathbb{R}_{\\ge 0}$。\n- 类别先验概率：$P(Y=0) = \\tfrac{1}{2}$ 和 $P(Y=1) = \\tfrac{1}{2}$。\n- 条件独立性假设：$p(x \\mid y) = p(g_{\\mathrm{HLA}} \\mid y) p(g_T \\mid y) f(a \\mid y)$。\n- $g_{\\mathrm{HLA}}$ 的条件概率：$P(g_{\\mathrm{HLA}}=1 \\mid Y=1) = 0.7$，$P(g_{\\mathrm{HLA}}=1 \\mid Y=0) = 0.05$。这意味着 $P(g_{\\mathrm{HLA}}=0 \\mid y) = 1 - P(g_{\\mathrm{HLA}}=1 \\mid y)$。\n- $g_T$ 的条件概率：$P(g_T=1 \\mid Y=0) = 0.6$，$P(g_T=1 \\mid Y=1) = 0.2$。这意味着 $P(g_T=0 \\mid y) = 1 - P(g_T=1 \\mid y)$。\n- $a$ 的类条件密度：\n  - $a \\mid Y=0 \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$，均值为 $\\mu_0 = 0.2$，标准差为 $\\sigma_0 = 0.1$。\n  - $a \\mid Y=1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2)$，均值为 $\\mu_1 = 1.0$，标准差为 $\\sigma_1 = 0.2$。\n  - 概率密度函数由下式给出 $f(a \\mid y) = \\frac{1}{\\sigma_y \\sqrt{2\\pi}} \\exp\\left( -\\frac{(a - \\mu_y)^2}{2 \\sigma_y^2} \\right)$。\n- 分类任务：对于一个观测值 $x=(g_{\\mathrm{HLA}}, g_T, a)$，预测能使后验概率 $P(Y=y \\mid X=x)$ 最大化的类别 $\\hat{y}$。\n- 平局决胜规则：若概率相等，则预测为 $\\hat{y}=1$。\n- 测试集：$(1, 0, 0.9)$、$(0, 1, 0.1)$、$(0, 0, 0.5)$、$(0, 1, 0.0)$、$(1, 1, 0.05)$。\n\n第 2 步：使用提取的已知条件进行验证。\n该问题描述了一个标准的朴素贝叶斯分类任务。\n- **科学依据：**该设置是药物基因组学中一个简化但合理的模型。特征（HLA 等位基因、转运蛋白基因、酶活性）是相关的生物标志物。概率框架在科学上是合理的。该问题不基于伪科学。\n- **良态问题：**模型所需的所有参数（先验概率、条件概率、分布参数）均已提供。目标函数（最大化后验概率）定义清晰，平局决胜规则确保了对任何输入都有唯一解。\n- **客观性：**问题以精确的数学语言陈述，没有歧义或主观看法。\n\n该问题不违反任何指定的无效标准。它是完整的、一致的、且可形式化的。\n\n第 3 步：结论与行动。\n该问题有效。将构建一个解决方案。\n\n解法：\n目标是设计一个分类器，它能预测使后验概率 $P(Y=y \\mid X=x)$ 最大化的类别 $\\hat{y}$。这被称为最大后验 (MAP) 决策规则。\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} P(Y=y \\mid X=x)\n$$\n根据贝叶斯定理，后验概率由下式给出：\n$$\nP(Y=y \\mid X=x) = \\frac{p(X=x \\mid Y=y) P(Y=y)}{p(X=x)}\n$$\n分母 $p(X=x)$ 是一个边际概率（也称为证据），用作归一化常数。由于它与类别 $y$ 无关，因此不影响最大化过程。因此，决策规则等价于最大化联合概率：\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} p(X=x \\mid Y=y) P(Y=y)\n$$\n问题指定了相等的类别先验概率，$P(Y=0) = P(Y=1) = \\tfrac{1}{2}$。因此，先验概率项也不影响最大化过程，可以省略。问题简化为最大化类条件似然 $p(X=x \\mid Y=y)$：\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} p(X=x \\mid Y=y)\n$$\n使用特征向量 $x=(g_{\\mathrm{HLA}}, g_T, a)$ 的条件独立性假设，似然函数为：\n$$\np(x \\mid y) = P(g_{\\mathrm{HLA}} \\mid Y=y) \\cdot P(g_T \\mid Y=y) \\cdot f(a \\mid Y=y)\n$$\n为避免因微小概率相乘导致的数值下溢，并为方便起见，标准做法是使用对数似然。由于对数是严格递增函数，最大化一个值等价于最大化其对数。设 $S_y$ 为与类别 $y$ 的对数后验概率成正比的分数。\n$$\n\\hat{y} = \\arg\\max_{y \\in \\{0, 1\\}} \\left( \\log P(g_{\\mathrm{HLA}} \\mid Y=y) + \\log P(g_T \\mid Y=y) + \\log f(a \\mid Y=y) \\right)\n$$\n特征 $a$ 的高斯分布的对数密度为：\n$$\n\\log f(a \\mid y) = \\log\\left(\\frac{1}{\\sigma_y \\sqrt{2\\pi}} \\exp\\left( -\\frac{(a - \\mu_y)^2}{2 \\sigma_y^2} \\right)\\right) = -\\log(\\sigma_y) - \\frac{1}{2}\\log(2\\pi) - \\frac{(a - \\mu_y)^2}{2 \\sigma_y^2}\n$$\n项 $-\\tfrac{1}{2}\\log(2\\pi)$ 对两个类别是共同的，可以在比较中省略。因此，每个类别 $y$ 的决策分数为：\n$$\nS_y = \\log P(g_{\\mathrm{HLA}} \\mid Y=y) + \\log P(g_T \\mid Y=y) - \\log(\\sigma_y) - \\frac{(a - \\mu_y)^2}{2 \\sigma_y^2}\n$$\n如果 $S_1 \\ge S_0$（包含平局决胜规则），则预测 $\\hat{y}$ 为 $1$，否则为 $0$。\n\n首先，我们必须根据给定信息将所有必要的条件概率制成表格。\n对于 $g_{\\mathrm{HLA}}$：\n- $P(g_{\\mathrm{HLA}}=1 \\mid Y=0) = 0.05$，所以 $P(g_{\\mathrm{HLA}}=0 \\mid Y=0) = 1 - 0.05 = 0.95$。\n- $P(g_{\\mathrm{HLA}}=1 \\mid Y=1) = 0.7$，所以 $P(g_{\\mathrm{HLA}}=0 \\mid Y=1) = 1 - 0.7 = 0.3$。\n对于 $g_T$：\n- $P(g_T=1 \\mid Y=0) = 0.6$，所以 $P(g_T=0 \\mid Y=0) = 1 - 0.6 = 0.4$。\n- $P(g_T=1 \\mid Y=1) = 0.2$，所以 $P(g_T=0 \\mid Y=1) = 1 - 0.2 = 0.8$。\n对于 $a$：\n- 类别 $Y=0$：$\\mu_0 = 0.2$，$\\sigma_0 = 0.1$。\n- 类别 $Y=1$：$\\mu_1 = 1.0$，$\\sigma_1 = 0.2$。\n\n现在我们将此决策规则应用于每个测试用例。\n\n1. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (1, 0, 0.9)$：\n$S_0 = \\log(0.05) + \\log(0.4) - \\log(0.1) - \\frac{(0.9 - 0.2)^2}{2(0.1)^2} = -2.996 - 0.916 - (-2.303) - \\frac{0.49}{0.02} \\approx -1.609 - 24.5 = -26.109$\n$S_1 = \\log(0.7) + \\log(0.8) - \\log(0.2) - \\frac{(0.9 - 1.0)^2}{2(0.2)^2} = -0.357 - 0.223 - (-1.609) - \\frac{0.01}{0.08} \\approx 1.029 - 0.125 = 0.904$\n由于 $S_1 > S_0$，预测为 $\\hat{y}=1$。\n\n2. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (0, 1, 0.1)$：\n$S_0 = \\log(0.95) + \\log(0.6) - \\log(0.1) - \\frac{(0.1 - 0.2)^2}{2(0.1)^2} = -0.051 - 0.511 - (-2.303) - \\frac{0.01}{0.02} \\approx 1.741 - 0.5 = 1.241$\n$S_1 = \\log(0.3) + \\log(0.2) - \\log(0.2) - \\frac{(0.1 - 1.0)^2}{2(0.2)^2} = -1.204 - \\frac{0.81}{0.08} \\approx -1.204 - 10.125 = -11.329$\n由于 $S_0 > S_1$，预测为 $\\hat{y}=0$。\n\n3. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (0, 0, 0.5)$：\n$S_0 = \\log(0.95) + \\log(0.4) - \\log(0.1) - \\frac{(0.5 - 0.2)^2}{2(0.1)^2} = -0.051 - 0.916 - (-2.303) - \\frac{0.09}{0.02} \\approx 1.336 - 4.5 = -3.164$\n$S_1 = \\log(0.3) + \\log(0.8) - \\log(0.2) - \\frac{(0.5 - 1.0)^2}{2(0.2)^2} = -1.204 - 0.223 - (-1.609) - \\frac{0.25}{0.08} \\approx 0.182 - 3.125 = -2.943$\n由于 $S_1 > S_0$，预测为 $\\hat{y}=1$。\n\n4. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (0, 1, 0.0)$：\n$S_0 = \\log(0.95) + \\log(0.6) - \\log(0.1) - \\frac{(0.0 - 0.2)^2}{2(0.1)^2} = 1.741 - \\frac{0.04}{0.02} = 1.741 - 2.0 = -0.259$\n$S_1 = \\log(0.3) + \\log(0.2) - \\log(0.2) - \\frac{(0.0 - 1.0)^2}{2(0.2)^2} = -1.204 - \\frac{1.0}{0.08} = -1.204 - 12.5 = -13.704$\n由于 $S_0 > S_1$，预测为 $\\hat{y}=0$。\n\n5. 观测值 $(g_{\\mathrm{HLA}}, g_T, a) = (1, 1, 0.05)$：\n$S_0 = \\log(0.05) + \\log(0.6) - \\log(0.1) - \\frac{(0.05 - 0.2)^2}{2(0.1)^2} = -2.996 - 0.511 - (-2.303) - \\frac{0.0225}{0.02} \\approx -1.204 - 1.125 = -2.329$\n$S_1 = \\log(0.7) + \\log(0.2) - \\log(0.2) - \\frac{(0.05 - 1.0)^2}{2(0.2)^2} = -0.357 - \\frac{0.9025}{0.08} \\approx -0.357 - 11.281 = -11.638$\n由于 $S_0 > S_1$，预测为 $\\hat{y}=0$。\n\n最终的预测序列是 $[1, 0, 1, 0, 0]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacogenomic genotype-phenotype classification task.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 0, 0.9),\n        (0, 1, 0.1),\n        (0, 0, 0.5),\n        (0, 1, 0.0),\n        (1, 1, 0.05),\n    ]\n\n    # Model parameters extracted from the problem statement.\n    \n    # P(g_HLA = g | Y = y)\n    # Stored as p_ghla[y][g]\n    p_ghla = {\n        0: {1: 0.05, 0: 0.95},\n        1: {1: 0.7, 0: 0.3}\n    }\n\n    # P(g_T = g | Y = y)\n    # Stored as p_gt[y][g]\n    p_gt = {\n        0: {1: 0.6, 0: 0.4},\n        1: {1: 0.2, 0: 0.8}\n    }\n\n    # Parameters for Gaussian density of a | Y = y\n    # Stored as params_a[y] = (mu, sigma)\n    params_a = {\n        0: (0.2, 0.1),  # mu_0, sigma_0\n        1: (1.0, 0.2)   # mu_1, sigma_1\n    }\n\n    def classify(g_hla: int, g_t: int, a: float) -> int:\n        \"\"\"\n        Classifies a single observation using the MAP decision rule.\n        The implementation uses log-probabilities to ensure numerical stability.\n        \n        The decision rule is to maximize the posterior P(Y=y|X=x).\n        This is equivalent to maximizing the log of the class-conditional likelihood,\n        since priors P(Y=y) are uniform.\n        \n        Score_y = log(P(g_HLA|Y=y)) + log(P(g_T|Y=y)) + log(f(a|Y=y))\n        \n        The log of the Gaussian PDF, ignoring constant terms common to both classes, is:\n        log(f(a|Y=y)) ~ -log(sigma_y) - (a - mu_y)^2 / (2 * sigma_y^2)\n        \"\"\"\n        \n        # Calculate score for class Y=0\n        mu0, sigma0 = params_a[0]\n        log_likelihood_g_0 = np.log(p_ghla[0][g_hla]) + np.log(p_gt[0][g_t])\n        log_pdf_a_0 = -np.log(sigma0) - ((a - mu0)**2) / (2 * sigma0**2)\n        score_0 = log_likelihood_g_0 + log_pdf_a_0\n        \n        # Calculate score for class Y=1\n        mu1, sigma1 = params_a[1]\n        log_likelihood_g_1 = np.log(p_ghla[1][g_hla]) + np.log(p_gt[1][g_t])\n        log_pdf_a_1 = -np.log(sigma1) - ((a - mu1)**2) / (2 * sigma1**2)\n        score_1 = log_likelihood_g_1 + log_pdf_a_1\n        \n        # Decision rule: predict Y=1 if score_1 is greater or equal (tie-breaking).\n        if score_1 >= score_0:\n            return 1\n        else:\n            return 0\n\n    results = []\n    for case in test_cases:\n        g_hla_val, g_t_val, a_val = case\n        prediction = classify(g_hla_val, g_t_val, a_val)\n        results.append(prediction)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413852"}, {"introduction": "在临床实践中，准确解释复杂的基因变异（如$CYP2D6$星形等位基因系统）对于预测药物代谢至关重要。本练习将引导您构建一个基于规则的确定性模型，而不是依赖于统计学习。您将学习如何解析包含结构变异（如拷贝数和杂合基因）的复杂基因型字符串，将其转化为一个定量的酶活性分数，并最终应用经典的米氏方程（$Michaelis-Menten$ kinetics）来预测代谢速率 [@problem_id:2413841]。这个实践旨在连接生物信息学中的基因命名法与药理学中的动力学模型，是药物基因组学应用的核心技能。", "problem": "实现一个决定性的、考虑单位的模型，该模型在固定血浆浓度下，将一个带有结构变异的细胞色素P450 2D6（CYP2D6）基因型映射到预测的可待因O-去甲基化速率。该基因型由两个单倍型指定。每个单倍型是一个字符串，由一个星号等位基因标记和可选的结构修饰符根据以下语法构成：一个简单的星号等位基因形式为“*k”，其中“k”是集合 {“*1”, “*2”, “*4”, “*5”, “*10”, “*17”, “*36”, “*41”} 中的一个标准星号等位基因标识符；一个整数拷贝数由后缀“xN”表示，该后缀应用于整个单倍型，并表示在同一条染色体上有 $N$ 个串联拷贝；一个串联杂合单倍型表示为“A+B”，它在单个染色体片段上结合了两个星号等位基因标记 $A$ 和 $B$；拷贝数也可以应用于串联杂合体，形式为“(A+B)xN”或“A+BxN”。一个简单星号等位基因 $a$ 的每拷贝内在活性由映射 $\\alpha(a)$ 给出，其值为 $\\alpha(\\text{“*1”})=1.0$、$\\alpha(\\text{“*2”})=1.0$、$\\alpha(\\text{“*4”})=0.0$、$\\alpha(\\text{“*5”})=0.0$、$\\alpha(\\text{“*10”})=0.25$、$\\alpha(\\text{“*17”})=0.5$、$\\alpha(\\text{“*36”})=0.0$ 和 $\\alpha(\\text{“*41”})=0.5$。对于一个串联杂合体“A+B”，其有效的每拷贝活性定义为\n$$\n\\alpha_{\\mathrm{tandem}}(A,B) \\equiv p_t \\cdot \\frac{\\alpha(A) + \\alpha(B)}{2},\n$$\n其中串联惩罚因子 $p_t=0.8$ 是一个固定值。对于一个拷贝数为 $c \\in \\mathbb{Z}_{\\ge 1}$ 的单倍型，若为简单等位基因 $a$，其单倍型活性贡献为 $c \\cdot \\alpha(a)$；若为串联杂合体 $A+B$，其贡献为 $c \\cdot \\alpha_{\\mathrm{tandem}}(A,B)$。总活性分数是两个单倍型贡献之和：\n$$\nS \\equiv S(H_1,H_2) = \\mathrm{contrib}(H_1) + \\mathrm{contrib}(H_2).\n$$\n从活性分数到可待因O-去甲基化速率的药代动力学映射遵循Michaelis–Menten（MM）动力学。设野生型（WT）表示活性分数为 $S_{\\mathrm{WT}}=2.0$ 的参考二倍体型。将最大速度 $V_{\\max}(S)$ 定义为\n$$\nV_{\\max}(S) \\equiv V_{\\max}^{\\mathrm{WT}} \\cdot \\frac{S}{S_{\\mathrm{WT}}},\n$$\n其中 $V_{\\max}^{\\mathrm{WT}}=1.0$，单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$。设Michaelis常数为 $K_m=0.2$，单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}$；设可待因血浆浓度为 $C$，单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}$。吗啡形成速率为\n$$\nv(S,C) \\equiv V_{\\max}(S) \\cdot \\frac{C}{K_m + C},\n$$\n以 $\\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$ 为单位报告。如果 $S=0$ 或 $C=0$，则根据上述定义 $v=0$。\n\n您的任务是编写一个程序，对下面的每个测试用例，解析两个单倍型字符串，根据指定规则计算 $S$，然后计算 $v(S,C)$。将所有测试用例的最终结果表示为单行输出，该行包含一个用方括号括起来的、以逗号分隔的列表，其中每个条目四舍五入到恰好 $6$ 位小数，单位为 $\\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$（不要打印单位）。\n\n测试套件（每个测试用例是 (单倍型$_1$, 单倍型$_2$, $C$) 形式的三元组）：\n$1.$ (“*1”, “*1”, $0.5$)\n$2.$ (“*4”, “*5”, $0.5$)\n$3.$ (“*1x3”, “*1”, $2.0$)\n$4.$ (“*36+*10”, “*1”, $0.5$)\n$5.$ (“*1x2”, “*10”, $0.5$)\n$6.$ (“*17”, “*4”, $10.0$)\n$7.$ (“*1”, “*1x2”, $0.0$)\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[r1,r2,r3,r4,r5,r6,r7]”），其中每个 $r_i$ 是一个按照上述规定四舍五入到 $6$ 位小数的浮点数。", "solution": "该问题要求实现一个决定性模型，以预测可待因O-去甲基化为吗啡的速率，这是一个由CYP2D6酶催化的代谢过程。该模型基于一个特定的药物基因组学基因型（由两个单倍型定义）和固定的可待因血浆浓度。解决方案遵循一个两部分的、基于规则的方法：首先，将基因型映射到一个数值活性分数；其次，使用经典酶动力学将此分数和底物浓度映射到代谢速率。\n\n第一步是根据给定的两个单倍型字符串 $H_1$ 和 $H_2$ 计算总活性分数 $S$。总分数是每个单倍型各自贡献的总和：\n$$\nS = \\mathrm{contrib}(H_1) + \\mathrm{contrib}(H_2)\n$$\n单个单倍型的贡献 $\\mathrm{contrib}(H)$ 的计算取决于其结构，该结构从其字符串表示中解析而来。单倍型字符串指定了一个基础等位基因构型和一个可选的拷贝数。\n\n首先，确定拷贝数，用整数 $c$ 表示。如果字符串包含后缀“xN”，则拷贝数 $c$ 为 $N$。如果没有此后缀，则拷贝数取为 $c=1$。字符串的其余部分指定了基础等位基因构型。\n\n基础等位基因构型有两种类型：\n1.  **简单等位基因：** 基础构型是单个星号等位基因，例如“*1”或“*10”。其贡献计算为 $c \\cdot \\alpha(a)$，其中 $a$ 是星号等位基因标识符，$\\alpha(a)$ 是其每拷贝内在活性。问题提供了以下活性映射：\n    -   $\\alpha(\\text{“*1”}) = 1.0$\n    -   $\\alpha(\\text{“*2”}) = 1.0$\n    -   $\\alpha(\\text{“*4”}) = 0.0$\n    -   $\\alpha(\\text{“*5”}) = 0.0$\n    -   $\\alpha(\\text{“*10”}) = 0.25$\n    -   $\\alpha(\\text{“*17”}) = 0.5$\n    -   $\\alpha(\\text{“*36”}) = 0.0$\n    -   $\\alpha(\\text{“*41”}) = 0.5$\n\n2.  **串联杂合等位基因：** 基础构型是两个星号等位基因的杂合体，表示为“A+B”。其每拷贝活性由一个包含惩罚项的特定公式定义：\n    $$\n    \\alpha_{\\mathrm{tandem}}(A,B) = p_t \\cdot \\frac{\\alpha(A) + \\alpha(B)}{2}\n    $$\n    串联惩罚因子给定为 $p_t=0.8$。那么，此单倍型的总贡献为 $c \\cdot \\alpha_{\\mathrm{tandem}}(A,B)$。\n\n第二步是使用计算出的总活性分数 $S$，基于Michaelis-Menten酶动力学模型来确定吗啡形成速率 $v$。最大反应速度 $V_{\\max}$ 被假定为与总酶活性成正比，总酶活性由分数 $S$ 表示。这种关系表示为：\n$$\nV_{\\max}(S) = V_{\\max}^{\\mathrm{WT}} \\cdot \\frac{S}{S_{\\mathrm{WT}}}\n$$\n其中 $S_{\\mathrm{WT}}=2.0$ 是参考野生型（WT）二倍体型（例如 *1/*1）的活性分数，而 $V_{\\max}^{\\mathrm{WT}}=1.0 \\, \\mathrm{mg}\\,\\mathrm{L}^{-1}\\,\\mathrm{h}^{-1}$ 是该参考型的最大速度。\n\n反应速率 $v$ 随后由Michaelis-Menten方程给出，该方程将反应速度与底物浓度 $C$ 联系起来：\n$$\nv(S,C) = V_{\\max}(S) \\cdot \\frac{C}{K_m + C}\n$$\nMichaelis常数给定为 $K_m=0.2 \\, \\mathrm{mg}\\,\\mathrm{L}^{-1}$。定义了一个特殊条件：如果活性分数 $S=0$ 或可待因浓度 $C=0$，则反应速率 $v$ 为 $0$。\n\n实现包括一个用于解析单个单倍型字符串以计算其贡献的函数，以及一个用于处理每个测试用例的主过程。解析函数首先分离出拷贝数和基础等位基因字符串。然后它检查是否存在杂合结构（“+”）以决定应用哪个活性公式。主过程对给定二倍体型的两个单倍型调用此解析函数，将它们的贡献相加得到 $S$，然后使用提供的浓度 $C$ 和药代动力学方程计算 $v$。每个测试用例的最终结果按照要求四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the codeine O-demethylation rate based on CYP2D6 genotype and plasma concentration.\n    \"\"\"\n\n    # --- Model Constants ---\n    ALPHA_MAP = {\n        \"*1\": 1.0, \"*2\": 1.0, \"*4\": 0.0, \"*5\": 0.0,\n        \"*10\": 0.25, \"*17\": 0.5, \"*36\": 0.0, \"*41\": 0.5\n    }\n    TANDEM_PENALTY = 0.8  # p_t\n    S_WT = 2.0\n    VMAX_WT = 1.0  # mg L^-1 h^-1\n    KM = 0.2  # mg L^-1\n\n    def _calculate_haplotype_contribution(hap_str: str) -> float:\n        \"\"\"\n        Parses a haplotype string and computes its activity score contribution.\n        \"\"\"\n        base_hap = hap_str\n        copy_count = 1\n\n        # Check for and extract copy number\n        if 'x' in hap_str:\n            parts = hap_str.split('x')\n            base_hap = parts[0]\n            copy_count = int(parts[1])\n\n        # Remove parentheses if present (e.g., from (A+B)xN)\n        base_hap = base_hap.strip('()')\n\n        # Check for tandem hybrid structure\n        if '+' in base_hap:\n            alleles = base_hap.split('+')\n            allele_a = alleles[0]\n            allele_b = alleles[1]\n            \n            activity_a = ALPHA_MAP.get(allele_a, 0.0)\n            activity_b = ALPHA_MAP.get(allele_b, 0.0)\n            \n            alpha_tandem = TANDEM_PENALTY * (activity_a + activity_b) / 2.0\n            per_copy_activity = alpha_tandem\n        else: # Simple allele\n            per_copy_activity = ALPHA_MAP.get(base_hap, 0.0)\n            \n        return copy_count * per_copy_activity\n\n    test_cases = [\n        (\"*1\", \"*1\", 0.5),\n        (\"*4\", \"*5\", 0.5),\n        (\"*1x3\", \"*1\", 2.0),\n        (\"*36+*10\", \"*1\", 0.5),\n        (\"*1x2\", \"*10\", 0.5),\n        (\"*17\", \"*4\", 10.0),\n        (\"*1\", \"*1x2\", 0.0)\n    ]\n\n    results = []\n    for hap1, hap2, C in test_cases:\n        contrib1 = _calculate_haplotype_contribution(hap1)\n        contrib2 = _calculate_haplotype_contribution(hap2)\n        \n        S = contrib1 + contrib2\n        \n        # Calculate metabolic rate v\n        if S == 0 or C == 0:\n            v = 0.0\n        else:\n            Vmax_S = VMAX_WT * (S / S_WT)\n            v = Vmax_S * (C / (KM + C))\n\n        results.append(f\"{v:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413841"}, {"introduction": "在临床决策中，预测模型的准确性固然重要，但其可解释性更是获得医生和患者信任的关键。本练习聚焦于模型的可解释性，要求您不仅要构建一个预测模型，还要解释其为何针对基因型相似但临床特征不同的患者给出差异化的剂量建议。您将应用沙普利加性解释（$SHAP$）的核心思想，来量化每个特征（如基因型、年龄、体重）对预测结果差异的贡献 [@problem_id:2413806]。这项实践旨在训练您超越“黑箱”预测，生成透明、可信的解释，这是将机器学习模型付诸临床实践的重要一环。", "problem": "您将设计并实现一个可解释的药物基因组学基因型-表型预测模型，该模型用于解释具有相似基因型但临床协变量不同的患者对之间的剂量建议差异。该场景基于一个被广泛研究的课题，即细胞色素P450和维生素K环氧化物还原酶复合体基因对华法林剂量的影响，使用通过普通最小二乘法 (OLS) 训练的简单线性模型，并利用 SHapley 加性解释 (SHAP) 或满足标准公理的等效加性、合作博弈论分解方法进行解释。您的程序必须是一个完整的、可运行的程序，能够完全按照规定格式生成最终输出。\n\n基本原理和建模假设：\n- 药物基因组学基因型影响药物代谢和药物靶点敏感性（中心法则：DNA 到 RNA 到蛋白质），从而导致剂量调整。当效应对于小扰动近似为加性时，我们采用经过充分检验的方法，将剂量建模为基因型特征和临床协变量的线性函数。\n- 我们将通过最小化残差平方和（普通最小二乘法）来训练一个线性回归模型，这是一种在线性模型中进行参数估计的标准且经过充分检验的方法。\n- 我们要求对每个预测使用 SHapley 加性解释 (SHAP) 或满足标准公理（效率公理、对称公理、虚拟公理和可加性公理）的等效合作博弈论加性归因方法进行可解释的局部解释，其背景数据集由训练数据的经验特征分布定义。\n\n数据规范：\n- 特征按以下顺序排列和索引：\n  - 索引 $0$：CYP2C9 活性评分（取值范围为 $\\{0,1,2\\}$）。\n  - 索引 $1$：VKORC1 $-1639$ A等位基因计数（取值范围为 $\\{0,1,2\\}$）。\n  - 索引 $2$：年龄（以十年为单位，例如，年龄 $50$ 岁编码为 $5.0$）。\n  - 索引 $3$：体重（以十公斤为单位，例如，体重 $70$ 公斤编码为 $7.0$）。\n\n- 训练设计矩阵 $X_{\\text{train}} \\in \\mathbb{R}^{6 \\times 4}$ 和目标向量 $y_{\\text{train}} \\in \\mathbb{R}^{6}$（稳定华法林剂量，单位为 mg/天）由下式给出：\n$$\nX_{\\text{train}}=\n\\begin{bmatrix}\n2 & 0 & 5.0 & 7.0\\\\\n1 & 1 & 6.0 & 6.5\\\\\n2 & 2 & 4.0 & 8.0\\\\\n0 & 1 & 7.0 & 5.0\\\\\n1 & 0 & 3.0 & 9.0\\\\\n2 & 1 & 5.5 & 7.5\n\\end{bmatrix},\n\\quad\ny_{\\text{train}}=\n\\begin{bmatrix}\n6.3\\\\\n5.55\\\\\n5.2\\\\\n5.2\\\\\n8.3\\\\\n5.55\n\\end{bmatrix}.\n$$\n\n任务要求：\n1) 在 $(X_{\\text{train}}, y_{\\text{train}})$ 上通过最小化误差平方和来拟合一个包含截距项的线性回归模型。将拟合后的模型表示为 $f(\\mathbf{x})=\\hat{b}+\\sum_{i=0}^{3}\\hat{w}_i x_i$。\n\n2) 将用于解释的背景数据集定义为 $X_{\\text{train}}$ 的经验分布。使用 SHapley 加性解释 (SHAP) 或满足标准公理并使用指定背景数据集的等效合作博弈论加性分解方法，将每个预测分解为一个基线项和多个加性特征归因。具体来说，对于任何输入 $\\mathbf{x}$，计算一个加性分解 $f(\\mathbf{x})=\\phi_0+\\sum_{i=0}^{3}\\phi_i(\\mathbf{x})$，其中 $\\phi_0$ 是与背景相关的基线预测，$\\phi_i(\\mathbf{x})$ 是特征 $i$ 的贡献。您必须实现一种与线性模型的 SHAP 公理和所述背景相符的归因方法。\n\n3) 对于下方的每个测试用例，计算：\n   - 患者 A 的预测剂量 $f(\\mathbf{x}^{(A)})$，单位为 mg/天。\n   - 患者 B 的预测剂量 $f(\\mathbf{x}^{(B)})$，单位为 mg/天。\n   - 差异 $f(\\mathbf{x}^{(B)})-f(\\mathbf{x}^{(A)})$，单位为 mg/天。\n   - 使 B 和 A 之间归因绝对差异最大化的特征索引 $j \\in \\{0,1,2,3\\}$，即 $j=\\arg\\max_{i} \\left|\\phi_i(\\mathbf{x}^{(B)})-\\phi_i(\\mathbf{x}^{(A)})\\right|$。如果出现平局，则返回最小的那个索引。\n   - 该特征的带符号的贡献差异 $\\phi_j(\\mathbf{x}^{(B)})-\\phi_j(\\mathbf{x}^{(A)})$，单位为 mg/天。\n\n测试套件：\n- 用例 $1$ (正常路径：基因型相同，体重不同):\n  - 患者 A: $\\mathbf{x}^{(A)}=[2,\\,1,\\,6.0,\\,6.0]$\n  - 患者 B: $\\mathbf{x}^{(B)}=[2,\\,1,\\,6.0,\\,8.0]$\n- 用例 $2$ (CYP2C9 存在基因型差异，协变量相同):\n  - 患者 A: $\\mathbf{x}^{(A)}=[1,\\,1,\\,5.0,\\,7.0]$\n  - 患者 B: $\\mathbf{x}^{(B)}=[2,\\,1,\\,5.0,\\,7.0]$\n- 用例 $3$ (边界情况：患者完全相同):\n  - 患者 A: $\\mathbf{x}^{(A)}=[2,\\,1,\\,5.5,\\,7.5]$\n  - 患者 B: $\\mathbf{x}^{(B)}=[2,\\,1,\\,5.5,\\,7.5]$\n\n单位和四舍五入：\n- 所有预测剂量和贡献值均以 mg/天为单位表示，并四舍五入到三位小数。特征索引是一个整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个元素对应一个测试用例，本身也是一个列表：$\\left[f(\\mathbf{x}^{(A)}), f(\\mathbf{x}^{(B)}), f(\\mathbf{x}^{(B)})-f(\\mathbf{x}^{(A)}), j, \\phi_j(\\mathbf{x}^{(B)})-\\phi_j(\\mathbf{x}^{(A)})\\right]$。\n- 因此，最终输出必须是形如下式的单行：\n  - 例如，使用占位符：$[[a_1,b_1,d_1,j_1,c_1],[a_2,b_2,d_2,j_2,c_2],[a_3,b_3,d_3,j_3,c_3]]$\n- 输出行中不允许有空格。必须仅打印带有方括号列表的这一行。", "solution": "该问题具有科学依据，提法严谨且客观。它指定了药物基因组学中的一个标准计算任务：拟合一个预测性线性模型，并解释其对特定个体的预测。数据、假设和所需计算都已明确定义，从而可以得到唯一且可验证的解决方案。所有必要组成部分——训练数据、模型类型、解释框架和测试用例——都已提供。该问题是有效的，我将继续提供完整的解决方案。\n\n目标是构建一个用于华法林剂量预测的线性回归模型，并使用一种等效于 SHapley 加性解释 (SHAP) 的博弈论归因方法来解释患者对之间预测的差异。\n\n**第1步：线性回归模型拟合**\n\n要拟合的模型是 $p=4$ 个特征的线性函数，包括一个截距项：\n$$f(\\mathbf{x}) = \\beta_0 + \\sum_{i=1}^{p} \\beta_i x_{i-1} = \\beta_0 + \\beta_1 x_0 + \\beta_2 x_1 + \\beta_3 x_2 + \\beta_4 x_3$$\n其中 $\\mathbf{x} = [x_0, x_1, x_2, x_3]^T$ 代表特征向量。系数 $\\mathbf{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4]^T$ 通过普通最小二乘法 (OLS) 估计，该方法旨在最小化残差平方和。\n\n给定训练数据 $X_{\\text{train}} \\in \\mathbb{R}^{6 \\times 4}$ 和 $y_{\\text{train}} \\in \\mathbb{R}^{6}$。为了容纳截距 $\\beta_0$，我们用一个全为1的前导列来增广特征矩阵 $X_{\\text{train}}$，从而创建设计矩阵 $X' \\in \\mathbb{R}^{6 \\times 5}$。\n$$\nX' =\n\\begin{bmatrix}\n1 & 2 & 0 & 5.0 & 7.0\\\\\n1 & 1 & 1 & 6.0 & 6.5\\\\\n1 & 2 & 2 & 4.0 & 8.0\\\\\n1 & 0 & 1 & 7.0 & 5.0\\\\\n1 & 1 & 0 & 3.0 & 9.0\\\\\n1 & 2 & 1 & 5.5 & 7.5\n\\end{bmatrix},\n\\quad\ny_{\\text{train}}=\n\\begin{bmatrix}\n6.3\\\\\n5.55\\\\\n5.2\\\\\n5.2\\\\\n8.3\\\\\n5.55\n\\end{bmatrix}\n$$\nOLS 估计值 $\\hat{\\mathbf{\\beta}}$ 是正规方程组的解：\n$$(X'^T X') \\hat{\\mathbf{\\beta}} = X'^T y_{\\text{train}}$$\n假设 $X'^T X'$ 是可逆的，则解由以下公式给出：\n$$\\hat{\\mathbf{\\beta}} = (X'^T X')^{-1} X'^T y_{\\text{train}}$$\n解此线性系统可得以下系数向量：\n$$\\hat{\\mathbf{\\beta}} \\approx [9.92349, -1.25301, -0.65000, -0.44157, 0.11747]^T$$\n因此，截距为 $\\hat{b} = \\hat{\\beta}_0 \\approx 9.923$，特征权重为 $\\hat{\\mathbf{w}} = [\\hat{w}_0, \\hat{w}_1, \\hat{w}_2, \\hat{w}_3]^T \\approx [-1.253, -0.650, -0.442, 0.117]^T$。\n拟合后的模型为：\n$$f(\\mathbf{x}) \\approx 9.923 - 1.253 x_0 - 0.650 x_1 - 0.442 x_2 + 0.117 x_3$$\n\n**第2步：用于预测解释的归因方法**\n\n该问题要求一种与 SHAP 公理一致的加性特征归因方法。对于线性模型 $f(\\mathbf{x}) = \\hat{b} + \\sum_{i=0}^{3} \\hat{w}_i x_i$，在输入 $\\mathbf{x}$ 处特征 $i$ 的 SHAP 值由下式给出：\n$$\\phi_i(\\mathbf{x}) = \\hat{w}_i (x_i - E[X_i])$$\n其中 $E[X_i]$ 是特征 $i$ 在背景数据分布上的期望值，该分布被定义为 $X_{\\text{train}}$ 的经验分布。因此，$E[X_i]$ 是 $X_{\\text{train}}$ 第 $i$ 列的均值。基准值 $\\phi_0$ 是模型在背景数据上的期望输出：\n$$\\phi_0 = E[f(\\mathbf{X})] = \\hat{b} + \\sum_{i=0}^{3} \\hat{w}_i E[X_i]$$\n分解式 $f(\\mathbf{x}) = \\phi_0 + \\sum_{i=0}^{3} \\phi_i(\\mathbf{x})$ 满足效率公理。\n\n任务是找出能够最好地解释两名患者 A 和 B 之间预测剂量*差异*的特征。特征 $i$ 的归因差异为：\n$$\\Delta\\phi_i = \\phi_i(\\mathbf{x}^{(B)}) - \\phi_i(\\mathbf{x}^{(A)})$$\n代入 $\\phi_i$ 的公式：\n$$\\Delta\\phi_i = \\left[\\hat{w}_i (x_i^{(B)} - E[X_i])\\right] - \\left[\\hat{w}_i (x_i^{(A)} - E[X_i])\\right]$$\n这可以简化为：\n$$\\Delta\\phi_i = \\hat{w}_i (x_i^{(B)} - x_i^{(A)})$$\n这个简洁的结果表明，一个特征贡献的变化就是其权重乘以其值的变化。这使我们能够计算所需的量，而无需显式地计算训练数据中的特征均值。解释了最大部分预测差异的特征 $j$ 通过以下方式找到：\n$$j = \\arg\\max_{i \\in \\{0,1,2,3\\}} |\\Delta\\phi_i| = \\arg\\max_{i \\in \\{0,1,2,3\\}} |\\hat{w}_i (x_i^{(B)} - x_i^{(A)})|$$\n平局通过选择最小的索引 $j$ 来解决。\n\n**第3步：测试用例评估**\n\n现在我们将这些公式应用于三个指定的测试用例。所有结果都四舍五入到三位小数。\n\n**用例 1:**\n- 患者 A: $\\mathbf{x}^{(A)} = [2, 1, 6.0, 6.0]$\n- 患者 B: $\\mathbf{x}^{(B)} = [2, 1, 6.0, 8.0]$\n- A 的预测剂量: $f(\\mathbf{x}^{(A)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(6.0) + 0.117(6.0) \\approx 4.817$\n- B 的预测剂量: $f(\\mathbf{x}^{(B)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(6.0) + 0.117(8.0) \\approx 5.052$\n- 剂量差异: $f(\\mathbf{x}^{(B)}) - f(\\mathbf{x}^{(A)}) \\approx 5.052 - 4.817 = 0.235$\n- 归因差异:\n  - $\\Delta\\phi_0 = \\hat{w}_0(2 - 2) = 0$\n  - $\\Delta\\phi_1 = \\hat{w}_1(1 - 1) = 0$\n  - $\\Delta\\phi_2 = \\hat{w}_2(6.0 - 6.0) = 0$\n  - $\\Delta\\phi_3 = \\hat{w}_3(8.0 - 6.0) = 2 \\hat{w}_3 \\approx 0.235$\n- 具有最大归因差异的特征: 唯一非零差异来自特征 $3$。因此，$j=3$。\n- $j=3$ 的带符号贡献差异: $\\Delta\\phi_3 \\approx 0.235$\n- 结果: $[4.817, 5.052, 0.235, 3, 0.235]$\n\n**用例 2:**\n- 患者 A: $\\mathbf{x}^{(A)} = [1, 1, 5.0, 7.0]$\n- 患者 B: $\\mathbf{x}^{(B)} = [2, 1, 5.0, 7.0]$\n- A 的预测剂量: $f(\\mathbf{x}^{(A)}) \\approx 9.923 - 1.253(1) - 0.650(1) - 0.442(5.0) + 0.117(7.0) \\approx 6.633$\n- B 的预测剂量: $f(\\mathbf{x}^{(B)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(5.0) + 0.117(7.0) \\approx 5.380$\n- 剂量差异: $f(\\mathbf{x}^{(B)}) - f(\\mathbf{x}^{(A)}) \\approx 5.380 - 6.633 = -1.253$\n- 归因差异:\n  - $\\Delta\\phi_0 = \\hat{w}_0(2 - 1) = \\hat{w}_0 \\approx -1.253$\n  - $\\Delta\\phi_1 = \\hat{w}_1(1 - 1) = 0$\n  - $\\Delta\\phi_2 = \\hat{w}_2(5.0 - 5.0) = 0$\n  - $\\Delta\\phi_3 = \\hat{w}_3(7.0 - 7.0) = 0$\n- 具有最大归因差异的特征: 唯一非零差异来自特征 $0$。因此，$j=0$。\n- $j=0$ 的带符号贡献差异: $\\Delta\\phi_0 \\approx -1.253$\n- 结果: $[6.633, 5.380, -1.253, 0, -1.253]$\n\n**用例 3:**\n- 患者 A: $\\mathbf{x}^{(A)} = [2, 1, 5.5, 7.5]$\n- 患者 B: $\\mathbf{x}^{(B)} = [2, 1, 5.5, 7.5]$\n- 患者相同，因此 $f(\\mathbf{x}^{(A)}) = f(\\mathbf{x}^{(B)})$。\n- 预测剂量: $f(\\mathbf{x}^{(A)}) \\approx 9.923 - 1.253(2) - 0.650(1) - 0.442(5.5) + 0.117(7.5) \\approx 5.217$\n- 剂量差异: $f(\\mathbf{x}^{(B)}) - f(\\mathbf{x}^{(A)}) = 0.000$\n- 归因差异: 由于 $\\mathbf{x}^{(A)} = \\mathbf{x}^{(B)}$，所有 $x_i^{(B)} - x_i^{(A)} = 0$。因此，对于所有 $i \\in \\{0, 1, 2, 3\\}$，$\\Delta\\phi_i = 0$。\n- 具有最大归因差异的特征: 所有绝对差异均为 $0$。平局规则规定选择最小的索引。因此，$j=0$。\n- $j=0$ 的带符号贡献差异: $\\Delta\\phi_0 = 0.000$\n- 结果: $[5.217, 5.217, 0.000, 0, 0.000]$\n\n这些计算为最终的程序实现提供了基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacogenomic prediction and explanation problem.\n\n    The solution involves three main steps:\n    1. Fit a linear regression model using Ordinary Least Squares (OLS) on the\n       provided training data.\n    2. For each test case, calculate the predicted warfarin dose for two patients,\n       A and B.\n    3. Calculate the difference in predictions and explain it by finding the\n       feature that contributes most to this difference, based on a SHAP-like\n       additive attribution method for linear models.\n    \"\"\"\n    \n    # 1. Define the training data from the problem statement.\n    X_train = np.array([\n        [2.0, 0.0, 5.0, 7.0],\n        [1.0, 1.0, 6.0, 6.5],\n        [2.0, 2.0, 4.0, 8.0],\n        [0.0, 1.0, 7.0, 5.0],\n        [1.0, 0.0, 3.0, 9.0],\n        [2.0, 1.0, 5.5, 7.5]\n    ])\n    y_train = np.array([6.3, 5.55, 5.2, 5.2, 8.3, 5.55])\n    \n    # 2. Fit a linear regression model.\n    # Augment the training data matrix with a column of ones for the intercept.\n    X_prime = np.hstack([np.ones((X_train.shape[0], 1)), X_train])\n    \n    # Solve the normal equations: (X'T * X') * beta = X'T * y\n    # This is numerically more stable than calculating the inverse directly.\n    try:\n        beta_hat = np.linalg.solve(X_prime.T @ X_prime, X_prime.T @ y_train)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if matrix is singular, though not expected here.\n        beta_hat = np.linalg.pinv(X_prime) @ y_train\n\n    intercept = beta_hat[0]\n    weights = beta_hat[1:]\n\n    # 3. Define the test cases.\n    test_cases = [\n        # Case 1 (happy path: identical genotypes, different weight)\n        (np.array([2.0, 1.0, 6.0, 6.0]), np.array([2.0, 1.0, 6.0, 8.0])),\n        # Case 2 (genotype difference at CYP2C9, same covariates)\n        (np.array([1.0, 1.0, 5.0, 7.0]), np.array([2.0, 1.0, 5.0, 7.0])),\n        # Case 3 (boundary: identical patients)\n        (np.array([2.0, 1.0, 5.5, 7.5]), np.array([2.0, 1.0, 5.5, 7.5]))\n    ]\n    \n    all_results = []\n\n    # 4. Process each test case.\n    for x_a, x_b in test_cases:\n        # a. Compute predicted doses for patient A and B.\n        # f(x) = intercept + sum(weights * features)\n        pred_a = intercept + weights.T @ x_a\n        pred_b = intercept + weights.T @ x_b\n\n        # b. Compute the difference in predictions.\n        pred_diff = pred_b - pred_a\n\n        # c. Compute the feature attribution differences.\n        # For a linear model, the SHAP-based attribution difference for feature i\n        # is simply weight_i * (x_b_i - x_a_i).\n        delta_phis = weights * (x_b - x_a)\n\n        # d. Find the feature index 'j' that maximizes the absolute attribution difference.\n        # np.argmax returns the first index in case of a tie, which satisfies the\n        # requirement to return the smallest such index.\n        j = np.argmax(np.abs(delta_phis))\n        \n        # e. Get the signed contribution difference for that feature.\n        contrib_diff = delta_phis[j]\n\n        # Store the 5 required values for the current test case.\n        case_result = [pred_a, pred_b, pred_diff, j, contrib_diff]\n        all_results.append(case_result)\n\n    # 5. Format the output string exactly as specified.\n    # Example format: [[a1,b1,d1,j1,c1],[a2,b2,d2,j2,c2],...]\n    # Floats must be rounded to three decimal places.\n    case_strings = []\n    for result in all_results:\n        pred_a_str = f\"{result[0]:.3f}\"\n        pred_b_str = f\"{result[1]:.3f}\"\n        pred_diff_str = f\"{result[2]:.3f}\"\n        j_str = str(result[3]) # Index is an integer\n        contrib_diff_str = f\"{result[4]:.3f}\"\n        \n        formatted_case = (\n            f\"[{pred_a_str},\"\n            f\"{pred_b_str},\"\n            f\"{pred_diff_str},\"\n            f\"{j_str},\"\n            f\"{contrib_diff_str}]\"\n        )\n        case_strings.append(formatted_case)\n\n    # Join all case strings with a comma and enclose in brackets.\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement must produce only the specified single-line format.\n    print(final_output)\n\nsolve()\n```", "id": "2413806"}]}