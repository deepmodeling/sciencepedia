{"hands_on_practices": [{"introduction": "蛋白质-配体对接的核心是能够准确评估和排序不同结合姿势的评分函数。这些函数通常由多个能量项组成，其中之一便是配体结合后产生的内部构象应变能。本练习将通过指导您从头开始实施一个经典的应变能计算，来揭开评分函数内部工作原理的神秘面纱。通过亲手计算键长、键角和二面角偏离其理想状态所引入的能量惩罚，您将对配体的能量状态如何影响其对接分数有一个具体而深入的理解。[@problem_id:2422877]", "problem": "您的任务是编写一个完整的程序，用于计算一个处在结合构象中配体的对接分数，该分数包含一个显式的构象应变惩罚项。对于一个给定的结合构象，总分定义为所提供的基础分数与一个和配体内部应变能成正比的惩罚项之和。设总分为 $S_{\\mathrm{total}}$，提供的基础分数为 $S_{\\mathrm{base}}$（单位为千卡/摩尔），非负权重因子为 $\\lambda$（无量纲）。应变能由经典分子力学模型定义，是键伸缩、角弯曲和扭转贡献的总和。总分由下式给出\n$$\nS_{\\mathrm{total}} \\;=\\; S_{\\mathrm{base}} + \\lambda \\, E_{\\mathrm{strain}},\n$$\n其中\n$$\nE_{\\mathrm{strain}} \\;=\\; \\sum_{\\text{bonds } i} \\frac{1}{2} \\, k_{b,i} \\, \\bigl(r_i - r_{0,i}\\bigr)^2 \\;+\\; \\sum_{\\text{angles } j} \\frac{1}{2} \\, k_{\\theta,j} \\, \\bigl(\\theta_j - \\theta_{0,j}\\bigr)^2 \\;+\\; \\sum_{\\text{torsions } k} k_{\\tau,k}\\,\\bigl(1 - \\cos\\left(n_k \\, (\\phi_k - \\phi_{0,k})\\right)\\bigr).\n$$\n此处，$k_{b,i}$ 是键力常数，单位为千卡/摩尔/平方埃，$r_i$ 是键长，单位为埃，$r_{0,i}$ 是相应的参考键长，单位为埃。$k_{\\theta,j}$ 是角力常数，单位为千卡/摩尔/弧度平方，$\\theta_j$ 是键角，单位为弧度，$\\theta_{0,j}$ 是相应的参考键角，单位为弧度。$k_{\\tau,k}$ 是扭转力常数，单位为千卡/摩尔，$n_k$ 是表示扭转周期性的正整数，$\\phi_k$ 是二面角，单位为弧度，$\\phi_{0,k}$ 是相应的参考二面角，单位为弧度。所有能量贡献均以千卡/摩尔表示。本问题中所有输入角度均以度为单位指定，且必须按度进行解释；三角函数 $\\cos(\\cdot)$ 使用弧度，所有角度差在计算能量前必须转换为弧度。输出的总分必须以千卡/摩尔为单位报告。\n\n您的程序必须评估以下测试套件。每个测试用例提供 $S_{\\mathrm{base}}$、$\\lambda$ 以及三个列表：键（bonds）、角（angles）和扭转（torsions）。键以三元组 $(k_b, r, r_0)$ 的形式提供；角以三元组 $(k_\\theta, \\theta_{\\mathrm{deg}}, \\theta_{0,\\mathrm{deg}})$ 的形式提供；扭转以四元组 $(k_\\tau, n, \\phi_{\\mathrm{deg}}, \\phi_{0,\\mathrm{deg}})$ 的形式提供。所有距离 $r$ 和 $r_0$ 的单位均为埃，所有提供的角度单位均为度，所有力常数的单位均如上述能量定义中所述。\n\n使用以下测试用例（每行是一个测试用例）：\n\n- 测试用例 1：\n  - $S_{\\mathrm{base}} = -7.5$, $\\lambda = 0.25$\n  - 键： $(300.0, 1.54, 1.52)$, $(200.0, 1.34, 1.34)$\n  - 角： $(60.0, 112.0, 109.5)$\n  - 扭转： $(0.5, 3, 60.0, 60.0)$, $(0.8, 3, 140.0, 60.0)$\n- 测试用例 2：\n  - $S_{\\mathrm{base}} = -3.2$, $\\lambda = 1.0$\n  - 键： $(250.0, 1.50, 1.50)$\n  - 角： $(50.0, 120.0, 120.0)$\n  - 扭转： $(1.2, 1, 180.0, 180.0)$\n- 测试用例 3：\n  - $S_{\\mathrm{base}} = -10.0$, $\\lambda = 0.5$\n  - 键： $(250.0, 1.58, 1.50)$, $(350.0, 1.40, 1.34)$\n  - 角： $(50.0, 130.0, 120.0)$, $(70.0, 100.0, 109.5)$\n  - 扭转： $(1.5, 2, 90.0, 0.0)$, $(0.3, 1, -180.0, 180.0)$\n- 测试用例 4：\n  - $S_{\\mathrm{base}} = -1.0$, $\\lambda = 0.0$\n  - 键： $(300.0, 1.60, 1.50)$\n  - 角： $(80.0, 140.0, 120.0)$\n  - 扭转： $(2.0, 3, 90.0, 60.0)$\n- 测试用例 5：\n  - $S_{\\mathrm{base}} = 0.0$, $\\lambda = 2.0$\n  - 键：无条目\n  - 角：无条目\n  - 扭转：无条目\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个分数都四舍五入到六位小数，例如 $[x_1,x_2,x_3,x_4,x_5]$。这些值必须以千卡/摩尔为单位，并且必须四舍五入到六位小数。输入中的角度单位是度，必须按度进行解释；在需要时，将其转换为弧度以用于公式计算。程序无需用户输入；它必须能直接运行并输出上述测试用例的分数。", "solution": "该问题陈述已经过严格验证，被认为是科学上合理、定义明确且客观的。它提出了一个计算分子内部应变能（对接分数的一个组成部分）的标准（尽管简化了）的计算化学公式。该问题是自洽的，提供了所有必要的数据和公式。不存在逻辑矛盾、含糊不清或事实错误。因此，不仅可能，而且需要一个直接的解决方案。\n\n任务是为一系列配体构象计算总对接分数 $S_{\\mathrm{total}}$。该分数由以下等式定义：\n$$\nS_{\\mathrm{total}} = S_{\\mathrm{base}} + \\lambda E_{\\mathrm{strain}}\n$$\n其中 $S_{\\mathrm{base}}$ 是给定的基础分数，$\\lambda$ 是一个无量纲的权重因子，$E_{\\mathrm{strain}}$ 是配体的内部构象应变能。问题为五个不同的测试用例提供了所有必要的参数。计算过程首先确定 $E_{\\mathrm{strain}}$，然后将其代入 $S_{\\mathrm{total}}$ 的方程中。\n\n应变能 $E_{\\mathrm{strain}}$ 使用经典分子力学势能函数进行建模，该函数是三个贡献之和：键伸缩、角弯曲和扭转。\n$$\nE_{\\mathrm{strain}} = E_{\\mathrm{bond}} + E_{\\mathrm{angle}} + E_{\\mathrm{torsion}}\n$$\n我们现在将详细说明每个分量的计算。\n\n键伸缩能 $E_{\\mathrm{bond}}$ 通过对所有指定键的贡献求和来计算。每个贡献都建模为谐振子势，用于惩罚与参考键长 $r_{0,i}$ 的偏差。公式为：\n$$\nE_{\\mathrm{bond}} = \\sum_{\\text{bonds } i} \\frac{1}{2} k_{b,i} (r_i - r_{0,i})^2\n$$\n此处，$k_{b,i}$ 是键力常数，单位为千卡/摩尔/Å²，$r_i$ 是测量的键长，单位为埃（Å），$r_{0,i}$ 是参考键长，单位为埃（Å）。每个测试用例的计算都涉及遍历所提供的键列表并累加每个键的能量。\n\n角弯曲能 $E_{\\mathrm{angle}}$ 的计算方式类似，即对所有指定角的谐振子势项求和。该项用于惩罚键角与参考值 $\\theta_{0,j}$ 的偏差。\n$$\nE_{\\mathrm{angle}} = \\sum_{\\text{angles } j} \\frac{1}{2} k_{\\theta,j} (\\theta_j - \\theta_{0,j})^2\n$$\n此计算的一个关键细节是单位的处理。力常数 $k_{\\theta,j}$ 的单位是千卡/摩尔/弧度²，这要求角度差 $(\\theta_j - \\theta_{0,j})$ 以弧度（rad）为单位。然而，输入的角度是以度为单位提供的。因此，必须进行转换：\n$$\n\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}} \\times \\frac{\\pi}{180}\n$$\n在计算角度差及其相应的能量贡献之前，算法必须将 $\\theta_j$ 和 $\\theta_{0,j}$ 都从度转换为弧度。\n\n扭转能（或二面角能）$E_{\\mathrm{torsion}}$ 由一个周期性余弦函数描述，该函数模拟了围绕化学键旋转的能垒。\n$$\nE_{\\mathrm{torsion}} = \\sum_{\\text{torsions } k} k_{\\tau,k} \\bigl(1 - \\cos\\left(n_k (\\phi_k - \\phi_{0,k})\\right)\\bigr)\n$$\n此处，$k_{\\tau,k}$ 是扭转力常数，单位为千卡/摩尔，$n_k$ 是周期性，$\\phi_k$ 和 $\\phi_{0,k}$ 分别是测量的二面角和参考二面角。与角弯曲项一样，三角函数 $\\cos(\\cdot)$ 对弧度进行运算。输入的二面角单位是度，在计算其差值并用于余弦函数的参数之前，必须将其转换为弧度。\n\n总体算法如下：\n1. 对于每个测试用例，检索参数：$S_{\\mathrm{base}}$、$\\lambda$ 以及键、角和扭转参数列表。\n2. 将总应变能 $E_{\\mathrm{strain}}$ 初始化为 $0$。\n3. 遍历键列表。对于每个键，使用键伸缩公式计算其能量，并将其加到 $E_{\\mathrm{strain}}$ 中。\n4. 遍历角列表。对于每个角，将其角度值从度转换为弧度，使用角弯曲公式计算能量，并将其加到 $E_{\\mathrm{strain}}$ 中。\n5. 遍历扭转列表。对于每个扭转，将其角度值从度转换为弧度，使用扭转旋转公式计算能量，并将其加到 $E_{\\mathrm{strain}}$ 中。\n6. 计算出总 $E_{\\mathrm{strain}}$ 后，计算最终分数 $S_{\\mathrm{total}} = S_{\\mathrm{base}} + \\lambda E_{\\mathrm{strain}}$。\n7. 然后按要求将计算出的分数四舍五入到六位小数。对所有测试用例重复此过程。最终输出是包含这些分数的单行逗号分隔列表，并用方括号括起来。对于 $\\lambda=0$ 的情况，从技术上讲，计算 $E_{\\mathrm{strain}}$ 是不必要的，因为它对 $S_{\\mathrm{total}}$ 的贡献为零，但一个稳健的实现无论如何都会计算它。对于没有几何项（列表为空）的情况，$E_{\\mathrm{strain}}$ 显然为 0。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ligand docking score problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"S_base\": -7.5, \"lambda\": 0.25,\n            \"bonds\": [(300.0, 1.54, 1.52), (200.0, 1.34, 1.34)],\n            \"angles\": [(60.0, 112.0, 109.5)],\n            \"torsions\": [(0.5, 3, 60.0, 60.0), (0.8, 3, 140.0, 60.0)]\n        },\n        # Test case 2\n        {\n            \"S_base\": -3.2, \"lambda\": 1.0,\n            \"bonds\": [(250.0, 1.50, 1.50)],\n            \"angles\": [(50.0, 120.0, 120.0)],\n            \"torsions\": [(1.2, 1, 180.0, 180.0)]\n        },\n        # Test case 3\n        {\n            \"S_base\": -10.0, \"lambda\": 0.5,\n            \"bonds\": [(250.0, 1.58, 1.50), (350.0, 1.40, 1.34)],\n            \"angles\": [(50.0, 130.0, 120.0), (70.0, 100.0, 109.5)],\n            \"torsions\": [(1.5, 2, 90.0, 0.0), (0.3, 1, -180.0, 180.0)]\n        },\n        # Test case 4\n        {\n            \"S_base\": -1.0, \"lambda\": 0.0,\n            \"bonds\": [(300.0, 1.60, 1.50)],\n            \"angles\": [(80.0, 140.0, 120.0)],\n            \"torsions\": [(2.0, 3, 90.0, 60.0)]\n        },\n        # Test case 5\n        {\n            \"S_base\": 0.0, \"lambda\": 2.0,\n            \"bonds\": [],\n            \"angles\": [],\n            \"torsions\": []\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_base = case[\"S_base\"]\n        lambda_val = case[\"lambda\"]\n        bonds = case[\"bonds\"]\n        angles = case[\"angles\"]\n        torsions = case[\"torsions\"]\n\n        # Calculate strain energy\n        e_strain = 0.0\n\n        # Bond stretching energy\n        for k_b, r, r_0 in bonds:\n            e_strain += 0.5 * k_b * (r - r_0)**2\n\n        # Angle bending energy\n        for k_theta, theta_deg, theta_0_deg in angles:\n            theta_rad = np.deg2rad(theta_deg)\n            theta_0_rad = np.deg2rad(theta_0_deg)\n            e_strain += 0.5 * k_theta * (theta_rad - theta_0_rad)**2\n\n        # Torsional rotation energy\n        for k_tau, n, phi_deg, phi_0_deg in torsions:\n            phi_rad = np.deg2rad(phi_deg)\n            phi_0_rad = np.deg2rad(phi_0_deg)\n            e_strain += k_tau * (1 - np.cos(n * (phi_rad - phi_0_rad)))\n\n        # Calculate total score\n        s_total = s_base + lambda_val * e_strain\n        results.append(s_total)\n\n    # Format the final output string\n    # Round to six decimal places and format as a string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2422877"}, {"introduction": "成功预测配体的结合姿势后，我们需要一种定量的方法来评估其准确性，尤其是当存在已知的实验结构（如晶体结构）作为参考时。均方根偏差（Root Mean Square Deviation, RMSD）是衡量两个结构重叠后差异的黄金标准。本练习将引导您计算一种更具化学意义的变体——基于药效团的 RMSD，它仅关注于对生物活性至关重要的化学特征。完成这个练习不仅能帮助您掌握姿势评估的核心技术，还能让您理解如何以化学家的方式来比较分子结构。[@problem_id:2422916]", "problem": "一个配体呈现出三个药效团特征：一个氢键（H-bond）供体，一个氢键（H-bond）受体，以及一个芳香环质心。现给定一个晶体学参考构象和一个对接构象中这些特征的三维（3D）笛卡尔坐标，单位为埃（Å）。基于药效团的均方根偏差（RMSD）定义为，在对所选特征进行最佳刚体叠合（一次旋转和一次平移）以最小化这些特征上的 RMSD 后，仅对这些药效团特征位置计算得到的 RMSD。\n\n晶体构象特征坐标（Å）：\n- 供体：$\\left(1,\\,0,\\,0\\right)$\n- 受体：$\\left(0,\\,1,\\,0\\right)$\n- 芳香环质心：$\\left(-1,\\,-1,\\,0\\right)$\n\n对接构象特征坐标（Å）：\n- 供体：$\\left(0,\\,1,\\,0\\right)$\n- 受体：$\\left(-1,\\,0,\\,0\\right)$\n- 芳香环质心：$\\left(1.1,\\,-1,\\,0\\right)$\n\n假设对应关系为：供体 $\\leftrightarrow$ 供体，受体 $\\leftrightarrow$ 受体，芳香环质心 $\\leftrightarrow$ 芳香环质心。使用 RMSD 的标准定义，\n$$\\mathrm{RMSD} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left\\|\\mathbf{r}_{i}-\\mathbf{s}_{i}\\right\\|^{2}},$$\n其中 $N$ 是匹配特征的数量，$\\mathbf{r}_{i}$ 和 $\\mathbf{s}_{i}$ 是对应特征在最佳叠合后的坐标，计算对接构象和晶体构象之间的基于药效团的 RMSD。对这三个特征执行最佳刚体叠合，以最小化 RMSD。\n\n请用一个以埃为单位的精确解析表达式表示您的最终答案。不要四舍五入。最终报告的值必须是单一的精确表达式。", "solution": "该问题要求计算一个配体的晶体构象和对接构象之间的基于药效团的均方根偏差（RMSD）。RMSD 需要在对三个指定的特征点进行最佳刚体叠合后计算得出。\n\n设晶体构象的坐标集为 $P = \\{\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3\\}$，对接构象的坐标集为 $Q = \\{\\mathbf{q}_1, \\mathbf{q}_2, \\mathbf{q}_3\\}$。对应关系如下：\n$\\mathbf{p}_1 = (1, 0, 0)$ (供体) $\\leftrightarrow$ $\\mathbf{q}_1 = (0, 1, 0)$ (供体)\n$\\mathbf{p}_2 = (0, 1, 0)$ (受体) $\\leftrightarrow$ $\\mathbf{q}_2 = (-1, 0, 0)$ (受体)\n$\\mathbf{p}_3 = (-1, -1, 0)$ (芳香环) $\\leftrightarrow$ $\\mathbf{q}_3 = (1.1, -1, 0)$ (芳香环)\n\n特征点数量为 $N=3$。RMSD 由下式给出：\n$$ \\mathrm{RMSD} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i - \\mathbf{s}_i\\|^2} $$\n其中 $\\mathbf{r}_i$ 和 $\\mathbf{s}_i$ 是最佳叠合后对应特征的坐标。这通过找到旋转矩阵 $R$ 和平移向量 $\\mathbf{t}$ 来实现，以最小化距离平方和 $$D^2 = \\sum_{i=1}^{N} \\| R\\mathbf{q}_i + \\mathbf{t} - \\mathbf{p}_i \\|^2$$。\n\n标准流程（Kabsch 算法）包括以下步骤：\n1.  **将两个点集都平移到各自的质心。**\n    晶体构象特征的质心 $\\mathbf{p}_c$ 是：\n    $$ \\mathbf{p}_c = \\frac{1}{3}(\\mathbf{p}_1 + \\mathbf{p}_2 + \\mathbf{p}_3) = \\frac{1}{3}\\left((1,0,0) + (0,1,0) + (-1,-1,0)\\right) = \\frac{1}{3}(0,0,0) = (0,0,0) $$\n    对接构象特征的质心 $\\mathbf{q}_c$ 是：\n    $$ \\mathbf{q}_c = \\frac{1}{3}(\\mathbf{q}_1 + \\mathbf{q}_2 + \\mathbf{q}_3) = \\frac{1}{3}\\left((0,1,0) + (-1,0,0) + (1.1, -1, 0)\\right) = \\frac{1}{3}(0.1, 0, 0) = \\left(\\frac{1}{30}, 0, 0\\right) $$\n    最佳平移向量 $\\mathbf{t}$ 使质心叠合：$\\mathbf{t} = \\mathbf{p}_c - R\\mathbf{q}_c$。问题随之简化为求解中心化坐标的最佳旋转 $R$。\n    中心化坐标为 $\\mathbf{x}_i = \\mathbf{p}_i - \\mathbf{p}_c$ 和 $\\mathbf{y}_i = \\mathbf{q}_i - \\mathbf{q}_c$。\n    由于 $\\mathbf{p}_c = (0,0,0)$，我们有 $\\mathbf{x}_i = \\mathbf{p}_i$：\n    $$ \\mathbf{x}_1 = (1, 0, 0), \\quad \\mathbf{x}_2 = (0, 1, 0), \\quad \\mathbf{x}_3 = (-1, -1, 0) $$\n    对接构象的中心化坐标是：\n    $$ \\mathbf{y}_1 = (0, 1, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(-\\frac{1}{30}, 1, 0\\right) $$\n    $$ \\mathbf{y}_2 = (-1, 0, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(-\\frac{31}{30}, 0, 0\\right) $$\n    $$ \\mathbf{y}_3 = (1.1, -1, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(\\frac{11}{10} - \\frac{1}{30}, -1, 0\\right) = \\left(\\frac{32}{30}, -1, 0\\right) $$\n\n2.  **计算最小误差平方和。**\n    误差平方和的最小值 $D^2_{\\min}$ 由下式给出：\n    $$ D^2_{\\min} = \\sum_{i=1}^{N} \\|\\mathbf{x}_i\\|^2 + \\sum_{i=1}^{N} \\|\\mathbf{y}_i\\|^2 - 2 \\sum_{k=1}^{3} \\sigma'_k $$\n    其中 $\\sigma'_k$ 是协方差矩阵 $C = \\sum_{i=1}^{N} \\mathbf{x}_i \\mathbf{y}_i^T$ 的奇异值，如果最佳变换是反射，则最小奇异值的符号需要翻转。\n\n    首先，我们计算中心化向量的范数平方和：\n    $$ \\sum_{i=1}^{3} \\|\\mathbf{x}_i\\|^2 = (1^2+0^2+0^2) + (0^2+1^2+0^2) + ((-1)^2+(-1)^2+0^2) = 1 + 1 + 2 = 4 $$\n    $$ \\sum_{i=1}^{3} \\|\\mathbf{y}_i\\|^2 = \\left(\\left(-\\frac{1}{30}\\right)^2 + 1^2\\right) + \\left(\\left(-\\frac{31}{30}\\right)^2\\right) + \\left(\\left(\\frac{32}{30}\\right)^2 + (-1)^2\\right) $$\n    $$ = \\frac{1}{900} + 1 + \\frac{961}{900} + \\frac{1024}{900} + 1 = 2 + \\frac{1+961+1024}{900} = 2 + \\frac{1986}{900} = 2 + \\frac{331}{150} = \\frac{631}{150} $$\n\n3.  **构建协方差矩阵并求其奇异值之和。**\n    所有给定坐标都位于 $z=0$ 平面上，这使其成为一个二维问题。我们使用 $\\mathbf{x}_i$ 和 $\\mathbf{y}_i$ 的 $x$ 和 $y$ 分量构建一个 $2 \\times 2$ 的协方差矩阵 $C'$：\n    $$ C' = \\sum_{i=1}^{3} \\begin{pmatrix} x_{i,1} \\\\ x_{i,2} \\end{pmatrix} \\begin{pmatrix} y_{i,1}  y_{i,2} \\end{pmatrix} $$\n    $$ C'_{jk} = \\sum_{i=1}^3 x_{i,j} y_{i,k} $$\n    $$ C'_{11} = (1)\\!\\left(-\\frac{1}{30}\\right) + (0)\\!\\left(-\\frac{31}{30}\\right) + (-1)\\!\\left(\\frac{32}{30}\\right) = -\\frac{1}{30}-\\frac{32}{30} = -\\frac{33}{30} = -\\frac{11}{10} $$\n    $$ C'_{12} = (1)(1) + (0)(0) + (-1)(-1) = 1+1=2 $$\n    $$ C'_{21} = (0)\\!\\left(-\\frac{1}{30}\\right) + (1)\\!\\left(-\\frac{31}{30}\\right) + (-1)\\!\\left(\\frac{32}{30}\\right) = -\\frac{31}{30}-\\frac{32}{30} = -\\frac{63}{30} = -\\frac{21}{10} $$\n    $$ C'_{22} = (0)(1) + (1)(0) + (-1)(-1) = 1 $$\n    所以，二维协方差矩阵为：\n    $$ C' = \\begin{pmatrix} -11/10  2 \\\\ -21/10  1 \\end{pmatrix} $$\n    带符号的奇异值之和 $\\sum \\sigma'_k$ 对应于 $\\mathrm{tr}(RC')$ 的最大值，其中 $R$ 是一个旋转矩阵。对于一个二维旋转 $R(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}$，其迹为：\n    $$ \\mathrm{tr}(R(\\theta)C') = (C'_{11}+C'_{22})\\cos\\theta + (C'_{21}-C'_{12})\\sin\\theta $$\n    令 $A = C'_{11}+C'_{22} = -11/10 + 1 = -1/10$ 且 $B = C'_{21}-C'_{12} = -21/10 - 2 = -41/10$。\n    $A\\cos\\theta+B\\sin\\theta$ 的最大值为 $\\sqrt{A^2+B^2}$。这个值等于奇异值之和 $\\sigma_1 + \\sigma_2$，因为 $\\det(C') = (-11/10)(1) - (2)(-21/10) = -11/10 + 42/10 = 31/10 > 0$，这确保了最佳变换是一个纯旋转（proper rotation）。\n    $$ \\sum_{k=1}^2 \\sigma_k = \\sqrt{\\left(-\\frac{1}{10}\\right)^2 + \\left(-\\frac{41}{10}\\right)^2} = \\sqrt{\\frac{1}{100} + \\frac{1681}{100}} = \\sqrt{\\frac{1682}{100}} = \\frac{\\sqrt{1682}}{10} $$\n    由于 $1682 = 2 \\times 841 = 2 \\times 29^2$，和为：\n    $$ \\sum_{k=1}^2 \\sigma_k = \\frac{\\sqrt{2 \\times 29^2}}{10} = \\frac{29\\sqrt{2}}{10} $$\n    由于问题是平面的，第三个奇异值 $\\sigma_3$ 为 $0$。\n\n4.  **计算 RMSD。**\n    现在我们将这些值代入 RMSD 公式：\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{N} D^2_{\\min} = \\frac{1}{3} \\left( \\sum \\|\\mathbf{x}_i\\|^2 + \\sum \\|\\mathbf{y}_i\\|^2 - 2\\sum \\sigma_k \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{3} \\left( 4 + \\frac{631}{150} - 2\\left(\\frac{29\\sqrt{2}}{10}\\right) \\right) = \\frac{1}{3} \\left( \\frac{600}{150} + \\frac{631}{150} - \\frac{29\\sqrt{2}}{5} \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{3} \\left( \\frac{1231}{150} - \\frac{29\\sqrt{2} \\times 30}{5 \\times 30} \\right) = \\frac{1}{3} \\left( \\frac{1231 - 870\\sqrt{2}}{150} \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1231 - 870\\sqrt{2}}{450} $$\n    最终的 RMSD 是该值的平方根：\n    $$ \\mathrm{RMSD} = \\sqrt{\\frac{1231 - 870\\sqrt{2}}{450}} $$\n    平方根内的值为正，因为 $870\\sqrt{2} \\approx 870 \\times 1.414 = 1230.18  1231$。", "answer": "$$ \\boxed{\\sqrt{\\frac{1231 - 870\\sqrt{2}}{450}}} $$", "id": "2422916"}, {"introduction": "虽然评分函数是强大的工具，但它们是对复杂物理现实的简化模型，因此存在固有的局限性。本项高级练习旨在培养您的批判性思维，从模型的使用者转变为模型的审视者。通过设计一个能够“欺骗”评分函数，获得高分但实际上结合能力很差的“恶意”配体，您将深刻洞察到简易评分函数的一个典型失败模式——忽视去溶剂化惩罚。这个富有挑战性的实践将磨练您的科学直觉，并强调理解计算模型背后假设的重要性。[@problem_id:2422880]", "problem": "给定一个为研究针对经验性评分函数的对抗性行为而设计的、简化但科学上合理的蛋白质-配体对接情景。一个受体由三维空间中（单位为埃）用于形成氢键的特征点描述：受体供体和受体受体。一个配体同样由配体供体和配体受体描述。当一对特征点中一个是供体，另一个是受体，且两点之间的欧几里得距离在指定的截断值之内时，这对特征点就构成一个氢键接触。该经验性评分不考虑角度依赖性，也没有体积惩罚。距离必须以埃为单位处理。能量必须以千卡/摩尔为单位处理。\n\n为任何构建的配体和固定的受体定义以下内容：\n\n- 经验性评分（待利用）：\n  - 经验性氢键接触计数是指距离小于或等于截断值 $d_{\\mathrm{hb}}$ 的供体-受体对的总数。\n  - 经验性冲突计数是指与任何受体特征点（供体或受体）的距离小于冲突距离 $d_{\\mathrm{clash}}$ 的配体特征点（供体或受体）的总数。\n  - 经验性评分为\n  $$S = w_{\\mathrm{hb}} \\cdot N_{\\mathrm{hb}} - w_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash}}.$$\n\n- 基于物理的质量代理（用于检测不良结合物）：\n  - 对于受体和配体之间的每一个供体-受体对，设其距离为 $r$。定义一个软距离依赖的接触权重\n  $$g(r) = \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right)。$$\n  - 物理能量代理为\n  $$E_{\\mathrm{true}} = - e_{\\mathrm{hb}} \\cdot \\sum_{\\text{所有受体-配体供体-受体对}} g(r) + p_{\\mathrm{polar}} \\cdot n_{\\mathrm{polar}} + p_{\\mathrm{rot}} \\cdot \\max(n_{\\mathrm{atoms}} - 1, 0) + p_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash,true}}，$$\n  其中 $n_{\\mathrm{polar}}$ 是配体供体和受体的数量（全部计为极性基团），$n_{\\mathrm{atoms}}$ 是配体供体和受体的总数，而 $N_{\\mathrm{clash,true}}$ 与 $N_{\\mathrm{clash}}$ 相同，但用于物理惩罚项。较低的 $E_{\\mathrm{true}}$ 表示更好的结合物；这里，“不良结合物”是指 $E_{\\mathrm{true}}$ 超过指定阈值的结合物。所有能量必须以 kcal/mol 表示。\n\n任务。对于每个测试用例，您必须构建一个配体，该配体明确地利用经验性评分 $S$，使其尽可能高，即使物理代理 $E_{\\mathrm{true}}$ 很差。您的程序必须为每个测试用例生成一个布尔值，指示您是否成功生成了一个“恶意”配体，其定义为同时满足以下两个条件的配体：\n- $S \\ge S_{\\mathrm{target}}$ 且\n- $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$,\n其中 $S_{\\mathrm{target}}$ 和 $E_{\\mathrm{bad}}$ 在下文的每个测试用例中指定。\n\n使用的基础原理：\n- 对接的经验性评分通常只计算在截断距离内的接触，而不考虑角度项。这是具有硬距离截断值 $d_{\\mathrm{hb}}$ 的 $N_{\\mathrm{hb}}$ 的基础。\n- 氢键的真实物理有利性在优选距离 $r_0$ 附近是距离敏感的，并受到与极性基团数量和柔性自由度成正比的去溶剂化和构象熵成本的惩罚。这是高斯函数 $g(r)$、每个极性基团的惩罚项 $p_{\\mathrm{polar}}$ 以及每个可旋转键的代理项 $p_{\\mathrm{rot}}$ 的基础。\n\n几何与单位：\n- 所有坐标均以埃为单位给出；您构建的配体坐标也必须以埃为单位。\n- 所有能量必须以千卡/摩尔计算。\n- 本问题中不使用角度。\n\n对于所有测试用例，使用标准欧几里得度量计算距离，“在截断值内”定义为小于或等于该截断值。\n\n测试套件。对于每个测试用例，都指定了受体特征、参数和阈值。受体供体和受体以 $[x,y,z]$ 坐标（埃）列表的形式给出。在此简化设置中，没有受体疏水基团。\n\n- 测试用例1（理想情况下的对抗性成功）：\n  - 受体受体：\n    - $[0.0, 0.0, 0.0]$, $[4.0, 0.0, 0.0]$, $[0.0, 4.0, 0.0]$, $[0.0, 0.0, 4.0]$, $[3.0, 3.0, 0.0]$。\n  - 受体供体：无。\n  - 经验性评分参数：$d_{\\mathrm{hb}} = 3.5$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$。\n  - 物理代理参数：$r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$。\n  - 阈值：$S_{\\mathrm{target}} = 5$, $E_{\\mathrm{bad}} = 5.0$。\n\n- 测试用例2（利用行为应无法满足“不良结合物”标准的边界情况）：\n  - 受体受体：\n    - $[0.0, 0.0, 0.0]$, $[5.0, 0.0, 0.0]$。\n  - 受体供体：\n    - $[0.0, 5.0, 0.0]$。\n  - 经验性评分参数：$d_{\\mathrm{hb}} = 2.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$。\n  - 物理代理参数：$r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$。\n  - 阈值：$S_{\\mathrm{target}} = 3$, $E_{\\mathrm{bad}} = 2.0$。\n\n- 测试用例3（混合特征、更大截断值、明确的对抗性成功）：\n  - 受体受体：\n    - $[0.0, 0.0, 0.0]$, $[2.0, 0.0, 0.0]$, $[0.0, 2.0, 0.0]$。\n  - 受体供体：\n    - $[1.0, 1.0, 0.0]$, $[1.0, -1.0, 0.0]$, $[3.0, 1.0, 0.0]$。\n  - 经验性评分参数：$d_{\\mathrm{hb}} = 3.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$。\n  - 物理代理参数：$r_0 = 2.8$, $\\sigma = 0.35$, $e_{\\mathrm{hb}} = 2.8$, $p_{\\mathrm{polar}} = 2.0$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$。\n  - 阈值：$S_{\\mathrm{target}} = 6$, $E_{\\mathrm{bad}} = 8.0$。\n\n您的程序必须为每个测试用例构建一个配体（供体和受体坐标集），旨在通过将互补的配体特征放置在尽可能多的受体特征的氢键截断距离内，同时在可行的情况下避免经验性冲突，从而最大化经验性评分 $S$。对配体原子数量没有其他限制。然后，按照上述定义计算 $S$ 和 $E_{\\mathrm{true}}$，并返回是否满足恶意成功的标准。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表（例如，“[True,False,True]”）。这三个布尔值必须按顺序分别对应于测试用例1、测试用例2和测试用例3。不得打印任何其他文本。", "solution": "用户提出了一个计算生物学问题，该问题关于构建对抗性配体，旨在最大化简化的经验性对接评分 $S$，同时使其具有较差的、基于物理的结合特性，该特性通过代理能量 $E_{\\mathrm{true}}$ 来衡量。如果一个配体对于给定的阈值同时满足 $S \\ge S_{\\mathrm{target}}$ 和 $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$，则被视为“恶意的”。\n\n首先验证问题的科学合理性和逻辑一致性。\n\n**步骤1：提取已知条件**\n- **受体/配体特征**：由氢键供体和受体的空间坐标定义。\n- **经验性评分, $S$**：$S = w_{\\mathrm{hb}} \\cdot N_{\\mathrm{hb}} - w_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash}}$。\n  - $N_{\\mathrm{hb}}$: 距离 $r \\le d_{\\mathrm{hb}}$ 的供体-受体对的数量。\n  - $N_{\\mathrm{clash}}$: 与任何受体特征点的距离 $r  d_{\\mathrm{clash}}$ 的配体特征点的数量。\n- **物理能量代理, $E_{\\mathrm{true}}$**：$E_{\\mathrm{true}} = - e_{\\mathrm{hb}} \\cdot \\sum g(r) + p_{\\mathrm{polar}} \\cdot n_{\\mathrm{polar}} + p_{\\mathrm{rot}} \\cdot \\max(n_{\\mathrm{atoms}} - 1, 0) + p_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash,true}}$。\n  - $g(r) = \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right)$ 是供体-受体对的软接触权重。\n  - $n_{\\mathrm{polar}}$: 配体极性原子（供体/受体）的数量。\n  - $n_{\\mathrm{atoms}}$: 配体特征点的总数。\n  - $N_{\\mathrm{clash,true}}$: 与 $N_{\\mathrm{clash}}$ 相同。\n- **任务**：为每个测试用例构建一个配体以最大化 $S$，然后确定它是否满足“恶意”标准：$S \\ge S_{\\mathrm{target}}$ 和 $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$。\n- **测试用例**：提供了三个不同的测试用例，每个用例都具有特定的受体几何形状、评分参数和阈值。\n\n**步骤2：验证问题陈述**\n该问题具有科学依据，模拟了简单对接评分函数中一个已知的漏洞，即相互作用是用硬性距离截断来建模的。物理代理能量 $E_{\\mathrm{true}}$ 正确地引入了诸如最佳相互作用距离 ($r_0$)、去溶剂化惩罚 (与 $p_{\\mathrm{polar}}$ 相关) 和构象熵成本 (与 $p_{\\mathrm{rot}}$ 相关) 等概念。问题是适定的，提供了所有必要的定义、常数和数据。术语在数学上是明确定义的和客观的。不存在矛盾或逻辑缺陷。\n\n**结论**：问题有效，可以解决。\n\n**步骤3：解决方案设计**\n目标是构建一个具有对抗性的配体。这意味着需要一种策略来最大化经验性评分 $S$，同时使物理能量代理 $E_{\\mathrm{true}}$ 尽可能差（高）。\n\n**评分分析：**\n- 为了最大化 $S = w_{\\mathrm{hb}} N_{\\mathrm{hb}} - w_{\\mathrm{clash}} N_{\\mathrm{clash}}$，我们必须最大化 $N_{\\mathrm{hb}}$ 并最小化 $N_{\\mathrm{clash}}$。$N_{\\mathrm{hb}}$ 的最大可能值对应于与受体上的每个特征点形成氢键。一个旨在实现此目的的简单配体构建方法是为每个受体原子放置一个互补的配体原子。为避免惩罚项，每个配体原子必须放置在距离所有受体原子 $r \\ge d_{\\mathrm{clash}}$ 的位置。\n- 为了最大化 $E_{\\mathrm{true}}$，我们必须使有利的能量项 $- e_{\\mathrm{hb}} \\sum g(r)$ 尽可能小（接近于零）。函数 $g(r)$ 是一个在 $r=r_0$ 处达到峰值的高斯函数，因此要最小化其值，相互作用距离 $r$ 应尽可能远离 $r_0$。惩罚项 $p_{\\mathrm{polar}}$、 $p_{\\mathrm{rot}}$ 和 $p_{\\mathrm{clash}}$ 应被最大化。\n\n**对抗性构建策略：**\n一个理性的对抗性策略结合了这些目标：\n1.  **配体组成**：对于受体上的 $N$ 个特征点（供体和受体）中的每一个，我们构建一个带有一个互补特征点的配体。这将 $n_{\\mathrm{atoms}} = n_{\\mathrm{polar}} = N$。这最大化了 $N_{\\mathrm{hb}}$ 的潜力。\n2.  **配体原子放置**：为了同时满足高 $S$ 和高 $E_{\\mathrm{true}}$ 的条件，我们应将每个配体原子放置在距离其目标受体原子为 $r$ 的位置，使得：\n    a. $d_{\\mathrm{clash}} \\le r \\le d_{\\mathrm{hb}}$ (以便计入 $N_{\\mathrm{hb}}$ 并避免 $S$ 的经验性冲突)。\n    b. $|r - r_0|$ 被最大化 (以最小化对 $E_{\\mathrm{true}}$ 的有利贡献)。这意味着在允许区间的某个边界上选择 $r$，即 $r = d_{\\mathrm{clash}}$ 或 $r = d_{\\mathrm{hb}}$。对于所有提供的测试用例，都有 $|d_{\\mathrm{clash}} - r_0|  |d_{\\mathrm{hb}} - r_0|$，这使得 $r = d_{\\mathrm{clash}}$ 成为对抗性放置的最佳选择。\n    c. 放置的配体原子不得与任何其他受体原子发生冲突。如果受体原子紧密堆积，沿固定轴（例如 x 轴）的简单位移可能会导致意外的冲突。一个更稳健的方法是测试几个正交位移矢量，并选择第一个不会与任何受体原子发生冲突的矢量。\n\n**算法实现：**\n对于每个测试用例：\n1.  构建配体。对于每个受体特征点 $\\vec{p}_i$，找到一个互补配体原子的有效位置。如果一个位置 $\\vec{p}'_i = \\vec{p}_i + \\vec{\\delta}$ 距离任何受体原子 $\\vec{p}_j$ 都大于或等于 $d_{\\mathrm{clash}}$，则该位置是有效的。我们测试一系列大小为 $d_{\\mathrm{clash}}$ 的正交位移矢量 $\\vec{\\delta}$ (例如, $(d_{\\mathrm{clash}}, 0, 0), (0, d_{\\mathrm{clash}}, 0), \\dots, (0, 0, -d_{\\mathrm{clash}})$)，并使用第一个产生有效、无冲突位置的矢量。\n2.  计算所构建配体的分数。\n    a. 根据上述策略确定所有配体供体和受体的坐标。\n    b. 通过计算所有距离 $\\le d_{\\mathrm{hb}}$ 的（受体供体，配体受体）和（受体受体，配体供体）对来计算 $N_{\\mathrm{hb}}$。\n    c. 在相同的对上计算 $\\sum g(r)$。\n    d. 通过检查每个配体原子，看其与任何受体原子的最小距离是否小于 $d_{\\mathrm{clash}}$ 来计算 $N_{\\mathrm{clash}}$。\n    e. 将这些值代入 $S$ 和 $E_{\\mathrm{true}}$ 的方程中。\n3.  评估恶意标准：检查是否 $S \\ge S_{\\mathrm{target}}$ 且 $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$。记录布尔结果。\n4.  最终输出是所有测试用例的这些布尔结果的列表。\n这个系统化的过程确保了一种一致且逻辑化的方法来构建对抗性配体，并根据问题的定义评估其属性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adversarial ligand construction problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"rec_acceptors\": np.array([\n                [0.0, 0.0, 0.0], [4.0, 0.0, 0.0], [0.0, 4.0, 0.0],\n                [0.0, 0.0, 4.0], [3.0, 3.0, 0.0]\n            ]),\n            \"rec_donors\": np.empty((0, 3)),\n            \"params\": {\n                \"d_hb\": 3.5, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 5, \"E_bad\": 5.0}\n        },\n        # Test case 2\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0]]),\n            \"rec_donors\": np.array([[0.0, 5.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 2.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 3, \"E_bad\": 2.0}\n        },\n        # Test case 3\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 2.0, 0.0]]),\n            \"rec_donors\": np.array([[1.0, 1.0, 0.0], [1.0, -1.0, 0.0], [3.0, 1.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 3.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.35, \"e_hb\": 2.8, \"p_polar\": 2.0,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 6, \"E_bad\": 8.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ligand_donors, ligand_acceptors = construct_adversarial_ligand(case)\n        S, E_true = calculate_scores(\n            ligand_donors, ligand_acceptors,\n            case[\"rec_donors\"], case[\"rec_acceptors\"],\n            case[\"params\"]\n        )\n        \n        is_malicious = (S = case[\"thresholds\"][\"S_target\"] and \n                        E_true = case[\"thresholds\"][\"E_bad\"])\n        results.append(str(is_malicious))\n\n    print(f\"[{','.join(results)}]\")\n\ndef construct_adversarial_ligand(case_data):\n    \"\"\"\n    Constructs a ligand by placing complementary atoms near receptor features.\n    The placement strategy is adversarial: place at a distance d_clash\n    from the target atom in a direction that does not clash with other receptor atoms.\n    \"\"\"\n    params = case_data[\"params\"]\n    d_clash = params[\"d_clash\"]\n    \n    rec_acceptors = case_data[\"rec_acceptors\"]\n    rec_donors = case_data[\"rec_donors\"]\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0]  0:\n        all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0]  0:\n        all_rec_pts.append(rec_donors)\n    \n    if not all_rec_pts:\n        return np.empty((0,3)), np.empty((0,3))\n\n    all_rec_pts = np.vstack(all_rec_pts)\n\n    deltas = np.array([\n        [d_clash, 0, 0], [0, d_clash, 0], [0, 0, d_clash],\n        [-d_clash, 0, 0], [0, -d_clash, 0], [0, 0, -d_clash]\n    ])\n\n    def find_non_clashing_pos(target_rec_pt, all_rec_pts, deltas):\n        for delta in deltas:\n            candidate_pos = target_rec_pt + delta\n            is_clashing = False\n            # Check candidate against all receptor points\n            distances = np.linalg.norm(all_rec_pts - candidate_pos, axis=1)\n            if np.any(distances  d_clash):\n                is_clashing = True\n            \n            if not is_clashing:\n                return candidate_pos\n        # Fallback if no non-clashing position is found (unlikely for these test cases)\n        return target_rec_pt + deltas[0]\n\n    ligand_donors = []\n    for rec_acc in rec_acceptors:\n        pos = find_non_clashing_pos(rec_acc, all_rec_pts, deltas)\n        ligand_donors.append(pos)\n\n    ligand_acceptors = []\n    for rec_don in rec_donors:\n        pos = find_non_clashing_pos(rec_don, all_rec_pts, deltas)\n        ligand_acceptors.append(pos)\n        \n    return np.array(ligand_donors), np.array(ligand_acceptors)\n\n\ndef calculate_scores(lig_donors, lig_acceptors, rec_donors, rec_acceptors, params):\n    \"\"\"\n    Calculates the empirical score (S) and physical energy proxy (E_true).\n    \"\"\"\n    # Unpack parameters\n    d_hb = params[\"d_hb\"]\n    d_clash = params[\"d_clash\"]\n    w_hb = params[\"w_hb\"]\n    w_clash = params[\"w_clash\"]\n    r0 = params[\"r0\"]\n    sigma = params[\"sigma\"]\n    e_hb = params[\"e_hb\"]\n    p_polar = params[\"p_polar\"]\n    p_rot = params[\"p_rot\"]\n    p_clash = params[\"p_clash\"]\n    \n    # Ligand properties\n    n_atoms = len(lig_donors) + len(lig_acceptors)\n    n_polar = n_atoms\n    \n    # Calculate N_hb and sum of g(r)\n    N_hb = 0\n    sum_g_r = 0.0\n\n    def g(r, r0, sigma):\n        return np.exp(-((r - r0)**2) / (2 * sigma**2))\n\n    # Receptor Acceptors vs Ligand Donors\n    if rec_acceptors.shape[0]  0 and lig_donors.shape[0]  0:\n        for lig_d in lig_donors:\n            for rec_a in rec_acceptors:\n                dist = np.linalg.norm(lig_d - rec_a)\n                if dist = d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n\n    # Receptor Donors vs Ligand Acceptors\n    if rec_donors.shape[0]  0 and lig_acceptors.shape[0]  0:\n        for lig_a in lig_acceptors:\n            for rec_d in rec_donors:\n                dist = np.linalg.norm(lig_a - rec_d)\n                if dist = d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n                \n    # Calculate N_clash\n    N_clash = 0\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0]  0: all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0]  0: all_rec_pts.append(rec_donors)\n    all_rec_pts = np.vstack(all_rec_pts) if all_rec_pts else np.empty((0,3))\n\n    all_lig_pts = []\n    if lig_donors.shape[0]  0: all_lig_pts.append(lig_donors)\n    if lig_acceptors.shape[0]  0: all_lig_pts.append(lig_acceptors)\n    all_lig_pts = np.vstack(all_lig_pts) if all_lig_pts else np.empty((0,3))\n\n    if all_rec_pts.shape[0]  0:\n        for lig_pt in all_lig_pts:\n            min_dist = np.min(np.linalg.norm(all_rec_pts - lig_pt, axis=1))\n            if min_dist  d_clash:\n                N_clash += 1\n\n    # Final score calculations\n    S = w_hb * N_hb - w_clash * N_clash\n    \n    E_true = -e_hb * sum_g_r \\\n             + p_polar * n_polar \\\n             + p_rot * max(n_atoms - 1, 0) \\\n             + p_clash * N_clash\n             \n    return S, E_true\n\nsolve()\n```", "id": "2422880"}]}