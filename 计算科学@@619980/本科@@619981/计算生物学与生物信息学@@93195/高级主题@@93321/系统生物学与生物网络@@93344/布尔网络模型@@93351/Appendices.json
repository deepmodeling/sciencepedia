{"hands_on_practices": [{"introduction": "布尔网络的核心在于其动态演化。通过这个练习，你将亲手模拟一个小型基因调控网络的逐步演化过程，即从一个给定的初始状态出发，根据逻辑规则一步步计算网络在未来时间点的状态。这个过程是理解布尔网络动态行为的基础，它能帮助你直观地看到系统如何最终陷入一个稳定的状态（不动点）或一个周期性振荡的模式（极限环）[@problem_id:1419905]。", "problem": "考虑一个由四个基因（记为 $G_1, G_2, G_3$ 和 $G_4$）组成的基因调控网络的简化模型。每个基因的状态可以是 ON（用 1 表示）或 OFF（用 0 表示）。在离散时间步 $t$，整个网络的状态由一个向量 $S(t) = (x_1(t), x_2(t), x_3(t), x_4(t))$ 描述，其中 $x_i(t)$ 是基因 $G_i$ 的状态。\n\n该网络根据同步更新方案演化，其中在时间 $t+1$ 时所有基因的状态是基于网络在时间 $t$ 时的状态同时确定的。控制这些相互作用的逻辑规则如下：\n\n- 基因 $G_1$ 的表达受基因 $G_4$ 抑制：\n  $x_1(t+1) = \\text{NOT } x_4(t)$\n\n- 基因 $G_2$ 的表达需要基因 $G_1$ 和 $G_3$ 都处于 ON 状态：\n  $x_2(t+1) = x_1(t) \\text{ AND } x_3(t)$\n\n- 如果基因 $G_1$ 或基因 $G_2$ 处于 ON 状态，则基因 $G_3$ 的表达被激活：\n  $x_3(t+1) = x_1(t) \\text{ OR } x_2(t)$\n\n- 基因 $G_4$ 的表达受基因 $G_3$ 激活：\n  $x_4(t+1) = x_3(t)$\n\n在此背景下，逻辑运算对二进制值的定义如下：NOT 1 = 0, NOT 0 = 1；1 AND 1 = 1，否则为 0；0 OR 0 = 0，否则为 1。\n\n网络在时间 $t=0$ 时的初始状态为 $S(0) = (1, 0, 0, 0)$。请确定从该初始状态开始，网络的长期行为（吸引子）。\n\nA. 网络达到一个位于 $(0, 0, 0, 0)$ 的不动点。\n\nB. 网络达到一个位于 $(1, 1, 1, 1)$ 的不动点。\n\nC. 网络进入一个长度为 2 的极限环。\n\nD. 网络进入一个长度为 4 的极限环。\n\nE. 网络进入一个长度为 7 的极限环。\n\nF. 网络进入一个长度不为 2、4 或 7 的极限环。", "solution": "我们将布尔更新规则表示为关于二进制变量 $x_{i}(t) \\in \\{0,1\\}$ 的算术表达式：\n$$x_{1}(t+1)=1-x_{4}(t),\\quad x_{2}(t+1)=x_{1}(t)\\,x_{3}(t),\\quad x_{3}(t+1)=x_{1}(t)+x_{2}(t)-x_{1}(t)\\,x_{2}(t),\\quad x_{4}(t+1)=x_{3}(t).$$\n从 $S(0)=(1,0,0,0)$ 开始，进行同步迭代计算。\n\n在 $t=1$ 时：\n$$x_{1}(1)=1-x_{4}(0)=1-0=1,$$\n$$x_{2}(1)=x_{1}(0)\\,x_{3}(0)=1\\cdot 0=0,$$\n$$x_{3}(1)=x_{1}(0)+x_{2}(0)-x_{1}(0)\\,x_{2}(0)=1+0-0=1,$$\n$$x_{4}(1)=x_{3}(0)=0,$$\n所以 $S(1)=(1,0,1,0)$。\n\n在 $t=2$ 时：\n$$x_{1}(2)=1-x_{4}(1)=1-0=1,$$\n$$x_{2}(2)=x_{1}(1)\\,x_{3}(1)=1\\cdot 1=1,$$\n$$x_{3}(2)=x_{1}(1)+x_{2}(1)-x_{1}(1)\\,x_{2}(1)=1+0-0=1,$$\n$$x_{4}(2)=x_{3}(1)=1,$$\n所以 $S(2)=(1,1,1,1)$。\n\n在 $t=3$ 时：\n$$x_{1}(3)=1-x_{4}(2)=1-1=0,$$\n$$x_{2}(3)=x_{1}(2)\\,x_{3}(2)=1\\cdot 1=1,$$\n$$x_{3}(3)=x_{1}(2)+x_{2}(2)-x_{1}(2)\\,x_{2}(2)=1+1-1=1,$$\n$$x_{4}(3)=x_{3}(2)=1,$$\n所以 $S(3)=(0,1,1,1)$。\n\n在 $t=4$ 时：\n$$x_{1}(4)=1-x_{4}(3)=1-1=0,$$\n$$x_{2}(4)=x_{1}(3)\\,x_{3}(3)=0\\cdot 1=0,$$\n$$x_{3}(4)=x_{1}(3)+x_{2}(3)-x_{1}(3)\\,x_{2}(3)=0+1-0=1,$$\n$$x_{4}(4)=x_{3}(3)=1,$$\n所以 $S(4)=(0,0,1,1)$。\n\n在 $t=5$ 时：\n$$x_{1}(5)=1-x_{4}(4)=1-1=0,$$\n$$x_{2}(5)=x_{1}(4)\\,x_{3}(4)=0\\cdot 1=0,$$\n$$x_{3}(5)=x_{1}(4)+x_{2}(4)-x_{1}(4)\\,x_{2}(4)=0+0-0=0,$$\n$$x_{4}(5)=x_{3}(4)=1,$$\n所以 $S(5)=(0,0,0,1)$。\n\n在 $t=6$ 时：\n$$x_{1}(6)=1-x_{4}(5)=1-1=0,$$\n$$x_{2}(6)=x_{1}(5)\\,x_{3}(5)=0\\cdot 0=0,$$\n$$x_{3}(6)=x_{1}(5)+x_{2}(5)-x_{1}(5)\\,x_{2}(5)=0+0-0=0,$$\n$$x_{4}(6)=x_{3}(5)=0,$$\n所以 $S(6)=(0,0,0,0)$。\n\n在 $t=7$ 时：\n$$x_{1}(7)=1-x_{4}(6)=1-0=1,$$\n$$x_{2}(7)=x_{1}(6)\\,x_{3}(6)=0\\cdot 0=0,$$\n$$x_{3}(7)=x_{1}(6)+x_{2}(6)-x_{1}(6)\\,x_{2}(6)=0+0-0=0,$$\n$$x_{4}(7)=x_{3}(6)=0,$$\n所以 $S(7)=(1,0,0,0)=S(0)$。\n\n轨迹经过了七个不同的状态\n$$(1,0,0,0)\\to(1,0,1,0)\\to(1,1,1,1)\\to(0,1,1,1)\\to(0,0,1,1)\\to(0,0,0,1)\\to(0,0,0,0)\\to(1,0,0,0),$$\n并在 $t=7$ 时首次返回初始状态。因此，吸引子是一个长度为 7 的极限环，对应选项 E。", "answer": "$$\\boxed{E}$$", "id": "1419905"}, {"introduction": "一个布尔网络的行为不仅取决于节点间的逻辑关系，还深刻地受到其更新机制的影响。这个练习将引导你探索同步更新与异步更新这两种不同模式下的系统动态，揭示即使是同一个网络，在不同的“时间节律”下其长期行为也可能截然不同 [@problem_id:1419944]。通过分析异步更新方案下的稳态，你将更深入地理解模型假设对预测系统动力学的重要性。", "problem": "在基因调控网络的研究中，布尔网络模型为理解系统动力学提供了一个既简化又强大的框架。网络的演化可使用不同的更新机制来建模。在同步机制中，所有节点在每个离散时间步同时更新其状态。相反，在通用异步 (GA) 机制下，在每个时间步，只有一个随机均匀选择的节点更新其状态。\n\n考虑一个由三个节点（基因）组成的假设的小型基因调控网络，由布尔变量 $X_1, X_2, \\text{和 } X_3$ 表示，其中状态 1 代表“开启”（表达）的基因，状态 0 代表“关闭”（抑制）的基因。其调控逻辑由以下布尔更新函数描述：\n\n$f_1(X_3) = \\neg X_3$\n$f_2(X_1) = X_1$\n$f_3(X_1, X_2) = X_1 \\land X_2$\n\n此处，$\\neg$ 表示“非”算子，$\\land$ 表示“与”算子。在同步更新机制下，已知该网络表现出单个复杂吸引子，即一个长度为 5 的极限环，并且它没有稳态（不动点）。\n\n你的任务是分析该网络在通用异步 (GA) 更新机制下的行为。在 GA 机制中，如果对任意单个随机选择的节点的更新都不会改变网络的整体状态，则该状态被定义为稳态吸引子。\n\n以下哪个选项正确描述了该网络在 GA 机制下的完整稳态吸引子集合？\n\nA. 单个状态 (0, 0, 0)\n\nB. 单个状态 (1, 1, 1)\n\nC. 两个状态 (1, 1, 0) 和 (0, 0, 1)\n\nD. 状态 (1, 0, 0) 和 (0, 1, 1)\n\nE. 不存在稳态。", "solution": "在 GA 机制下，如果更新任意单个节点都不会改变该状态，则该状态是一个稳态吸引子。这意味着在这样的状态下，每个节点的值都已等于其更新函数根据当前输入值计算出的值。因此，一个 GA 稳态必须满足以下不动点方程\n$$\nX_{1}=f_{1}(X_{3})=\\neg X_{3},\\quad X_{2}=f_{2}(X_{1})=X_{1},\\quad X_{3}=f_{3}(X_{1},X_{2})=X_{1}\\land X_{2}.\n$$\n我们联立求解这些方程。根据 $X_{2}=X_{1}$，将其代入 $X_{3}=X_{1}\\land X_{2}$ 可得\n$$\nX_{3}=X_{1}\\land X_{1}=X_{1}.\n$$\n将 $X_{3}=X_{1}$ 代入 $X_{1}=\\neg X_{3}$ 可得\n$$\nX_{1}=\\neg X_{1}.\n$$\n没有任何布尔值满足 $X_{1}=\\neg X_{1}$，因此该方程组无解。因此，不存在任何状态，使得在 GA 机制下更新其中任意单个节点后，该状态保持不变。\n\n因此，正确的选项是不存在稳态。", "answer": "$$\\boxed{E}$$", "id": "1419944"}, {"introduction": "当网络规模增大时，手动分析将变得不切实际，此时计算机模拟和算法分析就成了不可或缺的工具。这个练习要求你编写程序来系统性地寻找不同布尔网络的全部不动点，并判断它们是否具有生物开关中常见的“双稳态”特性 [@problem_id:2376740]。这不仅能将你对不动点和双稳态的理论理解转化为可执行的代码，也为你将来分析更复杂的生物系统奠定了坚实的计算基础。", "problem": "给定一个布尔网络 (BN) 的形式化定义，它是一个定义在有限布尔状态空间上的离散时间动力系统。一个具有 $n$ 个节点的 BN 在整数时间 $t \\in \\mathbb{Z}_{\\ge 0}$ 时有一个状态向量 $\\mathbf{x}(t) \\in \\{0,1\\}^n$，以及一个更新函数 $\\mathbf{F} : \\{0,1\\}^n \\to \\{0,1\\}^n$，其分量函数为 $F_i : \\{0,1\\}^n \\to \\{0,1\\}$，其中 $i \\in \\{1,\\dots,n\\}$。在同步更新模式下，其动力学行为由 $\\mathbf{x}(t+1) = \\mathbf{F}(\\mathbf{x}(t))$ 描述。一个不动点（也称为稳态）是任意满足 $\\mathbf{F}(\\mathbf{x}^\\ast) = \\mathbf{x}^\\ast$ 的 $\\mathbf{x}^\\ast \\in \\{0,1\\}^n$。如果一个 BN 恰好有两个不同的不动点，则称其为双稳态的。\n\n你的任务是编写一个程序，对以下每个布尔网络，确定其完整的不动点集合，并判断该网络是否是上述意义上的双稳态网络。所有逻辑运算符均作用于 $\\{0,1\\}$，其中 $\\lnot$ 是逻辑非，$\\land$ 是逻辑与，$\\lor$ 是逻辑或。本问题不涉及任何物理单位。\n\n测试用例（每个项目指定了 $n$ 和分量函数 $F_i$）：\n\n- 情况 T（一个旨在表示简单细胞开关的最小双节点触发器）：$n=2$，其中\n  - $F_1(x_1,x_2) = \\lnot x_2$，\n  - $F_2(x_1,x_2) = \\lnot x_1$。\n- 情况 S（单节点自保持）：$n=1$，其中\n  - $F_1(x_1) = x_1$。\n- 情况 Z（零映射）：$n=2$，其中\n  - $F_1(x_1,x_2) = 0$，\n  - $F_2(x_1,x_2) = 0$。\n- 情况 N（逐分量取反）：$n=2$，其中\n  - $F_1(x_1,x_2) = \\lnot x_1$，\n  - $F_2(x_1,x_2) = \\lnot x_2$。\n\n对于每种情况，要求的结果是一个包含以下三项的列表，顺序如下：\n- 等于不动点数量的整数 $k$，\n- 一个布尔值，当且仅当 $k=2$ 时为 $\\text{True}$，否则为 $\\text{False}$，\n- 一个不动点列表，其中每个不动点表示为一个在 $\\{0,1\\}^n$ 上按字典序列出的 $0$-$1$ 整数列表。\n\n你的程序应生成单行输出，其中包含四个情况（按 T, S, Z, N 顺序）的结果，并聚合成一个由方括号括起来的逗号分隔列表（例如 $[\\dots]$）。不需要任何输入，也不应打印任何其他文本。最终输出必须具有以下形式\n$[[k_T,\\mathrm{bistable}_T,\\mathrm{FPs}_T],[k_S,\\mathrm{bistable}_S,\\mathrm{FPs}_S],[k_Z,\\mathrm{bistable}_Z,\\mathrm{FPs}_Z],[k_N,\\mathrm{bistable}_N,\\mathrm{FPs}_N]]$，\n其中 $k_{\\cdot}$ 是整数，$\\mathrm{bistable}_{\\cdot}$ 是布尔值，而 $\\mathrm{FPs}_{\\cdot}$ 是由整数列表组成的列表。", "solution": "问题要求为四个指定的布尔网络识别所有不动点，并确定每个网络是否为双稳态。一个布尔网络 (BN) 由其节点数 $n$ 和一组布尔更新函数 $\\mathbf{F}: \\{0,1\\}^n \\to \\{0,1\\}^n$ 定义，这些函数根据 $\\mathbf{x}(t+1) = \\mathbf{F}(\\mathbf{x}(t))$ 决定系统的动力学行为。\n\n如果一个状态 $\\mathbf{x}^\\ast \\in \\{0,1\\}^n$ 在更新函数作用下保持不变，则它是一个不动点，或称稳态。在数学上，这个条件表示为：\n$$ \\mathbf{F}(\\mathbf{x}^\\ast) = \\mathbf{x}^\\ast $$\n这个向量方程等价于一个包含 $n$ 个联立布尔方程的系统：\n$$ F_i(x_1^\\ast, x_2^\\ast, \\dots, x_n^\\ast) = x_i^\\ast \\quad \\text{for all } i \\in \\{1, \\dots, n\\} $$\n如果一个网络恰好有两个不同的不动点，则定义其为双稳态。\n\n一个具有 $n$ 个节点的 BN 的状态空间是有限的，包含 $2^n$ 个可能的状态。对于问题中给出的较小的 $n$ 值（$n=1$ 和 $n=2$），找到所有不动点的最直接和最严谨的方法是在整个状态空间上进行穷举搜索。我们将遍历每个状态 $\\mathbf{x} \\in \\{0,1\\}^n$，计算其后续状态 $\\mathbf{F}(\\mathbf{x})$，并检查是否满足条件 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{x}$。\n\n我们将此过程应用于每个测试用例。逻辑非 ($\\lnot$)、与 ($\\land$) 和或 ($\\lor$) 在集合 $\\{0, 1\\}$ 上进行解释。我们将使用其算术等价形式，其中 $1$ 代表真，$0$ 代表假：$\\lnot p \\equiv 1-p$，$p \\land q \\equiv p \\cdot q$，$p \\lor q \\equiv p + q - p \\cdot q$。\n\n情况 T：最小双节点触发器\n该网络有 $n=2$ 个节点，更新函数为：\n$F_1(x_1, x_2) = \\lnot x_2$\n$F_2(x_1, x_2) = \\lnot x_1$\n状态空间为 $\\{(0,0), (0,1), (1,0), (1,1)\\}$。我们检查每个状态：\n- 对于 $\\mathbf{x}=(0,0)$: $\\mathbf{F}(0,0) = (\\lnot 0, \\lnot 0) = (1,1)$。由于 $(1,1) \\ne (0,0)$，所以这不是一个不动点。\n- 对于 $\\mathbf{x}=(0,1)$: $\\mathbf{F}(0,1) = (\\lnot 1, \\lnot 0) = (0,1)$。由于 $(0,1) = (0,1)$，所以这是一个不动点。\n- 对于 $\\mathbf{x}=(1,0)$: $\\mathbf{F}(1,0) = (\\lnot 0, \\lnot 1) = (1,0)$。由于 $(1,0) = (1,0)$，所以这是一个不动点。\n- 对于 $\\mathbf{x}=(1,1)$: $\\mathbf{F}(1,1) = (\\lnot 1, \\lnot 1) = (0,0)$。由于 $(0,0) \\ne (1,1)$，所以这不是一个不动点。\n不动点的集合是 $\\{(0,1), (1,0)\\}$。不动点的数量是 $k_T = 2$。因为 $k_T=2$，所以该网络是双稳态的。按字典序排列的不动点是 $[[0, 1], [1, 0]]$。\n结果：$[2, \\text{True}, [[0, 1], [1, 0]]]$。\n\n情况 S：单节点自保持\n该网络有 $n=1$ 个节点，更新函数为：\n$F_1(x_1) = x_1$\n状态空间为 $\\{(0), (1)\\}$。我们检查每个状态：\n- 对于 $\\mathbf{x}=(0)$: $\\mathbf{F}(0) = (0)$。由于 $(0) = (0)$，所以这是一个不动点。\n- 对于 $\\mathbf{x}=(1)$: $\\mathbf{F}(1) = (1)$。由于 $(1) = (1)$，所以这是一个不动点。\n不动点的集合是 $\\{(0), (1)\\}$。不动点的数量是 $k_S = 2$。因为 $k_S=2$，所以该网络是双稳态的。按字典序排列的不动点是 $[[0], [1]]$。\n结果：$[2, \\text{True}, [[0], [1]]]$。\n\n情况 Z：零映射\n该网络有 $n=2$ 个节点，更新函数为：\n$F_1(x_1, x_2) = 0$\n$F_2(x_1, x_2) = 0$\n这意味着对于所有 $\\mathbf{x} \\in \\{0,1\\}^2$，都有 $\\mathbf{F}(\\mathbf{x}) = (0,0)$。一个状态 $\\mathbf{x}^\\ast=(x_1^\\ast, x_2^\\ast)$ 是不动点，当且仅当 $\\mathbf{F}(\\mathbf{x}^\\ast) = \\mathbf{x}^\\ast$，这意味着 $(0,0) = (x_1^\\ast, x_2^\\ast)$。唯一满足此条件的状态是 $\\mathbf{x}^\\ast = (0,0)$。\n- 对于 $\\mathbf{x}=(0,0)$: $\\mathbf{F}(0,0) = (0,0)$。这是一个不动点。\n对于所有其他状态 $\\mathbf{x} \\ne (0,0)$，有 $\\mathbf{F}(\\mathbf{x}) = (0,0) \\ne \\mathbf{x}$。\n不动点的集合是 $\\{(0,0)\\}$。不动点的数量是 $k_Z = 1$。因为 $k_Z \\ne 2$，所以该网络不是双稳态的。不动点列表为 $[[0,0]]$。\n结果：$[1, \\text{False}, [[0, 0]]]$。\n\n情况 N：逐分量取反\n该网络有 $n=2$ 个节点，更新函数为：\n$F_1(x_1, x_2) = \\lnot x_1$\n$F_2(x_1, x_2) = \\lnot x_2$\n一个不动点必须满足 $x_1 = \\lnot x_1$ 和 $x_2 = \\lnot x_2$。在作用于 $\\{0,1\\}$ 的布尔代数中，不存在元素 $p$ 使得 $p = \\lnot p$。因此，这样的不动点不可能存在。我们通过检查所有状态来验证：\n- 对于 $\\mathbf{x}=(0,0)$: $\\mathbf{F}(0,0) = (\\lnot 0, \\lnot 0) = (1,1) \\ne (0,0)$。\n- 对于 $\\mathbf{x}=(0,1)$: $\\mathbf{F}(0,1) = (\\lnot 0, \\lnot 1) = (1,0) \\ne (0,1)$。\n- 对于 $\\mathbf{x}=(1,0)$: $\\mathbf{F}(1,0) = (\\lnot 1, \\lnot 0) = (0,1) \\ne (1,0)$。\n- 对于 $\\mathbf{x}=(1,1)$: $\\mathbf{F}(1,1) = (\\lnot 1, \\lnot 1) = (0,0) \\ne (1,1)$。\n没有不动点。不动点的数量是 $k_N = 0$。因为 $k_N \\ne 2$，所以该网络不是双稳态的。不动点列表为空，即 $[]$。\n结果：$[0, \\text{False}, []]$。\n\n情况 T, S, Z 和 N 的汇总结果将按规定格式化为单个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# No imports beyond the standard library are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the Boolean network fixed point problem for the given test cases.\n    \"\"\"\n\n    def analyze_bn(n, update_funcs):\n        \"\"\"\n        Finds all fixed points of a Boolean network by exhaustive search.\n\n        Args:\n            n (int): The number of nodes in the network.\n            update_funcs (list): A list of n lambda functions, where the i-th\n                                 function defines the update rule for node i.\n\n        Returns:\n            list: A list containing [k, is_bistable, fixed_points_list], where\n                  k is the number of fixed points, is_bistable is a boolean,\n                  and fixed_points_list is a list of fixed points.\n        \"\"\"\n        fixed_points = []\n        \n        # Iterate through all 2^n possible states.\n        # The integer i from 0 to 2^n - 1 represents a state, where its\n        # binary representation corresponds to the node values.\n        for i in range(2**n):\n            # Construct the state tuple from integer i in lexicographical order.\n            # E.g., for n=2, i=0->(0,0), i=1->(0,1), i=2->(1,0), i=3->(1,1).\n            state_tuple = tuple((i >> j) & 1 for j in range(n - 1, -1, -1))\n            \n            # Compute the next state by applying the update functions.\n            next_state_list = [func(*state_tuple) for func in update_funcs]\n            next_state_tuple = tuple(next_state_list)\n            \n            # Check if the state is a fixed point.\n            if next_state_tuple == state_tuple:\n                fixed_points.append(list(state_tuple))\n        \n        # Count the fixed points and determine bistability.\n        k = len(fixed_points)\n        is_bistable = (k == 2)\n        \n        return [k, is_bistable, fixed_points]\n\n    # Define the test cases from the problem statement.\n    # We use arithmetic (1-x for NOT) for Boolean logic on {0, 1}.\n    test_cases = [\n        # Case T: n=2, F1 = !x2, F2 = !x1\n        (2, [lambda x1, x2: 1 - x2, lambda x1, x2: 1 - x1]),\n        # Case S: n=1, F1 = x1\n        (1, [lambda x1: x1]),\n        # Case Z: n=2, F1 = 0, F2 = 0\n        (2, [lambda x1, x2: 0, lambda x1, x2: 0]),\n        # Case N: n=2, F1 = !x1, F2 = !x2\n        (2, [lambda x1, x2: 1 - x1, lambda x1, x2: 1 - x2]),\n    ]\n\n    results = []\n    for n, funcs in test_cases:\n        result = analyze_bn(n, funcs)\n        results.append(result)\n\n    # The final output must be a single line, formatted as a nested list string\n    # with no spaces. The standard str() representation includes spaces,\n    # so we remove them.\n    # Example: [[k, bistable, FPs], [k, bistable, FPs], ...]\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```", "id": "2376740"}]}