{"hands_on_practices": [{"introduction": "在生物网络中，一个节点可能同时具有高度中心性（hub特性）和高介数中心性（bottleneck特性）。本练习介绍了一个“中心-瓶颈差异分数”（$S_i = k_d \\cdot D_i - k_b \\cdot B_i$），旨在量化这两种属性的相对重要性。通过计算和解释这个分数，你将学会如何超越简单的标签，对节点的网络角色进行更细致的分类，并预测其在网络中的功能影响 [@problem_id:2409607]。", "problem": "在一个建模为无向、无权图的蛋白质-蛋白质相互作用（PPI）网络中，节点 $i$ 的度中心性是其相互作用伙伴的数量，节点 $i$ 的介数中心性是网络中所有通过 $i$ 的最短路径的比例。设 $D_i$ 表示节点 $i$ 归一化到区间 $[0,1]$ 的度中心性（例如，通过除以最大度数），设 $B_i$ 表示节点 $i$ 归一化到区间 $[0,1]$ 的介数中心性（例如，通过除以网络中可能的最大介数值）。考虑枢纽-瓶颈差异分数\n$$\nS_i \\;=\\; k_d \\cdot D_i \\;-\\; k_b \\cdot B_i,\n$$\n其中 $k_d>0$ 和 $k_b>0$ 是用户选择的权重，分别量化了对枢纽性（hubness）和瓶颈性（bottleneckness）的相对重视程度。在所选权重下，较大的正 $S_i$ 值表示相对于瓶颈性更强的枢纽主导性，而更负的 $S_i$ 值表示相对于枢纽性更强的瓶颈主导性。\n\n假设 $k_d = 1.0$ 且 $k_b = 1.5$。对于四个蛋白质 $P_1, P_2, P_3, P_4$，其归一化中心性如下：\n- $P_1$: $D_1 = 0.80$, $B_1 = 0.20$.\n- $P_2$: $D_2 = 0.30$, $B_2 = 0.60$.\n- $P_3$: $D_3 = 0.70$, $B_3 = 0.70$.\n- $P_4$: $D_4 = 0.10$, $B_4 = 0.05$.\n\n以下关于 $S_i$ 及其生物学解释的陈述中，哪些是正确的？选择所有适用项。\n\nA. 使用给定权重，$P_1$ 具有最大的正 $S_i$ 值并且是枢纽主导的；移除它会消除许多局部相互作用，但与 $S_i$ 值为负的节点相比，它破坏模块间最短路径流量的可能性相对较小。\n\nB. 使用给定权重，$P_2$ 是瓶颈主导的，并且相对于 $P_1$，它更可能通过最短路径介导模块间的通信；因此，在检测路径依赖信号传递的扰动实验中，它可能表现出更强的影响。\n\nC. 尽管 $D_3$ 和 $B_3$都很高，但在给定权重下 $S_3<0$，这说明 $S_i$ 反映的是相对重要性；将 $k_d$ 增加到 $k_b\\cdot \\dfrac{B_3}{D_3}$ 以上会使 $S_3$ 的符号翻转。\n\nD. 如果 $k_b$ 的值变为原来的2倍，那么对于所有 $B_i>0$ 的节点，$S_i$ 都会增加，因为更高的 $k_b$ 会奖励瓶颈性。\n\nE. 如果 $S_i \\approx 0$，那么必然有 $D_i \\approx 0$ 和 $B_i \\approx 0$；因此，$P_4$ 必定是一个外围的、无影响力的节点。", "solution": "对问题陈述进行验证。\n\n**1. 提取已知条件：**\n- 蛋白质-蛋白质相互作用（PPI）网络被建模为一个无向、无权图。\n- 节点 $i$ 的度中心性是其相互作用伙伴的数量。这被归一化为 $D_i \\in [0, 1]$。\n- 节点 $i$ 的介数中心性是所有通过 $i$ 的最短路径的比例。这被归一化为 $B_i \\in [0, 1]$。\n- 枢纽-瓶颈差异分数定义为 $S_i = k_d \\cdot D_i - k_b \\cdot B_i$。\n- $k_d > 0$ 和 $k_b > 0$ 是用户选择的权重。\n- 较大的正 $S_i$ 值表示枢纽主导；更负的 $S_i$ 值表示瓶颈主导。\n- 给定的具体权重为 $k_d = 1.0$ 和 $k_b = 1.5$。\n- 提供了四个蛋白质的归一化中心性值：\n  - $P_1$: $D_1 = 0.80$, $B_1 = 0.20$。\n  - $P_2$: $D_2 = 0.30$, $B_2 = 0.60$。\n  - $P_3$: $D_3 = 0.70$, $B_3 = 0.70$。\n  - $P_4$: $D_4 = 0.10$, $B_4 = 0.05$。\n\n**2. 验证：**\n- **科学依据**：PPI网络、度中心性、介数中心性、枢纽和瓶颈等概念是计算生物学和网络科学中的基础且已确立的概念。构建一个差异分数来权衡这两个属性是在复合度量设计中一种有效且常见的方法。该问题在科学上是合理的。\n- **适定性**：问题为分数 $S_i$ 提供了清晰的数学定义，所有必需的数值数据（$D_i$, $B_i$）和计算所需的参数（$k_d$, $k_b$）。问题是明确的，要求基于这些数据和定义来评估陈述。\n- **客观性**：问题以精确、客观的语言陈述。“枢纽主导”和“瓶颈主导”的解释明确地与计算出的分数 $S_i$ 的符号相关联。\n\n**3. 结论：**\n问题陈述是有效的。它有科学依据，内容完备，且具有适定性。我将继续进行解答。\n\n**推导**\n\n主要任务是使用公式 $S_i = k_d \\cdot D_i - k_b \\cdot B_i$ 和给定的权重 $k_d = 1.0$ 及 $k_b = 1.5$ 来计算每个蛋白质 $P_i$ 的枢纽-瓶颈差异分数 $S_i$。\n\n对于蛋白质 $P_1$：\n$$S_1 = (1.0 \\cdot 0.80) - (1.5 \\cdot 0.20) = 0.80 - 0.30 = 0.50$$\n\n对于蛋白质 $P_2$：\n$$S_2 = (1.0 \\cdot 0.30) - (1.5 \\cdot 0.60) = 0.30 - 0.90 = -0.60$$\n\n对于蛋白质 $P_3$：\n$$S_3 = (1.0 \\cdot 0.70) - (1.5 \\cdot 0.70) = 0.70 - 1.05 = -0.35$$\n\n对于蛋白质 $P_4$：\n$$S_4 = (1.0 \\cdot 0.10) - (1.5 \\cdot 0.05) = 0.10 - 0.075 = 0.025$$\n\n分数总结：$S_1 = 0.50$，$S_2 = -0.60$，$S_3 = -0.35$，$S_4 = 0.025$。\n正分（$S_i > 0$）表示枢纽主导。负分（$S_i < 0$）表示瓶颈主导。\n\n**逐项分析**\n\n**A. 使用给定权重，$P_1$ 具有最大的正 $S_i$ 值并且是枢纽主导的；移除它会消除许多局部相互作用，但与 $S_i$ 值为负的节点相比，它破坏模块间最短路径流量的可能性相对较小。**\n- 我们计算出 $S_1 = 0.50$ 和 $S_4 = 0.025$。两者均为正。$S_1$ 是最大的正分。这是正确的。\n- 由于 $S_1 > 0$，$P_1$ 被归类为枢纽主导。这是正确的。\n- $P_1$ 具有非常高的度中心性，$D_1 = 0.80$，是四个蛋白质中最高的。高一度意味着有许多直接的相互作用伙伴（“局部相互作用”）。移除它确实会消除这些相互作用。这是一个正确的解释。\n- $S_i$ 值为负的节点是 $P_2$（$S_2 = -0.60$）和 $P_3$（$S_3 = -0.35$）。这些是瓶颈主导的。它们的介数中心性很高（$B_2 = 0.60$，$B_3 = 0.70$），而 $P_1$ 的则较低（$B_1 = 0.20$）。高介数中心性的节点对于连接不同的网络模块至关重要，因此移除它们会对最短路径流量产生不成比例的影响。因此，移除 $P_1$ 比移除 $P_2$ 或 $P_3$ 更不可能破坏这种流量。该陈述完全符合网络理论。\n**结论：正确**\n\n**B. 使用给定权重，$P_2$ 是瓶颈主导的，并且相对于 $P_1$，它更可能通过最短路径介导模块间的通信；因此，在检测路径依赖信号传递的扰动实验中，它可能表现出更强的影响。**\n- 我们计算出 $S_2 = -0.60$。由于 $S_2 < 0$，$P_2$ 是瓶颈主导的。这是正确的。\n- 比较 $P_2$ 和 $P_1$：$B_2 = 0.60$ 显著高于 $B_1 = 0.20$。高介数中心性是“通过最短路径介导模块间通信”的节点的决定性特征。因此，$P_2$ 比 $P_1$ 更有可能扮演这个角色。这是正确的。\n- “路径依赖的信号传递”依赖于通信路径的完整性。对高介数中心性节点（如 $P_2$）的扰动会切断大量的最短路径，与扰动低介数中心性节点（如 $P_1$）相比，会对这类过程产生更强的破坏性影响。这个结论是合乎逻辑的。\n**结论：正确**\n\n**C. 尽管 $D_3$ 和 $B_3$都很高，但在给定权重下 $S_3<0$，这说明 $S_i$ 反映的是相对重要性；将 $k_d$ 增加到 $k_b\\cdot \\dfrac{B_3}{D_3}$ 以上会使 $S_3$ 的符号翻转。**\n- 对于 $P_3$，$D_3 = 0.70$ 和 $B_3 = 0.70$ 相对于 $[0, 1]$ 范围是很高的值。\n- 我们计算出 $S_3 = -0.35$，确实是负值。这是因为瓶颈性的权重（$k_b=1.5$）大于枢纽性的权重（$k_d=1.0$），所以在中心性分数相等的情况下，瓶颈项占主导地位。这正确地说明了 $S_i$ 衡量的是相对的、加权的重要性。\n- 要使 $S_3$ 的符号从负变正，我们需要 $S_3 > 0$。条件是 $k_d D_3 - k_b B_3 > 0$。对 $k_d$ 进行重排，我们得到 $k_d D_3 > k_b B_3$。因为 $D_3=0.70>0$，我们可以用它来除，得到 $k_d > k_b \\frac{B_3}{D_3}$。这个数学推导是完美无瑕的。\n**结论：正确**\n\n**D. 如果 $k_b$ 的值变为原来的2倍，那么对于所有 $B_i>0$ 的节点，$S_i$ 都会增加，因为更高的 $k_b$ 会奖励瓶颈性。**\n- 设初始分数为 $S_i = k_d D_i - k_b B_i$。\n- 设新权重为 $k_b' = 2k_b$。新分数为 $S_i' = k_d D_i - k_b' B_i = k_d D_i - 2k_b B_i$。\n- 分数的变化是 $\\Delta S_i = S_i' - S_i = (k_d D_i - 2k_b B_i) - (k_d D_i - k_b B_i) = -k_b B_i$。\n- 由于给定 $k_b > 0$，且选项考虑的是 $B_i > 0$ 的节点，所以变化量 $\\Delta S_i$ 严格为负。\n- 因此，增加 $k_b$ 会*减小* $S_i$ 的值。该陈述声称 $S_i$ 增加，这是错误的。所提供的理由也具有误导性；在这个特定公式的背景下，增加 $k_b$ 会对分数施加更大的惩罚，使其更负（更具瓶颈主导性），而不是增加它。\n**结论：错误**\n\n**E. 如果 $S_i \\approx 0$，那么必然有 $D_i \\approx 0$ 和 $B_i \\approx 0$；因此，$P_4$ 必定是一个外围的、无影响力的节点。**\n- 条件 $S_i \\approx 0$ 意味着 $k_d D_i - k_b B_i \\approx 0$，或者 $k_d D_i \\approx k_b B_i$。\n- 这是一个平衡方程。它不要求 $D_i$ 和 $B_i$ 都接近于0。例如，当 $k_d=1.0$ 和 $k_b=1.5$ 时，一个具有 $D_i=0.6$ 和 $B_i=0.4$ 的节点会有 $S_i = 1.0(0.6) - 1.5(0.4) = 0.6 - 0.6 = 0$。在这里，$D_i$ 和 $B_i$ 的值很大，不接近于零。该陈述的第一部分是一个逻辑谬误。\n- 对于 $P_4$，我们计算出 $S_4=0.025$，这接近于0。我们已知 $D_4=0.10$ 和 $B_4=0.05$。这些值确实很低，与外围节点一致。然而，单词“因此”暗示了基于一个有缺陷前提的因果联系。$P_4$ 是外围节点的结论并不是 $S_4 \\approx 0$ 的必然结果。一个 $S_i \\approx 0$ 的节点如果其度中心性和介数中心性都很高但相互平衡，那么它可能具有很高的影响力。该陈述的逻辑是不健全的。\n**结论：错误**", "answer": "$$\\boxed{ABC}$$", "id": "2409607"}, {"introduction": "人们通常认为移除一个网络中心（hub）会严重破坏网络功能，但这并非总是如此。本练习将通过一个“脆弱中心”的计算任务，让你亲手验证网络中的冗余性如何削弱单个中心节点的重要性。你将通过编程实现一个度量节点移除后网络连通性损失的算法，从而学会量化和识别那些对网络整体结构影响较小的中心节点 [@problem_id:2409629]。", "problem": "一个生物相互作用网络可以被建模为一个有限、无向、简单图 $G=(V,E)$，其中 $V$ 是节点（生物分子）的集合，$E$ 是无向边（相互作用）的集合。对于一个节点 $v \\in V$，其度 $\\deg(v)$ 是与 $v$ 关联的边的数量。如果一个节点 $v$ 的度满足 $\\deg(v) \\ge k_{\\text{hub}}$（其中 $k_{\\text{hub}} \\ge 1$ 为一个指定的整数阈值），则称该节点为枢纽节点。定义一个节点 $v$ 的移除效应如下：移除 $v$ 及其所有关联边，得到一个残余图 $G'=(V',E')$，其中 $V'=V \\setminus \\{v\\}$。设 $G'$ 的连通分量的大小为 $s_1,s_2,\\dots,s_m$（因此 $\\sum_{i=1}^{m} s_i = |V'|$）。在 $V'$ 中保持相互可达的无序节点对的数量为 $\\sum_{i=1}^{m} \\binom{s_i}{2}$。$V'$ 中无序节点对的总数为 $\\binom{|V'|}{2}$。定义可达性分数 $R(v)$ 为\n$$\nR(v) = \n\\begin{cases}\n1, & \\text{if } |V'| \\le 1,\\\\\n\\displaystyle \\frac{\\sum_{i=1}^{m} \\binom{s_i}{2}}{\\binom{|V'|}{2}}, & \\text{if } |V'| \\ge 2,\n\\end{cases}\n$$\n以及损失 $L(v) = 1 - R(v)$。对于一个指定的容差 $\\tau \\in [0,1]$，任何满足 $L(v) \\le \\tau$ 的枢纽节点 $v$ 都是一个脆弱枢纽节点。您的任务是为每个测试用例确定作为脆弱枢纽节点的节点索引列表，并按升序排序。\n\n使用以下测试套件。在所有情况下，图都是无向、简单的，节点索引是整数，且所有边都是不同节点索引的无序对。\n\n测试用例 $1$ (冗余桥接的模块):\n- 节点: $V_1 = \\{0,1,2,3,4,5,6,7,8\\}$，所以 $|V_1|=9$。\n- 边: $E_1$ 包含 $\\{0,1,2,3,4\\}$ 之间的所有 $\\binom{5}{2}$ 条边，$\\{5,6,7,8\\}$ 之间的所有 $\\binom{4}{2}$ 条边，以及两个模块间边 $(2,5)$ 和 $(3,6)$。明确地，\n$$\nE_1 = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(1,3),(1,4),(2,3),(2,4),(3,4),\n(5,6),(5,7),(5,8),(6,7),(6,8),(7,8),(2,5),(3,6)\\}.\n$$\n- 枢纽阈值: $k_{\\text{hub}}=5$。\n- 容差: $\\tau=0.05$。\n\n测试用例 $2$ (星形拓扑):\n- 节点: $V_2=\\{0,1,2,3,4,5,6\\}$，所以 $|V_2|=7$。\n- 边: $E_2=\\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\}$。\n- 枢纽阈值: $k_{\\text{hub}}=5$。\n- 容差: $\\tau=0.1$。\n\n测试用例 $3$ (环上的冗余高次度节点):\n- 节点: $V_3=\\{0,1,2,3,4,5\\}$，所以 $|V_3|=6$。\n- 边: $E_3$ 是一个 $6$ 元环，加上从节点 $0$ 到节点 $2$、$3$ 和 $4$ 的额外弦：\n$$\nE_3=\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0),(0,2),(0,3),(0,4)\\}.\n$$\n- 枢纽阈值: $k_{\\text{hub}}=5$。\n- 容差: $\\tau=0.0$。\n\n对于每个测试用例 $i \\in \\{1,2,3\\}$，计算脆弱枢纽节点的集合，即所有满足 $\\deg(v) \\ge k_{\\text{hub}}$ 和 $L(v) \\le \\tau$ 的节点 $v$。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是对应测试用例的脆弱枢纽节点索引列表（按升序排列）。例如，输出格式必须为\n$$\n[\\,[\\text{case 1 indices}],\\,[\\text{case 2 indices}],\\,[\\text{case 3 indices}]\\,].\n$$\n如果某个用例没有脆弱枢纽节点，则为该用例输出一个空列表 $[\\,]$。此问题不涉及物理单位或角度。每个测试用例所需的输出类型是整数列表，并按指定方式聚合成单行。", "solution": "在尝试求解之前，对问题陈述进行了严格的验证过程。\n\n**步骤 1：提取给定信息**\n\n问题提供了以下定义和数据：\n- 网络被建模为一个有限、无向、简单图 $G=(V,E)$。\n- 节点 $v$ 的度是 $\\deg(v)$。\n- 如果 $\\deg(v) \\ge k_{\\text{hub}}$（其中 $k_{\\text{hub}} \\ge 1$ 为一个整数阈值），则节点 $v$ 是一个枢纽节点。\n- 移除节点 $v$ 会产生一个残余图 $G'=(V \\setminus \\{v\\}, E')$。\n- $G'$ 的连通分量的大小为 $s_1, s_2, \\dots, s_m$。$G'$ 中的总节点数是 $|V'| = \\sum_{i=1}^{m} s_i$。\n- 可达性分数 $R(v)$ 定义为：\n$$\nR(v) = \n\\begin{cases}\n1, & \\text{if } |V'| \\le 1,\\\\\n\\displaystyle \\frac{\\sum_{i=1}^{m} \\binom{s_i}{2}}{\\binom{|V'|}{2}}, & \\text{if } |V'| \\ge 2.\n\\end{cases}\n$$\n- 损失是 $L(v) = 1 - R(v)$。\n- 脆弱枢纽节点是满足 $L(v) \\le \\tau$ 的枢纽节点 $v$，其中 $\\tau \\in [0,1]$ 是给定的容差。\n- 任务是为三个特定的测试用例找出所有的脆弱枢纽节点。\n\n测试用例 1：\n- 节点 $V_1 = \\{0, 1, 2, 3, 4, 5, 6, 7, 8\\}$ ($|V_1|=9$)。\n- 边 $E_1 = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(1,3),(1,4),(2,3),(2,4),(3,4), (5,6),(5,7),(5,8),(6,7),(6,8),(7,8),(2,5),(3,6)\\}$。\n- 参数: $k_{\\text{hub}}=5$, $\\tau=0.05$。\n\n测试用例 2：\n- 节点 $V_2=\\{0, 1, 2, 3, 4, 5, 6\\}$ ($|V_2|=7$)。\n- 边 $E_2=\\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\}$。\n- 参数: $k_{\\text{hub}}=5$, $\\tau=0.1$。\n\n测试用例 3：\n- 节点 $V_3=\\{0, 1, 2, 3, 4, 5\\}$ ($|V_3|=6$)。\n- 边 $E_3=\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0),(0,2),(0,3),(0,4)\\}$。\n- 参数: $k_{\\text{hub}}=5$, $\\tau=0.0$。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n根据有效性标准对问题进行评估。\n1.  **科学性**：问题使用标准的图论概念来建模网络属性。这是计算生物学和生物信息学中一种常规且有效的方法。度量 $R(v)$ 和 $L(v)$是明确定义的数学构造，用于量化网络破碎程度。不存在科学或逻辑上的缺陷。\n2.  **适定性**：所有术语都经过了数学上的精确定义。每个测试用例的输入（图和参数）都已明确提供。目标——找到一组特定的节点——是明确无误的。对于给定的图和参数，解是唯一的并且可以确定性地计算出来。\n3.  **客观性**：问题陈述不含主观或基于观点的断言。它提出了一个清晰的计算任务。\n4.  **完整性和一致性**：每个测试用例都用节点、边和参数完全指定。图的描述与明确的边列表一致。没有缺失数据或矛盾。\n5.  **可行性**：图的规模很小，使得所需的计算是可行的。没有给出任何物理上不可能或不一致的数据。\n\n**步骤 3：结论与行动**\n\n该问题在科学上是合理的，在数学上是适定的，并且是完全指定的。因此，它被判定为 **有效**。我们继续推导解决方案。\n\n**方法论**\n\n每个测试用例的解决方案通过执行以下算法获得：\n1.  对于给定的图 $G=(V,E)$，构建一个邻接表表示。\n2.  对于每个节点 $v \\in V$，计算其度 $\\deg(v)$。\n3.  确定枢纽节点的集合，$V_{\\text{hub}} = \\{v \\in V \\mid \\deg(v) \\ge k_{\\text{hub}}\\}$。\n4.  对于每个枢纽节点 $v \\in V_{\\text{hub}}$：\n    a. 确定残余图中的节点集合，$V' = V \\setminus \\{v\\}$。其大小为 $|V'| = |V|-1$。\n    b. 在节点集 $V'$ 上找到残余图 $G'$ 的连通分量。这可以通过标准的图遍历算法（如广度优先搜索(BFS)或深度优先搜索(DFS)）来完成，以找到这些分量的大小 $s_1, s_2, \\dots, s_m$。\n    c. 计算损失 $L(v)$。如果 $|V'| < 2$，$L(v) = 0$。否则，计算 $G'$ 中不同节点对的总数，即 $\\binom{|V'|}{2}$，以及保持连接的节点对数量，即 $\\sum_{i=1}^{m} \\binom{s_i}{2}$。可达性分数是 $R(v) = (\\sum_{i=1}^{m} \\binom{s_i}{2}) / \\binom{|V'|}{2}$，损失是 $L(v) = 1 - R(v)$。二项式系数 $\\binom{n}{2}$ 计算为 $n(n-1)/2$。\n    d. 将损失与容差进行比较：如果 $L(v) \\le \\tau$，则 $v$ 是一个脆弱枢纽节点。\n5.  收集该测试用例中所有已识别的脆弱枢纽节点索引，并将其作为一个排序列表呈现。\n\n**应用于测试用例**\n\n**测试用例 1：**\n- 图 $G_1=(V_1, E_1)$，其中 $|V_1|=9$, $k_{\\text{hub}}=5$, $\\tau=0.05$。\n- 度计算：\n  - $\\deg(0)=4$, $\\deg(1)=4$, $\\deg(2)=5$, $\\deg(3)=5$, $\\deg(4)=4$。\n  - $\\deg(5)=4$, $\\deg(6)=4$, $\\deg(7)=3$, $\\deg(8)=3$。\n- 枢纽节点（度 $\\ge 5$ 的节点）是 $\\{2, 3\\}$。\n- 对于枢纽节点 $v=2$：移除节点 $2$。残余图 $G_1'$ 的节点为 $V_1' = V_1 \\setminus \\{2\\}$，因此 $|V_1'|=8$。边 $(3,6)$ 仍然存在，保持了两个原始模块之间的连通性。因此，$G_1'$ 是完全连通的，有一个大小为 $s_1=8$ 的分量。\n  - 连通分量中的节点对数：$\\binom{8}{2} = 28$。\n  - $V_1'$ 中的总节点对数：$\\binom{8}{2} = 28$。\n  - $R(2) = 28/28 = 1$。\n  - $L(2) = 1 - 1 = 0$。由于 $0 \\le 0.05$，节点 $2$ 是一个脆弱枢纽节点。\n- 对于枢纽节点 $v=3$：移除节点 $3$。残余图 $G_1''$ 的大小为 $|V_1''|=8$。边 $(2,5)$ 仍然存在，保持图的连通性。它有一个大小为 $s_1=8$ 的分量。\n  - $L(3) = 0$。由于 $0 \\le 0.05$，节点 $3$ 是一个脆弱枢纽节点。\n- 用例 1 的脆弱枢纽节点是 $\\{2, 3\\}$，排序后为 $[2, 3]$。\n\n**测试用例 2：**\n- 图 $G_2=(V_2, E_2)$，其中 $|V_2|=7$, $k_{\\text{hub}}=5$, $\\tau=0.1$。这是一个中心为 $0$ 的星形图。\n- 度计算：$\\deg(0)=6$，对于 $v \\in \\{1, \\dots, 6\\}$，$\\deg(v)=1$。\n- 唯一的枢纽节点是节点 $0$。\n- 对于枢纽节点 $v=0$：移除节点 $0$。残余图 $G_2'$ 的节点为 $V_2' = \\{1, 2, 3, 4, 5, 6\\}$，因此 $|V_2'|=6$。移除中心节点会移除所有边。\n  - 分量是 $6$ 个孤立节点，每个大小为 $s_i=1$。\n  - 连通分量中的节点对数：$\\sum_{i=1}^6 \\binom{1}{2} = 0$。\n  - $V_2'$ 中的总节点对数：$\\binom{6}{2} = 15$。\n  - $R(0) = 0/15 = 0$。\n  - $L(0) = 1 - 0 = 1$。由于 $1 \\not\\le 0.1$，节点 $0$ 不是一个脆弱枢纽节点。\n- 用例 2 没有脆弱枢纽节点。结果是空列表 $[\\,]$。\n\n**测试用例 3：**\n- 图 $G_3=(V_3, E_3)$，其中 $|V_3|=6$, $k_{\\text{hub}}=5$, $\\tau=0.0$。\n- 度计算：\n  - $\\deg(0)=5$, $\\deg(1)=2$, $\\deg(2)=3$, $\\deg(3)=3$, $\\deg(4)=3$, $\\deg(5)=2$。\n- 唯一的枢纽节点是节点 $0$。\n- 对于枢纽节点 $v=0$：移除节点 $0$。残余图 $G_3'$ 的节点为 $V_3'=\\{1, 2, 3, 4, 5\\}$，因此 $|V_3'|=5$。剩余的边是 $(1,2), (2,3), (3,4), (4,5)$，它们形成一个路径图。\n  - 该图是连通的，所以有一个大小为 $s_1=5$ 的分量。\n  - 连通分量中的节点对数：$\\binom{5}{2} = 10$。\n  - $V_3'$ 中的总节点对数：$\\binom{5}{2} = 10$。\n  - $R(0) = 10/10 = 1$。\n  - $L(0) = 1 - 1 = 0$。由于 $0 \\le 0.0$，节点 $0$ 是一个脆弱枢纽节点。\n- 用例 3 的脆弱枢纽节点是 $\\{0\\}$，排序后为 $[0]$。\n\n**综合结果**\n- 用例 1: $[2, 3]$\n- 用例 2: $[\\,]$\n- 用例 3: $[0]$\n最终输出是通过聚合这些列表来构建的。", "answer": "```python\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Solves the fragile hub identification problem for a given suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": list(range(9)),\n            \"edges\": [(0,1),(0,2),(0,3),(0,4),(1,2),(1,3),(1,4),(2,3),(2,4),(3,4),\n                      (5,6),(5,7),(5,8),(6,7),(6,8),(7,8),(2,5),(3,6)],\n            \"k_hub\": 5,\n            \"tau\": 0.05\n        },\n        {\n            \"nodes\": list(range(7)),\n            \"edges\": [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)],\n            \"k_hub\": 5,\n            \"tau\": 0.1\n        },\n        {\n            \"nodes\": list(range(6)),\n            \"edges\": [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0),(0,2),(0,3),(0,4)],\n            \"k_hub\": 5,\n            \"tau\": 0.0\n        }\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        edges = case[\"edges\"]\n        k_hub = case[\"k_hub\"]\n        tau = case[\"tau\"]\n        num_nodes = len(nodes)\n\n        # Build adjacency list\n        adj = {node: [] for node in nodes}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # Calculate degrees and find hubs\n        degrees = {node: len(neighbors) for node, neighbors in adj.items()}\n        hubs = [node for node, deg in degrees.items() if deg >= k_hub]\n\n        fragile_hubs = []\n\n        for hub in hubs:\n            # 1. Define the residual graph\n            residual_nodes = [node for node in nodes if node != hub]\n            num_residual_nodes = len(residual_nodes)\n\n            if num_residual_nodes < 2:\n                loss = 0.0\n            else:\n                # 2. Find connected components in the residual graph using DFS\n                visited = set()\n                component_sizes = []\n                for start_node in residual_nodes:\n                    if start_node not in visited:\n                        component_size = 0\n                        stack = [start_node]\n                        visited.add(start_node)\n                        while stack:\n                            current_node = stack.pop()\n                            component_size += 1\n                            for neighbor in adj[current_node]:\n                                # neighbor must be in the residual graph and not visited\n                                if neighbor != hub and neighbor not in visited:\n                                    visited.add(neighbor)\n                                    stack.append(neighbor)\n                        component_sizes.append(component_size)\n\n                # 3. Calculate Loss L(v)\n                sum_of_pairs_in_components = sum(comb(s, 2, exact=True) for s in component_sizes)\n                total_pairs_in_residual = comb(num_residual_nodes, 2, exact=True)\n                \n                if total_pairs_in_residual == 0:\n                    reachability_fraction = 1.0\n                else:\n                    reachability_fraction = sum_of_pairs_in_components / total_pairs_in_residual\n                \n                loss = 1.0 - reachability_fraction\n\n            # 4. Check if the hub is fragile\n            if loss <= tau:\n                fragile_hubs.append(hub)\n\n        fragile_hubs.sort()\n        final_results.append(fragile_hubs)\n\n    # Format output as specified: [[...], [...], [...]]\n    # str(list) can add spaces, e.g., '[2, 3]'. remove spaces.\n    results_str = [str(res).replace(\" \", \"\") for res in final_results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2409629"}, {"introduction": "与中心节点类似，并非所有瓶颈节点（bottleneck）都同等关键；网络的可塑性可能通过冗余路径补偿某些瓶颈的移除。本练习引入了一个更精细的度量——“全局效率”，来量化这种补偿效应，并定义了“鲁棒瓶颈”这一概念。通过完成这个编程任务，你将学会如何评估和识别那些即使被移除，对网络整体通信效率影响很小的高介数节点，从而深化对网络鲁棒性的理解 [@problem_id:2409636]。", "problem": "给定代表相互作用网络的无向、无权图，你需要形式化并检测计算生物学与生物信息学意义下的“鲁棒瓶颈”实例：一个具有高介数中心性的节点，其移除可以通过冗余路径被网络可塑性有效补偿。你的任务是编写一个程序，对每个给定的测试图，返回在精确的数学定义标准下满足此属性的所有节点的列表。\n\n使用的基本依据是：无向图的定义、最短路径、介数中心性和网络效率。具体来说，请使用以下定义。\n\n- 图由邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 指定，当且仅当节点$i$和$j$之间存在无向边时，$A_{ij} = 1$。对于所有$i,j$，有$A_{ii} = 0$和$A_{ij} = A_{ji}$。节点从 $\\{0,1,\\dots,n-1\\}$ 开始，以0为基准进行索引。\n- 对于节点$s,t$，最短路径是实现$s$和$t$之间最小边数$d(s,t)$的任何路径。如果$s$和$t$不连通，则定义$d(s,t) = \\infty$。\n- 节点$v$的介数中心性$b(v)$是对于所有满足$s < t$，$s \\neq v \\neq t$的无序对$\\{s,t\\}$，从$s$到$t$的经过$v$的最短路径所占比例之和。即：\n$$\nb(v) = \\sum_{\\substack{s < t\\\\ s \\neq v \\neq t}} \\frac{\\sigma_{st}(v)}{\\sigma_{st}},\n$$\n其中$\\sigma_{st}$是$s$和$t$之间的最短路径数，$\\sigma_{st}(v)$是这些路径中经过$v$的数量。\n- 节点集$V$上的图的全局效率为：\n$$\nE(V) = \\frac{2}{|V|(|V|-1)} \\sum_{\\substack{i<j\\\\ i,j \\in V}} \\frac{1}{d(i,j)},\n$$\n约定$1/\\infty = 0$。\n\n为形式化“被网络可塑性有效补偿”，我们对每个候选节点$v$，比较在移除$v$前后，剩余节点$V \\setminus \\{v\\}$之间的效率：\n- 令$E_{\\text{before}}(v)$表示在原始图（即$v$存在时）中计算的所有满足$i<j$且$i,j \\in V \\setminus \\{v\\}$的无序对$\\{i,j\\}$的$1/d(i,j)$的平均值。\n- 令$E_{\\text{after}}(v)$表示相同的平均值，但距离是在移除$v$后得到的图（即在$V \\setminus \\{v\\}$上的导出子图）中计算的。\n- 定义相对效率下降\n$$\n\\Delta(v) = \\begin{cases}\n\\frac{E_{\\text{before}}(v)-E_{\\text{after}}(v)}{E_{\\text{before}}(v)}, & \\text{if } E_{\\text{before}}(v) > 0,\\\\\n0, & \\text{if } E_{\\text{before}}(v) = 0.\n\\end{cases}\n$$\n\n当且仅当节点$v$同时满足以下两个条件时，它才被视为“鲁棒瓶颈”：\n- 高介数标准：$b(v) \\ge Q_q(b)$ 且 $b(v) > 0$，其中$Q_q(b)$是对于给定的$q \\in (0,1)$，多重集$\\{b(0),b(1),\\dots,b(n-1)\\}$的$q$-分位数。\n- 补偿标准：$\\Delta(v) \\le \\tau$，其中$\\tau \\in [0,1]$是给定的容差。\n\n实现一个算法，在给定图以及参数$q$和$\\tau$的情况下，返回满足这两个标准的所有节点的排序列表。通过广度优先搜索计算无权图的精确最短路径，并精确计算介数中心性（例如，通过正确实现Brandes算法的无权图变体）。除给定信息外，你不得假设任何特定的图结构。\n\n测试套件与要求输出：\n- 使用以下三个测试用例，每个用例都由一个元素在$\\{0,1\\}$中的邻接矩阵给出，并共享参数$q$和$\\tau$。\n\n- 测试用例 1 (由冗余中间层连接的两个模块):\n  - $n = 8$，节点 $\\{0,1,2,3,4,5,6,7\\}$。\n  - 邻接矩阵 $A^{(1)}$，节点0到7的行分别为：\n    - 节点 $0$: $[0,1,1,0,0,0,1,1]$\n    - 节点 $1$: $[1,0,1,0,0,0,1,1]$\n    - 节点 $2$: $[1,1,0,0,0,0,1,1]$\n    - 节点 $3$: $[0,0,0,0,1,1,1,1]$\n    - 节点 $4$: $[0,0,0,1,0,1,1,1]$\n    - 节点 $5$: $[0,0,0,1,1,0,1,1]$\n    - 节点 $6$: $[1,1,1,1,1,1,0,0]$\n    - 节点 $7$: $[1,1,1,1,1,1,0,0]$\n  - 参数: $q = 0.8$, $\\tau = 0.01$。\n\n- 测试用例 2 (星形图):\n  - $n = 6$，节点 $\\{0,1,2,3,4,5\\}$。\n  - 邻接矩阵 $A^{(2)}$，节点0到5的行分别为：\n    - 节点 $0$: $[0,1,1,1,1,1]$\n    - 节点 $1$: $[1,0,0,0,0,0]$\n    - 节点 $2$: $[1,0,0,0,0,0]$\n    - 节点 $3$: $[1,0,0,0,0,0]$\n    - 节点 $4$: $[1,0,0,0,0,0]$\n    - 节点 $5$: $[1,0,0,0,0,0]$\n  - 参数: $q = 0.8$, $\\tau = 0.01$。\n\n- 测试用例 3 (四个节点的完全图):\n  - $n = 4$，节点 $\\{0,1,2,3\\}$。\n  - 邻接矩阵 $A^{(3)}$，节点0到3的行分别为：\n    - 节点 $0$: $[0,1,1,1]$\n    - 节点 $1$: $[1,0,1,1]$\n    - 节点 $2$: $[1,1,0,1]$\n    - 节点 $3$: $[1,1,1,0]$\n  - 参数: $q = 0.8$, $\\tau = 0.01$。\n\n对每个测试用例，输出满足这两个标准的、以0为基准索引的节点列表，并按升序排序。你的程序应生成单行输出，其中包含三个测试用例的结果，格式为逗号分隔的列表的列表，并用方括号括起来。例如，需要像`[[a,b],[c],[]]`这样的格式，其中$a,b,c$是整数。此问题不涉及物理单位或角度。所有结果必须是整数、整数列表或空列表；不应打印百分比。\n\n你的程序必须是自包含的，不接受任何输入。它必须为无向无权图实现正确的路径计数和精确的介数中心性计算，并精确应用上述定义。最终打印的行应严格为指定的聚合列表，不包含任何额外文本。", "solution": "用户提供了一个有科学依据、适定、客观且自包含的问题。其中如图论概念（如介数中心性和网络效率）的定义都是标准的。所提出的“鲁棒瓶颈”的形式化是一个基于这些标准度量、清晰且可操作的标准。该问题提供了所有必要的数据，包括图结构和参数，并指定了明确的计算目标。问题中没有矛盾、歧义或依赖于非科学性主张。因此，该问题是有效的，可以推导出解决方案。\n\n任务是识别网络中一种特定类型的节点，称为“鲁棒瓶颈”。这需要一个两部分的特征描述：该节点必须是网络流量的重要枢纽（高介数中心性），但其移除不能灾难性地破坏网络连通性，这通过全局效率的小幅下降来衡量（有效补偿）。我们将构建一个算法来识别给定图中的所有此类节点。\n\n整体算法流程如下。对于每个图，我们首先识别满足高介数标准的节点集。然后，对图中的每个节点，我们计算网络对其移除的恢复能力。最后，鲁棒瓶颈的集合是满足这两个标准的节点的交集。\n\n**1. 高介数标准**\n\n如果一个节点$v$的介数中心性$b(v)$为正，并且大于或等于一个统计阈值，则认为其具有高介数性。介数中心性定义为：\n$$\nb(v) = \\sum_{\\substack{s < t\\\\ s \\neq v \\neq t}} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n$$\n其中$\\sigma_{st}$是节点$s$和$t$之间的最短路径总数，$\\sigma_{st}(v)$是其中经过节点$v$的路径数。对于无向图，此和是针对所有不等于$v$的无序节点对$\\{s,t\\}$。\n\n为了计算图中所有节点$v$的$b(v)$，我们采用Brandes算法，这是一种针对无权图的高效方法。该算法通过遍历每个节点$s$作为源点并执行以下步骤来运行：\n- 从$s$开始启动广度优先搜索（BFS），以计算到所有其他节点$u$的最短路径距离$d(s,u)$和最短路径数量$\\sigma_{su}$。在BFS期间，我们还记录从$s$出发的最短路径上每个节点$u$的前驱节点$P_s(u)$。\n- BFS之后，节点按其与$s$的距离降序处理。对每个节点$w$，计算依赖性得分$\\delta_s(w)$。该分数量化了从$s$到其他节点的最短路径对$w$的依赖程度。依赖性从最远的节点向源点$s$“反向”累积。更新前驱节点$v \\in P_s(w)$的依赖性的公式是：\n$$\n\\delta_s(v) \\leftarrow \\delta_s(v) + \\frac{\\sigma_{sv}}{\\sigma_{sw}} (1 + \\delta_{s}(w))\n$$\n- 介数中心性$b(w)$是这些依赖性得分在所有可能的源点$s$上的总和。由于问题指定的是无向图，且中心性定义是基于无序对，标准Brandes算法（其对有序对求和）的结果必须除以2。\n\n一旦计算出所有的$b(v)$值，我们确定阈值$Q_q(b)$，即所有中心性值集合$\\{b(0), b(1), ..., b(n-1)\\}$的$q$-分位数。如果$b(v) \\ge Q_q(b)$且$b(v) > 0$，则节点$v$满足高介数标准。\n\n**2. 补偿标准**\n\n此标准衡量网络的“可塑性”，即其在节点被移除时重新路由流量的能力。我们使用网络效率的相对下降值$\\Delta(v)$来量化这一点。图的效率是衡量信息在网络中交换难易程度的指标。对于节点集$U$，它与$U$中所有节点对之间平均最短路径距离的倒数有关。\n\n对于每个候选节点$v$，我们在剩余节点集$V' = V \\setminus \\{v\\}$上定义两个与效率相关的和：\n- $S_{\\text{before}}(v) = \\sum_{\\substack{i<j\\\\ i,j \\in V'}} \\frac{1}{d(i,j)}$，其中距离$d(i,j)$是在完整的原始图中计算的。\n- $S_{\\text{after}}(v) = \\sum_{\\substack{i<j\\\\ i,j \\in V'}} \\frac{1}{d_v(i,j)}$，其中距离$d_v(i,j)$是在移除了节点$v$及其关联边的图中计算的。\n\n则相对效率下降为：\n$$\n\\Delta(v) = \\frac{S_{\\text{before}}(v)-S_{\\text{after}}(v)}{S_{\\text{before}}(v)}\n$$\n前提是$S_{\\text{before}}(v) > 0$。如果$S_{\\text{before}}(v) = 0$，则$\\Delta(v) = 0$。请注意，用于计算平均效率的归一化因子在此比率中被抵消了。\n\n为了计算这些和，我们需要所有节点对之间的最短路径（APSP）距离。由于图是无权的，这可以通过在相应图（原始图用于$d(i,j)$，简化图用于$d_v(i,j)$）中从每个节点运行一次单独的BFS来实现。\n\n如果节点$v$的移除导致了较小的效率下降，即$\\Delta(v) \\le \\tau$（其中$\\tau$是给定的容差），则该节点满足补偿标准。\n\n**3. 算法综合**\n\n对于给定的图和参数$q$和$\\tau$，完整的算法如下：\n1.  使用Brandes算法计算所有节点$v \\in V$的介数中心性$b(v)$。\n2.  计算阈值$Q_q(b)$作为中心性值的$q$-分位数。\n3.  识别高介数节点集 $V_{\\text{high-b}} = \\{v \\in V \\mid b(v) \\ge Q_q(b) \\land b(v) > 0\\}$。\n4.  计算原始图的APSP距离矩阵。\n5.  初始化一个空的补偿节点集$V_{\\text{comp}}$。\n6.  对每个节点$v \\in V$：\n    a. 使用预先计算的APSP距离计算$S_{\\text{before}}(v)$。\n    b. 构建由$V \\setminus \\{v\\}$导出的子图。\n    c. 计算该子图的APSP距离矩阵，并用它来找到$S_{\\text{after}}(v)$。\n    d. 计算$\\Delta(v)$。如果$\\Delta(v) \\le \\tau$，则将$v$添加到$V_{\\text{comp}}$。\n7.  鲁棒瓶颈的最终列表是交集$V_{\\text{high-b}} \\cap V_{\\text{comp}}$中节点的排序列表。\n\n此过程是确定性的，直接实现了所提供的定义，从而保证了对任何给定输入图的正确解。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef _bfs_for_brandes(adj, s, n):\n    \"\"\"Performs BFS from source s to compute shortest paths info.\"\"\"\n    S = []\n    P = {i: [] for i in range(n)}\n    sigma = {i: 0 for i in range(n)}\n    sigma[s] = 1\n    d = {i: -1 for i in range(n)}\n    d[s] = 0\n    \n    Q = deque([s])\n    \n    while Q:\n        v = Q.popleft()\n        S.append(v)\n        \n        for w in adj.get(v, []):\n            if d[w] < 0:\n                Q.append(w)\n                d[w] = d[v] + 1\n            \n            if d[w] == d[v] + 1:\n                sigma[w] += sigma[v]\n                P[w].append(v)\n    return S, P, sigma\n\ndef compute_betweenness_centrality(A):\n    \"\"\"Computes betweenness centrality using Brandes' algorithm for unweighted graphs.\"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return {}\n    \n    adj = {i: [j for j, connected in enumerate(row) if connected] for i, row in enumerate(A)}\n    betweenness = {i: 0.0 for i in range(n)}\n\n    for s in range(n):\n        S, P, sigma = _bfs_for_brandes(adj, s, n)\n        delta = {i: 0.0 for i in range(n)}\n        \n        while S:\n            w = S.pop()\n            for v in P.get(w, []):\n                if sigma.get(w, 0) != 0:\n                    delta[v] += (sigma.get(v, 0) / sigma[w]) * (1.0 + delta.get(w, 0.0))\n            if w != s:\n                betweenness[w] += delta.get(w, 0.0)\n\n    # For undirected graphs, divide by 2\n    for v in range(n):\n        betweenness[v] /= 2.0\n    return betweenness\n\ndef get_apsp_distances(A):\n    \"\"\"Computes all-pairs shortest path distances using BFS from each node.\"\"\"\n    n = A.shape[0]\n    dist = np.full((n, n), np.inf, dtype=float)\n    \n    adj = {i: [j for j, connected in enumerate(row) if connected] for i, row in enumerate(A)}\n\n    for i in range(n):\n        dist[i, i] = 0\n        q = deque([(i, 0)])\n        visited = {i}\n        \n        while q:\n            u, d = q.popleft()\n            for v in adj.get(u, []):\n                if v not in visited:\n                    visited.add(v)\n                    dist[i, v] = d + 1\n                    q.append((v, d + 1))\n    return dist\n\ndef find_robust_bottlenecks(A, q, tau):\n    \"\"\"Finds robust bottlenecks in a graph based on centrality and efficiency criteria.\"\"\"\n    n = A.shape[0]\n    nodes = list(range(n))\n\n    # 1. High-betweenness criterion\n    centralities = compute_betweenness_centrality(A)\n    b_values = np.array(list(centralities.values()))\n    \n    if n <= 1 or np.all(b_values == 0):\n        q_threshold = 0.0\n    else:\n        q_threshold = np.quantile(b_values, q, method='linear')\n    \n    high_b_nodes = {v for v, b in centralities.items() if b >= q_threshold and b > 0}\n    \n    if not high_b_nodes:\n        return []\n\n    # 2. Compensation criterion\n    dist_original = get_apsp_distances(A)\n    compensated_nodes = set()\n    \n    for v in nodes:\n        nodes_minus_v = [i for i in nodes if i != v]\n        \n        if len(nodes_minus_v) < 2:\n            delta_v = 0.0\n        else:\n            sum_inv_dist_before = 0.0\n            for i_idx, i in enumerate(nodes_minus_v):\n                for j in nodes_minus_v[i_idx + 1:]:\n                    dist = dist_original[i, j]\n                    if np.isfinite(dist) and dist > 0:\n                        sum_inv_dist_before += 1.0 / dist\n            \n            if sum_inv_dist_before == 0.0:\n                delta_v = 0.0\n            else:\n                adj_minus_v = np.delete(np.delete(A, v, axis=0), v, axis=1)\n                dist_after = get_apsp_distances(adj_minus_v)\n                \n                sum_inv_dist_after = 0.0\n                for i in range(len(nodes_minus_v) - 1):\n                    for j in range(i + 1, len(nodes_minus_v)):\n                        dist = dist_after[i, j]\n                        if np.isfinite(dist) and dist > 0:\n                            sum_inv_dist_after += 1.0 / dist\n                \n                delta_v = (sum_inv_dist_before - sum_inv_dist_after) / sum_inv_dist_before\n        \n        if delta_v <= tau:\n            compensated_nodes.add(v)\n            \n    result_nodes = sorted(list(high_b_nodes.intersection(compensated_nodes)))\n    return result_nodes\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    \n    # Shared parameters from the problem description\n    q = 0.8\n    tau = 0.01\n\n    # Test Case 1\n    A1 = np.array([\n        [0, 1, 1, 0, 0, 0, 1, 1],\n        [1, 0, 1, 0, 0, 0, 1, 1],\n        [1, 1, 0, 0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 1, 1, 1, 1],\n        [0, 0, 0, 1, 0, 1, 1, 1],\n        [0, 0, 0, 1, 1, 0, 1, 1],\n        [1, 1, 1, 1, 1, 1, 0, 0],\n        [1, 1, 1, 1, 1, 1, 0, 0]\n    ])\n\n    # Test Case 2\n    A2 = np.array([\n        [0, 1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0]\n    ])\n\n    # Test Case 3\n    A3 = np.array([\n        [0, 1, 1, 1],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [1, 1, 1, 0]\n    ])\n\n    test_cases = [A1, A2, A3]\n    \n    all_results = []\n    for A in test_cases:\n        result = find_robust_bottlenecks(A, q, tau)\n        all_results.append(str(result).replace(\" \", \"\"))\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2409636"}]}