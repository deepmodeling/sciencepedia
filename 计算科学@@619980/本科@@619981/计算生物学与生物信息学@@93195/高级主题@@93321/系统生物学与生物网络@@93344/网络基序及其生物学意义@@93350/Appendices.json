{"hands_on_practices": [{"introduction": "在研究网络基序的功能之前，首要任务是在复杂的生物网络中准确地识别它们。本练习将引导你设计一个算法，用于寻找“同构基序” (iso-motifs)——即那些拓扑结构相同但调控关系（如激活或抑制）的符号不同的基序实例。通过这个实践，你将亲身体验计算生物学中基序搜索的核心挑战，并深刻理解为何仅仅识别基序的“形状”是不够的，边的“符号”对于揭示其生物学功能至关重要。", "problem": "您的任务是设计并实现一个算法，用于在带符号的有向生物网络中检测“同构基序”（iso-motifs）的存在。此处的同构基序定义为：两个具有相同基序拓扑但调控符号不同的实例。例如，这个概念捕捉了转录调控网络中相干与非相干前馈环（Feed-Forward Loops, FFLs）共存的现象，其中相干 FFL 的直接调控符号等于其两步路径符号的乘积，而非相干 FFL 的这些符号不匹配。您的算法必须完全以数学术语表述，并实现为一个完整的、可运行的程序。\n\n基本定义：\n- 一个带符号有向图由一个符号邻接矩阵 $S \\in \\{-1,0,+1\\}^{n \\times n}$ 表示，该图包含一组 $n$ 个节点。其中 $S[u,v] = +1$ 表示从节点 $u$ 到节点 $v$ 的激活， $S[u,v] = -1$ 表示抑制，而 $S[u,v] = 0$ 表示不存在边。\n- 一个基序模板是一个有向拓扑，由一个 $k \\times k$ 的二元邻接矩阵 $M \\in \\{0,1\\}^{k \\times k}$ 表示，其中对于所有 $i$ 都有 $M[i,i] = 0$。$M$ 在 $S$ 中的一个导出匹配是一个单射 $\\phi: \\{0,\\dots,k-1\\} \\to \\{0,\\dots,n-1\\}$，使得对于所有 $i \\neq j$ 的有序对 $(i,j)$，边的存在或不存在都与模板完全匹配：$M[i,j] = 1$ 当且仅当 $S[\\phi(i),\\phi(j)] \\neq 0$，$M[i,j] = 0$ 当且仅当 $S[\\phi(i),\\phi(j)] = 0$。\n- 对于任何导出匹配 $\\phi$，定义其符号签名向量 $\\sigma_M(\\phi)$，该向量通过按一个固定的规范顺序（$(i,j)$ 的字典序）列出所有模板边 $(i,j)$（其中 $M[i,j]=1$）对应的 $S[\\phi(i),\\phi(j)]$ 的符号而得到。如果两个基序实例的符号签名向量不相同，则它们是符号相异的。\n\n您的任务是实现一个算法，给定一个宿主符号网络 $S$ 和一个基序模板 $M$，确定 $S$ 中是否存在至少两个 $M$ 的导出匹配，且它们的符号签名向量不同。如果存在，则图 $S$ 包含模板 $M$ 的同构基序；否则，不包含。\n\n要求：\n- 从上述基本定义出发，不假设任何专门的子图同构捷径。算法的正确性必须通过从导出匹配的定义出发进行构建来保证。\n- 实现必须是通用的，适用于在所述约束内的任意 $n$、$k$、$S$ 和 $M$。\n- 程序必须执行一个内置的宿主图和模板测试套件，并打印一行包含布尔结果列表的输出，其格式需与本问题末尾描述的完全一致。\n\n测试套件：\n实现该算法并在以下五个案例上进行评估。对于每个案例，输入均为一对 $(S, M)$。\n\n- 案例 1 (两个具有相同符号模式的 FFL；无同构基序):\n  - 宿主图大小 $n = 5$，边（每个三元组 $(u,v,s)$ 表示 $S[u,v]=s$）：\n    - $(0,1,+1)$, $(1,2,+1)$, $(0,2,+1)$,\n    - $(2,3,+1)$, $(3,4,+1)$, $(2,4,+1)$,\n    - 所有其他条目为 $0$。\n  - 模板大小 $k = 3$ (前馈环 (FFL) 拓扑):\n    - $M[0,1]=1$, $M[1,2]=1$, $M[0,2]=1$，所有其他对（包括所有对角线）的 $M[i,j]=0$。\n- 案例 2 (两个具有不同符号模式的 FFL；存在同构基序):\n  - 宿主图大小 $n = 6$，边：\n    - $(0,1,+1)$, $(1,2,+1)$, $(0,2,-1)$,\n    - $(3,4,+1)$, $(4,5,+1)$, $(3,5,+1)$,\n    - 所有其他条目为 $0$。\n  - 模板：与案例 1 中相同的 FFL 模板 $M$。\n- 案例 3 (不存在 FFL):\n  - 宿主图大小 $n = 4$，边：\n    - $(0,1,+1)$, $(1,2,-1)$, $(2,3,+1)$,\n    - 所有其他条目为 $0$。\n  - 模板：与案例 1 中相同的 FFL 模板 $M$。\n- 案例 4 (存在 FFL 拓扑，但因一条额外的边而违规；导出匹配被排除):\n  - 宿主图大小 $n = 3$，边：\n    - $(0,1,+1)$, $(1,2,+1)$, $(0,2,+1)$, 外加一条 $(2,0,+1)$,\n    - 所有其他条目为 $0$。\n  - 模板：与案例 1 中相同的 FFL 模板 $M$。\n- 案例 5 (一个不同的基序模板：一个有两条边的 3 节点有向链；存在同构基序):\n  - 宿主图大小 $n = 5$，边：\n    - $(0,1,+1)$, $(1,2,+1)$, $(3,4,-1)$, $(4,0,+1)$,\n    - 所有其他条目为 $0$。\n  - 模板大小 $k = 3$ (有向链):\n    - $M[0,1]=1$, $M[1,2]=1$，所有其他对（包括 $M[0,2]=0$ 和所有对角线）的 $M[i,j]=0$。\n\n输出规范：\n- 对于每个案例，您的程序必须计算一个布尔值，表示是否存在至少两个 $M$ 在 $S$ 中的导出匹配，其符号签名向量不同。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 `[x_1,x_2,x_3,x_4,x_5]`，其中每个 $x_i$ 是 `True` 或 `False`，并按上述案例的顺序排列。\n- 本问题不涉及物理单位。", "solution": "提交分析的问题陈述是有效的。它具有科学依据，在数学上是良定的，并且没有矛盾或含糊之处。关于带符号有向图、基序模板、导出匹配和符号签名向量的定义是精确的，并与计算生物学和图论中的既定概念一致。其目标是确定是否存在至少两个符号相异的基序实例，这是一个具体且可解的计算任务。我们将着手推导一个正确且完整的算法。\n\n核心任务是确定一个给定的带符号有向网络 $S$ 是否包含至少两个在符号模式上不同的基序模板 $M$ 的导出实例。形式上，设 $S$ 由一个大小为 $n \\times n$、元素取自 $\\{-1, 0, +1\\}$ 的符号邻接矩阵表示，设 $M$ 是一个大小为 $k \\times k$、代表基序拓扑的二元邻接矩阵。我们需要确定符号签名集合 $\\Sigma_{S,M}$ 是否包含多于一个唯一元素，其中 $\\Sigma_{S,M} = \\{ \\sigma_M(\\phi) \\mid \\phi \\text{ is an induced match of } M \\text{ in } S \\}$。因此，问题在于计算陈述 $|\\Sigma_{S,M}| > 1$ 的真值。\n\n根据要求，我们的算法将直接从这些第一性原理构建。算法的基础是对 $M$ 在 $S$ 中的所有导出匹配进行系统性搜索。一个导出匹配是从模板的 $k$ 个位置 $\\{0, \\dots, k-1\\}$ 到宿主图的 $n$ 个节点 $\\{0, \\dots, n-1\\}$ 的单射。所有此类单射的集合等价于 $n$ 个节点索引的有序 $k$-排列的集合。\n\n算法流程如下：\n\n1.  **枚举潜在映射**：我们生成从 $k$ 个模板位置到 $n$ 个图节点的所有可能的单射。这通过遍历节点集 $\\{0, 1, \\dots, n-1\\}$ 的所有 $k$-排列来实现。设 $p = (p_0, p_1, \\dots, p_{k-1})$ 是这样一个排列，它定义了一个候选映射 $\\phi(i) = p_i$，其中 $i \\in \\{0, \\dots, k-1\\}$。此类排列的总数为 $P(n,k) = \\frac{n!}{(n-k)!}$。\n\n2.  **验证导出匹配条件**：对于每个候选映射 $\\phi$（由一个排列 $p$ 表示），我们必须严格验证它是否构成一个导出匹配。根据定义，这要求对于每一对不同的模板位置 $(i, j)$，在 $S$ 中 $\\phi(i)$ 和 $\\phi(j)$ 之间存在一条边，当且仅当在 $M$ 中 $i$ 和 $j$ 之间存在一条边。这可转化为以下逻辑条件，该条件必须对所有 $i \\neq j$ 且 $i, j \\in \\{0, \\dots, k-1\\}$ 成立：\n    $$\n    (M[i,j] = 1) \\iff (S[\\phi(i), \\phi(j)] \\neq 0)\n    $$\n    如果这个条件对于任何一个对 $(i,j)$ 不成立，则映射 $\\phi$ 不是一个导出匹配，我们将其丢弃并继续处理下一个排列。\n\n3.  **提取和收集签名**：如果一个映射 $\\phi$ 对所有 $k(k-1)$ 个不同的位置对都满足导出匹配条件，那么它就是一个有效的匹配。我们接着提取其符号签名向量 $\\sigma_M(\\phi)$。\n    - 我们首先为模板 $M$ 的边建立一个规范顺序。设 $E_M = \\{(i,j) \\mid M[i,j] = 1, 0 \\le i, j < k\\}$。我们按字典序对 $E_M$ 的元素进行排序。设此有序序列为 $(e_1, e_2, \\dots, e_m)$，其中 $m = |E_M|$。\n    - 对于此规范序列中的每条边 $e_r = (i, j)$，我们找到相应的符号 $S[\\phi(i), \\phi(j)]$。\n    - 符号签名 $\\sigma_M(\\phi)$ 是按规范顺序收集的这些符号的元组：$(\\text{sign}(S, \\phi, e_1), \\dots, \\text{sign}(S, \\phi, e_m))$。\n    - 我们维护一个集合数据结构，记作 $\\mathcal{F}$，用于存储迄今发现的唯一符号签名。在找到一个有效匹配并构建其签名后，我们将该签名添加到 $\\mathcal{F}$ 中。\n\n4.  **终止条件**：主要目标是确定是否存在多个唯一的签名。因此，在向 $\\mathcal{F}$ 添加新签名后，我们检查其大小。如果在任何时候 $|\\mathcal{F}| > 1$，我们便证明了至少存在两个符号相异的实例（一个同构基序）。此时，算法可以立即终止对当前 $(S, M)$ 对的搜索，并报告结果为 `True`。如果所有 $P(n,k)$ 个排列的枚举完成，而 $|\\mathcal{F}|$ 仍然小于或等于 $1$，则表示所有找到的基序实例（如果有的话）都共享相同的符号模式。在这种情况下，结果为 `False`。\n\n这种由定义驱动的暴力方法保证了正确性，因为它详尽地检查了所有可能性，而没有依赖可能出错的启发式方法。对于指定的测试用例，其中 $n$ 和 $k$ 很小，这种方法在计算上是可行的。例如，在案例 2 中，$n=6$，$k=3$，排列数为 $P(6,3) = 120$，对于每个排列，我们执行 $k(k-1)=6$ 次检查，这是一个微不足道的计算负载。\n\n将此算法应用于测试用例：\n- 案例 1：宿主图在节点 $\\{0,1,2\\}$ 和 $\\{2,3,4\\}$ 处包含两个 FFL。两者都产生签名 $(+1, +1, +1)$。签名集合 $\\mathcal{F}$ 的大小从未超过 1。结果：`False`。\n- 案例 2：该图包含两个 FFL。在 $\\{0,1,2\\}$ 处的 FFL 签名为 $(+1, -1, +1)$，在 $\\{3,4,5\\}$ 处的 FFL 签名为 $(+1, +1, +1)$。集合 $\\mathcal{F}$ 的大小增长到 2。结果：`True`。\n- 案例 3：图拓扑不允许任何 FFL。集合 $\\mathcal{F}$ 保持为空。结果：`False`。\n- 案例 4：节点 $\\{0,1,2\\}$ 上的子图不是 *导出* FFL，因为存在一条额外的边 $S[2,0]=+1$，而模板要求此处无边 ($M[2,0]=0$)。未找到导出匹配。结果：`False`。\n- 案例 5：该图包含两个导出的 3 节点链。在节点 $\\{0,1,2\\}$ 上的匹配给出签名 $(+1,+1)$。在节点 $\\{3,4,0\\}$ 上的匹配给出签名 $(-1,+1)$。集合 $\\mathcal{F}$ 的大小达到 2。结果：`True`。\n\n因此，该算法已根据所有提供的场景得到验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import permutations\n\ndef solve():\n    \"\"\"\n    Solves the iso-motif detection problem for a hardcoded test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Two identical FFLs, no iso-motif\n        {\n            \"S_info\": {\"n\": 5, \"edges\": [(0, 1, 1), (1, 2, 1), (0, 2, 1), (2, 3, 1), (3, 4, 1), (2, 4, 1)]},\n            \"M_info\": {\"k\": 3, \"edges\": [(0, 1), (1, 2), (0, 2)]},\n        },\n        # Case 2: Two different FFLs, iso-motif exists\n        {\n            \"S_info\": {\"n\": 6, \"edges\": [(0, 1, 1), (1, 2, 1), (0, 2, -1), (3, 4, 1), (4, 5, 1), (3, 5, 1)]},\n            \"M_info\": {\"k\": 3, \"edges\": [(0, 1), (1, 2), (0, 2)]},\n        },\n        # Case 3: No FFLs present\n        {\n            \"S_info\": {\"n\": 4, \"edges\": [(0, 1, 1), (1, 2, -1), (2, 3, 1)]},\n            \"M_info\": {\"k\": 3, \"edges\": [(0, 1), (1, 2), (0, 2)]},\n        },\n        # Case 4: FFL topology present but not an induced match\n        {\n            \"S_info\": {\"n\": 3, \"edges\": [(0, 1, 1), (1, 2, 1), (0, 2, 1), (2, 0, 1)]},\n            \"M_info\": {\"k\": 3, \"edges\": [(0, 1), (1, 2), (0, 2)]},\n        },\n        # Case 5: Different motif (3-chain), iso-motif exists\n        {\n            \"S_info\": {\"n\": 5, \"edges\": [(0, 1, 1), (1, 2, 1), (3, 4, -1), (4, 0, 1)]},\n            \"M_info\": {\"k\": 3, \"edges\": [(0, 1), (1, 2)]},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Build host graph matrix S\n        n = case[\"S_info\"][\"n\"]\n        s_edges = case[\"S_info\"][\"edges\"]\n        S = np.zeros((n, n), dtype=int)\n        for u, v, sign in s_edges:\n            S[u, v] = sign\n\n        # Build motif template matrix M\n        k = case[\"M_info\"][\"k\"]\n        m_edges = case[\"M_info\"][\"edges\"]\n        M = np.zeros((k, k), dtype=int)\n        for i, j in m_edges:\n            M[i, j] = 1\n\n        # Execute the detection logic for the current case\n        has_iso_motif = find_iso_motifs(S, M, n, k)\n        results.append(has_iso_motif)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_iso_motifs(S, M, n, k):\n    \"\"\"\n    Determines if a host graph S contains iso-motifs for a template M.\n\n    An iso-motif exists if there are at least two induced matches of M in S\n    with distinct sign signature vectors.\n    \"\"\"\n    # Establish canonical order of template edges (lexicographic)\n    template_edges = []\n    for i in range(k):\n        for j in range(k):\n            if M[i, j] == 1:\n                template_edges.append((i, j))\n\n    found_signatures = set()\n    node_indices = range(n)\n\n    # Iterate through all k-permutations of the n host nodes\n    # Each permutation represents a potential injective mapping phi\n    for p in permutations(node_indices, k):\n        # p is the mapping: template position i -> host node p[i]\n        \n        is_induced_match = True\n        # Verify the induced match condition for all pairs of template positions\n        for i in range(k):\n            for j in range(k):\n                if i == j:\n                    continue\n                \n                # Check if edge existence matches between template and host subgraph\n                template_has_edge = (M[i, j] == 1)\n                host_has_edge = (S[p[i], p[j]] != 0)\n\n                if template_has_edge != host_has_edge:\n                    is_induced_match = False\n                    break\n            if not is_induced_match:\n                break\n        \n        # If it is an induced match, extract and store its signature\n        if is_induced_match:\n            signature = tuple(S[p[i], p[j]] for i, j in template_edges)\n            found_signatures.add(signature)\n            \n            # If we find more than one unique signature, an iso-motif exists\n            if len(found_signatures) > 1:\n                return True\n\n    # If the loop completes, an iso-motif was not found\n    return len(found_signatures) > 1\n\nsolve()\n```", "id": "2409925"}, {"introduction": "识别出网络基序后，下一步是探究它们的动态功能。本练习聚焦于一种常见的网络基序——相干前馈环路（coherent Feed-Forward Loop, FFL），它在生物系统中常扮演着信号滤波器的角色，能够过滤掉短暂的噪声信号。你将通过编写数值模拟程序，来探索在FFL的中间节点上增加一个负向自动调控（negative autoregulation）会如何影响其输出动态，从而直观地展示网络局部结构如何对生物行为进行精确调优。", "problem": "要求您量化在一个具有与逻辑门的相干前馈环（FFL）中，为中间节点 $B$ 添加一条自抑制（负向自动调节）边如何影响节点 $C$ 的输出动态。请从基因调控动力学的核心定义出发：产生与一阶降解相平衡，以及由S型Hill函数建模的转录调控。考虑一个包含有向边 $A \\to B \\to C$ 和 $A \\to C$ 的三基因网络，并作如下假设：\n\n- 每个节点 $X \\in \\{A,B,C\\}$ 是一个非负无量纲浓度 $X(t) \\ge 0$，其变化由以下形式的一阶微分方程控制\n$$\n\\frac{dX}{dt} \\;=\\; \\frac{P_X(\\cdot) - X}{\\tau_X},\n$$\n其中 $P_X(\\cdot)$ 是无量纲产生项，$\\tau_X > 0$ 是以降分钟为单位的降解时间常数。\n- $A$ 的输入是一个阶跃函数 $u(t)$，在时间 $t=0$ 时从 $u(0^-)=0$ 变为 $u(0^+)=1$。$A$ 的产生项为 $P_A(u)=u(t)$，因此\n$$\n\\frac{dA}{dt} \\;=\\; \\frac{u(t) - A}{\\tau_A}.\n$$\n- 激活Hill函数为\n$$\nH_{\\mathrm{act}}(x;K,n) \\;=\\; \\frac{x^n}{K^n + x^n},\n$$\n抑制Hill函数为\n$$\nH_{\\mathrm{rep}}(x;K,n) \\;=\\; \\frac{K^n}{K^n + x^n} \\;=\\; \\frac{1}{1+(x/K)^n}.\n$$\n- 不含自抑制时 $B$ 的产生项为\n$$\nP_B^{(0)}(A) \\;=\\; \\alpha_B \\, H_{\\mathrm{act}}(A;K_{AB},n_{AB}),\n$$\n带有负向自动调节（自抑制）时为\n$$\nP_B^{(-)}(A,B) \\;=\\; \\alpha_B \\, H_{\\mathrm{act}}(A;K_{AB},n_{AB}) \\, H_{\\mathrm{rep}}(B;K_{BB},n_{BB}).\n$$\n- $C$ 的产生使用与逻辑门，实现为来自 $A$ 和 $B$ 的激活作用的乘积：\n$$\nP_C(A,B) \\;=\\; \\alpha_C \\, H_{\\mathrm{act}}(A;K_{AC},n_{AC}) \\, H_{\\mathrm{act}}(B;K_{BC},n_{BC}).\n$$\n\n您的任务是编写一个程序，对每个测试用例，数值模拟系统在两种情景下对阶跃输入的响应：$B$ 处无自抑制（基线情景）和 $B$ 处有自抑制（负向自动调节情景）。对于每种情景，请计算输出 $C(t)$ 的以下三个定量指标：\n\n- 半升时间 $t_{50}$，定义为满足 $C(t) \\ge 0.5 \\, C_{\\infty}$ 的最早时间 $t$，其中 $C_{\\infty}$ 是给定情景下 $C$ 的稳态值。\n- 超调比 $r_{\\mathrm{ov}}$，定义为 $r_{\\mathrm{ov}} = \\max_t C(t) / C_{\\infty} - 1$，以小数形式（而非百分比）表示。\n- 峰值时间 $t_{\\mathrm{peak}}$，定义为 $C(t)$ 达到其最大值的时间。\n\n然后，对每个测试用例，报告以下差值\n$$\n\\Delta t_{50} = t_{50}^{(-)} - t_{50}^{(0)}, \\quad \\Delta r_{\\mathrm{ov}} = r_{\\mathrm{ov}}^{(-)} - r_{\\mathrm{ov}}^{(0)}, \\quad \\Delta t_{\\mathrm{peak}} = t_{\\mathrm{peak}}^{(-)} - t_{\\mathrm{peak}}^{(0)},\n$$\n其中上标 $(0)$ 和 $(-)$ 分别表示基线情景和负向自动调节情景。所有时间必须以分钟为单位报告。超调比是无量纲的，必须以小数形式报告。\n\n为确保通用性和可复现性的实现细节：\n\n- 在均匀网格 $t=0, \\Delta t, 2\\Delta t, \\dots, T_{\\max}$ 上，使用步长 $\\Delta t = 0.01$ 分钟和最终时间 $T_{\\max}=100$ 分钟的固定步长四阶龙格－库塔法进行数值积分。\n- 初始条件为 $A(0)=0$，$B(0)=0$，$C(0)=0$。\n- 将 $C_{\\infty}$ 估计为在 $t=T_{\\max}$ 时的最终模拟值。\n\n测试套件：对于每个测试，模拟两种情景（基线和负向自动调节）。在一个测试用例中，下面未明确列出的参数在两种情景下是相同的。\n\n- 测试 1（正常路径）：\n  - $\\tau_A=1$, $\\tau_B=2$, $\\tau_C=5$; $\\alpha_B=1$, $\\alpha_C=1$.\n  - $K_{AB}=0.5$, $n_{AB}=2$; $K_{AC}=0.5$, $n_{AC}=2$; $K_{BC}=0.5$, $n_{BC}=2$.\n  - 负向自动调节参数： $K_{BB}=0.5$, $n_{BB}=2$.\n- 测试 2（弱自抑制边界）：\n  - $\\tau_A=1$, $\\tau_B=2$, $\\tau_C=5$; $\\alpha_B=1$, $\\alpha_C=1$.\n  - $K_{AB}=0.5$, $n_{AB}=2$; $K_{AC}=0.5$, $n_{AC}=2$; $K_{BC}=0.5$, $n_{BC}=2$.\n  - 负向自动调节参数： $K_{BB}=5.0$, $n_{BB}=2$.\n- 测试 3（强自抑制且B快速）：\n  - $\\tau_A=1$, $\\tau_B=0.5$, $\\tau_C=5$; $\\alpha_B=1$, $\\alpha_C=1$.\n  - $K_{AB}=0.5$, $n_{AB}=2$; $K_{AC}=0.5$, $n_{AC}=2$; $K_{BC}=0.5$, $n_{BC}=2$.\n  - 负向自动调节参数： $K_{BB}=0.2$, $n_{BB}=3$.\n- 测试 4（B的慢动态）：\n  - $\\tau_A=1$, $\\tau_B=10$, $\\tau_C=5$; $\\alpha_B=1$, $\\alpha_C=1$.\n  - $K_{AB}=0.5$, $n_{AB}=2$; $K_{AC}=0.5$, $n_{AC}=2$; $K_{BC}=0.5$, $n_{BC}=2$.\n  - 负向自动调节参数： $K_{BB}=0.5$, $n_{BB}=2$.\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个三元列表 $[\\Delta t_{50}, \\Delta r_{\\mathrm{ov}}, \\Delta t_{\\mathrm{peak}}]$。因此，最终输出必须是以下形式的单行\n$[\\,[\\Delta t_{50}^{(1)},\\Delta r_{\\mathrm{ov}}^{(1)},\\Delta t_{\\mathrm{peak}}^{(1)}],\\,[\\Delta t_{50}^{(2)},\\Delta r_{\\mathrm{ov}}^{(2)},\\Delta t_{\\mathrm{peak}}^{(2)}],\\,[\\Delta t_{50}^{(3)},\\Delta r_{\\mathrm{ov}}^{(3)},\\Delta t_{\\mathrm{peak}}^{(3)}],\\,[\\Delta t_{50}^{(4)},\\Delta r_{\\mathrm{ov}}^{(4)},\\Delta t_{\\mathrm{peak}}^{(4)}]\\,]$，所有时间以分钟为单位，超调比为小数。", "solution": "该问题是有效的。它提出了一个定义明确的常微分方程组，用于模拟一个常见的生物网络基序——相干前馈环（FFL），并要求在有和无负向自动调节两种条件下对其动态响应进行定量分析。其公式表述基于系统生物学的既定原则，采用一阶降解动力学和用于转录调控的Hill函数。所有参数、初始条件和数值积分规范均已提供，使得该问题自成体系、客观且有科学依据。\n\n所研究的系统是一个三节点基因调控网络，包含基因 $A$、$B$ 和 $C$。其产物的浓度（表示为无量纲变量 $A(t)$、$B(t)$ 和 $C(t)$）根据以下耦合常微分方程组演化：\n$$\n\\frac{dA}{dt} = \\frac{u(t) - A}{\\tau_A}\n$$\n$$\n\\frac{dB}{dt} = \\frac{P_B - B}{\\tau_B}\n$$\n$$\n\\frac{dC}{dt} = \\frac{P_C(A,B) - C}{\\tau_C}\n$$\n其中 $\\tau_X > 0$ 是物种 $X$ 的降解时间常数。该系统由外部输入信号 $u(t)$ 驱动，该信号是一个从 $u(0^-)=0$ 变为 $u(0^+)=1$ 的阶跃函数。系统的初始状态为 $A(0)=0$，$B(0)=0$，$C(0)=0$。\n\n产生项 $P_B$ 和 $P_C$ 描述了调控相互作用。该问题对比了基因 $B$ 调控的两种情景：\n$1$. 基线情景（上标 $(0)$），其中 $B$ 仅受 $A$ 调控：\n$$\nP_B^{(0)}(A) = \\alpha_B \\, H_{\\mathrm{act}}(A;K_{AB},n_{AB})\n$$\n$2$. 负向自动调节情景（上标 $(-)$），其中 $B$ 抑制其自身的产生：\n$$\nP_B^{(-)}(A,B) = \\alpha_B \\, H_{\\mathrm{act}}(A;K_{AB},n_{AB}) \\, H_{\\mathrm{rep}}(B;K_{BB},n_{BB})\n$$\n此处，$\\alpha_B$ 是最大产生速率，而 $H_{\\mathrm{act}}$ 和 $H_{\\mathrm{rep}}$ 分别是用于激活和抑制的标准S型Hill函数：\n$$\nH_{\\mathrm{act}}(x;K,n) = \\frac{x^n}{K^n + x^n}, \\quad H_{\\mathrm{rep}}(x;K,n) = \\frac{K^n}{K^n + x^n} = \\frac{1}{1+(x/K)^n}\n$$\n参数 $K$ 和 $n$ 分别代表激活/抑制阈值和Hill系数（响应的陡峭程度）。\n\n$C$ 的产生由 $A$ 和 $B$ 通过与逻辑门共同控制，数学上实现为它们各自激活影响的乘积：\n$$\nP_C(A,B) = \\alpha_C \\, H_{\\mathrm{act}}(A;K_{AC},n_{AC}) \\, H_{\\mathrm{act}}(B;K_{BC},n_{BC})\n$$\n这种具有有向边 $A \\to B \\to C$ 和 $A \\to C$ 的结构定义了一个1型相干前馈环。与逻辑要求 $A$ 和 $B$ 必须同时存在才能强力激活 $C$。已知这种网络拓扑可用作一个对信号敏感的延迟元件，它能对持续的输入信号作出响应，但会过滤掉短暂的瞬时脉冲。\n\n为了求解该系统，我们必须执行数值积分。问题指定了使用四阶龙格－库塔（RK4）方法，在区间 $[0, T_{\\max}=100]$ 上以固定时间步长 $\\Delta t = 0.01$ 分钟进行。设状态向量为 $\\mathbf{y}(t) = [A(t), B(t), C(t)]^T$。该常微分方程组可写为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}(\\mathbf{y})$，其中对于 $t \\ge 0$，$u(t)=1$ 且系统是自治的：\n$$\n\\mathbf{F}(\\mathbf{y}) = \\begin{pmatrix} (1 - y_1) / \\tau_A \\\\ (P_B(y_1, y_2) - y_2) / \\tau_B \\\\ (P_C(y_1, y_2) - y_3) / \\tau_C \\end{pmatrix}\n$$\n从时间 $t_k$ 到 $t_{k+1} = t_k + \\Delta t$ 的RK4积分步长计算如下：\n$$\n\\mathbf{y}_{k+1} = \\mathbf{y}_k + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n增量为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{F}(\\mathbf{y}_k) \\\\\n\\mathbf{k}_2 &= \\mathbf{F}(\\mathbf{y}_k + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= \\mathbf{F}(\\mathbf{y}_k + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= \\mathbf{F}(\\mathbf{y}_k + \\Delta t \\, \\mathbf{k}_3)\n\\end{aligned}\n$$\n此过程从初始条件 $\\mathbf{y}_0 = [0, 0, 0]^T$ 开始重复，直到 $t=T_{\\max}$。\n\n获得 $C(t)$ 的时间序列后，我们提取三个关键指标来表征输出动态：\n$1$. 半升时间，$t_{50}$：$C(t)$ 达到其最终稳态值 $C_{\\infty}$ 的 $50\\%$ 所需的时间。我们估计 $C_{\\infty} \\approx C(T_{\\max})$。然后 $t_{50}$ 是第一个满足 $C(t) \\ge 0.5 \\, C_{\\infty}$ 的时间 $t$。已知负向自动调节可以加速转录因子的响应，因此我们预计 $t_{50}^{(-)} < t_{50}^{(0)}$，从而导致负的 $\\Delta t_{50}$。\n$2$. 超调比，$r_{\\mathrm{ov}}$：高于稳态值的最大相对超调量，定义为 $r_{\\mathrm{ov}} = [\\max_t C(t) / C_{\\infty}] - 1$。由于到达 $C$ 的两条路径中延迟的相互作用，该系统可能会出现超调。\n$3$. 峰值时间，$t_{\\mathrm{peak}}$：$C(t)$ 达到其最大值 $C_{\\mathrm{peak}} = \\max_t C(t)$ 的时间。这对应于最大超调发生的时间（如果存在超调）。如果没有发生超调，则 $t_{\\mathrm{peak}} = T_{\\max}$。\n\n对于每个测试用例，我们都执行此模拟和分析两次——一次是针对基线系统（情景 $(0)$），另一次是针对在节点 $B$ 上有负向自动调节的系统（情景 $(-)$）——并计算差值 $\\Delta t_{50} = t_{50}^{(-)} - t_{50}^{(0)}$，$\\Delta r_{\\mathrm{ov}} = r_{\\mathrm{ov}}^{(-)} - r_{\\mathrm{ov}}^{(0)}$，以及 $\\Delta t_{\\mathrm{peak}} = t_{\\mathrm{peak}}^{(-)} - t_{\\mathrm{peak}}^{(0)}$。这使得我们能够在这种FFL背景下直接量化负向自动调节的功能性作用。\n\n提供的Python代码实现了这整个过程。它定义了用于Hill动力学的辅助函数，为两种情景设置了ODE系统，实现了RK4积分器，并包含一个循环来处理每个测试用例、计算指标、计算它们的差值，并按规定格式化最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define test cases with all parameters.\n    test_cases = [\n        # Test 1: happy path\n        {\n            'tau_A': 1.0, 'tau_B': 2.0, 'tau_C': 5.0, 'alpha_B': 1.0, 'alpha_C': 1.0,\n            'K_AB': 0.5, 'n_AB': 2.0, 'K_AC': 0.5, 'n_AC': 2.0, 'K_BC': 0.5, 'n_BC': 2.0,\n            'K_BB': 0.5, 'n_BB': 2.0\n        },\n        # Test 2: weak self-inhibition\n        {\n            'tau_A': 1.0, 'tau_B': 2.0, 'tau_C': 5.0, 'alpha_B': 1.0, 'alpha_C': 1.0,\n            'K_AB': 0.5, 'n_AB': 2.0, 'K_AC': 0.5, 'n_AC': 2.0, 'K_BC': 0.5, 'n_BC': 2.0,\n            'K_BB': 5.0, 'n_BB': 2.0\n        },\n        # Test 3: strong self-inhibition with fast B\n        {\n            'tau_A': 1.0, 'tau_B': 0.5, 'tau_C': 5.0, 'alpha_B': 1.0, 'alpha_C': 1.0,\n            'K_AB': 0.5, 'n_AB': 2.0, 'K_AC': 0.5, 'n_AC': 2.0, 'K_BC': 0.5, 'n_BC': 2.0,\n            'K_BB': 0.2, 'n_BB': 3.0\n        },\n        # Test 4: slow B dynamics\n        {\n            'tau_A': 1.0, 'tau_B': 10.0, 'tau_C': 5.0, 'alpha_B': 1.0, 'alpha_C': 1.0,\n            'K_AB': 0.5, 'n_AB': 2.0, 'K_AC': 0.5, 'n_AC': 2.0, 'K_BC': 0.5, 'n_BC': 2.0,\n            'K_BB': 0.5, 'n_BB': 2.0\n        }\n    ]\n\n    # Simulation parameters\n    dt = 0.01\n    T_max = 100.0\n    time_points = np.arange(0, T_max + dt, dt)\n    num_steps = len(time_points)\n\n    def H_act(x, K, n):\n        \"\"\"Activation Hill function.\"\"\"\n        if x == 0: return 0.0\n        xn = x**n\n        Kn = K**n\n        return xn / (Kn + xn)\n\n    def H_rep(x, K, n):\n        \"\"\"Repression Hill function.\"\"\"\n        if K == 0: return 0.0\n        return 1.0 / (1.0 + (x / K)**n)\n\n    def odes(y, params, nar):\n        \"\"\"System of ODEs. y = [A, B, C].\"\"\"\n        A, B, C = y\n        p = params\n        \n        # dA/dt\n        dA_dt = (1.0 - A) / p['tau_A']\n        \n        # dB/dt\n        P_B_act = p['alpha_B'] * H_act(A, p['K_AB'], p['n_AB'])\n        if nar:\n            P_B = P_B_act * H_rep(B, p['K_BB'], p['n_BB'])\n        else:\n            P_B = P_B_act\n        dB_dt = (P_B - B) / p['tau_B']\n        \n        # dC/dt\n        P_C = p['alpha_C'] * H_act(A, p['K_AC'], p['n_AC']) * H_act(B, p['K_BC'], p['n_BC'])\n        dC_dt = (P_C - C) / p['tau_C']\n        \n        return np.array([dA_dt, dB_dt, dC_dt])\n\n    def rk4_solver(params, nar, dt, num_steps):\n        \"\"\"Fourth-order Runge-Kutta solver.\"\"\"\n        y = np.zeros((num_steps, 3))\n        y[0,:] = [0.0, 0.0, 0.0]\n        \n        for i in range(num_steps - 1):\n            k1 = odes(y[i], params, nar)\n            k2 = odes(y[i] + 0.5 * dt * k1, params, nar)\n            k3 = odes(y[i] + 0.5 * dt * k2, params, nar)\n            k4 = odes(y[i] + dt * k3, params, nar)\n            y[i+1] = y[i] + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        return y\n\n    def analyze_results(C_t, time_points):\n        \"\"\"Calculates metrics t50, r_ov, and t_peak.\"\"\"\n        C_inf = C_t[-1]\n        \n        if C_inf == 0:\n            return 0.0, 0.0, 0.0\n\n        # Half-rise time t50\n        half_rise_indices = np.where(C_t >= 0.5 * C_inf)[0]\n        t50 = time_points[half_rise_indices[0]] if len(half_rise_indices) > 0 else 0.0\n\n        # Overshoot ratio r_ov and peak time t_peak\n        C_peak_idx = np.argmax(C_t)\n        C_peak = C_t[C_peak_idx]\n        t_peak = time_points[C_peak_idx]\n        r_ov = C_peak / C_inf - 1.0\n        \n        return t50, r_ov, t_peak\n\n    all_results = []\n    for params in test_cases:\n        # Scenario 0: Baseline (no NAR)\n        solution_0 = rk4_solver(params, nar=False, dt=dt, num_steps=num_steps)\n        C_t_0 = solution_0[:, 2]\n        t50_0, rov_0, tpeak_0 = analyze_results(C_t_0, time_points)\n        \n        # Scenario (-): With Negative Autoregulation\n        solution_neg = rk4_solver(params, nar=True, dt=dt, num_steps=num_steps)\n        C_t_neg = solution_neg[:, 2]\n        t50_neg, rov_neg, tpeak_neg = analyze_results(C_t_neg, time_points)\n        \n        # Calculate differences\n        delta_t50 = t50_neg - t50_0\n        delta_rov = rov_neg - rov_0\n        delta_tpeak = tpeak_neg - tpeak_0\n        \n        all_results.append([delta_t50, delta_rov, delta_tpeak])\n\n    # Format output string exactly as required\n    inner_strings = []\n    for r in all_results:\n        # Format each number to avoid unnecessary trailing decimals\n        s_t50 = f\"{r[0]:.10f}\".rstrip('0').rstrip('.') if r[0] != 0 else '0'\n        s_rov = f\"{r[1]:.10f}\".rstrip('0').rstrip('.') if r[1] != 0 else '0'\n        s_tpeak = f\"{r[2]:.10f}\".rstrip('0').rstrip('.') if r[2] != 0 else '0'\n        inner_strings.append(f\"[{s_t50},{s_rov},{s_tpeak}]\")\n        \n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2409950"}, {"introduction": "除了数值模拟，数学分析为我们理解基序功能提供了另一种强有力的理论工具。本练习将深入研究一个著名的生物振荡器原型——三节点负反馈环路（three-node negative feedback loop），它构成了许多生物节律（如昼夜节律）的核心。你将运用线性稳定性分析来推导这个“抑制振荡器”（repressilator）从稳定状态转变为持续振荡所需的精确条件，从而揭示网络参数（如增益 $g$）与系统涌现出的动态行为（如振荡）之间的深刻联系。", "problem": "一个转录调控网络基序由一个$3$节点环路构成，其中每个基因都抑制下一个基因：基因$1$抑制基因$2$，基因$2$抑制基因$3$，基因$3$抑制基因$1$。令$x_{i}(t)$表示在时间$t$时基因$i$的蛋白质产物浓度，其中$i \\in \\{1,2,3\\}$。假设存在一个时间常数为$\\tau>0$的相同的线性降解，以及一个由抑制性Hill函数描述的相同的合成过程，该函数具有最大速率$\\alpha>0$、解离常数$K_{d}>0$和Hill系数$n>1$。这个$3$节点负反馈回路的动力学常微分方程（ODE）模型为：\n$$\n\\frac{d x_{1}}{d t} \\;=\\; -\\frac{x_{1}}{\\tau} \\;+\\; \\frac{\\alpha}{1 + \\left(\\frac{x_{3}}{K_{d}}\\right)^{n}},\\qquad\n\\frac{d x_{2}}{d t} \\;=\\; -\\frac{x_{2}}{\\tau} \\;+\\; \\frac{\\alpha}{1 + \\left(\\frac{x_{1}}{K_{d}}\\right)^{n}},\\qquad\n\\frac{d x_{3}}{d t} \\;=\\; -\\frac{x_{3}}{\\tau} \\;+\\; \\frac{\\alpha}{1 + \\left(\\frac{x_{2}}{K_{d}}\\right)^{n}}.\n$$\n假设存在一个对称稳态$(x_{1},x_{2},x_{3}) = (x^{*},x^{*},x^{*})$，其中$x^{*}>0$。定义合成函数$f(x) = \\dfrac{\\alpha}{1 + \\left(\\dfrac{x}{K_{d}}\\right)^{n}}$，并令$f'(x^{*})<0$表示其在$x^{*}$处的导数。引入无量纲单级增益$g = |f'(x^{*})|\\,\\tau$。\n\n分析对称稳态附近的局部动力学，并确定一对共轭复特征值首次穿过虚轴（可能发生局部Hopf分岔）时的精确临界值$g_{\\mathrm{crit}}$，该值仅用$g$表示。将$g_{\\mathrm{crit}}$报告为一个纯数。无需四舍五入。最终答案必须是单个实数。", "solution": "该问题要求确定一个由三个耦合常微分方程（ODE）组成的系统中Hopf分岔起始的临界参数值，该系统模拟一个基因抑制振荡器。系统由以下方程给出：\n$$\n\\frac{d x_{1}}{d t} \\;=\\; -\\frac{x_{1}}{\\tau} \\;+\\; f(x_{3})\n$$\n$$\n\\frac{d x_{2}}{d t} \\;=\\; -\\frac{x_{2}}{\\tau} \\;+\\; f(x_{1})\n$$\n$$\n\\frac{d x_{3}}{d t} \\;=\\; -\\frac{x_{3}}{\\tau} \\;+\\; f(x_{2})\n$$\n其中$x_{i}(t)$是蛋白质$i$的浓度，$\\tau > 0$是降解时间常数，而$f(x) = \\frac{\\alpha}{1 + \\left(\\frac{x}{K_{d}}\\right)^{n}}$是抑制性合成函数。我们已知存在一个对称稳态$(x^{*}, x^{*}, x^{*})$，其中$x^{*} > 0$。\n\n为了分析该稳态的局部稳定性，我们对系统进行线性化。这需要计算在稳态处求值的雅可比矩阵$J$。雅可比矩阵的元素由$J_{ij} = \\frac{\\partial}{\\partial x_{j}} \\left( \\frac{dx_{i}}{dt} \\right)$给出。\n向量场为$\\mathbf{F}(\\mathbf{x}) = (F_{1}, F_{2}, F_{3})^{T}$，其中\n$F_{1}(x_{1}, x_{2}, x_{3}) = -x_{1}/\\tau + f(x_{3})$，\n$F_{2}(x_{1}, x_{2}, x_{3}) = -x_{2}/\\tau + f(x_{1})$，\n$F_{3}(x_{1}, x_{2}, x_{3}) = -x_{3}/\\tau + f(x_{2})$。\n\n偏导数是：\n$$\n\\frac{\\partial F_{1}}{\\partial x_{1}} = -\\frac{1}{\\tau}, \\quad \\frac{\\partial F_{1}}{\\partial x_{2}} = 0, \\quad \\frac{\\partial F_{1}}{\\partial x_{3}} = f'(x_{3})\n$$\n$$\n\\frac{\\partial F_{2}}{\\partial x_{1}} = f'(x_{1}), \\quad \\frac{\\partial F_{2}}{\\partial x_{2}} = -\\frac{1}{\\tau}, \\quad \\frac{\\partial F_{2}}{\\partial x_{3}} = 0\n$$\n$$\n\\frac{\\partial F_{3}}{\\partial x_{1}} = 0, \\quad \\frac{\\partial F_{3}}{\\partial x_{2}} = f'(x_{2}), \\quad \\frac{\\partial F_{3}}{\\partial x_{3}} = -\\frac{1}{\\tau}\n$$\n在稳态$(x^{*}, x^{*}, x^{*})$处对这些求值，得到雅可比矩阵：\n$$\nJ =\n\\begin{pmatrix}\n-\\frac{1}{\\tau} & 0 & f'(x^{*}) \\\\\nf'(x^{*}) & -\\frac{1}{\\tau} & 0 \\\\\n0 & f'(x^{*}) & -\\frac{1}{\\tau}\n\\end{pmatrix}\n$$\n局部动力学由该矩阵的特征值$\\lambda$决定，这些特征值是特征方程$\\det(J - \\lambda I) = 0$的根，其中$I$是$3 \\times 3$单位矩阵。\n$$\n\\det\n\\begin{pmatrix}\n-\\frac{1}{\\tau} - \\lambda & 0 & f'(x^{*}) \\\\\nf'(x^{*}) & -\\frac{1}{\\tau} - \\lambda & 0 \\\\\n0 & f'(x^{*}) & -\\frac{1}{\\tau} - \\lambda\n\\end{pmatrix}\n= 0\n$$\n沿第一行展开行列式：\n$$\n\\left(-\\frac{1}{\\tau} - \\lambda\\right) \\left[ \\left(-\\frac{1}{\\tau} - \\lambda\\right)^{2} - 0 \\right] - 0 + f'(x^{*}) \\left[ f'(x^{*}) \\cdot f'(x^{*}) - 0 \\right] = 0\n$$\n化简为：\n$$\n\\left(-\\frac{1}{\\tau} - \\lambda\\right)^{3} + \\left(f'(x^{*})\\right)^{3} = 0\n$$\n$$\n\\left(\\lambda + \\frac{1}{\\tau}\\right)^{3} = \\left(f'(x^{*})\\right)^{3}\n$$\n我们定义一个新变量$z = \\lambda + \\frac{1}{\\tau}$并设$A = f'(x^{*})$。方程变为$z^{3} = A^{3}$。$z$的解是$A^{3}$的立方根，即$A \\cdot \\exp(i\\frac{2\\pi k}{3})$，其中$k \\in \\{0, 1, 2\\}$。\n三个根是：\n$z_{0} = A \\cdot \\exp(0) = A$\n$z_{1} = A \\cdot \\exp(i\\frac{2\\pi}{3}) = A \\left( \\cos(\\frac{2\\pi}{3}) + i\\sin(\\frac{2\\pi}{3}) \\right) = A \\left(-\\frac{1}{2} + i\\frac{\\sqrt{3}}{2}\\right)$\n$z_{2} = A \\cdot \\exp(i\\frac{4\\pi}{3}) = A \\left( \\cos(\\frac{4\\pi}{3}) + i\\sin(\\frac{4\\pi}{3}) \\right) = A \\left(-\\frac{1}{2} - i\\frac{\\sqrt{3}}{2}\\right)$\n\n现在，我们求解特征值$\\lambda = z - \\frac{1}{\\tau}$：\n$\\lambda_{1} = A - \\frac{1}{\\tau} = f'(x^{*}) - \\frac{1}{\\tau}$\n$\\lambda_{2} = A \\left(-\\frac{1}{2} + i\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\tau} = -\\frac{f'(x^{*})}{2} - \\frac{1}{\\tau} + i \\frac{\\sqrt{3}}{2}f'(x^{*})$\n$\\lambda_{3} = A \\left(-\\frac{1}{2} - i\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\tau} = -\\frac{f'(x^{*})}{2} - \\frac{1}{\\tau} - i \\frac{\\sqrt{3}}{2}f'(x^{*})$\n\n当一对共轭复特征值穿过虚轴时，发生Hopf分岔。这要求它们的实部为零，而虚部非零。特征值$\\lambda_{2}$和$\\lambda_{3}$构成这样一对。\n虚部为$\\pm \\frac{\\sqrt{3}}{2}f'(x^{*})$。因为我们已知$n > 1$，对于$x>0$，$f(x)$是一个严格递减函数，所以$f'(x^{*}) < 0$。因此，虚部非零。\n分岔条件是这对特征值的实部变为零：\n$$\n\\text{Re}(\\lambda_{2,3}) = -\\frac{f'(x^{*})}{2} - \\frac{1}{\\tau} = 0\n$$\n这给出：\n$$\n-f'(x^{*}) = \\frac{2}{\\tau}\n$$\n问题定义了无量纲单级增益$g = |f'(x^{*})|\\tau$。因为我们知道$f'(x^{*}) < 0$，所以有$|f'(x^{*})| = -f'(x^{*})$。因此，$g$的定义是$g = -f'(x^{*})\\tau$。\n我们可以重新整理这个表达式，将$-f'(x^{*})$表示为$\\frac{g}{\\tau}$。\n将此代入分岔条件：\n$$\n\\frac{g}{\\tau} = \\frac{2}{\\tau}\n$$\n由于$\\tau > 0$，我们可以在等式两边同乘以$\\tau$来求得$g$的临界值：\n$$\ng_{\\mathrm{crit}} = 2\n$$\n在此值下，复特征值的实部为零，预示着持续振荡的开始。第一个特征值$\\lambda_1 = f'(x^*) - 1/\\tau$的实部总是负的，因为$f'(x^*)<0$且$1/\\tau > 0$，所以它对应一个稳定模式，不参与分岔。\n因此，增益的临界值恰好是$2$。", "answer": "$$\\boxed{2}$$", "id": "2409935"}]}