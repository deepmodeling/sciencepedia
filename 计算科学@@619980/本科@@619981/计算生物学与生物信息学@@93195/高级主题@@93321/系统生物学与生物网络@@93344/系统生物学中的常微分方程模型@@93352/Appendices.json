{"hands_on_practices": [{"introduction": "在系统生物学中，对活细胞的建模不仅仅是描述化学反应。一个关键的、常被忽视的方面是细胞生长和分裂导致的分子稀释效应。本练习将指导您从基本原理出发，为指数生长的细胞推导出包含稀释项的常微分方程（ODE）模型，这对于准确预测细胞内分子浓度至关重要。[@problem_id:2411220]", "problem": "您的任务是构建和模拟一个机理常微分方程（ODE）模型，该模型在系统生物学的背景下，用于描述一个体积本身也是动态变量的指数增长细胞。该模型必须根据分子守恒和体积增长引起的稀释等第一性原理推导得出，然后针对指定的测试套件进行评估。\n\n考虑一个混合均匀的单细胞，其体积 $V(t)$ 按以下微分方程呈指数增长：\n$$\n\\frac{dV}{dt} = g \\, V,\n$$\n其中 $g$ 是比增长速率。设 $A(t)$ 和 $B(t)$ 分别表示两种物质 $A$ 和 $B$ 的细胞内浓度（单位为微摩尔，$\\mu \\mathrm{M}$）。假设单位体积内发生以下生物化学过程：\n- 物质 $A$ 以恒定速率 $q_A$ (单位 $\\mu \\mathrm{M} \\cdot \\mathrm{h}^{-1}$) 生成。\n- 物质 $A$ 以一级动力学转化为物质 $B$，速率常数为 $k_1$ (单位 $\\mathrm{h}^{-1}$)。\n- 物质 $B$ 以一级动力学降解，速率常数为 $k_2$ (单位 $\\mathrm{h}^{-1}$)。\n\n假设细胞内浓度因体积增长而被稀释。从定义 $C_i(t) = N_i(t)/V(t)$ 出发，其中 $N_i(t)$ 是物质 $i$ 的分子数量，对 $\\frac{d}{dt}(N_i/V)$ 应用商法则，推导在上述反应方案下 $A(t)$ 和 $B(t)$ 的常微分方程，并包含生长稀释效应。使用初始条件 $A(0) = A_0$、$B(0) = B_0$ 和 $V(0) = V_0$。时间 $t$ 的单位是小时（h），体积 $V$ 的单位是飞升（fL），浓度 $A$ 和 $B$ 的单位是微摩尔（$\\mu \\mathrm{M}$）。\n\n您的程序必须为每个测试用例计算在指定的最终时间 $T$（单位为小时）时的三元组 $[A(T), B(T), V(T)]$，给定参数 $g$、$q_A$、$k_1$、$k_2$ 和初始条件 $A_0$、$B_0$、$V_0$。所有报告的浓度单位必须是 $\\mu \\mathrm{M}$，细胞体积单位必须是 $\\mathrm{fL}$。每个测试用例的结果必须四舍五入到 $4$ 位小数。\n\n测试套件（每个元组为 $(g, q_A, k_1, k_2, T, A_0, B_0, V_0)$，单位为 $(\\mathrm{h}^{-1}, \\mu \\mathrm{M}\\cdot\\mathrm{h}^{-1}, \\mathrm{h}^{-1}, \\mathrm{h}^{-1}, \\mathrm{h}, \\mu \\mathrm{M}, \\mu \\mathrm{M}, \\mathrm{fL})$）：\n- 情况 1 (一般情况): $(0.2, 10.0, 1.0, 0.5, 5.0, 0.0, 0.0, 1.0)$。\n- 情况 2 (无增长，边界情况): $(0.0, 10.0, 1.0, 0.5, 5.0, 0.0, 0.0, 1.0)$。\n- 情况 3 (无生成，带有预载物料库的边缘情况): $(0.3, 0.0, 0.7, 0.4, 4.0, 5.0, 2.0, 1.5)$。\n- 情况 4 (快速增长，强稀释): $(1.0, 10.0, 1.0, 0.5, 3.0, 0.0, 0.0, 2.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果本身是一个包含三个浮点数的列表 $[A(T),B(T),V(T)]$，单位与规定一致，每个值都四舍五入到 $4$ 位小数。例如，包含两个用例的有效输出将类似于 $[[a_1,b_1,v_1],[a_2,b_2,v_2]]$，不含空格。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于化学动力学和系统生物学原理，作为一个可解的初值问题，其提法是适定的，并且没有歧义或矛盾。\n\n这个问题的核心是推导并求解一个常微分方程组（ODEs），该方程组描述了一个体积 $V(t)$ 呈指数增长的单细胞内两种分子物质 $A$ 和 $B$ 的浓度变化。\n\n**1. 控制方程的推导**\n\n控制变化体积 $V$ 中物质 $i$ 浓度 $C_i$ 的基本原理源于质量守恒。浓度定义为分子总数 $N_i$ 除以体积 $V$，即 $C_i(t) = N_i(t) / V(t)$。对时间 $t$ 应用商法则求导可得：\n$$\n\\frac{dC_i}{dt} = \\frac{d}{dt}\\left(\\frac{N_i}{V}\\right) = \\frac{1}{V}\\frac{dN_i}{dt} - \\frac{N_i}{V^2}\\frac{dV}{dt}\n$$\n问题陈述体积呈指数增长，$\\frac{dV}{dt} = gV$，其中 $g$ 是比增长速率。将此式与 $C_i = N_i/V$ 代入方程，得到：\n$$\n\\frac{dC_i}{dt} = \\frac{1}{V}\\frac{dN_i}{dt} - \\frac{C_i V}{V^2}(gV) = \\frac{1}{V}\\frac{dN_i}{dt} - gC_i\n$$\n这个方程是增长系统建模的基石。项 $\\frac{1}{V}\\frac{dN_i}{dt}$ 表示由生物化学反应引起的浓度变化率，而项 $-gC_i$ 表示因体积膨胀引起的物质稀释。\n\n问题以浓度速率（单位体积）的形式指定了反应动力学：\n- 对于物质 $A$：以恒定速率 $q_A$ 生成，并以 $-k_1 A$ 的速率进行一级反应转化为 $B$。\n- 对于物质 $B$：由 $A$ 以速率 $k_1 A$ 生成，并以速率 $-k_2 B$ 进行一级降解。\n\n这些对应于反应项 $\\frac{1}{V}\\frac{dN_i}{dt}$。我们现在可以构建完整的常微分方程组。\n\n对于体积 $V(t)$：\n$$\n\\frac{dV}{dt} = gV, \\quad V(0) = V_0\n$$\n对于浓度 $A(t)$：\n$$\n\\frac{dA}{dt} = \\underbrace{(q_A - k_1 A)}_{\\text{反应}} - \\underbrace{gA}_{\\text{稀释}} = q_A - (k_1 + g)A, \\quad A(0) = A_0\n$$\n对于浓度 $B(t)$：\n$$\n\\frac{dB}{dt} = \\underbrace{(k_1 A - k_2 B)}_{\\text{反应}} - \\underbrace{gB}_{\\text{稀释}} = k_1 A - (k_2 + g)B, \\quad B(0) = B_0\n$$\n这是一个由三个线性、一阶、常系数常微分方程组成的方程组。该系统适合采用精确的解析解法，与数值积分相比，解析解没有近似误差，因此更优。\n\n**2. 常微分方程组的解析解**\n\n这些方程是解耦的，或者可以依次求解。\n\n**体积 $V(t)$:**\n方程 $\\frac{dV}{dt} = gV$ 通过分离变量法求解，得到标准的指数增长公式：\n$$\nV(t) = V_0 e^{gt}\n$$\n\n**浓度 $A(t)$:**\n令 $K_A = k_1 + g$。常微分方程为 $\\frac{dA}{dt} + K_A A = q_A$。这是一个线性一阶常微分方程。假设 $K_A \\neq 0$（对于所有测试用例均为真，因为 $k_1 > 0$ 或 $g > 0$），解为：\n$$\nA(t) = \\frac{q_A}{K_A} + \\left(A_0 - \\frac{q_A}{K_A}\\right)e^{-K_A t}\n$$\n项 $\\frac{q_A}{K_A}$ 表示当时间趋于无穷大时将达到的稳态浓度 $A_{ss}$。\n\n**浓度 $B(t)$:**\n令 $K_B = k_2 + g$。常微分方程为 $\\frac{dB}{dt} + K_B B = k_1 A(t)$。这是另一个线性一阶常微分方程，但它是一个非齐次方程，带有时变强迫项 $k_1A(t)$。我们代入 $A(t)$ 的解并求解。\n\n求解方法取决于 $K_A$ 是否等于 $K_B$（即 $k_1 = k_2$）。对于提供的所有测试用例，都有 $k_1 \\neq k_2$，因此 $K_A \\neq K_B$。这种情况的通解可以使用积分因子法或等效方法（如“常数变易法”或“待定系数法”）推导得出。解的形式为 $B(t) = B_p(t) + B_h(t)$，其中 $B_h(t)$ 是齐次解，$B_p(t)$ 是特解。\n\n得到的 $B(t)$ 的解析解为：\n$$\nB(t) = C_1 + C_2 e^{-K_A t} + C_3 e^{-K_B t}\n$$\n其中系数 $C_1$、$C_2$ 和 $C_3$ 是由参数和初始条件决定的常数：\n$$\nC_1 = \\frac{k_1 q_A}{K_A K_B} = \\frac{k_1 q_A}{(k_1+g)(k_2+g)}\n$$\n$$\nC_2 = \\frac{k_1(A_0 - q_A/K_A)}{K_B - K_A} = \\frac{k_1(A_0(k_1+g) - q_A)}{(k_1+g)(k_2-k_1)}\n$$\n$$\nC_3 = B_0 - C_1 - C_2\n$$\n\n**3. 算法实现**\n\n程序将实现这些精确的解析解。对于每个测试用例，执行以下步骤：\n1.  提取参数 $g, q_A, k_1, k_2, T$ 和初始条件 $A_0, B_0, V_0$。\n2.  使用其解析公式计算 $V(T)$。\n3.  定义常数 $K_A = k_1 + g$ 和 $K_B = k_2 + g$。\n4.  使用其解析公式计算 $A(T)$。为增强稳健性，代码中包含了对 $K_A=0$ 的检查，尽管测试套件中并未要求。\n5.  计算 $B(t)$ 解的系数 $C_1$、$C_2$ 和 $C_3$。\n6.  使用其解析公式计算 $B(T)$。所有测试用例都满足 $k_1 \\neq k_2$，因此严格来说不需要 $k_1 = k_2$ 的特定公式，但考虑它是一种良好的编程实践。\n7.  计算出的 $A(T)$、$B(T)$ 和 $V(T)$ 值四舍五入到 4 位小数。\n8.  收集所有测试用例的结果，并按照问题要求格式化为单个字符串。\n\n这种方法确保了最高的精度和计算效率。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and simulates a mechanistic ODE model for an exponentially growing cell.\n    The solution is derived analytically and implemented to compute the state of the system\n    [A(T), B(T), V(T)] at a final time T for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (g, q_A, k_1, k_2, T, A_0, B_0, V_0)\n        (0.2, 10.0, 1.0, 0.5, 5.0, 0.0, 0.0, 1.0),\n        (0.0, 10.0, 1.0, 0.5, 5.0, 0.0, 0.0, 1.0),\n        (0.3, 0.0, 0.7, 0.4, 4.0, 5.0, 2.0, 1.5),\n        (1.0, 10.0, 1.0, 0.5, 3.0, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        g, q_A, k_1, k_2, T, A_0, B_0, V_0 = case\n\n        # 1. Solve for V(T)\n        V_T = V_0 * np.exp(g * T)\n\n        # 2. Solve for A(T)\n        K_A = k_1 + g\n        if K_A == 0:\n            # Handles the case g=0 and k1=0. A(t) grows linearly.\n            A_T = A_0 + q_A * T\n        else:\n            A_ss = q_A / K_A\n            A_T = A_ss + (A_0 - A_ss) * np.exp(-K_A * T)\n\n        # 3. Solve for B(T)\n        K_B = k_2 + g\n        \n        # Check for the special case k1 = k2, which implies K_A = K_B\n        if abs(k_1 - k_2) < 1e-9: # Use a tolerance for float comparison\n            if K_A == 0: # This implies k1=k2=g=0\n                # A(t) = A_0 + q_A*t\n                # dB/dt = 0, because k1=0\n                B_T = B_0\n            else:\n                A_ss = q_A / K_A\n                term1 = B_0 * np.exp(-K_A * T)\n                term2 = (k_1 * A_ss / K_A) * (1 - np.exp(-K_A * T))\n                term3 = k_1 * (A_0 - A_ss) * T * np.exp(-K_A * T)\n                B_T = term1 + term2 + term3\n        else:\n            # General case k1 != k2\n            if K_A == 0 or K_B == 0:\n                # This logic is more complex and not required by test cases.\n                # A full implementation would handle these edge cases.\n                # For this problem, we rely on test cases not hitting this.\n                # For instance, if K_A=0, A(t) is linear, integral for B is different.\n                # If K_B=0, integrating factor metod for B changes.\n                # We assume K_A, K_B != 0 for the general C1, C2, C3 formula.\n                pass\n            \n            C1 = (k_1 * q_A) / (K_A * K_B)\n            # Denominator is K_B - K_A = (k2+g) - (k1+g) = k2 - k1\n            C2 = (k_1 * (A_0 - q_A / K_A)) / (k_2 - k_1)\n            C3 = B_0 - C1 - C2\n            \n            B_T = C1 + C2 * np.exp(-K_A * T) + C3 * np.exp(-K_B * T)\n            \n        # Round results to 4 decimal places\n        A_T_rounded = round(A_T, 4)\n        B_T_rounded = round(B_T, 4)\n        V_T_rounded = round(V_T, 4)\n\n        results.append([A_T_rounded, B_T_rounded, V_T_rounded])\n\n    # Format the final output string to exactly match the requirement,\n    # which is a list of lists with no spaces.\n    # str(results) produces \"'[[...], [...]]'\", replace(\" \", \"\") removes spaces.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2411220"}, {"introduction": "磷酸化循环是细胞信号通路中最核心的基石之一，调控着无数生物过程。本练习将深入探讨一个“无效循环”（futile cycle）的动力学特性，您将使用Michaelis-Menten动力学来构建模型，并分析其稳态响应。通过这个实践，您将学会如何从数学上分析一个系统的稳定性，并判断其是否可能产生像双稳态这样的复杂行为。[@problem_id:2411269]", "problem": "要求您为一个蛋白质底物建立一个单位点无效循环模型，该底物可被不同的酶磷酸化和去磷酸化，并分析当激酶和磷酸酶的总量变化时是否会发生任何分岔。考虑一个底物有两种形式，未磷酸化的 $S$ 和磷酸化的 $S^{\\ast}$，以及酶激酶 $K$ 和磷酸酶 $F$。假设反应遵循质量作用定律，并且在准稳态近似下，磷酸化和去磷酸化的净速率由标准的米氏动力学速率捕获。设总底物由一个守恒定律固定，$S_{\\mathrm{T}} = [S] + [S^{\\ast}]$，其中 $[\\cdot]$ 表示浓度。设激酶和磷酸酶的总量分别为 $K_{\\mathrm{T}}$ 和 $F_{\\mathrm{T}}$。催化速率常数为 $k_{\\mathrm{cat},K}$ 和 $k_{\\mathrm{cat},F}$，米氏常数为 $K_{\\mathrm{M},K}$ 和 $K_{\\mathrm{M},F}$。所有浓度均以微摩尔（$\\mu \\mathrm{M}$）为单位，所有时间单位均以秒为单位。\n\n从基本定义（质量作用定律、酶-底物复合物形成、快速准稳态近似和组分守恒）出发，首先推导一个关于磷酸化分数 $y = [S^{\\ast}]/S_{\\mathrm{T}}$ 的一维常微分方程（ODE），该方程将 $dy/dt$ 表示为磷酸化和去磷酸化速率之差。您的推导必须对每个酶促步骤使用经过充分检验的准稳态下的米氏动力学速率公式以及守恒关系 $[S] = S_{\\mathrm{T}} - [S^{\\ast}]$。除了这些原则之外，不要先验地假设任何特定的函数形式。请通过用 $S_{\\mathrm{T}}$ 进行归一化来明确定义您引入的任何无量纲参数。\n\n然后，通过对推导出的 ODE 进行数学推理，确定 $K_{\\mathrm{T}}$ 和 $F_{\\mathrm{T}}$ 的变化是否会引起分岔，这里的分岔理解为在区间 $y \\in [0,1]$ 内稳态数量或稳定性的变化。您的推理必须基于推导出的 ODE 所蕴含的符号和单调性性质，而非外部文献。\n\n最后，实现一个程序，对于下面的每个测试用例，在固定的 $F_{\\mathrm{T}}$ 下，对一系列 $K_{\\mathrm{T}}$ 值进行数值计算以求解稳态，计算每个 $K_{\\mathrm{T}}$ 在 $y \\in [0,1]$ 中存在多少个不同的稳态，检查该计数是否在扫描范围内发生变化（这将指示分岔），并报告在扫描中观察到的最小和最大稳态磷酸化分数。请使用限制在 $y \\in [0,1]$ 区间内的稳健求根方法，并确保数值可靠性。将报告的磷酸化分数表示为四舍五入到三位小数的小数（因为 $y$ 是无量纲的，所以不需要单位）。本问题不涉及角度。\n\n测试套件（程序必须硬编码这些值并精确使用它们）：\n- 共同的底物总量 $S_{\\mathrm{T}} = 1.0\\,\\mu \\mathrm{M}$。\n- 测试用例1（平衡，中等饱和度）：$k_{\\mathrm{cat},K} = 1.0\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{cat},F} = 1.0\\,\\mathrm{s}^{-1}$，$K_{\\mathrm{M},K} = 0.2\\,\\mu \\mathrm{M}$，$K_{\\mathrm{M},F} = 0.2\\,\\mu \\mathrm{M}$，$F_{\\mathrm{T}} = 1.0\\,\\mu \\mathrm{M}$，在闭区间 $[0.2, 5.0]$ 上以 $121$ 个均匀间隔的值均匀扫描 $K_{\\mathrm{T}}$。\n- 测试用例2（零级反应区域）：$k_{\\mathrm{cat},K} = 1.0\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{cat},F} = 1.0\\,\\mathrm{s}^{-1}$，$K_{\\mathrm{M},K} = 0.01\\,\\mu \\mathrm{M}$，$K_{\\mathrm{M},F} = 0.01\\,\\mu \\mathrm{M}$，$F_{\\mathrm{T}} = 0.5\\,\\mu \\mathrm{M}$，在闭区间 $[0.01, 2.0]$ 上以 $121$ 个均匀间隔的值均匀扫描 $K_{\\mathrm{T}}$。\n- 测试用例3（不对称酶）：$k_{\\mathrm{cat},K} = 2.0\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{cat},F} = 0.5\\,\\mathrm{s}^{-1}$，$K_{\\mathrm{M},K} = 0.05\\,\\mu \\mathrm{M}$，$K_{\\mathrm{M},F} = 0.5\\,\\mu \\mathrm{M}$，$F_{\\mathrm{T}} = 1.5\\,\\mu \\mathrm{M}$，在闭区间 $[0.05, 3.0]$ 上以 $121$ 个均匀间隔的值均匀扫描 $K_{\\mathrm{T}}$。\n\n对于每个测试用例，您的程序必须按顺序输出一个包含以下四项的列表：\n- 在 $K_{\\mathrm{T}}$ 扫描中发现的不同稳态的最大数量（一个整数）。\n- 一个布尔值，指示稳态数量是否在扫描范围内发生变化（这是分岔指示器）。\n- 扫描范围内的最小稳态磷酸化分数 $y$ （一个四舍五入到三位小数的浮点数）。\n- 扫描范围内的最大稳态磷酸化分数 $y$ （一个四舍五入到三位小数的浮点数）。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个测试用例的结果，格式为由逗号分隔的列表的列表，并用方括号括起来。例如，带有占位符的输出看起来像 $[[1,\\mathrm{False},0.123,0.987],[1,\\mathrm{False},0.050,0.950],[1,\\mathrm{False},0.200,0.800]]$（这只是一个示例；您的实际数字必须来自您的计算）。", "solution": "对问题陈述进行验证。\n\n**第1步：提取给定条件**\n- **系统**：蛋白质底物的单位点无效循环。\n- **物种**：未磷酸化的底物 $S$，磷酸化的底物 $S^{\\ast}$，激酶 $K$，磷酸酶 $F$。\n- **反应**：$S$ 被 $K$ 磷酸化，$S^{\\ast}$ 被 $F$ 去磷酸化。\n- **动力学**：质量作用定律，准稳态近似，标准米氏动力学速率。\n- **守恒定律**：总底物 $S_{\\mathrm{T}} = [S] + [S^{\\ast}]$。\n- **变量**：\n    - 磷酸化分数：$y = [S^{\\ast}]/S_{\\mathrm{T}}$。\n- **参数**：\n    - 总底物浓度：$S_{\\mathrm{T}}$。\n    - 总激酶浓度：$K_{\\mathrm{T}}$。\n    - 总磷酸酶浓度：$F_{\\mathrm{T}}$。\n    - 激酶催化速率常数：$k_{\\mathrm{cat},K}$。\n    - 磷酸酶催化速率常数：$k_{\\mathrm{cat},F}$。\n    - 激酶米氏常数：$K_{\\mathrm{M},K}$。\n    - 磷酸酶米氏常数：$K_{\\mathrm{M},F}$。\n- **单位**：浓度为 $\\mu \\mathrm{M}$，时间为秒。\n- **任务1**：推导 $dy/dt$ 的一维常微分方程。\n- **任务2**：分析当 $K_{\\mathrm{T}}$ 和 $F_{\\mathrm{T}}$ 变化时，稳态的数量或稳定性发生分岔的可能性。\n- **任务3**：实现一个程序，对三个特定的测试用例进行数值计算以求解稳态并分析分岔。\n- **测试套件**：\n    - 共同参数：$S_{\\mathrm{T}} = 1.0\\,\\mu \\mathrm{M}$。\n    - 用例1：$k_{\\mathrm{cat},K} = 1.0\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{cat},F} = 1.0\\,\\mathrm{s}^{-1}$，$K_{\\mathrm{M},K} = 0.2\\,\\mu \\mathrm{M}$，$K_{\\mathrm{M},F} = 0.2\\,\\mu \\mathrm{M}$，$F_{\\mathrm{T}} = 1.0\\,\\mu \\mathrm{M}$，$K_{\\mathrm{T}} \\in [0.2, 5.0]$（$121$个点）。\n    - 用例2：$k_{\\mathrm{cat},K} = 1.0\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{cat},F} = 1.0\\,\\mathrm{s}^{-1}$，$K_{\\mathrm{M},K} = 0.01\\,\\mu \\mathrm{M}$，$K_{\\mathrm{M},F} = 0.01\\,\\mu \\mathrm{M}$，$F_{\\mathrm{T}} = 0.5\\,\\mu \\mathrm{M}$，$K_{\\mathrm{T}} \\in [0.01, 2.0]$（$121$个点）。\n    - 用例3：$k_{\\mathrm{cat},K} = 2.0\\,\\mathrm{s}^{-1}$，$k_{\\mathrm{cat},F} = 0.5\\,\\mathrm{s}^{-1}$，$K_{\\mathrm{M},K} = 0.05\\,\\mu \\mathrm{M}$，$K_{\\mathrm{M},F} = 0.5\\,\\mu \\mathrm{M}$，$F_{\\mathrm{T}} = 1.5\\,\\mu \\mathrm{M}$，$K_{\\mathrm{T}} \\in [0.05, 3.0]$（$121$个点）。\n- **输出格式**：对于每个用例，`[最大稳态数, 分岔布尔值, 最小y值, 最大y值]`。最终输出是这些列表的列表。\n\n**第2步：使用提取的给定条件进行验证**\n- **科学依据**：该问题使用米氏动力学描述了一个单位点酶促无效循环。这是系统生物学中的一个经典基础模型，最早由 Goldbeter 和 Koshland 进行了严谨的分析。它基于已确立的酶动力学原理。该问题具有科学合理性。\n- **适定性**：该问题为解析推导和数值计算提供了所有必要的参数和明确的目标。解的存在性和唯一性问题是解析任务的核心，这是一个有效的科学问题。该问题是适定的。\n- **客观性**：语言精确、量化，且不含主观性。它是计算生物学中的一个标准问题。\n- **完整性和一致性**：问题陈述是自洽的。数值计算部分的所有常数和边界条件都已指定。没有矛盾之处。\n- **真实性**：所提供的参数值在生物化学上是合理的。\n- **其他缺陷**：该问题不是隐喻性的、琐碎的、无法验证的或循环论证的。它完全属于系统生物学中 ODE 模型这一特定主题。\n\n**第3步：结论与行动**\n问题有效。将提供严谨的解答。\n\n**常微分方程的推导**\n\n该系统由两个相反的酶促反应组成：\n1.  底物 $S$ 在激酶 $K$ 的催化下磷酸化为 $S^{\\ast}$。\n2.  底物 $S^{\\ast}$ 在磷酸酶 $F$ 的催化下去磷酸化变回 $S$。\n\n在准稳态近似下，这些反应的净速率由米氏动力学描述。\n\n磷酸化速率 $v_{phos}$ 取决于其底物浓度 $[S]$ 和总激酶浓度 $K_{\\mathrm{T}}$。最大速率为 $V_{\\mathrm{max},K} = k_{\\mathrm{cat},K} K_{\\mathrm{T}}$。速率为：\n$$v_{phos} = \\frac{V_{\\mathrm{max},K} [S]}{K_{\\mathrm{M},K} + [S]} = \\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}} [S]}{K_{\\mathrm{M},K} + [S]}$$\n\n去磷酸化速率 $v_{dephos}$ 取决于其底物浓度 $[S^{\\ast}]$ 和总磷酸酶浓度 $F_{\\mathrm{T}}$。最大速率为 $V_{\\mathrm{max},F} = k_{\\mathrm{cat},F} F_{\\mathrm{T}}$。速率为：\n$$v_{dephos} = \\frac{V_{\\mathrm{max},F} [S^{\\ast}]}{K_{\\mathrm{M},F} + [S^{\\ast}]} = \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}} [S^{\\ast}]}{K_{\\mathrm{M},F} + [S^{\\ast}]}$$\n\n磷酸化形式 $[S^{\\ast}]$ 的浓度变化率是其生成速率与消耗速率之差：\n$$\\frac{d[S^{\\ast}]}{dt} = v_{phos} - v_{dephos}$$\n\n为了用磷酸化分数 $y = [S^{\\ast}]/S_{\\mathrm{T}}$ 来表示，我们使用守恒定律 $S_{\\mathrm{T}} = [S] + [S^{\\ast}]$。这意味着：\n$[S^{\\ast}] = y S_{\\mathrm{T}}$\n$[S] = S_{\\mathrm{T}} - [S^{\\ast}] = S_{\\mathrm{T}}(1-y)$\n\n将这些代入速率方程：\n$$\\frac{d(y S_{\\mathrm{T}})}{dt} = S_{\\mathrm{T}} \\frac{dy}{dt} = \\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}} S_{\\mathrm{T}}(1-y)}{K_{\\mathrm{M},K} + S_{\\mathrm{T}}(1-y)} - \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}} S_{\\mathrm{T}} y}{K_{\\mathrm{M},F} + S_{\\mathrm{T}} y}$$\n\n两边同除以常数 $S_{\\mathrm{T}}$，得到关于磷酸化分数 $y$ 的最终一维常微分方程：\n$$\\frac{dy}{dt} = \\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}} (1-y)}{K_{\\mathrm{M},K} + S_{\\mathrm{T}}(1-y)} - \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}} y}{K_{\\mathrm{M},F} + S_{\\mathrm{T}} y}$$\n\n按照要求，我们通过用 $S_{\\mathrm{T}}$ 进行归一化来定义无量纲米氏常数：\n$$J_K = \\frac{K_{\\mathrm{M},K}}{S_{\\mathrm{T}}} \\quad \\text{和} \\quad J_F = \\frac{K_{\\mathrm{M},F}}{S_{\\mathrm{T}}}$$\n使用这些参数，ODE 可以写成：\n$$\\frac{dy}{dt} = \\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}}}{S_{\\mathrm{T}}} \\frac{1-y}{J_K + 1-y} - \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}}}{S_{\\mathrm{T}}} \\frac{y}{J_F + y}$$\n\n**分岔分析**\n\n当 $\\frac{dy}{dt} = 0$ 时，系统达到稳态。这要求磷酸化和去磷酸化速率相等：\n$$v_{phos}(y) = v_{dephos}(y)$$\n$$\\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}} (1-y)}{K_{\\mathrm{M},K} + S_{\\mathrm{T}}(1-y)} = \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}} y}{K_{\\mathrm{M},F} + S_{\\mathrm{T}} y}$$\n$y \\in [0,1]$ 内的稳态数量对应于此方程解的数量。我们分析方程两边作为 $y$ 的函数的单调性。\n\n设 $V_1(y) = \\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}} (1-y)}{K_{\\mathrm{M},K} + S_{\\mathrm{T}}(1-y)}$。它关于 $y$ 的导数是：\n$$\\frac{dV_1}{dy} = k_{\\mathrm{cat},K} K_{\\mathrm{T}} \\frac{(-1)(K_{\\mathrm{M},K} + S_{\\mathrm{T}}(1-y)) - (1-y)(-S_{\\mathrm{T}})}{(K_{\\mathrm{M},K} + S_{\\mathrm{T}}(1-y))^2} = - \\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}} K_{\\mathrm{M},K}}{(K_{\\mathrm{M},K} + S_{\\mathrm{T}}(1-y))^2}$$\n由于所有参数（$k_{\\mathrm{cat},K}, K_{\\mathrm{T}}, K_{\\mathrm{M},K}, S_{\\mathrm{T}}$）都为正，对于所有 $y \\in [0,1]$，都有 $\\frac{dV_1}{dy} < 0$。因此，$V_1(y)$ 是 $y$ 的严格单调递减函数。\n\n设 $V_2(y) = \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}} y}{K_{\\mathrm{M},F} + S_{\\mathrm{T}} y}$。它关于 $y$ 的导数是：\n$$\\frac{dV_2}{dy} = k_{\\mathrm{cat},F} F_{\\mathrm{T}} \\frac{(1)(K_{\\mathrm{M},F} + S_{\\mathrm{T}}y) - y(S_{\\mathrm{T}})}{(K_{\\mathrm{M},F} + S_{\\mathrm{T}}y)^2} = \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}} K_{\\mathrm{M},F}}{(K_{\\mathrm{M},F} + S_{\\mathrm{T}}y)^2}$$\n由于所有参数都为正，对于所有 $y \\in [0,1]$，都有 $\\frac{dV_2}{dy} > 0$。因此，$V_2(y)$ 是 $y$ 的严格单调递增函数。\n\n一个严格递减函数和一个严格递增函数最多只能相交一次。\n- 在 $y=0$ 处：$V_1(0) = \\frac{k_{\\mathrm{cat},K} K_{\\mathrm{T}}}{K_{\\mathrm{M},K} + S_{\\mathrm{T}}} > 0$ 且 $V_2(0) = 0$。所以，$V_1(0) > V_2(0)$。\n- 在 $y=1$ 处：$V_1(1) = 0$ 且 $V_2(1) = \\frac{k_{\\mathrm{cat},F} F_{\\mathrm{T}}}{K_{\\mathrm{M},F} + S_{\\mathrm{T}}} > 0$。所以，$V_1(1) < V_2(1)$。\n\n根据介值定理，在区间 $(0,1)$ 内必须至少存在一个交点。鉴于严格的单调性，这个交点是唯一的。因此，对于任何一组正的参数 $K_{\\mathrm{T}}$ 和 $F_{\\mathrm{T}}$，总是存在且仅存在一个稳态。由于稳态的数量不能改变，因此其数量上不会发生分岔。\n\n接下来，我们检查稳定性。设 $f(y) = \\frac{dy}{dt} = V_1(y) - V_2(y)$。如果 $f'(y_{ss}) < 0$，稳态 $y_{ss}$ 是稳定的；如果 $f'(y_{ss}) > 0$，则是不稳定的。\n导数是 $f'(y) = \\frac{dV_1}{dy} - \\frac{dV_2}{dy}$。\n正如我们已经证明的，$\\frac{dV_1}{dy}$ 总是负的，而 $\\frac{dV_2}{dy}$ 总是正的。\n因此，$f'(y) = (\\text{负值}) - (\\text{正值}) < 0$ 对于所有 $y \\in [0,1]$。\n这证明了唯一的稳态总是稳定的。\n\n结论：在该系统中，$K_{\\mathrm{T}}$ 和 $F_{\\mathrm{T}}$ 的变化不会引起分岔（稳态数量或稳定性的变化）。稳态的数量始终为一个，并且这个稳态始终是稳定的。数值计算的目的是量化这个单一稳态对参数变化的响应，并验证这一解析结论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the futile cycle problem by deriving the ODE, analyzing bifurcations,\n    and numerically computing steady states for given test cases.\n    \"\"\"\n    \n    # Common parameter for all test cases\n    S_T = 1.0  # micromolar\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"k_cat_K\": 1.0, \"k_cat_F\": 1.0, \"K_M_K\": 0.2, \"K_M_F\": 0.2, \"F_T\": 1.0,\n            \"K_T_range\": np.linspace(0.2, 5.0, 121)\n        },\n        {\n            \"k_cat_K\": 1.0, \"k_cat_F\": 1.0, \"K_M_K\": 0.01, \"K_M_F\": 0.01, \"F_T\": 0.5,\n            \"K_T_range\": np.linspace(0.01, 2.0, 121)\n        },\n        {\n            \"k_cat_K\": 2.0, \"k_cat_F\": 0.5, \"K_M_K\": 0.05, \"K_M_F\": 0.5, \"F_T\": 1.5,\n            \"K_T_range\": np.linspace(0.05, 3.0, 121)\n        }\n    ]\n\n    # This function represents the ODE's right-hand side, dy/dt = 0 at steady state.\n    def steady_state_eq(y, K_T, F_T, k_cat_K, k_cat_F, K_M_K, K_M_F, S_T):\n        \"\"\"\n        Calculates the net rate of change of the phosphorylated fraction y.\n        A root of this function is a steady state.\n        \"\"\"\n        v_phos = (k_cat_K * K_T * (1 - y)) / (K_M_K + S_T * (1 - y))\n        v_dephos = (k_cat_F * F_T * y) / (K_M_F + S_T * y)\n        return v_phos - v_dephos\n\n    results = []\n    for case in test_cases:\n        ss_counts_per_KT = []\n        ss_values_per_KT = []\n\n        # Scan across the specified range of total kinase concentration K_T\n        for K_T_val in case[\"K_T_range\"]:\n            # Define arguments for the steady-state equation\n            args = (\n                K_T_val, case[\"F_T\"], case[\"k_cat_K\"], case[\"k_cat_F\"],\n                case[\"K_M_K\"], case[\"K_M_F\"], S_T\n            )\n            \n            # Find the steady-state root y in the valid interval [0, 1].\n            # Based on analytical derivation, there is always exactly one root.\n            # We use a robust root-finding algorithm confined to this interval.\n            sol = root_scalar(steady_state_eq, args=args, bracket=[0.0, 1.0], method='brentq')\n            \n            if sol.converged:\n                # The problem asks to count distinct steady states. \n                # Our analysis and the root finder confirm there is only one.\n                ss_counts_per_KT.append(1)\n                ss_values_per_KT.append(sol.root)\n            else:\n                # This should not happen based on the analytical proof.\n                ss_counts_per_KT.append(0)\n\n        # Post-process results for the current test case\n        max_ss_count = max(ss_counts_per_KT) if ss_counts_per_KT else 0\n        \n        # A bifurcation is detected if the number of steady states changes.\n        bifurcation_found = False\n        if len(set(ss_counts_per_KT)) > 1:\n            bifurcation_found = True\n\n        if ss_values_per_KT:\n            min_y = np.min(ss_values_per_KT)\n            max_y = np.max(ss_values_per_KT)\n        else:\n            min_y = 0.0\n            max_y = 0.0\n\n        results.append([max_ss_count, bifurcation_found, min_y, max_y])\n    \n    # Format the final output string to match the problem specification precisely,\n    # including trailing zeros for floats.\n    output_parts = []\n    for res in results:\n        # res[0] is max_ss_count (int)\n        # res[1] is bifurcation_found (bool)\n        # res[2] is min_y (float)\n        # res[3] is max_y (float)\n        part = f\"[{res[0]},{res[1]},{res[2]:.3f},{res[3]:.3f}]\"\n        output_parts.append(part)\n\n    final_output_str = f\"[{','.join(output_parts)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2411269"}, {"introduction": "系统生物学的最终目标之一是能够设计和构建具有特定功能的生物回路，就像工程师设计电子电路一样。本练习将带您进入合成生物学的世界，模拟一个旨在实现“带通滤波器”功能的基因回路，即输出仅在输入信号处于中等水平时才被激活。您将探索一种被称为非相干前馈环路（Incoherent Feed-Forward Loop）的网络基序，是如何通过其拓扑结构来产生这种精巧的非单调响应。[@problem_id:2411191]", "problem": "一个合成基因线路被设计用于实现一个带通滤波器：报告物种仅对外源输入 $I$ 的中等水平产生强响应，而对极低或极高水平的 $I$ 响应较弱。考虑以下具有三个状态变量的常微分方程 (ODE) 模型：$A(t)$ (激活物)，$R(t)$ (阻遏物) 和 $Y(t)$ (报告蛋白)。输入 $I$ 是一个恒定的外源信号。所有浓度单位均为纳摩尔 (nM)，时间单位为分钟 (min)。参数单位如下：生成速率为 nM/min，降解速率为 $1/\\text{min}$，希尔常数为 nM，希尔系数为无量纲。\n\n该模型为\n$$\n\\frac{dA}{dt} \\;=\\; k_a \\,\\frac{I^{n}}{K_a^{n} + I^{n}} \\;-\\; d_a\\,A,\n$$\n$$\n\\frac{dR}{dt} \\;=\\; k_r \\,\\frac{I^{m}}{K_r^{m} + I^{m}} \\;-\\; d_r\\,R,\n$$\n$$\n\\frac{dY}{dt} \\;=\\; k_y \\,\\frac{A^{p}}{K_y^{p} + A^{p}} \\;\\cdot\\; \\frac{K_i^{q}}{K_i^{q} + R^{q}} \\;-\\; d_y\\,Y.\n$$\n\n在此模型中，$I$ 通过指数为 $n$ 和 $m$ 的 S 型希尔函数激活 $A$ 和 $R$，$A$ 通过希尔指数 $p$ 激活 $Y$，而 $R$ 通过一个递减的希尔因子（希尔指数为 $q$）抑制 $Y$。假设初始条件为 $A(0)=0\\,\\text{nM}$，$R(0)=0\\,\\text{nM}$ 和 $Y(0)=0\\,\\text{nM}$。对于任意固定的常数 $I$，将稳态报告蛋白浓度 $Y^\\ast(I)$ 定义为当 $t \\to \\infty$ 时 $Y(t)$ 的极限。\n\n你的任务是，对于下面列出的每一组参数，在一个指定的输入值网格上确定稳态报告蛋白响应 $Y^\\ast(I)$，并提取表征带通行为的汇总统计量。你必须使用输入网格\n$$\nI \\in \\{\\,0,10,20,\\dots,500\\,\\}\\ \\text{nM},\n$$\n该网格包含从 $0$ 到 $500$ nM (包含两端) 的 $51$ 个均匀间隔点。\n\n对于每组参数，计算：\n- 在网格上每个 $I$ 对应的稳态值 $Y^\\ast(I)$，\n- 在网格内使 $Y^\\ast(I)$ 最大化的输入值 $I_{\\text{peak}}$ (单位 nM) (如果在数值精度范围内有多个值达到相同的最大值，则选择网格中最小的 $I$ 值)，\n- 对应的最大值 $Y_{\\text{peak}} = \\max_I Y^\\ast(I)$ (单位 nM)，\n- $Y^\\ast(0)$ 和 $Y^\\ast(500)$ 的值 (单位 nM)。\n\n使用以下参数集测试套件 (单位如上所述)：\n\n- 测试用例 1:\n  - $k_a = 50$, $d_a = 1$, $K_a = 50$, $n = 2$;\n  - $k_r = 40$, $d_r = 1$, $K_r = 80$, $m = 2$;\n  - $k_y = 120$, $d_y = 1$, $K_y = 30$, $p = 2$;\n  - $K_i = 60$, $q = 2$.\n\n- 测试用例 2:\n  - $k_a = 50$, $d_a = 1$, $K_a = 40$, $n = 2$;\n  - $k_r = 120$, $d_r = 1.5$, $K_r = 50$, $m = 3$;\n  - $k_y = 120$, $d_y = 1$, $K_y = 25$, $p = 2$;\n  - $K_i = 30$, $q = 2$.\n\n- 测试用例 3:\n  - $k_a = 60$, $d_a = 1$, $K_a = 40$, $n = 2$;\n  - $k_r = 10$, $d_r = 1$, $K_r = 100$, $m = 2$;\n  - $k_y = 120$, $d_y = 1$, $K_y = 30$, $p = 2$;\n  - $K_i = 10000$, $q = 1$.\n\n所有报告的数值中，浓度单位必须为纳摩尔 (nM)，输入 $I$ 的单位也必须为纳摩尔 (nM)。将最终输出中的每个数字四舍五入到 $3$ 位小数。\n\n最终输出格式：你的程序应生成一个单行输出，其中包含一个由方括号括起来的逗号分隔的扁平列表。该列表必须按顺序包含测试用例 1、测试用例 2、然后是测试用例 3 的四元组\n$$\n\\big[\\,I_{\\text{peak}},\\ Y_{\\text{peak}},\\ Y^\\ast(0),\\ Y^\\ast(500)\\,\\big]\n$$\n每个测试的结果依次连接成一个扁平列表。例如，输出必须看起来像\n$$\n[\\ I_{\\text{peak},1},\\ Y_{\\text{peak},1},\\ Y^\\ast_1(0),\\ Y^\\ast_1(500),\\ I_{\\text{peak},2},\\ \\dots,\\ I_{\\text{peak},3},\\ \\dots\\ ],\n$$\n其中每个数字都四舍五入到 $3$ 位小数，且没有额外文本。", "solution": "此问题已经过验证。\n\n**步骤 1：提取已知信息**\n- **模型方程：**\n$$\n\\frac{dA}{dt} \\;=\\; k_a \\,\\frac{I^{n}}{K_a^{n} + I^{n}} \\;-\\; d_a\\,A\n$$\n$$\n\\frac{dR}{dt} \\;=\\; k_r \\,\\frac{I^{m}}{K_r^{m} + I^{m}} \\;-\\; d_r\\,R\n$$\n$$\n\\frac{dY}{dt} \\;=\\; k_y \\,\\frac{(A^\\ast)^{p}}{K_y^{p} + (A^\\ast)^{p}} \\;\\cdot\\; \\frac{K_i^{q}}{K_i^{q} + (R^\\ast)^{q}} \\;-\\; d_y\\,Y\n$$\n- **状态变量与输入：** $A(t)$、$R(t)$、$Y(t)$ 和一个恒定输入 $I$。\n- **初始条件：** $A(0)=0$, $R(0)=0$, $Y(0)=0$。\n- **目标：** 对于固定的 $I$，求稳态浓度 $Y^\\ast(I) = \\lim_{t \\to \\infty} Y(t)$。\n- **输入网格：** $I \\in \\{0, 10, 20, \\dots, 500\\}$。\n- **任务：** 对每组参数，计算 $I_{\\text{peak}}$、$Y_{\\text{peak}}$、$Y^\\ast(0)$ 和 $Y^\\ast(500)$。\n- **参数组：** 提供了三个不同的测试用例，包含所有必需的参数值 ($k_a, d_a, K_a, n, k_r, d_r, K_r, m, k_y, d_y, K_y, p, K_i, q$)。\n\n**步骤 2：使用提取的已知信息进行验证**\n该问题具有科学依据，采用了基于希尔动力学的标准常微分方程 (ODE) 模型，这是系统生物学中描述基因调控的基石。该模型代表了一种 I 型非相干前馈环，这是一个被充分研究的网络基序。该问题是适定 (well-posed) 的：任务是计算系统的稳态，该稳态由一组从 ODE 推导出的代数方程唯一确定，然后对这些稳态值在一个离散的输入网格上进行简单分析。该问题是客观、自洽且内部一致的，提供了所有必要的参数和规范。参数在合成生物学的物理合理范围内。未发现任何缺陷。\n\n**步骤 3：结论与行动**\n该问题是**有效**的。将提供一个解决方案。\n\n问题的核心是确定物种 $A$、$R$ 和 $Y$ 的稳态浓度作为输入信号 $I$ 的函数。稳态由所有时间导数均为零的条件定义。\n令 $\\frac{dA}{dt} = 0$、$\\frac{dR}{dt} = 0$ 和 $\\frac{dY}{dt} = 0$，我们得到了一个关于稳态浓度（记为 $A^\\ast$、$R^\\ast$ 和 $Y^\\ast$）的代数方程组。\n\n从 $A$ 的方程中，我们得到：\n$$\nk_a \\,\\frac{I^{n}}{K_a^{n} + I^{n}} \\;-\\; d_a\\,A^\\ast = 0 \\quad \\implies \\quad A^\\ast(I) = \\frac{k_a}{d_a} \\frac{I^{n}}{K_a^{n} + I^{n}}\n$$\n类似地，从 $R$ 的方程中：\n$$\nk_r \\,\\frac{I^{m}}{K_r^{m} + I^{m}} \\;-\\; d_r\\,R^\\ast = 0 \\quad \\implies \\quad R^\\ast(I) = \\frac{k_r}{d_r} \\frac{I^{m}}{K_r^{m} + I^{m}}\n$$\n$A^\\ast$和$R^\\ast$的稳态表达式仅取决于输入 $I$ 及其各自的参数。这些表达式可以代入 $Y$ 的稳态方程中：\n$$\nk_y \\,\\frac{(A^\\ast)^{p}}{K_y^{p} + (A^\\ast)^{p}} \\;\\cdot\\; \\frac{K_i^{q}}{K_i^{q} + (R^\\ast)^{q}} \\;-\\; d_y\\,Y^\\ast = 0\n$$\n解出 $Y^\\ast$ 可得到其对 $A^\\ast$ 和 $R^\\ast$ 的依赖关系，从而也间接得到了其对 $I$ 的依赖关系：\n$$\nY^\\ast(I) = \\frac{k_y}{d_y} \\left( \\frac{(A^\\ast(I))^{p}}{K_y^{p} + (A^\\ast(I))^{p}} \\right) \\left( \\frac{K_i^{q}}{K_i^{q} + (R^\\ast(I))^{q}} \\right)\n$$\n这些代数方程提供了一种直接且计算高效的方法来计算任何给定输入 $I$ 下的稳态响应 $Y^\\ast$，从而无需对 ODE 进行数值积分。\n\n计算策略如下：\n1.  对三个测试用例中的每一个，使用给定的参数组。\n2.  按规定生成 $I$ 的输入网格：$I = \\{0, 10, 20, \\dots, 500\\}$。\n3.  对于网格中的每个 $I$ 值，使用推导出的代数公式计算稳态浓度 $A^\\ast(I)$、$R^\\ast(I)$ 和 $Y^\\ast(I)$。这通过使用向量化操作来实现以提高效率。\n4.  对得到的 $Y^\\ast$ 值数组进行分析，以找到所需的统计量：\n    -   $Y_{\\text{peak}}$ 是 $Y^\\ast$ 数组中的最大值。\n    -   $I_{\\text{peak}}$ 是网格中对应于首次出现 $Y_{\\text{peak}}$ 的 $I$ 值。\n    -   $Y^\\ast(0)$ 是 $Y^\\ast$ 数组的第一个元素，对应于 $I=0$。\n    -   $Y^\\ast(500)$ 是 $Y^\\ast$ 数组的最后一个元素，对应于 $I=500$。\n5.  每个测试用例得到的四个值——$I_{\\text{peak}}$、$Y_{\\text{peak}}$、$Y^\\ast(0)$、$Y^\\ast(500)$——被收集并格式化为一个单一的扁平列表，数值四舍五入到三位小数。\n\n此过程是确定性的，并直接满足了问题陈述的所有要求。该模型的结构（一个非相干前馈环）预期在阻遏物分支足够强且在比激活物分支更高的输入水平下被激活的参数组（测试用例 1 和 2）中产生带通行为。对于测试用例 3，抑制作用被设计为可忽略不计（$K_i$ 非常大），这应导致一个简单的低通（饱和）响应，其中峰值输出在最大输入水平下出现。这为实现提供了一个逻辑上的检验。在 $I=0$ 时，$A^\\ast(0)=0$ 且 $R^\\ast(0)=0$，导致所有情况下 $Y^\\ast(0) = 0$，因为 $Y$ 的激活项变为零。这可作为另一个基本检验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the synthetic gene circuit problem by calculating steady-state responses\n    for three different parameter sets and extracting summary statistics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            # k_a, d_a, K_a, n\n            'activator': (50.0, 1.0, 50.0, 2.0),\n            # k_r, d_r, K_r, m\n            'repressor': (40.0, 1.0, 80.0, 2.0),\n            # k_y, d_y, K_y, p\n            'reporter':  (120.0, 1.0, 30.0, 2.0),\n            # K_i, q\n            'inhibition': (60.0, 2.0)\n        },\n        # Test Case 2\n        {\n            'activator': (50.0, 1.0, 40.0, 2.0),\n            'repressor': (120.0, 1.5, 50.0, 3.0),\n            'reporter':  (120.0, 1.0, 25.0, 2.0),\n            'inhibition': (30.0, 2.0)\n        },\n        # Test Case 3\n        {\n            'activator': (60.0, 1.0, 40.0, 2.0),\n            'repressor': (10.0, 1.0, 100.0, 2.0),\n            'reporter':  (120.0, 1.0, 30.0, 2.0),\n            'inhibition': (10000.0, 1.0)\n        }\n    ]\n\n    # Define the input grid for I.\n    I_grid = np.arange(0, 501, 10, dtype=float)\n    \n    # Store all results in a flat list.\n    all_results = []\n\n    for params in test_cases:\n        # Unpack parameters for clarity.\n        k_a, d_a, K_a, n = params['activator']\n        k_r, d_r, K_r, m = params['repressor']\n        k_y, d_y, K_y, p = params['reporter']\n        K_i, q = params['inhibition']\n\n        # --- Calculate steady-state concentrations using vectorized numpy operations ---\n        \n        # Calculate A*(I)\n        I_n = np.power(I_grid, n)\n        Ka_n = K_a**n\n        # Add a small epsilon to the denominator to prevent division by zero at I=0 if K_a=0\n        A_ss = (k_a / d_a) * (I_n / (Ka_n + I_n + 1e-12))\n        \n        # Calculate R*(I)\n        I_m = np.power(I_grid, m)\n        Kr_m = K_r**m\n        R_ss = (k_r / d_r) * (I_m / (Kr_m + I_m + 1e-12))\n        \n        # Calculate Y*(I)\n        A_ss_p = np.power(A_ss, p)\n        Ky_p = K_y**p\n        activation_term = A_ss_p / (Ky_p + A_ss_p + 1e-12)\n\n        R_ss_q = np.power(R_ss, q)\n        Ki_q = K_i**q\n        repression_term = Ki_q / (Ki_q + R_ss_q + 1e-12)\n        \n        Y_ss_values = (k_y / d_y) * activation_term * repression_term\n\n        # --- Extract summary statistics ---\n        \n        # Find Y_peak and I_peak. np.argmax returns the index of the first maximum.\n        Y_peak = np.max(Y_ss_values)\n        peak_index = np.argmax(Y_ss_values)\n        I_peak = I_grid[peak_index]\n\n        # Get Y*(0) and Y*(500) from the computed array.\n        Y_ss_0 = Y_ss_values[0]\n        Y_ss_500 = Y_ss_values[-1]\n\n        # Append the quadruple to the list of all results.\n        all_results.extend([I_peak, Y_peak, Y_ss_0, Y_ss_500])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{x:.3f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2411191"}]}