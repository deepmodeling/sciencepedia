{"hands_on_practices": [{"introduction": "在分析任何网络时，第一步都是量化其基本属性。节点“度”（degree）是网络中最基本的属性，它表示一个节点拥有的连接数。本练习将通过一个小型蛋白质相互作用网络的实例，帮助你练习从原始互作列表中计算每个节点的度，并进一步计算一个简单的异质性指标，从而让你对网络结构有初步的量化认识。[@problem_id:1464939]", "problem": "一位系统生物学家正在研究一个由七种蛋白质组成的新表征的小型调控网络，我们将其标记为P1至P7。来自酵母双杂交筛选的实验数据已经确定了这些蛋白质之间的一系列物理相互作用。这些相互作用被认为是无向的，意味着蛋白质A和蛋白质B之间的相互作用是两者共享的单个连接。观察到的完整相互作用列表如下：\n\nP1 与 P2 相互作用\nP1 与 P3 相互作用\nP1 与 P4 相互作用\nP2 与 P5 相互作用\nP3 与 P4 相互作用\nP3 与 P6 相互作用\nP4 与 P7 相互作用\nP5 与 P6 相互作用\nP6 与 P7 相互作用\n\n在网络分析中，一个基本属性是节点的度，即它所具有的连接数。为了表征该网络的异质性，我们可以将连接最多的节点（枢纽节点）与平均连通性进行比较。计算该网络中最大度与网络平均度的比率。答案请四舍五入至三位有效数字。", "solution": "该网络有七个节点，标记为$P1$到$P7$，相互作用是无向边。根据给定的相互作用，通过计算每个节点的关联边数来确定其度：\n$$\\deg(P1)=3,\\ \\deg(P2)=2,\\ \\deg(P3)=3,\\ \\deg(P4)=3,\\ \\deg(P5)=2,\\ \\deg(P6)=3,\\ \\deg(P7)=2$$\n因此，最大度为\n$$d_{\\max}=3$$\n边的总数为 $m=9$。根据握手引理，度数之和等于 $2m$，因此 $n=7$ 个节点的平均度为\n$$\\bar{d}=\\frac{1}{n}\\sum_{i=1}^{n}\\deg(P_{i})=\\frac{2m}{n}=\\frac{2\\times 9}{7}=\\frac{18}{7}$$\n因此，所求的最大度与平均度的比率为\n$$r=\\frac{d_{\\max}}{\\bar{d}}=\\frac{3}{18/7}=\\frac{7}{6}\\approx 1.166\\ldots$$\n四舍五入到三位有效数字，结果是 $1.17$。", "answer": "$$\\boxed{1.17}$$", "id": "1464939"}, {"introduction": "无尺度网络并非随机形成，它们的生长遵循着特定的规则，其中最著名的就是“择优连接”（preferential attachment）或“富者愈富”原则。这个思想实验将此生长过程简化为一个清晰的定量问题，让你能够亲手计算连接概率，从而深入理解无尺度网络形成的核心驱动力。[@problem_id:1705406]", "problem": "在网络理论的研究中，许多现实世界网络（如引文网络或万维网）的增长可以通过一个称为优先连接的过程来建模。考虑一个由五篇奠基性论文组成的小型、孤立的引文网络。每篇论文的重要性由其“度”来量化，这个“度”代表了它在该网络中的连接数。这五篇论文的度分别为 $4, 3, 2, 2,$ 和 $1$。\n\n一篇新的研究论文正在撰写中，它将引用这五篇奠基性论文中的一篇。该引用过程的模型指出，新论文与任何一篇给定奠基性论文相连接的概率与该奠基性论文的度成正比。\n\n计算新论文引用现有网络中最具影响力论文（即度为4的那篇）的概率。将你的答案表示为一个最简分数。", "solution": "根据优先连接模型，新论文引用某一篇给定奠基性论文的概率与该论文的度成正比。设这些论文的度为 $k_{1}=4$, $k_{2}=3$, $k_{3}=2$, $k_{4}=2$, 和 $k_{5}=1$。总度数是所有度数的和\n$$\n\\sum_{i=1}^{5} k_{i} = 4+3+2+2+1 = 12.\n$$\n引用度为 $4$ 的论文的概率是\n$$\nP = \\frac{k_{1}}{\\sum_{i=1}^{5} k_{i}} = \\frac{4}{12} = \\frac{1}{3}.\n$$\n因此，所求概率为最简分数 $\\frac{1}{3}$。", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "1705406"}, {"introduction": "理论如何指导实践？择优连接原则不仅是一个解释网络如何增长的理论模型，更是一个可以用来开发强大算法的实用工具，例如在不完整的生物网络数据中预测缺失的相互作用。本练习将挑战你基于择优连接原则实现一个链接预测算法，该算法的核心思想是两个节点的度 $k_u$ 和 $k_v$ 越高，它们之间存在连接的可能性就越大。通过这个实践，你将体验到如何将理论知识转化为解决实际生物信息学问题的计算方法。[@problem_id:2428013]", "problem": "给定一个无向简单图，它代表一个不完整的蛋白质-蛋白质相互作用（PPI）网络。假设其底层的完整网络是无标度的，其度分布近似服从幂律。在此假设下，使用一个基于度的连接可能性模型，其中对于任何未被观测为边的无序节点对 $\\{u,v\\}$，其链接可能性得分定义为 $S(u,v) = k_u \\cdot k_v$，其中 $k_u$ 和 $k_v$ 是从观测到的（不完整的）图中计算出的度。该图没有自环，也没有多重边。节点由从 $0$ 到 $N-1$（含）的整数标记。对未观测到的节点对进行排序时，首先按 $S(u,v)$ 降序排序；若得分相同，则必须按 $(u,v)$（其中 $u<v$）的升序字典序来打破平局。\n\n对于每个测试用例，给定：\n- 节点数 $N$。\n- 观测到的边集 $E_{\\mathrm{obs}} \\subseteq \\{\\{u,v\\} \\mid 0 \\le u < v \\le N-1\\}$。\n- 真实的边集 $E_{\\mathrm{true}} \\subseteq \\{\\{u,v\\} \\mid 0 \\le u < v \\le N-1\\}$，它代表与同一节点集一致的底层完整网络。真实的缺失边集为 $E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}}$。\n- 一个整数 $L \\ge 1$。\n\n对于每个测试用例：\n1. 根据 $E_{\\mathrm{obs}}$ 计算每个节点 $u$ 的度 $k_u$。\n2. 枚举所有满足 $0 \\le u < v \\le N-1$ 且 $\\{u,v\\} \\notin E_{\\mathrm{obs}}$ 的无序节点对 $\\{u,v\\}$，并计算其得分 $S(u,v) = k_u \\cdot k_v$。\n3. 按 $S(u,v)$ 降序对所有未观测到的节点对进行排序，若得分相同，则按 $(u,v)$（其中 $u<v$）的升序字典序打破平局。\n4. 从此排序中选择前 $L$ 个节点对作为预测的边。\n5. 该测试用例的结果为这前 $L$ 个预测的节点对中有多少个存在于 $E_{\\mathrm{miss}}$ 中的整数计数。\n\n您的程序必须处理以下测试套件并输出结果：\n\n- 测试用例 A：\n  - $N = 6$\n  - $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(0,3),(1,2),(4,5)\\}$\n  - $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(2,3),(4,5)\\}$\n  - $L = 2$\n\n- 测试用例 B：\n  - $N = 6$\n  - $E_{\\mathrm{obs}} = \\{(0,1),(1,2),(3,4)\\}$\n  - $E_{\\mathrm{true}} = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$\n  - $L = 3$\n\n- 测试用例 C：\n  - $N = 5$\n  - $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(1,2)\\}$\n  - $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(1,2),(2,3)\\}$\n  - $L = 4$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 A、B、C 的顺序列出结果。列表元素必须是整数。例如：“[a,b,c]”，其中 $a$、$b$ 和 $c$ 分别是测试用例 A、测试用例 B 和测试用例 C 的整数结果。", "solution": "在尝试任何解决方案之前，首先对问题陈述进行验证。\n\n**问题验证**\n\n**步骤1：提取的已知条件**\n- 一个无向简单图代表一个不完整的蛋白质-蛋白质相互作用（PPI）网络。\n- 假设其底层的完整网络是无标度的。\n- 对于一个未观测到的无序节点对 $\\{u,v\\}$，其链接可能性得分定义为 $S(u,v) = k_u \\cdot k_v$，其中 $k_u$ 和 $k_v$ 是从观测图中计算出的度。\n- 节点由从 $0$ 到 $N-1$ 的整数标记。\n- 未观测到的节点对按得分 $S(u,v)$ 降序排序，若得分相同，则按 $(u,v)$ （其中 $u<v$）的升序字典序打破平局。\n- 每个测试用例的输入：节点数 $N$、观测到的边集 $E_{\\mathrm{obs}}$、真实的边集 $E_{\\mathrm{true}}$ 和一个整数 $L \\ge 1$。\n- 缺失边集为 $E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}}$。\n- 任务是找出排名前 $L$ 的节点对中有多少个是正确预测的缺失边。\n- 测试用例数据：\n    - 测试用例 A：$N = 6$, $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(0,3),(1,2),(4,5)\\}$, $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(2,3),(4,5)\\}$, $L = 2$。\n    - 测试用例 B：$N = 6$, $E_{\\mathrm{obs}} = \\{(0,1),(1,2),(3,4)\\}$, $E_{\\mathrm{true}} = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, $L = 3$。\n    - 测试用例 C：$N = 5$, $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(1,2)\\}$, $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(1,2),(2,3)\\}$, $L = 4$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在网络科学和计算生物学领域有坚实的基础。所描述的任务被称为“链接预测”。PPI 网络是无标度的这一假设是该领域的主流假说。使用像 $S(u,v) = k_u \\cdot k_v$ 这样的基于度的得分直接反映了优先连接原则，这是无标度网络增长的核心机制。该评分函数是一种成熟的启发式方法（称为度乘积或优先连接指数）。\n- **适定性**：该问题的规定具有数学上的精确性。所有输入都已定义，评分函数是明确的，打破平局的规则也是明确无歧义的。这确保了每个测试用例都存在一个单一的、确定性的整数结果。\n- **客观性**：问题陈述没有主观或模糊的语言。它是一个形式化的算法挑战。\n- **完整性与一致性**：为每个测试用例提供了所有必要的数据（$N$、$E_{\\mathrm{obs}}$、$E_{\\mathrm{true}}$、$L$）。问题规范中没有矛盾。\n\n**步骤3：结论与行动**\n该问题科学上合理、适定且自洽。因此被判定为**有效**。将提供一个解决方案。\n\n**基于原理的解决方案**\n\n该问题旨在解决不完整网络中的链接预测问题，其假设是真实的、完整的网络是无标度的。无标度网络的特点是其度分布 $P(k)$ 服从幂律，近似为 $P(k) \\sim k^{-\\gamma}$，其中 $k$ 是度，$\\gamma$ 是一个常数。这类网络的一个关键特征是存在少数高度连接的节点，即“枢纽”节点。生成无标度网络的优先连接模型假定，一个新节点与现有节点 $i$ 连接的概率与该节点 $i$ 的度 $k_i$ 成正比。\n\n这个原理被直接转化为一种链接预测的启发式方法。对于两个当前未连接的节点 $u$ 和 $v$，它们之间存在未来或未观测到的链接的可能性被假定为与它们当前度的乘积 $k_u \\cdot k_v$ 成正比。度数越高的节点越具“吸引力”，因此更有可能形成链接。该问题用从观测到的不完整网络 $G_{\\mathrm{obs}} = (V, E_{\\mathrm{obs}})$ 计算出的得分 $S(u,v) = k_u \\cdot k_v$ 来形式化这种启发式方法。\n\n算法流程如下：\n\n1.  **计算节点度**：对于所有节点集合 $V = \\{0, 1, \\dots, N-1\\}$ 中的每个节点 $u$，根据观测到的边集 $E_{\\mathrm{obs}}$ 计算其度 $k_u$。度 $k_u$ 是 $E_{\\mathrm{obs}}$ 中与 $u$ 相关联的边的数量。\n\n2.  **识别候选对并评分**：枚举所有可能的不同节点的无序对 $\\{u,v\\}$，其中 $u<v$。从此所有可能的边集中，移除那些已经存在于 $E_{\\mathrm{obs}}$ 中的边。剩余的节点对即为用于预测的候选边。对于每个这样的候选对 $\\{u,v\\}$，计算其链接可能性得分 $S(u,v) = k_u \\cdot k_v$。\n\n3.  **对候选对进行排序**：创建一个包含所有候选对的排序列表。主要排序标准是得分 $S(u,v)$ 的降序。次要标准（用于打破平局）是节点对 $(u,v)$ 的升序字典序（假设保持 $u<v$）。\n\n4.  **选择预测并评估**：从排序列表的顶部选择前 $L$ 个节点对。这些是预测的缺失边。通过计算这 $L$ 个预测的节点对中有多少个属于真实的缺失边集 $E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}}$ 来评估预测的性能。\n\n**示例说明：测试用例 A**\n\n让我们将此过程应用于测试用例 A。\n- **已知条件**：$N = 6$，$E_{\\mathrm{obs}} = \\{(0,1),(0,2),(0,3),(1,2),(4,5)\\}$，$E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(2,3),(4,5)\\}$，$L = 2$。\n\n1.  **计算度**：基于 $E_{\\mathrm{obs}}$：\n    - $k_0 = 3$ (连接到 $1,2,3$)\n    - $k_1 = 2$ (连接到 $0,2$)\n    - $k_2 = 2$ (连接到 $0,1$)\n    - $k_3 = 1$ (连接到 $0$)\n    - $k_4 = 1$ (连接到 $5$)\n    - $k_5 = 1$ (连接到 $4$)\n\n2.  **识别候选对并评分**：总节点对数为 $\\binom{6}{2} = 15$。已观测到的边有 $|E_{\\mathrm{obs}}| = 5$ 条。因此，有 $15-5=10$ 个未观测到的节点对。我们计算它们的得分：\n    - $S(0,4) = k_0 \\cdot k_4 = 3 \\cdot 1 = 3$\n    - $S(0,5) = k_0 \\cdot k_5 = 3 \\cdot 1 = 3$\n    - $S(1,3) = k_1 \\cdot k_3 = 2 \\cdot 1 = 2$\n    - $S(1,4) = k_1 \\cdot k_4 = 2 \\cdot 1 = 2$\n    - $S(1,5) = k_1 \\cdot k_5 = 2 \\cdot 1 = 2$\n    - $S(2,3) = k_2 \\cdot k_3 = 2 \\cdot 1 = 2$\n    - $S(2,4) = k_2 \\cdot k_4 = 2 \\cdot 1 = 2$\n    - $S(2,5) = k_2 \\cdot k_5 = 2 \\cdot 1 = 2$\n    - $S(3,4) = k_3 \\cdot k_4 = 1 \\cdot 1 = 1$\n    - $S(3,5) = k_3 \\cdot k_5 = 1 \\cdot 1 = 1$\n\n3.  **对候选对进行排序**：我们对这 10 个节点对进行排序。\n    - 得分为 $S=3$ 的对：$(0,4), (0,5)$。按字典序：$(0,4)$，然后是 $(0,5)$。\n    - 得分为 $S=2$ 的对：$(1,3), (1,4), (1,5), (2,3), (2,4), (2,5)$。按字典序。\n    - 得分为 $S=1$ 的对：$(3,4), (3,5)$。按字典序。\n    完整的排序列表开头如下：\n    1. $\\{0,4\\}$ (得分 $3$)\n    2. $\\{0,5\\}$ (得分 $3$)\n    3. $\\{1,3\\}$ (得分 $2$)\n    4. $\\{1,4\\}$ (得分 $2$)\n    ... 等等。\n\n4.  **选择预测并评估**：当 $L=2$ 时，我们选择前两个节点对：$\\{0,4\\}$ 和 $\\{0,5\\}$。\n    - 我们确定真实的缺失链接集：$E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}} = \\{(0,4), (2,3)\\}$。\n    - 我们将我们的预测与 $E_{\\mathrm{miss}}$进行核对：\n        - $\\{0,4\\}$ 是否在 $E_{\\mathrm{miss}}$ 中？是。\n        - $\\{0,5\\}$ 是否在 $E_{\\mathrm{miss}}$ 中？否。\n    - 正确预测的数量是 $1$。\n\n测试用例 A 的结果是 $1$。将相同的过程应用于所有其他测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the link prediction problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Edges are represented as sorted tuples (u, v) with u < v for consistency.\n    test_cases = [\n        # Test Case A\n        {\n            \"N\": 6,\n            \"E_obs\": set([(0, 1), (0, 2), (0, 3), (1, 2), (4, 5)]),\n            \"E_true\": set([(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (2, 3), (4, 5)]),\n            \"L\": 2,\n        },\n        # Test Case B\n        {\n            \"N\": 6,\n            \"E_obs\": set([(0, 1), (1, 2), (3, 4)]),\n            \"E_true\": set([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]),\n            \"L\": 3,\n        },\n        # Test Case C\n        {\n            \"N\": 5,\n            \"E_obs\": set([(0, 1), (0, 2), (1, 2)]),\n            \"E_true\": set([(0, 1), (0, 2), (0, 3), (1, 2), (2, 3)]),\n            \"L\": 4,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        E_obs = case[\"E_obs\"]\n        E_true = case[\"E_true\"]\n        L = case[\"L\"]\n\n        # 1. Compute the degree k_u for each node u from E_obs.\n        degrees = np.zeros(N, dtype=int)\n        for u, v in E_obs:\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        # 2. Enumerate all non-observed pairs and compute S(u,v).\n        non_observed_pairs = []\n        for u in range(N):\n            for v in range(u + 1, N):\n                if (u, v) not in E_obs:\n                    score = degrees[u] * degrees[v]\n                    # Store as a tuple for sorting: (score, u, v)\n                    non_observed_pairs.append((score, u, v))\n        \n        # 3. Rank all non-observed pairs.\n        # Sort by decreasing S(u,v) (score), then ascending (u,v).\n        # We achieve this by sorting on (-score, u, v).\n        non_observed_pairs.sort(key=lambda x: (-x[0], x[1], x[2]))\n        \n        # 4. Select the top L pairs as predicted edges.\n        # The number of predictions cannot exceed the number of available candidate pairs.\n        num_predictions = min(L, len(non_observed_pairs))\n        predicted_edges = set()\n        for i in range(num_predictions):\n            score, u, v = non_observed_pairs[i]\n            predicted_edges.add((u, v))\n            \n        # 5. Count how many predicted pairs are in E_miss.\n        E_miss = E_true.difference(E_obs)\n        correct_predictions = len(predicted_edges.intersection(E_miss))\n        \n        results.append(correct_predictions)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428013"}]}