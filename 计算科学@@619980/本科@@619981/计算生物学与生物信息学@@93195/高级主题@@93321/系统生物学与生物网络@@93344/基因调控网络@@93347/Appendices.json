{"hands_on_practices": [{"introduction": "负自动调节是基因调控网络中最常见和最重要的基本模块之一。通过这个练习，你将掌握一项核心技能：通过平衡蛋白质的生成和降解速率，来计算基因产物的稳态浓度。这是定量理解任何基因调控回路的第一步，帮助我们预测基因在稳定环境下的表达水平。[@problem_id:1435734]", "problem": "一位合成生物学家正在一个细菌宿主中设计一个简单的基因回路。该回路旨在实现负向自动调节，即一种我们称之为阻遏蛋白（R）的蛋白质会抑制其自身基因的表达。在$t$时刻，阻遏蛋白的浓度表示为$R(t)$。该系统的动力学由以下原理建模：\n\n1.  **生成：** 阻遏蛋白的合成速率由一个抑制性希尔函数描述。当R的浓度为零时，其生成速率达到最大值$k_p$。随着浓度$R(t)$的增加，该蛋白质会结合到其自身的启动子区域，从而抑制合成。这种抑制作用由一个常数$K$来表征，该常数$K$定义为使生成速率降至其最大值一半时的R浓度。该结合过程是非协同的，对应的希尔系数为$n=1$。\n\n2.  **降解：** 阻遏蛋白会从细胞中被持续移除。该移除过程遵循一级动力学，其特征是降解速率常数为$k_d$。\n\n所有参数$k_p$、$k_d$和$K$均为正实数常数。经过足够长的时间后，观察到系统达到一个稳定构型，此时阻遏蛋白的浓度不再变化。求出在这种最终的稳定构型中，阻遏蛋白R的浓度。你的答案应为一个以参数$k_p$、$k_d$和$K$表示的解析表达式。", "solution": "设$R(t)$表示阻遏蛋白的浓度。根据题意：\n- 生成过程遵循一个抑制性希尔函数，其中$n=1$，在$R=0$时速率最大为$k_{p}$，在$R=K$时为最大速率的一半。因此，生成速率为\n$$\n\\text{Production}(R) = \\frac{k_{p}}{1 + \\frac{R}{K}}.\n$$\n- 降解过程遵循一级动力学，速率常数为$k_{d}$，所以降解速率为\n$$\n\\text{Degradation}(R) = k_{d} R.\n$$\n\n因此，动力学方程为\n$$\n\\frac{dR}{dt} = \\frac{k_{p}}{1 + \\frac{R}{K}} - k_{d} R.\n$$\n\n在最终的稳定构型（稳态）下，$\\frac{dR}{dt}=0$。因此，$R$满足\n$$\n\\frac{k_{p}}{1 + \\frac{R}{K}} - k_{d} R = 0.\n$$\n整理可得\n$$\n\\frac{k_{p}}{1 + \\frac{R}{K}} = k_{d} R.\n$$\n两边同乘以$1 + \\frac{R}{K}$：\n$$\nk_{p} = k_{d} R \\left(1 + \\frac{R}{K}\\right) = k_{d} R + \\frac{k_{d}}{K} R^{2}.\n$$\n因此，$R$满足以下一元二次方程\n$$\n\\frac{k_{d}}{K} R^{2} + k_{d} R - k_{p} = 0.\n$$\n设$a = \\frac{k_{d}}{K}$，$b = k_{d}$，且$c = -k_{p}$。根据一元二次方程求根公式，\n$$\nR = \\frac{-b \\pm \\sqrt{b^{2} - 4 a c}}{2 a} = \\frac{-k_{d} \\pm \\sqrt{k_{d}^{2} + \\frac{4 k_{d} k_{p}}{K}}}{2 \\frac{k_{d}}{K}}.\n$$\n由于$k_{p}, k_{d}, K > 0$，具有物理意义的（非负）根应取正号。通过提取公因子$k_d$并化简，\n$$\nR^{\\ast} = \\frac{K}{2 k_{d}} \\left(-k_{d} + \\sqrt{k_{d}^{2} + \\frac{4 k_{d} k_{p}}{K}}\\right)\n= \\frac{K}{2} \\left(-1 + \\sqrt{1 + \\frac{4 k_{p}}{k_{d} K}}\\right).\n$$\n这就是以$k_{p}$、$k_{d}$和$K$表示的阻遏蛋白的稳态浓度。", "answer": "$$\\boxed{\\frac{K}{2}\\left(\\sqrt{1+\\frac{4 k_{p}}{k_{d} K}}-1\\right)}$$", "id": "1435734"}, {"introduction": "这个练习将基因调控的分子细节与一个宏观的生物学现象——发育过程中的模式形成——联系起来。它展示了单个参数，即描述基因响应“开关”特性的希尔系数$n$，如何显著影响基因表达边界的锐度。这个实践提供了一个具体的例子，说明了定量模型如何将分子机制与生命体层面的结果联系起来。[@problem_id:2393654]", "problem": "给定一个一维发育模型，其中一个抑制性形态原沿区间 $[0,L]$ 上的坐标 $x$ 形成空间梯度，并且一个靶基因根据 Hill 函数受到抑制。形态原浓度建模为 $M(x) = M_{0}\\,\\exp(-x/\\lambda)$，稳态基因表达水平建模为 $G(x) = \\dfrac{G_{\\max}}{1 + \\left(\\dfrac{M(x)}{K}\\right)^{n}}$，其中 $n$ 是 Hill 系数。本问题中所有量均为无量纲量。考虑固定参数值为 $M_{0} = 100$、$K = 1$、$\\lambda = 2$、$L = 20$ 以及 $G_{\\max} = 1$。\n\n将边界锐度定义为表达水平分别达到 $0.1\\,G_{\\max}$ 和 $0.9\\,G_{\\max}$ 的位置 $x_{0.1}$ 和 $x_{0.9}$ 之间的宽度 $\\Delta x_{10\\text{--}90}$。也就是说，$G(x_{0.1}) = 0.1\\,G_{\\max}$ 且 $G(x_{0.9}) = 0.9\\,G_{\\max}$，并且 $\\Delta x_{10\\text{--}90} = x_{0.9} - x_{0.1}$。假设 $x \\in [0,L]$。\n\n你的任务是为以下测试组中的每个 Hill 系数 $n$ 计算 $\\Delta x_{10\\text{--}90}$：\n- $n = 0.5$\n- $n = 1$\n- $n = 2$\n- $n = 4$\n- $n = 10$\n\n所有输出都必须是实数。你的程序必须生成单行输出，其中包含按测试组顺序排列的、四舍五入到 $6$ 位小数的宽度结果，并以逗号分隔的列表形式用方括号括起来。例如，如果五个结果是 $a_{1}$ 到 $a_{5}$，则输出必须为 \"[a1,a2,a3,a4,a5]\" 的形式。", "solution": "所述问题在科学上是合理的，内容自洽，且提法明确。它描述了发育生物学中空间模式形成的一个标准模型，其中形态原梯度建立了基因表达的边界。我将进行严谨的解析求解。\n\n目标是计算受形态原抑制的基因的边界锐度 $\\Delta x_{10\\text{--}90}$。形态原浓度 $M(x)$ 和由此产生的基因表达 $G(x)$ 由以下公式给出：\n$$M(x) = M_{0} \\exp(-x/\\lambda)$$\n$$G(x) = \\frac{G_{\\max}}{1 + \\left(\\frac{M(x)}{K}\\right)^{n}}$$\n固定的无量纲参数为 $M_{0} = 100$、$K = 1$、$\\lambda = 2$、$L = 20$ 以及 $G_{\\max} = 1$。Hill 系数 $n$ 是可变参数。\n\n边界锐度定义为 $\\Delta x_{10\\text{--}90} = x_{0.9} - x_{0.1}$，其中 $x_{0.1}$ 和 $x_{0.9}$ 分别是基因表达水平为其最大值 $10\\%$ 和 $90\\%$ 时的空间位置。也就是说，$G(x_{0.1}) = 0.1 G_{\\max}$ 且 $G(x_{0.9}) = 0.9 G_{\\max}$。\n\n首先，我们必须推导出基因表达为其最大值的分数 $p$ 时所在位置 $x_p$ 的通用表达式：$G(x_p) = p \\cdot G_{\\max}$。\n代入 $G(x)$ 的表达式，我们得到：\n$$p \\cdot G_{\\max} = \\frac{G_{\\max}}{1 + \\left(\\frac{M(x_p)}{K}\\right)^{n}}$$\n因为 $G_{\\max} \\neq 0$，我们可以将等式两边同时除以 $G_{\\max}$：\n$$p = \\frac{1}{1 + \\left(\\frac{M(x_p)}{K}\\right)^{n}}$$\n现在我们求解该位置的形态原浓度 $M(x_p)$：\n$$1 + \\left(\\frac{M(x_p)}{K}\\right)^{n} = \\frac{1}{p}$$\n$$\\left(\\frac{M(x_p)}{K}\\right)^{n} = \\frac{1}{p} - 1 = \\frac{1-p}{p}$$\n$$M(x_p) = K \\left(\\frac{1-p}{p}\\right)^{1/n}$$\n接下来，我们代入形态原梯度的表达式 $M(x) = M_{0} \\exp(-x/\\lambda)$，以求解位置 $x_p$：\n$$M_{0} \\exp(-x_p/\\lambda) = K \\left(\\frac{1-p}{p}\\right)^{1/n}$$\n$$\\exp(-x_p/\\lambda) = \\frac{K}{M_{0}} \\left(\\frac{1-p}{p}\\right)^{1/n}$$\n对等式两边取自然对数：\n$$-x_p/\\lambda = \\ln\\left[\\frac{K}{M_{0}} \\left(\\frac{1-p}{p}\\right)^{1/n}\\right]$$\n使用对数性质 $\\ln(ab) = \\ln(a) + \\ln(b)$ 和 $\\ln(a^b) = b\\ln(a)$：\n$$-x_p/\\lambda = \\ln\\left(\\frac{K}{M_{0}}\\right) + \\frac{1}{n} \\ln\\left(\\frac{1-p}{p}\\right)$$\n最后，解出 $x_p$：\n$$x_p = -\\lambda \\left[ \\ln\\left(\\frac{K}{M_{0}}\\right) + \\frac{1}{n} \\ln\\left(\\frac{1-p}{p}\\right) \\right]$$\n使用 $\\ln(a/b) = -\\ln(b/a)$ 和 $\\ln((1-p)/p) = -\\ln(p/(1-p))$，这可以被重写为一个更方便的形式：\n$$x_p = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{p}{1-p}\\right) \\right]$$\n这个方程给出了对于任何给定的表达水平分数 $p$ 的位置 $x_p$。\n\n现在，我们应用这个通用公式来求解 $x_{0.9}$ (其中 $p = 0.9$) 和 $x_{0.1}$ (其中 $p = 0.1$) 。\n对于 $x_{0.9}$：\n$$x_{0.9} = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{0.9}{1-0.9}\\right) \\right] = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln(9) \\right]$$\n对于 $x_{0.1}$：\n$$x_{0.1} = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{0.1}{1-0.1}\\right) \\right] = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln\\left(\\frac{1}{9}\\right) \\right]$$\n因为 $\\ln(1/9) = -\\ln(9)$，这可以简化为：\n$$x_{0.1} = \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) - \\frac{1}{n} \\ln(9) \\right]$$\n边界锐度 $\\Delta x_{10\\text{--}90}$ 是这两个位置之差：\n$$\\Delta x_{10\\text{--}90} = x_{0.9} - x_{0.1}$$\n$$\\Delta x_{10\\text{--}90} = \\left( \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) + \\frac{1}{n} \\ln(9) \\right] \\right) - \\left( \\lambda \\left[ \\ln\\left(\\frac{M_{0}}{K}\\right) - \\frac{1}{n} \\ln(9) \\right] \\right)$$\n$\\lambda \\ln(M_0/K)$ 项相互抵消，得出一个非常简洁的结果：\n$$\\Delta x_{10\\text{--}90} = \\frac{\\lambda}{n} \\ln(9) - \\left(-\\frac{\\lambda}{n} \\ln(9)\\right) = \\frac{2\\lambda}{n} \\ln(9)$$\n这个结果表明，边界锐度与 Hill 系数 $n$ 成反比，与形态原衰减长度 $\\lambda$ 成正比。更高的 Hill 系数（一种更具开关性或超敏性的响应）会导致更锐利的边界（更小的 $\\Delta x$）。\n\n我们现在将给定的值 $\\lambda=2$ 代入此公式：\n$$\\Delta x_{10\\text{--}90} = \\frac{2 \\cdot 2}{n} \\ln(9) = \\frac{4}{n} \\ln(9)$$\n$9$ 的自然对数值约为 $\\ln(9) \\approx 2.197224577$。使用这个值，我们计算测试组中每个 $n$ 值的锐度。\n\n对于 $n=0.5$：\n$$\\Delta x = \\frac{4}{0.5} \\ln(9) = 8 \\ln(9) \\approx 8 \\times 2.197224577 \\approx 17.577797$$\n对于 $n=1$：\n$$\\Delta x = \\frac{4}{1} \\ln(9) = 4 \\ln(9) \\approx 4 \\times 2.197224577 \\approx 8.788898$$\n对于 $n=2$：\n$$\\Delta x = \\frac{4}{2} \\ln(9) = 2 \\ln(9) \\approx 2 \\times 2.197224577 \\approx 4.394449$$\n对于 $n=4$：\n$$\\Delta x = \\frac{4}{4} \\ln(9) = \\ln(9) \\approx 2.197224577 \\approx 2.197225$$\n对于 $n=10$：\n$$\\Delta x = \\frac{4}{10} \\ln(9) = 0.4 \\ln(9) \\approx 0.4 \\times 2.197224577 \\approx 0.878890$$\n\n这些值将在实现中被计算并按要求格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the boundary sharpness for a gene expression pattern formed by a repressor morphogen gradient.\n    \"\"\"\n    \n    # Define the constants from the problem statement.\n    # While M0, K, L, and Gmax are given, they are not needed for the final analytical formula.\n    # The decay length lambda is required.\n    lambda_val = 2.0\n    \n    # Define the test suite of Hill coefficients.\n    hill_coefficients = [0.5, 1.0, 2.0, 4.0, 10.0]\n    \n    results = []\n    \n    # The derived analytical formula for boundary sharpness is:\n    # delta_x_10_90 = (2 * lambda / n) * ln(9)\n    constant_term = 2.0 * lambda_val * np.log(9.0)\n    \n    for n in hill_coefficients:\n        # Calculate the boundary sharpness for the current Hill coefficient.\n        delta_x = constant_term / n\n        \n        # Format the result to 6 decimal places and add to the list.\n        # Using string formatting a la f-string is precise for this task.\n        results.append(f\"{delta_x:.6f}\")\n        \n    # Print the final output in the specified format: [a1,a2,a3,a4,a5]\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "2393654"}, {"introduction": "我们将焦点从分析一个已知的网络转向一个更具挑战性的任务：发现网络本身的结构。这个练习模拟了系统生物学家的真实工作，他们必须设计实验（如基因敲除）并解读数据，以推断基因之间的调控连接。这个问题旨在锻炼你的逻辑推理能力，并让你深入理解网络推断的基本原理。[@problem_id:2393624]", "problem": "你必须编写一个完整的程序，对于几个包含基因 $A$、$B$ 和 $C$ 的三基因网络，仅使用稳态敲除数据，判断从 $A$ 到 $C$ 的调控是直接的、通过 $B$ 间接的，还是不存在的。建模假设、允许的观测数据和要求的输出在下文指定。\n\n基因调控网络被建模为一个处于稳态的线性连续时间系统。令 $x \\in \\mathbb{R}^3$ 表示稳态表达向量，按 $[A,B,C]$ 排序。令 $W \\in \\mathbb{R}^{3 \\times 3}$ 为对角线元素为零的加权邻接矩阵，其中元素 $W_{ij}$ 表示基因 $j$ 对基因 $i$ 的影响（行为靶标，列为调控者），令 $s \\in \\mathbb{R}^3$ 为一个恒定的基础输入向量。无约束的稳态 $x^{(\\varnothing)}$ 满足\n$$\nx^{(\\varnothing)} = W \\, x^{(\\varnothing)} + s,\n$$\n条件是 $W$ 的谱半径严格小于 $1$，从而 $(I - W)$ 可逆且稳态是唯一的。\n\n对子集 $S \\subseteq \\{A,B,C\\}$ 的敲除操作，建模为将每个 $i \\in S$ 的 $x_i$ 钳制为 $0$，并求解剩余基因的稳态方程。形式上，令 $R = \\{A,B,C\\} \\setminus S$；则在敲除 $S$ 下的稳态是向量 $x^{(S)} \\in \\mathbb{R}^3$，满足：\n- 对所有 $i \\in S$，$x^{(S)}_i = 0$，\n- $x^{(S)}_R$ 满足\n$$\nx^{(S)}_R = W_{R,R} \\, x^{(S)}_R + s_R,\n$$\n其中 $W_{R,R}$ 和 $s_R$ 是由 $R$ 索引的主子矩阵和子向量。\n\n对于每个网络，你只能使用稳态向量 $x^{(\\varnothing)}$、$x^{(\\{A\\})}$、$x^{(\\{B\\})}$ 和 $x^{(\\{A,B\\})}$ 来确定该网络中三元组 $(A,B,C)$ 的分类。如果 $|u - v| \\le \\varepsilon$ 且 $\\varepsilon = 10^{-8}$，则将两个实数 $u$ 和 $v$ 视为相等。\n\n为每个网络输出一个分类代码，如下所示：\n- 如果从 $A$ 到 $C$ 的调控是直接的（即，从 $A$到 $C$ 存在一个非零的直接影响，该影响不会因敲除 $B$ 而完全消除），则输出 $2$。\n- 如果从 $A$ 到 $C$ 的调控是通过 $B$ 间接的（即，$A$ 对 $C$ 的任何影响都会因敲除 $B$ 而消除，并且不存在从 $A$ 到 $C$ 的直接影响），则输出 $1$。\n- 如果从允许的稳态敲除数据中检测不到 $A$ 对 $C$ 的任何影响，则输出 $0$。\n\n你的程序必须实现上述模型，从提供的参数集生成允许的稳态敲除数据，然后仅使用这些数据为每个网络生成所需的分类代码。\n\n测试套件（顺序很重要，基因顺序为 $[A,B,C]$；$W$ 的行为靶标，列为调控者）：\n1. 情况 1 (仅直接):\n$$\nW^{(1)} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0.4 & 0 & 0\n\\end{bmatrix},\n\\quad\ns^{(1)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n2. 情况 2 (仅通过 $B$ 间接):\n$$\nW^{(2)} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0.5 & 0 & 0 \\\\\n0 & 0.6 & 0\n\\end{bmatrix},\n\\quad\ns^{(2)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n3. 情况 3 (直接与间接兼有):\n$$\nW^{(3)} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0.4 & 0 & 0 \\\\\n0.3 & 0.5 & 0\n\\end{bmatrix},\n\\quad\ns^{(3)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n4. 情况 4 (从 $A$ 到 $C$ 无路径):\n$$\nW^{(4)} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix},\n\\quad\ns^{(4)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n5. 情况 5 (直接与间接，并带有反馈 $C \\rightarrow A$):\n$$\nW^{(5)} = \\begin{bmatrix}\n0 & 0 & -0.2 \\\\\n0.5 & 0 & 0 \\\\\n0.2 & 0.5 & 0\n\\end{bmatrix},\n\\quad\ns^{(5)} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}.\n$$\n\n最终输出格式：你的程序应生成单行输出，其中包含五个案例的分类结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 都是如上定义的集合 $\\{0,1,2\\}$ 中的一个整数。不应打印任何额外文本。", "solution": "所提出的问题是计算系统生物学中一个适定性良好的练习，具体涉及从稳态扰动数据中推断网络拓扑。该问题具有科学依据、数学上精确，并且不含任何歧义或矛盾。我们将进行形式化的求解。\n\n该系统由线性稳态方程描述\n$$x = Wx + s$$\n其中 $x \\in \\mathbb{R}^3$ 是指定为 $A$、$B$ 和 $C$ (索引分别为 0、1 和 2) 的基因的表达水平向量，$W \\in \\mathbb{R}^{3 \\times 3}$ 是相互作用矩阵，$s \\in \\mathbb{R}^3$ 是基础生产向量。谱半径 $\\rho(W) < 1$ 的条件确保了 $(I-W)$ 是可逆的，从而产生唯一的稳态 $x = (I-W)^{-1}s$。\n\n对基因集 $S$ 的敲除对应于将这些基因的表达设置为 0，并允许由 $R = \\{A,B,C\\} \\setminus S$ 索引的剩余子系统达到新的稳态。该子系统的方程为\n$$x_R = W_{R,R}x_R + s_R$$\n其具有唯一解 $x_R = (I_{R,R} - W_{R,R})^{-1}s_R$，前提是主子矩阵 $W_{R,R}$ 也对应于一个稳定的系统。然后通过将 $i \\in S$ 的 $x_i^{(S)}$ 设置为 0，并用 $x_R$ 中的分量填充剩余部分来构建完整的状态向量 $x^{(S)}$。\n\n任务是仅使用来自四个实验的稳态表达向量来分类从基因 $A$到基因 $C$ 的调控：野生型 ($x^{(\\varnothing)}$)、敲除 $A$ ($x^{(\\{A\\})})$、敲除 $B$ ($x^{(\\{B\\})})$ 以及双敲除 $A$ 和 $B$ ($x^{(\\{A,B\\})}$)。该分类取决于区分直接调控 ($A \\to C$) 和间接调控 ($A \\to B \\to C$)。\n\n我们可以基于从允许的观测中获得的可量化效应，设计一个逻辑框架。令 $x_C^{(S)}$ 表示在对应于敲除集 $S$ 的稳态下基因 $C$ (分量 $x_2$) 的表达。\n\n首先，我们必须定义一个衡量 $A$ 对 $C$ 直接影响的指标，根据定义，这是一种不由基因 $B$ 介导的影响。这可以通过在基因 $B$ 已经缺失的遗传背景下，观察敲除基因 $A$ 的效果来量化。在这些条件下，基因 $C$ 表达的变化分离出了 $A$ 对 $C$ 的*不依赖于 B* 的影响。我们将直接效应 $\\Delta_{\\text{direct}}$ 定义为：\n$$\\Delta_{\\text{direct}} = x_C^{(\\{B\\})} - x_C^{(\\{A,B\\})}$$\n让我们分析这个表达式。基因 $C$ 的方程是 $x_2 = W_{20}x_0 + W_{21}x_1 + s_2$ (因为 $W_{22}=0$）。在 $\\{A,B\\}$ 双敲除下，$x_0 = 0$ 且 $x_1 = 0$，因此方程简化为 $x_2^{(\\{A,B\\})} = s_2$。这个实验直接测量了 $C$ 的基础生产。在 $\\{B\\}$ 敲除中，$x_1 = 0$，基因 $A$ 和 $C$ 的子系统达到平衡。因此，表达 $x_C^{(\\{B\\})}$ 反映了基础生产 $s_2$ 加上来自基因 $A$ 的任何贡献（通过项 $W_{20}x_0^{(\\{B\\})}$ 和任何反馈，如 $W_{02}$）。因此，差值 $\\Delta_{\\text{direct}}$ 在基因 $B$ 缺失的情况下，分离出了源自基因 $A$ 对基因 $C$ 的净效应。$\\Delta_{\\text{direct}}$ 的非零值（在数值容差 $\\varepsilon = 10^{-8}$ 内）是从 $A$ 到 $C$ 存在不涉及 $B$ 的调控路径的决定性证据。\n\n其次，我们定义一个衡量 $A$ 对 $C$ 总影响的指标，包括所有直接和间接路径。这可以很自然地通过在野生型背景下敲除 $A$ 后 $C$ 表达的变化来衡量：\n$$\\Delta_{\\text{total}} = x_C^{(\\varnothing)} - x_C^{(\\{A\\})}$$\n非零的 $\\Delta_{\\text{total}}$ 表明基因 $A$ 对基因 $C$ 有某种调控影响。\n\n利用这两个可测量的量，我们可以建立一个清晰的分类算法：\n\n1.  **测试直接调控 (代码 2):** 计算 $\\Delta_{\\text{direct}} = x_C^{(\\{B\\})} - x_C^{(\\{A,B\\})}$。如果 $|\\Delta_{\\text{direct}}| > \\varepsilon$，它表示从 $A$ 到 $C$ 存在直接的调控影响（或通过不涉及 B 的路径）。这符合代码 2 的定义。\n\n2.  **测试仅间接调控 (代码 1):** 如果第一个测试失败，即 $|\\Delta_{\\text{direct}}| \\le \\varepsilon$，这意味着从 $A$ 到 $C$ 的任何调控在 $B$ 被敲除时都会消除。然后我们检查一开始是否存在任何调控。我们计算 $\\Delta_{\\text{total}} = x_C^{(\\varnothing)} - x_C^{(\\{A\\})}$。如果 $|\\Delta_{\\text{total}}| > \\varepsilon$，我们得出结论，$A$ 对 $C$ 存在影响，但它必须完全通过 $B$ 来介导。这符合代码 1 的定义。\n\n3.  **测试无调控 (代码 0):** 如果以上两个测试都失败，即 $|\\Delta_{\\text{direct}}| \\le \\varepsilon$ 且 $|\\Delta_{\\text{total}}| \\le \\varepsilon$，则从可用数据中检测不到 $A$ 对 $C$ 的影响。这对应于代码 0。\n\n对每个提供的测试用例 $(W, s)$，实现将按以下步骤进行：\na) 对于四个敲除集 $S \\in \\{\\varnothing, \\{A\\}, \\{B\\}, \\{A,B\\}\\}$ 中的每一个，计算稳态向量 $x^{(S)}$。这涉及识别剩余的基因 $R$，构建子矩阵 $M_R = I_{R,R} - W_{R,R}$ 和子向量 $s_R$，并求解线性系统 $M_R x_R = s_R$。\nb) 从计算出的四个向量中提取基因 $C$ ($x_2$) 的表达水平。\nc) 计算 $\\Delta_{\\text{direct}}$ 和 $\\Delta_{\\text{total}}$。\nd) 应用上述分类逻辑来确定相应的整数代码。\ne) 收集所有测试用例的代码，并以指定格式呈现。需要使用数值线性代数库来稳健地求解方程组。", "answer": "```python\nimport numpy as np\n\ndef solve_steady_state(W, s, knockout_indices):\n    \"\"\"\n    Solves for the steady-state gene expression vector for a given network\n    and a set of knocked-out genes.\n\n    Args:\n        W (np.ndarray): The 3x3 weighted adjacency matrix.\n        s (np.ndarray): The 3x1 basal input vector.\n        knockout_indices (set): A set of indices (0, 1, or 2) for the genes to be knocked out.\n\n    Returns:\n        np.ndarray: The 3x1 steady-state expression vector x.\n    \"\"\"\n    all_indices = {0, 1, 2}\n    remaining_indices = sorted(list(all_indices - knockout_indices))\n\n    if not remaining_indices:\n        return np.zeros(3)\n\n    W_rr = W[np.ix_(remaining_indices, remaining_indices)]\n    s_r = s[remaining_indices]\n\n    # The system to solve is x_R = W_R,R * x_R + s_R\n    # which can be rewritten as (I - W_R,R) * x_R = s_R\n    I_rr = np.identity(len(remaining_indices))\n    A_matrix = I_rr - W_rr\n\n    # Solve the linear system for the remaining genes\n    try:\n        x_r = np.linalg.solve(A_matrix, s_r)\n    except np.linalg.LinAlgError:\n        # This case should not occur for the given problem constraints (rho(W) < 1)\n        # and its sub-systems.\n        return np.full(3, np.nan) \n\n    # Construct the full steady-state vector\n    x_full = np.zeros(3)\n    for i, idx in enumerate(remaining_indices):\n        x_full[idx] = x_r[i]\n        \n    return x_full\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and produce the final classification.\n    \"\"\"\n    # Problem parameters\n    # Gene indices: A=0, B=1, C=2\n    # Row=target, Col=regulator\n    \n    test_cases = [\n        # Case 1 (direct only)\n        (np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.4, 0.0, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 2 (indirect only via B)\n        (np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [0.0, 0.6, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 3 (both direct and indirect)\n        (np.array([[0.0, 0.0, 0.0], [0.4, 0.0, 0.0], [0.3, 0.5, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 4 (no path from A to C)\n        (np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]), np.array([1.0, 1.0, 1.0])),\n        # Case 5 (direct and indirect with feedback C -> A)\n        (np.array([[0.0, 0.0, -0.2], [0.5, 0.0, 0.0], [0.2, 0.5, 0.0]]), np.array([1.0, 1.0, 1.0]))\n    ]\n\n    results = []\n    epsilon = 1e-8\n    C_INDEX = 2\n\n    for W, s in test_cases:\n        # Generate the four required steady-state vectors from knockout experiments\n        x_wild_type = solve_steady_state(W, s, set())\n        x_ko_A = solve_steady_state(W, s, {0})\n        x_ko_B = solve_steady_state(W, s, {1})\n        x_ko_AB = solve_steady_state(W, s, {0, 1})\n\n        # Extract the expression level of gene C\n        x_C_wild_type = x_wild_type[C_INDEX]\n        x_C_ko_A = x_ko_A[C_INDEX]\n        x_C_ko_B = x_ko_B[C_INDEX]\n        x_C_ko_AB = x_ko_AB[C_INDEX]\n\n        # Calculate the direct and total effects\n        delta_direct = x_C_ko_B - x_C_ko_AB\n        delta_total = x_C_wild_type - x_C_ko_A\n\n        # Apply the classification logic\n        if abs(delta_direct) > epsilon:\n            # Code 2: A has an effect on C even when B is knocked out,\n            # indicating a direct path (or path not involving B).\n            results.append(2)\n        elif abs(delta_total) > epsilon:\n            # Code 1: The direct effect is zero, but the total effect is non-zero.\n            # This means the effect of A on C is entirely mediated by B.\n            results.append(1)\n        else:\n            # Code 0: The total effect of A on C is zero (or negligible).\n            results.append(0)\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393624"}]}