{"hands_on_practices": [{"introduction": "本次练习将让你亲身体验通量平衡分析的核心：寻找最优通量分布。通过一个已明确定义的微型代谢网络，你将分析并推导出如何通过优化资源分配来最大化生物质产量。这项实践旨在加深你对通量上下限和化学计量效率如何约束并塑造最优解空间的理解。[@problem_id:2390880]", "problem": "考虑一个通过通量平衡分析 (FBA) 分析的最小代谢网络，该网络由一个化学计量矩阵 $S$ 表示，其中包含代谢物 $\\{\\text{Glc}, \\text{ATP}_{e}\\}$ 和反应 $\\{R_{\\text{glc\\_upt}}, R_{\\text{gly}}, R_{\\text{atp\\_syn}}, R_{\\text{maint}}, R_{\\text{biom}}\\}$。伪代谢物 $\\text{ATP}_{e}$ 代表一个能量平衡池。这些反应及其对 $S$ 的化学计量贡献如下：\n- 对于 $\\text{Glc}$：$R_{\\text{glc\\_upt}}$ 的系数为 $+1$，$R_{\\text{gly}}$ 的系数为 $-1$，其余反应的系数为 $0$。\n- 对于 $\\text{ATP}_{e}$：$R_{\\text{gly}}$ 的系数为 $+2$，$R_{\\text{atp\\_syn}}$ 的系数为 $+y$，$R_{\\text{maint}}$ 的系数为 $-1$，$R_{\\text{biom}}$ 的系数为 $-b$，而 $R_{\\text{glc\\_upt}}$ 的系数为 $0$。\n\n设通量向量为 $v = (v_{\\text{glc\\_upt}}, v_{\\text{gly}}, v_{\\text{atp\\_syn}}, v_{\\text{maint}}, v_{\\text{biom}})$。稳态约束 $S v = 0$ 为：\n- $\\text{Glc}$ 平衡：$v_{\\text{glc\\_upt}} - v_{\\text{gly}} = 0$。\n- 能量平衡：$2 v_{\\text{gly}} + y \\, v_{\\text{atp\\_syn}} - v_{\\text{maint}} - b \\, v_{\\text{biom}} = 0$。\n\n通量边界为：\n- $0 \\le v_{\\text{glc\\_upt}} \\le G$，\n- $0 \\le v_{\\text{gly}}$ (无上限)，\n- $0 \\le v_{\\text{atp\\_syn}} \\le S$，\n- $M \\le v_{\\text{maint}}$ (无上限)，\n- $0 \\le v_{\\text{biom}}$ (无上限)。\n\n目标是最大化生物质通量 $v_{\\text{biom}}$。\n\n参数 $y$ 是化学计量矩阵 $S$ 中 ATP 合成酶反应 $R_{\\text{atp\\_syn}}$ 的三磷酸腺苷 (ATP) 产率系数。在基线模型中，$y = y_0$。在扰动模型中，ATP 产率增加了 $1.10$ 倍，即 $y = 1.10 \\, y_0$。\n\n任务：对于下面测试套件中的每一组参数，计算最优生物质目标值的变化，定义为 $\\Delta v_{\\text{biom}}^{\\star} = v_{\\text{biom}}^{\\star}(1.10\\,y_0) - v_{\\text{biom}}^{\\star}(y_0)$，其中 $v_{\\text{biom}}^{\\star}(y)$ 表示在参数和产率 $y$ 下的最优生物质通量。所有通量，包括报告的变化值，都必须以 $\\text{mmol}\\,(\\text{gDW}\\cdot \\text{h})^{-1}$ 为单位表示。将每个报告的变化值表示为保留六位小数的浮点数。\n\n测试套件（每个元组为 $(G, S, M, b, y_0)$，单位对于 $G, S, M$ 是 $\\text{mmol}\\,(\\text{gDW}\\cdot \\text{h})^{-1}$，对于 $b, y_0$ 是无量纲）：\n- 案例 $1$：$(G, S, M, b, y_0) = (\\,5,\\, 2,\\, 3,\\, 10,\\, 3.0\\,)$。\n- 案例 $2$：$(G, S, M, b, y_0) = (\\,5,\\, 0,\\, 3,\\, 10,\\, 3.0\\,)$。\n- 案例 $3$：$(G, S, M, b, y_0) = (\\,1,\\, 1,\\, 5,\\, 10,\\, 3.0\\,)$。\n- 案例 $4$：$(G, S, M, b, y_0) = (\\,0,\\, 4,\\, 10,\\, 10,\\, 3.0\\,)$。\n- 案例 $5$：$(G, S, M, b, y_0) = (\\,2,\\, 5,\\, 1,\\, 10,\\, 3.0\\,)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件相同，例如 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_i$ 是案例 $i$ 的经四舍五入的浮点数变化值 $\\Delta v_{\\text{biom}}^{\\star}$，单位为 $\\text{mmol}\\,(\\text{gDW}\\cdot \\text{h})^{-1}$。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**问题验证**\n\n逐字提取给定条件：一个包含代谢物 $\\{\\text{Glc}, \\text{ATP}_{e}\\}$ 和反应 $\\{R_{\\text{glc\\_upt}}, R_{\\text{gly}}, R_{\\text{atp\\_syn}}, R_{\\text{maint}}, R_{\\text{biom}}\\}$ 的代谢网络。化学计量矩阵 $S$ 导出了稳态约束 $S v = 0$：\n1. $v_{\\text{glc\\_upt}} - v_{\\text{gly}} = 0$\n2. $2 v_{\\text{gly}} + y \\, v_{\\text{atp\\_syn}} - v_{\\text{maint}} - b \\, v_{\\text{biom}} = 0$\n\n通量边界给定为：$0 \\le v_{\\text{glc\\_upt}} \\le G$，$0 \\le v_{\\text{gly}}$，$0 \\le v_{\\text{atp\\_syn}} \\le S$，$M \\le v_{\\text{maint}}$，以及 $0 \\le v_{\\text{biom}}$。目标是最大化 $v_{\\text{biom}}$。参数 $y$ 从基线值 $y_0$ 扰动至 $1.10 \\, y_0$。任务是计算最大生物质通量的变化值 $\\Delta v_{\\text{biom}}^{\\star}$。\n\n该问题是通量平衡分析 (FBA) 的一个标准应用，这是计算生物学中的一项基石技术。它在数学上被表述为一个线性规划 (LP) 问题。术语定义精确，结构逻辑清晰，并且在科学上基于代谢建模的原理。没有矛盾、歧义或事实性错误。因此，该问题被认定为**有效**。\n\n**解析解**\n\n任务是求解以下线性规划问题以获得最优生物质通量 $v_{\\text{biom}}^{\\star}$：\n最大化 $v_{\\text{biom}}$， subject to 以下约束：\n1. $v_{\\text{glc\\_upt}} - v_{\\text{gly}} = 0$\n2. $2 v_{\\text{gly}} + y \\, v_{\\text{atp\\_syn}} - v_{\\text{maint}} - b \\, v_{\\text{biom}} = 0$\n3. $0 \\le v_{\\text{glc\\_upt}} \\le G$\n4. $v_{\\text{gly}} \\ge 0$\n5. $0 \\le v_{\\text{atp\\_syn}} \\le S$\n6. $v_{\\text{maint}} \\ge M$\n7. $v_{\\text{biom}} \\ge 0$\n\n我们通过简化系统来求解。从第一个等式约束，我们推导出 $v_{\\text{glc\\_upt}} = v_{\\text{gly}}$。将其与 $v_{\\text{glc\\_upt}}$ 和 $v_{\\text{gly}}$ 的边界结合，我们得到糖酵解通量的一个有效边界：\n$$0 \\le v_{\\text{gly}} \\le G$$\n\n接下来，我们重排第二个等式约束以用其他通量表达目标变量 $v_{\\text{biom}}$。鉴于在所有测试案例中，生物质化学计量系数 $b$ 都指定为 $10$，我们可以假设 $b > 0$ 并写出：\n$$b \\, v_{\\text{biom}} = 2 v_{\\text{gly}} + y \\, v_{\\text{atp\\_syn}} - v_{\\text{maint}}$$\n$$v_{\\text{biom}} = \\frac{1}{b} (2 v_{\\text{gly}} + y \\, v_{\\text{atp\\_syn}} - v_{\\text{maint}})$$\n\n为了最大化 $v_{\\text{biom}}$，我们必须最大化该等式的右侧。该表达式是通量 $v_{\\text{gly}}$、$v_{\\text{atp\\_syn}}$ 和 $v_{\\text{maint}}$ 的线性组合。由于它们的边界是独立的，我们可以分别优化每一项：\n- $v_{\\text{gly}}$ 的系数是 $2/b$，是正数。为了最大化该表达式，我们必须最大化 $v_{\\text{gly}}$。其允许的最大值为 $G$。因此，我们设置 $v_{\\text{gly}} = G$。\n- $v_{\\text{atp\\_syn}}$ 的系数是 $y/b$。ATP 产率 $y$ 由正值给出 ($y_0=3.0$)，所以该系数是正数。我们必须最大化 $v_{\\text{atp\\_syn}}$，将其设置为其上界 $S$。\n- $v_{\\text{maint}}$ 的系数是 $-1/b$，是负数。为了最大化该表达式，我们必须最小化 $v_{\\text{maint}}$。其允许的最小值为 $M$。因此，我们设置 $v_{\\text{maint}} = M$。\n\n将这些最优选择代入 $v_{\\text{biom}}$ 的表达式中，得到最大潜在生物质通量：\n$$v_{\\text{biom}}^{\\text{potential}} = \\frac{2G + yS - M}{b}$$\n然而，我们还必须满足非负约束 $v_{\\text{biom}} \\ge 0$。如果营养物供应 ($G, S$) 不足以满足维持能量需求 ($M$)，分子可能为负，这对于生物质生产是生物学上不可行的。因此，真正的最优生物质通量 $v_{\\text{biom}}^{\\star}$ 是 $0$ 和潜在值中的最大值：\n$$v_{\\text{biom}}^{\\star}(y) = \\max \\left( 0, \\frac{2G + yS - M}{b} \\right)$$\n这个公式为给定参数集 $(G, S, M, b, y)$ 提供了最优生物质通量的解析解。\n\n所要求的计算是当 $y$ 从 $y_0$ 变为 $y_1 = 1.10 \\, y_0$ 时，这个最优通量的变化：\n$$\\Delta v_{\\text{biom}}^{\\star} = v_{\\text{biom}}^{\\star}(1.10 \\, y_0) - v_{\\text{biom}}^{\\star}(y_0)$$\n代入推导出的 $v_{\\text{biom}}^{\\star}(y)$ 表达式：\n$$\\Delta v_{\\text{biom}}^{\\star} = \\max \\left( 0, \\frac{2G + (1.10 \\, y_0)S - M}{b} \\right) - \\max \\left( 0, \\frac{2G + y_0 S - M}{b} \\right)$$\n对每个测试案例实施这个最终表达式以获得数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Flux Balance Analysis problem for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (G, S, M, b, y0).\n    test_cases = [\n        (5.0, 2.0, 3.0, 10.0, 3.0),\n        (5.0, 0.0, 3.0, 10.0, 3.0),\n        (1.0, 1.0, 5.0, 10.0, 3.0),\n        (0.0, 4.0, 10.0, 10.0, 3.0),\n        (2.0, 5.0, 1.0, 10.0, 3.0),\n    ]\n\n    results = []\n\n    def calculate_v_biom_star(G, S, M, b, y):\n        \"\"\"\n        Calculates the optimal biomass flux based on the derived analytical solution.\n\n        The formula is v_biom* = max(0, (2*G + y*S - M) / b).\n\n        Args:\n            G (float): Maximum glucose uptake rate.\n            S (float): Maximum ATP synthase flux.\n            M (float): Minimum maintenance ATP requirement.\n            b (float): Stoichiometric coefficient for biomass in energy balance.\n            y (float): ATP yield coefficient.\n\n        Returns:\n            float: The optimal biomass flux v_biom*.\n        \"\"\"\n        # The parameter b is assumed > 0 from the problem context.\n        # If b were 0, the problem would be ill-defined (unbounded or infeasible).\n        numerator = 2 * G + y * S - M\n        v_biom_potential = numerator / b\n        \n        # The biomass flux cannot be negative.\n        return np.maximum(0, v_biom_potential)\n\n    for case in test_cases:\n        G, S, M, b, y0 = case\n        \n        # ATP yield in the perturbed model\n        y1 = 1.10 * y0\n        \n        # Calculate optimal biomass for baseline and perturbed models\n        v_biom_star_y0 = calculate_v_biom_star(G, S, M, b, y0)\n        v_biom_star_y1 = calculate_v_biom_star(G, S, M, b, y1)\n        \n        # Calculate the change in optimal biomass flux\n        delta_v_biom_star = v_biom_star_y1 - v_biom_star_y0\n        \n        results.append(delta_v_biom_star)\n\n    # Format results to six decimal places as strings.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2390880"}, {"introduction": "现在，让我们从分析一个给定的模型，转向从零开始构建模型来探究一个真实的生物学问题。在本练习中，你将构建一个包含多种碳源的代谢模型，并利用FBA来预测细胞会优先选择哪种底物，从而模拟分解代谢物阻遏现象。这项实践展示了FBA的预测能力，并为你架起一座从生物学假说到模型驱动的定量预测之间的桥梁。[@problem_id:2390906]", "problem": "你的任务是实现一个完整、可运行的程序，该程序使用通量平衡分析 (FBA) 来预测细胞将首先消耗几种可用碳源中的哪一种。其假设基础是，分解代谢物阻遏调控机制会选择能产生最高最大生长速率的底物。你的实现必须从基本原理出发：稳态质量平衡和线性规划，不使用任何快捷公式。你将编码一个简化的、科学上合理的代谢网络，该网络追踪一个碳前体池和三磷酸腺苷 (ATP)，并且你将为每组给定的底物和环境边界，根据其在单一底物条件下的最大生物质生产速率，确定哪种底物会被优先选择。\n\n基本原理。通量平衡分析 (FBA) 假设细胞内代谢物浓度处于稳态，因此每种内部代谢物的净生成量为零。如果 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量向量，则稳态约束为 $S v = 0$。每个通量 $v_j$ 都受下界和上界的约束，并优化一个目标（此处为生物质生产）。求解一个线性规划 (LP) 问题，即在满足质量平衡和边界约束的条件下，最大化生物质反应通量。\n\n网络定义。使用以下内部代谢物：葡萄糖（内部）$glc_c$、乙酸盐（内部）$ac_c$、甘油（内部）$glyc_c$、氧气（内部）$o2_c$、二氧化碳（内部）$co2_c$、一个通用碳前体池 $C_c$ 和 ATP $atp_c$。以下反应构成了该网络，并写出了内部代谢物的化学计量系数：\n\n- 底物和氧气的输入（具有上界的边界源）：\n    - $r_0$: $\\emptyset \\rightarrow glc_c$\n    - $r_1$: $\\emptyset \\rightarrow ac_c$\n    - $r_2$: $\\emptyset \\rightarrow glyc_c$\n    - $r_3$: $\\emptyset \\rightarrow o2_c$\n\n- 二氧化碳的输出（具有上界的边界汇）：\n    - $r_4$: $co2_c \\rightarrow \\emptyset$\n\n- 同化和能量生成的内部反应（不可逆，非负通量）：\n    - $r_5$: $glc_c \\rightarrow 6\\, C_c + 2\\, atp_c$\n    - $r_6$: $glyc_c \\rightarrow 3\\, C_c + 1\\, atp_c$\n    - $r_7$: $ac_c \\rightarrow 2\\, C_c$\n    - $r_8$: $C_c + o2_c \\rightarrow co2_c + 10\\, atp_c$ （有氧呼吸）\n    - $r_9$: $C_c \\rightarrow co2_c + 2\\, atp_c$ （发酵，厌氧 ATP 生成）\n\n- 生物质合成（目标反应，不可逆）：\n    - $r_{10}$: $5\\, C_c + 20\\, atp_c \\rightarrow \\text{biomass}$\n\n必须对内部代谢物 $glc_c$、$ac_c$、$glyc_c$、$o2_c$、$co2_c$、$C_c$ 和 $atp_c$ 强制执行稳态质量平衡。生物质池不是一个平衡的代谢物；其生产通量 $v_{10}$ 是要最大化的目标。\n\n边界。所有内部反应通量都是非负的，即对于 $j \\in \\{5,6,7,8,9,10\\}$，$v_j \\ge 0$。二氧化碳输出 $r_4$ 的边界为 $0 \\le v_4 \\le 1000$。对于输入 $r_0$、$r_1$、$r_2$ 和 $r_3$，边界为 $0 \\le v_j \\le U_j$，其中 $U_0 = U_{\\mathrm{glc}}$、$U_1 = U_{\\mathrm{ac}}$、$U_2 = U_{\\mathrm{glyc}}$ 和 $U_3 = U_{\\mathrm{O2}}$。所有速率都应解释为 mmol/克干重/小时，但最终程序的输出将是如下规定的无量纲整数。\n\n计算任务。给定一组具有指定输入边界的可用碳源和一个氧气输入边界，根据以下决策规则预测哪种单一碳源将被首先消耗：对于集合中的每种可用碳源 $s$，通过求解 FBA 问题来计算最大生物质通量 $v_{10}^{(s)}$。求解时，仅将该碳源的输入边界设置为其指定的 $U_s$（在该次运行中，所有其他碳源输入边界均设置为 $0$），并遵守给定的氧气边界 $U_{\\mathrm{O2}}$。优先选择的碳源是产生最大生物质通量的那一个。如果在 $10^{-7}$ 的数值容差内出现平局，则根据以下映射选择索引最小的碳源。\n\n碳源索引映射：\n- 葡萄糖 $\\mapsto 0$\n- 乙酸盐 $\\mapsto 1$\n- 甘油 $\\mapsto 2$\n\n测试套件。你的程序必须硬编码并处理以下五个测试用例。对于每个用例，都给出了葡萄糖 $U_{\\mathrm{glc}}$、乙酸盐 $U_{\\mathrm{ac}}$、甘油 $U_{\\mathrm{glyc}}$ 和氧气 $U_{\\mathrm{O2}}$ 的输入边界。在一个用例中，当且仅当一个碳源的 $U_s > 0$ 时，它被认为是可用的。\n\n- 用例 A（氧气充足，葡萄糖和乙酸盐可用）：$U_{\\mathrm{glc}} = 10$，$U_{\\mathrm{ac}} = 10$，$U_{\\mathrm{glyc}} = 0$，$U_{\\mathrm{O2}} = 1000$。\n- 用例 B（氧气充足，乙酸盐和甘油可用）：$U_{\\mathrm{glc}} = 0$，$U_{\\mathrm{ac}} = 10$，$U_{\\mathrm{glyc}} = 10$，$U_{\\mathrm{O2}} = 1000$。\n- 用例 C（氧气受限，三种都可用）：$U_{\\mathrm{glc}} = 10$，$U_{\\mathrm{ac}} = 10$，$U_{\\mathrm{glyc}} = 10$，$U_{\\mathrm{O2}} = 3$。\n- 用例 D（厌氧，三种都可用）：$U_{\\mathrm{glc}} = 10$，$U_{\\mathrm{ac}} = 10$，$U_{\\mathrm{glyc}} = 10$，$U_{\\mathrm{O2}} = 0$。\n- 用例 E（葡萄糖稀缺，甘油充足，有氧）：$U_{\\mathrm{glc}} = 2$，$U_{\\mathrm{ac}} = 0$，$U_{\\mathrm{glyc}} = 20$，$U_{\\mathrm{O2}} = 1000$。\n\n最终输出规范。你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的整数列表作为结果。该列表必须按顺序包含用例 A 到 E 的优先碳源索引。例如，输出可能看起来像 $[0,2,0,0,2]$（这只是一个示例占位符；你的程序必须计算出实际值）。", "solution": "问题陈述已被评估并被认为是有效的。这是一个在计算系统生物学中被合理阐述的问题，基于通量平衡分析 (FBA) 的既定原则。所给的代谢网络虽然简化，但科学上是合理的，并且该任务是一个可以使用线性规划解决的标准优化问题。\n\n通量平衡分析的核心原则是假设内部代谢物浓度处于伪稳态。这由质量平衡方程 $S v = 0$ 表示，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是 $m$ 种代谢物和 $n$ 个反应的化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量向量。每个通量 $v_j$ 还受到下界和上界 $l_j \\le v_j \\le u_j$ 的约束。该分析旨在优化一个细胞目标，该目标被表达为通量的线性组合 $Z = c^T v$。对于此问题，目标是最大化生物质生产速率，这对应于反应 $r_{10}$ 的通量。\n\n这构成了一个线性规划 (LP) 问题，其标准形式可以表述为：\n$$\n\\begin{aligned}\n\\text{maximize} \\quad & c^T v \\\\\n\\text{subject to} \\quad & S v = 0 \\\\\n& l \\le v \\le u\n\\end{aligned}\n$$\n\n我们必须首先为给定的代谢网络构建此 LP 问题的各个组成部分。\n\n该网络由 $m=7$ 种内部代谢物和 $n=11$ 个反应组成。让我们为每个建立一个一致的顺序。\n代谢物：\n$0$: $glc_c$ (内部葡萄糖)\n$1$: $ac_c$ (内部乙酸盐)\n$2$: $glyc_c$ (内部甘油)\n$3$: $o2_c$ (内部氧气)\n$4$: $co2_c$ (内部二氧化碳)\n$5$: $C_c$ (碳前体池)\n$6$: $atp_c$ (ATP)\n\n反应 (通量 $v_j$):\n$v_0$: $r_0: \\emptyset \\rightarrow glc_c$\n$v_1$: $r_1: \\emptyset \\rightarrow ac_c$\n$v_2$: $r_2: \\emptyset \\rightarrow glyc_c$\n$v_3$: $r_3: \\emptyset \\rightarrow o2_c$\n$v_4$: $r_4: co2_c \\rightarrow \\emptyset$\n$v_5$: $r_5: glc_c \\rightarrow 6\\, C_c + 2\\, atp_c$\n$v_6$: $r_6: glyc_c \\rightarrow 3\\, C_c + 1\\, atp_c$\n$v_7$: $r_7: ac_c \\rightarrow 2\\, C_c$\n$v_8$: $r_8: C_c + o2_c \\rightarrow co2_c + 10\\, atp_c$\n$v_9$: $r_9: C_c \\rightarrow co2_c + 2\\, atp_c$\n$v_{10}$: $r_{10}: 5\\, C_c + 20\\, atp_c \\rightarrow \\text{biomass}$\n\n大小为 $7 \\times 11$ 的化学计量矩阵 $S$ 是通过用代谢物 $i$ 在反应 $j$ 中的化学计量系数填充其条目 $S_{ij}$ 来构建的。反应物的系数为负，产物的系数为正。\n\n$$\nS =\n\\begin{pmatrix}\n% v0  v1  v2  v3  v4  v5  v6  v7  v8  v9 v10\n  1 &  0 &  0 &  0 &  0 & -1 &  0 &  0 &  0 &  0 &  0 \\\\  % glc_c\n  0 &  1 &  0 &  0 &  0 &  0 &  0 & -1 &  0 &  0 &  0 \\\\  % ac_c\n  0 &  0 &  1 &  0 &  0 &  0 & -1 &  0 &  0 &  0 &  0 \\\\  % glyc_c\n  0 &  0 &  0 &  1 &  0 &  0 &  0 &  0 & -1 &  0 &  0 \\\\  % o2_c\n  0 &  0 &  0 &  0 & -1 &  0 &  0 &  0 &  1 &  1 &  0 \\\\  % co2_c\n  0 &  0 &  0 &  0 &  0 &  6 &  3 &  2 & -1 & -1 & -5 \\\\  % C_c\n  0 &  0 &  0 &  0 &  0 &  2 &  1 &  0 & 10 &  2 & -20   % atp_c\n\\end{pmatrix}\n$$\n\n目标是最大化 $v_{10}$。因此，目标向量 $c$ 是一个在对应于 $v_{10}$ 的位置为 $1$、其余位置为零的向量。\n$$ c^T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] $$\n由于标准的 LP 求解器通常是最小化，我们将最小化 $-c^T v$。\n\n通量边界由问题陈述定义。\n- $0 \\le v_0 \\le U_{\\mathrm{glc}}$\n- $0 \\le v_1 \\le U_{\\mathrm{ac}}$\n- $0 \\le v_2 \\le U_{\\mathrm{glyc}}$\n- $0 \\le v_3 \\le U_{\\mathrm{O2}}$\n- $0 \\le v_4 \\le 1000$\n- 对于 $j \\in \\{5, 6, 7, 8, 9, 10\\}$，$v_j \\ge 0$。这些内部通量的上界实际上是无限的。\n\n计算任务要求我们处理五个测试用例。对于每个用例，我们必须确定哪种单一可用碳源（葡萄糖、乙酸盐或甘油）能产生最高的生物质最大生产速率 $v_{10}$。如果一个碳源的摄取上限 $U_s > 0$，则该碳源是可用的。每个测试用例的流程如下：\n\n1.  根据非零的摄取上限，确定可用碳源的集合。碳源映射到索引：葡萄糖 $\\mapsto 0$，乙酸盐 $\\mapsto 1$，甘油 $\\mapsto 2$。\n\n2.  对于每种可用碳源 $s$，求解一个独立的 FBA 问题：\n    a. 将碳源 $s$ 的输入通量（即 $v_0$, $v_1$, 或 $v_2$）的上界设置为其指定值 $U_s$。\n    b. 将所有其他碳源输入通量的上界设置为 $0$。这确保只消耗一种碳源。\n    c. 氧气摄取上限 $v_3$ 设置为该测试用例给定的值 $U_{\\mathrm{O2}}$。\n    d. 所有其他边界保持指定值。\n    e. 求解 LP 以找到生物质反应可能的最大通量 $v_{10}^{(s)}$。\n\n3.  比较为每种可用碳源获得的最大生物质通量。优先选择的碳源是产生最高 $v_{10}^{(s)}$ 的那一个。\n\n4.  如果两个或多个碳源产生的最大生物质通量在 $10^{-7}$ 的容差内相等，则通过选择索引最小的碳源（$0 < 1 < 2$）来打破平局。\n\n该算法将使用 Python 中的 `scipy.optimize.linprog` 函数来实现，以解决 LP 问题。对于五个测试用例中的每一个，我们将执行此过程并确定优先碳源的索引。最终输出将是这些索引的列表。\n程序将硬编码化学计量矩阵、目标向量以及五个测试用例的参数。将定义一个函数来为给定的通量边界设置并求解 LP。程序的主要部分将遍历测试用例，为每个可用的底物调用求解器函数，并应用决策逻辑来找到每个用例的最优底物。然后将结果编译并以指定格式打印。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of Flux Balance Analysis problems to determine the preferred carbon source\n    for a simplified metabolic model under different environmental conditions.\n    \"\"\"\n\n    # Stoichiometric matrix S (7 metabolites x 11 reactions)\n    # Metabolites: glc_c, ac_c, glyc_c, o2_c, co2_c, C_c, atp_c\n    # Reactions: v0-v10\n    S = np.array([\n        # v0  v1  v2  v3  v4  v5  v6  v7  v8  v9 v10\n        [ 1,  0,  0,  0,  0, -1,  0,  0,  0,  0,  0],  # glc_c\n        [ 0,  1,  0,  0,  0,  0,  0, -1,  0,  0,  0],  # ac_c\n        [ 0,  0,  1,  0,  0,  0, -1,  0,  0,  0,  0],  # glyc_c\n        [ 0,  0,  0,  1,  0,  0,  0,  0, -1,  0,  0],  # o2_c\n        [ 0,  0,  0,  0, -1,  0,  0,  0,  1,  1,  0],  # co2_c\n        [ 0,  0,  0,  0,  0,  6,  3,  2, -1, -1, -5],  # C_c\n        [ 0,  0,  0,  0,  0,  2,  1,  0, 10,  2, -20]  # atp_c\n    ], dtype=np.float64)\n\n    # Objective function: maximize v_10 (biomass).\n    # linprog minimizes, so we minimize -v_10.\n    c = np.zeros(11, dtype=np.float64)\n    c[10] = -1.0\n\n    # Steady-state constraint: Sv = 0\n    b_eq = np.zeros(7, dtype=np.float64)\n\n    # Substrate mapping: name -> (index, uptake_reaction_index)\n    substrates = {\n        'glucose': (0, 0),\n        'acetate': (1, 1),\n        'glycerol': (2, 2)\n    }\n\n    # Test cases: (U_glc, U_ac, U_glyc, U_O2)\n    test_cases = [\n        # Case A: abundant oxygen, glucose and acetate available\n        {'U_glc': 10.0, 'U_ac': 10.0, 'U_glyc': 0.0, 'U_O2': 1000.0},\n        # Case B: abundant oxygen, acetate and glycerol available\n        {'U_glc': 0.0, 'U_ac': 10.0, 'U_glyc': 10.0, 'U_O2': 1000.0},\n        # Case C: oxygen-limited, all three available\n        {'U_glc': 10.0, 'U_ac': 10.0, 'U_glyc': 10.0, 'U_O2': 3.0},\n        # Case D: anaerobic, all three available\n        {'U_glc': 10.0, 'U_ac': 10.0, 'U_glyc': 10.0, 'U_O2': 0.0},\n        # Case E: glucose scarce, glycerol abundant, aerobic\n        {'U_glc': 2.0, 'U_ac': 0.0, 'U_glyc': 20.0, 'U_O2': 1000.0}\n    ]\n\n    final_results = []\n    \n    # Process each test case\n    for case in test_cases:\n        uptake_bounds = {\n            'glucose': case['U_glc'],\n            'acetate': case['U_ac'],\n            'glycerol': case['U_glyc']\n        }\n        oxygen_bound = case['U_O2']\n        \n        # Identify available substrates for the current case\n        available_substrates = []\n        for name, u_bound in uptake_bounds.items():\n            if u_bound > 0:\n                available_substrates.append(name)\n        \n        case_results = []\n\n        # Run FBA for each available substrate individually\n        for sub_name in available_substrates:\n            sub_idx, reaction_idx = substrates[sub_name]\n            \n            # Define flux bounds for this specific FBA run\n            bounds = [(0.0, None)] * 11\n            bounds[4] = (0.0, 1000.0)\n            \n            # Set carbon source bounds: only one is allowed to be non-zero\n            for name, (idx, rxn_idx) in substrates.items():\n                if name == sub_name:\n                    bounds[rxn_idx] = (0.0, uptake_bounds[name])\n                else:\n                    bounds[rxn_idx] = (0.0, 0.0)\n\n            # Set oxygen bound\n            bounds[3] = (0.0, oxygen_bound)\n            \n            # Solve the linear programming problem\n            res = linprog(c, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n            \n            max_biomass = 0.0\n            if res.success:\n                max_biomass = -res.fun\n            \n            case_results.append({'biomass': max_biomass, 'index': sub_idx})\n\n        # Determine the preferred substrate based on max biomass and tie-breaking rule\n        if not case_results:\n            # Should not happen with the given test cases, but good practice\n            # If no substrate is available, there's no preferred one.\n            # We can represent this with a placeholder like -1, but the problem\n            # guarantees at least one source.\n            continue\n            \n        max_biomass_val = -1.0\n        for r in case_results:\n            if r['biomass'] > max_biomass_val:\n                max_biomass_val = r['biomass']\n\n        # Find all substrates that achieve the max biomass within tolerance\n        tied_winners = [r for r in case_results if abs(r['biomass'] - max_biomass_val) < 1e-7]\n        \n        # Tie-break by choosing the one with the smallest index\n        best_substrate_idx = min(r['index'] for r in tied_winners)\n        final_results.append(best_substrate_idx)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2390906"}, {"introduction": "掌握了构建和优化模型的技能后，你现在可以运用FBA进行系统的网络分析，例如识别关键反应。本练习将引入“瓶颈”反应的概念——这类反应的缺失会导致某种前体代谢物无法被消耗而积累，从而可能中断网络功能。通过模拟单个反应的“敲除”，你将学会一种在药物靶点识别和必需基因预测中广泛应用的强大技术。[@problem_id:2390901]", "problem": "给定一系列稳态代谢网络，要求您针对一个特定的前体代谢物，识别出哪些是“瓶颈”消耗反应，删除这些反应将导致该前体物的累积。请基于第一性原理，在标准的通量平衡分析（FBA）框架下完成此任务。\n\n使用以下基本原理：\n- 稳态质量平衡由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 和通量向量 $v \\in \\mathbb{R}^{n}$ 通过以下线性约束表示：\n$$\nS\\,v = 0.\n$$\n- 每个反应 $j \\in \\{0,1,\\dots,n-1\\}$ 都有通量下界和上界 $l_j \\le v_j \\le u_j$，这些界限被收集为向量 $l, u \\in \\mathbb{R}^{n}$。\n- 为了表示特定的前体代谢物 $m^{\\star}$ 由环境或上游模块以严格为正的速率供应，一个指定的“来源反应” $s$ 必须满足以下边界条件：\n$$\nv_s \\ge p_{\\min},\n$$\n其中 $p_{\\min} > 0$ 是一个给定的常数。所有反应指数均从零开始，即 $\\{0,1,\\dots,n-1\\}$。\n\n本任务中使用的 $m^{\\star}$ 的瓶颈消耗反应的定义：\n- 一个反应 $r$ 是 $m^{\\star}$ 的候选消耗反应，当且仅当其化学计量系数 $S_{m^{\\star}, r} < 0$ 且上界 $u_r > 0$（因此在方向和容量上都可能进行消耗）。\n- 一个候选消耗反应 $r$ 是 $m^{\\star}$ 的瓶颈点，如果以下两个条件成立：\n  1. 在强制 $m^{\\star}$ 以至少 $p_{\\min}$ 的速率生产的情况下，基线模型是可行的，即存在 $v$ 使得 $S v = 0$, $l \\le v \\le u$, 且 $v_s \\ge p_{\\min}$。\n  2. 在删除反应 $r$（通过强制 $v_r = 0$，即设置 $l_r = u_r = 0$）而保持所有其他约束不变后，模型变得不可行。\n直观地讲，如果在强制 $m^{\\star}$ 以严格正速率生产的条件下，删除反应 $r$ 会破坏稳态可行性，那么网络将无法足够地消耗 $m^{\\star}$，这在任何动态松弛中都会导致其累积。\n\n您的任务：\n- 对于下面的每个测试用例，确定指定 $m^{\\star}$ 的所有瓶颈消耗反应的排序索引列表（从零开始）。\n- 如果某个测试用例的基线模型（在 $v_s \\ge p_{\\min}$ 条件下）不可行，则该用例返回空列表。\n\n测试套件：\n对于每个用例，您将获得矩阵 $S$、边界向量 $l$ 和 $u$、目标代谢物行的索引 $m^{\\star}$、来源反应的索引 $s$ 以及值 $p_{\\min}$。所有条目均为实数。符号 $\\mathrm{DM}$ 表示一个通用的流出/输出反应，用于维持稳态，建模为一个消耗指定代谢物的反应。\n\n- 用例 A（单个消耗反应必须承担所有产量）：\n  - 代谢物排序为 $[M,\\;B]$，反应排序为 $[R_0,R_1,R_2]$，其中 $R_0$ 是产生 $M$ 的摄取反应，$R_1$ 将 $M \\rightarrow B$ 转化，$R_2$ 是对 $B$ 的需求反应。\n  - 化学计量：\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1 & -1 & 0 \\\\\n    0  & +1 & -1\n    \\end{bmatrix}.\n    $$\n  - 边界：\n    $$\n    l = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\end{bmatrix}.\n    $$\n  - 目标代谢物索引 $m^{\\star} = 0$（$M$ 所在的行），来源反应索引 $s = 0$，以及 $p_{\\min} = 1$。\n\n- 用例 B（两个平行的消耗反应，任何一个都足够）：\n  - 代谢物排序为 $[M,\\;B_1,\\;B_2]$，反应排序为 $[R_0,R_1,R_2,R_3,R_4]$，其中 $R_0$ 是产生 $M$ 的摄取反应，$R_1$ 将 $M \\rightarrow B_1$ 转化，$R_2$ 将 $M \\rightarrow B_2$ 转化，$R_3,R_4$ 分别是对 $B_1,B_2$ 的需求反应。\n  - 化学计量：\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1 & -1 & -1 & 0  & 0 \\\\\n    0  & +1 & 0   & -1 & 0 \\\\\n    0  & 0  & +1  & 0  & -1\n    \\end{bmatrix}.\n    $$\n  - 边界：\n    $$\n    l = \\begin{bmatrix} 2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\\\ 10 \\\\ 10 \\end{bmatrix}.\n    $$\n  - 目标代谢物索引 $m^{\\star} = 0$（$M$ 所在的行），来源反应索引 $s = 0$，以及 $p_{\\min} = 2$。\n\n- 用例 C（单个可逆的消耗反应）：\n  - 代谢物排序为 $[M,\\;X]$，反应排序为 $[R_0,R_1,R_2]$，其中 $R_0$ 是产生 $M$ 的摄取反应，$R_1$ 是可逆的相互转化反应 $M \\rightleftharpoons X$，$R_2$ 是对 $X$ 的需求反应。\n  - 化学计量：\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1 & -1 & 0 \\\\\n    0  & +1 & -1\n    \\end{bmatrix}.\n    $$\n  - 边界：\n    $$\n    l = \\begin{bmatrix} 1 \\\\ -10 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\end{bmatrix}.\n    $$\n  - 目标代谢物索引 $m^{\\star} = 0$，来源反应索引 $s = 0$，以及 $p_{\\min} = 1$。\n\n- 用例 D（容量受限的备用消耗反应）：\n  - 代谢物排序为 $[M]$，反应排序为 $[R_0,R_1,R_2]$，其中 $R_0$ 是产生 $M$ 的摄取反应，$R_1,R_2$ 是 $M$ 的两个不同流出反应。\n  - 化学计量：\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1 & -1 & -1\n    \\end{bmatrix}.\n    $$\n  - 边界：\n    $$\n    l = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 1 \\\\ 0.6 \\end{bmatrix}.\n    $$\n  - 目标代谢物索引 $m^{\\star} = 0$，来源反应索引 $s = 0$，以及 $p_{\\min} = 1$。\n\n- 用例 E（基线不可行：不存在消耗反应）：\n  - 代谢物排序为 $[M]$，反应排序为 $[R_0]$，其中 $R_0$ 是产生 $M$ 的摄取反应。\n  - 化学计量：\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1\n    \\end{bmatrix}.\n    $$\n  - 边界：\n    $$\n    l = \\begin{bmatrix} 1 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\end{bmatrix}.\n    $$\n  - 目标代谢物索引 $m^{\\star} = 0$，来源反应索引 $s = 0$，以及 $p_{\\min} = 1$。\n\n最终输出格式：\n- 您的程序必须输出一行，其中包含一个结果列表，每个测试用例一个结果，按顺序聚合为方括号括起来的逗号分隔列表。\n- 每个结果本身必须是该测试用例的瓶颈消耗反应的从零开始的反应索引列表，按升序排列。\n- 因此，最终打印的行必须看起来像\n$$\n[\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]\n$$\n不含空格。例如，一个有效的输出可能是\n$$\n[[1],[],[1],[1],[]]\n$$\n如果这些分别是 A 到 E 各个用例的结果。", "solution": "我们从通量平衡分析（FBA）的稳态假设出发，该假设施加了线性约束 $S v = 0$ 以及通量边界 $l \\le v \\le u$。对于某个特定的前体代谢物 $m^{\\star}$，问题要求我们识别出那些删除后会导致 $m^{\\star}$ 累积的反应。由于FBA不显式地对动态累积进行建模（它强制执行 $S v = 0$），我们转而通过要求一个指定的来源反应 $s$ 满足 $v_s \\ge p_{\\min}$（对于给定的 $p_{\\min} > 0$）来强制 $m^{\\star}$ 以一个严格为正的速率生产。如果在删除了一个反应 $r$ 之后，模型在这些约束下变得不可行，那么在 $v_s \\ge p_{\\min}$ 的条件下就不可能维持稳态，这意味着在任何动态松弛中 $m^{\\star}$ 都会累积（因为系统无法充分消耗它以平衡其强制生产）。这是在静态FBA框架内诊断累积风险的标准方法。\n\n我们将瓶颈点标准形式化如下。一个反应 $r$ 是候选消耗反应，如果 $S_{m^{\\star}, r} < 0$ 且 $u_r > 0$，这意味着该反应可以在其容量范围内正向消耗 $m^{\\star}$。那么，$r$ 是一个瓶颈点，如果：\n1. 基线可行性问题有解：\n$$\n\\text{寻找 } v \\in \\mathbb{R}^{n} \\text{ 使得 } S v = 0,\\quad l \\le v \\le u,\\quad v_s \\ge p_{\\min}.\n$$\n2. 将反应 $r$ 删除后（即用 $l_r = u_r = 0$ 替换边界）的修改后的可行性问题没有解。\n\n这产生了一个纯粹的可行性检查问题。在计算上，这可以实现为一个目标为零的线性规划，即在上述约束条件下最小化 $0$。一个现代的线性规划求解器可以为每个情况确定可行性。\n\n算法设计：\n- 对每个测试用例，构建矩阵 $S$、边界 $l, u$、目标索引 $m^{\\star}$、来源索引 $s$ 和标量 $p_{\\min}$。\n- 通过将索引 $s$ 处的下界提高到至少 $p_{\\min}$ 来定义基线边界，即用 $\\max(l_s, p_{\\min})$ 替换 $l_s$。求解线性规划：\n$$\n\\min\\ 0 \\quad \\text{s.t. } S v = 0,\\; l \\le v \\le u.\n$$\n如果不可行，则为此用例返回空列表。\n- 否则，形成候选消耗反应列表 $\\mathcal{C} = \\{ r \\in \\{0,\\dots,n-1\\} \\mid S_{m^{\\star}, r} < 0 \\text{ 且 } u_r > 0 \\}$。\n- 对于每个 $r \\in \\mathcal{C}$，用 $l_r = u_r = 0$ 构建修改后的边界，并重新解决可行性问题。如果不可行，则将 $r$ 添加到瓶颈点集合中。\n- 返回排序后的瓶颈点索引列表。\n\n为什么这在所述定义下是正确的：\n- 如果基线不可行，那么无论是否删除反应，网络都无法在强制生产的情况下维持稳态；我们按规定返回空列表。\n- 如果删除 $r$ 使系统不可行，则在强制 $v_s \\ge p_{\\min}$ 的情况下，没有办法满足 $S v = 0$；$m^{\\star}$ 无法被网络的其余部分充分消耗。因此，在任何动态解释中 $m^{\\star}$ 都会累积，而 $r$ 是一个瓶颈点。\n- 相反，如果删除 $r$ 后系统仍然可行，则存在一个能够平衡强制生产的稳态通量向量；因此不会有强制累积。\n\n现在我们分析给定的用例。\n\n用例 A:\n- $S$ 和边界允许 $v_0 \\ge 1$，$v_1$ 将 $M$ 转化为 $B$，$v_2$ 流出 $B$。$M$ 的质量平衡要求 $v_0 - v_1 = 0$，因此 $v_1 = v_0 \\ge 1$ 在 $u_1 = 10$ 的范围内是可行的。$M$ 的唯一候选消耗反应是 $R_1$（索引 1）。删除 $R_1$ 会强制 $v_1 = 0$，这使得 $v_0 - v_1 = v_0 \\ge 1$ 无法平衡。因此，修改后的系统不可行。瓶颈点集合是 $[1]$。\n\n用例 B:\n- 基线要求 $v_0 \\ge 2$ 和 $v_1 + v_2 = v_0$，其中 $v_1, v_2 \\le 10$，以及流出反应 $v_3 = v_1$，$v_4 = v_2$。这是可行的。$M$ 的消耗反应是 $R_1$（索引 1）和 $R_2$（索引 2）。删除其中任何一个，另一个仍能在其容量范围内承载全部的 $v_0 \\ge 2$，因此可行性得以保持。瓶颈点集合是 $[]$。\n\n用例 C:\n- 基线：$v_0 \\ge 1$，$M$ 的质量平衡给出 $v_1 = v_0$，$X$ 的质量平衡给出 $v_2 = v_1$，这在 $v_1 \\in [-10,10]$ 和 $v_2 \\in [0,10]$ 的范围内是可行的。$M$ 的唯一消耗反应是 $R_1$（索引 1）。删除 $R_1$ 会强制 $v_1 = 0$，从而 $v_0 = 0$，与 $v_0 \\ge 1$ 相矛盾，导致不可行性。瓶颈点集合是 $[1]$。\n\n用例 D:\n- 基线：$v_0 \\ge 1$ 且 $v_1 + v_2 = v_0$，$0 \\le v_1 \\le 1$，$0 \\le v_2 \\le 0.6$。存在可行的选择，例如，$v_1 = 0.4$，$v_2 = 0.6$，$v_0 = 1$。消耗反应是 $R_1$（索引 1）和 $R_2$（索引 2）。删除 $R_1$ 后，剩下的 $v_2 \\le 0.6$ 无法平衡 $v_0 \\ge 1$，导致不可行；删除 $R_2$ 仍然允许 $v_1 = 1$ 来平衡。因此，瓶颈点集合是 $[1]$。\n\n用例 E:\n- 基线：$v_0 \\ge 1$ 但没有消耗反应，所以无法满足 $S v = 0$。根据定义，基线是不可行的，所以结果是空列表 $[]$。\n\n因此，用例 A 到 E 的聚合结果是\n$$\n[[1],[],[1],[1],[]].\n$$\n\n程序通过目标为零的线性规划实现可行性检查，并以要求的单行、无空格格式打印最终的聚合列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\nfrom scipy.optimize import linprog\n\ndef is_feasible(S, l_bounds, u_bounds):\n    \"\"\"\n    Check feasibility of S v = 0 with bounds l <= v <= u by minimizing a zero objective.\n    Returns True if feasible, False otherwise.\n    \"\"\"\n    m, n = S.shape\n    c = np.zeros(n)\n    A_eq = S\n    b_eq = np.zeros(m)\n    bounds = list(zip(l_bounds, u_bounds))\n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=\"highs\")\n    return res.status == 0\n\ndef find_choke_points(S, l, u, m_star, s_idx, p_min):\n    \"\"\"\n    Identify choke-point consumers for metabolite m_star.\n    - Enforce baseline feasibility with v_s >= p_min (raise l_s if needed).\n    - Candidate consumers r satisfy S[m_star, r] < 0 and u[r] > 0.\n    - r is a choke-point if deleting r (setting its bounds to 0) makes the system infeasible.\n    Returns sorted list of reaction indices.\n    \"\"\"\n    S = np.array(S, dtype=float)\n    l = np.array(l, dtype=float)\n    u = np.array(u, dtype=float)\n\n    # Enforce the minimal production bound at the source reaction\n    l_base = l.copy()\n    l_base[s_idx] = max(l_base[s_idx], p_min)\n\n    # Baseline feasibility check\n    if not is_feasible(S, l_base, u):\n        return []\n\n    # Identify candidate consumers for m_star\n    consumers = [j for j in range(S.shape[1]) if S[m_star, j] < 0 and u[j] > 0]\n\n    choke = []\n    for r in consumers:\n        l_mod = l_base.copy()\n        u_mod = u.copy()\n        # Delete reaction r\n        l_mod[r] = 0.0\n        u_mod[r] = 0.0\n        if not is_feasible(S, l_mod, u_mod):\n            choke.append(r)\n\n    return sorted(choke)\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A\n    S_A = np.array([\n        [ +1, -1,  0],\n        [  0, +1, -1],\n    ], dtype=float)\n    l_A = np.array([1, 0, 0], dtype=float)\n    u_A = np.array([10, 10, 10], dtype=float)\n    m_star_A = 0\n    s_A = 0\n    pmin_A = 1\n\n    # Case B\n    S_B = np.array([\n        [ +1, -1, -1,  0,  0],\n        [  0, +1,  0, -1,  0],\n        [  0,  0, +1,  0, -1],\n    ], dtype=float)\n    l_B = np.array([2, 0, 0, 0, 0], dtype=float)\n    u_B = np.array([10,10,10,10,10], dtype=float)\n    m_star_B = 0\n    s_B = 0\n    pmin_B = 2\n\n    # Case C\n    S_C = np.array([\n        [ +1, -1,  0],\n        [  0, +1, -1],\n    ], dtype=float)\n    l_C = np.array([1, -10, 0], dtype=float)\n    u_C = np.array([10, 10, 10], dtype=float)\n    m_star_C = 0\n    s_C = 0\n    pmin_C = 1\n\n    # Case D\n    S_D = np.array([\n        [ +1, -1, -1],\n    ], dtype=float)\n    l_D = np.array([1, 0, 0], dtype=float)\n    u_D = np.array([10, 1, 0.6], dtype=float)\n    m_star_D = 0\n    s_D = 0\n    pmin_D = 1\n\n    # Case E\n    S_E = np.array([\n        [ +1 ],\n    ], dtype=float)\n    l_E = np.array([1], dtype=float)\n    u_E = np.array([10], dtype=float)\n    m_star_E = 0\n    s_E = 0\n    pmin_E = 1\n\n    test_cases = [\n        (S_A, l_A, u_A, m_star_A, s_A, pmin_A),\n        (S_B, l_B, u_B, m_star_B, s_B, pmin_B),\n        (S_C, l_C, u_C, m_star_C, s_C, pmin_C),\n        (S_D, l_D, u_D, m_star_D, s_D, pmin_D),\n        (S_E, l_E, u_E, m_star_E, s_E, pmin_E),\n    ]\n\n    results = []\n    for S, l, u, m_star, s_idx, p_min in test_cases:\n        choke_list = find_choke_points(S, l, u, m_star, s_idx, p_min)\n        results.append(choke_list)\n\n    # Final print statement in the exact required format: no spaces.\n    print(json.dumps(results, separators=(',',':')))\n\nsolve()\n```", "id": "2390901"}]}