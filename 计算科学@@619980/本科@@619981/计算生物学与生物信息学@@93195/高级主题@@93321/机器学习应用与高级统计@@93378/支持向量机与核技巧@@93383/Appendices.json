{"hands_on_practices": [{"introduction": "本练习提供了一个具体、基于计算的视角，帮助你深入了解支持向量机（SVM）的“黑箱”。通过解决一个简单的对称案例 [@problem_id:2433176]，你将对径向基函数（RBF）核以及支持向量如何共同定义决策边界建立起扎实的直觉。这个实践的核心在于理解SVM的决策函数 $f(\\mathbf{x})$ 如何结合支持向量的影响，并通过核函数进行加权。", "problem": "一个细菌学实验室构建了一个二元分类器，使用支持向量机 (SVM) 和径向基函数 (RBF) 核来区分致病菌种和共生菌种。每个菌种的特征表示是源自基因组汇总统计数据的一个 $2$ 维空间中的点。训练集恰好由 $2$ 个带标签的样本组成：一个位于 $\\mathbf{x}_{1} = (1, 1)$ 的致病菌，其标签为 $y_{1} = +1$；以及一个位于 $\\mathbf{x}_{2} = (-1, -1)$ 的共生菌，其标签为 $y_{2} = -1$。该 SVM 使用 RBF 核\n$$\nK(\\mathbf{x}, \\mathbf{z}) = \\exp\\!\\big(-\\gamma \\|\\mathbf{x} - \\mathbf{z}\\|^{2}\\big),\n$$\n其中核参数 $\\gamma > 0$，并采用标准的硬间隔公式（即，在诱导的特征空间中是可分情况）。设得到的决策函数为\n$$\nf(\\mathbf{x}) = \\sum_{i=1}^{2} \\alpha_{i} y_{i} K(\\mathbf{x}_{i}, \\mathbf{x}) + b,\n$$\n其中对偶变量 $\\alpha_{i}$ 和偏置 $b$ 由硬间隔 SVM 优化确定。\n\n计算决策函数在查询点 $\\mathbf{x}_{\\ast} = (0, 0)$ 处的精确值，结果表示为关于 $\\gamma$ 的闭式解析表达式。将最终答案表示为单个简化表达式。无需四舍五入，也不涉及单位。", "solution": "对于二元标签 $y_{i} \\in \\{-1, +1\\}$ 和核 $K$，硬间隔支持向量机 (SVM) 的对偶优化问题为\n$$\n\\max_{\\boldsymbol{\\alpha} \\in \\mathbb{R}^{2}} \\; W(\\boldsymbol{\\alpha}) = \\sum_{i=1}^{2} \\alpha_{i} - \\frac{1}{2} \\sum_{i=1}^{2} \\sum_{j=1}^{2} \\alpha_{i} \\alpha_{j} y_{i} y_{j} K(\\mathbf{x}_{i}, \\mathbf{x}_{j}),\n$$\n约束条件为，对所有 $i$ 都有 $\\alpha_{i} \\ge 0$，以及等式约束\n$$\n\\sum_{i=1}^{2} \\alpha_{i} y_{i} = 0.\n$$\n决策函数为\n$$\nf(\\mathbf{x}) = \\sum_{i=1}^{2} \\alpha_{i} y_{i} K(\\mathbf{x}_{i}, \\mathbf{x}) + b,\n$$\n其中 $b$ 由 Karush–Kuhn–Tucker (KKT) 条件确定。在硬间隔情况下，该条件要求对于任意支持向量 $\\mathbf{x}_{i}$，\n$$\ny_{i} f(\\mathbf{x}_{i}) = 1.\n$$\n\n计算核矩阵的元素。对于参数为 $\\gamma > 0$ 的径向基函数 (RBF) 核，\n$$\nK(\\mathbf{x}_{1}, \\mathbf{x}_{1}) = \\exp\\!\\big(-\\gamma \\|\\mathbf{x}_{1} - \\mathbf{x}_{1}\\|^{2}\\big) = \\exp(0) = 1,\n$$\n$$\nK(\\mathbf{x}_{2}, \\mathbf{x}_{2}) = \\exp\\!\\big(-\\gamma \\|\\mathbf{x}_{2} - \\mathbf{x}_{2}\\|^{2}\\big) = 1.\n$$\n$\\mathbf{x}_{1} = (1, 1)$ 与 $\\mathbf{x}_{2} = (-1, -1)$ 之间的平方距离为\n$$\n\\|\\mathbf{x}_{1} - \\mathbf{x}_{2}\\|^{2} = (1 - (-1))^{2} + (1 - (-1))^{2} = 2^{2} + 2^{2} = 8,\n$$\n所以\n$$\nK(\\mathbf{x}_{1}, \\mathbf{x}_{2}) = K(\\mathbf{x}_{2}, \\mathbf{x}_{1}) = \\exp(-8 \\gamma).\n$$\n\n根据等式约束 $\\sum_{i=1}^{2} \\alpha_{i} y_{i} = 0$ 和问题的对称性，最优解满足 $\\alpha_{1} = \\alpha_{2} = a$，其中某个 $a \\ge 0$。将其代入对偶目标函数：\n\\begin{align*}\nW(a) &= \\alpha_{1} + \\alpha_{2} - \\frac{1}{2}\\Big( \\alpha_{1}^{2} y_{1}^{2} K_{11} + 2 \\alpha_{1} \\alpha_{2} y_{1} y_{2} K_{12} + \\alpha_{2}^{2} y_{2}^{2} K_{22} \\Big) \\\\\n&= 2 a - \\frac{1}{2}\\Big( a^{2} \\cdot 1 \\cdot 1 + 2 a^{2} \\cdot (+1)(-1) K_{12} + a^{2} \\cdot 1 \\cdot 1 \\Big) \\\\\n&= 2 a - \\frac{1}{2}\\Big( a^{2} + a^{2} - 2 a^{2} K_{12} \\Big) \\\\\n&= 2 a - a^{2} \\big(1 - K_{12}\\big),\n\\end{align*}\n其中 $K_{12} = \\exp(-8 \\gamma)$。对 $a$ 求导并令其等于零：\n$$\n\\frac{\\mathrm{d} W}{\\mathrm{d} a} = 2 - 2 a \\big(1 - K_{12}\\big) = 0 \\quad \\Longrightarrow \\quad a = \\frac{1}{1 - K_{12}} = \\frac{1}{1 - \\exp(-8 \\gamma)}.\n$$\n因此，\n$$\n\\alpha_{1} = \\alpha_{2} = \\frac{1}{1 - \\exp(-8 \\gamma)}.\n$$\n\n根据间隔条件确定 $b$。使用 $y_{1} f(\\mathbf{x}_{1}) = 1$ 和 $y_{2} f(\\mathbf{x}_{2}) = 1$：\n\\begin{align*}\n1 &= y_{1} f(\\mathbf{x}_{1}) = (+1)\\Big( \\alpha_{1} y_{1} K_{11} + \\alpha_{2} y_{2} K_{21} + b \\Big) = a \\big( 1 - K_{12} \\big) + b, \\\\\n1 &= y_{2} f(\\mathbf{x}_{2}) = (-1)\\Big( \\alpha_{1} y_{1} K_{12} + \\alpha_{2} y_{2} K_{22} + b \\Big) = a \\big( 1 - K_{12} \\big) - b.\n\\end{align*}\n将这两个方程相加得到\n$$\n2 = 2 a \\big(1 - K_{12}\\big) \\quad \\Longrightarrow \\quad a \\big(1 - K_{12}\\big) = 1,\n$$\n这与 $a = 1/(1 - K_{12})$ 的结果一致，而将两式相减可得 $b = 0$。\n\n现在计算决策函数在 $\\mathbf{x}_{\\ast} = (0, 0)$ 处的值。计算核函数的值：\n\\begin{align*}\n\\|\\mathbf{x}_{1} - \\mathbf{x}_{\\ast}\\|^{2} &= (1 - 0)^{2} + (1 - 0)^{2} = 1^{2} + 1^{2} = 2, \\\\\n\\|\\mathbf{x}_{2} - \\mathbf{x}_{\\ast}\\|^{2} &= (-1 - 0)^{2} + (-1 - 0)^{2} = 1^{2} + 1^{2} = 2,\n\\end{align*}\n所以\n$$\nK(\\mathbf{x}_{1}, \\mathbf{x}_{\\ast}) = \\exp(-2 \\gamma), \\quad K(\\mathbf{x}_{2}, \\mathbf{x}_{\\ast}) = \\exp(-2 \\gamma).\n$$\n因此，\n\\begin{align*}\nf(\\mathbf{x}_{\\ast}) &= \\alpha_{1} y_{1} K(\\mathbf{x}_{1}, \\mathbf{x}_{\\ast}) + \\alpha_{2} y_{2} K(\\mathbf{x}_{2}, \\mathbf{x}_{\\ast}) + b \\\\\n&= a \\big( +1 \\cdot \\exp(-2 \\gamma) \\big) + a \\big( -1 \\cdot \\exp(-2 \\gamma) \\big) + 0 \\\\\n&= a \\exp(-2 \\gamma) - a \\exp(-2 \\gamma) \\\\\n&= 0.\n\\end{align*}\n因此，对于所有 $\\gamma > 0$，决策函数在 $\\mathbf{x}_{\\ast} = (0, 0)$ 处的精确值恒等于零。", "answer": "$$\\boxed{0}$$", "id": "2433176"}, {"introduction": "建立模型只是成功的一半，调试模型则是另一半。本练习 [@problem_id:2433181] 模拟了一个极端过拟合的真实场景，挑战你通过分析关键超参数的行为来推断其原因，这是任何机器学习实践者都需掌握的关键技能。这道题将帮助你深入理解模型复杂性与泛化能力之间的权衡，特别是正则化参数 $C$ 和RBF核参数 $\\gamma$ 在控制这种权衡中的作用。", "problem": "一个研究团队正在构建一个支持向量机（SVM）分类器，以根据序列衍生的特征（如 $k$-mer 频率、预测的二级结构分数和 Pfam 域计数）来预测蛋白质功能。数据集包含 $n=2000$ 个蛋白质，被划分为类别均衡的分层训练/测试集。使用标准特征缩放方法训练了一个带有径向基函数（RBF）核的支持向量机。该模型在训练集上达到了 $99\\%$ 的准确率，但在测试集上仅有 $50\\%$ 的准确率。\n\n根据带松弛变量的支持向量机（SVM）的基本定义，它最小化一个在最大间隔分离和训练误差之间进行权衡的目标，\n$$\n\\min_{\\mathbf{w},b,\\boldsymbol{\\xi}} \\ \\frac{1}{2}\\lVert \\mathbf{w}\\rVert^2 + C \\sum_{i=1}^{n} \\xi_i \n\\quad \\text{subject to} \\quad y_i\\left(\\mathbf{w}^\\top \\phi(\\mathbf{x}_i) + b\\right) \\ge 1 - \\xi_i,\\ \\xi_i \\ge 0,\n$$\n并且核技巧通过一个核函数 $k(\\mathbf{x},\\mathbf{x}')$ 替换了内积 $\\langle \\phi(\\mathbf{x}), \\phi(\\mathbf{x}') \\rangle$，其中 RBF 核定义为\n$$\nk(\\mathbf{x},\\mathbf{x}') = \\exp\\!\\left(-\\gamma \\lVert \\mathbf{x} - \\mathbf{x}' \\rVert^2\\right),\n$$\n请针对此生物信息学任务，论证其泛化能力与训练拟合度的关系。\n\n哪个超参数最可能是导致观察到的差距的原因，为什么？\n\nA. 正则化参数 $C$ 过大，因此模型会严重惩罚训练误差，缩小间隔并过拟合训练数据。\n\nB. 正则化参数 $C$ 过小，导致模型欠拟合；这解释了 $99\\%$ 的训练准确率但 $50\\%$ 的测试准确率。\n\nC. RBF 核宽度参数 $\\gamma$ 过大，因此 $k(\\mathbf{x},\\mathbf{x}')$ 变得高度局部化，决策函数变得过于复杂，实际上是记住了训练集。\n\nD. RBF 核宽度参数 $\\gamma$ 过小，导致核函数变得过于宽泛且接近线性；这解释了 $99\\%$ 的训练准确率但 $50\\%$ 的测试准确率。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知信息**\n- 机器学习任务：用于蛋白质功能预测的支持向量机（SVM）分类器。\n- 特征：$k$-mer 频率、预测的二级结构分数、Pfam 域计数。\n- 数据集大小：$n=2000$ 个蛋白质。\n- 数据划分：类别均衡的分层训练/测试集。\n- 模型：使用径向基函数（RBF）核和标准特征缩放的支持向量机。\n- 性能：训练集准确率 $99\\%$，测试集准确率 $50\\%$。\n- SVM 目标函数：$\\min_{\\mathbf{w},b,\\boldsymbol{\\xi}} \\ \\frac{1}{2}\\lVert \\mathbf{w}\\rVert^2 + C \\sum_{i=1}^{n} \\xi_i$。\n- SVM 约束条件：$y_i\\left(\\mathbf{w}^\\top \\phi(\\mathbf{x}_i) + b\\right) \\ge 1 - \\xi_i$ 和 $\\xi_i \\ge 0$。\n- 核技巧：内积 $\\langle \\phi(\\mathbf{x}), \\phi(\\mathbf{x}') \\rangle$ 被核函数 $k(\\mathbf{x},\\mathbf{x}')$ 替代。\n- RBF 核定义：$k(\\mathbf{x},\\mathbf{x}') = \\exp\\!\\left(-\\gamma \\lVert \\mathbf{x} - \\mathbf{x}' \\rVert^2\\right)$。\n- 问题：确定最可能导致观察到的性能差距的超参数，并解释原因。\n\n**步骤2：使用提取的已知信息进行验证**\n该问题具有科学依据，描述了计算生物学和机器学习中的一个标准且现实的场景。SVM 目标函数和 RBF 核的定义在数学上是正确的。观察到的现象——训练准确率（$99\\%$）和测试准确率（$50\\%$）之间的巨大差异——是严重过拟合的典型案例。对于一个类别均衡的二分类任务， $50\\%$ 的测试准确率相当于随机猜测，表明模型完全没有泛化能力。该问题定义明确，要求根据超参数 $C$ 和 $\\gamma$ 的作用，对过拟合的原因进行合乎逻辑的推断。问题陈述内容完整、客观且内部一致。\n\n**步骤3：结论与行动**\n问题有效。将推导解决方案。\n\n问题的核心是训练准确率（$99\\%$）和测试准确率（$50\\%$）之间的巨大差距。这是一个教科书式的严重过拟合的例子，模型完美地学习了训练数据（包括噪声），以至于它无法泛化到未见过的数据上。在类别均衡的情况下，$50\\%$ 的测试准确率表明模型对新数据的预测能力不比随机猜测好。我们必须分析两个超参数 $C$ 和 $\\gamma$ 的作用，以确定最可能的原因。\n\n参数 $C$ 是正则化参数。它控制着在最大化间隔和最小化训练集分类误差之间的权衡。\n- 大的 $C$ 会对被错误分类的训练样本（即 $\\xi_i > 0$ 的样本）施加高额惩罚。这迫使优化器寻找一个能够正确分类尽可能多的训练样本的决策边界，即使这需要一个复杂的边界和较小的间隔。因此，大的 $C$ 会助长过拟合。\n- 小的 $C$ 施加的惩罚较小，允许为了获得更大的间隔而错误分类更多的训练样本。这会导致一个更简单、“更软”的决策边界，如果 $C$ 过小，可能会导致欠拟合。\n\nRBF 核中的参数 $\\gamma$，$k(\\mathbf{x},\\mathbf{x}') = \\exp(-\\gamma \\lVert \\mathbf{x} - \\mathbf{x}' \\rVert^2)$，定义了单个训练样本的影响力。\n- 小的 $\\gamma$ 会导致每个支持向量的影响半径较大，因为核函数值随距离的增加而缓慢减小。最终的决策边界会很平滑，其行为类似于线性分类器。一个非常小的 $\\gamma$ 可能会导致欠拟合。\n- 大的 $\\gamma$ 会导致一个非常小的影响半径。即使对于距离支持向量中等远的点，核函数值也会迅速下降到接近零。这意味着决策函数仅受支持向量紧邻区域内的点的影响。最终的决策边界变得高度复杂和非线性，基本上是围绕训练样本的一系列小的“决策岛”。这使得模型能够“记住”训练集，导致极端过拟合。\n\n鉴于性能指标——近乎完美的训练准确率和随机猜测水平的测试准确率——模型不仅是过拟合，而且是完全没有学到可泛化的模式。虽然大的 $C$ 通过惩罚训练误差来促进过拟合，但一个非常大的 $\\gamma$ 为观察到的极端“记忆”行为提供了机制。当 $\\gamma$ 很大时，每个训练点都可以成为其自己的支持向量，在自身周围创建一个局部化的决策区域。这完美地解释了模型如何在训练集上达到 $99\\%$ 的准确率，而对于那些不落在任一训练点极近区域内的测试点则毫无预测能力。因此，对于这种特定的、灾难性的失败模式，一个过大的 $\\gamma$ 是最直接且最有说服力的解释。\n\n评估选项：\n\nA. 正则化参数 $C$ 过大，因此模型会严重惩罚训练误差，缩小间隔并过拟合训练数据。\n这个说法实际上是正确的。大的 $C$ 确实会导致过拟合。然而，它并没有像 $\\gamma$ 的效应那样，能直接解释性能崩溃到 $50\\%$（随机猜测）的极端情况。它是一个促成因素，但对于这个特定的结果来说，可能不是主要或影响最大的因素。\n\nB. 正则化参数 $C$ 过小，导致模型欠拟合；这解释了 $99\\%$ 的训练准确率但 $50\\%$ 的测试准确率。\n这个说法是自相矛盾的。小的 $C$ 会导致欠拟合，这会表现为较低的训练准确率，而不是 $99\\%$。因此，该选项是**错误的**。\n\nC. RBF 核宽度参数 $\\gamma$ 过大，因此 $k(\\mathbf{x},\\mathbf{x}')$ 变得高度局部化，决策函数变得过于复杂，实际上是记住了训练集。\n这个说法准确地描述了大的 $\\gamma$ 的影响。高度局部化导致模型能够完美拟合训练数据的特定排列，从而获得近乎完美的训练准确率。同样是这种复杂性导致了泛化能力的完全丧失，产生了不比随机猜测更好的测试准确率。这是对观察到的性能最精确的解释。该选项是**正确的**。\n\nD. RBF 核宽度参数 $\\gamma$ 过小，导致核函数变得过于宽泛且接近线性；这解释了 $99\\%$ 的训练准确率但 $50\\%$ 的测试准确率。\n这个说法是自相矛盾的。小的 $\\gamma$ 会导致一个更简单、近乎线性的模型，如果真实边界是复杂的，这将会导致欠拟合。它不可能在一个复杂的数据集上达到 $99\\%$ 的训练准确率。因此，该选项是**错误的**。\n\n比较 A 和 C，选项 C 为观察到的极端过拟合情况提供了更强大、更具体的解释。由大 $\\gamma$ 引起的“记忆”效应是泛化能力完全崩溃至随机猜测水平的最可能原因。", "answer": "$$\\boxed{C}$$", "id": "2433181"}, {"introduction": "这项高级实践将你对核技巧的理解从仅仅使用预定义核函数提升到设计自己的核函数。通过为DNA序列创建一个加权字符串核 [@problem_id:2433200]，你将学习如何将生物学领域的先验知识（如外显子与内含子的生物学重要性差异）直接嵌入到SVM模型中，从而释放其解决复杂生物信息学问题的真正潜力。这个练习的核心在于将核函数理解为一种相似性度量，并利用它来指导SVM。", "problem": "给定一个与计算生物学中的剪接位点预测相关的二元分类场景，该场景使用核技巧为支持向量机 (SVM) 建模。考虑基于字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 的 DNA 序列，以及一个基于字母表 $\\{\\text{E}, \\text{I}\\}$ 的等长注释掩码，分别表示外显子和内含子位置。定义一个加权 $k$-谱字符串核，该核对完全发生在外显子区域内的匹配项增加权重，具体如下。\n\n令 $k \\in \\mathbb{N}$ 为一固定值。对于长度为 $n$ 的序列 $s$ 及其长度为 $n$ 的掩码 $m$，对于每个起始位置 $p \\in \\{0,1,\\dots,n-k\\}$，定义 $k$-mer 窗口 $s[p:p+k]$ 及其窗口掩码 $m[p:p+k]$。定义一个位置窗口权重\n$$\ng_{(s,m)}(p) \\;=\\;\n\\begin{cases}\nw_E & \\text{如果 } m[p:p+k] \\text{ 的所有符号都是 } \\text{E},\\\\\nw_I & \\text{如果 } m[p:p+k] \\text{ 的所有符号都是 } \\text{I},\\\\\n0 & \\text{其他情况}。\n\\end{cases}\n$$\n对于任意 $k$-mer $u \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}^k$，定义加权特征图分量\n$$\n\\phi_u(s,m) \\;=\\; \\sum_{p=0}^{n-k} g_{(s,m)}(p)\\,\\mathbf{1}\\!\\left[s[p:p+k] = u\\right],\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。两个注释序列 $(s,m)$ 和 $(t,n)$ 之间的核是内积\n$$\nK\\big((s,m),(t,n)\\big) \\;=\\; \\sum_{u \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}^k} \\phi_u(s,m)\\,\\phi_u(t,n).\n$$\n\n使用固定参数值 $k=2$、$w_E=2$ 和 $w_I=1$。考虑以下等长的注释 DNA 序列，每个序列以 $(\\text{序列}, \\text{掩码})$ 对的形式给出：\n- $A$: $($\"ACGTAC\"$,$ \"EEEIII\"$)$,\n- $B$: $($\"ACGTTC\"$,$ \"EEIIII\"$)$,\n- $C$: $($\"TTGTAC\"$,$ \"IIIIEE\"$)$,\n- $D$: $($\"AAAAAA\"$,$ \"IIIIII\"$)$,\n- $E$: $($\"AAAAAA\"$,$ \"EEEEEE\"$)$.\n\n您的任务是：\n- 计算核值 $K(A,A)$、$K(A,B)$、$K(B,C)$ 和 $K(D,E)$。\n- 对于集合 $\\{A,B,C\\}$，构建格拉姆矩阵 $G$，其元素为 $G_{ij} = K(S_i,S_j)$，其中 $S_1=A$，$S_2=B$，$S_3=C$，并确定 $G$ 是否为半正定（即在标准浮点舍入误差范围内，其所有特征值都大于或等于 $0$）。\n\n您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，结果按以下确切顺序排列：\n$[$$K(A,A)$$,$$K(A,B)$$,$$K(B,C)$$,$$K(D,E)$$,$$\\text{is\\_PSD}$$$]$，其中 $\\text{is\\_PSD}$ 是一个布尔值。例如，输出格式必须类似于 $[$$x$$,$$y$$,$$z$$,$$u$$,$$\\text{True}$$]$，不含空格。所有数值答案均无单位。测试套件包括上述指定的四个核评估以及对 $\\{A,B,C\\}$ 的格拉姆矩阵的半正定性检查，涵盖了典型案例、跨外显子/内含子交互、全内含子与全外显子的对比，以及一个矩阵级别的有效性检查。", "solution": "该问题具有科学依据、问题适定且客观。它基于机器学习和生物信息学的既定原则，提出了一个有效的计算任务。所有必要的数据和定义都已提供，不存在矛盾或歧义。我们将开始解题。\n\n问题的核心是计算一个加权 $k$-谱字符串核。两个注释序列 $(s, m)$ 和 $(t, n)$ 之间的核 $K$ 定义为其特征向量的内积，$K\\big((s,m),(t,n)\\big) = \\langle \\phi(s,m), \\phi(t,n) \\rangle$。这可以写成：\n$$\nK\\big((s,m),(t,n)\\big) = \\sum_{u \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}^k} \\phi_u(s,m)\\,\\phi_u(t,n)\n$$\n其中 $\\phi_u(s, m)$ 是根据其掩码 $m$ 在序列 $s$ 中 $k$-mer $u$ 的加权计数。一个更直接、计算上更高效的公式，避免了对所有可能的 $k$-mer $u$ 进行显式枚举，由下式给出：\n$$\nK\\big((s,m),(t,n)\\big) = \\sum_{p=0}^{|s|-k} \\sum_{q=0}^{|t|-k} g_{(s,m)}(p) g_{(t,n)}(q) \\mathbf{1}\\!\\left[s[p:p+k] = t[q:q+k]\\right]\n$$\n我们将采用特征图求和方法，因为它在概念上清晰且等价。给定固定参数 $k=2$、$w_E=2$ 和 $w_I=1$。所有序列的长度均为 $n=6$，因此每个序列中的 2-mer 数量为 $n-k+1 = 6-2+1=5$，起始位置为 $p \\in \\{0, 1, 2, 3, 4\\}$。\n\n首先，我们必须为每个注释序列 $S \\in \\{A, B, C, D, E\\}$ 计算特征图 $\\phi(S)$。对于一个 2-mer $u$，其特征图分量 $\\phi_u(S)$ 是其在序列中所有出现位置的位置权重 $g(p)$ 的总和。\n\n**1. 特征图计算**\n\n对于每个序列，我们列出 2-mer、它们的掩码窗口以及产生的位置权重 $g(p)$。\n\n- **序列 A**: $s_A = \\text{\"ACGTAC\"}$, $m_A = \\text{\"EEEIII\"}$\n  - $p=0$: $s_A[0:2]$=\"AC\", $m_A[0:2]$=\"EE\" (全为 'E') $\\implies g_A(0) = w_E = 2$。\n  - $p=1$: $s_A[1:3]$=\"CG\", $m_A[1:3]$=\"EE\" (全为 'E') $\\implies g_A(1) = w_E = 2$。\n  - $p=2$: $s_A[2:4]$=\"GT\", $m_A[2:4]$=\"EI\" (混合) $\\implies g_A(2) = 0$。\n  - $p=3$: $s_A[3:5]$=\"TA\", $m_A[3:5]$=\"II\" (全为 'I') $\\implies g_A(3) = w_I = 1$。\n  - $p=4$: $s_A[4:6]$=\"AC\", $m_A[4:6]$=\"II\" (全为 'I') $\\implies g_A(4) = w_I = 1$。\n  特征图 $\\phi(A)$ 的非零分量为：\n  $\\phi_{\\text{AC}}(A) = g_A(0) + g_A(4) = 2 + 1 = 3$。\n  $\\phi_{\\text{CG}}(A) = g_A(1) = 2$。\n  $\\phi_{\\text{TA}}(A) = g_A(3) = 1$。\n\n- **序列 B**: $s_B = \\text{\"ACGTTC\"}$, $m_B = \\text{\"EEIIII\"}$\n  - $p=0$: \"AC\", \"EE\" (全为 'E') $\\implies g_B(0) = w_E = 2$。\n  - $p=1$: \"CG\", \"EI\" (混合) $\\implies g_B(1) = 0$。\n  - $p=2$: \"GT\", \"II\" (全为 'I') $\\implies g_B(2) = w_I = 1$。\n  - $p=3$: \"TT\", \"II\" (全为 'I') $\\implies g_B(3) = w_I = 1$。\n  - $p=4$: \"TC\", \"II\" (全为 'I') $\\implies g_B(4) = w_I = 1$。\n  $\\phi(B)$ 的非零分量为：\n  $\\phi_{\\text{AC}}(B) = 2$, $\\phi_{\\text{GT}}(B) = 1$, $\\phi_{\\text{TT}}(B) = 1$, $\\phi_{\\text{TC}}(B) = 1$。\n\n- **序列 C**: $s_C = \\text{\"TTGTAC\"}$, $m_C = \\text{\"IIIIEE\"}$\n  - $p=0$: \"TT\", \"II\" (全为 'I') $\\implies g_C(0) = w_I = 1$。\n  - $p=1$: \"TG\", \"II\" (全为 'I') $\\implies g_C(1) = w_I = 1$。\n  - $p=2$: \"GT\", \"II\" (全为 'I') $\\implies g_C(2) = w_I = 1$。\n  - $p=3$: \"TA\", \"IE\" (混合) $\\implies g_C(3) = 0$。\n  - $p=4$: \"AC\", \"EE\" (全为 'E') $\\implies g_C(4) = w_E = 2$。\n  $\\phi(C)$ 的非零分量为：\n  $\\phi_{\\text{TT}}(C) = 1$, $\\phi_{\\text{TG}}(C) = 1$, $\\phi_{\\text{GT}}(C) = 1$, $\\phi_{\\text{AC}}(C) = 2$。\n\n- **序列 D**: $s_D = \\text{\"AAAAAA\"}$, $m_D = \\text{\"IIIIII\"}$\n  - 对于所有 $p \\in \\{0, 1, 2, 3, 4\\}$，2-mer 是 \"AA\"，掩码窗口是 \"II\"。\n  - 因此，对于所有 $p$，$g_D(p) = w_I = 1$。\n  $\\phi(D)$ 唯一的非零分量是：\n  $\\phi_{\\text{AA}}(D) = \\sum_{p=0}^4 1 = 5$。\n\n- **序列 E**: $s_E = \\text{\"AAAAAA\"}$, $m_E = \\text{\"EEEEEE\"}$\n  - 对于所有 $p \\in \\{0, 1, 2, 3, 4\\}$，2-mer 是 \"AA\"，掩码窗口是 \"EE\"。\n  - 因此，对于所有 $p$，$g_E(p) = w_E = 2$。\n  $\\phi(E)$ 唯一的非零分量是：\n  $\\phi_{\\text{AA}}(E) = \\sum_{p=0}^4 2 = 10$。\n\n**2. 核值计算**\n\n我们现在计算指定的核值。\n\n- $K(A,A) = \\langle\\phi(A), \\phi(A)\\rangle = \\sum_u (\\phi_u(A))^2 = (\\phi_{\\text{AC}}(A))^2 + (\\phi_{\\text{CG}}(A))^2 + (\\phi_{\\text{TA}}(A))^2 = 3^2 + 2^2 + 1^2 = 9 + 4 + 1 = 14$。\n\n- $K(A,B) = \\langle\\phi(A), \\phi(B)\\rangle = \\sum_u \\phi_u(A)\\phi_u(B)$。唯一具有非零权重的共同 2-mer 是 \"AC\"。\n  $K(A,B) = \\phi_{\\text{AC}}(A)\\phi_{\\text{AC}}(B) = 3 \\times 2 = 6$。\n\n- $K(B,C) = \\langle\\phi(B), \\phi(C)\\rangle$。共同的 2-mer 是 \"AC\"、\"GT\" 和 \"TT\"。\n  $K(B,C) = \\phi_{\\text{AC}}(B)\\phi_{\\text{AC}}(C) + \\phi_{\\text{GT}}(B)\\phi_{\\text{GT}}(C) + \\phi_{\\text{TT}}(B)\\phi_{\\text{TT}}(C) = (2 \\times 2) + (1 \\times 1) + (1 \\times 1) = 4 + 1 + 1 = 6$。\n\n- $K(D,E) = \\langle\\phi(D), \\phi(E)\\rangle$。唯一的共同 2-mer 是 \"AA\"。\n  $K(D,E) = \\phi_{\\text{AA}}(D)\\phi_{\\text{AA}}(E) = 5 \\times 10 = 50$。\n\n**3. 格拉姆矩阵和半正定性检查**\n\n集合 $\\{A, B, C\\}$ 的格拉姆矩阵 $G$ 是一个 $3 \\times 3$ 的对称矩阵，其元素为 $G_{ij} = K(S_i, S_j)$，其中 $S_1=A, S_2=B, S_3=C$。我们已经计算了非对角线元素 $K(A,B)=6$ 和 $K(B,C)=6$。我们需要计算 $K(A,C)$、$K(B,B)$ 和 $K(C,C)$。\n\n- $K(A,C) = \\langle\\phi(A), \\phi(C)\\rangle$。唯一的共同 2-mer 是 \"AC\"。\n  $K(A,C) = \\phi_{\\text{AC}}(A)\\phi_{\\text{AC}}(C) = 3 \\times 2 = 6$。\n\n- $K(B,B) = \\langle\\phi(B), \\phi(B)\\rangle = \\sum_u (\\phi_u(B))^2 = (\\phi_{\\text{AC}}(B))^2 + (\\phi_{\\text{GT}}(B))^2 + (\\phi_{\\text{TT}}(B))^2 + (\\phi_{\\text{TC}}(B))^2 = 2^2 + 1^2 + 1^2 + 1^2 = 4 + 1 + 1 + 1 = 7$。\n\n- $K(C,C) = \\langle\\phi(C), \\phi(C)\\rangle = \\sum_u (\\phi_u(C))^2 = (\\phi_{\\text{AC}}(C))^2 + (\\phi_{\\text{GT}}(C))^2 + (\\phi_{\\text{TT}}(C))^2 + (\\phi_{\\text{TG}}(C))^2 = 2^2 + 1^2 + 1^2 + 1^2 = 4 + 1 + 1 + 1 = 7$。\n\n因此，格拉姆矩阵为：\n$$\nG = \\begin{pmatrix} K(A,A) & K(A,B) & K(A,C) \\\\ K(B,A) & K(B,B) & K(B,C) \\\\ K(C,A) & K(C,B) & K(C,C) \\end{pmatrix} = \\begin{pmatrix} 14 & 6 & 6 \\\\ 6 & 7 & 6 \\\\ 6 & 6 & 7 \\end{pmatrix}\n$$\n为了确定 $G$ 是否为半正定 (PSD)，我们必须检查其所有特征值 $\\lambda$ 是否为非负。我们求解特征方程 $\\det(G - \\lambda I) = 0$。\n$$\n\\det \\begin{pmatrix} 14-\\lambda & 6 & 6 \\\\ 6 & 7-\\lambda & 6 \\\\ 6 & 6 & 7-\\lambda \\end{pmatrix} = 0\n$$\n$$\n(14-\\lambda)((7-\\lambda)^2 - 36) - 6(6(7-\\lambda) - 36) + 6(36 - 6(7-\\lambda)) = 0\n$$\n这可以简化为特征多项式 $(\\lambda-1)(\\lambda-5)(\\lambda-22)=0$。\n特征值为 $\\lambda_1 = 1$, $\\lambda_2 = 5$ 和 $\\lambda_3 = 22$。由于所有特征值均为严格正值，因此 G 不仅是半正定的，而且是正定的。这是符合预期的，因为任何在特征空间中定义为内积的核都是一个有效的 Mercer 核，并且总会产生一个半正定的格拉姆矩阵。`is_PSD` 的结果是 `True`。\n\n结果摘要：\n- $K(A,A) = 14$\n- $K(A,B) = 6$\n- $K(B,C) = 6$\n- $K(D,E) = 50$\n- `is_PSD` = `True`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes specified kernel values and checks the positive semidefiniteness \n    of a Gram matrix for a custom weighted k-spectrum string kernel.\n    \"\"\"\n    \n    # Define fixed parameters from the problem statement.\n    k = 2\n    w_E = 2.0\n    w_I = 1.0\n\n    # Define the annotated DNA sequences.\n    sequences = {\n        'A': (\"ACGTAC\", \"EEEIII\"),\n        'B': (\"ACGTTC\", \"EEIIII\"),\n        'C': (\"TTGTAC\", \"IIIIEE\"),\n        'D': (\"AAAAAA\", \"IIIIII\"),\n        'E': (\"AAAAAA\", \"EEEEEE\"),\n    }\n\n    def get_phi(seq_tuple, k, w_E, w_I):\n        \"\"\"\n        Computes the feature map phi for a given annotated sequence.\n        The map is a dictionary from k-mers to their weighted counts.\n        \"\"\"\n        s, m = seq_tuple\n        n = len(s)\n        phi = {}\n        for p in range(n - k + 1):\n            kmer = s[p:p + k]\n            mask_window = m[p:p + k]\n            weight = 0.0\n            \n            if all(char == 'E' for char in mask_window):\n                weight = w_E\n            elif all(char == 'I' for char in mask_window):\n                weight = w_I\n            \n            if weight > 0:\n                phi[kmer] = phi.get(kmer, 0.0) + weight\n        return phi\n\n    def kernel(phi_X, phi_Y):\n        \"\"\"\n        Computes the kernel value K(X, Y) as the inner product of their feature maps.\n        \"\"\"\n        val = 0.0\n        # Iterate over the smaller dictionary for efficiency.\n        if len(phi_X) > len(phi_Y):\n            phi_X, phi_Y = phi_Y, phi_X\n        \n        for kmer, value_X in phi_X.items():\n            value_Y = phi_Y.get(kmer, 0.0)\n            val += value_X * value_Y\n        return val\n\n    # Pre-compute all feature maps.\n    phis = {name: get_phi(data, k, w_E, w_I) for name, data in sequences.items()}\n\n    # Compute the four required kernel values.\n    k_AA = kernel(phis['A'], phis['A'])\n    k_AB = kernel(phis['A'], phis['B'])\n    k_BC = kernel(phis['B'], phis['C'])\n    k_DE = kernel(phis['D'], phis['E'])\n    \n    # Construct the Gram matrix G for the set {A, B, C}.\n    gram_keys = ['A', 'B', 'C']\n    N = len(gram_keys)\n    gram_matrix = np.zeros((N, N))\n    for i in range(N):\n        for j in range(i, N):\n            # Kernel function is symmetric, K(X, Y) = K(Y, X).\n            val = kernel(phis[gram_keys[i]], phis[gram_keys[j]])\n            gram_matrix[i, j] = val\n            gram_matrix[j, i] = val\n            \n    # Check if G is positive semidefinite by checking if all eigenvalues are non-negative.\n    # A small tolerance is used for floating-point arithmetic inaccuracies.\n    # np.linalg.eigvalsh is numerically stable and efficient for symmetric matrices.\n    eigenvalues = np.linalg.eigvalsh(gram_matrix)\n    is_psd = np.all(eigenvalues >= -1e-9)\n\n    # Assemble the final results list.\n    # Convert floats to integers if they are whole numbers.\n    results = [\n        int(k_AA) if k_AA == int(k_AA) else k_AA,\n        int(k_AB) if k_AB == int(k_AB) else k_AB,\n        int(k_BC) if k_BC == int(k_BC) else k_BC,\n        int(k_DE) if k_DE == int(k_DE) else k_DE,\n        is_psd\n    ]\n    \n    # Print the results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2433200"}]}