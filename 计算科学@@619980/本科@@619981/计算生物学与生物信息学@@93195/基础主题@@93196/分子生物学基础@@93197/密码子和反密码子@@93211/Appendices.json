{"hands_on_practices": [{"introduction": "遗传密码的简并性（即多个密码子编码同一个氨基酸）是一个基本特征。本练习将挑战你使用信息论来量化这种冗余，计算在翻译过程中发生的“信息损失”。通过这个实践，你将加深对香农熵的理解，并学会如何应用它来衡量生物系统中的内在不确定性。[@problem_id:2380340]", "problem": "一个信使核糖核酸 (mRNA) 编码序列由核糖体进行翻译，核糖体根据标准遗传密码将每个密码子（一个由三个核苷酸组成的三联体）映射到一个氨基酸。考虑以下模型：在每个编码位置，密码子是从 $61$ 个有义密码子（不包括终止密码子）中独立、均匀、随机地选择的，并且翻译是无错误的。由于同义密码子的存在，从密码子到氨基酸的映射是多对一的。设 $C$ 是表示一个位置上密码子的随机变量，而 $A$ 是表示该位置上翻译出的氨基酸的随机变量。使用以比特为单位的香农熵，对于一个分布为 $\\{p_x\\}$ 的离散随机变量 $X$，其熵为 $H(X) = - \\sum_{x} p_x \\log_{2} p_x$。\n\n在标准遗传密码中，每个氨基酸的同义密码子数量如下：两种氨基酸（甲硫氨酸和色氨酸）各有 $1$ 个密码子，九种氨基酸（苯丙氨酸、酪氨酸、组氨酸、谷氨酰胺、天冬酰胺、赖氨酸、天冬氨酸、谷氨酸、半胱氨酸）各有 $2$ 个密码子，一种氨基酸（异亮氨酸）有 $3$ 个密码子，五种氨基酸（缬氨酸、脯氨酸、苏氨酸、丙氨酸、甘氨酸）各有 $4$ 个密码子，以及三种氨基酸（丝氨酸、亮氨酸、精氨酸）各有 $6$ 个密码子。这些数量总和为 $61$ 个有义密码子。\n\n将一个位置上因翻译而丢失的信息定义为条件熵 $H(C \\mid A)$，它量化了在观察到氨基酸之后，关于原始密码子的期望不确定性。在上述模型下，计算每个翻译出的氨基酸的期望信息损失（以比特为单位）。将您的答案四舍五入至四位有效数字，并以“比特/氨基酸”为单位表示。", "solution": "首先对问题陈述进行严格验证。\n\n第一步：提取已知条件。\n-   系统是一个正在被翻译的 mRNA 编码序列。\n-   模型：在每个位置，从 $61$ 个有义密码子中独立、均匀、随机地选择一个密码子。不包括终止密码子。\n-   翻译过程无错误。\n-   $C$ 是表示某位置上密码子的随机变量。\n-   $A$ 是表示该位置上翻译出的氨基酸的随机变量。\n-   熵公式为以比特为单位的香农熵：$H(X) = - \\sum_{x} p_x \\log_{2}(p_x)$。\n-   待计算的量是翻译过程中丢失的信息，定义为条件熵 $H(C \\mid A)$。\n-   标准遗传密码的结构由每种氨基酸的同义密码子数量给出：\n    -   $2$ 种氨基酸各有 $1$ 个密码子。\n    -   $9$ 种氨基酸各有 $2$ 个密码子。\n    -   $1$ 种氨基酸有 $3$ 个密码子。\n    -   $5$ 种氨基酸各有 $4$ 个密码子。\n    -   $3$ 种氨基酸各有 $6$ 个密码子。\n-   有义密码子的总数为 $2 \\times 1 + 9 \\times 2 + 1 \\times 3 + 5 \\times 4 + 3 \\times 6 = 2 + 18 + 3 + 20 + 18 = 61$。这与已知信息一致。\n-   最终答案必须是一个以比特为单位的数值，并四舍五入到四位有效数字。\n\n第二步：使用提取的已知条件进行验证。\n-   **科学依据**：该问题基于信息论和分子生物学。它使用了香农熵的标准定义和公认的遗传密码结构。密码子概率均一的模型是在理论练习中使用的标准简化，并非对生物学现实的断言。作为一个基于模型的问题，它在科学上是成立的。\n-   **问题适定性**：该问题是适定的。它提供了所有必要的数据和明确的目标。量 $H(C \\mid A)$ 是一个良定义的数学对象，根据所提供的信息，其计算是可行的。存在唯一的数值解。\n-   **客观性**：该问题以客观的数学语言陈述。它没有歧义和主观断言。\n-   **结论**：该问题未违反任何指定的无效标准。它是一个计算生物学领域中有效且可解的问题。\n\n第三步：裁定与行动。\n-   该问题有效。将提供完整解答。\n\n任务是计算条件熵 $H(C \\mid A)$，它表示在已知氨基酸 $A$ 的情况下，关于密码子 $C$ 的剩余期望不确定性。条件熵的定义为：\n$$\nH(C \\mid A) = \\sum_{a \\in \\mathcal{A}} p(A=a) H(C \\mid A=a)\n$$\n其中 $\\mathcal{A}$ 是所有 $20$ 种标准氨基酸的集合，而 $p(A=a)$ 是观察到氨基酸 $a$ 的概率。\n\n首先，我们必须确定氨基酸的概率分布 $p(A=a)$。问题陈述， $61$ 个有义密码子中的每一个都是以均一的概率被选择的。因此，对于任何一个特定的有义密码子 $c$，其概率为 $p(C=c) = \\frac{1}{61}$。\n设 $N_a$ 为编码特定氨基酸 $a$ 的同义密码子的数量。观察到氨基酸 $a$ 的概率是所有映射到它的密码子概率的总和：\n$$\np(A=a) = \\sum_{c \\to a} p(C=c) = \\sum_{c \\to a} \\frac{1}{61} = \\frac{N_a}{61}\n$$\n\n接下来，我们必须确定给定一个氨基酸 $a$ 时的条件熵 $H(C \\mid A=a)$。这是在所有密码子都编码氨基酸 $a$ 的条件下，密码子分布的熵。\n$$\nH(C \\mid A=a) = - \\sum_{c} p(C=c \\mid A=a) \\log_{2}(p(C=c \\mid A=a))\n$$\n条件概率 $p(C=c \\mid A=a)$ 是在氨基酸为 $a$ 的条件下，密码子为 $c$ 的概率。根据条件概率的定义：\n$$\np(C=c \\mid A=a) = \\frac{p(C=c, A=a)}{p(A=a)}\n$$\n如果密码子 $c$ 不编码氨基酸 $a$，则此概率为 $0$。如果密码子 $c$ 确实编码氨基酸 $a$，则事件 $\\{C=c\\}$ 是事件 $\\{A=a\\}$ 的一个子集，所以 $p(C=c, A=a) = p(C=c) = \\frac{1}{61}$。\n因此，对于一个编码 $a$ 的密码子 $c$：\n$$\np(C=c \\mid A=a) = \\frac{1/61}{N_a/61} = \\frac{1}{N_a}\n$$\n这个结果是直观的：如果我们知道氨基酸是 $a$，并且有 $N_a$ 个可能的密码子为其编码，而最初每个密码子都是等可能的，那么在这个子集中它们仍然是等可能的。这 $N_a$ 个密码子中每一个的条件概率都是 $\\frac{1}{N_a}$。\n\n现在我们可以计算 $H(C \\mid A=a)$。求和是针对映射到 $a$ 的 $N_a$ 个密码子：\n$$\nH(C \\mid A=a) = - \\sum_{c \\to a} \\frac{1}{N_a} \\log_{2}\\left(\\frac{1}{N_a}\\right) = - N_a \\left(\\frac{1}{N_a} \\log_{2}\\left(\\frac{1}{N_a}\\right)\\right) = - \\log_{2}\\left(\\frac{1}{N_a}\\right) = \\log_{2}(N_a)\n$$\n如果 $N_a=1$，此熵为 $0$，这是正确的，因为没有不确定性。\n\n现在我们结合这些结果来计算总条件熵 $H(C \\mid A)$:\n$$\nH(C \\mid A) = \\sum_{a \\in \\mathcal{A}} p(A=a) H(C \\mid A=a) = \\sum_{a \\in \\mathcal{A}} \\frac{N_a}{61} \\log_{2}(N_a)\n$$\n我们可以根据氨基酸的密码子数 ($N_a$) 进行分组。设 $k_N$ 为拥有 $N$ 个密码子的氨基酸的数量。总和可以重写为：\n$$\nH(C \\mid A) = \\frac{1}{61} \\sum_{N} k_N \\cdot N \\cdot \\log_{2}(N)\n$$\n使用所提供的数据：\n-   $N=1$: $k_1 = 2$\n-   $N=2$: $k_2 = 9$\n-   $N=3$: $k_3 = 1$\n-   $N=4$: $k_4 = 5$\n-   $N=6$: $k_6 = 3$\n\n总和变为：\n$$\nH(C \\mid A) = \\frac{1}{61} \\left[ (2 \\cdot 1 \\cdot \\log_{2}(1)) + (9 \\cdot 2 \\cdot \\log_{2}(2)) + (1 \\cdot 3 \\cdot \\log_{2}(3)) + (5 \\cdot 4 \\cdot \\log_{2}(4)) + (3 \\cdot 6 \\cdot \\log_{2}(6)) \\right]\n$$\n我们计算每一项：\n-   $2 \\cdot 1 \\cdot \\log_{2}(1) = 2 \\cdot 0 = 0$\n-   $9 \\cdot 2 \\cdot \\log_{2}(2) = 18 \\cdot 1 = 18$\n-   $1 \\cdot 3 \\cdot \\log_{2}(3) = 3 \\log_{2}(3)$\n-   $5 \\cdot 4 \\cdot \\log_{2}(4) = 20 \\cdot \\log_{2}(2^2) = 20 \\cdot 2 = 40$\n-   $3 \\cdot 6 \\cdot \\log_{2}(6) = 18 \\cdot \\log_{2}(2 \\cdot 3) = 18 (\\log_{2}(2) + \\log_{2}(3)) = 18 (1 + \\log_{2}(3)) = 18 + 18 \\log_{2}(3)$\n\n将这些项相加：\n$$\n\\sum = 0 + 18 + 3 \\log_{2}(3) + 40 + 18 + 18 \\log_{2}(3) = (18 + 40 + 18) + (3 + 18) \\log_{2}(3) = 76 + 21 \\log_{2}(3)\n$$\n因此，条件熵的精确表达式为：\n$$\nH(C \\mid A) = \\frac{76 + 21 \\log_{2}(3)}{61}\n$$\n为了获得数值，我们使用 $\\log_{2}(3) = \\frac{\\ln(3)}{\\ln(2)} \\approx \\frac{1.098612}{0.693147} \\approx 1.5849625$。\n$$\nH(C \\mid A) \\approx \\frac{76 + 21 \\cdot (1.5849625)}{61} = \\frac{76 + 33.2842125}{61} = \\frac{109.2842125}{61} \\approx 1.791544467\n$$\n问题要求结果四舍五入到四位有效数字。\n$$\n1.791544467 \\approx 1.792\n$$\n因此，翻译过程中丢失的信息约为每个氨基酸 $1.792$ 比特。", "answer": "$$\n\\boxed{1.792}\n$$", "id": "2380340"}, {"introduction": "翻译不仅仅是一个简单的查找表；它是一个由tRNA分子和灵活的“摆动”配对规则介导的动态过程。这个问题要求你确定翻译一个基因组所需的最小tRNA种类数量，这实际上是在解决一个集合覆盖问题。本练习让你能够实际地审视细胞机器的效率，并探索生物信息学与经典计算机科学算法之间的相互作用。[@problem_id:2380386]", "problem": "您的任务是计算在特定的非标准摆动配对规则下，翻译给定核糖核酸 (RNA) 基因组所需的转运核糖核酸 (tRNA) 种类的最小数量，记为 $N_{\\min}$。分子生物学的中心法则指出，脱氧核糖核酸 (DNA) 转录为 RNA，RNA 再翻译成蛋白质。翻译过程通过 tRNA 反密码子与 RNA 密码子（基于字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 的三联体）的碱基配对，将密码子解码为氨基酸。标准的 Watson–Crick 碱基配对适用于密码子位置 $1$ 和 $2$（对应反密码子位置 $3$ 和 $2$），而摆动位（密码子位置 $3$ 和反密码子位置 $1$）允许由依赖修饰的规则所决定的扩展配对。在此假设每种 tRNA 对单一氨基酸具有特异性，并仅由其反密码子第 $1$ 位的摆动碱基来表征；反密码子的位置 $2$ 和 $3$ 假定为密码子前两个位置的严格 Watson–Crick 互补碱基。终止密码子不被翻译，必须忽略。\n\n基本依据与约束条件：\n- 密码子是基于 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 的长度为 $3$ 的词。标准核基因密码（标准遗传密码）将 $64$ 个密码子映射到 $20$ 种氨基酸和 $3$ 个终止信号（三个终止密码子是 $\\mathrm{UAA}$、$\\mathrm{UAG}$ 和 $\\mathrm{UGA}$）。只有有义密码子（非终止密码子）需要 tRNA。\n- 对于任何固定的氨基酸和固定的前两个碱基 $XY \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}^2$，其在该“家族框”中的同义密码子集合为 $XY\\{b \\mid b \\in \\mathcal{B}_{aa,XY}\\}$，其中 $\\mathcal{B}_{aa,XY} \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 取决于标准遗传密码的分配。用于该框的 tRNA 种类的反密码子位置 $2$ 和 $3$ 与 $X$ 和 $Y$ 互补，其反密码子摆动碱基决定了它在该框中可以解码哪些第三位碱基字母。一个 tRNA 不能服务于翻译成不同氨基酸的密码子，即使其反密码子可以进行碱基配对，因为氨酰化是氨基酸特异性的。\n- 摆动配对规则以从反密码子摆动碱基符号到其解码的密码子第三位碱基字母集合的映射形式提供。对于给定的氨基酸和 $XY$ 家族框，如果在基因组中为该框观察到的第三位碱基集合为 $S \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$，则该框所需的 tRNA 最小数量等于其解码字母集合能覆盖 $S$ 的摆动碱基类型的最小数量。这是一个在大小至多为 $4$ 的基础集上的最小集合覆盖问题。\n\n要使用的非标准摆动规则集：\n- 规则集 $\\mathcal{R}_{\\mathrm{NS1}}$（允许线粒体样超级摆动）：\n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{W}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$。\n- 规则集 $\\mathcal{R}_{\\mathrm{NS2}}$（无肌苷；扩展但非超级摆动）：\n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$, $\\mathrm{M}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$。\n- 规则集 $\\mathcal{R}_{\\mathrm{NS3}}$（限制性摆动；抑制的 $\\mathrm{G}\\text{-}\\mathrm{U}$ 配对）：\n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$。\n\n任务：\n- 实现一个程序，为每个测试用例按如下方式计算 $N_{\\min}$。对每种氨基酸，将基因组中编码该氨基酸的密码子根据其前两个碱基 $XY$ 进行分区。对于每个分区，设 $S$ 为基因组中针对该氨基酸和 $XY$ 实际观察到的第三位碱基字母集合。使用指定的摆动规则集，找出其解码字母集合能覆盖 $S$ 的反密码子摆动碱基类型的最小数量。将所有氨基酸和所有 $XY$ 分区的这个最小计数相加，得到该规则集下该基因组的 $N_{\\min}$。完全忽略终止密码子。所有计数均为整数，并应以整数形式报告。\n\n测试套件：\n- 用例 1：基因组 $\\mathcal{G}_1$，包含密码子 \n  $\\{\\mathrm{AUG},\\mathrm{GCU},\\mathrm{GCC},\\mathrm{GCA},\\mathrm{GCG},\\mathrm{GGU},\\mathrm{GGC},\\mathrm{GGA},\\mathrm{AUU},\\mathrm{AUC},\\mathrm{AUA},\\mathrm{UUU},\\mathrm{UUC},\\mathrm{CCU},\\mathrm{CCA},\\mathrm{UCU},\\mathrm{UCC},\\mathrm{UCA},\\mathrm{UCG},\\mathrm{AGU},\\mathrm{CUA},\\mathrm{CUG},\\mathrm{UUA},\\mathrm{GUU},\\mathrm{UAU},\\mathrm{UAC},\\mathrm{UAA},\\mathrm{UGA},\\mathrm{UAG}\\}$，在 $\\mathcal{R}_{\\mathrm{NS1}}$ 规则下进行评估。\n- 用例 2：相同的基因组 $\\mathcal{G}_1$，在 $\\mathcal{R}_{\\mathrm{NS2}}$ 规则下进行。\n- 用例 3：相同的基因组 $\\mathcal{G}_1$，在 $\\mathcal{R}_{\\mathrm{NS3}}$ 规则下进行。\n- 用例 4：基因组 $\\mathcal{G}_2$，包含重复 $10$ 次的 $\\mathrm{UUU}$ 和一个终止密码子 $\\mathrm{UAA}$，在 $\\mathcal{R}_{\\mathrm{NS3}}$ 规则下进行评估。\n- 用例 5：基因组 $\\mathcal{G}_{\\mathrm{all}}$，其中 $61$ 个有义密码子（所有标准遗传密码的有义密码子）各出现一次，在 $\\mathcal{R}_{\\mathrm{NS3}}$ 规则下进行评估。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$），其中每个 $\\text{result}_i$ 是上述列表中对应​​用例的整数 $N_{\\min}$。不应读取用户输入；所有数据必须嵌入在程序中。不涉及物理单位或角度。所有输出均为整数。实现语言和环境在最终答案说明中指定。", "solution": "问题陈述是有效的。它有科学依据、定义良好且客观。它基于分子生物学的既定原则，特别是信使 RNA 翻译成蛋白质的过程，提出了一个清晰的计算任务。该问题要求计算在特定的非标准摆动配对规则下，翻译一组给定的 RNA 密码子所需的转运 RNA (tRNA) 种类的最小数量 $N_{\\min}$。这是一个定义明确的优化问题，可以分解为一系列最小集合覆盖问题。\n\n基本原理是蛋白质合成依赖于 tRNA 分子上对应的三碱基反密码子对 mRNA 分子上三碱基密码子的识别。每个 tRNA 携带一个特定的氨基酸。虽然密码子的前两个位置与反密码子的第三和第二个位置的碱基配对分别遵循标准的 Watson-Crick 规则（$\\mathrm{A}$-$\\mathrm{U}$，$\\mathrm{G}$-$\\mathrm{C}$），但在“摆动”位置（密码子位置 $3$，反密码子位置 $1$）的配对则更为灵活。这种灵活性通常由反密码子第一个碱基的化学修饰所决定。该问题提供了三组假设的此类摆动配对规则，$\\mathcal{R}_{\\mathrm{NS1}}$、$\\mathcal{R}_{\\mathrm{NS2}}$ 和 $\\mathcal{R}_{\\mathrm{NS3}}$，将反密码子摆动碱基映射到它们可以识别的密码子第三位碱基的集合。\n\n核心约束是，由其反密码子和氨基酸特异性定义的单个 tRNA 种类，不能服务于翻译成不同氨基酸的密码子。这引出了核心算法步骤：对问题进行划分。tRNA 的总数 $N_{\\min}$ 是为不同密码子组所需的最小 tRNA 数量之和。这些组由唯一的（氨基酸，密码子前缀 $XY$）对定义，其中 $XY$ 是该组中密码子的前两个碱基。\n\n解决方案按以下步骤进行：\n\n步骤 $1$：数据结构化。\n首先，我们编码必要的生物学和问题特定的数据。\n- 标准核基因密码表示为从 $64$ 个密码子中的每一个到其对应氨基酸或终止信号的映射。例如，$\\mathrm{UUU} \\to \\text{苯丙氨酸}$ 和 $\\mathrm{UAA} \\to \\text{终止}$。\n- 非标准摆动配对规则（$\\mathcal{R}_{\\mathrm{NS1}}$、$\\mathcal{R}_{\\mathrm{NS2}}$ 和 $\\mathcal{R}_{\\mathrm{NS3}}$）作为映射存储。每个映射将一个反密码子摆动碱基（例如，`I` 代表肌苷）与它能配对的密码子第三位碱基集合（例如，$\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$）关联起来。\n- 每个测试用例的输入基因组以唯一的密码子集合形式提供。终止密码子（$\\mathrm{UAA}$、$\\mathrm{UAG}$、$\\mathrm{UGA}$）从任何分析中排除。\n\n步骤 $2$：密码子分区。\n对于给定的基因组和规则集，我们遍历所有存在的唯一的、非终止的密码子。每个密码子根据其编码的氨基酸及其前两个核苷酸（$XY$）进行分类。这会创建一组不相交的分区。对于每个由键（氨基酸, $XY$）标识的分区，我们收集所有观察到的第三位置碱基的集合。对于对应于（氨基酸$_{i}$， $XY_{j}$）的分区，设这个观察到的第三位碱基集合为 $S_{i,j}$。\n\n例如，如果基因组包含密码子 $\\mathrm{GCU}$、$\\mathrm{GCC}$ 和 $\\mathrm{GCA}$，它们都编码丙氨酸，并且都共享前缀 $\\mathrm{GC}$。这形成了一个键为（丙氨酸, $\\mathrm{GC}$）的单一分区，所需的第三位碱基集合为 $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$。\n\n步骤 $3$：解决最小集合覆盖问题。\n对于每个分区 $(i, j)$ 及其对应的所需第三位碱基集 $S_{i,j}$，我们必须找到 tRNA 摆动碱基（来自指定的规则集）的最小数量，其识别的碱基集合能共同“覆盖”$S_{i,j}$。这是一个经典的最小集合覆盖问题。要覆盖的元素全集是 $S_{i,j}$，它是 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 的一个子集。可用于形成覆盖的可用集合的集合由所选摆动规则映射中的值给出（例如，对于 $\\mathcal{R}_{\\mathrm{NS1}}$，可用集合为 $\\{\\mathrm{U}\\}, \\{\\mathrm{G}\\}, \\{\\mathrm{C}, \\mathrm{U}\\}, \\dots$）。\n\n由于全集大小至多为 $4$，这个问题可以通过穷举搜索有效解决。我们检查是否存在大小为 $k=1$ 的覆盖。如果不存在，我们检查大小为 $k=2$ 的覆盖，依此类推。第一个找到覆盖的 $k$ 就是最小大小。设 $c_{i,j}$ 为分区 $(i, j)$ 的最小 tRNA 数量。\n\n例如，要在规则集 $\\mathcal{R}_{\\mathrm{NS1}}$ 下覆盖（丙氨酸, $\\mathrm{GC}$）的集合 $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$，我们检查可用的摆动配对。反密码子摆动碱基 `I` 可识别 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$。由于 $S \\subseteq \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$，一个带有反密码子 `I` 的 tRNA 就足够了。因此，此分区的成本为 $c = 1$。如果没有单个 tRNA 能覆盖 $S$，我们将检查所有 tRNA 对，依此类推。\n\n步骤 $4$：最终计算。\ntRNA 种类的总最小数量 $N_{\\min}$ 是为每个分区计算的最小数量之和：\n$$ N_{\\min} = \\sum_{i,j} c_{i,j} $$\n对问题中指定的五个测试用例中的每一个，使用相应的基因组和摆动规则集重复此过程。最终输出是每个用例的 $N_{\\min}$ 整数值的有序列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the tRNA minimization problem for all test cases.\n    \"\"\"\n\n    # --- Data Definitions ---\n\n    # Standard Nuclear Genetic Code\n    genetic_code = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': 'Stop', 'UAG': 'Stop',\n        'UGU': 'C', 'UGC': 'C', 'UGA': 'Stop', 'UGG': 'W',\n\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    # Non-standard Wobble Rule Sets\n    wobble_rules = {\n        'R_NS1': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'I': frozenset({'A', 'C', 'U'}), 'W': frozenset({'A', 'C', 'G', 'U'}),\n            'K': frozenset({'A'}), 'Q': frozenset({'U', 'C'})\n        },\n        'R_NS2': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'Q': frozenset({'U', 'C'}), 'M': frozenset({'A', 'G'}),\n            'K': frozenset({'A'})\n        },\n        'R_NS3': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C'}), 'U': frozenset({'A'}),\n            'I': frozenset({'A', 'C', 'U'}), 'K': frozenset({'A'}),\n            'Q': frozenset({'U', 'C'})\n        }\n    }\n\n    # Test Suite\n    genome_g1 = {\n        \"AUG\", \"GCU\", \"GCC\", \"GCA\", \"GCG\", \"GGU\", \"GGC\", \"GGA\", \"AUU\", \"AUC\", \"AUA\",\n        \"UUU\", \"UUC\", \"CCU\", \"CCA\", \"UCU\", \"UCC\", \"UCA\", \"UCG\", \"AGU\", \"CUA\",\n        \"CUG\", \"UUA\", \"GUU\", \"UAU\", \"UAC\", \"UAA\", \"UGA\", \"UAG\"\n    }\n\n    genome_g2 = {\"UUU\"} # 10 times does not change the set, stop codon UAA is ignored\n\n    all_sense_codons = {codon for codon, aa in genetic_code.items() if aa != 'Stop'}\n\n    test_cases = [\n        (genome_g1, wobble_rules['R_NS1']),\n        (genome_g1, wobble_rules['R_NS2']),\n        (genome_g1, wobble_rules['R_NS3']),\n        (genome_g2, wobble_rules['R_NS3']),\n        (all_sense_codons, wobble_rules['R_NS3']),\n    ]\n\n    # --- Helper Functions ---\n    def solve_min_set_cover(target_set, covering_sets):\n        \"\"\"\n        Solves the minimum set cover problem for a small universe.\n        The target_set must be covered by the union of sets from covering_sets.\n        \"\"\"\n        if not target_set:\n            return 0\n        \n        # Check covers of increasing size\n        for k in range(1, len(covering_sets) + 1):\n            for combo in combinations(covering_sets, k):\n                # An arbitrary iterable of a collection of sets can be passed to union()\n                union_of_combo = frozenset.union(*combo)\n                if target_set.issubset(union_of_combo):\n                    return k\n        # This part should be unreachable if all bases can be covered.\n        # Fallback in case of an un-coverable base, though problem setup prevents this.\n        return len(target_set)\n\n    def compute_n_min(genome_codons, rules):\n        \"\"\"\n        Computes N_min for a given genome and rule set.\n        \"\"\"\n        codons_by_group = {}\n        for codon in genome_codons:\n            aa = genetic_code.get(codon)\n            if aa and aa != 'Stop':\n                prefix = codon[:2]\n                third_base = codon[2]\n                key = (aa, prefix)\n                if key not in codons_by_group:\n                    codons_by_group[key] = set()\n                codons_by_group[key].add(third_base)\n\n        total_trna_count = 0\n        available_covers = list(rules.values())\n        \n        for group_key, third_bases_needed in codons_by_group.items():\n            min_cover_size = solve_min_set_cover(frozenset(third_bases_needed), available_covers)\n            total_trna_count += min_cover_size\n            \n        return total_trna_count\n\n    # --- Main Logic ---\n    results = []\n    for genome, rules in test_cases:\n        result = compute_n_min(genome, rules)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2380386"}, {"introduction": "遗传密码的结构具有深远的进化意义，因为单个突变有时可能导致提前出现终止密码子，从而产生灾难性后果。这个高级实践将引导你检验一个真实的生物学假说：必需基因是否在选择压力下倾向于避免那些距离终止信号仅一步之遥的密码子。你将对序列数据应用统计学方法来寻找这一现象的证据，从而将基础概念与计算研究联系起来。[@problem_id:2380355]", "problem": "你的任务是通过编程来量化，在一组必需基因中，与一组匹配的非必需基因相比，那些与终止密码子仅有一个点突变之差的信使核糖核酸（mRNA）密码子是否存在代表性不足的现象。该分析必须基于分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、密码子是在字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 上长度为$3$的三联体的定义、三个终止密码子 $\\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$ 的存在，以及定义转运核糖核酸（tRNA）反密码子的碱基配对规则。如果一个密码子与任意一个终止密码子的汉明距离（两个等长字符串在不同位置上的字符数）恰好为$1$，并且该密码子本身不是终止密码子，则称其为“近终止”密码子。只有有义密码子（非终止密码子）计入使用总数。假设编码序列已经过剪接，并以$5'$到$3'$方向、在读码框内作为字母表 $\\Sigma$ 上的字符串提供，其长度是$3$的倍数。\n\n从这些基本原理出发：\n- 终止密码子集合为 $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$。\n- 所有密码子的集合为 $\\Sigma^3$，其大小为 $|\\Sigma^3| = 4^3 = 64$。\n- 有义密码子的集合为 $\\Sigma^3 \\setminus S$。\n- 一个“近终止”密码子 $c$ 满足 $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$ 且 $c \\notin S$。\n- 反密码子是在 Watson–Crick 配对规则（$\\mathrm{A}\\leftrightarrow \\mathrm{U}$，$\\mathrm{C}\\leftrightarrow \\mathrm{G}$）下密码子的反向互补序列，但在此处使用反密码子仅为说明密码子框架的合理性；计算完全在密码子层面进行。\n\n你必须设计一个算法，该算法能够：\n- 在给定的读码框中，将每个基因序列解析为不重叠的密码子。\n- 从使用计数中排除遇到的任何终止密码子。\n- 对每个基因集（必需基因与非必需基因），分别统计近终止有义密码子的总数和非近终止有义密码子的总数。\n- 构建一个包含以下条目的 $2\\times 2$ 列联表：\n  - $a$：必需基因中的近终止密码子计数，\n  - $b$：必需基因中的非近终止密码子计数，\n  - $c$：非必需基因中的近终止密码子计数，\n  - $d$：非必需基因中的非近终止密码子计数。\n- 计算平滑对数优势比，其中 Laplace 平滑参数为 $\\alpha > 0$：\n  $$\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right).$$\n- 对该表计算双侧 Fisher 精确检验的 $p$ 值\n  $$\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}.$$\n  如果任意行或任意列的和等于 $0$（即 $a+b=0$ 或 $c+d=0$ 或 $a+c=0$ 或 $b+d=0$），则为此程序的目的，将双侧 $p$ 值定义为 $1.0$。\n- 当且仅当 $\\mathrm{LOR}_\\alpha < 0$ 且双侧 $p$ 值小于指定的显著性阈值 $\\tau$ 时，宣布必需基因中存在“代表性不足”现象。\n\n实现要求：\n- 仅根据给定的序列和定义进行操作。\n- 将所有输入视为在 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 上的 mRNA 密码子。\n- 忽略任何无法形成完整密码子三联体的尾部核苷酸（所提供的序列长度将是 $3$ 的倍数）。\n\n测试套件：\n实现你的程序，以运行以下三个独立的测试用例。每个测试用例都指定了一组必需基因序列、一组非必需基因序列、一个平滑参数 $\\alpha$ 和一个显著性阈值 $\\tau$。所有序列都是有效的 mRNA 编码序列，每个字符串的长度都是 $3$ 的倍数，并且不包含内部终止密码子。\n\n- 测试用例1（平衡使用；预期无代表性不足）：\n  - 必需基因：\n    - $\\mathrm{E1} = \\text{\"AAGGCUAAAGCUUUU\"}$ 解析为 $(\\mathrm{AAG}, \\mathrm{GCU}, \\mathrm{AAA}, \\mathrm{GCU}, \\mathrm{UUU})$，\n    - $\\mathrm{E2} = \\text{\"GCCUGGUGGUUCGCA\"}$ 解析为 $(\\mathrm{GCC}, \\mathrm{UGG}, \\mathrm{UGG}, \\mathrm{UUC}, \\mathrm{GCA})$。\n  - 非必需基因：\n    - $\\mathrm{N1} = \\text{\"CAAGCUUAUGCGUUC\"}$ 解析为 $(\\mathrm{CAA}, \\mathrm{GCU}, \\mathrm{UAU}, \\mathrm{GCG}, \\mathrm{UUC})$，\n    - $\\mathrm{N2} = \\text{\"AAAGCCUUGGCAUUU\"}$ 解析为 $(\\mathrm{AAA}, \\mathrm{GCC}, \\mathrm{UUG}, \\mathrm{GCA}, \\mathrm{UUU})$。\n  - 参数： $\\alpha = 1.0$, $\\tau = 0.05$。\n\n- 测试用例2（必需基因中存在显著的代表性不足）：\n  - 必需基因：\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUC\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUC})$，\n    - $\\mathrm{E2} = \\text{\"GCUGCGUUUUUCGCC\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$。\n  - 非必需基因：\n    - $\\mathrm{N1} = \\text{\"AAAAAGCAAGAAUUA\"}$ 解析为 $(\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{CAA}, \\mathrm{GAA}, \\mathrm{UUA})$，\n    - $\\mathrm{N2} = \\text{\"UGGUCGUAUUACAGA\"}$ 解析为 $(\\mathrm{UGG}, \\mathrm{UCG}, \\mathrm{UAU}, \\mathrm{UAC}, \\mathrm{AGA})$。\n  - 参数： $\\alpha = 0.5$, $\\tau = 0.01$。\n\n- 测试用例3（两组中近终止密码子计数均为零的边界情况）：\n  - 必需基因：\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUU\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUU})$，\n    - $\\mathrm{E2} = \\text{\"UUCGCUGCCGCAGCG\"}$ 解析为 $(\\mathrm{UUC}, \\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG})$。\n  - 非必需基因：\n    - $\\mathrm{N1} = \\text{\"GCUGCGUUUUUCGCC\"}$ 解析为 $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$，\n    - $\\mathrm{N2} = \\text{\"GCAGCUUUCUUUGCG\"}$ 解析为 $(\\mathrm{GCA}, \\mathrm{GCU}, \\mathrm{UUC}, \\mathrm{UUU}, \\mathrm{GCG})$。\n  - 参数： $\\alpha = 1.0$, $\\tau = 0.05$。\n\n最终输出规范：\n- 对于每个测试用例，你的程序必须生成一个三元组 $[\\mathrm{LOR}_\\alpha, p, \\mathrm{underrep}]$，其中 $\\mathrm{LOR}_\\alpha$ 是如上定义的平滑对数优势比，$p$ 是双侧 Fisher 精确检验的 $p$ 值，而 $\\mathrm{underrep}$ 是一个布尔值，指示必需基因是否表现出统计上显著的代表性不足。将所有浮点输出四舍五入到$6$位小数。\n- 你的程序应生成单行输出，其中包含三个测试用例的结果。结果以逗号分隔的列表形式，并用方括号括起来，每个测试用例的结果本身也呈现为用方括号括起来的逗号分隔列表。例如：\"[[x1,y1,True],[x2,y2,False],[x3,y3,True]]\"。\n- 本问题不要求任何物理单位、角度或百分比；所有报告的量均为无量纲实数或布尔值。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于分子生物学，在数学上是适定的，并为所需的算法及其参数提供了完整、无歧义的规范。因此，我们将着手提供一个完整的解决方案。\n\n问题的核心是量化和检验一类被称为“近终止”密码子的特定密码子，在必需基因中相对于非必需基因是否存在代表性不足。该解决方案分四个逻辑阶段执行。\n\n**步骤1：近终止密码子的形式化与识别**\n\n问题将一个密码子 $c$ 定义为“近终止”，如果满足两个条件：\n1.  $c$ 必须是一个有义密码子，意味着它不是终止密码子集合 $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$ 的成员。\n2.  $c$ 与其最近的终止密码子之间的汉明距离必须恰好为 $1$。这可以形式化地表示为 $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$。两个等长字符串之间的汉明距离是相应符号不同的位置数量。\n\n为实现这一点，我们从字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 中系统地生成所有 $4^3 = 64$ 个可能的密码子。对于每个密码子 $c$，我们首先检查它是否属于 $S$。如果是，则将其丢弃。如果 $c \\notin S$，我们接着计算它与 $S$ 中三个终止密码子中每一个的汉明距离。如果这三个距离中的最小值为 $1$，则该密码子 $c$ 被归类为近终止密码子。\n\n此过程产生以下包含 $18$ 个近终止密码子的集合，该集合将被预先计算并用于所有后续分析：\n$\\{\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{AGA}, \\mathrm{CAA}, \\mathrm{CAG}, \\mathrm{CGA}, \\mathrm{GAA}, \\mathrm{GAG}, \\mathrm{GGA}, \\mathrm{UAC}, \\mathrm{UAU}, \\mathrm{UCA}, \\mathrm{UCG}, \\mathrm{UGC}, \\mathrm{UGU}, \\mathrm{UGG}, \\mathrm{UUA}, \\mathrm{UUG}\\}$。\n\n**步骤2：序列处理与列联表构建**\n\n提供的基因序列是 mRNA 碱基字符串。该算法按如下方式处理每个基因集（必需和非必需）：\n1.  对于每个基因序列（保证其长度是 $3$ 的倍数），我们将其解析为一个由长度为 $3$ 的非重叠、在读码框内的密码子组成的列表。\n2.  对于每个密码子，我们确定它是否属于预先计算的近终止密码子集合。\n3.  问题陈述指出输入序列不包含终止密码子，因此每个密码子都是有义密码子。一个密码子要么是“近终止”，要么是“非近终止”。\n4.  我们在一个集合（必需或非必需）内的所有基因中累积计数，以填充一个形式为 $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ 的 $2 \\times 2$ 列联表，其中：\n    - $a$：必需基因中近终止密码子的总数。\n    - $b$：必需基因中非近终止有义密码子的总数。\n    - $c$：非必需基因中近终止密码子的总数。\n    - $d$：非必需基因中非近终止有义密码子的总数。\n\n**步骤3：统计分析**\n\n列联表构建完成后，计算两个统计指标。\n\n首先，计算平滑对数优势比（$\\mathrm{LOR}_\\alpha$）以估计效应的大小和方向。该公式使用带有参数 $\\alpha > 0$ 的 Laplace 平滑来处理潜在的零计数：\n$$\n\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right)\n$$\n负的 $\\mathrm{LOR}_\\alpha$ 值表示，在必需基因集中，一个密码子是近终止密码子的优势低于非必需基因集，这表明存在代表性不足。计算中使用自然对数。\n\n其次，对列联表执行双侧 Fisher 精确检验，以评估基因类型（必需 vs. 非必需）与密码子类型（近终止 vs. 非近终止）之间关联的统计显著性。该检验计算一个 $p$ 值，它表示在零假设（即无关联）成立的前提下，观察到与所构建表格一样极端或更极端的表格的概率。一个小的 $p$ 值提供了反对零假设的证据。\n\n对于 $p$ 值的计算，有一条特殊的强制性规定：如果列联表的任何行和（$a+b$ 或 $c+d$）或列和（$a+c$ 或 $b+d$）为零，则 $p$ 值定义为 $1.0$。这处理了数据中某一类别完全缺失的情况，使得检验变得平凡。\n\n**步骤4：代表性不足的判定**\n\n“代表性不足”的最终判定基于两个必须同时满足的标准：\n1.  效应方向必须表明在必需基因中存在代表性不足：$\\mathrm{LOR}_\\alpha < 0$。\n2.  结果必须具有统计显著性：$p$ 值必须小于指定的显著性阈值 $\\tau$。\n\n如果 $\\mathrm{LOR}_\\alpha < 0$ 和 $p < \\tau$ 同时为真，则结果为 `True`；否则为 `False`。算法为每个测试用例计算这些值，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import fisher_exact\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"essential_genes\": [\"AAGGCUAAAGCUUUU\", \"GCCUGGUGGUUCGCA\"],\n            \"nonessential_genes\": [\"CAAGCUUAUGCGUUC\", \"AAAGCCUUGGCAUUU\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUC\", \"GCUGCGUUUUUCGCC\"],\n            \"nonessential_genes\": [\"AAAAAGCAAGAAUUA\", \"UGGUCGUAUUACAGA\"],\n            \"alpha\": 0.5,\n            \"tau\": 0.01\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUU\", \"UUCGCUGCCGCAGCG\"],\n            \"nonessential_genes\": [\"GCUGCGUUUUUCGCC\", \"GCAGCUUUCUUUGCG\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        }\n    ]\n\n    results = []\n    \n    # Pre-compute the set of near-stop codons once.\n    near_stop_codons = _get_near_stop_codons()\n\n    for case in test_cases:\n        # Extract parameters for the current test case.\n        essential_genes = case[\"essential_genes\"]\n        nonessential_genes = case[\"nonessential_genes\"]\n        alpha = case[\"alpha\"]\n        tau = case[\"tau\"]\n\n        # Step 1: Count codon types in essential genes.\n        a, b = _count_codon_types(essential_genes, near_stop_codons)\n        \n        # Step 2: Count codon types in nonessential genes.\n        c, d = _count_codon_types(nonessential_genes, near_stop_codons)\n        \n        # Step 3: Compute the smoothed log-odds ratio.\n        # LOR = log((a+alpha)/(b+alpha)) - log((c+alpha)/(d+alpha))\n        term_essential = (a + alpha) / (b + alpha)\n        term_nonessential = (c + alpha) / (d + alpha)\n        lor = np.log(term_essential) - np.log(term_nonessential)\n        \n        # Step 4: Compute the two-sided Fisher's exact test p-value.\n        table = np.array([[a, b], [c, d]])\n        \n        # Check for zero row or column sums as per the problem specification.\n        if (a + b == 0) or (c + d == 0) or (a + c == 0) or (b + d == 0):\n            p_value = 1.0\n        else:\n            _, p_value = fisher_exact(table, alternative='two-sided')\n            \n        # Step 5: Determine if there is underrepresentation.\n        # Condition: LOR < 0 and p-value < significance threshold tau.\n        is_underrepresented = lor < 0 and p_value < tau\n        \n        # Append the formatted result triplet to the list.\n        results.append([lor, p_value, is_underrepresented])\n\n    # Format the final output string as specified.\n    formatted_results = [\n        f\"[{lor:.6f},{p_val:.6f},{str(underrep)}]\"\n        for lor, p_val, underrep in results\n    ]\n    # The output format requires Python booleans to be lowercase true/false.\n    # The problem description's example shows True/False.\n    # Python's default str(bool) is 'True'/'False'. Let's ensure this is correct.\n    # \"[[x1,y1,True],[x2,y2,False],[x3,y3,True]]\" - This is Python repr, not JSON.\n    # So the default str() behavior is correct.\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _get_near_stop_codons():\n    \"\"\"\n    Generates the set of \"near-stop\" codons based on the problem definition.\n    A codon is near-stop if its Hamming distance to any stop codon is 1\n    and it is not itself a stop codon.\n    \"\"\"\n    bases = ['A', 'C', 'G', 'U']\n    stop_codons = {'UAA', 'UAG', 'UGA'}\n    \n    all_codons = {b1 + b2 + b3 for b1 in bases for b2 in bases for b3 in bases}\n    sense_codons = all_codons - stop_codons\n    \n    near_stop_set = set()\n    for codon in sense_codons:\n        min_dist = 3  # The maximum possible Hamming distance for length 3 strings.\n        for stop_codon in stop_codons:\n            dist = sum(1 for i in range(3) if codon[i] != stop_codon[i])\n            if dist < min_dist:\n                min_dist = dist\n        \n        if min_dist == 1:\n            near_stop_set.add(codon)\n            \n    return near_stop_set\n\ndef _count_codon_types(gene_sequences, near_stop_set):\n    \"\"\"\n    Parses gene sequences into codons and counts near-stop vs. non-near-stop codons.\n    \n    Args:\n        gene_sequences (list[str]): A list of mRNA sequences.\n        near_stop_set (set[str]): The pre-computed set of near-stop codons.\n\n    Returns:\n        tuple[int, int]: A tuple containing (near_stop_count, non_near_stop_count).\n    \"\"\"\n    near_stop_count = 0\n    non_near_stop_count = 0\n    \n    for seq in gene_sequences:\n        # Parse sequence into non-overlapping codons of length 3.\n        for i in range(0, len(seq), 3):\n            codon = seq[i:i+3]\n            \n            # According to problem, input sequences do not contain stop codons.\n            if codon in near_stop_set:\n                near_stop_count += 1\n            else:\n                non_near_stop_count += 1\n                \n    return near_stop_count, non_near_stop_count\n\n# The problem states \"No user input should be read... Implement your program to run...\".\n# This implies the code should be runnable.\n# A call to the main function is needed for it to execute when run as a script.\n# if __name__ == '__main__':\n#     solve()\n# The environment might not run this block, so it's safer to just call solve().\nsolve()\n```", "id": "2380355"}]}