{"hands_on_practices": [{"introduction": "DNA双螺旋的优雅结构依赖于一个严格的几何规则：一个较大的嘌呤与一个较小的嘧啶配对。这项实践挑战你像分子生物学家一样思考，并想象当这个规则被打破时会发生什么。通过思考在DNA聚合酶有限空间内，一个不正确的碱基配对所带来的物理后果，你将对复制保真度的结构基础有更深刻的理解。[@problem_id:1516177]", "problem": "设想一种DNA（脱氧核糖核酸）聚合酶，它能正常合成DNA，但完全不具备3'到5'的外切核酸酶活性，这意味着它没有校对能力。在以某条模板链进行DNA复制的过程中，该酶遇到了一个鸟嘌呤（G）碱基。聚合酶没有掺入正确的互补碱基——胞嘧啶（C），而是在鸟嘌呤的对面错误地将一个腺嘌呤（A）核苷酸掺入到正在增长的新生链中。\n\n下列哪个陈述最好地描述了这种嘌呤-嘌呤错配在该聚合酶活性位点的限制空间内对DNA双螺旋造成的主要物理扭曲？\n\nA. 所形成的G-A配对将比标准碱基对宽得多，从而形成一个凸起，与活性位点的氨基酸残基产生空间位阻。\n\nB. G-A配对将比标准碱基对窄得多，导致DNA双螺旋向内塌陷，并与活性位点中的关键催化残基失去接触。\n\nC. 这种错配会阻止碱基之间形成任何氢键，导致新添加的腺嘌呤立即解离。\n\nD. 这种不正确的配对会在糖-磷酸骨架上引起一个剧烈且不自然的弯曲，打断紧邻错配碱基上游的磷酸二酯键。\n\nE. G-A配对将与正确的G-C配对具有相同的宽度，因此不会发生物理扭曲，但是碱基之间的电子排斥会使酶变得不稳定。", "solution": "DNA双螺旋通过一个嘌呤与一个嘧啶配对来维持一个近乎恒定的螺旋直径；这保持了一个统一的C1'-C1'距离，并符合聚合酶活性位点经优化以识别和稳定的Watson-Crick几何结构。像$G$与$A$相对这样的嘌呤-嘌呤错配，会使两个较大的双环碱基彼此相对，从而增加了局部碱基对的宽度（相对于一个标准的$G$-$C$配对）。聚合酶活性位点为实现正确的Watson-Crick配对而强制要求形状互补性和特定的几何结构；因此，一个变宽的嘌呤-嘌呤配对会产生一个空间凸起，与活性位点中的氨基酸残基发生冲突，并使复合物不稳定。\n\n根据这些原则评估各个选项：选项A正确地指出，一个$G$-$A$配对会比标准碱基对更宽，并会在活性位点内造成空间位阻。选项B是错误的，因为嘌呤-嘌呤配对并不会更窄。选项C是错误的，因为$G$-$A$错配可以采取摇摆（wobble）或剪切（sheared）构象，从而形成有限的氢键；立即解离并非活性位点内的主要效应。选项D是错误的，因为错配并不会立即诱导磷酸二酯键断裂；骨架断裂需要特定的催化化学反应，而非仅仅由碱基对的几何形状驱动。选项E是错误的，因为$G$-$A$配对的宽度与$G$-$C$配对的宽度不同；主要的扭曲是空间扩张，而不仅仅是电子排斥。\n\n因此，最好的描述是嘌呤-嘌呤错配更宽，并导致一个凸起，从而在活性位点中引起空间位阻。", "answer": "$$\\boxed{A}$$", "id": "1516177"}, {"introduction": "虽然我们通常认为DNA碱基是静态的结构，但它们可以经历被称为互变异构的微妙、短暂的化学变化。这个练习将引导你逐步分析一个鸟嘌呤碱基上短暂的化学变化，如何在几轮复制后导致基因组中产生一个永久性的突变。这项实践将加深你对自发突变的化学起源以及错误如何在细胞分裂中传播的理解。[@problem_id:1516208]", "problem": "在对脱氧核糖核酸（DNA）自发突变的研究中，含氮碱基的互变异构是一个关键机制。通常情况下，在DNA双螺旋结构中，腺嘌呤（A）通过两个氢键与胸腺嘧啶（T）配对，鸟嘌呤（G）通过三个氢键与胞嘧啶（C）配对。鸟嘌呤和胸腺嘧啶通常以稳定的酮式结构存在。然而，鸟嘌呤可以发生短暂的互变异构，转变为罕见的烯醇式结构。在其常见的酮式结构中，鸟嘌呤6号位（O6）的氧作为氢键受体，1号位（N1）的氮作为氢键供体。在其罕见的烯醇式结构中，一个质子从N1转移到O6，导致O6变为氢键供体，而N1变为氢键受体。这种改变的模式使得烯醇式的鸟嘌呤能够与酮式的胸腺嘧啶形成稳定的碱基对。\n\n考虑一个具有以下序列的DNA分子片段：\n5'-ATGC-3'\n3'-TACG-5'\n\n在一次特定的DNA复制事件中，上游链（位于第三个位置）的鸟嘌呤（G）碱基在被复制的瞬间，短暂地转变为其烯醇互变异构体。在新的互补碱基被整合进去之后，它立即恢复到其稳定的酮式结构。假设没有DNA修复机制被激活。在此事件之后，该细胞及其后代会进行第二轮完整的DNA复制。由此产生的四个子二代DNA分子中，将有一个携带一个固定的点突变。\n\n在这个被稳定突变的子二代DNA分子中，第三个位置的碱基对将会是什么？\n\nA. G-C\n\nB. A-T\n\nC. T-A\n\nD. C-G\n\nE. G-T", "solution": "原始双链：\n上游链：5'-ATGC-3'\n下游链：3'-TACG-5'\n在第3个位置，正常的碱基对是G（上游链）与C（下游链）相对。\n\n在第一次复制期间，上游链作为模板。第3个位置的鸟嘌呤短暂地转变为烯醇互变异构体，并与胸腺嘧啶配对。DNA聚合酶在该烯醇式G的对面整合了T。整合后，G立即恢复为酮式，在一个子代双链中留下了一个G-T错配。第一次复制后的两个子代双链是：\n1) 错配的子代：上游链（旧）5'-ATGC-3' 与 下游链（新）3'-TATG-5' 配对（第3个位置G与T相对）。\n2) 正确的子代：上游链（新）5'-ATGC-3' 与 下游链（旧）3'-TACG-5' 配对（第3个位置G与C相对）。\n\n在第二次复制中，错配的子代会产生两种结果，因为每条链都作为模板进行正常的碱基配对：\n- 使用上游链的G（酮式）作为模板，会在其对面合成一个新的C，在该子二代中恢复G-C碱基对。\n- 使用下游链的T作为模板，会在其对面合成一个新的A，在该子二代中固定一个A-T碱基对。\n\n因此，在四个子二代DNA分子中，有一个在第3个位置携带了固定的 A-T 碱基对突变。", "answer": "$$\\boxed{B}$$", "id": "1516208"}, {"introduction": "嘌呤和嘧啶之间的区别在基因组尺度上具有深远的影响，使我们能够通过计算来区分蛋白质编码区（外显子）和非编码区（内含子）。这项高级的、动手的编程实践挑战你开发一个机器学习分类器，该分类器基于嘌呤-嘧啶序列的统计特征，例如在外显子中发现的标志性的3碱基周期性。这个练习将分子生物学理论与生物信息学实践相结合，展示了如何运用基本原理来分析大规模基因组数据。[@problem_id:2423535]", "problem": "给定一些短的脱氧核糖核酸 (DNA) 片段，您必须构建一个程序，该程序仅使用源自其局部嘌呤和嘧啶组成的特征，来学习区分蛋白质编码外显子和内含子。嘌呤是腺嘌呤或鸟嘌呤，嘧啶是胞嘧啶或胸腺嘧啶。训练集包含带标签的序列。测试集包含未带标签的序列。您的程序必须从嘌呤/嘧啶图景中计算特征，在训练集上拟合一个基于特定原理的线性分类器，并以指定格式输出对测试集的预测。\n\n使用的基本依据和假设：\n- 编码理论：遗传密码以长度为 $3$ 的密码子进行读取，蛋白质编码外显子反映了密码子结构。内含子不编码氨基酸，并且缺乏密码子对齐的约束。\n- 定义：将长度为 $L$ 的序列中位置 $i$ 的每个核苷酸映射到一个二进制指示符 $x_i$，$x_i = 1$ 如果碱基是嘌呤（腺嘌呤或鸟嘌呤），$x_i = 0$ 如果是嘧啶（胞嘧啶或胸腺嘧啶）。\n- 定义：从二进制序列 $(x_1,\\dots,x_L)$ 中，定义以下特征：\n  1. 嘌呤分数 $f_1 = \\frac{1}{L}\\sum_{i=1}^L x_i$。\n  2. 标准差 $f_2 = \\sqrt{\\frac{1}{L}\\sum_{i=1}^L (x_i - \\bar{x})^2}$，其中 $\\bar{x} = \\frac{1}{L}\\sum_{i=1}^L x_i$。\n  3. 滞后-3自相关系数 $f_3 = \\rho_3$，定义为\n     $$\\rho_3 = \\begin{cases}\n     \\dfrac{\\sum_{i=1}^{L-3} (x_i - \\bar{x})(x_{i+3} - \\bar{x})}{(L-3)\\, f_2^2}, & \\text{若 } f_2^2 > 0,\\\\\n     0, & \\text{若 } f_2^2 = 0.\n     \\end{cases}$$\n  4. 游程长度对比度 $f_4 = \\mathbb{E}[L_R] - \\mathbb{E}[L_Y]$，其中 $\\mathbb{E}[L_R]$ 是连续嘌呤游程（$x_i = 1$）的平均长度，$\\mathbb{E}[L_Y]$ 是连续嘧啶游程（$x_i = 0$）的平均长度。如果一个序列不包含某种类型的游程，则按惯例将相应的平均值定义为 $0$。\n\n分类器设计要求：\n- 训练一个基于以下概率建模原理的线性分类器：假设特征向量来自具有共享协方差矩阵和相等类先验概率的类条件多元正态分布；学习一个能够区分这两个类别的线性决策规则。实现不得依赖任何允许范围之外的外部数据或库。程序必须是完全确定性的。\n\n硬编码在程序中的输入：\n- 训练集：八个带标签的序列，标签 $1$ 代表外显子， $0$ 代表内含子。每个序列被指定为一个基序的精确重复：\n  - 外显子序列（标签 $1$）：\n    1. 将基序“AAT”精确重复 $30$ 次。\n    2. 将基序“GAA”精确重复 $30$ 次。\n    3. 将基序“CCG”精确重复 $30$ 次。\n    4. 将基序“ATG”精确重复 $30$ 次。\n  - 内含子序列（标签 $0$）：\n    1. 将基序“ACGT”精确重复 $24$ 次。\n    2. 将基序“TCGA”精确重复 $24$ 次。\n    3. 将基序“TTTCCCTTTCCC”精确重复 $5$ 次。\n    4. 将基序“AGCT”精确重复 $24$ 次。\n\n- 测试套件：六个要分类的未标记序列，通过将指定的基序重复指定的次数来构建：\n  1. 将“AAT”精确重复 $20$ 次。\n  2. 将“ACGT”精确重复 $15$ 次。\n  3. 将“TTTCCCTTTCCC”精确重复 $3$ 次。\n  4. 将“ATG”精确重复 $20$ 次。\n  5. 一个由 $60$ 个腺嘌呤（“A”）组成的序列。\n  6. 将“AGCT”精确重复 $15$ 次。\n\n算法和实现要求：\n- 使用嘌呤/嘧啶指示符定义，将每个序列映射到 $(x_1,\\dots,x_L)$。\n- 为每个序列计算特征向量 $(f_1,f_2,f_3,f_4)$。\n- 在训练特征向量上，使用共享协方差高斯假设和相等先验概率来拟合线性分类器，并用它来预测测试特征向量的标签。所有计算都必须使用有限维线性代数执行。如果任何协方差矩阵是奇异的或病态的，您必须使用 Moore–Penrose 伪逆。\n- 所有中间量都必须以浮点运算进行计算。不涉及物理单位或角度。\n- 需要明确处理的边界情况：\n  - 如果 $f_2^2 = 0$，则设置 $\\rho_3 = 0$。\n  - 如果没有嘌呤游程或没有嘧啶游程，在计算 $f_4$ 时将相应的平均游程长度设置为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个测试序列的预测标签，形式为用方括号括起来的逗号分隔的整数列表，例如，“[1,0,1,1,0,0]”。顺序必须与上面列出的顺序相匹配。\n\n答案规范：\n- 输出是集合 $\\{0,1\\}$ 中的整数。\n\n您的程序必须是完整且可直接运行的。它不能读取任何外部输入。它必须只使用指定的库。", "solution": "所提出的问题是计算生物学中的一个二元分类任务：区分对应于外显子的脱氧核糖核酸 (DNA) 序列与对应于内含子的序列。此任务必须通过构建一个仅基于序列局部嘌呤和嘧啶组成衍生特征的线性分类器来完成。该问题定义明确，有科学依据，并为唯一的、可验证的解决方案提供了所有必要的数据和约束。\n\n解决方案分为三个主要阶段。首先，我们形式化特征提取过程，将每个 DNA 序列转换为一个低维数值向量。其次，我们根据问题陈述的规定，从第一性原理推导线性分类器。第三，我们概述用于训练分类器和预测测试序列标签的完整算法流程。\n\n**1. 基于嘌呤-嘧啶内容的特征工程**\n\n核心假设是，由于编码区域存在密码子结构，外显子和内含子之间嘌呤和嘧啶分布的统计特性有所不同。我们首先将给定长度为 $L$ 的 DNA 序列转换为一个二进制数值序列。\n\n设一个 DNA 序列表示为 $S = (s_1, s_2, \\dots, s_L)$，其中 $s_i \\in \\{\\text{'A'}, \\text{'C'}, \\text{'G'}, \\text{'T'}\\}$。我们为从 $1$ 到 $L$ 的每个位置 $i$ 定义一个二进制指示变量 $x_i$。该映射基于核苷酸的化学分类：\n- 腺嘌呤（'A'）和鸟嘌呤（'G'）是嘌呤。\n- 胞嘧啶（'C'）和胸腺嘧啶（'T'）是嘧啶。\n\n二进制序列 $\\mathbf{x} = (x_1, x_2, \\dots, x_L)$ 定义如下：\n$$\nx_i = \\begin{cases} 1 & \\text{如果 } s_i \\text{ 是嘌呤 (A 或 G)} \\\\ 0 & \\text{如果 } s_i \\text{ 是嘧啶 (C 或 T)} \\end{cases}\n$$\n根据此二进制序列，我们计算一个 $4$ 维特征向量 $\\mathbf{f} = (f_1, f_2, f_3, f_4)$。\n\n**特征 $f_1$：嘌呤分数**\n此特征衡量了对嘌呤的整体组成偏向性。它是二进制序列的平均值。\n$$ f_1 = \\bar{x} = \\frac{1}{L} \\sum_{i=1}^L x_i $$\n\n**特征 $f_2$：标准差**\n此特征衡量了嘌呤/嘧啶含量的局部变化。它是二进制序列的标准差。具有均匀组成（全为嘌呤或全为嘧啶）的序列将有 $f_2 = 0$。\n$$ f_2 = \\sqrt{\\frac{1}{L} \\sum_{i=1}^L (x_i - \\bar{x})^2} $$\n对于伯努利变量序列，方差就是 $f_2^2 = \\bar{x}(1-\\bar{x})$，但在计算中采用直接公式。\n\n**特征 $f_3$：滞后-3自相关系数**\n这是用于检测编码潜力的最关键特征。遗传密码以密码子（即核苷酸三联体）形式读取。这给外显子序列的统计特性带来了周期为 $3$ 的规律性，而内含子中则不存在这种规律性。滞后-3自相关 $\\rho_3$ 就是为捕捉此信号而设计的。\n$$\nf_3 = \\rho_3 = \\begin{cases}\n     \\dfrac{\\sum_{i=1}^{L-3} (x_i - \\bar{x})(x_{i+3} - \\bar{x})}{(L-3)\\, f_2^2}, & \\text{若 } f_2^2 > 0,\\\\\n     0, & \\text{若 } f_2^2 = 0.\n     \\end{cases}\n$$\n对于具有强周期为 $3$ 的信号的序列，我们期望 $x_i \\approx x_{i+3}$，从而导致 $\\rho_3$ 具有较高的正值。对于随机序列，我们期望 $\\rho_3 \\approx 0$。\n\n**特征 $f_4$：游程长度对比度**\n此特征量化了连续嘌呤段与连续嘧啶段长度的差异。设 $\\mathbb{E}[L_R]$ 为嘌呤游程（其中 $x_i=1$）的平均长度，$\\mathbb{E}[L_Y]$ 为嘧啶游程（其中 $x_i=0$）的平均长度。\n$$ f_4 = \\mathbb{E}[L_R] - \\mathbb{E}[L_Y] $$\n按照惯例，如果一个序列不包含某种类型的游程（例如，一个全为嘌呤的序列没有嘧啶游程），则相应的平均长度定义为 $0$。\n\n**2. 分类器设计：线性判别分析**\n\n该问题要求基于特定的生成模型训练一个线性分类器。我们假设每个类别 $k \\in \\{0, 1\\}$（其中 $1$ 是外显子，$0$ 是内含子）的特征向量来自多元正态分布，$p(\\mathbf{f}|C_k) = \\mathcal{N}(\\mathbf{f} | \\boldsymbol{\\mu}_k, \\boldsymbol{\\Sigma}_k)$。问题规定了两个关键约束：协方差矩阵是共享的（$\\boldsymbol{\\Sigma}_1 = \\boldsymbol{\\Sigma}_0 = \\boldsymbol{\\Sigma}$）且类先验概率是相等的（$P(C_1) = P(C_0) = 0.5$）。此模型被称为线性判别分析（LDA）。\n\n首先，我们从训练集中估计模型参数，该训练集包含 $N$ 个特征向量 $\\{\\mathbf{f}_i\\}_{i=1}^N$ 及其对应的标签 $\\{y_i\\}_{i=1}^N$。设 $N_1$ 为外显子样本数，$N_0$ 为内含子样本数。\n\n类别均值 $\\boldsymbol{\\mu}_1$ 和 $\\boldsymbol{\\mu}_0$ 通过每个类别内特征向量的样本均值来估计：\n$$ \\boldsymbol{\\mu}_k = \\frac{1}{N_k} \\sum_{i: y_i=k} \\mathbf{f}_i \\quad \\text{对于 } k \\in \\{0, 1\\} $$\n\n共享协方差矩阵 $\\boldsymbol{\\Sigma}$ 通过两个类别的合并协方差来估计。这是一个无偏估计：\n$$ \\boldsymbol{\\Sigma} = \\frac{1}{N_0 + N_1 - 2} \\left[ \\sum_{i: y_i=0} (\\mathbf{f}_i - \\boldsymbol{\\mu}_0)(\\mathbf{f}_i - \\boldsymbol{\\mu}_0)^T + \\sum_{i: y_i=1} (\\mathbf{f}_i - \\boldsymbol{\\mu}_1)(\\mathbf{f}_i - \\boldsymbol{\\mu}_1)^T \\right] $$\n\n新特征向量 $\\mathbf{f}$ 的分类基于后验概率比，该比率由贝叶斯定理推导得出。如果 $P(C_1|\\mathbf{f}) > P(C_0|\\mathbf{f})$，我们将其分类为类别 $1$，这等价于比较它们的对数比率与 $0$ 的大小。\n$$ \\ln\\frac{P(C_1|\\mathbf{f})}{P(C_0|\\mathbf{f})} = \\ln\\frac{p(\\mathbf{f}|C_1)P(C_1)}{p(\\mathbf{f}|C_0)P(C_0)} > 0 $$\n在先验概率相等的情况下，这简化为 $\\ln p(\\mathbf{f}|C_1) - \\ln p(\\mathbf{f}|C_0) > 0$。代入多元正态概率密度函数并化简，$\\mathbf{f}$ 中的二次项会抵消，从而得到一个线性决策规则。\n$$ (\\mathbf{f} - \\boldsymbol{\\mu}_0)^T \\boldsymbol{\\Sigma}^{-1} (\\mathbf{f} - \\boldsymbol{\\mu}_0) - (\\mathbf{f} - \\boldsymbol{\\mu}_1)^T \\boldsymbol{\\Sigma}^{-1} (\\mathbf{f} - \\boldsymbol{\\mu}_1) < 0 $$\n展开并整理各项，得到决策函数：\n$$ \\mathbf{w}^T \\mathbf{f} - c > 0 $$\n其中权重向量 $\\mathbf{w}$ 和阈值 $c$ 定义为：\n$$ \\mathbf{w} = \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{\\mu}_1 - \\boldsymbol{\\mu}_0) $$\n$$ c = \\frac{1}{2} (\\boldsymbol{\\mu}_1^T \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}_1 - \\boldsymbol{\\mu}_0^T \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}_0) = \\mathbf{w}^T \\left( \\frac{\\boldsymbol{\\mu}_0 + \\boldsymbol{\\mu}_1}{2} \\right) $$\n根据指令，如果矩阵 $\\boldsymbol{\\Sigma}$ 是奇异的或病态的，则使用其 Moore-Penrose 伪逆 $\\boldsymbol{\\Sigma}^{\\dagger}$ 来代替 $\\boldsymbol{\\Sigma}^{-1}$。\n对于一个测试向量 $\\mathbf{f}_{\\text{test}}$ 的最终预测 $\\hat{y}$ 是：\n$$ \\hat{y} = \\begin{cases} 1 & \\text{如果 } \\mathbf{w}^T \\mathbf{f}_{\\text{test}} > c \\\\ 0 & \\text{否则} \\end{cases} $$\n\n**3. 算法流程**\n\n实现直接遵循上述原理。\n\n1.  **数据表示**：通过重复指定的基序来生成训练和测试序列。\n2.  **特征计算**：\n    -   创建一个函数，将 DNA 序列字符串映射到其二进制的嘌呤/嘧啶表示。\n    -   创建第二个函数，为任何给定的二进制序列计算 $4$ 维特征向量 $(f_1, f_2, f_3, f_4)$。此函数必须正确实现指定的公式，并处理 $f_3$（当 $f_2=0$ 时）和 $f_4$（当某种类型的游程不存在时）的边界情况。\n3.  **训练阶段**：\n    -   为所有 $N_1=4$ 个外显子训练序列和所有 $N_0=4$ 个内含子训练序列计算特征向量。\n    -   计算类别均值向量 $\\boldsymbol{\\mu}_0$ 和 $\\boldsymbol{\\mu}_1$。\n    -   计算合并协方差矩阵 $\\boldsymbol{\\Sigma}$。\n    -   使用数值线性代数程序计算伪逆 $\\boldsymbol{\\Sigma}^{\\dagger}$。\n    -   确定分类器权重向量 $\\mathbf{w}$ 和决策阈值 $c$。\n4.  **预测阶段**：\n    -   对于 $6$ 个测试序列中的每一个，计算其特征向量 $\\mathbf{f}_{\\text{test}}$。\n    -   对于每个 $\\mathbf{f}_{\\text{test}}$，计算判别分数 $S = \\mathbf{w}^T \\mathbf{f}_{\\text{test}}$。\n    -   将分数 $S$ 与阈值 $c$ 进行比较，以获得预测标签 $1$ 或 $0$。\n5.  **输出**：按指定顺序收集测试序列的预测标签，并将其格式化为单个输出字符串。\n\n这个严谨的、循序渐进的流程确保了解决方案既符合问题的约束，又基于已建立的统计学原理。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA sequence classification problem.\n    The solution involves feature extraction, training a Linear Discriminant Analysis (LDA)\n    classifier, and predicting labels for a test set.\n    \"\"\"\n\n    # --- 1. Data Definition ---\n    # Training set\n    train_exons_motifs = [(\"AAT\", 30), (\"GAA\", 30), (\"CCG\", 30), (\"ATG\", 30)]\n    train_introns_motifs = [(\"ACGT\", 24), (\"TCGA\", 24), (\"TTTCCCTTTCCC\", 5), (\"AGCT\", 24)]\n    \n    train_exons = [m * r for m, r in train_exons_motifs]\n    train_introns = [m * r for m, r in train_introns_motifs]\n    \n    # Test set\n    test_motifs = [\n        (\"AAT\", 20),\n        (\"ACGT\", 15),\n        (\"TTTCCCTTTCCC\", 3),\n        (\"ATG\", 20),\n        (\"A\", 60),\n        (\"AGCT\", 15),\n    ]\n    test_sequences = [m * r for m, r in test_motifs]\n\n    # --- 2. Feature Extraction ---\n    \n    def dna_to_binary(seq):\n        \"\"\"Maps a DNA sequence to a binary purine(1)/pyrimidine(0) sequence.\"\"\"\n        purines = {'A', 'G'}\n        return np.array([1 if base in purines else 0 for base in seq], dtype=np.float64)\n\n    def compute_features(seq_str):\n        \"\"\"Computes the 4-dimensional feature vector for a DNA sequence.\"\"\"\n        L = len(seq_str)\n        if L == 0:\n            return np.zeros(4)\n\n        x = dna_to_binary(seq_str)\n        \n        # f1: Purine fraction\n        f1 = np.mean(x)\n\n        # f2: Standard deviation\n        # use np.var to avoid floating point issues from (x_i - mean(x))^2\n        var_x = np.var(x)\n        f2 = np.sqrt(var_x)\n\n        # f3: Lag-3 autocorrelation\n        if var_x > 1e-12:  # Check for f2^2 > 0 with tolerance\n            x_minus_mean = x - f1\n            numerator = np.sum(x_minus_mean[:-3] * x_minus_mean[3:])\n            denominator = (L - 3) * var_x\n            f3 = numerator / denominator if denominator != 0 else 0.0\n        else:\n            f3 = 0.0\n\n        # f4: Run-length contrast\n        if L > 0:\n            runs_R = []\n            runs_Y = []\n            current_run_type = x[0]\n            current_run_length = 1\n            for i in range(1, L):\n                if x[i] == current_run_type:\n                    current_run_length += 1\n                else:\n                    if current_run_type == 1:\n                        runs_R.append(current_run_length)\n                    else:\n                        runs_Y.append(current_run_length)\n                    current_run_type = x[i]\n                    current_run_length = 1\n            # Add the last run\n            if current_run_type == 1:\n                runs_R.append(current_run_length)\n            else:\n                runs_Y.append(current_run_length)\n\n            mean_R = np.mean(runs_R) if runs_R else 0.0\n            mean_Y = np.mean(runs_Y) if runs_Y else 0.0\n            f4 = mean_R - mean_Y\n        else:\n            f4 = 0.0\n            \n        return np.array([f1, f2, f3, f4])\n\n    # --- 3. Training the LDA Classifier ---\n\n    # Compute feature vectors for training data\n    features_exons = np.array([compute_features(s) for s in train_exons])\n    features_introns = np.array([compute_features(s) for s in train_introns])\n    \n    # Estimate parameters\n    mu1 = np.mean(features_exons, axis=0) # Exon mean\n    mu0 = np.mean(features_introns, axis=0) # Intron mean\n\n    N1 = len(features_exons)\n    N0 = len(features_introns)\n    \n    # Pooled covariance matrix\n    S1 = np.zeros((4, 4))\n    for f in features_exons:\n        diff = (f - mu1).reshape(4, 1)\n        S1 += diff @ diff.T\n\n    S0 = np.zeros((4, 4))\n    for f in features_introns:\n        diff = (f - mu0).reshape(4, 1)\n        S0 += diff @ diff.T\n        \n    # Unbiased estimate of shared covariance\n    pooled_sigma = (S1 + S0) / (N1 + N0 - 2)\n    \n    # Use Moore-Penrose pseudoinverse for stability\n    sigma_inv = np.linalg.pinv(pooled_sigma)\n\n    # Calculate LDA weights and threshold\n    w = sigma_inv @ (mu1 - mu0)\n    c = w @ (mu1 + mu0) / 2.0\n\n    # --- 4. Prediction on Test Set ---\n    \n    predictions = []\n    for seq in test_sequences:\n        f_test = compute_features(seq)\n        score = w @ f_test\n        prediction = 1 if score > c else 0\n        predictions.append(prediction)\n        \n    # --- 5. Output ---\n    \n    print(f\"[{','.join(map(str, predictions))}]\")\n\nsolve()\n```", "id": "2423535"}]}