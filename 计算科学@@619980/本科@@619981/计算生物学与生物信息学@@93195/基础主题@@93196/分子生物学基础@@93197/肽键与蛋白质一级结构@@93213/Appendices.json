{"hands_on_practices": [{"introduction": "蛋白质的一级结构不仅是氨基酸的线性排列，更是具有不同化学性质的功能基团的序列。这个练习将引导你超越简单的字符匹配，通过将氨基酸按照疏水性、电荷等理化性质进行分类，来寻找两条序列之间在“性质层面”上的最长公共子序列。这项实践是序列比对和同源性分析中的核心技能，能帮助你理解功能的保守性为何常常体现在化学性质而非精确的氨基酸身份上。[@problem_id:2412673]", "problem": "给定一个在包含20种标准氨基酸（单字母代码）的集合$\\mathcal{A}$上的固定物理化学分类函数$M:\\mathcal{A}\\to\\{0,1,2,3,4,5,6\\}$，当且仅当两个残基在函数$M$下映射到同一个类别时，它们才被视为匹配。映射$M$根据粗略的物理化学性质对残基进行分组，如下所示：\n- 类别 $0$（脂肪族疏水性）：A, V, L, I, M\n- 类别 $1$（芳香族）：F, W, Y\n- 类别 $2$（极性不带电）：S, T, N, Q, C\n- 类别 $3$（酸性）：D, E\n- 类别 $4$（碱性）：K, R, H\n- 类别 $5$（小分子，甘氨酸）：G\n- 类别 $6$（特殊构象，脯氨酸）：P\n\n对于一对一级序列$X$和$Y$（$\\mathcal{A}$上的字符串），它们的物理化学类别序列$X'$和$Y'$通过$X'[i]=M(X[i])$和$Y'[j]=M(Y[j])$来定义。最长公共物理化学子序列长度$L(X,Y)$是满足以下条件的最大整数$k$：存在严格递增的索引序列$1\\le i_1&lt;i_2&lt;\\dots&lt;i_k\\le |X|$和$1\\le j_1&lt;j_2&lt;\\dots&lt;j_k\\le |Y|$，且对于所有$t\\in\\{1,\\dots,k\\}$，都有$X'[i_t]=Y'[j_t]$。这里，$|X|$和$|Y|$分别表示$X$和$Y$的长度。\n\n任务：对于下方的每个测试用例，计算$L(X,Y)$，即上述定义的最长公共物理化学子序列的长度。\n\n测试集（每个项目是一个有序对$(X,Y)$）：\n- 案例 1：$X=$ \"MTEYKLVVVGAGGVGKS\", $Y=$ \"GAGGVGKTCLLISYTTN\"\n- 案例 2：$X=$ \"DDEEEDD\", $Y=$ \"KKRHHK\"\n- 案例 3：$X=$ \"\", $Y=$ \"ACDE\"\n- 案例 4：$X=$ \"ACDEFGHIKLMNPQRSTVWY\", $Y=$ \"ACDEFGHIKLMNPQRSTVWY\"\n- 案例 5：$X=$ \"DEDE\", $Y=$ \"EEDD\"\n\n答案规格：\n- 对于每个案例，输出单个整数$L(X,Y)$（无其他数据类型）。\n- 将所有案例的结果按顺序聚合到一个单行的列表字面量中：一个用方括号括起来的逗号分隔列表，例如，“[a,b,c,d,e]”，其中$a,b,c,d,e$是整数。输出中不应出现空格。\n\n不涉及物理单位。您的程序不能读取任何输入，并且必须以指定格式精确地产生一行输出。", "solution": "问题陈述已经过分析，并被确定为有效。它具有科学依据，定义明确，客观，并包含得出唯一解所需的所有必要信息。该问题要求计算两个蛋白质序列之间最长公共子序列的长度，但不是基于氨基酸字母表本身，而是基于一个派生的物理化学类别字母表。这是生物信息学中的一个标准程序，它将一个基本的生物学概念与一个经典的计算机科学算法相结合。\n\n解决方案分为两步：首先，将输入的氨基酸序列转换为物理化学类别索引序列；其次，应用动态规划算法来找出这些转换后序列的最长公共子序列（LCS）的长度。\n\n第一步：物理化学转换\n\n问题定义了一个映射函数$M$，它从20种标准氨基酸的字母表$\\mathcal{A}$映射到一组整数类别标签$\\{0, 1, 2, 3, 4, 5, 6\\}$。该映射定义如下：\n- 类别 $0$（脂肪族疏水性）：$M(\\text{'A'}) = M(\\text{'V'}) = M(\\text{'L'}) = M(\\text{'I'}) = M(\\text{'M'}) = 0$\n- 类别 $1$（芳香族）：$M(\\text{'F'}) = M(\\text{'W'}) = M(\\text{'Y'}) = 1$\n- 类别 $2$（极性不带电）：$M(\\text{'S'}) = M(\\text{'T'}) = M(\\text{'N'}) = M(\\text{'Q'}) = M(\\text{'C'}) = 2$\n- 类别 $3$（酸性）：$M(\\text{'D'}) = M(\\text{'E'}) = 3$\n- 类别 $4$（碱性）：$M(\\text{'K'}) = M(\\text{'R'}) = M(\\text{'H'}) = 4$\n- 类别 $5$（小分子，甘氨酸）：$M(\\text{'G'}) = 5$\n- 类别 $6$（特殊构象，脯氨酸）：$M(\\text{'P'}) = 6$\n\n对于任何给定的输入序列对$X$（长度为$m = |X|$）和$Y$（长度为$n = |Y|$），我们首先计算它们对应的物理化学类别序列$X'$和$Y'$。这些整数序列是通过将映射$M$应用于每个残基来构建的：\n- $X' = [M(X_1), M(X_2), \\dots, M(X_m)]$\n- $Y' = [M(Y_1), M(Y_2), \\dots, M(Y_n)]$\n\n然后，问题就归结为找到$X'$和$Y'$的最长公共子序列的长度。\n\n第二步：最长公共子序列 (LCS) 算法\n\n序列$X'$和$Y'$的LCS长度是使用标准的动态规划方法计算的。令$dp[i][j]$为前缀$X'[1..i]$和$Y'[1..j]$的最长公共子序列的长度。$dp[i][j]$的值可以使用以下递推关系计算：\n\n$$\ndp[i][j] =\n\\begin{cases}\n0 & \\text{如果 } i=0 \\text{ 或 } j=0 \\\\\n1 + dp[i-1][j-1] & \\text{如果 } i,j > 0 \\text{ 且 } X'[i-1] = Y'[j-1] \\\\\n\\max(dp[i-1][j], dp[i][j-1]) & \\text{如果 } i,j > 0 \\text{ 且 } X'[i-1] \\neq Y'[j-1]\n\\end{cases}\n$$\n\n这里，序列$X'$和$Y'$的索引是从0开始的，这在计算实现中是常规做法，而$dp$表的索引$i$和$j$的范围分别是$0$到$m$和$0$到$n$。基本情况$dp[i][0] = 0$和$dp[0][j] = 0$（对于所有$i, j$）确立了任何序列与空序列的LCS长度为$0$。对于完整序列$X'$和$Y'$的最终答案，即LCS的长度，由$L(X, Y) = dp[m][n]$给出。\n\n此过程将应用于所提供的每个测试用例。例如，在案例1中：\n- $X = \\text{\"MTEYKLVVVGAGGVGKS\"}$\n- $Y = \\text{\"GAGGVGKTCLLISYTTN\"}$\n\n序列被转换为它们的类别表示：\n- $X' = [0, 2, 3, 1, 4, 0, 0, 0, 0, 5, 0, 5, 5, 0, 5, 4, 2]$\n- $Y' = [5, 0, 5, 5, 0, 5, 4, 2, 2, 0, 0, 0, 2, 1, 2, 2, 2]$\n\n对$X'$和$Y'$（长度均为17）应用动态规划算法，得出LCS长度为9。\n\n相同的方法得出其他案例的结果：\n- 案例 2：$X = \\text{\"DDEEEDD\"}$，$Y = \\text{\"KKRHHK\"}$。转换后的序列是$X'=[3,3,3,3,3,3,3]$和$Y'=[4,4,4,4,4,4]$。它们没有共同元素，因此LCS长度为0。\n- 案例 3：$X = \\text{\"\"}$，$Y = \\text{\"ACDE\"}$。由于$X$是空序列，LCS长度为0。\n- 案例 4：$X = \\text{\"ACDEFGHIKLMNPQRSTVWY\"}$，$Y = \\text{\"ACDEFGHIKLMNPQRSTVWY\"}$。这两个序列是相同的，因此它们转换后的序列也是相同的。LCS的长度就是序列的长度，即20。\n- 案例 5：$X = \\text{\"DEDE\"}$，$Y = \\text{\"EEDD\"}$。转换后的序列是$X'=[3,3,3,3]$和$Y'=[3,3,3,3]$。它们是相同的，因此LCS长度为4。\n\n因此，最终计算出的结果是[9, 0, 0, 20, 4]。下面的程序实现了这一完整逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the length of the longest common physicochemical subsequence for a suite of test cases.\n    \"\"\"\n\n    # Define the fixed physicochemical classification function M.\n    # A dictionary provides an efficient implementation of the mapping.\n    PHYSICOCHEMICAL_MAP = {\n        'A': 0, 'V': 0, 'L': 0, 'I': 0, 'M': 0,  # Class 0: Aliphatic hydrophobic\n        'F': 1, 'W': 1, 'Y': 1,                  # Class 1: Aromatic\n        'S': 2, 'T': 2, 'N': 2, 'Q': 2, 'C': 2,  # Class 2: Polar uncharged\n        'D': 3, 'E': 3,                          # Class 3: Acidic\n        'K': 4, 'R': 4, 'H': 4,                  # Class 4: Basic\n        'G': 5,                                  # Class 5: Glycine\n        'P': 6                                   # Class 6: Proline\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MTEYKLVVVGAGGVGKS\", \"GAGGVGKTCLLISYTTN\"), # Case 1\n        (\"DDEEEDD\", \"KKRHHK\"),                     # Case 2\n        (\"\", \"ACDE\"),                              # Case 3\n        (\"ACDEFGHIKLMNPQRSTVWY\", \"ACDEFGHIKLMNPQRSTVWY\"), # Case 4\n        (\"DEDE\", \"EEDD\"),                          # Case 5\n    ]\n    \n    def compute_lcs_length(X: str, Y: str) -> int:\n        \"\"\"\n        Calculates the length of the longest common physicochemical subsequence.\n        \n        Args:\n            X: The first protein sequence.\n            Y: The second protein sequence.\n            \n        Returns:\n            The integer length of the LCS of the transformed sequences.\n        \"\"\"\n        # Step 1: Transform amino acid sequences into physicochemical class sequences.\n        X_prime = [PHYSICOCHEMICAL_MAP[residue] for residue in X]\n        Y_prime = [PHYSICOCHEMICAL_MAP[residue] for residue in Y]\n        \n        m = len(X_prime)\n        n = len(Y_prime)\n\n        # Handle trivial case of empty sequences.\n        if m == 0 or n == 0:\n            return 0\n        \n        # Step 2: Compute LCS length using dynamic programming.\n        # Initialize a DP table of size (m+1) x (n+1) with zeros.\n        # dp[i][j] will store the LCS length of X_prime[:i] and Y_prime[:j].\n        dp = np.zeros((m + 1, n + 1), dtype=np.int32)\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # If the current elements match, extend the LCS from the previous subproblem.\n                if X_prime[i - 1] == Y_prime[j - 1]:\n                    dp[i, j] = 1 + dp[i - 1, j - 1]\n                # If they don't match, take the maximum LCS length from the two possible subproblems.\n                else:\n                    dp[i, j] = max(dp[i - 1, j], dp[i, j - 1])\n                    \n        # The final result is in the bottom-right corner of the table.\n        return int(dp[m, n])\n\n    results = []\n    for x_seq, y_seq in test_cases:\n        lcs_len = compute_lcs_length(x_seq, y_seq)\n        results.append(lcs_len)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412673"}, {"introduction": "蛋白质的稳定性是其行使功能的物理化学基础，而一级结构中的微小变化（突变）就可能破坏这种稳定性。本练习通过一个基于Kyte-Doolittle疏水性标度的简化模型，让你亲手量化序列突变的潜在影响。你将编写一个程序来计算“一级序列脆弱性”（$F(s,\\tau)$），即随机单点突变导致蛋白质不稳定的概率，从而深入理解序列、性质与功能之间的定量关系，并体验如何将生物学概念形式化为可计算的模型。[@problem_id:2412732]", "problem": "给定蛋白质基于一级序列的稳定性代理及其相应脆性度量的形式化定义。设一级结构为标准 $20$ 字母氨基酸字母表 $\\mathcal{A}=\\{\\text{A},\\text{R},\\text{N},\\text{D},\\text{C},\\text{Q},\\text{E},\\text{G},\\text{H},\\text{I},\\text{L},\\text{K},\\text{M},\\text{F},\\text{P},\\text{S},\\text{T},\\text{W},\\text{Y},\\text{V}\\}$ 上的字符串。使用 Kyte–Doolittle 亲水性指数值定义一个亲水性函数 $h:\\mathcal{A}\\to\\mathbb{R}$ 如下：$h(\\text{A})=1.8$, $h(\\text{R})=-4.5$, $h(\\text{N})=-3.5$, $h(\\text{D})=-3.5$, $h(\\text{C})=2.5$, $h(\\text{Q})=-3.5$, $h(\\text{E})=-3.5$, $h(\\text{G})=-0.4$, $h(\\text{H})=-3.2$, $h(\\text{I})=4.5$, $h(\\text{L})=3.8$, $h(\\text{K})=-3.9$, $h(\\text{M})=1.9$, $h(\\text{F})=2.8$, $h(\\text{P})=-1.6$, $h(\\text{S})=-0.8$, $h(\\text{T})=-0.7$, $h(\\text{W})=-0.9$, $h(\\text{Y})=-1.3$, $h(\\text{V})=4.2$。\n\n对于长度为 $L$ 的序列 $s=s_1 s_2\\cdots s_L$，其稳定性代理 $E(s)$ 由跨肽键的最近邻相互作用定义：\n$$\nE(s)=\\sum_{i=1}^{L-1} h(s_i)\\,h(s_{i+1}).\n$$\n按照惯例，对于 $L=1$，空和等于 $0$，因此 $E(s)=0$。\n\n单点突变体 $s^{(i\\to x)}$ 是通过将位置 $i\\in\\{1,2,\\dots,L\\}$ 的一个氨基酸替换为 $x\\in\\mathcal{A}\\setminus\\{s_i\\}$ 而得到的。对于一个非负的去稳定化阈值 $\\tau\\ge 0$，一个单点突变当且仅当满足以下条件时被认为是去稳定化的：\n$$\nE\\bigl(s^{(i\\to x)}\\bigr) < E(s)-\\tau.\n$$\n\n将一级序列脆性 $F(s,\\tau)$ 定义为所有单点突变体中去稳定化突变体所占的比例：\n$$\nF(s,\\tau) = \\frac{D(s,\\tau)}{19\\,L},\n$$\n其中 $D(s,\\tau)$ 是在 $19\\,L$ 种可能的单点替换中，去稳定化单点突变体的数量。每个测试用例所需的输出是 $F(s,\\tau)$ 的值，以四舍五入到 $6$ 位小数的小数形式表示。不要使用百分号；将该分数报告为小数。\n\n您的任务是编写一个完整的、可运行的程序，根据上述定义为下面的每个测试用例计算 $F(s,\\tau)$。测试用例集是：\n\n- 具有中等阈值的通用情况：$s=\\text{\"MKTIIALSYIFCLVFAD\"}$，$\\tau=0.25$。\n- $L=1$ 的边界情况：$s=\\text{\"G\"}$，$\\tau=0.0$。\n- 疏水性片段：$s=\\text{\"VVVV\"}$，$\\tau=0.0$。\n- 疏水/亲水交替模式：$s=\\text{\"DVDVDV\"}$，$\\tau=0.0$。\n- 大阈值（应产生零脆性）：$s=\\text{\"ACDEFGHIKLMNPQRSTVWY\"}$，$\\tau=100.0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\dots]$）。结果必须与上述测试用例的顺序相同，并且每个值必须四舍五入到 $6$ 位小数。", "solution": "在尝试任何解决方案之前，需要对问题陈述进行验证。\n\n### 第一步：提取已知信息\n\n-   **字母表**：$\\mathcal{A}=\\{\\text{A},\\text{R},\\text{N},\\text{D},\\text{C},\\text{Q},\\text{E},\\text{G},\\text{H},\\text{I},\\text{L},\\text{K},\\text{M},\\text{F},\\text{P},\\text{S},\\text{T},\\text{W},\\text{Y},\\text{V}\\}$，一个包含 $20$ 种标准氨基酸的集合。\n-   **亲水性函数**：$h:\\mathcal{A}\\to\\mathbb{R}$ 由 Kyte–Doolittle 指数定义：$h(\\text{A})=1.8$, $h(\\text{R})=-4.5$, $h(\\text{N})=-3.5$, $h(\\text{D})=-3.5$, $h(\\text{C})=2.5$, $h(\\text{Q})=-3.5$, $h(\\text{E})=-3.5$, $h(\\text{G})=-0.4$, $h(\\text{H})=-3.2$, $h(\\text{I})=4.5$, $h(\\text{L})=3.8$, $h(\\text{K})=-3.9$, $h(\\text{M})=1.9$, $h(\\text{F})=2.8$, $h(\\text{P})=-1.6$, $h(\\text{S})=-0.8$, $h(\\text{T})=-0.7$, $h(\\text{W})=-0.9$, $h(\\text{Y})=-1.3$, $h(\\text{V})=4.2$。\n-   **稳定性代理**：对于长度为 $L$ 的序列 $s=s_1 s_2\\cdots s_L$，稳定性代理为 $E(s)=\\sum_{i=1}^{L-1} h(s_i)\\,h(s_{i+1})$。对于 $L=1$，$E(s)=0$。\n-   **去稳定化突变**：一个单点突变体 $s^{(i\\to x)}$（位置 $i$ 的残基变为 $x$）相对于阈值 $\\tau\\ge 0$ 是去稳定化的，如果 $E\\bigl(s^{(i\\to x)}\\bigr) < E(s) - \\tau$。\n-   **脆性度量**：一级序列脆性 $F(s,\\tau)$ 是所有 $19\\,L$ 个单点突变体中去稳定化突变体所占的比例：$F(s,\\tau) = \\frac{D(s,\\tau)}{19\\,L}$，其中 $D(s,\\tau)$ 是此类去稳定化突变体的数量。\n-   **测试用例**：\n    1.  $s=\\text{\"MKTIIALSYIFCLVFAD\"}$, $\\tau=0.25$\n    2.  $s=\\text{\"G\"}$, $\\tau=0.0$\n    3.  $s=\\text{\"VVVV\"}$, $\\tau=0.0$\n    4.  $s=\\text{\"DVDVDV\"}$, $\\tau=0.0$\n    5.  $s=\\text{\"ACDEFGHIKLMNPQRSTVWY\"}$, $\\tau=100.0$\n-   **输出格式**：单行输出，包含一个用方括号括起来的逗号分隔的结果列表，每个结果四舍五入到 $6$ 位小数。\n\n### 第二步：使用提取的已知信息进行验证\n\n根据所需标准对问题进行评估。\n\n-   **科学依据**：该问题使用了已建立的 Kyte–Doolittle 亲水性标度。稳定性代理是一种简化的最近邻相互作用模型，这是计算生物学中用于说明基于序列的性质的常用教学工具。虽然不是一个完整的物理模型，但它基于合理的科学概念，并非伪科学。\n-   **适定性**：所有术语和函数 ($h, E, F$) 都经过了精确的数学定义。说明为计算任何给定序列 $s$ 和阈值 $\\tau$ 的脆性提供了清晰、确定性的过程。存在唯一的解，并且可以通过算法计算。\n-   **客观性**：问题以形式化、客观的语言陈述，没有主观或基于意见的断言。\n\n该问题不存在任何指定的缺陷。在一个简化模型的背景下，它在科学上是合理的，在数学上是可形式化的，是完备的，并且是算法可解的。\n\n### 第三步：结论与行动\n\n问题是**有效的**。将开发一个解决方案。\n\n### 解决方案推导\n\n任务是为一组给定的序列 $s$ 和去稳定化阈值 $\\tau$ 计算脆性 $F(s,\\tau)$。脆性是去稳定化单点突变所占的比例。如果稳定性能量的变化满足特定不等式，则在位置 $i$ 从残基 $s_i$ 到 $x$ 的突变是去稳定化的。\n\n一种朴素的方法是生成所有 $19\\,L$ 个突变序列，为每个序列计算稳定性代理 $E(s')$，并将其与原始序列的稳定性代理 $E(s)$ 进行比较。对于长度为 $L$ 的序列，计算 $E(s)$ 需要 $O(L)$ 次操作。这将导致总复杂度为 $O(L) \\times 19L = O(L^2)$，效率低下。\n\n一种计算效率更高的方法是直接计算稳定性的变化量 $\\Delta E = E(s^{(i\\to x)}) - E(s)$。定义 $E(s)$ 的求和仅涉及最近邻项。当一个残基 $s_i$ 突变为 $x$ 时，只有涉及 $s_i$ 的项会受到影响。设 $h_{old} = h(s_i)$ 和 $h_{new} = h(x)$。\n\n变化量 $\\Delta E$ 取决于突变的位置 $i$（在此推导中使用基于 $1$ 的索引）：\n\n1.  **内部位置 ($1 < i < L$)：** 涉及 $s_i$ 的原始项是 $h(s_{i-1})h(s_i) + h(s_i)h(s_{i+1})$。新项是 $h(s_{i-1})h(x) + h(x)h(s_{i+1})$。\n    变化量为：\n    $$\n    \\Delta E = \\left( h(s_{i-1})h_{new} + h_{new}h(s_{i+1}) \\right) - \\left( h(s_{i-1})h_{old} + h_{old}h(s_{i+1}) \\right) = (h_{new} - h_{old}) \\left( h(s_{i-1}) + h(s_{i+1}) \\right).\n    $$\n\n2.  **第一个位置 ($i=1, L > 1$)：** 唯一受影响的项是 $h(s_1)h(s_2)$。\n    $$\n    \\Delta E = h_{new}h(s_2) - h_{old}h(s_2) = (h_{new} - h_{old})h(s_2).\n    $$\n\n3.  **最后一个位置 ($i=L, L > 1$)：** 唯一受影响的项是 $h(s_{L-1})h(s_L)$。\n    $$\n    \\Delta E = h(s_{L-1})h_{new} - h(s_{L-1})h_{old} = (h_{new} - h_{old})h(s_{L-1}).\n    $$\n\n4.  **长度为一的序列 ($L=1$)：** 根据定义，对于任何长度为 $1$ 的序列，$E(s)=0$。任何单点突变体也是长度为 $1$ 的序列，因此其稳定性也为 $0$。因此，对于所有突变，$\\Delta E = 0$。\n\n去稳定化突变的条件是 $E(s^{(i\\to x)}) < E(s) - \\tau$。这可以使用 $\\Delta E$ 重写为 $E(s) + \\Delta E < E(s) - \\tau$，简化为：\n$$\n\\Delta E < -\\tau.\n$$\n这使我们能够在 $O(1)$ 时间内检查每次突变的条件，如果需要，可以在初始遍历中预先计算邻居的亲水性值。总体算法复杂度变为 $O(L)$。\n\n### 算法\n\n对于每个测试用例 $(s, \\tau)$：\n1.  初始化去稳定化突变计数器，$D \\leftarrow 0$。\n2.  设 $L$ 为序列 $s$ 的长度。\n3.  如果 $L=1$，根据问题定义，任何单残基序列的 $E(s)=0$。那么 $\\Delta E = 0$。去稳定化的条件是 $0 < -\\tau$。由于 $\\tau \\ge 0$，这个条件永远不会成立。因此，$D=0$ 且 $F(s, \\tau)=0$。\n4.  如果 $L > 1$，则遍历从 $0$ 到 $L-1$ 的每个位置 $i$（使用基于 $0$ 的索引）：\n    a. 设 $s_i$ 是位置 $i$ 的原始氨基酸。\n    b. 确定其邻居的亲水性总和，`context_h`：\n       - 如果 $i=0$：`context_h` = $h(s_1)$。\n       - 如果 $i=L-1$：`context_h` = $h(s_{L-2})$。\n       - 如果 $0 < i < L-1$：`context_h` = $h(s_{i-1}) + h(s_{i+1})$。\n    c. 设 $h_{old} = h(s_i)$。\n    d. 遍历字母表 $\\mathcal{A}$ 中的每个氨基酸 $x$：\n       i. 如果 $x$ 与 $s_i$ 相同，则继续下一个氨基酸。\n       ii. 设 $h_{new} = h(x)$。\n       iii. 计算 $\\Delta E = (h_{new} - h_{old}) \\times \\text{context\\_h}$。\n       iv. 如果 $\\Delta E < -\\tau$，则增加计数器 $D$。\n5.  在遍历所有位置和所有可能的替换后，计算脆性：$F(s, \\tau) = D / (19 \\times L)$。处理 $L=0$ 的情况以避免除以零，尽管测试用例中没有这种情况。\n6.  结果必须四舍五入到 $6$ 位小数。\n\n将实施此优化算法来解决提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the protein primary sequence fragility problem.\n    \"\"\"\n    # Define the Kyte-Doolittle hydropathy index values.\n    HYDROPATHY_MAP = {\n        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,\n        'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,\n        'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,\n        'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2\n    }\n    AMINO_ACIDS = sorted(HYDROPATHY_MAP.keys())\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MKTIIALSYIFCLVFAD\", 0.25),\n        (\"G\", 0.0),\n        (\"VVVV\", 0.0),\n        (\"DVDVDV\", 0.0),\n        (\"ACDEFGHIKLMNPQRSTVWY\", 100.0)\n    ]\n\n    results = []\n\n    for s, tau in test_cases:\n        L = len(s)\n        \n        # Per problem definition, for L=1, fragility is 0 as Delta E is always 0.\n        # Condition 0 < -tau is false for tau >= 0.\n        if L <= 1:\n            results.append(0.0)\n            continue\n            \n        destabilizing_mutant_count = 0\n        total_possible_mutants = 19 * L\n\n        # Iterate through each position i in the sequence s\n        for i in range(L):\n            original_aa = s[i]\n            h_old = HYDROPATHY_MAP[original_aa]\n\n            # Calculate the hydropathy sum of the neighbors (context)\n            context_h = 0.0\n            if i == 0:  # First position\n                context_h = HYDROPATHY_MAP[s[i+1]]\n            elif i == L - 1:  # Last position\n                context_h = HYDROPATHY_MAP[s[i-1]]\n            else:  # Interior position\n                context_h = HYDROPATHY_MAP[s[i-1]] + HYDROPATHY_MAP[s[i+1]]\n\n            # Iterate through all possible amino acid substitutions\n            for new_aa in AMINO_ACIDS:\n                if new_aa == original_aa:\n                    continue\n                \n                h_new = HYDROPATHY_MAP[new_aa]\n                \n                # Calculate the change in stability energy\n                delta_E = (h_new - h_old) * context_h\n                \n                # Check if the mutation is destabilizing\n                if delta_E < -tau:\n                    destabilizing_mutant_count += 1\n        \n        fragility = destabilizing_mutant_count / total_possible_mutants\n        results.append(round(fragility, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2412732"}, {"introduction": "根据中心法则，蛋白质序列由DNA序列翻译而来，但遗传密码的简并性意味着这种映射关系是“多对一”的。这个练习将带你逆流而上，从已知的蛋白质一级结构出发，结合不同物种中存在的“密码子使用偏好”这一统计规律，来推断其最有可能的原始DNA序列。通过解决这个问题，你不仅能加深对基因表达机制的理解，还能体验到如何运用概率模型来处理生物信息学中的溯源问题，这是分子进化和基因工程研究中的一项基本技能。[@problem_id:2412742]", "problem": "给定一个蛋白质一级结构，它是由肽键连接的氨基酸残基的有序序列。假设翻译遵循标准遗传密码，并且对于每种氨基酸，都存在一个由其同义密码子上的概率分布所描述的密码子使用偏好。在给定氨基酸序列的条件下，假设不同位置的密码子选择是条件独立的，那么一个脱氧核糖核酸（DNA）编码序列的概率被定义为在每个位置上选择的密码子概率的乘积。您的任务是，根据下文提供的密码子使用偏好表，为每个给定的蛋白质序列计算出最可能的祖先DNA编码序列及其对应的自然对数似然。\n\n形式化。设蛋白质序列长度为 $n$，氨基酸为 $a_1,a_2,\\dots,a_n$。对于每个氨基酸 $a_i$，令 $\\mathcal{C}(a_i)$ 表示其同义密码子集合，并令 $p(c\\mid a)$ 表示在给定氨基酸 $a$ 的条件下，密码子 $c\\in\\mathcal{C}(a)$ 的使用概率。一个与该蛋白质序列一致的DNA编码序列 $c_1c_2\\dots c_n$ 必须对所有的 $i$ 满足 $c_i\\in\\mathcal{C}(a_i)$。这样一个序列的概率为\n$$\nP(c_1c_2\\dots c_n\\mid a_1a_2\\dots a_n)=\\prod_{i=1}^{n} p(c_i\\mid a_i).\n$$\n最可能的DNA编码序列是上述乘积的任意一个最大化者。如果在任何位置出现平局（即对于一个给定的氨基酸，有多个密码子达到相同的最大概率），则通过在字母顺序 $A\\lt C\\lt G\\lt T$ 下选择字典序最小的密码子来打破平局。\n\n输出要求。对于每个蛋白质序列：\n- 计算最可能的DNA编码序列 $c_1c_2\\dots c_n$。\n- 计算其自然对数似然 $\\log P(c_1c_2\\dots c_n\\mid a_1a_2\\dots a_n)=\\sum_{i=1}^{n}\\log p(c_i\\mid a_i)$。\n- 使用四进制位置编码，通过映射 $A\\mapsto 0$、$C\\mapsto 1$、$G\\mapsto 2$、$T\\mapsto 3$，将DNA序列转换为单个非负整数。具体来说，对于一个长度为 $m$ 的DNA序列 $d_1d_2\\dots d_m$（这里 $m=3n$），通过 $d_j=A$ 时 $x_j=0$，$d_j=C$ 时 $x_j=1$，$d_j=G$ 时 $x_j=2$，$d_j=T$ 时 $x_j=3$ 来定义数字 $x_j\\in\\{0,1,2,3\\}$，并计算\n$$\nE(d_1d_2\\dots d_m)=\\sum_{j=1}^{m} x_j\\cdot 4^{m-j}.\n$$\n按照惯例，对于空序列（即 $n=0$ 时），取 $E(\\,\\cdot\\,)=0$ 且 $\\log P(\\,\\cdot\\,)=0$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来、不含空格的逗号分隔列表。对于每个测试用例，首先输出整数 $E$，然后输出四舍五入到6位小数的自然对数似然，因此整体格式为\n$$\n[\\;E_1,\\ell_1,E_2,\\ell_2,\\dots,E_k,\\ell_k\\;],\n$$\n其中 $\\ell_i$ 表示测试用例 $i$ 的四舍五入后的自然对数似然， $k$ 是测试用例的数量。\n\n使用以下标准遗传密码子集和密码子使用概率 $p(c\\mid a)$，在每种氨基酸内部，概率之和为 $1$：\n\n- 赖氨酸 ($K$): $\\mathrm{AAA}: 0.5$, $\\mathrm{AAG}: 0.5$。\n- 苯丙氨酸 ($F$): $\\mathrm{TTT}: 0.45$, $\\mathrm{TTC}: 0.55$。\n- 亮氨酸 ($L$): $\\mathrm{CTT}: 0.3$, $\\mathrm{CTC}: 0.1$, $\\mathrm{CTA}: 0.1$, $\\mathrm{CTG}: 0.3$, $\\mathrm{TTA}: 0.1$, $\\mathrm{TTG}: 0.1$。\n- 丝氨酸 ($S$): $\\mathrm{TCT}: 0.19$, $\\mathrm{TCC}: 0.17$, $\\mathrm{TCA}: 0.15$, $\\mathrm{TCG}: 0.12$, $\\mathrm{AGC}: 0.20$, $\\mathrm{AGT}: 0.17$。\n- 甘氨酸 ($G$): $\\mathrm{GGT}: 0.16$, $\\mathrm{GGC}: 0.34$, $\\mathrm{GGA}: 0.25$, $\\mathrm{GGG}: 0.25$。\n- 甲硫氨酸 ($M$): $\\mathrm{ATG}: 1.0$。\n- 色氨酸 ($W$): $\\mathrm{TGG}: 1.0$。\n\n测试集。请按此顺序将您的程序应用于以下蛋白质序列（单字母氨基酸代码）：\n- 用例 $1$：$\\text{\"MKW\"}$。\n- 用例 $2$：$\\text{\"LL\"}$。\n- 用例 $3$：空字符串 $\\text{\"\"}$。\n- 用例 $4$：$\\text{\"SGS\"}$。\n- 用例 $5$：$\\text{\"F\"}$。\n\n角度单位不适用。不涉及物理单位。最终输出必须遵循上述确切格式，自然对数似然值需四舍五-入到6位小数。", "solution": "该问题要求我们为给定的蛋白质一级结构确定最可能的祖先脱氧核糖核酸（DNA）编码序列，并计算该序列的自然对数似然。此任务需在一个密码子选择是条件独立的密码子使用偏好模型下执行。\n\n该问题定义明确，需要系统地应用概率论和组合优化原理。问题的核心在于最大化一个概率乘积。设蛋白质序列为 $S_p = a_1a_2\\dots a_n$，其中每个 $a_i$ 是一个氨基酸。相应的DNA编码序列为 $S_d = c_1c_2\\dots c_n$，其中每个密码子 $c_i$ 编码氨基酸 $a_i$。在给定蛋白质序列的条件下，此DNA序列的概率定义为：\n$$\nP(S_d \\mid S_p) = P(c_1c_2\\dots c_n \\mid a_1a_2\\dots a_n) = \\prod_{i=1}^{n} p(c_i \\mid a_i)\n$$\n其中 $p(c_i \\mid a_i)$ 是在必须编码氨基酸 $a_i$ 的条件下，观测到密码子 $c_i$ 的条件概率。\n\n我们的目标是找到使此概率最大化的DNA序列 $S_d^*$。由于自然对数函数 $\\log(x)$ 在 $x>0$ 时是单调递增的，最大化 $P(S_d \\mid S_p)$ 等价于最大化其自然对数，即对数似然 $\\ell = \\log P(S_d \\mid S_p)$：\n$$\n\\ell = \\log \\left( \\prod_{i=1}^{n} p(c_i \\mid a_i) \\right) = \\sum_{i=1}^{n} \\log p(c_i \\mid a_i)\n$$\n条件独立性的假设至关重要：为氨基酸 $a_i$ 选择密码子 $c_i$ 的决策不依赖于为任何其他 $j \\neq i$ 的氨基酸选择密码子 $c_j$。这使我们能够将全局优化问题分解为一组 $n$ 个独立的局部优化问题。为了最大化总和，我们必须独立地最大化每一项。对于从 $1$ 到 $n$ 的每个位置 $i$，我们选择使概率 $p(c_i \\mid a_i)$ 最大化的密码子 $c_i^*$：\n$$\nc_i^* = \\arg\\max_{c \\in \\mathcal{C}(a_i)} p(c \\mid a_i)\n$$\n其中 $\\mathcal{C}(a_i)$ 是氨基酸 $a_i$ 的同义密码子集合。\n\n问题陈述指定了一条平局打破规则：如果某个氨基酸的多个密码子共享相同的最大概率，则必须选择在排序 $A < C < G < T$ 下字典序最小的那个。这确保了最可能的DNA序列 $S_d^* = c_1^*c_2^*\\dots c_n^*$ 是唯一的。\n\n算法如下：\n$1$. 对于输入蛋白质序列 $S_p$ 中的每个氨基酸 $a_i$：\n    a. 从提供的密码子使用表中，确定其同义密码子集合及对应的概率。\n    b. 确定最大概率 $p_{\\max, i} = \\max_{c \\in \\mathcal{C}(a_i)} p(c \\mid a_i)$。\n    c. 汇编所有达到此最大概率的候选密码子列表。\n    d. 将这些候选密码子按字典序排序，并选择第一个，即 $c_i^*$。\n$2$. 连接所选的密码子，形成最可能的DNA序列：$S_d^* = c_1^*c_2^*\\dots c_n^*$。\n$3$. 通过对每个位置找到的最大概率取对数并求和，来计算总自然对数似然：\n$$\n\\ell^* = \\sum_{i=1}^{n} \\log(p_{\\max, i})\n$$\n$4$. 将得到的长度为 $m=3n$ 的DNA序列 $S_d^*$ 转换为其四进制整数表示 $E$。通过映射 $A \\mapsto 0$、$C \\mapsto 1$、$G \\mapsto 2$、$T \\mapsto 3$，使用位置记数法公式计算数值 $E$：\n$$\nE = \\sum_{j=1}^{m} x_j \\cdot 4^{m-j}\n$$\n其中 $x_j$ 是与 $S_d^*$ 中第 $j$ 个核苷酸 $d_j$ 对应的整数值。这可以使用霍纳法则（Horner's method）高效计算：从 $E=0$ 开始，遍历 $S_d^*$ 的核苷酸，将 $E$ 更新为 $E \\leftarrow E \\cdot 4 + x_j$。\n$5$. 对于空蛋白质序列（$n=0$）的特殊情况，得到的DNA序列也为空。按照惯例，对数似然 $\\ell^*$ 和编码 $E$ 均为 $0$。\n\n此过程应用于每个测试用例，以生成所需的 $(E, \\ell^*)$ 对。例如，对于氨基酸亮氨酸（Leucine, L），具有最大概率（$0.3$）的密码子是 $CTT$ 和 $CTG$。在字典序上，$CTG < CTT$，因此选择 $CTG$。对于赖氨酸（Lysine, K），密码子 $AAA$ 和 $AAG$ 的概率均为 $0.5$。在字典序上，$AAA < AAG$，因此选择 $AAA$。这种系统性的方法保证了对任何给定的蛋白质序列都能得到一个正确且唯一的解。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the most likely ancestral DNA sequence and its log-likelihood for a set of protein sequences.\n    \"\"\"\n    codon_usage_table = {\n        'K': {'AAA': 0.5, 'AAG': 0.5},\n        'F': {'TTT': 0.45, 'TTC': 0.55},\n        'L': {'CTT': 0.3, 'CTC': 0.1, 'CTA': 0.1, 'CTG': 0.3, 'TTA': 0.1, 'TTG': 0.1},\n        'S': {'TCT': 0.19, 'TCC': 0.17, 'TCA': 0.15, 'TCG': 0.12, 'AGC': 0.20, 'AGT': 0.17},\n        'G': {'GGT': 0.16, 'GGC': 0.34, 'GGA': 0.25, 'GGG': 0.25},\n        'M': {'ATG': 1.0},\n        'W': {'TGG': 1.0}\n    }\n\n    base4_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    test_cases = [\n        \"MKW\",\n        \"LL\",\n        \"\",\n        \"SGS\",\n        \"F\"\n    ]\n\n    # Pre-process the table to find the best codon for each amino acid\n    best_codons = {}\n    for aa, codons in codon_usage_table.items():\n        if not codons:\n            continue\n        max_prob = -1.0\n        for prob in codons.values():\n            if prob > max_prob:\n                max_prob = prob\n        \n        candidate_codons = []\n        for codon, prob in codons.items():\n            if prob == max_prob:\n                candidate_codons.append(codon)\n        \n        # Tie-break by choosing the lexicographically smallest codon\n        best_codon = sorted(candidate_codons)[0]\n        best_codons[aa] = (best_codon, max_prob)\n\n    results = []\n    for protein_seq in test_cases:\n        if not protein_seq:\n            results.extend([0, 0.0])\n            continue\n\n        most_likely_dna_seq = \"\"\n        total_log_likelihood = 0.0\n\n        for aa in protein_seq:\n            codon, prob = best_codons[aa]\n            most_likely_dna_seq += codon\n            if prob > 0:\n                total_log_likelihood += np.log(prob)\n        \n        # Calculate base-4 encoding using Horner's method\n        encoded_val = 0\n        for nucleotide in most_likely_dna_seq:\n            encoded_val = encoded_val * 4 + base4_map[nucleotide]\n        \n        results.extend([encoded_val, total_log_likelihood])\n\n    # Format the final output string\n    output_parts = []\n    for i, res in enumerate(results):\n        if i % 2 == 1:  # Log-likelihood, format to 6 decimal places\n            output_parts.append(f\"{res:.6f}\")\n        else:  # Integer encoding\n            output_parts.append(str(res))\n    \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2412742"}]}