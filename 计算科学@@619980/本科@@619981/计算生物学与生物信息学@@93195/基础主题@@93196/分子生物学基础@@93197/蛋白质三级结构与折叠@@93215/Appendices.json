{"hands_on_practices": [{"introduction": "球状蛋白质的一个显著特征是其紧密堆积的疏水核心，这是疏水效应驱动折叠的直接结果。这个练习提供了一个亲手实践的机会，使用一个简化的模型来量化这种堆积密度，并将其与均匀球体堆积的理论最大值进行比较。通过这个计算，你将能更直观地理解蛋白质结构内部的原子排列是多么高效和紧凑。[@problem_id:2422553]", "problem": "一个球状蛋白的疏水核心可近似为一个半径为 $12~\\text{\\AA}$ 的球体。该核心包含以下埋藏的侧链，其范德华体积（在此模型中假定为可加和的）以立方埃（$\\text{\\AA}^3$）为单位给出：\n\n- 苯丙氨酸 (Phe)：$3$ 个残基，每个体积为 $189$\n- 亮氨酸 (Leu)：$6$ 个残基，每个体积为 $166$\n- 异亮氨酸 (Ile)：$3$ 个残基，每个体积为 $166$\n- 缬氨酸 (Val)：$5$ 个残基，每个体积为 $140$\n- 甲硫氨酸 (Met)：$2$ 个残基，每个体积为 $166$\n- 酪氨酸 (Tyr)：$1$ 个残基，体积为 $193$\n- 色氨酸 (Trp)：$1$ 个残基，体积为 $227$\n- 丙氨酸 (Ala)：$4$ 个残基，每个体积为 $88$\n- 苏氨酸 (Thr)：$2$ 个残基，每个体积为 $116$\n- 半胱氨酸 (Cys)：$2$ 个残基，每个体积为 $108$\n- 脯氨酸 (Pro)：$2$ 个残基，每个体积为 $112$\n\n在此简化模型下，核心的侧链堆积密度定义为埋藏的侧链所占核心体积的比例。均质球体的理论最大堆积密度（Kepler 密堆积）为 $0.74048$。\n\n计算该核心的侧链堆积密度与 $0.74048$ 的比值。将最终答案表示为一个无量纲的十进制数，并四舍五入到四位有效数字。最终答案中不要包含单位。", "solution": "问题陈述经过验证，被认为是科学上可靠、定义明确且客观的。它基于一个用于分析蛋白质堆积的结构生物信息学标准模型，尽管该模型是简化的。所有必要数据均已提供，且定义清晰明确。该问题是有效的，将提供一个解答。\n\n主要任务是计算所算出的侧链堆积密度 $\\rho_{\\text{packing}}$与均质球体理论最大堆积密度 $\\rho_{\\text{max}}$ 的比值。堆积密度定义为组成核心的侧链所占体积的比例。\n\n首先，我们必须计算所有埋藏侧链的总范德华体积，记为 $V_{\\text{sc}}$。这是每个单独侧链体积的总和。问题提供了每种残基类型的数量和体积。\n\n总和计算如下：\n$V_{\\text{sc}} = (3 \\times 189) + (6 \\times 166) + (3 \\times 166) + (5 \\times 140) + (2 \\times 166) + (1 \\times 193) + (1 \\times 227) + (4 \\times 88) + (2 \\times 116) + (2 \\times 108) + (2 \\times 112)~\\text{\\AA}^3$。\n\n对每一项进行乘法运算：\n$V_{\\text{Phe}} = 3 \\times 189 = 567~\\text{\\AA}^3$\n$V_{\\text{Leu}} = 6 \\times 166 = 996~\\text{\\AA}^3$\n$V_{\\text{Ile}} = 3 \\times 166 = 498~\\text{\\AA}^3$\n$V_{\\text{Val}} = 5 \\times 140 = 700~\\text{\\AA}^3$\n$V_{\\text{Met}} = 2 \\times 166 = 332~\\text{\\AA}^3$\n$V_{\\text{Tyr}} = 1 \\times 193 = 193~\\text{\\AA}^3$\n$V_{\\text{Trp}} = 1 \\times 227 = 227~\\text{\\AA}^3$\n$V_{\\text{Ala}} = 4 \\times 88 = 352~\\text{\\AA}^3$\n$V_{\\text{Thr}} = 2 \\times 116 = 232~\\text{\\AA}^3$\n$V_{\\text{Cys}} = 2 \\times 108 = 216~\\text{\\AA}^3$\n$V_{\\text{Pro}} = 2 \\times 112 = 224~\\text{\\AA}^3$\n\n将这些值相加，得到总侧链体积：\n$$V_{\\text{sc}} = 567 + 996 + 498 + 700 + 332 + 193 + 227 + 352 + 232 + 216 + 224 = 4537~\\text{\\AA}^3$$\n\n接下来，我们计算疏水核心的体积 $V_{\\text{core}}$，它被近似为一个半径为 $R = 12~\\text{\\AA}$ 的球体。球体的体积由以下公式给出：\n$$V_{\\text{core}} = \\frac{4}{3}\\pi R^3$$\n代入给定的半径：\n$$V_{\\text{core}} = \\frac{4}{3}\\pi (12~\\text{\\AA})^3 = \\frac{4}{3}\\pi (1728)~\\text{\\AA}^3 = 2304\\pi~\\text{\\AA}^3$$\n\n侧链堆积密度 $\\rho_{\\text{packing}}$ 是总侧链体积与核心体积的比值：\n$$\\rho_{\\text{packing}} = \\frac{V_{\\text{sc}}}{V_{\\text{core}}} = \\frac{4537}{2304\\pi}$$\n\n问题要求计算此堆积密度与理论最大堆积密度 $\\rho_{\\text{max}} = 0.74048$ 的比值。设这个要求的比值为 $\\mathcal{R}$。\n$$\\mathcal{R} = \\frac{\\rho_{\\text{packing}}}{\\rho_{\\text{max}}} = \\frac{\\frac{4537}{2304\\pi}}{0.74048} = \\frac{4537}{2304 \\times 0.74048 \\times \\pi}$$\n\n现在，我们进行数值计算：\n$$V_{\\text{core}} = 2304\\pi \\approx 2304 \\times 3.14159265 \\approx 7238.229~\\text{\\AA}^3$$\n$$\\rho_{\\text{packing}} = \\frac{4537}{7238.229} \\approx 0.626815$$\n$$\\mathcal{R} = \\frac{0.626815}{0.74048} \\approx 0.846490$$\n\n问题要求答案四舍五入到四位有效数字。第五位有效数字是 $9$，大于或等于 $5$，所以我们将第四位数字向上取整。\n$$\\mathcal{R} \\approx 0.8465$$\n这个无量纲值表示蛋白质核心相对于均质球体理想密堆积的堆积效率。", "answer": "$$\\boxed{0.8465}$$", "id": "2422553"}, {"introduction": "从分析蛋白质的宏观性质过渡到局部，我们知道特定的氨基酸序列决定了最终的折叠构象。这个练习是一个思想实验，旨在分析一个脯氨酸到甘氨酸的单点突变如何影响一个β-转角，从而迫使我们深入探讨构象熵和主链灵活性等关键概念。通过推理这个突变的结构后果，你将能更好地理解单个残基的特性如何对局部乃至整体的蛋白质结构和稳定性产生深远影响。[@problem_id:2422509]", "problem": "一个$\\beta$-转角是由$4$个连续残基组成的局部基序，其中第$i$个残基的羰基氧与第$i+3$个残基的酰胺氢形成主链氢键，从而使肽链方向反转。考虑一个小的β-发夹结构，其转角是一个I型β-转角，且脯氨酸位于第$i+1$位。该脯氨酸之前的肽键处于反式构型，并且在第$i$和第$i+3$个残基之间观察到经典的$i \\rightarrow i+3$主链氢键。一个点突变将第$i+1$位的脯氨酸替换为甘氨酸，序列其他部分和溶剂条件均无变化。\n\n在折叠系综中，这个脯氨酸$\\rightarrow$甘氨酸的突变最可能的结构后果是下列哪一项？\n\nA. 由于第$i+1$位的主链构象熵增加，局部转角在热力学上变得不稳定，导致天然I型几何构型的占比下降，而由于第$i+3$个残基未改变，经典的$i \\rightarrow i+3$氢键仍然可能形成。\n\nB. 局部转角在热力学上变得稳定，因为甘氨酸偏好I型β-转角中第$i+1$位所需的正值$\\phi$主链二面角，从而相对于脯氨酸减少了张力。\n\nC. 该突变在第$i+1$位引入了一个新的主链氢键供体，加强了经典的$i \\rightarrow i+3$氢键，从而稳定了该转角。\n\nD. 该转角的稳定性和几何构型不受影响，因为β-转角的类型和稳定性仅取决于第$i+2$位残基的种类，而非第$i+1$位。\n\nE. 该转角转化为II型β-转角，因为甘氨酸与第$i+1$位所需的主链二面角最相容，使得II型几何构型比I型更有利。", "solution": "脯氨酸和甘氨酸在转角中的结构作用可以从主链构象偏好和氢键几何构型的第一性原理推断出来。\n\n定义与基准：\n- $\\beta$-转角涉及$4$个残基（从$i$到$i+3$），其特征是第$i$个残基的羰基与第$i+3$个残基的酰胺之间形成一个主链氢键。\n- I型$\\beta$-转角在第$i+1$和$i+2$位具有特征性的主链二面角$(\\phi, \\psi)$，使肽链形成一个紧凑的反转，通常第$i+1$位的$\\phi$角约在$-60^\\circ$附近，而$\\psi$角为负值。确切的数值并非必要；重要的是它们处于对大多数$\\phi,\\psi$受限的残基而言通常可及的区域。\n- 脯氨酸有一个环状侧链，将主链$\\phi$角限制在约$-60^\\circ$附近，从而降低了构象熵，并将局部主链预组织成与转角相容的构象。当脯氨酸占据一个位置时，它也缺少主链酰胺氢，因此不能在其自身位置上作为主链氢键的供体。\n- 甘氨酸除了氢原子外没有侧链，因此在拉曼钱德兰图上拥有最宽的允许区域，在未折叠态下具有最高的主链构象熵。将甘氨酸限制在一组特定的$(\\phi,\\psi)$角会比大多数残基产生更大的熵罚，这在热力学上不利于形成紧凑、明确的局部结构，除非有强烈的相互作用进行补偿。甘氨酸经常出现在其他残基不允许的主链区域位置上，例如在II型转角中第$i+2$位的正值$\\phi$角。\n\n现在考虑在一个I型$\\beta$-转角中，第$i+1$位发生脯氨酸$\\rightarrow$甘氨酸的突变，其前方的肽键为反式，并且存在一个经典的$i \\rightarrow i+3$氢键：\n\n- 热力学：用甘氨酸替换脯氨酸消除了预组织转角的构象限制。第$i+1$位在未折叠态下的构象熵增加（有更多可用状态），这增加了折叠时将主链固定成I型转角几何构型的熵代价。除非有更强的焓相互作用进行补偿，否则这种变化会降低折叠系综中精确I型几何构型的占比。因此，局部转角很可能在热力学上变得不稳定。\n- 氢键：经典的$i \\rightarrow i+3$氢键涉及第$i+3$个残基的供体和第$i$个残基的受体。改变第$i+1$个残基并不会移除第$i+3$位的供体；因此，原则上，如果转角几何构型得以形成，该氢键仍然可以形成。\n- 转角类型特异性：II型$\\beta$-转角通常需要在第$i+2$位有甘氨酸，因为该位置需要一个正值的$\\phi$角，而这对大多数残基是不允许的。第$i+1$位的甘氨酸并不特异性地促成II型几何构型。因此，在第$i+1$位发生脯氨酸$\\rightarrow$甘氨酸的突变本质上并不偏好向II型转角的转化。\n- 位置依赖性：在转角形成中，第$i+1$位残基的种类很重要，而不仅仅是第$i+2$位的种类；由于其受限的$\\phi$角，第$i+1$位的脯氨酸是I/II型转角的一个已知促进因素。\n\n逐项分析：\n\nA. 该选项指出，用甘氨酸替换脯氨酸后，由于第$i+1$位构象熵增加，转角变得不稳定，导致天然I型转角构型的占比减少，但因为第$i+3$个残基未变，经典的$i \\rightarrow i+3$氢键仍可能形成。这直接源于对甘氨酸与脯氨酸的熵的考量，以及氢键供体位于第$i+3$位这一事实。结论：正确。\n\nB. 该选项声称会稳定，因为甘氨酸在I型转角中偏好第$i+1$位的正值$\\phi$角。I型转角在第$i+1$位并不需要正值的$\\phi$角；它们通常具有接近$-60^\\circ$的负值$\\phi$角，这是脯氨酸自然采用的构象。甘氨酸本质上并不能稳定这种构象；其更大的柔性增加了有序化的熵代价。结论：错误。\n\nC. 该选项暗示在第$i+1$位增加一个酰胺氢会产生或加强经典的$i \\rightarrow i+3$氢键。经典的氢键供体是第$i+3$个残基的酰胺，而不是第$i+1$位。虽然第$i+1$位的甘氨酸确实拥有一个主链NH基团（与脯氨酸不同），但该NH并非定义该转角的氢键中的供体。因此，对于经典的稳定相互作用而言，这一推理是错误的。结论：错误。\n\nD. 该选项断言转角的稳定性和几何构型仅取决于第$i+2$位的残基。第$i+1$和$i+2$位都强烈影响转角的类型和稳定性；第$i+1$位的脯氨酸是一个众所周知的转角促进因素。因此，忽略第$i+1$位的作用是错误的。结论：错误。\n\nE. 该选项预测会转化为II型转角，因为现在第$i+1$位是甘氨酸。甘氨酸在II型转角中的特殊作用是在第$i+2$位（以容纳一个正值的$\\phi$角），而不是第$i+1$位。在第$i+1$位的甘氨酸不会特异性地驱动II型几何构型的形成。结论：错误。\n\n因此，最可能的结构后果在选项A中给出。", "answer": "$$\\boxed{A}$$", "id": "2422509"}, {"introduction": "现在，让我们从分析静态结构转向模拟动态的折叠过程。HP（疏水-极性）晶格模型是理解蛋白质折叠原理的基础计算工具，它将复杂的物理化学过程简化为几个核心规则。这个编程练习将指导你从头开始实现一个折叠模拟，通过枢轴移动探索构象空间，并使用蒙特卡洛算法来寻找低能态，从而在实践中体验驱动蛋白质形成其特定三维结构的基本力量。[@problem_id:2422555]", "problem": "您需要实现一个完整的、可运行的程序，该程序在二维方格晶格上对蛋白质折叠进行建模。该模型基于疏水-极性（HP）模型，并对给定氨基酸序列的同一初始构象评估两种折叠策略：一种是确定性的手动枢轴移动序列，另一种是定义为离散时间马尔可夫链的随机动力学。所有计算必须基于 HP 晶格模型的第一性原理，并且所有数学符号、变量、运算符和数字都必须使用 LaTeX 书写。\n\n一个长度为 $N$、残基索引为 $0,1,\\dots,N-1$ 的蛋白质由一个基于字母表 $\\{\\mathrm{H},\\mathrm{P}\\}$ 的序列 $S$ 表示，其中 $\\mathrm{H}$ 表示疏水，$\\mathrm{P}$ 表示极性。$S$ 的一个构象是将索引映射到坐标 $\\mathbf{r}_i \\in \\mathbb{Z}^2$ 的过程，使得对于所有 $i \\in \\{0,\\dots,N-2\\}$，连续残基之间的曼哈顿距离为1，即 $\\|\\mathbf{r}_{i+1}-\\mathbf{r}_i\\|_1=1$，并且对于所有 $i \\neq j$，$\\mathbf{r}_i \\neq \\mathbf{r}_j$（自回避行走）。对于所有测试用例，初始构象是沿 $x$ 轴的直线：\n$$\n\\mathbf{r}_i^{(0)} = (i,0) \\quad \\text{for } i \\in \\{0,1,\\dots,N-1\\}.\n$$\n\n对于序列 $S$，一个构象 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 的 HP 能量 $E$ 定义为\n$$\nE = -\\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ |i-j| > 1}} \\left[ S_i=\\mathrm{H} \\wedge S_j=\\mathrm{H} \\wedge \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = 1 \\right],\n$$\n其中 $[\\cdot]$ 是指示函数，当条件为真时其值为 $1$，否则为 $0$。每一个非连续的疏水-疏水接触对 $E$ 的贡献为 $-1$。能量是无量纲的。\n\n一个基本的枢轴移动由一个索引 $k \\in \\{1,2,\\dots,N-2\\}$ 和一个旋转角 $a \\in \\{+90,-90,180\\}$（角度单位为度）参数化。该移动通过围绕固定的枢轴位置 $\\mathbf{r}_k$，将后缀坐标 $\\{\\mathbf{r}_{k+1},\\dots,\\mathbf{r}_{N-1}\\}$ 在平面内旋转指定的角度来执行。如果结果构象违反了自回避性，则该移动无效且不产生任何效果（构象保持不变）。否则，该移动有效并更新构象。所有旋转必须是精确的晶格旋转：\n- 对于 $a=+90$，应用逆时针旋转矩阵 $\\begin{pmatrix}0 & -1 \\\\ 1 & 0\\end{pmatrix}$。\n- 对于 $a=-90$，应用顺时针旋转矩阵 $\\begin{pmatrix}0 & 1 \\\\ -1 & 0\\end{pmatrix}$。\n- 对于 $a=180$，应用旋转矩阵 $\\begin{pmatrix}-1 & 0 \\\\ 0 & -1\\end{pmatrix}$。\n\n对于每个测试用例，必须评估两种折叠策略：\n\n1. 手动引导：给定一个枢轴移动的有序列表 $\\{(k_m,a_m)\\}_{m=1}^M$，其中每个 $k_m \\in \\{1,\\dots,N-2\\}$ 且 $a_m \\in \\{+90,-90,180\\}$（角度单位为度），将它们按顺序应用于初始构象。任何无效的移动都会使该步骤的构象保持不变。在尝试了所有移动之后，计算最终构象的能量 $E_{\\mathrm{manual}}$。\n\n2. 自动随机动力学：从初始构象开始，考虑一个离散时间马尔可夫链，其在每一步 $t=1,2,\\dots,T_{\\max}$ 的转移规则如下：\n   - 从 $\\{1,2,\\dots,N-2\\}$ 中均匀抽取 $k$，从 $\\{+90,-90,180\\}$（角度单位为度）中均匀抽取 $a$。提出相应的枢轴移动。\n   - 如果提议的移动无效，则在步骤 $t$ 构象保持不变。\n   - 如果移动有效，计算 $\\Delta E = E_{\\text{proposed}} - E_{\\text{current}}$，并以概率 $p_{\\text{acc}} = \\min\\{1, \\exp(-\\Delta E / T)\\}$ 接受该移动，其中 $T$ 是温度，玻尔兹曼常数设为1，因此 $T$ 是无量纲的。如果接受，则将构象更新为提议的构象；否则，保留当前构象。\n   - 令 $E_{\\mathrm{best}}$ 表示截至并包括步骤 $t$（包括步骤 $0$ 的初始构象）所观察到的最低能量。\n该随机过程必须使用指定的整数伪随机种子进行初始化，以确保可再现性。此策略的输出是在 $T_{\\max}$ 步之后得到的 $E_{\\mathrm{auto}} = E_{\\mathrm{best}}$。\n\n您的程序必须精确实现上述定义，并为以下测试套件生成结果。在所有情况下，角度单位均为度，能量是无量纲整数，索引是基于零的，其中枢轴索引被限制在 $k \\in \\{1,2,\\dots,N-2\\}$。\n\n测试套件：\n- 案例 A:\n  - 序列 $S = \\text{\"HHHH\"}$，长度 $N=4$。\n  - 手动移动: $\\big[(1,+90),(2,+90)\\big]$。\n  - 温度 $T = 1$。\n  - 随机步骤 $T_{\\max} = 0$。\n  - 种子 $= 1$。\n- 案例 B:\n  - 序列 $S = \\text{\"HPHPHPHP\"}$，长度 $N=8$。\n  - 手动移动: 空列表 $\\big[\\ \\big]$。\n  - 温度 $T = 1$。\n  - 随机步骤 $T_{\\max} = 0$。\n  - 种子 $= 2$。\n- 案例 C:\n  - 序列 $S = \\text{\"HHHHHH\"}$，长度 $N=6$。\n  - 手动移动: $\\big[(1,+90),(2,+90),(4,-90)\\big]$。\n  - 温度 $T = 1$。\n  - 随机步骤 $T_{\\max} = 0$。\n  - 种子 $= 3$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表被方括号括起。列表中的每个元素对应一个测试用例，并且本身是一个包含两个元素的列表 $[E_{\\mathrm{manual}}, E_{\\mathrm{auto}}]$。例如，一个包含三个测试用例的输出应如下所示\n$$\n\\big[ [e_1^{\\mathrm{man}}, e_1^{\\mathrm{auto}}], [e_2^{\\mathrm{man}}, e_2^{\\mathrm{auto}}], [e_3^{\\mathrm{man}}, e_3^{\\mathrm{auto}}] \\big].\n$$", "solution": "该问题陈述是有效的。它在科学上基于公认的疏水-极性（HP）晶格模型，这是简化蛋白质折叠研究的基石。问题是适定的，提供了所有必要的定义、初始条件和参数以推导出唯一的解。其语言客观且数学上精确。我现在将着手提供一个完整的解决方案。\n\n该解决方案要求在二维方格晶格上实现一个由 HP 模型控制的蛋白质折叠模拟。一个蛋白质被抽象为一个长度为 $N$、基于字母表 $\\{\\mathrm{H}, \\mathrm{P}\\}$ 的序列 $S$，分别代表疏水和极性残基。该链的构象是在整数网格 $\\mathbb{Z}^2$ 上的一个自回避行走，由一系列坐标 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 表示，其中 $\\mathbf{r}_i = (x_i, y_i)$。对于所有测试用例，该链始于一个沿 x 轴完全伸展的线性构象，即 $\\mathbf{r}_i^{(0)} = (i,0)$。\n\nHP 模型的核心在于其能量函数，该函数假设疏水效应是蛋白质折叠的主导力。给定构象的能量 $E$ 是通过计算非相邻疏水残基之间的拓扑接触数量来计算的。如果两个这样的残基占据了相邻的晶格位点，则形成一个接触。能量由以下公式给出：\n$$\nE = -\\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ |i-j| > 1}} \\left[ S_i=\\mathrm{H} \\wedge S_j=\\mathrm{H} \\wedge \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = 1 \\right]\n$$\n其中 $[\\cdot]$ 是艾佛森括号。每一个这样的 H-H 接触对总能量的贡献为 $-1$，因此能量更低（更负）的构象更稳定。为了实现这一点，我们首先识别出所有对应于 $\\mathrm{H}$ 残基的索引。然后，我们遍历所有这些索引对 $(i, j)$，其中 $j > i+1$，并计算曼哈顿距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = |x_i - x_j| + |y_i - y_j|$。如果该距离为 $1$，我们就将能量计数器减一。初始线性构象的能量为 $E=0$，因为没有非相邻的残基发生接触。\n\n构象变化通过枢轴移动来建模。一个枢轴移动由一个索引 $k \\in \\{1, 2, \\dots, N-2\\}$ 和一个旋转角 $a \\in \\{+90, -90, 180\\}$ 度定义。位于 $\\mathbf{r}_k$ 的残基充当枢轴，从残基 $k+1$ 到 $N-1$ 的子链围绕它进行刚性旋转。前缀的坐标 $\\{\\mathbf{r}_0, \\dots, \\mathbf{r}_k\\}$ 保持固定。对于后缀中的每个点 $\\mathbf{r}_i$ ($i > k$)，其新位置 $\\mathbf{r}'_i$ 是通过围绕原点旋转向量 $\\mathbf{v}_i = \\mathbf{r}_i - \\mathbf{r}_k$ 并将其加回到枢轴坐标来找到的：$\\mathbf{r}'_i = \\mathbf{r}_k + R_a \\mathbf{v}_i$。平面上的旋转矩阵 $R_a$ 如下：\n$$\nR_{+90} = \\begin{pmatrix}0 & -1 \\\\ 1 & 0\\end{pmatrix}, \\quad R_{-90} = \\begin{pmatrix}0 & 1 \\\\ -1 & 0\\end{pmatrix}, \\quad R_{180} = \\begin{pmatrix}-1 & 0 \\\\ 0 & -1\\end{pmatrix}\n$$\n一个移动仅当其结果构象是自回避的，即所有坐标 $\\mathbf{r}'_i$ 都是唯一的时，才被认为是有效的。这通过检查坐标元组集合的大小是否为 $N$ 来验证。如果一个移动无效，构象不发生改变。\n\n评估两种折叠策略：\n\n1.  **手动引导：** 依次应用一个预定的枢轴移动序列。从初始线性构象开始，尝试每个移动 $(k_m, a_m)$。如果有效，则更新构象。如果无效，则丢弃该移动，并在未改变的构象上尝试下一个移动。处理完所有移动后，计算最终能量 $E_{\\mathrm{manual}}$。\n\n2.  **自动随机动力学：** 该策略采用 Metropolis-Hastings 蒙特卡洛模拟，一个离散时间马尔可夫链过程，来探索构象空间。从初始构象开始，模拟进行 $T_{\\max}$ 步。在每一步 $t$：\n    - 通过从 $\\{1, \\dots, N-2\\}$ 中均匀选择 $k$ 和从 $\\{+90, -90, 180\\}$ 中均匀选择 $a$ 来提议一个随机枢轴移动。\n    - 检查该移动的有效性。如果无效，则此步骤构象保持不变。\n    - 如果移动有效，则提出一个新的构象。计算能量变化 $\\Delta E = E_{\\text{proposed}} - E_{\\text{current}}$。\n    - 提议的移动以概率 $p_{\\text{acc}} = \\min\\{1, \\exp(-\\Delta E / T)\\}$ 被接受，其中 $T$ 是一个无量纲的温度参数。降低能量的移动（$\\Delta E < 0$）总是被接受。增加能量的移动以一个随能量增加而指数衰减的概率被接受，从而允许系统逃离局部极小值。如果一个移动被拒绝，构象保持不变。\n    - 在整个模拟过程中，追踪遇到的最低能量 $E_{\\mathrm{best}}$。该过程以起始构象的能量进行初始化。该策略的最终输出是 $T_{\\max}$ 步之后的 $E_{\\mathrm{auto}} = E_{\\mathrm{best}}$。对于给定的测试用例，$T_{\\max}=0$，意味着不执行任何随机步骤。因此，$E_{\\mathrm{auto}}$ 将仅仅是初始线性构象的能量。\n\n该实现将利用 `numpy` 数组来高效处理坐标向量和矩阵运算。整体逻辑被封装在一个主函数中，该函数处理每个测试用例，为手动和自动策略调用相应的函数，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_energy(coords, sequence):\n    \"\"\"\n    Calculates the HP energy of a given conformation.\n    Energy E = -1 for each non-adjacent H-H contact.\n    \"\"\"\n    n = len(sequence)\n    energy = 0\n    h_indices = [i for i, res in enumerate(sequence) if res == 'H']\n\n    if len(h_indices) < 2:\n        return 0\n\n    for i_idx in range(len(h_indices)):\n        for j_idx in range(i_idx + 1, len(h_indices)):\n            i = h_indices[i_idx]\n            j = h_indices[j_idx]\n\n            # Condition for non-adjacent residues\n            if abs(i - j) > 1:\n                # Manhattan distance\n                dist = np.sum(np.abs(coords[i] - coords[j]))\n                if dist == 1:\n                    energy -= 1\n    return energy\n\n\ndef get_proposed_coords(coords, n, k, angle):\n    \"\"\"\n    Generates a new conformation by applying a pivot move.\n    Returns the new coordinate array if the move is valid (self-avoiding),\n    otherwise returns None.\n    \"\"\"\n    # Pivot index k must be in {1, ..., N-2}\n    if not (1 <= k < n - 1):\n        return None\n\n    if angle == 90:\n        rot_matrix = np.array([[0, -1], [1, 0]], dtype=int)\n    elif angle == -90:\n        rot_matrix = np.array([[0, 1], [-1, 0]], dtype=int)\n    elif angle == 180:\n        rot_matrix = np.array([[-1, 0], [0, -1]], dtype=int)\n    else:\n        # Invalid angle\n        return None\n\n    new_coords = coords.copy()\n    pivot_coord = coords[k]\n    \n    # Suffix coordinates relative to the pivot\n    suffix_relative = coords[k+1:] - pivot_coord\n    \n    # Rotate the suffix vectors\n    rotated_suffix_relative = (rot_matrix @ suffix_relative.T).T\n    \n    # New absolute coordinates for the suffix\n    new_suffix_absolute = rotated_suffix_relative + pivot_coord\n    \n    new_coords[k+1:] = new_suffix_absolute\n    \n    # Check for self-avoidance. Using a set is efficient.\n    # The number of unique coordinates must be equal to the chain length.\n    if len(set(map(tuple, new_coords))) == n:\n        return new_coords\n    else:\n        return None\n\n\ndef solve():\n    \"\"\"\n    Main function to run the folding simulations for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"S\": \"HHHH\",\n            \"manual_moves\": [(1, 90), (2, 90)],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 1\n        },\n        {\n            \"S\": \"HPHPHPHP\",\n            \"manual_moves\": [],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 2\n        },\n        {\n            \"S\": \"HHHHHH\",\n            \"manual_moves\": [(1, 90), (2, 90), (4, -90)],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 3\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        sequence = case[\"S\"]\n        manual_moves = case[\"manual_moves\"]\n        T = case[\"T\"]\n        T_max = case[\"T_max\"]\n        seed = case[\"seed\"]\n\n        n = len(sequence)\n        \n        # --- Strategy 1: Manual Guidance ---\n        manual_coords = np.array([[i, 0] for i in range(n)], dtype=int)\n        \n        for k, angle in manual_moves:\n            proposed = get_proposed_coords(manual_coords, n, k, angle)\n            if proposed is not None:\n                manual_coords = proposed\n        \n        e_manual = calculate_energy(manual_coords, sequence)\n\n        # --- Strategy 2: Automated Stochastic Dynamics ---\n        rng = np.random.default_rng(seed)\n        \n        # Start with the initial linear conformation\n        current_coords = np.array([[i, 0] for i in range(n)], dtype=int)\n        current_energy = calculate_energy(current_coords, sequence)\n        best_energy = current_energy\n\n        # Perform T_max steps of Monte Carlo simulation\n        if T_max > 0 and n >= 3:\n            possible_k = list(range(1, n - 1))\n            possible_angles = [90, -90, 180]\n\n            for _ in range(T_max):\n                k_rand = rng.choice(possible_k)\n                angle_rand = rng.choice(possible_angles)\n                \n                proposed = get_proposed_coords(current_coords, n, k_rand, angle_rand)\n                \n                if proposed is not None:\n                    # Move is valid, evaluate for acceptance\n                    proposed_energy = calculate_energy(proposed, sequence)\n                    delta_E = proposed_energy - current_energy\n                    \n                    if delta_E < 0 or rng.random() < np.exp(-delta_E / T):\n                        # Accept the move\n                        current_coords = proposed\n                        current_energy = proposed_energy\n                \n                # If move is invalid, conformation and energy remain unchanged.\n                best_energy = min(best_energy, current_energy)\n\n        e_auto = best_energy\n        \n        results.append([e_manual, e_auto])\n\n    # Final print statement in the exact required format\n    output_str = \",\".join([f\"[{r[0]},{r[1]}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2422555"}]}