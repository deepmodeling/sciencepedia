{"hands_on_practices": [{"introduction": "中心法则描绘了从 $DNA$ 到蛋白质的单向信息流，但我们能否逆向而行？本练习将带你探索“反向翻译问题”：给定一个蛋白质序列，究竟有多少种不同的 $DNA$ 序列能够编码它？这个计算练习让你能够亲手量化遗传密码简并性所产生的巨大组合可能性，从而深刻体会到基因序列多样性的基础。[@problem_id:2800939]", "problem": "序列设计与注释中的一个核心挑战是从蛋白质到核酸的反向映射，通常称为反向翻译问题。仅使用分子生物学中心法则（脱氧核糖核酸（DNA）到核糖核酸（RNA）到蛋白质）的基本原则、核糖体阅读框的三联体、非重叠特性以及标准的遗传密码，完成以下任务：首先，精确定义反向翻译问题；其次，在仅考虑遗传密码简并性的情况下，计算能够编码一个指定肽链的、不同的编码链DNA序列集合的确切大小。\n\n需使用的假设：\n- 翻译过程以固定的阅读框从$5' \\to 3'$方向读取连续、非重叠的长度为$3$的密码子。\n- 标准遗传密码将$64$个密码子映射到$20$种氨基酸和$3$个终止信号；不发生密码子重编码、程序性移码或使用替代遗传密码。\n- 该肽链由单个无内含子的开放阅读框编码；计数中不包括末端终止密码子，并且如果肽链的第一个密码子是甲硫氨酸，则假定翻译起始于该密码子。\n- 不同位置的密码子选择是相互独立的；忽略密码子使用偏好、mRNA结构、调控基序及其他限制因素。\n- 标准遗传密码的简并性如下：甲硫氨酸（M）和色氨酸（W）的简并度为$1$；苯丙氨酸（F）、酪氨酸（Y）、组氨酸（H）、谷氨酰胺（Q）、天冬酰胺（N）、赖氨酸（K）、天冬氨酸（D）、谷氨酸（E）和半胱氨酸（C）的简并度为$2$；异亮氨酸（I）的简并度为$3$；丙氨酸（A）、甘氨酸（G）、脯氨酸（P）、苏氨酸（T）和缬氨酸（V）的简并度为$4$；亮氨酸（L）、精氨酸（R）和丝氨酸（S）的简并度为$6$。\n\n任务：\n1. 基于上述假设，用精确的术语定义反向翻译问题。\n2. 对于长度为$20$的肽链序列$\\text{MWSRLIYNQKDGTACFPVEH}$，计算在上述给定的标准遗传密码简并性下，能够编码它的不同$5' \\to 3'$编码链DNA序列（长度为$3 \\times 20$个核苷酸，不包括任何终止密码子）的确切数量。以精确整数形式提供最终答案，不要四舍五入。", "solution": "所述问题具有科学依据，提法得当，并包含足够的信息以得出唯一且有意义的解。因此，该问题被认为是有效的。解答按要求分为两部分呈现。\n\n第一部分：反向翻译问题的定义\n\n分子生物学中心法则描述了遗传信息从脱氧核糖核酸（DNA）流向核糖核酸（RNA），再到蛋白质的过程。翻译过程将信使RNA（mRNA）序列转换为肽链序列。这一转换由遗传密码所支配，遗传密码将密码子（核苷酸三联体）映射到氨基酸。\n\n设 $\\mathcal{A}$ 为包含$20$种标准氨基酸的集合，$\\mathcal{C}$ 为包含 $4^3 = 64$ 种可能密码子的集合。遗传密码是一个函数 $g: \\mathcal{C} \\to \\mathcal{A} \\cup \\{\\text{终止}\\}$，其中 $\\{\\text{终止}\\}$ 代表三个终止信号的集合。这个函数不是单射的；多个密码子可以映射到同一个氨基酸。这个特性被称为遗传密码的简并性。\n\n对于任意给定的氨基酸 $a \\in \\mathcal{A}$，我们可以将其编码密码子的集合定义为 $C_a = \\{c \\in \\mathcal{C} \\mid g(c) = a\\}$。这个集合的大小 $D(a) = |C_a|$，即为氨基酸 $a$ 的简并度。\n\n反向翻译问题是翻译的逆过程。它旨在确定能够编码一个给定肽链序列的所有可能的核酸序列的集合。\n\n形式上，给定一个长度为 $n$ 的肽链 $P$，表示为氨基酸序列 $P = p_1 p_2 \\dots p_n$，其中每个 $p_i \\in \\mathcal{A}$，反向翻译问题就是找到所有能够编码 $P$ 的编码链DNA序列（或其对应的mRNA序列）的集合 $S_{P}$。\n\n在每个氨基酸位置的密码子选择是相互独立的假设下，所有可能的mRNA序列的总集合是肽链中每个氨基酸的密码子集合的笛卡尔积：\n$$ S_{mRNA} = C_{p_1} \\times C_{p_2} \\times \\dots \\times C_{p_n} $$\n这类独特的mRNA序列的总数 $N_{mRNA}$ 是各个氨基酸简并度的乘积：\n$$ N_{mRNA} = |S_{mRNA}| = \\prod_{i=1}^{n} |C_{p_i}| = \\prod_{i=1}^{n} D(p_i) $$\n由于从DNA编码链到mRNA的转录是一一对应的映射（其中胸腺嘧啶T被尿嘧啶U替换），因此，编码肽链 $P$ 的不同编码链DNA序列的数量 $N_{DNA}$ 等于mRNA序列的数量。因此，$N_{DNA} = N_{mRNA}$。问题由此简化为基于标准遗传密码已知简并度的组合计算。\n\n第二部分：对肽链 $\\text{MWSRLIYNQKDGTACFPVEH}$ 的计算\n\n指定的肽链是 $P = \\text{MWSRLIYNQKDGTACFPVEH}$，长度为 $n=20$ 个氨基酸。问题要求计算能够编码该肽链的不同 $5' \\to 3'$ 编码链DNA序列的总数，不包括任何终止密码子。\n\n我们根据所提供的数据，确定序列中每个氨基酸的简并度：\n- $D(\\text{M, 甲硫氨酸}) = 1$\n- $D(\\text{W, 色氨酸}) = 1$\n- $D(\\text{S, 丝氨酸}) = 6$\n- $D(\\text{R, 精氨酸}) = 6$\n- $D(\\text{L, 亮氨酸}) = 6$\n- $D(\\text{I, 异亮氨酸}) = 3$\n- $D(\\text{Y, 酪氨酸}) = 2$\n- $D(\\text{N, 天冬酰胺}) = 2$\n- $D(\\text{Q, 谷氨酰胺}) = 2$\n- $D(\\text{K, 赖氨酸}) = 2$\n- $D(\\text{D, 天冬氨酸}) = 2$\n- $D(\\text{G, 甘氨酸}) = 4$\n- $D(\\text{T, 苏氨酸}) = 4$\n- $D(\\text{A, 丙氨酸}) = 4$\n- $D(\\text{C, 半胱氨酸}) = 2$\n- $D(\\text{F, 苯丙氨酸}) = 2$\n- $D(\\text{P, 脯氨酸}) = 4$\n- $D(\\text{V, 缬氨酸}) = 4$\n- $D(\\text{E, 谷氨酸}) = 2$\n- $D(\\text{H, 组氨酸}) = 2$\n\n序列总数 $N$ 是这些简并度值的乘积：\n$$ N = D(\\text{M}) \\times D(\\text{W}) \\times D(\\text{S}) \\times D(\\text{R}) \\times D(\\text{L}) \\times D(\\text{I}) \\times D(\\text{Y}) \\times D(\\text{N}) \\times D(\\text{Q}) \\times D(\\text{K}) \\times D(\\text{D}) \\times D(\\text{G}) \\times D(\\text{T}) \\times D(\\text{A}) \\times D(\\text{C}) \\times D(\\text{F}) \\times D(\\text{P}) \\times D(\\text{V}) \\times D(\\text{E}) \\times D(\\text{H}) $$\n为简化计算，我们按简并度值对各项进行分组。我们统计肽链中每种氨基酸出现的次数：\n- 简并度为$1$：M, W（出现$2$次）\n- 简并度为$2$：Y, N, Q, K, D, C, F, E, H（出现$9$次）\n- 简并度为$3$：I（出现$1$次）\n- 简并度为$4$：G, T, A, P, V（出现$5$次）\n- 简并度为$6$：S, R, L（出现$3$次）\n\n序列总数是这些简并度值乘以其出现频率的幂的乘积：\n$$ N = (1^2) \\times (2^9) \\times (3^1) \\times (4^5) \\times (6^3) $$\n我们可以使用质因数分解来简化这个表达式：\n$$ N = 1 \\times 2^9 \\times 3^1 \\times (2^2)^5 \\times (2 \\times 3)^3 $$\n$$ N = 2^9 \\times 3^1 \\times 2^{10} \\times 2^3 \\times 3^3 $$\n合并素数底数的幂：\n$$ N = 2^{(9+10+3)} \\times 3^{(1+3)} $$\n$$ N = 2^{22} \\times 3^4 $$\n现在，我们计算最终的整数值：\n$2^{10} = 1024$\n$2^{20} = (2^{10})^2 = 1024^2 = 1048576$\n$2^{22} = 2^{20} \\times 2^2 = 1048576 \\times 4 = 4194304$\n$3^4 = 81$\n最后，我们计算乘积：\n$$ N = 4194304 \\times 81 = 339738624 $$\n这就是能够编码指定肽链的不同编码链DNA序列的确切数量。", "answer": "$$\n\\boxed{339738624}\n$$", "id": "2800939"}, {"introduction": "遗传密码的简并性不仅提供了稳定性，还为信息的极致压缩提供了可能。在自然界中，一些基因组通过在同一段 $DNA$ 序列上、但在不同链或不同读码框中编码多个蛋白质，实现了惊人的信息密度。这个练习将挑战你解决一个迷人的生物信息学难题：设计一条 $DNA$ 单链，使其正向链编码一个蛋白质序列 $S_f$，而其反向互补链则编码另一个完全不同的蛋白质序列 $S_r$。通过解决这个双重编码问题，你将体验到如何创造性地利用简并性所提供的“选择自由度”，来满足看似苛刻的多重约束。[@problem_id:2384918]", "problem": "要求您编写一个完整、可运行的程序。给定两个等长的氨基酸序列，程序需要构建一个由字母表 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 构成的脱氧核糖核酸（DNA）序列。该DNA序列需满足以下条件：沿正向链 $5^{\\prime} \\rightarrow 3^{\\prime}$ 方向以密码子形式读取时，得到第一个蛋白质；而沿反向互补链 $5^{\\prime} \\rightarrow 3^{\\prime}$ 方向读取时，得到第二个不同的蛋白质。此构建过程必须利用遗传密码的简并性。如果在下述约束条件下，不存在这样的DNA序列，您的程序必须为该测试用例指出无解的情况。\n\n使用的基本原理和约束条件：\n- 分子生物学中心法则指出，信息从DNA流向核糖核酸（RNA），再到蛋白质。翻译过程将每个密码子（三个核苷酸的三联体）映射到一个氨基酸；标准核遗传密码是一个经过充分验证的从密码子到氨基酸的映射。\n- Watson–Crick 碱基配对定义了核苷酸的互补函数：$\\text{A}\\leftrightarrow \\text{T}$ 和 $\\text{C}\\leftrightarrow \\text{G}$。一个DNA字符串的反向互补序列是通过反转该字符串并用其互补核苷酸替换每个核苷酸得到的。\n- 令 $\\mathcal{A}$ 表示 $20$ 种标准氨基酸的集合，每种氨基酸由其标准的单字母代码表示（例如，$\\text{A}$ 代表 Alanine，$\\text{R}$ 代表 Arginine，…，$\\text{W}$ 代表 Tryptophan，$\\text{Y}$ 代表 Tyrosine，$\\text{M}$ 代表 Methionine 等）。终止密码子不属于 $\\mathcal{A}$，且不得出现在编码序列内部。\n- 令 $g : \\Sigma^3 \\rightarrow \\mathcal{A}\\cup\\{\\text{Stop}\\}$ 为从密码子到氨基酸（或终止密码子）的标准核遗传密码映射。请使用标准遗传密码（也称为 NCBI 翻译表 $1$），其中三个终止密码子为 $\\text{TAA}$、$\\text{TAG}$ 和 $\\text{TGA}$。\n- 令 $\\mathrm{RC} : \\Sigma^3 \\rightarrow \\Sigma^3$ 表示密码子上的反向互补算子，其定义为：反转密码子并根据 Watson–Crick 配对原则对每个核苷酸进行互补。\n\n问题形式化描述：\n- 给定两个等长（$L \\geq 1$）的氨基酸序列 $S_f$ 和 $S_r$，其中对于所有索引 $i \\in \\{0,1,\\dots,L-1\\}$，都有 $S_f[i] \\in \\mathcal{A}$ 和 $S_r[i] \\in \\mathcal{A}$。\n- 您必须确定一个 DNA 序列 $D \\in \\Sigma^{3L}$，该序列被划分为连续的密码子 $(c_0,c_1,\\dots,c_{L-1})$，其中 $c_i \\in \\Sigma^3$，并满足以下条件：\n  1. 对所有 $i \\in \\{0,1,\\dots,L-1\\}$，均有 $g(c_i) = S_f[i]$，以及\n  2. 对所有 $i \\in \\{0,1,\\dots,L-1\\}$，均有 $g(\\mathrm{RC}(c_i)) = S_r[L-1-i]$。\n- 如果存在多个有效的 $D$，您必须选择唯一的 $D$。该 $D$ 的获得方式是：对每个位置 $i$，选择字典序最小的密码子 $c_i$（其中 $\\Sigma$ 上的字典序定义为 $\\text{A} < \\text{C} < \\text{G} < \\text{T}$，并以标准方式扩展到 $\\Sigma^3$）。如果存在解，这种逐位选择将产生一个唯一的、确定性的 $D$。\n- 如果不存在这样的 $D$，您必须如下文所述，为该测试用例输出一个明确的空结果。\n- 根据定义，如果两个给定序列的长度不同，则不存在解。\n\n输出编码：\n- 对于每个测试用例，您必须将整个DNA序列 $D$ 输出为一个整数列表。其中核苷酸按映射 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$ 进行编码，并按顺序列出 $3L$ 个整数。如果不存在解，则为该测试用例输出空列表 $[\\ ]$。\n- 您的程序必须生成单行输出，其中包含所有测试用例的结果，聚合为一个列表的列表，不含任何空格，例如 $[[0,1,2],[\\ ],[2,2,3]]$。\n\n测试套件：\n您的程序必须硬编码并精确解决以下测试用例。每个测试用例都是一个序偶 $(S_f,S_r)$：\n- 情况 1 (顺利通过): $S_f=\\text{\"MALG\"}$, $S_r=\\text{\"TQGH\"}$。\n- 情况 2 (单密码子无解): $S_f=\\text{\"W\"}$, $S_r=\\text{\"A\"}$。\n- 情况 3 (单密码子有解): $S_f=\\text{\"M\"}$, $S_r=\\text{\"H\"}$。\n- 情况 4 (长度不匹配): $S_f=\\text{\"ACD\"}$, $S_r=\\text{\"GG\"}$。\n- 情况 5 (奇数长度有解): $S_f=\\text{\"AKR\"}$, $S_r=\\text{\"TFS\"}$。\n\n最终输出格式：\n- 您的程序必须打印单行文本，该行包含一个有 $5$ 个元素的列表，每个元素对应一个测试用例。每个元素要么是表示无解的空列表 $[\\ ]$，要么是代表DNA序列的 $3L$ 个整数列表（使用核苷酸到整数的编码 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$）。打印行中不得包含任何空格。", "solution": "我们从第一性原理出发，利用中心法则和 Watson–Crick 互补性，推导出一个构造性算法，并通过密码子映射和反向互补运算将其形式化。\n\n定义：\n- 令 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，$\\mathcal{A}$ 为 $20$ 种标准氨基酸的集合。\n- 令 $g:\\Sigma^3\\to \\mathcal{A}\\cup\\{\\text{Stop}\\}$ 为标准遗传密码映射，其终止密码子为 $\\text{TAA}$、$\\text{TAG}$、$\\text{TGA}$。\n- 令 $\\mathrm{comp}:\\Sigma\\to\\Sigma$ 为互补函数，$\\mathrm{comp}(\\text{A})=\\text{T}$，$\\mathrm{comp}(\\text{T})=\\text{A}$，$\\mathrm{comp}(\\text{C})=\\text{G}$，$\\mathrm{comp}(\\text{G})=\\text{C}$，通过逐字符应用可扩展至字符串。\n- 令 $\\mathrm{RC}:\\Sigma^k\\to \\Sigma^k$ 为反向互补运算，定义为 $\\mathrm{RC}(x_0x_1\\cdots x_{k-1})=\\mathrm{comp}(x_{k-1})\\cdots \\mathrm{comp}(x_1)\\mathrm{comp}(x_0)$。一个基本性质是，对于 $\\Sigma$ 上的任意字符串 $x,y$，有 $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$。\n\n我们给定两个等长（$L$）的氨基酸序列 $S_f$ 和 $S_r$（如果长度不同，则无解）。我们寻求一个 DNA 序列 $D=c_0c_1\\cdots c_{L-1}$，其中 $c_i\\in\\Sigma^3$，满足：\n- 对所有索引 $i\\in\\{0,\\dots,L-1\\}$，有 $g(c_i)=S_f[i]$。\n- 在读码框 $0$ 中读取反向互补链得到 $S_r$。根据性质 $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$，多个密码子连接体的反向互补等于每个密码子反向互补序列的逆序连接。因此，如果我们定义 $d_i=\\mathrm{RC}(c_i)$，那么反向互补链上位置 $j$（从 $5^{\\prime}$ 端起从 $0$ 开始计数）的密码子就是 $d_{L-1-j}$。为使反向链翻译为 $S_r$，必须对所有 $j$ 满足 $g(d_{L-1-j})=S_r[j]$，这等价于对所有 $i$ 满足 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。\n\n关键在于，这种分解显示了不同位置之间的独立性：每个正向密码子 $c_i$ 只影响反向链上对应的反转位置，并且当两条链都在读码框 $0$ 中读取时，不存在跨密码子的约束。因此，全局约束简化为 $L$ 个独立的局部约束。对于每个 $i\\in\\{0,\\dots,L-1\\}$，我们必须选择一个 $c_i\\in\\Sigma^3$ 同时满足配对条件 $g(c_i)=S_f[i]$ 和 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。如果任何位置 $i$ 找不到这样的 $c_i$，则无解；反之，由于 $\\mathrm{RC}$ 运算可如前述在连接操作上分配，每个位置的任何选择都将产生一个有效的全局解。\n\n为了利用简并性，我们计算任一氨基酸 $a\\in\\mathcal{A}$ 的同义密码子集合：\n$$\n\\mathrm{Codons}(a)=\\{c\\in\\Sigma^3 \\mid g(c)=a\\}.\n$$\n对每个位置 $i$，我们构建可行的正向密码子集合\n$$\n\\mathcal{C}_i=\\{c\\in \\mathrm{Codons}(S_f[i]) \\mid \\mathrm{RC}(c)\\in \\mathrm{Codons}(S_r[L-1-i])\\}.\n$$\n如果任何 $i$ 的 $\\mathcal{C}_i=\\varnothing$，则返回无解。否则，为保证确定性，我们应用字典序平局决胜规则。定义 $\\Sigma$ 上的序为 $\\text{A}<\\text{C}<\\text{G}<\\text{T}$，并通过标准字典序比较将其扩展到 $\\Sigma^3$。选择\n$$\nc_i=\\min\\nolimits_{\\text{lex}} \\mathcal{C}_i.\n$$\n连接这些 $c_i$ 即可得到唯一的确定性解 $D=c_0c_1\\cdots c_{L-1}$。\n\n正确性论证：\n- 可靠性（Soundness）：根据构造，对所有 $i$ 都有 $g(c_i)=S_f[i]$ 和 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。因此，$D$ 在正向链上翻译为 $S_f$，而 $\\mathrm{RC}(D)$ 在反向链上的读码框 $0$ 中翻译为 $S_r$。\n- 完备性（Completeness）：如果存在任何满足约束的解 $D^{\\star}$，那么对每个 $i$，其密码子 $c_i^{\\star}$ 必须属于 $\\mathcal{C}_i$。因此，对所有 $i$ 都有 $\\mathcal{C}_i\\neq\\varnothing$。我们的算法选择了某个 $c_i\\in\\mathcal{C}_i$，从而构建了一个有效的 $D$。确定性源于每个位置的字典序最小化选择。\n\n复杂度：\n- 预处理阶段在 $O(1)$ 时间内为所有 $a\\in\\mathcal{A}$ 构建 $\\mathrm{Codons}(a)$，使用常数大小的表。\n- 对于每个测试用例，对每个位置 $i$，我们最多扫描 $6$ 个密码子（对应高度简并的氨基酸，如 Leucine、Serine、Arginine）。因此，时间复杂度为 $O(L)$，带有一个小常数，空间复杂度为 $O(L)$ 用于存储结果。\n\n输出编码：\n- 通过映射 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$ 转换核苷酸。将 $D$ 编码为一个包含 $3L$ 个整数的有序列表。如果无解，输出空列表。将 $5$ 个必需测试用例的输出聚合到一个无空格的方括号列表中。\n\n应用于测试套件：\n- 对于 $S_f=\\text{\"MALG\"}$，$S_r=\\text{\"TQGH\"}$ 的情况 1 是可行的；通过逐位字典序选择可以获得一个有效的确定性解 $D$。\n- 对于 $S_f=\\text{\"W\"}$，$S_r=\\text{\"A\"}$ 的情况 2 是无解的，因为唯一的 Tryptophan 密码子 $\\text{TGG}$ 的反向互补序列是 $\\text{CCA}$ (Proline)，而它不编码 Alanine。\n- 对于 $S_f=\\text{\"M\"}$，$S_r=\\text{\"H\"}$ 的情况 3 是可行的，因为 $\\text{ATG}$ 的反向互补序列是 $\\text{CAT}$ (Histidine)。\n- 情况 4 长度不匹配，因此立即判定为无解。\n- 对于 $S_f=\\text{\"AKR\"}$，$S_r=\\text{\"TFS\"}$ 的情况 5 是可行的，通过适当的密码子选择可以找到解，该解由约束条件下的字典序最小化唯一确定。\n\n附带的程序实现了此算法，包含了标准遗传密码，构建了可行的密码子集合，强制执行了字典序规则，将结果转换为指定的整数编码，并以单行无空格的形式打印五个测试用例的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Mapping for nucleotide complements (Watson–Crick base pairing)\nCOMP = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n# Standard Genetic Code (NCBI Translation Table 1): DNA codons to amino acids (one-letter code)\nCODON_TO_AA = {\n    # Phenylalanine, Leucine\n    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n    # Serine, Proline, Threonine, Alanine\n    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n    # Tyrosine, Histidine, Glutamine, Asparagine, Lysine, Aspartic acid, Glutamic acid, Cysteine, Tryptophan\n    'TAT': 'Y', 'TAC': 'Y', 'TAA': 'Stop', 'TAG': 'Stop',\n    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n    'TGT': 'C', 'TGC': 'C', 'TGA': 'Stop', 'TGG': 'W',\n    # Leucine, Arginine, Isoleucine, Methionine, Valine, Serine, Arginine, Glycine\n    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n}\n\n# Build amino acid to codons mapping (excluding Stops)\nAA_TO_CODONS = {}\nfor codon, aa in CODON_TO_AA.items():\n    if aa == 'Stop':\n        continue\n    AA_TO_CODONS.setdefault(aa, []).append(codon)\n\n# Define nucleotide order for lexicographic sorting: A < C < G < T\nNUC_ORDER = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\ndef lex_key(codon: str):\n    return (NUC_ORDER[codon[0]], NUC_ORDER[codon[1]], NUC_ORDER[codon[2]])\n\n# Sort codon lists for deterministic lexicographic selection\nfor aa in AA_TO_CODONS:\n    AA_TO_CODONS[aa].sort(key=lex_key)\n\ndef reverse_complement(codon: str) -> str:\n    # Reverse the codon and complement each nucleotide\n    return ''.join(COMP[n] for n in reversed(codon))\n\ndef dna_to_ints(dna: str):\n    # Map nucleotides to integers A->0, C->1, G->2, T->3\n    mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    return [mapping[n] for n in dna]\n\ndef find_dual_encoding_dna(Sf: str, Sr: str):\n    # If lengths differ, impossible\n    if len(Sf) != len(Sr):\n        return []\n    L = len(Sf)\n    codons_forward = []\n\n    for i in range(L):\n        a_f = Sf[i]\n        a_r = Sr[L - 1 - i]\n        # Validate amino acids\n        if a_f not in AA_TO_CODONS or a_r not in AA_TO_CODONS:\n            return []\n        feasible = None\n        for codon in AA_TO_CODONS[a_f]:\n            rc = reverse_complement(codon)\n            # Ensure reverse complement codon encodes the required reverse amino acid\n            if rc in AA_TO_CODONS[a_r]:\n                feasible = codon\n                break  # lexicographically smallest due to prior sorting\n        if feasible is None:\n            return []\n        codons_forward.append(feasible)\n\n    dna = ''.join(codons_forward)\n    return dna_to_ints(dna)\n\ndef format_result_list(list_of_lists):\n    # Format as a single-line string with no spaces, nested lists\n    def format_one(lst):\n        return '[' + ','.join(str(x) for x in lst) + ']'\n    return '[' + ','.join(format_one(lst) for lst in list_of_lists) + ']'\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MALG\", \"TQGH\"),  # Case 1\n        (\"W\", \"A\"),        # Case 2\n        (\"M\", \"H\"),        # Case 3\n        (\"ACD\", \"GG\"),     # Case 4\n        (\"AKR\", \"TFS\"),    # Case 5\n    ]\n\n    results = []\n    for Sf, Sr in test_cases:\n        res = find_dual_encoding_dna(Sf, Sr)\n        results.append(res)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    print(format_result_list(results))\n\nsolve()\n```", "id": "2384867"}, {"introduction": "遗传密码的简并性不仅提供了稳定性，还为信息的极致压缩提供了可能。在自然界中，一些基因组通过在同一段 $DNA$ 序列上、但在不同链或不同读码框中编码多个蛋白质，实现了惊人的信息密度。这个练习将挑战你解决一个迷人的生物信息学难题：设计一条 $DNA$ 单链，使其正向链编码一个蛋白质序列 $S_f$，而其反向互补链则编码另一个完全不同的蛋白质序列 $S_r$。通过解决这个双重编码问题，你将体验到如何创造性地利用简并性所提供的“选择自由度”，来满足看似苛刻的多重约束。[@problem_id:2384918]", "problem": "要求您编写一个完整、可运行的程序。给定两个等长的氨基酸序列，程序需要构建一个由字母表 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 构成的脱氧核糖核酸（DNA）序列。该DNA序列需满足以下条件：沿正向链 $5^{\\prime} \\rightarrow 3^{\\prime}$ 方向以密码子形式读取时，得到第一个蛋白质；而沿反向互补链 $5^{\\prime} \\rightarrow 3^{\\prime}$ 方向读取时，得到第二个不同的蛋白质。此构建过程必须利用遗传密码的简并性。如果在下述约束条件下，不存在这样的DNA序列，您的程序必须为该测试用例指出无解的情况。\n\n使用的基本原理和约束条件：\n- 分子生物学中心法则指出，信息从DNA流向核糖核酸（RNA），再到蛋白质。翻译过程将每个密码子（三个核苷酸的三联体）映射到一个氨基酸；标准核遗传密码是一个经过充分验证的从密码子到氨基酸的映射。\n- Watson–Crick 碱基配对定义了核苷酸的互补函数：$\\text{A}\\leftrightarrow \\text{T}$ 和 $\\text{C}\\leftrightarrow \\text{G}$。一个DNA字符串的反向互补序列是通过反转该字符串并用其互补核苷酸替换每个核苷酸得到的。\n- 令 $\\mathcal{A}$ 表示 $20$ 种标准氨基酸的集合，每种氨基酸由其标准的单字母代码表示（例如，$\\text{A}$ 代表 Alanine，$\\text{R}$ 代表 Arginine，…，$\\text{W}$ 代表 Tryptophan，$\\text{Y}$ 代表 Tyrosine，$\\text{M}$ 代表 Methionine 等）。终止密码子不属于 $\\mathcal{A}$，且不得出现在编码序列内部。\n- 令 $g : \\Sigma^3 \\rightarrow \\mathcal{A}\\cup\\{\\text{Stop}\\}$ 为从密码子到氨基酸（或终止密码子）的标准核遗传密码映射。请使用标准遗传密码（也称为 NCBI 翻译表 $1$），其中三个终止密码子为 $\\text{TAA}$、$\\text{TAG}$ 和 $\\text{TGA}$。\n- 令 $\\mathrm{RC} : \\Sigma^3 \\rightarrow \\Sigma^3$ 表示密码子上的反向互补算子，其定义为：反转密码子并根据 Watson–Crick 配对原则对每个核苷酸进行互补。\n\n问题形式化描述：\n- 给定两个等长（$L \\geq 1$）的氨基酸序列 $S_f$ 和 $S_r$，其中对于所有索引 $i \\in \\{0,1,\\dots,L-1\\}$，都有 $S_f[i] \\in \\mathcal{A}$ 和 $S_r[i] \\in \\mathcal{A}$。\n- 您必须确定一个 DNA 序列 $D \\in \\Sigma^{3L}$，该序列被划分为连续的密码子 $(c_0,c_1,\\dots,c_{L-1})$，其中 $c_i \\in \\Sigma^3$，并满足以下条件：\n  1. 对所有 $i \\in \\{0,1,\\dots,L-1\\}$，均有 $g(c_i) = S_f[i]$，以及\n  2. 对所有 $i \\in \\{0,1,\\dots,L-1\\}$，均有 $g(\\mathrm{RC}(c_i)) = S_r[L-1-i]$。\n- 如果存在多个有效的 $D$，您必须选择唯一的 $D$。该 $D$ 的获得方式是：对每个位置 $i$，选择字典序最小的密码子 $c_i$（其中 $\\Sigma$ 上的字典序定义为 $\\text{A} < \\text{C} < \\text{G} < \\text{T}$，并以标准方式扩展到 $\\Sigma^3$）。如果存在解，这种逐位选择将产生一个唯一的、确定性的 $D$。\n- 如果不存在这样的 $D$，您必须如下文所述，为该测试用例输出一个明确的空结果。\n- 根据定义，如果两个给定序列的长度不同，则不存在解。\n\n输出编码：\n- 对于每个测试用例，您必须将整个DNA序列 $D$ 输出为一个整数列表。其中核苷酸按映射 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$ 进行编码，并按顺序列出 $3L$ 个整数。如果不存在解，则为该测试用例输出空列表 $[\\ ]$。\n- 您的程序必须生成单行输出，其中包含所有测试用例的结果，聚合为一个列表的列表，不含任何空格，例如 $[[0,1,2],[\\ ],[2,2,3]]$。\n\n测试套件：\n您的程序必须硬编码并精确解决以下测试用例。每个测试用例都是一个序偶 $(S_f,S_r)$：\n- 情况 1 (顺利通过): $S_f=\\text{\"MALG\"}$, $S_r=\\text{\"TQGH\"}$。\n- 情况 2 (单密码子无解): $S_f=\\text{\"W\"}$, $S_r=\\text{\"A\"}$。\n- 情况 3 (单密码子有解): $S_f=\\text{\"M\"}$, $S_r=\\text{\"H\"}$。\n- 情况 4 (长度不匹配): $S_f=\\text{\"ACD\"}$, $S_r=\\text{\"GG\"}$。\n- 情况 5 (奇数长度有解): $S_f=\\text{\"AKR\"}$, $S_r=\\text{\"TFS\"}$。\n\n最终输出格式：\n- 您的程序必须打印单行文本，该行包含一个有 $5$ 个元素的列表，每个元素对应一个测试用例。每个元素要么是表示无解的空列表 $[\\ ]$，要么是代表DNA序列的 $3L$ 个整数列表（使用核苷酸到整数的编码 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$）。打印行中不得包含任何空格。", "solution": "我们从第一性原理出发，利用中心法则和 Watson–Crick 互补性，推导出一个构造性算法，并通过密码子映射和反向互补运算将其形式化。\n\n定义：\n- 令 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，$\\mathcal{A}$ 为 $20$ 种标准氨基酸的集合。\n- 令 $g:\\Sigma^3\\to \\mathcal{A}\\cup\\{\\text{Stop}\\}$ 为标准遗传密码映射，其终止密码子为 $\\text{TAA}$、$\\text{TAG}$、$\\text{TGA}$。\n- 令 $\\mathrm{comp}:\\Sigma\\to\\Sigma$ 为互补函数，$\\mathrm{comp}(\\text{A})=\\text{T}$，$\\mathrm{comp}(\\text{T})=\\text{A}$，$\\mathrm{comp}(\\text{C})=\\text{G}$，$\\mathrm{comp}(\\text{G})=\\text{C}$，通过逐字符应用可扩展至字符串。\n- 令 $\\mathrm{RC}:\\Sigma^k\\to \\Sigma^k$ 为反向互补运算，定义为 $\\mathrm{RC}(x_0x_1\\cdots x_{k-1})=\\mathrm{comp}(x_{k-1})\\cdots \\mathrm{comp}(x_1)\\mathrm{comp}(x_0)$。一个基本性质是，对于 $\\Sigma$ 上的任意字符串 $x,y$，有 $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$。\n\n我们给定两个等长（$L$）的氨基酸序列 $S_f$ 和 $S_r$（如果长度不同，则无解）。我们寻求一个 DNA 序列 $D=c_0c_1\\cdots c_{L-1}$，其中 $c_i\\in\\Sigma^3$，满足：\n- 对所有索引 $i\\in\\{0,\\dots,L-1\\}$，有 $g(c_i)=S_f[i]$。\n- 在读码框 $0$ 中读取反向互补链得到 $S_r$。根据性质 $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$，多个密码子连接体的反向互补等于每个密码子反向互补序列的逆序连接。因此，如果我们定义 $d_i=\\mathrm{RC}(c_i)$，那么反向互补链上位置 $j$（从 $5^{\\prime}$ 端起从 $0$ 开始计数）的密码子就是 $d_{L-1-j}$。为使反向链翻译为 $S_r$，必须对所有 $j$ 满足 $g(d_{L-1-j})=S_r[j]$，这等价于对所有 $i$ 满足 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。\n\n关键在于，这种分解显示了不同位置之间的独立性：每个正向密码子 $c_i$ 只影响反向链上对应的反转位置，并且当两条链都在读码框 $0$ 中读取时，不存在跨密码子的约束。因此，全局约束简化为 $L$ 个独立的局部约束。对于每个 $i\\in\\{0,\\dots,L-1\\}$，我们必须选择一个 $c_i\\in\\Sigma^3$ 同时满足配对条件 $g(c_i)=S_f[i]$ 和 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。如果任何位置 $i$ 找不到这样的 $c_i$，则无解；反之，由于 $\\mathrm{RC}$ 运算可如前述在连接操作上分配，每个位置的任何选择都将产生一个有效的全局解。\n\n为了利用简并性，我们计算任一氨基酸 $a\\in\\mathcal{A}$ 的同义密码子集合：\n$$\n\\mathrm{Codons}(a)=\\{c\\in\\Sigma^3 \\mid g(c)=a\\}.\n$$\n对每个位置 $i$，我们构建可行的正向密码子集合\n$$\n\\mathcal{C}_i=\\{c\\in \\mathrm{Codons}(S_f[i]) \\mid \\mathrm{RC}(c)\\in \\mathrm{Codons}(S_r[L-1-i])\\}.\n$$\n如果任何 $i$ 的 $\\mathcal{C}_i=\\varnothing$，则返回无解。否则，为保证确定性，我们应用字典序平局决胜规则。定义 $\\Sigma$ 上的序为 $\\text{A}<\\text{C}<\\text{G}<\\text{T}$，并通过标准字典序比较将其扩展到 $\\Sigma^3$。选择\n$$\nc_i=\\min\\nolimits_{\\text{lex}} \\mathcal{C}_i.\n$$\n连接这些 $c_i$ 即可得到唯一的确定性解 $D=c_0c_1\\cdots c_{L-1}$。\n\n正确性论证：\n- 可靠性（Soundness）：根据构造，对所有 $i$ 都有 $g(c_i)=S_f[i]$ 和 $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$。因此，$D$ 在正向链上翻译为 $S_f$，而 $\\mathrm{RC}(D)$ 在反向链上的读码框 $0$ 中翻译为 $S_r$。\n- 完备性（Completeness）：如果存在任何满足约束的解 $D^{\\star}$，那么对每个 $i$，其密码子 $c_i^{\\star}$ 必须属于 $\\mathcal{C}_i$。因此，对所有 $i$ 都有 $\\mathcal{C}_i\\neq\\varnothing$。我们的算法选择了某个 $c_i\\in\\mathcal{C}_i$，从而构建了一个有效的 $D$。确定性源于每个位置的字典序最小化选择。\n\n复杂度：\n- 预处理阶段在 $O(1)$ 时间内为所有 $a\\in\\mathcal{A}$ 构建 $\\mathrm{Codons}(a)$，使用常数大小的表。\n- 对于每个测试用例，对每个位置 $i$，我们最多扫描 $6$ 个密码子（对应高度简并的氨基酸，如 Leucine、Serine、Arginine）。因此，时间复杂度为 $O(L)$，带有一个小常数，空间复杂度为 $O(L)$ 用于存储结果。\n\n输出编码：\n- 通过映射 $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$ 转换核苷酸。将 $D$ 编码为一个包含 $3L$ 个整数的有序列表。如果无解，输出空列表。将 $5$ 个必需测试用例的输出聚合到一个无空格的方括号列表中。\n\n应用于测试套件：\n- 对于 $S_f=\\text{\"MALG\"}$，$S_r=\\text{\"TQGH\"}$ 的情况 1 是可行的；通过逐位字典序选择可以获得一个有效的确定性解 $D$。\n- 对于 $S_f=\\text{\"W\"}$，$S_r=\\text{\"A\"}$ 的情况 2 是无解的，因为唯一的 Tryptophan 密码子 $\\text{TGG}$ 的反向互补序列是 $\\text{CCA}$ (Proline)，而它不编码 Alanine。\n- 对于 $S_f=\\text{\"M\"}$，$S_r=\\text{\"H\"}$ 的情况 3 是可行的，因为 $\\text{ATG}$ 的反向互补序列是 $\\text{CAT}$ (Histidine)。\n- 情况 4 长度不匹配，因此立即判定为无解。\n- 对于 $S_f=\\text{\"AKR\"}$，$S_r=\\text{\"TFS\"}$ 的情况 5 是可行的，通过适当的密码子选择可以找到解，该解由约束条件下的字典序最小化唯一确定。\n\n附带的程序实现了此算法，包含了标准遗传密码，构建了可行的密码子集合，强制执行了字典序规则，将结果转换为指定的整数编码，并以单行无空格的形式打印五个测试用例的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Mapping for nucleotide complements (Watson–Crick base pairing)\nCOMP = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n# Standard Genetic Code (NCBI Translation Table 1): DNA codons to amino acids (one-letter code)\nCODON_TO_AA = {\n    # Phenylalanine, Leucine\n    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n    # Serine, Proline, Threonine, Alanine\n    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n    # Tyrosine, Histidine, Glutamine, Asparagine, Lysine, Aspartic acid, Glutamic acid, Cysteine, Tryptophan\n    'TAT': 'Y', 'TAC': 'Y', 'TAA': 'Stop', 'TAG': 'Stop',\n    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n    'TGT': 'C', 'TGC': 'C', 'TGA': 'Stop', 'TGG': 'W',\n    # Leucine, Arginine, Isoleucine, Methionine, Valine, Serine, Arginine, Glycine\n    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n}\n\n# Build amino acid to codons mapping (excluding Stops)\nAA_TO_CODONS = {}\nfor codon, aa in CODON_TO_AA.items():\n    if aa == 'Stop':\n        continue\n    AA_TO_CODONS.setdefault(aa, []).append(codon)\n\n# Define nucleotide order for lexicographic sorting: A < C < G < T\nNUC_ORDER = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\ndef lex_key(codon: str):\n    return (NUC_ORDER[codon[0]], NUC_ORDER[codon[1]], NUC_ORDER[codon[2]])\n\n# Sort codon lists for deterministic lexicographic selection\nfor aa in AA_TO_CODONS:\n    AA_TO_CODONS[aa].sort(key=lex_key)\n\ndef reverse_complement(codon: str) -> str:\n    # Reverse the codon and complement each nucleotide\n    return ''.join(COMP[n] for n in reversed(codon))\n\ndef dna_to_ints(dna: str):\n    # Map nucleotides to integers A->0, C->1, G->2, T->3\n    mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    return [mapping[n] for n in dna]\n\ndef find_dual_encoding_dna(Sf: str, Sr: str):\n    # If lengths differ, impossible\n    if len(Sf) != len(Sr):\n        return []\n    L = len(Sf)\n    codons_forward = []\n\n    for i in range(L):\n        a_f = Sf[i]\n        a_r = Sr[L - 1 - i]\n        # Validate amino acids\n        if a_f not in AA_TO_CODONS or a_r not in AA_TO_CODONS:\n            return []\n        feasible = None\n        for codon in AA_TO_CODONS[a_f]:\n            rc = reverse_complement(codon)\n            # Ensure reverse complement codon encodes the required reverse amino acid\n            if rc in AA_TO_CODONS[a_r]:\n                feasible = codon\n                break  # lexicographically smallest due to prior sorting\n        if feasible is None:\n            return []\n        codons_forward.append(feasible)\n\n    dna = ''.join(codons_forward)\n    return dna_to_ints(dna)\n\ndef format_result_list(list_of_lists):\n    # Format as a single-line string with no spaces, nested lists\n    def format_one(lst):\n        return '[' + ','.join(str(x) for x in lst) + ']'\n    return '[' + ','.join(format_one(lst) for lst in list_of_lists) + ']'\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MALG\", \"TQGH\"),  # Case 1\n        (\"W\", \"A\"),        # Case 2\n        (\"M\", \"H\"),        # Case 3\n        (\"ACD\", \"GG\"),     # Case 4\n        (\"AKR\", \"TFS\"),    # Case 5\n    ]\n\n    results = []\n    for Sf, Sr in test_cases:\n        res = find_dual_encoding_dna(Sf, Sr)\n        results.append(res)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    print(format_result_list(results))\n\nsolve()\n```", "id": "2384918"}]}