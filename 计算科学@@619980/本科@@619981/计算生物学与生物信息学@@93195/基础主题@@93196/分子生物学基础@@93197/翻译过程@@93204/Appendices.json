{"hands_on_practices": [{"introduction": "在我们分析一个基因的功能或演化之前，首要任务是在浩瀚的基因组序列中将其定位。这个基础练习将引导你思考在双链DNA分子中，我们必须考虑多少种可能的“阅读方式”，即阅读框架。理解这一点是所有基因预测算法的基石，也是计算生物学分析的出发点。[@problem_id:1528641]", "problem": "在生物信息学领域，基因组注释的关键第一步是识别DNA序列中所有潜在的蛋白质编码基因。这是通过搜索开放阅读框（ORFs）来完成的，开放阅读框是可以被翻译成多肽的连续DNA片段。一个ORF以一个起始密码子开始，并在同一阅读框内以一个终止密码子结束。一个计算机算法的任务是分析一个新测序的、长度为 $N$ 个碱基对的线性双链DNA分子。为确保不会漏掉任何潜在的蛋白质，该算法必须在每个可能的阅读框中扫描该分子。阅读框是由起始核苷酸定义的，从该核苷酸开始，序列被翻译成不重叠的氨基酸三联体（密码子）。\n\n对这个给定的双链DNA分子进行完整搜索，必须对多少个不同的阅读框进行计算分析？", "solution": "开放阅读框由一个起始密码子和一个框内终止密码子定义，其中阅读框取决于序列如何被分割成长度为3个核苷酸的连续密码子。在任何一条单链上，根据选择的起始核苷酸（对应于偏移量$0$、$1$和$2$）将序列划分为三个一组的密码子，会产生三种不同的非重叠分区，即三种可能的阅读框。\n\n由于DNA分子是双链且反向平行的，潜在的蛋白质编码序列可以存在于任何一条链上。因此，算法必须分析一条链的5'到3'方向，以及其反向互补链的5'到3'方向。每条链产生3个阅读框。\n\n因此，需要分析的独立阅读框总数为\n$$\n3 \\times 2 = 6.\n$$\n长度 $N$ 不会改变这个数量，因为阅读框的数量仅取决于密码子的长度和所考虑的链的数量。", "answer": "$$\\boxed{6}$$", "id": "1528641"}, {"introduction": "在确定了阅读框架的重要性之后，下一个自然而然的问题是：如果阅读框架被破坏了会发生什么？本练习通过一个巧妙的假设场景，展示了插入和删除突变（统称为“移码突变”）如何导致蛋白质序列的灾难性改变。同时，它也揭示了第二个突变有时能够部分“补偿”第一个突变，从而恢复阅读框架，这深化了我们对基因翻译鲁棒性的理解。[@problem_id:1528639]", "problem": "一个假设的细菌基因 `enzY` 编码一种催化酶，该酶对于代谢一种特定的糖至关重要。功能完整的酶是一条由300个氨基酸组成的单一多肽链。\n\n一位研究人员创建了一个突变株，命名为突变体A，该突变株无法在仅含这种糖的培养基上生长。对突变体A进行DNA测序后发现，在 `enzY` 基因编码序列的第30个核苷酸之后，紧接着插入了一个鸟嘌呤（G）核苷酸。\n\n随后，研究人员将突变体A群体暴露于一种诱变剂中，并筛选出了“回复突变”菌株，这些菌株重新获得了代谢该糖的能力，即使其效率不如原始野生型菌株。其中一个这样的菌株被分离出来，命名为突变体B。对突变体B中的 `enzY` 基因进行测序后发现，最初的鸟嘌呤插入仍然存在。然而，发生了第二个新的突变：在对应于原始野生型序列中第46位核苷酸的位置上，发生了一个单核苷酸缺失。\n\n根据这些信息以及您对信使核糖核酸（mRNA）翻译过程的理解，与野生型蛋白相比，下列哪个陈述最准确地描述了在突变体B菌株中产生的EnzY蛋白？\n\nA. 该蛋白将具有与野生型相同的N端序列，随后是一小段不正确的氨基酸，然后C端序列将与野生型相同。\n\nB. 该蛋白将与野生型蛋白完全相同，因为插入和缺失的影响完全相互抵消。\n\nC. 该蛋白将严重截短且无功能，因为插入突变引入了一个提前终止密码子，而这个终止密码子没有被下游的缺失所抑制。\n\nD. 该蛋白与野生型相比仅有一个氨基酸替换的差异。\n\nE. 该蛋白从第一次插入的位置一直到其C端的氨基酸序列将完全不同。", "solution": "翻译过程以长度为$3$的非重叠密码子读取mRNA，因此每个氨基酸由一个核苷酸三联体编码。一条由$300$个氨基酸组成的多肽链对应于$300 \\times 3 = 900$个编码核苷酸（不包括终止密码子）。在野生型基因中，第$k$个密码子使用第$3k-2, 3k-1, 3k$个核苷酸。\n\n突变体A中的单核苷酸插入发生在第$30$个核苷酸之后。由于$30 \\equiv 0 \\pmod{3}$，这次插入恰好发生在一个密码子边界（第$10$个密码子之后）。单核苷酸插入会使阅读框从该点开始向前移动$+1$，因此在突变体A中，前$10$个氨基酸（由第$1$到第$30$个核苷酸编码）保持不变，而从第$11$个密码子开始的阅读框被改变（移码），通常会产生一连串不正确的氨基酸，并常常导致提前出现终止密码子。\n\n在突变体B中，原始的插入仍然存在，但在对应于野生型序列中第$46$个核苷酸的位置上，额外发生了一次单核苷酸缺失。由于$45 \\equiv 0 \\pmod{3}$，第$46$个核苷酸是野生型第$16$个密码子的第一个碱基（野生型密码子：第$11$个使用$31$–$33$号核苷酸，第$12$个使用$34$–$36$号，第$13$个使用$37$–$39$号，第$14$个使用$40$–$42$号，第$15$个使用$43$–$45$号，第$16$个使用$46$–$48$号）。单核苷酸缺失会使阅读框从该点开始向后移动$-1$。因此，由插入（在第$30$个核苷酸之后）引起的$+1$相移被由缺失（在第$46$个核苷酸处）引起的$-1$相移精确抵消，从而在缺失的下游恢复了原始阅读框。\n\n为了解其对氨基酸序列的影响，我们来比较两次突变前后密码子的分组情况。插入之后（但缺失之前），密码子重新排列如下：\n- 野生型的第$11$个密码子：$31$–$33$，在移位的框中变为（插入的碱基）–$31$–$32$；\n- 野生型的第$12$个密码子：$34$–$36$，变为$33$–$35$；以此类推，直到跨越野生型第$31$到第$46$个核苷酸的区域都以错误的阅读框被翻译。\n\n在突变体B中，缺失第$46$个核苷酸使得缺失位置紧邻下游的相位回到了原始框，因此完全处于下游的密码子（从野生型第$17$个密码子，即$49$–$51$号核苷酸开始）与野生型密码子完全匹配。因此：\n- N端（前$10$个氨基酸）与野生型相同（在第$31$个核苷酸之前没有变化）。\n- 从插入点开始，直到并包括跨越缺失位点的密码子所翻译的片段，都处于错误的阅读框中，因而编码了一小段不正确的氨基酸。\n- 从缺失位置完全下游的第一个密码子开始（即从野生型第$17$个密码子开始），阅读框和密码子都恢复为野生型，从而产生与野生型相同的C端序列。\n\n因此，突变体B中的蛋白将具有与野生型相同的N端序列，然后在插入和缺失位点之间有一小段改变了的氨基酸，其后是与野生型相同的C端序列。这与选项A相符，并排除了B（整体上不相同）、C（没有严重截短；阅读框已恢复）、D（在移码片段中发生了不止一个氨基酸的替换）和E（到C端的序列并非完全不同，因为阅读框已恢复）。", "answer": "$$\\boxed{A}$$", "id": "1528639"}, {"introduction": "从基因的结构转向其统计特性，这项高级实践将带你进入真实世界的生物信息学研究。你将扮演一名计算生物学家的角色，任务是分析一个基因家族的密码子使用模式是否与基因组的整体背景存在显著差异。这个挑战需要你应用严谨的统计方法来控制混淆变量，这是基因组学和演化研究中的一项核心技能。[@problem_id:2436458]", "problem": "您将处理一个关于计算生物学和生物信息学中翻译和密码子使用的问题。考虑在二重简并位点上的两类同义密码子：第三个密码子位置以鸟嘌呤或胞嘧啶结尾的（GC3），以及以腺嘌呤或胸腺嘧啶结尾的（AT3）。对于一个特定的基因家族和基因组背景（基因组的其余部分），您将获得按局部鸟嘌呤-胞嘧啶含量（GC）分层的计数。您必须确定，在控制了局部GC含量后，该基因家族的密码子使用是否与基因组背景存在显著差异。形式上，对于每个由 $k \\in \\{1,\\dots,K\\}$ 索引的层，考虑一个 $2 \\times 2$ 表格，其中第1行对应基因家族，第2行对应基因组背景，第1列对应GC3，第2列对应AT3。设 $a_k$ 为基因家族中GC3的计数，$b_k$ 为基因家族中AT3的计数，$c_k$ 为背景中GC3的计数，$d_k$ 为背景中AT3的计数，每层的总大小为 $n_k = a_k + b_k + c_k + d_k$。零假设是，在以每个层 $k$ 为条件下，基因家族中GC3与AT3的分布与背景中的分布相同，这可以解释为所有层的共同比值比（odds ratio）等于1。您必须在显著性水平 $\\alpha = 0.05$ 下检验此假设，并为每个测试用例输出一个整数决策：如果拒绝零假设，则输出 $1$，否则输出 $0$。\n\n请使用以下测试套件。每个测试用例包含 $K$ 个层。对于每个层 $k$，您将获得作为小数的局部GC含量 $g_k \\in [0,1]$（仅用于记录；假设检验必须控制分层，但不需要 $g_k$ 的数值），以及上文定义的计数 $(a_k,b_k,c_k,d_k)$。所有计数均为非负整数。\n\n测试用例A（包含三个层的通用情况）：\n- 层 $k=1$: $g_1 = 0.30$, $a_1 = 40$, $b_1 = 60$, $c_1 = 120$, $d_1 = 280$。\n- 层 $k=2$: $g_2 = 0.50$, $a_2 = 120$, $b_2 = 80$, $c_2 = 200$, $d_2 = 200$。\n- 层 $k=3$: $g_3 = 0.70$, $a_3 = 98$, $b_3 = 22$, $c_3 = 350$, $d_3 = 150$。\n\n测试用例B（与零假设一致的三个层的情况）：\n- 层 $k=1$: $g_1 = 0.30$, $a_1 = 30$, $b_1 = 70$, $c_1 = 60$, $d_1 = 140$。\n- 层 $k=2$: $g_2 = 0.50$, $a_2 = 50$, $b_2 = 50$, $c_2 = 150$, $d_2 = 150$。\n- 层 $k=3$: $g_3 = 0.70$, $a_3 = 35$, $b_3 = 15$, $c_3 = 210$, $d_3 = 90$。\n\n测试用例C（包含小数和零单元格的边缘情况，两个层）：\n- 层 $k=1$: $g_1 = 0.20$, $a_1 = 0$, $b_1 = 5$, $c_1 = 1$, $d_1 = 9$。\n- 层 $k=2$: $g_2 = 0.80$, $a_2 = 5$, $b_2 = 0$, $c_2 = 9$, $d_2 = 1$。\n\n您的程序必须为每个测试用例独立地进行一次有效的假设检验，该检验需检验所述的零假设，控制分层，并在显著性水平 $\\alpha = 0.05$ 下得出决策。最终输出格式必须为单行，其中包含按A、B、C顺序排列的决策的逗号分隔列表，并用方括号括起来，例如，[$1$,$0$,$0$]。", "solution": "我们使用列联表和条件推断来形式化该问题。翻译过程涉及将密码子映射到氨基酸。在比较基因家族和基因组背景之间的密码子使用时，正确的比较应仅限于同义变异，此处具体表现为二重简并位点上GC3与AT3的对比。局部鸟嘌呤-胞嘧啶（GC）含量可能会混淆密码子使用，因为偏向GC的区域可能独立于任何家族特异性选择而偏好以GC结尾的密码子。因此，统计检验必须通过以局部GC定义的层为条件来进行控制。\n\n对于每个由 $k \\in \\{1,\\dots,K\\}$ 索引的层，定义 $2 \\times 2$ 表格\n$$\n\\begin{array}{c|cc}\n & \\text{GC3} & \\text{AT3} \\\\\n\\hline\n\\text{家族} & a_k & b_k \\\\\n\\text{背景} & c_k & d_k \\\\\n\\end{array}\n$$\n行总计为 $n_{1k} = a_k + b_k$ 和 $n_{2k} = c_k + d_k$，列总计为 $m_{1k} = a_k + c_k$ 和 $m_{2k} = b_k + d_k$，总计为 $n_k = n_{1k} + n_{2k} = a_k + b_k + c_k + d_k$。\n\n在零假设（即在每个层中条件分布均相同，共同比值比等于1）下，并以每个层中固定的行总计和列总计为条件， $a_k$ 的分布是超几何分布，其期望和方差为：\n$$\n\\mathbb{E}[a_k] = \\frac{n_{1k} m_{1k}}{n_k}, \\quad \\mathrm{Var}(a_k) = \\frac{n_{1k} n_{2k} m_{1k} m_{2k}}{n_k^2 (n_k - 1)}.\n$$\n一个有原则的分层检验，用于聚合各层证据的是Cochran–Mantel–Haenszel (CMH) 统计量，它是通过将中心化后的计数求和，并根据超几何模型下的方差进行缩放，从第一性原理推导出来的：\n$$\nX^2_{\\mathrm{CMH}} = \\frac{\\left(\\sum_{k=1}^{K} (a_k - \\mathbb{E}[a_k])\\right)^2}{\\sum_{k=1}^{K} \\mathrm{Var}(a_k)}.\n$$\n在零假设下，对于足够大的 $n_k$， $X^2_{\\mathrm{CMH}}$ 近似服从自由度为1的卡方分布。在显著性水平 $\\alpha$ 下的双侧检验，当上尾概率满足 $p = 1 - F_{\\chi^2_1}(X^2_{\\mathrm{CMH}}) < \\alpha$ 时拒绝零假设，其中 $F_{\\chi^2_1}(\\cdot)$ 是自由度为1的卡方分布的累积分布函数。如果某个层的 $\\mathrm{Var}(a_k) = 0$（例如，边际退化），它不提供任何信息，应从总和中排除；如果分母中的总方差为 $0$，则该检验未定义，我们保守地设置 $p = 1$ （不拒绝）。\n\n现在我们将此方法应用于所提供的测试用例。\n\n测试用例A。三个层的数据如下：\n- $k=1$: $(a_1,b_1,c_1,d_1) = (40,60,120,280)$，因此 $n_{1,1} = 100$, $m_{1,1} = 160$, $n_1 = 500$。于是 $\\mathbb{E}[a_1] = \\frac{100 \\cdot 160}{500} = 32$，且 $\\mathrm{Var}(a_1) = \\frac{100 \\cdot 400 \\cdot 160 \\cdot 340}{500^2 \\cdot 499} \\approx 17.438$。\n- $k=2$: $(a_2,b_2,c_2,d_2) = (120,80,200,200)$，因此 $n_{1,2} = 200$, $m_{1,2} = 320$, $n_2 = 600$。于是 $\\mathbb{E}[a_2] = \\frac{200 \\cdot 320}{600} \\approx 106.667$，且 $\\mathrm{Var}(a_2) \\approx 33.250$。\n- $k=3$: $(a_3,b_3,c_3,d_3) = (98,22,350,150)$，因此 $n_{1,3} = 120$, $m_{1,3} = 448$, $n_3 = 620$。于是 $\\mathbb{E}[a_3] \\approx 86.710$，且 $\\mathrm{Var}(a_3) \\approx 19.440$。\n\n将偏差求和得到 $\\sum_k (a_k - \\mathbb{E}[a_k]) \\approx (40 - 32) + (120 - 106.667) + (98 - 86.710) \\approx 32.624$。总方差为 $\\sum_k \\mathrm{Var}(a_k) \\approx 17.438 + 33.250 + 19.440 \\approx 70.128$。因此，\n$$\nX^2_{\\mathrm{CMH}} \\approx \\frac{(32.624)^2}{70.128} \\approx 15.18,\n$$\n得出的上尾概率 $p \\ll 0.05$。决策：拒绝，输出 $1$。\n\n测试用例B。三个层的条件比例匹配：\n- $k=1$: $(a_1,b_1,c_1,d_1) = (30,70,60,140)$，因此 $\\mathbb{E}[a_1] = \\frac{100 \\cdot 90}{300} = 30$ 且 $a_1 - \\mathbb{E}[a_1] = 0$。\n- $k=2$: $(a_2,b_2,c_2,d_2) = (50,50,150,150)$，因此 $\\mathbb{E}[a_2] = \\frac{100 \\cdot 200}{400} = 50$ 且 $a_2 - \\mathbb{E}[a_2] = 0$。\n- $k=3$: $(a_3,b_3,c_3,d_3) = (35,15,210,90)$，因此 $\\mathbb{E}[a_3] = \\frac{50 \\cdot 245}{350} = 35$ 且 $a_3 - \\mathbb{E}[a_3] = 0$。\n\n因此 $\\sum_k (a_k - \\mathbb{E}[a_k]) = 0$，所以 $X^2_{\\mathrm{CMH}} = 0$ 且 $p = 1 \\ge 0.05$。决策：不拒绝，输出 $0$。\n\n测试用例C。两个层，计数小且有零：\n- $k=1$: $(a_1,b_1,c_1,d_1) = (0,5,1,9)$，因此 $n_{1,1} = 5$, $m_{1,1} = 1$, $n_1 = 15$。于是 $\\mathbb{E}[a_1] = \\frac{5 \\cdot 1}{15} = \\frac{1}{3}$ 且 $\\mathrm{Var}(a_1) = \\frac{5 \\cdot 10 \\cdot 1 \\cdot 14}{15^2 \\cdot 14} = \\frac{50}{225} \\approx 0.222$。\n- $k=2$: $(a_2,b_2,c_2,d_2) = (5,0,9,1)$，因此 $n_{1,2} = 5$, $m_{1,2} = 14$, $n_2 = 15$。于是 $\\mathbb{E}[a_2] = \\frac{5 \\cdot 14}{15} = \\frac{14}{3}$ 且 $\\mathrm{Var}(a_2) = \\frac{5 \\cdot 10 \\cdot 14 \\cdot 1}{15^2 \\cdot 14} = \\frac{50}{225} \\approx 0.222$。\n\n中心化后的计数为 $(a_1 - \\mathbb{E}[a_1]) = -\\frac{1}{3}$ 和 $(a_2 - \\mathbb{E}[a_2]) = +\\frac{1}{3}$，因此它们在求和时相互抵消，得到 $\\sum_k (a_k - \\mathbb{E}[a_k]) = 0$，所以 $X^2_{\\mathrm{CMH}} = 0$ 且 $p = 1 \\ge 0.05$。决策：不拒绝，输出 $0$。\n\n因此，对于测试用例 A、B 和 C，所需的输出分别为整数 $1$、$0$ 和 $0$，并以 [$1$,$0$,$0$] 的格式打印为单行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef cmh_decision(strata, alpha=0.05):\n    \"\"\"\n    Compute the Cochran–Mantel–Haenszel (CMH) chi-square test for K 2x2 strata.\n    Each stratum is a tuple (a, b, c, d) with:\n      a: family GC3\n      b: family AT3\n      c: background GC3\n      d: background AT3\n    Returns 1 if reject H0 at level alpha, else 0.\n    \"\"\"\n    dev_sum = 0.0\n    var_sum = 0.0\n    for (a, b, c, d) in strata:\n        n1 = a + b\n        n2 = c + d\n        m1 = a + c\n        m2 = b + d\n        n = n1 + n2\n        # Skip degenerate strata where variance is undefined or zero\n        if n <= 1:\n            continue\n        # Expected value and variance under hypergeometric model\n        exp_a = (n1 * m1) / n if n != 0 else 0.0\n        # Variance formula: n1*n2*m1*m2 / (n^2 * (n-1))\n        # Only accumulate if denominator is nonzero and variance positive\n        denom = (n * n) * (n - 1)\n        if denom == 0:\n            continue\n        var_a = (n1 * n2 * m1 * m2) / denom\n        # If variance is zero, the stratum contributes no information\n        if var_a <= 0.0:\n            continue\n        dev_sum += (a - exp_a)\n        var_sum += var_a\n    if var_sum <= 0.0:\n        # No informative strata; cannot reject\n        return 0\n    x2 = (dev_sum * dev_sum) / var_sum\n    p_value = 1.0 - chi2.cdf(x2, df=1)\n    return 1 if p_value < alpha else 0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a list of strata; each stratum includes the GC (unused) and counts (a,b,c,d).\n    # We only extract (a,b,c,d) for the CMH test.\n    test_cases = [\n        # Test case A\n        [\n            (0.30, 40, 60, 120, 280),\n            (0.50, 120, 80, 200, 200),\n            (0.70, 98, 22, 350, 150),\n        ],\n        # Test case B\n        [\n            (0.30, 30, 70, 60, 140),\n            (0.50, 50, 50, 150, 150),\n            (0.70, 35, 15, 210, 90),\n        ],\n        # Test case C\n        [\n            (0.20, 0, 5, 1, 9),\n            (0.80, 5, 0, 9, 1),\n        ],\n    ]\n\n    results = []\n    for case in test_cases:\n        strata = [(a, b, c, d) for (_g, a, b, c, d) in case]\n        result = cmh_decision(strata, alpha=0.05)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2436458"}]}