{"hands_on_practices": [{"introduction": "基因的精确调控通常涉及分子间的竞争。本练习将引导你应用热力学平衡原理，量化一个增强子如何在多个启动子之间进行“选择”。通过构建一个竞争性结合模型，你将学会如何利用解离常数（$K_{d}$）和有效浓度来计算特定增强子-启动子复合物形成的概率，这是理解基因表达特异性的基础。[@problem_id:2436287]", "id": "2436287", "problem": "单个基因组增强子可以通过染色质环化接触启动子，并仅在与一个启动子发生物理结合时激活转录。考虑一个增强子 $E$，它位于一个基因密集区域，附近有三个启动子 $P_{1}$、$P_{2}$ 和 $P_{3}$。该增强子可以处于以下四种互斥状态之一：未结合、与 $P_{1}$ 结合、与 $P_{2}$ 结合或与 $P_{3}$ 结合。$E$ 与每个启动子 $P_{i}$ 之间的结合由可逆反应 $E + P_{i} \\rightleftharpoons C_{i}$ 描述，其中 $C_{i}$ 是增强子-启动子复合物。在热力学平衡状态下，平衡解离常数定义为 $K_{i} = \\frac{[E][P_{i}]}{[C_{i}]}$，其中 $i \\in \\{1,2,3\\}$。\n\n假设：\n- 增强子是唯一的，因此总增强子浓度 $[E]_{\\mathrm{T}}$ 使得一次只能发生一个结合事件。\n- 每个启动子 $P_{i}$ 实际上以一个恒定的局部浓度 $c_{i}$ 存在，该浓度反映了其与增强子的三维相遇频率（有效摩尔浓度）。\n- 在相关尺度上，系统是充分混合的，并遵循质量作用定律。\n- 增强子与任何一个启动子的结合不会显著扰动其他启动子的有效浓度 $c_{i}$。\n\n给定以下实验测定的参数，单位为纳摩尔 (nM)：\n- $c_{1} = 100~\\text{nM}$, $c_{2} = 50~\\text{nM}$, $c_{3} = 200~\\text{nM}$,\n- $K_{1} = 10~\\text{nM}$, $K_{2} = 25~\\text{nM}$, $K_{3} = 100~\\text{nM}$。\n\n在这些假设下，增强子与启动子 $P_{1}$ 结合的平衡概率是多少？请以无量纲的小数形式提供答案，并四舍五入到四位有效数字。", "solution": "该问题要求计算在一个系统中，增强子 $E$ 与特定启动子 $P_{1}$ 结合的平衡概率。在该系统中，增强子也可能处于未结合状态，或与另外两个启动子 $P_{2}$ 和 $P_{3}$ 结合。这是一个经典的热力学平衡下的竞争性结合问题，可以使用统计力学原理来解决。\n\n系统中增强子有四种互斥状态：\n1.  未结合，我们记为状态 $S_{0}$。该物种是游离增强子 $E$。\n2.  与启动子 $P_{1}$ 结合，形成复合物 $C_{1}$。我们记为状态 $S_{1}$。\n3.  与启动子 $P_{2}$ 结合，形成复合物 $C_{2}$。我们记为状态 $S_{2}$。\n4.  与启动子 $P_{3}$ 结合，形成复合物 $C_{3}$。我们记为状态 $S_{3}$。\n\n增强子处于任何特定状态 $S_{i}$ 的概率与平衡时相应物种的浓度成正比。设 $p_{i}$ 为处于状态 $S_{i}$ 的概率。那么：\n$p_{0} \\propto [E]$\n$p_{1} \\propto [C_{1}]$\n$p_{2} \\propto [C_{2}]$\n$p_{3} \\propto [C_{3}]$\n\n总概率必须为 $1$：$p_{0} + p_{1} + p_{2} + p_{3} = 1$。\n\n为了找到不同物种浓度之间的关系，我们使用给定的平衡解离常数 $K_{i} = \\frac{[E][P_{i}]}{[C_{i}]}$。我们可以重新整理这个公式，用游离增强子浓度 $[E]$ 来表示每个复合物的浓度 $[C_{i}]$：\n$$[C_{i}] = \\frac{[E][P_{i}]}{K_{i}}$$\n\n问题陈述中指出，每个启动子 $P_{i}$ 以一个恒定的有效浓度 $c_{i}$ 存在。因此，我们可以代入 $[P_{i}] = c_{i}$：\n$$[C_{1}] = \\frac{[E]c_{1}}{K_{1}}$$\n$$[C_{2}] = \\frac{[E]c_{2}}{K_{2}}$$\n$$[C_{3}] = \\frac{[E]c_{3}}{K_{3}}$$\n\n找到增强子处于某一特定状态的概率，是该状态物种的浓度除以包含增强子的所有物种的总浓度。增强子所有可能形式的总浓度为 $[E]_{\\mathrm{T}} = [E] + [C_{1}] + [C_{2}] + [C_{3}]$。\n\n增强子与启动子 $P_{1}$ 结合的概率由下式给出：\n$$p_{1} = \\frac{[C_{1}]}{[E]_{\\mathrm{T}}} = \\frac{[C_{1}]}{[E] + [C_{1}] + [C_{2}] + [C_{3}]}$$\n\n我们可以将分母中的所有项表示为游离增强子浓度 $[E]$ 的函数：\n$$p_{1} = \\frac{\\frac{[E]c_{1}}{K_{1}}}{[E] + \\frac{[E]c_{1}}{K_{1}} + \\frac{[E]c_{2}}{K_{2}} + \\frac{[E]c_{3}}{K_{3}}}$$\n\n项 $[E]$ 是分子和分母中所有项的公因子，因此可以约去。这是统计力学的一个关键见解：参考态的绝对浓度不影响相对概率。\n$$p_{1} = \\frac{\\frac{c_{1}}{K_{1}}}{1 + \\frac{c_{1}}{K_{1}} + \\frac{c_{2}}{K_{2}} + \\frac{c_{3}}{K_{3}}}$$\n\n这个表达式等价于使用配分函数 $Z$ 的公式。未结合态的统计权重取为 $W_{0} = 1$。结合态的统计权重为 $W_{i} = \\frac{c_{i}}{K_{i}}$。配分函数是所有统计权重的总和：$Z = W_{0} + W_{1} + W_{2} + W_{3}$。任何状态 $i$ 的概率是 $p_{i} = \\frac{W_{i}}{Z}$。对于状态 $S_{1}$，这正是上面推导出的公式。\n\n现在，我们将给定的数值代入表达式中。\n给定的参数是：\n- $c_{1} = 100~\\text{nM}$\n- $c_{2} = 50~\\text{nM}$\n- $c_{3} = 200~\\text{nM}$\n- $K_{1} = 10~\\text{nM}$\n- $K_{2} = 25~\\text{nM}$\n- $K_{3} = 100~\\text{nM}$\n\n首先，我们计算无量纲比值 $\\frac{c_{i}}{K_{i}}$：\n$$\\frac{c_{1}}{K_{1}} = \\frac{100}{10} = 10$$\n$$\\frac{c_{2}}{K_{2}} = \\frac{50}{25} = 2$$\n$$\\frac{c_{3}}{K_{3}} = \\frac{200}{100} = 2$$\n\n现在，我们可以计算概率 $p_{1}$：\n$$p_{1} = \\frac{10}{1 + 10 + 2 + 2} = \\frac{10}{15}$$\n\n化简分数得到：\n$$p_{1} = \\frac{2}{3}$$\n\n问题要求答案以四舍五入到四位有效数字的小数形式给出。\n$$p_{1} = \\frac{2}{3} \\approx 0.666666...$$\n四舍五入到四位有效数字，我们得到 $0.6667$。\n这就是增强子与启动子 $P_{1}$ 结合的平衡概率。", "answer": "$$\\boxed{0.6667}$$"}, {"introduction": "在理解了分子识别的“为何”之后，我们来探讨其“如何”发生。本练习将转录因子在 DNA 上寻找其结合位点的过程建模为一个一维随机游走，这是分子生物学中的一个基本物理模型。通过求解这个模型，你将计算出搜索成功概率和平均搜索时间等关键指标，从而深入理解基因调控的效率和动力学过程。[@problem_id:2436198]", "id": "2436198", "problem": "一个沿着脱氧核糖核酸（DNA）聚合物扫描的转录因子可以被理想化为一个在位点离散晶格 $\\{0,1,\\dots,L-1\\}$ 上的连续时间一维随机行走。在索引 $s^{\\star}$ 处有一个唯一的目标位点；当转录因子到达 $s^{\\star}$ 时，搜索成功终止。从任何非目标位点 $i$ 出发，该因子以速率 $k_{\\ell}$ 尝试向左移动一个位点，以速率 $k_{r}$ 尝试向右移动一个位点，并能以速率 $k_{\\mathrm{off}}$ 从DNA上不可逆地解离（解绑）。在 $i=0$ 和 $i=L-1$ 处的边界是反射的：在 $i=0$ 处尝试向左移动不会改变其位置，在 $i=L-1$ 处尝试向右移动也不会改变其位置；这些反射移动不会发生，应被建模为这些跃迁的缺失，而非自跃迁。目标位点 $s^{\\star}$ 是一个成功的吸收态，意味着一旦到达，过程立即停止，此后不再发生解离。所有速率均为常数，单位为 $\\mathrm{s}^{-1}$，时间必须以秒为单位报告。\n\n对于给定的起始位点 $i_{0}$，定义以下两个量：\n- 概率 $p(i_{0})$，表示过程在解离前到达 $s^{\\star}$ 的概率。\n- 条件平均搜索时间 $m(i_{0}) = \\mathbb{E}[T \\mid \\text{在解离前到达 } s^{\\star}, X(0)=i_{0}]$，其中 $T$ 是到达 $s^{\\star}$ 的时间， $X(0)$ 是初始位置。若 $p(i_{0})=0$，则定义 $m(i_{0})=0$。\n\n在以下所有测试用例中，假设滑动速率是对称的，即 $k_{\\ell}=k_{r}=k$。你的程序必须为每个测试用例计算一对实数 $\\big(p(i_{0}), m(i_{0})\\big)$，其中 $m(i_{0})$ 以秒表示。每个实数必须四舍五入到小数点后恰好六位。\n\n测试套件参数如下，每个参数指定为一个元组 $(L, s^{\\star}, i_{0}, k, k_{\\mathrm{off}})$，其中所有整数和实数均已明确给出：\n- A例（一般内部目标）： $(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (21, 10, 0, 100.0, 1.0)$。\n- B例（从目标位点开始）： $(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (21, 10, 10, 100.0, 1.0)$。\n- C例（远处目标且强解离）： $(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (21, 20, 0, 50.0, 50.0)$。\n- D例（无解离的最小晶格）： $(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (2, 1, 0, 2.0, 0.0)$。\n\n你的程序应生成单行输出，其中包含按顺序汇总的结果，形式为一个用方括号括起来的、无空格的逗号分隔列表。该列表必须按上述顺序列出每个测试用例的两个浮点数，即 $[p(\\text{A}), m(\\text{A}), p(\\text{B}), m(\\text{B}), p(\\text{C}), m(\\text{C}), p(\\text{D}), m(\\text{D})]$，其中每个浮点数四舍五入到小数点后六位。", "solution": "在尝试任何解决方案之前，首先评估问题陈述的有效性。\n\n步骤1：提取已知条件\n- 过程：连续时间一维随机行走。\n- 状态空间：位点离散晶格 $\\mathcal{S} = \\{0, 1, \\dots, L-1\\}$。\n- 目标位点：唯一的吸收位点 $s^{\\star} \\in \\mathcal{S}$。\n- 初始位点：$i_{0} \\in \\mathcal{S}$。\n- 从任意非目标位点 $i$ 的跃迁速率：\n    - 到位点 $i-1$：速率 $k_{\\ell}$。\n    - 到位点 $i+1$：速率 $k_{r}$。\n    - 解离（失败）：速率 $k_{\\mathrm{off}}$。\n- 非目标边界处的边界条件：\n    - 在 $i=0$ 处：反射。向左移动的尝试不会发生。总出射跃迁速率为 $k_r + k_{\\mathrm{off}}$。\n    - 在 $i=L-1$ 处：反射。向右移动的尝试不会发生。总出射跃迁速率为 $k_\\ell + k_{\\mathrm{off}}$。\n- 特殊条件：对称滑动，$k_{\\ell} = k_{r} = k$。\n- 待计算的量：\n    - $p(i_{0})$：从 $i_{0}$ 开始，在解离前到达 $s^{\\star}$ 的概率。\n    - $m(i_{0})$：在搜索成功的情况下，到达 $s^{\\star}$ 的条件平均搜索时间。\n- 特殊定义：若 $p(i_{0})=0$，则 $m(i_{0})=0$。\n- 测试用例 $(L, s^{\\star}, i_{0}, k, k_{\\mathrm{off}})$：\n    - A: $(21, 10, 0, 100.0, 1.0)$\n    - B: $(21, 10, 10, 100.0, 1.0)$\n    - C: $(21, 20, 0, 50.0, 50.0)$\n    - D: $(2, 1, 0, 2.0, 0.0)$\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了一个带终止的连续时间马尔可夫链，这是统计物理学和计算生物学中用于研究蛋白质-DNA靶标搜索等过程的标准基础模型（Berg-von Hippel模型）。该问题在科学上是合理的。\n- **适定性**：该问题要求计算到达一个吸收态的成功概率和条件平均首达时间。对于有限态马尔可夫过程，这些量是良定义的，并导向一个唯一的稳定解，该解可通过求解一个线性方程组获得。\n- **客观性**：该问题使用精确、无歧义的数学和物理术语进行陈述。参数均已明确提供。\n\n步骤3：结论与行动\n- **结论**：该问题是有效的。它是一个生物物理建模中的标准、适定的问题。未发现任何缺陷。\n- **行动**：继续提供一个完整的、有理有据的解决方案。\n\n我们现在将为任意起始位点 $i \\in \\mathcal{S}$ 推导控制成功概率 $p(i)$ 和条件平均搜索时间 $m(i)$ 的线性方程组。\n\n**1. 成功概率 $p(i)$**\n\n令 $p_i$ 表示从位点 $i$ 开始最终到达目标位点 $s^{\\star}$ 的概率。根据定义，如果过程从目标位点开始，则已成功，因此我们有边界条件 $p_{s^{\\star}} = 1$。对于任意非目标位点 $i \\neq s^{\\star}$，我们可以基于第一步的结果写出关于 $p_i$ 的主方程。离开位点 $i$ 的总速率为 $\\lambda_i$。\n- 对于内部位点 $i \\in \\{1, \\dots, L-2\\}$，$\\lambda_i = k+k+k_{\\mathrm{off}} = 2k+k_{\\mathrm{off}}$。\n- 对于边界位点 $i \\in \\{0, L-1\\}$，$\\lambda_i = k+k_{\\mathrm{off}}$。\n\n对第一步移动进行条件化，$p_i$ 是从后续位点出发的成功概率的加权平均值：\n$p_i = \\sum_{j} \\frac{k_{i \\to j}}{\\lambda_i} p_j$。\n向解离态的跃迁其成功概率为 $0$。\n\n对于内部位点 $i \\in \\{1, \\dots, L-2\\}$ （其中 $i \\neq s^{\\star}$）：\n$$ (2k+k_{\\mathrm{off}})p_i = k p_{i-1} + k p_{i+1} $$\n对于 $i=0$ 处的边界（如果 $0 \\neq s^{\\star}$）：\n$$ (k+k_{\\mathrm{off}})p_0 = k p_1 $$\n对于 $i=L-1$ 处的边界（如果 $L-1 \\neq s^{\\star}$）：\n$$ (k+k_{\\mathrm{off}})p_{L-1} = k p_{L-2} $$\n\n这些关系为 $L-1$ 个未知概率 $\\{p_i\\}_{i \\in \\mathcal{S} \\setminus \\{s^{\\star}\\}}$ 构成了一个包含 $L-1$ 个方程的线性方程组。该系统可以写成矩阵形式 $A\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p}$ 是未知概率向量。矩阵 $A$ 是三对角的，向量 $\\mathbf{b}$ 包含由向已知状态 $p_{s^\\star}=1$ 的跃迁产生的项。一个特殊情况是当 $k_{\\mathrm{off}}=0$ 时；在这种情况下，解离不可能发生，因此粒子最终必须找到目标，从而得到对所有 $i$ 均有 $p_i = 1$。\n\n**2. 条件平均搜索时间 $m(i)$**\n\n令 $m_i$ 为从 $i$ 开始，在搜索成功的条件下，到达 $s^{\\star}$ 的条件平均时间。根据定义，$m_{s^{\\star}}=0$。为了进行严格推导，方便起见，我们首先求解未归一化的条件平均时间 $M_i = p_i m_i$。该量遵循一组类似的线性方程，但带有一个与各处位点的平均驻留时间相关的非齐次源项。\n\n对于任意位点 $i \\neq s^{\\star}$，$M_i$ 的控制方程为：\n$$ \\lambda_i M_i = p_i + \\sum_{j \\text{ (邻居)}} k_{i \\to j} M_j $$\n这个方程表明，一个状态流出的“成功时间”通量等于停留在该状态的贡献（平均驻留时间 $1/\\lambda_i$，由成功概率 $p_i$ 加权）加上从相邻状态流入的成功时间通量。\n\n对于内部位点 $i \\in \\{1, \\dots, L-2\\}$（其中 $i \\neq s^{\\star}$）：\n$$ (2k+k_{\\mathrm{off}})M_i = p_i + k M_{i-1} + k M_{i+1} \\implies k M_{i-1} - (2k+k_{\\mathrm{off}})M_i + k M_{i+1} = -p_i $$\n对于 $i=0$ 处的边界（如果 $0 \\neq s^{\\star}$）：\n$$ (k+k_{\\mathrm{off}})M_0 = p_0 + k M_1 \\implies -(k+k_{\\mathrm{off}})M_0 + k M_1 = -p_0 $$\n对于 $i=L-1$ 处的边界（如果 $L-1 \\neq s^{\\star}$）：\n$$ (k+k_{\\mathrm{off}})M_{L-1} = p_{L-1} + k M_{L-2} \\implies k M_{L-2} - (k+k_{\\mathrm{off}})M_{L-1} = -p_{L-1} $$\n\n这是一个关于未知数 $\\{M_i\\}_{i \\in \\mathcal{S} \\setminus \\{s^{\\star}\\}}$ 的 $L-1$ 个线性方程组。关键是，其左侧的系数矩阵与概率计算中的矩阵 $A$ 相同。右侧向量现在就是解向量 $\\mathbf{p}$ 的负值（对于相应的未知位点）。边界条件是 $M_{s^{\\star}} = p_{s^{\\star}}m_{s^{\\star}} = 1 \\cdot 0 = 0$。\n\n**算法**\n$(p(i_0), m(i_0))$ 的解通过以下步骤找到：\n1.  对于给定的测试用例 $(L, s^{\\star}, i_{0}, k, k_{\\mathrm{off}})$，检查是否满足平凡的起始条件 $i_{0} = s^{\\star}$。如果满足，结果为 $(1.0, 0.0)$。\n2.  如果 $k_{\\mathrm{off}} = 0$，将所有 $p_i$ 设为 1。否则，为概率 $\\{p_i\\}_{i \\neq s^{\\star}}$ 构建 $(L-1) \\times (L-1)$ 矩阵 $A$ 和右侧向量 $\\mathbf{b}_p$。求解线性系统 $A\\mathbf{p} = \\mathbf{b}_p$。\n3.  使用计算出的未知位点的概率，构建右侧向量 $\\mathbf{b}_M = -\\mathbf{p}$。\n4.  求解线性系统 $A\\mathbf{M} = \\mathbf{b}_M$ 以得到未归一化时间 $\\{M_i\\}_{i \\neq s^{\\star}}$。矩阵 $A$ 与步骤2中的相同。\n5.  对于指定的起始位点 $i_{0}$，计算条件平均搜索时间 $m(i_{0}) = M_{i_0} / p(i_{0})$。如果 $p(i_0)=0$，根据定义 $m(i_0)=0$。\n6.  返回数对 $(p(i_{0}), m(i_{0}))$。\n\n将对每个测试用例实施此过程。", "answer": "```python\nimport numpy as np\n\ndef _calculate_pair(L, s_star, i0, k, k_off):\n    \"\"\"\n    Calculates the success probability and conditional mean search time for a given\n    set of parameters by solving the corresponding systems of linear equations.\n\n    Args:\n        L (int): The number of sites on the DNA lattice, {0, 1, ..., L-1}.\n        s_star (int): The index of the target site.\n        i0 (int): The index of the starting site.\n        k (float): The symmetric hopping rate (k_l = k_r = k).\n        k_off (float): The dissociation rate.\n\n    Returns:\n        tuple[float, float]: A pair (p(i0), m(i0)) containing the success probability\n                             and the conditional mean search time.\n    \"\"\"\n    # Trivial case: starting at the target site.\n    if i0 == s_star:\n        return 1.0, 0.0\n\n    # Define the set of sites with unknown probabilities and times.\n    unknown_sites = [i for i in range(L) if i != s_star]\n    site_to_idx = {site: i for i, site in enumerate(unknown_sites)}\n    N = len(unknown_sites)\n\n    # =========================================================================\n    # Step 1: Solve for success probabilities p_i\n    # =========================================================================\n    p_vec_full = np.zeros(L)\n    \n    # Case with no dissociation: success is guaranteed.\n    if k_off == 0:\n        p_vec_full.fill(1.0)\n    else:\n        # Construct the linear system A*p = b for p_i where i != s_star.\n        A = np.zeros((N, N))\n        b = np.zeros(N)\n\n        for i in unknown_sites:\n            j = site_to_idx[i]\n            \n            # The diagonal element is the negative total rate of leaving site i.\n            rate_out = k_off\n            if i > 0: rate_out += k\n            if i < L - 1: rate_out += k\n            A[j, j] = -rate_out\n\n            # Off-diagonal elements represent transitions from neighbors.\n            # If a neighbor is the target, its contribution (k*p_s_star) goes to the RHS.\n            if i > 0:\n                pred = i - 1\n                if pred == s_star:\n                    b[j] -= k\n                else:\n                    A[j, site_to_idx[pred]] = k\n            \n            if i < L - 1:\n                succ = i + 1\n                if succ == s_star:\n                    b[j] -= k\n                else:\n                    A[j, site_to_idx[succ]] = k\n\n        p_sol = np.linalg.solve(A, b)\n\n        # Populate the full probability vector.\n        p_vec_full[s_star] = 1.0\n        for i, val in zip(unknown_sites, p_sol):\n            p_vec_full[i] = val\n    \n    p_i0 = p_vec_full[i0]\n    # If success is impossible, mean time is 0 by definition.\n    if p_i0 == 0:\n        return 0.0, 0.0\n\n    # =========================================================================\n    # Step 2: Solve for unnormalized mean times M_i = p_i * m_i\n    # =========================================================================\n    # The matrix A is identical to the one for probabilities.\n    # Re-construct it if it wasn't built (for k_off=0 case).\n    if k_off > 0:\n        pass  # A is already built\n    else:\n        A = np.zeros((N, N))\n        for i in unknown_sites:\n            j = site_to_idx[i]\n            rate_out = 0.0\n            if i > 0: rate_out += k\n            if i < L - 1: rate_out += k\n            A[j, j] = -rate_out\n            if i > 0 and (i - 1) != s_star: A[j, site_to_idx[i-1]] = k\n            if i < L - 1 and (i + 1) != s_star: A[j, site_to_idx[i+1]] = k\n\n    # The RHS is -p_i for each unknown site.\n    p_unknowns = np.array([p_vec_full[i] for i in unknown_sites])\n    b_M = -p_unknowns\n\n    M_sol = np.linalg.solve(A, b_M)\n\n    M_vec_full = np.zeros(L)\n    # M_s_star = 0 by definition.\n    for i, val in zip(unknown_sites, M_sol):\n        M_vec_full[i] = val\n\n    # =========================================================================\n    # Step 3: Calculate conditional mean times m_i = M_i / p_i\n    # =========================================================================\n    m_i0 = M_vec_full[i0] / p_i0\n    \n    return p_i0, m_i0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: (L, s_star, i0, k, k_off)\n        (21, 10, 0, 100.0, 1.0),\n        # Case B\n        (21, 10, 10, 100.0, 1.0),\n        # Case C\n        (21, 20, 0, 50.0, 50.0),\n        # Case D\n        (2, 1, 0, 2.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, s_star, i0, k, k_off = case\n        p, m = _calculate_pair(L, s_star, i0, k, k_off)\n        results.extend([p, m])\n\n    # Format output as a list of strings rounded to 6 decimal places.\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"}, {"introduction": "转录一旦启动，聚合酶的行进过程本身也可能成为限速步骤。本练习将运用排队论这一强大的数学工具，来模拟高活性基因上 RNA 聚合酶的“交通流”。通过分析这个系统，你将能够预测转录“交通拥堵”发生的可能性，这有助于我们理解在高表达需求下细胞如何管理和优化转录过程。[@problem_id:2436273]", "id": "2436273", "problem": "一个高度活跃的真核基因表现出启动子近端暂停与清除现象，这为核糖核酸（RNA）聚合酶II制造了一个瓶颈。将启动子近端区域建模为一个单服务通道，该通道一次只允许一个聚合酶进入生产性延伸阶段，并基于以下假设将转录动力学与经典排队模型联系起来。聚合酶的起始尝试构成一个泊松过程，其速率为$\\lambda$（每分钟到达次数）。一个已结合的聚合酶的启动子近端清除时间服从指数分布，其速率为$\\mu$（每分钟服务次数）。当启动子近端位点被占据时，到达的聚合酶会沿着启动子近端区域排成一个先进先出的队列；此启动子近端系统中的聚合酶数量（包括正在清除的一个和所有等待的）被建模为一个时齐连续时间马尔可夫链，对于所有状态$n \\ge 1$，其出生率恒为$\\lambda$，死亡率恒为$\\mu$。假设系统在稳态下运行，且$\\lambda < \\mu$。\n\n将“交通拥堵”定义为在随机选择的时刻，启动子近端系统（包括正在清除的一个）中至少有$k$个聚合酶的事件。从生灭过程的基本定义以及此类系统的稳态（细致）平衡出发，推导交通拥堵稳态概率的解析表达式，该表达式应是$\\lambda$、$\\mu$和$k$的函数。然后，使用符合生物学实际的参数$\\lambda = 3.5$ min$^{-1}$、$\\mu = 4.0$ min$^{-1}$和$k = 6$来评估此表达式。将你的最终答案表示为一个无单位的小数，并四舍五入到四位有效数字。", "solution": "在尝试任何解答之前，对所提出的问题进行严格验证。\n\n逐字提取已知条件：\n1.  该系统是一个代表真核基因启动子近端区域的单服务通道。\n2.  聚合酶的起始尝试是一个速率为$\\lambda$的泊松过程。\n3.  启动子近端清除时间服从速率为$\\mu$的指数分布。\n4.  当位点被占据时，形成一个先进先出的队列。\n5.  该系统被建模为一个时齐连续时间马尔可夫链。\n6.  对于所有状态，出生率恒为$\\lambda$。\n7.  对于所有状态$n \\ge 1$，死亡率恒为$\\mu$。\n8.  系统处于稳态。\n9.  满足稳定性条件$\\lambda < \\mu$。\n10. “交通拥堵”被定义为系统中至少有$k$个聚合酶的事件。\n11. 任务是推导交通拥堵稳态概率关于$\\lambda$、$\\mu$和$k$的函数。\n12. 任务包括使用特定参数评估该表达式：$\\lambda = 3.5$ min$^{-1}$、$\\mu = 4.0$ min$^{-1}$和$k = 6$。最终数值答案必须四舍五入到四位有效数字。\n\n验证结论：\n问题是有效的。它描述了一个经典的M/M/1排队模型，这是统计物理学和计算生物学中用于建模随机过程的标准且有科学依据的工具。问题是适定的，因为已明确给出唯一稳态的条件（$\\lambda < \\mu$）。所有术语都得到了精确的数学定义，设定是自洽且一致的，并且提供了所需的参数。不存在科学或逻辑上的缺陷。我们可以继续进行解答。\n\n所描述的系统是一个在状态空间$S = \\{0, 1, 2, \\dots\\}$上的生灭过程，其中状态$n$表示启动子近端系统（正在清除或等待）中RNA聚合酶II分子的数量。出生率$\\lambda_n$（到达）和死亡率$\\mu_n$（服务）由下式给出：\n$$ \\lambda_n = \\lambda \\quad \\text{for } n = 0, 1, 2, \\dots $$\n$$ \\mu_n = \\mu \\quad \\text{for } n = 1, 2, 3, \\dots $$\n且$\\mu_0 = 0$。\n\n在稳态下，进入任何状态$n$的转换速率必须等于离开状态$n$的转换速率。生灭过程的这一细致平衡原理产生以下方程组，其中$P_n$是处于状态$n$的稳态概率：\n$$ \\lambda_{n-1} P_{n-1} = \\mu_n P_n \\quad \\text{for } n \\ge 1 $$\n代入给定的速率：\n$$ \\lambda P_{n-1} = \\mu P_n \\quad \\text{for } n \\ge 1 $$\n我们可以写出$P_n$的递推关系：\n$$ P_n = \\left(\\frac{\\lambda}{\\mu}\\right) P_{n-1} $$\n我们定义交通强度$\\rho = \\frac{\\lambda}{\\mu}$。问题陈述$\\lambda < \\mu$，这确保了$\\rho < 1$。递推关系变为：\n$$ P_n = \\rho P_{n-1} $$\n通过重复应用，我们可以将每个$P_n$用$P_0$（系统为空的概率）表示：\n$$ P_1 = \\rho P_0 $$\n$$ P_2 = \\rho P_1 = \\rho^2 P_0 $$\n...\n$$ P_n = \\rho^n P_0 $$\n为了确定$P_0$，我们使用归一化条件，即所有概率之和必须等于1：\n$$ \\sum_{n=0}^{\\infty} P_n = 1 $$\n$$ \\sum_{n=0}^{\\infty} \\rho^n P_0 = P_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\n该求和是一个几何级数。由于$\\rho < 1$，级数收敛：\n$$ \\sum_{n=0}^{\\infty} \\rho^n = \\frac{1}{1-\\rho} $$\n将此结果代回归一化方程，得到：\n$$ P_0 \\left( \\frac{1}{1-\\rho} \\right) = 1 \\implies P_0 = 1-\\rho $$\n因此，系统中聚合酶数量的稳态概率分布是一个几何分布：\n$$ P_n = (1-\\rho) \\rho^n \\quad \\text{for } n \\ge 0 $$\n“交通拥堵”被定义为系统中至少有$k$个聚合酶的事件。该事件的概率，我们记为$P_{jam}$，是所有从$k$到无穷大的状态的概率之和：\n$$ P_{jam} = P(N \\ge k) = \\sum_{n=k}^{\\infty} P_n $$\n使用互补法则可以更高效地计算此概率：\n$$ P(N \\ge k) = 1 - P(N < k) = 1 - \\sum_{n=0}^{k-1} P_n $$\n$$ P(N \\ge k) = 1 - \\sum_{n=0}^{k-1} (1-\\rho) \\rho^n = 1 - (1-\\rho) \\sum_{n=0}^{k-1} \\rho^n $$\n项$\\sum_{n=0}^{k-1} \\rho^n$是一个有限几何级数，其和为$\\frac{1-\\rho^k}{1-\\rho}$。代入此式，我们得到：\n$$ P(N \\ge k) = 1 - (1-\\rho) \\left( \\frac{1-\\rho^k}{1-\\rho} \\right) = 1 - (1-\\rho^k) = \\rho^k $$\n因此，交通拥堵概率的解析表达式就是$\\rho^k$。\n$$ P_{jam}(\\lambda, \\mu, k) = \\left(\\frac{\\lambda}{\\mu}\\right)^k $$\n这是要求推导的第一部分。现在，我们必须用给定的参数来评估此表达式：$\\lambda = 3.5$ min$^{-1}$、$\\mu = 4.0$ min$^{-1}$和$k = 6$。\n首先，计算交通强度$\\rho$：\n$$ \\rho = \\frac{\\lambda}{\\mu} = \\frac{3.5}{4.0} = \\frac{7}{8} = 0.875 $$\n接下来，计算交通拥堵的概率，$P(N \\ge 6)$：\n$$ P(N \\ge 6) = \\rho^k = (0.875)^6 $$\n数值计算得出：\n$$ (0.875)^6 = 0.4487955322265625 $$\n问题要求将此结果四舍五入到四位有效数字。前四位有效数字是4、4、8、7。第五位是9，大于或等于5，所以我们将第四位数字向上取整。\n$$ P(N \\ge 6) \\approx 0.4488 $$", "answer": "$$\\boxed{0.4488}$$"}]}