{"hands_on_practices": [{"introduction": "预测单个“最佳”的RNA二级结构只是理解其功能的起点。在生物体内，RNA分子实际上以多种结构共存的动态系综形式存在。本练习将挑战您超越寻找最小自由能（MFE）结构，通过量化能量景观的“挫折度”——即计算在能量阈值$\\Delta$内，与最优能量$E_{\\min}$相近的竞争性亚优结构的数量——来加深理解[@problem_id:2427180]。这项动手实践对于理解RNA的动态本质，以及体会动态规划算法在探索广阔构象空间时的强大能力，具有不可估量的价值。", "problem": "您将实现一个程序，该程序在一个简化但符合科学标准的模型下，通过计算竞争性的、近乎最优的二级结构的数量，来量化核糖核酸（RNA）折叠景观的“挫败度”。目标是从第一性原理出发，推导出一个精确的算法，并针对一组给定的RNA序列和能量阈值，计算有多少亚优二级结构在能量上接近最低自由能（MFE）结构。\n\n定义和建模假设：\n- RNA序列是一个由字母表 $\\{ \\mathrm{A}, \\mathrm{U}, \\mathrm{G}, \\mathrm{C} \\}$ 中的字符组成的字符串。\n- 二级结构是一组非交叉的碱基对 $(i,j)$（其中 $i < j$）的集合，每个核苷酸最多属于一个碱基对，并且不存在假结（即，不存在满足 $i < k < j < \\ell$ 的两个碱基对 $(i,j)$ 和 $(k,\\ell)$）。\n- 允许的碱基对及其能量（单位：千卡/摩尔）如下：\n  - $\\mathrm{G}$–$\\mathrm{C}$ 或 $\\mathrm{C}$–$\\mathrm{G}$：能量 $-3$，\n  - $\\mathrm{A}$–$\\mathrm{U}$ 或 $\\mathrm{U}$–$\\mathrm{A}$：能量 $-2$，\n  - $\\mathrm{G}$–$\\mathrm{U}$ 或 $\\mathrm{U}$–$\\mathrm{G}$：能量 $-1$。\n  未配对的核苷酸贡献的能量为 $0$。\n- 发夹环最小长度约束：仅当 $j - i - 1 \\geq 3$ 时，碱基对 $(i,j)$ 才被允许。\n- 一个二级结构 $s$ 的总自由能是其所有碱基对能量的总和，记为 $E(s)$，单位为 $\\mathrm{kcal/mol}$。\n- 最低自由能（MFE）是在一个给定序列的所有有效二级结构 $s$ 上的 $E_{\\min} = \\min_{s} E(s)$。\n- 对于一个非负阈值 $\\Delta$（单位为 $\\mathrm{kcal/mol}$），将挫败计数定义为\n  $$F(\\Delta) = \\left| \\left\\{ s \\ \\big| \\ E_{\\min} < E(s) \\leq E_{\\min} + \\Delta \\right\\} \\right|,$$\n  即，能量严格大于 MFE 但与 MFE 的差距在 $\\Delta$ 之内的不同近优结构的数量。不同的结构由不同的碱基对集合定义。\n\n您的任务：\n- 仅使用上述定义，设计一个算法，该算法：\n  - 在给定约束下，计算序列的 $E_{\\min}$。\n  - 枚举所有有效的二级结构（无假结）及其能量。\n  - 为每个测试案例计算 $F(\\Delta)$。\n- 通用性要求：您的算法必须以纯数学和逻辑术语呈现和实现，仅依赖于上述定义和约束，并且其理解不应依赖于任何特定的外部生物学软件包。\n\n单位和数值格式：\n- 能量以 $\\mathrm{kcal/mol}$ 为单位；但是，您的程序的输出是无单位的计数值，每个都是整数。\n- 不使用角度。\n- 不使用百分比。\n\n测试套件：\n为以下每个 $(\\text{序列}, \\Delta)$ 对计算 $F(\\Delta)$：\n- 案例1：序列 \"GCAUCU\", $\\Delta = 1$。\n- 案例2：序列 \"GCAUCU\", $\\Delta = 3$。\n- 案例3：序列 \"AAAAAA\", $\\Delta = 5$。\n- 案例4：序列 \"AUGC\", $\\Delta = 10$。\n- 案例5：序列 \"GGGAAACCC\", $\\Delta = 2$。\n- 案例6：序列 \"GCAUUGC\", $\\Delta = 3$。\n- 案例7：序列 \"GGGCCC\", $\\Delta = 3$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,r6,r7]”），其中每个 $r_k$ 是按指定顺序排列的案例 $k$ 的整数挫败计数 $F(\\Delta)$。", "solution": "该问题要求我们为给定的RNA序列，计算在高于最低自由能（MFE）的指定能量阈值 $\\Delta$ 内的亚优二级结构的数量。这是一个定义在所有有效的无假结二级结构的状态空间上的计数问题。此类问题受非交叉条件的约束，其结构天然适合采用动态规划方法，因为一个序列的折叠可以分解为其子序列上独立的折叠问题。\n\n我们将基于这一原理设计一个算法。该算法的核心是系统地计算给定RNA序列每个可能子序列的能量分布。能量分布不仅仅是一个单一的最小值，而是对所有可能能量以及能够达到每种能量的不同结构数量的完整枚举。我们将此分布表示为一个从能量值 $E$ 到计数值 $c$ 的映射，表示有 $c$ 个不同的结构的总自由能为 $E$。\n\n设RNA序列为 $S$，长度为 $L$，索引从 $0$ 到 $L-1$。我们定义两个动态规划表 $N$ 和 $C$，其中每个条目 $(i,j)$（$0 \\le i \\le j < L$）存储一个能量分布映射。\n\n1.  $N(i,j)$: 此映射存储子序列 $S[i..j]$ 上所有有效二级结构的能量分布。\n2.  $C(i,j)$: 此映射存储在核苷酸 $S[i]$ 和 $S[j]$ 形成碱基对的条件下，子序列 $S[i..j]$ 上所有有效二级结构的能量分布。\n\n通过遍历子序列的长度 $d = j-i$（从 $d=0$ 到 $L-1$）来填充这些表。\n\n**基本情况：**\n- 对于空子序列，存在一种结构（空结构），其能量为 $0$。为了处理我们递推关系中的边界条件，我们定义 $N(i, i-1) = \\{0: 1\\}$。\n- 对于长度为 $1$ 的子序列 $S[i]$，只有一种结构（未配对的核苷酸），其能量为 $0$。因此，$N(i,i) = \\{0: 1\\}$。\n- 更一般地，对于任何太短而无法形成发夹环的子序列 $S[i..j]$（即 $j-i-1 < 3$），唯一可能的结构是没有任何碱基对的结构，其能量为 $0$。因此，对于 $d = j-i < 4$，$N(i,j) = \\{0: 1\\}$ 且 $C(i,j)$ 是一个空映射。\n\n**递推关系：**\n对于长度为 $d+1$ 的子序列 $S[i..j]$，其中 $d = j-i$：\n\n首先，我们计算 $C(i,j)$。只有在允许的情况下，才能在 $S[i..j]$ 上形成 $S[i]$ 与 $S[j]$ 配对的结构。令 $e(S[i], S[j])$ 为该碱基对的能量。该能量仅对规范配对（G-C, A-U, G-U）不为零。发夹环约束要求 $j - i - 1 \\ge 3$。如果满足这些条件，总能量是 $e(S[i], S[j])$ 与内部子序列 $S[i+1..j-1]$ 上任何有效结构的能量之和。因此，$C(i,j)$ 的分布是将 $N(i+1, j-1)$ 的分布中每个能量值都增加 $e(S[i], S[j])$ 得到的。\n$$C(i,j)[E + e(S[i],S[j])] = N(i+1, j-1)[E]$$\n对于分布 $N(i+1, j-1)$ 中的所有能量 $E$。如果不允许碱基对 $(i,j)$，$C(i,j)$ 为空。\n\n接着，我们计算 $N(i,j)$。我们考虑核苷酸 $S[j]$ 的所有可能性。\n1.  **$S[j]$ 未配对：** $S[i..j]$ 的结构集合与 $S[i..j-1]$ 的结构集合相同。因此，我们用 $N(i, j-1)$ 来初始化 $N(i,j)$ 的分布。\n2.  **$S[j]$ 与某个 $i \\le k < j$ 的 $S[k]$ 配对：** 非交叉约束意味着这种结构可以分解为两个独立的部分：外部子序列 $S[i..k-1]$ 上的结构，以及子序列 $S[k..j]$ 上 $(k,j)$ 必须配对的结构。后者的能量分布由 $C(k,j)$ 给出。对于一个给定的能量，其结构总数是通过这两个独立部分能量分布的卷积得到的。\n总能量 $E$ 是 $E_{left} + E_{bifurcation}$，其中 $E_{left}$ 来自 $S[i..k-1]$ 上的一个结构，而 $E_{bifurcation}$ 来自 $S[k..j]$ 上带有碱基对 $(k,j)$ 的一个结构。形成这种结构的方式数量为 $c_{left} \\times c_{bifurcation}$。\n\n综合这些情况，$N(i,j)$ 的递推关系是：\n$$N(i,j) = N(i,j-1) \\oplus \\bigoplus_{k=i}^{j-4} \\left( N(i,k-1) \\otimes C(k,j) \\right)$$\n此处，$\\oplus$ 表示通过对相同键的计数值求和来合并两个能量分布映射，而 $\\otimes$ 表示两个分布的卷积，对应于所有能量组合的计数值的乘积。为满足发夹环约束 $j-k-1 \\ge 3$，对 $k$ 的求和一直进行到 $j-4$。\n\n**最终计算：**\n填充完直至 $N(0, L-1)$ 的DP表后，我们得到了整个序列的完整能量分布。设其为 $D_{final} = N(0, L-1)$。\n1.  我们找到最低自由能，$E_{\\min} = \\min(\\text{keys}(D_{final}))$。\n2.  然后我们通过对 $D_{final}$ 中所有满足条件 $E_{\\min} < E \\leq E_{\\min} + \\Delta$ 的能量 $E$ 的计数值求和来计算挫败计数 $F(\\Delta)$。\n$$F(\\Delta) = \\sum_{E \\in D_{final}, E_{\\min} < E \\leq E_{\\min} + \\Delta} D_{final}[E]$$\n这个过程完全基于问题陈述中给出的第一性原理，提供了一个精确、可验证的计数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA frustration count problem for a suite of test cases.\n    \"\"\"\n\n    # --- Problem Definition ---\n\n    # Allowed base pairs and their energies\n    energy_map = {\n        'AU': -2, 'UA': -2,\n        'GC': -3, 'CG': -3,\n        'GU': -1, 'UG': -1,\n    }\n\n    # Hairpin minimum loop length constraint\n    MIN_LOOP_LENGTH = 3\n\n    # Test suite\n    test_cases = [\n        (\"GCAUCU\", 1),\n        (\"GCAUCU\", 3),\n        (\"AAAAAA\", 5),\n        (\"AUGC\", 10),\n        (\"GGGAAACCC\", 2),\n        (\"GCAUUGC\", 3),\n        (\"GGGCCC\", 3),\n    ]\n\n    # --- Algorithm Implementation ---\n    \n    def get_pair_energy(b1, b2):\n        \"\"\"Returns the energy of a base pair.\"\"\"\n        return energy_map.get(b1 + b2, 0)\n\n    def add_distributions(dist1, dist2):\n        \"\"\"Merges two energy distributions.\"\"\"\n        res = dist1.copy()\n        for e, c in dist2.items():\n            res[e] = res.get(e, 0) + c\n        return res\n\n    def convolve_distributions(dist1, dist2):\n        \"\"\"Computes the convolution of two energy distributions.\"\"\"\n        res = {}\n        if not dist1 or not dist2:\n            return res\n        for e1, c1 in dist1.items():\n            for e2, c2 in dist2.items():\n                new_e = e1 + e2\n                new_c = c1 * c2\n                res[new_e] = res.get(new_e, 0) + new_c\n        return res\n\n    def compute_frustration(sequence, delta):\n        \"\"\"\n        Computes the frustration count F(Delta) for a given RNA sequence.\n        \"\"\"\n        n = len(sequence)\n        \n        # N[i][j]: energy distribution for all structures on subsequence S[i..j]\n        # C[i][j]: energy distribution for structures on S[i..j] with (i,j) paired\n        N = [[{} for _ in range(n)] for _ in range(n)]\n        C = [[{} for _ in range(n)] for _ in range(n)]\n\n        # Base case for empty subsequence (N[i][i-1]) used in recurrence\n        N_pre = {0: 1}\n\n        # Initialize for subsequences of length 1\n        for i in range(n):\n            N[i][i] = {0: 1}\n\n        # Fill DP tables by increasing subsequence length d = j - i\n        for d in range(1, n):\n            for i in range(n - d):\n                j = i + d\n\n                # Compute C[i][j]\n                if d > MIN_LOOP_LENGTH:\n                    pair_energy = get_pair_energy(sequence[i], sequence[j])\n                    if pair_energy < 0:\n                        internal_dist = N[i + 1][j - 1]\n                        C[i][j] = {e + pair_energy: c for e, c in internal_dist.items()}\n                \n                # Compute N[i][j]\n                # Case 1: j is unpaired\n                dist_N = N[i][j - 1].copy()\n\n                # Case 2: j is paired with k\n                # k must be such that j-k-1 >= MIN_LOOP_LENGTH  => k <= j - MIN_LOOP_LENGTH - 1\n                for k in range(i, j - MIN_LOOP_LENGTH):\n                    dist_bifurcation = C[k][j]\n                    if not dist_bifurcation:\n                        continue\n                    \n                    dist_left = N[i][k - 1] if k > i else N_pre\n                    \n                    # Convolve left and bifurcation distributions\n                    convolution_result = convolve_distributions(dist_left, dist_bifurcation)\n                    dist_N = add_distributions(dist_N, convolution_result)\n                \n                N[i][j] = dist_N\n\n        final_distribution = N[0][n - 1]\n        \n        if not final_distribution:\n            return 0\n\n        # Calculate E_min and the frustration count F(Delta)\n        e_min = min(final_distribution.keys())\n        frustration_count = 0\n        for energy, count in final_distribution.items():\n            if e_min < energy <= e_min + delta:\n                frustration_count += count\n        \n        return frustration_count\n\n    results = []\n    for seq, delta_val in test_cases:\n        result = compute_frustration(seq, delta_val)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2427180"}, {"introduction": "在掌握了单序列折叠的基本原理之后，我们自然会想知道如何推断更复杂的RNA三级结构，这对于其功能至关重要。本练习将介绍一种强大的现代计算方法：利用多序列比对（MSA）中的协同进化信号来预测三级结构接触点[@problem_id:2427140]。通过亲手实现一个基于信息论（如互信息$I(X;Y)$）的算法，您将学习到如何从进化历史的“指纹”中解读出分子内部的直接物理相互作用。", "problem": "您的任务是利用从多重序列比对（MSA）中计算出的协同进化信号，来预测核糖核酸（RNA）中的三级接触点。目标是设计并实现一个程序，从第一性原理出发，使用信息论量构建成对协同进化分数，然后应用偏差校正以更好地分离直接的位置耦合。最终的预测结果将与一组提供的真实接触点（ground-truth）进行评估。您的方法必须源自以下基本原理和核心定义，并且在您的推理过程中不得使用任何未从这些基础推导出的快捷公式：分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）、Shannon熵的定义以及互信息的定义。\n\n所需的基本定义如下。对于一个在有限字母表上具有概率质量函数 $p(x)$ 的离散随机变量 $X$，Shannon熵定义为\n$$\nH(X) = - \\sum_{x} p(x) \\log p(x),\n$$\n其中 $\\log$ 表示以 $e$ 为底的自然对数。对于一对具有联合概率质量函数 $p(x,y)$ 和边际概率 $p(x)$ 和 $p(y)$ 的离散随机变量 $(X,Y)$，互信息是\n$$\nI(X;Y) = \\sum_{x}\\sum_{y} p(x,y)\\,\\log\\frac{p(x,y)}{p(x)\\,p(y)}.\n$$\n您必须使用这些定义作为构建算法的基本基础。\n\n您需要以符合原理的方式实现以下概念性步骤。\n- 从MSA中，将每个比对列视为一个在字母表 $\\{\\texttt{A}, \\texttt{C}, \\texttt{G}, \\texttt{U}, \\texttt{-}\\}$ 上的离散随机变量，字母表大小为 $q=5$，其中 $\\texttt{-}$ 表示一个空位（gap）。设该比对包含 $N$ 条等长为 $L$ 的序列。\n- 对于每个位置对 $(i,j)$（其中 $1 \\le i < j \\le L$），使用基于计数的频率估计方法，并结合狄利克雷（加性）伪计数先验来估计联合分布 $p_{ij}(x,y)$。具体来说，通过为每个配对状态 $(x,y)$ 添加一个伪计数 $\\alpha$ 来实现拉普拉斯平滑，然后进行归一化以获得有效的联合概率分布。让相应的边际概率分别通过将联合概率对 $y$ 或 $x$ 求和来计算。在所有计算中，使用以 $e$ 为底的自然对数。\n- 使用上述互信息 $I$ 的基本定义，为每一对 $(i,j)$ 计算初始的协同进化分数。\n- 在进行三级接触预测之前，推导并应用一种校正方法，该方法移除每个位置的平均背景偏差，以更好地近似直接耦合。该校正必须从以下原理推导得出：减去一个由每位置均值和成对分数矩阵的全局均值构建的可分离的平均偏差分量，以减少由整体位置变异性和有限样本效应引入的伪相关。您的推导不能依赖任何快捷公式；相反，您必须根据所述原理来证明您最终实现的校正形式的合理性。\n- 通过仅考虑序列间隔至少为 $s$ 的配对，即满足 $|i-j|\\ge s$ 的配对，来排除平凡的局部邻居。\n- 对每个测试用例，按校正后的分数对符合条件的位点对进行降序排序。若分数相同，则按 $(i,j)$（其中 $i<j$）的字典序升序确定性地排序。\n- 对每个测试用例，报告前 $k$ 个预测的精确率（precision at top-$k$），其定义为排名前 $k$ 的配对中正确预测的接触点数量除以 $k$。以小数形式报告（而非百分比）。\n\n所有答案均无单位。不涉及角度。每个分数都应以小数表示。使用 $s=3$，$k=2$，以及伪计数 $\\alpha=0.5$。\n\n测试套件。您的程序必须处理以下三个测试用例。每个测试用例都是一个独立的MSA，拥有其自己的真实接触点集。位置从1开始索引。对于所有测试用例，字母表固定为 $\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{U},\\texttt{-}\\}$。对每个用例，根据上述规范计算前 $k$ 个预测的精确率。\n\n- 测试用例A（正常路径；清晰的协同进化信号）。设 $L=10$。MSA由 $N=12$ 条序列组成：\n  - \"AACGUCCGUA\"\n  - \"UCGCGAGUGU\"\n  - \"GGAUAUAACC\"\n  - \"CUUGCGCCAG\"\n  - \"ACUCUUGGGA\"\n  - \"UAGGCCCUUU\"\n  - \"GGCUUAACCG\"\n  - \"CUACAGGAGC\"\n  - \"AAUUCCAUUU\"\n  - \"UCCGGUCCGA\"\n  - \"GGGCUAGACG\"\n  - \"CUUUAGAGAC\"\n  真实三级接触点是无序对 $\\{(2,9),(4,7)\\}$。评估所有满足 $|i-j|\\ge s$ 的配对。\n\n- 测试用例B（边界情况；无信号）。设 $L=8$。MSA由 $N=6$ 条相同的序列组成：\n  - \"ACGUACGU\"\n  - \"ACGUACGU\"\n  - \"ACGUACGU\"\n  - \"ACGUACGU\"\n  - \"ACGUACGU\"\n  - \"ACGUACGU\"\n  真实接触点集为空，即 $\\{\\}$。评估所有满足 $|i-j|\\ge s$ 的配对。\n\n- 测试用例C（边缘情况；空位与一个真实的远距离接触点协同变化）。设 $L=8$。MSA由 $N=10$ 条序列组成：\n  - \"ACGUACGU\"\n  - \"CGUAGUCG\"\n  - \"GUACCAUC\"\n  - \"UACGUGAA\"\n  - \"-CGUACG-\"\n  - \"-GUAGUC-\"\n  - \"AUCGAUGU\"\n  - \"CAGUGACG\"\n  - \"GCUACGUC\"\n  - \"UGACUCAA\"\n  真实三级接触点是 $\\{(1,8)\\}$。评估所有满足 $|i-j|\\ge s$ 的配对。\n\n最终输出格式。您的程序应生成单行输出，其中包含测试用例 A、B 和 C 的三个精确率值，以逗号分隔的列表形式并用方括号括起来。每个值应四舍五入到恰好三位小数。例如，一个可接受的输出格式是 \"[0.500,1.000,0.000]\"。", "solution": "该问题要求开发一种计算方法，从多重序列比对（MSA）中预测RNA分子的三级接触点。该方法需要从信息论的第一性原理构建，并且必须包含一个有原则的偏差校正。问题陈述的有效性得到确认，因为它在科学上基于生物信息学和信息论的既定概念，问题设定良好，所有必要的参数和数据都已指定，并且以客观、正式的语言表述。因此，该问题是有效的，将按如下方式构建解决方案。\n\n该方法的核心是量化MSA中残基位置对之间的协同进化。两个位置之间强烈的协同进化信号表明，它们可能处于一种补偿性进化压力之下，以维持结构或功能上的相互作用，例如三级接触。\n\n设给定的 MSA 包含 $N$ 条序列，每条长度为 $L$。残基字母表为 $\\mathcal{A} = \\{\\texttt{A}, \\texttt{C}, \\texttt{G}, \\texttt{U}, \\texttt{-}\\}$，大小为 $q=5$。MSA的每一列 $i$（其中 $i \\in \\{1, \\dots, L\\}$）可以被建模为一个从 $\\mathcal{A}$ 中取值的离散随机变量 $X_i$。\n\n步骤1：概率分布的估计\n\n为了量化协同进化，我们首先需要估计单个位置和位置对的概率分布。对于任何一对列 $(i,j)$（其中 $1 \\le i < j \\le L$），我们为所有 $x, y \\in \\mathcal{A}$ 估计其联合概率质量函数 $p_{ij}(x,y) = P(X_i=x, X_j=y)$。\n\n从 $N$ 条序列的有限样本中稳健地估计这些概率至关重要。我们使用带有加性伪计数的频率计数法，这是一种对应于狄利克雷先验的贝叶斯估计技术。这种方法，通常称为拉普拉斯平滑，可以防止未观察到的状态出现零概率，从而避免在对数计算中产生问题。\n\n设 $f_{ij}(x,y)$ 是在 MSA 的第 $i$ 列和第 $j$ 列中观察到的残基对 $(x,y)$ 的频率计数。我们为 $q^2$ 个可能的配对状态中的每一个添加一个伪计数 $\\alpha > 0$。估计的联合概率则为：\n$$\np_{ij}(x,y) = \\frac{f_{ij}(x,y) + \\alpha}{N + q^2 \\alpha}\n$$\n分母 $N + q^2 \\alpha$ 是归一化常数，它是所有原始计数（$N$）与所有伪计数之和（$q^2 \\alpha$）的总和。\n\n从联合概率分布 $p_{ij}(x,y)$，我们通过求和推导出边际概率分布 $p_i(x)$ 和 $p_j(y)$：\n$$\np_i(x) = \\sum_{y \\in \\mathcal{A}} p_{ij}(x,y) \\quad \\text{和} \\quad p_j(y) = \\sum_{x \\in \\mathcal{A}} p_{ij}(x,y)\n$$\n这些边际概率与联合分布一致，确保了 $\\sum_{x \\in \\mathcal{A}} p_i(x) = 1$ 和 $\\sum_{y \\in \\mathcal{A}} p_j(y) = 1$。\n\n步骤2：互信息作为协同进化分数\n\n来自信息论的互信息（MI）测量两个随机变量之间的统计依赖性。MSA列对 $(i,j)$ 的MI定义为：\n$$\nMI_{ij} = I(X_i; X_j) = \\sum_{x \\in \\mathcal{A}}\\sum_{y \\in \\mathcal{A}} p_{ij}(x,y)\\,\\log\\frac{p_{ij}(x,y)}{p_i(x)\\,p_j(y)}\n$$\n其中对数是自然对数（以 $e$ 为底）。一个高的 $MI_{ij}$ 值表示位置 $i$ 和 $j$ 之间存在强烈的统计耦合。然而，MI容易受到系统发育历史和有限采样效应产生的背景噪声的影响，这可能为并非直接接触的配对产生高分。\n\n步骤3：偏差校正的推导\n\n为了从背景噪声中分离出直接耦合的信号，必须对原始的MI分数进行校正。问题指定要推导一种基于减去可分离的平均偏差分量的校正。我们假设观察到的分数 $MI_{ij}$ 是真实直接耦合信号 $D_{ij}$ 和一个背景偏差项 $B_{ij}$ 的和，该偏差项可近似地分离为来自每个位置的贡献。\n$$\nMI_{ij} = D_{ij} + B_{ij}\n$$\n让我们将偏差项 $B_{ij}$ 建模为位置特定因子的乘积：$B_{ij} \\approx \\beta_i \\beta_j$。我们假设直接耦合信号 $D_{ij}$ 是稀疏的（即，仅对少数对应于真实接触的配对为非零），而背景偏差 $B_{ij}$ 是密集的。在此假设下，位置 $i$ 的平均分数将由偏差贡献主导。\n\n设 $\\overline{MI}_{i\\cdot}$ 表示位置 $i$ 对所有其他位置 $k \\neq i$ 的平均MI分数，而 $\\overline{MI}_{\\cdot\\cdot}$ 是所有配对 $(k,l)$（其中 $k \\neq l$）的全局平均MI分数。\n$$\n\\overline{MI}_{i\\cdot} = \\frac{1}{L-1} \\sum_{k \\neq i} MI_{ik} \\approx \\frac{1}{L-1} \\sum_{k \\neq i} \\beta_i \\beta_k = \\beta_i \\left(\\frac{1}{L-1} \\sum_{k \\neq i} \\beta_k\\right) = \\beta_i \\bar{\\beta}\n$$\n而全局平均值为：\n$$\n\\overline{MI}_{\\cdot\\cdot} = \\frac{1}{L(L-1)} \\sum_{k \\neq l} MI_{kl} \\approx \\frac{1}{L(L-1)} \\sum_{k \\neq l} \\beta_k \\beta_l \\approx \\bar{\\beta}^2\n$$\n从这些近似中，我们可以用可观察的平均值来表示偏差因子 $\\beta_i$：$\\beta_i \\approx \\overline{MI}_{i\\cdot} / \\bar{\\beta}$。将此代入偏差模型 $B_{ij} \\approx \\beta_i \\beta_j$：\n$$\nB_{ij} \\approx \\left(\\frac{\\overline{MI}_{i\\cdot}}{\\bar{\\beta}}\\right) \\left(\\frac{\\overline{MI}_{j\\cdot}}{\\bar{\\beta}}\\right) = \\frac{\\overline{MI}_{i\\cdot}\\overline{MI}_{j\\cdot}}{\\bar{\\beta}^2}\n$$\n使用 $\\bar{\\beta}^2 \\approx \\overline{MI}_{\\cdot\\cdot}$，我们得到偏差项的估计：\n$$\nB_{ij} \\approx \\frac{\\overline{MI}_{i\\cdot}\\overline{MI}_{j\\cdot}}{\\overline{MI}_{\\cdot\\cdot}}\n$$\n校正后的分数，被称为平均乘积校正（Average Product Correction, APC），是通过从原始MI分数中减去此偏差项得到的：\n$$\nAPC_{ij} = MI_{ij} - \\frac{\\overline{MI}_{i\\cdot}\\overline{MI}_{j\\cdot}}{\\overline{MI}_{\\cdot\\cdot}}\n$$\n这种校正有效地折减了那些两个位置都与所有其他位置表现出高平均MI的配对的MI分数，而这正是背景噪声的特征。\n\n步骤4：接触预测与评估\n\n接触预测的最终算法如下：\n1.  对于一个具有 $N$ 条序列和长度为 $L$ 的MSA，为所有配对 $(i,j)$（其中 $1 \\le i < j \\le L$）计算原始的 $MI_{ij}$ 分数。\n2.  从 $MI$ 分数矩阵中，为所有配对计算经过APC校正的分数 $APC_{ij}$。\n3.  筛选配对以仅考虑潜在的三级接触，排除局部邻居。我们只保留满足序列间隔标准 $|i-j| \\ge s$ 的配对，其中 $s=3$。\n4.  根据 $APC_{ij}$ 分数对符合条件的配对进行降序排名。分数相同时通过配对 $(i,j)$ 的字典序来解决。\n5.  从此排名列表中选择前 $k=2$ 个配对作为预测的接触点。\n6.  通过计算前 $k$ 个预测的精确率来评估预测准确性，即前 $k$ 个预测中出现在真实接触点集中的比例。\n$$\n\\text{Precision@k} = \\frac{|\\{\\text{前} k \\text{个预测}\\} \\cap \\{\\text{真实接触点}\\}|}{k}\n$$\n此过程将应用于每个测试用例，使用指定的参数：伪计数 $\\alpha=0.5$，序列间隔阈值 $s=3$，以及评估排名 $k=2$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the RNA contact prediction problem for all test cases.\n    \"\"\"\n\n    # --- Parameter Definition ---\n    s = 3  # Sequence separation threshold\n    k = 2  # Top-k predictions for precision calculation\n    alpha = 0.5  # Pseudocount for probability estimation\n    alphabet = {'A': 0, 'C': 1, 'G': 2, 'U': 3, '-': 4}\n    q = len(alphabet)\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"msa\": [\n                \"AACGUCCGUA\", \"UCGCGAGUGU\", \"GGAUAUAACC\", \"CUUGCGCCAG\",\n                \"ACUCUUGGGA\", \"UAGGCCCUUU\", \"GGCUUAACCG\", \"CUACAGGAGC\",\n                \"AAUUCCAUUU\", \"UCCGGUCCGA\", \"GGGCUAGACG\", \"CUUUAGAGAC\"\n            ],\n            \"contacts\": {(2, 9), (4, 7)}\n        },\n        {\n            \"name\": \"B\",\n            \"msa\": [\n                \"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\",\n                \"ACGUACGU\", \"ACGUACGU\", \"ACGUACGU\"\n            ],\n            \"contacts\": set()\n        },\n        {\n            \"name\": \"C\",\n            \"msa\": [\n                \"ACGUACGU\", \"CGUAGUCG\", \"GUACCAUC\", \"UACGUGAA\",\n                \"-CGUACG-\", \"-GUAGUC-\", \"AUCGAUGU\", \"CAGUGACG\",\n                \"GCUACGUC\", \"UGACUCAA\"\n            ],\n            \"contacts\": {(1, 8)}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        msa = case[\"msa\"]\n        true_contacts = case[\"contacts\"]\n        N = len(msa)\n        L = len(msa[0])\n\n        precision = calculate_precision(msa, true_contacts, L, N, q, alpha, s, k, alphabet)\n        results.append(f\"{precision:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_precision(msa, true_contacts, L, N, q, alpha, s, k, alphabet):\n    \"\"\"\n    Calculates the precision@k for a single test case.\n    \"\"\"\n    # 1. Convert MSA characters to integer representation for numpy\n    msa_int = np.array([[alphabet[res] for res in seq] for seq in msa], dtype=int)\n\n    # 2. Calculate Mutual Information (MI) matrix\n    mi_matrix = np.zeros((L, L))\n    for i in range(L):\n        for j in range(i + 1, L):\n            # 2a. Calculate joint frequency counts\n            freq_ij = np.zeros((q, q), dtype=float)\n            for seq_idx in range(N):\n                res_i = msa_int[seq_idx, i]\n                res_j = msa_int[seq_idx, j]\n                freq_ij[res_i, res_j] += 1\n            \n            # 2b. Estimate joint probability distribution with pseudocount\n            prob_ij = (freq_ij + alpha) / (N + q**2 * alpha)\n\n            # 2c. Estimate marginal probabilities by summing over the joint distribution\n            prob_i = prob_ij.sum(axis=1)\n            prob_j = prob_ij.sum(axis=0)\n\n            # 2d. Calculate Mutual Information\n            # Term p_i(x) * p_j(y) is calculated using an outer product.\n            # Due to alpha > 0, all probabilities are non-zero, avoiding log(0).\n            p_i_p_j = np.outer(prob_i, prob_j)\n            log_ratio = np.log(prob_ij / p_i_p_j)\n            \n            # The mutual information is the expectation of the log-ratio\n            mi = np.sum(prob_ij * log_ratio)\n            mi_matrix[i, j] = mi_matrix[j, i] = mi\n\n    # 3. Apply Average Product Correction (APC)\n    apc_matrix = np.zeros((L, L))\n    if L > 1:\n        # Calculate row/column and global averages.\n        # Note: Diagonal of mi_matrix is zero.\n        # Mean for position i is the sum of row i divided by (L-1).\n        mean_mi_i = mi_matrix.sum(axis=1) / (L - 1)\n        # Global mean is the sum of all elements divided by L*(L-1) off-diagonal pairs.\n        mean_mi_global = mi_matrix.sum() / (L * (L - 1)) if (L * (L - 1)) > 0 else 0\n\n        if mean_mi_global > 1e-9: # Avoid division by zero\n            # Correction term is outer product of position-wise means, normalized by global mean.\n            correction = np.outer(mean_mi_i, mean_mi_i) / mean_mi_global\n            apc_matrix = mi_matrix - correction\n        else: # If no background signal, APC score equals MI score\n            apc_matrix = mi_matrix\n        np.fill_diagonal(apc_matrix, 0)\n\n    # 4. Filter, rank pairs, and get top-k predictions\n    candidate_pairs = []\n    for i in range(L):\n        for j in range(i + 1, L):\n            # Apply sequence separation filter: |i-j| >= s\n            if (j - i) >= s:\n                # Store tuple for sorting: (-score, i, j)\n                # Negating score allows for descending order sort.\n                # (i, j) provides lexicographical tie-breaking.\n                candidate_pairs.append((-apc_matrix[i, j], i, j))\n    \n    candidate_pairs.sort()\n    \n    top_k_predictions = []\n    for idx in range(min(k, len(candidate_pairs))):\n        _, pred_i, pred_j = candidate_pairs[idx]\n        top_k_predictions.append(tuple(sorted((pred_i, pred_j))))\n\n    # 5. Calculate Precision@k\n    # Convert 1-based ground truth contacts to 0-based for comparison\n    true_contacts_0based = set()\n    for c1, c2 in true_contacts:\n        true_contacts_0based.add(tuple(sorted((c1 - 1, c2 - 1))))\n    \n    correct_predictions = 0\n    for pred_pair in top_k_predictions:\n        if pred_pair in true_contacts_0based:\n            correct_predictions += 1\n            \n    precision = correct_predictions / k if k > 0 else 0.0\n    return precision\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2427140"}, {"introduction": "现在，让我们将视角从显式的结构计算转向对生物物理性质的预测建模。RNA双链的稳定性，通常用其熔解温度$T_m$来量化，是一个关键的功能参数。本练习将引导您构建一个机器学习模型，直接从序列组成来预测$T_m$[@problem_id:2427183]。这项实践将展示数据驱动方法如何捕捉复杂的生物物理关系，而无需依赖完整的物理模型，从而将序列的微观特征与宏观可测量的性质联系起来。", "problem": "您将得到由四种核糖核苷酸——腺嘌呤 (A)、尿嘧啶 (U)、鸟嘌呤 (G) 和胞嘧啶 (C)——组成的短核糖核酸 (RNA) 序列。假定在固定的缓冲条件下，每条序列在等链浓度下与其反向互补链形成一个完全互补的双链体，因此熔解温度的任何变化仅源于序列的组成和排列。熔解温度，记为 $T_m$，是在热力学平衡状态下，一半双链体变性时的温度。经过充分检验的生物物理学事实表明，双链体的稳定性源于 Watson–Crick 碱基配对和碱基堆积相互作用，并且鸟嘌呤-胞嘧啶含量和最近邻二核苷酸堆积对稳定性有显著贡献。您的任务是实现一个机器学习回归器，该回归器仅根据序列本身，通过从标记样本中学习来预测 $T_m$。\n\n设计的基本依据：\n- 分子生物学的中心法则指出，遗传信息从脱氧核糖核酸 (DNA) 流向 RNA，再到蛋白质，但在这里我们只关注 RNA 碱基配对形成双链体。\n- RNA 双链体的稳定性由碱基配对和堆积决定；最近邻模型将双链体视为沿链的二核苷酸贡献之和，对于长度为 $L$ 的序列，相邻碱基对的数量为 $L-1$。\n- 较长的双链体和较高的鸟嘌呤-胞嘧啶比例通常更稳定，因此有用的特征必须能编码长度、鸟嘌呤-胞嘧啶含量和最近邻组成，而不预设任何特定的 $T_m$ 目标公式。\n\n您必须：\n- 仅使用序列，将每个序列表示为一个固定长度的实值特征向量。至少包括以下内容：\n  - 一个长度为 $16$ 的向量，对应于集合 $\\{ \\text{AA}, \\text{AU}, \\text{AG}, \\text{AC}, \\text{UA}, \\text{UU}, \\text{UG}, \\text{UC}, \\text{GA}, \\text{GU}, \\text{GG}, \\text{GC}, \\text{CA}, \\text{CU}, \\text{CG}, \\text{CC} \\}$ 中所有二核苷酸的归一化计数，其中每个分量等于该二核苷酸的计数除以 $(L-1)$（如果 $L \\ge 2$），如果 $L < 2$ 则等于 $0$。\n  - 鸟嘌呤-胞嘧啶核苷酸的比例，定义为鸟嘌呤或胞嘧啶核苷酸的数量除以 $L$（当 $L \\ge 1$ 时），如果 $L = 0$ 则为 $0$。\n  - 长度 $L$ 本身作为一个实值特征。\n  - 一个截距项。\n- 对训练数据拟合一个带有平方损失和 $\\ell_2$ 正则化（岭回归）的线性模型，使用闭式正规方程解。不要使用迭代训练或随机元素。\n- 使用生成的模型预测测试集的 $T_m$，将每个预测值四舍五入到小数点后两位。所有温度均以摄氏度表示。\n\n数学和算法要求：\n- 从 $N$ 个训练序列和每个序列的 $d$ 个特征构建一个设计矩阵 $X \\in \\mathbb{R}^{N \\times d}$，以及一个包含给定 $T_m$ 值（单位为摄氏度）的标签向量 $y \\in \\mathbb{R}^{N}$。\n- 使用 $\\ell_2$ 正则化，正则化强度 $\\alpha > 0$，应用于除截距外的所有系数。通过求解正规方程来计算岭回归解：\n$$\n\\left(X^\\top X + \\Lambda\\right) w = X^\\top y,\n$$\n其中 $w \\in \\mathbb{R}^{d}$ 是系数向量（包括截距），$\\Lambda \\in \\mathbb{R}^{d \\times d}$ 是一个对角矩阵，其对角线上的元素对于非截距系数为 $\\alpha$，对于截距系数为 $0$。不允许使用其他拟合程序。\n\n训练数据（序列，$T_m$ 单位为摄氏度）：\n- $\\text{AUAUAU}$, $22.0$\n- $\\text{GCGCGC}$, $54.0$\n- $\\text{AUGCUA}$, $34.0$\n- $\\text{GGGCCC}$, $57.0$\n- $\\text{AAAAAA}$, $18.0$\n- $\\text{CCGGCC}$, $53.0$\n- $\\text{AUGGCAU}$, $39.0$\n- $\\text{GGAUCC}$, $44.0$\n- $\\text{AUGCAUGC}$, $47.0$\n- $\\text{GCAUGCAC}$, $49.0$\n- $\\text{ACGUACGU}$, $45.0$\n- $\\text{UUUUUUUU}$, $20.0$\n- $\\text{GGGGGGGG}$, $68.0$\n- $\\text{AUAUAUAU}$, $30.0$\n- $\\text{GCGCGCGC}$, $62.0$\n- $\\text{AUGCUAGC}$, $48.0$\n- $\\text{CGAUCG}$, $41.0$\n- $\\text{AUGGCCAU}$, $53.0$\n- $\\text{AUGCUAGCUA}$, $56.0$\n- $\\text{GGCAUUGCCG}$, $63.0$\n\n测试集（预测每个序列的 $T_m$，单位为摄氏度）：\n- $\\text{AUAU}$\n- $\\text{GCGC}$\n- $\\text{AUGCAU}$\n- $\\text{GGCAUGCC}$\n- $\\text{ACACACAC}$\n- $\\text{GGAACCUU}$\n- $\\text{GC}$\n\n涵盖的边界情况包括 $L=2$ 和 $L=4$ 的短序列、低鸟嘌呤-胞嘧啶含量和高鸟嘌呤-胞嘧啶含量。\n\n您的程序必须：\n- 完全按照规定从序列构建特征。\n- 使用闭式正规方程，以固定的 $\\alpha = 10^{-3}$ 拟合一个岭回归模型。\n- 按以上列出的顺序预测测试集序列的 $T_m$。\n- 将每个预测的 $T_m$ 四舍五入到小数点后两位。\n- 生成单行输出，包含一个方括号括起来的逗号分隔列表形式的结果，例如 $[\\dots]$。\n\n角度单位不适用。所有温度必须解释为摄氏度，并以不带单位符号的小数形式报告。不允许用户输入或外部数据；程序必须是自包含和确定性的。", "solution": "所提出的问题是生物信息学和应用机器学习领域的一个经典练习，要求构建一个用于预测短 RNA 双链体熔解温度 $T_m$ 的模型。该任务需通过对从 RNA 序列派生的特征集应用岭回归来完成。问题陈述具有科学依据，定义明确，并包含确定性解决方案所需的所有信息。因此，该问题是有效的。我们开始进行求解。\n\n目标是找到一个从 RNA 序列到其熔解温度 $T_m$ 的映射。我们将构建一个形式为 $\\hat{T}_m = w^\\top x$ 的线性模型，其中 $x$ 是从序列派生的特征向量，$w$ 是从数据中学习到的系数向量。\n\n**步骤 1：特征工程**\n\n第一个也是最关键的步骤是将离散的 RNA 序列转换为一个连续的实值特征向量。根据规定，对于一个长度为 $L$ 的序列 $S$，其特征向量 $x \\in \\mathbb{R}^{d}$ 必须包含其长度、碱基组成和最近邻内容。我们定义一个维度为 $d=19$ 的特征向量，结构如下：\n\n1.  **截距项 ($x_0$)**：一个常数值 $1$。该项 $x_0 = 1$ 允许模型学习一个与任何序列特定属性无关的基线 $T_m$ 值。\n\n2.  **鸟嘌呤-胞嘧啶 (GC) 比例 ($x_1$)**：此特征定义为鸟嘌呤 ($G$) 和胞嘧啶 ($C$) 核苷酸数量与序列总长度的比值。\n    $$\n    x_1 = \\frac{N_G + N_C}{L} \\text{ for } L \\ge 1\n    $$\n    对于 $L=0$，$x_1 = 0$。此特征捕捉了 GC 对众所周知的稳定效应，GC 对形成三个氢键，而 AU 对只有两个。\n\n3.  **序列长度 ($x_2$)**：序列本身的长度 $L$，即 $x_2 = L$。由于累积的碱基堆积和氢键相互作用数量更多，较长的双链体通常更稳定。\n\n4.  **二核苷酸频率 ($x_3, \\dots, x_{18}$)**：这是一组 $16$ 个特征，代表所有可能的二核苷酸的归一化频率。二核苷酸集合为 $\\{\\text{AA}, \\text{AU}, \\text{AG}, \\text{AC}, \\ldots, \\text{CC}\\}$。我们按照问题陈述中指定的顺序为这 $16$ 个二核苷酸建立一个固定排序。对于这个有序集合中的每个二核苷酸 $D_k$，其对应的特征 $x_{k+3}$ 计算如下：\n    $$\n    x_{k+3} = \\frac{\\text{count}(D_k)}{L-1} \\text{ for } L \\ge 2\n    $$\n    对于 $L < 2$，$x_{k+3} = 0$。除数 $L-1$ 是长度为 $L$ 的序列中二核苷酸步骤的总数。这些特征代表了最近邻堆积相互作用对双链体稳定性的贡献，这是核酸热力学模型的基石。\n\n因此，对于任何给定的 RNA 序列，我们都可以构建一个唯一的 $19$ 维特征向量 $x = [x_0, x_1, \\dots, x_{18}]^\\top$。\n\n**步骤 2：模型构建与训练**\n\n我们得到一个包含 $N=20$ 个序列及其对应测量 $T_m$ 值的训练集。我们将这些数据组织成一个设计矩阵 $X \\in \\mathbb{R}^{N \\times d}$ 和一个标签向量 $y \\in \\mathbb{R}^{N}$。$X$ 的每一行 $i$ 是第 $i$ 个训练序列的特征向量 $x^{(i)\\top}$，对应的条目 $y_i$ 是其测量的 $T_m$。在这里，$d=19$。\n\n我们采用岭回归来学习系数向量 $w \\in \\mathbb{R}^{d}$。该模型最小化一个带有系数 $\\ell_2$ 范数惩罚的平方误差损失函数：\n$$\n\\min_{w} \\| Xw - y \\|_2^2 + \\alpha \\sum_{j=1}^{d-1} w_j^2\n$$\n注意，如规定，该惩罚项应用于除截距 $w_0$ 之外的所有系数。正则化参数 $\\alpha > 0$ 控制着拟合数据与惩罚大系数值之间的权衡，这有助于防止过拟合。\n\n最优权重向量 $w$ 通过求解为岭回归修正的正规方程找到：\n$$\n\\left(X^\\top X + \\Lambda\\right) w = X^\\top y\n$$\n这里，$\\Lambda$ 是一个 $d \\times d$ 的对角矩阵，用于实现选择性正则化。由于我们的截距项对应于第一个特征（索引为 $0$），$\\Lambda$ 的对角线元素为：\n$$\n\\Lambda_{jj} = \\begin{cases} 0 & \\text{if } j=0 \\\\ \\alpha & \\text{if } j \\in \\{1, 2, \\dots, d-1\\} \\end{cases}\n$$\n问题指定了一个固定的正则化强度 $\\alpha = 10^{-3}$。\n\n矩阵 $(X^\\top X + \\Lambda)$ 是对称的，并且对于 $\\alpha > 0$，是正定的，从而确保其可逆。权重向量 $w$ 的解通过求解这个线性系统获得：\n$$\nw = \\left(X^\\top X + \\Lambda\\right)^{-1} X^\\top y\n$$\n在计算上，直接求解该系统比显式计算矩阵的逆更数值稳定。\n\n**步骤 3：预测**\n\n一旦从训练数据中确定了权重向量 $w$，它就构成了我们的预测模型。要为一个新的测试序列预测熔解温度 $\\hat{T}_m$，我们首先使用完全相同的特征工程过程为其构建特征向量 $x_{\\text{test}} \\in \\mathbb{R}^{d}$。然后通过点积计算预测值：\n$$\n\\hat{T}_m = x_{\\text{test}}^\\top w\n$$\n每个测试序列的最终结果需要四舍五入到小数点后两位。这个确定性的过程保证了可复现的结果。该解决方案完全按照这些规范实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a ridge regression model to predict RNA melting temperature (Tm)\n    based on sequence features, using a closed-form normal equation solution.\n    \"\"\"\n    \n    # Training data: (sequence, Tm in Celsius)\n    training_data = [\n        (\"AUAUAU\", 22.0),\n        (\"GCGCGC\", 54.0),\n        (\"AUGCUA\", 34.0),\n        (\"GGGCCC\", 57.0),\n        (\"AAAAAA\", 18.0),\n        (\"CCGGCC\", 53.0),\n        (\"AUGGCAU\", 39.0),\n        (\"GGAUCC\", 44.0),\n        (\"AUGCAUGC\", 47.0),\n        (\"GCAUGCAC\", 49.0),\n        (\"ACGUACGU\", 45.0),\n        (\"UUUUUUUU\", 20.0),\n        (\"GGGGGGGG\", 68.0),\n        (\"AUAUAUAU\", 30.0),\n        (\"GCGCGCGC\", 62.0),\n        (\"AUGCUAGC\", 48.0),\n        (\"CGAUCG\", 41.0),\n        (\"AUGGCCAU\", 53.0),\n        (\"AUGCUAGCUA\", 56.0),\n        (\"GGCAUUGCCG\", 63.0)\n    ]\n\n    # Test suite sequences for which to predict Tm\n    test_sequences = [\n        \"AUAU\",\n        \"GCGC\",\n        \"AUGCAU\",\n        \"GGCAUGCC\",\n        \"ACACACAC\",\n        \"GGAACCUU\",\n        \"GC\"\n    ]\n    \n    # Regularization parameter\n    alpha = 1e-3\n    \n    # Ordered list of dinucleotides for feature vector construction\n    dinucl_order = [\n        'AA', 'AU', 'AG', 'AC', 'UA', 'UU', 'UG', 'UC', \n        'GA', 'GU', 'GG', 'GC', 'CA', 'CU', 'CG', 'CC'\n    ]\n    dinucl_map = {d: i for i, d in enumerate(dinucl_order)}\n    num_features = 1 + 1 + 1 + len(dinucl_order) # Intercept, GC-frac, length, dinucleotides\n\n    def featurize(sequence: str) -> np.ndarray:\n        \"\"\"\n        Converts an RNA sequence into a fixed-length feature vector.\n        Feature vector order: [intercept, gc_fraction, length, dinucleotide_freqs...]\n        \"\"\"\n        features = np.zeros(num_features)\n        L = len(sequence)\n\n        # 1. Intercept term (index 0)\n        features[0] = 1.0\n\n        # 2. GC-fraction (index 1)\n        if L > 0:\n            gc_count = sequence.count('G') + sequence.count('C')\n            features[1] = gc_count / L\n        else:\n            features[1] = 0.0\n\n        # 3. Length (index 2)\n        features[2] = float(L)\n\n        # 4. Dinucleotide frequencies (indices 3 to 18)\n        if L >= 2:\n            counts = {d: 0 for d in dinucl_order}\n            for i in range(L - 1):\n                dinuc = sequence[i:i+2]\n                if dinuc in counts:\n                    counts[dinuc] += 1\n            \n            # Normalize counts\n            for dinuc, count in counts.items():\n                features[3 + dinucl_map[dinuc]] = count / (L - 1)\n        \n        return features\n\n    # --- Model Training ---\n\n    # Construct the design matrix X and label vector y\n    num_training_samples = len(training_data)\n    X = np.zeros((num_training_samples, num_features))\n    y = np.zeros(num_training_samples)\n\n    for i, (seq, tm) in enumerate(training_data):\n        X[i, :] = featurize(seq)\n        y[i] = tm\n    \n    # Construct the regularization matrix Lambda\n    # The intercept (at index 0) is not regularized\n    Lambda = np.diag([0.0] + [alpha] * (num_features - 1))\n    \n    # Solve the normal equations: (X^T X + Lambda) w = X^T y\n    XTX = X.T @ X\n    XTy = X.T @ y\n    \n    A = XTX + Lambda\n    \n    # Solve for the weight vector w\n    try:\n        w = np.linalg.solve(A, XTy)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if solving fails, though unlikely with regularization\n        w = np.linalg.pinv(A) @ XTy\n\n    # --- Prediction ---\n\n    results = []\n    for seq in test_sequences:\n        # Generate feature vector for the test sequence\n        x_test = featurize(seq)\n        \n        # Predict Tm\n        tm_pred = x_test @ w\n        \n        # Round to two decimal places and store\n        results.append(round(tm_pred, 2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2427183"}]}