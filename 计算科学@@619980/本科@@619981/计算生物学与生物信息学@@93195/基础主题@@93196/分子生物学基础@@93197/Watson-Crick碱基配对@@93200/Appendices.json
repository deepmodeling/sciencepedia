{"hands_on_practices": [{"introduction": "沃森-克里克碱基配对的规则不仅定义了遗传信息的存储方式，也决定了DNA双螺旋的结构稳定性。这个练习将引导你运用生物物理学中经典的最近邻模型，亲手计算并比较DNA:DNA双螺旋与DNA:RNA杂合双螺旋的热力学稳定性。通过这个实践[@problem_id:2440503]，你将深刻理解核酸序列是如何直接转化为可量化的能量差异的，这对理解基因转录和设计生物技术工具至关重要。", "problem": "一个短双螺旋的形成采用标准吉布斯生成自由能的最近邻加和性模型，其中双螺旋形成的总标准吉布斯自由能变 $\\Delta G^{\\circ}_{\\mathrm{form}}$ 是沿链的逐步二核苷酸贡献之和，忽略了起始和末端校正。考虑一个脱氧核糖核酸（DNA）序列 $5'$-$\\mathrm{GCGC}$-$3'$，它与其精确的沃森-克里克（Watson-Crick）互补链 $3'$-$\\mathrm{CGCG}$-$5'$ 形成DNA:DNA双螺旋，或者与DNA互补链 $3'$-$\\mathrm{CGCG}$-$5'$ 配对，形成一个核糖核酸（RNA）:DNA杂合螺旋，其中RNA链为 $5'$-$\\mathrm{GCGC}$-$3'$。假设在 $T=310\\ \\mathrm{K}$ 的标准条件下，分离一个双螺旋所需的能量等于该双螺旋形成的标准吉布斯生成自由能的绝对值。\n\n使用以下每个最近邻步骤的标准吉布斯自由能贡献（单位：$\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$）：\n\n- DNA:DNA步骤：\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) = -9.37$\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC}) = -9.08$\n\n- RNA:DNA步骤（表示法 $\\mathrm{rXY}/\\mathrm{dZW}$ 指的是RNA步骤 $\\mathrm{XY}$ 与互补的DNA步骤 $\\mathrm{ZW}$ 配对）：\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) = -11.30$\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC}) = -9.21$\n\n对于序列 $5'$-$\\mathrm{GCGC}$-$3'$，沿 $5'\\to 3'$ 方向遇到的三个最近邻步骤，对于DNA:DNA是 $\\mathrm{GC}/\\mathrm{CG}$、$\\mathrm{CG}/\\mathrm{GC}$ 和 $\\mathrm{GC}/\\mathrm{CG}$；类似地，对于RNA:DNA是 $\\mathrm{rGC}/\\mathrm{dCG}$、$\\mathrm{rCG}/\\mathrm{dGC}$ 和 $\\mathrm{rGC}/\\mathrm{dCG}$。\n\n计算对于该序列，分离RNA:DNA杂合体相对于DNA:DNA双螺旋所需的额外能量，定义为\n$\\Delta E = E_{\\mathrm{sep}}(\\mathrm{RNA{:}DNA}) - E_{\\mathrm{sep}}(\\mathrm{DNA{:}DNA})$，\n并以 $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$ 为单位表示你的最终答案。将你的答案四舍五入到 $4$ 位有效数字。", "solution": "问题陈述基于已建立的核酸热力学最近邻模型，提出了一个定义明确的问题。所有必要的数据、条件和简化假设都已明确给出。该问题具有科学依据、客观且自成体系。因此，该问题被认为是有效的，我们继续进行求解。\n\n核酸双螺旋的热力学稳定性由其形成的标准吉布斯自由能变 $\\Delta G^{\\circ}_{\\mathrm{form}}$ 来量化。根据最近邻模型，该总能量是相邻碱基对步骤的熵和焓贡献的总和，并且按规定忽略了起始和末端效应。\n\n首先，我们计算DNA:DNA双螺旋形成的标准吉布斯自由能。序列为 $5'$-$\\mathrm{GCGC}$-$3'$，有 $4-1=3$ 个最近邻步骤。如问题所述，这些步骤是从 $5'$ 端到 $3'$ 端遍历的，得到二核苷酸对序列：$\\mathrm{GC}/\\mathrm{CG}$、$\\mathrm{CG}/\\mathrm{GC}$ 和 $\\mathrm{GC}/\\mathrm{CG}$。\n\nDNA:DNA双螺旋的总标准吉布斯自由能是这些步骤贡献的总和：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) + \\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC}) + \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG})\n$$\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = 2 \\cdot \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) + \\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC})\n$$\n代入以 $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$ 为单位的给定值：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = 2 \\cdot (-9.37) + (-9.08) = -18.74 - 9.08 = -27.82\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n\n接下来，我们对RNA:DNA杂合双螺旋进行类似的计算。RNA链是 $5'$-$\\mathrm{GCGC}$-$3'$，DNA互补链是 $3'$-$\\mathrm{CGCG}$-$5'$。最近邻步骤是 $\\mathrm{rGC}/\\mathrm{dCG}$、$\\mathrm{rCG}/\\mathrm{dGC}$ 和 $\\mathrm{rGC}/\\mathrm{dCG}$。\n\nRNA:DNA杂合体的总标准吉布斯自由能是：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) + \\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC}) + \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG})\n$$\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = 2 \\cdot \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) + \\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC})\n$$\n代入给定值：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = 2 \\cdot (-11.30) + (-9.21) = -22.60 - 9.21 = -31.81\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n\n问题将分离双螺旋所需的能量 $E_{\\mathrm{sep}}$ 定义为其形成的标准吉布斯自由能的绝对值。由于双螺旋形成是一个自发过程，$\\Delta G^{\\circ}_{\\mathrm{form}}$ 为负值，因此分离能为正值：\n$$\nE_{\\mathrm{sep}} = |\\Delta G^{\\circ}_{\\mathrm{form}}| = -\\Delta G^{\\circ}_{\\mathrm{form}}\n$$\n需要计算的量是分离RNA:DNA杂合体相对于DNA:DNA双螺旋所需的额外能量，记为 $\\Delta E$：\n$$\n\\Delta E = E_{\\mathrm{sep}}(\\mathrm{RNA{:}DNA}) - E_{\\mathrm{sep}}(\\mathrm{DNA{:}DNA})\n$$\n代入 $E_{\\mathrm{sep}}$ 的表达式：\n$$\n\\Delta E = (-\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA})) - (-\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}))\n$$\n$$\n\\Delta E = \\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) - \\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA})\n$$\n现在我们可以代入计算出的自由能值：\n$$\n\\Delta E = (-27.82\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}) - (-31.81\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1})\n$$\n$$\n\\Delta E = -27.82 + 31.81 = 3.99\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n问题要求将答案四舍五入到 $4$ 位有效数字。计算值为 $3.99$。为了用四位有效数字表示，我们将其写为 $3.990$。$\\Delta E$ 的正值表明，对于这个特定序列，RNA:DNA杂合体比其DNA:DNA对应物更稳定，需要更多能量来分离。", "answer": "$$\n\\boxed{3.990}\n$$", "id": "2440503"}, {"introduction": "碱基配对的强度差异对细胞内的分子机器有着实际影响。例如，由较弱的A-T配对（两个氢键）主导的重复序列，有时会成为DNA聚合酶的“陷阱”，导致复制错误和移码突变。本练习[@problem_id:2440493]要求你编写一个程序，根据一个简化的生物物理模型来识别这些所谓的“滑移序列”。这个实践将帮助你把碱基配对的化学原理应用到序列分析中，体验如何将一个生物学概念转化为一个可执行的算法。", "problem": "编写一个完整的程序，该程序在给定由字母表 {\"A\",\"C\",\"G\",\"T\"} 组成的脱氧核糖核酸（DNA）序列的情况下，根据一个基于 `Watson-Crick` 碱基配对的模型，检测所有“滑脱”窗口的起始索引。腺嘌呤-胸腺嘧啶碱基对贡献 $2$ 个氢键，鸟嘌呤-胞嘧啶碱基对贡献 $3$ 个氢键。如果一个窗口每个碱基的平均氢键数至多为一个指定的阈值，则该窗口被认为是“弱”的。一个窗口当且仅当它是弱的，并且在同一窗口内存在以下任一情况时，才被认为是“滑脱”的：(i) 存在一个腺嘌呤或胸腺嘧啶的同聚物长链，其长度至少为一个指定的整数；或 (ii) 存在一个二核苷酸基序 \"AT\" 或 \"TA\" 的连续串联重复，其重复次数至少为一个指定的整数。\n\n形式上，设一个序列为长度是 $n$ 的字符串 $s$，其字母表为 $\\{A,C,G,T\\}$。设 $w$ 为滑动窗口评估的窗口长度，其中 $1 \\le w \\le n$；如果 $n < w$，则不存在窗口。对于每个起始索引 $i$（$0 \\le i \\le n-w$），我们考虑窗口 $s[i:i+w]$。定义 $N_{AT}(i)$ 为该窗口中 $\\{A,T\\}$ 字符的计数，$N_{GC}(i)=w-N_{AT}(i)$。窗口中每个碱基的平均氢键数为\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3\\,N_{GC}(i)}{w}.\n$$\n给定一个实数阈值 $h_{\\max}$，如果 $\\bar{h}(i) \\le h_{\\max}$，则该窗口是弱窗口。在同一窗口内，定义：\n- 同聚物条件 $H(i)$：如果存在索引 $j$ 和整数长链长度 $\\ell \\ge L_{\\text{run}}$，使得 $s[j]=s[j+1]=\\cdots=s[j+\\ell-1]$ 并且 $s[j]\\in\\{A,T\\}$ 且 $[j, j+\\ell-1] \\subseteq [i, i+w-1]$，则该条件为真。\n- 二核苷酸重复条件 $D(i)$：如果存在索引 $j$、基序 $m\\in\\{\\text{\"AT\"},\\text{\"TA\"}\\}$ 以及整数 $r \\ge R_{\\text{rep}}$，使得子字符串 $s[j:j+2r]$ 等于 $m$ 自身连接 $r$ 次的结果，并且 $[j, j+2r-1] \\subseteq [i, i+w-1]$，则该条件为真。\n\n一个窗口 $s[i:i+w]$ 是滑脱的，当且仅当 $\\bar{h}(i) \\le h_{\\max}$ 且 $\\big(H(i)\\ \\text{or}\\ D(i)\\big)$ 为真。索引是基于 0 的。\n\n你的程序必须为每个测试用例输出一个列表，包含所有使得 $s[i:i+w]$ 为滑脱窗口的起始索引 $i$。如果 $n < w$，则为该测试用例输出空列表。\n\n测试套件。你的程序必须按顺序评估以下测试用例，并将索引列表聚合成如下指定的单个输出行：\n- 用例 1：$s=\\text{\"GAAAAAAG\"}$, $w=8$, $h_{\\max}=2.25$, $L_{\\text{run}}=6$, $R_{\\text{rep}}=3$。\n- 用例 2：$s=\\text{\"CCCCCC\"}$, $w=4$, $h_{\\max}=2.4$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=2$。\n- 用例 3：$s=\\text{\"ATATATGC\"}$, $w=6$, $h_{\\max}=2.2$, $L_{\\text{run}}=5$, $R_{\\text{rep}}=3$。\n- 用例 4：$s=\\text{\"TTTTT\"}$, $w=3$, $h_{\\max}=2.0$, $L_{\\text{run}}=3$, $R_{\\text{rep}}=2$。\n- 用例 5：$s=\\text{\"AATTAATT\"}$, $w=4$, $h_{\\max}=2.0$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=2$。\n- 用例 6：$s=\\text{\"AT\"}$, $w=3$, $h_{\\max}=2.5$, $L_{\\text{run}}=2$, $R_{\\text{rep}}=2$。\n- 用例 7：$s=\\text{\"ATATATAT\"}$, $w=6$, $h_{\\max}=2.1$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=3$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素是相应测试用例的索引列表，并且行中任何地方都不能有空格。例如，一个包含三个测试用例的输出应类似于 $[[i\\_1,\\dots],[\\dots],[]]$，不含空格。索引必须是整数。", "solution": "该问题要求在给定的脱氧核糖核酸（DNA）序列中识别出“滑脱”窗口。一个窗口如果同时满足两个不同的标准，即被指定为滑脱窗口：一个是基于氢键含量的“弱性”生物物理标准，另一个是与特定重复基序存在相关的结构标准。该解决方案需要对所有指定长度的可能窗口进行系统性评估。\n\n该算法通过在长度为 $n$ 的输入序列 $s$ 上滑动一个长度为 $w$ 的窗口来进行。对于每个可能的起始索引 $i$（$0 \\le i \\le n-w$），分析相应的子字符串 $s[i:i+w]$。如果 $n < w$，则不存在这样的窗口，结果是空索引集。\n\n对于每个窗口，我们首先评估弱性标准。每个碱基的平均氢键数 $\\bar{h}(i)$ 是窗口内腺嘌呤-胸腺嘧啶碱基数 $N_{AT}(i)$ 和鸟嘌呤-胞嘧啶碱基数 $N_{GC}(i)$ 的函数。鉴于腺嘌呤-胸腺嘧啶对由 $2$ 个氢键连接，鸟嘌呤-胞嘧啶对由 $3$ 个氢键连接，其公式为：\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3\\,N_{GC}(i)}{w}\n$$\n由于 $N_{AT}(i) + N_{GC}(i) = w$，我们可以代入 $N_{GC}(i) = w - N_{AT}(i)$ 以获得一个简化表达式：\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3(w - N_{AT}(i))}{w} \\;=\\; \\frac{3w - N_{AT}(i)}{w} \\;=\\; 3 - \\frac{N_{AT}(i)}{w}\n$$\n如果此平均值不超过指定的阈值 $h_{\\max}$，则窗口被定义为弱窗口。即，条件是 $\\bar{h}(i) \\le h_{\\max}$。如果一个窗口不满足此条件，它就不可能是滑脱窗口，算法将继续处理下一个窗口。\n\n如果窗口被发现是弱窗口，则对其进行结构标准检验。如果 $H(i)$ 或 $D(i)$ 这两个条件中有一个对子字符串 $s[i:i+w]$ 成立，则该标准被满足。\n\n第一个结构条件，即同聚物条件 $H(i)$，如果窗口包含一个单一碱基的连续长链，其中碱基是腺嘌呤（'A'）或胸腺嘧啶（'T'），并且该长链的长度 $\\ell$ 至少为一个指定的整数 $L_{\\text{run}}$，则该条件得到满足。这等同于在窗口内检查子字符串 $'A' \\times L_{\\text{run}}$ 或 $'T' \\times L_{\\text{run}}$ 的存在。\n\n第二个结构条件，即二核苷酸重复条件 $D(i)$，如果窗口包含二核苷酸基序 'AT' 或 'TA' 的连续串联重复，则该条件得到满足。重复次数 $r$ 必须至少为一个指定的整数 $R_{\\text{rep}}$。这对应于在窗口内搜索子字符串 $('AT') \\times R_{\\text{rep}}$ 或 $('TA') \\times R_{\\text{rep}}$。\n\n一个以索引 $i$ 开始的窗口，当且仅当它是弱窗口并且还满足逻辑析取 $(H(i) \\lor D(i))$ 时，被正式归类为滑脱窗口。算法必须收集所有这样的索引 $i$。\n\n计算过程如下：\n1. 对于一个给定的测试用例及其参数 $s, w, h_{\\max}, L_{\\text{run}}, R_{\\text{rep}}$，确定序列的长度 $n$。如果 $n < w$，返回一个空列表。\n2. 预先构建用于结构检查的基序字符串：一个长度为 $L_{\\text{run}}$ 的 A-同聚物，一个长度为 $L_{\\text{run}}$ 的 T-同聚物，一个长度为 $2R_{\\text{rep}}$ 的 AT-二核苷酸重复序列，以及一个长度为 $2R_{\\text{rep}}$ 的 TA-二核苷酸重复序列。\n3. 用索引 $i$ 从 $0$ 到 $n-w$ 进行迭代。对于每个 $i$：\n    a. 提取窗口子字符串 $s[i:i+w]$。\n    b. 计算窗口中 'A' 和 'T' 碱基的计数 $N_{AT}(i)$。\n    c. 检查弱性条件：$3w - N_{AT}(i) \\le h_{\\max} \\times w$。如果此条件为假，则继续下一个 $i$ 值。\n    d. 如果窗口是弱窗口，则检查结构条件：确定预先构建的任何基序字符串是否存在于该窗口的子字符串中。\n    e. 如果结构条件满足，将索引 $i$ 添加到结果列表中。\n4. 循环完成后，收集到的索引的最终列表即为该测试用例的解。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef find_slippery_windows(s: str, w: int, h_max: float, L_run: int, R_rep: int) -> list[int]:\n    \"\"\"\n    Detects the starting indices of all \"slippery\" windows in a DNA sequence.\n\n    A window is slippery if it is \"weak\" (low average hydrogen bonds) and contains\n    either a long A/T homopolymer or a tandem AT/TA repeat.\n    \"\"\"\n    n = len(s)\n    if n < w:\n        return []\n\n    slippery_indices = []\n\n    # Pre-generate the search motifs to avoid repeated string construction.\n    # The homopolymer condition requires a run of length *at least* L_run.\n    # Searching for a substring of exactly length L_run is sufficient because if a\n    # longer run exists, it must contain a run of length L_run.\n    homopolymer_A = 'A' * L_run\n    homopolymer_T = 'T' * L_run\n    \n    # Similarly, for dinucleotide repeats of length at least R_rep.\n    repeat_AT = 'AT' * R_rep\n    repeat_TA = 'TA' * R_rep\n\n    for i in range(n - w + 1):\n        window = s[i : i + w]\n\n        # 1. Weakness criterion evaluation.\n        # The average hydrogen bond count is (2*N_AT + 3*N_GC) / w.\n        # N_GC = w - N_AT.\n        # So, h_avg = (2*N_AT + 3*(w - N_AT)) / w = (3w - N_AT) / w.\n        # Condition: h_avg <= h_max  =>  (3w - N_AT) / w <= h_max\n        # To maintain precision, we use integer/float arithmetic on the un-divided form:\n        # 3w - N_AT <= h_max * w\n        n_at = window.count('A') + window.count('T')\n        \n        is_weak = (3 * w - n_at) <= h_max * w\n        \n        if not is_weak:\n            continue\n\n        # 2. Structural motif evaluation.\n        # This condition is checked only if the window is weak.\n        # H(i): Homopolymer of 'A' or 'T' of length >= L_run.\n        homopolymer_found = (homopolymer_A in window) or (homopolymer_T in window)\n\n        # D(i): Tandem repeat of 'AT' or 'TA' with >= R_rep repetitions.\n        dinucleotide_repeat_found = (repeat_AT in window) or (repeat_TA in window)\n\n        if homopolymer_found or dinucleotide_repeat_found:\n            slippery_indices.append(i)\n            \n    return slippery_indices\n\ndef solve():\n    \"\"\"\n    Runs the validation and solution for all test cases provided in the problem.\n    \"\"\"\n    test_cases = [\n        # (s, w, h_max, L_run, R_rep)\n        (\"GAAAAAAG\", 8, 2.25, 6, 3),\n        (\"CCCCCC\", 4, 2.4, 4, 2),\n        (\"ATATATGC\", 6, 2.2, 5, 3),\n        (\"TTTTT\", 3, 2.0, 3, 2),\n        (\"AATTAATT\", 4, 2.0, 4, 2),\n        (\"AT\", 3, 2.5, 2, 2),\n        (\"ATATATAT\", 6, 2.1, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, w, h_max, l_run, r_rep = case\n        result = find_slippery_windows(s, w, h_max, l_run, r_rep)\n        results.append(result)\n\n    # Format the final output string to be exactly as specified, with no spaces.\n    # e.g., [[0],[],[0,1,2]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2440493"}, {"introduction": "在计算生物学中，寻找两条核酸序列之间的互补区域是识别潜在生物学相互作用（如microRNA靶向）的核心任务。然而，完美的互补在生物体内很少见，常伴有小的瑕疵。本练习[@problem_id:2440548]挑战你设计一个动态规划算法，以寻找两条序列间允许单个核苷酸“凸起”的最长互补片段。这个任务不仅能加深你对碱基互补规则的运用，更是对算法设计和优化能力的一次综合性训练，让你掌握解决大规模序列比对问题的关键技术。", "problem": "给定两个核苷酸序列，其字母表为 $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T} \\}$（序列中也可能出现 $\\mathrm{U}$，在互补配对中视作与 $\\mathrm{T}$ 等价）。Watson-Crick 碱基配对的规范定义为：$\\mathrm{A}$ 与 $\\mathrm{T}$（或 $\\mathrm{U}$）配对，$\\mathrm{G}$ 与 $\\mathrm{C}$ 配对。两个序列之间的一个连续互补块是指一段最长的配对位置序列，其中每个配对位置都是正确的 Watson-Crick 配对，并且两个序列的邻接关系得以保持。在此问题中，您必须允许在块内的任意位置（任一序列中）存在至多一个凸起（单个未配对的核苷酸），同时在其他位置保持连续性。一个块的长度仅计算配对位置的数量；如果存在凸起，其对长度的贡献为零。形式上，设两个序列分别为长度为 $n$ 的 $S$ 和长度为 $m$ 的 $T$。一个块将子序列 $S[i_1..i_k]$ 与 $T[j_1..j_k]$ 对齐，其中对于所有 $\\ell \\in \\{1,\\dots,k\\}$，配对 $\\big(S[i_\\ell], T[j_\\ell]\\big)$ 都是 Watson-Crick 互补的，并且索引差异满足以下条件之一：$i_{\\ell} - i_{\\ell-1} = 1$ 且 $j_{\\ell} - j_{\\ell-1} = 1$（在 $\\ell-1$ 和 $\\ell$ 之间没有凸起），或者在整个块中仅出现一次 $i_{\\ell} - i_{\\ell-1} = 2, j_{\\ell} - j_{\\ell-1} = 1$（在 $S$ 中有一个单符号凸起）或 $i_{\\ell} - i_{\\ell-1} = 1, j_{\\ell} - j_{\\ell-1} = 2$（在 $T$ 中有一个单符号凸起）。您的任务是从第一性原理出发，设计一种动态规划算法，用以计算 $S$ 和 $T$ 之间此类块的最大可能长度。\n\n您的推导必须基于 Watson-Crick 碱基配对和连续性的基本定义，并结合使用最优子结构和重叠子问题的标准动态规划范式。请勿假定任何预先推导出的比对递推关系。您的算法必须对任意的 $S$ 和 $T$ 都是正确的，必须在 $\\mathcal{O}(nm)$ 时间内运行，并且为了能够扩展到兆碱基规模的输入，必须通过滚动数组仅使用 $\\mathcal{O}(m)$ 的额外内存。\n\n您的程序必须实现此算法并评估以下测试套件。对于每个案例，返回等于上述规则下最大块长度的整数。\n\n- 案例 1：$S = \\text{\"ACGTTGCA\"}$, $T = \\text{\"TGCATACGT\"}$。\n- 案例 2：$S = \\text{\"AAAA\"}$, $T = \\text{\"CCCC\"}$。\n- 案例 3：$S = \\text{\"ATGC\"}$, $T = \\text{\"TACG\"}$。\n- 案例 4：$S = \\text{\"ACGGT\"}$, $T = \\text{\"TGCA\"}$。\n- 案例 5：$S = \\text{\"A\"}$, $T = \\text{\"G\"}$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\texttt{[r_1,r_2,\\dots]}$），结果顺序与上述案例一致。每个结果都必须是一个整数。此问题不涉及物理单位。", "solution": "所提出的问题是计算生物学中一个明确定义的问题，具体涉及核苷酸序列的局部比对。它要求计算最长的连续 Watson-Crick 互补碱基对块的长度，并特别允许存在一个单核苷酸凸起。该问题具有科学依据和数学精确性，因此是有效的。我们将使用动态规划范式从第一性原理构建解决方案。\n\n问题的核心在于找到一个最优子结构。设两个序列分别为长度为 $n$ 的 $S$ 和长度为 $m$ 的 $T$。我们寻求在所有可能的起始和结束位置上有效块的最大长度。这是一个局部比对问题，其中块的分数是其长度（配对数），任何互补性的中断都会终止该块。\n\n我们的动态规划算法的状态不仅必须捕捉比对位置，还必须记录是否已经使用了那个允许的凸起。这就需要进行状态空间扩充。我们为递推关系定义两个矩阵或表：\n1.  设 $D_0(i, j)$ 为在 $(S[i], T[j])$ 对处精确结束、且块内**无凸起**的最长连续互补块的长度。在本次推导中，我们使用基于 1 的索引，因此 $i \\in \\{1, \\dots, n\\}$ 且 $j \\in \\{1, \\dots, m\\}$。\n2.  设 $D_1(i, j)$ 为在 $(S[i], T[j])$ 处结束、且包含**恰好一个凸起**的最长互补块的长度。\n\n最终答案将是 $D_0$ 和 $D_1$ 所有条目中的最大值。\n\n首先，我们定义一个函数 $\\text{is\\_complement}(c_1, c_2)$，如果字符 $c_1$ 和 $c_2$ 形成一个 Watson-Crick 对（A-T/U, G-C），则返回 $1$，否则返回 $0$。\n\n递推关系推导如下：\n\n对于 $D_0(i, j)$：一个在 $(i, j)$ 处结束且无凸起的连续块，只有在 $S[i]$ 和 $T[j]$ 互补时才可能存在。如果它们互补，该块就是一个在 $(i-1, j-1)$ 结束的无凸起块的延伸。如果它们不互补，任何进行中的块都将被终止，在 $(i, j)$ 结束的块的长度为 $0$。\n$$\nD_0(i, j) =\n\\begin{cases}\nD_0(i-1, j-1) + 1 & \\text{if } \\text{is\\_complement}(S[i], T[j]) = 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n\n对于 $D_1(i, j)$：一个在 $(i, j)$ 处结束且有一个凸起的块同样要求 $S[i]$ 和 $T[j]$ 互补。如果它们互补，该块可能通过以下三种方式之一形成：\n1.  通过延伸一个已经包含凸起的块：该块在 $(i-1, j-1)$ 处结束，其长度为 $D_1(i-1, j-1)$。\n2.  通过在序列 $S$ 中引入一个凸起：这涉及在 $(i-2, j-1)$ 处结束的无凸起块之后，立即将 $S[i]$ 与 $T[j]$ 匹配。字符 $S[i-1]$ 是凸起。长度基于 $D_0(i-2, j-1)$。\n3.  通过在序列 $T$ 中引入一个凸起：这涉及在 $(i-1, j-2)$ 处结束的无凸起块之后，立即将 $S[i]$ 与 $T[j]$ 匹配。字符 $T[j-1]$ 是凸起。长度基于 $D_0(i-1, j-2)$。\n\n我们取这些可能性中的最大值。如果 $S[i]$ 和 $T[j]$ 不互补，块被中断，因此 $D_1(i, j)=0$。\n$$\nD_1(i, j) =\n\\begin{cases}\n\\max \\Big( D_1(i-1, j-1), D_0(i-2, j-1), D_0(i-1, j-2) \\Big) + 1 & \\text{if } \\text{is\\_complement}(S[i], T[j]) = 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n\n边界条件是，对于任何 $i \\le 0$ 或 $j \\le 0$ 的 $i, j$， $D_0(i, j)$ 和 $D_1(i, j)$ 均为 $0$。这通过用零初始化动态规划表来处理。\n\n总的最大长度是 $\\max_{1 \\le i \\le n, 1 \\le j \\le m} \\{D_0(i, j), D_1(i, j)\\}$。\n\n该算法的时间复杂度为 $\\mathcal{O}(nm)$，因为存在对两个序列长度的嵌套循环。一个朴素的实现将需要 $\\mathcal{O}(nm)$ 的空间来存储两个动态规划表。然而，问题要求空间复杂度为 $\\mathcal{O}(m)$。我们观察到，计算两个表的第 $i$ 行仅依赖于第 $i-1$ 行和第 $i-2$ 行。这种依赖性允许使用“滚动数组”实现。要计算第 $i$ 行，我们只需要为 $D_0$ 存储第 $i-1$ 行和第 $i-2$ 行，为 $D_1$ 存储第 $i-1$ 行。\n\n具体来说，要计算 `d0_curr`（$D_0$ 的第 $i$ 行）和 `d1_curr`（$D_1$ 的第 $i$ 行），我们需要：\n- `d0_prev`（$D_0$ 的第 $i-1$ 行）\n- `d0_prev2`（$D_0$ 的第 $i-2$ 行）\n- `d1_prev`（$D_1$ 的第 $i-1$ 行）\n\n在外层循环的每一步 $i$ 中，我们计算 `d0_curr` 和 `d1_curr`。然后，在下一次迭代 $i+1$ 之前，我们更新滚动数组：`d0_prev2` 变为 `d0_prev`，`d0_prev` 变为 `d0_curr`，`d1_prev` 变为 `d1_curr`。这需要常数个大小为 $\\mathcal{O}(m)$ 的数组，从而满足内存限制。实现将忠实地转换此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nucleotide sequence alignment problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"ACGTTGCA\", \"TGCATACGT\"),\n        (\"AAAA\", \"CCCC\"),\n        (\"ATGC\", \"TACG\"),\n        (\"ACGGT\", \"TGCA\"),\n        (\"A\", \"G\"),\n    ]\n\n    results = []\n    \n    # Define the Watson-Crick complements\n    complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    \n    def is_complement(c1, c2):\n        \"\"\"Checks if two nucleotides are complementary, handling U as T.\"\"\"\n        c1_norm = 'T' if c1 == 'U' else c1\n        c2_norm = 'T' if c2 == 'U' else c2\n        return complement_map.get(c1_norm) == c2_norm\n\n    for S, T in test_cases:\n        n = len(S)\n        m = len(T)\n        \n        if n == 0 or m == 0:\n            results.append(0)\n            continue\n            \n        max_len = 0\n\n        # Rolling arrays for D_0 (no bulge) computation\n        # We need rows i-1 and i-2 to compute row i for D_1\n        d0_prev2 = np.zeros(m + 1, dtype=int)\n        d0_prev = np.zeros(m + 1, dtype=int)\n        \n        # Rolling array for D_1 (one bulge) computation\n        d1_prev = np.zeros(m + 1, dtype=int)\n\n        # Iterate through sequence S\n        for i in range(1, n + 1):\n            # Current rows for this iteration of i\n            d0_curr = np.zeros(m + 1, dtype=int)\n            d1_curr = np.zeros(m + 1, dtype=int)\n\n            # Iterate through sequence T\n            for j in range(1, m + 1):\n                if is_complement(S[i - 1], T[j - 1]):\n                    # Case 1: No bulge block extension\n                    d0_curr[j] = d0_prev[j - 1] + 1\n                    \n                    # Case 2: One bulge block formation/extension\n                    # Option A: Extend a block that already had a bulge\n                    extend_bulge_block = d1_prev[j - 1]\n                    \n                    # Option B: Introduce a new bulge in S (skip S[i-2])\n                    # Depends on a no-bulge block ending at (i-2, j-1)\n                    # This value is stored in d0_prev2[j-1]\n                    new_bulge_in_s = d0_prev2[j - 1]\n\n                    # Option C: Introduce a new bulge in T (skip T[j-2])\n                    # Depends on a no-bulge block ending at (i-1, j-2)\n                    # This value is stored in d0_prev[j-2]\n                    # We must check j>=2 to avoid negative indexing issues\n                    new_bulge_in_t = d0_prev[j - 2] if j >= 2 else 0\n\n                    d1_curr[j] = max(extend_bulge_block, new_bulge_in_s, new_bulge_in_t) + 1\n                \n                # If no complement, d0_curr[j] and d1_curr[j] remain 0 by initialization,\n                # correctly terminating the block.\n\n            # Update the maximum length found so far\n            current_max = 0\n            if d0_curr.size > 1:\n                current_max = max(current_max, d0_curr.max())\n            if d1_curr.size > 1:\n                current_max = max(current_max, d1_curr.max())\n            max_len = max(max_len, current_max)\n            \n            # Roll the arrays for the next iteration of i\n            d0_prev2 = d0_prev\n            d0_prev = d0_curr\n            d1_prev = d1_curr\n            \n        results.append(int(max_len))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440548"}]}