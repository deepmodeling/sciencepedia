{"hands_on_practices": [{"introduction": "DNA 复制过程必须极其精确，以保持基因组的完整性。这种高保真度源于多层次的纠错机制，其中 DNA 聚合酶自身的校对功能起着至关重要的作用。本练习将引导你从基本原理出发，构建一个量化模型，以理解校对功能的缺陷如何直接影响突变率——这是遗传学、进化和疾病研究中的一个核心概念 [@problem_id:2403484]。", "problem": "一个细胞使用高保真度的复制型DNA聚合酶来复制其脱氧核糖核酸（DNA）。该聚合酶以每个核苷酸$r_{0}$（每个碱基每次复制）的基线概率错误掺入核苷酸。该聚合酶具有$3^{\\prime}\\!\\to\\!5^{\\prime}$外切核酸酶校对功能，当发生错误掺入时，它会在延伸前以概率$p$进行纠正。复制后的错配修复（MMR）系统会以概率$q$纠正任何逃脱了校对的剩余错配。假设错误掺入事件是罕见的，且在不同位点上是独立的；校对和MMR对同一错误按顺序起作用（一个错配必须首先逃脱校对才能被MMR系统识别），并且所述概率在每个阶段独立应用，条件是前一阶段失败。\n\n考虑一个单倍体基因组，其每次完整基因组复制的核苷酸掺入数量为$L$。一个假设的突变使聚合酶的校对效率降低了$x$%，意味着新的校对纠正概率变为$(1 - \\frac{x}{100})p$，而$r_{0}$、$q$和$L$保持不变。\n\n推导一个单一的闭式解析表达式，表示仅因此校对效率降低而导致的每次细胞分裂每个基因组中复制诱导的点突变预期数量的增加量$\\Delta M(x)$，该表达式用$L$、$r_{0}$、$p$、$q$和$x$表示。将最终答案表示为一个解析表达式；不要进行数值计算，也不要在表达式中包含单位。答案应表示每次细胞分裂每个基因组中预期的额外突变数量。", "solution": "对问题陈述进行验证。\n\n逐字提取已知条件：\n- 每个核苷酸错误掺入的基线概率：$r_{0}$\n- 校对纠正的概率：$p$\n- 错配修复（MMR）纠正的概率：$q$\n- 每次完整基因组复制的核苷酸掺入数量：$L$\n- 校对效率降低的百分比：$x$\n- 新的校对纠正概率：$(1 - \\frac{x}{100})p$\n- 假设：错误掺入事件罕见且独立；校对和MMR按顺序独立作用。\n- 目标：推导每次细胞分裂每个基因组中复制诱导的点突变预期数量的增加量$\\Delta M(x)$。\n\n使用提取的已知条件进行验证：\n该问题具有科学依据，基于已确立的DNA复制保真度分子机制——聚合酶错误、外切核酸酶校对和错配修复。所提出的概率模型是计算生物学和群体遗传学中使用的标准、有效的简化模型。该问题提法严谨，提供了推导唯一解析解所需的所有参数和假设。语言客观、精确。设定自洽，无矛盾之处。该场景是对突变表型的一个假设但生物学上合理的表述。因此，该问题被认定为有效。\n\n解题过程如下。\n\n设$R$为单个核苷酸掺入事件导致永久性、固定突变的概率。一个突变要得以确立，必须发生一系列失败事件：聚合酶的初始错误掺入、即时校对机制的失败以及随后的错配修复系统的失败。\n\n首先，我们定义在基线条件下每个位点发生突变的概率，记为$R_{baseline}$。\n引入错误的概率为$r_{0}$。\n该错误逃脱$3^{\\prime}\\!\\to\\!5^{\\prime}$外切核酸酶校对机制的概率为$(1 - p)$。\n假定它已逃脱校对，所产生的错配逃脱复制后MMR系统的概率为$(1-q)$。\n由于这些顺序事件声明的独立性，每个位点发生突变的总概率是这些概率的乘积：\n$$R_{baseline} = r_{0} (1 - p) (1 - q)$$\n\n每次复制每个基因组的预期突变数$M$，是复制位点数（核苷酸掺入数）$L$与每个位点的突变概率$R$的乘积。这是$L$次独立伯努利试验之和的期望值。\n因此，每个基因组的基线预期突变数为：\n$$M_{baseline} = L \\cdot R_{baseline} = L r_{0} (1 - p) (1 - q)$$\n\n接下来，我们分析校对功能受损的情况。新的校对纠正概率$p_{new}$，比其原始值$p$降低了$x$个百分点：\n$$p_{new} = p \\left(1 - \\frac{x}{100}\\right)$$\n因此，新的校对*失败*概率为：\n$$1 - p_{new} = 1 - p \\left(1 - \\frac{x}{100}\\right)$$\n参数$r_{0}$、$q$和$L$保持不变。每个位点的新突变概率$R_{new}(x)$由下式给出：\n$$R_{new}(x) = r_{0} (1 - p_{new}) (1 - q) = r_{0} \\left[1 - p \\left(1 - \\frac{x}{100}\\right)\\right] (1 - q)$$\n每个基因组的新预期突变数$M_{new}(x)$为：\n$$M_{new}(x) = L \\cdot R_{new}(x) = L r_{0} \\left[1 - p \\left(1 - \\frac{x}{100}\\right)\\right] (1 - q)$$\n\n问题要求推导预期突变数的*增加量*$\\Delta M(x)$，即新预期值与基线预期值之差：\n$$\\Delta M(x) = M_{new}(x) - M_{baseline}$$\n代入上面推导出的表达式：\n$$\\Delta M(x) = \\left( L r_{0} \\left[1 - p \\left(1 - \\frac{x}{100}\\right)\\right] (1 - q) \\right) - \\left( L r_{0} (1 - p) (1 - q) \\right)$$\n我们可以提出公因式$L r_{0} (1 - q)$：\n$$\\Delta M(x) = L r_{0} (1 - q) \\left[ \\left(1 - p \\left(1 - \\frac{x}{100}\\right)\\right) - (1 - p) \\right]$$\n现在，我们简化方括号内的表达式：\n$$ \\left[ 1 - p + \\frac{px}{100} \\right] - (1 - p) = 1 - p + \\frac{px}{100} - 1 + p = \\frac{px}{100} $$\n将此结果代回$\\Delta M(x)$的方程，得到最终的闭式表达式：\n$$\\Delta M(x) = L r_{0} (1 - q) \\left(\\frac{px}{100}\\right)$$\n这可以写成：\n$$\\Delta M(x) = \\frac{L r_{0} p x (1 - q)}{100}$$\n此表达式表示仅由于指定的校对效率降低而导致的每次细胞分裂每个基因组的预期额外突变数。", "answer": "$$\\boxed{\\frac{L r_{0} p x (1 - q)}{100}}$$", "id": "2403484"}, {"introduction": "复制机器并非在一条完美的线性轨道上行进；DNA 模板本身可以形成复杂的二级结构。回文序列能够自我折叠形成“发夹”结构，这会物理性地阻碍或暂停 DNA 聚合酶的前进。这项编码实践将要求你开发一种算法来扫描基因组并识别这些潜在的障碍，这是基因组序列分析中的一项基本技能 [@problem_id:2403464]。", "problem": "给定一份关于脱氧核糖核酸（DNA）字符串中反向互补回文子串的形式化定义，以及一个可能导致DNA依赖性DNA聚合酶停滞的发夹结构形成的简化生物物理标准。设字母表为 $\\{A,C,G,T\\}$。对于一个长度为 $N$ 的基因组字符串 $G$，一个发夹候选结构 (hairpin candidate) 是 $G$ 的任意子串 $H$，该子串可被划分为 $H = L \\cdot \\ell \\cdot R$，其中 $L$ 是长度为 $s$ 的左臂，$\\ell$ 是长度为 $l$ 的环，而 $R$ 是长度为 $s$ 的右臂，且 $s \\in \\mathbb{Z}_{\\ge 1}$ 及 $l \\in \\mathbb{Z}_{\\ge 1}$。定义互补映射 $c$ 为 $c(A)=T$、$c(T)=A$、$c(C)=G$ 和 $c(G)=C$。对于每个位置 $j \\in \\{0,1,\\dots,s-1\\}$，在 $L[j]$ 和 $R[s-1-j]$ 之间定义一个碱基对。如果 $R[s-1-j] = c(L[j])$，则该碱基对为匹配 (match)；否则为错配 (mismatch)。令 $b$ 为总匹配数， $m$ 为总错配数，因此 $m = s - b$。令 $g$ 为鸟嘌呤-胞嘧啶 (GC) 对的匹配数，即满足 $\\{L[j],R[s-1-j]\\} = \\{G,C\\}$ 的匹配。定义GC分数 $f_{\\mathrm{GC}}$ 为：如果 $b \\neq 0$，则 $f_{\\mathrm{GC}}=g/b$；如果 $b=0$，则 $f_{\\mathrm{GC}} = 0$。\n\n一个发夹候选结构 $H$ 被预测为能形成稳定发夹结构并停滞聚合酶，当且仅当以下所有条件同时成立：\n- 茎长约束：$s_{\\min} \\le s \\le s_{\\max}$。\n- 环长约束：$l_{\\min} \\le l \\le l_{\\max}$。\n- 错配容忍度：$m \\le k_{\\max}$。\n- 最少配对数：$b \\ge b_{\\min}$。\n- 最低GC分数：$f_{\\mathrm{GC}} \\ge f_{\\mathrm{GC}}^{\\min}$。\n\n对于给定的基因组 $G$ 和参数 $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min})$，定义任务输出为 $G$ 中满足上述标准的独立发夹实例 (distinct hairpin instances) 的总数。其中，独立的实例由三元组 $(i,s,l)$ 定义，$i \\in \\{0,1,\\dots,N-(2s+l)\\}$ 为 $H$ 在 $G$ 中的起始索引，$s$ 和 $l$ 的定义如上。\n\n您的程序必须精确实现此定义，并为以下测试套件生成所需的输出。每个测试用例是一个元组，包含一个基因组字符串 $G$ 和一个七元参数组 $(s_{\\min}, s_{\\max}, l_{\\min}, l_{\\max}, k_{\\max}, b_{\\min}, f_{\\mathrm{GC}}^{\\min})$：\n\n- 测试用例 1 （通用富含GC的回文）：\n  - $G =$ \"AAAGCGCTTGCGCAAATTT\"\n  - 参数：$(4, 4, 2, 2, 0, 4, 0.75)$\n- 测试用例 2 （边界情况，恰好一个错配且GC分数在阈值上）：\n  - $G =$ \"TTTATCAAAGTTCCC\"\n  - 参数：$(3, 3, 3, 3, 1, 2, 0.5)$\n- 测试用例 3 （在严格约束下无有效发夹）：\n  - $G =$ \"ATCAAAGTT\"\n  - 参数：$(3, 3, 3, 3, 0, 3, 1.0)$\n- 测试用例 4 （两个分离的强发夹，均富含GC）：\n  - $G =$ \"AAAGCGCTTGCGCTTTCCGGAACCGGAAA\"\n  - 参数：$(4, 4, 2, 2, 0, 4, 1.0)$\n- 测试用例 5 （在阈值上的包含性，GC分数为 $\\frac{2}{3}$ 且错配数达到上限）：\n  - $G =$ \"AAAGTATCAAAGGTCCAAA\"\n  - 参数：$(5, 5, 3, 3, 2, 3, \\frac{2}{3})$\n\n角度单位不适用，也不涉及任何物理单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，列表顺序与上述测试用例的顺序一致（从测试用例1到测试用例5）。例如，要求的格式是“[rA,rB,rC,rD,rE]”，其中每一项是对应测试用例的整数计数。", "solution": "该问题陈述已经过严格验证，被认为是科学上可靠、定义明确且客观的。它为DNA发夹结构的形成提供了一个简化但连贯的生物物理模型，已知这些结构与复制过程中DNA聚合酶的停滞有关。所有术语、参数和标准都经过数学上的精确定义，使得问题清晰明确且可通过算法求解。未发现任何矛盾、信息缺失或伪科学主张。因此，解决方案不仅是可能的，而且是必需的。\n\n任务是枚举给定基因组字符串 $G$ 中所有满足一组同步生物物理和结构约束的独立发夹实例。一个独立的实例由一个三元组 $(i, s, l)$ 唯一标识，其中 $i$ 是发夹候选结构 $H$ 在 $G$ 中以0为基准的起始位置，$s$ 是茎臂的长度，$l$ 是环的长度。\n\n方法论是直接对所有可能的发夹候选结构的整个空间进行穷举搜索。该算法按如下方式系统地进行：\n\n1.  **候选结构生成**：我们根据输入参数 $(s_{\\min}, s_{\\max})$ 和 $(l_{\\min}, l_{\\max})$ 的约束，遍历茎长 $s$ 和环长 $l$ 的所有允许整数值。\n    $$ s \\in [s_{\\min}, s_{\\max}] $$\n    $$ l \\in [l_{\\min}, l_{\\max}] $$\n    对于每个有效的对 $(s, l)$，发夹候选结构 $H$ 的总长度为 $2s+l$。然后，我们遍历该候选结构在长度为 $N$ 的基因组 $G$ 中的所有可能的起始位置 $i$。\n    $$ i \\in [0, N - (2s+l)] $$\n    这种三重循环结构确保每个由 $(i, s, l)$ 定义的潜在发夹候选结构都被恰好考虑一次。\n\n2.  **子结构划分**：对于每个候选三元组 $(i,s,l)$，我们提取相应的子串 $H = G[i:i+2s+l]$。该子串被划分为其组成部分：左臂 $L$、环 $\\ell$ 和右臂 $R$。\n    -   $L = G[i:i+s]$\n    -   $\\ell = G[i+s:i+s+l]$\n    -   $R = G[i+s+l:i+2s+l]$\n\n3.  **生物物理分析**：然后我们分析左臂 $L$ 和右臂 $R$ 之间的配对潜力。根据问题定义，对于每个位置 $j \\in \\{0, 1, \\dots, s-1\\}$，在 $L[j]$ 和 $R[s-1-j]$ 之间形成一个碱基对。我们必须量化以下属性：\n    -   总匹配数 $b$，其中 $R[s-1-j] = c(L[j])$，$c$ 是互补映射 $\\{A \\leftrightarrow T, C \\leftrightarrow G\\}$。\n    -   总错配数 $m$，即 $m = s-b$。\n    -   鸟嘌呤-胞嘧啶 (GC) 匹配数 $g$，其中匹配涉及对 $\\{G,C\\}$。\n\n4.  **约束验证**：对于由 $(i,s,l)$ 定义的候选结构，其计算出的属性 $(b, m, g)$ 将根据给定的稳定性标准进行验证：\n    -   错配容忍度：$m \\le k_{\\max}$\n    -   最少配对数：$b \\ge b_{\\min}$\n    -   最低GC分数：一个关键的检查涉及GC分数 $f_{\\mathrm{GC}}$。其定义为：如果 $b \\neq 0$，则 $f_{\\mathrm{GC}} = g/b$；如果 $b=0$，则 $f_{\\mathrm{GC}} = 0$。此计算值必须满足 $f_{\\mathrm{GC}} \\ge f_{\\mathrm{GC}}^{\\min}$。\n\n5.  **枚举**：如果一个候选结构 $(i,s,l)$ 同时满足所有指定约束，则计为一个有效的发夹实例。在所有评估的候选结构中累加总数。\n\n这种穷举枚举提供了问题陈述所要求的精确、唯一且正确的解。每个测试用例的最终结果是此类有效 $(i,s,l)$ 三元组的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA hairpin counting problem for a suite of test cases.\n    \"\"\"\n    \n    # The complement map for DNA bases.\n    complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            \"AAAGCGCTTGCGCAAATTT\",\n            (4, 4, 2, 2, 0, 4, 0.75)\n        ),\n        (\n            \"TTTATCAAAGTTCCC\",\n            (3, 3, 3, 3, 1, 2, 0.5)\n        ),\n        (\n            \"ATCAAAGTT\",\n            (3, 3, 3, 3, 0, 3, 1.0)\n        ),\n        (\n            \"AAAGCGCTTGCGCTTTCCGGAACCGGAAA\",\n            (4, 4, 2, 2, 0, 4, 1.0)\n        ),\n        (\n            \"AAAGTATCAAAGGTCCAAA\",\n            (5, 5, 3, 3, 2, 3, 2/3)\n        ),\n    ]\n\n    def count_hairpins(G, params):\n        \"\"\"\n        Calculates the number of valid hairpin instances in a genome string.\n        \"\"\"\n        s_min, s_max, l_min, l_max, k_max, b_min, f_gc_min = params\n        N = len(G)\n        valid_hairpin_count = 0\n\n        # Iterate over all possible stem lengths s\n        for s in range(s_min, s_max + 1):\n            if s < 1: continue\n\n            # Iterate over all possible loop lengths l\n            for l in range(l_min, l_max + 1):\n                if l < 1: continue\n\n                hairpin_len = 2 * s + l\n                if hairpin_len > N:\n                    continue\n\n                # Iterate over all possible start positions i\n                for i in range(N - hairpin_len + 1):\n                    # Extract hairpin candidate substructures\n                    L = G[i : i + s]\n                    # Loop ell is G[i + s : i + s + l]\n                    R = G[i + s + l : i + hairpin_len]\n                    \n                    # Calculate biophysical properties\n                    b = 0  # matches\n                    g = 0  # GC matches\n                    \n                    for j in range(s):\n                        base_L = L[j]\n                        base_R = R[s - 1 - j]\n                        \n                        if complement_map.get(base_L) == base_R:\n                            b += 1\n                            if base_L in ('G', 'C'):\n                                g += 1\n                    \n                    m = s - b # mismatches\n\n                    # Check stability criteria\n                    # 1. Stem length (implicit in loop bounds)\n                    # 2. Loop length (implicit in loop bounds)\n                    # 3. Mismatch tolerance\n                    if m > k_max:\n                        continue\n                    \n                    # 4. Minimum pairing\n                    if b < b_min:\n                        continue\n                        \n                    # 5. Minimum GC fraction\n                    if b == 0:\n                        f_gc = 0.0\n                    else:\n                        f_gc = g / b\n                    \n                    if f_gc < f_gc_min:\n                        continue\n                        \n                    # If all criteria are met, this is a valid hairpin instance\n                    valid_hairpin_count += 1\n                        \n        return valid_hairpin_count\n\n    results = []\n    for genome, parameters in test_cases:\n        result = count_hairpins(genome, parameters)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403464"}, {"introduction": "在真核生物中，复制并非随机起始，而是在特定的“复制起始点”开始，并在“终止区”结束。这些事件在全基因组复制时间图谱中留下了特征性模式，起始区通常呈现为“U形”波谷，而终止区则呈现为“N形”波峰。这项练习将挑战你运用统计模型拟合——这是现代生物信息学的基石——来处理含噪声的数据，从而构建一个能够区分这些关键基因组特征的分类器 [@problem_id:2403516]。", "problem": "您的任务是构建一个确定性分类器，使用简化的合成复制时间图谱来区分与脱氧核糖核酸（DNA）复制的起始区和终止区相对应的基因组窗口。在复制时间数据中，起始区通常表现为U形谷，而终止区则通常表现为倒U形轮廓（N形）。在此任务中，每个复制时间图谱都表示为一个一维基因组坐标的标量函数的一组离散样本。\n\n每个测试用例通过在闭区间 $\\left[-1,1\\right]$ 上的 $n$ 个等间距坐标 $x_i$（其中 $i \\in \\{1,2,\\dots,n\\}$）上采样，来定义一个窗口内的合成复制时间图谱。在坐标 $x_i$ 处观测到的复制时间值由下式给出：\n$$\ny_i \\;=\\; a\\,(x_i - c)^2 + b + d\\,x_i + \\varepsilon_i,\n$$\n其中 $a, b, c, d$ 是实值参数，而 $\\varepsilon_i$ 是来自均值为 $0$、标准差为 $\\sigma$ 的正态分布的独立同分布样本。坐标网格定义为 $x_i = -1 + \\dfrac{2(i-1)}{n-1}$，其中 $i = 1,\\dots,n$。标签由内在曲率参数 $a$ 的符号定义：如果 $a > 0$，则为起始区（U形）；如果 $a < 0$，则为终止区（N形）。然而，在确定标签时，您必须仅将可观测的数对 $(x_i, y_i)$ 视为可用数据；不允许依赖隐藏的生成参数 $a$。\n\n您的程序必须为以下测试套件构建图谱，并按顺序为每个测试用例输出一个二元预测，规则如下：预测为起始区（U形）输出 $1$，预测为终止区（N形）输出 $0$。不提供用户输入；所需的所有量均在此处指定。没有需要报告的物理单位。不使用角度。所有输出必须是整数。\n\n测试套件（每个项目符号描述一个测试用例，必须按确切顺序进行评估）：\n\n- 用例 $1$：$n = 101$，$a = 0.8$，$b = 0.05$，$c = 0.0$，$d = 0.0$，$\\sigma = 0.05$，随机种子 $= 41$。\n- 用例 $2$：$n = 101$，$a = -0.7$，$b = -0.02$，$c = 0.2$，$d = 0.0$，$\\sigma = 0.05$，随机种子 $= 7$。\n- 用例 $3$：$n = 121$，$a = 0.4$，$b = 0.0$，$c = -0.2$，$d = 0.3$，$\\sigma = 0.07$，随机种子 $= 99$。\n- 用例 $4$：$n = 121$，$a = -0.5$，$b = 0.1$，$c = 0.1$，$d = -0.2$，$\\sigma = 0.08$，随机种子 $= 123$。\n- 用例 $5$：$n = 81$，$a = 0.25$，$b = 0.0$，$c = 0.0$，$d = -0.1$，$\\sigma = 0.15$，随机种子 $= 2025$。\n- 用例 $6$：$n = 81$，$a = -0.2$，$b = 0.05$，$c = -0.1$，$d = 0.0$，$\\sigma = 0.05$，随机种子 $= 555$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[1,0,1,1,0,0]”），结果的顺序与上述测试用例的顺序相同，不含任何其他文本。要求的输出是整数，且必须以长度为 $6$ 的列表形式报告。", "solution": "所提出的问题是统计估计和分类中的一个标准练习，因此是有效的。它要求构建一个确定性分类器，根据其形状来区分两类合成的基因组图谱。分类将在一个包含随机成分的已知模型所生成的数据上进行。\n\n其底层的物理过程由以下方程建模：\n$$ y_i \\;=\\; a(x_i - c)^2 + b + d x_i + \\varepsilon_i $$\n其中，对于 $i \\in \\{1, \\dots, n\\}$，$(x_i, y_i)$ 代表可观测数据，$\\varepsilon_i$ 是来自正态分布 $\\mathcal{N}(0, \\sigma^2)$ 的独立同分布随机变量，而 $a, b, c, d$ 是定义信号的隐藏参数。\n\n分类规则基于参数 $a$ 的符号。$a$ 的正值对应于‘起始’图谱（U形，上凹），而 $a$ 的负值对应于‘终止’图谱（N形，下凹）。任务是从观测数据 $(x_i, y_i)$ 中单独推断出这个符号。\n\n要完成此任务，我们必须首先识别模型方程的结构。通过展开二次项，方程可以重写为：\n$$ y_i = a x_i^2 - 2ac x_i + ac^2 + b + d x_i + \\varepsilon_i $$\n按 $x_i$ 的幂次对各项进行分组，揭示了一个简单的多项式结构：\n$$ y_i = (a) x_i^2 + (d - 2ac) x_i + (ac^2 + b) + \\varepsilon_i $$\n这是一个形式为 $y_i = \\beta_2 x_i^2 + \\beta_1 x_i + \\beta_0 + \\varepsilon_i$ 的二次模型，其中系数定义如下：\n$$ \\beta_2 = a $$\n$$ \\beta_1 = d - 2ac $$\n$$ \\beta_0 = ac^2 + b $$\n用于分类的关键参数 $a$ 与二次项的系数 $\\beta_2$ 完全相同。因此，问题简化为从含噪声的数据中估计 $\\beta_2$ 并确定其符号。\n\n估计此类线性模型系数的标准且最优的方法是最小二乘法。我们寻求找到一组估计系数 $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2]^T$，以最小化残差平方和（$SSR$）：\n$$ SSR = \\sum_{i=1}^{n} (y_i - (\\hat{\\beta}_0 + \\hat{\\beta}_1 x_i + \\hat{\\beta}_2 x_i^2))^2 $$\n该问题可以用矩阵代数表示。令 $\\mathbf{y}$ 为观测值 $[y_1, \\dots, y_n]^T$ 的 $n \\times 1$ 列向量。令 $\\mathbf{X}$ 为 $n \\times 3$ 的设计矩阵，其中每一行对应一个观测值，每一列对应一个预测项：\n$$\n\\mathbf{X} = \\begin{pmatrix}\n1 & x_1 & x_1^2 \\\\\n1 & x_2 & x_2^2 \\\\\n\\vdots & \\vdots & \\vdots \\\\\n1 & x_n & x_n^2\n\\end{pmatrix}\n$$\n于是线性模型为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$。最小化 $\\|\\mathbf{y} - \\mathbf{X}\\hat{\\boldsymbol{\\beta}}\\|^2$ 的最小二乘解 $\\hat{\\boldsymbol{\\beta}}$ 由正规方程组的解给出：\n$$ \\mathbf{X}^T \\mathbf{X} \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y} $$\n假设 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的，则解为：\n$$ \\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y} $$\n在数值上，该解可以通过诸如QR分解等方法高效计算，这些方法已在标准科学计算库中实现。\n\n我们对参数 $a$ 的估计值是二次项的估计系数，即 $\\hat{a} = \\hat{\\beta}_2$。于是，分类规则明确建立如下：\n- 如果 $\\hat{\\beta}_2 > 0$，则图谱被分类为起始区（标签 $1$）。\n- 如果 $\\hat{\\beta}_2 \\le 0$，则图谱被分类为终止区（标签 $0$）。\n\n对于每个测试用例，流程如下：\n1.  设置随机数生成器种子以确保可复现性。\n2.  在区间 $[-1, 1]$ 上生成 $n$ 个坐标 $x_i$。\n3.  从 $\\mathcal{N}(0, \\sigma^2)$ 生成 $n$ 个噪声样本 $\\varepsilon_i$。\n4.  使用给定的参数 $a, b, c, d, \\sigma$ 计算观测数据 $y_i$。\n5.  构建设计矩阵 $\\mathbf{X}$ 和观测向量 $\\mathbf{y}$。\n6.  求解最小二乘问题以得到 $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2]^T$。\n7.  根据 $\\hat{\\beta}_2$ 的符号应用决策规则，以获得分类标签。\n\n此流程将应用于所有指定的测试用例，以生成最终的预测列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the classification problem for a suite of synthetic DNA replication timing profiles.\n    The method involves fitting a quadratic model to the data using least squares\n    and classifying based on the sign of the estimated quadratic coefficient.\n    \"\"\"\n    test_cases = [\n        # n, a, b, c, d, sigma, seed\n        (101, 0.8, 0.05, 0.0, 0.0, 0.05, 41),\n        (101, -0.7, -0.02, 0.2, 0.0, 0.05, 7),\n        (121, 0.4, 0.0, -0.2, 0.3, 0.07, 99),\n        (121, -0.5, 0.1, 0.1, -0.2, 0.08, 123),\n        (81, 0.25, 0.0, 0.0, -0.1, 0.15, 2025),\n        (81, -0.2, 0.05, -0.1, 0.0, 0.05, 555),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n, a, b, c, d, sigma, seed = case\n        \n        # 1. Set the random seed for reproducibility.\n        np.random.seed(seed)\n        \n        # 2. Generate the coordinate grid over [-1, 1].\n        x = np.linspace(-1, 1, int(n))\n        \n        # 3. Generate Gaussian noise.\n        epsilon = np.random.normal(loc=0.0, scale=sigma, size=int(n))\n        \n        # 4. Compute the observed data y using the generative model.\n        y = a * (x - c)**2 + b + d * x + epsilon\n        \n        # 5. Construct the design matrix for quadratic regression.\n        # The model is y = beta_0 + beta_1*x + beta_2*x^2.\n        # The columns represent powers of x: x^0, x^1, x^2.\n        X = np.vstack([np.ones_like(x), x, x**2]).T\n        \n        # 6. Solve the linear least-squares problem to find the coefficients.\n        # The solution vector beta_hat corresponds to [beta_0, beta_1, beta_2].\n        beta_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # 7. The estimated quadratic coefficient, a_hat, is the third element.\n        a_hat = beta_hat[2]\n        \n        # 8. Apply the decision rule:\n        # 1 for initiation (U-shaped, a > 0), 0 for termination (N-shaped, a < 0).\n        prediction = 1 if a_hat > 0 else 0\n        results.append(prediction)\n\n    # 9. Format the output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403516"}]}