{"hands_on_practices": [{"introduction": "掌握遗传密码的第一步是能够将信使RNA（mRNA）序列准确地翻译成氨基酸序列。这个基础练习模拟了细胞内蛋白质合成的核心过程，要求你从一个给定的mRNA序列中识别出正确的阅读框架。通过这个实践 [@problem_id:1527156]，你将能够熟练运用密码子表，理解起始密码子和终止密码子在确定多肽链长度和序列中的关键作用。", "problem": "一位分子生物学家从一种新型嗜热细菌中分离出了一段成熟的信使核糖核酸（mRNA）的短片段。该mRNA片段的序列，从5'端到3'端读取，如下所示：\n\n5'-GCAUGGUUAGCAGCACGUAG-3'\n\n该mRNA翻译成多肽链的过程从第一个起始密码子（AUG）开始，并在到达第一个框内终止密码子时终止。使用提供的标准遗传密码表，确定从此mRNA片段合成的多肽的正确氨基酸序列。\n\n**遗传密码表（密码子 -> 氨基酸）：**\n\n*   **丙氨酸 (Ala):** GCU, GCC, GCA, GCG\n*   **精氨酸 (Arg):** CGU, CGC, CGA, CGG, AGA, AGG\n*   **天冬酰胺 (Asn):** AAU, AAC\n*   **天冬氨酸 (Asp):** GAU, GAC\n*   **半胱氨酸 (Cys):** UGU, UGC\n*   **谷氨酸 (Glu):** GAA, GAG\n*   **谷氨酰胺 (Gln):** CAA, CAG\n*   **甘氨酸 (Gly):** GGU, GGC, GGA, GGG\n*   **组氨酸 (His):** CAU, CAC\n*   **异亮氨酸 (Ile):** AUU, AUC, AUA\n*   **亮氨酸 (Leu):** UUA, UUG, CUU, CUC, CUA, CUG\n*   **赖氨酸 (Lys):** AAA, AAG\n*   **甲硫氨酸 (Met) / 起始:** AUG\n*   **苯丙氨酸 (Phe):** UUU, UUC\n*   **脯氨酸 (Pro):** CCU, CCC, CCA, CCG\n*   **丝氨酸 (Ser):** UCU, UCC, UCA, UCG, AGU, AGC\n*   **苏氨酸 (Thr):** ACU, ACC, ACA, ACG\n*   **色氨酸 (Trp):** UGG\n*   **酪氨酸 (Tyr):** UAU, UAC\n*   **缬氨酸 (Val):** GUU, GUC, GUA, GUG\n*   **终止:** UAA, UAG, UGA\n\n下列哪项代表了正确的多肽序列？\n\nA. Ala-Trp-Leu-Ala-Ala-Arg\n\nB. Met-Val-Ser-Ser-Thr\n\nC. Ala-Gly-Ser-Ser-Thr\n\nD. Met-Val-Ser-Ser-Thr-Tyr\n\nE. Met-Gly-Ser-Ser-Thr-Arg", "solution": "原理：\n- mRNA的翻译从核糖体沿5'端扫描时遇到的第一个起始密码子AUG开始，并以此阅读框进行。\n- 从起始位点开始，密码子以不重叠的三联体形式被读取，直到遇到第一个框内终止密码子（UAA、UAG或UGA）。\n\n步骤：\n1) 给定的mRNA序列（5' 到 3'）是GCAUGGUUAGCAGCACGUAG。从5'端开始扫描寻找第一个AUG。第一个AUG出现在第三个核苷酸处，因此阅读框从这个AUG开始。\n\n2) 从该AUG开始，将序列划分为密码子：\nAUG GUU AGC AGC ACG UAG\n\n3) 使用提供的遗传密码表翻译每个密码子：\n- AUG → 甲硫氨酸 (Met)，起始\n- GUU → 缬氨酸 (Val)\n- AGC → 丝氨酸 (Ser)\n- AGC → 丝氨酸 (Ser)\n- ACG → 苏氨酸 (Thr)\n- UAG → 终止\n\n4) 合成的多肽序列是Met-Val-Ser-Ser-Thr，在UAG终止密码子处结束。\n\n5) 与选项匹配：这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1527156"}, {"introduction": "遗传密码的解读严格遵循三联体规则，一旦这个阅读框架被打破，其后果可能是灾难性的。本练习通过一个假设的场景，对比了单个核苷酸缺失和整个密码子缺失两种突变类型。通过分析这两种情况 [@problem_id:2342150]，你将深刻理解“移码突变”为何通常比“框内缺失”对蛋白质功能的影响更为严重，从而对基因序列的完整性有更深入的认识。", "problem": "一位研究人员正在研究一个基因，该基因编码一种由150个氨基酸组成的小酶，对细胞代谢至关重要。这种酶的正常功能取决于其精确的三维结构。该基因编码序列在DNA模板链上的起始部分如下：\n`3'-TAC CCG AAT GCT...-5'`\n这对应于由核糖体翻译的信使RNA (mRNA) 序列：\n`5'-AUG GGC UUA CGA...-3'`\n\n在该基因座上，两种不同的突变被引入到不同的细胞培养物中。\n\n*   **突变1：** 模板DNA链上第二个密码子中的第一个胞嘧啶（C）核苷酸缺失。\n*   **突变2：** 模板DNA链上的整个第二个密码子“CCG”缺失。\n\n假设在这两种情况下，转录和翻译都越过了突变位点，并且遗传密码以非重叠的三联体形式读取。下列哪项陈述最准确地预测并比较了这两种突变基因产生的酶的功能性后果？\n\nA. 两种突变都将是同样灾难性的，导致产生完全无功能的蛋白质，因为它们都发生在基因的起始位置附近。\nB. 突变2可能比突变1对酶功能的损害更大，因为它涉及更多遗传物质的丢失。\nC. 突变1可能比突变2对酶功能的影响更严重，因为它将改变突变位点下游的整个氨基酸序列，并可能导致翻译提前终止。\nD. 突变2的影响会更严重，因为删除整个密码子是细胞校对机制无法纠正的改变，这与单个碱基的缺失不同。\nE. 突变1的影响会较小，因为只丢失了一个核苷酸，产生的蛋白质与原始蛋白质几乎相同，而突变2导致丢失一个完整的氨基酸。", "solution": "对所提供序列和遗传密码原则的解读：\n- 模板DNA链按3'到5'方向给出：3'-TAC CCG AAT GCT...-5'。根据标准碱基配对规则和反向平行转录，mRNA为5'-AUG GGC UUA CGA...-3'，其翻译结果为：AUG (Met), GGC (Gly), UUA (Leu), CGA (Arg), ...\n- 核糖体从AUG开始以非重叠的三联体形式读取mRNA；任何非三的倍数的插入或缺失都会改变读码框（移码突变），从而改变所有下游的密码子，并通常会引入一个提前的终止密码子。\n\n分析突变1（模板链第二个密码子中第一个C的缺失）：\n- 起始部分原始模板：3'-TAC CCG AAT GCT...-5'。\n- 删除第二个密码子的第一个C后得到：3'-TAC CGA ATG CT...-5'。\n- 从起始密码子开始转录，mRNA的起始部分仍为5'-AUG（第一个密码子未改变）。继续经过缺失位点，初始TAC之后的模板碱基现在是CGA ATG CT...，转录成的mRNA碱基为GCU UAC GA...，因此从起始处开始的突变mRNA为：5'-AUG GCU UAC GA...-3'。\n- 从AUG开始分组为密码子：AUG | GCU | UAC | GA...，这与原始的AUG | GGC | UUA | CGA...不同。\n- 这是一个从第二个密码子开始的移码突变：每个下游密码子都被改变，并且很可能很快出现一个提前的终止密码子（UAA、UAG或UGA），从而产生一个被截短、错误折叠且几乎肯定无功能的酶。由于此移码突变发生在起始位置附近，截短会发生得很早且很严重。\n\n分析突变2（整个第二个模板密码子CCG的缺失）：\n- 移除模板上的3'-CCG-5'后，模板变为：3'-TAC AAT GCT...-5'。\n- 相应的mRNA为5'-AUG UUA CGA...-3'。\n- 从头开始翻译得到 AUG (Met), UUA (Leu), CGA (Arg), ...；读码框得以保留，唯一的变化是丢失了由被删除的密码子编码的甘氨酸残基。蛋白质序列的其余部分保持不变。\n- 如果该残基至关重要，码内单个氨基酸的缺失会影响功能，但总的来说，其破坏性远小于一个会打乱序列并导致提前终止的早期移码突变。\n\n比较和结论：\n- 突变1在起始位置附近引起移码突变，改变了所有下游的氨基酸，并可能引入一个提前的终止密码子，从而产生一个严重截短、无功能的酶。\n- 突变2移除了一个氨基酸，但保留了读码框；蛋白质序列的其余部分得以维持，因此其功能性影响通常没有移码突变那么严重。\n- 因此，基于上述原因，最准确的陈述是突变1可能比突变2具有更严重的影响。\n\n因此，正确选项是C。", "answer": "$$\\boxed{C}$$", "id": "2342150"}, {"introduction": "我们今天使用的标准遗传密码是随机形成的，还是经过进化选择而优化的产物？这个问题是进化生物学和生物信息学的核心议题之一。这个高级实践将引导你使用计算方法，通过模拟和比较大量随机生成的遗传密码，来定量评估我们标准遗传密码的“容错”能力 [@problem_id:2435520]。这项练习不仅能让你体验如何用编程来探索复杂的生物学假说，更能让你领会到，自然选择是如何在分子层面塑造出一个能够最大程度缓冲突变有害影响的、精妙而鲁棒的编码系统。", "problem": "给定经典的“标准遗传密码”（美国国家生物技术信息中心翻译表 1），该密码将基于字母表 $\\{U,C,A,G\\}$ 的所有 RNA 密码子映射到 $20$ 种氨基酸及一个终止信号的集合。同时，对于每种氨基酸，给定一个标量物理化学性质，即 Kyte–Doolittle 亲疏水指数。请按如下方式定义一个代价泛函，该泛函用于量化所编码的氨基酸性质对单核苷酸突变的敏感度。\n\n令 $\\mathcal{C}$ 为所有 $64$ 个 RNA 密码子的集合，令 $\\mathcal{S} \\subset \\mathcal{C}$ 为有义密码子的子集（即 $\\mathcal{C}$ 中排除终止密码子）。定义一个无向邻接集 $\\mathcal{E} \\subset \\{\\{c_i,c_j\\} \\mid c_i,c_j \\in \\mathcal{S}, c_i \\neq c_j\\}$，其中仅包含满足汉明距离为 $1$ 的无序对 $\\{c_i,c_j\\}$（即 $c_i$ 和 $c_j$ 仅有一个核苷酸不同）。对于任意相邻对 $\\{c_i,c_j\\} \\in \\mathcal{E}$，定义突变权重 $w(c_i,c_j)$：如果差异核苷酸构成转换（嘌呤 $\\leftrightarrow$ 嘌呤 或 嘧啶 $\\leftrightarrow$ 嘧啶，其中 $\\{A,G\\}$ 为嘌呤，$\\{C,U\\}$ 为嘧啶），则 $w(c_i,c_j) = w_t$；否则（此情况为颠换）$w(c_i,c_j) = w_v$。\n\n令 $h:\\mathcal{A} \\to \\mathbb{R}$ 为 $20$ 种氨基酸集合 $\\mathcal{A}$ 上的 Kyte–Doolittle 亲疏水指数。对于一个遗传密码（一个映射 $g:\\mathcal{C} \\to \\mathcal{A}\\cup\\{\\text{Stop}\\}$），定义其误差代价为\n$$\n\\operatorname{Cost}(g;w_t,w_v) \\;=\\; \\frac{1}{|\\mathcal{E}|} \\sum_{\\{c_i,c_j\\}\\in\\mathcal{E}} w(c_i,c_j)\\,\\big(h(g(c_i)) - h(g(c_j))\\big)^2.\n$$\n\n您将比较标准遗传密码 $g_{\\text{std}}$ 与在两种模型下随机生成的备选密码系综：\n- 简并性保持模型：对于每种氨基酸 $a \\in \\mathcal{A}$，令 $n_a$ 为标准遗传密码 $g_{\\text{std}}$ 中映射到 $a$ 的有义密码子数量。一个随机密码 $g$ 是从所有双射 $g:\\mathcal{S}\\to L$ 中均匀采样的，其中 $L$ 是一个多重集，每种氨基酸 $a$ 在其中恰好出现 $n_a$ 次；终止密码子保持不变。\n- 无约束模型：$\\mathcal{S}$ 中的每个有义密码子都被赋予一个从 $\\mathcal{A}$ 中独立且均匀抽取的氨基酸；终止密码子保持不变。\n\n对于给定的参数 $(M,w_t,w_v,b,\\text{seed})$，其中 $M$ 是要生成的随机密码数量，$w_t$ 和 $w_v$ 是非负实数权重，$b\\in\\{0,1\\}$ 指示模型类型（$b=1$ 为简并性保持模型，$b=0$ 为无约束模型），$\\text{seed}$ 用于初始化伪随机数生成器，请计算以下比例：\n$$\nq \\;=\\; \\frac{1}{M}\\sum_{m=1}^{M} \\mathbf{1}\\left\\{\\operatorname{Cost}(g^{(m)};w_t,w_v) \\;<\\; \\operatorname{Cost}(g_{\\text{std}};w_t,w_v)\\right\\},\n$$\n其中 $g^{(m)}$ 是采样得到的随机密码，$\\mathbf{1}\\{\\cdot\\}$ 是示性函数。\n\n请使用以下明确数据：\n\n- 标准遗传密码映射 $g_{\\text{std}}$（RNA 密码子到氨基酸单字母代码，包括 Stop）：\n$UUU\\mapsto F$, $UUC\\mapsto F$, $UUA\\mapsto L$, $UUG\\mapsto L$, $UCU\\mapsto S$, $UCC\\mapsto S$, $UCA\\mapsto S$, $UCG\\mapsto S$, $UAU\\mapsto Y$, $UAC\\mapsto Y$, $UAA\\mapsto \\text{Stop}$, $UAG\\mapsto \\text{Stop}$, $UGU\\mapsto C$, $UGC\\mapsto C$, $UGA\\mapsto \\text{Stop}$, $UGG\\mapsto W$, $CUU\\mapsto L$, $CUC\\mapsto L$, $CUA\\mapsto L$, $CUG\\mapsto L$, $CCU\\mapsto P$, $CCC\\mapsto P$, $CCA\\mapsto P$, $CCG\\mapsto P$, $CAU\\mapsto H$, $CAC\\mapsto H$, $CAA\\mapsto Q$, $CAG\\mapsto Q$, $CGU\\mapsto R$, $CGC\\mapsto R$, $CGA\\mapsto R$, $CGG\\mapsto R$, $AUU\\mapsto I$, $AUC\\mapsto I$, $AUA\\mapsto I$, $AUG\\mapsto M$, $ACU\\mapsto T$, $ACC\\mapsto T$, $ACA\\mapsto T$, $ACG\\mapsto T$, $AAU\\mapsto N$, $AAC\\mapsto N$, $AAA\\mapsto K$, $AAG\\mapsto K$, $AGU\\mapsto S$, $AGC\\mapsto S$, $AGA\\mapsto R$, $AGG\\mapsto R$, $GUU\\mapsto V$, $GUC\\mapsto V$, $GUA\\mapsto V$, $GUG\\mapsto V$, $GCU\\mapsto A$, $GCC\\mapsto A$, $GCA\\mapsto A$, $GCG\\mapsto A$, $GAU\\mapsto D$, $GAC\\mapsto D$, $GAA\\mapsto E$, $GAG\\mapsto E$, $GGU\\mapsto G$, $GGC\\mapsto G$, $GGA\\mapsto G$, $GGG\\mapsto G$.\n\n- Kyte–Doolittle 亲疏水指数 $h$（氨基酸单字母代码到实数值）：\n$A\\mapsto 1.8$, $R\\mapsto -4.5$, $N\\mapsto -3.5$, $D\\mapsto -3.5$, $C\\mapsto 2.5$, $Q\\mapsto -3.5$, $E\\mapsto -3.5$, $G\\mapsto -0.4$, $H\\mapsto -3.2$, $I\\mapsto 4.5$, $L\\mapsto 3.8$, $K\\mapsto -3.9$, $M\\mapsto 1.9$, $F\\mapsto 2.8$, $P\\mapsto -1.6$, $S\\mapsto -0.8$, $T\\mapsto -0.7$, $W\\mapsto -0.9$, $Y\\mapsto -1.3$, $V\\mapsto 4.2$.\n\n测试套件。对于以下每个参数集 $(M,w_t,w_v,b,\\text{seed})$，计算相应的 $q$ 值，并按所列顺序报告所有结果：\n- 情况 1：$(M,w_t,w_v,b,\\text{seed})=(10000,2.0,1.0,1,42)$。\n- 情况 2：$(M,w_t,w_v,b,\\text{seed})=(4000,1.0,1.0,1,123)$。\n- 情况 3：$(M,w_t,w_v,b,\\text{seed})=(2000,4.0,1.0,0,999)$。\n\n最终输出格式。您的程序应产生单行输出，其中包含三个实数值结果，形式为用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$）。输出行中不允许有额外的空白字符或文本。", "solution": "该问题陈述是计算生物学中一个有效、良定且有科学依据的练习。它要求评估标准遗传密码对单核苷酸突变的稳健性，该稳健性通过所编码氨基酸的物理化学性质的变化来量化。我将着手提供一个完整的解决方案。\n\n问题的核心是计算标准遗传密码 $g_{\\text{std}}$ 的代价泛函，并将其与大量随机生成的备选密码系综的代价值进行比较。最终要计算的量 $q$ 代表在给定的度量标准下，比标准密码更“优”（即具有更低代价）的随机密码所占的比例。\n\n首先，我们必须将所提供的数据和定义形式化为一个计算框架。\n核酸集合为 $\\mathcal{N} = \\{U, C, A, G\\}$。所有密码子的集合为 $\\mathcal{C} = \\mathcal{N}^3$，因此 $|\\mathcal{C}|=4^3=64$。所提供的标准遗传密码 $g_{\\text{std}}$ 将 $\\mathcal{C}$ 划分为 $21$ 个集合：对于集合 $\\mathcal{A}$ 中的 $20$ 种氨基酸各有一个集合，另有一个用于“终止”信号。我们已知有 $3$ 个终止密码子，这意味着有义密码子子集 $\\mathcal{S}$ 的大小为 $|\\mathcal{S}| = 64 - 3 = 61$。Kyte-Doolittle 亲疏水指数是一个函数 $h: \\mathcal{A} \\to \\mathbb{R}$。$g_{\\text{std}}$ 和 $h$ 均已提供，并将存储在字典数据结构中以便高效查找。\n\n代价泛函定义为：\n$$\n\\operatorname{Cost}(g;w_t,w_v) \\;=\\; \\frac{1}{|\\mathcal{E}|} \\sum_{\\{c_i,c_j\\}\\in\\mathcal{E}} w(c_i,c_j)\\,\\big(h(g(c_i)) - h(g(c_j))\\big)^2\n$$\n为了评估此泛函，我们必须首先构建邻接集 $\\mathcal{E}$。$\\mathcal{E}$ 由所有汉明距离为 $1$ 的不同有义密码子的无序对 $\\{c_i, c_j\\}$ 组成。我们将遍历所有 $\\binom{61}{2}$ 对有义密码子，检查它们的汉明距离，如果为 $1$，则将该对添加到一个代表 $\\mathcal{E}$ 的列表中。为了保证确定性，我们为这 $61$ 个有义密码子建立一个固定的、排序的顺序。然后，$\\mathcal{E}$ 的元素可以作为指向此有序列表的索引对来存储。\n\n对于 $\\mathcal{E}$ 中的每一对 $\\{c_i, c_j\\}$，我们还必须确定其突变权重 $w(c_i, c_j)$。该权重取决于单核苷酸替换是转换还是颠换。转换是同一化学类别内的替换：嘌呤 $\\leftrightarrow$ 嘌呤（$\\{A,G\\}$）或嘧啶 $\\leftrightarrow$ 嘧啶（$\\{C,U\\}$）。颠换是类别之间的替换。如果突变是转换，则 $w(c_i, c_j)=w_t$；否则，它是颠换，$w(c_i, c_j)=w_v$。在构建 $\\mathcal{E}$ 的过程中，我们识别每对密码子中的差异核苷酸并对突变进行分类，将此信息与索引对一起存储。密码子图和突变类型的这种预计算只需执行一次，因为它与遗传密码映射 $g$ 以及权重 $w_t, w_v$ 无关。\n\n有了这些结构，我们就可以实现一个函数 `calculate_cost(g, wt, wv)`，它接受一个密码 $g$（表示为有义密码子对应的氨基酸分配的有序列表）以及权重 $w_t$ 和 $w_v$。该函数遍历预先计算好的集合 $\\mathcal{E}$。对于每个边 $\\{c_i, c_j\\}$，它检索分配的氨基酸 $a_i = g(c_i)$ 和 $a_j = g(c_j)$，找到它们的亲疏水值 $h(a_i)$ 和 $h(a_j)$，确定相应的权重 $w_t$ 或 $w_v$，并将项 $w(c_i, c_j)(h(a_i) - h(a_j))^2$ 加到一个累加和中。最后，这个和将通过总边数 $|\\mathcal{E}|$进行归一化。\n\n对于每个测试案例 $(M, w_t, w_v, b, \\text{seed})$，主要流程包括以下几个步骤：\n1. 使用给定的 `seed` 初始化一个伪随机数生成器以确保可复现性。我们使用 `numpy.random.default_rng`。\n2. 计算参考代价 $\\operatorname{Cost}_{\\text{std}} = \\operatorname{Cost}(g_{\\text{std}}; w_t, w_v)$。这是用于与随机密码进行比较的基准。\n3. 初始化一个用于记录“更优”密码的计数器为 $0$。\n4. 循环运行 $M$ 次。在每次迭代中，根据参数 $b$ 指定的模型生成一个随机密码 $g^{(m)}$。\n    - 如果 $b=1$（简并性保持模型），我们必须保持标准遗传密码中分配给每种氨基酸的密码子数量不变。这通过创建一个由 $g_{\\text{std}}$ 分配给有义密码子的 $61$ 个氨基酸组成的列表，然后生成该列表的随机排列来实现。这个经过排列的列表代表了新随机密码 $g^{(m)}$ 的氨基酸分配。\n    - 如果 $b=0$（无约束模型），则为 $61$ 个有义密码子中的每一个从包含 $20$ 种氨基酸的集合 $\\mathcal{A}$ 中独立、均匀且有放回地抽取一个氨基酸进行分配。\n5. 对于每个随机生成的密码 $g^{(m)}$，计算其代价 $\\operatorname{Cost}(g^{(m)}; w_t, w_v)$。\n6. 将此代价与 $\\operatorname{Cost}_{\\text{std}}$ 进行比较。如果 $\\operatorname{Cost}(g^{(m)}) < \\operatorname{Cost}_{\\text{std}}$，则计数器递增。\n7. 经过 $M$ 次迭代后，最终结果 $q$ 是计数器的值除以 $M$。\n\n整个过程被封装在一个单独的程序中。首先执行预计算步骤，然后对指定的测试案例进行循环，每个案例都执行模拟并计算相应的 $q$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating the Standard Genetic Code's optimality.\n    \"\"\"\n    # Define the biological data as provided in the problem statement.\n    GENETIC_CODE_RAW = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': 'Stop', 'UAG': 'Stop',\n        'UGU': 'C', 'UGC': 'C', 'UGA': 'Stop', 'UGG': 'W',\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    HYDROPATHY_RAW = {\n        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,\n        'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,\n        'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,\n        'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2\n    }\n\n    NUCLEOTIDES = ['U', 'C', 'A', 'G']\n    PURINES = {'A', 'G'}\n    PYRIMIDINES = {'U', 'C'}\n\n    # 1. Pre-computation steps, performed once.\n    # Generate all codons and identify sense codons in a fixed order.\n    all_codons = sorted([n1 + n2 + n3 for n1 in NUCLEOTIDES for n2 in NUCLEOTIDES for n3 in NUCLEOTIDES])\n    \n    sense_codons = []\n    std_aa_assignments = []\n    for codon in all_codons:\n        aa = GENETIC_CODE_RAW.get(codon)\n        if aa != 'Stop':\n            sense_codons.append(codon)\n            std_aa_assignments.append(aa)\n\n    # 2. Build the adjacency graph E for sense codons.\n    # Store edges as {'i': <idx1>, 'j': <idx2>, 'type': <'transition'|'transversion'>}\n    num_sense_codons = len(sense_codons)\n    adjacency_info = []\n    for i in range(num_sense_codons):\n        for j in range(i + 1, num_sense_codons):\n            c1, c2 = sense_codons[i], sense_codons[j]\n            \n            diff_count = 0\n            diff_pos = -1\n            for k in range(3):\n                if c1[k] != c2[k]:\n                    diff_count += 1\n                    diff_pos = k\n            \n            if diff_count == 1:\n                nuc1, nuc2 = c1[diff_pos], c2[diff_pos]\n                is_transversion = (nuc1 in PURINES and nuc2 in PYRIMIDINES) or \\\n                                  (nuc1 in PYRIMIDINES and nuc2 in PURINES)\n                mut_type = 'transversion' if is_transversion else 'transition'\n                adjacency_info.append({'i': i, 'j': j, 'type': mut_type})\n    \n    num_edges = len(adjacency_info)\n\n    # 3. Define the cost function using pre-computed graph structure.\n    def calculate_cost(aa_assignments, wt, wv):\n        total_squared_error = 0.0\n        for edge in adjacency_info:\n            i, j = edge['i'], edge['j']\n            weight = wt if edge['type'] == 'transition' else wv\n            \n            h1 = HYDROPATHY_RAW[aa_assignments[i]]\n            h2 = HYDROPATHY_RAW[aa_assignments[j]]\n            \n            total_squared_error += weight * (h1 - h2)**2\n            \n        return total_squared_error / num_edges\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10000, 2.0, 1.0, 1, 42),\n        (4000, 1.0, 1.0, 1, 123),\n        (2000, 4.0, 1.0, 0, 999),\n    ]\n\n    results = []\n    amino_acid_pool = list(HYDROPATHY_RAW.keys())\n    \n    # Process each test case.\n    for M, wt, wv, b, seed in test_cases:\n        rng = np.random.default_rng(seed)\n        \n        # Calculate cost for the standard code as a benchmark.\n        cost_std = calculate_cost(std_aa_assignments, wt, wv)\n        \n        better_code_count = 0\n        for _ in range(M):\n            # Generate a random code based on the specified model.\n            if b == 1: # Degeneracy-preserving model\n                random_aa_assignments = rng.permutation(std_aa_assignments)\n            else: # Unconstrained model (b=0)\n                random_aa_assignments = rng.choice(amino_acid_pool, size=num_sense_codons, replace=True)\n            \n            # Calculate cost for the random code.\n            cost_random = calculate_cost(random_aa_assignments, wt, wv)\n            \n            # Compare to the standard code's cost.\n            if cost_random < cost_std:\n                better_code_count += 1\n                \n        q = better_code_count / M\n        results.append(q)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2435520"}]}