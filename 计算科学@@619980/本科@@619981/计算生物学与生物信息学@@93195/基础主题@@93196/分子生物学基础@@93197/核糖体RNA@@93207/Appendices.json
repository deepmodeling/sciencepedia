{"hands_on_practices": [{"introduction": "在rRNA这样的功能性分子中，并非所有核苷酸位点都同等重要。一些位点由于在维持关键结构或催化功能中扮演核心角色，在进化过程中表现出高度的保守性。本练习将引导你使用信息论中的一个强大工具——香农熵（Shannon Entropy），来量化多重序列比对中每个位点的变异程度，从而识别出这些受到功能约束的保守区域[@problem_id:2426486]。通过计算熵值$H_j$，你将亲身体验如何从序列数据中挖掘出关于rRNA功能的宝贵线索。", "problem": "给定一个固定的多序列比对，其包含来自小亚基核糖体RNA（rRNA）的片段，特别是$16\\mathrm{S}$ rRNA。该比对由 $M=8$ 条序列组成，每条序列的长度为 $L=12$，字符集为 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U},\\mathrm{T},\\mathrm{N},-\\}$。这些序列是：\n\n- $S_1$: \"AAAAANGACAAG\"\n- $S_2$: \"AAC-UNGACAAT\"\n- $S_3$: \"AAG-T-GACAAU\"\n- $S_4$: \"AAU-C-GAGAAC\"\n- $S_5$: \"AGA-ANGA-UAN\"\n- $S_6$: \"AGC-U-GA-UA-\"\n- $S_7$: \"AGGAT-G--UAA\"\n- $S_8$: \"AGU-CN---AAA\"\n\n对于每个比对列 $j \\in \\{1,\\dots,L\\}$，按如下方式解释字符：\n- 将 $\\mathrm{T}$ 视作 $\\mathrm{U}$。\n- 将符号 $\\mathrm{N}$ 和 $-$ 视作无信息字符，并将其从该列的所有频率和概率计算中排除。\n- 只有四种标准核糖核苷酸 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 对概率有贡献。\n\n设 $n(j)$ 为经过上述解释后第 $j$ 列中信息字符的数量，设 $n_b(j)$ 为第 $j$ 列中碱基 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 的数量。定义第 $j$ 列的经验碱基概率为\n$$\np_b(j) = \\frac{n_b(j)}{n(j)}\n$$\n适用于那些 $n_b(j) > 0$ 的碱基 $b$。定义第 $j$ 列的香农熵（单位：比特）为\n$$\nH_j = -\\sum_{\\substack{b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\} \\\\ p_b(j) > 0}} p_b(j)\\,\\log_2 p_b(j),\n$$\n并约定如果 $n(j)=0$，则 $H_j = 0$。定义第 $j$ 列的覆盖度为\n$$\nc_j = \\frac{n(j)}{M}.\n$$\n\n当且仅当一个列对于指定的阈值 $\\tau$ 和 $\\gamma$ 同时满足 $H_j \\le \\tau$ 和 $c_j \\ge \\gamma$ 时，该列被认为是功能受限的。\n\n您的任务是编写一个程序，对于上述比对，精确地按照定义计算每列 $j \\in \\{1,\\dots,12\\}$ 的 $H_j$ 和 $c_j$，并为以下每个参数对 $(\\tau,\\gamma)$，返回所有功能受限列的 $j$ 值列表，使用基于1的索引：\n\n测试套件（三组参数对）：\n- 案例 1: $(\\tau,\\gamma) = (0.0, 0.5)$\n- 案例 2: $(\\tau,\\gamma) = (1.0, 0.5)$\n- 案例 3: $(\\tau,\\gamma) = (2.0, 0.75)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有三个案例的结果，格式为一个由方括号括起来的逗号分隔列表，不含空格。每个案例的结果本身必须是一个由方括号括起来、逗号分隔的所选列索引（按升序排列）的列表。例如，一个包含三个案例的有效输出应如下所示：”[[1,2],[3],[4,5,6]]“。", "solution": "问题陈述已经过验证，并被认定为有效。它在科学上基于生物信息学的原理，特别是通过分析多序列比对来推断功能限制。该问题定义明确，提供了所有必要的数据和数学定义，以确保一个唯一且有意义的解。所有术语都是客观且精确定义的。\n\n任务是在一个给定的多序列比对中（包含 $M=8$ 条序列，每条长度为 $L=12$）识别出功能受限的列。如果一个列 $j$ 的香农熵 $H_j$ 和覆盖度 $c_j$ 满足条件 $H_j \\le \\tau$ 和 $c_j \\ge \\gamma$（其中 $(\\tau, \\gamma)$ 是给定的阈值），则该列被视为功能受限。\n\n解法系统地对每一列 $j \\in \\{1, \\dots, 12\\}$ 进行处理。\n\n首先，对每列的字符应用一个预处理步骤。碱基 $\\mathrm{T}$ 被视作 $\\mathrm{U}$，无信息字符（$\\mathrm{N}$、$-$）被丢弃。只有标准核糖核苷酸 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 被用于后续计算。\n\n设序列集合为 $\\{S_i\\}_{i=1}^M$。序列 $i$ 中第 $j$ 列的字符为 $S_i[j]$。\n对于每一列 $j$：\n1.  在进行 $\\mathrm{T} \\to \\mathrm{U}$ 转换后，通过计算 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 中的字符数量来确定信息字符数 $n(j)$。\n2.  覆盖度 $c_j$ 按信息字符的比例计算：\n    $$\n    c_j = \\frac{n(j)}{M} = \\frac{n(j)}{8}\n    $$\n3.  从信息字符中统计每种碱基 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ 的数量 $n_b(j)$。\n4.  计算每种碱基的经验概率：\n    $$\n    p_b(j) = \\frac{n_b(j)}{n(j)}\n    $$\n    此定义仅在 $n(j) > 0$ 时有效。\n5.  使用以下公式计算香农熵 $H_j$（单位：比特）：\n    $$\n    H_j = -\\sum_{\\substack{b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\} \\\\ n_b(j) > 0}} p_b(j)\\,\\log_2 p_b(j)\n    $$\n    如果 $n(j)=0$，根据问题定义，我们取 $H_j=0$。\n\n给定的比对如下：\n- $S_1$: \"AAAAANGACAAG\"\n- $S_2$: \"AAC-UNGACAAT\"\n- $S_3$: \"AAG-T-GACAAU\"\n- $S_4$: \"AAU-C-GAGAAC\"\n- $S_5$: \"AGA-ANGA-UAN\"\n- $S_6$: \"AGC-U-GA-UA-\"\n- $S_7$: \"AGGAT-G--UAA\"\n- $S_8$: \"AGU-CN---AAA\"\n\n每列计算出的 $H_j$ 和 $c_j$ 值总结在下表中。\n\n| 列 ($j$) | 处理后的字符 | $n(j)$ | 碱基计数 ($n_b(j)$) | $c_j$ | 香农熵 $H_j$ (比特) |\n|--------------|----------------------|--------|------------------------------|---------|------------------------------|\n| $1$ | `AAAAAAAA` | $8$ | A:$8$ | $1.0$ | $0.0$ |\n| $2$ | `AAAGGGGA` | $8$ | A:$4$, G:$4$ | $1.0$ | $1.0$ |\n| $3$ | `ACGGAGGU` | $8$ | A:$1$, C:$2$, G:$4$, U:$1$ | $1.0$ | $\\approx 1.811$ |\n| $4$ | `AAUCA` (T$\\to$U) | $5$ | A:$3$, C:$1$, U:$1$ | $0.625$ | $\\approx 1.371$ |\n| $5$ | `AUUCAUUC` (T$\\to$U) | $8$ | A:$2$, C:$2$, U:$4$ | $1.0$ | $1.5$ |\n| $6$ | | $0$ | - | $0.0$ | $0.0$ |\n| $7$ | `GGGGGGG` | $7$ | G:$7$ | $0.875$ | $0.0$ |\n| $8$ | `AAAGAA` | $6$ | A:$5$, G:$1$ | $0.75$ | $\\approx 0.650$ |\n| $9$ | `CCCAA` | $5$ | A:$2$, C:$3$ | $0.625$ | $\\approx 0.971$ |\n| $10$ | `AAAAUUAA` | $8$ | A:$6$, U:$2$ | $1.0$ | $\\approx 0.811$ |\n| $11$ | `AGUUAGAA` | $8$ | A:$4$, G:$2$, U:$2$ | $1.0$ | $1.5$ |\n| $12$ | `GUCAAU` (T$\\to$U) | $6$ | A:$2$, C:$1$, G:$1$, U:$2$ | $0.75$ | $\\approx 1.918$ |\n\n有了这些值，我们对每个测试案例评估约束条件 $H_j \\le \\tau$ 和 $c_j \\ge \\gamma$。\n\n**案例 1: $(\\tau, \\gamma) = (0.0, 0.5)$**\n我们需要 $H_j = 0.0$ 且 $c_j \\ge 0.5$。\n- 第1列：$H_1=0.0$, $c_1=1.0$。满足条件。\n- 第6列：$H_6=0.0$，但 $c_6=0.0 < 0.5$。不满足条件。\n- 第7列：$H_7=0.0$, $c_7=0.875$。满足条件。\n此案例的功能受限列集合为 $\\{1, 7\\}$。\n\n**案例 2: $(\\tau, \\gamma) = (1.0, 0.5)$**\n我们需要 $H_j \\le 1.0$ 且 $c_j \\ge 0.5$。\n- 第1列：$H_1=0.0 \\le 1.0$, $c_1=1.0 \\ge 0.5$。满足。\n- 第2列：$H_2=1.0 \\le 1.0$, $c_2=1.0 \\ge 0.5$。满足。\n- 第7列：$H_7=0.0 \\le 1.0$, $c_7=0.875 \\ge 0.5$。满足。\n- 第8列：$H_8 \\approx 0.650 \\le 1.0$, $c_8=0.75 \\ge 0.5$。满足。\n- 第9列：$H_9 \\approx 0.971 \\le 1.0$, $c_9=0.625 \\ge 0.5$。满足。\n- 第10列：$H_{10} \\approx 0.811 \\le 1.0$, $c_{10}=1.0 \\ge 0.5$。满足。\n其他列的熵值均大于1.0或覆盖度小于0.5。\n此案例的功能受限列集合为 $\\{1, 2, 7, 8, 9, 10\\}$。\n\n**案例 3: $(\\tau, \\gamma) = (2.0, 0.75)$**\n我们需要 $H_j \\le 2.0$ 且 $c_j \\ge 0.75$。\n- 第1列：$H_1=0.0 \\le 2.0$, $c_1=1.0 \\ge 0.75$。满足。\n- 第2列：$H_2=1.0 \\le 2.0$, $c_2=1.0 \\ge 0.75$。满足。\n- 第3列：$H_3 \\approx 1.811 \\le 2.0$, $c_3=1.0 \\ge 0.75$。满足。\n- 第4列：$c_4=0.625 < 0.75$。不满足。\n- 第5列：$H_5=1.5 \\le 2.0$, $c_5=1.0 \\ge 0.75$。满足。\n- 第6列：$c_6=0.0 < 0.75$。不满足。\n- 第7列：$H_7=0.0 \\le 2.0$, $c_7=0.875 \\ge 0.75$。满足。\n- 第8列：$H_8 \\approx 0.650 \\le 2.0$, $c_8=0.75 \\ge 0.75$。满足。\n- 第9列：$c_9=0.625 < 0.75$。不满足。\n- 第10列：$H_{10} \\approx 0.811 \\le 2.0$, $c_{10}=1.0 \\ge 0.75$。满足。\n- 第11列：$H_{11}=1.5 \\le 2.0$, $c_{11}=1.0 \\ge 0.75$。满足。\n- 第12列：$H_{12} \\approx 1.918 \\le 2.0$, $c_{12}=0.75 \\ge 0.75$。满足。\n此案例的功能受限列集合为 $\\{1, 2, 3, 5, 7, 8, 10, 11, 12\\}$。\n\n将最终结果编译成所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Computes functionally constrained columns in an rRNA alignment for three test cases.\n    \"\"\"\n    # Define the alignment and problem constants.\n    sequences = [\n        \"AAAAANGACAAG\",\n        \"AAC-UNGACAAT\",\n        \"AAG-T-GACAAU\",\n        \"AAU-C-GAGAAC\",\n        \"AGA-ANGA-UAN\",\n        \"AGC-U-GA-UA-\",\n        \"AGGAT-G--UAA\",\n        \"AGU-CN---AAA\",\n    ]\n    M = 8  # Number of sequences\n    L = 12 # Length of sequences\n\n    # Test suite parameters (tau, gamma).\n    test_cases = [\n        (0.0, 0.5),\n        (1.0, 0.5),\n        (2.0, 0.75),\n    ]\n\n    # Transpose the alignment to get columns.\n    columns = list(zip(*sequences))\n    \n    # Calculate entropy and coverage for each column.\n    column_metrics = []\n    for j in range(L):\n        column_chars = columns[j]\n        \n        # Pre-process characters: T -> U, filter for informative bases.\n        informative_chars = []\n        for char in column_chars:\n            if char == 'T':\n                informative_chars.append('U')\n            elif char in 'ACGU':\n                informative_chars.append(char)\n        \n        n_j = len(informative_chars)\n        \n        # Calculate coverage (c_j).\n        c_j = n_j / M\n        \n        # Calculate Shannon entropy (H_j).\n        H_j = 0.0\n        if n_j > 0:\n            # Count occurrences of each base in the column.\n            counts = collections.Counter(informative_chars)\n            for base in counts:\n                p_b_j = counts[base] / n_j\n                H_j -= p_b_j * np.log2(p_b_j)\n        \n        column_metrics.append({'H': H_j, 'c': c_j})\n\n    # Apply the constraint criteria for each test case.\n    all_results = []\n    for tau, gamma in test_cases:\n        constrained_columns = []\n        for j in range(L):\n            metrics = column_metrics[j]\n            if metrics['H'] = tau and metrics['c'] >= gamma:\n                # Append 1-based index.\n                constrained_columns.append(j + 1)\n        all_results.append(constrained_columns)\n\n    # Format the final output string.\n    # e.g., [[1,2],[3],[4,5,6]]\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2426486"}, {"introduction": "一个预测出的rRNA二级结构本质上是一个科学假设。要验证这一假设，最有力的方法之一是在多物种序列比对中寻找进化上的协同证据。本练习将带你探索“补偿性碱基替换”（Compensatory Base-pair Changes, CBCs）这一概念，它是一个真实存在的碱基配对在进化过程中得以维持的有力标志[@problem_id:2426467]。你将通过编程实现一个算法来统计CBCs的数量，从而对预测的螺旋结构进行打分和验证。", "problem": "编写一个完整的程序，该程序在给定一个固定的核糖体RNA（rRNA）多重序列比对和一组固定的预测螺旋的情况下，评估每个螺旋的补偿性碱基对变化（CBC）支持度，并针对几个阈值报告有多少螺旋得到了验证。\n\n核糖体RNA（rRNA）的多重序列比对（MSA）以 $S$ 条长度为 $L$ 的等长比对序列的形式提供。所有序列均为字母表 {A, C, G, U, -} 上的字符串，其中短划线字符表示一个缺口。将一个预测螺旋视为由一个或多个碱基配对的比对列索引对 $(i,j)$ 组成的集合，其中 $1 \\le i  j \\le L$，并使用从1开始的索引。\n\n将标准碱基对集合 $P$ 定义为 $P = \\{(A,U),(U,A),(G,C),(C,G),(G,U),(U,G)\\}$。对于给定的一对比对列 $(i,j)$ 和一条给定的序列 $k \\in \\{1,\\dots,S\\}$，设 $x_k$ 为第 $i$ 列的核苷酸，$y_k$ 为第 $j$ 列的核苷酸。如果 $(x_k,y_k) \\in P$，则序列 $k$ 在 $(i,j)$ 位置贡献一个标准配对状态；否则，对于 $(i,j)$ 的计算将忽略该序列。\n\n对于给定的一对列 $(i,j)$，将补偿性碱基对变化（CBCs）的数量定义为满足以下条件的无序序列对 $\\{k,\\ell\\}$（其中 $1 \\le k  \\ell \\le S$）的数量：\n- $(x_k,y_k) \\in P$ 和 $(x_{\\ell},y_{\\ell}) \\in P$ 均成立，并且\n- $x_k \\ne x_{\\ell}$ 和 $y_k \\ne y_{\\ell}$。\n\n对于一个由 $m \\in \\{1,\\dots,H_{\\text{pairs}}\\}$ 的配对 $(i_m,j_m)$ 组成的螺旋，将其总CBC计数定义为其所有组成的碱基对列对的CBC计数之和：\n$$\n\\mathrm{CBC\\_total} = \\sum_{m=1}^{H_{\\text{pairs}}} \\mathrm{CBC}(i_m,j_m).\n$$\n如果 $\\mathrm{CBC\\_total} \\ge t$，则认为该螺旋在阈值 $t$ 下得到验证。\n\n使用以下固定的MSA（包含 $S=6$ 条序列和 $L=12$ 列），表示为6个等长字符串：\n\n- $s_1 =$ \"AAGGG--UCCUU\"\n- $s_2 =$ \"GGAGG-ACCUCC\"\n- $s_3 =$ \"-UUGGC-UCAA-\"\n- $s_4 =$ \"-GGGG--GCUU-\"\n- $s_5 =$ \"-CCGGAUCCGG-\"\n- $s_6 =$ \"-AGGG--UCCU-\"\n\n使用以下包含5个预测螺旋的集合，每个螺旋都指定为基于1的索引对 $(i,j)$ 的列表：\n- 螺旋 1: $(2,11)$ 和 $(3,10)$\n- 螺旋 2: $(4,9)$\n- 螺旋 3: $(5,8)$\n- 螺旋 4: $(6,7)$\n- 螺旋 5: $(1,12)$\n\n测试套件（在相同的MSA和螺旋集上独立评估四个阈值 $t$）：\n- 案例 1: $t = 5$\n- 案例 2: $t = 0$\n- 案例 3: $t = 1$\n- 案例 4: $t = 100$\n\n你的程序必须为每个案例计算在给定阈值 $t$ 下被验证的螺旋数量。最终输出必须是单行文本，包含一个由逗号分隔的列表，该列表按案例顺序列出了4个整数结果，并用方括号括起来（例如，“[a,b,c,d]”），不得包含额外文本。不要求也不允许用户输入。角度和物理单位不适用于此问题；所有报告的量均为无量纲整数。", "solution": "该问题要求基于来自多重序列比对（MSA）的进化证据，验证预测的核糖体RNA（rRNA）二级结构螺旋。具体来说，我们必须通过计算补偿性碱基对变化（CBCs）来量化对每个预测螺旋的支持度，然后针对几个给定的阈值，确定有多少个螺旋满足验证标准。\n\n提供的输入包括一个由 $S=6$ 条长度为 $L=12$ 的rRNA序列组成的MSA，一个由5个预测螺旋（通过比对列对定义）组成的集合，以及一组用于验证的4个整数阈值。所有列索引都是基于1的，在计算时必须转换为基于0的索引。\n\n一个基本概念是标准碱基对集合，定义为 $P = \\{(A,U),(U,A),(G,C),(C,G),(G,U),(U,G)\\}$。对于给定的一对比对列 $(i,j)$ 和一条序列 $k$，如果位于这些列的核苷酸对 $(x_k, y_k)$ 满足 $(x_k, y_k) \\in P$，则它们形成一个标准配对状态。\n\n分析的核心在于补偿性碱基对变化（CBC）的定义。根据问题描述，一个列对 $(i,j)$ 的CBC计数是MSA中满足两个严格条件的无序序列对 $\\{k,\\ell\\}$ 的数量：\n$1$. 两条序列都必须在列 $(i,j)$ 处形成一个标准碱基对：$(x_k, y_k) \\in P$ 且 $(x_{\\ell}, y_{\\ell}) \\in P$。\n$2$. 两个位置上的核苷酸必须都不同：$x_k \\ne x_{\\ell}$ 且 $y_k \\ne y_{\\ell}$。这要求两个位点发生协同变化，例如，从 $(G,C)$ 变为 $(A,U)$ 或从 $(G,C)$ 变为 $(C,G)$，但不能从 $(G,C)$ 变为 $(G,U)$，因为第一个碱基没有改变。\n\n一个螺旋的总支持度 $\\mathrm{CBC\\_total}$ 是构成该螺旋的所有列对 $(i_m, j_m)$ 的CBC计数的总和：$\\mathrm{CBC\\_total} = \\sum_{m=1}^{H_{\\text{pairs}}} \\mathrm{CBC}(i_m,j_m)$。最后，如果一个螺旋的总支持度达到或超过阈值 $t$，即 $\\mathrm{CBC\\_total} \\ge t$，则认为该螺旋在阈值 $t$ 下得到验证。\n\n该解决方案遵循一个系统的、多步骤的算法：\n\n首先，我们处理输入数据。MSA被存储为字符串数组。螺旋集合被存储为基于1的索引对的列表的列表。标准碱基对集合 $P$ 存储在哈希集合中，以实现高效的 $O(1)$ 查找。\n\n其次，对于螺旋中定义的每个相关的比对列对 $(i,j)$，我们计算其CBC计数。采用了一种计算上高效的方法：\n$1$. 对于给定的列对 $(i,j)$，遍历MSA中的所有 $S$ 条序列。\n$2$. 对每条序列 $k$，提取核苷酸对 $(x_k, y_k)$。如果该对属于集合 $P$，则保留它。\n$3$. 为所有保留的标准碱基对构建一个频率图（多重集）。这个图，我们称之为 $M$，存储了所发现的每种唯一的标准碱基对类型及其出现的序列数。\n$4. $通过遍历映射 $M$ 中作为键存在的所有不同标准碱基对类型 $\\{p_a, p_b\\}$ 的无序对来计算CBC计数。设 $p_a = (x_a, y_a)$ 和 $p_b = (x_b, y_b)$。如果满足严格的补偿条件（$x_a \\ne x_b$ 且 $y_a \\ne y_b$），那么这两种类型对CBC计数有贡献。在类型为 $p_a$ 的序列和类型为 $p_b$ 的序列之间形成的CBC数量是它们频率的乘积，即 $M[p_a] \\times M[p_b]$。列对 $(i,j)$ 的总CBC计数是所有合格的碱基对类型对的这些乘积之和。\n\n第三，对于5个预测螺旋中的每一个，我们通过将其所有组成列对在上一步中计算出的CBC计数相加，来计算其总支持度 $\\mathrm{CBC\\_total}$。\n\n第四，我们根据指定的阈值评估螺旋。对于集合 $\\{5, 0, 1, 100\\}$ 中的每个阈值 $t$，我们遍历5个螺旋，并计算有多少个螺旋的 $\\mathrm{CBC\\_total}$ 值大于或等于 $t$。\n\n这个过程产生一个包含4个整数计数的列表，对应于每个阈值下验证的螺旋数量，这就是最终结果。", "answer": "```python\nimport collections\n\n# There is no need for numpy or scipy for this problem, but the template requires this formatting.\n# import numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the rRNA helix validation problem based on Compensatory Base-pair Changes (CBCs).\n    \"\"\"\n\n    # --- Step 1: Define Givens from the problem statement ---\n\n    # Multiple Sequence Alignment (S=6, L=12)\n    msa = [\n        \"AAGGG--UCCUU\",\n        \"GGAGG-ACCUCC\",\n        \"-UUGGC-UCAA-\",\n        \"-GGGG--GCUU-\",\n        \"-CCGGAUCCGG-\",\n        \"-AGGG--UCCU-\",\n    ]\n\n    # Predicted Helices (1-based indexing)\n    helices_1_based = {\n        1: [(2, 11), (3, 10)],\n        2: [(4, 9)],\n        3: [(5, 8)],\n        4: [(6, 7)],\n        5: [(1, 12)],\n    }\n    \n    # Convert helices to 0-based indexing for programming convenience\n    helices = {\n        name: [(i - 1, j - 1) for i, j in pairs]\n        for name, pairs in helices_1_based.items()\n    }\n\n    # Canonical Base Pairs\n    canonical_pairs = {\n        ('A', 'U'), ('U', 'A'),\n        ('G', 'C'), ('C', 'G'),\n        ('G', 'U'), ('U', 'G'),\n    }\n\n    # Test cases: Threshold values\n    thresholds = [5, 0, 1, 100]\n    \n    # --- Step 2: Implement the CBC calculation logic ---\n\n    def calculate_cbc_for_pair(col_i, col_j):\n        \"\"\"\n        Calculates the CBC count for a single pair of alignment columns.\n        \"\"\"\n        # Extract pairs from the specified columns for all sequences\n        sequence_pairs = []\n        for seq in msa:\n            pair = (seq[col_i], seq[col_j])\n            if pair in canonical_pairs:\n                sequence_pairs.append(pair)\n\n        # If fewer than 2 sequences have canonical pairs, no CBC is possible.\n        if len(sequence_pairs)  2:\n            return 0\n        \n        # Create a frequency map of the canonical pairs found\n        pair_counts = collections.Counter(sequence_pairs)\n        \n        cbc_count = 0\n        \n        # Get the unique pair types\n        unique_pair_types = list(pair_counts.keys())\n        \n        # Iterate over all unordered pairs of distinct pair types\n        for i in range(len(unique_pair_types)):\n            for j in range(i + 1, len(unique_pair_types)):\n                p_a = unique_pair_types[i]\n                p_b = unique_pair_types[j]\n                \n                x_a, y_a = p_a\n                x_b, y_b = p_b\n                \n                # Check for the strict CBC condition: x_k != x_l AND y_k != y_l\n                if x_a != x_b and y_a != y_b:\n                    # The number of CBCs between these two types is the product of their frequencies\n                    cbc_count += pair_counts[p_a] * pair_counts[p_b]\n                    \n        return cbc_count\n\n    # --- Step 3: Calculate total CBC support for each helix ---\n    \n    helix_total_cbcs = {}\n    for helix_name, column_pairs in helices.items():\n        total_cbc_for_helix = 0\n        for i, j in column_pairs:\n            total_cbc_for_helix += calculate_cbc_for_pair(i, j)\n        helix_total_cbcs[helix_name] = total_cbc_for_helix\n\n    # --- Step 4: Evaluate helices against thresholds and collect results ---\n\n    results = []\n    for t in thresholds:\n        validated_helices_count = 0\n        for helix_name in helices:\n            if helix_total_cbcs[helix_name] >= t:\n                validated_helices_count += 1\n        results.append(validated_helices_count)\n\n    # --- Final Output ---\n    # The final print statement must match the required format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```", "id": "2426467"}, {"introduction": "在分析和验证了给定的结构之后，一个更具挑战性的任务是从头（*de novo*）预测RNA的折叠方式。本练习将直接面对RNA折叠这一核心问题，即如何仅根据单个RNA序列来预测其最稳定的二级结构。我们将运用一个简化的热力学模型，通过枚举所有可能的无假结（pseudoknot-free）结构并计算其折叠自由能（$\\Delta G_f$），来找到能量最低、从而在生物学上最可能存在的构象[@problem_id:2426514]。", "problem": "给定一小段核糖体RNA（rRNA）片段，要求您在一个简化的、科学上合理的的热力学模型下，探究其所有可能的无假结二级结构。目标是为每个提供的序列片段枚举所有满足规范碱基配对规则的二级结构，计算每个结构的折叠吉布斯自由能（$\\Delta G_f$），然后根据热力学稳定性对这些结构进行排序（$\\Delta G_f$ 越负越稳定）。\n\n使用以下基础生物学和物理学依据：\n- 核糖核酸（RNA）中的互补碱基配对：规范的 Watson–Crick 配对（$\\mathrm{A}$-$\\mathrm{U}$ 和 $\\mathrm{G}$-$\\mathrm{C}$）以及摆动配对（$\\mathrm{G}$-$\\mathrm{U}$）。这些配对基于氢键和空间兼容性。\n- 折叠吉布斯自由能（$\\Delta G_f$）作为一个稳定和去稳定贡献的加性模型，其中更负的值表示更稳定的结构。\n\n二级结构模型和约束：\n- 允许的碱基对恰好为 $\\{\\mathrm{A}\\text{-}\\mathrm{U},\\mathrm{U}\\text{-}\\mathrm{A},\\mathrm{G}\\text{-}\\mathrm{C},\\mathrm{C}\\text{-}\\mathrm{G},\\mathrm{G}\\text{-}\\mathrm{U},\\mathrm{U}\\text{-}\\mathrm{G}\\}$。\n- 一个核苷酸最多只能参与一个碱基对。\n- 禁止假结（非交叉约束）：如果位置 $i$ 和 $j$ 形成一个配对且 $ij$，位置 $k$ 和 $\\ell$ 形成一个配对且 $k\\ell$，则必须不能出现 $ikj\\ell$ 的情况。\n- 最小发夹环长度为 $m=3$：如果 $i$ 与 $j$ 配对，则必须满足 $j-i-1\\ge m$。\n\n热力学评分（简化的加性模型，所有能量单位为 $\\mathrm{kcal/mol}$）：\n- 每个碱基对的稳定能 $e(x_i,x_j)$：\n  - $e(\\mathrm{G},\\mathrm{C})=e(\\mathrm{C},\\mathrm{G})=-3.0$,\n  - $e(\\mathrm{A},\\mathrm{U})=e(\\mathrm{U},\\mathrm{A})=-2.0$,\n  - $e(\\mathrm{G},\\mathrm{U})=e(\\mathrm{U},\\mathrm{G})=-1.0$。\n- 发夹环罚分 $h(L)$ 仅适用于闭合发夹环的碱基对（即，在 $i$ 和 $j$ 之间没有其他严格嵌套的碱基对的配对 $(i,j)$），其中 $L=j-i-1$：\n  - $h(L)=3.0+0.4\\cdot(L-3)$ for $L\\ge 3$。\n- 堆积奖励 $s_{\\text{stack}}=-0.5$ 对每个相邻的堆积对施加一次，即对于每个满足 $(i,j)$ 是配对且 $(i+1,j-1)$ 也是结构中配对的情况，加上 $s_{\\text{stack}}$。\n- 除上述项外，不施加额外的罚分或奖励（没有明确的内环、凸环或多分支环项）。\n\n对于序列 $x_1x_2\\ldots x_n$ 上的一个结构 $S$，其碱基对集合为 $\\mathcal{P}(S)$，发夹闭合对集合为 $\\mathcal{H}(S)\\subseteq \\mathcal{P}(S)$，堆积邻接集合为 $\\mathcal{T}(S)=\\{(i,j)\\in \\mathcal{P}(S)\\,:\\,(i+1,j-1)\\in \\mathcal{P}(S)\\}$，其简化的折叠吉布斯自由能为\n$$\n\\Delta G_f(S)\n=\n\\sum_{(i,j)\\in \\mathcal{P}(S)} e(x_i,x_j)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{H}(S)} h(j-i-1)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{T}(S)} s_{\\text{stack}}.\n$$\n\n计算要求：\n- 为每个测试序列枚举所有符合上述规则的无假结二级结构。\n- 计算每个结构的 $\\Delta G_f$。\n- 按 $\\Delta G_f$ 升序（负值更小的在前）对结构进行排序。如果在数值舍入误差范围内多个结构具有无法区分的能量，则视它们为并列。\n\n单位和数值格式：\n- 能量以 $\\mathrm{kcal/mol}$ 为单位报告。\n- 将每个报告的能量四舍五入到三位小数。\n- 为了排序和去重，如果两个能量 $E_1$ 和 $E_2$ 满足 $\\left|E_1-E_2\\right|  10^{-6}$，您可以将它们视为相同，这在此处等同于通过四舍五入到三位小数进行去重。\n\n测试套件：\n使用以下四个序列（每个序列都是一个独立的测试用例）。在数学描述中，索引是基于 $1$ 的，但您在代码中必须使用基于 $0$ 的索引来实现。\n1. $x^{(1)}=$ \"GGAUCCAUUGCC\"\n2. $x^{(2)}=$ \"AAAAAGAAAAAA\"\n3. $x^{(3)}=$ \"GGGAAUUCCCUU\"\n4. $x^{(4)}=$ \"AUGCUAGCUA\"\n\n答案规范：\n- 对于每个测试用例，按升序输出前 $K=3$ 个唯一的能量值（四舍五入到三位小数后）。如果唯一的能量值少于 $K$ 个，则输出所有可用的唯一能量值。\n- 最终输出必须是单行，包含一个列表的列表，每个内部列表对应一个测试用例，顺序与上面给出的一致。该行必须格式化为 Python 风格的浮点数嵌套列表，精确到三位小数且不带单位，例如：\"[[-7.200,-6.800,-6.400],[0.000],[-5.300,-5.000,-4.600],[-2.000,-1.600,-1.500]]\"。", "solution": "所述问题在科学上是合理的，在数学上是适定的，并且是客观的。它为核糖体RNA（rRNA）片段的折叠提供了一个简化但一致的热力学模型。所有参数、约束和目标都以足够的严谨性进行了规定，从而能够得到一个唯一且可验证的解。因此，该问题被认为是有效的，并且有必要提供一个计算解决方案。\n\n核心任务是枚举给定 RNA 序列所有可能的无假结二级结构，计算每个结构的吉布斯自由能（$\\Delta G_f$），并找出最稳定的构型。鉴于所提供序列的长度很小（最多 $n=12$ 个核苷酸），采用带记忆化的递归枚举的直接方法在计算上是可行的，并且比针对此特定、简化的能量模型定制的复杂动态规划公式更容易正确实现。\n\n算法按以下步骤进行：\n\n首先，我们定义一个递归函数，记为 $\\Phi(i, j)$，它为子序列 $x_i, \\dots, x_j$ 生成所有有效二级结构的集合。一个结构在数学上是一个表示碱基配对的对偶 $(p, q)$ 的集合，其中 $i \\le p  q \\le j$。为了遵守非交叉（无假结）约束，此函数基于分解原理进行操作：\n\n1.  $x_i, \\dots, x_j$ 上的一个结构，要么使核苷酸 $x_j$ 不配对，要么将其与某个核苷酸 $x_k$ 配对，其中 $i \\le k  j$。\n2.  如果 $x_j$ 不配对，则可能的结构集合与子序列 $x_i, \\dots, x_{j-1}$ 的结构集合相同，由 $\\Phi(i, j-1)$ 给出。\n3.  如果 $x_j$ 与 $x_k$ 配对（其中 $(x_k, x_j)$ 是一个允许的配对且 $j-k-1 \\ge m=3$），非交叉约束规定整体结构是该配对“左侧”子序列 $x_i, \\dots, x_{k-1}$ 上的结构和该配对“内部”子序列 $x_{k+1}, \\dots, x_{j-1}$ 上的结构的组合。从这两个区域（分别通过 $\\Phi(i, k-1)$ 和 $\\Phi(k+1, j-1)$ 获得）的所有有效子结构的组合被生成，并与新的配对 $(k, j)$ 结合。\n\n递归的基准情形是子序列太短而无法形成发夹环（$j-i-1  m$），此时唯一有效的结构是没有配对的空结构。$\\Phi(i, j)$ 的结果被记忆化，以避免对重叠子问题的冗余计算。\n\n其次，对于每个枚举的结构 $S$，我们严格按照提供的公式计算其折叠吉布斯自由能 $\\Delta G_f(S)$：\n$$\n\\Delta G_f(S)\n=\n\\sum_{(i,j)\\in \\mathcal{P}(S)} e(x_i,x_j)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{H}(S)} h(j-i-1)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{T}(S)} s_{\\text{stack}}.\n$$\n对于给定的结构 $S$（表示为配对集合 $\\mathcal{P}(S)$），其计算是通过遍历每个配对 $(i, j) \\in \\mathcal{P}(S)$ 并应用以下逻辑来执行的：\n- 碱基对稳定能 $e(x_i, x_j)$ 总是被加上。\n- 如果相邻的内部配对 $(i+1, j-1)$ 也是 $\\mathcal{P}(S)$ 的成员，则加上堆积奖励 $s_{\\text{stack}} = -0.5$。\n- 当且仅当配对 $(i, j)$ 是一个发夹闭合对时，才加上发夹环罚分 $h(j-i-1)$，这意味着不存在其他配对 $(p, q) \\in \\mathcal{P}(S)$ 使得 $i  p  q  j$。对每个配对都要检查此条件。\n\n没有配对的结构 $\\mathcal{P}(S) = \\emptyset$ 始终是一种可能性，其能量为 $\\Delta G_f = 0.0$。\n\n最后，对于每个输入序列，收集所有可能结构计算出的能量。通过将满足 $|E_1 - E_2|  10^{-6}$ 的值 $E_1, E_2$ 视为相同来进行能量去重，这可以通过在识别唯一值之前四舍五入到高精度（例如 $9$ 位小数）来实现。得到的唯一能量按升序排序，并选择前 $K=3$ 个（如果唯一能量不足，则选择所有存在的）。然后将这些值格式化为三位小数，以作为指定的最终输出。", "answer": "```python\nimport numpy as np\n\n# Global constants and memoization table, reset for each sequence.\nBASE_PAIR_ENERGIES = {\n    ('G', 'C'): -3.0, ('C', 'G'): -3.0,\n    ('A', 'U'): -2.0, ('U', 'A'): -2.0,\n    ('G', 'U'): -1.0, ('U', 'G'): -1.0,\n}\nALLOWED_PAIRS = set(BASE_PAIR_ENERGIES.keys())\nSTACKING_BONUS = -0.5\nMIN_HAIRPIN_LOOP_LENGTH = 3\n\nmemo_structures = {}\nsequence_str = \"\"\n\ndef hairpin_penalty(length):\n    \"\"\"Calculates the hairpin loop penalty based on its length.\"\"\"\n    return 3.0 + 0.4 * (length - MIN_HAIRPIN_LOOP_LENGTH)\n\ndef generate_structures(i, j):\n    \"\"\"\n    Recursively generates all possible pseudoknot-free secondary structures\n    for the subsequence sequence_str[i:j+1].\n    Uses memoization to store results.\n    A structure is represented as a frozenset of pairs (tuples) for hashability.\n    \"\"\"\n    if (i, j) in memo_structures:\n        return memo_structures[(i, j)]\n\n    # Base case: subsequence is too short to form any pair according to the minimum hairpin loop rule.\n    if j  i + MIN_HAIRPIN_LOOP_LENGTH + 1:\n        # The only possible structure is the one with no pairs.\n        return {frozenset()}\n\n    # Recursive step\n    # Case 1: Nucleotide j is unpaired. Structures are the same as for the subsequence [i, j-1].\n    # A copy is made to prevent modification of the memoized set.\n    res_structures = set(generate_structures(i, j - 1))\n\n    # Case 2: Nucleotide j pairs with some k, where i = k  j.\n    # The minimum loop length constraint implies j-k-1 >= m=3, so k = j-4.\n    for k in range(i, j - MIN_HAIRPIN_LOOP_LENGTH):\n        if (sequence_str[k], sequence_str[j]) in ALLOWED_PAIRS:\n            # The pair (k, j) partitions the structure into an 'inner' part (subsequence k+1 to j-1)\n            # and a 'left' part (subsequence i to k-1). We find all structures for both.\n            left_structures = generate_structures(i, k - 1)\n            inner_structures = generate_structures(k + 1, j - 1)\n\n            # Combine all possibilities from the subproblems.\n            for s_left in left_structures:\n                for s_inner in inner_structures:\n                    new_structure = s_left.union(s_inner, {(k, j)})\n                    res_structures.add(new_structure)\n    \n    memo_structures[(i, j)] = res_structures\n    return res_structures\n\ndef calculate_energy(structure, sequence):\n    \"\"\"Calculates the Gibbs free energy of a given secondary structure.\"\"\"\n    if not structure:\n        return 0.0\n\n    total_energy = 0.0\n    \n    # Pre-compute which pairs are hairpin-closing to avoid repeated checks.\n    hairpin_closing_pairs = set()\n    for i, j in structure:\n        is_hairpin = True\n        for p, q in structure:\n            if i  p and q  j:\n                is_hairpin = False\n                break\n        if is_hairpin:\n            hairpin_closing_pairs.add((i, j))\n\n    for i, j in structure:\n        # 1. Add base-pair stabilization energy\n        total_energy += BASE_PAIR_ENERGIES[(sequence[i], sequence[j])]\n        \n        # 2. Add stacking bonus if an adjacent inner pair exists\n        if (i + 1, j - 1) in structure:\n            total_energy += STACKING_BONUS\n            \n        # 3. Add hairpin loop penalty if the pair closes a hairpin\n        if (i, j) in hairpin_closing_pairs:\n            loop_length = j - i - 1\n            total_energy += hairpin_penalty(loop_length)\n            \n    return total_energy\n\ndef solve_for_sequence(seq):\n    \"\"\"Orchestrates the full process for a single RNA sequence.\"\"\"\n    global memo_structures, sequence_str\n    memo_structures = {}\n    sequence_str = seq\n    n = len(seq)\n    \n    if n == 0:\n        return [0.0]\n\n    all_structures = generate_structures(0, n - 1)\n    \n    energies = [calculate_energy(s, seq) for s in all_structures]\n\n    # Deduplicate energies using high precision, then sort.\n    # A precision of 9 decimal places is sufficient for the 1e-6 tie condition.\n    unique_energies = sorted(list(set(np.round(energies, 9))))\n    \n    # Return top K=3 or fewer if not enough unique energies are found.\n    return unique_energies[:3]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the solution for all test cases and print\n    the final output in the required format.\n    \"\"\"\n    test_cases = [\n        \"GGAUCCAUUGCC\",\n        \"AAAAAGAAAAAA\",\n        \"GGGAAUUCCCUU\",\n        \"AUGCUAGCUA\",\n    ]\n\n    final_results = []\n    for seq in test_cases:\n        top_energies = solve_for_sequence(seq)\n        final_results.append(top_energies)\n\n    # Format the final list of lists of floats into the specified string format.\n    # example: \"[[-7.200,-6.800,-6.400],[0.000],[-5.300,-5.000,-4.600],[-2.000,-1.600,-1.500]]\"\n    outer_list_parts = []\n    for result_list in final_results:\n        inner_list_parts = [f\"{e:.3f}\" for e in result_list]\n        outer_list_parts.append(f\"[{','.join(inner_list_parts)}]\")\n    \n    print(f\"[{','.join(outer_list_parts)}]\")\n\nsolve()\n```", "id": "2426514"}]}