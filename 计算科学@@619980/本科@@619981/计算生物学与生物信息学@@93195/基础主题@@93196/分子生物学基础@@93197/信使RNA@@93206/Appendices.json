{"hands_on_practices": [{"introduction": "信使RNA（mRNA）的稳定性是基因表达调控中的一个关键因素，它直接影响着蛋白质的合成水平，其半衰期（$t_{1/2}$）是衡量稳定性的核心指标。本练习将带你模拟一个经典的生物学实验，通过分析在转录被抑制后mRNA分子降解的数据，来计算其半衰期。这个过程不仅能加深你对一级动力学降解模型的理解，还能让你掌握从实验数据中提取关键生物学参数的基本技能 [@problem_id:1445058]。", "problem": "在一项旨在表征基因表达动力学的系统生物学实验中，研究人员研究了一种名为糖酵解激活因子 (Glycolysis-Activating Factor, GAF) 的基因的特定信使RNA (mRNA) 转录本的稳定性。他们在时间 $t=0$ 分钟时，用放线菌素D (actinomycin D) 处理细胞培养物，这是一种能完全并瞬间中止所有转录的药物。随后，他们在多个时间点测量 GAF mRNA 的浓度。已知 mRNA 的降解遵循一级动力学。实验数据如下表所示。\n\n| 时间, $t$ (分钟) | GAF mRNA 浓度 (纳摩尔/升) |\n| :------------------ | :--------------------------------------- |\n| 0                   | 100.0                                    |\n| 10                  | 60.0                                     |\n| 20                  | 36.0                                     |\n| 30                  | 21.6                                     |\n| 40                  | 13.0                                     |\n\n使用所有给出的数据点，确定 GAF mRNA 的半衰期。结果以分钟为单位，并四舍五入至三位有效数字。", "solution": "放线菌素D 在 $t=0$ 时中止转录，因此其后的 mRNA 浓度 $C(t)$ 遵循一级衰减：\n$$\\frac{dC}{dt}=-k\\,C \\quad\\Rightarrow\\quad C(t)=C_{0}\\exp(-k t).$$\n取自然对数可得到一个关于 $t$ 的线性关系：\n$$\\ln C(t)=\\ln C_{0}-k\\,t.$$\n因此，使用最小二乘法将 $y=\\ln C$ 与 $t$ 的关系拟合成 $y=a+bt$ 的形式，可得 $b=-k$。使用所有五个数据点 $(t_{i},C_{i})$（其中 $t_{i}\\in\\{0,10,20,30,40\\}$ 分钟， $C_{i}\\in\\{100.0,60.0,36.0,21.6,13.0\\}$ 纳摩尔/升），定义 $y_{i}=\\ln C_{i}$。标准的最小二乘斜率为\n$$b=\\frac{n\\sum t_{i}y_{i}-\\left(\\sum t_{i}\\right)\\left(\\sum y_{i}\\right)}{n\\sum t_{i}^{2}-\\left(\\sum t_{i}\\right)^{2}},\\quad k=-b,$$\n其中 $n=5$。计算所需的和：\n$$\\sum t_{i}=0+10+20+30+40=100,\\qquad \\sum t_{i}^{2}=0^{2}+10^{2}+20^{2}+30^{2}+40^{2}=3000.$$\n计算 $y_{i}=\\ln C_{i}$：\n$$\\ln 100=4.605170186,\\quad \\ln 60=4.094344562,\\quad \\ln 36=3.583518938,\\quad \\ln 21.6=3.072693314,\\quad \\ln 13.0=2.564949357.$$\n因此，\n$$\\sum y_{i}=4.605170186+4.094344562+3.583518938+3.072693314+2.564949357=17.920676357,$$\n$$\\sum t_{i}y_{i}=0\\cdot 4.605170186+10\\cdot 4.094344562+20\\cdot 3.583518938+30\\cdot 3.072693314+40\\cdot 2.564949357=307.39259808.$$\n所以，\n$$b=\\frac{5\\cdot 307.39259808-100\\cdot 17.920676357}{5\\cdot 3000-100^{2}}=\\frac{-255.1046453}{5000}=-0.05102092906,$$\n故\n$$k=0.05102092906\\ \\text{min}^{-1}.$$\n半衰期为\n$$t_{1/2}=\\frac{\\ln 2}{k}=\\frac{0.69314718056}{0.05102092906}\\approx 13.5855\\ \\text{分钟}。$$\n四舍五入到三位有效数字，半衰期为 $13.6$ 分钟。", "answer": "$$\\boxed{13.6}$$", "id": "1445058"}, {"introduction": "细胞内mRNA的浓度由其合成（转录）和降解之间的动态平衡决定。本练习构建了一个简洁但功能强大的数学模型，用于描述当细胞遭遇环境压力、转录速率发生改变时，mRNA分子数量 $N(t)$ 的动态变化过程。通过求解该模型，你将能够计算系统达到新稳态所需的时间，从而深入理解细胞如何响应外界信号并调整其基因表达 [@problem_id:1445057]。", "problem": "在一个真核细胞内基因表达的简化模型中，从基因 *StressResp1* 转录而来的一种特定信使RNA (mRNA) 的数量，由其合成（转录）和降解之间的平衡所决定。降解过程被建模为一级衰变。最初，细胞处于一个基础、无应激的状态，此时 *StressResp1* 的转录速率是恒定的，为 $k_{tx, basal} = 0.50$ 分子/分钟。*StressResp1* mRNA的半衰期为 $t_{1/2} = 7.0$ 分钟。\n\n在时间 $t=0$ 时，细胞受到一个突发的环境应激源。这一事件瞬时且永久地将转录速率增加到一个新的、更高的恒定值 $k_{tx, new} = 10.0$ 分子/分钟，而mRNA的半衰期保持不变。\n\n计算细胞内 *StressResp1* mRNA 分子数量达到其新的、应激后稳态值的95%所需的时间。答案以分钟为单位，并四舍五入到三位有效数字。", "solution": "设 $N(t)$ 表示mRNA分子的数量。对于一级降解，其控制方程为\n$$\n\\frac{dN}{dt}=k_{tx}-\\gamma N,\n$$\n其中降解速率常数 $\\gamma$ 与半衰期 $t_{1/2}$ 的关系为\n$$\nt_{1/2}=\\frac{\\ln 2}{\\gamma}\\quad\\Rightarrow\\quad \\gamma=\\frac{\\ln 2}{t_{1/2}}.\n$$\n在 $t=0$ 之前，系统处于基础稳态，因此在 $t=0$ 时的初始条件为\n$$\nN(0)=N_{ss,basal}=\\frac{k_{tx,basal}}{\\gamma}.\n$$\n对于 $t\\ge 0$，转录速率为 $k_{tx,new}$，其稳态为\n$$\nN_{ss,new}=\\frac{k_{tx,new}}{\\gamma}.\n$$\n针对输入信号的阶跃变化，该线性常微分方程的解为\n$$\nN(t)=N_{ss,new}+\\bigl(N(0)-N_{ss,new}\\bigr)\\exp(-\\gamma t).\n$$\n我们想要求出当 $N(t)$ 达到 $0.95\\,N_{ss,new}$ 时的时间 $t$。令 $N(t)=0.95\\,N_{ss,new}$ 并求解 $t$，\n$$\n0.95\\,N_{ss,new}=N_{ss,new}+\\bigl(N(0)-N_{ss,new}\\bigr)\\exp(-\\gamma t),\n$$\n$$\n0.05\\,N_{ss,new}=\\bigl(N_{ss,new}-N(0)\\bigr)\\exp(-\\gamma t),\n$$\n$$\n\\exp(-\\gamma t)=\\frac{0.05\\,N_{ss,new}}{N_{ss,new}-N(0)}=\\frac{0.05\\,(k_{tx,new}/\\gamma)}{(k_{tx,new}-k_{tx,basal})/\\gamma}=\\frac{0.05\\,k_{tx,new}}{k_{tx,new}-k_{tx,basal}}.\n$$\n因此，\n$$\nt=\\frac{1}{\\gamma}\\ln\\!\\left(\\frac{k_{tx,new}-k_{tx,basal}}{0.05\\,k_{tx,new}}\\right)=\\frac{t_{1/2}}{\\ln 2}\\,\\ln\\!\\left(\\frac{k_{tx,new}-k_{tx,basal}}{0.05\\,k_{tx,new}}\\right).\n$$\n代入给定值 $t_{1/2}=7.0$，$k_{tx,basal}=0.50$，和 $k_{tx,new}=10.0$，\n$$\nt=\\frac{7.0}{\\ln 2}\\,\\ln\\!\\left(\\frac{10.0-0.50}{0.05\\cdot 10.0}\\right)=\\frac{7.0}{\\ln 2}\\,\\ln(19)\\approx 29.7.\n$$\n四舍五入到三位有效数字，所需时间为 $29.7$ 分钟。", "answer": "$$\\boxed{29.7}$$", "id": "1445057"}, {"introduction": "替代剪接是真核生物中一种普遍的机制，它允许单个基因产生多种不同的mRNA亚型，极大地丰富了蛋白质组的多样性。本练习将引导你进入一个更高级的计算生物学领域，使用图论来为mRNA剪接过程建模。你将把外显子视为节点，内含子剪接效率作为边的权重，通过动态规划等算法来量化不同剪接路径的概率和重要性，从而探索复杂的“剪接密码” [@problem_id:2404500]。", "problem": "您正在将信使 RNA (mRNA) 剪接建模为一个有向无环图，其中外显子是按 $5'$ 到 $3'$ 顺序排列的节点，而内含子则对应于具有效率值的有向边。考虑一个图 $G=(V,E)$，其中 $V=\\{1,2,\\dots,N\\}$ 按 $5'$ 到 $3'$ 的顺序索引外显子，每条有向边 $(i,j)\\in E$ 都满足 $i < j$，并有一个相关的权重 $w_{ij}\\in[0,1]$，表示将外显子 $i$ 直接连接到外显子 $j$ 的内含子剪接效率。一个有效的剪接异构体对应于从外显子 $1$ 到外显子 $N$ 的任何一条有向路径。特定路径的路径概率定义为该路径上所有边权重的乘积。假设不同边的内含子剪接事件是相互独立的。\n\n对于下方的每个测试用例，给定 $N$ 和带权重的边集 $E$，计算以下量：\n\n1. 从外显子 $1$ 到外显子 $N$ 的最大路径概率 $P_{\\max}$，定义为从 $1$ 到 $N$ 的所有有向路径 $\\pi$ 的边权重乘积 $\\prod_{(u,v)\\in \\pi} w_{uv}$ 的最大值。\n\n2. 总路径质量 $M$，定义为从外显子 $1$ 到外显子 $N$ 的所有有向路径的路径概率之和。\n\n3. 对于每个外显子 $k\\in\\{1,\\dots,N\\}$，其包含概率 $\\pi_k$，定义为所有从外显子 $1$ 到外显子 $N$ 且包含外显子 $k$ 的有向路径的概率之和，再除以 $M$。\n\n如果 $M=0$，则定义 $P_{\\max}=0$ 且对所有 $k$，$\\pi_k=0$。\n\n您的程序必须为每个测试用例生成一个列表，其中包含 $[P_{\\max},M,\\pi_1,\\pi_2,\\dots,\\pi_N]$ 的值，这些值是四舍五入到小数点后恰好 $6$ 位的十进制数。最终输出必须是单行文本，包含一个按顺序排列的、由各个测试用例列表组成的列表，不得包含其他任何文本。\n\n请使用以下测试套件：\n\n- 测试用例 1：$N=3$；边及其权重为 $w_{12}=0.9, w_{23}=0.8, w_{13}=0.3$。\n\n- 测试用例 2：$N=4$；边及其权重为 $w_{12}=0.5, w_{23}=0.6, w_{34}=0.9, w_{13}=0.4, w_{24}=0.2, w_{14}=0.05$。\n\n- 测试用例 3：$N=3$；边及其权重为 $w_{12}=1.0, w_{23}=0.0, w_{13}=0.7$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按上述规定贡献一个列表，例如：“[[...],[...],[...]]”。", "solution": "该问题陈述是有效的。它在一个有向无环图（DAG）上提出了一个适定的计算任务，这是计算生物学中可变剪接的一个标准模型。所有待计算量的定义在数学上都是精确的，并且该问题没有科学上的不准确、歧义或矛盾之处。该问题可以利用外显子（节点）的拓扑排序，通过动态规划高效地解决。\n\n该解决方案在图 $G=(V, E)$ 上包含三个主要的计算步骤，其中 $V=\\{1, 2, \\dots, N\\}$ 且一条边 $(i, j)$ 意味着 $i<j$。我们将在数组中使用基于 0 的索引，因此问题中的节点 $k$ 对应于索引 $k-1$。\n\n1.  **最大路径概率 ($P_{\\max}$)**\n\n    从外显子 $1$ 到外显子 $N$ 的最大路径概率可以使用一种类似于在 DAG 中寻找最长路径的动态规划方法来找到。令 $P_{\\max}(i)$ 为从起始外显子 $1$ 到外显子 $i$ 的最大路径概率。我们的目标是计算 $P_{\\max}(N)$。\n\n    -   **基准情形**：从外显子 $1$ 到其自身的路径没有边，因此其概率乘积为 $1$。故 $P_{\\max}(1) = 1$。对于任何其他从 $1$ 无法到达的节点 $i$，$P_{\\max}(i)$ 默认为 $0$。\n\n    -   **递推关系**：对于任何外显子 $i > 1$，从 $1$到 $i$ 的路径必须通过一条边 $(j, i)$ 从一个前驱外显子 $j$ 到达。到 $i$ 的最大路径概率是所有前驱 $j$ 的（到 $j$ 的路径概率乘以连接边 $(j, i)$ 的权重）中的最大值。外显子按其从 $1$ 到 $N$ 的自然顺序处理。\n        $$ P_{\\max}(i) = \\max_{j : (j, i) \\in E} \\{ P_{\\max}(j) \\cdot w_{ji} \\} $$\n        最终结果是 $P_{\\max} = P_{\\max}(N)$。如果不存在从 $1$ 到 $N$ 的路径，该值将为 $0$。\n\n2.  **总路径质量 ($M$)**\n\n    总路径质量 $M$ 是从外显子 $1$ 到外显子 $N$ 的所有不同路径的概率之和。这也可以使用动态规划来计算。令 $M_{fwd}(i)$ 为从外显子 $1$ 到外显子 $i$ 的所有路径的总质量。我们希望找到 $M = M_{fwd}(N)$。\n\n    -   **基准情形**：如前所述，从 $1$ 到 $1$ 有一条长度为 $0$ 的单一路径，其概率为 $1$。所以，$M_{fwd}(1) = 1$。\n\n    -   **递推关系**：对于任何外显子 $i > 1$，在 $i$ 处的总质量是其所有前驱贡献的质量之和。每个前驱 $j$ 贡献其自身的总质量 $M_{fwd}(j)$ 乘以边 $(j, i)$ 的权重。\n        $$ M_{fwd}(i) = \\sum_{j : (j, i) \\in E} M_{fwd}(j) \\cdot w_{ji} $$\n        最终结果是 $M = M_{fwd}(N)$。\n\n3.  **包含概率 ($\\pi_k$)**\n\n    外显子 $k$ 的包含概率 $\\pi_k$ 是所有从 $1$ 到 $N$ 且经过 $k$ 的路径的总概率，并用总路径质量 $M$ 进行归一化。\n    一条从 $1$ 到 $N$ 且经过 $k$ 的路径可以看作是一条从 $1$ 到 $k$ 的路径和一条从 $k$ 到 $N$ 的路径的串联。由于剪接事件的独立性，这样一条复合路径的概率是其组成子路径概率的乘积。\n\n    因此，经过 $k$ 的路径总质量是两个量的乘积：\n    - 从 $1$ 到 $k$ 的路径总质量：这正是我们已经计算过的 $M_{fwd}(k)$。\n    - 从 $k$ 到 $N$ 的路径总质量。我们将其称为 $M_{rev}(k)$。\n\n    $M_{rev}(k)$ 这一项可以通过一次“反向”动态规划来计算，即计算从每个外显子 $k$ 到最终外显子 $N$ 的总路径质量。\n\n    -   **基准情形**：从 $N$ 到其自身的路径总质量为 $1$，所以 $M_{rev}(N) = 1$。\n\n    -   **递推关系**：对于任何外显子 $k < N$，一条从 $k$ 开始的路径必须前进到一个后继外显子 $j$。总质量是来自所有后继的贡献之和。\n        $$ M_{rev}(k) = \\sum_{j : (k, j) \\in E} w_{kj} \\cdot M_{rev}(j) $$\n        该递推关系通过按从 $N-1$ 到 $1$ 的逆序处理外显子来求解。\n\n    最后，包含概率 $\\pi_k$ 由以下公式给出：\n    $$ \\pi_k = \\frac{M_{fwd}(k) \\cdot M_{rev}(k)}{M} $$\n    为了使此公式有效，我们必须有 $M > 0$。根据定义，对于任何从 $1$ 到 $N$ 的路径，外显子 $1$ 和 $N$ 必须被包含。因此，$\\pi_1 = \\frac{M_{fwd}(1) \\cdot M_{rev}(1)}{M} = \\frac{1 \\cdot M}{M} = 1$ 且 $\\pi_N = \\frac{M_{fwd}(N) \\cdot M_{rev}(N)}{M} = \\frac{M \\cdot 1}{M} = 1$。\n\n    如果 $M=0$，表示不存在从 $1$ 到 $N$ 的路径，问题陈述明确规定 $P_{\\max}=0$ 且对于所有 $k \\in \\{1, \\dots, N\\}$，$\\pi_k=0$。我们的算法通过在计算包含概率之前检查 $M$ 的计算值来处理这种情况。", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(N, edges):\n    \"\"\"\n    Computes P_max, M, and pi_k for a single mRNA splicing graph.\n\n    Args:\n        N (int): The number of exons.\n        edges (list of tuples): A list of (u, v, w) tuples representing edges.\n\n    Returns:\n        list: A list of floats [P_max, M, pi_1, ..., pi_N].\n    \"\"\"\n    # Use 0-based indexing for nodes 0 to N-1\n    pred = [[] for _ in range(N)]\n    succ = [[] for _ in range(N)]\n    for u, v, w in edges:\n        pred[v - 1].append((u - 1, w))\n        succ[u - 1].append((v - 1, w))\n\n    # 1. Maximum path probability (P_max)\n    p_max = np.zeros(N, dtype=float)\n    if N > 0:\n        p_max[0] = 1.0\n    for i in range(1, N):\n        max_prob = 0.0\n        for j, w in pred[i]:\n            max_prob = max(max_prob, p_max[j] * w)\n        p_max[i] = max_prob\n    P_max = p_max[N - 1] if N > 0 else 0.0\n\n    # 2. Total path mass (M) and forward masses (m_fwd)\n    m_fwd = np.zeros(N, dtype=float)\n    if N > 0:\n        m_fwd[0] = 1.0\n    for i in range(1, N):\n        total_mass = 0.0\n        for j, w in pred[i]:\n            total_mass += m_fwd[j] * w\n        m_fwd[i] = total_mass\n    M = m_fwd[N - 1] if N > 0 else 0.0\n\n    # Handle case where no path exists from 1 to N\n    if M == 0:\n        return [0.0] * (2 + N)\n\n    # 3. Backward masses (m_rev)\n    m_rev = np.zeros(N, dtype=float)\n    if N > 0:\n        m_rev[N - 1] = 1.0\n    for k in range(N - 2, -1, -1):\n        total_mass = 0.0\n        for j, w in succ[k]:\n            total_mass += w * m_rev[j]\n        m_rev[k] = total_mass\n\n    # 4. Inclusion probabilities (pi_k)\n    pi = np.zeros(N, dtype=float)\n    for k in range(N):\n        pi[k] = (m_fwd[k] * m_rev[k]) / M\n\n    result = [P_max, M] + pi.tolist()\n    return result\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (3, [(1, 2, 0.9), (2, 3, 0.8), (1, 3, 0.3)]),\n        (4, [(1, 2, 0.5), (2, 3, 0.6), (3, 4, 0.9), (1, 3, 0.4), (2, 4, 0.2), (1, 4, 0.05)]),\n        (3, [(1, 2, 1.0), (2, 3, 0.0), (1, 3, 0.7)]),\n    ]\n\n    all_results = []\n    for N, edges in test_cases:\n        case_result_raw = calculate_metrics(N, edges)\n        # Format results to exactly 6 decimal places\n        formatted_case_result = [f\"{v:.6f}\" for v in case_result_raw]\n        all_results.append(f\"[{','.join(formatted_case_result)}]\")\n\n    # Print the final output in the required single-line format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2404500"}]}