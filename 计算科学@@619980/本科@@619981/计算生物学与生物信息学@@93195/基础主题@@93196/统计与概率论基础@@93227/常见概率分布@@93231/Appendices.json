{"hands_on_practices": [{"introduction": "寡核苷酸合成是现代生物技术的核心。这个练习将带你探讨一个实际问题：在合成过程中，每个碱基的添加都有微小的出错概率，如何计算最终得到一条完美DNA链的概率？通过这个实践[@problem_id:2381059]，你将应用独立事件概率和二项分布的原理，来量化生物合成过程的成功率。", "problem": "在一个长度为 $100$ 的寡核苷酸的高通量化学合成过程中，每个核苷酸的掺入事件都是独立的，并且在每个位置上，发生错误掺入（即错误）的概率为 $1/500$。只有当寡核苷酸链上任何位置都没有发生错误掺入时，该寡核苷酸才被认为是完美的。\n\n在这些假设下，一个合成的 $100$-聚体是完美的概率是多少？请以小数形式提供答案，并四舍五入到 $4$ 位有效数字。", "solution": "首先对问题陈述进行严格验证。\n\n逐字提取的已知条件如下：\n1.  寡核苷酸长度：$100$。\n2.  每个核苷酸掺入事件是独立的。\n3.  每个位置发生错误掺入的概率：$1/500$。\n4.  只有在没有发生任何错误掺入时，寡核苷酸才被认为是完美的。\n5.  最终答案必须是四舍五入到 $4$ 位有效数字的小数。\n\n验证评估：\n-   **具有科学依据：** 该问题提出了一个简化但标准且科学上有效的寡核苷酸合成错误模型。给定的参数是符合实际的。\n-   **问题定义明确：** 该问题定义清晰。给定的条件充分且一致，足以计算出唯一的概率。\n-   **客观性：** 语言是定量的、精确的，没有任何主观或模棱两可的术语。\n\n该问题被认为是有效的，因为它具有科学依据、问题定义明确、客观，并且没有违反任何无效标准。我们可以继续进行求解。\n\n设 $L$ 为寡核苷酸的长度，所以 $L=100$。\n设 $p_{error}$ 为在任何单个位置发生错误掺入的概率。我们已知 $p_{error} = \\frac{1}{500}$。\n在 $L$ 个位置上，每个位置的掺入事件都是独立的。\n为了使寡核苷酸是完美的，每个位置都必须发生正确的掺入。\n设 $p_{correct}$ 为在单个位置发生正确掺入的概率。由于这是错误掺入的互补事件，其概率为：\n$$p_{correct} = 1 - p_{error} = 1 - \\frac{1}{500} = \\frac{499}{500}$$\n为了使整个 $100$-聚体是完美的，必须有 $100$ 次独立的正确掺入。一系列独立事件的概率是它们各自概率的乘积。\n设 $P(\\text{perfect})$ 为合成的 $100$-聚体是完美的概率。这要求在位置 $1$ 发生正确掺入，并且在位置 $2$ 发生正确掺入，...，并且在位置 $100$ 发生正确掺入。\n因此，$P(\\text{perfect})$ 是 $p_{correct}$ 自身相乘 $L$ 次的积：\n$$P(\\text{perfect}) = (p_{correct})^{L}$$\n代入给定值：\n$$P(\\text{perfect}) = \\left(\\frac{499}{500}\\right)^{100}$$\n这个问题也可以用二项分布来正式描述。设 $X$ 为一个随机变量，表示在长度为 $L=100$ 的序列中错误掺入的数量。那么 $X$ 服从二项分布 $X \\sim B(n, p)$，其中试验次数为 $n=L=100$，“成功”（这里定义为一次错误掺入）的概率为 $p=p_{error}=\\frac{1}{500}$。\n观察到恰好 $k$ 次错误掺入的概率由概率质量函数给出：\n$$P(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}$$\n一个完美的寡核苷酸对应于发生零次错误掺入的情况，即 $k=0$。\n$$P(X=0) = \\binom{100}{0} \\left(\\frac{1}{500}\\right)^{0} \\left(1-\\frac{1}{500}\\right)^{100-0}$$\n使用恒等式 $\\binom{n}{0} = 1$ 和对于任何非零 $x$，$x^0 = 1$，上式可简化为：\n$$P(X=0) = 1 \\cdot 1 \\cdot \\left(\\frac{499}{500}\\right)^{100} = \\left(\\frac{499}{500}\\right)^{100}$$\n这证实了最初的推理。我们现在计算其数值。\n$$P(\\text{perfect}) = (0.998)^{100}$$\n计算这个值得到：\n$$P(\\text{perfect}) \\approx 0.8185852503...$$\n问题要求答案四舍五入到 $4$ 位有效数字。前四位有效数字是 $8$、$1$、$8$ 和 $5$。第五位有效数字是 $8$，大于等于 $5$，所以我们必须对第四位有效数字进行向上取整。\n$$P(\\text{perfect}) \\approx 0.8186$$\n这是最终的概率。", "answer": "$$\\boxed{0.8186}$$", "id": "2381059"}, {"introduction": "在基因组学中，我们经常需要用统计模型来描述生物特征的分布，例如基因的长度。正态分布是一种强大而常见的工具，尽管它是一个连续模型，但常被用来近似描述像基因长度这样的离散但数值范围大的变量。这个练习[@problem_id:2381054]将指导你如何利用正态分布的特性，通过标准化（计算z分数）来估算特定长度范围内的基因所占的比例。", "problem": "在一个细菌物种的比较基因组学分析中，假设随机选择的一个基因的长度（单位为碱基对）被建模为一个连续随机变量 $L$，该变量服从均值为 $\\mu$、方差为 $\\sigma^{2}$ 的正态分布。具体来说，假设 $L \\sim \\mathcal{N}(\\mu,\\sigma^{2})$，其中 $\\mu = 950$，$\\sigma = 300$。仅使用正态分布的定义、线性变换的性质以及标准正态分布的累积分布函数（CDF），确定长度小于 $500$ 碱基对（bp）的基因所占的比例。将你的最终结果表示为小数，并四舍五入到 $4$ 位有效数字。", "solution": "所提出的问题是有效且有科学依据的，尽管对于像基因长度这样严格为正的量使用正态分布是一种常见的理论简化。在该模型下，出现非物理的负长度的可能性可以忽略不计，因为均值 $\\mu = 950$ 相对于标准差 $\\sigma = 300$ 足够大（$\\mu/\\sigma \\approx 3.17$）。我们现在开始进行正式求解。\n\n基因的长度，用连续随机变量 $L$ 表示，被建模为正态分布 $L \\sim \\mathcal{N}(\\mu, \\sigma^2)$。给定的参数是均值 $\\mu = 950$ 和标准差 $\\sigma = 300$。我们的目标是计算长度小于 500 碱基对的基因所占的比例，即概率 $P(L < 500)$。\n\n问题明确要求使用线性变换来标准化该变量。这是正确且标准的方法。任何均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布随机变量 $X$ 都可以通过以下变换转换为标准正态随机变量 $Z \\sim \\mathcal{N}(0, 1)$：\n$$Z = \\frac{X - \\mu}{\\sigma}$$\n将此变换应用于随机变量 $L$，我们可以用 $Z$ 来表示所求的概率。$L < 500$ 事件等价于涉及 $Z$ 的事件：\n$$P(L < 500) = P\\left(\\frac{L - \\mu}{\\sigma} < \\frac{500 - \\mu}{\\sigma}\\right)$$\n代入 $\\mu$ 和 $\\sigma$ 的给定值：\n$$P(L < 500) = P\\left(Z < \\frac{500 - 950}{300}\\right)$$\n我们对标准化值进行算术计算，该值通常称为 z-score：\n$$z = \\frac{500 - 950}{300} = \\frac{-450}{300} = -1.5$$\n因此，问题简化为求标准正态随机变量 $Z$ 小于 $-1.5$ 的概率：\n$$P(L < 500) = P(Z < -1.5)$$\n根据定义，这个概率是标准正态分布的累积分布函数（CDF），记为 $\\Phi(z)$，在 $z = -1.5$ 处的值。\n$$P(L < 500) = \\Phi(-1.5)$$\n$\\Phi(-1.5)$ 的值必须从标准正态概率表或可靠的计算来源获得。该值约为：\n$$\\Phi(-1.5) \\approx 0.0668072$$\n问题要求将此结果四舍五入到 4 位有效数字。0.0668072 中的前四位有效数字是 6、6、8 和 0。第五位有效数字是 7，大于或等于 5，所以我们将第四位有效数字向上取整。\n$$0.0668072 \\approx 0.06681$$\n因此，长度小于 500 碱基对的基因所占的比例约为 0.06681。", "answer": "$$\\boxed{0.06681}$$", "id": "2381054"}, {"introduction": "生物系统通常是动态且充满随机性的，对它们进行建模是计算生物学的一大挑战。这个综合性练习[@problem_id:2381044]模拟了一个微生物种群的繁衍、存活与死亡，让你将多种概率分布知识融会贯通。你将需要根据不同的初始条件和种群规模，分别应用多项分布、正态近似以及泊松过程等概念来解决问题，体验构建和分析随机生物模型的全过程。", "problem": "一种微生物种群以离散的时间步长演化。在每一步中，每个细胞独立地经历三种互斥结果之一：以概率 $p_d$ 分裂成两个细胞，以概率 $p_m$ 死亡，或以概率 $1 - p_d - p_m$ 保持为单个细胞。所有细胞的行为相互独立，且在给定当前时间步的条件下，与过去无关。设 $N_0$ 表示一步开始时的细胞数量，$N_1$ 表示该步结束时的细胞数量。除非另有说明，所有概率都必须以小数形式报告，并四舍五入到六位小数。\n\n基于此模型，计算下列参数集的所求概率。每个部分都是一个独立的测试用例；最终的程序输出必须按下列顺序列出汇总结果。\n\n测试套件：\n\n- 案例 A（精确计算，固定初始规模）：给定初始细胞数为 $N_0 = n_0$ 且 $n_0 = 10$，$p_d = 0.3$，$p_m = 0.2$，计算一步之后细胞总数恰好为 $k_A = 12$ 的精确概率。\n\n- 案例 B（大种群近似）：给定初始细胞数为 $N_0 = n_0$ 且 $n_0 = 3000$，$p_d = 0.02$，$p_m = 0.015$，将一步后的总数建模为近似高斯分布，其参数由模型所蕴含的单个细胞结果分布和独立性确定。在此近似下，计算细胞总数小于或等于 $k_B = 3050$ 的概率。将高斯近似解释为实数线上的连续分布，并且不应用连续性校正。\n\n- 案例 C（泊松初始种群，净变化）：假设 $N_0$ 是一个均值为 $\\lambda_0 = 200$ 的泊松随机变量。给定 $p_d = 0.04$ 和 $p_m = 0.06$，计算一步之内细胞数量的净变化 $\\Delta = N_1 - N_0 = r_C = -5$ 的精确概率。\n\n- 案例 D（无分裂的边界情况）：给定初始细胞数为 $N_0 = n_0$ 且 $n_0 = 25$，$p_d = 0$，$p_m = 0.1$，计算一步之后细胞总数恰好为 $k_D = 22$ 的精确概率。\n\n你的程序应产生单行输出，包含用方括号括起来的、以逗号分隔的结果列表，顺序为 $[\\text{案例 A 结果}, \\text{案例 B 结果}, \\text{案例 C 结果}, \\text{案例 D 结果}]$。例如，它应该看起来像 $[x_A,x_B,x_C,x_D]$，其中每个 $x_\\cdot$ 都是一个四舍五入到六位小数的小数。", "solution": "问题陈述已经过严格验证。所描述的模型是一个标准的离散时间分支过程，这是随机建模中的一个基本构造。所有参数均已提供，问题在数学上是精确的，并且框架在科学上是合理的。不存在矛盾、歧义或事实不准确之处。该问题被认为是有效的，现在将提供一个完整的解决方案。\n\n模型的核心是单个细胞在一个时间步长内的结果集合。一个细胞可以分裂成 $2$ 个，存活为 $1$ 个，或死亡变成 $0$ 个细胞。设随机变量 $X$ 表示单个祖细胞在一步结束时产生的细胞数量。$X$ 的概率质量函数是：\n$$\nP(X=k) = \n\\begin{cases} \np_d & \\text{if } k=2 \\\\\np_m & \\text{if } k=0 \\\\\n1 - p_d - p_m & \\text{if } k=1 \n\\end{cases}\n$$\n如果初始种群规模为 $N_0 = n_0$，则一步后的种群规模 $N_1$ 是 $n_0$ 个独立同分布的随机变量 $X_i$ 的总和，每个 $X_i$ 的分布都与 $X$ 相同：\n$$ N_1 = \\sum_{i=1}^{n_0} X_i $$\n此框架将应用于每个案例。\n\n案例 A：初始种群固定为 $N_0 = n_0 = 10$。概率为 $p_d = 0.3$ 和 $p_m = 0.2$，这意味着存活概率为 $p_s = 1 - 0.3 - 0.2 = 0.5$。我们必须计算 $N_1 = k_A = 12$ 的精确概率。\n\n设 $d$、$m$ 和 $s$ 分别为初始 $n_0=10$ 个细胞中分裂、死亡和存活的细胞数量。这些数字必须满足 $d+m+s=10$。一步后的细胞总数为 $N_1 = 2d + 1s + 0m$。给定 $N_1=12$。\n通过代入 $s = n_0 - d - m$，我们可以用 $d$、$m$ 和 $n_0$ 来表示 $N_1$：\n$$N_1 = 2d + (n_0 - d - m) = n_0 + d - m$$\n在此案例中，我们有 $12 = 10 + d - m$，可简化为条件 $d - m = 2$。\n我们必须找到所有满足约束条件 $d-m=2$ 和 $d+m \\le 10$ 的非负整数对 $(d,m)$。可能的数对为 $(d,m) \\in \\{(2,0), (3,1), (4,2), (5,3), (6,4)\\}$。\n任何特定构型 $(d,m,s)$ 的概率由多项式概率质量函数给出：\n$$P(D=d, M=m, S=s) = \\frac{n_0!}{d!m!s!} p_d^d p_m^m p_s^s$$\n总概率是所有有效构型的总和：\n$$P(N_1=12) = \\sum_{(d,m,s)} \\frac{10!}{d!m!s!} (0.3)^d (0.2)^m (0.5)^s$$\n总和是基于从 $d-m=2$ 导出的五种组合：\n\\begin{itemize}\n    \\item $(d,m,s)=(2,0,8)：\\frac{10!}{2!0!8!}(0.3)^2(0.2)^0(0.5)^8 \\approx 0.015800$\n    \\item $(d,m,s)=(3,1,6)：\\frac{10!}{3!1!6!}(0.3)^3(0.2)^1(0.5)^6 = 0.070875$\n    \\item $(d,m,s)=(4,2,4)：\\frac{10!}{4!2!4!}(0.3)^4(0.2)^2(0.5)^4 = 0.063788$\n    \\item $(d,m,s)=(5,3,2)：\\frac{10!}{5!3!2!}(0.3)^5(0.2)^3(0.5)^2 = 0.012247$\n    \\item $(d,m,s)=(6,4,0)：\\frac{10!}{6!4!0!}(0.3)^6(0.2)^4(0.5)^0 \\approx 0.000246$\n\\end{itemize}\n将这些概率相加得到 $P(N_1=12) \\approx 0.162956$。\n\n案例 B：初始种群数量很大，$N_0 = n_0 = 3000$，且 $p_d = 0.02$，$p_m = 0.015$。存活概率为 $p_s = 1 - 0.02 - 0.015 = 0.965$。我们将使用高斯近似来计算 $N_1$ 以求得 $P(N_1 \\le k_B = 3050)$。\n根据中心极限定理，对于大的 $n_0$，$N_1 = \\sum_{i=1}^{n_0} X_i$ 的分布趋近于正态分布 $\\mathcal{N}(\\mu_{N_1}, \\sigma^2_{N_1})$。其参数由单个细胞结果分布 $X$ 的均值和方差决定。\n$X$ 的均值为 $E[X] = 2 \\cdot p_d + 1 \\cdot p_s + 0 \\cdot p_m = 2(0.02) + 1(0.965) = 1.005$。\n$N_1$ 的均值为 $\\mu_{N_1} = n_0 E[X] = 3000 \\cdot 1.005 = 3015$。\n为了求方差，我们首先计算 $E[X^2] = 2^2 \\cdot p_d + 1^2 \\cdot p_s + 0^2 \\cdot p_m = 4(0.02) + 1(0.965) = 1.045$。\n$X$ 的方差为 $Var(X) = E[X^2] - (E[X])^2 = 1.045 - (1.005)^2 = 1.045 - 1.010025 = 0.034975$。\n$N_1$ 的方差为 $\\sigma^2_{N_1} = n_0 Var(X) = 3000 \\cdot 0.034975 = 104.925$。\n标准差为 $\\sigma_{N_1} = \\sqrt{104.925} \\approx 10.24329$。\n我们要求 $P(N_1 \\le 3050)$，其中 $N_1 \\sim \\mathcal{N}(3015, 104.925)$。我们将值 $3050$ 标准化：\n$$Z = \\frac{3050 - \\mu_{N_1}}{\\sigma_{N_1}} = \\frac{3050 - 3015}{\\sqrt{104.925}} = \\frac{35}{10.24329} \\approx 3.41680$$\n所求概率是标准正态累积分布函数 $\\Phi(Z)$ 的值：\n$$P(N_1 \\le 3050) = \\Phi(3.41680) \\approx 0.999685$$\n\n案例 C：初始种群 $N_0$ 是一个均值为 $\\lambda_0 = 200$ 的泊松随机变量。概率为 $p_d=0.04$ 和 $p_m=0.06$，因此 $p_s=0.9$。我们必须求出净变化 $\\Delta = N_1 - N_0 = r_C = -5$ 的精确概率。\n泊松过程的一个关键特性是，如果泊松分布数量的个体独立地进行多项式分类，则每个结果类别中的个体数量是独立的泊松随机变量。\n设 $N_d$、$N_m$ 和 $N_s$ 分别是分裂、死亡和存活的初始细胞数量。那么：\n$N_d \\sim \\text{Poisson}(\\lambda_d = \\lambda_0 p_d = 200 \\cdot 0.04 = 8)$\n$N_m \\sim \\text{Poisson}(\\lambda_m = \\lambda_0 p_m = 200 \\cdot 0.06 = 12)$\n$N_s \\sim \\text{Poisson}(\\lambda_s = \\lambda_0 p_s = 200 \\cdot 0.9 = 180)$\n总种群规模为 $N_0 = N_d + N_m + N_s$ 和 $N_1 = 2N_d + 1N_s + 0N_m$。\n净变化为 $\\Delta = N_1 - N_0 = (2N_d + N_s) - (N_d + N_m + N_s) = N_d - N_m$。\n我们需要求 $P(N_d - N_m = -5)$。两个独立泊松随机变量的差遵循 Skellam 分布。设 $Y = N_d - N_m$。则 $Y \\sim \\text{Skellam}(\\mu_1=\\lambda_d, \\mu_2=\\lambda_m)$。\n我们需要参数为 $\\mu_1 = 8$ 和 $\\mu_2 = 12$ 时的概率 $P(Y = -5)$。Skellam 分布的概率质量函数为 $P(Y=k) = e^{-(\\mu_1+\\mu_2)} (\\frac{\\mu_1}{\\mu_2})^{k/2} I_{|k|}(2\\sqrt{\\mu_1\\mu_2})$，其中 $I_{|k|}$ 是第一类修正贝塞尔函数。使用计算库对 $k=-5$，$\\mu_1=8$ 和 $\\mu_2=12$ 计算该函数，得出 $P(\\Delta = -5) \\approx 0.064560$。\n\n案例 D：初始种群为 $N_0 = n_0 = 25$，且 $p_d=0$，$p_m=0.1$。存活概率为 $p_s = 1 - 0 - 0.1 = 0.9$。我们必须求出 $N_1 = k_D = 22$ 的精确概率。\n由于 $p_d=0$，没有细胞分裂。一个细胞要么存活（概率为 $0.9$），要么死亡（概率为 $0.1$）。最终种群规模 $N_1$ 就是存活细胞的数量。这是一个经典的二项试验问题。存活细胞的数量 $S$ 遵循二项分布：\n$$S \\sim \\text{Binomial}(n=n_0, p=p_s) = \\text{Binomial}(n=25, p=0.9)$$\n我们需要计算 $P(N_1=22) = P(S=22)$。使用二项分布的概率质量函数：\n$$P(S=k) = \\binom{n}{k} p^k (1-p)^{n-k}$$\n$$P(S=22) = \\binom{25}{22} (0.9)^{22} (1-0.9)^{25-22} = \\frac{25 \\cdot 24 \\cdot 23}{3 \\cdot 2 \\cdot 1} (0.9)^{22} (0.1)^3$$\n$$P(S=22) = 2300 \\cdot (0.9)^{22} \\cdot (0.001) \\approx 0.226498$$\n至此，所有案例的推导完毕。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, skellam, binom\nfrom scipy.special import comb\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\ndef solve_case_a(n0, pd, pm, kA):\n    \"\"\"\n    Computes the exact probability P(N1=kA) for a fixed initial population size.\n    This involves summing probabilities over all state configurations (d, m, s)\n    that result in the target population size.\n    \"\"\"\n    ps = 1 - pd - pm\n    # We require N1 = n0 + d - m = kA, which means d - m = kA - n0.\n    delta = kA - n0\n\n    total_prob = 0.0\n    # Iterate through all possible numbers of deaths 'm'\n    for m in range(n0 + 1):\n        # From d - m = delta, we get d = m + delta\n        d = m + delta\n        # The numbers of divisions and deaths must be non-negative\n        if d < 0:\n            continue\n        # The sum of cells undergoing any fate cannot exceed the initial population\n        if d + m > n0:\n            break\n        \n        s = n0 - d - m\n        \n        # Multinomial coefficient: n! / (d! * m! * s!)\n        # Calculated as comb(n,d) * comb(n-d,m) to avoid large numbers in factorial\n        coeff = comb(n0, d, exact=True) * comb(n0 - d, m, exact=True)\n        prob = coeff * (pd ** d) * (pm ** m) * (ps ** s)\n        total_prob += prob\n        \n    return total_prob\n\ndef solve_case_b(n0, pd, pm, kB):\n    \"\"\"\n    Computes P(N1 <= kB) using a Gaussian approximation for the final population size.\n    \"\"\"\n    ps = 1 - pd - pm\n    # Mean and variance of the number of offspring from a single cell (X)\n    mu_x = 2 * pd + 1 * ps\n    e_x_sq = 4 * pd + 1 * ps\n    var_x = e_x_sq - mu_x**2\n    \n    # Mean and variance of the total final population (N1)\n    mu_n1 = n0 * mu_x\n    var_n1 = n0 * var_x\n    \n    # Use the CDF of the normal distribution\n    return norm.cdf(kB, loc=mu_n1, scale=np.sqrt(var_n1))\n\ndef solve_case_c(lambda0, pd, pm, rC):\n    \"\"\"\n    Computes the exact probability that the net change N1 - N0 is rC,\n    when the initial population N0 is a Poisson random variable.\n    \"\"\"\n    # The number of dividing and dying cells are independent Poisson variables\n    lambda_d = lambda0 * pd\n    lambda_m = lambda0 * pm\n    \n    # The net change N1 - N0 is the difference between the number of divisions \n    # and the number of deaths, which follows a Skellam distribution.\n    return skellam.pmf(rC, lambda_d, lambda_m)\n\ndef solve_case_d(n0, pd, pm, kD):\n    \"\"\"\n    Computes the exact probability P(N1=kD) in the case of no divisions (pd=0).\n    This simplifies to a binomial probability.\n    \"\"\"\n    ps = 1 - pd - pm\n    # With no divisions, N1 is the number of surviving cells, which follows\n    # a binomial distribution.\n    return binom.pmf(kD, n0, ps)\n\ndef solve():\n    \"\"\"\n    Solves all test cases and prints the results in the required format.\n    \"\"\"\n    # Define test case parameters.\n    # Case A: (n0, pd, pm, kA)\n    # Case B: (n0, pd, pm, kB)\n    # Case C: (lambda0, pd, pm, rC)\n    # Case D: (n0, pd, pm, kD)\n    test_cases = {\n        'A': (10, 0.3, 0.2, 12),\n        'B': (3000, 0.02, 0.015, 3050),\n        'C': (200, 0.04, 0.06, -5),\n        'D': (25, 0.0, 0.1, 22),\n    }\n\n    # Calculate results for each case\n    result_a = solve_case_a(*test_cases['A'])\n    result_b = solve_case_b(*test_cases['B'])\n    result_c = solve_case_c(*test_cases['C'])\n    result_d = solve_case_d(*test_cases['D'])\n\n    results = [result_a, result_b, result_c, result_d]\n\n    # Format results to six decimal places and print\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2381044"}]}