{"hands_on_practices": [{"introduction": "贝叶斯定理在诊断医学中扮演着核心角色，它提供了一个数学框架，用于根据新的证据（例如检验结果）更新我们对某个假设（例如患者是否患有某种疾病）的信念。这个练习将带你扮演一位兽医的角色，面对一个神秘的症状。通过处理先验概率（疾病的普遍性）、敏感性（真阳性率）和特异性（真阴性率），你将学会如何结合所有信息，计算出在一次阴性检测结果后，宠物患上另一种罕见疾病的后验概率。这个过程是生物信息学和临床决策中进行概率推理的基石 [@problem_id:1898684]。", "problem": "一位兽医正在调查狗的一种奇特新症状：脚垫出现微弱、间歇性的生物发光。经过广泛研究，确定该症状仅由两种互斥且罕见的疾病之一引起：Canine Lumiviral Infection (CLI) 或 Amber-Paw Syndrome (APS)。\n\n在普通犬类群体中，CLI 的患病率为 1/100，而 APS 的患病率为 1/2000。并非所有患有这些疾病的狗都会表现出该症状。患有 CLI 的狗表现出发光脚垫症状的概率是 0.80。患有 APS 的狗表现出该症状的概率是 0.95。\n\n有一种针对 CLI 的快速诊断测试，但没有针对 APS 的。该 CLI 测试的灵敏度为 0.98，特异性为 0.99。\n\n一只表现出发光脚垫症状的狗被带到诊所。兽医对它进行了 CLI 测试，结果呈阴性。鉴于这些信息，这只狗患有 Amber-Paw Syndrome 的概率是多少？\n\n计算你的答案，并四舍五入到三位有效数字。", "solution": "设 $C$ 表示 CLI，$A$ 表示 APS，$S$ 表示发光脚垫症状，$N$ 表示 CLI 测试结果为阴性。已知：$P(C)=\\frac{1}{100}=0.01$，$P(A)=\\frac{1}{2000}=0.0005$，$P(S\\mid C)=0.80$，$P(S\\mid A)=0.95$。CLI 测试的灵敏度为 $0.98$，特异性为 $0.99$，所以 $P(N\\mid C)=1-0.98=0.02$，并且由于 $A$ 意味着不是 $C$，$P(N\\mid A)=0.99$。该症状仅由 $C$ 或 $A$ 引起，因此可以忽略其他原因。\n\n我们要求解 $P(A\\mid S,N)$。根据贝叶斯定理，并在给定疾病条件下 $S$ 和 $N$ 条件独立，我们有\n$$\nP(A\\mid S,N)=\\frac{P(A)P(S\\mid A)P(N\\mid A)}{P(C)P(S\\mid C)P(N\\mid C)+P(A)P(S\\mid A)P(N\\mid A)}.\n$$\n计算各项：\n$$\nP(A)P(S\\mid A)P(N\\mid A)=\\frac{1}{2000}\\cdot 0.95\\cdot 0.99=0.00047025,\n$$\n$$\nP(C)P(S\\mid C)P(N\\mid C)=\\frac{1}{100}\\cdot 0.80\\cdot 0.02=0.00016.\n$$\n因此\n$$\nP(A\\mid S,N)=\\frac{0.00047025}{0.00016+0.00047025}=\\frac{1881}{2521}\\approx 0.746133\\ldots\n$$\n四舍五入到三位有效数字，结果为 $0.746$。", "answer": "$$\\boxed{0.746}$$", "id": "1898684"}, {"introduction": "在生物信息学中，尤其是在遗传关联研究中，简单地观察数据可能会导致错误的结论，这种现象被称为辛普森悖论。当一个趋势在数据的不同子集中都存在，但在合并数据后却消失或逆转时，悖论就出现了。此练习通过一个真实的遗传学场景，即群体分层，向你展示了如何使用贝叶斯因果模型（特别是“有向无环图”或 DAGs）来识别和纠正由混杂变量引起的偏差。解决这个问题将锻炼你超越表面相关性、进行严谨因果推断的能力，这是解释复杂生物学数据的关键技能 [@problem_id:2374723]。", "problem": "一项生物样本库研究汇总了来自两个祖先上不同的亚群体的个体。设二元变量为：基因型指示变量 $G \\in \\{0,1\\}$ 表示一个等位基因存在 ($G=1$) 与否 ($G=0$)，疾病状态 $D \\in \\{0,1\\}$ 表示病例 ($D=1$) 与对照 ($D=0$)，以及亚群体 $S \\in \\{s_{0}, s_{1}\\}$。在每个亚群体内部，该等位基因被认为会增加风险：对于 $S=s_{0}$，层内风险为 $P(D=1 \\mid G=0, S=s_{0}) = 0.01$ 和 $P(D=1 \\mid G=1, S=s_{0}) = 0.02$；对于 $S=s_{1}$，层内风险为 $P(D=1 \\mid G=0, S=s_{1}) = 0.20$ 和 $P(D=1 \\mid G=1, S=s_{1}) = 0.30$。亚群体的混合比例为 $P(S=s_{0}) = 0.70$ 和 $P(S=s_{1}) = 0.30$。该等位基因在 $s_{0}$ 中比在 $s_{1}$ 中常见得多：$P(G=1 \\mid S=s_{0}) = 0.90$ 和 $P(G=1 \\mid S=s_{1}) = 0.10$。\n\n仅使用联合概率、条件概率的定义以及全概率定律作为基本出发点，完成以下任务：为被称为 Simpson 悖论的观测到的逆转现象推断出恰当的因果解释和调整策略，并计算上述数值所蕴含的边际风险 $P(D=1 \\mid G=1)$ 和 $P(D=1 \\mid G=0)$，以检验该等位基因在每个亚群体内部有害的情况下，在总体上是否表现出保护性。\n\n哪个选项使用贝叶斯因果模型最好地解释了该悖论，并指出了恢复 $G$ 对 $D$ 的因果效应的正确调整方法？\n\nA. 一个包含边 $S \\rightarrow G$、$S \\rightarrow D$ 和 $G \\rightarrow D$ 的有向无环图 (DAG) 解释了这种逆转：$S$ 混淆了 $G \\rightarrow D$ 的关系，因为它同时影响 $G$ 和 $D$ 。边际关联 $P(D=1 \\mid G)$ 是关于 $S$ 的一个混合，因此根据给定的数值，即使对于每个分层 $s \\in \\{s_{0}, s_{1}\\}$ 都有 $P(D=1 \\mid G=1, S=s) > P(D=1 \\mid G=0, S=s)$，我们仍然会得到 $P(D=1 \\mid G=1) < P(D=1 \\mid G=0)$。对 $S$ 进行调整可以恢复该等位基因真实的增加风险的效应。\n\nB. 一个包含 $G \\rightarrow S \\leftarrow D$ 的 DAG（因此 $S$ 是一个对撞节点）可以解释这种逆转：悖论仅在对 $S$ 进行条件化时出现。不进行条件化，边际关联就等于因果效应，所以不需要调整，并且给定的数值将意味着 $P(D=1 \\mid G=1) > P(D=1 \\mid G=0)$。\n\nC. 一个包含 $G \\leftarrow S \\rightarrow D$ 的 DAG 可以解释这种逆转，但要消除偏倚，必须对结果 $D$ 而不是 $S$ 进行调整。只有在对 $D$ 进行条件化之后，总体关联才会反转方向。\n\nD. 一个包含 $G \\rightarrow D$ 且没有其他边的 DAG 解释了数据；不存在混淆，观察到的逆转是抽样变异性。边际关联和条件关联在方向上一致，因此不需要调整。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤1：提取已知条件**\n提供的定量信息如下：\n-   一组三个二元随机变量：$G \\in \\{0,1\\}$ (基因型)，$D \\in \\{0,1\\}$ (疾病状态)，$S \\in \\{s_{0}, s_{1}\\}$ (亚群体)。\n-   亚群体 $s_{0}$ 的层内条件概率 (风险)：\n    $P(D=1 \\mid G=0, S=s_{0}) = 0.01$\n    $P(D=1 \\mid G=1, S=s_{0}) = 0.02$\n-   亚群体 $s_{1}$ 的层内条件概率 (风险)：\n    $P(D=1 \\mid G=0, S=s_{1}) = 0.20$\n    $P(D=1 \\mid G=1, S=s_{1}) = 0.30$\n-   亚群体边际概率 (混合比例)：\n    $P(S=s_{0}) = 0.70$\n    $P(S=s_{1}) = 0.30$\n-   以亚群体为条件的等位基因频率：\n    $P(G=1 \\mid S=s_{0}) = 0.90$\n    $P(G=1 \\mid S=s_{1}) = 0.10$\n\n**步骤2：验证问题陈述**\n该问题描述了一个由混淆导致 Simpson 悖论的经典场景，这是一个公认的统计现象。其背景是遗传关联研究中的群体分层，这是生物信息学和统计遗传学中的一个基本课题。所有概率都定义良好，并在需要时总和为一 (例如，$P(S=s_{0}) + P(S=s_{1}) = 0.70 + 0.30 = 1.0$)。所提供的数据是自洽的、一致的且科学上可信的。该问题提法得当，要求使用概率演算和有向无环图 (DAG) 进行标准的因果推理分析。核心陈述中没有逻辑矛盾、事实错误或含糊之处。因此，该问题是有效的。\n\n**步骤3：求解推导**\n任务是计算边际风险，验证悖论，并确定正确的因果解释和调整策略。基本原理是全概率定律和贝叶斯定理。\n\n首先，我们确定变量 $S$、$G$ 和 $D$ 之间的因果关系来构建一个 DAG。\n1.  祖先亚群体 ($S$) 是一个在个体基因型 ($G$) 之前的群体属性。问题陈述指出亚群体之间的等位基因频率不同 ($P(G=1 \\mid S=s_0) \\neq P(G=1 \\mid S=s_1)$)，这意味着存在一个因果有向边 $S \\rightarrow G$。\n2.  亚群体 ($S$) 也可以通过除特定等位基因 $G$ 之外的各种遗传、环境或社会经济因素影响疾病风险 ($D$)。给定数据显示，亚群体之间的基线疾病风险差异显著 (例如，$P(D=1 \\mid G=0, S=s_0) = 0.01$ 而 $P(D=1 \\mid G=0, S=s_1) = 0.20$)。这意味着存在一个因果有向边 $S \\rightarrow D$。\n3.  问题假设等位基因 ($G$) 影响疾病风险 ($D$)。层内风险证实了这一点：在两个亚群体中，该等位基因的存在都增加了疾病的风险 ($P(D=1 \\mid G=1, S=s) > P(D=1 \\mid G=0, S=s)$ for $s \\in \\{s_0, s_1\\}$)。这证明了存在一个因果有向边 $G \\rightarrow D$。\n综合这些，因果结构可以用一个包含边 $S \\rightarrow G$ 和 $S \\rightarrow D$ 以及 $G \\rightarrow D$ 的DAG来表示。在这个结构中，$S$ 是 $G$ 和 $D$ 的共同原因，使其成为 $G$ 和 $D$ 之间关系的混淆因子。路径 $G \\leftarrow S \\rightarrow D$ 是一条非因果的“后门”路径，它可以在 $G$ 和 $D$ 之间引起虚假关联。\n\n接下来，我们计算边际 (总体) 风险，$P(D=1 \\mid G=1)$ 和 $P(D=1 \\mid G=0)$。对于一个特定的基因型 $g \\in \\{0, 1\\}$，其边际风险 $P(D=1 \\mid G=g)$ 可以通过应用全概率定律，对亚群体 $S$ 进行边际化得到：\n$$P(D=1 \\mid G=g) = \\sum_{s \\in \\{s_0, s_1\\}} P(D=1 \\mid G=g, S=s) P(S=s \\mid G=g)$$\n为了使用这个公式，我们必须首先使用贝叶斯定理计算 $P(S=s \\mid G=g)$：\n$$P(S=s \\mid G=g) = \\frac{P(G=g \\mid S=s) P(S=s)}{P(G=g)}$$\n这需要基因型的边际概率 $P(G=g)$，它同样通过全概率定律求得：\n$$P(G=g) = P(G=g \\mid S=s_0)P(S=s_0) + P(G=g \\mid S=s_1)P(S=s_1)$$\n我们还需要等位基因不存在的概率，即 $P(G=0 \\mid S=s_0) = 1 - 0.90 = 0.10$ 和 $P(G=0 \\mid S=s_1) = 1 - 0.10 = 0.90$。\n\n计算：\n1.  基因型的边际概率：\n    $P(G=1) = (0.90)(0.70) + (0.10)(0.30) = 0.63 + 0.03 = 0.66$\n    $P(G=0) = (0.10)(0.70) + (0.90)(0.30) = 0.07 + 0.27 = 0.34$\n    (检验：$0.66 + 0.34 = 1.0$)\n\n2.  给定基因型的亚群体条件概率：\n    $P(S=s_0 \\mid G=1) = \\frac{P(G=1 \\mid S=s_0)P(S=s_0)}{P(G=1)} = \\frac{(0.90)(0.70)}{0.66} = \\frac{0.63}{0.66} = \\frac{21}{22}$\n    $P(S=s_1 \\mid G=1) = \\frac{P(G=1 \\mid S=s_1)P(S=s_1)}{P(G=1)} = \\frac{(0.10)(0.30)}{0.66} = \\frac{0.03}{0.66} = \\frac{1}{22}$\n    $P(S=s_0 \\mid G=0) = \\frac{P(G=0 \\mid S=s_0)P(S=s_0)}{P(G=0)} = \\frac{(0.10)(0.70)}{0.34} = \\frac{0.07}{0.34} = \\frac{7}{34}$\n    $P(S=s_1 \\mid G=0) = \\frac{P(G=0 \\mid S=s_1)P(S=s_1)}{P(G=0)} = \\frac{(0.90)(0.30)}{0.34} = \\frac{0.27}{0.34} = \\frac{27}{34}$\n\n3.  边际风险：\n    $P(D=1 \\mid G=1) = P(D=1 \\mid G=1, S=s_0)P(S=s_0 \\mid G=1) + P(D=1 \\mid G=1, S=s_1)P(S=s_1 \\mid G=1)$\n    $$P(D=1 \\mid G=1) = (0.02)\\left(\\frac{21}{22}\\right) + (0.30)\\left(\\frac{1}{22}\\right) = \\frac{0.42 + 0.30}{22} = \\frac{0.72}{22} \\approx 0.0327$$\n    $P(D=1 \\mid G=0) = P(D=1 \\mid G=0, S=s_0)P(S=s_0 \\mid G=0) + P(D=1 \\mid G=0, S=s_1)P(S=s_1 \\mid G=0)$\n    $$P(D=1 \\mid G=0) = (0.01)\\left(\\frac{7}{34}\\right) + (0.20)\\left(\\frac{27}{34}\\right) = \\frac{0.07 + 5.40}{34} = \\frac{5.47}{34} \\approx 0.1609$$\n\n比较这些风险，我们发现 $P(D=1 \\mid G=1) \\approx 0.0327 < P(D=1 \\mid G=0) \\approx 0.1609$。这展示了一个逆转现象：在混合群体中，该等位基因表现出保护性。然而，我们已知对于每个分层 $s$，都有 $P(D=1 \\mid G=1, S=s) > P(D=1 \\mid G=0, S=s)$。这就是 Simpson 悖论。混淆变量 $S$ 与暴露 ($G$) 和结果 ($D$) 都有关联，并产生了一个虚假的边际关联。要估计 $G$ 对 $D$ 的真实因果效应，必须对混淆因子 $S$ 进行调整。这通过检查分层特定风险来完成，这些风险一致地表明该等位基因是有害的。悖论的产生是因为携带风险等位基因 ($G=1$) 的个体主要来自低风险群体 ($s_0$)，而没有该等位基因 ($G=0$) 的个体主要来自高风险群体 ($s_1$)。\n\n**步骤4：评估选项**\n\nA. 该选项提出了包含 $S \\rightarrow G$、$S \\rightarrow D$ 和 $G \\rightarrow D$ 的 DAG。这正确地将 $S$ 建模为混淆因子。它指出边际关联 $P(D=1 \\mid G)$ 将会逆转，我们的计算结果 $P(D=1 \\mid G=1) < P(D=1 \\mid G=0)$ 证实了这一点。它正确地指出真实效应是增加风险的，并且通过对 $S$ 进行调整得以恢复。其推理是合理的，并与我们的推导完全一致。\n**结论：正确。**\n\nB. 该选项提出了一个 $S$ 为对撞节点 ($G \\rightarrow S \\leftarrow D$) 的 DAG。这种因果结构是无稽之谈，因为基因型和疾病不会导致祖先。它错误地声称悖论*源于*对 $S$ 的条件化，这与混淆的真相恰恰相反。它还错误地预测边际关联将是正向的。\n**结论：错误。**\n\nC. 该选项正确地识别了混淆结构 ($G \\leftarrow S \\rightarrow D$)，但提议对结果 $D$ 进行调整。在因果推断中，为了找到原因的效应而对结果进行调整是一个根本性错误，这会引入偏倚，而不是消除它。悖论是关于边际关联的观察，而不是在对结果进行条件化之后才出现的东西。\n**结论：错误。**\n\nD. 该选项声称没有混淆，正确的 DAG 仅仅是 $G \\rightarrow D$。这与给定的概率直接矛盾，这些概率显示了 $S$ 和 $G$ 之间以及 $S$ 和 $D$ 之间的强关联。它错误地将悖论归结为“抽样变异性”，而实际上它是给定群体概率的确定性结果。\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2374723"}, {"introduction": "贝叶斯推断的真正威力在于其动态性——它是一个随着新数据的到来而不断学习和更新信念的过程。没有什么比贝叶斯自适应临床试验更能体现这一点了。在这个实践中，你将从静态计算转向动态模拟，通过编写程序来模拟一个临床试验的序贯分析过程。你的任务是根据累积的数据，在每个中期阶段更新效应大小的后验分布，并应用一个预设的停止规则来决定试验是否应提前结束。这项练习将理论知识转化为实际的计算技能，让你体验贝叶斯方法在现代药物研发中的强大应用 [@problem_id:2374692]。", "problem": "您正在分析一项关于连续分子反应的双臂随机临床研究，其中实验组（药物A）与安慰剂组进行比较。设效应大小为组间均值之差，定义为 $\\delta = \\mu_{A} - \\mu_{P}$。假设存在以下生成模型：以 $\\delta$ 为条件，在期中分析时观察到的累积样本均值之差，记作 $\\bar{d} = \\bar{y}_{A} - \\bar{y}_{P}$，服从均值为 $\\delta$、方差为 $\\sigma^{2}\\left(\\frac{1}{n_{A}} + \\frac{1}{n_{P}}\\right)$ 的正态分布，其中 $n_{A}$ 和 $n_{P}$ 是累积样本量，而 $\\sigma^{2} > 0$ 为已知且两组共有的方差。$\\delta$ 的先验分布为均值为 $\\mu_{0}$、方差为 $\\tau_{0}^{2}$ 的正态分布，且 $\\tau_{0}^{2} > 0$。在每次期中分析时，您需要使用 Bayes 定理，根据截至该次分析累积的所有数据来更新 $\\delta$ 的后验分布。\n\n指定一个单侧有效性中止规则如下：在第一次期中分析 $k$ 时，若 $\\delta$ 超过具有临床意义的阈值 $\\delta_{\\star}$ 的后验概率满足 $\\mathbb{P}\\!\\left(\\delta > \\delta_{\\star} \\mid \\text{data up to look } k\\right) > p_{\\star}$，则因有效性而中止研究，否则继续。如果没有期中分析满足该规则，则不发生提前中止。\n\n您的任务是实现一个程序，对于下方的每个测试用例，按顺序评估期中分析，并输出首次满足规则的分析的索引 $k$（第一次分析使用 $1$），如果规则从未被满足，则输出 $0$。所有概率在内部必须以 $\\left[0,1\\right]$ 范围内的小数形式报告；请勿使用百分比表示法。\n\n使用以下测试套件，其中每个测试用例由元组 $(\\mu_{0}, \\tau_{0}^{2}, \\sigma^{2}, \\delta_{\\star}, p_{\\star}, \\text{looks})$ 指定。每次分析由元组 $(n_{A}, \\bar{y}_{A}, n_{P}, \\bar{y}_{P})$ 给出。\n\n- 测试用例 1（一个典型的在后期分析中越过规则界值的案例）：\n  - $(\\mu_{0}, \\tau_{0}^{2}, \\sigma^{2}, \\delta_{\\star}, p_{\\star}) = (0, 1, 1, 0.1, 0.95)$\n  - looks =\n    - 分析 1：$(20, 0.05, 20, 0.00)$\n    - 分析 2：$(40, 0.50, 40, 0.00)$\n\n- 测试用例 2（即使样本量较大也未越界）：\n  - $(\\mu_{0}, \\tau_{0}^{2}, \\sigma^{2}, \\delta_{\\star}, p_{\\star}) = (0, 1, 1, 0.1, 0.95)$\n  - looks =\n    - 分析 1：$(30, 0.00, 30, 0.00)$\n    - 分析 2：$(60, 0.05, 60, 0.02)$\n    - 分析 3：$(100, 0.07, 100, 0.05)$\n\n- 测试用例 3（接近阈值的案例，因未严格超过 $p_{\\star}$ 而不应中止）：\n  - $(\\mu_{0}, \\tau_{0}^{2}, \\sigma^{2}, \\delta_{\\star}, p_{\\star}) = (0, 1, 1, 0.1, 0.95)$\n  - looks =\n    - 分析 1：$(50, 0.4385, 50, 0.0000)$\n\n- 测试用例 4（触发提前中止的信息性先验）：\n  - $(\\mu_{0}, \\tau_{0}^{2}, \\sigma^{2}, \\delta_{\\star}, p_{\\star}) = (0.3, 0.01, 1, 0.1, 0.95)$\n  - looks =\n    - 分析 1：$(10, 0.05, 10, 0.00)$\n\n- 测试用例 5（弱先验，在多次分析中累积证据）：\n  - $(\\mu_{0}, \\tau_{0}^{2}, \\sigma^{2}, \\delta_{\\star}, p_{\\star}) = (0.0, 1000000.0, 1, 0.1, 0.95)$\n  - looks =\n    - 分析 1：$(8, 0.12, 8, 0.00)$\n    - 分析 2：$(50, 0.11, 50, 0.00)$\n    - 分析 3：$(100, 0.20, 100, 0.00)$\n    - 分析 4：$(200, 0.27, 200, 0.00)$\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的整数列表（例如，$[r_{1},r_{2},r_{3},r_{4},r_{5}]$），其中 $r_{i}$ 是测试用例 $i$ 首次满足规则的分析索引，如果从未满足则为 $0$。此问题中不涉及物理单位或角度；所有输入和输出均为无单位量。要求的输出类型仅为整数。", "solution": "该问题要求在贝叶斯自适应临床试验中确定一个提前中止点。对问题陈述的验证证实了其具有科学依据、问题定义清晰且客观。它代表了使用共轭正态-正态模型的贝叶斯推断的标准应用，这是生物统计学中的一个常见范式。该问题是有效的，并将提供一个解决方案。\n\n解决方案的核心在于在每次期中分析时，顺序更新效应大小 $\\delta$ 的后验分布，并检查是否满足预定义的中止标准。模型定义如下：\n\n1.  **先验分布**：关于效应大小 $\\delta$ 的先验信念由一个正态分布建模，$\\delta \\sim \\mathcal{N}(\\mu_{0}, \\tau_{0}^{2})$，其中 $\\mu_{0}$ 是先验均值，$\\tau_{0}^{2}$ 是先验方差。\n\n2.  **似然函数**：截至期中分析 $k$ 收集的数据由累积样本量 $n_{A,k}$ 和 $n_{P,k}$ 以及累积样本均值 $\\bar{y}_{A,k}$ 和 $\\bar{y}_{P,k}$ 汇总。观察到的均值差异 $\\bar{d}_k = \\bar{y}_{A,k} - \\bar{y}_{P,k}$ 作为似然函数的汇总统计量。问题陈述指出，在给定真实效应大小 $\\delta$ 的条件下，该统计量的分布是正态的：$\\bar{d}_k \\mid \\delta \\sim \\mathcal{N}(\\delta, \\sigma_{k}^{2})$，其中抽样方差为 $\\sigma_{k}^{2} = \\sigma^{2}\\left(\\frac{1}{n_{A,k}} + \\frac{1}{n_{P,k}}\\right)$。\n\n正态先验和正态似然（方差已知）的组合构成了一个共轭模型。此性质确保了 $\\delta$ 的后验分布也是一个正态分布。在每次分析 $k$ 时，此后验分布的参数（记为 $\\mathcal{N}(\\mu_{k}, \\tau_{k}^{2})$）会根据该次分析可用的累积数据进行更新。后验参数使用以下标准贝叶斯更新规则计算。\n\n后验精度（方差的倒数）是先验精度和数据精度的总和：\n$$\n\\frac{1}{\\tau_{k}^{2}} = \\frac{1}{\\tau_{0}^{2}} + \\frac{1}{\\sigma_{k}^{2}}\n$$\n由此，后验方差 $\\tau_{k}^{2}$ 为：\n$$\n\\tau_{k}^{2} = \\left(\\frac{1}{\\tau_{0}^{2}} + \\frac{1}{\\sigma_{k}^{2}}\\right)^{-1}\n$$\n后验均值 $\\mu_{k}$ 是先验均值 $\\mu_{0}$ 和观测数据 $\\bar{d}_k$ 的精度加权平均值：\n$$\n\\mu_k = \\tau_k^2 \\left( \\frac{\\mu_0}{\\tau_0^2} + \\frac{\\bar{d}_k}{\\sigma_k^2} \\right)\n$$\n因此，对于每次分析 $k$，效应大小的后验分布为 $\\delta \\mid \\text{data}_k \\sim \\mathcal{N}(\\mu_k, \\tau_k^2)$。\n\n中止规则在效应大小 $\\delta$ 超过临床意义阈值 $\\delta_{\\star}$ 的后验概率大于指定概率阈值 $p_{\\star}$ 的第一次分析 $k$ 时触发。在数学上，该条件为 $\\mathbb{P}(\\delta > \\delta_{\\star} \\mid \\text{data}_k) > p_{\\star}$。\n\n为了评估此概率，我们将正态后验分布标准化。设 $Z$ 为标准正态随机变量，$Z \\sim \\mathcal{N}(0,1)$。该概率可计算为：\n$$\n\\mathbb{P}(\\delta > \\delta_{\\star}) = \\mathbb{P}\\left(\\frac{\\delta - \\mu_k}{\\sqrt{\\tau_k^2}} > \\frac{\\delta_{\\star} - \\mu_k}{\\sqrt{\\tau_k^2}}\\right) = \\mathbb{P}\\left(Z > \\frac{\\delta_{\\star} - \\mu_k}{\\sqrt{\\tau_k^2}}\\right)\n$$\n该概率使用标准正态分布的生存函数（或互补累积分布函数）计算，通常记为 $1 - \\Phi(z)$，其中 $\\Phi(z)$ 是标准正态累积分布函数（CDF）。\n\n每个测试用例的算法如下：\n从 $k=1$ 开始，遍历指定的期中分析。对于每次分析，执行以下步骤：\n1.  计算观察到的均值差 $\\bar{d}_k = \\bar{y}_{A,k} - \\bar{y}_{P,k}$ 和抽样方差 $\\sigma_k^2 = \\sigma^2 \\left( \\frac{1}{n_{A,k}} + \\frac{1}{n_{P,k}} \\right)$。\n2.  计算后验均值 $\\mu_k$ 和后验方差 $\\tau_k^2$。\n3.  计算后验概率 $\\mathbb{P}(\\delta > \\delta_{\\star} \\mid \\text{data}_k) = 1 - \\Phi\\left((\\delta_{\\star} - \\mu_k) / \\sqrt{\\tau_k^2}\\right)$。\n4.  将此概率与阈值 $p_{\\star}$ 进行比较。如果 $\\mathbb{P}(\\delta > \\delta_{\\star} \\mid \\text{data}_k) > p_{\\star}$，研究中止。结果为当前分析的索引 $k$。该测试用例的流程终止。\n5.  如果条件未满足，则继续下一次分析。\n如果循环完成而条件从未被满足，则意味着没有发生提前中止，结果为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef find_stopping_look(mu0, tau0_sq, sigma_sq, delta_star, p_star, looks):\n    \"\"\"\n    Evaluates interim looks sequentially to find the first look that satisfies the stopping rule.\n\n    Args:\n        mu0 (float): Prior mean for delta.\n        tau0_sq (float): Prior variance for delta.\n        sigma_sq (float): Known common variance for the response in each arm.\n        delta_star (float): Clinically meaningful threshold for the effect size.\n        p_star (float): Probability threshold for the stopping rule.\n        looks (list): A list of tuples, where each tuple represents an interim look\n                      with format (nA, yA_bar, nP, yP_bar).\n\n    Returns:\n        int: The 1-based index of the first stopping look, or 0 if the rule is never satisfied.\n    \"\"\"\n    if tau0_sq <= 0:\n        raise ValueError(\"Prior variance must be positive.\")\n    \n    prior_precision = 1.0 / tau0_sq\n\n    for k, look_data in enumerate(looks, 1):\n        nA, yA_bar, nP, yP_bar = look_data\n\n        if nA <= 0 or nP <= 0:\n            # Sample sizes must be positive to calculate variance.\n            # As per problem constraints, this should not happen.\n            continue\n\n        d_bar = yA_bar - yP_bar\n        \n        # Calculate sampling variance for the difference in means\n        data_var = sigma_sq * (1.0 / nA + 1.0 / nP)\n        if data_var <= 0:\n            # This case also should not happen given sigma_sq > 0\n            continue\n        data_precision = 1.0 / data_var\n        \n        # Calculate posterior parameters\n        post_precision = prior_precision + data_precision\n        post_var = 1.0 / post_precision\n        post_mean = post_var * (mu0 * prior_precision + d_bar * data_precision)\n        post_std = np.sqrt(post_var)\n        \n        # Calculate the posterior probability P(delta > delta_star | data)\n        # This is P(Z > (delta_star - post_mean) / post_std) for Z ~ N(0,1)\n        # We use the survival function (sf), which is 1 - cdf.\n        prob = norm.sf((delta_star - post_mean) / post_std)\n        \n        # Check the stopping criterion\n        if prob > p_star:\n            return k\n            \n    # If the loop completes, the stopping rule was never met.\n    return 0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (mu0, tau0_sq, sigma_sq, delta_star, p_star, looks)\n        (0.0, 1.0, 1.0, 0.1, 0.95, \n         [(20, 0.05, 20, 0.00), (40, 0.50, 40, 0.00)]),\n        # Case 2\n        (0.0, 1.0, 1.0, 0.1, 0.95, \n         [(30, 0.00, 30, 0.00), (60, 0.05, 60, 0.02), (100, 0.07, 100, 0.05)]),\n        # Case 3\n        (0.0, 1.0, 1.0, 0.1, 0.95, \n         [(50, 0.4385, 50, 0.0000)]),\n        # Case 4\n        (0.3, 0.01, 1.0, 0.1, 0.95, \n         [(10, 0.05, 10, 0.00)]),\n        # Case 5\n        (0.0, 1000000.0, 1.0, 0.1, 0.95, \n         [(8, 0.12, 8, 0.00), (50, 0.11, 50, 0.00), (100, 0.20, 100, 0.00), (200, 0.27, 200, 0.00)])\n    ]\n\n    results = []\n    for case in test_cases:\n        mu0, tau0_sq, sigma_sq, delta_star, p_star, looks = case\n        result = find_stopping_look(mu0, tau0_sq, sigma_sq, delta_star, p_star, looks)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2374692"}]}