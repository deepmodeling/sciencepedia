{"hands_on_practices": [{"introduction": "在高通量生物学研究中，我们经常同时进行数千次假设检验。这个练习将通过一个基础的概率计算，揭示一个看似很小的单次检验错误率（例如 $\\alpha=0.05$）在多次检验下如何迅速累积，导致我们有极高的概率至少得到一个假阳性结果。理解这个被称为“多重检验问题”的概念，是解读基因组学和蛋白质组学数据时避免错误结论的第一步 [@problem_id:2430505]。", "problem": "在一个转录因子结合位点预测器的计算生物学验证研究中，一位研究人员使用染色质免疫沉淀后测序 (ChIP-seq) 的阴性对照区域来评估在没有真实信号的情况下统计检验流程的表现。假设该研究人员对 $m = 20$ 个独立的阴性对照区域进行假设检验，每次检验的显著性水平为 $\\alpha = 0.05$。假设所有 $m$ 个原假设均为真，且各检验相互独立。这些检验中至少有一个纯粹因为偶然性而被判定为显著的概率是多少？请用小数表示你的答案，并四舍五入到 $4$ 位有效数字。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 独立假设检验的数量：$m = 20$。\n- 检验在阴性对照区域上进行，意味着所有原假设都假定为真。\n- 单次检验的显著性水平（单次检验的I类错误率）：$\\alpha = 0.05$。\n- 各检验相互独立。\n- 需要计算的量是至少有一次检验被判定为显著的概率。\n- 最终答案必须是四舍五入到 $4$ 位有效数字的小数。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。它涉及族系误差率（FWER）的概念，这是多重假设检验中的一个基本主题，也是生物信息学和计算生物学中的一个关键领域。所描述的场景——使用阴性对照评估统计特性——是一种标准且有效的方法。该问题陈述清晰，提供了所有必要的参数（$m$，$\\alpha$）和假设（独立性、原假设为真），足以得出一个唯一且有意义的解。问题没有内部矛盾、歧义，也不依赖于非科学的前提。该问题是概率论在现实科学情境中的直接应用。\n\n**步骤3：结论与行动**\n该问题被判定为有效。将构建一个解法。\n\n**解法构建**\n问题要求计算在进行 $m$ 次独立假设检验时，若所有原假设都为真，观察到至少一个统计显著结果的概率。这是多重比较中的一个经典问题。\n\n设 $H_{0,i}$ 为第 $i$ 次检验的原假设，其中 $i$ 的范围从 $1$ 到 $m$。已知所有 $H_{0,i}$ 均为真。\n显著性水平 $\\alpha$ 是单次检验中犯I类错误的概率。当一个为真的原假设被错误地拒绝时，就发生了I类错误。因此，对于任何单次检验 $i$，其结果被判定为显著（即拒绝 $H_{0,i}$）的概率为：\n$$P(\\text{test } i \\text{ is significant}) = \\alpha$$\n\n已知 $\\alpha = 0.05$。\n\n其互补事件是单次检验*不*被判定为显著。该事件的概率为：\n$$P(\\text{test } i \\text{ is not significant}) = 1 - \\alpha$$\n\n问题陈述所有 $m = 20$ 次检验都是相互独立的。我们想求*至少有一次*检验是显著的概率。设 $A$ 为 $m$ 次检验中至少有一次显著的事件。计算上更简单的方法是先计算其互补事件 $A^c$ 的概率，即*所有*检验都不显著的事件。\n\n由于各检验是独立的，所有 $m$ 次检验都不显著的概率是它们各自概率的乘积：\n$$P(A^c) = P(\\text{test 1 is not significant} \\cap \\text{test 2 is not significant} \\cap \\dots \\cap \\text{test } m \\text{ is not significant})$$\n$$P(A^c) = \\prod_{i=1}^{m} P(\\text{test } i \\text{ is not significant})$$\n$$P(A^c) = (1 - \\alpha)^m$$\n\n那么，事件 $A$（至少有一次检验显著）的概率可以根据互补法则得出：\n$$P(A) = 1 - P(A^c)$$\n$$P(A) = 1 - (1 - \\alpha)^m$$\n\n这个量在完全原假设下被称为族系误差率（FWER）。\n\n现在，我们将给定的值代入这个公式：\n- 检验次数, $m = 20$。\n- 显著性水平, $\\alpha = 0.05$。\n\n$$P(A) = 1 - (1 - 0.05)^{20}$$\n$$P(A) = 1 - (0.95)^{20}$$\n\n为了得到数值结果，我们计算 $(0.95)^{20}$：\n$$ (0.95)^{20} \\approx 0.358485922 $$\n\n现在，我们求最终的概率：\n$$ P(A) \\approx 1 - 0.358485922 $$\n$$ P(A) \\approx 0.641514078 $$\n\n问题要求答案四舍五入到 $4$ 位有效数字。前四位有效数字是 $6$、$4$、$1$ 和 $5$。第五位数字是 $1$，小于 $5$，所以我们向下舍入。\n最终结果是 $0.6415$。\n这个结果展示了一个关键概念：即使单次检验的错误率很小（$5\\%$），随着检验次数的增加，出现至少一个假发现的概率也会迅速膨胀。对于 $20$ 次检验，出现至少一个假阳性结果的概率超过 $64\\%$。", "answer": "$$\\boxed{0.6415}$$", "id": "2430505"}, {"introduction": "在科学研究中，我们有时会遇到多个独立研究都显示出某种趋势，但单个研究的 $p$ 值都未能达到显著性阈值（例如 $p > 0.05$）的情况。我们应该就此放弃吗？这个练习介绍了一种荟萃分析（meta-analysis）的基本方法，教你如何从第一性原理出发，严格地合并来自独立研究的证据，并计算出一个组合 $p$ 值。通过这个实践，你将看到两个不显著的结果如何能够汇集成一个强有力的统计结论 [@problem_id:2430501]。", "problem": "一个生物标志物在两个独立的 RNA 测序 (RNA-seq) 队列中被评估其在两个表型组之间的差异表达。每个队列都针对相同的零假设“真实平均表达差异为零”进行了一项有效检验，并产生了独立的 p 值 $p_1$ 和 $p_2$。观测值为 $p_1 = 0.1$ 和 $p_2 = 0.1$。该研究预先注册的荟萃分析计划指定了一个合并规则，当 p 值的乘积足够小时拒绝原假设：定义检验统计量 $T = p_1 p_2$，并将合并 p 值定义为 $\\Pr\\!\\left(U_1 U_2 \\leq T \\mid H_0\\right)$，其中在零假设 $H_0$ 下，p 值 $U_1$ 和 $U_2$ 独立同分布于 $\\mathrm{Uniform}(0,1)$。\n\n计算观测数据的精确合并 p 值。答案应四舍五入至四位有效数字。回答中不应包含任何单位。", "solution": "在零假设 $H_0$ 下，p 值 $U_1$ 和 $U_2$ 独立同分布于 $\\mathrm{Uniform}(0,1)$。由乘积法则定义的合并 p 值是尾部概率\n$$\n\\Pr\\!\\left(U_1 U_2 \\leq t\\right),\n$$\n该概率在观测值 $t = p_1 p_2$ 处计算。为从第一性原理出发得到此结果，我们使用 $(U_1,U_2)$ 的联合密度（其在单位正方形上为 $1$）来计算 $t \\in (0,1)$ 时 $T = U_1 U_2$ 的累积分布函数：\n$$\nF_T(t) \\equiv \\Pr\\!\\left(U_1 U_2 \\leq t\\right) = \\iint_{\\{(u_1,u_2)\\in(0,1)^2: u_1 u_2 \\leq t\\}} 1 \\,\\mathrm{d}u_2\\,\\mathrm{d}u_1.\n$$\n对于一个固定的 $u_1 \\in (0,1)$，条件 $u_1 u_2 \\leq t$ 等价于 $u_2 \\leq t/u_1$。当 $u_1 \\in (0,t)$ 时，$t/u_1 \\geq 1$，因此关于 $u_2$ 的内层积分区间为 $(0,1)$；当 $u_1 \\in [t,1)$ 时，内层积分区间为 $(0, t/u_1)$。因此，\n$$\nF_T(t) = \\int_{0}^{t} \\left(\\int_{0}^{1} 1 \\,\\mathrm{d}u_2\\right) \\mathrm{d}u_1 + \\int_{t}^{1} \\left(\\int_{0}^{t/u_1} 1 \\,\\mathrm{d}u_2\\right) \\mathrm{d}u_1\n= \\int_{0}^{t} 1 \\,\\mathrm{d}u_1 + \\int_{t}^{1} \\frac{t}{u_1} \\,\\mathrm{d}u_1.\n$$\n计算这些积分可得\n$$\nF_T(t) = t + t \\int_{t}^{1} \\frac{1}{u_1} \\,\\mathrm{d}u_1 = t + t\\left[\\ln(1) - \\ln(t)\\right] = t - t \\ln(t),\n$$\n其中 $t \\in (0,1)$。对于观测数据，$p_1 = 0.1$ 且 $p_2 = 0.1$，因此 $t = p_1 p_2 = 0.01$。所以，合并 p 值为\n$$\nF_T(0.01) = 0.01 - 0.01 \\ln(0.01) = 0.01 \\left(1 - \\ln(0.01)\\right).\n$$\n使用自然对数，$\\ln(0.01) = -\\ln(100) = -2 \\ln(10) \\approx -4.605170186$，因此\n$$\nF_T(0.01) \\approx 0.01 \\left(1 + 4.605170186\\right) = 0.01 \\times 5.605170186 = 0.05605170186.\n$$\n四舍五入到四位有效数字，得到 $0.05605$。\n\n这个精确的合并 p 值大于 $0.05$，所以在常用的显著性水平 $\\alpha = 0.05$ 下不具有统计显著性，但题目要求输出的是 p 值本身。", "answer": "$$\\boxed{0.05605}$$", "id": "2430501"}, {"introduction": "当你构建了一个机器学习模型来预测生物学结果（例如患者生存率）并获得一个性能指标（如 AUC）时，你如何确定这个性能不是偶然产生的？置换检验（permutation testing）是一种功能强大且直观的非参数方法，可以为任何统计量生成一个经验性的零分布，从而评估其显著性。这个动手实践将指导你编写代码，从零开始为一个模型的 AUC 计算精确的 $p$ 值，让你真正掌握在计算生物学中验证模型性能的核心技能 [@problem_id:2430559]。", "problem": "给定一个来自计算生物学和生物信息学的二元分类场景，在该场景中，一个模型为每位患者针对一个生存终点分配一个实值风险评分。设有 $n$ 位患者，索引为 $i \\in \\{1,\\dots,n\\}$，其模型评分为 $s_i \\in \\mathbb{R}$，二元标签为 $y_i \\in \\{0,1\\}$，其中 $y_i = 1$ 表示感兴趣事件（例如，非存活），而 $y_i = 0$ 表示事件未发生（例如，存活）。受试者工作特征曲线下面积 (Area Under the Receiver Operating Characteristic Curve, AUC) 从第一性原理定义如下\n$$\n\\mathrm{AUC}(s,y) \\;=\\; \\frac{1}{n_1 n_0} \\sum_{i: y_i=1} \\sum_{j: y_j=0} \\left( \\mathbf{1}\\{s_i > s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\} \\right),\n$$\n其中 $n_1 = \\sum_{i=1}^n \\mathbf{1}\\{y_i=1\\}$ 且 $n_0 = \\sum_{i=1}^n \\mathbf{1}\\{y_i=0\\}$，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。如果 $n_1 = 0$ 或 $n_0 = 0$，则按照惯例定义 $\\mathrm{AUC}(s,y) = 0.5$。\n\n为评估观测到的 $\\mathrm{AUC}(s,y)$ 的统计显著性，考虑一个在原假设下的标签置换检验，该原假设为：给定评分，标签是可交换的。形式上，设 $\\mathcal{Y}$ 是所有标签组合 $y' \\in \\{0,1\\}^n$ 的集合，其中恰好有 $n_1$ 个 1 和 $n_0$ 个 0，并设置换零分布在 $\\mathcal{Y}$ 上是均匀的。用于检验 $\\mathrm{AUC}(s,y)$ 是否超出偶然预期的单侧右尾 p 值为\n$$\np \\;=\\; \\frac{1}{|\\mathcal{Y}|} \\sum_{y' \\in \\mathcal{Y}} \\mathbf{1}\\big\\{\\mathrm{AUC}(s,y') \\;\\ge\\; \\mathrm{AUC}(s,y)\\big\\}.\n$$\n在 $n_1 = 0$ 或 $n_0 = 0$ 的退化边界情况下，将 p 值定义为 $1.0$。\n\n你的任务是编写一个完整的程序，为下述每个测试用例计算上文定义的精确置换 p 值。程序必须按照所述定义实现，不得进行任何近似。对于跨类别的评分平局（相同值），使用 AUC 定义中给出的 $\\tfrac{1}{2}$ 惯例。\n\n测试套件（每个用例按给定顺序将 $(s,y)$ 指定为数组）：\n- 用例 1（构造的平衡中等性能，AUC 等于 0.6）：\n  - $s = [$ $0.6$, $0.2$, $0.5$, $0.1$, $0.45$, $0.5$, $0.5$ $]$\n  - $y = [$ $1$, $0$, $0$, $1$, $1$, $1$, $1$ $]$\n- 用例 2（近乎完美的分离）：\n  - $s = [$ $0.9$, $0.8$, $0.7$, $0.2$, $0.1$ $]$\n  - $y = [$ $1$, $1$, $1$, $0$, $0$ $]$\n- 用例 3（所有标签相同的退化边界情况）：\n  - $s = [$ $0.3$, $0.1$, $0.9$, $0.7$ $]$\n  - $y = [$ $1$, $1$, $1$, $1$ $]$\n- 用例 4（交错的平局导致 AUC 等于 0.5）：\n  - $s = [$ $0.1$, $0.1$, $0.2$, $0.2$, $0.3$, $0.3$ $]$\n  - $y = [$ $1$, $0$, $1$, $0$, $1$, $0$ $]$\n\n最终输出规范：\n- 对于每个用例，以十进制形式输出 p 值，并精确到小数点后 $6$ 位。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述用例相同，例如：[ $p_1$, $p_2$, $p_3$, $p_4$ ]。", "solution": "问题陈述已经过验证，并被确定为有效。其在科学上是合理的，问题提法得当，没有歧义，并且内部一致。该问题植根于既定的统计实践，即使用置换检验来评估模型性能指标（本例中为受试者工作特征曲线下面积 (AUC)）的显著性。所有术语都经过了精确的数学定义，所提供的测试用例在计算上是可行的。因此，我们可以着手推导解决方案。\n\n任务是为一个观测到的 AUC 计算精确的单侧置换 p 值。这需要直接实现所提供的定义，不进行任何近似。该算法包括两个主要步骤：为给定的一组评分和标签计算 AUC，以及枚举置换空间以确定 p 值。\n\n首先，我们定义计算 $\\mathrm{AUC}(s,y)$ 的过程。给定一个评分向量 $s \\in \\mathbb{R}^n$ 和一个二元标签向量 $y \\in \\{0,1\\}^n$，我们计算正标签的数量 $n_1 = \\sum_{i=1}^n \\mathbf{1}\\{y_i=1\\}$ 和负标签的数量 $n_0 = \\sum_{i=1}^n \\mathbf{1}\\{y_i=0\\}$。根据问题陈述，如果 $n_1=0$ 或 $n_0=0$，则按惯例将 AUC 定义为 $0.5$。否则，AUC 使用以下公式计算：\n$$\n\\mathrm{AUC}(s,y) \\;=\\; \\frac{1}{n_1 n_0} \\sum_{i: y_i=1} \\sum_{j: y_j=0} \\left( \\mathbf{1}\\{s_i > s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\} \\right)\n$$\n该计算涉及遍历所有正标签和负标签样本对，比较它们的评分，并根据指示函数 $\\mathbf{1}\\{\\cdot\\}$ 对结果求和，该函数以 $\\tfrac{1}{2}$ 的值处理平局情况。最终的总和通过总对数 $n_1 n_0$ 进行归一化。\n\n其次，我们讨论 p 值的计算。对于给定的测试用例 $(s,y)$，我们首先计算观测到的 AUC，记为 $\\mathrm{AUC}_{\\text{obs}} = \\mathrm{AUC}(s,y)$。置换检验的原假设假定标签相对于评分是可交换的。在此原假设下，所有可能的标签分配集合 $\\mathcal{Y}$ 包含所有长度为 $n$ 的二元向量，这些向量的正负标签计数与原始向量 $y$ 相同，即分别为 $n_1$ 和 $n_0$。该置换空间的大小由二项式系数 $|\\mathcal{Y}| = \\binom{n}{n_1}$ 给出。\n\n为了计算精确的 p 值，我们必须枚举 $\\mathcal{Y}$ 中的每一个唯一置换 $y'$。对每个 $y'$，我们计算其对应的 $\\mathrm{AUC}(s, y')$。单侧右尾 p 值是这些置换中 AUC 大于或等于观测 AUC 的置换所占的比例：\n$$\np \\;=\\; \\frac{1}{|\\mathcal{Y}|} \\sum_{y' \\in \\mathcal{Y}} \\mathbf{1}\\big\\{\\mathrm{AUC}(s,y') \\;\\ge\\; \\mathrm{AUC}_{\\text{obs}}\\big\\}\n$$\n在 $n_1=0$ 或 $n_0=0$ 的退化情况下，p 值定义为 $1.0$。\n\n此过程应用于每个测试用例：\n- 对于用例 1 ($n=7$, $n_1=5$)，我们计算 $\\mathrm{AUC}_{\\text{obs}}$，然后遍历所有 $|\\mathcal{Y}| = \\binom{7}{5} = 21$ 个标签置换来找到 p 值。\n- 对于用例 2 ($n=5$, $n_1=3$)，我们有 $|\\mathcal{Y}| = \\binom{5}{3} = 10$。观测数据显示出完美分离，因此 $\\mathrm{AUC}_{\\text{obs}} = 1.0$。p 值是同样能达到 AUC 为 1.0 的置换所占的比例。由于所有评分都是唯一的，只有当三个最高的评分被分配给正标签时，才可能实现完美分离。只有一种这样的分配。因此，p 值是 $1/10 = 0.1$。\n- 对于用例 3 ($n=4$, $n_1=4, n_0=0$)，这是一个退化边界情况。根据定义，p 值为 $1.0$。\n- 对于用例 4 ($n=6$, $n_1=3$)，我们有 $|\\mathcal{Y}| = \\binom{6}{3} = 20$。由于评分在两个类别之间的对称分布，观测数据得出 $\\mathrm{AUC}_{\\text{obs}}=0.5$。p 值是 $\\mathrm{AUC} \\ge 0.5$ 的置换所占的比例。由于当 $n_1=n_0$ 时 AUC 统计量的对称性（$\\mathrm{AUC}(y') + \\mathrm{AUC}(1-y')=1$），在零假设下 AUC 值的分布围绕 0.5 对称。$\\mathrm{AUC} > 0.5$ 的情况数量必须等于 $\\mathrm{AUC} < 0.5$ 的情况数量。通过解析计数可知，有 8 个置换产生的 $\\mathrm{AUC}=0.5$，剩下 12 个置换的 AUC 不等于 0.5。根据对称性，必有 6 个大于 0.5。因此，$\\mathrm{AUC} \\ge 0.5$ 的置换总数为 $8+6=14$。p 值因此为 $14/20 = 0.7$。\n\n该实现将以编程方式为每个用例执行此穷举枚举，确保遵循所提供的精确定义。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Computes exact permutation p-values for the AUC statistic for a suite of test cases.\n    \"\"\"\n\n    def calculate_auc(scores: np.ndarray, labels: np.ndarray) -> float:\n        \"\"\"\n        Calculates the Area Under the ROC Curve (AUC) based on the provided formula.\n        \"\"\"\n        n1 = np.sum(labels == 1)\n        n0 = np.sum(labels == 0)\n\n        if n1 == 0 or n0 == 0:\n            return 0.5\n        \n        pos_scores = scores[labels == 1]\n        neg_scores = scores[labels == 0]\n        \n        auc_sum = 0.0\n        for s_i in pos_scores:\n            for s_j in neg_scores:\n                if s_i > s_j:\n                    auc_sum += 1.0\n                elif s_i == s_j:\n                    auc_sum += 0.5\n        \n        return auc_sum / (n1 * n0)\n\n    def compute_exact_p_value(s: np.ndarray, y: np.ndarray) -> float:\n        \"\"\"\n        Computes the exact permutation p-value for the observed AUC.\n        \"\"\"\n        n = len(s)\n        n1 = int(np.sum(y))\n        n0 = n - n1\n\n        if n1 == 0 or n0 == 0:\n            return 1.0\n\n        auc_observed = calculate_auc(s, y)\n        \n        indices = np.arange(n)\n        # Generate all combinations of indices for the positive class\n        pos_label_indices_iter = combinations(indices, n1)\n        \n        num_permutations = comb(n, n1, exact=True)\n        count_ge_observed = 0\n\n        for pos_indices in pos_label_indices_iter:\n            y_perm = np.zeros(n, dtype=int)\n            y_perm[list(pos_indices)] = 1\n            \n            auc_permuted = calculate_auc(s, y_perm)\n            \n            # Using a small tolerance for floating point comparison is good practice,\n            # but for this problem's small denominators, direct comparison is exact.\n            if auc_permuted >= auc_observed:\n                count_ge_observed += 1\n                \n        return count_ge_observed / num_permutations\n\n    test_cases = [\n        # Case 1: balanced moderate performance\n        (np.array([0.6, 0.2, 0.5, 0.1, 0.45, 0.5, 0.5]), \n         np.array([1, 0, 0, 1, 1, 1, 1])),\n        # Case 2: near-perfect separation\n        (np.array([0.9, 0.8, 0.7, 0.2, 0.1]), \n         np.array([1, 1, 1, 0, 0])),\n        # Case 3: degenerate boundary case\n        (np.array([0.3, 0.1, 0.9, 0.7]), \n         np.array([1, 1, 1, 1])),\n        # Case 4: interleaved ties\n        (np.array([0.1, 0.1, 0.2, 0.2, 0.3, 0.3]), \n         np.array([1, 0, 1, 0, 1, 0]))\n    ]\n    \n    results = []\n    for s, y in test_cases:\n        p_value = compute_exact_p_value(s, y)\n        results.append(f\"{p_value:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2430559"}]}