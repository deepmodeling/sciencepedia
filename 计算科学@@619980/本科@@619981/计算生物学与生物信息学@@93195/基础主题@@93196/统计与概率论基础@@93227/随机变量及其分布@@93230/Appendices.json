{"hands_on_practices": [{"introduction": "许多生物学测量，例如反应时间或本例中的神经元尖峰放电时间间隔，都可以被建模为连续随机变量。我们的目标是找到一个最能描述观测数据的概率分布。本练习以神经元活动的跨尖峰时间间隔（inter-spike intervals, ISIs）为案例，指导你比较一个简单的无记忆模型（指数分布）和一个更灵活的模型（伽马分布），并运用赤池信息准则（Akaike Information Criterion, AIC）进行模型选择。[@problem_id:2424264]", "problem": "您将执行一个建模任务，其灵感来自计算神经生物学中的脉冲序列分析。自发放电神经元的脉冲间期 (inter-spike interval, ISI) 是指连续动作电位之间经过的时间，可被视为一个正值随机变量。您将实现一个程序，该程序针对多个在已知机制下生成的合成ISI数据集，通过原则性的统计模型选择方法，从一组候选分布中选出最佳拟合分布。\n\n请使用以下基本原理：\n- 独立同分布 (i.i.d.) 假设：观测到的ISI $\\{x_i\\}_{i=1}^{n}$ 被建模为来自某个参数族的独立同分布样本。\n- 带速率参数 $\\lambda$ 的指数分布：概率密度函数为 $f(x \\mid \\lambda) = \\lambda e^{-\\lambda x}$，其中 $x > 0$。\n- 带形状参数 $k$ 和尺度参数 $\\theta$ 的伽马分布：概率密度函数为 $f(x \\mid k,\\theta) = \\dfrac{x^{k-1} e^{-x/\\theta}}{\\Gamma(k)\\,\\theta^{k}}$，其中 $x > 0$。\n- 最大似然估计 (Maximum likelihood estimation, MLE)：对于一个独立同分布样本，似然函数为 $L(\\boldsymbol{\\theta}\\,;\\,\\mathbf{x}) = \\prod_{i=1}^{n} f(x_i \\mid \\boldsymbol{\\theta})$，对数似然函数为 $\\ell(\\boldsymbol{\\theta}\\,;\\,\\mathbf{x}) = \\sum_{i=1}^{n} \\log f(x_i \\mid \\boldsymbol{\\theta})$。MLE $\\widehat{\\boldsymbol{\\theta}}$ 在允许的参数范围内最大化 $\\ell(\\boldsymbol{\\theta}\\,;\\,\\mathbf{x})$。\n- Akaike Information Criterion (AIC)：对于一个具有 $p$ 个自由参数和最大化对数似然 $\\ell(\\widehat{\\boldsymbol{\\theta}}\\,;\\,\\mathbf{x})$ 的模型，其模型分数为 $\\mathrm{AIC} = 2p - 2\\,\\ell(\\widehat{\\boldsymbol{\\theta}}\\,;\\,\\mathbf{x})$。优先选择 AIC 较小的模型。\n\n您的程序必须：\n1. 对于每个提供的测试用例，使用指定的随机种子，在给定的生成机制下模拟一个ISI数据集，并假设时间单位为秒。\n2. 通过最大似然法拟合候选模型指数分布和伽马分布。对于指数分布，约束 $\\lambda > 0$。对于伽马分布，约束 $k > 0$ 和 $\\theta > 0$，并使用支撑集为 $(0,\\infty)$ 的非移位形式。\n3. 计算每个模型的 AIC，并选择 AIC 值较小的模型。\n4. 将所选模型编码为整数：指数分布 $\\rightarrow 0$，伽马分布 $\\rightarrow 1$。\n\n物理单位：ISI 以秒为单位测量。由于输出是模型标识符，因此无需进行单位转换。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件（为保证可复现性，使用单个固定种子）：\n- 对所有模拟使用随机种子 $20231119$。\n- 情况 1（理想路径，无记忆放电）：速率 $\\lambda = 8\\,\\mathrm{s}^{-1}$ 的指数分布，样本量 $n = 2000$。\n- 情况 2（规律化放电，亚泊松可变性）：形状 $k = 3$、尺度 $\\theta = 0.04\\,\\mathrm{s}$ 的伽马分布，样本量 $n = 2000$。\n- 情况 3（簇状/猝发放电，超泊松可变性）：形状 $k = 0.5$、尺度 $\\theta = 0.2\\,\\mathrm{s}$ 的伽马分布，样本量 $n = 2000$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含按情况 1、2、3 顺序排列的结果，形式为方括号括起来的逗号分隔列表。每个条目必须是该情况下所选模型的整数代码。例如，一个有效的输出形如：\"[0,1,1]\"。", "solution": "在尝试任何解决方案之前，会对所提供的问题进行验证。\n\n### 步骤 1：提取已知信息\n- **建模假设：** 脉冲间期 (ISI) $\\{x_i\\}_{i=1}^{n}$ 是独立同分布 (i.i.d.) 的正值随机变量。\n- **候选模型：**\n    1.  **指数分布：** 概率密度函数 (PDF) $f(x \\mid \\lambda) = \\lambda e^{-\\lambda x}$，其中 $x > 0$。参数：速率 $\\lambda > 0$。\n    2.  **伽马分布：** PDF $f(x \\mid k,\\theta) = \\dfrac{x^{k-1} e^{-x/\\theta}}{\\Gamma(k)\\,\\theta^{k}}$，其中 $x > 0$。参数：形状 $k > 0$，尺度 $\\theta > 0$。\n- **参数估计：** 最大似然估计 (MLE)。\n    - 对数似然：$\\ell(\\boldsymbol{\\theta}\\,;\\,\\mathbf{x}) = \\sum_{i=1}^{n} \\log f(x_i \\mid \\boldsymbol{\\theta})$。\n- **模型选择：** Akaike Information Criterion (AIC)。\n    - 公式：$\\mathrm{AIC} = 2p - 2\\,\\ell(\\widehat{\\boldsymbol{\\theta}}\\,;\\,\\mathbf{x})$，其中 $p$ 是自由参数的数量，$\\ell(\\widehat{\\boldsymbol{\\theta}}\\,;\\,\\mathbf{x})$ 是最大化的对数似然。\n    - 规则：选择 AIC 值较小的模型。\n- **输出编码：** 指数分布 $\\rightarrow 0$，伽马分布 $\\rightarrow 1$。\n- **模拟设置：**\n    - **随机种子：** 对所有模拟使用 $20231119$。\n    - **测试用例 1：** 数据由速率 $\\lambda = 8\\,\\mathrm{s}^{-1}$、样本量 $n = 2000$ 的指数分布生成。\n    - **测试用例 2：** 数据由形状 $k = 3$、尺度 $\\theta = 0.04\\,\\mathrm{s}$、样本量 $n = 2000$ 的伽马分布生成。\n    - **测试用例 3：** 数据由形状 $k = 0.5$、尺度 $\\theta = 0.2\\,\\mathrm{s}$、样本量 $n = 2000$ 的伽马分布生成。\n- **物理单位：** ISI 以秒为单位。最终输出是无量纲的整数代码。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据验证标准对问题陈述进行分析。\n\n- **科学性：** 该问题明确地处于计算神经生物学和统计学的交叉领域。指数分布和伽马分布是脉冲间期的标准模型，分别代表无记忆（泊松）和更一般的更新过程。MLE 和 AIC 是用于参数估计和模型选择的既定基本方法。该问题在科学上是合理的。\n- **适定性：** 目标明确：对于三个指定的数据集中的每一个，拟合两个模型，计算它们的 AIC 分数，并选择分数较低的模型。使用固定的随机种子确保了合成数据集是唯一确定的，从而得到唯一的解。该问题是适定的。\n- **客观性：** 该问题使用精确的数学定义和统计程序进行描述。没有主观性语言或依赖于个人观点。\n- **不完整或矛盾的设置：** 提供了所有必要的信息：数据的生成过程（分布和参数）、样本量、随机种子、用于拟合的候选模型、参数估计方法 (MLE)、模型选择标准 (AIC) 以及确切的输出格式。该问题是自洽且一致的。\n- **不切实际或不可行：** 参数值和样本量对于神经生理学实验是现实的。所需的计算是标准的且可行的。\n- **不适定或结构不良：** 该问题被构造成一个清晰的、顺序性的任务。术语在统计学背景下有明确的定义。\n\n### 步骤 3：结论与行动\n该问题有效。它具有科学依据、适定、客观，并包含获得唯一、可复现解所需的所有信息。将着手开发解决方案。\n\n### 解决方案推导\n任务是为三个合成数据集在指数分布和伽马分布之间进行模型选择。这需要模拟数据，对每个候选模型的参数执行最大似然估计 (MLE)，然后使用 Akaike Information Criterion (AIC) 来选择更优的模型。\n\n#### 数据模拟\n必须根据每个测试用例的规范生成数据。为保证可复现性，将使用以种子 $20231119$ 初始化的单个随机数生成器。\n- **情况 1 (指数分布)：** 速率为 $\\lambda$ 的指数分布的均值为 $1/\\lambda$。许多标准库函数，例如 `numpy.random.Generator.exponential`，是按尺度参数 $\\beta$ 参数化的，该参数等于均值。因此，对于 $\\lambda = 8\\,\\mathrm{s}^{-1}$，尺度为 $\\beta = 1/8\\,\\mathrm{s} = 0.125\\,\\mathrm{s}$。我们将使用此尺度生成 $n = 2000$ 个样本。\n- **情况 2 和 3 (伽马分布)：** 伽马分布由形状 $k$ 和尺度 $\\theta$ 指定。`numpy.random.Generator.gamma` 函数直接由 `shape` 和 `scale` 参数化，因此我们可以直接使用所提供的参数 $k$ 和 $\\theta$ 为每种情况生成 $n=2000$ 个样本，无需转换。\n\n#### 最大似然估计 (MLE) 和对数似然计算\n\n**1. 指数模型**\nPDF 为 $f(x \\mid \\lambda) = \\lambda e^{-\\lambda x}$。对于数据集 $\\mathbf{x} = \\{x_1, \\dots, x_n\\}$，对数似然函数为：\n$$ \\ell(\\lambda; \\mathbf{x}) = \\sum_{i=1}^n \\log(\\lambda e^{-\\lambda x_i}) = \\sum_{i=1}^n (\\log \\lambda - \\lambda x_i) = n \\log \\lambda - \\lambda \\sum_{i=1}^n x_i $$\n为了找到 MLE $\\widehat{\\lambda}$，我们对 $\\lambda$ 求导并令结果为零：\n$$ \\frac{\\partial \\ell}{\\partial \\lambda} = \\frac{n}{\\lambda} - \\sum_{i=1}^n x_i = 0 $$\n这得到了速率参数的著名 MLE：\n$$ \\widehat{\\lambda}_{\\text{MLE}} = \\frac{n}{\\sum_{i=1}^n x_i} = \\frac{1}{\\bar{x}} $$\n其中 $\\bar{x}$ 是样本均值。计算出 $\\widehat{\\lambda}_{\\text{MLE}}$ 后，最大化的对数似然为 $\\ell_{\\text{max, exp}} = \\ell(\\widehat{\\lambda}_{\\text{MLE}}; \\mathbf{x})$。\n\n**2. 伽马模型**\nPDF 为 $f(x \\mid k, \\theta) = \\frac{x^{k-1} e^{-x/\\theta}}{\\Gamma(k) \\theta^k}$。对于数据集 $\\mathbf{x}$，对数似然函数为：\n$$ \\ell(k, \\theta; \\mathbf{x}) = \\sum_{i=1}^n \\left[ (k-1)\\log x_i - \\frac{x_i}{\\theta} - \\log \\Gamma(k) - k \\log \\theta \\right] $$\n与指数分布不同，MLEs $\\widehat{k}_{\\text{MLE}}$ 和 $\\widehat{\\theta}_{\\text{MLE}}$ 没有闭式解。必须通过数值方法最大化 $\\ell(k, \\theta; \\mathbf{x})$ 来找到它们。这等效于最小化负对数似然 $-\\ell(k, \\theta; \\mathbf{x})$。我们将使用 `scipy.stats.gamma.fit` 函数，这是一个用于此目的的专用工具。问题指定了一个在 $(0, \\infty)$ 上的非移位伽马分布，这对应于位置参数为 $0$。我们将通过在拟合函数中使用 `floc=0` 参数来强制执行这一点。该函数将返回估计的形状 $\\widehat{k}_{\\text{MLE}}$ 和尺度 $\\widehat{\\theta}_{\\text{MLE}}$。然后，使用这些估计参数对 log-PDF 值求和，计算出最大化的对数似然 $\\ell_{\\text{max, gamma}}$。\n\n#### Akaike Information Criterion (AIC)\n模型的 AIC 由 $\\mathrm{AIC} = 2p - 2\\ell_{\\text{max}}$ 给出，其中 $p$ 是估计参数的数量。\n- **对于指数模型：** 我们估计一个参数 $\\lambda$，因此 $p_{\\text{exp}} = 1$。\n$$ \\mathrm{AIC}_{\\text{exp}} = 2(1) - 2\\ell_{\\text{max, exp}} $$\n- **对于伽马模型：** 我们估计两个参数 $k$和 $\\theta$，因此 $p_{\\text{gamma}} = 2$。\n$$ \\mathrm{AIC}_{\\text{gamma}} = 2(2) - 2\\ell_{\\text{max, gamma}} $$\n\n#### 模型选择\n对于每个数据集，我们将计算 $\\mathrm{AIC}_{\\text{exp}}$ 和 $\\mathrm{AIC}_{\\text{gamma}}$。选择具有较小 AIC 值的模型作为数据的更佳拟合。然后将所选模型编码为整数（指数分布为 0，伽马分布为 1）。对所有三个测试用例重复此过程。\n- **情况 1：** 数据从指数分布生成。我们预计指数模型的 AIC 会更低。\n- **情况 2 和 3：** 数据从伽马分布生成。伽马模型比指数模型更通用（指数分布是伽马分布在 $k=1$ 时的特例）。因此，我们预计伽马模型将提供显著更好的拟合，并具有更低的 AIC。\n\n实现将精确遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import expon, gamma\n\ndef solve():\n    \"\"\"\n    Simulates inter-spike interval data, fits Exponential and Gamma models,\n    and selects the best model using AIC.\n    \"\"\"\n    # Define the random seed and test cases from the problem statement.\n    seed = 20231119\n    test_cases = [\n        {'type': 'exponential', 'params': {'rate': 8.0}, 'n': 2000},\n        {'type': 'gamma', 'params': {'shape': 3.0, 'scale': 0.04}, 'n': 2000},\n        {'type': 'gamma', 'params': {'shape': 0.5, 'scale': 0.2}, 'n': 2000},\n    ]\n\n    # Initialize the random number generator for reproducibility.\n    # The numpy Generator provides modern, preferred random number generation.\n    rng = np.random.default_rng(seed)\n\n    results = []\n    for case in test_cases:\n        # Step 1: Simulate the ISI dataset\n        n = case['n']\n        if case['type'] == 'exponential':\n            # numpy.random.exponential is parameterized by scale = 1/rate\n            rate = case['params']['rate']\n            scale = 1.0 / rate\n            data = rng.exponential(scale=scale, size=n)\n        elif case['type'] == 'gamma':\n            # numpy.random.gamma is parameterized by shape (k) and scale (theta)\n            shape = case['params']['shape']\n            scale = case['params']['scale']\n            data = rng.gamma(shape=shape, scale=scale, size=n)\n        \n        # Ensure all data points are positive, as required by the distributions.\n        # This is a safeguard; generated values should already be positive.\n        data = data[data > 0]\n\n        # Step 2: Fit candidate models by Maximum Likelihood Estimation (MLE)\n\n        # --- Exponential Model ---\n        # The MLE for the rate (lambda) is the reciprocal of the sample mean.\n        # The scale parameter (beta) used by scipy is 1/lambda.\n        lambda_mle = 1.0 / np.mean(data)\n        \n        # Calculate the maximized log-likelihood.\n        # scipy.stats.expon uses scale = 1/lambda.\n        loglik_exp = np.sum(expon.logpdf(data, scale=1.0/lambda_mle))\n        \n        # Number of parameters for the Exponential model is 1 (lambda).\n        p_exp = 1\n        \n        # Compute AIC.\n        aic_exp = 2 * p_exp - 2 * loglik_exp\n\n        # --- Gamma Model ---\n        # The MLE for Gamma parameters (k, theta) has no closed-form solution.\n        # We use scipy.stats.gamma.fit for numerical MLE.\n        # The problem states an unshifted Gamma, so we fix location (loc) to 0.\n        # The fit method returns (shape, location, scale).\n        k_mle, _, theta_mle = gamma.fit(data, floc=0)\n        \n        # Calculate the maximized log-likelihood using the estimated parameters.\n        # scipy.stats.gamma uses shape 'a' and 'scale'.\n        loglik_gamma = np.sum(gamma.logpdf(data, a=k_mle, scale=theta_mle, loc=0))\n        \n        # Number of parameters for the Gamma model is 2 (k, theta).\n        p_gamma = 2\n        \n        # Compute AIC.\n        aic_gamma = 2 * p_gamma - 2 * loglik_gamma\n\n        # Step 3: Select model with the smaller AIC and encode the result\n        # Exponential -> 0, Gamma -> 1\n        if aic_exp  aic_gamma:\n            selected_model = 0\n        else:\n            selected_model = 1\n        \n        results.append(selected_model)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424264"}, {"introduction": "在上一个练习的基础上，我们思考一个更复杂的情形：如果我们的数据并非来自单一的同质来源，而是多个不同群体的混合体呢？这在生物学中很常见，比如分析细胞群体。本练习将使用高斯混合模型（Gaussian Mixture Model, GMM）来模拟两种细胞类型的荧光数据，让你亲手实践混合模型中似然值和后验概率的核心计算。[@problem_id:2424270]", "problem": "通过流式细胞术测量的一群细胞表现出异质性的荧光信号，这是由两种不同的细胞类型引起的。设单个细胞荧光强度的以 10 为底的对数是一个实值随机变量 $I \\in \\mathbb{R}$。假设 $I$ 来自一个双组分高斯混合模型 (GMM)，其中组分 $j \\in \\{1,2\\}$ 对应一种生物细胞类型，其 $I$ 的高斯分布由均值 $\\mu_j \\in \\mathbb{R}$ 和标准差 $\\sigma_j \\in \\mathbb{R}_{0}$ 表征，且混合比例为 $\\pi_1 \\in (0,1)$ 和 $\\pi_2 = 1 - \\pi_1$。观测值是从该混合模型中独立同分布地抽取的样本。\n\n对于下面定义的每个测试用例，您将获得混合参数 $(\\pi_1,\\mu_1,\\sigma_1,\\mu_2,\\sigma_2)$ 和一个有限的观测对数强度列表 $I_1,\\dots,I_n$。仅使用第一性原理和自然对数，为每个测试用例计算以下内容：\n- 总样本对数似然 $L = \\sum_{i=1}^{n} \\log\\left(\\pi_1 \\, \\phi(I_i \\mid \\mu_1,\\sigma_1^2) + (1-\\pi_1)\\, \\phi(I_i \\mid \\mu_2,\\sigma_2^2)\\right)$，其中 $\\phi(\\cdot \\mid \\mu,\\sigma^2)$ 表示均值为 $\\mu$、方差为 $\\sigma^2$ 的高斯概率密度函数。\n- 最大后验分类计数 $C$，定义为在指定模型下，其属于组分 1 的后验概率至少为 0.5 的观测值 $I_i$ 的数量。\n\n报告 $L$（四舍五入到 6 位小数）和 $C$（作为整数）。\n\n测试套件（每个用例的参数后附观测值列表）：\n- 用例 $1$：$(\\pi_1,\\mu_1,\\sigma_1,\\mu_2,\\sigma_2) = (0.55,\\, 1.10,\\, 0.20,\\, 3.00,\\, 0.35)$; 观测值 $[0.90,\\, 1.05,\\, 1.25,\\, 2.85,\\, 2.95,\\, 3.15]$。\n- 用例 $2$：$(\\pi_1,\\mu_1,\\sigma_1,\\mu_2,\\sigma_2) = (0.50,\\, 2.00,\\, 0.40,\\, 2.40,\\, 0.50)$; 观测值 $[1.50,\\, 2.10,\\, 2.30,\\, 2.70,\\, 3.00]$。\n- 用例 $3$：$(\\pi_1,\\mu_1,\\sigma_1,\\mu_2,\\sigma_2) = (0.20,\\, 2.50,\\, 0.15,\\, 2.50,\\, 0.60)$; 观测值 $[2.50,\\, 2.55,\\, 1.50,\\, 3.70,\\, 2.30,\\, 2.70]$。\n\n您的程序必须为每个用例计算 $(L,C)$，并生成单行输出，其中包含一个扁平列表中的所有结果，顺序为用例 1、用例 2、用例 3，格式为 $[L_1, C_1, L_2, C_2, L_3, C_3]$，其中每个 $L_k$ 四舍五入到 6 位小数，每个 $C_k$ 为整数。例如，一个有效的示意格式是 $[r_1, r_2, r_3, r_4, r_5, r_6]$，其中 $r_1 = L_1$，$r_2 = C_1$，以此类推。不需要单位，所有对数都必须是自然对数。", "solution": "所述问题具有科学依据，定义明确且客观。它提出了统计建模和计算生物学中的一个标准任务：在给定一组参数和观测值的情况下，评估一个高斯混合模型 (GMM)。需要计算的量——对数似然和基于后验概率的分类计数——都经过了精确的数学定义。所有必要的数据均已提供。因此，该问题是有效的，我们着手进行求解。\n\n该问题要求对于一个给定的双组分GMM，根据其参数 $\\Theta = (\\pi_1, \\mu_1, \\sigma_1, \\mu_2, \\sigma_2)$ 和一组 $n$ 个观测值 $\\{I_i\\}_{i=1}^n$ 来计算两个量。\n\n首先，我们定义高斯概率密度函数 (PDF)。对于一个随机变量 $x \\in \\mathbb{R}$，均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布的 PDF 由以下公式给出：\n$$\n\\phi(x \\mid \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n$$\n问题提供了标准差 $\\sigma_1$ 和 $\\sigma_2$。\n\nGMM 将观测值 $I_i$ 的概率密度描述为两个组分密度的加权和：\n$$\np(I_i \\mid \\Theta) = \\pi_1 \\, \\phi(I_i \\mid \\mu_1, \\sigma_1^2) + \\pi_2 \\, \\phi(I_i \\mid \\mu_2, \\sigma_2^2)\n$$\n其中混合比例为 $\\pi_1 \\in (0,1)$ 且 $\\pi_2 = 1 - \\pi_1$。\n\n第一个需要计算的量是总样本对数似然，即 $L$。由于观测值 $I_1, \\dots, I_n$ 是独立同分布的，样本的总似然是各个似然的乘积，即 $P(\\{I_i\\} \\mid \\Theta) = \\prod_{i=1}^n p(I_i \\mid \\Theta)$。总样本对数似然是该乘积的自然对数，可以简化为各个对数似然的和：\n$$\nL = \\log\\left(\\prod_{i=1}^n p(I_i \\mid \\Theta)\\right) = \\sum_{i=1}^n \\log(p(I_i \\mid \\Theta))\n$$\n代入 $p(I_i \\mid \\Theta)$ 的表达式，我们得到用于计算的公式：\n$$\nL = \\sum_{i=1}^{n} \\log\\left(\\pi_1 \\, \\phi(I_i \\mid \\mu_1, \\sigma_1^2) + (1-\\pi_1)\\, \\phi(I_i \\mid \\mu_2, \\sigma_2^2)\\right)\n$$\n必须为每个测试用例计算此值，并四舍五入到 6 位小数。\n\n第二个需要计算的量是最大后验 (MAP) 分类计数，即 $C$。这需要我们根据每个观测值 $I_i$ 的后验概率，将其分配到两个组分之一。设 $Z_i \\in \\{1, 2\\}$ 是一个潜变量，表示观测值 $I_i$ 源自的组分。在给定观测值和模型参数的情况下，使用 Bayes 定理可以求得 $I_i$ 属于组分 1 的后验概率：\n$$\nP(Z_i=1 \\mid I_i, \\Theta) = \\frac{p(I_i \\mid Z_i=1, \\Theta) \\, P(Z_i=1 \\mid \\Theta)}{p(I_i \\mid \\Theta)}\n$$\n在这里，各项分别是：\n-   先验概率 $P(Z_i=1 \\mid \\Theta) = \\pi_1$。\n-   组分条件似然 $p(I_i \\mid Z_i=1, \\Theta) = \\phi(I_i \\mid \\mu_1, \\sigma_1^2)$。\n-   证据或边缘似然 $p(I_i \\mid \\Theta)$，即先前定义的 GMM PDF。\n\n因此，组分 1 的后验概率为：\n$$\n\\gamma(Z_i=1) \\equiv P(Z_i=1 \\mid I_i, \\Theta) = \\frac{\\pi_1 \\, \\phi(I_i \\mid \\mu_1, \\sigma_1^2)}{\\pi_1 \\, \\phi(I_i \\mid \\mu_1, \\sigma_1^2) + (1 - \\pi_1) \\, \\phi(I_i \\mid \\mu_2, \\sigma_2^2)}\n$$\n问题定义了 MAP 分类规则：如果一个观测值 $I_i$ 的后验概率至少为 0.5，则将其分配给组分 1。\n计数 $C$ 是满足此条件的观测值的总数：\n$$\nC = \\sum_{i=1}^{n} \\mathbb{I}(\\gamma(Z_i=1) \\ge 0.5)\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，当其参数为真时值为 1，否则为 0。\n\n每个测试用例的计算步骤如下：\n$1$. 初始化总对数似然 $L = 0$ 和计数 $C = 0$。\n$2$. 对于所提供列表中的每个观测值 $I_i$：\n    a. 计算 $I_i$ 在组分 1下的密度，$d_1 = \\phi(I_i \\mid \\mu_1, \\sigma_1^2)$。\n    b. 计算 $I_i$ 在组分 2下的密度，$d_2 = \\phi(I_i \\mid \\mu_2, \\sigma_2^2)$。\n    c. 计算组分 1 的加权密度，$w_1 = \\pi_1 d_1$。\n    d. 计算组分 2 的加权密度，$w_2 = (1-\\pi_1) d_2$。\n    e. $I_i$ 的边缘似然为 $p_i = w_1 + w_2$。\n    f. 将 $\\log(p_i)$ 加到总对数似然 $L$ 上。\n    g. 计算组分 1 的后验概率：$\\gamma(Z_i=1) = w_1 / p_i$。\n    h. 如果 $\\gamma(Z_i=1) \\ge 0.5$，则将计数 $C$ 加 1。\n$3$. 遍历所有观测值后，将 $L$ 的最终值四舍五入到 6 位小数。 $C$ 的值为整数。\n$4$. 存储序对 $(L, C)$。\n\n对所有三个测试用例重复此过程，并将结果汇编成一个单一的扁平列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Gaussian Mixture Model problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": (0.55, 1.10, 0.20, 3.00, 0.35),\n            \"observations\": [0.90, 1.05, 1.25, 2.85, 2.95, 3.15]\n        },\n        {\n            \"params\": (0.50, 2.00, 0.40, 2.40, 0.50),\n            \"observations\": [1.50, 2.10, 2.30, 2.70, 3.00]\n        },\n        {\n            \"params\": (0.20, 2.50, 0.15, 2.50, 0.60),\n            \"observations\": [2.50, 2.55, 1.50, 3.70, 2.30, 2.70]\n        }\n    ]\n\n    results = []\n\n    def gaussian_pdf(x, mu, sigma):\n        \"\"\"\n        Calculates the probability density function of a Gaussian distribution.\n        Uses first principles as required.\n        \"\"\"\n        if sigma = 0:\n            raise ValueError(\"Standard deviation must be positive.\")\n        variance = sigma**2\n        coeff = 1.0 / np.sqrt(2.0 * np.pi * variance)\n        exponent = -((x - mu)**2) / (2.0 * variance)\n        return coeff * np.exp(exponent)\n\n    for case in test_cases:\n        pi1, mu1, sigma1, mu2, sigma2 = case[\"params\"]\n        observations = case[\"observations\"]\n        \n        pi2 = 1.0 - pi1\n        total_log_likelihood = 0.0\n        map_count_c1 = 0\n\n        for I_i in observations:\n            # Calculate the PDF values for each component\n            pdf1 = gaussian_pdf(I_i, mu1, sigma1)\n            pdf2 = gaussian_pdf(I_i, mu2, sigma2)\n\n            # Calculate weighted densities\n            weighted_pdf1 = pi1 * pdf1\n            weighted_pdf2 = pi2 * pdf2\n\n            # Calculate marginal likelihood for the observation I_i\n            p_i = weighted_pdf1 + weighted_pdf2\n\n            # Update total log-likelihood, using natural logarithm\n            if p_i > 0:\n                total_log_likelihood += np.log(p_i)\n\n            # Calculate posterior probability for component 1 (responsibility)\n            # and perform MAP classification\n            if p_i > 0:\n                posterior1 = weighted_pdf1 / p_i\n                if posterior1 >= 0.5:\n                    map_count_c1 += 1\n        \n        # Round the total log-likelihood to 6 decimal places\n        L = round(total_log_likelihood, 6)\n        # C is the integer count\n        C = map_count_c1\n        \n        results.append(L)\n        results.append(C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424270"}, {"introduction": "现在，让我们从对静态测量建模，转向对随时间演化的动态过程进行建模。许多生物系统会发生随机性变化。本练习将短串联重复（Short Tandem Repeat, STR）区域长度的代际变化建模为一个随机游走过程，让你能够计算一些关键的预测性指标，例如在多代之后某个基因座的期望长度及其方差。[@problem_id:2424265]", "problem": "考虑单个基因组位点，该位点上短串联重复 (STR) 单元的数量是一个整数值随机过程 $\\{N_t\\}_{t \\in \\{0,1,2,\\dots\\}}$。设 $N_0$ 为初始重复数。对于每一代 $t \\in \\{0,1,2,\\dots\\}$，通过 $N_{t+1} = N_t + \\Delta N_t$ 定义变化量 $\\Delta N_t$。假设 $\\{\\Delta N_t\\}_{t \\ge 0}$ 是独立同分布的随机变量，其概率质量函数由参数 $\\alpha \\in [0,1]$、$\\beta \\in [0,1]$ 和 $\\gamma \\in [0,1]$ 决定，具体如下：\n- 以 $1 - \\alpha$ 的概率，$\\Delta N_t = 0$（无变化）。\n- 以 $\\alpha$ 的概率，发生一次滑动事件。在发生滑动事件的条件下，变化的幅度为 $1$ 的概率是 $1 - \\gamma$，为 $2$ 的概率是 $\\gamma$。在幅度确定的条件下，方向为扩张（正向）的概率是 $\\beta$，为缩短（负向）的概率是 $1 - \\beta$。\n\n等价地，对于 $k \\in \\{-2,-1,0,1,2\\}$：\n- $\\mathbb{P}(\\Delta N_t = 0) = 1 - \\alpha$，\n- $\\mathbb{P}(\\Delta N_t = +1) = \\alpha (1 - \\gamma)\\beta$，\n- $\\mathbb{P}(\\Delta N_t = -1) = \\alpha (1 - \\gamma)(1 - \\beta)$，\n- $\\mathbb{P}(\\Delta N_t = +2) = \\alpha \\gamma \\beta$，\n- $\\mathbb{P}(\\Delta N_t = -2) = \\alpha \\gamma (1 - \\beta)$。\n\n对于固定的代数 $T \\in \\mathbb{N}$，定义总变化量 $S_T = \\sum_{t=0}^{T-1} \\Delta N_t$，因此 $N_T = N_0 + S_T$。\n\n对于下方的每个测试用例，计算以下量值：\n1. 经过 $T$ 代后的期望重复数 $\\mathbb{E}[N_T]$，以实数形式表示。\n2. 经过 $T$ 代后重复数的方差 $\\mathrm{Var}(N_T)$，以实数形式表示。\n3. 精确概率 $\\mathbb{P}(N_T = N_0)$，以实数形式表示。\n4. 对于给定的非负整数 $K$，计算精确概率 $\\mathbb{P}(N_T \\ge N_0 + K)$，以实数形式表示。\n5. 一个布尔值，指示单代扩张是否比单代缩短更有可能，即 $\\mathbb{P}(\\Delta N_t  0)  \\mathbb{P}(\\Delta N_t  0)$ 是否成立。\n\n所有概率和期望必须根据指定的分布假设进行精确计算。将每个浮点数输出四舍五入到 $6$ 位小数。布尔值必须报告为 True 或 False。不涉及物理单位。\n\n测试套件（每个用例以 $(N_0, T, \\alpha, \\beta, \\gamma, K)$ 的形式给出）：\n- 用例 1：$(12, 20, 0.6, 0.55, 0.1, 3)$。\n- 用例 2：$(18, 15, 0.0, 0.5, 0.3, 2)$。\n- 用例 3：$(10, 24, 1.0, 0.5, 0.0, 0)$。\n- 用例 4：$(22, 7, 1.0, 1.0, 0.2, 5)$。\n\n您的程序应生成单行输出，其中包含测试套件的结果，结果为逗号分隔的列表，并用方括号括起来。每个测试用例的结果本身应是一个包含五个值的列表，顺序如下：$[\\mathbb{E}[N_T], \\mathrm{Var}(N_T), \\mathbb{P}(N_T = N_0), \\mathbb{P}(N_T \\ge N_0 + K), \\text{布尔值}]$。例如，整体输出必须采用以下形式\n$[[e_1,v_1,p^{(=)}_1,p^{(\\ge)}_1,b_1],[e_2,v_2,p^{(=)}_2,p^{(\\ge)}_2,b_2],[e_3,v_3,p^{(=)}_3,p^{(\\ge)}_3,b_3],[e_4,v_4,p^{(=)}_4,p^{(\\ge)}_4,b_4]]$\n且不含空格。", "solution": "提交分析的问题陈述被认为是有效的。其具有科学依据、良构、客观且自洽。它描述了一个离散时间、离散状态的随机过程，这是计算生物学中的一个标准建模范式，并针对该过程在固定步数后的状态提出了具体的、可计算的问题。其中的参数和条件是一致的，且在数学上是合理的。因此，我们可以着手推导解决方案。\n\n该问题定义了一个基因组重复数 $N_t$ 的随机过程。每代的变化量 $\\Delta N_t$ 是一个独立同分布 (i.i.d.) 的随机变量。我们已知其概率质量函数 (PMF)，由参数 $\\alpha \\in [0,1]$、$\\beta \\in [0,1]$ 和 $\\gamma \\in [0,1]$ 决定。设 $\\Delta N$ 是一个服从该分布的通用随机变量。其 PMF 为：\n$$\n\\mathbb{P}(\\Delta N = k) =\n\\begin{cases}\n1 - \\alpha  \\text{if } k=0 \\\\\n\\alpha (1 - \\gamma)\\beta  \\text{if } k=1 \\\\\n\\alpha (1 - \\gamma)(1 - \\beta)  \\text{if } k=-1 \\\\\n\\alpha \\gamma \\beta  \\text{if } k=2 \\\\\n\\alpha \\gamma (1 - \\beta)  \\text{if } k=-2 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n经过 $T$ 代后的总变化量为 $S_T = \\sum_{t=0}^{T-1} \\Delta N_t$，最终的重复数为 $N_T = N_0 + S_T$，其中 $N_0$ 是一个给定的常数。我们必须为每个测试用例计算五个量值。\n\n**1. 期望重复数, $\\mathbb{E}[N_T]$**\n\n根据期望的线性性质，\n$$ \\mathbb{E}[N_T] = \\mathbb{E}[N_0 + S_T] = N_0 + \\mathbb{E}[S_T] $$\n由于 $\\Delta N_t$ 是独立同分布的，\n$$ \\mathbb{E}[S_T] = \\mathbb{E}\\left[\\sum_{t=0}^{T-1} \\Delta N_t\\right] = \\sum_{t=0}^{T-1} \\mathbb{E}[\\Delta N_t] = T \\cdot \\mathbb{E}[\\Delta N] $$\n单步变化 $\\Delta N$ 的期望根据其定义计算：\n$$ \\mathbb{E}[\\Delta N] = \\sum_{k \\in \\{-2, -1, 1, 2\\}} k \\cdot \\mathbb{P}(\\Delta N=k) $$\n$$ \\mathbb{E}[\\Delta N] = (1)[\\alpha(1-\\gamma)\\beta] + (-1)[\\alpha(1-\\gamma)(1-\\beta)] + (2)[\\alpha\\gamma\\beta] + (-2)[\\alpha\\gamma(1-\\beta)] $$\n$$ = \\alpha(1-\\gamma)(\\beta - (1-\\beta)) + 2\\alpha\\gamma(\\beta - (1-\\beta)) $$\n$$ = \\alpha(1-\\gamma)(2\\beta - 1) + 2\\alpha\\gamma(2\\beta - 1) $$\n$$ = \\alpha(2\\beta - 1)(1-\\gamma+2\\gamma) = \\alpha(1+\\gamma)(2\\beta-1) $$\n因此，经过 $T$ 代后的期望重复数是：\n$$ \\mathbb{E}[N_T] = N_0 + T\\alpha(1+\\gamma)(2\\beta-1) $$\n\n**2. 重复数的方差, $\\mathrm{Var}(N_T)$**\n\n由于 $N_0$ 是一个常数，$\\mathrm{Var}(N_T) = \\mathrm{Var}(N_0 + S_T) = \\mathrm{Var}(S_T)$。因为 $\\Delta N_t$ 是独立的，所以它们的和的方差等于各方差之和：\n$$ \\mathrm{Var}(S_T) = \\mathrm{Var}\\left(\\sum_{t=0}^{T-1} \\Delta N_t\\right) = \\sum_{t=0}^{T-1} \\mathrm{Var}(\\Delta N_t) = T \\cdot \\mathrm{Var}(\\Delta N) $$\n单步变化的方差为 $\\mathrm{Var}(\\Delta N) = \\mathbb{E}[(\\Delta N)^2] - (\\mathbb{E}[\\Delta N])^2$。我们首先计算二阶矩 $\\mathbb{E}[(\\Delta N)^2]$：\n$$ \\mathbb{E}[(\\Delta N)^2] = \\sum_{k \\in \\{-2, -1, 1, 2\\}} k^2 \\cdot \\mathbb{P}(\\Delta N=k) $$\n$$ = (1)^2[\\alpha(1-\\gamma)\\beta] + (-1)^2[\\alpha(1-\\gamma)(1-\\beta)] + (2)^2[\\alpha\\gamma\\beta] + (-2)^2[\\alpha\\gamma(1-\\beta)] $$\n$$ = \\alpha(1-\\gamma)(\\beta + 1 - \\beta) + 4\\alpha\\gamma(\\beta + 1 - \\beta) $$\n$$ = \\alpha(1-\\gamma) + 4\\alpha\\gamma = \\alpha(1-\\gamma+4\\gamma) = \\alpha(1+3\\gamma) $$\n将 $\\mathbb{E}[(\\Delta N)^2]$ 和 $\\mathbb{E}[\\Delta N]$ 的表达式代入，我们得到 $N_T$ 的方差：\n$$ \\mathrm{Var}(N_T) = T \\left( \\alpha(1+3\\gamma) - [\\alpha(1+\\gamma)(2\\beta-1)]^2 \\right) $$\n\n**3. 概率 $\\mathbb{P}(N_T = N_0)$ 与 4. 概率 $\\mathbb{P}(N_T \\ge N_0 + K)$**\n\n这些概率关系到总变化量 $S_T$ 的分布。具体而言，$\\mathbb{P}(N_T = N_0) = \\mathbb{P}(S_T = 0)$ 且 $\\mathbb{P}(N_T \\ge N_0 + K) = \\mathbb{P}(S_T \\ge K)$。$S_T$ 是 $T$ 个独立同分布的离散随机变量之和，其分布是 $\\Delta N$ 分布的 $T$ 重卷积。这可以使用动态规划高效地计算。\n\n设 $P_t(k) = \\mathbb{P}(S_t=k)$ 为经过 $t$ 代后总变化量的概率质量函数。基本情况是 $t=0$ 时，$S_0=0$，所以 $P_0(0)=1$ 且对于 $k \\ne 0$ 有 $P_0(k)=0$。递推步骤由 $S_{t+1} = S_t + \\Delta N_t$ 导出：\n$$ P_{t+1}(k) = \\mathbb{P}(S_{t+1}=k) = \\sum_{j \\in \\{-2, -1, 0, 1, 2\\}} \\mathbb{P}(S_t=k-j)\\mathbb{P}(\\Delta N_t=j) $$\n设 $p_j = \\mathbb{P}(\\Delta N = j)$。递推关系为：\n$$ P_{t+1}(k) = p_{-2}P_t(k+2) + p_{-1}P_t(k+1) + p_0P_t(k) + p_1P_t(k-1) + p_2P_t(k-2) $$\n我们可以从 $S_0$ 的分布开始，对 $t = 1, \\dots, T$ 迭代此计算。在每一步 $t$，我们基于 $S_{t-1}$ 的分布来计算 $S_t$ 的分布。我们维护一个字典，将和的每个可能值 $k$ 映射到其概率 $P_t(k)$。\n经过 $T$ 次迭代后，我们得到 $S_T$ 的概率质量函数。所需的概率则为：\n$$ \\mathbb{P}(N_T = N_0) = P_T(0) $$\n$$ \\mathbb{P}(N_T \\ge N_0 + K) = \\sum_{k=K}^{\\infty} P_T(k) = \\sum_{k=K}^{2T} P_T(k) $$\n求和是有限的，因为 $S_T$ 的最大可能值为 $2T$。\n\n**5. 布尔值: $\\mathbb{P}(\\Delta N_t  0)  \\mathbb{P}(\\Delta N_t  0)$**\n\n这个问题比较的是单步扩张与单步缩短的概率。\n扩张的概率是：\n$$ \\mathbb{P}(\\Delta N  0) = \\mathbb{P}(\\Delta N=1) + \\mathbb{P}(\\Delta N=2) = \\alpha(1-\\gamma)\\beta + \\alpha\\gamma\\beta = \\alpha\\beta(1-\\gamma+\\gamma) = \\alpha\\beta $$\n缩短的概率是：\n$$ \\mathbb{P}(\\Delta N  0) = \\mathbb{P}(\\Delta N=-1) + \\mathbb{P}(\\Delta N=-2) = \\alpha(1-\\gamma)(1-\\beta) + \\alpha\\gamma(1-\\beta) = \\alpha(1-\\beta)(1-\\gamma+\\gamma) = \\alpha(1-\\beta) $$\n需要评估的不等式是 $\\alpha\\beta  \\alpha(1-\\beta)$。\n如果 $\\alpha = 0$，不等式两边都为 $0$，则 $0  0$ 为假。\n如果 $\\alpha  0$，我们可以用 $\\alpha$ 除以两边得到 $\\beta  1-\\beta$，化简为 $2\\beta  1$，即 $\\beta  0.5$。\n因此，该条件成立当且仅当 $\\alpha  0$ 且 $\\beta  0.5$。\n\n这些推导为解决该问题提供了一个完整的分析和计算框架。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted result.\n    \"\"\"\n    test_cases = [\n        (12, 20, 0.6, 0.55, 0.1, 3),\n        (18, 15, 0.0, 0.5, 0.3, 2),\n        (10, 24, 1.0, 0.5, 0.0, 0),\n        (22, 7, 1.0, 1.0, 0.2, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_quantities(*case)\n        results.append(result)\n\n    # Format the final output string as specified in the problem.\n    # e.g., [[e1,v1,p1_eq,p1_ge,b1],[e2,v2,p2_eq,p2_ge,b2],...]\n    formatted_case_results = []\n    for r in results:\n        # r[0] to r[3] are floats, r[4] is a bool\n        formatted_case_results.append(\n            f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f},{r[3]:.6f},{str(r[4])}]\"\n        )\n    \n    final_output_string = f\"[{','.join(formatted_case_results).replace(' ','')}]\"\n    print(final_output_string)\n\ndef compute_quantities(N0, T, alpha, beta, gamma, K):\n    \"\"\"\n    Computes the five required quantities for a single test case.\n\n    Args:\n        N0 (int): Initial repeat count.\n        T (int): Number of generations.\n        alpha (float): Probability of a slippage event.\n        beta (float): Probability of expansion, given slippage.\n        gamma (float): Probability of magnitude 2 change, given slippage.\n        K (int): Threshold for the probability calculation P(N_T = N_0 + K).\n\n    Returns:\n        A list containing the five results:\n        [E[N_T], Var(N_T), P(N_T=N_0), P(N_T=N_0+K), expansion_likelier_bool]\n    \"\"\"\n\n    # 1. Expected Repeat Count, E[N_T]\n    mu_delta = alpha * (1 + gamma) * (2 * beta - 1)\n    e_nt = N0 + T * mu_delta\n\n    # 2. Variance of Repeat Count, Var(N_T)\n    e2_delta = alpha * (1 + 3 * gamma)\n    var_delta = e2_delta - mu_delta**2\n    var_nt = T * var_delta\n\n    # Probabilities of single-step changes\n    p_changes = {\n        0: 1 - alpha,\n        1: alpha * (1 - gamma) * beta,\n        -1: alpha * (1 - gamma) * (1 - beta),\n        2: alpha * gamma * beta,\n        -2: alpha * gamma * (1 - beta),\n    }\n\n    # 3. P(N_T = N_0) and 4. P(N_T = N_0 + K) using dynamic programming\n    # dist[k] stores P(S_t = k)\n    dist = defaultdict(float)\n    dist[0] = 1.0\n\n    for _ in range(T):\n        next_dist = defaultdict(float)\n        for s_val, s_prob in dist.items():\n            if s_prob > 0:\n                for change, p_change in p_changes.items():\n                    if p_change > 0:\n                        next_dist[s_val + change] += s_prob * p_change\n        dist = next_dist\n    \n    prob_nt_eq_n0 = dist.get(0, 0.0)\n    \n    prob_nt_ge_n0_plus_k = sum(prob for val, prob in dist.items() if val >= K)\n\n    # 5. Boolean: P(Delta_N > 0) > P(Delta_N  0)\n    # This simplifies to alpha*beta > alpha*(1-beta)\n    # which is true iff alpha > 0 and beta > 0.5\n    is_expansion_likelier = alpha > 0 and beta > 0.5\n    \n    return [e_nt, var_nt, prob_nt_eq_n0, prob_nt_ge_n0_plus_k, is_expansion_likelier]\n\nsolve()\n```", "id": "2424265"}]}