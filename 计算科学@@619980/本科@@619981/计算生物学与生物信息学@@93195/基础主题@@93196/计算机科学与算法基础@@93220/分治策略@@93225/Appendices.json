{"hands_on_practices": [{"introduction": "在生物信息学中，我们常常面临内存无法容纳全部数据的数据集，即所谓的“大数据”挑战。本练习旨在解决这一现实问题，通过计算一个元基因组样本中所有独特的$k$-mer的数量，同时遵循严格的内存预算。这个练习将指导你应用分治策略，不是通过分割输入数据，而是巧妙地分割问题的“解空间”（即所有可能的$k$-mer），从而让你掌握在有限的计算资源下处理海量数据的核心技巧 [@problem_id:2386106]。", "problem": "给定一个由脱氧核糖核酸 (DNA) 字符串构成的多重集，这些字符串建立在字母表 $\\Sigma=\\{A,C,G,T\\}$ 之上。对于一个整数 $k \\ge 1$，一个$k$-mer是指任意一个长度为 $k$、且仅由 $\\Sigma$ 中字符组成的连续子串。任何包含 $\\Sigma$ 之外字符的子串均不被视为有效的$k$-mer，且必须被忽略。对于一个 DNA 字符串集合，设 $\\mathcal{K}_k$ 表示在该集合中至少一个字符串里出现过的所有有效$k$-mer的集合。您的任务是在一个模拟随机存取存储器 (RAM) 的严格内存预算下，精确计算 $|\\mathcal{K}_k|$ 的值。该内存预算被形式化定义如下：在任何时刻，您的程序在内存中不允许同时持有超过 $B$ 个不同的$k$-mer键。您可以假设 $B \\ge 1$ 是一个整数。\n\n请设计并实现一个程序，对给定的几组参数集 $(\\text{sequences}, k, B)$，返回每组参数对应的 $|\\mathcal{K}_k|$ 精确值，同时确保您方法中的任何数据结构在任何时候都不会并发存储超过 $B$ 个不同的$k$-mer。整体输入可能大于可用 RAM；因此，您的方法必须通过构建计算过程来获取最终的精确结果，且不超出对并发存储的不同键数量的规定约束。输入序列应被视为只读字符串；不要假设有任何可用的特殊预处理索引。\n\n在您的程序中使用以下参数值测试套件。在下方的每个项目中，都给出了值 $k$ 和预算 $B$，其后是 DNA 字符串列表。在所有情况下，都应忽略包含 $\\Sigma$ 之外字符的子串。\n\n- 测试用例 1: $k=3$, $B=2$, sequences = [\"ACGTACGT\",\"TACG\"]。\n- 测试用例 2: $k=2$, $B=4$, sequences = [\"AAAAAA\"]。\n- 测试用例 3: $k=2$, $B=1$, sequences = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"]。\n- 测试用例 4: $k=4$, $B=1$, sequences = [\"ATATATATAT\",\"TATATATATA\"]。\n- 测试用例 5: $k=1$, $B=1$, sequences = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"]。\n- 测试用例 6: $k=3$, $B=2$, sequences = [\"AC\",\"G\"]。\n\n您的程序必须为每个测试用例计算整数 $|\\mathcal{K}_k|$，其中 $\\mathcal{K}_k$ 的定义如上所述。要求的最终输出格式为单行文本，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与上述测试用例的顺序一致，例如：“[x1,x2,x3,x4,x5,x6]”，其中每个 $x_i$ 是测试用例 $i$ 的 $|\\mathcal{K}_k|$ 的整数值。", "solution": "对问题陈述进行严格验证。\n\n**步骤 1：提取已知条件**\n- **字母表**：$\\Sigma=\\{A,C,G,T\\}$\n- **$k$-mer**：一个长度为 $k \\ge 1$、仅由 $\\Sigma$ 中字符组成的连续子串。\n- **无效子串**：包含 $\\Sigma$ 之外字符的子串将被忽略。\n- **输入**：一个字符串多重集，记为 `sequences`。\n- **输入参数 $k$**：一个整数，表示 $k$-mer 的长度，其中 $k \\ge 1$。\n- **输入参数 $B$**：一个整数，表示内存预算，代表可并发存储的不同 $k$-mer 键的最大数量。给定条件为 $B \\ge 1$。\n- **目标**：计算 $|\\mathcal{K}_k|$，即输入 `sequences` 中存在的所有唯一的、有效的 $k$-mer 集合 $\\mathcal{K}_k$ 的基数。\n- **约束**：算法在任何给定时间点都不得在内存中存储超过 $B$ 个不同的 $k$-mer。\n- **测试用例**：\n    - 测试用例 1: $k=3$, $B=2$, sequences = [\"ACGTACGT\",\"TACG\"]。\n    - 测试用例 2: $k=2$, $B=4$, sequences = [\"AAAAAA\"]。\n    - 测试用例 3: $k=2$, $B=1$, sequences = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"]。\n    - 测试用例 4: $k=4$, $B=1$, sequences = [\"ATATATATAT\",\"TATATATATA\"]。\n    - 测试用例 5: $k=1$, $B=1$, sequences = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"]。\n    - 测试用例 6: $k=3$, $B=2$, sequences = [\"AC\",\"G\"]。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在计算生物学和生物信息学领域有充分的依据。$k$-mer 计数是基因组组装、序列比对和宏基因组学分析等应用的一项基本任务。使用字母表 $\\Sigma=\\{A,C,G,T\\}$ 以及忽略非标准字符（如 'N'）的概念是标准惯例。此问题是流式算法中“不同元素问题”的一个变种，应用于生物信息学领域并遵循特定的内存模型。它在科学上和计算上都是合理的。\n- **适定性**：此问题是适定的。目标是计算一个唯一定义集合 $\\mathcal{K}_k$ 的基数。输入和约束条件都已明确指定。对于任何一组有效输入，都存在一个唯一的整数解。\n- **客观性**：问题陈述使用了精确、客观和形式化的数学语言。它没有歧义性、主观性或基于观点的论述。\n\n**步骤 3：结论与行动**\n问题是 **有效的**。这是一个标准的、定义明确的计算问题，具有清晰的约束和目标。着手制定解决方案。\n\n**基于原则的解决方案**\n\n这个问题的核心挑战是严格的内存预算 $B$，这使得朴素的方法不可行。一个直接的解决方案，例如遍历所有序列，提取所有$k$-mer，然后将它们插入单个哈希集合中，在不同$k$-mer的总数 $|\\mathcal{K}_k|$ 超过 $B$ 时将会失败。因此，该问题要求一种能够处理大于可用内存的数据的算法，通常称为“外存”算法或“核外”算法。\n\n解决此类问题的指导原则是 **分治**。然而，我们不能对只读的输入数据（序列）进行分割，而必须分割问题空间本身。问题空间是字母表 $\\Sigma$ 上所有可能的 $4^k$ 个$k$-mer的集合。通过将此空间划分为不相交的子集，我们可以独立地计算每个子集内不同的$k$-mer数量，然后将结果求和。分区的不相交特性确保了没有$k$-mer会被重复计数。\n\n此处最有效的分割策略是基于前缀对$k$-mer空间进行递归分割。让我们定义一个函数 $\\text{Count}(\\rho)$，它计算输入序列中以给定前缀 $\\rho$ 开头的不同$k$-mer的数量。那么，不同$k$-mer的总数就是 $\\text{Count}(\\text{\"\"})$，其中 $\\text{\"\"}$ 是空前缀。\n\n该算法被构建为一个递归函数，尝试在内存预算 $B$ 内解决 $\\text{Count}(\\rho)$。\n\n1. **尝试计数**：为了计算 $\\text{Count}(\\rho)$，我们遍历所有输入序列。对于找到的每个有效$k$-mer，我们检查它是否以前缀 $\\rho$ 开头。如果是，我们将其添加到一个内存中的集合，称之为 $S_{\\rho}$。\n\n2. **内存预算检查**：在此过程中，我们持续监控集合的大小 $|S_{\\rho}|$。\n    - 如果处理完整个数据集后 $|S_{\\rho}|$ 从未超过 $B$，那么我们已成功计算了此分区的不同$k$-mer数量。函数返回 $|S_{\\rho}|$。这构成了我们递归的基准情形。\n    - 如果在任何时候 $|S_{\\rho}|$ 变得大于 $B$，这意味着由前缀 $\\rho$ 定义的分区太大，无法在内存限制内处理。我们必须进行“溢出”，在此上下文中，这意味着放弃当前计数并细分问题。\n\n3. **递归细分（划分步骤）**：发生“溢出”时，我们将对应于前缀 $\\rho$ 的分区根据下一个字符细分为四个更小的、不相交的分区。这四个新前缀将是 $\\rho+'A'$、$\\rho+'C'$、$\\rho+'G'$ 和 $\\rho+'T'$。前缀 $\\rho$ 的总计数即为这些更小分区的计数之和。这可以递归地表示为：\n$$ \\text{Count}(\\rho) = \\text{Count}(\\rho+'A') + \\text{Count}(\\rho+'C') + \\text{Count}(\\rho+'G') + \\text{Count}(\\rho+'T') $$\n这种递归调用有效地启动了对数据的新一轮遍历，每一轮都专注于一个更具体的$k$-mer子集。\n\n4. **终止**：递归保证会终止。随着前缀长度的增加，对应的$k$-mer空间分区会变得更小。在极限情况下，前缀长度将变为 $k$。一个长度为 $k$ 的前缀所对应的分区最多只可能包含一个唯一的$k$-mer（即前缀本身）。由于预算 $B \\ge 1$，对于由长度为 $k$ 的前缀定义的分区，不可能发生溢出。因此，递归深度至多为 $k$，并且总能达到基准情形（在预算内成功计数）。\n\n这种基于前缀的递归分治策略能够正确计算出不同$k$-mer的精确数量，同时在计算的每个阶段都严格遵守内存约束。这种内存合规性的代价是计算时间的增加，因为输入序列可能需要被多次扫描。\n\n在处理之前，必须处理任何不在 $\\Sigma = \\{A, C, G, T\\}$ 中的字符。一种稳健的方法是将这些字符视作分隔符，将每个输入序列分割成一组仅由有效字符组成的连续子串。然后，$k$-mer提取逻辑仅应用于这些有效的子串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the k-mer counting problem for the predefined test suite.\n    \"\"\"\n    \n    test_cases = [\n        # (sequences, k, B)\n        ([\"ACGTACGT\", \"TACG\"], 3, 2),\n        ([\"AAAAAA\"], 2, 4),\n        ([\"NNNNN\", \"ACNGT\", \"ACGTTN\"], 2, 1),\n        ([\"ATATATATAT\", \"TATATATATA\"], 4, 1),\n        ([\"ACGTACGT\", \"GGGG\", \"TTTT\", \"CCCC\", \"AAAA\"], 1, 1),\n        ([\"AC\", \"G\"], 3, 2),\n    ]\n\n    results = []\n    for sequences, k, B in test_cases:\n        result = count_distinct_kmers(sequences, k, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef count_distinct_kmers(sequences, k, B):\n    \"\"\"\n    Main entry point for the k-mer counting algorithm. It initializes\n    the recursive counting process.\n\n    Args:\n        sequences (list[str]): The list of DNA sequences.\n        k (int): The length of the k-mer.\n        B (int): The memory budget (max number of distinct k-mers).\n\n    Returns:\n        int: The total count of distinct k-mers.\n    \"\"\"\n    if k <= 0:\n        return 0\n\n    valid_chars = {'A', 'C', 'G', 'T'}\n    \n    # Pre-process sequences to handle invalid characters like 'N'.\n    # This creates a list of substrings containing only valid DNA characters.\n    valid_substrings = []\n    for seq in sequences:\n        current_sub = []\n        for char in seq:\n            if char in valid_chars:\n                current_sub.append(char)\n            else:\n                if current_sub:\n                    valid_substrings.append(\"\".join(current_sub))\n                    current_sub = []\n        if current_sub:\n            valid_substrings.append(\"\".join(current_sub))\n\n    return _count_recursive(valid_substrings, k, B, \"\", np.array(list(valid_chars)))\n\ndef _count_recursive(valid_substrings, k, B, prefix, alphabet):\n    \"\"\"\n    Recursively counts distinct k-mers using a divide-and-conquer approach.\n\n    Args:\n        valid_substrings (list[str]): A list of DNA segments with no invalid characters.\n        k (int): The k-mer length.\n        B (int): The memory budget.\n        prefix (str): The current prefix defining the k-mer partition to count.\n        alphabet (np.ndarray): The characters of the DNA alphabet.\n\n    Returns:\n        int: The count of distinct k-mers for the given partition.\n    \"\"\"\n    kmers_in_partition = set()\n    has_spilled = False\n\n    for sub_seq in valid_substrings:\n        if len(sub_seq) < k:\n            continue\n        for i in range(len(sub_seq) - k + 1):\n            # Potential k-mer\n            kmer = sub_seq[i:i+k]\n            if kmer.startswith(prefix):\n                kmers_in_partition.add(kmer)\n                if len(kmers_in_partition) > B:\n                    has_spilled = True\n                    break  # from inner loop\n        if has_spilled:\n            break  # from outer loop\n    \n    if has_spilled:\n        # Memory budget exceeded. Subdivide the problem and recurse.\n        # This logical branch should not be reachable if len(prefix) == k\n        # because the set would contain at most 1 element, and B >= 1.\n        # The check is an assertion of this logic.\n        if len(prefix) >= k:\n             # This indicates a logical error or an invalid state (e.g., B=0).\n             # Given problem constraints B>=1, this is unreachable.\n             return 1\n             \n        sub_count = 0\n        for char in alphabet:\n            new_prefix = prefix + char\n            sub_count += _count_recursive(valid_substrings, k, B, new_prefix, alphabet)\n        return sub_count\n    else:\n        # Base case: Succeeded in counting k-mers for this partition within the budget.\n        return len(kmers_in_partition)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386106"}, {"introduction": "分治策略不仅限于处理大规模数据集，它同样是加速搜索和优化的强大工具。本练习将分治思想应用于一个具体的生物学问题：在DNA序列中寻找所有反向互补回文结构。你将学习如何利用二分搜索（一种经典的分治算法）来高效地确定每个可能中心点的最大回文半径，这展示了分治法如何作为复杂算法中的一个关键优化模块，显著提升计算效率 [@problem_id:2386095]。", "problem": "您的任务是设计并实现一个分治（D&C）算法，以在一个脱氧核糖核酸（DNA）染色体中找到所有逆相补回文子串。一个DNA染色体将被建模为一个由字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 构成的有限字符串。使用标准的碱基配对规则：$\\mathrm{A}$ 与 $\\mathrm{T}$ 配对，$\\mathrm{C}$ 与 $\\mathrm{G}$ 配对。对于任何DNA字符串 $s$，通过逐个字符应用这些配对规则来定义其互补链 $\\operatorname{comp}(s)$，并通过反转 $\\operatorname{comp}(s)$ 来定义其逆相补链 $\\operatorname{rc}(s)$。如果一个字符串 $w$ 满足 $w=\\operatorname{rc}(w)$，则它是一个逆相补回文。对于索引，使用基于 $0$ 的索引。对于一个子串 $s[i:j]$（包含 $i$ 且不包含 $j$），其长度为 $j-i$。\n\n从字符串子串和DNA互补规则的基本定义出发，并利用二分搜索是每次将搜索区间减半的经典分治策略这一公认事实，设计一个算法，该算法能够：\n- 预处理染色体，以在固定编码下实现常数时间的子串相等性查询。\n- 对每个潜在的回文中心，使用分治策略（对半径进行二分搜索）来找到最大半径，使得对应的子串等于其逆相补。\n- 枚举所有长度至少为 $k$ 的逆相补回文子串。\n\n该算法必须纯粹用数学和逻辑术语来构建，并且可用任何现代编程语言实现。不涉及任何生物湿实验步骤。所有答案均无单位。您必须将所有满足标准的子串以数对 $[i,\\ell]$ 的形式输出，其中 $i$ 是起始索引，$\\ell$ 是长度，且 $i$ 使用基于 $0$ 的索引。对于每个染色体，按 $i$ 的升序对数对进行排序，如果 $i$ 相等，则按 $\\ell$ 的升序排序。因为在标准的DNA碱基配对规则下，没有核苷酸是自身的互补，所以只可能存在偶数长度的逆相补回文；您的方法应通过回文性测试从第一性原理发现这一点，而不是依赖于硬编码的特例。\n\n您必须将该算法实现为一个单一、完整、可运行的程序，为以下测试套件生成结果。对每个案例，计算所有长度至少为 $k$ 的逆相补回文子串：\n\n- 测试用例 1：染色体 $s=\\text{\"ATCGAT\"}$，$k=4$。\n- 测试用例 2：染色体 $s=\\text{\"AAAAAA\"}$，$k=3$。\n- 测试用例 3：染色体 $s=\\text{\"CGAATTCG\"}$，$k=4$。\n- 测试用例 4：染色体 $s=\\text{\"AT\"}$，$k=2$。\n- 测试用例 5：染色体 $s=\\text{\"ATAT\"}$，$k=2$。\n\n最终输出格式：您的程序必须生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且其本身就是一个 $[i,\\ell]$ 数对的列表。例如，通用结构为 $[[[i_1,\\ell_1],[i_2,\\ell_2],\\dots],[],\\dots]$。输出行中不得有任何空格。", "solution": "问题在于设计并实现一种分治算法，用于在给定的脱氧核糖核酸（DNA）序列中，根据最小长度约束，识别所有逆相补回文子串。该问题定义明確，科学上根植于分子生物学和计算字符串分析的原理，并包含了获得唯一解所需的所有信息。\n\n首先，我们对定义进行形式化。DNA序列 $s$ 是一个由字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 构成的字符串。互补规则定义了一个函数 $c: \\Sigma \\to \\Sigma$，其中 $c(\\mathrm{A})=\\mathrm{T}$，$c(\\mathrm{T})=\\mathrm{A}$，$c(\\mathrm{C})=\\mathrm{G}$，以及 $c(\\mathrm{G})=\\mathrm{C}$。对于一个字符串 $s = s_0s_1\\dots s_{n-1}$，其互补链为 $\\operatorname{comp}(s) = c(s_0)c(s_1)\\dots c(s_{n-1})$，其反转链为 $\\operatorname{rev}(s) = s_{n-1}\\dots s_1s_0$。逆相补链定义为 $\\operatorname{rc}(s) = \\operatorname{rev}(\\operatorname{comp}(s))$。如果一个子串 $w$ 满足条件 $w = \\operatorname{rc}(w)$，则它是一个逆相补回文。我们的任务是，在给定的染色体 $s$ 中，找到所有长度（记为 $|w|$）至少为给定整数 $k$ 的此类子串 $w$。\n\n一个关键的观察，按要求从第一性原理推导，是关于这类回文串可能的长度。一个奇数长度的回文串 $w$，比如 $|w| = 2r+1$（对于某个整数 $r \\ge 0$），有一个中心字符 $w_r$。回文条件 $w = \\operatorname{rc}(w)$ 意味着对于所有 $i \\in \\{0, \\dots, 2r\\}$ 都有 $w_i = c(w_{2r-i})$。对于 $i=r$ 处的中心字符，这给出 $w_r = c(w_r)$。然而，对于标准的DNA碱基，没有一个碱基是自身的互补：对于任何 $x \\in \\Sigma$ 都有 $c(x) \\neq x$。因此，没有字符能满足中心条件，所以不存在奇数长度的逆相补回文。所有这类回文串必须具有偶数长度，即 $|w| = 2r$（对于 $r \\ge 1$）。\n\n偶数长度的回文以两个字符之间为中心。对于长度为 $N$ 的字符串 $s$，偶数长度回文有 $N-1$ 个可能的中心，位于索引 $i-1$ 和 $i$ 之间，其中 $i \\in \\{1, \\dots, N-1\\}$。对于一个给定的中心 $i$，一个半径为 $r \\ge 1$ 的回文是子串 $s[i-r : i+r]$，其长度为 $2r$。该子串成为逆相补回文的条件是，对于所有 $k \\in \\{1, \\dots, r\\}$，都有 $s[i-k] = c(s[i+k-1])$。\n\n指定算法的核心是一种分治策略。对于每个潜在的中心，我们必须找到回文属性成立的最大半径 $R_{max}$。然后，该中心的所有有效回文就是那些半径 $r \\in \\{1, \\dots, R_{max}\\}$ 的回文。回文属性是单调的：如果它对半径 $r$ 成立，那么它对任何更小的半径 $r' < r$ 也必然成立。这种结构允许使用二分搜索（一种经典的分治技术）来高效地找到 $R_{max}$。对于一个中心 $i$，半径 $r$ 的搜索空间是区间 $[0, \\min(i, N-i)]$。\n\n要高效地执行二分搜索，每次对回文属性的检查都必须在常数时间 $O(1)$ 内完成。对于半径 $r$，逐字符比较的朴素方法需要 $O(r)$ 时间，导致总复杂度为 $O(N^2)$。该问题要求通过预处理来实现 $O(1)$ 的子串相等性查询。多项式滚动哈希是实现此目的的标准方法。在中心 $i$ 处，半径为 $r$ 的回文条件 $s[i-k] = c(s[i+k-1])$（对于 $k=1, \\dots, r$）等价于字符串相等性 $s[i-r : i] = \\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$。\n\n为了使用哈希实现此检查，我们预先计算两个字符串的哈希值：原始字符串 $s$ 和其完整的逆相补链 $s_{rc} = \\operatorname{rc}(s)$。设 $|s| = N$。子串 $s[i-r:i]$ 是 $s$ 的一个简单子串。子串 $\\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$ 等价于 $s_{rc}$ 的一个特定子串。$s[i:i+r]$ 的逆相补对应于 $s_{rc}$ 中从索引 $N-(i+r)$ 开始、长度为 $r$ 的子串，即 $s_{rc}[N-i-r : N-i]$。因此，在中心 $i$ 处对半径 $r$ 的回文检查简化为比较 $s[i-r : i]$ 的哈希值与 $s_{rc}[N-i-r : N-i]$ 的哈希值。通过对 $s$ 和 $s_{rc}$ 进行预计算的前缀哈希，这种比较需要 $O(1)$ 时间。为了最小化哈希冲突，采用了一种双哈希方案，使用两对独立的基数和模数。\n\n完整的算法流程如下：\n1.  **预处理（$O(N)$ 时间）**：\n    a. 给定长度为 $N$ 的输入字符串 $s$。\n    b. 构建其逆相补链 $s_{rc}$。\n    c. 对 $s$ 和 $s_{rc}$，使用两个不同的（基数，模数）对，预先计算两组前缀哈希值和基数的幂。\n\n2.  **回文搜索（$O(N \\log N)$ 时间）**：\n    a. 初始化一个空列表 `results` 来存储找到的回文。\n    b. 遍历每个潜在的中心 $i \\in \\{1, \\dots, N-1\\}$。\n    c. 对于每个中心 $i$，确定最大可能半径 $r_{lim} = \\min(i, N-i)$。\n    d. 在半径 $r \\in [1, r_{lim}]$ 上执行二分搜索，以找到使得 $s[i-r:i]$ 和 $\\operatorname{rev}(\\operatorname{comp}(s[i:i+r]))$ 相等的最大半径 $R_{max}$。通过比较 $s[i-r:i]$ 和 $s_{rc}[N-i-r:N-i]$ 的双哈希值，此检查在 $O(1)$ 时间内完成。\n    e. 找到 $R_{max}$ 后，以 $i$ 为中心、半径从 $1$ 到 $R_{max}$ 的所有子串都是逆相补回文。它们的长度为 $2, 4, \\dots, 2R_{max}$。\n\n3.  **结果枚举与格式化**：\n    a. 对于每个中心 $i$ 及其找到的 $R_{max}$，遍历从 $\\lceil k/2 \\rceil$ 到 $R_{max}$ 的半径 $r$。对于每个这样的 $r$，就找到了一个有效的回文。其长度为 $\\ell = 2r$，起始索引为 $j = i-r$。将数对 $[j, \\ell]$ 添加到 `results` 列表中。\n    b. 遍历完所有中心后，按起始索引 $j$ 的升序对 `results` 列表进行排序，若 $j$ 相等，则按长度 $\\ell$ 排序。\n    c. 按规定格式化最终输出。\n\n该算法的总时间复杂度由搜索步骤主导，为 $O(N \\log N)$。空间复杂度为 $O(N)$，用于存储字符串及其哈希表。该方法符合问题陈述的所有要求。", "answer": "```python\nimport numpy as np\n\n# No scipy is used in this solution.\n\nclass DualStringHasher:\n    \"\"\"\n    Computes and provides rolling hashes for a string using two different\n    (base, modulus) pairs to minimize collisions.\n    \"\"\"\n    def __init__(self, s: str):\n        self.n = len(s)\n        self.p1, self.m1 = 31, 10**9 + 7\n        self.p2, self.m2 = 37, 10**9 + 9\n        \n        char_map = {'A': 1, 'C': 2, 'G': 3, 'T': 4}\n        # Using .get with a default value handles potential invalid characters\n        s_int = [char_map.get(c, 0) for c in s]\n\n        self.powers1 = [1] * (self.n + 1)\n        self.hashes1 = [0] * (self.n + 1)\n        self.powers2 = [1] * (self.n + 1)\n        self.hashes2 = [0] * (self.n + 1)\n\n        for i in range(self.n):\n            self.powers1[i+1] = (self.powers1[i] * self.p1) % self.m1\n            self.hashes1[i+1] = (self.hashes1[i] * self.p1 + s_int[i]) % self.m1\n            self.powers2[i+1] = (self.powers2[i] * self.p2) % self.m2\n            self.hashes2[i+1] = (self.hashes2[i] * self.p2 + s_int[i]) % self.m2\n\n    def get_hash_pair(self, i: int, j: int) -> tuple[int, int]:\n        \"\"\"\n        Returns the hash pair for the substring s[i:j].\n        \"\"\"\n        length = j - i\n        if length <= 0:\n            return (0, 0)\n        h1 = (self.hashes1[j] - (self.hashes1[i] * self.powers1[length]) % self.m1 + self.m1) % self.m1\n        h2 = (self.hashes2[j] - (self.hashes2[i] * self.powers2[length]) % self.m2 + self.m2) % self.m2\n        return (h1, h2)\n\ndef find_palindromes(s: str, k: int) -> list[list[int]]:\n    \"\"\"\n    Finds all reverse-complement palindromic substrings of length at least k.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return []\n\n    comp_map = str.maketrans(\"ACGT\", \"TGCA\")\n    s_comp = s.translate(comp_map)\n    s_rc = s_comp[::-1]\n\n    hasher_s = DualStringHasher(s)\n    hasher_rc = DualStringHasher(s_rc)\n    \n    results = []\n\n    # Iterate through all possible centers for even-length palindromes.\n    # Center is between index i-1 and i.\n    for i in range(1, n):\n        # Binary search for the maximum radius r.\n        low, high = 0, min(i, n - i)\n        max_r = 0\n        \n        while low <= high:\n            r = (low + high) // 2\n            if r == 0:\n                low = r + 1\n                continue\n\n            # Substring s[i-r:i]\n            hash1 = hasher_s.get_hash_pair(i - r, i)\n            # The reverse complement of s[i:i+r] is found in s_rc\n            # at index n-(i+r) with length r => s_rc[n-i-r : n-i]\n            hash2 = hasher_rc.get_hash_pair(n - i - r, n - i)\n\n            if hash1 == hash2:\n                max_r = r\n                low = r + 1\n            else:\n                high = r - 1\n        \n        # Collect all valid palindromes for this center\n        if max_r > 0:\n            # We need length 2r >= k, so r >= k/2\n            min_r_for_k = (k + 1) // 2\n            for r in range(min_r_for_k, max_r + 1):\n                start_index = i - r\n                length = 2 * r\n                results.append([start_index, length])\n    \n    # Sort results by start index, then by length\n    results.sort()\n    \n    return results\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n    test_cases = [\n        (\"ATCGAT\", 4),\n        (\"AAAAAA\", 3),\n        (\"CGAATTCG\", 4),\n        (\"AT\", 2),\n        (\"ATAT\", 2),\n    ]\n\n    all_results = []\n    for s, k in test_cases:\n        case_result = find_palindromes(s, k)\n        all_results.append(case_result)\n\n    # Format the output string exactly as required, with no spaces.\n    # str(all_results) would introduce spaces, so we build it manually.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2386095"}, {"introduction": "本练习作为一个进阶挑战，旨在探索分治策略与动态规划这两种强大算法思想之间的深刻联系。你将解决一个实际的分子生物学设计问题：为环状质粒优化聚合酶链式反应（PCR）的引物布局，以最小化扩增子之间的重叠。这个问题天然地导向一个寻找最优路径的解法，通过采用带记忆化的递归实现，你将发现其与分治法的共通之处，从而深化对复杂优化问题解决策略的理解 [@problem_id:2386122]。", "problem": "给定一个环状脱氧核糖核酸（DNA）质粒，你可以在位置 $0$ 将其线性化，从而得到一个长度为 $N$、基于字母表 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 的线性序列 $S$。你需要设计一个分治算法，在满足具有生物学背景的引物有效性约束的条件下，选择一系列聚合酶链式反应（PCR）扩增子，以最小的总重叠覆盖从位置 $0$ 到 $N-1$ 的整个线性化序列。\n\n引物是长度固定为 $k_p$（单位为核苷酸）的连续子序列。如果 $k_p$-mer $S[p:p+k_p]$ 满足以下所有条件，则位置 $p$ 为一个有效的引物起始点：\n1. 鸟嘌呤/胞嘧啶（GC）含量，定义为 $(\\#\\text{G}+\\#\\text{C})/k_p$，位于闭区间 $[g\\_{\\min}, g\\_{\\max}]$ 内。\n2. 根据 Wallace 法则计算的解链温度 $T_m$，定义为 $T_m = 2(\\#\\text{A}+\\#\\text{T}) + 4(\\#\\text{G}+\\#\\text{C})$，位于闭区间 $[t\\_{\\min}, t\\_{\\max}]$ 内，单位为摄氏度（所有内部温度计算均以摄氏度为单位）。\n3. 该 $k_p$-mer 中的最大同聚物运行长度（即相同连续核苷酸的最大数量）最多为 $h\\_{\\max}$。\n\n我们定义两组有效的引物起始点：有效正向引物起始点集合 $F$ 和有效反向引物起始点集合 $R$。在这个计算模型中，对 $R$ 的有效性验证使用与 $F$ 相同的标准并作用于同一序列 $S$。这在科学上是合理的，因为 GC 含量、同聚物运行以及基于 Wallace 法则的解链温度在反向互补操作下保持不变。\n\n一个扩增子由一对 $(a,b)$ 定义，其中 $a \\in F$，$b \\in R$ 且 $a < b$。它覆盖的索引范围为 $[a, b + k_p - 1]$（含边界）。其核苷酸长度为 $L = (b + k_p) - a$。只有长度 $L$ 位于闭区间 $[A\\_{\\min}, A\\_{\\max}]$ 内的扩增子才被允许。\n\n一个扩增子覆盖集是一个有序列表 $((a\\_1,b\\_1), \\dots, (a\\_m,b\\_m))$，满足：\n- $a\\_1 = 0$ 且 $b\\_m = N - k_p$，\n- 对每个 $i \\in \\{1, \\dots, m-1\\}$，下一个扩增子的起始位置不晚于当前扩增子的结束位置，即 $a\\_{i+1} \\le b\\_i + k\\_p$，并且是严格前进的，即 $a\\_{i+1} \\ge a\\_i + 1$（无停滞），\n- 每个 $L\\_i = (b\\_i + k\\_p) - a\\_i$ 均位于 $[A\\_{\\min}, A\\_{\\max}]$ 内。\n\n连续扩增子 $i$ 和 $i+1$ 之间的重叠定义为 $\\max\\{0, (b\\_i + k\\_p) - a\\_{i+1}\\}$。目标是最小化总重叠，即所有连续扩增子对的重叠之和。\n\n你的任务是实现一个分治算法，该算法在给定序列 $S$ 和相关参数后，计算出能够实现最小总重叠的扩增子覆盖集，并输出其正向引物起始位置的列表 $(a\\_1, a\\_2, \\dots, a\\_m)$。如果存在多个最优解，返回字典序最小的正向引物起始位置列表。如果不存在有效的覆盖集，则返回空列表。\n\n程序必须是自包含的，并且仅依赖于给定的参数和下文的测试序列。所有内部温度计算必须以摄氏度为单位；输出中不需要其他物理单位或角度。最终输出是整数列表（正向引物起始位置），每个测试用例对应一个列表。\n\n测试套件：\n- 用例 1：\n  - $S =$ 将字符串 $\\text{ATGC}$ 重复恰好 $30$ 次形成的字符串，因此 $N = 120$。\n  - $k\\_p = 8$。\n  - $g\\_{\\min} = 0.5$, $g\\_{\\max} = 0.5$。\n  - $t\\_{\\min} = 24$, $t\\_{\\max} = 24$。\n  - $h\\_{\\max} = 3$。\n  - $A\\_{\\min} = 40$, $A\\_{\\max} = 40$。\n- 用例 2：\n  - $S =$ 将 $\\text{ATGC}$ 重复 $15$ 次，然后是 $\\text{AAAAAA}$，再然后是 $\\text{ATGC}$ 重复 $5$ 次，三者串联而成。这得到 $N = 86$。\n  - $k\\_p = 8$。\n  - $g\\_{\\min} = 0.5$, $g\\_{\\max} = 0.5$。\n  - $t\\_{\\min} = 24$, $t\\_{\\max} = 24$。\n  - $h\\_{\\max} = 2$。\n  - $A\\_{\\min} = 28$, $A\\_{\\max} = 32$。\n- 用例 3：\n  - $S =$ 由 $\\text{A}$ 重复 $26$ 次组成的字符串，因此 $N = 26$。\n  - $k\\_p = 8$。\n  - $g\\_{\\min} = 0.5$, $g\\_{\\max} = 0.6$。\n  - $t\\_{\\min} = 20$, $t\\_{\\max} = 40$。\n  - $h\\_{\\max} = 2$。\n  - $A\\_{\\min} = 24$, $A\\_{\\max} = 30$。\n\n最终输出格式：\n你的程序应生成单行文本，其中包含所有用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个用例的结果本身也是一个由方括号括起来的整数列表（可能为空）。例如，一个有效的格式是 [[0,40,80],[0,29,58],[]]。\n\n你的程序必须计算并以这种确切的单行格式输出测试套件中三个用例的最优正向引物起始位置列表。不应打印任何其他文本。", "solution": "用户提出了一个计算生物学问题，要求设计一个分治算法，以找到一个最优的 PCR 扩增子集合来覆盖一个线性 DNA 序列。最优性定义为在满足一系列生化和物理约束的条件下，最小化连续扩增子之间的总重叠。\n\n在继续之前，需要对问题陈述进行严格验证。\n\n### 步骤 1：提取给定信息\n- **序列：** 一个长度为 $N$ 的线性 DNA 序列 $S$，字母表为 $\\{\\text{A, C, G, T}\\}$。\n- **引物长度：** 一个固定的整数 $k_p$。\n- **引物有效性约束：** 一个从位置 $p$ 开始的引物（即 $k_p$-mer $S[p:p+k_p]$）是有效的，如果：\n    1.  其鸟嘌呤-胞嘧啶（GC）含量在 $[g_{\\min}, g_{\\max}]$ 范围内。\n    2.  其解链温度 $T_m = 2(\\#\\text{A}+\\#\\text{T}) + 4(\\#\\text{G}+\\#\\text{C})$ 在 $[t_{\\min}, t_{\\max}]$ 范围内。\n    3.  其最大同聚物运行长度最多为 $h_{\\max}$。\n- **引物集合：** $F$（正向引物起始点）和 $R$（反向引物起始点）是引物有效的起始位置集合。问题陈述表明两者使用相同的有效性标准，这对于给定的指标在科学上是合理的。\n- **扩增子定义：** 扩增子是一对 $(a, b)$，其中 $a \\in F$，$b \\in R$，$a < b$。它跨越的索引范围是 $[a, b+k_p-1]$。其长度 $L = (b+k_p)-a$ 必须在 $[A_{\\min}, A_{\\max}]$ 范围内。\n- **覆盖集：** 一个有序的扩增子列表 $((a_1, b_1), \\dots, (a_m, b_m))$ 必须满足：\n    1.  $a_1 = 0$ 且 $b_m = N-k_p$。\n    2.  连续的扩增子必须连接并前进：$a_{i+1} \\in [a_i+1, b_i+k_p]$。\n- **目标：** 最小化总重叠，定义为 $\\sum_{i=1}^{m-1} \\max\\{0, (b_i+k_p) - a_{i+1}\\}$。\n- **输出：** 正向引物起始位置的列表 $(a_1, \\dots, a_m)$。\n- **平局打破规则：** 如果有多个解具有相同的最小重叠，则返回字典序最小的正向引物起始列表。\n- **无解情况：** 如果不存在有效的覆盖，返回一个空列表。\n- **算法约束：** 算法必须是“分治”策略。\n\n### 步骤 2：使用提取的信息进行验证\n1.  **科学依据：** 该问题在分子生物学概念上基础扎实。PCR、引物、扩增子、GC 含量、解链温度（通过 Wallace 法则）和同聚物约束是引物设计的基础。该模型是一种简化，但对于一个计算问题来说，它在科学上是合理的。\n2.  **良定性与完整性：** 该问题在数学上是良定的。它明确了输入、所有约束、一个清晰的目标函数，以及平局打破和无解情况的规则。这是一个经典的优化问题，可以建模为在有向无环图（DAG）上寻找最短路径。\n3.  **算法约束分析：** 问题要求使用“分治”（D&C）算法。这种问题结构——寻找最小化成本总和的最优路径——通常用动态规划（DP）来解决。标准的 D&C 算法依赖于解决不重叠的子问题，但这并不自然适用，因为一个子问题（例如，覆盖序列的一个片段）的最优解依赖于其边界状态，这破坏了子问题的独立性。然而，动态规划可以被看作是分治法的一种扩展，它使用记忆化或制表法来处理重叠的子问题。一个 DP 解的递归、记忆化实现直接遵循了 D&C 的结构。因此，将该指令解释为允许使用动态规划解法是合理且正确的。我们将继续采用 DP 解法，这符合“分治”指令的精神。\n\n### 步骤 3：结论与行动\n该问题是有效的。它具有科学依据、良定性，并提供了所有必要的信息。我们将基于动态规划来构建解决方案。\n\n### 解决方案设计\n该问题可以建模为在有向无环图（DAG）中寻找最短路径。图的节点是有效的正向引物起始位置。如果从 $u$ 开始的一个有效扩增子可以覆盖序列至 $v$ 或超过 $v$，从而允许一个新的扩增子在 $v$ 开始，则存在一条从节点 $u$ 到节点 $v$ 的边。边的权重是重叠量。\n\n**1. 预计算有效引物位点**\n首先，我们识别出所有在 $[0, N-k_p]$ 范围内可以作为有效引物起始点的位置 $p$。我们定义一个函数 `is_valid_primer`，用于检查给定 $k_p$-mer 的 GC 含量、解链温度和同聚物运行约束。我们遍历 $S$ 中所有可能的起始位置，并构建一个这些有效位点的排序列表，记为 $P_{\\text{valid}}$。如果 $0 \\notin P_{\\text{valid}}$ 或 $N-k_p \\notin P_{\\text{valid}}$，则不可能有解。\n\n**2. 动态规划公式**\n我们将使用动态规划来寻找总重叠最小的路径。设 $C[v]$ 为用一系列扩增子覆盖序列所需的最小总重叠，其中最后一个正向引物起始于 $v \\in P_{\\text{valid}}$。设 $\\Pi[v]$ 存储相应的正向引物起始位置列表 $(a_1, \\dots, a_k=v)$。\n\n- **初始化：**\n  对于起始于位置 $a_1=0$ 的引物：\n  - $C[0] = 0$\n  - $\\Pi[0] = [0]$\n  对于所有其他 $v \\in P_{\\text{valid}}$，$v>0$：\n  - $C[v] = \\infty$\n  - $\\Pi[v] = []$\n\n- **递推关系：**\n  我们按递增顺序遍历有效引物位点 $u \\in P_{\\text{valid}}$。对于每个我们已找到有效路径的 $u$（即 $C[u] < \\infty$），我们探索所有可能的下一个正向引物 $v \\in P_{\\text{valid}}$，其中 $v > u$。\n  对于每一对 $(u, v)$，我们必须计算一次转移的最小可能重叠。这需要选择一个反向引物 $b \\in P_{\\text{valid}}$ 来形成扩增子 $(u, b)$，使得：\n  1. 扩增子是有效的：其长度 $L=(b+k_p)-u$ 在 $[A_{\\min}, A_{\\max}]$ 内。\n  2. 下一个引物起始点 $v$ 是可达的：$u < v \\le b+k_p$。\n  为了最小化从 $u$ 到 $v$ 的转移重叠，即 $(b+k_p)-v$，我们必须选择满足所有约束的最小有效 $b$。\n  \n  对于从 $u$ 到 $v$ 的转移，对 $b$ 的约束是：\n  - $b \\in P_{\\text{valid}}$\n  - $b > u$\n  - 来自扩增子长度：$u+A_{\\min}-k_p \\le b \\le u+A_{\\max}-k_p$\n  - 来自 $v$ 的可达性：$b \\ge v-k_p$\n\n  令 $b^*$ 为 $P_{\\text{valid}}$ 中满足这些条件的最小值。如果存在这样的 $b^*$，则重叠为 $\\text{cost}(u,v) = (b^*+k_p) - v$。通过 $u$ 到达 $v$ 的总成本为 $C_{\\text{new}} = C[u] + \\text{cost}(u,v)$，新路径为 $\\Pi_{\\text{new}} = \\Pi[u] + [v]$。\n\n- **带平局打破规则的更新步骤：**\n  如果新路径更优，我们更新 $v$ 的条目。如果一个路径的成本更低，或者成本相同但字典序更小，则该路径更优。\n  $$ \\text{if } (C_{\\text{new}} < C[v]) \\text{ or } (C_{\\text{new}} == C[v] \\text{ and } \\Pi_{\\text{new}} < \\Pi[v]): $$\n  $$ \\quad C[v] = C_{\\text{new}} $$\n  $$ \\quad \\Pi[v] = \\Pi_{\\text{new}} $$\n\n**3. 最终解的重构**\n在计算完所有可达节点的成本和路径之后，我们必须确定完整的最佳路径。一个有效的覆盖必须以扩增子 $(a_m, b_m)$ 结尾，其中 $b_m = N-k_p$。最后一个正向引物 $a_m$ 必须满足：\n1. $a_m \\in P_{\\text{valid}}$\n2. 扩增子 $(a_m, N-k_p)$ 是有效的。其长度必须在 $[A_{\\min}, A_{\\max}]$ 内，这意味着 $N-A_{\\max} \\le a_m \\le N-A_{\\min}$。\n\n我们找到所有存在路径（$C[a_m] < \\infty$）的此类有效终点位置 $a_m$。在这些候选者中，我们选择对应于最小总重叠 $C[a_m]$ 的那一个。如果成本出现平局，我们选择其路径 $\\Pi[a_m]$ 字典序最小的候选者。如果无法到达任何此类有效的终点位置，则解不存在。\n\n这种 DP 方法系统地探索了所有有效的扩增子链，并保证能根据指定标准找到最优解。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"S\": \"ATGC\" * 30, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.5,\n            \"t_min\": 24, \"t_max\": 24, \"h_max\": 3, \"A_min\": 40, \"A_max\": 40\n        },\n        # Case 2\n        {\n            \"S\": \"ATGC\" * 15 + \"AAAAAA\" + \"ATGC\" * 5, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.5,\n            \"t_min\": 24, \"t_max\": 24, \"h_max\": 2, \"A_min\": 28, \"A_max\": 32\n        },\n        # Case 3\n        {\n            \"S\": \"A\" * 26, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.6,\n            \"t_min\": 20, \"t_max\": 40, \"h_max\": 2, \"A_min\": 24, \"A_max\": 30\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = find_optimal_covering(**params)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[0,40,80],[0,28,56],[]]\n    result_strs = []\n    for res in results:\n        result_strs.append('[' + ','.join(map(str, res)) + ']')\n    \n    print(f\"[{','.join(result_strs)}]\")\n\ndef get_homopolymer_run(seq):\n    \"\"\"Calculates the maximum length of a homopolymer run in a sequence.\"\"\"\n    if not seq:\n        return 0\n    max_run = 0\n    current_run = 0\n    current_char = ''\n    for char in seq:\n        if char == current_char:\n            current_run += 1\n        else:\n            max_run = max(max_run, current_run)\n            current_char = char\n            current_run = 1\n    max_run = max(max_run, current_run)\n    return max_run\n\ndef is_valid_primer(subsequence, k_p, g_min, g_max, t_min, t_max, h_max):\n    \"\"\"Checks if a given k-mer subsequence is a valid primer.\"\"\"\n    gc_count = subsequence.count('G') + subsequence.count('C')\n    gc_frac = gc_count / k_p\n    if not (g_min <= gc_frac <= g_max):\n        return False\n    \n    at_count = k_p - gc_count\n    tm = 2 * at_count + 4 * gc_count\n    if not (t_min <= tm <= t_max):\n        return False\n        \n    hp_run = get_homopolymer_run(subsequence)\n    if hp_run > h_max:\n        return False\n        \n    return True\n\ndef find_optimal_covering(S, k_p, g_min, g_max, t_min, t_max, h_max, A_min, A_max):\n    \"\"\"\n    Implements the dynamic programming algorithm to find the optimal amplicon covering.\n    \"\"\"\n    N = len(S)\n    \n    # Step 1: Pre-compute valid primer sites\n    valid_sites = []\n    for p in range(N - k_p + 1):\n        sub = S[p : p + k_p]\n        if is_valid_primer(sub, k_p, g_min, g_max, t_min, t_max, h_max):\n            valid_sites.append(p)\n    \n    valid_sites_set = set(valid_sites)\n    \n    # Check if start and end conditions are even possible\n    if 0 not in valid_sites_set or (N - k_p) not in valid_sites_set:\n        return []\n\n    # Step 2: Dynamic Programming\n    costs = {p: float('inf') for p in valid_sites}\n    paths = {p: [] for p in valid_sites}\n    \n    costs[0] = 0\n    paths[0] = [0]\n    \n    # Main DP loop\n    for u in valid_sites:\n        if costs[u] == float('inf'):\n            continue\n            \n        # Iterate over all possible next forward primers v\n        # Find start index for v > u\n        v_start_idx = np.searchsorted(valid_sites, u, side='right')\n        for v in valid_sites[v_start_idx:]:\n            # Calculate minimum overlap for transition u -> v\n            # Find the best reverse primer b*\n            b_min_req = max(u + 1, u + A_min - k_p, v - k_p)\n            b_max_req = u + A_max - k_p\n            \n            # Find smallest b in valid_sites within [b_min_req, b_max_req]\n            b_start_idx = np.searchsorted(valid_sites, b_min_req, side='left')\n            \n            if b_start_idx < len(valid_sites):\n                b_star = valid_sites[b_start_idx]\n                if b_star <= b_max_req:\n                    overlap = (b_star + k_p) - v\n                    new_cost = costs[u] + overlap\n                    new_path = paths[u] + [v]\n                    \n                    # Update DP table if a better path is found (cost or lexicographical)\n                    if new_cost < costs[v] or (new_cost == costs[v] and new_path < paths[v]):\n                        costs[v] = new_cost\n                        paths[v] = new_path\n\n    # Step 3: Reconstruct final solution\n    best_final_path = []\n    min_final_cost = float('inf')\n    \n    # Find all valid candidates for the last forward primer a_m\n    b_m = N - k_p\n    a_m_min = N - A_max\n    a_m_max = N - A_min\n    \n    final_candidates = []\n    for a_m in valid_sites:\n        if a_m_min <= a_m <= a_m_max and a_m < b_m and costs[a_m] != float('inf'):\n            final_candidates.append(a_m)\n\n    if not final_candidates:\n        return []\n\n    # Find the minimum cost among all valid final paths\n    for a_m in final_candidates:\n        min_final_cost = min(min_final_cost, costs[a_m])\n\n    if min_final_cost == float('inf'):\n        return []\n    \n    # Among all paths with minimum cost, find the lexicographically smallest one\n    best_paths_for_min_cost = []\n    for a_m in final_candidates:\n        if costs[a_m] == min_final_cost:\n            best_paths_for_min_cost.append(paths[a_m])\n\n    return min(best_paths_for_min_cost)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2386122"}]}