{"hands_on_practices": [{"introduction": "此练习旨在通过一个直观的几何例子来巩固准凸性的核心定义。我们将分析一个基于两点最短距离的函数，并观察其水平集如何因集合的并运算而丧失凸性。通过这个练习，你将对水平集在判断函数准凸性中的关键作用建立起牢固的直观认识。[@problem_id:3170729]", "problem": "设 $n \\ge 2$ 且 $a,b \\in \\mathbb{R}^n$，$a \\ne b$。考虑函数 $f : \\mathbb{R}^n \\to \\mathbb{R}$，定义为 $f(x) = \\min\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\}$，其中 $\\| \\cdot \\|_2$ 表示欧几里得范数。回顾以下基本定义。以 $c \\in \\mathbb{R}^n$ 为中心、半径为 $r \\ge 0$ 的闭欧几里得球是 $B(c,r) := \\{ x \\in \\mathbb{R}^n \\mid \\|x-c\\|_2 \\le r \\}$。一个集合 $C \\subseteq \\mathbb{R}^n$ 是凸的，如果对于所有 $x,y \\in C$ 和所有 $\\lambda \\in [0,1]$，点 $\\lambda x + (1-\\lambda) y$ 都属于 $C$。一个函数 $h : \\mathbb{R}^n \\to \\mathbb{R}$ 是准凸的，如果对于每个 $t \\in \\mathbb{R}$，其下水平集 $\\{ x \\in \\mathbb{R}^n \\mid h(x) \\le t \\}$ 是凸的。\n\n仅使用这些定义，分析 $f$ 的下水平集和上水平集的几何性质，并判断哪些陈述是正确的。选择所有适用的选项。\n\nA. 对于任何 $t \\ge 0$，下水平集 $\\{ x \\in \\mathbb{R}^n \\mid f(x) \\le t \\}$ 等于 $B(a,t) \\cup B(b,t)$。\n\nB. 如果 $a \\ne b$，那么对于每个 $t > 0$，集合 $\\{ x \\in \\mathbb{R}^n \\mid f(x) \\le t \\}$ 是非凸的。\n\nC. 当 $a \\ne b$ 时，函数 $f$ 在 $\\mathbb{R}^n$ 上是准凸的。\n\nD. 对于所有 $t \\ge 0$，上水平集 $\\{ x \\in \\mathbb{R}^n \\mid f(x) \\ge t \\}$ 是凸的。\n\nE. 函数 $g(x) = \\max\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\}$ 的下水平集是凸的，因此是准凸的。", "solution": "问题陈述已经过验证，是自洽的、数学上合理的、定义明确的。所有定义和条件在优化和分析中都是标准的。\n\n给定函数 $f(x) = \\min\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\}$，其中 $a,b \\in \\mathbb{R}^n$，$a \\ne b$ 且 $n \\ge 2$。我们将根据所提供的定义来分析每个陈述。\n\n**评估选项A**\n\n陈述是：对于任何 $t \\ge 0$，下水平集 $\\{ x \\in \\mathbb{R}^n \\mid f(x) \\le t \\}$ 等于 $B(a,t) \\cup B(b,t)$。\n\n令 $S_t = \\{ x \\in \\mathbb{R}^n \\mid f(x) \\le t \\}$。根据 $f$ 的定义，这即是 $S_t = \\{ x \\in \\mathbb{R}^n \\mid \\min\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\} \\le t \\}$。\n两个非负数的最小值小于或等于 $t$ 的充要条件是这两个数中至少有一个小于或等于 $t$。\n因此，条件 $\\min\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\} \\le t$ 等价于条件 $(\\|x-a\\|_2 \\le t)$ 或 $(\\|x-b\\|_2 \\le t)$。\n满足 $\\|x-a\\|_2 \\le t$ 的点集，根据定义，是闭球 $B(a,t)$。\n满足 $\\|x-b\\|_2 \\le t$ 的点集是闭球 $B(b,t)$。\n因此，$S_t = \\{ x \\in \\mathbb{R}^n \\mid \\|x-a\\|_2 \\le t \\} \\cup \\{ x \\in \\mathbb{R}^n \\mid \\|x-b\\|_2 \\le t \\} = B(a,t) \\cup B(b,t)$。\n条件 $t \\ge 0$ 与范数的非负性是一致的。\n\n结论：**正确**。\n\n**评估选项B**\n\n陈述是：如果 $a \\ne b$，那么对于每个 $t > 0$，集合 $\\{ x \\in \\mathbb{R}^n \\mid f(x) \\le t \\}$ 是非凸的。\n\n根据选项A，这个集合是 $S = B(a,t) \\cup B(b,t)$。由于 $a \\ne b$ 且两个球的半径相同，一个球不可能包含另一个球。两个不同球的并集，当一个不包含另一个时，不是凸集。我们可以构造一个反例来正式证明这一点。\n由于 $a \\ne b$，向量 $a-b$ 非零。由于 $n \\ge 2$，存在一个非零向量 $u \\in \\mathbb{R}^n$ 与 $a-b$ 正交，即 $u \\cdot (a-b) = 0$。我们可以将 $u$ 单位化，使得 $\\|u\\|_2 = 1$。\n令 $p = a + t u$。那么 $\\|p-a\\|_2 = \\|tu\\|_2 = t\\|u\\|_2 = t$。所以 $p \\in B(a,t)$，因此 $p \\in S$。\n令 $q = b + t u$。那么 $\\|q-b\\|_2 = \\|tu\\|_2 = t\\|u\\|_2 = t$。所以 $q \\in B(b,t)$，因此 $q \\in S$。\n现在考虑线段 $[p,q]$ 的中点，即 $m = \\frac{1}{2}p + \\frac{1}{2}q = \\frac{1}{2}(a+b) + tu$。\n为了证明 $S$ 是非凸的，我们必须证明 $m \\notin S$。这需要证明 $m \\notin B(a,t)$ 且 $m \\notin B(b,t)$。\n我们来计算 $m$ 到 $a$ 的距离：\n$m - a = \\frac{1}{2}(b-a) + tu$。\n由于 $u$ 与 $b-a$ 正交，我们可以使用勾股定理：\n$\\|m-a\\|_2^2 = \\|\\frac{1}{2}(b-a)\\|_2^2 + \\|tu\\|_2^2 = (\\frac{1}{2}\\|b-a\\|_2)^2 + (t\\|u\\|_2)^2 = (\\frac{\\|a-b\\|_2}{2})^2 + t^2$。\n令 $d = \\|a-b\\|_2$。由于 $a \\ne b$，所以 $d>0$。\n$\\|m-a\\|_2^2 = (d/2)^2 + t^2$。由于 $d>0$ 且 $t>0$，我们有 $(d/2)^2 > 0$，所以 $\\|m-a\\|_2^2 > t^2$。这意味着 $\\|m-a\\|_2 > t$，所以 $m \\notin B(a,t)$。\n类似地，我们来计算 $m$ 到 $b$ 的距离：\n$m - b = \\frac{1}{2}(a-b) + tu$。\n$\\|m-b\\|_2^2 = \\|\\frac{1}{2}(a-b)\\|_2^2 + \\|tu\\|_2^2 = (d/2)^2 + t^2 > t^2$。这意味着 $\\|m-b\\|_2 > t$，所以 $m \\notin B(b,t)$。\n由于 $m$ 不在任何一个球内，所以 $m \\notin B(a,t) \\cup B(b,t)$。我们找到了集合中的两个点 $p, q$，它们的中点不在该集合中。这个构造对于任何 $t>0$ 都有效。因此，对于任何 $t > 0$，该集合都是非凸的。\n\n结论：**正确**。\n\n**评估选项C**\n\n陈述是：当 $a \\ne b$ 时，函数 $f$ 在 $\\mathbb{R}^n$ 上是准凸的。\n\n一个函数是准凸的，当且仅当其所有的下水平集都是凸的。\n$f$ 的下水平集形如 $\\{ x \\in \\mathbb{R}^n \\mid f(x) \\le t \\}$，其中 $t \\in \\mathbb{R}$。\n如果我们选择任何 $t > 0$，选项B的分析表明其下水平集是非凸的。\n对于 $t=0$，水平集是 $\\{x \\in \\mathbb{R}^n \\mid \\min\\{\\|x-a\\|_2, \\|x-b\\|_2\\} = 0 \\}$，也就是集合 $\\{a, b\\}$。由于 $a \\ne b$，这个由两个点组成的集合不是凸的。\n由于存在至少一个 $t$ 值（实际上是任何 $t \\ge 0$）使得下水平集不是凸的，根据定义，函数 $f$ 不是准凸的。\n\n结论：**不正确**。\n\n**评估选项D**\n\n陈述是：对于所有 $t \\ge 0$，上水平集 $\\{ x \\in \\mathbb{R}^n \\mid f(x) \\ge t \\}$ 是凸的。\n\n令 $U_t = \\{ x \\in \\mathbb{R}^n \\mid f(x) \\ge t \\}$。这等价于 $\\{ x \\in \\mathbb{R}^n \\mid \\min\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\} \\ge t \\}$。\n两个数的最小值大于或等于 $t$ 的充要条件是这两个数都大于或等于 $t$。\n所以，$U_t = \\{ x \\in \\mathbb{R}^n \\mid \\|x-a\\|_2 \\ge t \\text{ 且 } \\|x-b\\|_2 \\ge t \\}$。\n这个集合是两个集合的交集，每个集合都是一个闭球的补集。\n为了反驳这个陈述，我们需要找到一个 $t \\ge 0$ 的值，使得 $U_t$ 不是凸的。\n令 $d = \\|a-b\\|_2 > 0$。我们选择 $t$ 使得 $t > d/2$。例如，取 $t=d$。\n令 $p, q \\in U_t$。我们检查它们的中点是否在 $U_t$ 中。\n令 $u$ 是一个与 $a-b$ 正交的单位向量，因为 $n \\ge 2$ 所以它存在。\n令 $m = (a+b)/2$。\n考虑点 $p = m + Ru$ 和 $q = m - Ru$，其中 $R>0$ 是一个大的标量。\n如选项B的分析所示，$\\|p-a\\|_2 = \\|p-b\\|_2 = \\sqrt{(d/2)^2 + R^2}$。\n为确保 $p, q \\in U_t$，我们需要 $\\sqrt{(d/2)^2 + R^2} \\ge t$，如果我们选择足够大的 $R$（例如 $R \\ge t$），这是成立的。\n现在考虑 $[p,q]$ 的中点，即 $m = (a+b)/2$。\n我们必须检查 $m \\in U_t$ 是否成立。这要求 $\\|m-a\\|_2 \\ge t$ 且 $\\|m-b\\|_2 \\ge t$。\n$\\|m-a\\|_2 = \\|\\frac{1}{2}(b-a)\\|_2 = d/2$。\n$\\|m-b\\|_2 = \\|\\frac{1}{2}(a-b)\\|_2 = d/2$。\n我们选择的 $t$ 是 $t > d/2$。因此，$\\|m-a\\|_2 < t$ 且 $\\|m-b\\|_2 < t$。$m$ 属于 $U_t$ 的条件没有满足。\n所以，对于任何 $t > d/2$，我们可以找到点 $p, q \\in U_t$，它们的中点 $m$ 不在 $U_t$ 中。因此，对于 $t > \\|a-b\\|_2/2$，上水平集是非凸的。该陈述声称对所有 $t \\ge 0$ 都是凸的，这是错误的。\n\n结论：**不正确**。\n\n**评估选项E**\n\n陈述是：函数 $g(x) = \\max\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\}$ 的下水平集是凸的，因此是准凸的。\n\n我们来分析 $g(x)$ 的下水平集。\n令 $L_t = \\{ x \\in \\mathbb{R}^n \\mid g(x) \\le t \\} = \\{ x \\in \\mathbb{R}^n \\mid \\max\\{ \\|x-a\\|_2, \\|x-b\\|_2 \\} \\le t \\}$。\n两个数的最大值小于或等于 $t$ 的充要条件是这两个数都小于或等于 $t$。\n所以，$L_t = \\{ x \\in \\mathbb{R}^n \\mid \\|x-a\\|_2 \\le t \\text{ 且 } \\|x-b\\|_2 \\le t \\}$。\n这是点 $x$ 的集合，这些点既在球 $B(a,t)$ 内，也在球 $B(b,t)$ 内。\n因此，$L_t = B(a,t) \\cap B(b,t)$。\n一个闭球 $B(c,r)$ 是一个凸集。这可以用三角不等式来证明：对于任何 $x,y \\in B(c,r)$ 和 $\\lambda \\in [0,1]$，令 $z = \\lambda x + (1-\\lambda)y$。那么 $\\|z-c\\|_2 = \\|\\lambda(x-c) + (1-\\lambda)(y-c)\\|_2 \\le \\lambda\\|x-c\\|_2 + (1-\\lambda)\\|y-c\\|_2 \\le \\lambda r + (1-\\lambda)r = r$。因此 $z \\in B(c,r)$。\n凸集的一个基本性质是它们的交集也是一个凸集。由于 $B(a,t)$ 和 $B(b,t)$ 都是凸集，它们的交集 $L_t = B(a,t) \\cap B(b,t)$ 也是一个凸集。\n这对任何 $t \\in \\mathbb{R}$ 都成立。如果 $t < 0$，$L_t$ 是空集，空集是凸的。如果 $t \\ge 0$，上述论证成立。\n由于 $g(x)$ 的所有下水平集都是凸的，根据问题中提供的定义，函数 $g(x)$ 是准凸的。\n\n结论：**正确**。", "answer": "$$\\boxed{A, B, E}$$", "id": "3170729"}, {"introduction": "凸函数的一个重要特性是其在求和运算下保持封闭，但准凸函数却不具备这一特性。本练习将引导你构建一个简单而有力的反例，以揭示这一关键差异。通过分析函数和的水平集结构，你将更深刻地理解准凸性与凸性之间的细微区别。[@problem_id:3170821]", "problem": "设 $f:\\mathbb{R}\\to\\mathbb{R}$ 和 $g:\\mathbb{R}\\to\\mathbb{R}$ 定义为\n$$\nf(x)=\\begin{cases}\n0,  x\\in[-3,-2],\\\\\n1,  \\text{其他情况},\n\\end{cases}\n\\qquad\ng(x)=\\begin{cases}\n0,  x\\in[2,3],\\\\\n1,  \\text{其他情况}。\n\\end{cases}\n$$\n回顾一下，一个函数 $h:\\mathbb{R}^{n}\\to\\mathbb{R}$ 是准凸的，当且仅当它的每个下水平集 $S_{h}(\\alpha):=\\{x\\in\\mathbb{R}^{n}:\\ h(x)\\le \\alpha\\}$ 都是凸集。\n\n仅使用此定义和集合运算的基本原理，完成以下任务：\n- 证明 $f$ 和 $g$ 在 $\\mathbb{R}$ 上是准凸的。\n- 定义 $h:=f+g$。给出一个值 $\\alpha\\in\\mathbb{R}$，使得其下水平集 $S_{h}(\\alpha)$ 不是凸集，从而证明 $h$ 不是准凸的。\n- 推导恒等式\n$$\nS_{f+g}(t)\\;=\\;\\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big),\n$$\n并解释为什么即使所有 $S_{f}(\\alpha)$ 和 $S_{g}(\\beta)$ 都是凸集，等式右侧也可能不是凸集。在你的解释中，将这种交集的并集结构与上镜图的闵可夫斯基和的水平切片所产生的集合的闵可夫斯基加法进行对比，以阐明为什么 $f+g$ 的非凸下水平集会出现。\n- 令\n$$\nt_{\\star}\\;:=\\;\\inf\\{\\,t\\in\\mathbb{R}:\\ S_{h}(t)\\ \\text{是凸集且非空}\\,\\}。\n$$\n以精确形式计算 $t_{\\star}$。你的最终答案必须是一个实数；不需要四舍五入。", "solution": "该问题在凸分析领域内被验证为自洽、有科学依据且定义明确。\n\n首先，我们证明函数 $f$ 和 $g$ 是准凸的。\n一个函数是准凸的，如果它的所有下水平集都是凸集。函数 $\\phi:\\mathbb{R}\\to\\mathbb{R}$ 的下水平集是 $S_{\\phi}(\\alpha) := \\{x \\in \\mathbb{R} : \\phi(x) \\le \\alpha\\}$。\n\n对于函数 $f(x)$，其值域是集合 $\\{0, 1\\}$。我们分析它对于任意 $\\alpha \\in \\mathbb{R}$ 的下水平集 $S_f(\\alpha)$：\n- 如果 $\\alpha < 0$，条件 $f(x) \\le \\alpha$ 永远不满足，所以 $S_f(\\alpha) = \\emptyset$。空集是凸集。\n- 如果 $0 \\le \\alpha < 1$，条件 $f(x) \\le \\alpha$ 等价于 $f(x) = 0$。这在 $x \\in [-3, -2]$ 时发生。因此，$S_f(\\alpha) = [-3, -2]$。在 $\\mathbb{R}$ 中，闭区间是一个凸集。\n- 如果 $\\alpha \\ge 1$，条件 $f(x) \\le \\alpha$ 总是满足的，因为 $f(x)$ 的值是 $0$ 或 $1$。因此，$S_f(\\alpha) = \\mathbb{R}$。整个实数轴是一个凸集。\n因为对于所有的 $\\alpha \\in \\mathbb{R}$，$S_f(\\alpha)$ 都是凸集，所以函数 $f$ 是准凸的。\n\n对于函数 $g(x)$，其值域也是 $\\{0, 1\\}$。我们分析它的下水平集 $S_g(\\beta)$：\n- 如果 $\\beta < 0$，$S_g(\\beta) = \\emptyset$，这是凸集。\n- 如果 $0 \\le \\beta < 1$，条件 $g(x) \\le \\beta$ 等价于 $g(x) = 0$。这在 $x \\in [2, 3]$ 时发生。因此，$S_g(\\beta) = [2, 3]$，这是一个凸区间。\n- 如果 $\\beta \\ge 1$，条件 $g(x) \\le \\beta$ 总是满足的。因此，$S_g(\\beta) = \\mathbb{R}$，这是凸集。\n因为对于所有的 $\\beta \\in \\mathbb{R}$，$S_g(\\beta)$ 都是凸集，所以函数 $g$ 是准凸的。\n\n接下来，我们定义 $h(x) := f(x) + g(x)$ 并证明它不是准凸的。我们首先确定 $h(x)$ 的形式：\n- 如果 $x \\in [-3, -2]$，那么 $f(x)=0$ 且 $g(x)=1$，所以 $h(x) = 0+1=1$。\n- 如果 $x \\in [2, 3]$，那么 $f(x)=1$ 且 $g(x)=0$，所以 $h(x) = 1+0=1$。\n- 其他情况下，$x \\notin [-3, -2]$ 且 $x \\notin [2, 3]$，所以 $f(x)=1$ 且 $g(x)=1$，这得到 $h(x)=1+1=2$。\n因此，函数 $h$ 由下式给出\n$$\nh(x) = \\begin{cases}\n1,  x \\in [-3, -2] \\cup [2, 3] \\\\\n2,  \\text{其他情况}。\n\\end{cases}\n$$\n为了证明 $h$ 不是准凸的，我们必须找到一个值 $\\alpha$，使得其下水平集 $S_h(\\alpha)$ 不是凸集。我们选择 $\\alpha=1$。相应的下水平集是\n$$\nS_h(1) = \\{x \\in \\mathbb{R} : h(x) \\le 1\\} = \\{x \\in \\mathbb{R} : h(x) = 1\\} = [-3, -2] \\cup [2, 3].\n$$\n这个集合是两个不相交区间的并集。为了证明它不是凸集，我们可以从每个区间中各取一点，比如 $x_1 = -2.5 \\in [-3, -2]$ 和 $x_2 = 2.5 \\in [2, 3]$。这些点的凸组合，例如当 $\\lambda = 0.5$ 时，为 $x_{\\lambda} = 0.5(-2.5) + 0.5(2.5) = 0$。对于 $x=0$，我们有 $h(0)=2$。因为 $h(0) > 1$，所以点 $x=0$ 不在 $S_h(1)$ 中。下水平集 $S_h(1)$ 不包含其两点之间的线段，所以它不是一个凸集。因此，$h$ 不是一个准凸函数。\n\n现在，我们来推导恒等式 $S_{f+g}(t)\\;=\\;\\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big)$。令 $h=f+g$。\n我们通过双向包含来证明这一点。\n($\\subseteq$): 设 $x \\in S_h(t)$。根据定义，$f(x)+g(x) \\le t$。令 $\\alpha_0 = f(x)$ 和 $\\beta_0 = g(x)$。那么 $\\alpha_0 + \\beta_0 \\le t$。此外，$f(x) \\le \\alpha_0$ 意味着 $x \\in S_f(\\alpha_0)$，而 $g(x) \\le \\beta_0$ 意味着 $x \\in S_g(\\beta_0)$。因此，$x \\in S_f(\\alpha_0) \\cap S_g(\\beta_0)$。因为存在一对 $(\\alpha_0, \\beta_0)$ 满足 $\\alpha_0 + \\beta_0 \\le t$，使得 $x$ 位于相应的交集中，所以 $x$ 必定位于所有这些对的并集中。即，$x \\in \\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big)$。\n($\\supseteq$): 设 $x \\in \\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big)$。根据并集的定义，存在至少一对 $(\\alpha_1, \\beta_1)$ 使得 $\\alpha_1 + \\beta_1 \\le t$ 并且 $x \\in S_f(\\alpha_1) \\cap S_g(\\beta_1)$。由 $x \\in S_f(\\alpha_1)$，我们有 $f(x) \\le \\alpha_1$。由 $x \\in S_g(\\beta_1)$，我们有 $g(x) \\le \\beta_1$。将这两个不等式相加得到 $f(x) + g(x) \\le \\alpha_1 + \\beta_1$。因为 $\\alpha_1 + \\beta_1 \\le t$，我们得出结论 $f(x)+g(x) \\le t$，这意味着 $x \\in S_{f+g}(t)$。\n因此，该恒等式得证。\n\n这个恒等式解释了为什么两个准凸函数之和不一定是准凸的。虽然 $f$ 和 $g$ 是准凸的保证了每个下水平集 $S_f(\\alpha)$ 和 $S_g(\\beta)$ 都是凸集，两个凸集的交集 $S_f(\\alpha) \\cap S_g(\\beta)$ 也总是凸集。然而，和的下水平集 $S_{f+g}(t)$ 是由这些凸交集的*并集*构成的。一般而言，凸集的并集不一定是凸集。我们关于 $h$ 在 $t=1$ 时的例子就说明了这一点：$S_h(1)$ 是集合 $[-3, -2]$（来自对 $(\\alpha,\\beta) = (0,1)$，其满足 $\\alpha+\\beta=1\\le 1$）和 $[2, 3]$（来自对 $(\\alpha,\\beta)=(1,0)$，其满足 $\\alpha+\\beta=1\\le 1$）的并集，结果为非凸集 $[-3, -2] \\cup [2, 3]$。这与凸函数的行为形成鲜明对比。对于*凸*函数 $\\phi_1, \\phi_2$，其和 $\\phi_1+\\phi_2$ 也是凸的。这个性质根植于一个事实，即和函数的上镜图是各个上镜图的闵可夫斯基和，$\\operatorname{epi}(\\phi_1+\\phi_2) = \\operatorname{epi}(\\phi_1) + \\operatorname{epi}(\\phi_2)$，并且两个凸集的闵可夫斯基和总是凸的。准凸性是一个定义在下水平集上的较弱条件，函数加法运算不能转化为在这些集合上的保持凸性的运算（如闵可夫斯基和）。相反，它导致了交集的并集结构，这可能会破坏凸性。\n\n最后，我们计算 $t_{\\star}\\;:=\\;\\inf\\{\\,t\\in\\mathbb{R}:\\ S_{h}(t)\\ \\text{是凸集且非空}\\,\\}$。我们分析 $h(x)$ 对于所有 $t \\in \\mathbb{R}$ 的下水平集：\n- 对于 $t < 1$：$S_h(t) = \\{x \\in \\mathbb{R} : h(x) \\le t\\} = \\emptyset$。空集是凸集但不是非空的。所以，这些 $t$ 的值不在我们要求下确界的集合中。\n- 对于 $1 \\le t < 2$：$S_h(t) = \\{x \\in \\mathbb{R} : h(x) \\le t\\} = [-3, -2] \\cup [2, 3]$。这个集合是非空的，但正如我们已经证明的，它不是凸集。\n- 对于 $t \\ge 2$：$S_h(t) = \\{x \\in \\mathbb{R} : h(x) \\le t\\} = \\mathbb{R}$。这是因为 $h(x)$ 的最大值是 $2$。集合 $\\mathbb{R}$ 既是凸集也是非空的。\n\n因此，$S_h(t)$ 是凸集且非空的 $t$ 值的集合是区间 $[2, \\infty)$。题目要求的是这个集合的下确界。\n$$\nt_{\\star} = \\inf [2, \\infty) = 2.\n$$\n下水平集的性质恰好在 $t=2$ 处从非凸变为凸。", "answer": "$$\n\\boxed{2}\n$$", "id": "3170821"}, {"introduction": "准凸性（及准凹性）的真正威力在于其在优化问题中的应用。本练习将指导你实现经典的二分搜索算法，该算法能将一个复杂的优化问题转化为一系列简单的可行性问题。你将亲身体会到，正是水平集的凸性使得这种高效的算法策略成为可能。[@problem_id:3170813]", "problem": "你需要通过对一个标量阈值进行二分搜索，来实现用于准凹最大化的水平集方法。目标函数定义为 $f(x)=\\min_{i\\in\\{1,\\dots,m\\}} a_i^\\top x$，其中每个 $a_i\\in\\mathbb{R}^n$，可行域 $X\\subset\\mathbb{R}^n$ 是一个由线性不等式和边界约束描述的多胞体。该方法依赖于测试水平集的可行性：对于给定的阈值 $\\alpha\\in\\mathbb{R}$，检查是否存在 $x\\in X$ 使得 $f(x)\\ge \\alpha$。利用这种单调可行性属性，对 $\\alpha$ 实现一个二分搜索，以近似求解 $f(x)$ 在 $X$ 上的最大值。\n\n使用的基本定义：\n- 如果对于所有的 $\\alpha\\in\\mathbb{R}$，每个上水平集 $\\{x\\in\\mathbb{R}^n:\\ f(x)\\ge \\alpha\\}$ 都是凸集，则函数 $f:\\mathbb{R}^n\\to\\mathbb{R}$ 是准凹的。\n- 多胞体 $X$ 是有限多个线性不等式和边界约束的解集。\n- 线性规划 (LP) 是一类具有线性目标和线性约束的优化问题。\n\n使用的核心可行性等价关系：\n- 对于 $f(x)=\\min_i a_i^\\top x$，上水平集 $\\{x\\in X:\\ f(x)\\ge \\alpha\\}$ 等价于 $\\{x\\in X:\\ a_i^\\top x\\ge \\alpha\\ \\text{for all}\\ i=1,\\dots,m\\}$，这是半空间的交集。这个集合的可行性可以通过设置一个零目标且只包含约束的线性规划 (LP) 求解器来检查。\n\n实现要求：\n1. 在有界区间 $[\\alpha_\\text{low},\\alpha_\\text{high}]$ 内对 $\\alpha$ 使用二分搜索，其中：\n   - $\\alpha_\\text{low}$ 是通过在某个可行点 $x_0\\in X$ 处计算 $f(x_0)$ 得到的。你可以通过求解一个目标为零且仅包含定义 $X$ 的约束的线性规划 (LP) 问题来获得 $x_0$。\n   - $\\alpha_\\text{high}$ 是从界 $f(x)\\le \\min_{i} \\max_{x\\in X} a_i^\\top x$ 得到的，你应该通过求解 $m$ 个在 $X$ 上最大化 $a_i^\\top x$（等价于最小化 $-a_i^\\top x$）的线性规划 (LP) 问题来计算它。\n2. 对于给定的 $\\alpha$，通过求解一个零目标函数、受限于定义 $X$ 的约束以及所有 $i$ 的附加约束 $a_i^\\top x\\ge \\alpha$ 的线性规划 (LP) 问题来测试可行性。这等价于对所有的 $i$ 有 $-a_i^\\top x\\le -\\alpha$，并且可以通过不等式约束来处理。\n3. 继续二分搜索，直到区间长度小于一个容差，并返回最终的 $\\alpha_\\text{low}$作为 $f(x)$ 在 $X$ 上的最大值的近似值。\n\n你的程序必须是一个使用指定环境的、单一完整的、可运行的 Python 程序。它必须解决以下测试套件，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个值四舍五入到 $6$ 位小数：\n\n测试套件：\n- 案例 $1$ (正常路径): $n=2$, $X=\\{x\\in\\mathbb{R}^2:\\ 0\\le x_1\\le 1,\\ 0\\le x_2\\le 1\\}$, $a_1^\\top=[1,0]$, $a_2^\\top=[0,1]$。预期的最大值是 $\\alpha^\\star=1$。\n- 案例 $2$ (边界覆盖): $n=3$, $X=\\{x\\in\\mathbb{R}^3:\\ x_i\\ge 0\\ \\text{for}\\ i\\in\\{1,2,3\\},\\ x_1+x_2+x_3\\le 1\\}$, $a_1^\\top=[1,0,0]$, $a_2^\\top=[0,1,0]$, $a_3^\\top=[0,0,1]$。预期的最大值是 $\\alpha^\\star=1/3$。\n- 案例 $3$ (带有负方向的边界情况): $n=2$, $X=\\{x\\in\\mathbb{R}^2:\\ 0\\le x_1\\le 1,\\ 0\\le x_2\\le 1\\}$, $a_1^\\top=[-1,0]$, $a_2^\\top=[0,-1]$, $a_3^\\top=[1,-1]$。预期的最大值是 $\\alpha^\\star=0$。\n\n容差和输出精度：\n- 对 $\\alpha$ 的区间使用 $10^{-7}$ 的二分搜索容差。\n- 将每个案例的 $f(x)$ 近似最大值输出为浮点数，四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[0.123456,0.333333,1.000000]$）。", "solution": "用户希望实现一个对分算法，以找到一个准凹函数在多胞体上的最大值。\n\n### 第 1 步：提取已知信息\n\n- **目标函数：** $f(x)=\\min_{i\\in\\{1,\\dots,m\\}} a_i^\\top x$，其中 $x \\in \\mathbb{R}^n$ 且 $a_i\\in\\mathbb{R}^n$。\n- **可行域：** 一个由有限个线性不等式和边界约束定义的多胞体 $X\\subset\\mathbb{R}^n$。\n- **算法：** 对标量阈值 $\\alpha$ 的对分法（二分搜索）。\n- **可行性测试：** 对于给定的 $\\alpha$，检查集合 $\\{x\\in X:\\ f(x)\\ge \\alpha\\}$ 是否非空。这等价于检查线性系统的可行性：$x \\in X$ 且对于所有 $i \\in \\{1, \\dots, m\\}$ 有 $a_i^\\top x \\ge \\alpha$。这个可行性检查是使用一个带有零目标函数的线性规划 (LP) 求解器来执行的。\n- **初始区间 $[\\alpha_\\text{low}, \\alpha_\\text{high}]$**:\n    - $\\alpha_\\text{low}$ 通过找到一个可行点 $x_0 \\in X$ 并计算 $f(x_0)$ 来确定。点 $x_0$ 是通过求解一个在 $X$ 上的零目标 LP 来找到的。\n    - $\\alpha_\\text{high}$ 通过上界 $U = \\min_{i=1,\\dots,m} \\left( \\max_{x\\in X} a_i^\\top x \\right)$ 来确定。这需要求解 $m$ 个独立的 LP 问题。\n- **终止条件：** 二分搜索持续进行，直到区间长度 $(\\alpha_\\text{high} - \\alpha_\\text{low})$ 小于 $10^{-7}$ 的容差。\n- **输出：** $\\alpha_\\text{low}$ 的最终值，四舍五入到 6 位小数。\n- **测试案例：**\n    1.  $n=2$, $X=\\{x\\in\\mathbb{R}^2 : 0\\le x_1\\le 1, 0\\le x_2\\le 1\\}$, $a_1=[1,0]^\\top$, $a_2=[0,1]^\\top$。\n    2.  $n=3$, $X=\\{x\\in\\mathbb{R}^3 : x_i\\ge 0 \\text{ for } i\\in\\{1,2,3\\}, x_1+x_2+x_3\\le 1\\}$, $a_1=[1,0,0]^\\top$, $a_2=[0,1,0]^\\top$, $a_3=[0,0,1]^\\top$。\n    3.  $n=2$, $X=\\{x\\in\\mathbb{R}^2 : 0\\le x_1\\le 1, 0\\le x_2\\le 1\\}$, $a_1=[-1,0]^\\top$, $a_2=[0,-1]^\\top$, $a_3=[1,-1]^\\top$。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n- **科学依据：** 该问题是凸优化和准凸优化领域的一个标准练习。函数 $f(x) = \\min_i a_i^\\top x$ 是一组线性（因此是凹）函数的逐点最小值。凹函数的逐点最小值是一个凹函数。由于每个凹函数也是准凹函数，因此前提成立。基于检查水平集可行性的对分法是优化准凸/准凹函数的经典且正确的算法。使用 LP 建立搜索区间和执行可行性检查的方法也是标准的，并且在数学上是合理的。\n- **良态性：** 问题是良态的。对于所有测试案例，目标函数是连续的，可行集 $X$ 是一个紧多胞体。因此，最大值保证存在。对分算法保证收敛到这个最大值。\n- **客观性：** 问题以精确的数学术语陈述，没有歧义或主观语言。\n\n问题陈述内部一致、科学合理且良态。所有必需的信息都已提供。\n\n### 第 3 步：结论和行动\n\n问题有效。将提供解决方案。\n\n### 基于原理的解决方案\n\n该问题要求我们找到函数 $f(x)$ 在集合 $X$ 上的最大值，可正式表述为：\n$$\n\\text{maximize} \\quad f(x) = \\min_{i=1,\\dots,m} a_i^\\top x \\\\\n\\text{subject to} \\quad x \\in X\n$$\n其中 $X$ 是一个多胞体。这是一个准凹最大化问题。\n\n**1. 准凹性与对分法**\n\n如果一个函数 $f(x)$ 的上水平集 $S_\\alpha = \\{x \\mid f(x) \\ge \\alpha\\}$ 对于所有 $\\alpha \\in \\mathbb{R}$ 都是凸的，那么该函数是准凹的。对于我们的函数 $f(x) = \\min_{i} a_i^\\top x$，其上水平集为：\n$$\nS_\\alpha = \\{x \\mid \\min_{i=1,\\dots,m} a_i^\\top x \\ge \\alpha\\} = \\{x \\mid a_i^\\top x \\ge \\alpha \\text{ for all } i=1,\\dots,m\\}\n$$\n每个条件 $a_i^\\top x \\ge \\alpha$ 定义了一个闭半空间，它是一个凸集。有限个凸集的交集也是一个凸集。因此，$S_\\alpha$ 是凸的，且 $f(x)$ 是准凹的。\n\n令 $\\alpha^\\star = \\max_{x \\in X} f(x)$ 为最优值。使得对分法可行的关键属性是，在水平集和可行域的交集中找到一个点的可行性，即集合 $S_\\alpha \\cap X$ 的非空性，相对于 $\\alpha$ 是单调的。\n- 如果存在一个 $x \\in X$ 使得 $f(x) \\ge \\alpha$，那么最优值 $\\alpha^\\star$ 必须至少为 $\\alpha$。\n- 如果不存在 $x \\in X$ 使得 $f(x) \\ge \\alpha$，那么最优值 $\\alpha^\\star$ 必须小于 $\\alpha$。\n\n这种单调属性使我们能够对 $\\alpha$ 的值使用二分搜索（对分法）来找到 $\\alpha^\\star$。\n\n**2. 通过线性规划进行可行性检查**\n\n对分算法的核心是可行性检查：对于给定的 $\\alpha$，集合 $\\{x \\in X \\mid f(x) \\ge \\alpha\\}$ 是否为空？这个集合由定义多胞体 $X$ 的原始约束加上所有 $i$ 的新约束 $a_i^\\top x \\ge \\alpha$ 来描述。由于所有这些约束都是线性不等式，它们共同定义了另一个多胞体。判断一个多胞体是否为空是一个标准的线性可行性问题，可以使用线性规划 (LP) 求解器来解决。我们构建一个目标函数为零 ($c = 0$) 并包含所有组合起来的线性约束的 LP。如果 LP 求解器找到一个可行解，则该集合非空。否则，它是空的。\n\n**3. 算法**\n\n对分算法按以下步骤进行：\n\n- **步骤 A：初始化搜索区间 $[\\alpha_\\text{low}, \\alpha_\\text{high}]$**\n    需要一个保证包含最优值 $\\alpha^\\star$ 的初始区间。\n    1.  **下界 ($\\alpha_\\text{low}$):** 我们找到任意一个可行点 $x_0 \\in X$。这可以通过求解一个目标函数为零、仅受限于定义 $X$ 的约束的 LP 来完成。如果找到解 $x_0$，我们计算 $f(x_0)$。由于 $x_0 \\in X$，我们知道 $\\alpha^\\star \\ge f(x_0)$。因此我们可以设置 $\\alpha_\\text{low} = f(x_0)$。\n    2.  **上界 ($\\alpha_\\text{high}$):** 对于任意 $x \\in X$，我们有 $f(x) = \\min_i a_i^\\top x \\le a_j^\\top x$ 对任意 $j \\in \\{1,\\dots,m\\}$ 成立。这进一步意味着 $f(x) \\le \\max_{y \\in X} a_j^\\top y$。由于这对所有 $j$ 都成立，它也必须对 $j$ 上的最小值成立：\n        $$\n        f(x) \\le \\min_{j=1,\\dots,m} \\left( \\max_{y \\in X} a_j^\\top y \\right)\n        $$\n        这给出了 $\\alpha^\\star$ 的一个有效上界。我们通过求解 $m$ 个 LP 来计算这个界，其中第 $j$ 个 LP 在 $X$ 上最大化 $a_j^\\top x$。然后我们将 $\\alpha_\\text{high}$ 设置为这 $m$ 个最大值中的最小值。\n\n- **步骤 B：对分迭代**\n    当区间宽度 $(\\alpha_\\text{high} - \\alpha_\\text{low})$ 大于指定的容差 $\\epsilon$ 时：\n    1.  计算中点：$\\alpha_\\text{mid} = (\\alpha_\\text{low} + \\alpha_\\text{high}) / 2$。\n    2.  为 $\\alpha_\\text{mid}$ 求解可行性 LP。约束是 $X$ 的约束加上对所有 $i$ 的 $a_i^\\top x \\ge \\alpha_\\text{mid}$。\n    3.  如果存在可行解，这意味着 $\\alpha^\\star \\ge \\alpha_\\text{mid}$。我们更新下界：$\\alpha_\\text{low} = \\alpha_\\text{mid}$。\n    4.  如果不存在可行解，这意味着 $\\alpha^\\star  \\alpha_\\text{mid}$。我们更新上界：$\\alpha_\\text{high} = \\alpha_\\text{mid}$。\n\n- **步骤 C：终止**\n    当 $\\alpha_\\text{high} - \\alpha_\\text{low} \\le \\epsilon$ 时循环终止。$\\alpha_\\text{low}$ 的最终值是 $\\alpha^\\star$ 的一个经过认证的下界，并且与真实最优值的差距在 $\\epsilon$ 之内。该值作为解返回。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_quasiconcave_max(a_vectors, A_ub, b_ub, bounds, tol=1e-7):\n    \"\"\"\n    Maximizes a quasiconcave function f(x) = min(a_i^T x) over a polytope X\n    using a bisection method on the function value alpha.\n\n    Args:\n        a_vectors (np.ndarray): Matrix where rows are the vectors a_i.\n        A_ub (np.ndarray or None): Matrix A for inequality constraints A @ x = b of the polytope X.\n        b_ub (np.ndarray or None): Vector b for inequality constraints A @ x = b of the polytope X.\n        bounds (list of tuples): Bounds for each variable x_i in X.\n        tol (float): Tolerance for the binary search interval width.\n\n    Returns:\n        float: The approximate maximum value of f(x).\n    \"\"\"\n    n = a_vectors.shape[1]\n    m = a_vectors.shape[0]\n    c_zero = np.zeros(n)\n    \n    # --- Step 1: Find initial search interval [alpha_low, alpha_high] ---\n\n    # Find an initial feasible point x0 to establish a lower bound.\n    res_x0 = linprog(c_zero, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs-ds')\n    if not res_x0.success:\n        # The feasible set X is empty.\n        # This case is not expected for the given problem.\n        raise ValueError(\"Feasible region X is empty.\")\n    x0 = res_x0.x\n    \n    # alpha_low is f(x0), a guaranteed achievable value.\n    alpha_low = np.min(a_vectors @ x0)\n\n    # Find the upper bound by solving m LPs: max_{x in X} (a_i^T x) for each i.\n    max_vals = []\n    for i in range(m):\n        # linprog minimizes, so to maximize a_i^T x, we minimize -a_i^T x.\n        c_i = -a_vectors[i]\n        res_max = linprog(c_i, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs-ds')\n        if not res_max.success:\n            # Should not happen for bounded polytopes.\n            # Could indicate an unbounded problem if bounds were not provided.\n             raise ValueError(f\"Could not solve LP to find upper bound for a_{i}.\")\n        # The maximum value is the negative of the minimum found by linprog.\n        max_val = -res_max.fun\n        max_vals.append(max_val)\n    \n    # alpha_high is the minimum of these maximums.\n    alpha_high = np.min(max_vals)\n    \n    # --- Step 2: Binary Search ---\n    \n    while alpha_high - alpha_low > tol:\n        alpha_mid = (alpha_low + alpha_high) / 2\n        \n        # Check feasibility of {x in X | f(x) >= alpha_mid}.\n        # This adds constraints a_i^T x >= alpha_mid for all i.\n        # In linprog format: -a_i^T x = -alpha_mid.\n        level_set_A = -a_vectors\n        level_set_b = -np.full(m, alpha_mid)\n\n        # Combine constraints of X and the level set.\n        if A_ub is not None and b_ub is not None:\n            feas_A_ub = np.vstack((A_ub, level_set_A))\n            feas_b_ub = np.concatenate((b_ub, level_set_b))\n        else:\n            feas_A_ub = level_set_A\n            feas_b_ub = level_set_b\n\n        # Solve the feasibility LP (zero objective function).\n        res_feas = linprog(c_zero, A_ub=feas_A_ub, b_ub=feas_b_ub, bounds=bounds, method='highs-ds')\n        \n        if res_feas.success:\n            # A feasible point exists for alpha_mid, so the true max is at least alpha_mid.\n            alpha_low = alpha_mid\n        else:\n            # No feasible point exists, the true max must be less than alpha_mid.\n            alpha_high = alpha_mid\n            \n    # --- Step 3: Return result ---\n    return alpha_low\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the quasiconcave maximization problem.\n    \"\"\"\n    \n    # Case 1: n=2, X=[0,1]^2, a1=[1,0], a2=[0,1]\n    case1_a = np.array([[1, 0], [0, 1]])\n    case1_A_ub = None\n    case1_b_ub = None\n    case1_bounds = [(0, 1), (0, 1)]\n\n    # Case 2: n=3, X={x>=0, sum(x)=1}, a_i are standard basis vectors\n    case2_a = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    case2_A_ub = np.array([[1, 1, 1]])\n    case2_b_ub = np.array([1])\n    case2_bounds = [(0, None), (0, None), (0, None)]\n    \n    # Case 3: n=2, X=[0,1]^2, a1=[-1,0], a2=[0,-1], a3=[1,-1]\n    case3_a = np.array([[-1, 0], [0, -1], [1, -1]])\n    case3_A_ub = None\n    case3_b_ub = None\n    case3_bounds = [(0, 1), (0, 1)]\n\n    test_cases = [\n        (case1_a, case1_A_ub, case1_b_ub, case1_bounds),\n        (case2_a, case2_A_ub, case2_b_ub, case2_bounds),\n        (case3_a, case3_A_ub, case3_b_ub, case3_bounds),\n    ]\n\n    results = []\n    for case in test_cases:\n        a_vectors, A_ub, b_ub, bounds = case\n        result = solve_quasiconcave_max(a_vectors, A_ub, b_ub, bounds)\n        results.append(result)\n\n    # Format output to 6 decimal places as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3170813"}]}