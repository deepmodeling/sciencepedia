{"hands_on_practices": [{"introduction": "在科学和工程实践中，我们经常需要从一组充满噪声的测量数据中提炼出简单的线性模型，例如校准传感器。这个练习 [@problem_id:2218047] 将引导您完成使用正规方程进行线性回归的全过程。您将学习如何根据原始数据构建线性系统 $A\\mathbf{x} \\approx \\mathbf{b}$，求解最佳拟合直线的参数，并通过计算残差的范数来量化模型的拟合优度。", "problem": "一位工程师正在校准一种新型热传感器。假设该传感器的输出电压 $V$ 是环境温度 $T$ 的线性函数。该关系由方程 $V(T) = c_0 + c_1 T$ 建模，其中 $c_0$ 和 $c_1$ 是待确定的校准常数。为求得这些常数，在受控环境中进行了四次测量：\n\n*   在温度 $T=10$ 摄氏度时，测得的电压为 $V=2.6$ 伏特。\n*   在温度 $T=20$ 摄氏度时，测得的电压为 $V=3.4$ 伏特。\n*   在温度 $T=30$ 摄氏度时，测得的电压为 $V=4.7$ 伏特。\n*   在温度 $T=40$ 摄氏度时，测得的电压为 $V=5.4$ 伏特。\n\n参数 $c_0$ 和 $c_1$ 的确定方式是，使得测量电压与线性模型预测电压之差的平方和最小。设所得的最佳拟合直线为 $\\hat{V}(T) = \\hat{c}_0 + \\hat{c}_1 T$。\n\n您的任务是计算残差向量的欧几里得范数，其中残差向量的分量是每次测量的电压与该最佳拟合直线预测的相应电压之差。\n\n最终答案以伏特为单位表示，并四舍五入到三位有效数字。", "solution": "我们将电压建模为温度的线性函数 $V(T)=c_{0}+c_{1}T$，并使用四组测量值 $(T_{i},V_{i})=(10,2.6),(20,3.4),(30,4.7),(40,5.4)$ 通过最小二乘法确定 $(\\hat{c}_{0},\\hat{c}_{1})$。设设计矩阵为 $X=\\begin{pmatrix}1  10 \\\\ 1  20 \\\\ 1  30 \\\\ 1  40\\end{pmatrix}$，观测向量为 $\\boldsymbol{V}=\\begin{pmatrix}2.6 \\\\ 3.4 \\\\ 4.7 \\\\ 5.4\\end{pmatrix}$。最小二乘估计满足\n$$\n\\begin{pmatrix}\\hat{c}_{0} \\\\ \\hat{c}_{1}\\end{pmatrix}=(X^{T}X)^{-1}X^{T}\\boldsymbol{V},\n$$\n等价于正规方程组\n$$\n\\begin{pmatrix}n  \\sum T_{i} \\\\ \\sum T_{i}  \\sum T_{i}^{2}\\end{pmatrix}\\begin{pmatrix}\\hat{c}_{0} \\\\ \\hat{c}_{1}\\end{pmatrix}=\\begin{pmatrix}\\sum V_{i} \\\\ \\sum T_{i}V_{i}\\end{pmatrix}.\n$$\n计算各项和：$n=4$，$\\sum T_{i}=10+20+30+40=100$，$\\sum T_{i}^{2}=10^{2}+20^{2}+30^{2}+40^{2}=3000$，$\\sum V_{i}=2.6+3.4+4.7+5.4=16.1$，以及 $\\sum T_{i}V_{i}=10\\cdot 2.6+20\\cdot 3.4+30\\cdot 4.7+40\\cdot 5.4=451$。因此我们求解\n$$\n\\begin{pmatrix}4  100 \\\\ 100  3000\\end{pmatrix}\\begin{pmatrix}\\hat{c}_{0} \\\\ \\hat{c}_{1}\\end{pmatrix}=\\begin{pmatrix}16.1 \\\\ 451\\end{pmatrix}.\n$$\n行列式为 $4\\cdot 3000-100\\cdot 100=2000$，所以\n$$\n\\hat{c}_{0}=\\frac{3000\\cdot 16.1-100\\cdot 451}{2000}=1.6,\\quad \\hat{c}_{1}=\\frac{-100\\cdot 16.1+4\\cdot 451}{2000}=0.097.\n$$\n因此最佳拟合直线为 $\\hat{V}(T)=1.6+0.097\\,T$。\n\n计算在四个温度下的残差 $r_{i}=V_{i}-\\hat{V}(T_{i})$：\n$$\n\\hat{V}(10)=1.6+0.097\\cdot 10=2.57,\\quad r_{1}=2.6-2.57=0.03,\n$$\n$$\n\\hat{V}(20)=1.6+0.097\\cdot 20=3.54,\\quad r_{2}=3.4-3.54=-0.14,\n$$\n$$\n\\hat{V}(30)=1.6+0.097\\cdot 30=4.51,\\quad r_{3}=4.7-4.51=0.19,\n$$\n$$\n\\hat{V}(40)=1.6+0.097\\cdot 40=5.48,\\quad r_{4}=5.4-5.48=-0.08.\n$$\n残差向量 $\\boldsymbol{r}$ 的欧几里得范数为\n$$\n\\|\\boldsymbol{r}\\|_{2}=\\sqrt{\\sum_{i=1}^{4}r_{i}^{2}}=\\sqrt{(0.03)^{2}+(-0.14)^{2}+(0.19)^{2}+(-0.08)^{2}}=\\sqrt{0.063}.\n$$\n计算平方根并四舍五入到三位有效数字，得到\n$$\n\\|\\boldsymbol{r}\\|_{2}\\approx 0.251.\n$$\n该值的单位是伏特，因为每个残差都是一个电压差。", "answer": "$$\\boxed{0.251}$$", "id": "2218047"}, {"introduction": "线性最小二乘法的威力远不止于拟合简单的直线。我们可以用它来为依赖多个变量的现象建模，比如模拟一个表面上的温度分布。这个练习 [@problem_id:2218050] 将方法推广到寻找一组三维数据点的最佳拟合平面，从而巩固您为多变量模型构建设计矩阵 $A$ 并应用相同的正规方程求解模型系数的能力。", "problem": "一位材料科学家正在研究一种新开发合金的热性能。他们将一块该材料的矩形板放置在受控环境中，并测量板表面上四个不同位置 $(x, y)$ 的温度 $T$。假设长度和温度的测量单位是一个一致但未指明的单位系统。该科学家希望找到板上温度分布的最佳线性模型，其形式为 $T(x,y) = c_1 x + c_2 y + c_3$。\n\n收集到的四个数据点 $(x, y, T)$ 如下：\n- (1, 1, 3.5)\n- (2, -1, 1.2)\n- (-1, 2, 4.0)\n- (0, -2, -0.5)\n\n使用线性最小二乘法，确定最佳拟合平面的系数 $c_1, c_2,$ 和 $c_3$。请按 $c_1, c_2, c_3$ 的特定顺序提供这些值。您的最终答案应四舍五入到三位有效数字。", "solution": "我们寻求模型 $T(x,y)=c_{1}x+c_{2}y+c_{3}$ 对四个数据点 $(x_{i},y_{i},T_{i})$ 的最小二乘拟合。令\n$$\nA=\\begin{pmatrix}\n1  1  1\\\\\n2  -1  1\\\\\n-1  2  1\\\\\n0  -2  1\n\\end{pmatrix},\\quad\n\\mathbf{c}=\\begin{pmatrix}c_{1}\\\\ c_{2}\\\\ c_{3}\\end{pmatrix},\\quad\n\\mathbf{b}=\\begin{pmatrix}3.5\\\\ 1.2\\\\ 4.0\\\\ -0.5\\end{pmatrix}.\n$$\n最小二乘解满足正规方程组 $A^{\\top}A\\,\\mathbf{c}=A^{\\top}\\mathbf{b}$。计算所需的各分量：\n$$\n\\sum x_{i}=2,\\quad \\sum y_{i}=0,\\quad \\sum x_{i}^{2}=6,\\quad \\sum y_{i}^{2}=10,\\quad \\sum x_{i}y_{i}=-3,\n$$\n$$\n\\sum x_{i}T_{i}=1.9,\\quad \\sum y_{i}T_{i}=11.3,\\quad \\sum T_{i}=8.2.\n$$\n因此\n$$\nA^{\\top}A=\\begin{pmatrix}6  -3  2\\\\ -3  10  0\\\\ 2  0  4\\end{pmatrix},\\quad\nA^{\\top}\\mathbf{b}=\\begin{pmatrix}1.9\\\\ 11.3\\\\ 8.2\\end{pmatrix}.\n$$\n这得到线性方程组\n$$\n\\begin{cases}\n6c_{1}-3c_{2}+2c_{3}=1.9,\\\\\n-3c_{1}+10c_{2}=11.3,\\\\\n2c_{1}+4c_{3}=8.2.\n\\end{cases}\n$$\n由第三个方程，$c_{1}+2c_{3}=4.1$，所以 $c_{1}=4.1-2c_{3}$。代入第二个方程得到 $-3(4.1-2c_{3})+10c_{2}=11.3$，化简为 $5c_{2}+3c_{3}=11.8$。将 $c_{1}=4.1-2c_{3}$ 代入第一个方程得到 $3c_{2}+10c_{3}=22.7$。求解\n$$\n\\begin{cases}\n5c_{2}+3c_{3}=11.8,\\\\\n3c_{2}+10c_{3}=22.7\n\\end{cases}\n$$\n可得\n$$\nc_{2}=\\frac{11.8\\cdot 10-3\\cdot 22.7}{41}=\\frac{49.9}{41}=\\frac{499}{410},\\quad\nc_{3}=\\frac{5\\cdot 22.7-3\\cdot 11.8}{41}=\\frac{78.1}{41}=\\frac{781}{410}.\n$$\n然后\n$$\nc_{1}=4.1-2c_{3}=\\frac{41}{10}-2\\cdot\\frac{781}{410}=\\frac{1681-1562}{410}=\\frac{119}{410}.\n$$\n因此，精确的系数为\n$$\nc_{1}=\\frac{119}{410},\\quad c_{2}=\\frac{499}{410},\\quad c_{3}=\\frac{781}{410}.\n$$\n四舍五入到三位有效数字：\n$$\nc_{1}\\approx 0.290,\\quad c_{2}\\approx 1.22,\\quad c_{3}\\approx 1.90.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0.290  1.22  1.90\\end{pmatrix}}$$", "id": "2218050"}, {"introduction": "尽管正规方程提供了一个直接的解析解，但在计算机上进行实际应用时，会暴露出与数值稳定性相关的关键挑战。这个高级编程练习 [@problem_id:3257364] 要求您亲自实现正规方程法，并将其精度与更稳健的基于 QR 分解的求解器进行比较。通过处理臭名昭著的病态希尔伯特矩阵，您将亲眼见证正规方程的理论优雅性如何在浮点运算中受到影响，从而深刻理解数值条件数的实际意义。", "problem": "实现一个完整的程序，从基本原理出发，推导并使用正规方程法求解线性最小二乘问题，并对比其在由希尔伯特矩阵构建的良态和病态实例上的数值行为。从线性最小二乘的基本公式出发：给定一个矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）和一个右侧向量 $b \\in \\mathbb{R}^m$，定义目标函数 $f(x) = \\tfrac{1}{2}\\lVert A x - b \\rVert_2^2$（其中 $x \\in \\mathbb{R}^n$）。对 $f(x)$ 使用微积分来获得最小化点的驻点条件，并实现一个求解器，该求解器仅使用指定运行时中可用的基本线性代数运算来强制执行此驻点条件。不要使用任何黑盒最小二乘例程。然后，实现一个基于正交三角 (QR) 分解的数值稳定的参考求解器，以获得基准解。解释并演示 $A$ 中的病态条件如何降低正规方程法的性能，尤其是在项为 $H_{ij} = \\tfrac{1}{i + j - 1}$（对于整数 $i \\ge 1$, $j \\ge 1$）的希尔伯特矩阵上。\n\n遵循以下要求。\n\n- 推导基础：从 $f(x) = \\tfrac{1}{2}\\lVert A x - b \\rVert_2^2$ 和规则“$\\tfrac{1}{2}\\lVert r(x) \\rVert_2^2$ 的梯度是 $J(x)^\\top r(x)$，其中 $J(x)$ 是 $r(x)$ 的雅可比矩阵”开始。将其特化到线性残差 $r(x) = A x - b$ 并推导出您的求解器必须满足的驻点条件。不要在问题陈述本身中包含任何预先推导的“捷径”公式。\n- 为您的设计提供信息的数值稳定性讨论：在浮点运算中，误差增长取决于 $A$ 相对于 2-范数的条件数 $\\kappa_2(A)$。回想一下，构造 $A^\\top A$ 会使 2-范数条件数平方，与应用正交变换的基于 QR 的方法相比，这会放大舍入误差。\n- 实现要求：\n  - 实现一个函数，通过上述推导的正规方程法求解线性最小二乘问题。使用直接线性求解器而不是显式求逆来求解得到的对称系统。\n  - 实现一个参考求解器，该求解器使用瘦 QR 分解 $A = Q R$（其中 $Q \\in \\mathbb{R}^{m \\times n}$ 具有标准正交列，且 $R \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵），然后求解 $R x = Q^\\top b$。\n  - 实现一个函数来构建一个矩形希尔伯特矩阵 $H \\in \\mathbb{R}^{m \\times n}$，其项为 $H_{ij} = \\tfrac{1}{i + j - 1}$。\n  - 对于下面的每个测试用例，通过 $b = A x_{\\mathrm{true}} + \\varepsilon$ 来构建 $b$，其中 $\\varepsilon \\in \\mathbb{R}^m$ 是一个固定的、微小的、确定性的扰动，其项为 $\\varepsilon_i = \\alpha \\cdot (-1)^i$，其中 $\\alpha$ 是一个指定的标量。这确保了一个受控的、非零的残差，用于评估灵敏度。\n- 每个测试用例的误差度量和要求输出：\n  - 对于求解器输出的 $x$，计算前向相对误差为 $e(x) = \\dfrac{\\lVert x - x_{\\mathrm{true}} \\rVert_2}{\\lVert x_{\\mathrm{true}} \\rVert_2}$。\n  - 对于每个测试用例，计算比率 $r = \\dfrac{e(x_{\\mathrm{NE}})}{e(x_{\\mathrm{QR}})}$，其中 $x_{\\mathrm{NE}}$ 是正规方程解，$x_{\\mathrm{QR}}$ 是基于 QR 的解。\n  - 您的程序必须输出一行，其中包含所有测试用例的这些比率的列表，按顺序排列，格式为用方括号括起来的逗号分隔列表，例如：$[r_1,r_2,r_3,r_4]$。每个 $r_k$ 必须作为浮点数输出。\n\n测试套件。精确实现以下四个测试用例，以检验不同的条件状况和边界情况：\n\n- 测试用例 1（良态，小型，在微小扰动下一致）：\n  - $A_1 \\in \\mathbb{R}^{3 \\times 2}$，行分别为 $[1,0]$、$[0,1]$、$[1,1]$。\n  - $x_{\\mathrm{true},1} = [1,-1]^\\top$。\n  - $\\alpha = 10^{-12}$ 且对于 $i \\in \\{1,2,3\\}$ 有 $\\varepsilon_i = \\alpha \\cdot (-1)^i$，因此 $b_1 = A_1 x_{\\mathrm{true},1} + \\varepsilon$。\n- 测试用例 2（希尔伯特矩阵，中等维度，病态）：\n  - $A_2 = H \\in \\mathbb{R}^{10 \\times 5}$，其中对于 $i \\in \\{1,\\dots,10\\}$, $j \\in \\{1,\\dots,5\\}$ 有 $H_{ij} = \\tfrac{1}{i + j - 1}$。\n  - $x_{\\mathrm{true},2} \\in \\mathbb{R}^5$，其项为 $x_{\\mathrm{true},2} = [1,-1,1,-1,1]^\\top$。\n  - $\\alpha = 10^{-12}$ 且对于 $i \\in \\{1,\\dots,10\\}$ 有 $\\varepsilon_i = \\alpha \\cdot (-1)^i$，因此 $b_2 = A_2 x_{\\mathrm{true},2} + \\varepsilon$。\n- 测试用例 3（希尔伯特矩阵，更大维度，更病态）：\n  - $A_3 = H \\in \\mathbb{R}^{24 \\times 12}$，其中对于 $i \\in \\{1,\\dots,24\\}$, $j \\in \\{1,\\dots,12\\}$ 有 $H_{ij} = \\tfrac{1}{i + j - 1}$。\n  - $x_{\\mathrm{true},3} \\in \\mathbb{R}^{12}$，其项为 $x_{\\mathrm{true},3}(j) = 1$（若 $j$ 为奇数）和 $x_{\\mathrm{true},3}(j) = -1$（若 $j$ 为偶数），其中 $j \\in \\{1,\\dots,12\\}$。\n  - $\\alpha = 10^{-12}$ 且对于 $i \\in \\{1,\\dots,24\\}$ 有 $\\varepsilon_i = \\alpha \\cdot (-1)^i$，因此 $b_3 = A_3 x_{\\mathrm{true},3} + \\varepsilon$。\n- 测试用例 4（希尔伯特矩阵，单列边界情况）：\n  - $A_4 = H \\in \\mathbb{R}^{10 \\times 1}$，其中对于 $i \\in \\{1,\\dots,10\\}$ 有 $H_{i1} = \\tfrac{1}{i}$。\n  - $x_{\\mathrm{true},4} = [1]$。\n  - $\\alpha = 10^{-12}$ 且对于 $i \\in \\{1,\\dots,10\\}$ 有 $\\varepsilon_i = \\alpha \\cdot (-1)^i$，因此 $b_4 = A_4 x_{\\mathrm{true},4} + \\varepsilon$。\n\n程序输出格式规范：\n\n- 您的程序必须在标准输出上产生且仅产生一行，其中包含列表 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是为测试用例 k 定义的比率。不要打印任何额外的文本或行。此问题不涉及角度和物理单位，因此不需要进行单位转换。", "solution": "任务是求解线性最小二乘问题，即寻找一个向量 $x \\in \\mathbb{R}^n$，使得对于给定的矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）和向量 $b \\in \\mathbb{R}^m$，目标函数 $f(x) = \\frac{1}{2}\\lVert A x - b \\rVert_2^2$ 最小。我们将从基本原理出发推导正规方程，实现一个基于它们的求解器，将其数值稳定性与更稳健的基于 QR 的方法进行对比，并在包括病态希尔伯特矩阵在内的一系列问题上对两者进行测试。\n\n**1. 正规方程的推导**\n\n线性最小二乘问题的解是使目标函数 $f(x)$ 最小化的向量 $x$。由于 $f(x)$ 是一个可微的凸函数，其最小值点可以通过找到梯度为零的点来获得。问题指定使用向量函数平方范数梯度的一般规则：$g(x) = \\frac{1}{2}\\lVert r(x) \\rVert_2^2$ 的梯度是 $\\nabla g(x) = J(x)^\\top r(x)$，其中 $J(x)$ 是残差函数 $r(x)$ 的雅可比矩阵。\n\n对于线性最小二乘问题，残差函数是 $r(x) = Ax - b$。该函数关于 $x$ 是线性的。为了找到其雅可比矩阵，我们考虑 $x$ 中的一个微小扰动 $\\delta x$ 如何影响 $r(x)$：\n$$r(x + \\delta x) = A(x + \\delta x) - b = (Ax - b) + A \\delta x = r(x) + A \\delta x$$\n雅可比矩阵 $J(x)$ 是线性逼近 $r(x)$ 变化的矩阵，即 $r(x + \\delta x) \\approx r(x) + J(x) \\delta x$。通过直接比较， $r(x) = Ax - b$ 的雅可比矩阵是常数矩阵 $J(x) = A$。\n\n现在，我们将提供的梯度规则应用于我们的目标函数 $f(x)$：\n$$\\nabla f(x) = J(x)^\\top r(x) = A^\\top (Ax - b)$$\n$x$ 是最小化点的必要条件是 $x$ 处的梯度必须为零向量：\n$$\\nabla f(x) = 0$$\n这导出了驻点条件：\n$$A^\\top (Ax - b) = 0$$\n重新整理此方程得到**正规方程**组：\n$$A^\\top A x = A^\\top b$$\n这是一个包含 n 个未知数的 n 个线性方程的方阵系统。矩阵 $C = A^\\top A$ 是对称的。如果 $A$ 的列是线性无关的（即 $A$ 具有满列秩，这对于超定最小二乘问题是典型情况），那么 $A^\\top A$ 也是正定的，因此是可逆的，从而保证 $x$ 有唯一解。\n\n**2. 数值稳定性与求解方法**\n\n**正规方程法：**\n此方法包括两个步骤：\n1.  构造矩阵 $A^\\top A$ 和向量 $A^\\top b$。\n2.  求解得到的 $n \\times n$ 线性系统 $(A^\\top A) x = (A^\\top b)$ 以得到 $x$。\n\n该方法的主要数值缺陷与矩阵 $A^\\top A$ 的条件数有关。矩阵 $M$ 的 2-范数条件数（记为 $\\kappa_2(M)$）衡量了系统 $My=d$ 的解对 $M$ 和 $d$ 中扰动的敏感度。对于正规方程，系统的条件数是 $\\kappa_2(A^\\top A)$。可以证明 $\\kappa_2(A^\\top A) = (\\kappa_2(A))^2$。\n\n如果 $A$ 是病态的，即 $\\kappa_2(A)$ 很大，那么 $\\kappa_2(A^\\top A)$ 将会大得多。例如，如果 $\\kappa_2(A) = 10^4$，那么 $\\kappa_2(A^\\top A) = 10^8$。求解具有如此大条件数的系统可能会导致浮点运算中存在的舍入误差被显著放大，导致计算出的解 $x_{\\mathrm{NE}}$ 远非真正的最小化点。\n\n**QR 分解法：**\n一种数值上更稳定的方法避免了显式构造 $A^\\top A$。这可以通过使用 $A$ 的正交三角 (QR) 分解来实现。对于 $A \\in \\mathbb{R}^{m \\times n}$ 且 $m \\ge n$ 并具有满列秩，我们可以计算一个“瘦”QR 分解：\n$$A = QR$$\n其中 $Q \\in \\mathbb{R}^{m \\times n}$ 具有标准正交列（$Q^\\top Q = I_n$，其中 $I_n$ 是 $n \\times n$ 的单位矩阵），而 $R \\in \\mathbb{R}^{n \\times n}$ 是一个对角线元素为正的上三角矩阵。\n\n将此代入目标函数：\n$$\\lVert Ax - b \\rVert_2^2 = \\lVert QRx - b \\rVert_2^2$$\n我们可以将残差向量 $QRx - b$ 乘以任何正交矩阵而不改变其 2-范数。尽管 $Q$ 不是方阵，我们可以利用性质 $Q^\\top Q = I_n$。$\\lVert Ax-b \\rVert_2$ 的最小化点 $x$ 是正规方程 $A^\\top A x = A^\\top b$ 的解。代入 $A=QR$：\n$$(QR)^\\top (QR) x = (QR)^\\top b$$\n$$R^\\top Q^\\top Q R x = R^\\top Q^\\top b$$\n$$R^\\top I_n R x = R^\\top Q^\\top b$$\n$$R^\\top R x = R^\\top Q^\\top b$$\n由于 $R$ 是可逆的（因为 $A$ 是满秩的），$R^\\top$ 也是可逆的。我们可以通过左乘 $(R^\\top)^{-1}$ 得到：\n$$Rx = Q^\\top b$$\n这是一个关于 $x$ 的上三角系统，可以使用回代法高效、准确地求解。该系统的条件数是 $\\kappa_2(R)$。可以证明 $\\kappa_2(R) = \\kappa_2(A)$。因此，QR 方法求解的是一个与原始矩阵 $A$ 具有相同条件数的系统，避免了正规方程中出现的平方效应。这使得当 $A$ 病态时，QR 方法在对抗舍入误差方面显著更为稳健。\n\n**3. 实现与测试策略**\n\n我们将实现三个核心函数：\n- `construct_hilbert(m, n)`：创建一个 $m \\times n$ 的希尔伯特矩阵 $H$，其项为 $H_{ij} = 1/(i+j-1)$，对于基于 1 的索引 i, j。\n- `solve_normal_equations(A, b)`：通过构造和求解 $A^\\top A x = A^\\top b$ 来解决最小二乘问题，使用像 `numpy.linalg.solve` 这样的标准直接求解器。\n- `solve_qr(A, b)`：通过计算 $A$ 的瘦 QR 分解并求解 $Rx = Q^\\top b$ 来解决最小二乘问题。将使用带 `mode='reduced'` 的 `numpy.linalg.qr` 进行分解。\n\n程序将遍历四个指定的测试用例。对于每个案例，它将：\n1.  构造矩阵 $A$（自定义矩阵或希尔伯特矩阵）。\n2.  定义真实解 $x_{\\mathrm{true}}$。\n3.  构建右侧向量 $b = A x_{\\mathrm{true}} + \\varepsilon$，其中 $\\varepsilon$ 是一个小的、确定性的扰动向量。\n4.  使用正规方程法（$x_{\\mathrm{NE}}$）和 QR 方法（$x_{\\mathrm{QR}}$）计算解。\n5.  计算每个解的前向相对误差：$e(x) = \\lVert x - x_{\\mathrm{true}} \\rVert_2 / \\lVert x_{\\mathrm{true}} \\rVert_2$。\n6.  计算这些误差的比率 $r = e(x_{\\mathrm{NE}}) / e(x_{\\mathrm{QR}})$。\n\n最终输出将是这些比率的列表，这将展示正规方程法在 $A$ 的条件数增加时精度的下降情况，特别是在希尔伯特矩阵测试用例中。对于良态问题（案例 1）和特殊的单列情况（案例 4），该比率预计接近 1，表明精度相当。对于病态的希尔伯特矩阵（案例 2 和 3），该比率预计将显著大于 1，突显了基于 QR 的方法卓越的数值稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_hilbert(m, n):\n    \"\"\"\n    Constructs an m x n Hilbert matrix.\n    The entry (i, j) is 1 / (i + j - 1), using 1-based indexing.\n    \"\"\"\n    i = np.arange(1, m + 1).reshape(m, 1)\n    j = np.arange(1, n + 1).reshape(1, n)\n    return 1.0 / (i + j - 1)\n\ndef solve_normal_equations(A, b):\n    \"\"\"\n    Solves the linear least squares problem min ||Ax - b||_2\n    using the normal equations A.T*A*x = A.T*b.\n    \"\"\"\n    AtA = A.T @ A\n    Atb = A.T @ b\n    x_ne = np.linalg.solve(AtA, Atb)\n    return x_ne\n\ndef solve_qr(A, b):\n    \"\"\"\n    Solves the linear least squares problem min ||Ax - b||_2\n    using a thin QR factorization A = QR, solving Rx = Q.T*b.\n    \"\"\"\n    Q, R = np.linalg.qr(A, mode='reduced')\n    Qtb = Q.T @ b\n    x_qr = np.linalg.solve(R, Qtb)\n    return x_qr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the required output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_spec = [\n        # Test case 1: well-conditioned, small\n        {\n            'm': 3, 'n': 2, 'alpha': 1e-12,\n            'A_def': lambda m, n: np.array([[1., 0.], [0., 1.], [1., 1.]]),\n            'xtrue_def': lambda n: np.array([1., -1.])\n        },\n        # Test case 2: Hilbert, moderate dimensions, ill-conditioned\n        {\n            'm': 10, 'n': 5, 'alpha': 1e-12,\n            'A_def': construct_hilbert,\n            'xtrue_def': lambda n: np.array([1. if (i % 2) == 0 else -1. for i in range(n)])\n        },\n        # Test case 3: Hilbert, larger dimensions, more ill-conditioned\n        {\n            'm': 24, 'n': 12, 'alpha': 1e-12,\n            'A_def': construct_hilbert,\n            'xtrue_def': lambda n: np.array([1. if (i % 2) == 0 else -1. for i in range(n)])\n        },\n        # Test case 4: Hilbert, edge case with one column\n        {\n            'm': 10, 'n': 1, 'alpha': 1e-12,\n            'A_def': construct_hilbert,\n            'xtrue_def': lambda n: np.array([1.])\n        }\n    ]\n\n    ratios = []\n\n    for case in test_cases_spec:\n        m, n, alpha = case['m'], case['n'], case['alpha']\n        \n        # 1. Construct matrix A\n        A = case['A_def'](m, n)\n        \n        # 2. Construct true solution xtrue\n        xtrue = case['xtrue_def'](n)\n        \n        # 3. Construct the right-hand side b = A*xtrue + epsilon\n        # Perturbation epsilon_i = alpha * (-1)^i for i = 1, ..., m\n        epsilon = alpha * ((-1.0)**np.arange(1, m + 1))\n        b = A @ xtrue + epsilon\n        \n        # 4. Solve using both methods\n        x_ne = solve_normal_equations(A, b)\n        x_qr = solve_qr(A, b)\n        \n        # 5. Compute forward relative errors\n        norm_xtrue = np.linalg.norm(xtrue)\n        \n        err_ne = np.linalg.norm(x_ne - xtrue) / norm_xtrue\n        err_qr = np.linalg.norm(x_qr - xtrue) / norm_xtrue\n        \n        # 6. Compute and store the ratio of errors\n        # Handle the unlikely case of err_qr being zero to avoid division by zero\n        if err_qr == 0.0:\n            if err_ne == 0.0:\n                ratio = 1.0\n            else:\n                ratio = float('inf')\n        else:\n            ratio = err_ne / err_qr\n            \n        ratios.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, ratios))}]\")\n\nsolve()\n```", "id": "3257364"}]}