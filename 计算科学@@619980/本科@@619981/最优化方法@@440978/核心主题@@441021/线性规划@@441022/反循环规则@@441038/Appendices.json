{"hands_on_practices": [{"introduction": "理解算法潜在的失效模式，最好的方法莫过于亲眼见证它的发生。本练习将提供一个经典的线性规划问题，该问题以导致单纯形法循环而闻名。通过编程实现标准的 Dantzig 主元选择法则和 Bland 的反循环法则，你将直接观察到不当的主元选择如何导致算法陷入无限循环，以及一个精心设计的规则如何保证算法最终收敛 [@problem_id:3117274]。", "problem": "要求您实现一个线性规划（LP）单纯形法的模拟，以研究不同主元选择规则下的退化和循环现象。此问题的基础是线性规划的典范形式：在满足线性等式约束和非负性条件下，最大化一个线性目标函数；以及单纯形法，该方法通过主元变换从一个基本可行解（BFS）移动到另一个，直到满足最优性条件。在线性规划的标准形式中，问题表述为在约束条件 $A x = b$ 和 $x \\ge 0$ 下最大化 $c^\\top x$，这种形式是通过引入松弛变量从 $\\le$ 约束得到的。单纯形法使用一个由 $A$ 的列组成的基矩阵 $B$，并计算当前的基本可行解 $x_B = B^{-1} b$；它为非基变量计算判别数 $r_N = c_N - c_B^\\top B^{-1} N$，如果 $r_N$ 的某个分量为正（对于最大化问题），则执行一次主元变换。当一个或多个基变量等于 $0$ 时，就会出现退化现象。循环指的是在目标函数值没有改善的情况下重复访问相同的基，这通常是由退化主元变换引起的。本问题考虑两种主元规则：Dantzig 规则（选择具有最大正判别数的变量作为入基变量）和 Bland 规则（在具有正判别数的变量中，选择下标最小的作为入基变量；在满足最小比率测试的变量中，选择下标最小的作为出基变量）。您必须实现这两种主元规则，并通过检测重复的基来实证检验循环现象。\n\n实现一个程序，该程序能够：\n- 通过添加松弛变量，将每个以 $\\le$ 形式给出的线性规划问题转换为标准等式形式。\n- 使用 Dantzig 规则和 Bland 规则模拟单纯形法。在每次迭代中，计算 $x_B = B^{-1} b$、对偶向量 $y^\\top = c_B^\\top B^{-1}$、判别数 $r_N = c_N - y^\\top N$，根据指定规则选择入基变量，通过 $B d_B = A_{\\cdot,e}$ 计算方向 $d_B$，对 $d_{B,i} > 0$ 的分量执行最小比率测试以选择出基变量，然后进行主元变换。当所有判别数都为非正（最优性）、问题无界（沿某个判别数为正的方向上没有正的 $d_{B,i}$）或当先前出现过的基再次出现（循环）时，停止。对于正值和相等性比较，使用数值容差 $\\varepsilon = 10^{-9}$。\n- 对于每个测试用例，报告在使用 Dantzig 规则和 Bland 规则下是否检测到循环（布尔值），以及每种规则终止时的最终目标函数值 $c^\\top x$（浮点数）。如果检测到循环，则报告检测到循环时的目标函数值。如果检测到无界，则将目标函数值报告为 $0.0$。\n\n测试套件：\n提供三个带有决策变量非负约束的 $\\le$ 形式的线性规划问题：\n\n- 案例 1（退化问题，已知在 Dantzig 规则下会循环，而 Bland 规则可以避免）：\n  最大化 $10 x_1 - 57 x_2 - 9 x_3 - 24 x_4$，约束条件为\n  $0.5 x_1 - 5.5 x_2 - 2.5 x_3 + 9 x_4 \\le 0$，\n  $0.5 x_1 - 1.5 x_2 - 0.5 x_3 + 1 x_4 \\le 0$，\n  $1 x_1 \\le 1$，\n  以及 $x_1, x_2, x_3, x_4 \\ge 0$。\n  此问题引入 $3$ 个松弛变量，且 $b = [0, 0, 1]^\\top$。\n\n- 案例 2（非退化问题，简单的有界问题）：\n  最大化 $3 x_1 + 2 x_2$，约束条件为\n  $1 x_1 + 1 x_2 \\le 4$，\n  $1 x_1 \\le 2$，\n  $1 x_2 \\le 3$，\n  以及 $x_1, x_2 \\ge 0$。\n\n- 案例 3（初始时入基变量的判别数存在相等情况的边界案例）：\n  最大化 $1 x_1 + 1 x_2$，约束条件为\n  $1 x_1 + 1 x_2 \\le 1$，\n  $1 x_1 \\le 0.5$，\n  $1 x_2 \\le 0.5$，\n  以及 $x_1, x_2 \\ge 0$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例的结果应为一个形式为 $[d\\_cycle, b\\_cycle, d\\_opt, b\\_opt]$ 的列表，其中 $d\\_cycle$ 和 $b\\_cycle$ 是布尔值，分别表示在 Dantzig 规则和 Bland 规则下是否发生循环，$d\\_opt$ 和 $b\\_opt$ 是浮点数，分别给出 Dantzig 规则和 Bland 规则下的最终目标函数值。例如，输出应类似于 $[[\\text{True},\\text{False},10.0,10.0],[\\dots],[\\dots]]$。浮点数必须以十进制形式打印；本问题不涉及物理单位。", "solution": "我们从线性规划（LP）的基本形式开始。在线性规划的标准形式中，问题旨在约束条件 $A x = b$ 和 $x \\ge 0$ 下最大化 $c^\\top x$。任何形如 $M x \\le b$ 且 $x \\ge 0$ 的约束系统都可以通过引入松弛变量 $s \\ge 0$（使得 $M x + s = b$）转换为标准形式。这会产生一个等式系统 $A x' = b$，其中 $x' = \\begin{bmatrix} x \\\\ s \\end{bmatrix}$，$A = [M \\ \\ I]$，以及增广的目标向量 $c' = \\begin{bmatrix} c \\\\ 0 \\end{bmatrix}$。基本可行解（BFS）是通过从 $A$ 中选取 $m$ 列（$m$ 等于约束的数量）组成一个基 $B$，求解 $x_B = B^{-1} b$，将非基变量 $x_N$ 设为 $0$，并要求 $x_B \\ge 0$ 来获得的。在标准初始化中，松弛变量构成基，因为这对应于单位矩阵，因此只要 $b \\ge 0$，就存在一个基本可行解。\n\n单纯形法通过主元变换向前推进：从非基变量集合中选择一个入基变量，从基变量集合中选择一个出基变量。选择的指导原则依赖于判别数。设 $B$ 为基矩阵，$N$ 为由非基变量对应的列组成的 $A$ 的子矩阵。将 $c_B$ 和 $c_N$ 表示为目标系数的相应划分。当前解为 $x_B = B^{-1} b$。目标函数可以表示为：\n$$\nz = c^\\top x = c_B^\\top x_B + c_N^\\top x_N = c_B^\\top B^{-1} b + \\left( c_N^\\top - c_B^\\top B^{-1} N \\right) x_N,\n$$\n因此判别数（在最大化问题中也称为相对利润）为：\n$$\nr_N = c_N - c_B^\\top B^{-1} N.\n$$\n如果 $r_N$ 的所有分量都为非正，那么增加任何非基变量都不能改善目标函数，当前的基本可行解就是最优解。如果某个 $r_j > 0$，那么增加相应的非基变量 $x_j$ 可以增加 $z$，该变量就是入基的候选变量。对基变量的影响由满足以下条件的方向 $d_B$ 决定：\n$$\nB d_B = A_{\\cdot,j},\n$$\n这样，将 $x_j$ 增加 $\\theta$ 会使基变量变为 $x_B(\\theta) = x_B - \\theta d_B$。最小比率测试通过将 $\\theta$ 限制为满足 $x_B(\\theta) \\ge 0$ 的最大非负值来确保可行性，该值由以下公式给出：\n$$\n\\theta^\\star = \\min_{i: d_{B,i} > 0} \\frac{x_{B,i}}{d_{B,i}}.\n$$\n如果不存在分量 $d_{B,i} > 0$，则问题在 $x_j$ 方向上是无界的，因为增加 $x_j$ 会在不违反可行性的情况下改善目标函数。\n\n退化指的是一个或多个基变量等于零的情况。在退化主元变换中，最小比率 $\\theta^\\star$ 等于零，导致目标函数值没有变化，并可能使算法重新访问先前见过的基。循环是算法重复访问同一个基（以及同一个基本可行解）的现象，从而在不改善目标函数的情况下进入无限循环。所研究的主元规则有：\n- Dantzig 规则：在所有 $r_j > 0$ 的非基变量中，选择 $r_j$ 最大的变量作为入基变量；执行比率测试，并选择第一个（或任何一致的）达到最小比率的基变量作为出基变量。\n- Bland 规则：在所有 $r_j > 0$ 的非基变量中，选择下标最小的一个作为入基变量；在所有达到最小比率的下标中，选择下标最小的基变量作为出基变量。\n\nBland 规则通过对基序列强制实施字典序单调性来防止循环，这一结果得到了单纯形法中主元选择理论的支持：当入基和出基变量的平局都由最小下标打破时，算法不会重新访问先前见过的基。\n\n算法设计：\n- 输入：对于每个测试用例，一个矩阵 $M$、向量 $b$ 和原始决策变量的目标系数向量 $c$，以及非负约束 $x \\ge 0$。\n- 转换为标准形式：构造 $A = [M \\ \\ I_m]$ 和 $c' = \\begin{bmatrix} c \\\\ 0_m \\end{bmatrix}$，初始基由 $m$ 个松弛变量（下标从 $n$ 到 $n + m - 1$）组成。\n- 迭代：\n  1. 通过选择 $A$ 中与当前基对应的列来构成 $B$。通过求解 $B x_B = b$ 计算 $x_B = B^{-1} b$。通过求解 $B^\\top y = c_B$ 计算 $y$，从而得到 $y^\\top = c_B^\\top B^{-1}$。\n  2. 计算 $r_N = c_N - y^\\top N$。如果 $\\max_j r_{N,j} \\le \\varepsilon$，则声明为最优解。\n  3. 选择入基变量：\n     - Dantzig 规则：选择满足 $r_{N,j} > \\varepsilon$ 且具有最大 $r_{N,j}$ 的下标 $j$；一致地处理平局情况（例如，选择第一个遇到的）。\n     - Bland 规则：在非基集合中选择满足 $r_{N,j} > \\varepsilon$ 的最小下标 $j$。\n  4. 通过求解 $B d_B = A_{\\cdot,j}$ 计算 $d_B$。对 $d_{B,i} > \\varepsilon$ 的分量执行比率测试：$\\theta_i = x_{B,i} / d_{B,i}$，并选择最小化 $\\theta_i$ 的出基下标；处理平局：\n     - Dantzig 规则：第一个遇到的最小值。\n     - Bland 规则：在最小值中，选择最小的基变量下标。\n  5. 主元变换：用入基变量替换出基变量，并更新基和非基集合。\n  6. 循环检测：维护一个已访问基的集合（表示为变量下标的有序元组）。如果新的基已经存在于集合中，则声明发生循环。\n- 终止：返回是否检测到循环以及最终的目标函数值 $c^\\top x$。如果发生循环，在退化主元变换期间目标函数值保持不变；报告检测到循环时的值。如果检测到无界（没有 $d_{B,i} > 0$），则报告 $0.0$。\n\n测试用例和预期现象：\n- 案例 1（Beale 的循环示例）：给定 $c = [10, -57, -9, -24]$，$b = [0, 0, 1]^\\top$ 以及给定的约束，初始基本可行解是退化的（$x = 0$，松弛变量 $s_1 = 0$，$s_2 = 0$，$s_3 = 1$）。在 Dantzig 规则下，一系列退化主元变换可能会重新访问先前遇到的基，从而表现出循环现象；而在 Bland 规则下，主元变换序列会避免循环并达到最优解。\n- 案例 2：一个简单的有界非退化线性规划问题，其中 $c = [3, 2]$，$b = [4, 2, 3]^\\top$；两种规则都应收敛到最优值，通常在 $x_1 = 2$，$x_2 = 2$ 处，目标函数值 $z = 10$，且不发生循环。\n- 案例 3：一个初始时入基变量判别数存在平局的边界情况（$c = [1, 1]$，$b = [1, 0.5, 0.5]^\\top$）；两种规则仍应避免循环，最优解为 $x_1 = 0.5$，$x_2 = 0.5$，目标函数值 $z = 1$。\n\n最终的程序为这三个测试用例实现了上述算法，并以指定格式输出结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nEPS = 1e-9\nMAX_ITERS = 200\n\ndef simplex(M, b, c, rule=\"dantzig\"):\n    \"\"\"\n    Solve a maximization LP given in <= form with nonnegativity: M x <= b, x >= 0, maximize c^T x.\n    Adds slacks to get equality, runs simplex with specified pivot rule.\n    rule: \"dantzig\" or \"bland\".\n    Returns: (cycled: bool, optimal_value: float)\n    \"\"\"\n    M = np.array(M, dtype=float)\n    b = np.array(b, dtype=float)\n    c = np.array(c, dtype=float)\n\n    m, n = M.shape  # m constraints, n decision variables\n\n    # Build standard-form A = [M | I], augmented c' = [c, 0_m]\n    A = np.hstack([M, np.eye(m, dtype=float)])\n    c_full = np.concatenate([c, np.zeros(m, dtype=float)])\n\n    # Initial basis: slacks\n    basis = list(range(n, n + m))\n    nonbasis = list(range(0, n))\n\n    visited_bases = set()\n    visited_bases.add(tuple(basis))\n\n    cycled = False\n    z_value = 0.0\n\n    for _ in range(MAX_ITERS):\n        B = A[:, basis]  # m x m\n        N = A[:, nonbasis]  # m x (n_nonbasic)\n\n        # Solve for x_B and y\n        try:\n            x_B = np.linalg.solve(B, b)\n        except np.linalg.LinAlgError:\n            # Singular basis; treat as cycle or fail-safe\n            cycled = True\n            break\n        c_B = c_full[basis]\n        c_N = c_full[nonbasis]\n        try:\n            y = np.linalg.solve(B.T, c_B)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Reduced costs r_N = c_N - y^T N\n        r_N = c_N - (y @ N)\n\n        # Check optimality (no positive reduced costs)\n        max_r = np.max(r_N) if r_N.size > 0 else -np.inf\n        if max_r <= EPS:\n            # Optimal; compute objective z = c_B^T x_B\n            z_value = float(c_B @ x_B)\n            cycled = False\n            break\n\n        # Select entering variable\n        enter_idx_in_N = None\n        if rule == \"dantzig\":\n            # Choose index with largest positive reduced cost\n            # If multiple, choose first encountered\n            candidates = [(j, r) for j, r in enumerate(r_N) if r > EPS]\n            if not candidates:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n            # Find argmax r\n            max_val = -np.inf\n            for j, r in candidates:\n                if r > max_val:\n                    max_val = r\n                    enter_idx_in_N = j\n        elif rule == \"bland\":\n            # Choose smallest variable index in nonbasis with r > EPS\n            enter_idx_in_N = None\n            min_var_index = None\n            for j, r in enumerate(r_N):\n                if r > EPS:\n                    var_index = nonbasis[j]\n                    if (min_var_index is None) or (var_index < min_var_index):\n                        min_var_index = var_index\n                        enter_idx_in_N = j\n            if enter_idx_in_N is None:\n                z_value = float(c_B @ x_B)\n                cycled = False\n                break\n        else:\n            raise ValueError(\"Unknown rule: must be 'dantzig' or 'bland'.\")\n\n        entering_var = nonbasis[enter_idx_in_N]\n\n        # Compute direction d_B by solving B d_B = a_enter\n        a_enter = A[:, entering_var]\n        try:\n            d_B = np.linalg.solve(B, a_enter)\n        except np.linalg.LinAlgError:\n            cycled = True\n            break\n\n        # Ratio test\n        ratios = []\n        for i in range(m):\n            if d_B[i] > EPS:\n                ratios.append(x_B[i] / d_B[i])\n            else:\n                ratios.append(np.inf)\n        min_ratio = min(ratios) if ratios else np.inf\n        if np.isinf(min_ratio):\n            # Unbounded direction\n            z_value = 0.0\n            cycled = False\n            break\n\n        # Select leaving variable\n        leave_row = None\n        if rule == \"dantzig\":\n            # First encountered minimum ratio\n            for i in range(m):\n                if d_B[i] > EPS:\n                    if abs(ratios[i] - min_ratio) <= EPS:\n                        leave_row = i\n                        break\n        else:  # bland\n            # Among minima, choose smallest basic variable index\n            candidate_rows = []\n            for i in range(m):\n                if d_B[i] > EPS and abs(ratios[i] - min_ratio) <= EPS:\n                    candidate_rows.append(i)\n            if not candidate_rows:\n                z_value = 0.0\n                cycled = False\n                break\n            # Select smallest index of the basic variable\n            best_row = candidate_rows[0]\n            best_var_index = basis[best_row]\n            for i in candidate_rows[1:]:\n                var_idx = basis[i]\n                if var_idx < best_var_index:\n                    best_var_index = var_idx\n                    best_row = i\n            leave_row = best_row\n\n        leaving_var = basis[leave_row]\n\n        # Pivot: update basis and nonbasis\n        basis[leave_row] = entering_var\n        # Update nonbasis: replace entering with leaving\n        # Keep nonbasis sorted for consistent behavior except Bland requires index ordering; we will reconstruct properly\n        nonbasis = [v for v in nonbasis if v != entering_var]\n        nonbasis.append(leaving_var)\n        # For Bland, maintain sorted nonbasis to enforce index ordering in selection\n        if rule == \"bland\":\n            nonbasis.sort()\n\n        # Check cycling: if basis repeats, declare cycle\n        basis_tuple = tuple(basis)\n        if basis_tuple in visited_bases:\n            cycled = True\n            # Objective at cycle detection\n            z_value = float(c_full[basis] @ x_B)\n            break\n        visited_bases.add(basis_tuple)\n\n        # Continue to next iteration\n\n    else:\n        # Max iterations reached; treat as cycle for safety\n        cycled = True\n        z_value = float(c_full[basis] @ x_B) if 'x_B' in locals() else 0.0\n\n    return cycled, z_value\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1: Beale's cycling example (degenerate)\n    M1 = np.array([\n        [0.5, -5.5, -2.5, 9.0],\n        [0.5, -1.5, -0.5, 1.0],\n        [1.0,  0.0,  0.0, 0.0]\n    ], dtype=float)\n    b1 = np.array([0.0, 0.0, 1.0], dtype=float)\n    c1 = np.array([10.0, -57.0, -9.0, -24.0], dtype=float)\n\n    # Case 2: Simple bounded non-degenerate\n    M2 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b2 = np.array([4.0, 2.0, 3.0], dtype=float)\n    c2 = np.array([3.0, 2.0], dtype=float)\n\n    # Case 3: Edge case with tie in entering reduced costs\n    M3 = np.array([\n        [1.0, 1.0],\n        [1.0, 0.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    b3 = np.array([1.0, 0.5, 0.5], dtype=float)\n    c3 = np.array([1.0, 1.0], dtype=float)\n\n    test_cases = [\n        (M1, b1, c1),\n        (M2, b2, c2),\n        (M3, b3, c3)\n    ]\n\n    results = []\n    for M, b, c in test_cases:\n        d_cycle, d_opt = simplex(M, b, c, rule=\"dantzig\")\n        b_cycle, b_opt = simplex(M, b, c, rule=\"bland\")\n        # Round floats to 6 decimals for stable output\n        d_opt_round = round(float(d_opt), 6)\n        b_opt_round = round(float(b_opt), 6)\n        results.append([d_cycle, b_cycle, d_opt_round, b_opt_round])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and floats are printed correctly in a single-line list of lists.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, float):\n            # Keep as decimal\n            return f\"{item}\"\n        else:\n            return str(item)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```", "id": "3117274"}, {"introduction": "循环现象并非仅仅是理论上的巧合，它与线性规划问题的一个内在属性——退化（degeneracy）——紧密相关。这个练习将带你从单个精心构造的例子走向统计性实验。你将编写一个程序，生成具有可控退化程度的随机线性规划问题，并测量在不同退化水平下循环发生的频率，从而为 Bland 法则等反循环规则的稳健性提供经验证据 [@problem_id:3098133]。", "problem": "要求您实现并运行一个计算实验，以比较在不同退化水平下，单纯形法在两种主元规则下的循环发生率。该研究必须在标准型线性规划的规范框架下进行。实验必须是完全可复现的，并且必须以单行输出的形式生成所要求的摘要。\n\n从以下基本概念开始：\n- 标准型线性规划问题是在等式约束和非负性条件下最大化一个目标函数：最大化 $c^{\\mathsf{T}} x$，约束条件为 $A x = b$, $x \\ge 0$。通过从 $A$ 中选择一个由 $m$ 个线性无关列组成的基（其中 $A$ 有 $m$ 行），解出基变量，并将非基变量设为 $0$，可以得到一个基本可行解 (BFS)。\n- 单纯形法通过主元变换从一个基本可行解移动到另一个：选择一个检验数为正的进基变量（对于最大化问题），通过最小比率检验选择一个出基变量，然后更新基。\n- 当最小比率为零导致步长为零时，会发生退化，这可能导致基的重复，并可能引发循环。\n- Bland 法则（一种抗循环规则）选择所有检验数为正的变量中索引最小的作为进基变量，并选择所有最小比率并列的变量中索引最小的作为出基变量。Bland 定理保证，使用此规则，单纯形法不会发生循环。\n\n您的任务：\n1) 具有受控退化水平的实例生成。\n- 在“带松弛变量的不等式”实例化中进行操作，以便可以通过右端项来控制退化。对于每个实例，生成一个具有严格正整数项的随机矩阵 $M \\in \\mathbb{R}^{m \\times n}$，一个右端项 $b \\in \\mathbb{R}^m_{\\ge 0}$，以及一个目标函数 $c \\in \\mathbb{R}^n$。\n- 使用松弛变量构建标准型：定义 $A = [M \\; I_m] \\in \\mathbb{R}^{m \\times (n+m)}$，增广决策向量 $x_{\\text{aug}} = [x; s] \\in \\mathbb{R}^{n+m}$，以及增广目标 $c_{\\text{aug}} = [c; 0_m] \\in \\mathbb{R}^{n+m}$。初始基是对应于松弛变量的索引集合，得到基本可行解 $x=0$, $s=b$。\n- 通过一个参数 $\\delta \\in [0,1]$ 控制退化，该参数指定右端项中恰好为零的项的比例。精确地说，将 $b$ 中恰好 $\\lfloor \\delta \\cdot m \\rfloor$ 个项设为 $0$，并将 $b$ 的所有其他项设为严格正整数。这直接控制了初始基本可行解中有多少个基松弛变量为零（初始退化）。\n\n2) 两种待比较的主元规则。\n- 朴素规则：在每次迭代中，选择任何具有最大正检验数的非基变量作为进基变量（通过选择最大索引来打破僵局），并通过最小比率检验选择出基变量（在并列的出基候选变量中通过选择最大索引来打破僵局）。\n- Bland 法则：在每次迭代中，选择具有严格正检验数的最小索引非基变量作为进基变量，并通过最小比率检验选择出基变量，其中通过最小索引来打破僵局。\n\n3) 实现要求。\n- 实现一个用于最大化问题的修正单纯形法，该方法从松弛基开始，并重复以下步骤：\n  a) 计算基变量的值 $x_B = B^{-1} b$ 和非基列 $a_j$ 的检验数 $r_j = c_j - c_B^{\\mathsf{T}} B^{-1} a_j$。\n  b) 当在固定的数值容差内没有 $r_j > 0$ 时，以最优性停止。\n  c) 如果对于所选的进基列，$B^{-1} a_j \\le 0$（分量级），则检测到无界性。\n  d) 使用 $d = B^{-1} a_j$ 执行最小比率检验，并计算 $\\theta = \\min \\{ x_{B,i} / d_i \\mid d_i > 0 \\}$；如果 $\\theta = 0$，则主元变换是退化的。\n- 使用严格的循环检测器：如果在运行期间基（作为变量索引的集合）重复出现，则声明发生循环。一旦检测到循环，立即停止。每次运行使用 $K$ 次迭代的硬性上限，以避免在错误情况下出现无限循环。\n- 数值容差：使用固定的容差 $\\varepsilon$ 来判断严格正性和并列条件，其中 $r_j > \\varepsilon$ 被视为正检验数，而 $d_i > \\varepsilon$ 被视为严格正的步长方向分量。\n\n4) 实验设计和测试套件。\n- 固定 $m = 4$，$n = 3$，迭代上限 $K = 200$，容差 $\\varepsilon = 10^{-12}$，以及每个退化水平的试验次数 $T = 40$。\n- 对于每次试验，通过将每个元素作为 $\\{1,2,3,4,5\\}$ 中的独立整数抽取来生成 $M$，确保 $M$ 的每一列都有严格为正的和，按照 $\\delta$ 的规定生成 $b$，并通过在 $\\{-2,-1,0,1,2,3\\}$ 中抽取独立整数来生成 $c$。\n- 使用随机种子 $2025$ 以确保可复现性。对于每个实例和每个 $\\delta$，从相同的初始基开始运行两种主元规则，并记录是否检测到循环。\n- 使用以下退化水平作为测试套件：$\\delta \\in \\{0.0, 0.5, 1.0\\}$。\n\n5) 要求输出。\n- 对于给定顺序中的每个 $\\delta$，汇总在朴素规则下和在 Bland 法则下检测到循环的试验次数（总共 $T$ 次）。最终输出必须是单行的 Python 风格列表之列表：\n  [[δ1, naive_cycles1, bland_cycles1],[δ2, naive_cycles2, bland_cycles2],[δ3, naive_cycles3, bland_cycles3]]\n其中每个 δi 是对应的退化水平（十进制数），每个计数是整数。\n- 您的程序必须为固定的测试套件（$\\delta \\in \\{0.0, 0.5, 1.0\\}$，$T = 40$，$m = 4$，$n = 3$，迭代上限 $K = 200$，容差 $\\varepsilon = 10^{-12}$，种子 $2025$）精确地生成一行此格式的输出。", "solution": "用户要求进行一个计算实验，以评估单纯形法中循环的发生率作为实例退化水平的函数。这需要实现带有两种不同主元规则的修正单纯形算法——一种易于产生循环的朴素规则和 Bland 的抗循环规则——并在具有受控退化水平的一组随机生成的线性规划（LP）实例上执行它们。\n\n解决方案的结构如下：\n1.  一个用于生成可复现的标准型 LP 实例的程序，其中初始退化水平由参数 $\\delta$ 控制。\n2.  一个修正单纯形法的实现，该实现包含一个严格的循环检测器和两种指定的主元规则。\n3.  一个编排脚本，根据指定的实验设计执行实验并生成最终的汇总统计数据。\n\n**1. 可复现的实例生成**\n\n为确保实验的可复现性，我们使用一个以指定种子 $2025$ 初始化的专用随机数生成器。每个 LP 实例的生成都遵循问题规范。一个实例由矩阵 $M \\in \\mathbb{R}^{m \\times n}$、右端项向量 $b \\in \\mathbb{R}^{m}$ 和目标函数系数 $c \\in \\mathbb{R}^{n}$ 定义，维度固定为 $m=4$ 和 $n=3$。\n\n-   矩阵 $M$ 用从集合 $\\{1, 2, 3, 4, 5\\}$ 中均匀抽取的整数填充。\n-   目标向量 $c$ 包含从 $\\{-2, -1, 0, 1, 2, 3\\}$ 中均匀抽取的整数。\n-   退化水平通过向量 $b$ 控制。参数 $\\delta \\in \\{0.0, 0.5, 1.0\\}$ 决定了 $b$ 中被设为 $0$ 的项的比例。具体来说，$\\lfloor \\delta \\cdot m \\rfloor$ 个项被设为 $0$，其余的 $m - \\lfloor \\delta \\cdot m \\rfloor$ 个项被设为严格正整数（从 $\\{1, ..., 10\\}$ 中抽取）。\n\n从这些组件出发，构建标准型 LP 问题：最大化 $c_{\\text{aug}}^{\\mathsf{T}} x_{\\text{aug}}$，约束条件为 $A x_{\\text{aug}} = b$ 和 $x_{\\text{aug}} \\ge 0$。增广矩阵是 $A = [M \\; I_m] \\in \\mathbb{R}^{m \\times (n+m)}$，增广决策向量是 $x_{\\text{aug}} \\in \\mathbb{R}^{n+m}$，增广成本向量是 $c_{\\text{aug}} = [c; 0_m] \\in \\mathbb{R}^{n+m}$。初始基选择为松弛变量集，对应于 $A$ 中的单位矩阵 $I_m$。初始基本可行解 (BFS) 是 $x=0$, $s=b$。$b$ 中零项的数量直接对应于这个初始 BFS 中退化的基变量的数量。\n\n**2. 修正单纯形法的实现**\n\n一个实现修正单纯形法的函数被设计用来求解这些实例。它接受一个实例 $(A, b, c_{\\text{aug}})$ 和一个主元规则作为输入。\n\n**核心算法与计算**\n该算法从一个 BFS 迭代到另一个。在每次迭代中，给定一个基矩阵 $B$（由基集 $B_{\\text{indices}}$ 索引的 $A$ 的列组成），计算以下量：\n-   基矩阵的逆， $B^{-1}$。\n-   基变量的值：$x_B = B^{-1} b$。\n-   单纯形乘子（对偶变量）：$y = c_B^{\\mathsf{T}} B^{-1}$，其中 $c_B$ 是基变量的目标系数。\n-   所有非基变量 $j$ 的检验数：$r_j = c_j - y^{\\mathsf{T}} a_j$。\n\n**循环检测**\n为了严格检测循环，在每次迭代开始时，存储构成基的索引集合 $B_{\\text{indices}}$。维护一个包含所有先前访问过的基（为进行规范表示，表示为排序后的索引元组）的历史记录。如果在历史记录中找到了当前的基，则检测到一个循环，算法终止。同时，强制执行 $K=200$ 的最大迭代次数限制作为安全措施。\n\n**主元规则实现**\n进基变量和出基变量的选择取决于所选的主元规则。所有浮点数比较都使用 $\\varepsilon = 10^{-12}$ 的数值容差。\n\n*   **进基变量选择**：如果一个非基变量 $j$ 的检验数 $r_j > \\varepsilon$，则它是进基的候选变量。\n    -   **朴素规则**：选择具有最大检验数的候选变量。通过选择索引最大的变量来打破僵局。\n    -   **Bland 法则**：选择索引最小的候选变量。\n\n*   **出基变量选择**：出基变量由最小比率检验确定。首先，计算进基变量 $j$ 的搜索方向 $d = B^{-1} a_j$。步长为 $\\theta = \\min \\{ x_{B,i} / d_i \\mid d_i > \\varepsilon \\}$。如果所有的 $d_i \\le \\varepsilon$，则问题是无界的。否则，出基候选变量是对应于达到这个最小比率 $\\theta$ 的索引 $i$ 的基变量。\n    -   **朴素规则**：如果最小比率存在并列情况，则选择候选变量中索引最大的变量出基。\n    -   **Bland 法则**：如果存在并列情况，则选择候选变量中索引最小的变量出基。\n\n如果最小比率 $\\theta$ 为零（或数值上接近零，即 $|\\theta|  \\varepsilon$），则主元变换是退化的。这种情况发生在值为 $0$ 的基变量被选为出基变量时，导致解空间中没有实际移动，这正是可能导致循环的机制。\n\n**3. 实验执行**\n\n主要的实验程序遍历指定的退化水平 $\\delta \\in \\{0.0, 0.5, 1.0\\}$。对于每个 $\\delta$，执行 $T=40$ 次试验。在每次试验中：\n1.  使用指定的参数和已设定种子的随机数生成器生成一个新的 LP 实例 $(M, b, c)$。\n2.  使用 'naive' 主元规则在此实例上运行单纯形求解器。如果求解器报告出现循环，则朴素规则的循环计数器加一。\n3.  在*同一个*实例上使用 'Bland's' 主元规则运行单纯形求解器。如果检测到循环，则 Bland 法则的循环计数器加一。\n\n在完成给定 $\\delta$ 的所有 $T=40$ 次试验后，记录结果——$[\\delta, \\text{naive\\_cycles}, \\text{bland\\_cycles}]$。根据 Bland 定理的保证，`bland_cycles` 的计数在所有情况下都应为 $0$，这可作为对实现正确性的验证。最终输出是所有测试的 $\\delta$ 值的结果汇总，格式化为单行的列表之列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef generate_instance(m, n, delta, rng):\n    \"\"\"\n    Generates a random LP instance (M, b, c) with controlled degeneracy.\n    \"\"\"\n    # Generate M with entries in {1, 2, 3, 4, 5}.\n    # rng.integers(low, high) is exclusive of high.\n    M = rng.integers(1, 6, size=(m, n))\n\n    # Generate c with entries in {-2, -1, 0, 1, 2, 3}.\n    c = rng.integers(-2, 4, size=n)\n\n    # Generate b with a specified fraction 'delta' of zero entries.\n    num_zeros = math.floor(delta * m)\n    \n    # Create an array of positive integers for the non-zero part.\n    b_pos_part = rng.integers(1, 11, size=m - num_zeros)\n    b_zero_part = np.zeros(num_zeros)\n    \n    b = np.concatenate((b_pos_part, b_zero_part))\n    rng.shuffle(b)\n    \n    return M, b.astype(float), c.astype(float)\n\n\ndef simplex_solver(M, b, c, pivot_rule, K, epsilon):\n    \"\"\"\n    Solves a linear program using the revised simplex method.\n    \n    Returns:\n        str: 'optimal', 'unbounded', 'cycle', 'max_iter', or an error string.\n    \"\"\"\n    m, n = M.shape\n    num_vars = n + m\n\n    # Form the augmented system A x_aug = b, max c_aug^T x_aug\n    A = np.hstack([M, np.eye(m)])\n    c_aug = np.concatenate([c, np.zeros(m)])\n\n    # Initial basis: slack variables\n    B_indices = list(range(n, num_vars))\n    \n    basis_history = set()\n\n    for _ in range(K):\n        # 1. Cycle Detection\n        current_basis_key = tuple(sorted(B_indices))\n        if current_basis_key in basis_history:\n            return 'cycle'\n        basis_history.add(current_basis_key)\n\n        # 2. Compute Revised Simplex quantities\n        B = A[:, B_indices]\n        try:\n            B_inv = np.linalg.inv(B)\n        except np.linalg.LinAlgError:\n            return 'singular_basis'\n        \n        c_B = c_aug[B_indices]\n        x_B = B_inv @ b\n        y = c_B @ B_inv\n\n        # 3. Find Entering Variable\n        N_indices = [i for i in range(num_vars) if i not in B_indices]\n        reduced_costs = {j: c_aug[j] - y @ A[:, j] for j in N_indices}\n        \n        candidates = {j: rc for j, rc in reduced_costs.items() if rc  epsilon}\n        if not candidates:\n            return 'optimal'\n\n        # Select entering variable based on pivot rule\n        if pivot_rule == 'naive':\n            max_rc = max(candidates.values())\n            tied_j = [j for j, rc in candidates.items() if abs(rc - max_rc)  epsilon]\n            j_enter = max(tied_j)\n        elif pivot_rule == 'bland':\n            j_enter = min(candidates.keys())\n        else:\n            raise ValueError(\"Invalid pivot rule\")\n\n        # 4. Find Leaving Variable (Minimum Ratio Test)\n        d = B_inv @ A[:, j_enter]\n        if np.all(d = epsilon):\n            return 'unbounded'\n\n        min_ratio = float('inf')\n        # First pass to find the minimum ratio\n        for i in range(m):\n            if d[i]  epsilon:\n                ratio = x_B[i] / d[i]\n                if ratio  min_ratio:\n                    min_ratio = ratio\n        \n        if min_ratio == float('inf'): # Should be caught by unbounded check, but for safety\n             return 'unbounded'\n        \n        # Second pass to find all ties for the minimum ratio\n        leaving_pos_candidates = []\n        for i in range(m):\n            if d[i]  epsilon:\n                 if abs((x_B[i] / d[i]) - min_ratio)  epsilon:\n                    leaving_pos_candidates.append(i)\n\n        if not leaving_pos_candidates:\n             # This can happen in highly degenerate cases, e.g. all x_B[i] are ~0 for d[i]0\n             # and floating point issues hide the min_ratio=0 case.\n             # We must select a leaving var if d has a positive component.\n             for i in range(m):\n                 if d[i]  epsilon:\n                     leaving_pos_candidates.append(i)\n\n        leaving_var_candidates = [B_indices[i] for i in leaving_pos_candidates]\n\n        # Select leaving variable based on pivot rule\n        if pivot_rule == 'naive':\n            j_leave = max(leaving_var_candidates)\n        elif pivot_rule == 'bland':\n            j_leave = min(leaving_var_candidates)\n\n        # 5. Update Basis\n        leave_pos = B_indices.index(j_leave)\n        B_indices[leave_pos] = j_enter\n\n    return 'max_iter'\n\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment and print the final result.\n    \"\"\"\n    # Experiment parameters\n    m, n = 4, 3\n    K = 200\n    epsilon = 1e-12\n    T = 40\n    seed = 2025\n    delta_suite = [0.0, 0.5, 1.0]\n\n    rng = np.random.default_rng(seed)\n\n    experiment_results = []\n    \n    for delta in delta_suite:\n        naive_cycles = 0\n        bland_cycles = 0\n        \n        for _ in range(T):\n            # Generate the same instance for both rules in each trial\n            M, b, c = generate_instance(m, n, delta, rng)\n\n            # Run with Naive Rule\n            result_naive = simplex_solver(M, b, c, 'naive', K, epsilon)\n            if result_naive == 'cycle':\n                naive_cycles += 1\n            \n            # Run with Bland's Rule\n            result_bland = simplex_solver(M, b, c, 'bland', K, epsilon)\n            if result_bland == 'cycle':\n                bland_cycles += 1\n        \n        experiment_results.append([delta, naive_cycles, bland_cycles])\n\n    # Final print statement in the exact required format.\n    # repr() gives the python-style list of lists string format.\n    # .replace(' ', '') removes all whitespace to match the specified format.\n    print(repr(experiment_results).replace(' ', ''))\n\nsolve()\n```", "id": "3098133"}]}