{"hands_on_practices": [{"introduction": "我们的第一个练习将引导你轻松进入路径跟踪方法的世界。我们将探讨在一个简单的超立方体（即 $\\ell_{\\infty}$ 范数球）内最小化线性函数的问题，这是许多应用中常见的约束形式 [@problem_id:3107367]。这些约束的特殊结构将极大地简化牛顿系统，让我们能专注于核心概念：对数障碍函数如何使迭代点远离边界，以及中心路径如何在可行集的内部优雅地弯曲，并仅在极限情况下才趋近于顶点。", "problem": "考虑在一个 $\\ell_{\\infty}$ 球上最小化线性目标函数的线性优化问题。设 $n \\in \\mathbb{N}$ 为维度，$r \\in \\mathbb{R}_{>0}$ 为球的半径，$c \\in \\mathbb{R}^{n}$ 为目标系数向量。该问题是在约束 $\\lVert x \\rVert_{\\infty} \\le r$ 下最小化 $c^{\\top} x$，这等价于对于 $i \\in \\{1,\\dots,n\\}$ 的 $2n$ 个线性不等式系统 $-r \\le x_i \\le r$。除非 $c$ 的某个分量为零，否则该线性规划的精确解位于超立方体 $\\{-r,r\\}^{n}$ 的一个顶点上。\n\n本任务是使用对数障碍和路径跟踪方法实现中心路径计算，然后数值上检验中心路径如何避开顶点，而精确解却位于顶点上。使用以下基本原理：\n- $\\ell_{\\infty}$ 球 $\\{x \\in \\mathbb{R}^{n} : \\lVert x \\rVert_{\\infty} \\le r\\}$ 是所有 $i \\in \\{1,\\dots,n\\}$ 的不等式 $x_i \\le r$ 和 $-x_i \\le r$ 的交集。\n- 不等式 $a^{\\top} x \\le b$ 的对数障碍是 $-\\log(b - a^{\\top} x)$，当松弛量 $b - a^{\\top} x$ 从正方向趋近于 $0$ 时，该值趋于 $+\\infty$。\n- 中心路径由严格凸的障碍增广目标函数对于 $t \\in \\mathbb{R}_{>0}$ 的唯一最小化点 $x(t)$ 定义，从一个内点开始，并对所有有限的 $t$ 保持在内部。\n\n从这些原则出发，不要使用任何快捷公式。从头开始推导所需内容。具体来说：\n1. 为 $\\ell_{\\infty}$ 球约束重构障碍问题。展示障碍如何增广目标函数 $c^{\\top} x$，并解释为什么结果函数仅在 $\\lVert x \\rVert_{\\infty}  r$ 时是严格凸且有限的。\n2. 推导中心路径点 $x(t)$ 的平稳性条件，并实现一个阻尼牛顿法来求解给定 $t$ 下得到的非线性系统。通过选择合适的步长，确保该方法在每次迭代中都保持可行性，即 $\\lVert x \\rVert_{\\infty}  r$。\n3. 仅使用关于箱体上线性目标函数的基本推理来计算原始线性规划的精确解 $x^{\\star}$。以科学合理的方式处理某些 $c_i = 0$ 的情况。\n4. 对于每个测试用例，在计算中心路径点 $x(t)$ 后，报告：\n   - 从 $x(t)$ 到超立方体 $\\{-r,r\\}^{n}$ 最近顶点的欧几里得距离，以实数形式表示。\n   - 目标间隙 $c^{\\top} x(t) - c^{\\top} x^{\\star}$，以实数形式表示。\n   - 一个布尔值，如果 $\\max_i |x_i(t)|  r$ 则为真，否则为假，表示对于所选的有限 $t$，中心路径点是否严格避开了边界（因此也避开了顶点）。\n\n您的程序必须实现阻尼牛顿法，并为以下参数值测试套件生成输出：\n- 测试用例 1：$n = 2$，$r = 0.2$，$c = (1,2)$，$t = 5$。\n- 测试用例 2：$n = 2$，$r = 0.2$，$c = (1,2)$，$t = 100$。\n- 测试用例 3：$n = 3$，$r = 0.1$，$c = (1,-0.5,3)$，$t = 20$。\n- 测试用例 4：$n = 3$，$r = 0.1$，$c = (1,0,1)$，$t = 20$。\n- 测试用例 5：$n = 2$，$r = 0.05$，$c = (-1,-1)$，$t = 50$。\n\n此问题中没有物理量，因此不需要物理单位。没有出现角度，因此不需要角度单位。不使用百分比。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $[d, g, b]$ 形式的列表，其中 $d$ 是到最近顶点的欧几里得距离，$g$ 是目标间隙，$b$ 是内部布尔值。例如，输出应为 $[[d_1,g_1,b_1],[d_2,g_2,b_2],\\dots]$ 的形式。", "solution": "该问题要求为 $\\ell_{\\infty}$ 球上的线性规划实现中心路径和路径跟踪方法。我们必须从第一性原理出发推导必要的组成部分，并使用阻尼牛顿法进行计算。\n\n### 1. 问题重构与障碍函数\n\n线性优化问题是在约束 $\\lVert x \\rVert_{\\infty} \\le r$ 下，最小化向量 $x \\in \\mathbb{R}^n$ 的目标函数 $f_0(x) = c^{\\top}x$。这里，$c \\in \\mathbb{R}^n$ 是目标系数向量，$r \\in \\mathbb{R}_{0}$ 是球的半径。\n\n约束 $\\lVert x \\rVert_{\\infty} \\le r$ 等价于 $2n$ 个线性不等式集合：\n$x_i \\le r, \\quad \\text{for } i \\in \\{1,\\dots,n\\}$\n$-x_i \\le r, \\quad \\text{for } i \\in \\{1,\\dots,n\\}$\n\n这个不等式集合的对数障碍函数 $\\Phi(x)$ 是各个障碍的总和：\n$$ \\Phi(x) = \\sum_{i=1}^{n} \\left( -\\log(r - x_i) - \\log(r - (-x_i)) \\right) = - \\sum_{i=1}^{n} \\log(r^2 - x_i^2) $$\n$\\Phi(x)$ 的定义域是对数函数的参数为正的点集，即对所有 $i$ 都有 $r^2 - x_i^2 > 0$。这个条件等价于对所有 $i$ 都有 $|x_i|  r$，或者 $\\lVert x \\rVert_{\\infty}  r$。这是可行集严格的内部。当任何 $x_i$ 趋近于 $r$ 或 $-r$ 时，项 $\\log(r^2 - x_i^2)$ 趋近于 $-\\infty$，因此 $\\Phi(x)$ 趋近于 $+\\infty$。\n\n中心路径由参数 $t > 0$ 的障碍增广目标函数的最小化点 $x(t)$ 定义：\n$$ F(x, t) = c^{\\top}x + \\frac{1}{t}\\Phi(x) = c^{\\top}x - \\frac{1}{t}\\sum_{i=1}^{n} \\log(r^2 - x_i^2) $$\n该函数仅在可行集的严格内部 $\\{x \\in \\mathbb{R}^n : \\lVert x \\rVert_{\\infty}  r\\}$ 上有定义且有限。\n\n为了证明 $F(x, t)$ 是严格凸的，我们分析其 Hessian 矩阵。目标函数 $c^{\\top}x$ 是线性的，因此是凸的。我们检验障碍项的凸性。设 $\\phi(x) = -\\frac{1}{t} \\sum_{i=1}^n \\log(r^2 - x_i^2)$。二阶偏导数为：\n$$ \\frac{\\partial^2 \\phi}{\\partial x_j \\partial x_k} = 0 \\quad \\text{for } j \\neq k $$\n$$ \\frac{\\partial^2 \\phi}{\\partial x_j^2} = -\\frac{1}{t} \\frac{\\partial^2}{\\partial x_j^2} \\log(r^2 - x_j^2) = -\\frac{1}{t} \\frac{\\partial}{\\partial x_j} \\left( \\frac{-2x_j}{r^2 - x_j^2} \\right) = \\frac{2}{t} \\frac{(r^2 - x_j^2) - x_j(-2x_j)}{(r^2-x_j^2)^2} = \\frac{2}{t} \\frac{r^2 + x_j^2}{(r^2 - x_j^2)^2} $$\n由于 $t>0$，$r>0$，且 $|x_j|  r$，项 $\\frac{\\partial^2 \\phi}{\\partial x_j^2}$ 是严格为正的。因此，$\\phi(x)$ 的 Hessian 矩阵是一个对角线上元素严格为正的对角矩阵，意味着它是正定的。因此，$\\phi(x)$ 是一个严格凸函数。一个凸函数 ($c^{\\top}x$) 和一个严格凸函数 ($\\phi(x)$) 的和是严格凸的。在凸集上的严格凸函数有唯一的最小化点。\n\n### 2. 中心路径平稳性与牛顿法\n\n中心路径上的点 $x(t)$ 是 $F(x, t)$ 的唯一最小化点。为了找到它们，我们将 $F(x,t)$ 关于 $x$ 的梯度设为零（平稳性条件）：\n$$ \\nabla_x F(x, t) = \\nabla_x \\left( c^{\\top}x - \\frac{1}{t}\\sum_{i=1}^{n} \\log(r^2 - x_i^2) \\right) = 0 $$\n梯度向量 $\\nabla_x F(x, t)$ 的分量为：\n$$ (\\nabla_x F(x, t))_j = c_j - \\frac{1}{t} \\frac{-2x_j}{r^2 - x_j^2} = c_j + \\frac{2x_j}{t(r^2 - x_j^2)} $$\n我们必须求解关于 $x$ 的非线性方程组 $\\nabla_x F(x, t) = 0$。阻尼牛顿法是用于此目的的迭代过程。从一个点 $x_k$ 开始，下一个迭代点是 $x_{k+1} = x_k + \\alpha_k \\Delta x_k$，其中 $\\Delta x_k$ 是牛顿步长，$\\alpha_k$ 是步长大小。\n\n牛顿步长 $\\Delta x_k$ 通过求解线性系统得到：\n$$ \\nabla^2 F(x_k, t) \\Delta x_k = - \\nabla F(x_k, t) $$\n其中 $\\nabla^2 F(x_k, t)$ 是 $F(x,t)$ 在 $x_k$ 处的 Hessian 矩阵。如前所推导，Hessian 矩阵是一个对角矩阵，其元素为：\n$$ (\\nabla^2 F(x, t))_{jj} = \\frac{2}{t} \\frac{r^2 + x_j^2}{(r^2 - x_j^2)^2} $$\n由于 Hessian 矩阵是对角的，系统解耦，牛顿步长的分量可以很容易地计算出来：\n$$ (\\Delta x_k)_j = - \\frac{(\\nabla F(x_k, t))_j}{(\\nabla^2 F(x_k, t))_{jj}} $$\n步长大小 $\\alpha_k \\in (0, 1]$ 通过回溯线搜索来选择，以确保两个条件：\n1.  **可行性**：下一个迭代点 $x_{k+1}$ 必须保持严格可行，即 $\\lVert x_k + \\alpha_k \\Delta x_k \\rVert_{\\infty}  r$。\n2.  **充分下降**：步长必须提供目标函数值的充分下降，通常通过 Armijo 条件来强制执行：$F(x_k + \\alpha_k \\Delta x_k, t) \\le F(x_k, t) + \\gamma \\alpha_k \\nabla F(x_k, t)^{\\top} \\Delta x_k$，其中 $\\gamma \\in (0, 0.5)$ 是一个小常数。\n\n迭代过程从一个严格可行的点开始，例如 $x_0 = 0$，并持续进行，直到梯度范数 $\\lVert \\nabla F(x_k, t) \\rVert_2$ 低于某个容差，表明已找到一个平稳点。\n\n### 3. 线性规划的精确解\n\n原始问题是在所有 $i$ 的约束 $-r \\le x_i \\le r$ 下最小化 $\\sum_{i=1}^n c_i x_i$。目标函数和约束是可分的。每个分量 $c_i x_i$ 对总和的贡献可以独立最小化。\n为了在区间 $[-r, r]$ 上最小化 $c_i x_i$：\n- 如果 $c_i > 0$，当 $x_i$ 取最小负值时达到最小值，所以 $x_i^{\\star} = -r$。\n- 如果 $c_i  0$，当 $x_i$ 取最大正值时达到最小值，所以 $x_i^{\\star} = r$。\n- 如果 $c_i = 0$，项 $c_i x_i$ 总是 $0$，因此任何 $x_i \\in [-r, r]$ 对此分量都是最优的。最优解的集合是超立方体的一个面。\n\n最优目标值 $p^{\\star} = c^{\\top}x^{\\star}$ 是唯一的，无论当某些 $c_i=0$ 时 $x^\\star$ 是否唯一。它可以计算如下：\n$$ p^{\\star} = \\sum_{i: c_i > 0} c_i(-r) + \\sum_{i: c_i  0} c_i(r) = -r \\sum_{i: c_i > 0} c_i + r \\sum_{i: c_i  0} c_i = -r \\left( \\sum_{i: c_i > 0} |c_i| + \\sum_{i: c_i  0} |c_i| \\right) = -r \\sum_{i=1}^n |c_i| $$\n\n### 4. 所需计算\n\n对于每个测试用例，在计算中心路径点 $x(t)$ 后，我们确定以下量：\n\n- **到最近顶点的欧几里得距离 ($d$)**：可行超立方体的顶点是 $\\{-r, r\\}^n$ 中的点。对于给定点 $x(t)$，欧几里得距离最近的顶点 $v^{\\star}$ 是通过将每个分量 $v^{\\star}_i$ 设置为 $-r$ 或 $r$ 中较近的一个来找到的。也就是说，$v^{\\star}_i = r \\cdot \\text{sign}(x_i(t))$（按惯例，$\\text{sign}(0)$ 为 $1$）。距离是 $d = \\lVert x(t) - v^{\\star} \\rVert_2$。\n\n- **目标间隙 ($g$)**：这是中心路径点的目标值与真实最优值之间的差：$g = c^{\\top}x(t) - p^{\\star}$。\n\n- **内部布尔值 ($b$)**：如果计算出的点 $x(t)$ 严格位于可行区域内部，即 $\\max_i |x_i(t)|  r$，则此布尔值为 `true`，否则为 `false`。对于有限的 $t$ 和正确的实现，此值应始终为 `true`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified optimization problems using a damped Newton method\n    for the central path and computes the required metrics.\n    \"\"\"\n    \n    test_cases = [\n        {'n': 2, 'r': 0.2, 'c': np.array([1, 2]), 't': 5},\n        {'n': 2, 'r': 0.2, 'c': np.array([1, 2]), 't': 100},\n        {'n': 3, 'r': 0.1, 'c': np.array([1, -0.5, 3]), 't': 20},\n        {'n': 3, 'r': 0.1, 'c': np.array([1, 0, 1]), 't': 20},\n        {'n': 2, 'r': 0.05, 'c': np.array([-1, -1]), 't': 50}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, r, c, t = case['n'], case['r'], case['c'], case['t']\n\n        # --- Damped Newton Method to find x(t) ---\n        \n        def F(x, t_p, c_p, r_p):\n            # Barrier augmented objective function\n            if np.max(np.abs(x)) >= r_p:\n                return np.inf\n            return c_p.T @ x - (1/t_p) * np.sum(np.log(r_p**2 - x**2))\n\n        def grad_F(x, t_p, c_p, r_p):\n            # Gradient of F\n            return c_p + (2 / t_p) * (x / (r_p**2 - x**2))\n\n        def Hess_F_diag(x, t_p, c_p, r_p):\n            # Diagonal of the Hessian of F\n            return (2 / t_p) * (r_p**2 + x**2) / (r_p**2 - x**2)**2\n\n        # Newton method parameters\n        x_t = np.zeros(n)\n        max_iter = 100\n        tolerance = 1e-9\n        \n        # Backtracking line search parameters\n        alpha = 1.0\n        beta = 0.5  # backtracking factor\n        gamma = 0.01 # Armijo condition parameter\n\n        for _ in range(max_iter):\n            grad = grad_F(x_t, t, c, r)\n            \n            # Check for convergence\n            if np.linalg.norm(grad)  tolerance:\n                break\n            \n            hess_diag = Hess_F_diag(x_t, t, c, r)\n            delta_x = -grad / hess_diag\n            \n            # Backtracking line search\n            alpha = 1.0\n            m = gamma * grad.T @ delta_x # Precompute for Armijo condition\n            f_x = F(x_t, t, c, r)\n            \n            while True:\n                x_new = x_t + alpha * delta_x\n                # Check feasibility first, as F is undefined outside\n                if np.max(np.abs(x_new)) >= r:\n                    alpha *= beta\n                    continue\n                # Check Armijo condition\n                if F(x_new, t, c, r) > f_x + alpha * m:\n                    alpha *= beta\n                else:\n                    break\n            \n            x_t += alpha * delta_x\n\n        # --- Exact Solution Calculation ---\n        p_star = -r * np.sum(np.abs(c))\n\n        # --- Compute required outputs ---\n        \n        # 1. Distance d to the nearest vertex\n        # The nearest vertex v_star has components r*sign(x_i)\n        v_star = np.where(x_t >= 0, r, -r)\n        d = np.linalg.norm(x_t - v_star)\n        \n        # 2. Objective gap g\n        g = c.T @ x_t - p_star\n        \n        # 3. Interior boolean b\n        b = np.max(np.abs(x_t))  r\n\n        results.append([d, g, b])\n\n    # --- Format final output string ---\n    formatted_results = []\n    for res in results:\n        # Format boolean as lowercase 'true'/'false'\n        formatted_res = f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\"\n        formatted_results.append(formatted_res)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3107367"}, {"introduction": "在初步探索的基础上，这个练习将带你深入了解通用线性规划内点方法的核心。你将实现一个原始-对偶路径跟踪算法，这是许多先进求解器的基础 [@problem_id:3107281]。这项练习要求你推导并求解关于受扰动KKT条件的完整牛顿系统，更重要的是，通过数值方法验证该理论的基石：对偶间隙与障碍参数 $\\mu$ 之间的线性关系。", "problem": "考虑一个具有非负约束的标准等式形式线性规划。原始问题是最小化 $c^{\\mathsf{T}} x$，约束条件为 $A x = b$ 和 $x \\ge 0$；对偶问题是最大化 $b^{\\mathsf{T}} y$，约束条件为 $A^{\\mathsf{T}} y + s = c$ 和 $s \\ge 0$。对于一个障碍参数 $\\mu \\in \\mathbb{R}_{0}$，中心路径被定义为满足扰动 Karush–Kuhn–Tucker (KKT) 条件的三元组 $(x(\\mu), y(\\mu), s(\\mu))$ 的集合\n$$\nA x = b,\\quad A^{\\mathsf{T}} y + s = c,\\quad X S \\mathbf{e} = \\mu \\mathbf{e},\\quad x  0,\\ s  0,\n$$\n其中 $X = \\mathrm{diag}(x)$，$S = \\mathrm{diag}(s)$，$\\mathbf{e}$ 是维度为 $n$ 的全一向量。\n\n任务：\n1. 仅从原始问题和对偶问题的定义、平稳性条件和互补松弛条件以及上述中心路径的定义出发，推导一个符号恒等式，将对偶间隙 $g(\\mu) \\equiv c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu)$ 完全用障碍参数 $\\mu$ 和原始变量数 $n$ 来表示。除这些定义外，不要假定任何其他结果。\n2. 设计一个阻尼牛顿法，在给定 $(A,b,c)$ 和一个正数 $\\mu$ 的情况下，通过求解非线性系统，数值计算中心路径方程的严格正解 $(x(\\mu), y(\\mu), s(\\mu))$\n$$\nF(x,y,s;\\mu) \\equiv \n\\begin{bmatrix}\nA x - b \\\\\nA^{\\mathsf{T}} y + s - c \\\\\nX S \\mathbf{e} - \\mu \\mathbf{e}\n\\end{bmatrix}\n= \\mathbf{0},\n$$\n并使用线搜索来保持 $x  0$ 和 $s  0$。使用通过在当前迭代点上对 $F$ 进行线性化得到的牛顿步长，并采用“分数到边界”步长来强制保持正性。\n3. 对于下述每个测试用例，使用同一组障碍参数 $\\mu \\in \\{ 1.0,\\ 0.1,\\ 10^{-3},\\ 10^{-6} \\}$。对于每个 $\\mu$ 和每个测试用例，使用你设计的牛顿法计算一个数值中心路径解 $(x(\\mu),y(\\mu),s(\\mu))$。然后评估绝对偏差\n$$\n\\Delta(\\mu) \\equiv \\left|\\, c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu) \\;-\\; f(n,\\mu)\\,\\right|,\n$$\n其中 $f(n,\\mu)$ 是你在任务1中推导出的关于 $n$ 和 $\\mu$ 的函数。对于每个测试用例，你的程序必须输出一个列表，其中包含与四个指定的 $\\mu$ 值相对应的 $\\Delta(\\mu)$ 值，并严格按照给定的顺序。\n\n测试套件：\n- 测试用例 1:\n  - $m = 1$, $n = 2$,\n  - $A = \\begin{bmatrix} 1  1 \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 2 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 2  1.5 \\end{bmatrix}^{\\mathsf{T}}$.\n- 测试用例 2:\n  - $m = 2$, $n = 3$,\n  - $A = \\begin{bmatrix} 1  2  0 \\\\ 0  1  1 \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 1  3  2 \\end{bmatrix}^{\\mathsf{T}}$.\n- 测试用例 3:\n  - $m = 3$, $n = 5$,\n  - $A = \\begin{bmatrix}\n      1  0  1  0  1 \\\\\n      0  1  1  2  0 \\\\\n      2  0  0  1  1\n    \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 3 \\\\ 4 \\\\ 4 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 1  2  3  4  1 \\end{bmatrix}^{\\mathsf{T}}$.\n- 测试用例 4:\n  - $m = 2$, $n = 4$,\n  - $A = \\begin{bmatrix} 1  0  1  0 \\\\ 0  1  1  1 \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 0.5  1.5  2.0  3.0 \\end{bmatrix}^{\\mathsf{T}}$.\n\n实现细节与要求：\n- 使用通过对 $F(x,y,s;\\mu)$ 求导得到的牛顿系统，在每次迭代中计算 $(\\Delta x, \\Delta y, \\Delta s)$。使用因子为 $\\tau = 0.99$ 的“分数到边界”步长来保持 $x$ 和 $s$ 的严格正性。如果需要，采用简单的回溯线搜索以减小残差范数 $\\|F\\|_2$。\n- 对于给定的测试用例，使用初始严格可行点 $x^{(0)} = \\mathbf{1}_n$, $y^{(0)} = \\mathbf{0}_m$, $s^{(0)} = c$，该点满足 $A x^{(0)} = b$ 和 $A^{\\mathsf{T}} y^{(0)} + s^{(0)} = c$，且 $x^{(0)}  0$，$s^{(0)}  0$。\n- 当 $\\mu = 10^{-6}$ 时，必须选择合适的数值公差，以可靠地解析出绝对值至少为 $10^{-9}$ 的 $\\Delta(\\mu)$。\n- 你的程序必须生成单行输出，其中包含一个由四个子列表组成的逗号分隔列表，每个子列表对应一个测试用例，并按 $\\mu \\in \\{ 1.0,\\ 0.1,\\ 10^{-3},\\ 10^{-6} \\}$ 的顺序排列四个 $\\Delta(\\mu)$ 值。例如，输出格式必须为\n  $$\n  \\big[\\,[\\Delta_1(\\mu_1),\\Delta_1(\\mu_2),\\Delta_1(\\mu_3),\\Delta_1(\\mu_4)],\\ [\\Delta_2(\\mu_1),\\ldots],\\ [\\Delta_3(\\mu_1),\\ldots],\\ [\\Delta_4(\\mu_1),\\ldots]\\,\\big]\n  $$\n  不含任何额外文本。", "solution": "该问题被评估为有效，因为它科学地基于线性规划内点法的既定理论，问题设定良好并提供了所有必要信息，且表述客观。\n\n### 任务1：对偶间隙的符号恒等式\n\n第一个任务是推导中心路径上对偶间隙 $g(\\mu)$ 的一个恒等式，用障碍参数 $\\mu$ 和原始变量数 $n$ 来表示。对偶间隙定义为原始目标函数值与对偶目标函数值之差：\n$$\ng(\\mu) \\equiv c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu)\n$$\n其中 $(x(\\mu), y(\\mu), s(\\mu))$ 是中心路径上的一个点。中心路径由对数障碍问题的 Karush-Kuhn-Tucker (KKT) 条件定义。问题陈述中提供的相关条件是：\n1. 原始可行性：$A x = b$\n2. 对偶可行性与平稳性：$A^{\\mathsf{T}} y + s = c$\n3. 扰动互补松弛性：$X S \\mathbf{e} = \\mu \\mathbf{e}$，其中 $X = \\mathrm{diag}(x)$ 且 $S = \\mathrm{diag}(s)$\n\n我们从对偶间隙的定义开始。我们可以将对偶可行性条件中 $c$ 的表达式代入间隙方程：\n$$\ng(\\mu) = (A^{\\mathsf{T}} y + s)^{\\mathsf{T}} x - b^{\\mathsf{T}} y\n$$\n使用转置的性质 $(U+V)^{\\mathsf{T}} = U^{\\mathsf{T}} + V^{\\mathsf{T}}$ 和 $(UV)^{\\mathsf{T}} = V^{\\mathsf{T}} U^{\\mathsf{T}}$，我们展开第一项：\n$$\ng(\\mu) = (y^{\\mathsf{T}} A + s^{\\mathsf{T}}) x - b^{\\mathsf{T}} y = y^{\\mathsf{T}} (Ax) + s^{\\mathsf{T}} x - b^{\\mathsf{T}} y\n$$\n接下来，我们使用原始可行性条件 $A x = b$ 来替换项 $(Ax)$：\n$$\ng(\\mu) = y^{\\mathsf{T}} b + s^{\\mathsf{T}} x - b^{\\mathsf{T}} y\n$$\n$y^{\\mathsf{T}} b$ 和 $b^{\\mathsf{T}} y$ 都是标量，表示相同的内积，因此它们相等。于是，它们相互抵消：\n$$\ng(\\mu) = s^{\\mathsf{T}} x\n$$\n这表明对偶间隙等于原始变量 $x$ 和对偶松弛变量 $s$ 的内积。\n\n现在，我们使用扰动互补松弛性条件 $X S \\mathbf{e} = \\mu \\mathbf{e}$。这是一个向量方程，可以按分量写成：\n$$\nx_i s_i = \\mu \\quad \\text{for } i = 1, 2, \\ldots, n\n$$\n内积 $s^{\\mathsf{T}} x$ 是这些分量乘积之和：\n$$\ns^{\\mathsf{T}} x = \\sum_{i=1}^{n} s_i x_i\n$$\n将 $x_i s_i = \\mu$ 代入求和中的每一项，我们得到：\n$$\ns^{\\mathsf{T}} x = \\sum_{i=1}^{n} \\mu = n \\mu\n$$\n因此，中心路径上的对偶间隙与障碍参数 $\\mu$ 和原始变量数 $n$ 成正比。\n$$\ng(\\mu) = c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu) = n \\mu\n$$\n因此，问题中要求的函数 $f(n, \\mu)$ 是 $f(n, \\mu) = n \\mu$。\n\n### 任务2：阻尼牛顿法设计\n\n第二个任务是设计一个阻尼牛顿法，对于给定的 $\\mu > 0$，找到中心路径上的一个点 $(x(\\mu), y(\\mu), s(\\mu))$。这需要求解非线性方程组 $F(x,y,s;\\mu) = \\mathbf{0}$，其中：\n$$\nF(x,y,s;\\mu) = \n\\begin{bmatrix}\nA x - b \\\\\nA^{\\mathsf{T}} y + s - c \\\\\nX S \\mathbf{e} - \\mu \\mathbf{e}\n\\end{bmatrix}\n= \\mathbf{0}\n$$\n牛顿法通过求解线性化系统 $J(\\Delta x, \\Delta y, \\Delta s)^{\\mathsf{T}} = -F$ 来迭代地寻找搜索方向 $(\\Delta x, \\Delta y, \\Delta s)$，其中 $J$ 是 $F$ 的雅可比矩阵。$F$ 关于 $(x, y, s)$ 的雅可比矩阵是：\n$$\nJ(x,y,s) = \n\\begin{bmatrix}\n\\frac{\\partial}{\\partial x}(Ax-b)  \\frac{\\partial}{\\partial y}(Ax-b)  \\frac{\\partial}{\\partial s}(Ax-b) \\\\\n\\frac{\\partial}{\\partial x}(A^{\\mathsf{T}}y+s-c)  \\frac{\\partial}{\\partial y}(A^{\\mathsf{T}}y+s-c)  \\frac{\\partial}{\\partial s}(A^{\\mathsf{T}}y+s-c) \\\\\n\\frac{\\partial}{\\partial x}(XSe-\\mu e)  \\frac{\\partial}{\\partial y}(XSe-\\mu e)  \\frac{\\partial}{\\partial s}(XSe-\\mu e)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA  \\mathbf{0}  \\mathbf{0} \\\\\n\\mathbf{0}  A^{\\mathsf{T}}  I \\\\\nS  \\mathbf{0}  X\n\\end{bmatrix}\n$$\n牛顿系统定义为 $J \\begin{pmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta s \\end{pmatrix} = -\\begin{pmatrix} A x - b \\\\ A^{\\mathsf{T}} y + s - c \\\\ X S \\mathbf{e} - \\mu \\mathbf{e} \\end{pmatrix}$。我们定义原始可行性残差 ($r_p$)、对偶可行性残差 ($r_d$) 和中心性残差 ($r_c$)：\n$$\nr_p = b - Ax \\\\\nr_d = c - A^{\\mathsf{T}} y - s \\\\\nr_c = \\mu \\mathbf{e} - X S \\mathbf{e} = \\mu \\mathbf{e} - \\mathrm{diag}(x) \\mathrm{diag}(s) \\mathbf{e}\n$$\n牛顿系统变为：\n1. $A \\Delta x = r_p$\n2. $A^{\\mathsf{T}} \\Delta y + \\Delta s = r_d$\n3. $S \\Delta x + X \\Delta s = r_c$\n\n为了高效地求解这个系统，我们使用分块消元法。从(2)中，我们将 $\\Delta s$ 表示为 $\\Delta y$ 的函数：$\\Delta s = r_d - A^{\\mathsf{T}} \\Delta y$。将此代入(3)：\n$$\nS \\Delta x + X(r_d - A^{\\mathsf{T}} \\Delta y) = r_c \\implies S \\Delta x - X A^{\\mathsf{T}} \\Delta y = r_c - X r_d\n$$\n由于 $S$ 是对角且正的（因为 $s0$），我们可以解出 $\\Delta x$：\n$$\n\\Delta x = S^{-1}(X A^{\\mathsf{T}} \\Delta y + r_c - X r_d) = X S^{-1} A^{\\mathsf{T}} \\Delta y + S^{-1}(r_c - X r_d)\n$$\n现在将这个 $\\Delta x$ 的表达式代入(1)：\n$$\nA \\left( X S^{-1} A^{\\mathsf{T}} \\Delta y + S^{-1}(r_c - X r_d) \\right) = r_p\n$$\n重新整理得到关于 $\\Delta y$ 的正规方程组：\n$$\n(A X S^{-1} A^{\\mathsf{T}}) \\Delta y = r_p - A S^{-1}(r_c - X r_d)\n$$\n这是一个关于 $\\Delta y$ 的 $m \\times m$ 线性系统，其中 $m$ 是 $A$ 的行数。矩阵 $M = A X S^{-1} A^{\\mathsf{T}}$ 是对称正定的（假设 $A$ 行满秩），因此是可逆的。\n\n单次牛顿迭代的算法如下：\n1. 给定当前迭代点 $(x, y, s)$，计算残差 $r_p$、$r_d$ 和 $r_c$。\n2. 构造正规方程矩阵 $M = A \\mathrm{diag}(x) \\mathrm{diag}(s^{-1}) A^{\\mathsf{T}}$ 和右侧向量 $v = r_p - A \\mathrm{diag}(s^{-1})(r_c - \\mathrm{diag}(x)r_d)$。\n3. 求解 $m \\times m$ 系统 $M \\Delta y = v$ 以得到 $\\Delta y$。\n4. 反向代入以求得 $\\Delta s$：$\\Delta s = r_d - A^{\\mathsf{T}} \\Delta y$。\n5. 反向代入以求得 $\\Delta x$：$\\Delta x = S^{-1}(r_c - X \\Delta s) = \\mathrm{diag}(s^{-1})(r_c - \\mathrm{diag}(x)\\Delta s)$。\n\n为了保持 $x$ 和 $s$ 的严格正性，需要执行线搜索。选择一个步长 $\\alpha \\in (0, 1]$。然后更新为 $(x, y, s) \\leftarrow (x, y, s) + \\alpha (\\Delta x, \\Delta y, \\Delta s)$。\n步长 $\\alpha$ 由“分数到边界”规则确定：\n$$\n\\alpha_x^{\\max} = \\min \\left( \\{1\\} \\cup \\{ -x_i/\\Delta x_i \\mid \\Delta x_i  0 \\} \\right) \\\\\n\\alpha_s^{\\max} = \\min \\left( \\{1\\} \\cup \\{ -s_i/\\Delta s_i \\mid \\Delta s_i  0 \\} \\right) \\\\\n\\alpha = \\tau \\min(\\alpha_x^{\\max}, \\alpha_s^{\\max})\n$$\n其中 $\\tau \\in (0, 1)$ 是一个安全因子，给定为 $\\tau=0.99$。如果需要回溯，可以进一步减小 $\\alpha$（例如，乘以因子0.5），直到残差范数 $\\|F\\|_2$ 减小。\n\n### 任务3：数值实现与评估\n\n最后的任务是实现牛顿法并将其应用于给定的测试用例。对于每个测试用例和每个 $\\mu \\in \\{ 1.0, 0.1, 10^{-3}, 10^{-6} \\}$ 值，算法计算中心路径点 $(x(\\mu), y(\\mu), s(\\mu))$。牛顿迭代的初始点指定为 $x^{(0)} = \\mathbf{1}_n$，$y^{(0)} = \\mathbf{0}_m$ 和 $s^{(0)} = c$。对于所有测试用例，该初始点都是严格可行的，满足 $A x^{(0)} = b$，$A^{\\mathsf{T}} y^{(0)} + s^{(0)} = c$，$x^{(0)}  0$ 和 $s^{(0)}  0$。迭代将持续进行，直到残差向量的欧几里得范数 $\\|F(x,y,s;\\mu)\\|_2$ 低于预设的公差（例如 $10^{-12}$）。\n\n收敛后，计算绝对偏差 $\\Delta(\\mu)$：\n$$\n\\Delta(\\mu) = \\left| c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu) - n \\mu \\right|\n$$\n考虑到对于可行点有 $c^{\\mathsf{T}}x-b^{\\mathsf{T}}y = s^{\\mathsf{T}}x$，并且算法驱动 $XSe$ 趋向于 $\\mu e$，我们也可以将其写为：\n$$\n\\Delta(\\mu) = \\left| s(\\mu)^{\\mathsf{T}} x(\\mu) - n \\mu \\right|\n$$\n该值衡量了数值计算出的对偶间隙与中心路径上的理论值的接近程度。最终输出将是一个列表，包含每个测试用例计算出的 $\\Delta(\\mu)$ 值。", "answer": "```python\nimport numpy as np\n\ndef newton_solver(A, b, c, mu, x0, y0, s0):\n    \"\"\"\n    Solves the central path equations using a damped Newton method.\n    F(x,y,s;mu) = [Ax - b; A^T y + s - c; X S e - mu e] = 0\n    \"\"\"\n    x, y, s = x0.copy(), y0.copy(), s0.copy()\n    m, n = A.shape\n    e = np.ones(n)\n    \n    # Algorithmic parameters\n    max_iter = 50\n    tolerance = 1e-12  # Tolerance for the residual norm\n    tau = 0.99  # Fraction-to-the-boundary factor\n\n    for i in range(max_iter):\n        # Calculate residuals\n        r_p = b - (A @ x)\n        r_d = c - (A.T @ y) - s\n        r_c = mu * e - x * s\n\n        # Check for convergence\n        residuals = np.concatenate((r_p, r_d, r_c))\n        res_norm = np.linalg.norm(residuals)\n        if res_norm  tolerance:\n            break\n\n        # Solve the Newton system using normal equations\n        # Efficiently compute M = A @ diag(x/s) @ A.T\n        x_over_s = x / s\n        M = (A * x_over_s) @ A.T\n\n        # Efficiently compute rhs = r_p - A @ ((r_c - x * r_d) / s)\n        rhs_vec = (r_c - x * r_d) / s\n        rhs = r_p - A @ rhs_vec\n\n        # Solve for dy\n        dy = np.linalg.solve(M, rhs)\n        \n        # Back-substitute for ds\n        ds = r_d - A.T @ dy\n        \n        # Back-substitute for dx\n        dx = (r_c - x * ds) / s\n\n        # Line search (fraction-to-the-boundary rule)\n        alpha_x_vals = [-xi / dxi for xi, dxi in zip(x, dx) if dxi  0]\n        alpha_x = min([1.0] + alpha_x_vals)\n\n        alpha_s_vals = [-si / dsi for si, dsi in zip(s, ds) if dsi  0]\n        alpha_s = min([1.0] + alpha_s_vals)\n\n        alpha = tau * min(alpha_x, alpha_s)\n        \n        # Simple backtracking to ensure residual reduction (optional but good practice)\n        current_res_norm_sq = res_norm**2\n        for _ in range(10): # Max 10 backtracking steps\n            x_new, y_new, s_new = x + alpha * dx, y + alpha * dy, s + alpha * ds\n            r_p_new = b - (A @ x_new)\n            r_d_new = c - (A.T @ y_new) - s_new\n            r_c_new = mu * e - x_new * s_new\n            new_res_norm_sq = np.linalg.norm(r_p_new)**2 + np.linalg.norm(r_d_new)**2 + np.linalg.norm(r_c_new)**2\n            if new_res_norm_sq  current_res_norm_sq:\n                break\n            alpha *= 0.5 # Reduce step size\n        \n        # Update variables\n        x, y, s = x_new, y_new, s_new\n\n    return x, y, s\n\ndef solve_for_case(A, b, c):\n    \"\"\"\n    Computes the absolute deviation Delta(mu) for a given problem instance\n    and a set of mu values.\n    \"\"\"\n    m, n = A.shape\n    mu_values = [1.0, 0.1, 1e-3, 1e-6]\n    delta_values = []\n\n    for mu in mu_values:\n        # Per the problem, use the same initial feasible point for each mu.\n        x0 = np.ones(n)\n        y0 = np.zeros(m)\n        s0 = c.copy()\n\n        # Compute the point on the central path\n        x_mu, y_mu, s_mu = newton_solver(A, b, c, mu, x0, y0, s0)\n\n        # Calculate the numerical duality gap\n        # Although c.T@x - b.T@y is the primary definition, s.T@x is numerically\n        # more direct for checking the centrality condition.\n        # The KKT conditions imply they are equal at the solution.\n        numerical_gap = s_mu.T @ x_mu\n\n        # Theoretical gap on the central path is n*mu\n        theoretical_gap = n * mu\n\n        # Calculate the absolute deviation\n        delta = abs(numerical_gap - theoretical_gap)\n        delta_values.append(delta)\n        \n    return delta_values\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"A\": np.array([[1.0, 1.0]]),\n            \"b\": np.array([2.0]),\n            \"c\": np.array([2.0, 1.5])\n        },\n        # Test case 2\n        {\n            \"A\": np.array([[1.0, 2.0, 0.0], [0.0, 1.0, 1.0]]),\n            \"b\": np.array([3.0, 2.0]),\n            \"c\": np.array([1.0, 3.0, 2.0])\n        },\n        # Test case 3\n        {\n            \"A\": np.array([\n                [1.0, 0.0, 1.0, 0.0, 1.0],\n                [0.0, 1.0, 1.0, 2.0, 0.0],\n                [2.0, 0.0, 0.0, 1.0, 1.0]\n            ]),\n            \"b\": np.array([3.0, 4.0, 4.0]),\n            \"c\": np.array([1.0, 2.0, 3.0, 4.0, 1.0])\n        },\n        # Test case 4\n        {\n            \"A\": np.array([[1.0, 0.0, 1.0, 0.0], [0.0, 1.0, 1.0, 1.0]]),\n            \"b\": np.array([2.0, 3.0]),\n            \"c\": np.array([0.5, 1.5, 2.0, 3.0])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_for_case(case[\"A\"], case[\"b\"], case[\"c\"])\n        all_results.append(result)\n\n    # Format the final output string to be exactly as required (no spaces)\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3107281"}, {"introduction": "一个算法的真正实力，只有在被推向极限时才能显现。这最后一个练习可视为对你所开发的路径跟踪方法的一次“压力测试” [@problem_id:3107306]。通过构建一个包含近乎平行约束的问题，我们将创建一个数值病态的场景，并亲眼观察可行域的几何形状如何影响牛顿法的性能，从而为深入理解内点算法的鲁棒性及潜在挑战提供关键的洞见。", "problem": "您将构建并分析一个二维线性规划族，其活性约束法向量近似平行，然后实现一个基于对数障碍的路径跟踪内点法，以经验性地揭示中心路径如何在一个狭窄的可行楔形区域中移动，以及矩阵条件如何影响牛顿步。\n\n您应使用的基本理论基础是对数障碍的凸性、Karush–Kuhn–Tucker (KKT) 最优性条件，以及用于求解障碍增广目标的光滑无约束最小化问题的 Newton 方法。基于这些，推导出中心路径方程和障碍子问题的牛顿步。\n\n考虑以下构造。对于给定的角度参数 $\\theta \\in (0,\\pi/2)$（角度单位：弧度），定义两个具有近似平行的外法向量的不等式约束\n$$\na_1 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix},\\quad a_2 = \\begin{bmatrix}\\cos\\theta \\\\ \\sin\\theta\\end{bmatrix},\\quad b_1 = 1,\\quad b_2 = 1,\n$$\n以及对称箱式约束\n$$\n- B \\le x_1 \\le B,\\quad - B \\le x_2 \\le B,\\quad \\text{with } B = 2.\n$$\n设目标是最小化 $c^\\top x$，其中\n$$\nc = - (a_1 + a_2).\n$$\n这种选择会导出一个最优解，该解位于 $a_1^\\top x = b_1$ 和 $a_2^\\top x = b_2$ 都为活性的交点附近。对于一组由 $i \\in \\{1,\\dots,m\\}$ 索引的不等式约束，将它们统一写为\n$$\ng_i(x) = b_i - a_i^\\top x > 0,\\quad \\text{因此 } x \\text{ 必须对所有 } i \\text{ 满足 } g_i(x) > 0。\n$$\n对于参数 $t > 0$，对数障碍路径跟踪子问题是\n$$\n\\min_{x \\in \\mathbb{R}^2} \\; f_t(x) = t\\, c^\\top x - \\sum_{i=1}^m \\log\\big(g_i(x)\\big),\n$$\n其中心路径由 $f_t$ 的唯一最小化子 $x^\\star(t)$ 刻画，当 $t \\to +\\infty$ 时。\n\n您必须完成的任务：\n\n1) 从 $f_t(x)$ 和 $g_i(x)$ 的定义出发，用 $\\{a_i,b_i\\}$ 和 $t$ 推导出梯度 $\\nabla f_t(x)$ 和 Hessian 矩阵 $\\nabla^2 f_t(x)$。\n\n2) 实现一个路径跟踪（障碍）法，该方法构造一个递增序列 $t_k$，并对每个 $t_k$，通过对 $f_{t_k}$ 应用阻尼牛顿步来找到牛顿点 $x^\\star(t_k)$，从前一个中心点开始作为热启动。使用以下具体且可测试的选择：\n- 在 $t_0 = 1$ 和 $x_0 = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$ 处初始化。\n- 使用乘法更新策略 $t_{k+1} = \\mu \\, t_k$，其中 $\\mu = 10$。\n- 设不等式约束的数量为 $m = 6$（两个角度约束和四个箱式约束）。\n- 当代理对偶间隙 $m / t_k \\le \\varepsilon_{\\text{gap}}$ 且 $\\varepsilon_{\\text{gap}} = 10^{-4}$ 时，终止外循环。\n- 对于固定 $t_k$ 的内层牛顿循环，通过求解 $\\nabla^2 f_{t_k}(x)\\, \\Delta x = - \\nabla f_{t_k}(x)$ 来计算牛顿步 $\\Delta x$，并使用回溯线搜索，强制满足：\n  (i) 通过比例为 $\\eta = 0.99$ 的到边界的比例步长法，实现严格可行性 $g_i(x + \\alpha \\Delta x) > 0$，\n  (ii) 一个参数为 $\\beta = 10^{-4}$ 且回溯收缩因子为 $\\gamma = 0.5$ 的 Armijo 下降条件，从 $\\alpha = 1$ 开始。\n- 当牛顿减量平方 $\\lambda(x)^2 = \\nabla f_t(x)^\\top \\left(\\nabla^2 f_t(x)\\right)^{-1} \\nabla f_t(x)$ 满足 $\\lambda(x)^2 / 2 \\le 10^{-8}$ 时，停止内层牛顿循环。\n\n3) 量化条件数。在每次牛顿迭代中，计算 Hessian 矩阵 $\\nabla^2 f_t(x)$ 的条件数（在谱 2-范数下）。汇总在整个运行过程中观察到的最大值。\n\n4) 量化步长接受情况。在整个运行过程中，跟踪回溯线搜索接受的最小步长 $\\alpha$。\n\n5) 量化计算量。计算所有外循环直到终止所花费的总牛顿步数。\n\n通过对以下角度（以弧度为单位）评估算法，提供一个测试套件形式的教学数据集，这些角度从良态情况过渡到近似平行状态：\n- $\\theta = 0.5$,\n- $\\theta = 0.1$,\n- $\\theta = 0.01$,\n- $\\theta = 0.001$.\n\n对于每个测试用例 $\\theta$，您的程序必须返回三元组\n$$\n[\\text{total\\_newton\\_steps},\\; \\text{max\\_condition\\_number},\\; \\text{min\\_accepted\\_step}],\n$$\n其中 $\\text{total\\_newton\\_steps}$ 是一个整数，另外两个量是实数。没有物理单位适用；角度按指定以弧度为单位。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应于与上面相同顺序的测试用例，并且本身是 $[\\text{total\\_newton\\_steps},\\text{max\\_condition\\_number},\\text{min\\_accepted\\_step}]$ 形式的列表。例如，形状必须是\n$$\n\\big[ [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot] \\big].\n$$", "solution": "用户希望为一系列二维线性规划（LP）问题实现并分析一种路径跟踪内点法。这些线性规划的定义性特征是存在两个约束法向量，当参数 $\\theta$ 趋近于零时，它们变得近似平行，这旨在突显与病态条件相关的数值挑战。\n\n解决方案将按以下步骤呈现：\n1.  对数障碍目标函数的梯度和 Hessian 矩阵的推导。\n2.  路径跟踪算法的详细描述，包括更新障碍参数 $t$ 的外循环和用于中心化的内层 Newton 法循环。\n3.  线搜索过程的解释，协调指定的多个条件。\n4.  需要收集的数据的合理性说明：总牛顿步数、最大 Hessian 条件数和最小接受步长。\n\n### 1. 数学公式与导数\n\n问题是在一组线性不等式约束下，最小化线性目标 $c^\\top x$。给定 $m=6$ 个约束，形式为 $a_i^\\top x \\le b_i$，其中 $i=1,\\dots,m$。在障碍法中，通过定义函数 $g_i(x) = b_i - a_i^\\top x > 0$ 来处理这些约束。\n\n路径跟踪法求解一系列由目标函数 $f_t(x)$ 定义的无约束优化问题：\n$$ f_t(x) = t c^\\top x - \\sum_{i=1}^m \\log\\big(g_i(x)\\big) = t c^\\top x - \\sum_{i=1}^m \\log(b_i - a_i^\\top x) $$\n其中 $t > 0$ 是障碍参数。对于 $t > 0$，最小化子 $x^\\star(t)$ 的集合构成了中心路径。\n\n**任务 1：梯度和 Hessian 矩阵的推导**\n\n为了应用 Newton 法最小化 $f_t(x)$，我们必须计算其梯度 $\\nabla f_t(x)$ 和 Hessian 矩阵 $\\nabla^2 f_t(x)$。\n\n**梯度 $\\nabla f_t(x)$：**\n梯度是通过对 $f_t(x)$ 关于向量 $x$ 求导来计算的。对对数项使用链式法则，$\\nabla_x \\log(u(x)) = \\frac{1}{u(x)}\\nabla_x u(x)$。\n这里，$u(x) = g_i(x) = b_i - a_i^\\top x$，所以 $\\nabla_x g_i(x) = -a_i$。\n线性项 $\\nabla_x(t c^\\top x)$ 的梯度就是 $t c$。\n$$ \\nabla f_t(x) = \\nabla \\left( t c^\\top x - \\sum_{i=1}^m \\log(b_i - a_i^\\top x) \\right) $$\n$$ \\nabla f_t(x) = t c - \\sum_{i=1}^m \\frac{1}{b_i - a_i^\\top x} (-a_i) $$\n$$ \\nabla f_t(x) = t c + \\sum_{i=1}^m \\frac{a_i}{b_i - a_i^\\top x} $$\n\n**Hessian 矩阵 $\\nabla^2 f_t(x)$：**\nHessian 矩阵是通过对梯度求导得到的二阶偏导数矩阵。线性项 $t c$ 的 Hessian 矩阵为零。对于求和项，我们对 $\\frac{a_i}{b_i - a_i^\\top x}$ 关于 $x$ 求导。\n$$ \\nabla^2 f_t(x) = \\nabla \\left( t c + \\sum_{i=1}^m \\frac{a_i}{b_i - a_i^\\top x} \\right)^\\top $$\n使用规则 $\\nabla_x \\left( \\frac{v(x)}{u(x)} \\right) = \\frac{u \\nabla v - v \\nabla u^\\top}{u^2}$ 比较复杂。一个更简单的方法是将每一项看作 $a_i (b_i - a_i^\\top x)^{-1}$ 并再次应用链式法则。\n$$ \\nabla_x \\left( (b_i - a_i^\\top x)^{-1} \\right) = -(b_i - a_i^\\top x)^{-2} (-a_i^\\top) = \\frac{a_i^\\top}{(b_i - a_i^\\top x)^2} $$\n向量值函数的导数则为：\n$$ \\nabla_x \\left( \\frac{a_i}{b_i - a_i^\\top x} \\right) = a_i \\otimes \\nabla_x \\left( \\frac{1}{b_i - a_i^\\top x} \\right) = a_i \\frac{a_i^\\top}{(b_i - a_i^\\top x)^2} = \\frac{a_i a_i^\\top}{(b_i - a_i^\\top x)^2} $$\n符号 $\\otimes$ 表示外积。对所有约束求和得到 Hessian 矩阵：\n$$ \\nabla^2 f_t(x) = \\sum_{i=1}^m \\frac{a_i a_i^\\top}{(b_i - a_i^\\top x)^2} $$\nHessian 矩阵是半正定秩一矩阵的和。由于向量集合 $\\{a_i\\}$ 张成 $\\mathbb{R}^2$，对于可行集严格内部的任何 $x$，Hessian 矩阵都是正定的，这确保了 $f_t(x)$ 是严格凸的并且有唯一的最小化子。\n\n### 2. 算法实现\n\n该算法包含两个嵌套循环。\n\n**外循环：路径跟踪**\n此循环迭代地增加障碍参数 $t$，以将解推向可行区域的边界，原始 LP 的最优解就在那里。\n1.  **初始化**：从 $t_0=1$ 和一个严格可行点 $x_0 = [0, 0]^\\top$ 开始。\n2.  **迭代**：在每一步 $k$，使用 Newton 法求解无约束子问题 $\\min_x f_{t_k}(x)$，从前一个解 $x^\\star(t_{k-1})$ 作为热启动开始。结果是 $x^\\star(t_k)$。\n3.  **更新**：使用乘法规则 $t_{k+1} = \\mu t_k$ 增加障碍参数，其中 $\\mu = 10$。\n4.  **终止**：当代理对偶间隙 $m/t_k$ 低于指定的容差 $\\varepsilon_{\\text{gap}} = 10^{-4}$ 时，循环终止。代理间隙 $m/t$ 是真实对偶间隙的一个上界，是障碍法的标准终止准则。\n\n**内循环：用于中心化的 Newton 法**\n对于固定的 $t=t_k$，我们使用阻尼牛顿法找到 $f_t(x)$ 的最小化子。\n1.  **初始化**：从 $x = x^\\star(t_{k-1})$ 开始（对于第一次外循环，则为 $x_0$）。\n2.  **牛顿步计算**：通过求解线性系统来计算牛顿步 $\\Delta x$：\n    $$ \\nabla^2 f_t(x) \\Delta x = - \\nabla f_t(x) $$\n    其中梯度和 Hessian 矩阵在当前迭代点 $x$ 处计算。\n3.  **牛顿减量**：计算牛顿减量平方 $\\lambda(x)^2$：\n    $$ \\lambda(x)^2 = \\nabla f_t(x)^\\top (\\nabla^2 f_t(x))^{-1} \\nabla f_t(x) = - \\nabla f_t(x)^\\top \\Delta x $$\n4.  **终止**：当 $\\lambda(x)^2 / 2 \\le 10^{-8}$ 时，内循环终止。量 $\\lambda(x)^2/2$ 是次优性 $f_t(x) - f_t(x^\\star(t))$ 的一个估计。\n5.  **线搜索与更新**：使用回溯线搜索找到一个合适的步长 $\\alpha$。更新解：$x \\leftarrow x + \\alpha \\Delta x$。\n\n### 3. 回溯线搜索\n\n步长 $\\alpha$ 对确保收敛至关重要。问题指定了一个具有多个条件的回溯线搜索，这可以被解释为一个鲁棒的过程：\n1.  **可行性限制**：首先，确定保持严格可行性的最大可能步长 $\\alpha_{\\text{max}}$，即 $g_i(x + \\alpha \\Delta x) > 0$。这由 $\\alpha_{\\text{max}} = \\min \\{ (b_i - a_i^\\top x) / (a_i^\\top \\Delta x) \\}$ 给出，其中 $i$ 遍历所有使 $a_i^\\top \\Delta x > 0$ 的索引。一个初始步长被提议为 $\\alpha = \\min(1.0, \\eta \\alpha_{\\text{max}})$，其中 $\\eta=0.99$。这可以防止步长恰好落在边界上，那会使对数障碍函数无定义。这种解释协调了“从 $\\alpha=1$ 开始”的一般指令与特定的“到边界的比例”规则。\n2.  **Armijo 条件**：从这个受限的 $\\alpha$ 开始，线搜索随后收缩步长，直到满足 Armijo-Goldstein 充分下降条件：\n    $$ f_t(x + \\alpha \\Delta x) \\le f_t(x) + \\beta \\alpha \\nabla f_t(x)^\\top \\Delta x $$\n    其中 $\\beta=10^{-4}$。如果条件不满足，步长将乘以一个因子 $\\gamma=0.5$：$\\alpha \\leftarrow \\gamma \\alpha$。\n\n这种两阶段方法（为可行性进行限制，然后为充分下降进行回溯）确保了每一步既是严格可行的，又在最小化目标方面取得了充分进展。\n\n### 4. 分析与量化指标\n\n问题要求量化算法的性能，特别是在约束变得近似平行（$\\theta \\to 0$）时。\n-   **总牛顿步数**：这衡量了将 LP 求解到期望精度所需的总计算量。随着 $\\theta$ 减小，中心路径变得更尖锐，热启动的效果变差，可能导致每次外循环的牛顿步数增加。\n-   **最大 Hessian 条件数**：条件数 $\\kappa(\\nabla^2 f_t(x))$ 衡量了牛顿系统解对扰动的敏感性。当 $\\theta \\to 0$ 时，$a_1$ 和 $a_2$ 变得近似共线。当迭代点 $x$ 靠近这两个约束为活性的角落时，Hessian 矩阵和中的相应项 $\\frac{a_1 a_1^\\top}{g_1(x)^2}$ 和 $\\frac{a_2 a_2^\\top}{g_2(x)^2}$ 会产生一个具有一个非常大的特征值（方向 $a_1+a_2$）和一个小得多的特征值（方向 $a_1-a_2$）的矩阵。这导致条件数爆炸，表明存在严重病态。\n-   **最小接受步长**：这跟踪线搜索接受的最小步长 $\\alpha$。严重的病态或中心路径的急剧曲率可能迫使算法采取非常小的步长来满足可行性和/或 Armijo 条件，表明在取得进展方面存在困难。\n\n通过对递减的 $\\theta$ 值跟踪这三个指标，我们可以经验性地观察到内点法理论所预测的数值性能下降。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the path-following algorithm for the specified test cases.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    B = 2.0  # Box constraint size\n    M = 6    # Number of inequality constraints\n\n    # --- Path-Following Algorithm Parameters ---\n    T_0 = 1.0          # Initial barrier parameter\n    MU = 10.0          # Barrier parameter update factor\n    EPS_GAP = 1e-4     # Surrogate duality gap tolerance for termination\n\n    # --- Newton's Method (Inner Loop) Parameters ---\n    NEWTON_TOL_LAMBDA_SQ = 2 * 1e-8  # Termination tolerance for lambda^2\n    ETA = 0.99                     # Fraction-to-the-boundary for line search\n    BETA = 1e-4                    # Armijo condition parameter\n    GAMMA = 0.5                    # Backtracking line search contraction factor\n\n    def setup_problem(theta):\n        \"\"\"Constructs the LP matrices A, b, and cost vector c for a given theta.\"\"\"\n        a1 = np.array([1.0, 0.0])\n        b1 = 1.0\n        a2 = np.array([np.cos(theta), np.sin(theta)])\n        b2 = 1.0\n        \n        c = -(a1 + a2)\n        \n        A = np.array([\n            a1,                      # Constraint: x1  1\n            a2,                      # Constraint: cos(theta)*x1 + sin(theta)*x2  1\n            [1.0, 0.0],              # Box: x1  2\n            [-1.0, 0.0],             # Box: -x1  2\n            [0.0, 1.0],              # Box: x2  2\n            [0.0, -1.0]              # Box: -x2  2\n        ])\n        \n        b = np.array([b1, b2, B, B, B, B])\n        \n        return c, A, b\n\n    def objective_f_t(t, c, A, b, x):\n        \"\"\"Computes the log-barrier objective function f_t(x).\"\"\"\n        g = b - A @ x\n        if np.any(g = 1e-12):  # Safety check for strict feasibility\n            return np.inf\n        return t * (c @ x) - np.sum(np.log(g))\n\n    def solve_for_theta(theta):\n        \"\"\"\n        Runs the full path-following method for a single theta value.\n        \n        Returns:\n            A list containing [total_newton_steps, max_condition_number, min_accepted_step].\n        \"\"\"\n        c, A, b = setup_problem(theta)\n        \n        # Initialization\n        t = T_0\n        x = np.array([0.0, 0.0])\n\n        total_newton_steps = 0\n        max_condition_number = 0.0\n        min_accepted_step = 1.0\n\n        # --- Outer Loop: Path-Following ---\n        while M / t > EPS_GAP:\n            \n            # --- Inner Loop: Newton's Method for Centering ---\n            while True:\n                # Calculate g(x), gradient, and Hessian\n                g = b - A @ x\n                inv_g = 1.0 / g\n                \n                grad = t * c + A.T @ inv_g\n                \n                weights = inv_g**2\n                H = A.T @ (A * weights[:, np.newaxis])\n                \n                # Track condition number\n                cond_H = np.linalg.cond(H)\n                max_condition_number = max(max_condition_number, cond_H)\n\n                # Solve Newton system: H * delta_x = -grad\n                try:\n                    delta_x = np.linalg.solve(H, -grad)\n                except np.linalg.LinAlgError:\n                    # Fallback for singular Hessian, though unlikely in theory\n                    delta_x = np.linalg.pinv(H, rcond=1e-15) @ -grad\n\n                # Calculate squared Newton decrement\n                lambda_sq = -grad.T @ delta_x\n                \n                # Check for inner loop convergence\n                if lambda_sq = NEWTON_TOL_LAMBDA_SQ:\n                    break\n                \n                # --- Backtracking Line Search ---\n                # 1. Cap step size by fraction-to-the-boundary rule\n                alpha_max_boundary = np.inf\n                v = A @ delta_x\n                # Indices where we are moving towards a boundary (a_i^T * delta_x > 0)\n                mask = v > 1e-12\n                if np.any(mask):\n                    alpha_max_boundary = np.min(g[mask] / v[mask])\n                \n                alpha = min(1.0, ETA * alpha_max_boundary)\n\n                # 2. Enforce Armijo sufficient decrease condition\n                f_current = objective_f_t(t, c, A, b, x)\n                armijo_check_term = BETA * grad.T @ delta_x\n\n                while True:\n                    x_next = x + alpha * delta_x\n                    f_next = objective_f_t(t, c, A, b, x_next)\n                    if f_next = f_current + alpha * armijo_check_term:\n                        break  # Armijo condition satisfied\n                    \n                    alpha *= GAMMA\n                    if alpha  1e-16: # Safety break for extremely small alpha\n                        break\n                \n                # Update x and tracking variables\n                x = x_next\n                min_accepted_step = min(min_accepted_step, alpha)\n                total_newton_steps += 1\n            \n            # --- Update t for the next outer iteration ---\n            t *= MU\n\n        return [total_newton_steps, max_condition_number, min_accepted_step]\n\n    # --- Main Execution ---\n    test_cases = [0.5, 0.1, 0.01, 0.001]\n    \n    # Store results from each test case\n    results = []\n    for theta in test_cases:\n        res = solve_for_theta(theta)\n        results.append(res)\n    \n    # Format the output string exactly as required\n    formatted_results = []\n    for res in results:\n        # Format: [integer, float, float]\n        formatted_sublist = f\"[{res[0]},{res[1]},{res[2]}]\"\n        formatted_results.append(formatted_sublist)\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\n# Run the main solver\nsolve()\n```", "id": "3107306"}]}