{"hands_on_practices": [{"introduction": "此练习在纳什均衡的抽象概念与具体的线性代数之间架起了一座直接的桥梁。通过分析一个具有二次支付函数的双人博弈，您将看到均衡条件如何简化为一个可解的线性方程组。这为理解特定类别博弈中的解是如何确定的提供了一个清晰且基础的视角 [@problem_id:2448674]。", "problem": "给定一个由实数矩阵和向量参数化的双人连续策略博弈族。玩家 $1$ 选择向量 $x \\in \\mathbb{R}^{n_1}$，玩家 $2$ 选择向量 $y \\in \\mathbb{R}^{n_2}$。收益函数为\n$$\nu_1(x,y) = -\\tfrac{1}{2}\\,x^\\top A x \\;-\\; x^\\top B y \\;+\\; b^\\top x,\n\\qquad\nu_2(x,y) = -\\tfrac{1}{2}\\,y^\\top C y \\;-\\; y^\\top B^\\top x \\;+\\; c^\\top y,\n$$\n其中 $A \\in \\mathbb{R}^{n_1 \\times n_1}$ 和 $C \\in \\mathbb{R}^{n_2 \\times n_2}$ 是对称正定矩阵，$B \\in \\mathbb{R}^{n_1 \\times n_2}$，$b \\in \\mathbb{R}^{n_1}$，$c \\in \\mathbb{R}^{n_2}$。当且仅当 $x^\\star$ 最大化 $u_1(\\cdot,y^\\star)$ 且 $y^\\star$ 最大化 $u_2(x^\\star,\\cdot)$ 时，策略对 $(x^\\star,y^\\star)$ 是一个纳什均衡 (NE)，其中最大化分别在 $\\mathbb{R}^{n_1}$ 和 $\\mathbb{R}^{n_2}$ 上进行。对于一个内部无约束的均衡，必须满足一阶平稳性条件：\n$$\n\\nabla_x u_1(x^\\star,y^\\star) = 0, \\qquad \\nabla_y u_2(x^\\star,y^\\star) = 0.\n$$\n\n对于下面的每一组参数，确定一个策略组合 $(x^\\star,y^\\star)$，使其满足上述平稳性条件，联合残差向量的无穷范数数值公差在 $10^{-6}$ 以内。所有量均为无量纲。将结果报告为一个列表，该列表由 $x^\\star$ 和 $y^\\star$ 串联而成，每个条目使用标准舍入法四舍五入到六位小数。\n\n测试套件：\n1. 情况 1，$n_1 = 1, n_2 = 1$：\n   - $A = [2]$, $B = [1]$, $C = [3]$, $b = [1]$, $c = [2]$。\n2. 情况 2，$n_1 = 2, n_2 = 1$：\n   - $A = \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}$, $B = \\begin{bmatrix} 1 \\\\ 0.5 \\end{bmatrix}$, $C = [2]$, $b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, $c = [1]$。\n3. 情况 3，$n_1 = 1, n_2 = 2$：\n   - $A = [5]$, $B = \\begin{bmatrix} 1  -0.5 \\end{bmatrix}$, $C = \\begin{bmatrix} 3  1 \\\\ 1  2 \\end{bmatrix}$, $b = [0]$, $c = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个用方括号括起来的逗号分隔数字列表，按上面列出的顺序对应于一个测试用例。例如，\n$$\n\\texttt{[[x\\_1,\\dots,x\\_{n\\_1},y\\_1,\\dots,y\\_{n\\_2}],[\\dots],[\\dots]]}\n$$\n不应打印任何额外文本。所有数字必须四舍五入到六位小数，并以标准十进制表示法（非科学记数法）打印。", "solution": "所提出的问题是计算博弈论中一个明确定义的任务。它要求为一类具有连续策略空间和二次收益函数的双人博弈找到纳什均衡。在进行任何计算之前，必须进行严格的分析。\n\n该问题是有效的。它在科学上基于博弈论和优化的原理，其提法良好，数据充分且一致，并以客观的数学语言表述。所有有效性条件均已满足。\n\n让我们开始推导解答。\n\n一个策略组合 $(x^\\star, y^\\star)$ 构成纳什均衡，前提是没有任何一方玩家有单方面偏离的动机。这意味着 $x^\\star$ 必须相对于 $x$ 最大化玩家1的收益 $u_1(x, y^\\star)$，而 $y^\\star$ 必须相对于 $y$ 最大化玩家2的收益 $u_2(x^\\star, y)$。\n\n收益函数如下：\n$$\nu_1(x,y) = -\\tfrac{1}{2}\\,x^\\top A x - x^\\top B y + b^\\top x,\n$$\n$$\nu_2(x,y) = -\\tfrac{1}{2}\\,y^\\top C y - y^\\top B^\\top x + c^\\top y.\n$$\n对于玩家2的固定策略 $\\bar{y}$，玩家1的收益 $u_1(x, \\bar{y})$ 是 $x$ 的函数。该函数关于 $x$ 的海森矩阵为 $\\nabla_{xx}^2 u_1 = -A$。问题陈述 $A$ 是一个对称正定矩阵。因此，$-A$ 是对称负定矩阵。这证明了 $u_1(x, \\bar{y})$ 是 $x$ 的严格凹函数。类似地，对于玩家1的固定策略 $\\bar{x}$，$u_2(\\bar{x}, y)$ 关于 $y$ 的海森矩阵为 $\\nabla_{yy}^2 u_2 = -C$。由于 $C$ 也被给定为对称正定矩阵，因此 $u_2(\\bar{x}, y)$ 是 $y$ 的严格凹函数。\n\n对于定义在无约束欧几里得空间（此处为 $\\mathbb{R}^{n_1}$ 和 $\\mathbb{R}^{n_2}$）上的严格凹函数，最大值的一阶必要条件也是充分条件。唯一的全局最大值在梯度为零向量的点处找到。\n\n最优性的一阶条件是 $\\nabla_x u_1(x^\\star, y^\\star) = 0$ 和 $\\nabla_y u_2(x^\\star, y^\\star) = 0$。我们计算梯度：\n使用标准矩阵微积分法则，其中 $A$ 和 $C$ 是对称的：\n$$\n\\nabla_x u_1(x,y) = \\nabla_x \\left(-\\tfrac{1}{2}x^\\top Ax - x^\\top By + b^\\top x\\right) = -Ax - By + b.\n$$\n$$\n\\nabla_y u_2(x,y) = \\nabla_y \\left(-\\tfrac{1}{2}y^\\top Cy - y^\\top B^\\top x + c^\\top y\\right) = -Cy - B^\\top x + c.\n$$\n\n将这些梯度设为零，得到纳什均衡 $(x^\\star, y^\\star)$ 必须满足的方程组：\n$$\n-Ax^\\star - By^\\star + b = 0 \\quad \\implies \\quad Ax^\\star + By^\\star = b\n$$\n$$\n-B^\\top x^\\star - Cy^\\star + c = 0 \\quad \\implies \\quad B^\\top x^\\star + Cy^\\star = c\n$$\n这是一个线性方程组。我们可以用更紧凑的分块矩阵形式来表示它。令 $z = \\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 为策略的串联向量。则均衡条件为：\n$$\n\\begin{bmatrix}\nA  B \\\\\nB^\\top  C\n\\end{bmatrix}\n\\begin{bmatrix}\nx^\\star \\\\\ny^\\star\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nb \\\\\nc\n\\end{bmatrix}\n$$\n将此系统记为 $M z^\\star = d$，其中 $M = \\begin{bmatrix} A  B \\\\ B^\\top  C \\end{bmatrix}$ 是大小为 $(n_1+n_2) \\times (n_1+n_2)$ 的系数矩阵，$z^\\star = \\begin{bmatrix} x^\\star \\\\ y^\\star \\end{bmatrix}$ 是未知的均衡策略组合，$d = \\begin{bmatrix} b \\\\ c \\end{bmatrix}$ 是常数向量。\n\n当且仅当矩阵 $M$ 非奇异时，存在唯一的纳什均衡。对于提供的每个测试用例，我们可以构建矩阵 $M$ 和向量 $d$，并求解线性方程组以得到 $z^\\star$。解的形式为 $z^\\star = M^{-1} d$。\n\n我们将此过程应用于每个测试用例。\n\n**情况 1：** $n_1=1, n_2=1$\n参数：$A = [2]$, $B = [1]$, $C = [3]$, $b = [1]$, $c = [2]$。\n方程组为：\n$$\n\\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix} \\begin{bmatrix} x^\\star \\\\ y^\\star \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\n$$\n矩阵的行列式为 $(2)(3) - (1)(1) = 5$，非零。解为：\n$$\n\\begin{bmatrix} x^\\star \\\\ y^\\star \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 1 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 0.2 \\\\ 0.6 \\end{bmatrix}\n$$\n结果为 $(x^\\star, y^\\star) = (0.2, 0.6)$。\n\n**情况 2：** $n_1=2, n_2=1$\n参数：$A = \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}$, $B = \\begin{bmatrix} 1 \\\\ 0.5 \\end{bmatrix}$, $C = [2]$, $b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, $c = [1]$。\n串联向量为 $z = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ y_1 \\end{bmatrix}$。线性方程组为：\n$$\n\\begin{bmatrix} 4  1  1 \\\\ 1  3  0.5 \\\\ 1  0.5  2 \\end{bmatrix} \\begin{bmatrix} x_1^\\star \\\\ x_2^\\star \\\\ y_1^\\star \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}\n$$\n求解这个 $3 \\times 3$ 方程组可得唯一解。\n\n**情况 3：** $n_1=1, n_2=2$\n参数：$A = [5], B = \\begin{bmatrix} 1  -0.5 \\end{bmatrix}, C = \\begin{bmatrix} 3  1 \\\\ 1  2 \\end{bmatrix}, b = [0], c = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。\n串联向量为 $z = \\begin{bmatrix} x_1 \\\\ y_1 \\\\ y_2 \\end{bmatrix}$。线性方程组为：\n$$\n\\begin{bmatrix} 5  1  -0.5 \\\\ 1  3  1 \\\\ -0.5  1  2 \\end{bmatrix} \\begin{bmatrix} x_1^\\star \\\\ y_1^\\star \\\\ y_2^\\star \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\\\ -1 \\end{bmatrix}\n$$\n这个 $3 \\times 3$ 方程组也有唯一解。\n\n实现将构建这些系统，并使用标准的高精度线性求解器来找到解向量，然后按要求格式化。使用诸如 LU 分解之类的直接求解器可确保残差的数值公差以很高的精度得到满足，远超 $10^{-6}$ 的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the Nash Equilibrium of a two-player continuous-strategy game\n    with quadratic payoffs for a given set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[2.0]]),\n            \"B\": np.array([[1.0]]),\n            \"C\": np.array([[3.0]]),\n            \"b\": np.array([1.0]),\n            \"c\": np.array([2.0]),\n        },\n        {\n            \"A\": np.array([[4.0, 1.0], [1.0, 3.0]]),\n            \"B\": np.array([[1.0], [0.5]]),\n            \"C\": np.array([[2.0]]),\n            \"b\": np.array([1.0, 0.0]),\n            \"c\": np.array([1.0]),\n        },\n        {\n            \"A\": np.array([[5.0]]),\n            \"B\": np.array([[1.0, -0.5]]),\n            \"C\": np.array([[3.0, 1.0], [1.0, 2.0]]),\n            \"b\": np.array([0.0]),\n            \"c\": np.array([1.0, -1.0]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        B = case[\"B\"]\n        C = case[\"C\"]\n        b = case[\"b\"]\n        c = case[\"c\"]\n\n        n1 = A.shape[0]\n        n2 = C.shape[0]\n\n        # Construct the block matrix M = [[A, B], [B.T, C]]\n        # The total size is (n1+n2) x (n1+n2)\n        M = np.block([\n            [A, B],\n            [B.T, C]\n        ])\n\n        # Construct the concatenated vector d = [b, c]\n        d = np.concatenate((b, c))\n\n        # Solve the linear system M*z = d for z = [x, y]\n        # np.linalg.solve is a high-precision direct solver, which is\n        # appropriate for this problem and ensures the residual tolerance\n        # is met.\n        z_star = np.linalg.solve(M, d)\n\n        results.append(z_star)\n\n    # Format the output string exactly as required.\n    # Each number must be rounded to six decimal places.\n    case_strings = []\n    for res_vector in results:\n        # Using f-string formatting handles rounding and avoids scientific notation.\n        formatted_vector = [f\"{x:.6f}\" for x in res_vector]\n        case_strings.append(f\"[{','.join(formatted_vector)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2448674"}, {"introduction": "此实践探索了一个更贴近现实的场景：一个资源分配博弈，其中参与者的行为受到约束并产生共同的成本。您将通过最大化一个势函数来实施投影梯度法以寻找纳什均衡，这是一种适用于具有特定结构博弈的强大技术。此外，通过将此均衡与社会最优分配进行比较，您将深入了解“无政府代价”——即系统中自利行为导致的效率损失 [@problem_id:3154624]。", "problem": "考虑一个有 $n$ 个参与者的非合作水资源分配博弈，参与者由 $i \\in \\{1,\\dots,n\\}$ 索引。每个参与者 $i$ 选择一个共享资源的非负分配量 $a_i \\in \\mathbb{R}_{\\ge 0}$。可行集是凸集 $X = \\{a \\in \\mathbb{R}^n \\mid a_i \\ge 0 \\text{ for all } i, \\ \\sum_{i=1}^n a_i \\le W\\}$，其中 $W \\in \\mathbb{R}_{>0}$ 是可用水资源总量。参与者 $i$ 从分配量 $a_i$ 中获得的收益由凹二次效用函数 $u_i(a_i) = b_i a_i - \\frac{c_i}{2} a_i^2$ 建模，其中参数 $b_i \\in \\mathbb{R}_{>0}$ 和 $c_i \\in \\mathbb{R}_{>0}$。该群体面临一个凸性稀缺性惩罚，该惩罚取决于总分配量 $z = \\sum_{i=1}^n a_i$，定义为 $s(z) = \\alpha \\left(\\frac{z}{W}\\right)^2$，其中 $\\alpha \\in \\mathbb{R}_{>0}$。每个参与者的支付为\n$$\nf_i(a) = u_i(a_i) - s\\!\\left(\\sum_{j=1}^n a_j\\right) = b_i a_i - \\frac{c_i}{2} a_i^2 - \\alpha \\left(\\frac{\\sum_{j=1}^n a_j}{W}\\right)^2,\n$$\n这引出了一个精确势博弈，其势函数为\n$$\n\\Phi(a) = \\sum_{i=1}^n u_i(a_i) - s\\!\\left(\\sum_{i=1}^n a_i\\right).\n$$\n纳什均衡是任意满足以下条件的 $a^\\star \\in X$：任何参与者的任何单方面偏离都不会增加其支付。\n\n任务：\n1. 使用投影梯度法，通过在凸集 $X$ 上最大化势函数 $\\Phi(a)$ 来计算该博弈的一个纳什均衡 $a^{\\mathrm{NE}}$。投影是关于到 $X$ 上的欧几里得范数的投影。投影梯度法应通过沿 $\\nabla \\Phi(a)$ 方向上升，然后投影到 $X$上来更新 $a$。使用回溯步长选择以确保 $\\Phi(a)$ 的单调上升，并在迭代变化量小于一个小的容差或达到固定的最大迭代次数时终止。\n2. 使用基于第一性原理证明的方法（例如，通过对总量约束的拉格朗日乘子进行二分法来求解 Karush-Kuhn-Tucker (KKT) 条件），计算在 $X$ 上最大化总效用 $\\sum_{i=1}^n u_i(a_i)$ 的效率分配 $a^{\\mathrm{eff}}$（即不考虑稀缺性惩罚）。\n3. 对于每个测试用例，报告纳什均衡和效率分配之间的欧几里得距离，即计算 $d = \\|a^{\\mathrm{NE}} - a^{\\mathrm{eff}}\\|_2$。\n\n推理和推导的基本依据：\n- 根据最佳响应定义的纳什均衡。\n- 凸集上凹优化的性质。\n- 纳什均衡与可行集上势函数最大化点重合的精确势博弈。\n- 凸优化的 Karush-Kuhn-Tucker (KKT) 条件。\n\n使用以下包含参数集 $(n, W, \\alpha, b, c)$ 的测试套件：\n- 案例 1：$n = 3$, $W = 5$, $\\alpha = 1$, $b = [4, 3, 2]$, $c = [1, 1.5, 2]$。\n- 案例 2：$n = 3$, $W = 100$, $\\alpha = 0.5$, $b = [2, 2, 2]$, $c = [1, 1, 1]$。\n- 案例 3：$n = 4$, $W = 7$, $\\alpha = 1$, $b = [3, 3, 3, 3]$, $c = [1, 1, 1, 1]$。\n- 案例 4：$n = 3$, $W = 2$, $\\alpha = 2$, $b = [1, 2, 6]$, $c = [2, 1, 1.5]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_k$ 是第 $k$ 个测试用例的欧几里得距离 $d$。不使用物理单位；所有量均为无量纲实数。输出必须是浮点数。", "solution": "用户提供的问题是一个定义明确的优化和博弈论问题，具有科学依据和正式的陈述。它要求计算两种不同的资源分配向量，即纳什均衡和社会效率分配，以及它们之间的距离。该问题是有效的，可以使用凸优化和博弈论的原理来解决。\n\n根据问题描述，解决方案分为两个主要部分：\n1.  计算效率分配 $a^{\\mathrm{eff}}$。\n2.  计算纳什均衡 $a^{\\mathrm{NE}}$。\n最后，为每个测试用例计算这两个向量之间的欧几里得距离。\n\n### 第一部分：效率分配的计算 ($a^{\\mathrm{eff}}$)\n\n效率分配 $a^{\\mathrm{eff}}$ 定义为最大化个体效用之和 $\\sum_{i=1}^n u_i(a_i)$ 的分配向量 $a$，受制于定义可行集 $X = \\{a \\in \\mathbb{R}^n \\mid a_i \\ge 0 \\text{ for all } i, \\ \\sum_{i=1}^n a_i \\le W\\}$ 的约束。\n\n优化问题为：\n$$\n\\max_{a} \\quad U(a) = \\sum_{i=1}^n \\left( b_i a_i - \\frac{c_i}{2} a_i^2 \\right) \\\\\n\\text{subject to} \\quad \\sum_{i=1}^n a_i \\le W, \\quad a_i \\ge 0 \\quad \\forall i \\in \\{1, \\dots, n\\}.\n$$\n目标函数 $U(a)$ 是一系列严格凹函数的和，因此它是严格凹的。可行集 $X$ 是一个紧凸集。因此，这个凸优化问题存在唯一解 $a^{\\mathrm{eff}}$。我们可以使用 Karush-Kuhn-Tucker (KKT) 条件找到这个解。\n\n拉格朗日函数为：\n$$\n\\mathcal{L}(a, \\lambda, \\mu) = \\sum_{i=1}^n \\left(b_i a_i - \\frac{c_i}{2} a_i^2\\right) - \\lambda \\left(\\sum_{i=1}^n a_i - W\\right) - \\sum_{i=1}^n \\mu_i (-a_i)\n$$\n其中 $\\lambda \\ge 0$ 是总量资源约束的拉格朗日乘子，$\\mu_i \\ge 0$ 是非负性约束 $a_i \\ge 0$ 的乘子。\n\nKKT 条件是：\n1.  **平稳性**：$\\frac{\\partial \\mathcal{L}}{\\partial a_i} = b_i - c_i a_i - \\lambda + \\mu_i = 0$ for $i=1, \\dots, n$。\n2.  **原始可行性**：$\\sum_{i=1}^n a_i \\le W$ 和 $a_i \\ge 0$。\n3.  **对偶可行性**：$\\lambda \\ge 0$ 和 $\\mu_i \\ge 0$。\n4.  **互补松弛性**：$\\lambda(\\sum_{i=1}^n a_i - W) = 0$ 和 $\\mu_i a_i = 0$。\n\n从平稳性条件，我们得到 $c_i a_i = b_i - \\lambda + \\mu_i$。从互补松弛性条件 $\\mu_i a_i = 0$，我们对每个参与者 $i$ 有两种情况：\n- 如果 $a_i > 0$，则 $\\mu_i = 0$。平稳性条件给出 $a_i = (b_i - \\lambda) / c_i$。对于 $a_i > 0$，必须有 $b_i > \\lambda$。\n- 如果 $a_i = 0$，则 $\\mu_i \\ge 0$。平稳性条件给出 $\\mu_i = \\lambda - b_i$，这要求 $\\lambda \\ge b_i$。\n\n结合这些情况，参与者 $i$ 的分配量可以表示为单个乘子 $\\lambda$ 的函数：\n$$\na_i(\\lambda) = \\max\\left(0, \\frac{b_i - \\lambda}{c_i}\\right)\n$$\n$\\lambda$ 的值由总量资源约束及其相应的松弛条件 $\\lambda(\\sum a_i - W) = 0$ 决定：\n- **情况 1**：无约束最大化点的 $\\sum_{i=1}^n (b_i/c_i) \\le W$。在这种情况下，我们可以设置 $\\lambda=0$。约束 $\\sum a_i \\le W$ 不起作用。解为 $a_i^{\\mathrm{eff}} = b_i/c_i$，由于 $b_i, c_i > 0$，这些解都是正的。\n- **情况 2**：无约束最大化点违反了资源限制，即 $\\sum_{i=1}^n (b_i/c_i) > W$。约束必须是激活的，所以 $\\sum a_i = W$ 且 $\\lambda > 0$。我们必须找到一个 $\\lambda > 0$ 的值，满足方程 $\\sum_{i=1}^n \\max\\left(0, \\frac{b_i - \\lambda}{c_i}\\right) = W$。函数 $g(\\lambda) = \\sum_{i=1}^n \\max\\left(0, \\frac{b_i - \\lambda}{c_i}\\right)$ 是关于 $\\lambda$ 的连续单调递减函数。我们可以使用在区间 $[0, \\max_i(b_i)]$ 上的二分搜索高效地找到满足 $g(\\lambda) = W$ 的根 $\\lambda$。\n\n### 第二部分：纳什均衡的计算 ($a^{\\mathrm{NE}}$)\n\n问题指出该博弈是具有势函数 $\\Phi(a)$ 的精确势博弈。对于这类博弈，纳什均衡集合与可行策略空间上势函数的局部最大化点集合重合。由于 $\\Phi(a)$ 是严格凹的（我们将看到），并且可行集 $X$ 是凸的，因此存在唯一的 $\\Phi(a)$ 全局最大化点，这也是该博弈唯一的纳什均衡。\n\n势函数为：\n$$\n\\Phi(a) = \\sum_{i=1}^n u_i(a_i) - s\\left(\\sum_{i=1}^n a_i\\right) = \\sum_{i=1}^n \\left( b_i a_i - \\frac{c_i}{2} a_i^2 \\right) - \\frac{\\alpha}{W^2} \\left(\\sum_{j=1}^n a_j\\right)^2\n$$\n$\\Phi(a)$ 的海森矩阵是一个其元素为 $H_{ij} = \\frac{\\partial^2 \\Phi}{\\partial a_i \\partial a_j}$ 的矩阵。\n$$\nH_{ii} = -c_i - \\frac{2\\alpha}{W^2} \\qquad \\text{and} \\qquad H_{ij} = -\\frac{2\\alpha}{W^2} \\quad \\text{for } i \\ne j\n$$\n海森矩阵为 $H = -\\left(\\text{diag}(c) + \\frac{2\\alpha}{W^2} \\mathbf{1}\\mathbf{1}^T\\right)$，其中 $\\text{diag}(c)$ 是对角线元素为 $c_i > 0$ 的对角矩阵，$\\mathbf{1}\\mathbf{1}^T$ 是全一矩阵。该矩阵是负定的，这证实了 $\\Phi(a)$ 是严格凹的。\n\n我们通过解决以下优化问题来找到 $a^{\\mathrm{NE}}$：\n$$\n\\max_{a \\in X} \\Phi(a)\n$$\n我们按规定使用投影梯度上升法。迭代更新规则是：\n$$\na^{(k+1)} = P_X\\left(a^{(k)} + t_k \\nabla \\Phi(a^{(k)})\\right)\n$$\n其中 $P_X$ 是到集合 $X$ 上的欧几里得投影，$t_k$ 是步长。\n\n势函数 $\\nabla \\Phi(a)$ 的梯度分量为：\n$$\n[\\nabla \\Phi(a)]_i = \\frac{\\partial \\Phi}{\\partial a_i} = b_i - c_i a_i - \\frac{2\\alpha}{W^2} \\sum_{j=1}^n a_j\n$$\n将点 $y \\in \\mathbb{R}^n$ 投影到集合 $X = \\{a \\in \\mathbb{R}^n \\mid a_i \\ge 0, \\sum a_i \\le W\\}$ 上的投影 $P_X(y)$ 是一个标准问题。如果对所有 $i$ 都有 $y_i \\ge 0$ 且 $\\sum y_i \\le W$，则 $P_X(y)=y$。否则，投影位于 $X$ 的边界上。一种常用算法首先将 $y$ 投影到非负象限，即 $y' = \\max(0, y)$。如果 $\\sum y'_i \\le W$，则 $P_X(y) = y'$。如果 $\\sum y'_i > W$，则投影必须位于单纯形 $\\{a \\mid a_i \\ge 0, \\sum a_i = W\\}$ 上。这个投影可以高效计算，例如通过对 $y$ 的分量进行排序。\n\n步长 $t_k$ 通过回溯线搜索来选择，以确保单调上升，即 $\\Phi(a^{(k+1)}) > \\Phi(a^{(k)})$。我们从一个初始步长 $t$ 开始，并以一个因子 $\\beta \\in (0,1)$ 来减小它，直到满足条件。\n\n当连续迭代之间的差的范数 $\\|a^{(k+1)}-a^{(k)}\\|_2$ 小于指定的容差，或达到最大迭代次数时，算法终止。\n\n### 第三部分：距离计算\n\n在计算出 $a^{\\mathrm{eff}}$ 和 $a^{\\mathrm{NE}}$ 后，它们之间的欧几里得距离计算如下：\n$$\nd = \\|a^{\\mathrm{NE}} - a^{\\mathrm{eff}}\\|_2 = \\sqrt{\\sum_{i=1}^n (a_i^{\\mathrm{NE}} - a_i^{\\mathrm{eff}})^2}\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_efficient_allocation(n, W, b, c):\n    \"\"\"\n    Computes the socially efficient allocation by maximizing sum of utilities.\n    Solves the KKT conditions, using bisection if the aggregate constraint is active.\n    \"\"\"\n    b = np.array(b)\n    c = np.array(c)\n    \n    # Unconstrained maximizers\n    a_unconstrained = b / c\n    \n    if np.sum(a_unconstrained) = W:\n        return a_unconstrained\n    else:\n        # Constraint is active, find lambda using bisection\n        \n        # The sum of allocations as a function of lambda\n        def sum_a(lam):\n            return np.sum(np.maximum(0, (b - lam) / c))\n\n        # Search space for lambda\n        low_lam, high_lam = 0.0, np.max(b)\n        \n        # Bisection search for 100 iterations for high precision\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            if sum_a(mid_lam) > W:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        \n        final_lambda = (low_lam + high_lam) / 2.0\n        a_eff = np.maximum(0, (b - final_lambda) / c)\n        return a_eff\n\ndef compute_nash_equilibrium(n, W, alpha, b, c):\n    \"\"\"\n    Computes the Nash equilibrium by maximizing the potential function\n    using a projected gradient ascent method.\n    \"\"\"\n    b = np.array(b)\n    c = np.array(c)\n\n    def potential(a):\n        z = np.sum(a)\n        utility_sum = np.sum(b * a - (c / 2) * a**2)\n        scarcity_penalty = alpha * (z / W)**2\n        return utility_sum - scarcity_penalty\n\n    def grad_potential(a):\n        z = np.sum(a)\n        return b - c * a - (2 * alpha / W**2) * z\n\n    def project_onto_X(y, W_proj):\n        \"\"\" Projects a vector y onto the set {x | x_i >= 0, sum(x_i) = W_proj}. \"\"\"\n        y_plus = np.maximum(0, y)\n        if np.sum(y_plus) = W_proj:\n            return y_plus\n        \n        # Projection onto the simplex {x | x_i >= 0, sum(x_i) = W_proj}\n        # Using the algorithm from Duchi et al. (2008)\n        u = np.sort(y)[::-1]\n        cssv = np.cumsum(u)\n        indices = np.arange(1, len(y) + 1)\n        \n        # valid_indices filters the indices `j` that satisfy the condition\n        # u_j - (1/j) * (cssv_j - W) > 0\n        valid_indices = u * indices > (cssv - W_proj)\n        \n        # In case all are False (e.g. y components are very negative)\n        if not np.any(valid_indices):\n             rho = len(y)\n        else:\n             rho = np.max(indices[valid_indices])\n\n        theta = (cssv[rho - 1] - W_proj) / rho\n        return np.maximum(0, y - theta)\n\n    # Projected gradient ascent parameters\n    max_iter = 2000\n    tolerance = 1e-10\n    step_size_init = 1.0\n    beta = 0.5  # Backtracking factor\n\n    a_k = np.zeros(n) # Initial allocation\n\n    for _ in range(max_iter):\n        phi_k = potential(a_k)\n        grad_k = grad_potential(a_k)\n        \n        t = step_size_init\n        \n        a_k_next = None\n        while t > 1e-12:\n            a_candidate = project_onto_X(a_k + t * grad_k, W)\n            if potential(a_candidate) >= phi_k:\n                a_k_next = a_candidate\n                break\n            t *= beta\n        \n        if a_k_next is None:\n            a_k_next = a_k\n        \n        if np.linalg.norm(a_k_next - a_k)  tolerance:\n            a_k = a_k_next\n            break\n            \n        a_k = a_k_next\n        \n    return a_k\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    test_cases = [\n        # (n, W, alpha, b, c)\n        (3, 5.0, 1.0, [4.0, 3.0, 2.0], [1.0, 1.5, 2.0]),\n        (3, 100.0, 0.5, [2.0, 2.0, 2.0], [1.0, 1.0, 1.0]),\n        (4, 7.0, 1.0, [3.0, 3.0, 3.0, 3.0], [1.0, 1.0, 1.0, 1.0]),\n        (3, 2.0, 2.0, [1.0, 2.0, 6.0], [2.0, 1.0, 1.5]),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, W, alpha, b, c = case\n        \n        # 1. Compute the efficient allocation\n        a_eff = compute_efficient_allocation(n, W, b, c)\n        \n        # 2. Compute the Nash equilibrium\n        a_ne = compute_nash_equilibrium(n, W, alpha, b, c)\n        \n        # 3. Compute the Euclidean distance\n        distance = np.linalg.norm(a_ne - a_eff)\n        results.append(distance)\n\n    # Format output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3154624"}, {"introduction": "知道均衡的存在是一回事，而高效地找到它则是另一回事。这项高级实践将四种不同的迭代算法——最优响应、梯度博弈、近端最优响应和外梯度法——进行对比，以求解一系列二次博弈的纳什均衡。通过实施和基准测试这些方法，您将对它们在不同情况下的收敛特性、稳定性和性能有一个实践性的理解 [@problem_id:3154618]。", "problem": "您需要设计、实现并比较四种迭代方法，用于计算光滑、严格凸二次双人博弈中的纳什均衡，并在一系列测试用例中对它们的收敛行为进行基准测试。纳什均衡的定义是：在该点上，对于另一方的策略，每个参与者的策略都是最优的。对于可微成本函数，一阶最优性条件将纳什均衡刻画为一个合适算子的零点。您的程序必须是一个完整、可运行的程序，不接受任何输入，并打印一行包含汇总结果的输出。\n\n本任务的基本基础如下。\n\n- 两名参与者分别选择向量 $x \\in \\mathbb{R}^{n}$ 和 $y \\in \\mathbb{R}^{m}$。参与者 1 最小化二次目标\n$$\nf_1(x,y) = \\tfrac{1}{2} x^\\top Q_1 x + x^\\top C y + b_1^\\top x + c_1,\n$$\n参与者 2 最小化\n$$\nf_2(x,y) = \\tfrac{1}{2} y^\\top Q_2 y + y^\\top D x + b_2^\\top y + c_2,\n$$\n其中 $Q_1 \\in \\mathbb{R}^{n \\times n}$ 和 $Q_2 \\in \\mathbb{R}^{m \\times m}$ 是对称正定矩阵，$C \\in \\mathbb{R}^{n \\times m}$ 和 $D \\in \\mathbb{R}^{m \\times n}$ 是耦合矩阵，$b_1 \\in \\mathbb{R}^n$，$b_2 \\in \\mathbb{R}^m$ 是向量。常数 $c_1$ 和 $c_2$ 在最优性中不起作用，可以是任意值。\n\n- 编码一阶最优性条件的算子映射为\n$$\nF(z) = \\begin{bmatrix}\n\\nabla_x f_1(x,y) \\\\\n\\nabla_y f_2(x,y)\n\\end{bmatrix}\n= M z + q,\n\\quad\nz = \\begin{bmatrix} x \\\\ y \\end{bmatrix},\n\\quad\nM = \\begin{bmatrix} Q_1  C \\\\ D  Q_2 \\end{bmatrix},\n\\quad\nq = \\begin{bmatrix} b_1 \\\\ b_2 \\end{bmatrix}.\n$$\n在 $M$ 是对称正定的条件下（例如，当 $D=C^\\top$ 且 $Q_1$, $Q_2$ 对称正定时），$F$ 是强单调且 Lipschitz 连续的。唯一的纳什均衡 $z^\\star$ 满足 $F(z^\\star) = 0$。\n\n您的任务是实现以下迭代方法，从上述基本基础出发，并且不依赖于问题陈述中的任何快捷公式。\n\n- 最佳响应 (Best Response, BR)：在固定对手当前策略的情况下，顺序地最小化每个参与者的目标函数，使用二次子问题的精确解。\n\n- 梯度博弈 (Gradient Play, GP)：使用算子 $F$ 对两个参与者的策略应用同步的基于梯度的步骤。\n\n- 近端最佳响应 (Proximal Best Response, PBR)：修改最佳响应方法，通过向每个参与者的子问题中添加一个二次正则化项，惩罚与当前迭代点的偏差，从而引发收缩并稳定迭代过程。\n\n- 外梯度 (Extragradient, EG)：在主更新之前应用一个额外的前瞻梯度步，以校正算子的曲率；在两个阶段均使用映射 $F$。\n\n对于梯度博弈和外梯度法，您必须根据 $F$ 的 Lipschitz 常数选择步长。对于二次博弈，$F$ 是线性的，其 Lipschitz 常数等于 $M$ 的谱范数，记为 $L$。一个安全的选择是步长 $\\gamma$ 满足 $0  \\gamma \\leq 1/L$。对于近端最佳响应，选择一个正则化参数 $\\rho  0$；一个实用且有理论依据的选择是 $\\rho = L$。\n\n实现细节如下：\n\n- 初始化：对所有方法使用零向量 $z_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n\n- 终止准则：对于每种方法，迭代直至欧几里得范数误差 $\\lVert z_k - z^\\star \\rVert_2$ 小于容差 $\\varepsilon = 10^{-8}$，或直至达到最大迭代次数 $N_{\\max} = 5000$。如果方法在 $N_{\\max}$ 次迭代内未能达到容差，则为该方法报告 -1。\n\n- 输出：对于每个测试用例，按 BR、GP、PBR 和 EG 的顺序报告一个包含 4 个整数的列表，这些整数对应于各自方法所需的迭代次数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是针对一个测试用例的列表。例如，一个有效的输出格式为\n$$\n[[i_{1,\\mathrm{BR}}, i_{1,\\mathrm{GP}}, i_{1,\\mathrm{PBR}}, i_{1,\\mathrm{EG}}],[i_{2,\\mathrm{BR}}, i_{2,\\mathrm{GP}}, i_{2,\\mathrm{PBR}}, i_{2,\\mathrm{EG}}],\\dots]\n$$\n其中每个 $i_{\\cdot,\\cdot}$ 都是一个整数。\n\n测试套件规范：\n\n提供以下五个凸二次博弈，所有博弈均设置 $D = C^\\top$ 以确保 $M$ 是对称的。\n\n- 案例 1 (标量变量，中等耦合)：\n$$\nn=m=1,\\quad\nQ_1 = [\\,2\\,],\\quad\nQ_2 = [\\,3\\,],\\quad\nC = [\\,0.5\\,],\\quad\nb_1 = [\\,1\\,],\\quad\nb_2 = [\\,-2\\,].\n$$\n\n- 案例 2 (标量变量，解耦边界情况)：\n$$\nn=m=1,\\quad\nQ_1 = [\\,1.5\\,],\\quad\nQ_2 = [\\,2.5\\,],\\quad\nC = [\\,0.0\\,],\\quad\nb_1 = [\\,-1.0\\,],\\quad\nb_2 = [\\,3.0\\,].\n$$\n\n- 案例 3 (二维变量，中等耦合)：\n$$\nn=m=2,\\quad\nQ_1 = \\begin{bmatrix} 2  0 \\\\ 0  4 \\end{bmatrix},\\quad\nQ_2 = \\begin{bmatrix} 3  0 \\\\ 0  1.5 \\end{bmatrix},\\quad\nC = \\begin{bmatrix} 0.3  -0.1 \\\\ 0.2  0.0 \\end{bmatrix},\\quad\nb_1 = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}.\n$$\n\n- 案例 4 (二维变量，病态但稳定)：\n$$\nn=m=2,\\quad\nQ_1 = \\begin{bmatrix} 0.01  0 \\\\ 0  100 \\end{bmatrix},\\quad\nQ_2 = \\begin{bmatrix} 0.001  0 \\\\ 0  50 \\end{bmatrix},\\quad\nC = \\begin{bmatrix} 0.05  0.0 \\\\ 0.0  0.05 \\end{bmatrix},\\quad\nb_1 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}.\n$$\n\n- 案例 5 (三维变量，更强但仍稳定的耦合)：\n$$\nn=m=3,\\quad\nQ_1 = \\mathrm{diag}(1,2,3),\\quad\nQ_2 = \\mathrm{diag}(1.5,2.5,3.5),\\quad\nC = 0.3\\,I_3,\\quad\nb_1 = \\begin{bmatrix} 1 \\\\ -2 \\\\ 0.5 \\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix} -1 \\\\ 1 \\\\ 2 \\end{bmatrix},\n$$\n其中 $I_3$ 是 $3 \\times 3$ 单位矩阵。\n\n实现约束：\n\n- 通过求解线性系统 $M z^\\star + q = 0$ 来精确计算 $z^\\star$。\n\n- 对于梯度博弈和外梯度法，将 $L$ 计算为 $M$ 的谱范数，并使用 $\\gamma = 1/L$。\n\n- 对于近端最佳响应，使用 $\\rho = L$。\n\n- 确保所有迭代都从 $z_0 = 0$ 开始，并使用欧几里得范数误差容差 $\\varepsilon = 10^{-8}$。\n\n您的最终程序必须以指定格式单行打印所有五个案例的结果，其中每个内部列表给出相应案例的迭代次数 $[i_{\\mathrm{BR}}, i_{\\mathrm{GP}}, i_{\\mathrm{PBR}}, i_{\\mathrm{EG}}]$。", "solution": "我们从可微、严格凸二次博弈中纳什均衡和一阶最优性的基本定义开始。参与者 1 关于 $x$ 的梯度是\n$$\n\\nabla_x f_1(x,y) = Q_1 x + C y + b_1,\n$$\n参与者 2 关于 $y$ 的梯度是\n$$\n\\nabla_y f_2(x,y) = Q_2 y + D x + b_2.\n$$\n将变量 $z = \\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 和梯度堆叠起来，得到算子 $F(z) = M z + q$，其中\n$$\nM = \\begin{bmatrix} Q_1  C \\\\ D  Q_2 \\end{bmatrix}, \\quad q = \\begin{bmatrix} b_1 \\\\ b_2 \\end{bmatrix}.\n$$\n当 $M$ 是对称正定时（对于测试套件，通过取 $D=C^\\top$ 且 $Q_1, Q_2$ 为对称正定且耦合足够小，此条件成立），$F$ 是强单调且 Lipschitz 连续的。唯一的纳什均衡解 $F(z^\\star) = 0$。因为 $F$ 是线性的，我们得到\n$$\nM z^\\star + q = 0 \\quad \\Rightarrow \\quad z^\\star = - M^{-1} q,\n$$\n这可以使用线性求解器计算。\n\n我们现在从核心原理推导每种迭代方法。\n\n- 最佳响应 (BR)。固定对手的策略，可将每个参与者的问题简化为关于其自身变量的严格凸二次问题。二次函数 $x \\mapsto \\tfrac{1}{2} x^\\top Q_1 x + (C y_k + b_1)^\\top x$ 的最小化点由一阶条件 $Q_1 x_{k+1} + C y_k + b_1 = 0$ 刻画，即\n$$\nx_{k+1} = -Q_1^{-1}(C y_k + b_1).\n$$\n然后，给定 $x_{k+1}$，参与者 2 的最佳响应满足 $Q_2 y_{k+1} + D x_{k+1} + b_2 = 0$，即\n$$\ny_{k+1} = -Q_2^{-1}(D x_{k+1} + b_2).\n$$\n这两个更新实现了一种块高斯-赛德尔方法来求解 $M z + q = 0$。\n\n- 梯度博弈 (GP)。使用算子 $F$ 对两个参与者同时进行梯度步长的更新可写为\n$$\nz_{k+1} = z_k - \\gamma F(z_k) = z_k - \\gamma (M z_k + q).\n$$\n对于常数为 $L = \\lVert M \\rVert_2$（谱范数）的线性 Lipschitz 算子，稳定性的一个充分条件是 $0  \\gamma \\le 1/L$。我们选择 $\\gamma = 1/L$ 作为安全的步长。\n\n- 近端最佳响应 (PBR)。近端修正通过添加二次正则化项来惩罚与当前迭代点的变化。对于参与者 1，子问题是\n$$\n\\min_x \\left\\{ \\tfrac{1}{2} x^\\top Q_1 x + (C y_k + b_1)^\\top x + \\tfrac{\\rho}{2} \\lVert x - x_k \\rVert_2^2 \\right\\}.\n$$\n其一阶条件是\n$$\nQ_1 x_{k+1} + C y_k + b_1 + \\rho (x_{k+1} - x_k) = 0 \\quad \\Rightarrow \\quad (Q_1 + \\rho I) x_{k+1} = \\rho x_k - C y_k - b_1,\n$$\n得到\n$$\nx_{k+1} = (Q_1 + \\rho I)^{-1}(\\rho x_k - C y_k - b_1).\n$$\n类似地，参与者 2 的更新是\n$$\ny_{k+1} = (Q_2 + \\rho I)^{-1}(\\rho y_k - D x_{k+1} - b_2).\n$$\n选择 $\\rho = L$ 会产生强收缩，与未正则化的 BR 相比，可以稳定并通常加速收斂。\n\n- 外梯度法 (EG)。Korpelevich 用于单调变分不等式的外梯度法在主更新前计算一个前瞻点，并在该点评估算子。对于我们的无约束线性 $F$，\n$$\nz_{k+\\tfrac{1}{2}} = z_k - \\gamma F(z_k), \\quad\nz_{k+1} = z_k - \\gamma F(z_{k+\\tfrac{1}{2}}),\n$$\n采用同样的安全步长选择 $\\gamma = 1/L$。这可以校正曲率，并且与普通的梯度博弈相比，在许多情况下能提供更好的鲁棒性和更快的收敛速度。\n\n所有方法都从 $z_0 = 0$ 开始。当欧几里得范数误差满足\n$$\n\\lVert z_k - z^\\star \\rVert_2 \\le \\varepsilon, \\quad \\varepsilon = 10^{-8},\n$$\n或迭代次数超过 $N_{\\max} = 5000$ 时终止，后一种情况报告失败代码 $-1$。\n\n对于每个由 $(Q_1, Q_2, C, D, b_1, b_2)$ 定义的测试用例，我们：\n\n1. 构造 $M$ 和 $q$。\n2. 计算均衡点 $z^\\star = -M^{-1} q$。\n3. 通过奇异值计算谱范数 $L = \\lVert M \\rVert_2$，并设置 $\\gamma = 1/L$ 和 $\\rho = L$。\n4. 从 $z_0 = 0$ 开始运行 BR、GP、PBR 和 EG，计算迭代次数，直到达到容差或发生失败。\n5. 记录四个整数 $[i_{\\mathrm{BR}}, i_{\\mathrm{GP}}, i_{\\mathrm{PBR}}, i_{\\mathrm{EG}}]$。\n\n测试套件中的设计覆盖范围：\n\n- 案例 2 设置 $C = 0$，创建了解耦问题。BR 和 PBR 在一次遍历中就能获得精确解，因为每个参与者的子问题都是独立的；GP 和 EG 仍然线性收敛，但通常需要多次迭代。这是一个测试正确性和精确性的边界情况。\n\n- 案例 4 使用病态的 $Q_1$ 和 $Q_2$ 以及小但非零的耦合。由于条件数问题，GP 显著变慢；EG 和 PBR 提高了稳定性。这测试了对条件数的敏感性以及正则化和前瞻的好处。\n\n- 案例 1、3 和 5 分别在一维、二维和三维设置中提供了“理想路径”和更强耦合的场景，测试了跨维度的可扩展性和鲁棒性。\n\n最终的程序精确地实现了这些步骤，并打印出包含五个案例迭代次数的所要求的嵌套列表的单行输出。这通过到固定容差的迭代次数，使用相同的初始化和从算子的 Lipschitz 常数推导出的理论上安全的参数选择，定量地对收敛行为（“速率”）进行了基准测试。", "answer": "```python\n# Python 3.12; numpy 1.23.5; scipy not used.\nimport numpy as np\n\ndef spectral_norm(M: np.ndarray) - float:\n    # Spectral norm (largest singular value)\n    return np.linalg.svd(M, compute_uv=False)[0]\n\ndef equilibrium(M: np.ndarray, q: np.ndarray) - np.ndarray:\n    # Solve M z* + q = 0 = z* = - M^{-1} q\n    return -np.linalg.solve(M, q)\n\ndef best_response(Q1, Q2, C, D, b1, b2, z_star, tol=1e-8, max_iters=5000):\n    n = Q1.shape[0]\n    m = Q2.shape[0]\n    x = np.zeros(n)\n    y = np.zeros(m)\n    for k in range(1, max_iters + 1):\n        # Player 1 best response\n        rhs1 = -C @ y - b1\n        x = np.linalg.solve(Q1, rhs1)\n        # Player 2 best response\n        rhs2 = -D @ x - b2\n        y = np.linalg.solve(Q2, rhs2)\n        z = np.concatenate([x, y])\n        err = np.linalg.norm(z - z_star)\n        if err = tol:\n            return k\n    return -1\n\ndef proximal_best_response(Q1, Q2, C, D, b1, b2, z_star, rho, tol=1e-8, max_iters=5000):\n    n = Q1.shape[0]\n    m = Q2.shape[0]\n    x = np.zeros(n)\n    y = np.zeros(m)\n    Q1p = Q1 + rho * np.eye(n)\n    Q2p = Q2 + rho * np.eye(m)\n    for k in range(1, max_iters + 1):\n        rhs1 = rho * x - C @ y - b1\n        x = np.linalg.solve(Q1p, rhs1)\n        rhs2 = rho * y - D @ x - b2\n        y = np.linalg.solve(Q2p, rhs2)\n        z = np.concatenate([x, y])\n        err = np.linalg.norm(z - z_star)\n        if err = tol:\n            return k\n    return -1\n\ndef gradient_play(M, q, z_star, gamma, tol=1e-8, max_iters=5000):\n    z = np.zeros_like(z_star)\n    for k in range(1, max_iters + 1):\n        Fz = M @ z + q\n        z = z - gamma * Fz\n        err = np.linalg.norm(z - z_star)\n        if err = tol:\n            return k\n    return -1\n\ndef extragradient(M, q, z_star, gamma, tol=1e-8, max_iters=5000):\n    z = np.zeros_like(z_star)\n    for k in range(1, max_iters + 1):\n        Fz = M @ z + q\n        z_half = z - gamma * Fz\n        Fz_half = M @ z_half + q\n        z = z - gamma * Fz_half\n        err = np.linalg.norm(z - z_star)\n        if err = tol:\n            return k\n    return -1\n\ndef build_block_matrix(Q1, Q2, C, D):\n    return np.block([[Q1, C],\n                     [D, Q2]])\n\ndef solve_case(Q1, Q2, C, D, b1, b2):\n    M = build_block_matrix(Q1, Q2, C, D)\n    q = np.concatenate([b1, b2])\n    z_star = equilibrium(M, q)\n    L = spectral_norm(M)\n    gamma = 1.0 / L\n    rho = L\n    it_br = best_response(Q1, Q2, C, D, b1, b2, z_star, tol=1e-8, max_iters=5000)\n    it_gp = gradient_play(M, q, z_star, gamma=gamma, tol=1e-8, max_iters=5000)\n    it_pbr = proximal_best_response(Q1, Q2, C, D, b1, b2, z_star, rho=rho, tol=1e-8, max_iters=5000)\n    it_eg = extragradient(M, q, z_star, gamma=gamma, tol=1e-8, max_iters=5000)\n    return [it_br, it_gp, it_pbr, it_eg]\n\ndef solve():\n    test_cases = []\n\n    # Case 1: scalar, moderate coupling\n    Q1 = np.array([[2.0]])\n    Q2 = np.array([[3.0]])\n    C = np.array([[0.5]])\n    D = C.T\n    b1 = np.array([1.0])\n    b2 = np.array([-2.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 2: scalar, decoupled\n    Q1 = np.array([[1.5]])\n    Q2 = np.array([[2.5]])\n    C = np.array([[0.0]])\n    D = C.T\n    b1 = np.array([-1.0])\n    b2 = np.array([3.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 3: 2D, moderate coupling\n    Q1 = np.array([[2.0, 0.0],\n                   [0.0, 4.0]])\n    Q2 = np.array([[3.0, 0.0],\n                   [0.0, 1.5]])\n    C = np.array([[0.3, -0.1],\n                  [0.2,  0.0]])\n    D = C.T\n    b1 = np.array([1.0, -1.0])\n    b2 = np.array([0.5, -0.5])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 4: 2D, ill-conditioned\n    Q1 = np.array([[0.01, 0.0],\n                   [0.0, 100.0]])\n    Q2 = np.array([[0.001, 0.0],\n                   [0.0, 50.0]])\n    C = np.array([[0.05, 0.0],\n                  [0.0, 0.05]])\n    D = C.T\n    b1 = np.array([1.0, 1.0])\n    b2 = np.array([-1.0, 2.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 5: 3D, stronger but stable coupling\n    Q1 = np.diag([1.0, 2.0, 3.0])\n    Q2 = np.diag([1.5, 2.5, 3.5])\n    C = 0.3 * np.eye(3)\n    D = C.T\n    b1 = np.array([1.0, -2.0, 0.5])\n    b2 = np.array([-1.0, 1.0, 2.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    results = []\n    for Q1, Q2, C, D, b1, b2 in test_cases:\n        res = solve_case(Q1, Q2, C, D, b1, b2)\n        results.append(res)\n\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3154618"}]}