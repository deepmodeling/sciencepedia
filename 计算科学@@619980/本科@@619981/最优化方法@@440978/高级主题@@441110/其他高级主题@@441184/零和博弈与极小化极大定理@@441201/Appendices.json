{"hands_on_practices": [{"introduction": "$2 \\times 2$ 零和博弈是学习博弈论的基石。这个练习将引导你从第一性原理出发，推导出这类博弈的通用解，特别是运用关键的“无差异原理”。通过完成这个推导 [@problem_id:3199092]，你将掌握分析和解决更广泛策略冲突问题的核心分析工具。", "problem": "考虑一个零和矩阵博弈，博弈方为行参与者（最大化者）和列参与者（最小化者）。行参与者的收益矩阵为\n$$\nA=\\begin{pmatrix}\na & b\\\\\nc & d\n\\end{pmatrix},\n$$\n其中 $a,b,c,d \\in \\mathbb{R}$。设行参与者以概率 $x=(p,1-p)$ 在第一行和第二行之间混合，列参与者以概率 $y=(q,1-q)$ 在第一列和第二列之间混合，其中 $p,q \\in [0,1]$。博弈的值是行参与者在均衡时的收益 $v$。仅从期望收益、最优反应和最小最大定理（该定理断言有限零和博弈中最大最小值和最小最大值相等）的定义出发，推导在一般情况下（即双方都严格混合，也就是说，没有纯策略对任何一方占优，且不存在纯策略鞍点）的均衡混合策略 $x^\\star=(p^\\star,1-p^\\star)$、均衡混合策略 $y^\\star=(q^\\star,1-q^\\star)$ 以及博弈值 $v$ 的显式封闭形式表达式。用 $a,b,c,d$ 表示你的答案。\n\n然后，分析严格混合失效的边缘情况。你的分析应确定：\n- 何时参与者有严格占优的纯策略，以及这如何决定 $(x^\\star,y^\\star,v)$。\n- 何时存在纯策略鞍点，以及如何直接从 $A$ 中读出 $(x^\\star,y^\\star,v)$。\n- 在 $a-b-c+d=0$ 的退化情况下会发生什么，以及这与前两项如何相互作用，包括完全退化的子情况 $a=b=c=d$。\n\n你必须以封闭形式给出一般混合策略的公式。不要假设任何数值，也不要四舍五入。你最终报告的答案应为由 $p^\\star$、$q^\\star$ 和 $v$ 组成的三元组，且仅用 $a,b,c,d$ 表示一般严格混合情况下的结果。", "solution": "该问题要求推导一般 $2 \\times 2$ 零和博弈的均衡策略和博弈值，然后分析特殊情况。\n\n设行参与者的策略是两行上的概率分布 $x=(p, 1-p)$，列参与者的策略是两列上的概率分布 $y=(q, 1-q)$，其中 $p, q \\in [0,1]$。行参与者的收益矩阵由下式给出\n$$\nA=\\begin{pmatrix}\na & b\\\\\nc & d\n\\end{pmatrix}\n$$\n行参与者的期望收益 $E$ 是参与者策略的函数：\n$$\nE(x,y) = x A y^T = \\begin{pmatrix} p & 1-p \\end{pmatrix} \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} \\begin{pmatrix} q \\\\ 1-q \\end{pmatrix}\n$$\n展开此表达式得到期望收益 $E(p,q)$：\n$$\nE(p,q) = p(aq + b(1-q)) + (1-p)(cq + d(1-q))\n$$\n$$\nE(p,q) = paq + pb - pbq + cq + d - dq - pcq - pd + pdq\n$$\n$$\nE(p,q) = pq(a-b-c+d) + p(b-d) + q(c-d) + d\n$$\n\n有限零和博弈的最小最大定理保证了混合策略纳什均衡的存在性，并且博弈值 $v$ 是唯一的。均衡是一对策略 $(x^\\star, y^\\star)$，使得任何一方都没有单方面偏离的动机。\n\n**1. 一般情况：严格混合策略均衡**\n\n我们首先分析一般情况，其中均衡策略 $x^\\star=(p^\\star, 1-p^\\star)$ 和 $y^\\star=(q^\\star, 1-q^\\star)$ 是严格混合的，即 $p^\\star \\in (0,1)$ 和 $q^\\star \\in (0,1)$。要使一个参与者愿意混合其纯策略，鉴于对手的均衡策略，他必须对自己的纯策略无差异。这被称为无差异原则。\n\n行参与者的无差异：要使行参与者愿意在第1行和第2行之间混合，当列参与者使用策略 $y^\\star=(q^\\star, 1-q^\\star)$ 时，从每行获得的期望收益必须相等。\n- 第1行的期望收益：$a q^\\star + b(1-q^\\star)$\n- 第2行的期望收益：$c q^\\star + d(1-q^\\star)$\n\n将这两者设为相等，得到行参与者无差异的条件：\n$$\na q^\\star + b(1-q^\\star) = c q^\\star + d(1-q^\\star)\n$$\n$$\nq^\\star(a-b) + b = q^\\star(c-d) + d\n$$\n$$\nq^\\star(a-b-c+d) = d-b\n$$\n假设分母不为零，我们可以解出 $q^\\star$：\n$$\nq^\\star = \\frac{d-b}{a-b-c+d}\n$$\n这个均衡收益对行参与者的两个纯策略都是相同的，它就是博弈的值 $v$。\n\n列参与者的无差异：类似地，要使列参与者愿意混合，在给定行参与者策略 $x^\\star=(p^\\star, 1-p^\\star)$ 的情况下，对于两种列选择，行参与者的期望收益（列参与者试图最小化这个收益）必须相同。\n- 第1列的期望收益：$a p^\\star + c(1-p^\\star)$\n- 第2列的期望收益：$b p^\\star + d(1-p^\\star)$\n\n将这两者设为相等，得到列参与者无差异的条件：\n$$\na p^\\star + c(1-p^\\star) = b p^\\star + d(1-p^\\star)\n$$\n$$\np^\\star(a-c) + c = p^\\star(b-d) + d\n$$\n$$\np^\\star(a-c-b+d) = d-c\n$$\n解出 $p^\\star$：\n$$\np^\\star = \\frac{d-c}{a-b-c+d}\n$$\n这个共同的收益也是博弈的值 $v$。\n\n博弈值 $v$：我们可以通过将一个参与者的均衡策略代入另一个参与者的收益表达式来计算 $v$。使用行参与者对抗 $q^\\star$ 的收益表达式：\n$$\nv = a q^\\star + b(1-q^\\star) = a \\left( \\frac{d-b}{a-b-c+d} \\right) + b \\left( 1 - \\frac{d-b}{a-b-c+d} \\right)\n$$\n$$\nv = \\frac{a(d-b)}{a-b-c+d} + \\frac{b(a-b-c+d - (d-b))}{a-b-c+d}\n$$\n$$\nv = \\frac{ad-ab}{a-b-c+d} + \\frac{b(a-c)}{a-b-c+d} = \\frac{ad-ab+ab-bc}{a-b-c+d}\n$$\n$$\nv = \\frac{ad-bc}{a-b-c+d}\n$$\n这为存在严格混合均衡的一般情况提供了完整的解。这种情况发生在没有任何参与者有占优策略且不存在纯策略鞍点时，这对应于使 $p^\\star \\in (0,1)$ 和 $q^\\star \\in (0,1)$ 成立的关于 $a,b,c,d$ 的条件。\n\n**2. 边缘情况分析**\n\n上述公式仅在 $a-b-c+d \\neq 0$ 且所得概率在区间 $(0,1)$ 内时有效。我们现在分析这些条件不成立的情况。\n\n**占优纯策略**：如果一个纯策略对另一个纯策略总是产生更好的收益，无论对手如何选择，那么它就是占优的。\n- **行参与者**：如果 $a>c$ 且 $b>d$，则第1行严格占优于第2行。行参与者总会选择第1行，即 $p^\\star=1$。列参与者知道这一点，会选择使行参与者收益最小化的列。因此，列参与者会选择第1列（如果 $a \\le b$）或第2列（如果 $b \\le a$）。均衡策略为 $x^\\star=(1,0)$，列参与者选择纯策略，博弈值为 $v=\\min(a,b)$。\n- **列参与者**：如果 $a>b$ 且 $c>d$，则第2列严格占优于第1列（因为列参与者是最小化者，希望收益更小）。列参与者总会选择第2列，即 $q^\\star=0$。行参与者知道这一点，会选择使自己收益最大化的行，即第1行（如果 $b \\ge d$）或第2行（如果 $d \\ge b$）。均衡策略为 $y^\\star=(0,1)$，行参与者选择纯策略，博弈值为 $v=\\max(b,d)$。\n\n**纯策略鞍点**：如果矩阵中的一个元素 $A_{ij}$ 既是其所在行的最小值，又是其所在列的最大值，那么它就是一个纯策略鞍点。例如，如果 $a \\le b$ 且 $a \\ge c$，则 $(a,c)$ 构成第1列，行参与者会选择收益为 $a$ 的第1行。而 $(a,b)$ 构成第1行，列参与者会选择收益为 $a$ 的第1列。因此，$(1,1)$ 是一个纯策略纳什均衡。此时，$x^\\star=(1,0)$, $y^\\star=(1,0)$，博弈值为 $v=a$。在这种情况下，不需要混合策略。\n\n**退化情况**：当 $a-b-c+d=0$ 时，上述公式中的分母为零。\n- 如果在这种情况下还存在占优策略或鞍点，则解由它们决定。\n- 如果没有占优策略或鞍点，这个条件意味着一个参与者的无差异条件对另一个参与者的策略没有约束。例如，如果 $d-c=0$ 且 $d-b=0$（即 $b=c=d$），那么 $a=b=c=d$，所有收益都相同。任何策略都是最优的。如果 $d-c \\neq 0$，但 $a-b-c+d=0$，则 $p^\\star$ 的分子非零而分母为零，表明无差异条件永远无法满足，这意味着存在纯策略占优，我们回到了之前的边缘情况。如果分子和分母都为零（例如，$d=c$ 且 $a=b$），那么行参与者对两行的收益是相同的，无论列参与者如何选择。这会导致有无穷多个均衡策略。", "answer": "$$\n\\boxed{\\begin{pmatrix} p^\\star, & q^\\star, & v \\end{pmatrix} = \\begin{pmatrix} \\frac{d-c}{a-b-c+d}, & \\frac{d-b}{a-b-c+d}, & \\frac{ad-bc}{a-b-c+d} \\end{pmatrix}}\n$$", "id": "3199092"}, {"introduction": "在掌握了有限博弈的基础后，我们将视野扩展到包含连续策略空间的博弈。这个练习 [@problem_id:3199088] 探讨了当简单均衡的条件不被满足时会发生什么，从而引出“极小化极大值差距”这一重要概念。通过这个例子，你将更深刻地理解为何混合策略是如此关键，以及它们如何在更复杂的场景中重建均衡。", "problem": "考虑一个双人零和博弈，其中玩家X（最小化者）在区间 $X = [0, 2\\pi]$ 中选择 $x$，而玩家Y（最大化者）从离散集合 $Y_{\\text{pure}} = \\{-1, 1\\}$ 中选择 $y$。给玩家Y的收益是 $f(x,y) = \\sin(x)\\, y$。在优化方法的意义上，最小最大值为 $\\inf_{x \\in X} \\sup_{y \\in Y_{\\text{pure}}} f(x,y)$，最大最小值为 $\\sup_{y \\in Y_{\\text{pure}}} \\inf_{x \\in X} f(x,y)$，而经典的最小最大不等式表明，在没有进一步假设的情况下，有 $\\inf_{x} \\sup_{y} f(x,y) \\ge \\sup_{y} \\inf_{x} f(x,y)$。\n\n定义内部最大函数 $g(x) = \\sup_{y \\in Y_{\\text{pure}}} f(x,y)$，并令 $\\operatorname{co}(g)$ 表示 $g$ 在 $X$ 上的凹包，即满足对所有 $x \\in X$ 都有 $h(x) \\le g(x)$ 的最大凹函数 $h: X \\to \\mathbb{R}$。假设，受最小最大定理中结构条件的启发，我们用非凹的内部收益 $g$ 的凹包 $\\operatorname{co}(g)$ 来替代它，从而形成松弛最小最大值 $\\inf_{x \\in X} \\operatorname{co}(g)(x)$。此外，允许玩家Y使用基于 $Y_{\\text{pure}}$ 的混合策略，这（在这种双线性收益下）等价于在凸包 $\\operatorname{conv}(Y_{\\text{pure}}) = [-1, 1]$ 中选择 $y$。\n\n从上述核心定义（零和博弈、最小最大/最大最小值、凹包）出发，完成以下任务：\n\n1. 从 $f(x,y)$ 和 $Y_{\\text{pure}}$ 显式推导出 $g(x)$。\n2. 计算纯策略最小最大值 $\\inf_{x \\in X} \\sup_{y \\in Y_{\\text{pure}}} f(x,y)$ 和纯策略最大最小值 $\\sup_{y \\in Y_{\\text{pure}}} \\inf_{x \\in X} f(x,y)$。\n3. 确定 $X$ 上的凹包 $\\operatorname{co}(g)$ 并计算 $\\inf_{x \\in X} \\operatorname{co}(g)(x)$。\n4. 计算当玩家Y被允许使用混合策略时的最大最小值，即 $\\sup_{y \\in [-1,1]} \\inf_{x \\in X} f(x,y)$，并证明该值等于步骤3中的松弛最小最大值。\n5. 最后，报告纯策略博弈的最小最大间隙的数值，其定义为\n$$\nG \\equiv \\inf_{x \\in X} \\sup_{y \\in Y_{\\text{pure}}} f(x,y)\\;-\\;\\sup_{y \\in Y_{\\text{pure}}} \\inf_{x \\in X} f(x,y).\n$$\n\n要求的最终答案是单个实数 $G$。无需四舍五入，也不涉及物理单位。", "solution": "该问题是优化方法和博弈论中的一个有效练习。所有术语都有明确定义，且问题在数学上和逻辑上是自洽的。我们按照问题陈述中概述的五个步骤进行求解。\n\n收益函数为 $f(x,y) = \\sin(x) y$，其中玩家X选择 $x \\in X = [0, 2\\pi]$ 以最小化收益，玩家Y选择 $y \\in Y_{\\text{pure}} = \\{-1, 1\\}$ 以最大化收益。\n\n1. 推导 $g(x) = \\sup_{y \\in Y_{\\text{pure}}} f(x,y)$：\n内部最大函数 $g(x)$ 定义为在玩家X固定选择 $x$ 的情况下，玩家Y可以实现的最大收益。\n$$\ng(x) = \\sup_{y \\in \\{-1, 1\\}} \\sin(x) y\n$$\n我们评估玩家Y每种可能的纯策略的收益：\n- 若 $y = 1$，收益为 $\\sin(x)$。\n- 若 $y = -1$，收益为 $-\\sin(x)$。\n上确界是这两个值中较大的一个：\n$$\ng(x) = \\max\\{\\sin(x), -\\sin(x)\\}\n$$\n这是绝对值函数的定义。因此，\n$$\ng(x) = |\\sin(x)|\n$$\n\n2. 计算纯策略最小最大值和最大最小值：\n\n纯策略最小最大值为 $\\inf_{x \\in X} \\sup_{y \\in Y_{\\text{pure}}} f(x,y)$。使用步骤1的结果，这等于：\n$$\n\\inf_{x \\in [0, 2\\pi]} g(x) = \\inf_{x \\in [0, 2\\pi]} |\\sin(x)|\n$$\n函数 $|\\sin(x)|$ 总是非负的，即 $|\\sin(x)| \\ge 0$。当 $\\sin(x) = 0$ 时，它达到最小值0。在区间 $x \\in [0, 2\\pi]$ 内，这发生在 $x = 0$、$x = \\pi$ 和 $x = 2\\pi$ 处。因此，最小最大值为0。\n$$\n\\inf_{x \\in X} \\sup_{y \\in Y_{\\text{pure}}} f(x,y) = 0\n$$\n纯策略最大最小值为 $\\sup_{y \\in Y_{\\text{pure}}} \\inf_{x \\in X} f(x,y)$。我们首先计算玩家Y每种纯策略的内部下确界：\n- 对于 $y=1$：问题是求 $\\inf_{x \\in [0, 2\\pi]} \\sin(x) \\cdot 1$。在区间 $[0, 2\\pi]$ 上 $\\sin(x)$ 的最小值为-1，出现在 $x=3\\pi/2$ 处。\n- 对于 $y=-1$：问题是求 $\\inf_{x \\in [0, 2\\pi]} \\sin(x) \\cdot (-1) = \\inf_{x \\in [0, 2\\pi]} -\\sin(x)$。这等价于 $-\\sup_{x \\in [0, 2\\pi]} \\sin(x)$。在 $[0, 2\\pi]$ 上 $\\sin(x)$ 的最大值为1，出现在 $x=\\pi/2$ 处。所以，下确界是-1。\n现在，我们对玩家Y的选择取上确界：\n$$\n\\sup_{y \\in \\{-1, 1\\}} \\{-1, -1\\} = -1\n$$\n因此，最大最小值为-1。\n$$\n\\sup_{y \\in Y_{\\text{pure}}} \\inf_{x \\in X} f(x,y) = -1\n$$\n\n3. 确定 $\\operatorname{co}(g)$ 并计算 $\\inf_{x \\in X} \\operatorname{co}(g)(x)$：\n要分析的函数是在区间 $X = [0, 2\\pi]$ 上的 $g(x) = |\\sin(x)|$。凹包 $\\operatorname{co}(g)$ 是满足对所有 $x \\in X$ 都有 $h(x) \\le g(x)$ 的最大凹函数 $h(x)$。\n令 $h(x) = \\operatorname{co}(g)(x)$。根据定义，对所有 $x \\in [0, 2\\pi]$，有 $h(x) \\le |\\sin(x)|$。\n对所有 $x \\in [0, 2\\pi]$，函数 $k(x) = 0$ 是一个凹函数（因为它是线性的）。它也满足 $k(x) = 0 \\le |\\sin(x)| = g(x)$。由于 $h(x)$ 是*最大*的此类凹函数，因此必须对所有 $x$ 都有 $h(x) \\ge k(x) = 0$。于是，我们有 $0 \\le h(x) \\le |\\sin(x)|$。\n这意味着在 $|\\sin(x)|=0$ 的点，也必须有 $h(x)=0$。在 $[0, 2\\pi]$ 中的这些点是 $x=0$、$x=\\pi$ 和 $x=2\\pi$。所以，$h(0)=0$，$h(\\pi)=0$ 和 $h(2\\pi)=0$。\n一个在 $[0, 2\\pi]$ 上是凹的函数 $h$ 必须满足Jensen不等式。让我们考察 $x_1 = \\pi/2$ 和 $x_2 = 3\\pi/2$ 之间的中点，即 $x_m = \\pi$。凹性要求：\n$$\nh(\\pi) \\ge \\frac{1}{2}h(\\pi/2) + \\frac{1}{2}h(3\\pi/2)\n$$\n由于 $h(\\pi)=0$ 且对所有 $x$ 都有 $h(x) \\ge 0$，我们得到：\n$$\n0 \\ge \\frac{1}{2}(h(\\pi/2) + h(3\\pi/2))\n$$\n因为 $h(\\pi/2) \\ge 0$ 且 $h(3\\pi/2) \\ge 0$，满足此不等式的唯一方法是 $h(\\pi/2)=0$ 且 $h(3\\pi/2)=0$。\n现在考虑区间 $[0, \\pi]$。我们有一个凹函数 $h(x)$，满足 $h(0)=0$，$h(\\pi/2)=0$，$h(\\pi)=0$，且 $h(x) \\ge 0$。一个在区间上非负且在端点处为零的凹函数，在该区间内必须处处为零。将此应用于像 $[0, \\pi/2]$ 和 $[\\pi/2, \\pi]$ 这样的子区间，我们推断出对所有 $x \\in [0, \\pi]$ 都有 $h(x)=0$。对区间 $[\\pi, 2\\pi]$ 的类似论证表明，在该区间上 $h(x)$ 也为0。\n因此，满足条件的唯一函数是对所有 $x \\in [0, 2\\pi]$ 都有 $h(x)=0$。\n$$\n\\operatorname{co}(g)(x) = 0\n$$\n那么松弛最小最大值为：\n$$\n\\inf_{x \\in X} \\operatorname{co}(g)(x) = \\inf_{x \\in [0, 2\\pi]} 0 = 0\n$$\n\n4. 计算混合策略最大最小值：\n在这里，玩家Y被允许从 $Y_{\\text{pure}}$ 的凸包中选择任何 $y$，即 $\\operatorname{conv}(\\{-1,1\\}) = [-1, 1]$。要计算的值是 $\\sup_{y \\in [-1,1]} \\inf_{x \\in [0, 2\\pi]} f(x,y)$。\n令 $H(y) = \\inf_{x \\in [0, 2\\pi]} \\sin(x) y$。\n- 若 $y > 0$，玩家X希望使 $\\sin(x)$ 尽可能为负。因此，$\\inf_{x} \\sin(x) y = y \\cdot (\\inf_{x} \\sin(x)) = y \\cdot (-1) = -y$。\n- 若 $y < 0$，玩家X希望使 $\\sin(x)$ 尽可能为正以最小化 $y \\sin(x)$。因此，$\\inf_{x} \\sin(x) y = y \\cdot (\\sup_{x} \\sin(x)) = y \\cdot (1) = y$。\n- 若 $y=0$，$H(0) = \\inf_x 0 = 0$。\n综合这些情况，我们得到对 $y \\in [-1, 1]$ 有 $H(y) = -|y|$。\n现在的问题是计算 $\\sup_{y \\in [-1,1]} H(y)$：\n$$\n\\sup_{y \\in [-1,1]} -|y|\n$$\n函数 $-|y|$ 在 $y=0$ 处有最大值0。\n$$\n\\sup_{y \\in [-1,1]} \\inf_{x \\in [0, 2\\pi]} f(x,y) = 0\n$$\n正如最小最大松弛理论所预期的，这个值0等于步骤3中求得的松弛最小最大值 $\\inf_{x \\in X} \\operatorname{co}(g)(x)$。\n\n5. 计算最小最大间隙 $G$：\n纯策略博弈的最小最大间隙定义为：\n$$\nG = \\left(\\inf_{x \\in X} \\sup_{y \\in Y_{\\text{pure}}} f(x,y)\\right) - \\left(\\sup_{y \\in Y_{\\text{pure}}} \\inf_{x \\in X} f(x,y)\\right)\n$$\n使用步骤2中计算出的值：\n$$\nG = 0 - (-1) = 1\n$$\n这个非零间隙表明，对于纯策略博弈，博弈的顺序是重要的，并且不存在纯策略均衡。通过允许混合策略建立的博弈值为0。", "answer": "$$\\boxed{1}$$", "id": "3199088"}, {"introduction": "理论的价值最终体现在实践中，尤其是在机器学习等现代计算领域。本练习 [@problem_id:3199108] 是对极小化极大定理核心假设的一次经验性探究。通过编写并观察一个简单算法的行为，你将亲眼见证为何凸-凹结构不仅仅是理论上的精巧设定，更是保证算法收敛、找到问题解的实际必要条件。", "problem": "要求您设计并实现一个实证检验，以说明在双人零和博弈中，为使最小最大定理能保证收敛到一个值，第二参与者变量具有凹性的必要性。该设计必须源于基本定义和事实：\n\n- 双人零和博弈由一个支付函数 $f(x,y)$ 指定，其中极小化参与者选择 $x$，极大化参与者选择 $y$，两者均在紧凸集上进行选择。最小最大定理指出，如果 $f$ 关于 $x$ 是凸的，关于 $y$ 是凹的，并且域是紧凸的，那么该博弈存在一个值，且\n$$\n\\min_{x \\in X} \\max_{y \\in Y} f(x,y) \\;=\\; \\max_{y \\in Y} \\min_{x \\in X} f(x,y).\n$$\n- 当关于 $y$ 的凹性不成立时，等式可能失效，博弈可能没有单一的值，并且标准鞍点算法可能无法收敛到一个共同的值。\n\n构建一个函数族 $f_{\\alpha}$，并演示如何通过数值最小最大法和标准投影梯度法的行为来检测对 $y$ 的凹性的违反。\n\n您的任务：\n\n1) 定义域和函数族。\n- 令 $X = [-1,1]$ 且 $Y = [-1,1]$。\n- 对于参数 $\\alpha \\in \\mathbb{R}_{\\ge 0}$，定义支付函数\n$$\nf_{\\alpha}(x,y) \\;=\\; x\\,y \\;+\\; \\alpha\\, y^4.\n$$\n- 对于固定的 $y$，$f_{\\alpha}$ 关于 $x$ 是线性的，因此是凸的。对于 $\\alpha > 0$，$f_{\\alpha}$ 在 $Y$ 上关于 $y$ 不是凹的。\n\n2) 通过离散化量化最小最大排序。\n- 将 $X$ 和 $Y$ 各自均匀离散化为 $N$ 个等间距点，在张量网格上评估 $f_{\\alpha}$，并按规定顺序取离散极值，从而近似计算\n$$\nV^{-+}_{\\alpha} \\;=\\; \\min_{x \\in X} \\max_{y \\in Y} f_{\\alpha}(x,y), \\qquad\nV^{+-}_{\\alpha} \\;=\\; \\max_{y \\in Y} \\min_{x \\in X} f_{\\alpha}(x,y)\n$$\n。使用 $N = 1001$。\n\n3) 实现一个标准鞍点算法并观察其行为。\n- 使用投影梯度下降-上升法 (PGDA)：在迭代 $t \\in \\{1,\\dots,T\\}$ 中，步长为 $\\eta_t = \\eta_0/\\sqrt{t}$，\n$$\nx_{t+1} \\;=\\; \\Pi_X\\!\\left( x_t \\;-\\; \\eta_t \\,\\nabla_x f_{\\alpha}(x_t,y_t) \\right), \\qquad\ny_{t+1} \\;=\\; \\Pi_Y\\!\\left( y_t \\;+\\; \\eta_t \\,\\nabla_y f_{\\alpha}(x_t,y_t) \\right),\n$$\n其中 $\\Pi_X$ 和 $\\Pi_Y$ 分别是到 $X$ 和 $Y$ 上的投影，且\n$$\n\\nabla_x f_{\\alpha}(x,y) \\;=\\; y, \\qquad \\nabla_y f_{\\alpha}(x,y) \\;=\\; x \\;+\\; 4\\alpha y^3.\n$$\n- 使用 $T = 20000$，$\\eta_0 = 0.2$，并初始化 $(x_1,y_1) = (0.5,-0.5)$。\n- 令支付的移动平均值为\n$$\n\\bar{f} \\;=\\; \\frac{2}{T} \\sum_{t=T/2+1}^{T} f_{\\alpha}(x_t,y_t).\n$$\n\n4) 在最终迭代处测量原始-对偶间隙。\n- 在 $(x_T,y_T)$ 处，使用 $N = 1001$ 个等距点对 $X$ 和 $Y$ 进行一维离散化，近似计算间隙\n$$\n\\mathrm{gap}_T \\;=\\; \\max_{y \\in Y} f_{\\alpha}(x_T,y) \\;-\\; \\min_{x \\in X} f_{\\alpha}(x,y_T)\n$$\n\n5) 测试套件。\n- 使用参数集 $\\alpha \\in \\{0.0, 0.3, 2.0\\}$。\n- 对于每个 $\\alpha$，计算 $(V^{-+}_{\\alpha}, V^{+-}_{\\alpha})$，运行 PGDA 算法计算 $\\bar{f}$，并计算 $\\mathrm{gap}_T$。\n- 将成功标准“算法收敛到一个值”定义为以下条件的合取：\n  - $|V^{-+}_{\\alpha} - V^{+-}_{\\alpha}| \\le \\varepsilon_{\\mathrm{eq}}$,\n  - $\\mathrm{gap}_T \\le \\varepsilon_{\\mathrm{gap}}$,\n  - $|\\bar{f} - V^{-+}_{\\alpha}| \\le \\varepsilon_{\\mathrm{val}}$.\n- 使用容差 $\\varepsilon_{\\mathrm{eq}} = 10^{-2}$，$\\varepsilon_{\\mathrm{gap}} = 5 \\times 10^{-2}$，$\\varepsilon_{\\mathrm{val}} = 5 \\times 10^{-2}$。\n\n6) 要求的最终输出格式。\n- 您的程序应生成单行输出，其中包含所有测试用例按测试套件顺序汇总的结果。对于每个 $\\alpha$，输出四元组\n$$\n\\left[ V^{-+}_{\\alpha},\\; V^{+-}_{\\alpha},\\; \\bar{f},\\; \\text{success} \\right],\n$$\n并将所有测试用例的结果展平为一个列表。因此，最终输出必须是单行，格式完全为\n“[r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12]”，\n其中 $r_k$ 是按所述顺序排列的值，布尔值打印为 True 或 False。\n\n不应需要用户输入；所有参数均如上文所述固定。本问题中没有物理单位、角度或百分比，因此无需报告。", "solution": "该问题要求通过实证来展示最小最大定理对支付函数凹凸性的依赖。具体来说，我们将构建一个由值 $\\alpha$ 参数化的双人零和博弈族，其中当 $\\alpha > 0$ 时，定理的条件被违反。然后，我们将使用数值方法证明这种违反会导致最小最大值等式失效，以及标准鞍点算法——投影梯度下降-上升法 (PGDA)——的收敛失败。\n\n一个双人零和博弈由一个支付函数 $f(x, y)$ 定义，其中参与者1从集合 $X$ 中选择 $x$ 以最小化支付，参与者2从集合 $Y$ 中选择 $y$ 以最大化支付。域 $X$ 和 $Y$ 要求是紧凸集。Von Neumann-Sion 最小最大定理指出，如果对于每个固定的 $y$，$f(x, y)$ 关于 $x$ 是凸的，并且对于每个固定的 $x$，$f(x, y)$ 关于 $y$ 是凹的，那么该博弈存在一个值，即：\n$$\n\\min_{x \\in X} \\max_{y \\in Y} f(x,y) = \\max_{y \\in Y} \\min_{x \\in X} f(x,y)\n$$\n我们将左侧记为 $V^{-+}$，右侧记为 $V^{+-}$。\n\n**1. 问题构建**\n\n选定的域为 $X = [-1, 1]$ 和 $Y = [-1, 1]$，它们都是紧凸集。支付函数由下式给出：\n$$\nf_{\\alpha}(x,y) = xy + \\alpha y^4\n$$\n其中 $\\alpha \\ge 0$ 是一个参数。\n\n我们必须首先验证其凹凸性。二阶偏导数是：\n$$\n\\frac{\\partial^2 f_{\\alpha}}{\\partial x^2} = 0\n$$\n$$\n\\frac{\\partial^2 f_{\\alpha}}{\\partial y^2} = 12 \\alpha y^2\n$$\n对于任何固定的 $y$，$f_{\\alpha}$ 关于 $x$ 是线性的，因此其关于 $x$ 的二阶导数为 $0$。二阶导数非负的函数是凸函数，所以对于所有 $\\alpha$，$f_{\\alpha}$ 关于 $x$ 都是凸的。\n为了使函数关于 $y$ 是凹的，其关于 $y$ 的二阶导数必须为非正。当 $\\alpha \\ge 0$ 时，对所有 $y$ 都有 $\\frac{\\partial^2 f_{\\alpha}}{\\partial y^2} = 12 \\alpha y^2 \\ge 0$。这仅在 $\\alpha = 0$ 的平凡情况下才为非正。对于任何 $\\alpha > 0$，该函数关于 $y$ 是严格凸的（对于 $y \\neq 0$），因此违反了最小最大定理的凹性要求。\n\n**2. 数值分析方法**\n\n我们将采用三种数值度量来研究违反凹性条件的影响。\n\n**a) 离散化最小最大值：** 我们通过将域 $X$ 和 $Y$ 离散化为 $N=1001$ 个等距点来近似 $V^{-+}_{\\alpha}$ 和 $V^{+-}_{\\alpha}$。我们构建一个支付矩阵 $M_{ij} = f_{\\alpha}(x_i, y_j)$ 并计算离散最小最大值：\n$$\nV^{-+}_{\\alpha} \\approx \\min_{i} \\max_{j} M_{ij} \\qquad \\text{和} \\qquad V^{+-}_{\\alpha} \\approx \\max_{j} \\min_{i} M_{ij}\n$$\n弱最小最大不等式始终成立：$V^{+-}_{\\alpha} \\le V^{-+}_{\\alpha}$。该定理在其条件下保证等式成立。一个显著的差异 $|V^{-+}_{\\alpha} - V^{+-}_{\\alpha}| > \\varepsilon_{\\mathrm{eq}}$ 是一个强有力的指标，表明定理的条件未被满足，且博弈缺少一个单一的值。\n\n**b) 投影梯度下降-上升法 (PGDA)：** 这是一种旨在寻找鞍点 $(x^*, y^*)$ 的迭代算法。更新公式如下：\n$$\nx_{t+1} = \\Pi_X\\left( x_t - \\eta_t \\nabla_x f_{\\alpha}(x_t,y_t) \\right)\n$$\n$$\ny_{t+1} = \\Pi_Y\\left( y_t + \\eta_t \\nabla_y f_{\\alpha}(x_t,y_t) \\right)\n$$\n其中 $\\Pi_X$ 和 $\\Pi_Y$ 分别是到集合 $X=[-1,1]$ 和 $Y=[-1,1]$ 上的投影，$\\eta_t$ 是第 $t$ 次迭代的步长。我们函数的梯度为：\n$$\n\\nabla_x f_{\\alpha}(x,y) = y\n$$\n$$\n\\nabla_y f_{\\alpha}(x,y) = x + 4\\alpha y^3\n$$\n如果算法收敛到一个鞍点 $(x^*, y^*)$，那么支付序列 $f_{\\alpha}(x_t, y_t)$ 应该收敛到博弈的值 $f_{\\alpha}(x^*, y^*)$。我们监测迭代后半部分的支付移动平均值 $\\bar{f}$，作为衡量算法行为的指标。\n\n**c) 原始-对偶间隙：** 在最终迭代 $T$ 时，我们测量原始-对偶间隙，它量化了状态 $(x_T, y_T)$ 距离真实鞍点的程度。\n$$\n\\mathrm{gap}_T = \\max_{y \\in Y} f_{\\alpha}(x_T,y) - \\min_{x \\in X} f_{\\alpha}(x,y_T)\n$$\n对于一个真实的鞍点 $(x^*, y^*)$，这个间隙为零。一个大的非零间隙表明算法未能找到鞍点。\n\n**3. 预期结果**\n\n*   **情况 $\\alpha = 0$：** 函数为 $f_0(x,y) = xy$。这是一个线性-线性函数，满足凸-凹条件。我们预期 $V^{-+}_0 = V^{+-}_0 = 0$。PGDA 算法应该收敛到鞍点 $(0,0)$，导致 $\\bar{f} \\approx 0$ 和 $\\mathrm{gap}_T \\approx 0$。收敛性测试应该会成功。\n\n*   **情况 $\\alpha > 0$：** 对 $y$ 的凹性条件被违反。我们预期会观察到一个最小最大间隙，$V^{-+}_{\\alpha} > V^{+-}_{\\alpha}$。$y$ 的梯度中的项 $4\\alpha y^3$ 起到了一个不稳定化的作用，将 $y$ 从 $0$ 推向其域的边界 $y=\\pm 1$。这会阻止 PGDA 算法收敛到单个点，可能导致周期性或混沌行为。因此，最终的迭代值 $(x_T, y_T)$ 不会构成一个鞍点，从而产生一个大的 $\\mathrm{gap}_T$，并且移动平均值 $\\bar{f}$ 可能不对应于一个有意义的值。收敛性测试预计会失败。\n\n该实现将对 $\\alpha \\in \\{0.0, 0.3, 2.0\\}$ 执行这些计算，并应用指定的成功标准来正式报告每种情况下的收敛性。这些结果将实证性地验证凸-凹结构对于最小最大定理提供的保证是至关重要的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs an empirical test to illustrate the necessity of concavity\n    in the second player’s variable for the minimax theorem to hold.\n    \"\"\"\n    # Define the test cases and parameters from the problem statement.\n    test_cases = [\n        # (alpha)\n        (0.0),\n        (0.3),\n        (2.0),\n    ]\n\n    # --- Fixed Parameters ---\n    N = 1001\n    T = 20000\n    eta_0 = 0.2\n    x_init, y_init = 0.5, -0.5\n    \n    # Tolerances for success criterion\n    eps_eq = 1e-2\n    eps_gap = 5e-2\n    eps_val = 5e-2\n\n    # Discretization grids for X and Y\n    x_grid = np.linspace(-1, 1, N)\n    y_grid = np.linspace(-1, 1, N)\n\n    results = []\n\n    for alpha in test_cases:\n        # Define the payoff function and its gradients\n        f_alpha = lambda x, y: x * y + alpha * y**4\n        grad_x_f = lambda x, y: y\n        grad_y_f = lambda x, y: x + 4 * alpha * y**3\n\n        # Task 2: Quantify minimax orderings by discretization\n        # We use broadcasting for efficiency. X_col is (N, 1), Y_row is (1, N).\n        # The resulting payoff_matrix[i, j] corresponds to f(x_grid[i], y_grid[j]).\n        X_col = x_grid[:, np.newaxis]\n        Y_row = y_grid[np.newaxis, :]\n        payoff_matrix = X_col * Y_row + alpha * Y_row**4\n\n        # V_minus_plus = min_x max_y f(x,y)\n        # For each x (row), find the max over y (columns). Then find min of those maxes.\n        max_over_y = np.max(payoff_matrix, axis=1)\n        V_minus_plus = np.min(max_over_y)\n        \n        # V_plus_minus = max_y min_x f(x,y)\n        # For each y (column), find min over x (rows). Then find max of those mins.\n        min_over_x = np.min(payoff_matrix, axis=0)\n        V_plus_minus = np.max(min_over_x)\n\n        # Task 3: Implement Projected Gradient Descent-Ascent (PGDA)\n        x, y = x_init, y_init\n        f_values_second_half = []\n        \n        for t in range(1, T + 1):\n            eta_t = eta_0 / np.sqrt(t)\n            \n            # Gradient update step\n            x_new = x - eta_t * grad_x_f(x, y)\n            y_new = y + eta_t * grad_y_f(x, y)\n            \n            # Projection step\n            x = np.clip(x_new, -1, 1)\n            y = np.clip(y_new, -1, 1)\n            \n            # Store payoffs from the second half of iterations\n            if t > T / 2:\n                f_values_second_half.append(f_alpha(x, y))\n        \n        # Final iterates\n        x_T, y_T = x, y\n        \n        # Calculate the running average of payoffs\n        f_bar = np.mean(f_values_second_half)\n\n        # Task 4: Measure primal-dual gap at the final iterate\n        # max_{y in Y} f(x_T, y) approximated by discretization\n        max_val_y = np.max(f_alpha(x_T, y_grid))\n        \n        # min_{x in X} f(x, y_T) approximated by discretization\n        min_val_x = np.min(f_alpha(x_grid, y_T))\n        \n        gap_T = max_val_y - min_val_x\n\n        # Task 5: Test for success\n        cond1 = np.abs(V_minus_plus - V_plus_minus) = eps_eq\n        cond2 = gap_T = eps_gap\n        cond3 = np.abs(f_bar - V_minus_plus) = eps_val\n        \n        success = cond1 and cond2 and cond3\n        \n        # Append the quadruple of results\n        results.extend([V_minus_plus, V_plus_minus, f_bar, success])\n\n    # Final print statement in the exact required format.\n    # Convert boolean to string \"True\" or \"False\" as required.\n    formatted_results = [f\"{r:.7f}\" if isinstance(r, (float, np.floating)) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# This block is for local execution and will not be part of the final answer string.\n# if __name__ == '__main__':\n#     solve()\n```", "id": "3199108"}]}