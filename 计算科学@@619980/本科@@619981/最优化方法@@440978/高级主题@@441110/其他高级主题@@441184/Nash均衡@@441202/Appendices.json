{"hands_on_practices": [{"introduction": "实践出真知。本节的第一个练习将带你进入一个经典的经济学场景：双寡头垄断。我们将比较两种不同的竞争模型——古诺（Cournot）模型，其中企业同时选择产量；以及斯塔克尔伯格（Stackelberg）模型，其中一家企业充当领导者。通过求解这两种情况下的均衡，你将亲身体验如何运用最优反应函数和逆向归纳法进行分析，并定量地理解“先行者优势”的来源。[@problem_id:3154609]", "problem": "考虑一个同质产品的双寡头数量竞争模型。市场逆需求函数为 $p(Q) = a - bQ$，其中 $a = 120$，$b = 2$。$Q = q_{1} + q_{2}$ 是总产量，$q_{i} \\ge 0$ 是企业 $i$ 的产量（$i \\in \\{1,2\\}$）。每个企业的边际成本为常数 $c = 20$，固定成本为零，因此企业 $i$ 的利润为 $\\pi_{i}(q_{i}, q_{j}) = \\big(p(q_{1}+q_{2}) - c\\big) q_{i}$。\n\n您将使用第一性原理的优化方法分析两种时序协议：\n\n- Stackelberg（两阶段）：企业 1（领导者）在阶段 1 选择 $q_{1}$。然后企业 2（跟随者）在阶段 2 观察到 $q_{1}$ 并选择 $q_{2}$。\n- Cournot（同时行动）：企业 1 和企业 2 同时选择 $q_{1}$ 和 $q_{2}$。\n\n使用纳什均衡（NE）作为相互最优反应的定义，通过求取适当的导数并应用一阶条件（FOC）来解决每个企业的问题，必要时通过凹性验证最优性。对于 Stackelberg 情况，采用逆向归纳法推导跟随者的最优反应和领导者的最优选择，然后计算由此产生的均衡产量和企业 1 的利润。接下来，通过求解最优反应方程组，推导 Cournot 博弈中的同时行动纳什均衡产量和企业 1 的利润。\n\n最后，计算企业 1 作为 Stackelberg 领导者相对于同时行动纳什均衡所获得的精确利润增益，定义为\n$\\Delta \\pi_{1} = \\pi_{1}^{\\text{Stackelberg}} - \\pi_{1}^{\\text{Cournot}}$。\n请给出精确的有理数作为最终答案（不要四舍五入）。最终答案中不要包含任何单位。", "solution": "我们分步求解两种博弈模型的均衡，并计算企业1的利润。\n\n**1. 古诺 (Cournot) 均衡求解**\n\n在古诺模型中，两个企业同时选择产量。每个企业最大化自己的利润，并将对方的产量视为给定。\n\n企业 $i$ 的利润函数为：\n$$\n\\pi_i(q_i, q_j) = (120 - 2(q_i + q_j) - 20)q_i = (100 - 2q_i - 2q_j)q_i = 100q_i - 2q_i^2 - 2q_iq_j\n$$\n\n为了找到企业1的最优反应，我们对 $\\pi_1$ 求关于 $q_1$ 的偏导数并令其为零（一阶条件）：\n$$\n\\frac{\\partial \\pi_1}{\\partial q_1} = 100 - 4q_1 - 2q_2 = 0\n$$\n这给出了企业1的最优反应函数：$4q_1 = 100 - 2q_2 \\implies q_1(q_2) = 25 - \\frac{1}{2}q_2$。\n\n由于对称性，企业2的最优反应函数为：$q_2(q_1) = 25 - \\frac{1}{2}q_1$。\n\n在纳什均衡中，两个最优反应函数必须同时满足。我们将一个代入另一个来求解均衡产量：\n$$\nq_1 = 25 - \\frac{1}{2}\\left(25 - \\frac{1}{2}q_1\\right) = 25 - 12.5 + \\frac{1}{4}q_1\n$$\n$$\n\\frac{3}{4}q_1 = 12.5 \\implies q_1 = \\frac{50}{3}\n$$\n因此，古诺均衡产量为 $q_1^{\\text{Cournot}} = q_2^{\\text{Cournot}} = \\frac{50}{3}$。\n\n企业1在古诺均衡下的利润为：\n$$\n\\pi_1^{\\text{Cournot}} = \\left(100 - 2\\left(\\frac{50}{3}\\right) - 2\\left(\\frac{50}{3}\\right)\\right) \\cdot \\frac{50}{3} = \\left(100 - \\frac{200}{3}\\right) \\cdot \\frac{50}{3} = \\frac{100}{3} \\cdot \\frac{50}{3} = \\frac{5000}{9}\n$$\n\n**2. 斯塔克尔伯格 (Stackelberg) 均衡求解**\n\n我们使用逆向归纳法。领导者（企业1）知道跟随者（企业2）会根据其最优反应函数 $q_2(q_1) = 25 - \\frac{1}{2}q_1$ 来行动。\n\n企业1将此反应代入自己的利润函数，以选择能最大化其利润的 $q_1$：\n$$\n\\pi_1(q_1) = \\left(100 - 2q_1 - 2\\left(25 - \\frac{1}{2}q_1\\right)\\right)q_1\n$$\n$$\n\\pi_1(q_1) = (100 - 2q_1 - 50 + q_1)q_1 = (50 - q_1)q_1 = 50q_1 - q_1^2\n$$\n\n为了最大化此利润，我们对 $q_1$ 求导并令其为零：\n$$\n\\frac{d\\pi_1}{dq_1} = 50 - 2q_1 = 0 \\implies q_1^{\\text{Stackelberg}} = 25\n$$\n\n企业1在斯塔克尔伯格均衡下的利润为：\n$$\n\\pi_1^{\\text{Stackelberg}} = (50 - 25) \\cdot 25 = 625\n$$\n\n**3. 计算利润增益**\n\n企业1作为领导者所获得的利润增益是斯塔克尔伯格利润与古诺利润之差：\n$$\n\\Delta \\pi_1 = \\pi_1^{\\text{Stackelberg}} - \\pi_1^{\\text{Cournot}} = 625 - \\frac{5000}{9} = \\frac{5625 - 5000}{9} = \\frac{625}{9}\n$$", "answer": "$$\\boxed{\\frac{625}{9}}$$", "id": "3154609"}, {"introduction": "在分散决策的基础上，这个练习将探讨“无政府代价”（price of anarchy）——即非合作行为给整个系统带来的效率损失。你将分析一个一般的双人线性二次博弈，分别计算纳什均衡（每个参与者都追求自身利益最大化）和社会最优解（所有参与者的总成本最小化）。这种对比对于理解从交通网络到资源分配等各类系统中的均衡效率至关重要。[@problem_id:3154673]", "problem": "考虑一个双人线性二次博弈，其中参与人 $i \\in \\{1,2\\}$ 选择一个标量决策变量 $x_i \\in \\mathbb{R}$。成本函数由下式给出\n$$\nf_i(x_1,x_2) \\;=\\; \\frac{1}{2} \\, q_i \\, x_i^{2} \\;+\\; b_i \\, x_i \\, x_{-i} \\;+\\; c_i \\, x_i,\n$$\n其中 $x_{-i}$ 表示另一位参与人的决策。令 $q_1 = 2$, $q_2 = 4$, $b_1 = 1$, $b_2 = 1$, $c_1 = -5$, 且 $c_2 = 1$。假设对每个参与人都有 $q_i > 0$，因此每个参与人的优化问题对于其自身的决策变量是严格凸的。\n\n从纳什均衡（NE）的定义（即没有参与人可以通过单方面偏离来降低自己的成本）出发，并使用可微凸函数的一阶最优性条件，推导刻画纳什均衡的分块线性系统，并求解该均衡点 $(x_1^{\\ast}, x_2^{\\ast})$。然后，构建最小化社会成本的中心化优化问题\n$$\nF(x_1,x_2) \\;=\\; f_1(x_1,x_2) \\;+\\; f_2(x_1,x_2),\n$$\n推导其一阶最优性条件，并求解中心化最优解 $(x_1^{c}, x_2^{c})$。\n\n将您的最终结果表示为两个解连接成的单行向量 $\\big(x_1^{\\ast}, \\, x_2^{\\ast}, \\, x_1^{c}, \\, x_2^{c}\\big)$。无需四舍五入。", "solution": "该问题要求为一个双人线性二次博弈找到两个不同的解：纳什均衡（NE）解和中心化（社会最优）解。\n\n首先，我们确定纳什均衡，记为 $(x_1^{\\ast}, x_2^{\\ast})$。纳什均衡是一种状态，在该状态下，假设另一位参与人的决策保持不变，任何参与人都无法通过单方面改变自己的决策来改善其结果（即降低其成本）。对于参与人 $i \\in \\{1,2\\}$，其成本函数 $f_i(x_1, x_2)$ 关于其自身的决策变量 $x_i$ 是可微且凸的，此条件在数学上通过一阶最优性条件 $\\frac{\\partial f_i}{\\partial x_i} = 0$ 来表示。\n\n参与人 $i$ 的成本函数如下：\n$$\nf_i(x_1,x_2) = \\frac{1}{2} q_i x_i^{2} + b_i x_i x_{-i} + c_i x_i\n$$\n其中 $x_{-i}$ 是另一位参与人的决策。问题陈述 $q_i > 0$，这确保了 $f_i$ 关于 $x_i$ 是严格凸的，从而保证一阶条件能够确定参与人 $i$ 优化问题的唯一最小值。\n\n让我们计算每个参与人的偏导数。\n对参与人 1：\n$$\n\\frac{\\partial f_1}{\\partial x_1} = q_1 x_1 + b_1 x_2 + c_1 = 0\n$$\n\n对参与人 2：\n$$\n\\frac{\\partial f_2}{\\partial x_2} = q_2 x_2 + b_2 x_1 + c_2 = 0\n$$\n\n这两个方程构成了纳什均衡 $(x_1^{\\ast}, x_2^{\\ast})$ 的一个线性系统。将给定参数值 $q_1 = 2$, $q_2 = 4$, $b_1 = 1$, $b_2 = 1$, $c_1 = -5$, 且 $c_2 = 1$ 代入：\n\\begin{align*}\n2 x_1^{\\ast} + x_2^{\\ast} - 5 = 0 \\\\\n4 x_2^{\\ast} + x_1^{\\ast} + 1 = 0\n\\end{align*}\n整理得：\n\\begin{align*}\n2 x_1^{\\ast} + x_2^{\\ast} = 5 \\\\\nx_1^{\\ast} + 4 x_2^{\\ast} = -1\n\\end{align*}\n从第一个方程，我们可以用 $x_1^{\\ast}$ 表示 $x_2^{\\ast}$：$x_2^{\\ast} = 5 - 2 x_1^{\\ast}$。\n将此代入第二个方程：\n$$\nx_1^{\\ast} + 4(5 - 2 x_1^{\\ast}) = -1 \\implies x_1^{\\ast} + 20 - 8 x_1^{\\ast} = -1 \\implies -7 x_1^{\\ast} = -21 \\implies x_1^{\\ast} = 3\n$$\n将 $x_1^{\\ast}$ 的值代回以求得 $x_2^{\\ast}$：\n$$\nx_2^{\\ast} = 5 - 2(3) = 5 - 6 = -1\n$$\n因此，纳什均衡为 $(x_1^{\\ast}, x_2^{\\ast}) = (3, -1)$。\n\n接下来，我们确定中心化最优解，记为 $(x_1^{c}, x_2^{c})$。这是使社会总成本 $F(x_1,x_2) = f_1(x_1,x_2) + f_2(x_1,x_2)$ 最小化的决策对。\n社会成本函数 $F(x_1,x_2)$ 为：\n$$\nF(x_1,x_2) = \\left(\\frac{1}{2} q_1 x_1^{2} + b_1 x_1 x_2 + c_1 x_1\\right) + \\left(\\frac{1}{2} q_2 x_2^{2} + b_2 x_1 x_2 + c_2 x_2\\right)\n$$\n$$\nF(x_1,x_2) = \\frac{1}{2} q_1 x_1^{2} + \\frac{1}{2} q_2 x_2^{2} + (b_1 + b_2) x_1 x_2 + c_1 x_1 + c_2 x_2\n$$\n为了找到最小值，我们计算 $F$ 的梯度并令其为零。一阶条件为 $\\frac{\\partial F}{\\partial x_1} = 0$ 和 $\\frac{\\partial F}{\\partial x_2} = 0$。\n$$\n\\frac{\\partial F}{\\partial x_1} = q_1 x_1 + (b_1 + b_2) x_2 + c_1 = 0\n$$\n$$\n\\frac{\\partial F}{\\partial x_2} = q_2 x_2 + (b_1 + b_2) x_1 + c_2 = 0\n$$\n将参数值代入该系统：\n\\begin{align*}\n2 x_1^{c} + (1+1) x_2^{c} - 5 = 0 \\implies 2 x_1^{c} + 2 x_2^{c} = 5 \\\\\n4 x_2^{c} + (1+1) x_1^{c} + 1 = 0 \\implies 2 x_1^{c} + 4 x_2^{c} = -1\n\\end{align*}\n用第二个方程减去第一个方程，得到：\n$$\n(2 x_1^{c} + 4 x_2^{c}) - (2 x_1^{c} + 2 x_2^{c}) = -1 - 5 \\implies 2 x_2^{c} = -6 \\implies x_2^{c} = -3\n$$\n将 $x_2^{c} = -3$ 代入第一个方程：\n$$\n2 x_1^{c} + 2(-3) = 5 \\implies 2 x_1^{c} - 6 = 5 \\implies 2 x_1^{c} = 11 \\implies x_1^{c} = \\frac{11}{2}\n$$\n因此，中心化最优解为 $(x_1^{c}, x_2^{c}) = (\\frac{11}{2}, -3)$。\n\n最终结果表示为连接的行向量 $\\big(x_1^{\\ast}, x_2^{\\ast}, x_1^{c}, x_2^{c}\\big)$。\n计算出的值为 $x_1^{\\ast} = 3$, $x_2^{\\ast} = -1$, $x_1^{c} = \\frac{11}{2}$ 和 $x_2^{c} = -3$。\n最终向量为 $\\big(3, -1, \\frac{11}{2}, -3\\big)$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 3  -1  \\frac{11}{2}  -3 \\end{pmatrix}}\n$$", "id": "3154673"}, {"introduction": "虽然解析解很有用，但许多现实世界中的博弈过于复杂，无法通过纸笔解决。这个编程练习将介绍在一类被称为“势博弈”（potential games）的特殊博弈中，寻找纳什均衡的计算方法。你将实现并比较两种迭代算法——块坐标下降法和梯度下降法——来观察如何通过数值优化找到均衡点，这项技术在机器学习和工程学的现代应用中占据核心地位。[@problem_id:3154641]", "problem": "考虑一个连续的 $n$ 人最小化博弈，其策略为 $x \\in \\mathbb{R}^n$，其中参与者 $i$ 控制坐标 $x_i$ 并寻求最小化其可微成本 $f_i(x)$。如果存在一个连续可微的势函数 $\\Phi(x)$，使得对于每个参与者 $i$，其偏导数满足 $\\frac{\\partial f_i(x)}{\\partial x_i} = \\frac{\\partial \\Phi(x)}{\\partial x_i}$，则该博弈是一个精确势博弈 (Exact Potential Game, EPG)。在此类博弈中，纳什均衡是一个策略组合 $x^\\star$，其中没有参与者可以单方面降低其成本。在可微性条件下，这意味着同时满足所有 $i$ 的一阶平稳性条件 $\\frac{\\partial f_i(x^\\star)}{\\partial x_i} = 0$。由于 EPG 的性质，这等价于 $\\nabla \\Phi(x^\\star) = 0$。\n\n您的任务是实现一个程序，对于给定的二次势函数和固定步长，比较应用于势函数 $\\Phi$ 的两种优化方法的收敛速度（达到固定容差所需的迭代次数）：块坐标下降法 (Block Coordinate Descent, BCD) 和同步梯度下降法 (Simultaneous Gradient Descent, GD)。两种方法都作用于势函数，而不是直接作用于每个参与者的 $f_i$。势函数由以下凸二次型给出：\n$$\n\\Phi(x) = \\tfrac{1}{2} x^\\top Q x + c^\\top x,\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，而 $c \\in \\mathbb{R}^n$。对于给定的初始条件 $x^{(0)}$、固定步长 $\\alpha$（仅用于 GD）、容差 $\\varepsilon$ 和最大迭代预算 $T_{\\max}$，对每个测试用例执行以下操作：\n- 根据 EPG 性质和 $\\Phi$ 的一阶平稳性计算纳什均衡 $x^\\star$。\n- 运行块坐标下降法 (BCD)：每次对一个坐标执行 $\\Phi$ 的循环一维精确最小化，同时保持其他坐标固定，并以完整周期为单位计算迭代次数（一个周期等于 $n$ 次坐标更新）。每个周期结束后，计算欧几里得范数 $\\lVert x^{(t)} - x^\\star \\rVert_2$，当其小于或等于 $\\varepsilon$ 或当 $t$ 达到 $T_{\\max}$ 时停止。\n- 运行同步梯度下降法 (GD)：使用固定步长 $\\alpha$ 通过单次梯度步骤同时更新所有坐标，在每一步之后计算 $\\lVert x^{(t)} - x^\\star \\rVert_2$，并在其小于或等于 $\\varepsilon$ 或当 $t$ 达到 $T_{\\max}$ 时停止。\n\n如果任一方法在 $T_{\\max}$ 次迭代内未能达到容差，则报告该方法的迭代次数为 $T_{\\max}$。此问题中没有物理单位，也没有使用角度量。\n\n使用以下测试套件，其中每个用例指定了 $Q$、$c$、$x^{(0)}$、$\\alpha$、$\\varepsilon$ 和 $T_{\\max}$：\n\n- 测试用例 $1$ ($n=3$)：\n  $$\n  Q^{(1)} = \\begin{bmatrix}\n  3  1  0 \\\\\n  1  4  1 \\\\\n  0  1  2\n  \\end{bmatrix},\\quad\n  c^{(1)} = \\begin{bmatrix}\n  -1\\\\\n  2\\\\\n  -3\n  \\end{bmatrix},\\quad\n  x^{(1)}_0 = \\begin{bmatrix}\n  5\\\\\n  -4\\\\\n  3\n  \\end{bmatrix},\\quad\n  \\alpha^{(1)} = 0.2,\\quad\n  \\varepsilon^{(1)} = 10^{-6},\\quad\n  T^{(1)}_{\\max} = 10000.\n  $$\n\n- 测试用例 $2$ ($n=3$，病态但对称正定)：\n  $$\n  Q^{(2)} = \\begin{bmatrix}\n  10^{-3}  0  0 \\\\\n  0  1  0.99 \\\\\n  0  0.99  1\n  \\end{bmatrix},\\quad\n  c^{(2)} = \\begin{bmatrix}\n  0.1\\\\\n  -2\\\\\n  1\n  \\end{bmatrix},\\quad\n  x^{(2)}_0 = \\begin{bmatrix}\n  3\\\\\n  -2\\\\\n  4\n  \\end{bmatrix},\\quad\n  \\alpha^{(2)} = 0.5,\\quad\n  \\varepsilon^{(2)} = 10^{-6},\\quad\n  T^{(2)}_{\\max} = 10000.\n  $$\n\n- 测试用例 $3$ ($n=3$，导致 GD 不收敛的激进的步长)：\n  $$\n  Q^{(3)} = \\begin{bmatrix}\n  10  2  0 \\\\\n  2  1  0 \\\\\n  0  0  0.5\n  \\end{bmatrix},\\quad\n  c^{(3)} = \\begin{bmatrix}\n  5\\\\\n  -3\\\\\n  1\n  \\end{bmatrix},\\quad\n  x^{(3)}_0 = \\begin{bmatrix}\n  -1\\\\\n  5\\\\\n  2\n  \\end{bmatrix},\\quad\n  \\alpha^{(3)} = 0.3,\\quad\n  \\varepsilon^{(3)} = 10^{-6},\\quad\n  T^{(3)}_{\\max} = 2000.\n  $$\n\n- 测试用例 $4$ ($n=2$)：\n  $$\n  Q^{(4)} = \\begin{bmatrix}\n  2  -0.8 \\\\\n  -0.8  1.5\n  \\end{bmatrix},\\quad\n  c^{(4)} = \\begin{bmatrix}\n  -1\\\\\n  2.5\n  \\end{bmatrix},\\quad\n  x^{(4)}_0 = \\begin{bmatrix}\n  10\\\\\n  -10\n  \\end{bmatrix},\\quad\n  \\alpha^{(4)} = 0.7,\\quad\n  \\varepsilon^{(4)} = 10^{-6},\\quad\n  T^{(4)}_{\\max} = 10000.\n  $$\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例 $k \\in \\{1,2,3,4\\}$，输出两个整数：块坐标下降法 (BCD) 达到容差所需的迭代次数，以及同步梯度下降法 (GD) 达到容差所需的迭代次数；如果某种方法在迭代预算内未能收敛，则为该方法输出 $T^{(k)}_{\\max}$。因此，最终输出必须是\n$$\n[\\text{BCD}^{(1)},\\text{GD}^{(1)},\\text{BCD}^{(2)},\\text{GD}^{(2)},\\text{BCD}^{(3)},\\text{GD}^{(3)},\\text{BCD}^{(4)},\\text{GD}^{(4)}].\n$$", "solution": "该问题要求比较块坐标下降法 (BCD) 和同步梯度下降法 (GD) 在寻找一个 $n$ 人精确势博弈 (EPG) 的纳什均衡时的收敛速度。该均衡对应于给定二次势函数 $\\Phi(x)$ 的最小化子。\n\n**1. 寻找纳什均衡**\n\n该博弈被定义为一个具有连续可微势函数 $\\Phi(x)$ 的 EPG。纳什均衡 $x^\\star$ 是一个策略组合，在该组合中，没有参与者可以单方面改善其结果。对于每个参与者 $i$ 的可微成本函数 $f_i(x)$，这意味着一阶平稳性条件 $\\frac{\\partial f_i(x^\\star)}{\\partial x_i} = 0$ 对所有 $i \\in \\{1, \\dots, n\\}$ 均成立。EPG 的性质，$\\frac{\\partial f_i(x)}{\\partial x_i} = \\frac{\\partial \\Phi(x)}{\\partial x_i}$，意味着这些条件的集合等价于势函数的梯度为零：$\\nabla \\Phi(x^\\star) = 0$。\n\n势函数以凸二次型的形式给出：\n$$\n\\Phi(x) = \\tfrac{1}{2} x^\\top Q x + c^\\top x\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定矩阵，而 $c \\in \\mathbb{R}^n$。\n\n$\\Phi(x)$ 的梯度计算如下：\n$$\n\\nabla \\Phi(x) = \\frac{1}{2} (Q + Q^\\top)x + c = Qx + c\n$$\n因为 $Q$ 是对称的。\n\n将梯度设为零可得到纳什均衡条件：$Q x^\\star + c = 0$。\n由于 $Q$ 是正定的，因此它是可逆的。因此，存在唯一的纳什均衡 $x^\\star$，可以通过求解以下线性方程组找到：\n$$\nx^\\star = -Q^{-1} c\n$$\n在实现中，为了稳定性和效率，该线性系统是通过数值方法求解 $x^\\star$ 的，而不是显式计算逆矩阵 $Q^{-1}$。\n\n**2. 块坐标下降法 (BCD)**\n\n块坐标下降法是一种迭代优化算法，在每一步中，它都针对单个坐标最小化目标函数，同时保持所有其他坐标固定。对于此问题，我们对每个坐标 $x_i$（其中 $i \\in \\{0, 1, \\dots, n-1\\}$）执行循环更新。BCD 的单次迭代（由计数器 $t$ 表示）包含一个由 $n$ 次更新组成的完整周期。\n\n对于二次势函数 $\\Phi(x)$，关于单个坐标 $x_i$ 的最小化可以精确执行。为了在保持所有 $j \\neq i$ 的 $x_j$ 固定的情况下找到 $x_i$ 的最优值，我们求解第 $i$ 个坐标的平稳性条件：$\\frac{\\partial \\Phi(x)}{\\partial x_i} = (\\nabla \\Phi(x))_i = Q_{ii} x_i + \\sum_{j \\neq i} Q_{ij} x_j + c_i = 0$。\n求解 $x_i$，得到坐标 $i$ 新值的更新规则：\n$$\nx_i^{\\text{new}} = - \\frac{1}{Q_{ii}} \\left( \\sum_{j \\neq i} Q_{ij} x_j + c_i \\right)\n$$\n由于 $Q$ 是正定的，其对角线元素 $Q_{ii}$ 均为正。我们的实现方式在一个周期内顺序更新向量 $x$ 的坐标（高斯-赛德尔法）。\n\n**3. 同步梯度下降法 (GD)**\n\n同步梯度下降法同时更新向量 $x$ 的所有分量，通过沿势函数梯度的反方向移动一步来执行。对于具有固定步长 $\\alpha > 0$ 的迭代 $t$，其更新规则为：\n$$\nx^{(t+1)} = x^{(t)} - \\alpha \\nabla \\Phi(x^{(t)}) = x^{(t)} - \\alpha (Q x^{(t)} + c)\n$$\n为使 GD 收敛到凸二次函数的唯一最小化子，步长 $\\alpha$ 必须在 $0 < \\alpha < 2/\\lambda_{\\max}(Q)$ 的范围内，其中 $\\lambda_{\\max}(Q)$ 是矩阵 $Q$ 的最大特征值。如果 $\\alpha$ 的选择超出此范围，算法可能会振荡或发散。\n\n以下是用于解决问题的 Python 代码实现。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_bcd(Q, c, x0, x_star, eps, T_max):\n    \"\"\"\n    Performs Block Coordinate Descent on the quadratic potential Phi(x).\n    An iteration is one full cycle of n coordinate updates.\n    \"\"\"\n    n = Q.shape[0]\n    x_bcd = x0.copy()\n\n    # If the initial point is already within tolerance, it takes 0 iterations.\n    if np.linalg.norm(x_bcd - x_star) = eps:\n        return 0\n\n    for t in range(1, T_max + 1):\n        for i in range(n):\n            # The update for x[i] is to exactly minimize Phi along the i-th axis.\n            # This is found by setting the i-th partial derivative to 0:\n            # (Qx)_i + c_i = 0 => Q_ii * x_i + sum_{j!=i} Q_ij * x_j + c_i = 0\n            # We use the most recently updated values of x (Gauss-Seidel style).\n            non_diag_sum = Q[i, :] @ x_bcd - Q[i, i] * x_bcd[i]\n            x_bcd[i] = -(non_diag_sum + c[i]) / Q[i, i]\n\n        # Check for convergence after each full cycle\n        if np.linalg.norm(x_bcd - x_star) = eps:\n            return t\n    \n    return T_max\n\ndef run_gd(Q, c, x0, x_star, alpha, eps, T_max):\n    \"\"\"\n    Performs a fixed-step Simultaneous Gradient Descent on the potential Phi(x).\n    \"\"\"\n    x_gd = x0.copy()\n\n    # If the initial point is already within tolerance, it takes 0 iterations.\n    if np.linalg.norm(x_gd - x_star) = eps:\n        return 0\n\n    for t in range(1, T_max + 1):\n        # Gradient of Phi(x) is nabla_Phi = Qx + c\n        grad = Q @ x_gd + c\n        \n        # Update step\n        x_gd = x_gd - alpha * grad\n        \n        # Check for convergence after each step\n        if np.linalg.norm(x_gd - x_star) = eps:\n            return t\n        \n    return T_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"Q\": np.array([[3.0, 1.0, 0.0], [1.0, 4.0, 1.0], [0.0, 1.0, 2.0]]),\n            \"c\": np.array([-1.0, 2.0, -3.0]),\n            \"x0\": np.array([5.0, -4.0, 3.0]),\n            \"alpha\": 0.2,\n            \"eps\": 1e-6,\n            \"T_max\": 10000\n        },\n        # Test case 2\n        {\n            \"Q\": np.array([[1e-3, 0.0, 0.0], [0.0, 1.0, 0.99], [0.0, 0.99, 1.0]]),\n            \"c\": np.array([0.1, -2.0, 1.0]),\n            \"x0\": np.array([3.0, -2.0, 4.0]),\n            \"alpha\": 0.5,\n            \"eps\": 1e-6,\n            \"T_max\": 10000\n        },\n        # Test case 3\n        {\n            \"Q\": np.array([[10.0, 2.0, 0.0], [2.0, 1.0, 0.0], [0.0, 0.0, 0.5]]),\n            \"c\": np.array([5.0, -3.0, 1.0]),\n            \"x0\": np.array([-1.0, 5.0, 2.0]),\n            \"alpha\": 0.3,\n            \"eps\": 1e-6,\n            \"T_max\": 2000\n        },\n        # Test case 4\n        {\n            \"Q\": np.array([[2.0, -0.8], [-0.8, 1.5]]),\n            \"c\": np.array([-1.0, 2.5]),\n            \"x0\": np.array([10.0, -10.0]),\n            \"alpha\": 0.7,\n            \"eps\": 1e-6,\n            \"T_max\": 10000\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Q, c, x0 = case[\"Q\"], case[\"c\"], case[\"x0\"]\n        alpha, eps, T_max = case[\"alpha\"], case[\"eps\"], case[\"T_max\"]\n\n        # 1. Compute the Nash equilibrium x_star by solving Q * x_star = -c\n        x_star = np.linalg.solve(Q, -c)\n        \n        # 2. Run Block Coordinate Descent\n        bcd_iters = run_bcd(Q, c, x0, x_star, eps, T_max)\n        results.append(bcd_iters)\n        \n        # 3. Run Simultaneous Gradient Descent\n        gd_iters = run_gd(Q, c, x0, x_star, alpha, eps, T_max)\n        results.append(gd_iters)\n\n    # Final print statement in the exact required format.\n    # print(f\"[{','.join(map(str, results))}]\")\n    # This function is not called in the final output, but running it yields the answer.\n```", "answer": "$$[11,46,55,10000,10,2000,10,20]$$", "id": "3154641"}]}