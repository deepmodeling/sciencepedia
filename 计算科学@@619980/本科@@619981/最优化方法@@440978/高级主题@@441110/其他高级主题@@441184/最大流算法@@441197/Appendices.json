{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。此练习旨在通过手动计算，带你走过 Ford-Fulkerson 方法的全过程。通过使用广度优先搜索 (BFS) 寻找增广路径，你将亲手构建和更新残差图，直到找到最大流，这个过程将加深你对算法核心机制的理解。最后，通过识别最终残差图中的最小割，你将有机会验证强大的最大流最小割定理。[@problem_id:3148824]", "problem": "考虑一个有源点 $s$ 和汇点 $t$ 的有向网络。节点集为 $V=\\{s,a,b,c,d,t\\}$。每条有向边 $(u,v)$ 的容量 $c_{uv}$ 如下所示。所有未指明的有向边对的容量均为 $0$。\n\n- $s \\to a$：$8$\n- $s \\to b$：$5$\n- $a \\to b$：$3$\n- $a \\to c$：$4$\n- $a \\to d$：$2$\n- $b \\to a$：$1$\n- $b \\to c$：$4$\n- $b \\to d$：$5$\n- $c \\to d$：$8$\n- $c \\to t$：$5$\n- $d \\to t$：$7$\n\n从流的基本定义（容量限制、节点流量守恒和残余容量）出发，应用 Ford-Fulkerson 方法，并使用广度优先搜索（BFS）来选择增广路径。在每次 BFS 中，按顶点名称的字母顺序探索出向的残余邻居。在每个增广步骤中，计算并记录所产生的残余图，列出所有残余容量严格为正的有向边上的残余容量（包括前向和后向残余边）。持续此过程，直到残余图中不存在 $s$–$t$ 路径为止。\n\n然后，通过以下方式验证最优性：\n- 在最终的残余图中，确定从 $s$ 可达的顶点集合 $S \\subseteq V$，并用它来指定一个 $s$–$t$ 割 $(S,\\bar{S})$。\n- 从基本原理计算该割的容量，并解释为什么它能证明流是最大的。\n\n将最大 $s$–$t$ 流的值表示为一个实数。无需四舍五入。", "solution": "问题要求在给定的有向网络中找到从源点 $s$ 到汇点 $t$ 的最大流。我们将使用 Ford-Fulkerson 方法。增广路径将通过在残余图上使用广度优先搜索（BFS）找到。在 BFS 的每一步中，出向的残余邻居按字母顺序进行探索。\n\n该网络的顶点集为 $V=\\{s,a,b,c,d,t\\}$。有向边 $(u,v)$ 的初始容量 $c(u,v)$ 为：\n- $c(s,a) = 8$\n- $c(s,b) = 5$\n- $c(a,b) = 3$\n- $c(a,c) = 4$\n- $c(a,d) = 2$\n- $c(b,a) = 1$\n- $c(b,c) = 4$\n- $c(b,d) = 5$\n- $c(c,d) = 8$\n- $c(c,t) = 5$\n- $c(d,t) = 7$\n所有其他容量均为 $0$。\n\nFord-Fulkerson 方法在残余图 $G_f$ 中迭代地寻找 $s-t$ 增广路径并增加流量。边 $(u,v)$ 的残余容量为 $c_f(u,v) = c(u,v) - f(u,v)$，其中 $f(u,v)$ 是当前流量。每当有单位流量从 $u$ 发送到 $v$，前向边 $(u,v)$ 的残余容量减少一个单位，而后向边 $(v,u)$ 的残余容量增加一个单位。最初，所有地方的流量都为 $0$，因此残余图与原始容量图相同。\n\n**迭代 1：在 $G_{f_0}$ 中寻找增广路径**\n\n我们从总流量 $|f|=0$ 开始。残余容量 $c_{f_0}(u,v)$ 等于原始容量 $c(u,v)$。\n1.  **BFS 寻找增广路径：**\n    - 队列：$[s]$。前驱节点映射 `pred`: $\\{s: \\text{None}\\}$。\n    - 出队 $s$。邻居：$a, b$。按字母顺序：\n        - 入队 $a$\n        - 入队 $b$\n    - 队列：$[a, b]$。出队 $a$。邻居：$b, c, d$。\n        - $b$ 已经在队列中。\n        - 入队 $c$\n        - 入队 $d$\n    - 队列：$[b, c, d]$。出队 $b$。邻居：$a, c, d$ 都已访问/在队列中。\n    - 队列：$[c, d]$。出队 $c$。邻居：$d, t$。\n        - $d$ 在队列中。\n        - 入队 $t$\n2.  **路径与瓶颈：** 找到的路径是 $P_1: s \\to a \\to c \\to t$。瓶颈容量是 $\\Delta_1 = \\min(c_{f_0}(s,a), c_{f_0}(a,c), c_{f_0}(c,t)) = \\min(8, 4, 5) = 4$。\n3.  **增广流量：** 我们沿着 $P_1$ 推送 $\\Delta_1=4$ 单位的流量。总流量变为 $|f| = 4$。\n4.  **残余图 $G_{f_1}$：**\n    - 对于 $P_1$ 中的边：$c_{f_1}(s,a) = 8-4=4$, $c_{f_1}(a,c) = 4-4=0$, $c_{f_1}(c,t) = 5-4=1$。\n    - 对于后向边：$c_{f_1}(a,s) = 0+4=4$, $c_{f_1}(c,a) = 0+4=4$, $c_{f_1}(t,c) = 0+4=4$。\n    - $G_{f_1}$ 中严格为正的残余容量：\n        - $c_{f_1}(s,a)=4$, $c_{f_1}(s,b)=5$\n        - $c_{f_1}(a,b)=3$, $c_{f_1}(a,d)=2$, $c_{f_1}(a,s)=4$\n        - $c_{f_1}(b,a)=1$, $c_{f_1}(b,c)=4$, $c_{f_1}(b,d)=5$\n        - $c_{f_1}(c,a)=4$, $c_{f_1}(c,d)=8$, $c_{f_1}(c,t)=1$\n        - $c_{f_1}(d,t)=7$\n        - $c_{f_1}(t,c)=4$\n\n**迭代 2：在 $G_{f_1}$ 中寻找增广路径**\n\n1.  **BFS：**\n    - 队列：$[s]$。`pred`: $\\{s: \\text{None}\\}$。\n    - 出队 $s$。邻居：$a, b$。入队 $a, b$。\n    - 队列：$[a, b]$。出队 $a$。邻居（按字母顺序）：$b, d, s$。$b$ 在队列中。入队 $d$ (`pred[d]=a`)。$s$ 已访问。\n    - 队列：$[b, d]$。出队 $b$。邻居（按字母顺序）：$a, c, d$。$a$ 已访问。入队 $c$ (`pred[c]=b`)。$d$ 在队列中。\n    - 队列：$[d, c]$。出队 $d$。邻居：$t$。入队 $t$ (`pred[t]=d`)。到达 $t$。\n2.  **路径与瓶颈：** 路径是 $P_2: s \\to a \\to d \\to t$。瓶颈是 $\\Delta_2 = \\min(c_{f_1}(s,a), c_{f_1}(a,d), c_{f_1}(d,t)) = \\min(4, 2, 7) = 2$。\n3.  **增广流量：** 总流量变为 $|f| = 4+2=6$。\n4.  **残余图 $G_{f_2}$：**\n    - $P_2$ 中的边：$c_{f_2}(s,a) = 4-2=2$, $c_{f_2}(a,d)=2-2=0$, $c_{f_2}(d,t)=7-2=5$。\n    - 后向边：$c_{f_2}(a,s) = 4+2=6$, $c_{f_2}(d,a)=0+2=2$, $c_{f_2}(t,d)=0+2=2$。\n    - $G_{f_2}$ 中严格为正的残余容量：\n        - $c_{f_2}(s,a)=2$, $c_{f_2}(s,b)=5$\n        - $c_{f_2}(a,b)=3$, $c_{f_2}(a,s)=6$\n        - $c_{f_2}(b,a)=1$, $c_{f_2}(b,c)=4$, $c_{f_2}(b,d)=5$\n        - $c_{f_2}(c,a)=4$, $c_{f_2}(c,d)=8$, $c_{f_2}(c,t)=1$\n        - $c_{f_2}(d,a)=2$, $c_{f_2}(d,t)=5$\n        - $c_{f_2}(t,c)=4$, $c_{f_2}(t,d)=2$\n\n**迭代 3：在 $G_{f_2}$ 中寻找增广路径**\n\n1.  **BFS：**\n    - 队：$[s]$。出队 $s$。入队 $a,b$。\n    - 队：$[a,b]$。出队 $a$。邻居 $b,s$ 已访问/在队列中。\n    - 队：$[b]$。出队 $b$。邻居 $a,c,d,s$。$a$ 已访问。入队 $c$ (`pred[c]=b`)。入队 $d$ (`pred[d]=b`)。$s$ 已访问。\n    - 队：$[c,d]$。出队 $c$。邻居 $a,d,t$。$a,d$ 已访问/在队列中。入队 $t$ (`pred[t]=c`)。到达 $t$。\n2.  **路径与瓶颈：** 路径是 $P_3: s \\to b \\to c \\to t$。瓶颈是 $\\Delta_3 = \\min(c_{f_2}(s,b), c_{f_2}(b,c), c_{f_2}(c,t)) = \\min(5, 4, 1) = 1$。\n3.  **增广流量：** 总流量是 $|f| = 6+1=7$。\n4.  **残余图 $G_{f_3}$：**\n    - $P_3$ 中的边：$c_{f_3}(s,b)=5-1=4$, $c_{f_3}(b,c)=4-1=3$, $c_{f_3}(c,t)=1-1=0$。\n    - 后向边：$c_{f_3}(b,s)=0+1=1$, $c_{f_3}(c,b)=0+1=1$, $c_{f_3}(t,c)=4+1=5$。\n    - $G_{f_3}$ 中严格为正的残余容量：\n        - $c_{f_3}(s,a)=2$, $c_{f_3}(s,b)=4$\n        - $c_{f_3}(a,b)=3$, $c_{f_3}(a,s)=6$\n        - $c_{f_3}(b,a)=1$, $c_{f_3}(b,c)=3$, $c_{f_3}(b,d)=5$, $c_{f_3}(b,s)=1$\n        - $c_{f_3}(c,a)=4$, $c_{f_3}(c,b)=1$, $c_{f_3}(c,d)=8$\n        - $c_{f_3}(d,a)=2$, $c_{f_3}(d,t)=5$\n        - $c_{f_3}(t,c)=5$, $c_{f_3}(t,d)=2$\n\n**迭代 4：在 $G_{f_3}$ 中寻找增广路径**\n\n1.  **BFS：**\n    - 队：$[s]$。出队 $s$。入队 $a,b$。\n    - 队：$[a,b]$。出队 $a$。邻居 $b,s$ 已访问/在队列中。\n    - 队：$[b]$。出队 $b$。邻居 $a,c,d,s$。$a,s$ 已访问。入队 $c$ (`pred[c]=b`)。入队 $d$ (`pred[d]=b`)。\n    - 队：$[c,d]$。出队 $c$。邻居 $a,b,d$ 已访问/在队列中。\n    - 队：$[d]$。出队 $d$。邻居 $a,t$。$a$ 已访问。入队 $t$ (`pred[t]=d`)。到达 $t$。\n2.  **路径与瓶颈：** 路径是 $P_4: s \\to b \\to d \\to t$。瓶颈是 $\\Delta_4 = \\min(c_{f_3}(s,b), c_{f_3}(b,d), c_{f_3}(d,t)) = \\min(4, 5, 5) = 4$。\n3.  **增广流量：** 总流量是 $|f| = 7+4=11$。\n4.  **残余图 $G_{f_4}$：**\n    - $P_4$ 中的边：$c_{f_4}(s,b)=4-4=0$, $c_{f_4}(b,d)=5-4=1$, $c_{f_4}(d,t)=5-4=1$。\n    - 后向边：$c_{f_4}(b,s)=1+4=5$, $c_{f_4}(d,b)=0+4=4$, $c_{f_4}(t,d)=2+4=6$。\n    - $G_{f_4}$ 中严格为正的残余容量：\n        - $c_{f_4}(s,a)=2$\n        - $c_{f_4}(a,b)=3$, $c_{f_4}(a,s)=6$\n        - $c_{f_4}(b,a)=1$, $c_{f_4}(b,c)=3$, $c_{f_4}(b,d)=1$, $c_{f_4}(b,s)=5$\n        - $c_{f_4}(c,a)=4$, $c_{f_4}(c,b)=1$, $c_{f_4}(c,d)=8$\n        - $c_{f_4}(d,a)=2$, $c_{f_4}(d,b)=4$, $c_{f_4}(d,t)=1$\n        - $c_{f_4}(t,c)=5$, $c_{f_4}(t,d)=6$\n\n**迭代 5：在 $G_{f_4}$ 中寻找增广路径**\n\n1.  **BFS：**\n    - 队：$[s]$。出队 $s$。邻居 $a$。入队 $a$。\n    - 队：$[a]$。出队 $a$。邻居 $b,s$。入队 $b$ (`pred[b]=a`)。$s$ 已访问。\n    - 队：$[b]$。出队 $b$。邻居 $a,c,d,s$。$a,s$ 已访问。入队 $c$ (`pred[c]=b`)。入队 $d$ (`pred[d]=b`)。\n    - 队：$[c,d]$。出队 $c$。邻居 $a,b,d$ 已访问/在队列中。\n    - 队：$[d]$。出队 $d$。邻居 $a,b,t$。$a,b$ 已访问。入队 $t$ (`pred[t]=d`)。到达 $t$。\n2.  **路径与瓶颈：** 路径是 $P_5: s \\to a \\to b \\to d \\to t$。瓶颈是 $\\Delta_5 = \\min(c_{f_4}(s,a), c_{f_4}(a,b), c_{f_4}(b,d), c_{f_4}(d,t)) = \\min(2, 3, 1, 1) = 1$。\n3.  **增广流量：** 总流量是 $|f| = 11+1=12$。\n4.  **残余图 $G_{f_5}$：**\n    - $P_5$ 中的边：$c_{f_5}(s,a)=2-1=1$, $c_{f_5}(a,b)=3-1=2$, $c_{f_5}(b,d)=1-1=0$, $c_{f_5}(d,t)=1-1=0$。\n    - 后向边：$c_{f_5}(a,s)=6+1=7$, $c_{f_5}(b,a)=1+1=2$, $c_{f_5}(d,b)=4+1=5$, $c_{f_5}(t,d)=6+1=7$。\n    - $G_{f_5}$ 中严格为正的残余容量：\n        - $c_{f_5}(s,a)=1$\n        - $c_{f_5}(a,b)=2$, $c_{f_5}(a,s)=7$\n        - $c_{f_5}(b,a)=2$, $c_{f_5}(b,c)=3$, $c_{f_5}(b,s)=5$\n        - $c_{f_5}(c,a)=4$, $c_{f_5}(c,b)=1$, $c_{f_5}(c,d)=8$\n        - $c_{f_5}(d,a)=2$, $c_{f_5}(d,b)=5$\n        - $c_{f_5}(t,c)=5$, $c_{f_5}(t,d)=7$\n\n**终止**\n\n我们在最终的残余图 $G_{f_5}$ 上再尝试进行一次 BFS：\n1.  **BFS：**\n    - 队：$[s]$。出队 $s$。入队 $a$。\n    - 队：$[a]$。出队 $a$。邻居 $b,s$。入队 $b$。\n    - 队：$[b]$。出队 $b$。邻居 $a,c,s$。入队 $c$。\n    - 队：$[c]$。出队 $c$。邻居 $a,b,d$。入队 $d$。\n    - 队：$[d]$。出队 $d$。邻居 $a,b$。都已访问。\n    - 队列变空。已访问的节点集合为 $\\{s, a, b, c, d\\}$。汇点 $t$ 从 $s$ 不可达。\n算法终止。最大流是所有增广量之和：$|f|_{max} = \\Delta_1 + \\Delta_2 + \\Delta_3 + \\Delta_4 + \\Delta_5 = 4 + 2 + 1 + 4 + 1 = 12$。\n\n**最优性验证**\n\n根据最大流最小割定理，最大流的值等于最小 $s-t$ 割的容量。我们可以从最终的残余图 $G_{f_5}$ 中找到一个最小割。\n1.  **确定割：** 令 $S$ 为在 $G_{f_5}$ 中从 $s$ 可达的顶点集合，$\\bar{S} = V \\setminus S$。从我们最后一次 BFS 尝试中，我们发现 $S = \\{s, a, b, c, d\\}$。因此，$\\bar{S} = \\{t\\}$。\n2.  **计算割的容量：** 割 $(S, \\bar{S})$ 的容量是所有原始边 $(u,v)$（其中 $u \\in S$ 且 $v \\in \\bar{S}$）的容量之和。\n    - 从 $S$ 跨越到 $\\bar{S}$ 的边是 $(c,t)$ 和 $(d,t)$。\n    - 割的容量是 $C(S, \\bar{S}) = c(c,t) + c(d,t)$。\n    - 代入给定值：$C(S, \\bar{S}) = 5 + 7 = 12$。\n3.  **结论：** 我们找到了一个值为 12 的流和一个容量为 12 的 $s-t$ 割。由于任何流的值最多是任何割的容量，因此该流必定是最大流，该割必定是最小割。这个割的存在证明了值为 12 的流是最大的。", "answer": "$$\\boxed{12}$$", "id": "3148824"}, {"introduction": "残差图中最巧妙也最关键的概念之一是“反向边”的使用，它允许算法“撤销”或“重路由”先前分配的流。本练习将让你聚焦于这一特定机制。通过对一个包含反向边的特定路径进行单步增广，你将清楚地看到流是如何被重新调整的，从而为找到更优的整体流动方案创造可能。掌握这个概念对于深刻理解最大流算法至关重要。[@problem_id:3148815]", "problem": "考虑一个有向网络，其顶点集为 $V=\\{s,a,b,c,t\\}$，边集为 $E=\\{(s,a),(s,c),(a,b),(a,t),(c,b),(b,t)\\}$。每条边 $(u,v)\\in E$ 都有一个非负容量 $c_{uv}$。该网络上的一个流是一个函数 $f:V\\times V\\to\\mathbb{R}$，它满足边的容量限制、除源点 $s$ 和汇点 $t$ 外所有顶点的流量守恒，以及对于所有有序对 $(u,v)\\in V\\times V$ 的斜对称性 $f_{uv}=-f_{vu}$。由一个可行流导出的残留网络是根据沿有向对增加或减少流量的能力来定义的，从而产生正向和反向的残留容量。Ford–Fulkerson 方法在残留网络中沿着一条从 $s$到 $t$ 的有向路径进行增广，增广量为不违反该路径上任何残留容量的最大值，然后相应地更新流。\n\n设容量为\n$$(c_{s,a},c_{s,c},c_{a,b},c_{a,t},c_{c,b},c_{b,t})=(6,5,3,4,4,7)。$$\n一个初始可行流由下式给出\n$$(f_{s,a},f_{s,c},f_{a,b},f_{a,t},f_{c,b},f_{b,t})=(3,2,2,1,2,4),$$\n并且，根据斜对称性，对于所有有序对 $(u,v)$，有 $f_{v,u}=-f_{u,v}$。\n\n在该初始流导出的残留网络中，考虑有向路径\n$$s\\to c\\to b\\to a\\to t,$$\n其中从 $b$到 $a$ 的遍历是沿着原始边 $(a,b)$ 的反向进行的。沿着这条路径，以路径上残留容量允许的最大量进行一次增广，并相应地更新流 $f$。\n\n任务：\n1. 确定路径 $s\\to c\\to b\\to a\\to t$ 上由残留容量允许的最大增广值，并执行此增广以获得更新后的流 $f$。\n2. 计算此次增广后，有向对 $(s,c)$、$(c,b)$、$(a,b)$、$(b,a)$ 和 $(a,t)$ 的更新后残留容量。\n3. 对至少一个有序对，明确验证斜对称性 $f_{uv}=-f_{vu}$。\n4. 最后，报告这次单次增广后从 $s$ 到 $t$ 的流值，其定义为 $\\sum_{v\\in V} f_{s,v}$。\n\n以单个实数形式提供从 $s$ 到 $t$ 的最终流值。无需四舍五入。", "solution": "该问题已经过验证，被认为是适定的、自洽的且科学上合理的。所有提供的数据，包括初始流，都与流网络的定义一致。这些任务是 Ford–Fulkerson 方法的直接应用。\n\n问题要求在给定网络中沿指定路径进行一次流增广。设初始流为 $f$，更新后的流为 $f'$。容量由向量 $(c_{s,a}, c_{s,c}, c_{a,b}, c_{a,t}, c_{c,b}, c_{b,t}) = (6, 5, 3, 4, 4, 7)$ 给出。初始可行流由 $(f_{s,a}, f_{s,c}, f_{a,b}, f_{a,t}, f_{c,b}, f_{b,t}) = (3, 2, 2, 1, 2, 4)$ 给出。所有不在 $E$ 中的边上的流均为 $0$。\n\n关于流 $f$ 的顶点有序对 $(u,v)$ 的残留容量 $c_f(u,v)$ 定义如下：\n1.  如果 $(u,v) \\in E$（一条正向边），则 $c_f(u,v) = c_{uv} - f_{uv}$。这是剩余容量。\n2.  如果 $(v,u) \\in E$（一条反向边），则 $c_f(u,v) = f_{vu}$。这是可以推回的流量。\n3.  其他情况下 $c_f(u,v) = 0$。\n\n增广路径为 $P = s \\to c \\to b \\to a \\to t$。我们必须首先确定沿此路径的最大可能增广值，即路径各段残留容量的最小值。\n\n路径的各段为 $(s,c)$、$(c,b)$、$(b,a)$ 和 $(a,t)$。\n1.  **段 $(s,c)$：** 这是一条正向边，因为 $(s,c) \\in E$。其残留容量为：\n    $$c_f(s,c) = c_{sc} - f_{sc} = 5 - 2 = 3$$\n2.  **段 $(c,b)$：** 这是一条正向边，因为 $(c,b) \\in E$。其残留容量为：\n    $$c_f(c,b) = c_{cb} - f_{cb} = 4 - 2 = 2$$\n3.  **段 $(b,a)$：** 这是一条反向边，因为原始边是 $(a,b) \\in E$。其残留容量是边 $(a,b)$ 上的当前流量：\n    $$c_f(b,a) = f_{ab} = 2$$\n4.  **段 $(a,t)$：** 这是一条正向边，因为 $(a,t) \\in E$。其残留容量为：\n    $$c_f(a,t) = c_{at} - f_{at} = 4 - 1 = 3$$\n\n最大增广值 $\\Delta$ 是这些残留容量的最小值：\n$$\\Delta = \\min\\{c_f(s,c), c_f(c,b), c_f(b,a), c_f(a,t)\\} = \\min\\{3, 2, 2, 3\\} = 2$$\n这完成了任务1的第一部分。\n\n接下来，我们沿路径 $P$ 将流增加 $\\Delta=2$。流 $f'_{uv}$ 根据以下规则更新：\n-   对于 $P$ 上的每条正向边 $(u,v)$，我们增加流量：$f'_{uv} = f_{uv} + \\Delta$。\n-   对于 $P$ 上的每条反向边 $(u,v)$（其中 $(v,u) \\in E$），我们减少原始边上的流量：$f'_{vu} = f_{vu} - \\Delta$。\n\n应用这些规则：\n-   对于 $(s,c)$：$f'_{sc} = f_{sc} + \\Delta = 2 + 2 = 4$。\n-   对于 $(c,b)$：$f'_{cb} = f_{cb} + \\Delta = 2 + 2 = 4$。\n-   对于 $(b,a)$，原始边是 $(a,b)$：$f'_{ab} = f_{ab} - \\Delta = 2 - 2 = 0$。\n-   对于 $(a,t)$：$f'_{at} = f_{at} + \\Delta = 1 + 2 = 3$。\n\n不属于增广路径的边上的流量保持不变：\n-   $f'_{sa} = f_{sa} = 3$。\n-   $f'_{bt} = f_{bt} = 4$。\n\n这完成了任务1的第二部分。\n\n对于任务2，我们使用新的流 $f'$ 计算指定对的更新后残留容量。\n-   $(s,c)$: 正向边。$c_{f'}(s,c) = c_{sc} - f'_{sc} = 5 - 4 = 1$。\n-   $(c,b)$: 正向边。$c_{f'}(c,b) = c_{cb} - f'_{cb} = 4 - 4 = 0$。\n-   $(a,b)$: 正向边。$c_{f'}(a,b) = c_{ab} - f'_{ab} = 3 - 0 = 3$。\n-   $(b,a)$: 反向边。$c_{f'}(b,a) = f'_{ab} = 0$。\n-   $(a,t)$: 正向边。$c_{f'}(a,t) = c_{at} - f'_{at} = 4 - 3 = 1$。\n\n对于任务3，我们为一个有序对验证斜对称性 $f'_{uv} = -f'_{vu}$。我们使用 $(a,b)$。\n根据我们的更新，我们有 $f'_{ab} = 0$。\n根据斜对称性的定义，$f'_{ba}$ 必须是 $-f'_{ab}$。\n因此，$f'_{ba} = -0 = 0$。我们使用反向流的增广规则来验证这一点。初始反向流为 $f_{ba} = -f_{ab} = -2$。路径段 $b \\to a$ 在残留图中是一个正向段，因此流量沿此方向增加。从 $b$到 $a$ 的流量推送 $\\Delta$ 等同于将 $\\Delta$ 加到 $f_{ba}$ 上。\n$f'_{ba} = f_{ba} + \\Delta = -2 + 2 = 0$。\n结果是一致的，斜对称性成立：$f'_{ab} = 0$ 且 $f'_{ba}=0$。\n\n对于任务4，我们报告从 $s$到 $t$ 的最终流值。流的值 $|f'|$ 是从源点 $s$ 流出的总净流量：\n$$|f'| = \\sum_{v \\in V} f'_{sv}$$\n唯一可能使 $f'_{sv}$ 非零的顶点 $v$ 是 $a$ 和 $c$，因为 $(s,a)$ 和 $(s,c)$ 是从 $s$ 出发的仅有的边。\n$$|f'| = f'_{sa} + f'_{sc}$$\n代入更新后的流值：\n$$|f'| = 3 + 4 = 7$$\n作为检验，我们可以计算流入汇点 $t$ 的总净流量：\n$$|f'| = \\sum_{v \\in V} f'_{vt} = f'_{at} + f'_{bt} = 3 + 4 = 7$$\n数值匹配。单次增广后的流值为 $7$。初始流值为 $|f| = f_{sa} + f_{sc} = 3+2=5$。新的流值为 $|f'| = |f| + \\Delta = 5+2=7$，这是一致的。", "answer": "$$\\boxed{7}$$", "id": "3148815"}, {"introduction": "现在，让我们从纸笔计算转向代码实现，将理论付诸实践。这个练习要求你实现 Edmonds-Karp 算法，并将其作为一个探索性工具，来检验最大流最小割定理的一个重要推论。通过编程实验，你将凭经验验证，为何增加非最小割边的容量不会影响最大流，而增加最小割边的容量则可能改变结果。这项任务不仅能锻炼你的编程能力，更能让你体会到算法在验证和探索理论方面的强大力量。[@problem_id:3148846]", "problem": "考虑一个有源点 $s$ 和汇点 $t$ 的有向流网络。流网络是一个有向图 $(V,E)$，带有一个容量函数 $\\text{cap}: E \\to \\mathbb{R}_{\\ge 0}$。一个可行流 $f: E \\to \\mathbb{R}_{\\ge 0}$ 必须满足：对于每条边 $(u,v) \\in E$，满足容量限制 $0 \\le f(u,v) \\le \\text{cap}(u,v)$；对于每个节点 $x \\in V \\setminus \\{s,t\\}$，满足流量守恒约束 $\\sum_{(u,x)\\in E} f(u,x) = \\sum_{(x,v)\\in E} f(x,v)$。流的值为 $\\sum_{(s,v)\\in E} f(s,v)$。\n\n一个割 $(S,T)$ 是 $V$ 的一个划分，使得 $s \\in S$ 且 $t \\in T$。其容量定义为 $\\sum_{(u,v)\\in E,\\, u\\in S,\\, v\\in T} \\text{cap}(u,v)$。\n\n您的任务是构建一个特定的流网络，并凭经验验证：增加不跨越最小割的边的容量不会改变最大流，而增加跨越最小割的边的容量可能会改变最大流。您必须使用称为 Edmonds–Karp 算法的广度优先搜索 (BFS) 变体来实现 Ford–Fulkerson 方法（广度优先搜索 (BFS) 寻找边数最少的增广路径）。\n\n使用以下网络：\n- 顶点: $V = \\{s,a,b,c,t\\}$。\n- 有向边和容量：\n  - $(s,a)$，容量为 $4$。\n  - $(s,b)$，容量为 $3$。\n  - $(a,c)$，容量为 $100$。\n  - $(b,c)$，容量为 $100$。\n  - $(c,t)$，容量为 $5$。\n\n将任何未在上面列出的边解释为容量为 $0$。当测试用例指定增加这样一条边的容量时，实际上是向网络中添加了该边。\n\n实现一个程序，该程序：\n1. 计算给定网络上的基准最大 $s$–$t$ 流。\n2. 将以下每个容量增加独立地应用于基础网络，并重新计算最大流值：\n   - 测试 $1$：将 $(a,c)$ 的容量增加 $50$。\n   - 测试 $2$：将 $(s,a)$ 的容量增加 $10$。\n   - 测试 $3$：将 $(a,c)$ 的容量增加 $50$，并将 $(b,c)$ 的容量增加 $200$。\n   - 测试 $4$：将 $(c,t)$ 的容量增加 $1$。\n   - 测试 $5$：将 $(c,t)$ 的容量增加 $100$。\n   - 测试 $6$：将 $(a,b)$ 的容量增加 $100$（注意：此边初始不存在，即容量为 $0$）。\n3. 在单行上生成以下最终输出，形式为用方括号括起来的逗号分隔列表：\n   - 基准最大流值，为整数。\n   - 对于测试 $1$、$2$、$3$ 和 $6$，输出一个布尔值，表示新的最大流是否等于基准值。\n   - 对于测试 $4$ 和 $5$，输出新的最大流值，为整数。\n\n因此，您的程序应以以下确切格式输出：\n$[F_0,B_1,B_2,B_3,M_4,M_5,B_6]$，\n其中 $F_0$ 是基准最大流，$B_i$ 是用于指定测试的布尔值，测试其是否与基准值相等，而 $M_4$、$M_5$ 是给出测试 $4$ 和 $5$ 的新最大流值的整数。\n\n不允许用户输入。所有数值答案都是无单位的整数或布尔值。算法计算必须对所有指定的测试都正确。\n\n测试套件摘要：\n- 基准：无更改。\n- 测试 $1$：$(a,c) \\leftarrow (a,c) + 50$。\n- 测试 $2$：$(s,a) \\leftarrow (s,a) + 10$。\n- 测试 $3$：$(a,c) \\leftarrow (a,c) + 50$，$ (b,c) \\leftarrow (b,c) + 200$。\n- 测试 $4$：$(c,t) \\leftarrow (c,t) + 1$。\n- 测试 $5$：$(c,t) \\leftarrow (c,t) + 100$。\n- 测试 $6$：$(a,b) \\leftarrow (a,b) + 100$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，例如 `[F_0,B_1,B_2,B_3,M_4,M_5,B_6]`。", "solution": "### 理论框架与求解\n\n该问题要求实现 Edmonds-Karp 算法，这是 Ford-Fulkerson 方法的一种特定实现，用于在给定网络中寻找最大流。核心原理是最大流最小割定理，该定理指出，网络中从源点 $s$ 到汇点 $t$ 的最大流等于任何 $s$-$t$ 割的最小容量。\n\n**Edmonds-Karp 算法**\nEdmonds-Karp 算法在残差图 $G_f$ 上操作。对于给定的流 $f$，边 $(u,v)$ 的残差容量为 $c_f(u,v) = \\text{cap}(u,v) - f(u,v)$。残差图由具有正残差容量的边组成。它还包括残差容量为 $c_f(v,u) = f(u,v)$ 的“反向”边 $(v,u)$，表示“推回”流的可能性。\n\n算法流程如下：\n1.  将所有边的流 $f$ 初始化为 $0$。\n2.  当残差图 $G_f$ 中存在从 $s$ 到 $t$ 的增广路径时：\n    a. 找到这样一条路径 $P$。Edmonds-Karp 变体规定使用广度优先搜索（BFS）来找到边数最少的路径。\n    b. 确定该路径的瓶颈容量，$\\Delta = \\min_{(u,v) \\in P} \\{c_f(u,v)\\}$。\n    c. 沿路径 $P$ 增加 $\\Delta$ 的流。对于 $P$ 中的每条边 $(u,v)$，更新流：$f(u,v) \\leftarrow f(u,v) + \\Delta$ 和 $f(v,u) \\leftarrow f(v,u) - \\Delta$。这等同于更新残差图：$c_f(u,v) \\leftarrow c_f(u,v) - \\Delta$ 和 $c_f(v,u) \\leftarrow c_f(v,u) + \\Delta$。\n3. 当找不到更多增广路径时，算法终止。从源点发出的总流即为最大流。\n\n**基础网络分析**\n让我们分析给定的网络 $G = (V, E)$，其中 $V = \\{s,a,b,c,t\\}$。\n- 从源点出发的边：$(s,a)$ 容量为 $4$，$(s,b)$ 容量为 $3$。从 $s$ 出发的总容量为 $4+3=7$。\n- 到汇点的边：$(c,t)$ 容量为 $5$。到 $t$ 的总输入容量为 $5$。\n- 内部边：$(a,c)$ 容量为 $100$，$(b,c)$ 容量为 $100$。\n\n最大流受网络“最窄”部分的限制，这对应于一个最小割。一个割 $(S,T)$ 是 $V$ 的一个划分，其中 $s \\in S$ 且 $t \\in T$。让我们评估一些简单割的容量：\n-   $C_1 = (\\{s\\}, \\{a,b,c,t\\})$。容量为 $\\text{cap}(s,a) + \\text{cap}(s,b) = 4 + 3 = 7$。\n-   $C_2 = (\\{s,a,b,c\\}, \\{t\\})$。容量为 $\\text{cap}(c,t) = 5$。\n-   $C_3 = (\\{s,a,b\\}, \\{c,t\\})$。容量为 $\\text{cap}(a,c) + \\text{cap}(b,c) = 100 + 100 = 200$。\n\n这些割容量的最小值是 $5$。根据最大流最小割定理，基准最大流 $F_0$ 为 $5$。最小割是 $(S=\\{s,a,b,c\\}, T=\\{t\\})$，唯一跨越此割的边是 $(c,t)$。\n\n**测试用例分析**\n该问题展示了最大流最小割定理的一个关键推论：增加*不*属于最小割的边的容量不会增加最大流，因为该边不是瓶颈。相反，增加*属于*最小割的边的容量可以增加最大流。\n\n-   **基准 ($F_0$)**：如前所述，最大流受边 $(c,t)$ 的容量限制。因此，$F_0 = 5$。\n\n-   **测试 1**：将 $\\text{cap}(a,c)$ 增加 $50$ 至 $150$。边 $(a,c)$ 不跨越最小割 $(S=\\{s,a,b,c\\}, T=\\{t\\})$。瓶颈仍然是容量为 $5$ 的边 $(c,t)$。最大流不变。结果：$F_1 = 5$。布尔值 $B_1$ 为 True。\n\n-   **测试 2**：将 $\\text{cap}(s,a)$ 增加 $10$ 至 $14$。边 $(s,a)$ 不跨越最小割。瓶颈仍然是 $(c,t)$。最大流不变。结果：$F_2 = 5$。布尔值 $B_2$ 为 True。\n\n-   **测试 3**：将 $\\text{cap}(a,c)$ 增加 $50$，$\\text{cap}(b,c)$ 增加 $200$。两条边都不跨越最小割。瓶颈仍然是 $(c,t)$。最大流不变。结果：$F_3 = 5$。布尔值 $B_3$ 为 True。\n\n-   **测试 4**：将 $\\text{cap}(c,t)$ 增加 $1$ 至 $6$。这条边*是*最小割。此割的容量现在是 $6$。下一个最小的割容量来自割 $C_1$，为 $7$。新的最小割容量是 $\\min(6, 7) = 6$。最大流增加到此值。结果：$M_4 = 6$。\n\n-   **测试 5**：将 $\\text{cap}(c,t)$ 增加 $100$ 至 $105$。原始最小割 $(S=\\{s,a,b,c\\}, T=\\{t\\})$ 的容量现在是 $105$。新的瓶颈是割 $(S=\\{s\\}, T=\\{a,b,c,t\\})$，其容量为 $\\text{cap}(s,a) + \\text{cap}(s,b) = 4 + 3 = 7$。最大流增加到 $7$。结果：$M_5 = 7$。\n\n-   **测试 6**：添加容量为 $100$ 的边 $(a,b)$。此边位于最小割 $(S=\\{s,a,b,c\\}, T=\\{t\\})$ 的集合 $S$ 内部。它为从 $a$到 $b$ 的流提供了一条新路径，但所有流仍必须通过瓶颈边 $(c,t)$。它没有创造绕过瓶颈的新路径。最大流不变。结果：$F_6 = 5$。布尔值 $B_6$ 为 True。\n\n**结果总结**\n-   $F_0 = 5$\n-   $B_1 = \\text{True}$\n-   $B_2 = \\text{True}$\n-   $B_3 = \\text{True}$\n-   $M_4 = 6$\n-   $M_5 = 7$\n-   $B_6 = \\text{True}$\n\n最终输出将是 `[5,True,True,True,6,7,True]`。以下 Python 程序实现了 Edmonds-Karp 算法，以编程方式计算并验证这些结果。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef edmonds_karp(capacity_matrix, source, sink):\n    \"\"\"\n    使用 Edmonds-Karp 算法计算流网络中从源点到汇点的最大流。\n    \"\"\"\n    num_vertices = len(capacity_matrix)\n    residual_graph = np.copy(capacity_matrix)\n    max_flow = 0\n    \n    while True:\n        # 使用 BFS 寻找增广路径\n        parent = [-1] * num_vertices\n        queue = deque([source])\n        visited = {source}\n        \n        path_found = False\n        while queue:\n            u = queue.popleft()\n            if u == sink:\n                path_found = True\n                break\n            \n            for v in range(num_vertices):\n                if v not in visited and residual_graph[u, v] > 0:\n                    queue.append(v)\n                    visited.add(v)\n                    parent[v] = u\n        \n        if not path_found:\n            break  # 没有更多增广路径\n            \n        # 找到路径的瓶颈容量\n        path_flow = float('inf')\n        v = sink\n        while v != source:\n            u = parent[v]\n            path_flow = min(path_flow, residual_graph[u, v])\n            v = u\n            \n        # 更新残差图\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual_graph[u, v] -= path_flow\n            residual_graph[v, u] += path_flow\n            v = u\n            \n        max_flow += path_flow\n        \n    return max_flow\n\ndef solve():\n    \"\"\"\n    为基准情况和所有测试用例解决流网络问题。\n    \"\"\"\n    # 顶点映射: s=0, a=1, b=2, c=3, t=4\n    vertex_map = {'s': 0, 'a': 1, 'b': 2, 'c': 3, 't': 4}\n    num_vertices = 5\n    source = vertex_map['s']\n    sink = vertex_map['t']\n\n    # 基础网络容量矩阵\n    base_capacity = np.zeros((num_vertices, num_vertices), dtype=np.int64)\n    base_capacity[vertex_map['s'], vertex_map['a']] = 4\n    base_capacity[vertex_map['s'], vertex_map['b']] = 3\n    base_capacity[vertex_map['a'], vertex_map['c']] = 100\n    base_capacity[vertex_map['b'], vertex_map['c']] = 100\n    base_capacity[vertex_map['c'], vertex_map['t']] = 5\n\n    # 测试用例定义: ((要修改的边), 容量增量)\n    test_cases = [\n        # 测试 1\n        [((vertex_map['a'], vertex_map['c']), 50)],\n        # 测试 2\n        [((vertex_map['s'], vertex_map['a']), 10)],\n        # 测试 3\n        [\n            ((vertex_map['a'], vertex_map['c']), 50),\n            ((vertex_map['b'], vertex_map['c']), 200)\n        ],\n        # 测试 4\n        [((vertex_map['c'], vertex_map['t']), 1)],\n        # 测试 5\n        [((vertex_map['c'], vertex_map['t']), 100)],\n        # 测试 6\n        [((vertex_map['a'], vertex_map['b']), 100)],\n    ]\n\n    # 计算基准最大流\n    baseline_flow = edmonds_karp(base_capacity, source, sink)\n    results = [int(baseline_flow)]\n\n    # 独立运行每个测试用例\n    for i, modifications in enumerate(test_cases):\n        modified_capacity = np.copy(base_capacity)\n        for (u, v), increase in modifications:\n            modified_capacity[u, v] += increase\n        \n        new_flow = edmonds_karp(modified_capacity, source, sink)\n        \n        # 根据问题规范格式化结果\n        test_number = i + 1\n        if test_number in [1, 2, 3, 6]:\n            results.append(int(new_flow) == int(baseline_flow))\n        elif test_number in [4, 5]:\n            results.append(int(new_flow))\n\n    # 按要求格式打印最终输出\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3148846"}]}