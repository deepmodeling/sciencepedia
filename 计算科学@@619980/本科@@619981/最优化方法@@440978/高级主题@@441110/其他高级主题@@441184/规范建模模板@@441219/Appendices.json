{"hands_on_practices": [{"introduction": "资源分配是优化领域最基本的问题之一，在商业、工程和公共管理等领域无处不在。本练习模拟了一个博物馆分配有限资源（空间和电力）以最大化游客参与度的真实场景。通过这个实践，您将把一个描述性的问题转化为一个经典的线性规划（LP）模型，从而巩固您将现实世界的限制条件精确地表述为数学不等式的核心建模能力。[@problem_id:3106569]", "problem": "一个博物馆希望为一系列互动展品分配占地面积和电力，以最大化游客的参与度。决策变量是分配给第 $i$ 个展品的占地面积 $x_i$（单位：平方米，记作 $\\mathrm{m}^2$）和电力 $p_i$（单位：千瓦，记作 $\\mathrm{kW}$），其中 $i \\in \\{1,\\dots,n\\}$。参与度被建模为线性函数 $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$，其中 $\\alpha_i$ 和 $\\beta_i$ 是非负系数，分别反映了每单位空间和电力的边际参与度。分配必须满足资源约束：总空间预算、总电力预算、每个展品的空间和电力上限，以及反映最大功率密度的每个展品的电力和空间之间的线性耦合关系。\n\n根据线性规划（LP）的基本原理——在线性约束下对凸多面体上的线性目标进行优化——将此分配问题表述为一个LP，并实现一个求解器，该求解器能为给定的参数计算出最大化参与度的分配向量。可行集必须反映标准的物理现实：非负分配、容量限制以及形式为 $p_i \\le r_i x_i$ 的线性耦合约束，其中 $r_i$ 是第 $i$ 个展品允许的最大功率密度，单位为 $\\mathrm{kW}/\\mathrm{m}^2$。\n\n您必须使用以下规范的LP建模模板：定义决策向量 $y = [x_1,\\dots,x_n,p_1,\\dots,p_n]^\\top$，构建一个包含所有约束的线性目标和线性不等式系统，并计算最优的 $y^\\star$。\n\n程序必须为下面的每个测试案例求解LP，并为每个案例输出一个列表，其中包含最优分配和最优参与度值，顺序为 $[x_1,\\dots,x_n,p_1,\\dots,p_n,z]$，其中 $z$ 是 $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$ 的最大值。所有 $x_i$ 必须解释为 $\\mathrm{m}^2$，所有 $p_i$ 必须解释为 $\\mathrm{kW}$；仅报告数值，不带单位符号，并四舍五入到小数点后四位。\n\n使用的基本定义：\n- 线性规划（LP）：在线性等式和不等式约束下，对由线性边界定义的集合上的线性目标函数进行最大化或最小化。可行域是一个凸多面体，最优解（如果存在）在某个极点处达到。\n- 非负性和容量约束反映了资源和设备的物理限制。\n\n除了这些基本原理外，您不得使用任何快捷公式。从第一性原理推导出线性模型：决策变量、目标和约束。然后使用通用求解器求解LP。\n\n测试套件：\n- 案例1（理想路径，预算适度紧张，多个展品，所有约束都可能被激活）：\n  - 展品数量：$n = 3$。\n  - 参与度系数：$\\alpha = (3.0,\\, 2.5,\\, 1.0)$ 和 $\\beta = (5.0,\\, 2.0,\\, 4.0)$。\n  - 预算：总空间 $S = 120.0$ $\\mathrm{m}^2$，总电力 $P = 30.0$ $\\mathrm{kW}$。\n  - 功率密度限制：$r = (0.20,\\, 0.10,\\, 0.25)$ $\\mathrm{kW}/\\mathrm{m}^2$。\n  - 各展品上限：$\\bar{x} = (60.0,\\, 50.0,\\, 80.0)$ $\\mathrm{m}^2$，$\\bar{p} = (15.0,\\, 20.0,\\, 12.0)$ $\\mathrm{kW}$。\n- 案例2（边界案例，总电力紧张且耦合约束显著）：\n  - 展品数量：$n = 3$。\n  - 参与度系数：$\\alpha = (2.0,\\, 1.5,\\, 3.0)$ 和 $\\beta = (1.0,\\, 0.5,\\, 2.0)$。\n  - 预算：总空间 $S = 80.0$ $\\mathrm{m}^2$，总电力 $P = 12.0$ $\\mathrm{kW}$。\n  - 功率密度限制：$r = (0.15,\\, 0.12,\\, 0.20)$ $\\mathrm{kW}/\\mathrm{m}^2$。\n  - 各展品上限：$\\bar{x} = (40.0,\\, 40.0,\\, 60.0)$ $\\mathrm{m}^2$，$\\bar{p} = (10.0,\\, 10.0,\\, 15.0)$ $\\mathrm{kW}$。\n- 案例3（边缘案例，一个展品的空间边际参与度为零，另一个展品的电力边际参与度为零，且耦合紧密）：\n  - 展品数量：$n = 2$。\n  - 参与度系数：$\\alpha = (0.0,\\, 0.9)$ 和 $\\beta = (2.0,\\, 0.0)$。\n  - 预算：总空间 $S = 10.0$ $\\mathrm{m}^2$，总电力 $P = 5.0$ $\\mathrm{kW}$。\n  - 功率密度限制：$r = (0.50,\\, 0.20)$ $\\mathrm{kW}/\\mathrm{m}^2$。\n  - 各展品上限：$\\bar{x} = (10.0,\\, 10.0)$ $\\mathrm{m}^2$，$\\bar{p} = (5.0,\\, 1.0)$ $\\mathrm{kW}$。\n\n建模要求：\n- 决策变量：对所有 $i$，有 $x_i \\ge 0$ 和 $p_i \\ge 0$。\n- 目标：最大化 $\\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$。\n- 约束：\n  - 总空间：$\\sum_{i=1}^{n} x_i \\le S$。\n  - 总电力：$\\sum_{i=1}^{n} p_i \\le P$。\n  - 耦合：对所有 $i$，有 $p_i \\le r_i x_i$。\n  - 边界：对所有 $i$，有 $0 \\le x_i \\le \\bar{x}_i$ 和 $0 \\le p_i \\le \\bar{p}_i$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试案例，并且本身是一个包含 $[x_1,\\dots,x_n,p_1,\\dots,p_n,z]$ 的列表，所有数字四舍五入到小数点后四位。例如，正确的格式为：$[[\\dots],[\\dots],[\\dots]]$，其中逗号后没有空格。输出中不包括单位符号；将 $x_i$ 值解释为 $\\mathrm{m}^2$，将 $p_i$ 值解释为 $\\mathrm{kW}$。", "solution": "用户希望我解决一个关于博物馆资源分配的线性规划问题。\n\n我的计划如下：\n1.  **验证问题陈述。**\n    -   **步骤1：提取给定信息。** 我将列出问题描述中提供的所有变量、常数和约束。\n    -   **步骤2：使用提取的给定信息进行验证。** 我将检查问题是否科学合理、适定、客观和完整。这似乎是一个标准的资源分配问题，是线性规划的一个典型应用。设置清晰，为测试案例提供了所有必要的参数。约束是线性的，目标函数也是线性的。这符合线性规划（LP）问题的定义。物理约束（非负性、容量限制）是现实的。问题是适定且客观的。它直接关系到指定的优化方法和规范建模模板（资源分配）的主题。\n    -   **步骤3：结论和行动。** 问题似乎是有效的。我将继续进行解答。\n\n2.  **构建解决方案。**\n    -   **基于原则的设计**：我需要从第一性原理出发解释LP问题的构建过程。\n    -   **决策变量**：问题将它们定义为每个展品 $i$ 的 $x_i$（空间）和 $p_i$（电力）。问题要求创建一个单一的决策向量 $y = [x_1, \\dots, x_n, p_1, \\dots, p_n]^\\top$。这个向量有 $2n$ 个元素。\n    -   **目标函数**：目标是最大化总参与度，其由线性函数给出：$z = \\sum_{i=1}^{n} \\alpha_i x_i + \\sum_{i=1}^{n} \\beta_i p_i$。用矩阵形式表示，这是 $c^\\top y$，其中 $c = [\\alpha_1, \\dots, \\alpha_n, \\beta_1, \\dots, \\beta_n]^\\top$。由于标准的LP求解器通常是最小化，我将通过最小化 $-c^\\top y$ 来最大化 $c^\\top y$。\n    -   **约束**：我需要列出所有约束，并将它们表示为 $A_{ub} y \\le b_{ub}$ 和 $A_{eq} y = b_{eq}$（如果有的话）的形式。该问题只有不等式约束。\n        -   **总空间**：$\\sum_{i=1}^{n} x_i \\le S$。\n        -   **总电力**：$\\sum_{i=1}^{n} p_i \\le P$。\n        -   **耦合**：对每个 $i=1, \\dots, n$，$p_i \\le r_i x_i$。这可以重写为 $-r_i x_i + p_i \\le 0$。\n        -   **上限**：对每个 $i=1, \\dots, n$，$x_i \\le \\bar{x}_i$ 和 $p_i \\le \\bar{p}_i$。\n        -   **非负性**：对每个 $i=1, \\dots, n$，$x_i \\ge 0$ 和 $p_i \\ge 0$。这些通常由LP求解器作为边界处理，所以我不需要将它们放入 $A_{ub}$ 矩阵中。`scipy.optimize.linprog` 函数将 `bounds` 作为单独的参数。每个变量 $y_j$ 的边界是 $(l_j, u_j)$。\n            - 对于 $j = 1, \\dots, n$，变量是 $x_j$，其边界是 $(0, \\bar{x}_j)$。\n            - 对于 $j = n+1, \\dots, 2n$，变量是 $p_{j-n}$，其边界是 $(0, \\bar{p}_{j-n})$。\n\n3.  **为LP求解器构建矩阵。**\n    -   让我们系统地进行。决策向量是 $y = [x_1, \\dots, x_n, p_1, \\dots, p_n]^\\top$。它的维度是 $2n \\times 1$。\n    -   目标向量是 $c = [\\alpha_1, \\dots, \\alpha_n, \\beta_1, \\dots, \\beta_n]^\\top$。我们想最大化 $c^\\top y$，这等价于最小化 $-c^\\top y$。\n    -   约束需要写成 $A_{ub} y \\le b_{ub}$ 的形式。\n        -   **总空间约束（1行）：**\n            $\\sum_{i=1}^{n} x_i + \\sum_{i=1}^{n} 0 \\cdot p_i \\le S$。\n            $A_{ub}$ 中对应的行将是 $[1, 1, \\dots, 1, 0, 0, \\dots, 0]$（n个1后跟n个0）。$b_{ub}$ 中对应的元素是 $S$。\n        -   **总电力约束（1行）：**\n            $\\sum_{i=1}^{n} 0 \\cdot x_i + \\sum_{i=1}^{n} p_i \\le P$。\n            $A_{ub}$ 中对应的行将是 $[0, 0, \\dots, 0, 1, 1, \\dots, 1]$（n个0后跟n个1）。$b_{ub}$ 中对应的元素是 $P$。\n        -   **耦合约束（$n$ 行）：**\n            对于每个 $i \\in \\{1, \\dots, n\\}$，我们有 $-r_i x_i + p_i \\le 0$。\n            $A_{ub}$ 中第 $i$ 个耦合约束行将在第 $i$ 个位置（对应 $x_i$）有 $-r_i$，在第 $(n+i)$ 个位置（对应 $p_i$）有 $+1$，其他位置为零。$b_{ub}$ 中对应的元素是 $0$。\n        -   **不等式约束总数**：$1$（空间）+ $1$（电力）+ $n$（耦合）= $n+2$。\n        -   因此，$A_{ub}$ 将是一个大小为 $(n+2) \\times 2n$ 的矩阵。\n        -   而 $b_{ub}$ 将是一个大小为 $(n+2) \\times 1$ 的向量。\n    -   边界是分开处理的。对于每个变量 $y_k$，边界是 $[0, u_k]$。\n        -   对于 $k \\in \\{1, \\dots, n\\}$，变量是 $x_k$，上界是 $\\bar{x}_k$。所以边界是 $(0, \\bar{x}_k)$。\n        -   对于 $k \\in \\{n+1, \\dots, 2n\\}$，变量是 $p_{k-n}$，上界是 $\\bar{p}_{k-n}$。所以边界是 $(0, \\bar{p}_{k-n})$。\n        `scipy.optimize.linprog` 函数接受一个元组列表作为边界。\n\n4.  **实现Python代码。**\n    -   使用 `scipy.optimize.linprog`。\n    -   函数签名为 `linprog(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='highs')`。\n    -   我将使用 'highs' 求解器，这是默认的并且通常很稳健。\n    -   `c`：要**最小化**的目标函数的系数。所以我必须传递 `-c = [-\\alpha_1, ..., -\\beta_n]`。\n    -   `A_ub`：不等式约束矩阵。\n    -   `b_ub`：不等式约束向量。\n    -   `bounds`：每个决策变量的 `(min, max)` 对序列。\n    -   `linprog` 函数返回一个结果对象。最优值在 `result.x` 中，最优目标函数值在 `result.fun` 中。由于我最小化了 $-c^\\top y$，`result.fun` 将是最小值，因此原始目标的最大值是 `-result.fun`。\n    -   我将创建一个函数 `solve_case(params)`，它接收一个测试案例的参数，构建矩阵，调用 `linprog`，并格式化输出。\n    -   脚本的主要部分将定义测试案例并遍历它们，为每个案例调用 `solve_case`。\n    -   最终输出需要是一个列表的列表，每个内部列表为 `[x_1, ..., x_n, p_1, ..., p_n, z]`，数字四舍五入到小数点后四位。格式为 `[[...],[...],[...]]`。\n\n5.  **详细检查一个案例以确保无误：**\n    -   **案例1：**\n        -   $n = 3$\n        -   决策向量 $y = [x_1, x_2, x_3, p_1, p_2, p_3]^\\top$ (6个变量)。\n        -   $\\alpha = [3.0, 2.5, 1.0]$\n        -   $\\beta = [5.0, 2.0, 4.0]$\n        -   $c_{\\max} = [3.0, 2.5, 1.0, 5.0, 2.0, 4.0]$\n        -   $c_{\\min} = [-3.0, -2.5, -1.0, -5.0, -2.0, -4.0]$\n        -   $S = 120.0$, $P = 30.0$\n        -   $r = [0.20, 0.10, 0.25]$\n        -   $\\bar{x} = [60.0, 50.0, 80.0]$\n        -   $\\bar{p} = [15.0, 20.0, 12.0]$\n\n        -   **边界**：\n            - $x_1$: $(0, 60.0)$\n            - $x_2$: $(0, 50.0)$\n            - $x_3$: $(0, 80.0)$\n            - $p_1$: $(0, 15.0)$\n            - $p_2$: $(0, 20.0)$\n            - $p_3$: $(0, 12.0)$\n            `bounds = [(0, 60), (0, 50), (0, 80), (0, 15), (0, 20), (0, 12)]`\n\n        -   **不等式约束 $A_{ub} y \\le b_{ub}$**：\n            - 约束数量 = $n+2 = 5$。\n            - $A_{ub}$ 是 $5 \\times 6$ 矩阵。$b_{ub}$ 是 $5 \\times 1$ 向量。\n\n            1.  **空间：** $x_1 + x_2 + x_3 \\le 120.0$\n                $A_{ub}$ 的第1行：$[1, 1, 1, 0, 0, 0]$\n                $b_{ub}[0] = 120.0$\n            2.  **电力：** $p_1 + p_2 + p_3 \\le 30.0$\n                $A_{ub}$ 的第2行：$[0, 0, 0, 1, 1, 1]$\n                $b_{ub}[1] = 30.0$\n            3.  **耦合1：** $p_1 \\le 0.20 x_1 \\Rightarrow -0.20x_1 + p_1 \\le 0$\n                $A_{ub}$ 的第3行：$[-0.20, 0, 0, 1, 0, 0]$\n                $b_{ub}[2] = 0.0$\n            4.  **耦合2：** $p_2 \\le 0.10 x_2 \\Rightarrow -0.10x_2 + p_2 \\le 0$\n                $A_{ub}$ 的第4行：$[0, -0.10, 0, 0, 1, 0]$\n                $b_{ub}[3] = 0.0$\n            5.  **耦合3：** $p_3 \\le 0.25 x_3 \\Rightarrow -0.25x_3 + p_3 \\le 0$\n                $A_{ub}$ 的第5行：$[0, 0, -0.25, 0, 0, 1]$\n                $b_{ub}[4] = 0.0$\n\n        -   **矩阵 $A_{ub}$：**\n            ```\n            [[ 1.0,  1.0,  1.0,  0.0,  0.0,  0.0],\n             [ 0.0,  0.0,  0.0,  1.0,  1.0,  1.0],\n             [-0.2,  0.0,  0.0,  1.0,  0.0,  0.0],\n             [ 0.0, -0.1,  0.0,  0.0,  1.0,  0.0],\n             [ 0.0,  0.0, -0.25, 0.0,  0.0,  1.0]]\n            ```\n        -   **向量 $b_{ub}$：**\n            `[120.0, 30.0, 0.0, 0.0, 0.0]`\n\n        -   这似乎是正确的，可以进行实现了。我将根据 $n$ 动态构建这些矩阵。\n\n6.  **代码结构：**\n    -   `solve()` 函数：\n        -   `test_cases` 列表，包含每个案例参数的字典或元组。元组 $(n, \\alpha, \\beta, S, P, r, \\bar{x}, \\bar{p})$ 似乎不错。\n        -   `results = []`。\n        -   循环 `for case in test_cases`:\n            -   解包 $n, \\alpha, \\beta, S, P, r, \\bar{x}, \\bar{p}$。\n            -   构建 $c$, $A_{ub}$, $b_{ub}$, `bounds`。\n            -   `n_vars = 2 * n`\n            -   `c = -np.concatenate([alpha, beta])`\n            -   `A_ub = np.zeros((n + 2, n_vars))`\n            -   `b_ub = np.zeros(n + 2)`\n            -   `A_ub[0, :n] = 1` (空间约束)\n            -   `b_ub[0] = S`\n            -   `A_ub[1, n:] = 1` (电力约束)\n            -   `b_ub[1] = P`\n            -   循环 `for i in range(n)`:\n                -   `A_ub[2 + i, i] = -r[i]` (耦合 $x_i$)\n                -   `A_ub[2 + i, n + i] = 1` (耦合 $p_i$)\n                -   `b_ub[2 + i] = 0`\n            -   `bounds` 列表: `[(0, x_bar[i]) for i in range(n)] + [(0, p_bar[i]) for i in range(n)]`\n            -   `res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')`\n            -   检查 `res.success`。问题是良构的，所以应该会成功。\n            -   `optimal_y = res.x`\n            -   `optimal_z = -res.fun`\n            -   将 `optimal_y` 和 `optimal_z` 合并到一个列表中。\n            -   将所有值四舍五入到小数点后四位。\n            -   将格式化后的列表追加到 `results`。\n    -   最终的打印语句: `print(f\"[{','.join(map(str, results))}]\")`。这个格式有点棘手。我需要将每个内部列表转换为没有空格的字符串。\n        -   `str(a_list)` 会产生 `[1, 2, 3]`。\n        -   我需要 `[1,2,3]`。\n        -   所以，对于每个结果列表，我需要 `f\"[{','.join(map(str, rounded_result_list))}]\"`。\n        -   然后我用逗号连接这些字符串：`f\"[{','.join(stringified_results)}]\"`\n\n这个结构似乎是完整的、合理的，并遵循了“基于原则的设计”的要求。它从第一性原理推导出模型，然后描述如何求解它。我将确保每个数学符号都在LaTeX中。这是一项繁重的工作，但是一个严格的要求。例如，即使是`1`也应该是`$1$`。\n\n我将仔细检查测试案例。\n案例1：$n=3$。`x`变量：$x_1, x_2, x_3$。`p`变量：$p_1, p_2, p_3$。共6个变量。$A_{ub}$ 中有 $1+1+3=5$ 个约束。\n案例2：$n=3$。结构相同。\n案例3：$n=2$。`x`变量：$x_1, x_2$。`p`变量：$p_1, p_2$。共4个变量。$A_{ub}$ 中有 $1+1+2=4$ 个约束。\n\n问题明确指出 $\\alpha_i$ 和 $\\beta_i$ 是非负的。这很重要，因为它确保了目标函数在可行集（这是一个紧集）上有上界。极值定理保证了最优解的存在，因为可行集（由线性不等式定义的多面体）是闭合且有界的（紧集），并且目标函数是连续的。LP理论进一步保证，如果可行集非空，则最优解在多面体的一个顶点处达到。问题设置确保了可行集非空（例如，所有 $i$ 的 $x_i=0, p_i=0$ 是一个可行解）。问题是良构的。\n\n最后检查输出格式。\n`[x_1,\\dots,x_n,p_1,\\dots,p_n,z]`\n$x_i$ 单位为 $\\mathrm{m}^2$，`p_i` 单位为 $\\mathrm{kW}$。\n所有数字四舍五入到小数点后四位。\n总体输出是 `[[case1_results], [case2_results], [case3_results]]`。\n例如：`[[1.0000,2.0000,..,100.0000],[...],[...]]`\n我之前计划的手动字符串构建对此是正确的。\n`f\"{num:.4f}\"` 将正确格式化数字。\n\n看起来计划很周密。我准备开始写作了。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    解决一系列用于博物馆资源分配的线性规划问题。\n    \"\"\"\n    test_cases = [\n        # 案例1\n        {\n            \"n\": 3,\n            \"alpha\": np.array([3.0, 2.5, 1.0]),\n            \"beta\": np.array([5.0, 2.0, 4.0]),\n            \"S\": 120.0,\n            \"P\": 30.0,\n            \"r\": np.array([0.20, 0.10, 0.25]),\n            \"x_bar\": np.array([60.0, 50.0, 80.0]),\n            \"p_bar\": np.array([15.0, 20.0, 12.0]),\n        },\n        # 案例2\n        {\n            \"n\": 3,\n            \"alpha\": np.array([2.0, 1.5, 3.0]),\n            \"beta\": np.array([1.0, 0.5, 2.0]),\n            \"S\": 80.0,\n            \"P\": 12.0,\n            \"r\": np.array([0.15, 0.12, 0.20]),\n            \"x_bar\": np.array([40.0, 40.0, 60.0]),\n            \"p_bar\": np.array([10.0, 10.0, 15.0]),\n        },\n        # 案例3\n        {\n            \"n\": 2,\n            \"alpha\": np.array([0.0, 0.9]),\n            \"beta\": np.array([2.0, 0.0]),\n            \"S\": 10.0,\n            \"P\": 5.0,\n            \"r\": np.array([0.50, 0.20]),\n            \"x_bar\": np.array([10.0, 10.0]),\n            \"p_bar\": np.array([5.0, 1.0]),\n        },\n    ]\n\n    results_for_all_cases = []\n    \n    for case in test_cases:\n        n = case[\"n\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        S = case[\"S\"]\n        P = case[\"P\"]\n        r = case[\"r\"]\n        x_bar = case[\"x_bar\"]\n        p_bar = case[\"p_bar\"]\n\n        # 决策向量 y = [x_1, ..., x_n, p_1, ..., p_n]\n        # 变量数量为 2*n\n        n_vars = 2 * n\n\n        # 需要最大化的目标函数 c_vector^T * y。\n        # linprog 函数求解最小值，因此我们求解 -c_vector^T * y 的最小值。\n        # c_vector = [alpha_1, ..., alpha_n, beta_1, ..., beta_n]\n        c = -np.concatenate([alpha, beta])\n\n        # 不等式约束 A_ub * y = b_ub\n        # 共有 n+2 个此类约束：1个用于空间，1个用于电力，n个用于耦合。\n        A_ub = np.zeros((n + 2, n_vars))\n        b_ub = np.zeros(n + 2)\n\n        # 1. 总空间约束: sum(x_i) = S\n        A_ub[0, :n] = 1\n        b_ub[0] = S\n        \n        # 2. 总电力约束: sum(p_i) = P\n        A_ub[1, n:] = 1\n        b_ub[1] = P\n        \n        # 3. 耦合约束: p_i = r_i * x_i  =>  -r_i * x_i + p_i = 0\n        for i in range(n):\n            A_ub[2 + i, i] = -r[i]\n            A_ub[2 + i, n + i] = 1\n            b_ub[2 + i] = 0\n\n        # 每个变量的边界: 0 = y_i = u_i\n        # bounds = [(0, x_bar_1), ..., (0, x_bar_n), (0, p_bar_1), ..., (0, p_bar_n)]\n        bounds_x = [(0, val) for val in x_bar]\n        bounds_p = [(0, val) for val in p_bar]\n        bounds = bounds_x + bounds_p\n\n        # 求解线性规划问题\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.success:\n            optimal_y = res.x\n            # 最大化的目标值是最小化值的 -1 倍\n            optimal_z = -res.fun\n            # 将分配方案和目标值合并到一个列表中\n            current_result = list(optimal_y) + [optimal_z]\n            results_for_all_cases.append(current_result)\n        else:\n            # 处理求解器失败的情况\n            # 对于这个良构问题，不应执行此路径。\n            # 用 NaN 填充或进行适当的错误处理。\n            # 使用大小正确的 NaN 以避免破坏输出格式。\n            results_for_all_cases.append([np.nan] * (n_vars + 1))\n\n    # 根据要求格式化最终输出字符串：\n    # [[case1_results],[case2_results],...]，不含空格且保留4位小数。\n    output_parts = []\n    for res_list in results_for_all_cases:\n        formatted_numbers = [f\"{num:.4f}\" for num in res_list]\n        part_str = \"[\" + \",\".join(formatted_numbers) + \"]\"\n        output_parts.append(part_str)\n        \n    final_output_string = \"[\" + \",\".join(output_parts) + \"]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3106569"}, {"introduction": "网络流问题是运筹学的基石，用于模拟商品、数据或资源在网络中的流动。本练习引入了一个常见的现实世界复杂性：非线性成本，其中运输成本随流量分段变化。您将学习一种强大的建模技巧——通过引入额外的变量将凸分段线性成本函数线性化——从而将问题转化为一个标准的、可高效求解的线性规划问题，这展示了LP框架的灵活性和扩展性。[@problem_id:3106543]", "problem": "要求您使用线性规划（LP）建立并求解一个带有分段线性弧成本的单商品最小成本网络流模型。其基本原理是网络流守恒定律：对于每个节点，总流出量减去总流入量等于该节点的净供给（源点为正）或需求（汇点为负），以及线性优化的定义，即在线性等式约束和变量边界的条件下，最小化一个线性目标函数。\n\n每个有向弧 $(i,j)$ 都有一个容量 $u_{ij}$ 和一个形式为 $c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij})$ 的凸分段线性成本，其中 $f_{ij}$ 是弧 $(i,j)$ 上的流量，$a_{ij} \\ge 0$，$b_{ij} \\ge 0$，且 $\\theta_{ij} \\ge 0$。为了得到一个线性规划，使用两个非负分段变量来表示 $f_{ij}$，这两个变量相对于阈值 $\\theta_{ij}$ 分割流量，并施加适当的边界和守恒约束。在满足每个节点的流量守恒和弧容量限制的条件下，最小化总成本。\n\n您的程序必须：\n- 针对每个测试用例，根据上述描述构建 LP：为每条弧引入分段变量以线性化成本，施加从 $u_{ij}$ 和 $\\theta_{ij}$ 导出的分段边界，并施加从节点供给和需求导出的逐节点流量守恒等式。\n- 求解该 LP，并为每个测试用例返回最优目标值（总成本），形式为十进制数。\n\n不涉及物理单位。不出现角度。不出现百分比。\n\n测试套件：\n提供一个单一程序，解决以下三个测试用例。每个测试用例描述一个有向网络。节点由标签表示，弧由元组 $(i,j,a_{ij},b_{ij},\\theta_{ij},u_{ij})$ 给出，所有数学实体（包括数字）均以 LaTeX 格式书写。\n\n- 测试用例 $1$（正常路径，混合阈值和容量）：\n  - 节点：$\\{S,A,B,T\\}$。\n  - 供给/需求：$s_S = 6$，$s_A = 0$，$s_B = 0$，$s_T = -6$。\n  - 弧：\n    - (S,A, $a_{SA}=2, b_{SA}=3, \\theta_{SA}=3, u_{SA}=5$),\n    - (S,B, $a_{SB}=1, b_{SB}=0.5, \\theta_{SB}=1, u_{SB}=4$),\n    - (A,T, $a_{AT}=1.5, b_{AT}=2, \\theta_{AT}=2, u_{AT}=4$),\n    - (B,T, $a_{BT}=2, b_{BT}=1, \\theta_{BT}=4, u_{BT}=5$),\n    - (S,T, $a_{ST}=3, b_{ST}=1, \\theta_{ST}=1, u_{ST}=2$)。\n\n- 测试用例 $2$（边界情况：容量等于阈值或容量低于阈值）：\n  - 节点：$\\{S,A,T\\}$。\n  - 供给/需求：$s_S = 5$，$s_A = 0$，$s_T = -5$。\n  - 弧：\n    - (S,A, $a_{SA}=1, b_{SA}=5, \\theta_{SA}=3, u_{SA}=3$),\n    - (A,T, $a_{AT}=2, b_{AT}=4, \\theta_{AT}=5, u_{AT}=3$),\n    - (S,T, $a_{ST}=4, b_{ST}=0, \\theta_{ST}=2, u_{ST}=2$)。\n\n- 测试用例 $3$（边缘情况：零阈值）：\n  - 节点：$\\{S,C,T\\}$。\n  - 供给/需求：$s_S = 4$，$s_C = 0$，$s_T = -4$。\n  - 弧：\n    - (S,C, $a_{SC}=1, b_{SC}=2, \\theta_{SC}=0, u_{SC}=5$),\n    - (C,T, $a_{CT}=1, b_{CT}=1, \\theta_{CT}=0, u_{CT}=5$),\n    - (S,T, $a_{ST}=0, b_{ST}=0, \\theta_{ST}=0, u_{ST}=1$)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的最优目标值，形式为用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3]$）。每个 $result_k$ 必须是一个十进制数（浮点数）。程序必须是独立完整的，无需输入，并直接按规定求解所提供的三个测试用例。", "solution": "该问题要求构建并求解一个单商品最小成本网络流问题，其中每条弧的成本是流量的凸分段线性函数。该问题需建模为线性规划（LP）。\n\n其基本原理是通过引入新变量来表示成本函数不同分段上的流量，从而将一个凸分段线性目标函数转换为线性目标函数。因为原始目标函数是凸的，且约束是线性的，最小化器会自然地优先使用较便宜分段上的流量，然后再使用较昂贵分段上的流量，从而验证了这种分解的有效性，无需额外的整数变量或特殊分支规则。\n\n设网络由一个有向图 $G = (V, E)$ 表示，其中 $V$ 是节点集，$E$ 是弧集。对于每个节点 $i \\in V$，有一个净供给 $s_i$。如果 $s_i > 0$，节点 $i$ 是一个源点。如果 $s_i  0$，它是一个汇点。如果 $s_i = 0$，它是一个中转节点。对于一个有效的问题，总供给必须等于总需求，即 $\\sum_{i \\in V} s_i = 0$。\n\n对于每条弧 $(i,j) \\in E$，我们给定：\n- $u_{ij}$：弧的最大容量。\n- 一个关于弧上流量 $f_{ij}$ 的凸分段线性成本函数 $c_{ij}(f_{ij})$，定义为：\n$$ c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij}) $$\n其中 $a_{ij} \\ge 0$，$b_{ij} \\ge 0$，且 $\\theta_{ij} \\ge 0$ 是成本函数斜率改变处的流量阈值。\n\n优化问题为：\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} c_{ij}(f_{ij}) $$\n约束条件为：\n$1$. 每个节点 $k \\in V$ 的流量守恒：\n$$ \\sum_{j:(k,j) \\in E} f_{kj} - \\sum_{i:(i,k) \\in E} f_{ik} = s_k $$\n$2$. 每条弧 $(i,j) \\in E$ 的弧容量约束：\n$$ 0 \\le f_{ij} \\le u_{ij} $$\n\n为线性化目标函数，我们将每条弧的流量变量 $f_{ij}$ 分解为两个非负变量 $f_{ij}^{(1)}$ 和 $f_{ij}^{(2)}$：\n$$ f_{ij} = f_{ij}^{(1)} + f_{ij}^{(2)} $$\n这些变量表示成本函数两个线性分段上的流量：\n- $f_{ij}^{(1)}$ 是第一分段的流量，最高达到阈值 $\\theta_{ij}$。\n- $f_{ij}^{(2)}$ 是第二分段的流量，超过阈值 $\\theta_{ij}$。\n\n这种分解受以下边界约束：\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\n这样，成本函数中的项 $\\max(0, f_{ij} - \\theta_{ij})$ 等价于 $f_{ij}^{(2)}$。弧 $(i,j)$ 的成本函数现在可以重写为这些新变量的线性函数：\n$$ c_{ij}(f_{ij}^{(1)}, f_{ij}^{(2)}) = a_{ij} (f_{ij}^{(1)} + f_{ij}^{(2)}) + b_{ij} f_{ij}^{(2)} = a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} $$\n第一分段上流量的边际成本是 $a_{ij}$，第二分段上是 $a_{ij} + b_{ij}$。由于 $b_{ij} \\ge 0$，第二分段的成本总是大于或等于第一分段。因此，一个最小化总成本的 LP 求解器会自动在为第二段（更昂贵的）分配任何流量之前，先使第一段饱和（达到其边界 $\\theta_{ij}$）。\n\n完整的 LP 构建如下：\n\n**决策变量：**\n对于每条弧 $(i,j) \\in E$，我们有两个变量 $f_{ij}^{(1)}$ 和 $f_{ij}^{(2)}$。\n\n**目标函数：**\n最小化总线性成本：\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} \\left( a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} \\right) $$\n\n**约束条件：**\n$1$. 每个节点 $k \\in V$ 的流量守恒：\n$$ \\sum_{j:(k,j) \\in E} \\left( f_{kj}^{(1)} + f_{kj}^{(2)} \\right) - \\sum_{i:(i,k) \\in E} \\left( f_{ik}^{(1)} + f_{ik}^{(2)} \\right) = s_k $$\n这构成了一组线性等式约束 ($A_{eq}x = b_{eq}$)。\n\n$2$. 每条弧 $(i,j) \\in E$ 的弧容量：\n$$ f_{ij}^{(1)} + f_{ij}^{(2)} \\le u_{ij} $$\n这构成了一组线性不等式约束 ($A_{ub}x \\le b_{ub}$)。\n\n$3$. 每条弧 $(i,j) \\in E$ 的变量边界：\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\n$f_{ij}^{(2)}$ 的上界由弧容量约束隐式处理。标准的 LP 形式将这些组合成一个单一的边界向量。\n\n这个构建方法被应用于每个测试用例。节点和弧的数据被用来构建目标向量 $c$、约束矩阵 $A_{eq}$ 和 $A_{ub}$、相应的右端向量 $b_{eq}$ 和 $b_{ub}$，以及变量边界。然后使用一个标准的 LP 求解器，例如 `scipy.optimize.linprog`，来找到最小化目标函数 $Z$ 的解向量 $x = [..., f_{ij}^{(1)}, f_{ij}^{(2)}, ...]^T$。$Z$ 的最优值是网络流的最小总成本，也就是所要求的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves three minimum-cost network flow problems with piecewise-linear costs.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"nodes\": [\"S\", \"A\", \"B\", \"T\"],\n            \"supplies\": {\"S\": 6.0, \"A\": 0.0, \"B\": 0.0, \"T\": -6.0},\n            \"arcs\": [\n                # (from, to, a, b, theta, u)\n                (\"S\", \"A\", 2.0, 3.0, 3.0, 5.0),\n                (\"S\", \"B\", 1.0, 0.5, 1.0, 4.0),\n                (\"A\", \"T\", 1.5, 2.0, 2.0, 4.0),\n                (\"B\", \"T\", 2.0, 1.0, 4.0, 5.0),\n                (\"S\", \"T\", 3.0, 1.0, 1.0, 2.0)\n            ]\n        },\n        # Test Case 2\n        {\n            \"nodes\": [\"S\", \"A\", \"T\"],\n            \"supplies\": {\"S\": 5.0, \"A\": 0.0, \"T\": -5.0},\n            \"arcs\": [\n                (\"S\", \"A\", 1.0, 5.0, 3.0, 3.0),\n                (\"A\", \"T\", 2.0, 4.0, 5.0, 3.0),\n                (\"S\", \"T\", 4.0, 0.0, 2.0, 2.0)\n            ]\n        },\n        # Test Case 3\n        {\n            \"nodes\": [\"S\", \"C\", \"T\"],\n            \"supplies\": {\"S\": 4.0, \"C\": 0.0, \"T\": -4.0},\n            \"arcs\": [\n                (\"S\", \"C\", 1.0, 2.0, 0.0, 5.0),\n                (\"C\", \"T\", 1.0, 1.0, 0.0, 5.0),\n                (\"S\", \"T\", 0.0, 0.0, 0.0, 1.0)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        supplies = case[\"supplies\"]\n        arcs_data = case[\"arcs\"]\n\n        num_nodes = len(nodes)\n        num_arcs = len(arcs_data)\n        num_vars = 2 * num_arcs\n\n        node_map = {name: i for i, name in enumerate(nodes)}\n\n        # LP formulation: min c'x s.t. A_eq x = b_eq, A_ub x = b_ub, and bounds on x.\n        \n        # 1. Objective function vector c\n        c = np.zeros(num_vars)\n        for i, arc in enumerate(arcs_data):\n            _, _, a, b, _, _ = arc\n            c[2 * i] = a         # Cost for the first segment f_ij^(1)\n            c[2 * i + 1] = a + b # Cost for the second segment f_ij^(2)\n            \n        # 2. Equality constraints A_eq, b_eq (flow conservation)\n        A_eq = np.zeros((num_nodes, num_vars))\n        b_eq = np.array([supplies[name] for name in nodes])\n        \n        for i, arc in enumerate(arcs_data):\n            u_name, v_name, _, _, _, _ = arc\n            u_idx, v_idx = node_map[u_name], node_map[v_name]\n            \n            # For arc i, variables are at 2*i and 2*i+1.\n            # Total flow on arc i is f_i^(1) + f_i^(2).\n            # It is an outflow from node u, so coefficient is +1.\n            A_eq[u_idx, 2 * i] = 1.0\n            A_eq[u_idx, 2 * i + 1] = 1.0\n            \n            # It is an inflow to node v, so coefficient is -1.\n            A_eq[v_idx, 2 * i] = -1.0\n            A_eq[v_idx, 2 * i + 1] = -1.0\n\n        # 3. Inequality constraints A_ub, b_ub (arc capacity)\n        A_ub = np.zeros((num_arcs, num_vars))\n        b_ub = np.zeros(num_arcs)\n        for i, arc in enumerate(arcs_data):\n            _, _, _, _, _, u_cap = arc\n            # f_i^(1) + f_i^(2) = u_i\n            A_ub[i, 2 * i] = 1.0\n            A_ub[i, 2 * i + 1] = 1.0\n            b_ub[i] = u_cap\n\n        # 4. Variable bounds\n        bounds = []\n        for arc in arcs_data:\n            _, _, _, _, theta, _ = arc\n            # 0 = f_i^(1) = theta_i\n            bounds.append((0, theta))\n            # 0 = f_i^(2)\n            bounds.append((0, None))\n\n        # Solve the Linear Program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            results.append(res.fun)\n        else:\n            # This path is not expected for the given valid test cases.\n            results.append(float('nan')) \n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3106543"}, {"introduction": "多式联运是网络优化的一个重要实际应用，通常涉及离散决策，例如选择运输方式。本练习构建了一个包含换乘固定成本的模型，这类问题通常需要使用混合整数线性规划（MILP）来求解。然而，本练习的核心启示在于，解决问题前应先深入分析其结构；当离散选择数量很少时，直接枚举所有可能性是一种比调用通用求解器更有效、更具洞察力的策略，这凸显了针对性分析的价值。[@problem_id:3106536]", "problem": "考虑一个单商品多式联运网络，该网络有三个节点：一个源节点 $S$、一个中间换乘节点 $X$ 和一个汇节点 $T$。商品必须通过 $X$ 从 $S$ 运输到 $T$。在每个路段 $(S,X)$ 和 $(X,T)$ 上有两种可用的运输模式：公路和铁路。设模式集合为 $\\{\\text{road}, \\text{rail}\\}$。运输量（需求）由 $D$ 表示（单位：货物）。\n\n使用的基本原理和定义：\n- 流量守恒：网络流的一个基本属性指出，离开一个节点的总流量等于进入该节点的总流量，并根据源点和汇点进行调整。在此设定中，这意味着每个路段必须精确运输 $D$ 单位货物，因此对于模式 $m$，有 $\\sum_{m} f_{SX}^{m} = D$ 和 $\\sum_{m} f_{XT}^{m} = D$。\n- 容量约束：网络中在给定模式 $m$ 下的每个弧 $(i,j)$ 都有一个最大允许流量（容量） $U_{ij}^{m} \\ge 0$。可行流满足 $f_{ij}^{m} \\le U_{ij}^{m}$。\n- 线性成本和排放：在固定弧段上采用固定模式时，运输成本和排放量与运输量成线性关系，即成本为 $c_{ij}^{m}$（单位：美元/单位），排放量为 $e_{ij}^{m}$（单位：千克二氧化碳当量）。\n- 二元模式选择和转换惩罚：为了编码一个路段是使用公路还是铁路，定义二元变量 $y_{SX}^{\\text{road}}, y_{SX}^{\\text{rail}}, y_{XT}^{\\text{road}}, y_{XT}^{\\text{rail}} \\in \\{0,1\\}$，使得 $\\sum_{m} y_{SX}^{m} = 1$ 且 $\\sum_{m} y_{XT}^{m} = 1$。使用一个二元转换变量 $z \\in \\{0,1\\}$，并附带一个固定惩罚 $P_{\\text{switch}}$（单位：美元），如果节点 $X$ 处的两个路段模式不同，则会产生此惩罚。模式转换由不等式 $z \\ge y_{SX}^{\\text{road}} + y_{XT}^{\\text{rail}} - 1$ 和 $z \\ge y_{SX}^{\\text{rail}} + y_{XT}^{\\text{road}} - 1$ 联系起来。\n\n建模要求：\n- 决策变量是每种模式 $m$ 的流量 $f_{SX}^{m} \\ge 0$ 和 $f_{XT}^{m} \\ge 0$，指示每个路段所选模式的二元变量 $y_{SX}^{m}, y_{XT}^{m}$，以及指示在 $X$ 处是否发生模式转换的二元变量 $z$。\n- 需求满足和流量守恒：$\\sum_{m} f_{SX}^{m} = D$ 和 $\\sum_{m} f_{XT}^{m} = D$。\n- 容量和 big-M 一致性：对于 $(i,j) \\in \\{(S,X),(X,T)\\}$ 和 $m \\in \\{\\text{road},\\text{rail}\\}$，有 $f_{ij}^{m} \\le U_{ij}^{m} \\cdot y_{ij}^{m}$。这强制要求一个路段上的所有流量都使用能够承载 $D$ 的单一选定模式。\n- 排放约束：$\\sum_{m} \\left(e_{SX}^{m} f_{SX}^{m} + e_{XT}^{m} f_{XT}^{m}\\right) \\le E_{\\max}$，其中 $E_{\\max}$ 是排放上限（单位：千克二氧化碳当量）。\n- 目标：最小化总物流成本 $C = \\sum_{m} \\left(c_{SX}^{m} f_{SX}^{m} + c_{XT}^{m} f_{XT}^{m}\\right) + P_{\\text{switch}} \\cdot z$。\n\n您的任务是编写一个完整的程序，在给定几组参数的情况下，计算满足上述约束条件的最小目标值 $C$。如果某组参数没有可行解，则返回浮点数 $+\\infty$ 表示不可行。所有成本必须以美元表示为浮点数。\n\n测试套件和参数：\n对于每个测试用例，参数包括 $D$、容量 $U_{SX}^{\\text{road}}, U_{SX}^{\\text{rail}}, U_{XT}^{\\text{road}}, U_{XT}^{\\text{rail}}$、成本 $c_{SX}^{\\text{road}}, c_{SX}^{\\text{rail}}, c_{XT}^{\\text{road}}, c_{XT}^{\\text{rail}}$、单位排放量 $e_{SX}^{\\text{road}}, e_{SX}^{\\text{rail}}, e_{XT}^{\\text{road}}, e_{XT}^{\\text{rail}}$、排放上限 $E_{\\max}$ 和转换惩罚 $P_{\\text{switch}}$。请使用以下四个测试用例，这些用例旨在覆盖典型、约束有效和边缘场景：\n\n- 测试用例 1（理想路径，成本驱动）：\n  - $D = 10$\n  - 容量：$U_{SX}^{\\text{road}} = 20$, $U_{SX}^{\\text{rail}} = 20$, $U_{XT}^{\\text{road}} = 20$, $U_{XT}^{\\text{rail}} = 20$\n  - 成本：$c_{SX}^{\\text{road}} = 4$, $c_{SX}^{\\text{rail}} = 6$, $c_{XT}^{\\text{road}} = 4$, $c_{XT}^{\\text{rail}} = 6$\n  - 单位排放量：$e_{SX}^{\\text{road}} = 2$, $e_{SX}^{\\text{rail}} = 1$, $e_{XT}^{\\text{road}} = 2$, $e_{XT}^{\\text{rail}} = 1$\n  - 排放上限：$E_{\\max} = 100$\n  - 转换惩罚：$P_{\\text{switch}} = 2$\n\n- 测试用例 2（排放约束起决定作用，强制选择低排放方案）：\n  - $D = 10$\n  - 容量：$U_{SX}^{\\text{road}} = 100$, $U_{SX}^{\\text{rail}} = 100$, $U_{XT}^{\\text{road}} = 100$, $U_{XT}^{\\text{rail}} = 100$\n  - 成本：$c_{SX}^{\\text{road}} = 5$, $c_{SX}^{\\text{rail}} = 3$, $c_{XT}^{\\text{road}} = 5$, $c_{XT}^{\\text{rail}} = 3$\n  - 单位排放量：$e_{SX}^{\\text{road}} = 2$, $e_{SX}^{\\text{rail}} = 1$, $e_{XT}^{\\text{road}} = 2$, $e_{XT}^{\\text{rail}} = 1$\n  - 排放上限：$E_{\\max} = 25$\n  - 转换惩罚：$P_{\\text{switch}} = 8$\n\n- 测试用例 3（惩罚较低时，转换模式有利）：\n  - $D = 8$\n  - 容量：$U_{SX}^{\\text{road}} = 20$, $U_{SX}^{\\text{rail}} = 20$, $U_{XT}^{\\text{road}} = 20$, $U_{XT}^{\\text{rail}} = 20$\n  - 成本：$c_{SX}^{\\text{road}} = 4$, $c_{SX}^{\\text{rail}} = 2$, $c_{XT}^{\\text{road}} = 4$, $c_{XT}^{\\text{rail}} = 6$\n  - 单位排放量：$e_{SX}^{\\text{road}} = 2$, $e_{SX}^{\\text{rail}} = 0.8$, $e_{XT}^{\\text{road}} = 2$, $e_{XT}^{\\text{rail}} = 0.8$\n  - 排放上限：$E_{\\max} = 100$\n  - 转换惩罚：$P_{\\text{switch}} = 2$\n\n- 测试用例 4（由于两个路段的两种模式容量均不足而不可行）：\n  - $D = 12$\n  - 容量：$U_{SX}^{\\text{road}} = 10$, $U_{SX}^{\\text{rail}} = 10$, $U_{XT}^{\\text{road}} = 10$, $U_{XT}^{\\text{rail}} = 10$\n  - 成本：$c_{SX}^{\\text{road}} = 3$, $c_{SX}^{\\text{rail}} = 3$, $c_{XT}^{\\text{road}} = 3$, $c_{XT}^{\\text{rail}} = 3$\n  - 单位排放量：$e_{SX}^{\\text{road}} = 1$, $e_{SX}^{\\text{rail}} = 1$, $e_{XT}^{\\text{road}} = 1$, $e_{XT}^{\\text{rail}} = 1$\n  - 排放上限：$E_{\\max} = 100$\n  - 转换惩罚：$P_{\\text{switch}} = 1$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的最小总成本（以美元为单位），格式为用方括号括起来的逗号分隔列表，例如 $[c_1,c_2,c_3,c_4]$。如果某个用例不可行，则在该位置输出 $+\\infty$。不应打印任何其他文本。", "solution": "经评估，用户提供的问题是有效的。\n\n### 第 1 步：提取已知条件\n- **节点**：源节点 $S$、中间节点 $X$、汇节点 $T$。\n- **运输路段**：$(S,X)$ 和 $(X,T)$。\n- **运输模式**：$m \\in \\{\\text{road}, \\text{rail}\\}$。\n- **需求**：$D$ 单位货物。\n- **决策变量**：\n    - 流量：对于 $m \\in \\{\\text{road}, \\text{rail}\\}$，有 $f_{SX}^{m} \\ge 0, f_{XT}^{m} \\ge 0$。\n    - 模式选择（二元）：对于 $m \\in \\{\\text{road}, \\text{rail}\\}$，有 $y_{SX}^{m}, y_{XT}^{m} \\in \\{0,1\\}$。\n    - 模式转换（二元）：$z \\in \\{0,1\\}$。\n- **参数**：\n    - 容量：$U_{ij}^{m} \\ge 0$。\n    - 单位成本：$c_{ij}^{m}$。\n    - 单位排放：$e_{ij}^{m}$。\n    - 转换惩罚：$P_{\\text{switch}}$。\n    - 排放上限：$E_{\\max}$。\n- **约束条件**：\n    1.  **需求满足/流量守恒**：$\\sum_{m} f_{SX}^{m} = D$ 和 $\\sum_{m} f_{XT}^{m} = D$。\n    2.  **模式选择排他性**：$\\sum_{m} y_{SX}^{m} = 1$ 和 $\\sum_{m} y_{XT}^{m} = 1$。\n    3.  **容量和模式一致性 (Big-M)**：对于 $(i,j) \\in \\{(S,X),(X,T)\\}$ 和 $m \\in \\{\\text{road},\\text{rail}\\}$，有 $f_{ij}^{m} \\le U_{ij}^{m} \\cdot y_{ij}^{m}$。\n    4.  **排放限制**：$\\sum_{m} \\left(e_{SX}^{m} f_{SX}^{m} + e_{XT}^{m} f_{XT}^{m}\\right) \\le E_{\\max}$。\n    5.  **转换逻辑**：$z \\ge y_{SX}^{\\text{road}} + y_{XT}^{\\text{rail}} - 1$ 和 $z \\ge y_{SX}^{\\text{rail}} + y_{XT}^{\\text{road}} - 1$。\n- **目标函数**：最小化总成本 $C = \\sum_{m} \\left(c_{SX}^{m} f_{SX}^{m} + c_{XT}^{m} f_{XT}^{m}\\right) + P_{\\text{switch}} \\cdot z$。\n- **测试用例**：提供了四个特定的参数集。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是单商品、固定费用、多式联运网络流问题的典型范式。所有定义（流量守恒、容量、线性成本、转换的二元逻辑）都是运筹学和优化方法领域的标准原则。该模型是一个混合整数线性规划（MILP），这是一个成熟的数学框架。该问题在科学和数学上是合理的。\n2.  **适定性**：该问题是适定的。给定一组参数，约束条件定义了一个可行域，目标是在该区域中找到一个使线性函数最小化的点。存在一个唯一的、稳定的、有意义的解（最小成本），或者可行域为空（此时问题不可行）。问题要求的是目标值，这是明确定义的。\n3.  **客观性**：问题陈述是精确、定量的，没有主观或含糊不清的语言。所有术语都得到了正式定义。\n4.  **自洽性和一致性**：问题为其解决方案提供了所有必要的数据和约束。这些约束是内部一致的。例如，big-M 约束 $f_{ij}^{m} \\le U_{ij}^{m} \\cdot y_{ij}^{m}$ 与流量守恒 $\\sum_{m} f_{ij}^{m} = D$ 和模式选择 $\\sum_{m} y_{ij}^{m} = 1$ 相结合，正确地强制规定了如果为路段 $(i,j)$ 选择了模式 $m^*$（即 $y_{ij}^{m^*} = 1$），则全部流量 $D$ 必须使用该模式（$f_{ij}^{m^*} = D$）并且在其容量范围内（$D \\le U_{ij}^{m^*}$）。\n5.  **相关性**：该问题直接关系到*优化方法*领域中的*典型建模模板（资源分配、混合、调度、网络流）*主题。\n\n### 第 3 步：结论与行动\n问题有效。将制定一个合理的解决方案。\n\n### 解决方案\n该问题描述了一个混合整数线性规划（MILP）。然而，其离散决策空间非常小。第一个路段 $(S,X)$ 有两种模式选择，第二个路段 $(X,T)$ 也有两种选择。这导致从 $S$ 到 $T$ 的整个运输路径只有 $2 \\times 2 = 4$ 种可能的模式组合。这四种路径是：\n1.  公路 $\\rightarrow$ 公路\n2.  公路 $\\rightarrow$ 铁路\n3.  铁路 $\\rightarrow$ 公路\n4.  铁路 $\\rightarrow$ 铁路\n\n鉴于离散选择数量少，我们可以通过完全枚举来解决此问题，而无需使用通用的 MILP 求解器。每个测试用例的流程是评估这四条路径中的每一条，检查可行性，如果可行则计算总成本，并找出所有可行路径中的最低成本。\n\n对于由模式选择 $(m_1, m_2)$ 定义的给定路径，其中 $m_1$ 是路段 $(S,X)$ 上的模式， $m_2$ 是路段 $(X,T)$ 上的模式，求解过程如下：\n\n1.  **设置流量**：根据问题约束，如果为路段 $(S,X)$ 选择了模式 $m_1$，则流量 $f_{SX}^{m_1}$ 必须等于总需求 $D$，而另一模式上的流量为 $0$。类似地，对于路段 $(X,T)$，有 $f_{XT}^{m_2} = D$。\n\n2.  **检查可行性**：\n    -   **容量约束**：总需求 $D$ 不得超过每个路段上所选模式的容量。\n        $$ D \\le U_{SX}^{m_1} \\quad \\text{和} \\quad D \\le U_{XT}^{m_2} $$\n    -   **排放约束**：沿所选路径运输需求 $D$ 所产生的总排放量不得超过最大允许排放量 $E_{\\max}$。\n        $$ e_{SX}^{m_1} \\cdot D + e_{XT}^{m_2} \\cdot D \\le E_{\\max} $$\n    如果违反了任一约束，则该路径不可行。\n\n3.  **计算成本**：如果一条路径是可行的，其总成本 $C$ 是运输成本和转换惩罚（如适用）的总和。\n    -   运输成本：$C_{\\text{transport}} = c_{SX}^{m_1} \\cdot D + c_{XT}^{m_2} \\cdot D$。\n    -   转换惩罚：如果 $m_1 \\neq m_2$，则增加一笔惩罚 $P_{\\text{switch}}$。\n    -   总成本：$C_{\\text{total}} = C_{\\text{transport}} + (\\text{如果 } m_1 \\neq m_2 \\text{ 则为 } P_{\\text{switch}} \\text{ 否则为 } 0)$。\n\n4.  **确定最小成本**：给定测试用例的最优成本是所有可行路径的 $C_{\\text{total}}$ 中的最小值。如果没有可行路径，则该测试用例的问题不可行，成本被视为 $+\\infty$。\n\n让我们以测试用例 1 为例应用此枚举方法：\n- **参数**：$D=10$, $E_{\\max}=100$, $P_{\\text{switch}}=2$。\n- **容量**：$U^{\\text{road}}_{SX}=20, U^{\\text{rail}}_{SX}=20, U^{\\text{road}}_{XT}=20, U^{\\text{rail}}_{XT}=20$。\n- **成本**：$c^{\\text{road}}_{SX}=4, c^{\\text{rail}}_{SX}=6, c^{\\text{road}}_{XT}=4, c^{\\text{rail}}_{XT}=6$。\n- **排放**：$e^{\\text{road}}_{SX}=2, e^{\\text{rail}}_{SX}=1, e^{\\text{road}}_{XT}=2, e^{\\text{rail}}_{XT}=1$。\n\n所有容量（$20$）都大于或等于 $D=10$，因此所有路径在容量上都是可行的。\n\n1.  **路径（公路 $\\rightarrow$ 公路）**：\n    -   排放量：$10 \\cdot (e^{\\text{road}}_{SX} + e^{\\text{road}}_{XT}) = 10 \\cdot (2+2) = 40$。由于 $40 \\le E_{\\max}=100$，因此在排放上是可行的。\n    -   成本：$10 \\cdot (c^{\\text{road}}_{SX} + c^{\\text{road}}_{XT}) = 10 \\cdot (4+4) = 80$。无转换惩罚。总成本 = $80.0$。\n\n2.  **路径（公路 $\\rightarrow$ 铁路）**：\n    -   排放量：$10 \\cdot (e^{\\text{road}}_{SX} + e^{\\text{rail}}_{XT}) = 10 \\cdot (2+1) = 30$。由于 $30 \\le 100$，它是可行的。\n    -   成本：$10 \\cdot (c^{\\text{road}}_{SX} + c^{\\text{rail}}_{XT}) + P_{\\text{switch}} = 10 \\cdot (4+6) + 2 = 102$。总成本 = $102.0$。\n\n3.  **路径（铁路 $\\rightarrow$ 公路）**：\n    -   排放量：$10 \\cdot (e^{\\text{rail}}_{SX} + e^{\\text{road}}_{XT}) = 10 \\cdot (1+2) = 30$。由于 $30 \\le 100$，它是可行的。\n    -   成本：$10 \\cdot (c^{\\text{rail}}_{SX} + c^{\\text{road}}_{XT}) + P_{\\text{switch}} = 10 \\cdot (6+4) + 2 = 102$。总成本 = $102.0$。\n\n4.  **路径（铁路 $\\rightarrow$ 铁路）**：\n    -   排放量：$10 \\cdot (e^{\\text{rail}}_{SX} + e^{\\text{rail}}_{XT}) = 10 \\cdot (1+1) = 20$。由于 $20 \\le 100$，它是可行的。\n    -   成本：$10 \\cdot (c^{\\text{rail}}_{SX} + c^{\\text{rail}}_{XT}) = 10 \\cdot (6+6) = 120$。无转换惩罚。总成本 = $120.0$。\n\n可行路径的成本集合为 $\\{80.0, 102.0, 102.0, 120.0\\}$。最低成本是 $80.0$。对所有测试用例重复此过程。该实现将为每个参数集系统地评估这四个离散选择。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multimodal transport network problem for a suite of test cases.\n    \"\"\"\n    \n    # Test cases defined as tuples of parameters.\n    # Format: (D, U_sx_r, U_sx_l, U_xt_r, U_xt_l, \n    #          c_sx_r, c_sx_l, c_xt_r, c_xt_l,\n    #          e_sx_r, e_sx_l, e_xt_r, e_xt_l,\n    #          E_max, P_switch)\n    # where 'r' is road and 'l' is rail.\n    test_cases = [\n        # Test case 1\n        (10, 20, 20, 20, 20, 4, 6, 4, 6, 2, 1, 2, 1, 100, 2),\n        # Test case 2\n        (10, 100, 100, 100, 100, 5, 3, 5, 3, 2, 1, 2, 1, 25, 8),\n        # Test case 3\n        (8, 20, 20, 20, 20, 4, 2, 4, 6, 2, 0.8, 2, 0.8, 100, 2),\n        # Test case 4\n        (12, 10, 10, 10, 10, 3, 3, 3, 3, 1, 1, 1, 1, 100, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        D, U_sx_r, U_sx_l, U_xt_r, U_xt_l, \\\n        c_sx_r, c_sx_l, c_xt_r, c_xt_l, \\\n        e_sx_r, e_sx_l, e_xt_r, e_xt_l, \\\n        E_max, P_switch = case\n\n        # For organization, store parameters in dictionaries keyed by mode\n        params = {\n            'road': {\n                'U_sx': U_sx_r, 'U_xt': U_xt_r,\n                'c_sx': c_sx_r, 'c_xt': c_xt_r,\n                'e_sx': e_sx_r, 'e_xt': e_xt_r\n            },\n            'rail': {\n                'U_sx': U_sx_l, 'U_xt': U_xt_l,\n                'c_sx': c_sx_l, 'c_xt': c_xt_l,\n                'e_sx': e_sx_l, 'e_xt': e_xt_l\n            }\n        }\n        \n        min_total_cost = float('inf')\n        \n        # Enumerate the 4 possible mode combinations (paths)\n        modes = ['road', 'rail']\n        for mode1 in modes:  # Mode for leg (S, X)\n            for mode2 in modes:  # Mode for leg (X, T)\n                \n                # 1. Feasibility Check: Capacity\n                if D > params[mode1]['U_sx'] or D > params[mode2]['U_xt']:\n                    continue  # This path is infeasible due to capacity\n                \n                # 2. Feasibility Check: Emissions\n                total_emissions = (params[mode1]['e_sx'] + params[mode2]['e_xt']) * D\n                if total_emissions > E_max:\n                    continue  # This path is infeasible due to emissions\n                    \n                # If both checks pass, the path is feasible. Calculate its cost.\n                \n                # 3. Calculate Cost\n                transport_cost = (params[mode1]['c_sx'] + params[mode2]['c_xt']) * D\n                \n                switching_cost = 0\n                if mode1 != mode2:\n                    switching_cost = P_switch\n                \n                current_total_cost = transport_cost + switching_cost\n                \n                # 4. Update Minimum Cost\n                if current_total_cost  min_total_cost:\n                    min_total_cost = current_total_cost\n\n        results.append(min_total_cost)\n\n    # Format the final output to match the specification\n    # The str() function correctly formats float('inf') as 'inf'\n    formatted_results = [f\"{r:.1f}\" if r != float('inf') else 'inf' for r in results]\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3106536"}]}