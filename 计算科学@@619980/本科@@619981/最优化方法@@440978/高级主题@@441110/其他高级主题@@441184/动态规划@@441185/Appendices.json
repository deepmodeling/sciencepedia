{"hands_on_practices": [{"introduction": "动态规划的核心在于将复杂问题分解为一系列更小的、可管理的决策步骤。本练习将通过一个经典的股票交易问题来实践这一思想。你的任务是在每天结束时决定是持有股票还是持有现金，以实现利润最大化。这个练习将帮助你掌握如何定义能够捕捉每个决策点必要信息的状态，并构建状态之间的转移关系，这是解决时序决策问题的关键。[@problem_id:3230619]", "problem": "给定一个单支股票的有限每日价格序列和一个非负的固定交易费。该费用在每次完成“先买后卖”的交易时，于卖出那一刻收取。你可以完成任意次数的交易，但受限于一个约束：任何时候你都不能持有多于一股股票；也就是说，你必须先卖出才能再次买入。不允许卖空。你的任务是设计并实现一个程序，为每个提供的测试用例计算在这些规则下的最大可能总利润。\n\n在推理和推导算法时，仅能使用以下基本原理：动态规划（DP）中的最优性原理和子问题分解，以及利润作为已完成交易所实现收益的累计和的标准定义。程序必须计算精确的最优值，而非近似值，并且必须足够高效，能够以线性的时间和常数的额外空间处理长序列。\n\n假设与说明：\n- 费用在每次交易的卖出时收取一次，买入时不收取。\n- 价格为非负整数。\n- 如果不存在有利可图的交易，最大利润为零。\n- 在任何一天开始前的初始状态是：不持有股票，累计利润为零。\n\n需要在程序中实现和评估的测试套件（按所列顺序处理）：\n- 用例 $1$: 价格 $[1,3,2,8,4,9]$，费用 $2$。\n- 用例 $2$: 价格 $[9,8,7,6,5]$，费用 $1$。\n- 用例 $3$: 价格 $[1,5,3,8,4,9]$，费用 $10$。\n- 用例 $4$: 价格 $[1,2,3,4,5]$，费用 $0$。\n- 用例 $5$: 价格 $[5]$，费用 $3$。\n- 用例 $6$: 价格 $[1,1,1,2,2,3,1,2]$，费用 $1$。\n- 用例 $7$: 价格 $[]$（空序列），费用 $5$。\n- 用例 $8$: 价格 $[3,2,6,5,0,3]$，费用 $1$。\n\n输出要求：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：[result1, result2, result3, ...]），每个结果是对应测试用例的最大利润，表示为一个非负整数。", "solution": "在有固定费用的股票交易中最大化利润是一个经典的优化问题，可以使用动态规划（DP）的原理高效解决。该问题表现出最优子结构特性，意味着一个价格序列的最优解可以由其前缀的最优解构建而成。这使我们能够将问题分解为一系列更小的、重叠的子问题。\n\n我们的推导过程将首先定义系统的状态，然后建立控制状态转换的递推关系，确定初始条件，最后展示这些元素如何结合，从而得到具有线性时间和常数空间复杂度的解法。\n\n设每日价格序列表示为 $P = [p_0, p_1, \\dots, p_{n-1}]$，交易费用为 $f$。在任何给定的一天 $i$ 结束时，我们的财务状况完全由我们的累计利润以及是否持有股票决定。这引出了为每一天 $i$ 定义两个状态变量：\n\n1.  $cash_i$：在第 $i$ 天结束时，如果我们**不**持有股票（即我们持有现金），可以实现的最大利润。\n2.  $hold_i$：在第 $i$ 天结束时，如果我们**正**持有一股股票，可以实现的最大利润。请注意，这个值可能是负数，因为它代表了我们包含所持股票成本在内的净值。\n\n现在我们可以根据第 $i-1$ 天的状态，建立定义 $cash_i$ 和 $hold_i$ 的状态转移方程，即递推关系。\n\n为了计算 $cash_i$，我们考虑在第 $i$ 天结束时的两种可能性：\n- 我们在第 $i-1$ 天结束时已经处于现金状态，并选择不进行任何操作。在这种情况下，我们的利润保持为 $cash_{i-1}$。\n- 我们在第 $i-1$ 天结束时持有一支股票，并在第 $i$ 天卖出。卖出股票获得价格 $p_i$ 但需支付费用 $f$。我们的新利润是前一个状态的值 $hold_{i-1}$ 与销售净收入 $p_i - f$ 之和。\n第 $i$ 天的最优现金状态是这两种结果中的最大值：\n$$ cash_i = \\max(cash_{i-1}, hold_{i-1} + p_i - f) $$\n\n为了计算 $hold_i$，我们同样考虑在第 $i$ 天结束时的两种可能性：\n- 我们在第 $i-1$ 天结束时已经持有一支股票，并选择继续持有。我们的状态值保持为 $hold_{i-1}$。\n- 我们在第 $i-1$ 天结束时处于现金状态，并选择在第 $i$ 天买入一股股票。这个操作花费 $p_i$，这笔费用从我们可用的现金 $cash_{i-1}$ 中扣除。\n第 $i$ 天的最优持有状态是这两种情形中的最大值。这反映了是继续持有先前购得的股票，还是以当前价格买入一支新股票的策略，取两者中能带来更好（负得更少或正得更多）头寸的那个：\n$$ hold_i = \\max(hold_{i-1}, cash_{i-1} - p_i) $$\n\n这些递推关系的基本情况对应于第一天之前的状态（即在 $i=-1$ 时）。\n- 最初，我们利润为零且不持有股票。因此，$cash_{-1} = 0$。\n- 不可能在过程开始时就已经持有股票。为了在递推中正确地对此建模，我们将持有状态初始化为一个值，以确保除非购买了股票，否则它在第一步中不可能是最大值。负无穷大的值，$hold_{-1} = -\\infty$，正好用于此目的。\n\n该算法通过从第 $i=0$ 天迭代到第 $i=n-1$ 天，在每一步应用状态转移方程来进行。最终答案是最后一天之后的最大利润。由于只有在不持有任何股票时才能实现利润，所以解是最后一天的现金状态值，$cash_{n-1}$。递推关系确保了此值为非负，因为 $cash_i$ 从 $0$ 开始，并且只有在发生有利可图的交易时才会增加。\n\n这些递推关系表明可以使用两个大小为 $n$ 的数组来存储所有 $i$ 的 $cash_i$ 和 $hold_i$ 的值。然而，请注意，第 $i$ 天的计算仅依赖于第 $i-1$ 天的值。这允许进行显著的空间优化。我们无需存储整个历史记录，只需维护两个变量来表示现金和持有状态的最新值。\n\n设这些变量为 $current\\_cash$ 和 $current\\_hold$。迭代算法如下：\n1.  初始化 $current\\_cash = 0$ 和 $current\\_hold = -\\infty$。\n2.  对于价格序列 $P$ 中的每个价格 $p$：\n    a. 将上一步的 $current\\_cash$ 值存储在一个临时变量中，例如，$previous\\_cash = current\\_cash$。\n    b. 更新 $current\\_cash = \\max(current\\_cash, current\\_hold + p - f)$。\n    c. 更新 $current\\_hold = \\max(current\\_hold, previous\\_cash - p)$。\n3.  循环结束后，最终结果是 $current\\_cash$。\n\n这种优化方法的时间复杂度为 $O(n)$，因为它只涉及对价格序列的一次遍历；空间复杂度为 $O(1)$，因为它只使用几个变量来存储当前状态。这满足了问题的效率要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_max_profit(prices, fee):\n    \"\"\"\n    Computes the maximum profit from stock transactions with a fee.\n\n    This function uses a dynamic programming approach with O(1) space complexity.\n    It maintains two state variables:\n    - cash: the maximum profit at the end of a day if not holding a stock.\n    - hold: the maximum profit at the end of a day if holding a stock.\n\n    Args:\n        prices (list[int]): A list of daily stock prices.\n        fee (int): The transaction fee applied on each sale.\n\n    Returns:\n        int: The maximum possible profit.\n    \"\"\"\n    # cash: max profit if we end the day with no stock\n    cash = 0\n    # hold: max profit if we end the day with one stock\n    # Initialized to a very small number, as it's impossible to hold a stock\n    # before the first day. This represents a state of negative infinity.\n    hold = -np.inf\n\n    # Iterate through each day's price\n    for price in prices:\n        # Cache the cash value from the previous step before it's updated.\n        # This is crucial because the new 'hold' state depends on the 'cash'\n        # state before any transaction on the current day.\n        prev_cash = cash\n\n        # Update the 'cash' state.\n        # We can either do nothing (maintaining 'cash') or sell the stock we're\n        # holding ('hold + price - fee'). We take the maximum.\n        cash = max(cash, hold + price - fee)\n\n        # Update the 'hold' state.\n        # We can either do nothing (maintaining 'hold') or buy a stock today,\n        # which transitions from the previous cash state ('prev_cash - price').\n        # We take the maximum.\n        hold = max(hold, prev_cash - price)\n\n    # The final profit must be an integer and is the profit in the 'cash' state\n    # after the last day, as we must sell all stock to realize profit.\n    return int(cash)\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the stock profit problem.\n    \"\"\"\n    # The test suite provided in the problem statement.\n    test_cases = [\n        # (prices, fee)\n        ([1, 3, 2, 8, 4, 9], 2),       # Case 1\n        ([9, 8, 7, 6, 5], 1),         # Case 2\n        ([1, 5, 3, 8, 4, 9], 10),      # Case 3\n        ([1, 2, 3, 4, 5], 0),         # Case 4\n        ([5], 3),                     # Case 5\n        ([1, 1, 1, 2, 2, 3, 1, 2], 1), # Case 6\n        ([], 5),                      # Case 7\n        ([3, 2, 6, 5, 0, 3], 1),      # Case 8\n    ]\n\n    results = []\n    for prices, fee in test_cases:\n        result = compute_max_profit(prices, fee)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3230619"}, {"introduction": "许多问题看似可以通过每一步都选择“当前最佳”的贪心策略来解决，但这种短视的方法往往无法得到全局最优解。本练习将通过一个资源分配的例子，让你亲手构建一个反例，证明贪心策略的局限性。你将运用动态规划的贝尔曼最优性原理，从未来倒推，找到真正的最优分配方案，从而深刻理解动态规划在确保全局最优性方面的独特优势。[@problem_id:3124007]", "problem": "考虑一个有限期资源分配问题，该问题涵盖 $T=2$ 个离散时期和两个项目 $A$ 和 $B$。在每个时期 $t \\in \\{1,2\\}$，必须将 $1$ 个不可分割的资源单位精确地分配给一个项目。令 $x_A$ 和 $x_B$ 表示到第 $2$ 期结束时分配给项目 $A$ 和 $B$ 的累计资源单位数，因此 $x_A + x_B = 2$ 且 $x_A, x_B \\in \\{0,1,2\\}$。第 $2$ 期结束时的总回报是各项目特定回报之和 $f_A(x_A) + f_B(x_B)$，其中项目回报函数 $f_A$ 和 $f_B$ 在集合 $\\{0,1,2\\}$ 上的定义如下：\n- $f_A(0)=0$, $f_A(1)=8$, $f_A(2)=9$,\n- $f_B(0)=0$, $f_B(1)=7$, $f_B(2)=20$.\n\n一个忽略未来时期的自然贪心策略如下：在每个时期 $t$，将当前资源单位分配给当前边际回报增量 $\\Delta f_i(x_i) = f_i(x_i+1)-f_i(x_i)$ 最大的项目，平局则任意选择。\n\n任务：\n1. 使用动态规划中的最优性原理，定义一个关于时间 $t$ 的值函数和一个能捕捉累计分配情况的合适状态，并写出相应的 Bellman 递归式，该递归式将终端时刻的总回报评估为 $f_A(x_A)+f_B(x_B)$。\n2. 使用此递归计算最优分配及其总回报。\n3. 计算上述贪心策略获得的总回报，并证明它严格小于最优值，从而提供一个具体反例，说明按最大边际增量选择的贪心策略失败，而基于时间 $t$ 的动态规划（DP）能得出最优分配。\n\n最终答案仅提供最优总回报，形式为一个实数。无需四舍五入，不涉及单位。", "solution": "所述问题是一个有限期资源分配问题。该问题是自洽的、数学上一致的，并且属于优化方法的标准框架内。因此，该问题是有效的。我们按顺序解决这三个任务，开始解答。\n\n### 任务 1：动态规划公式化\n\n令时间周期由 $t \\in \\{1, 2\\}$ 索引。在每个时期，一个不可分割的资源单位被分配给两个项目 $A$ 或 $B$ 中的一个。待分配的总单位数为 $T=2$。\n\n我们将时期 $t$ 开始时的系统状态定义为 $s_t = (n_A, n_B)$，其中 $n_A$ 和 $n_B$ 分别是在时期 $1, \\dots, t-1$ 期间分配给项目 $A$ 和 $B$ 的累计单位数。这意味着状态约束为 $n_A + n_B = t-1$。\n\n时期 $t$ 的决策或行动是 $u_t \\in \\{A, B\\}$，表示选择将该单位分配给项目 $A$ 还是项目 $B$。\n\n状态转移是确定性的。如果时期 $t$ 的状态是 $(n_A, n_B)$，那么时期 $t+1$ 的状态将变为：\n- 如果行动是 $u_t=A$，则为 $(n_A+1, n_B)$。\n- 如果行动是 $u_t=B$，则为 $(n_A, n_B+1)$。\n\n目标是最大化期末的总回报，其由 $f_A(x_A) + f_B(x_B)$ 给出，其中 $(x_A, x_B)$ 是 $T=2$ 个时期后的最终分配，满足 $x_A+x_B=2$。\n\n令 $J_t(n_A, n_B)$ 为从期末开始计算的最优（最大）总回报，前提是系统在时期 $t$ 开始时处于状态 $(n_A, n_B)$。这是一个定义在状态和时间上的值函数。最优性原理引出以下通过时间倒推导出的 Bellman 递归式：\n$$\nJ_t(n_A, n_B) = \\max \\begin{cases} J_{t+1}(n_A+1, n_B)  \\text{若 } u_t=A \\\\ J_{t+1}(n_A, n_B+1)  \\text{若 } u_t=B \\end{cases}\n$$\n该递归在一个概念上的时期 $t=3$ 终止，此时所有 $2$ 次分配都已完成。在这个终端阶段的值就是总回报本身，基于最终分配 $(x_A, x_B)$：\n$$\nJ_3(x_A, x_B) = f_A(x_A) + f_B(x_B) \\quad \\text{其中 } x_A+x_B=2.\n$$\n\n### 任务 2：最优分配与回报的计算\n\n我们应用任务 1 中建立的后向递归。\n\n**终端阶段 ($t=3$)：**\n我们计算所有可能的最终分配 $(x_A, x_B)$ 的值，其中 $x_A, x_B \\in \\{0,1,2\\}$ 且 $x_A+x_B=2$。\n- 对于分配 $(2,0)$：$J_3(2,0) = f_A(2) + f_B(0) = 9 + 0 = 9$。\n- 对于分配 $(1,1)$：$J_3(1,1) = f_A(1) + f_B(1) = 8 + 7 = 15$。\n- 对于分配 $(0,2)$：$J_3(0,2) = f_A(0) + f_B(2) = 0 + 20 = 20$。\n\n**时期 $t=2$：**\n在第 $2$ 期开始时，已分配了一个单位 ($t-1=1$)。可能的状态是 $(1,0)$ 和 $(0,1)$。\n- 对于状态 $s_2 = (1,0)$：我们正在决定第二个单位的分配。\n  - 行动 $A$：导致最终状态 $(2,0)$。值为 $J_3(2,0)=9$。\n  - 行动 $B$：导致最终状态 $(1,1)$。值为 $J_3(1,1)=15$。\n  因此，$J_2(1,0) = \\max\\{9, 15\\} = 15$。最优行动是 $B$。\n- 对于状态 $s_2 = (0,1)$：我们正在决定第二个单位的分配。\n  - 行动 $A$：导致最终状态 $(1,1)$。值为 $J_3(1,1)=15$。\n  - 行动 $B$：导致最终状态 $(0,2)$。值为 $J_3(0,2)=20$。\n  因此，$J_2(0,1) = \\max\\{15, 20\\} = 20$。最优行动是 $B$。\n\n**时期 $t=1$：**\n在第 $1$ 期开始时，没有单位被分配，所以状态是 $s_1 = (0,0)$。我们正在决定第一个单位的分配。\n- 行动 $A$：在 $t=2$ 时导致状态 $(1,0)$。此路径的最优值为 $J_2(1,0)=15$。\n- 行动 $B$：在 $t=2$ 时导致状态 $(0,1)$。此路径的最优值为 $J_2(0,1)=20$。\n因此，可实现的最大回报是 $J_1(0,0) = \\max\\{15, 20\\} = 20$。第一个最优行动是 $B$。\n\n通过向前追踪最优决策：\n1. 在 $t=1$ 时，从状态 $(0,0)$ 开始，最优行动是 $B$。系统转移到状态 $(0,1)$。\n2. 在 $t=2$ 时，处于状态 $(0,1)$，最优行动是 $B$。系统转移到最终分配 $(0,2)$。\n\n最优分配是 $(x_A, x_B) = (0,2)$，它产生的最优总回报为 $f_A(0) + f_B(2) = 0 + 20 = 20$。\n\n### 任务 3：贪心策略分析\n\n贪心策略在每个时期将单位分配给当前边际回报最大的项目，边际回报定义为 $\\Delta f_i(x_i) = f_i(x_i+1) - f_i(x_i)$，其中 $x_i$ 是当前已分配给项目 $i$ 的单位数。\n\n首先，我们计算边际回报：\n- 对于项目 $A$：\n  - $\\Delta f_A(0) = f_A(1) - f_A(0) = 8 - 0 = 8$。\n  - $\\Delta f_A(1) = f_A(2) - f_A(1) = 9 - 8 = 1$。\n- 对于项目 $B$：\n  - $\\Delta f_B(0) = f_B(1) - f_B(0) = 7 - 0 = 7$。\n  - $\\Delta f_B(1) = f_B(2) - f_B(1) = 20 - 7 = 13$。\n\n现在，我们模拟贪心策略：\n- **时期 $t=1$**：当前分配为 $(0,0)$。我们比较增加第一个单位的边际回报：$\\Delta f_A(0)=8$ 和 $\\Delta f_B(0)=7$。由于 $8 > 7$，贪心策略将单位分配给项目 $A$。分配变为 $(1,0)$。\n- **时期 $t=2$**：当前分配为 $(1,0)$。我们比较增加第二个单位的边际回报：项目 $A$ 的 $\\Delta f_A(1)=1$ 和项目 $B$ 的 $\\Delta f_B(0)=7$。由于 $7 > 1$，贪心策略将单位分配给项目 $B$。最终分配变为 $(1,1)$。\n\n贪心策略得到的最终分配是 $(x_A, x_B) = (1,1)$。此分配的总回报为：\n$$ f_A(1) + f_B(1) = 8 + 7 = 15. $$\n贪心策略获得的总回报为 $15$，严格小于使用动态规划找到的最优回报 $20$。这证实了短视的贪心方法对于此问题是次优的。在 $t=1$ 时的贪心选择使得系统无法进入回报最高的状态 $(0,2)$，因为它未能考虑到第二次分配给项目 $B$ 所带来的巨大未来边际收益。", "answer": "$$\n\\boxed{20}\n$$", "id": "3124007"}, {"introduction": "前面的练习主要关注基于时间序列的决策。现在，我们将挑战一类更为复杂的组合优化问题——任务排序。这个问题是著名的旅行商问题（Traveling Salesperson Problem, TSP）的一个变体，其挑战在于决策空间会随着任务数量的增加而爆炸式增长。你将学习一种强大的“子集动态规划”技巧，其中状态不再仅仅是时间点，而是已完成任务的集合，这为你解决更广泛的排序、路径规划和组合设计问题提供了关键思路。[@problem_id:3123982]", "problem": "一个制造单元必须处理一组索引为 $[n] = \\{1,2,3,4,5\\}$ 的作业。从作业 $i$ 切换到作业 $j$ 会产生一个与设置相关的成本 $s_{ij}$，从初始机器状态 $0$ 切换到作业 $j$ 的成本为 $s_{0j}$。每个作业必须在从初始状态 $0$ 开始的某个序列中被精确处理一次。总序列成本定义为沿序列的切换成本之和，即如果序列为 $0 \\to j_{1} \\to j_{2} \\to \\dots \\to j_{n}$，则总成本为 $s_{0,j_{1}} + \\sum_{k=1}^{n-1} s_{j_{k}, j_{k+1}}$。目标是最小化这个总切换成本。\n\n该实例由以下数据给出。初始切换成本为\n$$\n\\bigl(s_{0,1}, s_{0,2}, s_{0,3}, s_{0,4}, s_{0,5}\\bigr) = (8, 3, 9, 4, 7).\n$$\n对于 $i,j \\in \\{1,2,3,4,5\\}$，作业间的切换成本 $s_{ij}$ 由以下矩阵指定\n$$\n\\begin{bmatrix}\ns_{1,1}  s_{1,2}  s_{1,3}  s_{1,4}  s_{1,5} \\\\\ns_{2,1}  s_{2,2}  s_{2,3}  s_{2,4}  s_{2,5} \\\\\ns_{3,1}  s_{3,2}  s_{3,3}  s_{3,4}  s_{3,5} \\\\\ns_{4,1}  s_{4,2}  s_{4,3}  s_{4,4}  s_{4,5} \\\\\ns_{5,1}  s_{5,2}  s_{5,3}  s_{5,4}  s_{5,5}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0  6  7  5  3 \\\\\n4  0  5  2  6 \\\\\n7  4  0  7  5 \\\\\n1  6  6  0  4 \\\\\n5  5  2  6  0\n\\end{bmatrix}.\n$$\n\n从基本的 Bellman 最优性原理出发，推导一个动态规划公式，该公式使用形式为 $(S,j)$ 的状态，其中 $S \\subseteq [n]$ 是已完成作业的集合，$j \\in S$ 是最后一个完成的作业，以计算最小的总切换成本。然后，将您的公式应用于给定实例，计算在从初始状态 $0$ 开始并精确访问每个作业一次的所有序列中，可实现的最小总切换成本。\n\n将您的最终答案表示为一个精确的整数，不进行四舍五入，不带单位。", "solution": "根据指定的验证标准对问题进行评估。\n\n### 问题验证\n**第1步：提取已知条件**\n- 作业集合：$[n] = \\{1, 2, 3, 4, 5\\}$。\n- 初始机器状态：$0$。\n- 从作业 $i$ 到作业 $j$ 的切换成本：$s_{ij}$。\n- 从状态 $0$ 到作业 $j$ 的初始切换成本：$s_{0j}$。\n- 初始切换成本数据：$(s_{0,1}, s_{0,2}, s_{0,3}, s_{0,4}, s_{0,5}) = (8, 3, 9, 4, 7)$。\n- 对于 $i,j \\in \\{1,2,3,4,5\\}$，作业间的切换成本 $s_{ij}$ 数据：\n$$\n\\begin{bmatrix}\n0  6  7  5  3 \\\\\n4  0  5  2  6 \\\\\n7  4  0  7  5 \\\\\n1  6  6  0  4 \\\\\n5  5  2  6  0\n\\end{bmatrix}\n$$\n- 约束：每个作业必须被精确处理一次。\n- 操作序列：$0 \\to j_{1} \\to j_{2} \\to \\dots \\to j_{n}$。\n- 目标函数：最小化总成本，定义为 $s_{0,j_{1}} + \\sum_{k=1}^{n-1} s_{j_{k}, j_{k+1}}$。\n- 任务：推导一个状态为 $(S, j)$ 的动态规划公式，并应用它来找到最小的总切换成本。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据**：该问题是非对称旅行商路径问题 (ATSPP) 的一个经典实例，这是组合优化和运筹学中一个成熟的问题。所要求的解决方法，动态规划，是解决此类问题（特别是 Held-Karp 算法）的标准且强大的技术。该问题在数学上和科学上都是合理的。\n- **适定性**：问题是适定的。它旨在在一个有限、非空的排列集合上找到成本函数的最小值。最小值保证存在。动态规划方法确保找到唯一的最小成本。\n- **客观性**：问题以精确、客观的语言陈述。所有成本都以明确的数值数据给出，目标函数定义明确。\n- **完整性与一致性**：提供了所有必要的数据（成本）和约束。问题陈述中没有矛盾。对角线元素 $s_{ii}=0$ 与问题中每个作业只访问一次的约束一致，这排除了从一个作业到其自身的转换。\n\n**第3步：结论与行动**\n该问题是有效的，因为它具有科学依据、适定、客观和完整。将推导和计算解决方案。\n\n### 动态规划公式\n\n该问题可以建模为在状态空间图中寻找最短路径，因此适合使用动态规划。该公式基于 Bellman 最优性原理，该原理指出最优路径由最优子路径组成。\n\n设 $S \\subseteq [n]$ 是已处理的作业子集，设 $j \\in S$ 是序列中最后一个处理的作业。我们将状态定义为序对 $(S, j)$。\n\n设 $C(S, j)$ 是从初始机器状态 $0$ 开始，精确访问集合 $S$ 中的每个作业一次，并以作业 $j$ 结束的路径的最小成本。\n\n**基本情况：**\n对于只访问了一个作业的路径，访问过的作业集合为 $S = \\{j\\}$。路径就是 $0 \\to j$。成本是初始切换成本 $s_{0j}$。\n因此，对于每个 $j \\in [n]$，基本情况为：\n$$\nC(\\{j\\}, j) = s_{0j}\n$$\n\n**递推关系：**\n对于任何大小 $|S| > 1$ 的集合 $S$ 和任何作业 $j \\in S$，覆盖 $S$ 中所有作业并到达 $j$ 的最优路径必定来自某个作业 $i \\in S \\setminus \\{j\\}$。根据 Bellman 原理，到达 $i$ 的子路径必须覆盖了 $S \\setminus \\{j\\}$ 中的所有作业，并且其本身必须是最优的。这样一个子路径的成本是 $C(S \\setminus \\{j\\}, i)$。从 $i$ 到 $j$，我们产生额外的切换成本 $s_{ij}$。为了找到作为集合 $S$ 中最后一个作业到达 $j$ 的最小成本，我们必须考虑所有可能的倒数第二个作业 $i$，并选择使总成本最小化的那一个。\n\n这给出了当 $|S| \\geq 2$ 时的递推关系：\n$$\nC(S, j) = \\min_{i \\in S \\setminus \\{j\\}} \\{ C(S \\setminus \\{j\\}, i) + s_{ij} \\}\n$$\n\n**最终解：**\n问题要求处理所有 $n$ 个作业。最终访问的作业集合是 $S = [n] = \\{1, 2, 3, 4, 5\\}$。序列可以在任何作业 $j \\in [n]$ 结束。最小总切换成本是所有可能的完整序列成本中的最小值。\n$$\n\\text{最小总成本} = \\min_{j \\in [n]} \\{ C([n], j) \\}\n$$\n\n### 应用于给定实例\n我们现在将此公式应用于所提供的数据，其中 $n=5$。\n\n**阶段 1: $|S|=1$**\n成本是初始切换成本 $s_{0j}$。\n$C(\\{1\\}, 1) = s_{0,1} = 8$\n$C(\\{2\\}, 2) = s_{0,2} = 3$\n$C(\\{3\\}, 3) = s_{0,3} = 9$\n$C(\\{4\\}, 4) = s_{0,4} = 4$\n$C(\\{5\\}, 5) = s_{0,5} = 7$\n\n**阶段 2: $|S|=2$**\n我们计算 $C(\\{i,j\\}, j) = C(\\{i\\}, i) + s_{ij}$。\n$C(\\{1,2\\}, 1) = C(\\{2\\},2)+s_{2,1} = 3+4 = 7$\n$C(\\{1,2\\}, 2) = C(\\{1\\},1)+s_{1,2} = 8+6 = 14$\n$C(\\{1,3\\}, 1) = C(\\{3\\},3)+s_{3,1} = 9+7 = 16$\n$C(\\{1,3\\}, 3) = C(\\{1\\},1)+s_{1,3} = 8+7 = 15$\n$C(\\{1,4\\}, 1) = C(\\{4\\},4)+s_{4,1} = 4+1 = 5$\n$C(\\{1,4\\}, 4) = C(\\{1\\},1)+s_{1,4} = 8+5 = 13$\n$C(\\{1,5\\}, 1) = C(\\{5\\},5)+s_{5,1} = 7+5 = 12$\n$C(\\{1,5\\}, 5) = C(\\{1\\},1)+s_{1,5} = 8+3 = 11$\n$C(\\{2,3\\}, 2) = C(\\{3\\},3)+s_{3,2} = 9+4 = 13$\n$C(\\{2,3\\}, 3) = C(\\{2\\},2)+s_{2,3} = 3+5 = 8$\n$C(\\{2,4\\}, 2) = C(\\{4\\},4)+s_{4,2} = 4+6 = 10$\n$C(\\{2,4\\}, 4) = C(\\{2\\},2)+s_{2,4} = 3+2 = 5$\n$C(\\{2,5\\}, 2) = C(\\{5\\},5)+s_{5,2} = 7+5 = 12$\n$C(\\{2,5\\}, 5) = C(\\{2\\},2)+s_{2,5} = 3+6 = 9$\n$C(\\{3,4\\}, 3) = C(\\{4\\},4)+s_{4,3} = 4+6 = 10$\n$C(\\{3,4\\}, 4) = C(\\{3\\},3)+s_{3,4} = 9+7 = 16$\n$C(\\{3,5\\}, 3) = C(\\{5\\},5)+s_{5,3} = 7+2 = 9$\n$C(\\{3,5\\}, 5) = C(\\{3\\},3)+s_{3,5} = 9+5 = 14$\n$C(\\{4,5\\}, 4) = C(\\{5\\},5)+s_{5,4} = 7+6 = 13$\n$C(\\{4,5\\}, 5) = C(\\{4\\},4)+s_{4,5} = 4+4 = 8$\n\n**阶段 3: $|S|=3$**\n使用递推关系 $C(S,k) = \\min_{j \\in S \\setminus \\{k\\}} \\{ C(S \\setminus \\{k\\}, j) + s_{jk} \\}$。\n$C(\\{1,2,3\\},1) = \\min\\{C(\\{2,3\\},2)+s_{21}, C(\\{2,3\\},3)+s_{31}\\} = \\min\\{13+4, 8+7\\} = 15$\n$C(\\{1,2,3\\},2) = \\min\\{C(\\{1,3\\},1)+s_{12}, C(\\{1,3\\},3)+s_{32}\\} = \\min\\{16+6, 15+4\\} = 19$\n$C(\\{1,2,3\\},3) = \\min\\{C(\\{1,2\\},1)+s_{13}, C(\\{1,2\\},2)+s_{23}\\} = \\min\\{7+7, 14+5\\} = 14$\n$C(\\{1,2,4\\},1) = \\min\\{C(\\{2,4\\},2)+s_{21}, C(\\{2,4\\},4)+s_{41}\\} = \\min\\{10+4, 5+1\\} = 6$\n$C(\\{1,2,4\\},2) = \\min\\{C(\\{1,4\\},1)+s_{12}, C(\\{1,4\\},4)+s_{42}\\} = \\min\\{5+6, 13+6\\} = 11$\n$C(\\{1,2,4\\},4) = \\min\\{C(\\{1,2\\},1)+s_{14}, C(\\{1,2\\},2)+s_{24}\\} = \\min\\{7+5, 14+2\\} = 12$\n$C(\\{1,3,5\\},3) = \\min\\{C(\\{1,5\\},1)+s_{13}, C(\\{1,5\\},5)+s_{53}\\} = \\min\\{12+7, 11+2\\} = 13$\n$C(\\{2,3,4\\},3) = \\min\\{C(\\{2,4\\},2)+s_{23}, C(\\{2,4\\},4)+s_{43}\\} = \\min\\{10+5, 5+6\\} = 11$\n$C(\\{2,3,5\\},3) = \\min\\{C(\\{2,5\\},2)+s_{23}, C(\\{2,5\\},5)+s_{53}\\} = \\min\\{12+5, 9+2\\} = 11$\n$C(\\{2,4,5\\},5) = \\min\\{C(\\{2,4\\},2)+s_{25}, C(\\{2,4\\},4)+s_{45}\\} = \\min\\{10+6, 5+4\\} = 9$\n$C(\\{3,4,5\\},3) = \\min\\{C(\\{4,5\\},4)+s_{43}, C(\\{4,5\\},5)+s_{53}\\} = \\min\\{13+6, 8+2\\} = 10$\n$|S|=3$ 的其他值也类似计算。\n\n**阶段 4: $|S|=4$**\n计算继续进行。例如，对于 $S=\\{1,2,3,4\\}$：\n$C(\\{1,2,3,4\\},1) = \\min\\{C(\\{2,3,4\\},2)+s_{21}, C(\\{2,3,4\\},3)+s_{31}, C(\\{2,3,4\\},4)+s_{41}\\} = \\min\\{14+4, 11+7, 15+1\\} = 16$\n$C(\\{1,2,3,4\\},2) = \\min\\{C(\\{1,3,4\\},1)+s_{12}, C(\\{1,3,4\\},3)+s_{32}, C(\\{1,3,4\\},4)+s_{42}\\} = \\min\\{17+6, 12+4, 21+6\\} = 16$\n$C(\\{1,2,3,4\\},3) = \\min\\{C(\\{1,2,4\\},1)+s_{13}, C(\\{1,2,4\\},2)+s_{23}, C(\\{1,2,4\\},4)+s_{43}\\} = \\min\\{6+7, 11+5, 12+6\\} = 13$\n$C(\\{1,2,3,4\\},4) = \\min\\{C(\\{1,2,3\\},1)+s_{14}, C(\\{1,2,3\\},2)+s_{24}, C(\\{1,2,3\\},3)+s_{34}\\} = \\min\\{15+5, 19+2, 14+7\\} = 20$\n$|S|=4$ 的其他值也类似计算，得出在最后阶段使用的以下值：\n$C(\\{1,2,3,5\\},1)=17, C(\\{1,2,3,5\\},2)=17, C(\\{1,2,3,5\\},3)=12, C(\\{1,2,3,5\\},5)=18$\n$C(\\{1,2,4,5\\},1)=14, C(\\{1,2,4,5\\},2)=13, C(\\{1,2,4,5\\},4)=16, C(\\{1,2,4,5\\},5)=9$\n$C(\\{1,3,4,5\\},1)=17, C(\\{1,3,4,5\\},3)=10, C(\\{1,3,4,5\\},4)=20, C(\\{1,3,4,5\\},5)=17$\n$C(\\{2,3,4,5\\},2)=14, C(\\{2,3,4,5\\},3)=11, C(\\{2,3,4,5\\},4)=15, C(\\{2,3,4,5\\},5)=16$\n\n**阶段 5: $|S|=5$**\n我们计算完整集合 $S=\\{1,2,3,4,5\\}$ 的成本。\n$C(S,1) = \\min\\{C(\\{2,3,4,5\\},2)+s_{21}, C(\\{2,3,4,5\\},3)+s_{31}, C(\\{2,3,4,5\\},4)+s_{41}, C(\\{2,3,4,5\\},5)+s_{51}\\} = \\min\\{14+4, 11+7, 15+1, 16+5\\} = \\min\\{18, 18, 16, 21\\} = 16$.\n\n$C(S,2) = \\min\\{C(\\{1,3,4,5\\},1)+s_{12}, C(\\{1,3,4,5\\},3)+s_{32}, C(\\{1,3,4,5\\},4)+s_{42}, C(\\{1,3,4,5\\},5)+s_{52}\\} = \\min\\{17+6, 10+4, 20+6, 17+5\\} = \\min\\{23, 14, 26, 22\\} = 14$.\n\n$C(S,3) = \\min\\{C(\\{1,2,4,5\\},1)+s_{13}, C(\\{1,2,4,5\\},2)+s_{23}, C(\\{1,2,4,5\\},4)+s_{43}, C(\\{1,2,4,5\\},5)+s_{53}\\} = \\min\\{14+7, 13+5, 16+6, 9+2\\} = \\min\\{21, 18, 22, 11\\} = 11$.\n\n$C(S,4) = \\min\\{C(\\{1,2,3,5\\},1)+s_{14}, C(\\{1,2,3,5\\},2)+s_{24}, C(\\{1,2,3,5\\},3)+s_{34}, C(\\{1,2,3,5\\},5)+s_{54}\\} = \\min\\{17+5, 17+2, 12+7, 18+6\\} = \\min\\{22, 19, 19, 24\\} = 19$.\n\n$C(S,5) = \\min\\{C(\\{1,2,3,4\\},1)+s_{15}, C(\\{1,2,3,4\\},2)+s_{25}, C(\\{1,2,3,4\\},3)+s_{35}, C(\\{1,2,3,4\\},4)+s_{45}\\} = \\min\\{16+3, 16+6, 13+5, 20+4\\} = \\min\\{19, 22, 18, 24\\} = 18$.\n\n**最终答案计算**\n最小总切换成本是所有可能结束作业中的最小值：\n$$\n\\text{最小总成本} = \\min \\{ C(S,1), C(S,2), C(S,3), C(S,4), C(S,5) \\}\n$$\n$$\n\\text{最小总成本} = \\min \\{16, 14, 11, 19, 18\\} = 11\n$$\n产生此成本的最优序列可以通过回溯计算找到。最小成本 $11$ 是 $C(\\{1,2,3,4,5\\},3)$。这是从状态 $(\\{1,2,4,5\\}, 5)$ 得到的，成本为 $C(\\{1,2,4,5\\},5)+s_{53} = 9+2=11$。进一步回溯揭示最优路径是 $0 \\to 2 \\to 4 \\to 1 \\to 5 \\to 3$，总成本为 $s_{0,2} + s_{2,4} + s_{4,1} + s_{1,5} + s_{5,3} = 3 + 2 + 1 + 3 + 2 = 11$。", "answer": "$$\n\\boxed{11}\n$$", "id": "3123982"}]}