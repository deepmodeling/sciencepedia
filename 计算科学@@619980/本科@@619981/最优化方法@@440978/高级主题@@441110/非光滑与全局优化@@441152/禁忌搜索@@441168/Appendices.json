{"hands_on_practices": [{"introduction": "旅行商问题（TSP）是检验优化算法性能的经典战场。本练习要求你亲手构建一个完整的禁忌搜索求解器来应对这一挑战，并在此过程中探索一个核心的设计权衡：是详尽地搜索整个邻域以找到最佳移动，还是使用一个受限的候选列表来节省计算时间？通过对这两种策略的实证比较，你将深刻理解算法效率与解质量之间的微妙平衡。[@problem_id:3190936]", "problem": "在一个对称的欧几里得旅行商问题（TSP）中，实现并实证评估禁忌搜索（Tabu Search）的两种候选列表策略。目标是在单次迭代的计算成本和解的质量方面，比较全邻域扫描与大小为 $k$ 的受限候选列表。该问题必须通过编写一个完整的、可运行的程序来解决。\n\n给定以下基本定义和假设：\n- 旅行商问题定义在一个包含 $n$ 个节点（城市）的完全图上，其中每条无向边 $(i,j)$ 具有对称距离 $d_{ij} = d_{ji} \\ge 0$。对于一个巡回（排列）$\\pi$，目标函数 $f(\\pi)$ 是由 $\\pi$ 导出的环路上的欧几里得距离之和，即 $f(\\pi) = \\sum_{t=0}^{n-1} d_{\\pi_t,\\pi_{t+1 \\bmod n}}$。\n- 邻域算子由 $2$-opt 移动定义。一个 2-opt 移动通过选择一对索引 $(i, j)$（其中 $0 \\le i  j  n$）并反转它们之间的路径段来工作。", "solution": "用户希望为应用于对称欧几里得旅行商问题（TSP）的禁忌搜索（TS）算法实现并评估两种候选列表策略。这需要详细实现TSP环境、具有特定组件的TS元启发式算法以及两种竞争策略，然后基于提供的测试用例进行实证比较。\n\n### **1. 问题建模**\n问题被定义为在完全图 $G=(V, E)$ 上的对称旅行商问题（TSP），其中 $V$ 是位于单位正方形 $[0,1] \\times [0,1]$ 内的 $n$ 个城市（节点）的集合。每条边 $(i, j) \\in E$ 的成本（距离）$d_{ij}$ 是城市 $i$ 和 $j$ 之间的欧几里得距离。一个解是一个巡回，即城市的排列 $\\pi$。目标是找到一个使总长度最小化的巡回，其长度由函数 $f(\\pi) = \\sum_{t=0}^{n-1} d_{\\pi_t, \\pi_{(t+1) \\pmod n}}$ 给出。\n\n### **2. 邻域结构与移动评估**\n解的邻域由 **2-opt 算子** 定义。一个 2-opt 移动通过选择两条不相邻的边，移除它们，并以唯一另一种能产生有效巡回的方式重新连接四个形成的端点来变换一个巡回。这等同于反转巡回的一个片段。一个移动由一对索引 $(i, j)$ 定义，其中 $0 \\le i  j \\le n-1$，对应于路径段 $\\pi[i \\ldots j]$ 的反转。问题规定排除平凡的全巡回反转 $(i,j)=(0, n-1)$。\n\n2-opt 移动导致巡回长度的变化（delta）可以在 $O(1)$ 时间内计算。如果边 $(\\pi_{i-1}, \\pi_i)$ 和 $(\\pi_j, \\pi_{j+1})$ 被移除并替换为 $(\\pi_{i-1}, \\pi_j)$ 和 $(\\pi_i, \\pi_{j+1})$（其中索引模 $n$），则 delta 为：\n$$ \\Delta = d(\\pi_{i-1}, \\pi_j) + d(\\pi_i, \\pi_{j+1}) - d(\\pi_{i-1}, \\pi_i) - d(\\pi_j, \\pi_{j+1}) $$\n每次这样的计算都计为一次目标评估，这是每次迭代计算成本的主要衡量标准。\n\n### **3. 禁忌搜索框架**\n禁忌搜索（TS）算法是一种引导局部搜索方法以逃离局部最优的元启发式算法。实现遵循以下特定规则：\n\n-   **禁忌列表**：使用基于属性的短期记忆。当执行一个 2-opt 移动时，两条新**添加**的边被声明为禁忌。\n-   **禁忌任期 ($T_{\\text{tenure}}$)**：被放入禁忌列表的边在固定的后续迭代次数 $T_{\\text{tenure}}$ 内禁止被重新添加。如果一个移动需要添加当前在禁忌列表中的边，则该移动是禁忌的。\n-   **特赦准则**：如果执行某移动能得到一个总长度严格小于整个搜索过程中找到的最佳解（$f(\\pi_{\\text{new}})  f(\\pi^\\star)$）的新巡回，则可以无视该移动的禁忌状态。\n-   **移动选择规则**：在每次迭代中，从一组候选移动中选择最佳的“可接受”移动（即非禁忌或满足特赦准则）。如果在候选集中找不到可接受的移动，则从该集合中选择最佳移动，无论其禁忌状态如何。\n\n### **4. 候选列表策略**\n问题的核心是比较在每次迭代中生成候选移动集的两种策略：\n\n1.  **全邻域扫描**：候选集包含所有可能的 $N = \\frac{n(n-1)}{2}-1$ 个有效的 2-opt 移动。算法评估该集合中每个移动的 delta，并选择最佳的可接受移动。这是一种穷举式的局部搜索，以高昂的单次迭代计算成本（恰好 $N$ 次评估）为代价，最大限度地增加了找到好移动的机会。\n\n2.  **受限候选列表（RCL）**：候选集是全邻域的一个小子集。从所有可能的移动集合中，无放回地均匀采样恰好 $k$ 个不同的 2-opt 移动。只评估这 $k$ 个移动。该策略显著降低了单次迭代的计算成本（降至 $k$ 次评估），但它是非穷举的，有可能错过全邻域中的最佳移动。\n\n### **5. 初始化**\n为确保可复现性，搜索过程是确定性初始化的：\n-   **城市坐标**：对于给定的种子 $s$，生成 $n$ 个点，其坐标从均匀分布 $\\mathcal{U}[0,1]$ 中抽取。\n-   **初始巡回**：初始解是使用从城市 $0$ 开始的贪婪最近邻启发式算法构建的。距离上的平局通过选择索引较小的城市来打破。\n\n### **6. 算法实现与度量指标**\n实现被封装在每个测试用例的类中。该类管理问题数据生成、两次TS运行以及结果计算。\n\n-   **数据结构**：使用 `numpy` 数组存储巡回排列。使用 `字典` 作为禁忌列表，将边元组 `(u, v)` (其中 `u  v`) 映射到其禁忌到期的迭代次数。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial import distance_matrix\n\nclass TSPSolver:\n    \"\"\"\n    Implements and compares Tabu Search with full-scan and RCL strategies for TSP.\n    \"\"\"\n    def __init__(self, n, T, k, s, T_tenure):\n        self.n = n\n        self.T = T\n        self.k = k\n        self.seed = s\n        self.T_tenure = T_tenure\n\n        # Generate problem data using the specified seed\n        self.rng = np.random.default_rng(self.seed)\n        self.points = self.rng.random((self.n, 2))\n        self.dist_matrix = distance_matrix(self.points, self.points)\n        \n        # Pre-compute all valid 2-opt moves\n        self.all_moves = self._generate_all_moves()\n        self.num_all_moves = len(self.all_moves)\n\n    def _generate_all_moves(self):\n        \"\"\"Generates all valid 2-opt moves (i, j) with 0 = i  j  n, excluding (0, n-1).\"\"\"\n        moves = []\n        for i in range(self.n):\n            for j in range(i + 1, self.n):\n                if i == 0 and j == self.n - 1:\n                    continue\n                moves.append((i, j))\n        return moves\n\n    def _get_initial_tour(self):\n        \"\"\"Builds an initial tour using the nearest-neighbor heuristic from node 0.\"\"\"\n        tour = [0]\n        unvisited = set(range(1, self.n))\n        current_city = 0\n        while unvisited:\n            distances_to_unvisited = {\n                city: self.dist_matrix[current_city, city] for city in unvisited\n            }\n            min_dist_val = min(distances_to_unvisited.values())\n            candidates = [\n                city for city, dist in distances_to_unvisited.items() if dist == min_dist_val\n            ]\n            next_city = min(candidates)\n            \n            tour.append(next_city)\n            unvisited.remove(next_city)\n            current_city = next_city\n        return tour\n\n    def _calculate_tour_cost(self, tour):\n        \"\"\"Calculates the total length of a given tour.\"\"\"\n        cost = 0.0\n        for i in range(self.n):\n            cost += self.dist_matrix[tour[i], tour[(i + 1) % self.n]]\n        return cost\n\n    def _tabu_search(self, strategy):\n        \"\"\"\n        Executes the Tabu Search algorithm for a given strategy ('full' or 'rcl').\n        \"\"\"\n        # A separate RNG for sampling to ensure reproducibility based on the main seed.\n        sampling_rng = np.random.default_rng(self.seed)\n\n        # Initialization\n        initial_tour = self._get_initial_tour()\n        current_tour = np.array(initial_tour)\n        best_tour = current_tour.copy()\n        current_obj = self._calculate_tour_cost(current_tour)\n        best_obj = current_obj\n        \n        tabu_until = {}  # Maps tabu edges to the iteration they become available\n        total_evals = 0\n\n        for iter_num in range(1, self.T + 1):\n            if strategy == 'full':\n                moves_to_check_indices = range(self.num_all_moves)\n                evals_this_iter = self.num_all_moves\n            else: # rcl\n                k_effective = min(self.k, self.num_all_moves)\n                moves_to_check_indices = sampling_rng.choice(\n                    self.num_all_moves, size=k_effective, replace=False\n                )\n                evals_this_iter = k_effective\n            \n            total_evals += evals_this_iter\n            \n            best_delta_in_iter = np.inf\n            best_move_in_iter = None\n            best_admissible_delta = np.inf\n            best_admissible_move = None\n\n            for move_idx in moves_to_check_indices:\n                i, j = self.all_moves[move_idx]\n                \n                # Delta calculation (O(1))\n                p_im1_idx = i - 1\n                p_jp1_idx = (j + 1) % self.n\n                p_im1 = current_tour[p_im1_idx]\n                p_i = current_tour[i]\n                p_j = current_tour[j]\n                p_jp1 = current_tour[p_jp1_idx]\n\n                delta = (self.dist_matrix[p_im1, p_j] + self.dist_matrix[p_i, p_jp1] -\n                         self.dist_matrix[p_im1, p_i] - self.dist_matrix[p_j, p_jp1])\n\n                # Admissibility Check\n                new_obj = current_obj + delta\n                \n                # Aspiration\n                is_aspirated = new_obj  best_obj\n                \n                # Tabu check for the two edges to be added\n                edge1 = tuple(sorted((p_im1, p_j)))\n                edge2 = tuple(sorted((p_i, p_jp1)))\n                is_tabu = (tabu_until.get(edge1, 0) >= iter_num or\n                           tabu_until.get(edge2, 0) >= iter_num)\n                \n                is_admissible = (not is_tabu) or is_aspirated\n                \n                if is_admissible:\n                    if delta  best_admissible_delta:\n                        best_admissible_delta = delta\n                        best_admissible_move = (i, j)\n                \n                if delta  best_delta_in_iter:\n                    best_delta_in_iter = delta\n                    best_move_in_iter = (i, j)\n            \n            # Select move for this iteration\n            if best_admissible_move is not None:\n                move_to_apply = best_admissible_move\n                delta_to_apply = best_admissible_delta\n            else:\n                move_to_apply = best_move_in_iter\n                delta_to_apply = best_delta_in_iter\n\n            if move_to_apply is None:\n                continue\n\n            # Apply the chosen move\n            i, j = move_to_apply\n            \n            # Get cities for tabu update before reversal\n            p_im1_idx = i - 1\n            p_jp1_idx = (j + 1) % self.n\n            p_im1 = current_tour[p_im1_idx]\n            p_i = current_tour[i]\n            p_j = current_tour[j]\n            p_jp1 = current_tour[p_jp1_idx]\n\n            # Reverse the tour segment\n            current_tour[i : j + 1] = current_tour[i : j + 1][::-1]\n            current_obj += delta_to_apply\n\n            if current_obj  best_obj:\n                best_obj = current_obj\n                best_tour = current_tour.copy()\n\n            # Update tabu list with newly added edges\n            edge1 = tuple(sorted((p_im1, p_j)))\n            edge2 = tuple(sorted((p_i, p_jp1)))\n            tabu_expiry_iter = iter_num + self.T_tenure\n            tabu_until[edge1] = tabu_expiry_iter\n            tabu_until[edge2] = tabu_expiry_iter\n        \n        avg_evals = total_evals / self.T\n        return best_obj, avg_evals\n\n    def run_comparison(self):\n        \"\"\"Runs both strategies and computes the required metrics.\"\"\"\n        f_full_star, avg_evals_full = self._tabu_search(strategy='full')\n        f_rcl_star, avg_evals_rcl = self._tabu_search(strategy='rcl')\n        \n        if f_full_star == 0:\n            rel_gap = 0.0\n        else:\n            rel_gap = (f_rcl_star - f_full_star) / f_full_star\n            \n        return [avg_evals_full, avg_evals_rcl, rel_gap, f_full_star, f_rcl_star]\n\ndef solve():\n    test_cases = [\n        # (n, T, k, s, T_tenure)\n        (10, 120, 1, 42, 7),\n        (12, 150, 20, 7, 7),\n        (14, 180, 90, 123, 8),\n        (6, 80, 2, 5, 5),\n    ]\n\n    results_for_print = []\n    for case in test_cases:\n        solver = TSPSolver(*case)\n        result = solver.run_comparison()\n        \n        avg_full_str = f\"{result[0]:.2f}\"\n        avg_rcl_str = f\"{result[1]:.2f}\"\n        gap_str = f\"{result[2]:.6f}\"\n        best_full_str = f\"{result[3]:.6f}\"\n        best_rcl_str = f\"{result[4]:.6f}\"\n        \n        results_for_print.append(\n            f\"[{avg_full_str},{avg_rcl_str},{gap_str},{best_full_str},{best_rcl_str}]\"\n        )\n        \n    print(f\"[{','.join(results_for_print)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3190936"}, {"introduction": "禁忌搜索的威力远不止于解决像旅行商问题这样的路径规划难题。本练习将带你进入一个全新的应用领域——计算机科学中的寄存器分配问题。你将学习如何将一个复杂的分配问题（及其冲突约束）建模为禁忌搜索可以处理的形式，这突显了为特定问题精心设计解的表示、邻域结构和禁忌属性的极端重要性。[@problem_id:3190900]", "problem": "考虑使用禁忌搜索 (TS) 解决寄存器分配这一组合优化问题。设有 $n$ 个程序变量，索引为 $i \\in \\{1,2,\\dots,n\\}$，以及 $k$ 个机器寄存器，索引为 $r \\in \\{1,2,\\dots,k\\}$。一个分配是一个函数 $x:\\{1,\\dots,n\\}\\to \\{0,1,\\dots,k\\}$，其中 $x_i = 0$ 表示变量 $i$ 溢出到内存，而 $x_i = r$ 表示变量 $i$ 被分配给寄存器 $r$。干涉约束由一个无向图 $G=(V,E)$ 给出，其中 $V=\\{1,\\dots,n\\}$。图中的一条边 $(i,j)\\in E$ 表示变量 $i$ 和 $j$ 不能同时共享同一个寄存器。定义一个软成本模型，包括溢出变量 $i$ 的溢出成本 $s_i \\ge 0$ 和将变量 $i$ 分配给寄存器 $r$ 的寄存器分配成本 $c_{i,r} \\ge 0$。这些成本捕捉了诸如变量-寄存器绑定和偏好等属性。变量 $i$ 可能被限制在一个允许的寄存器子集 $A_i \\subseteq \\{1,\\dots,k\\}$ 内；分配给 $A_i$ 之外的寄存器是不允许的。\n\n定义需要最小化的目标函数为\n$$\nC(x) = \\sum_{i=1}^{n} \\left( \\mathbf{1}\\{x_i=0\\} \\cdot s_i + \\mathbf{1}\\{x_i\\neq 0\\} \\cdot c_{i,x_i} \\right) + M \\cdot \\sum_{(i,j)\\in E} \\mathbf{1}\\{x_i = x_j \\land x_i \\neq 0\\},\n$$\n其中 $M$ 是一个正的惩罚参数，其取值严格大于任何可达到的溢出与寄存器成本之和，以确保在存在可行分配的情况下，强烈抑制违反干涉约束的行为。\n\n实现一个确定性的禁忌搜索 (TS) 算法来最小化 $C(x)$，该算法遵循以下源自标准启发式搜索原则的基本设计：\n1. 初始化：从所有 $i$ 的分配均为 $x_i=0$ 开始。\n2. 邻域：在每次迭代中，考虑所有只改变一个分量 $x_i$ 的移动：即将 $x_i$ 设置为任何满足 $r \\neq x_i$ 的允许寄存器 $r \\in A_i$，或者在 $x_i \\neq 0$ 时将 $x_i$ 设置为 0。\n3. 移动属性与禁忌列表：当执行一个将 $x_i$ 从值 $v_{\\text{old}}$ 变为值 $v_{\\text{new}}$ 的移动时，将属性 $(i, v_{\\text{old}})$ 添加到禁忌列表中，并设置一个固定的任期 $t$。如果 $(i, v)$ 存在于禁忌列表中且剩余任期为正，则将 $x_i$ 设置为值 $v$ 的候选移动是禁忌的。\n4. 特赦准则：如果一个禁忌移动能产生比迄今为止找到的最优解还要严格更优的目标值，则允许该移动。\n5. 移动选择与平局处理：在所有可接受的移动中，选择目标值最小的一个。通过选择最小的变量索引 $i$ 来确定性地打破平局；如果仍然平局，则选择 $x_i$ 的最小目标值（溢出由0表示，小于任何寄存器索引）。\n6. 迭代与终止：使用固定的迭代预算 $I$，即使选定的邻居不会改善当前目标值，也总是移动到该邻居，并在每次迭代中更新禁忌任期。\n\n你的程序必须完全按照规定实现此 TS 算法，其中惩罚 $M$ 的选择如下\n$$\nM = \\left( \\sum_{i=1}^{n} s_i \\right) + \\left( \\sum_{i=1}^{n} \\max_{r \\in A_i} c_{i,r} \\right) + 1,\n$$\n这保证了一个单位的冲突成本比任何无冲突的溢出与寄存器成本组合都要高。\n\n使用以下实例测试套件，每个实例由 $(n,k,E,s,c,\\{A_i\\}_{i=1}^{n})$ 给出。$E$ 和 $A_i$ 中所有变量和寄存器的索引都是基于1的。算法不得生成对不允许的寄存器的分配。\n\n测试用例1（存在可行着色的理想情况）：\n- $n=5$, $k=3$。\n- $E = \\{(1,2),(1,3),(2,4),(3,4),(4,5)\\}$。\n- $s = [8,7,6,9,5]$。\n- $c = \\begin{bmatrix}\n0  4  2\\\\\n3  0  5\\\\\n6  2  0\\\\\n0  2  4\\\\\n3  1  0\n\\end{bmatrix}$。\n- $A_1 = \\{1,2,3\\}$, $A_2 = \\{1,2,3\\}$, $A_3 = \\{1,2,3\\}$, $A_4 = \\{1,2,3\\}$, $A_5 = \\{1,2,3\\}$。\n\n测试用例2（$k=1$ 且链式干涉的边界情况）：\n- $n=4$, $k=1$。\n- $E = \\{(1,2),(2,3),(3,4)\\}$。\n- $s = [5,5,5,5]$。\n- $c = \\begin{bmatrix}\n0\\\\\n0\\\\\n0\\\\\n0\n\\end{bmatrix}$。\n- $A_1 = \\{1\\}$, $A_2 = \\{1\\}$, $A_3 = \\{1\\}$, $A_4 = \\{1\\}$。\n\n测试用例3（存在允许寄存器限制和导致无溢出时冲突不可避免的交叉边）：\n- $n=6$, $k=2$。\n- $E = \\{(1,2),(2,3),(1,3),(4,5),(5,6),(4,6),(3,4)\\}$。\n- $s = [9,4,9,4,8,3]$。\n- $c = \\begin{bmatrix}\n0  999\\\\\n1  0\\\\\n999  0\\\\\n999  0\\\\\n2  0\\\\\n0  999\n\\end{bmatrix}$。\n- $A_1 = \\{1\\}$, $A_2 = \\{1,2\\}$, $A_3 = \\{2\\}$, $A_4 = \\{2\\}$, $A_5 = \\{1,2\\}$, $A_6 = \\{1\\}$。\n\n测试用例4（无干涉；分配到最便宜的允许寄存器）：\n- $n=4$, $k=2$。\n- $E = \\emptyset$。\n- $s = [10,10,10,10]$。\n- $c = \\begin{bmatrix}\n1  5\\\\\n0  2\\\\\n3  0\\\\\n2  2\n\\end{bmatrix}$。\n- $A_1 = \\{1,2\\}$, $A_2 = \\{1,2\\}$, $A_3 = \\{1,2\\}$, $A_4 = \\{1,2\\}$。\n\n测试用例5（所有变量仅允许一个寄存器；链式干涉强制要求溢出）：\n- $n=3$, $k=2$。\n- $E = \\{(1,2),(2,3)\\}$。\n- $s = [3,3,3]$。\n- $c = \\begin{bmatrix}\n1  999\\\\\n0  999\\\\\n2  999\n\\end{bmatrix}$。\n- $A_1 = \\{1\\}$, $A_2 = \\{1\\}$, $A_3 = \\{1\\}$。\n\n实现细节：\n- 使用固定的禁忌任期 $t=7$ 和固定的迭代预算 $I=200$。\n- 在数学描述中使用基于1的寄存器索引，但根据需要在内部实现中使用基于0的数组。\n- 通过指定的平局处理规则并避免任何随机性来确保确定性。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，即 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_j$ 是 TS 算法在第 $j$ 个测试用例上找到的最小目标值。此问题不涉及物理单位或角度；所有值都是根据定义的成本和惩罚得出的无量纲整数。输出必须完全符合指定格式。", "solution": "用户提供了一个定义明确的组合优化问题，即寄存器分配问题，并要求使用一个确定性指定的禁忌搜索 (TS) 算法来解决。\n\n### 步骤 1：问题验证\n\n第一步是验证问题陈述。\n\n#### 提取的已知条件：\n- **问题**：最小化寄存器分配的成本函数。\n- **实体**：$n$ 个变量， $k$ 个寄存器。\n- **分配**：$x_i \\in \\{0, 1, \\dots, k\\}$，其中 $x_i=0$ 是内存溢出。\n- **目标函数**：$C(x) = \\sum_{i=1}^{n} \\left( \\mathbf{1}\\{x_i=0\\} \\cdot s_i + \\mathbf{1}\\{x_i\\neq 0\\} \\cdot c_{i,x_i} \\right) + M \\cdot \\sum_{(i,j)\\in E} \\mathbf{1}\\{x_i = x_j \\land x_i \\neq 0\\}$。\n- **惩罚参数**：$M = \\left( \\sum_{i=1}^{n} s_i \\right) + \\left( \\sum_{i=1}^{n} \\max_{r \\in A_i} c_{i,r} \\right) + 1$。\n- **硬约束**：变量 $i$ 只能分配给给定集合 $A_i$ 中的寄存器。\n- **算法**：确定性禁忌搜索，具体规定如下：\n    1.  **初始化**：所有变量都溢出，即对所有 $i$ 都有 $x_i=0$。\n    2.  **邻域**：移动包括将单个变量 $i$ 的分配 $x_i$ 更改为另一个允许的值（$A_i$ 中的另一个寄存器或溢出到内存，由 $0$ 表示）。\n    3.  **禁忌机制**：当将 $x_i$ 从 $v_{\\text{old}}$ 移动到 $v_{\\text{new}}$ 时，属性 $(i, v_{\\text{old}})$ 被添加到禁忌列表中，任期为 $t$。如果 $(i, v)$ 在列表中，则后续将 $x_i$ 设置为值 $v$ 的移动是禁忌的。这可以防止变量的分配被立即撤销。\n    4.  **特赦准则**：如果禁忌移动能产生一个成本严格低于搜索至今找到的最佳成本的解，则该移动被允许。\n    5.  **移动选择与平局处理**：选择最佳的可接受移动（非禁忌或满足特赦准则）。通过优先选择涉及最小变量索引 $i$ 的移动，然后是最小的新分配值 $v_{\\text{new}}$（其中 $0$ 最小）来打破平局。\n    6.  **终止**：搜索运行固定的迭代次数 $I$。\n- **参数**：禁忌任期 $t=7$，迭代预算 $I=200$。\n- **数据**：提供了五个不同的测试用例，包含所有必要的参数 ($n, k, E, s, c, \\{A_i\\}$)。\n\n#### 验证结论：\n问题是**有效的**。\n- 它在组合优化和编译器设计这一成熟领域具有**科学依据**。\n- 它是**良构的**，所有参数、规则和初始条件都已指定，确保了确定性和唯一的结果。\n- 它是**客观的**，使用精确的数学语言，避免了任何主观性。\n- 结构完整且无矛盾。为惩罚 $M$ 提供的公式是合理的，并达到了其预期目的，即对违反约束的惩罚要重于任何可能的有效分配成本。\n\n### 步骤 2：算法解决方案\n基于已验证的问题，设计了指定禁忌搜索算法的 Python 实现。对于每个测试用例，逻辑如下。\n\n1.  **数据准备**：加载当前测试用例的参数（$n, k, E, s, c, A$）。将问题描述中基于1的索引转换为基于0的索引，以便在 Python 数组和列表中使用（例如，变量 $0$ 到 $n-1$，引用这些索引的边）。为高效查找冲突变量，构建了干涉图 $G=(V,E)$ 的邻接表表示。\n\n2.  **惩罚计算**：根据给定公式精确计算惩罚参数 $M$。该值确保任何即使只有一个寄存器冲突的解的成本也高于任何无冲突解的成本。\n\n3.  **初始化**：搜索从初始分配 $x$ 开始，其中所有变量都溢出（对于所有 $i=0, \\dots, n-1$，有 $x_i=0$）。计算此初始解的成本 $C(x_{\\text{initial}})$。此解及其成本被设为初始的迄今为止最优解 $x_{\\text{best}}$ 和最优成本 $C_{\\text{best}}$。一个实现为二维数组 `tabu_list[n][k+1]` 的禁忌列表被初始化为全零。`tabu_list[i][v]` 将存储将值 $v$ 分配给变量 $i$ 的禁忌剩余任期。\n\n4.  **迭代搜索**：主循环执行固定的迭代次数 $I=200$。在每次迭代中：\n    a.  **禁忌任期更新**：`tabu_list` 中所有正数条目减1。这模拟了时间的推移和禁忌状态的最终到期。\n    b.  **邻域探索**：算法系统地探索当前解 $x$ 的邻域。对于每个变量 $i \\in \\{0, \\dots, n-1\\}$，它考虑所有移动到新值 $v_{\\text{new}} \\in (A_i \\cup \\{0\\}) \\setminus \\{x_i\\}$ 的可能。为了实施确定性的平局打破规则，此探索按变量索引 $i$ 排序，然后按新值 $v_{\\text{new}}$ 排序。\n    c.  **移动评估**：对于每个潜在的移动，计算所得邻居解的成本。为优化性能，这是增量地完成的。成本变化 ($\\Delta C$) 的计算仅考虑变量 $i$ 的基础成本变化以及涉及变量 $i$ 及其在干涉图中邻居的冲突成本变化。邻居的成本则为 $C(x') = C(x) + \\Delta C$。\n    d.  **可接受性检查**：检查每个移动的可接受性。将 $x_i$ 设置为 $v_{\\text{new}}$ 的移动是可接受的，如果：\n        i.  它不是禁忌的（即 `tabu_list[i][v_new] == 0`）。\n        ii. 它是禁忌的但满足特赦准则（即，产生的成本 $C(x')$ 严格小于 $C_{\\text{best}}$）。\n    e.  **最佳移动选择**：算法跟踪当前迭代邻域扫描中迄今找到的最佳可接受移动。选择导致成本最低的移动，并通过预定义的评估顺序确定性地打破平局。\n    f.  **状态转移**：如果找到了一个可接受的移动，则通过应用最佳移动来更新当前解 $x$。成本 $C(x)$ 也被更新。通过为*逆向*移动设置任期来修改 `tabu_list`。具体来说，如果 $x_i$ 从 $v_{\\text{old}}$ 变为 $v_{\\text{new}}$，则将 `tabu_list[i][v_old]` 设置为禁忌任期 $t=7$。\n    g.  **最优解更新**：如果新的当前解 $x$ 的成本低于 $C_{\\text{best}}$，则更新 $x_{\\text{best}}$ 和 $C_{\\text{best}}$。\n\n5.  **结果收集**：在 $I$ 次迭代后，存储当前测试用例的最终 $C_{\\text{best}}$ 值。对所有测试用例重复此过程。\n\n6.  **最终输出**：将从所有测试用例中收集到的最小成本格式化为单个用方括号括起来的逗号分隔字符串，以符合要求。\n\n这一详细的、确定性的过程在最终答案中提供的 Python 代码中实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified deterministic Tabu Search algorithm for the register allocation problem.\n\n    The solution follows the problem's strict definition of the Tabu Search metaheuristic,\n    including initialization, neighborhood structure, tabu tenure, aspiration criterion,\n    deterministic tie-breaking, and termination condition.\n    \"\"\"\n    \n    test_suite = [\n        {\n            \"n\": 5, \"k\": 3, \"E\": [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)],\n            \"s\": [8, 7, 6, 9, 5],\n            \"c\": [[0, 4, 2], [3, 0, 5], [6, 2, 0], [0, 2, 4], [3, 1, 0]],\n            \"A\": [[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]\n        },\n        {\n            \"n\": 4, \"k\": 1, \"E\": [(1, 2), (2, 3), (3, 4)],\n            \"s\": [5, 5, 5, 5],\n            \"c\": [[0], [0], [0], [0]],\n            \"A\": [[1], [1], [1], [1]]\n        },\n        {\n            \"n\": 6, \"k\": 2, \"E\": [(1, 2), (2, 3), (1, 3), (4, 5), (5, 6), (4, 6), (3, 4)],\n            \"s\": [9, 4, 9, 4, 8, 3],\n            \"c\": [[0, 999], [1, 0], [999, 0], [999, 0], [2, 0], [0, 999]],\n            \"A\": [[1], [1, 2], [2], [2], [1, 2], [1]]\n        },\n        {\n            \"n\": 4, \"k\": 2, \"E\": [],\n            \"s\": [10, 10, 10, 10],\n            \"c\": [[1, 5], [0, 2], [3, 0], [2, 2]],\n            \"A\": [[1, 2], [1, 2], [1, 2], [1, 2]]\n        },\n        {\n            \"n\": 3, \"k\": 2, \"E\": [(1, 2), (2, 3)],\n            \"s\": [3, 3, 3],\n            \"c\": [[1, 999], [0, 999], [2, 999]],\n            \"A\": [[1], [1], [1]]\n        }\n    ]\n\n    I = 200  # Iteration budget\n    t = 7    # Tabu tenure\n\n    final_results = []\n\n    for case_data in test_suite:\n        n = case_data[\"n\"]\n        k = case_data[\"k\"]\n        s = np.array(case_data[\"s\"])\n        c = np.array(case_data[\"c\"])\n        E_0based = [(u - 1, v - 1) for u, v in case_data[\"E\"]]\n        A = case_data[\"A\"]\n\n        adj = [[] for _ in range(n)]\n        for u, v in E_0based:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        sum_s = np.sum(s)\n        sum_max_c = 0\n        for i in range(n):\n            if not A[i]:\n                max_c_i = 0\n            else:\n                max_c_i = max(c[i][r - 1] for r in A[i])\n            sum_max_c += max_c_i\n        M = sum_s + sum_max_c + 1\n\n        def calculate_full_cost(assignment):\n            cost = 0\n            for i in range(n):\n                if assignment[i] == 0:\n                    cost += s[i]\n                else:\n                    cost += c[i][assignment[i] - 1]\n            for u, v in E_0based:\n                if assignment[u] != 0 and assignment[u] == assignment[v]:\n                    cost += M\n            return cost\n\n        x = np.zeros(n, dtype=int)\n        current_cost = calculate_full_cost(x)\n        \n        best_x = np.copy(x)\n        best_cost = current_cost\n        \n        tabu_list = np.zeros((n, k + 1), dtype=int)\n\n        for _ in range(I):\n            tabu_list[tabu_list > 0] -= 1\n\n            best_move = None\n            best_move_cost = float('inf')\n\n            for i in range(n):\n                v_old = x[i]\n                \n                allowed_vals = set(A[i])\n                allowed_vals.add(0)\n                move_options = sorted([val for val in allowed_vals if val != v_old])\n\n                for v_new in move_options:\n                    old_base_cost_i = s[i] if v_old == 0 else c[i][v_old - 1]\n                    new_base_cost_i = s[i] if v_new == 0 else c[i][v_new - 1]\n                    delta_base = new_base_cost_i - old_base_cost_i\n                    \n                    delta_conflict = 0\n                    for j in adj[i]:\n                        if v_old != 0 and v_old == x[j]:\n                            delta_conflict -= M\n                        if v_new != 0 and v_new == x[j]:\n                            delta_conflict += M\n                    \n                    move_cost = current_cost + delta_base + delta_conflict\n                    \n                    is_tabu = tabu_list[i][v_new] > 0\n                    aspirated = move_cost  best_cost\n                    \n                    if (not is_tabu) or aspirated:\n                        if move_cost  best_move_cost:\n                            best_move_cost = move_cost\n                            best_move = (i, v_new)\n            \n            if best_move is None:\n                break\n                \n            i_move, v_new_move = best_move\n            v_old_move = x[i_move]\n            \n            x[i_move] = v_new_move\n            current_cost = best_move_cost\n            \n            tabu_list[i_move][v_old_move] = t\n            \n            if current_cost  best_cost:\n                best_cost = current_cost\n                best_x = np.copy(x)\n        \n        final_results.append(best_cost)\n    \n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3190900"}]}