{"hands_on_practices": [{"introduction": "将理论付诸实践是掌握任何科学概念的关键。我们首先从一个经典的应用场景入手：如何用最少的成本部署传感器来覆盖所有关键区域。解决这类优化问题的第一步，也是最关键的一步，是将其转化为精确的数学语言。这个练习 [@problem_id:3130513] 将指导你把一个实际问题构建成一个混合整数规划（MIP）模型，并探索如何通过线性规划（LP）松弛和添加有效不等式来加强模型，这是求解大规模整数规划问题的核心思想。", "problem": "一个城市必须部署一组成本最低的环境传感器，以确保每个关键地点至少被一个传感器覆盖。放置在候选位置的传感器会覆盖其感应半径内的地点子集。使用以下实例，将此决策问题表述为一个集合覆盖问题。现有3个地点，索引为 $i \\in \\{1,2,3\\}$，以及3个候选传感器位置，索引为 $j \\in \\{a,b,c\\}$。地点覆盖集合如下：\n- 传感器 $a$ 覆盖地点 $\\{1,2\\}$，\n- 传感器 $b$ 覆盖地点 $\\{2,3\\}$，\n- 传感器 $c$ 覆盖地点 $\\{1,3\\}$。\n所有传感器的成本均为单位成本，因此 $c_a = c_b = c_c = 1$。定义一个二进制决策变量 $x_j$，表示是否在候选位置 $j$ 放置传感器。\n\n从集合覆盖问题的形式化定义和混合整数规划（MIP）的标准元素出发，完成以下任务：\n\n1. 为此实例编写一个完整的MIP模型，以最小化总成本并满足覆盖约束。模型应包括变量、目标函数和约束的精确定义。使用二进制变量 $x_j \\in \\{0,1\\}$。\n\n2. 通过将整数约束替换为连续边界，提出一个线性规划（LP）松弛。然后，使用基于地点子集的容量论证，推导出一个加强有效不等式。陈述该不等式的一般形式，然后针对给定实例进行实例化，以获得一个关于 $x_a$、$x_b$ 和 $x_c$ 的具体不等式。\n\n3. 使用LP松弛以及您推导出的有效不等式，计算此实例的加强LP的最优目标值。将您的最终数值答案四舍五入到四位有效数字。", "solution": "用户要求我解决一个多部分的优化问题。\n\n**第一部分：MIP 公式化**\n首先验证问题，以确保其科学性、适定性和客观性。\n\n**步骤1：提取已知条件**\n-   需要覆盖的关键地点集合为 $S = \\{1, 2, 3\\}$。\n-   候选传感器位置集合为 $U = \\{a, b, c\\}$。\n-   传感器的覆盖集合为：\n    -   传感器 $a$ 覆盖地点 $S_a = \\{1, 2\\}$。\n    -   传感器 $b$ 覆盖地点 $S_b = \\{2, 3\\}$。\n    -   传感器 $c$ 覆盖地点 $S_c = \\{1, 3\\}$。\n-   每个传感器的成本是单位成本：$c_a = c_b = c_c = 1$。\n-   决策变量是二进制的：对于每个 $j \\in U$，有 $x_j \\in \\{0, 1\\}$，其中如果传感器放置在位置 $j$，则 $x_j = 1$，否则 $x_j = 0$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题是集合覆盖问题的一个经典实例，这是组合优化和计算机科学中的一个基本课题。\n-   **科学性**：该问题基于整数规划的既定数学原理。传感器放置的情景是这些原理的标准应用。\n-   **适定性**：问题定义清晰，有明确的目标（最小化成本）和一套完整的约束（覆盖所有地点）。存在有意义的最优解。\n-   **客观性**：问题使用精确、无歧义的数学术语进行陈述。\n\n**步骤3：结论与行动**\n问题是有效的。我将继续进行解答。\n\n解决方案按用户要求分为三个部分呈现。\n\n**1. 完整的MIP模型**\n\n目标是建立一个混合整数规划（MIP）模型。这需要定义决策变量、目标函数和约束条件。\n\n**决策变量：**\n正如问题中所定义的，我们为每个候选传感器位置 $j \\in \\{a, b, c\\}$ 使用二进制决策变量 $x_j$。\n$x_j = \\begin{cases} 1 & \\text{如果在位置 } j \\text{ 放置传感器} \\\\ 0 & \\text{否则} \\end{cases}$\n因此，变量为 $x_a$、$x_b$ 和 $x_c$，并且它们被限制在 $\\{0, 1\\}$ 中。\n\n**目标函数：**\n目标是最小化部署传感器的总成本。总成本是所选传感器成本的总和。\n成本函数为：\n$$ \\text{最小化 } \\sum_{j \\in \\{a,b,c\\}} c_j x_j $$\n鉴于 $c_a = c_b = c_c = 1$，目标函数简化为：\n$$ \\text{最小化 } Z = x_a + x_b + x_c $$\n\n**约束条件：**\n核心要求是每个关键地点必须至少被一个传感器覆盖。这转化为一组约束，每个地点一个。如果覆盖地点 $i$ 的传感器的决策变量之和至少为 $1$，则地点 $i$ 被覆盖。\n\n-   **地点1的约束：** 地点1被传感器 $a$ 和 $c$ 覆盖。因此，必须至少部署其中一个。\n    $$ x_a + x_c \\ge 1 $$\n-   **地点2的约束：** 地点2被传感器 $a$ 和 $b$ 覆盖。\n    $$ x_a + x_b \\ge 1 $$\n-   **地点3的约束：** 地点3被传感器 $b$ 和 $c$ 覆盖。\n    $$ x_b + x_c \\ge 1 $$\n\n**完整的MIP模型：**\n此集合覆盖实例的完整MIP模型是：\n$$ \\begin{aligned} \\text{最小化 } \\quad & Z = x_a + x_b + x_c \\\\ \\text{满足 } \\quad & x_a + x_c \\ge 1 \\\\ & x_a + x_b \\ge 1 \\\\ & x_b + x_c \\ge 1 \\\\ & x_a, x_b, x_c \\in \\{0, 1\\} \\end{aligned} $$\n\n**2. LP松弛和加强有效不等式**\n\n**线性规划（LP）松弛：**\nLP松弛是通过放宽决策变量的整数约束得到的，即将 $x_j \\in \\{0, 1\\}$ 替换为 $0 \\le x_j \\le 1$。\n\nLP松弛为：\n$$ \\begin{aligned} \\text{最小化 } \\quad & Z_{LP} = x_a + x_b + x_c \\\\ \\text{满足 } \\quad & x_a + x_c \\ge 1 \\\\ & x_a + x_b \\ge 1 \\\\ & x_b + x_c \\ge 1 \\\\ & 0 \\le x_a, x_b, x_c \\le 1 \\end{aligned} $$\n通过观察可知，该LP的一个可行最优解是 $x_a = x_b = x_c = 0.5$，其目标值为 $Z_{LP} = 0.5 + 0.5 + 0.5 = 1.5$。这个解是分数的，因此不是原始MIP的有效解。\n\n**加强有效不等式：**\n有效不等式是指所有整数可行解都满足的不等式。加强有效不等式是能切掉LP松弛的某些分数解的不等式。我们可以利用基于地点子集的容量论证来推导这样的不等式。\n\n这种不等式的一般形式是通过考虑地点的一个子集 $I \\subseteq S$ 推导出来的。对于每个地点 $i \\in I$，约束 $\\sum_{j: i \\in S_j} x_j \\ge 1$ 必须成立。将这些不等式对所有 $i \\in I$ 求和，得到：\n$$ \\sum_{i \\in I} \\left( \\sum_{j: i \\in S_j} x_j \\right) \\ge \\sum_{i \\in I} 1 = |I| $$\n改变求和顺序，我们得到：\n$$ \\sum_{j \\in U} \\left( \\sum_{i \\in I \\cap S_j} 1 \\right) x_j \\ge |I| $$\n这就提供了一般形式的不等式：\n$$ \\sum_{j \\in U} |S_j \\cap I| x_j \\ge |I| $$\n\n对于给定的实例，我们选择所有地点作为子集，即 $I = \\{1, 2, 3\\}$。我们有 $|I|=3$。我们计算每个传感器覆盖集与 $I$ 的交集的大小：\n-   $|S_a \\cap I| = |\\{1, 2\\} \\cap \\{1, 2, 3\\}| = 2$\n-   $|S_b \\cap I| = |\\{2, 3\\} \\cap \\{1, 2, 3\\}| = 2$\n-   $|S_c \\cap I| = |\\{1, 3\\} \\cap \\{1, 2, 3\\}| = 2$\n\n将这些值代入一般形式，得到具体的不等式实例：\n$$ 2x_a + 2x_b + 2x_c \\ge 3 $$\n这可以简化为：\n$$ x_a + x_b + x_c \\ge 1.5 $$\n这个不等式对于LP松弛是有效的。对于原始MIP，左侧 $X = x_a + x_b + x_c$ 必须是整数，因为每个 $x_j$ 都是整数。因此，对于任何整数解，$X \\ge 1.5$ 意味着 $X \\ge \\lceil 1.5 \\rceil = 2$。\n\n由此得到的MIP的加强有效不等式是：\n$$ x_a + x_b + x_c \\ge 2 $$\n这个不等式被LP最优解 $x_a = x_b = x_c = 0.5$ 所违反，因为 $0.5 + 0.5 + 0.5 = 1.5  2$。因此，它是一个加强割。\n\n**3. 加强LP的最优目标值**\n\n我们将推导出的有效不等式添加到LP松弛中，形成一个加强LP：\n$$ \\begin{aligned} \\text{最小化 } \\quad  Z_{SLP} = x_a + x_b + x_c \\\\ \\text{满足 } \\quad  x_a + x_c \\ge 1 \\\\  x_a + x_b \\ge 1 \\\\  x_b + x_c \\ge 1 \\\\  x_a + x_b + x_c \\ge 2 \\\\  0 \\le x_a, x_b, x_c \\le 1 \\end{aligned} $$\n目标函数是最小化 $Z_{SLP} = x_a + x_b + x_c$。第四个约束 $x_a + x_b + x_c \\ge 2$ 直接给出了目标值的下界：$Z_{SLP} \\ge 2$。\n\n为了确定是否可以达到这个下界，我们需要找到是否存在一个可行解 $(x_a, x_b, x_c)$，它满足所有约束并达到目标值 $2$。让我们测试在平面 $x_a + x_b + x_c = 2$ 上是否存在一个可行点。\n\n考虑点 $(x_a, x_b, x_c) = (1, 1, 0)$。\n目标值为 $1 + 1 + 0 = 2$。\n现在，我们通过验证所有约束来检查该点是否可行：\n1.  $x_a + x_c = 1 + 0 = 1 \\ge 1$ (满足)\n2.  $x_a + x_b = 1 + 1 = 2 \\ge 1$ (满足)\n3.  $x_b + x_c = 1 + 0 = 1 \\ge 1$ (满足)\n4.  $x_a + x_b + x_c = 1 + 1 + 0 = 2 \\ge 2$ (满足)\n5.  $0 \\le 1 \\le 1$, $0 \\le 1 \\le 1$, $0 \\le 0 \\le 1$ (全部满足)\n\n由于点 $(1, 1, 0)$ 是可行的，且其目标值 $2$ 与目标函数的下界相匹配，因此它是一个最优解。因此，加强LP的最优目标值为 $2$。\n通过对称性，点 $(1, 0, 1)$ 和 $(0, 1, 1)$ 也是最优解，产生相同的目标值。\n\n加强LP的最优目标值恰好是 $2$。表示为四位有效数字，即为 $2.000$。", "answer": "$$\n\\boxed{2.000}\n$$", "id": "3130513"}, {"introduction": "建立了数学模型后，我们自然会问：如何找到最优解？虽然集合覆盖问题是NP-难的，但当问题中的元素总数（即全集的大小 $N$）较小时，我们可以通过动态规划（DP）来高效地求得精确解。这个练习 [@problem_id:3203736] 将让你亲手实现一个基于“位掩码”（bitmask）的动态规划算法。这不仅是一次宝贵的编程实践，更能让你深刻体会到组合优化问题的内在复杂性，并理解为何在更大规模的问题上我们常常需要依赖近似算法。", "problem": "您需要实现一个程序，通过应用基于子集的动态规划来解决小型有限全集上的最小集合覆盖问题实例。最小集合覆盖问题的定义如下：给定一个有限元素全集和一组子集，任务是选择最少数量的子集，使其并集包含全集中的所有元素。其基本原理是关于集合的组合优化问题的定义，以及将一个优化问题分解为具有最优子结构的重叠子问题的动态规划原理，同时结合使用位掩码对子集进行规范的有限表示。程序必须使用一种表示方法，其中全集的每个子集都被编码为一个整数位掩码，并且必须使用一个动态规划数组，其中状态变量定义为 $dp[\\text{mask}]$，它存储了用于覆盖 $\\text{mask}$ 中所有索引位为1的元素的最小集合数量（允许覆盖超出 $\\text{mask}$ 范围的额外元素）。如果对于一个给定的实例，由于所有可用集合的并集不包含全集中的所有元素而无法覆盖整个全集，则程序必须为该实例返回 $-1$。\n\n每个实例的全集是整数集合 $\\{0,1,\\dots,N-1\\}$，其中 $N \\le 20$。子集以元素索引列表的形式给出。您的算法必须从基本原理出发进行设计：将子集表示为位掩码，如前所述定义状态 $dp[\\text{mask}]$，并通过考虑将每个可用集合添加至任何已覆盖子集的效果，利用最优子结构原理在状态间传播改进。\n\n程序必须为以下每个测试实例计算最小集合数。在所有情况下，全集为 $\\{0,1,\\dots,N-1\\}$，且集合已明确给出：\n\n- 测试 $1$：$N=7$，集合：\n  - $S_1=\\{0,1,2\\}$\n  - $S_2=\\{2,3\\}$\n  - $S_3=\\{3,4,5\\}$\n  - $S_4=\\{5,6\\}$\n  - $S_5=\\{0,4,6\\}$\n  - $S_6=\\{1,5\\}$\n  - $S_7=\\{0,3,6\\}$\n\n- 测试 $2$：$N=0$，集合：无（全集为空）。\n\n- 测试 $3$：$N=5$，集合：\n  - $S_1=\\{0,1\\}$\n  - $S_2=\\{1,2\\}$\n  - $S_3=\\{2,3\\}$\n  - $S_4=\\{0,3\\}$\n  在此实例中，元素 $4$ 未出现在任何集合中。\n\n- 测试 $4$：$N=20$，集合：\n  - $S_1=\\{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19\\}$\n  - $S_2=\\{0,2,4,6,8,10,12,14,16,18\\}$\n\n- 测试 $5$：$N=10$，集合：\n  - $S_1=\\{0,1,2,3,4\\}$\n  - $S_2=\\{5,6,7,8,9\\}$\n  - $S_3=\\{0,5,6\\}$\n  - $S_4=\\{1,7,8\\}$\n  - $S_5=\\{2,9\\}$\n  - $S_6=\\{3,4\\}$\n\n- 测试 $6$：$N=6$，集合：\n  - $S_1=\\{0,1,2\\}$\n  - $S_2=\\{0,1,2\\}$（与 $S_1$ 重复）\n  - $S_3=\\{3,4,5\\}$\n\n对于每个测试，要求的答案是覆盖全集 $\\{0,1,\\dots,N-1\\}$ 中所有元素所需的最小集合数，如果不存在覆盖则为 $-1$。最终输出格式必须为单行，包含所有测试的结果，按顺序排列，形式为逗号分隔的列表并用方括号括起来，例如 $[a_1,a_2,\\dots,a_k]$，其中每个 $a_i$ 是对应于第 $i$ 个测试实例的整数。此问题不涉及物理单位、角度或百分比；答案是指定的纯整数。", "solution": "在小型有限全集上的最小集合覆盖问题可以通过基于子集的动态规划来解决，利用了问题固有的最优子结构和重叠子问题特性。其基本原理包括：集合覆盖组合优化问题的定义、动态规划原理以及通过位掩码表示集合。\n\n我们考虑一个大小为 $N$ 的全集 $\\mathcal{U}$，具体为 $\\mathcal{U}=\\{0,1,\\dots,N-1\\}$，其中 $N \\le 20$。每个可用的子集 $S_i \\subseteq \\mathcal{U}$ 表示为一个位掩码 $b_i$，其中 $b_i$ 的第 $j$ 位为 $1$ 当且仅当 $j \\in S_i$。位掩码 $\\text{mask}$ 是一个表示 $\\mathcal{U}$ 的子集的整数：其所覆盖的元素集合为 $\\{j \\mid \\text{mask} \\text{ 的第 } j \\text{ 位为1}\\}$。\n\n我们为每个 $\\text{mask} \\in \\{0,1,\\dots,2^N-1\\}$ 定义一个状态变量 $dp[\\text{mask}]$，解释为所选集合的并集覆盖了 $\\text{mask}$ 所指示的所有元素的最小集合数（允许覆盖超出 $\\text{mask}$ 范围的元素）。动态规划原理之所以适用，是因为覆盖一个较大的元素集合可以通过扩展一个较小集合的覆盖范围来构建，且覆盖一个给定子集的最优方式是由覆盖其子子集的最优方式加上一个额外集合构成的。基准情况是 $dp[0]=0$，因为覆盖空集需要零个集合。所有其他状态都可以初始化为一个表示“尚未到达”的哨兵值（例如，在分析中使用 $+\\infty$，在代码中则使用一个足够大的整数实现）。\n\n算法按如下方式传播改进。对于任何具有有限值 $dp[\\text{mask}]$ 的状态 $\\text{mask}$，以及对于任何子集位掩码 $b_i$，我们可以转换到一个新状态 $\\text{mask}' = \\text{mask} \\lor b_i$，其中 $\\lor$ 表示按位或运算符，意味着 $\\text{mask}'$ 代表当前已覆盖元素与 $S_i$ 中元素的并集。根据最优子结构原理，增加一个集合会使计数加 1，因此如果候选值 $dp[\\text{mask}] + 1$ 能改进当前已知值，我们就可以用它来更新 $dp[\\text{mask}']$。这个遍历所有状态和所有集合的迭代过程确保了我们探索所有已选集合的组合，同时通过 $dp$ 体现的记忆化避免了冗余计算。\n\n代表完全覆盖的终止状态是 $\\text{full} = 2^N - 1$，对应于第 $0$ 位到第 $N-1$位都已设置的位掩码。如果处理后 $dp[\\text{full}]$ 仍为哨兵值，则说明无法实现完全覆盖，因为所有可用集合的并集不包含全集中的每个元素；在这种情况下，我们输出 $-1$。否则，$dp[\\text{full}]$ 就是所需的最小集合数。\n\n其正确性可以通过对集合添加次数的归纳法来证明。基准情况 $dp[0]=0$ 是正确的。假设对于所有汉明权重（即置位位数）小于 $k$ 的掩码 $\\text{mask}$，$dp[\\text{mask}]$ 都正确地表示了覆盖 $\\text{mask}$ 中元素所需的最小集合数。对于任何权重为 $k$ 的掩碼，其最优覆盖必然是通过将一个集合添加至某个子集的最优覆盖而得到的（如果添加的集合贡献的元素都已被覆盖，则可能是同一个掩码，但这种情况下成本不会改善，将被忽略）。状态转移 $\\text{mask}' = \\text{mask} \\lor b_i$ 捕捉了集合的并集操作，而用 $dp[\\text{mask}] + 1$ 更新 $dp[\\text{mask}']$ 则体现了添加一个集合的成本。由于我们检查了所有掩码的所有集合并记录了最小成本，该算法能够得到覆盖整个全集的掩码的真正最小值。\n\n计算复杂度为 $O(M \\cdot 2^N)$，其中 $M$ 是该实例中可用集合的数量。由于 $N \\le 20$ 意味着 $2^N \\le 1{,}048{,}576$，因此这是可行的。动态规划数组的内存使用量为 $O(2^N)$。\n\n我们将此方法应用于所提供的测试实例：\n\n- 测试 $1$ ($N=7$)：算法探索各种组合；一个最优覆盖是 $S_1 \\cup S_3 \\cup S_4$，用 $3$ 个集合覆盖了 $\\{0,1,2,3,4,5,6\\}$。任意两个集合都不足以覆盖，因此最小值为 $3$。\n\n- 测试 $2$ ($N=0$)：全集为空，因此 $dp[0]=0$，答案是 $0$。\n\n- 测试 $3$ ($N=5$)：元素 $4$ 在所有集合中均缺失，因此可用集合的并集无法覆盖整个全集；答案是 $-1$。\n\n- 测试 $4$ ($N=20$)：$S_1$ 单独覆盖了 $\\{0,1,\\dots,19\\}$，因此最小值为 $1$。\n\n- 测试 $5$ ($N=10$)：选择 $S_1$ 和 $S_2$ 可以覆盖所有元素 $\\{0,1,\\dots,9\\}$；没有任何单个集合能覆盖所有元素，因此最小值为 $2$。\n\n- 测试 $6$ ($N=6$)：尽管 $S_1$ 有一个重复项，我们仍需要 $2$ 个集合（$S_1$ 或其重复项加上 $S_3$）来覆盖所有元素 $\\{0,1,2,3,4,5\\}$；最小值为 $2$。\n\n程序计算这些结果，并以指定的单行格式打印它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef min_set_cover(n, sets):\n    \"\"\"\n    Compute the minimum number of sets to cover the universe {0,1,...,n-1}.\n    If impossible, return -1.\n    \"\"\"\n    # Convert sets to bitmasks\n    set_masks = []\n    union_mask = 0\n    for s in sets:\n        mask = 0\n        for x in s:\n            if x  0 or x >= n:\n                # Ignore out-of-range elements silently; problem design ensures validity.\n                continue\n            mask |= 1  x\n        set_masks.append(mask)\n        union_mask |= mask\n\n    if n == 0:\n        return 0\n\n    full_mask = (1  n) - 1\n    if (union_mask  full_mask) != full_mask:\n        # Not all elements are coverable\n        return -1\n\n    # DP over masks: dp[mask] = minimum sets to cover all bits in mask (allow over-covering)\n    INF = n + 1  # upper bound: cannot need more than n sets if each contributes at least one new element\n    dp = [INF] * (full_mask + 1)\n    dp[0] = 0\n\n    # Iterate over all masks and try adding each set\n    for mask in range(full_mask + 1):\n        curr = dp[mask]\n        if curr == INF:\n            continue\n        for s in set_masks:\n            new_mask = mask | s\n            if dp[new_mask] > curr + 1:\n                dp[new_mask] = curr + 1\n\n    ans = dp[full_mask]\n    return ans if ans != INF else -1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple (N, list_of_sets_as_lists)\n    test_cases = [\n        # Test 1: N=7\n        (7, [\n            [0,1,2],\n            [2,3],\n            [3,4,5],\n            [5,6],\n            [0,4,6],\n            [1,5],\n            [0,3,6],\n        ]),\n        # Test 2: N=0 (empty universe)\n        (0, [\n            # no sets\n        ]),\n        # Test 3: N=5 with missing element 4\n        (5, [\n            [0,1],\n            [1,2],\n            [2,3],\n            [0,3],\n        ]),\n        # Test 4: N=20 with one full-cover set\n        (20, [\n            list(range(20)),\n            [0,2,4,6,8,10,12,14,16,18],\n        ]),\n        # Test 5: N=10 with two blocks\n        (10, [\n            [0,1,2,3,4],\n            [5,6,7,8,9],\n            [0,5,6],\n            [1,7,8],\n            [2,9],\n            [3,4],\n        ]),\n        # Test 6: N=6 with duplicate set\n        (6, [\n            [0,1,2],\n            [0,1,2],\n            [3,4,5],\n        ]),\n    ]\n\n    results = []\n    for n, sets in test_cases:\n        result = min_set_cover(n, sets)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3203736"}, {"introduction": "对于现实世界中的大规模问题，精确算法往往因计算量过大而不可行，此时我们通常采用近似算法。贪心算法是解决集合覆盖问题最著名也最直观的方法，它能在可接受的时间内给出一个接近最优解的“足够好”的解。这个练习 [@problem_id:3180742] 的精妙之处在于，它不只是让你简单地运行贪心算法，而是要求你在一个精心构造的实例上，将其结果与真正的最优解进行比较，从而深刻理解贪心策略的决策机制及其潜在的局限性。", "problem": "一个集合覆盖问题由一个全集 $U$、 $U$ 的一个子集族 $\\{S_i\\}$ 以及一个非负成本向量 $c \\in \\mathbb{R}^{m}$ 定义，其中 $m$ 是集合的数量。决策变量 $x_i \\in \\{0,1\\}$ 表示是否选择集合 $S_i$。令 $A = (a_{ij})$ 为二元关联矩阵，其中如果元素 $j \\in U$ 包含在集合 $S_i$ 中，则 $a_{ij} = 1$，否则 $a_{ij} = 0$。集合覆盖问题旨在最小化 $\\sum_{i=1}^{m} c_i x_i$，约束条件为对所有 $j \\in U$ 都有 $\\sum_{i=1}^{m} a_{ij} x_i \\geq 1$。考虑以下实例，其中 $U = \\{1,2,3,4,5,6,7,8,h_1,h_2\\}$，有五个索引为 $i \\in \\{0,1,2,3,4\\}$ 的集合，其成本分别为 $c_0 = 10$、$c_1 = 9$、$c_2 = 9$、$c_3 = 6$ 和 $c_4 = 6$。关联矩阵 $A$（行的顺序为 $i=0,1,2,3,4$，列的顺序为 $1,2,3,4,5,6,7,8,h_1,h_2$）是\n$$\nA =\n\\begin{pmatrix}\n1  1  1  1  1  1  1  1  0  0 \\\\\n1  1  1  1  0  0  0  0  1  1 \\\\\n0  0  0  0  1  1  1  1  1  1 \\\\\n0  0  0  0  0  0  0  0  1  0 \\\\\n0  0  0  0  0  0  0  0  0  1 \\\\\n\\end{pmatrix}.\n$$\n因此，$S_0$ 覆盖 $\\{1,2,3,4,5,6,7,8\\}$，$S_1$ 覆盖 $\\{1,2,3,4,h_1,h_2\\}$，$S_2$ 覆盖 $\\{5,6,7,8,h_1,h_2\\}$，$S_3$ 覆盖 $\\{h_1\\}$，以及 $S_4$ 覆盖 $\\{h_2\\}$。考虑标准的贪心启发式算法，该算法迭代地选择能最小化比率 $c_i / |\\{j \\in U : a_{ij} = 1 \\text{ and } \\sum_{k} a_{kj} x_k = 0\\}|$ 的集合 $i$，即成本除以新覆盖元素的数量，直到 $U$ 的所有元素都被覆盖。将解 $x$ 的冗余度定义为\n$$\nR(x) \\;=\\; \\sum_{j \\in U} \\left( \\sum_{i=0}^{4} a_{ij} x_i \\;-\\; 1 \\right),\n$$\n该公式计算了所有元素超过一次的覆盖次数之和。令 $x^{\\text{greedy}}$ 为贪心启发式算法产生的解，令 $x^{\\text{OPT}}$ 为在给定集合上最小化总成本的最优解。计算比率\n$$\n\\mathcal{Q} \\;=\\; \\frac{R\\!\\left(x^{\\text{greedy}}\\right)}{R\\!\\left(x^{\\text{OPT}}\\right)}.\n$$\n给出最终答案的精确值，不要进行四舍五入。", "solution": "我们从集合覆盖问题的核心定义开始：选择集合以覆盖 $U$ 中的每个元素至少一次，同时最小化总成本。贪心启发式算法的规则是，在每次迭代中，选择使其成本与新覆盖元素（即当时尚未被覆盖的元素）数量之比最小的集合。\n\n步骤1：确定贪心选择序列。\n\n最初，所有 $10$ 个元素都未被覆盖。计算初始比率：\n- 对于 $S_0$：它新覆盖 $8$ 个元素（元素 $1,2,3,4,5,6,7,8$），因此比率为 $10 / 8 = 1.25$。\n- 对于 $S_1$：它新覆盖 $6$ 个元素（元素 $1,2,3,4,h_1,h_2$），因此比率为 $9 / 6 = 1.5$。\n- 对于 $S_2$：它新覆盖 $6$ 个元素（元素 $5,6,7,8,h_1,h_2$），因此比率为 $9 / 6 = 1.5$。\n- 对于 $S_3$：它新覆盖 $1$ 个元素（$h_1$），因此比率为 $6 / 1 = 6$。\n- 对于 $S_4$：它新覆盖 $1$ 个元素（$h_2$），因此比率为 $6 / 1 = 6$。\n\n贪心规则首先选择 $S_0$，因为 $1.25$ 是最小的比率。选择 $S_0$ 后，已覆盖的元素是 $\\{1,2,3,4,5,6,7,8\\}$，未覆盖的元素是 $\\{h_1,h_2\\}$。\n\n接下来，针对未覆盖的元素 $\\{h_1,h_2\\}$ 重新计算比率：\n- $S_1$ 现在新增 $2$ 个元素（$h_1$ 和 $h_2$），比率为 $9 / 2 = 4.5$。\n- $S_2$ 也新增 $2$ 个元素，比率为 $9 / 2 = 4.5$。\n- $S_3$ 新增 $1$ 个元素（$h_1$），比率为 $6 / 1 = 6$。\n- $S_4$ 新增 $1$ 个元素（$h_2$），比率为 $6 / 1 = 6$。\n\n最小的比率是 $4.5$，由 $S_1$ 和 $S_2$ 提供。不失一般性地，我们选择 $S_1$。添加 $S_1$ 后，未覆盖的元素 $\\{h_1, h_2\\}$ 都被覆盖了，至此全集 $U$ 中的所有元素均已覆盖，算法终止。\n因此，贪心解为 $x^{\\text{greedy}}$，其中 $x_0 = 1$，$x_1 = 1$，且 $x_2 = x_3 = x_4 = 0$。\n\n步骤2：确定给定集合中的一个最优解 $x^{\\text{OPT}}$。\n\n我们评估候选的覆盖方案：\n- $\\{S_0,S_1\\}$ 覆盖所有元素，总成本为 $10 + 9 = 19$。\n- $\\{S_0,S_2\\}$ 同样覆盖所有元素，成本为 $10 + 9 = 19$。\n- $\\{S_1,S_2\\}$ 覆盖所有元素（因为 $S_1$ 覆盖 $\\{1,2,3,4,h_1,h_2\\}$，$S_2$ 覆盖 $\\{5,6,7,8,h_1,h_2\\}$），总成本为 $9 + 9 = 18$。\n- $\\{S_0,S_3,S_4\\}$ 覆盖所有元素，成本为 $10 + 6 + 6 = 22$。\n其他组合要么无法覆盖所有元素，要么成本更高。\n\n因此，最优解为 $x^{\\text{OPT}}$，其中 $x_1 = 1$，$x_2 = 1$，且 $x_0 = x_3 = x_4 = 0$，最小总成本为 $18$。\n\n步骤3：计算两种解的冗余度 $R(x)$。\n\n根据定义，\n$$\nR(x) = \\sum_{j \\in U} \\left( \\sum_{i=0}^{4} a_{ij} x_i - 1 \\right),\n$$\n该公式计算了所有元素超过一次的覆盖次数之和。\n\n计算由集合 $\\{S_0,S_1\\}$ 构成的贪心解 $x^{\\text{greedy}}$ 的冗余度 $R\\!\\left(x^{\\text{greedy}}\\right)$：\n- 元素 $1,2,3,4$：被 $S_0$ 和 $S_1$ 两者覆盖，因此每个的覆盖重数为 $2$，各贡献 $2 - 1 = 1$，总计 $4$。\n- 元素 $5,6,7,8$：仅被 $S_0$ 覆盖，重数为 $1$，各贡献 $0$，总计 $0$。\n- 元素 $h_1$：仅被 $S_1$ 覆盖，重数为 $1$，贡献为 $0$。\n- 元素 $h_2$：仅被 $S_1$ 覆盖，重数为 $1$，贡献为 $0$。\n\n因此，\n$$\nR\\!\\left(x^{\\text{greedy}}\\right) = 4 + 0 + 0 + 0 = 4.\n$$\n\n计算由集合 $\\{S_1,S_2\\}$ 构成的最优解 $x^{\\text{OPT}}$ 的冗余度 $R\\!\\left(x^{\\text{OPT}}\\right)$：\n- 元素 $1,2,3,4$：仅被 $S_1$ 覆盖，重数为 $1$，各贡献 $0$，总计 $0$。\n- 元素 $5,6,7,8$：仅被 $S_2$ 覆盖，重数为 $1$，各贡献 $0$，总计 $0$。\n- 元素 $h_1$：被 $S_1$ 和 $S_2$ 两者覆盖，重数为 $2$，贡献为 $1$。\n- 元素 $h_2$：被 $S_1$ 和 $S_2$ 两者覆盖，重数为 $2$，贡献为 $1$。\n\n因此，\n$$\nR\\!\\left(x^{\\text{OPT}}\\right) = 0 + 0 + 1 + 1 = 2.\n$$\n\n步骤4：计算所要求的比率 $\\mathcal{Q}$。\n\n根据定义，\n$$\n\\mathcal{Q} = \\frac{R\\!\\left(x^{\\text{greedy}}\\right)}{R\\!\\left(x^{\\text{OPT}}\\right)} = \\frac{4}{2} = 2.\n$$\n\n因此，对于此实例，贪心解产生的冗余度正好是最优解的两倍。", "answer": "$$\\boxed{2}$$", "id": "3180742"}]}