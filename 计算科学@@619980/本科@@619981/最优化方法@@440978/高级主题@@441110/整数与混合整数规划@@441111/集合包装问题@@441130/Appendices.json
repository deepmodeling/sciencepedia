{"hands_on_practices": [{"introduction": "动手实践是掌握集合包装问题精髓的最佳途径。让我们从一个经典的资源分配场景开始：大学考试调度[@problem_id:3181311]。这个练习旨在将一个实际问题——如何安排考试以避免监考人员和教室的资源冲突——转化为一个集合包装模型。通过构建这个模型，你将亲身体会到如何将现实世界的约束（例如，一个监考人员不能同时出现在两个地方）精确地表达为数学上的集合不相交条件，即 $A x \\le \\mathbf{1}$。", "problem": "本题要求您使用集合包装问题的框架，为一个独立的小型大学考试调度问题系列进行建模和求解。其根本基础是集合包装问题的核心定义：给定一个基本项全集和一个子集族，从中选择一个成对不相交的子集族，以最大化给定的目标函数。在此设定下，基本项是资源（监考员和教室），每个子集代表一个占用特定资源集的可能考试选项。不相交原则通过一个二元关联矩阵和线性不等式来强制执行。\n\n设资源全集由有限集 $U$ 表示，考试选项的索引集为 $S = \\{1,2,\\dots,m\\}$。对于每个选项 $s \\in S$，令 $R(s) \\subseteq U$ 表示选项 $s$ 占用的资源集合。定义一个关联矩阵 $A \\in \\{0,1\\}^{|U|\\times m}$ 如下：\n$$\nA_{u,s} = \\begin{cases}\n1  &\\text{if } u \\in R(s),\\\\\n0  &\\text{otherwise.}\n\\end{cases}\n$$\n令 $x \\in \\{0,1\\}^m$ 为决策向量，指示哪些选项被选中；令 $w \\in \\mathbb{R}_+^m$ 为非负公平性权重的向量。加权集合包装模型为：\n$$\n\\max_{x \\in \\{0,1\\}^m} \\quad \\sum_{s=1}^m w_s x_s \\quad \\text{subject to} \\quad A x \\le \\mathbf{1},\n$$\n其中 $\\mathbf{1}$ 是 $\\mathbb{R}^{|U|}$ 中的全1向量，不等式是逐分量成立的。约束 $A x \\le \\mathbf{1}$ 确保了没有资源 $u \\in U$ 被超过一个选定的选项使用，即选定的选项在资源上是成对不相交的。公平性权重 $w_s$ 编码了选择每个选项的相对期望程度。\n\n您的程序必须为下方的每个测试实例，在所有满足 $A x \\le \\mathbf{1}$ 和 $x \\in \\{0,1\\}^m$ 的 $x$ 中，计算出最优目标值 $\\sum_{s=1}^m w_s x_s$。若最优目标值出现平局，则优先选择基数 $\\sum_{s=1}^m x_s$ 更大的解来打破平局。若仍然存在平局，则优先选择所选选项的索引集字典序最小的解。\n\n测试套件。请严格使用以下四个实例。对于每个实例，都提供了明确的全集 $U$、占用资源的集合族 $\\{R(s)\\}_{s=1}^m$ 以及公平性权重 $w$。资源标签纯粹是符号性的；将标签的相等性视为资源的同一性。\n\n- 实例 1（理想情况，教室和监考员之间有有意义的重叠）：\n  - 全集 $U^{(1)} = \\{I_1, I_2, I_3, R_{101}, R_{102}\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(1)}(1) = \\{I_1, I_2, R_{101}\\}$，权重 $w^{(1)}_1 = 8.0$。\n    - $s=2$: $R^{(1)}(2) = \\{I_2, I_3, R_{101}\\}$，权重 $w^{(1)}_2 = 7.5$。\n    - $s=3$: $R^{(1)}(3) = \\{I_1, I_3, R_{102}\\}$，权重 $w^{(1)}_3 = 6.0$。\n    - $s=4$: $R^{(1)}(4) = \\{I_2, R_{102}\\}$，权重 $w^{(1)}_4 = 4.5$。\n    - $s=5$: $R^{(1)}(5) = \\{I_3, R_{102}\\}$，权重 $w^{(1)}_5 = 5.0$。\n    - $s=6$: $R^{(1)}(6) = \\{I_1, R_{101}\\}$，权重 $w^{(1)}_6 = 4.0$。\n- 实例 2（边界情况：高公平性权重的选项共享监考员，最多只允许选择一个）：\n  - 全集 $U^{(2)} = \\{I_1, I_2, R_{101}, R_{102}, R_{103}\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(2)}(1) = \\{I_1, I_2, R_{101}\\}$，权重 $w^{(2)}_1 = 9.0$。\n    - $s=2$: $R^{(2)}(2) = \\{I_1, I_2, R_{102}\\}$，权重 $w^{(2)}_2 = 9.5$。\n    - $s=3$: $R^{(2)}(3) = \\{I_1, I_2, R_{103}\\}$，权重 $w^{(2)}_3 = 9.2$。\n- 实例 3（边缘情况：所有选项相互不相交，选择所有选项是可行的）：\n  - 全集 $U^{(3)} = \\{I_1, I_2, I_3, I_4, R_{101}, R_{102}, R_{103}, R_{104}\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(3)}(1) = \\{I_1, R_{101}\\}$，权重 $w^{(3)}_1 = 2.5$。\n    - $s=2$: $R^{(3)}(2) = \\{I_2, R_{102}\\}$，权重 $w^{(3)}_2 = 2.5$。\n    - $s=3$: $R^{(3)}(3) = \\{I_3, R_{103}\\}$，权重 $w^{(3)}_3 = 2.5$。\n    - $s=4$: $R^{(3)}(4) = \\{I_4, R_{104}\\}$，权重 $w^{(3)}_4 = 2.5$。\n- 实例 4（平局情况，展示了可行性与最优性之间的张力以及按基数打破平局）：\n  - 全集 $U^{(4)} = \\{I_1, I_2, I_3, R_{101}, R_{102}, R_{103}\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(4)}(1) = \\{I_1, R_{101}\\}$，权重 $w^{(4)}_1 = 4.0$。\n    - $s=2$: $R^{(4)}(2) = \\{I_2, R_{102}\\}$，权重 $w^{(4)}_2 = 4.0$。\n    - $s=3$: $R^{(4)}(3) = \\{I_1, I_2, R_{103}\\}$，权重 $w^{(4)}_3 = 8.0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个实例 $k \\in \\{1,2,3,4\\}$，输出一个包含两个元素的列表，按顺序分别为最优目标值和所选选项的数量。因此，最终输出必须具有以下形式：\n$$\n\\big[ [\\text{opt}^{(1)}, \\text{card}^{(1)}], [\\text{opt}^{(2)}, \\text{card}^{(2)}], [\\text{opt}^{(3)}, \\text{card}^{(3)}], [\\text{opt}^{(4)}, \\text{card}^{(4)}] \\big],\n$$\n打印行中不含空格。不涉及任何物理单位或角度单位；所有数值结果均为无量纲的实数和整数（视情况而定）。", "solution": "该问题要求解决一系列加权集合包装实例，这是组合优化中的一个经典问题。该问题被正式定义为一个整数线性规划：\n$$\n\\max_{x \\in \\{0,1\\}^m} \\quad \\sum_{s=1}^m w_s x_s \\quad \\text{subject to} \\quad A x \\le \\mathbf{1}\n$$\n其中 $x$ 是一个二元决策向量，指示 $m$ 个选项中的哪些被选中；$w$ 是一个非负权重向量；约束 $A x \\le \\mathbf{1}$ 确保了没有资源被使用超过一次。矩阵 $A$ 是一个关联矩阵，其中如果资源 $u$ 被选项 $s$ 使用，则 $A_{u,s} = 1$，否则 $A_{u,s} = 0$。不等式 $A x \\le \\mathbf{1}$ 等价于：对于任意两个选定的选项 $s_i$ 和 $s_j$（其中 $x_i=1$ 且 $x_j=1$），它们各自的资源集 $R(s_i)$ 和 $R(s_j)$ 必须不相交，即 $R(s_i) \\cap R(s_j) = \\emptyset$。\n\n任务是找到一个可行解 $x$，使得目标函数 $\\sum w_s x_s$ 最大化。由于决策向量 $x$ 属于 $\\{0,1\\}^m$，所有可能的 $x$ 选择的集合是有限的，其大小为 $2^m$。对于给定的实例，选项数量 $m$ 很小（$m \\le 6$），这使得对所有 $2^m$ 个可能的选项子集进行穷举搜索在计算上是可行的。\n\n该求解算法对每个实例，通过遍历所有可能的可用选项子集来进行。对于每个子集，我们执行以下步骤：\n1. **可行性检查**：一个选项子集是可行的，当且仅当该子集内的所有选项对在其资源需求上都相互不相交。这通过验证子集中任意两个不同选项 $s_i$ 和 $s_j$ 的资源集交集 $R(s_i) \\cap R(s_j)$ 为空集来检查。\n\n2. **评估**：如果一个子集被发现是可行的，则通过对该子集中所有选项 $s$ 的权重 $w_s$ 求和来计算其目标值。基数就是子集中选项的数量。\n\n3. **最优解的选择**：算法会记录迄今为止找到的最佳解。一个新的可行解如果根据指定的分级决胜规则更优，则会替换当前的最佳解：\n    a. 新解具有严格更大的目标值 $\\sum w_s x_s$。\n    b. 如果目标值相等，新解具有严格更大的基数 $\\sum x_s$。\n    c. 如果目标值和基数都相等，新解的选项索引集比当前最优解的字典序更小。\n\n该过程保证能找到问题陈述所定义的唯一最优解。我们将此算法应用于四个实例中的每一个。\n\n**实例 1**：$m=6$，因此有 $2^6=64$ 个子集需要检查。在检查了所有可行子集后，使目标最大化的子集是 $\\{s=1, s=5\\}$。\n- 资源集：$R^{(1)}(1) = \\{I_1, I_2, R_{101}\\}$ 和 $R^{(1)}(5) = \\{I_3, R_{102}\\}$。它们的交集为空，因此该选择是可行的。\n- 目标值：$w^{(1)}_1 + w^{(1)}_5 = 8.0 + 5.0 = 13.0$。\n- 基数：$2$。\n这产生了一个比任何其他可行子集都更高的目标值。例如，次优值为 $9.0$，对应于集合 $\\{s=5, s=6\\}$。因此，最优值为 $13.0$，基数为 $2$。\n\n**实例 2**：$m=3$。选项为 $s=1, s=2, s=3$。所有选项都共享资源 $\\{I_1, I_2\\}$。\n- $R^{(2)}(1) \\cap R^{(2)}(2) = \\{I_1, I_2\\} \\ne \\emptyset$。\n- $R^{(2)}(1) \\cap R^{(2)}(3) = \\{I_1, I_2\\} \\ne \\emptyset$。\n- $R^{(2)}(2) \\cap R^{(2)}(3) = \\{I_1, I_2\\} \\ne \\emptyset$。\n因此，任意两个选项都不能同时被选中。可行解最多只能包含一个选项。最优解是选择权重最高的单个选项，即 $s=2$，其权重为 $w^{(2)}_2 = 9.5$。\n- 最优值：$9.5$。\n- 基数：$1$。\n\n**实例 3**：$m=4$。四个选项的资源集两两不相交。\n- $R^{(3)}(i) \\cap R^{(3)}(j) = \\emptyset$ for all $i \\ne j$.\n这意味着任何选项子集都是可行的。由于所有权重 $w_s = 2.5$ 都是正的，最优解是选择所有四个选项。\n- 目标值：$w^{(3)}_1+w^{(3)}_2+w^{(3)}_3+w^{(3)}_4 = 4 \\times 2.5 = 10.0$。\n- 基数：$4$。\n\n**实例 4**：$m=3$。资源集为 $R^{(4)}(1)=\\{I_1, R_{101}\\}$, $R^{(4)}(2)=\\{I_2, R_{102}\\}$ 和 $R^{(4)}(3)=\\{I_1, I_2, R_{103}\\}$。\n- 冲突：$R^{(4)}(1) \\cap R^{(4)}(3) = \\{I_1\\}$，$R^{(4)}(2) \\cap R^{(4)}(3) = \\{I_2\\}$。\n- 可行对：$R^{(4)}(1) \\cap R^{(4)}(2) = \\emptyset$。\n可行的子集（包装）是 $\\{s=1\\}$, $\\{s=2\\}$, $\\{s=3\\}$ 和 $\\{s=1, s=2\\}$。我们来评估它们：\n- $\\{s=1\\}$：值 = $4.0$，基数 = $1$。\n- $\\{s=2\\}$：值 = $4.0$，基数 = $1$。\n- $\\{s=3\\}$：值 = $8.0$，基数 = $1$。\n- $\\{s=1, s=2\\}$：值 = $w^{(4)}_1 + w^{(4)}_2 = 4.0 + 4.0 = 8.0$，基数 = $2$。\n最大目标值为 $8.0$，由 $\\{s=3\\}$ 和 $\\{s=1, s=2\\}$ 两个集合同时达到。根据决胜规则，我们优先选择基数较大的那个。集合 $\\{s=1, s=2\\}$ 的基数为 $2$，而 $\\{s=3\\}$ 的基数为 $1$。\n- 最优值：$8.0$。\n- 基数：$2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Models and solves the set packing instances described in the problem.\n    \"\"\"\n    \n    test_cases = [\n        # Instance 1\n        {\n            \"U\": {\"I1\", \"I2\", \"I3\", \"R101\", \"R102\"},\n            \"options\": [\n                (8.0, {\"I1\", \"I2\", \"R101\"}),\n                (7.5, {\"I2\", \"I3\", \"R101\"}),\n                (6.0, {\"I1\", \"I3\", \"R102\"}),\n                (4.5, {\"I2\", \"R102\"}),\n                (5.0, {\"I3\", \"R102\"}),\n                (4.0, {\"I1\", \"R101\"}),\n            ]\n        },\n        # Instance 2\n        {\n            \"U\": {\"I1\", \"I2\", \"R101\", \"R102\", \"R103\"},\n            \"options\": [\n                (9.0, {\"I1\", \"I2\", \"R101\"}),\n                (9.5, {\"I1\", \"I2\", \"R102\"}),\n                (9.2, {\"I1\", \"I2\", \"R103\"}),\n            ]\n        },\n        # Instance 3\n        {\n            \"U\": {\"I1\", \"I2\", \"I3\", \"I4\", \"R101\", \"R102\", \"R103\", \"R104\"},\n            \"options\": [\n                (2.5, {\"I1\", \"R101\"}),\n                (2.5, {\"I2\", \"R102\"}),\n                (2.5, {\"I3\", \"R103\"}),\n                (2.5, {\"I4\", \"R104\"}),\n            ]\n        },\n        # Instance 4\n        {\n            \"U\": {\"I1\", \"I2\", \"I3\", \"R101\", \"R102\", \"R103\"},\n            \"options\": [\n                (4.0, {\"I1\", \"R101\"}),\n                (4.0, {\"I2\", \"R102\"}),\n                (8.0, {\"I1\", \"I2\", \"R103\"}),\n            ]\n        }\n    ]\n\n    def solve_instance(options):\n        \"\"\"\n        Solves a single weighted set packing instance by exhaustive search.\n        \n        Args:\n            options: A list of tuples, where each tuple contains the weight (float)\n                     and the set of required resources (set of strings).\n\n        Returns:\n            A list containing the optimal objective value and the cardinality of the\n            optimal set.\n        \"\"\"\n        num_options = len(options)\n        \n        # Best solution found so far, using (objective, cardinality, index_set)\n        # We initialize objective to a value lower than any possible sum of non-negative weights.\n        best_solution = (-1.0, -1, [])\n\n        # Iterate through all 2^m subsets of options using a bitmask\n        for i in range(1  num_options):\n            current_options_indices = []\n            for j in range(num_options):\n                if (i >> j)  1:\n                    current_options_indices.append(j)\n\n            # Check feasibility of the current subset\n            is_feasible = True\n            current_obj_val = 0.0\n            used_resources = set()\n\n            for idx in current_options_indices:\n                weight, resources = options[idx]\n                if not resources.isdisjoint(used_resources):\n                    is_feasible = False\n                    break\n                used_resources.update(resources)\n                current_obj_val += weight\n\n            if is_feasible:\n                current_cardinality = len(current_options_indices)\n                # Option indices are 1-based for lexicographical comparison\n                current_index_set = [idx + 1 for idx in current_options_indices]\n\n                # Tie-breaking logic\n                # 1. Higher objective value is better\n                if current_obj_val > best_solution[0]:\n                    best_solution = (current_obj_val, current_cardinality, current_index_set)\n                elif current_obj_val == best_solution[0]:\n                    # 2. Higher cardinality is better\n                    if current_cardinality > best_solution[1]:\n                        best_solution = (current_obj_val, current_cardinality, current_index_set)\n                    elif current_cardinality == best_solution[1]:\n                        # 3. Lexicographically smaller index set is better\n                        if current_index_set  best_solution[2]:\n                            best_solution = (current_obj_val, current_cardinality, current_index_set)\n        \n        return [best_solution[0], best_solution[1]]\n\n    results = []\n    for case in test_cases:\n        result = solve_instance(case[\"options\"])\n        results.append(result)\n\n    # Format the final output string to be exactly as specified, with no spaces.\n    list_of_strings = [f\"[{val},{card}]\" for val, card in results]\n    final_output_string = f\"[{','.join(list_of_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3181311"}, {"introduction": "在掌握了基础建模之后，我们可以探索一个更复杂的应用：带有公平性约束的课程安排[@problem_id:3181267]。这个练习不仅巩固了集合包装在调度问题中的核心应用，还引入了额外的“旁侧约束”来满足更细致的现实需求，例如保证不同学生群体的代表性和对服务不足群体的覆盖。通过这个练习，你将学会如何扩展基础的集合包装模型，使其能够处理更复杂、更符合社会与伦理考量的多目标决策问题，从而体会到优化建模的强大威力与灵活性。", "problem": "考虑一个为构建专业实验课程序列名单而设计的集合包装问题。设学生群体的基本集合表示为 $U = \\{u_1, u_2, \\dots, u_n\\}$，候选实验序列的族表示为 $S = \\{s_1, s_2, \\dots, s_m\\}$，其中每个 $s_j \\subseteq U$ 枚举了将共同参加序列 $j$ 的群体。定义二进制决策变量 $x_j \\in \\{0,1\\}$，用于指示是否选择序列 $j$。设 $A \\in \\{0,1\\}^{n \\times m}$ 为关联矩阵，当且仅当 $u_i \\in s_j$ 时，条目 $A_{ij} = 1$，否则 $A_{ij} = 0$。序列之间的不重叠要求意味着每个群体最多只能出现在一个选定的序列中，这由线性系统 $A x \\le \\mathbf{1}$ 描述，其中 $x = (x_1, \\dots, x_m)^\\top$，$\\mathbf{1}$ 是 $n$ 维的全1向量。每个序列 $j$ 都有一个教育价值 $v_j \\in \\mathbb{R}$，集合为 $v \\in \\mathbb{R}^m$，目标是最大化 $\\sum_{j=1}^m v_j x_j = v^\\top x$。\n\n为了确保各群体的代表性并覆盖服务不足的群体，施加了公平性附加约束。设群体标签的集合为 $G = \\{g_1, \\dots, g_p\\}$，设 $B \\in \\{0,1\\}^{p \\times m}$ 为群体成员关系矩阵，如果序列 $j$ 服务于群体 $g_k$，则 $B_{k j} = 1$，否则 $B_{k j} = 0$。每个群体所选序列数量的下限和上限分别由 $B x \\ge L$ 和 $B x \\le U$ 捕获，其中 $L, U \\in \\mathbb{Z}_{\\ge 0}^p$。对于服务不足的群体，设 $w \\in \\{0,1\\}^n$ 是一个掩码，其中 $w_i = 1$ 表示群体 $u_i$ 服务不足；在选择 $x$ 下，服务不足群体的总覆盖率为 $\\sum_{i=1}^n w_i (A x)_i$，可以要求其满足下限 $C_{\\min} \\in \\mathbb{Z}_{\\ge 0}$。\n\n你的任务是编写一个完整的程序，为每个提供的测试用例计算一个最优选择 $x$，该选择在满足 $x \\in \\{0,1\\}^m$、$A x \\le \\mathbf{1}$ 和指定的公平性附加约束的条件下，最大化 $v^\\top x$。当存在多个最优解时，按以下确定性规则打破平局：在具有相同目标值的解中，优先选择覆盖更多群体的解，即最大化 $\\sum_{i=1}^n (A x)_i$；如果仍然平局，则优先选择其选定序列索引的排序列表在字典序上最小的解。对于每个测试用例，你的程序应输出排序后的选定索引列表（作为整数列表），或者如果约束不可行，则输出布尔值 `False`。\n\n使用以下测试套件，其中有 $n = 5$ 个群体和 $m = 6$ 个序列：\n\n定义关联矩阵\n$$\nA = \\begin{bmatrix}\n1  0  0  1  0  0\\\\\n1  1  0  0  0  1\\\\\n0  1  0  0  1  0\\\\\n0  0  1  0  0  1\\\\\n0  0  0  1  1  0\n\\end{bmatrix}.\n$$\n\n定义教育价值\n$$\nv = \\begin{bmatrix}\n8  7  4  6  9  5\n\\end{bmatrix}.\n$$\n\n定义两个群体 $G = \\{g_{\\mathrm{day}}, g_{\\mathrm{evening}}\\}$ 和群体成员关系矩阵\n$$\nB = \\begin{bmatrix}\n1  0  1  1  1  0\\\\\n0  1  0  0  0  1\n\\end{bmatrix},\n$$\n其中第一行对应于 $g_{\\mathrm{day}}$，第二行对应于 $g_{\\mathrm{evening}}$。\n\n定义服务不足群体掩码\n$$\nw = \\begin{bmatrix}\n0  0  0  1  0\n\\end{bmatrix},\n$$\n它将群体 $u_4$ 标记为服务不足。\n\n三个测试用例如下：\n\n- 测试用例 1（基准集合包装）：没有公平性附加约束，即 $B x \\ge L$ 且 $L = \\begin{bmatrix} 0  0 \\end{bmatrix}$，$B x \\le U$ 且 $U = \\begin{bmatrix} +\\infty  +\\infty \\end{bmatrix}$（无上限），服务不足群体覆盖率下限为 $C_{\\min} = 0$。\n- 测试用例 2（晚间课程最低代表性及服务不足群体覆盖）：要求至少选择一个晚间序列，$B x \\ge L$ 且 $L = \\begin{bmatrix} 0  1 \\end{bmatrix}$，无上限，服务不足群体覆盖率下限为 $C_{\\min} = 1$。\n- 测试用例 3（不可行的晚间课程配额）：要求至少选择两个晚间序列，$B x \\ge L$ 且 $L = \\begin{bmatrix} 0  2 \\end{bmatrix}$，无上限，服务不足群体覆盖率下限为 $C_{\\min} = 0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果格式化为不含空格的整数列表（例如 `[1,3,5]`）或布尔值 `False`。例如，三个测试用例的总体输出格式必须像 `[[1,3,5],[2,3,4],False]`。此问题不涉及物理单位或角度，数值应完全按照规定报告为整数或布尔值。", "solution": "提出的问题是一个带约束的集合包装问题，属于整数线性规划（ILP）的范畴。目标是选择一个由二进制决策向量 $x \\in \\{0,1\\}^m$ 代表的实验序列子集，以在遵守多项约束的同时最大化总价值函数。该问题定义明确，数学上合理，并为其解决提供了所有必要的数据。\n\n问题的核心是针对三组不同的约束条件求解以下整数线性规划问题：\n-   **最大化**：$v^\\top x$\n-   **约束条件**：\n    1.  $x_j \\in \\{0, 1\\}$ for $j = 1, \\dots, m$\n    2.  $A x \\le \\mathbf{1}$（集合包装约束）\n    3.  $B x \\ge L$（群体下限约束）\n    4.  $B x \\le U$（群体上限约束，在此问题中实际上不存在）\n    5.  $(w^\\top A) x \\ge C_{\\min}$（服务不足群体覆盖约束）\n\n通过一个三级平局打破规则来保证解的唯一性：\n1.  主要目标：最大化教育价值 $O_1 = v^\\top x = \\sum_{j=1}^{m} v_j x_j$。\n2.  次要目标：最大化覆盖的学生群体总数 $O_2 = \\sum_{i=1}^{n} (A x)_i$。这可以写成 $(\\mathbf{1}^\\top A) x$。\n3.  第三目标：选择其选定序列索引的排序列表在字典序上最小的解。\n\n鉴于序列数量较少（$m=6$），可能解的搜索空间大小为 $2^6 = 64$。这个规模小到足以允许对所有可能的二进制向量 $x$ 进行穷举搜索（暴力枚举）。该方法保证能根据分层目标找到全局最优解。\n\n求解过程如下：\n1.  遍历长度为 $m=6$ 的每个可能的二进制向量 $x$。\n2.  对于每个 $x$，通过检查给定测试用例的所有活动约束来验证它是否为可行解。\n3.  如果一个解满足 $A x \\le \\mathbf{1}$、$B x \\ge L$ 和 $(w^\\top A) x \\ge C_{\\min}$，则该解是可行的。\n4.  收集所有可行解。如果找不到可行解，则问题不可行。\n5.  对于每个可行解，计算主要目标值 $O_1$ 和次要目标值 $O_2$。\n6.  然后根据分层标准对可行解集进行排序：首先按 $O_1$ 降序排序，然后按 $O_2$ 降序排序，最后按选定索引排序列表的字典升序排序。\n7.  此排序列表中的第一个条目即为最优解。\n\n此过程应用于三个测试用例中的每一个。\n\n**测试用例 1**：基准集合包装。约束为 $L=\\begin{bmatrix} 0  0 \\end{bmatrix}^\\top$ 和 $C_{\\min}=0$。这些是平凡约束，任何选择都满足。唯一有意义的约束是集合包装约束 $A x \\le \\mathbf{1}$。穷举搜索表明，选择序列 $\\{s_1, s_3, s_5\\}$（对应于 $x=[1,0,1,0,1,0]^\\top$）可产生唯一的最大值 $O_1 = v_1 + v_3 + v_5 = 8 + 4 + 9 = 21$。排序后的索引为 $[1,3,5]$。\n\n**测试用例 2**：晚间课程最低代表性及服务不足群体覆盖。约束为 $L=\\begin{bmatrix} 0  1 \\end{bmatrix}^\\top$ 和 $C_{\\min}=1$。这些施加了两个关键条件：\n-   从 $B x \\ge L$ 可知，第二行意味着 $\\sum_{j=1}^{m} B_{2j}x_j = x_2 + x_6 \\ge 1$。\n-   从 $(w^\\top A)x \\ge C_{\\min}$，我们得到 $x_3 + x_6 \\ge 1$。\n因此，一个可行解必须满足（$x_2=1$ 或 $x_6=1$）以及（$x_3=1$ 或 $x_6=1$）。我们在此条件下搜索最佳包装。找到的最优可行解是选择序列 $\\{s_2, s_3, s_4\\}$，对应于 $x=[0,1,1,1,0,0]^\\top$。该解给出的值为 $O_1 = v_2 + v_3 + v_4 = 7 + 4 + 6 = 17$。没有其他可行解能达到更高的值。排序后的索引为 $[2,3,4]$。\n\n**测试用例 3**：不可行的晚间课程配额。约束为 $L=\\begin{bmatrix} 0  2 \\end{bmatrix}^\\top$，这意味着 $x_2 + x_6 \\ge 2$。由于 $x_2$ 和 $x_6$ 是二进制的，这强制要求 $x_2=1$ 和 $x_6=1$。然而，序列 $s_2$ 和 $s_6$ 共享群体 $u_2$（因为 $A_{2,2}=1$ 和 $A_{2,6}=1$）。同时选择两者违反了对应于群体 $u_2$ 的不重叠约束 $A x \\le \\mathbf{1}$ 的第二行，即 $x_1 + x_2 + x_6 \\le 1$。代入 $x_2=1, x_6=1$ 会得出矛盾 $x_1+1+1 \\le 1$。因此，不存在可行解。结果是 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Solves the set packing problem for three test cases using brute-force enumeration.\n    \"\"\"\n    # Define problem data based on the provided statement.\n    # n=5 cohorts, m=6 sequences\n    A = np.array([\n        [1, 0, 0, 1, 0, 0],\n        [1, 1, 0, 0, 0, 1],\n        [0, 1, 0, 0, 1, 0],\n        [0, 0, 1, 0, 0, 1],\n        [0, 0, 0, 1, 1, 0]\n    ])\n    v = np.array([8, 7, 4, 6, 9, 5])\n    B = np.array([\n        [1, 0, 1, 1, 1, 0],\n        [0, 1, 0, 0, 0, 1]\n    ])\n    w = np.array([0, 0, 0, 1, 0])\n\n    # Pre-calculate vectors for objectives and constraints to optimize the inner loop.\n    # Vector for calculating total cohort coverage (Secondary Objective O2)\n    cohort_counts_per_seq = np.ones(A.shape[0]) @ A\n    \n    # Vector for calculating underserved cohort coverage\n    underserved_coverage_per_seq = w @ A\n\n    # Define the three test cases as specified in the problem.\n    test_cases = [\n        # Test case 1: Baseline set packing\n        {'L': np.array([0, 0]), 'C_min': 0},\n        # Test case 2: Minimum evening representation and underserved coverage\n        {'L': np.array([0, 1]), 'C_min': 1},\n        # Test case 3: Infeasible evening quota\n        {'L': np.array([0, 2]), 'C_min': 0}\n    ]\n\n    results = []\n    \n    # Process each test case\n    for case in test_cases:\n        L = case['L']\n        C_min = case['C_min']\n        \n        feasible_solutions = []\n        \n        # Enumerate all 2^m possible selections using itertools.product\n        m = A.shape[1]\n        for x_tuple in product([0, 1], repeat=m):\n            x = np.array(x_tuple)\n            \n            # 1. Check non-overlap constraint: A*x = 1\n            if not np.all(A @ x = 1):\n                continue\n            \n            # 2. Check group quota constraint: B*x >= L\n            if not np.all(B @ x >= L):\n                continue\n            \n            # 3. Check underserved coverage constraint: (w^T * A) * x >= C_min\n            if not (underserved_coverage_per_seq @ x >= C_min):\n                continue\n            \n            # If all constraints pass, the solution is feasible.\n            # Calculate objective values for tie-breaking.\n            obj1_value = v @ x\n            obj2_cohorts = cohort_counts_per_seq @ x\n            indices = sorted([i + 1 for i, val in enumerate(x) if val == 1])\n            \n            feasible_solutions.append({\n                'obj1': obj1_value,\n                'obj2': obj2_cohorts,\n                'indices': indices\n            })\n\n        if not feasible_solutions:\n            # If no feasible solutions were found, the problem is infeasible.\n            results.append(False)\n        else:\n            # Sort solutions based on the hierarchical tie-breaking rule.\n            # Python's list.sort is stable, so we can sort by each key in reverse order of priority.\n            \n            # Tertiary: Lexicographically smallest list of indices (ascending)\n            feasible_solutions.sort(key=lambda s: s['indices'])\n            # Secondary: Number of cohorts covered (descending)\n            feasible_solutions.sort(key=lambda s: s['obj2'], reverse=True)\n            # Primary: Educational value (descending)\n            feasible_solutions.sort(key=lambda s: s['obj1'], reverse=True)\n            \n            # The first element after sorting is the optimal solution.\n            best_solution = feasible_solutions[0]\n            results.append(best_solution['indices'])\n            \n    # Format the final output string according to the specification.\n    # e.g., [[1,3,5],[2,3,4],False]\n    def format_result(item):\n        if isinstance(item, list):\n            return f\"[{','.join(map(str, item))}]\"\n        return str(item)\n\n    print(f\"[{','.join(map(format_result, results))}]\")\n\nsolve()\n\n```", "id": "3181267"}, {"introduction": "前面的练习侧重于如何“使用”集合包装模型来解决问题，而这个练习则转向“分析”解决问题的算法[@problem_id:3181347]。我们将深入探讨一个非常直观但可能并非最优的策略——“按权重贪心”算法。通过设计并分析一个专门的“对抗性实例”，你将亲眼见证这个简单启发式算法的局限性，并精确计算其性能的“近似比”。这个理论实践不仅能加深你对集合包装问题计算复杂度（NP-hard）的理解，还能让你明白为什么需要发展更复杂的算法来寻求最优解。", "problem": "考虑加权集合包装问题：给定一个有限基集 $U$ 和一个子集族 $\\mathcal{F} \\subseteq 2^{U}$，其中每个子集都有非负权重 $\\{w(S)\\}_{S \\in \\mathcal{F}}$，目标是选择一个子集族 $\\mathcal{P} \\subseteq \\mathcal{F}$，其中的集合两两不交，并使得 $\\sum_{S \\in \\mathcal{P}} w(S)$ 最大化。一个简单的按权重贪心算法会迭代地选择一个剩余集合中权重最大的集合 $S \\in \\mathcal{F}$，并删除所有与 $S$ 相交的集合，重复此过程直到没有集合剩下。\n\n请设计并分析一个仅限于大小为 $2$ 和 $3$ 的集合的对抗性实例，该实例导致按权重贪心算法选择一个次优解。您的实例应由 $m \\in \\mathbb{N}$ 个相同的构件组成，每个构件 $i \\in \\{1, \\dots, m\\}$ 基于六个不同的元素 $\\{a_{i}, b_{i}, x_{i}, y_{i}, u_{i}, v_{i}\\}$ 构建，包含三个集合：\n- 一个大小为 2 的集合 $S_{i}^{(2)} = \\{a_{i}, b_{i}\\}$，其权重为 $w(S_{i}^{(2)}) = w + \\varepsilon$，\n- 两个不相交的大小为 3 的集合 $S_{i,1}^{(3)} = \\{a_{i}, x_{i}, y_{i}\\}$ 和 $S_{i,2}^{(3)} = \\{b_{i}, u_{i}, v_{i}\\}$，每个集合的权重均为 $w(S_{i,1}^{(3)}) = w(S_{i,2}^{(3)}) = w$，\n其中 $w  0$ 且 $\\varepsilon \\in (0, w)$，并且不同索引 $i$ 的构件是不相交的。\n\n从集合包装和按权重贪心程序的核心定义出发，严格证明应用于您的实例的按权重贪心算法会选择 $m$ 个集合 $\\{S_{i}^{(2)}\\}_{i=1}^{m}$，而最优解会选择 $2m$ 个集合 $\\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}_{i=1}^{m}$。然后，计算近似比\n$$\\rho(m, w, \\varepsilon) = \\frac{\\text{贪心解的总权重}}{\\text{最优解的总权重}}$$\n作为 $m$、$w$ 和 $\\varepsilon$ 的函数，并求当 $\\varepsilon \\to 0^{+}$ 时的极限，以获得由此对抗性构造得出的极限最坏情况值。最后，解释这个极限值与将相同的构造思想推广到 $k$-集合包装问题（其中每个集合的大小最多为 $k$）时的预期值相比如何。\n\n将极限最坏情况近似比报告为单个精确数值。无需四舍五入。不涉及物理单位。", "solution": "该问题陈述是分析 NP 难优化问题的近似算法方面的一个有效练习。其提法恰当，在计算机科学理论中有科学依据，并且所有术语和条件都已精确定义。因此，我们可以进行严格的求解。\n\n该问题要求分析在按权重贪心启发式算法下，加权集合包装问题的一个特定对抗性实例。该实例由 $m \\in \\mathbb{N}$ 个相同且不相交的构件组成。\n\n首先，让我们将问题实例形式化。基集为 $U = \\bigcup_{i=1}^{m} U_{i}$，其中每个 $U_i = \\{a_{i}, b_{i}, x_{i}, y_{i}, u_{i}, v_{i}\\}$ 是构件 $i$ 的元素集。由于这些构件不相交，我们有 $|U| = 6m$。集合族为 $\\mathcal{F} = \\bigcup_{i=1}^{m} \\mathcal{F}_i$，其中 $\\mathcal{F}_i = \\{S_{i}^{(2)}, S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$。这些集合及其权重如下：\n- $S_{i}^{(2)} = \\{a_{i}, b_{i}\\}$，权重为 $w(S_{i}^{(2)}) = w + \\varepsilon$。\n- $S_{i,1}^{(3)} = \\{a_{i}, x_{i}, y_{i}\\}$，权重为 $w(S_{i,1}^{(3)}) = w$。\n- $S_{i,2}^{(3)} = \\{b_{i}, u_{i}, v_{i}\\}$，权重为 $w(S_{i,2}^{(3)}) = w$。\n\n参数受限于 $w  0$ 和 $\\varepsilon \\in (0, w)$。\n\n我们首先分析按权重贪心算法在此实例 $\\mathcal{F}$ 上的行为。该算法迭代地在所有当前可用集合中选择权重最大的一个。\n在初始步骤中，可用集合集为 $\\mathcal{F}$。$\\mathcal{F}$ 中集合的权重为 $w$ 或 $w+\\varepsilon$。由于 $\\varepsilon  0$，最大权重为 $w+\\varepsilon$。此权重与 $m$ 个形如 $S_{i}^{(2)}$ 的集合相关联。\n\n算法将选择这些最大权重集合中的一个。不失一般性地，我们假设它在第一次迭代中选择了 $S_{1}^{(2)}$。此集合的权重为 $w(S_{1}^{(2)}) = w + \\varepsilon$。选择 $S_{1}^{(2)}$ 后，算法会移除 $S_{1}^{(2)}$ 本身以及 $\\mathcal{F}$ 中所有与 $S_{1}^{(2)} = \\{a_1, b_1\\}$ 有非空交集的其他集合。让我们找出这些集合：\n- $S_{1,1}^{(3)} = \\{a_1, x_1, y_1\\}$ 与 $S_{1}^{(2)}$ 相交，因为 $a_1 \\in S_{1}^{(2)} \\cap S_{1,1}^{(3)}$。\n- $S_{1,2}^{(3)} = \\{b_1, u_1, v_1\\}$ 与 $S_{1}^{(2)}$ 相交，因为 $b_1 \\in S_{1}^{(2)} \\cap S_{1,2}^{(3)}$。\n\n根据构造，来自不同构件 $i \\neq j$ 的集合是不相交的。因此，对于 $j \\neq 1$，$S_{j}^{(2)}$、$S_{j,1}^{(3)}$ 和 $S_{j,2}^{(3)}$ 均不与 $S_{1}^{(2)}$ 相交。\n第一次迭代后，剩余的可用集合集为 $\\mathcal{F}' = \\bigcup_{i=2}^{m} \\mathcal{F}_i$。问题现在被简化为具有 $m-1$ 个构件的相同初始结构。\n\n根据归纳法，贪心算法将继续选择 $S_{2}^{(2)}$，然后是 $S_{3}^{(2)}$，依此类推，直到 $S_{m}^{(2)}$。在每一步 $i$，选择 $S_{i}^{(2)}$ 会导致 $S_{i,1}^{(3)}$ 和 $S_{i,2}^{(3)}$ 被移除。贪心算法产生的最终解是两两不交的集合集 $\\mathcal{P}_{G} = \\{S_{1}^{(2)}, S_{2}^{(2)}, \\dots, S_{m}^{(2)}\\}$。\n这个贪心解的总权重 $W_G$ 是所选集合的权重之和：\n$$W_G = \\sum_{i=1}^{m} w(S_{i}^{(2)}) = \\sum_{i=1}^{m} (w + \\varepsilon) = m(w + \\varepsilon)$$\n\n接下来，我们必须确定最优解。最优解是一个子集族 $\\mathcal{P}_{OPT} \\subseteq \\mathcal{F}$，其中的集合两两不交且总权重最大。由于这些构件是不相交的，整个优化问题可以分解为 $m$ 个独立的子问题，每个构件一个。总的最优权重是单个构件最优权重的 $m$ 倍。\n让我们分析在 $\\mathcal{F}_i$ 上的单个构件子问题。集合为 $S_{i}^{(2)}$、$S_{i,1}^{(3)}$ 和 $S_{i,2}^{(3)}$。我们寻求从这三个集合中找到一个最大权重包装。\n构件 $i$ 的可能的最大包装有：\n1. $\\{S_{i}^{(2)}\\}$: 我们不能包含 $S_{i,1}^{(3)}$ 或 $S_{i,2}^{(3)}$，因为它们都与 $S_{i}^{(2)}$ 相交。此包装的权重为 $w(S_{i}^{(2)}) = w + \\varepsilon$。\n2. $\\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$: 这两个集合是不相交的，因为 $S_{i,1}^{(3)} \\cap S_{i,2}^{(3)} = \\{a_{i}, x_{i}, y_{i}\\} \\cap \\{b_{i}, u_{i}, v_{i}\\} = \\emptyset$。此包装的权重为 $w(S_{i,1}^{(3)}) + w(S_{i,2}^{(3)}) = w + w = 2w$。\n\n为了找到该构件的最优解，我们比较这两个包装的权重。已知 $\\varepsilon \\in (0, w)$，这意味着 $\\varepsilon  w$。因此，$w + \\varepsilon  w + w = 2w$。\n单个构件 $i$ 的最优包装是 $\\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$，总权重为 $2w$。\n整体最优解是每个构件最优解的并集：\n$\\mathcal{P}_{OPT} = \\bigcup_{i=1}^{m} \\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$。\n最优解的总权重 $W_{OPT}$ 为：\n$$W_{OPT} = \\sum_{i=1}^{m} (w(S_{i,1}^{(3)}) + w(S_{i,2}^{(3)})) = \\sum_{i=1}^{m} (w + w) = 2mw$$\n\n现在，我们可以计算近似比 $\\rho(m, w, \\varepsilon)$，即贪心解的权重与最优解的权重之比：\n$$\\rho(m, w, \\varepsilon) = \\frac{W_G}{W_{OPT}} = \\frac{m(w + \\varepsilon)}{2mw} = \\frac{w + \\varepsilon}{2w} = \\frac{1}{2} + \\frac{\\varepsilon}{2w}$$\n作为检验，我们注意到该比率与 $m$ 无关，这与实例的重复结构所预期的相符。\n\n问题要求计算当 $\\varepsilon \\to 0^{+}$ 时该比率的极限最坏情况值。\n$$\\lim_{\\varepsilon \\to 0^{+}} \\rho(m, w, \\varepsilon) = \\lim_{\\varepsilon \\to 0^{+}} \\left(\\frac{1}{2} + \\frac{\\varepsilon}{2w}\\right)$$\n由于 $w  0$ 是一个固定的正常数，当 $\\varepsilon \\to 0^{+}$ 时，项 $\\frac{\\varepsilon}{2w}$ 趋近于 0。\n$$\\lim_{\\varepsilon \\to 0^{+}} \\rho(m, w, \\varepsilon) = \\frac{1}{2} + 0 = \\frac{1}{2}$$\n\n最后，我们解释这个结果。该实例是 $k$-集合包装的一个例子，其中最大集合大小为 $k=3$。按权重贪心算法被一个大小为 2、权重稍高为 $w+\\varepsilon$ 的集合 $S_i^{(2)}$ 所“引诱”。选择这个“诱饵”集合会阻止选择两个不相交的集合 $S_{i,1}^{(3)}$ 和 $S_{i,2}^{(3)}$，它们的大小均为 3，权重均为 $w$。该构件的最优解由这两个集合组成，总权重为 $2w$。贪心解与最优解权重的极限比率为 $w/(2w) = 1/2$。\n这个构造是用于建立贪心算法近似比下界的典型例子。对于一个广义的 $k$-集合包装问题（最大集合大小为 $k$），可以构造类似的构件。人们会使用一个大小为 $k-1$、权重为 $w+\\varepsilon$ 的“诱饵”集合，该集合与 $k-1$ 个不相交的大小为 $k$、权重各为 $w$ 的集合相交。贪心算法会选择该诱饵集合，总权重为 $w+\\varepsilon$。最优解将由 $k-1$ 个较大的集合组成，总权重为 $(k-1)w$。当 $\\varepsilon \\to 0^{+}$ 时，得到的近似比将趋近于 $\\frac{w}{(k-1)w} = \\frac{1}{k-1}$。\n在我们的问题中，$k=3$，所以广义公式预测的最坏情况比率为 $\\frac{1}{3-1} = \\frac{1}{2}$。我们计算出的极限值与此预期完全相符。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3181347"}]}