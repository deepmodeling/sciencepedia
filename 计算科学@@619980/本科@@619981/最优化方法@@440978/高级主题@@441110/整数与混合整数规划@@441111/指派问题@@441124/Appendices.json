{"hands_on_practices": [{"introduction": "我们从一个经典的实际应用场景入手。这项练习将指派问题的抽象概念置于一个易于理解的现实情境中。您将练习如何将一个实际需求——在此案例中是最大化技能匹配度——转化为一个规范的指派问题数学模型，并找出其最优解。通过这个过程，您将建立对指派问题核心结构的直观理解和建模能力。[@problem_id:2223397]", "problem": "一家名为 Code-Forge Solutions 的科技公司正在启动其年度指导计划。四位新晋实习开发者——Ben、Chloe、David 和 Emily——将与四位资深工程师进行一对一的配对指导。这四位资深工程师是 Alvarez 博士、Borges 博士、Chen 博士和 Dupont 博士。为确保最有效的指导，项目主管为每一种可能的实习生-导师配对评估了一个“技能兼容性得分”。分数范围为 0 到 100，如下表所示。\n\n| 实习生 | Alvarez 博士 | Borges 博士 | Chen 博士 | Dupont 博士 |\n| :---------- | :---------- | :--------- | :------- | :--------- |\n| Ben         | 82          | 85         | 70       | 90         |\n| Chloe       | 78          | 82         | 81       | 75         |\n| David       | 75          | 77         | 92       | 80         |\n| Emily       | 88          | 79         | 73       | 84         |\n\n每位实习生必须被分配给且仅分配给一位资深工程师，每位资深工程师也必须指导且仅指导一位实习生。你的任务是确定实习生与导师的分配方案，以使技能兼容性得分之和最大化。这个可能的最大总分是多少？", "solution": "设 $S$ 为分数矩阵，其行由实习生 $\\{ \\text{Ben}, \\text{Chloe}, \\text{David}, \\text{Emily} \\}$ 索引，列由导师 $\\{ \\text{Alvarez}, \\text{Borges}, \\text{Chen}, \\text{Dupont} \\}$ 索引。一个分配方案是从实习生到导师的一一对应（双射）$\\sigma$，其总分为\n$$\nT(\\sigma)=\\sum_{\\text{apprentice } a} S\\bigl(a,\\sigma(a)\\bigr).\n$$\n对于任何分配方案，每位实习生贡献的分数最多是其所在行的最大值，因此\n$$\nT(\\sigma) \\leq \\sum_{\\text{apprentice } a} \\max_{\\text{mentor } m} S(a,m).\n$$\n计算每行的最大值：\n- 对于 Ben: $\\max\\{82,85,70,90\\}=90$，在与 Dupont 配对时达到。\n- 对于 Chloe: $\\max\\{78,82,81,75\\}=82$，在与 Borges 配对时达到。\n- 对于 David: $\\max\\{75,77,92,80\\}=92$，在与 Chen 配对时达到。\n- 对于 Emily: $\\max\\{88,79,73,84\\}=88$，在与 Alvarez 配对时达到。\n\n这些最大值出现在不同的列中（Dupont, Borges, Chen, Alvarez），因此以下分配方案\n$$\n\\text{Ben} \\to \\text{Dupont},\\quad \\text{Chloe} \\to \\text{Borges},\\quad \\text{David} \\to \\text{Chen},\\quad \\text{Emily} \\to \\text{Alvarez}\n$$\n是可行的，并且达到了上限。其总分为\n$$\nT=90+82+92+88=352.\n$$\n因此，通过将一个可行的分配方案与上限值相匹配，这个值就是可能的最大总分。", "answer": "$$\\boxed{352}$$", "id": "2223397"}, {"introduction": "为什么指派问题可以被高效求解？它的“简单性”背后隐藏着深刻的数学原理。本练习将引导您探索指派问题优美的理论基础。通过考察“完全幺模性”($\\text{Total Unimodularity}$)这一关键概念，您将理解为何线性规划松弛能够为指派问题（一种二分图匹配问题）提供整数解，以及当这种特殊的二分结构被破坏时，整数性又将如何丧失。[@problem_id:3099237]", "problem": "考虑优化方法中的经典指派问题：给定一组由 $i \\in \\{1,2,3\\}$ 索引的工人和一组由 $j \\in \\{1,2,3\\}$ 索引的工作，将工人 $i$ 分配给工作 $j$ 的报酬为 $c_{ij} \\in \\mathbb{R}$，目标是在排他性约束下选择分配方案以最大化总报酬。标准的整数规划模型使用决策变量 $x_{ij} \\in \\{0,1\\}$，其中 $x_{ij} = 1$ 表示工人 $i$ 被分配给工作 $j$，否则 $x_{ij} = 0$。线性规划 (LP) 松弛将整数性要求放宽为 $x_{ij} \\in [0,1]$。\n\n从以下基础出发：\n- 指派问题的基本模型由以下线性约束定义：对每个 $i \\in \\{1,2,3\\}$，$\\sum_{j=1}^{3} x_{ij} = 1$；对每个 $j \\in \\{1,2,3\\}$，$\\sum_{i=1}^{3} x_{ij} = 1$；目标是最大化 $\\sum_{i=1}^{3}\\sum_{j=1}^{3} c_{ij} x_{ij}$。\n- 完全幺模性 (Total Unimodularity, TUM) 的概念是指，如果一个矩阵 $A$ 的每个方子矩阵的行列式的值都在 $\\{0, \\pm 1\\}$ 中，则该矩阵是完全幺模的。当约束矩阵是完全幺模的且右端向量是整数时，可行域的每个极点都是整数的。\n\n第一部分 (二分图基线)：考虑由 $c_{11} = 5$, $c_{22} = 5$, $c_{33} = 5$ 定义的报酬，以及对于所有 $i \\neq j$ 的 $(i,j)$，$c_{ij} = 1$。定义上述标准指派模型及其 LP 松弛。利用完全幺模性的定义和工人-工作约束的二分图关联结构，从第一性原理出发，解释为什么在这种二分图设置下，LP 松弛具有整数极点。\n\n第二部分 (破坏整数性的最小改动)：现在将约束改为在一个包含三个实体 $V = \\{1,2,3\\}$ 的集合上的非二分图匹配结构，决策变量为 $y_{12}, y_{23}, y_{31} \\in [0,1]$，表示是否选择无向对 $\\{p,q\\}$。对每个 $v \\in V$ 施加度约束 $\\sum_{e \\in \\delta(v)} y_{e} \\leq 1$，其中 $\\delta(v)$ 是与 $v$ 关联的边的集合。设三条边上的报酬为 $c_{12} = 3$, $c_{23} = 3$, $c_{31} = 3$，并考虑 $y_{e} \\in \\{0,1\\}$ 的整数线性规划 (ILP) 版本和 $y_{e} \\in [0,1]$ 的 LP 松弛版本。\n\n使用核心定义，通过计算一个合适的方子矩阵的行列式，检验非二分图约束矩阵是否是完全幺模的。然后，计算此非二分图实例的 ILP 和 LP 松弛的最优值。最后，报告此非二分图实例的整数性差距，定义为 $Z_{\\text{LP}} - Z_{\\text{ILP}}$。将最终答案表示为单个实数。如果选择四舍五入，请将答案保留到四位有效数字。不需要单位。", "solution": "此问题包含两部分。第一部分要求解释为什么标准指派问题的线性规划 (LP) 松弛具有整数极点。第二部分要求计算一个相关的但非二分图匹配问题的整数性差距。\n\n### 第一部分：二分图指派问题和整数性\n\n指派问题定义在一组工人 $i \\in \\{1, 2, 3\\}$ 和一组工作 $j \\in \\{1, 2, 3\\}$ 上。决策变量是 $x_{ij}$，其中如果工人 $i$ 被分配给工作 $j$，则 $x_{ij} = 1$，否则 $x_{ij} = 0$。目标是最大化总报酬，即 $\\sum_{i=1}^{3}\\sum_{j=1}^{3} c_{ij} x_{ij}$。\n\n约束条件如下：\n1. 每个工人必须被分配到恰好一个工作：对每个 $i \\in \\{1, 2, 3\\}$，$\\sum_{j=1}^{3} x_{ij} = 1$。\n2. 每个工作必须被分配给恰好一个工人：对每个 $j \\in \\{1, 2, 3\\}$，$\\sum_{i=1}^{3} x_{ij} = 1$。\n\n整数线性规划 (ILP) 要求 $x_{ij} \\in \\{0, 1\\}$。LP 松弛将其替换为 $x_{ij} \\in [0, 1]$，或者更简单地是 $x_{ij} \\geq 0$，因为约束已经隐含了 $x_{ij} \\leq 1$。\n\n约束可以用矩阵形式写为 $A\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x}$ 是包含9个变量 $x_{ij}$ 的列向量，$A$ 是 $6 \\times 9$ 的约束矩阵，$\\mathbf{b}$ 是一个包含六个1的列向量。对应于变量 $x_{ij}$ 的 $A$ 的每一列都恰好有两个非零元素，且都等于1。一个1出现在对应于工人 $i$ 的约束的行中，另一个1出现在对应于工作 $j$ 的行中。\n\n这个结构是关键。矩阵 $A$ 是完全二分图 $K_{3,3}$ 的点边关联矩阵，其中一组顶点代表工人，另一组代表工作。$A$ 的列对应于图的边，行对应于图的顶点。如果一个矩阵的每个方子矩阵的行列式都在集合 $\\{0, 1, -1\\}$ 中，则该矩阵是完全幺模 (TUM) 的。一个图的关联矩阵是完全幺模的，当且仅当该图是二分图。由于指派问题的约束矩阵是二分图的关联矩阵，所以它是完全幺模的。\n\n为了从第一性原理证明这一点，我们考虑 $A$ 的任意一个 $k \\times k$ 子矩阵 $S$。我们可以通过对 $k$ 进行归纳来证明 $\\det(S) \\in \\{0, 1, -1\\}$。\n- **基础情况 ($k=1$):** 一个 $1 \\times 1$ 的子矩阵就是 $A$ 的一个元素。$A$ 的元素是 $0$ 或 $1$。因此，行列式为 $0$ 或 $1$。\n- **归纳步骤 ($k  1$):** 假设所有 $(k-1) \\times (k-1)$ 的子矩阵的行列式都在 $\\{0, 1, -1\\}$ 中。考虑一个 $k \\times k$ 的子矩阵 $S$。\n    1. 如果 $S$ 有一列全为零，则 $\\det(S) = 0$。\n    2. 如果 $S$ 有一列恰好有一个非零元素（该元素必然是1），我们可以沿该列展开行列式。行列式的值是 $\\pm 1$ 乘以 $A$ 的一个 $(k-1) \\times (k-1)$ 子矩阵的行列式。根据归纳假设，这个子式的值在 $\\{0, 1, -1\\}$ 中，因此 $\\det(S) \\in \\{0, 1, -1\\}$。\n    3. 如果 $S$ 的每一列至少有两个非零元素，由于 $A$ 的每一列恰好有两个1，因此 $S$ 的每一列也必须恰好有两个1。$A$ 的行可以被划分为对应工人约束的集合 ($U$) 和对应工作约束的集合 ($V$)。$A$ 的任何一列在 $U$-行中有一个1，在 $V$-行中有一个1。相应地，将 $S$ 的行划分为 $S_U$ 和 $S_V$。如果我们将 $S_U$ 中的行相加，会得到一个行向量。如果我们将 $S_V$ 中的行相加，会得到另一个行向量。对于 $S$ 中的任何一列，它的两个1必须分布在来自 $S_U$ 和 $S_V$ 的行之间。如果对于每一列，一个1位于来自 $S_U$ 的行中，另一个位于来自 $S_V$ 的行中，那么 $S_U$ 中各行之和等于 $S_V$ 中各行之和。这意味着 $S$ 的行是线性相关的，因此 $\\det(S) = 0$。如果存在一列，其两个1都位于 $S_U$ 中或都位于 $S_V$ 中，这将与二分图结构相矛盾。对于二分图的关联矩阵，这种情况不会发生。\n\n由于 $A$ 是完全幺模的，且右端向量 $\\mathbf{b}$ 是整数的（所有元素均为1），线性规划的一个基本定理指出，由 $\\{ \\mathbf{x} | A\\mathbf{x} = \\mathbf{b}, \\mathbf{x} \\geq 0 \\}$ 定义的可行域的所有极点都是整数的。因为线性规划的最优解总可以在一个极点上找到，所以指派问题的 LP 松弛的最优解将由整数值构成。\n\n### 第二部分：非二分图匹配和整数性差距\n\n我们现在考虑一个在非二分图上的匹配问题，具体来说是一个3-圈，其顶点为 $V=\\{1,2,3\\}$，边为 $\\{1,2\\},\\{2,3\\},\\{3,1\\}$。决策变量为 $y_{12}, y_{23}, y_{31}$。约束条件是 $\\sum_{e \\in \\delta(v)} y_e \\leq 1$ 对每个顶点 $v$ 成立，其中 $\\delta(v)$ 是与 $v$ 关联的边的集合。\n约束条件是：\n$y_{12} + y_{31} \\leq 1$ (对于顶点 1)\n$y_{12} + y_{23} \\leq 1$ (对于顶点 2)\n$y_{23} + y_{31} \\leq 1$ (对于顶点 3)\n目标是最大化 $Z = 3y_{12} + 3y_{23} + 3y_{31}$。\n\n首先，我们检验约束矩阵是否是完全幺模的。矩阵 $A$ 是：\n$$ A = \\begin{pmatrix} 1  0  1 \\\\ 1  1  0 \\\\ 0  1  1 \\end{pmatrix} $$\n这个矩阵是一个 $3 \\times 3$ 的方阵，所以它本身就是一个子矩阵。它的行列式是：\n$$ \\det(A) = 1(1 \\cdot 1 - 0 \\cdot 1) - 0(1 \\cdot 1 - 0 \\cdot 1) + 1(1 \\cdot 1 - 1 \\cdot 0) = 1(1) + 1(1) = 2 $$\n由于 $\\det(A) = 2$，不在 $\\{0, 1, -1\\}$ 集合中，所以矩阵 $A$ 不是完全幺模的。这是预料之中的，因为它是奇圈 ($C_3$) 的关联矩阵，而奇圈是非二分图。\n\n接下来，我们计算 ILP 的最优值 $Z_{\\text{ILP}}$，其中 $y_e \\in \\{0,1\\}$。我们想找到一个总权重最大的匹配（一组没有公共顶点的边）。我们最多只能选择一条边。例如，如果我们选择边 $\\{1,2\\}$ ($y_{12}=1$)，那么顶点1和顶点2都被覆盖。约束 $y_{12} + y_{31} \\leq 1$ 和 $y_{12} + y_{23} \\leq 1$ 迫使 $y_{31}=0$ 和 $y_{23}=0$。解 $(y_{12},y_{23},y_{31})=(1,0,0)$ 是可行的。目标值为 $3(1) + 3(0) + 3(0) = 3$。根据对称性，选择任何一条边都会得到目标值3。我们不能选择两条或更多条边，因为它们会共享一个顶点。因此，整数规划的最优值是 $Z_{\\text{ILP}} = 3$。\n\n现在，我们计算 LP 松弛的最优值 $Z_{\\text{LP}}$，其中 $y_e \\in [0,1]$。\n考虑可行点 $y_{12} = 0.5$, $y_{23} = 0.5$, $y_{31} = 0.5$。\n检查约束条件：\n$y_{12} + y_{31} = 0.5 + 0.5 = 1 \\leq 1$\n$y_{12} + y_{23} = 0.5 + 0.5 = 1 \\leq 1$\n$y_{23} + y_{31} = 0.5 + 0.5 = 1 \\leq 1$\n该点是可行的。在该点的目标值为 $Z = 3(0.5 + 0.5 + 0.5) = 3(1.5) = 4.5$。\n为了证明这是最优的，我们将三个约束相加：\n$(y_{12} + y_{31}) + (y_{12} + y_{23}) + (y_{23} + y_{31}) \\leq 1 + 1 + 1$\n$2(y_{12} + y_{23} + y_{31}) \\leq 3$\n$y_{12} + y_{23} + y_{31} \\leq 1.5$\n目标函数为 $Z = 3(y_{12} + y_{23} + y_{31})$。将推导出的不等式两边乘以3，我们得到目标函数的一个上界：\n$Z = 3(y_{12} + y_{23} + y_{31}) \\leq 3(1.5) = 4.5$。\n由于我们找到了一个达到此上界的可行解，因此 LP 松弛的最优值为 $Z_{\\text{LP}} = 4.5$。\n\n最后，整数性差距是 LP 最优值与 ILP 最优值之差：\n整数性差距 = $Z_{\\text{LP}} - Z_{\\text{ILP}} = 4.5 - 3 = 1.5$。", "answer": "$$ \\boxed{1.5} $$", "id": "3099237"}, {"introduction": "在许多决策场景中，仅仅找到一个最优解是不够的；我们往往需要一系列高质量的备选方案。这个高级实践练习将挑战您应用分支定界法($\\text{branch-and-bound}$)来系统地找出成本最低的前 $k$ 个指派方案。通过完成这项任务，您将体验到如何将一个基础的指派问题求解器作为核心模块，嵌入到更复杂的算法框架中，从而对解空间进行更全面的探索。[@problem_id:3099154]", "problem": "给定经典的线性分配问题：对于一个整数维度 $n$、一个成本矩阵 $C \\in \\mathbb{R}^{n \\times n}$ 以及 $\\{0,1,\\dots,n-1\\}$ 上所有排列的集合 $\\Pi_n$，目标是找到一个排列 $\\pi \\in \\Pi_n$，以最小化总成本 $\\sum_{i=0}^{n-1} C_{i, \\pi(i)}$，并满足一对一的分配约束。分配问题可以被表述为一个带有全幺模约束矩阵的线性规划（LP）问题，这确保了其连续松弛问题的任何最优解都是整数解。求解单个最优分配的一种高效组合算法是匈牙利算法。\n\n在此任务中，您将利用分配问题的结构，不仅计算最优解，还要按总成本的非递减顺序计算 $k$ 个最佳的不同分配。您将使用一种系统的分支定界过程，该过程通过固定或禁止特定的分配对来划分排列空间，并重复求解仍属于分配问题类别的子问题。\n\n使用以下维度为 $5 \\times 5$ 的固定成本矩阵：\n$$\nC \\;=\\;\n\\begin{bmatrix}\n3  3  9  9  9 \\\\\n3  3  9  9  9 \\\\\n9  9  3  4  4 \\\\\n9  9  4  3  4 \\\\\n9  9  4  4  3\n\\end{bmatrix}.\n$$\n所有条目均为无单位的抽象成本。\n\n用于您的推理和推导的基本依据：\n- 分配问题是在满足每个 $i$ 的 $\\sum_{j=0}^{n-1} x_{ij} = 1$、每个 $j$ 的 $\\sum_{i=0}^{n-1} x_{ij} = 1$ 以及所有 $i,j$ 的 $x_{ij} \\in \\{0,1\\}$ 约束条件下，最小化 $\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} C_{ij} x_{ij}$。其约束矩阵是全幺模的，因此使用 $x_{ij} \\in [0,1]$ 的线性规划松弛会产生整数最优极点。\n- 求解单个分配问题的一种标准且经过充分测试的方法是匈牙利算法，或等效的线性总和分配例程，它为给定的成本矩阵返回一个最优排列。\n\n您的程序必须实现一种分支定界方法，利用分配结构找到 $k$ 个最佳分配。分支必须基于包含或排除特定的行-列对，并在每次分支后重新求解一个分配子问题。每个子问题必须保持为分配问题，并被精确地求解。定界由子问题的最优目标值给出。搜索必须以最佳优先的顺序进行，使用一个以当前子问题的最优成本为键的优先队列。成本相等的分配应按其排列向量 $(\\pi(0),\\pi(1),\\dots,\\pi(n-1))$ 的字典序排序。\n\n定义以下具有不同目标数量 $k$ 的测试套件：\n- $k = 0$,\n- $k = 1$,\n- $k = 3$,\n- $k = 5$,\n- $k = 10$.\n\n对于每个 $k$，按非递减顺序列出 $k$ 个最佳不同分配的总成本。不同的分配意味着不同的排列 $\\pi$；允许相等的总成本，并应在输出列表中作为重复值出现。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含汇总为列表的列表的结果，每个内部列表对应按上述顺序排列的一个 $k$ 值。该行必须是一个精确的、用方括号括起来、逗号分隔的 Python 风格字面量，不含任何额外文本。例如，`[[],[15],[15,15,17],\\dots]` 这样的行是可以接受的。\n\n此问题不涉及物理单位。角度单位不适用。百分比不适用。所有数值答案都应以整数形式返回。程序必须是自包含的，并且只能使用指定的执行环境。\n\n测试套件覆盖范围说明：\n- $k = 0$ 是一个边界情况，应返回一个空列表。\n- $k = 1$ 用于测试标准的单个最优分配检索。\n- $k = 3$ 和 $k = 5$ 测试生成多个次优分配，包括成本相等的情况。\n- $k = 10$ 测试在探索多个分区时，分支定界机制的更深层枚举和正确性。", "solution": "解决方案将通过实现一个分支定界算法来开发，以找到给定成本矩阵的 $k$ 个最佳分配。该方法是 Murty 和 Lawler 提出的用于在组合优化问题中寻找 $k$ 个最佳解的算法的推广。此过程的核心是在一个状态空间树上进行最佳优先搜索，其中每个节点代表一个子问题，对应于所有可能排列的一个子集。\n\n指导该算法的基本原则如下：\n\n1.  **分支定界搜索**：该算法通过系统地划分所有排列的空间 $\\Pi_n$ 来进行探索。搜索由每个分区内解的成本下界引导，从而使算法能够优先处理解空间中更有希望的区域。这是一种 A* 搜索的形式。\n\n2.  **状态空间树与划分**：搜索树中的一个节点代表一个由特定分配约束集定义的子问题。这些约束的形式可以是强制执行一个特定的分配 $(i, j)$（一个*包含*或*固定*的分配），也可以是不允许它（一个*排除*或*禁止*的分配）。当为子问题 $P$ 找到一个解 $\\pi$ 时，$P$ 的解空间被划分为一组不相交的子集，其并集为 $P \\setminus \\{\\pi\\}$。这是通过创建新的子问题来实现的，每个子问题都继承 $P$ 的约束，并添加一个新约束，这些新约束共同使 $\\pi$ 无效，同时覆盖所有其他可能性。具体来说，如果 $\\pi$ 由在父问题 $P$ 中未被固定的分配 $\\{(r_0, c_0), (r_1, c_1), \\dots, (r_{m-1}, c_{m-1})\\}$ 组成，我们生成 $m$ 个新子问题。第 $i$ 个子问题添加了固定分配 $(r_0, c_0), \\dots, (r_{i-1}, c_{i-1})$ 和禁止分配 $(r_i, c_i)$ 的约束。\n\n3.  **下界确定**：对于任何子问题（树中的一个节点），该子问题的最优解为相应解空间分区内任何分配的成本提供了一个有效的下界。关键的洞见在于，每个由一组固定和禁止的分配定义的子问题，其本身就是一个分配问题。我们可以使用标准的分配算法来最优地求解它。为此，我们使用 `scipy.optimize.linear_sum_assignment` 函数，它是匈牙利算法或拍卖算法等算法的高效实现。它求解分配问题的线性规划松弛，由于约束矩阵的全幺模性，这保证了 $\\{0,1\\}$ 问题的一个整数（因而是最优的）解。\n\n4.  **使用优先队列的最佳优先搜索**：为确保按成本的非递减顺序找到解，使用一个优先队列（最小堆）来管理活跃的子问题。优先队列中的每个条目代表一个潜在的下一个最优解，存储了子问题的最优成本和排列，以及定义它的约束。优先队列主要按成本排序。这保证了算法总是扩展成本下界最低的节点，这一策略被称为最佳优先搜索。为了处理成本相等的情况并确保确定性输出，排列向量本身被用作优先队列的次要键，这实现了为成本相等的分配指定的字典序排序。\n\n总体算法流程如下：\n\n1.  **初始化**：创建一个空列表 `k_best_solutions` 来存储结果。初始化一个优先队列 `pq` 来管理候选解，并使用一个集合 `found_perms` 来跟踪已添加到结果中的不同排列，以避免重复。\n\n2.  **根解**：求解初始的、无约束的分配问题，以找到全局最优解 $(\\pi_1, c_1)$。该解是一个候选解，并将相应的节点推入优先队列。\n\n3.  **迭代搜索**：算法进入一个循环，直到找到 $k$ 个解或优先队列为空。在每次迭代中：\n    a. 从优先队列中提取成本最低的候选解 $(\\pi, c, \\text{fixed}, \\text{forbidden})$。\n    b. 如果排列 $\\pi$ 之前未被找到，则将其记录为下一个最优解，并将其成本 $c$ 添加到结果列表中。\n    c. 如原则 2 所述，通过相对于解 $\\pi$ 划分由 $(\\text{fixed}, \\text{forbidden})$ 定义的解空间，生成一组新的子子问题。\n    d. 求解每个新子问题。如果找到一个有效的、成本有限的解，则将这个新的候选解 $(\\pi', c', \\dots)$ 添加到优先队列中。\n\n4.  **子问题构建**：为了求解一个具有一组固定分配 $F$ 和禁止分配 $X$ 的子问题，我们构建一个简化的分配问题。固定分配的成本被求和。与这些分配对应的行和列被移除，为剩余未分配的行和列创建一个较小的成本矩阵。禁止的分配 $X$ 通过将此简化成本矩阵中的相应条目设置为无穷大来处理。然后对这个简化的矩阵调用 `linear_sum_assignment` 函数。子问题解的总成本是固定成本与简化问题最优成本之和。\n\n这个系统化的过程保证了 $k$ 个最佳的不同分配会以其成本的正确的、非递减的顺序被找到。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the k-best assignment problem for a fixed cost matrix and a suite of k values.\n    \"\"\"\n    C = np.array([\n        [3, 3, 9, 9, 9],\n        [3, 3, 9, 9, 9],\n        [9, 9, 3, 4, 4],\n        [9, 9, 4, 3, 4],\n        [9, 9, 4, 4, 3]\n    ], dtype=np.int64)\n\n    test_cases = [0, 1, 3, 5, 10]\n    \n    all_results = []\n    for k in test_cases:\n        result_costs = k_best_assignments(C, k)\n        all_results.append(result_costs)\n\n    # Format the final output string as a list of lists literal with no spaces.\n    final_output = \"[\" + \",\".join([str(sublist).replace(\" \", \"\") for sublist in all_results]) + \"]\"\n    print(final_output)\n\ndef k_best_assignments(C, k):\n    \"\"\"\n    Finds the k-best assignments for a given cost matrix C using a branch-and-bound algorithm.\n\n    Args:\n        C (np.ndarray): The n x n cost matrix.\n        k (int): The number of best assignments to find.\n\n    Returns:\n        list: A list of the total costs of the k-best assignments, in non-decreasing order.\n    \"\"\"\n    if k == 0:\n        return []\n\n    n = C.shape[0]\n    infinity = np.iinfo(np.int64).max\n    \n    # Priority queue stores tuples: (cost, perm, fixed_assignments, forbidden_assignments)\n    # The tuple structure allows heapq to tie-break on perm for lexicographical order.\n    pq = []\n    \n    k_best_costs = []\n    found_perms = set()\n\n    def solve_subproblem(fixed, forbidden):\n        \"\"\"\n        Solves an assignment subproblem defined by fixed and forbidden assignments.\n        \n        Args:\n            fixed (tuple): A tuple of (row, col) pairs that must be in the solution.\n            forbidden (tuple): A tuple of (row, col) pairs that are disallowed.\n\n        Returns:\n            tuple: A tuple (cost, permutation) for the subproblem's optimal solution.\n                   Returns (infinity, None) if no solution exists.\n        \"\"\"\n        fixed_cost = sum(C[r, c] for r, c in fixed)\n        \n        fixed_rows = {r for r, c in fixed}\n        fixed_cols = {c for r, c in fixed}\n        \n        rows_to_solve = [i for i in range(n) if i not in fixed_rows]\n        cols_to_solve = [i for i in range(n) if i not in fixed_cols]\n\n        if not rows_to_solve:\n            perm_list = [-1] * n\n            for r,c in fixed:\n                perm_list[r] = c\n            return fixed_cost, tuple(perm_list)\n\n        sub_C = C[np.ix_(rows_to_solve, cols_to_solve)].copy()\n        \n        for r_orig, c_orig in forbidden:\n            if r_orig in rows_to_solve and c_orig in cols_to_solve:\n                r_sub = rows_to_solve.index(r_orig)\n                c_sub = cols_to_solve.index(c_orig)\n                sub_C[r_sub, c_sub] = infinity\n        \n        row_ind, col_ind = linear_sum_assignment(sub_C)\n        sub_cost = sub_C[row_ind, col_ind].sum()\n\n        if sub_cost >= infinity:\n            return infinity, None\n\n        total_cost = fixed_cost + sub_cost\n        \n        perm = [-1] * n\n        for r, c in fixed:\n            perm[r] = c\n        \n        for i in range(len(row_ind)):\n            perm[rows_to_solve[row_ind[i]]] = cols_to_solve[col_ind[i]]\n            \n        return total_cost, tuple(perm)\n\n    # Solve the root problem (1st best solution)\n    initial_fixed = tuple()\n    initial_forbidden = tuple()\n    cost, perm = solve_subproblem(initial_fixed, initial_forbidden)\n\n    if perm is not None:\n        heapq.heappush(pq, (cost, perm, initial_fixed, initial_forbidden))\n\n    while pq and len(k_best_costs)  k:\n        cost, perm, fixed, forbidden = heapq.heappop(pq)\n        \n        if perm in found_perms:\n            continue\n\n        k_best_costs.append(int(cost))\n        found_perms.add(perm)\n\n        # Branch from the newly found solution by partitioning its subproblem\n        current_assignments = set((i, p) for i, p in enumerate(perm))\n        \n        # Identify assignments made in this subproblem (not fixed by parent)\n        assignments_in_subproblem = sorted(list(current_assignments - set(fixed)))\n\n        for i in range(len(assignments_in_subproblem)):\n            # Create a new partition by fixing previous assignments and forbidding the current one\n            newly_fixed_prefix = assignments_in_subproblem[:i]\n            assignment_to_forbid = assignments_in_subproblem[i]\n            \n            new_fixed = tuple(sorted(list(fixed) + newly_fixed_prefix))\n            new_forbidden = tuple(sorted(list(forbidden) + [assignment_to_forbid]))\n\n            sub_cost, sub_perm = solve_subproblem(new_fixed, new_forbidden)\n\n            if sub_perm is not None:\n                heapq.heappush(pq, (sub_cost, sub_perm, new_fixed, new_forbidden))\n                \n    return k_best_costs\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3099154"}]}