{"hands_on_practices": [{"introduction": "割平面方法的核心在于生成能“切掉”线性规划松弛问题非整数解的有效不等式。这个练习将引导你从单纯形表中的一行出发，一步步推导出经典的Gomory分数割。通过这个过程，你将具体地理解这些割平面是如何从数学上被构造出来的，从而为后续更复杂的应用打下坚实的理论基础。[@problem_id:3104181]", "problem": "考虑一个 $0$–$1$ 背包问题，其决策变量为 $x_{1}, x_{2}, x_{3}, x_{4} \\in \\{0,1\\}$，容量约束为 $\\sum_{i=1}^{4} w_{i} x_{i} \\leq W$，以及一个待最大化的线性目标 $\\sum_{i=1}^{4} p_{i} x_{i}$。在线性规划（LP）松弛中，变量边界 $x_{i} \\leq 1$ 通过引入松弛变量 $s_{i} \\geq 0$ 表示为等式 $x_{i} + s_{i} = 1$。假设该 LP 松弛已通过单纯形表求解得到一个最优基本可行解 $\\hat{x}$，其中受整数约束的基变量是 $x_{3}$，并且其在单纯形表中的对应行为\n$$\nx_{3} + 2.75\\, s_{1} - 1.30\\, s_{2} + 0.45\\, s_{4} = 0.37462.\n$$\n假设在此 LP 解中，该行中的非基松弛变量满足 $\\hat{s}_{1} = 0$、$\\hat{s}_{2} = 0$ 和 $\\hat{s}_{4} = 0$，因此基变量的值为 $\\hat{x}_{3} = 0.37462$，这是一个小数，故对于 $0$–$1$ 背包问题是不可行的。\n\n仅使用整数变量、向下取整和分数部分运算的基本定义，以及单纯形表的结构，推导适用于形式为 $x_{k} + \\sum_{j} a_{j} s_{j} = b_{k}$（其中 $x_{k}$ 要求为整数，而 $s_{j} \\geq 0$ 是连续变量）的混合整数单纯形表行的 Gomory 分数割。然后，将此推导应用于给定的行以获得具体的割平面，并计算 LP 解 $\\hat{x}$ 违反此割平面的量；也就是说，计算量：\n$$\n\\text{violation} \\;=\\; \\text{RHS} \\;-\\; \\text{LHS evaluated at } \\hat{s}.\n$$\n将最终数值答案四舍五入到四位有效数字，并将违背量报告为一个无单位的纯数。", "solution": "任务是为一个一般的混合整数规划问题推导 Gomory 分数割，然后将其应用于一个 $0$–$1$ 背包问题的特定单纯形表行。最后，我们必须计算当前的线性规划（LP）松弛解违反该割平面的量。\n\n首先，我们推导 Gomory 混合整数割。\n考虑一个混合整数规划的 LP 松弛问题的最优单纯形表中的一个通用行：\n$$ x_{k} + \\sum_{j \\in N} a_{j} s_{j} = b_{k} $$\n在这个方程中，$x_k$ 是一个要求为整数的基变量。对于 $j \\in N$ 的变量 $s_j$ 是非基变量，假设它们是连续且非负的 ($s_j \\ge 0$)。在当前的基本可行解中，对所有 $j \\in N$ 都有 $s_j=0$，这意味着 $x_k = b_k$。当 $b_k$ 不是整数时，问题就出现了，这违反了对 $x_k$ 的整数性约束。\n\n设 $f_0$ 为 $b_k$ 的小数部分，定义为 $f_0 = b_k - \\lfloor b_k \\rfloor$。由于 $b_k$ 不是整数，我们有 $0  f_0  1$。可以通过分离涉及非基变量的项来重写单纯形表方程：\n$$ \\sum_{j \\in N} a_{j} s_{j} = b_k - x_k $$\n代入 $b_k = \\lfloor b_k \\rfloor + f_0$，我们得到：\n$$ \\sum_{j \\in N} a_{j} s_{j} = \\lfloor b_k \\rfloor - x_k + f_0 $$\n对于混合整数问题的任何可行解，$x_k$ 必须是整数。由于 $\\lfloor b_k \\rfloor$ 也是整数，项 $I = \\lfloor b_k \\rfloor - x_k$ 必须是整数。方程因此变为：\n$$ \\sum_{j \\in N} a_{j} s_{j} = I + f_0, \\quad \\text{for some integer } I $$\n为了继续，我们将非基变量的索引集 $N$ 划分为两个不相交的集合：$N^+ = \\{ j \\in N \\mid a_j \\ge 0 \\}$ 和 $N^- = \\{ j \\in N \\mid a_j  0 \\}$。方程则为：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} + \\sum_{j \\in N^-} a_{j} s_{j} = I + f_0 $$\n我们根据 $I$ 的整数值分析两种情况。\n\n情况1：$I \\ge 0$。\n已知对所有 $j$ 都有 $s_j \\ge 0$，且对 $j \\in N^-$ 有 $a_j  0$，项 $\\sum_{j \\in N^-} a_{j} s_{j}$ 必须是非正的（$\\le 0$）。因此，我们可以写出：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} \\ge I + f_0 $$\n由于 $I$ 是整数且 $I \\ge 0$，当 $I=0$ 时右侧取最小值。这得到 $I+f_0 \\ge f_0$。因此，对于这种情况，任何可行的整数解都必须满足：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} \\ge f_0 $$\n\n情况2：$I \\le -1$。\n已知对所有 $j$ 都有 $s_j \\ge 0$，且对 $j \\in N^+$ 有 $a_j \\ge 0$，项 $\\sum_{j \\in N^+} a_{j} s_{j}$ 必须是非负的（$\\ge 0$）。因此，我们有：\n$$ \\sum_{j \\in N^-} a_{j} s_{j} \\le I + f_0 $$\n由于 $0  f_0  1$，项 $f_0 - 1$ 是负数。将不等式两边乘以负数量 $\\frac{f_0}{f_0-1}$ 会反转不等号：\n$$ \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge \\frac{f_0}{f_0 - 1} (I + f_0) $$\n对于右侧，由于 $I$ 是整数且 $I \\le -1$，我们有 $I + f_0 \\le -1 + f_0 = -(1-f_0)$。除以 $f_0 - 1 = -(1-f_0)$ 再次反转不等号：$\\frac{I+f_0}{f_0-1} \\ge \\frac{-(1-f_0)}{-(1-f_0)} = 1$。乘以 $f_0  0$ 得到 $\\frac{f_0(I+f_0)}{f_0-1} \\ge f_0$。因此，对于这种情况，任何可行的整数解都必须满足：\n$$ \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0 $$\n\n一个有效的割平面必须对任何可行的整数解都成立，而这些解必然属于情况1或情况2。我们可以将这两个推导出的不等式合并成一个单一的有效割平面。\n注意到 $\\sum_{j \\in N^+} a_{j} s_{j} \\ge 0$ 并且 $\\frac{f_0}{f_0-1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge 0$。\n如果一个解属于情况1，它满足 $\\sum_{j \\in N^+} a_j s_j \\ge f_0$。在左侧加上非负项 $\\frac{f_0}{f_0-1} \\sum_{j \\in N^-} a_j s_j$ 仍然保持不等式成立。\n如果一个解属于情况2，它满足 $\\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0$。在左侧加上非负项 $\\sum_{j \\in N^+} a_j s_j$ 仍然保持不等式成立。\n因此，以下不等式对所有可行的整数解都有效：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} + \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0 $$\n这就是 Gomory 混合整数分数割。\n\n现在，我们将此推导应用于所提供的特定单纯形表行：\n$$ x_{3} + 2.75\\, s_{1} - 1.30\\, s_{2} + 0.45\\, s_{4} = 0.37462 $$\n这里，整数基变量是 $x_k = x_3$。非基变量是 $s_1, s_2, s_4$。\n右侧是 $b_3 = 0.37462$。小数部分是 $f_0 = b_3 - \\lfloor b_3 \\rfloor = 0.37462 - 0 = 0.37462$。\n非基变量的系数是 $a_1 = 2.75$, $a_2 = -1.30$ 和 $a_4 = 0.45$。\n我们根据它们的符号进行分类：\n$N^+ = \\{1, 4\\}$ 因为 $a_1 = 2.75  0$ 且 $a_4 = 0.45  0$。\n$N^- = \\{2\\}$ 因为 $a_2 = -1.30  0$。\n\n将这些值代入通用割平面公式：\n$$ a_1 s_1 + a_4 s_4 + \\frac{f_0}{f_0 - 1} a_2 s_2 \\ge f_0 $$\n$$ 2.75\\, s_{1} + 0.45\\, s_{4} + \\left( \\frac{0.37462}{0.37462 - 1} \\right) (-1.30)\\, s_{2} \\ge 0.37462 $$\n$s_2$ 的系数计算如下：\n$$ \\left( \\frac{0.37462}{-0.62538} \\right) (-1.30) = \\frac{-0.487006}{-0.62538} \\approx 0.778736 $$\n所以，具体的割平面是：\n$$ 2.75\\, s_{1} + 0.778736...\\, s_{2} + 0.45\\, s_{4} \\ge 0.37462 $$\n问题要求计算当前 LP 解对此割平面的违背量。在一个最优 LP 单纯形表中，所有非基变量都为零。所以，$\\hat{s}_1 = 0$、$\\hat{s}_2 = 0$ 和 $\\hat{s}_4 = 0$。\n违背量定义为在当前解 $\\hat{s}$ 处求值的 $\\text{RHS} - \\text{LHS}$（右端项 - 左端项）。\n在当前解下，割平面的左侧（LHS）是：\n$$ \\text{LHS} = 2.75(0) + 0.778736...(0) + 0.45(0) = 0 $$\n割平面的右侧（RHS）是 $f_0 = 0.37462$。\n因此，违背量是：\n$$ \\text{Violation} = \\text{RHS} - \\text{LHS} = 0.37462 - 0 = 0.37462 $$\n当前的 LP 解违反了该割平面，因为 $0 \\ge 0.37462$ 是错误的。违背量为 $0.37462$。\n将结果四舍五入到四位有效数字得到 $0.3746$。", "answer": "$$\\boxed{0.3746}$$", "id": "3104181"}, {"introduction": "在学会如何推导单个割平面之后，下一步是理解如何将割平面整合到分支定界搜索中。本练习要求你为背包问题实现一个完整的分支切割算法。你将通过编程实践，量化地衡量添加一个最小覆盖不等式与标准的分支定界方法相比，是如何有效减少搜索树规模的。[@problem_id:3104203]", "problem": "考虑二元背包问题，其定义为目标是最大化 $ \\sum_{i=1}^{n} v_i x_i $，约束条件为容量约束 $ \\sum_{i=1}^{n} w_i x_i \\le W $ 和整数约束 $ x \\in \\{0,1\\}^n $。线性规划松弛将 $ x \\in \\{0,1\\}^n $ 替换为 $ 0 \\le x \\le \\mathbf{1} $，从而为最优值提供一个有效的上界。一个覆盖（cover）是任意满足 $ \\sum_{i \\in C} w_i  W $ 的索引集 $ C \\subseteq \\{1,\\ldots,n\\} $。一个极小覆盖（minimal cover）是指一个覆盖 $ C $，对于其中的每一个 $ j \\in C $，都有 $ \\sum_{i \\in C \\setminus \\{j\\}} w_i \\le W $。对于任意极小覆盖 $ C $，不等式 $ \\sum_{i \\in C} x_i \\le |C| - 1 $ 是有效的，并且可以在分支切割（branch-and-cut）方案的根节点处作为割平面添加。\n\n从这些核心定义出发，设计一个程序，该程序：\n- 实现一个分支定界（branch-and-bound）搜索，在每个节点使用线性规划松弛来计算上界，并剪除那些无法改进目标值的节点。\n- 实现一个分支切割（branch-and-cut）变体，在根节点添加一个极小覆盖不等式（并在整个搜索过程中保持它），并衡量其相对于不带割平面的分支定界算法在已处理节点数量上的影响。\n- 使用一个确定性的分支规则，该规则选择松弛解中值为分数的变量，并选择值最接近 $ 0.5 $ 的那一个，先对 $ x_j = 1 $ 进行分支，再对 $ x_j = 0 $ 进行分支。\n- 将节点计数为求解了线性规划松弛的节点数量。一个仅通过变量固定就被检测为不可行而未求解松弛的节点不应被计数。\n\n您的程序必须：\n1. 从 $ (w, W) $ 自动构建一个极小覆盖 $ C $。一种有效的方法是：按 $ w_i $ 的非递增顺序选取物品，直到它们的总重量超过 $ W $，以此选择一个初始覆盖；然后，当 $ \\sum_{i \\in C} w_i - \\min_{j \\in C} w_j  W $ 时，从 $ C $ 中重复移除重量最小的物品，当 $ \\sum_{i \\in C} w_i - \\min_{j \\in C} w_j \\le W $ 时，确保了极小性。\n2. 在每个节点使用线性规划松弛来计算上界，方法是最小化 $ -\\sum_{i=1}^{n} v_i x_i $，约束条件为 $ \\sum_{i=1}^{n} w_i x_i \\le W $，如果存在覆盖，则加上 $ \\sum_{i \\in C} x_i \\le |C| - 1 $，以及 $ 0 \\le x \\le \\mathbf{1} $ 和任何由分支产生的变量固定。\n3. 使用一个贪心启发式算法构建一个可行解来初始化当前最优解（incumbent），该算法按 $ v_i / w_i $ 的非递增顺序选取物品，直到达到容量上限。\n\n测试套件。使用以下三个探索不同行为的测试用例：\n- 用例A（存在非平凡的极小覆盖）：$ n = 7 $，$ v = [16, 14, 13, 12, 10, 8, 6] $，$ w = [8, 7, 6, 6, 5, 4, 3] $，$ W = 15 $。这里存在一个极小覆盖（例如，选择最重的物品直到超过容量）。\n- 用例B（不存在覆盖）：$ n = 6 $，$ v = [7, 9, 6, 5, 4, 8] $，$ w = [3, 4, 5, 2, 1, 4] $，$ W = 25 $。由于 $ \\sum_{i=1}^{n} w_i  W $，不存在覆盖，添加割平面相对于仅分支应该没有效果。\n- 用例C（双物品极小覆盖）：$ n = 5 $，$ v = [12, 12, 9, 9, 8] $，$ w = [6, 6, 5, 5, 4] $，$ W = 10 $。在最重的物品中存在一个大小为2的极小覆盖，其不等式 $ x_{i} + x_{j} \\le 1 $ 可以收紧松弛。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表被方括号括起来，每个测试用例贡献一个双元素列表 $ [N_{\\text{branch}}, N_{\\text{cut}}] $，其中 $ N_{\\text{branch}} $ 等于仅使用分支的已处理节点数，$ N_{\\text{cut}} $ 等于添加了极小覆盖不等式后已处理的节点数。例如，打印的字符串应形如 $ [[N_1^{\\text{branch}},N_1^{\\text{cut}}],[N_2^{\\text{branch}},N_2^{\\text{cut}}],[N_3^{\\text{branch}},N_3^{\\text{cut}}]] $。", "solution": "用户要求设计一个程序，用于比较标准分支定界算法与一个用于解决二元背包问题的分支切割变体的性能。性能通过搜索树中处理的节点数量来衡量。如果一个节点对应的线性规划（$LP$）松弛被求解，则该节点被计数。\n\n该问题定义为最大化总价值 $Z = \\sum_{i=1}^{n} v_i x_i$，满足容量约束 $\\sum_{i=1}^{n} w_i x_i \\le W$ 和二元变量约束 $x_i \\in \\{0, 1\\}$（对于所有 $i \\in \\{1, \\ldots, n\\}$）。变量 $v_i$ 和 $w_i$ 分别代表物品 $i$ 的价值和重量，而 $W$ 是背包的容量。\n\n该解决方案是围绕一个深度优先的分支定界搜索框架构建的。对于每个测试用例，该框架执行两次：一次作为纯粹的分支定界算法，另一次作为包含了特定割平面的分支切割算法。\n\n**1. 初始下界（当前最优解）**\n\n为了实现有效剪枝，搜索过程会用一个高质量的可行解进行初始化，该解为最优目标值提供了一个初始下界。此解通过贪心启发式算法构建。物品按其价值重量比 $v_i / w_i$ 的非递增顺序排序。它们被依次添入背包，前提是不违反容量约束 $W$。这个贪心解的总价值作为初始的当前最优值 $Z_{best}$。\n\n**2. 覆盖不等式生成**\n\n对于分支切割变体，会生成一个称为覆盖不等式的单一有效不等式，并将其添加到根节点的 $LP$ 松弛中。这个不等式在整个搜索树中保持有效。\n\n覆盖 $C$ 是一组物品索引，其总重量超过背包容量：$\\sum_{i \\in C} w_i  W$。极小覆盖是一种覆盖，其任何真子集都不再是覆盖；也就是说，对于任何物品 $j \\in C$，都有 $\\sum_{i \\in C \\setminus \\{j\\}} w_i \\le W$。对于任何极小覆盖 $C$，不等式 $\\sum_{i \\in C} x_i \\le |C| - 1$ 对于整数问题是有效的。这是因为如果选择了 $C$ 中的所有物品（即对所有 $i \\in C$，都有 $x_i = 1$），它们的总重量将超过 $W$，从而违反容量约束。因此，一个可行解中最多只能包含来自极小覆盖 $C$ 中的 $|C| - 1$ 个物品。\n\n生成这样一个极小覆盖的具体步骤如下：\n- 通过按重量 $w_i$ 的非递增顺序选择物品，直到其累积重量刚好超过 $W$，形成一个初始覆盖。\n- 然后通过重复尝试移除重量最小的物品来使这个初始覆盖变为极小覆盖。如果移除该物品后，剩余的集合仍然是一个覆盖（即其重量总和仍然超过 $W$），则永久移除该物品，并在较小的集合上重复此过程。当移除当前最轻的物品将导致集合不再是覆盖时，该过程终止。\n\n如果没有任何物品集合的总重量大于 $W$（即 $\\sum_{i=1}^n w_i \\le W$），则不存在覆盖，此时分支切割算法与分支定界算法相同。\n\n**3. 分支定界/切割引擎**\n\n算法的核心是对二叉搜索树的递归探索，这里使用一个栈来实现深度优先搜索（DFS）遍历。树中的每个节点对应一个子问题，其中一部分变量被固定为 $0$ 或 $1$。\n\n在每个节点上，执行以下步骤：\n1.  **可行性预检查**：在求解任何 $LP$ 之前，进行一个简单的检查。如果固定为 $1$ 的物品的重量总和已经超过容量 $W$，则该节点不可行并被剪除。此类节点不被计数。\n2.  **节点处理**：如果节点可能是可行的，它将被正式计数，并且其 $LP$ 松弛将被求解。$LP$ 松弛包括目标函数最大化 $\\sum v_i x_i$，并满足以下约束：\n    - 容量约束：$\\sum_{i=1}^{n} w_i x_i \\le W$。\n    - 边界约束：$0 \\le x_i \\le 1$。\n    - 来自自分支的变量固定，例如 $x_j=0$ 或 $x_j=1$。\n    - （对于分支切割）覆盖不等式：$\\sum_{i \\in C} x_i \\le |C| - 1$。\n    `scipy.optimize.linprog` 函数用于此目的，配置为最小化负的目标函数 $-\\sum v_i x_i$。\n\n3.  **剪枝**：求解 $LP$ 后，其结果决定了下一步的操作。设松弛的最优值为 $Z_{LP}$。\n    - **通过不可行性剪枝**：如果 $LP$ 松弛不可行，则该子问题不包含任何可行解。该节点被剪除。\n    - **通过界限剪枝**：如果 $Z_{LP} \\le Z_{best}$，此子树中的任何解都无法改进已知的最佳整数解。该节点被剪除。\n    - **通过整数性剪枝**：如果 $LP$ 解向量 $\\mathbf{x}^*$ 是整数值的（在小容差范围内），它就是原始背包问题的一个可行解。如果其价值 $\\sum v_i x_i^*$ 大于 $Z_{best}$，则更新 $Z_{best}$。然后该节点被剪除，因为在此路径上进一步分支无法产生更好的解。\n\n4.  **分支**：如果节点未被剪除且 $LP$ 解向量 $\\mathbf{x}^*$ 是小数，则进行分支。\n    - **变量选择**：分支变量 $x_j$ 被确定性地选择为具有最接近 $0.5$ 的小数值的变量。\n    - **子节点生成**：为搜索栈创建两个新节点：一个对应于固定 $x_j=1$，另一个对应于 $x_j=0$。为了遵循先探索 $x_j=1$ 分支的要求，对应 $x_j=0$ 的节点先被推入栈，然后是对应 $x_j=1$ 的节点。\n\n当栈为空时，搜索终止，这表示整个可行空间已被隐式枚举。每个测试用例的最终输出是一对整数：纯分支定界运行的总节点数和分支切割运行的总节点数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run the branch-and-cut experiments on the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (nontrivial minimal cover present)\n        {'v': [16, 14, 13, 12, 10, 8, 6], 'w': [8, 7, 6, 6, 5, 4, 3], 'W': 15},\n        # Case B (no cover exists)\n        {'v': [7, 9, 6, 5, 4, 8], 'w': [3, 4, 5, 2, 1, 4], 'W': 25},\n        # Case C (two-item minimal cover)\n        {'v': [12, 12, 9, 9, 8], 'w': [6, 6, 5, 5, 4], 'W': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        v, w, W = case['v'], case['w'], case['W']\n        n_branch = solve_knapsack_instance(v, w, W, use_cut=False)\n        n_cut = solve_knapsack_instance(v, w, W, use_cut=True)\n        results.append([n_branch, n_cut])\n\n    # The final print statement must follow the exact specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_minimal_cover(w, W):\n    \"\"\"\n    Generates a single minimal cover based on the provided algorithm.\n    \"\"\"\n    n = len(w)\n    if np.sum(w) = W:\n        return None\n\n    # Sort items by weight in descending order to build initial cover\n    sorted_indices = np.argsort(w)[::-1]\n    \n    cover_indices = set()\n    current_weight = 0\n    for i in sorted_indices:\n        cover_indices.add(i)\n        current_weight += w[i]\n        if current_weight > W:\n            break\n    \n    # Iteratively make the cover minimal\n    while True:\n        if len(cover_indices) = 1:\n            break\n            \n        weights_in_cover = [(idx, w[idx]) for idx in cover_indices]\n        min_weight_item_idx, min_weight = min(weights_in_cover, key=lambda item: item[1])\n        \n        # If removing the lightest item still results in a cover, do it\n        if np.sum([w[i] for i in cover_indices]) - min_weight > W:\n            cover_indices.remove(min_weight_item_idx)\n        else:\n            break # Cover is now minimal\n            \n    return sorted(list(cover_indices))\n\ndef greedy_heuristic(v, w, W):\n    \"\"\"\n    Finds an initial feasible solution using a greedy approach based on v/w ratio.\n    \"\"\"\n    n = len(v)\n    ratios = v / w\n    \n    sorted_indices = np.argsort(ratios)[::-1]\n    \n    x = np.zeros(n)\n    current_weight = 0\n    current_value = 0.0\n    \n    for i in sorted_indices:\n        if current_weight + w[i] = W:\n            x[i] = 1.0\n            current_weight += w[i]\n            current_value += v[i]\n            \n    return current_value, x\n\ndef solve_knapsack_instance(v_in, w_in, W, use_cut):\n    \"\"\"\n    Solves a knapsack instance using branch-and-bound, optionally with a cover cut.\n    \"\"\"\n    n = len(v_in)\n    v = np.array(v_in, dtype=float)\n    w = np.array(w_in, dtype=float)\n\n    # 1. Get initial lower bound from greedy heuristic\n    lower_bound, _ = greedy_heuristic(v, w, W)\n\n    # 2. Setup base LP constraints\n    c_obj = -v\n    A_ub_list = [w]\n    b_ub_list = [W]\n    \n    if use_cut:\n        cover = generate_minimal_cover(w, W)\n        if cover:\n            cover_ineq = np.zeros(n)\n            cover_ineq[cover] = 1.0\n            A_ub_list.append(cover_ineq)\n            b_ub_list.append(float(len(cover) - 1))\n\n    A_ub = np.array(A_ub_list)\n    b_ub = np.array(b_ub_list)\n    \n    # 3. Branch-and-Bound search\n    node_count = 0\n    stack = [{}]  # Stack for DFS, stores dicts of fixed variables\n\n    while stack:\n        fixed_vars = stack.pop()\n\n        # Pre-check: prune if fixed items already violate capacity\n        current_weight = sum(w[i] for i, val in fixed_vars.items() if val == 1)\n        if current_weight > W:\n            continue\n\n        # Node is processed: an LP will be solved\n        node_count += 1\n        \n        # Setup bounds for the current subproblem\n        bounds = [(0.0, 1.0) for _ in range(n)]\n        for i, val in fixed_vars.items():\n            bounds[i] = (float(val), float(val))\n\n        # Solve the LP relaxation\n        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs-ds')\n        \n        # Pruning based on LP result\n        if not res.success:\n            continue  # Prune by infeasibility\n            \n        upper_bound = -res.fun\n        if upper_bound = lower_bound + 1e-9:\n            continue  # Prune by bound\n            \n        x_sol = res.x\n        is_integer = np.all(np.isclose(x_sol, np.round(x_sol)))\n        \n        if is_integer:\n            current_value = np.dot(v, np.round(x_sol))\n            if current_value > lower_bound:\n                lower_bound = current_value\n            continue  # Prune by integrality\n            \n        # Branching on the most fractional variable\n        fractional_indices = np.where((x_sol > 1e-9)  (x_sol  1 - 1e-9))[0]\n        \n        if not fractional_indices.any():\n            continue # Should be caught by is_integer, but as a safeguard\n\n        branch_var_idx = min(fractional_indices, key=lambda i: abs(x_sol[i] - 0.5))\n        \n        # Push child nodes for DFS (x=1 branch explored first)\n        fixed_0 = fixed_vars.copy()\n        fixed_0[branch_var_idx] = 0\n        stack.append(fixed_0)\n        \n        fixed_1 = fixed_vars.copy()\n        fixed_1[branch_var_idx] = 1\n        stack.append(fixed_1)\n        \n    return node_count\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3104203"}, {"introduction": "在实际的求解器中，寻找“最”违反当前解的割平面本身可能是一个计算成本很高的问题。最后的这个练习将探讨一个重要的实践权衡：是使用快速的启发式方法寻找一个“足够好”的割平面，还是使用精确算法寻找“最好”的割平面。你将实现这两种策略，并比较它们在收紧线性规划松弛界方面的效果。[@problem_id:3104276]", "problem": "您的任务是在一个简化的分支切割框架内，为一个二元背包优化问题实现并比较两种割平面生成策略。考虑一个二元决策向量 $x \\in \\{0,1\\}^n$、利润向量 $p \\in \\mathbb{R}^n_{\\ge 0}$、重量向量 $a \\in \\mathbb{Z}^n_{0}$ 以及容量 $b \\in \\mathbb{Z}_{0}$。二元背包问题是在单个背包不等式的约束下，最大化线性目标函数：\n$$\n\\max \\; p^\\top x \\quad \\text{subject to} \\quad a^\\top x \\le b, \\quad x \\in \\{0,1\\}^n.\n$$\n其线性规划松弛将 $x \\in \\{0,1\\}^n$ 替换为 $0 \\le x \\le \\mathbf{1}$。分支切割方法通过有效不等式（割平面）迭代地加强此松弛，并在必要时对当前解中的分数分量进行分支。\n\n您的程序必须实现并比较两种基于 Chvátal-Gomory 割（CG 割）的割平面生成器，这两种生成器专门用于背包覆盖不等式：\n\n- 一个“基于舍入”的 CG 割平面生成器：给定当前的线性规划松弛解 $\\hat{x} \\in [0,1]^n$，按 $\\hat{x}_i$ 的降序对索引进行排序，并贪婪地构建一个集合 $S$，不断添加物品，直到累积重量 $\\sum_{i \\in S} a_i$ 严格超过容量 $b$。如果找到了这样的集合，则提出覆盖不等式\n$$\n\\sum_{i \\in S} x_i \\le |S| - 1,\n$$\n并且仅当它被当前解所违反时才接受它，即当\n$$\n\\sum_{i \\in S} \\hat{x}_i - (|S| - 1)  0.\n$$\n\n- 一个用于背包覆盖不等式的“精确分离” CG 割平面生成器：在所有满足 $\\sum_{i \\in S} a_i  b$（一个覆盖）的子集 $S \\subseteq \\{1,\\dots,n\\}$ 中，找到使违背量\n$$\n\\sum_{i \\in S} \\hat{x}_i - (|S| - 1)\n$$\n最大化的子集。仅当最大违背量严格为正时，才生成相应的不等式。\n\n这些覆盖不等式是 Chvátal-Gomory 割的一个特例。从背包不等式 $a^\\top x \\le b$ 出发，任何满足 $\\sum_{i \\in S} a_i  b$ 的子集 $S$ 都能导出覆盖不等式 $\\sum_{i \\in S} x_i \\le |S| - 1$，该不等式对于所有满足 $a^\\top x \\le b$ 的 $x \\in \\{0,1\\}^n$ 都是有效的。\n\n您必须实现：\n1. 一个使用标准方法求解线性规划松弛的优化例程。\n2. 上文定义的基于舍入的割平面生成器。\n3. 通过最优地解决覆盖分离问题来实现的精确分离例程。\n4. 在根节点进行一轮割平面生成（此任务无需进一步分支）。\n5. 一个动态规划例程，用于计算精确的最优整数解值以供比较。\n\n对于每个测试用例，计算：\n- 在根节点分别添加基于舍入的割平面（如果有）和添加精确分离割平面（如果有）后的线性规划松弛界。\n- 通过动态规划获得的整数最优值。\n- 添加割平面后的相对差距（以小数表示）：\n$$\n\\text{gap}_{\\text{round}} = \\frac{\\text{LP}_{\\text{round}} - \\text{OPT}_{\\text{int}}}{\\text{OPT}_{\\text{int}}}, \\quad\n\\text{gap}_{\\text{exact}} = \\frac{\\text{LP}_{\\text{exact}} - \\text{OPT}_{\\text{int}}}{\\text{OPT}_{\\text{int}}}.\n$$\n- 一个布尔值，指示精确分离是否实现了比基于舍入的割平面更小的差距，评估为 $\\text{gap}_{\\text{exact}}  \\text{gap}_{\\text{round}}$。\n\n您的推导和实现中要使用的基本原理：\n- 二元整数规划的线性规划松弛及其可行域 $0 \\le x \\le \\mathbf{1}$。\n- 从背包约束派生出的背包覆盖不等式的有效性，其合理性基于 $x$ 的二元性质和容量超额条件。\n- 针对整数重量和容量的精确 0–1 背包优化的动态规划。\n\n测试套件：\n使用以下具有整数重量和容量的实例：\n- 测试用例 1（一般分数情况）：\n  - $p = [20,18,14,11]$\n  - $a = [7,6,5,4]$\n  - $b = 10$\n- 测试用例 2（整数松弛情况，边界）：\n  - $p = [9,7,5]$\n  - $a = [5,4,3]$\n  - $b = 9$\n- 测试用例 3（较大的分数情况）：\n  - $p = [28,26,21,18,16]$\n  - $a = [10,9,7,6,5]$\n  - $b = 17$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个列表的列表。每个内部列表必须是 $[\\text{gap}_{\\text{round}}, \\text{gap}_{\\text{exact}}, \\text{exact\\_better}]$ 的形式，其中前两个条目是浮点数，第三个是布尔值。例如：\n$[[g_1^{\\text{round}},g_1^{\\text{exact}},True],[g_2^{\\text{round}},g_2^{\\text{exact}},False],\\dots]$。", "solution": "所给问题要求实现并比较两种针对二元背包问题的割平面生成策略。解决方案需要一个涉及整数优化、线性规划和专门割平面生成算法的多步骤方法。以下是所用方法的基于原理的详细阐述。\n\n### 1. 通过动态规划求解最优整数解\n\n0-1 二元背包问题的精确最优值，记为 $\\text{OPT}_{\\text{int}}$，作为比较线性规划 (LP) 松弛界的基准。对于具有整数重量 $a_i$ 和整数容量 $b$ 的问题，动态规划 (DP) 提供了一种精确而高效的方法来找到这个值。\n\n设 $dp(i, w)$ 为使用前 $i$ 个物品（从索引 $0$ 到 $i-1$）的子集，在总重量限制恰好为 $w$ 的情况下可实现的最大利润。状态转移或递推关系定义如下：对于每个物品 $i$ 和容量 $w$，我们决定是否包含物品 $i-1$（利润为 $p_{i-1}$，重量为 $a_{i-1}$）。\n\n- 如果不包含物品 $i-1$，利润与使用前 $i-1$ 个物品在容量为 $w$ 时的最大利润相同，即 $dp(i-1, w)$。\n- 如果包含物品 $i-1$（仅当 $w \\ge a_{i-1}$ 时可能），利润为 $p_{i-1}$ 加上使用前 $i-1$ 个物品在剩余容量 $w - a_{i-1}$ 下的最大利润，即 $p_{i-1} + dp(i-1, w - a_{i-1})$。\n\n因此，递推关系为：\n$$\ndp(i, w) = \\begin{cases}\n    dp(i-1, w)  \\text{if } a_{i-1}  w \\\\\n    \\max(dp(i-1, w), p_{i-1} + dp(i-1, w - a_{i-1}))  \\text{if } a_{i-1} \\le w\n\\end{cases}\n$$\nDP 表初始化为 $dp(0, w) = 0$（对所有 $w$），表示没有物品时利润为零。在为所有 $i \\in \\{1, \\dots, n\\}$ 和 $w \\in \\{1, \\dots, b\\}$ 填满表后，最优整数解值在 $dp(n, b)$ 处找到。\n\n### 2. 线性规划松弛与割平面生成\n\n分支切割方法始于求解整数规划的 LP 松弛。二元约束 $x \\in \\{0, 1\\}^n$ 被松弛为对所有 $i$ 的连续界 $0 \\le x_i \\le 1$。初始 LP 松弛为：\n$$\n\\max \\; p^\\top x \\quad \\text{subject to} \\quad a^\\top x \\le b, \\quad 0 \\le x_i \\le 1 \\quad \\forall i.\n$$\n此问题使用标准的 LP 求解器解决。设解为 $\\hat{x}$。如果 $\\hat{x}$ 完全是整数，则它对于原问题是最优的。如果 $\\hat{x}$ 含有分数分量，则 LP 界 $p^\\top \\hat{x}$ 是 $\\text{OPT}_{\\text{int}}$ 的一个上界。我们接着寻求添加被 $\\hat{x}$ 违反的有效不等式（割平面）以收紧此界。问题指定使用背包覆盖不等式。一个集合 $S \\subseteq \\{1, \\dots, n\\}$ 是一个**覆盖** (cover)，如果 $\\sum_{i \\in S} a_i  b$。相应的**覆盖不等式** (cover inequality) 是 $\\sum_{i \\in S} x_i \\le |S| - 1$。这个不等式是有效的，因为如果从 $S$ 中选择了超过 $|S|-1$ 个物品（即，对于 $x \\in \\{0,1\\}^n$，$\\sum_{i \\in S} x_i \\ge |S|$），它们的总重量将超过容量 $b$，从而违反背包约束。\n\n一个割平面只有在被当前 LP 解 $\\hat{x}$ 违反时才有用，即 $\\sum_{i \\in S} \\hat{x}_i  |S| - 1$。\n\n#### 2.1. 基于舍入的割平面生成器\n\n这是一种寻找被违反的覆盖不等式的启发式方法。它利用了这样一种直觉：在 $\\hat{x}$ 中具有高分数分量的物品是构成被违反覆盖的首要候选者。算法如下：\n1. 按其对应值 $\\hat{x}_i$ 的降序对物品索引 $i$ 进行排序。\n2. 按照此排序顺序，贪婪地将物品添加到一个集合 $S$ 中。\n3. 一旦 $S$ 中物品的累积重量超过容量 $b$，即 $\\sum_{i \\in S} a_i  b$，便停止。\n4. 如果找到了这样一个覆盖 $S$，检查它是否被 $\\hat{x}$ 违反：$\\sum_{i \\in S} \\hat{x}_i  |S| - 1$。如果是，则生成此割平面。\n\n#### 2.2. 精确分离割平面生成器\n\n该方法旨在找到*违背程度最大*的覆盖不等式。寻找一个能最大化违背量 $\\sum_{i \\in S} \\hat{x}_i - (|S| - 1)$ 的覆盖 $S$ 的问题，被称为背包覆盖不等式的**分离问题** (separation problem)。我们可以将其形式化为一个优化问题。设 $y_i$ 是一个二元变量，其中如果物品 $i$ 在 $S$ 中，则 $y_i=1$，否则 $y_i=0$。\n我们想最大化 $\\sum_{i=1}^n \\hat{x}_i y_i - (\\sum_{i=1}^n y_i - 1)$，这等价于最大化 $\\sum_{i=1}^n (\\hat{x}_i - 1)y_i + 1$，约束条件为 $\\sum_{i=1}^n a_i y_i  b$。由于 $a_i$ 和 $b$ 是整数，这等价于 $\\sum_{i=1}^n a_i y_i \\ge b+1$。\n\n令 $v_i = \\hat{x}_i - 1$。分离问题是：\n$$\n\\max \\sum_{i=1}^n v_i y_i \\quad \\text{subject to} \\quad \\sum_{i=1}^n a_i y_i \\ge b+1, \\quad y \\in \\{0,1\\}^n.\n$$\n这是背包问题的一个变种。它可以使用动态规划来最优地解决。设 $dp_{sep}(i, w)$ 为使用前 $i$ 个物品子集且总重量恰好为 $w$ 时 $\\sum_{j=1}^i v_j y_j$ 的最大值。其递推关系类似于标准背包 DP。计算完表后，通过取 $\\max_{w \\ge b+1} dp_{sep}(n, w)$ 找到分离目标的最大值。最大违背量是该值加 $1$。如果这个最大违背量为正，我们通过回溯 DP 表来重构最优覆盖集 $S$。\n\n### 3. 比较与评估\n\n对于每个测试用例，流程如下：\n1. 使用背包 DP 计算 $\\text{OPT}_{\\text{int}}$。\n2. 求解初始 LP 松弛以获得根节点解 $\\hat{x}$。\n3. 使用基于舍入的启发式方法生成一个割平面。如果找到了一个有效的、被违反的割平面，则将其添加到 LP 中并重新求解以获得 $\\text{LP}_{\\text{round}}$。如果没有找到割平面，则 $\\text{LP}_{\\text{round}}$ 是初始 LP 值。\n4. 使用精确分离例程生成一个割平面。如果找到了一个有效的、被违反的割平面，则将其添加到初始 LP 中并重新求解以获得 $\\text{LP}_{\\text{exact}}$。如果没有找到割平面，则 $\\text{LP}_{\\text{exact}}$ 是初始 LP 值。\n5. 计算相对差距 $\\text{gap}_{\\text{round}} = (\\text{LP}_{\\text{round}} - \\text{OPT}_{\\text{int}}) / \\text{OPT}_{\\text{int}}$ 和 $\\text{gap}_{\\text{exact}} = (\\text{LP}_{\\text{exact}} - \\text{OPT}_{\\text{int}}) / \\text{OPT}_{\\text{int}}$。\n6. 判断精确方法是否提供了严格更优的差距，即 $\\text{gap}_{\\text{exact}}  \\text{gap}_{\\text{round}}$。\n\n这种结构化的比较能够对一个简单启发式方法与一个精确（但计算更密集）的割平面生成方法的有效性进行定量评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"p\": np.array([20, 18, 14, 11], dtype=float),\n            \"a\": np.array([7, 6, 5, 4], dtype=int),\n            \"b\": 10\n        },\n        {\n            \"p\": np.array([9, 7, 5], dtype=float),\n            \"a\": np.array([5, 4, 3], dtype=int),\n            \"b\": 9\n        },\n        {\n            \"p\": np.array([28, 26, 21, 18, 16], dtype=float),\n            \"a\": np.array([10, 9, 7, 6, 5], dtype=int),\n            \"b\": 17\n        },\n    ]\n\n    all_results = []\n\n    def solve_knapsack_dp(p, a, b):\n        \"\"\"Solves the 0-1 knapsack problem using dynamic programming.\"\"\"\n        n = len(p)\n        dp = np.zeros((n + 1, b + 1), dtype=float)\n        for i in range(1, n + 1):\n            profit = p[i - 1]\n            weight = a[i - 1]\n            for w in range(b + 1):\n                if weight = w:\n                    dp[i, w] = max(dp[i - 1, w], profit + dp[i - 1, w - weight])\n                else:\n                    dp[i, w] = dp[i - 1, w]\n        return dp[n, b]\n\n    def solve_lp(p, A_ub, b_ub):\n        \"\"\"Helper function to solve the LP relaxation.\"\"\"\n        n = len(p)\n        c = -p\n        bounds = [(0, 1) for _ in range(n)]\n        # Using 'highs' for robustness and performance, as recommended by SciPy.\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return -res.fun, res.x\n        else:\n            # For this problem, LPs should always be feasible.\n            raise RuntimeError(\"LP solver failed.\")\n\n    def rounding_cut_generator(x_hat, a, b):\n        \"\"\"Generates a cover inequality using a rounding-based heuristic.\"\"\"\n        n = len(a)\n        indices = np.argsort(-x_hat)\n        cover_s = []\n        current_weight = 0\n        for idx in indices:\n            cover_s.append(idx)\n            current_weight += a[idx]\n            if current_weight > b:\n                break\n        else:  # 'else' on a for-loop executes if the loop completed without break\n            return None # No cover found\n\n        violation = np.sum(x_hat[cover_s]) - (len(cover_s) - 1)\n        if violation > 1e-9:\n            return cover_s\n        return None\n\n    def exact_separation_generator(x_hat, a, b):\n        \"\"\"Finds the most violated cover inequality using dynamic programming.\"\"\"\n        n = len(a)\n        v = x_hat - 1  # Profits for the separation problem\n        total_weight = int(np.sum(a))\n        \n        # dp[i, w]: max value for items up to i-1 with exact weight w\n        dp = np.full((n + 1, total_weight + 1), -np.inf)\n        parent = {} # For backtracking\n        dp[0, 0] = 0\n\n        for i in range(1, n + 1):\n            profit = v[i - 1]\n            weight = a[i - 1]\n            for w in range(total_weight + 1):\n                # Case 1: Don't include item i-1\n                dp[i, w] = dp[i-1, w]\n                parent[(i, w)] = (i-1, w)\n\n                # Case 2: Include item i-1\n                if w >= weight:\n                    val_with_item = profit + dp[i-1, w - weight]\n                    if val_with_item > dp[i, w]:\n                        dp[i, w] = val_with_item\n                        parent[(i, w)] = (i-1, w - weight)\n\n        max_val = -np.inf\n        best_w = -1\n        capacity_limit = b + 1\n        \n        for w in range(capacity_limit, total_weight + 1):\n            if dp[n, w] > max_val:\n                max_val = dp[n, w]\n                best_w = w\n        \n        max_violation = max_val + 1\n        if max_violation > 1e-9:\n            # Backtrack to find the cover set\n            cover_s = []\n            curr_w = best_w\n            for i in range(n, 0, -1):\n                prev_i, prev_w = parent[(i, curr_w)]\n                if curr_w != prev_w: # This means item i-1 was taken\n                    cover_s.append(i-1)\n                    curr_w = prev_w\n            return cover_s\n        return None\n\n    for case in test_cases:\n        p, a, b = case[\"p\"], case[\"a\"], case[\"b\"]\n        n = len(p)\n        \n        opt_int = solve_knapsack_dp(p, a, b)\n        \n        A_orig = a.reshape(1, -1)\n        b_orig = np.array([b])\n        \n        lp_root_val, x_hat = solve_lp(p, A_orig, b_orig)\n\n        # Rounding-based cut path\n        S_round = rounding_cut_generator(x_hat, a, b)\n        lp_round_val = lp_root_val\n        if S_round:\n            cut_row = np.zeros(n)\n            cut_row[S_round] = 1\n            A_new = np.vstack([A_orig, cut_row])\n            b_new = np.append(b_orig, [len(S_round) - 1])\n            lp_round_val, _ = solve_lp(p, A_new, b_new)\n        \n        # Exact separation cut path\n        S_exact = exact_separation_generator(x_hat, a, b)\n        lp_exact_val = lp_root_val\n        if S_exact:\n            cut_row = np.zeros(n)\n            cut_row[S_exact] = 1\n            A_new = np.vstack([A_orig, cut_row])\n            b_new = np.append(b_orig, [len(S_exact) - 1])\n            lp_exact_val, _ = solve_lp(p, A_new, b_new)\n            \n        # Calculate gaps and comparison\n        if opt_int > 0:\n            gap_round = (lp_round_val - opt_int) / opt_int\n            gap_exact = (lp_exact_val - opt_int) / opt_int\n        else: # Handle case of zero optimal value to avoid division by zero\n            gap_round = lp_round_val if lp_round_val > 0 else 0.0\n            gap_exact = lp_exact_val if lp_exact_val > 0 else 0.0\n\n        exact_better = gap_exact  gap_round\n\n        all_results.append([gap_round, gap_exact, exact_better])\n\n    # Format the final output string exactly as requested.\n    result_str = \"[\" + \",\".join(f\"[{r[0]},{r[1]},{str(r[2])}]\" for r in all_results) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "3104276"}]}