{"hands_on_practices": [{"introduction": "Tarski's recursive definition of truth hinges on the concept of a variable assignment, which provides context for evaluating formulas with free variables. This practice will help you master the formal machinery of assignments, including the crucial update notation $s[x\\mapsto a]$ used to define the semantics of quantifiers. By working through it, you will also solidify your understanding of the Coincidence Lemma, a fundamental theorem which precisely clarifies why the truth of a formula only depends on the values assigned to its free variables [@problem_id:2983816].", "problem": "Consider a language $L$ of First-Order Logic (FOL), an $L$-structure $\\mathcal{M}$ with domain $M$ and interpretation function, and a variable assignment $s\\colon \\mathrm{Var}\\to M$. The Tarskian satisfaction relation $\\mathcal{M}\\models \\varphi[s]$ is determined by the structure $\\mathcal{M}$ and the assignment $s$, and term evaluation is written $\\llbracket t\\rrbracket^{\\mathcal{M},s}$. Select all statements that correctly characterize the role of the assignment $s$ in Tarskian semantics and correctly formalize the update notation $s[x\\mapsto a]$ together with its algebraic properties.\n\nA. For any $s\\colon \\mathrm{Var}\\to M$ and $a\\in M$, the update $s[x\\mapsto a]$ is the assignment $t\\colon \\mathrm{Var}\\to M$ defined by $t(x)=a$ and $t(y)=s(y)$ for all $y\\neq x$.\n\nB. For any $x,y\\in \\mathrm{Var}$ with $x\\neq y$ and any $a,b\\in M$, the updates commute: $s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$.\n\nC. For any formula $\\varphi$, modifying $s$ at a variable $x$ that is bound in $\\varphi$ can change the truth value of $\\mathcal{M}\\models \\varphi[s]$.\n\nD. If $s,s'\\colon \\mathrm{Var}\\to M$ agree on the set of free variables of a formula $\\varphi$, then $\\mathcal{M}\\models \\varphi[s]$ if and only if $\\mathcal{M}\\models \\varphi[s']$.\n\nE. For any term $t$, if $x$ does not occur among the variables of $t$, then $\\llbracket t\\rrbracket^{\\mathcal{M},s}=\\llbracket t\\rrbracket^{\\mathcal{M},s[x\\mapsto a]}$ for all $a\\in M$.\n\nF. For any formula $\\varphi$ and any $a\\in M$, one has $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if there exists $a\\in M$ such that $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$.", "solution": "The problem statement is a standard exercise in first-order logic, specifically pertaining to Tarski's definition of truth (or satisfaction). The concepts presented—first-order language $L$, $L$-structure $\\mathcal{M}$, domain $M$, variable assignment $s$, satisfaction relation $\\mathcal{M}\\models \\varphi[s]$, term evaluation $\\llbracket t\\rrbracket^{\\mathcal{M},s}$, and assignment update $s[x\\mapsto a]$—are all standard and well-defined. The question is a well-posed inquiry into the formal properties of these concepts.\n\nTherefore, the problem statement is valid. We will proceed to analyze each option.\n\nThe core of Tarskian semantics relies on a recursive definition of satisfaction. A variable assignment $s\\colon \\mathrm{Var}\\to M$ maps each variable in the set of all variables $\\mathrm{Var}$ to an element of the domain $M$. The truth of a formula $\\varphi$ is evaluated relative to a structure $\\mathcal{M}$ and such an assignment $s$.\n\nLet's evaluate each statement.\n\n**A. For any $s\\colon \\mathrm{Var}\\to M$ and $a\\in M$, the update $s[x\\mapsto a]$ is the assignment $t\\colon \\mathrm{Var}\\to M$ defined by $t(x)=a$ and $t(y)=s(y)$ for all $y\\neq x$.**\n\nThis statement provides the formal definition of the notation $s[x\\mapsto a]$. It represents a new assignment, let's call it $s'$, which is a slight modification of the original assignment $s$. The new assignment $s'$ maps the variable $x$ to the specific domain element $a$, and for every other variable $y$ (where $y$ is a variable symbol different from $x$), it agrees with the original assignment, i.e., $s'(y) = s(y)$. This is the standard, universally accepted definition of assignment modification used in the semantics of quantified formulas.\n\nVerdict: **Correct**.\n\n**B. For any $x,y\\in \\mathrm{Var}$ with $x\\neq y$ and any $a,b\\in M$, the updates commute: $s[x\\mapsto a][y\\mapsto b]=s[y\\mapsto b][x\\mapsto a]$.**\n\nTo verify this, we must check if the two resulting assignments are the same function. Two functions are equal if and only if they have the same domain and codomain and map each element in the domain to the same element in the codomain. Let $s_1 = s[x\\mapsto a][y\\mapsto b]$ and $s_2 = s[y\\mapsto b][x\\mapsto a]$. We need to show that $s_1(z) = s_2(z)$ for an arbitrary variable $z \\in \\mathrm{Var}$.\n\nLet's consider the possible cases for $z$:\n1.  Case $z = x$:\n    - $s_1(x) = (s[x\\mapsto a][y\\mapsto b])(x)$. The \"outer\" update is with respect to $y$, and since $x \\neq y$, the value at $x$ is determined by the \"inner\" assignment $s[x\\mapsto a]$. Thus, $s_1(x) = (s[x\\mapsto a])(x) = a$.\n    - $s_2(x) = (s[y\\mapsto b][x\\mapsto a])(x)$. The outer update is with respect to $x$, which by definition maps $x$ to $a$. Thus, $s_2(x) = a$.\n    So, $s_1(x) = s_2(x)$.\n\n2.  Case $z = y$:\n    - $s_1(y) = (s[x\\mapsto a][y\\mapsto b])(y)$. The outer update is with respect to $y$, which by definition maps $y$ to $b$. Thus, $s_1(y) = b$.\n    - $s_2(y) = (s[y\\mapsto b][x\\mapsto a])(y)$. The outer update is with respect to $x$, and since $y \\neq x$, the value at $y$ is determined by the inner assignment $s[y\\mapsto b]$. Thus, $s_2(y) = (s[y\\mapsto b])(y) = b$.\n    So, $s_1(y) = s_2(y)$.\n\n3.  Case $z \\neq x$ and $z \\neq y$:\n    - $s_1(z) = (s[x\\mapsto a][y\\mapsto b])(z)$. The outer update does not affect $z$, so the value is $(s[x\\mapsto a])(z)$. The inner update also does not affect $z$, so the value is $s(z)$.\n    - $s_2(z) = (s[y\\mapsto b][x\\mapsto a])(z)$. The outer update does not affect $z$, so the value is $(s[y\\mapsto b])(z)$. The inner update also does not affect $z$, so the value is $s(z)$.\n    So, $s_1(z) = s_2(z)$.\n\nSince $s_1$ and $s_2$ agree on all variables, they are the same assignment. The condition $x \\neq y$ is crucial, as $s[x\\mapsto a][x\\mapsto b]$ would map $x$ to $b$, whereas $s[x\\mapsto b][x\\mapsto a]$ would map $x$ to $a$.\n\nVerdict: **Correct**.\n\n**C. For any formula $\\varphi$, modifying $s$ at a variable $x$ that is bound in $\\varphi$ can change the truth value of $\\mathcal{M}\\models \\varphi[s]$.**\n\nThe truth value of a formula depends only on the values assigned to its *free* variables. Bound variables are placeholders for quantification. For example, consider the formula $\\varphi = \\forall x P(x)$. The satisfaction condition is $\\mathcal{M} \\models \\forall x P(x)[s]$ if and only if for all $a \\in M$, we have $\\mathcal{M} \\models P(x)[s[x\\mapsto a]]$. The original value $s(x)$ plays no role in this evaluation; the evaluation depends on testing the subformula $P(x)$ for *all* possible values for $x$ from the domain. Therefore, changing $s(x)$ to some other value $s'(x)$ has no effect on the truth of $\\mathcal{M} \\models \\forall x P(x)[s]$. This principle generalizes to all quantified formulas and any bound variable. The statement claims the opposite.\n\nVerdict: **Incorrect**.\n\n**D. If $s,s'\\colon \\mathrm{Var}\\to M$ agree on the set of free variables of a formula $\\varphi$, then $\\mathcal{M}\\models \\varphi[s]$ if and only if $\\mathcal{M}\\models \\varphi[s']$.**\n\nThis is a fundamental result in model theory, often called the **Coincidence Lemma** or **Relevance Lemma**. It formalizes the intuition that the satisfaction of a formula depends only on the what the assignment does to the variables that actually appear free in the formula. The proof is a straightforward structural induction on the complexity of the formula $\\varphi$. The base cases for atomic formulas are clear, as their truth values depend only on the evaluation of their terms, which in turn depend only on the variables within them (all of which are free). The inductive steps for logical connectives and quantifiers preserve the property. We sketched the proof for the universal quantifier in the analysis of option C. This statement is a correct and central theorem of Tarskian semantics.\n\nVerdict: **Correct**.\n\n**E. For any term $t$, if $x$ does not occur among the variables of $t$, then $\\llbracket t\\rrbracket^{\\mathcal{M},s}=\\llbracket t\\rrbracket^{\\mathcal{M},s[x\\mapsto a]}$ for all $a\\in M$.**\n\nThis is the analogue of the Coincidence Lemma (Option D) for terms. The value of a term $\\llbracket t \\rrbracket^{\\mathcal{M},s}$ is determined by the interpretation of constants and function symbols, and by the values assigned by $s$ to the variables appearing in $t$. If a variable $x$ does not appear in $t$, then changing the value of $s(x)$ via the update $s[x\\mapsto a]$ will not affect the evaluation of $t$. A formal proof proceeds by induction on the structure of the term $t$.\n- Base case ($t$ is a constant $c$): $\\llbracket c\\rrbracket^{\\mathcal{M},s} = c^{\\mathcal{M}} = \\llbracket c\\rrbracket^{\\mathcal{M},s[x\\mapsto a]}$.\n- Base case ($t$ is a variable $y$): Since $x$ does not occur in $t$, $y \\neq x$. Then $\\llbracket y\\rrbracket^{\\mathcal{M},s} = s(y)$ and $\\llbracket y\\rrbracket^{\\mathcal{M},s[x\\mapsto a]} = (s[x\\mapsto a])(y) = s(y)$. They are equal.\n- Inductive step ($t$ is $f(t_1, \\ldots, t_k)$): Since $x$ does not occur in $t$, it does not occur in any subterm $t_i$. By the induction hypothesis, $\\llbracket t_i\\rrbracket^{\\mathcal{M},s} = \\llbracket t_i\\rrbracket^{\\mathcal{M},s[x\\mapsto a]}$ for all $i$. Then $\\llbracket t\\rrbracket^{\\mathcal{M},s} = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M},s}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M},s}) = f^{\\mathcal{M}}(\\llbracket t_1\\rrbracket^{\\mathcal{M},s[x\\mapsto a]}, \\ldots, \\llbracket t_k\\rrbracket^{\\mathcal{M},s[x\\mapsto a]}) = \\llbracket t\\rrbracket^{\\mathcal{M},s[x\\mapsto a]}$.\n\nThe statement is correct.\n\nVerdict: **Correct**.\n\n**F. For any formula $\\varphi$ and any $a\\in M$, one has $\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if there exists $a\\in M$ such that $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$.**\n\nThis statement fundamentally misrepresents the semantics of the universal quantifier. The Tarskian definition of satisfaction for a universally quantified formula is:\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if for **all** elements $b\\in M$, it is the case that $\\mathcal{M}\\models \\varphi[s[x\\mapsto b]]$.\n\nThe statement given is:\n$\\mathcal{M}\\models \\forall x\\,\\varphi[s]$ if and only if there **exists** an element $a\\in M$ such that $\\mathcal{M}\\models \\varphi[s[x\\mapsto a]]$.\n\nThe right-hand side of the equivalence in the statement is the definition for the *existential quantifier*: $\\mathcal{M}\\models \\exists x\\,\\varphi[s]$. The statement incorrectly equates the meaning of \"for all\" with \"there exists\". These are only equivalent in the trivial and uninteresting case where the domain $M$ contains exactly one element (assuming it's non-empty). In general, this is false. For example, in the integers, \"for all $x$, $x>0$\" is false, but \"there exists $x$ such that $x>0$\" is true. The extraneous \"and any $a \\in M$\" at the beginning of the proposition is ill-formed and adds confusion, but does not salvage the core logical error.\n\nVerdict: **Incorrect**.\n\nSummary of correct statements: A, B, D, E.", "answer": "$$\\boxed{ABDE}$$", "id": "2983816"}, {"introduction": "While variable assignments provide the semantic tool for defining truth, substitution is the corresponding syntactic operation for manipulating formulas. This practice delves into the subtle but critical concept of capture-avoiding substitution, forcing a rigorous distinction between free and bound variables and revealing why naive textual replacement can corrupt a formula's intended meaning. Properly grasping this concept and the associated Substitution Lemma is essential for connecting syntactic deduction with semantic consequence [@problem_id:2983801].", "problem": "In the setting of First-Order Logic (FOL), let $\\mathcal{L}$ be a first-order language with variables, a unary relation symbol $\\mathsf{P}$, a binary relation symbol $\\mathsf{Q}$, a constant symbol $\\mathsf{c}$, and a binary function symbol $\\mathsf{f}$. Formulas are built from atomic formulas using Boolean connectives and quantifiers. Under Tarski’s definition of truth, satisfaction is given relative to a structure $\\mathcal{M}$ interpreting the nonlogical symbols and a variable assignment $s$.\n\nSelect all statements that correctly and rigorously characterize capture-avoiding substitution, free and bound variables, and explain why naive substitution can invalidate the quantifier clauses in Tarski’s definition of truth.\n\nA. An occurrence of a variable $v$ in a formula is bound if and only if it lies within the scope of a quantifier of the form $\\forall v$ or $\\exists v$ that binds it; otherwise it is free. The set of free variables is defined inductively: if $\\varphi$ is atomic, then $\\mathrm{Free}(\\varphi)$ is the set of variables that occur in the term positions of $\\varphi$; for Boolean connectives, $\\mathrm{Free}(\\neg\\varphi)=\\mathrm{Free}(\\varphi)$ and $\\mathrm{Free}(\\varphi\\star\\psi)=\\mathrm{Free}(\\varphi)\\cup\\mathrm{Free}(\\psi)$ for any binary connective $\\star$; for quantifiers, $\\mathrm{Free}(\\forall v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$ and $\\mathrm{Free}(\\exists v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$.\n\nB. Capture-avoiding substitution of a term $t$ for a variable $x$ in a formula $\\varphi$, denoted $\\varphi[t/x]$, is defined as replacing every free occurrence of $x$ in $\\varphi$ by $t$ while first $\\alpha$-renaming any bound variables $y$ in $\\varphi$ whose quantifiers have scope over a position where $t$ would be inserted and such that $y$ occurs free in $t$, so that no free variable of $t$ becomes bound after substitution.\n\nC. Under Tarski semantics, naive substitution—i.e., textual replacement of $x$ by $t$ uniformly in $\\varphi$ without any renaming—cannot change the truth value of $\\varphi$ under any structure $\\mathcal{M}$ and assignment $s$, because the truth of quantified formulas depends only on the domain of $\\mathcal{M}$ and the assignment to the bound variables.\n\nD. Let $\\varphi(x)=\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$ and let $t=y$. Then the naive textual replacement yields $\\varphi[y/x]=\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$, and, for every structure $\\mathcal{M}$ and assignment $s$, $\\mathcal{M},s\\models\\varphi(x)$ if and only if $\\mathcal{M},s\\models\\varphi[y/x]$; thus the two formulas are equivalent.\n\nE. The substitution lemma for capture-avoiding substitution states: for any structure $\\mathcal{M}$, assignment $s$, formula $\\varphi$, variable $x$, and term $t$, if $\\varphi[t/x]$ is formed by capture-avoiding substitution, then $\\mathcal{M},s\\models\\varphi[t/x]$ if and only if $\\mathcal{M},s[x\\mapsto\\llbracket t\\rrbracket_{\\mathcal{M},s}]\\models\\varphi$. Naive substitution can fail this equivalence when free variables in $t$ become bound as a result of substitution, thereby breaking the inductive proof of the quantifier clauses.\n\nF. To avoid capture, it suffices to rename only the bound occurrences of $x$ in $\\varphi$ before substituting $t$ for $x$; the free variables of $t$ do not need consideration because quantifiers in $\\varphi$ do not interact with variables introduced by substitution.\n\nChoose all correct options.", "solution": "The problem statement is first validated to ensure its scientific and logical integrity.\n\n**Step 1: Extract Givens**\n- Logic System: First-Order Logic (FOL).\n- Language $\\mathcal{L}$:\n    - A set of variables, including $v, x, y$.\n    - A unary relation symbol $\\mathsf{P}$.\n    - A binary relation symbol $\\mathsf{Q}$.\n    - A constant symbol $\\mathsf{c}$.\n    - A binary function symbol $\\mathsf{f}$.\n- Semantics: Tarski’s definition of truth, with satisfaction ($\\models$) defined relative to a structure $\\mathcal{M}$ and a variable assignment $s$.\n- Task: Select all statements that correctly characterize:\n    1. Capture-avoiding substitution.\n    2. Free and bound variables.\n    3. The failure of naive substitution with respect to Tarski's semantics.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly situated in mathematical logic, a core discipline of mathematics. All concepts mentioned—first-order logic, Tarski's semantics, free and bound variables, and substitution—are standard, well-defined, and fundamental to the field. The provided language $\\mathcal{L}$ is a typical example. The problem does not violate any mathematical principles.\n- **Well-Posed:** The problem asks for the evaluation of several propositions concerning established logical concepts. For each proposition, a definite verdict of correct or incorrect can be reached based on the standard theory of first-order logic. A unique set of correct options exists.\n- **Objective:** The language of the problem is precise and uses standard technical terminology from logic (e.g., \"unary relation symbol\", \"variable assignment\", \"capture-avoiding substitution\"). It is free from ambiguity and subjective content.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It is a well-formed question about fundamental concepts in first-order logic. Proceeding to solution and option analysis.\n\n**Analysis of Options**\n\n**Option A:** This statement defines free and bound variables and gives an inductive definition for the set of free variables of a formula, $\\mathrm{Free}(\\varphi)$.\n- The informal definition \"An occurrence of a variable $v$ in a formula is bound if and only if it lies within the scope of a quantifier of the form $\\forall v$ or $\\exists v$ that binds it; otherwise it is free\" is a correct high-level description.\n- The inductive definition is broken down by the structure of the formula:\n    - For an atomic formula $\\varphi$, $\\mathrm{Free}(\\varphi)$ is correctly identified as the set of variables appearing in its terms.\n    - For Boolean connectives, the rules $\\mathrm{Free}(\\neg\\varphi)=\\mathrm{Free}(\\varphi)$ and $\\mathrm{Free}(\\varphi\\star\\psi)=\\mathrm{Free}(\\varphi)\\cup\\mathrm{Free}(\\psi)$ are correct, as connectives do not bind variables.\n    - For quantifiers, the rules $\\mathrm{Free}(\\forall v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$ and $\\mathrm{Free}(\\exists v\\,\\varphi)=\\mathrm{Free}(\\varphi)\\setminus\\{v\\}$ are the standard definitions. The quantifier binds the variable $v$, removing it from the set of free variables.\nThe entire statement is a correct and standard presentation of the concept of free variables in first-order logic.\nVerdict: **Correct**.\n\n**Option B:** This statement defines capture-avoiding substitution, denoted $\\varphi[t/x]$.\n- It correctly states that the operation replaces every free occurrence of a variable $x$ in a formula $\\varphi$ with a term $t$.\n- It correctly identifies the problem to be avoided: \"variable capture,\" where a free variable in the term $t$ becomes bound by a quantifier in $\\varphi$.\n- It correctly describes the standard solution: first perform $\\alpha$-renaming on any bound variable $y$ in $\\varphi$ if that variable $y$ also occurs free in $t$ and the substitution for $x$ would place $t$ inside the scope of the quantifier binding $y$.\nThis is a rigorous and accurate description of the process and purpose of capture-avoiding substitution.\nVerdict: **Correct**.\n\n**Option C:** This statement claims that naive (simple textual replacement) substitution is always truth-preserving.\n- The claim is that naive substitution \"cannot change the truth value of $\\varphi$ under any structure $\\mathcal{M}$ and assignment $s$\". This is fundamentally false. Variable capture, which naive substitution allows, can indeed alter the truth value and logical meaning of a formula.\n- The provided justification, \"because the truth of quantified formulas depends only on the domain of $\\mathcal{M}$ and the assignment to the bound variables,\" is an incorrect oversimplification. The truth of a quantified formula $\\forall z \\psi$ depends on the satisfaction of $\\psi$ for all assignments to $z$, which in turn depends on the interpretation of all predicates, functions, and other free variables within $\\psi$.\n- A counterexample is sufficient to disprove this. Let $\\varphi(x)$ be $\\exists y (x \\neq y)$. This is true in any structure with at least two elements for any assignment to $x$. Now, let $t=y$. Naive substitution yields $\\exists y (y \\neq y)$, which is always false. The truth value has changed.\nVerdict: **Incorrect**.\n\n**Option D:** This option presents a specific example of naive substitution and claims the resulting formulas are logically equivalent.\n- The formula is $\\varphi(x)=\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$ and the substitution is of $t=y$ for $x$.\n- The naive substitution is correctly identified as $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$. In this process, the free variable $y$ from the term $t$ is \"captured\" by the $\\forall y$ quantifier.\n- The claim is that $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$ is logically equivalent to $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$.\n- This claim is false. The first formula has a free variable $x$, so its truth depends on the assignment to $x$. The second formula is a sentence (no free variables), so its truth depends only on the structure $\\mathcal{M}$. A formula with a free variable cannot be logically equivalent to a sentence (unless both are valid or both unsatisfiable, which is not the case here).\n- To demonstrate, let $\\mathcal{M}$ be a structure with domain $D=\\{a,b\\}$. Let $\\mathsf{P}^{\\mathcal{M}} = D$ and $\\mathsf{Q}^{\\mathcal{M}} = \\{(a,a), (a,b)\\}$.\n- Consider an assignment $s$ where $s(x) = a$. Then $\\mathcal{M}, s \\models \\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(x,y))$ becomes $\\mathcal{M}, s \\models \\forall y\\,\\mathsf{Q}(a,y)$. This is true, as $(a,a) \\in \\mathsf{Q}^{\\mathcal{M}}$ and $(a,b) \\in \\mathsf{Q}^{\\mathcal{M}}$.\n- Now consider the substituted formula $\\forall y\\,(\\mathsf{P}(y)\\to\\mathsf{Q}(y,y))$. In this structure, this becomes $\\forall y\\,\\mathsf{Q}(y,y)$. This is false, because for $y=b$, the condition $\\mathsf{Q}(b,b)$ is not met (i.e., $(b,b) \\notin \\mathsf{Q}^{\\mathcal{M}}$).\n- Since we have found a structure $\\mathcal{M}$ and an assignment $s$ for which the two formulas have different truth values, they are not logically equivalent.\nVerdict: **Incorrect**.\n\n**Option E:** This statement presents the substitution lemma and explains why naive substitution can lead to its failure.\n- The first part is a correct statement of the substitution lemma for capture-avoiding substitution: $\\mathcal{M},s\\models\\varphi[t/x]$ if and only if $\\mathcal{M},s[x\\mapsto\\llbracket t\\rrbracket_{\\mathcal{M},s}]\\models\\varphi$. This lemma is the crucial semantic justification for the syntactic operation of substitution. It asserts that substituting a term for a variable in a formula has the same semantic effect as evaluating the original formula in an environment where the variable is assigned the value of the term.\n- The second part explains the failure of naive substitution: \"when free variables in $t$ become bound as a result of substitution, thereby breaking the inductive proof of the quantifier clauses.\" This is a precise diagnosis. The proof of the substitution lemma proceeds by induction on the structure of $\\varphi$. The inductive step for a quantifier, e.g., $\\forall z \\psi$, relies on the fact that the free variables of $t$ are not captured by $\\forall z$, allowing the substitution to distribute over the quantifier. When capture occurs, this step in the proof fails, and the lemma does not hold.\nVerdict: **Correct**.\n\n**Option F:** This statement proposes an alternative, incorrect method for avoiding capture.\n- It suggests that it is sufficient to \"rename only the bound occurrences of $x$ in $\\varphi$\". This is nonsensical. Substitution, by definition, applies only to *free* occurrences of $x$. Bound occurrences of $x$ within subformulas like $\\forall x \\psi$ are unaffected by the substitution $\\varphi[t/x]$.\n- The critical issue in variable capture is not the variable being replaced ($x$), but the variables in the term being inserted ($t$). The statement claims \"the free variables of $t$ do not need consideration\", which is the exact opposite of the truth. It is precisely the free variables of $t$ that are in danger of being captured by quantifiers in $\\varphi$. The procedure for capture avoidance involves renaming the bound variables in $\\varphi$ that clash with the free variables in $t$.\nVerdict: **Incorrect**.\n\n**Summary of Conclusions**\n- Option A: Correct.\n- Option B: Correct.\n- Option C: Incorrect.\n- Option D: Incorrect.\n- Option E: Correct.\n- Option F: Incorrect.\n\nThe correct options are A, B, and E.", "answer": "$$\\boxed{ABE}$$", "id": "2983801"}, {"introduction": "Tarski's formal definition of truth was not merely a technical exercise; it was designed to satisfy his \"Convention T,\" a criterion of material adequacy that connects the formal definition to our intuitive understanding of truth. This exercise challenges you to apply the full Tarskian semantic apparatus to a concrete sentence and structure, requiring a correct instantiation of the T-schema. Successfully doing so demonstrates a deep understanding of the crucial distinction between the object language being analyzed and the metalanguage used to describe its truth conditions [@problem_id:2983809].", "problem": "Fix a first-order language $L$ containing equality $=$, a constant symbol $0$, and a binary function symbol $+$. Let $\\mathcal{N}$ be the standard $L$-structure with domain $\\mathbb{N}$ that interprets $0$ as $0 \\in \\mathbb{N}$ and $+$ as ordinary addition on $\\mathbb{N}$. Consider the $L$-sentence $\\forall x\\, (x+0=x)$. Your task is to instantiate Convention T (Tarski’s schema for truth) for this sentence by selecting the correct metalanguage biconditional that carefully separates use from mention and renders, in the metalanguage, what the object-language sentence says about the structure $\\mathcal{N}$.\n\nWhich of the following is the correct instance of Convention T for the given sentence in the given structure?\n\nA. \"$\\forall x\\,(x+0=x)$ is true in $\\mathcal{N}$ if and only if $\\forall x\\,(x+0=x)$.\"\n\nB. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$.\"\n\nC. \"‘$\\forall x\\,(x+0=x)$’ is true in $L$ if and only if for all $n \\in \\mathbb{N}$, $n+0=n$.\"\n\nD. \"‘$\\forall x\\,(x+0=x)$’ is true if and only if for all assignments $s$, $\\mathcal{N} \\models x+0=x$.\"\n\nE. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if $\\mathcal{N} \\models \\forall x\\,(x+0=x)$.\"", "solution": "The problem statement is a valid exercise in mathematical logic. It is well-posed, scientifically grounded in model theory, and all terms and conditions are specified with sufficient precision to determine a unique, correct answer.\n\nThe task is to correctly instantiate Alfred Tarski's Convention T for a given sentence in a specific structure. Convention T, also known as the material adequacy condition, demands that any satisfactory definition of truth for a language $L$ must allow for the derivation of a biconditional statement for every sentence $\\phi$ in $L$. This biconditional takes the form:\n$$ \\text{\"}\\phi\\text{\" is true if and only if } P $$\nwhere \"$\\phi$\" on the left-hand side is the *name* of the sentence (a mentioned expression) and $P$ on the right-hand side is the sentence itself *used* in the metalanguage, or rather, a *translation* of $\\phi$ into the metalanguage that describes the state of affairs asserted by $\\phi$. When truth is defined relative to a structure (model-theoretic truth), the schema becomes:\n$$ \\text{\"}\\phi\\text{\" is true in } \\mathcal{M} \\text{ if and only if } P_{\\mathcal{M}} $$\nwhere $\\mathcal{M}$ is the structure and $P_{\\mathcal{M}}$ is the metalanguage statement describing the condition that $\\phi$ asserts about the domain and interpretations of $\\mathcal{M}$.\n\nLet us apply this to the given problem.\nThe object language is $L$, containing symbols $=$, $0$, and $+$.\nThe sentence is $\\phi \\equiv \\forall x\\,(x+0=x)$.\nThe structure is $\\mathcal{N}$, with domain $\\mathbb{N}$, where the constant symbol $0$ is interpreted as the number $0 \\in \\mathbb{N}$ (denoted $0^{\\mathcal{N}}$) and the function symbol $+$ is interpreted as standard addition on $\\mathbb{N}$ (denoted $+^{\\mathcal{N}}$).\n\nThe left-hand side of the T-biconditional must be a statement predicating truth of the sentence $\\phi$ with respect to the structure $\\mathcal{N}$. This must correctly use quotation marks to *mention* the sentence. The proper form is:\n`‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ ...`\n\nThe right-hand side must be the metalanguage translation of what $\\phi$ asserts about the structure $\\mathcal{N}$. We derive this by recursively applying the Tarskian definition of truth:\n1. The sentence is of the form $\\forall x \\, \\psi(x)$, where $\\psi(x)$ is the formula $x+0=x$. The truth definition for a universal quantifier states that $\\mathcal{N} \\models \\forall x \\, \\psi(x)$ if and only if for every element $n$ in the domain of $\\mathcal{N}$, the formula $\\psi(x)$ is satisfied when $x$ is assigned the value $n$. The domain of $\\mathcal{N}$ is $\\mathbb{N}$. So, this translates to: \"for every $n \\in \\mathbb{N}$, the condition corresponding to $x+0=x$ holds for $n$.\"\n\n2. Now we translate the atomic formula $x+0=x$ for an element $n \\in \\mathbb{N}$. The formula is an equality between two terms, $t_1 \\equiv x+0$ and $t_2 \\equiv x$. The formula is satisfied if the interpretations of these terms are equal.\n    - The interpretation of the term $t_1 \\equiv x+0$ involves applying the interpretation of the function symbol $+$, which is the function $+^{\\mathcal{N}}$, to the interpretations of the variable $x$ and the constant symbol $0$. For an element $n \\in \\mathbb{N}$, the variable $x$ evaluates to $n$, and the constant symbol $0$ evaluates to its interpretation $0^{\\mathcal{N}}$. Thus, the term $x+0$ evaluates to $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}})$.\n    - The interpretation of the term $t_2 \\equiv x$ is simply the element $n$ assigned to the variable $x$.\n    - Therefore, the condition that $x+0=x$ holds for $n$ translates to the metalanguage equality: $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$.\n\n3. Combining these steps, the full metalanguage translation $P_{\\mathcal{N}}$ is: \"for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n, 0^{\\mathcal{N}}) = n$.\"\n\nPutting both sides together, the correct T-biconditional is:\n`‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$.`\n\nNow we evaluate the given options.\n\n**A. \"$\\forall x\\,(x+0=x)$ is true in $\\mathcal{N}$ if and only if $\\forall x\\,(x+0=x)$.\"**\nThis option has a fatal use-mention confusion. The phrase `$\\forall x\\,(x+0=x)$` on the left is used as a subject, but it is not placed in quotes, failing to properly name the sentence. More fundamentally, the right-hand side simply repeats the object-language sentence. Convention T requires a translation into the metalanguage that describes the conditions on the model's domain, not a repetition of the object-language syntax. This biconditional is uninformative.\n**Verdict: Incorrect.**\n\n**B. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if for every $n \\in \\mathbb{N}$, $+^{\\mathcal{N}}(n,0^{\\mathcal{N}})=n$.\"**\nThis option perfectly matches our derivation.\n- The left side correctly mentions the sentence `‘$\\forall x\\,(x+0=x)$’` and predicates its truth in the structure $\\mathcal{N}$.\n- The right side provides a precise metalanguage translation of the sentence's meaning, describing a property of the elements in the domain $\\mathbb{N}$ and the interpretations of the symbols, $+^{\\mathcal{N}}$ and $0^{\\mathcal{N}}$. It correctly unpacks the universal quantifier and the interpretation of the terms.\n**Verdict: Correct.**\n\n**C. \"‘$\\forall x\\,(x+0=x)$’ is true in $L$ if and only if for all $n \\in \\mathbb{N}$, $n+0=n$.\"**\nThis option contains a critical error on the left side. Truth is not defined for a language $L$, but for a sentence *in a structure* (or interpretation) $\\mathcal{N}$ for that language. A sentence can be true in one structure and false in another. The phrase \"true in $L$\" is syntactically an error and conceptually meaningless in model theory. While the right side is a correct, though slightly less formal, metalanguage translation, the error on the left side invalidates the entire statement.\n**Verdict: Incorrect.**\n\n**D. \"‘$\\forall x\\,(x+0=x)$’ is true if and only if for all assignments $s$, $\\mathcal{N} \\models x+0=x$.\"**\nThis option is flawed for multiple reasons. First, the left side is incomplete, omitting \"in $\\mathcal{N}$\". Second, and more importantly, the right-hand side does not provide the required translation into a statement about the domain objects. Instead, it couches the condition in semantic terms by using the satisfaction relation `$\\models$`. This is circular. The statement `$\\mathcal{N} \\models \\forall x \\psi(x)$` is *defined* in terms of satisfaction for all assignments (or, more accurately, for all domain elements substituted for $x$). Convention T requires the elimination of semantic predicates like `$\\models$` from the right-hand side, replacing them with the actual conditions in the domain.\n**Verdict: Incorrect.**\n\n**E. \"‘$\\forall x\\,(x+0=x)$’ is true in $\\mathcal{N}$ if and only if $\\mathcal{N} \\models \\forall x\\,(x+0=x)$.\"**\nThis statement is a tautology. The English phrase \"`‘\\phi’` is true in $\\mathcal{N}$\" is simply the natural language reading of the formal notation `$\\mathcal{N} \\models \\phi$`. Thus, this option asserts that a statement is true if and only if it is true. This does not provide the required translation of the object-language sentence into a non-semantic assertion about the domain, and is therefore not a correct instantiation of Convention T.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{B}$$", "id": "2983809"}]}