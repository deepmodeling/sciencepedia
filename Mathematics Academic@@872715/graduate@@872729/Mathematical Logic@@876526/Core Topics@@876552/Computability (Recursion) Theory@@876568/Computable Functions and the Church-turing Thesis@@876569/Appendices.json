{"hands_on_practices": [{"introduction": "The Church-Turing thesis posits that any function intuitively considered \"computable\" can be computed by a Turing machine. This exercise grounds this abstract claim in concrete reality by challenging you to construct a Turing machine for a fundamental arithmetic operation, addition, from first principles. By defining the states and transition rules, you will gain a deep appreciation for how a simple, formal model can execute a step-by-step algorithm, directly engaging with the mechanistic nature of computation. [@problem_id:2970583]", "problem": "A deterministic single-tape Turing Machine (TM) is given formally as a $7$-tuple $(Q,\\Sigma,\\Gamma,\\delta,q_{0},q_{\\mathrm{acc}},q_{\\mathrm{rej}})$, where $Q$ is a finite set of states, $\\Sigma \\subseteq \\Gamma \\setminus \\{\\sqcup\\}$ is the input alphabet, $\\Gamma$ is the tape alphabet, $\\delta: Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\{L,N,R\\}$ is the transition function mapping a current state and scanned symbol to a next state, a symbol to write, and a head move left ($L$), no move ($N$), or right ($R$), $q_{0} \\in Q$ is the start state, and $q_{\\mathrm{acc}}, q_{\\mathrm{rej}} \\in Q$ are halting accept and reject states. Unary representation encodes a natural number $k$ as the string $1^{k}$, and we encode a pair $(m,n)$ as the concatenation $1^{m} 0 1^{n}$ on the tape, surrounded by blanks $\\sqcup$.\n\nStarting from the foundational definitions of Turing computability and the unary encoding above, construct a deterministic single-tape TM that computes the total function $f(m,n) = m + n$ by transforming an input with tape contents $\\sqcup^{\\omega} 1^{m} 0 1^{n} \\sqcup^{\\omega}$ into an output $\\sqcup^{\\omega} 1^{m+n} \\sqcup^{\\omega}$ and then halting in the accept state. The head initially scans the leftmost nonblank symbol of the input. Your construction must implement addition via a move-and-erase strategy: first eliminate the separator $0$ by writing a blank $\\sqcup$, thereby creating a single-cell gap, and then shift the right block of 1-symbols left by one cell using a loop that repeatedly moves and erases a single $1$ from immediately to the right of the gap into the gap until the gap reaches the right end of the block.\n\nExplicitly provide:\n- The tape alphabet $\\Gamma$, input alphabet $\\Sigma$, blank symbol, and the set of named states in $Q$.\n- The transition function $\\delta$ entries for all state-symbol pairs that occur during correct computation on inputs of the form $1^{m} 0 1^{n}$, covering the phases that scan to the separator, erase the separator, inspect the symbol immediately to the right of the gap, write $1$ into the gap when appropriate, erase the moved $1$, and decide to halt.\n- A brief invariant-based argument from first principles that this TM computes $f(m,n) = m+n$ as specified by the Church–Turing thesis, namely that the informal algorithm of eliminating the separator and shifting the right block is realized by the formal transition system and halts on all inputs of the specified form with the correct output.\n\nFinally, derive the exact number of head moves, denoted $T(m,n)$, executed by your TM from the initial configuration on input $1^{m} 0 1^{n}$ until halting. Express $T(m,n)$ as a single closed-form analytic expression in terms of $m$ and $n$. No rounding is required, and no units apply. The final answer must be a single expression.", "solution": "To construct the Turing machine, we define its components and transition function based on the specified algorithm.\n\n### TM Components\n\n*   **Set of States ($Q$)**: We define a set of states to manage the phases of the computation: $Q = \\{q_0, q_{\\text{find1}}, q_{\\text{carry1}}, q_{\\text{write1}}, q_{\\text{acc}}, q_{\\text{rej}}\\}$.\n    *   $q_0$: Initial state, scans right to find the separator `0`.\n    *   $q_{\\text{find1}}$: Scans for the next `1` in the right-hand block to be shifted.\n    *   $q_{\\text{carry1}}$: Moves a \"picked-up\" `1` leftward to fill the current gap.\n    *   $q_{\\text{write1}}$: State after writing a `1` into the gap, preparing to move to the new gap.\n    *   $q_{\\text{acc}}$: The halting accept state.\n    *   $q_{\\text{rej}}$: The halting reject state (not used for valid inputs).\n*   **Input Alphabet ($\\Sigma$)**: $\\Sigma = \\{0, 1\\}$.\n*   **Tape Alphabet ($\\Gamma$)**: $\\Gamma = \\{0, 1, \\sqcup\\}$, where $\\sqcup$ is the blank symbol.\n\n### Transition Function ($\\delta$)\n\nThe transitions are designed to execute the algorithm in phases:\n\n1.  **Phase 1: Scan to the separator.** In state $q_0$, the machine moves right over the initial block of $m$ ones.\n    $$ \\delta(q_0, 1) = (q_0, 1, R) $$\n\n2.  **Phase 2: Erase the separator.** When the separator `0` is found, it is replaced with a blank $\\sqcup$, and the head moves right to start the shifting process.\n    $$ \\delta(q_0, 0) = (q_{\\text{find1}}, \\sqcup, R) $$\n\n3.  **Phase 3: The shifting loop and termination.** This loop shifts the block $1^n$ one cell to the left.\n    *   **Find a `1` to move:** In state $q_{\\text{find1}}$, if a `1` is found, it is erased (replaced with $\\sqcup$) and the machine enters state $q_{\\text{carry1}}$ to move it left.\n        $$ \\delta(q_{\\text{find1}}, 1) = (q_{\\text{carry1}}, \\sqcup, L) $$\n    *   **Termination condition:** If state $q_{\\text{find1}}$ encounters a $\\sqcup$, it means all $n$ ones have been shifted. The computation is complete, and the machine halts.\n        $$ \\delta(q_{\\text{find1}}, \\sqcup) = (q_{\\text{acc}}, \\sqcup, N) $$\n    *   **Move `1` left:** In state $q_{\\text{carry1}}$, the machine moves left to find the $\\sqcup$ gap. The construction ensures this takes one left move. It writes a `1` and enters state $q_{\\text{write1}}$.\n        $$ \\delta(q_{\\text{carry1}}, \\sqcup) = (q_{\\text{write1}}, 1, R) $$\n    *   **Reposition for next search:** In state $q_{\\text{write1}}$, the machine has just filled the old gap. It moves right over the newly created gap to re-enter state $q_{\\text{find1}}$ and search for the next `1`.\n        $$ \\delta(q_{\\text{write1}}, \\sqcup) = (q_{\\text{find1}}, \\sqcup, R) $$\n\n### Invariant-Based Argument for Correctness\n\nThe TM correctly computes $f(m,n)=m+n$.\n*   **Initialization**: The machine starts with tape contents $\\sqcup^{\\omega} 1^m 0 1^n \\sqcup^{\\omega}$.\n*   **Pre-Loop**: The transitions for state $q_0$ move the head across the $m$ ones and replace the separator `0` with a $\\sqcup$. The tape becomes $\\sqcup^{\\omega} 1^m \\sqcup 1^n \\sqcup^{\\omega}$, and the machine is in state $q_{\\text{find1}}$ over the first `1` of the $1^n$ block (or a $\\sqcup$ if $n=0$).\n*   **Loop Invariant**: At the start of the $k$-th iteration of the main loop (for $k \\in \\{1, \\dots, n\\}$), the tape holds the string $1^{m+k-1} \\sqcup 1^{n-(k-1)}$, the state is $q_{\\text{find1}}$, and the head scans the leftmost `1` of the right block. A single execution of the loop transforms the tape to $1^{m+k} \\sqcup 1^{n-k}$ and restores the machine to state $q_{\\text{find1}}$ at the start of the new right block, preserving the invariant for the next iteration.\n*   **Termination**: The loop runs $n$ times. After the $n$-th iteration, the tape holds $1^{m+n} \\sqcup$. The machine, in state $q_{\\text{find1}}$, then scans right and finds a $\\sqcup$. This triggers the transition to $q_{\\text{acc}}$, halting the machine. The final tape contains $\\sqcup^{\\omega} 1^{m+n} \\sqcup^{\\omega}$, the correct output. This constructive procedure demonstrates that addition is Turing-computable, aligning with the Church-Turing thesis.\n\n### Derivation of Head Moves $T(m,n)$\n\nThe total number of head moves, $T(m,n)$, is calculated by summing the moves in each phase for an input $1^m 0 1^n$:\n\n1.  **Scan to separator**: $m$ right moves.\n2.  **Erase separator**: $1$ right move.\n3.  **Shifting loop**: The loop runs $n$ times. Each iteration involves:\n    *   One left move ($\\delta(q_{\\text{find1}}, 1)$).\n    *   One right move ($\\delta(q_{\\text{carry1}}, \\sqcup)$).\n    *   One right move ($\\delta(q_{\\text{write1}}, \\sqcup)$).\n    This totals $3$ moves per iteration, for a total of $3n$ moves.\n4.  **Termination**: The final transition to $q_{\\text{acc}}$ involves $0$ moves.\n\nThe total number of head moves is the sum:\n$$ T(m,n) = m + 1 + 3n + 0 = m + 3n + 1 $$\nThis formula holds for all non-negative integers $m, n \\geq 0$.", "answer": "$$\\boxed{m+3n+1}$$", "id": "2970583"}, {"introduction": "While the class of primitive recursive functions is powerful, it is limited to functions that are total, meaning they must halt on all inputs. This practice explores the unbounded minimization, or $\\mu$-operator, which is the crucial tool for extending our formalism to partial recursive functions, thereby capturing the full power of Turing machines. By analyzing a function defined with the $\\mu$-operator, you will see precisely how unbounded search can lead to non-terminating computations, a foundational concept in understanding the limits of what can be effectively calculated. [@problem_id:2970597]", "problem": "Let $\\mathbb{N}$ denote the set of natural numbers, and recall the foundational framework of primitive recursion: initial functions (zero, successor, projections) together with closure under composition and primitive recursion generate the class of primitive recursive functions, and a relation is primitive recursive if its characteristic function is primitive recursive. The Church-Turing Thesis (CTT) asserts that effectively computable functions on $\\mathbb{N}$ coincide with those computable by any reasonable formalism, such as a Turing machine; in the arithmetic hierarchy, the unbounded minimization operator extends primitive recursion to partial recursive functions, not guaranteed to be total.\n\nDefine the unbounded minimization (the $\\mu$-operator) as follows: for a predicate $R(x,y)$ on $\\mathbb{N}$, the term $\\mu y\\, R(x,y)$ denotes the least $y$ such that $R(x,y)$ holds, if such a $y$ exists, and otherwise it does not yield a value (the search does not terminate). Consider the explicit primitive recursive predicate\n$$\nR(x,y) \\equiv \\big(1y\\big)\\wedge \\big(yx\\big)\\wedge \\big(y \\text{ divides } x\\big),\n$$\nwhere “$y$ divides $x$” abbreviates the existence of $k\\leq x$ with $y\\cdot k=x$, and inequalities and multiplication are taken in their usual arithmetic sense on $\\mathbb{N}$.\n\nDefine the function\n$$\nf(x) \\;=\\; \\mu y\\, R(x,y),\n$$\nthat is, $f(x)$ is the least nontrivial divisor of $x$ strictly between $1$ and $x$ if such a divisor exists. Starting from the fundamental definitions and closure properties of primitive recursive functions and relations, justify that $R$ is primitive recursive, explain why the unbounded $\\mu$ applied to $R$ can yield a partial function (give a clear condition on $x$ for which the search diverges), and determine the exact value of $f(2023)$.\n\nYour final answer must be a single real-valued number. No rounding is required.", "solution": "The problem requires a three-part analysis of a function $f(x)$ defined using the unbounded minimization operator $\\mu$. The analysis involves: 1. Justifying that the predicate $R(x,y)$ used in the definition of $f(x)$ is primitive recursive. 2. Explaining why $f(x)$ is a partial, not total, function by identifying the conditions on $x$ for which its value is undefined. 3. Calculating the specific value of $f(2023)$.\n\nFirst, we address the primitive recursiveness of the predicate $R(x,y)$. A relation is defined as primitive recursive if its characteristic function is a primitive recursive function. The characteristic function $\\chi_P$ of a predicate $P$ is defined as $\\chi_P(\\dots) = 1$ if $P(\\dots)$ is true, and $\\chi_P(\\dots) = 0$ if $P(\\dots)$ is false.\n\nThe predicate is given by\n$$\nR(x,y) \\equiv \\big(1y\\big)\\wedge \\big(yx\\big)\\wedge \\big(y \\text{ divides } x\\big).\n$$\nThe class of primitive recursive relations is closed under the logical operations of conjunction ($\\wedge$), disjunction ($\\vee$), negation ($\\neg$), and bounded quantification ($\\forall zt$, $\\exists zt$). This is because the characteristic functions of the resulting relations can be constructed from the characteristic functions of the original relations using primitive recursive functions like multiplication and addition. Specifically, for two predicates $P_1$ and $P_2$, the characteristic function of their conjunction, $\\chi_{P_1 \\wedge P_2}$, can be expressed as $\\chi_{P_1} \\cdot \\chi_{P_2}$. Therefore, if we can show that each component of the conjunction is a primitive recursive relation, then $R(x,y)$ itself must be a primitive recursive relation.\n\nThe three component predicates are:\n1.  $P_1(y) \\equiv 1  y$\n2.  $P_2(x,y) \\equiv y  x$\n3.  $P_3(x,y) \\equiv y \\text{ divides } x$\n\nFor $P_1$ and $P_2$, the \"less than\" relation, $u  v$, is a standard primitive recursive relation. Its characteristic function can be defined using limited subtraction (monus), denoted $u \\dot{-} v$, which is known to be primitive recursive. For example, $\\chi_{uv}(u,v) = 1 \\dot{-} (1 \\dot{-} (v \\dot{-} u))$. Since constants (like $1$) and projection functions are primitive recursive, the relations $1  y$ and $y  x$ are primitive recursive.\n\nFor $P_3(x,y)$, the problem defines \"$y$ divides $x$\" as the existence of a $k \\leq x$ such that $y \\cdot k = x$. This can be written formally using a bounded existential quantifier:\n$$\nP_3(x,y) \\equiv (\\exists k \\leq x) [y \\cdot k = x].\n$$\nThe predicate inside the quantifier is $Q(x,y,k) \\equiv (y \\cdot k = x)$. The multiplication function ($y \\cdot k$) is a primitive recursive function. The equality relation ($u=v$) is a primitive recursive relation (its characteristic function can also be built using monus: $1 \\dot{-} ((u \\dot{-} v) + (v \\dot{-} u))$). Since a predicate formed by comparing two primitive recursive functions is primitive recursive, $Q(x,y,k)$ is a primitive recursive relation. The class of primitive recursive relations is closed under bounded existential quantification. Therefore, $P_3(x,y)$ is a primitive recursive relation.\n\nSince $P_1(y)$, $P_2(x,y)$, and $P_3(x,y)$ are all primitive recursive relations, their conjunction, $R(x,y)$, is also a primitive recursive relation.\n\nSecond, we explain why $f(x) = \\mu y\\, R(x,y)$ can be a partial function. The unbounded minimization operator $\\mu y \\, R(x,y)$ is defined as the least natural number $y$ for which the predicate $R(x,y)$ holds true. The computation of $f(x)$ involves a search, testing $y=0, 1, 2, \\dots$ in sequence, until a $y$ is found that satisfies $R(x,y)$. If no such $y$ exists, the search never terminates, and the function $f(x)$ is undefined for that input $x$.\n\nFor a given $x$, $f(x)$ is defined if and only if there exists a $y \\in \\mathbb{N}$ such that $R(x,y)$ is true. The predicate $R(x,y)$ is true if $y$ is a divisor of $x$ and simultaneously satisfies $1  y  x$. A divisor $y$ of $x$ satisfying $1  y  x$ is known as a proper, non-trivial divisor. The existence of such a divisor is the definition of a composite number.\n\nTherefore, the search for $y$ will terminate if and only if $x$ is a composite number. If $x$ is not composite, no such $y$ exists, and the function $f(x)$ will be undefined. The numbers that are not composite are the prime numbers, and the special cases $x=0$ and $x=1$.\n- If $x$ is prime, its only positive divisors are $1$ and $x$. Neither satisfies the condition $1  y  x$.\n- If $x=1$, the condition $yx$ (i.e., $y1$) is only satisfied by $y=0$. But $y=0$ does not satisfy $1y$. So no $y$ works.\n- If $x=0$, the condition $yx$ (i.e., $y0$) is never satisfied for any $y \\in \\mathbb{N}$.\n\nThus, $f(x)$ is a partial function which is defined only for composite numbers $x \\geq 4$. For all prime numbers $x$, and for $x \\in \\{0, 1\\}$, $f(x)$ is undefined.\n\nThird, we determine the value of $f(2023)$. Based on the definition, $f(2023)$ is the smallest natural number $y$ such that $1  y  2023$ and $y$ divides $2023$. This is equivalent to finding the smallest prime factor of $2023$. We test small prime numbers in increasing order.\n- For $y=2$: $2023$ is an odd number, so it is not divisible by $2$.\n- For $y=3$: The sum of the digits of $2023$ is $2+0+2+3=7$. Since $7$ is not divisible by $3$, $2023$ is not divisible by $3$.\n- For $y=5$: The last digit of $2023$ is not $0$ or $5$, so it is not divisible by $5$.\n- For $y=7$: We perform the division: $2023 \\div 7$.\n  $20 \\div 7 = 2$ with a remainder of $6$.\n  $62 \\div 7 = 8$ with a remainder of $6$.\n  $63 \\div 7 = 9$ with a remainder of $0$.\n  So, $2023 = 7 \\times 289$.\n\nSince $y=7$ divides $2023$, and it satisfies the conditions $1  7$ and $7  2023$, the predicate $R(2023, 7)$ is true. As we have shown that no smaller integer $y1$ divides $2023$, the value $y=7$ is the least natural number satisfying the predicate.\nTherefore, by definition of the $\\mu$-operator, $f(2023) = 7$.\nFor completeness, we note that $289 = 17^2$, so the prime factorization of $2023$ is $7 \\times 17^2$. The set of divisors of $2023$ strictly between $1$ and $2023$ is $\\{7, 17, 119, 289\\}$. The least element of this set is indeed $7$.", "answer": "$$\n\\boxed{7}\n$$", "id": "2970597"}, {"introduction": "The formal equivalence between Turing machines and recursive functions gives rise to profound meta-mathematical tools, notably the $s$-$m$-$n$ theorem and Kleene's recursion theorem. These theorems enable programs to manipulate and refer to their own code, a cornerstone of computability theory. This advanced practice challenges you to apply these powerful results to construct a \"quine\" — a program that outputs its own description — providing a hands-on experience with the logic of self-reference. [@problem_id:2970608]", "problem": "Fix an acceptable Gödel numbering of partial computable functions so that for each $e \\in \\mathbb{N}$, the index $e$ names a unary partial computable function $y \\mapsto \\varphi_{e}(y)$, and for each $e \\in \\mathbb{N}$, the index $e$ also names a binary partial computable function $(x,y) \\mapsto \\varphi_{e}^{(2)}(x,y)$ (obtained by any standard uniform pairing of inputs). Assume the following foundational facts.\n\n1. There exists a total primitive recursive pairing function $\\langle \\cdot,\\cdot \\rangle : \\mathbb{N}^{2} \\to \\mathbb{N}$ that is bijective with primitive recursive projections.\n2. There exists a universal index $U$ for the binary enumeration such that for all $e,a,y \\in \\mathbb{N}$, one has $\\varphi_{U}^{(2)}(\\langle e,a \\rangle, y) = \\varphi_{e}^{(2)}(a,y)$.\n3. (Kleene $s$-$m$-$n$) There exists a total primitive recursive function $s : \\mathbb{N}^{2} \\to \\mathbb{N}$ such that for all $e,a,y \\in \\mathbb{N}$, one has $\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)$.\n4. Fix an index $p$ for the binary “print” program, defined by $\\varphi_{p}^{(2)}(x,y) = x$ for all $x,y \\in \\mathbb{N}$.\n\nDefine the binary partial computable function $D : \\mathbb{N}^{2} \\rightrightarrows \\mathbb{N}$ by\n$$\nD(x,y) \\;=\\; \\varphi_{s(p,\\,s(x,x))}(y),\n$$\nand fix any index $d$ satisfying $\\varphi_{d}^{(2)}(x,y) = D(x,y)$ for all $x,y \\in \\mathbb{N}$.\n\nUsing only the fundamental facts above (especially the Kleene Recursion Theorem and the $s$-$m$-$n$ theorem), construct a unary self-referential program (a “quine”) that on any input $y$ outputs its own index. Your construction must proceed from first principles by explicitly building the index as a computable expression from the given primitives $s$, $p$, and the chosen index $d$. In the course of your derivation, explain the conceptual role that the $s$-$m$-$n$ theorem plays in enabling the self-reference.\n\nWhat is a single closed-form expression, in terms of the symbols $s$ and $d$ introduced above, for the index $e^{\\star}$ of such a quine? Provide your final answer as a single symbolic expression. No numerical approximation or rounding is required.", "solution": "The objective is to find an index $e^{\\star} \\in \\mathbb{N}$ such that for all inputs $y \\in \\mathbb{N}$, the partial computable function $\\varphi_{e^{\\star}}$ halts and outputs its own index: $\\varphi_{e^{\\star}}(y) = e^{\\star}$. This self-referential program, or quine, is constructed by applying the principles of the Kleene Recursion Theorem.\n\nThe core mechanism is the $s$-$m$-$n$ theorem. It provides a computable way to transform a program that takes two inputs, $\\varphi_e^{(2)}(x,y)$, into a specialized program, $\\varphi_{s(e,a)}(y)$, by fixing the first input $x=a$. This ability for programs to manipulate their own and other programs' indices enables the required self-reference.\n\nThe construction begins by analyzing the function $D(x,y) = \\varphi_{s(p,s(x,x))}(y)$. We are given that $d$ is an index for this function, so $\\varphi_d^{(2)}(x,y) = D(x,y)$ for all $x,y \\in \\mathbb{N}$.\n\nLet us simplify the expression for $D(x,y)$. By the definition of the $s$-$m$-$n$ theorem:\n$$ \\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y) $$\nIn the expression for $D(x,y)$, we identify $e=p$ and $a=s(x,x)$, which gives:\n$$ \\varphi_{s(p, s(x,x))}(y) = \\varphi_{p}^{(2)}(s(x,x), y) $$\nThe index $p$ corresponds to the \"print\" program, where $\\varphi_{p}^{(2)}(z,y) = z$. Substituting $z = s(x,x)$ yields:\n$$ \\varphi_{p}^{(2)}(s(x,x), y) = s(x,x) $$\nTherefore, the function $D(x,y)$ simplifies to $D(x,y) = s(x,x)$. Since $d$ is the index for $D(x,y)$, we have established a crucial property:\n$$ \\varphi_{d}^{(2)}(x,y) = s(x,x) $$\nThis program with index $d$ takes two inputs, $x$ and $y$, ignores $y$, and returns the value $s(x,x)$.\n\nWe now employ the standard construction from the proof of the Recursion Theorem. We define the candidate index for our quine as:\n$$ e^{\\star} = s(d,d) $$\nTo verify this, we evaluate the function $\\varphi_{e^{\\star}}(y)$ for an arbitrary input $y$:\n$$ \\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y) $$\nApplying the $s$-$m$-$n$ theorem (with $e=d$ and $a=d$):\n$$ \\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y) $$\nUsing our property of the function $\\varphi_d^{(2)}$ (with $x=d$):\n$$ \\varphi_{d}^{(2)}(d,y) = s(d,d) $$\nChaining these equalities together:\n$$ \\varphi_{e^{\\star}}(y) = s(d,d) $$\nSince we defined $e^{\\star} = s(d,d)$, we have shown that for any input $y$, $\\varphi_{e^{\\star}}(y) = e^{\\star}$. This confirms that $s(d,d)$ is the index of a quine.", "answer": "$$\n\\boxed{s(d,d)}\n$$", "id": "2970608"}]}