{"hands_on_practices": [{"introduction": "A central theme in special holonomy is that restricting the holonomy group of a Riemannian manifold has profound consequences for its global topology. This practice provides a direct look at this principle by examining the K3 surface, a foundational example of a hyperkähler manifold with holonomy in $\\mathrm{SU}(2)$. By starting with the Hodge numbers, which are constrained by the special geometry, you will compute the Betti numbers and thereby uncover the topological \"fingerprint\" that the special holonomy imposes on the manifold [@problem_id:2990640].", "problem": "Let $X$ be a compact complex surface of K3 type: it is simply connected, has trivial canonical bundle $K_{X} \\cong \\mathcal{O}_{X}$, and admits a Ricci-flat Kähler metric, so its Riemannian holonomy is contained in the Special Unitary group $\\mathrm{SU}(2)$. The Hodge numbers of $X$ are specified by\n$$\nh^{0,0} = h^{2,2} = 1, \\quad h^{2,0} = h^{0,2} = 1, \\quad h^{1,1} = 20,\n$$\nand all other $h^{p,q}$ vanish. Using only foundational properties of compact Kähler manifolds and cohomological dualities, compute the Betti numbers $b_{k}$ for $k = 0,1,2,3,4$ of $X$. Provide your final answer as the row matrix $\\left(b_{0}, b_{1}, b_{2}, b_{3}, b_{4}\\right)$ and, in the course of your computation, verify the identities $b_{2} = 22$ and $b_{1} = b_{3} = 0$. No rounding is required.", "solution": "The Betti numbers, $b_k$, of a compact Kähler manifold $X$ are related to its Hodge numbers, $h^{p,q}$, through the Hodge decomposition of the de Rham cohomology groups. For a compact Kähler manifold of complex dimension $n$, the $k$-th Betti number is the dimension of the $k$-th de Rham cohomology group, $b_k = \\dim_{\\mathbb{C}} H^k(X, \\mathbb{C})$, and is given by the sum over all Hodge numbers $h^{p,q} = \\dim_{\\mathbb{C}} H^{p,q}(X)$ such that $p+q=k$:\n$$b_k = \\sum_{p+q=k} h^{p,q}$$\nThe problem provides a compact complex surface of K3 type, for which the complex dimension is $n=2$. This implies its real dimension is $2n=4$, so we need to compute the Betti numbers $b_k$ for $k=0, 1, 2, 3, 4$. The computation will rely on the provided Hodge numbers and general theorems for compact Kähler manifolds.\n\nThe givens are:\n- $X$ is a compact complex surface ($n=2$).\n- $X$ is simply connected ($\\pi_1(X) = 0$).\n- The Hodge numbers are $h^{0,0} = 1$, $h^{2,2} = 1$, $h^{2,0} = 1$, $h^{0,2} = 1$, $h^{1,1} = 20$.\n- All other Hodge numbers $h^{p,q}$ are zero for $p+q \\le 4$.\n\nWe will also use two fundamental duality theorems:\n1.  **Poincaré Duality**: For a compact, orientable, real $m$-dimensional manifold, $b_k = b_{m-k}$. Since $X$ is a complex surface, it is orientable and has real dimension $m=4$, so $b_k = b_{4-k}$.\n2.  **Serre Duality**: For a compact complex $n$-dimensional manifold, $h^{p,q} = h^{n-p, n-q}$. For $X$, with $n=2$, this means $h^{p,q} = h^{2-p, 2-q}$.\n\nLet's compute each Betti number systematically.\n\n**Computation of $b_0$**:\nThe $0$-th Betti number for any connected manifold is $1$. A K3 surface is connected. Thus, $b_0 = 1$.\nUsing the Hodge decomposition formula:\n$$b_0 = \\sum_{p+q=0} h^{p,q} = h^{0,0}$$\nThe problem states that $h^{0,0} = 1$. This confirms that $b_0=1$.\n\n**Computation of $b_1$**:\nThe problem states that the surface $X$ is simply connected. For a general topological space, the first homology group $H_1(X, \\mathbb{Z})$ is the abelianization of the fundamental group $\\pi_1(X)$. Since $\\pi_1(X)$ is trivial, $H_1(X, \\mathbb{Z}) = 0$. By the universal coefficient theorem for cohomology, the first cohomology group with complex coefficients is $H^1(X, \\mathbb{C}) = \\mathrm{Hom}(H_1(X, \\mathbb{Z}), \\mathbb{C}) = 0$. The dimension of this group is the first Betti number, so $b_1 = 0$.\nWe can verify this using the Hodge numbers:\n$$b_1 = \\sum_{p+q=1} h^{p,q} = h^{1,0} + h^{0,1}$$\nThe problem states that all other Hodge numbers are zero, which implies $h^{1,0}=0$ and $h^{0,1}=0$. Therefore, $b_1 = 0+0=0$. This is consistent and verifies the first part of the identity $b_1=b_3=0$.\n\n**Computation of $b_2$**:\nUsing the Hodge decomposition:\n$$b_2 = \\sum_{p+q=2} h^{p,q} = h^{2,0} + h^{1,1} + h^{0,2}$$\nWe are given the values $h^{2,0}=1$, $h^{1,1}=20$, and $h^{0,2}=1$. Substituting these values, we find:\n$$b_2 = 1 + 20 + 1 = 22$$\nThis verifies the identity $b_2=22$ stated in the problem. The given value $h^{0,2} = 1$ is also consistent with Hodge conjugation, which requires $h^{p,q} = h^{q,p}$, as $h^{0,2} = h^{2,0} = 1$.\n\n**Computation of $b_3$**:\nWe use Poincaré duality for a compact real $4$-manifold:\n$$b_3 = b_{4-3} = b_1$$\nSince we have already established that $b_1=0$, it immediately follows that $b_3=0$. This verifies the second part of the identity $b_1=b_3=0$.\nTo confirm this with the Hodge decomposition:\n$$b_3 = \\sum_{p+q=3} h^{p,q} = h^{2,1} + h^{1,2}$$\nThe problem implies $h^{2,1}=0$ and $h^{1,2}=0$. We can also derive this using Serre duality ($h^{p,q} = h^{2-p, 2-q}$):\n$$h^{2,1} = h^{2-2, 2-1} = h^{0,1}$$\n$$h^{1,2} = h^{2-1, 2-2} = h^{1,0}$$\nSince $h^{1,0}=0$ and $h^{0,1}=0$, it follows that $h^{1,2}=0$ and $h^{2,1}=0$.\nThus, $b_3 = 0+0=0$. This is again perfectly consistent.\n\n**Computation of $b_4$**:\nUsing Poincaré duality:\n$$b_4 = b_{4-4} = b_0$$\nSince $b_0=1$, we have $b_4=1$.\nUsing the Hodge decomposition:\n$$b_4 = \\sum_{p+q=4} h^{p,q} = h^{2,2}$$\nThe problem gives $h^{2,2}=1$, which confirms that $b_4=1$. This is also consistent with Serre duality, as $h^{2,2}=h^{2-2, 2-2}=h^{0,0}=1$.\n\n**Summary of Results**:\nThe computed Betti numbers for the K3 surface $X$ are:\n- $b_0 = 1$\n- $b_1 = 0$\n- $b_2 = 22$\n- $b_3 = 0$\n- $b_4 = 1$\n\nThe ordered vector of Betti numbers is $(1, 0, 22, 0, 1)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 0 & 22 & 0 & 1\n\\end{pmatrix}\n}\n$$", "id": "2990640"}, {"introduction": "Moving beyond the Kähler setting, we encounter the exceptional holonomy groups, which are defined by intricate algebraic structures. This exercise invites you to construct the exceptional group $G_2$ from first principles, starting with its definition as the subgroup of $\\mathrm{SO}(7)$ that preserves a specific 3-form $\\varphi_0$. You will connect this geometric definition to the underlying algebraic structure of the octonions, identifying the Lie algebra $\\mathfrak{g}_2$ with an algebra of derivations, thus demystifying one of the most important objects in the theory [@problem_id:2990643].", "problem": "Let $\\{e^{1},\\dots,e^{7}\\}$ be the standard orthonormal coframe on $\\mathbb{R}^{7}$ with the usual Euclidean metric $g_{0}$ and orientation. Denote $e^{ijk}=e^{i}\\wedge e^{j}\\wedge e^{k}$. Consider the $3$-form\n$$\n\\varphi_{0}=e^{123}+e^{145}+e^{167}+e^{246}-e^{257}-e^{347}-e^{356}.\n$$\nLet $\\mathrm{SO}(7)$ denote the Special Orthogonal group (SO) of the Euclidean metric $g_{0}$. The group $\\mathrm{SO}(7)$ acts on $\\Lambda^{3}(\\mathbb{R}^{7})$ by pullback: for $A\\in\\mathrm{SO}(7)$ and $\\psi\\in\\Lambda^{3}(\\mathbb{R}^{7})$, set $A^{*}\\psi(u,v,w)=\\psi(Au,Av,Aw)$. Define the stabilizer subgroup\n$$\nH=\\{A\\in \\mathrm{SO}(7)\\mid A^{*}\\varphi_{0}=\\varphi_{0}\\}.\n$$\nUsing only the core definitions of the action of $\\mathrm{SO}(7)$ on differential forms, the inner product $g_{0}$, and the cross product induced by a $3$-form via $g_{0}$, and relying on well-tested facts about derivations of the octonion algebra, carry out the following:\n\n- Derive that $H$ preserves the cross product $\\times_{\\varphi_{0}}$ defined by the condition\n$$\ng_{0}(u\\times_{\\varphi_{0}} v,w)=\\varphi_{0}(u,v,w)\n$$\nfor all $u,v,w\\in\\mathbb{R}^{7}$.\n\n- By differentiating the defining condition $A^{*}\\varphi_{0}=\\varphi_{0}$ along smooth curves $A(t)\\in \\mathrm{SO}(7)$ with $A(0)=\\mathrm{Id}$, identify the Lie algebra $\\mathfrak{h}$ of $H$ with the derivation algebra of the nonassociative algebra $(\\mathbb{R}^{7},\\times_{\\varphi_{0}})$, and compute $\\dim\\mathfrak{h}$.\n\n- Conclude from the structure of $\\mathfrak{h}$ that $H$ is isomorphic to the compact real form of the exceptional simple Lie group of type $G_{2}$.\n\nAnswer specification: Your final answer must be the integer $\\dim H$. Express the final answer as an exact integer with no rounding and no units.", "solution": "Let $(\\mathbb{R}^{7}, g_{0})$ be the $7$-dimensional Euclidean space with the standard metric $g_{0}$. The given $3$-form is\n$$\n\\varphi_{0}=e^{123}+e^{145}+e^{167}+e^{246}-e^{257}-e^{347}-e^{356} \\in \\Lambda^{3}(\\mathbb{R}^{7})^{*}.\n$$\nThe group $H$ is the stabilizer of $\\varphi_{0}$ within $\\mathrm{SO}(7)$, i.e., $H = \\{A \\in \\mathrm{SO}(7) \\mid A^{*}\\varphi_{0} = \\varphi_{0}\\}$.\n\n**Part 1: Preservation of the Cross Product**\n\nThe cross product $\\times_{\\varphi_{0}}$ is defined for any $u,v \\in \\mathbb{R}^{7}$ as the unique vector $u \\times_{\\varphi_{0}} v$ such that\n$$\ng_{0}(u \\times_{\\varphi_{0}} v, w) = \\varphi_{0}(u,v,w) \\quad \\forall w \\in \\mathbb{R}^{7}.\n$$\nAn element $A \\in H$ is an operator in $\\mathrm{SO}(7)$ that preserves $\\varphi_{0}$. This means $A$ preserves the metric $g_{0}$ and for all $u,v,w \\in \\mathbb{R}^{7}$, the pullback condition $A^{*}\\varphi_{0} = \\varphi_{0}$ implies\n$$\n\\varphi_{0}(Au, Av, Aw) = \\varphi_{0}(u,v,w).\n$$\nWe wish to show that $A$ is an automorphism of the algebra $(\\mathbb{R}^{7}, \\times_{\\varphi_{0}})$, meaning $A(u \\times_{\\varphi_{0}} v) = (Au) \\times_{\\varphi_{0}} (Av)$.\n\nTo verify this, we check if the vector $A(u \\times_{\\varphi_{0}} v)$ satisfies the defining property of $(Au) \\times_{\\varphi_{0}} (Av)$. For any vector $w' \\in \\mathbb{R}^{7}$, we must have $g_{0}((Au) \\times_{\\varphi_{0}} (Av), w') = \\varphi_{0}(Au, Av, w')$.\nSince $A \\in \\mathrm{SO}(7)$ is an invertible linear map, any $w' \\in \\mathbb{R}^{7}$ can be written as $w' = Aw$ for some unique $w \\in \\mathbb{R}^{7}$. So we compute:\n$$\ng_{0}((Au) \\times_{\\varphi_{0}} (Av), Aw) = \\varphi_{0}(Au, Av, Aw).\n$$\nSince $A \\in H$, we have $\\varphi_{0}(Au, Av, Aw) = \\varphi_{0}(u,v,w)$. By definition of the cross product, this is equal to $g_{0}(u \\times_{\\varphi_{0}} v, w)$.\n$$\ng_{0}((Au) \\times_{\\varphi_{0}} (Av), Aw) = g_{0}(u \\times_{\\varphi_{0}} v, w).\n$$\nNow, since $A$ is an isometry ($A \\in \\mathrm{SO}(7)$), it preserves the inner product: $g_{0}(x,y) = g_{0}(Ax, Ay)$ for all $x,y \\in \\mathbb{R}^{7}$. Applying this to the right-hand side, we get:\n$$\ng_{0}(u \\times_{\\varphi_{0}} v, w) = g_{0}(A(u \\times_{\\varphi_{0}} v), Aw).\n$$\nCombining our findings, we have\n$$\ng_{0}((Au) \\times_{\\varphi_{0}} (Av), Aw) = g_{0}(A(u \\times_{\\varphi_{0}} v), Aw).\n$$\nThis equality holds for any $w \\in \\mathbb{R}^{7}$, which implies it holds for any $w' = Aw$ spanning $\\mathbb{R}^{7}$. Since the metric $g_{0}$ is non-degenerate, this requires the first arguments of the inner product to be equal:\n$$\nA(u \\times_{\\varphi_{0}} v) = (Au) \\times_{\\varphi_{0}} (Av).\n$$\nThis confirms that any element $A \\in H$ preserves the cross product $\\times_{\\varphi_{0}}$, i.e., it is an automorphism of the algebra $(\\mathbb{R}^{7}, \\times_{\\varphi_{0}})$.\n\n**Part 2: The Lie Algebra $\\mathfrak{h}$ and its Dimension**\n\nThe Lie algebra $\\mathfrak{h}$ of the Lie group $H$ is the subspace of $\\mathfrak{so}(7)$ consisting of endomorphisms $X$ such that $\\exp(tX) \\in H$ for all $t \\in \\mathbb{R}$. Let $A(t) = \\exp(tX)$ be a curve in $H$ with $A(0) = \\mathrm{Id}$ and $A'(0) = X$. The condition $A(t)^{*}\\varphi_{0} = \\varphi_{0}$ is $\\varphi_{0}(A(t)u, A(t)v, A(t)w) = \\varphi_{0}(u,v,w)$. Differentiating this with respect to $t$ at $t=0$ gives:\n$$\n\\frac{d}{dt}\\bigg|_{t=0} \\varphi_{0}(A(t)u, A(t)v, A(t)w) = 0.\n$$\nUsing the product rule, we get:\n$$\n\\varphi_{0}(Xu, v, w) + \\varphi_{0}(u, Xv, w) + \\varphi_{0}(u, v, Xw) = 0.\n$$\nThis is the condition for an endomorphism $X$ to be a derivation of the trilinear form $\\varphi_{0}$. Since $X \\in \\mathfrak{h} \\subset \\mathfrak{so}(7)$, $X$ is skew-symmetric, i.e., $g_{0}(Xx, y) + g_{0}(x, Xy) = 0$ for all $x,y \\in \\mathbb{R}^{7}$.\n\nLet's translate the derivation condition on $\\varphi_{0}$ to a condition on the cross product algebra.\nThe condition is $g_{0}((Xu) \\times_{\\varphi_{0}} v, w) + g_{0}(u \\times_{\\varphi_{0}} (Xv), w) + g_{0}(u \\times_{\\varphi_{0}} v, Xw) = 0$.\nUsing the skew-symmetry of $X$, the third term becomes $-g_{0}(X(u \\times_{\\varphi_{0}} v), w)$. The equation is:\n$$\ng_{0}((Xu) \\times_{\\varphi_{0}} v + u \\times_{\\varphi_{0}} (Xv) - X(u \\times_{\\varphi_{0}} v), w) = 0.\n$$\nSince this holds for all $w$ and $g_{0}$ is non-degenerate, we must have:\n$$\nX(u \\times_{\\varphi_{0}} v) = (Xu) \\times_{\\varphi_{0}} v + u \\times_{\\varphi_{0}} (Xv).\n$$\nThis is the Leibniz rule, defining $X$ as a derivation of the algebra $(\\mathbb{R}^{7}, \\times_{\\varphi_{0}})$. Thus, $\\mathfrak{h}$ is the set of skew-symmetric derivations of this algebra.\n\nThe algebra $(\\mathbb{R}^{7}, g_{0}, \\times_{\\varphi_{0}})$ is isomorphic to the algebra of imaginary octonions $\\mathrm{Im}(\\mathbb{O})$. A \"well-tested fact\" about the octonion algebra is that any derivation of the full octonion algebra $\\mathbb{O}$ preserves the decomposition $\\mathbb{O} = \\mathbb{R} \\cdot 1 \\oplus \\mathrm{Im}(\\mathbb{O})$ and acts on $\\mathrm{Im}(\\mathbb{O})$ as a skew-symmetric endomorphism with respect to the metric $g_0$. This means the condition $X \\in \\mathfrak{so}(7)$ is automatically satisfied for any derivation of the cross-product algebra. Therefore, the Lie algebra $\\mathfrak{h}$ is precisely the derivation algebra of $(\\mathbb{R}^{7}, \\times_{\\varphi_{0}})$. This algebra is the compact real form of the exceptional Lie algebra $\\mathfrak{g}_{2}$.\n\nTo compute the dimension of $\\mathfrak{h} \\cong \\mathfrak{g}_{2}$, we analyze its position within $\\mathfrak{so}(7)$. We use the Orbit-Stabilizer theorem for the action of $\\mathrm{SO}(7)$ on $\\Lambda^{3}(\\mathbb{R}^{7})^{*}$. The Lie algebra version is $\\dim(\\mathfrak{so}(7)) = \\dim(\\mathfrak{h}) + \\dim(\\text{Orbit of } \\varphi_{0})$.\nThe dimension of $\\mathfrak{so}(7)$ is $\\binom{7}{2} = \\frac{7 \\cdot 6}{2} = 21$.\nThe tangent space to the orbit at $\\varphi_0$ is $\\{ L_X \\varphi_0 \\mid X \\in \\mathfrak{so}(7) \\}$, where $(L_X \\varphi_0)(u,v,w) = \\varphi_0(Xu,v,w) + \\varphi_0(u,Xv,w) + \\varphi_0(u,v,Xw)$. The dimension of $\\mathfrak{h}$ is the dimension of the kernel of the map $X \\mapsto L_X \\varphi_0$.\nConsider the map $\\Psi: \\mathbb{R}^{7} \\to \\mathfrak{so}(7)$ defined by $\\Psi(v) = L_{v}$, where $L_{v}(u) = v \\times_{\\varphi_{0}} u$. First, we verify $L_{v} \\in \\mathfrak{so}(7)$. For any $u, w \\in \\mathbb{R}^7$:\n$g_{0}(L_{v}u, w) = g_{0}(v \\times_{\\varphi_{0}} u, w) = \\varphi_{0}(v,u,w)$.\n$g_{0}(u, L_{v}w) = g_{0}(u, v \\times_{\\varphi_{0}} w) = \\varphi_0(u,v,w)$.\nSince $\\varphi_0$ is a 3-form, it is anti-symmetric in its arguments, so $\\varphi_{0}(v,u,w) = -\\varphi_{0}(u,v,w)$. Therefore, $g_0(L_v u, w) = -g_0(u, L_v w)$, which shows that $L_v$ is a skew-symmetric endomorphism, i.e., $L_v \\in \\mathfrak{so}(7)$.\n\nThe map $\\Psi: v \\mapsto L_v$ is injective, since $L_v=0$ implies $v \\times_{\\varphi_0} u = 0$ for all $u$, which implies $v=0$. Let $S = \\mathrm{Im}(\\Psi)$. Then $\\dim S = 7$.\nAn element $L_v \\in S$ is in $\\mathfrak{h}$ if and only if it is a derivation. This means $L_v(a \\times_{\\varphi_0} b) = (L_v a) \\times_{\\varphi_0} b + a \\times_{\\varphi_0} (L_v b)$, which translates to $v \\times_{\\varphi_0} (a \\times_{\\varphi_0} b) = (v \\times_{\\varphi_0} a) \\times_{\\varphi_0} b + a \\times_{\\varphi_0} (v \\times_{\\varphi_0} b)$. This is the Jacobi identity, which is not satisfied by the octonion cross product unless one of the vectors is zero. Thus, $S \\cap \\mathfrak{h} = \\{0\\}$.\n\nA deeper result from the theory, which we can take as a \"well-tested fact\", is that the decomposition $\\mathfrak{so}(7) = \\mathfrak{h} \\oplus S$ holds. This can be formally shown by considering the action of any $X \\in \\mathfrak{so}(7)$ on $\\varphi_0$. The resulting $3$-form $L_X \\varphi_0$ lies in a specific $7$-dimensional subspace of $\\Lambda^3(\\mathbb{R}^7)^*$, which can be identified with the image of $S$ under the map $Y \\mapsto L_Y \\varphi_0$. This allows for finding a unique $v \\in \\mathbb{R}^7$ such that $X-L_v$ annihilates $\\varphi_0$, meaning $X-L_v \\in \\mathfrak{h}$. This establishes the direct sum decomposition.\nFrom $\\mathfrak{so}(7) = \\mathfrak{h} \\oplus S$, we take the dimensions:\n$$\n\\dim(\\mathfrak{so}(7)) = \\dim(\\mathfrak{h}) + \\dim(S)\n$$\n$$\n21 = \\dim(\\mathfrak{h}) + 7\n$$\nSolving for $\\dim(\\mathfrak{h})$, we find:\n$$\n\\dim(\\mathfrak{h}) = 14.\n$$\n\n**Part 3: Conclusion on the Group H**\n\nThe Lie algebra of $H$ is $\\mathfrak{h} \\cong \\mathfrak{g}_{2}$, a compact simple Lie algebra of dimension $14$. Since $H$ is defined as a closed subgroup of the compact Lie group $\\mathrm{SO}(7)$, $H$ itself is a compact Lie group. It is a standard result in Lie theory that the (connected) compact Lie group whose Lie algebra is the compact real form of $\\mathfrak{g}_{2}$ is the exceptional Lie group $G_{2}$. The stabilizer group $H$ is known to be connected, and therefore $H$ is isomorphic to $G_{2}$.\nThe dimension of the group $H$ is equal to the dimension of its Lie algebra $\\mathfrak{h}$.\n$$\n\\dim H = \\dim \\mathfrak{h} = 14.\n$$\nThe problem asks for this integer value.", "answer": "$$\\boxed{14}$$", "id": "2990643"}, {"introduction": "While theoretical criteria for special holonomy are elegant, verifying them for a given metric can be a formidable task. This practice challenges you to bridge the gap between abstract theory and computational verification by implementing an algorithm based on the Ambrose–Singer theorem. You will translate this fundamental result into a working program that tests whether a given set of curvature endomorphisms can generate the full Lie algebra of $G_2$ or $\\mathrm{Spin}(7)$, offering a modern, hands-on perspective on how special geometries are discovered and classified in practice [@problem_id:2990656].", "problem": "Design and implement a complete, runnable program that realizes an Ambrose–Singer theorem-based holonomy test for cohomogeneity-one Riemannian metric ansätze in dimensions $7$ and $8$, targeting full $G_2$ and $\\mathrm{Spin}(7)$ holonomy, respectively. The program must construct and use the following mathematical objects and operations, grounded in first principles.\n\nFundamental base:\n- The holonomy group of a Riemannian manifold $(M,g)$ with the Levi–Civita connection is the group generated by parallel transports along loops based at a point. Its Lie algebra (the holonomy algebra) is a subalgebra of the special orthogonal Lie algebra $\\mathfrak{so}(n)$ for dimension $n$.\n- The Ambrose–Singer theorem states that the holonomy algebra at a point is generated by curvature endomorphisms $R_x(u,v)$ at that point and their parallel transports along piecewise smooth loops.\n- For a torsion-free $G_2$ structure on $\\mathbb{R}^7$, the defining $3$-form $\\varphi$ is parallel and the holonomy algebra lies in the stabilizer Lie algebra of $\\varphi$ inside $\\mathfrak{so}(7)$; full $G_2$ holonomy corresponds to the holonomy algebra being exactly the $14$-dimensional Lie algebra $\\mathfrak{g}_2$ that preserves $\\varphi$.\n- For a torsion-free $\\mathrm{Spin}(7)$ structure on $\\mathbb{R}^8$, the defining Cayley $4$-form $\\Psi$ is parallel and the holonomy algebra lies in the stabilizer Lie algebra of $\\Psi$ inside $\\mathfrak{so}(8)$; full $\\mathrm{Spin}(7)$ holonomy corresponds to the holonomy algebra being exactly the $21$-dimensional Lie algebra $\\mathfrak{spin}(7)$ that preserves $\\Psi$.\n\nCore definitions the program must use:\n1. The space $\\mathfrak{so}(n)$ of skew-symmetric matrices, with the Lie bracket $[A,B]=AB-BA$.\n2. The natural action of $\\mathfrak{so}(n)$ on $\\Lambda^k(\\mathbb{R}^n)$ induced by the derivation property on exterior powers: for a $k$-form $\\omega$ and $A\\in\\mathfrak{so}(n)$,\n$$\n(A\\cdot \\omega)_{i_1\\cdots i_k}=\\sum_{r=1}^k \\sum_{j=1}^n A_{i_r j}\\,\\omega_{i_1\\cdots i_{r-1}\\, j \\, i_{r+1}\\cdots i_k},\n$$\ninterpreted in the canonical wedge basis with the appropriate antisymmetry signs.\n3. The stabilizer Lie algebra of a form $\\omega$ inside $\\mathfrak{so}(n)$ is the kernel of the linear map $L_\\omega:\\mathfrak{so}(n)\\to \\Lambda^k(\\mathbb{R}^n)$ given by $L_\\omega(A)=A\\cdot \\omega$.\n\nCanonical normal forms to be used:\n- In dimension $7$, use the standard $G_2$ $3$-form $\\varphi\\in\\Lambda^3(\\mathbb{R}^7)$ expressed in the orthonormal basis $(e^1,\\dots,e^7)$ by\n$$\n\\varphi = e^{123} + e^{145} + e^{167} + e^{246} - e^{257} - e^{347} - e^{356},\n$$\nwhere $e^{ijk}$ denotes $e^i\\wedge e^j\\wedge e^k$, and indices are strictly increasing triples.\n- In dimension $8$, use the standard $\\mathrm{Spin}(7)$ Cayley $4$-form $\\Psi\\in\\Lambda^4(\\mathbb{R}^8)$ expressed in the orthonormal basis $(e^1,\\dots,e^8)$ by\n$$\n\\Psi = e^{1234} + e^{1256} + e^{1278} + e^{1357} - e^{1368} - e^{1458} - e^{1467} - e^{2358} - e^{2367} - e^{2457} + e^{2468} + e^{3456} + e^{3478} + e^{5678}.\n$$\n\nAlgorithm to implement:\n- Build the linear map $L_\\varphi:\\mathfrak{so}(7)\\to \\Lambda^3(\\mathbb{R}^7)$ and $L_\\Psi:\\mathfrak{so}(8)\\to \\Lambda^4(\\mathbb{R}^8)$, in coordinates, using the action above. Compute their kernels (null spaces). These kernels are the stabilizer Lie algebras $\\mathfrak{g}_2\\subset \\mathfrak{so}(7)$ and $\\mathfrak{spin}(7)\\subset \\mathfrak{so}(8)$, respectively, with expected dimensions $14$ and $21$.\n- Given a finite set of curvature endomorphisms modeled as matrices in $\\mathfrak{so}(n)$ at a basepoint (representing $R_x(u,v)$ for various tangent vectors $u,v$), compute the Lie algebra they generate via iterative closure under Lie brackets and linear span until stabilization.\n- Use Ambrose–Singer: for a cohomogeneity-one ansatz, symmetry reduces the needed parallel transport sampling; testing the generated curvature Lie algebra at a representative point suffices to determine whether full $G_2$ or $\\mathrm{Spin}(7)$ holonomy is achievable. Conclude \"full holonomy achieved\" if and only if:\n    1. Every generator in the closed Lie algebra preserves the calibration form ($A\\cdot\\varphi=0$ or $A\\cdot\\Psi=0$), i.e., the algebra lies in the stabilizer kernel; and\n    2. The dimension of the generated algebra equals the full stabilizer dimension ($14$ for $G_2$, $21$ for $\\mathrm{Spin}(7)$).\n- All linear algebra must be done numerically but deterministically and with appropriate tolerances for floating-point arithmetic.\n\nTest suite:\nProvide and hard-code the following six test cases, each a tuple describing the structure type and a finite set of curvature endomorphisms:\n1. A $G_2$ case where the input set is a basis of the full stabilizer kernel in $\\mathbb{R}^7$; expected output is boolean $true$.\n2. A $G_2$ edge case where the input set contains only the zero curvature endomorphism in $\\mathbb{R}^7$; expected output is boolean $false$.\n3. A $G_2$ negative case where the input contains a single curvature endomorphism not preserving $\\varphi$; expected output is boolean $false$.\n4. A $\\mathrm{Spin}(7)$ case where the input set is a basis of the full stabilizer kernel in $\\mathbb{R}^8$; expected output is boolean $true$.\n5. A $\\mathrm{Spin}(7)$ edge case where the input set contains a very small subset of the stabilizer kernel that does not generate the full kernel under Lie brackets; expected output is boolean $false$.\n6. A $\\mathrm{Spin}(7)$ negative case where the input contains a single curvature endomorphism not preserving $\\Psi$; expected output is boolean $false$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"), where each result is a boolean value \"True\" or \"False\". No physical units are involved. Angles are not involved. No percentages are involved. The program must be self-contained, require no input, and strictly adhere to the specified runtime environment and library constraints. The internal algorithm must follow the principle-based design above and must not rely on any external geometric shortcuts or precomputed special holonomy bases; it must derive the stabilizer Lie algebras from the given calibration forms via first-principles linear algebra.", "solution": "We explain the algorithm and its mathematical grounding step by step, integrating the Ambrose–Singer theorem, representation theory, and constructive linear algebra, and then translate it to a robust computational procedure.\n\n1. Start from the Ambrose–Singer theorem: the holonomy algebra $\\mathfrak{hol}_x(M)\\subset \\mathfrak{so}(n)$ of a Riemannian manifold $(M,g)$ at a point $x$ is generated by curvature endomorphisms $R_x(u,v)$ transported along loops through $x$. For cohomogeneity-one ansätze, group symmetries constrain the curvature along orbits, and testing the Lie algebra generated by a representative finite set of curvature endomorphisms at one point is meaningful as a necessary and often sufficient check for full holonomy.\n\n2. For special holonomy in dimension $7$ and $8$, we use parallel calibrations to characterize the stabilizer subalgebras:\n   - In $\\mathbb{R}^7$, a torsion-free $G_2$ structure has a parallel $3$-form $\\varphi$; the holonomy algebra lies in the stabilizer Lie algebra $\\{A\\in\\mathfrak{so}(7):A\\cdot\\varphi=0\\}$, which is $\\mathfrak{g}_2$ of dimension $14$.\n   - In $\\mathbb{R}^8$, a torsion-free $\\mathrm{Spin}(7)$ structure has a parallel Cayley $4$-form $\\Psi$; the holonomy algebra lies in $\\{A\\in\\mathfrak{so}(8):A\\cdot\\Psi=0\\}$, which is $\\mathfrak{spin}(7)$ of dimension $21$.\n\n   Here, the action $A\\cdot\\omega$ for $A\\in\\mathfrak{so}(n)$ and a $k$-form $\\omega\\in\\Lambda^k(\\mathbb{R}^n)$ is the induced representation by derivations on exterior powers. In coordinates in an orthonormal basis $(e^1,\\dots,e^n)$, writing $\\omega$ in the canonical wedge basis and denoting components $\\omega_{i_1\\cdots i_k}$ for strictly increasing multi-indices,\n   $$\n   (A\\cdot\\omega)_{i_1\\cdots i_k}=\\sum_{r=1}^k \\sum_{j=1}^n A_{i_r j}\\,\\omega_{i_1\\cdots i_{r-1}\\, j \\, i_{r+1}\\cdots i_k},\n   $$\n   with the understanding that duplicates in the multi-index yield zero due to antisymmetry, and otherwise the basis vector $e^{i_1\\cdots j \\cdots i_k}$ must be reordered to strictly increasing order with the corresponding sign.\n\n3. Construct the canonical calibration forms:\n   - The $G_2$ $3$-form $\\varphi$ in $\\mathbb{R}^7$ is\n     $$\n     \\varphi = e^{123} + e^{145} + e^{167} + e^{246} - e^{257} - e^{347} - e^{356}.\n     $$\n   - The $\\mathrm{Spin}(7)$ Cayley $4$-form $\\Psi$ in $\\mathbb{R}^8$ is\n     $$\n     \\Psi = e^{1234} + e^{1256} + e^{1278} + e^{1357} - e^{1368} - e^{1458} - e^{1467} - e^{2358} - e^{2367} - e^{2457} + e^{2468} + e^{3456} + e^{3478} + e^{5678}.\n     $$\n\n   Represent these forms as sparse mappings from strictly increasing index tuples to coefficients. This makes the induced action computable.\n\n4. Build the linear maps $L_\\varphi:\\mathfrak{so}(7)\\to \\Lambda^3(\\mathbb{R}^7)$ and $L_\\Psi:\\mathfrak{so}(8)\\to \\Lambda^4(\\mathbb{R}^8)$ by evaluating $A\\cdot\\omega$ on each basis generator $A$ of $\\mathfrak{so}(n)$, where the basis consists of elementary skew-symmetric matrices $E^{ij}$ with entries $(E^{ij})_{ij}=+1$, $(E^{ij})_{ji}=-1$ and zero otherwise for $i<j$. Vectorize $\\mathfrak{so}(n)$ by listing pairs $(i,j)$ with $i<j$, and vectorize $\\Lambda^k(\\mathbb{R}^n)$ by listing strictly increasing $k$-tuples of indices. Stack the columns to form the matrix representation of $L_\\omega$.\n\n5. Compute the kernels (null spaces) of $L_\\varphi$ and $L_\\Psi$ numerically using singular value decomposition with a robust tolerance. These kernels are the stabilizer Lie algebras: numerically, they will have dimensions $14$ for $\\mathbb{R}^7$ and $21$ for $\\mathbb{R}^8$, respectively. Recover matrix bases for these kernels from their vectorized forms.\n\n6. Define the Lie algebra closure operation on a set $\\mathcal{S}\\subset \\mathfrak{so}(n)$: iteratively enrich the set by adding all Lie brackets $[A,B]$ for $A,B$ in the current set, along with maintaining the linear span, until no new independent elements appear (stabilization). Independence is checked numerically by rank increase of the stacked vectorized matrices with a tolerance.\n\n7. Ambrose–Singer-based test: Given a candidate curvature set $\\{R_x(u_\\alpha,v_\\alpha)\\}\\subset\\mathfrak{so}(n)$ at a point for a cohomogeneity-one ansatz,\n   - Compute the closed Lie algebra they generate via step $6$.\n   - Check that every generator lies in the stabilizer kernel, i.e., $A\\cdot\\varphi=0$ for $n=7$ or $A\\cdot\\Psi=0$ for $n=8$, by evaluating $L_\\omega(A)$ and verifying it is numerically zero.\n   - Check that the dimension of the generated algebra equals the full stabilizer dimension ($14$ in dimension $7$, $21$ in dimension $8$).\n   If both checks pass, conclude that full $G_2$ (for $n=7$) or full $\\mathrm{Spin}(7)$ (for $n=8$) holonomy is achievable by the ansatz; otherwise, it is not.\n\n8. Implement a test suite covering:\n   - A $G_2$ \"happy path\" case using a full kernel basis in $\\mathbb{R}^7$.\n   - A $G_2$ boundary case with trivial curvature (zero matrix).\n   - A $G_2$ significant negative case with a curvature endomorphism outside the stabilizer (does not preserve $\\varphi$).\n   - A $\\mathrm{Spin}(7)$ \"happy path\" case using a full kernel basis in $\\mathbb{R}^8$.\n   - A $\\mathrm{Spin}(7)$ edge case with a small proper subset of the stabilizer that does not generate the full stabilizer algebra under brackets.\n   - A $\\mathrm{Spin}(7)$ significant negative case with a curvature endomorphism outside the stabilizer (does not preserve $\\Psi$).\n\n9. The program outputs a single line, a Python list of booleans $[b_1,b_2,b_3,b_4,b_5,b_6]$ corresponding to the six tests above. True indicates \"full holonomy achieved\" under the criteria; False otherwise.\n\nThis design adheres to the Ambrose–Singer theorem by generating holonomy via curvature brackets, conforms to the representation-theoretic characterization of special holonomy via stabilizer Lie algebras preserving parallel calibrations, and uses only first-principles linear-algebraic computations on $\\mathfrak{so}(n)$ and $\\Lambda^k(\\mathbb{R}^n)$ without external geometric shortcuts.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\n# Utility: generate list of index pairs i<j for so(n)\ndef so_index_pairs(n):\n    pairs = []\n    for i in range(n):\n        for j in range(i+1, n):\n            pairs.append((i, j))\n    return pairs\n\n# Utility: vectorize a skew-symmetric matrix A by listing entries A_{ij} for i<j\ndef vectorize_skew(A):\n    n = A.shape[0]\n    pairs = so_index_pairs(n)\n    v = np.array([A[i, j] for (i, j) in pairs], dtype=float)\n    return v\n\n# Utility: rebuild skew-symmetric matrix from vectorized upper-triangle entries\ndef rebuild_skew_from_vector(v, n):\n    A = np.zeros((n, n), dtype=float)\n    pairs = so_index_pairs(n)\n    for idx, (i, j) in enumerate(pairs):\n        A[i, j] = v[idx]\n        A[j, i] = -v[idx]\n    return A\n\n# Generate basis of k-forms: strictly increasing k-tuples from range(n)\ndef k_form_basis_indices(n, k):\n    # simple recursive combination generator\n    indices = list(range(n))\n    res = []\n\n    def rec(start, curr):\n        if len(curr) == k:\n            res.append(tuple(curr))\n            return\n        for i in range(start, n):\n            rec(i+1, curr + [i])\n    rec(0, [])\n    return res\n\n# Sign and sorting for a list of indices to transform to strictly increasing order\ndef sort_with_sign_and_check(indices):\n    # Returns (sorted_tuple, sign), or (None, 0) if duplicates present (wedge = 0)\n    # Count duplicates\n    k = len(indices)\n    # Check duplicates\n    if len(set(indices)) < k:\n        return None, 0\n    # Compute sign of permutation needed to sort indices\n    # We'll use a simple bubble sort to count swaps\n    arr = list(indices)\n    sign = 1\n    # Bubble sort counting swaps\n    for i in range(k):\n        for j in range(0, k - i - 1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                sign *= -1\n    return tuple(arr), sign\n\n# Action of a skew-symmetric matrix A on a k-form omega (sparse dict) in R^n\n# omega_dict maps strictly increasing tuples (i1,...,ik) to coefficient\ndef action_on_form(A, omega_dict, n, k, basis_k, basis_index_map):\n    # Returns vector of coefficients in the wedge basis (ordered by basis_k)\n    res = np.zeros(len(basis_k), dtype=float)\n    # Loop over each basis term in omega\n    for I, c in omega_dict.items():\n        I_list = list(I)\n        # For each position r in the multi-index\n        for r in range(k):\n            i_r = I_list[r]\n            # Sum over j indices\n            for j in range(n):\n                val = A[i_r, j]\n                if val == 0.0:\n                    continue\n                new_indices = I_list.copy()\n                new_indices[r] = j\n                sorted_tuple, sign = sort_with_sign_and_check(new_indices)\n                if sorted_tuple is None:\n                    continue  # wedge zero due to duplicate\n                idx = basis_index_map[sorted_tuple]\n                res[idx] += c * val * sign\n    return res\n\n# Build the linear operator matrix L_omega: so(n) -> Lambda^k\ndef build_action_matrix(n, k, omega_dict):\n    basis_k = k_form_basis_indices(n, k)\n    basis_index_map = {tup: idx for idx, tup in enumerate(basis_k)}\n    pairs = so_index_pairs(n)\n    m = len(pairs)\n    # Initialize matrix of shape (dim Λ^k) x (dim so(n))\n    M = np.zeros((len(basis_k), m), dtype=float)\n    # For each basis element of so(n), compute its action column\n    for col_idx, (i, j) in enumerate(pairs):\n        A = np.zeros((n, n), dtype=float)\n        A[i, j] = 1.0\n        A[j, i] = -1.0\n        vec = action_on_form(A, omega_dict, n, k, basis_k, basis_index_map)\n        M[:, col_idx] = vec\n    return M, basis_k\n\n# Canonical G2 3-form in R^7 (0-based indices)\ndef g2_3form():\n    # phi = e^{123} + e^{145} + e^{167} + e^{246} - e^{257} - e^{347} - e^{356}\n    # Map 1..7 -> 0..6\n    terms = {\n        (0, 1, 2): 1.0,\n        (0, 3, 4): 1.0,\n        (0, 5, 6): 1.0,\n        (1, 3, 5): 1.0,\n        (1, 4, 6): -1.0,\n        (2, 3, 6): -1.0,\n        (2, 4, 5): -1.0,\n    }\n    return terms\n\n# Canonical Spin(7) Cayley 4-form in R^8 (0-based indices)\ndef spin7_4form():\n    # Psi = e^{1234} + e^{1256} + e^{1278} + e^{1357} - e^{1368} - e^{1458} - e^{1467}\n    #      - e^{2358} - e^{2367} - e^{2457} + e^{2468} + e^{3456} + e^{3478} + e^{5678}\n    terms = {\n        (0, 1, 2, 3): 1.0,\n        (0, 1, 4, 5): 1.0,\n        (0, 1, 6, 7): 1.0,\n        (0, 2, 4, 6): 1.0,\n        (0, 2, 5, 7): -1.0,\n        (0, 3, 4, 7): -1.0,\n        (0, 3, 5, 6): -1.0,\n        (1, 2, 4, 7): -1.0,\n        (1, 2, 5, 6): -1.0,\n        (1, 3, 4, 6): -1.0,\n        (1, 3, 5, 7): 1.0,\n        (2, 3, 4, 5): 1.0,\n        (2, 3, 6, 7): 1.0,\n        (4, 5, 6, 7): 1.0,\n    }\n    return terms\n\n# Compute nullspace (kernel) basis of action matrix M and rebuild matrix basis\ndef stabilizer_basis(n, k, omega_dict, tol=1e-12):\n    M, _ = build_action_matrix(n, k, omega_dict)\n    # null_space returns columns of an orthonormal basis\n    K = null_space(M, rcond=tol)\n    # Each column corresponds to a vectorized skew-symmetric matrix\n    basis_mats = []\n    for i in range(K.shape[1]):\n        v = K[:, i]\n        A = rebuild_skew_from_vector(v, n)\n        basis_mats.append(A)\n    return basis_mats, M\n\n# Compute Lie algebra closure under commutators and linear span\ndef lie_algebra_closure(initial_mats, n, tol=1e-10, max_iters=50):\n    # Maintain a list of basis vectors (vectorized upper triangular entries)\n    basis_vecs = []\n    def add_vector(v):\n        nonlocal basis_vecs\n        if len(basis_vecs) == 0:\n            if np.linalg.norm(v) > tol:\n                basis_vecs.append(v)\n                return True\n            else:\n                return False\n        # Stack existing with new v\n        B = np.column_stack(basis_vecs + [v])\n        # Compute ranks before and after adding v using SVD\n        s_before = np.linalg.svd(np.column_stack(basis_vecs), compute_uv=False)\n        s_after = np.linalg.svd(B, compute_uv=False)\n        # Rank with tolerance\n        rank_before = np.sum(s_before > tol)\n        rank_after = np.sum(s_after > tol)\n        if rank_after > rank_before:\n            basis_vecs.append(v)\n            return True\n        else:\n            return False\n\n    # Initialize with provided matrices\n    mats = []\n    for A in initial_mats:\n        v = vectorize_skew(A)\n        added = add_vector(v)\n        if added:\n            mats.append(A.copy())\n\n    # Iterative closure under commutators\n    changed = True\n    iters = 0\n    while changed and iters < max_iters:\n        changed = False\n        iters += 1\n        # Generate commutators between current mats\n        current_mats = mats.copy()\n        for i in range(len(current_mats)):\n            for j in range(i, len(current_mats)):\n                A = current_mats[i]\n                B = current_mats[j]\n                C = A @ B - B @ A\n                v = vectorize_skew(C)\n                if add_vector(v):\n                    mats.append(C.copy())\n                    changed = True\n    # Return basis vectors and corresponding matrices reconstructed\n    # Reconstruct matrices from basis_vecs to ensure consistency\n    basis_mats = [rebuild_skew_from_vector(v, n) for v in basis_vecs]\n    return basis_vecs, basis_mats\n\n# Check preservation: for each basis vector v in so(n), verify M @ v ~ 0\ndef preserves_form(basis_vecs, M, tol=1e-8):\n    for v in basis_vecs:\n        w = M @ v\n        if np.linalg.norm(w) > tol:\n            return False\n    return True\n\n# Produce a random skew vector outside the stabilizer kernel\ndef random_outside_kernel(n, kernel_vecs, seed=0):\n    rng = np.random.default_rng(seed)\n    m = len(so_index_pairs(n))\n    # Form kernel matrix columns\n    if len(kernel_vecs) == 0:\n        # If kernel is empty, random is fine\n        v = rng.standard_normal(m)\n        return v\n    K = np.column_stack(kernel_vecs)\n    # Generate random vector and project out kernel component\n    for _ in range(100):\n        r = rng.standard_normal(m)\n        # Projection onto kernel: K (K^T K)^-1 K^T r\n        # Use pseudoinverse for stability\n        P = K @ np.linalg.pinv(K)\n        v = r - P @ r\n        if np.linalg.norm(v) > 1e-8:\n            return v\n    # Fallback: small perturbation\n    v = rng.standard_normal(m)\n    return v\n\ndef solve():\n    results = []\n\n    # Build stabilizer bases and action matrices\n    # G2 in R^7\n    n7 = 7\n    phi = g2_3form()\n    g2_basis_mats, M_phi = stabilizer_basis(n7, 3, phi, tol=1e-12)\n    g2_kernel_vecs = [vectorize_skew(A) for A in g2_basis_mats]\n    g2_expected_dim = len(g2_basis_mats)  # Should be 14\n\n    # Spin(7) in R^8\n    n8 = 8\n    psi = spin7_4form()\n    spin7_basis_mats, M_psi = stabilizer_basis(n8, 4, psi, tol=1e-12)\n    spin7_kernel_vecs = [vectorize_skew(A) for A in spin7_basis_mats]\n    spin7_expected_dim = len(spin7_basis_mats)  # Should be 21\n\n    # Construct test cases\n    # 1. G2 full: use full kernel basis\n    g2_full_case = (\"G2\", g2_basis_mats)\n\n    # 2. G2 edge: zero curvature endomorphism\n    zero7 = np.zeros((n7, n7), dtype=float)\n    g2_edge_case = (\"G2\", [zero7])\n\n    # 3. G2 negative: random outside stabilizer\n    v_out_g2 = random_outside_kernel(n7, g2_kernel_vecs, seed=42)\n    A_out_g2 = rebuild_skew_from_vector(v_out_g2, n7)\n    g2_negative_case = (\"G2\", [A_out_g2])\n\n    # 4. Spin(7) full: use full kernel basis\n    spin7_full_case = (\"Spin7\", spin7_basis_mats)\n\n    # 5. Spin(7) edge: small subset of kernel\n    spin7_edge_case = (\"Spin7\", spin7_basis_mats[:2])\n\n    # 6. Spin(7) negative: random outside stabilizer\n    v_out_spin7 = random_outside_kernel(n8, spin7_kernel_vecs, seed=123)\n    A_out_spin7 = rebuild_skew_from_vector(v_out_spin7, n8)\n    spin7_negative_case = (\"Spin7\", [A_out_spin7])\n\n    test_cases = [\n        g2_full_case,\n        g2_edge_case,\n        g2_negative_case,\n        spin7_full_case,\n        spin7_edge_case,\n        spin7_negative_case,\n    ]\n\n    # Evaluate each case\n    for case in test_cases:\n        kind, mats = case\n        if kind == \"G2\":\n            n = n7\n            M = M_phi\n            expected_dim = g2_expected_dim\n        elif kind == \"Spin7\":\n            n = n8\n            M = M_psi\n            expected_dim = spin7_expected_dim\n        else:\n            # Unknown kind; declare False\n            results.append(False)\n            continue\n\n        # Compute lie algebra closure\n        basis_vecs, basis_mats = lie_algebra_closure(mats, n, tol=1e-10, max_iters=50)\n\n        # Check preservation of the form\n        preserves = preserves_form(basis_vecs, M, tol=1e-8)\n\n        # Compute dimension (rank) of the span of basis_vecs\n        if len(basis_vecs) == 0:\n            dim = 0\n        else:\n            B = np.column_stack(basis_vecs)\n            s = np.linalg.svd(B, compute_uv=False)\n            dim = int(np.sum(s > 1e-10))\n\n        # Full holonomy achieved if preserves and dim equals expected stabilizer dimension\n        full = preserves and (dim == expected_dim)\n        results.append(full)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2990656"}]}