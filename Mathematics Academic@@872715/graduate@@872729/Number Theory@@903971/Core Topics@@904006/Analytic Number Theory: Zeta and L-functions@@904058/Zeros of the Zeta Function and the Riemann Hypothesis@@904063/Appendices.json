{"hands_on_practices": [{"introduction": "This first practice grounds our understanding in the global properties of the Riemann zeta function. We will move beyond its initial series definition by using analytic continuation to explore the function's behavior at negative integers. This exercise demonstrates a powerful technique involving the Hurwitz zeta function and Bernoulli numbers to uncover the values of $\\zeta(s)$ at these points [@problem_id:3031541], which are related to its trivial zeros.", "problem": "Let $\\,\\zeta(s)\\,$ denote the Riemann zeta function, initially defined for $\\operatorname{Re}(s)>1$ by the Dirichlet series $\\,\\zeta(s)=\\sum_{n=1}^{\\infty}n^{-s}\\,$, and let $\\,\\zeta(s,a)\\,$ denote the Hurwitz zeta function, initially defined for $\\operatorname{Re}(s)>1$ and $a\\in(0,1]$ by $\\,\\zeta(s,a)=\\sum_{n=0}^{\\infty}(n+a)^{-s}\\,$. The Bernoulli polynomials $\\,B_{n}(a)\\,$ and Bernoulli numbers $\\,B_{n}=B_{n}(1)\\,$ are defined by the generating function\n$$\n\\frac{t\\,\\exp(a t)}{\\exp(t)-1}=\\sum_{n=0}^{\\infty}B_{n}(a)\\,\\frac{t^{n}}{n!},\\qquad |t|2\\pi.\n$$\nStarting from these fundamental definitions and the well-tested integral representation\n$$\n\\Gamma(s)\\,\\zeta(s,a)=\\int_{0}^{\\infty}\\frac{x^{\\,s-1}\\,\\exp(-a x)}{1-\\exp(-x)}\\,\\mathrm{d}x\\qquad\\text{for }\\operatorname{Re}(s)>1,\n$$\nderive the analytic continuation of $\\,\\zeta(s,a)\\,$ to negative integers and show that for every integer $m\\ge 1$ one has\n$$\n\\zeta(-m)=-\\frac{B_{m+1}}{m+1}.\n$$\nThen compute $\\,\\zeta(-1)\\,$ and $\\,\\zeta(-3)\\,$ explicitly. The final answers should be exact values; no rounding is required.", "solution": "The problem requires the derivation of the value of the Riemann zeta function $\\zeta(s)$ at negative integers, starting from a given integral representation of the Hurwitz zeta function $\\zeta(s,a)$. The derivation proceeds by finding an analytic continuation for $\\zeta(s,a)$, specializing to $\\zeta(s) = \\zeta(s,1)$, and then computing the required values using Bernoulli numbers.\n\nThe starting point is the integral representation for the Hurwitz zeta function $\\zeta(s,a)$, valid for $\\operatorname{Re}(s)>1$ and $a \\in (0,1]$:\n$$ \\Gamma(s)\\,\\zeta(s,a)=\\int_{0}^{\\infty}\\frac{x^{\\,s-1}\\,\\exp(-a x)}{1-\\exp(-x)}\\,\\mathrm{d}x $$\nTo obtain an analytic continuation, we analyze the integrand. The term $\\frac{\\exp(-ax)}{1-\\exp(-x)}$ can be related to the generating function for the Bernoulli polynomials, $B_k(a)$, given by:\n$$ \\frac{t\\,\\exp(a t)}{\\exp(t)-1}=\\sum_{k=0}^{\\infty}B_{k}(a)\\,\\frac{t^{k}}{k!} $$\nLet's manipulate the term in the integral. Let $t = -x$. Then $x=-t$. The expression $\\frac{\\exp(-ax)}{1-\\exp(-x)}$ can be written as:\n$$ \\frac{\\exp(-ax)}{1-\\exp(-x)} = \\frac{1}{x} \\frac{x \\exp(-ax)}{1-\\exp(-x)} = \\frac{1}{x} \\frac{-t \\exp(at)}{1-\\exp(t)} = \\frac{1}{x} \\frac{t \\exp(at)}{\\exp(t)-1} $$\nSubstituting the generating function:\n$$ \\frac{\\exp(-ax)}{1-\\exp(-x)} = \\frac{1}{x} \\sum_{k=0}^{\\infty}B_{k}(a)\\,\\frac{(-x)^{k}}{k!} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k B_k(a)}{k!} x^{k-1} $$\nThis expansion is valid for $|x|2\\pi$. We substitute this into the integral representation:\n$$ \\Gamma(s)\\zeta(s,a) = \\int_0^\\infty x^{s-1} \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k-1} \\right) \\mathrm{d}x = \\int_0^\\infty \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k+s-2} \\right) \\mathrm{d}x $$\nTo handle the divergence of the integral and the region of convergence of the series, we split the integral at a point within the radius of convergence, for example at $x=1$:\n$$ \\Gamma(s)\\zeta(s,a) = \\int_0^1 \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k+s-2} \\right) \\mathrm{d}x + \\int_1^\\infty \\frac{x^{s-1} \\exp(-ax)}{1-e^{-x}} \\mathrm{d}x $$\nThe second integral, $\\int_1^\\infty \\frac{x^{s-1} \\exp(-ax)}{1-e^{-x}} \\mathrm{d}x$, converges for all $s \\in \\mathbb{C}$ because the integrand decays exponentially as $x \\to \\infty$. Therefore, this integral defines an entire function of $s$.\n\nFor the first integral, we can interchange summation and integration for $\\operatorname{Re}(s)>1$:\n$$ \\int_0^1 \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k+s-2} \\right) \\mathrm{d}x = \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} \\int_0^1 x^{k+s-2} \\mathrm{d}x $$\nThe inner integral evaluates to:\n$$ \\int_0^1 x^{k+s-2} \\mathrm{d}x = \\left[\\frac{x^{k+s-1}}{k+s-1}\\right]_0^1 = \\frac{1}{k+s-1} $$\nThis is valid for $\\operatorname{Re}(k+s-2) > -1$, i.e., $\\operatorname{Re}(s) > 1-k$. Since we assumed $\\operatorname{Re}(s)>1$, this holds for all $k \\ge 0$.\nThus, for $\\operatorname{Re}(s)>1$, we have:\n$$ \\Gamma(s)\\zeta(s,a) = \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!(k+s-1)} + \\int_1^\\infty \\frac{x^{s-1} \\exp(-ax)}{1-e^{-x}} \\mathrm{d}x $$\nThe right-hand side provides the analytic continuation of $\\Gamma(s)\\zeta(s,a)$ to the entire complex plane, with simple poles at $s=1-k$ for $k=0, 1, 2, \\ldots$ arising from the terms in the sum. Let's call this function $\\Phi(s,a)$. Thus, $\\zeta(s,a) = \\Phi(s,a)/\\Gamma(s)$.\n\nWe want to evaluate $\\zeta(s,a)$ at negative integers, say $s = -m$ for $m \\in \\mathbb{Z}_{\\ge 1}$. Let's find a general formula for $\\zeta(1-k, a)$ for $k \\in \\mathbb{Z}_{\\ge 1}$.\nWe evaluate $\\zeta(1-k, a) = \\lim_{s \\to 1-k} \\frac{\\Phi(s,a)}{\\Gamma(s)}$. This is an indeterminate form of type $\\infty/\\infty$ because both $\\Phi(s,a)$ (due to the $k$-th term of the sum) and $\\Gamma(s)$ (since $1-k \\le 0$) have poles at $s=1-k$.\n\nNear $s = 1-k$, the dominant term in $\\Phi(s,a)$ is the one with the pole:\n$$ \\Phi(s,a) \\sim \\frac{(-1)^k B_k(a)}{k!(k+s-1)} = \\frac{(-1)^k B_k(a)}{k!(s - (1-k))} $$\nThe residue of $\\Phi(s,a)$ at $s=1-k$ is $\\operatorname{Res}_{s=1-k} \\Phi(s,a) = \\frac{(-1)^k B_k(a)}{k!}$.\nThe Gamma function $\\Gamma(s)$ has a simple pole at $s = -(k-1) = 1-k$. The residue is:\n$$ \\operatorname{Res}_{s=1-k} \\Gamma(s) = \\frac{(-1)^{k-1}}{(k-1)!} $$\nSo near $s=1-k$, $\\Gamma(s)$ behaves like:\n$$ \\Gamma(s) \\sim \\frac{(-1)^{k-1}}{(k-1)!(s - (1-k))} $$\nNow, we can compute the limit for $\\zeta(1-k, a)$:\n$$ \\zeta(1-k, a) = \\lim_{s \\to 1-k} \\frac{\\Phi(s,a)}{\\Gamma(s)} = \\frac{ \\frac{(-1)^k B_k(a)}{k!(s - (1-k))} }{ \\frac{(-1)^{k-1}}{(k-1)!(s - (1-k))} } = \\frac{(-1)^k B_k(a)}{k!} \\cdot \\frac{(k-1)!}{(-1)^{k-1}} $$\n$$ \\zeta(1-k, a) = -\\frac{B_k(a)}{k} \\quad \\text{for integer } k \\ge 1. $$\nThe problem asks for $\\zeta(-m)$ for integer $m \\ge 1$. We set $-m = 1-k$, which implies $k = m+1$. Since $m \\ge 1$, $k \\ge 2$, so the formula is applicable.\n$$ \\zeta(-m, a) = -\\frac{B_{m+1}(a)}{m+1} $$\nThe Riemann zeta function $\\zeta(s)$ is related to the Hurwitz zeta function $\\zeta(s,a)$ by $\\zeta(s) = \\zeta(s,1)$ for $\\operatorname{Re}(s)>1$. By uniqueness of analytic continuation, this relation holds for all $s$ where both functions are defined. We set $a=1$:\n$$ \\zeta(-m) = \\zeta(-m, 1) = -\\frac{B_{m+1}(1)}{m+1} $$\nThe problem defines the Bernoulli numbers as $B_n = B_n(1)$. Therefore, for any integer $m \\ge 1$:\n$$ \\zeta(-m) = -\\frac{B_{m+1}}{m+1} $$\nThis completes the derivation of the required formula.\n\nNow, we must compute $\\zeta(-1)$ and $\\zeta(-3)$. This requires the Bernoulli numbers $B_2$ and $B_4$. We use the generating function for $B_n = B_n(1)$:\n$$ \\frac{t\\,\\exp(t)}{\\exp(t)-1}=\\sum_{n=0}^{\\infty}B_{n}\\,\\frac{t^{n}}{n!} $$\nWe can find the first few terms by expanding the left side in a Taylor series around $t=0$:\n$$ \\frac{t\\,\\exp(t)}{\\exp(t)-1} = t + \\frac{t}{\\exp(t)-1} $$\nThe standard generating function for Bernoulli numbers (let's call them $b_k$) is $\\frac{t}{\\exp(t)-1} = \\sum_{k=0}^{\\infty} b_k \\frac{t^k}{k!}$, where $b_0=1$, $b_1=-1/2$, $b_2=1/6$, $b_3=0$, $b_4=-1/30$, etc.\n$$ \\sum_{n=0}^{\\infty}B_{n}\\,\\frac{t^{n}}{n!} = t + \\left( b_0 + b_1 t + b_2 \\frac{t^2}{2!} + b_3 \\frac{t^3}{3!} + b_4 \\frac{t^4}{4!} + \\dots \\right) $$\n$$ B_0 + B_1 t + B_2 \\frac{t^2}{2} + B_3 \\frac{t^3}{6} + B_4 \\frac{t^4}{24} + \\dots = b_0 + (1+b_1)t + b_2 \\frac{t^2}{2} + b_3 \\frac{t^3}{6} + b_4 \\frac{t^4}{24} + \\dots $$\nBy comparing coefficients, we find:\n$B_0 = b_0 = 1$.\n$B_1 = 1+b_1 = 1 - 1/2 = 1/2$.\n$B_2 = b_2 = 1/6$.\n$B_3 = b_3 = 0$.\n$B_4 = b_4 = -1/30$.\n\nNow we can compute the specific values of $\\zeta(s)$.\nFor $m=1$:\n$$ \\zeta(-1) = -\\frac{B_{1+1}}{1+1} = -\\frac{B_2}{2} = -\\frac{1/6}{2} = -\\frac{1}{12} $$\nFor $m=3$:\n$$ \\zeta(-3) = -\\frac{B_{3+1}}{3+1} = -\\frac{B_4}{4} = -\\frac{-1/30}{4} = \\frac{1}{120} $$\nThe computed values are $\\zeta(-1) = -1/12$ and $\\zeta(-3) = 1/120$.", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{1}{12}  \\frac{1}{120} \\end{pmatrix}}\n$$", "id": "3031541"}, {"introduction": "Having established the zeta function's global structure, we now focus on its most mysterious feature: the non-trivial zeros, which the Riemann Hypothesis conjectures all lie on the critical line. This computational exercise delves into the statistical distribution of these zeros by investigating Gram's Law, a simple heuristic about their spacing. By numerically implementing an approximation based on the Riemann-Siegel formula to find a failure of this law [@problem_id:3031532], you will gain a hands-on appreciation for the complex reality of the zero distribution.", "problem": "Let $\\zeta(s)$ denote the Riemann zeta function, defined for $\\Re(s) > 1$ by the series $\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$ and extended to the complex plane by analytic continuation except for a simple pole at $s=1$. Define the Hardy $Z$-function by $Z(t) = e^{i \\theta(t)} \\zeta\\!\\left(\\tfrac{1}{2} + i t\\right)$, where $\\theta(t)$ is the Riemann–Siegel theta function given by\n$$\n\\theta(t) = \\arg \\Gamma\\!\\left(\\tfrac{1}{4} + \\tfrac{i t}{2}\\right) - \\tfrac{t}{2} \\log \\pi,\n$$\nwith the branch of the argument chosen continuously for $t \\ge 0$. The Gram points $\\{g_n\\}_{n \\ge 0}$ are defined implicitly by $\\theta(g_n) = n \\pi$ for integers $n \\ge 0$. Gram’s law asserts that, heuristically, the values $Z(g_n)$ should alternate in sign at successive Gram points. A failure of Gram’s law is observed when two successive values $Z(g_n)$ and $Z(g_{n+1})$ have the same sign (or one is zero), so that the alternation property is violated.\n\nStarting from the following fundamental base:\n- The functional equation for the Riemann zeta function, equivalently expressed through the Hardy $Z$-function $Z(t)$ being real-valued for real $t$.\n- The Riemann–Siegel theta function asymptotics for large $t$ derived from Stirling’s approximation for the gamma function:\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5},\n$$\nwith derivative\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}.\n$$\n- The Riemann–Siegel approximate functional equation for $Z(t)$, which yields the truncated main sum\n$$\nZ(t) \\approx 2 \\sum_{n=1}^{N} n^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log n\\big), \\quad \\text{where } N = \\left\\lfloor \\sqrt{\\tfrac{t}{2\\pi}} \\right\\rfloor,\n$$\nand the neglected remainder is of lower order for moderate to large $t$.\n\nYour task is to construct a program that demonstrates a concrete failure of Gram’s law by computing successive Gram points $g_n$ in chosen index ranges, evaluating $Z(g_n)$ via the truncated Riemann–Siegel main sum, and checking whether the signs of $Z(g_n)$ alternate. Use the asymptotic expansion above to compute $\\theta(t)$ and $\\theta'(t)$, and solve $\\theta(t) = n \\pi$ for $t$ numerically using a stable root-finding method (such as Newton’s method with a robust fallback to bisection if needed). Then evaluate the truncated sum for $Z(t)$ and determine its sign. Treat values where $Z(t)$ is numerically indistinguishable from zero (within a small absolute tolerance) as breaking alternation.\n\nDesign the program to process the following test suite of index ranges $(n_{\\text{start}}, n_{\\text{end}})$:\n- Case 1 (happy path): $(10, 30)$.\n- Case 2 (targeted failure search): $(120, 140)$.\n- Case 3 (larger index window): $(500, 520)$.\n\nFor each case, scan $n$ from $n_{\\text{start}}$ to $n_{\\text{end}}-1$, compute $g_n$ and $g_{n+1}$, and determine the smallest integer $n$ in the interval such that $Z(g_n)$ and $Z(g_{n+1})$ do not alternate signs. If the alternation holds throughout the interval, return $-1$ for that case. The required outputs for the three cases are thus integers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). No physical units or angle units are required. The numerical algorithms you implement must be scientifically sound and consistent with the stated base formulas, and your numerical tolerances must be chosen plausibly to reflect the approximations involved.", "solution": "The posed problem is a well-defined computational exercise in number theory, requiring the numerical investigation of Gram's law for the Riemann zeta function. The problem provides all necessary mathematical definitions and approximations to proceed. It is scientifically grounded, internally consistent, and requires no information beyond what is supplied. Therefore, the problem is deemed valid and a solution will be presented.\n\nThe core of the task is to find the smallest integer index $n$ within specified ranges $(n_{\\text{start}}, n_{\\text{end}})$ for which Gram's law fails. Gram's law heuristically predicts that the sign of the Hardy $Z$-function, $Z(t)$, alternates at consecutive Gram points, $g_n$ and $g_{n+1}$. A failure occurs if $Z(g_n)$ and $Z(g_{n+1})$ have the same sign, or if one is zero. This is equivalent to testing the condition $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$.\n\nThe solution is constructed through a sequence of methodical steps:\n$1$. Implementing the provided asymptotic formulas for the Riemann-Siegel theta function $\\theta(t)$ and its derivative $\\theta'(t)$.\n$2$. Developing a numerical procedure to find the Gram points $g_n$ by solving the equation $\\theta(g_n) = n\\pi$.\n$3$. Implementing the provided truncated Riemann-Siegel main sum to approximate the Hardy $Z$-function, $Z(t)$.\n$4$. Systematically scanning the given index ranges to detect the first failure of sign alternation.\n\n**1. Implementation of Asymptotic Formulas**\n\nThe problem supplies specific asymptotic expansions for the Riemann-Siegel theta function $\\theta(t)$ and its derivative $\\theta'(t)$. These functions are fundamental to the calculation.\n\n- The function $\\theta(t)$ is implemented using the expansion:\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5}\n$$\nThis approximation is valid for large $t$.\n\n- The derivative, $\\theta'(t)$, required for the root-finding algorithm, is implemented using its corresponding expansion:\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}\n$$\n\n**2. Computation of Gram Points**\n\nThe Gram points, $\\{g_n\\}$, are defined as the solutions to the equation $\\theta(t) = n\\pi$ for non-negative integers $n$. This is a root-finding problem for the function $f(t) = \\theta(t) - n\\pi$. Given the availability of the analytic derivative $f'(t) = \\theta'(t)$, Newton's method is an efficient and appropriate choice as suggested. The iterative update rule is:\n$$\nt_{k+1} = t_k - \\frac{f(t_k)}{f'(t_k)} = t_k - \\frac{\\theta(t_k) - n\\pi}{\\theta'(t_k)}\n$$\nTo ensure convergence, a good initial guess $t_0$ for $g_n$ is required. By inverting the dominant term of the $\\theta(t)$ expansion, $\\theta(t) \\approx \\frac{t}{2} \\log(\\frac{t}{2\\pi})$, we can derive a suitable starting value. Setting $n\\pi \\approx \\frac{t}{2}\\log(\\frac{t}{2\\pi})$, we arrive at the approximate relation $t \\approx 2\\pi n / \\log(n)$. This provides a robust initial guess for the Newton-Raphson iteration for sufficiently large $n$. The implementation will use the `scipy.optimize.newton` function, which provides a reliable a pre-built solver.\n\n**3. Evaluation of the Hardy Z-function**\n\nThe Hardy $Z$-function is evaluated using the provided truncated Riemann-Siegel main sum:\n$$\nZ(t) \\approx 2 \\sum_{k=1}^{N} k^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log k\\big)\n$$\nwhere the number of terms in the sum, $N$, is given by $N = \\lfloor \\sqrt{t/(2\\pi)} \\rfloor$. The value of $\\theta(t)$ required in the cosine term is computed using the same asymptotic formula from Step $1$. This approximation for $Z(t)$ is accurate for moderately large values of $t$, which corresponds to the index ranges being investigated.\n\n**4. Detection of Gram's Law Failures**\n\nThe final stage of the algorithm is to test for failures. For each integer $n$ in a given range $[n_{\\text{start}}, n_{\\text{end}}-1]$, the following procedure is executed:\n$a$. Compute the Gram points $g_n$ and $g_{n+1}$ using the Newton's method procedure from Step $2$.\n$b$. Evaluate the corresponding $Z$-function values, $Z(g_n)$ and $Z(g_{n+1})$, using the formula from Step $3$.\n$c$. Determine the signs of these two values. A value $v$ is considered to be zero if $|v|  \\epsilon$ for a small tolerance, $\\epsilon = 10^{-9}$. The sign is defined as:\n$$\n\\text{sign}(v) = \\begin{cases} 1  \\text{if } v  \\epsilon \\\\ -1  \\text{if } v  -\\epsilon \\\\ 0  \\text{if } |v| \\le \\epsilon \\end{cases}\n$$\n$d$. Check if the signs fail to alternate. A failure is registered if $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$. This condition correctly captures cases where the signs are identical (product is $1$) or where one of the values is numerically zero (product is $0$).\n$e$. If a failure is found for index $n$, that value is recorded as the result for the given range, and the search for that range terminates. If the loop completes without finding any failures, the result is recorded as $-1$.\n\nThis complete algorithmic design is implemented in the accompanying Python script, which processes the specified test cases and produces the required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Computes the smallest index n of a Gram's law failure in given ranges.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 30),\n        (120, 140),\n        (500, 520),\n    ]\n\n    # Numerical tolerance for treating a value as zero\n    ZERO_TOLERANCE = 1e-9\n\n    memoized_theta = {}\n    \n    def theta(t: float) - float:\n        \"\"\"\n        Asymptotic expansion for the Riemann-Siegel theta function.\n        \"\"\"\n        if t in memoized_theta:\n            return memoized_theta[t]\n        \n        if t = 0:\n            return 0.0\n            \n        # Per the problem statement\n        t_inv = 1.0 / t\n        t_inv_3 = t_inv**3\n        t_inv_5 = t_inv**5\n        \n        term1 = t / 2.0 * np.log(t / (2.0 * np.pi))\n        term2 = -t / 2.0\n        term3 = -np.pi / 8.0\n        term4 = 1.0 / 48.0 * t_inv\n        term5 = 7.0 / 5760.0 * t_inv_3\n        term6 = 31.0 / 80640.0 * t_inv_5\n        \n        result = term1 + term2 + term3 + term4 + term5 + term6\n        memoized_theta[t] = result\n        return result\n\n    def theta_prime(t: float) - float:\n        \"\"\"\n        Derivative of the asymptotic expansion for theta(t).\n        \"\"\"\n        if t = 0:\n            return np.inf  # Avoid division by zero, effectively pushing solver away\n\n        t_inv_2 = 1.0 / (t * t)\n        t_inv_4 = t_inv_2 * t_inv_2\n        t_inv_6 = t_inv_4 * t_inv_2\n\n        term1 = 0.5 * np.log(t / (2.0 * np.pi))\n        term2 = -1.0 / (48.0) * t_inv_2\n        term3 = -7.0 / (1920.0) * t_inv_4\n        term4 = -31.0 / (16128.0) * t_inv_6\n        \n        return term1 + term2 + term3 + term4\n\n    memoized_gram_points = {}\n    \n    def find_gram_point(n: int) - float:\n        \"\"\"\n        Finds the n-th Gram point g_n by solving theta(t) = n*pi.\n        \"\"\"\n        if n in memoized_gram_points:\n            return memoized_gram_points[n]\n\n        # Objective function for root finding: f(t) = theta(t) - n*pi\n        func = lambda t: theta(t) - n * np.pi\n        \n        # Derivative of the objective function\n        fprime = theta_prime\n        \n        # Initial guess from inverting the leading term of theta(t)\n        # t/2*log(t/(2*pi)) ~ n*pi = x*log(x) ~ n where x=t/(2*pi)\n        # For large n, t ~ 2*pi*n / log(n)\n        if n  1:\n            t_guess = 2 * np.pi * n / np.log(n)\n        else: # Heuristic for small n where log(n) is problematic\n            t_guess = 20.0 \n\n        # Use Scipy's Newton-Raphson solver\n        gram_point = newton(func, t_guess, fprime=fprime, tol=1e-12, maxiter=100)\n        memoized_gram_points[n] = gram_point\n        return gram_point\n\n    memoized_z_values = {}\n\n    def Z_func(t: float) - float:\n        \"\"\"\n        Approximates the Hardy Z-function using the truncated Riemann-Siegel main sum.\n        \"\"\"\n        if t in memoized_z_values:\n            return memoized_z_values[t]\n\n        N = int(np.sqrt(t / (2.0 * np.pi)))\n        if N == 0:\n            return 0.0\n\n        theta_val = theta(t)\n        \n        k_vals = np.arange(1, N + 1)\n        \n        terms = (1.0 / np.sqrt(k_vals)) * np.cos(theta_val - t * np.log(k_vals))\n        total_sum = np.sum(terms)\n        \n        result = 2.0 * total_sum\n        memoized_z_values[t] = result\n        return result\n\n    def get_sign(value: float) - int:\n        \"\"\"\n        Determines the sign of a value, treating small values as zero.\n        \"\"\"\n        if value  ZERO_TOLERANCE:\n            return 1\n        elif value  -ZERO_TOLERANCE:\n            return -1\n        else:\n            return 0\n\n    results = []\n    for n_start, n_end in test_cases:\n        found_failure_index = -1\n        for n in range(n_start, n_end):\n            # We need to evaluate Z at g_n and g_{n+1}\n            g_n = find_gram_point(n)\n            g_n_plus_1 = find_gram_point(n + 1)\n\n            z_n = Z_func(g_n)\n            z_n_plus_1 = Z_func(g_n_plus_1)\n\n            sign_n = get_sign(z_n)\n            sign_n_plus_1 = get_sign(z_n_plus_1)\n\n            # A failure occurs if signs do not alternate\n            if sign_n * sign_n_plus_1 != -1:\n                found_failure_index = n\n                break\n        \n        results.append(found_failure_index)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031532"}, {"introduction": "This final practice reveals the profound reason why the locations of the non-trivial zeros are of paramount importance to number theory. The explicit formula provides a direct bridge between the zeros of the $\\zeta$-function and the distribution of prime numbers, which is encoded by the Chebyshev function $\\psi(x)$. By computing an approximation of $\\psi(x)$ using a finite number of known zeros [@problem_id:3031529], you will witness firsthand how the distribution of primes is influenced by a \"music\" played by the zeta zeros.", "problem": "Let $x$ be a real number with $x gt; 1$ and let $\\psi(x)$ denote the Chebyshev function $\\psi(x) = \\sum_{n \\le x} \\Lambda(n)$, where $\\Lambda(n)$ is the von Mangoldt function. Consider the explicit formula that expresses $\\psi(x)$ in terms of the nontrivial zeros of the Riemann zeta function $\\zeta(s)$, where each nontrivial zero is denoted by $\\rho = \\beta + i \\gamma$ with $0 lt; \\beta lt; 1$. For $x$ that is not an exact prime power, a classical formulation of the explicit formula is\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\nwhere the sum ranges over all nontrivial zeros $\\rho$ of $\\zeta(s)$, counted with multiplicity. In this problem, you will compute a truncated version of the explicit formula to estimate $\\psi(x) - x$ at $x = 10^{6}$, using a finite list of known zero ordinates and assuming that for the zeros used, the Riemann Hypothesis (RH) holds so that $\\beta = \\tfrac{1}{2}$ for those zeros. You will also assess the sensitivity of the estimate to small perturbations in the locations of these zeros.\n\nYou must adhere to the following algorithmic and mathematical requirements:\n- Use $x = 10^{6}$.\n- Let the set of available zero ordinates be the first ten positive ordinates $\\gamma_{k}$ of the nontrivial zeros of $\\zeta(s)$ on the critical line $\\operatorname{Re}(s) = \\tfrac{1}{2}$, listed below:\n  - $\\gamma_{1} = 14.134725141734693$,\n  - $\\gamma_{2} = 21.022039638771555$,\n  - $\\gamma_{3} = 25.010857580145688$,\n  - $\\gamma_{4} = 30.424876125859513$,\n  - $\\gamma_{5} = 32.935061587739189$,\n  - $\\gamma_{6} = 37.586178158825671$,\n  - $\\gamma_{7} = 40.918719012147495$,\n  - $\\gamma_{8} = 43.327073280914999$,\n  - $\\gamma_{9} = 48.005150881167159$,\n  - $\\gamma_{10} = 49.773832477672302$.\n- For a truncation level $N \\in \\{0,1,\\dots,10\\}$, approximate\n$$\n\\psi(x) - x \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\nwhere $\\rho_{k} = \\tfrac{1}{2} + i \\gamma_{k}$ and $\\overline{\\rho_{k}} = \\tfrac{1}{2} - i \\gamma_{k}$. Note that for real $x$, each pair contributes a real value, and the pairwise sum simplifies to\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}.\n$$\n- To assess sensitivity of the estimate to the location of a zero, introduce a perturbation to a chosen ordinate: for a given index $j \\in \\{1,\\dots,N\\}$ and a small real perturbation $\\delta$, replace $\\gamma_{j}$ by $\\gamma_{j} + \\delta$ and recompute the truncated estimate. Define the sensitivity measure as the absolute difference between the perturbed and unperturbed estimates.\n\nAll computations are purely mathematical and unitless; use the natural logarithm for all logarithms. You should implement the algorithm with real arithmetic and the trigonometric simplification given above.\n\nTest suite:\n- Use $x = 10^{6}$ and the list of $\\gamma_{k}$ above. Compute the following five outputs:\n  1) The truncated estimate with $N = 0$ (edge case, no zeros used).\n  2) The truncated estimate with $N = 5$ (baseline partial sum).\n  3) The truncated estimate with $N = 10$ (larger partial sum).\n  4) The sensitivity for $N = 10$ when perturbing the $j = 5$ ordinate by $\\delta = 10^{-6}$.\n  5) The sensitivity for $N = 10$ when perturbing the $j = 1$ ordinate by $\\delta = 10^{-6}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of the five computations as a comma-separated list enclosed in square brackets, in the order listed above. For example, an output line must look like\n$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4},\\text{result}_{5}]$\nwith each $\\text{result}_{k}$ a real number written in standard decimal notation.", "solution": "The user wants to compute a truncated version of the explicit formula for the Chebyshev function $\\psi(x)$ and assess its sensitivity to perturbations in the locations of the zeros of the Riemann zeta function.\n\n### Principle-Based Design\n\nThe problem revolves around the explicit formula from analytic number theory, which relates the prime-counting function $\\psi(x)$ to the nontrivial zeros $\\rho$ of the Riemann zeta function $\\zeta(s)$. The formula provided is:\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\nThis can be rearranged to express the deviation of $\\psi(x)$ from $x$:\n$$\n\\psi(x) - x \\;=\\; -\\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\nThe sum is over all nontrivial zeros $\\rho$. These zeros come in complex conjugate pairs. If $\\rho = \\beta + i\\gamma$ is a zero, then so is its conjugate $\\overline{\\rho} = \\beta - i\\gamma$. The problem assumes the Riemann Hypothesis for the given zeros, meaning their real part is $\\beta = \\frac{1}{2}$. Under this assumption, a pair of zeros is given by $\\rho_k = \\frac{1}{2} + i\\gamma_k$ and $\\overline{\\rho_k} = \\frac{1}{2} - i\\gamma_k$ for a positive ordinate $\\gamma_k  0$.\n\nThe core of the algorithm is to compute a truncated approximation for $\\psi(x) - x$ by summing over the first $N$ pairs of zeros. The approximation, which we will denote as $E(x, N, \\{\\gamma_k\\})$, is:\n$$\nE(x, N, \\{\\gamma_k\\}) \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\nThe contribution from each conjugate pair of zeros is a real-valued term. As stated in the problem, this term simplifies to:\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}\n$$\nOur algorithm implements a function, `compute_psi_minus_x`, that calculates this truncated estimate $E(x, N, \\{\\gamma_k\\})$.\n\n**Algorithmic Steps:**\n\n1.  **Define Inputs and Constants:** The value of $x$ is set to $10^6$. The list of the first $10$ positive ordinates $\\{\\gamma_k\\}$ is stored.\n\n2.  **Modular Function:** A function `compute_psi_minus_x(x, gammas_list)` is designed to compute the estimate. It takes $x$ and a list of ordinates as input, where the length of the list corresponds to the truncation level $N$.\n\n3.  **Constant Term Calculation:** The function first computes the zero-independent part of the expression: $C(x) = \\log(2\\pi) + \\frac{1}{2}\\log(1 - x^{-2})$. The total estimate is $-S - C(x)$, where $S$ is the sum over zeros. For numerical stability with large $x$, the term $\\log(1 - x^{-2})$ is computed as `np.log1p(-x**-2)`, which is more accurate for arguments close to $0$.\n\n4.  **Summation over Zeros:** The function then iterates through the provided `gammas_list`. For each $\\gamma_k$, it calculates the contribution from the corresponding zero pair using the simplified real-valued formula. These contributions are summed up to obtain the total sum $S = \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right)$.\n\n5.  **Final Estimate:** The function returns the final estimate $-S - C(x)$.\n\n6.  **Test Case Computations:**\n    -   The estimates for $N=0$, $N=5$, and $N=10$ are computed by calling `compute_psi_minus_x` with the appropriate slice of the `gammas` list. For $N=0$, an empty list is passed, resulting in a sum $S=0$.\n    -   The baseline estimate for $N=10$ is stored for the sensitivity analysis.\n\n7.  **Sensitivity Analysis:** To assess sensitivity, a perturbed estimate is calculated. A copy of the full `gammas` list (for $N=10$) is made. The chosen ordinate $\\gamma_j$ is modified by adding a small perturbation $\\delta = 10^{-6}$. The `compute_psi_minus_x` function is called with this perturbed list. The sensitivity is then computed as the absolute difference between this perturbed estimate and the baseline $N=10$ estimate. This process is performed for $j=1$ and $j=5$.\n\n8.  **Output Formatting:** The five required numerical results are collected into a list and formatted into a single output string as specified.\n\nThis structured approach ensures correctness by directly implementing the established mathematical formulas and provides robust numerical results by leveraging appropriate functions from the `numpy` library.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_psi_minus_x(x, gammas_list):\n    \"\"\"\n    Computes the truncated explicit formula approximation for psi(x) - x.\n\n    Args:\n        x (float): The value at which to evaluate the function. Must be  1.\n        gammas_list (list of float): A list of the positive ordinates of the\n                                     nontrivial zeros of the Riemann zeta function.\n\n    Returns:\n        float: The approximated value of psi(x) - x.\n    \"\"\"\n    log_x = np.log(x)\n    x_sqrt = np.sqrt(x)\n\n    # Calculate the constant terms: -log(2*pi) - 0.5*log(1 - x**-2)\n    # Using np.log1p(y) = log(1+y) for better precision when y is close to 0.\n    # Here, y = -x**-2, which is very close to 0 for x=10^6.\n    const_term = -(np.log(2 * np.pi) + 0.5 * np.log1p(-x**-2))\n\n    # Calculate the sum over the nontrivial zeros.\n    sum_zeros = 0.0\n    for gamma in gammas_list:\n        arg = gamma * log_x\n        # Contribution from the pair of zeros (1/2 + i*gamma, 1/2 - i*gamma)\n        numerator = 0.5 * np.cos(arg) + gamma * np.sin(arg)\n        denominator = 0.25 + gamma**2\n        term = 2 * x_sqrt * numerator / denominator\n        sum_zeros += term\n    \n    # The full formula is -sum_zeros + const_term\n    return -sum_zeros + const_term\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    x = 10.0**6\n    gammas = [\n        14.134725141734693,\n        21.022039638771555,\n        25.010857580145688,\n        30.424876125859513,\n        32.935061587739189,\n        37.586178158825671,\n        40.918719012147495,\n        43.327073280914999,\n        48.005150881167159,\n        49.773832477672302\n    ]\n    delta = 1e-6\n\n    # 1) Compute the truncated estimate with N = 0 (no zeros used)\n    est_N0 = compute_psi_minus_x(x, [])\n    \n    # 2) Compute the truncated estimate with N = 5\n    est_N5 = compute_psi_minus_x(x, gammas[:5])\n\n    # 3) Compute the truncated estimate with N = 10\n    est_N10 = compute_psi_minus_x(x, gammas)\n\n    # 4) Compute the sensitivity for N = 10 when perturbing gamma_5\n    gammas_pert_j5 = gammas[:]  # Create a copy\n    gammas_pert_j5[4] += delta   # j=5 corresponds to index 4\n    est_pert_j5 = compute_psi_minus_x(x, gammas_pert_j5)\n    sens_j5 = abs(est_pert_j5 - est_N10)\n\n    # 5) Compute the sensitivity for N = 10 when perturbing gamma_1\n    gammas_pert_j1 = gammas[:]  # Create a copy\n    gammas_pert_j1[0] += delta   # j=1 corresponds to index 0\n    est_pert_j1 = compute_psi_minus_x(x, gammas_pert_j1)\n    sens_j1 = abs(est_pert_j1 - est_N10)\n\n    results = [est_N0, est_N5, est_N10, sens_j5, sens_j1]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031529"}]}