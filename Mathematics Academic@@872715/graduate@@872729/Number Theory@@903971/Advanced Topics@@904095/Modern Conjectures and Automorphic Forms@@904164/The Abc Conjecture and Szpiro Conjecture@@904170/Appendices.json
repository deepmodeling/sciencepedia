{"hands_on_practices": [{"introduction": "This first practice grounds our understanding in the core definitions related to the $abc$ conjecture. By computing the radical, $\\operatorname{rad}(abc)$, and the quality, $q(a,b,c)$, for a fundamental triple, we can directly engage with the key quantities at play. This exercise establishes a baseline for a \"typical\" triple, where the quality is less than $1$, providing a crucial reference point for understanding the rare, exceptional cases the conjecture seeks to constrain. [@problem_id:3024518]", "problem": "Let $\\left(a,b,c\\right)=\\left(2,3,5\\right)$ be a coprime triple with $a+b=c$. Recall the following standard definitions.\n- For a nonzero integer $n$, the radical $\\operatorname{rad}\\!\\left(n\\right)$ is the product of the distinct prime numbers dividing $n$.\n- For a coprime triple $\\left(a,b,c\\right)$ with $a+b=c$, the quality is defined by $q\\!\\left(a,b,c\\right)=\\dfrac{\\ln c}{\\ln \\operatorname{rad}\\!\\left(abc\\right)}$, where $\\ln$ denotes the natural logarithm.\n\nStarting from these definitions and the usual formulation of the abc conjecture (which asserts that for every $\\epsilon>0$ there are only finitely many coprime triples $\\left(a,b,c\\right)$ with $a+b=c$ and $c>\\operatorname{rad}\\!\\left(abc\\right)^{1+\\epsilon}$), and from the equivalence between the abc conjecture and Szpiro's conjecture for elliptic curves over $\\mathbb{Q}$, do the following:\n- Compute $\\operatorname{rad}\\!\\left(abc\\right)$ for $\\left(a,b,c\\right)=\\left(2,3,5\\right)$.\n- Compute the quality $q\\!\\left(a,b,c\\right)$.\n- Using only these foundational definitions and facts, assess whether the computed quality is typical relative to conjectural bounds suggested by the abc conjecture and its equivalence to Szpiro's conjecture, justifying your assessment conceptually.\n\nProvide your final answer as the exact symbolic expression for $q\\!\\left(a,b,c\\right)$. Do not approximate numerically, and do not include explanatory text in the final answer box.", "solution": "The problem is evaluated as valid. The provided data, definitions, and conditions are self-contained, mathematically sound, and form a well-posed problem in the field of number theory. The premise $(a,b,c) = (2,3,5)$ correctly forms a coprime triple satisfying $a+b=c$, as $2+3=5$ and $\\gcd(2,3)=\\gcd(2,5)=\\gcd(3,5)=1$. The definitions of the radical and quality, and the statement of the abc conjecture, are standard.\n\nThe solution proceeds in three parts as requested: computation of the radical, computation of the quality, and a conceptual assessment of the quality.\n\nFirst, we compute the radical, $\\operatorname{rad}(abc)$.\nThe triple is given as $(a,b,c) = (2,3,5)$. The product is $abc = 2 \\times 3 \\times 5 = 30$.\nThe radical of a nonzero integer $n$, denoted $\\operatorname{rad}(n)$, is the product of the distinct prime numbers that divide $n$. The prime factorization of $30$ is $2^1 \\cdot 3^1 \\cdot 5^1$. The distinct prime factors are $2$, $3$, and $5$.\nTherefore, the radical is:\n$$ \\operatorname{rad}(abc) = \\operatorname{rad}(30) = 2 \\times 3 \\times 5 = 30 $$\n\nSecond, we compute the quality, $q(a,b,c)$.\nThe quality of a coprime triple $(a,b,c)$ with $a+b=c$ is defined as:\n$$ q(a,b,c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)} $$\nSubstituting the values $c=5$ and $\\operatorname{rad}(abc)=30$ from our specific triple:\n$$ q(2,3,5) = \\frac{\\ln 5}{\\ln 30} $$\nThis is the exact symbolic expression for the quality.\n\nThird, we assess whether this computed quality is typical in the context of the abc conjecture.\nThe abc conjecture states that for any real number $\\epsilon > 0$, there are only finitely many coprime triples $(a,b,c)$ with $a+b=c$ that satisfy the inequality $c > (\\operatorname{rad}(abc))^{1+\\epsilon}$.\nTo understand this in terms of quality, we can manipulate the inequality. Taking the natural logarithm of both sides (a strictly increasing function, which preserves the inequality):\n$$ \\ln c > \\ln\\left( (\\operatorname{rad}(abc))^{1+\\epsilon} \\right) $$\nUsing the logarithm property $\\ln(x^y) = y \\ln x$:\n$$ \\ln c > (1+\\epsilon) \\ln(\\operatorname{rad}(abc)) $$\nFor any non-trivial triple, $a,b,c$ are positive integers, so $\\operatorname{rad}(abc) \\ge \\operatorname{rad}(1 \\cdot 2 \\cdot 3) = 6 > 1$, which implies $\\ln(\\operatorname{rad}(abc)) > 0$. We can thus divide by $\\ln(\\operatorname{rad}(abc))$ without changing the direction of the inequality:\n$$ \\frac{\\ln c}{\\ln(\\operatorname{rad}(abc))} > 1+\\epsilon $$\nThe left-hand side is the definition of the quality, $q(a,b,c)$. The abc conjecture is therefore equivalent to the statement that for any $\\epsilon > 0$, only a finite number of triples have a quality $q(a,b,c) > 1+\\epsilon$. This implies that almost all triples are expected to have a quality $q(a,b,c) \\le 1$. Triples with $q > 1$ are considered high-quality and are the rare exceptions that the conjecture addresses. The conjecture is often stated as $\\limsup q(a,b,c) = 1$.\n\nFor our triple $(2,3,5)$, the quality is $q(2,3,5) = \\frac{\\ln 5}{\\ln 30}$.\nSince $5  30$, and the natural logarithm function $\\ln(x)$ is strictly increasing for $x > 0$, it follows that $\\ln 5  \\ln 30$.\nTherefore, the quality is:\n$$ q(2,3,5) = \\frac{\\ln 5}{\\ln 30}  1 $$\nA quality less than $1$ is entirely ordinary and does not fall into the category of exceptional triples that the abc conjecture describes. The conjecture is concerned with the rarity of triples where $c$ is \"surprisingly large\" compared to the product of the primes dividing $a,b,c$. In our case, $c=5$ is significantly smaller than $\\operatorname{rad}(abc)=30$, leading to a low quality. In fact, because $a,b,c$ are themselves prime numbers, the product $abc$ is square-free, meaning $\\operatorname{rad}(abc) = abc$. This leads to a particularly small quality value relative to many other triples.\nThe reference to Szpiro's conjecture, which is equivalent to the abc conjecture, provides a geometric viewpoint. A high-quality abc-triple gives rise to a Frey elliptic curve whose discriminant is unusually large compared to its conductor. The triple $(2,3,5)$ would correspond to an elliptic curve that is unremarkable from the perspective of the Szpiro inequality.\nIn conclusion, the computed quality $q(2,3,5)$ is less than $1$ and is therefore considered typical and unexceptional. It is fully consistent with the behavior expected for the vast majority of integer triples according to the abc conjecture.", "answer": "$$\\boxed{\\frac{\\ln 5}{\\ln 30}}$$", "id": "3024518"}, {"introduction": "Having established a baseline with a typical triple, we now investigate an example that highlights the true substance of the $abc$ conjecture. This practice examines an $abc$-triple with a quality $q(a,b,c) > 1$, demonstrating the existence of the very \"high-quality\" triples that the conjecture claims are rare. The key insight to be gained is understanding how the presence of perfect powers in the triple dramatically reduces the size of the radical, $\\operatorname{rad}(abc)$, relative to $c$, thereby inflating the quality. [@problem_id:3024524]", "problem": "Consider the setting of the $abc$ conjecture: an $abc$-triple is a triple of coprime positive integers $(a,b,c)$ with $a+b=c$. For an integer $n \\geq 1$, the radical $\\operatorname{rad}(n)$ is defined as the product of the distinct prime numbers dividing $n$. For an $abc$-triple $(a,b,c)$ with $\\gcd(a,b,c)=1$, the quality is defined by $q(a,b,c)=\\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$, where $\\ln$ denotes the natural logarithm.\n\nStarting from these definitions alone, take the triple $(a,b,c)=(1,8,9)$ (which satisfies $a+b=c$ and $\\gcd(a,b,c)=1$), and:\n- compute $\\operatorname{rad}(abc)$,\n- compute $q(a,b,c)$ in exact symbolic form, and\n- explain, in the context of the $abc$ conjecture and its connection to Szpiro's conjecture, how the fact that $c$ is a perfect square affects the size of $\\operatorname{rad}(abc)$ relative to $c$.\n\nExpress the final pair of computed quantities (in the order $\\operatorname{rad}(abc)$, $q(a,b,c)$) as exact expressions. No rounding is required.", "solution": "The problem is valid as it is self-contained, scientifically grounded in established number theory, and well-posed. All definitions and conditions are standard and consistent.\n\nThe problem asks for three tasks concerning the $abc$-triple $(a,b,c)=(1,8,9)$.\nFirst, we are to compute the radical of the product $abc$.\nSecond, we are to compute the quality $q(a,b,c)$ of the triple.\nThird, we must provide an explanation regarding the implications of $c$ being a perfect square.\n\nLet's address each task in sequence.\n\n1.  **Computation of $\\operatorname{rad}(abc)$**\n\nThe given triple is $(a,b,c) = (1,8,9)$. The integers are positive, coprime ($\\gcd(1,8,9)=1$), and satisfy $a+b=c$ since $1+8=9$.\nThe product $abc$ is $1 \\times 8 \\times 9 = 72$.\n\nThe radical of an integer $n$, denoted $\\operatorname{rad}(n)$, is the product of its distinct prime factors. To find $\\operatorname{rad}(72)$, we first find the prime factorization of $72$.\n$$72 = 8 \\times 9 = 2^3 \\times 3^2$$\nThe distinct prime factors of $72$ are $2$ and $3$.\nTherefore, the radical is the product of these distinct primes:\n$$\\operatorname{rad}(abc) = \\operatorname{rad}(72) = 2 \\times 3 = 6$$\n\n2.  **Computation of $q(a,b,c)$**\n\nThe quality of an $abc$-triple is defined as $q(a,b,c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$.\nFor our triple, we have $c=9$ and from the previous step, $\\operatorname{rad}(abc)=6$.\nSubstituting these values into the formula for quality gives:\n$$q(1,8,9) = \\frac{\\ln 9}{\\ln 6}$$\nTo express this in a more detailed symbolic form using properties of logarithms, we can write $\\ln 9 = \\ln(3^2) = 2 \\ln 3$ and $\\ln 6 = \\ln(2 \\times 3) = \\ln 2 + \\ln 3$.\nSo, the exact symbolic form of the quality is:\n$$q(1,8,9) = \\frac{2 \\ln 3}{\\ln 2 + \\ln 3}$$\nNumerically, this value is approximately $1.226$, which is greater than $1$. Triples with quality greater than $1$ are of particular interest in the study of the $abc$ conjecture.\n\n3.  **Explanation of the effect of $c$ being a perfect square**\n\nThe $abc$ conjecture posits that for any real number $\\varepsilon > 0$, there are only finitely many $abc$-triples for which $c > (\\operatorname{rad}(abc))^{1+\\varepsilon}$. This is equivalent to saying that the quality $q(a,b,c) = \\frac{\\ln c}{\\ln \\operatorname{rad}(abc)}$ exceeds $1+\\varepsilon$ for only a finite number of triples. The conjecture implies that the radical $\\operatorname{rad}(abc)$ is typically not much smaller than $c$.\n\nThe size of $\\operatorname{rad}(n)$ relative to $n$ is small precisely when $n$ is a \"powerful\" number, i.e., when its prime factorization contains high powers of primes. The fact that $c$ is a perfect square is a specific instance of this.\nIf an integer $c$ is a perfect square, say $c=k^2$ for some integer $k>1$, then its prime factorization consists of primes raised to even powers. The radical, $\\operatorname{rad}(c)$, only accounts for the distinct prime factors, so $\\operatorname{rad}(c) = \\operatorname{rad}(k)$. Since $\\operatorname{rad}(k) \\le k$, we have $\\operatorname{rad}(c) \\le \\sqrt{c}$. For our triple, $c=9=3^2$, so $\\operatorname{rad}(c)=\\operatorname{rad}(9)=3$, and indeed $\\operatorname{rad}(9) = \\sqrt{9}$.\nIn general, if an integer $n$ is a perfect $m$-th power, $n=k^m$, then $\\operatorname{rad}(n) = \\operatorname{rad}(k) \\le k = n^{1/m}$. This shows that a number being a perfect power significantly reduces the size of its radical relative to the number itself.\n\nIn an $abc$-triple, since $a,b,c$ are pairwise coprime, $\\operatorname{rad}(abc) = \\operatorname{rad}(a)\\operatorname{rad}(b)\\operatorname{rad}(c)$. When one of the components, such as $c$, is a perfect power, its contribution to the radical, $\\operatorname{rad}(c)$, is small relative to its contribution to the sum (since $c=a+b$). This tends to make the overall radical $\\operatorname{rad}(abc)$ small in comparison to $c$. For our triple, $a=1$, $b=8=2^3$, and $c=9=3^2$. Both $b$ and $c$ are perfect powers, making $\\operatorname{rad}(b)=2$ (much smaller than $8$) and $\\operatorname{rad}(c)=3$ (smaller than $9$). This results in a small total radical $\\operatorname{rad}(abc)=6$ compared to $c=9$, leading to a high quality $q(1,8,9) > 1$. Triples containing perfect powers are the primary source of high-quality examples that test the limits of the $abc$ conjecture.\n\nThe connection to Szpiro's conjecture arises from the study of elliptic curves. For any $abc$-triple, one can construct a corresponding Frey-Hellegouarch elliptic curve, for instance $y^2 = x(x-a)(x+b)$. A version of Szpiro's conjecture relates the minimal discriminant $\\Delta$ and the conductor $N$ of an elliptic curve over $\\mathbb{Q}$ by the inequality $|\\Delta| \\le C(\\varepsilon) N^{6+\\varepsilon}$ for any $\\varepsilon > 0$. For the Frey curve associated with an $abc$-triple, the conductor $N$ is essentially $\\operatorname{rad}(abc)$ and the discriminant $\\Delta$ is proportional to $(abc)^2$. An $abc$-triple where one term is a high power (like $c$ being a perfect square) leads to a Frey curve where the conductor $N$ is unusually small relative to the discriminant $|\\Delta|$. Such a curve is an \"extreme\" case in the context of Szpiro's conjecture, just as the corresponding $abc$-triple is an \"extreme\" case for the $abc$ conjecture. The two conjectures are, in fact, known to be equivalent.", "answer": "$$\\boxed{\\begin{pmatrix} 6  \\frac{2 \\ln 3}{\\ln 2 + \\ln 3} \\end{pmatrix}}$$", "id": "3024524"}, {"introduction": "While analyzing individual cases is essential, number theory often advances through the systematic, large-scale exploration of numerical data. This final hands-on practice transitions from theoretical calculation to computational methodology, guiding you through the design of an algorithm to search for high-quality $abc$-triples. This exercise simulates the work of a computational number theorist, developing a tool to test the limits of the $abc$ conjecture and gather empirical evidence about the distribution of these remarkable triples. [@problem_id:3024529]", "problem": "Given positive integers $a$, $b$, and $c$ satisfying $a+b=c$ and $\\gcd(a,b)=1$, the triple $(a,b,c)$ is called an $abc$ triple. For a positive integer $n$, define the radical $\\operatorname{rad}(n)$ to be the product of the distinct prime numbers dividing $n$. The $abc$ quality associated to a triple $(a,b,c)$ is the logarithmic quantity\n$$\nq_{\\log}(a,b,c) = \\frac{\\log c}{\\log \\operatorname{rad}(abc)},\n$$\nwhere $\\log$ denotes the natural logarithm. A related scale-sensitive indicator is the ratio\n$$\nq_{\\mathrm{ratio}}(a,b,c) = \\frac{c}{\\operatorname{rad}(abc)}.\n$$\nThe number theory context is that the $abc$ conjecture predicts that for every $\\varepsilon>0$ there are only finitely many triples with $c > \\operatorname{rad}(abc)^{1+\\varepsilon}$, and that large observed values of $q_{\\log}$ and $q_{\\mathrm{ratio}}$ are rare and of intrinsic interest. The conjecture has deep connections to Szpiro's conjecture for elliptic curves, and computational exploration of $abc$ triples is used to find examples that stress the conjectured bounds.\n\nYour task is to design a complete algorithm and implement it to enumerate all coprime triples $(a,b,c)$ with $a+b=c$ and $1 \\le a \\le b$, $3 \\le c \\le B$, for a given bound $B$, compute $\\operatorname{rad}(abc)$, $q_{\\log}(a,b,c)$, and $q_{\\mathrm{ratio}}(a,b,c)$, and track the triple with maximal $q_{\\log}$ for each $B$. You must:\n- Start from the fundamental definitions of $\\gcd$, prime numbers, and $\\operatorname{rad}(n)$.\n- Use a prime factorization strategy grounded in well-tested algorithmic facts, such as the sieve of Eratosthenes and smallest prime factor arrays, to compute $\\operatorname{rad}(n)$ efficiently for all $n \\le B$.\n- Represent prime divisors for each $n$ as an appropriate data structure (for example, sets of primes) so that $\\operatorname{rad}(abc)$ is obtained by taking the union of prime divisors of $a$, $b$, and $c$ and multiplying the primes in the union.\n- Maintain a data structure to track the maximal $q_{\\log}$ observed so far and the corresponding triple $(a,b,c)$, along with $\\operatorname{rad}(abc)$ and $q_{\\mathrm{ratio}}(a,b,c)$.\n\nYou must implement the algorithm as a complete, runnable program that:\n- Precomputes prime divisors for all $n \\le \\max \\{B\\}$ across the test suite using a smallest prime factor array derived from the sieve of Eratosthenes.\n- Enumerates all triples $(a,b,c)$ satisfying $a+b=c$, $1 \\le a \\le b$, $3 \\le c \\le B$, and $\\gcd(a,b)=1$.\n- Computes $\\operatorname{rad}(abc)$ by taking the union of prime divisors of $a$, $b$, and $c$ and multiplying the distinct primes in the union.\n- Computes $q_{\\log}(a,b,c)$ and $q_{\\mathrm{ratio}}(a,b,c)$ for each triple, and tracks the triple with maximal $q_{\\log}$.\n\nTest suite:\n- Use the bounds $B \\in \\{3, 50, 200, 500, 2000\\}$.\n- The case $B=3$ serves as a boundary condition where only the smallest nontrivial triple can occur.\n- The larger bounds test efficiency and correctness of the data structures and enumeration across a wider search space.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each test case result must be a list in the form $[B, q_{\\log}^{\\ast}, a^{\\ast}, b^{\\ast}, c^{\\ast}, \\operatorname{rad}(a^{\\ast}b^{\\ast}c^{\\ast}), q_{\\mathrm{ratio}}^{\\ast}]$, where the superscript $\\ast$ denotes the maximizer of $q_{\\log}$ for the given bound $B$.\n- Express $q_{\\log}^{\\ast}$ and $q_{\\mathrm{ratio}}^{\\ast}$ as decimal floats rounded to ten decimal places.\n- The single-line output should thus look like $[[B_1,q_{\\log,1},a_1,b_1,c_1,\\operatorname{rad}_1,q_{\\mathrm{ratio},1}],[B_2,q_{\\log,2},a_2,b_2,c_2,\\operatorname{rad}_2,q_{\\mathrm{ratio},2}],\\dots]$ with no other text.\n\nScientific realism and derivation requirements:\n- Begin the derivation of your algorithm from the definitions of prime numbers, the sieve of Eratosthenes for generating primes and smallest prime factors, and the definition of $\\operatorname{rad}(n)$.\n- Do not introduce shortcut formulas; justify how the union of prime factor sets yields $\\operatorname{rad}(abc)$ and why $\\gcd(a,b)=1$ is a sufficient coprimality condition for an $abc$ triple.\n- Explain clearly how the data structures ensure both correctness and efficiency of the enumeration and maximum tracking, and provide a brief complexity analysis framed in terms of $B$.", "solution": "The posed problem is a computational task in number theory, focused on the exploration of $abc$-triples, which are central to the $abc$ conjecture. The objective is to find the $abc$-triple $(a,b,c)$ that maximizes the quality metric $q_{\\log}(a,b,c)$ for various upper bounds $B$ on $c$.\n\nThe solution is constructed in two principal phases: a precomputation phase to efficiently determine the radical of any integer up to the maximum search bound, and an enumeration phase to systematically search for and evaluate all valid $abc$-triples.\n\n### Part 1: Theoretical Foundation and Definitions\n\nAn $abc$-triple is a set of three positive integers $(a, b, c)$ satisfying two conditions:\n1.  $a + b = c$\n2.  $\\gcd(a,b) = 1$ (they are coprime)\n\nThe radical of a positive integer $n$, denoted $\\operatorname{rad}(n)$, is defined as the product of its distinct prime factors.\n$$\n\\operatorname{rad}(n) = \\prod_{p | n, p \\text{ is prime}} p\n$$\n\nThe quality of an $abc$-triple is assessed using two metrics:\n$$\nq_{\\log}(a,b,c) = \\frac{\\log c}{\\log \\operatorname{rad}(abc)} \\quad \\text{and} \\quad q_{\\mathrm{ratio}}(a,b,c) = \\frac{c}{\\operatorname{rad}(abc)}\n$$\nOur goal is to find the triple that maximizes $q_{\\log}$ for $c \\le B$.\n\nA critical property of an $abc$-triple is that the integers $a, b, c$ are pairwise coprime. This is proven as follows:\n- We are given $\\gcd(a,b)=1$.\n- Let $d = \\gcd(a,c)$. Since $d$ divides $a$ and $c$, it must also divide their difference, $c-a=b$. Thus, $d$ is a common divisor of $a$ and $b$. As $\\gcd(a,b)=1$, it must be that $d=1$. Therefore, $\\gcd(a,c)=1$.\n- Similarly, let $d' = \\gcd(b,c)$. Since $d'$ divides $b$ and $c$, it must divide $c-b=a$. Thus, $d'$ is a common divisor of $a$ and $b$. As $\\gcd(a,b)=1$, it must be that $d'=1$. Therefore, $\\gcd(b,c)=1$.\n\nSince $a$, $b$, and $c$ are pairwise coprime, their sets of prime factors are disjoint. The set of prime factors of the product $abc$ is the union of these disjoint sets. Consequently, the radical of the product is the product of the radicals:\n$$\n\\operatorname{rad}(abc) = \\operatorname{rad}(a) \\operatorname{rad}(b) \\operatorname{rad}(c)\n$$\nThis property greatly simplifies the calculation of $\\operatorname{rad}(abc)$, as we can compute the radicals of $a$, $b$, and $c$ independently.\n\n### Part 2: Algorithmic Design\n\n**2.1. Efficient Precomputation of Radicals**\nA naive approach of factoring each integer during the search would be computationally prohibitive. The complexity of the overall algorithm is dominated by the triple enumeration, which is $O(B^2 \\log B)$, so individual computations inside the main loop must be highly efficient. We therefore precompute the radical for every integer up to the maximum bound $B_{\\max}$ specified in the test suite.\n\nThe precomputation utilizes a sieve method to first find the Smallest Prime Factor (SPF) of each number.\n1.  Create an array `spf` of size $B_{\\max}+1$, initialized with `spf[i] = i`.\n2.  Use a Sieve of Eratosthenes variant to populate `spf`. Iterate $p$ from $2$ to $\\sqrt{B_{\\max}}$. If `spf[p] == p` ($p$ is prime), iterate through its multiples $i = p^2, p^2+p, \\dots, B_{\\max}$ and set `spf[i] = p` if `spf[i]` is still $i$. This process has a time complexity of $O(B_{\\max} \\log \\log B_{\\max})$.\n\nWith the `spf` array, we can efficiently compute the `radicals` array.\n1.  Create an array `rad` of size $B_{\\max}+1$. Initialize `rad[1] = 1$.\n2.  Iterate $i$ from $2$ to $B_{\\max}$. Let $p=\\text{spf}[i]$ and $m=i/p$. The prime factors of $i$ are the prime factors of $m$ plus possibly $p$.\n    - If $p$ is also a prime factor of $m$ (which can be checked by testing if $\\text{spf}[m] == p$), then $\\operatorname{rad}(i)=\\operatorname{rad}(m)$.\n    - Otherwise, $p$ is a new prime factor, so $\\operatorname{rad}(i)=\\operatorname{rad}(m) \\cdot p$.\nThis calculation takes constant time for each $i$, so building the `rad` array is an $O(B_{\\max})$ operation once the `spf` array is available. Total precomputation time is dominated by the sieve: $O(B_{\\max} \\log \\log B_{\\max})$.\n\n**2.2. Triple Enumeration and Maximization**\nThe search for the optimal triple is performed by systematically iterating through all valid candidates. To improve efficiency across the test suite of multiple bounds $B \\in \\{B_1, B_2, \\dots, B_k\\}$, we sort the bounds in increasing order and perform a single cumulative search.\n\nThe enumeration proceeds as follows:\n1.  Initialize a variable `max_q_log` to $0$ and a structure to hold the data for the best triple found so far.\n2.  Iterate through the sorted bounds $B_j$. For each $B_j$, continue the search for $c$ from where the previous search for $B_{j-1}$ left off.\n3.  The main search consists of nested loops:\n    - Outer loop: `for c from 3 to B`.\n    - Inner loop: `for a from 1 to c/2`. The condition $1 \\le a \\le b$ combined with $a+b=c$ implies $2a \\le c$, so we only need to check $a \\le \\lfloor c/2 \\rfloor$.\n4.  Inside the loops:\n    a. Calculate $b = c-a$.\n    b. Check for coprimality: `if gcd(a,b) == 1`. The Euclidean algorithm for GCD is very efficient, with complexity $O(\\log a)$.\n    c. If coprime, we have a valid $abc$-triple. Compute `rad_abc = rad[a] * rad[b] * rad[c]`, using the precomputed `rad` array.\n    d. Compute $q_{\\log} = \\log(c) / \\log(\\text{rad\\_abc})$.\n    e. Compare $q_{\\log}$ with `max_q_log`. If the new value is greater, update `max_q_log` and store all relevant data for the current triple $(a,b,c)$: $q_{\\log}$, $a$, $b$, $c$, $\\operatorname{rad}(abc)$, and $q_{\\mathrm{ratio}} = c/\\operatorname{rad}(abc)$.\n\nAfter the loops for a given bound $B_j$ are complete, the currently stored best triple is the solution for that bound. This process is repeated for all bounds.\n\n**2.3. Overall Complexity**\n-   **Precomputation**: $O(B_{\\max} \\log \\log B_{\\max})$.\n-   **Enumeration**: For a single bound $B$, the two nested loops run approximately $\\sum_{c=3}^{B} c/2 \\approx B^2/4$ times. Each step involves a GCD calculation, $O(\\log c)$. The total time for enumeration up to bound $B$ is roughly $O(B^2 \\log B)$.\n-   For the entire test suite, the complexity is dominated by the search for the largest bound $B_{\\max}$, resulting in a total complexity of $O(B_{\\max}^2 \\log B_{\\max})$. For $B_{\\max} = 2000$, this is approximately $(2000)^2 \\log(2000) \\approx 3 \\times 10^7$ operations, which is computationally feasible.\n\nThis algorithmic design is correct, starting from fundamental principles, and efficient enough to solve the problem within reasonable time constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the abc-triple problem by enumerating triples and finding the one\n    that maximizes the q_log quality for a series of given bounds.\n    \"\"\"\n    test_cases = [3, 50, 200, 500, 2000]\n    \n    # Use an efficient cumulative search by sorting the bounds.\n    sorted_bounds = sorted(test_cases)\n    max_B = sorted_bounds[-1]\n\n    def precompute_radicals(limit):\n        \"\"\"\n        Precomputes radicals for all integers up to a given limit.\n        This is done by first sieving for the Smallest Prime Factor (SPF)\n        and then iteratively building the radical array.\n        \n        Complexity: O(limit * log(log(limit)))\n        \"\"\"\n        spf = list(range(limit + 1))\n        # Sieve for Smallest Prime Factor (SPF)\n        for i in range(2, int(math.sqrt(limit)) + 1):\n            if spf[i] == i:  # i is prime\n                for j in range(i * i, limit + 1, i):\n                    if spf[j] == j:  # Only update if not already set\n                        spf[j] = i\n        \n        # Compute radicals using the SPF array\n        rad = [0] * (limit + 1)\n        rad[1] = 1\n        for i in range(2, limit + 1):\n            p = spf[i]\n            m = i // p\n            # If the smallest prime factor of i/p is p itself,\n            # this means p was already a factor of m, so the distinct prime\n            # factors are the same for i and m.\n            if spf[m] == p:\n                rad[i] = rad[m]\n            else:\n                # p is a new prime factor.\n                rad[i] = rad[m] * p\n        return rad\n\n    radicals = precompute_radicals(max_B)\n\n    # State for tracking the maximum q_log and its corresponding triple data\n    # format: [q_log, a, b, c, rad_abc, q_ratio]\n    max_q_log = 0.0\n    best_triple_data = [0.0, 0, 0, 0, 0, 0.0]\n\n    results_map = {}\n    current_c = 3\n    \n    for b_bound in sorted_bounds:\n        # Enumerate triples from the last c checked up to the current bound\n        for c in range(current_c, b_bound + 1):\n            # Iterate a from 1 up to c/2. a=b and a+b=c implies 2a=c.\n            for a in range(1, c // 2 + 1):\n                b = c - a\n                # The core condition for an abc-triple\n                if math.gcd(a, b) == 1:\n                    # 'a,b,c' are pairwise coprime, so rad(abc) = rad(a)rad(b)rad(c)\n                    rad_abc = radicals[a] * radicals[b] * radicals[c]\n\n                    # The problem statement guarantees rad(abc) > 1 for valid triples.\n                    q_log = np.log(c) / np.log(rad_abc)\n                    \n                    if q_log > max_q_log:\n                        max_q_log = q_log\n                        q_ratio = c / rad_abc\n                        best_triple_data = [q_log, a, b, c, rad_abc, q_ratio]\n\n        # Store the best result found up to this bound\n        results_map[b_bound] = [\n            b_bound,\n            round(best_triple_data[0], 10),\n            best_triple_data[1],\n            best_triple_data[2],\n            best_triple_data[3],\n            best_triple_data[4],\n            round(best_triple_data[5], 10)\n        ]\n        \n        current_c = b_bound + 1\n\n    # Assemble the final output in the original order of test cases\n    final_output_list = []\n    for b_val in test_cases:\n        result_list = results_map[b_val]\n        # Format numbers to match required output, especially floats\n        formatted_parts = [str(result_list[0])]\n        formatted_parts.append(f\"{result_list[1]:.10f}\")\n        formatted_parts.extend(map(str, result_list[2:6]))\n        formatted_parts.append(f\"{result_list[6]:.10f}\")\n        \n        final_output_list.append(f\"[{','.join(formatted_parts)}]\")\n        \n    print(f\"[{','.join(final_output_list)}]\")\n\nsolve()\n```", "id": "3024529"}]}