{"hands_on_practices": [{"introduction": "Resolution-based theorem provers do not operate on arbitrary first-order logic sentences; they require input in a standardized format known as clausal form. This exercise walks you through the essential, step-by-step process of converting a formula into a set of clauses, a critical skill for preparing problems for automated reasoning. Mastering this pipeline, from eliminating implications to the crucial step of Skolemization [@problem_id:3050816], is the first gateway to applying resolution in practice.", "problem": "Let $\\Phi$ be the first-order sentence in First-Order Logic (FOL) given by\n$$\n\\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(R(y,z)\\rightarrow R(x,z))\\big).\n$$\nStarting from the fundamental equivalences of FOL (implication elimination, movement to prenex form using quantifier laws, and Skolemization which replaces each existentially quantified variable by a Skolem function of all universally quantified variables in whose scope it appears), perform a full clausal transformation of $\\Phi$ into Conjunctive Normal Form (CNF). This includes, in order: eliminating implications, moving negations inwards, producing a prenex form, standardizing variables apart, Skolemizing existential quantifiers with Skolem symbols that have the correct dependencies, dropping universal quantifiers, distributing to CNF, and finally forming the clause set with variables standardized apart across clauses and with duplicate literals and tautological clauses removed.\n\nCompute the total number of distinct clauses in the resulting clause set. Give your final answer as a single integer.", "solution": "The problem asks for the clausal transformation of a given first-order logic (FOL) sentence $\\Phi$ and to determine the number of clauses in the resulting set. The problem is well-posed and grounded in the principles of mathematical logic. I will proceed with the solution by following the specified sequence of transformation steps.\n\nThe initial FOL sentence is:\n$$ \\Phi \\equiv \\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(R(y,z)\\rightarrow R(x,z))\\big) $$\n\nThe first step is to eliminate implications. The subformula $R(y,z)\\rightarrow R(x,z)$ is transformed using the equivalence $A \\rightarrow B \\equiv \\lnot A \\lor B$. Applying this, the sentence becomes:\n$$ \\Phi_1 \\equiv \\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(\\lnot R(y,z)\\lor R(x,z))\\big) $$\n\nThe second step is to move negations inwards. In $\\Phi_1$, the only negation symbol $\\lnot$ is already applied directly to an atomic formula, $R(y,z)$. Therefore, no changes are needed in this step.\n\nThe third step is to convert the formula to prenex normal form, where all quantifiers are at the front. In $\\Phi_1$, the quantifier $\\forall z$ is within the scope of the conjunction. The variable $z$ is not a free variable in the first conjunct, $R(x,y)$. We can therefore move the quantifier $\\forall z$ outwards using the equivalence $P \\land (\\forall z\\,Q(z)) \\equiv \\forall z\\,(P \\land Q(z))$, where $z$ is not free in $P$. Applying this gives:\n$$ \\Phi_2 \\equiv \\forall x\\,\\exists y\\,\\forall z\\,\\big(R(x,y)\\,\\land\\,(\\lnot R(y,z)\\lor R(x,z))\\big) $$\nThis formula is now in prenex normal form.\n\nThe fourth step is to standardize variables apart. In $\\Phi_2$, each quantifier ($\\forall x$, $\\exists y$, $\\forall z$) binds a unique variable name. No renaming is necessary at this stage.\n\nThe fifth step is Skolemization, which eliminates existential quantifiers. The sentence $\\Phi_2$ has one existential quantifier, $\\exists y$. The variable $y$ is within the scope of the universal quantifier $\\forall x$. Thus, we replace $y$ with a Skolem function of $x$. Let this function be denoted by the symbol $f$. We replace every occurrence of $y$ with $f(x)$ and remove the quantifier $\\exists y$. The resulting formula is:\n$$ \\Phi_3 \\equiv \\forall x\\,\\forall z\\,\\big(R(x,f(x))\\,\\land\\,(\\lnot R(f(x),z)\\lor R(x,z))\\big) $$\n\nThe sixth step is to drop all universal quantifiers. The variables $x$ and $z$ are now considered implicitly universally quantified. This leaves us with the quantifier-free matrix:\n$$ M \\equiv R(x,f(x))\\,\\land\\,(\\lnot R(f(x),z)\\lor R(x,z)) $$\n\nThe seventh step is to convert the matrix $M$ into Conjunctive Normal Form (CNF). The formula $M$ is already in CNF, as it is a conjunction of two clauses. The first clause is the literal $R(x,f(x))$, and the second clause is the disjunction of two literals $\\lnot R(f(x),z)\\lor R(x,z)$. No further distribution is required.\n\nThe eighth step is to form the clause set. From the CNF formula $M$, we extract the clauses. The set of clauses is:\n$$ S = \\{ \\{R(x,f(x))\\}, \\{\\lnot R(f(x),z), R(x,z)\\} \\} $$\n\nThe ninth step is to standardize variables apart across clauses. In the set $S$, the variable $x$ appears in both clauses. In a clause set, variables are local to their respective clauses. To make this explicit, we can rename the variables such that no two clauses share a variable name. Let us rename the variable $x$ in the first clause to $v_1$, and the variables $x$ and $z$ in the second clause to $v_2$ and $v_3$ respectively. The resulting set of clauses is:\n$$ S' = \\{ \\{R(v_1,f(v_1))\\}, \\{\\lnot R(f(v_2),v_3), R(v_2,v_3)\\} \\} $$\n\nThe tenth step is to remove any duplicate literals within clauses and any tautological clauses from the set.\n- The first clause, $\\{R(v_1,f(v_1))\\}$, contains only one literal and is not a tautology.\n- The second clause, $\\{\\lnot R(f(v_2),v_3), R(v_2,v_3)\\}$, consists of two distinct literals. It is not a tautology because a clause is a tautology only if it contains a literal and its exact complement (e.g., $L$ and $\\lnot L$). Here, the literals are $\\lnot R(f(v_2),v_3)$ and $R(v_2,v_3)$, which are not complements of each other since their arguments differ.\nTherefore, the clause set $S'$ is already in its final, simplified form.\n\nThe final step is to compute the total number of distinct clauses in the resulting set $S'$. The set contains two distinct clauses:\n1. $C_1 = \\{R(v_1,f(v_1))\\}$\n2. $C_2 = \\{\\lnot R(f(v_2),v_3), R(v_2,v_3)\\}$\nThus, the total number of clauses is $2$.", "answer": "$$\n\\boxed{2}\n$$", "id": "3050816"}, {"introduction": "The engine that drives first-order resolution is unification, the algorithmic process of finding a substitution that makes two terms syntactically identical. This practice problem [@problem_id:3050868] isolates this core mechanism, presenting a classic case where unification fails due to the \"occurs check.\" Understanding this rule is vital, as it prevents the creation of invalid, infinite terms and ensures the termination and correctness of the unification algorithm.", "problem": "In first-order logic with function symbols and variables, resolution depends on the ability to unify terms. Unification attempts to find a substitution that makes two terms syntactically identical, subject to the occurs check, which prohibits assigning a variable to a term that contains that variable. Consider the set of terms $\\{f(x,x), f(g(y), y)\\}$ over a language with unary function symbol $g$ and binary function symbol $f$, and variables $x$ and $y$. Determine whether these two terms are unifiable under the occurs check by systematically attempting to solve the induced equations between their corresponding subterms and identifying any violation of the occurs check. If they are unifiable, provide the most general unifier (Most General Unifier (MGU)) as a single substitution written in set notation of the form $\\{x \\mapsto t_{x}, y \\mapsto t_{y}\\}$. If they are not unifiable under the occurs check, your final answer must be the empty set $\\varnothing$ to indicate that the set of unifiers is empty. The final answer must be a single symbolic mathematical expression.", "solution": "The problem requires determining whether the two terms $f(x,x)$ and $f(g(y), y)$ are unifiable, subject to the occurs check. Unification is the process of finding a substitution for variables that makes two logical expressions syntactically identical. If such a substitution exists, the terms are unifiable; otherwise, they are not. The most general unifier (MGU) is a substitution that is more general than any other unifier.\n\nWe begin by setting up an equation between the two terms:\n$$f(x,x) = f(g(y), y)$$\n\nThe unification algorithm proceeds by decomposing the initial equation. Since the outermost function symbols on both sides are identical (both are $f$), we can equate their respective arguments. This yields a set of two simultaneous equations:\n1. $$x = g(y)$$\n2. $$x = y$$\n\nThis set of equations, $\\{x = g(y), x = y\\}$, must be solved to find a consistent substitution. We can attempt to solve this system by using one equation to substitute into the other.\n\nLet's use the second equation, $x = y$. This equation suggests a substitution where either $x$ is replaced by $y$ or $y$ is replaced by $x$. Let's choose the substitution $\\sigma_1 = \\{x \\mapsto y\\}$. We apply this substitution to the first equation, $x = g(y)$.\n\nApplying $\\sigma_1$ to the left side of the first equation, $x$, results in $y$.\nApplying $\\sigma_1$ to the right side, $g(y)$, results in $g(y)$ (since the variable $x$ does not appear).\n\nThis transforms the first equation into:\n$$y = g(y)$$\n\nWe now have a new equation to solve. According to the rules of unification, an equation of the form $V = T$, where $V$ is a variable and $T$ is a term, can be resolved by the substitution $\\{V \\mapsto T\\}$. However, this is only permissible if the variable $V$ does not occur within the term $T$. This condition is known as the **occurs check**.\n\nIn our derived equation, $y = g(y)$, the variable to be substituted is $y$, and the term is $g(y)$. We must perform the occurs check: does the variable $y$ appear in the term $g(y)$? Yes, it clearly does.\n\nThe substitution $\\{y \\mapsto g(y)\\}$ would lead to an infinite regress. Substituting $y$ with $g(y)$ would yield $g(y) = g(g(y))$, which simplifies to $y = g(y)$ after applying the substitution again, and so on. This represents an attempt to unify a variable with a term that contains that same variable, creating an infinite term, which is disallowed in standard first-order logic.\n\nBecause the variable $y$ occurs in the term $g(y)$, the occurs check fails. The failure of the occurs check at this step implies that there is no finite substitution that can make the original set of equations consistent.\n\nTherefore, the unification process terminates in failure. The terms $f(x,x)$ and $f(g(y), y)$ are not unifiable. Consequently, the set of unifiers is the empty set.", "answer": "$$\\boxed{\\varnothing}$$", "id": "3050868"}, {"introduction": "Once a formula is in clausal form and we can unify literals, the final stage is to apply the resolution inference rule repeatedly to prove unsatisfiability by deriving a contradiction. This exercise [@problem_id:3050890] serves as a capstone, challenging you to construct a complete resolution refutation from a given set of clauses. By methodically resolving pairs of clauses and chaining the inferences, you will see how to reach the empty clause, $\\Box$, which is the definitive proof of a contradiction.", "problem": "Let $\\mathcal{L}$ be a first-order language with a constant symbol $a$, a unary function symbol $f$, and a unary predicate symbol $P$. Consider the following set of clauses in clausal form:\n- $C_{1}: P(a)$,\n- $C_{2}: \\lnot P(x) \\lor P(f(x))$,\n- $C_{3}: \\lnot P(f(f(a)))$.\n\nTasks:\n1. Using the first-order resolution rule with standard unification, construct a complete resolution refutation that derives the empty clause $\\Box$ from $\\{C_{1}, C_{2}, C_{3}\\}$.\n2. Let a binary resolution inference be defined as resolving exactly one pair of complementary literals between two clauses to produce their resolvent (no factoring, paramodulation, or other inference rules are allowed). Count only such binary resolution inferences as steps. What is the minimal number of binary resolution inferences required to refute $\\{C_{1}, C_{2}, C_{3}\\}$?\n\nProvide your reasoning from first principles of clauses, unification, and the resolution rule. The final answer must be a single integer giving the minimal number of binary resolution inferences. No rounding is needed.", "solution": "The problem asks for a resolution refutation of the given clause set and to find the minimum number of resolution steps required.\n\nThe initial set of clauses in set notation is:\n- $C_1 = \\{P(a)\\}$\n- $C_2 = \\{\\lnot P(x) \\lor P(f(x))\\}$\n- $C_3 = \\{\\lnot P(f(f(a)))\\}$\n\n**1. Constructing the Resolution Refutation**\n\nWe will apply the resolution rule to derive the empty clause ($\\Box$). A standard refutation sequence is as follows:\n\n**Step 1:** Resolve $C_1$ and $C_2$.\n- Parent clauses: $\\{P(a)\\}$ and $\\{\\lnot P(x), P(f(x))\\}$.\n- To resolve, we unify the atom $P(a)$ from $C_1$ with the atom $P(x)$ underlying the literal $\\lnot P(x)$ in $C_2$.\n- The most general unifier (MGU) is $\\theta_1 = \\{x \\mapsto a\\}$.\n- Applying this substitution and resolving the complementary literals leaves the resolvent clause:\n- $C_4 = \\{P(f(a))\\}$\n\n**Step 2:** Resolve the newly derived clause $C_4$ with $C_2$.\n- Parent clauses: $\\{P(f(a))\\}$ and $\\{\\lnot P(x), P(f(x))\\}$. To avoid variable capture, we standardize the variables in $C_2$ apart, using a new variable $y$: $C'_2 = \\{\\lnot P(y), P(f(y))\\}$.\n- We unify the atom $P(f(a))$ from $C_4$ with the atom $P(y)$ from $C'_2$.\n- The MGU is $\\theta_2 = \\{y \\mapsto f(a)\\}$.\n- The resolvent is:\n- $C_5 = \\{P(f(f(a)))\\}$\n\n**Step 3:** Resolve $C_5$ with the final clause $C_3$.\n- Parent clauses: $\\{P(f(f(a)))\\}$ and $\\{\\lnot P(f(f(a)))\\}$.\n- The two clauses contain complementary unit literals. The atoms unify with an empty MGU.\n- Resolving them yields the **empty clause**:\n- $C_6 = \\Box$\n\nThe derivation of the empty clause completes the refutation. This refutation required 3 binary resolution steps.\n\n**2. Determining the Minimal Number of Steps**\n\nWe must show that no refutation with fewer than 3 steps is possible.\n\n- A refutation in **1 step** is impossible. The empty clause can only be derived by resolving two complementary unit clauses, $\\{L\\}$ and $\\{\\lnot L\\}$. The initial set $\\{C_1, C_2, C_3\\}$ does not contain such a pair.\n\n- A refutation in **2 steps** would require generating a clause in the first step that can resolve with one of the initial clauses to produce $\\Box$.\n    - A first step must resolve two of the initial clauses. The possible resolutions are:\n        - (a) Resolve $C_1$ and $C_2$: As shown above, this yields $C_4 = \\{P(f(a))\\}$.\n        - (b) Resolve $C_2$ and $C_3$: Let's use a standardized $C'_2 = \\{\\lnot P(y), P(f(y))\\}$. We unify $P(f(y))$ from $C'_2$ with $P(f(f(a)))$ from $C_3$. The MGU is $\\{y \\mapsto f(a)\\}$. The resolvent is $C_7 = \\{\\lnot P(f(a))\\}$.\n        - (c) Resolve $C_1$ and $C_3$: This is not possible as they contain literals of the same sign.\n    - Now, for the second step, can we resolve either $C_4$ or $C_7$ with an *initial* clause to get $\\Box$?\n        - Case (a): We have $C_4 = \\{P(f(a))\\}$. To get $\\Box$, we need to resolve it with $\\{\\lnot P(f(a))\\}$. This is exactly clause $C_7$, but deriving $C_7$ required its own resolution step. Can we resolve $C_4$ with an initial clause? The only candidate is $C_3 = \\{\\lnot P(f(f(a)))\\}$. The atoms $P(f(a))$ and $P(f(f(a)))$ are not unifiable. So, this path fails.\n        - Case (b): We have $C_7 = \\{\\lnot P(f(a))\\}$. To get $\\Box$, we need to resolve it with $\\{P(f(a))\\}$, which is clause $C_4$. Again, this requires a separate first step. Can we resolve $C_7$ with an initial clause? The only candidate is $C_1 = \\{P(a)\\}$. The atoms $P(f(a))$ and $P(a)$ are not unifiable. This path also fails.\n\nSince a 2-step refutation is not possible, and we have constructed a 3-step refutation, the minimal number of binary resolution inferences required is 3.", "answer": "$$ \\boxed{3} $$", "id": "3050890"}]}