{"hands_on_practices": [{"introduction": "The best way to understand the Dirichlet hyperbola method is to apply it directly. This exercise guides you through a concrete calculation for the sum of the divisor function, $\\sum_{n \\le 100} \\tau(n)$ ([@problem_id:3090772]). By manually partitioning the lattice points under the hyperbola $ab=100$ and summing the contributions from each region, you will gain a tangible sense of how the abstract formula works in practice.", "problem": "Let $f$ and $g$ be arithmetic functions on the positive integers, and let their Dirichlet convolution $(f * g)$ be defined by $(f * g)(n) = \\sum_{ab = n} f(a) g(b)$. Starting from this definition and the counting interpretation of the inequality $ab \\leq x$ as a region in the integer lattice under the hyperbola $ab = x$, derive the Dirichlet hyperbola method decomposition that partitions the sum $\\sum_{n \\leq x} (f * g)(n)$ into three pieces by splitting at the hyperbola vertex. Then, specialize to the case $f = g = 1$ and $x = 100$, where $1$ denotes the constant function $1(n) = 1$ for all positive integers $n$. \n\nCarry out the following steps:\n- Explicitly construct the hyperbola partition for $x = 100$ by describing the three regions in terms of inequalities on $a$ and $b$ with the splitting line at $a = \\sqrt{100}$ and $b = \\sqrt{100}$. Use the greatest integer function (floor function) $\\lfloor \\cdot \\rfloor$ where needed.\n- Compute the three sums arising from the decomposition when $f = g = 1$.\n- Verify numerically that the decomposition yields the exact equality with the original sum $\\sum_{n \\leq 100} \\tau(n)$, where $\\tau(n)$ is the number of positive divisors of $n$.\n\nProvide the final value of $\\sum_{n \\leq 100} \\tau(n)$ as a single integer. No rounding is required.", "solution": "The problem asks for a derivation of the sum $\\sum_{n \\leq x} (f * g)(n)$ using the Dirichlet hyperbola method, and then to apply this method to the specific case where $x = 100$ and $f$ and $g$ are the constant function $1(n)=1$ for all positive integers $n$.\n\nFirst, we derive the general decomposition. The sum in question is given by:\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} (f * g)(n) $$\nUsing the definition of the Dirichlet convolution, $(f * g)(n) = \\sum_{ab=n} f(a)g(b)$, we can rewrite the sum as:\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{ab=n} f(a)g(b) $$\nThis is equivalent to summing over all pairs of positive integers $(a, b)$ such that their product $ab \\leq x$:\n$$ S(x) = \\sum_{ab \\leq x} f(a)g(b) $$\nThe condition $ab \\leq x$ for positive integers $a$ and $b$ defines a region in the first quadrant of the integer lattice, on or below the hyperbola $ab=x$. The Dirichlet hyperbola method provides a way to count the points in this region by partitioning it.\n\nLet $u$ be a positive real parameter, which we will set to $u = \\sqrt{x}$. The region of summation, $R = \\{(a, b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid ab \\leq x\\}$, can be partitioned into three disjoint subregions by splitting at $a = u$ and $b = u$:\n1.  $R_1 = \\{(a, b) \\in R \\mid a \\leq u, b \\leq u\\}$\n2.  $R_2 = \\{(a, b) \\in R \\mid a \\leq u, b  u\\}$\n3.  $R_3 = \\{(a, b) \\in R \\mid a  u, b \\leq u\\}$\nNote that if $a  u$ and $b  u$ then $ab  u^2=x$, so there are no points in this fourth quadrant of the partition satisfying $ab \\leq x$. The union $R_1 \\cup R_2 \\cup R_3$ is the entire region $R$.\n\nThe total sum $S(x)$ is the sum of the contributions from these three disjoint regions:\n$$ S(x) = \\sum_{(a,b) \\in R_1} f(a)g(b) + \\sum_{(a,b) \\in R_2} f(a)g(b) + \\sum_{(a,b) \\in R_3} f(a)g(b) $$\nLet $F(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} f(k)$ and $G(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} g(k)$ be the summatory functions of $f$ and $g$. The sums over each region can be expressed as:\n- Sum over $R_1$: $\\sum_{a=1}^{\\lfloor u \\rfloor} \\sum_{b=1}^{\\lfloor u \\rfloor} f(a)g(b) = \\left(\\sum_{a=1}^{\\lfloor u \\rfloor} f(a)\\right) \\left(\\sum_{b=1}^{\\lfloor u \\rfloor} g(b)\\right) = F(\\lfloor u \\rfloor)G(\\lfloor u \\rfloor)$.\n- Sum over $R_2$: $\\sum_{a=1}^{\\lfloor u \\rfloor} f(a) \\sum_{b=\\lfloor u \\rfloor+1}^{\\lfloor x/a \\rfloor} g(b) = \\sum_{a=1}^{\\lfloor u \\rfloor} f(a) \\left( G(\\lfloor x/a \\rfloor) - G(\\lfloor u \\rfloor) \\right)$.\n- Sum over $R_3$: $\\sum_{b=1}^{\\lfloor u \\rfloor} g(b) \\sum_{a=\\lfloor u \\rfloor+1}^{\\lfloor x/b \\rfloor} f(a) = \\sum_{b=1}^{\\lfloor u \\rfloor} g(b) \\left( F(\\lfloor x/b \\rfloor) - F(\\lfloor u \\rfloor) \\right)$.\n\nNow, we specialize to the case given in the problem: $f(n) = g(n) = 1$ for all $n \\in \\mathbb{Z}^+$, and $x = 100$.\nFor this case, the convolution is the divisor function, $\\tau(n) = (1 * 1)(n) = \\sum_{d|n} 1$. The sum we wish to compute is $\\sum_{n=1}^{100} \\tau(n)$.\nThe summatory functions are $F(y) = G(y) = \\sum_{k=1}^{\\lfloor y \\rfloor} 1 = \\lfloor y \\rfloor$.\nThe splitting parameter is $u = \\sqrt{x} = \\sqrt{100} = 10$. Thus, $\\lfloor u \\rfloor = 10$.\n\nThe partition of the region $ab \\leq 100$ is as follows:\n- Region 1: $R_1 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 1 \\le a \\le 10, 1 \\le b \\le 10\\}$.\n- Region 2: $R_2 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 1 \\le a \\le 10, 10  b \\le \\lfloor 100/a \\rfloor\\}$.\n- Region 3: $R_3 = \\{(a,b) \\in \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\mid 10  a \\le \\lfloor 100/b \\rfloor, 1 \\le b \\le 10\\}$.\n\nWe now compute the three sums arising from this decomposition. Since $f(a)=g(b)=1$ for all $a,b$, the sum over a region is simply the number of integer points in that region.\n\nSum for Region 1:\nThe number of points in $R_1$ is the size of the $10 \\times 10$ square:\n$$ \\text{Sum}_1 = \\sum_{a=1}^{10} \\sum_{b=1}^{10} 1 = 10 \\times 10 = 100 $$\n\nSum for Region 2:\nThe number of points in $R_2$ is:\n$$ \\text{Sum}_2 = \\sum_{a=1}^{10} \\sum_{b=11}^{\\lfloor 100/a \\rfloor} 1 = \\sum_{a=1}^{10} \\max(0, \\lfloor 100/a \\rfloor - 10) $$\nThe term is non-zero only for $a  10$.\n$a=1: \\lfloor 100/1 \\rfloor - 10 = 100 - 10 = 90$\n$a=2: \\lfloor 100/2 \\rfloor - 10 = 50 - 10 = 40$\n$a=3: \\lfloor 100/3 \\rfloor - 10 = 33 - 10 = 23$\n$a=4: \\lfloor 100/4 \\rfloor - 10 = 25 - 10 = 15$\n$a=5: \\lfloor 100/5 \\rfloor - 10 = 20 - 10 = 10$\n$a=6: \\lfloor 100/6 \\rfloor - 10 = 16 - 10 = 6$\n$a=7: \\lfloor 100/7 \\rfloor - 10 = 14 - 10 = 4$\n$a=8: \\lfloor 100/8 \\rfloor - 10 = 12 - 10 = 2$\n$a=9: \\lfloor 100/9 \\rfloor - 10 = 11 - 10 = 1$\n$a=10: \\lfloor 100/10 \\rfloor - 10 = 10 - 10 = 0$\n$$ \\text{Sum}_2 = 90 + 40 + 23 + 15 + 10 + 6 + 4 + 2 + 1 + 0 = 191 $$\n\nSum for Region 3:\nThe number of points in $R_3$ is:\n$$ \\text{Sum}_3 = \\sum_{b=1}^{10} \\sum_{a=11}^{\\lfloor 100/b \\rfloor} 1 = \\sum_{b=1}^{10} \\max(0, \\lfloor 100/b \\rfloor - 10) $$\nBy symmetry with the calculation for $\\text{Sum}_2$, we have:\n$$ \\text{Sum}_3 = 191 $$\n\nFinally, we verify numerically that the decomposition yields the exact value for the original sum. The total sum is the sum of the counts from the three disjoint regions:\n$$ \\sum_{n=1}^{100} \\tau(n) = \\text{Sum}_1 + \\text{Sum}_2 + \\text{Sum}_3 = 100 + 191 + 191 = 482 $$\nThe method of partitioning the summation region is an exact counting procedure. Therefore, the numerical calculation confirms that the sum of the values from the three pieces correctly gives the total sum. The final value is the result of this exact calculation.", "answer": "$$\\boxed{482}$$", "id": "3090772"}, {"introduction": "The precision of the hyperbola method lies in its careful handling of the overlap region to avoid double-counting points. This problem zooms in on this critical detail by examining the special case where $x$ is a perfect square, which ensures the splitting point $\\sqrt{x}$ is an integer ([@problem_id:3090733]). Focusing on the single lattice point $(\\sqrt{x}, \\sqrt{x})$ reveals exactly how the principle of inclusion-exclusion operates, ensuring every point is counted precisely once.", "problem": "Let $d(n)$ denote the number of positive divisors of the positive integer $n$. For a real parameter $x \\geq 1$, consider the summatory divisor function $\\sum_{n \\leq x} d(n)$, and recall the reinterpretation based on counting lattice points: $\\sum_{n \\leq x} d(n)$ equals the number of pairs $(a,b) \\in \\mathbb{N}^{2}$ with $ab \\leq x$. Assume $x$ is a perfect square, so that $\\sqrt{x} \\in \\mathbb{N}$.\n\nUsing only the fundamental definition of $d(n)$ and the counting interpretation above, partition the set of pairs $(a,b)$ with $ab \\leq x$ into two symmetric parts with respect to the diagonal $a=b$, by first counting those with $a \\leq \\sqrt{x}$ and then those with $b \\leq \\sqrt{x}$, and correcting for any overlap to avoid double counting. Focus on the unique diagonal point at the corner of the feasible region, namely $(a,b) = (\\sqrt{x}, \\sqrt{x})$.\n\nDetermine the exact net contribution to $\\sum_{n \\leq x} d(n)$ arising solely from the diagonal corner point $(\\sqrt{x}, \\sqrt{x})$ after the symmetric partition and overlap correction are carried out. Give your answer as a single number.", "solution": "The problem asks for the net contribution of the specific lattice point $(\\sqrt{x}, \\sqrt{x})$ to the summatory divisor function $\\sum_{n \\leq x} d(n)$ when calculated using a specific counting method, given the condition that $x$ is a perfect square.\n\nLet the summatory divisor function be denoted by $S(x) = \\sum_{n \\leq x} d(n)$. The function $d(n)$ is the number of positive divisors of $n$. A fundamental property is that $d(n) = \\sum_{ab=n, a,b \\in \\mathbb{N}} 1$. Therefore, the summatory function can be expressed as a count of lattice points in the plane:\n$$ S(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{ab=n} 1 = \\sum_{\\substack{a,b \\in \\mathbb{N} \\\\ ab \\leq x}} 1 $$\nThis means $S(x)$ is the number of pairs of positive integers $(a,b)$ such that their product is less than or equal to $x$. These pairs correspond to lattice points in the first quadrant that lie on or below the hyperbola $ab=x$.\n\nThe problem specifies a particular method for counting these points, which is a textbook application of the principle of inclusion-exclusion, often known as the Dirichlet hyperbola method. Let $y = \\sqrt{x}$. Since $x$ is a perfect square, $y$ is a positive integer.\nThe set of all points to be counted is $P = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x\\}$.\nFor any point $(a,b) \\in P$, it is impossible for both $a  y$ and $b  y$ to be true, because this would imply $ab  y \\cdot y = x$, contradicting the condition $ab \\leq x$. Therefore, for any point in $P$, it must be that either $a \\leq y$ or $b \\leq y$ (or both).\n\nFollowing the problem's instructions, we define two sets:\n1. The set of pairs with $a \\leq y$: Let this be $P_1 = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x \\text{ and } a \\leq y\\}$.\n2. The set of pairs with $b \\leq y$: Let this be $P_2 = \\{(a,b) \\in \\mathbb{N}^2 \\mid ab \\leq x \\text{ and } b \\leq y\\}$.\n\nThe total set of points is the union of these two sets, $P = P_1 \\cup P_2$. The counting method described is to sum the sizes of $P_1$ and $P_2$ and then subtract the size of their intersection to correct for double-counting.\n$$ S(x) = |P| = |P_1 \\cup P_2| = |P_1| + |P_2| - |P_1 \\cap P_2| $$\nThe problem asks for the \"net contribution\" of the specific point $p_0 = (y,y) = (\\sqrt{x}, \\sqrt{x})$ to this calculation. The net contribution is determined by how many times this specific point is counted in each term of the formula. This can be formalized using an indicator function, $\\chi_{p_0}(A)$, which is $1$ if $p_0 \\in A$ and $0$ otherwise. The net contribution is $\\chi_{p_0}(P_1) + \\chi_{p_0}(P_2) - \\chi_{p_0}(P_1 \\cap P_2)$.\n\nWe now check if the point $p_0 = (y,y)$ belongs to each of these sets.\n1.  **Contribution to $|P_1|$**:\n    The point $p_0$ is in $P_1$ if it satisfies the conditions $ab \\leq x$ and $a \\leq y$. For $p_0=(y,y)$, we have $a=y$ and $b=y$.\n    - The first condition is $ab = y \\cdot y = y^2 = x$. So, $ab \\leq x$ is satisfied.\n    - The second condition is $a=y$. So, $a \\leq y$ is satisfied.\n    Since both conditions are met, the point $p_0$ is in the set $P_1$. Its contribution to the count $|P_1|$ is $1$. Thus, $\\chi_{p_0}(P_1) = 1$.\n\n2.  **Contribution to $|P_2|$**:\n    The point $p_0$ is in $P_2$ if it satisfies the conditions $ab \\leq x$ and $b \\leq y$. For $p_0=(y,y)$, we have $a=y$ and $b=y$.\n    - The first condition $ab \\leq x$ is satisfied, as shown above.\n    - The second condition is $b=y$. So, $b \\leq y$ is satisfied.\n    Since both conditions are met, the point $p_0$ is in the set $P_2$. Its contribution to the count $|P_2|$ is $1$. Thus, $\\chi_{p_0}(P_2) = 1$.\n\n3.  **Contribution to $|P_1 \\cap P_2|$ (the overlap correction)**:\n    The set $P_1 \\cap P_2$ consists of points $(a,b)$ satisfying all three conditions: $ab \\leq x$, $a \\leq y$, and $b \\leq y$. The purpose of subtracting $|P_1 \\cap P_2|$ is to remove the points that were counted in both $|P_1|$ and $|P_2|$.\n    We check if $p_0=(y,y)$ belongs to this intersection.\n    - As established, $p_0$ satisfies $ab \\leq x$.\n    - As established, $p_0$ satisfies $a \\leq y$.\n    - As established, $p_0$ satisfies $b \\leq y$.\n    Since $p_0$ is in both $P_1$ and $P_2$, it is, by definition, in their intersection $P_1 \\cap P_2$. Its contribution to the count $|P_1 \\cap P_2|$ is $1$. Thus, $\\chi_{p_0}(P_1 \\cap P_2) = 1$.\n\nFinally, the net contribution of the point $p_0 = (\\sqrt{x}, \\sqrt{x})$ to the total sum $S(x)$ after the partition and overlap correction is the sum of its contributions, with the appropriate signs:\n$$ \\text{Net Contribution} = \\chi_{p_0}(P_1) + \\chi_{p_0}(P_2) - \\chi_{p_0}(P_1 \\cap P_2) = 1 + 1 - 1 = 1 $$\nThis result is consistent with the goal of the method, which is to count every valid lattice point exactly once. The point $(\\sqrt{x}, \\sqrt{x})$ corresponds to the single divisor pair of the integer $x$ where the factors are equal. The inclusion-exclusion procedure correctly counts this point one time in the final sum.", "answer": "$$\n\\boxed{1}\n$$", "id": "3090733"}, {"introduction": "The principles behind the hyperbola method are not just theoretical; they lead to powerful computational tools. The identity $\\sum_{n \\le x} d(n) = \\sum_{k=1}^{\\lfloor x \\rfloor} \\lfloor x/k \\rfloor$, which arises from counting the lattice points under the hyperbola, can be used to create an algorithm far more efficient than naive summation. This final practice challenges you to develop and analyze an algorithm that computes this sum in $O(\\sqrt{x})$ time, demonstrating the practical value of understanding the structure of these sums ([@problem_id:3090756]).", "problem": "You are to derive, implement, and analyze an algorithm based on the Dirichlet hyperbola method to compute the summatory divisor function. Let $d(n)$ denote the number of positive divisors of the integer $n$. Define the summatory function $D(x)$ by\n$$\nD(x) = \\sum_{n \\le x} d(n),\n$$\nfor any integer $x \\ge 0$. Starting only from the fundamental definition that $d(n)$ counts positive divisors of $n$ and the identity that counting divisor pairs corresponds to counting lattice points $(a,b)$ with $ab \\le x$, derive an algorithm that computes $D(x)$ in $O(\\sqrt{x})$ time by grouping indices $n$ with equal values of the floor function $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$. The grouping strategy should be used to avoid iterating over all $n \\le x$ and should rely on the observation that $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$ takes the same value over contiguous ranges of $n$.\n\nYour program must implement this algorithm for a fixed test suite and output the results in the specified format. The test suite consists of the following integer values of $x$:\n- $x = 0$ (boundary case),\n- $x = 1$ (smallest nontrivial case),\n- $x = 2$ (very small case),\n- $x = 10$ (small case),\n- $x = 100$ (moderate case),\n- $x = 999999$ (large case just below a round threshold),\n- $x = 1000000$ (large case at a round threshold).\n\nFor each $x$ in the test suite, your program must compute $D(x)$ as an integer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite (for example, if the results were $r_1, r_2, \\ldots, r_7$, the output must be in the exact format $[r_1,r_2,r_3,r_4,r_5,r_6,r_7]$).\n\nNo physical units or angles are involved in this problem. All quantities are pure integers. Ensure that your algorithm achieves $O(\\sqrt{x})$ time complexity by grouping indices with equal values of $\\left\\lfloor \\frac{x}{n} \\right\\rfloor$.", "solution": "The objective is to derive and implement an algorithm to compute the summatory divisor function, $D(x) = \\sum_{n \\le x} d(n)$, in $O(\\sqrt{x})$ time, where $d(n)$ is the number of positive divisors of $n$. The derivation will follow the principle of the Dirichlet hyperbola method and will utilize the specified optimization of grouping indices.\n\nFirst, we express $D(x)$ in a more tractable form. The definition of the divisor function is $d(n) = \\sum_{k|n, k0} 1$. Substituting this into the definition of $D(x)$ for an integer $x \\ge 0$ gives:\n$$\nD(x) = \\sum_{n=1}^{\\lfloor x \\rfloor} d(n) = \\sum_{n=1}^{\\lfloor x \\rfloor} \\sum_{k|n} 1\n$$\nThe double summation counts pairs of positive integers $(n, k)$ such that $k$ divides $n$ and $n \\le x$. The condition $k|n$ implies that $n = km$ for some positive integer $m$. The condition $n \\le x$ thus becomes $km \\le x$. This allows us to re-index the sum over pairs of positive integers $(k, m)$ such that their product $km \\le x$:\n$$\nD(x) = \\sum_{k,m \\in \\mathbb{Z}^+; km \\le x} 1\n$$\nGeometrically, this sum represents the number of integer lattice points $(k,m)$ in the first quadrant that lie on or under the hyperbola $km = x$.\n\nTo evaluate this sum, we can iterate through one variable, say $k$, and for each $k$, sum up the valid counts for $m$. The variable $k$ can range from $1$ to $\\lfloor x \\rfloor$. For a fixed $k$, the condition $km \\le x$ is equivalent to $m \\le \\frac{x}{k}$. Since $m$ must be an integer, the number of possible values for $m$ is $\\lfloor \\frac{x}{k} \\rfloor$. This leads to the following identity for $D(x)$:\n$$\nD(x) = \\sum_{k=1}^{\\lfloor x \\rfloor} \\sum_{m=1}^{\\lfloor x/k \\rfloor} 1 = \\sum_{k=1}^{\\lfloor x \\rfloor} \\left\\lfloor \\frac{x}{k} \\right\\rfloor\n$$\nA naive algorithm to compute this sum would iterate $k$ from $1$ to $\\lfloor x \\rfloor$, which has a time complexity of $O(x)$. For large $x$, this is inefficient.\n\nThe problem requires an $O(\\sqrt{x})$ algorithm, achieved by grouping indices. We observe that the term $\\lfloor \\frac{x}{k} \\rfloor$ is a non-increasing step function of $k$. It takes the same value for many consecutive values of $k$. We can exploit this by grouping terms with the same value of $\\lfloor \\frac{x}{k} \\rfloor$ and calculating their contribution to the sum in a single step.\n\nLet us formalize this grouping strategy. We iterate through blocks of indices. Let a block start at index $k$. The value of the floor function for this block is $v = \\lfloor \\frac{x}{k} \\rfloor$. We need to find the largest index $k_{end}$ such that for all integers $i$ with $k \\le i \\le k_{end}$, we have $\\lfloor \\frac{x}{i} \\rfloor = v$.\n\nThe condition $\\lfloor \\frac{x}{i} \\rfloor = v$ is equivalent to the inequality $v \\le \\frac{x}{i}  v+1$.\nThe left part of the inequality, $v \\le \\frac{x}{i}$, implies $i \\le \\frac{x}{v}$. Since $i$ must be an integer, $i \\le \\lfloor \\frac{x}{v} \\rfloor$.\nThe right part, $\\frac{x}{i}  v+1$, implies $i  \\frac{x}{v+1}$.\nFor any $i \\ge k$, we have $\\frac{x}{i} \\le \\frac{x}{k}$, so $\\lfloor \\frac{x}{i} \\rfloor \\le \\lfloor \\frac{x}{k} \\rfloor = v$. Therefore, we only need to find the largest $i$ that satisfies $v \\le \\lfloor \\frac{x}{i} \\rfloor$. This occurs at $i = \\lfloor \\frac{x}{v} \\rfloor$.\nThus, for a starting index $k$, the block of indices for which $\\lfloor \\frac{x}{i} \\rfloor$ remains constant at $v = \\lfloor \\frac{x}{k} \\rfloor$ is $[k, k_{end}]$, where $k_{end} = \\lfloor \\frac{x}{v} \\rfloor = \\lfloor \\frac{x}{\\lfloor x/k \\rfloor} \\rfloor$.\n\nThe number of terms in this block is $(k_{end} - k + 1)$. The contribution of this entire block to the total sum is $(k_{end} - k + 1) \\times v$. After processing this block, the next index to consider is $k_{end} + 1$.\n\nThe algorithm is as follows:\n1. Initialize a total sum $S = 0$ and the starting index $k = 1$.\n2. While $k \\le x$:\n   a. If $k  x$, terminate. For an integer $x$, this is equivalent to $k  \\lfloor x \\rfloor$.\n   b. Calculate the value $v = \\lfloor \\frac{x}{k} \\rfloor$. If $v=0$, all subsequent terms are $0$, so we can terminate.\n   c. Determine the end of the current block, $k_{end} = \\lfloor \\frac{x}{v} \\rfloor$.\n   d. Add the contribution of this block to the total sum: $S \\leftarrow S + (k_{end} - k + 1) \\times v$.\n   e. Update the index to the start of the next block: $k \\leftarrow k_{end} + 1$.\n3. The final result is $D(x) = S$.\n\nTo analyze the complexity, we count the number of iterations. The loop advances $k$ in jumps. The number of unique values of $\\lfloor \\frac{x}{k} \\rfloor$ for $k=1, \\dots, \\lfloor x \\rfloor$ determines the number of iterations.\n- For $k \\in [1, \\lfloor\\sqrt{x}\\rfloor]$, there are at most $\\lfloor\\sqrt{x}\\rfloor$ distinct values of $k$, and thus at most $\\lfloor\\sqrt{x}\\rfloor$ distinct values of $\\lfloor\\frac{x}{k}\\rfloor$.\n- For $k \\in (\\lfloor\\sqrt{x}\\rfloor, \\lfloor x \\rfloor]$, we have $k  \\sqrt{x}$, which implies $\\frac{x}{k}  \\sqrt{x}$. So, the value $v = \\lfloor \\frac{x}{k} \\rfloor$ is an integer in the range $[1, \\lfloor\\sqrt{x}\\rfloor - 1]$. There are at most $\\lfloor\\sqrt{x}\\rfloor - 1$ distinct values in this range.\nThe total number of distinct values of $\\lfloor \\frac{x}{k} \\rfloor$, and therefore the number of loop iterations, is bounded by $2\\lfloor\\sqrt{x}\\rfloor$. Each iteration involves a few arithmetic operations, taking constant time. Thus, the overall time complexity of this algorithm is $O(\\sqrt{x})$. This meets the requirements of the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef divisor_summatory_function(x: int) -> int:\n    \"\"\"\n    Computes the summatory divisor function D(x) = sum_{n = x} d(n)\n    using the Dirichlet hyperbola method optimized with index grouping.\n\n    The identity D(x) = sum_{k=1}^{x} floor(x/k) is used. The sum is\n    computed in O(sqrt(x)) time by grouping terms where floor(x/k)\n    is constant.\n\n    Args:\n        x: A non-negative integer.\n\n    Returns:\n        The integer value of D(x).\n    \"\"\"\n    if x  1:\n        return 0\n\n    # According to the problem statement, all quantities are integers.\n    # Python's integers support arbitrary precision, so overflow is not a concern\n    # for the given test cases.\n    x = int(x)\n\n    total_sum = 0\n    k = 1\n    while k = x:\n        # v is the value of floor(x/k) for the current block of indices.\n        v = x // k\n\n        # k_end is the last index for which floor(x/i) has the value v.\n        # k_end = floor(x / v)\n        k_end = x // v\n\n        # The number of indices in the block [k, k_end] is (k_end - k + 1).\n        # Add the contribution of this block to the total sum.\n        num_terms = k_end - k + 1\n        total_sum += num_terms * v\n\n        # Jump to the start of the next block.\n        k = k_end + 1\n\n    return total_sum\n\ndef solve():\n    \"\"\"\n    Runs the calculation for the test suite specified in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,          # boundary case\n        1,          # smallest nontrivial case\n        2,          # very small case\n        10,         # small case\n        100,        # moderate case\n        999999,     # large case just below a round threshold\n        1000000     # large case at a round threshold\n    ]\n\n    results = []\n    for x_val in test_cases:\n        result = divisor_summatory_function(x_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3090756"}]}