{"hands_on_practices": [{"introduction": "To study aliquot sequences, we first need a reliable method for calculating any term in the sequence. This practice guides you through designing an efficient algorithm to compute the aliquot sum, $s(n)$, for any integer $n$. By leveraging the fundamental theorem of arithmetic and the multiplicative nature of the sum-of-divisors function, you will build a foundational tool for all further exploration. [@problem_id:3080697]", "problem": "You are to design and implement an algorithm to compute the aliquot sum function $s(n)$, defined for a positive integer $n$ as the sum of all positive divisors of $n$ that are strictly less than $n$. The algorithm must be based on the prime factorization of $n$ and derived from first principles: start from the definition of divisors, the concept of prime factorization, and the multiplicativity of the sum-of-divisors function. You must not assume any special-case shortcuts or precomputed tables. Your implementation should be general and correct for any positive integer input in the given test suite.\n\nYour program must:\n- Given a positive integer $n$, compute $s(n)$ using its prime factorization and the multiplicative structure of the sum-of-divisors function.\n- For each $n$, also compute its aliquot type code $t(n)$, defined as:\n  - $t(n)=-1$ if $s(n)  n$ (deficient),\n  - $t(n)=0$ if $s(n)=n$ (perfect),\n  - $t(n)=1$ if $s(n)  n$ (abundant).\n- Handle the boundary case $n=1$ according to the definition $s(1)=0$.\n\nThe foundational base you may use includes:\n- The definition of divisors and proper divisors of $n$.\n- The Fundamental Theorem of Arithmetic, which guarantees that every $n\\ge 2$ factors uniquely into a product of prime powers.\n- The multiplicativity of the sum-of-divisors function, deduced from the structure of divisors of coprime integers.\n- The finite geometric series identity for sums of powers of a prime in a single prime-power factor.\n\nYou must also reason about and state the time complexity of your algorithm in terms of the complexity of factoring $n$. In particular, suppose the time to factor $n$ is $T_{\\mathrm{fact}}(n)$. You must express the overall time complexity using $T_{\\mathrm{fact}}(n)$ and other relevant arithmetic parameters of $n$ that arise naturally from the factorization process, with clear justification grounded in the above foundational base. The reasoning belongs in your solution text; the program should only perform the computations.\n\nTest suite:\n- Inputs $n$ to evaluate: $[1,2,28,12,25,220,360,9973]$.\n- For each $n$ in the order given, output the pair $[s(n),t(n)]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of bracketed pairs, enclosed in square brackets, with no extra whitespace. For example, the output must look like $[[a\\_1,b\\_1],[a\\_2,b\\_2],\\dots]$ where each $a\\_i$ and $b\\_i$ are integers corresponding to $s(n)$ and $t(n)$ for the $i$-th test input.\n- The output must be a single line in exactly this format: a top-level list containing the $8$ ordered pairs in the same order as the test suite.\n\nYour program must be deterministic and must not require any input. No physical or angle units are involved; all outputs are pure integers. The final answers for the test suite must be integers and lists of integers as specified, aggregated into a single line as described.", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It consists of a standard number theory task with all necessary definitions and constraints clearly specified.\n\nThe problem requires the computation of the aliquot sum $s(n)$ for a positive integer $n$. The aliquot sum is defined as the sum of the positive divisors of $n$ that are strictly less than $n$. These divisors are also known as the proper divisors of $n$. The sum of all positive divisors of $n$, including $n$ itself, is denoted by the sum-of-divisors function, $\\sigma(n)$. From these definitions, the aliquot sum is given by the relation $s(n) = \\sigma(n) - n$.\n\nThe problem also requires the classification of $n$ based on its aliquot sum. An integer $n$ is classified as deficient if $s(n)  n$, perfect if $s(n) = n$, and abundant if $s(n)  n$. These classifications correspond to aliquot type codes $t(n) = -1$, $t(n) = 0$, and $t(n) = 1$, respectively.\n\nThe derivation of the algorithm must be based on first principles, specifically using the prime factorization of $n$.\n\nFor the boundary case $n=1$, the only positive divisor is $1$. The set of proper divisors is empty. Therefore, the sum of proper divisors is $s(1) = 0$. Since $s(1)  1$, the number $1$ is deficient, and its type code is $t(1)=-1$.\n\nFor any integer $n \\ge 2$, the Fundamental Theorem of Arithmetic states that $n$ has a unique prime factorization of the form:\n$$n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k} = \\prod_{i=1}^{k} p_i^{a_i}$$\nwhere $p_1, p_2, \\dots, p_k$ are distinct prime numbers and $a_1, a_2, \\dots, a_k$ are positive integers.\n\nAny divisor $d$ of $n$ must be of the form:\n$$d = p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} = \\prod_{i=1}^{k} p_i^{b_i}$$\nwhere for each $i \\in \\{1, 2, \\dots, k\\}$, the exponent $b_i$ is an integer satisfying $0 \\le b_i \\le a_i$.\n\nThe sum-of-divisors function, $\\sigma(n)$, is the sum of all such divisors $d$. This can be expressed as a nested summation over all possible values of the exponents $b_i$:\n$$\\sigma(n) = \\sum_{b_1=0}^{a_1} \\sum_{b_2=0}^{a_2} \\cdots \\sum_{b_k=0}^{a_k} \\left( p_1^{b_1} p_2^{b_2} \\cdots p_k^{b_k} \\right)$$\nDue to the distributive property of multiplication over addition, this multi-dimensional sum can be factored into a product of one-dimensional sums:\n$$\\sigma(n) = \\left( \\sum_{b_1=0}^{a_1} p_1^{b_1} \\right) \\left( \\sum_{b_2=0}^{a_2} p_2^{b_2} \\right) \\cdots \\left( \\sum_{b_k=0}^{a_k} p_k^{b_k} \\right) = \\prod_{i=1}^{k} \\left( \\sum_{b_i=0}^{a_i} p_i^{b_i} \\right)$$\nThis expression reveals the multiplicative nature of the $\\sigma$ function. The term for each prime factor $p_i^{a_i}$ is $\\sigma(p_i^{a_i}) = \\sum_{b_i=0}^{a_i} p_i^{b_i}$. Thus, $\\sigma(n) = \\prod_{i=1}^{k} \\sigma(p_i^{a_i})$.\n\nEach sum $\\sum_{b=0}^{a} p^b = 1 + p + p^2 + \\dots + p^a$ is a finite geometric series. The sum of a geometric series is given by the formula $\\sum_{j=0}^{m} r^j = \\frac{r^{m+1}-1}{r-1}$. Applying this formula with $r=p$ and $m=a$, we get:\n$$\\sigma(p^a) = \\frac{p^{a+1}-1}{p-1}$$\nSubstituting this back into the product for $\\sigma(n)$, we obtain the complete formula based on prime factorization:\n$$\\sigma(n) = \\prod_{i=1}^{k} \\frac{p_i^{a_i+1}-1}{p_i-1}$$\n\nThe algorithm to compute $s(n)$ and $t(n)$ can be summarized as follows:\n1. Handle the boundary case: If $n=1$, return $s(1)=0$ and $t(1)=-1$.\n2. For $n \\ge 2$, find its prime factorization $n = \\prod_{i=1}^{k} p_i^{a_i}$. This yields a set of pairs $(p_i, a_i)$.\n3. Initialize the sum of divisors, $\\sigma_{val}$, to $1$.\n4. For each pair $(p_i, a_i)$ in the factorization, compute the term $\\sigma(p_i^{a_i}) = \\frac{p_i^{a_i+1}-1}{p_i-1}$.\n5. Multiply this term into the running product: $\\sigma_{val} = \\sigma_{val} \\times \\sigma(p_i^{a_i})$.\n6. After iterating through all prime factors, the final value is $\\sigma(n) = \\sigma_{val}$.\n7. Compute the aliquot sum: $s(n) = \\sigma(n) - n$.\n8. Determine the aliquot type code $t(n)$ by comparing $s(n)$ with $n$:\n   - If $s(n)  n$, $t(n) = -1$.\n   - If $s(n) = n$, $t(n) = 0$.\n   - If $s(n)  n$, $t(n) = 1$.\n\nThe time complexity of this algorithm is dominated by the prime factorization step. Let $T_{\\mathrm{fact}}(n)$ be the time required to find the prime factorization of $n$. The steps following factorization involve iterating through the $k$ distinct prime factors of $n$. For each factor $p_i^{a_i}$, we perform a constant number of arithmetic operations (exponentiation, subtraction, division). The number of distinct prime factors $k$ is at most $O(\\log n)$. The magnitude of the intermediate and final numbers is polynomially bounded in $n$. Specifically, the arithmetic operations on these numbers take time that is polynomial in their bit length, which is $O(\\log n)$. Therefore, the total time for the post-factorization computation is $O(\\text{poly}(\\log n))$. Since integer factorization is a computationally hard problem, with the best known algorithms having super-polynomial complexity in $\\log n$, $T_{\\mathrm{fact}}(n)$ is the dominant term. The overall time complexity of the algorithm is thus $O(T_{\\mathrm{fact}}(n))$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliquot sum and aliquot type for a given list of integers,\n    as per the problem statement.\n    \"\"\"\n\n    def get_prime_factorization(n):\n        \"\"\"\n        Computes the prime factorization of a positive integer n.\n        Returns a dictionary mapping each prime factor to its exponent.\n        Uses trial division, which is efficient for the given test cases.\n        \"\"\"\n        if n  1:\n            return {}\n        \n        factors = {}\n        # Handle factor 2\n        while n % 2 == 0:\n            factors[2] = factors.get(2, 0) + 1\n            n //= 2\n        \n        # Handle odd factors\n        d = 3\n        while d * d = n:\n            while n % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                n //= d\n            d += 2\n            \n        # If n is still greater than 1, it must be a prime factor itself.\n        if n  1:\n            factors[n] = factors.get(n, 0) + 1\n            \n        return factors\n\n    def compute_s_and_t(n):\n        \"\"\"\n        Computes the aliquot sum s(n) and aliquot type code t(n).\n        \"\"\"\n        if n == 1:\n            s_n = 0\n            t_n = -1  # Deficient\n            return [s_n, t_n]\n\n        factors = get_prime_factorization(n)\n        \n        sigma_n = 1\n        for p, a in factors.items():\n            # Using the geometric series sum formula: (p^(a+1) - 1) / (p - 1)\n            sigma_p_a = (p**(a + 1) - 1) // (p - 1)\n            sigma_n *= sigma_p_a\n            \n        s_n = sigma_n - n\n        \n        if s_n  n:\n            t_n = -1  # Deficient\n        elif s_n == n:\n            t_n = 0   # Perfect\n        else:\n            t_n = 1   # Abundant\n            \n        return [s_n, t_n]\n\n    test_cases = [1, 2, 28, 12, 25, 220, 360, 9973]\n    \n    results = []\n    for n in test_cases:\n        result = compute_s_and_t(n)\n        results.append(result)\n\n    # Format the output string exactly as specified, with no extra whitespace.\n    pair_strings = [f\"[{s},{t}]\" for s, t in results]\n    final_output = f\"[{','.join(pair_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3080697"}, {"introduction": "With a method to compute $s(n)$ in hand, we can begin to investigate its mapping properties. This exercise presents an intriguing inverse problem: which integers $m$ result in an aliquot sum of exactly 1? Solving this requires a careful case-by-case analysis based on the fundamental properties of numbers, leading to a surprisingly elegant characterization that links the aliquot function directly to the concept of primality. [@problem_id:3080703]", "problem": "Let $s(n)$ denote the sum of the proper divisors of a positive integer $n$, that is, $s(n) = \\sum_{d \\mid n,\\, d  n} d$. Consider the directed aliquot graph whose vertices are the positive integers and whose directed edges are given by $m \\to s(m)$. The in-degree of a vertex $n$ in this graph is the number of distinct positive integers $m$ such that $s(m) = n$. Using only foundational definitions from elementary number theory, determine the in-degree of $n=1$ by finding all positive integers $m$ satisfying $s(m) = 1$ and giving a complete characterization of such $m$ in terms of primality or compositeness. Express the final in-degree exactly as a closed-form symbolic expression. No rounding is required.", "solution": "The problem requires us to determine the in-degree of the vertex $n=1$ in the directed aliquot graph. The function $s(n)$ is defined as the sum of the proper divisors of a positive integer $n$. A proper divisor of $n$ is any positive divisor of $n$ other than $n$ itself. Symbolically, this is expressed as $s(n) = \\sum_{d|n, \\, dn} d$.\n\nThe in-degree of a vertex $n$ is the number of distinct positive integers $m$ such that the function $s(m)$ evaluates to $n$. For this problem, we must find the cardinality of the set $\\{m \\in \\mathbb{Z}^+ \\mid s(m) = 1\\}$. This requires finding all positive integers $m$ that satisfy the equation $s(m) = 1$.\n\nLet us analyze the equation $s(m) = 1$. The sum $s(m)$ is a sum of positive integers. For this sum to equal $1$, two conditions must be met:\n$1$. The set of proper divisors must be non-empty.\n$2$. The set of proper divisors must contain exactly one element, which must be the integer $1$.\n\nWe can systematically investigate all positive integers $m$ by partitioning them into three exhaustive categories: $m=1$, $m$ is a prime number, and $m$ is a composite number.\n\nCase 1: $m=1$.\nThe only positive divisor of $1$ is $1$. The set of proper divisors of $1$ consists of its positive divisors that are strictly less than $1$. There are no such integers. The set of proper divisors is the empty set, $\\emptyset$. The sum of the elements of an empty set is defined to be $0$. Therefore, $s(1) = 0$. Since $0 \\neq 1$, $m=1$ is not a solution.\n\nCase 2: $m$ is a prime number.\nLet $m=p$, where $p$ is any prime number. By definition, a prime number is an integer greater than $1$ whose only positive divisors are $1$ and itself. The set of all positive divisors of $p$ is $\\{1, p\\}$. The set of proper divisors of $p$ consists of its divisors that are strictly less than $p$. In this case, the only proper divisor is $1$.\nThus, for any prime number $p$, the sum of its proper divisors is $s(p) = 1$. This shows that every prime number is a solution to the equation $s(m)=1$.\n\nCase 3: $m$ is a composite number.\nA composite number is an integer greater than $1$ that is not prime. By definition, if $m$ is composite, it must have at least one divisor $d$ such that $1  d  m$. Since $m1$, $1$ is always a proper divisor of $m$. The integer $d$ is also a proper divisor by definition. Therefore, the set of proper divisors of any composite number $m$ contains at least two distinct elements, $\\{1, d, \\dots\\}$.\nThe sum of the proper divisors, $s(m)$, is the sum of all such divisors. Since all divisors are positive, $s(m) \\ge 1+d$. Given that $d  1$, it follows that $s(m) > 1+1=2$.\nSo, for any composite number $m$, $s(m) \\ge 2$, which means $s(m)$ cannot be equal to $1$. No composite number is a solution to the equation.\n\nCombining the results from all three cases, we have a complete characterization of the integers $m$ for which $s(m)=1$: an integer $m$ satisfies $s(m)=1$ if and only if $m$ is a prime number.\n\nThe problem asks for the in-degree of $n=1$, which is the total count of these integers $m$. The set of solutions is the set of all prime numbers, $\\mathbb{P} = \\{2, 3, 5, 7, 11, \\dots\\}$.\nA fundamental result in number theory, first proven by Euclid, states that there are infinitely many prime numbers. Therefore, the cardinality of the set of integers $m$ satisfying $s(m)=1$ is infinite.\n\nThe in-degree of $n=1$ is the number of such integers, which is infinite. This value is represented symbolically.", "answer": "$$\n\\boxed{\\infty}\n$$", "id": "3080703"}, {"introduction": "The central challenge in this topic is understanding the long-term behavior of aliquot sequences. This capstone practice asks you to synthesize your computational skills to track a sequence until it terminates or enters a cycle. You will implement sophisticated cycle-detection algorithms, such as Floyd's tortoise-and-hare method, to classify the ultimate fate of a sequence and calculate key invariants like its preperiod and cycle length. [@problem_id:3080656]", "problem": "You are to implement a complete, runnable program that computes aliquot sequences for given starting integers until either termination or entry into a cycle is detected. Begin from first principles by using the definition of the sum-of-proper-divisors function and the induced sequence. Derive and implement both a hashing-based detection and Floyd’s cycle-finding algorithm to ensure robustness. The program must compute specified numerical invariants that quantify the behavior of each aliquot sequence.\n\nDefinitions and fundamental base:\n- For any integer $n \\geq 0$, define the set of proper divisors of $n$ as all positive integers $d$ such that $d \\mid n$ and $0  d  n$. Define the sum of proper divisors function $s(n)$ by $s(n) = \\sum_{d \\mid n, \\; 0  d  n} d$, with the conventions $s(0) = 0$ and $s(1) = 0$.\n- The aliquot sequence $\\{a_k\\}_{k \\geq 0}$ starting at $a_0 = n$ is defined recursively by $a_{k+1} = s(a_k)$ for all $k \\geq 0$.\n- The sequence is said to terminate if it reaches $0$ at some finite index. The sequence is said to be cyclic if there exist integers $\\mu \\geq 0$ and $\\lambda \\geq 1$ such that $a_{\\mu} = a_{\\mu+\\lambda}$, and thereafter $a_{t+\\lambda} = a_t$ for all $t \\geq \\mu$. The integer $\\mu$ is the preperiod (also called tail length), and $\\lambda$ is the cycle length.\n- For canonical reporting of a cycle, define the cycle representative $c$ to be $0$ in the terminating case and the minimal element (with respect to the usual order on integers) among $\\{a_{\\mu}, a_{\\mu+1}, \\dots, a_{\\mu+\\lambda-1}\\}$ in the cyclic case.\n\nTask requirements:\n- Implement a function to compute $s(n)$ from its definition, using only fundamental divisor properties (for example, if $d \\mid n$ with $1  d \\leq \\sqrt{n}$, then both $d$ and $n/d$ are divisors).\n- Implement two independent cycle detection strategies for the sequence generated by $s(n)$:\n  1. A hashing-based method that records visited values and their first indices to detect the first repeat and determine $\\mu$ and $\\lambda$.\n  2. Floyd’s cycle-finding algorithm (also known as the tortoise-and-hare method) adapted to detect termination when $0$ is encountered and otherwise to recover $\\mu$ and $\\lambda$.\n- Define the output invariants for a starting value $n$ as the triple $[\\mu, \\lambda, c]$, where $c = 0$ if and only if the sequence terminates and otherwise $c$ is the minimal element of the eventual cycle.\n\nTest suite:\n- Your program must evaluate the starting values $n \\in \\{1, 6, 10, 13, 220, 12496\\}$ and compute the corresponding triples $[\\mu, \\lambda, c]$ for each.\n- These values cover a boundary case ($n = 1$), a perfect number that is a fixed point ($n = 6$), a general terminating case ($n = 10$), a prime that terminates via $1$ ($n = 13$), an amicable pair leading to a $2$-cycle ($n = 220$), and a sociable cycle of length $5$ ($n = 12496$).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a triple in brackets. For the specified test suite, the output must have the form\n$[[\\mu_1,\\lambda_1,c_1],[\\mu_2,\\lambda_2,c_2],...,[\\mu_6,\\lambda_6,c_6]]$\nwith no spaces.", "solution": "The problem of computing aliquot sequence invariants is a well-defined computational task within the domain of number theory. It is scientifically grounded, objective, and contains all necessary definitions and constraints to proceed with a formal solution. The provided test cases are standard examples used to illustrate the diverse behaviors of aliquot sequences, including termination, fixed points (cycles of length $1$), amicable pairs (cycles of length $2$), and sociable cycles (cycles of length greater than $2$). The problem is therefore deemed **valid**.\n\nThe solution proceeds in three stages. First, we construct the sum-of-proper-divisors function, $s(n)$, which is the generator of the sequence. Second, we formalize the generation of the aliquot sequence and the definitions of the required numerical invariants: the preperiod length $\\mu$, the cycle length $\\lambda$, and the cycle representative $c$. Finally, we detail the implementation of two distinct algorithms for detecting cycles and termination—a hashing-based method and Floyd’s cycle-finding algorithm—to compute these invariants for any given starting integer $n$.\n\n### 1. The Sum-of-Proper-Divisors Function, $s(n)$\n\nThe core of the problem is the function $s(n)$, defined as the sum of the positive divisors of an integer $n$ excluding $n$ itself. The definition is $s(n) = \\sum_{d|n, 0  d  n} d$. The conventions $s(0) = 0$ and $s(1) = 0$ are given.\n\nFor $n  1$, we can compute $s(n)$ efficiently. The integer $1$ is always a proper divisor, so we may initialize a sum with $1$. We then search for other divisors. A key property of divisors is that they come in pairs. If $d$ is a divisor of $n$, then $n/d$ is also a divisor. We can exploit this by iterating a test divisor $d$ from $2$ up to the integer part of the square root of $n$, $\\lfloor\\sqrt{n}\\rfloor$.\n\nThe algorithm is as follows:\n1.  Handle the base cases as per the definition: if $n \\le 1$, return $0$.\n2.  For $n  1$, initialize a variable `total_sum` to $1$, accounting for the divisor $d=1$.\n3.  Iterate with an integer $d$ from $2$ up to and including $\\lfloor\\sqrt{n}\\rfloor$.\n4.  In each iteration, if $d$ divides $n$ (i.e., $n \\pmod d = 0$), then $d$ is a proper divisor, so we add it to `total_sum`. Its corresponding paired divisor is $q = n/d$.\n5.  If $d$ is not equal to its pair $q$ (which occurs when $n$ is not a perfect square), then $q$ is another distinct divisor. We add $q$ to `total_sum` as well. If $d=q$ (i.e., $n=d^2$), we have already accounted for this single divisor $d$, so no further action is needed for the pair.\n6.  The final value of `total_sum` is $s(n)$.\n\nFor example, to compute $s(220)$: $\\sqrt{220} \\approx 14.8$.\n- Initialize sum = $1$.\n- Divisors up to $14$: $2, 4, 5, 10, 11$.\n- Pairs: $220/2=110$, $220/4=55$, $220/5=44$, $220/10=22$, $220/11=20$.\n- $s(220) = 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284$.\n\n### 2. Aliquot Sequence Invariants: $[\\mu, \\lambda, c]$\n\nAn aliquot sequence is generated by iterating the $s(n)$ function, starting from an initial integer $a_0 = n$:\n$$ a_{k+1} = s(a_k) \\quad \\text{for } k \\geq 0 $$\nThis sequence, $\\{a_k\\}_{k \\geq 0}$, can either terminate by reaching $0$ or eventually repeat, entering a cycle. We are tasked with quantifying this behavior using three invariants:\n-   **Preperiod length ($\\mu$)**: The number of terms in the sequence before it becomes periodic or terminates. This is the length of the \"tail\".\n-   **Cycle length ($\\lambda$)**: The number of unique terms in the repeating cycle. For a terminating sequence, there is no cycle, so we adopt the convention $\\lambda = 0$.\n-   **Cycle representative ($c$)**: For a cyclic sequence, this is the minimal integer value within the cycle $\\{a_\\mu, a_{\\mu+1}, \\ldots, a_{\\mu+\\lambda-1}\\}$. For a terminating sequence, we set $c = 0$.\n\n### 3. Cycle and Termination Detection Algorithms\n\nWe implement two independent algorithms to find the invariants $[\\mu, \\lambda, c]$.\n\n#### Method 1: Hashing-Based Detection\n\nThis method relies on memory to keep track of every term generated in the sequence. A hash map (or dictionary) is used to store each unique term encountered and the index of its first appearance.\n1.  Initialize an empty sequence list, `seq`, and add the starting value $n$, so `seq = [n]`.\n2.  Initialize a hash map, `visited`, mapping the value $n$ to its index $0$: `visited = {n: 0}`.\n3.  Begin a loop to generate subsequent terms:\n    a.  Let `current_val` be the last term in `seq`. Compute `next_val = s(current_val)`.\n    b.  **Termination Check**: If `next_val` is $0$, the sequence terminates. The preperiod length is the count of all terms before $0$, so $\\mu = \\text{len(seq)}$. By convention, we set $\\lambda = 0$ and $c = 0$. The process for this starting value is complete.\n    c.  **Cycle Check**: If `next_val` is already a key in the `visited` map, a cycle has been detected. The first time we saw this value was at index $\\mu = \\text{visited[next_val]}$. The current number of terms generated is $\\text{len(seq)}$. The cycle length is therefore $\\lambda = \\text{len(seq)} - \\mu$. The elements of the cycle are given by the sub-sequence `seq[μ:]`. The cycle representative is $c = \\min(\\text{seq[μ:]})$. The process is complete.\n    d.  **Continuation**: If `next_val` is not $0$ and has not been visited, record it: add `next_val` to the `visited` map with its index, `visited[next_val] = len(seq)`, and append it to the `seq` list. Then, continue the loop.\n\nThis method is straightforward and directly yields all three invariants $\\mu$, $\\lambda$, and $c$.\n\n#### Method 2: Floyd's Cycle-Finding Algorithm (Tortoise and Hare)\n\nThis algorithm uses two pointers, a \"tortoise\" and a \"hare\", moving through the sequence at different speeds. It detects a cycle with constant space complexity, but requires additional steps to find the invariants.\n\n1.  **Phase 1: Detect Cycle or Termination**\n    a.  Initialize `tortoise = s(n)` and `hare = s(s(n))`. Handle the edge cases where these initial values might be $0$, indicating immediate termination.\n    b.  Advance the pointers in a loop: `tortoise = s(tortoise)` and `hare = s(s(hare))`.\n    c.  The loop terminates if either `tortoise == hare` (a cycle is detected) or if `tortoise` or `hare` becomes $0$ (termination is detected).\n\n2.  **Phase 2: Determine Invariants**\n    a.  **If Termination was Detected**: The sequence ends in $0$. To find $\\mu$, we must re-trace the sequence from the start: initialize `current_val = n` and a counter `mu_val = 0`. Step through the sequence (`current_val = s(current_val)`) until `current_val` becomes $0$, incrementing `mu_val` at each step. The final count is $\\mu$. The other invariants are $\\lambda=0$ and $c=0$.\n    b.  **If a Cycle was Detected**: The pointers met at a value `tortoise` which is an element within the cycle.\n        i.  **Find Preperiod Length ($\\mu$):** Initialize one pointer `ptr1` to the start, $n$, and another `ptr2` to the meeting point, `tortoise`. Advance both pointers one step at a time (`ptr1 = s(ptr1)`, `ptr2 = s(ptr2)`). The first point at which they become equal is the first element of the cycle, $a_\\mu$. The number of steps taken is the preperiod length, $\\mu$.\n        ii. **Find Cycle Length ($\\lambda$):** Starting from the first element of the cycle, $a_\\mu$, advance a pointer one step at a time (`ptr = s(ptr)`) until it returns to $a_\\mu$. The number of steps taken is the cycle length, $\\lambda$.\n        iii. **Find Cycle Representative ($c$):** Iterate through the $\\lambda$ elements of the cycle, starting from $a_\\mu$, and find their minimum value. This is $c$.\n\nBoth methods are implemented in the final program. The hashing-based approach is used to generate the final output due to its more direct computation of all three required invariants.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... is not needed for this problem.\n\ndef s(n: int) - int:\n    \"\"\"\n    Computes the sum of proper divisors of an integer n, s(n).\n    s(n) is the sum of all positive integers d such that d | n and 0  d  n.\n    By convention, s(0) = 0 and s(1) = 0.\n    \"\"\"\n    if n = 1:\n        return 0\n    \n    # Initialize sum with 1, as 1 is a proper divisor for all n  1.\n    total = 1\n    \n    # Iterate from 2 up to the square root of n.\n    # np.sqrt is used as per the allowed library set.\n    limit = int(np.sqrt(n))\n    for d in range(2, limit + 1):\n        if n % d == 0:\n            total += d\n            quotient = n // d\n            # Add the paired divisor if it's not the same as d (for non-perfect squares).\n            if d != quotient:\n                total += quotient\n                \n    return total\n\ndef analyze_sequence_hash(n: int) - list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using a hashing-based method.\n    \n    Returns:\n        A list [mu, lambda, c] representing the preperiod, cycle length,\n        and cycle representative.\n    \"\"\"\n    if n == 0:\n        return [0, 1, 0] # A fixed point, but often treated as termination.\n                         # The prompt definition s(0)=0 leads to [0, 1, 0].\n                         # Let's align with the termination definition.\n                         # Sequence 0 - 0. Preperiod 0. Cycle length 1. rep 0.\n                         # But test cases imply 0 means termination. So we just need to handle s(a_k)=0.\n    \n    sequence = [n]\n    visited = {n: 0} # Maps value to its first index\n    k = 0\n    while True:\n        # We add a practical limit to prevent potential infinite loops on\n        # sequences whose behavior is unknown (e.g., Lehmer five), though not\n        # strictly needed for the given test cases.\n        if k  2000:\n            # This case should not be reached for the provided inputs\n            raise RuntimeError(f\"Sequence starting at {n} did not resolve within the iteration limit.\")\n\n        current_val = sequence[-1]\n        next_val = s(current_val)\n        \n        # Termination check\n        if next_val == 0:\n            mu = len(sequence)\n            lam = 0\n            c = 0\n            return [mu, lam, c]\n        \n        # Cycle detection check\n        if next_val in visited:\n            mu = visited[next_val]\n            lam = len(sequence) - mu\n            cycle = sequence[mu:]\n            c = min(cycle)\n            return [mu, lam, c]\n            \n        # Continue sequence generation\n        visited[next_val] = len(sequence)\n        sequence.append(next_val)\n        k += 1\n\ndef analyze_sequence_floyd(n: int) - list[int]:\n    \"\"\"\n    Analyzes the aliquot sequence starting at n using Floyd's cycle-finding algorithm.\n    This function is implemented to satisfy the problem requirement but is not\n    used to generate the final output. The hash-based method is more direct.\n    \n    Returns:\n        A list [mu, lambda, c].\n    \"\"\"\n    # Handle simple termination cases first\n    if n == 0:\n        return [0, 0, 0] # Terminating\n    val_s = s(n)\n    if val_s == 0:\n        return [1, 0, 0] # n - 0\n    val_ss = s(val_s)\n    if val_ss == 0:\n        return [2, 0, 0] # n - s(n) - 0\n\n    tortoise = val_s\n    hare = val_ss\n    \n    # Phase 1: Find a meeting point or termination\n    while tortoise != hare:\n        tortoise = s(tortoise)\n        hare = s(s(hare))\n        if tortoise == 0 or hare == 0:\n            # Termination found\n            mu = 0\n            curr = n\n            while curr != 0:\n                curr = s(curr)\n                mu += 1\n            return [mu, 0, 0]\n\n    # Phase 2: Cycle found, now find invariants\n    # Find preperiod length (mu)\n    mu = 0\n    ptr1 = n\n    ptr2 = tortoise\n    while ptr1 != ptr2:\n        ptr1 = s(ptr1)\n        ptr2 = s(ptr2)\n        mu += 1\n    \n    # Find cycle length (lambda)\n    lam = 1\n    ptr2 = s(ptr1)\n    cycle_min = ptr1\n    while ptr1 != ptr2:\n        cycle_min = min(cycle_min, ptr2)\n        ptr2 = s(ptr2)\n        lam += 1\n        \n    c = cycle_min\n    \n    return [mu, lam, c]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on the test suite and print the output.\n    \"\"\"\n    test_cases = [1, 6, 10, 13, 220, 12496]\n\n    results = []\n    # We use the hash-based method as it's more direct for finding all invariants.\n    # The problem requires implementing both methods; `analyze_sequence_floyd` is also provided.\n    for n in test_cases:\n        mu, lam, c = analyze_sequence_hash(n)\n        results.append(f\"[{mu},{lam},{c}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3080656"}]}