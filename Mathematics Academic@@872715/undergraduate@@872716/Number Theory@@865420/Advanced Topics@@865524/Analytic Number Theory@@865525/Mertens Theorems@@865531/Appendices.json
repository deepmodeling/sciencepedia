{"hands_on_practices": [{"introduction": "The derivations of Mertens' theorems rely on a crucial approximation: for a large prime $p$, the term $\\ln(1 - 1/p)$ behaves much like $-1/p$. This exercise challenges you to go beyond this first-order approximation and rigorously analyze the error term using the Taylor series expansion of the logarithm. By finding the best possible constant $C$ in the bound $| \\ln(1 - 1/p) + 1/p | \\le C/p^2$, you will develop a deeper appreciation for the analytical tools that underpin the study of prime numbers [@problem_id:3087063].", "problem": "In the study of products over prime numbers arising in Mertens' theorems, one frequently approximates the natural logarithm of factors of the form $1 - \\frac{1}{p}$, where $p$ is prime, by its first-order term. Let $p$ be any integer with $p \\geq 2$, and define the truncation error\n$$\nE(p) := \\ln\\!\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}.\n$$\nStarting only from the fundamental fact that the natural logarithm admits a convergent power series expansion around zero for inputs of absolute value less than one, and using basic properties of series with positive terms, derive a uniform bound of the form $|E(p)| \\leq \\frac{C}{p^{2}}$ that is valid for all integers $p \\geq 2$. Determine, in exact closed form, the smallest constant $C$ for which this inequality holds uniformly in $p$. Your final answer must be this exact minimal constant $C$ as a single analytic expression.", "solution": "The problem is to determine the smallest constant $C$ such that the inequality $|E(p)| \\leq \\frac{C}{p^{2}}$ holds for all integers $p \\geq 2$, where the error term $E(p)$ is defined as\n$$\nE(p) := \\ln\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}.\n$$\nThe derivation must start from the power series expansion of the natural logarithm.\n\nThe Maclaurin series for $\\ln(1-x)$ is given by\n$$\n\\ln(1-x) = -\\sum_{k=1}^{\\infty} \\frac{x^{k}}{k} = -x - \\frac{x^{2}}{2} - \\frac{x^{3}}{3} - \\dots\n$$\nThis series converges for $|x|  1$.\n\nWe are interested in the case where $p$ is an integer such that $p \\geq 2$. Let us set $x = \\frac{1}{p}$. For $p \\geq 2$, we have $0  \\frac{1}{p} \\leq \\frac{1}{2}$, so the condition $|x|  1$ is satisfied, and the series expansion is valid. Substituting $x = \\frac{1}{p}$ into the series gives:\n$$\n\\ln\\left(1 - \\frac{1}{p}\\right) = -\\sum_{k=1}^{\\infty} \\frac{1}{k p^{k}} = -\\frac{1}{p} - \\frac{1}{2p^{2}} - \\frac{1}{3p^{3}} - \\dots\n$$\nNow, we substitute this expression into the definition of $E(p)$:\n$$\nE(p) = \\left(-\\sum_{k=1}^{\\infty} \\frac{1}{k p^{k}}\\right) + \\frac{1}{p}\n$$\nWe can separate the first term of the sum:\n$$\nE(p) = \\left(-\\frac{1}{p} - \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}\\right) + \\frac{1}{p}\n$$\nThe terms $\\frac{1}{p}$ cancel out, leaving:\n$$\nE(p) = -\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}} = -\\left(\\frac{1}{2p^{2}} + \\frac{1}{3p^{3}} + \\frac{1}{4p^{4}} + \\dots\\right)\n$$\nWe are looking for the smallest constant $C$ such that $|E(p)| \\leq \\frac{C}{p^{2}}$ for all integers $p \\geq 2$.\nFirst, let's find the expression for $|E(p)|$. Since $p \\geq 2$, every term in the series $\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}$ is positive. Therefore,\n$$\n|E(p)| = \\left|-\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}\\right| = \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}}\n$$\nThe inequality we must satisfy is:\n$$\n\\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}} \\leq \\frac{C}{p^{2}}\n$$\nTo find the smallest $C$ that holds for all integers $p \\geq 2$, we should analyze the expression $p^{2}|E(p)|$. Let $f(p) = p^{2}|E(p)|$. We seek $C = \\sup_{p \\geq 2, p \\in \\mathbb{Z}} f(p)$.\n$$\nf(p) = p^{2} \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k}} = \\sum_{k=2}^{\\infty} \\frac{p^{2}}{k p^{k}} = \\sum_{k=2}^{\\infty} \\frac{1}{k p^{k-2}}\n$$\nLet's write out the first few terms of the series for $f(p)$:\n$$\nf(p) = \\frac{1}{2p^{2-2}} + \\frac{1}{3p^{3-2}} + \\frac{1}{4p^{4-2}} + \\dots = \\frac{1}{2} + \\frac{1}{3p} + \\frac{1}{4p^{2}} + \\frac{1}{5p^{3}} + \\dots\n$$\nEach term in this series, $\\frac{1}{k p^{k-2}}$ for $k \\geq 3$, is a positive and strictly decreasing function of $p$ for $p>0$. The first term, $\\frac{1}{2}$, is constant. Therefore, their sum, $f(p)$, is a strictly decreasing function of $p$ for $p > 0$.\nThe supremum of $f(p)$ over the set of integers $p \\geq 2$ must occur at the smallest integer in this set, which is $p=2$.\nSo, the smallest constant $C$ is given by the value of $f(2)$:\n$$\nC = f(2) = \\sum_{k=2}^{\\infty} \\frac{1}{k 2^{k-2}}\n$$\nTo evaluate this series, we can factor out a constant to make it resemble a known series:\n$$\nC = \\frac{1}{2 \\cdot 2^{0}} + \\frac{1}{3 \\cdot 2^{1}} + \\frac{1}{4 \\cdot 2^{2}} + \\dots = \\sum_{k=2}^{\\infty} \\frac{4}{k 2^{k}} = 4 \\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k}\n$$\nWe recall the Maclaurin series for $-\\ln(1-x)$:\n$$\n-\\ln(1-x) = \\sum_{k=1}^{\\infty} \\frac{x^{k}}{k}\n$$\nSetting $x = \\frac{1}{2}$, we obtain:\n$$\n-\\ln\\left(1-\\frac{1}{2}\\right) = -\\ln\\left(\\frac{1}{2}\\right) = \\ln(2) = \\sum_{k=1}^{\\infty} \\frac{(1/2)^{k}}{k}\n$$\nWe can split the sum:\n$$\n\\ln(2) = \\frac{(1/2)^{1}}{1} + \\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k} = \\frac{1}{2} + \\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k}\n$$\nFrom this, we can isolate the series we need to evaluate:\n$$\n\\sum_{k=2}^{\\infty} \\frac{(1/2)^{k}}{k} = \\ln(2) - \\frac{1}{2}\n$$\nFinally, we substitute this result back into our expression for $C$:\n$$\nC = 4 \\left( \\ln(2) - \\frac{1}{2} \\right) = 4\\ln(2) - 2\n$$\nThis is the exact minimal constant $C$ for which the inequality $|E(p)| \\leq \\frac{C}{p^{2}}$ holds for all integers $p \\geq 2$.", "answer": "$$\\boxed{4\\ln(2) - 2}$$", "id": "3087063"}, {"introduction": "After analyzing the behavior of a single term in the prime product, we now turn to the global picture. Mertens' third theorem makes a striking prediction about the collective behavior of primes: the product $\\prod_{p \\le x} (1 - 1/p)$ decays like $1/\\ln x$. This computational practice invites you to verify this remarkable result empirically. By writing code to compute the product and analyze the behavior of the quantity $(\\ln x) \\prod_{p \\le x} (1 - 1/p)$, you will gain direct, hands-on intuition for the theorem's meaning and witness how theoretical asymptotics manifest in real data [@problem_id:3087061].", "problem": "You are asked to design and implement a complete program to numerically investigate properties connected to Mertens' theorems in number theory. Define the function $P(x)$ for real $x \\geq 1$ by extending it piecewise constantly as follows: for each integer $n \\geq 1$, let\n$$\nP(n) \\;=\\; \\prod_{p \\leq n} \\left( 1 - \\frac{1}{p} \\right),\n$$\nwhere the product ranges over all prime numbers $p \\leq n$, and for non-integers $x$ define $P(x)$ by $P(x) = P(\\lfloor x \\rfloor)$. Let $L(x)$ denote the scaled product\n$$\nL(x) \\;=\\; (\\log x)\\, P(x),\n$$\nwhere $\\log$ denotes the natural logarithm. Your goals are:\n- To test the monotonicity of $P(x)$ as $x$ increases over integers.\n- To quantify the near-constancy of $L(x)$ over prescribed sample sets.\n\nYou must base your reasoning and design on fundamental definitions and well-tested facts:\n- A prime number is a positive integer greater than $1$ that has no positive divisors other than $1$ and itself.\n- The product $P(n)$ is defined by multiplying factors $(1 - 1/p)$ for all primes $p \\leq n$.\n- The natural logarithm $\\log x$ is strictly increasing for $x  0$.\n\nTasks to implement:\n1. Prime generation and cumulative product:\n   - Generate all prime numbers up to a maximum bound $N_{\\max}$ using a correct and efficient method based solely on the definition of a prime number (for example, a sieve).\n   - Compute the cumulative sequence $(P(n))_{n=1}^{N_{\\max}}$ by updating only when $n$ is prime, since for composite $n$ no new factor enters the product.\n\n2. Monotonicity test:\n   - For each bound $N$, check whether the sequence $(P(1),P(2),\\dots,P(N))$ is non-increasing. Because each new factor $(1 - 1/p)$ satisfies $0  (1 - 1/p)  1$, the ideal exact arithmetic would imply $P(n)$ is non-increasing in $n$. In floating-point arithmetic, allow a minimal numerical tolerance when comparing successive values.\n\n3. Near-constancy metric for $L(x)$:\n   - For a given bound $N$ and a specified sample set $S \\subseteq \\{2,3,\\dots,N\\}$, define the list of sampled values $\\{L(x) : x \\in S\\}$.\n   - Quantify near-constancy by the dimensionless ratio\n     $$\n     R(S) \\;=\\; \\frac{\\max_{x \\in S} L(x) \\;-\\; \\min_{x \\in S} L(x)}{\\mathrm{median}\\,\\{L(x) : x \\in S\\}},\n     $$\n     provided the median is positive; if the median is zero, set $R(S) = 0$ for that case.\n   - You must compute this ratio for two types of sample sets:\n     - The integer sample set $S_{\\mathrm{int}}(N) = \\{2,3,\\dots,N\\}$.\n     - The prime sample set $S_{\\mathrm{prime}}(N) = \\{p \\leq N : p \\text{ is prime}\\}$.\n   This metric tests the idea, suggested by Mertens' theorems, that $L(x)$ varies slowly with $x$; the computation should include small primes and moderate ranges.\n\nTest suite:\n- Your program must run with no input and compute results for the following six parameter sets $(N,\\mathrm{mode})$, where $\\mathrm{mode}$ indicates the sample set used in the near-constancy metric:\n  1. $(2,\\text{\"integers\"})$ using $S_{\\mathrm{int}}(2)$.\n  2. $(2,\\text{\"primes\"})$ using $S_{\\mathrm{prime}}(2)$.\n  3. $(30,\\text{\"integers\"})$ using $S_{\\mathrm{int}}(30)$.\n  4. $(30,\\text{\"primes\"})$ using $S_{\\mathrm{prime}}(30)$.\n  5. $(100000,\\text{\"integers\"})$ using $S_{\\mathrm{int}}(100000)$.\n  6. $(100000,\\text{\"primes\"})$ using $S_{\\mathrm{prime}}(100000)$.\n\nPer test case, your program must output a two-element list $[b, r]$, where $b$ is a boolean indicating whether $(P(n))_{n=1}^{N}$ is non-increasing, and $r$ is the floating-point value of $R(S)$ for the specified sample set.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order listed above and is itself a two-element list $[b,r]$. For example, a syntactically valid format is\n  $$\n  [[\\text{True},0.0123],[\\text{True},0.0456],\\dots]\n  $$\n- There are no physical units or angles in this problem. All numerical answers are unitless real numbers.", "solution": "The provided Python solution implements the required numerical investigation by first pre-computing all necessary data up to the maximum bound $N_{\\max}=100000$, and then processing each test case.\n\n**Algorithm Steps:**\n1.  **Pre-computation:**\n    *   **Prime Generation:** A boolean array `is_prime` is created, and all prime numbers up to $N_{\\max}$ are identified using the Sieve of Eratosthenes. This efficient method marks multiples of each prime as composite.\n    *   **Cumulative Product Calculation:** An array `P_values` is created to store the values of $P(n)$ for $n$ from 1 to $N_{\\max}$. $P(1)$ is initialized to 1. The array is then populated iteratively: for each $n > 1$, $P(n)$ is set to $P(n-1)$, and if $n$ is prime, this value is multiplied by the new factor $(1 - 1/n)$.\n2.  **Test Case Evaluation:** For each test case $(N, \\text{mode})$:\n    *   **Monotonicity Check:** The pre-computed sequence $(P(1), \\dots, P(N))$ is checked to be non-increasing. A loop verifies that $P(n) \\le P(n-1)$ for all $n \\in [2, N]$, allowing for a small numerical tolerance. The boolean result `b` is recorded.\n    *   **Near-Constancy Metric:**\n        *   The appropriate sample set $S$ is constructed, either as all integers from 2 to $N$ or as all primes up to $N$.\n        *   For each $x \\in S$, the value $L(x) = (\\log x) P(x)$ is calculated using the pre-computed `P_values`.\n        *   The metric $R(S)$ is computed from the list of $L(x)$ values by finding their maximum, minimum, and median, and applying the formula $R(S) = (\\max - \\min) / \\text{median}$.\n3.  **Output Generation:** The final list of results $[b, R(S)]$ for all test cases is formatted into the specified string format and printed. The `numpy` library is used for efficient array operations, logarithms, and statistical calculations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes results for a numerical investigation of Mertens' theorems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, \"integers\"),\n        (2, \"primes\"),\n        (30, \"integers\"),\n        (30, \"primes\"),\n        (100000, \"integers\"),\n        (100000, \"primes\"),\n    ]\n\n    # Determine the maximum N required across all test cases for pre-computation.\n    N_max = 0\n    if test_cases:\n        N_max = max(n for n, mode in test_cases)\n\n    # Pre-computation Phase\n    # This block will only run if there are test cases to process.\n    if N_max  0:\n        # 1. Prime generation using Sieve of Eratosthenes\n        is_prime = np.ones(N_max + 1, dtype=bool)\n        if N_max = 0:\n            is_prime[0] = False\n        if N_max = 1:\n            is_prime[1] = False\n        for i in range(2, int(np.sqrt(N_max)) + 1):\n            if is_prime[i]:\n                is_prime[i*i::i] = False\n        \n        prime_numbers = np.where(is_prime)[0]\n\n        # 2. Cumulative product P(n)\n        # P(n) = product_{p=n} (1 - 1/p)\n        P_values = np.zeros(N_max + 1, dtype=np.float64)\n        if N_max = 1:\n            P_values[1] = 1.0\n        \n        for n in range(2, N_max + 1):\n            P_values[n] = P_values[n-1]\n            if is_prime[n]:\n                P_values[n] *= (1.0 - 1.0 / n)\n\n    results = []\n    # Process each test case\n    for N, mode in test_cases:\n        # Task 2: Monotonicity test of P(n)\n        is_non_increasing = True\n        tolerance = 1e-12  # Numerical tolerance for float comparison\n        for n in range(2, N + 1):\n            if P_values[n]  P_values[n-1] + tolerance:\n                is_non_increasing = False\n                break\n        \n        # Task 3: Near-constancy metric R(S)\n        sample_set = np.array([], dtype=int)\n        if mode == \"integers\":\n            if N = 2:\n                sample_set = np.arange(2, N + 1)\n        elif mode == \"primes\":\n            # Filter pre-computed primes to include only those = N\n            sample_set = prime_numbers[prime_numbers = N]\n        \n        r_metric = 0.0\n        if sample_set.size  0:\n            # Calculate L(x) = log(x) * P(x) for x in the sample set.\n            # For integer x in sample set, P(x) = P_values[x].\n            L_values = np.log(sample_set) * P_values[sample_set]\n            \n            if L_values.size  0:\n                L_median = np.median(L_values)\n                if L_median  0:\n                    L_max = np.max(L_values)\n                    L_min = np.min(L_values)\n                    r_metric = (L_max - L_min) / L_median\n        \n        results.append([is_non_increasing, r_metric])\n\n    # Final print statement in the exact required format.\n    # Format: [[b1,r1],[b2,r2],...] with no spaces inside inner lists.\n    inner_strings = [f\"[{b},{r}]\" for b, r in results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3087061"}, {"introduction": "The constants appearing in Mertens' theorems, such as the Meissel-Mertens constant $B_1$ and the Euler-Mascheroni constant $\\gamma$, are not disconnected curiosities; they are linked through a beautiful underlying structure. This final exercise guides you to numerically verify the profound identity $C - B_1 = -\\gamma$, where $C$ is a related constant arising from the error terms in the logarithmic approximation. Successfully completing this computational challenge provides strong evidence for the deep coherence of the theory and demonstrates how different aspects of prime number distribution are elegantly intertwined [@problem_id:3087073].", "problem": "You are to write a complete program that numerically evaluates the convergent series for a prime-dependent constant and verifies a Mertens-identity within a prescribed numerical tolerance. Work in purely mathematical terms with natural logarithms. All mathematical notation must be interpreted in the standard sense of number theory. No physical units are involved.\n\nDefinitions and fundamental bases:\n- Let $\\mathbb{P}$ denote the set of prime numbers.\n- Define the constant\n$$\nC \\;=\\; -\\sum_{p \\in \\mathbb{P}} \\sum_{k \\ge 2} \\frac{1}{k\\,p^k}.\n$$\n- The Meissel–Mertens constant $B_{1}$ is defined by the limit in Mertens' second theorem:\n$$\n\\sum_{p \\le x} \\frac{1}{p} \\;=\\; \\log \\log x \\;+\\; B_{1} \\;+\\; o(1) \\quad \\text{as } x \\to \\infty.\n$$\n- The Euler–Mascheroni constant $\\gamma$ is the constant appearing in Mertens' third theorem:\n$$\n\\prod_{p \\le x} \\left(1 - \\frac{1}{p}\\right) \\;\\sim\\; \\frac{e^{-\\gamma}}{\\log x} \\quad \\text{as } x \\to \\infty,\n$$\nequivalently,\n$$\n\\sum_{p \\le x} \\log\\!\\left(1 - \\frac{1}{p}\\right) \\;=\\; -\\log \\log x \\;-\\; \\gamma \\;+\\; o(1).\n$$\n- The power-series identity\n$$\n\\log(1 - z) \\;=\\; -\\sum_{k \\ge 1} \\frac{z^k}{k}, \\quad |z|1,\n$$\nis to be used as a fundamental analytic tool.\n\nTask:\n1) Numerically approximate $C$ using primes up to a cutoff $P_{C}$ by the absolutely convergent reformulation\n$$\nC \\;=\\; \\sum_{p \\in \\mathbb{P}} \\left[\\log\\!\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}\\right],\n$$\nso that a practical approximation is\n$$\nC(P_{C}) \\;=\\; \\sum_{p \\le P_{C}} \\left[\\log\\!\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p}\\right].\n$$\n2) Independently approximate $B_{1}$ using primes up to a cutoff $P_{B}$ via\n$$\nB_{1}(P_{B}) \\;=\\; \\sum_{p \\le P_{B}} \\frac{1}{p} \\;-\\; \\log \\log P_{B}.\n$$\n3) Using the numerical value of the Euler–Mascheroni constant $\\gamma$, verify the identity\n$$\nC \\;-\\; B_{1} \\;=\\; -\\gamma\n$$\nwithin a given absolute tolerance $\\tau$ by checking whether\n$$\n\\left|\\, C(P_{C}) \\;-\\; B_{1}(P_{B}) \\;+\\; \\gamma \\,\\right| \\;\\le\\; \\tau.\n$$\n\nImplementation requirements:\n- Use an efficient prime sieve to enumerate all primes up to $\\max\\{P_{C}, P_{B}\\}$ for each test instance.\n- Use natural logarithms everywhere. For improved numerical stability when evaluating $\\log\\!\\left(1 - \\frac{1}{p}\\right)$, it is acceptable to use the numerically stable transformation $\\log(1 - u) = \\log1p(-u)$ with $u = \\frac{1}{p}$.\n- The final outputs must be integers, with value $1$ if the verification passes the tolerance test and $0$ otherwise.\n\nTest suite:\nRun your program on the following parameter triples $(P_{C}, P_{B}, \\tau)$:\n- Case 1 (small, boundary-like): $(P_{C}, P_{B}, \\tau) = (30000, 400000, 0.05)$.\n- Case 2 (medium): $(P_{C}, P_{B}, \\tau) = (150000, 1500000, 0.02)$.\n- Case 3 (larger): $(P_{C}, P_{B}, \\tau) = (1000000, 5000000, 0.01)$.\n\nFinal output format:\nYour program should produce a single line of output containing the pass-or-fail results for the above cases as a comma-separated list of integers enclosed in square brackets, for example, “[1,0,1]”. Each entry is $1$ if the absolute deviation $\\left|C(P_{C}) - B_{1}(P_{B}) + \\gamma\\right|$ is at most $\\tau$, and $0$ otherwise. No other output should be printed.", "solution": "The identity $C - B_{1} = -\\gamma$ can be established from the definitions given in the problem statement. The asymptotic formulas for Mertens' second and third theorems are:\n$$\n\\sum_{p \\le x} \\frac{1}{p} = \\log \\log x + B_{1} + o(1)\n$$\n$$\n\\sum_{p \\le x} \\log\\left(1 - \\frac{1}{p}\\right) = -\\log \\log x - \\gamma + o(1)\n$$\nSumming these two relations term by term yields:\n$$\n\\sum_{p \\le x} \\left[ \\log\\left(1 - \\frac{1}{p}\\right) + \\frac{1}{p} \\right] = (\\log \\log x + B_{1}) + (-\\log \\log x - \\gamma) + o(1) = B_{1} - \\gamma + o(1)\n$$\nAs $x \\to \\infty$, the left-hand side converges to the constant $C$ (as given by the problem's alternate definition for $C$). Thus, we have the exact identity $C = B_1 - \\gamma$, which rearranges to $C - B_1 + \\gamma = 0$.\n\nThe provided Python solution numerically verifies this identity by approximating the left-hand side and checking if its absolute value is within a given tolerance $\\tau$.\n\n**Algorithm Steps:**\n1.  **Prime Generation:** An efficient prime sieve (Sieve of Eratosthenes) is used to generate all prime numbers up to the maximum cutoff required by any test case. This is done once to optimize performance.\n2.  **Approximation of C:** For each test case $(P_C, P_B, \\tau)$, the approximation $C(P_C)$ is calculated by summing the expression $\\log(1 - 1/p) + 1/p$ over all primes $p \\le P_C$. The numerically stable `numpy.log1p` function is used.\n3.  **Approximation of $B_1$:** The approximation $B_1(P_B)$ is calculated by summing the reciprocals $1/p$ for all primes $p \\le P_B$ and then subtracting $\\log \\log P_B$.\n4.  **Verification:** The Euler–Mascheroni constant $\\gamma$ is retrieved from `numpy.euler_gamma`. The absolute deviation $\\Delta = |C(P_C) - B_1(P_B) + \\gamma|$ is computed. The result for the test case is 1 if $\\Delta \\le \\tau$ and 0 otherwise.\n5.  **Output Generation:** The results are collected and formatted into the required comma-separated list. Vectorized computations with `numpy` are used throughout for efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically verifies the identity C - B_1 = -gamma related to Mertens' theorems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (P_C, P_B, tau)\n        (30000, 400000, 0.05),\n        (150000, 1500000, 0.02),\n        (1000000, 5000000, 0.01),\n    ]\n\n    def sieve_of_eratosthenes(n):\n        \"\"\"\n        Generates prime numbers up to n using the Sieve of Eratosthenes.\n        \n        Args:\n            n (int): The upper limit for prime generation.\n            \n        Returns:\n            np.ndarray: A NumPy array of prime numbers.\n        \"\"\"\n        is_prime = np.ones(n + 1, dtype=bool)\n        is_prime[0:2] = False\n        for i in range(2, int(np.sqrt(n)) + 1):\n            if is_prime[i]:\n                is_prime[i*i::i] = False\n        return np.where(is_prime)[0]\n\n    # Determine the maximum prime needed across all test cases and sieve once.\n    max_p_overall = 0\n    if test_cases:\n        max_p_overall = max(max(case[0], case[1]) for case in test_cases)\n    \n    all_primes = sieve_of_eratosthenes(max_p_overall)\n    \n    # Retrieve the value of the Euler–Mascheroni constant.\n    gamma = np.euler_gamma\n\n    results = []\n    for p_c, p_b, tau in test_cases:\n        # C(P_C) calculation\n        # Filter primes up to the cutoff P_C\n        primes_c = all_primes[all_primes = p_c]\n        inv_p_c = 1.0 / primes_c\n        # Calculate C(P_C) using the numerically stable log1p function\n        c_approx = np.sum(np.log1p(-inv_p_c) + inv_p_c)\n\n        # B_1(P_B) calculation\n        # Filter primes up to the cutoff P_B\n        primes_b = all_primes[all_primes = p_b]\n        inv_p_b = 1.0 / primes_b\n        sum_inv_p_b = np.sum(inv_p_b)\n        # Calculate B_1(P_B)\n        b1_approx = sum_inv_p_b - np.log(np.log(p_b))\n\n        # Verification step\n        # Calculate the absolute deviation from the expected identity C - B_1 + gamma = 0\n        deviation = abs(c_approx - b1_approx + gamma)\n        \n        # Check if the deviation is within the specified tolerance\n        if deviation = tau:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3087073"}]}