{"hands_on_practices": [{"introduction": "Christoffel symbols are not just abstract mathematical objects; they have a direct physical interpretation. They quantify how the basis vectors change from point to point, and this appears in the geodesic equation as a term accounting for the curvature of spacetime. This introductory exercise [@problem_id:1535623] strips away the complexity of higher dimensions to reveal this core concept in a simple one-dimensional setting, allowing you to see how the geometry itself dictates a particle's \"acceleration\" along the straightest possible path.", "problem": "Consider a particle moving in a one-dimensional space described by a single coordinate $x$. The geometry of this space is defined by the metric with line element $ds^2 = x^2 (dx)^2$, for $x > 0$. The particle is unconstrained and moves along a geodesic path, which is parameterized by an affine parameter $\\lambda$. The particle's \"velocity\" with respect to this parameter is denoted by $v = \\frac{dx}{d\\lambda}$.\n\nDetermine the particle's \"acceleration\", $\\frac{d^2x}{d\\lambda^2}$, as an analytic expression in terms of its position $x$ and velocity $v$.", "solution": "For a one-dimensional manifold with metric $g_{xx} = x^{2}$, the geodesic equation for an affine parameter $\\lambda$ is\n$$\n\\frac{d^{2}x}{d\\lambda^{2}} + \\Gamma^{x}_{xx} \\left(\\frac{dx}{d\\lambda}\\right)^{2} = 0.\n$$\nThe Christoffel symbol is computed from\n$$\n\\Gamma^{x}_{xx} = \\frac{1}{2} g^{xx} \\partial_{x} g_{xx},\n$$\nwith $g_{xx} = x^{2}$ and $g^{xx} = \\frac{1}{x^{2}}$. Thus\n$$\n\\partial_{x} g_{xx} = 2x,\\quad \\Gamma^{x}_{xx} = \\frac{1}{2} \\cdot \\frac{1}{x^{2}} \\cdot 2x = \\frac{1}{x}.\n$$\nSubstituting into the geodesic equation and denoting $v = \\frac{dx}{d\\lambda}$ gives\n$$\n\\frac{d^{2}x}{d\\lambda^{2}} + \\frac{1}{x} v^{2} = 0,\n$$\nso the acceleration is\n$$\n\\frac{d^{2}x}{d\\lambda^{2}} = -\\frac{v^{2}}{x}.\n$$\nThis result can also be confirmed from the Euler-Lagrange equation with Lagrangian $L = \\frac{1}{2} x^{2} \\left(\\frac{dx}{d\\lambda}\\right)^{2}$.", "answer": "$$\\boxed{-\\frac{v^{2}}{x}}$$", "id": "1535623"}, {"introduction": "The ability to compute Christoffel symbols from a given metric is a foundational skill in geometric analysis and general relativity. The Koszul formula provides the explicit recipe for this calculation, directly connecting the metric tensor and its derivatives to the connection coefficients. This practice problem [@problem_id:3071021] provides a crucial workout, guiding you through the systematic application of the formula for a non-trivial two-dimensional metric that represents a space of constant negative curvature.", "problem": "Let $(\\mathbb{R}^{2},g)$ be a smooth Riemannian manifold with global coordinates $(x,y)$ and metric $g$ specified by $g = dx^{2} + e^{2x} dy^{2}$. The Levi-Civita connection is characterized by being torsion-free and metric-compatible. Using these defining properties as the fundamental base, and applying the standard derivation that yields the Koszul formula, determine the connection coefficients (Christoffel symbols) of the Levi-Civita connection in the coordinate basis $\\{\\partial_{x},\\partial_{y}\\}$ for this metric. Specifically, identify which $\\Gamma^{k}_{ij}$ are nonzero and compute their explicit expressions as functions of $x$.\n\nFor automatic checking, present your final answer as a single row matrix containing the eight entries in the exact order\n$$(\\Gamma^{x}_{xx},\\Gamma^{x}_{xy},\\Gamma^{x}_{yx},\\Gamma^{x}_{yy},\\Gamma^{y}_{xx},\\Gamma^{y}_{xy},\\Gamma^{y}_{yx},\\Gamma^{y}_{yy}).$$\nYour answer must be a single closed-form analytic expression. Do not include any units. No rounding is required.", "solution": "The problem asks for the determination of the Christoffel symbols (connection coefficients) $\\Gamma^{k}_{ij}$ for the Levi-Civita connection on the Riemannian manifold $(\\mathbb{R}^{2},g)$ with the metric $g = dx^{2} + e^{2x} dy^{2}$. The calculation must be based on the fundamental properties of the Levi-Civita connection, namely that it is torsion-free and metric-compatible, which give rise to the Koszul formula.\n\nFirst, we identify the components of the metric tensor $g_{ij}$ and its inverse $g^{ij}$ in the coordinate system $(x^1, x^2) = (x, y)$. The basis vectors are $\\partial_1 = \\partial_x$ and $\\partial_2 = \\partial_y$. The line element is given by $ds^2 = g_{ij} dx^i dx^j$.\nFrom the expression $g = dx^{2} + e^{2x} dy^{2}$, we have:\n$$\ng_{11} = g_{xx} = 1\n$$\n$$\ng_{12} = g_{21} = g_{xy} = g_{yx} = 0\n$$\n$$\ng_{22} = g_{yy} = e^{2x}\n$$\nThe matrix representation of the metric tensor is:\n$$\n[g_{ij}] = \\begin{pmatrix} 1 & 0 \\\\ 0 & e^{2x} \\end{pmatrix}\n$$\nThe inverse metric tensor, $[g^{ij}]$, is the matrix inverse of $[g_{ij}]$:\n$$\n[g^{ij}] = [g_{ij}]^{-1} = \\begin{pmatrix} 1 & 0 \\\\ 0 & e^{-2x} \\end{pmatrix}\n$$\nSo, the components of the inverse metric are:\n$$\ng^{11} = g^{xx} = 1\n$$\n$$\ng^{12} = g^{21} = g^{xy} = g^{yx} = 0\n$$\n$$\ng^{22} = g^{yy} = e^{-2x}\n$$\n\nThe Levi-Civita connection is uniquely defined by two conditions:\n$1$. It is torsion-free, meaning $\\nabla_X Y - \\nabla_Y X - [X, Y] = 0$, which implies the symmetry of the lower indices of the Christoffel symbols: $\\Gamma^{k}_{ij} = \\Gamma^{k}_{ji}$.\n$2$. It is metric-compatible, meaning $\\nabla g = 0$, which can be written as $(\\nabla_X g)(Y, Z) = X(g(Y, Z)) - g(\\nabla_X Y, Z) - g(Y, \\nabla_X Z) = 0$.\n\nThese two conditions lead to the Koszul formula for the connection coefficients:\n$$\n\\Gamma^{k}_{ij} = \\frac{1}{2} g^{kl} \\left( \\frac{\\partial g_{jl}}{\\partial x^i} + \\frac{\\partial g_{il}}{\\partial x^j} - \\frac{\\partial g_{ij}}{\\partial x^l} \\right)\n$$\nHere, we use the summation convention over the repeated index $l$, and $(x^1, x^2)=(x,y)$.\n\nNext, we compute the partial derivatives of the metric components $g_{ij}$. Since $g_{11}=1$ and $g_{12}=g_{21}=0$ are constants, their derivatives are zero. The only non-constant component is $g_{22} = e^{2x}$.\nThe required derivatives are:\n$$\n\\frac{\\partial g_{11}}{\\partial x^k} = 0 \\text{ for } k=1, 2\n$$\n$$\n\\frac{\\partial g_{12}}{\\partial x^k} = 0 \\text{ for } k=1, 2\n$$\n$$\n\\frac{\\partial g_{22}}{\\partial x^1} = \\frac{\\partial (e^{2x})}{\\partial x} = 2e^{2x}\n$$\n$$\n\\frac{\\partial g_{22}}{\\partial x^2} = \\frac{\\partial (e^{2x})}{\\partial y} = 0\n$$\nThe sole non-zero partial derivative of a metric component is $\\frac{\\partial g_{22}}{\\partial x^1}$.\n\nNow we can compute the Christoffel symbols $\\Gamma^{k}_{ij}$. Due to the symmetry $\\Gamma^{k}_{ij} = \\Gamma^{k}_{ji}$, we only need to compute for $i \\leq j$.\n\nCase $k=1$ (or $k=x$):\n$$\n\\Gamma^{1}_{ij} = \\frac{1}{2} g^{1l} \\left( \\frac{\\partial g_{jl}}{\\partial x^i} + \\frac{\\partial g_{il}}{\\partial x^j} - \\frac{\\partial g_{ij}}{\\partial x^l} \\right) = \\frac{1}{2} g^{11} \\left( \\frac{\\partial g_{j1}}{\\partial x^i} + \\frac{\\partial g_{i1}}{\\partial x^j} - \\frac{\\partial g_{ij}}{\\partial x^1} \\right)\n$$\nsince $g^{12}=0$.\n\n$\\Gamma^{x}_{xx} = \\Gamma^{1}_{11} = \\frac{1}{2} g^{11} \\left( \\frac{\\partial g_{11}}{\\partial x^1} + \\frac{\\partial g_{11}}{\\partial x^1} - \\frac{\\partial g_{11}}{\\partial x^1} \\right) = \\frac{1}{2}(1)\\left(\\frac{\\partial(1)}{\\partial x}\\right) = 0$.\n\n$\\Gamma^{x}_{xy} = \\Gamma^{1}_{12} = \\frac{1}{2} g^{11} \\left( \\frac{\\partial g_{21}}{\\partial x^1} + \\frac{\\partial g_{11}}{\\partial x^2} - \\frac{\\partial g_{12}}{\\partial x^1} \\right) = \\frac{1}{2}(1)(0 + 0 - 0) = 0$. By symmetry, $\\Gamma^{x}_{yx} = \\Gamma^{1}_{21} = 0$.\n\n$\\Gamma^{x}_{yy} = \\Gamma^{1}_{22} = \\frac{1}{2} g^{11} \\left( \\frac{\\partial g_{21}}{\\partial x^2} + \\frac{\\partial g_{21}}{\\partial x^2} - \\frac{\\partial g_{22}}{\\partial x^1} \\right) = \\frac{1}{2}(1)\\left( 0 + 0 - \\frac{\\partial g_{22}}{\\partial x^1} \\right) = -\\frac{1}{2}(2e^{2x}) = -e^{2x}$.\n\nCase $k=2$ (or $k=y$):\n$$\n\\Gamma^{2}_{ij} = \\frac{1}{2} g^{2l} \\left( \\frac{\\partial g_{jl}}{\\partial x^i} + \\frac{\\partial g_{il}}{\\partial x^j} - \\frac{\\partial g_{ij}}{\\partial x^l} \\right) = \\frac{1}{2} g^{22} \\left( \\frac{\\partial g_{j2}}{\\partial x^i} + \\frac{\\partial g_{i2}}{\\partial x^j} - \\frac{\\partial g_{ij}}{\\partial x^2} \\right)\n$$\nsince $g^{21}=0$.\n\n$\\Gamma^{y}_{xx} = \\Gamma^{2}_{11} = \\frac{1}{2} g^{22} \\left( \\frac{\\partial g_{12}}{\\partial x^1} + \\frac{\\partial g_{12}}{\\partial x^1} - \\frac{\\partial g_{11}}{\\partial x^2} \\right) = \\frac{1}{2}e^{-2x}(0 + 0 - 0) = 0$.\n\n$\\Gamma^{y}_{xy} = \\Gamma^{2}_{12} = \\frac{1}{2} g^{22} \\left( \\frac{\\partial g_{22}}{\\partial x^1} + \\frac{\\partial g_{12}}{\\partial x^2} - \\frac{\\partial g_{12}}{\\partial x^2} \\right) = \\frac{1}{2}e^{-2x}\\left(\\frac{\\partial g_{22}}{\\partial x^1}\\right) = \\frac{1}{2}e^{-2x}(2e^{2x}) = 1$. By symmetry, $\\Gamma^{y}_{yx} = \\Gamma^{2}_{21} = 1$.\n\n$\\Gamma^{y}_{yy} = \\Gamma^{2}_{22} = \\frac{1}{2} g^{22} \\left( \\frac{\\partial g_{22}}{\\partial x^2} + \\frac{\\partial g_{22}}{\\partial x^2} - \\frac{\\partial g_{22}}{\\partial x^2} \\right) = \\frac{1}{2}e^{-2x}\\left(\\frac{\\partial g_{22}}{\\partial x^2}\\right) = \\frac{1}{2}e^{-2x}(0) = 0$.\n\nIn summary, the non-zero Christoffel symbols are:\n$$\n\\Gamma^{x}_{yy} = -e^{2x}\n$$\n$$\n\\Gamma^{y}_{xy} = \\Gamma^{y}_{yx} = 1\n$$\nAll other symbols $\\Gamma^{k}_{ij}$ are zero.\n\nWe assemble the answer as a row matrix in the specified order:\n$(\\Gamma^{x}_{xx}, \\Gamma^{x}_{xy}, \\Gamma^{x}_{yx}, \\Gamma^{x}_{yy}, \\Gamma^{y}_{xx}, \\Gamma^{y}_{xy}, \\Gamma^{y}_{yx}, \\Gamma^{y}_{yy})$.\nSubstituting the calculated values yields:\n$(0, 0, 0, -e^{2x}, 0, 1, 1, 0)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & 0 & 0 & -e^{2x} & 0 & 1 & 1 & 0\n\\end{pmatrix}\n}\n$$", "id": "3071021"}, {"introduction": "While analytical calculations are essential for building understanding, many modern applications in physics and engineering rely on numerical methods to handle complex geometries. This advanced practice [@problem_id:3042876] challenges you to bridge the gap between abstract theory and computational practice. By implementing the Koszul formula and the geodesic equation using numerical differentiation, you will translate the formal mathematics into a concrete algorithm, gaining insight into how these concepts are applied in simulations and real-world problem-solving.", "problem": "You are to implement a numerical procedure to approximate the Christoffel symbols of the Levi-Civita connection at a point for a given smooth Riemannian metric on a $2$-dimensional manifold, and then use these symbols to compute the geodesic acceleration at that point for a given tangent vector. The aim is to work from first principles and numerically approximate the required partial derivatives of the metric using finite differences.\n\nFundamental base for derivation: The Levi-Civita connection is the unique torsion-free, metric-compatible affine connection associated with a Riemannian metric. Using these defining properties, derive the expression for the connection coefficients in local coordinates and implement a numerical approximation of the metric derivatives needed to evaluate them.\n\nAlgorithmic requirements:\n- Work in local coordinates $x^{1}, x^{2}$ on a $2$-dimensional manifold and let $g_{ij}(x^{1}, x^{2})$ denote the components of the metric tensor at the point $(x^{1}, x^{2})$, which form a symmetric positive-definite matrix.\n- Approximate the partial derivatives $\\partial_{k} g_{ij}$ at a point $(x^{1}, x^{2})$ by second-order accurate central differences on a uniform grid with step size $h$:\n$$\n\\partial_{k} g_{ij}(x^{1}, x^{2}) \\approx \\frac{g_{ij}(x^{1}, \\ldots, x^{k} + h, \\ldots) - g_{ij}(x^{1}, \\ldots, x^{k} - h, \\ldots)}{2 h}.\n$$\n- Using the derived expression for the Levi-Civita connection coefficients in terms of $g_{ij}$, its inverse $g^{ij}$, and the partial derivatives $\\partial_{k} g_{ij}$, compute the Christoffel symbols $\\Gamma^{k}_{\\; ij}$ at the given point.\n- Given a tangent vector $v = (v^{1}, v^{2})$ at the point, compute the geodesic acceleration components $a^{k}$ in coordinates:\n$$\na^{k} = - \\sum_{i=1}^{2} \\sum_{j=1}^{2} \\Gamma^{k}_{\\; ij} \\, v^{i} \\, v^{j}.\n$$\n\nInput-free program: Your program must implement the described procedure for each of the specified test cases below without requiring any user input and print the results in the exact final output format.\n\nAngle unit specification: For any test case using polar coordinates, interpret angles in radians.\n\nTest suite:\n- Case $1$ (flat Euclidean metric):\n  - Metric: $g(x^{1}, x^{2}) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$.\n  - Point: $(x^{1}, x^{2}) = (0.3, -0.7)$.\n  - Step size: $h = 10^{-3}$.\n  - Tangent vector: $v = (1.2, -0.5)$.\n\n- Case $2$ (polar plane metric in $(r, \\theta)$ with $\\theta$ in radians):\n  - Metric: $g(r, \\theta) = \\mathrm{diag}(1, r^{2})$ where $r = x^{1}$ and $\\theta = x^{2}$.\n  - Point: $(r, \\theta) = (2.0, 1.0)$.\n  - Step size: $h = 10^{-4}$.\n  - Tangent vector: $v = (0.5, 1.2)$.\n\n- Case $3$ (smooth anisotropic curved metric):\n  - Metric: $g(x^{1}, x^{2}) = \\begin{pmatrix} 1 + (x^{1})^{2} & x^{1} x^{2} \\\\ x^{1} x^{2} & 1 + (x^{2})^{2} \\end{pmatrix}$.\n  - Point: $(x^{1}, x^{2}) = (0.2, -0.3)$.\n  - Step size: $h = 10^{-3}$.\n  - Tangent vector: $v = (0.7, -1.1)$.\n\n- Case $4$ (boundary-step sensitivity for the same anisotropic metric):\n  - Metric: $g(x^{1}, x^{2}) = \\begin{pmatrix} 1 + (x^{1})^{2} & x^{1} x^{2} \\\\ x^{1} x^{2} & 1 + (x^{2})^{2} \\end{pmatrix}$.\n  - Point: $(x^{1}, x^{2}) = (0.2, -0.3)$.\n  - Step size: $h = 10^{-6}$.\n  - Tangent vector: $v = (0.7, -1.1)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, where each item is the ordered pair of geodesic acceleration components $[a^{1}, a^{2}]$ for that case.\n- Express each component as a floating-point number rounded to $8$ decimal places.\n- For example, a valid output format looks like\n$$\n\\text{[[0.00000000,0.00000000],[2.88000000,-0.60000000],[\\ldots,\\ldots],[\\ldots,\\ldots]]}.\n$$", "solution": "The problem requires the numerical computation of Christoffel symbols and geodesic acceleration on a $2$-dimensional Riemannian manifold. The procedure is grounded in the fundamental principles of differential geometry, which we shall first establish before outlining the numerical algorithm.\n\n### Theoretical Foundation: The Levi-Civita Connection\n\nA connection on the tangent bundle of a manifold provides a way to differentiate vector fields. The Levi-Civita connection is the unique connection associated with a Riemannian metric $g$ that satisfies two crucial properties:\n\n1.  **Metric Compatibility**: The connection preserves the metric under parallel transport. In local coordinates $(x^1, \\dots, x^n)$, this condition is expressed as the covariant derivative of the metric tensor being zero: $\\nabla_k g_{ij} = 0$. Using the definition of the covariant derivative for a rank-2 tensor, this translates to:\n    $$ \\partial_k g_{ij} - \\sum_{l=1}^n \\Gamma^l_{ki} g_{lj} - \\sum_{l=1}^n \\Gamma^l_{kj} g_{il} = 0 $$\n    where $\\partial_k = \\frac{\\partial}{\\partial x^k}$ and $\\Gamma^l_{ij}$ are the connection coefficients, known as Christoffel symbols of the second kind.\n\n2.  **Torsion-Free**: The connection is symmetric. This means that for any vector fields $X$ and $Y$, $\\nabla_X Y - \\nabla_Y X = [X,Y]$. In local coordinates, this simplifies to the symmetry of the lower indices of the Christoffel symbols:\n    $$ \\Gamma^k_{ij} = \\Gamma^k_{ji} $$\n\nThese two conditions uniquely determine the Christoffel symbols in terms of the metric tensor and its partial derivatives. To derive this relationship, we write the metric compatibility condition three times with permuted indices:\n1.  $\\partial_i g_{jk} = \\sum_{l=1}^n (\\Gamma^l_{ij} g_{lk} + \\Gamma^l_{ik} g_{jl})$\n2.  $\\partial_j g_{ik} = \\sum_{l=1}^n (\\Gamma^l_{ji} g_{lk} + \\Gamma^l_{jk} g_{il})$\n3.  $\\partial_k g_{ij} = \\sum_{l=1}^n (\\Gamma^l_{ki} g_{lj} + \\Gamma^l_{kj} g_{il})$\n\nUsing the symmetry $\\Gamma^l_{ij} = \\Gamma^l_{ji}$, we can combine these. We compute $(1) + (2) - (3)$:\n$$ \\partial_i g_{jk} + \\partial_j g_{ik} - \\partial_k g_{ij} = 2 \\sum_{l=1}^n \\Gamma^l_{ij} g_{lk} $$\nThis quantity is known as the Christoffel symbol of the first kind, $\\Gamma_{kij} = \\sum_{l=1}^n g_{kl} \\Gamma^l_{ij}$. Thus:\n$$ \\Gamma_{kij} = \\frac{1}{2} (\\partial_i g_{jk} + \\partial_j g_{ik} - \\partial_k g_{ij}) $$\nTo find the Christoffel symbols of the second kind, $\\Gamma^k_{ij}$, we contract with the inverse metric tensor $g^{mk}$ (where $\\sum_{k=1}^n g^{mk} g_{kl} = \\delta^m_l$):\n$$ \\Gamma^m_{ij} = \\sum_{k=1}^n g^{mk} \\Gamma_{kij} $$\nSubstituting the expression for $\\Gamma_{kij}$ gives the Koszul formula, which is the basis for our computation. Relabeling the indices to match the problem statement ($m \\to k$, $k \\to l$):\n$$ \\Gamma^{k}_{ij} = \\frac{1}{2} \\sum_{l=1}^{2} g^{kl} (\\partial_i g_{jl} + \\partial_j g_{il} - \\partial_l g_{ij}) $$\nThis formula is valid in any local coordinate system for the Levi-Civita connection.\n\n### Geodesic Equation and Acceleration\n\nA geodesic is a curve whose tangent vector is parallel along itself. In local coordinates, a curve $\\gamma(t) = (x^1(t), x^2(t))$ is a geodesic if its tangent vector $v^i = \\frac{dx^i}{dt}$ satisfies the geodesic equation:\n$$ \\frac{d^2 x^k}{dt^2} + \\sum_{i=1}^2 \\sum_{j=1}^2 \\Gamma^k_{ij}(x(t)) \\frac{dx^i}{dt} \\frac{dx^j}{dt} = 0 $$\nThe term $\\frac{d^2 x^k}{dt^2}$ is the coordinate acceleration of the curve. The geodesic acceleration, which is the acceleration required to deviate from a geodesic path, is therefore defined as the negative of the second term:\n$$ a^k = - \\sum_{i=1}^{2} \\sum_{j=1}^{2} \\Gamma^{k}_{ij} v^{i} v^{j} $$\nThis is the quantity we must compute.\n\n### Numerical Implementation\n\nThe overall procedure consists of the following steps:\n\n1.  **Metric Definition**: For each test case, the metric tensor components $g_{ij}(x^1, x^2)$ are given as a function of the coordinates.\n\n2.  **Numerical Differentiation**: The partial derivatives $\\partial_k g_{ij}$ at a point $P=(p^1, p^2)$ are required. These are approximated using a second-order central finite difference scheme with a step size $h$:\n    $$ \\partial_1 g_{ij}(P) \\approx \\frac{g_{ij}(p^1+h, p^2) - g_{ij}(p^1-h, p^2)}{2h} $$\n    $$ \\partial_2 g_{ij}(P) \\approx \\frac{g_{ij}(p^1, p^2+h) - g_{ij}(p^1, p^2-h)}{2h} $$\n    This must be done for each component $g_{11}, g_{12}, g_{21}, g_{22}$.\n\n3.  **Inverse Metric**: The metric tensor $g_{ij}$ is evaluated at the point $P$. Its inverse, $g^{ij}$, is then computed. For a $2 \\times 2$ matrix $g = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$, the inverse is $g^{-1} = \\frac{1}{ad-bc} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}$.\n\n4.  **Christoffel Symbols Calculation**: Using the numerically computed derivatives $\\partial_k g_{ij}$ and the inverse metric $g^{kl}$, the $2^3=8$ Christoffel symbol components $\\Gamma^k_{ij}$ are calculated at point $P$ using the Koszul formula derived above.\n\n5.  **Geodesic Acceleration Calculation**: Finally, given a tangent vector $v=(v^1, v^2)$, the components of the geodesic acceleration $a^k$ are computed by contracting the Christoffel symbols with the tangent vector components according to the formula $a^k = - \\sum_{i,j} \\Gamma^k_{ij} v^i v^j$.\n\nThis procedure is applied to each of the four test cases specified. It is noteworthy that for Case 1 (Euclidean metric) all derivatives are zero, leading to zero Christoffel symbols and zero acceleration, which serves as a basic sanity check. For Case 2 (polar coordinates), the results can be verified against the well-known analytical expressions. For Cases 3 and 4, the metric components are polynomials of degree at most two, which means the second-order central difference formula for the first derivatives will be exact, irrespective of the step size $h$. Therefore, the results for Case 3 and Case 4 are expected to be identical up to floating-point precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It defines the test cases, computes the geodesic acceleration for each,\n    and prints the results in the required format.\n    \"\"\"\n\n    def compute_acceleration(metric_func, point, h, v):\n        \"\"\"\n        Computes the geodesic acceleration at a point for a given metric.\n\n        Args:\n            metric_func (callable): A function that takes a point (list/array of 2 floats)\n                                    and returns the 2x2 metric tensor g_ij as a numpy array.\n            point (np.ndarray): The (x^1, x^2) coordinates of the point of interest.\n            h (float): The step size for the finite difference approximation.\n            v (np.ndarray): The tangent vector (v^1, v^2) at the point.\n\n        Returns:\n            np.ndarray: The components of the geodesic acceleration (a^1, a^2).\n        \"\"\"\n        # Dimension of the manifold\n        dim = 2\n\n        # 1. Numerical Differentiation\n        # dg[k, i, j] will store partial_k g_ij\n        dg = np.zeros((dim, dim, dim))\n\n        for k in range(dim):\n            # Create points for central difference along the k-th coordinate\n            point_plus_h = point.copy()\n            point_minus_h = point.copy()\n            point_plus_h[k] += h\n            point_minus_h[k] -= h\n\n            # Compute metric at these points\n            g_plus = metric_func(point_plus_h)\n            g_minus = metric_func(point_minus_h)\n\n            # Central difference formula for partial_k g_ij\n            dg[k, :, :] = (g_plus - g_minus) / (2 * h)\n\n        # 2. Inverse Metric\n        # Compute the metric and its inverse at the point of interest\n        g = metric_func(point)\n        g_inv = np.linalg.inv(g)\n\n        # 3. Christoffel Symbols Calculation\n        # Gamma[k, i, j] stores Gamma^k_ij\n        # Formula: Gamma^k_ij = (1/2) * g^{kl} * (d_i g_{jl} + d_j g_{il} - d_l g_{ij})\n        # Using numpy.einsum for efficient tensor contraction\n        \n        # Term 1: g^{kl} * d_i g_{jl} -> maps to einsum('kl,ijl->kij', g_inv, dg)\n        term1 = np.einsum('kl,ijl->kij', g_inv, dg)\n        \n        # Term 2: g^{kl} * d_j g_{il} -> maps to einsum('kl,jil->kij', g_inv, dg)\n        term2 = np.einsum('kl,jil->kij', g_inv, dg)\n\n        # Term 3: g^{kl} * d_l g_{ij} -> maps to einsum('kl,lij->kij', g_inv, dg)\n        term3 = np.einsum('kl,lij->kij', g_inv, dg)\n\n        Gamma = 0.5 * (term1 + term2 - term3)\n\n        # 4. Geodesic Acceleration Calculation\n        # a^k = -Gamma^k_{ij} * v^i * v^j\n        a = -np.einsum('kij,i,j->k', Gamma, v, v)\n\n        return a\n\n    # --- Test Cases ---\n\n    # Case 1: Flat Euclidean metric\n    def metric_case1(p):\n        return np.array([[1.0, 0.0], [0.0, 1.0]])\n\n    # Case 2: Polar plane metric\n    def metric_case2(p):\n        r = p[0]\n        # Metric is undefined at r=0, but test point is away from it.\n        if r <= 0:\n            # Return a non-singular value to avoid issues if h is too large,\n            # though for given test cases this is not an issue.\n            return np.identity(2)\n        return np.array([[1.0, 0.0], [0.0, r**2]])\n\n    # Case 3 & 4: Smooth anisotropic curved metric\n    def metric_case3_4(p):\n        x1, x2 = p[0], p[1]\n        return np.array([[1 + x1**2, x1 * x2], [x1 * x2, 1 + x2**2]])\n\n    test_cases = [\n        {'metric_func': metric_case1, 'point': np.array([0.3, -0.7]), 'h': 1e-3, 'v': np.array([1.2, -0.5])},\n        {'metric_func': metric_case2, 'point': np.array([2.0, 1.0]), 'h': 1e-4, 'v': np.array([0.5, 1.2])},\n        {'metric_func': metric_case3_4, 'point': np.array([0.2, -0.3]), 'h': 1e-3, 'v': np.array([0.7, -1.1])},\n        {'metric_func': metric_case3_4, 'point': np.array([0.2, -0.3]), 'h': 1e-6, 'v': np.array([0.7, -1.1])},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_acceleration(case['metric_func'], case['point'], case['h'], case['v'])\n        results.append(result)\n\n    # Format the output as specified\n    formatted_results = [f\"[{r[0]:.8f},{r[1]:.8f}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3042876"}]}