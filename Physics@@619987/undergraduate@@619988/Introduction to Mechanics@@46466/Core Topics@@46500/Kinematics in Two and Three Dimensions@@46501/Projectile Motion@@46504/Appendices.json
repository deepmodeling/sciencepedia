{"hands_on_practices": [{"introduction": "Mastering projectile motion begins with a solid grasp of the idealized case, where we ignore air resistance. This exercise moves beyond simply calculating flight times or distances for specific scenarios and instead challenges you to explore the intrinsic geometry of the parabolic trajectory by deriving a general relationship between a projectile's maximum height and its horizontal range [@problem_id:2209981]. This practice will sharpen your algebraic skills and deepen your understanding of how launch angle dictates the shape of the flight path.", "problem": "A sports analytics firm is designing a realistic physics engine for a new virtual reality game. A key mechanic in the game involves throwing a ball from ground level with an initial speed $v_0$ at a launch angle $\\theta$ with respect to the horizontal. For a specific in-game challenge, the trajectory of the ball must satisfy a precise aesthetic condition: the total horizontal distance it travels before landing back on the ground (its range, $R$) must be exactly $n$ times its maximum vertical height ($H$). The ball is launched and lands at the same vertical level.\n\nAssuming the acceleration due to gravity is a constant $g$ and that air resistance is negligible, derive an analytical expression for the launch angle $\\theta$ in terms of the dimensionless factor $n$.", "solution": "Let the initial speed be $v_{0}$ and the launch angle be $\\theta$ above the horizontal. Under constant gravitational acceleration $g$ downward and with no air resistance, the projectile’s motion is governed by\n$$\nx(t)=v_{0}\\cos\\theta\\, t,\\qquad y(t)=v_{0}\\sin\\theta\\, t-\\frac{1}{2}gt^{2}.\n$$\nThe time of flight $T$ (returning to the launch height, so $y(T)=0$ with $T>0$) satisfies\n$$\n0=v_{0}\\sin\\theta\\, T-\\frac{1}{2}gT^{2}\\quad\\Rightarrow\\quad T=\\frac{2v_{0}\\sin\\theta}{g}.\n$$\nThe range $R$ is the horizontal displacement at $t=T$:\n$$\nR=x(T)=v_{0}\\cos\\theta\\left(\\frac{2v_{0}\\sin\\theta}{g}\\right)=\\frac{v_{0}^{2}}{g}\\sin(2\\theta).\n$$\nThe maximum height $H$ occurs when the vertical velocity vanishes. The vertical velocity is $v_{y}(t)=v_{0}\\sin\\theta-gt$, so setting $v_{y}(t_{h})=0$ gives\n$$\nt_{h}=\\frac{v_{0}\\sin\\theta}{g}.\n$$\nThus,\n$$\nH=y(t_{h})=v_{0}\\sin\\theta\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)-\\frac{1}{2}g\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)^{2}=\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}.\n$$\nThe condition $R=nH$ yields\n$$\n\\frac{v_{0}^{2}}{g}\\sin(2\\theta)=n\\left(\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}\\right).\n$$\nCanceling the common factor $\\frac{v_{0}^{2}}{g}$ and using $\\sin(2\\theta)=2\\sin\\theta\\cos\\theta$,\n$$\n\\sin(2\\theta)=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n2\\sin\\theta\\cos\\theta=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n4\\cos\\theta=n\\sin\\theta.\n$$\nTherefore,\n$$\n\\cot\\theta=\\frac{n}{4}\\quad\\Rightarrow\\quad \\tan\\theta=\\frac{4}{n}\\quad\\Rightarrow\\quad \\theta=\\arctan\\!\\left(\\frac{4}{n}\\right).\n$$\nFor $n>0$, this yields the unique physically relevant launch angle in the interval $(0,\\frac{\\pi}{2})$.", "answer": "$$\\boxed{\\arctan\\!\\left(\\frac{4}{n}\\right)}$$", "id": "2209981"}, {"introduction": "While the ideal model provides a crucial foundation, real-world trajectories are shaped by forces like air resistance. This next practice introduces a linear drag force, $\\vec{F}_d = -b\\vec{v}$, a first-order correction to our model that makes it more realistic [@problem_id:2210044]. By analyzing a variation of the classic 'monkey and hunter' thought experiment, you will see precisely how drag affects the outcome and develop the essential skill of solving first-order differential equations in a physical context.", "problem": "An engineer is testing a new automated defense system designed to neutralize rogue drones. A small drone is positioned hovering stationary at a horizontal distance $L$ and a vertical height $H$ relative to a projectile launcher located at ground level. The launcher is aimed directly at the drone.\n\nAt time $t=0$, the launcher fires a projectile with an initial speed $v_0$. Simultaneously, the drone's power is cut, and it begins to fall from rest under the influence of gravity.\n\nThe projectile has a mass $m$. It experiences a linear air resistance force given by $\\vec{F}_d = -b\\vec{v}$, where $b$ is a positive drag coefficient and $\\vec{v}$ is the velocity of the projectile. The motion of the falling drone can be modeled as that of a point mass in free fall, so air resistance on the drone itself can be considered negligible. The acceleration due to gravity is a constant, $g$.\n\nThe system is designed to work in a vacuum, where the projectile would hit the drone. Due to the presence of air, the projectile will miss. Determine the vertical distance between the projectile and the drone at the precise moment the projectile reaches the same horizontal position as the drone's initial location. Express your answer as a single closed-form analytic expression in terms of the given parameters: $L, H, v_0, m, b,$ and $g$.", "solution": "Let the launcher be at the origin, with the drone initially at $(L,H)$. The projectile is fired at $t=0$ with speed $v_{0}$ aimed directly at $(L,H)$, so its initial velocity components are\n$$\nv_{0x}=\\frac{v_{0}L}{\\sqrt{L^{2}+H^{2}}},\\qquad v_{0y}=\\frac{v_{0}H}{\\sqrt{L^{2}+H^{2}}}.\n$$\nWith linear drag $\\vec{F}_{d}=-b\\vec{v}$ and gravity $-mg\\,\\hat{y}$, the equations of motion by components are\n$$\nm\\frac{dv_{x}}{dt}=-b\\,v_{x},\\qquad m\\frac{dv_{y}}{dt}=-b\\,v_{y}-mg.\n$$\nDefine the time constant $\\tau=\\frac{m}{b}$. Solving the $x$-motion,\n$$\nv_{x}(t)=v_{0x}\\exp\\!\\left(-\\frac{t}{\\tau}\\right),\\qquad x(t)=v_{0x}\\tau\\left(1-\\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\right).\n$$\nLet $t_{L}$ be the time when the projectile reaches $x=L$. Then\n$$\nL=v_{0x}\\tau\\left(1-\\exp\\!\\left(-\\frac{t_{L}}{\\tau}\\right)\\right)\\;\\Rightarrow\\;\\exp\\!\\left(-\\frac{t_{L}}{\\tau}\\right)=1-\\frac{L}{v_{0x}\\tau},\n$$\nwhich requires $0<\\frac{L}{v_{0x}\\tau}<1$ and yields\n$$\nt_{L}=-\\tau\\,\\ln\\!\\left(1-\\frac{L}{v_{0x}\\tau}\\right).\n$$\nFor the $y$-motion,\n$$\nv_{y}(t)=(v_{0y}+g\\tau)\\exp\\!\\left(-\\frac{t}{\\tau}\\right)-g\\tau,\\qquad\ny_{p}(t)=\\tau(v_{0y}+g\\tau)\\left(1-\\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\right)-g\\tau t,\n$$\nwith $y_{p}(0)=0$. Evaluating at $t_{L}$ and using $1-\\exp(-t_{L}/\\tau)=\\frac{L}{v_{0x}\\tau}$,\n$$\ny_{p}(t_{L})=\\frac{v_{0y}+g\\tau}{v_{0x}}\\,L-g\\tau t_{L}.\n$$\nSince $\\frac{v_{0y}}{v_{0x}}=\\frac{H}{L}$, this becomes\n$$\ny_{p}(t_{L})=H+\\frac{g\\tau L}{v_{0x}}-g\\tau t_{L}.\n$$\nThe drone falls freely from rest, so\n$$\ny_{d}(t)=H-\\frac{1}{2}gt^{2}\\;\\Rightarrow\\;y_{d}(t_{L})=H-\\frac{1}{2}g t_{L}^{2}.\n$$\nThus the vertical separation (distance) at $t_{L}$ is\n$$\nD=\\left|y_{d}(t_{L})-y_{p}(t_{L})\\right|=\\left|-\\frac{1}{2}g t_{L}^{2}-\\frac{g\\tau L}{v_{0x}}+g\\tau t_{L}\\right|.\n$$\nUsing $t_{L}=-\\tau\\ln\\!\\left(1-\\frac{L}{v_{0x}\\tau}\\right)$, this becomes\n$$\nD=\\left|-g\\tau^{2}\\left[\\frac{1}{2}\\left(\\ln\\!\\left(1-\\frac{L}{v_{0x}\\tau}\\right)\\right)^{2}+\\frac{L}{v_{0x}\\tau}+\\ln\\!\\left(1-\\frac{L}{v_{0x}\\tau}\\right)\\right]\\right|.\n$$\nSince $0<\\frac{L}{v_{0x}\\tau}<1$, the bracketed term is positive, so the absolute value removes the minus sign. Noting\n$$\n\\frac{L}{v_{0x}\\tau}=\\frac{\\sqrt{L^{2}+H^{2}}}{v_{0}\\tau}=\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}},\n$$\nand $\\tau=\\frac{m}{b}$, we obtain the closed-form expression\n$$\nD=g\\left(\\frac{m}{b}\\right)^{2}\\left[\\frac{1}{2}\\left(\\ln\\!\\left(1-\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}}\\right)\\right)^{2}+\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}}+\\ln\\!\\left(1-\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}}\\right)\\right],\n$$\nvalid provided $0<\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}}<1$ so that the projectile reaches $x=L$.", "answer": "$$\\boxed{g\\left(\\frac{m}{b}\\right)^{2}\\left[\\frac{1}{2}\\left(\\ln\\!\\left(1-\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}}\\right)\\right)^{2}+\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}}+\\ln\\!\\left(1-\\frac{b\\sqrt{L^{2}+H^{2}}}{m v_{0}}\\right)\\right]}$$", "id": "2210044"}, {"introduction": "Many real-world physics problems, especially those involving non-linear forces like quadratic air resistance, do not have 'clean' analytical solutions. For these, we turn to the power of computational methods. This hands-on exercise guides you through building a program to solve a projectile targeting problem that is analytically intractable [@problem_id:2430429]. By implementing a numerical 'shooting method', you will learn how to find solutions to complex physical systems, a fundamental skill in modern science and engineering.", "problem": "A two-dimensional projectile of mass $m$ is launched from the origin with initial speed $v_0$ at launch angle $\\theta$ measured from the horizontal. The projectile moves under uniform gravitational acceleration $\\mathbf{g} = (0,-g)$ and experiences a quadratic aerodynamic drag force proportional to the square of the speed and opposite to the instantaneous velocity. Model the drag using Newton's second law as follows. Let the state be $\\mathbf{r}(t) = (x(t),y(t))$ and $\\mathbf{v}(t) = (v_x(t),v_y(t))$ with $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$. The equations of motion are\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\nwith initial conditions\n$$\nx(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.\n$$\nThe drag parameter $k$ is defined by\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\nwhere $\\rho$ is the air density, $C_d$ is the drag coefficient, and $A$ is the cross-sectional area.\n\nYour task is to write a complete, runnable program that, for each target point $(x_T,y_T)$, uses a root-finding algorithm to determine all launch angle(s) $\\theta \\in (0,\\tfrac{\\pi}{2})$ (strictly between horizontal and vertical) that cause the projectile to pass the vertical line $x = x_T$ at height $y = y_T$. The root-finding must be applied to a scalar function of the launch angle constructed from first principles as follows.\n\n1. For a given $\\theta$, define the scalar function\n$$\nF(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,\n$$\nwhere $t^\\star(\\theta)$ is the first time (if any) at which $x\\big(t^\\star(\\theta)\\big) = x_T$ during the flight launched at angle $\\theta$ with speed $v_0$. If the projectile never reaches $x_T$ (for example, if it lands with $y=0$ before $x$ reaches $x_T$), then $F(\\theta)$ is undefined and that $\\theta$ should not be used in a bracketing pair for root finding.\n\n2. A valid solution angle $\\theta^\\star$ satisfies $F(\\theta^\\star) = 0$. Your program must systematically search the interval $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$ with $\\theta_{\\min} = 0.1^\\circ$ and $\\theta_{\\max} = 89.9^\\circ$ to detect subintervals where $F(\\theta)$ changes sign, and then apply a one-dimensional root-finding algorithm (for example, a bracketing method) to each detected subinterval to converge to a root.\n\n3. If multiple distinct roots exist, all such angles in $(0^\\circ,90^\\circ)$ must be found and reported. If no root exists, report an empty list for that case.\n\nNumerical requirements and conventions:\n\n- Use the above differential equations and initial conditions as the only physical model; do not substitute any closed-form trajectory formulas.\n- Implement a numerical ordinary differential equation integrator that halts when $x(t)$ first equals $x_T$ (if it occurs) or when the projectile hits the ground $y(t)=0$ while descending. Use tolerances sufficiently tight to reliably detect crossings.\n- Distances must be in meters, time in seconds, mass in kilograms, air density in kilograms per cubic meter, area in square meters, and acceleration in meters per second squared. Angles must be reported in degrees.\n- Report each solution angle in degrees, rounded to three decimal places.\n- A solution angle is acceptable if, at the crossing time $t^\\star$, the value $|y(t^\\star) - y_T|$ is within $10^{-3}$ meters. Your root-finding tolerance should ensure this target accuracy.\n- For reproducibility, use the following fixed physical parameters for all test cases: $m = 0.145$ kilograms, $\\rho = 1.225$ kilograms per cubic meter, $C_d = 0.47$, $A = 0.0042$ square meters, and $g = 9.81$ meters per second squared.\n\nTest suite to cover different regimes:\n\n- Case $1$ (happy path, ground target with two solutions expected): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (80.0, 0.0)$ meters.\n- Case $2$ (elevated target, typically one or two solutions): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (60.0, 10.0)$ meters.\n- Case $3$ (short range, two solutions expected): $v_0 = 30.0$ meters per second, $(x_T,y_T) = (30.0, 0.0)$ meters.\n- Case $4$ (beyond maximum range, no solution expected): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (200.0, 0.0)$ meters.\n\nProgram input and output specification:\n\n- There is no external input. Use the exact constants and test suite above.\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets. Each case's result must be a list of the solution angle(s) in degrees, sorted in ascending order and rounded to three decimal places. If no solution exists for a case, output an empty list for that case.\n- For example, the required overall output format is like $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$ with numeric entries shown in decimal form and no extra text.\n\nYour program must be complete and runnable as provided, and it must use a root-finding algorithm applied to $F(\\theta)$ as defined above to locate the solution angle(s) for each case. Angles must be reported in degrees.", "solution": "The problem proposed is a well-defined and standard exercise in computational physics. It is scientifically grounded, mathematically consistent, and all necessary parameters for its solution are provided. The physical model, based on Newton's second law with quadratic air resistance, is a canonical representation of projectile motion in a viscous medium. The numerical task, which is to find the launch angles that result in the projectile passing through a specific target point, constitutes a boundary value problem. The prescribed method of solution—the shooting method coupled with a root-finding algorithm for a scalar function—is a robust and appropriate technique for this class of problems. Therefore, the problem is valid and we shall proceed with a complete solution.\n\nThe core of the problem is to solve a system of coupled first-order ordinary differential equations (ODEs). Let the state of the system at time $t$ be described by the vector $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$. The equations of motion can be written in the form $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$, where the function $\\mathbf{f}$ is defined as:\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\nThe initial state at $t=0$ is given by $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$. The parameter $\\theta$ is the launch angle, which we must determine.\n\nA direct analytical solution for the trajectory $\\mathbf{r}(t)$ does not exist for this system. We must employ a numerical approach. The problem asks us to find the value(s) of $\\theta$ for which the trajectory passes through the target point $(x_T, y_T)$. This is a boundary value problem. We will solve it using a \"shooting method,\" which transforms the boundary value problem into a root-finding problem.\n\nThe shooting method proceeds as follows:\n1.  We select a trial launch angle $\\theta$. This fully specifies the initial conditions $\\mathbf{S}(0)$.\n2.  We numerically integrate the system of ODEs from $t=0$ forward in time. This process \"shoots\" the projectile.\n3.  We monitor the trajectory to find the time $t^\\star$ at which the projectile's horizontal position $x(t)$ first equals the target's horizontal position $x_T$.\n4.  At this time $t^\\star$, we evaluate the projectile's height, $y(t^\\star)$.\n5.  We define a scalar objective function, $F(\\theta)$, as the difference between the projectile's height at $x=x_T$ and the target height $y_T$:\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    A solution angle $\\theta^\\star$ is one for which $F(\\theta^\\star) = 0$. The problem is therefore reduced to finding the roots of the function $F(\\theta)$.\n\nTo implement this method, we require a robust ODE integrator. The `solve_ivp` function from the SciPy library is an excellent tool for this. A critical feature of `solve_ivp` is its ability to detect \"events\"—conditions where a function of the state and time becomes zero. We will use this feature to precisely determine the crossing time $t^\\star$ without having to integrate to a fixed maximum time and then interpolate.\n\nWe define two terminal event functions:\n1.  `event_reach_x_target(t, S)`: This function returns $x(t) - x_T$. The integrator will stop when this value is zero, indicating the projectile has reached the target's longitude.\n2.  `event_hit_ground(t, S)`: This function returns $y(t)$. We configure it to trigger only when $y(t)$ is decreasing (i.e., the projectile is falling), which signals that the projectile has hit the ground before reaching $x=x_T$.\n\nThe function $F(\\theta)$ is constructed by calling the ODE solver for a given $\\theta$. If the integration is terminated by the `event_reach_x_target` event, we calculate and return $y(t^\\star) - y_T$. If it is terminated by `event_hit_ground`, or if it reaches a maximum simulation time without triggering any event, it means the trajectory falls short. In this case, the function $F(\\theta)$ is considered undefined for the purpose of bracketing, and we can return a non-numerical value like `NaN` (Not a Number) to signify this.\n\nTo find all roots of $F(\\theta)=0$ in the specified interval $\\theta \\in [0.1^\\circ, 89.9^\\circ]$, we employ a two-stage process:\n1.  **Bracketing**: We first discretize the search interval into a fine grid of angles. We evaluate $F(\\theta)$ at each point on this grid. By searching for adjacent grid points $(\\theta_i, \\theta_{i+1})$ where the sign of the function changes (i.e., $F(\\theta_i) \\cdot F(\\theta_{i+1})  0$), we identify sub-intervals that are guaranteed to contain at least one root, according to the Intermediate Value Theorem. It is important to handle the `NaN` cases correctly, as a valid bracket requires defined numerical values at both ends.\n2.  **Solving**: For each bracket $[\\theta_a, \\theta_b]$ found, we apply a numerical root-finding algorithm. Brent's method, implemented in `scipy.optimize.brentq`, is a highly effective choice. It combines the guaranteed convergence of the bisection method with the faster convergence of the secant method, and it is the standard for one-dimensional root-finding when a bracketing interval is known. The tolerance of the root-finder will be set to ensure the required precision on both the angle and the final target height.\n\nThis systematic procedure of numerical integration, event detection, bracketing, and root-solving will be applied to each test case to find all valid launch angles.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2  0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root)  1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}]}