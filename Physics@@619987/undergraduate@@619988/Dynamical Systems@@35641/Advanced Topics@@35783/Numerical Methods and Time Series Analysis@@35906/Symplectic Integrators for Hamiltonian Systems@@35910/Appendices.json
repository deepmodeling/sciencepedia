{"hands_on_practices": [{"introduction": "The power of symplectic integrators lies in their simple but elegant structure, which arises from splitting a Hamiltonian into solvable parts. This first practice focuses on the foundational skill of constructing a symplectic Euler integrator, one of the simplest methods of this class. By deriving the explicit update rules for a particle in a given potential, you will directly apply the 'kick-then-drift' sequence that is central to many structure-preserving algorithms [@problem_id:1713082].", "problem": "A student in a computational physics course is assigned the task of simulating the one-dimensional motion of a particle. The dynamics of this particle are governed by a separable Hamiltonian of the form $H(q,p) = T(p) + V(q)$, where $q$ is the position, $p$ is the momentum, $T(p)$ is the kinetic energy, and $V(q)$ is the potential energy.\n\nFor this simulation, a specific first-order numerical integrator, sometimes known as the symplectic Euler-B method, must be implemented. This method consists of two sequential steps to advance the system from a state $(q_n, p_n)$ at time $t_n$ to a new state $(q_{n+1}, p_{n+1})$ at time $t_{n+1} = t_n + \\Delta t$, where $\\Delta t$ is the time step. The procedure is as follows:\n\n1.  First, update the momentum from its current value $p_n$ to its new value $p_{n+1}$. This update is performed using a single explicit Euler step over the time interval $\\Delta t$, driven by the force which is derived from the potential energy $V(q)$ evaluated at the initial position, $q_n$.\n2.  Second, update the position from its current value $q_n$ to its new value $q_{n+1}$. This update is performed using a single explicit Euler step over the same time interval $\\Delta t$, with the velocity being determined from the *newly computed* momentum, $p_{n+1}$.\n\nThe specific system under consideration is a particle of mass $m$ moving in a one-dimensional quartic potential well, described by the potential energy function $V(q) = \\frac{1}{4} k q^4$, where $k$ is a positive constant. The corresponding kinetic energy is given by $T(p) = \\frac{p^2}{2m}$.\n\nYour task is to determine the explicit update expressions for the position $q_{n+1}$ and the momentum $p_{n+1}$. Your final expressions must be given solely in terms of the initial state variables $q_n$ and $p_n$, the time step $\\Delta t$, and the physical parameters $m$ and $k$.", "solution": "We start from the separable Hamiltonian $H(q,p)=T(p)+V(q)$, with the equations of motion given by Hamilton's equations:\n$$\n\\dot{q}=\\frac{\\partial H}{\\partial p}=\\frac{\\partial T}{\\partial p},\\qquad \\dot{p}=-\\frac{\\partial H}{\\partial q}=-\\frac{\\partial V}{\\partial q}.\n$$\nFor the given system, $T(p)=\\frac{p^{2}}{2m}$ and $V(q)=\\frac{1}{4}k q^{4}$. Therefore,\n$$\n\\frac{\\partial T}{\\partial p}=\\frac{p}{m},\\qquad \\frac{\\partial V}{\\partial q}=k q^{3},\n$$\nso the equations of motion are\n$$\n\\dot{q}=\\frac{p}{m},\\qquad \\dot{p}=-k q^{3}.\n$$\n\nThe symplectic Euler-B method (kick then drift) advances $(q_{n},p_{n})$ to $(q_{n+1},p_{n+1})$ in two steps over the time step $\\Delta t$:\n\n1) Momentum update (explicit Euler using the force evaluated at $q_{n}$):\n$$\np_{n+1}=p_{n}+\\Delta t\\,\\dot{p}\\big|_{q=q_{n}}=p_{n}-\\Delta t\\,k\\,q_{n}^{3}.\n$$\n\n2) Position update (explicit Euler using the velocity evaluated at $p_{n+1}$):\n$$\nq_{n+1}=q_{n}+\\Delta t\\,\\dot{q}\\big|_{p=p_{n+1}}=q_{n}+\\Delta t\\,\\frac{p_{n+1}}{m}.\n$$\n\nSubstituting the momentum update into the position update gives an expression solely in terms of $q_{n}$, $p_{n}$, $\\Delta t$, $m$, and $k$:\n$$\nq_{n+1}=q_{n}+\\frac{\\Delta t}{m}\\left(p_{n}-\\Delta t\\,k\\,q_{n}^{3}\\right) = q_{n}+\\frac{\\Delta t}{m}p_{n}-\\frac{k\\,(\\Delta t)^{2}}{m}q_{n}^{3}.\n$$\n\nThus, the explicit updates required are:\n$$\np_{n+1}=p_{n}-\\Delta t\\,k\\,q_{n}^{3},\\qquad\nq_{n+1}=q_{n}+\\frac{\\Delta t}{m}p_{n}-\\frac{k\\,(\\Delta t)^{2}}{m}q_{n}^{3}.\n$$", "answer": "$$\\boxed{\\begin{cases} p_{n+1} = p_n - \\Delta t k q_n^3 \\\\ q_{n+1} = q_n + \\frac{\\Delta t}{m} p_n - \\frac{k(\\Delta t)^2}{m} q_n^3 \\end{cases}}$$", "id": "1713082"}, {"introduction": "What makes an integrator 'symplectic'? The defining characteristic is its ability to preserve phase-space volume, a key feature of Hamiltonian dynamics rooted in Liouville's theorem. This practice provides a powerful, computational demonstration of this principle by tracking the area of a region in phase space as it evolves under two different integrators [@problem_id:2444632]. You will see firsthand how a standard non-symplectic method distorts this area, while a symplectic one preserves it, highlighting the geometric fidelity essential for long-term simulations.", "problem": "Consider the two-dimensional harmonic oscillator with Hamiltonian $H(x,p)=\\dfrac{p^2}{2 m}+\\dfrac{1}{2} k x^2$ with $m=1$ and $k=\\omega^2$, where $x$ is the position coordinate and $p$ is the conjugate momentum. The Hamiltonian equations of motion are $\\dot{x}=p$ and $\\dot{p}=-\\omega^2 x$. Define two discrete-time one-step maps with time step $h$ as follows:\n- Map $\\mathcal{F}$ (an explicit forward step): $x_{n+1}=x_n+h\\,p_n$, $p_{n+1}=p_n-h\\,\\omega^2 x_n$.\n- Map $\\mathcal{S}$ (a semi-implicit step): $p_{n+1}=p_n-h\\,\\omega^2 x_n$, $x_{n+1}=x_n+h\\,p_{n+1}$.\nLet $\\mathcal{C}_0$ be a closed convex polygon in the $(x,p)$ phase plane with $M$ vertices $\\{(x_j(0),p_j(0))\\}_{j=0}^{M-1}$ ordered counterclockwise, given by\n$$\nx_j(0)=R\\cos\\theta_j,\\quad p_j(0)=R\\sin\\theta_j,\\quad \\theta_j=\\dfrac{2\\pi j}{M},\n$$\nfor $j\\in\\{0,1,\\dots,M-1\\}$, with all angles measured in radians. All quantities are dimensionless.\n\nFor a given map $\\mathcal{M}\\in\\{\\mathcal{F},\\mathcal{S}\\}$ and a positive integer $N$, define $\\mathcal{C}_N$ as the polygon obtained by applying $N$ successive steps of $\\mathcal{M}$ to each vertex of $\\mathcal{C}_0$, preserving vertex order. Define the polygonal area functional\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|,\n$$\nwith cyclic indexing $x_M\\equiv x_0$ and $p_M\\equiv p_0$. For each test case below, compute the area ratio $A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$ for $\\mathcal{M}=\\mathcal{F}$ and for $\\mathcal{M}=\\mathcal{S}$.\n\nUse the following test suite of parameter sets $(\\omega,h,N,M,R)$:\n- Test $1$: $(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$.\n- Test $2$: $(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$.\n- Test $3$: $(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$.\n- Test $4$: $(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$.\n\nYour program must produce, for each test in the order listed, two floating-point numbers: first the area ratio for map $\\mathcal{F}$, then the area ratio for map $\\mathcal{S}$. Round each number to $6$ decimal places. The final output must be a single line containing a comma-separated list enclosed in square brackets with all results in order, that is,\n$$\n\\left[\\rho^{(\\mathcal{F})}_1,\\rho^{(\\mathcal{S})}_1,\\rho^{(\\mathcal{F})}_2,\\rho^{(\\mathcal{S})}_2,\\rho^{(\\mathcal{F})}_3,\\rho^{(\\mathcal{S})}_3,\\rho^{(\\mathcal{F})}_4,\\rho^{(\\mathcal{S})}_4\\right],\n$$\nwhere $\\rho^{(\\mathcal{M})}_i=A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$ for the $i$-th test case and map $\\mathcal{M}$. No physical units are involved in this problem, and all angles must be in radians.", "solution": "The problem asks for the ratio of phase-space areas of a polygon evolved under two different numerical integration schemes for the harmonic oscillator. A direct simulation of each of the $M$ vertices for $N$ time steps is a valid but computationally inefficient approach. A more insightful solution is found by analyzing the algebraic properties of the maps.\n\nLet the state of the system in phase space be represented by the vector $\\mathbf{z} = (x, p)^T$. The Hamiltonian equations of motion are $\\dot{x} = \\partial H / \\partial p = p/m$ and $\\dot{p} = -\\partial H / \\partial x = -kx$. With $m=1$ and $k=\\omega^2$, we have $\\dot{\\mathbf{z}} = \\mathbf{A} \\mathbf{z}$ where $\\mathbf{A} = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}$. The maps $\\mathcal{F}$ and $\\mathcal{S}$ are discrete approximations to the flow of this linear system.\n\nBoth maps, $\\mathcal{F}$ and $\\mathcal{S}$, are linear transformations from the state $(x_n, p_n)$ at time step $n$ to the state $(x_{n+1}, p_{n+1})$ at step $n+1$. We can express them in matrix form, $\\mathbf{z}_{n+1} = \\mathbf{M} \\mathbf{z}_n$.\n\nFor map $\\mathcal{F}$ (explicit forward Euler):\n$$\n\\begin{cases}\nx_{n+1} = x_n + h\\,p_n \\\\\np_{n+1} = p_n - h\\,\\omega^2 x_n\n\\end{cases}\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\nThe one-step evolution matrix is thus $\\mathbf{M}_{\\mathcal{F}} = \\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}$.\n\nFor map $\\mathcal{S}$ (semi-implicit Euler):\n$$\n\\begin{cases}\np_{n+1} = p_n - h\\,\\omega^2 x_n \\\\\nx_{n+1} = x_n + h\\,p_{n+1} = x_n + h(p_n - h\\omega^2 x_n) = (1-h^2\\omega^2)x_n + h p_n\n\\end{cases}\n$$\n$$\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\nThe one-step evolution matrix is $\\mathbf{M}_{\\mathcal{S}} = \\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}$.\n\nAfter $N$ steps, the transformation from the initial state $\\mathbf{z}_0$ to the final state $\\mathbf{z}_N$ is given by $\\mathbf{z}_N = (\\mathbf{M}_{\\mathcal{M}})^N \\mathbf{z}_0$, where $\\mathcal{M} \\in \\{\\mathcal{F}, \\mathcal{S}\\}$. This is a linear transformation, let us call its matrix $\\mathbf{T} = (\\mathbf{M}_{\\mathcal{M}})^N$.\n\nThe area of a polygon $\\mathcal{C}$ with vertices $\\{(x_j, p_j)\\}_{j=0}^{M-1}$ is given by the shoelace formula:\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|\n$$\nWhen a polygon is subjected to a linear transformation with matrix $\\mathbf{T}$, its area $A$ is transformed to $A' = |\\det(\\mathbf{T})| A$.\nIn our case, the vertices $\\{\\mathbf{z}_j(0)\\}$ of the initial polygon $\\mathcal{C}_0$ are transformed into the vertices $\\{\\mathbf{z}_j(N) = \\mathbf{T} \\mathbf{z}_j(0)\\}$ of the final polygon $\\mathcal{C}_N$. Therefore, the area of the final polygon is $A[\\mathcal{C}_N] = |\\det(\\mathbf{T})| A[\\mathcal{C}_0]$.\n\nThe required area ratio is:\n$$\n\\dfrac{A[\\mathcal{C}_N]}{A[\\mathcal{C}_0]} = |\\det(\\mathbf{T})| = |\\det((\\mathbf{M}_{\\mathcal{M}})^N)| = |\\det(\\mathbf{M}_{\\mathcal{M}})|^N\n$$\nThis result is independent of the specific geometry of the initial polygon, i.e., the parameters $M$ and $R$ are irrelevant to the final ratio. We only need to compute the determinants of the one-step matrices.\n\nFor map $\\mathcal{F}$:\n$$\n\\det(\\mathbf{M}_{\\mathcal{F}}) = (1)(1) - (h)(-h\\omega^2) = 1 + h^2\\omega^2\n$$\nThe area ratio is $\\rho^{(\\mathcal{F})} = (1 + h^2\\omega^2)^N$. Since $h > 0$ and $\\omega > 0$, this value is always greater than $1$, indicating that the area grows exponentially. This map is not symplectic.\n\nFor map $\\mathcal{S}$:\n$$\n\\det(\\mathbf{M}_{\\mathcal{S}}) = (1-h^2\\omega^2)(1) - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1\n$$\nThe area ratio is $\\rho^{(\\mathcal{S})} = (1)^N = 1$. This map preserves the phase-space area exactly for any choice of parameters and is therefore a symplectic map.\n\nWe now apply these formulas to the given test cases.\n\nTest $1$: $(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(1)^2)^{100} = (1.01)^{100} \\approx 2.704814$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nTest $2$: $(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.5)^2(1)^2)^{20} = (1.25)^{20} \\approx 86.736174$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nTest $3$: $(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(2)^2)^{100} = (1.04)^{100} \\approx 50.504948$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nTest $4$: $(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.01)^2(1)^2)^{1000} = (1.0001)^{1000} \\approx 1.105116$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nThese calculations will be implemented in the provided program structure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analytically calculating the area ratios for the two maps.\n    The area ratio for a polygon under a linear map T is given by |det(T)|.\n    For N steps, the transformation is T = M^N, where M is the one-step matrix.\n    The area ratio is |det(M^N)| = |det(M)|^N.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (omega, h, N, M, R)\n    test_cases = [\n        (1.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.5, 20, 128, 1.0),\n        (2.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.01, 1000, 128, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega, h, N, M, R = case\n\n        # --- Map F (Explicit Euler) ---\n        # The one-step matrix M_F has determinant det(M_F) = 1 + h^2 * omega^2.\n        # The area ratio after N steps is (det(M_F))^N.\n        det_M_F = 1.0 + h**2 * omega**2\n        rho_F = np.power(det_M_F, N)\n\n        # --- Map S (Symplectic Euler) ---\n        # The one-step matrix M_S has determinant det(M_S) = 1.\n        # The area ratio after N steps is (det(M_S))^N = 1^N = 1.\n        rho_S = 1.0\n\n        # Append the rounded results for the current test case.\n        results.append(round(rho_F, 6))\n        results.append(round(rho_S, 6))\n\n    # Final print statement in the exact required format.\n    # The output is a single line, comma-separated list of numbers in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2444632"}, {"introduction": "Beyond preserving phase-space area, many widely-used symplectic integrators possess another crucial property: time-reversibility. This means that integrating forward and then backward in time returns you exactly to your starting point, mirroring the time-symmetric nature of the underlying physical laws. In this exercise, you will put this property to the test by comparing the symmetric velocity Verlet scheme against the non-symmetric, though highly accurate, fourth-order Runge-Kutta method [@problem_id:2444614]. The results starkly illustrate the importance of symmetry for achieving long-term fidelity in numerical simulations.", "problem": "Consider a one-dimensional harmonic oscillator with Hamiltonian $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k}{2}q^2$, where $q$ is position, $p$ is momentum, $m$ is mass, and $k$ is the spring constant. The dynamics are governed by Hamilton’s equations. Starting from an initial state $(q_0,p_0)$ at time $t=0$, define the following quantitative diagnostic of numerical reversibility for a given time-stepping method: integrate the system forward in time for $N$ uniform steps of size $h$ to obtain $(q_N,p_N)$, then integrate backward in time for $N$ uniform steps of size $-h$ starting from $(q_N,p_N)$ to obtain $(\\tilde{q}_0,\\tilde{p}_0)$. The numerical reversibility error is the Euclidean norm $E=\\sqrt{(\\tilde{q}_0-q_0)^2+(\\tilde{p}_0-p_0)^2}$.\n\nWrite a complete, runnable program that computes this forward-then-backward numerical reversibility error $E$ for two integrators:\n- the classical fourth-order Runge-Kutta (RK4) method,\n- the velocity Verlet symplectic scheme.\n\nAll quantities in this problem are dimensionless, so report all numerical results as dimensionless real numbers. Your program must compute the errors $E$ for both integrators for each of the following test cases, each specified by $(m,k,q_0,p_0,h,N)$:\n1. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.1,\\,100\\right)$, a general case.\n2. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.01,\\,1000\\right)$, a small time step case.\n3. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,1.9,\\,100\\right)$, a large time step near the stability boundary for the harmonic oscillator.\n4. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.05,\\,10000\\right)$, a long-time integration.\n5. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,0.2,\\,-0.3,\\,0.37,\\,0\\right)$, a boundary condition case with zero steps.\n6. $(m,k,q_0,p_0,h,N)=\\left(2.0,\\,0.5,\\,0.3,\\,0.7,\\,0.07,\\,1234\\right)$, a nontrivial mass and stiffness.\n\nFor each test case, compute two errors: $E_{\\mathrm{RK4}}$ and $E_{\\mathrm{Verlet}}$. The final output must be a single line containing a comma-separated list enclosed in square brackets, ordered as\n$[E_{\\mathrm{RK4}}^{(1)},E_{\\mathrm{Verlet}}^{(1)},E_{\\mathrm{RK4}}^{(2)},E_{\\mathrm{Verlet}}^{(2)},\\dots,E_{\\mathrm{RK4}}^{(6)},E_{\\mathrm{Verlet}}^{(6)}]$,\nwhere the superscript indicates the test case number. Each number must be rounded to $12$ decimal places.\n\nYour implementation must start from Hamilton’s equations for the given $H(q,p)$ and use the two specified integrators without relying on any external data. No angles are involved. The final output must strictly match the specified single-line format.", "solution": "The problem requires a comparative analysis of the numerical reversibility of two integrators, the fourth-order Runge-Kutta method and the velocity Verlet method, for a one-dimensional harmonic oscillator. We begin by establishing the governing equations of motion.\n\nThe system is described by the Hamiltonian $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k}{2}q^2$, where $q$ is position, $p$ is momentum, $m$ is mass, and $k$ is the spring constant. All quantities are dimensionless. The dynamics are governed by Hamilton's equations:\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -kq $$\nThis is a system of two coupled first-order ordinary differential equations. We can represent the state of the system by a vector $\\mathbf{y}(t) = [q(t), p(t)]^T$. The equations of motion can then be written in the compact form $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$, where the vector field $\\mathbf{f}$ is given by:\n$$ \\mathbf{f}(\\mathbf{y}) = \\mathbf{f}(q, p) = \\begin{pmatrix} p/m \\\\ -kq \\end{pmatrix} $$\nWe are tasked to integrate this system numerically using two distinct methods.\n\nFirst, we consider the classical fourth-order Runge-Kutta (RK4) method. Given the state $\\mathbf{y}_n$ at time $t_n$, a single step of size $h$ to find the state $\\mathbf{y}_{n+1}$ at time $t_{n+1} = t_n + h$ is given by the formula:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\nwhere the intermediate stages are defined as:\n$$ \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1) $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2) $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h\\mathbf{k}_3) $$\nNote that in the implementation, the factor of $h$ is typically applied at the final stage. The RK4 method is a general-purpose, explicit integrator with a local truncation error of order $O(h^5)$, resulting in a global error of order $O(h^4)$. However, it is not a symplectic integrator, meaning it does not generally preserve the geometric structure of Hamiltonian systems. Consequently, it is not time-reversible.\n\nSecond, we consider the velocity Verlet method. This method is specifically designed for Hamiltonian systems of the separable form $H(q,p) = T(p) + V(q)$, which our harmonic oscillator Hamiltonian satisfies with $T(p)=p^2/(2m)$ and $V(q)=kq^2/2$. The algorithm for a single step from $(q_n, p_n)$ to $(q_{n+1}, p_{n+1})$ is as follows:\n$1$. Update momentum by a half step using the force $F(q) = -\\partial V/\\partial q = -kq$:\n$$ p_{n+1/2} = p_n + \\frac{h}{2} F(q_n) = p_n - \\frac{h}{2} k q_n $$\n$2$. Update position by a full step using the half-step momentum:\n$$ q_{n+1} = q_n + h \\frac{p_{n+1/2}}{m} $$\n$3$. Update momentum by a final half step using the new force $F(q_{n+1})$:\n$$ p_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{h}{2} k q_{n+1} $$\nThe velocity Verlet method has a local truncation error of order $O(h^3)$, giving a global error of order $O(h^2)$. Its crucial advantage for Hamiltonian mechanics is that it is a symplectic integrator. A key consequence of this property is that the method is time-reversible (or symmetric).\n\nThe numerical reversibility error, $E$, is designed to test this property directly. Let $\\Phi_h$ be the numerical map that advances the system by one step of size $h$. The procedure is:\n$1$. Integrate forward for $N$ steps from an initial state $\\mathbf{y}_0 = (q_0, p_0)$ to obtain $\\mathbf{y}_N = \\Phi_h^N(\\mathbf{y}_0)$.\n$2$. From $\\mathbf{y}_N$, integrate backward for $N$ steps using a step size of $-h$ to obtain $\\tilde{\\mathbf{y}}_0 = \\Phi_{-h}^N(\\mathbf{y}_N)$.\n$3$. The error is the Euclidean distance $E = \\|\\tilde{\\mathbf{y}}_0 - \\mathbf{y}_0\\| = \\sqrt{(\\tilde{q}_0-q_0)^2+(\\tilde{p}_0-p_0)^2}$.\n\nFor a time-reversible integrator, the exact composition of a forward step and a backward step is the identity map: $\\Phi_{-h} \\circ \\Phi_h = \\mathrm{Id}$. This property extends to any number of steps, so $\\Phi_{-h}^N \\circ \\Phi_h^N = \\mathrm{Id}$. Therefore, for the velocity Verlet method, we expect $\\tilde{\\mathbf{y}}_0 = \\mathbf{y}_0$ in exact arithmetic. The calculated error $E_{\\mathrm{Verlet}}$ should thus be zero, or a very small number attributable to the accumulation of floating-point precision errors.\n\nFor the non-symmetric RK4 method, $\\Phi_{-h} \\circ \\Phi_h \\neq \\mathrm{Id}$. The forward-backward integration will not return to the initial state. The resulting error $E_{\\mathrm{RK4}}$ will be non-zero and will provide a quantitative measure of the method's lack of reversibility. This error is expected to depend on the step size $h$ and the number of steps $N$.\n\nThe program will implement these two algorithms, apply them to the specified test cases according to the forward-backward procedure, and compute the error $E$. For test case $5$, where $N=0$, no integration steps are taken. Thus, $\\mathbf{y}_N = \\mathbf{y}_0$ and $\\tilde{\\mathbf{y}}_0 = \\mathbf{y}_N = \\mathbf{y}_0$, resulting in an error of $E=0$ for both methods, trivially.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical reversibility error for RK4 and Velocity Verlet integrators\n    for a 1D harmonic oscillator across several test cases.\n    \"\"\"\n\n    test_cases = [\n        # (m, k, q0, p0, h, N)\n        (1.0, 1.0, 1.0, 0.0, 0.1, 100),       # 1. General case\n        (1.0, 1.0, 1.0, 0.0, 0.01, 1000),     # 2. Small time step\n        (1.0, 1.0, 1.0, 0.0, 1.9, 100),       # 3. Large time step\n        (1.0, 1.0, 1.0, 0.0, 0.05, 10000),    # 4. Long-time integration\n        (1.0, 1.0, 0.2, -0.3, 0.37, 0),      # 5. Zero steps\n        (2.0, 0.5, 0.3, 0.7, 0.07, 1234),     # 6. Nontrivial parameters\n    ]\n\n    def rk4_step(q, p, h, m, k):\n        \"\"\"Performs a single RK4 step for the harmonic oscillator.\"\"\"\n        \n        # k1\n        k1q = p / m\n        k1p = -k * q\n\n        # k2\n        q2 = q + 0.5 * h * k1q\n        p2 = p + 0.5 * h * k1p\n        k2q = p2 / m\n        k2p = -k * q2\n\n        # k3\n        q3 = q + 0.5 * h * k2q\n        p3 = p + 0.5 * h * k2p\n        k3q = p3 / m\n        k3p = -k * q3\n\n        # k4\n        q4 = q + h * k3q\n        p4 = p + h * k3p\n        k4q = p4 / m\n        k4p = -k * q4\n        \n        q_new = q + (h / 6.0) * (k1q + 2.0 * k2q + 2.0 * k3q + k4q)\n        p_new = p + (h / 6.0) * (k1p + 2.0 * k2p + 2.0 * k3p + k4p)\n        \n        return q_new, p_new\n\n    def verlet_step(q, p, h, m, k):\n        \"\"\"Performs a single Velocity Verlet step for the harmonic oscillator.\"\"\"\n        \n        force_initial = -k * q\n        p_half = p + 0.5 * h * force_initial\n        q_new = q + h * (p_half / m)\n        force_final = -k * q_new\n        p_new = p_half + 0.5 * h * force_final\n        \n        return q_new, p_new\n\n    def compute_reversibility_error(integrator_step, m, k, q0, p0, h, N):\n        \"\"\"\n        Computes the forward-then-backward numerical reversibility error E.\n        \"\"\"\n        if N == 0:\n            return 0.0\n\n        q, p = q0, p0\n        \n        # Forward integration\n        for _ in range(N):\n            q, p = integrator_step(q, p, h, m, k)\n        \n        # Backward integration\n        for _ in range(N):\n            q, p = integrator_step(q, p, -h, m, k)\n            \n        q_tilde_0, p_tilde_0 = q, p\n        \n        error = np.sqrt((q_tilde_0 - q0)**2 + (p_tilde_0 - p0)**2)\n        return error\n\n    results = []\n    for case in test_cases:\n        m, k, q0, p0, h, N = case\n        \n        m, k, q0, p0, h = float(m), float(k), float(q0), float(p0), float(h)\n        N = int(N)\n        \n        error_rk4 = compute_reversibility_error(rk4_step, m, k, q0, p0, h, N)\n        error_verlet = compute_reversibility_error(verlet_step, m, k, q0, p0, h, N)\n        \n        results.append(round(error_rk4, 12))\n        results.append(round(error_verlet, 12))\n    \n    final_output = \",\".join(map(str, results))\n    print(f\"[{final_output}]\")\n\nsolve()\n```", "id": "2444614"}]}