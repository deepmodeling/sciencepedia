{"hands_on_practices": [{"introduction": "Before a molecular dynamics simulation can begin, we must prepare the system in an initial state that reflects the desired physical conditions. A crucial step is setting the initial temperature, which in the microscopic world is a measure of the average kinetic energy of the particles. This exercise [@problem_id:1981020] guides you through the standard procedure of scaling atomic velocities to achieve a precise target temperature, reinforcing the connection between microscopic dynamics and macroscopic thermodynamics through the equipartition theorem.", "problem": "A computational physics student is preparing to run a Molecular Dynamics (MD) simulation, a computer simulation method for analyzing the physical movements of atoms and molecules. The simulation will model a system of liquid Argon.\n\nThe system consists of $N=500$ Argon atoms, each with a mass of $m = 6.634 \\times 10^{-26}$ kg. The goal is to initialize the system so that its initial kinetic temperature is exactly $T = 120.0$ K.\n\nTo achieve this, the student first assigns an initial velocity vector to each atom using a random number generator. As a standard procedure to prevent the entire system from drifting through space, the velocities are then adjusted so that the total momentum of the center of mass is zero. After this correction, the sum of the squares of the speeds of all atoms in the system is measured to be $\\sum_{i=1}^{N} |\\vec{v}'_i|^2 = 3.500 \\times 10^7 \\text{ (m/s)}^2$, where $\\vec{v}'_i$ is the velocity of the $i$-th atom after the momentum correction.\n\nTo reach the desired temperature, all of these corrected velocity vectors $\\vec{v}'_i$ must be uniformly scaled by a single dimensionless factor, $\\lambda$, to obtain the final initial velocities $\\vec{v}_i = \\lambda \\vec{v}'_i$. Calculate the required value of this scaling factor $\\lambda$.\n\nUse the Boltzmann constant $k_B = 1.381 \\times 10^{-23}$ J/K. Round your final answer to four significant figures.", "solution": "The instantaneous kinetic temperature in classical MD is set by the equipartition theorem. With the center-of-mass momentum constrained to zero, the number of translational kinetic degrees of freedom is $f = 3N - 3$. The total kinetic energy must satisfy\n$$\nK = \\frac{f}{2} k_{B} T = \\frac{3N-3}{2} k_{B} T.\n$$\nFor identical atoms of mass $m$, after uniformly scaling the already momentum-corrected velocities $\\vec{v}'_{i}$ by $\\lambda$ so that $\\vec{v}_{i} = \\lambda \\vec{v}'_{i}$, the kinetic energy is\n$$\nK = \\frac{1}{2} m \\sum_{i=1}^{N} |\\vec{v}_{i}|^{2} = \\frac{1}{2} m \\lambda^{2} \\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2}.\n$$\nEquating these and solving for $\\lambda$ gives\n$$\n\\frac{1}{2} m \\lambda^{2} \\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2} = \\frac{3N-3}{2} k_{B} T\n\\;\\;\\Longrightarrow\\;\\;\n\\lambda = \\sqrt{\\frac{(3N-3) k_{B} T}{m \\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2}}}.\n$$\nInsert the given values $N=500$, $k_{B} = 1.381 \\times 10^{-23}$ J/K, $T = 120.0$ K, $m = 6.634 \\times 10^{-26}$ kg, and $\\sum_{i=1}^{N} |\\vec{v}'_{i}|^{2} = 3.500 \\times 10^{7}$ (m/s)$^{2}$:\n$$\n\\lambda = \\sqrt{\\frac{(3 \\times 500 - 3)\\,(1.381 \\times 10^{-23})\\,(120.0)}{(6.634 \\times 10^{-26})\\,(3.500 \\times 10^{7})}}.\n$$\nCompute the numerator:\n$$\n(3 \\times 500 - 3)\\,(1.381 \\times 10^{-23})\\,(120.0) = 1497 \\times 1.381 \\times 10^{-23} \\times 120.0 = 2.4808284 \\times 10^{-18}.\n$$\nDivide by $m$:\n$$\n\\frac{2.4808284 \\times 10^{-18}}{6.634 \\times 10^{-26}} = 3.73956648 \\times 10^{7}.\n$$\nDivide by $\\sum_{i} |\\vec{v}'_{i}|^{2}$:\n$$\n\\frac{3.73956648 \\times 10^{7}}{3.500 \\times 10^{7}} = 1.068447566.\n$$\nTake the square root to obtain\n$$\n\\lambda = \\sqrt{1.068447566} \\approx 1.033657\\ldots\n$$\nRounded to four significant figures,\n$$\n\\lambda = 1.034.\n$$\nUnits are consistent and $\\lambda$ is dimensionless, as required.", "answer": "$$\\boxed{1.034}$$", "id": "1981020"}, {"introduction": "To simulate a small part of a bulk material without introducing artificial surfaces, molecular dynamics simulations employ periodic boundary conditions (PBC), where the simulation box is replicated infinitely in all directions. This practice problem [@problem_id:2458300] challenges you to implement the minimum image convention, the fundamental algorithm for correctly calculating the distance between two particles in a periodic system. Mastering this concept is essential for accurately computing forces and understanding the core mechanics of nearly all modern MD codes.", "problem": "You are to write a complete, runnable program that demonstrates the effect of the minimum image convention for periodic boundary conditions in molecular dynamics (MD) simulations. The program must compute the Euclidean distance between two particles in an orthorhombic periodic simulation box in two ways: (1) the naive Euclidean distance that ignores periodicity, and (2) the Euclidean distance after applying the minimum image convention. Distances must be expressed in nanometers (nm) and reported rounded to exactly six decimal places.\n\nBackground and fundamental base: In molecular dynamics (MD) simulations with periodic boundary conditions (PBC), an infinite tiling of the finite simulation box is used to mimic bulk behavior. The physical distance between two particles is interpreted as the minimum distance between one particle and any periodic image of the other. The underlying geometric rule is derived from the definition of Euclidean distance and the translation symmetry of the lattice. For an orthorhombic box with side lengths $L_x$, $L_y$, and $L_z$, the minimum distance is obtained by selecting an integer number of box-length translations along each axis that minimizes the Euclidean norm of the displacement vector. Your program must implement this rule.\n\nYour task:\n- Define a function that, given two $3$-dimensional positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ in nanometers and box lengths $(L_x,L_y,L_z)$ in nanometers, returns two values:\n  1) the naive Euclidean distance $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$ in nm,\n  2) the minimum image convention distance $d_{\\text{mic}}$ in nm, obtained by translating the displacement components by integer multiples of $(L_x,L_y,L_z)$ to minimize the norm.\n- Treat the box as orthorhombic and axis-aligned.\n- Positions may lie outside the primary box interval. Your implementation must still correctly compute $d_{\\text{mic}}$ using periodicity.\n- To make your implementation clear, also include within the program a multi-line pseudocode string (not printed) that outlines the minimum image convention logic you implemented.\n\nNumerical and unit requirements:\n- All distances must be in nanometers (nm).\n- Report distances rounded to exactly $6$ decimal places.\n\nTest suite:\nYour program must compute $[d_{\\text{naive}}, d_{\\text{mic}}]$ for each of the following $5$ test cases, in the stated order.\n\n1) Happy path, small separation well within the box:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) Crossing a periodic boundary along one axis:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) Anisotropic box and wrapping along multiple axes:\n- Box: $(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) Exactly half-box separation along one axis (tie case):\n- Box: $(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) Positions outside the primary box interval:\n- Box: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of pairs enclosed in square brackets. Each pair corresponds to one test case in the specified order and must have the form $[d_{\\text{naive}},d_{\\text{mic}}]$, with both values rounded to exactly $6$ decimal places in nanometers. There must be no spaces in the output.\n- For example, the required overall format is like $[[a_1,b_1],[a_2,b_2],\\dots]$ where each $a_k$ and $b_k$ are floats in nanometers with exactly $6$ decimal places.", "solution": "The problem posed is a fundamental exercise in computational statistical mechanics, specifically concerning the implementation of periodic boundary conditions (PBC) in molecular dynamics (MD) simulations. The use of PBC is a standard and necessary technique to approximate the properties of a macroscopic system by simulating a small, finite number of particles. It mitigates the severe surface effects that would otherwise dominate the behavior of a small system. The core of this problem is the correct calculation of inter-particle distances, which is governed by the minimum image convention (MIC).\n\nThe problem is well-posed, scientifically grounded, and provides all necessary data for a unique and verifiable solution. We will proceed with a rigorous derivation and implementation.\n\nLet the orthorhombic simulation box be defined by a set of three orthogonal vectors corresponding to the side lengths, $\\mathbf{L} = (L_x, L_y, L_z)$. The position of two particles, $i$ and $j$, are given by vectors $\\mathbf{r}_i$ and $\\mathbf{r}_j$.\n\nFirst, we define the naive Euclidean distance, $d_{\\text{naive}}$. This is the standard distance in a non-periodic, three-dimensional Euclidean space. It is calculated from the norm of the displacement vector $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$.\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\nwhere $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$. This calculation ignores the periodic nature of the simulation box and treats the system as if it were isolated in a vacuum.\n\nSecond, we address the minimum image convention distance, $d_{\\text{mic}}$. In a periodic system, the simulation box is replicated infinitely in all directions. A particle at position $\\mathbf{r}$ has an infinite lattice of periodic images at positions $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$, where $n_x, n_y, n_z$ are any integers. The physical distance between particle $i$ and particle $j$ is the shortest distance between particle $i$ and *any* of the periodic images of particle $j$.\n\nMathematically, this is expressed as:\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\nFor an orthorhombic box, the minimization of the norm can be performed independently for each Cartesian component. Let us consider the $x$-component of the displacement vector, $\\Delta x = x_j - x_i$. We must find an integer $n_x$ that minimizes $|\\Delta x - n_x L_x|$. This is achieved when $n_x$ is the integer nearest to the ratio $\\Delta x / L_x$. This is the \"nearest integer function,\" often denoted as $\\text{nint}(s)$ or implemented via `round(s)`.\n\nThe MIC-adjusted displacement component, $\\Delta x'$, is therefore:\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\nThis formula correctly \"wraps\" the displacement vector component into the interval $[-L_x/2, L_x/2]$. The same logic applies to the $y$ and $z$ components. The complete MIC-adjusted displacement vector, $\\Delta\\mathbf{r}'$, is then:\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\nThis vector operation is robust and correctly handles cases where particle coordinates may lie outside the primary simulation box, as only their relative displacement matters.\n\nThe minimum image distance, $d_{\\text{mic}}$, is the Euclidean norm of this adjusted displacement vector:\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\nThe provided test cases will be solved using this established methodology. The implementation will utilize the `numpy` library for efficient vector arithmetic. For each test case, we will compute $d_{\\text{naive}}$ and $d_{\\text{mic}}$ and report the results rounded to precisely $6$ decimal places as specified. The special case of a displacement of exactly half a box length, e.g., $\\Delta x = L_x/2$, is handled by the `round` function, which typically rounds to the nearest even integer (e.g., in `numpy`), but the resulting distance is uniquely $L_x/2$ regardless of the sign choice for the adjusted displacement. For $\\Delta x = L_x/2$, $\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$. The magnitude is unambiguous.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "While powerful, MD simulations are necessarily limited to a finite number of particles, which can introduce systematic artifacts in calculated properties. This practice [@problem_id:1980948] delves into the important concept of finite-size effects, where a measured quantity like the diffusion coefficient, $D$, depends on the simulation box size, $L$. By applying a theoretical scaling law to data from simulations of varying sizes, you will learn the critical research skill of extrapolating your results to the thermodynamic limit, thereby obtaining a more accurate estimate of the true bulk property.", "problem": "A researcher is conducting a series of Molecular Dynamics (MD) simulations to determine the self-diffusion coefficient, $D$, of a simple fluid. The simulations are performed in a cubic box with periodic boundary conditions. It is known that for such systems, the calculated diffusion coefficient, $D(L)$, depends on the side length $L$ of the simulation box due to finite-size effects. A well-established theoretical model predicts this dependence for large $L$ as:\n$$D(L) = D_\\infty - \\frac{k_{H}}{L}$$\nwhere $D_\\infty$ is the true diffusion coefficient in the thermodynamic limit (an infinitely large system), and $k_{H}$ is a constant that depends on the fluid's properties.\n\nTo find $D_\\infty$, the researcher runs three simulations with different numbers of particles, $N$, while keeping the number density $\\rho$ constant at $0.80 \\, \\sigma_0^{-3}$, where $\\sigma_0$ is a characteristic length unit. The measured diffusion coefficients, in units of $\\sigma_0^2/\\tau_0$ where $\\tau_0$ is a characteristic time unit, are recorded as follows:\n\n| Simulation | Number of Particles ($N$) | Measured Diffusion Coefficient ($D/\\left(\\sigma_0^2/\\tau_0\\right)$) |\n|------------|---------------------------|----------------------------------------------------------|\n| 1          | 256                       | 1.05                                                     |\n| 2          | 512                       | 1.34                                                     |\n| 3          | 1000                      | 1.56                                                     |\n\nUsing the provided data and the theoretical model, determine the best estimate for the true diffusion coefficient, $D_\\infty$. Express your final answer as a numerical value in units of $\\sigma_0^2/\\tau_0$, rounded to three significant figures.", "solution": "We start from the finite-size scaling relation for the diffusion coefficient,\n$$D(L) = D_{\\infty} - \\frac{k_{H}}{L}.$$\nAt fixed number density $\\rho$, the cubic simulation box length is related to the number of particles $N$ by\n$$\\rho = \\frac{N}{L^{3}} \\quad \\Rightarrow \\quad L = \\left(\\frac{N}{\\rho}\\right)^{1/3}, \\quad \\frac{1}{L} = \\left(\\frac{\\rho}{N}\\right)^{1/3}.$$\nDefine $x \\equiv \\frac{1}{L}$ and $y \\equiv D(L)$. Then the model is linear,\n$$y = D_{\\infty} - k_{H} x.$$\nEquivalently, letting $s \\equiv N^{-1/3}$ one has $x = \\rho^{1/3} s$, so\n$$y = D_{\\infty} - \\bigl(k_{H}\\rho^{1/3}\\bigr) s.$$\nA linear regression of $y$ on $s$ has the same intercept $D_{\\infty}$ as a regression on $x$, because if $x=c\\,s$ for a positive constant $c$, then for least-squares fit $y=a+bs$ one has $a=\\bar{y} - \\frac{\\operatorname{cov}(s,y)}{\\operatorname{var}(s)}\\,\\bar{s}$, while for $y=a'+b'x$ one has $a'=\\bar{y} - \\frac{\\operatorname{cov}(x,y)}{\\operatorname{var}(x)}\\,\\bar{x}=\\bar{y} - \\frac{c\\,\\operatorname{cov}(s,y)}{c^{2}\\operatorname{var}(s)}\\,c\\,\\bar{s}=\\bar{y} - \\frac{\\operatorname{cov}(s,y)}{\\operatorname{var}(s)}\\,\\bar{s}=a$.\n\nThus we fit the three data points using $s_{i}=N_{i}^{-1/3}$:\n$$s_{1}=256^{-1/3}=2^{-8/3}\\approx 0.157490131,$$\n$$s_{2}=512^{-1/3}=2^{-3}=0.125,$$\n$$s_{3}=1000^{-1/3}=10^{-1}=0.1,$$\nwith $y_{1}=1.05$, $y_{2}=1.34$, $y_{3}=1.56$.\n\nFor a least-squares line $y=a+ms$,\n$$m=\\frac{\\sum_{i=1}^{3}(s_{i}-\\bar{s})(y_{i}-\\bar{y})}{\\sum_{i=1}^{3}(s_{i}-\\bar{s})^{2}}, \\quad a=\\bar{y}-m\\,\\bar{s},$$\nwith\n$$\\bar{s}=\\frac{s_{1}+s_{2}+s_{3}}{3}\\approx \\frac{0.157490131+0.125+0.1}{3}\\approx 0.127496710,$$\n$$\\bar{y}=\\frac{1.05+1.34+1.56}{3}=\\frac{3.95}{3}\\approx 1.316666667.$$\nCompute the needed sums:\n$$\\sum s_{i}y_{i}\\approx 0.157490131\\cdot 1.05+0.125\\cdot 1.34+0.1\\cdot 1.56\\approx 0.488864638,$$\n$$\\sum s_{i}^{2}\\approx (0.157490131)^{2}+0.125^{2}+0.1^{2}\\approx 0.050428141,$$\n$$\\sum s_{i}\\approx 0.382490131,\\quad \\sum y_{i}=3.95.$$\nThen, using the equivalent formulas\n$$m=\\frac{3\\sum s_{i}y_{i}-(\\sum s_{i})(\\sum y_{i})}{3\\sum s_{i}^{2}-(\\sum s_{i})^{2}}, \\quad a=\\frac{(\\sum y_{i})(\\sum s_{i}^{2})-(\\sum s_{i})(\\sum s_{i}y_{i})}{3\\sum s_{i}^{2}-(\\sum s_{i})^{2}},$$\nwe obtain numerically\n$$a \\approx 2.448 \\quad \\Rightarrow \\quad D_{\\infty}\\approx 2.448.$$\nRounded to three significant figures, this gives\n$$D_{\\infty}\\approx 2.45 \\quad \\text{in units of } \\sigma_{0}^{2}/\\tau_{0}.$$", "answer": "$$\\boxed{2.45}$$", "id": "1980948"}]}