{"hands_on_practices": [{"introduction": "The Turing machine is a cornerstone of theoretical computer science, providing a formal definition of an \"algorithm\". To truly grasp its power and limitations, it's essential to move beyond the abstract definition and analyze its performance on concrete tasks. This exercise [@problem_id:93270] offers a hands-on opportunity to calculate the time complexity of a specific Turing machine by counting the exact number of steps it takes to perform unary multiplication. This detailed analysis builds intuition for how simple, local rules translate into global computation and how we quantify the resources required.", "problem": "A specific Turing machine is defined by the set of states $Q = \\{q_0, q_1, q_2, q_h\\}$, where $q_0$ is the start state and $q_h$ is the halt state. The tape alphabet is $\\Gamma = \\{0, 1, X, \\square\\}$, where $\\square$ is the blank symbol. The machine's behavior is described by the following transition function $\\delta(q, s) = (q', s', d)$, where $q$ is the current state, $s$ is the symbol under the head, $q'$ is the next state, $s'$ is the symbol to be written on the tape, and $d \\in \\{L, R\\}$ is the direction to move the head.\n\nThe transition rules are:\n1.  $\\delta(q_0, 1) = (q_1, X, R)$\n2.  $\\delta(q_0, X) = (q_0, X, R)$\n3.  $\\delta(q_0, 0) = (q_h, 0, R)$\n4.  $\\delta(q_1, 1) = (q_1, 1, R)$\n5.  $\\delta(q_1, 0) = (q_1, 0, R)$\n6.  $\\delta(q_1, \\square) = (q_2, \\square, L)$\n7.  $\\delta(q_2, 1) = (q_2, 1, L)$\n8.  $\\delta(q_2, 0) = (q_2, 0, L)$\n9.  $\\delta(q_2, X) = (q_2, X, L)$\n10. $\\delta(q_2, \\square) = (q_0, \\square, R)$\n\nThe machine starts on a tape containing the string `1^n01^m` for non-negative integers $n$ and $m$, surrounded by blank symbols. The tape configuration is `... \\square \\square 1...1 0 1...1 \\square \\square ...`, where `1...1` has length $n$ and `1...1` has length $m$. The head is initially positioned on the leftmost symbol of the input string. If $n>0$, this is the first '1'. If $n=0$, the string is `01^m`, and the head starts on the '0'.\n\nCalculate the total number of steps the Turing machine takes to enter the halt state $q_h$, as a function of the parameters $n$ and $m$.", "solution": "We analyze one “mark-and-return” cycle, which repeats once for each of the $n$ initial 1’s, then a final sweep to halt.\n\n1. In state $q_0$, on the $i$th cycle the head starts on the leftmost symbol (position 1) and moves right over $i-1$ X’s then reads the $i$th unmarked 1:\n$$\\text{steps in }q_0 = (i-1)+1 = i.$$\n\n2. Upon marking that 1 to X and entering $q_1$, the head moves right from position $i+1$ to the first blank at position $n+2+m$, including the blank cell:\n$$\\text{steps in }q_1 = (n+2+m)-(i+1)+1 = n+m+2-i.$$\n\n3. Upon reading the blank and entering $q_2$, the head moves left from position $n+1+m$ back to the blank at position 0, including that blank:\n$$\\text{steps in }q_2 = (n+1+m)-0+1 = n+m+2.$$\n\n4. Total per cycle (independent of $i$):\n$$i + (n+m+2-i) + (n+m+2) = 2n + 2m + 4.$$\n\n5. Summing over $i=1,\\dots,n$ gives\n$$n(2n+2m+4)=2n^2+2nm+4n.$$\n\n6. After the $n$th cycle, the machine returns to $q_0$ at position 1, skips all $n$ X’s, then reads the 0 and halts. This adds\n$$n + 1$$\nsteps.\n\n7. Total steps:\n$$2n^2 +2nm+4n + (n+1)=2n^2+2nm+5n+1.$$\nOne checks that for $n=0$ the formula gives 1, matching the single-step halt.\n\nThus the machine halts in\n$$2n^2 +2nm+5n +1$$\nsteps.", "answer": "$$\\boxed{2n^2 + 2nm + 5n + 1}$$", "id": "93270"}, {"introduction": "While Turing machines define what is computable, Boolean circuits provide a more practical model for studying the efficiency of computations, particularly those that can be parallelized. However, different types of circuits can have vastly different costs for the same function. This practice [@problem_id:93346] explores this by comparing the required size of a Disjunctive Normal Form (DNF) formula against a standard gate-based circuit for the fundamental parity function. By calculating this ratio, you will uncover an exponential gap in efficiency, a classic result illustrating the power of circuit depth and the limitations of \"shallow\" computational models like DNF.", "problem": "In the study of Boolean function complexity, we are interested in the resources required to represent or compute a function. Two common models of computation are Disjunctive Normal Form (DNF) formulas and Boolean circuits.\n\nThe $n$-bit parity function, $PAR_n: \\{0,1\\}^n \\to \\{0,1\\}$, is defined as $PAR_n(x_1, \\ldots, x_n) = x_1 \\oplus x_2 \\oplus \\ldots \\oplus x_n$, where $\\oplus$ denotes addition modulo 2 (XOR). The function evaluates to 1 if the number of 1s in the input string is odd, and 0 otherwise.\n\nA Boolean formula is in Disjunctive Normal Form (DNF) if it is a disjunction (OR) of one or more conjunctive clauses (ANDs of literals). A literal is either a variable $x_i$ or its negation $\\neg x_i$. The size of a DNF formula is defined as the number of its conjunctive clauses.\n\nA Boolean circuit is a directed acyclic graph where input nodes are labeled with input variables, and internal nodes (gates) are from a specified basis. Here, we consider the standard basis $B = \\{\\text{AND, OR, NOT}\\}$. The AND and OR gates have a fan-in of 2, and NOT gates have a fan-in of 1. The size of a circuit is the total number of gates.\n\nYou are tasked to find the ratio $\\mathcal{R}(n)$ of the minimal DNF size to a specific circuit size for the $n$-bit parity function, for $n \\geq 2$:\n$$\n\\mathcal{R}(n) = \\frac{S_{DNF}^{min}(PAR_n)}{S_C(PAR_n)}\n$$\nwhere:\n1.  $S_{DNF}^{min}(PAR_n)$ is the size of the minimal DNF formula for the $n$-bit parity function.\n2.  $S_C(PAR_n)$ is the size of a circuit that computes $PAR_n$ constructed as a linear cascade of $(n-1)$ 2-input XOR modules. That is, the circuit computes $(((x_1 \\oplus x_2) \\oplus x_3) \\oplus \\dots) \\oplus x_n$. You are given that the minimal circuit size for a 2-input XOR function, $a \\oplus b$, using the basis $B$ is 4.\n\nExpress $\\mathcal{R}(n)$ as a closed-form analytical expression in terms of $n$.", "solution": "The ratio is defined as:\n\n$$\n\\mathcal{R}(n) = \\frac{S_{DNF}^{\\min}(PAR_n)}{S_C(PAR_n)}\n$$\n\nwhere $S_{DNF}^{\\min}(PAR_n)$ is the minimal DNF size for the $n$-bit parity function and $S_C(PAR_n)$ is the size of the specified circuit for $PAR_n$.\n\nFirst, determine $S_{DNF}^{\\min}(PAR_n)$. The $n$-bit parity function $PAR_n(x_1, \\ldots, x_n)$ outputs 1 if the number of 1s in the input is odd. Each satisfying assignment (with an odd number of 1s) must be covered by a distinct conjunctive clause in any DNF for $PAR_n$, because any two such assignments differ in at least two bits and cannot be merged into the same clause. The number of assignments with an odd number of 1s is $2^{n-1}$, as half of the $2^n$ inputs satisfy this condition (by symmetry). Thus, the minimal DNF size is:\n\n$$\nS_{DNF}^{\\min}(PAR_n) = 2^{n-1}\n$$\n\n\nNext, determine $S_C(PAR_n)$. The circuit is a linear cascade of $(n-1)$ 2-input XOR modules, computing $(((x_1 \\oplus x_2) \\oplus x_3) \\oplus \\cdots \\oplus x_n)$. Each 2-input XOR module is implemented with minimal size 4 using the basis $\\{\\text{AND}, \\text{OR}, \\text{NOT}\\}$. Therefore, the total circuit size is:\n\n$$\nS_C(PAR_n) = 4(n-1)\n$$\n\n\nNow, compute the ratio:\n\n$$\n\\mathcal{R}(n) = \\frac{S_{DNF}^{\\min}(PAR_n)}{S_C(PAR_n)} = \\frac{2^{n-1}}{4(n-1)}\n$$\n\nSimplify the expression:\n\n$$\n\\frac{2^{n-1}}{4(n-1)} = \\frac{2^{n-1}}{2^2 (n-1)} = 2^{n-1} \\cdot 2^{-2} \\cdot \\frac{1}{n-1} = \\frac{2^{n-3}}{n-1}\n$$\n\n\nThus, the closed-form analytical expression for $\\mathcal{R}(n)$ is $\\frac{2^{n-3}}{n-1}$.", "answer": "$$ \\boxed{\\dfrac{2^{n-3}}{n-1}} $$", "id": "93346"}, {"introduction": "After exploring how to compute and how to do so efficiently, we turn to the fundamental limits of computation itself. The Post Correspondence Problem (PCP) is a famous puzzle-like problem that, despite its simple statement, is undecidable—no general algorithm can determine if a solution exists for all possible inputs. This exercise [@problem_id:93327] demystifies PCP by tasking you with finding a solution for a specific, solvable instance. By working through the search process, you will gain a concrete understanding of the problem's mechanics, which is crucial for appreciating why PCP represents a fundamental barrier in computation theory.", "problem": "The Post Correspondence Problem (PCP) is a well-known undecidable decision problem in theoretical computer science. An instance of the problem consists of a finite set of \"dominoes,\" where each domino has a string on the top and a string on the bottom. Given a set of $N$ dominoes, represented as pairs of non-empty strings $(t_i, b_i)$ for $i=1, \\dots, N$ over a finite alphabet $\\Sigma$, a \"solution\" to this instance is a sequence of indices $i_1, i_2, \\dots, i_k$ with $k \\ge 1$, such that the concatenation of the top strings equals the concatenation of the bottom strings:\n$$ t_{i_1}t_{i_2}\\dots t_{i_k} = b_{i_1}b_{i_2}\\dots b_{i_k} $$\nThe integer $k$ is called the length of the solution. If a solution exists, there could be multiple solutions, potentially of different lengths.\n\nConsider the following instance of the Post Correspondence Problem with $N=3$ dominoes over the binary alphabet $\\Sigma = \\{0, 1\\}$:\n1.  $(t_1, b_1) = (10, 1)$\n2.  $(t_2, b_2) = (11, 01)$\n3.  $(t_3, b_3) = (01, 101)$\n\nDetermine the length $k$ of the shortest non-empty solution for this specific PCP instance.", "solution": "We are looking for the shortest sequence of indices $i_1, i_2, \\dots, i_k$ such that the top string $T = t_{i_1}t_{i_2}\\dots t_{i_k}$ equals the bottom string $B = b_{i_1}b_{i_2}\\dots b_{i_k}$. We can find this by performing a breadth-first search, checking sequences of length $k=1, 2, 3, \\dots$ until a solution is found.\n\n**k=1:** We check each domino individually.\n*   Domino 1: $t_1 = 10 \\neq b_1 = 1$.\n*   Domino 2: $t_2 = 11 \\neq b_2 = 01$.\n*   Domino 3: $t_3 = 01 \\neq b_3 = 101$.\nNo solution of length 1 exists.\n\n**k=2:** We check all $3^2=9$ sequences of length 2. We can prune the search by observing that for a match to occur, the concatenated top and bottom strings must begin with the same symbol. This requires starting with domino 1, since $t_1$ and $b_1$ both start with '1', whereas for dominoes 2 and 3, the top and bottom strings start with different symbols. Thus, we only need to check sequences starting with index 1.\n*   Sequence (1,1): $T = 1010$, $B = 11$. No match.\n*   Sequence (1,2): $T = 1011$, $B = 101$. No match.\n*   Sequence (1,3): $T = 1001$, $B = 1101$. No match.\nNo solution of length 2 exists.\n\n**k=3:** We continue the search from promising partial sequences. After step (1,2), the top string was `1011` and the bottom was `101`. The bottom string is a prefix of the top. Let's append each domino.\n*   Sequence (1,2,1): $T = 1011 \\cdot 10 = 101110$, $B = 101 \\cdot 1 = 1011$. No match.\n*   Sequence (1,2,2): $T = 1011 \\cdot 11 = 101111$, $B = 101 \\cdot 01 = 10101$. No match.\n*   Sequence (1,2,3): $T = 1011 \\cdot 01 = 101101$, $B = 101 \\cdot 101 = 101101$. The strings match!\n\nWe have found a solution with the sequence of indices `(1, 2, 3)`.\n$$t_1t_2t_3 = 10 \\cdot 11 \\cdot 01 = 101101$$\n$$b_1b_2b_3 = 1 \\cdot 01 \\cdot 101 = 101101$$\nSince we performed a breadth-first search and found no solution for $k=1$ or $k=2$, this solution of length $k=3$ is the shortest.", "answer": "$$\\boxed{3}$$", "id": "93327"}]}