{"hands_on_practices": [{"introduction": "A cornerstone of fault-tolerant quantum computation is \"bootstrapping\"—the art of producing high-quality resource states from fallible physical components. This practice explores a common bootstrapping method known as a \"discard-and-retry\" protocol, used here to prepare a four-qubit ancilla state. By calculating the \"Amortized Infidelity,\" a figure of merit that combines the probability of producing a faulty state with the average number of attempts required, you will gain a quantitative understanding of the critical trade-off between resource overhead and state fidelity that lies at the heart of practical FTQC design [@problem_id:177893].", "problem": "In fault-tolerant quantum computation (FTQC), high-fidelity ancilla states are crucial for procedures like syndrome measurement. A common strategy to produce such states from faulty hardware is \"bootstrapping\" via a \"discard-and-retry\" protocol. This problem analyzes the trade-off between overhead and quality in such a scheme.\n\n**Protocol Details:**\n\n1.  **State Preparation:** A procedure attempts to create a four-qubit cat state, $|\\psi_{cat}\\rangle = \\frac{1}{\\sqrt{2}}(|0000\\rangle + |1111\\rangle)$. The process is imperfect. With probability $1-p_0$, it succeeds and produces the correct state $|\\psi_{cat}\\rangle$. With probability $p_0$, it fails and produces a \"bad\" state, which is orthogonal to $|\\psi_{cat}\\rangle$.\n\n2.  **Verification:** The prepared four-qubit state is verified by measuring three commuting check operators: $M_1=Z_1Z_2$, $M_2=Z_2Z_3$, and $M_3=Z_3Z_4$.\n    *   For the correct state $|\\psi_{cat}\\rangle$, the true measurement outcome for all three operators is +1.\n    *   For any \"bad\" state produced by a preparation failure, the true measurement outcome for each of the three check operators is assumed to be independently and uniformly random (i.e., +1 with probability $1/2$ and -1 with probability $1/2$).\n\n3.  **Faulty Measurements:** The verification measurements are themselves faulty. Each of the three measurements fails with a probability $p_m$. A failure causes the measurement device to report the opposite of the true outcome (e.g., if the true outcome is +1, a faulty measurement reports -1).\n\n4.  **Accept/Reject Condition:** A single attempt consists of state preparation followed by the three verification measurements. The prepared state is \"accepted\" if and only if all three measurements report the outcome +1. Otherwise, the state is discarded, and the entire protocol is repeated from the beginning. This continues until a state is accepted.\n\n**Figure of Merit:**\n\nTo evaluate the effectiveness of this bootstrapping protocol, we define a figure of merit called the \"Amortized Infidelity\", $F$. This is the product of the average resource overhead and the final state's infidelity:\n$$F = N_{avg} \\times I_f$$\nwhere:\n*   $N_{avg}$ is the *average number of attempts* required to obtain one accepted state.\n*   $I_f$ is the *final infidelity*, defined as the probability that an accepted state is, in fact, a \"bad\" state.\n\n**Task:**\n\nCalculate the Amortized Infidelity $F$ for this protocol in terms of the preparation error probability $p_0$ and the measurement error probability $p_m$.", "solution": "The amortized infidelity is defined as $ F = N_{\\text{avg}} \\times I_f $, where:\n- $ N_{\\text{avg}} $ is the average number of attempts required to obtain an accepted state.\n- $ I_f $ is the final infidelity, the probability that an accepted state is bad.\n\nAn attempt is accepted if all three verification measurements report +1. The probability of acceptance, $ P(\\text{accept}) $, is derived by considering the two cases: the state is good (preparation successful) or bad (preparation failed).\n\n**Case 1: Good state (preparation successful)**\n- Probability of good state: $ P(S) = 1 - p_0 $.\n- For a good state, the true outcomes of $ M_1 $, $ M_2 $, and $ M_3 $ are all +1.\n- Each measurement reports the true outcome with probability $ 1 - p_m $ and flips the outcome with probability $ p_m $.\n- Probability that a single measurement reports +1: $ 1 - p_m $.\n- Since measurements are independent, the probability that all three report +1 is:\n  \n$$\n  P(\\text{accept} \\mid S) = (1 - p_m)^3.\n  $$\n\n\n**Case 2: Bad state (preparation failed)**\n- Probability of bad state: $ P(F) = p_0 $.\n- For a bad state, the true outcome of each check operator is independently +1 or -1 with probability $ 1/2 $.\n- For a single measurement, the reported outcome is +1 if:\n  - The true outcome is +1 and no measurement error: probability $ (1/2)(1 - p_m) $.\n  - The true outcome is -1 and a measurement error occurs: probability $ (1/2) p_m $.\n- Total probability that a single measurement reports +1:\n  \n$$\n  P(R = +1) = \\frac{1}{2}(1 - p_m) + \\frac{1}{2} p_m = \\frac{1}{2}.\n  $$\n\n- Since the true outcomes and measurement errors are independent, the reported outcomes are independent. Thus, the probability that all three report +1 is:\n  \n$$\n  P(\\text{accept} \\mid F) = \\left( \\frac{1}{2} \\right)^3 = \\frac{1}{8}.\n  $$\n\n\n**Total probability of acceptance**\n\n$$\nP(\\text{accept}) = P(\\text{accept} \\mid S) P(S) + P(\\text{accept} \\mid F) P(F) = (1 - p_m)^3 (1 - p_0) + \\frac{1}{8} p_0.\n$$\n\n\n**Average number of attempts**\n- The number of attempts follows a geometric distribution with success probability $ P(\\text{accept}) $.\n- The average number of attempts is:\n  \n$$\n  N_{\\text{avg}} = \\frac{1}{P(\\text{accept})} = \\frac{1}{(1 - p_m)^3 (1 - p_0) + \\frac{1}{8} p_0}.\n  $$\n\n\n**Final infidelity**\n- The probability that a state is bad and accepted is:\n  \n$$\n  P(F \\cap \\text{accept}) = P(\\text{accept} \\mid F) P(F) = \\frac{1}{8} p_0.\n  $$\n\n- The final infidelity is the conditional probability:\n  \n$$\n  I_f = P(F \\mid \\text{accept}) = \\frac{P(F \\cap \\text{accept})}{P(\\text{accept})} = \\frac{\\frac{1}{8} p_0}{(1 - p_m)^3 (1 - p_0) + \\frac{1}{8} p_0}.\n  $$\n\n\n**Amortized infidelity**\n\n$$\nF = N_{\\text{avg}} \\times I_f = \\frac{1}{P(\\text{accept})} \\times \\frac{P(F \\cap \\text{accept})}{P(\\text{accept})} = \\frac{P(F \\cap \\text{accept})}{[P(\\text{accept})]^2}.\n$$\n\nSubstituting the expressions:\n\n$$\nF = \\frac{\\frac{1}{8} p_0}{\\left[ (1 - p_m)^3 (1 - p_0) + \\frac{1}{8} p_0 \\right]^2}.\n$$\n\nSimplifying the denominator:\n\n$$\n(1 - p_m)^3 (1 - p_0) + \\frac{1}{8} p_0 = \\frac{8 (1 - p_m)^3 (1 - p_0) + p_0}{8},\n$$\n\nso:\n\n$$\n[P(\\text{accept})]^2 = \\left( \\frac{8 (1 - p_m)^3 (1 - p_0) + p_0}{8} \\right)^2 = \\frac{[8 (1 - p_m)^3 (1 - p_0) + p_0]^2}{64}.\n$$\n\nThus:\n\n$$\nF = \\frac{\\frac{1}{8} p_0}{\\frac{[8 (1 - p_m)^3 (1 - p_0) + p_0]^2}{64}} = \\frac{p_0}{8} \\cdot \\frac{64}{[8 (1 - p_m)^3 (1 - p_0) + p_0]^2} = \\frac{8 p_0}{[8 (1 - p_m)^3 (1 - p_0) + p_0]^2}.\n$$\n\nThe amortized infidelity is:\n\n$$\nF = \\frac{8 p_0}{\\left( 8 (1 - p_m)^3 (1 - p_0) + p_0 \\right)^2}.\n$$", "answer": "$$ \\boxed{ \\dfrac{ 8 p_0 }{ \\left( 8 (1 - p_m)^3 (1 - p_0) + p_0 \\right)^2 } } $$", "id": "177893"}, {"introduction": "While increasing the size of an error-correcting code generally offers better protection, it also increases the number of physical components and operations, providing more opportunities for faults to occur. This exercise puts you in the role of a quantum architect, tasking you with finding the optimal size for a repetition-code ancilla used in a stabilizer measurement. By modeling the total error as a sum of competing effects—one that decreases with the ancilla size $n$ and one that increases with it—you will use basic calculus to strike the perfect balance, a routine yet essential task in minimizing logical errors and managing overhead in any realistic fault-tolerant system [@problem_id:178012].", "problem": "In fault-tolerant quantum computation (FTQC), a key procedure is the measurement of stabilizer generators of a quantum error-correcting code. This measurement must itself be fault-tolerant, meaning a small number of faults in the measurement circuit should not lead to an undetected error in the measurement outcome. A common technique involves using an ancilla block which is itself a small error-correcting code.\n\nConsider the measurement of a stabilizer of the Steane code. This procedure uses an ancilla system based on a 1D repetition code of length $n$, where $n$ is a positive odd integer representing the number of ancilla qubits. The choice of $n$ involves a trade-off: a larger $n$ provides better intrinsic error suppression, but increases the circuit complexity, thus providing more opportunities for faults to occur.\n\nAn analysis of the leading-order contributions to the effective probability of error for the stabilizer measurement, $P_{\\text{eff}}(n)$, yields the following model, which balances these two effects:\n$$P_{\\text{eff}}(n) = P_{\\text{overhead}}(n) + P_{\\text{leakage}}(n)$$\nwhere:\n1.  $P_{\\text{overhead}}(n) = \\alpha n^2$. This term represents the probability of a logical error arising from pairs of faults in the ancilla control circuitry. The quadratic dependence on $n$ arises because the number of gate locations in the circuit is proportional to $n$, and the leading cause of logical errors are pairs of faults, whose number scales as the square of the number of locations. The parameter $\\alpha$ is a positive constant derived from the physical gate error rate.\n2.  $P_{\\text{leakage}}(n) = \\beta/n$. This term accounts for the failure of the repetition code to suppress a specific kind of ambient, non-local noise. For this noise model, the probability that the noise causes an undetected logical error is found to be inversely proportional to the code distance, which is $n$ for the repetition code. The parameter $\\beta$ is a positive constant characterizing the strength of this ambient noise.\n\nYour task is to find the optimal size of the ancilla verifier. Treating $n$ as a continuous positive variable, determine the value $n_{\\text{opt}}$ that minimizes the total effective error probability $P_{\\text{eff}}(n)$. Express your answer as a symbolic expression in terms of $\\alpha$ and $\\beta$.", "solution": "The effective error probability is given by:\n\n$$ P_{\\text{eff}}(n) = \\alpha n^2 + \\frac{\\beta}{n} $$\n\nTo find the minimum, take the derivative with respect to $ n $ and set it to zero:\n\n$$ \\frac{dP_{\\text{eff}}}{dn} = 2\\alpha n - \\beta n^{-2} = 0 $$\n\nSolving the equation:\n\n$$ 2\\alpha n = \\frac{\\beta}{n^2} $$\n\n\n$$ 2\\alpha n^3 = \\beta $$\n\n\n$$ n^3 = \\frac{\\beta}{2\\alpha} $$\n\n\n$$ n = \\left( \\frac{\\beta}{2\\alpha} \\right)^{1/3} $$\n\nConfirming it is a minimum by checking the second derivative:\n\n$$ \\frac{d^2P_{\\text{eff}}}{dn^2} = 2\\alpha + 2\\beta n^{-3} = 2\\alpha + \\frac{2\\beta}{n^3} $$\n\nSince $ \\alpha > 0 $, $ \\beta > 0 $, and $ n > 0 $, the second derivative is positive, confirming a minimum.", "answer": "$$ \\boxed{\\left( \\frac{\\beta}{2\\alpha} \\right)^{1/3}} $$", "id": "178012"}, {"introduction": "The celebrated threshold theorem promises that we can make logical error rates arbitrarily low by concatenating codes, provided the physical error rate is below a certain threshold. This advanced exercise gives you a concrete taste of this principle by analyzing a two-level concatenated Steane code. You will assess how errors at the first logical level—which can manifest either as an uncorrectable logical Pauli error or a detectable \"erasure\"—propagate to the second level of encoding. This practice is crucial for understanding how the structure of concatenated codes, and their ability to handle different types of failures, leads to the powerful exponential suppression of errors that makes large-scale quantum computation possible [@problem_id:177956].", "problem": "Consider a fault-tolerant quantum computer architecture based on a two-level concatenation of the `[[7,1,3]]` Steane code. The physical qubits are subject to a depolarizing channel where each qubit experiences an error with probability $p \\ll 1$ per elementary time step or gate operation.\n\nThe Steane code has a distance $d=3$. A code with distance $d$ can correct any combination of $k$ Pauli errors and $e$ erasure errors as long as the condition $2k+e < d$ is satisfied.\n\nAt the first level of concatenation (level-1), a logical qubit is encoded in 7 physical qubits. After a full error correction (EC) cycle, a level-1 logical qubit can emerge in one of three states:\n1.  **Correct:** The block is error-free.\n2.  **Failed (Pauli Error):** The block suffers an uncorrectable logical Pauli error ($\\bar{X}$, $\\bar{Y}$, or $\\bar{Z}$). This occurs mainly due to pairs of physical faults that are miscorrected into a logical operator. The total probability for such a failure is $p_{fail}^{(1)} = A p^2$, where $A$ is a constant.\n3.  **Damaged (Erasure):** A specific, non-standard failure mode exists. With a certain probability, a combination of a single physical fault and a transient fault in the classical decoding hardware leads to a post-correction physical error on the block (e.g., a weight-2 Pauli error) which is detectable but not a logical operator. The higher-level protocol identifies such \"damaged\" blocks and treats them as erased logical qubits. The probability of a level-1 block becoming damaged is $p_{dam}^{(1)} = B p^2$, where $B$ is another constant.\n\nA level-2 logical qubit is encoded using 7 of these level-1 logical qubits. The level-2 EC protocol is capable of correcting Pauli and erasure errors on the level-1 blocks according to the `[[7,1,3]]` code's capabilities.\n\nDerive the total logical error probability, $p^{(2)}$, for a level-2 qubit. Your derivation should be to the lowest non-vanishing order in the physical error probability $p$. Express your answer in terms of the given constants $A$ and $B$, and the physical error rate $p$.", "solution": "The level-2 logical error probability, $ p^{(2)} $, is derived by considering the failure modes of the level-2 error correction (EC) for the concatenated [[7,1,3]] Steane code. Each level-1 logical qubit (block) can be in one of three states after EC:\n- Correct with probability $ 1 - A p^2 - B p^2 + O(p^3) $\n- Failed (Pauli error) with probability $ p_{\\text{fail}}^{(1)} = A p^2 $\n- Damaged (erasure) with probability $ p_{\\text{dam}}^{(1)} = B p^2 $\n\nThe level-2 EC uses the [[7,1,3]] code, which can correct combinations of $ k $ Pauli errors and $ e $ erasure errors on level-1 blocks if $ 2k + e < 3 $. The EC fails (leading to a logical error at level-2) for uncorrectable patterns. To the lowest non-vanishing order in $ p $ (which is $ p^4 $, since each level-1 failure is $ O(p^2) $), the uncorrectable patterns are:\n1. Two or more failed (Pauli error) level-1 blocks.\n2. One failed and at least one damaged (erasure) level-1 block.\n\nThe probability of these events is calculated, neglecting higher-order terms ($ O(p^6) $ and above).\n\n- **Two failed blocks**: The number of ways to choose two blocks out of seven is $ \\binom{7}{2} = 21 $. The probability for a specific pair to be failed is $ (A p^2)^2 = A^2 p^4 $. The other five blocks must be correct to leading order (probability $ \\approx 1 $), so the contribution is:\n  \n$$\n  \\binom{7}{2} (A p^2)^2 = 21 A^2 p^4\n  $$\n\n\n- **One failed and one damaged block**: Choose one block for failure ($ \\binom{7}{1} = 7 $ ways) and one distinct block for damage ($ \\binom{6}{1} = 6 $ ways). The probability for a specific failed block is $ A p^2 $, and for a specific damaged block is $ B p^2 $. The other five blocks must be correct to leading order (probability $ \\approx 1 $), so the contribution is:\n  \n$$\n  7 \\times 6 \\times (A p^2) \\times (B p^2) = 42 A B p^4\n  $$\n\n\nEvents with more than two failures (e.g., three failed blocks, or two failed and one damaged) are $ O(p^6) $ or higher and are neglected. Similarly, three or more damaged blocks alone are $ O(p^6) $.\n\nSumming the contributions:\n\n$$\np^{(2)} = 21 A^2 p^4 + 42 A B p^4 + O(p^6) = 21 A (A + 2B) p^4\n$$\n\n\nThis is the total logical error probability for the level-2 qubit to leading order.", "answer": "$$\\boxed{21 A (A + 2B) p^{4}}$$", "id": "177956"}]}