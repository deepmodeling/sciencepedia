{"hands_on_practices": [{"introduction": "We begin by examining a foundational concept in fault tolerance: the distinction between a static qubit error and a dynamic gate fault. This exercise [@problem_id:83521] uses the elementary 3-qubit repetition code to reveal how a single error during the error-correction process itself can be more dangerous than an error on the data. By tracing how a faulty CNOT gate corrupts the syndrome measurement, you will see how an initially perfect state can end up with a logical error, motivating the need for carefully designed fault-tolerant protocols.", "problem": "A distance-3 repetition code is used to protect a logical qubit against bit-flip ($X$) errors. The logical basis states are defined as $|0\\rangle_L = |000\\rangle$ and $|1\\rangle_L = |111\\rangle$. Error detection and correction are achieved by measuring the two stabilizer generators $S_1 = Z_1 Z_2$ and $S_2 = Z_2 Z_3$, where $Z_i$ is the Pauli-$Z$ operator on qubit $i$.\n\nThe measurement of a stabilizer $Z_i Z_j$ is performed using an ancillary qubit, denoted as the ancilla. The ancilla is initialized in the state $|0\\rangle_a$, and then a circuit consisting of two consecutive CNOT gates, CNOT($i, a$) followed by CNOT($j, a$), is applied. The measurement of the ancilla in the computational basis $\\{|0\\rangle, |1\\rangle\\}$ yields the syndrome bit. An outcome of 0 corresponds to a syndrome bit $s=0$ (stabilizer eigenvalue $+1$), and an outcome of 1 corresponds to $s=1$ (stabilizer eigenvalue $-1$).\n\nConsider a logical qubit initialized in the error-free state $|0\\rangle_L$. A single cycle of error correction is initiated, where the syndrome for $S_1$ is measured first, followed by the syndrome measurement for $S_2$.\n\nA single fault occurs during this cycle: in the measurement of the first stabilizer $S_1 = Z_1 Z_2$, the second CNOT gate, CNOT(2, a), is faulty. The faulty gate performs the standard CNOT(2, a) operation but also applies a Pauli $X$ error to its control qubit (data qubit 2). All other gates and measurements in the entire error correction cycle are assumed to be perfect.\n\nThe correction procedure is based on the measured syndrome pair $(s_1, s_2)$. It assumes that at most one single-qubit $X$ error has occurred and applies the corresponding Pauli $X$ correction to the data qubit that uniquely corresponds to the measured syndrome. If the syndrome is (0,0), no correction is applied.\n\nCalculate the probability that this single fault results in a logical error. A logical error is defined as the event where the final state of the data qubits, after the correction step, would be decoded as $|1\\rangle_L$ by a subsequent, perfect round of error correction.", "solution": "The initial state is $|0\\rangle_L = |000\\rangle$. The error correction cycle begins with the measurement of $S_1 = Z_1 Z_2$ using an ancilla initialized to $|0\\rangle_a$.\n\n- Apply CNOT(1, a): the control qubit is qubit 1 (state $|0\\rangle$), so the ancilla remains unchanged. State: $|000\\rangle |0\\rangle_a$.\n- The second CNOT gate, CNOT(2, a), is faulty. First, it performs the standard CNOT(2, a): control qubit 2 is $|0\\rangle$, so the ancilla remains unchanged. State: $|000\\rangle |0\\rangle_a$. Then, it applies an $X$ error to qubit 2, flipping it to $|1\\rangle$. State: $|010\\rangle |0\\rangle_a$.\n- Measure the ancilla: outcome is 0 (since it is $|0\\rangle$), so syndrome bit $s_1 = 0$.\n- After measurement, discard the ancilla. Data state: $|010\\rangle$.\n\nNext, measure $S_2 = Z_2 Z_3$ with a new ancilla initialized to $|0\\rangle_a$.\n\n- Apply CNOT(2, a): control qubit 2 is $|1\\rangle$, so the ancilla flips. State: $|010\\rangle |1\\rangle_a$.\n- Apply CNOT(3, a): control qubit 3 is $|0\\rangle$, so no change. State: $|010\\rangle |1\\rangle_a$.\n- Measure the ancilla: outcome is 1, so syndrome bit $s_2 = 1$.\n- Syndrome pair: $(s_1, s_2) = (0, 1)$.\n\nThe correction procedure for syndrome (0,1) assumes a single $X$ error on qubit 3 and applies $X_3$.\n\n- Apply $X$ to qubit 3: state changes from $|010\\rangle$ to $|011\\rangle$.\n\nThe final state is $|011\\rangle$. A subsequent perfect round of error correction would decode this state:\n\n- Measure $S_1 = Z_1 Z_2$: \n  - $Z_1 Z_2 |011\\rangle = Z_1 |0\\rangle \\otimes Z_2 |1\\rangle \\otimes |1\\rangle = (+1)|0\\rangle \\otimes (-1)|1\\rangle \\otimes |1\\rangle = -|011\\rangle$, so eigenvalue $-1$, syndrome bit $s_1 = 1$.\n- Measure $S_2 = Z_2 Z_3$:\n  - $Z_2 Z_3 |011\\rangle = |0\\rangle \\otimes Z_2 |1\\rangle \\otimes Z_3 |1\\rangle = |0\\rangle \\otimes (-|1\\rangle) \\otimes (-|1\\rangle) = (+1)|011\\rangle$, so eigenvalue $+1$, syndrome bit $s_2 = 0$.\n- Syndrome (1,0) corresponds to an $X$ error on qubit 1. Apply $X_1$: $|011\\rangle$ becomes $|111\\rangle = |1\\rangle_L$.\n\nThe state is decoded as $|1\\rangle_L$, a logical error, since the initial state was $|0\\rangle_L$. The fault always leads to this outcome, as the evolution is deterministic with no branching.\n\nTherefore, the probability of a logical error is 1.", "answer": "$$ \\boxed{1} $$", "id": "83521"}, {"introduction": "While error-correcting codes protect quantum states, universal computation requires non-Clifford gates, which are notoriously resource-intensive to implement fault-tolerantly. The dominant paradigm involves \"magic state distillation,\" and this practice problem asks you to analyze the \"state factory\" that produces these essential resources. Calculating the expected resource cost, while accounting for probabilistic success and state recycling, provides a practical perspective on the overheads that will dominate large-scale quantum algorithms.", "problem": "In fault-tolerant quantum computation schemes, such as those using the Steane [[7,1,3]] code, logical operations from the Clifford group (e.g., Hadamard, Phase, CNOT) can often be implemented transversally, making them relatively low-cost. However, non-Clifford gates, like the $T$ gate ($T = \\text{diag}(1, e^{i\\pi/4})$), are essential for universal quantum computation but are much more expensive to implement fault-tolerantly.\n\nA common method for implementing a logical $T$ gate is through \"magic state injection\". This involves preparing a specialized ancilla qubit in a \"magic state\" and consuming it. These magic states must be prepared with very high fidelity, a task accomplished by a \"magic state distillation factory\".\n\nConsider a factory that runs an \"$N_{in}$-to-1\" distillation protocol. For each attempt, the protocol consumes $N_{in}$ physical magic states.\n- With a probability $p_{succ}$, the attempt is successful, producing one high-fidelity logical magic state. In this case, it is also determined that $k$ of the initial $N_{in}$ states were not corrupted by errors and can be returned to the pool of available physical states.\n- With a probability $1-p_{succ}$, the attempt fails. No logical magic state is produced, and all $N_{in}$ physical states are considered lost.\n\nFor the factory to be a net consumer of states (i.e., not a perpetual motion machine), it must satisfy the condition $N_{in} > k p_{succ}$.\n\nA logical Controlled-Phase gate ($CS$, or controlled-$S$ gate), which is a non-Clifford gate, is required for a particular algorithm. A standard decomposition of the logical $CS$ gate requires the execution of several logical Clifford gates and three logical T-family gates ($T$ or $T^\\dagger$). Assume that the cost of preparing a magic state for a $T^\\dagger$ gate is identical to that for a $T$ gate. The cost of the logical Clifford gates is considered negligible in comparison to the magic state preparation.\n\nCalculate the expected number of *net* physical magic states that are consumed to implement a single logical $CS$ gate. Your answer should be expressed in terms of the parameters $N_{in}$, $k$, and $p_{succ}$.", "solution": "To find the expected number of net physical magic states consumed to implement a single logical $CS$ gate, note that the gate requires three logical $T$-family gates (each $T$ or $T^\\dagger$). Each $T$-family gate requires one logical magic state, so three logical magic states are needed.\n\nThe expected net consumption of physical magic states to produce one logical magic state, denoted $E$, satisfies the equation derived from the distillation protocol:\n- With probability $p_{succ}$, the attempt succeeds: net consumption is $N_{in} - k$ physical states (consuming $N_{in}$ but returning $k$ uncorrupted states), and no further cost is incurred.\n- With probability $1 - p_{succ}$, the attempt fails: net consumption is $N_{in}$ physical states (all lost), and the process restarts, incurring an additional expected cost $E$.\n\nThus, the equation for $E$ is:\n\n$$\nE = p_{succ} (N_{in} - k) + (1 - p_{succ}) (N_{in} + E)\n$$\n\nSolving for $E$:\n\n$$\nE = p_{succ} N_{in} - p_{succ} k + (1 - p_{succ}) N_{in} + (1 - p_{succ}) E\n$$\n\n\n$$\nE = N_{in} - p_{succ} k + (1 - p_{succ}) E\n$$\n\n\n$$\nE - (1 - p_{succ}) E = N_{in} - p_{succ} k\n$$\n\n\n$$\np_{succ} E = N_{in} - p_{succ} k\n$$\n\n\n$$\nE = \\frac{N_{in} - p_{succ} k}{p_{succ}} = \\frac{N_{in}}{p_{succ}} - k\n$$\n\nThis is the expected net physical magic states consumed per logical magic state. For three logical magic states, the total expected net consumption is:\n\n$$\n3E = 3 \\left( \\frac{N_{in}}{p_{succ}} - k \\right)\n$$\n\nThe production of each logical magic state is identical and independent, and the expression for $E$ accounts for the reuse of returned physical states within the distillation process for that state. Therefore, the total expected net consumption for three logical magic states is $3E$.", "answer": "$$\\boxed{3\\left(\\frac{N_{in}}{p_{succ}} - k\\right)}$$", "id": "83631"}, {"introduction": "A fault-tolerant system is only as good as its classical decoder. This final exercise [@problem_id:83509] explores a critical failure mode of the widely-used minimum-weight perfect matching (MWPM) decoder on the surface code. You will analyze a scenario where a single physical error creates an ambiguous syndrome due to the code's boundary. This leads to a \"decoder degeneracy,\" where the choice between pairing two defects directly versus pairing them to the boundary have the same likelihood, creating a significant probability of logical failure.", "problem": "Consider a distance $d=3$ rotated surface code defined on a $3 \\times 3$ grid of data qubits. The data qubits are located at integer coordinates $(i,j)$ for $i,j \\in \\{0, 1, 2\\}$. The code has four $Z$-type plaquette stabilizers, $S_k$, whose locations can be identified with the centers of the four elementary squares of the grid: $s_1 \\to (0.5, 0.5)$, $s_2 \\to (1.5, 0.5)$, $s_3 \\to (0.5, 1.5)$, and $s_4 \\to (1.5, 1.5)$. An $X$ error on a data qubit at $(i,j)$ flips the measurement outcome of the adjacent $Z$-stabilizers. For instance, an $X$ error on qubit $q_{0,1}$ creates a syndrome pair $\\{s_1, s_3\\}$.\n\nThe correction of $X$ errors is performed using a minimum-weight perfect-matching (MWPM) algorithm. The algorithm finds a set of paths (error chains) that pair up all the syndrome defects with either each other or with a boundary, such that the total weight (length) of the paths is minimized. The weight of a path between two points is their Manhattan distance.\n\nSuppose the system experiences a single-qubit $X$ error on data qubit $q_{0,1}$. The syndrome measurement will thus reveal two excited stabilizers. The MWPM decoder must pair them. However, it can also pair each defect to the nearest boundary. If there are multiple pairings with the same minimum weight (a degeneracy), the decoder chooses one of them uniformly at random.\n\nA logical error occurs if the applied correction operator $C$, combined with the initial error $E$, results in a net operation $E' = C \\cdot E$ that is equivalent to a non-trivial logical operator $X_L$. A logical $X_L$ operator for this code is a string of $X$ operators connecting the top boundary of the code to the bottom boundary, such as $X_L = X_{i,0}X_{i,1}X_{i,2}$ for any column $i$.\n\nCalculate the probability that the MWPM decoding procedure for the given error $E = X_{0,1}$ results in a logical $X_L$ error.", "solution": "1.  **Identify the Syndrome:**\n    The initial error is $E = X_{0,1}$, a single Pauli $X$ operator on the data qubit at coordinates $(0,1)$. A data qubit at $(i,j)$ is adjacent to $Z$-stabilizer plaquettes at $(i-0.5, j-0.5)$, $(i+0.5, j-0.5)$, $(i-0.5, j+0.5)$, and $(i+0.5, j+0.5)$, if they are on the grid.\n    For qubit $q_{0,1}$, the adjacent plaquettes on the grid are at $(0-0.5, 1-0.5)=(-0.5,0.5)$ (off-grid), $(0+0.5, 1-0.5)=(0.5,0.5)$ (which is $s_1$), $(0-0.5, 1+0.5)=(-0.5,1.5)$ (off-grid), and $(0+0.5, 1+0.5)=(0.5,1.5)$ (which is $s_3$).\n    Thus, the error $X_{0,1}$ creates a syndrome consisting of two defects: $\\{s_1, s_3\\}$.\n\n2.  **Find Minimum-Weight Matchings:**\n    The MWPM decoder must pair the defects $\\{s_1, s_3\\}$. There are two plausible ways to do this with minimal weight:\n    *   **Matching 1 (Direct Pairing):** Pair $s_1$ directly with $s_3$. The weight of this pairing is the Manhattan distance between their locations:\n        $W_1 = w(s_1, s_3) = |0.5-0.5| + |1.5-0.5| = 1$.\n    *   **Matching 2 (Boundary Pairing):** Pair each defect to the nearest boundary. The nearest boundary for both defects is the left boundary (at $x=0$).\n        *   The distance from $s_1(0.5, 0.5)$ to the left boundary is $0.5$.\n        *   The distance from $s_3(0.5, 1.5)$ to the left boundary is $0.5$.\n        *   The total weight for this pairing is $W_2 = 0.5 + 0.5 = 1$.\n\n3.  **Analyze the Decoder's Choice:**\n    Since both matchings have the same minimum weight ($W_1 = W_2 = 1$), the decoder faces a degeneracy. It will choose one of the two matchings uniformly at random, each with a probability of $1/2$.\n\n4.  **Determine the Outcome of Each Correction:**\n    *   **Correction for Matching 1:** The direct pairing corresponds to an error chain of length 1 connecting $s_1$ and $s_3$. This chain is the single error $X_{0,1}$. The decoder applies the correction $C_1 = X_{0,1}$. The net error on the system is $C_1 \\cdot E = X_{0,1} \\cdot X_{0,1} = I$ (the identity operator). This successfully corrects the error. No logical error occurs.\n    *   **Correction for Matching 2:** The boundary pairing corresponds to two error chains. One connects $s_1$ to the left boundary (error $X_{0,0}$), and the other connects $s_3$ to the left boundary (error $X_{0,2}$). The decoder applies the correction $C_2 = X_{0,0} \\otimes X_{0,2}$. The net error on the system is $C_2 \\cdot E = (X_{0,0} \\otimes X_{0,2}) \\cdot X_{0,1} = X_{0,0} \\otimes X_{0,1} \\otimes X_{0,2}$. This operator is a string of Pauli $X$ operators on all qubits in column 0, connecting the bottom boundary to the top boundary. By definition, this is a logical operator $X_L$. A logical error occurs.\n\n5.  **Calculate the Probability:**\n    The decoder chooses Matching 1 with probability $1/2$, resulting in no logical error. It chooses Matching 2 with probability $1/2$, resulting in a logical error.\n    Therefore, the total probability of a logical error is $1/2$.", "answer": "$$\\boxed{\\frac12}$$", "id": "83509"}]}