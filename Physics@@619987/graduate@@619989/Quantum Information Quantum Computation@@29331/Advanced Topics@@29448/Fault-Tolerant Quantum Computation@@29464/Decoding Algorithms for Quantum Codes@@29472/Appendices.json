{"hands_on_practices": [{"introduction": "Many powerful quantum codes, such as the toric code, possess an intuitive geometric structure that simplifies understanding error correction. In these codes, physical errors manifest as \"defects\" or \"syndromes\" on a lattice, and the decoding process can be visualized as finding paths to pair up these defects. This first exercise [@problem_id:66247] provides a hands-on opportunity to apply a simple greedy algorithm, which iteratively matches the closest pair of syndromes. This practice builds fundamental intuition for syndrome-matching, a concept at the heart of more sophisticated decoding strategies like Minimum-Weight Perfect Matching.", "problem": "The toric code is a quantum error-correcting code defined on a two-dimensional square lattice with periodic boundary conditions (a torus). Qubits are placed on the edges of the lattice. The code is stabilized by two types of operators: star operators $A_s = \\prod_{j \\in s} X_j$ for each vertex $s$, and plaquette operators $B_p = \\prod_{j \\in \\partial p} Z_j$ for each plaquette $p$.\n\nPauli $X$ errors on qubits can cause pairs of adjacent plaquette operators to yield an outcome of $-1$ when measured. These plaquettes with a $-1$ outcome are called Z-syndromes. The goal of decoding is to infer the X-error chain from the syndrome locations and apply a correction chain of X operators to restore the state to the codespace. The correction chain must pair up all the syndromes. The problem of finding the most likely error configuration is equivalent to finding a set of paths pairing the syndromes with minimum total length (weight).\n\nConsider a toric code on a sufficiently large $L \\times L$ lattice. An error event creates four Z-syndromes, located at plaquettes $p_1, p_2, p_3, p_4$. The centers of these plaquettes can be described by integer coordinates $(x,y)$ on a dual lattice. The syndrome locations are given by $p_1=(0,0)$, $p_2=(W,0)$, $p_3=(0,H)$, and $p_4=(W,H)$, forming a rectangle. The distance between two syndromes is their Manhattan distance on the dual lattice, $d((x_i, y_i), (x_j, y_j)) = |x_i - x_j| + |y_i - y_j|$. This distance corresponds to the weight of the shortest X-operator chain connecting the two plaquettes.\n\nA simple decoding strategy is the greedy closest-pair algorithm. It works as follows:\n1.  Start with the set of all syndromes.\n2.  Find the pair of not-yet-matched syndromes with the minimum Manhattan distance.\n3.  Match this pair. The weight of the corresponding correction chain is this minimum distance.\n4.  Remove the matched pair from the set of syndromes to be considered.\n5.  Repeat steps 2-4 until all syndromes are paired.\n\nIn case of a tie for the closest pair, the pair $(p_i, p_j)$ with $ij$ that is lexicographically first is chosen. For example, if $(p_1, p_3)$ and $(p_2, p_4)$ are both closest pairs, $(p_1, p_3)$ is chosen because $(1,3)$ comes before $(2,4)$ lexicographically.\n\nGiven the syndrome rectangle dimensions $W$ and $H$, calculate the total weight of the correction determined by this greedy algorithm. For this problem, use $W=3$ and $H=1$.", "solution": "1. Syndrome coordinates: \n   $p_1=(0,0)$, $p_2=(W,0)$, $p_3=(0,H)$, $p_4=(W,H)$ with $W=3$, $H=1$.  \n2. Compute Manhattan distances $d_{ij}=|x_i-x_j|+|y_i-y_j|$:\n   $$d_{12}=|0-3|+|0-0|=3,\\quad d_{13}=|0-0|+|0-1|=1,$$\n   $$d_{14}=|0-3|+|0-1|=4,\\quad d_{23}=|3-0|+|0-1|=4,$$\n   $$d_{24}=|3-3|+|0-1|=1,\\quad d_{34}=|0-3|+|1-1|=3.$$\n3. The minimum distance is $1$, achieved by pairs $(p_1,p_3)$ and $(p_2,p_4)$. By lexicographic tie-breaking we choose $(p_1,p_3)$ first.  \n   Weight of this match: $d_{13}=1$.  \n4. Remove $p_1,p_3$. Remaining syndromes $p_2,p_4$ have distance $d_{24}=1$.  \n   Weight of this match: $1$.  \n5. Total correction weight $=1+1=2$.", "answer": "$$\\boxed{2}$$", "id": "66247"}, {"introduction": "While intuitive, simple greedy algorithms have limitations. The most straightforward correction for a given syndrome—often the one with the smallest number of physical operations—is not always the correct one, potentially leaving a residual error that corrupts the logical information. This exercise [@problem_id:66362] delves into such a scenario using the famous [[7,1,3]] Steane code. You will see how a simple weight-2 error can mislead a decoder that only seeks the minimum-weight correction, demonstrating the challenges posed by codes where different errors can produce the same syndrome.", "problem": "An important task in quantum computation is correcting errors that corrupt quantum states. The [[7,1,3]] Steane code is a well-known quantum error-correcting code that encodes one logical qubit into seven physical qubits and can correct any single-qubit error. It is a CSS code defined by a set of stabilizer generators. For this problem, we will use the following standard set of stabilizer generators:\nThe three $X$-type stabilizers are:\n$S_1^X = X_1 X_3 X_5 X_7$\n$S_2^X = X_2 X_3 X_6 X_7$\n$S_3^X = X_4 X_5 X_6 X_7$\n\nAnd the three $Z$-type stabilizers are:\n$S_1^Z = Z_1 Z_3 Z_5 Z_7$\n$S_2^Z = Z_2 Z_3 Z_6 Z_7$\n$S_3^Z = Z_4 Z_5 Z_6 Z_7$\n\nHere, $X_i, Y_i, Z_i$ are the Pauli operators acting on the $i$-th qubit, indexed from 1 to 7.\n\nSuppose the encoded quantum state is subjected to a weight-2 Pauli-$X$ error given by the operator $E = X_1 X_2$. To correct this error, the following procedure is applied:\n1. The $Z$-type stabilizers ($S_1^Z, S_2^Z, S_3^Z$) are measured. The outcome of measuring $S_j^Z$ is $m_j \\in \\{+1, -1\\}$. The classical syndrome is a bit string $s = (s_1, s_2, s_3)$, where $s_j = (1-m_j)/2$. An error $E$ produces a syndrome bit $s_j=1$ if it anti-commutes with $S_j^Z$, and $s_j=0$ if it commutes.\n2. A decoding algorithm is used to infer a correction operator $C$ from the syndrome $s$. The algorithm we consider is a greedy one: it identifies the Pauli $X$-operator $C$ of the minimum possible Hamming weight that would produce the observed syndrome $s$. The Hamming weight of a Pauli operator is the number of qubits on which it acts non-trivially (i.e., not as the identity operator $I$).\n3. The correction operator $C$ is applied to the system.\n\nThe residual error after this procedure is given by the operator $E_{res} = C E$. This residual error may not be the identity operator, meaning the correction was not successful.\n\nYour task is to compute the Hamming weight of the residual error operator $E_{res}$.", "solution": "The error operator is $E = X_1 X_2$. The Z-type stabilizers and their syndrome bits are computed as follows:\n\n- $S_1^Z = Z_1 Z_3 Z_5 Z_7$: $E$ and $S_1^Z$ both act non-trivially on qubit 1. Since $X$ and $Z$ anti-commute, and there is one common qubit (odd), they anti-commute. Thus, $s_1 = 1$.\n- $S_2^Z = Z_2 Z_3 Z_6 Z_7$: $E$ and $S_2^Z$ both act non-trivially on qubit 2. With one common qubit (odd), they anti-commute. Thus, $s_2 = 1$.\n- $S_3^Z = Z_4 Z_5 Z_6 Z_7$: $E$ acts on qubits 1 and 2, while $S_3^Z$ acts on qubits 4, 5, 6, and 7. No common qubits, so they commute. Thus, $s_3 = 0$.\n\nThe syndrome is $s = (1, 1, 0)$. The correction operator $C$ is a Pauli X-operator of minimum Hamming weight that produces this syndrome. Represent $C$ by a binary vector $(v_1, v_2, \\dots, v_7)$ where $v_i = 1$ if $X_i$ is included, and $v_i = 0$ otherwise. The syndrome equations are:\n\n- $v_1 + v_3 + v_5 + v_7 \\equiv 1 \\pmod{2}$ (from $s_1 = 1$)\n- $v_2 + v_3 + v_6 + v_7 \\equiv 1 \\pmod{2}$ (from $s_2 = 1$)\n- $v_4 + v_5 + v_6 + v_7 \\equiv 0 \\pmod{2}$ (from $s_3 = 0$)\n\nSearching for solutions by Hamming weight:\n\n- Weight 0: $(0,0,0,0,0,0,0)$ gives syndrome $(0,0,0)$, not $(1,1,0)$.\n- Weight 1: Test vectors with exactly one $v_i = 1$:\n  - $(1,0,0,0,0,0,0)$: $1+0+0+0=1$, $0+0+0+0=0 \\neq 1$ — invalid.\n  - $(0,1,0,0,0,0,0)$: $0+0+0+0=0 \\neq 1$, $1+0+0+0=1$ — invalid.\n  - $(0,0,1,0,0,0,0)$: $0+1+0+0=1$, $0+1+0+0=1$, $0+0+0+0=0$ — valid.\n  - $(0,0,0,1,0,0,0)$: $0+0+0+0=0 \\neq 1$ — invalid.\n  - $(0,0,0,0,1,0,0)$: $0+0+1+0=1$, $0+0+0+0=0 \\neq 1$ — invalid.\n  - $(0,0,0,0,0,1,0)$: $0+0+0+0=0 \\neq 1$, $0+0+1+0=1$ — invalid.\n  - $(0,0,0,0,0,0,1)$: $0+0+0+1=1$, $0+0+0+1=1$, $0+0+0+1=1 \\neq 0$ — invalid.\n  Only $(0,0,1,0,0,0,0)$ (i.e., $C = X_3$) works, with weight 1.\n\nSince a weight-1 solution exists, the minimum weight is 1, and $C = X_3$. The residual error is:\n$$\nE_{\\text{res}} = C E = X_3 (X_1 X_2) = X_1 X_2 X_3.\n$$\n\nThe Hamming weight is the number of non-identity factors, which is 3 (qubits 1, 2, and 3).", "answer": "$$ \\boxed{3} $$", "id": "66362"}, {"introduction": "Beyond direct matching, some decoding paradigms draw inspiration from other fields, like statistical mechanics. The Renormalization Group (RG) decoder provides a powerful, multi-scale approach to identifying errors by progressively simplifying the syndrome pattern. In this final practice [@problem_id:66386], you will perform the core step of an RG decoder: coarse-graining a syndrome lattice. By applying a local parity rule to blocks of syndromes, you will see how information about large-scale errors can be extracted from fine-grained data, illustrating a completely different, yet effective, philosophy of decoding.", "problem": "In the context of quantum error correction, the surface code is a prominent topological quantum error-correcting code. Consider a surface code defined on a $2D$ lattice with periodic boundary conditions (a torus). Qubits reside on the edges of this lattice. The code is defined by a set of stabilizer operators. For this problem, we are concerned with the $Z$-type stabilizers, also known as plaquette operators. Each plaquette operator is a product of Pauli-$Z$ operators acting on the qubits forming the boundary of a face (plaquette) of the lattice.\n\nWhen errors occur, some stabilizers may no longer commute with the error operators, leading to a measurement outcome of $-1$ for those stabilizers. The set of these outcomes is called the error syndrome. We can represent the syndrome as a binary lattice where a '1' denotes a violated stabilizer (outcome $-1$) and a '0' denotes a satisfied stabilizer (outcome $+1$).\n\nOne method for decoding the surface code is the renormalization group (RG) decoder. This decoder operates by coarse-graining the syndrome lattice to identify logical errors. Consider a single step of an RG decoder acting on an $L \\times L$ syndrome lattice, where $L$ is an even integer. The lattice is partitioned into disjoint $2 \\times 2$ blocks of syndrome bits. A new, smaller $(L/2) \\times (L/2)$ coarse-grained syndrome lattice is then constructed. The value of each new syndrome site is determined by a majority rule applied to the corresponding $2 \\times 2$ block in the original lattice. For this problem, the majority rule is defined as the parity of the syndrome bits within the block: the coarse-grained syndrome bit is '1' if the number of '1's in its corresponding $2 \\times 2$ block is odd, and '0' if it is even.\n\nSuppose for a $4 \\times 4$ surface code, the measured $Z$-stabilizer syndrome lattice, $S$, is given by the following matrix:\n$$\nS = \\begin{pmatrix}\nS_{00}  S_{01}  S_{02}  S_{03} \\\\\nS_{10}  S_{11}  S_{12}  S_{13} \\\\\nS_{20}  S_{21}  S_{22}  S_{23} \\\\\nS_{30}  S_{31}  S_{32}  S_{33}\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0  0 \\\\\n1  1  1  0 \\\\\n0  1  1  1 \\\\\n0  0  1  1\n\\end{pmatrix}\n$$\nThe coarse-graining process maps this $4 \\times 4$ lattice $S$ to a $2 \\times 2$ lattice $S'$, where the element $S'_{IJ}$ is determined by the block of elements $\\{S_{ij}\\}$ with $i \\in \\{2I, 2I+1\\}$ and $j \\in \\{2J, 2J+1\\}$.\n\nYour task is to compute the resulting $2 \\times 2$ coarse-grained syndrome lattice $S'$. Then, convert this $2 \\times 2$ matrix into a single integer. The integer is formed by reading the elements of $S'$ row by row, from left to right, treating the sequence as a 4-bit binary number $(S'_{00}S'_{01}S'_{10}S'_{11})_2$, where $S'_{00}$ is the most significant bit.", "solution": "The problem asks us to perform one step of a renormalization group (RG) decoding procedure on a given $4 \\times 4$ syndrome lattice $S$ to obtain a $2 \\times 2$ coarse-grained lattice $S'$. The final answer should be an integer representation of $S'$.\n\nThe given $4 \\times 4$ syndrome lattice is:\n$$\nS = \\begin{pmatrix}\n0  1  0  0 \\\\\n1  1  1  0 \\\\\n0  1  1  1 \\\\\n0  0  1  1\n\\end{pmatrix}\n$$\n\nThe coarse-graining rule states that the $2 \\times 2$ lattice $S'$ is obtained by partitioning $S$ into four $2 \\times 2$ blocks and applying a parity rule to each block. Let the coarse-grained lattice be:\n$$\nS' = \\begin{pmatrix}\nS'_{00}  S'_{01} \\\\\nS'_{10}  S'_{11}\n\\end{pmatrix}\n$$\nThe rule for each element $S'_{IJ}$ is given by the parity (sum modulo 2) of the elements in the corresponding block of $S$.\n$$\nS'_{IJ} = \\left( \\sum_{i=2I}^{2I+1} \\sum_{j=2J}^{2J+1} S_{ij} \\right) \\pmod 2\n$$\n\nWe compute each element of $S'$ step-by-step.\n\n**1. Compute $S'_{00}$:**\nThis element corresponds to the top-left $2 \\times 2$ block of $S$.\n$$\n\\text{Block}_{00} = \\begin{pmatrix}\nS_{00}  S_{01} \\\\\nS_{10}  S_{11}\n\\end{pmatrix} = \\begin{pmatrix}\n0  1 \\\\\n1  1\n\\end{pmatrix}\n$$\nThe sum of the elements in this block is $0 + 1 + 1 + 1 = 3$.\nThe parity is $3 \\pmod 2 = 1$.\nSo, $S'_{00} = 1$.\n\n**2. Compute $S'_{01}$:**\nThis element corresponds to the top-right $2 \\times 2$ block of $S$.\n$$\n\\text{Block}_{01} = \\begin{pmatrix}\nS_{02}  S_{03} \\\\\nS_{12}  S_{13}\n\\end{pmatrix} = \\begin{pmatrix}\n0  0 \\\\\n1  0\n\\end{pmatrix}\n$$\nThe sum of the elements in this block is $0 + 0 + 1 + 0 = 1$.\nThe parity is $1 \\pmod 2 = 1$.\nSo, $S'_{01} = 1$.\n\n**3. Compute $S'_{10}$:**\nThis element corresponds to the bottom-left $2 \\times 2$ block of $S$.\n$$\n\\text{Block}_{10} = \\begin{pmatrix}\nS_{20}  S_{21} \\\\\nS_{30}  S_{31}\n\\end{pmatrix} = \\begin{pmatrix}\n0  1 \\\\\n0  0\n\\end{pmatrix}\n$$\nThe sum of the elements in this block is $0 + 1 + 0 + 0 = 1$.\nThe parity is $1 \\pmod 2 = 1$.\nSo, $S'_{10} = 1$.\n\n**4. Compute $S'_{11}$:**\nThis element corresponds to the bottom-right $2 \\times 2$ block of $S$.\n$$\n\\text{Block}_{11} = \\begin{pmatrix}\nS_{22}  S_{23} \\\\\nS_{32}  S_{33}\n\\end{pmatrix} = \\begin{pmatrix}\n1  1 \\\\\n1  1\n\\end{pmatrix}\n$$\nThe sum of the elements in this block is $1 + 1 + 1 + 1 = 4$.\nThe parity is $4 \\pmod 2 = 0$.\nSo, $S'_{11} = 0$.\n\nCombining these results, the coarse-grained syndrome lattice is:\n$$\nS' = \\begin{pmatrix}\n1  1 \\\\\n1  0\n\\end{pmatrix}\n$$\n\nThe final step is to convert this matrix into a single integer. We read the elements row by row, $S'_{00}, S'_{01}, S'_{10}, S'_{11}$, to form a 4-bit binary number with $S'_{00}$ as the most significant bit.\nThe binary string is $1110_2$.\n\nNow, we convert this binary number to its decimal representation:\n$$\n(1110)_2 = 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0\n$$\n$$\n= 1 \\cdot 8 + 1 \\cdot 4 + 1 \\cdot 2 + 0 \\cdot 1\n$$\n$$\n= 8 + 4 + 2 + 0 = 14\n$$\nThe resulting integer is 14.", "answer": "$$\\boxed{14}$$", "id": "66386"}]}