{"hands_on_practices": [{"introduction": "The design of any Entanglement-Assisted Calderbank-Shor-Steane (EA-CSS) code begins with a fundamental trade-off, encapsulated in the parameter balance equation. This relation shows how pre-shared entanglement, quantified by the number of ebits $c$, can enable the creation of a quantum code with $k$ logical qubits even when the chosen classical codes $C_X$ and $C_Z$ would fail to produce a useful code under the standard CSS framework. The following exercise [@problem_id:80311] provides hands-on practice with this crucial equation, demonstrating how entanglement serves as a vital resource to make seemingly impossible code constructions viable.", "problem": "In the framework of entanglement-assisted quantum error correction (EAQEC), a quantum code can be constructed from two classical linear codes, $C_X$ and $C_Z$, defined over the field GF(2). These codes are used to detect and correct bit-flip (X) and phase-flip (Z) errors, respectively. Unlike standard Calderbank-Shor-Steane (CSS) codes, EAQEC codes can utilize pre-shared entanglement, quantified by the number of ebits $c$, to overcome situations where the classical codes do not meet the standard CSS condition ($C_Z^\\perp \\subseteq C_X$). This allows for the construction of quantum codes from a wider range of classical codes.\n\nAn EA-CSS code, denoted by $[[n, k, d; c]]$, is constructed from classical codes $C_X = [n, k_X, d_X]$ and $C_Z = [n, k_Z, d_Z]$. The number of encoded logical qubits, $k$, and the number of required ebits, $c$, are related to the parameters of the classical codes by the following fundamental trade-off relation:\n$$k = k_X + k_Z - n + c$$\nHere, $n$ is the number of physical qubits, $k_X$ is the dimension of $C_X$, and $k_Z$ is the dimension of $C_Z$. The number of logical qubits $k$ and the number of ebits $c$ must be non-negative integers.\n\nConsider the task of constructing an EA-CSS code using $n$ physical qubits. The classical code chosen for correcting X-errors is $C_X$ with parameters $[n, k_X] = [25, 10]$, and the code for correcting Z-errors is $C_Z$ with parameters $[n, k_Z] = [25, 12]$.\n\nWhat is the minimum number of ebits, $c$, required for this construction to yield a valid quantum code that encodes at least two logical qubits?", "solution": "The problem asks for the minimum number of ebits, $c$, needed to construct an EA-CSS code that encodes $k \\ge 2$ logical qubits, given the parameters of two classical codes $C_X$ and $C_Z$.\n\nFirst, we identify the given parameters from the problem statement:\n- The number of physical qubits is the same for both classical codes: $n = 25$.\n- The dimension of the classical code $C_X$ is $k_X = 10$.\n- The dimension of the classical code $C_Z$ is $k_Z = 12$.\n- The required number of logical qubits must satisfy the condition $k \\ge 2$.\n- Both $k$ and $c$ must be non-negative integers ($k \\ge 0, c \\ge 0$).\n\nThe central formula that governs the parameters of an EA-CSS code is:\n$$k = k_X + k_Z - n + c$$\n\nWe can first calculate the term $(k_X + k_Z - n)$, which represents the number of logical qubits that could be encoded by a standard CSS code (if the orthogonality condition were met and $c=0$).\n$$k_{CSS} = k_X + k_Z - n = 10 + 12 - 25$$\n$$k_{CSS} = 22 - 25 = -3$$\nSince this value is negative, it is impossible to construct a standard CSS code ($c=0$) that encodes any logical qubits ($k \\ge 0$). This demonstrates that entanglement assistance is necessary for this construction to yield any useful quantum code.\n\nThe relationship between $k$ and $c$ for this specific construction is:\n$$k = -3 + c$$\n\nThe problem requires that the resulting quantum code encodes at least two logical qubits. This translates to the mathematical inequality:\n$$k \\ge 2$$\n\nNow, we substitute the expression for $k$ in terms of $c$ into this inequality:\n$$-3 + c \\ge 2$$\n\nTo find the minimum required number of ebits, we solve this inequality for $c$:\n$$c \\ge 2 + 3$$\n$$c \\ge 5$$\n\nSince the number of ebits $c$ must be an integer, the smallest integer value that satisfies the condition $c \\ge 5$ is $c=5$.\n\nWith $c=5$, the number of encoded logical qubits would be $k = -3 + 5 = 2$. This satisfies the condition $k \\ge 2$. Any smaller integer value for $c$ (e.g., $c=4$) would result in $k = -3+4=1$, which violates the problem's requirement of $k \\ge 2$.\n\nTherefore, the minimum number of ebits required is 5.", "answer": "$$ \\boxed{5} $$", "id": "80311"}, {"introduction": "Having seen how the number of ebits $c$ influences a code's capacity, we now turn to its physical origin. The value of $c$ is not arbitrary; it is determined by the specific structure of the classical codes used in the EA-CSS construction and quantifies their degree of non-orthogonality. This practice [@problem_id:80241] focuses on the essential calculation of $c$ by finding the rank of the matrix product of the two parity-check matrices, giving you a direct method to compute the entanglement cost for a given pair of classical codes.", "problem": "An Entanglement-Assisted Quantum Error-Correcting (EA-QEC) code can be constructed from two classical linear codes over $\\mathbb{F}_2$. This construction, known as Entanglement-Assisted Calderbank-Shor-Steane (EA-CSS), provides a powerful generalization of the standard CSS framework.\n\nGiven two classical linear codes, $C_X$ with parameters $[n, k_X]$ and $C_Z$ with parameters $[n, k_Z]$, an EA-CSS code can be built. The $X$-type stabilizer generators for the quantum code are derived from the rows of the parity-check matrix $H_X$ of the classical code $C_X$. Similarly, the $Z$-type stabilizer generators are derived from the rows of the parity-check matrix $H_Z$ of the classical code $C_Z$.\n\nThe number of pre-shared entangled Bell pairs (ebits), denoted by $c$, required for this construction is determined by the overlap in the commutation relations of the stabilizer generators. It is given by the formula:\n$$\nc = \\text{rank}(H_X H_Z^T)\n$$\nwhere the matrix multiplication and rank are computed over the binary field $\\mathbb{F}_2$.\n\nConsider two classical linear codes, $C_X$ and $C_Z$, both of block length $n=5$.\nThe code $C_X$ is defined by the following generator matrix:\n$$\nG_X = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 1 & 1 \\end{pmatrix}\n$$\nThe code $C_Z$ is defined by the following generator matrix:\n$$\nG_Z = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 1 & 0 \\end{pmatrix}\n$$\nBoth matrices are in systematic form $G = [I_k | P]$, where $I_k$ is the $k \\times k$ identity matrix and $P$ is a $k \\times (n-k)$ matrix. The corresponding parity-check matrix is given by $H = [P^T | I_{n-k}]$.\n\nCalculate the number of ebits, $c$, required for the EA-CSS code constructed from the classical codes $C_X$ and $C_Z$.", "solution": "To determine the number of ebits $c$ for the EA-CSS code, we use the formula $c = \\text{rank}(H_X H_Z^T)$ over $\\mathbb{F}_2$, where $H_X$ and $H_Z$ are the parity-check matrices of the classical codes $C_X$ and $C_Z$, respectively.\n\nGiven the generator matrices in systematic form:\n- $G_X = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 1 & 1 \\end{pmatrix} = [I_2 \\mid P_X]$, so $P_X = \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\end{pmatrix}$.\n- $G_Z = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 1 & 0 \\end{pmatrix} = [I_3 \\mid P_Z]$, so $P_Z = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\\\ 1 & 0 \\end{pmatrix}$.\n\nThe parity-check matrices are given by $H = [P^T \\mid I_{n-k}]$:\n- For $C_X$, $k_X = 2$, $n - k_X = 3$:\n  $$\n  H_X = [P_X^T \\mid I_3] = \\begin{pmatrix} 1 & 0 & 1 & 0 & 0 \\\\ 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 \\end{pmatrix}.\n  $$\n- For $C_Z$, $k_Z = 3$, $n - k_Z = 2$:\n  $$\n  H_Z = [P_Z^T \\mid I_2] = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 0 & 1 \\end{pmatrix}.\n  $$\n\nNow compute $H_Z^T$:\n$$\nH_Z^T = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\\\ 1 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\end{pmatrix}.\n$$\n\nNext, compute the product $H_X H_Z^T$ over $\\mathbb{F}_2$:\n- $H_X$ is $3 \\times 5$, $H_Z^T$ is $5 \\times 2$, so the product is $3 \\times 2$.\n- Element $(1,1)$: $(1,0,1,0,0) \\cdot (1,0,1,1,0)^T = 1\\cdot1 + 0\\cdot0 + 1\\cdot1 + 0\\cdot1 + 0\\cdot0 = 1 + 0 + 1 + 0 + 0 = 0$.\n- Element $(1,2)$: $(1,0,1,0,0) \\cdot (1,1,0,0,1)^T = 1\\cdot1 + 0\\cdot1 + 1\\cdot0 + 0\\cdot0 + 0\\cdot1 = 1 + 0 + 0 + 0 + 0 = 1$.\n- Element $(2,1)$: $(1,1,0,1,0) \\cdot (1,0,1,1,0)^T = 1\\cdot1 + 1\\cdot0 + 0\\cdot1 + 1\\cdot1 + 0\\cdot0 = 1 + 0 + 0 + 1 + 0 = 0$.\n- Element $(2,2)$: $(1,1,0,1,0) \\cdot (1,1,0,0,1)^T = 1\\cdot1 + 1\\cdot1 + 0\\cdot0 + 1\\cdot0 + 0\\cdot1 = 1 + 1 + 0 + 0 + 0 = 0$.\n- Element $(3,1)$: $(0,1,0,0,1) \\cdot (1,0,1,1,0)^T = 0\\cdot1 + 1\\cdot0 + 0\\cdot1 + 0\\cdot1 + 1\\cdot0 = 0$.\n- Element $(3,2)$: $(0,1,0,0,1) \\cdot (1,1,0,0,1)^T = 0\\cdot1 + 1\\cdot1 + 0\\cdot0 + 0\\cdot0 + 1\\cdot1 = 0 + 1 + 0 + 0 + 1 = 0$.\n\nThus,\n$$\nH_X H_Z^T = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\\\ 0 & 0 \\end{pmatrix}.\n$$\n\nNow find the rank over $\\mathbb{F}_2$:\n- The matrix has rows: $(0,1)$, $(0,0)$, $(0,0)$.\n- The first row is non-zero, and the other rows are zero. The row space is spanned by $(0,1)$, which has dimension 1.\n- Therefore, $\\text{rank}(H_X H_Z^T) = 1$.\n\nHence, the number of ebits $c = 1$.", "answer": "$$\\boxed{1}$$", "id": "80241"}, {"introduction": "Moving from code construction to operation, we explore a critical aspect of error correction: decoding. An error is detected by measuring a syndrome, but what happens when different physical errors produce the exact same syndrome? This exercise [@problem_id:80330] investigates this phenomenon, known as error degeneracy. You will analyze a scenario where the recovery operation, based on a misidentified error, leaves behind a residual operator that acts non-trivially on the encoded logical qubit, illustrating a fundamental challenge in the design and analysis of all quantum error-correcting codes.", "problem": "In an entanglement-assisted quantum error correcting (EAQEC) code, pre-shared entanglement between sender and receiver is used to relax the constraints on the stabilizer generators. Specifically, the generators of the code, acting on the physical data qubits, are not required to commute with each other.\n\nConsider an $[[n=3, k=1, c=1]]$ EAQEC code that encodes one logical qubit ($k=1$) into three physical qubits ($n=3$) with the assistance of one Bell pair ($c=1$). The code is defined by two physical generators, $g_1$ and $g_2$, which are elements of the 3-qubit Pauli group $G_3$:\n$$ g_1 = Z_1 \\otimes Z_2 \\otimes I_3 $$\n$$ g_2 = I_1 \\otimes X_2 \\otimes X_3 $$\nHere, $X_i, Y_i, Z_i$ are the standard Pauli operators for qubit $i$, and $I_i$ is the identity operator on qubit $i$. The non-commutativity of these generators, $[g_1, g_2] \\neq 0$, necessitates the use of the Bell pair.\n\nThe logical Pauli operators for the encoded qubit are given by:\n$$ \\bar{X} = X_1 \\otimes X_2 \\otimes I_3 $$\n$$ \\bar{Z} = I_1 \\otimes Z_2 \\otimes Z_3 $$\nThe logical identity is $\\bar{I} = I_1 \\otimes I_2 \\otimes I_3$, and the logical Y operator is $\\bar{Y} = i\\bar{X}\\bar{Z}$.\n\nAn error is a Pauli operator $E \\in G_3$ acting on the physical qubits. The error syndrome is a binary vector whose components are determined by the commutation relations of the error $E$ with the generators $\\{g_j\\}$. An error $E$ is detected by measuring the eigenvalues of the generators. If $E$ anti-commutes with $g_j$, it flips the corresponding syndrome bit. Two distinct errors, $E_1$ and $E_2$, are called degenerate if they produce the same error syndrome.\n\nSuppose the system is subjected to a single-qubit Pauli error $E_1 = Z_3$. However, due to error degeneracy, the recovery procedure mistakenly assumes that a different single-qubit error, $E_2 = Z_2$, has occurred. The recovery operation $R$ is therefore chosen to be the inverse of the assumed error, $R=E_2^\\dagger$. This recovery operation is applied to the error-corrupted state.\n\nDetermine the resulting effective logical Pauli operator that is applied to the encoded qubit. Express your answer as one of $\\bar{I}$, $\\bar{X}$, $\\bar{Y}$, or $\\bar{Z}$.", "solution": "The problem asks for the effective logical operator resulting from a specific error and a mistaken recovery operation. The overall transformation on the logical state $|\\psi_L\\rangle$ is $R E_1$, where $E_1$ is the actual error and $R$ is the recovery operation.\n\n**Step 1: Verify that the errors $E_1$ and $E_2$ are degenerate.**\nTwo errors are degenerate if they have the same syndrome. The syndrome for an error $E$ is determined by its commutation relations with the generators $g_1$ and $g_2$. We use the fact that for any two Pauli operators $P, Q$, they either commute ($[P,Q]=PQ-QP=0$) or anti-commute ($\\{P,Q\\}=PQ+QP=0$).\n\nLet's calculate the syndrome for the actual error, $E_1 = Z_3 = I_1 \\otimes I_2 \\otimes Z_3$.\n- Commutation with $g_1 = Z_1 \\otimes Z_2 \\otimes I_3$: The error $E_1$ acts only on qubit 3, while the generator $g_1$ acts only on qubits 1 and 2. Since the operators act on disjoint sets of qubits, they commute: $[E_1, g_1] = 0$. The first syndrome bit is 0.\n- Commutation with $g_2 = I_1 \\otimes X_2 \\otimes X_3$: The error $E_1$ and generator $g_2$ both have a non-identity operator on qubit 3 ($Z_3$ and $X_3$, respectively). Since $X_3$ and $Z_3$ anti-commute, the full operators also anti-commute: $\\{E_1, g_2\\} = 0$. The second syndrome bit is 1.\n\nThe syndrome for $E_1 = Z_3$ is $(0, 1)$.\n\nNow, let's calculate the syndrome for the assumed error, $E_2 = Z_2 = I_1 \\otimes Z_2 \\otimes I_3$.\n- Commutation with $g_1 = Z_1 \\otimes Z_2 \\otimes I_3$: Both operators have a non-identity component on qubit 2 ($Z_2$ and $Z_1 Z_2$). Since $Z_2$ commutes with $Z_1 Z_2$, the full operators commute: $[E_2, g_1] = 0$. The first syndrome bit is 0.\n- Commutation with $g_2 = I_1 \\otimes X_2 \\otimes X_3$: The error $E_2$ and generator $g_2$ both have a non-identity operator on qubit 2 ($Z_2$ and $X_2$, respectively). Since $Z_2$ and $X_2$ anti-commute, the full operators also anti-commute: $\\{E_2, g_2\\} = 0$. The second syndrome bit is 1.\n\nThe syndrome for $E_2 = Z_2$ is $(0, 1)$.\nSince both errors have the same syndrome, they are indeed degenerate.\n\n**Step 2: Determine the effective logical operator.**\nThe initial state is an encoded logical state $|\\psi_L\\rangle$.\nThe error $E_1 = Z_3$ occurs, transforming the state to $E_1 |\\psi_L\\rangle = Z_3 |\\psi_L\\rangle$.\n\nThe recovery procedure assumes the error was $E_2=Z_2$. The corresponding recovery operation is $R = E_2^\\dagger$. Since $Z_2$ is Hermitian and unitary, $Z_2^\\dagger = Z_2$. So, $R = Z_2$.\n\nThe recovery operation is applied to the corrupted state:\n$$ |\\psi_{final}\\rangle = R (E_1 |\\psi_L\\rangle) = Z_2 (Z_3 |\\psi_L\\rangle) $$\nThe effective operator acting on the logical state is the product of the recovery operator and the error operator:\n$$ L_{eff} = R E_1 = Z_2 Z_3 = I_1 \\otimes Z_2 \\otimes Z_3 $$\n\n**Step 3: Express the effective operator in terms of the code's logical operators.**\nThe problem provides the definitions of the logical operators:\n$$ \\bar{X} = X_1 \\otimes X_2 \\otimes I_3 $$\n$$ \\bar{Z} = I_1 \\otimes Z_2 \\otimes Z_3 $$\nBy comparing our result for the effective operator with these definitions, we see that:\n$$ L_{eff} = I_1 \\otimes Z_2 \\otimes Z_3 = \\bar{Z} $$\nThus, the misidentification of the error leads to the application of a logical $\\bar{Z}$ gate on the encoded qubit.", "answer": "$$ \\boxed{\\bar{Z}} $$", "id": "80330"}]}