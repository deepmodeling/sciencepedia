{"hands_on_practices": [{"introduction": "While many introductory examples of topological codes use a square lattice, the underlying principles are far more general. This exercise challenges you to apply the fundamental definitions of stabilizer generators to a different geometry: a hexagonal honeycomb lattice. By determining the weight of the vertex and face operators, you will solidify your understanding of how the local structure of the lattice dictates the properties of the code's stabilizers [@problem_id:178658].", "problem": "Consider a topological stabilizer code constructed on a regular 2D hexagonal lattice with periodic boundary conditions (a torus). This lattice structure is also known as a 6.6.6 tiling. The code is defined as follows:\n\n1.  A single qubit is placed on each **edge** of the lattice.\n2.  The stabilizer group $\\mathcal{S}$ is generated by two types of local operators:\n    *   **Vertex operators**: For each vertex $v$ on the lattice, there is a stabilizer generator $A_v = \\bigotimes_{j \\in \\text{star}(v)} X_j$, where $\\text{star}(v)$ is the set of edges incident to the vertex $v$, and $X_j$ is the Pauli-X operator acting on the qubit $j$ on edge $j$.\n    *   **Face operators**: For each face $p$ (also called a plaquette) of the lattice, there is a stabilizer generator $B_p = \\bigotimes_{k \\in \\partial p} Z_k$, where $\\partial p$ is the set of edges that form the boundary of the face $p$, and $Z_k$ is the Pauli-Z operator acting on the qubit $k$ on edge $k$.\n\nThe **weight** of a Pauli operator is defined as the number of qubits on which it acts non-trivially. Let $w_V$ be the weight of any given vertex operator $A_v$, and $w_F$ be the weight of any given face operator $B_p$. For a regular lattice, these weights are uniform for all vertices and all faces.\n\nCalculate the product of the vertex operator weight and the face operator weight, $P = w_V \\cdot w_F$.", "solution": "The lattice is a regular hexagonal lattice (6.6.6 tiling) with periodic boundary conditions, forming a torus. Qubits are placed on the edges.\n\n- **Vertex operator weight $w_V$**:  \n  Each vertex operator $A_v$ acts on all edges incident to vertex $v$. In a hexagonal lattice, each vertex has degree 3 (since three hexagons meet at each vertex). Thus, the operator acts on 3 qubits, so:  \n  $$\n  w_V = 3\n  $$\n\n- **Face operator weight $w_F$**:  \n  Each face operator $B_p$ acts on all edges bounding face $p$. Each face is a hexagon, so it has 6 edges. Thus, the operator acts on 6 qubits, so:  \n  $$\n  w_F = 6\n  $$\n\n- **Product $P = w_V \\cdot w_F$**:  \n  Substituting the weights:  \n  $$\n  P = 3 \\times 6 = 18\n  $$", "answer": "$$ \\boxed{18} $$", "id": "178658"}, {"introduction": "A key goal in quantum error correction is to build codes with ever-increasing resilience to noise, which is quantified by the code distance $d$. This practice explores a powerful method for achieving this: code concatenation, where one code is nested inside another. By combining a topological outer code with a perfect inner code, you will calculate the distance of the resulting composite code and see firsthand how their strengths multiply to enhance error protection [@problem_id:180239].", "problem": "**Background:**\nA quantum error-correcting code is characterized by the notation $[[n, k, d]]$, where $n$ is the number of physical qubits, $k$ is the number of encoded logical qubits, and $d$ is the code distance. The distance is the minimum weight of a non-trivial logical operator, which determines the code's error-correcting capability.\n\nThe toric code is a prominent example of a topological stabilizer code. It is defined on a 2D square lattice with periodic boundary conditions (a torus). Physical qubits are located on the edges of the lattice. The code's stabilizers are of two types: \"star operators\" ($A_s$), which are products of Pauli-$X$ operators on the qubits surrounding a vertex $s$, and \"plaquette operators\" ($B_p$), which are products of Pauli-$Z$ operators on the qubits forming the boundary of a face $p$. The code distance of the toric code is determined by the size of the lattice. We denote its distance by the symbol $d_{TC}$.\n\nCode concatenation is a technique to construct new, often more powerful, codes. Given an \"outer\" code $C_{out}$ and an \"inner\" code $C_{in}$, the concatenated code $C_{out} \\circ C_{in}$ is formed by replacing each physical qubit of $C_{out}$ with a logical qubit encoded by an entire block of the inner code $C_{in}$.\n\n**Problem:**\nConsider a concatenated code constructed as follows:\n1.  The outer code is a toric code with a given code distance $d_{TC}$.\n2.  The inner code is the perfect quantum error-correcting code with parameters $[[5, 1, 3]]$.\n\nEach of the physical qubits of the distance-$d_{TC}$ toric code is replaced by an independent block of the $[[5,1,3]]$ code. Calculate the overall code distance, $d_{concat}$, of this resulting concatenated code. Express your answer in terms of $d_{TC}$.", "solution": "1. The toric code has distance \n$$d_{\\rm out}=d_{TC}.$$\n2. The inner $[[5,1,3]]$ code has distance \n$$d_{\\rm in}=3.$$\n3. Under concatenation, any logical operator of the outer code of weight $w$ must induce logical operators in $w$ distinct inner blocks. Each such inner logical operator has weight at least $d_{\\rm in}$. Hence the minimum total weight of a nontrivial logical operator in the concatenated code is\n$$d_{\\rm concat}=d_{\\rm out}\\,d_{\\rm in}.$$\n4. Substituting gives\n$$d_{\\rm concat}=d_{TC}\\times 3.$$", "answer": "$$\\boxed{3\\,d_{TC}}$$", "id": "180239"}, {"introduction": "The \"topological\" nature of these codes is most profoundly revealed in the connection between their information-storage capacity and the global geometry of the lattice. This exercise explores this deep connection by defining the toric code on an unconventional surface: a fractal Sierpinski carpet. You will calculate the ground state degeneracy to see how the number of logical qubits is determined by the intricate topological features of this fascinating mathematical object [@problem_id:180324].", "problem": "The toric code is a stabilizer quantum error-correcting code typically defined on a two-dimensional square lattice with periodic boundary conditions. However, the model can be generalized to any 2D cell complex, which is a graph embedded on a surface, defining faces (plaquettes). In this generalized toric code, qubits are located on the edges of the complex. The stabilizer group is generated by two types of operators:\n1.  Star operators: For each vertex $v$, an operator $A_v = \\prod_{e \\sim v} X_e$, where the product is over all edges $e$ incident to $v$, and $X_e$ is the Pauli-X operator on the qubit on edge $e$.\n2.  Plaquette operators: For each face $p$, an operator $B_p = \\prod_{e \\in \\partial p} Z_e$, where the product is over all edges $e$ on the boundary of $p$, and $Z_e$ is the Pauli-Z operator on the qubit on edge $e$.\n\nThe ground states of the system are the states $|\\psi\\rangle$ that are stabilized by all generators, i.e., $A_v |\\psi\\rangle = |\\psi\\rangle$ and $B_p |\\psi\\rangle = |\\psi\\rangle$ for all $v$ and $p$. The number of encoded logical qubits is determined by the topology of the cell complex. For a code defined on a surface with genus $g$ and $b$ boundaries (holes), with open boundary conditions as defined above, the number of logical qubits is $k_{logical} = 2g + b - 1$. The ground state degeneracy is then $2^{k_{logical}}$.\n\nThe Sierpinski carpet is a fractal constructed iteratively. The $k$-th stage approximation of the carpet, denoted $S_k$, can be viewed as a 2D cell complex. The construction starts with a single solid square for $k=0$. To get from stage $k$ to $k+1$, every square in the complex $S_k$ is subdivided into a $3 \\times 3$ grid of smaller squares, and the central square of each grid is removed. $S_0$ is a single square, $S_1$ is a square with a central square hole, $S_2$ is composed of 8 squares-with-holes, forming a larger structure with a total of 9 holes of different sizes, and so on.\n\nConsider a toric code defined on the cell complex of the $k$-th stage Sierpinski carpet $S_k$. Assume the complex has open boundary conditions, meaning it is not wrapped on a torus or other closed surface. Determine the ground state degeneracy of this system as a function of the integer construction stage $k$.", "solution": "1. For a surface with genus $g$ and $b$ boundary components, the number of logical qubits is\n$$\nk_{\\text{logical}}=2g+b-1.\n$$\nHere the Sierpinski carpet $S_k$ is a planar region, so $g=0$. Its boundary components consist of the outer boundary plus each hole. Thus if $h_k$ is the number of holes in $S_k$, then $b=h_k+1$ and\n$$\nk_{\\text{logical}}=(h_k+1)-1=h_k.\n$$\n\n2. The recursion for the number of holes $h_k$ is: start with $h_0=0$, and at each stage each of the existing squares spawns 1 new central hole in its $3 \\times 3$ subdivision, giving the relation:\n$$\nh_{k+1}=8 h_k+1.\n$$\nThis linear recurrence with $h_0=0$ has the closed-form solution:\n$$\nh_k=\\frac{8^k-1}{7}.\n$$\n\n3. The ground state degeneracy is:\n$$\n\\text{GSD}=2^{k_{\\text{logical}}}=2^{h_k}=2^{\\frac{8^k-1}{7}}.\n$$", "answer": "$$\\boxed{2^{\\frac{8^k-1}{7}}}$$", "id": "180324"}]}