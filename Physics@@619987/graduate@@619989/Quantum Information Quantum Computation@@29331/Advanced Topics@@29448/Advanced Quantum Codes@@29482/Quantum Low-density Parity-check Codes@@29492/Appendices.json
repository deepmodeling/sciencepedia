{"hands_on_practices": [{"introduction": "Spatially coupled codes represent a powerful architecture for constructing high-performance QLDPC codes. A key feature of these codes is their behavior at the boundaries, where logical operators can be localized with low weight. This hands-on problem [@problem_id:123274] allows you to explore this phenomenon directly on a simple chain, providing foundational insight into why spatial coupling can be used to engineer the properties of logical operators and improve error correction performance.", "id": "123274", "problem": "Consider a quantum error-correcting code defined on a one-dimensional chain of qubits. The chain has a length of $L$ sites, indexed by $i \\in \\{1, 2, \\dots, L\\}$, where $L \\ge 3$ is an integer. At each site $i$, there are two qubits, denoted by $q_{i,1}$ and $q_{i,2}$. The total number of qubits is $N=2L$.\n\nThis code is a Calderbank-Shor-Steane (CSS) code, specified by its set of stabilizer generators. The stabilizers are of two types: Z-type and X-type.\n\nThe Z-type stabilizer generators are given by:\n$$ s_{i,Z} = Z_{i,1} Z_{i,2} Z_{i+1,1} \\quad \\text{for } i \\in \\{1, 2, \\dots, L-1\\} $$\nHere, $Z_{i,j}$ is the Pauli-Z operator acting on qubit $q_{i,j}$.\n\nThe X-type stabilizer generators are given by:\n$$ s_{i,X} = X_{i-1,2} X_{i,1} X_{i,2} \\quad \\text{for } i \\in \\{2, 3, \\dots, L\\} $$\nHere, $X_{i,j}$ is the Pauli-X operator acting on qubit $q_{i,j}$.\n\nA logical X-operator, $\\bar{X}$, is an operator of the form $\\prod_{(i,j) \\in S} X_{i,j}$ for some non-empty set of qubit indices $S$, that satisfies two conditions:\n1. It commutes with all stabilizer generators ($[\\bar{X}, s_{k,Z}] = 0$ and $[\\bar{X}, s_{k,X}] = 0$ for all valid $k$).\n2. It is non-trivial, meaning it is not a product of X-type stabilizer generators.\n\nThe problem is to determine the support size (i.e., the number of qubits on which the operator acts non-trivially) of a minimal-weight logical X-operator that is localized at the $i=1$ boundary of the chain. An operator is defined as \"localized at the $i=1$ boundary\" if its support is entirely contained within the set of qubits at site 1, $\\{q_{1,1}, q_{1,2}\\}$.\n\n", "solution": "1. The candidate logical operator supported on site 1 is $\\bar X_S=\\prod_{(i,j)\\in S}X_{i,j}$ with $S\\subseteq\\{(1,1),(1,2)\\}$.  Possible weights are $|S|=1$ or $2$.  \n2. Check $|S|=1$.  If $\\bar X=X_{1,1}$ then  \n   $$[X_{1,1},\\,s_{1,Z}]=[X_{1,1},\\,Z_{1,1}Z_{1,2}Z_{2,1}]\\neq0$$  \n   since $X_{1,1}Z_{1,1}=-Z_{1,1}X_{1,1}$.  Likewise $X_{1,2}$ anticommutes with $s_{1,Z}$.  Hence no weight-1 operator commutes with all Z-stabilizers.  \n3. Take $|S|=2$, $\\bar X=X_{1,1}X_{1,2}$.  Then  \n   a) Z–type:  \n   $$[X_{1,1}X_{1,2},\\,Z_{1,1}Z_{1,2}Z_{2,1}]\n     =0$$  \n   since each Z–X anticommute once giving a net + sign, and no other Z–stabilizer overlaps site 1.  \n   b) X–type: only $s_{2,X}=X_{1,2}X_{2,1}X_{2,2}$ overlaps site 1; but $X_{1,1}X_{1,2}$ commutes with $X_{1,2}$.  All other $s_{i,X}$ act on sites $\\ge2$.  \n4. Non-triviality: no X–stabilizer has support on $q_{1,1}$, so $X_{1,1}X_{1,2}$ cannot be written as a product of $s_{i,X}$.  \n5. Conclusion: the minimal support size is $2$.", "answer": "\n$$\\boxed{2}$$\n"}, {"introduction": "Belief propagation, specifically the sum-product algorithm, is the workhorse for decoding LDPC codes. It operates by iteratively passing messages representing belief probabilities—or log-likelihood ratios (LLRs)—between variable and check nodes in the code's Tanner graph. To truly grasp this process, this practice exercise [@problem_id:123319] challenges you to manually trace the first few iterations of the algorithm, calculating the evolution of LLRs and experiencing firsthand how the decoder processes syndrome information to identify errors.", "id": "123319", "problem": "A quantum CSS code is constructed from two identical classical linear codes whose parity-check matrix $H$ defines a $(d_v, d_c) = (3,4)$-regular Tanner graph with $N=8$ variable nodes (qubits) and $M=6$ check nodes (stabilizer checks). The Z-errors are decoded independently using the stabilizer checks for Z-errors, whose corresponding Tanner graph is described by the following check-to-variable neighborhood lists:\n- $N(c_1) = \\{v_1, v_2, v_3, v_4\\}$\n- $N(c_2) = \\{v_5, v_6, v_7, v_8\\}$\n- $N(c_3) = \\{v_1, v_2, v_5, v_6\\}$\n- $N(c_4) = \\{v_3, v_4, v_7, v_8\\}$\n- $N(c_5) = \\{v_1, v_3, v_5, v_7\\}$\n- $N(c_6) = \\{v_2, v_4, v_6, v_8\\}$\n\nThe qubits are subject to independent noise, and the initial prior log-likelihood ratio (LLR) for a Z-error on any qubit $i$ is given by $L_{ch} = \\log \\frac{P(e_i=0)}{P(e_i=1)} = 2 \\text{arctanh}(1/2)$.\n\nA single Z-error occurs on qubit $v_1$. The resulting syndrome is measured and provided to a belief propagation (sum-product) decoder. Calculate the final LLR for qubit $v_1$, denoted $L_1^{(\\text{final})}$, after two full iterations of the decoding algorithm.\n\nThe belief propagation update rules are as follows:\n- **Initialization**: Let $L_i^{(0)} = L_{ch}$ be the initial LLR for each qubit $i$. Messages from check nodes to variable nodes are initialized to zero for the first iteration, i.e., $u_{j \\to i}^{(0)}=0$.\n- **Variable-to-Check (V2C) message**: The message from variable node $i$ to check node $j$ at iteration $t$ is:\n$$m_{i \\to j}^{(t)} = L_i^{(0)} + \\sum_{k \\in N(i) \\setminus \\{j\\}} u_{k \\to i}^{(t-1)}$$\n- **Check-to-Variable (C2V) message**: The message from check node $j$ to variable node $i$ at iteration $t$ is:\n$$u_{j \\to i}^{(t)} = 2 \\text{arctanh} \\left( (-1)^{s_j} \\prod_{k \\in N(j) \\setminus \\{i\\}} \\tanh\\left(\\frac{m_{k \\to j}^{(t)}}{2}\\right) \\right)$$\nwhere $s_j \\in \\{0,1\\}$ is the measured syndrome bit for check $j$.\n- **Final LLR**: After $T$ iterations, the final LLR for qubit $i$ is:\n$$L_i^{(T)} = L_i^{(0)} + \\sum_{j \\in N(i)} u_{j \\to i}^{(T)}$$\n\n", "solution": "We denote \n$$\\alpha = L_{ch} = 2\\arctanh\\bigl(\\tfrac12\\bigr),\\qquad\na = \\arctanh\\bigl(\\tfrac18\\bigr),\\qquad\nb = 2a = 2\\arctanh\\bigl(\\tfrac18\\bigr).$$\nAll check‐to‐variable messages at iteration 1 are\n$$u_{j\\to i}^{(1)} = 2\\arctanh\\bigl((-1)^{s_j}( \\tanh(\\alpha/2))^3\\bigr)\n=2\\arctanh\\bigl((-1)^{s_j}\\tfrac1{8}\\bigr)\n=\\begin{cases}+\\,b,&s_j=0,\\\\-\\,b,&s_j=1.\\end{cases}$$\nSince the single error on $v_1$ gives $s_{1,3,5}=1$ and $s_{2,4,6}=0$, we have\n$$u_{c_j\\to i}^{(1)}=-b\\quad(j=1,3,5),\\quad u_{c_j\\to i}^{(1)}=+b\\quad(j=2,4,6).$$\nAt iteration 2, the variable‐to‐check messages from each $v_i$ are\n$$m_{i\\to j}^{(2)}\n=\\alpha+\\sum_{k\\in N(i)\\setminus\\{j\\}}u_{k\\to i}^{(1)},$$\nwhich one checks case by case.  In particular for $v_1$, each\n$$m_{1\\to j}^{(2)}=\\alpha+(-b)+(-b)=\\alpha-2b\\quad(j=1,3,5).$$\nNext the check‐to‐variable messages at iteration 2 for $j\\in\\{1,3,5\\}$ are\n$$u_{j\\to1}^{(2)}\n=2\\arctanh\\Bigl((-1)^{s_j}\\!\\prod_{k\\in N(j)\\setminus\\{1\\}}\\tanh\\bigl(m_{k\\to j}^{(2)}/2\\bigr)\\Bigr).$$\nOne finds for each such $j$ exactly two neighbors with $m=\\alpha$ and one with $m=\\alpha+2b$, so\n$$\\tanh\\bigl(\\alpha/2\\bigr)=\\tfrac12,\\quad\n\\tanh\\bigl((\\alpha+2b)/2\\bigr)\n=\\tanh\\bigl(d+2a\\bigr)\\;\\text{with }d=\\arctanh(\\tfrac12)\n=\\frac{97}{146}.$$\nHence\n$$\\prod\\tanh=\\bigl(\\tfrac12\\bigr)^2\\cdot\\frac{97}{146}=\\frac{97}{584},$$\nand since $s_j=1$,\n$$u_{j\\to1}^{(2)}=2\\arctanh\\!\\Bigl(-\\tfrac{97}{584}\\Bigr)=-2\\arctanh\\!\\Bigl(\\tfrac{97}{584}\\Bigr).$$\nFinally the posterior LLR after two iterations is\n$$L_1^{(2)}=L_1^{(0)}+\\sum_{j\\in N(1)}u_{j\\to1}^{(2)}\n=\\alpha-3\\cdot2\\arctanh\\!\\Bigl(\\tfrac{97}{584}\\Bigr)\n=2\\arctanh\\!\\Bigl(\\tfrac12\\Bigr)-6\\arctanh\\!\\Bigl(\\tfrac{97}{584}\\Bigr).$$", "answer": "\n$$\\boxed{2\\arctanh\\!\\bigl(\\tfrac12\\bigr)\\;-\\;6\\arctanh\\!\\bigl(\\tfrac{97}{584}\\bigr)}$$\n"}, {"introduction": "The behavior of iterative decoders near their performance threshold bears a striking resemblance to critical phase transitions in statistical physics. This analogy is not just qualitative; it allows for quantitative predictions about performance, governed by universal laws. This exercise [@problem_id:123413] introduces a powerful phenomenological model for the decoding dynamics near its critical point, enabling you to derive a universal scaling exponent $\\beta$ that describes how the logical error rate vanishes as the physical error rate approaches the threshold.", "id": "123413", "problem": "A family of `(w_c, w_r)`-regular quantum low-density parity-check (QLDPC) codes is used for error correction on a quantum depolarizing channel. The performance of a belief-propagation (BP) decoder for such a system exhibits a sharp threshold at a physical error probability `p_{th}`. For physical error rates `p < p_{th}`, the decoder successfully corrects errors with high probability, while for `p > p_{th}`, it fails. The behavior near this threshold is analogous to a critical phase transition in statistical physics.\n\nThe state of the iterative decoder can be characterized by a single parameter, `x`, representing the average probability that a message passed between nodes in the code's Tanner graph is incorrect. The evolution of this parameter over iterations is modeled by a discrete-time map.\n\nLet `\\epsilon = (p_{th}-p)/p_{th}` be the reduced distance from the threshold, where `p` is the physical error rate. For `p` just below `p_{th}`, `\\epsilon` is a small positive number (`0 < \\epsilon \\ll 1`). In this regime, the evolution of the average message error probability `x_t` at iteration `t` is accurately described by the phenomenological map:\n$$\nx_{t+1} = (1+\\alpha\\epsilon)x_t - \\gamma x_t^3\n$$\nHere, `\\alpha` and `\\gamma` are positive, dimensionless constants that depend on the code structure (i.e., on the weights `w_c` and `w_r`). The term `(1+\\alpha\\epsilon)x_t` reflects the tendency for errors to proliferate slightly below the threshold, while the term `-\\gamma x_t^3` models the collective, non-linear error-correcting capability of the code's check nodes. The cubic form is characteristic of systems with certain symmetries where quadratic terms vanish.\n\nAfter many iterations, the system settles into a steady-state message error probability, `x_\\infty(\\epsilon)`. It is assumed that the logical error rate of the code, `P_L`, is directly proportional to this residual error: `P_L \\propto x_\\infty(\\epsilon)`. The logical error rate is thus expected to follow a power-law scaling with respect to the distance from the threshold:\n$$\nP_L \\propto \\epsilon^\\beta\n$$\nDerive the value of the scaling exponent `\\beta`.\n\n", "solution": "We impose the fixed‐point condition $x_{t+1}=x_t=x_\\infty$. The evolution map is\n$$\nx_\\infty = (1+\\alpha\\epsilon)x_\\infty - \\gamma x_\\infty^3.\n$$\n\nRearranging gives\n$$\n0 = \\alpha\\epsilon\\,x_\\infty - \\gamma\\,x_\\infty^3.\n$$\n\nFor the nontrivial solution $x_\\infty\\neq0$,\n$$\n\\alpha\\epsilon - \\gamma\\,x_\\infty^2 = 0\n\\quad\\Rightarrow\\quad\nx_\\infty^2 = \\frac{\\alpha}{\\gamma}\\,\\epsilon.\n$$\n\nTaking the positive root yields\n$$\nx_\\infty = \\sqrt{\\frac{\\alpha}{\\gamma}}\\,\\epsilon^{1/2}.\n$$\n\nSince $P_L\\propto x_\\infty$, it follows that $P_L\\propto \\epsilon^{1/2}$ and hence $\\beta=\\tfrac12$.", "answer": "$$\\boxed{\\frac{1}{2}}$$"}]}