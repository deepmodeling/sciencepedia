{"hands_on_practices": [{"introduction": "The first step towards building a functional quantum computer is mastering the control of individual qubits. This exercise [@problem_id:63624] delves into this fundamental challenge by asking you to quantify the performance of a single-qubit NOT gate, one of the most basic building blocks. By modeling the impact of quasi-static frequency detuning—a common form of environmental noise—you will calculate the average gate fidelity, connecting an abstract performance metric to a realistic physical error mechanism.", "problem": "A single qubit is subjected to a resonant driving field. In a rotating frame, the Hamiltonian describing this system in the presence of a frequency detuning $\\delta$ is given by:\n$$ H = \\frac{\\hbar}{2} \\left( \\Omega \\sigma_x + \\delta \\sigma_z \\right) $$\nwhere $\\sigma_x$ and $\\sigma_z$ are Pauli matrices, $\\Omega$ is the Rabi frequency of the driving field, and $\\delta$ represents a quasi-static detuning of the qubit's transition frequency from the drive frequency. The detuning $\\delta$ is a random variable that is constant during a single gate operation but varies from one operation to the next. It is drawn from a Gaussian probability distribution $P(\\delta)$ with zero mean and variance $\\sigma^2$:\n$$ P(\\delta) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{\\delta^2}{2\\sigma^2}\\right) $$\nAn ideal single-qubit NOT gate (an X-gate) is implemented by a resonant ($\\delta = 0$) $\\pi$-pulse, which corresponds to applying the drive for a time $T = \\pi/\\Omega$. The presence of the detuning $\\delta$ causes errors in the gate operation.\n\nThe quality of the gate is quantified by the average gate fidelity, $\\bar{F}$. The corresponding average gate infidelity is $\\mathcal{I} = 1 - \\bar{F}$. In the limit of small noise, where the standard deviation of the detuning is much smaller than the Rabi frequency ($\\sigma \\ll \\Omega$), the average gate infidelity can be approximated by its leading-order term:\n$$ \\mathcal{I} \\approx C \\left( \\frac{\\sigma}{\\Omega} \\right)^2 $$\nYour task is to calculate the dimensionless coefficient $C$. For this problem, you may set $\\hbar=1$.", "solution": "We set $\\hbar=1$ and define the small parameter $\\epsilon = \\delta / \\Omega$. The ideal X-gate is $V = \\exp(-i(\\pi/2)\\sigma_x) = -i\\sigma_x$ (up to a global phase). The actual evolution under the Hamiltonian $H = \\frac{1}{2}\\Omega(\\sigma_x + \\epsilon\\sigma_z)$ for time $T=\\pi/\\Omega$ is\n$$ U(\\delta) = \\exp\\left[-i\\frac{\\pi}{2}(\\sigma_x + \\epsilon\\sigma_z)\\right] = \\cos\\left(\\frac{\\theta}{2}\\right)I - i\\sin\\left(\\frac{\\theta}{2}\\right)\\mathbf{N}\\cdot\\boldsymbol{\\sigma} $$\nwhere $\\theta = \\pi\\sqrt{1+\\epsilon^2}$ and the rotation axis is $\\mathbf{N} = (1, 0, \\epsilon) / \\sqrt{1+\\epsilon^2}$.\n\nThe average gate fidelity for a single qubit ($d=2$) is given by the formula:\n$$ F(\\delta) = \\frac{|\\text{Tr}(V^\\dagger U)|^2 + 2}{6} $$\nWith $V^\\dagger = +i\\sigma_x$, we compute the trace:\n$$ \\text{Tr}(V^\\dagger U) = i\\,\\text{Tr}(\\sigma_x U) = 2 N_x \\sin\\left(\\frac{\\theta}{2}\\right), \\quad \\text{where } N_x = \\frac{1}{\\sqrt{1+\\epsilon^2}} $$\nThus, the squared trace is:\n$$ |\\text{Tr}(V^\\dagger U)|^2 = \\frac{4}{1+\\epsilon^2}\\sin^2\\left(\\frac{\\pi}{2}\\sqrt{1+\\epsilon^2}\\right) $$\nFor small $\\epsilon \\ll 1$, we expand the terms. First, $\\sqrt{1+\\epsilon^2} \\approx 1 + \\epsilon^2/2$. Then the argument of the sine function is $\\frac{\\pi}{2}\\sqrt{1+\\epsilon^2} \\approx \\frac{\\pi}{2} + \\frac{\\pi}{4}\\epsilon^2$. Using $\\sin(\\pi/2 + x) = \\cos(x)$, we get:\n$$ \\sin^2\\left(\\frac{\\pi}{2}\\sqrt{1+\\epsilon^2}\\right) \\approx \\cos^2\\left(\\frac{\\pi}{4}\\epsilon^2\\right) \\approx 1 - O(\\epsilon^4) $$\nThe fidelity is then:\n$$ F(\\delta) \\approx \\frac{4(1-\\epsilon^2)(1) + 2}{6} = \\frac{6 - 4\\epsilon^2}{6} = 1 - \\frac{2}{3}\\epsilon^2 $$\nThe average gate infidelity $\\mathcal{I}$ is $1 - \\bar{F}$. We average $F(\\delta)$ over the Gaussian distribution of $\\delta$.\n$$ \\bar{F} = \\langle F(\\delta) \\rangle \\approx \\left\\langle 1 - \\frac{2}{3}\\epsilon^2 \\right\\rangle = 1 - \\frac{2}{3}\\langle \\epsilon^2 \\rangle $$\nSince $\\epsilon = \\delta/\\Omega$, we have $\\langle \\epsilon^2 \\rangle = \\langle (\\delta/\\Omega)^2 \\rangle = \\langle \\delta^2 \\rangle / \\Omega^2 = \\sigma^2/\\Omega^2$.\nSo the infidelity is:\n$$ \\mathcal{I} = 1 - \\bar{F} \\approx \\frac{2}{3}\\left(\\frac{\\sigma}{\\Omega}\\right)^2 $$\nComparing this to the given form $\\mathcal{I} \\approx C (\\sigma/\\Omega)^2$, we find the coefficient $C = 2/3$.", "answer": "$$\\boxed{\\frac{2}{3}}$$", "id": "63624"}, {"introduction": "A quantum algorithm, in its abstract form, often assumes that any two qubits can interact. However, real quantum hardware has rigid constraints, such as only allowing interactions between nearest-neighbor qubits. This practice problem [@problem_id:63601] addresses this critical challenge of \"quantum compilation\" by tasking you with mapping a three-qubit Quantum Fourier Transform onto a linear qubit array. This involves decomposing gates and optimizing the circuit schedule, providing hands-on experience with the practical steps required to run algorithms on physical devices.", "problem": "A crucial aspect of designing quantum algorithms for physical hardware is compiling the abstract circuit into a sequence of native gates executable on a specific quantum processor architecture. A common architecture is a linear array of qubits with nearest-neighbor connectivity.\n\nConsider a 3-qubit system with qubits labeled $q_0, q_1, q_2$ arranged in a line, such that two-qubit gates can only be performed between adjacent pairs $(q_0, q_1)$ and $(q_1, q_2)$. The native gate set consists of arbitrary single-qubit unitary gates and Controlled-NOT (CNOT) gates between adjacent qubits.\n\nThe Quantum Fourier Transform (QFT) on 3 qubits is defined by the standard circuit composed of Hadamard (H) gates, controlled-phase gates ($C-P(\\phi)$), and a final SWAP gate to correctly order the output qubits. The logical circuit is given by:\n$$ U_{\\text{QFT3}} = \\text{SWAP}(q_0, q_2) \\cdot (I \\otimes I \\otimes H_2) \\cdot C-P_{21}(\\pi/2) \\cdot C-P_{20}(\\pi/4) \\cdot (I \\otimes H_1 \\otimes I) \\cdot C-P_{10}(\\pi/2) \\cdot (H_0 \\otimes I \\otimes I) $$\nwhere $C-P_{ij}(\\phi)$ is a controlled-phase gate with control qubit $q_i$ and target qubit $q_j$, and $H_k$ is a Hadamard gate on qubit $q_k$.\n\nTo implement this on the linear array, the logical gates must be decomposed into native gates. Use the following standard decompositions:\n1.  A nearest-neighbor controlled-phase gate $C-P_{c,t}(\\phi)$ is implemented using a sequence of gates that includes two CNOTs. For depth calculation, its decomposition is: $P(\\phi/2)_c$, followed by CNOT($c,t$), followed by $P(-\\phi/2)_t$, followed by CNOT($c,t$).\n2.  A CNOT gate between non-adjacent qubits $q_i$ and $q_{i+2}$ (i.e., CNOT($i, i+2$)) is implemented via the intermediate qubit $q_{i+1}$ as: CNOT($i+1, i+2$), CNOT($i, i+1$), CNOT($i+1, i+2$), CNOT($i, i+1$). The same pattern applies to CNOT($i+2, i$).\n3.  A SWAP gate between non-adjacent qubits $q_i$ and $q_{i+2}$ is implemented by a sequence of three nearest-neighbor SWAPs: SWAP($i, i+1$), SWAP($i+1, i+2$), SWAP($i, i+1$). A nearest-neighbor SWAP($j, j+1$) is implemented with three CNOTs: CNOT($j, j+1$), CNOT($j+1, j$), CNOT($j, j+1$).\n\nThe circuit depth is defined as the number of layers of simultaneously executable gates. A layer can consist of:\n- Any number of single-qubit gates acting on different qubits.\n- A set of non-overlapping CNOT gates. Note that on a 3-qubit linear array, CNOT($q_0,q_1$) and CNOT($q_1,q_2$) conflict, so at most one CNOT can be active in any layer.\n\nAssume CNOTs in both directions (e.g., CNOT($q_0,q_1$) and CNOT($q_1,q_0$)) are available as primitive gates of depth 1.\n\nDetermine the minimum circuit depth required to implement the full 3-qubit QFT on this linear array.", "solution": "The total circuit depth is the sum of layers required for CNOT operations and layers for single-qubit gates that cannot be parallelized.\n      \n1.  **Calculate the CNOT cost for each logical gate.** Since at most one CNOT can be active in any layer, the CNOT depth is the total number of CNOTs.\n    *   $C-P_{10}(\\pi/2)$ (nearest-neighbor): The decomposition rule implies 2 CNOTs.\n    *   $C-P_{20}(\\pi/4)$ (non-adjacent): This gate's decomposition requires two CNOTs between non-adjacent qubits $q_2$ and $q_0$. Each non-adjacent CNOT is implemented with 4 nearest-neighbor CNOTs. Total cost = $2 \\times 4 = 8$ CNOTs.\n    *   $C-P_{21}(\\pi/2)$ (nearest-neighbor): 2 CNOTs.\n    *   $\\text{SWAP}(q_0, q_2)$ (non-adjacent): Requires 3 nearest-neighbor SWAPs. Each nn-SWAP costs 3 CNOTs. Total cost = $3 \\times 3 = 9$ CNOTs.\n    *   **Total CNOT Depth**: $2 + 8 + 2 + 9 = 21$ layers.\n\n2.  **Calculate the single-qubit gate layer depth.** We must add layers for the single-qubit gates (H and P gates from the CP-decompositions) that are sequenced between the CNOT blocks. We group them to find the minimum number of additional layers.\n    *   Layer 1: $H_0$ (at the very beginning).\n    *   Layer 2: The first $P$ gate for $C-P_{10}$.\n    *   Layer 3: The second $P$ gate for $C-P_{10}$ and the $H_1$ gate (these can be done in parallel).\n    *   Layer 4: The first $P$ gate for $C-P_{20}$.\n    *   Layer 5: The second $P$ gate for $C-P_{20}$.\n    *   Layer 6: The $P$ gates for $C-P_{21}$ and the $H_2$ gate (these can be grouped into a single layer before the SWAP CNOTs).\n    \n    This conservative scheduling, where single-qubit gate layers are executed separately from CNOT layers, adds 6 layers to the depth.\n\n3.  **Calculate Total Depth.** Summing the CNOT depth and the single-qubit gate depth gives the total circuit depth.\n    *   Total Depth = (CNOT Depth) + (Single-Qubit Gate Depth) = $21 + 6 = 27$.", "answer": "$$\\boxed{27}$$", "id": "63601"}, {"introduction": "For a quantum computer to be robust against noise, operations are typically restricted to a set of fault-tolerant gates, like the Clifford+T set. This poses a challenge: how do we perform arbitrary rotations, such as $R_z(\\theta)$, that are essential for many algorithms using only these discrete building blocks? This problem [@problem_id:63628] explores the state-of-the-art solution, where such gates are approximated by a sequence of T-gates and Clifford operations. You will determine the optimal T-count to synthesize a target rotation to a given precision, a task that sits at the heart of compiling powerful quantum algorithms.", "problem": "In the field of fault-tolerant quantum computation, the Clifford+T gate set is a standard choice for universal computation. The set consists of the Clifford gates (Hadamard gate $H$, Phase gate $S=\\sqrt{Z}$, and CNOT) and the non-Clifford $T$ gate, where $T=S^{1/2}=\\begin{pmatrix} 1 & 0 \\\\ 0 & e^{i\\pi/4} \\end{pmatrix}$. While Clifford gates can be implemented fault-tolerantly with relative ease (e.g., via state distillation and gate teleportation), the $T$ gate is a resource-intensive \"magic\" state. Consequently, it is crucial to minimize the number of $T$ gates (the T-count) in a quantum circuit.\n\nArbitrary single-qubit rotations, such as $R_z(\\theta) = \\exp(-i\\theta Z/2) = \\begin{pmatrix} e^{-i\\theta/2} & 0 \\\\ 0 & e^{i\\theta/2} \\end{pmatrix}$, must be approximated by sequences of Clifford and T gates. A common and efficient strategy for synthesizing Z-rotations is to use a number-theoretic algorithm that finds an optimal approximation of $R_z(\\theta)$ by a rotation of the form $R_z(k\\pi/2^m)$, where $k$ and $m$ are integers. Such a rotation can be synthesized using only Clifford and T gates.\n\nFor a target gate $U_{target}$ and its approximation $U_{approx}$, the synthesis error is measured by the operator norm distance $\\epsilon = \\|U_{target} - U_{approx}\\|$. The relationship between the operator norm distance and the angle difference for two Z-rotations is given by $\\|R_z(\\theta_1) - R_z(\\theta_2)\\| = 2|\\sin((\\theta_1-\\theta_2)/4)|$.\n\nState-of-the-art algorithms can synthesize the gate $R_z(k\\pi/2^m)$, for an odd integer $k$, with a T-count of exactly $T_c = 4m-2$. If $k$ is even, say $k=2j$, then $R_z(k\\pi/2^m) = R_z(j\\pi/2^{m-1})$, and a more efficient synthesis with a T-count based on $m-1$ is possible. Therefore, to find the optimal T-count, one should always reduce the fraction $k/2^m$ until $k$ is odd.\n\nYour task is to determine the optimal (minimum) T-count required to synthesize the single-qubit rotation $R_z(\\pi/15)$ to a precision of $\\epsilon = 10^{-10}$.", "solution": "We want to approximate the target rotation $R_z(\\pi/15)$ by an accessible rotation $R_z(k\\pi/2^m)$ such that the operator norm error $\\epsilon = \\|R_z(\\pi/15)-R_z(k\\pi/2^m)\\|$ is at most $10^{-10}$.\n\n1.  **Error Condition:** The error for two Z-rotations $R_z(\\theta_1)$ and $R_z(\\theta_2)$ is given by $\\epsilon = 2|\\sin((\\theta_1-\\theta_2)/4)|$. We require this to be $\\le 10^{-10}$.\n    $$ 2\\left|\\sin\\left(\\frac{\\theta_1-\\theta_2}{4}\\right)\\right| \\le \\epsilon $$\n    For small angles, $\\sin(x) \\approx x$, so the condition on the angle difference $\\delta\\theta = \\theta_1 - \\theta_2$ is approximately $|\\delta\\theta/4| \\le \\epsilon/2$, or $|\\delta\\theta| \\le 2\\epsilon$. Using the arcsin for better precision:\n    $$ |\\delta\\theta| \\le 4\\arcsin\\left(\\frac{\\epsilon}{2}\\right) $$\n\n2.  **Angle Approximation:** We need to find integers $k, m$ such that the angle difference $|\\pi/15 - k\\pi/2^m|$ satisfies the condition. Dividing by $\\pi$:\n    $$ \\left|\\frac{1}{15} - \\frac{k}{2^m}\\right| \\le \\frac{4\\arcsin(\\epsilon/2)}{\\pi} $$\n    Let's calculate the required precision threshold, $\\Delta$:\n    $$ \\Delta = \\frac{4\\arcsin(5 \\times 10^{-11})}{\\pi} \\approx 6.366 \\times 10^{-11} $$\n\n3.  **Finding m:** We are looking for the best rational approximation of $1/15$ with a denominator of $2^m$. A simple way to find a sufficient $m$ is to bound the approximation error. If we choose $k = \\text{round}(2^m/15)$, the error is at most half the step size:\n    $$ \\left|\\frac{1}{15} - \\frac{k}{2^m}\\right| = \\frac{|2^m/15 - k|}{2^m} \\le \\frac{0.5}{2^m} = \\frac{1}{2^{m+1}} $$\n    To guarantee our error is small enough, we require $\\frac{1}{2^{m+1}} \\le \\Delta$, which gives $2^{m+1} \\ge 1/\\Delta \\approx 1.57 \\times 10^{10}$. Taking $\\log_2$ of both sides:\n    $$ m+1 \\ge \\log_2(1.57 \\times 10^{10}) \\approx 33.86 $$\n    This implies we need at least $m = 33$. However, this is a worst-case bound. Let's test if a smaller $m$, like $m=32$, is sufficient.\n\n4.  **Test $m=32$:**\n    We calculate the nearest integer $k$ to $2^{32}/15$:\n    $$ k = \\text{round}(2^{32}/15) = \\text{round}(286331153.0666\\ldots) = 286331153 $$\n    Now we check the actual error for this choice of $k$ and $m=32$:\n    $$ \\left|\\frac{1}{15} - \\frac{286331153}{2^{32}}\\right| = \\frac{|2^{32}/15 - 286331153|}{2^{32}} = \\frac{|286331153.0666... - 286331153|}{2^{32}} \\approx \\frac{0.0666...}{2^{32}} \\approx 1.55 \\times 10^{-11} $$\n    Since $1.55 \\times 10^{-11}  6.366 \\times 10^{-11}$, the precision requirement is met with $m=32$.\n\n5.  **Calculate T-Count:** The integer $k=286331153$ is odd. The T-count for synthesizing $R_z(k\\pi/2^m)$ with odd $k$ is given by the formula $T_c = 4m - 2$.\n    $$ T_c = 4(32) - 2 = 128 - 2 = 126 $$\nThe minimal T-count is 126.", "answer": "$$\\boxed{126}$$", "id": "63628"}]}