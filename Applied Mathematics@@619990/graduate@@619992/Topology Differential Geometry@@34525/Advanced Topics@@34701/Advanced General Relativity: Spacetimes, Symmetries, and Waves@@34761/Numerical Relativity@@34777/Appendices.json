{"hands_on_practices": [{"introduction": "Before evolving Einstein's equations through time, one must first specify a valid \"snapshot\" of the spacetime geometry on an initial slice. This initial data is not arbitrary; it must satisfy a set of constraint equations. This exercise [@problem_id:1001099] delves into the Hamiltonian constraint, a cornerstone of the 3+1 formalism, by asking you to quantify how a proposed initial state, constructed using the common conformal method, deviates from being a physically valid vacuum solution.", "problem": "In the 3+1 ADM formalism of general relativity, the Einstein field equations for a vacuum spacetime split into constraint and evolution equations. For initial data on a spacelike hypersurface $\\Sigma$, the Hamiltonian constraint must be satisfied. For a time-symmetric slice, the extrinsic curvature $K_{ij}$ vanishes, and the Hamiltonian constraint simplifies to $\\mathcal{H} = R = 0$, where $R$ is the Ricci scalar of the 3-metric $\\gamma_{ij}$ on the slice.\n\nA common method for constructing initial data is the conformal method. One proposes a physical metric $\\gamma_{ij}$ that is conformally related to a simpler, known metric $\\tilde{\\gamma}_{ij}$ via a conformal factor $\\psi$:\n$$\n\\gamma_{ij} = \\psi^4 \\tilde{\\gamma}_{ij}\n$$\nIf we choose the conformal metric to be flat, $\\tilde{\\gamma}_{ij} = \\delta_{ij}$ (the Euclidean metric), the physical metric is called conformally flat. For such a metric, the Ricci scalar $R$ is related to the conformal factor $\\psi$ by the equation:\n$$\nR = -8\\psi^{-5} \\nabla^2 \\psi\n$$\nwhere $\\nabla^2 = \\delta^{ij}\\partial_i\\partial_j$ is the standard flat-space Laplacian operator. If $\\psi$ is a solution to the Hamiltonian constraint, then $\\nabla^2 \\psi = 0$.\n\nConsider a proposed conformal factor given in spherical coordinates $(r, \\theta, \\phi)$ by:\n$$\n\\psi(r) = A \\exp\\left(-\\frac{r^2}{\\sigma^2}\\right) + B\n$$\nwhere $r = \\sqrt{x^2+y^2+z^2}$ is the radial coordinate, and $A$, $B$, and $\\sigma$ are positive real constants. This form of $\\psi$ does not generally satisfy the Hamiltonian constraint.\n\nDerive an expression for the Hamiltonian constraint violation, $\\mathcal{H}$, at the radial coordinate $r=\\sigma$. Your final answer should be a closed-form expression in terms of the constants $A$, $B$, and $\\sigma$.", "solution": "We start from the Hamiltonian-constraint violation for a conformally flat metric,\n$$\n\\mathcal{H}=R=-8\\,\\psi^{-5}\\nabla^2\\psi\\,,\n$$\nand for a purely radial $\\psi(r)$ in flat space,\n$$\n\\nabla^2\\psi\n=\\frac{1}{r^2}\\partial_r\\bigl(r^2\\partial_r\\psi\\bigr)\\,. \n$$\nGiven \n$$\n\\psi(r)=A\\exp\\bigl(-\\tfrac{r^2}{\\sigma^2}\\bigr)+B,\n$$\nwe compute\n$$\n\\partial_r\\psi\n=A\\bigl(-\\tfrac{2r}{\\sigma^2}\\bigr)e^{-r^2/\\sigma^2}\n=-\\frac{2Ar}{\\sigma^2}e^{-r^2/\\sigma^2},\n$$\n$$\nr^2\\partial_r\\psi\n=-\\frac{2A\\,r^3}{\\sigma^2}e^{-r^2/\\sigma^2},\n$$\n$$\n\\partial_r\\bigl(r^2\\partial_r\\psi\\bigr)\n=-\\frac{2A}{\\sigma^2}\\frac{d}{dr}\\Bigl(r^3e^{-r^2/\\sigma^2}\\Bigr)\n=-\\frac{2A}{\\sigma^2}e^{-r^2/\\sigma^2}\\bigl(3r^2-\\tfrac{2r^4}{\\sigma^2}\\bigr).\n$$\nHence\n$$\n\\nabla^2\\psi\n=-\\frac{2A}{\\sigma^2}e^{-r^2/\\sigma^2}\\Bigl(3-\\frac{2r^2}{\\sigma^2}\\Bigr).\n$$\nEvaluating at $r=\\sigma$ gives $r^2/\\sigma^2=1$ and\n$$\n\\nabla^2\\psi\\big|_{r=\\sigma}\n=-\\frac{2A}{\\sigma^2}e^{-1}.\n$$\nThus\n$$\n\\mathcal{H}\\big|_{r=\\sigma}\n=-8\\,\\psi^{-5}\n\\Bigl(-\\frac{2A}{\\sigma^2}e^{-1}\\Bigr)\n=\\frac{16A\\,e^{-1}}{\\sigma^2\\,\\psi(\\sigma)^5},\n$$\nwith $\\psi(\\sigma)=A e^{-1}+B$.", "answer": "$$\\boxed{\\frac{16A e^{-1}}{\\sigma^2\\bigl(Ae^{-1}+B\\bigr)^5}}$$", "id": "1001099"}, {"introduction": "A numerical simulation is only useful if it remains stable and produces physically meaningful results over time. This exercise [@problem_id:1001246] addresses the fundamental concept of numerical stability through the lens of the renowned Courant-Friedrichs-Lewy (CFL) condition. By performing a Von Neumann stability analysis on a discretized wave equation, you will derive the critical relationship between the time step $\\Delta t$ and grid spacing $\\Delta x$ required to prevent numerical errors from growing uncontrollably.", "problem": "The one-dimensional scalar wave equation is a fundamental model in mathematical physics, given by\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = v^2 \\frac{\\partial^2 u}{\\partial x^2}\n$$\nwhere $u(x, t)$ is the wave amplitude, $v$ is the constant propagation speed, $t$ is time, and $x$ is the spatial coordinate. In numerical relativity, a stable numerical scheme is crucial for evolving such equations.\n\nConsider a numerical solution on a uniform grid with spatial step $\\Delta x$ and time step $\\Delta t$, where $u_j^n \\equiv u(j\\Delta x, n\\Delta t)$. The wave equation is discretized using a second-order accurate centered finite-difference scheme in space and a second-order leapfrog scheme in time:\n$$\n\\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2} = v^2 \\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} \\right)\n$$\nTo analyze the stability of this scheme, we use the Von Neumann method. We consider a single Fourier mode for the numerical solution:\n$$\nu_j^n = \\xi^n e^{i k j \\Delta x}\n$$\nwhere $k$ is the wave number and $\\xi = \\xi(k)$ is the complex amplification factor. For the numerical solution to remain bounded (i.e., for the scheme to be stable), the magnitude of the amplification factor must satisfy the condition $|\\xi| \\le 1$ for all possible real wave numbers $k$.\n\nThe Courant-Friedrichs-Lewy (CFL) condition arises from this analysis. It constrains the relationship between the time step, spatial step, and wave speed. This relationship is typically expressed in terms of the Courant number, $\\mu = \\frac{v \\Delta t}{\\Delta x}$.\n\nYour task is to determine the stability limit for this specific numerical scheme. Derive the maximum allowed value of the Courant number $\\mu$ for which the scheme is stable for all wave numbers.", "solution": "We discretize the wave equation via centered differences in space and leap-frog in time:\n$$\\frac{u_j^{n+1}-2u_j^n+u_j^{n-1}}{(\\Delta t)^2}\n= v^2\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}\\,. $$\n\n1.  Substitute the Fourier mode $u_j^n=\\xi^n e^{ikj\\Delta x}$.  Then\n$$\\frac{\\xi^{n+1}-2\\xi^n+\\xi^{n-1}}{(\\Delta t)^2}\n= v^2\\frac{e^{ik\\Delta x}-2+e^{-ik\\Delta x}}{(\\Delta x)^2}\\,\\xi^n.$$\nDivide by $\\xi^n$ and multiply by $(\\Delta t)^2$:\n$$\\xi+\\xi^{-1}-2=\\mu^2\\,(e^{i k\\Delta x}-2+e^{-i k\\Delta x}),\\quad\n\\mu=\\frac{v\\Delta t}{\\Delta x}.$$\n\n2.  Use $e^{i\\theta}+e^{-i\\theta}-2=-4\\sin^2(\\theta/2)$ with $\\theta=k\\Delta x$:\n$$\\xi+\\xi^{-1}-2=-4\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\n\\;\\Longrightarrow\\;\n\\cos(\\omega\\Delta t)=1-2\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr),$$\nwhere $\\xi=e^{\\pm i\\omega\\Delta t}$.\n\n3.  Stability requires the right‐hand side lie in $[-1,1]$ for all $k$:\n$$-1\\le 1-2\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\\le1.$$\nThe most restrictive bound is\n$$1-2\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\\ge -1\n\\;\\Longrightarrow\\;\n\\mu^2\\sin^2\\!\\bigl(\\tfrac{k\\Delta x}{2}\\bigr)\\le1.$$\nSince $\\sin^2\\!(\\tfrac{k\\Delta x}{2})\\le1$ for all real $k$, we obtain\n$$\\mu^2\\le1\\quad\\Longrightarrow\\quad \\mu\\le1.$$\nThus the scheme is stable for $\\mu\\le1\\,$.", "answer": "$$\\boxed{1}$$", "id": "1001246"}, {"introduction": "Modern simulations of dynamic spacetimes, such as black hole mergers, rely on sophisticated reformulations of Einstein's equations to ensure long-term stability. The Baumgarte-Shapiro-Shibata-Nakamura (BSSN) formalism is a leading example, improving upon the foundational Arnowitt-Deser-Misner (ADM) formulation. This hands-on coding problem [@problem_id:2420591] bridges theory and practice by guiding you through the implementation of the essential transformation from ADM initial data to the BSSN variables, a critical first step in building a robust numerical relativity code.", "problem": "You are to implement, verify, and test a transformation from Arnowitt–Deser–Misner (ADM) initial data to Baumgarte–Shapiro–Shibata–Nakamura (BSSN) variables on a uniform three-dimensional Cartesian grid using periodic boundary conditions. The ADM initial data consist of the spatial metric $\\gamma_{ij}$ and the extrinsic curvature $K_{ij}$. The BSSN variables to be produced are the conformal factor $\\phi$, the conformal metric $\\tilde{\\gamma}_{ij}$, the conformal trace-free extrinsic curvature $A_{ij}$, the mean curvature $K$, and the contracted conformal connection functions $\\tilde{\\Gamma}^{i}$.\n\nStarting point (fundamental definitions and identities from the $3+1$ decomposition and the BSSN formulation):\n- The conformal decomposition of the metric is $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$ with $\\det(\\tilde{\\gamma}_{ij}) = 1$. From this, $\\det(\\gamma_{ij}) = e^{12 \\phi}$ and thus $\\phi = \\frac{1}{12} \\ln \\det(\\gamma_{ij})$.\n- The mean curvature is the trace of the extrinsic curvature with respect to $\\gamma_{ij}$: $K = \\gamma^{ij} K_{ij}$, where $\\gamma^{ij}$ is the matrix inverse of $\\gamma_{ij}$.\n- The trace-free part of $K_{ij}$ is $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$. The conformal trace-free extrinsic curvature is $A_{ij} = e^{-4 \\phi} S_{ij}$.\n- The contracted conformal connection functions in Cartesian coordinates with $\\det(\\tilde{\\gamma}_{ij}) = 1$ satisfy $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$, where $\\tilde{\\gamma}^{ij}$ is the matrix inverse of $\\tilde{\\gamma}_{ij}$. Spatial derivatives are to be approximated numerically.\n\nNumerical requirements:\n- Use a uniform Cartesian grid with $N \\times N \\times N$ points covering the periodic domain $[0, L] \\times [0, L] \\times [0, L]$. Grid spacing is $\\Delta x = \\Delta y = \\Delta z = L/N$. Grid points are located at $x_{n} = n \\Delta x$, $y_{m} = m \\Delta y$, $z_{p} = p \\Delta z$ for integers $n, m, p$ in $\\{0, 1, \\dots, N-1\\}$.\n- Use periodic boundary conditions in all three directions.\n- Compute spatial derivatives with a second-order central finite difference. For any scalar or tensor component $u$, the discrete derivative along coordinate $x$ is $\\partial_{x} u \\approx \\left(u(x+\\Delta x) - u(x-\\Delta x)\\right) / (2 \\Delta x)$, and similarly for $y$ and $z$, with periodic wrapping.\n\nImplementation tasks:\n- Write a module that, given fields $\\gamma_{ij}$ and $K_{ij}$ on the grid, computes $\\phi$, $\\tilde{\\gamma}_{ij}$, $A_{ij}$, $K$, and $\\tilde{\\Gamma}^{i}$ at every grid point according to the definitions above.\n- Validate the implementation on the following three test cases. In each case, the ADM data are specified analytically, and you must construct $\\gamma_{ij}$ and $K_{ij}$ on the grid, apply your transformation, and compare to analytically known BSSN quantities wherever they are nontrivial.\n\nTest suite (use the same grid parameters $N$ and $L$ for all cases):\n- Common grid parameters: $N = 32$, $L = 2\\pi$.\n\n- Case $1$ (pure conformal factor with flat conformal metric, vanishing extrinsic curvature):\n  - Define $f(x) = a \\sin(k x)$ with $a = 0.1$ and $k = 1$, depending on $x$ only.\n  - Set $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ and $K_{ij} = 0$.\n  - Analytic BSSN references: $\\phi = f(x)$, $\\tilde{\\gamma}_{ij} = \\delta_{ij}$, $A_{ij} = 0$, $K = 0$, $\\tilde{\\Gamma}^{i} = 0$.\n\n- Case $2$ (nontrivial unit-determinant conformal metric with zero conformal factor and vanishing extrinsic curvature):\n  - Define $h(x) = b \\cos(k x)$ with $b = 0.2$ and $k = 2$, depending on $x$ only.\n  - Set $\\tilde{\\gamma}_{ij} = \\mathrm{diag}\\left(e^{h(x)}, e^{-h(x)}, 1\\right)$ and $\\gamma_{ij} = \\tilde{\\gamma}_{ij}$, with $K_{ij} = 0$.\n  - Analytic BSSN references: $\\phi = 0$, $A_{ij} = 0$, $K = 0$. The inverse conformal metric is $\\tilde{\\gamma}^{ij} = \\mathrm{diag}\\left(e^{-h(x)}, e^{h(x)}, 1\\right)$. Hence $\\tilde{\\Gamma}^{x} = -\\partial_{x}\\tilde{\\gamma}^{xx} = e^{-h(x)} h'(x)$ with $h'(x) = - b k \\sin(k x)$, and $\\tilde{\\Gamma}^{y} = 0$, $\\tilde{\\Gamma}^{z} = 0$.\n\n- Case $3$ (nontrivial conformal factor, flat conformal metric, and extrinsic curvature with prescribed trace and trace-free parts):\n  - Define $f(x) = a \\cos(k x)$ with $a = 0.05$ and $k = 3$, depending on $x$ only. Let $K_{0} = 0.4$ and $s = 0.3$ be constants.\n  - Set $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ and define a constant trace-free tensor $S_{ij} = \\mathrm{diag}(s, -s/2, -s/2)$ (trace-free with respect to $\\delta_{ij}$). Define $K_{ij} = \\frac{1}{3} \\gamma_{ij} K_{0} + e^{4 f(x)} S_{ij}$.\n  - Analytic BSSN references: $\\phi = f(x)$, $\\tilde{\\gamma}_{ij} = \\delta_{ij}$, $K = K_{0}$, $A_{ij} = S_{ij}$, $\\tilde{\\Gamma}^{i} = 0$.\n\nError evaluation and required output:\n- For each case, compute:\n  - The maximum absolute error in $\\phi$ over all grid points: $\\max |\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{ref}}|$.\n  - The maximum absolute error in $K$ over all grid points: $\\max |K_{\\mathrm{num}} - K_{\\mathrm{ref}}|$.\n  - The maximum absolute error in $A_{ij}$ over all grid points and components: $\\max |A^{\\mathrm{num}}_{ij} - A^{\\mathrm{ref}}_{ij}|$.\n  - The maximum pointwise Euclidean norm of the error in $\\tilde{\\Gamma}^{i}$: $\\max \\sqrt{(\\Delta \\tilde{\\Gamma}^{x})^{2} + (\\Delta \\tilde{\\Gamma}^{y})^{2} + (\\Delta \\tilde{\\Gamma}^{z})^{2}}$.\n- Your program should produce a single line of output containing all results for the three cases, in order, as a comma-separated list enclosed in square brackets: $[\\mathrm{case1\\_phi},\\mathrm{case1\\_K},\\mathrm{case1\\_A},\\mathrm{case1\\_\\tilde{\\Gamma}};\\mathrm{case2\\_phi},\\mathrm{case2\\_K},\\mathrm{case2\\_A},\\mathrm{case2\\_\\tilde{\\Gamma}};\\mathrm{case3\\_phi},\\mathrm{case3\\_K},\\mathrm{case3\\_A},\\mathrm{case3\\_\\tilde{\\Gamma}}]$. Replace semicolons with commas in the actual output string, resulting in a flat list of $12$ floating-point numbers. No other text should be printed.", "solution": "The problem statement is submitted for validation. The givens, definitions, and test cases are extracted and analyzed for internal consistency and scientific validity. The problem concerns the transformation of initial data for Einstein's field equations from the Arnowitt–Deser–Misner (ADM) formalism to the Baumgarte–Shapiro–Shibata–Nakamura (BSSN) formalism. All definitions—the conformal decomposition of the metric $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$, the definition of the mean curvature $K = \\gamma^{ij} K_{ij}$, the conformal trace-free extrinsic curvature $A_{ij}$, and the contracted conformal connection functions $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$—are standard in the field of numerical relativity. The provided test cases are verified to be consistent with these definitions. The problem is a well-posed computational physics task with clear, objective specifications and verifiable outcomes. It is therefore deemed valid.\n\nThe solution requires implementing a numerical procedure to compute the BSSN variables ($\\phi, \\tilde{\\gamma}_{ij}, K, A_{ij}, \\tilde{\\Gamma}^{i}$) from the ADM variables ($\\gamma_{ij}, K_{ij}$) on a uniform Cartesian grid. The procedure is as follows.\n\nFirst, a uniform, periodic, three-dimensional Cartesian grid is established. The grid has $N \\times N \\times N$ points, where $N=32$, covering the domain $[0, L] \\times [0, L] \\times [0, L]$ with $L=2\\pi$. The grid spacing is $\\Delta x = \\Delta y = \\Delta z = L/N$. The coordinates at each grid point $(i,j,k)$ are $(x_i, y_j, z_k)$. For each of the three test cases, the initial ADM tensor fields $\\gamma_{ij}$ and $K_{ij}$ are constructed as arrays on this grid according to their analytical definitions.\n\nThe transformation proceeds with the following sequence of calculations at each grid point:\n\n1.  **Conformal Factor $\\phi$**: The determinant of the spatial metric, $\\det(\\gamma_{ij})$, is computed. The conformal factor is then given by $\\phi = \\frac{1}{12} \\ln(\\det(\\gamma_{ij}))$. This isolates the volumetric part of the spatial geometry.\n\n2.  **Conformal Metric $\\tilde{\\gamma}_{ij}$**: Using the computed conformal factor $\\phi$, the physical metric $\\gamma_{ij}$ is conformally rescaled to obtain the conformal metric $\\tilde{\\gamma}_{ij} = e^{-4\\phi} \\gamma_{ij}$. By construction, this metric has a unit determinant, $\\det(\\tilde{\\gamma}_{ij}) = 1$.\n\n3.  **Mean Curvature $K$**: The inverse of the physical spatial metric, $\\gamma^{ij}$, is computed by inverting the $3 \\times 3$ matrix $\\gamma_{ij}$ at each grid point. The mean curvature is then found by contracting the inverse metric with the extrinsic curvature: $K = \\gamma^{ij} K_{ij}$. This is a summation over both indices, representing the trace of $K_{ij}$.\n\n4.  **Conformal Trace-Free Extrinsic Curvature $A_{ij}$**: First, the trace-free part of the extrinsic curvature with respect to the physical metric is calculated as $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$. This tensor is then conformally rescaled to yield the BSSN variable $A_{ij} = e^{-4\\phi} S_{ij}$.\n\n5.  **Contracted Conformal Connection Functions $\\tilde{\\Gamma}^{i}$**: This is the only step requiring numerical differentiation.\n    a.  The inverse of the conformal metric, $\\tilde{\\gamma}^{ij}$, is computed from $\\tilde{\\gamma}_{ij}$.\n    b.  The spatial derivatives $\\partial_j$ of the components of $\\tilde{\\gamma}^{ij}$ are computed using a second-order central finite difference scheme with periodic boundary conditions. For a field $u(x,y,z)$ and grid spacing $\\Delta x$, the derivative with respect to $x$ at grid point $i$ is approximated as $\\partial_x u_i \\approx \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x}$. The periodic nature of the domain means that index $i+1$ at the boundary wraps to the beginning, and $i-1$ wraps to the end.\n    c.  The connection functions are then computed by contracting these derivatives: $\\tilde{\\Gamma}^{i} = - \\sum_{j} \\partial_j \\tilde{\\gamma}^{ij}$. Explicitly, for each component $i \\in \\{x, y, z\\}$:\n    $$ \\tilde{\\Gamma}^x = -(\\partial_x \\tilde{\\gamma}^{xx} + \\partial_y \\tilde{\\gamma}^{xy} + \\partial_z \\tilde{\\gamma}^{xz}) $$\n    $$ \\tilde{\\Gamma}^y = -(\\partial_x \\tilde{\\gamma}^{yx} + \\partial_y \\tilde{\\gamma}^{yy} + \\partial_z \\tilde{\\gamma}^{yz}) $$\n    $$ \\tilde{\\Gamma}^z = -(\\partial_x \\tilde{\\gamma}^{zx} + \\partial_y \\tilde{\\gamma}^{zy} + \\partial_z \\tilde{\\gamma}^{zz}) $$\n    Note that because the inverse metric is symmetric ($\\tilde{\\gamma}^{ij} = \\tilde{\\gamma}^{ji}$), the expression is equivalent to the divergence of the rows (or columns) of the inverse conformal metric tensor.\n\nFinally, for each test case, the numerically computed BSSN fields are compared against their provided analytical reference solutions. The error metrics are calculated as specified: the maximum absolute error for the scalar and tensor fields $\\phi$, $K$, and $A_{ij}$, and the maximum of the pointwise Euclidean norm of the error vector for $\\tilde{\\Gamma}^{i}$. These errors are expected to be small, on the order of the truncation error of the second-order finite difference scheme, which is $O(\\Delta x^2)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted from the specified environment.\n\ndef solve():\n    \"\"\"\n    Implements and tests the ADM to BSSN transformation for numerical relativity.\n    \"\"\"\n    N = 32\n    L = 2.0 * np.pi\n    dx = L / N\n    # We use np.mgrid to create coordinate arrays where the first axis corresponds to x,\n    # the second to y, and the third to z. This is unconventional but allows for\n    # straightforward indexing e.g., axis=0 for x-derivatives.\n    coords = np.mgrid[0:N, 0:N, 0:N].astype(float) * dx\n    x, y, z = coords[0], coords[1], coords[2]\n\n    def central_diff(field, axis, step):\n        \"\"\"Computes 2nd-order periodic central difference.\"\"\"\n        return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2.0 * step)\n\n    def adm_to_bssn(gamma, K_ij, dx, dy, dz):\n        \"\"\"\n        Performs the transformation from ADM to BSSN variables on the grid.\n        \n        Args:\n            gamma (np.ndarray): Physical metric, shape (3, 3, N, N, N).\n            K_ij (np.ndarray): Extrinsic curvature, shape (3, 3, N, N, N).\n            dx, dy, dz (float): Grid spacings.\n\n        Returns:\n            A tuple of BSSN variables: (phi, tilde_gamma, A_ij, K_trace, Gamma_i).\n        \"\"\"\n        # Transpose for np.linalg functions which operate on the last two axes\n        gamma_T = gamma.transpose(2, 3, 4, 0, 1)\n        \n        # 1. Conformal factor phi\n        gamma_det = np.linalg.det(gamma_T)\n        phi = (1.0 / 12.0) * np.log(gamma_det)\n\n        # 2. Conformal metric tilde_gamma_ij\n        # Use broadcasting: (N,N,N) * (3,3,N,N,N)\n        tilde_gamma = np.exp(-4.0 * phi) * gamma\n        \n        # 3. Mean curvature K\n        gamma_inv_T = np.linalg.inv(gamma_T)\n        gamma_inv = gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        K_trace = np.einsum('ij...,ij...->...', gamma_inv, K_ij)\n\n        # 4. Conformal trace-free extrinsic curvature A_ij\n        S_ij = K_ij - (1.0 / 3.0) * K_trace * gamma  # Broadcasting K_trace * gamma\n        A_ij = np.exp(-4.0 * phi) * S_ij\n        \n        # 5. Contracted conformal connection functions Gamma^i\n        tilde_gamma_T = tilde_gamma.transpose(2, 3, 4, 0, 1)\n        tilde_gamma_inv_T = np.linalg.inv(tilde_gamma_T)\n        tilde_gamma_inv = tilde_gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        \n        Gamma_i = np.zeros((3, N, N, N))\n        \n        # Sum over j: partial_j tilde_gamma^ij\n        # For i = 0 (x-component):\n        Gamma_i[0] = -(central_diff(tilde_gamma_inv[0, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[0, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[0, 2], 2, dz))\n        # For i = 1 (y-component):\n        Gamma_i[1] = -(central_diff(tilde_gamma_inv[1, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[1, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[1, 2], 2, dz))\n        # For i = 2 (z-component):\n        Gamma_i[2] = -(central_diff(tilde_gamma_inv[2, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[2, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[2, 2], 2, dz))\n        \n        return phi, tilde_gamma, A_ij, K_trace, Gamma_i\n\n    all_errors = []\n\n    # Test Case 1\n    a, k = 0.1, 1.0\n    f_x = a * np.sin(k * x)\n    \n    gamma_1 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_1[0, 0] = conf_factor\n    gamma_1[1, 1] = conf_factor\n    gamma_1[2, 2] = conf_factor\n    \n    K_ij_1 = np.zeros((3, 3, N, N, N))\n    \n    phi_num_1, tilde_gamma_num_1, A_ij_num_1, K_num_1, Gamma_i_num_1 = adm_to_bssn(gamma_1, K_ij_1, dx, dx, dx)\n    \n    phi_ref_1 = f_x\n    K_ref_1 = np.zeros_like(phi_ref_1)\n    A_ij_ref_1 = np.zeros_like(A_ij_num_1)\n    Gamma_i_ref_1 = np.zeros_like(Gamma_i_num_1)\n    \n    err_phi_1 = np.max(np.abs(phi_num_1 - phi_ref_1))\n    err_K_1 = np.max(np.abs(K_num_1 - K_ref_1))\n    err_A_1 = np.max(np.abs(A_ij_num_1 - A_ij_ref_1))\n    err_Gamma_1 = np.max(np.sqrt(np.sum((Gamma_i_num_1 - Gamma_i_ref_1)**2, axis=0)))\n    all_errors.extend([err_phi_1, err_K_1, err_A_1, err_Gamma_1])\n\n    # Test Case 2\n    b, k = 0.2, 2.0\n    h_x = b * np.cos(k * x)\n    \n    gamma_2 = np.zeros((3, 3, N, N, N))\n    gamma_2[0, 0] = np.exp(h_x)\n    gamma_2[1, 1] = np.exp(-h_x)\n    gamma_2[2, 2] = 1.0\n    \n    K_ij_2 = np.zeros((3, 3, N, N, N))\n\n    phi_num_2, _, A_ij_num_2, K_num_2, Gamma_i_num_2 = adm_to_bssn(gamma_2, K_ij_2, dx, dx, dx)\n\n    phi_ref_2 = np.zeros_like(phi_num_2)\n    K_ref_2 = np.zeros_like(K_num_2)\n    A_ij_ref_2 = np.zeros_like(A_ij_num_2)\n    \n    Gamma_i_ref_2 = np.zeros((3, N, N, N))\n    hp_x = -b * k * np.sin(k * x)\n    Gamma_i_ref_2[0] = np.exp(-h_x) * hp_x\n    \n    err_phi_2 = np.max(np.abs(phi_num_2 - phi_ref_2))\n    err_K_2 = np.max(np.abs(K_num_2 - K_ref_2))\n    err_A_2 = np.max(np.abs(A_ij_num_2 - A_ij_ref_2))\n    err_Gamma_2 = np.max(np.sqrt(np.sum((Gamma_i_num_2 - Gamma_i_ref_2)**2, axis=0)))\n    all_errors.extend([err_phi_2, err_K_2, err_A_2, err_Gamma_2])\n\n    # Test Case 3\n    a, k = 0.05, 3.0\n    K0, s = 0.4, 0.3\n    f_x = a * np.cos(k * x)\n    \n    gamma_3 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_3[0, 0] = conf_factor\n    gamma_3[1, 1] = conf_factor\n    gamma_3[2, 2] = conf_factor\n    \n    S_ij_const = np.zeros((3, 3))\n    S_ij_const[0, 0] = s\n    S_ij_const[1, 1] = -s / 2.0\n    S_ij_const[2, 2] = -s / 2.0\n    \n    K_ij_3 = (1.0 / 3.0) * K0 * gamma_3 + conf_factor * S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    \n    phi_num_3, _, A_ij_num_3, K_num_3, Gamma_i_num_3 = adm_to_bssn(gamma_3, K_ij_3, dx, dx, dx)\n\n    phi_ref_3 = f_x\n    K_ref_3 = np.full_like(K_num_3, K0)\n    A_ij_ref_3 = S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    Gamma_i_ref_3 = np.zeros_like(Gamma_i_num_3)\n    \n    err_phi_3 = np.max(np.abs(phi_num_3 - phi_ref_3))\n    err_K_3 = np.max(np.abs(K_num_3 - K_ref_3))\n    err_A_3 = np.max(np.abs(A_ij_num_3 - A_ij_ref_3))\n    err_Gamma_3 = np.max(np.sqrt(np.sum((Gamma_i_num_3 - Gamma_i_ref_3)**2, axis=0)))\n    all_errors.extend([err_phi_3, err_K_3, err_A_3, err_Gamma_3])\n\n    print(f\"[{','.join(map(str, all_errors))}]\")\n\nsolve()\n```", "id": "2420591"}]}