{"hands_on_practices": [{"introduction": "The fundamental property of a linear code is that every codeword $\\mathbf{c}$ must satisfy the equation $H\\mathbf{c}^T = \\mathbf{0}$, where $H$ is the parity-check matrix. This exercise provides a direct, hands-on opportunity to work with this definition by solving the system of parity-check equations for a specific non-zero codeword. This practice solidifies the core concept of what it means for a vector to be part of a code. [@problem_id:1388956]", "problem": "In linear coding theory, a binary linear code can be defined as the set of all vectors $c$ that satisfy the equation $Hc^T = \\mathbf{0}$, where $H$ is a given matrix called the parity-check matrix, and all arithmetic is performed modulo 2 (i.e., over the finite field $\\mathbb{F}_2 = \\{0, 1\\}$). These vectors $c$ are called codewords.\n\nConsider a code defined by the following $2 \\times 4$ parity-check matrix:\n$$H = \\begin{pmatrix} 1 & 1 & 1 & 0 \\\\ 0 & 1 & 1 & 1 \\end{pmatrix}$$\nYour task is to find a specific non-zero codeword $c = (c_1, c_2, c_3, c_4)$ for this code. The codeword must satisfy the additional condition that its first component is $1$ (i.e., $c_1=1$). If multiple such codewords exist, choose the one that is lexicographically smallest. (A vector $u$ is lexicographically smaller than a vector $v$ if at the first position where they differ, the entry in $u$ is smaller than the entry in $v$).\n\nExpress your answer for the codeword $c$ as a row vector.", "solution": "We work over the field $\\mathbb{F}_{2}$. A codeword $c = (c_{1},c_{2},c_{3},c_{4})$ satisfies $Hc^{T}=\\mathbf{0}$, where\n$$\nH=\\begin{pmatrix}1&1&1&0\\\\0&1&1&1\\end{pmatrix}.\n$$\nThis gives the system\n$$\nc_{1}+c_{2}+c_{3}=0,\\qquad c_{2}+c_{3}+c_{4}=0,\n$$\nwith all sums modulo $2$. The additional constraint is $c_{1}=1$.\n\nFrom the first equation with $c_{1}=1$,\n$$\n1+c_{2}+c_{3}=0 \\;\\;\\Rightarrow\\;\\; c_{2}+c_{3}=1 \\;\\;\\Rightarrow\\;\\; c_{3}=1+c_{2}.\n$$\nSubstitute into the second equation:\n$$\nc_{2}+(1+c_{2})+c_{4}=0 \\;\\;\\Rightarrow\\;\\; (c_{2}+c_{2})+1+c_{4}=0 \\;\\;\\Rightarrow\\;\\; 0+1+c_{4}=0 \\;\\;\\Rightarrow\\;\\; c_{4}=1.\n$$\nThus all solutions with $c_{1}=1$ have the form\n$$\n(c_{1},c_{2},c_{3},c_{4})=(1,\\,c_{2},\\,1+c_{2},\\,1),\n$$\nwhere $c_{2}\\in\\{0,1\\}$. To obtain the lexicographically smallest vector among those with $c_{1}=1$, choose the smallest possible $c_{2}$, namely $c_{2}=0$. This yields\n$$\nc=(1,0,1,1).\n$$\nIt is non-zero and satisfies both parity-check equations.", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 0 & 1 & 1 \\end{pmatrix}}$$", "id": "1388956"}, {"introduction": "While finding individual codewords is a good start, the real power of a linear code lies in its structure as a vector space. This practice takes you a step further by asking you to find a basis for the entire code. A basis is a minimal set of linearly independent codewords from which all other codewords can be generated, giving you a complete and efficient description of the code space. [@problem_id:1389005]", "problem": "In digital communications, linear binary codes are used to detect and correct errors in transmitted data. A linear binary code $C$ is a subspace of the vector space $\\mathbb{F}_2^n$, where $\\mathbb{F}_2 = \\{0, 1\\}$ is the field with two elements. One way to define such a code is by using a parity-check matrix $H$. A binary vector $\\mathbf{c}$ of length $n$ is a valid codeword in $C$ if it satisfies the equation $H\\mathbf{c}^T = \\mathbf{0}$, where the matrix-vector multiplication is performed with all arithmetic done modulo 2 (i.e., $1+1=0$).\n\nConsider a linear binary code $C$ of length $n=5$ which is defined by the following parity-check matrix $H$:\n$$ H = \\begin{pmatrix} 1 & 1 & 0 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 1 \\end{pmatrix} $$\nA basis for the code $C$ is a set of linearly independent codewords that can be used to generate all other codewords in $C$ through linear combinations (i.e., addition of vectors modulo 2).\n\nWhich of the following sets of vectors forms a basis for the code $C$?\n\nA. $\\{(1,0,0,1,0), (0,1,0,0,1), (0,0,1,1,1)\\}$\n\nB. $\\{(1,0,0,1,0), (0,1,0,0,1), (0,0,1,1,1), (1,1,0,1,1)\\}$\n\nC. $\\{(1,1,0,1,1), (0,1,1,0,1)\\}$\n\nD. $\\{(1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0)\\}$", "solution": "We work over $\\mathbb{F}_{2}$, so all additions are modulo $2$ and $1+1=0$. A codeword $\\mathbf{c}=(c_{1},c_{2},c_{3},c_{4},c_{5})$ is in $C$ if and only if it satisfies\n$$\nH\\mathbf{c}^{T}=\\mathbf{0}.\n$$\nWith\n$$\nH=\\begin{pmatrix}\n1 & 1 & 0 & 1 & 1\\\\\n0 & 1 & 1 & 0 & 1\n\\end{pmatrix},\n$$\nthe two parity constraints are\n$$\nc_{1}+c_{2}+c_{4}+c_{5}=0,\\qquad c_{2}+c_{3}+c_{5}=0.\n$$\n\nFirst, determine the dimension of $C$. The rank of $H$ over $\\mathbb{F}_{2}$ is $2$ because its two rows are nonzero and not equal, hence linearly independent. Therefore, the dimension $k$ of $C$ is\n$$\nk=n-\\operatorname{rank}(H)=5-2=3.\n$$\nAny basis of $C$ must consist of exactly $3$ linearly independent codewords.\n\nCheck option A: $\\{(1,0,0,1,0),\\,(0,1,0,0,1),\\,(0,0,1,1,1)\\}$.\n- For $\\mathbf{v}_{1}=(1,0,0,1,0)$,\n$$\nH\\mathbf{v}_{1}^{T}=\\begin{pmatrix}1+0+1+0\\\\ 0+0+0\\end{pmatrix}=\\begin{pmatrix}0\\\\ 0\\end{pmatrix}.\n$$\n- For $\\mathbf{v}_{2}=(0,1,0,0,1)$,\n$$\nH\\mathbf{v}_{2}^{T}=\\begin{pmatrix}0+1+0+1\\\\ 1+0+1\\end{pmatrix}=\\begin{pmatrix}0\\\\ 0\\end{pmatrix}.\n$$\n- For $\\mathbf{v}_{3}=(0,0,1,1,1)$,\n$$\nH\\mathbf{v}_{3}^{T}=\\begin{pmatrix}0+0+1+1\\\\ 0+1+1\\end{pmatrix}=\\begin{pmatrix}0\\\\ 0\\end{pmatrix}.\n$$\nThus all three vectors are in $C$. To show linear independence, suppose $a_{1}\\mathbf{v}_{1}+a_{2}\\mathbf{v}_{2}+a_{3}\\mathbf{v}_{3}=\\mathbf{0}$ with $a_{i}\\in\\mathbb{F}_{2}$. Looking at coordinates $1$, $2$, and $3$ gives $a_{1}=0$, $a_{2}=0$, and $a_{3}=0$, respectively, so only the trivial combination yields zero. Hence they are linearly independent. Since $k=3$, these three independent codewords form a basis. Therefore, A is a valid basis.\n\nCheck option B: it contains the three vectors from A plus $(1,1,0,1,1)$. First, $(1,1,0,1,1)\\in C$ because\n$$\nH\\begin{pmatrix}1\\\\ 1\\\\ 0\\\\ 1\\\\ 1\\end{pmatrix}=\\begin{pmatrix}1+1+1+1\\\\ 1+0+1\\end{pmatrix}=\\begin{pmatrix}0\\\\ 0\\end{pmatrix}.\n$$\nHowever, this set is linearly dependent because\n$$\n(1,0,0,1,0)+(0,1,0,0,1)=(1,1,0,1,1).\n$$\nA basis cannot be linearly dependent, so B is not a basis.\n\nCheck option C: $\\{(1,1,0,1,1),(0,1,1,0,1)\\}$. We already verified $(1,1,0,1,1)\\in C$. For $(0,1,1,0,1)$,\n$$\nH\\begin{pmatrix}0\\\\ 1\\\\ 1\\\\ 0\\\\ 1\\end{pmatrix}=\\begin{pmatrix}0+1+0+1\\\\ 1+1+1\\end{pmatrix}=\\begin{pmatrix}0\\\\ 1\\end{pmatrix}\\neq\\begin{pmatrix}0\\\\ 0\\end{pmatrix},\n$$\nso it is not a codeword. Therefore C is not a valid basis set.\n\nCheck option D: $(1,0,0,0,0)$ fails the first parity check since\n$$\nH\\begin{pmatrix}1\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\end{pmatrix}=\\begin{pmatrix}1\\\\ 0\\end{pmatrix}\\neq\\begin{pmatrix}0\\\\ 0\\end{pmatrix}.\n$$\nThus D does not consist of codewords and cannot be a basis.\n\nConclusion: Only option A is a basis for $C$.", "answer": "$$\\boxed{A}$$", "id": "1389005"}, {"introduction": "Now let's apply our knowledge to the primary purpose of these codes: error correction. This problem introduces syndrome decoding in a realistic context where errors are not equally likely. You will calculate the syndrome of a received, corrupted word to narrow down the possible error locations and then use a given probability distribution to perform maximum-likelihood decoding, identifying the single most probable bit-flip. [@problem_id:1388964]", "problem": "In a new type of experimental non-volatile memory, data is stored in blocks of 7 bits. To protect against errors, these blocks are restricted to be codewords of a linear code defined by the following parity-check matrix $H$ over the finite field $\\mathbb{F}_2$:\n$$\nH = \\begin{pmatrix}\n1 & 0 & 1 & 1 & 0 & 1 & 1 \\\\\n0 & 1 & 1 & 0 & 1 & 0 & 1 \\\\\n1 & 1 & 0 & 0 & 1 & 1 & 0\n\\end{pmatrix}\n$$\nDue to the physical layout of the memory cells, the likelihood of a single bit-flip error is not uniform across the 7 positions. After extensive testing, it has been determined that if a single bit-flip occurs, the conditional probability that the flip is at position $i$ (where $i$ is 1-indexed) is given by the vector $P = (p_1, p_2, p_3, p_4, p_5, p_6, p_7)$, where:\n$p_1=0.10$, $p_2=0.05$, $p_3=0.20$, $p_4=0.15$, $p_5=0.25$, $p_6=0.10$, $p_7=0.15$.\n\nA memory block is read, yielding the received word $r = (1, 1, 0, 0, 0, 1, 0)$. It is known that exactly one bit-flip error has corrupted the original codeword. Following the principle of maximum likelihood decoding, determine the most probable 1-indexed position of the flipped bit.", "solution": "Let the transmitted codeword be $c \\in \\mathbb{F}_{2}^{7}$ satisfying $Hc^{T}=0$. With exactly one bit-flip at position $i$, the error vector is $e=e_{i}$ and the received word is $r=c+e$ over $\\mathbb{F}_{2}$. The syndrome is\n$$\ns=Hr^{T}=H(c+e)^{T}=Hc^{T}+He^{T}=0+He^{T}=He^{T},\n$$\nso $s$ must equal the $i$-th column $h_{i}$ of $H$. Therefore, the set of feasible error positions is\n$$\n\\{i : h_{i}=s\\}.\n$$\nCompute the syndrome $s=Hr^{T}$ for $r=(1,1,0,0,0,1,0)$ over $\\mathbb{F}_{2}$:\n- First component: $1\\cdot 1+0\\cdot 1+1\\cdot 0+1\\cdot 0+0\\cdot 0+1\\cdot 1+1\\cdot 0=1+0+0+0+0+1+0=2\\equiv 0$.\n- Second component: $0\\cdot 1+1\\cdot 1+1\\cdot 0+0\\cdot 0+1\\cdot 0+0\\cdot 1+1\\cdot 0=0+1+0+0+0+0+0=1$.\n- Third component: $1\\cdot 1+1\\cdot 1+0\\cdot 0+0\\cdot 0+1\\cdot 0+1\\cdot 1+0\\cdot 0=1+1+0+0+0+1+0=3\\equiv 1$.\nThus\n$$\ns=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix}.\n$$\nList the columns of $H$:\n$$\nh_{1}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\quad\nh_{2}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix},\\quad\nh_{3}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\quad\nh_{4}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\quad\nh_{5}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix},\\quad\nh_{6}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\quad\nh_{7}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix}.\n$$\nThe feasible positions satisfy $h_{i}=s$, hence $i \\in \\{2,5\\}$. Under maximum likelihood with the known single-error model and prior probabilities $p_{i}$ for the error position, the posterior over feasible $i$ is proportional to $p_{i}$:\n$$\n\\Pr(i \\mid r,\\text{ one error}) \\propto p_{i}\\,\\mathbf{1}\\{h_{i}=s\\}.\n$$\nTherefore we choose\n$$\n\\arg\\max_{i \\in \\{2,5\\}} p_{i}=\\arg\\max\\{p_{2},p_{5}\\}=\\arg\\max\\{0.05,0.25\\}=5.\n$$\nHence, the most probable flipped bit position is $5$.", "answer": "$$\\boxed{5}$$", "id": "1388964"}]}