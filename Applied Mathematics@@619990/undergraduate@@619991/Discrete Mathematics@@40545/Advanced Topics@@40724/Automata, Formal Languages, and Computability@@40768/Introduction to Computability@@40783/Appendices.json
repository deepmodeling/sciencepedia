{"hands_on_practices": [{"introduction": "To begin our exploration of computability, we first learn to distinguish between different kinds of questions we can ask about algorithms, modeled here as Turing Machines. This first exercise focuses on a 'syntactic' property—one that relates to the machine's description rather than its computational behavior. Determining if a property like this is decidable is a crucial first step in understanding the boundary between what is and is not computable. [@problem_id:1377291]", "problem": "In the theory of computation, we analyze the properties of algorithms by modeling them as Turing Machines (TMs). A Turing Machine $M$ can be formally described by a tuple representing its set of states, tape alphabet, transition function, start state, accept state, and reject state. Any such formal description can be encoded as a finite-length string, denoted $\\langle M \\rangle$.\n\nConsider the language $L$ defined over the alphabet of these encodings. The language $L$ consists of all string encodings of Turing Machines that possess a specific structural property. Specifically, the language is defined as:\n$$ L = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine that has a finite, even number of states} \\} $$\n\nIs the language $L$ decidable? Select the correct statement and justification from the options below.\n\nA. The language $L$ is decidable because a decider can be constructed to parse the encoding $\\langle M \\rangle$, count the number of states specified in the machine's description, and accept if this count is even. This process is guaranteed to halt for any input.\n\nB. The language $L$ is undecidable because determining properties of a Turing Machine requires solving the Halting Problem, as one would need to see which states are actually used during a computation.\n\nC. The language $L$ is undecidable because of Rice's Theorem, which states that any non-trivial property of the language recognized by a Turing Machine is undecidable.\n\nD. The language $L$ is decidable because a Universal Turing Machine can be used to simulate $M$ on all possible inputs to count the states it enters, and since the number of states is finite, the simulation will eventually determine if the number of visited states is even.", "solution": "We are given the language $L = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine that has a finite, even number of states} \\}$. In the standard formal definition of a Turing Machine, the set of states $Q$ is finite by definition. Therefore, the property that defines $L$ reduces to the syntactic property that the cardinality $|Q|$ is even.\n\nTo decide $L$, construct a decider $D$ operating on an arbitrary input string $w$ as follows:\n1. Verify whether $w$ is a valid encoding $\\langle M \\rangle$ of a Turing Machine under the fixed, effective encoding scheme. This check is a finite syntactic parsing procedure on a finite string and is decidable. If $w$ is not a valid encoding, reject, since $w \\notin L$.\n2. If $w = \\langle M \\rangle$ is valid, parse the description to extract the state set $Q$ of $M$ and compute $n = |Q|$ by counting the listed states in the encoding.\n3. Compute $n \\bmod 2$ and accept if and only if $n \\bmod 2 = 0$.\n\nCorrectness: By construction, the machine accepts exactly those encodings whose Turing Machines have an even number of states. Termination: Each step consists of parsing a finite string and performing finite counting and arithmetic, so the procedure halts on all inputs. Hence $L$ is decidable.\n\nThis matches statement A. Statement B is incorrect because the property concerns the number of states defined in the description, not which states are visited during any computation, so no appeal to the Halting Problem is needed. Statement C misapplies Rice’s Theorem, which concerns semantic properties of the language recognized by a Turing Machine; here the property is purely syntactic about the machine’s encoding. Statement D is incorrect because simulating on all inputs is unnecessary and would not yield a general decider; moreover, it counts visited states rather than the defined total number of states.\n\nTherefore, the correct choice is A.", "answer": "$$\\boxed{A}$$", "id": "1377291"}, {"introduction": "Having seen how a machine's static description can be analyzed, we now turn to its dynamic behavior. This problem introduces a powerful concept: imposing a resource limit, such as a maximum number of computational steps, can transform an otherwise undecidable problem into a decidable one. By exploring this 'bounded' version of a computational question, you'll gain insight into the specific conditions that make the general Halting Problem impossible to solve. [@problem_id:1377286]", "problem": "In the theory of computation, we study the fundamental capabilities and limitations of machines. A Turing Machine (TM) is a mathematical model of a hypothetical computing device that manipulates symbols on a strip of tape according to a table of rules. The description of a Turing Machine, denoted as $\\langle M \\rangle$, is a finite string that encodes its states, alphabet, and transition function.\n\nA language is a set of strings. We say a language $L$ is **decidable** if there exists a special Turing Machine, called a decider, which for any given input string $w$, will always halt and correctly determine whether or not $w$ is in $L$. If a TM halts and enters a designated `accept` state, we say it accepts the input.\n\nConsider the following language, which we will call $L_{CyberGuard}$:\n$$ L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that accepts its own description } \\langle M \\rangle \\text{ as input in at most 4096 steps} \\} $$\n\nWhich of the following statements about the language $L_{CyberGuard}$ is correct?\n\nA. $L_{CyberGuard}$ is decidable.\n\nB. $L_{CyberGuard}$ is not decidable because it is equivalent to the Halting Problem, which is known to be undecidable.\n\nC. $L_{CyberGuard}$ is not decidable, but it is Turing-recognizable (also known as recursively enumerable).\n\nD. The decidability of $L_{CyberGuard}$ cannot be determined without knowing the specific encoding scheme used for $\\langle M \\rangle$.\n\nE. $L_{CyberGuard}$ is an empty language, because no Turing Machine can analyze its own code.", "solution": "We seek to determine the decidability of the language $L_{CyberGuard} = \\{ \\langle M \\rangle \\mid M \\text{ accepts } \\langle M \\rangle \\text{ in at most } 4096 \\text{ steps} \\}$.\n\nKey principle: For any fixed time bound $t \\in \\mathbb{N}$, the property “$M$ accepts $w$ within at most $t$ steps” is decidable. This follows because a universal simulator can emulate $M$ on $w$ for at most $t$ steps, which is a finite, effectively bounded computation. Therefore, the machine that performs this simulation and checks acceptance within the bound is a decider.\n\nConstruction of a decider $D$ for $L_{CyberGuard}$:\n- On input string $x$:\n  1. Check if $x$ is a valid encoding of some TM. If not, reject. This parsing check is decidable for any fixed effective encoding of TMs.\n  2. Let $x = \\langle M \\rangle$. Simulate $M$ on input $\\langle M \\rangle$ for at most $4096$ steps using a standard universal Turing Machine procedure. Maintain a counter $c$ initialized to $0$.\n  3. While $c < 4096$ and $M$ has not halted, perform one simulated transition and set $c := c + 1$.\n  4. If during this simulation $M$ enters the accept state before $c$ reaches $4096$, then accept; otherwise reject.\n\nTermination: The loop performs at most $4096$ iterations, and each simulated step is computable. Thus $D$ halts on all inputs, so $D$ is a decider.\n\nCorrectness: By construction, $D$ accepts exactly those encodings $\\langle M \\rangle$ such that $M$ accepts $\\langle M \\rangle$ within at most $4096$ steps, which is precisely $L_{CyberGuard}$.\n\nConsequences for the options:\n- A is correct: $L_{CyberGuard}$ is decidable by the decider $D$ above.\n- B is false: Unlike the Halting Problem (which is unbounded), here the time is bounded by a fixed constant, making the property decidable.\n- C is false: The language is not merely Turing-recognizable; it is decidable.\n- D is false: Decidability does not depend on the specific standard encoding beyond being an effective encoding; for any fixed effective encoding, the above decider works.\n- E is false: The language is not empty; for example, a TM that immediately accepts any input will accept its own description in fewer than $4096$ steps.\n\nTherefore, the correct statement is A.", "answer": "$$\\boxed{A}$$", "id": "1377286"}, {"introduction": "This final practice tackles a key conceptual hurdle in computability theory: why is halting decidable for a specific, finite set of machines but undecidable in the general case? This thought experiment forces us to pinpoint the precise source of undecidability, which lies not in the complexity of any single machine, but in the infinite number of possible machines we must consider. Understanding this distinction is fundamental to grasping the profound limits of algorithmic problem-solving. [@problem_id:1377287]", "problem": "In the theory of computation, the general Halting Problem for Turing Machines is a canonical example of an undecidable problem. The problem can be stated as: \"Given the description of an arbitrary Turing Machine (TM) $M$ and an arbitrary input string $w$, will $M$ eventually halt when run on input $w$?\" It has been proven that no algorithm exists that can solve the Halting Problem for all possible pairs of $(M, w)$.\n\nNow, consider a different, more restricted problem. Let's define the \"Fixed-State Blank-Tape Halting Problem,\" denoted $H_N$. The problem is as follows: \"Given the description of a TM, $M$, which has a set of states $Q$ with $|Q| \\leq N$ and a fixed tape alphabet $\\Gamma = \\{0, 1, B\\}$ (where $B$ is the blank symbol), will $M$ eventually halt if it is started on a tape that is entirely blank?\"\n\nSurprisingly, for any fixed positive integer $N$, the problem $H_N$ is decidable. For instance, $H_{20}$ (where the number of states is at most 20) is a decidable problem.\n\nWhich of the following statements provides the primary and most accurate reason for why the problem $H_N$ is decidable for a fixed $N$, in stark contrast to the general Halting Problem?\n\nA. A TM with a fixed, finite number of states can only have a finite number of possible configurations (state, head position, tape contents), so a decider can just wait for a configuration to repeat, at which point it knows the TM has entered a loop.\n\nB. The set of all possible Turing Machines with no more than $N$ states and a fixed tape alphabet is finite. Therefore, a decider can be constructed with knowledge of the halting behavior of every single one of these machines.\n\nC. A blank tape constitutes a trivial input. Any TM running on a blank tape will either halt very quickly or enter a simple, easily detectable loop, unlike the complex behavior possible with non-trivial inputs.\n\nD. The undecidability of the Halting Problem arises from TMs that are capable of universal computation. A TM with a small, fixed number of states, such as 20, is not powerful enough to be a universal Turing Machine.\n\nE. The general Halting Problem is undecidable because the input string $w$ can be of arbitrary, unbounded length. The $H_{N}$ problem is decidable because the input is fixed to be a single, specific type (the blank tape).", "solution": "The correct answer is B. Let's analyze why B is the correct reason and why the other options are incorrect.\n\n**Analysis of the Correct Option (B)**\n\nThe key difference between the general Halting Problem and the $H_N$ problem lies in the set of Turing Machines being considered.\n\n1.  **General Halting Problem:** The input to the Halting Problem is a pair $(M, w)$, where $M$ can be *any* Turing Machine. The set of all possible Turing Machines is countably infinite. The proof of the Halting Problem's undecidability (often done by diagonalization) relies on this infinitude. It shows that if a decider $H$ existed, one could construct a new TM $M'$ that $H$ cannot correctly analyze, leading to a contradiction.\n\n2.  **$H_N$ Problem:** The input to this problem is a TM $M$ that is drawn from a specific, restricted set: those TMs with at most $N$ states and a fixed tape alphabet $\\Gamma = \\{0, 1, B\\}$.\n\nLet's count how many such machines there are. A TM is defined by its transition function, $\\delta: Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\{L, R\\}$.\n- The number of states is at most $N$. Let's consider the set of TMs with exactly $k$ states, where $k \\le N$.\n- The size of the tape alphabet is $|\\Gamma| = 3$.\n- For each state $q \\in Q$ (excluding the halt state, let's say) and each tape symbol $\\gamma \\in \\Gamma$, the transition function must specify a next state, a symbol to write, and a head movement.\n- The number of choices for the next state is $k$ (or $k+1$ if we include the halt state).\n- The number of choices for the symbol to write is $|\\Gamma| = 3$.\n- The number of choices for the head movement is 2 (Left or Right).\n\nFor a fixed number of states $k$, the number of possible transition functions is finite. For example, for a TM with $k$ non-halting states, there are $k \\times |\\Gamma|$ possible inputs to the transition function. For each of these, there are $(k+1) \\times |\\Gamma| \\times 2$ possible outputs. The total number of such TMs is $((k+1) \\times 3 \\times 2)^{k \\times 3}$. While this number is astronomically large even for a small $k$, it is crucially **finite**.\n\nSince the total set of TMs for $H_N$ is the union of TMs with $1, 2, ..., N$ states, this total set is also finite.\n\nBecause the set of machines is finite, we can, in principle, create a decider for $H_N$. This decider can be a giant lookup table. For every single one of the finite number of machines in the set, we can determine whether it halts on a blank tape. We can then hard-code this information into our decider. When the decider is given a machine $M$ as input, it simply looks up $M$ in its internal table and outputs \"halts\" or \"does not halt.\" This process is guaranteed to terminate and give the correct answer. The construction of this table might be computationally infeasible (it is related to the uncomputable Busy Beaver function), but its *existence* proves that the problem is decidable.\n\n**Analysis of Incorrect Options**\n\n*   **A: A TM with a fixed, finite number of states can only have a finite number of possible configurations...**\n    This is false. A configuration of a TM is described by $(q, i, T)$, where $q$ is the current state, $i$ is the head position, and $T$ is the entire content of the tape. Since the tape is infinitely long, the number of possible tape contents is infinite. Therefore, the number of possible configurations is also infinite. A TM can run forever without repeating a configuration by continuously moving in one direction and writing new symbols.\n\n*   **C: A blank tape constitutes a trivial input...**\n    This is incorrect. A TM running on a blank tape can still perform highly complex computations. It can use the blank tape as its work space, writing and reading symbols. The famous \"Busy Beaver\" problem is precisely about finding the $n$-state TM that produces the most output on a blank tape before halting, demonstrating that complex behavior is possible.\n\n*   **D: The undecidability of the Halting Problem arises from TMs that are capable of universal computation...**\n    This is a common misconception. While universal Turing Machines (UTMs) are an important concept, the undecidability of the Halting Problem applies to the entire class of TMs, not just UTMs. Furthermore, it is not definitively known whether a 20-state TM can be universal (the smallest known UTM has fewer states), but this is irrelevant. The reason for decidability is the *finiteness of the problem set*, not the computational power of any individual machine within that set.\n\n*   **E: The general Halting Problem is undecidable because the input string $w$ can be of arbitrary, unbounded length...**\n    This misattributes the source of undecidability. The Halting Problem remains undecidable even if we fix the input. For example, the problem \"Given an arbitrary TM $M$, will it halt on the empty string (or a blank tape)?\" is also undecidable. The \"infinity\" that causes the problem is the infinite set of possible machines $M$, not the infinite set of possible inputs $w$. Option E incorrectly swaps these two sources of infinity.", "answer": "$$\\boxed{B}$$", "id": "1377287"}]}