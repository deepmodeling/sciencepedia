{"hands_on_practices": [{"introduction": "To truly grasp the concept of nondeterminism, it's essential to simulate an NFA's behavior firsthand. This exercise guides you through the process of tracking the set of active states as an NFA processes an input string, including the crucial effect of $\\epsilon$-transitions. Mastering this skill is fundamental to understanding how an NFA explores multiple computational paths simultaneously. [@problem_id:1388210]", "problem": "A computer scientist is designing a simple lexical analysis tool based on a Nondeterministic Finite Automaton (NFA) to detect a specific pattern in a binary data stream. The NFA is formally defined with the following components:\n- A set of states $Q = \\{q_0, q_1, q_2, q_3\\}$.\n- An input alphabet $\\Sigma = \\{0, 1\\}$.\n- A start state $q_{start} = q_0$.\n- A set of accept states $F = \\{q_3\\}$.\n\nThe transition function, $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$, where $\\mathcal{P}(Q)$ is the power set of $Q$ and $\\epsilon$ denotes the empty string, is given by the following table of rules. Note that if a state-input pair is not listed, its transition leads to the empty set $\\emptyset$.\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\epsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\nGiven the input string `101`, determine the set of all possible states the machine could be in after processing the entire string. Select the correct set from the options below.\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "For an NFA with $\\epsilon$-transitions, at each step we compute the $\\epsilon$-closure of the current set of states, then move on the input symbol, and finally take the $\\epsilon$-closure again. Let $\\text{E}(S)$ denote the $\\epsilon$-closure of a set $S$. Unspecified transitions go to the empty set.\n\nInitial closure:\n$$\nS_{0}=\\text{E}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\nAfter reading the first symbol $1$:\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\text{E}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\nAfter reading the second symbol $0$:\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\text{E}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\nAfter reading the third symbol $1$:\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\text{E}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\nTherefore, after processing the entire string $101$, the set of possible states is $\\{q_{0},q_{1},q_{2},q_{3}\\}$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1388210"}, {"introduction": "Now that you can trace an NFA's execution, let's move on to designing one. This problem introduces a classic design pattern where an NFA must recognize strings ending with a specific substring. You will see how nondeterminism allows the machine to \"guess\" that the critical pattern is about to begin, elegantly solving a problem that would be more complex for a deterministic automaton. [@problem_id:1388241]", "problem": "In the field of theoretical computer science, a Nondeterministic Finite Automaton (NFA) is a model of computation used to recognize patterns in strings of text. An NFA is formally defined by a 5-tuple $M = (Q, \\Sigma, \\delta, q_0, F)$, where:\n- $Q$ is a finite set of states.\n- $\\Sigma$ is a finite set of input symbols, called the alphabet.\n- $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$ is the transition function, where $\\mathcal{P}(Q)$ is the power set of $Q$.\n- $q_0 \\in Q$ is the start state.\n- $F \\subseteq Q$ is the set of final (or accepting) states.\n\nAn NFA accepts a string if there exists at least one sequence of transitions, starting from $q_0$, that leads to a state in $F$ after processing the entire string.\n\nConsider the language $L$ consisting of all strings over the alphabet $\\Sigma = \\{a, b\\}$ that end with the substring 'ab'. Which of the following formal descriptions correctly represents an NFA that accepts exactly the language $L$? In all options, the set of states is $Q=\\{q_0, q_1, q_2\\}$, the alphabet is $\\Sigma = \\{a, b\\}$, and the start state is $q_0$. Transitions not explicitly defined are assumed to map to the empty set, $\\emptyset$.\n\nA. $F = \\{q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nB. $F = \\{q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nC. $F = \\{q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n   - $\\delta(q_2, a) = \\{q_2\\}$\n   - $\\delta(q_2, b) = \\{q_2\\}$\n\nD. $F = \\{q_0, q_2\\}$, and the transition function $\\delta$ is defined as:\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$", "solution": "The problem asks us to identify the Nondeterministic Finite Automaton (NFA) that accepts the language $L$ of all strings over $\\Sigma = \\{a, b\\}$ ending with the substring 'ab'. Let's analyze the properties of this language and then evaluate each option.\n\nThe language $L$ includes strings like \"ab\", \"aab\", \"bab\", and \"abbab\". It does not include strings like the empty string $\\epsilon$, \"a\", \"b\", \"ba\", or \"aba\". An NFA for this language must be able to process an arbitrary prefix and then recognize the final 'ab' sequence.\n\nLet's analyze each option:\n\n**Analysis of Option A:**\n- $Q = \\{q_0, q_1, q_2\\}$, start state $q_0$, $F = \\{q_2\\}$.\n- Transitions: $\\delta(q_0, a) = \\{q_0, q_1\\}$, $\\delta(q_0, b) = \\{q_0\\}$, $\\delta(q_1, b) = \\{q_2\\}$.\n\nThe logic of this NFA can be interpreted as follows:\n- State $q_0$ is the initial state and also a \"searching\" state. It consumes any sequence of 'a's and 'b's. The loops $\\delta(q_0, a) \\ni q_0$ and $\\delta(q_0, b) = \\{q_0\\}$ allow the machine to remain in this state for any prefix.\n- The transition $\\delta(q_0, a) \\ni q_1$ is nondeterministic. When the NFA reads an 'a' in state $q_0$, it can \"guess\" that this 'a' might be the start of the desired \"ab\" suffix. It spawns a new computation path that moves to state $q_1$.\n- State $q_1$ represents the hypothesis that the last character seen was the 'a' in \"ab\".\n- If the next character is 'b', the transition $\\delta(q_1, b) = \\{q_2\\}$ takes this path to the final state $q_2$. If the string ends here, it is accepted.\n- If any other character is read in state $q_1$ (e.g., an 'a'), or any character is read in state $q_2$, the path dies as there are no defined transitions.\n\nLet's test this NFA with some strings:\n- String \"aab\":\n    1. Start in $q_0$. Read 'a'. $\\delta(q_0, a) = \\{q_0, q_1\\}$. The NFA is now in the set of states $\\{q_0, q_1\\}$.\n    2. Read 'a'. From $q_0$, $\\delta(q_0, a) = \\{q_0, q_1\\}$. From $q_1$, $\\delta(q_1, a) = \\emptyset$. The union of resulting states is $\\{q_0, q_1\\} \\cup \\emptyset = \\{q_0, q_1\\}$. The NFA is in states $\\{q_0, q_1\\}$.\n    3. Read 'b'. From $q_0$, $\\delta(q_0, b) = \\{q_0\\}$. From $q_1$, $\\delta(q_1, b) = \\{q_2\\}$. The union of resulting states is $\\{q_0\\} \\cup \\{q_2\\} = \\{q_0, q_2\\}$.\n    4. The string ends. The final set of states is $\\{q_0, q_2\\}$. Since this set contains a final state ($q_2 \\in F$), the string \"aab\" is accepted. Correct.\n- String \"aba\":\n    1. Start in $q_0$. Read 'a'. States are $\\{q_0, q_1\\}$.\n    2. Read 'b'. From $q_0 \\to \\{q_0\\}$, from $q_1 \\to \\{q_2\\}$. States are $\\{q_0, q_2\\}$.\n    3. Read 'a'. From $q_0 \\to \\{q_0, q_1\\}$, from $q_2 \\to \\emptyset$. States are $\\{q_0, q_1\\}$.\n    4. The string ends. The final set of states is $\\{q_0, q_1\\}$. This set does not contain any state from $F$. The string \"aba\" is rejected. Correct.\nThis construction correctly accepts all strings ending in \"ab\" and rejects all others. Therefore, Option A is the correct answer.\n\n**Analysis of Option B:**\n- $F = \\{q_2\\}$, $\\delta(q_0, a) = \\{q_1\\}$, $\\delta(q_0, b) = \\{q_0\\}$, $\\delta(q_1, b) = \\{q_2\\}$.\nThis NFA is deterministic in its transitions (each maps to a singleton set or empty set). The issue is the transition $\\delta(q_0, a) = \\{q_1\\}$. Once an 'a' is read, the machine must move to $q_1$ and can never return to $q_0$.\n- Let's test \"aab\". Start in $q_0$. Read 'a'. Go to $q_1$. Read 'a'. $\\delta(q_1, a) = \\emptyset$. The computation path halts without reaching a final state. The string \"aab\" is rejected, but it should be accepted. Therefore, Option B is incorrect. This NFA only accepts strings of the form $b^k ab$ for $k \\ge 0$.\n\n**Analysis of Option C:**\n- $F = \\{q_2\\}$. This NFA is similar to A, but with added self-loops on the final state $q_2$: $\\delta(q_2, a) = \\{q_2\\}$ and $\\delta(q_2, b) = \\{q_2\\}$.\nThese loops mean that once the machine reaches the final state $q_2$ (i.e., once it has seen an \"ab\" substring), it will remain in that final state no matter what characters follow.\n- Let's test \"aba\".\n    1. Start in $q_0$. Read 'a'. States are $\\{q_0, q_1\\}$.\n    2. Read 'b'. From $q_0 \\to \\{q_0\\}$, from $q_1 \\to \\{q_2\\}$. States are $\\{q_0, q_2\\}$.\n    3. Read 'a'. From $q_0 \\to \\{q_0, q_1\\}$, from $q_2 \\to \\{q_2\\}$. States are $\\{q_0, q_1, q_2\\}$.\n    4. The string ends. The final set of states contains $q_2 \\in F$. The string \"aba\" is accepted. This is incorrect, as \"aba\" does not end with \"ab\". This NFA accepts any string *containing* \"ab\" as a substring. Therefore, Option C is incorrect.\n\n**Analysis of Option D:**\n- $F = \\{q_0, q_2\\}$. This NFA has the same transitions as the correct NFA in Option A, but the set of final states is different. Here, the start state $q_0$ is also a final state.\nBecause $q_0$ is a final state, the empty string $\\epsilon$ is accepted, which is incorrect. Furthermore, consider the transitions $\\delta(q_0, a) \\ni q_0$ and $\\delta(q_0, b) = \\{q_0\\}$. There is a path for *any* input string that simply remains in state $q_0$. Since $q_0$ is an accepting state, this path will cause the string to be accepted. For example, for the string \"b\", the machine can follow the path $q_0 \\xrightarrow{b} q_0$, ending in a final state. So, \"b\" is accepted. This is incorrect. This NFA accepts all strings in $\\Sigma^*$. Therefore, Option D is incorrect.\n\nBased on the analysis, only Option A correctly describes an NFA for the specified language.", "answer": "$$\\boxed{A}$$", "id": "1388241"}, {"introduction": "This final practice highlights the remarkable efficiency and power of nondeterminism. You are challenged to build an NFA for a language that is notoriously difficult for deterministic machines to recognize with a small number of states. This exercise demonstrates how an NFA's ability to \"guess\" a specific position within a string can lead to a dramatically simpler and more intuitive design. [@problem_id:1388199]", "problem": "In the field of theoretical computer science, a Nondeterministic Finite Automaton (NFA) is a model of computation used to recognize patterns in strings of symbols. Consider the alphabet $\\Sigma = \\{0, 1\\}$. We define a language $L$ as the set of all binary strings over this alphabet in which the third-to-last symbol is a $1$. For example, the string `1010` is in $L$ because its third-to-last symbol is `1`, while the string `011` is not in $L$ because its third-to-last symbol is `0`. The string `10` is not in $L$ as it is too short to have a third-to-last symbol.\n\nWhat is the minimum number of states required for a Nondeterministic Finite Automaton (NFA) to accept the language $L$?", "solution": "Let the language be $L = \\{w \\in \\{0, 1\\}^* \\mid \\text{the third-to-last symbol of } w \\text{ is } 1\\}$. We are looking for the minimum number of states in a Nondeterministic Finite Automaton (NFA) that accepts $L$.\n\nThe key idea behind designing an NFA for this language is to use nondeterminism to \"guess\" which symbol is the third-to-last symbol. The NFA will proceed as follows:\n1.  Read any number of symbols (0s or 1s) until it guesses that it is currently at the third-to-last symbol of the input string.\n2.  If it makes this guess, it must verify that the current symbol is a $1$.\n3.  After verifying the `1`, it must then verify that there are exactly two more symbols remaining in the input string.\n\nWe can construct an NFA with four states to accomplish this. Let's label the states $q_0, q_1, q_2, q_3$.\n\n-   **State $q_0$ (Start State):** This is the initial state. The NFA is in this state as long as it has not yet decided that it has seen the third-to-last symbol.\n    -   On reading a $0$, the NFA stays in state $q_0$.\n    -   On reading a $1$, the NFA has a nondeterministic choice:\n        a) Stay in state $q_0$ (interpreting this `1` as not being the third-to-last symbol).\n        b) Transition to state $q_1$ (guessing that this `1` is the third-to-last symbol).\n\n-   **State $q_1$:** The NFA enters this state after guessing it has just read the third-to-last symbol, which was a `1`. Now it needs to see exactly two more symbols to reach the end of the string.\n\n-   **State $q_2$:** The NFA enters this state after being in state $q_1$ and reading one more symbol (either a $0$ or a $1$). This symbol corresponds to the second-to-last symbol of the string.\n\n-   **State $q_3$ (Accepting State):** The NFA enters this state after being in state $q_2$ and reading one more symbol (either a $0$ or a $1$). This symbol corresponds to the last symbol of the string. Since the NFA has now successfully read the entire string after making its guess, this must be an accepting state. There are no outgoing transitions from $q_3$. If there are more symbols in the input, that computational path dies.\n\nLet's summarize the transitions formally:\n-   $\\delta(q_0, 0) = \\{q_0\\}$\n-   $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n-   $\\delta(q_1, 0) = \\{q_2\\}$\n-   $\\delta(q_1, 1) = \\{q_2\\}$\n-   $\\delta(q_2, 0) = \\{q_3\\}$\n-   $\\delta(q_2, 1) = \\{q_3\\}$\n\nThe set of states is $Q = \\{q_0, q_1, q_2, q_3\\}$.\nThe start state is $q_0$.\nThe set of final states is $F = \\{q_3\\}$.\n\nThis construction uses 4 states.\n\nTo argue that this is the minimum number of states, we can use the Myhill-Nerode theorem's extension for NFAs or a more intuitive argument. An NFA for this language must, in some sense, \"remember\" that it has seen a `1` and then count that two more characters have passed. To distinguish a string ending in $1xx$ (where $x$ is 0 or 1) from other strings, the machine needs a path of at least length 3 to process the sequence `1`, `x`, `x` and then accept. A path of length 3 requires 4 distinct states. For example, consider the path on input `100`: $q_0 \\xrightarrow{1} q_1 \\xrightarrow{0} q_2 \\xrightarrow{0} q_3$. This path consists of 3 transitions and involves 4 states. If we had fewer than 4 states, say 3 states, any path of length 3 must contain a cycle. This would imply that the machine also accepts strings of other lengths (e.g., $1(xx)^k$ for some $k>1$) where the original `1` would no longer be in the third-to-last position, leading to an incorrect language. Therefore, at least 4 states are required.", "answer": "$$\\boxed{4}$$", "id": "1388199"}]}