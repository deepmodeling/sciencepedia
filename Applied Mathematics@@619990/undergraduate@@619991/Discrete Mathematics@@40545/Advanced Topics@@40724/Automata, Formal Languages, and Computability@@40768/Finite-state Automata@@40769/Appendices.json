{"hands_on_practices": [{"introduction": "The first step in mastering finite-state automata is learning to interpret their behavior. This exercise provides a fully defined Deterministic Finite Automaton (DFA) and asks you to deduce the rule, or language, it enforces on binary strings. By tracing the paths for different inputs, you will practice how to associate each state with a specific property of the processed string, a fundamental skill in reverse-engineering the logic of any state machine [@problem_id:1370394].", "problem": "Consider a Deterministic Finite Automaton (DFA), denoted as $M$, which operates on binary strings from the alphabet $\\Sigma = \\{0, 1\\}$. This automaton is designed to recognize a specific class of strings based on the parity of the counts of its symbols.\n\nThe automaton $M$ is formally defined by the following components:\n- The set of states is $Q = \\{S_0, S_1, S_2, S_3\\}$.\n- The start state is $q_0 = S_0$.\n- The set of accepting states is $F = \\{S_1\\}$.\n- The transition function, $\\delta: Q \\times \\Sigma \\to Q$, is defined by the table below:\n  - $\\delta(S_0, 0) = S_2$\n  - $\\delta(S_0, 1) = S_1$\n  - $\\delta(S_1, 0) = S_3$\n  - $\\delta(S_1, 1) = S_0$\n  - $\\delta(S_2, 0) = S_0$\n  - $\\delta(S_2, 1) = S_3$\n  - $\\delta(S_3, 0) = S_1$\n  - $\\delta(S_3, 1) = S_2$\n\nA binary string is accepted by $M$ if and only if processing the string from the start state $S_0$ ends in the accepting state $S_1$. What property must a binary string have to be accepted by this automaton?\n\nA. The string contains an odd number of 0s and an even number of 1s.\n\nB. The string contains an even number of 0s and an odd number of 1s.\n\nC. The string contains an odd number of 0s and an odd number of 1s.\n\nD. The string contains an even number of 0s and an even number of 1s.\n\nE. The total number of symbols in the string is odd.\n\nF. The string is non-empty and contains only 1s.", "solution": "We interpret the DFA states as encoding the parities of the counts of symbols seen so far. For a string $w \\in \\{0,1\\}^{*}$, let $n_{0}(w)$ and $n_{1}(w)$ denote the number of $0$’s and $1$’s in $w$, respectively, and define the parity vector\n$$\np(w) = \\left(n_{0}(w) \\bmod 2,\\; n_{1}(w) \\bmod 2\\right) \\in \\{0,1\\} \\times \\{0,1\\}.\n$$\nClaim: After reading $w$ from $S_{0}$, the automaton is in the unique state $S$ corresponding to $p(w)$ via the mapping\n$$\nS_{0} \\leftrightarrow (0,0),\\quad S_{1} \\leftrightarrow (0,1),\\quad S_{2} \\leftrightarrow (1,0),\\quad S_{3} \\leftrightarrow (1,1).\n$$\nBase case: For the empty string $\\epsilon$, $p(\\epsilon)=(0,0)$ and the DFA is at $S_{0}$ by definition, matching the mapping.\n\nInductive step: Suppose after $w$ the DFA is in the state corresponding to $p(w)=(a,b)$. Reading a symbol $0$ toggles the parity of $0$’s and preserves that of $1$’s, yielding $p(w0)=(a+1 \\bmod 2,b)$. Reading a symbol $1$ toggles the parity of $1$’s and preserves that of $0$’s, yielding $p(w1)=(a,b+1 \\bmod 2)$. The given transitions match exactly these toggles:\n- $\\delta(S_{0},0)=S_{2}$ and $\\delta(S_{2},0)=S_{0}$ toggle between $(0,0)$ and $(1,0)$; $\\delta(S_{1},0)=S_{3}$ and $\\delta(S_{3},0)=S_{1}$ toggle between $(0,1)$ and $(1,1)$.\n- $\\delta(S_{0},1)=S_{1}$ and $\\delta(S_{1},1)=S_{0}$ toggle between $(0,0)$ and $(0,1)$; $\\delta(S_{2},1)=S_{3}$ and $\\delta(S_{3},1)=S_{2}$ toggle between $(1,0)$ and $(1,1)$.\nThus the claim holds by induction for all $w$.\n\nSince the accepting set is $F=\\{S_{1}\\}$ and $S_{1}$ corresponds to parity vector $(0,1)$, a string is accepted if and only if it has an even number of $0$’s and an odd number of $1$’s.\n\nAmong the options, this is exactly option B.", "answer": "$$\\boxed{B}$$", "id": "1370394"}, {"introduction": "Beyond analyzing an automaton, we can systematically transform it to recognize new, related languages. This practice explores one of the most elegant properties of DFAs: language complementation. By taking a simple automaton and inverting its set of accepting states, you will discover how this single change creates a new machine that accepts precisely the strings the original machine rejected, highlighting a deep connection between an automaton's structure and the language it defines [@problem_id:1370388].", "problem": "Consider a Deterministic Finite Automaton (DFA), denoted as $M$, which is formally defined by the 5-tuple $M = (Q, \\Sigma, \\delta, q_0, F)$. The components of this automaton are specified as follows:\n- The set of states is $Q = \\{S_0, S_1\\}$.\n- The alphabet is $\\Sigma = \\{a, b\\}$.\n- The start state is $q_0 = S_0$.\n- The set of final (or accepting) states is $F = \\{S_0\\}$.\n- The transition function, $\\delta: Q \\times \\Sigma \\to Q$, is defined by the following rules:\n    - $\\delta(S_0, a) = S_1$\n    - $\\delta(S_0, b) = S_0$\n    - $\\delta(S_1, a) = S_0$\n    - $\\delta(S_1, b) = S_1$\n\nNow, let us construct a new automaton, $M'$, from $M$. The automaton $M'$ has the same set of states $Q$, the same alphabet $\\Sigma$, the same transition function $\\delta$, and the same start state $q_0$. The only difference is its set of final states, $F'$, which is defined as the complement of $F$ with respect to $Q$. That is, $F' = Q \\setminus F$.\n\nLet $L(M')$ be the language accepted by the new automaton $M'$. For a string $w$, let $|w|_a$ denote the number of occurrences of the symbol 'a' in $w$, and let $|w|_b$ denote the number of occurrences of the symbol 'b' in $w$. Which of the following descriptions accurately characterizes the language $L(M')$?\n\nA. The set of all strings $w \\in \\Sigma^*$ where $|w|_a$ is odd.\n\nB. The set of all strings $w \\in \\Sigma^*$ where $|w|_a$ is even.\n\nC. The set of all strings $w \\in \\Sigma^*$ where $|w|_b$ is odd.\n\nD. The set of all strings $w \\in \\Sigma^*$ where $|w|_b$ is even.\n\nE. The empty language, $\\emptyset$.\n\nF. The set of all strings, $\\Sigma^*$.", "solution": "We analyze the DFA $M=(Q,\\Sigma,\\delta,q_{0},F)$ with $Q=\\{S_{0},S_{1}\\}$, $\\Sigma=\\{a,b\\}$, $q_{0}=S_{0}$, $F=\\{S_{0}\\}$, and transitions $\\delta(S_{0},a)=S_{1}$, $\\delta(S_{0},b)=S_{0}$, $\\delta(S_{1},a)=S_{0}$, $\\delta(S_{1},b)=S_{1}$. Define the extended transition function $\\hat{\\delta}:Q\\times\\Sigma^{*}\\to Q$. We claim that for all $w\\in\\Sigma^{*}$,\n$$\n\\hat{\\delta}(S_{0},w)=\\begin{cases}\nS_{0} & \\text{iff } |w|_{a}\\equiv 0 \\pmod{2},\\\\\nS_{1} & \\text{iff } |w|_{a}\\equiv 1 \\pmod{2}.\n\\end{cases}\n$$\nThis is proved by induction on the length of $w$. For the base case $w=\\epsilon$, we have $\\hat{\\delta}(S_{0},\\epsilon)=S_{0}$ and $|\\epsilon|_{a}=0$, which is even. For the inductive step, assume the statement holds for $x\\in\\Sigma^{*}$. Consider $xa$ and $xb$. For $xa$, by definition of $\\hat{\\delta}$ and $\\delta$,\n$$\n\\hat{\\delta}(S_{0},xa)=\\delta(\\hat{\\delta}(S_{0},x),a),\n$$\nwhich flips $S_{0}\\leftrightarrow S_{1}$ compared to $\\hat{\\delta}(S_{0},x)$, while $|xa|_{a}=|x|_{a}+1$ flips the parity; hence the equivalence is preserved. For $xb$,\n$$\n\\hat{\\delta}(S_{0},xb)=\\delta(\\hat{\\delta}(S_{0},x),b)=\\hat{\\delta}(S_{0},x),\n$$\nand $|xb|_{a}=|x|_{a}$ keeps the parity; hence the equivalence is preserved. Therefore, $M$ accepts exactly those $w$ with $|w|_{a}$ even:\n$$\nL(M)=\\{w\\in\\Sigma^{*}\\mid |w|_{a}\\text{ is even}\\}.\n$$\nThe automaton $M'$ has the same $Q,\\Sigma,\\delta,q_{0}$, but $F'=Q\\setminus F=\\{S_{1}\\}$. Thus $L(M')$ is the complement of $L(M)$ with respect to $\\Sigma^{*}$, namely\n$$\nL(M')=\\{w\\in\\Sigma^{*}\\mid |w|_{a}\\text{ is odd}\\}.\n$$\nAmong the options, this corresponds to A.", "answer": "$$\\boxed{A}$$", "id": "1370388"}, {"introduction": "The ultimate test of understanding is not just to analyze, but to create. This final exercise challenges you to design a DFA from the ground up to satisfy a set of combined constraints, a task common in fields like protocol design and syntax validation. You must carefully determine what information the automaton needs to 'remember' at each step—in this case, both the parity of a character count and the identity of the last character seen—and map this composite memory onto a minimal set of states [@problem_id:1370378].", "problem": "A data stream validator is being designed to process sequences of data packets over the alphabet $\\Sigma = \\{a, b\\}$. For a sequence of packets to be considered valid, it must simultaneously satisfy two rules:\n\n1.  **The Integrity Rule:** No two consecutive packets can be of the same type. For example, `aba` is valid, but `aa` and `abb` are not.\n2.  **The Parity Rule:** The total number of packets of type `a` in the sequence must be even.\n\nThe validator is to be implemented as a Deterministic Finite Automaton (DFA), a theoretical model of computation that reads an input string one character at a time and changes its internal state accordingly. After reading the entire string, the automaton's final state determines whether the string is accepted (valid) or rejected (invalid).\n\nWhat is the minimum number of internal states required for such a DFA that correctly identifies all valid sequences of packets?", "solution": "We must recognize the language over $\\Sigma=\\{a,b\\}$ consisting of all strings that simultaneously satisfy:\n(1) no two consecutive symbols are equal, and\n(2) the number of $a$'s is even.\nCall this language $L$.\n\nUpper bound via explicit DFA construction:\nTo enforce the integrity rule, the automaton must remember the last seen symbol (or that none has been seen yet) and go to a dead state upon a repeated symbol. To enforce the parity rule, it must track the parity of the count of $a$'s. Combining these requirements yields the following six-state deterministic automaton:\n- $q_{0}$: start, no previous symbol, even parity; accepting.\n- $q_{1}$: last symbol $a$, odd parity; rejecting.\n- $q_{2}$: last symbol $b$, even parity; accepting.\n- $q_{3}$: last symbol $b$, odd parity; rejecting.\n- $q_{4}$: last symbol $a$, even parity; accepting.\n- $q_{\\mathrm{dead}}$: dead state; rejecting.\n\nTransitions, determined by toggling parity on $a$, preserving parity on $b$, and sending to $q_{\\mathrm{dead}}$ on any repeated symbol:\n- From $q_{0}$: on $a$ go to $q_{1}$; on $b$ go to $q_{2}$.\n- From $q_{1}$: on $a$ go to $q_{\\mathrm{dead}}$; on $b$ go to $q_{3}$.\n- From $q_{2}$: on $a$ go to $q_{1}$; on $b$ go to $q_{\\mathrm{dead}}$.\n- From $q_{3}$: on $a$ go to $q_{4}$; on $b$ go to $q_{\\mathrm{dead}}$.\n- From $q_{4}$: on $a$ go to $q_{\\mathrm{dead}}$; on $b$ go to $q_{2}$.\n- From $q_{\\mathrm{dead}}$: on $a$ or $b$ stay in $q_{\\mathrm{dead}}$.\n\nCorrectness follows by induction on input length: the state encodes exactly the last symbol (if any), whether a violation has occurred, and the parity of the number of $a$'s; the accepting states are precisely those with no violation and even parity. Hence $6$ states suffice, so the minimal number of states is at most $6$.\n\nLower bound via Myhill–Nerode distinguishability:\nWe exhibit six pairwise distinguishable right-congruence classes by considering the following prefixes and their future behavior:\n- $\\epsilon$ leads to $q_{0}$ (accepting).\n- $a$ leads to $q_{1}$ (rejecting).\n- $b$ leads to $q_{2}$ (accepting).\n- $ab$ leads to $q_{3}$ (rejecting).\n- $aba$ leads to $q_{4}$ (accepting).\n- $bb$ (or $aa$) leads to $q_{\\mathrm{dead}}$ (rejecting, with all future continuations rejected).\n\nDistinguishing suffixes:\n- $q_{\\mathrm{dead}}$ is not equivalent to any other state since the empty suffix is accepted from $q_{0},q_{2},q_{4}$ but rejected from $q_{\\mathrm{dead}}$.\n- $q_{1}$ and $q_{3}$ are distinguishable by suffix $a$: from $q_{1}$, $a$ goes to $q_{\\mathrm{dead}}$ (reject); from $q_{3}$, $a$ goes to $q_{4}$ (accept).\n- Among the accepting states $q_{0},q_{2},q_{4}$:\n  - $q_{2}$ is distinguishable from $q_{0}$ and $q_{4}$ by suffix $b$: from $q_{2}$, $b$ goes to $q_{\\mathrm{dead}}$ (reject), whereas from $q_{0}$ and $q_{4}$, $b$ goes to $q_{2}$ (accept).\n  - $q_{0}$ is distinguishable from $q_{4}$ by suffix $aba$: from $q_{0}$, $aba$ is accepted (ends in $q_{4}$); from $q_{4}$, the first $a$ goes to $q_{\\mathrm{dead}}$ (reject).\n- Accepting versus rejecting states are obviously distinguishable by the empty suffix.\n\nThus these six classes are pairwise distinguishable, so any DFA for $L$ needs at least $6$ states.\n\nCombining the upper and lower bounds, the minimal number of states required is $6$.", "answer": "$$\\boxed{6}$$", "id": "1370378"}]}