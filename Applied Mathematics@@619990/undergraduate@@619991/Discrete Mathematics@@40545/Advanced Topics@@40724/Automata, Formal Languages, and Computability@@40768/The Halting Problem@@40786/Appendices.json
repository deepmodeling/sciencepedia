{"hands_on_practices": [{"introduction": "The classic Halting Problem is undecidable because a Turing Machine has infinite memory, allowing for a boundless number of configurations. This exercise challenges that premise by asking you to consider a \"Finite-Tape Turing Machine\" with a fixed number of states, tape length, and symbols [@problem_id:1408272]. By quantifying the total number of distinct configurations this machine can possibly enter, you will gain a concrete understanding of why finite resources make the halting question decidable.", "problem": "Consider a theoretical computing model called a Finite-Tape Turing Machine (FTTM). An FTTM is defined by a finite set of internal states, $Q$, with a size of $|Q| = s$; a finite tape alphabet, $\\Gamma$, with a size of $|\\Gamma| = k$ symbols; and a tape that is strictly finite, consisting of a fixed number of cells, $n$. The machine has a single tape head that can read or write one symbol at a time and move left or right, but it cannot move off the tape. The machine's behavior is governed by a deterministic transition function.\n\nA complete \"configuration\" of the FTTM at any moment is defined by its current internal state, the position of its tape head, and the entire sequence of symbols written on its tape. Since the number of possible configurations is finite, any FTTM that does not halt must eventually repeat a configuration, entering an infinite loop. This implies that the halting problem for any FTTM is decidable.\n\nGiven an FTTM with $s$ states, a tape of length $n$, and an alphabet of $k$ symbols, what is the maximum number of distinct configurations possible? This value also represents the maximum number of computational steps after which we can definitively decide whether the machine halts or loops, by simply simulating it and checking if it has halted yet.\n\nSelect the correct expression for this maximum number of steps.\n\nA. $s \\cdot n \\cdot k^{n}$\n\nB. $s + n + k$\n\nC. $k^{s \\cdot n}$\n\nD. $s \\cdot k \\cdot n$\n\nE. $n \\cdot s^{k}$\n\nF. $(s \\cdot k)^{n}$", "solution": "A complete configuration is specified by:\n- the internal state $q \\in Q$ with $|Q|=s$,\n- the head position $i$ on a tape of length $n$ (so $n$ possible positions),\n- the full tape contents, which is a word of length $n$ over the alphabet $\\Gamma$ with $|\\Gamma|=k$, hence $k^{n}$ possibilities.\n\nBy the product rule of counting, the total number of distinct configurations is\n$$\nN=\\underbrace{s}_{\\text{state}}\\cdot\\underbrace{n}_{\\text{head position}}\\cdot\\underbrace{k^{n}}_{\\text{tape contents}}=s\\cdot n\\cdot k^{n}.\n$$\n\nBecause the transition function is deterministic and there are only $N$ configurations, by the pigeonhole principle, after $N$ steps a configuration must repeat unless the machine has halted earlier. Therefore, simulating for at most $N$ steps suffices to decide halting versus looping. Among the given options, this matches option A: $s \\cdot n \\cdot k^{n}$.", "answer": "$$\\boxed{A}$$", "id": "1408272"}, {"introduction": "While the halting problem for Turing Machines is famously undecidable, the equivalent problem for simpler models like Deterministic Finite Automata (DFAs) is straightforward to solve. This practice challenges you to pinpoint the fundamental architectural distinction that accounts for this profound difference in computability [@problem_id:1457086]. Analyzing this contrast will clarify precisely which feature grants Turing Machines their universal power and, simultaneously, introduces the paradox of undecidability.", "problem": "The halting problem for Turing Machines (TMs) is a classic example of an undecidable problem in computer science. The language corresponding to this problem is defined as $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a Turing Machine and } M \\text{ halts on input string } w \\}$. No algorithm exists that can decide for all possible pairs $\\langle M, w \\rangle$ whether or not $M$ will halt on $w$.\n\nIn contrast, consider an analogous problem for a simpler computational model, the Deterministic Finite Automaton (DFA). The language for the acceptance problem for DFAs is $A_{DFA} = \\{ \\langle D, w \\rangle \\mid D \\text{ is a DFA and } D \\text{ accepts input string } w \\}$. This problem is decidable. An algorithm can be constructed that always correctly determines whether a given DFA $D$ accepts a string $w$.\n\nWhat is the single most fundamental difference between the computational models of a TM and a DFA that accounts for this profound disparity, i.e., why is $A_{TM}$ undecidable while $A_{DFA}$ is decidable?\n\nA. A TM can write symbols to its tape, whereas a DFA can only read from its input.\n\nB. The transition function of a TM is allowed to be a partial function (undefined for some state-symbol pairs), while the transition function of a standard DFA must be a total function.\n\nC. The control logic of a TM can have an infinite number of states, while a DFA is, by definition, restricted to a finite number of states.\n\nD. A TM possesses a potentially infinite memory in the form of an unbounded tape, allowing for an infinite number of distinct machine configurations, whereas a DFA's memory is restricted to its finite set of states, forcing its computation to terminate.\n\nE. Nondeterministic TMs are equivalent in power to deterministic TMs, while Nondeterministic Finite Automata (NFAs) are more expressive than DFAs.", "solution": "We analyze why $A_{TM}$ is undecidable while $A_{DFA}$ is decidable by comparing the computational power of Turing Machines (TMs) and Deterministic Finite Automata (DFAs) in terms of their configuration spaces and memory.\n\nA TM on input $w$ has configurations determined by a finite control state $q \\in Q$, an unbounded tape whose contents can be modeled as a word over the tape alphabet $t \\in \\Gamma^{*}$ of unbounded length, and a head position $h \\in \\mathbb{N}$. Hence the set of possible configurations for a TM includes triples of the form $(q, t, h)$ with $t$ ranging over arbitrarily long strings and $h$ over unbounded positions, which yields an infinite configuration space. This unbounded memory (unbounded tape) permits simulating arbitrary computations and enables self-referential diagonal arguments, implying that there cannot exist a decider for $A_{TM}$. The undecidability of the halting problem fundamentally relies on the ability to have infinitely many distinct machine configurations arising from unbounded working memory.\n\nIn contrast, a DFA has no work tape and only a finite set of states $Q$. On input $w = a_{1}a_{2}\\dots a_{n}$, its computation proceeds deterministically by applying the total transition function $\\delta: Q \\times \\Sigma \\to Q$ exactly $|w|$ steps, moving strictly right over the input and halting after consuming the entire string. The relevant computational information at any point is just the current state $q \\in Q$ (the input head position is implicitly determined by the number of steps taken). Therefore, deciding $A_{DFA}$ is straightforward: simulate $\\delta$ for $|w|$ steps and check whether the resulting state is in the accept set $F \\subseteq Q$. This is always possible because the number of steps is bounded by $|w|$ and the machine has only finitely many states; thus the acceptance problem is decidable.\n\nNow we evaluate the options:\n\nA. While TMs can write and DFAs cannot, the decisive reason for undecidability is not merely the act of writing but the presence of unbounded working memory, which creates an infinite configuration space. The write capability is a means to exploit unbounded memory, but it is not the single fundamental distinction.\n\nB. Whether the transition function is partial or total is not the source of undecidability; TMs can be made total by adding a rejecting sink without affecting the undecidability of $A_{TM}$.\n\nC. This is false: a standard TM has a finite control with a finite number of states. Its power comes from unbounded tape, not infinite control.\n\nD. This captures the essential difference: a TM’s unbounded tape yields potentially infinite distinct configurations, enabling non-termination and the undecidability of halting, whereas a DFA’s computation is constrained by a finite set of states and a bounded number of steps on input $w$, making $A_{DFA}$ decidable.\n\nE. This is incorrect: NFAs and DFAs are equivalent in expressive power; nondeterminism does not create a fundamental gap here, and TMs remain equivalent under determinism and nondeterminism.\n\nTherefore, the single most fundamental difference accounting for the disparity is the unbounded memory of TMs versus the finite state memory of DFAs, as stated in option D.", "answer": "$$\\boxed{D}$$", "id": "1457086"}, {"introduction": "A common point of confusion is why the Halting Problem is undecidable for any arbitrary Turing Machine, yet decidable for certain restricted classes of machines. This problem explores a fascinating case: Turing Machines that have a small, bounded number of states [@problem_id:1457046]. By working through this scenario, you will understand the critical difference between a problem defined over an infinite set of machines versus a finite one, revealing why such a restriction makes the problem decidable without contradicting the general theorem.", "problem": "In the theory of computation, a Turing Machine (TM) is a mathematical model of computation described by a set of states, a tape alphabet, and a transition function. The encoding of a Turing machine, denoted as $\\langle M \\rangle$, is a finite string that represents the machine $M$. The empty string is denoted by $\\epsilon$.\n\nA central problem in this field is the halting problem on the empty input, which corresponds to the language $HALT_{\\epsilon}$. This language is defined as:\n$$HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on input } \\epsilon \\}$$\nIt is a well-established theorem that $HALT_{\\epsilon}$ is an undecidable language. This means no algorithm exists that can correctly determine for any arbitrary TM whether it halts on the empty input.\n\nNow, consider a different language, which we will call $L_{20}$. This language is defined for Turing machines that use a fixed tape alphabet $\\Gamma = \\{0, 1, \\text{blank}\\}$ and is given by:\n$$L_{20} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM with at most 20 states that halts on input } \\epsilon \\}$$\nIt is a fact that, unlike $HALT_{\\epsilon}$, the language $L_{20}$ is decidable. This may seem paradoxical, as $L_{20}$ appears to be a specific case of the halting problem.\n\nWhich of the following statements provides the most accurate and fundamental explanation for why $L_{20}$ is decidable, and why this fact does not contradict the undecidability of $HALT_{\\epsilon}$?\n\nA. A universal Turing machine can simulate any TM with at most 20 states until it halts. This simulation is only guaranteed to terminate for machines with a small, finite number of states.\n\nB. The undecidability of $HALT_{\\epsilon}$ is proven by a reduction from the general halting problem $A_{TM}$. This reduction technique is invalid if the target machines are restricted to have at most 20 states.\n\nC. Any TM with 20 or fewer states that does not halt on input $\\epsilon$ must enter a simple, repeating loop of configurations on the tape. A decider can detect this loop, a feat which is impossible for TMs with more states.\n\nD. The property \"halts on input $\\epsilon$\" is a non-trivial property of TMs. According to Rice's Theorem, this implies undecidability. However, Rice's Theorem has an exception for machines with a small number of states.\n\nE. The set of all distinct Turing machines with a fixed alphabet and a bounded number of states is finite. A decider can therefore be constructed with a hardcoded list of all such machines that are known to halt on $\\epsilon$. This approach is impossible for $HALT_{\\epsilon}$ because the set of all possible TMs is infinite.", "solution": "We are given $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M\\text{ halts on }\\epsilon\\}$, which is undecidable, and $L_{20}=\\{\\langle M\\rangle\\mid M\\text{ uses }\\Gamma=\\{0,1,\\text{blank}\\}\\text{, has at most }20\\text{ states, and halts on }\\epsilon\\}$, which is decidable. We must explain why $L_{20}$ is decidable without contradicting the undecidability of $HALT_{\\epsilon}$.\n\nStep 1 (Finiteness of the set of machines with bounded states and fixed alphabet): Fix the tape alphabet $\\Gamma=\\{0,1,\\text{blank}\\}$ and a state set $Q$ with $1\\leq |Q|\\leq 20$. For a deterministic single-tape Turing machine, the transition function is a partial function $\\delta:Q\\times\\Gamma\\to\\Gamma\\times\\{L,R\\}\\times(Q\\cup\\{\\text{halt-accept},\\text{halt-reject}\\})$. For each pair $(q,a)\\in Q\\times\\Gamma$, the number of choices for $\\delta(q,a)$ is finite because:\n- the write symbol comes from the finite set $\\Gamma$,\n- the head move comes from the finite set $\\{L,R\\}$,\n- the next control is chosen from the finite set $Q\\cup\\{\\text{halt-accept},\\text{halt-reject}\\}$.\nHence, for fixed $Q$ and $\\Gamma$, the set of possible transition tables is a finite product of finite sets, therefore finite. Taking the union over all $|Q|\\leq 20$ still yields a finite set. Consequently, the set of all TMs with $\\Gamma=\\{0,1,\\text{blank}\\}$ and at most $20$ states is finite. If the encoding $\\langle\\cdot\\rangle$ is fixed and injective, the set of valid encodings of such machines is also finite.\n\nStep 2 (Decidability from finiteness): Let $S$ be the finite set of encodings of all TMs with $\\Gamma=\\{0,1,\\text{blank}\\}$ and at most $20$ states. Then $L_{20}\\subseteq S$ and $L_{20}$ itself is finite. Any finite language is decidable: a decider can be built that, on input $x$, first checks whether $x\\in S$ (reject if not), and if $x\\in S$, accepts if and only if $x$ is in the finite hardcoded subset $H\\subseteq S$ consisting of exactly those encodings that are known to halt on input $\\epsilon$. Equivalently, one can implement a finite lookup table for $H$.\n\nStep 3 (No contradiction with the undecidability of $HALT_{\\epsilon}$): The undecidability of $HALT_{\\epsilon}$ concerns an infinite domain of machines with unbounded numbers of states and transition possibilities. Restricting attention to a finite subset of machines (those with at most $20$ states over a fixed alphabet) yields a finite language, which is trivially decidable. Undecidability results such as those proved via reductions or Rice’s Theorem do not apply to a finite restriction of the input domain; there is no paradox.\n\nAssessment of the options:\n- A is false: simulation does not guarantee termination for non-halting machines, regardless of having at most $20$ states.\n- B is misleading: while standard reductions target unrestricted machines, this does not explain decidability; the core reason is finiteness.\n- C is false: a non-halting TM need not enter a simple repeating loop of configurations; it can write fresh tape symbols indefinitely without repeating a configuration.\n- D is false: Rice’s Theorem has no “small number of states” exception; rather, it does not apply to a finite restriction of the machine set.\n- E is correct: the set of such machines is finite, so one can decide by finite lookup, and this does not contradict the undecidability of $HALT_{\\epsilon}$ because the latter ranges over an infinite set.", "answer": "$$\\boxed{E}$$", "id": "1457046"}]}