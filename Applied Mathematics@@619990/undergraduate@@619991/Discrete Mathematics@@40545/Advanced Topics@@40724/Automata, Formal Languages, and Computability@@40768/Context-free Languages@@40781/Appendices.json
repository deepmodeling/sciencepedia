{"hands_on_practices": [{"introduction": "Mastering the theory of computation often begins with getting your hands dirty. Before we can design complex automata, we must first build a solid intuition for how they operate. This first exercise provides a direct opportunity to do just that by simulating a Pushdown Automaton (PDA) step-by-step. By tracing the PDA's configuration—its state, remaining input, and stack content—on a specific string, you will gain a concrete understanding of how these components interact to recognize a context-free language [@problem_id:1359998].", "problem": "Consider a Pushdown Automaton (PDA), $M$, intended to recognize a specific language over the alphabet $\\Sigma=\\{a,b\\}$. The PDA is formally defined by the 7-tuple $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$, where:\n- The set of states is $Q = \\{q_0\\}$.\n- The input alphabet is $\\Sigma = \\{a, b\\}$.\n- The stack alphabet is $\\Gamma = \\{A, Z_0\\}$.\n- The start state is $q_0$.\n- The initial stack symbol is $Z_0$.\n- The set of final (accepting) states is $F = \\{q_0\\}$.\n- The transition function, $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\times \\Gamma \\to \\mathcal{P}(Q \\times \\Gamma^*)$, is given by the following rules:\n    1. $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n    2. $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n    3. $\\delta(q_0, b, A) = \\{(q_0, \\epsilon)\\}$ (where $\\epsilon$ denotes an empty string, signifying a pop operation)\n\nThe PDA starts in state $q_0$ with the symbol $Z_0$ on the stack. An input string is processed from left to right. A string is accepted if the PDA is in a final state after processing the entire string. If at any point no valid transition is defined for the current state, input symbol, and stack top, the PDA halts and the string is rejected.\n\nGiven the input string $w = \\text{aaababb}$, determine the final content of the stack after the PDA has processed the entire string. The stack content should be represented as a string of symbols, with the top of the stack being the leftmost symbol.\n\nWhich of the following represents the final content of the stack?\n\nA. $AZ_0$\n\nB. $Z_0$\n\nC. $AAZ_0$\n\nD. $AAAZ_0$\n\nE. The PDA halts and rejects the string before processing it completely.", "solution": "We simulate the PDA $M$ on the input $w=\\text{aaababb}$, starting in state $q_{0}$ with initial stack $Z_{0}$. The transitions available are:\n- On $a$ with top $Z_{0}$: $\\delta(q_{0}, a, Z_{0}) = \\{(q_{0}, AZ_{0})\\}$, which pushes $A$.\n- On $a$ with top $A$: $\\delta(q_{0}, a, A) = \\{(q_{0}, AA)\\}$, which pushes another $A$.\n- On $b$ with top $A$: $\\delta(q_{0}, b, A) = \\{(q_{0}, \\epsilon)\\}$, which pops $A$.\n\nProcess each symbol of $w$ and track the stack (top is leftmost):\n- Initially: stack $Z_{0}$.\n- Read first $a$: apply $\\delta(q_{0}, a, Z_{0})$, stack becomes $AZ_{0}$.\n- Read second $a$: apply $\\delta(q_{0}, a, A)$, stack becomes $AAZ_{0}$.\n- Read third $a$: apply $\\delta(q_{0}, a, A)$, stack becomes $AAAZ_{0}$.\n- Read first $b$: apply $\\delta(q_{0}, b, A)$, stack becomes $AAZ_{0}$.\n- Read next $a$: apply $\\delta(q_{0}, a, A)$, stack becomes $AAAZ_{0}$.\n- Read next $b$: apply $\\delta(q_{0}, b, A)$, stack becomes $AAZ_{0}$.\n- Read final $b$: apply $\\delta(q_{0}, b, A)$, stack becomes $AZ_{0}$.\n\nAt no point does the PDA lack a valid transition; thus it does not halt prematurely. After processing all input symbols, the final stack content is $AZ_{0}$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1359998"}, {"introduction": "Having traced the execution of a PDA, the next logical step is to design one yourself. This practice challenges you to construct a PDA to recognize the language $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$. This task moves beyond simple one-to-one counting and requires you to use the stack to enforce a specific ratio between two parts of a string, a hallmark capability of pushdown automata that sets them apart from simpler finite automata [@problem_id:1359997].", "problem": "You are an engineer designing a validation component for a new data streaming protocol. The protocol transmits data as a sequence of two types of signals, 'a' and 'b'. A stream is considered valid if and only if it consists of a block of one or more 'a' signals followed by a block of 'b' signals, where the number of 'b' signals is exactly double the number of 'a' signals. This corresponds to the language $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$.\n\nYour task is to specify the logic for a Pushdown Automaton (PDA), a type of computational model with a stack, to recognize this language. A PDA is formally defined by a 7-tuple $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$.\n\nThe proposed PDA has the following components:\n- A set of states $Q = \\{q_0, q_1, q_2\\}$, where $q_0$ is the start state, $q_1$ is an intermediate state, and $q_2$ is the sole accept state.\n- An input alphabet $\\Sigma = \\{a, b\\}$.\n- A stack alphabet $\\Gamma = \\{S, Z_0\\}$, where $Z_0$ is the initial symbol on the stack.\n- The start state is $q_0$.\n- The set of final states is $F = \\{q_2\\}$.\n\nThe core logic of the PDA is defined by its transition function, $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\times \\Gamma \\to \\mathcal{P}(Q \\times \\Gamma^*)$, where $\\epsilon$ denotes the empty string and $\\mathcal{P}$ denotes the power set. A transition $\\delta(q, x, Y) = \\{(p, \\gamma)\\}$ means that if the PDA is in state $q$, reads input symbol $x$, and has symbol $Y$ on top of the stack, it can move to state $p$ and replace $Y$ with the string of symbols $\\gamma$.\n\nWhich of the following definitions of the transition function $\\delta$ will make the PDA correctly recognize the language $L = \\{a^n b^{2n} \\mid n \\ge 1\\}$?\n\nA.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SS)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nB.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SSZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SSS)\\}$\n$\\delta(q_0, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n\nC.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SSZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SSS)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nD.\n$\\delta(q_0, a, Z_0) = \\{(q_0, SSZ_0)\\}$\n$\\delta(q_0, a, S) = \\{(q_0, SSS)\\}$\n$\\delta(q_0, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, b, S) = \\{(q_1, \\epsilon)\\}$\n$\\delta(q_1, \\epsilon, S) = \\{(q_2, S)\\}$", "solution": "We must design and verify a pushdown automaton that accepts exactly the strings in $L=\\{a^{n}b^{2n}\\mid n\\ge 1\\}$ by final state, using a stack alphabet $\\{S,Z_{0}\\}$ with $Z_{0}$ initially on the stack.\n\nKey counting invariant required for $L$: after reading $n$ leading $a$’s, the stack must contain exactly $2n$ copies of $S$ above $Z_{0}$, i.e., $S^{2n}Z_{0}$; during the subsequent $b$-block, each $b$ must pop exactly one $S$; the PDA should accept exactly when the input is fully consumed and the stack has returned to $Z_{0}$ (with a suitable $\\epsilon$-move to a final state). The transition from reading $a$’s to reading $b$’s must be one-way (no $a$ after any $b$), typically enforced by moving from $q_{0}$ to $q_{1}$ on the first $b$.\n\nAnalyze each option by tracking the number of $S$’s pushed for $a$’s and popped for $b$’s, and by checking acceptance conditions.\n\nOption A:\n- $\\delta(q_{0},a,Z_{0})=(q_{0},SZ_{0})$ pushes one $S$ on the first $a$.\n- $\\delta(q_{0},a,S)=(q_{0},SS)$ replaces $S$ by $SS$, net $+1$ $S$ per additional $a$.\nHence after $n$ $a$’s, the stack is $S^{n}Z_{0}$ (only $n$ copies of $S$). On $b$’s:\n- $\\delta(q_{0},b,S)=(q_{1},\\epsilon)$ pops one $S$ and switches to $q_{1}$ on the first $b$.\n- $\\delta(q_{1},b,S)=(q_{1},\\epsilon)$ continues popping one $S$ per $b$.\nFinally, $\\delta(q_{1},\\epsilon,Z_{0})=(q_{2},Z_{0})$ allows acceptance when input is consumed and stack top is $Z_{0}$. Therefore this automaton accepts exactly strings $a^{n}b^{n}$, not $a^{n}b^{2n}$. Option A is incorrect.\n\nOption B:\n- $\\delta(q_{0},a,Z_{0})=(q_{0},SSZ_{0})$ pushes two $S$ on the first $a$.\n- $\\delta(q_{0},a,S)=(q_{0},SSS)$ replaces $S$ by $SSS$, net $+2$ $S$ per additional $a$.\nThus after $n$ $a$’s, the stack is $S^{2n}Z_{0}$, as desired. On $b$’s:\n- $\\delta(q_{0},b,S)=(q_{1},\\epsilon)$ then $\\delta(q_{1},b,S)=(q_{1},\\epsilon)$ pop one $S$ per $b$.\nHowever, acceptance is by final state $q_{2}$, and the only $\\epsilon$-move to $q_{2}$ given is $\\delta(q_{0},\\epsilon,Z_{0})=(q_{2},Z_{0})$, which:\n1) Incorrectly accepts the empty string (input empty, at start top is $Z_{0}$), violating $n\\ge 1$.\n2) Provides no accepting transition from $q_{1}$ when the stack returns to $Z_{0}$ after consuming $2n$ $b$’s. Therefore valid strings would be rejected. Option B is incorrect.\n\nOption C:\n- $\\delta(q_{0},a,Z_{0})=(q_{0},SSZ_{0})$ and $\\delta(q_{0},a,S)=(q_{0},SSS)$ ensure that after $n$ $a$’s the stack is $S^{2n}Z_{0}$.\n- $\\delta(q_{0},b,S)=(q_{1},\\epsilon)$ moves to $q_{1}$ on the first $b$ and pops one $S$; $\\delta(q_{1},b,S)=(q_{1},\\epsilon)$ continues popping one $S$ per $b$.\n- When all $2n$ $S$’s have been popped, the stack top is $Z_{0}$. The transition $\\delta(q_{1},\\epsilon,Z_{0})=(q_{2},Z_{0})$ allows moving to the accept state exactly when the input has been fully consumed and the stack has returned to $Z_{0}$.\nThis construction guarantees:\n1) Exactly two $S$’s are pushed per $a$, so $2n$ $S$’s after $n$ $a$’s.\n2) Exactly one $S$ is popped per $b$, so acceptance is possible only after precisely $2n$ $b$’s have been read.\n3) There is no transition on $a$ in $q_{1}$, preventing any $a$ after the first $b$.\n4) There is no $\\epsilon$-accept from $q_{0}$ with $Z_{0}$, so the empty string is not accepted; at least one $a$ is required to produce an $S$ on top so that a $b$ can be read.\nTherefore Option C correctly recognizes $L$.\n\nOption D:\nSame as Option C except the accepting $\\epsilon$-move is $\\delta(q_{1},\\epsilon,S)=(q_{2},S)$, i.e., it allows moving to the accept state while an $S$ remains on the stack. For an input $a^{n}b^{m}$ with $m<2n$, after consuming all input we are in $q_{1}$ with top $S$ and can take $\\epsilon$ to $q_{2}$, hence incorrectly accept strings with too few $b$’s. Option D is incorrect.\n\nThus the correct choice is Option C.", "answer": "$$\\boxed{C}$$", "id": "1359997"}, {"introduction": "While pushdown automata provide a machine-based model for recognizing context-free languages, an equally powerful and often more intuitive approach is to define them generatively using a Context-Free Grammar (CFG). This exercise focuses on constructing a CFG for a language where the count of one symbol is double the count of another. You'll explore how recursive production rules can elegantly build strings that maintain a specific numerical relationship, offering a different yet complementary perspective to the automaton model [@problem_id:1360008].", "problem": "In the theory of formal languages, a Context-Free Grammar (CFG) is a formal grammar in which every production rule is of the form $V \\to w$, where $V$ is a single non-terminal symbol, and $w$ is a string of terminals and/or non-terminals.\n\nConsider the language $L$ defined over the alphabet $\\Sigma = \\{0, 1\\}$. The language $L$ consists of all strings where the number of zeros is exactly double the number of ones. This can be formally written as $L = \\{w \\in \\{0, 1\\}^* \\mid n_0(w) = 2 \\cdot n_1(w) \\}$, where $n_0(w)$ is the count of the symbol '0' in string $w$, and $n_1(w)$ is the count of the symbol '1' in $w$. The empty string, denoted by $\\epsilon$, is part of this language.\n\nWhich of the following Context-Free Grammars correctly generates the language $L$? In each grammar, $S$ is the start symbol.\n\nA. The grammar with the following rules:\n$S \\to \\epsilon$\n$S \\to SS$\n$S \\to 1S0S0$\n$S \\to 0S1S0$\n$S \\to 00S1$\n\nB. The grammar with the following rules:\n$S \\to \\epsilon$\n$S \\to SSS$\n$S \\to 100$\n$S \\to 010$\n$S \\to 001$\n\nC. The grammar with the following rules:\n$S \\to \\epsilon$\n$S \\to 0S1$\n\nD. The grammar with the following rules:\n$S \\to \\epsilon$\n$S \\to 00S1S$", "solution": "The correct grammar must satisfy two conditions:\n1.  **Soundness**: Every string generated by the grammar must be in the language $L$. That is, for any string $w$ derived from the start symbol $S$, it must be true that $n_0(w) = 2 \\cdot n_1(w)$.\n2.  **Completeness**: The grammar must be able to generate every string that is in the language $L$.\n\nLet's analyze each option based on these two criteria.\n\n**Analysis of Option A:**\nThe rules are: $S \\to \\epsilon \\mid SS \\mid 1S0S0 \\mid 0S1S0 \\mid 00S1$.\n\n*   **Soundness**: We can check this by induction on the length of the derivation.\n    *   **Base Case**: The rule $S \\to \\epsilon$ generates the empty string. For $\\epsilon$, $n_0(\\epsilon) = 0$ and $n_1(\\epsilon) = 0$, so $0 = 2 \\cdot 0$. The property holds.\n    *   **Inductive Step**: Assume that any string derivable from $S$ in fewer than $k$ steps satisfies the property. Consider a derivation of length $k$.\n        *   If the first rule is $S \\to SS$, the resulting string is $w_1w_2$ where $w_1$ and $w_2$ are derived from $S$ in fewer steps. By the inductive hypothesis, $n_0(w_1) = 2n_1(w_1)$ and $n_0(w_2) = 2n_1(w_2)$. For the combined string $w_1w_2$, $n_0(w_1w_2) = n_0(w_1) + n_0(w_2) = 2n_1(w_1) + 2n_1(w_2) = 2(n_1(w_1) + n_1(w_2)) = 2n_1(w_1w_2)$. The property holds.\n        *   If the first rule is $S \\to 1S_a0S_b0$, where $S_a, S_b$ are instances of $S$, the resulting string $w$ is formed from one '1', two '0's, and strings $w_a, w_b$ derived from $S_a, S_b$. By hypothesis, $n_0(w_a)=2n_1(w_a)$ and $n_0(w_b)=2n_1(w_b)$. For the final string $w$, $n_1(w) = 1 + n_1(w_a) + n_1(w_b)$ and $n_0(w) = 2 + n_0(w_a) + n_0(w_b) = 2 + 2n_1(w_a) + 2n_1(w_b) = 2(1 + n_1(w_a) + n_1(w_b)) = 2n_1(w)$. The property holds.\n        *   Similar logic applies to $S \\to 0S1S0$ and $S \\to 00S1$. Each of these rules adds two '0's and one '1' to strings that already satisfy the property, thus preserving it.\n    *   Therefore, the grammar is sound.\n\n*   **Completeness**: This grammar is also complete. It can generate all strings in $L$. For example, to generate the string $w=100010$ (which is in $L$ as $n_1=2, n_0=4$), we can use the following derivation:\n    $S \\to 1S0S0 \\to 1(\\epsilon)0(00S1)0 \\to 10(00\\epsilon1)0 = 100010$.\n    The structure of the rules allows for the necessary interleaving of symbols that simpler grammars might miss.\n\nSince the grammar is both sound and complete, it is a correct grammar for the language $L$.\n\n**Analysis of Option B:**\nThe rules are: $S \\to \\epsilon \\mid SSS \\mid 100 \\mid 010 \\mid 001$.\nThis grammar is sound, as any concatenation of the \"atomic\" strings `100`, `010`, `001` will maintain the property $n_0(w) = 2n_1(w)$. However, it is **not complete**. Consider the string $w=101000 \\in L$ (since $n_1=2, n_0=4$). This string cannot be formed by concatenating the strings `100`, `010`, and `001`. For example, the string starts with `101`, which is not a prefix of any of the atomic blocks. Therefore, this grammar cannot generate all strings in $L$.\n\n**Analysis of Option C:**\nThe rules are: $S \\to \\epsilon \\mid 0S1$.\nThis is a well-known grammar for the language $\\{0^n 1^n \\mid n \\ge 0\\}$. For any non-empty string $w$ generated by this grammar, $n_0(w) = n_1(w)$. This violates the condition $n_0(w) = 2n_1(w)$ for our target language $L$. For example, this grammar generates the string `01`, which is not in $L$. Thus, the grammar is **not sound**.\n\n**Analysis of Option D:**\nThe rules are: $S \\to \\epsilon \\mid 00S1S$.\nThis grammar is sound, as the recursive rule $S \\to 00S1S$ adds two '0's and one '1' to strings that already satisfy the property. However, it is **not complete**. Any non-empty string generated by this grammar must start with the symbol '0' (specifically, with '00'). It cannot generate the string `100`, which is a valid string in the language $L$.\n\n**Conclusion:**\nOnly the grammar in Option A is both sound and complete for the language $L$.", "answer": "$$\\boxed{A}$$", "id": "1360008"}]}