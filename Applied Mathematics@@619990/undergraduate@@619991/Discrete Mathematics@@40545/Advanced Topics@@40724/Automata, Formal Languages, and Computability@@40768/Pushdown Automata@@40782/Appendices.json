{"hands_on_practices": [{"introduction": "Understanding a Pushdown Automaton (PDA) begins with learning to read its formal definition and trace its execution. This first exercise provides a complete PDA and asks you to find a string it accepts. By manually simulating the machine's state changes and stack manipulations based on its transition function $\\delta$, you will gain a concrete understanding of how these components work together to recognize a specific language. This practice is fundamental to mastering the operational mechanics of PDAs [@problem_id:1394348].", "problem": "A Pushdown Automaton (PDA) is formally defined as a 7-tuple $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$. Consider the specific PDA $M$ defined as follows:\n-   $Q = \\{q_0, q_1, q_2\\}$ is the set of states.\n-   $\\Sigma = \\{a, b, c\\}$ is the input alphabet.\n-   $\\Gamma = \\{X, Z_0\\}$ is the stack alphabet.\n-   $q_0$ is the start state.\n-   $Z_0$ is the initial stack symbol.\n-   $F = \\{q_2\\}$ is the set of final (accepting) states.\n-   $\\delta$ is the transition function, defined by the following rules:\n    1.  $\\delta(q_0, a, Z_0) = \\{(q_0, XXZ_0)\\}$\n    2.  $\\delta(q_0, a, X) = \\{(q_0, XXX)\\}$\n    3.  $\\delta(q_0, c, X) = \\{(q_1, X)\\}$\n    4.  $\\delta(q_1, b, X) = \\{(q_1, \\epsilon)\\}$\n    5.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nHere, a transition rule $\\delta(q_i, \\sigma, A) = \\{(q_j, B)\\}$ means that if the machine is in state $q_i$, reads input symbol $\\sigma$, and the top of the stack is $A$, it can transition to state $q_j$ and replace $A$ on the stack with $B$. An input symbol of $\\epsilon$ denotes an empty string (the transition occurs without consuming an input symbol), and a replacement string of $\\epsilon$ denotes a pop operation (the symbol is removed from the stack without pushing anything).\n\nFind one non-empty string that is accepted by this PDA $M$.", "solution": "We analyze the effect of each transition. In state $q_{0}$, reading an $a$ when the stack top is $Z_{0}$ applies $\\delta(q_{0}, a, Z_{0})=(q_{0}, XXZ_{0})$, pushing two $X$ symbols. For subsequent $a$ symbols with stack top $X$, $\\delta(q_{0}, a, X)=(q_{0}, XXX)$ replaces the top $X$ by $XXX$, increasing the number of $X$ by two per $a$. Thus, after reading $n\\geq 1$ copies of $a$ in $q_{0}$, the stack holds $2n$ copies of $X$ above $Z_{0}$. Reading $c$ with top $X$ executes $\\delta(q_{0}, c, X)=(q_{1}, X)$, switching to $q_{1}$ without changing the stack. In $q_{1}$, each $b$ with top $X$ applies $\\delta(q_{1}, b, X)=(q_{1}, \\epsilon)$, popping one $X$. After exactly $2n$ copies of $b$, the stack top becomes $Z_{0}$, at which point the $\\epsilon$-transition $\\delta(q_{1}, \\epsilon, Z_{0})=(q_{2}, Z_{0})$ moves to the accepting state $q_{2}$. Therefore the language accepted is $\\{a^{n}cb^{2n}\\mid n\\geq 1\\}$, so a concrete non-empty accepted string is $acbb$ (the case $n=1$).\n\nWe now give the explicit computation for $w=acbb$ using instantaneous descriptions $(\\text{state}, \\text{input remaining}, \\text{stack})$, with the top of the stack on the left:\n$$(q_{0}, acbb, Z_{0}) \\vdash (q_{0}, cbb, XXZ_{0}) \\quad\\text{by }\\delta(q_{0}, a, Z_{0})=(q_{0}, XXZ_{0}),$$\n$$(q_{0}, cbb, XXZ_{0}) \\vdash (q_{1}, bb, XXZ_{0}) \\quad\\text{by }\\delta(q_{0}, c, X)=(q_{1}, X),$$\n$$(q_{1}, bb, XXZ_{0}) \\vdash (q_{1}, b, XZ_{0}) \\quad\\text{by }\\delta(q_{1}, b, X)=(q_{1}, \\epsilon),$$\n$$(q_{1}, b, XZ_{0}) \\vdash (q_{1}, \\epsilon, Z_{0}) \\quad\\text{by }\\delta(q_{1}, b, X)=(q_{1}, \\epsilon),$$\n$$(q_{1}, \\epsilon, Z_{0}) \\vdash (q_{2}, \\epsilon, Z_{0}) \\quad\\text{by }\\delta(q_{1}, \\epsilon, Z_{0})=(q_{2}, Z_{0}).$$\nSince $q_{2}\\in F$ and the input is exhausted, $acbb$ is accepted.", "answer": "$$\\boxed{acbb}$$", "id": "1394348"}, {"introduction": "Beyond tracing a correct machine, a crucial skill is identifying flaws in an incorrect one. This problem presents a nearly perfect PDA designed to recognize palindromic structures of the form $w\\#w^R$, a classic task for this type of automaton. Your challenge is to act as a debugger, analyzing the set of transitions to find the single rule that causes the machine to accept strings it should reject. This exercise [@problem_id:1394387] emphasizes the importance of precision in defining transitions and how a small error can violate the language's formal definition.", "problem": "A computer scientist is designing an automaton to recognize a specific language. The target language is $L = \\{w\\#w^R \\mid w \\in \\{0,1\\}^*\\}$, where $w^R$ is the reverse of the string $w$. For example, the string `011#110` is in $L$, while `01#01` is not.\n\nThe scientist proposes a Pushdown Automaton (PDA), which is a type of automaton equipped with a stack. The proposed PDA is defined by the 7-tuple $M = (Q, \\Sigma, \\Gamma, \\delta, q_{start}, Z_0, F)$, with the following components:\n-   Set of states: $Q = \\{q_0, q_1, q_2\\}$\n-   Input alphabet: $\\Sigma = \\{0, 1, \\#\\}$\n-   Stack alphabet: $\\Gamma = \\{0, 1, Z_0\\}$\n-   Start state: $q_{start} = q_0$\n-   Initial stack symbol: $Z_0$\n-   Set of final (accepting) states: $F = \\{q_2\\}$\n\nThe PDA is designed to operate as follows: in state $q_0$, it reads the substring $w$ and pushes its symbols onto the stack. When it reads the `#` symbol, it switches to state $q_1$. In state $q_1$, it matches the incoming symbols of $w^R$ with the symbols popped from the stack. If the input is fully read and the stack is empty (except for $Z_0$), it moves to the accepting state $q_2$.\n\nThe transition function $\\delta$ contains exactly one faulty rule that causes the PDA to fail in its task of recognizing language $L$. This means the PDA either accepts strings that are not in $L$ or rejects strings that are in $L$. The set of transitions is listed below.\n\n-   $\\delta(q_0, 0, X) = \\{(q_0, 0X)\\}$ for any $X \\in \\Gamma$\n-   $\\delta(q_0, 1, X) = \\{(q_0, 1X)\\}$ for any $X \\in \\Gamma$\n-   $\\delta(q_0, \\#, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$\n-   $\\delta(q_1, 0, 0) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, 1, 1) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$\n-   $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nYour task is to identify the faulty transition rule among the options provided below.\n\nA. The transition rule $\\delta(q_0, 0, X) = \\{(q_0, 0X)\\}$ for any $X \\in \\Gamma$.\n\nB. The transition rule $\\delta(q_0, \\#, X) = \\{(q_1, X)\\}$ for any $X \\in \\Gamma$.\n\nC. The transition rule $\\delta(q_1, 0, 1) = \\{(q_1, \\epsilon)\\}$.\n\nD. The transition rule $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$.", "solution": "We want the PDA to accept exactly $L=\\{w\\#w^{R}\\mid w\\in\\{0,1\\}^{*}\\}$. Let $w=a_{1}a_{2}\\dots a_{n}$ with each $a_{i}\\in\\{0,1\\}$. In state $q_{0}$ the PDA pushes each read symbol of $w$ onto the stack so that, after reading all of $w$, the stack content (from top to bottom) is $a_{n}a_{n-1}\\dots a_{1}Z_{0}$. Upon reading $\\#$, it must switch to $q_{1}$ without altering the stack, so that in $q_{1}$ it can compare the incoming symbols with the stack top. In $q_{1}$, to enforce $w^{R}$, each next input symbol must equal the current stack top and be popped; when all of the input is consumed and only $Z_{0}$ remains, an $\\epsilon$-move to the accepting state $q_{2}$ is taken.\n\nNow check each listed transition against this intended behavior.\n\n1) $\\delta(q_{0},0,X)=\\{(q_{0},0X)\\}$ for any $X\\in\\Gamma$. This correctly pushes a $0$ on top of whatever is on the stack while reading the left half $w$. This implements the required push behavior, so it is consistent.\n\n2) $\\delta(q_{0},\\#,X)=\\{(q_{1},X)\\}$ for any $X\\in\\Gamma$. This correctly switches from building the stack to the matching phase at the delimiter $\\#$, leaving the stack unchanged, which is exactly what is needed.\n\n3) $\\delta(q_{1},0,1)=\\{(q_{1},\\epsilon)\\}$. In the matching phase, the input symbol must equal the stack top to pop it for language $w\\#w^{R}$. However, this rule pops a $1$ when reading a $0$, permitting a mismatch. This acceptance of mismatches causes the PDA to accept strings not in $L$. A concrete counterexample is the input $1\\#0$: starting with $Z_{0}$, in $q_{0}$ reading $1$ pushes $1$ so the stack is $1Z_{0}$; reading $\\#$ moves to $q_{1}$ with stack unchanged; in $q_{1}$ reading $0$, the faulty rule $\\delta(q_{1},0,1)$ pops the $1$; with input now exhausted and stack top $Z_{0}$, the transition $\\delta(q_{1},\\epsilon,Z_{0})=(q_{2},Z_{0})$ moves to $q_{2}$. Thus $1\\#0$ is accepted, but $1\\#0\\notin L$ because $w=1$ implies $w^{R}=1$, not $0$. Hence this rule is faulty.\n\n4) $\\delta(q_{1},\\epsilon,Z_{0})=\\{(q_{2},Z_{0})\\}$. This permits acceptance by final state once the input is consumed and the stack has returned to $Z_{0}$. It is consistent with the intended acceptance condition and does not introduce incorrect acceptance, because reaching $q_{2}$ is only an accepting configuration when the input has been consumed.\n\nTherefore, the unique faulty transition among the options is $\\delta(q_{1},0,1)=\\{(q_{1},\\epsilon)\\}$, i.e., option C.", "answer": "$$\\boxed{C}$$", "id": "1394387"}, {"introduction": "The ultimate test of understanding is the ability to design. In this final exercise, you will construct a Pushdown Automaton for the language $L = \\{a^n b^{n+1} \\mid n \\ge 0\\}$. The task is to select the correct set of transition rules that allows the machine to use its stack for counting, handle the 'plus one' condition, and correctly manage edge cases like $n=0$. This practice solidifies your ability to translate an abstract language specification into the concrete operational logic of a PDA [@problem_id:1394394].", "problem": "Consider the language $L$ defined over the alphabet $\\Sigma = \\{a, b\\}$ as $L = \\{a^n b^{n+1} \\mid n \\ge 0\\}$. We wish to construct a Pushdown Automaton (PDA) that accepts this language by final state.\n\nA PDA is formally defined by a 7-tuple $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$. For this problem, let the components be fixed as follows:\n- The set of states $Q = \\{q_0, q_1, q_2\\}$\n- The input alphabet $\\Sigma = \\{a, b\\}$\n- The stack alphabet $\\Gamma = \\{A, Z_0\\}$\n- The initial state is $q_0$\n- The initial stack symbol is $Z_0$\n- The set of final (accepting) states $F = \\{q_2\\}$\n\nA transition is defined as $\\delta(\\text{current\\_state}, \\text{input\\_symbol}, \\text{stack\\_top}) = \\{(\\text{next\\_state}, \\text{string\\_to\\_push})\\}$. The symbol $\\epsilon$ represents the empty string.\n\nWhich of the following definitions of the transition function $\\delta$ correctly specifies a PDA that accepts the language $L$?\n\nA.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, \\epsilon)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_1, \\epsilon)\\}$\n6.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nB.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, b, Z_0) = \\{(q_1, Z_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, A)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_1, \\epsilon)\\}$\n6.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nC.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, b, Z_0) = \\{(q_1, AZ_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, AA)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_1, \\epsilon)\\}$\n6.  $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\nD.\n1.  $\\delta(q_0, a, Z_0) = \\{(q_0, AZ_0)\\}$\n2.  $\\delta(q_0, a, A) = \\{(q_0, AA)\\}$\n3.  $\\delta(q_0, b, Z_0) = \\{(q_1, Z_0)\\}$\n4.  $\\delta(q_0, b, A) = \\{(q_1, A)\\}$\n5.  $\\delta(q_1, b, A) = \\{(q_2, \\epsilon)\\}$\n6.  $\\delta(q_2, b, A) = \\{(q_2, \\epsilon)\\}$", "solution": "We need a PDA that accepts exactly the strings in $L = \\{a^{n} b^{n+1} \\mid n \\ge 0\\}$ by final state, over $\\Sigma = \\{a,b\\}$, with stack alphabet $\\Gamma = \\{A, Z_{0}\\}$, start state $q_{0}$, start stack symbol $Z_{0}$, and accepting state set $F = \\{q_{2}\\}$. A standard construction uses the following invariant-driven strategy: while reading $a$’s in $q_{0}$, push one $A$ for each $a$ so that after $a^{n}$ the stack is $A^{n} Z_{0}$. When the first $b$ is seen, move to a new state $q_{1}$ but do not pop on that first $b$; this accounts for the extra $b$ required by $b^{n+1}$. Then, for each subsequent $b$, pop one $A$. When all $A$’s have been popped, the stack top is $Z_{0}$. At that moment, the input must be exhausted if and only if the number of $b$’s after the first equals the number of $a$’s, and we accept by an $\\epsilon$-move to the final state $q_{2}$. No $a$ is allowed after the first $b$, so there should be no transition on $a$ from $q_{1}$.\n\nOption B exactly implements this plan:\n1. $\\delta(q_{0}, a, Z_{0}) = \\{(q_{0}, A Z_{0})\\}$ pushes $A$ on the first $a$.\n2. $\\delta(q_{0}, a, A) = \\{(q_{0}, A A)\\}$ pushes $A$ on each subsequent $a$.\n3. $\\delta(q_{0}, b, Z_{0}) = \\{(q_{1}, Z_{0})\\}$ consumes the first $b$ when $n = 0$ and moves to $q_{1}$ without popping or pushing.\n4. $\\delta(q_{0}, b, A) = \\{(q_{1}, A)\\}$ consumes the first $b$ when $n \\ge 1$ and moves to $q_{1}$ without popping (accounts for the extra $b$).\n5. $\\delta(q_{1}, b, A) = \\{(q_{1}, \\epsilon)\\}$ pops one $A$ for each subsequent $b$.\n6. $\\delta(q_{1}, \\epsilon, Z_{0}) = \\{(q_{2}, Z_{0})\\}$ accepts by final state exactly when the stack top is $Z_{0}$ and input is exhausted.\n\nCorrectness that Option B accepts exactly $L$:\n- For any $w \\in L$, let $w = a^{n} b^{n+1}$. After reading $a^{n}$ in $q_{0}$, the stack is $A^{n} Z_{0}$. The next symbol is the first $b$, which applies either rule 3 (if $n = 0$) or rule 4 (if $n \\ge 1$), moving to $q_{1}$ and leaving the stack unchanged. There remain exactly $n$ $b$’s. Each of those $n$ $b$’s triggers rule 5, popping one $A$. After these $n$ $b$’s, the stack is $Z_{0}$ and the input is exhausted. Then rule 6 applies, moving to $q_{2}$, and the string is accepted by final state.\n- Conversely, suppose the PDA accepts some input. The only way to reach $q_{2}$ is via rule 6 from $q_{1}$ with stack top $Z_{0}$. The only way to enter $q_{1}$ is by reading a $b$ in $q_{0}$ (rules 3 or 4), so the input has the form $a^{n} b^{m}$ with $m \\ge 1$, and no $a$ can occur after that first $b$ since there is no transition on $a$ from $q_{1}$. In $q_{1}$ the only input-consuming transition is rule 5, which requires an $A$ to pop for each $b$ after the first. Since there are exactly $n$ $A$’s on the stack when leaving $q_{0}$, exactly $n$ further $b$’s can be consumed before the stack returns to $Z_{0}$. At that point, there is no transition on $b$ with $Z_{0}$, so the input must be exhausted; then rule 6 applies. Therefore the total number of $b$’s is exactly $1 + n$, and accepted strings are exactly $a^{n} b^{n+1}$.\n\nAll other options fail:\n- Option A wrongly includes $\\delta(q_{0}, \\epsilon, Z_{0}) = \\{(q_{2}, Z_{0})\\}$, which accepts the empty string, not in $L$; it also fails to accept $b$ for $n=0$.\n- Option C pushes an $A$ on the first $b$, so it rejects $b$ (the case $n=0$), which must be in $L$.\n- Option D lacks an accepting $\\epsilon$-move on $Z_{0}$ from $q_{1}$ and thus rejects $b$ when $n=0$.\n\nHence, the correct transition function is Option B.", "answer": "$$\\boxed{B}$$", "id": "1394394"}]}