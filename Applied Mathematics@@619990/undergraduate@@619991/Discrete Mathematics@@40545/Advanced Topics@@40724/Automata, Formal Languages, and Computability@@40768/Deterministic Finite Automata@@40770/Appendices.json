{"hands_on_practices": [{"introduction": "The power of a Deterministic Finite Automaton lies in its states, which act as a form of finite memory. This first exercise provides a classic demonstration of this principle, where you will determine the states needed to track a simple repeating pattern: a count modulo a number. By figuring out how to recognize strings where the number of 'a's is congruent to $1$ modulo $3$, you'll gain a core intuition for DFA design: states represent the essential information we need to remember about the string we've seen so far. [@problem_id:1362816]", "problem": "In the theory of computation, a Deterministic Finite Automaton (DFA) is a theoretical model of a machine that can recognize a set of strings, known as a formal language. Consider a language $L$ over the alphabet $\\Sigma = \\{a, b\\}$. A string $w$ is defined to be in language $L$ if and only if the total number of occurrences of the character 'a' in $w$ is congruent to 1 modulo 3. For any string $w$, let $n_a(w)$ denote the number of 'a's in $w$. Then, mathematically, the language is $L = \\{w \\in \\{a, b\\}^* \\mid n_a(w) \\equiv 1 \\pmod{3}\\}$. Note that the empty string has zero 'a's.\n\nWhat is the minimum number of states required for a DFA to recognize this language $L$?", "solution": "We seek the minimum number of states of a DFA recognizing $L = \\{w \\in \\{a,b\\}^{*} \\mid n_{a}(w) \\equiv 1 \\pmod{3}\\}$. The behavior of the language depends only on $n_{a}(w) \\bmod 3$, so consider the congruence classes modulo $3$.\n\nLower bound (Myhill-Nerode distinguishability):\nFor $i \\in \\{0,1,2\\}$, define the set\n$$\nC_{i} = \\{ w \\in \\{a,b\\}^{*} \\mid n_{a}(w) \\equiv i \\pmod{3} \\}.\n$$\nWe show that $C_{0}, C_{1}, C_{2}$ are pairwise distinguishable with respect to $L$. Let $u \\in C_{i}$ and $v \\in C_{j}$ with $i \\neq j$. Choose a distinguishing extension $t = a^{k}$ where $k \\equiv 1 - i \\pmod{3}$. Then\n$$\nn_{a}(ut) \\equiv n_{a}(u) + n_{a}(t) \\equiv i + k \\equiv i + (1 - i) \\equiv 1 \\pmod{3},\n$$\nso $ut \\in L$. On the other hand,\n$$\nn_{a}(vt) \\equiv n_{a}(v) + n_{a}(t) \\equiv j + k \\equiv j + (1 - i) \\equiv 1 + (j - i) \\pmod{3}.\n$$\nSince $j - i \\not\\equiv 0 \\pmod{3}$, we have $n_{a}(vt) \\not\\equiv 1 \\pmod{3}$, so $vt \\notin L$. Thus $C_{i}$ and $C_{j}$ are distinguishable. Therefore, by the Myhill-Nerode theorem, any DFA for $L$ requires at least $3$ states.\n\nUpper bound (construction of a $3$-state DFA):\nDefine a DFA with state set $Q = \\{q_{0}, q_{1}, q_{2}\\}$, start state $q_{0}$, accepting set $\\{q_{1}\\}$, and transition function\n$$\n\\delta(q_{r}, a) = q_{(r+1) \\bmod 3}, \\quad \\delta(q_{r}, b) = q_{r}.\n$$\nBy induction on the length of the input, after reading any $w$, the automaton is in state $q_{n_{a}(w) \\bmod 3}$. Hence it accepts exactly when $n_{a}(w) \\equiv 1 \\pmod{3}$, so it recognizes $L$.\n\nCombining the lower bound of $3$ with the existence of a $3$-state DFA, the minimum number of states required is $3$.", "answer": "$$\\boxed{3}$$", "id": "1362816"}, {"introduction": "Real-world systems often have to satisfy multiple rules at once. Instead of designing a complex machine from scratch, we can often build simpler machines for each rule and then combine them, a testament to the closure properties of regular languages. This practice introduces the 'product construction,' a fundamental technique for creating a new automaton that accepts the intersection of two languages, effectively running two DFAs in parallel. By analyzing the resulting machine, you will see how complex logic can emerge from combining simple components. [@problem_id:1362787]", "problem": "Consider two Deterministic Finite Automata (DFA), $M_1$ and $M_2$, defined over the alphabet $\\Sigma = \\{a, b\\}$.\n\nThe first automaton, $M_1 = (Q_1, \\Sigma, \\delta_1, q_S, F_1)$, is defined as follows:\n-   The set of states is $Q_1 = \\{q_S, q_A, q_B\\}$.\n-   The start state is $q_S$.\n-   The set of accepting (final) states is $F_1 = \\{q_A, q_B\\}$. Note that the start state is the only non-accepting state.\n-   The transition function, $\\delta_1: Q_1 \\times \\Sigma \\to Q_1$, is given by the following rules:\n    -   $\\delta_1(q_S, a) = q_A$\n    -   $\\delta_1(q_S, b) = q_B$\n    -   $\\delta_1(q_A, a) = q_A$\n    -   $\\delta_1(q_A, b) = q_B$\n    -   $\\delta_1(q_B, a) = q_A$\n    -   $\\delta_1(q_B, b) = q_B$\n\nThe second automaton, $M_2 = (Q_2, \\Sigma, \\delta_2, p_0, F_2)$, is defined as follows:\n-   The set of states is $Q_2 = \\{p_0, p_1\\}$.\n-   The start state is $p_0$.\n-   The set of accepting (final) states is $F_2 = \\{p_1\\}$.\n-   The transition function, $\\delta_2: Q_2 \\times \\Sigma \\to Q_2$, is given by the following rules:\n    -   $\\delta_2(p_0, a) = p_1$\n    -   $\\delta_2(p_0, b) = p_0$\n    -   $\\delta_2(p_1, a) = p_1$\n    -   $\\delta_2(p_1, b) = p_0$\n\nA new automaton, $M_3 = (Q_3, \\Sigma, \\delta_3, q_{start}, F_3)$, is constructed from $M_1$ and $M_2$ with the following components:\n-   State set: $Q_3 = Q_1 \\times Q_2$ (the Cartesian product of the state sets).\n-   Start state: $q_{start} = (q_S, p_0)$.\n-   Set of accepting states: $F_3 = F_1 \\times F_2$.\n-   Transition function: $\\delta_3((q, p), \\sigma) = (\\delta_1(q, \\sigma), \\delta_2(p, \\sigma))$ for any state $(q, p) \\in Q_3$ and any symbol $\\sigma \\in \\Sigma$.\n\nWhich of the following statements accurately describes the language $L(M_3)$ accepted by the machine $M_3$?\n\nA. The language of all non-empty strings over the alphabet $\\{a, b\\}$.\n\nB. The language of all strings over the alphabet $\\{a, b\\}$ that end with the symbol 'a'.\n\nC. The language of all strings over the alphabet $\\{a, b\\}$ that contain at least one 'a'.\n\nD. The language of all strings over the alphabet $\\{a, b\\}$ that start with 'a' and end with 'a'.\n\nE. The empty language.", "solution": "We analyze each DFA and the product construction.\n\nFor $M_{1}$, observe from the transition function that once the first input symbol is read from $q_{S}$, the machine moves to either $q_{A}$ on symbol $a$ or $q_{B}$ on symbol $b$, and both $q_{A}$ and $q_{B}$ are accepting. For any subsequent symbol, $\\delta_{1}$ preserves the property that the state indicates the last symbol read: $\\delta_{1}(q_{A},a)=q_{A}$, $\\delta_{1}(q_{A},b)=q_{B}$, $\\delta_{1}(q_{B},a)=q_{A}$, and $\\delta_{1}(q_{B},b)=q_{B}$. Therefore, for any non-empty string $w \\in \\{a,b\\}^{+}$, after processing $w$ the state is in $F_{1}$, and for the empty string $\\epsilon$, the machine remains in $q_{S} \\notin F_{1}$. Hence,\n$$\nL(M_{1})=\\{a,b\\}^{+}.\n$$\n\nFor $M_{2}$, from $p_{0}$ the transition on $a$ goes to $p_{1}$ and on $b$ stays at $p_{0}$; from $p_{1}$ the transition on $a$ stays at $p_{1}$ and on $b$ goes to $p_{0}$. By induction on the length of the input, after processing any string $w \\in \\{a,b\\}^{\\ast}$, the automaton is in $p_{1}$ if and only if the last symbol of $w$ is $a$, and is in $p_{0}$ otherwise (including $w=\\epsilon$). Since $F_{2}=\\{p_{1}\\}$, we have\n$$\nL(M_{2})=\\{\\,w \\in \\{a,b\\}^{\\ast} : \\text{the last symbol of } w \\text{ is } a\\,\\}.\n$$\n\nFor the product DFA $M_{3}$, the construction is $Q_{3}=Q_{1}\\times Q_{2}$, start state $q_{start}=(q_{S},p_{0})$, transition $\\delta_{3}((q,p),\\sigma)=(\\delta_{1}(q,\\sigma),\\delta_{2}(p,\\sigma))$, and accepting set $F_{3}=F_{1}\\times F_{2}$. For any input $w \\in \\{a,b\\}^{\\ast}$, by definition of the product construction, $M_{3}$ accepts $w$ if and only if $M_{1}$ accepts $w$ and $M_{2}$ accepts $w$, i.e.,\n$$\nL(M_{3})=L(M_{1}) \\cap L(M_{2}).\n$$\nSubstituting the characterizations of $L(M_{1})$ and $L(M_{2})$,\n$$\nL(M_{3})=\\{a,b\\}^{+} \\cap \\{\\,w \\in \\{a,b\\}^{\\ast} : \\text{last symbol is } a\\,\\}.\n$$\nSince every string whose last symbol is $a$ is necessarily non-empty, the intersection simplifies to\n$$\nL(M_{3})=\\{\\,w \\in \\{a,b\\}^{\\ast} : \\text{the last symbol of } w \\text{ is } a\\,\\}.\n$$\nThis matches option B: the language of all strings over $\\{a,b\\}$ that end with the symbol $a$.", "answer": "$$\\boxed{B}$$", "id": "1362787"}, {"introduction": "This final practice challenges you to apply and synthesize the concepts from the previous exercises. You will design a DFA from the ground up to validate data packets that must meet two independent criteria simultaneously: one based on arithmetic properties (divisibility) and another on symbol counts (parity). This task requires you to not only conceptualize the product construction yourself but also to reason about the minimality of the resulting automaton, bringing together design, analysis, and optimization in a single, comprehensive problem. [@problem_id:1362807]", "problem": "In a specialized data transmission system, a remote sensor sends data packets to a central controller. Each packet is a non-empty binary string. For a packet to be considered valid and processed by the controller, it must satisfy two distinct criteria simultaneously. The binary string is read from left to right, with the leftmost bit being the most significant bit.\n\nThe criteria for a valid packet are:\n1.  The integer value represented by the binary string must be divisible by 5.\n2.  The total number of '1's in the binary string must be odd.\n\nFor example, the string \"101\" represents the integer 5, and it contains two '1's. It satisfies the first criterion but not the second, so it is an invalid packet. The string \"11001\" represents the integer 25, and it contains three '1's. It satisfies both criteria, so it is a valid packet.\n\nWhat is the minimum number of states required for a Deterministic Finite Automaton (DFA) that accepts the language of all valid data packets?", "solution": "Let $w \\in \\{0,1\\}^{+}$ be read left to right. Let $\\operatorname{val}(w)$ be the integer value of $w$ in base $2$, and let $\\operatorname{par}(w) \\in \\{E,O\\}$ denote the parity (even/odd) of the number of $1$s in $w$. The language is\n$$\nL=\\{\\,w \\in \\{0,1\\}^{+} : \\operatorname{val}(w) \\equiv 0 \\pmod{5}\\ \\text{and}\\ \\operatorname{par}(w)=O\\,\\}.\n$$\n\nA DFA that recognizes $L$ must track simultaneously:\n- the remainder $r \\in \\{0,1,2,3,4\\}$ of the current prefix modulo $5$, and\n- the parity $p \\in \\{E,O\\}$ of the number of $1$s seen so far.\n\nThus consider the deterministic automaton with state set\n$$\nQ=\\{0,1,2,3,4\\} \\times \\{E,O\\}.\n$$\nOn reading a bit $b \\in \\{0,1\\}$ from state $(r,p)$, the transition is\n$$\n(r,p) \\xrightarrow{b} \\big((2r+b) \\bmod 5,\\; p \\oplus [b=1]\\big),\n$$\nwhere $p \\oplus [b=1]$ toggles the parity iff $b=1$. The start state is $(0,E)$, and the accepting states are exactly\n$$\nF=\\{(0,O)\\}.\n$$\n\nWe show that this DFA has $10$ reachable and pairwise distinguishable states, hence the minimum number of states required is $10$.\n\nReachability of all $10$ states:\n- For any $r \\in \\{0,1,2,3,4\\}$, take the standard binary representation $x_{r}$ of $r$ (allow leading zero if needed to ensure non-empty input), then by construction the remainder after reading $x_{r}$ is $r$. The parity $\\operatorname{par}(x_{r})$ may be $E$ or $O$.\n- To independently adjust parity without changing the remainder modulo $5$, use a fixed word $y$ of length $8$ with odd parity and $\\operatorname{val}(y) \\equiv 0 \\pmod{5}$. One explicit choice is $y=00011001$, for which $\\operatorname{val}(y)=25 \\equiv 0 \\pmod{5}$ and $\\operatorname{par}(y)=O$. Appending $y$ toggles the parity (since it adds an odd number of $1$s) while preserving the remainder modulo $5$ because\n$$\n2^{8} \\equiv (2^{4})^{2} \\equiv 1 \\pmod{5},\\quad \\operatorname{val}(y) \\equiv 0 \\pmod{5}.\n$$\nTherefore, for any desired $(r,p)$, read $x_{r}$ to achieve remainder $r$, and append $y$ if necessary to adjust parity to $p$. Hence every pair in $Q$ is reachable.\n\nPairwise distinguishability (Myhillâ€“Nerode):\nLet $(r,p)$ and $(r',p')$ be two distinct states in $Q$. We produce a distinguishing suffix $s$ such that exactly one of the two extended computations is accepting.\n\nFirst, note the congruence tool: since $2^{4}=16 \\equiv 1 \\pmod{5}$, for any $a \\in \\{0,1,2,3,4\\}$ there exists a $4$-bit word $u$ with $\\operatorname{val}(u) \\equiv a \\pmod{5}$. Consequently, for any $r$ there exists a $4$-bit word $x$ with\n$$\n\\operatorname{val}(x) \\equiv -r \\pmod{5},\n$$\nso that appending $x$ to a prefix with remainder $r$ yields final remainder $0$:\n$$\nr\\cdot 2^{4} + \\operatorname{val}(x) \\equiv r \\cdot 1 + (-r) \\equiv 0 \\pmod{5}.\n$$\nIf we need to adjust the parity of $x$, we may append $y$ (as above); appending $y$ preserves the remainder $0$ while toggling parity, because $2^{8} \\equiv 1 \\pmod{5}$ and $\\operatorname{val}(y) \\equiv 0 \\pmod{5}$.\n\nNow distinguish the two cases:\n- If $r \\neq r'$, define $x$ as above with $\\operatorname{val}(x) \\equiv -r \\pmod{5}$. Let $q$ be the parity required to accept from $(r,p)$, namely $q=O$ if $p=E$ and $q=E$ if $p=O$. If $\\operatorname{par}(x)=q$, set $s=x$; otherwise set $s=xy$. From $(r,p)$, $s$ gives remainder $0$ and parity $O$, so it is accepting. From $(r',p')$, since $|s| \\equiv 4 \\pmod{8}$, we have $2^{|s|} \\equiv 1 \\pmod{5}$ and thus the final remainder is\n$$\nr'\\cdot 2^{|s|} + \\operatorname{val}(s) \\equiv r' + \\operatorname{val}(x) \\equiv r' - r \\not\\equiv 0 \\pmod{5},\n$$\nhence it is rejecting. Therefore $(r,p)$ and $(r',p')$ are distinguishable.\n- If $r=r'$ but $p \\neq p'$, use the same $x$ with $\\operatorname{val}(x) \\equiv -r \\pmod{5}$ and choose $s$ to make the final parity match the accepting requirement from $(r,p)$ (i.e., $s=x$ or $s=xy$ to ensure $O$). Then from $(r,p)$ the string $s$ is accepting, while from $(r,p')$ it yields remainder $0$ but the wrong parity, hence it is rejecting. Thus the states are distinguishable.\n\nSince all $10$ states in $Q$ are reachable and pairwise distinguishable, the minimal DFA for $L$ has exactly $10$ states.\n\nTherefore, the minimum number of states required is $10$.", "answer": "$$\\boxed{10}$$", "id": "1362807"}]}