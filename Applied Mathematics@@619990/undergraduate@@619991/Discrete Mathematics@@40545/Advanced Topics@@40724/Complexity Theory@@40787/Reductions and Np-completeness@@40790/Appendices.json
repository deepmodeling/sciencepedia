{"hands_on_practices": [{"introduction": "A cornerstone of complexity theory is the concept of a reduction, where we solve one problem by transforming it into another. This first exercise provides a classic and intuitive example, showing how a solver for the CLIQUE problem on a graph can be used to solve the INDEPENDENT-SET problem on the same set of vertices. You will see how a simple graph transformation—constructing the complement graph—establishes a direct equivalence between the two, illustrating the fundamental idea of polynomial-time reducibility [@problem_id:1395778].", "problem": "In computational complexity theory, decision problems are often studied by relating them to one another. Consider the following two fundamental problems in graph theory for a simple, undirected graph $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of edges.\n\n1.  **INDEPENDENT-SET Problem**: Given a graph $G$ and a positive integer $k$, is there a subset of vertices $S \\subseteq V$ of size at least $k$ such that for any two distinct vertices $u, v \\in S$, the edge $(u, v)$ is not in $E$? Such a set $S$ is called an independent set.\n\n2.  **CLIQUE Problem**: Given a graph $G$ and a positive integer $k$, is there a subset of vertices $C \\subseteq V$ of size at least $k$ such that for any two distinct vertices $u, v \\in C$, the edge $(u, v)$ is in $E$? Such a set $C$ is called a clique.\n\nSuppose you have access to a hypothetical, ultra-fast \"black box\" algorithm that can solve the CLIQUE problem in polynomial time. You are now tasked with solving an instance of the INDEPENDENT-SET problem for a specific graph, which we will call $G_{IS}$. The graph $G_{IS}$ has 75 vertices. Your goal is to determine if $G_{IS}$ contains an independent set of size at least 18.\n\nTo solve this, you can construct a new graph, let's call it $G'$, and pose a single question about it to your CLIQUE solver. This question will take the form of asking whether $G'$ contains a clique of a certain size.\n\nFor this problem, recall that the complement of a graph $G=(V, E)$, denoted $\\bar{G}$, is a graph with the same vertex set $V$, in which an edge $(u,v)$ exists if and only if it does not exist in $G$.\n\nWhich of the following describes the correct graph $G'$ and the correct size of the clique to query for, in order to solve the original INDEPENDENT-SET problem on $G_{IS}$?\n\nA. $G'$ is the same graph as $G_{IS}$, and you should ask for a clique of size 18.\n\nB. $G'$ is the complement of $G_{IS}$, and you should ask for a clique of size $75 - 18 = 57$.\n\nC. $G'$ is the same graph as $G_{IS}$, and you should ask for a clique of size $75 - 18 = 57$.\n\nD. $G'$ is the complement of $G_{IS}$, and you should ask for a clique of size 18.\n\nE. It is not possible to solve the INDEPENDENT-SET problem using a solver for the CLIQUE problem.", "solution": "The goal is to determine if a graph $G_{IS} = (V, E_{IS})$ has an independent set of size at least $k_{IS}$, by using a solver for the CLIQUE problem. We are given $|V|=75$ and $k_{IS}=18$.\n\nLet's analyze the relationship between an independent set in a graph $G$ and a clique in its complement graph $\\bar{G}$.\n\nLet $G = (V, E)$ be a graph. Its complement graph is $\\bar{G} = (V, \\bar{E})$, where $\\bar{E}$ is the set of all pairs of distinct vertices $\\{u, v\\}$ such that $\\{u, v\\} \\notin E$.\n\nBy definition, an independent set in $G$ is a subset of vertices $S \\subseteq V$ such that for every pair of distinct vertices $u, v \\in S$, the edge $(u, v)$ is **not** in $E$.\n\nBy definition, a clique in $\\bar{G}$ is a subset of vertices $C \\subseteq V$ such that for every pair of distinct vertices $u, v \\in C$, the edge $(u, v)$ **is** in $\\bar{E}$.\n\nNow, let's connect these two definitions. According to the definition of the complement graph $\\bar{G}$, an edge $(u, v)$ is in $\\bar{E}$ if and only if the edge $(u, v)$ is not in $E$.\n\nTherefore, the condition \"for every pair of distinct vertices $u, v \\in C$, the edge $(u, v)$ is in $\\bar{E}$\" (the definition of $C$ being a clique in $\\bar{G}$) is exactly equivalent to the condition \"for every pair of distinct vertices $u, v \\in C$, the edge $(u, v)$ is not in $E$\" (the definition of $C$ being an independent set in $G$).\n\nThis establishes a direct equivalence: A subset of vertices $S$ is an independent set in a graph $G$ if and only if $S$ is a clique in the complement graph $\\bar{G}$.\n\nConsequently, a graph $G$ has an independent set of size at least $k$ if and only if its complement graph $\\bar{G}$ has a clique of size at least $k$.\n\nIn our specific problem, we want to determine if the graph $G_{IS}$ has an independent set of size at least $k_{IS}=18$. Based on the reasoning above, this is equivalent to asking if the complement graph of $G_{IS}$, which we'll call $\\bar{G}_{IS}$, has a clique of size at least 18.\n\nSo, to use our CLIQUE solver, we must perform the following steps:\n1.  Construct the complement graph of $G_{IS}$. This will be our graph $G'$. So, $G' = \\bar{G}_{IS}$. The number of vertices remains 75.\n2.  Query the CLIQUE solver with the graph $G'$ and the size $k=18$. The solver will tell us if $G'$ has a clique of size at least 18.\n\nIf the solver returns TRUE, then $\\bar{G}_{IS}$ has a clique of size at least 18, which means $G_{IS}$ has an independent set of size at least 18. If it returns FALSE, then $G_{IS}$ does not.\n\nLet's evaluate the given options:\nA. $G'$ is the same graph as $G_{IS}$, and you should ask for a clique of size 18. This is incorrect. It would test if $G_{IS}$ itself has a clique of size 18, not an independent set.\nB. $G'$ is the complement of $G_{IS}$, and you should ask for a clique of size $75 - 18 = 57$. This is incorrect. The size of the clique in the complement graph is the same as the size of the independent set in the original graph. The size 57 relates to the vertex cover problem, not the independent set problem in this direct manner.\nC. $G'$ is the same graph as $G_{IS}$, and you should ask for a clique of size $75 - 18 = 57$. This is incorrect for two reasons: it uses the wrong graph and the wrong size.\nD. $G'$ is the complement of $G_{IS}$, and you should ask for a clique of size 18. This is the correct procedure. The graph to query is the complement of the original, and the size parameter remains the same as the desired independent set size.\nE. It is not possible to solve the INDEPENDENT-SET problem using a solver for the CLIQUE problem. This is incorrect, as we have just described a valid polynomial-time reduction.\n\nTherefore, the correct course of action is described in option D.", "answer": "$$\\boxed{D}$$", "id": "1395778"}, {"introduction": "Reductions are powerful because they reveal unexpected connections between seemingly disparate problems. This practice demonstrates how an abstract number theory problem, PARTITION, can be reduced to a concrete logistical problem, 2-PROCESSOR-SCHEDULING. By constructing this bridge, you will gain hands-on experience in proving a problem is NP-hard and appreciate how theoretical concepts of computation apply to practical challenges in resource management and optimization [@problem_id:1395769].", "problem": "In computational complexity theory, to prove that a problem $L_2$ is Nondeterministic Polynomial Time (NP)-hard, one can perform a polynomial-time reduction from a known NP-complete problem $L_1$ to $L_2$. This is denoted as $L_1 \\leq_p L_2$. This process involves creating a polynomial-time algorithm that transforms any instance of $L_1$ into an instance of $L_2$, such that the original instance is a \"yes\"-instance if and only if the transformed instance is also a \"yes\"-instance.\n\nConsider the following two decision problems:\n\n1.  **PARTITION**: Given a finite multiset $S = \\{s_1, s_2, \\dots, s_n\\}$ of positive integers, can $S$ be partitioned into two disjoint subsets, $S_A$ and $S_B$, such that the sum of the numbers in $S_A$ is equal to the sum of the numbers in $S_B$? The PARTITION problem is known to be NP-complete.\n\n2.  **2-PROCESSOR-SCHEDULING**: Given a set of $n$ jobs, each with a positive integer processing time $p_i$, and an overall deadline $D$, is it possible to assign these jobs to two identical processors such that all jobs are completed by time $D$? The completion time for a set of jobs on a single processor is the sum of their processing times. The overall completion time for the entire set of jobs, also known as the makespan, is the maximum of the completion times of the two processors.\n\nA computer scientist aims to demonstrate that 2-PROCESSOR-SCHEDULING is NP-hard by reducing PARTITION to it. Which one of the following statements correctly and completely describes the construction of a valid polynomial-time reduction?\n\nA. An instance of PARTITION with multiset $S = \\{s_1, \\dots, s_n\\}$ is transformed into an instance of 2-PROCESSOR-SCHEDULING with $n$ jobs having processing times $\\{s_1, \\dots, s_n\\}$ and a deadline $D = \\frac{1}{2} \\sum_{i=1}^{n} s_i$. A valid partition of $S$ exists if and only if a schedule meeting the deadline $D$ exists.\n\nB. An instance of 2-PROCESSOR-SCHEDULING with $n$ jobs having processing times $\\{p_1, \\dots, p_n\\}$ and a deadline $D$ is transformed into an instance of PARTITION with a multiset $S = \\{p_1, \\dots, p_n\\}$. A schedule meeting the deadline $D$ exists if and only if a valid partition of $S$ exists.\n\nC. An instance of PARTITION with multiset $S = \\{s_1, \\dots, s_n\\}$ is transformed into an instance of 2-PROCESSOR-SCHEDULING with $n$ jobs having processing times $\\{s_1, \\dots, s_n\\}$ and a deadline $D = \\sum_{i=1}^{n} s_i$. A valid partition of $S$ exists if and only if a schedule meeting the deadline $D$ exists.\n\nD. An instance of PARTITION with multiset $S = \\{s_1, \\dots, s_n\\}$ is transformed into an instance of 2-PROCESSOR-SCHEDULING with $n$ jobs having processing times $\\{s_1, \\dots, s_n\\}$ and a deadline $D = \\frac{1}{2} \\sum_{i=1}^{n} s_i$. A valid partition of $S$ exists if and only if a schedule meeting the deadline $D$ does *not* exist.\n\nE. An instance of PARTITION with multiset $S = \\{s_1, \\dots, s_n\\}$ is transformed into an instance of 2-PROCESSOR-SCHEDULING with two jobs having processing times $p_1 = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} s_i$ and $p_2 = \\sum_{i=\\lfloor n/2 \\rfloor+1}^{n} s_i$, and a deadline $D = \\frac{1}{2} \\sum_{i=1}^{n} s_i$. A valid partition of $S$ exists if and only if a schedule meeting the deadline $D$ exists.", "solution": "We reduce PARTITION to 2-PROCESSOR-SCHEDULING. Given an instance of PARTITION with multiset $S=\\{s_{1},\\dots,s_{n}\\}$ of positive integers, define the 2-PROCESSOR-SCHEDULING instance with $n$ jobs having processing times $p_{i}=s_{i}$ for $i\\in\\{1,\\dots,n\\}$ and deadline\n$$\nD=\\frac{1}{2}\\sum_{i=1}^{n}s_{i}.\n$$\nThis mapping is computable in time polynomial in $n$ because it only copies the list and computes a sum.\n\nTo prove correctness, let $T=\\sum_{i=1}^{n}s_{i}$ denote the total sum.\n\n(Only-if) Suppose there exists a valid partition $S=S_{A}\\cup S_{B}$ with $S_{A}\\cap S_{B}=\\varnothing$ and $\\sum_{s\\in S_{A}}s=\\sum_{s\\in S_{B}}s=\\frac{T}{2}$. Assign the jobs corresponding to $S_{A}$ to processor $1$ and those corresponding to $S_{B}$ to processor $2$. The completion times are $C_{1}=\\frac{T}{2}$ and $C_{2}=\\frac{T}{2}$, so the makespan is $\\max\\{C_{1},C_{2}\\}=\\frac{T}{2}=D$. Thus a schedule meeting the deadline $D$ exists.\n\n(If) Conversely, suppose there exists an assignment of jobs to the two processors that completes by time $D$, i.e., the makespan is at most $D$. Let $C_{1}$ and $C_{2}$ be the sums of processing times assigned to processors $1$ and $2$, respectively. By definition of makespan, $\\max\\{C_{1},C_{2}\\}\\leq D$. Since every job is assigned to exactly one processor,\n$$\nC_{1}+C_{2}=T=2D.\n$$\nBecause $C_{1}\\leq D$ and $C_{2}\\leq D$ while $C_{1}+C_{2}=2D$, it follows that $C_{1}=D$ and $C_{2}=D$. Therefore the sets of jobs on each processor form a partition of $S$ into two subsets of equal sum, yielding a valid partition.\n\nThus, a valid partition of $S$ exists if and only if there is a schedule meeting the deadline $D$. The reduction is polynomial-time, so this establishes NP-hardness. This construction is precisely described by option A. The other options fail because: B reduces in the wrong direction; C uses $D=T$, which is always achievable and does not reflect PARTITION; D reverses the truth condition; E collapses $n$ jobs to two aggregated jobs, losing the necessary combinatorial structure of PARTITION.", "answer": "$$\\boxed{A}$$", "id": "1395769"}, {"introduction": "What if you had a magic box that could instantly tell you *if* a solution exists, but not *what* the solution is? This final practice explores the powerful concept of self-reduction, where a decision oracle is used to solve a search problem. By designing an algorithm that uses a hypothetical SAT solver to find a satisfying assignment, you will uncover the profound relationship between decision and search problems and understand that for NP-complete problems, finding a solution is polynomially equivalent to deciding if one exists [@problem_id:1395818].", "problem": "Imagine you are an engineer at a vanguard technology firm that has just prototyped a revolutionary device: the \"SAT-Oracle\". This device can accept any Boolean formula in Conjunctive Normal Form (CNF) and, in polynomial time, determine whether it is satisfiable. The oracle's output is binary: it returns `1` if there exists at least one assignment of truth values to the variables that makes the entire formula true, and `0` otherwise. The oracle does **not**, however, provide a satisfying assignment itself.\n\nYour task is to design a high-level algorithm that serves as a software wrapper for this oracle. This algorithm must take any Boolean formula $\\phi$ in CNF with $n$ distinct variables ($x_1, x_2, \\dots, x_n$) as input. If $\\phi$ is satisfiable, your algorithm must output one complete satisfying truth assignment. If $\\phi$ is unsatisfiable, it should report that.\n\nConsidering an algorithm that is maximally efficient in terms of interactions with the expensive-to-use SAT-Oracle, what is the exact number of calls to the oracle required in the worst-case to either find a satisfying assignment or determine that none exists for a formula with $n$ variables?\n\nA. $n$\n\nB. $2n$\n\nC. $n+1$\n\nD. $n^2$\n\nE. $2^n$\n\nF. $1$", "solution": "The problem asks for an algorithm that uses a decision oracle for the Boolean Satisfiability (SAT) problem to find a satisfying assignment (a search problem). This is a classic example of a self-reduction. Let the given Boolean formula be $\\phi$ with variables $\\{x_1, x_2, \\dots, x_n\\}$. The oracle, let's call it `is_SAT(formula)`, returns `1` if `formula` is satisfiable and `0` otherwise.\n\nOur algorithm must handle two possibilities: the input formula $\\phi$ might be satisfiable or unsatisfiable.\n\n**Step 1: Initial Satisfiability Check**\nFirst, we must determine if a solution even exists. We make our first call to the oracle with the original formula $\\phi$.\n$$ \\text{Call 1: } \\text{is\\_SAT}(\\phi) $$\nIf `is_SAT}(\\phi)` returns `0`, we know the formula is unsatisfiable. The algorithm can immediately terminate and report this fact. This scenario uses just one oracle call.\n\nIf `is_SAT}(\\phi)` returns `1`, we know the formula is satisfiable, and we must proceed to find an assignment. This branch of the algorithm will represent the worst-case in terms of the number of calls.\n\n**Step 2: Iteratively Determine Variable Assignments**\nNow that we know a satisfying assignment exists, we can determine the value of each variable, one by one, from $x_1$ to $x_n$.\n\nLet's start with variable $x_1$. We want to know if there is a satisfying assignment where $x_1$ is true. To test this, we create a new formula, $\\phi_1$, by conjoining $\\phi$ with the literal $x_1$. In CNF, this is equivalent to adding a new clause `(x_1)` to the formula $\\phi$.\n$$ \\phi_1 = \\phi \\land x_1 $$\nWe then ask the oracle if this new formula is satisfiable.\n$$ \\text{Call 2: } \\text{is\\_SAT}(\\phi_1) $$\n\nThere are two possible outcomes:\n- If `is_SAT}(\\phi_1)` returns `1`: This means there exists a satisfying assignment for $\\phi$ where $x_1 = \\text{true}$. We can commit to this assignment. We fix $x_1 = \\text{true}$ and update our working formula to $\\phi_1$. The problem is now reduced to finding a satisfying assignment for the remaining variables in the context of $\\phi_1$.\n- If `is_SAT}(\\phi_1)` returns `0`: This means there is no satisfying assignment for $\\phi$ where $x_1 = \\text{true}$. Since we know from Step 1 that $\\phi$ *is* satisfiable, it logically follows that in *every* satisfying assignment of $\\phi$, $x_1$ must be `false`. We therefore fix $x_1 = \\text{false}$ and update our working formula to $\\phi_0 = \\phi \\land \\neg x_1$. We know for certain that $\\phi_0$ is satisfiable.\n\nIn either case, a single oracle call was sufficient to determine the correct truth value for $x_1$.\n\n**Step 3: Generalization and Repetition**\nWe repeat this process for the remaining variables. For the second variable, $x_2$, we take our current working formula (which is either $\\phi_1$ or $\\phi_0$ from the previous step, let's call it $\\phi'$) and test the assignment $x_2 = \\text{true}$. We form $\\phi'' = \\phi' \\land x_2$ and make our next oracle call.\n$$ \\text{Call 3: } \\text{is\\_SAT}(\\phi'') $$\nBased on the result, we fix the value of $x_2$ and update the working formula again.\n\nWe continue this for all $n$ variables, from $x_1$ to $x_n$. For each variable $x_i$, we perform exactly one oracle call to decide its value.\n\n**Step 4: Counting the Calls**\nLet's tally the total number of oracle calls for the worst-case scenario (which is when the formula is satisfiable):\n- One initial call to check the satisfiability of the original formula $\\phi$.\n- One call for each of the $n$ variables to determine its truth value.\n\nTotal calls = $1 \\text{ (for the initial check)} + n \\text{ (one for each variable)} = n+1$.\n\nAfter $n+1$ calls, we will have determined the truth values for all variables $x_1, \\dots, x_n$ that form a satisfying assignment. This is the worst-case number of calls, as the case of an unsatisfiable formula takes only 1 call. Therefore, the tightest upper bound on the number of calls required is $n+1$.", "answer": "$$\\boxed{C}$$", "id": "1395818"}]}