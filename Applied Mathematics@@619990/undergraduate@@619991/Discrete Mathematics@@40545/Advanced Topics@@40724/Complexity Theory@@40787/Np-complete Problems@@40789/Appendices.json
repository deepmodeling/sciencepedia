{"hands_on_practices": [{"introduction": "Before exploring the immense challenge of *finding* a solution to a 3-Satisfiability (3-SAT) problem, we must first master the fundamental task of *verifying* one. This exercise provides a direct, hands-on opportunity to evaluate a given truth assignment against a specific 3-CNF formula. By stepping through each clause, you will build a concrete understanding of what it means for a clause, and an entire formula, to be satisfied.", "problem": "In computational complexity theory, the Boolean Satisfiability Problem (SAT) is a foundational problem. A common variant is 3-Satisfiability (3-SAT). A boolean formula is in 3-Conjunctive Normal Form (3-CNF) if it is a conjunction of clauses, where each clause is a disjunction of exactly three literals. A literal is a boolean variable or its negation. We use the symbol $\\land$ to denote logical AND (conjunction), $\\lor$ to denote logical OR (disjunction), and $\\neg$ to denote logical NOT (negation).\n\nConsider a 3-CNF formula $\\phi$ defined over a set of four boolean variables $\\{x_1, x_2, x_3, x_4\\}$. The formula $\\phi$ is given by the conjunction of the following five clauses:\n$C_1 = (\\neg x_1 \\lor x_2 \\lor \\neg x_3)$\n$C_2 = (\\neg x_1 \\lor x_2 \\lor x_4)$\n$C_3 = (x_1 \\lor x_2 \\lor x_3)$\n$C_4 = (\\neg x_2 \\lor \\neg x_3 \\lor x_4)$\n$C_5 = (x_3 \\lor \\neg x_4 \\lor x_2)$\n\nSo, the full formula is $\\phi = C_1 \\land C_2 \\land C_3 \\land C_4 \\land C_5$.\n\nA clause is said to be satisfied by a truth assignment if at least one of its literals evaluates to True under that assignment. The entire formula $\\phi$ is satisfied only if all its clauses are satisfied.\n\nYou are given the following truth assignment $A$:\n$x_1 = \\text{True}$\n$x_2 = \\text{False}$\n$x_3 = \\text{True}$\n$x_4 = \\text{False}$\n\nDetermine the total number of clauses in the formula $\\phi$ that are satisfied by the truth assignment $A$.", "solution": "A clause in a 3-CNF formula is satisfied if at least one of its literals evaluates to $\\text{True}$. The logical disjunction $\\lor$ evaluates to $\\text{True}$ if at least one operand is $\\text{True}$, and the negation satisfies $\\neg \\text{True}=\\text{False}$ and $\\neg \\text{False}=\\text{True}$. Under the assignment $A$ with $x_{1}=\\text{True}$, $x_{2}=\\text{False}$, $x_{3}=\\text{True}$, $x_{4}=\\text{False}$, we first compute the needed negations: $\\neg x_{1}=\\text{False}$, $\\neg x_{2}=\\text{True}$, $\\neg x_{3}=\\text{False}$, $\\neg x_{4}=\\text{True}$.\n\nEvaluate each clause:\n$$C_{1}=(\\neg x_{1}\\lor x_{2}\\lor \\neg x_{3})=(\\text{False}\\lor \\text{False}\\lor \\text{False})=\\text{False},$$\n$$C_{2}=(\\neg x_{1}\\lor x_{2}\\lor x_{4})=(\\text{False}\\lor \\text{False}\\lor \\text{False})=\\text{False},$$\n$$C_{3}=(x_{1}\\lor x_{2}\\lor x_{3})=(\\text{True}\\lor \\text{False}\\lor \\text{True})=\\text{True},$$\n$$C_{4}=(\\neg x_{2}\\lor \\neg x_{3}\\lor x_{4})=(\\text{True}\\lor \\text{False}\\lor \\text{False})=\\text{True},$$\n$$C_{5}=(x_{3}\\lor \\neg x_{4}\\lor x_{2})=(\\text{True}\\lor \\text{True}\\lor \\text{False})=\\text{True}.$$\n\nThus, exactly three clauses, $C_{3}$, $C_{4}$, and $C_{5}$, are satisfied by $A$.", "answer": "$$\\boxed{3}$$", "id": "1410968"}, {"introduction": "The 3-SAT problem serves as a cornerstone for proving that other problems are computationally hard. A key technique in these proofs is the polynomial-time reduction, which often involves transforming an instance of another problem into an equivalent 3-SAT instance. This practice [@problem_id:1410930] gives you hands-on experience with this crucial step, showing how to convert a clause with more than three literals into a set of 3-literal clauses that are satisfiable if and only if the original clause was.", "problem": "In a computational complexity theory course, a student named Alex is studying the proof that 3-Satisfiability (3-SAT) is NP-complete. A key step in many related proofs is the reduction of a general k-Satisfiability problem to 3-SAT. This involves converting any clause with more than 3 literals into a set of clauses each having at most 3 literals, while preserving satisfiability.\n\nAlex considers a specific clause of size 4, $C = (x_1 \\lor x_2 \\lor x_3 \\lor \\neg x_4)$, where $x_1, x_2, x_3, x_4$ are Boolean variables. A literal is a variable or its negation. A clause is a disjunction (OR) of literals. A formula in Conjunctive Normal Form (CNF) is a conjunction (AND) of clauses. A formula is in 3-CNF if it is in CNF and every clause has exactly 3 literals.\n\nThe task is to find a new formula, $C'$, which is a conjunction of 3-literal clauses, such that $C'$ is satisfiable if and only if the original clause $C$ is satisfiable. This transformation can be achieved by introducing a new auxiliary Boolean variable, let's call it $z_1$.\n\nWhich of the following formulas is a correct transformation of $C$ into an equisatisfiable formula in CNF where each clause has 3 literals? Select all that apply.\n\nA. $(x_1 \\lor x_2 \\lor z_1) \\land (\\neg z_1 \\lor x_3 \\lor \\neg x_4)$\n\nB. $(x_1 \\lor x_2 \\lor z_1) \\land (\\neg z_1 \\lor x_3 \\lor x_4)$\n\nC. $(x_1 \\lor x_2 \\lor \\neg z_1) \\land (z_1 \\lor x_3 \\lor \\neg x_4)$\n\nD. $(x_1 \\lor z_1 \\lor \\neg z_1) \\land (x_2 \\lor x_3 \\lor \\neg x_4)$", "solution": "We need a 3-CNF formula $C'$ using a fresh variable $z_{1}$ such that, for every fixed assignment to the original variables $(x_{1},x_{2},x_{3},x_{4})$, the original clause $C=(x_{1}\\lor x_{2}\\lor x_{3}\\lor \\neg x_{4})$ is true if and only if there exists an assignment to $z_{1}$ making $C'$ true. This is the equisatisfiability condition required in standard reductions from $k$-SAT to $3$-SAT.\n\nWe verify each option.\n\nOption A: $C'=(x_{1}\\lor x_{2}\\lor z_{1})\\land(\\neg z_{1}\\lor x_{3}\\lor \\neg x_{4})$.\n- If $C$ is true:\n  - If $(x_{1}\\lor x_{2})$ is true, set $z_{1}=0$. Then the first clause becomes $(x_{1}\\lor x_{2}\\lor 0)=(x_{1}\\lor x_{2})$, which is true, and the second clause becomes $(1\\lor x_{3}\\lor \\neg x_{4})$, which is true.\n  - If $(x_{1}\\lor x_{2})$ is false, then $(x_{3}\\lor \\neg x_{4})$ must be true. Set $z_{1}=1$. Then the first clause becomes $(x_{1}\\lor x_{2}\\lor 1)$, which is true, and the second clause becomes $(0\\lor x_{3}\\lor \\neg x_{4})=(x_{3}\\lor \\neg x_{4})$, which is true.\n  Hence if $C$ is true, there exists $z_{1}$ such that $C'$ is true.\n- Conversely, if $C'$ is true for some $z_{1}$:\n  - If $z_{1}=0$, then the first clause is $(x_{1}\\lor x_{2})$, so $(x_{1}\\lor x_{2})$ is true and $C$ is true.\n  - If $z_{1}=1$, then the second clause is $(x_{3}\\lor \\neg x_{4})$, so $(x_{3}\\lor \\neg x_{4})$ is true and $C$ is true.\nThus A is a correct equisatisfiable transformation.\n\nOption B: $C'=(x_{1}\\lor x_{2}\\lor z_{1})\\land(\\neg z_{1}\\lor x_{3}\\lor x_{4})$.\nConsider the assignment $x_{1}=0$, $x_{2}=0$, $x_{3}=0$, $x_{4}=1$. Then $C=(0\\lor 0\\lor 0\\lor 0)=0$. But $C'$ becomes $(0\\lor 0\\lor z_{1})\\land(\\neg z_{1}\\lor 0\\lor 1)=z_{1}\\land 1$, which is true by choosing $z_{1}=1$. Hence $C$ is false while $C'$ is satisfiable, so B is not equisatisfiable with $C$.\n\nOption C: $C'=(x_{1}\\lor x_{2}\\lor \\neg z_{1})\\land(z_{1}\\lor x_{3}\\lor \\neg x_{4})$.\n- If $C$ is true:\n  - If $(x_{1}\\lor x_{2})$ is true, set $z_{1}=1$. Then the first clause is $(x_{1}\\lor x_{2}\\lor 0)=(x_{1}\\lor x_{2})$, true, and the second clause is $(1\\lor x_{3}\\lor \\neg x_{4})$, true.\n  - If $(x_{1}\\lor x_{2})$ is false, then $(x_{3}\\lor \\neg x_{4})$ must be true. Set $z_{1}=0$. Then the first clause is $(x_{1}\\lor x_{2}\\lor 1)$, true, and the second clause is $(0\\lor x_{3}\\lor \\neg x_{4})=(x_{3}\\lor \\neg x_{4})$, true.\n  Hence if $C$ is true, there exists $z_{1}$ such that $C'$ is true.\n- Conversely, if $C'$ is true for some $z_{1}$:\n  - If $z_{1}=1$, then the first clause reduces to $(x_{1}\\lor x_{2})$, so $C$ is true.\n  - If $z_{1}=0$, then the second clause reduces to $(x_{3}\\lor \\neg x_{4})$, so $C$ is true.\nThus C is a correct equisatisfiable transformation.\n\nOption D: $C'=(x_{1}\\lor z_{1}\\lor \\neg z_{1})\\land(x_{2}\\lor x_{3}\\lor \\neg x_{4})$.\nThe first clause is a tautology since $(z_{1}\\lor \\neg z_{1})$ is always true, so $C'$ is equivalent to $(x_{2}\\lor x_{3}\\lor \\neg x_{4})$. Take $x_{1}=1$, $x_{2}=0$, $x_{3}=0$, $x_{4}=1$. Then $C=(1\\lor 0\\lor 0\\lor 0)=1$, but $C'=(0\\lor 0\\lor 0)=0$, regardless of $z_{1}$. Hence D is not equisatisfiable with $C$.\n\nTherefore, exactly options A and C are correct.", "answer": "$$\\boxed{AC}$$", "id": "1410930"}, {"introduction": "Understanding how to construct a reduction, as practiced in the previous exercise [@problem_id:1410930], is only half the battle; knowing how to apply it correctly is critical. This problem presents a common logical pitfall in NP-completeness proofs where a reduction is performed in the wrong direction. By analyzing the analyst's mistake, you will solidify your understanding of the precise logic required to prove a problem is NP-hard: reducing a known NP-complete problem *to* the new problem in question.", "problem": "A political consulting firm is analyzing the computational complexity of two key strategic planning problems: Campaign Staffing (CS) and Message Control (MC).\n\nThe **Campaign Staffing (CS)** problem is defined as follows:\n- Given a set $P$ of $n$ potential campaign projects, a list $C$ of pairs of projects that are incompatible with each other, and an integer $k$.\n- Question: Is it possible to select a subset of projects $P' \\subseteq P$ of size at least $k$ such that no two projects in $P'$ are incompatible?\n\nThe **Message Control (MC)** problem is defined as follows:\n- Given a set $T$ of topics for a political debate, a list $L$ of \"risky pairs\" of topics, and an integer $j$.\n- Question: Is it possible to select a subset of topics $T' \\subseteq T$ of size at most $j$ such that for every risky pair in $L$, at least one of the topics in the pair is a member of $T'$?\n\nThe firm's lead theoretician has already established that the Message Control (MC) problem is NP-complete.\n\nA junior analyst is tasked with determining the complexity of the Campaign Staffing (CS) problem. The analyst claims that CS is also NP-complete. To justify this, they propose the following polynomial-time transformation from an arbitrary instance of CS to an instance of MC:\n\n1.  Given a CS instance with $n$ projects $P$, incompatibilities $C$, and an integer $k$.\n2.  Create an MC instance where the set of topics $T$ is identical to the set of projects $P$.\n3.  The list of risky pairs $L$ is identical to the list of incompatibilities $C$.\n4.  The integer for the MC instance is set to $j = n - k$.\n\nThe analyst correctly argues that the original CS instance has a \"yes\" answer if and only if this newly constructed MC instance also has a \"yes\" answer. Based on this transformation, the analyst concludes their proof is complete.\n\nAssuming the analyst's argument for the equivalence of the solutions is correct, which of the following statements accurately describes the analyst's contribution?\n\nA. The analyst has correctly proven that CS is NP-complete.\n\nB. The analyst has proven that CS is in NP, but not that it is NP-hard.\n\nC. The analyst has proven that if CS is in NP, then CS is NP-complete.\n\nD. The analyst has shown a reduction in the wrong direction; this transformation does not help prove that CS is NP-complete.\n\nE. The analyst has proven that CS can be solved in polynomial time.", "solution": "To determine the validity of the analyst's conclusion, we must understand the requirements for proving a problem is NP-complete. A problem $X$ is NP-complete if it satisfies two conditions:\n1.  $X$ is in the complexity class NP (Nondeterministic Polynomial time). This means that a proposed solution to an instance of $X$ can be verified for correctness in polynomial time.\n2.  $X$ is NP-hard. This means that every problem in NP can be reduced to $X$ in polynomial time.\n\nIn practice, to prove a problem $X$ is NP-hard, we don't reduce every problem in NP to it. Instead, we take a single, known NP-complete problem, let's call it $Y$, and show that $Y$ can be reduced to $X$ in polynomial time. This is denoted as $Y \\le_p X$. A polynomial-time reduction from $Y$ to $X$ is an algorithm that transforms any instance of $Y$ into an instance of $X$ in polynomial time, such that the original $Y$ instance is a \"yes\" instance if and only if the transformed $X$ instance is a \"yes\" instance. This shows that $X$ is at least as hard as $Y$. Since $Y$ is NP-hard (hard for all of NP), $X$ must also be NP-hard.\n\nIn this problem, the two problems are Campaign Staffing (CS) and Message Control (MC). We are given that MC is NP-complete. The analyst wants to prove that CS is NP-complete. To do this, they would need to show that:\n1.  CS is in NP.\n2.  CS is NP-hard.\n\nTo prove CS is NP-hard, the analyst should have taken the known NP-complete problem, MC, and shown a reduction MC $\\le_p$ CS.\n\nHowever, the analyst did the opposite. They created a reduction from CS to MC, which is written as CS $\\le_p$ MC. The analyst showed that any instance of CS can be transformed into an instance of MC in polynomial time.\n\nWhat does the reduction CS $\\le_p$ MC tell us? It means that if we had a polynomial-time algorithm to solve MC, we could use it to solve CS in polynomial time. Since MC is NP-complete, it is believed that no such polynomial-time algorithm exists. This reduction places an upper bound on the difficulty of CS relative to MC; it shows that CS is \"no harder than\" MC. It does not provide a lower bound on the difficulty of CS. Proving NP-hardness requires showing that a problem is at least as hard as a known NP-hard problem.\n\nTherefore, the analyst's reduction is in the \"wrong direction\" for the purpose of proving that CS is NP-hard. The transformation they constructed does not contribute to a proof of the NP-completeness of CS.\n\nLet's evaluate the given options:\nA. The analyst has correctly proven that CS is NP-complete. This is false. The reduction is in the wrong direction to prove NP-hardness.\nB. The analyst has proven that CS is in NP, but not that it is NP-hard. The analyst's transformation does not address whether CS is in NP. (Note: CS *is* in NP because one can easily check if a given set of $k$ projects has any incompatibilities, but the analyst's work did not demonstrate this fact). The work also fails to prove NP-hardness.\nC. The analyst has proven that if CS is in NP, then CS is NP-complete. This is false. To be NP-complete, CS must also be proven NP-hard, which the analyst has not done.\nD. The analyst has shown a reduction in the wrong direction; this transformation does not help prove that CS is NP-complete. This is the correct statement. To prove CS is NP-complete, the analyst needed to reduce a known NP-complete problem *to* CS (e.g., MC $\\le_p$ CS), not the other way around.\nE. The analyst has proven that CS can be solved in polynomial time. This is false. The reduction only implies that CS is solvable in polynomial time *if* MC is, which is strongly believed to be false.\n\nThe analyst's fundamental error is misunderstanding the directionality of reductions required for NP-hardness proofs.", "answer": "$$\\boxed{D}$$", "id": "1388452"}]}