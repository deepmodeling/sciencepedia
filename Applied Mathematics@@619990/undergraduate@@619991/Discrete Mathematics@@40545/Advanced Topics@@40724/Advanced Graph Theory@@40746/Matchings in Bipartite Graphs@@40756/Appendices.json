{"hands_on_practices": [{"introduction": "Many real-world allocation puzzles, such as assigning jobs to applicants or students to dorm rooms, can be modeled as matching problems in bipartite graphs. Before attempting to create a perfect assignment, it's crucial to know if one is even possible. This practice applies Hall's Marriage Theorem, a cornerstone result that provides a clear-cut condition for the existence of a perfect matching, allowing you to identify the specific bottleneck preventing a full assignment. [@problem_id:1382813]", "problem": "A university housing department is assigning five students from the Lavender group to five single rooms in the Gold dorm. A student can only be assigned to a room they have listed as acceptable. The housing department wants to find a \"perfect matching\" where each of the five students is assigned to a unique acceptable room.\n\nThe five students in the Lavender group are {Amy, Brian, Chloe, David, Emily}. Let this set be $L$.\nThe five available rooms in the Gold dorm are {G-101, G-102, G-103, G-104, G-105}.\n\nThe list of acceptable rooms for each student is as follows:\n- **Amy:** {G-103, G-104}\n- **Brian:** {G-101, G-102}\n- **Chloe:** {G-104, G-105}\n- **David:** {G-101}\n- **Emily:** {G-102}\n\nA perfect matching of students to rooms is not possible. According to Hall's Marriage Theorem, this impossibility can be demonstrated by finding a subset of students $S \\subseteq L$ for which the number of unique rooms they are collectively willing to occupy is smaller than the number of students in the subset. If we let $N(S)$ be the set of all rooms acceptable to at least one student in $S$, this condition is written as $|N(S)| < |S|$.\n\nWhich of the following subsets $S$ of students from the Lavender group satisfies the condition $|N(S)| < |S|$?\n\nA. $S = \\{\\text{Amy, Chloe}\\}$\n\nB. $S = \\{\\text{Brian, David, Emily}\\}$\n\nC. $S = \\{\\text{Amy, Brian, Chloe}\\}$\n\nD. $S = \\{\\text{David, Emily}\\}$\n\nE. $S = \\{\\text{Amy, David}\\}$", "solution": "We are given the student set $L=\\{\\text{Amy, Brian, Chloe, David, Emily}\\}$ and the room set $\\{\\text{G-101, G-102, G-103, G-104, G-105}\\}$. For each subset $S \\subseteq L$, let $N(S)$ denote the union of acceptable rooms for the students in $S$. By Hall's Marriage Theorem, a perfect matching is impossible if there exists some $S$ with $|N(S)|<|S|$. We check each listed option.\n\nFor option A, $S=\\{\\text{Amy, Chloe}\\}$. The acceptable rooms are:\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-104, G-105}\\}=\\{\\text{G-103, G-104, G-105}\\}.$$\nThus $|S|=2$ and $|N(S)|=3$, so $|N(S)|\\not<|S|$.\n\nFor option B, $S=\\{\\text{Brian, David, Emily}\\}$. The acceptable rooms are:\n$$N(S)=\\{\\text{G-101, G-102}\\}\\cup\\{\\text{G-101}\\}\\cup\\{\\text{G-102}\\}=\\{\\text{G-101, G-102}\\}.$$\nThus $|S|=3$ and $|N(S)|=2$, so $|N(S)|<|S|$. This satisfies Hall's condition for impossibility.\n\nFor option C, $S=\\{\\text{Amy, Brian, Chloe}\\}$. The acceptable rooms are:\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-101, G-102}\\}\\cup\\{\\text{G-104, G-105}\\}=\\{\\text{G-101, G-102, G-103, G-104, G-105}\\}.$$\nThus $|S|=3$ and $|N(S)|=5$, so $|N(S)|\\not<|S|$.\n\nFor option D, $S=\\{\\text{David, Emily}\\}$. The acceptable rooms are:\n$$N(S)=\\{\\text{G-101}\\}\\cup\\{\\text{G-102}\\}=\\{\\text{G-101, G-102}\\}.$$\nThus $|S|=2$ and $|N(S)|=2$, so $|N(S)|\\not<|S|$.\n\nFor option E, $S=\\{\\text{Amy, David}\\}$. The acceptable rooms are:\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-101}\\}=\\{\\text{G-101, G-103, G-104}\\}.$$\nThus $|S|=2$ and $|N(S)|=3$, so $|N(S)|\\not<|S|$.\n\nTherefore, the only subset among the options that satisfies $|N(S)|<|S|$ is option B.", "answer": "$$\\boxed{B}$$", "id": "1382813"}, {"introduction": "Once we know a matching might exist, how do we systematically find the largest one? The most fundamental method is the augmenting path algorithm, which iteratively grows a matching by finding specific alternating paths. This hands-on exercise guides you through the core steps of this algorithm, offering a concrete visualization of how a matching is constructed and improved, building intuition for one of the most powerful tools in graph theory. [@problem_id:1520050]", "problem": "Consider a bipartite graph $G = (U \\cup V, E)$, where the vertex partitions are $U = \\{u_1, u_2, u_3, u_4\\}$ and $V = \\{v_1, v_2, v_3, v_4\\}$. The set of edges $E$ is given by $\\{(u_1, v_1), (u_1, v_2), (u_1, v_3), (u_2, v_1), (u_3, v_1)\\}$.\n\nAn augmenting path algorithm is used to find a maximum matching by starting with an empty matching, $M_0 = \\emptyset$, and iteratively increasing its size. In each iteration, an augmenting path with respect to the current matching is found, and the matching is updated by taking the symmetric difference between the matching and the path.\n\nYou are to perform exactly two iterations of this algorithm. The rules for selecting an augmenting path at each step are as follows:\n1.  The path must have the minimum possible number of edges (i.e., it must be a shortest augmenting path).\n2.  If multiple shortest augmenting paths exist, you must choose the one that is lexicographically smallest. A path is represented by its sequence of vertices, e.g., $(w_0, w_1, \\dots, w_k)$. Paths are compared element-wise based on the vertex ordering $u_1 < u_2 < u_3 < u_4 < v_1 < v_2 < v_3 < v_4$.\n\nStarting with the empty matching $M_0$, determine the first augmenting path $P_1$ according to the rules to create a new matching $M_1 = M_0 \\oplus P_1$. Then, with respect to $M_1$, find the second augmenting path $P_2$ to create the final matching $M_2 = M_1 \\oplus P_2$.\n\nWhich of the following sets of edges represents the final matching $M_2$?\n\nA. $\\{(u_1, v_1), (u_2, v_1)\\}$\n\nB. $\\{(u_1, v_1)\\}$\n\nC. $\\{(u_1, v_2), (u_2, v_1)\\}$\n\nD. $\\{(u_1, v_3), (u_2, v_1)\\}$\n\nE. $\\{(u_1, v_2), (u_3, v_1)\\}$", "solution": "We work in the bipartite graph $G=(U\\cup V,E)$ with $U=\\{u_{1},u_{2},u_{3},u_{4}\\}$, $V=\\{v_{1},v_{2},v_{3},v_{4}\\}$, and $E=\\{(u_{1},v_{1}), (u_{1},v_{2}), (u_{1},v_{3}), (u_{2},v_{1}), (u_{3},v_{1})\\}$. An augmenting path with respect to a matching $M$ is an alternating path that starts and ends at free vertices and whose first and last edges are not in $M$. The algorithm updates via the symmetric difference: if $P$ is an augmenting path, then $M\\oplus P$ flips the matched status of exactly the edges on $P$.\n\nIteration 1 starts with $M_{0}=\\emptyset$. Every edge is unmatched and both endpoints are free, so every single edge is an augmenting path of length $1$, which is the minimum possible. Among all length-$1$ paths, we pick the lexicographically smallest by the given order $u_{1}<u_{2}<u_{3}<u_{4}<v_{1}<v_{2}<v_{3}<v_{4}$. The candidate paths are $(u_{1},v_{1})$, $(u_{1},v_{2})$, $(u_{1},v_{3})$, $(u_{2},v_{1})$, $(u_{3},v_{1})$. Comparing sequences, the smallest is $(u_{1},v_{1})$. Thus $P_{1}=(u_{1},v_{1})$ and\n$$\nM_{1}=M_{0}\\oplus P_{1}=\\{(u_{1},v_{1})\\}.\n$$\n\nIteration 2 proceeds with respect to $M_{1}=\\{(u_{1},v_{1})\\}$. The free vertices are $u_{2},u_{3},u_{4}$ in $U$ and $v_{2},v_{3},v_{4}$ in $V$. There is no augmenting path of length $1$ because any single edge must connect two free vertices; the only edges present touch either $u_{1}$ or $v_{1}$, which are matched. Therefore the shortest augmenting paths have length $3$ (since augmenting paths have odd length). From $u_{2}$, following unmatched then matched then unmatched edges yields two candidates:\n$$\n(u_{2},v_{1},u_{1},v_{2}),\\quad (u_{2},v_{1},u_{1},v_{3}),\n$$\nsince $(u_{2},v_{1})$ is unmatched, $(v_{1},u_{1})$ is matched, and from $u_{1}$ the unmatched neighbors are $v_{2}$ and $v_{3}$, both free. Similarly from $u_{3}$ we obtain $(u_{3},v_{1},u_{1},v_{2})$ and $(u_{3},v_{1},u_{1},v_{3})$, and starting at free $v_{2}$ or $v_{3}$ yields symmetric paths beginning with $v_{2}$ or $v_{3}$. Among all these length-$3$ paths, we choose the lexicographically smallest: comparing first vertices, $u_{2}$ is smallest among $u_{2},u_{3},v_{2},v_{3}$, and between the two starting with $u_{2}$ we compare the last vertex $v_{2}$ versus $v_{3}$, giving $(u_{2},v_{1},u_{1},v_{2})$ as the lexicographically smallest. Hence $P_{2}=(u_{2},v_{1},u_{1},v_{2})$.\n\nWe update the matching by symmetric difference with $P_{2}$. The edges of $P_{2}$ are $(u_{2},v_{1})$, $(u_{1},v_{1})$, $(u_{1},v_{2})$. Flipping these relative to $M_{1}=\\{(u_{1},v_{1})\\}$ removes $(u_{1},v_{1})$ and adds $(u_{2},v_{1})$ and $(u_{1},v_{2})$. Therefore\n$$\nM_{2}=M_{1}\\oplus P_{2}=\\{(u_{1},v_{2}),\\,(u_{2},v_{1})\\},\n$$\nwhich corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1520050"}, {"introduction": "While augmenting path algorithms guarantee an optimal solution, one might wonder if simpler, \"greedy\" strategies could perform almost as well. This problem delves into the crucial field of algorithmic analysis by asking you to evaluate the performance of a simple greedy assignment strategy against the best possible outcome. By analyzing its worst-case performance, you will gain a deeper appreciation for why sophisticated algorithms are often necessary and understand the concept of an approximation ratio. [@problem_id:1520052]", "problem": "In a large-scale distributed computing environment, a resource manager needs to assign tasks to processing nodes. For a given integer parameter $k \\ge 1$, the system consists of two sets of nodes: a set of $2k$ \"provider\" nodes $A$ and a set of $2k$ \"requester\" nodes $B$. The nodes are grouped into $k$ independent clusters, indexed from $1$ to $k$. For each index $i \\in \\{1, \\ldots, k\\}$, cluster $i$ consists of two provider nodes, $\\{a_{i,1}, a_{i,2}\\}$, and two requester nodes, $\\{b_{i,1}, b_{i,2}\\}$.\n\nThe compatibility between providers and requesters within any cluster $i$ is defined as follows, forming a bipartite graph:\n1.  **Direct Links**: Node $a_{i,1}$ can serve node $b_{i,1}$, and node $a_{i,2}$ can serve node $b_{i,2}$. These form the set of direct links.\n2.  **Backup Link**: Node $a_{i,1}$ can also serve node $b_{i,2}$. This forms the set of backup links.\nThere are no other compatibilities; specifically, nodes from different clusters cannot be connected.\n\nThe system uses a simple, deterministic greedy algorithm for assignment. The algorithm prioritizes backup links over direct links. It operates in two sequential phases:\n- **Phase 1**: The algorithm iterates through all possible backup links in the entire system. For each backup link $(u, v)$ it considers, if both node $u$ and node $v$ are currently unassigned, it assigns them to each other.\n- **Phase 2**: After completing Phase 1, the algorithm iterates through all possible direct links. For each direct link $(u, v)$ it considers, if both node $u$ and node $v$ are currently unassigned, it assigns them to each other.\n\nThe order of consideration of links within each phase does not affect the outcome for this specific system architecture. Let $N_{greedy}(k)$ be the total number of assignments made by this greedy algorithm, and let $N_{opt}(k)$ be the maximum possible number of assignments (the size of a maximum matching) for the system.\n\nDetermine the performance ratio $\\frac{N_{opt}(k)}{N_{greedy}(k)}$ for this system. The result is a constant value independent of $k$.", "solution": "The problem asks for the performance ratio of a specific greedy matching algorithm against an optimal matching on a specially constructed family of bipartite graphs. Let's analyze the number of assignments made by the greedy algorithm, $N_{greedy}(k)$, and the maximum possible number of assignments, $N_{opt}(k)$.\n\nFirst, let's formally define the bipartite graph $G_k = (L_k \\cup R_k, E_k)$ for a given $k \\ge 1$.\nThe two partitions of vertices are the provider nodes and requester nodes:\n$L_k = \\bigcup_{i=1}^{k} \\{a_{i,1}, a_{i,2}\\}$\n$R_k = \\bigcup_{i=1}^{k} \\{b_{i,1}, b_{i,2}\\}$\nThe size of each partition is $|L_k| = |R_k| = 2k$.\n\nThe edge set $E_k$ is composed of direct links and backup links.\nThe set of backup links is $E_{backup} = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$.\nThe set of direct links is $E_{direct} = \\{ (a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}) \\mid i=1, \\ldots, k \\}$.\nThe total edge set is $E_k = E_{backup} \\cup E_{direct}$. The graph consists of $k$ disjoint identical components, one for each index $i$.\n\n**Step 1: Calculate the size of the greedy matching, $N_{greedy}(k)$.**\nThe greedy algorithm proceeds in two phases. Let $M_G$ denote the matching constructed by the algorithm.\n\n**Phase 1: Process Backup Links**\nThe algorithm considers all edges in $E_{backup}$. Let's consider the edge $(a_{i,1}, b_{i,2})$ for an arbitrary cluster $i$. Initially, all nodes are unassigned. Since the clusters are disjoint, the assignment within one cluster does not affect the initial state of another.\nFor each $i \\in \\{1, \\ldots, k\\}$, the algorithm considers the backup link $(a_{i,1}, b_{i,2})$. Both nodes $a_{i,1}$ and $b_{i,2}$ are unassigned, so this edge is added to the matching $M_G$. This happens for every cluster $i$.\nAfter Phase 1 is complete, the matching consists of all backup links:\n$M_G = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$.\nAt this point, the size of the matching is $k$.\nThe set of assigned nodes are:\n- From partition $L_k$: $\\{a_{1,1}, a_{2,1}, \\ldots, a_{k,1}\\}$\n- From partition $R_k$: $\\{b_{1,2}, b_{2,2}, \\ldots, b_{k,2}\\}$\n\n**Phase 2: Process Direct Links**\nThe algorithm now considers all edges in $E_{direct}$. An edge can only be added if both its endpoints are unassigned.\nThe direct links are of two types for each cluster $i$: $(a_{i,1}, b_{i,1})$ and $(a_{i,2}, b_{i,2})$.\n- For the link $(a_{i,1}, b_{i,1})$: The node $a_{i,1}$ was already assigned in Phase 1 to $b_{i,2}$. Therefore, this link cannot be added to the matching.\n- For the link $(a_{i,2}, b_{i,2})$: The node $b_{i,2}$ was already assigned in Phase 1 to $a_{i,1}$. Therefore, this link cannot be added to the matching.\nThis holds true for all $i \\in \\{1, \\ldots, k\\}$. Thus, no new edges are added to the matching in Phase 2.\n\nThe final matching produced by the greedy algorithm is $M_G = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$.\nThe size of this matching is $N_{greedy}(k) = |M_G| = k$.\n\n**Step 2: Calculate the size of the maximum matching, $N_{opt}(k)$.**\nThe graph $G_k$ is a disjoint union of $k$ identical subgraphs, one for each cluster $i$. The maximum matching of $G_k$ is the union of the maximum matchings of these subgraphs. Let's find the maximum matching for a single cluster $i$.\nThe subgraph for cluster $i$ has nodes $\\{a_{i,1}, a_{i,2}\\}$ and $\\{b_{i,1}, b_{i,2}\\}$ and edges $(a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}), (a_{i,1}, b_{i,2})$.\nWe can find a perfect matching in this subgraph, for example, by choosing the two direct links:\n$M_i^* = \\{ (a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}) \\}$.\nThis matching covers all four nodes in the subgraph for cluster $i$. Its size is 2. Since a perfect matching covers all vertices, it must be a maximum matching for the subgraph. The size of the maximum matching for one cluster is 2.\n\nTo find the maximum matching for the entire graph $G_k$, we sum the sizes of the maximum matchings for each of the $k$ disjoint clusters.\n$N_{opt}(k) = \\sum_{i=1}^{k} |M_i^*| = \\sum_{i=1}^{k} 2 = 2k$.\n\n**Step 3: Calculate the performance ratio.**\nThe performance ratio is the size of the optimal matching divided by the size of the greedy matching.\n$$ \\text{Performance Ratio} = \\frac{N_{opt}(k)}{N_{greedy}(k)} = \\frac{2k}{k} = 2 $$\nThe ratio is 2, independent of the value of $k$ (for $k \\ge 1$).", "answer": "$$\\boxed{2}$$", "id": "1520052"}]}