{"hands_on_practices": [{"introduction": "The Quicksort algorithm's efficiency stems from its \"divide and conquer\" strategy, which hinges on a crucial subroutine known as partitioning. This exercise challenges you to perform a single pass of the Lomuto partition scheme, a common method for rearranging an array around a chosen pivot element. By meticulously tracing these steps [@problem_id:1398611], you will gain a concrete understanding of how Quicksort begins to establish order within a dataset, a foundational skill for analyzing and implementing this powerful sorting algorithm.", "problem": "In a distributed computing environment, a load balancer needs to quickly rearrange a list of incoming tasks based on their assigned priority values. The goal is to perform a single partitioning pass to group tasks with lower priority values before tasks with higher priority values, relative to a chosen pivot task. This helps in delegating tasks more efficiently.\n\nYou are given a list of priority values for five tasks: $[7, 2, 9, 1, 5]$.\n\nThe partitioning algorithm to be used is as follows:\n1. The last element in the list is selected as the pivot value.\n2. A boundary index, `i`, is initialized to a position that is one place before the first element of the list.\n3. A second index, `j`, iterates through the list from the first element up to, but not including, the pivot element.\n4. During the iteration, if the element at index `j` is less than or equal to the pivot's value, the boundary index `i` is first incremented, and then the element at index `i` is swapped with the element at index `j`.\n5. After the iteration is complete, the pivot element is swapped with the element at index `i+1`.\n\nWhich of the following lists represents the state of the task list after this one-time partitioning process is complete?\n\nA. $[2, 1, 5, 7, 9]$\n\nB. $[1, 2, 5, 7, 9]$\n\nC. $[2, 1, 9, 7, 5]$\n\nD. $[5, 2, 7, 1, 9]$\n\nE. $[2, 1, 7, 5, 9]$", "solution": "We apply the described Lomuto-style partition to the list $A = [7,2,9,1,5]$ using the last element as pivot.\n\nSet the pivot $p = A[4] = 5$ and initialize the boundary index $i = -1$. Iterate $j$ from $0$ to $3$ and perform the conditional swap when $A[j] \\leq p$.\n\nFor $j=0$: $A[0] = 7$. Since $7 \\leq 5$ is false, do nothing; $i=-1$, $A=[7,2,9,1,5]$.\n\nFor $j=1$: $A[1] = 2$. Since $2 \\leq 5$ is true, increment $i$ to $0$ and swap $A[0]$ with $A[1]$, giving $A=[2,7,9,1,5]$.\n\nFor $j=2$: $A[2] = 9$. Since $9 \\leq 5$ is false, do nothing; $i=0$, $A=[2,7,9,1,5]$.\n\nFor $j=3$: $A[3] = 1$. Since $1 \\leq 5$ is true, increment $i$ to $1$ and swap $A[1]$ with $A[3]$, giving $A=[2,1,9,7,5]$.\n\nAfter the loop, swap the pivot with $A[i+1]$, i.e., swap $A[2]$ with $A[4]$, resulting in $A=[2,1,5,7,9]$.\n\nThus, the state of the list after one partition pass is $[2,1,5,7,9]$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1398611"}, {"introduction": "Beyond understanding how an algorithm operates, it is crucial to analyze its efficiency under various conditions. This practice explores the concept of worst-case performance by focusing on the bubble sort algorithm, whose efficiency is highly sensitive to the initial order of the data. By identifying the specific arrangement of elements that requires the maximum number of swaps [@problem_id:1398625], you will develop a deeper appreciation for how an algorithm's complexity is linked to the structure of its input.", "problem": "Consider a standard implementation of the bubble sort algorithm designed to sort a list of distinct numbers into ascending order. The algorithm repeatedly steps through the list, compares each pair of adjacent items, and swaps them if they are in the wrong order. These passes through the list are repeated until a pass is completed without making any swaps. The efficiency of this algorithm is highly dependent on the initial arrangement of the elements. The worst-case input is defined as the initial arrangement of elements that requires the maximum possible number of swaps to be completely sorted.\n\nSuppose we have a list containing a permutation of the $N$ distinct positive integers (i.e., the integers from $1$ to $N$). Which of the following statements best describes the arrangement of this list that constitutes the worst-case input for the bubble sort algorithm?\n\nA. The list alternates between the largest and smallest available numbers from the set (e.g., for $N=5$, the list is $[5, 1, 4, 2, 3]$).\n\nB. The list is sorted in strictly descending order (e.g., for $N=5$, the list is $[5, 4, 3, 2, 1]$).\n\nC. The list is the result of taking a list sorted in ascending order and moving the smallest element to the final position (e.g., for $N=5$, the list is $[2, 3, 4, 5, 1]$).\n\nD. The list consists of two halves: the first half of the list contains the smaller half of the numbers sorted in descending order, and the second half contains the larger half of the numbers sorted in descending order (e.g., for $N=6$, the list would be $[3, 2, 1, 6, 5, 4]$).", "solution": "Let the input be a permutation $\\pi$ of $\\{1,2,\\ldots,N\\}$. Define the inversion count of $\\pi$ by\n$$\nI(\\pi) = \\left|\\{(i,j) : 1 \\leq i  j \\leq N,\\ \\pi(i)  \\pi(j)\\}\\right|.\n$$\nTwo key facts connect $I(\\pi)$ to bubble sort:\n1) Bubble sort performs only adjacent swaps of out-of-order pairs. Swapping an adjacent inverted pair $(\\pi(i),\\pi(i+1))$ with $\\pi(i)  \\pi(i+1)$ toggles exactly that one inversion and does not change the relative order of any other pair, hence reduces $I(\\pi)$ by $1$ per swap. Bubble sort terminates exactly when $I(\\pi)=0$, which corresponds to ascending order. Therefore, the total number of swaps performed by bubble sort equals the initial inversion count $I(\\pi)$.\n2) The maximum possible number of inversions over all permutations of $N$ distinct numbers occurs when every pair is inverted, i.e., when the list is strictly descending. In that case, every pair $(i,j)$ with $ij$ contributes an inversion, so\n$$\nI_{\\max} = \\binom{N}{2}.\n$$\nFor any arrangement that is not strictly descending, there exists at least one pair in correct ascending order, hence $I(\\pi)  \\binom{N}{2}$.\n\nTherefore, the worst-case input for bubble sort (maximizing the number of swaps) is the strictly descending order. Among the options, this is exactly choice B. For completeness, note that the other options have fewer inversions: for example, option C has $I = N-1$, and for $N=2m$ in option D the inversion count is $2\\binom{m}{2}  \\binom{2m}{2}$; option A is not fully inverted and thus also has $I  \\binom{N}{2}$.\n\nHence the correct choice is B.", "answer": "$$\\boxed{B}$$", "id": "1398625"}, {"introduction": "In practical applications, choosing the right algorithm involves a cost-benefit analysis based on how the data will be used. This problem presents a classic trade-off: is it more efficient to perform many slow searches on unsorted data, or to pay an upfront cost to sort the data and then perform many fast searches? By deriving the breakeven point [@problem_id:1398631], you will learn how to use algorithmic complexity analysis not just as a theoretical tool, but as a practical guide for making informed engineering decisions based on computational costs and query volume.", "problem": "A data processing system must perform $k$ independent search queries on a static dataset stored as an array of $n$ unique items. Two strategies are being considered to handle these queries. The efficiency of each strategy is measured by its total computational time, which is determined by the number of two fundamental operations: key comparisons and data moves. The time required for a single key comparison is $T_c$, and the time for a single data move is $T_m$. You can assume that $n \\ge 3$.\n\n**Strategy 1: Repeated Linear Search**\nFor each of the $k$ queries, perform a linear search on the original, unsorted array. In the worst-case scenario, a single linear search requires $n$ key comparisons.\n\n**Strategy 2: Sort-then-Search**\nFirst, sort the array once using a specific implementation of a comparison-based sorting algorithm. In the worst case, this algorithm performs exactly $A \\cdot n \\log_2(n)$ key comparisons and $B \\cdot n \\log_2(n)$ data moves, where $A$ and $B$ are constants characteristic of the algorithm. After sorting, perform a binary search for each of the $k$ queries. In the worst case, a binary search on a sorted array of size $n$ requires $\\lfloor \\log_2(n) \\rfloor + 1$ key comparisons. Data moves are not a factor during the search phase.\n\nDetermine the smallest integer value of $k$ for which the total worst-case time cost of Strategy 2 is strictly less than the total worst-case time cost of Strategy 1. Your answer should be a formula in terms of $n, T_c, T_m, A$, and $B$.", "solution": "Let $L=\\lfloor \\log_{2}(n) \\rfloor + 1$ denote the worst-case number of key comparisons for a binary search on size $n$.\n\nWorst-case total time for Strategy 1 (repeated linear search):\nEach query costs $n$ comparisons, so\n$$\nT_{1}=k \\cdot n \\cdot T_{c}.\n$$\n\nWorst-case total time for Strategy 2 (sort-then-search):\nSorting costs $A \\cdot n \\log_{2}(n)$ comparisons and $B \\cdot n \\log_{2}(n)$ moves, giving time\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right).\n$$\nEach of the $k$ binary searches costs $L$ comparisons, so the search phase costs\n$$\nk \\cdot L \\cdot T_{c}.\n$$\nHence,\n$$\nT_{2}=n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}.\n$$\n\nWe require $T_{2}T_{1}$:\n$$\nn \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)+k L T_{c}k n T_{c}.\n$$\nRearranging,\n$$\nk T_{c}(n-L)n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right).\n$$\nFor $n \\ge 3$, we have $n-L0$, and $T_{c}0$, so dividing yields\n$$\nk\\frac{n \\log_{2}(n)\\left(A T_{c}+B T_{m}\\right)}{T_{c}(n-L)}\n=\\frac{n \\log_{2}(n)}{n-L}\\left(A+B \\frac{T_{m}}{T_{c}}\\right).\n$$\nTherefore, the smallest integer $k$ satisfying the strict inequality is\n$$\nk_{\\min}=\\left\\lfloor \\frac{n \\log_{2}(n)}{n-\\left(\\lfloor \\log_{2}(n) \\rfloor +1\\right)}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor +1.\n$$", "answer": "$$\\boxed{\\left\\lfloor \\frac{n \\log_{2}(n)}{\\,n-\\left(\\lfloor \\log_{2}(n) \\rfloor +1\\right)\\,}\\left(A+B \\frac{T_{m}}{T_{c}}\\right)\\right\\rfloor +1}$$", "id": "1398631"}]}