{"hands_on_practices": [{"introduction": "This first practice lays the groundwork for algorithm analysis by examining a simple iterative structure. The exercise [@problem_id:1349082] is designed to reinforce the fundamental concept of Big-O notation: how we distill the essence of an algorithm's performance by focusing on its growth rate relative to the input size $n$, while disregarding constant factors, no matter how large.", "problem": "An engineer is developing a system for a social media platform to verify the integrity of its user accounts. They have designed an algorithm called `verifyAllAccounts` that takes a list of $n$ user profiles as input. The algorithm iterates through each of the $n$ profiles one by one. For each individual profile, it calls a sub-procedure named `runComplianceScan`. This `runComplianceScan` sub-procedure is designed to perform a fixed and constant set of 1000 primitive computational operations (such as data field comparisons and hash checks) to ensure the account meets the platform's terms of service. The number of operations performed by `runComplianceScan` is always 1000, regardless of the specific data in the profile or the total number of users $n$.\n\nAssuming that accessing each profile in the list takes a constant amount of time, what is the asymptotic time complexity (Big-O notation) of the entire `verifyAllAccounts` algorithm as a function of the number of users, $n$?\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n^2)$\n\nE. $O(1000^n)$\n\nF. $O(1)$", "solution": "To determine the time complexity of the `verifyAllAccounts` algorithm, we need to analyze the total number of primitive operations it performs as a function of the input size, $n$. Let $T(n)$ represent this total number of operations.\n\nThe algorithm consists of a main loop that iterates through each of the $n$ user profiles. This structure can be modeled as a `for` loop that runs from $i=1$ to $n$.\n\nFor each iteration of this main loop (i.e., for each user profile), the algorithm calls the `runComplianceScan` sub-procedure. The problem states that `runComplianceScan` performs a constant number of operations, specifically 1000.\n\nSo, in the first iteration (for the first user), 1000 operations are performed.\nIn the second iteration (for the second user), another 1000 operations are performed.\nThis continues for all $n$ users.\n\nTo find the total number of operations $T(n)$, we sum the operations performed in each of the $n$ iterations of the main loop. Since each iteration contributes exactly 1000 operations, the total is:\n$$T(n) = \\sum_{i=1}^{n} 1000$$\nThis is equivalent to adding 1000 to itself $n$ times:\n$$T(n) = 1000 + 1000 + \\dots + 1000 \\quad (n \\text{ times})$$\n$$T(n) = 1000 \\cdot n$$\n\nNow, we must find the Big-O complexity for $T(n)$. According to the definition of Big-O notation, a function $T(n)$ is in $O(g(n))$ if there exist positive constants $c$ and $n_0$ such that $0 \\le T(n) \\le c \\cdot g(n)$ for all $n \\ge n_0$.\n\nIn our case, $T(n) = 1000n$. We are looking for the simplest function $g(n)$ that bounds $T(n)$. Let's test the function $g(n) = n$.\nWe need to check if $1000n \\le c \\cdot n$ for some constant $c$ and for all $n \\ge n_0$.\nIf we choose the constant $c = 1000$, the inequality becomes $1000n \\le 1000n$. This is true for all $n \\ge 1$. So, we can pick $c=1000$ and $n_0=1$.\nSince we have found such constants, we can conclude that $T(n)$ is in $O(n)$.\n\nIn Big-O analysis, constant factors are disregarded because we are interested in the growth rate of the function as $n$ becomes very large. The function $1000n$ grows linearly with $n$, just like the function $n$ does. Therefore, the asymptotic time complexity is $O(n)$.\n\nComparing our result with the given choices:\nA. $O(\\log n)$: Incorrect. Logarithmic growth is much slower than linear.\nB. $O(n)$: Correct. The runtime grows linearly with the number of users.\nC. $O(n \\log n)$: Incorrect. This is super-linear growth, often seen in efficient sorting algorithms.\nD. $O(n^2)$: Incorrect. This is quadratic growth, typical of a nested loop where the inner loop's iterations also depend on $n$.\nE. $O(1000^n)$: Incorrect. This is exponential growth and is far greater than the actual linear growth.\nF. $O(1)$: Incorrect. Constant time complexity would mean the runtime is independent of $n$.\n\nTherefore, the correct time complexity is $O(n)$.", "answer": "$$\\boxed{B}$$", "id": "1349082"}, {"introduction": "Moving beyond simple loops, this exercise explores a more complex nested loop structure whose runtime is not immediately obvious. The analysis of this common algorithmic pattern [@problem_id:1349044] requires moving from direct counting to applying mathematical approximations, specifically involving the harmonic series. This practice highlights how seemingly simple code can hide a more nuanced complexity, such as $O(n \\ln n)$, and develops the skills needed to uncover it.", "problem": "A prototype for a new decentralized data verification system is being analyzed. The system operates in rounds. For a dataset of size $n$, the main coordinating node performs a series of checks. It iterates through an integer parameter $i$ from $1$ up to $n$. In each iteration $i$, it queries a set of validator nodes. The number of validators queried in a specific iteration $i$ is given by the integer value $V_i = \\lfloor n/i \\rfloor$.\n\nYour task is to determine the asymptotic complexity of the total number of validator queries, $T$, performed by the coordinating node for processing a single dataset of size $n$. Select the tightest correct bound for $T$ from the options below, expressed using Big-O notation.\n\nA. $O(n)$\n\nB. $O(\\log_{2} n)$\n\nC. $O(n \\ln n)$\n\nD. $O(n^2)$\n\nE. $O(n \\log_{2} n)$\n\nF. $O(\\sqrt{n})$", "solution": "Let $T$ denote the total number of validator queries:\n$$\nT=\\sum_{i=1}^{n}\\left\\lfloor \\frac{n}{i} \\right\\rfloor.\n$$\nUse the inequality for the floor function: for any real $x$,\n$$\nx-1<\\lfloor x \\rfloor \\leq x.\n$$\nApplying this with $x=\\frac{n}{i}$ gives, for each $i$,\n$$\n\\frac{n}{i}-1<\\left\\lfloor \\frac{n}{i} \\right\\rfloor \\leq \\frac{n}{i}.\n$$\nSumming from $i=1$ to $n$ yields\n$$\n\\sum_{i=1}^{n}\\left(\\frac{n}{i}-1\\right)<\\sum_{i=1}^{n}\\left\\lfloor \\frac{n}{i} \\right\\rfloor \\leq \\sum_{i=1}^{n}\\frac{n}{i}.\n$$\nTherefore,\n$$\nn\\sum_{i=1}^{n}\\frac{1}{i}-n<T\\leq n\\sum_{i=1}^{n}\\frac{1}{i}.\n$$\nLet $H_{n}=\\sum_{i=1}^{n}\\frac{1}{i}$ be the $n$th harmonic number. It is known that\n$$\nH_{n}=\\ln n+\\gamma+O\\!\\left(\\frac{1}{n}\\right)=\\ln n+O(1),\n$$\nwhere $\\gamma$ is the Eulerâ€“Mascheroni constant. Substituting into the bounds gives\n$$\nn(\\ln n+O(1))-n<T\\leq n(\\ln n+O(1)).\n$$\nThus,\n$$\nT=n\\ln n+O(n),\n$$\nwhich implies $T=\\Theta(n\\ln n)$, and hence $T=O(n\\ln n)$. Since $\\ln n$ and $\\log_{2}(n)$ differ by a constant factor, $O(n\\ln n)$ and $O(n\\log_{2} n)$ are equivalent. Among the given options, the tightest correct bound is $O(n\\ln n)$.", "answer": "$$\\boxed{C}$$", "id": "1349044"}, {"introduction": "The analysis of recursive algorithms often leads to recurrence relations, and this practice tackles a particularly interesting one. The presented recurrence [@problem_id:1349048] does not fit the standard Master Theorem template directly. This problem will guide you through the powerful technique of using a change of variables to transform the recurrence into a solvable form, a crucial skill for analyzing many advanced divide-and-conquer algorithms.", "problem": "An experimental data processing algorithm, known as the \"Hierarchical Aggregation Transform\" (HAT), is designed to analyze large, high-dimensional datasets. The HAT algorithm operates on a dataset of size $n$. In each step, it performs a set of comparisons and merges that takes a time proportional to the base-2 logarithm of the dataset size. After this step, it recursively calls itself on two independent, transformed subproblems, where the effective size of each subproblem is the square root of the original dataset's size. For a dataset of size $n$, the running time $T(n)$ of the HAT algorithm can be modeled by the recurrence relation:\n\n$$T(n) = 2T(\\sqrt{n}) + \\log_{2}n$$\n\nAssume that for small inputs ($n \\le 4$), the running time $T(n)$ is a constant. Determine the tightest asymptotic upper and lower bound (Big-Theta notation) for the running time $T(n)$ of this algorithm.\n\nSelect the correct asymptotic bound from the options below.\n\nA. $\\Theta(\\log_{2}n)$\n\nB. $\\Theta((\\log_{2}n)^2)$\n\nC. $\\Theta(\\sqrt{n})$\n\nD. $\\Theta(\\log_{2}n \\cdot \\log_{2}(\\log_{2}n))$\n\nE. $\\Theta(n)$", "solution": "We are given the recurrence\n$$T(n)=2T(\\sqrt{n})+\\log_{2}n,$$\nwith the base condition that $T(n)$ is $\\Theta(1)$ for $n \\leq 4$.\n\nIntroduce the change of variables $n=2^{m}$ so that $m=\\log_{2}n$, and define $S(m)=T(2^{m})$. Then $\\sqrt{n}=2^{m/2}$, so the recurrence becomes\n$$S(m)=2S\\left(\\frac{m}{2}\\right)+m,$$\nwith $S(m)=\\Theta(1)$ for $m \\leq 2$.\n\nThis is a standard divide-and-conquer recurrence of the form $S(m)=aS(m/b)+f(m)$ with $a=2$, $b=2$, and $f(m)=m$. We have $m^{\\log_{b}a}=m^{\\log_{2}2}=m$. Thus $f(m)=\\Theta\\!\\left(m^{\\log_{2}2}\\right)$, which is case 2 of the Master Theorem, yielding\n$$S(m)=\\Theta\\!\\left(m\\log m\\right).$$\nTo be explicit about logarithm bases, this can be written as $S(m)=\\Theta\\!\\left(m\\log_{2}m\\right)$, since changing the base of the logarithm only affects constant factors.\n\nAlternatively, using a recursion-tree argument: at level $i$, there are $2^{i}$ subproblems of size $m/2^{i}$, each contributing $m/2^{i}$ to the non-recursive cost, so the total per level is $2^{i}\\cdot(m/2^{i})=m$. The depth is the smallest $d$ such that $m/2^{d}\\leq 2$, i.e., $d=\\Theta(\\log_{2}m)$, so the non-leaf cost sums to $\\Theta(m\\log_{2}m)$. The number of leaves is $2^{d}=\\Theta(m)$, each costing $\\Theta(1)$, adding $\\Theta(m)$, and the total remains $\\Theta(m\\log_{2}m)$.\n\nTransforming back to $n$ using $m=\\log_{2}n$ gives\n$$T(n)=S(\\log_{2}n)=\\Theta\\!\\left(\\log_{2}n\\cdot\\log_{2}\\!\\bigl(\\log_{2}n\\bigr)\\right).$$\nAmong the provided options, this matches option D.", "answer": "$$\\boxed{D}$$", "id": "1349048"}]}