{"hands_on_practices": [{"introduction": "To truly understand Breadth-First Search, it's essential to perform the traversal yourself. This first practice exercise guides you through the core mechanics of a BFS, starting from a given node in a network represented by an adjacency matrix. By manually managing the queue and tracking visited nodes, you will see firsthand how BFS explores the graph in a systematic, layer-by-layer fashion, a fundamental behavior that underpins all its applications. [@problem_id:1485198]", "problem": "In a small-scale, isolated data center, a network of 8 servers, labeled 1 through 8, are interconnected. The network topology is bidirectional and is represented by an $8 \\times 8$ adjacency matrix $A$, where $A_{ij} = 1$ if there is a direct link between server $i$ and server $j$, and $A_{ij} = 0$ otherwise. The matrix $A$ is given by:\n$$\nA = \\begin{pmatrix}\n0 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\n\\end{pmatrix}\n$$\nA broadcast protocol is initiated to distribute a critical update from a source server to all other servers in the network. The protocol uses a Breadth-First Search (BFS) algorithm to determine the order in which servers are visited. The traversal starts at server 3. When exploring the neighbors of a server, if multiple unvisited neighbors are found, they are added to the visit queue in ascending order of their server labels (e.g., server 2 would be enqueued before server 4).\n\nDetermine the sequence of server labels in the order they are first discovered (i.e., marked as \"visited\") during the BFS traversal.", "solution": "Interpret the graph from the symmetric adjacency matrix $A$ as an undirected graph. The neighbor sets read from the rows are:\n$$\nN(1)=\\{2,3,4\\},\\quad N(2)=\\{1\\},\\quad N(3)=\\{1,5,6\\},\\quad N(4)=\\{1\\},\n$$\n$$\nN(5)=\\{3,8\\},\\quad N(6)=\\{3,7\\},\\quad N(7)=\\{6\\},\\quad N(8)=\\{5\\}.\n$$\nUse BFS starting at server $3$. Principle: enqueue the start node and mark it visited; then iteratively dequeue a node, scan its neighbors in ascending order, and enqueue any unvisited neighbor immediately upon discovery (marking it visited at that time). The order of discovery is the order nodes are first enqueued.\n\nInitialize: queue $Q=[\\,]$, visited sequence empty. Enqueue $3$ and mark visited. Discovery order so far: $3$; queue $Q=[3]$.\n\nDequeue $3$. Its neighbors in ascending order are $1,5,6$. None are visited, so enqueue them in that order and mark visited upon enqueue. Discovery order: $3,1,5,6$; queue $Q=[1,5,6]$.\n\nDequeue $1$. Its neighbors are $2,3,4$ in ascending order. Among these, $3$ is already visited; enqueue $2$ then $4$. Discovery order: $3,1,5,6,2,4$; queue $Q=[5,6,2,4]$.\n\nDequeue $5$. Its neighbors are $3,8$. Node $3$ is visited; enqueue $8$. Discovery order: $3,1,5,6,2,4,8$; queue $Q=[6,2,4,8]$.\n\nDequeue $6$. Its neighbors are $3,7$. Node $3$ is visited; enqueue $7$. Discovery order: $3,1,5,6,2,4,8,7$; queue $Q=[2,4,8,7]$.\n\nDequeue $2$. Neighbor $1$ is already visited; no change. Queue $Q=[4,8,7]$.\n\nDequeue $4$. Neighbor $1$ is visited; no change. Queue $Q=[8,7]$.\n\nDequeue $8$. Neighbor $5$ is visited; no change. Queue $Q=[7]$.\n\nDequeue $7$. Neighbor $6$ is visited; no change. Queue empty; BFS completes.\n\nThus, the order of first discovery is $3,1,5,6,2,4,8,7$.", "answer": "$$\\boxed{\\begin{pmatrix}3 & 1 & 5 & 6 & 2 & 4 & 8 & 7\\end{pmatrix}}$$", "id": "1485198"}, {"introduction": "One of the most powerful features of BFS is its ability to find the shortest path between nodes in any unweighted graph. This exercise builds on the traversal mechanics by asking you to calculate the distance from a source to all other nodes. You will see how the layer-by-layer exploration directly corresponds to increasing path lengths, solidifying your understanding of why BFS is the go-to algorithm for this fundamental task. [@problem_id:1354187]", "problem": "Consider an undirected, unweighted graph G defined by a set of vertices $V$ and a set of edges $E$.\nThe vertex set is $V = \\{S, A, B, C, D, E, F, G\\}$.\nThe edge set is $E = \\{(S, A), (S, B), (S, C), (A, D), (B, D), (B, E), (C, F), (D, G), (E, G)\\}$.\n\nYou are to perform a Breadth-First Search (BFS) on this graph, starting from vertex $S$. The BFS algorithm computes the shortest path distance (in terms of number of edges) from the source vertex to all other vertices. These distances are stored in an array or map, which we will call `dist`. Initially, `$dist(S) = 0$` and `$dist(v) = \\infty$` for all other vertices `$v \\in V$`.\n\nA crucial rule for this specific execution is that whenever the algorithm needs to process the neighbors of a vertex, it must do so in alphabetical order.\n\nAfter the BFS algorithm has completely traversed the graph, what is the final state of the `dist` array? Choose the correct option from the list below.\n\nA. `dist(S)=0, dist(A)=1, dist(B)=1, dist(C)=1, dist(D)=2, dist(E)=2, dist(F)=2, dist(G)=3`\n\nB. `dist(S)=0, dist(A)=1, dist(B)=5, dist(C)=6, dist(D)=2, dist(E)=4, dist(F)=7, dist(G)=3`\n\nC. `dist(S)=0, dist(A)=1, dist(B)=1, dist(C)=1, dist(D)=2, dist(E)=2, dist(F)=2, dist(G)=4`\n\nD. `dist(S)=0, dist(A)=1, dist(B)=1, dist(C)=1, dist(D)=3, dist(E)=2, dist(F)=2, dist(G)=4`\n\nE. `dist(S)=0, dist(A)=1, dist(B)=2, dist(C)=3, dist(D)=2, dist(E)=3, dist(F)=4, dist(G)=3`", "solution": "We treat the graph as undirected, so each listed edge connects both ways. For each vertex $v$, let $N(v)$ denote its neighbors, processed in alphabetical order as required. The adjacency sets are:\n$N(S)=\\{A,B,C\\}$, $N(A)=\\{D,S\\}$, $N(B)=\\{D,E,S\\}$, $N(C)=\\{F,S\\}$, $N(D)=\\{A,B,G\\}$, $N(E)=\\{B,G\\}$, $N(F)=\\{C\\}$, $N(G)=\\{D,E\\}$.\n\nBreadth-First Search (BFS) invariant: when a vertex $u$ is dequeued, for each neighbor $v\\in N(u)$ not yet discovered, set $dist(v)=dist(u)+1$ and enqueue $v$. Because BFS explores in nondecreasing order of distance, the first time a vertex is discovered its distance is the shortest-path distance. Alphabetical neighbor ordering only determines tie-breaking.\n\nInitialize: $dist(S)=0$ and $dist(v)=\\infty$ for all $v\\neq S$. Queue $Q=[S]$.\n\nProcess $S$: neighbors in alphabetical order are $A,B,C$.\n- Discover $A$: $dist(A)=dist(S)+1=1$, enqueue $A$.\n- Discover $B$: $dist(B)=1$, enqueue $B$.\n- Discover $C$: $dist(C)=1$, enqueue $C$.\nQueue becomes $[A,B,C]$.\n\nDequeue $A$: neighbors in order $D,S$.\n- $D$ undiscovered: $dist(D)=dist(A)+1=2$, enqueue $D$.\n- $S$ already discovered.\nQueue becomes $[B,C,D]$.\n\nDequeue $B$: neighbors in order $D,E,S$.\n- $D$ already discovered (shortest known).\n- $E$ undiscovered: $dist(E)=dist(B)+1=2$, enqueue $E$.\n- $S$ already discovered.\nQueue becomes $[C,D,E]$.\n\nDequeue $C$: neighbors in order $F,S$.\n- $F$ undiscovered: $dist(F)=dist(C)+1=2$, enqueue $F$.\n- $S$ already discovered.\nQueue becomes $[D,E,F]$.\n\nDequeue $D$: neighbors in order $A,B,G$.\n- $A$ and $B$ already discovered.\n- $G$ undiscovered: $dist(G)=dist(D)+1=3$, enqueue $G$.\nQueue becomes $[E,F,G]$.\n\nDequeue $E$: neighbors $B,G$ already discovered. Queue becomes $[F,G]$.\nDequeue $F$: neighbor $C$ already discovered. Queue becomes $[G]$.\nDequeue $G$: neighbors $D,E$ already discovered. Queue empty; BFS terminates.\n\nFinal distances are $dist(S)=0$, $dist(A)=1$, $dist(B)=1$, $dist(C)=1$, $dist(D)=2$, $dist(E)=2$, $dist(F)=2$, $dist(G)=3$, which matches option A.", "answer": "$$\\boxed{A}$$", "id": "1354187"}, {"introduction": "It is crucial to distinguish between the shortest path in terms of edges and the shortest path in terms of weight. This exercise presents a weighted graph but asks you to perform a standard BFS, intentionally ignoring the weights to construct a spanning tree. By calculating the total weight of this BFS tree, you will gain a clear insight into how BFS prioritizes the number of connections (topology) over the cost of those connections, highlighting the specific problem domain where BFS excels. [@problem_id:1414543]", "problem": "Consider an undirected, weighted graph $G$ with the set of vertices $V = \\{\\text{A, B, C, D, E, F, G}\\}$. The edges and their corresponding integer weights are given as a list of tuples (vertex1, vertex2, weight):\n$E = \\{(\\text{A, B, 3}), (\\text{A, C, 8}), (\\text{A, D, 10}), (\\text{B, C, 2}), (\\text{B, E, 5}), (\\text{C, F, 4}), (\\text{D, F, 7}), (\\text{E, G, 6}), (\\text{F, G, 1})\\}$.\n\nYour task is to find the Breadth-First Search (BFS) tree rooted at the source vertex A. For the purpose of running the search algorithm, you must treat the graph as if it were unweighted, meaning the determination of which vertices to visit next depends only on the graph's topology, not the edge weights. When a vertex has multiple neighbors to visit, you must explore them in alphabetical order.\n\nAfter the BFS traversal is complete and the resulting spanning tree is determined, calculate the sum of the original weights of all the edges that form this BFS tree. Provide this total weight as your final answer.", "solution": "We perform a breadth-first search (BFS) on the undirected graph, treating it as unweighted and exploring neighbors in alphabetical order. Initialize the queue with source A, mark A discovered, and build the BFS tree by adding the edge by which each newly discovered vertex is first reached.\n\nStart with queue containing A. Dequeue A and examine its neighbors in alphabetical order: B, C, D. All are undiscovered, so we discover them in this order, set their parent to A, and enqueue them. The BFS tree gains edges $A\\text{-}B$, $A\\text{-}C$, $A\\text{-}D$.\n\nQueue is now $[B, C, D]$. Dequeue B and examine its neighbors in alphabetical order: A, C, E. A and C are already discovered, E is undiscovered, so discover E with parent B and enqueue it. The BFS tree gains edge $B\\text{-}E$.\n\nQueue is $[C, D, E]$. Dequeue C and examine its neighbors in alphabetical order: A, B, F. A and B are already discovered, F is undiscovered, so discover F with parent C and enqueue it. The BFS tree gains edge $C\\text{-}F$.\n\nQueue is $[D, E, F]$. Dequeue D and examine its neighbors in alphabetical order: A, F. Both are already discovered; no new vertices are added.\n\nQueue is $[E, F]$. Dequeue E and examine its neighbors in alphabetical order: B, G. B is already discovered, G is undiscovered, so discover G with parent E and enqueue it. The BFS tree gains edge $E\\text{-}G$.\n\nQueue is $[F, G]$. Dequeue F and examine its neighbors in alphabetical order: C, D, G. All are already discovered; no new vertices are added.\n\nQueue is $[G]$. Dequeue G and examine its neighbors in alphabetical order: E, F. Both are already discovered; BFS terminates.\n\nHence, the BFS tree edges are\n$$\\{A\\text{-}B,\\ A\\text{-}C,\\ A\\text{-}D,\\ B\\text{-}E,\\ C\\text{-}F,\\ E\\text{-}G\\}.$$\nUsing the original edge weights, the total weight of this BFS tree is\n$$3+8+10+5+4+6=36.$$", "answer": "$$\\boxed{36}$$", "id": "1414543"}]}