{"hands_on_practices": [{"introduction": "To truly grasp the Depth-First Search algorithm, there is no substitute for tracing its execution by hand. This exercise guides you through a classic recursive DFS on a small graph, asking you to record the discovery and finish times for each vertex. Understanding these timestamps is key, as they form the foundation for many powerful applications of DFS, such as topological sorting and finding strongly connected components. [@problem_id:1362166]", "problem": "A software build system uses a \"dependency resolution protocol\" to determine the correct order for compiling a set of interconnected code modules. The protocol operates on a graph of modules and their dependencies. This process involves assigning two timestamps to each module: a \"discovery time\" and a \"finish time\".\n\nThe protocol is as follows:\n1.  A global timestamp counter is initialized to 1.\n2.  The process begins at a starting module. If no start is specified, it begins with the module that comes first in alphabetical order.\n3.  When a module is visited for the first time, it is marked \"discovered,\" its discovery time is set to the current value of the global timestamp, and the timestamp is incremented by 1.\n4.  The system then examines the neighbors of the just-discovered module. It recursively calls the protocol on the first unvisited neighbor found, according to alphabetical order.\n5.  After the recursive calls for all of a module's neighbors have returned, the module is marked \"finished,\" its finish time is set to the current value of the global timestamp, and the timestamp is incremented by 1. The process then returns to where it was called from.\n6.  If the initial traversal completes and there are still unvisited modules, the process is repeated starting from the unvisited module that comes first in alphabetical order.\n\nConsider a project with eight modules: A, B, C, D, E, F, G, H. The dependency relationships are symmetric (i.e., if X depends on Y, then Y depends on X) and are defined as follows:\n-   Module A is connected to B, D, and E.\n-   Module B is connected to A and C.\n-   Module C is connected to B, G, and H.\n-   Module D is connected to A and F.\n-   Module E is connected to A and F.\n-   Module F is connected to D, E, and G.\n-   Module G is connected to C and F.\n-   Module H is connected to C.\n\nStarting the protocol from module A, determine the discovery and finish times for all eight modules. Which of the following options correctly lists the `(discovery_time, finish_time)` pairs for all modules, ordered alphabetically from A to H?\n\nA. A:(1,16), B:(8,9), C:(7,12), D:(2,15), E:(4,5), F:(3,14), G:(6,13), H:(10,11)\n\nB. A:(1, 16), B:(2, 15), C:(3, 14), D:(8, 9), E:(6, 7), F:(5, 10), G:(4, 11), H:(12, 13)\n\nC. A:(1, 16), B:(2, 15), C:(3, 14), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(12, 13)\n\nD. A:(1, 16), B:(2, 15), C:(3, 12), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(13, 14)", "solution": "We perform a depth-first traversal with a global timestamp $t$ initialized to $1$, starting at $A$, and exploring neighbors in alphabetical order. On first visit to a node $v$, set its discovery time $d(v)=t$ and increment $t$ by $1$. After all recursive calls for $v$’s neighbors return, set its finish time $f(v)=t$ and increment $t$ by $1$.\n\nInitialize $t=1$.\n\nStart at $A$ with neighbors in order $B,D,E$.\n$$d(A)=1,\\quad t=2$$\nGo to $B$ (first unvisited neighbor of $A$). Neighbors of $B$ in order $A,C$.\n$$d(B)=2,\\quad t=3$$\n$A$ is already visited; go to $C$. Neighbors of $C$ in order $B,G,H$.\n$$d(C)=3,\\quad t=4$$\n$B$ is visited; go to $G$. Neighbors of $G$ in order $C,F$.\n$$d(G)=4,\\quad t=5$$\n$C$ is visited; go to $F$. Neighbors of $F$ in order $D,E,G$.\n$$d(F)=5,\\quad t=6$$\nGo to $D$ (first unvisited). Neighbors of $D$ in order $A,F$.\n$$d(D)=6,\\quad t=7$$\nBoth $A$ and $F$ are visited; finish $D$:\n$$f(D)=7,\\quad t=8$$\nReturn to $F$; next neighbor is $E$ (unvisited).\n$$d(E)=8,\\quad t=9$$\nNeighbors of $E$ are $A,F$, both visited; finish $E$:\n$$f(E)=9,\\quad t=10$$\nBack to $F$; next neighbor $G$ is visited; finish $F$:\n$$f(F)=10,\\quad t=11$$\nBack to $G$; no more neighbors; finish $G$:\n$$f(G)=11,\\quad t=12$$\nBack to $C$; next neighbor is $H$ (unvisited).\n$$d(H)=12,\\quad t=13$$\n$H$’s neighbor $C$ is visited; finish $H$:\n$$f(H)=13,\\quad t=14$$\nBack to $C$; no more neighbors; finish $C$:\n$$f(C)=14,\\quad t=15$$\nBack to $B$; no more neighbors; finish $B$:\n$$f(B)=15,\\quad t=16$$\nBack to $A$; remaining neighbors $D,E$ are already visited; finish $A$:\n$$f(A)=16,\\quad t=17$$\n\nThus the discovery/finish times are:\n- $A:(1,16)$\n- $B:(2,15)$\n- $C:(3,14)$\n- $D:(6,7)$\n- $E:(8,9)$\n- $F:(5,10)$\n- $G:(4,11)$\n- $H:(12,13)$\n\nThis matches option C.", "answer": "$$\\boxed{C}$$", "id": "1362166"}, {"introduction": "Does a single graph have only one Depth-First Search tree? This practice tackles that common question by demonstrating how the traversal's outcome is sensitive to implementation details. By comparing two DFS runs on the same graph using different adjacency list orderings, you will see firsthand how the resulting tree structure and edge classifications (tree, back, etc.) can change dramatically. [@problem_id:1496211]", "problem": "Consider an undirected graph $G = (V, E)$ where the set of vertices is $V = \\{A, B, C, D, E, F\\}$ and the set of edges is $E = \\{\\{A, B\\}, \\{A, C\\}, \\{A, D\\}, \\{B, C\\}, \\{C, D\\}, \\{C, E\\}, \\{D, F\\}, \\{E, F\\}\\}$.\n\nA Depth-First Search (DFS) is an algorithm for traversing a graph. When performing a DFS starting from a source vertex, the edges of the graph are classified. An edge $(u, v)$ is a \"tree edge\" if vertex $v$ is first discovered by exploring from vertex $u$. An edge $(u, v)$ is a \"back edge\" if vertex $v$ is an ancestor of vertex $u$ in the DFS tree but is not its parent. The collection of tree edges forms a DFS tree (or forest).\n\nThe structure of the DFS tree and the classification of edges depend on the order in which adjacent vertices are visited. This order is determined by the graph's adjacency list representation.\n\nTwo different DFS traversals are performed on graph $G$, both starting from vertex $A$.\n1.  **Traversal 1**: Uses an adjacency list representation, $L_1$, where the neighbors of each vertex are listed in alphabetical order. This traversal produces a DFS tree $T_1$.\n2.  **Traversal 2**: Uses a different adjacency list representation, $L_2$, where the neighbors for each vertex are listed in the specific order given below. This traversal produces a DFS tree $T_2$.\n\nAdjacency List $L_2$:\n- A: [D, C, B]\n- B: [C, A]\n- C: [E, D, B, A]\n- D: [F, C, A]\n- E: [F, C]\n- F: [E, D]\n\nBased on these two traversals, which of the following statements is true?\n\nA. The set of back edges is the same for both traversals.\n\nB. The DFS tree $T_1$ has a greater height than the DFS tree $T_2$. (The height of a tree is the number of edges on the longest downward path from the root to a leaf.)\n\nC. The edge $\\{C, D\\}$ is a tree edge in $T_1$ and also a tree edge in $T_2$.\n\nD. The edge $\\{A, D\\}$ is a back edge in $T_1$ but a tree edge in $T_2$.\n\nE. Vertex $C$ has the same parent in both DFS trees $T_1$ and $T_2$.", "solution": "We first construct the alphabetical adjacency lists for $L_1$ from $E=\\{\\{A,B\\},\\{A,C\\},\\{A,D\\},\\{B,C\\},\\{C,D\\},\\{C,E\\},\\{D,F\\},\\{E,F\\}\\}$:\n- $A:[B,C,D]$, $B:[A,C]$, $C:[A,B,D,E]$, $D:[A,C,F]$, $E:[C,F]$, $F:[D,E]$.\n\nDepth-first search with $L_1$ starting at $A$ proceeds as follows.\n- From $A$ visit $B$: tree edge $\\{A,B\\}$.\n- From $B$ visit $C$: tree edge $\\{B,C\\}$. Encounter $C\\to A$ where $A$ is an ancestor not parent: back edge $\\{A,C\\}$.\n- From $C$ visit $D$: tree edge $\\{C,D\\}$.\n- At $D$, encounter $D\\to A$ where $A$ is an ancestor not parent: back edge $\\{A,D\\}$. Then visit $F$: tree edge $\\{D,F\\}$.\n- From $F$ visit $E$: tree edge $\\{F,E\\}$.\n- At $E$, encounter $E\\to C$ where $C$ is an ancestor not parent: back edge $\\{C,E\\}$.\n\nThus for $T_1$, the tree edges are $\\{\\{A,B\\},\\{B,C\\},\\{C,D\\},\\{D,F\\},\\{F,E\\}\\}$, forming the path $A\\!-\\!B\\!-\\!C\\!-\\!D\\!-\\!F\\!-\\!E$. The back edges are $\\{\\{A,C\\},\\{A,D\\},\\{C,E\\}\\}$. The height of $T_1$ is $5$ (longest root-to-leaf path has $5$ edges).\n\nNow use $L_2$:\n- $A:[D,C,B]$, $B:[C,A]$, $C:[E,D,B,A]$, $D:[F,C,A]$, $E:[F,C]$, $F:[E,D]$.\n\nDepth-first search with $L_2$ starting at $A$ proceeds as follows.\n- From $A$ visit $D$: tree edge $\\{A,D\\}$.\n- From $D$ visit $F$: tree edge $\\{D,F\\}$.\n- From $F$ visit $E$: tree edge $\\{F,E\\}$.\n- From $E$ visit $C$: tree edge $\\{E,C\\}$.\n- At $C$, encounter $C\\to D$ where $D$ is an ancestor not parent: back edge $\\{C,D\\}$. Then visit $B$: tree edge $\\{C,B\\}$.\n- At $B$, encounter $B\\to A$ where $A$ is an ancestor not parent: back edge $\\{A,B\\}$. Back at $C$, encounter $C\\to A$ where $A$ is an ancestor not parent: back edge $\\{A,C\\}$.\n\nThus for $T_2$, the tree edges are $\\{\\{A,D\\},\\{D,F\\},\\{F,E\\},\\{E,C\\},\\{C,B\\}\\}$, forming the path $A\\!-\\!D\\!-\\!F\\!-\\!E\\!-\\!C\\!-\\!B$. The back edges are $\\{\\{A,B\\},\\{A,C\\},\\{C,D\\}\\}$. The height of $T_2$ is also $5$.\n\nEvaluate the statements:\n- A: The back-edge sets differ ($\\{\\{A,C\\},\\{A,D\\},\\{C,E\\}\\}$ versus $\\{\\{A,B\\},\\{A,C\\},\\{C,D\\}\\}$), so false.\n- B: Heights are equal ($5$ and $5$), so false.\n- C: $\\{C,D\\}$ is a tree edge in $T_1$ but a back edge in $T_2$, so false.\n- D: $\\{A,D\\}$ is a back edge in $T_1$ and a tree edge in $T_2$, so true.\n- E: The parent of $C$ in $T_1$ is $B$, while in $T_2$ it is $E$, so false.\n\nTherefore, only statement D is correct.", "answer": "$$\\boxed{D}$$", "id": "1496211"}, {"introduction": "Beyond simply visiting nodes, DFS provides a framework for solving complex problems on graphs. This exercise challenges you to apply the logic of graph traversal to a practical application: counting the number of unique paths in a Directed Acyclic Graph (DAG). This problem bridges the gap between the mechanics of search algorithms and the powerful paradigm of dynamic programming on graphs. [@problem_id:1362142]", "problem": "A software build system analyzes dependencies between different modules to determine valid compilation orders. These dependencies are represented as a Directed Acyclic Graph (DAG), where a set of vertices represents the modules and a directed edge from module $U$ to module $V$ indicates that module U is a prerequisite for V (i.e., U must be compiled before V).\n\nA \"simple compilation sequence\" is defined as a path from a starting module to a final module that does not revisit any module. The system needs to determine the total number of distinct simple compilation sequences between a specific start module and a target module for performance analysis.\n\nConsider a system with the following dependency graph:\n- The set of modules (vertices) is $V = \\{0, 1, 2, 3, 4, 5, 6, 7, 8\\}$.\n- The set of dependencies (edges) is $E = \\{(0, 1), (0, 2), (1, 3), (1, 4), (2, 4), (2, 5), (3, 6), (4, 6), (4, 7), (5, 7), (6, 8), (7, 8)\\}$.\n- The `start_module` is $s = 0$.\n- The `target_module` is $t = 8$.\n\nWhat is the total number of distinct simple compilation sequences from the `start_module` to the `target_module`?", "solution": "We model the number of distinct simple paths from a vertex $v$ to the target $t$ by a function $N(v)$. In a Directed Acyclic Graph, the simple path count satisfies the dynamic programming relation\n$$\nN(v)=\\sum_{(v,u)\\in E}N(u),\n$$\nwith the base case\n$$\nN(t)=1,\n$$\nsince there is exactly one trivial path from $t$ to itself. We process vertices in reverse topological order consistent with the given edge directions.\n\nGiven $t=8$, set\n$$\nN(8)=1.\n$$\nUsing the outgoing edges:\n- From $7$ to $8$, we have\n$$\nN(7)=N(8)=1.\n$$\n- From $6$ to $8$, we have\n$$\nN(6)=N(8)=1.\n$$\n- From $5$ to $7$, we have\n$$\nN(5)=N(7)=1.\n$$\n- From $4$ to $6$ and $7$, we have\n$$\nN(4)=N(6)+N(7)=1+1=2.\n$$\n- From $3$ to $6$, we have\n$$\nN(3)=N(6)=1.\n$$\n- From $2$ to $4$ and $5$, we have\n$$\nN(2)=N(4)+N(5)=2+1=3.\n$$\n- From $1$ to $3$ and $4$, we have\n$$\nN(1)=N(3)+N(4)=1+2=3.\n$$\n- From $0$ to $1$ and $2$, we have\n$$\nN(0)=N(1)+N(2)=3+3=6.\n$$\n\nTherefore, the total number of distinct simple compilation sequences from $s=0$ to $t=8$ is $N(0)=6$.", "answer": "$$\\boxed{6}$$", "id": "1362142"}]}