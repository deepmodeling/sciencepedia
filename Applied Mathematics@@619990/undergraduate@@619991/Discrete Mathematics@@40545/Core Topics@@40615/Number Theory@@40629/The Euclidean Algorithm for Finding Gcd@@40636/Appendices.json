{"hands_on_practices": [{"introduction": "The Euclidean algorithm is not just an abstract mathematical procedure; it provides elegant solutions to practical, real-world problems. This first exercise demonstrates how finding the greatest common divisor can solve a common design challenge involving dimensions and tiling. By working through the scenario presented in [@problem_id:1406858], you'll see how a seemingly complex spatial problem boils down to a straightforward application of the algorithm, reinforcing its core computational steps and its relevance outside of pure mathematics.", "problem": "A landscape architect is designing a rectangular patio for a new city park. The designated area for the patio measures 1164 centimeters in length and 876 centimeters in width. The architect plans to pave the entire area using identical, non-overlapping square tiles. To minimize costs and aesthetic disruption from grout lines, the architect wants to use the largest possible square tiles that can cover the area perfectly without any of the tiles being cut.\n\nWhat is the side length, in centimeters, of the largest possible square tiles that can be used for this project?", "solution": "Let the side length of each square tile be $s$. To tile the $1164$ by $876$ rectangle exactly with non-overlapping squares of side $s$, both $1164$ and $876$ must be integer multiples of $s$. Therefore, $s$ must be a common divisor of $1164$ and $876$. The largest such $s$ is the greatest common divisor:\n$$\ns=\\gcd(1164,876).\n$$\nCompute $\\gcd(1164,876)$ using the Euclidean algorithm:\n$$\n1164=1 \\cdot 876+288,\n$$\n$$\n876=3\\cdot 288+12,\n$$\n$$\n288=24\\cdot 12+0.\n$$\nThe last nonzero remainder is $12$, hence\n$$\n\\gcd(1164,876)=12.\n$$\nTherefore, the side length of the largest square tile is $12$ centimeters.", "answer": "$$\\boxed{12}$$", "id": "1406858"}, {"introduction": "Having practiced the standard, forward application of the algorithm, we now reverse our perspective. The Euclidean algorithm generates a unique sequence of remainders, but can we work backward from a given sequence of remainders to find the original numbers? This practice [@problem_id:1406844] challenges you to reconstruct the smallest possible pair of integers, $a$ and $b$, from their algorithmic \"fingerprint\". This reverse-engineering exercise deepens your understanding of the relationship between quotients and remainders and is a key step towards understanding the Extended Euclidean Algorithm.", "problem": "The Euclidean algorithm is a method for finding the Greatest Common Divisor (GCD) of two integers. When the algorithm is applied to two positive integers $a$ and $b$ with $a > b$, it generates a sequence of divisions with remainders. The first division is of $a$ by $b$ to get a remainder $r_1$. The second is of $b$ by $r_1$ to get a remainder $r_2$. This process continues, where at each subsequent step, the previous divisor is divided by the previous remainder, until the remainder is 0. The GCD is the last non-zero remainder.\n\nSuppose that for a particular pair of positive integers $a$ and $b$ with $a>b$, the execution of the Euclidean algorithm produces the following sequence of successive non-zero remainders: $r_1 = 24$, $r_2 = 18$, and $r_3 = 6$.\n\nFind the smallest possible value for the sum $a+b$.", "solution": "By the Euclidean algorithm, with successive remainders $r_{1}=24$, $r_{2}=18$, $r_{3}=6$, the divisions take the form\n$$\na=q_{1}b+24,\\quad 0<24<b,\\quad q_{1}\\in\\mathbb{Z}_{\\ge 1},\n$$\n$$\nb=q_{2}\\cdot 24+18,\\quad 0<18<24,\\quad q_{2}\\in\\mathbb{Z}_{\\ge 1},\n$$\n$$\n24=q_{3}\\cdot 18+6,\\quad 0<6<18,\n$$\n$$\n18=q_{4}\\cdot 6+0.\n$$\nFrom $24=q_{3}\\cdot 18+6$ it follows that $q_{3}=1$. From $18=q_{4}\\cdot 6$ it follows that $q_{4}=3$. Thus the only free quotients are $q_{1},q_{2}\\in\\mathbb{Z}_{\\ge 1}$, and\n$$\nb=24q_{2}+18,\\qquad a=q_{1}b+24.\n$$\nHence the sum is\n$$\na+b=(q_{1}+1)b+24=(q_{1}+1)(24q_{2}+18)+24.\n$$\nTo minimize $a+b$ over integers $q_{1},q_{2}\\ge 1$, choose $q_{1}=1$ and $q_{2}=1$, yielding\n$$\nb=24\\cdot 1+18=42,\\qquad a=1\\cdot 42+24=66,\n$$\nso\n$$\na+b=66+42=108.\n$$\nThese values are consistent with the given remainders:\n$$\n66=1\\cdot 42+24,\\quad 42=1\\cdot 24+18,\\quad 24=1\\cdot 18+6,\\quad 18=3\\cdot 6+0.\n$$\nTherefore, the smallest possible value of $a+b$ is $108$.", "answer": "$$\\boxed{108}$$", "id": "1406844"}, {"introduction": "From mathematical theory, we now turn to computational practice, where subtle errors can have drastic consequences. This final exercise explores a common pitfall in implementing the Euclidean algorithm recursively. You will analyze a piece of pseudocode that contains a single, critical flaw and determine why it fails to work as intended [@problem_id:1406857]. Debugging this faulty logic will solidify your understanding of recursion and highlight why the precise structure of the recursive call is essential for guaranteeing the algorithm's termination and correctness.", "problem": "A student is tasked with implementing a recursive function to find the Greatest Common Divisor (GCD) of two non-negative integers. The GCD is the largest positive integer that divides both numbers without a remainder. The student writes the following pseudocode for a function named `Altered_GCD`.\n\n```\nFUNCTION Altered_GCD(a, b):\n    // a and b are non-negative integers\n    // 'MOD' represents the modulo operator\n\n    IF b == 0:\n        RETURN a\n    ELSE:\n        RETURN Altered_GCD(a MOD b, b)\n```\n\nAnalyze the behavior of this `Altered_GCD` function. Which of the following statements most accurately describes its functionality for any non-negative integer inputs `a` and `b`?\n\nA. The function correctly computes the GCD for all non-negative integers `a` and `b`.\n\nB. The function correctly computes the GCD if and only if the initial input satisfies `a >= b`.\n\nC. The function fails to terminate for any input where `b` is a positive integer.\n\nD. The function computes the Least Common Multiple (LCM) instead of the GCD.\n\nE. The function correctly computes the GCD, but only when `a` and `b` are coprime (their GCD is 1).", "solution": "The problem asks us to analyze a flawed recursive implementation of the Euclidean algorithm for finding the Greatest Common Divisor (GCD). Let's analyze the behavior of the `Altered_GCD(a, b)` function by examining its base case and its recursive step.\n\nThe provided pseudocode is:\n```\nFUNCTION Altered_GCD(a, b):\n    IF b == 0:\n        RETURN a\n    ELSE:\n        RETURN Altered_GCD(a MOD b, b)\n```\n\n**Case 1: The Base Case**\nThe base case for the recursion is `b == 0`. If the function is called with `b=0`, such as `Altered_GCD(a, 0)`, it immediately returns `a`. This is the correct behavior, as the GCD of any number `a` and 0 is defined to be `a`. So, the function terminates and gives the correct answer if the second argument is initially 0.\n\n**Case 2: The Recursive Step**\nThe recursive step is executed when `b > 0`. The function calls itself with new arguments: `Altered_GCD(a MOD b, b)`.\n\nLet's trace the arguments.\nLet the initial call be with `(a_0, b_0) = (a, b)`.\nThe first recursive call will be with `(a_1, b_1)`, where:\n$a_1 = a_0 \\text{ MOD } b_0$\n$b_1 = b_0$\n\nThe second recursive call will be with `(a_2, b_2)`, where:\n$a_2 = a_1 \\text{ MOD } b_1$\n$b_2 = b_1$\n\nNotice the crucial flaw: the second argument, `b`, is passed unchanged in every recursive call. Let's write `b_n` for the second argument at the n-th recursive step. We have $b_n = b_{n-1} = \\dots = b_1 = b_0 = b$.\n\nFor a recursive algorithm to terminate, its state must progress towards the base case. In this algorithm, the base case is `b == 0`. Since the value of the second argument never changes from its initial value `b`, the condition `b == 0` will never be met unless `b` was 0 from the very beginning.\n\nLet's consider an arbitrary input `(a, b)` where `b > 0`.\nThe sequence of calls is:\n`Altered_GCD(a, b)`\n`-> Altered_GCD(a MOD b, b)`\n`-> Altered_GCD((a MOD b) MOD b, b)`\n`-> Altered_GCD(((a MOD b) MOD b) MOD b, b)`\n...and so on.\n\nLet's examine the first argument. Let $a' = a \\text{ MOD } b$. By definition of the modulo operator, $0 \\le a' < b$.\nThe next argument for the first position is $a' \\text{ MOD } b$. Since $0 \\le a' < b$, it follows that $a' \\text{ MOD } b = a'$.\nSo, after the first recursive call `Altered_GCD(a MOD b, b)`, every subsequent call will be `Altered_GCD(a MOD b, b)`. The function has entered a state from which it can never escape. This results in an infinite recursion.\n\nFor example, let's trace `Altered_GCD(25, 10)`:\n1. `Altered_GCD(25, 10)` -> `b` is not 0. Returns `Altered_GCD(25 MOD 10, 10)`, which is `Altered_GCD(5, 10)`.\n2. `Altered_GCD(5, 10)` -> `b` is not 0. Returns `Altered_GCD(5 MOD 10, 10)`, which is `Altered_GCD(5, 10)`.\n3. `Altered_GCD(5, 10)` -> Returns `Altered_GCD(5, 10)`. ... This continues forever.\n\nLet's trace another example where `a < b`, like `Altered_GCD(10, 25)`:\n1. `Altered_GCD(10, 25)` -> `b` is not 0. Returns `Altered_GCD(10 MOD 25, 25)`, which is `Altered_GCD(10, 25)`.\n2. This immediately enters an infinite loop.\n\nThe only scenario where termination occurs is when the initial `b` is 0. If `b` is any positive integer, the function will enter an infinite recursion and fail to terminate.\n\nNow let's evaluate the options:\nA. The function correctly computes the GCD for all non-negative integers `a` and `b`. This is false. It fails to terminate if `b > 0$.\nB. The function correctly computes the GCD if and only if the initial input satisfies `a >= b`. This is false. Our example `Altered_GCD(25, 10)` shows it fails even if `a > b`.\nC. The function fails to terminate for any input where `b` is a positive integer. This is true, as our analysis showed. The value of `b` never decreases to reach the base case of 0.\nD. The function computes the Least Common Multiple (LCM) instead of the GCD. This is false. The structure is based on the Euclidean algorithm, and its failure mode is non-termination, not computing a different quantity.\nE. The function correctly computes the GCD, but only when `a` and `b` are coprime (their GCD is 1). This is false. For example, `Altered_GCD(7, 5)` (coprime) fails to terminate just like `Altered_GCD(25, 10)`. The termination issue is independent of the coprimality of the inputs.\n\nTherefore, the most accurate description is that the function fails to terminate for any positive `b`.", "answer": "$$\\boxed{C}$$", "id": "1406857"}]}