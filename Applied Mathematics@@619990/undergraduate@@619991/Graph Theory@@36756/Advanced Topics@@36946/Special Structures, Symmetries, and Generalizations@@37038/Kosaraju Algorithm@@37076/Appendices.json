{"hands_on_practices": [{"introduction": "Kosaraju's algorithm hinges on two passes of Depth-First Search (DFS). The first pass, performed on the original graph $G$, is not just about visiting vertices, but about establishing a crucial ordering based on when the search finishes with each vertex. This exercise [@problem_id:1517012] provides essential practice in meticulously tracing a DFS to calculate these finishing times, a foundational skill for correctly implementing the algorithm.", "problem": "Consider a directed graph $G = (V, E)$ with a set of vertices $V = \\{v_0, v_1, v_2, v_3, v_4\\}$ and a set of directed edges $E$. The edges are defined as follows:\n- There is a central vertex $v_0$ that has outgoing edges to all other vertices.\n- The other vertices form a cycle, directed in a clockwise manner based on their indices.\nSpecifically, the set of edges is $E = \\{(v_0, v_1), (v_0, v_2), (v_0, v_3), (v_0, v_4), (v_1, v_2), (v_2, v_3), (v_3, v_4), (v_4, v_1)\\}$.\n\nWe will perform a Depth-First Search (DFS) on this graph $G$. The DFS procedure uses a global integer timer, which is initialized to 0.\n- When a vertex `u` is first discovered, its discovery time `d[u]` is recorded as the current value of the timer, and then the timer is incremented by 1.\n- After all neighbors of `u` have been visited, `u` is finished. Its finishing time `f[u]` is recorded as the current value of the timer, and then the timer is incremented by 1.\n\nThe DFS traversal follows these specific rules:\n1. The main DFS loop processes the vertices in the order of their indices: $v_0, v_1, v_2, v_3, v_4$. The first unvisited vertex in this sequence is chosen as the starting point for a new search tree.\n2. When exploring the neighbors of any given vertex, the neighbors are visited in increasing order of their vertex index. For example, from vertex $v_0$, the algorithm will attempt to visit $v_1$, then $v_2$, then $v_3$, and finally $v_4$.\n\nYour task is to determine the finishing times for all vertices $v_0, v_1, v_2, v_3, v_4$ after the DFS traversal is complete. Present your answer as a sequence of five integers, representing the finishing times of $v_0, v_1, v_2, v_3, v_4$ in that order.", "solution": "We perform a standard DFS with a global timer initialized to $t=0$. Upon discovering a vertex $u$, we set $d[u]=t$ and then update $t \\leftarrow t+1$. After finishing all neighbors of $u$, we set $f[u]=t$ and then update $t \\leftarrow t+1$. The main loop visits vertices in the order $v_{0},v_{1},v_{2},v_{3},v_{4}$, and adjacency lists are explored in increasing index order.\n\nStart with $v_{0}$ (unvisited), so we call $\\mathrm{DFS-Visit}(v_{0})$:\n- Discover $v_{0}$:\n$$d[v_{0}]=0,\\quad t\\leftarrow 1.$$\nExplore neighbors of $v_{0}$ in order $v_{1},v_{2},v_{3},v_{4}$.\n\nFrom $v_{0}$, visit $v_{1}$ (white):\n- Discover $v_{1}$:\n$$d[v_{1}]=1,\\quad t\\leftarrow 2.$$\nNeighbors of $v_{1}$: only $v_{2}$. Visit $v_{2}$ (white):\n- Discover $v_{2}$:\n$$d[v_{2}]=2,\\quad t\\leftarrow 3.$$\nNeighbors of $v_{2}$: only $v_{3}$. Visit $v_{3}$ (white):\n- Discover $v_{3}$:\n$$d[v_{3}]=3,\\quad t\\leftarrow 4.$$\nNeighbors of $v_{3}$: only $v_{4}$. Visit $v_{4}$ (white):\n- Discover $v_{4}$:\n$$d[v_{4}]=4,\\quad t\\leftarrow 5.$$\nNeighbors of $v_{4}$: only $v_{1}$, which is already discovered (gray), so no recursion. Finish $v_{4}$:\n$$f[v_{4}]=5,\\quad t\\leftarrow 6.$$\n\nReturn to $v_{3}$, no more neighbors. Finish $v_{3}$:\n$$f[v_{3}]=6,\\quad t\\leftarrow 7.$$\n\nReturn to $v_{2}$, no more neighbors. Finish $v_{2}$:\n$$f[v_{2}]=7,\\quad t\\leftarrow 8.$$\n\nReturn to $v_{1}$, no more neighbors. Finish $v_{1}$:\n$$f[v_{1}]=8,\\quad t\\leftarrow 9.$$\n\nBack to $v_{0}$, continue its neighbor list: $v_{2},v_{3},v_{4}$ are already finished (black), so no new visits. Finish $v_{0}$:\n$$f[v_{0}]=9,\\quad t\\leftarrow 10.$$\n\nThe main loop examines $v_{1},v_{2},v_{3},v_{4}$, all already visited, so DFS terminates. Therefore, the finishing times in the order $(v_{0},v_{1},v_{2},v_{3},v_{4})$ are\n$$f[v_{0}]=9,\\quad f[v_{1}]=8,\\quad f[v_{2}]=7,\\quad f[v_{3}]=6,\\quad f[v_{4}]=5.$$", "answer": "$$\\boxed{\\begin{pmatrix}9 & 8 & 7 & 6 & 5\\end{pmatrix}}$$", "id": "1517012"}, {"introduction": "The brilliance of Kosaraju's algorithm lies in how it connects its two main phases. The finishing times computed in the first DFS are not just arbitrary numbers; they dictate the precise order for starting new search trees in the second DFS on the transpose graph $G^T$. This problem [@problem_id:1517044] focuses squarely on this pivotal step, testing your understanding of how to correctly sequence the vertices for the second pass.", "problem": "Consider a directed graph $G = (V, E)$, where the set of vertices is $V = \\{A, B, C, D, E, F, G, H\\}$. The edges $E$ are given by the following adjacency list representation:\n\n- $A: B$\n- $B: C, E, F$\n- $C: D, G$\n- $D: C, H$\n- $E: A, F$\n- $F: G$\n- $G: F$\n- $H: D$\n\nIn the first phase of an algorithm to find the strongly connected components of this graph, a Depth First Search (DFS) is performed on $G$. The main loop of this DFS considers vertices in alphabetical order (A, then B, then C, etc.) to start new search trees if they have not yet been visited. After the DFS is complete, the finishing time for each vertex is recorded as follows:\n\n- $f(A) = 16$\n- $f(B) = 15$\n- $f(C) = 12$\n- $f(D) = 7$\n- $f(E) = 14$\n- $f(F) = 10$\n- $f(G) = 11$\n- $f(H) = 6$\n\nThe second phase of the algorithm involves performing a DFS on the transpose of the graph, $G^T$. The vertices are chosen as starting points for this second DFS in a specific order determined by the results from the first phase. What is the correct sequence of vertices to be used as starting points for the DFS traversals in this second phase?\n\nA. A, B, E, C, G, F, D, H\nB. A, B, C, D, E, F, G, H\nC. H, D, F, G, C, E, B, A\nD. C, G, F, D, H, A, E, B\nE. A, E, B, F, C, G, D, H", "solution": "In Kosarajuâ€™s algorithm, the first phase runs a DFS on $G$ and records finishing times $f(v)$ for each vertex $v$. The second phase runs a DFS on the transpose graph $G^{T}$, choosing new DFS start vertices in order of strictly decreasing finishing times from the first phase.\n\nFrom the given data,\n$f(A)=16$, $f(B)=15$, $f(E)=14$, $f(C)=12$, $f(G)=11$, $f(F)=10$, $f(D)=7$, $f(H)=6$.\nSorting vertices by decreasing $f$ gives the sequence\n$$A, B, E, C, G, F, D, H.$$\nThis matches option A.", "answer": "$$\\boxed{A}$$", "id": "1517044"}, {"introduction": "A true test of understanding an algorithm is to ask *why* it works and whether its steps can be altered. This thought experiment [@problem_id:1517055] challenges the standard sequence of Kosaraju's algorithm by proposing to run the first DFS on the transpose graph $G^T$ and the second on the original graph $G$. By analyzing this \"reversed\" procedure, you will gain a deeper insight into the logical necessity of the algorithm's specific design.", "problem": "An algorithm designer is working on finding the Strongly Connected Components (SCCs) of a directed graph $G=(V, E)$. They are familiar with Kosaraju's algorithm, which consists of the following steps:\n1.  Run a Depth First Search (DFS) on the graph $G$ to determine the finishing times (or a post-order traversal sequence) for all vertices.\n2.  Compute the transpose graph $G^T$, which is the graph $G$ with all its edges reversed.\n3.  Run a DFS on $G^T$, with the main loop processing vertices in decreasing order of their finishing times as determined in Step 1. Each tree in the resulting DFS forest corresponds to a distinct SCC of the original graph $G$.\n\nThe designer proposes a \"Reversed Kosaraju's Algorithm\" by swapping the roles of $G$ and $G^T$ in the main steps. The proposed algorithm is as follows:\n1.  Compute the transpose graph $G^T$.\n2.  Run a DFS on the transpose graph $G^T$ to determine the finishing times for all vertices.\n3.  Run a DFS on the original graph $G$, with the main loop processing vertices in decreasing order of their finishing times as determined in Step 2. The designer claims that each tree in this second DFS forest will correspond to a distinct SCC.\n\nWhich of the following statements accurately evaluates the correctness of this \"Reversed Kosaraju's Algorithm\"?\nA. Yes, this reversed algorithm is also a correct method for finding all Strongly Connected Components of any directed graph.\nB. No, this reversed algorithm fails for any directed graph that contains more than one Strongly Connected Component.\nC. No, this reversed algorithm is not correct because the processing order derived from $G^T$ does not guarantee that the DFS on $G$ will be confined to a single SCC for components processed after the first one.\nD. No, this reversed algorithm is not correct because a DFS on the original graph $G$ in the final step cannot utilize finishing times computed from the transpose graph $G^T$.", "solution": "The proposed \"Reversed Kosaraju's Algorithm\" is indeed correct. Let's analyze why by examining the properties of the condensation graph and DFS finishing times.\n\n1.  **First Pass on $G^T$**: The first DFS is performed on the transpose graph, $G^T$. Let $C(G)$ be the condensation graph of $G$, where each node represents an SCC. The condensation graph of the transpose, $C(G^T)$, is simply $C(G)$ with all its edges reversed. A key property of DFS is that for any directed acyclic graph (like a condensation graph), a DFS traversal ensures that if there's an edge from component $S_i$ to $S_j$, the maximum finishing time in $S_i$ will be greater than the maximum finishing time in $S_j$.\n\n2.  **Topological Sort**: When we run DFS on $G^T$, we are effectively creating a topological sort of its components in $C(G^T)$. If there is an edge $S_2 \\to S_1$ in $C(G^T)$, then the maximum finishing time in $S_2$ will be greater than the maximum finishing time in $S_1$ (i.e., $f_{G^T}(S_2) > f_{G^T}(S_1)$). Therefore, sorting the vertices in decreasing order of their finishing times from this pass will list vertices from the \"source\" components of $C(G^T)$ first.\n\n3.  **Source in $G^T$ is Sink in $G$**: A \"source\" component in $C(G^T)$ (one with no incoming edges from other components) corresponds to a \"sink\" component in $C(G)$ (one with no outgoing edges to other components). So, the processing order for the second pass starts with vertices from the sink components of the original graph $G$.\n\n4.  **Second Pass on $G$**: The second DFS is run on the original graph $G$, processing vertices in decreasing order of their $f_{G^T}$ times. This means we will start new DFS trees from vertices in the sink components of $G$ first. When we start a DFS from a vertex $v$ inside a sink SCC of $G$, the search can explore all of $v$'s SCC. However, because it is a sink component in $G$, there are no edges leading from this SCC to any other SCC. Thus, the search is naturally confined to this single SCC, correctly identifying it.\n\n5.  **Iterative Process**: After this sink SCC is identified and its vertices are marked as visited, the algorithm proceeds to the next unvisited vertex in the sorted list. This vertex will belong to a component that is a \"sink\" relative to the *remaining, unvisited* components. Any outgoing edges from its component must lead to vertices in the SCC(s) that were already found and marked as visited. Again, the DFS search on $G$ will be confined to the current component.\n\nThis logic holds for the entire process. The reversed algorithm correctly partitions the graph into its SCCs, just like the standard version. Therefore, the designer's proposal is correct.", "answer": "$$\\boxed{A}$$", "id": "1517055"}]}