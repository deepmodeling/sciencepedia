{"hands_on_practices": [{"introduction": "Topological sorting is fundamentally about ordering tasks based on their dependencies. Before we can generate these orderings, it's crucial to understand how to verify if a given sequence is valid. This first exercise provides a practical scenario of software module compilation and asks you to apply the core definition of a topological sort—that for every dependency from task $U$ to task $V$, $U$ must come before $V$—to check several proposed sequences for correctness. [@problem_id:1549706]", "problem": "A software project is divided into seven distinct modules: Setup (S), Core (C), User Interface (UI), Networking (N), Database (D), Analytics (A), and Logging (L). Due to compilation dependencies, some modules must be compiled before others. The complete set of direct dependencies is given as follows:\n- The `Core` module depends on the `Setup` module.\n- The `UI` module depends on the `Core` module.\n- The `Networking` module depends on the `Core` module.\n- The `Database` module depends on both the `UI` and `Networking` modules.\n- The `Analytics` module depends on the `Networking` module.\n- The `Logging` module depends on both the `Database` and `Analytics` modules.\n\nA build sequence is a linear ordering of all seven modules. A build sequence is considered valid if and only if for every dependency, the required module appears before the module that depends on it.\n\nYour task is to determine which of the following proposed build sequences are valid.\n\nA. `Setup, Core, UI, Networking, Analytics, Database, Logging`\n\nB. `Setup, Core, Database, UI, Networking, Analytics, Logging`\n\nC. `Setup, Core, Networking, UI, Analytics, Database, Logging`\n\nD. `Setup, Core, UI, Networking, Logging, Database, Analytics`\n\nE. `Setup, Networking, Core, UI, Analytics, Database, Logging`", "solution": "Let the modules be denoted by $S$ (Setup), $C$ (Core), $UI$ (User Interface), $N$ (Networking), $D$ (Database), $A$ (Analytics), and $L$ (Logging). The dependency constraints can be written as the strict inequalities:\n$$SC,$$\n$$CUI,\\quad CN,$$\n$$UID,\\quad ND,$$\n$$NA,$$\n$$DL,\\quad AL.$$\nA build sequence is valid if and only if all these inequalities hold with respect to the positions of the modules in the sequence. For a given proposed sequence, define $p(X)$ as the position index of module $X$ in that sequence (smaller $p(X)$ means earlier in the order). The sequence is valid if and only if each listed inequality is satisfied by the corresponding $p(\\cdot)$ values.\n\nSequence A: Setup, Core, UI, Networking, Analytics, Database, Logging.\nThus $p(S)=1$, $p(C)=2$, $p(UI)=3$, $p(N)=4$, $p(A)=5$, $p(D)=6$, $p(L)=7$. Check:\n$$p(S)p(C):\\ 12,$$\n$$p(C)p(UI):\\ 23,\\quad p(C)p(N):\\ 24,$$\n$$p(UI)p(D):\\ 36,\\quad p(N)p(D):\\ 46,$$\n$$p(N)p(A):\\ 45,$$\n$$p(D)p(L):\\ 67,\\quad p(A)p(L):\\ 57.$$\nAll constraints hold, so A is valid.\n\nSequence B: Setup, Core, Database, UI, Networking, Analytics, Logging.\nThus $p(S)=1$, $p(C)=2$, $p(D)=3$, $p(UI)=4$, $p(N)=5$, $p(A)=6$, $p(L)=7$. Check $p(UI)p(D)$ requires $43$, which is false. Therefore B violates $UID$ (and also $ND$), so B is invalid.\n\nSequence C: Setup, Core, Networking, UI, Analytics, Database, Logging.\nThus $p(S)=1$, $p(C)=2$, $p(N)=3$, $p(UI)=4$, $p(A)=5$, $p(D)=6$, $p(L)=7$. Check:\n$$p(S)p(C):\\ 12,$$\n$$p(C)p(UI):\\ 24,\\quad p(C)p(N):\\ 23,$$\n$$p(UI)p(D):\\ 46,\\quad p(N)p(D):\\ 36,$$\n$$p(N)p(A):\\ 35,$$\n$$p(D)p(L):\\ 67,\\quad p(A)p(L):\\ 57.$$\nAll constraints hold, so C is valid.\n\nSequence D: Setup, Core, UI, Networking, Logging, Database, Analytics.\nThus $p(S)=1$, $p(C)=2$, $p(UI)=3$, $p(N)=4$, $p(L)=5$, $p(D)=6$, $p(A)=7$. Check $p(D)p(L)$ requires $65$, which is false, and $p(A)p(L)$ requires $75$, which is false. Therefore D is invalid.\n\nSequence E: Setup, Networking, Core, UI, Analytics, Database, Logging.\nThus $p(S)=1$, $p(N)=2$, $p(C)=3$, $p(UI)=4$, $p(A)=5$, $p(D)=6$, $p(L)=7$. Check $p(C)p(N)$ requires $32$, which is false. Therefore E is invalid.\n\nTherefore, the valid build sequences among the options are A and C.", "answer": "$$\\boxed{AC}$$", "id": "1549706"}, {"introduction": "Now that we can verify a topological sort, let's explore the structural properties of the graph that constrain these orderings. Which tasks can possibly start the entire project, and which can be the very last to finish? This practice guides you to connect a vertex's role in the graph (its in-degree and out-degree) to its potential position in a valid sequence, introducing the critical concepts of source and sink nodes. [@problem_id:1549724]", "problem": "Consider a Directed Acyclic Graph (DAG) defined by a set of vertices $V = \\{A, B, C, D, E, F, G, H\\}$ and a set of directed edges $E = \\{(A, B), (A, C), (B, D), (C, D), (D, F), (E, C), (E, G), (G, H)\\}$. A topological sort of a DAG is a linear ordering of its vertices such that for every directed edge from vertex $u$ to vertex $v$, vertex $u$ comes before vertex $v$ in the ordering.\n\nLet $S_{first}$ be the set of all vertices that can appear first in at least one valid topological sort of the given graph. Let $S_{last}$ be the set of all vertices that can appear last in at least one valid topological sort.\n\nIdentify the correct sets for $S_{first}$ and $S_{last}$ from the options below.\n\nA. $S_{first} = \\{A, E\\}$ and $S_{last} = \\{F, H\\}$\n\nB. $S_{first} = \\{A\\}$ and $S_{last} = \\{H\\}$\n\nC. $S_{first} = \\{A, E\\}$ and $S_{last} = \\{D, F, H\\}$\n\nD. $S_{first} = \\{E\\}$ and $S_{last} = \\{F\\}$\n\nE. $S_{first} = \\{A, B, E\\}$ and $S_{last} = \\{D, F, H\\}$", "solution": "A topological ordering is a linear order consistent with all directed edges. Two fundamental properties used here are:\n1) In any topological ordering, the first vertex must be a source, i.e., a vertex with no incoming edges. Formally, if a vertex $v$ appears first and there exists an edge $(u,v)$, then $u$ must appear before $v$, which is impossible. Hence only vertices with $\\deg^{-}(v)=0$ can be first.\n2) In any topological ordering, the last vertex must be a sink, i.e., a vertex with no outgoing edges. If a vertex $v$ appears last and there exists an edge $(v,w)$, then $v$ must appear before $w$, which is impossible. Hence only vertices with $\\deg^{+}(v)=0$ can be last.\n\nCompute in-degrees using $E=\\{(A,B),(A,C),(B,D),(C,D),(D,F),(E,C),(E,G),(G,H)\\}$:\n- $\\deg^{-}(A)=0$ since no edge enters $A$.\n- $\\deg^{-}(B)=1$ from $(A,B)$.\n- $\\deg^{-}(C)=2$ from $(A,C)$ and $(E,C)$.\n- $\\deg^{-}(D)=2$ from $(B,D)$ and $(C,D)$.\n- $\\deg^{-}(E)=0$ since no edge enters $E$.\n- $\\deg^{-}(F)=1$ from $(D,F)$.\n- $\\deg^{-}(G)=1$ from $(E,G)$.\n- $\\deg^{-}(H)=1$ from $(G,H)$.\n\nThus the sources are exactly $\\{A,E\\}$, so $S_{first}=\\{A,E\\}$. Each source can appear first by choosing it as the initial vertex in Kahn’s algorithm.\n\nCompute out-degrees:\n- $\\deg^{+}(A)=2$ to $B$ and $C$.\n- $\\deg^{+}(B)=1$ to $D$.\n- $\\deg^{+}(C)=1$ to $D$.\n- $\\deg^{+}(D)=1$ to $F$.\n- $\\deg^{+}(E)=2$ to $C$ and $G$.\n- $\\deg^{+}(F)=0$.\n- $\\deg^{+}(G)=1$ to $H$.\n- $\\deg^{+}(H)=0$.\n\nThus the sinks are exactly $\\{F,H\\}$, so $S_{last}=\\{F,H\\}$. Any sink can be placed last because for a sink $s$, any topological order of $V\\setminus\\{s\\}$ extended by appending $s$ remains valid (there are no edges leaving $s$ to violate the order).\n\nComparing with the options, this corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1549724"}, {"introduction": "In many real-world applications, such as build systems or project plans, ambiguity is undesirable; we often need a single, deterministic sequence of tasks. This final, more advanced practice challenges you to think like a system designer: how can we modify a dependency graph to ensure there is only one possible topological sort? This exercise reveals the deep connection between a unique topological sort and the existence of a Hamiltonian path in the graph, pushing you to synthesize multiple graph theory concepts to solve a practical design problem. [@problem_id:1549737]", "problem": "In project management and computer science, a set of tasks with dependencies among them can be modeled as a Directed Acyclic Graph (DAG), where vertices represent tasks and a directed edge from task $U$ to task $V$ means $U$ must be completed before $V$ can begin. A topological sort of this DAG gives a valid linear sequence in which the tasks can be executed.\n\nA software development project consists of eight distinct modules that need to be compiled. The dependencies between these modules are given as follows:\n- Module `M1` must be compiled before module `M3`.\n- Module `M2` must be compiled before module `M3`.\n- Module `M3` must be compiled before module `M4`.\n- Module `M3` must be compiled before module `M5`.\n- Module `M4` must be compiled before module `M6`.\n- Module `M5` must be compiled before module `M6`.\n- Module `M6` must be compiled before module `M7`.\n- Module `M6` must be compiled before module `M8`.\n\nFor the build process to be fully deterministic and reproducible without ambiguity, there must be exactly one unique topological sort for the dependency graph. Your task is to determine the minimum number of additional dependencies (new directed edges) that must be added to the graph to guarantee that it has a unique topological sort. The new edges must not create any cycles.", "solution": "Let $G=(V,E)$ be the given DAG with $V=\\{M_{1},\\dots,M_{8}\\}$ and edges\n$$\nE=\\{M_{1}\\to M_{3},\\,M_{2}\\to M_{3},\\,M_{3}\\to M_{4},\\,M_{3}\\to M_{5},\\,M_{4}\\to M_{6},\\,M_{5}\\to M_{6},\\,M_{6}\\to M_{7},\\,M_{6}\\to M_{8}\\}.\n$$\nA DAG has a unique topological order if and only if, in that order $(v_{1},\\dots,v_{n})$, every consecutive pair satisfies $v_{i}\\to v_{i+1}\\in E$; equivalently, the graph contains a directed Hamiltonian path through all vertices. Necessity: if the order is unique and $v_{i}$ and $v_{i+1}$ were not joined by a direct edge, then there is no path of length at least $2$ from $v_{i}$ to $v_{i+1}$ (that would require an intermediate vertex between them), so $v_{i}$ and $v_{i+1}$ would be incomparable and could be swapped, contradicting uniqueness. Sufficiency: if the graph contains edges $v_{1}\\to v_{2}\\to\\cdots\\to v_{n}$, then for all $ij$ there is a path $v_{i}\\to v_{j}$, so the reachability relation is a total order and the topological order is unique.\n\nThus we must add edges to create a single directed path through all $M_{i}$ without cycles, using only edges consistent with the partial order. Consider the valid linear extension\n$$\n(M_{1},\\,M_{2},\\,M_{3},\\,M_{4},\\,M_{5},\\,M_{6},\\,M_{7},\\,M_{8}).\n$$\nFor uniqueness, we need edges between each consecutive pair. The existing edges already include $M_{2}\\to M_{3}$, $M_{3}\\to M_{4}$, $M_{5}\\to M_{6}$, and $M_{6}\\to M_{7}$. The missing consecutive edges for this order are\n$$\nM_{1}\\to M_{2},\\quad M_{4}\\to M_{5},\\quad M_{7}\\to M_{8}.\n$$\nAdding these three edges yields the Hamiltonian path\n$$\nM_{1}\\to M_{2}\\to M_{3}\\to M_{4}\\to M_{5}\\to M_{6}\\to M_{7}\\to M_{8},\n$$\nwhich imposes a total order and hence guarantees a unique topological sort. These additions do not create cycles because each added edge connects a previously incomparable pair: initially, $M_{1}$ and $M_{2}$ are both sources (no path between them), $M_{4}$ and $M_{5}$ are incomparable siblings under $M_{3}$, and $M_{7}$ and $M_{8}$ are sinks (no path between them).\n\nMinimality: at least one edge is necessary to compare $M_{1}$ and $M_{2}$; otherwise there are two initial zero in-degree vertices and at least two topological orders differing by their swap. Similarly, at least one edge is necessary to compare $M_{4}$ and $M_{5}$, and at least one to compare $M_{7}$ and $M_{8}$. No single added edge can simultaneously render two of these pairs comparable without creating a cycle, because any path attempting to compare $M_{4}$ and $M_{5}$ would have to go through $M_{6}$ (which would require reversing an existing edge), and any path attempting to compare $M_{1}$ and $M_{2}$ would have to go through $M_{3}$ (which is after both). Hence at least three added edges are required. Since three edges suffice as shown, the minimum number is $3$.", "answer": "$$\\boxed{3}$$", "id": "1549737"}]}