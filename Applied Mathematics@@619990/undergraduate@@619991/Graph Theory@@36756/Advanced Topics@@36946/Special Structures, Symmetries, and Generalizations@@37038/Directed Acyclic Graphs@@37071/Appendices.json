{"hands_on_practices": [{"introduction": "The most fundamental property of a Directed Acyclic Graph (DAG) is the complete absence of directed cycles. In practical applications like scheduling tasks or resolving dependencies, a cycle represents a logical paradox: a task that must be completed before itself. This first exercise challenges you to analyze a set of software build dependencies to determine if they form a valid, workable plan or if a hidden cyclic dependency makes the project impossible as stated [@problem_id:1496996].", "problem": "A project manager at a software company is planning the build process for a new microservices-based application. The application consists of six distinct modules: `Auth`, `Billing`, `Catalog`, `Delivery`, `Frontend`, and `Orders`. The build process is governed by a set of dependencies, where one module must be compiled and deployed before another. These dependencies are given as a set of ordered pairs `(U, V)`, which signifies that module `U` must be successfully built before the build for module `V` can begin.\n\nThe complete set of dependencies, `D`, for this project is:\n`D = {(Frontend, Auth), (Auth, Orders), (Orders, Billing), (Catalog, Frontend), (Billing, Auth), (Orders, Delivery)}`\n\nAnalyze this set of dependencies to determine the structural properties of the project's build process. Which of the following statements accurately describes the situation?\n\nA. The dependencies are valid and a possible build order is: `Catalog, Frontend, Auth, Orders, Billing, Delivery`.\n\nB. The dependencies are valid and a possible build order is: `Catalog, Frontend, Auth, Orders, Delivery, Billing`.\n\nC. The dependencies contain a logical contradiction, specifically forming a cycle of length 3.\n\nD. The dependencies contain a logical contradiction, specifically forming a cycle of length 4.\n\nE. The set of dependencies is valid, but multiple distinct build orders are possible.", "solution": "Define the directed graph $G=(V,E)$ where $V=\\{\\text{Auth}, \\text{Billing}, \\text{Catalog}, \\text{Delivery}, \\text{Frontend}, \\text{Orders}\\}$ and $E=D=\\{(\\text{Frontend}, \\text{Auth}), (\\text{Auth}, \\text{Orders}), (\\text{Orders}, \\text{Billing}), (\\text{Catalog}, \\text{Frontend}), (\\text{Billing}, \\text{Auth}), (\\text{Orders}, \\text{Delivery})\\}$. A valid build order exists if and only if $G$ is a directed acyclic graph; equivalently, if and only if there is no directed cycle, in which case a topological ordering exists.\n\nFrom $E$, observe the three edges\n$$(\\text{Auth}, \\text{Orders}),\\quad (\\text{Orders}, \\text{Billing}),\\quad (\\text{Billing}, \\text{Auth}).$$\nThese imply the directed cycle\n$$\\text{Auth} \\to \\text{Orders} \\to \\text{Billing} \\to \\text{Auth},$$\nwhich is a cycle of length $3$. Therefore, $G$ is not acyclic and no topological ordering exists. Consequently:\n- Any proposed concrete build order (such as those in options A and B) cannot satisfy all dependencies; for example, both list $\\text{Auth}$ before $\\text{Billing}$, violating $(\\text{Billing}, \\text{Auth})$.\n- Since there is a cycle, the dependency set is not valid, so it is not the case that the set is valid with multiple distinct build orders.\n\nThus, the correct description is that the dependencies contain a logical contradiction forming a cycle of length $3$, which matches option C.", "answer": "$$\\boxed{C}$$", "id": "1496996"}, {"introduction": "Once you have a valid DAG, you can perform powerful structural analyses, such as understanding how many different ways there are to get from a start to an end point. This practice introduces a dynamic programming approach to count all distinct paths through a microservice architecture, a core technique for network routing and process analysis. By working through this problem, you'll see how the acyclic nature of the graph allows for an elegant and efficient counting method [@problem_id:1496941].", "problem": "A team of software engineers is designing the architecture for a new application. The architecture is composed of several microservices that have specific dependencies on each other, forming a Directed Acyclic Graph (DAG). A data packet must travel from an initial service to a final service through a valid sequence of connected services. A valid path is a sequence of services $s_1, s_2, \\dots, s_k$ where data can flow from $s_i$ to $s_{i+1}$ for all $i=1, \\dots, k-1$.\n\nThe system has a single entry point, the `Start` service, and a single exit point, the `End` service. The dependencies are as follows:\n\n- The `Start` service directs data to the `Auth`, `UI`, and `API` services.\n- The `Auth` service is a prerequisite for both the `DB_Read` and `DB_Write` services.\n- The `UI` service is a prerequisite for both the `DB_Read` and `DB_Write` services.\n- The `API` service is a prerequisite for both the `DB_Read` and `DB_Write` services.\n- The `DB_Read` service is a prerequisite for both the `Analytics` and `Processing` services.\n- The `DB_Write` service is a prerequisite for both the `Analytics` and `Processing` services.\n- The `Analytics` service is a prerequisite for the `End` service.\n- The `Processing` service is a prerequisite for the `End` service.\n\nCalculate the total number of distinct paths a data packet can take to travel from the `Start` service to the `End` service.", "solution": "We model the microservice dependencies as a directed acyclic graph and count directed paths from the unique source to the unique sink using dynamic programming on a topological order. Let $P(v)$ denote the number of distinct directed paths from $\\text{Start}$ to a node $v$. The fundamental principle is that for any node $v$ (other than the source), the number of paths into $v$ equals the sum of path counts into its immediate predecessors:\n$$\nP(v)=\\sum_{u \\in \\operatorname{pred}(v)} P(u).\n$$\nThe base case is the source:\n$$\nP(\\text{Start})=1.\n$$\nFrom the given edges, the predecessors are:\n- $\\operatorname{pred}(\\text{Auth})=\\{\\text{Start}\\}$, $\\operatorname{pred}(\\text{UI})=\\{\\text{Start}\\}$, $\\operatorname{pred}(\\text{API})=\\{\\text{Start}\\}$,\n- $\\operatorname{pred}(\\text{DB\\_Read})=\\{\\text{Auth},\\text{UI},\\text{API}\\}$, $\\operatorname{pred}(\\text{DB\\_Write})=\\{\\text{Auth},\\text{UI},\\text{API}\\}$,\n- $\\operatorname{pred}(\\text{Analytics})=\\{\\text{DB\\_Read},\\text{DB\\_Write}\\}$, $\\operatorname{pred}(\\text{Processing})=\\{\\text{DB\\_Read},\\text{DB\\_Write}\\}$,\n- $\\operatorname{pred}(\\text{End})=\\{\\text{Analytics},\\text{Processing}\\}$.\n\nCompute path counts layer by layer:\n$$\nP(\\text{Auth})=P(\\text{Start})=1,\\quad P(\\text{UI})=P(\\text{Start})=1,\\quad P(\\text{API})=P(\\text{Start})=1.\n$$\n$$\nP(\\text{DB\\_Read})=P(\\text{Auth})+P(\\text{UI})+P(\\text{API})=1+1+1=3,\n$$\n$$\nP(\\text{DB\\_Write})=P(\\text{Auth})+P(\\text{UI})+P(\\text{API})=1+1+1=3.\n$$\n$$\nP(\\text{Analytics})=P(\\text{DB\\_Read})+P(\\text{DB\\_Write})=3+3=6,\n$$\n$$\nP(\\text{Processing})=P(\\text{DB\\_Read})+P(\\text{DB\\_Write})=3+3=6.\n$$\nFinally,\n$$\nP(\\text{End})=P(\\text{Analytics})+P(\\text{Processing})=6+6=12.\n$$\nTherefore, the total number of distinct paths from $\\text{Start}$ to $\\text{End}$ is $12$.", "answer": "$$\\boxed{12}$$", "id": "1496941"}, {"introduction": "Real-world problems often involve more than just connections; they involve costs, time, or distances. By adding weights to the edges of a DAG, we can model these factors and search for optimal paths. This exercise demonstrates a critical distinction: the path with the fewest steps is not always the fastest or most efficient. You will compare the structurally simplest path with the fastest path in a project workflow, highlighting the importance of weighted analysis in optimization problems [@problem_id:1497000].", "problem": "A project manager is analyzing a project's workflow, which can be modeled as a weighted Directed Acyclic Graph (DAG). In this model, vertices represent milestones, and a directed edge from milestone $U$ to milestone $V$ with a weight $w$ signifies a task that must be completed to get from $U$ to $V$, requiring $w$ hours to finish.\n\nThe project starts at a source milestone $S$ and is completed at a sink milestone $T$. The graph is defined by the set of vertices $V = \\{S, A, B, C, T\\}$ and the following set of directed edges with their corresponding time requirements in hours:\n- An edge from $S$ to $A$ with a weight of 8.\n- An edge from $S$ to $B$ with a weight of 3.\n- An edge from $A$ to $T$ with a weight of 4.\n- An edge from $B$ to $C$ with a weight of 2.\n- An edge from $C$ to $T$ with a weight of 5.\n\nThe manager is interested in comparing two distinct types of paths from the start milestone $S$ to the completion milestone $T$:\n1. The \"structurally simplest path,\" defined as the path that consists of the minimum number of sequential tasks (i.e., the minimum number of edges).\n2. The \"fastest path,\" defined as the path that takes the minimum total time to complete (i.e., the minimum sum of edge weights).\n\nCalculate the absolute difference in total hours between the structurally simplest path and the fastest path. Express your answer in hours.", "solution": "We list all directed paths from $S$ to $T$ and compute both the number of edges (for structural simplicity) and the total time (sum of weights) for each.\n\nPath $P_{1}: S \\rightarrow A \\rightarrow T$.\n- Number of edges: $2$.\n- Total time: $w(S,A)+w(A,T)=8+4=12$.\n\nPath $P_{2}: S \\rightarrow B \\rightarrow C \\rightarrow T$.\n- Number of edges: $3$.\n- Total time: $w(S,B)+w(B,C)+w(C,T)=3+2+5=10$.\n\nBy definition, the structurally simplest path is the one with the minimum number of edges, which is $P_{1}$ with $2$ edges and total time $12$.\n\nThe fastest path is the one with the minimum total time, which is $P_{2}$ with total time $10$.\n\nThe required absolute difference in total hours is\n$$|12-10|=2.$$", "answer": "$$\\boxed{2}$$", "id": "1497000"}]}