{"hands_on_practices": [{"introduction": "The way we represent a graph in memory has a profound impact on the efficiency of algorithms that operate on it. This first exercise explores this fundamental principle by analyzing a task on a graph given in the common adjacency list format. By determining the most efficient way to find all \"stand-alone\" or isolated vertices, you will derive the cornerstone $O(V+E)$ complexity that serves as a baseline for many graph traversal algorithms. [@problem_id:1480481]", "problem": "A system architect is analyzing a large-scale network of microservices. The network consists of $V$ distinct microservices, identified by integers from $0$ to $V-1$. Communication between these services is facilitated by $E$ one-way, directed communication channels. A channel from service $u$ to service $v$ allows $u$ to send data to $v$, but not vice versa.\n\nThe entire network topology is provided to you in an adjacency list format. This consists of an array of $V$ lists, where the $i$-th list contains the identifiers of all services that service $i$ can directly send data to. The sum of the lengths of all these lists is equal to $E$.\n\nYour task is to identify all \"stand-alone\" microservices. A microservice is defined as stand-alone if and only if it has a total degree of zero, meaning it neither sends data to any other service nor receives data from any other service.\n\nWhat is the tightest worst-case time complexity of the most efficient algorithm to find all stand-alone services, as a function of $V$ and $E$?\n\nA) $O(V)$\n\nB) $O(E)$\n\nC) $O(V+E)$\n\nD) $O(V \\cdot E)$\n\nE) $O(V \\log V + E)$\n\nF) $O(V^2)$", "solution": "We are given a directed graph on $V$ vertices with $E$ edges in adjacency list form. A vertex is stand-alone if it has total degree zero, i.e., both in-degree and out-degree are zero. To find all such vertices efficiently, proceed as follows.\n\nInitialize two arrays for degrees: for each vertex $i \\in \\{0,\\dots,V-1\\}$, set $\\text{indeg}[i]=0$ and compute $\\text{outdeg}[i]=|\\text{Adj}[i]|$ by reading the list for $i$. For each edge encountered while scanning the adjacency lists, say $(i \\rightarrow v)$ where $v$ appears in $\\text{Adj}[i]$, increment $\\text{indeg}[v]$ by $1$. After completing the scan, declare $i$ stand-alone if and only if $\\text{indeg}[i]=0$ and $\\text{outdeg}[i]=0$; this requires a final pass over all $V$ vertices.\n\nCorrectness follows from the definitions: the out-degree is equal to the length of the adjacency list, and the in-degree is the count of incoming edges, which we compute by visiting each edge exactly once and incrementing the destinationâ€™s in-degree.\n\nLet $T(V,E)$ denote the running time. Scanning all $V$ adjacency lists to obtain out-degrees takes time proportional to the total number of list headers plus their elements, which is $O(V+E)$. While scanning, we process each of the $E$ edges once to accumulate in-degrees, which is $O(E)$. The final pass over all $V$ vertices to collect stand-alone vertices is $O(V)$. Therefore,\n$$\nT(V,E)=O(V)+O(E)+O(V)=O(V+E).\n$$\n\nThis is tight in the worst case. Any algorithm must at least inspect each adjacency list to determine whether it is empty, which is $\\Omega(V)$, and must also account for all $E$ edges to determine in-degrees, which is $\\Omega(E)$. Hence there is a lower bound\n$$\nT(V,E)=\\Omega(V+E),\n$$\nand combined with the upper bound, the optimal worst-case complexity is\n$$\nT(V,E)=\\Theta(V+E).\n$$\n\nAmong the given choices, this corresponds to $O(V+E)$.", "answer": "$$\\boxed{C}$$", "id": "1480481"}, {"introduction": "While general complexity bounds are useful, we can often achieve a more precise analysis by leveraging the specific properties of the graph in question. This practice demonstrates this concept using a tree, a fundamental structure in computer science and network design. You will analyze an elegant two-step algorithm to find a tree's diameter, and in doing so, see how the property that a tree with $V$ vertices has exactly $V-1$ edges allows us to simplify the general $O(V+E)$ complexity to a tighter, more informative bound. [@problem_id:1480548]", "problem": "In the design of a fault-tolerant, decentralized computing network, the nodes are connected to form a tree structure. This topology ensures connectivity with no redundant links. A critical performance metric for this network is its \"communication diameter,\" defined as the maximum number of hops (edges) in the shortest path between any two nodes.\n\nTo determine this diameter, the following two-step procedure is implemented:\n1.  An arbitrary starting node, `s`, performs a network-wide query to identify the node `u` that is farthest from it. This query is implemented using a Breadth-First Search (BFS), where \"farthest\" is defined by the greatest number of hops.\n2.  The identified node `u` then initiates its own BFS to find the node `v` that is, in turn, farthest from it. The distance between `u` and `v` is declared as the network's communication diameter.\n\nThe network is modeled as a connected, unweighted graph with $V$ nodes and $E$ edges. Given that this graph is a tree, determine the tightest possible worst-case time complexity for this entire two-step procedure. Express your answer in Big-O notation as a function of $V$ and/or $E$.", "solution": "We model the network as a connected, unweighted tree with $V$ nodes and $E$ edges. For any tree, the structural identity $E=V-1$ holds by definition (connected and acyclic).\n\nBreadth-First Search (BFS), implemented with adjacency lists, visits each vertex and each edge at most once. Therefore, the time complexity of a single BFS is\n$$\nT_{\\text{BFS}}(V,E)=\\Theta(V+E)=O(V+E).\n$$\nStep 1 performs one BFS from $s$ to find the farthest node $u$, costing $O(V+E)$. Step 2 performs another BFS from $u$ to find the farthest node $v$, again costing $O(V+E)$. Thus, the total time is\n$$\nT_{\\text{total}}(V,E)=T_{\\text{BFS}}(V,E)+T_{\\text{BFS}}(V,E)=O\\big((V+E)+(V+E)\\big)=O(V+E).\n$$\nBecause the graph is a tree, we substitute $E=V-1$ to obtain\n$$\nT_{\\text{total}}(V,E)=O\\big(V+(V-1)\\big)=O(2V-1)=O(V).\n$$\nThis $O(V)$ bound is the tightest possible worst-case complexity for the given two-step procedure on a tree.", "answer": "$$\\boxed{O(V)}$$", "id": "1480548"}, {"introduction": "Many complex algorithms are built by using simpler algorithms, like Breadth-First Search (BFS) or Depth-First Search (DFS), as subroutines. A key skill for an algorithm designer is to analyze the cost of a single call to such a subroutine within a larger context. This final exercise challenges you to do just that in the context of bipartite matching, where you will compare the complexities of BFS and DFS for finding a single augmenting path, highlighting the efficiency of standard graph traversals even when applied to advanced problems. [@problem_id:1480488]", "problem": "In a large-scale logistics system, tasks must be assigned to available autonomous agents. This scenario is modeled using a bipartite graph $G = (U \\cup V, E)$, where $U$ is the set of tasks and $V$ is the set of agents. An edge $(u, v)$ exists if agent $v$ is capable of performing task $u$. A set of assignments corresponds to a matching $M \\subseteq E$, which is a set of edges with no common vertices. An assignment is considered *maximal* when no more assignments can be immediately added, but it might not be of the largest possible size.\n\nTo improve a non-optimal matching $M$, one can find an *augmenting path*. An alternating path is a simple path in the graph whose edges alternate between being in the matching $M$ and not in the matching $E \\setminus M$. An augmenting path is an alternating path that starts at a free (unmatched) vertex in $U$ and ends at a free vertex in $V$.\n\nAn analyst is tasked with implementing a routine to find just one such augmenting path. Two approaches are considered, both starting from a single specified free task $s \\in U$:\n\n1.  **BFS-based search**: Perform a single Breadth-First Search (BFS) to find a path from $s$ to any free agent in $V$. The search must respect the alternating path constraint: from a task vertex, traverse only an edge not in $M$; from an agent vertex, traverse only an edge in $M$.\n2.  **DFS-based search**: Perform a single Depth-First Search (DFS) with the same alternating path constraints.\n\nLet $n = |U| + |V|$ be the total number of vertices and $m = |E|$ be the total number of edges in the graph. Assume that standard, efficient implementations of BFS and DFS are used, where each vertex and edge is processed at most a constant number of times during a single search.\n\nWhat are the tightest worst-case time complexities for the BFS-based search ($C_{BFS}$) and the DFS-based search ($C_{DFS}$) to find one augmenting path starting from $s$?\n\nA. $C_{BFS} = O(n+m)$ and $C_{DFS} = O(n \\cdot m)$\n\nB. $C_{BFS} = O(m)$ and $C_{DFS} = O(n \\cdot m)$\n\nC. $C_{BFS} = O(m)$ and $C_{DFS} = O(n+m)$\n\nD. $C_{BFS} = O(n+m)$ and $C_{DFS} = O(n+m)$\n\nE. $C_{BFS} = O(n+m)$ and $C_{DFS} = O(m \\log n)$\n\nF. $C_{BFS} = O(n^2)$ and $C_{DFS} = O(m^2)$", "solution": "We formalize the alternating-path search as a graph traversal on a directed version of the bipartite graph induced by the current matching $M$. Construct an implicit directed graph $G'$ over the same vertex set $U \\cup V$ with the following directed edges:\n- For each unmatched edge $\\{u,v\\} \\in E \\setminus M$ with $u \\in U$, add a directed edge $u \\to v$ (allowed move from a task to an agent).\n- For each matched edge $\\{u,v\\} \\in M$ with $v \\in V$, add a directed edge $v \\to u$ (allowed move from an agent to a task).\n\nAn alternating path for $M$ starting at a free task $s \\in U$ is precisely a directed path in $G'$ starting from $s$. An augmenting path corresponds to such a path that ends at a free agent in $V$.\n\nFor a single traversal (either BFS or DFS) starting from $s$, under a standard implementation that maintains a visited set and iterates adjacency lists once, the key property is:\n- Each vertex is enqueued/stack-pushed at most once.\n- Each directed edge is examined at most a constant number of times.\n\nBecause $G'$ has the same vertex set as $G$, the number of vertices is $n = |U| + |V|$. Each undirected edge in $E$ contributes at most one directed edge in $G'$ relevant to the traversal at any step (either $u \\to v$ for unmatched edges or $v \\to u$ for matched edges), and thus the number of directed edges examined is $O(m)$ overall. Therefore, both BFS and DFS on $G'$ have worst-case time complexity bounded by visiting all vertices and exploring all relevant directed edges, yielding:\n$$\nC_{BFS} = O(n + m), \\quad C_{DFS} = O(n + m).\n$$\n\nThese bounds are tight in the worst case because there exist instances where the search explores the entire reachable subgraph before either finding a free agent or concluding none is reachable, requiring inspection of $\\Theta(n + m)$ total elements.\n\nNote: The higher $O(n \\cdot m)$ bounds arise when repeatedly performing multiple DFS searches from different free tasks across phases (as in naive augmenting matching algorithms), but the problem explicitly restricts to a single BFS or a single DFS starting from a fixed $s$, with standard implementations that process each vertex and edge a constant number of times. Hence the tightest worst-case bounds for a single search are $O(n + m)$ for both.", "answer": "$$\\boxed{D}$$", "id": "1480488"}]}