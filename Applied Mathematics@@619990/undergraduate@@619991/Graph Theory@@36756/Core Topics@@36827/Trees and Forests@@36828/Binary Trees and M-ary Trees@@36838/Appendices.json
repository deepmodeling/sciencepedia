{"hands_on_practices": [{"introduction": "Understanding the relationship between a tree's height, branching factor, and total vertices is fundamental to designing efficient data structures. When storing a large dataset in an m-ary tree, we often want to minimize the tree's height to ensure fast access times. This first exercise [@problem_id:1483741] challenges you to apply this principle by calculating the minimum possible height for a tree given a required number of vertices, reinforcing the quantitative trade-offs involved in tree design.", "problem": "In graph theory, an *m-ary tree* is a rooted tree where each node has no more than $m$ children. The *height* of a rooted tree is defined as the number of edges on the longest path from the root node to a leaf node. The root is at level 0. What is the minimum possible height of a 5-ary tree (where $m=5$) that contains at least 2000 total vertices?", "solution": "An $m$-ary rooted tree of height $h$ has at most the number of vertices obtained by filling every level completely up to level $h$. The level counts are $1, m, m^{2}, \\ldots, m^{h}$, so the maximal total number of vertices for height $h$ is the geometric series\n$$\nT_{m}(h)=\\sum_{i=0}^{h} m^{i}=\\frac{m^{h+1}-1}{m-1}.\n$$\nTo minimize the height for a given number of vertices $N$, we must ensure that the maximal capacity at that height is at least $N$, since no $m$-ary tree of height $h$ can exceed $T_{m}(h)$ vertices. Therefore, the minimum height $h$ satisfies\n$$\nT_{5}(h)=\\frac{5^{h+1}-1}{4}\\geq 2000.\n$$\nThis inequality is equivalent to\n$$\n5^{h+1}\\geq 4\\cdot 2000+1=8001.\n$$\nWe compare powers of $5$:\n$$\n5^{5}=3125<8001<15625=5^{6}.\n$$\nThus the smallest integer $h+1$ satisfying the inequality is $6$, which gives $h=5$. Therefore, the minimum possible height is $5$.", "answer": "$$\\boxed{5}$$", "id": "1483741"}, {"introduction": "While visualizing a tree is intuitive, in computational applications they are often represented linearly through traversal sequences. A key skill is the ability to reconstruct the tree's two-dimensional structure from these one-dimensional representations. This next practice [@problem_id:1483739] is a classic puzzle that guides you through the logic of rebuilding a binary tree from its in-order and post-order traversals, a process fundamental to parsing and data serialization.", "problem": "In the study of data structures, a binary tree can be uniquely determined if both its in-order and post-order traversal sequences are known. Consider a binary tree with seven distinct nodes, labeled with characters. The sequence of nodes visited during an in-order traversal is found to be `D, B, E, A, F, C, G`, and the sequence from a post-order traversal is `D, E, B, F, G, C, A`.\n\nFrom this information, determine the correct pre-order traversal sequence for this binary tree.\n\nPlease select your answer from the following options:\n\nA. `A, B, D, E, C, F, G`\n\nB. `A, C, G, F, B, E, D`\n\nC. `D, E, B, F, G, C, A`\n\nD. `D, B, E, A, F, C, G`\n\nE. `A, B, C, D, E, F, G`\n\nF. `G, C, F, A, E, B, D`", "solution": "We use the properties of tree traversals:\n1) In post-order, the last element is the root. Given post-order $D, E, B, F, G, C, A$, the root is $A$.\n2) In in-order, elements to the left of the root are in the left subtree, and elements to the right are in the right subtree. Given in-order $D, B, E, A, F, C, G$, we split at $A$ to obtain:\n$$\\text{in-order left} = D, B, E \\quad \\text{and} \\quad \\text{in-order right} = F, C, G.$$\nThe post-order splits accordingly into the left and right subtrees (preserving order) before the last element $A$:\n$$\\text{post-order left} = D, E, B \\quad \\text{and} \\quad \\text{post-order right} = F, G, C.$$\n\nReconstruct left subtree:\n- From $\\text{post-order left} = D, E, B$, the root is $B$.\n- In $\\text{in-order left} = D, B, E$, split at $B$: left is $D$, right is $E$.\n- Therefore, the left subtree is a root $B$ with left child $D$ and right child $E$.\n\nReconstruct right subtree:\n- From $\\text{post-order right} = F, G, C$, the root is $C$.\n- In $\\text{in-order right} = F, C, G$, split at $C$: left is $F$, right is $G$.\n- Therefore, the right subtree is a root $C$ with left child $F$ and right child $G$.\n\nCompute pre-order (root, left, right):\n- Visit root $A$.\n- Then the left subtree in pre-order: $B, D, E$.\n- Then the right subtree in pre-order: $C, F, G$.\nThus the pre-order traversal is $A, B, D, E, C, F, G$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1483739"}, {"introduction": "Beyond simply designing algorithms for trees, a crucial aspect of computer science is analyzing their efficiency. Understanding the performance of an algorithm allows us to predict its behavior and make informed design choices, especially in large-scale systems. In this final exercise [@problem_id:1483709], you will analyze the computational cost of a common algorithm for finding the Lowest Common Ancestor (LCA) of two nodes, translating its operational steps into a precise mathematical expression based on tree depths.", "problem": "In a large-scale distributed system, a hierarchical namespace is modeled as a rooted binary tree. Each node in this tree represents a resource and is assigned a unique identifier. To perform certain consistency and permission checks, the system frequently needs to find the Lowest Common Ancestor (LCA) of two given nodes. The LCA of two nodes $u$ and $v$ is defined as the lowest (i.e., deepest) node that has both $u$ and $v$ as descendants.\n\nThe system's data structure for each node only provides a single operation relevant to navigating the tree structure: `getParent()`, which returns the identifier of the parent node. The root node is the only node for which `getParent()` returns a special `NULL` value. The \"depth\" of a node is the number of edges on the path from the root to that node, making the depth of the root 0.\n\nAn algorithm is designed to find the LCA of two distinct nodes, $u$ and $v$. The algorithm operates as follows, assuming the depths of $u$ and $v$ (denoted $d_u$ and $d_v$, respectively) are pre-calculated and known without cost:\n1.  The deeper of the two nodes is moved up the tree by repeatedly calling `getParent()` on it until it reaches the same depth as the shallower node.\n2.  Once both nodes are at the same depth, `getParent()` is called on both nodes simultaneously in each step. This process is repeated until the two nodes become the same. This common node is their LCA.\n\nLet the LCA of nodes $u$ and $v$ be located at a depth of $d_{LCA}$. Derive a simplified expression for the total number of `getParent()` calls made by this algorithm to find the LCA. Express your answer in terms of $d_u$, $d_v$, and $d_{LCA}$.", "solution": "Let the depths of nodes be $d_{u}$ and $d_{v}$, and the LCA depth be $d_{LCA}$. Define $m=\\min(d_{u},d_{v})$ and $M=\\max(d_{u},d_{v})$.\n\nPhase 1 (depth alignment): The deeper node is moved up by exactly $M-m=|d_{u}-d_{v}|$ edges, so the number of calls in this phase is\n$$\n|d_{u}-d_{v}|.\n$$\n\nAfter alignment, both nodes are at depth $m$. Phase 2 (simultaneous ascent): They move upward together until reaching depth $d_{LCA}$. The number of steps is $m-d_{LCA}$, and each step makes two calls (one per node), so calls in this phase are\n$$\n2(m-d_{LCA}).\n$$\n\nTherefore, the total number of calls is\n$$\n|d_{u}-d_{v}|+2(m-d_{LCA}).\n$$\nSince $M-m=|d_{u}-d_{v}|$ and $M+m=d_{u}+d_{v}$, we simplify:\n$$\n|d_{u}-d_{v}|+2(m-d_{LCA})=(M-m)+2m-2d_{LCA}=M+m-2d_{LCA}=d_{u}+d_{v}-2d_{LCA}.\n$$\n\nEquivalently, this equals the sum of the distances from $u$ and $v$ to their LCA: $(d_{u}-d_{LCA})+(d_{v}-d_{LCA})=d_{u}+d_{v}-2d_{LCA}$.", "answer": "$$\\boxed{d_{u}+d_{v}-2d_{LCA}}$$", "id": "1483709"}]}