{"hands_on_practices": [{"introduction": "The best way to learn an algorithm is to trace its execution. This first practice problem guides you through the fundamental steps of Kruskal's algorithm in a practical network design scenario. By sorting the potential connections by cost and methodically building up the network, you will gain direct experience with the algorithm's greedy selection process and the crucial logic of cycle detection. [@problem_id:1517280]", "problem": "A technology company is designing a private, encrypted Wide Area Network (WAN) to connect its eight major data centers, labeled DC1 through DC8. The goal is to establish a network topology that connects all data centers, either directly or indirectly, with the minimum possible annual leasing cost for the fiber-optic links. The available point-to-point links and their associated annual costs (in thousands of dollars) are listed below. The list is provided in a pre-sorted order based on another internal metric, not by cost.\n\n*   (DC5, DC7) - Cost: 17\n*   (DC1, DC2) - Cost: 11\n*   (DC3, DC8) - Cost: 20\n*   (DC5, DC6) - Cost: 13\n*   (DC1, DC5) - Cost: 18\n*   (DC2, DC4) - Cost: 15\n*   (DC7, DC8) - Cost: 16\n*   (DC1, DC3) - Cost: 14\n*   (DC3, DC4) - Cost: 12\n*   (DC2, DC6) - Cost: 19\n\nThe network engineering team decides to apply Kruskal's algorithm to determine the optimal set of links to lease. What is the set of links that constitutes the network after the first five links have been successfully added according to the algorithm?\n\nA. `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`\n\nB. `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC2, DC4)}`\n\nC. `{(DC1, DC2), (DC3, DC4), (DC1, DC3), (DC5, DC7), (DC1, DC5)}`\n\nD. `{(DC3, DC8), (DC2, DC6), (DC1, DC5), (DC5, DC7), (DC7, DC8)}`", "solution": "Kruskal's algorithm constructs a Minimum Spanning Tree (MST) by iteratively selecting the edge with the lowest weight from a list of all available edges, provided that adding the edge does not form a cycle with the edges already selected.\n\nFirst, we must sort all available links (edges) by their cost (weight) in non-decreasing order.\n\nThe provided list is:\n*   (DC5, DC7), Cost: 17\n*   (DC1, DC2), Cost: 11\n*   (DC3, DC8), Cost: 20\n*   (DC5, DC6), Cost: 13\n*   (DC1, DC5), Cost: 18\n*   (DC2, DC4), Cost: 15\n*   (DC7, DC8), Cost: 16\n*   (DC1, DC3), Cost: 14\n*   (DC3, DC4), Cost: 12\n*   (DC2, DC6), Cost: 19\n\nSorting these by cost gives the following ordered list:\n1.  (DC1, DC2), Cost: 11\n2.  (DC3, DC4), Cost: 12\n3.  (DC5, DC6), Cost: 13\n4.  (DC1, DC3), Cost: 14\n5.  (DC2, DC4), Cost: 15\n6.  (DC7, DC8), Cost: 16\n7.  (DC5, DC7), Cost: 17\n8.  (DC1, DC5), Cost: 18\n9.  (DC2, DC6), Cost: 19\n10. (DC3, DC8), Cost: 20\n\nNext, we trace the algorithm. Initially, each data center is in its own disjoint set, representing a forest of eight components: `{DC1}, {DC2}, {DC3}, {DC4}, {DC5}, {DC6}, {DC7}, {DC8}`. The set of selected edges is empty.\n\n**Step 1 (First successful addition):**\nWe consider the lowest-cost edge: (DC1, DC2) with a cost of 11. The data centers DC1 and DC2 are in different sets (`{DC1}` and `{DC2}`). Adding this edge will not create a cycle. So, we add it.\n*   Selected Edges: `{(DC1, DC2)}`\n*   Sets are now: `{{DC1, DC2}, {DC3}, {DC4}, {DC5}, {DC6}, {DC7}, {DC8}}`\n\n**Step 2 (Second successful addition):**\nThe next-lowest-cost edge is (DC3, DC4) with a cost of 12. DC3 and DC4 are in different sets (`{DC3}` and `{DC4}`). We add this edge.\n*   Selected Edges: `{(DC1, DC2), (DC3, DC4)}`\n*   Sets are now: `{{DC1, DC2}, {DC3, DC4}, {DC5}, {DC6}, {DC7}, {DC8}}`\n\n**Step 3 (Third successful addition):**\nThe next edge is (DC5, DC6) with a cost of 13. DC5 and DC6 are in different sets (`{DC5}` and `{DC6}`). We add this edge.\n*   Selected Edges: `{(DC1, DC2), (DC3, DC4), (DC5, DC6)}`\n*   Sets are now: `{{DC1, DC2}, {DC3, DC4}, {DC5, DC6}, {DC7}, {DC8}}`\n\n**Step 4 (Fourth successful addition):**\nThe next edge is (DC1, DC3) with a cost of 14. DC1 is in the set `{DC1, DC2}` and DC3 is in the set `{DC3, DC4}`. Since these are different sets, adding the edge does not create a cycle. We add it and merge the two sets.\n*   Selected Edges: `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3)}`\n*   Sets are now: `{{DC1, DC2, DC3, DC4}, {DC5, DC6}, {DC7}, {DC8}}`\n\n**Step 5 (Cycle detection):**\nThe next edge is (DC2, DC4) with a cost of 15. We check which sets DC2 and DC4 belong to. DC2 is in `{DC1, DC2, DC3, DC4}` and DC4 is also in `{DC1, DC2, DC3, DC4}`. Since they are in the same set, adding this edge would create a cycle (specifically, DC1-DC2-DC4-DC3-DC1). Therefore, we **reject** this edge.\n\n**Step 6 (Fifth successful addition):**\nWe move to the next edge in the sorted list: (DC7, DC8) with a cost of 16. DC7 is in `{DC7}` and DC8 is in `{DC8}`. These are different sets, so we add the edge. This is our fifth successfully added edge.\n*   Selected Edges: `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`\n*   Sets are now: `{{DC1, DC2, DC3, DC4}, {DC5, DC6}, {DC7, DC8}}`\n\nThe process stops here as we were asked for the set of the first five successfully added edges. The resulting set is `{(DC1, DC2), (DC3, DC4), (DC5, DC6), (DC1, DC3), (DC7, DC8)}`.\n\nComparing this result with the given options, we find that it matches option A.", "answer": "$$\\boxed{A}$$", "id": "1517280"}, {"introduction": "After mastering the \"how,\" it is essential to understand the \"why.\" This problem moves from procedure to principle by asking you to evaluate a conjecture about the algorithm's behavior with the lightest edges in a graph. Engaging with this question will strengthen your grasp of the theoretical underpinnings of Kruskal's algorithm, particularly the properties that guarantee its greedy choices lead to an optimal solution. [@problem_id:1517301]", "problem": "In a computer science course on algorithms, a student is studying Kruskal's algorithm for finding a Minimum Spanning Tree (MST). A Minimum Spanning Tree is a subgraph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. The student proposes the following conjecture:\n\n\"In any connected, simple, undirected graph with at least 3 vertices where all edge weights are distinct, the edge with the second-smallest weight in the entire graph must always be included in the MST.\"\n\nYour task is to evaluate this conjecture. Which of the following statements is correct and provides the most accurate reasoning?\n\nA. The conjecture is false. Consider a cycle of three vertices (a triangle) where the edges are the three lightest edges in the graph. The third edge considered, which could be the second-lightest edge overall, will be discarded as it forms a cycle, so it is not always included.\n\nB. The conjecture is true. The edge with the smallest weight is always included first. The edge with the second-smallest weight is considered next. Since the graph is simple and all edge weights are distinct, these two edges cannot connect the same pair of vertices. Therefore, the second edge cannot form a cycle with the first, and it will always be included.\n\nC. The conjecture is false. An edge is excluded by Kruskal's algorithm if its endpoints are already connected. It is possible that the two endpoints of the second-lightest edge are connected by a path of several other edges that are all lighter than it.\n\nD. The conjecture is true. Kruskal's algorithm is a greedy algorithm. To ensure the final tree weight is minimized, it must select the two lightest edges available to start building the tree, as these provide the \"cheapest\" connections.\n\nE. The conjecture's validity is not guaranteed and depends on the specific structure of the graph. In a sparsely connected graph it is likely true, but in a dense graph, it is likely false.", "solution": "Let $G=(V,E)$ be a connected, simple, undirected graph with $|V| \\geq 3$ and distinct edge weights. Let the edges be ordered by strictly increasing weight as $e_{1}, e_{2}, \\dots, e_{m}$, where $w(e_{1}) < w(e_{2}) < \\dots < w(e_{m})$. Kruskal’s algorithm considers edges in this order and adds an edge if and only if it does not create a cycle with the already selected edges; equivalently, it adds an edge if its endpoints lie in different connected components of the current forest.\n\nFirst, when $e_{1}$ is considered, no edges have yet been selected, so adding $e_{1}$ cannot create a cycle. Therefore $e_{1}$ is always included.\n\nNext, consider $e_{2}$. At the moment $e_{2}$ is considered, the only previously considered and possibly included edge is $e_{1}$. The current forest has at most one edge, namely $e_{1}$, which connects its two endpoints into a single component, leaving all other vertices in singleton components. The only way for $e_{2}$ to be excluded by Kruskal’s rule at this point would be if its endpoints were already connected by a path using only the edges already included. The only included edge available is $e_{1}$. Thus, for the endpoints of $e_{2}$ to be already connected, $e_{2}$ would have to connect the same unordered pair of vertices as $e_{1}$. However, because the graph is simple, there is at most one edge between any pair of vertices, so $e_{2}$ cannot be a parallel edge to $e_{1}$. Therefore, the endpoints of $e_{2}$ are in different components when $e_{2}$ is considered, and adding $e_{2}$ does not create a cycle. Hence Kruskal’s algorithm must include $e_{2}$.\n\nBecause the edge weights are distinct, the Minimum Spanning Tree is unique, and Kruskal’s algorithm produces that unique MST. Consequently, $e_{2}$ is in the MST. This directly validates the conjecture.\n\nEvaluating the options:\n- A is incorrect because it misidentifies the third edge considered as possibly the second-lightest; the second-lightest edge is the second considered, and, as shown, it is included.\n- B is correct: it precisely captures that with a simple graph and distinct weights, $e_{2}$ cannot close a cycle at the time it is considered, so it is always included.\n- C is incorrect for the second-lightest edge: there cannot exist a path of several edges all lighter than $e_{2}$, since only $e_{1}$ is lighter.\n- D reaches the correct conclusion but gives an imprecise justification; Kruskal does not select edges simply because they are the two lightest in the abstract, but because the second-lightest cannot form a cycle at its turn.\n- E is incorrect; the property does not depend on sparsity or density under the given assumptions.\n\nTherefore, the correct choice with accurate reasoning is B.", "answer": "$$\\boxed{B}$$", "id": "1517301"}, {"introduction": "Real-world systems are dynamic, and so are the networks that model them. This final exercise explores a practical and advanced application: updating an existing Minimum Spanning Tree when the weight of an edge changes. By applying the cycle property of MSTs, you will develop an efficient method to adapt to network improvements, demonstrating how theoretical graph properties translate into powerful, real-world algorithmic solutions. [@problem_id:1517296]", "problem": "An aerospace company manages a large constellation of $n$ communication satellites in orbit. The network of possible communication links between these satellites is modeled as a weighted, undirected graph $G=(V, E)$, where $V$ is the set of $n$ satellites and $E$ is the set of all possible direct communication links. The weight of an edge $(u, v)$ in $E$ represents the signal latency between satellite $u$ and satellite $v$. To ensure efficient and reliable communication with minimum overall latency, the active links are configured to form a Minimum Spanning Tree (MST), denoted as $T$, of the graph $G$.\n\nSuppose a new laser communication technology is deployed on a single pair of satellites, $(u, v)$. This specific link $(u, v)$ was *not* part of the original MST, $T$. The upgrade reduces its communication latency from its original value $w(u,v)$ to a new, lower value $w'(u,v)$. The network administrators must determine if this new, faster link should be incorporated into the communication backbone and, if so, how to form the new MST, $T'$.\n\nA proposed update procedure is as follows:\n1. Temporarily add the newly upgraded link $(u, v)$ to the existing MST, $T$. This action creates a new graph, $T \\cup \\{(u,v)\\}$, which contains exactly one cycle.\n2. To form the new MST, $T'$, and maintain the property of minimum total latency, exactly one link must be removed from this newly formed cycle.\n\nWhich of the following statements correctly identifies the rule for selecting the link to be removed from the cycle and the worst-case time complexity to identify this specific link? You are given the existing MST, $T$, represented in a way that allows for efficient traversal (e.g., an adjacency list), and the two satellites $u$ and $v$. The total number of satellites is $n$.\n\nA. Remove the link with the smallest latency in the cycle. The complexity is $O(n \\log n)$.\n\nB. Remove the link with the largest latency in the cycle. The complexity is $O(n)$.\n\nC. If $w'(u, v)$ is smaller than the latency of every other link in the cycle, remove the link with the largest latency in the cycle; otherwise, the MST remains unchanged. The complexity to make this determination is $O(n^2)$.\n\nD. Remove the link with the largest latency in the cycle. The complexity is $O(\\log n)$.\n\nE. Always remove the link $(u, v)$ itself, as it was the one most recently added. The complexity is $O(1)$.\n\nF. Remove the link with the largest latency in the cycle. The complexity is $O(n^2)$.", "solution": "We model the constellation as a weighted, undirected graph $G=(V,E)$ with weights representing latencies. Let $T$ be an MST of $G$. A non-tree edge $(u,v)$ has its weight reduced from $w(u,v)$ to $w'(u,v)$, and we consider updating $T$.\n\nAdding $(u,v)$ to $T$ creates exactly one cycle because $T$ is a tree, so there is a unique simple path $P_{T}(u,v)$ in $T$ between $u$ and $v$; therefore the cycle is\n$$\nC \\;=\\; P_{T}(u,v) \\cup \\{(u,v)\\}.\n$$\nLet $e^{\\ast}$ be an edge of maximum latency in $C$:\n$$\ne^{\\ast} \\;\\in\\; \\arg\\max_{e \\in C} w(e),\n$$\nwhere for $(u,v)$ we use the updated weight $w'(u,v)$. By the cycle property of MSTs: in any cycle, an edge whose weight is strictly larger than that of every other edge in the cycle does not belong to any MST. Therefore, to preserve minimal total latency after adding $(u,v)$, the correct operation is to remove a maximum-latency edge from $C$. There are two cases:\n- If $w'(u,v) < \\max_{e \\in P_{T}(u,v)} w(e)$, then $e^{\\ast} \\neq (u,v)$ and\n$$\nw(T \\cup \\{(u,v)\\} \\setminus \\{e^{\\ast}\\}) \\;=\\; w(T) + w'(u,v) - w(e^{\\ast}) \\;<\\; w(T),\n$$\nso the updated MST is $T' = T \\cup \\{(u,v)\\} \\setminus \\{e^{\\ast}\\}$.\n- If $w'(u,v) \\ge \\max_{e \\in P_{T}(u,v)} w(e)$, then $e^{\\ast} = (u,v)$ (or a tie), and removing $(u,v)$ yields the original $T$, which remains an MST.\n\nThus the selection rule is “remove the link with the largest latency in the cycle.”\n\nTo identify the specific link to remove, we need the maximum-weight edge on the unique path $P_{T}(u,v)$. Given $T$ via an adjacency list and the vertices $u$ and $v$, we can:\n1. Perform a DFS or BFS from $u$ to find $v$ and record parent pointers; this traverses at most $n-1$ edges because $T$ is a tree, so it takes $O(n)$ time.\n2. Reconstruct $P_{T}(u,v)$ from parent pointers and scan its edges to find the maximum latency; this also takes $O(n)$ time in the worst case.\n\nTherefore, the total worst-case time is $O(n)$. Among the options, this corresponds to removing the largest-latency edge with $O(n)$ time.\n\nHence, the correct choice is B.", "answer": "$$\\boxed{B}$$", "id": "1517296"}]}