{"hands_on_practices": [{"introduction": "To truly grasp Borůvka's algorithm, it's helpful to contrast it with other classic Minimum Spanning Tree (MST) algorithms. This first exercise focuses on the crucial differences in the initial edge selection strategy between Borůvka's and Kruskal's algorithms. By analyzing a small, well-defined graph with specific tie-breaking rules, you will see firsthand how Borůvka's \"parallel\" approach of finding the cheapest edge for each component simultaneously differs from Kruskal's \"global\" approach of picking the single cheapest edge available in the entire graph [@problem_id:1484776]. This practice is designed to clarify the unique logic that underpins Borůvka's method from the very first step.", "problem": "A technology startup is planning a small, private network to connect four of its primary servers, labeled A, B, C, and D. The cost to establish a direct, high-speed link between any two servers has been calculated. The network must be connected, meaning there is a path between any two servers, and the total cost of the links must be minimized. This is a classic Minimum Spanning Tree (MST) problem. The graph of servers (vertices) and possible links (weighted edges) is defined as follows:\n\n-   Vertices: `{A, B, C, D}`\n-   Edges and Costs:\n    -   (A, C) with a cost of 10 units.\n    -   (B, D) with a cost of 10 units.\n    -   (C, D) with a cost of 10 units.\n    -   (A, B) with a cost of 20 units.\n\nTo build the MST, two algorithms, Kruskal's and Borůvka's, are considered. To ensure a unique solution from each algorithm, the following deterministic tie-breaking rules are mandated:\n\n1.  **Kruskal's Algorithm Tie-Breaking:** When multiple edges have the same minimal cost, the algorithm must process the edge whose canonical representation `(U, V)` (where the label `U` is lexicographically smaller than `V`) comes **last** in lexicographical (alphabetical) order.\n2.  **Borůvka's Algorithm Tie-Breaking:** In an iteration, if a component has more than one cheapest edge connecting it to external components, the algorithm must select the edge that connects to the vertex with the lexicographically **smallest** label.\n\nWhich of the following options correctly identifies the first edge selected by Kruskal's algorithm and the set of all unique edges selected in the first iteration of Borůvka's algorithm?\n\nA. Kruskal's first edge: `(A, C)`; Borůvka's first iteration set: `{ (A, C), (B, D), (C, D) }`\n\nB. Kruskal's first edge: `(C, D)`; Borůvka's first iteration set: `{ (A, C), (B, D) }`\n\nC. Kruskal's first edge: `(A, C)`; Borůvka's first iteration set: `{ (A, C), (B, D) }`\n\nD. Kruskal's first edge: `(C, D)`; Borůvka's first iteration set: `{ (C, A), (D, B), (C, D) }`\n\nE. Kruskal's first edge: `(B, D)`; Borůvka's first iteration set: `{ (A, C), (B, D) }`", "solution": "We model the network as a weighted, undirected graph with vertex set $\\{A,B,C,D\\}$ and edges with costs: $(A,C)$, $(B,D)$, $(C,D)$ each of cost $10$, and $(A,B)$ of cost $20$. A Minimum Spanning Tree (MST) is a connected, acyclic subgraph that spans all vertices and minimizes total edge cost.\n\nKruskal's algorithm selects edges in nondecreasing order of weight, skipping edges that would form a cycle. The tie-breaking rule here states: among multiple edges of the same minimal cost, process the edge whose canonical representation $(U,V)$ with $U<V$ is lexicographically last. For the edges of cost $10$, the canonical pairs are $(A,C)$, $(B,D)$, and $(C,D)$. Since $A<B<C$, the lexicographic ascending order on these pairs is\n$$(A,C) \\prec (B,D) \\prec (C,D).$$\nBy the mandated rule, Kruskal processes the lexicographically last among these, namely $(C,D)$, as the first edge.\n\nBorůvka's algorithm begins with each vertex as its own component and, in one iteration, has each component choose its cheapest outgoing edge; if multiple cheapest edges exist for a component, the tie-break selects the edge to the vertex with the lexicographically smallest label. The initial components are $\\{A\\}, \\{B\\}, \\{C\\}, \\{D\\}$, and we find:\n- For $A$: cheapest incident edges are $(A,C)$ of cost $10$ and $(A,B)$ of cost $20$. The unique cheapest is $(A,C)$.\n- For $B$: cheapest incident edges are $(B,D)$ of cost $10$ and $(A,B)$ of cost $20$. The unique cheapest is $(B,D)$.\n- For $C$: cheapest incident edges are $(C,A)$ and $(C,D)$, both of cost $10$. By the tie-break, choose the one to the lexicographically smaller neighbor, namely $A$, so select $(C,A)$, which is the same undirected edge as $(A,C)$.\n- For $D$: cheapest incident edges are $(D,B)$ and $(D,C)$, both of cost $10$. By the tie-break, choose the one to the lexicographically smaller neighbor, namely $B$, so select $(D,B)$, which is the same undirected edge as $(B,D)$.\n\nThe set of all unique edges selected in the first Borůvka iteration is therefore $\\{(A,C),(B,D)\\}$.\n\nCombining these results: Kruskal's first edge is $(C,D)$, and Borůvka's first-iteration set is $\\{(A,C),(B,D)\\}$. This matches option B.", "answer": "$$\\boxed{B}$$", "id": "1484776"}, {"introduction": "After understanding the initial edge selection, the next step is to trace how Borůvka's algorithm iteratively builds the MST. This problem guides you through the complete execution of the algorithm on a \"Hierarchically Connected Star Graph,\" a hypothetical structure designed to make the merging of components clear and systematic. By following the process through its distinct phases, you will directly observe how disjoint sets of vertices merge into larger components, and how edge weights at different scales come into play in successive iterations [@problem_id:1484797]. This exercise provides an invaluable, concrete visualization of the algorithm's core component-reduction mechanism.", "problem": "Consider a specialized undirected weighted graph, which we will call a \"Hierarchically Connected Star Graph\". This graph is defined by a parameter $n$, where $n = 2^k + 1$ for some positive integer $k$. The graph has $n$ vertices, labeled $v_0, v_1, \\ldots, v_{n-1}$.\n\nThe edges and their corresponding weights are defined as follows:\n\n1.  **Hub Connections:** For each $i \\in \\{1, 2, \\ldots, n-1\\}$, there is an edge connecting the central vertex $v_0$ to the peripheral vertex $v_i$. The weight of each of these edges is $W = n-1$.\n\n2.  **Peripheral Connections:** For each $i \\in \\{1, 2, \\ldots, n-2\\}$, there is an edge connecting the vertex $v_i$ to $v_{i+1}$. The weight of the edge $(v_i, v_{i+1})$ is given by the formula $w(v_i, v_{i+1}) = 2^p$, where $p$ is the largest non-negative integer such that $i$ is divisible by $2^p$.\n\nSuppose Borůvka's algorithm is executed on this graph to find a Minimum Spanning Tree (MST). In cases where multiple edges have the same minimum weight, the algorithm breaks ties by choosing the edge connected to the vertex with the smallest index.\n\nDetermine the total weight of the resulting MST. Express your answer as a closed-form analytic expression in terms of $n$.", "solution": "The problem asks for the total weight of the Minimum Spanning Tree (MST) found by Borůvka's algorithm on a specific graph. The graph has $n$ vertices, $v_0, v_1, \\ldots, v_{n-1}$, where $n = 2^k + 1$ for some integer $k \\ge 1$. Let $N = n-1 = 2^k$.\n\nThe weights are:\n-   $w(v_0, v_i) = N$ for $i=1, \\ldots, N$.\n-   $w(v_i, v_{i+1}) = 2^p$ for $i=1, \\ldots, N-1$, where $p$ is the largest integer such that $2^p$ divides $i$.\n\nBorůvka's algorithm works in iterations. In each iteration, every component finds its minimum-weight outgoing edge, and all such edges are added to the MST forest.\n\n**Initial State:**\nThe algorithm starts with $n$ components, where each vertex is its own component: $C_0=\\{v_0\\}, C_1=\\{v_1\\}, \\ldots, C_{N}=\\{v_{n-1}\\}$.\n\n**Iteration 1:**\nWe find the minimum-weight outgoing edge for each component.\n-   For component $C_0=\\{v_0\\}$: The outgoing edges are $(v_0, v_i)$ for $i=1, \\ldots, N$, all with weight $N=2^k$. The tie-breaking rule selects $(v_0, v_1)$.\n-   For any peripheral component $C_i=\\{v_i\\}$ where $i \\in \\{1, \\ldots, N\\}$: The outgoing edges are $(v_i, v_0)$ (weight $N$) and possibly $(v_i, v_{i-1})$ and $(v_i, v_{i+1})$. The weights of these peripheral connection edges are $w(v_{i-1},v_i) = 2^{p(i-1)}$ and $w(v_i,v_{i+1}) = 2^{p(i)}$. The smallest possible weight for a peripheral edge corresponds to $p=0$, which gives a weight of $2^0=1$. This occurs when the index $i$ or $i-1$ is odd. Since $k \\ge 1$, $N=2^k \\ge 2$, so any peripheral edge with weight 1 is cheaper than any hub connection.\n-   Let's analyze the peripheral edges with weight 1. These are $(v_i, v_{i+1})$ where $p(i)=0$, i.e., $i$ is odd. So, edges $(v_1, v_2), (v_3, v_4), \\ldots, (v_{N-1}, v_N)$ all have weight 1.\n-   For an odd-indexed component $C_i$: its cheapest edge is $(v_i, v_{i+1})$ with weight 1.\n-   For an even-indexed component $C_i$: its cheapest edge is $(v_i, v_{i-1})$ with weight 1.\n-   As a result, components $\\{v_1, v_2\\}$, $\\{v_3, v_4\\}$, ..., $\\{v_{N-1}, v_N\\}$ are formed by adding edges of weight 1. There are $N/2$ such edges. The central component $C_0$ remains separate because its chosen edge $(v_0,v_1)$ has weight $N$, which is not added yet because $C_1$ found a cheaper edge.\n-   After iteration 1, we have $N/2$ components of size 2, plus the isolated component $C_0$. Total components: $N/2+1$.\n-   Weight added in Iteration 1: $\\frac{N}{2} \\times 1 = \\frac{N}{2}$.\n\n**Iteration 2:**\n-   The components are now of the form $C'_{j} = \\{v_{2j-1}, v_{2j}\\}$ for $j=1, \\ldots, N/2$.\n-   The cheapest outgoing edge for such a component will connect it to a neighboring component $C'_{j-1}$ or $C'_{j+1}$. The connecting edges are $(v_{2j-2}, v_{2j-1})$ and $(v_{2j}, v_{2j+1})$.\n-   The weight of $(v_{2j}, v_{2j+1})$ has index $i=2j$, for which $p(2j) \\ge 1$. The smallest non-zero $p(i)$ is 1, so the next level of edge weights is $2^1=2$. This occurs for edges $(v_2, v_3), (v_6, v_7), \\ldots$. However, the edge connecting two of our new components is, for example, $(v_2, v_3)$, which links $\\{v_1,v_2\\}$ and $\\{v_3,v_4\\}$. The index is $i=2$, so $p(2)=1$ and the weight is $2^1=2$.\n-   In general, the cheapest edge leaving a component $\\{v_{2j-1}, v_{2j}\\}$ will be either $(v_{2j-2}, v_{2j-1})$ or $(v_{2j}, v_{2j+1})$. The indices $2j-2$ and $2j$ are even. The one with the lowest weight will be chosen. The weights are $w(v_{2j-2}, v_{2j-1}) = 2^{p(2j-2)}$ and $w(v_{2j}, v_{2j+1}) = 2^{p(2j)}$. One of these will have $p=1$, giving weight 2. This is cheaper than any hub connection (weight $N=2^k$) as long as $k \\ge 2$.\n-   The components of size 2 merge into components of size 4. For example, $\\{v_1, v_2\\}$ and $\\{v_3, v_4\\}$ merge via edge $(v_2, v_3)$ of weight $2^{p(2)}=2$. There are $N/4$ such merging edges.\n-   After iteration 2, we have $N/4$ components of size 4, plus $C_0$. Total components: $N/4+1$.\n-   Weight added in Iteration 2: $\\frac{N}{4} \\times 2 = \\frac{N}{2}$.\n\n**Iteration $m$ (for $1 \\le m \\le k$):**\n-   At the beginning of iteration $m$, we have $N/2^{m-1}$ components of size $2^{m-1}$ (plus $C_0$).\n-   The cheapest edge connecting two such components, like $\\{v_1, \\ldots, v_{2^{m-1}}\\}$ and $\\{v_{2^{m-1}+1}, \\ldots, v_{2^m}\\}$, is the edge $(v_{2^{m-1}}, v_{2^{m-1}+1})$.\n-   The index is $i=2^{m-1}$, so $p(i) = m-1$. The weight of this edge is $2^{m-1}$.\n-   This weight is smaller than the hub connection weight $N=2^k$ for $m-1 < k$, which is true for $m \\le k$.\n-   The components of size $2^{m-1}$ merge into components of size $2^m$. There are $\\frac{N/2^{m-1}}{2} = N/2^m$ such merges.\n-   Weight added in Iteration $m$: $\\frac{N}{2^m} \\times 2^{m-1} = \\frac{N}{2}$.\n\n**After Iteration $k$:**\n-   All the peripheral vertices $v_1, \\ldots, v_N$ have merged into a single large component $C_{path} = \\{v_1, \\ldots, v_N\\}$.\n-   The total number of components is now 2: $C_0$ and $C_{path}$.\n-   The total weight added so far from iterations 1 to $k$ is $\\sum_{m=1}^{k} \\frac{N}{2} = k \\times \\frac{N}{2}$.\n\n**Final Iteration ($k+1$):**\n-   The two remaining components, $C_0=\\{v_0\\}$ and $C_{path}=\\{v_1, \\ldots, v_N\\}$, must now connect.\n-   The cheapest outgoing edge from $C_{path}$ is one of the hub connections $(v_i, v_0)$, all of which have weight $N$.\n-   Similarly, the cheapest outgoing edge from $C_0$ is one of the hub connections, with weight $N$.\n-   The algorithm adds one of these edges (e.g., $(v_0, v_1)$ by the tie-breaking rule) to connect the two components.\n-   Weight added in Iteration $k+1$: $N$.\n-   The algorithm terminates as there is only one component left.\n\n**Total Weight Calculation:**\nThe total weight of the MST is the sum of weights added in all iterations.\nTotal Weight = (Weight from iterations 1 to $k$) + (Weight from iteration $k+1$)\nTotal Weight = $\\left(k \\times \\frac{N}{2}\\right) + N$\n\nNow, we substitute $N = n-1$ and $k = \\log_2(N) = \\log_2(n-1)$.\nTotal Weight = $\\log_2(n-1) \\times \\frac{n-1}{2} + (n-1)$\n\nThis can be factored:\nTotal Weight = $(n-1) \\left(\\frac{\\log_2(n-1)}{2} + 1\\right)$", "answer": "$$\\boxed{(n-1) \\left(\\frac{\\log_{2}(n-1)}{2} + 1\\right)}$$", "id": "1484797"}, {"introduction": "An algorithm's true power lies not just in its correctness, but also in its efficiency. In this final practice, we shift our focus to the performance of Borůvka's algorithm by exploring its worst-case behavior. You are challenged to act as an adversary and devise a weighting scheme for a wheel graph, $W_n$, that forces the algorithm to take the maximum possible number of iterations [@problem_id:1484805]. This exercise will deepen your understanding of why the number of iterations is logarithmically bounded—specifically, at most $\\lfloor \\log_{2} n \\rfloor$—and reveal the fundamental properties that make Borůvka's algorithm so efficient, particularly in parallel computing environments.", "problem": "Borůvka's algorithm is a method for finding a Minimum Spanning Tree (MST) in a connected, undirected graph with distinct edge weights. The algorithm proceeds in iterations. It begins with each vertex of the graph considered as a separate component, forming a forest of components. In each iteration, every component identifies the edge with the minimum weight connecting one of its vertices to a vertex in a *different* component. All such minimum-weight edges are then added to the MST forest. As edges are added, components merge. The algorithm terminates when only one component, the MST itself, remains.\n\nConsider a wheel graph, denoted as $W_n$, for $n \\ge 3$. This graph consists of a central \"hub\" vertex, let's call it $v_0$, and a set of $n-1$ \"rim\" vertices, $v_1, v_2, \\ldots, v_{n-1}$. The rim vertices are connected to form a cycle graph $C_{n-1}$, meaning edges exist between $v_i$ and $v_{i+1}$ for $i=1, \\ldots, n-2$, and also between $v_{n-1}$ and $v_1$. Additionally, the hub vertex $v_0$ is connected by a \"spoke\" edge to every rim vertex $v_i$ for $i=1, \\ldots, n-1$.\n\nYour task is to analyze the worst-case performance of Borůvka's algorithm on such a graph. Devise a general strategy for assigning unique positive integer weights to the edges of $W_n$ that maximizes the number of iterations Borůvka's algorithm must perform.\n\nWhat is the maximum possible number of iterations required by Borůvka's algorithm to find the MST of a wheel graph $W_n$, expressed as a function of $n$?", "solution": "Let $W_{n}$ have hub $v_{0}$ and rim vertices $v_{1},\\ldots,v_{n-1}$ connected in a cycle. Borůvka’s algorithm proceeds in phases; at the start of a phase with $c$ components, each component chooses its lightest outgoing edge, all these edges are added, and the resulting connected pieces are contracted.\n\nKey general fact (used for the upper bound): In any phase, if the current number of components is $c$, then the number after the phase is at most\n$$\n\\left\\lfloor \\frac{c}{2} \\right\\rfloor.\n$$\nReason: Direct each component’s chosen edge outward. Each weakly connected component of the directed graph contains at least two original components (because every node has outdegree $1$ and no chosen edge is a self-loop), so the number of resulting components is at most $\\lfloor c/2 \\rfloor$.\n\nTherefore, after $t$ phases,\n$$\nc_{t} \\le \\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor.\n$$\nTo force the maximum possible number of phases before reaching a single component, we want equality at each step, namely $c_{i+1}=\\left\\lfloor c_{i}/2 \\right\\rfloor$. If this can be achieved for all phases starting from $c_{0}=n$, then the algorithm terminates when\n$$\n\\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor = 1,\n$$\nwhich is equivalent to $1 \\le \\frac{n}{2^{t}} < 2$, i.e., $2^{t} \\le n < 2^{t+1}$. Thus the maximum possible number of phases is\n$$\nt = \\left\\lfloor \\log_{2} n \\right\\rfloor.\n$$\n\nWe now give a weight assignment strategy for $W_{n}$ that achieves $c_{i+1}=\\left\\lfloor c_{i}/2 \\right\\rfloor$ in every phase.\n\nWeight-assignment strategy (unique positive integers, with strict separation into “bands” per phase):\n1) Partition the rim edges of the initial cycle into two alternating sets around the cycle. Assign to one of these sets (call them “level-1 edges”) strictly increasing small integer weights, all smaller than any other edge weight. Assign to all spokes and to the other rim edges strictly larger integer weights so that, for every rim vertex, its minimum incident edge is its designated level-1 rim edge (not a spoke). Also choose the hub’s lightest spoke to be larger than all level-1 edges (so it does not disturb rim choices) but lighter than the other spokes, so the hub chooses exactly one spoke.\n\nConsequence of step 1: Along the rim, every chosen level-1 rim edge is selected by both its endpoints, forming disjoint pairs of rim vertices; if the rim has odd length, exactly one rim vertex remains unmatched. The hub chooses one spoke. Counting components after this phase:\n- If the number of current components $c$ is even (rim count odd), the hub’s single chosen spoke attaches to the unique unmatched rim component, so $c$ is halved: $c_{1} = c/2$.\n- If $c$ is odd (rim count even), the hub’s spoke attaches to one of the newly formed rim pairs, making a size-3 component, and the remaining rim pairs are separate; again $c_{1} = (c-1)/2 = \\lfloor c/2 \\rfloor$.\n\nThus in either case $c_{1}=\\left\\lfloor \\frac{n}{2} \\right\\rfloor$.\n\n2) Inductive continuation: After contracting, the component graph is again a wheel: one hub component and a rim cycle of $c_{1}-1$ components. Preassign the remaining (not-yet-chosen) rim edges so that at “level-2” an alternating subset of rim edges has weights strictly larger than all level-1 weights but strictly smaller than any other remaining edges incident to rim components. Ensure every rim component’s two spokes (to the hub component) are heavier than its designated level-2 rim edge, while among the hub’s spokes one is the smallest in this band so the hub chooses exactly one spoke. This forces the same pairing behavior on the rim components at level 2, yielding\n$$\nc_{2}=\\left\\lfloor \\frac{c_{1}}{2} \\right\\rfloor.\n$$\n\n3) Repeat this hierarchical assignment for levels $3,4,\\ldots$ so that at level $j$ the designated rim edges all lie in a weight band strictly above all prior levels and strictly below any edges that must be avoided at that level. Uniqueness of weights is guaranteed by choosing distinct integers within each band. This ensures that at every phase $i$ the choice pattern is exactly the same: rim components pair along the cycle; the hub component picks exactly one spoke; and the component count satisfies the equality\n$$\nc_{i+1}=\\left\\lfloor \\frac{c_{i}}{2} \\right\\rfloor.\n$$\n\nBy induction, after $t$ phases we have $c_{t}=\\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor$, so the maximum possible number of Borůvka iterations until a single component remains is the unique integer $t$ with $2^{t} \\le n < 2^{t+1}$, namely\n$$\n\\left\\lfloor \\log_{2} n \\right\\rfloor.\n$$\n\nHence the worst-case (maximized over all distinct positive integer weight assignments) number of Borůvka iterations on the wheel $W_{n}$ is exactly $\\left\\lfloor \\log_{2} n \\right\\rfloor$.", "answer": "$$\\boxed{\\left\\lfloor \\log_{2} n \\right\\rfloor}$$", "id": "1484805"}]}