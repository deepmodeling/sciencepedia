{"hands_on_practices": [{"introduction": "Detecting cycles in a directed graph is a classic application of Depth-First Search (DFS). This first exercise provides a concrete scenario to practice the core mechanism: tracing the traversal step-by-step and identifying the 'back edges' that signify a loop. Mastering this fundamental skill is essential before tackling more complex cycle-related problems. [@problem_id:1493924]", "problem": "A city planner is designing the traffic flow for a new downtown district with 6 intersections, numbered 0 through 5. To manage traffic, all streets will be one-way. A crucial task is to ensure that the proposed layout does not contain any \"traffic loops\"â€”routes that allow a driver to return to their starting intersection simply by following a sequence of one-way streets.\n\nTo check for such loops, an algorithm based on Depth-First Search (DFS) is employed. The intersections are treated as vertices and the one-way streets as directed edges in a graph. A cycle is detected if the DFS process finds a \"back edge,\" which is an edge from a currently visited vertex to an ancestor vertex that is still in the process of being explored (i.e., it is on the current recursion path).\n\nThe proposed one-way streets are as follows:\n- 0 to 1\n- 1 to 2\n- 2 to 0\n- 1 to 3\n- 3 to 4\n- 4 to 1\n- 5 to 4\n\nThe DFS algorithm adheres to the following rules:\n1. The search begins at vertex 0.\n2. If the graph has multiple disconnected components, the search continues by selecting the lowest-numbered unvisited vertex.\n3. When exploring from any given vertex, its adjacent neighbors are visited in ascending numerical order.\n\nHow many back edges will be detected in total by this specific execution of the DFS algorithm?\n\nA. 0\n\nB. 1\n\nC. 2\n\nD. 3\n\nE. 4", "solution": "We model intersections as vertices $0,1,2,3,4,5$ and one-way streets as directed edges. The DFS starts at $0$, visits neighbors in ascending order, and continues with the lowest-numbered unvisited vertex when a component finishes. A back edge is an edge from a currently explored vertex to an ancestor on the current recursion stack.\n\nConstruct adjacency lists in ascending order: $0:\\{1\\}$, $1:\\{2,3\\}$, $2:\\{0\\}$, $3:\\{4\\}$, $4:\\{1\\}$, $5:\\{4\\}$.\n\nBegin DFS at $0$. Mark $0$ active (on the recursion stack). From $0$, visit $1$; edge $0\\to 1$ is a tree edge. At $1$, visit $2$ first; edge $1\\to 2$ is a tree edge. At $2$, its neighbor is $0$. Vertex $0$ is active and is an ancestor of $2$, so $2\\to 0$ is a back edge; count $1$. Finish $2$ (it leaves the stack). Return to $1$ and visit next neighbor $3$; edge $1\\to 3$ is a tree edge. At $3$, visit $4$; edge $3\\to 4$ is a tree edge. At $4$, its neighbor is $1$, which is still active and is an ancestor of $4$, so $4\\to 1$ is a back edge; count $2$. Finish $4$, then $3$, then $1$, then $0$.\n\nAfter finishing this component, the lowest-numbered unvisited vertex is $5$. Start DFS at $5$. Its neighbor is $4$, which has already finished (not on the current stack), so $5\\to 4$ is not a back edge. No additional back edges are found.\n\nTherefore, the total number of back edges detected is $2$.", "answer": "$$\\boxed{C}$$", "id": "1493924"}, {"introduction": "Real-world problems often involve cycles with specific structural constraints, not just any cycle. This practice explores such a scenario, where a valid cycle must strictly alternate between two types of edges. A powerful technique to solve this is to construct an augmented 'state-space' graph where a node represents both a location and the protocol used to arrive there, effectively transforming the problem into a standard cycle detection task on a new graph. [@problem_id:1493919]", "problem": "In the design of a next-generation System on a Chip (SoC), two different communication protocols, \"Synchro\" and \"Asynchro\", are used for data transfer between functional components. A critical failure mode, known as protocol resonance, can occur if a signal gets trapped in a feedback loop where the communication protocol strictly alternates at each step.\n\nYou are given a model of the chip's architecture as follows:\n- A set of $n$ functional components, indexed by integers $V = \\{0, 1, \\dots, n-1\\}$.\n- The Synchro protocol network, modeled as a directed graph $G_S = (V, E_S)$, where a directed edge $(u, v) \\in E_S$ indicates that component $u$ can send data to component $v$ using the Synchro protocol.\n- The Asynchro protocol network, modeled as a directed graph $G_A = (V, E_A)$, where an edge $(u, v) \\in E_A$ represents a valid data transfer from $u$ to $v$ using the Asynchro protocol.\n\nAn \"alternating feedback loop\" is a sequence of components $v_0, v_1, \\dots, v_k=v_0$ (where the path has at least one edge) such that the communication protocols used for the connections $(v_0, v_1), (v_1, v_2), \\dots, (v_{k-1}, v_k)$ strictly alternate between Synchro and Asynchro. For instance, if $(v_0, v_1)$ is a Synchro connection, then $(v_1, v_2)$ must be Asynchro, $(v_2, v_3)$ must be Synchro, and so on, with the pattern holding true for the final edge $(v_{k-1}, v_k = v_0)$ that closes the loop.\n\nGiven a specific chip design, your task is to determine the total number of unique functional components that are part of at least one such alternating feedback loop.\n\n**Chip Specification:**\n- Number of components, $n = 8$.\n- Synchro edge set, $E_S = \\{(0, 1), (1, 2), (3, 4), (5, 6), (7, 0)\\}$.\n- Asynchro edge set, $E_A = \\{(2, 3), (4, 5), (6, 7), (6, 1)\\}$.", "solution": "We are asked to count the number of vertices in at least one directed cycle whose edges strictly alternate between Synchro edges from $E_S$ and Asynchro edges from $E_A$. An alternating cycle must have even length so that the alternation holds consistently around the loop.\n\nWe enumerate possible alternating cycles by following edges that must alternate in type at each step.\n\nFirst, examine cycles beginning with Synchro edges:\n- From $(0,1) \\in E_S$: the next edge must be Asynchro out of $1$. There is no $(1, \\cdot) \\in E_A$, so no cycle arises.\n- From $(1,2) \\in E_S$: the next edges are forced by alternation:\n$$1 \\to 2 \\text{ (S) },\\quad 2 \\to 3 \\text{ (A) },\\quad 3 \\to 4 \\text{ (S) },\\quad 4 \\to 5 \\text{ (A) },\\quad 5 \\to 6 \\text{ (S) },\\quad 6 \\to 1 \\text{ (A) },$$\nwhich closes a directed alternating cycle through the vertices $\\{1,2,3,4,5,6\\}$.\n- From $(3,4) \\in E_S$ and $(5,6) \\in E_S$: the same forced alternation leads into the same cycle $\\{1,2,3,4,5,6\\}$ as above.\n- From $(7,0) \\in E_S$: the next edge must be Asynchro out of $0$, but there is no $(0, \\cdot) \\in E_A$, so no cycle arises.\n\nNext, examine cycles beginning with Asynchro edges:\n- From $(2,3) \\in E_A$: alternation forces\n$$2 \\to 3 \\text{ (A) },\\quad 3 \\to 4 \\text{ (S) },\\quad 4 \\to 5 \\text{ (A) },\\quad 5 \\to 6 \\text{ (S) },\\quad 6 \\to 1 \\text{ (A) },\\quad 1 \\to 2 \\text{ (S) },$$\nwhich is the same alternating cycle through $\\{1,2,3,4,5,6\\}$.\n- From $(4,5) \\in E_A$ and $(6,1) \\in E_A$: by the same alternation, we obtain the same cycle $\\{1,2,3,4,5,6\\}$.\n- From $(6,7) \\in E_A$: alternation forces $7 \\to 0$ via Synchro, but then an Asynchro edge out of $0$ would be required and none exists, so no cycle arises.\n\nFinally, we justify that vertices $0$ and $7$ cannot belong to any alternating cycle. For $0$ to be in an alternating cycle, there must exist an outgoing Asynchro edge from $0$ when the preceding edge into $0$ is Synchro (or an incoming Asynchro edge if the outgoing is Synchro). However, there is no $(0,\\cdot) \\in E_A$ and no $(\\cdot,0) \\in E_A$. For $7$, the only incoming edge is Asynchro $(6,7)$, which forces the next edge out of $7$ to be Synchro $(7,0)$, and then an Asynchro edge out of $0$ would be required, which does not exist. Hence neither $0$ nor $7$ can be in any alternating cycle.\n\nTherefore, the unique alternating cycle is $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 6 \\to 1$, and the set of vertices in at least one alternating feedback loop is $\\{1,2,3,4,5,6\\}$.\n\nThe total number of such vertices is $6$.", "answer": "$$\\boxed{6}$$", "id": "1493919"}, {"introduction": "This advanced problem demonstrates how the DFS algorithm can be extended to verify properties of cycles, not just their existence. By cleverly reframing the condition on the product of weights as a question of parity, we can solve the problem efficiently in linear time. This exercise challenges you to augment the state maintained during the DFS traversal, a key technique for solving a wide array of graph problems beyond simple connectivity. [@problem_id:1493933]", "problem": "Consider a directed graph $G = (V, E)$, where $V$ is the set of vertices with $|V| = N$, and $E$ is the set of edges with $|E| = M$. Each edge $(u, v) \\in E$ is assigned a weight $w(u, v)$ from the set $\\{-1, 1\\}$. You are tasked with designing an algorithm to determine if there exists at least one simple cycle in $G$ for which the product of the weights of its constituent edges is equal to $-1$. A simple cycle is a path that starts and ends at the same vertex and does not repeat any other vertices.\n\nWhich of the following options represents the tightest bound on the worst-case time complexity for the most efficient algorithm that correctly solves this problem for any general directed graph?\n\nA. $O(N + M)$\n\nB. $O((N+M)\\log N)$\n\nC. $O(N \\cdot M)$\n\nD. $O(N^2)$\n\nE. The problem is NP-hard, meaning no polynomial-time algorithm is known to exist.", "solution": "The core of the problem is to find a simple cycle where the product of edge weights is $-1$. This is equivalent to finding a simple cycle containing an odd number of edges with weight $-1$. This rephrasing transforms the problem from a product calculation into a parity check.\n\nWe can solve this by augmenting a standard graph traversal algorithm, such as Depth First Search (DFS), to keep track of parity information. The key idea is that any simple cycle in a directed graph can be identified during a DFS traversal by the discovery of a non-tree edge (a back, forward, or cross edge), which closes a loop with existing tree edges.\n\nLet's define the state we need to maintain during the DFS. For each vertex $u$ that we visit, we will compute `parity[u]`, which represents the parity of the count of `-1` weighted edges on the unique path from the root of the current DFS tree to $u$. We can define this parity as 0 for an even count and 1 for an odd count. The operation to combine parities will be the XOR operation ($\\oplus$).\n\nThe algorithm proceeds as follows:\n1.  Initialize a `color` array for all $N$ vertices to `WHITE` (unvisited).\n2.  Initialize a `parity` array for all $N$ vertices.\n3.  Iterate through each vertex $v$ in $V$. If `color[v]` is `WHITE`, start a DFS from $v$. For this new DFS tree, set `parity[v] = 0` and call `DFS(v)`.\n\nThe recursive `DFS(u)` function works as follows:\n1.  Set `color[u]` to `GRAY` (currently visiting).\n2.  For each neighbor $v$ of $u$ connected by an edge $(u,v)$:\n    a. Let `edge_parity` be 1 if $w(u,v) = -1$, and 0 if $w(u,v) = 1$.\n    b. **Case 1: $v$ is `WHITE`.** This is a tree edge. We update the parity for $v$ based on the path from the root, which extends the path to $u$. So, `parity[v]` = `parity[u]` $\\oplus$ `edge_parity`. Then, we recursively call `DFS(v)`. If the recursive call signals that a target cycle has been found, we propagate this information up.\n    c. **Case 2: $v$ is not `WHITE`.** This means $(u,v)$ is a non-tree edge (back, forward, or cross). This edge closes a simple cycle. The cycle consists of the edge $(u,v)$ and the path in the DFS tree connecting $v$ back to $u$. The tree path connecting $v$ to $u$ consists of the path from the lowest common ancestor (LCA) of $u$ and $v$ down to $u$, and the path from the LCA down to $v$. The parity of the number of `-1` edges on this tree path is `parity[u]` $\\oplus$ `parity[v]`.\n        - To see why, let $P_r(x)$ be the parity of the tree path from the DFS root $r$ to a vertex $x$. By our definition, `parity[x]` = $P_r(x)$.\n        - Let `lca = LCA(u,v)`. The tree path from $r$ to $u$ can be seen as the path from $r$ to `lca` followed by the path from `lca` to $u$. Thus, `parity[u]` = $P_r(\\text{lca}) \\oplus P_{\\text{lca}}(u)$. Similarly, `parity[v]` = $P_r(\\text{lca}) \\oplus P_{\\text{lca}}(v)$.\n        - Taking the XOR of these two equations, we get: `parity[u]` $\\oplus$ `parity[v]` = ($P_r(\\text{lca}) \\oplus P_{\\text{lca}}(u)) \\oplus (P_r(\\text{lca}) \\oplus P_{\\text{lca}}(v)) = P_{\\text{lca}}(u) \\oplus P_{\\text{lca}}(v)$. This is exactly the parity of `-1` edges on the tree path that connects $u$ and $v$.\n    d. Now, we can find the parity of the entire cycle formed by the non-tree edge $(u,v)$. The cycle's total parity is the sum (in terms of XOR) of the parity of the tree path and the parity of the edge $(u,v)$ itself.\n       `cycle_parity` = (`parity[u]` $\\oplus$ `parity[v]`) $\\oplus$ `edge_parity`.\n    e. If `cycle_parity` is 1, we have found a simple cycle with an odd number of `-1` edges. We can immediately stop and report that such a cycle exists.\n\n3.  After visiting all neighbors of $u$, set `color[u]` to `BLACK` (finished).\n\nThis algorithm is essentially a single pass of DFS over the entire graph. The `color` array, used to classify edges, and the `parity` array add a constant amount of storage per vertex. The computation at each vertex and for each edge is a constant number of operations (XOR and comparison). Therefore, the overall time complexity of this algorithm is bounded by the complexity of DFS, which is $O(N + M)$.\n\nWhile many problems involving \"simple cycles\" with specific properties are NP-hard (which might suggest E), this particular problem has an efficient polynomial-time solution due to the nature of the parity constraint. The most efficient algorithm has a tight worst-case time complexity of $O(N + M)$.", "answer": "$$\\boxed{A}$$", "id": "1493933"}]}