{"hands_on_practices": [{"introduction": "Both Breadth-First Search (BFS) and Depth-First Search (DFS) are fundamental algorithms for exploring a graph, and each generates a spanning tree in the process. While their strategies are distinct—BFS explores layer by layer and DFS plunges as deep as possible—it is instructive to consider when they might produce identical results. This exercise [@problem_id:1483515] challenges you to identify a graph structure where the BFS and DFS trees are structurally the same, reinforcing your understanding of their core mechanics under specific tie-breaking rules.", "problem": "Consider a simple connected undirected graph $G=(V,E)$, where $V$ is the set of vertices and $E$ is the set of edges. Two standard algorithms for traversing such a graph are the Breadth-First Search (BFS) and the Depth-First Search (DFS). A traversal starting from a source vertex $v_s$ generates a spanning tree of the graph's connected component, known as a BFS tree or a DFS tree, depending on the algorithm used.\n\nThe structure of these trees depends on the graph's topology, the starting vertex, and the rule used to break ties when a vertex has multiple unvisited neighbors. For this problem, assume that when multiple unvisited neighbors are available, the algorithm always chooses to visit the neighbor with the smallest integer label first. The BFS and DFS trees are considered structurally identical if they are rooted at the same vertex and have the exact same set of edges.\n\nAll graphs in the options below share the same vertex set $V = \\{1, 2, 3, 4, 5\\}$. The traversal for each graph starts at the source vertex $v_s = 1$.\n\nWhich of the following graphs produces structurally identical BFS and DFS trees under these conditions?\n\nA. Graph $G_A$ with edge set $E_A = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}\\}$.\n\nB. Graph $G_B$ with edge set $E_B = \\{\\{1,2\\}, \\{1,3\\}, \\{1,4\\}, \\{2,3\\}, \\{2,4\\}, \\{3,4\\}, \\{1,5\\}\\}$.\n\nC. Graph $G_C$ with edge set $E_C = \\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}, \\{1,4\\}, \\{4,5\\}, \\{5,1\\}\\}$.\n\nD. Graph $G_D$ with edge set $E_D = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,1\\}\\}$.", "solution": "We analyze when the BFS and DFS spanning trees, both rooted at $1$ and using the smallest-label tie-breaking rule, produce the same edge set. BFS explores vertices level by level using a queue, adding a tree edge $(u,v)$ when $v$ is first discovered from $u$; DFS explores by always proceeding to the smallest unvisited neighbor using a stack/recursion, adding a tree edge when recursing to an unvisited neighbor.\n\nOption A: $E_{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}$. This is a path $1$–$2$–$3$–$4$–$5$.\n- DFS from $1$: proceed to the smallest unvisited neighbor at each step, yielding the path $1 \\to 2 \\to 3 \\to 4 \\to 5$. The DFS tree edges are\n$$E_{T,\\mathrm{DFS}}^{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}.$$\n- BFS from $1$: discover $2$ from $1$, then $3$ from $2$, then $4$ from $3$, then $5$ from $4$. The BFS tree edges are\n$$E_{T,\\mathrm{BFS}}^{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}.$$\nThus $E_{T,\\mathrm{DFS}}^{A}=E_{T,\\mathrm{BFS}}^{A}$, so they are identical.\n\nOption B: $E_{B}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{2,3\\},\\{2,4\\},\\{3,4\\},\\{1,5\\}\\}$. This is $K_{4}$ on $\\{1,2,3,4\\}$ plus $\\{1,5\\}$.\n- DFS from $1$: go to $2$, then to $3$, then to $4$, backtrack to $1$, then to $5$. The DFS tree edges are\n$$E_{T,\\mathrm{DFS}}^{B}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{1,5\\}\\}.$$\n- BFS from $1$: discover all neighbors of $1$ in increasing order: $2,3,4,5$. The BFS tree edges are\n$$E_{T,\\mathrm{BFS}}^{B}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{1,5\\}\\}.$$\nThese sets differ, so not identical.\n\nOption C: $E_{C}=\\{\\{1,2\\},\\{2,3\\},\\{3,1\\},\\{1,4\\},\\{4,5\\},\\{5,1\\}\\}$. This is two triangles $\\{1,2,3\\}$ and $\\{1,4,5\\}$ sharing $1$.\n- DFS from $1$: go to $2$, then $3$, backtrack to $1$, then $4$, then $5$. The DFS tree edges are\n$$E_{T,\\mathrm{DFS}}^{C}=\\{\\{1,2\\},\\{2,3\\},\\{1,4\\},\\{4,5\\}\\}.$$\n- BFS from $1$: discover $2,3,4,5$ from $1$. The BFS tree edges are\n$$E_{T,\\mathrm{BFS}}^{C}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{1,5\\}\\}.$$\nThese sets differ, so not identical.\n\nOption D: $E_{D}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,1\\}\\}$, a $5$-cycle.\n- DFS from $1$: go $1 \\to 2 \\to 3 \\to 4 \\to 5$. The DFS tree edges are\n$$E_{T,\\mathrm{DFS}}^{D}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}.$$\n- BFS from $1$: discover $2$ and $5$ from $1$, then discover $3$ from $2$ and $4$ from $5$. The BFS tree edges are\n$$E_{T,\\mathrm{BFS}}^{D}=\\{\\{1,2\\},\\{1,5\\},\\{2,3\\},\\{5,4\\}\\}.$$\nThese sets differ, so not identical.\n\nTherefore, only Option A yields structurally identical BFS and DFS trees under the stated conditions.", "answer": "$$\\boxed{A}$$", "id": "1483515"}, {"introduction": "Having seen that BFS and DFS trees can sometimes be identical, we now explore the opposite extreme: how different can they be? This practice [@problem_id:1483546] uses a hypothetical wheel graph to create a scenario that starkly contrasts the \"short and wide\" tree generated by BFS with the \"long and narrow\" tree from DFS. By analyzing the heights of these two trees, you will develop a strong intuition for the characteristic shapes that result from each traversal strategy and how they reflect the algorithm's operational principles.", "problem": "Consider a simple, connected, undirected graph called a Wheel Graph, denoted $W_N$, constructed with $N$ vertices. The vertices are labeled $v_0, v_1, \\dots, v_{N-1}$. The vertex $v_0$ is called the \"hub\" and is connected by an edge to every \"rim\" vertex $v_i$ for $i \\in \\{1, 2, \\dots, N-1\\}$. The rim vertices are also connected to form a cycle, with edges $(v_i, v_{i+1})$ for $i=1, \\dots, N-2$, and an edge $(v_{N-1}, v_1)$.\n\nWe perform two separate graph traversals starting from the hub vertex $v_0$: a Breadth-First Search (BFS) and a Depth-First Search (DFS). These traversals generate a BFS tree and a DFS tree, respectively, which are spanning trees of $W_N$ rooted at $v_0$. For both algorithms, if there is a choice among multiple unvisited neighbors of a vertex, the algorithm must always explore the neighbor with the smallest vertex index first.\n\nThe height of a rooted tree is defined as the number of edges on the longest path from the root to any leaf node. Let $H_{BFS}$ be the height of the BFS tree and $H_{DFS}$ be the height of the DFS tree.\n\nFor a Wheel Graph with $N=50$ vertices, calculate the value of the difference $H_{DFS} - H_{BFS}$.", "solution": "We analyze the BFS and DFS spanning trees of the wheel graph $W_{N}$ rooted at the hub $v_{0}$, under the rule that when multiple unvisited neighbors exist, the smallest-index vertex is chosen.\n\nBy definition, $v_{0}$ is adjacent to every rim vertex $v_{i}$ for $i \\in \\{1,\\dots,N-1\\}$, and the rim forms a cycle with edges $(v_{i},v_{i+1})$ for $i=1,\\dots,N-2$ and $(v_{N-1},v_{1})$.\n\nFirst, consider the BFS tree rooted at $v_{0}$. At the start, BFS discovers all neighbors of $v_{0}$, namely $v_{1},v_{2},\\dots,v_{N-1}$, and places them at distance $1$ from $v_{0}$. When each $v_{i}$ is later processed, all its neighbors are already discovered: $v_{0}$ is the root and each rim neighbor $v_{i-1}$ or $v_{i+1}$ was discovered from $v_{0}$. Therefore, no vertex appears at a level beyond $1$. Hence the BFS tree is a star centered at $v_{0}$, and its height is\n$$\nH_{BFS}=1.\n$$\n\nNext, consider the DFS tree rooted at $v_{0}$ with the smallest-index rule. From $v_{0}$, the smallest-index neighbor is $v_{1}$, so the first DFS edge is $(v_{0},v_{1})$. At $v_{1}$, the neighbors are $\\{v_{0},v_{2},v_{N-1}\\}$; excluding the visited $v_{0}$, the smallest unvisited neighbor is $v_{2}$, so the next edge is $(v_{1},v_{2})$. Inductively, for $k=2,\\dots,N-2$, at $v_{k}$ the unvisited neighbors among $\\{v_{0},v_{k-1},v_{k+1}\\}$ reduce to $\\{v_{k+1}\\}$ under the smallest-index rule (since $v_{0}$ and $v_{k-1}$ are already visited), and the DFS proceeds along $(v_{k},v_{k+1})$. At $v_{N-1}$, all neighbors $v_{0},v_{N-2},v_{1}$ are already visited, so DFS backtracks all the way to $v_{0}$, at which point all vertices are visited. Therefore, the DFS tree edges form the path\n$$\n(v_{0},v_{1}),(v_{1},v_{2}),\\dots,(v_{N-2},v_{N-1}),\n$$\nwhich has $N-1$ edges from $v_{0}$ to $v_{N-1}$. Thus the DFS tree is a path of length $N-1$ rooted at one end, and its height is\n$$\nH_{DFS}=N-1.\n$$\n\nFor $N=50$, we have\n$$\nH_{DFS}-H_{BFS}=(50-1)-1=48.\n$$", "answer": "$$\\boxed{48}$$", "id": "1483546"}, {"introduction": "Moving beyond the structure of the spanning tree itself, a deeper understanding of DFS involves classifying all of the graph's edges in relation to the traversal. In directed graphs, this classification—into tree, back, forward, and cross edges—is a powerful tool for analyzing graph properties like cycles and connectivity. This problem [@problem_id:1483505] provides hands-on practice with this concept by asking you to perform a DFS and identify a cross edge, which requires a careful accounting of vertex discovery and finish times.", "problem": "Consider a directed graph $G = (V, E)$ with the vertex set $V = \\{s, a, b, c, d\\}$ and the edge set $E = \\{(s, a), (s, c), (a, b), (c, d), (d, b)\\}$.\n\nA Depth-First Search (DFS) is performed on this graph starting from vertex $s$. The algorithm follows a standard convention: when a vertex has multiple unvisited neighbors, they are chosen to be visited in alphabetical order.\n\nIn the context of a DFS on a directed graph, edges are classified into four types based on the relationship between the source vertex $u$ and the destination vertex $v$ of the edge $(u, v)$ in the resulting DFS tree/forest:\n1.  **Tree edge**: An edge to a vertex $v$ that is discovered for the first time by traversing $(u, v)$.\n2.  **Back edge**: An edge where $v$ is an ancestor of $u$.\n3.  **Forward edge**: A non-tree edge where $v$ is a descendant of $u$.\n4.  **Cross edge**: An edge that is not a tree, back, or forward edge. This typically connects two distinct subtrees, where $v$ has been fully explored (i.e., its discovery and finish times are both before $u$ is discovered).\n\nBased on the specified DFS traversal, which one of the following edges is a cross edge?\n\nA. (s, c)\n\nB. (a, b)\n\nC. (d, b)\n\nD. (c, d)", "solution": "To determine the type of each edge, we must perform a Depth-First Search (DFS) on the graph $G$ starting from vertex $s$, following the rule that unvisited neighbors are visited in alphabetical order. We will keep track of the discovery time (when a vertex is first visited) and the finish time (when all of its descendants have been visited) for each vertex. Let's denote discovery time as $d[v]$ and finish time as $f[v]$, and maintain a global timer, $\\textit{time}$.\n\n**Step-by-step DFS Traversal:**\n\n1.  **Start at `s`**: $\\textit{time} = 1$. $d[s] = 1$. Neighbors of `s` are `a` and `c`. In alphabetical order, we visit `a` first. The edge `(s, a)` is explored.\n2.  **Move to `a`**: $\\textit{time} = 2$. $d[a] = 2$. Vertex `a` was unvisited, so `(s, a)` is a **Tree edge**. The neighbor of `a` is `b`. We visit `b`. The edge `(a, b)` is explored.\n3.  **Move to `b`**: $\\textit{time} = 3$. $d[b] = 3$. Vertex `b` was unvisited, so `(a, b)` is a **Tree edge**. Vertex `b` has no outgoing edges. We are finished exploring from `b`.\n4.  **Finish `b`**: $\\textit{time} = 4$. $f[b] = 4$. Backtrack to `a`.\n5.  **Return to `a`**: Vertex `a` has no other unvisited neighbors. We are finished exploring from `a`.\n6.  **Finish `a`**: $\\textit{time} = 5$. $f[a] = 5$. Backtrack to `s`.\n7.  **Return to `s`**: The next unvisited neighbor of `s` is `c`. We visit `c`. The edge `(s, c)` is explored.\n8.  **Move to `c`**: $\\textit{time} = 6$. $d[c] = 6$. Vertex `c` was unvisited, so `(s, c)` is a **Tree edge**. The neighbor of `c` is `d`. We visit `d`. The edge `(c, d)` is explored.\n9.  **Move to `d`**: $\\textit{time} = 7$. $d[d] = 7$. Vertex `d` was unvisited, so `(c, d)` is a **Tree edge**. The neighbor of `d` is `b`. We explore the edge `(d, b)`.\n10. **Analyze edge `(d, b)`**: The destination vertex `b` has already been visited. We must classify this edge. We compare the discovery and finish times of `b` with the discovery time of `d`.\n    - $d[b] = 3$\n    - $f[b] = 4$\n    - $d[d] = 7$\n    The condition for a cross edge $(u, v)$ is that $d[v]  f[v]  d[u]$. For our edge `(d, b)`, this corresponds to $d[b]  f[b]  d[d]$. Substituting the values, we get $3  4  7$, which is true. Therefore, `(d, b)` is a **Cross edge**.\n11. **Return to `d`**: Vertex `d` has no other neighbors. We are finished exploring from `d`.\n12. **Finish `d`**: $\\textit{time} = 8$. $f[d] = 8$. Backtrack to `c`.\n13. **Return to `c`**: Vertex `c` has no other unvisited neighbors. We are finished exploring from `c`.\n14. **Finish `c`**: $\\textit{time} = 9$. $f[c] = 9$. Backtrack to `s`.\n15. **Return to `s`**: Vertex `s` has no other unvisited neighbors. We are finished exploring from `s`.\n16. **Finish `s`**: $\\textit{time} = 10$. $f[s] = 10$. The DFS is complete.\n\n**Summary of Discovery/Finish Times:**\n- s: $d=1, f=10$\n- a: $d=2, f=5$\n- b: $d=3, f=4$\n- c: $d=6, f=9$\n- d: $d=7, f=8$\n\n**Analyzing the Options:**\n\n-   **A. (s, c)**: When this edge was explored from `s`, `c` was unvisited. This is a **Tree edge**.\n-   **B. (a, b)**: When this edge was explored from `a`, `b` was unvisited. This is a **Tree edge**.\n-   **C. (d, b)**: When this edge was explored from `d`, `b` had already been visited and finished ($d[b]=3, f[b]=4$). Since $d[b]  f[b]  d[d]$, this is a **Cross edge**.\n-   **D. (c, d)**: When this edge was explored from `c`, `d` was unvisited. This is a **Tree edge**.\n\nTherefore, the only cross edge among the options is `(d, b)`.", "answer": "$$\\boxed{C}$$", "id": "1483505"}]}