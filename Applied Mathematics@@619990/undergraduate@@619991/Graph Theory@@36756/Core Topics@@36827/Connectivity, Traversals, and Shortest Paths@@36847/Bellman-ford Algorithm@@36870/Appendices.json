{"hands_on_practices": [{"introduction": "The best way to truly grasp an algorithm is to perform its operations by hand. This first exercise guides you through the core mechanism of the Bellman-Ford algorithm: the iterative relaxation process. By manually tracing how distance estimates are updated with each pass over the edges, you will gain a concrete understanding of how the algorithm progressively finds shorter paths, even in the presence of negative edge weights. This practice solidifies the fundamental mechanics before moving to more abstract applications. [@problem_id:1482434]", "id": "1482434", "problem": "In a futuristic research project, scientists are studying a network of five temporal nodes, labeled A, B, C, D, and E, that are interconnected by directed \"chroniton links\". Each link $(u, v)$ has an associated integer \"time-shift\" value, representing the time distortion experienced when traversing from node $u$ to node $v$. Some advanced links even allow for negative time-shifts.\n\nThe network is represented by a directed weighted graph with vertices $V = \\{A, B, C, D, E\\}$. The set of chroniton links and their corresponding time-shifts (weights) is given as a list of tuples $(u, v, w)$:\n$E = [(\\text{A}, \\text{B}, 6), (\\text{A}, \\text{C}, 7), (\\text{B}, \\text{D}, 5), (\\text{B}, \\text{E}, -4), (\\text{C}, \\text{B}, -2), (\\text{C}, \\text{D}, 8), (\\text{D}, \\text{E}, 9), (\\text{E}, \\text{A}, 2), (\\text{E}, \\text{C}, 7)]$\n\nTo calculate the minimum possible total time-shift from a designated source node to all other nodes, the science team employs the Bellman-Ford algorithm. The source node is A. The algorithm initializes the time-shift estimate for node A to 0 and for all other nodes to infinity. Then, it iteratively relaxes the edges. In each pass of the algorithm, the edges are relaxed sequentially in the exact order they appear in the list $E$ above.\n\nWhat is the ordered tuple of time-shift estimates for the nodes $(\\text{A}, \\text{B}, \\text{C}, \\text{D}, \\text{E})$ after exactly two full passes of the Bellman-Ford algorithm have been completed?\n\nA. $(0, 5, 7, 10, 1)$\nB. $(0, 5, 7, 11, 2)$\nC. $(0, 6, 7, 11, 2)$\nD. $(0, 5, 7, 10, 2)$\nE. $(0, 4, 5, 10, 1)$\n\n", "solution": "We apply the Bellman-Ford algorithm from source A with initial estimates $d(A)=0$ and $d(B)=d(C)=d(D)=d(E)=+\\infty$. The relaxation rule is: for each edge $(u,v,w)$, if $d(u)+w<d(v)$, then set $d(v)\\leftarrow d(u)+w$. Edges are processed in the given order on each pass.\n\nPass 1:\n1. $(A,B,6)$: $d(A)+6=0+6=6<+\\infty\\Rightarrow d(B)=6$.\n2. $(A,C,7)$: $d(A)+7=0+7=7<+\\infty\\Rightarrow d(C)=7$.\n3. $(B,D,5)$: $d(B)+5=6+5=11<+\\infty\\Rightarrow d(D)=11$.\n4. $(B,E,-4)$: $d(B)-4=6-4=2<+\\infty\\Rightarrow d(E)=2$.\n5. $(C,B,-2)$: $d(C)-2=7-2=5<d(B)=6\\Rightarrow d(B)=5$.\n6. $(C,D,8)$: $d(C)+8=7+8=15\\not<d(D)=11\\Rightarrow$ no change.\n7. $(D,E,9)$: $d(D)+9=11+9=20\\not<d(E)=2\\Rightarrow$ no change.\n8. $(E,A,2)$: $d(E)+2=2+2=4\\not<d(A)=0\\Rightarrow$ no change.\n9. $(E,C,7)$: $d(E)+7=2+7=9\\not<d(C)=7\\Rightarrow$ no change.\n\nAfter pass 1: $(d(A),d(B),d(C),d(D),d(E))=(0,5,7,11,2)$.\n\nPass 2:\n1. $(A,B,6)$: $0+6=6\\not<5\\Rightarrow$ no change.\n2. $(A,C,7)$: $0+7=7\\not<7\\Rightarrow$ no change.\n3. $(B,D,5)$: $5+5=10<11\\Rightarrow d(D)=10$.\n4. $(B,E,-4)$: $5-4=1<2\\Rightarrow d(E)=1$.\n5. $(C,B,-2)$: $7-2=5\\not<5\\Rightarrow$ no change.\n6. $(C,D,8)$: $7+8=15\\not<10\\Rightarrow$ no change.\n7. $(D,E,9)$: $10+9=19\\not<1\\Rightarrow$ no change.\n8. $(E,A,2)$: $1+2=3\\not<0\\Rightarrow$ no change.\n9. $(E,C,7)$: $1+7=8\\not<7\\Rightarrow$ no change.\n\nAfter pass 2: $(d(A),d(B),d(C),d(D),d(E))=(0,5,7,10,1)$, which corresponds to option A.", "answer": "$$\\boxed{A}$$"}, {"introduction": "Calculating the length of a shortest path is useful, but often the ultimate goal is to know the path itself. This practice focuses on using the final output of the Bellman-Ford algorithm to achieve this. You will learn how to use the predecessor array, a map that stores the \"parent\" of each vertex in the shortest-path tree, to reconstruct the exact sequence of nodes from the source to a destination. This skill is essential for translating the algorithm's numerical results into practical solutions, such as a specific route in a network. [@problem_id:1482432]", "id": "1482432", "problem": "A network administrator is analyzing a small, directed computer network to find the most efficient routing paths from a source server, S. The network consists of four nodes: S (Source), A, B, and T (Target). The links between nodes have an associated cost, which can be positive (representing latency) or negative (representing a processing speed-up or optimized link).\n\nThe network is defined by the following directed edges and their corresponding costs:\n- S to A: cost 4\n- S to B: cost 2\n- S to T: cost 7\n- A to B: cost -3\n- A to T: cost 6\n- B to T: cost 4\n\nThe administrator runs the Bellman-Ford algorithm with S as the source vertex to find the shortest paths to all other nodes. After the algorithm completes, the final shortest-path distance estimates (D) and the predecessor vertices (P) are computed as follows:\n\n| Vertex `v` | Distance `D[v]` | Predecessor `P[v]` |\n|:----------:|:----------------:|:------------------:|\n|      S     |         0        |        NIL         |\n|      A     |         4        |         S          |\n|      B     |         1        |         A          |\n|      T     |         5        |         B          |\n\nGiven this final output from the Bellman-Ford algorithm, what is the shortest path from the source S to the target T?\n\nA. S → T\nB. S → B → T\nC. S → A → T\nD. S → A → B → T\nE. It is not possible to determine the path from the information provided.\n\n", "solution": "We use the Bellman-Ford algorithm’s path reconstruction property: after convergence, the predecessor map $P$ defines a shortest-path tree rooted at the source $S$. Specifically, for any vertex $v \\neq S$ with predecessor $P[v]=u$, the final distances satisfy\n$$\nD[v] = D[u] + w(u,v),\n$$\nand the unique path from $S$ to $v$ in the predecessor graph is a shortest path with total cost $D[v]$.\n\nTo obtain the shortest path from $S$ to $T$, we backtrack predecessors starting at $T$:\n- $P[T] = B$ implies the last edge on the shortest $S \\to T$ path is $B \\to T$.\n- $P[B] = A$ implies the preceding edge is $A \\to B$.\n- $P[A] = S$ implies the first edge is $S \\to A$.\n- $P[S] = \\text{NIL}$ indicates we have reached the source.\n\nThus, the path reconstructed from the predecessor chain is $S \\to A \\to B \\to T$. By the Bellman-Ford correctness condition,\n$$\nD[T] = D[B] + w(B,T) = D[A] + w(A,B) + w(B,T) = D[S] + w(S,A) + w(A,B) + w(B,T),\n$$\nso this predecessor-defined path is the shortest path from $S$ to $T$.\n\nMatching the options, this is exactly option D.", "answer": "$$\\boxed{D}$$"}, {"introduction": "The key advantage of the Bellman-Ford algorithm over alternatives like Dijkstra's is its ability to handle negative edge weights. However, this capability is conditional upon the absence of negative-weight cycles, which would create unstable, infinitely decreasing paths. This problem challenges you to think like a network engineer, carefully modifying an edge weight to harness the benefit of a negative cost while simultaneously ensuring the network remains stable. This exercise moves beyond simple execution to analytical design, deepening your understanding of the critical boundary between a useful negative edge and a problematic negative cycle. [@problem_id:1482465]", "id": "1482465", "problem": "A network administrator is analyzing a small data routing network. The network topology is represented as a directed graph where vertices are routers and edge weights represent the latency (time delay) in milliseconds (ms). Due to the network's protocol, routing decisions always aim to find the path with the minimum total latency from a source S to a destination T.\n\nThe current network configuration is defined by the following vertices {S, A, B, T} and their connections with associated latencies:\n*   S to A: 2 ms\n*   S to B: 8 ms\n*   A to B: 3 ms\n*   B to A: 5 ms\n*   A to T: 10 ms\n*   B to T: 10 ms\n\nThe administrator is planning an upgrade on the link from router A to router B. This upgrade will reduce its latency by a positive integer value $\\Delta$ ms. The new latency of the A to B link will therefore be $3 - \\Delta$ ms. Note that this upgrade might result in a negative latency, representing a scenario where predictive data forwarding gives the link a \"time credit.\"\n\nThe administrator needs to determine the maximum possible integer value for the reduction $\\Delta$ that satisfies two critical conditions simultaneously:\n1.  The overall shortest path (the path with the minimum total latency) from the source router S to the destination router T must be different from the original shortest path before the upgrade.\n2.  The network must remain stable, meaning the upgrade must not introduce any routing loops that would cause the total latency to decrease indefinitely. In graph theory terms, no negative-weight cycles should be created.\n\nWhat is the maximum possible integer value of the latency reduction $\\Delta$ (in ms)?\n\n", "solution": "Model the network as a directed graph with edge weights equal to latencies. The original edge weights are: $w(S,A)=2$, $w(S,B)=8$, $w(A,B)=3$, $w(B,A)=5$, $w(A,T)=10$, $w(B,T)=10$. After the upgrade, $w(A,B)$ becomes $3-\\Delta$ with $\\Delta$ a positive integer.\n\nFirst, determine the original shortest $S$–$T$ path by evaluating the simple $S$–$T$ paths:\n$$\n\\begin{aligned}\nL(S\\to A\\to T)&=2+10=12,\\\\\nL(S\\to B\\to T)&=8+10=18,\\\\\nL(S\\to A\\to B\\to T)&=2+3+10=15,\\\\\nL(S\\to B\\to A\\to T)&=8+5+10=23.\n\\end{aligned}\n$$\nThe minimum is $12$ via $S\\to A\\to T$, so the original shortest path is $S\\to A\\to T$.\n\nAfter the upgrade, only paths that include $A\\to B$ change. The relevant $S$–$T$ path lengths as functions of $\\Delta$ are:\n$$\n\\begin{aligned}\nL_{1}(\\Delta)&=L(S\\to A\\to T)=12,\\\\\nL_{2}(\\Delta)&=L(S\\to B\\to T)=18,\\\\\nL_{3}(\\Delta)&=L(S\\to A\\to B\\to T)=2+(3-\\Delta)+10=15-\\Delta,\\\\\nL_{4}(\\Delta)&=L(S\\to B\\to A\\to T)=23.\n\\end{aligned}\n$$\n\nTo avoid negative-weight cycles (stability), inspect the only directed cycle involving the modified edge, namely $A\\to B\\to A$ with total weight\n$$\nw(A,B)+w(B,A)=(3-\\Delta)+5=8-\\Delta.\n$$\nThe condition of no negative-weight cycles requires\n$$\n8-\\Delta\\geq 0\\quad\\Longleftrightarrow\\quad \\Delta\\leq 8.\n$$\n\nTo ensure the overall shortest $S$–$T$ path changes from the original $S\\to A\\to T$, we must have that path no longer be a shortest path. Since $L_{1}(\\Delta)=12$ is unchanged, it suffices to require some other path be strictly shorter than $12$. The only candidate that can beat $12$ is $L_{3}(\\Delta)=15-\\Delta$, so we need\n$$\n15-\\Delta<12\\quad\\Longleftrightarrow\\quad \\Delta>3.\n$$\nBecause $\\Delta$ is a positive integer, this gives $\\Delta\\in\\{4,5,6,7,8\\}$ when combined with the stability constraint $\\Delta\\leq 8$.\n\nAmong these, the maximum possible integer $\\Delta$ is $\\Delta=8$. For $\\Delta=8$, the cycle $A\\to B\\to A$ has zero weight (not negative), so stability is preserved, and the shortest path length becomes $L_{3}(8)=15-8=7<12$, which is achieved by $S\\to A\\to B\\to T$, different from the original $S\\to A\\to T$.\n\nTherefore, the maximum integer reduction satisfying both conditions is $8$.", "answer": "$$\\boxed{8}$$"}]}