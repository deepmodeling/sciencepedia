{"hands_on_practices": [{"introduction": "Understanding graph traversal begins with mastering the fundamental mechanics of algorithms like Breadth-First Search (BFS). This exercise requires you to meticulously trace a verification algorithm that uses BFS to check a graph coloring for conflicts [@problem_id:1508906]. By simulating the process, you will gain a concrete understanding of how queues, visited sets, and neighbor exploration work together to systematically explore a graph's structure.", "problem": "A telecommunications company is deploying a new wireless network consisting of $N$ transmission towers. To prevent signal interference, adjacent towers in the network must be assigned different frequency channels. A junior engineer has proposed an initial frequency assignment for all towers. Your task is to analyze the output of a specific verification algorithm designed to check this assignment for conflicts.\n\nThe network is modeled as a simple undirected graph where the towers are vertices, indexed from $0$ to $N-1$, and an edge exists between two vertices if their corresponding towers are close enough to interfere. The frequency assignment is given as an array where the $i$-th element is the channel assigned to tower $i$.\n\nThe verification algorithm proceeds as follows:\n1. It performs a Breadth-First Search (BFS) traversal on the graph.\n2. The traversal starts from the vertex with the lowest index (vertex 0). If the graph has multiple disconnected components, the traversal will only explore the component connected to vertex 0.\n3. A queue of vertices to visit is maintained. Initially, it contains only vertex 0. A set of visited vertices is also maintained, initially containing only vertex 0.\n4. In each step, a vertex `u` is dequeued. For each of its neighbors `v`, ordered by their increasing index value, the algorithm checks if vertex `v` has the same assigned frequency as vertex `u`.\n5. If `frequency(u) = frequency(v)`, a conflict is detected. The algorithm immediately terminates and outputs the pair of vertex indices `(u, v)`.\n6. If `frequency(u) != frequency(v)` and `v` has not been visited, `v` is marked as visited and enqueued.\n7. If the BFS completes without finding any such conflicts, the algorithm reports that the assignment is valid for the explored component.\n\nConsider a network with $N=8$ towers, labeled 0 through 7.\nThe frequency assignment is given by the channels: `[Red, Green, Blue, Green, Red, Blue, Green, Red]` for towers 0 through 7, respectively.\nThe interference links (edges) are:\n`(0, 1), (0, 4), (1, 2), (1, 3), (1, 6), (2, 5), (3, 7), (4, 5), (6, 7)`\n\nWhat is the output produced by this verification algorithm for the given network configuration?\n\nA. The pair `(1, 3)`\n\nB. The pair `(0, 4)`\n\nC. The pair `(2, 5)`\n\nD. The frequency assignment is valid.\n\nE. The pair `(4, 5)`", "solution": "We model the network as an undirected graph on vertices $0,1,\\ldots,7$ with edges $\\{(0,1),(0,4),(1,2),(1,3),(1,6),(2,5),(3,7),(4,5),(6,7)\\}$. The assigned frequencies (channels) are $c(0)=\\text{Red}$, $c(1)=\\text{Green}$, $c(2)=\\text{Blue}$, $c(3)=\\text{Green}$, $c(4)=\\text{Red}$, $c(5)=\\text{Blue}$, $c(6)=\\text{Green}$, $c(7)=\\text{Red}$.\n\nThe verification algorithm performs a BFS starting at the lowest-index vertex, which is $0$. It initializes the queue with $[0]$ and the visited set as $\\{0\\}$. At each step it dequeues a vertex $u$ and scans its neighbors $v$ in increasing index order. For each neighbor $v$, it first checks whether $c(u)=c(v)$. If so, it immediately terminates and outputs the pair $(u,v)$. If $c(u)\\neq c(v)$ and $v$ has not been visited, it marks $v$ visited and enqueues it.\n\nProceeding:\n- Dequeue $u=0$. The neighbors of $0$ are $\\{1,4\\}$, ordered as $[1,4]$.\n  - For $v=1$: $c(0)=\\text{Red}$ and $c(1)=\\text{Green}$, so $c(0)\\neq c(1)$. Since $1$ is unvisited, mark visited to get $\\{0,1\\}$ and enqueue $1$, yielding queue $[1]$.\n  - For $v=4$: $c(0)=\\text{Red}$ and $c(4)=\\text{Red}$, so $c(0)=c(4)$. A conflict is detected and the algorithm immediately terminates, outputting the pair $(0,4)$.\n\nSince the algorithm stops at the first detected conflict, the output is $(0,4)$, which corresponds to option B.", "answer": "$$\\boxed{B}$$", "id": "1508906"}, {"introduction": "Graph traversals are not only for finding paths but also for uncovering fundamental structural properties of a network. This problem challenges you to determine the existence of a path with an even number of edges, a question that can be answered elegantly without finding the path itself [@problem_id:1508937]. The solution lies in using a traversal to test for bipartiteness, a core graph property that directly governs path length parity.", "problem": "In the design of a fault-tolerant communication network, engineers are exploring a redundancy protocol. For a data packet to be validated, it must be possible for it to travel from a source node to a destination node by traversing a path with an even number of links. A path is defined as a sequence of distinct vertices connected by edges.\n\nThe network topology is represented by an undirected graph with a set of 8 nodes, labeled A through H. The connections (edges) are given by the following adjacency list:\n- A: [B, D]\n- B: [A, C, G]\n- C: [B, D, F]\n- D: [A, C, E]\n- E: [D, F, H]\n- F: [C, E, G]\n- G: [B, F, H]\n- H: [E, G]\n\nBased on this network structure, which one of the following statements is true?\n\nA. A path with an even number of links exists from node A to node G, but not from node B to node E.\n\nB. A path with an even number of links exists from node B to node E, but not from node A to node G.\n\nC. Paths with an even number of links exist for both pairs (A, G) and (B, E).\n\nD. A path with an even number of links does not exist for either pair (A, G) or (B, E).", "solution": "We need to determine, for the given undirected graph, whether there exist simple paths (paths with all vertices distinct) of even length between the specified pairs of vertices. The key graph-theoretic principle we use is the characterization of bipartite graphs: a graph is bipartite if and only if it contains no odd cycle, and equivalently, its vertices can be partitioned into two disjoint sets so that every edge joins one set to the other. In a bipartite graph with partition sets $X$ and $Y$, any path alternates between $X$ and $Y$, so for any path from $u$ to $v$, the length $\\ell$ satisfies\n$$\n\\ell \\equiv \n\\begin{cases}\n0 \\pmod{2}, & \\text{if } u,v \\in X \\text{ or } u,v \\in Y, \\\\\n1 \\pmod{2}, & \\text{if } u \\in X, v \\in Y \\text{ or } u \\in Y, v \\in X.\n\\end{cases}\n$$\nTherefore, an even-length path between two vertices exists if and only if they lie in the same part of a bipartition, provided the graph is connected between them.\n\nWe now show the given graph is bipartite by constructing a valid $2$-coloring (partition). Start by placing $A$ in $X$. Since $A$ is adjacent to $B$ and $D$, we must place $B,D \\in Y$. Since $B$ is adjacent to $C$ and $G$, we must place $C,G \\in X$. Since $D$ is adjacent to $C$ and $E$, this requires $C \\in X$ (consistent) and $E \\in X$. Next, since $C$ is adjacent to $F$, we place $F \\in Y$. Since $E$ is adjacent to $H$, we place $H \\in Y$. Check all remaining adjacencies: $F$ is adjacent to $C,E,G$ which lie in $X$, and $G$ is adjacent to $B,F,H$ which lie in $Y$, and $H$ is adjacent to $E,G$ which lie in $X$. This assignment is consistent, so the graph is bipartite with\n$$\nX = \\{A,C,E,G\\}, \\quad Y = \\{B,D,F,H\\}.\n$$\n\nApply the parity rule:\n- For $(A,G)$, we have $A \\in X$ and $G \\in X$, so any $A$–$G$ path has even length, hence an even-length path exists. An explicit example is $A-B-G$, which has length $2$ and uses distinct vertices.\n- For $(B,E)$, we have $B \\in Y$ and $E \\in X$, so any $B$–$E$ path has odd length. Therefore, there is no even-length path from $B$ to $E$. For instance, no path of length $2$ exists because from $B$ to any neighbor in $\\{A,C,G\\}$, none is adjacent to $E$, and the bipartition argument rules out all even lengths in general.\n\nThus, an even-length path exists from $A$ to $G$ but not from $B$ to $E$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1508937"}, {"introduction": "Once the basics of graph traversal are understood, we can explore advanced techniques designed for greater efficiency in large-scale networks. This problem introduces a powerful optimization known as bidirectional search, where two traversals expand simultaneously from the source and target [@problem_id:1508918]. By tracing this algorithm, you will see how 'meeting in the middle' can significantly reduce the search space and find a path more quickly than a standard, one-way search.", "problem": "A technology company, \"ConnectSphere\", is testing a new routing algorithm for its server mesh network. The network consists of a set of servers, identified by integer IDs. Data can be transmitted between specific pairs of servers along bidirectional links. The algorithm, named \"Bidirectional Convergence Search (BCS)\", is designed to find a communication path between a source server `s` and a target server `t`.\n\nThe BCS algorithm is specified as follows:\n- Two search processes are initiated simultaneously: a \"forward search\" starting from `s` and a \"backward search\" starting from `t`.\n- The algorithm maintains two sets of visited servers: `V_s` for the forward search and `V_t` for the backward search. Initially, `V_s = {s}` and `V_t = {t}`.\n- It also maintains two first-in-first-out queues of servers to visit, representing the frontiers of each search: `Q_s` and `Q_t`. Initially, `Q_s` contains only `s`, and `Q_t` contains only `t`.\n- The algorithm proceeds in discrete, alternating steps (a forward expansion followed by a backward expansion).\n\n1.  **Forward Expansion Step**: The forward search expands one level. For every server `u` at the current front of `Q_s`, all its neighbors are examined. Any neighbor `v` that has not yet been added to `V_s` is added to `V_s` and also enqueued into a temporary queue for the next forward frontier. After all servers in the current `Q_s` have been processed, `Q_s` is replaced by this temporary queue.\n2.  **Forward Termination Check**: After the forward expansion is complete, the algorithm checks if the sets `V_s` and `V_t` have any servers in common. If `V_s \\cap V_t` is not an empty set, the algorithm terminates immediately.\n3.  **Backward Expansion Step**: If the algorithm has not terminated, the backward search expands one level. This step is analogous to the forward expansion: for every server `u` in `Q_t`, any neighbor `v` not in `V_t` is added to `V_t` and a temporary queue for the next backward frontier. `Q_t` is then replaced by this temporary queue.\n4.  **Backward Termination Check**: After the backward expansion, the algorithm again checks if `V_s \\cap V_t` is non-empty. If it is, the algorithm terminates. Otherwise, the process repeats from the Forward Expansion Step.\n\nConsider a network of 12 servers where the connections are given by the following pairs of server IDs:\n(1, 2), (1, 3), (1, 4), (2, 5), (3, 6), (3, 7), (4, 8), (5, 9), (6, 9), (7, 10), (8, 11), (9, 12), (10, 12), (11, 12).\n\nThe source server is `s=2` and the target server is `t=11`. Your task is to determine the total number of unique servers that have been visited by the algorithm when it terminates. This is the size of the union of the two visited sets, `|V_s \\cup V_t|`, at the moment of termination.", "solution": "Treat the network as an undirected graph with neighbor sets determined from the given bidirectional links. From the pairs, the neighbor sets are\n$$\n\\begin{aligned}\n&N(1)=\\{2,3,4\\},\\quad N(2)=\\{1,5\\},\\quad N(3)=\\{1,6,7\\},\\quad N(4)=\\{1,8\\},\\\\\n&N(5)=\\{2,9\\},\\quad N(6)=\\{3,9\\},\\quad N(7)=\\{3,10\\},\\quad N(8)=\\{4,11\\},\\\\\n&N(9)=\\{5,6,12\\},\\quad N(10)=\\{7,12\\},\\quad N(11)=\\{8,12\\},\\quad N(12)=\\{9,10,11\\}.\n\\end{aligned}\n$$\nInitialize the bidirectional search with source $s=2$ and target $t=11$:\n$$\nV_{s}=\\{2\\},\\quad Q_{s}=[2],\\quad V_{t}=\\{11\\},\\quad Q_{t}=[11].\n$$\nForward expansion step 1 (process all of $Q_{s}$):\nFrom $2$ add unvisited neighbors $1,5$:\n$$\nV_{s}=\\{2,1,5\\},\\quad Q_{s}=[1,5].\n$$\nForward termination check:\n$$\nV_{s}\\cap V_{t}=\\{2,1,5\\}\\cap\\{11\\}=\\varnothing.\n$$\nBackward expansion step 1 (process all of $Q_{t}$):\nFrom $11$ add unvisited neighbors $8,12$:\n$$\nV_{t}=\\{11,8,12\\},\\quad Q_{t}=[8,12].\n$$\nBackward termination check:\n$$\nV_{s}\\cap V_{t}=\\{2,1,5\\}\\cap\\{11,8,12\\}=\\varnothing.\n$$\nForward expansion step 2 (process all of $Q_{s}$):\nFrom $1$ add unvisited neighbors $3,4$; from $5$ add unvisited neighbor $9$:\n$$\nV_{s}=\\{2,1,5,3,4,9\\},\\quad Q_{s}=[3,4,9].\n$$\nForward termination check:\n$$\nV_{s}\\cap V_{t}=\\{2,1,5,3,4,9\\}\\cap\\{11,8,12\\}=\\varnothing.\n$$\nBackward expansion step 2 (process all of $Q_{t}$):\nFrom $8$ add unvisited neighbor $4$; from $12$ add unvisited neighbors $9,10$:\n$$\nV_{t}=\\{11,8,12,4,9,10\\},\\quad Q_{t}=[4,9,10].\n$$\nBackward termination check:\n$$\nV_{s}\\cap V_{t}=\\{2,1,5,3,4,9\\}\\cap\\{11,8,12,4,9,10\\}=\\{4,9\\}\\neq\\varnothing,\n$$\nso the algorithm terminates here. The total number of unique visited servers at termination is\n$$\n|V_{s}\\cup V_{t}|=\\left|\\{1,2,3,4,5,9\\}\\cup\\{11,8,12,4,9,10\\}\\right|=\\left|\\{1,2,3,4,5,8,9,10,11,12\\}\\right|=10.\n$$", "answer": "$$\\boxed{10}$$", "id": "1508918"}]}