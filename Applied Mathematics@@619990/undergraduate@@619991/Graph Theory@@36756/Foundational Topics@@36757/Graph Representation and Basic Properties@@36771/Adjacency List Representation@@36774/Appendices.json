{"hands_on_practices": [{"introduction": "To effectively use any data structure, it's crucial to understand how its size relates to the data it represents. This first practice explores the fundamental connection between the total number of entries in an adjacency list and the number of edges in a graph. By analyzing a complete graph $K_n$, you will develop a formula for the size of its adjacency list representation, providing a concrete understanding of its space requirements. [@problem_id:1479131]", "problem": "Let $K_n$ be a complete graph with $n$ vertices, where $n \\geq 2$. A complete graph is a simple undirected graph in which every pair of distinct vertices is connected by a unique edge.\n\nThe graph is represented using an adjacency list structure. In this representation, for each of the $n$ vertices, we maintain a list of all the other vertices to which it is directly connected.\n\nDetermine a formula for the total number of entries across all the adjacency lists combined for the graph $K_n$. Express your answer as a function of $n$.", "solution": "In an adjacency list representation, the total number of entries across all lists equals the sum of the degrees of all vertices, because each vertex contributes one entry for each of its neighbors.\n\nIn the complete graph $K_{n}$, every vertex is adjacent to every other vertex, so each vertex has degree $n-1$. Therefore, summing degrees directly gives\n$$\n\\sum_{v \\in V} \\deg(v) = n \\cdot (n-1) = n(n-1).\n$$\nEquivalently, by the handshake lemma, the sum of degrees equals twice the number of edges:\n$$\n\\sum_{v \\in V} \\deg(v) = 2|E|.\n$$\nFor $K_{n}$, the number of edges is\n$$\n|E| = \\binom{n}{2} = \\frac{n(n-1)}{2},\n$$\nso\n$$\n\\sum_{v \\in V} \\deg(v) = 2 \\cdot \\frac{n(n-1)}{2} = n(n-1).\n$$\nThus, the total number of adjacency list entries for $K_{n}$ is $n(n-1)$.", "answer": "$$\\boxed{n(n-1)}$$", "id": "1479131"}, {"introduction": "Moving from undirected to directed graphs, we encounter new challenges and applications, such as modeling dependencies in a software project. Standard adjacency lists for directed graphs efficiently store outgoing connections, but what if we need to find vertices with no incoming connections (source vertices)? This exercise challenges you to devise a method to find all 'foundational modules' using only the standard adjacency list, a common and practical task in graph-based analysis. [@problem_id:1479134]", "problem": "In a large software project, the build system analyzes dependencies between different modules to determine the correct compilation order. These dependencies can be modeled as a directed graph $G = (V, E)$, where the set of vertices $V$ represents the modules and a directed edge $(U, V) \\in E$ means that module $U$ must be compiled before module $V$.\n\nThe dependency information is stored in a standard adjacency list representation. For each module $U \\in V$, there is a list, `adj[U]`, containing all modules $V$ for which an edge $(U, V)$ exists.\n\nA \"foundational module\" is defined as a module that has no prerequisites; it does not depend on any other module. In graph theory terms, this corresponds to a \"source vertex,\" which is a vertex with an in-degree of zero.\n\nConsider a project with 8 modules, labeled $V = \\{0, 1, 2, 3, 4, 5, 6, 7\\}$. The adjacency list for the dependency graph is given as follows:\n- `adj[0] = [1, 2]`\n- `adj[1] = [3]`\n- `adj[2] = [3, 4]`\n- `adj[3] = []`\n- `adj[4] = []`\n- `adj[5] = [6]`\n- `adj[6] = [4]`\n- `adj[7] = []`\n\nUsing only the provided adjacency list, identify the complete set of all foundational modules.\n\nA. {3, 4, 7}\n\nB. {0, 5, 7}\n\nC. {0, 5}\n\nD. {7}\n\nE. {0, 1, 2, 5, 6}", "solution": "We are given a directed graph with vertex set $V=\\{0,1,2,3,4,5,6,7\\}$ and adjacency lists specifying outgoing edges. A foundational module is a source vertex, i.e., a vertex with in-degree zero. Let $\\deg^{-}(v)$ denote the in-degree of vertex $v$.\n\nInitialize for all $v \\in V$:\n$$\n\\deg^{-}(v)=0.\n$$\n\nProcess each adjacency list and increment $\\deg^{-}$ for targets of each directed edge:\n- From $0$: edges $(0,1)$ and $(0,2)$ give\n$$\n\\deg^{-}(1)\\leftarrow \\deg^{-}(1)+1=1,\\quad \\deg^{-}(2)\\leftarrow \\deg^{-}(2)+1=1.\n$$\n- From $1$: edge $(1,3)$ gives\n$$\n\\deg^{-}(3)\\leftarrow \\deg^{-}(3)+1=1.\n$$\n- From $2$: edges $(2,3)$ and $(2,4)$ give\n$$\n\\deg^{-}(3)\\leftarrow \\deg^{-}(3)+1=2,\\quad \\deg^{-}(4)\\leftarrow \\deg^{-}(4)+1=1.\n$$\n- From $3$: no edges, no changes.\n- From $4$: no edges, no changes.\n- From $5$: edge $(5,6)$ gives\n$$\n\\deg^{-}(6)\\leftarrow \\deg^{-}(6)+1=1.\n$$\n- From $6$: edge $(6,4)$ gives\n$$\n\\deg^{-}(4)\\leftarrow \\deg^{-}(4)+1=2.\n$$\n- From $7$: no edges, no changes.\n\nCollecting the final in-degrees:\n$$\n\\deg^{-}(0)=0,\\ \\deg^{-}(1)=1,\\ \\deg^{-}(2)=1,\\ \\deg^{-}(3)=2,\\ \\deg^{-}(4)=2,\\ \\deg^{-}(5)=0,\\ \\deg^{-}(6)=1,\\ \\deg^{-}(7)=0.\n$$\n\nThe vertices with $\\deg^{-}(v)=0$ are\n$$\n\\{0,5,7\\}.\n$$\nComparing with the options, this matches option B.", "answer": "$$\\boxed{B}$$", "id": "1479134"}, {"introduction": "Adjacency lists are not just for storing graph structures; they are the backbone of many powerful graph algorithms. This practice delves into solving an optimization problem on a Directed Acyclic Graph (DAG), a structure common in scheduling and dependency analysis. You will develop a dynamic programming approach to find the longest path starting from each vertex, demonstrating how the adjacency list representation facilitates efficient recursive traversals. [@problem_id:1479126]", "problem": "A software project is composed of several interdependent modules. These dependencies form a directed graph where an edge from module `u` to module `v` means that `u` must be completed before `v` can be started. The project management team has confirmed that there are no circular dependencies, meaning the graph is a Directed Acyclic Graph (DAG). The \"completion time\" for a sequence of tasks is determined by the number of sequential dependency steps. Specifically, the length of a path in this graph is defined as the number of edges it contains.\n\nConsider a project with 7 modules, labeled 0 through 6. The dependencies are given by the following adjacency list representation, where `Adj[i]` contains the list of modules that depend directly on module `i`:\n\n*   `Adj[0] = [1, 2]`\n*   `Adj[1] = [3]`\n*   `Adj[2] = [3, 4]`\n*   `Adj[3] = [5]`\n*   `Adj[4] = [5, 6]`\n*   `Adj[5] = []`\n*   `Adj[6] = []`\n\nYour task is to determine, for each module, the length of the longest sequence of dependent modules that must be completed after it. This corresponds to finding the length of the longest path starting from each vertex in the dependency graph.\n\nCalculate the lengths of the longest paths originating from each vertex from 0 to 6, respectively. Present your final answer as a row matrix containing these seven integer lengths in order from vertex 0 to vertex 6.", "solution": "Let the given directed acyclic graph be $G = (V, E)$, where $V = \\{0, 1, 2, 3, 4, 5, 6\\}$ is the set of vertices (modules) and $E$ is the set of edges (dependencies) defined by the adjacency list. We need to find the length of the longest path starting from each vertex $u \\in V$. Let's denote this quantity by $L(u)$. The length of a path is the number of edges it contains.\n\nThis problem can be solved efficiently using dynamic programming with memoization. The key insight is to define $L(u)$ recursively.\nA vertex $u$ with no outgoing edges (a sink node) cannot be the start of any path, so the longest path starting from it has a length of 0.\nFor any other vertex $u$, a path starting at $u$ consists of an edge $(u, v)$ to one of its neighbors $v$, followed by a path starting from $v$. To find the longest path from $u$, we must choose the neighbor $v$ that has the longest path starting from it.\n\nThis gives us the following recurrence relation for $L(u)$:\n- If the out-degree of $u$ is 0 (i.e., `Adj[u]` is empty), then $L(u) = 0$.\n- Otherwise, $L(u) = 1 + \\max_{v \\in \\text{Adj}[u]} \\{L(v)\\}$.\n\nA naive recursive implementation of this formula would be inefficient because the value of $L(v)$ for a single vertex $v$ might be recomputed many times. For instance, in our graph, $L(3)$ would be required to compute both $L(1)$ and $L(2)$.\n\nTo avoid redundant computations, we use memoization. We'll use an array, let's call it `memo`, of the same size as the number of vertices, initialized with a sentinel value (e.g., -1) to indicate that the longest path for that vertex has not yet been computed.\n\nThe algorithm proceeds as follows: We define a function, `compute_L(u)`, that computes $L(u)$.\n1.  If `memo[u]` is not -1, it means we have already computed $L(u)$, so we return the stored value `memo[u]`.\n2.  If `Adj[u]` is empty, $u$ is a sink. We set `memo[u] = 0` and return 0.\n3.  Otherwise, we recursively call `compute_L(v)` for all neighbors $v \\in \\text{Adj}[u]$. We take the maximum of these returned values, add 1, and store the result in `memo[u]`.\n4.  Finally, we iterate through all vertices $i \\in V$ and call `compute_L(i)` if its value hasn't been computed yet.\n\nLet's apply this to the given graph. Initialize `memo = [-1, -1, -1, -1, -1, -1, -1]`.\n\nWe need to compute $L(0), L(1), \\dots, L(6)$. Let's compute them in a depth-first manner, starting from `compute_L(0)`.\n\n- **`compute_L(0)`**: `memo[0]` is -1. `Adj[0] = [1, 2]`. We need $L(1)$ and $L(2)$.\n    - **`compute_L(1)`**: `memo[1]` is -1. `Adj[1] = [3]`. We need $L(3)$.\n        - **`compute_L(3)`**: `memo[3]` is -1. `Adj[3] = [5]`. We need $L(5)$.\n            - **`compute_L(5)`**: `memo[5]` is -1. `Adj[5]` is empty. So, $L(5) = 0$. Set `memo[5] = 0`. Return 0.\n        - Back in `compute_L(3)`, we have $L(5)=0$. So, $L(3) = 1 + L(5) = 1 + 0 = 1$. Set `memo[3] = 1`. Return 1.\n    - Back in `compute_L(1)`, we have $L(3)=1$. So, $L(1) = 1 + L(3) = 1 + 1 = 2$. Set `memo[1] = 2$. Return 2.\n    - Now `compute_L(0)` needs $L(2)$.\n    - **`compute_L(2)`**: `memo[2]` is -1. `Adj[2] = [3, 4]`. We need $L(3)$ and $L(4)$.\n        - **`compute_L(3)`**: `memo[3]` is 1 (already computed). Return 1.\n        - **`compute_L(4)`**: `memo[4]` is -1. `Adj[4] = [5, 6]`. We need $L(5)$ and $L(6)$.\n            - **`compute_L(5)`**: `memo[5]` is 0 (already computed). Return 0.\n            - **`compute_L(6)`**: `memo[6]` is -1. `Adj[6]` is empty. So, $L(6) = 0$. Set `memo[6] = 0$. Return 0.\n        - Back in `compute_L(4)`, we have $L(5)=0$ and $L(6)=0$. So, $L(4) = 1 + \\max(L(5), L(6)) = 1 + \\max(0, 0) = 1$. Set `memo[4] = 1`. Return 1.\n    - Back in `compute_L(2)`, we have $L(3)=1$ and $L(4)=1$. So, $L(2) = 1 + \\max(L(3), L(4)) = 1 + \\max(1, 1) = 2$. Set `memo[2] = 2`. Return 2.\n- Back in `compute_L(0)`, we have $L(1)=2$ and $L(2)=2$. So, $L(0) = 1 + \\max(L(1), L(2)) = 1 + \\max(2, 2) = 3$. Set `memo[0] = 3`.\n\nAt this point, the `memo` array is `[3, 2, 2, 1, 1, 0, 0]`. All values have been computed as part of the initial call to `compute_L(0)`. We can verify our results:\n- $L(6) = 0$ (sink)\n- $L(5) = 0$ (sink)\n- $L(4) = 1 + \\max(L(5), L(6)) = 1 + \\max(0, 0) = 1$\n- $L(3) = 1 + L(5) = 1 + 0 = 1$\n- $L(2) = 1 + \\max(L(3), L(4)) = 1 + \\max(1, 1) = 2$\n- $L(1) = 1 + L(3) = 1 + 1 = 2$\n- $L(0) = 1 + \\max(L(1), L(2)) = 1 + \\max(2, 2) = 3$\n\nThe calculations are consistent. The final list of longest path lengths, ordered from vertex 0 to 6, is (3, 2, 2, 1, 1, 0, 0).", "answer": "$$\\boxed{\\begin{pmatrix} 3 & 2 & 2 & 1 & 1 & 0 & 0 \\end{pmatrix}}$$", "id": "1479126"}]}