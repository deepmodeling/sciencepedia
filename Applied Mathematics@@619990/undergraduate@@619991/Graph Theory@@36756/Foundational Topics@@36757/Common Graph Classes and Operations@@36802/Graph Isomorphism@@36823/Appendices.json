{"hands_on_practices": [{"introduction": "The most direct way to prove that two graphs are *not* isomorphic is to find a structural property that one graph possesses and the other lacks. These properties, known as graph invariants, include basic counts like the number of vertices and edges, as well as more subtle features like degree sequences and cycle structures. This first exercise challenges you to apply this fundamental technique by identifying a key difference between two simple graphs, reinforcing the use of invariants as a powerful tool for disproving isomorphism.", "problem": "Consider two simple, undirected graphs, $G_1$ and $G_2$.\n\nThe graph $G_1$, known as the \"bull graph\", is constructed as follows: It has a set of five vertices $\\{v_1, v_2, v_3, v_4, v_5\\}$. The vertex set $\\{v_1, v_2, v_3\\}$ forms a triangle, meaning the edges $\\{v_1, v_2\\}$, $\\{v_2, v_3\\}$, and $\\{v_3, v_1\\}$ all exist. Additionally, there is an edge from $v_1$ to $v_4$ and an edge from $v_2$ to $v_5$. There are no other edges.\n\nThe graph $G_2$ is the 5-cycle graph, denoted $C_5$. It consists of five vertices connected in a single, circular sequence.\n\nTwo graphs are isomorphic if there exists a one-to-one correspondence between their vertices that preserves the adjacency of vertices. If two graphs are isomorphic, they must share all structural properties (e.g., number of vertices, number of edges, cycle lengths, vertex degrees, etc.).\n\nWhich of the following statements provides a valid reason why graphs $G_1$ and $G_2$ are not isomorphic?\n\nA. The number of vertices in $G_1$ is different from the number of vertices in $G_2$.\n\nB. The number of edges in $G_1$ is different from the number of edges in $G_2$.\n\nC. $G_1$ contains a subgraph isomorphic to a 3-cycle ($C_3$), whereas $G_2$ does not.\n\nD. The minimum degree of any vertex in $G_1$ is the same as the minimum degree of any vertex in $G_2$.\n\nE. Both $G_1$ and $G_2$ are bipartite graphs.", "solution": "We compare isomorphism invariants for $G_{1}$ (bull graph) and $G_{2}=C_{5}$.\n\nCompute basic counts for $G_{1}$:\n- Vertices: $|V(G_{1})|=5$.\n- Edges: the triangle on $\\{v_{1},v_{2},v_{3}\\}$ contributes $3$ edges, plus edges $\\{v_{1},v_{4}\\}$ and $\\{v_{2},v_{5}\\}$, giving $|E(G_{1})|=5$.\n- Degrees: $\\deg(v_{1})=3$, $\\deg(v_{2})=3$, $\\deg(v_{3})=2$, $\\deg(v_{4})=1$, $\\deg(v_{5})=1$, so the degree multiset is $\\{3,3,2,1,1\\}$ and $\\delta(G_{1})=1$.\n- Cycles: $G_{1}$ contains a $C_{3}$ (the triangle on $\\{v_{1},v_{2},v_{3}\\}$).\n\nCompute basic counts for $G_{2}=C_{5}$:\n- Vertices: $|V(G_{2})|=5$.\n- Edges: $|E(G_{2})|=5$.\n- Degrees: every vertex has degree $2$, so the degree multiset is $\\{2,2,2,2,2\\}$ and $\\delta(G_{2})=2$.\n- Cycles: $C_{5}$ contains no $C_{3}$.\n\nEvaluate the statements using isomorphism invariants:\n- A is false because $|V(G_{1})|=|V(G_{2})|=5$.\n- B is false because $|E(G_{1})|=|E(G_{2})|=5$.\n- C is true: presence or absence of a $C_{3}$ is preserved under isomorphism; $G_{1}$ has a $C_{3}$ while $G_{2}$ does not, so they are not isomorphic.\n- D is false because $\\delta(G_{1})=1$ and $\\delta(G_{2})=2$ are not the same.\n- E is false because neither graph is bipartite: $G_{1}$ has a $C_{3}$ and $G_{2}=C_{5}$ is an odd cycle.\n\nTherefore, the valid reason is given by option C.", "answer": "$$\\boxed{C}$$", "id": "1379143"}, {"introduction": "While a single differing property is enough to disprove isomorphism, proving it requires a more constructive effort: you must find an explicit, structure-preserving map between the vertices of the two graphs. This practice shifts the focus from finding differences to demonstrating equivalence through the construction of an isomorphism. The problem explores the intriguing case of a graph that is isomorphic to its own complement, requiring you to find the specific relabeling that reveals their identical structures.", "problem": "Consider two distinct communication networks, Alpha and Beta, each consisting of four nodes labeled $\\{n_1, n_2, n_3, n_4\\}$. The networks are defined by the direct communication links between their nodes.\n\nIn Network Alpha, the links are configured as a simple path: a link exists between $n_1$ and $n_2$, between $n_2$ and $n_3$, and between $n_3$ and $n_4$. No other links exist in Network Alpha.\n\nNetwork Beta is designed based on the principle of complementarity to Network Alpha. A direct link exists between any two nodes in Network Beta if and only if there is *no* direct link between those same two nodes in Network Alpha.\n\nTwo networks are considered structurally identical, or isomorphic, if one can be transformed into the other by simply relabeling its nodes. Formally, this means there exists a one-to-one and onto function $f$ (a bijection) that maps the nodes of Network Alpha to the nodes of Network Beta, such that a link exists between any two nodes $u$ and $v$ in Network Alpha if and only if a link exists between the corresponding nodes $f(u)$ and $f(v)$ in Network Beta.\n\nWhich of the following functions $f: \\{n_1, n_2, n_3, n_4\\} \\to \\{n_1, n_2, n_3, n_4\\}$ represents a valid isomorphism from Network Alpha to Network Beta?\n\nA. $f(n_1) = n_1$, $f(n_2) = n_2$, $f(n_3) = n_3$, $f(n_4) = n_4$\n\nB. $f(n_1) = n_4$, $f(n_2) = n_3$, $f(n_3) = n_2$, $f(n_4) = n_1$\n\nC. $f(n_1) = n_2$, $f(n_2) = n_4$, $f(n_3) = n_1$, $f(n_4) = n_3$\n\nD. $f(n_1) = n_2$, $f(n_2) = n_1$, $f(n_3) = n_4$, $f(n_4) = n_3$\n\nE. $f(n_1) = n_1$, $f(n_2) = n_3$, $f(n_3) = n_2$, $f(n_4) = n_4$", "solution": "Let $V=\\{n_{1},n_{2},n_{3},n_{4}\\}$. In Network Alpha (call it $A$), the edge set is\n$$\nE_{A}=\\big\\{\\{n_{1},n_{2}\\},\\{n_{2},n_{3}\\},\\{n_{3},n_{4}\\}\\big\\}.\n$$\nNetwork Beta (call it $B$) is the complement of $A$ on $V$, so its edges are precisely the non-edges of $A$. Since $K_{4}$ has $6$ edges and $E_{A}$ has $3$, the complement edges are\n$$\nE_{B}=\\big\\{\\{n_{1},n_{3}\\},\\{n_{1},n_{4}\\},\\{n_{2},n_{4}\\}\\big\\}.\n$$\nA function $f:V\\to V$ is an isomorphism from $A$ to $B$ if and only if for all distinct $u,v\\in V$,\n$$\n\\{u,v\\}\\in E_{A}\\quad\\Longleftrightarrow\\quad \\{f(u),f(v)\\}\\in E_{B}.\n$$\n\nTest each option:\n\nA. Identity $f(n_{i})=n_{i}$ fails because $\\{n_{1},n_{2}\\}\\in E_{A}$ maps to $\\{n_{1},n_{2}\\}\\notin E_{B}$.\n\nB. $f(n_{1})=n_{4}$, $f(n_{2})=n_{3}$, $f(n_{3})=n_{2}$, $f(n_{4})=n_{1}$ fails because $\\{n_{1},n_{2}\\}\\in E_{A}$ maps to $\\{n_{4},n_{3}\\}=\\{n_{3},n_{4}\\}\\notin E_{B}$.\n\nC. $f(n_{1})=n_{2}$, $f(n_{2})=n_{4}$, $f(n_{3})=n_{1}$, $f(n_{4})=n_{3}$ works. Check edges of $A$:\n- $\\{n_{1},n_{2}\\}\\mapsto\\{n_{2},n_{4}\\}\\in E_{B}$,\n- $\\{n_{2},n_{3}\\}\\mapsto\\{n_{4},n_{1}\\}=\\{n_{1},n_{4}\\}\\in E_{B}$,\n- $\\{n_{3},n_{4}\\}\\mapsto\\{n_{1},n_{3}\\}\\in E_{B}$.\nCheck non-edges of $A$ (which must map to non-edges of $B$):\n- $\\{n_{1},n_{3}\\}\\mapsto\\{n_{2},n_{1}\\}=\\{n_{1},n_{2}\\}\\notin E_{B}$,\n- $\\{n_{1},n_{4}\\}\\mapsto\\{n_{2},n_{3}\\}\\notin E_{B}$,\n- $\\{n_{2},n_{4}\\}\\mapsto\\{n_{4},n_{3}\\}=\\{n_{3},n_{4}\\}\\notin E_{B}$.\nThus the iff condition holds, so $f$ is an isomorphism.\n\nD. $f(n_{1})=n_{2}$, $f(n_{2})=n_{1}$, $f(n_{3})=n_{4}$, $f(n_{4})=n_{3}$ fails because $\\{n_{1},n_{2}\\}\\in E_{A}$ maps to $\\{n_{1},n_{2}\\}\\notin E_{B}$.\n\nE. $f(n_{1})=n_{1}$, $f(n_{2})=n_{3}$, $f(n_{3})=n_{2}$, $f(n_{4})=n_{4}$ fails because $\\{n_{2},n_{3}\\}\\in E_{A}$ maps to $\\{n_{3},n_{2}\\}=\\{n_{2},n_{3}\\}\\notin E_{B}$.\n\nTherefore, the only valid isomorphism among the options is C.", "answer": "$$\\boxed{C}$$", "id": "1379138"}, {"introduction": "For many graph classes, especially in computer science applications, we need a systematic and automatable way to determine isomorphism. This leads to the idea of a \"canonical label\"â€”a unique signature generated from a graph's structure, where two rooted trees are isomorphic if and only if they produce the same signature. This exercise guides you through a recursive algorithm for generating such a signature for rooted trees, providing a hands-on look at how theoretical concepts of isomorphism are turned into practical algorithms.", "problem": "In database systems designed for hierarchical data, it is often necessary to generate a unique, compact \"structural signature\" for a tree-like data structure. This signature, which we will call the Canonical Hierarchical String (CHS), for a given rooted tree. The CHS is defined by the following recursive rules:\n\n1.  **Leaf Rule**: The CHS of a leaf node (a node with no children) is the string \"0\".\n2.  **Internal Node Rule**: For an internal node (a node with children), its CHS is constructed as follows:\n    a. First, recursively compute the CHS for each of its children. This will produce a set of strings, one for each child's subtree.\n    b. Sort this set of strings lexicographically (i.e., alphabetically, as they would appear in a dictionary, based on standard character codes).\n    c. Concatenate the sorted strings in order, without any separators, to form a single new string.\n    d. Finally, enclose this new concatenated string within a single pair of parentheses, `(` and `)`. This resulting string is the CHS for the internal node.\n\nConsider the following rooted tree defined by its parent-child relationships:\n- The root of the tree is node `N0`.\n- `N0` has two children: `N1` and `N2`.\n- `N1` has two children: `N3` and `N4`.\n- `N2` has three children: `N5`, `N6`, and `N7`.\n- `N3` has two children: `N8` and `N9`.\n- `N4` has one child: `N10`.\n- `N5` has one child: `N11`.\n- `N6` has one child: `N12`.\n- The nodes `N7`, `N8`, `N9`, `N10`, `N11`, and `N12` are all leaf nodes.\n\nDetermine the Canonical Hierarchical String (CHS) for the root node `N0`.", "solution": "We apply the recursive definition of the Canonical Hierarchical String (CHS).\n\nBy the Leaf Rule, for all leaves we have:\n$$\\mathrm{CHS}(N_{7})=\\text{0},\\quad \\mathrm{CHS}(N_{8})=\\text{0},\\quad \\mathrm{CHS}(N_{9})=\\text{0},\\quad \\mathrm{CHS}(N_{10})=\\text{0},\\quad \\mathrm{CHS}(N_{11})=\\text{0},\\quad \\mathrm{CHS}(N_{12})=\\text{0}.$$\n\nFor internal nodes at the next level, use the Internal Node Rule.\n\nFor $N_{3}$ with children $N_{8}$ and $N_{9}$, the multiset of child CHS strings is `{\"0\", \"0\"}`. Sorting yields `\"0\", \"0\"`, concatenation gives `\"00\"`, and enclosing in parentheses gives:\n$$\\mathrm{CHS}(N_{3})=\\text{(00)}.$$\n\nFor $N_{4}$ with child $N_{10}$, we sort `{\"0\"}` (trivial), concatenate to `\"0\"`, and enclose to get:\n$$\\mathrm{CHS}(N_{4})=\\text{(0)}.$$\n\nFor $N_{5}$ with child $N_{11}$, the same reasoning gives:\n$$\\mathrm{CHS}(N_{5})=\\text{(0)}.$$\n\nFor $N_{6}$ with child $N_{12}$, similarly:\n$$\\mathrm{CHS}(N_{6})=\\text{(0)}.$$\n\nNow compute CHS for $N_{1}$, whose children are $N_{3}$ and $N_{4}$ with CHS strings `\"(00)\"` and `\"(0)\"`. To sort lexicographically, compare `\"(0)\"` versus `\"(00)\"` character by character: both start with `(`, then `0`; at the third character, `)` in `\"(0)\"` precedes `0` in `\"(00)\"` in standard character order. Hence the sorted order is `\"(0)\", \"(00)\"`, concatenation yields `\"(0)(00)\"`, and enclosing gives:\n$$\\mathrm{CHS}(N_{1})=\\text{((0)(00))}.$$\n\nNext compute CHS for $N_{2}$, whose children are $N_{5}$, $N_{6}$, and $N_{7}$ with CHS strings `\"(0)\", \"(0)\", \"0\"`. Sorting lexicographically places any string beginning with `(` before `0`, so the order is `\"(0)\", \"(0)\", \"0\"`. Concatenation gives `\"(0)(0)0\"`, and enclosing gives:\n$$\\mathrm{CHS}(N_{2})=\\text{((0)(0)0)}.$$\n\nFinally compute CHS for the root $N_{0}$, whose children are $N_{1}$ and $N_{2}$ with CHS strings `\"((0)(00))\"` and `\"((0)(0)0)\"`. To sort, compare `\"((0)(00))\"` with `\"((0)(0)0)\"` character by character. They agree on the first six characters `((0)(0`; at the seventh character, `)` in `\"((0)(0)0)\"` precedes `0` in `\"((0)(00))\"`. Therefore the sorted order is `\"((0)(0)0)\", \"((0)(00))\"`. Concatenation gives `\"((0)(0)0)((0)(00))\"`, and enclosing yields:\n$$\\mathrm{CHS}(N_{0})=\\text{(((0)(0)0)((0)(00)))}.$$", "answer": "$$\\boxed{(((0)(0)0)((0)(00)))}$$", "id": "1507616"}]}