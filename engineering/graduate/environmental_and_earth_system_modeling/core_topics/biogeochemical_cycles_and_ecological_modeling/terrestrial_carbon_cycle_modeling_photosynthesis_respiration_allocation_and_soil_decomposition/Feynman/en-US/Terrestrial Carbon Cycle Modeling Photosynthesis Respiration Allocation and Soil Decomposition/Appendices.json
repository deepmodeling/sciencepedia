{
    "hands_on_practices": [
        {
            "introduction": "To accurately model the terrestrial carbon cycle, we must first master its primary engine: leaf-level photosynthesis. This initial practice focuses on the celebrated Farquhar, von Caemmerer, and Berry (FvCB) model, a cornerstone of plant ecophysiology. By working through this problem (), you will gain direct experience calculating net CO$_2$ assimilation based on its two primary biochemical limitations—the Rubisco-limited rate ($W_c$) and the electron transport-limited rate ($W_j$). The exercise of identifying the limiting regime and quantifying the sensitivity of assimilation to intercellular CO$_2$ concentration, $\\frac{\\partial A}{\\partial C_i}$, provides a foundational understanding of how a leaf's carbon uptake responds to its internal state and environmental conditions.",
            "id": "3921312",
            "problem": "Consider a steady-state leaf of a temperate $\\text{C}_3$ plant at $25\\,^\\circ\\text{C}$, where net carbon dioxide assimilation arises from the balance of biochemical demand for carbon dioxide and mitochondrial respiration. Use the standard biochemical descriptions for $\\text{C}_3$ photosynthesis commonly attributed to the Farquhar, von Caemmerer, and Berry model. The two biochemical limitations are:\n- The carboxylation-limited rate controlled by Ribulose-1,5-bisphosphate carboxylase/oxygenase (Rubisco), which follows Michaelis–Menten kinetics for carbon dioxide with competitive inhibition by oxygen.\n- The electron-transport-limited rate controlled by light-driven electron transport supporting ribulose-1,5-bisphosphate regeneration, with the canonical stoichiometry for $\\text{C}_3$ photosynthesis.\n\nLet the following parameters be given:\n- Maximum Rubisco carboxylation capacity $V_{c\\max} = 70$ $\\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$,\n- Effective electron transport rate $J = 140$ $\\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$,\n- Day respiration (mitochondrial respiration in the light) $R_{d} = 1.5$ $\\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$,\n- Intercellular carbon dioxide partial pressure $C_{i} = 300$ $\\mu\\mathrm{bar}$,\n- Oxygen partial pressure $O = 21000$ $\\mu\\mathrm{bar}$,\n- Michaelis–Menten constants for Rubisco $K_{c} = 404$ $\\mu\\mathrm{bar}$ and $K_{o} = 27800$ $\\mu\\mathrm{bar}$,\n- Carbon dioxide compensation point in the absence of dark respiration $\\Gamma^{*} = 42$ $\\mu\\mathrm{bar}$.\n\nStarting from the fundamental laws and well-tested formulas underlying the above biochemical model:\n1. Derive expressions for the Rubisco-limited gross assimilation rate $W_{c}$ and the electron-transport-limited gross assimilation rate $W_{j}$ in terms of $V_{c\\max}$, $J$, $C_{i}$, $O$, $K_{c}$, $K_{o}$, and $\\Gamma^{*}$.\n2. Determine the limiting regime by comparing $W_{c}$ and $W_{j}$. Encode the regime as a real number $r$, with $r = 0$ for Rubisco limitation and $r = 1$ for electron-transport limitation.\n3. Compute the net assimilation $A$ as the appropriate gross rate minus $R_{d}$.\n4. Quantify the instantaneous sensitivity $\\partial A/\\partial C_{i}$ at the specified $C_{i}$, using the limiting expression from step 2.\n\nExpress $A$ in $\\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$ and $\\partial A/\\partial C_{i}$ in $\\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}\\,\\mu\\text{bar}^{-1}$. Round both $A$ and $\\partial A/\\partial C_{i}$ to four significant figures. Report the final result as a row vector $(A, \\partial A/\\partial C_{i}, r)$. Do not include units in the row vector.",
            "solution": "The problem statement is evaluated as scientifically grounded, well-posed, and objective. It is based on the standard Farquhar, von Caemmerer, and Berry (FvCB) model of $\\text{C}_3$ photosynthesis, a cornerstone of plant physiology and ecosystem modeling. All necessary parameters are provided with physically realistic values and consistent units, and the tasks are clearly defined. The problem is therefore deemed valid and a full solution is warranted.\n\nThe solution proceeds in four sequential steps as requested.\n\n### 1. Derive expressions for $W_c$ and $W_j$\n\nThe gross assimilation rate is modeled as the minimum of two limiting rates: the Rubisco-limited rate ($W_c$) and the electron-transport-limited rate ($W_j$).\n\nThe Rubisco-limited rate, $W_c$, is determined by the carboxylation capacity of the enzyme Rubisco. The kinetics are described by a Michaelis-Menten equation for the substrate $\\text{CO}_2$ (with partial pressure $C_i$), including competitive inhibition by $\\text{O}_2$ (with partial pressure $O$). The net effect of photorespiration, which consumes a portion of the fixed carbon, is incorporated through the $\\text{CO}_2$ compensation point in the absence of mitochondrial respiration, $\\Gamma^*$. The rate of carboxylation, $v_c$, is given by:\n$$ v_c = \\frac{V_{c\\max} C_i}{C_i + K_c \\left(1 + \\frac{O}{K_o}\\right)} $$\nThe gross assimilation rate, $W_c$, accounts for the carbon released via the photorespiratory pathway by scaling $v_c$ by the factor $(1 - \\Gamma^*/C_i)$, yielding the standard expression:\n$$ W_c = v_c \\left(1 - \\frac{\\Gamma^*}{C_i}\\right) = \\frac{V_{c\\max} (C_i - \\Gamma^*)}{C_i + K_c \\left(1 + \\frac{O}{K_o}\\right)} $$\n\nThe electron-transport-limited rate, $W_j$, is determined by the rate of regeneration of Ribulose-1,5-bisphosphate (RuBP), which is fueled by ATP and NADPH produced by the light-dependent reactions of photosynthesis. The effective rate of electron transport is given as $J$. According to the canonical stoichiometry for $\\text{C}_3$ photosynthesis, the gross assimilation rate $W_j$ is related to $J$, $C_i$, and $\\Gamma^*$. This relationship accounts for the partitioning of electrons between the carboxylation and oxygenation pathways. The standard expression for the electron-transport-limited gross assimilation rate is:\n$$ W_j = \\frac{J (C_i - \\Gamma^*)}{4(C_i + 2\\Gamma^*)} $$\n\n### 2. Determine the limiting regime\n\nTo determine the operative limiting process, we calculate the numerical values for $W_c$ and $W_j$ using the provided parameters:\n- $V_{c\\max} = 70 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$\n- $J = 140 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$\n- $C_i = 300 \\, \\mu\\mathrm{bar}$\n- $O = 21000 \\, \\mu\\mathrm{bar}$\n- $K_c = 404 \\, \\mu\\mathrm{bar}$\n- $K_o = 27800 \\, \\mu\\mathrm{bar}$\n- $\\Gamma^* = 42 \\, \\mu\\mathrm{bar}$\n\nFirst, we calculate the effective Michaelis-Menten constant for carboxylation in the presence of oxygen, let's call it $K_{eff}$:\n$$ K_{eff} = K_c \\left(1 + \\frac{O}{K_o}\\right) = 404 \\, \\mu\\mathrm{bar} \\left(1 + \\frac{21000 \\, \\mu\\mathrm{bar}}{27800 \\, \\mu\\mathrm{bar}}\\right) \\approx 404(1.755396) \\approx 709.18 \\, \\mu\\mathrm{bar} $$\nNow we can compute $W_c$:\n$$ W_c = \\frac{V_{c\\max} (C_i - \\Gamma^*)}{C_i + K_{eff}} = \\frac{70 \\, (300 - 42)}{300 + 709.18} = \\frac{70 \\times 258}{1009.18} = \\frac{18060}{1009.18} \\approx 17.8956 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1} $$\nNext, we compute $W_j$:\n$$ W_j = \\frac{J (C_i - \\Gamma^*)}{4(C_i + 2\\Gamma^*)} = \\frac{140 \\, (300 - 42)}{4(300 + 2 \\times 42)} = \\frac{140 \\times 258}{4(384)} = \\frac{36120}{1536} = 23.515625 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1} $$\nComparing the two rates, we find that $W_c \\approx 17.90 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$ and $W_j \\approx 23.52 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$.\nSince $W_c  W_j$, the gross assimilation rate is limited by Rubisco activity. According to the problem's encoding scheme, this corresponds to a regime identifier $r=0$.\n\n### 3. Compute the net assimilation $A$\n\nThe gross assimilation rate, $A_g$, is the minimum of the potential rates:\n$$ A_g = \\min(W_c, W_j) = W_c \\approx 17.8956 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1} $$\nThe net assimilation rate, $A$, is the gross rate minus the rate of mitochondrial respiration in the light, $R_d$:\n$$ A = A_g - R_d = 17.8956 - 1.5 = 16.3956 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1} $$\nRounding to four significant figures, we get $A = 16.40 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$.\n\n### 4. Quantify the instantaneous sensitivity $\\partial A/\\partial C_{i}$\n\nThe sensitivity of net assimilation to intercellular $\\text{CO}_2$ is the partial derivative $\\partial A/\\partial C_i$. Since the system is Rubisco-limited at the specified operating point, $A = W_c - R_d$. The derivative is therefore:\n$$ \\frac{\\partial A}{\\partial C_i} = \\frac{\\partial}{\\partial C_i} (W_c - R_d) = \\frac{\\partial W_c}{\\partial C_i} $$\nsince $R_d$ is constant with respect to $C_i$. We differentiate the expression for $W_c$ with respect to $C_i$ using the quotient rule. Let $K' = K_c(1 + O/K_o)$ for simplicity.\n$$ W_c = V_{c\\max} \\frac{C_i - \\Gamma^*}{C_i + K'} $$\n$$ \\frac{\\partial W_c}{\\partial C_i} = V_{c\\max} \\left[ \\frac{(1)(C_i + K') - (C_i - \\Gamma^*)(1)}{(C_i + K')^2} \\right] $$\n$$ \\frac{\\partial W_c}{\\partial C_i} = V_{c\\max} \\left[ \\frac{K' + \\Gamma^*}{(C_i + K')^2} \\right] = \\frac{V_{c\\max} \\left( K_c\\left(1 + \\frac{O}{K_o}\\right) + \\Gamma^* \\right)}{\\left( C_i + K_c\\left(1 + \\frac{O}{K_o}\\right) \\right)^2} $$\nSubstituting the numerical values:\n$$ \\frac{\\partial A}{\\partial C_i} = \\frac{70 \\, (709.18 + 42)}{(300 + 709.18)^2} = \\frac{70 \\times 751.18}{(1009.18)^2} = \\frac{52582.6}{1018443.9} \\approx 0.051629 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}\\,\\mu\\text{bar}^{-1} $$\nRounding to four significant figures, we get $\\partial A/\\partial C_i = 0.05163 \\, \\mu\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}\\,\\mu\\text{bar}^{-1}$.\n\nThe final result is the row vector $(A, \\partial A/\\partial C_{i}, r)$ with the calculated values.",
            "answer": "$$\\boxed{\\begin{pmatrix} 16.40  0.05163  0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "After modeling the instantaneous rate of carbon uptake, the next step is to understand how this carbon accumulates and moves through an ecosystem over time. This practice shifts our perspective from fast fluxes to the slower dynamics of carbon stocks using a linear compartmental model, a fundamental tool in ecosystem science. Here, you will represent the ecosystem as a set of interconnected pools (leaf, wood, soil) and use the power of linear algebra to analyze its behavior (). By calculating the system's transient response to a step-change in carbon input, you will explore core concepts like steady states, residence times, and how perturbations propagate through different ecosystem components at varying speeds.",
            "id": "3921364",
            "problem": "Consider a linear terrestrial carbon cycle model with three pools: leaf ($L$), wood ($W$), and soil ($S$). Let $\\mathbf{C}(t) = [C_L(t),C_W(t),C_S(t)]^\\top$ denote the carbon stocks in kilograms of carbon per square meter ($\\text{kg C m}^{-2}$). The system obeys mass conservation, first-order losses, and linear inter-pool transfers from litterfall. Specifically, assume:\n- First-order loss rates $k_L$, $k_W$, and $k_S$ for leaf, wood, and soil respectively, all in $\\mathrm{s^{-1}}$.\n- Fractions $p_{LS}$ and $p_{WS}$, where $p_{LS} \\in [0,1]$ is the fraction of leaf losses that become soil inputs (the remainder $1-p_{LS}$ is respired to the atmosphere), and $p_{WS} \\in [0,1]$ is the fraction of wood losses that become soil inputs (the remainder $1-p_{WS}$ is respired to the atmosphere).\n- An external input vector $\\mathbf{I}(t) = [I_L(t), I_W(t), I_S(t)]^\\top$ in $\\text{kg C m}^{-2}\\,\\text{s}^{-1}$, representing photosynthetic allocation to leaf and wood and exogenous soil inputs (e.g., root exudates).\n\nUnder these assumptions, the state-space model is\n$$\n\\frac{d\\mathbf{C}}{dt} = \\mathbf{I}(t) - \\mathbf{A}\\,\\mathbf{C}(t),\n$$\nwith\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\nk_L  0  0 \\\\\n0  k_W  0 \\\\\n- p_{LS}\\,k_L  - p_{WS}\\,k_W  k_S\n\\end{bmatrix},\n$$\nso that\n$\n\\frac{dC_L}{dt} = I_L(t) - k_L C_L,\\ \n\\frac{dC_W}{dt} = I_W(t) - k_W C_W,\\ \n\\frac{dC_S}{dt} = I_S(t) + p_{LS} k_L C_L + p_{WS} k_W C_W - k_S C_S.\n$\n\nSuppose the system is at steady state under a constant pre-step input $\\mathbf{I}_{\\text{old}}$ for $t  0$, so that $\\mathbf{A}\\,\\mathbf{C}(0) = \\mathbf{I}_{\\text{old}}$. At $t=0$ the leaf input experiences a step increase of magnitude $\\Delta I_L$ (in $\\text{kg C m}^{-2}\\,\\text{s}^{-1}$), i.e.,\n$\nI_L(t) = I_{L,\\text{old}} + \\Delta I_L\\,u(t),\n$\nwhere $u(t)$ is the unit step function. The wood and soil inputs remain unchanged, so $\\mathbf{I}_{\\text{new}} = [I_{L,\\text{old}} + \\Delta I_L,\\ I_{W,\\text{old}},\\ I_{S,\\text{old}}]^\\top$ for $t \\ge 0$.\n\nTask: For each test case below, construct $\\mathbf{A}$, compute the pre-step steady state $\\mathbf{C}(0)$ satisfying $\\mathbf{A}\\,\\mathbf{C}(0)=\\mathbf{I}_{\\text{old}}$, and then compute the transient solution $\\mathbf{C}(t)$ for $t \\ge 0$ using the matrix exponential $e^{-\\mathbf{A}t}$. Report $\\mathbf{C}(T)$ at the specified evaluation time $T$.\n\nExpress all outputs for carbon stocks in $\\text{kg C m}^{-2}$, rounded to six decimal places. Angles are not involved. Do not use the percentage sign; any fractions are to be expressed as decimals.\n\nTest Suite (each parameter set is physically plausible and uses conversions from days and years to seconds where applicable; use $1\\,\\text{day} = 86,400\\,\\text{s}$ and $1\\,\\text{year} = 365 \\times 86,400\\,\\text{s}$):\n1. Happy path:\n   - $k_L = \\frac{1}{30\\,\\text{days}}$,\n   - $k_W = \\frac{1}{5\\,\\text{years}}$,\n   - $k_S = \\frac{1}{2\\,\\text{years}}$,\n   - $p_{LS} = 0.7$, $p_{WS} = 0.9$,\n   - $\\mathbf{I}_{\\text{old}} = \\left[\\frac{0.004}{1\\,\\text{day}},\\ \\frac{0.002}{1\\,\\text{day}},\\ \\frac{0.0001}{1\\,\\text{day}}\\right]$,\n   - $\\Delta I_L = \\frac{0.001}{1\\,\\text{day}}$,\n   - $T = 7\\,\\text{days}$.\n2. Zero step (boundary consistency):\n   - $k_L = \\frac{1}{30\\,\\text{days}}$,\n   - $k_W = \\frac{1}{5\\,\\text{years}}$,\n   - $k_S = \\frac{1}{2\\,\\text{years}}$,\n   - $p_{LS} = 0.7$, $p_{WS} = 0.9$,\n   - $\\mathbf{I}_{\\text{old}} = \\left[\\frac{0.004}{1\\,\\text{day}},\\ \\frac{0.002}{1\\,\\text{day}},\\ \\frac{0.0001}{1\\,\\text{day}}\\right]$,\n   - $\\Delta I_L = \\frac{0}{1\\,\\text{day}}$,\n   - $T = 10\\,\\text{days}$.\n3. Slow wood decay, no leaf-to-soil transfer, fast soil turnover:\n   - $k_L = \\frac{1}{60\\,\\text{days}}$,\n   - $k_W = \\frac{1}{50\\,\\text{years}}$,\n   - $k_S = \\frac{1}{0.5\\,\\text{years}}$,\n   - $p_{LS} = 0.0$, $p_{WS} = 0.6$,\n   - $\\mathbf{I}_{\\text{old}} = \\left[\\frac{0.003}{1\\,\\text{day}},\\ \\frac{0.001}{1\\,\\text{day}},\\ \\frac{0.0002}{1\\,\\text{day}}\\right]$,\n   - $\\Delta I_L = \\frac{0.005}{1\\,\\text{day}}$,\n   - $T = 20\\,\\text{years}$.\n4. Instantaneous evaluation ($T=0$):\n   - $k_L = \\frac{1}{20\\,\\text{days}}$,\n   - $k_W = \\frac{1}{10\\,\\text{years}}$,\n   - $k_S = \\frac{1}{1\\,\\text{year}}$,\n   - $p_{LS} = 0.5$, $p_{WS} = 0.8$,\n   - $\\mathbf{I}_{\\text{old}} = \\left[\\frac{0.006}{1\\,\\text{day}},\\ \\frac{0.0025}{1\\,\\text{day}},\\ \\frac{0.00015}{1\\,\\text{day}}\\right]$,\n   - $\\Delta I_L = \\frac{0.001}{1\\,\\text{day}}$,\n   - $T = 0\\,\\text{days}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item is the list $[C_L(T),C_W(T),C_S(T)]$ for the corresponding test case, with each number rounded to six decimal places (e.g., $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$).",
            "solution": "The user has provided a problem statement that is complete, self-contained, and scientifically grounded. It describes a linear three-pool terrestrial carbon cycle model, a standard construct in environmental and earth system modeling. The governing equations are a system of linear first-order ordinary differential equations, which are well-posed. The parameters and initial conditions are clearly defined, and the task is a standard exercise in linear systems analysis. The problem is therefore deemed valid and a solution will be provided.\n\nThe state of the system is described by the vector of carbon stocks $\\mathbf{C}(t) = [C_L(t), C_W(t), C_S(t)]^\\top$, where $C_L$, $C_W$, and $C_S$ represent the carbon in the leaf, wood, and soil pools, respectively. The dynamics are governed by the linear state-space model:\n$$\n\\frac{d\\mathbf{C}}{dt} = \\mathbf{I}(t) - \\mathbf{A}\\,\\mathbf{C}(t)\n$$\nwhere $\\mathbf{I}(t)$ is the vector of external carbon inputs and $\\mathbf{A}$ is the system matrix. For $t \\ge 0$, the input vector is constant, denoted by $\\mathbf{I}_{\\text{new}}$. The equation can be rewritten as:\n$$\n\\frac{d\\mathbf{C}}{dt} + \\mathbf{A}\\,\\mathbf{C}(t) = \\mathbf{I}_{\\text{new}}\n$$\nThis is a non-homogeneous system of linear ordinary differential equations. The solution can be found by considering the deviation from the new steady state.\n\nFirst, we determine the initial condition $\\mathbf{C}(0)$. The problem states that for $t  0$, the system is at steady state under a constant input $\\mathbf{I}_{\\text{old}}$. At steady state, $\\frac{d\\mathbf{C}}{dt} = \\mathbf{0}$, which implies:\n$$\n\\mathbf{A}\\,\\mathbf{C}(0) = \\mathbf{I}_{\\text{old}}\n$$\nThe system matrix $\\mathbf{A}$ is given by:\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\nk_L  0  0 \\\\\n0  k_W  0 \\\\\n- p_{LS}\\,k_L  - p_{WS}\\,k_W  k_S\n\\end{bmatrix}\n$$\nIts determinant is $\\det(\\mathbf{A}) = k_L k_W k_S$. Since the loss rates $k_L$, $k_W$, and $k_S$ are inverse turnover times, they are strictly positive. Therefore, $\\det(\\mathbf{A}) \\ne 0$, and the matrix $\\mathbf{A}$ is invertible. The initial state $\\mathbf{C}(0)$ is uniquely determined by:\n$$\n\\mathbf{C}(0) = \\mathbf{A}^{-1}\\mathbf{I}_{\\text{old}}\n$$\nNext, we define the new steady state, $\\mathbf{C}_{\\text{new,ss}}$, which the system will approach as $t \\to \\infty$ under the new constant input $\\mathbf{I}_{\\text{new}}$. This state is also found by setting the derivative to zero:\n$$\n\\mathbf{A}\\,\\mathbf{C}_{\\text{new,ss}} = \\mathbf{I}_{\\text{new}} \\implies \\mathbf{C}_{\\text{new,ss}} = \\mathbf{A}^{-1}\\mathbf{I}_{\\text{new}}\n$$\nTo find the transient solution for $t \\ge 0$, we introduce a new variable $\\mathbf{y}(t)$ representing the deviation of the state from the new equilibrium:\n$$\n\\mathbf{y}(t) = \\mathbf{C}(t) - \\mathbf{C}_{\\text{new,ss}}\n$$\nThe time derivative is $\\frac{d\\mathbf{y}}{dt} = \\frac{d\\mathbf{C}}{dt}$, since $\\mathbf{C}_{\\text{new,ss}}$ is a constant vector. Substituting this into the governing equation:\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{I}_{\\text{new}} - \\mathbf{A}\\,\\mathbf{C}(t) = \\mathbf{A}\\,\\mathbf{C}_{\\text{new,ss}} - \\mathbf{A}\\,\\mathbf{C}(t) = -\\mathbf{A}(\\mathbf{C}(t) - \\mathbf{C}_{\\text{new,ss}})\n$$\nThis simplifies to a homogeneous linear differential equation:\n$$\n\\frac{d\\mathbf{y}}{dt} = -\\mathbf{A}\\,\\mathbf{y}(t)\n$$\nThe solution to this equation is given by the matrix exponential:\n$$\n\\mathbf{y}(t) = e^{-\\mathbf{A}t} \\mathbf{y}(0)\n$$\nwhere $\\mathbf{y}(0) = \\mathbf{C}(0) - \\mathbf{C}_{\\text{new,ss}}$ is the initial deviation. Substituting back for $\\mathbf{C}(t)$:\n$$\n\\mathbf{C}(t) - \\mathbf{C}_{\\text{new,ss}} = e^{-\\mathbf{A}t} (\\mathbf{C}(0) - \\mathbf{C}_{\\text{new,ss}})\n$$\nThis yields the complete transient solution for $\\mathbf{C}(t)$ for $t \\ge 0$:\n$$\n\\mathbf{C}(t) = \\mathbf{C}_{\\text{new,ss}} + e^{-\\mathbf{A}t} (\\mathbf{C}(0) - \\mathbf{C}_{\\text{new,ss}})\n$$\nTo implement the solution for each test case, the following algorithm is used:\n1.  Convert all given time-dependent parameters ($k_L$, $k_W$, $k_S$, $\\mathbf{I}_{\\text{old}}$, $\\Delta I_L$, and $T$) into base SI units of seconds ($\\mathrm{s}$) and kilograms of carbon per square meter per second ($\\text{kg C m}^{-2}\\,\\text{s}^{-1}$). The conversion factors are $1\\,\\text{day} = 86400\\,\\text{s}$ and $1\\,\\text{year} = 365 \\times 86400\\,\\text{s}$.\n2.  Construct the matrix $\\mathbf{A}$, the pre-step input vector $\\mathbf{I}_{\\text{old}}$, and the post-step input vector $\\mathbf{I}_{\\text{new}} = [I_{L,\\text{old}} + \\Delta I_L, I_{W,\\text{old}}, I_{S,\\text{old}}]^\\top$.\n3.  Compute the inverse of $\\mathbf{A}$, denoted $\\mathbf{A}^{-1}$.\n4.  Calculate the initial carbon stock vector $\\mathbf{C}(0) = \\mathbf{A}^{-1}\\mathbf{I}_{\\text{old}}$.\n5.  Calculate the new steady-state carbon stock vector $\\mathbf{C}_{\\text{new,ss}} = \\mathbf{A}^{-1}\\mathbf{I}_{\\text{new}}$.\n6.  Compute the matrix exponential $e^{-\\mathbf{A}T}$, where $T$ is the evaluation time in seconds.\n7.  Calculate the final carbon stock vector $\\mathbf{C}(T)$ using the derived solution formula.\n8.  Round the components of $\\mathbf{C}(T)$ to six decimal places as required.\n\nThis procedure is applied to each test case provided in the problem statement. The matrix exponential $e^{-\\mathbf{A}T}$ is computed numerically using the `scipy.linalg.expm` function, and matrix-vector operations are handled by the `numpy` library.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the terrestrial carbon cycle model for given test cases.\n    \"\"\"\n    DAY_S = 86400.0\n    YEAR_S = 365.0 * DAY_S\n\n    test_cases = [\n        {\n            \"kL_inv_time\": 30.0 * DAY_S, \"kW_inv_time\": 5.0 * YEAR_S, \"kS_inv_time\": 2.0 * YEAR_S,\n            \"pLS\": 0.7, \"pWS\": 0.9,\n            \"I_old_vals\": [0.004, 0.002, 0.0001], \"I_old_times\": [DAY_S, DAY_S, DAY_S],\n            \"dIL_val\": 0.001, \"dIL_time\": DAY_S,\n            \"T_val\": 7.0, \"T_unit\": DAY_S\n        },\n        {\n            \"kL_inv_time\": 30.0 * DAY_S, \"kW_inv_time\": 5.0 * YEAR_S, \"kS_inv_time\": 2.0 * YEAR_S,\n            \"pLS\": 0.7, \"pWS\": 0.9,\n            \"I_old_vals\": [0.004, 0.002, 0.0001], \"I_old_times\": [DAY_S, DAY_S, DAY_S],\n            \"dIL_val\": 0.0, \"dIL_time\": DAY_S,\n            \"T_val\": 10.0, \"T_unit\": DAY_S\n        },\n        {\n            \"kL_inv_time\": 60.0 * DAY_S, \"kW_inv_time\": 50.0 * YEAR_S, \"kS_inv_time\": 0.5 * YEAR_S,\n            \"pLS\": 0.0, \"pWS\": 0.6,\n            \"I_old_vals\": [0.003, 0.001, 0.0002], \"I_old_times\": [DAY_S, DAY_S, DAY_S],\n            \"dIL_val\": 0.005, \"dIL_time\": DAY_S,\n            \"T_val\": 20.0, \"T_unit\": YEAR_S\n        },\n        {\n            \"kL_inv_time\": 20.0 * DAY_S, \"kW_inv_time\": 10.0 * YEAR_S, \"kS_inv_time\": 1.0 * YEAR_S,\n            \"pLS\": 0.5, \"pWS\": 0.8,\n            \"I_old_vals\": [0.006, 0.0025, 0.00015], \"I_old_times\": [DAY_S, DAY_S, DAY_S],\n            \"dIL_val\": 0.001, \"dIL_time\": DAY_S,\n            \"T_val\": 0.0, \"T_unit\": DAY_S\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Convert all parameters to base SI units\n        kL = 1.0 / case[\"kL_inv_time\"]\n        kW = 1.0 / case[\"kW_inv_time\"]\n        kS = 1.0 / case[\"kS_inv_time\"]\n        pLS = case[\"pLS\"]\n        pWS = case[\"pWS\"]\n        T_s = case[\"T_val\"] * case[\"T_unit\"]\n\n        I_old_per_s = np.array([v / t for v, t in zip(case[\"I_old_vals\"], case[\"I_old_times\"])])\n        dIL_per_s = case[\"dIL_val\"] / case[\"dIL_time\"]\n\n        # 2. Construct matrices and vectors\n        A = np.array([\n            [kL, 0, 0],\n            [0, kW, 0],\n            [-pLS * kL, -pWS * kW, kS]\n        ])\n\n        I_old = I_old_per_s\n        I_new = I_old + np.array([dIL_per_s, 0, 0])\n\n        # 3. Calculate initial state C(0) and new steady state C_new_ss\n        A_inv = np.linalg.inv(A)\n        C0 = A_inv @ I_old\n        C_new_ss = A_inv @ I_new\n\n        # 4. Calculate the transient solution C(T)\n        if T_s == 0:\n            # At T=0, the state is still the initial state C(0)\n            CT = C0\n        else:\n            # General solution: C(t) = C_new_ss + exp(-A*t) * (C(0) - C_new_ss)\n            mat_exp = expm(-A * T_s)\n            CT = C_new_ss + mat_exp @ (C0 - C_new_ss)\n        \n        # 5. Round and store the result\n        rounded_CT = np.round(CT, 6).tolist()\n        results.append(rounded_CT)\n        \n    # Final print statement in the exact required format without extra spaces.\n    final_output_str = str(results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While analytical solutions are powerful, most real-world ecosystem models are too complex and must be solved numerically. This final practice addresses a critical challenge in computational modeling: ensuring that the numerical simulation upholds fundamental physical laws. A model that allows carbon stocks to become negative or that fails to conserve mass in a closed system lacks credibility. This exercise () requires you to design a numerical time-stepping scheme that, by its very structure, guarantees both non-negativity and mass conservation. By exploring the properties of an implicit time-stepping method, you will develop an essential skill for building robust and physically plausible models of the carbon cycle.",
            "id": "3921332",
            "problem": "Consider a terrestrial carbon system represented by $m$ well-mixed pools with state vector $\\mathbf{C}(t) \\in \\mathbb{R}^m$, where each component $C_i(t)$ denotes carbon stock in pool $i$. The dynamics are governed by internal transfers between pools and external source/sink terms. Let $a_{ij} \\geq 0$ denote the first-order transfer rate from pool $j$ to pool $i$ (so $a_{ij}$ multiplies $C_j$), $\\;r_i \\geq 0$ denote the first-order external loss rate (e.g., respiration to the atmosphere) from pool $i$, and $I_i(t)$ denote the external input to pool $i$. Assume that transfers are conservative internally (i.e., transfer of carbon from pool $j$ to pool $i$ is a loss for $j$ and a gain for $i$ of equal magnitude). The continuous-time mass balance can be written as\n$$\n\\frac{dC_i}{dt} = I_i(t) + \\sum_{j \\neq i} a_{ij} C_j(t) \\;-\\; \\sum_{j \\neq i} a_{ji} C_i(t) \\;-\\; r_i C_i(t), \\quad i = 1,\\dots,m,\n$$\nwhich compactly expresses production from other pools, destruction to other pools, and external loss.\n\nYour task is to design a time discretization from first principles that enforces the following two invariants for any time step $\\Delta t  0$:\n- Non-negativity: if $C_i^n \\geq 0$ for all $i$ at time level $n$, then $C_i^{n+1} \\geq 0$ for all $i$ at time level $n+1$.\n- Mass conservation under zero net external flux: if $I_i^n = 0$ for all $i$ and $r_i = 0$ for all $i$, then $\\sum_{i=1}^m C_i^{n+1} = \\sum_{i=1}^m C_i^n$ exactly.\n\nBegin from the fundamental law of mass balance and the sign constraints on fluxes ($a_{ij} \\geq 0$, $r_i \\geq 0$), and construct a discrete update that achieves both properties without violating the production–destruction pairing inherent to conservative internal transfers. You must not introduce any ad hoc clipping; the scheme must guarantee non-negativity by construction. All quantities are non-dimensional and unitless.\n\nImplement your discretization as a program that advances the system over a specified number of time steps for each test case below. For each test, compute booleans that verify the required properties. Use absolute tolerance $\\epsilon = 10^{-12}$ when checking equalities and monotonicity.\n\nTest Suite:\n- Test $1$ (closed, conservation): $m = 3$, $\\Delta t = 0.5$, $N = 20$ steps. Transfer matrix elements (rates from $j$ to $i$):\n  $$\n  a_{11} = 0, \\; a_{12} = 0.10, \\; a_{13} = 0.05; \\quad\n  a_{21} = 0.08, \\; a_{22} = 0, \\; a_{23} = 0.04; \\quad\n  a_{31} = 0.02, \\; a_{32} = 0.06, \\; a_{33} = 0.\n  $$\n  External loss rates: $r_1 = 0$, $r_2 = 0$, $r_3 = 0$. External inputs: $I_1^n = 0$, $I_2^n = 0$, $I_3^n = 0$ for all $n$. Initial condition: $C_1^0 = 1.2$, $C_2^0 = 0.8$, $C_3^0 = 2.5$. Output boolean $b_1$ that is $true$ if $\\left|\\sum_i C_i^{N} - \\sum_i C_i^0\\right| \\leq \\epsilon$ and all $C_i^n \\geq 0$ for $n = 1,\\dots,N$.\n\n- Test $2$ (external loss, monotone total): same $a_{ij}$ as Test $1$, $\\Delta t = 0.5$, $N = 20$ steps. External loss rates: $r_1 = 0.10$, $r_2 = 0.05$, $r_3 = 0.00$. External inputs: $I_i^n = 0$ for all $i,n$. Initial condition: $C_1^0 = 1.2$, $C_2^0 = 0.8$, $C_3^0 = 2.5$. Output boolean $b_2$ that is $true$ if the total stock is non-increasing at every step, i.e., $\\sum_i C_i^{n+1} \\leq \\sum_i C_i^n + \\epsilon$ for all $n$, and all $C_i^n \\geq 0$.\n\n- Test $3$ (positivity with zeros present): $m = 4$, $\\Delta t = 1.0$, $N = 10$ steps. Transfer matrix elements:\n  $$\n  a_{11} = 0, \\; a_{12} = 0.05, \\; a_{13} = 0.02, \\; a_{14} = 0.00; \\\\\n  a_{21} = 0.03, \\; a_{22} = 0, \\; a_{23} = 0.01, \\; a_{24} = 0.02; \\\\\n  a_{31} = 0.00, \\; a_{32} = 0.04, \\; a_{33} = 0, \\; a_{34} = 0.03; \\\\\n  a_{41} = 0.02, \\; a_{42} = 0.00, \\; a_{43} = 0.05, \\; a_{44} = 0.\n  $$\n  External loss rates: $r_1 = 0.00$, $r_2 = 0.01$, $r_3 = 0.00$, $r_4 = 0.02$. External inputs: $I_i^n = 0$ for all $i,n$. Initial condition: $C_1^0 = 0.00$, $C_2^0 = 1.00$, $C_3^0 = 0.30$, $C_4^0 = 0.00$. Output boolean $b_3$ that is $true$ if all $C_i^n \\geq 0$ for all $n$.\n\n- Test $4$ (edge case, two pools, closed): $m = 2$, $\\Delta t = 0.5$, $N = 5$ steps. Transfer matrix elements:\n  $$\n  a_{11} = 0, \\; a_{12} = 0.70; \\quad\n  a_{21} = 0.30, \\; a_{22} = 0.\n  $$\n  External loss rates: $r_1 = 0$, $r_2 = 0$. External inputs: $I_i^n = 0$ for all $i,n$. Initial condition: $C_1^0 = 0.00$, $C_2^0 = 5.00$. Output boolean $b_4$ that is $true$ if $\\left|\\sum_i C_i^{N} - \\sum_i C_i^0\\right| \\leq \\epsilon$ and all $C_i^n \\geq 0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for Tests $1$–$4$ as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{true},\\text{false},\\text{true},\\text{true}\\right]$). In Python, booleans will appear as $\\left[\\text{True},\\text{False},\\text{True},\\text{True}\\right]$. No other text should be printed.",
            "solution": "The problem requires the design of a numerical time-stepping scheme for a system of linear ordinary differential equations representing a compartmental carbon cycle model. The scheme must, by construction and for any time step $\\Delta t  0$, guarantee two properties: non-negativity of carbon stocks and exact mass conservation for a closed system.\n\nThe governing equation for the carbon stock $C_i(t)$ in pool $i$ is given by:\n$$\n\\frac{dC_i}{dt} = I_i(t) + \\sum_{j \\neq i} a_{ij} C_j(t) \\;-\\; \\sum_{j \\neq i} a_{ji} C_i(t) \\;-\\; r_i C_i(t)\n$$\nwhere $a_{ij} \\geq 0$ is the transfer rate from pool $j$ to pool $i$, $r_i \\geq 0$ is the external loss rate from pool $i$, and $I_i(t)$ is the external input to pool $i$.\n\nThis system can be written in matrix-vector form. Let $\\mathbf{C}(t) = [C_1(t), \\dots, C_m(t)]^T$ be the state vector and $\\mathbf{I}(t) = [I_1(t), \\dots, I_m(t)]^T$ be the input vector. The system is then $\\frac{d\\mathbf{C}}{dt} = \\mathbf{I}(t) + A\\mathbf{C}(t)$, where the system matrix $A \\in \\mathbb{R}^{m \\times m}$ is defined by its elements:\n$$\nA_{ij} =\n\\begin{cases}\na_{ij}  \\text{if } i \\neq j \\\\\n-\\left( \\sum_{k \\neq i} a_{ki} + r_i \\right)  \\text{if } i = j\n\\end{cases}\n$$\nThe off-diagonal elements $A_{ij}$ ($i \\neq j$) are non-negative, representing production of $C_i$ from $C_j$. The diagonal elements $A_{ii}$ are non-positive, representing the total loss rate from pool $i$ due to transfers to other pools and external losses. Such a matrix is a compartmental matrix.\n\nA fundamental property of this continuous system is that for non-negative initial conditions $C_i(0) \\geq 0$ and non-negative inputs $I_i(t) \\geq 0$, the solution remains non-negative, $C_i(t) \\geq 0$ for all $t  0$. Furthermore, if the system is closed (i.e., $I_i(t) = 0$ and $r_i = 0$ for all $i$), the total mass $S(t) = \\sum_{i=1}^m C_i(t)$ is conserved. This is because the column sums of $A$ in a closed system are $\\sum_{i=1}^m A_{ij} = \\sum_{i \\neq j} a_{ij} + A_{jj} = \\sum_{i \\neq j} a_{ij} - \\sum_{k \\neq j} a_{kj} = 0$, which implies $\\frac{dS}{dt} = \\sum_i \\sum_j A_{ij} C_j = \\sum_j (\\sum_i A_{ij}) C_j = 0$.\n\nOur task is to find a discrete-time representation that preserves these properties. We begin from the integral form of the mass balance over a time interval $[t_n, t_{n+1}]$ of duration $\\Delta t = t_{n+1} - t_n$:\n$$\nC_i^{n+1} - C_i^n = \\int_{t_n}^{t_{n+1}} \\left( I_i(t) + (A\\mathbf{C}(t))_i \\right) dt\n$$\nA simple choice is to approximate the integrand using its value at the start of the interval, $t_n$. This yields the Forward Euler method:\n$$\n\\mathbf{C}^{n+1} = \\mathbf{C}^n + \\Delta t (\\mathbf{I}^n + A\\mathbf{C}^n) = (I + \\Delta t A)\\mathbf{C}^n + \\Delta t \\mathbf{I}^n\n$$\nFor non-negativity, the matrix $(I + \\Delta t A)$ must map non-negative vectors to non-negative vectors, which requires all its elements to be non-negative. However, the diagonal elements are $1 + \\Delta t A_{ii} = 1 - \\Delta t (\\sum_{k \\neq i} a_{ki} + r_i)$, which can be negative if $\\Delta t$ is sufficiently large. This violates the requirement that the scheme works for any $\\Delta t  0$.\n\nA superior choice is to approximate the integrand using its value at the end of the interval, $t_{n+1}$. This is the Backward Euler method:\n$$\n\\mathbf{C}^{n+1} - \\mathbf{C}^n = \\Delta t (\\mathbf{I}^{n+1} + A\\mathbf{C}^{n+1})\n$$\nAssuming inputs are piecewise constant over the interval (i.e., $\\mathbf{I}(t) = \\mathbf{I}^n$ for $t \\in [t_n, t_{n+1})$), we have:\n$$\n\\mathbf{C}^{n+1} - \\Delta t A\\mathbf{C}^{n+1} = \\mathbf{C}^n + \\Delta t \\mathbf{I}^n\n$$\n$$\n(I - \\Delta t A)\\mathbf{C}^{n+1} = \\mathbf{C}^n + \\Delta t \\mathbf{I}^n\n$$\nThis is an implicit scheme, as it requires solving a linear system for $\\mathbf{C}^{n+1}$ at each step. Let's analyze its properties.\n\n**1. Non-negativity:**\nThe matrix for the linear system is $M = I - \\Delta t A$. Its elements are:\n- Off-diagonal ($i \\neq j$): $M_{ij} = -\\Delta t A_{ij} = -\\Delta t a_{ij} \\leq 0$.\n- Diagonal ($i = j$): $M_{ii} = 1 - \\Delta t A_{ii} = 1 + \\Delta t (\\sum_{k \\neq i} a_{ki} + r_i) \\geq 1$.\nA matrix with positive diagonal entries, non-positive off-diagonal entries, and which is strictly diagonally dominant (as $M$ is) is a non-singular M-matrix. A key property of non-singular M-matrices is that their inverse, $M^{-1}$, has all non-negative entries. The solution is given by $\\mathbf{C}^{n+1} = M^{-1}(\\mathbf{C}^n + \\Delta t \\mathbf{I}^n)$.\nGiven $C_i^n \\geq 0$ and $I_i^n \\geq 0$, the vector on the right, $(\\mathbf{C}^n + \\Delta t \\mathbf{I}^n)$, is component-wise non-negative. Multiplying a non-negative vector by a non-negative matrix ($M^{-1}$) yields a non-negative vector. Thus, $C_i^{n+1} \\geq 0$ is guaranteed for any $\\Delta t  0$. This fulfills the non-negativity requirement by construction, without any ad-hoc clipping.\n\n**2. Mass Conservation:**\nConsider a closed system where $I_i^n = 0$ and $r_i = 0$ for all $i$. The update rule is $(I - \\Delta t A)\\mathbf{C}^{n+1} = \\mathbf{C}^n$. The total mass at step $n$ is $S^n = \\sum_i C_i^n = \\mathbf{1}^T \\mathbf{C}^n$, where $\\mathbf{1}^T$ is a row vector of ones. Pre-multiplying the update equation by $\\mathbf{1}^T$:\n$$\n\\mathbf{1}^T (I - \\Delta t A) \\mathbf{C}^{n+1} = \\mathbf{1}^T \\mathbf{C}^n\n$$\n$$\n(\\mathbf{1}^T - \\Delta t \\mathbf{1}^T A) \\mathbf{C}^{n+1} = S^n\n$$\nThe $j$-th element of the vector $\\mathbf{1}^T A$ is $\\sum_i A_{ij}$. For a closed system, $r_j=0$, so the column sum is $\\sum_i A_{ij} = \\sum_{i \\neq j} a_{ij} + A_{jj} = \\sum_{i \\neq j} a_{ij} - \\sum_{k \\neq j} a_{kj} = 0$. Therefore, $\\mathbf{1}^T A = \\mathbf{0}^T$ is the zero vector.\nThe equation simplifies to:\n$$\n(\\mathbf{1}^T - \\Delta t \\mathbf{0}^T) \\mathbf{C}^{n+1} = S^n \\implies \\mathbf{1}^T \\mathbf{C}^{n+1} = S^n \\implies S^{n+1} = S^n\n$$\nThe Backward Euler scheme conserves mass exactly for any $\\Delta t  0$ in a closed system.\n\nThe Backward Euler method satisfies both required invariants and is derived from the fundamental mass balance law. The implementation will proceed by constructing the matrix $M=I-\\Delta t A$ and solving the linear system for $\\mathbf{C}^{n+1}$ at each time step.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, dt, N, a, r, C0, I, epsilon):\n    \"\"\"\n    Runs the carbon cycle simulation using the Backward Euler method.\n\n    Args:\n        m (int): Number of pools.\n        dt (float): Time step.\n        N (int): Number of steps.\n        a (np.ndarray): Transfer rate matrix (a_ij from j to i).\n        r (np.ndarray): External loss rate vector.\n        C0 (np.ndarray): Initial carbon stock vector.\n        I (np.ndarray): External input vector (assumed constant).\n        epsilon (float): Tolerance for checks.\n\n    Returns:\n        list: A list of carbon stock vectors over time, [C^0, C^1, ..., C^N].\n    \"\"\"\n    # Construct the continuous system matrix A\n    A = np.copy(a)\n    for j in range(m):\n        # The sum of transfers out of pool j is the sum of column j of a\n        loss_to_other_pools = np.sum(a[:, j])\n        A[j, j] = -(loss_to_other_pools + r[j])\n\n    # Construct the discrete system matrix M for Backward Euler\n    # M C^{n+1} = C^n + dt * I\n    M = np.identity(m) - dt * A\n\n    # Time-stepping loop\n    C_history = [C0]\n    C_current = np.copy(C0)\n    \n    rhs_base = dt * I\n\n    for _ in range(N):\n        rhs = C_current + rhs_base\n        C_next = np.linalg.solve(M, rhs)\n        C_history.append(C_next)\n        C_current = C_next\n\n    return C_history\n\ndef solve():\n    \"\"\"\n    Solves the provided test cases and prints the results.\n    \"\"\"\n    epsilon = 1e-12\n    results = []\n\n    # Test 1: Closed system, conservation check\n    m1 = 3\n    dt1 = 0.5\n    N1 = 20\n    a1 = np.array([[0.0, 0.10, 0.05], [0.08, 0.0, 0.04], [0.02, 0.06, 0.0]])\n    r1 = np.array([0.0, 0.0, 0.0])\n    C0_1 = np.array([1.2, 0.8, 2.5])\n    I1 = np.zeros(m1)\n    \n    C_hist1 = run_simulation(m1, dt1, N1, a1, r1, C0_1, I1, epsilon)\n    \n    all_positive1 = all(np.all(c = -epsilon) for c in C_hist1)\n    initial_total_mass1 = np.sum(C_hist1[0])\n    final_total_mass1 = np.sum(C_hist1[-1])\n    conserved1 = abs(final_total_mass1 - initial_total_mass1) = epsilon\n    results.append(all_positive1 and conserved1)\n\n    # Test 2: External loss, monotone total check\n    m2, dt2, N2 = m1, dt1, N1\n    a2 = a1\n    r2 = np.array([0.10, 0.05, 0.00])\n    C0_2 = C0_1\n    I2 = np.zeros(m2)\n    \n    C_hist2 = run_simulation(m2, dt2, N2, a2, r2, C0_2, I2, epsilon)\n    \n    all_positive2 = all(np.all(c = -epsilon) for c in C_hist2)\n    non_increasing2 = True\n    for n in range(len(C_hist2) - 1):\n        if np.sum(C_hist2[n+1])  np.sum(C_hist2[n]) + epsilon:\n            non_increasing2 = False\n            break\n    results.append(all_positive2 and non_increasing2)\n\n    # Test 3: Positivity with zeros present\n    m3 = 4\n    dt3 = 1.0\n    N3 = 10\n    a3 = np.array([\n        [0.00, 0.05, 0.02, 0.00],\n        [0.03, 0.00, 0.01, 0.02],\n        [0.00, 0.04, 0.00, 0.03],\n        [0.02, 0.00, 0.05, 0.00]\n    ])\n    r3 = np.array([0.00, 0.01, 0.00, 0.02])\n    C0_3 = np.array([0.00, 1.00, 0.30, 0.00])\n    I3 = np.zeros(m3)\n    \n    C_hist3 = run_simulation(m3, dt3, N3, a3, r3, C0_3, I3, epsilon)\n    \n    all_positive3 = all(np.all(c = -epsilon) for c in C_hist3)\n    results.append(all_positive3)\n\n    # Test 4: Edge case, two pools, closed\n    m4 = 2\n    dt4 = 0.5\n    N4 = 5\n    a4 = np.array([[0.0, 0.70], [0.30, 0.0]])\n    r4 = np.array([0.0, 0.0])\n    C0_4 = np.array([0.00, 5.00])\n    I4 = np.zeros(m4)\n    \n    C_hist4 = run_simulation(m4, dt4, N4, a4, r4, C0_4, I4, epsilon)\n    \n    all_positive4 = all(np.all(c = -epsilon) for c in C_hist4)\n    initial_total_mass4 = np.sum(C_hist4[0])\n    final_total_mass4 = np.sum(C_hist4[-1])\n    conserved4 = abs(final_total_mass4 - initial_total_mass4) = epsilon\n    results.append(all_positive4 and conserved4)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}