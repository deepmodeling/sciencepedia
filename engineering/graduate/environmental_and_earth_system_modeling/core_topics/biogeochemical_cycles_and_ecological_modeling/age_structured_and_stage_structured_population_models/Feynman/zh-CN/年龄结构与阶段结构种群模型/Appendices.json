{
    "hands_on_practices": [
        {
            "introduction": "在种群生态学中，我们常常关注由主导特征值 $\\lambda$ 决定的长期渐近行为。然而，种群的短期动态（即瞬时动态）可能截然不同，这在保护生物学和物种管理中尤为重要。本练习 () 旨在阐明一个关键概念：即使一个种群的生命史参数预示着长期增长，其初始年龄结构也可能导致种群在短期内经历意想不到的衰退。",
            "id": "1830225",
            "problem": "一个生态学家团队正在研究一种新发现的岛屿爬行动物物种。他们使用年龄结构法来模拟其种群动态，时间步长为一年。该种群被分为四个年龄组：\n-   第1组：幼体（0至1岁）\n-   第2组：亚成体（1至2岁）\n-   第3组：成体（2至3岁）\n-   第4组：衰老体（3至4岁）\n\n没有个体能存活超过4年。年龄组 $i$ 中个体的单位繁殖率，记为 $F_i$，是该个体每年产下的平均幼体数量。年龄组 $i$ 中个体的存活率，记为 $S_i$，是其存活并进入年龄组 $i+1$ 的概率。生态学家们确定了以下生命率：\n-   繁殖率：$F_1 = 0$, $F_2 = 1.0$, $F_3 = 2.0$, $F_4 = 0$。\n-   存活率：$S_1 = 0.8$, $S_2 = 0.6$, $S_3 = 0.3$。\n\n在时间 $t=0$ 时对种群进行了初始普查，得到各年龄组的数量如下：\n-   $n_1(0) = 100$ 个幼体\n-   $n_2(0) = 100$ 个亚成体\n-   $n_3(0) = 100$ 个成体\n-   $n_4(0) = 2000$ 个衰老个体\n\n虽然该种群的长期增长率大于1，但初始年龄分布可能会导致瞬时动态。计算时间 $t=1$ 年时的总种群数量与时间 $t=0$ 时的总种群数量之比。将你的最终答案四舍五入到三位有效数字。",
            "solution": "设 $n_i(t)$ 表示时间 $t$ 时年龄组 $i$ 中的个体数量，设 $N(t)=\\sum_{i=1}^{4}n_i(t)$ 为时间 $t$ 时的总种群数量。对于时间步长为一年的 Leslie 矩阵模型，年龄结构的更新方程为\n$$\nn_1(t+1)=\\sum_{i=1}^{4}F_i\\,n_i(t),\\quad\nn_2(t+1)=S_1\\,n_1(t),\\quad\nn_3(t+1)=S_2\\,n_2(t),\\quad\nn_4(t+1)=S_3\\,n_3(t).\n$$\n使用给定的繁殖率 $F_1=0$, $F_2=1.0$, $F_3=2.0$, $F_4=0$，存活率 $S_1=0.8$, $S_2=0.6$, $S_3=0.3$，以及初始普查数据 $n_1(0)=100$, $n_2(0)=100$, $n_3(0)=100$, $n_4(0)=2000$，我们计算：\n$$\nn_1(1)=F_1n_1(0)+F_2n_2(0)+F_3n_3(0)+F_4n_4(0)=0\\cdot 100+1.0\\cdot 100+2.0\\cdot 100+0\\cdot 2000=300,\n$$\n$$\nn_2(1)=S_1n_1(0)=0.8\\cdot 100=80,\\quad\nn_3(1)=S_2n_2(0)=0.6\\cdot 100=60,\\quad\nn_4(1)=S_3n_3(0)=0.3\\cdot 100=30.\n$$\n因此，\n$$\nN(0)=n_1(0)+n_2(0)+n_3(0)+n_4(0)=100+100+100+2000=2300,\n$$\n$$\nN(1)=n_1(1)+n_2(1)+n_3(1)+n_4(1)=300+80+60+30=470.\n$$\n所要求的比值为\n$$\n\\frac{N(1)}{N(0)}=\\frac{470}{2300}=0.204347826\\ldots\n$$\n四舍五入到三位有效数字，结果为 $0.204$。",
            "answer": "$$\\boxed{0.204}$$"
        },
        {
            "introduction": "瞬时动态的出现引出了一个更深层次的数学问题：其背后的机制是什么？答案在于矩阵的非正规性 (non-normality) 及其非正交的特征向量。本练习 () 将引导你深入探索这一现象，通过构建一个 Leslie 矩阵，展示即使在渐近衰退（主导特征值 $\\lambda \\lt 1$）的情况下，种群如何也能经历显著的瞬时增长。",
            "id": "3860255",
            "problem": "考虑一个具有两个年龄组（幼年和成年）的离散时间年龄结构种群模型，其动态由一个 Leslie 矩阵控制。设时间 $t$ 的种群状态为 $n_t \\in \\mathbb{R}^2_{\\ge 0}$，更新规则为 $n_{t+1} = L n_t$，其中 Leslie 矩阵 $L$ 由下式给出\n$$\nL = \\begin{pmatrix}\nf_1   f_2 \\\\\ns_1   0\n\\end{pmatrix}.\n$$\n假设以下具有生物学合理性的参数：幼年繁殖率 $f_1 = 0.3$，成年繁殖率 $f_2 = 1.5$，以及幼年存活率 $s_1 = 0.4$。$L$ 的元素是非负的，表示与标准年龄结构种群模型一致的特定年龄繁殖率和存活率。\n\n仅从 Leslie 矩阵、谱半径、特征向量和非正规性的定义出发，分析此系统，以证明该矩阵 $L$ 是非正规的，并且其主特征值 $\\lambda$ 严格小于 $1$。解释右特征向量的非正交性如何在主特征值小于 $1$ 的情况下仍能产生瞬时增长，从而构建一个 $\\lambda  1$ 且表现出瞬时增长的非正规 Leslie 矩阵的明确示例。\n\n将时间 $t$ 的总种群数量定义为 $\\|n_t\\|_1 = |(n_t)_1| + |(n_t)_2|$。对于满足 $\\|n_0\\|_1 = 1$ 的初始状态 $n_0$，两个时间步内的最大瞬时增长因子为\n$$\nG_{\\max}(2) \\equiv \\sup_{\\|n_0\\|_1 = 1} \\frac{\\|n_2\\|_1}{\\|n_0\\|_1}.\n$$\n计算上述矩阵 $L$ 的 $G_{\\max}(2)$。将你的最终答案表示为一个无单位数，并四舍五入到四位有效数字。",
            "solution": "问题要求分析一个给定的 $2 \\times 2$ Leslie 矩阵，包括证明其非正规性，证明其主特征值小于 $1$，解释瞬时增长，以及计算两个时间步内的最大增长因子 $G_{\\max}(2)$。\n\n该问题被验证为具有科学依据、问题明确且客观。所有必要信息均已提供，该任务是数理种群生物学中的一个标准练习。\n\n首先，我们将给定的参数值，即幼年繁殖率 $f_1 = 0.3$，成年繁殖率 $f_2 = 1.5$，以及幼年存活率 $s_1 = 0.4$，代入 Leslie 矩阵 $L$ 中：\n$$\nL = \\begin{pmatrix} f_1   f_2 \\\\ s_1   0 \\end{pmatrix} = \\begin{pmatrix} 0.3   1.5 \\\\ 0.4   0 \\end{pmatrix}\n$$\n\n**1. 矩阵 $L$ 的非正规性**\n\n如果一个矩阵 $A$ 与其共轭转置 $A^*$ 可交换，即 $AA^* = A^*A$，则该矩阵被定义为正规矩阵。对于像 $L$ 这样的实矩阵，此条件变为 $LL^T = L^T L$，其中 $L^T$ 是 $L$ 的转置。\n\n$L$ 的转置是：\n$$\nL^T = \\begin{pmatrix} 0.3   0.4 \\\\ 1.5   0 \\end{pmatrix}\n$$\n现在，我们计算乘积 $LL^T$ 和 $L^T L$：\n$$\nLL^T = \\begin{pmatrix} 0.3   1.5 \\\\ 0.4   0 \\end{pmatrix} \\begin{pmatrix} 0.3   0.4 \\\\ 1.5   0 \\end{pmatrix} = \\begin{pmatrix} (0.3)^2 + (1.5)^2   (0.3)(0.4) \\\\ (0.4)(0.3)   (0.4)^2 \\end{pmatrix} = \\begin{pmatrix} 0.09 + 2.25   0.12 \\\\ 0.12   0.16 \\end{pmatrix} = \\begin{pmatrix} 2.34   0.12 \\\\ 0.12   0.16 \\end{pmatrix}\n$$\n$$\nL^T L = \\begin{pmatrix} 0.3   0.4 \\\\ 1.5   0 \\end{pmatrix} \\begin{pmatrix} 0.3   1.5 \\\\ 0.4   0 \\end{pmatrix} = \\begin{pmatrix} (0.3)^2 + (0.4)^2   (0.3)(1.5) \\\\ (1.5)(0.3)   (1.5)^2 \\end{pmatrix} = \\begin{pmatrix} 0.09 + 0.16   0.45 \\\\ 0.45   2.25 \\end{pmatrix} = \\begin{pmatrix} 0.25   0.45 \\\\ 0.45   2.25 \\end{pmatrix}\n$$\n由于 $LL^T \\neq L^T L$，矩阵 $L$ 是非正规的。\n\n**2. 特征值分析**\n\n$L$ 的特征值 $\\lambda$ 是特征方程 $\\det(L - \\lambda I) = 0$ 的根，其中 $I$ 是单位矩阵。\n$$\n\\det \\begin{pmatrix} 0.3 - \\lambda   1.5 \\\\ 0.4   -\\lambda \\end{pmatrix} = 0\n$$\n$$\n(0.3 - \\lambda)(-\\lambda) - (1.5)(0.4) = 0\n$$\n$$\n-0.3\\lambda + \\lambda^2 - 0.6 = 0\n$$\n$$\n\\lambda^2 - 0.3\\lambda - 0.6 = 0\n$$\n使用二次公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$：\n$$\n\\lambda = \\frac{0.3 \\pm \\sqrt{(-0.3)^2 - 4(1)(-0.6)}}{2} = \\frac{0.3 \\pm \\sqrt{0.09 + 2.4}}{2} = \\frac{0.3 \\pm \\sqrt{2.49}}{2}\n$$\n两个特征值为 $\\lambda_1 = \\frac{0.3 + \\sqrt{2.49}}{2}$ 和 $\\lambda_2 = \\frac{0.3 - \\sqrt{2.49}}{2}$。\n决定种群长期渐近行为的主特征值是模最大的那个。根据非负矩阵的 Perron-Frobenius 定理，这个值是正实数特征值，即 $\\lambda = \\lambda_1$。\n\n我们需要证明 $\\lambda  1$：\n$$\n\\frac{0.3 + \\sqrt{2.49}}{2}  1\n$$\n$$\n0.3 + \\sqrt{2.49}  2\n$$\n$$\n\\sqrt{2.49}  1.7\n$$\n两边平方（两边均为正）：\n$$\n2.49  (1.7)^2 = 2.89\n$$\n这个不等式成立，所以主特征值 $\\lambda$ 严格小于 $1$。这意味着对于任何初始状态 $n_0$，种群数量将渐近衰减至零，即 $\\lim_{t\\to\\infty} n_t = 0$。\n\n**3. 由非正规性引起的瞬时增长**\n\n已确立的事实是：(i) $L$ 是非正规的，以及 (ii) 其主特征值（谱半径）$\\rho(L) = \\lambda  1$。\n$L$ 的非正规性意味着其特征向量不是正交的。一个初始种群向量 $n_0$ 可以投影到特征向量构成的基上。种群的演化由 $n_t = L^t n_0$ 给出。由于特征向量的非正交性，在短时间内各分量之间可能发生相长干涉。这可能导致种群数量（由选定的范数衡量）在最终由 $\\rho(L)  1$ 决定的衰减接管之前出现暂时性增长。这种现象被称为瞬时增长。\n\n更正式地说，如果对于某个整数 $k \\ge 1$，矩阵范数 $\\|L^k\\|$ 大于 $1$，则可能出现瞬时增长。对于一个正规矩阵 $A$，其诱导 2-范数满足 $\\|A^k\\|_2 = (\\rho(A))^k$。如果 $\\rho(A)  1$，那么对于所有 $k \\ge 1$ 都有 $\\|A^k\\|_2  1$，这排除了（在 2-范数下的）瞬时增长。对于像 $L$ 这样的非正规矩阵，即使当 $\\rho(L)  1$ 时，也可能出现 $\\|L^k\\| > 1$。这个矩阵 $L$ 提供了一个明确的例子。\n\n**4. $G_{\\max}(2)$ 的计算**\n\n两个时间步内的最大瞬时增长因子 $G_{\\max}(2)$ 定义为：\n$$\nG_{\\max}(2) = \\sup_{\\|n_0\\|_1 = 1} \\frac{\\|n_2\\|_1}{\\|n_0\\|_1}\n$$\n由于 $n_2 = L^2 n_0$ 并且我们考虑的是满足 $\\|n_0\\|_1 = 1$ 的初始状态，这可以简化为：\n$$\nG_{\\max}(2) = \\sup_{\\|n_0\\|_1 = 1} \\|L^2 n_0\\|_1\n$$\n这个表达式是矩阵 $L^2$ 的诱导矩阵 1-范数的定义，记为 $\\|L^2\\|_1$。矩阵的 1-范数是其各列绝对值之和的最大值。\n\n首先，我们计算矩阵 $L^2$：\n$$\nL^2 = L \\cdot L = \\begin{pmatrix} 0.3   1.5 \\\\ 0.4   0 \\end{pmatrix} \\begin{pmatrix} 0.3   1.5 \\\\ 0.4   0 \\end{pmatrix}\n$$\n$$\nL^2 = \\begin{pmatrix} (0.3)(0.3) + (1.5)(0.4)   (0.3)(1.5) + (1.5)(0) \\\\ (0.4)(0.3) + (0)(0.4)   (0.4)(1.5) + (0)(0) \\end{pmatrix}\n$$\n$$\nL^2 = \\begin{pmatrix} 0.09 + 0.60   0.45 \\\\ 0.12   0.60 \\end{pmatrix} = \\begin{pmatrix} 0.69   0.45 \\\\ 0.12   0.60 \\end{pmatrix}\n$$\n$L^2$ 的所有元素都是非负的，因此求和中的绝对值是多余的。我们计算 $L^2$ 的每一列的和：\n第 1 列的和：$0.69 + 0.12 = 0.81$\n第 2 列的和：$0.45 + 0.60 = 1.05$\n\n诱导 1-范数是这些和中的最大值：\n$$\n\\|L^2\\|_1 = \\max(0.81, 1.05) = 1.05\n$$\n因此，两个时间步内的最大瞬时增长因子是 $G_{\\max}(2) = 1.05$。由于 $G_{\\max}(2) > 1$，尽管该系统是渐近稳定的，但它在两个时间步内表现出瞬时增长。\n\n问题要求答案四舍五入到四位有效数字。\n$$\n1.05 = 1.050\n$$",
            "answer": "$$\\boxed{1.050}$$"
        },
        {
            "introduction": "从理论分析转向实际应用，一个核心挑战是如何根据经验数据构建和验证模型。本练习 () 提供了一个完整的、从数据到模型的实践工作流程。你将学习如何从普查和转移数据中估计转移概率和繁殖力，构建阶段结构投影矩阵，并使用统计检验来评估模型的一个基本假设——马尔可夫性。这个过程是连接理论模型与现实世界应用的关键桥梁。",
            "id": "3860290",
            "problem": "给定某单一物种在固定时间步长下监测得到的离散体型分级的普查和转移数据。目标是构建一个阶段结构投影矩阵，该矩阵基于生存、生长和繁殖将种群向量从一个时间步推进到下一个时间步，并评估阶段层面的动态是否与马尔可夫过程假设一致。此构建的基础包括以下经过充分检验的事实和核心定义：阶段结构种群由一个作用于阶段丰度向量的非负投影矩阵表示；离散阶段之间的生存和生长可以通过一个与马尔可夫链一致的阶段间转移概率矩阵来建模；繁殖可以表示为各阶段对一个预定义的新生阶段的贡献；根据 Perron-Frobenius 定理，非负矩阵的主特征值决定了渐近增长率；多项式模型的最大似然估计 (MLE) 产生相对频率估计量，而狄利克雷共轭先验产生一个正则化估计量，以避免零计数导致的退化情况。\n\n您必须在程序中从第一性原理出发实现以下概念：\n- 设存在 $K$ 个离散体型阶段，索引为 $i \\in \\{1,\\dots,K\\}$。令 $n_t(j)$ 表示在当前时间 $t$ 观测到的处于阶段 $j$ 的个体数量，令 $N(i,j)$ 表示在存活者中观测到的从时间 $t$ 的阶段 $j$ 转移到时间 $t+1$ 的阶段 $i$ 的个体数量。特定阶段存活率 $s_j$ 是阶段 $j$ 中存活到下一个时间步任何阶段的个体比例，给定存活的情况下，目标阶段的条件生长分布由每个 $j$ 对应于所有 $i$ 的一个概率向量表示，记为 $p_{ij}$，该向量应使用最大似然估计从 $N(i,j)$ 估计，并可选择性地通过一个集中参数为 $\\alpha_{\\text{Dir}}$ 的对称狄利克雷先验进行正则化以处理零计数。阶段层面的马尔可夫假设是指下一阶段结果的分布仅取决于当前阶段 $j$，而不取决于 $j$ 之前的阶段。\n- 令 $f_j$ 表示各阶段的繁殖力，定义为在时间 $t$ 处于阶段 $j$ 的一个个体在时间 $t+1$ 贡献进入阶段 $i=1$ 的新生个体的期望数量。使用阶段 $j$ 的汇总后代计数除以该区间内阶段 $j$ 的抽样亲本个体数量来估计 $f_j$。\n- 构建阶段结构投影矩阵 $A \\in \\mathbb{R}^{K \\times K}$，使得 $A_{ij}$ 等于在时间 $t$ 处于阶段 $j$ 的每个个体在时间 $t+1$ 产生的处于阶段 $i$ 的个体期望数量。在第一行（新生阶段）适当地合并生存-生长和繁殖力。渐近增长率 $\\lambda$ 是 $A$ 的主特征值，稳定阶段分布是与 $\\lambda$ 相关联并归一化使其总和为 $1$ 的特征向量。\n- 使用连续三个时间步的汇总三元转移计数来评估马尔可夫假设。对于每个当前阶段 $j$，给定进入下一阶段 $i$ 的转移计数汇总，这些计数按两种先前阶段历史类别（例如，相对于 $j$ 的“先前-低”与“先前-高”）划分。对于固定的 $j$，使用适当的拟合优度检验来检验两种先前阶段类别间的分布相等性，并确定在水平 $\\alpha_{\\text{Sig}}$ 下是否存在反对马尔可夫假设的统计显著证据。如果任何阶段 $j$ 显示出对先前阶段类别的显著依赖性，则认为该测试案例的马尔可夫假设被违反。如果由于计数不足而无法对某个 $j$ 进行检验，则视该 $j$ 未提供反对该假设的证据。\n\n您的程序必须纯粹使用数学和逻辑运算来实现以上内容。以下测试套件提供了三个科学上合理的案例，所有量均为无单位量。对于每个案例，构建 $A$，计算主特征值 $\\lambda$，并评估马尔可夫假设以产生一个布尔判定。使用给定的 $K$、$n_t$、$N$、繁殖力亲本样本计数 $m_j$、繁殖力后代计数 $b_j$、狄利克雷集中参数 $\\alpha_{\\text{Dir}}$ 和马尔可夫检验显著性水平 $\\alpha_{\\text{Sig}}$。所有整数和实数均在测试套件中提供。需要时，通过对称狄利克雷正则化处理零计数。如果 $n_t(j)=0$，则设置 $s_j=0$，并确保相应的列（如果存在）仅贡献繁殖力。\n\n测试套件：\n- 案例 1 (理想情形，中等计数，适度正则化，无马尔可夫违例)：\n    - $K=4$\n    - $n_t = [120, 80, 60, 40]$\n    - $N$ 的列对应 $j=1,2,3,4$；行对应目标阶段 $i=1,2,3,4$：\n      - 第1列：$[50, 30, 8, 2]$\n      - 第2列：$[10, 28, 18, 4]$\n      - 第3列：$[0, 6, 28, 14]$\n      - 第4列：$[0, 2, 8, 22]$\n    - 繁殖力亲本 $m = [60, 50, 40, 30]$\n    - 繁殖力后代 $b = [10, 25, 80, 90]$\n    - $\\alpha_{\\text{Dir}} = 0.5$\n    - $\\alpha_{\\text{Sig}} = 0.05$\n    - 三元汇总计数，对于每个当前阶段 $j$，分为两种先前阶段类别，每个类别是关于下一阶段 $i$ 的数组：\n      - $j=1$：先前-低 $[40, 25, 10, 2]$，先前-高 $[35, 22, 9, 3]$\n      - $j=2$：先前-低 $[12, 25, 14, 5]$，先前-高 $[10, 22, 12, 6]$\n      - $j=3$：先前-低 $[2, 6, 28, 10]$，先前-高 $[0, 4, 30, 12]$\n      - $j=4$：先前-低 $[0, 4, 12, 20]$，先前-高 $[0, 2, 10, 22]$\n- 案例 2 (含零边界情况，依赖正则化，计数少，因功效低而无马尔可夫违例)：\n    - $K=4$\n    - $n_t = [50, 0, 15, 5]$\n    - $N$：\n      - 第1列：$[15, 5, 0, 0]$\n      - 第2列：$[0, 0, 0, 0]$\n      - 第3列：$[3, 3, 2, 1]$\n      - 第4列：$[0, 1, 1, 2]$\n    - $m = [50, 0, 15, 5]$\n    - $b = [5, 0, 10, 8]$\n    - $\\alpha_{\\text{Dir}} = 1.0$\n    - $\\alpha_{\\text{Sig}} = 0.05$\n    - 三元汇总计数：\n      - $j=1$：先前-低 $[8, 10, 2, 0]$，先前-高 $[7, 9, 2, 0]$\n      - $j=3$：先前-低 $[2, 3, 3, 1]$，先前-高 $[1, 2, 3, 3]$\n      - $j=4$：先前-低 $[0, 1, 1, 2]$，先前-高 $[0, 1, 1, 2]$\n- 案例 3 (在一个当前阶段有清晰的非马尔可夫信号)：\n    - $K=4$\n    - $n_t = [100, 100, 100, 100]$\n    - $N$：\n      - 第1列：$[40, 20, 10, 0]$\n      - 第2列：$[10, 30, 30, 10]$\n      - 第3列：$[5, 20, 40, 20]$\n      - 第4列：$[0, 10, 30, 50]$\n    - $m = [100, 100, 100, 100]$\n    - $b = [20, 40, 80, 100]$\n    - $\\alpha_{\\text{Dir}} = 0.3$\n    - $\\alpha_{\\text{Sig}} = 0.01$\n    - 三元汇总计数：\n      - $j=1$：先前-低 $[30, 25, 15, 0]$，先前-高 $[28, 22, 18, 2]$\n      - $j=2$：先前-低 $[12, 30, 25, 13]$，先前-高 $[5, 20, 35, 20]$\n      - $j=3$：先前-低 $[3, 15, 45, 17]$，先前-高 $[10, 30, 30, 15]$\n      - $j=4$：先前-低 $[0, 10, 30, 50]$，先前-高 $[0, 10, 30, 50]$\n\n算法要求：\n- 使用 $n_t(j)$ 和 $N(\\cdot,j)$ 估计 $s_j$。\n- 使用多项式最大似然估计以及由 $\\alpha_{\\text{Dir}}$ 控制的可选对称狄利克雷正则化来估计 $p_{ij}$。如果阶段 $j$ 的总存活者计数为零，则在构建 $A$ 时对 $p_{ij}$ 使用目标阶段上的均匀分布，注意存活因子会使这些项归零。\n- 使用汇总的后代计数 $b_j$ 除以亲本样本量 $m_j$ 来估计 $f_j$，并约定如果 $m_j=0$ 则 $f_j=0$。\n- 通过将生存-生长转移和对新生阶段 $i=1$ 的繁殖力贡献相结合来构建 $A$。\n- 计算 $A$ 的主特征值 $\\lambda$ 并以浮点数形式报告。\n- 对于每个当前阶段 $j$ 的马尔可夫假设检验，应用皮尔逊卡方检验来检验两种先前阶段类别间的下一阶段分布的相等性。如果阶段 $j$ 的总计数不足以进行可靠检验，则跳过该 $j$。汇总所有 $j$ 的决策：如果在指定的显著性水平 $\\alpha_{\\text{Sig}}$ 下未检测到违例，则报告布尔值 true，否则报告 false。\n\n最终输出格式规范：\n您的程序应生成一行输出，其中包含三个测试案例的结果，格式为方括号内以逗号分隔的列表，其中每个元素是一个两项列表 $[\\lambda,\\text{markov\\_ok}]$，$\\lambda$ 是浮点数，$\\text{markov\\_ok}$ 是布尔值。例如，您的最终输出必须类似于 $[[\\lambda_1,\\text{True}],[\\lambda_2,\\text{False}],[\\lambda_3,\\text{True}]]$，其中的数值为您程序计算出的实际值。",
            "solution": "从体型分级数据构建阶段结构投影矩阵始于对生存、条件生长转移和繁殖力的定义。设 $K$ 为阶段数。在时间 $t$，各阶段的丰度向量记为 $n_t(j)$，其中 $j \\in \\{1,\\dots,K\\}$。观测到的转移计数 $N(i,j)$ 汇总了在时间 $t$ 处于阶段 $j$ 并在存活者中于时间 $t+1$ 观测到处于阶段 $i$ 的个体。从阶段 $j$ 存活的个体数量为 $\\sum_{i=1}^K N(i,j)$，当 $n_t(j)0$ 时，特定阶段的存活比例为 $s_j = \\frac{\\sum_{i=1}^K N(i,j)}{n_t(j)}$，并约定当 $n_t(j)=0$ 时 $s_j=0$。这是基于频率的存活率估计的直接应用，其假设是普查数据 $n_t(j)$ 和转移数据 $N(i,j)$ 是在同一区间内测量的。\n\n以存活为条件，一个处于阶段 $j$ 的个体转移到阶段 $i$ 的概率被建模为关于 $i$ 的多项式分布。当分母为正时，多项式模型的最大似然估计 (MLE) 产生相对频率估计量 $p_{ij} = \\frac{N(i,j)}{\\sum_{i=1}^K N(i,j)}$。为了对有零值的情况进行正则化并提高稳定性，可以采用一个集中参数为 $\\alpha_{\\text{Dir}}$ 的对称狄利克雷先验。狄利克雷先验是多项式似然的共轭先验，类别概率的后验均值为\n$$\np_{ij} = \\frac{N(i,j) + \\alpha_{\\text{Dir}}}{\\sum_{i=1}^K N(i,j) + K \\,\\alpha_{\\text{Dir}}}.\n$$\n此表达式源于狄利克雷先验与多项式似然的共轭性，其中后验参数是先验参数加上观测计数。如果 $\\sum_{i=1}^K N(i,j) = 0$，则后验均值自动简化为均匀分布 $p_{ij} = \\frac{1}{K}$，但由于在这种情况下 $s_j=0$，因此阶段 $j$ 的生存-生长贡献在投影矩阵中将为零。\n\n繁殖力定义为当前时间步处于阶段 $j$ 的每个个体在下一时间步贡献进入第一阶段的新生个体的期望数量。使用汇总的后代计数 $b_j$ 和亲本样本量 $m_j$，繁殖力估计量为\n$$\nf_j = \\begin{cases}\n\\frac{b_j}{m_j},  m_j  0,\\\\\n0,  m_j=0,\n\\end{cases}\n$$\n这与计数比率估计量一致，其假设是后代被正确地归因于亲本阶段，并且 $m_j$ 反映了抽样到的贡献繁殖的亲本数量。\n\n阶段结构投影矩阵 $A \\in \\mathbb{R}^{K\\times K}$ 汇集了从每个当前阶段 $j$ 到每个下一阶段 $i$ 的期望贡献。从阶段 $j$ 到阶段 $i$ 的生存-生长贡献是所有 $i$ 的乘积 $s_j \\, p_{ij}$，因为在 $n_t(j)$ 个个体中，有比例为 $s_j$ 的个体存活下来，并根据 $p_{ij}$ 分布到各个目标阶段。繁殖贡献被假定进入新生阶段 $i=1$，因此繁殖力加到 $A$ 的第一行。于是，\n$$\nA_{ij} = \\begin{cases}\ns_j \\, p_{ij} + f_j,  i=1,\\\\\ns_j \\, p_{ij},  i\\in\\{2,\\dots,K\\}.\n\\end{cases}\n$$\n第一行的加性结构反映了处于阶段 $j$ 的个体既可以通过生存-生长存活并出现在阶段 $i=1$，也可以独立地通过繁殖产生进入阶段 $i=1$ 的新生个体。\n\n给定 $A$，渐近增长率由 $A$ 的主特征值 $\\lambda$ 决定。由于 $A$ 是非负的，Perron-Frobenius (PF) 定理保证了存在一个与谱半径相等的实数主特征值 $\\lambda$ 和一个相应的正特征向量。在数值上，可以计算 $A$ 的特征值和特征向量，取实部最大的特征值为 $\\lambda$，并通过将相关的右特征向量归一化使其总和为 1 来获得稳定阶段分布：\n$$\n\\lambda = \\max_{k} \\Re(\\mu_k), \\quad \\text{where } A v_k = \\mu_k v_k,\n$$\n稳定分布 $w$ 是 $w = \\frac{\\Re(v_{k^\\star})}{\\sum_i \\Re(v_{k^\\star,i})}$，其中 $k^\\star$ 是达到最大值的索引。\n\n为了在阶段层面评估马尔可夫假设，考虑连续三个时间步，并对固定的当前阶段 $j$，按两种先前阶段类别汇总进入下一阶段 $i$ 的转移计数。马尔可夫假设断言下一阶段结果的分布仅取决于 $j$；因此，两种先前阶段类别下关于 $i$ 的分布应该是相等的。这可以通过对每个 $j$ 的一个 $2 \\times K$ 列联表进行皮尔逊卡方独立性检验来测试。对于阶段 $j$，构建表格\n$$\n\\begin{pmatrix}\nc^{(1)}_1  c^{(1)}_2  \\dots  c^{(1)}_K\\\\\nc^{(2)}_1  c^{(2)}_2  \\dots  c^{(2)}_K\n\\end{pmatrix},\n$$\n其中 $c^{(1)}_i$ 和 $c^{(2)}_i$ 是两种先前阶段类别转移到下一阶段 $i$ 的计数。计算卡方检验统计量和 $p$ 值。如果 $p$ 值小于指定的显著性水平 $\\alpha_{\\text{Sig}}$，则对于该 $j$ 拒绝分布相等的原假设，这表明存在反对马尔可夫假设的证据。如果计数不足（例如，总数太小或某行为零），可以跳过对该 $j$ 的检验以避免伪结论。汇总所有 $j$ 的结果：如果任何被检验的 $j$ 拒绝了原假设，则声明存在违例；否则，接受该案例的马尔可夫假设。\n\n将这些步骤应用于测试套件：\n- 对于案例 1，使用 $n_t$ 和 $N$ 计算 $s_j$，用 $\\alpha_{\\text{Dir}}=0.5$ 估计 $p_{ij}$，使用 $b$ 和 $m$ 估计 $f_j$，构建 $A$，并计算 $\\lambda$。在 $\\alpha_{\\text{Sig}}=0.05$ 水平下对每个当前阶段 $j$ 进行卡方检验；鉴于所提供的三元计数，先前阶段类别间的分布是相似的，因此检验不应拒绝原假设，从而对马尔可夫假设得出“真”的判定。\n- 对于案例 2，$n_t$ 和 $N$ 中的零值使得有必要使用 $\\alpha_{\\text{Dir}}=1.0$ 的正则化来避免退化的转移。相应地计算 $s_j$、$p_{ij}$、$f_j$ 和 $A$。三元计数很小；在 $\\alpha_{\\text{Sig}}=0.05$ 水平下，有限的检验功效加上类别间的相似模式不应导致拒绝，因此马尔可夫判定应为“真”。\n- 对于案例 3，在 $\\alpha_{\\text{Dir}}=0.3$ 下计算 $s_j$、$p_{ij}$、$f_j$、$A$ 和 $\\lambda$。构造的三元计数旨在显示至少一个当前阶段（例如，$j=2$ 和 $j=3$）在先前阶段类别间存在显著差异，并且在更严格的水平 $\\alpha_{\\text{Sig}}=0.01$ 下，对这些 $j$ 的卡方检验应拒绝原假设，从而对马尔可夫假设得出“假”的判定。\n\n因此，程序为每个案例输出配对 $[\\lambda,\\text{markov\\_ok}]$，并将它们汇总成指定的单行列表格式。特征值和卡方 $p$ 值的数值计算依赖于与上述数学定义一致的既定线性代数和统计检验程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2_contingency\n\ndef estimate_survival(n_t, N):\n    \"\"\"\n    Estimate stage-specific survival s_j as survivors / initial counts.\n    n_t: array of shape (K,)\n    N: array of shape (K,K) with columns j and rows i (destinations)\n    Returns s: array of shape (K,)\n    \"\"\"\n    K = len(n_t)\n    s = np.zeros(K, dtype=float)\n    for j in range(K):\n        survivors = float(np.sum(N[:, j]))\n        if n_t[j]  0:\n            s[j] = survivors / float(n_t[j])\n        else:\n            s[j] = 0.0\n    # Clip to [0,1] for numerical safety\n    return np.clip(s, 0.0, 1.0)\n\ndef estimate_p_ij(N, alpha_dirichlet):\n    \"\"\"\n    Estimate conditional transition probabilities p_{ij} per column j.\n    Uses multinomial MLE with symmetric Dirichlet regularization alpha_dirichlet.\n    N: array (K,K), columns j, rows i\n    Returns P: array (K,K) where columns sum to 1 (unless total survivors=0 - uniform).\n    \"\"\"\n    K = N.shape[0]\n    P = np.zeros_like(N, dtype=float)\n    for j in range(K):\n        col = N[:, j].astype(float)\n        total = float(np.sum(col))\n        if total  0.0:\n            # Posterior mean under symmetric Dirichlet prior\n            P[:, j] = (col + alpha_dirichlet) / (total + K * alpha_dirichlet)\n        else:\n            # No survivors: uniform distribution (will be zeroed by s_j anyway)\n            P[:, j] = np.full(K, 1.0 / K)\n    return P\n\ndef estimate_fecundity(b, m):\n    \"\"\"\n    Estimate per-stage fecundity f_j = b_j / m_j with f_j=0 when m_j=0.\n    b: array (K,) offspring counts per stage\n    m: array (K,) parent sample sizes per stage\n    Returns f: array (K,)\n    \"\"\"\n    f = np.zeros_like(b, dtype=float)\n    for j in range(len(b)):\n        if m[j]  0:\n            f[j] = float(b[j]) / float(m[j])\n        else:\n            f[j] = 0.0\n    return f\n\ndef build_projection_matrix(n_t, N, b, m, alpha_dirichlet):\n    \"\"\"\n    Construct the stage-structured projection matrix A.\n    A_{ij} = s_j * p_{ij} for all i, with fecundity added to first row: A_{1j} += f_j.\n    \"\"\"\n    K = len(n_t)\n    s = estimate_survival(n_t, N)\n    P = estimate_p_ij(N, alpha_dirichlet)\n    f = estimate_fecundity(b, m)\n    A = np.zeros((K, K), dtype=float)\n    # Survival-growth contributions\n    for j in range(K):\n        A[:, j] = s[j] * P[:, j]\n    # Fecundity contributions to recruit stage (i=0 in zero-based indexing)\n    A[0, :] += f\n    return A\n\ndef dominant_eigenvalue(A):\n    \"\"\"\n    Compute the dominant eigenvalue (largest real part) of nonnegative matrix A.\n    \"\"\"\n    w, v = np.linalg.eig(A)\n    # Select eigenvalue with largest real part\n    idx = np.argmax(w.real)\n    lam = float(w.real[idx])\n    return lam\n\ndef test_markov_assumption(triplet_counts_by_j, alpha_sig, min_total_per_group=4):\n    \"\"\"\n    Evaluate the Markovian assumption using Pearson Chi-Square test per current stage j.\n    triplet_counts_by_j: dict mapping j (0-based) - {'prev_low': array(K,), 'prev_high': array(K,)}\n    alpha_sig: significance level for rejecting equality of distributions\n    min_total_per_group: minimum total counts per group to attempt test\n    Returns True if no violation detected; False otherwise.\n    \"\"\"\n    violation = False\n    for j, groups in triplet_counts_by_j.items():\n        low = np.array(groups['prev_low'], dtype=float)\n        high = np.array(groups['prev_high'], dtype=float)\n        if np.sum(low)  min_total_per_group or np.sum(high)  min_total_per_group:\n            # Insufficient counts: skip this stage\n            continue\n        table = np.vstack([low, high])\n        # Perform chi-square test for independence\n        try:\n            chi2, pval, dof, expected = chi2_contingency(table, correction=False)\n        except Exception:\n            # In case of numerical issues, add small smoothing and retry\n            eps = 1e-8\n            table = table + eps\n            chi2, pval, dof, expected = chi2_contingency(table, correction=False)\n        if pval  alpha_sig:\n            violation = True\n            # No need to continue if violation found; but continue to parse all to be thorough\n    return not violation\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict encoding K, n_t, N, m, b, alpha_dirichlet, alpha_sig, triplet_counts_by_j\n    test_cases = [\n        {\n            \"K\": 4,\n            \"n_t\": np.array([120, 80, 60, 40], dtype=int),\n            \"N\": np.array([\n                [50, 10, 0, 0],\n                [30, 28, 6, 2],\n                [8, 18, 28, 8],\n                [2, 4, 14, 22]\n            ], dtype=int),\n            \"m\": np.array([60, 50, 40, 30], dtype=int),\n            \"b\": np.array([10, 25, 80, 90], dtype=int),\n            \"alpha_dirichlet\": 0.5,\n            \"alpha_sig\": 0.05,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([40, 25, 10, 2], dtype=int),\n                    \"prev_high\": np.array([35, 22, 9, 3], dtype=int)},\n                1: {\"prev_low\": np.array([12, 25, 14, 5], dtype=int),\n                    \"prev_high\": np.array([10, 22, 12, 6], dtype=int)},\n                2: {\"prev_low\": np.array([2, 6, 28, 10], dtype=int),\n                    \"prev_high\": np.array([0, 4, 30, 12], dtype=int)},\n                3: {\"prev_low\": np.array([0, 4, 12, 20], dtype=int),\n                    \"prev_high\": np.array([0, 2, 10, 22], dtype=int)}\n            }\n        },\n        {\n            \"K\": 4,\n            \"n_t\": np.array([50, 0, 15, 5], dtype=int),\n            \"N\": np.array([\n                [15, 0, 3, 0],\n                [5, 0, 3, 1],\n                [0, 0, 2, 1],\n                [0, 0, 1, 2]\n            ], dtype=int),\n            \"m\": np.array([50, 0, 15, 5], dtype=int),\n            \"b\": np.array([5, 0, 10, 8], dtype=int),\n            \"alpha_dirichlet\": 1.0,\n            \"alpha_sig\": 0.05,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([8, 10, 2, 0], dtype=int),\n                    \"prev_high\": np.array([7, 9, 2, 0], dtype=int)},\n                2: {\"prev_low\": np.array([2, 3, 3, 1], dtype=int),\n                    \"prev_high\": np.array([1, 2, 3, 3], dtype=int)},\n                3: {\"prev_low\": np.array([0, 1, 1, 2], dtype=int),\n                    \"prev_high\": np.array([0, 1, 1, 2], dtype=int)}\n            }\n        },\n        {\n            \"K\": 4,\n            \"n_t\": np.array([100, 100, 100, 100], dtype=int),\n            \"N\": np.array([\n                [40, 10, 5, 0],\n                [20, 30, 20, 10],\n                [10, 30, 40, 30],\n                [0, 10, 20, 50]\n            ], dtype=int),\n            \"m\": np.array([100, 100, 100, 100], dtype=int),\n            \"b\": np.array([20, 40, 80, 100], dtype=int),\n            \"alpha_dirichlet\": 0.3,\n            \"alpha_sig\": 0.01,\n            \"triplet\": {\n                0: {\"prev_low\": np.array([30, 25, 15, 0], dtype=int),\n                    \"prev_high\": np.array([28, 22, 18, 2], dtype=int)},\n                1: {\"prev_low\": np.array([12, 30, 25, 13], dtype=int),\n                    \"prev_high\": np.array([5, 20, 35, 20], dtype=int)},\n                2: {\"prev_low\": np.array([3, 15, 45, 17], dtype=int),\n                    \"prev_high\": np.array([10, 30, 30, 15], dtype=int)},\n                3: {\"prev_low\": np.array([0, 10, 30, 50], dtype=int),\n                    \"prev_high\": np.array([0, 10, 30, 50], dtype=int)}\n            }\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        K = case[\"K\"]\n        n_t = case[\"n_t\"]\n        N = case[\"N\"]\n        m = case[\"m\"]\n        b = case[\"b\"]\n        alpha_dir = case[\"alpha_dirichlet\"]\n        alpha_sig = case[\"alpha_sig\"]\n        triplet = case[\"triplet\"]\n\n        # Build projection matrix\n        A = build_projection_matrix(n_t, N, b, m, alpha_dir)\n        # Compute dominant eigenvalue\n        lam = dominant_eigenvalue(A)\n        # Evaluate Markov assumption\n        markov_ok = test_markov_assumption(triplet, alpha_sig, min_total_per_group=K)\n\n        # Round lambda for neat output\n        lam_rounded = round(lam, 6)\n        results.append([lam_rounded, markov_ok])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}