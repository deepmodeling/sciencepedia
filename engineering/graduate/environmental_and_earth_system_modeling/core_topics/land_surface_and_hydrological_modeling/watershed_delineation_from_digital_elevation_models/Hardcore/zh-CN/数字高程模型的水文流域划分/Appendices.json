{
    "hands_on_practices": [
        {
            "introduction": "从数字高程模型（DEM）中划分流域的基础是确定水流从一个网格单元到下一个网格单元的路径。本练习将让你亲手实践最常用的D8算法，该算法将水流导向坡度最陡的单个相邻单元。通过在一个小规模网格上手动计算流向并识别如流向相等（tie cases）等特殊情况 ，你将为理解驱动大规模水文模型的核心逻辑建立坚实的直觉。",
            "id": "3930970",
            "problem": "考虑一个大小为 $3 \\times 3$ 单元格的方形栅格数字高程模型 (DEM) 图斑，其单元格宽度统一为 $L$，高程（单位：米，相对于某一基准面）由以下矩阵给出，其中中心单元格位于第 2 行，第 2 列：\n$$\n\\begin{pmatrix}\n90  95  90 \\\\\n95  100  95 \\\\\n92  95  92\n\\end{pmatrix}.\n$$\n假设 $L = 30\\,\\mathrm{m}$，并且平面邻域距离对于主方向邻居为 $d_{\\text{cardinal}} = L$，对于对角线邻居为 $d_{\\text{diagonal}} = \\sqrt{2}\\,L$。使用八方向 (D8) 算法，其定义如下：对于一个高程为 $z_i$ 的单元格 $i$，其到邻居 $j$ 的候选下坡方向，通过在 DEM 图斑内的所有相邻单元格 $j$ 中，根据条件 $z_i \\ge z_j$（下坡或平坦），最大化局部坡度\n$$\ns_{i \\to j} = \\frac{z_i - z_j}{d_{ij}}\n$$\n来选择。如果对于所有邻居 $j$ 都有 $s_{i \\to j} = 0$，或者对于所有邻居 $j$ 都有 $z_i  z_j$，则该单元格是一个洼地或平地，在不进行洼地处理的情况下没有唯一的下坡方向。坡向模糊定义为：在所有可选邻居中，出现两个或多个不同的邻居 $j$ 具有完全相等的最大 $s_{i \\to j}$ 值。\n\n应用上述定义计算中心单元格及其 8 个邻居的 D8 流向，计算范围仅限于位于 $3 \\times 3$ 图斑内的邻居（忽略任何图斑外的单元格）。然后，识别并计算在这 9 个单元格中需要明确解决的坡向模糊的数量。报告图斑中坡向模糊的总数作为最终答案。最终答案以整数形式表示，无需四舍五入。",
            "solution": "此问题已经过验证。\n\n### 步骤 1：提取已知条件\n- 一个 $3 \\times 3$ 的方形栅格数字高程模型 (DEM)。\n- 单元格宽度 $L = 30\\,\\mathrm{m}$。\n- 高程矩阵 $Z$：\n$$\nZ = \\begin{pmatrix}\n90  95  90 \\\\\n95  100  95 \\\\\n92  95  92\n\\end{pmatrix}\n$$\n- 平面邻域距离：主方向邻居为 $d_{\\text{cardinal}} = L$，对角线邻居为 $d_{\\text{diagonal}} = \\sqrt{2}\\,L$。\n- D8 算法规则：从单元格 $i$ 到邻居 $j$ 的下坡方向通过最大化坡度 $s_{i \\to j} = \\frac{z_i - z_j}{d_{ij}}$ 来选择，条件是水流为下坡或平坦，即 $z_i \\ge z_j$。\n- 洼地或平地的定义：一个单元格，其所有邻居 $j$ 的 $s_{i \\to j} = 0$ 或所有邻居 $j$ 的 $z_i  z_j$。\n- 坡向模糊的定义：在所有可选邻居中，有两个或更多个不同的邻居 $j$ 具有相同的最大坡度 $s_{i \\to j}$。\n- 任务：计算所有 9 个单元格的流向，仅考虑 $3 \\times 3$ 图斑内的邻居，并计算坡向模糊的总数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于 D8 流向算法，这是水文学和地理信息科学 (GIS) 中用于模拟 DEM 表面水流的一种基本且广泛使用的方法。其设置是标准的教科书式练习。原理是科学合理的。\n- **适定性**：该问题是自洽的。它提供了所有必要的数据（高程网格、单元格大小、距离定义）以及一个精确、无歧义的算法来确定流向和识别坡向模糊。边界条件（将邻居限制在图斑内）已明确说明。存在唯一的整数解。\n- **客观性**：该问题以精确、定量和客观的语言陈述，不含任何主观或推测性内容。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为其具有科学依据、适定性和客观性。没有可识别的缺陷。将推导解答。\n\n解答过程是系统地分析 DEM 图斑中的 9 个单元格。设一个单元格用其行和列索引 $(r, c)$ 表示，其高程为 $z_{rc}$。单元格宽度为 $L = 30\\,\\mathrm{m}$。到邻居的坡度由 $s = \\frac{\\Delta z}{d}$ 给出，其中 $\\Delta z$ 是高程差， $d$ 是距离。对于主方向邻居，$d=L$。对于对角线邻居，$d=\\sqrt{2}L$。我们寻求为每个单元格最大化此坡度，只考虑高程满足 $z_j \\le z_i$ 的邻居。\n\n让我们逐个分析每个单元格：\n\n**单元格 (1,1): $z_{11} = 90$**\n图斑内的邻居是 $(1,2)$、$(2,1)$ 和 $(2,2)$，其高程分别为 $z_{12}=95$、$z_{21}=95$ 和 $z_{22}=100$。所有邻居的高程都更高 ($z_j  z_{11}$)。根据问题定义，此单元格是一个洼地。没有可选的下坡或平坦邻居，因此不可能出现坡向模糊。\n(1,1) 的坡向模糊数量：$0$。\n\n**单元格 (1,2): $z_{12} = 95$**\n可选邻居 $j$ (其中 $z_j \\le 95$) 有：\n- $(1,1)$: $z_{11}=90$。主方向。$s_{12 \\to 11} = \\frac{95 - 90}{L} = \\frac{5}{L}$。\n- $(1,3)$: $z_{13}=90$。主方向。$s_{12 \\to 13} = \\frac{95 - 90}{L} = \\frac{5}{L}$。\n- $(2,1)$: $z_{21}=95$。对角线方向。$s_{12 \\to 21} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n- $(2,3)$: $z_{23}=95$。对角线方向。$s_{12 \\to 23} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n最大坡度为 $\\frac{5}{L}$。该坡度出现在两个不同的邻居：$(1,1)$ 和 $(1,3)$。这构成一个坡向模糊。\n(1,2) 的坡向模糊数量：$1$。\n\n**单元格 (1,3): $z_{13} = 90$**\n图斑内的邻居是 $(1,2)$、$(2,2)$ 和 $(2,3)$，其高程分别为 $z_{12}=95$、$z_{22}=100$ 和 $z_{23}=95$。所有邻居的高程都更高。这是一个洼地。\n(1,3) 的坡向模糊数量：$0$。\n\n**单元格 (2,1): $z_{21} = 95$**\n可选邻居 $j$ (其中 $z_j \\le 95$) 有：\n- $(1,1)$: $z_{11}=90$。主方向。$s_{21 \\to 11} = \\frac{95 - 90}{L} = \\frac{5}{L}$。\n- $(3,1)$: $z_{31}=92$。主方向。$s_{21 \\to 31} = \\frac{95 - 92}{L} = \\frac{3}{L}$。\n- $(1,2)$: $z_{12}=95$。对角线方向。$s_{21 \\to 12} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n- $(3,2)$: $z_{32}=95$。对角线方向。$s_{21 \\to 32} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n最大坡度为 $\\frac{5}{L}$，对应唯一的邻居 $(1,1)$。没有发生坡向模糊。\n(2,1) 的坡向模糊数量：$0$。\n\n**单元格 (2,2): $z_{22} = 100$**\n所有 8 个邻居的高程都较低，因此都是可选的。\n- 主方向邻居 ($d=L$): $(1,2)$, $(2,1)$, $(2,3)$, $(3,2)$。高程均为 $z=95$。坡度为 $s = \\frac{100 - 95}{L} = \\frac{5}{L}$。\n- 对角线邻居 ($d=\\sqrt{2}L$):\n  - $(1,1)$, $z_{11}=90$: $s = \\frac{100 - 90}{\\sqrt{2}L} = \\frac{10}{\\sqrt{2}L} = \\frac{5\\sqrt{2}}{L}$。\n  - $(1,3)$, $z_{13}=90$: $s = \\frac{100 - 90}{\\sqrt{2}L} = \\frac{10}{\\sqrt{2}L} = \\frac{5\\sqrt{2}}{L}$。\n  - $(3,1)$, $z_{31}=92$: $s = \\frac{100 - 92}{\\sqrt{2}L} = \\frac{8}{\\sqrt{2}L} = \\frac{4\\sqrt{2}}{L}$。\n  - $(3,3)$, $z_{33}=92$: $s = \\frac{100 - 92}{\\sqrt{2}L} = \\frac{8}{\\sqrt{2}L} = \\frac{4\\sqrt{2}}{L}$。\n为了比较这些坡度，我们比较 $\\frac{5}{L}$、$\\frac{5\\sqrt{2}}{L}$ 和 $\\frac{4\\sqrt{2}}{L}$ 的值。由于 $\\sqrt{2} \\approx 1.414$，我们有 $5\\sqrt{2} \\approx 7.07$ 和 $4\\sqrt{2} \\approx 5.66$。最大坡度为 $\\frac{5\\sqrt{2}}{L}$。该坡度出现在两个不同的邻居：$(1,1)$ 和 $(1,3)$。这是一个坡向模糊。\n(2,2) 的坡向模糊数量：$1$。\n\n**单元格 (2,3): $z_{23} = 95$**\n可选邻居 $j$ (其中 $z_j \\le 95$) 有：\n- $(1,3)$: $z_{13}=90$。主方向。$s_{23 \\to 13} = \\frac{95 - 90}{L} = \\frac{5}{L}$。\n- $(3,3)$: $z_{33}=92$。主方向。$s_{23 \\to 33} = \\frac{95 - 92}{L} = \\frac{3}{L}$。\n- $(1,2)$: $z_{12}=95$。对角线方向。$s_{23 \\to 12} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n- $(3,2)$: $z_{32}=95$。对角线方向。$s_{23 \\to 32} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n最大坡度为 $\\frac{5}{L}$，对应唯一的邻居 $(1,3)$。没有发生坡向模糊。\n(2,3) 的坡向模糊数量：$0$。\n\n**单元格 (3,1): $z_{31} = 92$**\n图斑内的邻居是 $(2,1)$、$(2,2)$ 和 $(3,2)$，其高程分别为 $z_{21}=95$、$z_{22}=100$ 和 $z_{32}=95$。所有邻居的高程都更高。这是一个洼地。\n(3,1) 的坡向模糊数量：$0$。\n\n**单元格 (3,2): $z_{32} = 95$**\n可选邻居 $j$ (其中 $z_j \\le 95$) 有：\n- $(3,1)$: $z_{31}=92$。主方向。$s_{32 \\to 31} = \\frac{95 - 92}{L} = \\frac{3}{L}$。\n- $(3,3)$: $z_{33}=92$。主方向。$s_{32 \\to 33} = \\frac{95 - 92}{L} = \\frac{3}{L}$。\n- $(2,1)$: $z_{21}=95$。对角线方向。$s_{32 \\to 21} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n- $(2,3)$: $z_{23}=95$。对角线方向。$s_{32 \\to 23} = \\frac{95 - 95}{\\sqrt{2}L} = 0$。\n最大坡度为 $\\frac{3}{L}$。该坡度出现在两个不同的邻居：$(3,1)$ 和 $(3,3)$。这构成一个坡向模糊。\n(3,2) 的坡向模糊数量：$1$。\n\n**单元格 (3,3): $z_{33} = 92$**\n图斑内的邻居是 $(2,2)$、$(2,3)$ 和 $(3,2)$，其高程分别为 $z_{22}=100$、$z_{23}=95$ 和 $z_{32}=95$。所有邻居的高程都更高。这是一个洼地。\n(3,3) 的坡向模糊数量：$0$。\n\n**总计数**\n将所有 9 个单元格的坡向模糊数量相加：\n坡向模糊总数 = $0 + 1 + 0 + 0 + 1 + 0 + 0 + 1 + 0 = 3$。\n图斑中坡向模糊的总数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "从单个单元扩展到整个地貌，本实践要求你用代码实现一个完整的流域划分算法。你将把D8流向逻辑转化为一个函数，然后从一个给定的出水口单元开始，应用反向图遍历（具体来说是广度优先搜索，BFS）。这个练习  旨在弥合理论与应用之间的鸿沟，展示如何通过编程来识别所有汇入目标点的上游单元，这是流域分析的核心任务。",
            "id": "3930952",
            "problem": "给定一个网格化的数字高程模型 (DEM)，你需要通过反向图遍历标记所有上游单元，从而为一个指定的出口单元划定流域。其科学依据是，重力驱动水流从高重力势能区域流向低重力势能区域。在栅格DEM上，水流被近似为从给定单元流向其8个相邻单元中下坡梯度最大的那个单元。八方向 ($D8$) 算法构建了一个有向图，其中每个单元最多只有一条出边，指向其8个相邻单元中具有最大正向下坡梯度的唯一邻居（如果存在这样的邻居）。\n\n基本原理：\n- 单位质量的重力势能为 $g h$，其中 $g$ 表示重力加速度，$h$ 表示高程。在一个边长为 $s$ 的正方形单元构成的规则网格上，最陡下降的离散近似方法会选择使高程降与平面距离之比最大的邻居。\n- 对于索引为 $(i,j)$、高程为 $z_{i,j}$ 的单元，及其索引为 $(i+\\Delta i, j+\\Delta j)$、高程为 $z_{i+\\Delta i, j+\\Delta j}$ 的邻居，如果 $|\\Delta i| + |\\Delta j| = 1$（基本方向），则平面距离为 $d = s$；如果 $|\\Delta i| = |\\Delta j| = 1$（对角线方向），则平面距离为 $d = s\\sqrt{2}$。朝向该邻居的离散下坡梯度为\n$$\n\\gamma = \\frac{z_{i,j} - z_{i+\\Delta i, j+\\Delta j}}{d}.\n$$\n- 单元 $(i,j)$ 的 $D8$ 出流方向是使其在8个邻居中 $\\gamma$ 值最大的邻居 $(i+\\Delta i^\\ast, j+\\Delta j^\\ast)$，前提是该最大值必须为严格正数；否则，该单元是一个没有出流的汇或洼地。\n\n基于出口的流域划定遵循以下定义：出口单元 $(i_0,j_0)$ 的流域是所有其唯一 $D8$ 流路径最终能到达 $(i_0,j_0)$ 的单元的集合。这个集合可以通过从 $(i_0,j_0)$ 开始进行反向图遍历来构建，将任何出流指向当前单元的邻居添加进来。\n\n你的任务：\n- 实现一个完整的程序，该程序：\n  - 使用上述离散最陡下降规则，根据DEM构建 $D8$ 流向。\n  - 从一个给定的出口单元开始，执行反向广度优先搜索 (Breadth-First Search, BFS)，以标记出所有通过 $D8$ 流向诱导的有向图排入该出口的上游单元。\n  - 将标记的单元数量乘以单元尺寸的平方，计算流域面积。\n- 为反向遍历明确应用以下终止条件：\n  - 不要遍历到DEM域之外。任何索引超出DEM边界的邻居都将被排除。\n  - 不要遍历到无数据单元。将无数据表示为非数值 (not-a-number)，并在计算出流和反向遍历时排除这些单元。\n  - 不要重新访问已标记的单元。维护一个已访问集合以防止循环并确保终止。\n  - 当BFS队列为空时停止遍历；此时，所有上游贡献单元都已被探索完毕。\n  - 被分类为洼地（在 $D8$ 下没有定义出流）的单元不能位于任何其他单元的上游，因此在反向遍历期间绝不会作为入流邻居出现；除非它们本身就是出口，否则不会被添加到流域中。\n- 所有流域面积以平方米 $\\mathrm{m}^2$ 表示，并四舍五入到一位小数。\n\n测试套件：\n- 对所有单元坐标 $(i,j)$ 使用零基索引。\n- 每个测试用例以 $(\\text{DEM}, s, (i_0,j_0))$ 的形式给出，其中 $\\text{DEM}$ 是一个二维高程数组，$s$ 是以米为单位的单元尺寸，$(i_0,j_0)$ 是出口位置。\n- 提供以下测试用例：\n  - 案例1（理想路径）：一个向西北倾斜的平面。设 $\\text{DEM}_1$ 为 $5\\times 5$ 数组，其中 $z_{i,j} = i + j$，单元尺寸 $s_1 = 10$ 米，出口位于 $(0,0)$。预期的流域包括所有不排入更低内部洼地（此处没有）的单元，因此在 $D8$ 算法下它应该覆盖整个区域。\n  - 案例2（边界条件）：一个向顶行单调倾斜的坡面。设 $\\text{DEM}_2$ 为 $5\\times 5$ 数组，其中 $z_{i,j} = i$，单元尺寸 $s_2 = 20$ 米，出口位于 $(0,2)$。在 $D8$ 算法下，每个单元都倾向于尽可能向正北流动；由于区域边界的存在，顶行实际上充当了一组局部最小值点。$(0,2)$ 的流域应包括出口本身以及沿第 $j=2$ 列正南方的单元。\n  - 案例3（含内部洼地和无数据的边缘情况）：从与案例1相同的平面开始，通过设置 $z_{2,2} = -5$ 引入一个内部洼地，并在 $(1,4)$ 处引入一个设为非数值的无数据单元。使用单元尺寸 $s_3 = 30$ 米，出口位于 $(0,0)$。内部洼地会捕获其周围部分水流，从而减少到达出口的上游区域面积。\n\n你的程序应生成单行输出，其中包含三个测试用例的流域面积，格式为方括号内以逗号分隔的列表，每个面积以 $\\mathrm{m}^2$ 为单位，四舍五入到一位小数（例如，“[2500.0,2000.0,12300.0]”）。",
            "solution": "该问题已经过验证，被确定为具有科学依据、定义明确且客观。它基于计算水文学的既定原则，提出了一个清晰、可形式化的任务。解决方案分两个阶段实施：首先，使用八方向 ($D8$) 模型构建流向网格；其次，从指定的出口单元开始，通过反向图遍历来划定流域。\n\n**阶段1：D8流向网格构建**\n\n第一阶段涉及创建一个有向图，该图表示水流穿过数字高程模型 (DEM) 的最陡下降路径。对于网格坐标为 $(i,j)$、高程为 $z_{i,j}$ 的每个单元，我们确定其8个相邻邻居中哪一个提供了最大下坡梯度的路径。\n\n到相邻单元的离散梯度 $\\gamma$ 定义为高程降与平面距离之比：\n$$\n\\gamma = \\frac{z_{i,j} - z_{neighbor}}{\\text{distance}}\n$$\n对于基本方向的邻居（北、南、东、西），距离为 $s$；对于对角线方向的邻居（东北、西北、东南、西南），距离为 $s\\sqrt{2}$，其中 $s$ 是网格单元的边长。\n\n该算法遍历DEM中的每个单元 $(i,j)$：\n1.  如果单元格包含无数据值（表示为 `NaN`），则将其标记为此类并从流计算中排除。任何单元都不能流入或流出无数据单元。\n2.  对于一个有效单元，我们检查其8个邻居。对于每个有效的邻居（即在网格边界内且不是无数据单元），计算其梯度 $\\gamma$。\n3.  D8流向被分配给对应于最大严格正梯度（$\\max(\\gamma)  0$）的邻居。这为有向图中的单元 $(i,j)$ 建立了一条唯一的出边。\n4.  如果没有邻居的海拔更低，则所有梯度都小于或等于 $0$。在这种情况下，该单元被分类为洼地或汇，并且不分配出流方向。\n\n此阶段的结果是一对与DEM尺寸相同的网格 `flow_di` 和 `flow_dj`。对于每个单元 $(i,j)$，值 `flow_di[i,j]` 和 `flow_dj[i,j]` 分别存储其下游邻居的行和列偏移量。洼地由偏移量 $(0,0)$ 表示，无数据单元由特殊标志表示。\n\n**阶段2：通过反向广度优先搜索 (BFS) 进行流域划定**\n\n出口单元的流域被定义为所有水流沿D8流路径最终会到达该出口的单元的集合。通过使用从出口开始的反向图遍历算法，特别是广度优先搜索 (BFS)，可以有效地识别这个集合。\n\n算法流程如下：\n1.  初始化一个队列，并将出口单元 $(i_0, j_0)$ 添加到队列中。\n2.  使用一个布尔网格 `watershed_mask` 来跟踪已被识别为流域一部分的单元。出口单元被标记为已访问。\n3.  算法进入一个循环，只要队列不为空就继续。在每次迭代中，从队列中取出一个单元 $(i_{curr}, j_{curr})$。\n4.  然后我们检查 $(i_{curr}, j_{curr})$ 的8个邻居。对于每个邻居 $(i_n, j_n)$，我们检查其预先计算的流向是否指向当前单元。这是“反向”步骤：我们检查 $(i_n + \\text{flow\\_di}[i_n, j_n], j_n + \\text{flow\\_dj}[i_n, j_n])$ 是否等于 $(i_{curr}, j_{curr})$。\n5.  如果一个邻居流入当前单元，并且尚未被添加到流域中（即 `watershed_mask[i_n, j_n]` 为假），则将其标记为流域的一部分并加入队列。这个过程确保我们系统地发现所有上游贡献单元。\n6.  遍历自然地处理了指定的终止条件：它不会尝试访问DEM边界之外的单元，不会遍历到无数据单元中，并且 `watershed_mask` 防止一个单元被处理多次。当队列为空时，过程终止，表示所有相连的上游单元都已被找到。\n\n最后，总流域面积 $A$ 通过将流域中的总单元数 $N$ 乘以单个单元的面积 $s^2$ 来计算：\n$$\nA = N \\times s^2\n$$\n三个测试用例的面积均使用此方法计算，并按要求四舍五入到一位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef create_flow_direction_grid(dem, cell_size):\n    \"\"\"\n    Constructs a D8 flow direction grid from a DEM.\n\n    Args:\n        dem (np.ndarray): The Digital Elevation Model.\n        cell_size (float): The size of each grid cell.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: Two grids representing the row (di) and\n        column (dj) offsets of the flow direction for each cell.\n    \"\"\"\n    rows, cols = dem.shape\n    # Initialize flow direction grids. (0, 0) represents a pit.\n    flow_di = np.zeros_like(dem, dtype=int)\n    flow_dj = np.zeros_like(dem, dtype=int)\n\n    s_sqrt2 = cell_size * np.sqrt(2)\n    # Neighbor definitions: (di, dj, distance) for N, NE, E, SE, S, SW, W, NW\n    neighbors_info = [\n        (-1, 0, cell_size),    # N\n        (-1, 1, s_sqrt2),     # NE\n        (0, 1, cell_size),    # E\n        (1, 1, s_sqrt2),      # SE\n        (1, 0, cell_size),    # S\n        (1, -1, s_sqrt2),     # SW\n        (0, -1, cell_size),   # W\n        (-1, -1, s_sqrt2)     # NW\n    ]\n\n    for i in range(rows):\n        for j in range(cols):\n            if np.isnan(dem[i, j]):\n                # Use a special value (99) to flag NoData cells.\n                flow_di[i, j] = 99\n                flow_dj[i, j] = 99\n                continue\n\n            z_current = dem[i, j]\n            max_gamma = 0.0\n            best_dir = (0, 0)  # Default to a pit\n\n            for di, dj, dist in neighbors_info:\n                ni, nj = i + di, j + dj\n\n                if 0 = ni  rows and 0 = nj  cols:\n                    z_neighbor = dem[ni, nj]\n                    if not np.isnan(z_neighbor):\n                        # Gradient is positive for downslope flow.\n                        if z_current  z_neighbor:\n                            gamma = (z_current - z_neighbor) / dist\n                            if gamma  max_gamma:\n                                max_gamma = gamma\n                                best_dir = (di, dj)\n            \n            flow_di[i, j] = best_dir[0]\n            flow_dj[i, j] = best_dir[1]\n    \n    return flow_di, flow_dj\n\ndef delineate_watershed(flow_di, flow_dj, outlet_coords, cell_size):\n    \"\"\"\n    Delineates the watershed for a given outlet using reverse BFS.\n\n    Args:\n        flow_di (np.ndarray): Grid of flow direction row offsets.\n        flow_dj (np.ndarray): Grid of flow direction column offsets.\n        outlet_coords (tuple[int, int]): The (row, col) of the outlet cell.\n        cell_size (float): The size of each grid cell.\n\n    Returns:\n        float: The calculated watershed area.\n    \"\"\"\n    rows, cols = flow_di.shape\n    outlet_i, outlet_j = outlet_coords\n\n    # Outlet validation: must be within bounds and not a NoData cell.\n    is_invalid_outlet = not (0 = outlet_i  rows and 0 = outlet_j  cols) \\\n                        or flow_di[outlet_i, outlet_j] == 99\n    if is_invalid_outlet:\n        return 0.0\n\n    watershed_mask = np.zeros_like(flow_di, dtype=bool)\n    queue = deque([outlet_coords])\n    \n    watershed_mask[outlet_i, outlet_j] = True\n    cell_count = 1\n\n    # Offsets to check all 8 neighbors of a current cell.\n    neighbor_offsets = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\n    while queue:\n        curr_i, curr_j = queue.popleft()\n\n        # Check 8 neighbors to see if any flow into the current cell.\n        for di, dj in neighbor_offsets:\n            ni, nj = curr_i + di, curr_j + dj\n\n            if 0 = ni  rows and 0 = nj  cols and not watershed_mask[ni, nj]:\n                # Skip NoData cells.\n                if flow_di[ni, nj] == 99:\n                    continue\n                \n                # Check if neighbor (ni,nj) flows to (curr_i, curr_j).\n                if (ni + flow_di[ni, nj] == curr_i) and (nj + flow_dj[ni, nj] == curr_j):\n                    watershed_mask[ni, nj] = True\n                    cell_count += 1\n                    queue.append((ni, nj))\n    \n    area = cell_count * cell_size**2\n    return area\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the watershed delineation for each.\n    \"\"\"\n    # Case 1: Simple plane sloping to the northwest.\n    dem1 = np.array([[float(i + j) for j in range(5)] for i in range(5)])\n    s1 = 10.0\n    outlet1 = (0, 0)\n\n    # Case 2: Monotonic slope towards the top row.\n    dem2 = np.array([[float(i) for j in range(5)] for i in range(5)])\n    s2 = 20.0\n    outlet2 = (0, 2)\n    \n    # Case 3: Plane with an internal pit and a NoData cell.\n    dem3 = np.array([[float(i + j) for j in range(5)] for i in range(5)])\n    dem3[2, 2] = -5.0\n    dem3[1, 4] = np.nan\n    s3 = 30.0\n    outlet3 = (0, 0)\n    \n    test_cases = [\n        (dem1, s1, outlet1),\n        (dem2, s2, outlet2),\n        (dem3, s3, outlet3)\n    ]\n\n    results = []\n    for dem, s, outlet in test_cases:\n        flow_di, flow_dj = create_flow_direction_grid(dem, s)\n        area = delineate_watershed(flow_di, flow_dj, outlet, s)\n        results.append(round(area, 1))\n    \n    # Print the results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一旦从DEM中提取出排水网络，下一步通常是定量地描述其结构。本实践介绍了地貌学中用于此目的的两个最基本的度量指标：Strahler 流序（Strahler stream order）和 Shreve 流幅（Shreve stream magnitude）。通过将这些递归排序规则应用于一个样本网络 ，你将学会如何对河段进行分类，并深入了解流域的拓扑复杂性。",
            "id": "3931003",
            "problem": "一个数字高程模型 (DEM) 已经过水文调整（填洼和确保单调流），并使用八方向 (D8) 法计算了汇流路径。提取的排水网络表示为一个由河段组成的有向无环图，其中每个河段连接一个源头到其第一个汇流点，或者一个汇流点到下一个汇流点或出口。假设所有汇流点都是二元的（恰好有两个汇入河段）。\n\n网络拓扑由 $11$ 个河段 $\\{\\ell_1,\\ell_2,\\dots,\\ell_{11}\\}$ 组成，排列如下：\n- 源头河段：$\\ell_1, \\ell_2, \\ell_3, \\ell_4, \\ell_5, \\ell_6$。\n- 汇流点：\n  - 节点 $X_1$：$\\ell_1$ 和 $\\ell_2$ 汇合形成下游河段 $\\ell_7$。\n  - 节点 $X_2$：$\\ell_3$ 和 $\\ell_4$ 汇合形成下游河段 $\\ell_8$。\n  - 节点 $X_3$：$\\ell_7$ 和 $\\ell_8$ 汇合形成下游河段 $\\ell_9$。\n  - 节点 $X_4$：$\\ell_5$ 和 $\\ell_6$ 汇合形成下游河段 $\\ell_{10}$。\n  - 节点 $X_5$：$\\ell_9$ 和 $\\ell_{10}$ 汇合形成下游河段 $\\ell_{11}$，该河段最终排入出口。\n\n仅使用核心定义，按以下步骤进行：\n- 递归地定义 Strahler 河流级序 $S(\\ell)$：每个源头河段的级序 $S=1$；在两个上游河段（级序分别为 $s_1$ 和 $s_2$）的汇流点，如果 $s_1 \\neq s_2$，则下游河段的级序为 $\\max(s_1,s_2)$，如果 $s_1=s_2$，则为 $\\max(s_1,s_2)+1$。\n- 递归地定义 Shreve 河流量级 $M(\\ell)$：每个源头河段的量级 $M=1$；在两个上游河段（量级分别为 $m_1$ 和 $m_2$）的汇流点，下游河段的量级为 $m_1+m_2$。\n\n计算所有河段 $\\ell \\in \\{\\ell_1,\\dots,\\ell_{11}\\}$ 的 $S(\\ell)$ 和 $M(\\ell)$。然后构建两个关于河段的经验离散分布：\n- $P_S$ 是 Strahler 级序在所有河段上的分布，即在观测到的不同 Strahler 级序集合上的概率质量函数，其中某个级序值的概率等于它在 $11$ 个河段中出现的相对频率。\n- $P_M$ 是 Shreve 量级在所有河段上的分布，即在观测到的不同 Shreve 量级集合上的概率质量函数，其中某个量级值的概率等于它在 $11$ 个河段中出现的相对频率。\n\n使用以自然对数为底的香农熵公式 $H(P) = -\\sum_i p_i \\ln p_i$，计算熵差\n$$\\Delta H \\equiv H(P_M) - H(P_S).$$\n将最终答案表示为以自然单位（奈特）为单位的精确表达式。无需进行数值四舍五入。",
            "solution": "用户提供的问题已经过分析和验证。所有给定条件逐字列出：一个数字高程模型 (DEM) 已经过水文调整，汇流路径采用八方向 (D8) 法，网络是一个由河段组成的有向无环图，且所有汇流点都是二元的。该网络有 $11$ 个河段 $\\{\\ell_1, \\ell_2, \\dots, \\ell_{11}\\}$。源头河段为 $\\ell_1, \\ell_2, \\ell_3, \\ell_4, \\ell_5, \\ell_6$。五个汇流点为：节点 $X_1$：$\\ell_1$ 和 $\\ell_2$ 汇合形成 $\\ell_7$。节点 $X_2$：$\\ell_3$ 和 $\\ell_4$ 汇合形成 $\\ell_8$。节点 $X_3$：$\\ell_7$ 和 $\\ell_8$ 汇合形成 $\\ell_9$。节点 $X_4$：$\\ell_5$ 和 $\\ell_6$ 汇合形成 $\\ell_{10}$。节点 $X_5$：$\\ell_9$ 和 $\\ell_{10}$ 汇合形成 $\\ell_{11}$。问题给出了 Strahler 河流级序 $S(\\ell)$ 和 Shreve 河流量级 $M(\\ell)$ 的递归定义。任务是计算所有河段的 $S(\\ell)$ 和 $M(\\ell)$，在 $11$ 个河段的集合上构建两个经验离散概率分布 $P_S$ 和 $P_M$，并使用以自然对数为底的香农熵 $H(P) = -\\sum_i p_i \\ln p_i$ 计算熵差 $\\Delta H = H(P_M) - H(P_S)$。\n\n该问题在水文学和地貌学方面有科学依据，数学上是适定的，提供了所有必要信息，并使用客观、明确的语言进行表述。它不违反任何无效性标准。因此，该问题被认为是有效的，有必要给出完整解答。\n\n解答过程分三个阶段进行：\n1.  计算所有河段的 Strahler 级序和 Shreve 量级。\n2.  构建概率分布 $P_S$ 和 $P_M$。\n3.  计算熵差 $\\Delta H$。\n\n首先，我们从源头开始向下游计算每个河段的 Strahler 河流级序 $S(\\ell)$。\n-   源头河段为 $\\ell_1, \\ell_2, \\ell_3, \\ell_4, \\ell_5, \\ell_6$。根据定义，它们的 Strahler 级序均为 $1$。\n    $S(\\ell_1)=1, S(\\ell_2)=1, S(\\ell_3)=1, S(\\ell_4)=1, S(\\ell_5)=1, S(\\ell_6)=1$。\n-   在汇流点 $X_1$，河段 $\\ell_1$ 和 $\\ell_2$ 汇合。由于 $S(\\ell_1) = S(\\ell_2) = 1$，下游河段 $\\ell_7$ 的级序为 $S(\\ell_7) = S(\\ell_1) + 1 = 1+1=2$。\n-   在汇流点 $X_2$，河段 $\\ell_3$ 和 $\\ell_4$ 汇合。由于 $S(\\ell_3) = S(\\ell_4) = 1$，下游河段 $\\ell_8$ 的级序为 $S(\\ell_8) = S(\\ell_3) + 1 = 1+1=2$。\n-   在汇流点 $X_4$，河段 $\\ell_5$ 和 $\\ell_6$ 汇合。由于 $S(\\ell_5) = S(\\ell_6) = 1$，下游河段 $\\ell_{10}$ 的级序为 $S(\\ell_{10}) = S(\\ell_5) + 1 = 1+1=2$。\n-   在汇流点 $X_3$，河段 $\\ell_7$ 和 $\\ell_8$ 汇合。由于 $S(\\ell_7) = S(\\ell_8) = 2$，下游河段 $\\ell_9$ 的级序为 $S(\\ell_9) = S(\\ell_7) + 1 = 2+1=3$。\n-   在汇流点 $X_5$，河段 $\\ell_9$ 和 $\\ell_{10}$ 汇合。由于 $S(\\ell_9) = 3$ 且 $S(\\ell_{10}) = 2$，级序不相等。下游河段 $\\ell_{11}$ 的级序为 $S(\\ell_{11}) = \\max(S(\\ell_9), S(\\ell_{10})) = \\max(3, 2) = 3$。\n这 $11$ 个河段的完整 Strahler 级序集合是：$\\{1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3\\}$。\n\n其次，我们计算每个河段的 Shreve 河流量级 $M(\\ell)$。\n-   根据定义，源头河段的 Shreve 量级为 $1$。\n    $M(\\ell_1)=1, M(\\ell_2)=1, M(\\ell_3)=1, M(\\ell_4)=1, M(\\ell_5)=1, M(\\ell_6)=1$。\n-   在汇流点 $X_1$，下游量级是上游量级之和：$M(\\ell_7) = M(\\ell_1) + M(\\ell_2) = 1+1=2$。\n-   在汇流点 $X_2$：$M(\\ell_8) = M(\\ell_3) + M(\\ell_4) = 1+1=2$。\n-   在汇流点 $X_4$：$M(\\ell_{10}) = M(\\ell_5) + M(\\ell_6) = 1+1=2$。\n-   在汇流点 $X_3$：$M(\\ell_9) = M(\\ell_7) + M(\\ell_8) = 2+2=4$。\n-   在汇流点 $X_5$：$M(\\ell_{11}) = M(\\ell_9) + M(\\ell_{10}) = 4+2=6$。\n这 $11$ 个河段的完整 Shreve 量级集合是：$\\{1, 1, 1, 1, 1, 1, 2, 2, 2, 4, 6\\}$。\n\n接下来，我们构建经验概率分布。河段总数为 $N=11$。\nStrahler 级序的分布 $P_S$ 由级序值 $\\{1, 2, 3\\}$ 的频率决定。\n-   $S=1$ 的河段数：$n_1 = 6$。概率 $p_S(1) = \\frac{6}{11}$。\n-   $S=2$ 的河段数：$n_2 = 3$。概率 $p_S(2) = \\frac{3}{11}$。\n-   $S=3$ 的河段数：$n_3 = 2$。概率 $p_S(3) = \\frac{2}{11}$。\n分布 $P_S$ 为 $\\{(1, \\frac{6}{11}), (2, \\frac{3}{11}), (3, \\frac{2}{11})\\}$。\n\nShreve 量级的分布 $P_M$ 由量级值 $\\{1, 2, 4, 6\\}$ 的频率决定。\n-   $M=1$ 的河段数：$n'_1 = 6$。概率 $p_M(1) = \\frac{6}{11}$。\n-   $M=2$ 的河段数：$n'_2 = 3$。概率 $p_M(2) = \\frac{3}{11}$。\n-   $M=4$ 的河段数：$n'_3 = 1$。概率 $p_M(4) = \\frac{1}{11}$。\n-   $M=6$ 的河段数：$n'_4 = 1$。概率 $p_M(6) = \\frac{1}{11}$。\n分布 $P_M$ 为 $\\{(1, \\frac{6}{11}), (2, \\frac{3}{11}), (4, \\frac{1}{11}), (6, \\frac{1}{11})\\}$。\n\n最后，我们计算每个分布的香农熵及其差值 $\\Delta H = H(P_M) - H(P_S)$。\n$P_S$ 的熵为：\n$$H(P_S) = - \\left( \\frac{6}{11} \\ln\\left(\\frac{6}{11}\\right) + \\frac{3}{11} \\ln\\left(\\frac{3}{11}\\right) + \\frac{2}{11} \\ln\\left(\\frac{2}{11}\\right) \\right)$$\n$P_M$ 的熵为：\n$$H(P_M) = - \\left( \\frac{6}{11} \\ln\\left(\\frac{6}{11}\\right) + \\frac{3}{11} \\ln\\left(\\frac{3}{11}\\right) + \\frac{1}{11} \\ln\\left(\\frac{1}{11}\\right) + \\frac{1}{11} \\ln\\left(\\frac{1}{11}\\right) \\right)$$\n现在，我们计算差值 $\\Delta H = H(P_M) - H(P_S)$。注意到 $H(P_S)$ 和 $H(P_M)$ 的表达式中的前两项是相同的，它们在相减时会抵消。\n\\begin{align*}\n\\Delta H = H(P_M) - H(P_S) \\\\\n= \\left[ - \\left( \\frac{1}{11} \\ln\\frac{1}{11} + \\frac{1}{11} \\ln\\frac{1}{11} \\right) \\right] - \\left[ - \\left( \\frac{2}{11} \\ln\\frac{2}{11} \\right) \\right] \\\\\n= -\\frac{2}{11} \\ln\\frac{1}{11} + \\frac{2}{11} \\ln\\frac{2}{11} \\\\\n= \\frac{2}{11} \\left( \\ln\\frac{2}{11} - \\ln\\frac{1}{11} \\right)\n\\end{align*}\n使用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$：\n$$ \\Delta H = \\frac{2}{11} \\ln\\left(\\frac{2/11}{1/11}\\right) = \\frac{2}{11} \\ln(2) $$\n这就是以奈特为单位的熵差的最终精确表达式。",
            "answer": "$$\\boxed{\\frac{2}{11}\\ln(2)}$$"
        }
    ]
}