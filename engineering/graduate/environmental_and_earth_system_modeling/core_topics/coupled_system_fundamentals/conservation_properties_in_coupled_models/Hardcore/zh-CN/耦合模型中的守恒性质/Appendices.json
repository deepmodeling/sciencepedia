{
    "hands_on_practices": [
        {
            "introduction": "在耦合具有不同网格的模型时，一个常见的初步想法是使用简单的插值方法，例如双线性插值。本练习通过数学方法阐明为何这类直观的方法往往存在缺陷，会导致人为地产生或销毁质量或能量等守恒量。通过完成这个反例的推导 ，您将对为何必须设计专门的守恒重映照方案有一个基本的理解。",
            "id": "3871283",
            "problem": "考虑一个矩形域 $\\Omega = [0,1] \\times [0,1]$，它代表地球系统模型（Earth System Model, ESM）耦合界面的一部分，其中标量示踪场 $q(x,y)$ 在分量模型之间进行交换。在一个纯粹的诊断性格点到格点重映中，守恒算子必须保持全局质量 $M = \\int_{\\Omega} q(x,y)\\,dA$ 不变。一个广泛使用的非守恒算子是双线性插值，它构建一个多项式 $p(x,y)$，该多项式与网格节点上给定的 $q$ 的点值相匹配，但通常不保持面积分守恒。\n\n从第一性原理出发，完成以下任务：\n\n1. 定义在 $\\Omega$ 上的双线性插值多项式，形式为 $p(x,y) = a + b x + c y + d x y$，使其在四个角点 $(0,0)$, $(1,0)$, $(0,1)$ 和 $(1,1)$ 处与源场 $q(x,y)$ 的点值完全匹配。\n2. 推导域积分 $\\int_{\\Omega} p(x,y)\\,dx\\,dy$ 关于系数 $(a,b,c,d)$ 的表达式。\n3. 设源场为 $q(x,y) = x^{2}$（一个光滑的非双线性场）。计算与 $q$ 在四个角点处匹配的 $p(x,y)$ 的系数 $(a,b,c,d)$，然后计算 $\\int_{\\Omega} p(x,y)\\,dx\\,dy$。\n4. 计算真实的全局质量 $\\int_{\\Omega} q(x,y)\\,dx\\,dy$，并由此计算由双线性插值引起的全局质量变化 $\\Delta M = \\int_{\\Omega} p(x,y)\\,dx\\,dy - \\int_{\\Omega} q(x,y)\\,dx\\,dy$。\n\n以单个数字形式给出 $\\Delta M$ 的最终值。不需要单位。如果您选择对任何中间步骤进行数值近似，请保留最终的精确值。",
            "solution": "在格点到格点重映下，被动示踪物的守恒要求是全局质量 $M = \\int_{\\Omega} q(x,y)\\,dA$ 保持不变。由点采样定义的双线性插值多项式通常不保持 $M$ 守恒，因为它强制的是点值一致而不是面积加权一致。\n\n步骤 1：双线性插值多项式形式和角点约束。\n\n设双线性插值多项式为\n$$\np(x,y) = a + b x + c y + d x y.\n$$\n在 $\\Omega$ 的四个角点上施加点值一致的条件，得到\n\n$$\np(0,0) = a = q(0,0), \\quad p(1,0) = a + b = q(1,0),\n$$\n\n\n$$\np(0,1) = a + c = q(0,1), \\quad p(1,1) = a + b + c + d = q(1,1).\n$$\n\n由此可得，系数为\n\n$$\na = q(0,0), \\quad b = q(1,0) - q(0,0), \\quad c = q(0,1) - q(0,0), \\quad d = q(1,1) - q(1,0) - q(0,1) + q(0,0).\n$$\n\n\n步骤 2：双线性多项式的域积分。\n\n计算在 $\\Omega$ 上的积分：\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} p(x,y)\\,dx\\,dy = \\int_{0}^{1}\\int_{0}^{1} \\left(a + b x + c y + d x y\\right)\\,dx\\,dy.\n$$\n\n逐项积分：\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} a\\,dx\\,dy = a,\n$$\n\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} b x\\,dx\\,dy = b \\left(\\int_{0}^{1} x\\,dx\\right)\\left(\\int_{0}^{1} dy\\right) = b \\cdot \\frac{1}{2} \\cdot 1 = \\frac{b}{2},\n$$\n\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} c y\\,dx\\,dy = c \\left(\\int_{0}^{1} y\\,dy\\right)\\left(\\int_{0}^{1} dx\\right) = c \\cdot \\frac{1}{2} \\cdot 1 = \\frac{c}{2},\n$$\n\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} d x y\\,dx\\,dy = d \\left(\\int_{0}^{1} x\\,dx\\right)\\left(\\int_{0}^{1} y\\,dy\\right) = d \\cdot \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{d}{4}.\n$$\n\n因此，\n\n$$\n\\int_{\\Omega} p(x,y)\\,dx\\,dy = a + \\frac{b}{2} + \\frac{c}{2} + \\frac{d}{4}.\n$$\n\n如果我们将 $(a,b,c,d)$ 的角点值表达式代入，该式可简化为四个角点值之和的四分之一：\n\n$$\n\\int_{\\Omega} p(x,y)\\,dx\\,dy = \\frac{1}{4}\\left[q(0,0) + q(1,0) + q(0,1) + q(1,1)\\right].\n$$\n\n我们可以通过代入 $a$、$b$、$c$ 和 $d$ 来验证这一点：\n\n$$\na + \\frac{b}{2} + \\frac{c}{2} + \\frac{d}{4} = q(0,0) + \\frac{q(1,0) - q(0,0)}{2} + \\frac{q(0,1) - q(0,0)}{2} + \\frac{q(1,1) - q(1,0) - q(0,1) + q(0,0)}{4},\n$$\n\n化简后得到\n\n$$\n\\frac{1}{4}\\left[q(0,0) + q(1,0) + q(0,1) + q(1,1)\\right].\n$$\n\n\n步骤 3：应用于 $q(x,y) = x^{2}$。\n\n计算角点值：\n\n$$\nq(0,0) = 0^{2} = 0, \\quad q(1,0) = 1^{2} = 1,\n$$\n\n\n$$\nq(0,1) = 0^{2} = 0, \\quad q(1,1) = 1^{2} = 1.\n$$\n\n因此，\n\n$$\na = 0, \\quad b = 1 - 0 = 1, \\quad c = 0 - 0 = 0, \\quad d = 1 - 1 - 0 + 0 = 0,\n$$\n\n插值多项式为\n\n$$\np(x,y) = 0 + 1 \\cdot x + 0 \\cdot y + 0 \\cdot x y = x.\n$$\n\n其域积分为\n\n$$\n\\int_{\\Omega} p(x,y)\\,dx\\,dy = \\int_{0}^{1}\\int_{0}^{1} x\\,dx\\,dy = \\left(\\int_{0}^{1} x\\,dx\\right)\\left(\\int_{0}^{1} dy\\right) = \\frac{1}{2} \\cdot 1 = \\frac{1}{2}.\n$$\n\n\n步骤 4：真实的全局质量和由插值引起的变化。\n\n计算真实的全局质量：\n\n$$\n\\int_{\\Omega} q(x,y)\\,dx\\,dy = \\int_{0}^{1}\\int_{0}^{1} x^{2}\\,dx\\,dy = \\left(\\int_{0}^{1} x^{2}\\,dx\\right)\\left(\\int_{0}^{1} dy\\right) = \\frac{1}{3} \\cdot 1 = \\frac{1}{3}.\n$$\n\n因此，由双线性插值引起的全局质量变化为\n\n$$\n\\Delta M = \\int_{\\Omega} p(x,y)\\,dx\\,dy - \\int_{\\Omega} q(x,y)\\,dx\\,dy = \\frac{1}{2} - \\frac{1}{3} = \\frac{1}{6}.\n$$\n\n这个明确的反例表明，双线性插值不是守恒的：它会改变示踪场的全局积分，除非该场本身在单元格上是双线性的（在这种情况下，双线性插值多项式能精确再现该场，且不改变积分值）。对于非双线性的选择 $q(x,y)=x^{2}$，通过角点采样的双线性插值，质量增加了 $\\Delta M = \\frac{1}{6}$。",
            "answer": "$$\\boxed{\\frac{1}{6}}$$"
        },
        {
            "introduction": "在理解了非守恒方法的缺陷之后，下一步是构建一个在设计上就保证守恒的方案。本练习将引导您推导并实现一个一阶守恒重映照算法，这是模型耦合中的一项基础技术。其中的循环测试  进一步介绍了一种标准方法，用于验证您实现的稳健性，并量化由有限精度算法所带来的不可避免的数值漂移。",
            "id": "3871306",
            "problem": "一个标量在环境系统模型的两个分量之间通过一个耦合接口进行交换，该接口在覆盖闭区间 $\\left[0,1\\right]$ 的不同一维计算网格之间重映射场。每个网格 $\\mathcal{G}$ 由一系列严格递增的单元边界 $\\left\\{x_0, x_1, \\dots, x_N\\right\\}$ 定义，其中 $x_0 = 0$ 且 $x_N = 1$，并通过单元平均值 $\\left\\{c_i\\right\\}_{i=0}^{N-1}$ 来表示该标量，这些值在每个单元 $\\left[x_i, x_{i+1}\\right)$ 上是分段常数。该标量在整个域上的全局积分是所有单元积分之和，对于网格 $\\mathcal{G}$，其值为 $\\sum_{i=0}^{N-1} c_i \\,\\Delta x_i$，其中 $\\Delta x_i = x_{i+1} - x_i$。\n\n耦合采用了一种旨在守恒的重映射操作：当从具有边界 $\\left\\{x^S_i\\right\\}$ 和单元平均值 $\\left\\{c^S_i\\right\\}$ 的源网格 $\\mathcal{G}_S$ 重映射到具有边界 $\\left\\{x^T_j\\right\\}$ 的目标网格 $\\mathcal{G}_T$ 时，必须构造目标单元平均值 $\\left\\{c^T_j\\right\\}$，以使 $\\mathcal{G}_T$ 上的全局积分等于 $\\mathcal{G}_S$ 上的全局积分。请从第一性原理出发，推导出一个正确的算法流程，用于从 $\\left\\{c^S_i\\right\\}$ 和网格几何 $\\left\\{x^S_i\\right\\}$ 及 $\\left\\{x^T_j\\right\\}$ 构建 $\\left\\{c^T_j\\right\\}$，以确保在整个域上既不损失也不创造质量。您的推导必须仅基于以下基本原理：\n- 分段常数函数在某一区间上的积分等于该常数值乘以区间长度。\n- 跨分区守恒：整个域上的积分等于其任何精确分区上积分的总和。\n- 单元平均值的定义：一个单元上的平均值等于该场在该单元上的积分除以单元宽度。\n\n然后，您将设计并实现一个循环测试，在两个网格之间反复来回重映射，以量化由有限精度算术引起的全局积分中的数值漂移。循环测试从一个初始网格 $\\mathcal{G}_A$ 及其单元平均值 $\\left\\{c^A_i\\right\\}$ 开始，重映射到第二个网格 $\\mathcal{G}_B$ 以获得 $\\left\\{c^B_j\\right\\}$，然后重映射回 $\\mathcal{G}_A$ 以获得一组新的值 $\\left\\{c^{A,(1)}_i\\right\\}$。这个来回序列重复 $n$ 个循环，产生 $\\left\\{c^{A,(n)}_i\\right\\}$。将循环测试的漂移度量定义为 $n$ 个循环后 $\\mathcal{G}_A$ 上的全局积分与 $\\mathcal{G}_A$ 上初始全局积分之间的绝对差值，\n$$\nD_n \\equiv \\left| \\sum_{i=0}^{N_A-1} c^{A,(n)}_i \\,\\Delta x^A_i \\;-\\; \\sum_{i=0}^{N_A-1} c^{A,(0)}_i \\,\\Delta x^A_i \\right|.\n$$\n您必须通过对连续标量场 $f(x)$ 在 $\\mathcal{G}_A$ 的每个单元上进行精确解析积分，然后除以单元宽度来构造初始单元平均值 $\\left\\{c^{A,(0)}_i\\right\\}$。设\n$$\nf(x) \\;=\\; \\sin\\!\\left(2\\pi x\\right) \\;+\\; 0.3\\,\\cos\\!\\left(5\\pi x\\right) \\;+\\; 0.5\\,x,\n$$\n并使用精确反导数计算单元积分。将最终的漂移值表示为无量纲的小数。\n\n实现一个完整、可运行的程序，该程序：\n- 根据指定的规则构建网格。\n- 通过对 $f(x)$ 进行解析积分来计算 $\\mathcal{G}_A$ 上的初始单元平均值。\n- 根据您推导的流程在网格之间执行守恒重映射。\n- 对每个指定案例执行循环测试，并输出漂移度量 $D_n$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$）。每个结果必须是十进制数。\n\n使用以下参数值测试套件来检验算法的不同方面，包括一般情况、分辨率不匹配、非均匀几何、相同网格作为边界情况以及严重分辨率差异。对于每种情况，定义在 $\\left[0,1\\right]$ 上的网格 $\\mathcal{G}_A$ 和 $\\mathcal{G}_B$ 以及循环次数：\n- 案例 1：$\\mathcal{G}_A$ 是具有 $N_A = 8$ 个单元的均匀网格，$\\mathcal{G}_B$ 是具有 $N_B = 8$ 个单元的均匀网格，循环次数 $n = 10$。\n- 案例 2：$\\mathcal{G}_A$ 是具有 $N_A = 10$ 个单元的均匀网格，$\\mathcal{G}_B$ 是具有 $N_B = 12$ 个单元的均匀网格，循环次数 $n = 20$。\n- 案例 3：$\\mathcal{G}_A$ 是具有 $N_A = 64$ 个单元的拉伸非均匀网格，其边界为 $x^A_i = \\left(i/N_A\\right)^{1.7}$（对于 $i = 0,\\dots,64$），$\\mathcal{G}_B$ 是具有 $N_B = 64$ 个单元的均匀网格，循环次数 $n = 50$。\n- 案例 4：$\\mathcal{G}_A$ 是具有 $N_A = 32$ 个单元的均匀网格，$\\mathcal{G}_B$ 与 $\\mathcal{G}_A$ 相同，循环次数 $n = 100$。\n- 案例 5：$\\mathcal{G}_A$ 是具有 $N_A = 5$ 个单元的均匀网格，$\\mathcal{G}_B$ 是具有 $N_B = 200$ 个单元的均匀网格，循环次数 $n = 5$。\n\n您的程序必须计算并输出列表 $\\left[D_{n}^{(1)}, D_{n}^{(2)}, D_{n}^{(3)}, D_{n}^{(4)}, D_{n}^{(5)}\\right]$，格式为上述所描述的精确单行格式。不涉及角度或物理单位；结果是无量纲的小数。",
            "solution": "所述问题具有科学依据，提法明确，客观，并包含得出唯一解所需的所有必要信息。这是守恒律数值方法领域的一个标准问题，特别关注不同计算网格之间的守恒重映射。任务涉及从第一性原理推导算法，实现该算法，并使用循环测试来量化数值漂移。因此，该问题被认定为 **有效**。\n\n解决方案分两部分呈现：首先，根据指定的第一性原理推导守恒重映射算法；其次，概述循环测试和漂移度量计算的实现方案。\n\n**1. 守恒重映射算法的推导**\n\n目标是根据源网格 $\\mathcal{G}_S$ 上的一组单元平均值 $\\left\\{c^S_i\\right\\}$，计算目标网格 $\\mathcal{G}_T$ 上的一组单元平均值 $\\left\\{c^T_j\\right\\}$，使得标量的全局积分守恒。源场是一个分段常数函数 $\\phi_S(x)$，它在第 $i$ 个单元区间 $\\left[x^S_i, x^S_{i+1}\\right)$ 上取值为 $c^S_i$。目标场 $\\phi_T(x)$ 同样由在单元 $\\left[x^T_j, x^T_{j+1}\\right)$ 上的值 $c^T_j$ 定义。\n\n全局守恒要求目标网格上的总积分等于源网格上的总积分：\n$$\n\\sum_{j=0}^{N_T-1} c^T_j \\Delta x^T_j = \\sum_{i=0}^{N_S-1} c^S_i \\Delta x^S_i\n$$\n其中 $\\Delta x^T_j = x^T_{j+1} - x^T_j$ 和 $\\Delta x^S_i = x^S_{i+1} - x^S_i$ 分别是各自的单元宽度。\n\n我们根据给定的原理推导单个目标单元平均值 $c^T_j$ 的公式。\n首先，根据单元平均值的定义，值 $c^T_j$ 是单元 $\\left[x^T_j, x^T_{j+1}\\right)$ 中标量的总量（积分），我们将其表示为 $M^T_j$，除以该单元的宽度 $\\Delta x^T_j$：\n$$\nc^T_j = \\frac{M^T_j}{\\Delta x^T_j} = \\frac{1}{\\Delta x^T_j} \\int_{x^T_j}^{x^T_{j+1}} \\phi_T(x) \\, dx\n$$\n守恒重映射的核心原理是，目标单元中的质量是通过在目标单元的空间区间上对*源*场 $\\phi_S(x)$ 进行积分来确定的。\n$$\nM^T_j = \\int_{x^T_j}^{x^T_{j+1}} \\phi_S(x) \\, dx\n$$\n由于源网格 $\\mathcal{G}_S$ 构成了域 $\\left[0,1\\right]$ 的一个精确分区，我们可以将目标单元区间 $\\left[x^T_j, x^T_{j+1}\\right)$ 上的积分分解为它与每个源单元 $\\left[x^S_i, x^S_{i+1}\\right)$ 相交区域上的积分之和。\n$$\nM^T_j = \\sum_{i=0}^{N_S-1} \\int_{\\left[x^T_j, x^T_{j+1}\\right) \\cap \\left[x^S_i, x^S_{i+1}\\right)} \\phi_S(x) \\, dx\n$$\n在任何非空的相交区间内，源场 $\\phi_S(x)$ 是常数且等于 $c^S_i$。根据常数的积分等于常数乘以区间长度的原理，相交区域上的积分变为：\n$$\n\\int_{\\left[x^T_j, x^T_{j+1}\\right) \\cap \\left[x^S_i, x^S_{i+1}\\right)} c^S_i \\, dx = c^S_i \\cdot \\text{length}\\left(\\left[x^T_j, x^T_{j+1}\\right) \\cap \\left[x^S_i, x^S_{i+1}\\right)\\right)\n$$\n设 $\\Delta x_{ij}^{\\text{overlap}}$ 表示源单元 $i$ 和目标单元 $j$ 的相交部分的长度。该长度由以下公式给出：\n$$\n\\Delta x_{ij}^{\\text{overlap}} = \\max\\left(0, \\min\\left(x^S_{i+1}, x^T_{j+1}\\right) - \\max\\left(x^S_i, x^T_j\\right)\\right)\n$$\n将此代入 $M^T_j$ 的表达式，我们得到目标单元 $j$ 中的总质量是源单元值的加权和，其中权重是重叠长度：\n$$\nM^T_j = \\sum_{i=0}^{N_S-1} c^S_i \\, \\Delta x_{ij}^{\\text{overlap}}\n$$\n最后，通过除以目标单元宽度 $\\Delta x^T_j$，我们得到目标单元平均值 $c^T_j$ 的表达式：\n$$\nc^T_j = \\frac{1}{\\Delta x^T_j} \\sum_{i=0}^{N_S-1} c^S_i \\, \\max\\left(0, \\min\\left(x^S_{i+1}, x^T_{j+1}\\right) - \\max\\left(x^S_i, x^T_j\\right)\\right)\n$$\n这就是推导出来的一阶守恒重映射算法。它明确保证了在精确算术下，重映射后的场保持标量守恒。在实际实现中，任何与守恒的偏差都源于有限精度的浮点运算，而这正是循环测试要研究的主题。\n\n**2. 循环测试的算法设计**\n\n循环测试的实现如下：\n首先，对于每个测试案例，根据指定的规则（均匀或拉伸）构建源网格 $\\mathcal{G}_A$ 和目标网格 $\\mathcal{G}_B$。\n\n接下来，计算网格 $\\mathcal{G}_A$ 上的初始单元平均值，表示为 $\\left\\{c^{A,(0)}_i\\right\\}$。这是通过在 $\\mathcal{G}_A$ 的每个单元上对指定的连续标量场 $f(x)$ 进行解析积分来完成的。该函数为：\n$$\nf(x) = \\sin(2\\pi x) + 0.3\\,\\cos(5\\pi x) + 0.5\\,x\n$$\n其精确反导数 $F(x)$ 是：\n$$\nF(x) = -\\frac{1}{2\\pi}\\cos(2\\pi x) + \\frac{0.3}{5\\pi}\\sin(5\\pi x) + \\frac{1}{4}x^2\n$$\n在单元 $\\left[x^A_i, x^A_{i+1}\\right)$ 上的积分是 $F(x^A_{i+1}) - F(x^A_i)$。因此，初始单元平均值为：\n$$\nc^{A,(0)}_i = \\frac{F(x^A_{i+1}) - F(x^A_i)}{x^A_{i+1} - x^A_i}\n$$\n$\\mathcal{G}_A$ 上的初始全局积分计算为 $I^{A,(0)} = \\sum_{i=0}^{N_A-1} c^{A,(0)}_i \\Delta x^A_i$。\n\n然后，循环测试进行指定的循环次数 $n$。在每个循环 $k$（从 $0$ 到 $n-1$）中：\n1.  将场从 $\\mathcal{G}_A$ 重映射到 $\\mathcal{G}_B$：$\\left\\{c^B_j\\right\\} = \\text{Remap}\\left(\\left\\{c^{A,(k)}_i\\right\\}, \\mathcal{G}_A, \\mathcal{G}_B\\right)$。\n2.  将场从 $\\mathcal{G}_B$ 重映射回 $\\mathcal{G}_A$：$\\left\\{c^{A,(k+1)}_i\\right\\} = \\text{Remap}\\left(\\left\\{c^B_j\\right\\}, \\mathcal{G}_B, \\mathcal{G}_A\\right)$。\n`Remap` 函数实现了上一节中推导的公式。\n\n经过 $n$ 个循环后，获得最终场 $\\left\\{c^{A,(n)}_i\\right\\}$。最终全局积分计算为 $I^{A,(n)} = \\sum_{i=0}^{N_A-1} c^{A,(n)}_i \\Delta x^A_i$。\n\n最后，漂移度量 $D_n$ 计算为最终和初始全局积分之间的绝对差：\n$$\nD_n = \\left| I^{A,(n)} - I^{A,(0)} \\right|\n$$\n对问题陈述中定义的五个测试案例中的每一个重复此过程。收集得到的 $D_n$ 值，并以要求的格式呈现。实现中使用双精度浮点数（`float64`）进行所有计算，以最小化舍入误差，尽管该问题旨在揭示这些误差的累积效应。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to derive, implement, and test a conservative remapping algorithm.\n    \"\"\"\n\n    def F(x: np.ndarray) - np.ndarray:\n        \"\"\"\n        Calculates the exact antiderivative of the function f(x).\n        f(x) = sin(2*pi*x) + 0.3*cos(5*pi*x) + 0.5*x\n        F(x) = -1/(2*pi)*cos(2*pi*x) + 0.3/(5*pi)*sin(5*pi*x) + 0.25*x**2\n        \"\"\"\n        term1 = -1.0 / (2.0 * np.pi) * np.cos(2.0 * np.pi * x)\n        term2 = 0.3 / (5.0 * np.pi) * np.sin(5.0 * np.pi * x)\n        term3 = 0.25 * x**2\n        return term1 + term2 + term3\n\n    def make_grid(N: int, grid_type: str = 'uniform', power: float = 1.0) - np.ndarray:\n        \"\"\"\n        Constructs a grid with N cells on the interval [0, 1].\n        Returns an array of N+1 cell edges.\n        \"\"\"\n        if grid_type == 'uniform':\n            return np.linspace(0.0, 1.0, N + 1, dtype=np.float64)\n        elif grid_type == 'stretched':\n            base = np.arange(N + 1, dtype=np.float64) / N\n            return np.power(base, power)\n        else:\n            raise ValueError(f\"Unknown grid type: {grid_type}\")\n\n    def remap(c_source: np.ndarray, grid_source: np.ndarray, grid_target: np.ndarray) - np.ndarray:\n        \"\"\"\n        Performs first-order conservative remapping from a source to a target grid.\n        \n        Args:\n            c_source: Array of cell-average values on the source grid.\n            grid_source: Array of source grid cell edges.\n            grid_target: Array of target grid cell edges.\n        \n        Returns:\n            Array of cell-average values on the target grid.\n        \"\"\"\n        n_source_cells = len(c_source)\n        n_target_cells = len(grid_target) - 1\n        \n        c_target = np.zeros(n_target_cells, dtype=np.float64)\n        delta_x_target = np.diff(grid_target)\n\n        for j in range(n_target_cells):\n            target_cell_start = grid_target[j]\n            target_cell_end = grid_target[j+1]\n            \n            total_mass_in_target_cell = 0.0\n            \n            for i in range(n_source_cells):\n                source_cell_start = grid_source[i]\n                source_cell_end = grid_source[i+1]\n                \n                # Calculate the length of the intersection interval\n                overlap_length = max(0.0, min(source_cell_end, target_cell_end) - max(source_cell_start, target_cell_start))\n                \n                if overlap_length  0.0:\n                    total_mass_in_target_cell += c_source[i] * overlap_length\n            \n            if delta_x_target[j]  1e-15: # Avoid division by zero\n                c_target[j] = total_mass_in_target_cell / delta_x_target[j]\n        \n        return c_target\n\n    test_cases = [\n        {'NA': 8, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 8, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 10},\n        {'NA': 10, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 12, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 20},\n        {'NA': 64, 'grid_A_type': 'stretched', 'power_A': 1.7, 'NB': 64, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 50},\n        {'NA': 32, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 32, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 100},\n        {'NA': 5, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 200, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Construct grids\n        grid_A = make_grid(case['NA'], case['grid_A_type'], case['power_A'])\n        grid_B = make_grid(case['NB'], case['grid_B_type'], case['power_B'])\n        \n        # 2. Compute initial cell-averages on grid A\n        delta_x_A = np.diff(grid_A)\n        cell_integrals_A_0 = F(grid_A[1:]) - F(grid_A[:-1])\n        c_A_0 = cell_integrals_A_0 / delta_x_A\n        \n        # 3. Calculate initial global integral\n        initial_global_integral = np.sum(c_A_0 * delta_x_A)\n        \n        # 4. Perform cycle test\n        c_A_current = c_A_0.copy()\n        for _ in range(case['n_cycles']):\n            c_B = remap(c_A_current, grid_A, grid_B)\n            c_A_current = remap(c_B, grid_B, grid_A)\n            \n        # 5. Calculate final global integral and drift metric\n        final_global_integral = np.sum(c_A_current * delta_x_A)\n        drift = abs(final_global_integral - initial_global_integral)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.17g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "守恒原则不仅必须在单一的重映照步骤中得到遵守，在复杂、多阶段的耦合工作流中同样如此。本练习展示了一个将陆地径流输送到海洋模型的实际例子，这是地球系统模拟中的一项常见任务。通过确保从陆地单元到河口、再从河口到海洋的每个阶段的映照都经过归一化 ，您将学会在一个真实且模块化的耦合系统中如何保证全局质量守恒。",
            "id": "3871305",
            "problem": "考虑一个耦合的陆地-海洋模型，其中陆地表面径流通过河流网络被输送到海洋模型网格。其基本原理是全球范围内的水量质量守恒：输送到海洋的陆地径流总量必须等于在河口处计算的海洋总入流量。形式上，对于一组以 $i \\in \\{1,\\dots,L\\}$ 索引的陆地网格单元，其径流通量为 $r_i$（单位 $\\mathrm{m\\,s^{-1}}$），面积为 $A_i$（单位 $\\mathrm{m^2}$），则每个陆地单元的体积源为 $Q_i = r_i A_i$（单位 $\\mathrm{m^3\\,s^{-1}}$）。设存在以 $k \\in \\{1,\\dots,K\\}$ 索引的河口和以 $j \\in \\{1,\\dots,O\\}$ 索引的海洋网格单元。\n\n河流路径方案由两个离散映射指定：\n- 一个从陆地到河口的分数路径矩阵 $R \\in \\mathbb{R}^{K \\times L}$，其条目 $R_{k i} \\ge 0$ 表示从 $Q_i$ 输送到河口 $k$ 的分数。$R$ 的列之和初始可能不为 $1$，必须进行归一化以确保在陆地到河口的阶段守恒。\n- 一个从河口到海洋的候选权重规范，对每个河口 $k$，以一个海洋单元候选列表和非负未归一化权重的形式给出 $\\{(j, w_{j k})\\}$，其中 $w_{j k} \\ge 0$。一个海洋掩码（ocean mask）标识了哪些海洋单元是湿润的（有效的）。对于每个河口，有效候选区必须在湿润海洋单元上进行归一化，以定义一个满足 $\\sum_{j=1}^{O} \\tilde{w}_{j k} = 1$ 的分布 $\\tilde{w}_{j k}$。\n\n目标是构建一个从陆地单元到海洋单元的离散映射 $M \\in \\mathbb{R}^{O \\times L}$，使得路径输送的海洋流量 $D_j$（单位 $\\mathrm{m^3\\,s^{-1}}$）满足\n$$\nD_j = \\sum_{i=1}^{L} M_{j i} Q_i,\n$$\n并且全局守恒条件\n$$\n\\sum_{j=1}^{O} D_j = \\sum_{i=1}^{L} Q_i\n$$\n在离散系统中精确成立，直至数值精度。该映射必须通过归一化后的 $R$ 和归一化后的 $\\tilde{w}_{j k}$ 导出：\n$$\nM_{j i} = \\sum_{k=1}^{K} \\tilde{w}_{j k}\\, \\bar{R}_{k i},\n$$\n其中 $\\bar{R}$ 是 $R$ 的按列归一化版本，定义为\n$$\n\\bar{R}_{k i} =\n\\begin{cases}\n\\displaystyle \\frac{R_{k i}}{\\sum_{k'=1}^{K} R_{k' i}},  \\text{if } \\sum_{k'=1}^{K} R_{k' i}  0, \\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n要根据未归一化的权重 $w_{j k}$ 和海洋掩码构建 $\\tilde{w}_{j k}$，仅使用单元 $j$ 为湿润的候选区 $(j, w_{j k})$。对于每个至少有一个有效候选区的河口 $k$，定义\n$$\n\\tilde{w}_{j k} = \\frac{w_{j k}}{\\sum_{j' \\text{ valid}} w_{j' k}} \\quad \\text{在有效候选区上}。\n$$\n如果一个河口 $k$ 没有有效候选区，则必须应用回退规则，将其所有流量分配给索引最小的湿润海洋单元 $j^\\star$，因此 $\\tilde{w}_{j^\\star k} = 1$ 且对于 $j \\ne j^\\star$，$\\tilde{w}_{j k} = 0$。如果没有湿润的海洋单元，则无法构建该映射；这种情况不会出现在测试套件中。\n\n使用上述框架，并从质量守恒和离散归一化原则出发，实现一个程序，该程序：\n1. 按列归一化 $R$ 以获得 $\\bar{R}$。\n2. 在湿润海洋单元上归一化从河口到海洋的权重以获得 $\\tilde{w}_{j k}$，必要时使用回退规则。\n3. 通过 $M_{j i} = \\sum_{k=1}^{K} \\tilde{w}_{j k}\\, \\bar{R}_{k i}$ 构建 $M$。\n4. 计算 $Q_i = r_i A_i$ 和 $D_j = \\sum_{i=1}^{L} M_{j i} Q_i$。\n5. 对于每个测试用例，返回一个布尔值，指示是否满足 $\\left|\\sum_{j=1}^{O} D_j - \\sum_{i=1}^{L} Q_i\\right| \\le \\varepsilon$，其中绝对容差 $\\varepsilon = 10^{-6}$（单位 $\\mathrm{m^3\\,s^{-1}}$）。\n\n所有流量均以 $\\mathrm{m^3\\,s^{-1}}$ 表示。仅在涉及角度时使用弧度或度；本问题不使用角度。\n\n测试套件：\n提供四个具有明确参数的测试用例：\n\n- 测试用例 1（一般正常路径）：\n    - 陆地单元 $L = 4$，面积 $A = [1.0 \\times 10^{10}, 0.8 \\times 10^{10}, 1.2 \\times 10^{10}, 0.5 \\times 10^{10}]$，径流通量 $r = [1.0 \\times 10^{-8}, 3.0 \\times 10^{-8}, 2.0 \\times 10^{-8}, 0.0]$。\n    - 河口 $K = 2$，陆地到河口的路径矩阵\n      $$\n      R = \\begin{bmatrix}\n      1.0  1.0  0.0  0.6 \\\\\n      0.0  0.0  1.0  0.4\n      \\end{bmatrix}.\n      $$\n    - 海洋单元 $O = 3$，湿润掩码 $\\text{mask} = [\\text{True}, \\text{True}, \\text{True}]$。\n    - 河口到海洋的候选区：\n        - 河口 1：$\\{(0, 2.0), (1, 1.0)\\}$。\n        - 河口 2：$\\{(1, 1.0), (2, 3.0)\\}$。\n\n- 测试用例 2（掩码引发的重新归一化）：\n    - $L$、$A$ 和 $R$ 与测试用例 1 相同。\n    - 径流通量 $r = [2.0 \\times 10^{-8}, 0.0, 5.0 \\times 10^{-9}, 1.0 \\times 10^{-9}]$。\n    - 海洋单元 $O = 3$，湿润掩码 $\\text{mask} = [\\text{True}, \\text{True}, \\text{False}]$。\n    - 河口到海洋的候选区：\n        - 河口 1：$\\{(0, 2.0), (1, 1.0)\\}$。\n        - 河口 2：$\\{(1, 1.0), (2, 3.0)\\}$，其中海洋单元 2 是干燥的，必须被排除，使得河口 2 在剩余的有效候选区上进行归一化。\n\n- 测试用例 3（河口无有效候选区时的回退规则）：\n    - $L$ 和 $R$ 与测试用例 1 相同，面积 $A = [1.0 \\times 10^{10}, 0.8 \\times 10^{10}, 1.2 \\times 10^{10}, 0.5 \\times 10^{10}]$，径流通量 $r = [1.0 \\times 10^{-8}, 2.0 \\times 10^{-8}, 1.0 \\times 10^{-8}, 3.0 \\times 10^{-9}]$。\n    - 海洋单元 $O = 3$，湿润掩码 $\\text{mask} = [\\text{False}, \\text{True}, \\text{False}]$，因此只有海洋单元 1（索引为 1）是湿润的。\n    - 河口到海洋的候选区：\n        - 河口 1：$\\{(0, 1.0), (2, 1.0)\\}$，由于掩码的原因，两者都无效，触发回退到索引最小的湿润单元。\n        - 河口 2：$\\{(1, 1.0)\\}$，有效。\n\n- 测试用例 4（零径流的边界情况）：\n    - 陆地单元 $L = 3$，面积 $A = [1.0 \\times 10^{6}, 2.0 \\times 10^{6}, 3.0 \\times 10^{6}]$，径流通量 $r = [0.0, 0.0, 0.0]$。\n    - 河口 $K = 1$，陆地到河口的路径矩阵\n      $$\n      R = \\begin{bmatrix}\n      1.0  1.0  1.0\n      \\end{bmatrix}.\n      $$\n    - 海洋单元 $O = 2$，湿润掩码 $\\text{mask} = [\\text{True}, \\text{True}]$。\n    - 河口到海洋的候选区：\n        - 河口 1：$\\{(0, 1.0), (1, 1.0)\\}$。\n\n您的程序应生成一行输出，其中包含一个用逗号分隔并用方括号括起来的结果列表（例如，\"[result1,result2,result3,result4]\"），其中每个条目都是一个布尔值，指示对于相应的测试用例，全局守恒是否在绝对容差 $\\varepsilon = 10^{-6}$（单位 $\\mathrm{m^3\\,s^{-1}}$）内成立。",
            "solution": "用户希望验证并解决一个关于耦合陆海模型中质量守恒的问题。\n\n### 问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n**步骤 1：提取给定信息**\n\n- **索引：** 陆地单元 $i \\in \\{1, \\dots, L\\}$；河口 $k \\in \\{1, \\dots, K\\}$；海洋单元 $j \\in \\{1, \\dots, O\\}$。\n- **陆地径流：** 径流通量 $r_i$ ($\\mathrm{m\\,s^{-1}}$)，陆地单元面积 $A_i$ ($\\mathrm{m^2}$)，体积源 $Q_i = r_i A_i$ ($\\mathrm{m^3\\,s^{-1}}$)。\n- **陆地到河口路径 ($R$)：** 一个矩阵 $R \\in \\mathbb{R}^{K \\times L}$，其中 $R_{k i} \\ge 0$ 定义了从陆地单元 $i$ 到河口 $k$ 的未归一化路径。\n- **$R$ 的归一化：** $R$ 按列归一化以产生 $\\bar{R}$，使得对于每个陆地单元 $i$，其对所有河口的分数贡献总和为 1，除非总贡献为零。公式为：\n$$\n\\bar{R}_{k i} =\n\\begin{cases}\n\\displaystyle \\frac{R_{k i}}{\\sum_{k'=1}^{K} R_{k' i}},  \\text{if } \\sum_{k'=1}^{K} R_{k' i}  0, \\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n- **河口到海洋的分布 ($\\tilde{w}$):**\n    - 输入：对每个河口 $k$ 的未归一化权重列表 $\\{(j, w_{j k})\\}$，其中 $w_{j k} \\ge 0$，以及一个标识湿润单元的海洋 `mask`。\n    - 归一化：对于每个至少有一个有效候选区（即候选区 $(j, w_{jk})$ 中单元 $j$ 是湿润的）的河口 $k$，归一化权重 $\\tilde{w}_{j k}$ 由下式给出：\n    $$\n    \\tilde{w}_{j k} = \\frac{w_{j k}}{\\sum_{j' \\text{ valid}} w_{j' k}}\n    $$\n    - 回退规则：如果河口 $k$ 没有有效候选区，其全部流量将被分配给索引最小的湿润海洋单元 $j^\\star$，即 $\\tilde{w}_{j^\\star k} = 1$，且该 $k$ 的所有其他 $\\tilde{w}_{j k}$ 均为 $0$。\n- **陆地到海洋映射 ($M$)：** 一个矩阵 $M \\in \\mathbb{R}^{O \\times L}$，构建为 $M_{j i} = \\sum_{k=1}^{K} \\tilde{w}_{j k}\\, \\bar{R}_{k i}$。\n- **海洋流量 ($D$)：** 进入海洋单元 $j$ 的流量为 $D_j = \\sum_{i=1}^{L} M_{j i} Q_i$。\n- **守恒检查：** 任务是验证全局守恒条件 $|\\sum_{j=1}^{O} D_j - \\sum_{i=1}^{L} Q_i| \\le \\varepsilon$ 是否成立，绝对容差为 $\\varepsilon = 10^{-6} \\, \\mathrm{m^3\\,s^{-1}}$。\n- **测试套件：** 提供了四个具有所有必要参数的明确测试用例。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n1.  **科学依据：** 该问题基于质量守恒的基本原理，这是物理学和环境建模的基石。所描述的将径流从陆地表面网格通过河流网络输送到海洋网格的框架是地球系统模型中各组成部分的标准（尽管简化了）表示。单位和物理量是正确且现实的。该问题在科学上是合理的。\n\n2.  **适定性：** 问题是适定的。所有输入都已指定，推导中间量和最终量的过程也定义明确。对于陆地到河口矩阵 $\\bar{R}$ 和河口到海洋权重 $\\tilde{w}$ 的归一化规则是明确的，并涵盖了所有描述的必要情况，包括列总和为零和河口没有有效目标（回退规则）。问题保证至少有一个海洋单元是湿润的，从而防止回退规则出现未定义的结果。这确保了可以构建唯一的解。\n\n3.  **客观性：** 问题以精确、客观的数学和计算术语陈述。没有主观语言或依赖于观点。\n\n4.  **缺陷检查清单：**\n    - **科学上不合理：** 无。核心概念是合理的。\n    - **不可形式化：** 问题通过数学方程明确地形式化了。\n    - **不完整/矛盾：** 每个测试用例提供的信息是完整的。归一化规则被设计为相互一致并强制守恒。\n    - **不切实际/不可行：** 数值是合理的，计算是可行的。\n    - **不适定/结构不良：** 问题结构良好，提供了逐步的程序。\n    - **琐碎/同义反复：** 该问题要求实现一个数值方案并验证其属性。守恒性质是归一化步骤数学设计中固有的。我们可以从解析上证明这一点：\n        总海洋流量为 $\\sum_j D_j = \\sum_j \\sum_i M_{ji} Q_i$。\n        代入 $M_{ji}$：$\\sum_j \\sum_i (\\sum_k \\tilde{w}_{jk} \\bar{R}_{ki}) Q_i$。\n        重排有限和：$\\sum_i Q_i \\sum_k \\bar{R}_{ki} (\\sum_j \\tilde{w}_{jk})$。\n        根据定义，河口到海洋的权重是归一化的，因此对于任何河口 $k$，$\\sum_j \\tilde{w}_{jk} = 1$。\n        表达式简化为 $\\sum_i Q_i \\sum_k \\bar{R}_{ki}$。\n        根据 $\\bar{R}$ 的定义，对于任何有水流被输送的陆地单元 $i$（即 $\\sum_{k'} R_{k'i}  0$），我们有 $\\sum_k \\bar{R}_{ki} = 1$。如果来自 $i$ 的水流没有被输送（即 $\\sum_{k'} R_{k'i} = 0$），则 $\\sum_k \\bar{R}_{ki} = 0$。\n        在后一种情况下，$\\sum_j D_j$ 将不包括来自 $Q_i$ 的贡献，这违反了全局守恒。然而，问题的表述和测试用例仅包括任何非零源 $Q_i$ 都与可输送的陆地单元相关联的场景（即其在 $R$ 中的列不全为零）。因此，对于所有 $Q_i \\neq 0$ 的 $i$，我们有 $\\sum_k \\bar{R}_{ki} = 1$。对于 $Q_i=0$ 的单元，$\\sum_k \\bar{R}_{ki}$ 的值无关紧要。\n        因此，总流量变为 $\\sum_i Q_i \\cdot 1 = \\sum_i Q_i$。\n        守恒是由解析公式保证的。任务是数值上实现这个公式，并检查该属性在浮点精度内是否成立，这是一个有效的数值验证任务。\n    - **外部可验证性：** 问题完全可以通过计算来验证。\n\n**步骤 3：结论与行动**\n\n此问题是 **有效的**。它是一个定义明确、具有科学相关性的计算练习，旨在实现和验证一个质量守恒的耦合方案。我现在将着手构建解决方案。\n\n### 解决方案\n\n解决方案涉及为每个测试用例实现指定的计算序列。该方法的核心在于两个归一化步骤，这两个步骤旨在确保质量（在这种情况下是水量）在从陆地单元到海洋的每个传输阶段都得到守恒。\n\n1.  **计算源项 $Q$**：对于每个陆地单元 $i$，体积径流源 $Q_i$ 是径流通量 $r_i$ 与单元面积 $A_i$ 的乘积。总源是所有陆地单元的总和，$\\sum_{i=1}^{L} Q_i$。\n\n2.  **归一化陆地到河口矩阵 $R$**：原始路径矩阵 $R$ 按列归一化以产生 $\\bar{R}$。对于每个陆地单元 $i$（第 $i$ 列），其总径流在河口 $k$ 之间分配。归一化确保只要径流被输送到任何地方，单元 $i$ 的 $100\\%$ 的径流都被计算在内。如果列和 $\\sum_{k'=1}^{K} R_{k' i}$ 为正，则每个元素除以该和，使新的列和为 $1$。如果列和为 $0$，则 $\\bar{R}$ 中该列的所有元素保持为 $0$，表示来自此单元的水在河流系统中丢失了。\n\n3.  **归一化河口到海洋权重 $\\tilde{w}$**：此步骤构建一个矩阵，我们称之为 $\\tilde{W}$（维度为 $O \\times K$），其中每个条目 $\\tilde{W}_{jk}$ 对应于数学项 $\\tilde{w}_{jk}$。对于每个河口 $k$（第 $k$ 列），其总入流量在海洋单元 $j$ 之间分配。这需要对提供的候选权重 $w_{jk}$ 进行归一化。关键是，这种归一化只考虑由 `mask` 指定的“湿润”海洋单元。\n    - 如果一个河口有有效候选区（即指向湿润海洋单元的候选区），它们的权重相加，然后每个单独的权重除以这个总和。\n    - 如果一个河口没有有效候选区，回退规则规定其全部流量都导向索引最小的单一湿润海洋单元 $j^\\star$。这通过设置 $\\tilde{w}_{j^\\star k} = 1$ 来表示。\n    在所有情况下，对于任何给定的河口 $k$，$\\tilde{W}$ 矩阵中结果列的总和为 $1$（$\\sum_{j=1}^{O} \\tilde{w}_{jk}=1$）。\n\n4.  **构建全局映射矩阵 $M$**：从陆地单元 $i$ 到海洋单元 $j$ 的端到端映射是两个中间映射的乘积。公式 $M_{j i} = \\sum_{k=1}^{K} \\tilde{w}_{j k}\\, \\bar{R}_{k i}$ 精确地是矩阵乘法的定义。因此，$M = \\tilde{W} \\cdot \\bar{R}$。\n\n5.  **计算海洋流量 $D$**：进入每个海洋单元 $j$ 的总流量 $D_j$，是来自所有陆地单元贡献的总和。这由矩阵-向量乘积 $D = M \\cdot Q$ 给出。\n\n6.  **验证守恒**：最后，将进入海洋的总流量 $\\sum_{j=1}^{O} D_j$ 与来自陆地的总源 $\\sum_{i=1}^{L} Q_i$ 进行比较。正如解析上证明的那样，这些总和应该相等。检查将验证这个等式在数值上是否成立，即在给定的浮点容差 $\\varepsilon=10^{-6}$ 内。\n\n实现将使用 `NumPy` 库进行高效的数组和矩阵运算，这与所描述的数学形式直接对应。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general happy path)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([1.0e-8, 3.0e-8, 2.0e-8, 0.0]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([True, True, True]),\n            'mouth_candidates': [\n                [(0, 2.0), (1, 1.0)],  # Mouth 1 (k=0)\n                [(1, 1.0), (2, 3.0)]   # Mouth 2 (k=1)\n            ]\n        },\n        # Test case 2 (mask-induced renormalization)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([2.0e-8, 0.0, 5.0e-9, 1.0e-9]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([True, True, False]),\n            'mouth_candidates': [\n                [(0, 2.0), (1, 1.0)],\n                [(1, 1.0), (2, 3.0)]\n            ]\n        },\n        # Test case 3 (fallback when no valid candidates for a mouth)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([1.0e-8, 2.0e-8, 1.0e-8, 3.0e-9]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([False, True, False]),\n            'mouth_candidates': [\n                [(0, 1.0), (2, 1.0)],\n                [(1, 1.0)]\n            ]\n        },\n        # Test case 4 (boundary case with zero runoff)\n        {\n            'L': 3, 'K': 1, 'O': 2,\n            'A': np.array([1.0e6, 2.0e6, 3.0e6]),\n            'r': np.array([0.0, 0.0, 0.0]),\n            'R': np.array([[1.0, 1.0, 1.0]]),\n            'mask': np.array([True, True]),\n            'mouth_candidates': [\n                [(0, 1.0), (1, 1.0)]\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\ndef _process_case(case_data):\n    \"\"\"\n    Processes a single test case for conservation validation.\n    \n    Args:\n        case_data (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        bool: True if mass is conserved within the tolerance, False otherwise.\n    \"\"\"\n    # Extract parameters from the case data\n    L, K, O = case_data['L'], case_data['K'], case_data['O']\n    A, r, R, mask, mouth_cands = (case_data['A'], case_data['r'], case_data['R'],\n                                   case_data['mask'], case_data['mouth_candidates'])\n    epsilon = 1e-6\n\n    # 1. Compute volumetric source Q from land cells\n    Q = r * A\n    total_Q = np.sum(Q)\n\n    # 2. Normalize the land-to-mouth routing matrix R to get R_bar\n    R_bar = np.zeros_like(R, dtype=float)\n    col_sums = np.sum(R, axis=0)\n    # Use boolean indexing to avoid division by zero\n    non_zero_cols_mask = col_sums  0\n    R_bar[:, non_zero_cols_mask] = R[:, non_zero_cols_mask] / col_sums[non_zero_cols_mask]\n\n    # 3. Construct the normalized mouth-to-ocean weight matrix W_tilde\n    W_tilde = np.zeros((O, K), dtype=float)\n    wet_ocean_indices = np.where(mask)[0]\n    # Smallest-indexed wet ocean cell for fallback rule\n    # The problem guarantees at least one wet cell.\n    j_star = wet_ocean_indices[0]\n\n    for k in range(K):\n        candidates = mouth_cands[k]\n        valid_candidates = [(j, w) for j, w in candidates if mask[j]]\n\n        if not valid_candidates:\n            # Fallback rule: No valid candidates, assign all to j_star\n            W_tilde[j_star, k] = 1.0\n        else:\n            # Normalization over valid candidates\n            valid_weights = np.array([w for j, w in valid_candidates])\n            weight_sum = np.sum(valid_weights)\n\n            if weight_sum  0:\n                for i, (j, w) in enumerate(valid_candidates):\n                    W_tilde[j, k] = valid_weights[i] / weight_sum\n            # If weight_sum is 0, W_tilde[:, k] remains 0. This violates conservation\n            # sum(W_tilde[:,k])=1. The problem assumes this won't happen for valid cands.\n\n    # 4. Construct the land-to-ocean mapping matrix M\n    # M_ji = sum_k(W_tilde_jk * R_bar_ki) - M = W_tilde @ R_bar\n    M = W_tilde @ R_bar\n\n    # 5. Compute ocean discharge D for each ocean cell\n    # D_j = sum_i(M_ji * Q_i) - D = M @ Q\n    D = M @ Q\n    total_D = np.sum(D)\n\n    # 6. Verify global conservation within the absolute tolerance\n    return abs(total_D - total_Q) = epsilon\n\n# The following is a patched solve() function to produce lowercase booleans as per the example.\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general happy path)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([1.0e-8, 3.0e-8, 2.0e-8, 0.0]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([True, True, True]),\n            'mouth_candidates': [\n                [(0, 2.0), (1, 1.0)],  # Mouth 1 (k=0)\n                [(1, 1.0), (2, 3.0)]   # Mouth 2 (k=1)\n            ]\n        },\n        # Test case 2 (mask-induced renormalization)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([2.0e-8, 0.0, 5.0e-9, 1.0e-9]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([True, True, False]),\n            'mouth_candidates': [\n                [(0, 2.0), (1, 1.0)],\n                [(1, 1.0), (2, 3.0)]\n            ]\n        },\n        # Test case 3 (fallback when no valid candidates for a mouth)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([1.0e-8, 2.0e-8, 1.0e-8, 3.0e-9]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([False, True, False]),\n            'mouth_candidates': [\n                [(0, 1.0), (2, 1.0)],\n                [(1, 1.0)]\n            ]\n        },\n        # Test case 4 (boundary case with zero runoff)\n        {\n            'L': 3, 'K': 1, 'O': 2,\n            'A': np.array([1.0e6, 2.0e6, 3.0e6]),\n            'r': np.array([0.0, 0.0, 0.0]),\n            'R': np.array([[1.0, 1.0, 1.0]]),\n            'mask': np.array([True, True]),\n            'mouth_candidates': [\n                [(0, 1.0), (1, 1.0)]\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}