{
    "hands_on_practices": [
        {
            "introduction": "When coupling model components that operate on different grids, a common task is to transfer a physical field, like a tracer concentration, from a source grid to a target grid. An intuitive approach is to use a standard interpolation method like bilinear interpolation. This practice provides a rigorous, hands-on mathematical demonstration of why such methods, while preserving values at specific points, generally fail to conserve integrated quantities like total mass, leading to unphysical sources or sinks in a coupled system . By constructing a concrete counterexample, you will solidify your understanding of why specialized conservative remapping algorithms are indispensable in Earth system modeling.",
            "id": "3871283",
            "problem": "Consider a rectangular domain $\\Omega = [0,1] \\times [0,1]$ representing a portion of the Earth system model (ESM) coupling interface where a scalar tracer field $q(x,y)$ is exchanged between component models. In a purely diagnostic grid-to-grid remapping, a conservative operator must preserve the global mass $M = \\int_{\\Omega} q(x,y)\\,dA$. A widely used non-conservative operator is bilinear interpolation, which constructs a polynomial $p(x,y)$ that matches given pointwise values of $q$ at grid nodes but does not, in general, preserve the area integral.\n\nStarting from first principles, do the following:\n\n1. Define the bilinear interpolant over $\\Omega$ in the form $p(x,y) = a + b x + c y + d x y$ that exactly matches the pointwise values of the source field $q(x,y)$ at the four corners $(0,0)$, $(1,0)$, $(0,1)$, and $(1,1)$.\n2. Derive the expression for the domain integral $\\int_{\\Omega} p(x,y)\\,dx\\,dy$ in terms of the coefficients $(a,b,c,d)$.\n3. Let the source field be $q(x,y) = x^{2}$ (a smooth non-bilinear field). Compute the coefficients $(a,b,c,d)$ of $p(x,y)$ that match $q$ at the four corners, and then evaluate $\\int_{\\Omega} p(x,y)\\,dx\\,dy$.\n4. Compute the true global mass $\\int_{\\Omega} q(x,y)\\,dx\\,dy$ and hence the change in global mass $\\Delta M = \\int_{\\Omega} p(x,y)\\,dx\\,dy - \\int_{\\Omega} q(x,y)\\,dx\\,dy$ caused by bilinear interpolation.\n\nProvide the final value of $\\Delta M$ as a single number. No units are required. If you choose to approximate any intermediate steps numerically, retain the exact final value.",
            "solution": "The conservation requirement for a passive tracer under grid-to-grid remapping is that the global mass $M = \\int_{\\Omega} q(x,y)\\,dA$ is invariant. A bilinear interpolant, defined from pointwise samples, does not generally preserve $M$ because it enforces pointwise agreement rather than area-weighted agreement.\n\nStep 1: Bilinear interpolant form and corner constraints.\n\nLet the bilinear interpolant be\n$$\np(x,y) = a + b x + c y + d x y.\n$$\nImposing pointwise agreement at the four corners of $\\Omega$ gives\n\n$$\np(0,0) = a = q(0,0), \\quad p(1,0) = a + b = q(1,0),\n$$\n\n\n$$\np(0,1) = a + c = q(0,1), \\quad p(1,1) = a + b + c + d = q(1,1).\n$$\n\nFrom these, the coefficients are\n\n$$\na = q(0,0), \\quad b = q(1,0) - q(0,0), \\quad c = q(0,1) - q(0,0), \\quad d = q(1,1) - q(1,0) - q(0,1) + q(0,0).\n$$\n\n\nStep 2: Domain integral of a bilinear polynomial.\n\nCompute the integral over $\\Omega$:\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} p(x,y)\\,dx\\,dy = \\int_{0}^{1}\\int_{0}^{1} \\left(a + b x + c y + d x y\\right)\\,dx\\,dy.\n$$\n\nIntegrate term by term:\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} a\\,dx\\,dy = a,\n$$\n\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} b x\\,dx\\,dy = b \\left(\\int_{0}^{1} x\\,dx\\right)\\left(\\int_{0}^{1} dy\\right) = b \\cdot \\frac{1}{2} \\cdot 1 = \\frac{b}{2},\n$$\n\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} c y\\,dx\\,dy = c \\left(\\int_{0}^{1} y\\,dy\\right)\\left(\\int_{0}^{1} dx\\right) = c \\cdot \\frac{1}{2} \\cdot 1 = \\frac{c}{2},\n$$\n\n\n$$\n\\int_{0}^{1}\\int_{0}^{1} d x y\\,dx\\,dy = d \\left(\\int_{0}^{1} x\\,dx\\right)\\left(\\int_{0}^{1} y\\,dy\\right) = d \\cdot \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{d}{4}.\n$$\n\nThus,\n\n$$\n\\int_{\\Omega} p(x,y)\\,dx\\,dy = a + \\frac{b}{2} + \\frac{c}{2} + \\frac{d}{4}.\n$$\n\nIf we substitute the corner-value expressions for $(a,b,c,d)$, this simplifies to one quarter of the sum of the corner values:\n\n$$\n\\int_{\\Omega} p(x,y)\\,dx\\,dy = \\frac{1}{4}\\left[q(0,0) + q(1,0) + q(0,1) + q(1,1)\\right].\n$$\n\nWe can verify this by substituting $a$, $b$, $c$, and $d$:\n\n$$\na + \\frac{b}{2} + \\frac{c}{2} + \\frac{d}{4} = q(0,0) + \\frac{q(1,0) - q(0,0)}{2} + \\frac{q(0,1) - q(0,0)}{2} + \\frac{q(1,1) - q(1,0) - q(0,1) + q(0,0)}{4},\n$$\n\nwhich reduces to\n\n$$\n\\frac{1}{4}\\left[q(0,0) + q(1,0) + q(0,1) + q(1,1)\\right].\n$$\n\n\nStep 3: Apply to $q(x,y) = x^{2}$.\n\nEvaluate the corner values:\n\n$$\nq(0,0) = 0^{2} = 0, \\quad q(1,0) = 1^{2} = 1,\n$$\n\n\n$$\nq(0,1) = 0^{2} = 0, \\quad q(1,1) = 1^{2} = 1.\n$$\n\nThus,\n\n$$\na = 0, \\quad b = 1 - 0 = 1, \\quad c = 0 - 0 = 0, \\quad d = 1 - 1 - 0 + 0 = 0,\n$$\n\nand the interpolant is\n\n$$\np(x,y) = 0 + 1 \\cdot x + 0 \\cdot y + 0 \\cdot x y = x.\n$$\n\nIts domain integral is\n\n$$\n\\int_{\\Omega} p(x,y)\\,dx\\,dy = \\int_{0}^{1}\\int_{0}^{1} x\\,dx\\,dy = \\left(\\int_{0}^{1} x\\,dx\\right)\\left(\\int_{0}^{1} dy\\right) = \\frac{1}{2} \\cdot 1 = \\frac{1}{2}.\n$$\n\n\nStep 4: True global mass and change caused by interpolation.\n\nCompute the true global mass:\n\n$$\n\\int_{\\Omega} q(x,y)\\,dx\\,dy = \\int_{0}^{1}\\int_{0}^{1} x^{2}\\,dx\\,dy = \\left(\\int_{0}^{1} x^{2}\\,dx\\right)\\left(\\int_{0}^{1} dy\\right) = \\frac{1}{3} \\cdot 1 = \\frac{1}{3}.\n$$\n\nTherefore, the change in global mass due to bilinear interpolation is\n\n$$\n\\Delta M = \\int_{\\Omega} p(x,y)\\,dx\\,dy - \\int_{\\Omega} q(x,y)\\,dx\\,dy = \\frac{1}{2} - \\frac{1}{3} = \\frac{1}{6}.\n$$\n\nThis explicit counterexample shows that bilinear interpolation is not conservative: it alters the global integral of the tracer field unless the field is itself bilinear over the cell (in which case the bilinear interpolant reproduces the field exactly and does not change the integral). For the non-bilinear choice $q(x,y)=x^{2}$, the mass increases by $\\Delta M = \\frac{1}{6}$ under bilinear interpolation from corner samples.",
            "answer": "$$\\boxed{\\frac{1}{6}}$$"
        },
        {
            "introduction": "Having established that simple interpolation is not sufficient, the next logical step is to construct a method that is explicitly designed to be conservative. This exercise guides you through the derivation and implementation of a first-order conservative remapping scheme from fundamental principles of integral conservation . You will then move from theory to a crucial aspect of practice by designing a \"cycle test,\" a standard technique in numerical modeling to assess the long-term stability and error accumulation of remapping algorithms when subjected to repeated application under finite-precision arithmetic.",
            "id": "3871306",
            "problem": "A scalar quantity is exchanged between two components of an environmental system model through a coupling interface that remaps fields between distinct one-dimensional computational grids covering the closed interval $\\left[0,1\\right]$. Each grid $\\mathcal{G}$ is defined by a strictly increasing sequence of cell edges $\\left\\{x_0, x_1, \\dots, x_N\\right\\}$ with $x_0 = 0$ and $x_N = 1$, and represents the scalar by cell-averaged values $\\left\\{c_i\\right\\}_{i=0}^{N-1}$ that are piecewise constant over each cell $\\left[x_i, x_{i+1}\\right)$. The global integral of the scalar over the domain is the sum of cell integrals, which for grid $\\mathcal{G}$ is $\\sum_{i=0}^{N-1} c_i \\,\\Delta x_i$ with $\\Delta x_i = x_{i+1} - x_i$.\n\nThe coupling uses a remapping operation intended to be conservative: when remapping from a source grid $\\mathcal{G}_S$ with edges $\\left\\{x^S_i\\right\\}$ and cell-averages $\\left\\{c^S_i\\right\\}$ to a target grid $\\mathcal{G}_T$ with edges $\\left\\{x^T_j\\right\\}$, the target cell-averages $\\left\\{c^T_j\\right\\}$ must be constructed so that the global integral on $\\mathcal{G}_T$ equals the global integral on $\\mathcal{G}_S$. Starting from the conservation law for a passive scalar and the definition of a cell-average as an integral normalized by the cell width, derive from first principles a correct algorithmic procedure for building $\\left\\{c^T_j\\right\\}$ from $\\left\\{c^S_i\\right\\}$ and the grid geometries $\\left\\{x^S_i\\right\\}$ and $\\left\\{x^T_j\\right\\}$ without losing or creating mass over the domain. Your derivation must use only the following bases:\n- The integral of a piecewise constant function over an interval equals the constant value times the interval length.\n- Conservation across a partition: the integral over the whole domain equals the sum of integrals over any exact partition of the domain.\n- The definition of a cell-average: the average over a cell equals the integral of the field over the cell divided by the cell width.\n\nYou will then design and implement a cycle test that repeatedly remaps back and forth between two grids to quantify numerical drift in global integrals caused by finite-precision arithmetic. The cycle test starts with an initial grid $\\mathcal{G}_A$ and its cell-averages $\\left\\{c^A_i\\right\\}$, remaps to a second grid $\\mathcal{G}_B$ to get $\\left\\{c^B_j\\right\\}$, and then remaps back to $\\mathcal{G}_A$ to obtain a new set $\\left\\{c^{A,(1)}_i\\right\\}$. This back-and-forth sequence is repeated for $n$ cycles, producing $\\left\\{c^{A,(n)}_i\\right\\}$. Define the drift metric for the cycle test as the absolute difference between the global integral on $\\mathcal{G}_A$ after $n$ cycles and the initial global integral on $\\mathcal{G}_A$,\n$$\nD_n \\equiv \\left| \\sum_{i=0}^{N_A-1} c^{A,(n)}_i \\,\\Delta x^A_i \\;-\\; \\sum_{i=0}^{N_A-1} c^{A,(0)}_i \\,\\Delta x^A_i \\right|.\n$$\nYou must construct the initial cell-averages $\\left\\{c^{A,(0)}_i\\right\\}$ by exact analytic integration of a continuous scalar field $f(x)$ over each cell of $\\mathcal{G}_A$, divided by the cell width. Let\n$$\nf(x) \\;=\\; \\sin\\!\\left(2\\pi x\\right) \\;+\\; 0.3\\,\\cos\\!\\left(5\\pi x\\right) \\;+\\; 0.5\\,x,\n$$\nand use exact antiderivatives to compute cell-integrals. Express the final drift values as dimensionless decimals.\n\nImplement a complete, runnable program that:\n- Constructs grids from specified rules.\n- Computes initial cell-averages on $\\mathcal{G}_A$ by analytic integration of $f(x)$.\n- Performs conservative remapping between grids according to your derived procedure.\n- Executes the cycle test for each specified case and outputs the drift metric $D_n$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$). Each result must be a decimal number.\n\nUse the following test suite of parameter values to exercise different facets of the algorithm, including a general case, resolution mismatch, nonuniform geometry, identical grids as a boundary case, and severe resolution disparity. For each case, define grids $\\mathcal{G}_A$ and $\\mathcal{G}_B$ over $\\left[0,1\\right]$ and the number of cycles:\n- Case $1$: $\\mathcal{G}_A$ uniform with $N_A = 8$ cells, $\\mathcal{G}_B$ uniform with $N_B = 8$ cells, number of cycles $n = 10$.\n- Case $2$: $\\mathcal{G}_A$ uniform with $N_A = 10$ cells, $\\mathcal{G}_B$ uniform with $N_B = 12$ cells, number of cycles $n = 20$.\n- Case $3$: $\\mathcal{G}_A$ stretched nonuniform with $N_A = 64$ cells and edges $x^A_i = \\left(i/N_A\\right)^{1.7}$ for $i = 0,\\dots,64$, $\\mathcal{G}_B$ uniform with $N_B = 64$ cells, number of cycles $n = 50$.\n- Case $4$: $\\mathcal{G}_A$ uniform with $N_A = 32$ cells, $\\mathcal{G}_B$ identical to $\\mathcal{G}_A$, number of cycles $n = 100$.\n- Case $5$: $\\mathcal{G}_A$ uniform with $N_A = 5$ cells, $\\mathcal{G}_B$ uniform with $N_B = 200$ cells, number of cycles $n = 5$.\n\nYour program must compute and output the list $\\left[D_{n}^{(1)}, D_{n}^{(2)}, D_{n}^{(3)}, D_{n}^{(4)}, D_{n}^{(5)}\\right]$ in the exact single-line format described above. No angles or physical units are involved; results are dimensionless decimals.",
            "solution": "**1. Derivation of the Conservative Remapping Algorithm**\n\nThe objective is to compute a set of cell-average values $\\left\\{c^T_j\\right\\}$ on a target grid $\\mathcal{G}_T$ from a set of cell-average values $\\left\\{c^S_i\\right\\}$ on a source grid $\\mathcal{G}_S$, such that the global integral of the scalar quantity is conserved. The source field is a piecewise constant function $\\phi_S(x)$ which takes the value $c^S_i$ on the $i$-th cell interval $\\left[x^S_i, x^S_{i+1}\\right)$. The target field $\\phi_T(x)$ is similarly defined by values $c^T_j$ on cells $\\left[x^T_j, x^T_{j+1}\\right)$.\n\nGlobal conservation requires that the total integral on the target grid equals the total integral on the source grid:\n$$\n\\sum_{j=0}^{N_T-1} c^T_j \\Delta x^T_j = \\sum_{i=0}^{N_S-1} c^S_i \\Delta x^S_i\n$$\nwhere $\\Delta x^T_j = x^T_{j+1} - x^T_j$ and $\\Delta x^S_i = x^S_{i+1} - x^S_i$ are the respective cell widths.\n\nWe derive the formula for an individual target cell-average, $c^T_j$, based on the provided principles.\nFirst, by the definition of a cell-average, the value $c^T_j$ is the total amount (integral) of the scalar in the cell $\\left[x^T_j, x^T_{j+1}\\right)$, which we denote as $M^T_j$, divided by the cell's width $\\Delta x^T_j$:\n$$\nc^T_j = \\frac{M^T_j}{\\Delta x^T_j} = \\frac{1}{\\Delta x^T_j} \\int_{x^T_j}^{x^T_{j+1}} \\phi_T(x) \\, dx\n$$\nThe core principle of conservative remapping is that the mass in a target cell is determined by integrating the *source* field $\\phi_S(x)$ over the target cell's spatial interval.\n$$\nM^T_j = \\int_{x^T_j}^{x^T_{j+1}} \\phi_S(x) \\, dx\n$$\nSince the source grid $\\mathcal{G}_S$ forms an exact partition of the domain $\\left[0,1\\right]$, we can decompose the integral over the target cell interval $\\left[x^T_j, x^T_{j+1}\\right)$ into a sum of integrals over the regions where it intersects with each source cell $\\left[x^S_i, x^S_{i+1}\\right)$.\n$$\nM^T_j = \\sum_{i=0}^{N_S-1} \\int_{\\left[x^T_j, x^T_{j+1}\\right) \\cap \\left[x^S_i, x^S_{i+1}\\right)} \\phi_S(x) \\, dx\n$$\nWithin any non-empty intersection interval, the source field $\\phi_S(x)$ is constant and equal to $c^S_i$. Based on the principle that the integral of a constant is the constant times the interval length, the integral over the intersection becomes:\n$$\n\\int_{\\left[x^T_j, x^T_{j+1}\\right) \\cap \\left[x^S_i, x^S_{i+1}\\right)} c^S_i \\, dx = c^S_i \\cdot \\text{length}\\left(\\left[x^T_j, x^T_{j+1}\\right) \\cap \\left[x^S_i, x^S_{i+1}\\right)\\right)\n$$\nLet $\\Delta x_{ij}^{\\text{overlap}}$ denote the length of the intersection of source cell $i$ and target cell $j$. This length is given by:\n$$\n\\Delta x_{ij}^{\\text{overlap}} = \\max\\left(0, \\min\\left(x^S_{i+1}, x^T_{j+1}\\right) - \\max\\left(x^S_i, x^T_j\\right)\\right)\n$$\nSubstituting this into the expression for $M^T_j$, we obtain the total mass in target cell $j$ as a weighted sum of source cell values, where the weights are the overlap lengths:\n$$\nM^T_j = \\sum_{i=0}^{N_S-1} c^S_i \\, \\Delta x_{ij}^{\\text{overlap}}\n$$\nFinally, we obtain the expression for the target cell-average $c^T_j$ by dividing by the target cell width $\\Delta x^T_j$:\n$$\nc^T_j = \\frac{1}{\\Delta x^T_j} \\sum_{i=0}^{N_S-1} c^S_i \\, \\max\\left(0, \\min\\left(x^S_{i+1}, x^T_{j+1}\\right) - \\max\\left(x^S_i, x^T_j\\right)\\right)\n$$\nThis is the derived first-order conservative remapping algorithm. It explicitly guarantees that the remapped field conserves the scalar quantity in exact arithmetic. Any deviation from conservation in a practical implementation arises from finite-precision floating-point arithmetic, which is the subject of the cycle test.\n\n**2. Algorithmic Design for the Cycle Test**\n\nThe cycle test is implemented as follows:\nFirst, for each test case, the source grid $\\mathcal{G}_A$ and target grid $\\mathcal{G}_B$ are constructed according to the specified rules (uniform or stretched).\n\nNext, the initial cell-averages on grid $\\mathcal{G}_A$, denoted $\\left\\{c^{A,(0)}_i\\right\\}$, are computed. This is done by analytically integrating the specified continuous scalar field $f(x)$ over each cell of $\\mathcal{G}_A$. The function is:\n$$\nf(x) = \\sin(2\\pi x) + 0.3\\,\\cos(5\\pi x) + 0.5\\,x\n$$\nIts exact antiderivative $F(x)$ is:\n$$\nF(x) = -\\frac{1}{2\\pi}\\cos(2\\pi x) + \\frac{0.3}{5\\pi}\\sin(5\\pi x) + \\frac{1}{4}x^2\n$$\nThe integral over a cell $\\left[x^A_i, x^A_{i+1}\\right)$ is $F(x^A_{i+1}) - F(x^A_i)$. The initial cell-average is therefore:\n$$\nc^{A,(0)}_i = \\frac{F(x^A_{i+1}) - F(x^A_i)}{x^A_{i+1} - x^A_i}\n$$\nThe initial global integral on $\\mathcal{G}_A$ is calculated as $I^{A,(0)} = \\sum_{i=0}^{N_A-1} c^{A,(0)}_i \\Delta x^A_i$.\n\nThe cycle test then proceeds for a specified number of cycles, $n$. In each cycle $k$ (from $0$ to $n-1$):\n1.  The field is remapped from $\\mathcal{G}_A$ to $\\mathcal{G}_B$: $\\left\\{c^B_j\\right\\} = \\text{Remap}\\left(\\left\\{c^{A,(k)}_i\\right\\}, \\mathcal{G}_A, \\mathcal{G}_B\\right)$.\n2.  The field is remapped back from $\\mathcal{G}_B$ to $\\mathcal{G}_A$: $\\left\\{c^{A,(k+1)}_i\\right\\} = \\text{Remap}\\left(\\left\\{c^B_j\\right\\}, \\mathcal{G}_B, \\mathcal{G}_A\\right)$.\nThe `Remap` function implements the formula derived in the previous section.\n\nAfter $n$ cycles, the final field $\\left\\{c^{A,(n)}_i\\right\\}$ is obtained. The final global integral is calculated as $I^{A,(n)} = \\sum_{i=0}^{N_A-1} c^{A,(n)}_i \\Delta x^A_i$.\n\nFinally, the drift metric $D_n$ is computed as the absolute difference between the final and initial global integrals:\n$$\nD_n = \\left| I^{A,(n)} - I^{A,(0)} \\right|\n$$\nThis process is repeated for each of the five test cases defined in the problem statement. The resulting values of $D_n$ are collected and presented in the required format. The implementation uses double-precision floating-point numbers (`float64`) for all calculations to minimize round-off errors, although the problem is designed to reveal their cumulative effect.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to derive, implement, and test a conservative remapping algorithm.\n    \"\"\"\n\n    def F(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the exact antiderivative of the function f(x).\n        f(x) = sin(2*pi*x) + 0.3*cos(5*pi*x) + 0.5*x\n        F(x) = -1/(2*pi)*cos(2*pi*x) + 0.3/(5*pi)*sin(5*pi*x) + 0.25*x**2\n        \"\"\"\n        term1 = -1.0 / (2.0 * np.pi) * np.cos(2.0 * np.pi * x)\n        term2 = 0.3 / (5.0 * np.pi) * np.sin(5.0 * np.pi * x)\n        term3 = 0.25 * x**2\n        return term1 + term2 + term3\n\n    def make_grid(N: int, grid_type: str = 'uniform', power: float = 1.0) -> np.ndarray:\n        \"\"\"\n        Constructs a grid with N cells on the interval [0, 1].\n        Returns an array of N+1 cell edges.\n        \"\"\"\n        if grid_type == 'uniform':\n            return np.linspace(0.0, 1.0, N + 1, dtype=np.float64)\n        elif grid_type == 'stretched':\n            base = np.arange(N + 1, dtype=np.float64) / N\n            return np.power(base, power)\n        else:\n            raise ValueError(f\"Unknown grid type: {grid_type}\")\n\n    def remap(c_source: np.ndarray, grid_source: np.ndarray, grid_target: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Performs first-order conservative remapping from a source to a target grid.\n        \n        Args:\n            c_source: Array of cell-average values on the source grid.\n            grid_source: Array of source grid cell edges.\n            grid_target: Array of target grid cell edges.\n        \n        Returns:\n            Array of cell-average values on the target grid.\n        \"\"\"\n        n_source_cells = len(c_source)\n        n_target_cells = len(grid_target) - 1\n        \n        c_target = np.zeros(n_target_cells, dtype=np.float64)\n        delta_x_target = np.diff(grid_target)\n\n        for j in range(n_target_cells):\n            target_cell_start = grid_target[j]\n            target_cell_end = grid_target[j+1]\n            \n            total_mass_in_target_cell = 0.0\n            \n            for i in range(n_source_cells):\n                source_cell_start = grid_source[i]\n                source_cell_end = grid_source[i+1]\n                \n                # Calculate the length of the intersection interval\n                overlap_length = max(0.0, min(source_cell_end, target_cell_end) - max(source_cell_start, target_cell_start))\n                \n                if overlap_length > 0.0:\n                    total_mass_in_target_cell += c_source[i] * overlap_length\n            \n            if delta_x_target[j] > 1e-15: # Avoid division by zero\n                c_target[j] = total_mass_in_target_cell / delta_x_target[j]\n        \n        return c_target\n\n    test_cases = [\n        {'NA': 8, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 8, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 10},\n        {'NA': 10, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 12, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 20},\n        {'NA': 64, 'grid_A_type': 'stretched', 'power_A': 1.7, 'NB': 64, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 50},\n        {'NA': 32, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 32, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 100},\n        {'NA': 5, 'grid_A_type': 'uniform', 'power_A': 1.0, 'NB': 200, 'grid_B_type': 'uniform', 'power_B': 1.0, 'n_cycles': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Construct grids\n        grid_A = make_grid(case['NA'], case['grid_A_type'], case['power_A'])\n        grid_B = make_grid(case['NB'], case['grid_B_type'], case['power_B'])\n        \n        # 2. Compute initial cell-averages on grid A\n        delta_x_A = np.diff(grid_A)\n        cell_integrals_A_0 = F(grid_A[1:]) - F(grid_A[:-1])\n        c_A_0 = cell_integrals_A_0 / delta_x_A\n        \n        # 3. Calculate initial global integral\n        initial_global_integral = np.sum(c_A_0 * delta_x_A)\n        \n        # 4. Perform cycle test\n        c_A_current = c_A_0.copy()\n        for _ in range(case['n_cycles']):\n            c_B = remap(c_A_current, grid_A, grid_B)\n            c_A_current = remap(c_B, grid_B, grid_A)\n            \n        # 5. Calculate final global integral and drift metric\n        final_global_integral = np.sum(c_A_current * delta_x_A)\n        drift = abs(final_global_integral - initial_global_integral)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.17g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice synthesizes the principles from the previous exercises and applies them to a realistic, multi-stage coupling problem: routing freshwater runoff from a land model to an ocean model. In Earth system models, ensuring that the total volume of water generated on land precisely matches the total volume delivered to the ocean is critical for preventing long-term drift in global sea level and salinity. This exercise requires you to construct a complex, two-stage conservative mapping that involves careful normalization of routing weights and handling of real-world constraints like land-ocean masks, demonstrating how the fundamental principle of conservation is upheld in operational scientific software .",
            "id": "3871305",
            "problem": "Consider a coupled landâ€“ocean model where land surface runoff is routed through a river network to an ocean model grid. The fundamental base is the conservation of mass for water at the global scale: the integral of terrestrial runoff delivered to the ocean must equal the total oceanic inflow evaluated at river mouths. Formally, for a set of land grid cells indexed by $i \\in \\{1,\\dots,L\\}$ with runoff flux $r_i$ (in $\\mathrm{m\\,s^{-1}}$) and area $A_i$ (in $\\mathrm{m^2}$), the volumetric source per land cell is $Q_i = r_i A_i$ (in $\\mathrm{m^3\\,s^{-1}}$). Let there be river mouths indexed by $k \\in \\{1,\\dots,K\\}$ and ocean grid cells indexed by $j \\in \\{1,\\dots,O\\}$.\n\nA river routing scheme is specified by two discrete mappings:\n- A land-to-mouth fractional routing matrix $R \\in \\mathbb{R}^{K \\times L}$ with entries $R_{k i} \\ge 0$ representing the fraction of $Q_i$ routed to mouth $k$. Columns of $R$ may not initially sum to $1$ and must be normalized to ensure conservation at the land-to-mouth stage.\n- A mouth-to-ocean candidate weight specification given, for each mouth $k$, as a list of ocean cell candidates and nonnegative unnormalized weights $\\{(j, w_{j k})\\}$ with $w_{j k} \\ge 0$. An ocean mask identifies which ocean cells are wet (valid). For each mouth, valid candidates must be normalized over wet ocean cells to define a distribution $\\tilde{w}_{j k}$ that satisfies $\\sum_{j=1}^{O} \\tilde{w}_{j k} = 1$.\n\nThe goal is to construct a discrete mapping $M \\in \\mathbb{R}^{O \\times L}$ from land cells to ocean cells such that the routed ocean discharges $D_j$ (in $\\mathrm{m^3\\,s^{-1}}$) satisfy\n$$\nD_j = \\sum_{i=1}^{L} M_{j i} Q_i,\n$$\nand the global conservation condition\n$$\n\\sum_{j=1}^{O} D_j = \\sum_{i=1}^{L} Q_i\n$$\nholds exactly in the discrete system up to numerical precision. The mapping must be derived from the normalized $R$ and normalized $\\tilde{w}_{j k}$ by\n$$\nM_{j i} = \\sum_{k=1}^{K} \\tilde{w}_{j k}\\, \\bar{R}_{k i},\n$$\nwhere $\\bar{R}$ is the column-normalized version of $R$ defined by\n$$\n\\bar{R}_{k i} =\n\\begin{cases}\n\\displaystyle \\frac{R_{k i}}{\\sum_{k'=1}^{K} R_{k' i}}, & \\text{if } \\sum_{k'=1}^{K} R_{k' i} > 0, \\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\nTo construct $\\tilde{w}_{j k}$ from unnormalized weights $w_{j k}$ and an ocean mask, use only candidates $(j, w_{j k})$ where cell $j$ is wet. For each mouth $k$ with at least one valid candidate, define\n$$\n\\tilde{w}_{j k} = \\frac{w_{j k}}{\\sum_{j' \\text{ valid}} w_{j' k}} \\quad \\text{over valid candidates}.\n$$\nIf a mouth $k$ has no valid candidates, a fallback rule must assign all of its discharge to the smallest-indexed wet ocean cell $j^\\star$, so that $\\tilde{w}_{j^\\star k} = 1$ and $\\tilde{w}_{j k} = 0$ for $j \\ne j^\\star$. If there are no wet ocean cells, the mapping cannot be constructed; such a case will not appear in the test suite.\n\nUsing the above framework and starting from conservation of mass and discrete normalization principles, implement a program that:\n1. Normalizes $R$ by columns to obtain $\\bar{R}$.\n2. Normalizes mouth-to-ocean weights over wet ocean cells to obtain $\\tilde{w}_{j k}$, using the fallback rule when needed.\n3. Constructs $M$ via $M_{j i} = \\sum_{k=1}^{K} \\tilde{w}_{j k}\\, \\bar{R}_{k i}$.\n4. Computes $Q_i = r_i A_i$ and $D_j = \\sum_{i=1}^{L} M_{j i} Q_i$.\n5. Returns, for each test case, a boolean indicating whether $\\left|\\sum_{j=1}^{O} D_j - \\sum_{i=1}^{L} Q_i\\right| \\le \\varepsilon$ with absolute tolerance $\\varepsilon = 10^{-6}$ (in $\\mathrm{m^3\\,s^{-1}}$).\n\nExpress all discharges in $\\mathrm{m^3\\,s^{-1}}$. Use radians or degrees only if angles are involved; in this problem, no angles are used.\n\nTest Suite:\nProvide four test cases with explicit parameters:\n\n- Test case $1$ (general happy path):\n    - Land cells $L = 4$ with areas $A = [1.0 \\times 10^{10}, 0.8 \\times 10^{10}, 1.2 \\times 10^{10}, 0.5 \\times 10^{10}]$ and runoff fluxes $r = [1.0 \\times 10^{-8}, 3.0 \\times 10^{-8}, 2.0 \\times 10^{-8}, 0.0]$.\n    - River mouths $K = 2$ with land-to-mouth routing matrix\n      $$\n      R = \\begin{bmatrix}\n      1.0 & 1.0 & 0.0 & 0.6 \\\\\n      0.0 & 0.0 & 1.0 & 0.4\n      \\end{bmatrix}.\n      $$\n    - Ocean cells $O = 3$ with wet mask $\\text{mask} = [\\text{True}, \\text{True}, \\text{True}]$.\n    - Mouth-to-ocean candidates:\n        - Mouth $1$: $\\{(0, 2.0), (1, 1.0)\\}$.\n        - Mouth $2$: $\\{(1, 1.0), (2, 3.0)\\}$.\n\n- Test case $2$ (mask-induced renormalization):\n    - Same $L$, $A$, and $R$ as in test case $1$.\n    - Runoff fluxes $r = [2.0 \\times 10^{-8}, 0.0, 5.0 \\times 10^{-9}, 1.0 \\times 10^{-9}]$.\n    - Ocean cells $O = 3$ with wet mask $\\text{mask} = [\\text{True}, \\text{True}, \\text{False}]$.\n    - Mouth-to-ocean candidates:\n        - Mouth $1$: $\\{(0, 2.0), (1, 1.0)\\}$.\n        - Mouth $2$: $\\{(1, 1.0), (2, 3.0)\\}$, where ocean cell $2$ is dry and must be excluded, leaving mouth $2$ to normalize over the remaining valid candidate.\n\n- Test case $3$ (fallback when no valid candidates for a mouth):\n    - Same $L$ and $R$ as in test case $1$, with areas $A = [1.0 \\times 10^{10}, 0.8 \\times 10^{10}, 1.2 \\times 10^{10}, 0.5 \\times 10^{10}]$ and runoff fluxes $r = [1.0 \\times 10^{-8}, 2.0 \\times 10^{-8}, 1.0 \\times 10^{-8}, 3.0 \\times 10^{-9}]$.\n    - Ocean cells $O = 3$ with wet mask $\\text{mask} = [\\text{False}, \\text{True}, \\text{False}]$, so only ocean cell $1$ (index $1$) is wet.\n    - Mouth-to-ocean candidates:\n        - Mouth $1$: $\\{(0, 1.0), (2, 1.0)\\}$, both invalid due to the mask, triggering the fallback to the smallest-index wet cell.\n        - Mouth $2$: $\\{(1, 1.0)\\}$, valid.\n\n- Test case $4$ (boundary case with zero runoff):\n    - Land cells $L = 3$ with areas $A = [1.0 \\times 10^{6}, 2.0 \\times 10^{6}, 3.0 \\times 10^{6}]$ and runoff fluxes $r = [0.0, 0.0, 0.0]$.\n    - River mouths $K = 1$ with land-to-mouth routing matrix\n      $$\n      R = \\begin{bmatrix}\n      1.0 & 1.0 & 1.0\n      \\end{bmatrix}.\n      $$\n    - Ocean cells $O = 2$ with wet mask $\\text{mask} = [\\text{True}, \\text{True}]$.\n    - Mouth-to-ocean candidates:\n        - Mouth $1$: $\\{(0, 1.0), (1, 1.0)\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each entry is a boolean indicating whether global conservation holds within the absolute tolerance $\\varepsilon = 10^{-6}$ (in $\\mathrm{m^3\\,s^{-1}}$) for the corresponding test case.",
            "solution": "The solution requires implementing a two-stage conservative routing scheme. The conservation property is guaranteed analytically if each stage of the mapping is properly normalized, and the numerical implementation should verify this. The process is as follows:\n\n1.  **Compute Volumetric Source Term**: The total runoff volume from the land, which must be conserved, is calculated. For each land cell $i$, the volumetric source is $Q_i = r_i A_i$. The total source is $\\sum_i Q_i$.\n\n2.  **Normalize Land-to-Mouth Matrix ($R \\to \\bar{R}$)**: The first stage routes water from land cells to river mouths. To ensure no water is lost or created in this step, the routing matrix $R$ is normalized column-wise. For each land cell (column) $i$, the sum of fractions of its runoff going to all mouths must equal 1. This is achieved by dividing each element $R_{ki}$ by its column sum $\\sum_{k'} R_{k'i}$. If a column sum is zero (i.e., the land cell's runoff is not routed anywhere), its entries in the normalized matrix $\\bar{R}$ remain zero.\n\n3.  **Normalize Mouth-to-Ocean Weights ($w \\to \\tilde{w}$)**: The second stage distributes water from river mouths to ocean cells. This requires constructing a normalized weight matrix, which we can call $\\tilde{W}$ (of size $O \\times K$), from the candidate weights $w_{jk}$ and the ocean mask. For each mouth $k$ (column), the normalization is performed over the subset of its candidate ocean cells that are \"wet\" (i.e., `mask[j]` is True).\n    - If a mouth has one or more valid (wet) candidates, their weights are summed, and each valid candidate's weight is divided by this sum. All weights for invalid (dry) candidates become zero.\n    - If a mouth has no valid candidates, the fallback rule is applied: its entire discharge is routed to the single smallest-indexed wet ocean cell, $j^\\star$. This means $\\tilde{w}_{j^\\star k} = 1$, and all other $\\tilde{w}_{jk}$ for that mouth are zero.\n    This two-part rule ensures that for every mouth $k$, its column in the $\\tilde{W}$ matrix sums to 1.\n\n4.  **Construct Global Mapping Matrix ($M$):** The end-to-end mapping matrix $M$ is the product of the two normalized stage matrices: $M = \\tilde{W} \\cdot \\bar{R}$. This matrix multiplication combines the land-to-mouth and mouth-to-ocean distributions into a single land-to-ocean mapping.\n\n5.  **Compute Ocean Discharges and Verify Conservation**: The final discharge into each ocean cell is computed by applying the mapping to the source vector: $D = M \\cdot Q$. The global conservation check is then performed by comparing the total land source, $\\sum_i Q_i$, with the total ocean sink, $\\sum_j D_j$. Due to the normalization at each step, these two sums should be equal up to floating-point precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general happy path)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([1.0e-8, 3.0e-8, 2.0e-8, 0.0]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([True, True, True]),\n            'mouth_candidates': [\n                [(0, 2.0), (1, 1.0)],  # Mouth 1 (k=0)\n                [(1, 1.0), (2, 3.0)]   # Mouth 2 (k=1)\n            ]\n        },\n        # Test case 2 (mask-induced renormalization)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([2.0e-8, 0.0, 5.0e-9, 1.0e-9]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([True, True, False]),\n            'mouth_candidates': [\n                [(0, 2.0), (1, 1.0)],\n                [(1, 1.0), (2, 3.0)]\n            ]\n        },\n        # Test case 3 (fallback when no valid candidates for a mouth)\n        {\n            'L': 4, 'K': 2, 'O': 3,\n            'A': np.array([1.0e10, 0.8e10, 1.2e10, 0.5e10]),\n            'r': np.array([1.0e-8, 2.0e-8, 1.0e-8, 3.0e-9]),\n            'R': np.array([[1.0, 1.0, 0.0, 0.6], [0.0, 0.0, 1.0, 0.4]]),\n            'mask': np.array([False, True, False]),\n            'mouth_candidates': [\n                [(0, 1.0), (2, 1.0)],\n                [(1, 1.0)]\n            ]\n        },\n        # Test case 4 (boundary case with zero runoff)\n        {\n            'L': 3, 'K': 1, 'O': 2,\n            'A': np.array([1.0e6, 2.0e6, 3.0e6]),\n            'r': np.array([0.0, 0.0, 0.0]),\n            'R': np.array([[1.0, 1.0, 1.0]]),\n            'mask': np.array([True, True]),\n            'mouth_candidates': [\n                [(0, 1.0), (1, 1.0)]\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\ndef _process_case(case_data):\n    \"\"\"\n    Processes a single test case for conservation validation.\n    \n    Args:\n        case_data (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        bool: True if mass is conserved within the tolerance, False otherwise.\n    \"\"\"\n    # Extract parameters from the case data\n    L, K, O = case_data['L'], case_data['K'], case_data['O']\n    A, r, R, mask, mouth_cands = (case_data['A'], case_data['r'], case_data['R'],\n                                   case_data['mask'], case_data['mouth_candidates'])\n    epsilon = 1e-6\n\n    # 1. Compute volumetric source Q from land cells\n    Q = r * A\n    total_Q = np.sum(Q)\n\n    # 2. Normalize the land-to-mouth routing matrix R to get R_bar\n    R_bar = np.zeros_like(R, dtype=float)\n    col_sums = np.sum(R, axis=0)\n    # Use boolean indexing to avoid division by zero\n    non_zero_cols_mask = col_sums > 0\n    R_bar[:, non_zero_cols_mask] = R[:, non_zero_cols_mask] / col_sums[non_zero_cols_mask]\n\n    # 3. Construct the normalized mouth-to-ocean weight matrix W_tilde\n    W_tilde = np.zeros((O, K), dtype=float)\n    wet_ocean_indices = np.where(mask)[0]\n    # Smallest-indexed wet ocean cell for fallback rule\n    # The problem guarantees at least one wet cell.\n    j_star = wet_ocean_indices[0]\n\n    for k in range(K):\n        candidates = mouth_cands[k]\n        valid_candidates = [(j, w) for j, w in candidates if mask[j]]\n\n        if not valid_candidates:\n            # Fallback rule: No valid candidates, assign all to j_star\n            W_tilde[j_star, k] = 1.0\n        else:\n            # Normalization over valid candidates\n            valid_weights = np.array([w for j, w in valid_candidates])\n            weight_sum = np.sum(valid_weights)\n\n            if weight_sum > 0:\n                for i, (j, w) in enumerate(valid_candidates):\n                    W_tilde[j, k] = valid_weights[i] / weight_sum\n            # If weight_sum is 0, W_tilde[:, k] remains 0. This violates conservation\n            # sum(W_tilde[:,k])=1. The problem assumes this won't happen for valid cands.\n\n    # 4. Construct the land-to-ocean mapping matrix M\n    # M_ji = sum_k(W_tilde_jk * R_bar_ki) -> M = W_tilde @ R_bar\n    M = W_tilde @ R_bar\n\n    # 5. Compute ocean discharge D for each ocean cell\n    # D_j = sum_i(M_ji * Q_i) -> D = M @ Q\n    D = M @ Q\n    total_D = np.sum(D)\n\n    # 6. Verify global conservation within the absolute tolerance\n    return abs(total_D - total_Q) <= epsilon\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}