{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a foundational application of the concepts we've discussed. You will calculate the buoyancy frequency, $N^2$, directly from idealized analytical profiles representing a polar halocline. This practice solidifies the mathematical connection between temperature and salinity gradients and the resulting fluid stability, and introduces the interpretation of these gradients in the context of double-diffusive processes. ",
            "id": "3918365",
            "problem": "Consider a vertically stratified polar ocean halocline occupying depths $z \\in [0, 200]$ with $z$ measured positive downward (oceanographic depth coordinate). Assume a hydrostatic, inviscid, Boussinesq fluid with a linearized equation of state for seawater density,\n$$\n\\rho(z) = \\rho_{0} \\left[ 1 - \\alpha \\left( T(z) - T_{0} \\right) + \\beta \\left( S(z) - S_{0} \\right) \\right],\n$$\nwhere $\\rho_{0}$ is a constant reference density, $\\alpha$ is the thermal expansion coefficient, and $\\beta$ is the haline contraction coefficient. Treat Practical Salinity ($\\mathrm{psu}$) as dimensionless in this linearization. Let gravitational acceleration be $g = 9.81$ $\\mathrm{m\\,s^{-2}}$. Take $\\alpha = 2.0 \\times 10^{-4}$ $\\mathrm{K^{-1}}$ and $\\beta = 7.6 \\times 10^{-4}$ (per salinity unit).\n\nObserved temperature and salinity profiles are given by smooth transition functions representative of a halocline overlying a warmer, saltier Atlantic layer:\n$$\nS(z) = S_{s} + \\frac{\\Delta S}{2} \\left[ 1 + \\tanh\\!\\left( \\frac{z - z_{h}}{h} \\right) \\right],\n\\quad\nT(z) = T_{s} + \\frac{\\Delta T}{2} \\left[ 1 + \\tanh\\!\\left( \\frac{z - z_{t}}{H_{t}} \\right) \\right],\n$$\nwith parameters $S_{s} = 31.0$, $\\Delta S = 3.8$, $z_{h} = 60$, $h = 40$, $T_{s} = -1.8$, $\\Delta T = 2.3$, $z_{t} = 100$, and $H_{t} = 30$, where all numbers are in consistent SI units except temperature in degrees Celsius and salinity in Practical Salinity units.\n\nStarting from hydrostatic balance and the linearized equation of state above, derive the vertical buoyancy-restoring frequency squared $N^{2}(z)$ (also called the Brunt–Väisälä frequency squared) in terms of the vertical gradients of $T(z)$ and $S(z)$ for the specified sign convention ($z$ positive downward). Then evaluate $N^{2}$ at $z = 60$ and express the result in $\\mathrm{s^{-2}}$.\n\nIn addition, using the same local gradients at $z = 60$, assess the susceptibility of the water column to salt-finger type double-diffusive instability in a brief discussion (no calculation required in the final answer). Base your assessment on the signs and relative magnitudes of the thermal and haline stratifications in the chosen coordinate convention.\n\nRound the final numerical value of $N^{2}(60)$ to four significant figures. Express the final answer in $\\mathrm{s^{-2}}$.",
            "solution": "We begin from hydrostatic balance for a stably stratified Boussinesq fluid with the oceanographic depth coordinate $z$ taken positive downward. Hydrostatic balance states\n$$\n\\frac{d p}{d z} = \\rho(z) \\, g,\n$$\nand small vertical displacements $\\xi$ of fluid parcels relative to the background stratification yield a linear restoring acceleration determined by the local density gradient. Consider displacing a parcel from $z$ to $z + \\xi$. In the Boussinesq approximation, the parcel retains its density $\\rho(z)$, while the environment at $z + \\xi$ has density $\\rho(z + \\xi) \\approx \\rho(z) + \\xi \\, \\frac{d \\rho}{d z}$. The resulting buoyancy acceleration is proportional to the density difference:\n$$\na = - g \\, \\frac{\\rho(z + \\xi) - \\rho(z)}{\\rho_{0}} \\approx - g \\, \\frac{\\xi}{\\rho_{0}} \\, \\frac{d \\rho}{d z}.\n$$\nHence the linearized equation of motion for the displacement is\n$$\n\\frac{d^{2} \\xi}{d t^{2}} = - \\frac{g}{\\rho_{0}} \\frac{d \\rho}{d z} \\, \\xi,\n$$\nwhich identifies the buoyancy frequency squared (Brunt–Väisälä frequency squared) as\n$$\nN^{2}(z) = \\frac{g}{\\rho_{0}} \\frac{d \\rho}{d z}.\n$$\nThis expression is appropriate for $z$ positive downward: stable stratification has $\\frac{d \\rho}{d z}  0$, giving $N^{2}  0$.\n\nNext, we use the linearized equation of state\n$$\n\\rho(z) = \\rho_{0} \\left[ 1 - \\alpha \\left( T(z) - T_{0} \\right) + \\beta \\left( S(z) - S_{0} \\right) \\right]\n$$\nto obtain the density gradient\n$$\n\\frac{d \\rho}{d z} = \\rho_{0} \\left[ - \\alpha \\, \\frac{d T}{d z} + \\beta \\, \\frac{d S}{d z} \\right].\n$$\nSubstituting into the expression for $N^{2}(z)$ gives\n$$\nN^{2}(z) = g \\left[ - \\alpha \\, \\frac{d T}{d z} + \\beta \\, \\frac{d S}{d z} \\right].\n$$\n\nWe now compute the required vertical gradients at $z = 60$. The given profiles are\n$$\nS(z) = S_{s} + \\frac{\\Delta S}{2} \\left[ 1 + \\tanh\\!\\left( \\frac{z - z_{h}}{h} \\right) \\right], \\quad\nT(z) = T_{s} + \\frac{\\Delta T}{2} \\left[ 1 + \\tanh\\!\\left( \\frac{z - z_{t}}{H_{t}} \\right) \\right].\n$$\nTheir derivatives are\n$$\n\\frac{d S}{d z} = \\frac{\\Delta S}{2 h} \\, \\operatorname{sech}^{2}\\!\\left( \\frac{z - z_{h}}{h} \\right), \\quad\n\\frac{d T}{d z} = \\frac{\\Delta T}{2 H_{t}} \\, \\operatorname{sech}^{2}\\!\\left( \\frac{z - z_{t}}{H_{t}} \\right),\n$$\nwhere $\\operatorname{sech}(x) = 1 / \\cosh(x)$ and $\\frac{d}{d x} \\tanh(x) = \\operatorname{sech}^{2}(x)$.\n\nAt $z = 60$, with the parameters $z_{h} = 60$ and $h = 40$, we have\n$$\n\\frac{z - z_{h}}{h} = \\frac{60 - 60}{40} = 0, \\quad \\operatorname{sech}^{2}(0) = 1,\n$$\nso\n$$\n\\frac{d S}{d z}\\bigg|_{z=60} = \\frac{\\Delta S}{2 h} = \\frac{3.8}{2 \\times 40} = \\frac{3.8}{80} = 0.0475.\n$$\nFor temperature, with $z_{t} = 100$ and $H_{t} = 30$,\n$$\n\\frac{z - z_{t}}{H_{t}} = \\frac{60 - 100}{30} = - \\frac{40}{30} = - \\frac{4}{3},\n$$\nand thus\n$$\n\\operatorname{sech}^{2}\\!\\left( - \\frac{4}{3} \\right) = \\operatorname{sech}^{2}\\!\\left( \\frac{4}{3} \\right) = \\frac{1}{\\cosh^{2}\\!\\left( \\frac{4}{3} \\right)}.\n$$\nCompute $\\cosh\\!\\left( \\frac{4}{3} \\right) = \\frac{\\exp\\!\\left( \\frac{4}{3} \\right) + \\exp\\!\\left( - \\frac{4}{3} \\right)}{2}$. Using $\\exp\\!\\left( \\frac{4}{3} \\right) \\approx 3.793668$ and $\\exp\\!\\left( - \\frac{4}{3} \\right) \\approx 0.263597$, we find\n$$\n\\cosh\\!\\left( \\frac{4}{3} \\right) \\approx \\frac{3.793668 + 0.263597}{2} \\approx 2.028633, \\quad\n\\operatorname{sech}^{2}\\!\\left( \\frac{4}{3} \\right) \\approx \\frac{1}{(2.028633)^{2}} \\approx 0.242973.\n$$\nTherefore,\n$$\n\\frac{d T}{d z}\\bigg|_{z=60} = \\frac{\\Delta T}{2 H_{t}} \\, \\operatorname{sech}^{2}\\!\\left( \\frac{4}{3} \\right)\n= \\frac{2.3}{2 \\times 30} \\times 0.242973\n= \\frac{2.3}{60} \\times 0.242973\n\\approx 0.0383333 \\times 0.242973\n\\approx 0.00931396.\n$$\n\nNow evaluate $N^{2}(60)$:\n$$\nN^{2}(60) = g \\left[ - \\alpha \\, \\frac{d T}{d z}\\bigg|_{z=60} + \\beta \\, \\frac{d S}{d z}\\bigg|_{z=60} \\right]\n= 9.81 \\left[ - (2.0 \\times 10^{-4}) \\times 0.00931396 + (7.6 \\times 10^{-4}) \\times 0.0475 \\right].\n$$\nCompute the bracketed term:\n$$\n- \\alpha \\, \\frac{d T}{d z}\\bigg|_{z=60} \\approx - 2.0 \\times 10^{-4} \\times 0.00931396 \\approx - 1.86279 \\times 10^{-6},\n$$\n$$\n\\beta \\, \\frac{d S}{d z}\\bigg|_{z=60} \\approx 7.6 \\times 10^{-4} \\times 0.0475 = 3.61000 \\times 10^{-5},\n$$\nso\n$$\n\\left[ - \\alpha \\, \\frac{d T}{d z} + \\beta \\, \\frac{d S}{d z} \\right]_{z=60} \\approx 3.61000 \\times 10^{-5} - 1.86279 \\times 10^{-6} = 3.42372 \\times 10^{-5}.\n$$\nFinally,\n$$\nN^{2}(60) \\approx 9.81 \\times 3.42372 \\times 10^{-5} \\approx 3.35865 \\times 10^{-4} \\ \\mathrm{s^{-2}}.\n$$\nRounded to four significant figures, this is\n$$\nN^{2}(60) \\approx 3.359 \\times 10^{-4} \\ \\mathrm{s^{-2}}.\n$$\n\nSalt-finger susceptibility assessment at $z = 60$: Salt-finger double-diffusive instability typically requires a statically stable density stratification where salinity is destabilizing (saltier water over fresher water, i.e., $\\frac{d S}{d z}  0$ in the $z$ positive downward convention) while temperature is stabilizing (warmer water over colder water, i.e., $\\frac{d T}{d z}  0$), with a density ratio\n$$\nR_{\\rho} = \\frac{\\alpha \\, \\left| \\frac{d T}{d z} \\right|}{\\beta \\, \\left| \\frac{d S}{d z} \\right|}\n$$\nin an appropriate range determined by molecular diffusivity contrasts. Here, both $\\frac{d S}{d z}  0$ and $\\frac{d T}{d z}  0$ at $z = 60$, meaning both salinity and temperature gradients are stabilizing in the $z$ positive downward convention. A representative density ratio using magnitudes,\n$$\nR_{\\rho} = \\frac{\\alpha \\, \\frac{d T}{d z}}{\\beta \\, \\frac{d S}{d z}} \\approx \\frac{2.0 \\times 10^{-4} \\times 0.00931396}{7.6 \\times 10^{-4} \\times 0.0475} \\approx 0.0516,\n$$\nis small and, together with the stabilizing signs, does not indicate susceptibility to salt-finger instability. Instead, the configuration (colder, fresher over warmer, saltier) is characteristic of the diffusive-convective double-diffusive regime below the halocline, but at $z = 60$ the local gradients are both stabilizing, precluding salt fingers.",
            "answer": "$$\\boxed{3.359 \\times 10^{-4}}$$"
        },
        {
            "introduction": "Building on the calculation of stratification, this practice explores one of its most critical applications: estimating rates of vertical turbulent mixing. You will use the Osborn model, a cornerstone of physical oceanography, to derive diapycnal diffusivity $K_{\\rho}$ from measurements of the turbulent dissipation rate $\\epsilon$ and the buoyancy frequency $N^2$. This exercise demonstrates how stratification governs the efficiency of mixing, a crucial process for nutrient transport and the global climate system. ",
            "id": "3918390",
            "problem": "You are given vertical profiles of microstructure turbulent kinetic energy dissipation rate, stratification quantified by buoyancy frequency squared, and associated measurement uncertainties at specified depths. Your objective is to derive, compute, and report the diapycnal diffusivity profile and its uncertainty for each profile, based on first principles of the turbulent kinetic energy budget and the connection between irreversible buoyancy flux and scalar transport.\n\nDerive an expression for the diapycnal diffusivity $K_{\\rho}$ starting from the steady-state balance of Turbulent Kinetic Energy (TKE) and the definition of mixing efficiency, then connect the irreversible buoyancy flux to the scalar gradient through a gradient-diffusion closure. In your derivation, use the following foundations:\n- The definition of buoyancy frequency squared $N^2$ under stable stratification in terms of the background density gradient and gravitational acceleration.\n- The steady-state TKE budget in a stratified fluid relating dissipation rate to irreversible conversion of TKE into potential energy via the buoyancy flux.\n- A constant mixing efficiency $\\Gamma$ that relates the irreversible buoyancy flux to the dissipation rate.\n- A Fickian closure linking vertical buoyancy flux to a diapycnal diffusivity acting on the background density stratification.\n\nAssume independent uncertainties in the microstructure dissipation rate $\\epsilon$, the stratification $N^2$, and the mixing efficiency $\\Gamma$, each provided as one-standard-deviation values. Using first-order uncertainty propagation about the derived $K_{\\rho}$, compute the one-standard-deviation uncertainty $\\sigma_{K_{\\rho}}$ at each depth. Ensure that the computed $K_{\\rho}$ values are non-negative and finite for the provided test data.\n\nReport all diffusivities and their uncertainties in meters squared per second ($\\text{m}^2/\\text{s}$). Round every reported floating-point value to $3$ significant figures.\n\nTest Suite:\nFor each case, you are given arrays at specified depths with values and one-standard-deviation uncertainties. All $\\epsilon$ are in watts per kilogram ($\\text{m}^2/\\text{s}^3$), all $N^2$ are in $\\text{s}^{-2}$, and $\\Gamma$ is dimensionless.\n\n- Case A (thermocline-like stratification):\n  - Depths: $\\{5,15,50,100\\}$ meters\n  - $\\epsilon$: $\\{2\\times10^{-8},1.5\\times10^{-8},1\\times10^{-8},0.8\\times10^{-8}\\}$\n  - $\\sigma_{\\epsilon}$: $\\{0.5\\times10^{-8},0.3\\times10^{-8},0.2\\times10^{-8},0.1\\times10^{-8}\\}$\n  - $N^2$: $\\{1\\times10^{-4},0.7\\times10^{-4},0.3\\times10^{-4},0.1\\times10^{-4}\\}$\n  - $\\sigma_{N^2}$: $\\{1\\times10^{-5},0.7\\times10^{-5},0.3\\times10^{-5},0.1\\times10^{-5}\\}$\n  - $\\Gamma$ mean and one-standard-deviation: mean $0.2$, $\\sigma_{\\Gamma}=0.05$\n\n- Case B (weakly stratified, high variability):\n  - Depths: $\\{10,30,60,120\\}$ meters\n  - $\\epsilon$: $\\{5\\times10^{-9},4\\times10^{-9},3\\times10^{-9},2\\times10^{-9}\\}$\n  - $\\sigma_{\\epsilon}$: $\\{1\\times10^{-9},0.8\\times10^{-9},0.6\\times10^{-9},0.4\\times10^{-9}\\}$\n  - $N^2$: $\\{5\\times10^{-6},3\\times10^{-6},2\\times10^{-6},1\\times10^{-6}\\}$\n  - $\\sigma_{N^2}$: $\\{0.8\\times10^{-6},0.6\\times10^{-6},0.4\\times10^{-6},0.2\\times10^{-6}\\}$\n  - $\\Gamma$ mean and one-standard-deviation: mean $0.2$, $\\sigma_{\\Gamma}=0.07$\n\n- Case C (strong stratification):\n  - Depths: $\\{20,40,80,150\\}$ meters\n  - $\\epsilon$: $\\{2\\times10^{-9},1.5\\times10^{-9},1\\times10^{-9},0.7\\times10^{-9}\\}$\n  - $\\sigma_{\\epsilon}$: $\\{0.5\\times10^{-9},0.4\\times10^{-9},0.3\\times10^{-9},0.2\\times10^{-9}\\}$\n  - $N^2$: $\\{3\\times10^{-4},4\\times10^{-4},5\\times10^{-4},6\\times10^{-4}\\}$\n  - $\\sigma_{N^2}$: $\\{3\\times10^{-5},3.5\\times10^{-5},4\\times10^{-5},4.5\\times10^{-5}\\}$\n  - $\\Gamma$ mean and one-standard-deviation: mean $0.2$, $\\sigma_{\\Gamma}=0.03$\n\nYour program must:\n- Implement your derived expression to compute $K_{\\rho}$ and $\\sigma_{K_{\\rho}}$ at each depth for each case using first-order uncertainty propagation with independent errors.\n- Round all outputs to $3$ significant figures.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list consisting of two lists: the rounded diapycnal diffusivity values $[K_{\\rho,1},\\dots,K_{\\rho,n}]$ and the corresponding rounded uncertainties $[\\sigma_{K_{\\rho,1}},\\dots,\\sigma_{K_{\\rho,n}}]$, both in $\\text{m}^2/\\text{s}$. The final output format must be:\n$[[[K_{\\rho}^{A}], [\\sigma_{K_{\\rho}}^{A}]], [[K_{\\rho}^{B}], [\\sigma_{K_{\\rho}}^{B}]], [[K_{\\rho}^{C}], [\\sigma_{K_{\\rho}}^{C}]]]$\nwhere each bracketed list contains the values at the specified depths for the corresponding case.",
            "solution": "The user-provided problem is assessed as valid. It is scientifically grounded in the principles of geophysical fluid dynamics, specifically the theory of turbulent mixing in stratified fluids. The problem is well-posed, with sufficient information provided to derive a unique solution. The language is objective and the data are physically realistic. We proceed with the solution.\n\nThe primary objective is to derive an expression for the diapycnal diffusivity, $K_{\\rho}$, and its associated uncertainty, $\\sigma_{K_{\\rho}}$, and then compute these values for the given test cases.\n\n**Derivation of Diapycnal Diffusivity $K_{\\rho}$**\n\nThe derivation starts from the physical principles outlined in the problem statement.\n\n1.  **Turbulent Kinetic Energy (TKE) Budget and Mixing Efficiency ($\\Gamma$)**: In a stably stratified fluid, turbulent eddies do work against the background buoyancy gradient, converting kinetic energy into potential energy. A portion of this work results in irreversible mixing. The rate of this irreversible conversion is the buoyancy flux, $B$. In a steady-state TKE budget, the rate of TKE dissipation, $\\epsilon$ (in units of $\\text{m}^2/\\text{s}^3$ or W/kg), is related to the buoyancy flux through a mixing efficiency factor, $\\Gamma$, which is dimensionless. This relationship is given as:\n    $$ B = \\Gamma \\epsilon $$\n    Here, $\\Gamma$ represents the fraction of dissipated turbulent energy that contributes to irreversible mixing. A canonical value often used in oceanography is $\\Gamma = 0.2$.\n\n2.  **Gradient-Diffusion (Fickian) Closure**: The buoyancy flux, $B$, can also be parameterized as a diffusive process acting on the background density gradient. This is a Fickian-type closure where the flux is proportional to the gradient. The diapycnal diffusivity, $K_{\\rho}$ (in units of $\\text{m}^2/\\text{s}$), is the coefficient of proportionality:\n    $$ B = -K_{\\rho} \\frac{g}{\\rho_0} \\frac{d\\bar{\\rho}}{dz} $$\n    where $g$ is the acceleration due to gravity, $\\rho_0$ is a reference density, and $\\frac{d\\bar{\\rho}}{dz}$ is the mean vertical density gradient.\n\n3.  **Buoyancy Frequency ($N^2$)**: The stability of the stratification is quantified by the buoyancy frequency squared, $N^2$ (in units of $\\text{s}^{-2}$), which is defined as:\n    $$ N^2 = -\\frac{g}{\\rho_0} \\frac{d\\bar{\\rho}}{dz} $$\n    For a stable stratification, $\\frac{d\\bar{\\rho}}{dz}  0$, and thus $N^2  0$. Substituting the definition of $N^2$ into the expression for $B$:\n    $$ B = K_{\\rho} N^2 $$\n\n4.  **Final Expression for $K_{\\rho}$**: By equating the two expressions for the buoyancy flux $B$, we obtain a direct relationship between the measurable turbulence parameters ($\\epsilon$, $N^2$) and the diapycnal diffusivity $K_{\\rho}$:\n    $$ K_{\\rho} N^2 = \\Gamma \\epsilon $$\n    Solving for $K_{\\rho}$ yields the Osborn model (1980):\n    $$ K_{\\rho} = \\frac{\\Gamma \\epsilon}{N^2} $$\n    This is the expression used for all subsequent calculations.\n\n**Derivation of Uncertainty in Diapycnal Diffusivity $\\sigma_{K_{\\rho}}$**\n\nThe uncertainty in $K_{\\rho}$ is calculated using the first-order propagation of uncertainty for independent variables. The function is $K_{\\rho} = f(\\Gamma, \\epsilon, N^2)$. The general formula for the variance $\\sigma_{K_{\\rho}}^2$ is:\n$$ \\sigma_{K_{\\rho}}^2 = \\left( \\frac{\\partial K_{\\rho}}{\\partial \\Gamma} \\sigma_{\\Gamma} \\right)^2 + \\left( \\frac{\\partial K_{\\rho}}{\\partial \\epsilon} \\sigma_{\\epsilon} \\right)^2 + \\left( \\frac{\\partial K_{\\rho}}{\\partial N^2} \\sigma_{N^2} \\right)^2 $$\nwhere $\\sigma_{\\Gamma}$, $\\sigma_{\\epsilon}$, and $\\sigma_{N^2}$ are the one-standard-deviation uncertainties of the respective variables.\n\n1.  **Partial Derivatives**: The required partial derivatives of $K_{\\rho}$ are:\n    -   $\\frac{\\partial K_{\\rho}}{\\partial \\Gamma} = \\frac{\\epsilon}{N^2}$\n    -   $\\frac{\\partial K_{\\rho}}{\\partial \\epsilon} = \\frac{\\Gamma}{N^2}$\n    -   $\\frac{\\partial K_{\\rho}}{\\partial N^2} = -\\frac{\\Gamma \\epsilon}{(N^2)^2}$\n\n2.  **Propagation of Uncertainty**: Substituting the derivatives into the variance formula leads to a cumbersome expression. It is more convenient to work with relative uncertainties. For a function of the form $y = c \\cdot x_1^{a_1} x_2^{a_2} \\dots$, the squared relative uncertainty is given by:\n    $$ \\left( \\frac{\\sigma_y}{y} \\right)^2 = \\sum_{i} \\left( a_i \\frac{\\sigma_{x_i}}{x_i} \\right)^2 $$\n    For our function, $K_{\\rho} = \\Gamma^1 \\epsilon^1 (N^2)^{-1}$, the exponents are $a_{\\Gamma}=1$, $a_{\\epsilon}=1$, and $a_{N^2}=-1$. Applying the formula:\n    $$ \\left( \\frac{\\sigma_{K_{\\rho}}}{K_{\\rho}} \\right)^2 = \\left( 1 \\cdot \\frac{\\sigma_{\\Gamma}}{\\Gamma} \\right)^2 + \\left( 1 \\cdot \\frac{\\sigma_{\\epsilon}}{\\epsilon} \\right)^2 + \\left( -1 \\cdot \\frac{\\sigma_{N^2}}{N^2} \\right)^2 $$\n    This simplifies to:\n    $$ \\left( \\frac{\\sigma_{K_{\\rho}}}{K_{\\rho}} \\right)^2 = \\left( \\frac{\\sigma_{\\Gamma}}{\\Gamma} \\right)^2 + \\left( \\frac{\\sigma_{\\epsilon}}{\\epsilon} \\right)^2 + \\left( \\frac{\\sigma_{N^2}}{N^2} \\right)^2 $$\n\n3.  **Final Expression for $\\sigma_{K_{\\rho}}$**: The final expression for the one-standard-deviation uncertainty in $K_{\\rho}$ is obtained by solving for $\\sigma_{K_{\\rho}}$:\n    $$ \\sigma_{K_{\\rho}} = K_{\\rho} \\sqrt{ \\left( \\frac{\\sigma_{\\Gamma}}{\\Gamma} \\right)^2 + \\left( \\frac{\\sigma_{\\epsilon}}{\\epsilon} \\right)^2 + \\left( \\frac{\\sigma_{N^2}}{N^2} \\right)^2 } $$\n    This expression will be used for the uncertainty calculations.\n\n**Computational Strategy**\n\nFor each test case and at each specified depth, the following steps are performed:\n1.  Calculate $K_{\\rho}$ using the derived formula $K_{\\rho} = \\Gamma \\epsilon / N^2$.\n2.  Calculate the corresponding uncertainty $\\sigma_{K_{\\rho}}$ using the relative uncertainty propagation formula.\n3.  Round both $K_{\\rho}$ and $\\sigma_{K_{\\rho}}$ to $3$ significant figures. For programmatic implementation, this is most robustly achieved by formatting the numerical output as a string in scientific notation with two decimal places (e.g., `'1.23e-05'`), which inherently represents $3$ significant figures.\n4.  The results from all depths for a given case are collected into two lists, one for $K_{\\rho}$ and one for $\\sigma_{K_{\\rho}}$. These are then formatted into the final required output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, computes, and reports diapycnal diffusivity and its uncertainty\n    based on microstructure measurements.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"epsilon\": np.array([2e-8, 1.5e-8, 1e-8, 0.8e-8]),\n            \"sigma_epsilon\": np.array([0.5e-8, 0.3e-8, 0.2e-8, 0.1e-8]),\n            \"N2\": np.array([1e-4, 0.7e-4, 0.3e-4, 0.1e-4]),\n            \"sigma_N2\": np.array([1e-5, 0.7e-5, 0.3e-5, 0.1e-5]),\n            \"Gamma\": 0.2,\n            \"sigma_Gamma\": 0.05\n        },\n        {\n            \"epsilon\": np.array([5e-9, 4e-9, 3e-9, 2e-9]),\n            \"sigma_epsilon\": np.array([1e-9, 0.8e-9, 0.6e-9, 0.4e-9]),\n            \"N2\": np.array([5e-6, 3e-6, 2e-6, 1e-6]),\n            \"sigma_N2\": np.array([0.8e-6, 0.6e-6, 0.4e-6, 0.2e-6]),\n            \"Gamma\": 0.2,\n            \"sigma_Gamma\": 0.07\n        },\n        {\n            \"epsilon\": np.array([2e-9, 1.5e-9, 1e-9, 0.7e-9]),\n            \"sigma_epsilon\": np.array([0.5e-9, 0.4e-9, 0.3e-9, 0.2e-9]),\n            \"N2\": np.array([3e-4, 4e-4, 5e-4, 6e-4]),\n            \"sigma_N2\": np.array([3e-5, 3.5e-5, 4e-5, 4.5e-5]),\n            \"Gamma\": 0.2,\n            \"sigma_Gamma\": 0.03\n        }\n    ]\n\n    def format_to_sf(value, sf):\n        \"\"\"\n        Formats a number to a string with a specified number of significant figures,\n        using scientific notation.\n        \"\"\"\n        precision = sf - 1\n        return f\"{value:.{precision}e}\"\n\n    all_cases_results = []\n\n    for case in test_cases:\n        gamma = case[\"Gamma\"]\n        sigma_gamma = case[\"sigma_Gamma\"]\n        epsilon = case[\"epsilon\"]\n        sigma_epsilon = case[\"sigma_epsilon\"]\n        N2 = case[\"N2\"]\n        sigma_N2 = case[\"sigma_N2\"]\n\n        # Calculate K_rho\n        # K_rho = (Gamma * epsilon) / N^2\n        K_rhos = (gamma * epsilon) / N2\n\n        # Calculate uncertainty in K_rho\n        # (sigma_K/K)^2 = (sigma_Gamma/Gamma)^2 + (sigma_eps/eps)^2 + (sigma_N2/N2)^2\n        rel_unc_gamma_sq = (sigma_gamma / gamma)**2\n        rel_unc_eps_sq = (sigma_epsilon / epsilon)**2\n        rel_unc_n2_sq = (sigma_N2 / N2)**2\n        \n        # Calculate sigma_K_rho\n        sigma_K_rhos = K_rhos * np.sqrt(rel_unc_gamma_sq + rel_unc_eps_sq + rel_unc_n2_sq)\n\n        # Round to 3 significant figures by formatting the string output\n        rounded_K_rhos = [format_to_sf(k, 3) for k in K_rhos]\n        rounded_sigma_K_rhos = [format_to_sf(s, 3) for s in sigma_K_rhos]\n        \n        all_cases_results.append([rounded_K_rhos, rounded_sigma_K_rhos])\n\n    # Construct the final output string exactly as specified.\n    case_strings = []\n    for K_list, sigma_list in all_cases_results:\n        k_str = f\"[{','.join(K_list)}]\"\n        s_str = f\"[{','.join(sigma_list)}]\"\n        case_strings.append(f\"[{k_str},{s_str}]\")\n\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice bridges the gap between theory and real-world observation by simulating the complete data processing pipeline for oceanographic measurements. Starting with raw, noisy time series from a CTD profiler, you will implement steps for despiking, bin-averaging, and numerical differentiation to produce a robust estimate of the $N^2(z)$ profile. This comprehensive problem emphasizes the importance of careful data handling and uncertainty quantification in obtaining scientifically reliable estimates of stratification. ",
            "id": "3918419",
            "problem": "You are given three synthetic raw time series representing measurements from a Conductivity-Temperature-Depth (CTD) profiler: temperature $T(t)$ in degrees Celsius, practical salinity $S(t)$ in dimensionless practical salinity units, and pressure $p(t)$ in decibars. Your task is to implement a complete procedure to estimate the squared buoyancy frequency profile $N^2(z)$ as a function of the vertical coordinate $z$ (defined as positive upward) from these raw time series, including despiking, binning in pressure, and derivative estimation with uncertainty quantification (error bars).\n\nUse the following fundamental base, assumptions, and definitions:\n- The gravitational acceleration is $g = 9.81 \\, \\text{m s}^{-2}$.\n- Adopt the Boussinesq approximation with a linearized equation of state for seawater density around a reference state:\n  $$\\rho \\approx \\rho_0 \\left(1 - \\alpha (T - T_0) + \\beta (S - S_0)\\right),$$\n  where $\\rho_0$ is a constant reference density, $T_0$ and $S_0$ are reference temperature and salinity, and $\\alpha$ (thermal expansion coefficient) and $\\beta$ (haline contraction coefficient) are treated as constants for the purpose of the calculation.\n- The squared buoyancy frequency is defined with the vertical coordinate $z$ taken as positive upward:\n  $$N^2(z) = -\\frac{g}{\\rho_0}\\frac{d\\rho}{dz}.$$\n  Under the linearized equation of state, and assuming negligible pressure dependence in density (i.e., using potential density locally and ignoring compressibility), this reduces to\n  $$N^2(z) \\approx g\\left(\\alpha\\frac{dT}{dz} - \\beta\\frac{dS}{dz}\\right).$$\n- Convert pressure to depth using the approximation $1$ decibar $\\approx 1$ meter, and define $z$ as $z = -\\mathrm{depth}$, so that $z$ increases upward. Your numerical derivatives must be taken with respect to $z$.\n\nProcedure requirements:\n1. Despiking:\n   - Identify and remove spikes in the raw $T(t)$ and $S(t)$ series using a robust statistic such as the median absolute deviation. A data point is considered a spike if its absolute deviation from the median exceeds a specified multiple of the median absolute deviation. Apply the same removal mask to all three time series to maintain alignment.\n2. Binning:\n   - Bin the despiked data by pressure into uniform bins of width $\\Delta p$ (in decibars), compute the bin centers $p_b$, and convert them to depth $d_b$ (in meters) using the $1$ decibar $\\approx 1$ meter approximation, then to $z_b = -d_b$ (in meters).\n   - For each bin $b$, compute the mean $\\overline{T}_b$, the mean $\\overline{S}_b$, and the number of samples $n_b$. Also compute the sample variance $\\mathrm{Var}(T)_b$ and $\\mathrm{Var}(S)_b$ within the bin. Use a minimum occupancy threshold to discard underpopulated bins.\n   - Instrument noise standard deviations are given by $\\sigma_T$ for temperature and $\\sigma_S$ for salinity. Treat instrument noise as independent and additive to sample variance. The variance of the bin mean should be estimated as\n     $$\\mathrm{Var}(\\overline{T}_b) \\approx \\frac{\\mathrm{Var}(T)_b + \\sigma_T^2}{n_b}, \\quad \\mathrm{Var}(\\overline{S}_b) \\approx \\frac{\\mathrm{Var}(S)_b + \\sigma_S^2}{n_b}.$$\n3. Derivative estimation:\n   - Estimate $dT/dz$ and $dS/dz$ at interior bin centers using central differences:\n     $$\\left.\\frac{dX}{dz}\\right|_{b} \\approx \\frac{\\overline{X}_{b+1} - \\overline{X}_{b-1}}{z_{b+1} - z_{b-1}}, \\quad X \\in \\{T,S\\}.$$\n   - Propagate uncertainty assuming independence of bin means:\n     $$\\mathrm{Var}\\left(\\left.\\frac{dX}{dz}\\right|_b\\right) \\approx \\frac{\\mathrm{Var}(\\overline{X}_{b+1}) + \\mathrm{Var}(\\overline{X}_{b-1})}{\\left(z_{b+1} - z_{b-1}\\right)^2}.$$\n   - For bins where central differences are not possible (edges), use one-sided differences if needed; however, the test queries below will target interior bins.\n4. Buoyancy frequency and error bars:\n   - Compute $N^2_b$ at bin $b$ as\n     $$N^2_b = g\\left(\\alpha \\left.\\frac{dT}{dz}\\right|_b - \\beta \\left.\\frac{dS}{dz}\\right|_b\\right),$$\n     and estimate its variance (neglecting covariance between the temperature and salinity derivative estimates):\n     $$\\mathrm{Var}(N^2_b) \\approx g^2\\left(\\alpha^2\\,\\mathrm{Var}\\left(\\left.\\frac{dT}{dz}\\right|_b\\right) + \\beta^2\\,\\mathrm{Var}\\left(\\left.\\frac{dS}{dz}\\right|_b\\right)\\right).$$\n   - Report the one-standard-deviation uncertainty as $\\sigma_{N^2_b} = \\sqrt{\\mathrm{Var}(N^2_b)}$.\n\nConstants and instrument characteristics to use in all computations:\n- $g = 9.81 \\, \\text{m s}^{-2}$,\n- $\\alpha = 2.0 \\times 10^{-4} \\, \\text{K}^{-1}$,\n- $\\beta = 8.0 \\times 10^{-4}$ (dimensionless per practical salinity unit),\n- $\\sigma_T = 0.002 \\, \\text{K}$,\n- $\\sigma_S = 0.002$ (practical salinity units),\n- Spike threshold multiplier $k = 5$ (i.e., remove points where the absolute deviation from the median exceeds $k$ times the median absolute deviation),\n- Pressure bin width $\\Delta p = 5$ decibars,\n- Minimum bin occupancy $n_{\\min} = 8$ samples.\n\nTest suite:\nImplement and run your algorithm on the following three synthetic cases. For each case, generate $N$ time samples of pressure uniformly spanning the specified range, add small random jitter to emulate profiling, then compute the \"true\" profiles $T_{\\mathrm{true}}(p)$ and $S_{\\mathrm{true}}(p)$ and add Gaussian instrument noise with standard deviations $\\sigma_T$ and $\\sigma_S$. Insert random spikes at a low probability in both $T$ and $S$ before despiking.\n\n- Case 1 (happy path, clearly stratified):\n  - $N = 3000$, pressure range $p \\in [0, 100]$ decibars.\n  - True profiles:\n    $$T_{\\mathrm{true}}(p) = 20 - 0.05\\,p + 0.2\\sin\\left(\\frac{2\\pi p}{50}\\right), \\quad S_{\\mathrm{true}}(p) = 34 + 0.01\\,p.$$\n  - Spikes: with probability $0.002$ per sample, add an offset of $\\pm 1.0$ K to $T$ and $\\pm 0.5$ to $S$ (choose signs at random independently).\n  - Target evaluation depth: $z_{\\mathrm{target}} = -50$ meters (i.e., at approximately $50$ meters depth; recall $z$ is positive upward).\n- Case 2 (near-homogeneous, boundary condition):\n  - $N = 3000$, pressure range $p \\in [0, 100]$ decibars.\n  - True profiles:\n    $$T_{\\mathrm{true}}(p) = 10 + 0.001\\,p, \\quad S_{\\mathrm{true}}(p) = 35 + 0.0002\\,p.$$\n  - Spikes: with probability $0.002$ per sample, add an offset of $\\pm 1.0$ K to $T$ and $\\pm 0.5$ to $S$.\n  - Target evaluation depth: $z_{\\mathrm{target}} = -50$ meters.\n- Case 3 (edge case with an unstable near-surface layer):\n  - $N = 3000$, pressure range $p \\in [0, 100]$ decibars.\n  - True profiles:\n    $$T_{\\mathrm{true}}(p) = \\begin{cases} 14 + 0.03\\,p,  p  25, \\\\ 14 + 0.03\\cdot 25 - 0.05\\,(p-25),  p \\ge 25, \\end{cases} \\quad S_{\\mathrm{true}}(p) = 35 + 0.0005\\,p.$$\n  - Spikes: with probability $0.002$ per sample, add an offset of $\\pm 1.0$ K to $T$ and $\\pm 0.5$ to $S$.\n  - Target evaluation depth: $z_{\\mathrm{target}} = -15$ meters (to capture the region influenced by the unstable layer).\n\nOutput specification:\n- For each case, locate the bin center $z_b$ closest to the specified $z_{\\mathrm{target}}$ among bins where central differences are available (i.e., interior bins). Report the pair $\\left[N^2(z_b), \\sigma_{N^2}(z_b)\\right]$ in units of $\\text{s}^{-2}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes a two-element list of floats:\n  $$\\left[\\left[N^2_1, \\sigma_{N^2,1}\\right], \\left[N^2_2, \\sigma_{N^2,2}\\right], \\left[N^2_3, \\sigma_{N^2,3}\\right]\\right].$$",
            "solution": "The user has provided a well-defined problem in computational physical oceanography. The task is to implement a complete data processing pipeline to estimate the squared buoyancy frequency profile, denoted as $N^2(z)$, from synthetic raw time series of temperature $T(t)$, practical salinity $S(t)$, and pressure $p(t)$. The procedure includes data generation, despiking, bin-averaging, numerical differentiation, and uncertainty propagation. The problem is scientifically sound, well-posed, and all necessary parameters and equations are provided.\n\nThe scientific foundation of this problem is the concept of buoyancy frequency, a measure of the static stability of a fluid parcel in a stratified environment. For a parcel displaced vertically, its tendency to return to its original position (oscillate) or continue moving away (overturn) is determined by the sign of $N^2$. A positive $N^2$ indicates stability, while a negative $N^2$ signifies instability.\n\nThe core relationship is the linearized equation of state for seawater density $\\rho$:\n$$ \\rho \\approx \\rho_0 \\left(1 - \\alpha (T - T_0) + \\beta (S - S_0)\\right) $$\nwhere $\\rho_0, T_0, S_0$ are reference values, $\\alpha$ is the thermal expansion coefficient, and $\\beta$ is the haline contraction coefficient.\nThe squared buoyancy frequency, with the vertical coordinate $z$ defined as positive upward, is given by:\n$$ N^2(z) = -\\frac{g}{\\rho_0}\\frac{d\\rho}{dz} $$\nSubstituting the linearized equation of state and assuming pressure effects on density are locally negligible, we arrive at the working equation:\n$$ N^2(z) \\approx g\\left(\\alpha\\frac{dT}{dz} - \\beta\\frac{dS}{dz}\\right) $$\nThe vertical coordinate $z$ is derived from pressure $p$ (in decibars) using the hydrostatic approximation $z \\approx -p$.\n\nThe implementation will follow the specified procedure step-by-step.\n\n1.  **Synthetic Data Generation**: For each test case, we first generate the raw data.\n    - A pressure time series $p(t)$ is created for $N$ samples, uniformly distributed over the specified pressure range.\n    - The \"true\" temperature $T_{\\mathrm{true}}(p)$ and salinity $S_{\\mathrm{true}}(p)$ profiles are computed based on the given analytical functions for each case.\n    - To simulate instrument measurements, Gaussian noise with specified standard deviations $\\sigma_T$ and $\\sigma_S$ is added to the true profiles.\n    - Finally, random spikes of a given magnitude are added to a small fraction of the temperature and salinity data points to simulate measurement errors.\n\n2.  **Despiking**: Raw observational data are often contaminated with spurious spikes. We employ a robust statistical method to identify and remove them.\n    - For both the temperature and salinity time series, we calculate the median and the Median Absolute Deviation (MAD), defined as $\\mathrm{MAD} = \\mathrm{median}(|x_i - \\mathrm{median}(x)|)$.\n    - A data point $x_i$ is flagged as a spike if its absolute deviation from the series median exceeds a threshold, i.e., $|x_i - \\mathrm{median}(x)|  k \\times \\mathrm{MAD}$, where $k$ is a specified multiplier.\n    - A combined mask is created, marking any time step where either $T(t)$ or $S(t)$ is a spike. This entire time step (including the corresponding $p(t)$ value) is removed to ensure the alignment and integrity of the datasets.\n\n3.  **Bin Averaging**: The despiked, high-frequency data are binned to create a smooth profile as a function of depth.\n    - Pressure bins of a fixed width $\\Delta p$ are defined over the pressure range.\n    - The despiked data points $(p, T, S)$ are assigned to their respective pressure bins.\n    - Bins with fewer than a minimum number of samples, $n_{\\min}$, are discarded to ensure statistical robustness.\n    - For each valid bin $b$, we compute the bin-center pressure $p_b$ (and thus $z_b = -p_b$), the number of samples $n_b$, the mean temperature $\\overline{T}_b$, the mean salinity $\\overline{S}_b$, and their sample variances $\\mathrm{Var}(T)_b$ and $\\mathrm{Var}(S)_b$.\n\n4.  **Uncertainty of Bin Means**: The uncertainty in the bin-averaged quantities stems from both environmental variability within the bin (captured by sample variance) and instrument noise.\n    - The variance of the mean for each bin is estimated by combining these two sources, assuming they are independent:\n      $$ \\mathrm{Var}(\\overline{T}_b) \\approx \\frac{\\mathrm{Var}(T)_b + \\sigma_T^2}{n_b} $$\n      $$ \\mathrm{Var}(\\overline{S}_b) \\approx \\frac{\\mathrm{Var}(S)_b + \\sigma_S^2}{n_b} $$\n\n5.  **Numerical Differentiation and Uncertainty Propagation**: The vertical gradients $dT/dz$ and $dS/dz$ are estimated from the binned profiles.\n    - We use a second-order central difference scheme for interior bins, which offers better accuracy than one-sided differences:\n      $$ \\left.\\frac{dX}{dz}\\right|_{b} \\approx \\frac{\\overline{X}_{b+1} - \\overline{X}_{b-1}}{z_{b+1} - z_{b-1}}, \\quad \\text{for } X \\in \\{T,S\\} $$\n    - The uncertainty in these gradients is determined by propagating the uncertainties from the bin means. Assuming the bin means $\\overline{X}_{b+1}$ and $\\overline{X}_{b-1}$ are independent random variables, the variance of the derivative estimate is:\n      $$ \\mathrm{Var}\\left(\\left.\\frac{dX}{dz}\\right|_b\\right) \\approx \\frac{\\mathrm{Var}(\\overline{X}_{b+1}) + \\mathrm{Var}(\\overline{X}_{b-1})}{\\left(z_{b+1} - z_{b-1}\\right)^2} $$\n\n6.  **Buoyancy Frequency and Final Uncertainty**: The final step is to combine the gradients to calculate $N^2_b$ and its total uncertainty.\n    - The squared buoyancy frequency at interior bin $b$ is computed as:\n      $$ N^2_b = g\\left(\\alpha \\left.\\frac{dT}{dz}\\right|_b - \\beta \\left.\\frac{dS}{dz}\\right|_b\\right) $$\n    - Assuming the errors in the estimates of $dT/dz$ and $dS/dz$ are uncorrelated, the variance of $N^2_b$ is propagated as follows:\n      $$ \\mathrm{Var}(N^2_b) \\approx g^2\\left(\\alpha^2\\,\\mathrm{Var}\\left(\\left.\\frac{dT}{dz}\\right|_b\\right) + \\beta^2\\,\\mathrm{Var}\\left(\\left.\\frac{dS}{dz}\\right|_b\\right)\\right) $$\n    - The final reported uncertainty is the standard deviation, $\\sigma_{N^2_b} = \\sqrt{\\mathrm{Var}(N^2_b)}$.\n\n7.  **Target Value Extraction**: For each test case, the problem requires reporting the computed $N^2_b$ and $\\sigma_{N^2_b}$ for the interior bin whose center $z_b$ is closest to a specified target depth $z_{\\mathrm{target}}$. This involves a simple search over the array of interior bin depths.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import median_abs_deviation\n\ndef process_ctd_profile(case_params, constants, sim_params):\n    \"\"\"\n    Generates synthetic CTD data and computes the buoyancy frequency profile.\n    \"\"\"\n    # Unpack parameters\n    T_func, S_func = case_params['profiles']\n    z_target = case_params['z_target']\n    \n    g = constants['g']\n    alpha = constants['alpha']\n    beta = constants['beta']\n    \n    sigma_T = constants['sigma_T']\n    sigma_S = constants['sigma_S']\n    despike_k = constants['despike_k']\n    dp_bin = constants['dp_bin']\n    n_min = constants['n_min']\n\n    N_samples = sim_params['N']\n    p_range = sim_params['p_range']\n    spike_prob = sim_params['spike_prob']\n    spike_mag_T = sim_params['spike_mag_T']\n    spike_mag_S = sim_params['spike_mag_S']\n    \n    # 1. Data Generation\n    rng = np.random.default_rng(seed=case_params['seed'])\n    \n    p_raw = rng.uniform(p_range[0], p_range[1], N_samples)\n    \n    T_true = T_func(p_raw)\n    S_true = S_func(p_raw)\n    \n    T_noisy = T_true + rng.normal(0, sigma_T, N_samples)\n    S_noisy = S_true + rng.normal(0, sigma_S, N_samples)\n\n    # Add spikes\n    T_spiked, S_spiked = T_noisy.copy(), S_noisy.copy()\n    spike_indices = rng.choice([False, True], size=N_samples, p=[1 - spike_prob, spike_prob])\n    \n    spike_offsets_T = rng.choice([-spike_mag_T, spike_mag_T], size=N_samples)\n    spike_offsets_S = rng.choice([-spike_mag_S, spike_mag_S], size=N_samples)\n    \n    T_spiked[spike_indices] += spike_offsets_T[spike_indices]\n    S_spiked[spike_indices] += spike_offsets_S[spike_indices]\n    \n    # 2. Despiking\n    median_T = np.median(T_spiked)\n    mad_T = median_abs_deviation(T_spiked, scale=1)\n    is_spike_T = np.abs(T_spiked - median_T)  despike_k * mad_T if mad_T  0 else np.zeros_like(T_spiked, dtype=bool)\n\n    median_S = np.median(S_spiked)\n    mad_S = median_abs_deviation(S_spiked, scale=1)\n    is_spike_S = np.abs(S_spiked - median_S)  despike_k * mad_S if mad_S  0 else np.zeros_like(S_spiked, dtype=bool)\n\n    valid_mask = ~(is_spike_T | is_spike_S)\n    p_d, T_d, S_d = p_raw[valid_mask], T_spiked[valid_mask], S_spiked[valid_mask]\n    \n    # 3. Binning\n    p_bins = np.arange(p_range[0], p_range[1] + dp_bin, dp_bin)\n    bin_centers = p_bins[:-1] + dp_bin / 2.0\n    \n    p_b, z_b = [], []\n    T_b_mean, S_b_mean = [], []\n    var_T_b_mean, var_S_b_mean = [], []\n\n    for i in range(len(p_bins) - 1):\n        bin_mask = (p_d = p_bins[i])  (p_d  p_bins[i+1])\n        T_in_bin, S_in_bin = T_d[bin_mask], S_d[bin_mask]\n        n_b = len(T_in_bin)\n        \n        if n_b = n_min:\n            p_b.append(bin_centers[i])\n            z_b.append(-bin_centers[i])\n            \n            T_b_mean.append(np.mean(T_in_bin))\n            S_b_mean.append(np.mean(S_in_bin))\n\n            # 4. Uncertainty of Bin Means\n            var_T_sample = np.var(T_in_bin, ddof=1) if n_b  1 else 0\n            var_S_sample = np.var(S_in_bin, ddof=1) if n_b  1 else 0\n\n            var_T_b_mean.append((var_T_sample + sigma_T**2) / n_b)\n            var_S_b_mean.append((var_S_sample + sigma_S**2) / n_b)\n\n    # Convert to numpy arrays for vectorized operations\n    z_b = np.array(z_b)\n    T_b_mean, S_b_mean = np.array(T_b_mean), np.array(S_b_mean)\n    var_T_b_mean, var_S_b_mean = np.array(var_T_b_mean), np.array(var_S_b_mean)\n\n    if len(z_b)  3:\n        return [np.nan, np.nan] # Not enough bins for central difference\n\n    # 5. Derivative Estimation  Uncertainty\n    z_interior = z_b[1:-1]\n    \n    # Numerators for central difference\n    dT = T_b_mean[2:] - T_b_mean[:-2]\n    dS = S_b_mean[2:] - S_b_mean[:-2]\n    # Denominator\n    dz = z_b[2:] - z_b[:-2]\n\n    # Gradients\n    dTdz = dT / dz\n    dSdz = dS / dz\n    \n    # Variance of derivatives\n    var_dT = var_T_b_mean[2:] + var_T_b_mean[:-2]\n    var_dS = var_S_b_mean[2:] + var_S_b_mean[:-2]\n    \n    var_dTdz = var_dT / dz**2\n    var_dSdz = var_dS / dz**2\n    \n    # 6. Buoyancy Frequency  Final Uncertainty\n    N2 = g * (alpha * dTdz - beta * dSdz)\n    var_N2 = g**2 * (alpha**2 * var_dTdz + beta**2 * var_dSdz)\n    sigma_N2 = np.sqrt(var_N2)\n    \n    # 7. Target Value Extraction\n    target_idx = np.argmin(np.abs(z_interior - z_target))\n    \n    return [N2[target_idx], sigma_N2[target_idx]]\n\ndef solve():\n    constants = {\n        'g': 9.81, 'alpha': 2.0e-4, 'beta': 8.0e-4,\n        'sigma_T': 0.002, 'sigma_S': 0.002,\n        'despike_k': 5, 'dp_bin': 5, 'n_min': 8\n    }\n    \n    sim_params = {\n        'N': 3000, 'p_range': [0, 100], 'spike_prob': 0.002,\n        'spike_mag_T': 1.0, 'spike_mag_S': 0.5\n    }\n\n    test_cases = [\n        {\n            'profiles': (\n                lambda p: 20 - 0.05 * p + 0.2 * np.sin(2 * np.pi * p / 50),\n                lambda p: 34 + 0.01 * p\n            ),\n            'z_target': -50,\n            'seed': 42\n        },\n        {\n            'profiles': (\n                lambda p: 10 + 0.001 * p,\n                lambda p: 35 + 0.0002 * p\n            ),\n            'z_target': -50,\n            'seed': 43\n        },\n        {\n            'profiles': (\n                lambda p: np.where(p  25, \n                                   14 + 0.03 * p, \n                                   14 + 0.03 * 25 - 0.05 * (p - 25)),\n                lambda p: 35 + 0.0005 * p\n            ),\n            'z_target': -15,\n            'seed': 44\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_ctd_profile(case, constants, sim_params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}