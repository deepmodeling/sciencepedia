{
    "hands_on_practices": [
        {
            "introduction": "To model thermohaline circulation, we must begin with its fundamental driver: variations in seawater density. This exercise provides practice in applying the linearized equation of state, a foundational tool in physical oceanography that simplifies the complex relationship between temperature ($T$), salinity ($S$), and density ($\\rho$). By calculating the density anomaly of a water parcel relative to its surroundings , you will develop a quantitative understanding of buoyancy and the initial tendency of water to sink or rise, which is the first step in forming deep ocean currents.",
            "id": "3926354",
            "problem": "In environmental and earth system modeling of thermohaline circulation, seawater density depends on temperature and salinity at a given pressure. Consider a near-surface parcel at $p=0\\,\\mathrm{dbar}$ with $(T,S)=(2\\,^\\circ\\mathrm{C}, 35.2\\,\\mathrm{psu})$, referenced to $(T_0,S_0)=(4\\,^\\circ\\mathrm{C}, 35.0\\,\\mathrm{psu})$, where $\\mathrm{psu}$ denotes Practical Salinity Unit. Assume the Boussinesq approximation (BA), in which a constant reference density $\\rho_0$ is used to linearize thermodynamic effects while retaining buoyancy, and take the thermal expansion coefficient $\\alpha=2\\times 10^{-4}\\,\\mathrm{K}^{-1}$ and the haline contraction coefficient $\\beta=7.5\\times 10^{-4}\\,\\mathrm{psu}^{-1}$, both evaluated at the reference state and at $p=0\\,\\mathrm{dbar}$. Let the reference density at the reference state be $\\rho_0=1027\\,\\mathrm{kg\\,m^{-3}}$.\n\nStarting from fundamental definitions of how density varies with temperature and salinity at fixed pressure, and invoking a first-order linearization about $(T_0,S_0)$ consistent with the Boussinesq approximation, compute the density anomaly at $p=0\\,\\mathrm{dbar}$, namely the quantity $\\rho'=\\rho(T,S,0)-\\rho(T_0,S_0,0)$, expressed in units of $\\mathrm{kg\\,m^{-3}}$. Round your final numerical result to four significant figures. Then, based on the sign of $\\rho'$ and the Boussinesq buoyancy concept, briefly assess whether the parcel is statically lighter or heavier than the reference and the qualitative implication for its tendency to rise or sink. Only the numerical value of $\\rho'$ is required for the final answer; the buoyancy assessment should be included in your reasoning.",
            "solution": "The density of seawater, $\\rho$, is a function of temperature ($T$), salinity ($S$), and pressure ($p$). At a fixed pressure, we can perform a first-order Taylor series expansion of $\\rho(T,S)$ around a reference state $(T_0, S_0)$:\n$$\n\\rho(T,S) \\approx \\rho(T_0,S_0) + \\left.\\frac{\\partial\\rho}{\\partial T}\\right|_{(T_0, S_0)} (T - T_0) + \\left.\\frac{\\partial\\rho}{\\partial S}\\right|_{(T_0, S_0)} (S - S_0)\n$$\nThe reference density is given as $\\rho_0 = \\rho(T_0,S_0,0) = 1027\\,\\mathrm{kg\\,m^{-3}}$. The partial derivatives are related to the thermal expansion coefficient, $\\alpha$, and the haline contraction coefficient, $\\beta$, by their standard definitions:\n$$\n\\alpha \\equiv -\\frac{1}{\\rho_0} \\left.\\frac{\\partial\\rho}{\\partial T}\\right|_{(T_0, S_0)} \\implies \\left.\\frac{\\partial\\rho}{\\partial T}\\right|_{(T_0, S_0)} = -\\rho_0 \\alpha\n$$\n$$\n\\beta \\equiv \\frac{1}{\\rho_0} \\left.\\frac{\\partial\\rho}{\\partial S}\\right|_{(T_0, S_0)} \\implies \\left.\\frac{\\partial\\rho}{\\partial S}\\right|_{(T_0, S_0)} = \\rho_0 \\beta\n$$\nSubstituting these into the Taylor expansion gives the linearized equation of state:\n$$\n\\rho(T,S) \\approx \\rho_0 - \\rho_0 \\alpha (T - T_0) + \\rho_0 \\beta (S - S_0)\n$$\nThe density anomaly, $\\rho'$, is the difference between the parcel's density and the reference density, $\\rho' = \\rho(T,S) - \\rho_0$. Using the linearized equation, we find:\n$$\n\\rho' \\approx \\rho_0 \\left[ -\\alpha (T - T_0) + \\beta (S - S_0) \\right]\n$$\nNow, we substitute the provided values into this expression:\n- Parcel state: $(T,S) = (2\\,^\\circ\\mathrm{C}, 35.2\\,\\mathrm{psu})$\n- Reference state: $(T_0,S_0) = (4\\,^\\circ\\mathrm{C}, 35.0\\,\\mathrm{psu})$\n- Reference density: $\\rho_0 = 1027\\,\\mathrm{kg\\,m^{-3}}$\n- Thermal expansion coefficient: $\\alpha = 2 \\times 10^{-4}\\,\\mathrm{K}^{-1}$\n- Haline contraction coefficient: $\\beta = 7.5 \\times 10^{-4}\\,\\mathrm{psu}^{-1}$\n\nThe differences in temperature and salinity are:\n$$\nT - T_0 = 2\\,^\\circ\\mathrm{C} - 4\\,^\\circ\\mathrm{C} = -2\\,\\mathrm{K}\n$$\n$$\nS - S_0 = 35.2\\,\\mathrm{psu} - 35.0\\,\\mathrm{psu} = 0.2\\,\\mathrm{psu}\n$$\nNow we compute the density anomaly $\\rho'$:\n$$\n\\rho' = (1027\\,\\mathrm{kg\\,m^{-3}}) \\left[ -(2 \\times 10^{-4}\\,\\mathrm{K}^{-1})(-2\\,\\mathrm{K}) + (7.5 \\times 10^{-4}\\,\\mathrm{psu}^{-1})(0.2\\,\\mathrm{psu}) \\right]\n$$\n$$\n\\rho' = 1027 \\left[ (4 \\times 10^{-4}) + (1.5 \\times 10^{-4}) \\right] \\,\\mathrm{kg\\,m^{-3}}\n$$\n$$\n\\rho' = 1027 \\left[ 5.5 \\times 10^{-4} \\right] \\,\\mathrm{kg\\,m^{-3}}\n$$\n$$\n\\rho' = 0.56485 \\,\\mathrm{kg\\,m^{-3}}\n$$\nRounding to four significant figures gives:\n$$\n\\rho' \\approx 0.5649 \\,\\mathrm{kg\\,m^{-3}}\n$$\nSince the density anomaly $\\rho'$ is positive, the parcel is denser (heavier) than the reference water. The buoyancy force per unit volume on the parcel is $-g\\rho'$, which is negative (downward). This means the parcel is unstable relative to the reference state and will tend to sink, a key process in deep water formation.",
            "answer": "$$\n\\boxed{0.5649}\n$$"
        },
        {
            "introduction": "Having established how temperature and salinity control density, we now turn to the mechanisms that modify these properties at the ocean's surface. Air-sea interaction is the primary driver, altering the density of the mixed layer through exchanges of heat and freshwater. This practice guides you through the calculation of the surface buoyancy flux ($B_0$), a key metric that combines the effects of heating/cooling and evaporation/precipitation to determine whether surface water becomes lighter or denser . Understanding buoyancy flux is crucial for identifying the regions and conditions that lead to deep water formation and drive the global conveyor belt.",
            "id": "3926322",
            "problem": "Consider a subtropical ocean region where the mixed-layer exchanges heat and freshwater with the atmosphere. Assume a linearized equation of state for seawater, $ \\rho' = -\\rho_0 \\left( \\alpha T' - \\beta S' \\right) $, and define buoyancy as $ b = -g \\rho' / \\rho_0 = g \\left( \\alpha T' - \\beta S' \\right) $. The surface buoyancy flux $B_0$ is the turbulent flux of $b$ across the air–sea interface. Let the net surface heat flux be $Q_T=-200\\,\\mathrm{W\\, m^{-2}}$ (negative indicating cooling of the ocean), the net evaporation minus precipitation be $E-P=1\\,\\mathrm{m\\, yr^{-1}}$ (positive indicating net evaporation), and the near-surface salinity be $S_0=35$ in Practical Salinity Units (PSU). Take the thermal expansion coefficient to be $\\alpha=2\\times 10^{-4}\\,\\mathrm{K^{-1}}$, the haline contraction coefficient to be $\\beta=7.5\\times 10^{-4}\\,\\mathrm{psu^{-1}}$, and the specific heat capacity of seawater at constant pressure to be $c_p=4000\\,\\mathrm{J\\, kg^{-1}\\, K^{-1}}$. Use gravitational acceleration $g=9.81\\,\\mathrm{m\\, s^{-2}}$ and reference seawater density $\\rho_0=1025\\,\\mathrm{kg\\, m^{-3}}$. Assume that the freshwater flux is free of salt, so that its effect on salinity can be represented as a “virtual” salt flux based on $S_0$.\n\nStarting from conservation of heat and salt and the linearized equation of state, derive the expression for the surface buoyancy flux $B_0$ in terms of $Q_T$, $E-P$, $S_0$, $\\alpha$, $\\beta$, $c_p$, $g$, and $\\rho_0$, making clear the sign conventions. Then evaluate $B_0$ numerically for the given parameters and determine the net sign of $B_0$.\n\nExpress your final numerical result for $B_0$ in units of $\\mathrm{m^2\\, s^{-3}}$ and round your answer to three significant figures. State clearly whether the net buoyancy flux is positive or negative based on your computed value. For the conversion from years to seconds, take $1\\,\\mathrm{yr} = 365\\times 24\\times 3600\\,\\mathrm{s}$.",
            "solution": "The surface buoyancy flux, $B_0$, is the turbulent kinematic flux of buoyancy $b = g(\\alpha T' - \\beta S')$ across the air-sea interface. It can be expressed in terms of the kinematic fluxes of heat and salt:\n$$ B_0 = \\langle w'b' \\rangle_s = g(\\alpha \\langle w'T' \\rangle_s - \\beta \\langle w'S' \\rangle_s) $$\nwhere $\\langle w'T' \\rangle_s$ is the kinematic surface heat flux and $\\langle w'S' \\rangle_s$ is the virtual kinematic surface salt flux.\n\nThe kinematic heat flux is related to the net surface heat flux $Q_T$ (in $\\mathrm{W\\, m^{-2}}$) by:\n$$ \\langle w'T' \\rangle_s = \\frac{Q_T}{\\rho_0 c_p} $$\nThe virtual salt flux is due to the removal of freshwater by evaporation ($E$) and addition by precipitation ($P$). A net evaporation ($E-P > 0$) increases surface salinity, equivalent to a downward salt flux:\n$$ \\langle w'S' \\rangle_s = S_0 (E-P) $$\nSubstituting these into the equation for $B_0$ gives the final expression:\n$$ B_0 = g \\left( \\alpha \\frac{Q_T}{\\rho_0 c_p} - \\beta S_0 (E-P) \\right) $$\nA negative $B_0$ indicates a buoyancy loss (densification), promoting convection.\n\nTo evaluate $B_0$ numerically, we first convert the freshwater flux $E-P$ to SI units:\n$$ 1\\,\\mathrm{yr} = 365 \\times 24 \\times 3600\\,\\mathrm{s} = 31,536,000\\,\\mathrm{s} $$\n$$ E-P = \\frac{1\\,\\mathrm{m}}{31,536,000\\,\\mathrm{s}} \\approx 3.171 \\times 10^{-8}\\,\\mathrm{m\\, s^{-1}} $$\nThe buoyancy flux $B_0$ is the sum of a thermal component ($B_T$) and a haline component ($B_S$):\n$$ B_T = g \\alpha \\frac{Q_T}{\\rho_0 c_p} = (9.81\\,\\mathrm{m\\, s^{-2}}) (2 \\times 10^{-4}\\,\\mathrm{K^{-1}}) \\frac{-200\\,\\mathrm{W\\, m^{-2}}}{(1025\\,\\mathrm{kg\\, m^{-3}}) (4000\\,\\mathrm{J\\, kg^{-1}\\, K^{-1}})} \\approx -9.571 \\times 10^{-8}\\,\\mathrm{m^2\\, s^{-3}} $$\n$$ B_S = -g \\beta S_0 (E-P) = -(9.81\\,\\mathrm{m\\, s^{-2}}) (7.5 \\times 10^{-4}\\,\\mathrm{psu^{-1}}) (35\\,\\mathrm{psu}) (3.171 \\times 10^{-8}\\,\\mathrm{m\\, s^{-1}}) \\approx -8.168 \\times 10^{-9}\\,\\mathrm{m^2\\, s^{-3}} $$\nThe total surface buoyancy flux is the sum of these two components:\n$$ B_0 = B_T + B_S \\approx (-9.571 \\times 10^{-8}) + (-0.8168 \\times 10^{-8})\\,\\mathrm{m^2\\, s^{-3}} \\approx -1.0388 \\times 10^{-7}\\,\\mathrm{m^2\\, s^{-3}} $$\nRounding to three significant figures, the result is $B_0 \\approx -1.04 \\times 10^{-7}\\,\\mathrm{m^2\\, s^{-3}}$.\nThe net sign of the buoyancy flux is negative. This indicates a net loss of buoyancy at the ocean surface, as both cooling and net evaporation make the surface water denser. This condition promotes vertical mixing and is conducive to deep water formation.",
            "answer": "$$ \\boxed{-1.04 \\times 10^{-7}} $$"
        },
        {
            "introduction": "We now synthesize our understanding of density, buoyancy, and surface forcing to explore the behavior of the thermohaline circulation as a complete system. This final practice utilizes a conceptual two-box model, a classic approach pioneered by Stommel to reveal the essential dynamics of the Atlantic Meridional Overturning Circulation (AMOC). By finding the equilibrium states of this model under different forcing conditions , you will investigate how the competition between stabilizing thermal gradients and destabilizing freshwater fluxes can give rise to multiple stable circulation patterns, a phenomenon with profound implications for climate stability and abrupt change.",
            "id": "3926295",
            "problem": "Consider a two-box representation of the Atlantic Meridional Overturning Circulation (AMOC) under the Boussinesq approximation, with one box representing low latitudes and the other representing high latitudes. Let the boxes exchange a dimensionless overturning transport $\\tilde{q}$, taken positive when the upper limb flows from low to high latitudes. Assume a linear equation of state for density anomaly with temperature and salinity differences between the boxes, and steady-state conservation of heat and salt subject to physically prescribed boundary fluxes. The goal is to compute multiple steady states for $\\tilde{q}$, if they exist, and to classify the overturning as thermally versus salinity dominated based on the relative contributions to density.\n\nFundamental base:\n- The Boussinesq approximation implies incompressibility and that density variations only affect buoyancy, not continuity.\n- The linear equation of state for seawater density anomaly is $\\Delta \\rho = \\rho_0\\left(-\\alpha \\Delta T + \\beta \\Delta S\\right)$, where $\\rho_0$ is a reference density, $\\alpha$ is the thermal expansion coefficient, $\\beta$ is the haline contraction coefficient, $\\Delta T$ is the temperature difference (low minus high latitudes), and $\\Delta S$ is the salinity difference (low minus high latitudes).\n- Steady-state scalar conservation for a well-mixed box with advection and linear surface forcing gives, for temperature, $0 = \\eta\\left(\\Delta T_\\star - \\Delta T\\right) - \\left(|\\tilde{q}| + \\kappa_T\\right)\\Delta T$ and, for salinity, $0 = f_S - \\left(|\\tilde{q}| + \\kappa_S\\right)\\Delta S^\\prime$, where $\\eta$ is a relaxation rate for temperature, $\\Delta T_\\star$ is a prescribed large-scale meridional temperature contrast, $\\kappa_T$ and $\\kappa_S$ are dimensionless symmetric mixing parameters for temperature and salinity respectively, $f_S$ is a dimensionless freshwater forcing (expressed as a virtual salt flux), and $\\Delta S^\\prime$ is the dimensionless salinity difference scaled by a characteristic salinity contrast $S_\\star$. These relations yield\n$$\nx(\\tilde{q}) = \\frac{\\Delta T}{\\Delta T_\\star} = \\frac{1}{1 + |\\tilde{q}| + \\kappa_T}, \\quad y(\\tilde{q}) = \\frac{\\Delta S^\\prime}{1} = \\frac{f_S}{|\\tilde{q}| + \\kappa_S}.\n$$\n- A hydraulic closure relates transport to the density difference, nondimensionalized as\n$$\n\\tilde{q} = c\\left(-\\alpha\\,\\Delta T_\\star\\,x(\\tilde{q}) + \\beta\\,S_\\star\\,y(\\tilde{q})\\right),\n$$\nwhere $c$ is a dimensionless proportionality constant combining geometry and friction with the relaxation scale, and $S_\\star$ is the salinity difference scaling.\n\nThe steady-state problem is therefore the nonlinear, piecewise system\n$$\n\\tilde{q} = c\\left(-\\alpha\\,\\Delta T_\\star\\,\\frac{1}{1 + |\\tilde{q}| + \\kappa_T} + \\beta\\,S_\\star\\,\\frac{f_S}{|\\tilde{q}| + \\kappa_S}\\right),\n$$\nwhich may admit multiple real solutions for $\\tilde{q}$ depending on parameters. For a given solution $\\tilde{q}$, compute the actual temperature and salinity contrasts:\n$$\n\\Delta T = \\Delta T_\\star\\,x(\\tilde{q}) = \\Delta T_\\star \\frac{1}{1 + |\\tilde{q}| + \\kappa_T}, \\quad \\Delta S = S_\\star\\,y(\\tilde{q}) = S_\\star \\frac{f_S}{|\\tilde{q}| + \\kappa_S},\n$$\nand the corresponding density contributions\n$$\nD_T = \\alpha\\,\\Delta T, \\quad D_S = \\beta\\,\\Delta S.\n$$\nClassify an equilibrium as thermally dominated if $|D_T| > |D_S|$, and as salinity dominated if $|D_S| \\ge |D_T|$.\n\nYou must write a complete, runnable program that, for a specified set of parameters and freshwater forcing values, finds all steady-state solutions for $\\tilde{q}$ on the branches $\\tilde{q} \\ge 0$ and $\\tilde{q} \\le 0$, classifies each solution, and summarizes the parameter ranges (across the tested $f_S$ values) that yield thermally dominated versus salinity dominated overturning.\n\nYour algorithm should:\n- Treat the piecewise absolute value by solving separately on $\\tilde{q} \\ge 0$ with $|\\tilde{q}| = \\tilde{q}$ and on $\\tilde{q} \\le 0$ with $|\\tilde{q}| = -\\tilde{q}$.\n- For each branch, define the function\n$$\ng_\\pm(\\tilde{q}) = c\\left(-\\alpha\\,\\Delta T_\\star\\,\\frac{1}{1 \\pm \\tilde{q} + \\kappa_T} + \\beta\\,S_\\star\\,\\frac{f_S}{\\pm \\tilde{q} + \\kappa_S}\\right) - \\tilde{q},\n$$\nwhere $+$ corresponds to $\\tilde{q} \\ge 0$ and $-$ to $\\tilde{q} \\le 0$, and find all real roots within a bounded search domain $[-Q_{\\max}, Q_{\\max}]$ with $Q_{\\max} = 100$ using robust bracketing. Discard any roots that violate the branch sign condition.\n- For each found root, compute $\\Delta T$, $\\Delta S$, $D_T$, $D_S$, and the classification.\n\nTest suite:\nDefine four test cases, each as a tuple of parameters and a list of freshwater forcing values $f_S$. Parameters are $\\alpha$ (per Kelvin), $\\beta$ (per practical salinity unit), $\\Delta T_\\star$ (Kelvin), $S_\\star$ (practical salinity unit), $\\kappa_T$ (dimensionless), $\\kappa_S$ (dimensionless), and $c$ (dimensionless). Use the following scientifically plausible values:\n- Test case $1$: $(\\alpha, \\beta, \\Delta T_\\star, S_\\star, \\kappa_T, \\kappa_S, c) = (2\\times 10^{-4}, 8\\times 10^{-4}, 25, 2, 0.3, 0.2, 80)$ with $f_S \\in \\{0.1, 0.3, 0.5, 0.7, 0.9\\}$.\n- Test case $2$: $(\\alpha, \\beta, \\Delta T_\\star, S_\\star, \\kappa_T, \\kappa_S, c) = (2\\times 10^{-4}, 8\\times 10^{-4}, 15, 3, 0.1, 0.1, 120)$ with $f_S \\in \\{0.0, 0.2, 0.4, 0.6, 0.8, 1.0\\}$.\n- Test case $3$: $(\\alpha, \\beta, \\Delta T_\\star, S_\\star, \\kappa_T, \\kappa_S, c) = (2\\times 10^{-4}, 8\\times 10^{-4}, 35, 1, 0.5, 0.5, 50)$ with $f_S \\in \\{0.05, 0.1, 0.2, 0.4\\}$.\n- Test case $4$: $(\\alpha, \\beta, \\Delta T_\\star, S_\\star, \\kappa_T, \\kappa_S, c) = (2\\times 10^{-4}, 8\\times 10^{-4}, 20, 2.5, 0.2, 0.3, 100)$ with $f_S \\in \\{0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75\\}$.\n\nFor each test case, over its $f_S$ list, compute:\n- The maximum number of steady states found across all $f_S$ values (an integer).\n- The count of $f_S$ values for which at least one thermally dominated equilibrium exists (an integer).\n- The count of $f_S$ values for which at least one salinity dominated equilibrium exists (an integer).\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the three integers in the order described above. For example, the output should look like $[ [n_1,t_1,s_1],[n_2,t_2,s_2],\\dots ]$. All outputs are dimensionless and must be reported with no physical units attached. Angles are not involved in this problem, so no angle unit specification is required, and no percentages are requested.",
            "solution": "The problem requires writing a program to find the steady-state solutions for the dimensionless overturning transport, $\\tilde{q}$, in a two-box model of the AMOC. The core of the problem is to find the roots of the nonlinear equation:\n$$ f(\\tilde{q}) = \\tilde{q} - c\\left(-\\alpha\\,\\Delta T_\\star\\,\\frac{1}{1 + |\\tilde{q}| + \\kappa_T} + \\beta\\,S_\\star\\,\\frac{f_S}{|\\tilde{q}| + \\kappa_S}\\right) = 0 $$\nDue to the absolute value term $|\\tilde{q}|$, the equation is piecewise and must be solved on two separate branches.\n\n**1. Positive Branch ($\\tilde{q} \\ge 0$)**\nFor this branch, $|\\tilde{q}| = \\tilde{q}$. The equation to solve is:\n$$ f_+(\\tilde{q}) = \\tilde{q} - c\\left(-\\alpha\\,\\Delta T_\\star\\,\\frac{1}{1 + \\tilde{q} + \\kappa_T} + \\beta\\,S_\\star\\,\\frac{f_S}{\\tilde{q} + \\kappa_S}\\right) = 0 $$\nWe seek roots of $f_+(\\tilde{q})$ in the domain $[0, Q_{\\max}]$.\n\n**2. Negative Branch ($\\tilde{q} \\le 0$)**\nFor this branch, $|\\tilde{q}| = -\\tilde{q}$. The equation becomes:\n$$ f_-(\\tilde{q}) = \\tilde{q} - c\\left(-\\alpha\\,\\Delta T_\\star\\,\\frac{1}{1 - \\tilde{q} + \\kappa_T} + \\beta\\,S_\\star\\,\\frac{f_S}{-\\tilde{q} + \\kappa_S}\\right) = 0 $$\nWe seek roots of $f_-(\\tilde{q})$ in the domain $[-Q_{\\max}, 0]$. The denominators remain positive since $\\tilde{q} \\le 0$ and the mixing parameters $\\kappa_T, \\kappa_S$ are positive.\n\n**3. Numerical Implementation**\nThe provided Python code implements a robust root-finding strategy:\n- It defines functions `f_plus` and `f_minus` corresponding to the two branches.\n- For each branch, it discretizes the search domain and scans for intervals where the function changes sign. This indicates the presence of a root.\n- The `scipy.optimize.brentq` function, a reliable bracketing root-finder, is then used on each such interval to locate the root with high precision.\n- After finding all unique roots $\\tilde{q}$ for a given set of parameters and forcing $f_S$, the code proceeds to classify each equilibrium state.\n\n**4. Classification of Equilibria**\nFor each root $\\tilde{q}$, the code calculates the absolute magnitudes of the thermal and saline density contributions, $|D_T|$ and $|D_S|$:\n$$ |D_T| = \\alpha\\,\\Delta T_\\star \\frac{1}{1 + |\\tilde{q}| + \\kappa_T} $$\n$$ |D_S| = \\beta\\,S_\\star \\frac{f_S}{|\\tilde{q}| + \\kappa_S} $$\nThe classification follows the specified criteria:\n- **Thermally dominated:** $|D_T| > |D_S|$\n- **Salinity dominated:** $|D_S| \\ge |D_T|$\n\nThe program iterates through all test cases and their associated $f_S$ values, computes all solutions, classifies them, and aggregates the results into the required output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the two-box AMOC model for multiple equilibria across a range of\n    freshwater forcings for four different parameter sets.\n    \"\"\"\n\n    # Define the four test cases as per the problem statement.\n    test_cases = [\n        {\n            \"params\": (2e-4, 8e-4, 25, 2, 0.3, 0.2, 80),\n            \"fS_values\": [0.1, 0.3, 0.5, 0.7, 0.9]\n        },\n        {\n            \"params\": (2e-4, 8e-4, 15, 3, 0.1, 0.1, 120),\n            \"fS_values\": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]\n        },\n        {\n            \"params\": (2e-4, 8e-4, 35, 1, 0.5, 0.5, 50),\n            \"fS_values\": [0.05, 0.1, 0.2, 0.4]\n        },\n        {\n            \"params\": (2e-4, 8e-4, 20, 2.5, 0.2, 0.3, 100),\n            \"fS_values\": [0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75]\n        }\n    ]\n\n    all_results = []\n    Q_max = 100.0  # Search domain [-Q_max, Q_max]\n    num_scan_points = 2001 # Number of points to scan for root bracketing\n    root_tolerance = 1e-9\n\n    def find_all_roots(func, domain_min, domain_max, args):\n        \"\"\"Finds all roots of a function in a domain by scanning for sign changes.\"\"\"\n        roots = []\n        domain = np.linspace(domain_min, domain_max, num_scan_points)\n        f_vals = func(domain, *args)\n        \n        for i in range(len(domain) - 1):\n            if f_vals[i] * f_vals[i+1]  0:\n                try:\n                    root = optimize.brentq(func, domain[i], domain[i+1], args=args)\n                    \n                    # Avoid adding duplicate roots\n                    is_duplicate = False\n                    for r in roots:\n                        if abs(root - r)  root_tolerance:\n                            is_duplicate = True\n                            break\n                    if not is_duplicate:\n                        roots.append(root)\n\n                except ValueError:\n                    # brentq can fail if values at endpoints have the same sign,\n                    # which can happen with floating point inaccuracies. Pass.\n                    pass\n        return roots\n\n    for case in test_cases:\n        alpha, beta, delta_T_star, S_star, kappa_T, kappa_S, c = case[\"params\"]\n        fS_values = case[\"fS_values\"]\n\n        max_num_states = 0\n        thermal_count = 0\n        salinity_count = 0\n\n        for f_S in fS_values:\n            args = (alpha, beta, delta_T_star, S_star, kappa_T, kappa_S, c, f_S)\n\n            # Define the functions for the two branches (q >= 0 and q = 0)\n            def f_plus(q, alpha, beta, delta_T_star, S_star, kappa_T, kappa_S, c, f_S):\n                term_T = -alpha * delta_T_star / (1 + q + kappa_T)\n                term_S = beta * S_star * f_S / (q + kappa_S)\n                return q - c * (term_T + term_S)\n\n            def f_minus(q, alpha, beta, delta_T_star, S_star, kappa_T, kappa_S, c, f_S):\n                term_T = -alpha * delta_T_star / (1 - q + kappa_T)\n                term_S = beta * S_star * f_S / (-q + kappa_S)\n                return q - c * (term_T + term_S)\n            \n            solutions = []\n\n            # Check for root at q=0\n            if f_S > 0: # Avoid division by zero if kappa_S is 0\n                val_at_zero = -c * (\n                    -alpha * delta_T_star / (1 + kappa_T) +\n                    beta * S_star * f_S / kappa_S\n                )\n                if abs(val_at_zero)  root_tolerance:\n                    solutions.append(0.0)\n\n            # Find roots on q > 0 branch\n            positive_roots = find_all_roots(f_plus, root_tolerance, Q_max, args)\n            solutions.extend(positive_roots)\n\n            # Find roots on q  0 branch\n            negative_roots = find_all_roots(f_minus, -Q_max, -root_tolerance, args)\n            solutions.extend(negative_roots)\n\n            max_num_states = max(max_num_states, len(solutions))\n            \n            has_thermal = False\n            has_salinity = False\n            \n            if solutions:\n                for q_tilde in solutions:\n                    q_abs = abs(q_tilde)\n                    \n                    # Calculate density contributions\n                    D_T_abs = alpha * delta_T_star / (1 + q_abs + kappa_T)\n                    D_S_abs = beta * S_star * f_S / (q_abs + kappa_S)\n                    \n                    # Classify\n                    if D_T_abs > D_S_abs:\n                        has_thermal = True\n                    else: # D_S_abs >= D_T_abs\n                        has_salinity = True\n            \n            if has_thermal:\n                thermal_count += 1\n            if has_salinity:\n                salinity_count += 1\n        \n        all_results.append([max_num_states, thermal_count, salinity_count])\n\n    # Format the final output string exactly as specified.\n    # str() on a list produces the correct \"[v1, v2, ...]\" format.\n    result_str = \",\".join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}