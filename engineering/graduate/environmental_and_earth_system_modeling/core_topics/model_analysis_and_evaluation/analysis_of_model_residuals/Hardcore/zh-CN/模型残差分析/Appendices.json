{
    "hands_on_practices": [
        {
            "introduction": "任何稳健的模型评估都始于对其残差（即观测值与预测值之差）的详尽分析。第一个实践练习将通过计算残差时间序列的三个基本描述性统计量——均值、方差和一阶自相关——为您奠定基础。通过从第一性原理出发实现这些计算，您将具体理解这些指标如何揭示系统性模型偏差和时间依赖性，而这些都是水文建模中的常见问题。",
            "id": "3862150",
            "problem": "考虑一个月度水文时间序列的背景，其中观测径流量 $Q_t$（单位为立方米/秒，记作 $\\mathrm{m^3/s}$）与模型估算的径流量 $\\hat{Q}_t$ 配对，时间步长为 $t = 1, \\dots, n$。将时间 $t$ 的模型残差定义为 $r_t = Q_t - \\hat{Q}_t$，单位为 $\\mathrm{m^3/s}$。从第一性原理的角度出发，使用描述性统计和时间序列分析（自相关函数 (ACF)）中的经典样本定义，计算残差序列的三个汇总统计量：样本均值、无偏样本方差和滞后1阶的样本自相关。滞后1阶自相关必须通过连续残差距平（相对于其样本均值）之间的相关性来计算。如果在某个案例中 $r_t$ 的样本方差为零，则按惯例将滞后1阶自相关定义为 $0$。以 $\\mathrm{m^3/s}$ 为单位表示平均残差，以 $(\\mathrm{m^3/s})^2$ 为单位表示方差，滞后1阶自相关则表示为无单位的纯数。本任务不涉及角度。\n\n仅从基础定义（样本均值、无偏样本方差和通过样本协方差计算的样本自相关）出发，实现一个程序来为每个提供的测试案例生成这三个残差汇总统计量。问题陈述中不允许使用任何简化公式；解决方案必须从核心定义推导得出。\n\n使用以下测试套件。每个测试案例提供序列 $(Q_t)_{t=1}^n$ 和 $(\\hat{Q}_t)_{t=1}^n$：\n\n- 测试案例1（季节性模型偏差，$n = 12$）：\n  - $Q_t = \\{42, 55, 60, 75, 110, 160, 190, 175, 140, 100, 70, 50\\}$。\n  - $\\hat{Q}_t = \\{40, 50, 58, 80, 120, 150, 180, 170, 130, 95, 75, 55\\}$。\n\n- 测试案例2（完美模型，$n = 12$）：\n  - $Q_t = \\{60, 65, 70, 90, 130, 170, 200, 190, 150, 110, 80, 60\\}$。\n  - $\\hat{Q}_t = \\{60, 65, 70, 90, 130, 170, 200, 190, 150, 110, 80, 60\\}$。\n\n- 测试案例3（恒定偏差，$n = 12$）：\n  - $Q_t = \\{42, 55, 60, 75, 110, 160, 190, 175, 140, 100, 70, 50\\}$。\n  - $\\hat{Q}_t = \\{22, 35, 40, 55, 90, 140, 170, 155, 120, 80, 50, 30\\}$。\n\n- 测试案例4（残差中存在强正序列相关性，$n = 12$）：\n  - $Q_t = \\{50, 60, 70, 90, 120, 160, 190, 180, 150, 110, 80, 60\\}$。\n  - $\\hat{Q}_t = \\{45, 52, 58, 75, 103, 141, 170, 162, 134, 96, 70, 53\\}$。\n\n- 测试案例5（交替残差，负序列相关性，$n = 12$）：\n  - $Q_t = \\{50, 60, 70, 90, 120, 160, 190, 180, 150, 110, 80, 60\\}$。\n  - $\\hat{Q}_t = \\{40, 70, 61, 99, 112, 168, 183, 187, 156, 104, 85, 55\\}$。\n\n- 测试案例6（最小长度的边界情况，$n = 2$）：\n  - $Q_t = \\{100, 120\\}$。\n  - $\\hat{Q}_t = \\{95, 130\\}$。\n\n对每个测试案例，计算：\n- 样本均值 $\\bar{r}$（单位：$\\mathrm{m^3/s}$）。\n- 无偏样本方差 $s_r^2$（单位：$(\\mathrm{m^3/s})^2$）。\n- 滞后1阶自相关 $\\rho_1$（无单位）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例的结果必须是一个包含三个小数值 $\\left[\\bar{r}, s_r^2, \\rho_1\\right]$ 的列表，并四舍五入到 $6$ 位小数，并且总输出必须是这些列表按测试案例顺序组成的列表，例如：$\\left[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots\\right]$。",
            "solution": "此问题经评估为有效。它在科学上基于时间序列分析和描述性统计学的原理，并应用于环境模型评估。问题陈述清晰，提供了计算唯一且有意义解所需的所有数据和定义。语言客观而精确。我将按照要求，从第一性原理出发推导解决方案。\n\n任务是为模型残差的时间序列 $r_t = Q_t - \\hat{Q}_t$ 计算三个统计汇总量，其中 $Q_t$ 是观测径流量，$\\hat{Q}_t$ 是模型在时间 $t$ 估算的径流量，时间步长为 $t = 1, \\dots, n$。所需的汇总量是样本均值 ($\\bar{r}$)、无偏样本方差 ($s_r^2$) 和滞后1阶样本自相关 ($\\rho_1$)。\n\n设残差序列为 $r = \\{r_1, r_2, \\dots, r_n\\}$。\n\n**1. 样本均值 ($\\bar{r}$)**\n\n样本均值是残差值的算术平均值。这是样本分布的一阶矩。其经典定义是所有观测值之和除以观测值数量 $n$。\n\n$$ \\bar{r} = \\frac{1}{n} \\sum_{t=1}^{n} r_t $$\n\n$\\bar{r}$ 的单位与 $r_t$ 的单位相同，即 $\\mathrm{m^3/s}$。\n\n**2. 无偏样本方差 ($s_r^2$)**\n\n无偏样本方差衡量数据围绕样本均值的离散程度。“无偏”一词表示分母是 $n-1$，这修正了因使用样本均值而非真实（但未知）的总体均值而引入的偏差。其定义为与样本均值的离差平方和除以 $n-1$。\n\n$$ s_r^2 = \\frac{1}{n-1} \\sum_{t=1}^{n} (r_t - \\bar{r})^2 $$\n\n该定义对 $n > 1$ 有效。所有提供的测试案例都满足此条件。$s_r^2$ 的单位是 $r_t$ 单位的平方，即 $(\\mathrm{m^3/s})^2$。\n\n**3. 滞后1阶样本自相关 ($\\rho_1$)**\n\n滞后1阶样本自相关衡量残差值 $r_t$ 与其后继残差值 $r_{t+1}$ 之间的线性关系。问题要求其计算“使用连续残差距平（相对于其样本均值）之间的相关性”。这对应于样本自相关函数 (ACF) 在滞后1阶的标准定义，即滞后1阶的样本自协方差除以样本方差（或滞后0阶的自协方差）。\n\n滞后 $k$ 阶的样本自协方差，记作 $\\hat{\\gamma}(k)$，定义为：\n$$ \\hat{\\gamma}(k) = \\frac{1}{n} \\sum_{t=1}^{n-k} (r_t - \\bar{r})(r_{t+k} - \\bar{r}) $$\n\n对于滞后 $k=1$，自协方差为：\n$$ \\hat{\\gamma}(1) = \\frac{1}{n} \\sum_{t=1}^{n-1} (r_t - \\bar{r})(r_{t+1} - \\bar{r}) $$\n\n样本方差，即滞后 $k=0$ 时的自协方差，为：\n$$ \\hat{\\gamma}(0) = \\frac{1}{n} \\sum_{t=1}^{n} (r_t - \\bar{r})^2 $$\n\n滞后1阶样本自相关 $\\rho_1$ 是 $\\hat{\\gamma}(1)$ 与 $\\hat{\\gamma}(0)$ 的比值。分子和分母中的因子 $1/n$ 可以消去。\n\n$$ \\rho_1 = \\frac{\\hat{\\gamma}(1)}{\\hat{\\gamma}(0)} = \\frac{\\frac{1}{n} \\sum_{t=1}^{n-1} (r_t - \\bar{r})(r_{t+1} - \\bar{r})}{\\frac{1}{n} \\sum_{t=1}^{n} (r_t - \\bar{r})^2} = \\frac{\\sum_{t=1}^{n-1} (r_t - \\bar{r})(r_{t+1} - \\bar{r})}{\\sum_{t=1}^{n} (r_t - \\bar{r})^2} $$\n\n$\\rho_1$ 是一个无量纲的纯数，因为分子中的单位 $(\\mathrm{m^3/s})^2$ 与分母中的单位相抵消。根据问题陈述，必须处理一个特殊情况：如果样本方差为零，即分母 $\\sum_{t=1}^{n} (r_t - \\bar{r})^2$ 为零，则将 $\\rho_1$ 定义为 $0$。这个惯例避免了除以零。这种情况当且仅当所有残差 $r_t$ 相同时发生，此时 $s_r^2=0$。\n\n程序实现将针对每个提供的测试案例，遵循这三个推导出的公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes residual summaries for multiple test cases and prints the results.\n    The summaries are: sample mean, unbiased sample variance, and lag-1 autocorrelation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (seasonal model bias, n = 12)\n        (\n            np.array([42, 55, 60, 75, 110, 160, 190, 175, 140, 100, 70, 50], dtype=np.float64),\n            np.array([40, 50, 58, 80, 120, 150, 180, 170, 130, 95, 75, 55], dtype=np.float64)\n        ),\n        # Test Case 2 (perfect model, n = 12)\n        (\n            np.array([60, 65, 70, 90, 130, 170, 200, 190, 150, 110, 80, 60], dtype=np.float64),\n            np.array([60, 65, 70, 90, 130, 170, 200, 190, 150, 110, 80, 60], dtype=np.float64)\n        ),\n        # Test Case 3 (constant bias, n = 12)\n        (\n            np.array([42, 55, 60, 75, 110, 160, 190, 175, 140, 100, 70, 50], dtype=np.float64),\n            np.array([22, 35, 40, 55, 90, 140, 170, 155, 120, 80, 50, 30], dtype=np.float64)\n        ),\n        # Test Case 4 (strong positive serial dependence in residuals, n = 12)\n        (\n            np.array([50, 60, 70, 90, 120, 160, 190, 180, 150, 110, 80, 60], dtype=np.float64),\n            np.array([45, 52, 58, 75, 103, 141, 170, 162, 134, 96, 70, 53], dtype=np.float64)\n        ),\n        # Test Case 5 (alternating residuals, negative serial dependence, n = 12)\n        (\n            np.array([50, 60, 70, 90, 120, 160, 190, 180, 150, 110, 80, 60], dtype=np.float64),\n            np.array([40, 70, 61, 99, 112, 168, 183, 187, 156, 104, 85, 55], dtype=np.float64)\n        ),\n        # Test Case 6 (boundary case with minimal length, n = 2)\n        (\n            np.array([100, 120], dtype=np.float64),\n            np.array([95, 130], dtype=np.float64)\n        )\n    ]\n    \n    results_list = []\n    \n    for Q_t, Q_hat_t in test_cases:\n        \n        # 0. Calculate the residual series r_t = Q_t - Q_hat_t\n        r_t = Q_t - Q_hat_t\n        n = len(r_t)\n\n        # 1. Compute the sample mean of residuals, r_bar\n        # Formula: r_bar = (1/n) * sum(r_t) for t=1 to n\n        r_bar = np.mean(r_t)\n\n        # 2. Compute the unbiased sample variance, s_r^2\n        # Formula: s_r^2 = (1/(n-1)) * sum((r_t - r_bar)^2) for t=1 to n\n        # numpy.var with ddof=1 calculates the unbiased sample variance.\n        # This check is only for n=1, but all test cases have n>1.\n        if n > 1:\n            s_r_sq = np.var(r_t, ddof=1)\n        else:\n            s_r_sq = 0.0\n\n        # 3. Compute the lag-1 autocorrelation, rho_1\n        # Formula: rho_1 = sum((r_t - r_bar)(r_{t+1} - r_bar)) / sum((r_t - r_bar)^2)\n        # The sum in the numerator is from t=1 to n-1.\n        \n        # Calculate deviations from the mean (anomalies)\n        anomalies = r_t - r_bar\n        \n        # Calculate the denominator: sum of squared anomalies\n        sum_sq_anomalies = np.sum(anomalies**2)\n\n        # Handle the case where variance is zero, as specified in the problem\n        if sum_sq_anomalies < 1e-12: # Use a small tolerance for float comparison\n            rho_1 = 0.0\n        else:\n            # Numerator: sum of products of consecutive anomalies\n            # anomalies[:-1] is {r_1-r_bar, ..., r_{n-1}-r_bar}\n            # anomalies[1:] is {r_2-r_bar, ..., r_n-r_bar}\n            numerator = np.sum(anomalies[:-1] * anomalies[1:])\n            rho_1 = numerator / sum_sq_anomalies\n        \n        # Store results for this case, formatted to 6 decimal places\n        case_result = [r_bar, s_r_sq, rho_1]\n        results_list.append(case_result)\n\n    # Format the final output string as a list of lists.\n    # Each sublist contains the three computed values rounded to 6 decimal places.\n    output_parts = []\n    for res in results_list:\n        # Format each number to 6 decimal places (f-string with :.6f)\n        # and create the string for one sub-list, e.g., \"[val1,val2,val3]\"\n        formatted_res = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        output_parts.append(formatted_res)\n\n    # Join the sub-list strings with commas and enclose in brackets,\n    # e.g., \"[[...],[...]]\"\n    final_output = f\"[{','.join(output_parts)}]\"\n\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "尽管均值和方差等汇总统计量能提供总体情况，但误差度量本身的选择会显著影响我们对模型性能的看法。本练习旨在探讨两种广泛使用的度量指标——均方根误差（$RMSE$）和平均绝对误差（$MAE$）——之间的关键区别。通过一个可控的数值实验，您将放大最大的残差，从而直接观察并量化$RMSE$的平方项如何使其对异常值比$MAE$敏感得多，这对于在存在极端事件时批判性地评估模型至关重要。",
            "id": "3862083",
            "problem": "您将进行一项确定性实验，以在环境和地球系统模型的残差分析背景下，量化误差度量对离群值的敏感性。设残差向量表示为 $\\mathbf{r} = (r_1, r_2, \\dots, r_n) \\in \\mathbb{R}^n$，其中 $n \\in \\mathbb{N}$。均方根误差 (RMSE) 和平均绝对误差 (MAE) 定义如下\n$$\n\\mathrm{RMSE}(\\mathbf{r}) = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} r_i^2}, \\quad \\mathrm{MAE}(\\mathbf{r}) = \\frac{1}{n}\\sum_{i=1}^{n} |r_i|.\n$$\n为了模拟离群值的影响，您将使用一个非负缩放因子来扰动一部分残差。给定一个比例 $f \\in [0,1]$，定义 $m = \\lfloor f n \\rfloor$。通过选择与 $|r_i|$ 最大值相对应的 $m$ 个索引来构建大小为 $m$ 的索引集 $\\mathcal{S} \\subset \\{1,2,\\dots,n\\}$，若 $|r_i|$ 值相同，则优先选择较小的索引（即，按 $|r_i|$ 降序排序，然后按索引升序排序）。对于给定的缩放因子 $c \\ge 0$，定义扰动后的残差向量 $\\mathbf{r}'$ 如下：\n$$\nr'_i = \\begin{cases}\nc \\, r_i,  \\text{if } i \\in \\mathcal{S},\\\\\nr_i,  \\text{if } i \\notin \\mathcal{S}.\n\\end{cases}\n$$\n对每个测试用例，计算：\n- 变化量 $\\Delta \\mathrm{RMSE} = \\mathrm{RMSE}(\\mathbf{r}') - \\mathrm{RMSE}(\\mathbf{r})$ 和 $\\Delta \\mathrm{MAE} = \\mathrm{MAE}(\\mathbf{r}') - \\mathrm{MAE}(\\mathbf{r})$，\n- 比率 $\\rho_{\\mathrm{RMSE}} = \\mathrm{RMSE}(\\mathbf{r}') / \\mathrm{RMSE}(\\mathbf{r})$ 和 $\\rho_{\\mathrm{MAE}} = \\mathrm{MAE}(\\mathbf{r}') / \\mathrm{MAE}(\\mathbf{r})$。\n\n如果基准分母为零，当分子为正时，定义比率为 $+\\infty$；当分子和分母都为零时，定义比率为 $1$。\n\n您的程序必须为以下测试套件计算这些量。在每个案例中，都指定了残差向量 $\\mathbf{r}$、比例 $f$ 和缩放因子 $c$：\n\n- 测试用例 1：$\\mathbf{r} = [0.2, -0.1, 0.3, -1.5, 0.7, 0.0, 1.2, -0.4, 0.6, -0.3, 2.5, -0.2, 0.1, -0.9, 0.8, -0.7, 0.4, -0.6, 0.05, -0.05]$, $f = 0.1$, $c = 3.0$.\n- 测试用例 2：$\\mathbf{r} = [-0.2, 0.2, -0.2, 0.2, 0.0, 0.0, 0.1, -0.1, 0.15, -0.15]$, $f = 0.0$, $c = 10.0$.\n- 测试用例 3：$\\mathbf{r} = [1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0]$, $f = 1.0$, $c = 2.0$.\n- 测试用例 4：$\\mathbf{r} = [0.05, -0.04, 0.06, -0.07, 0.08, -0.09, 0.1, -0.11, 0.12, -0.13, 5.0, -0.14]$, $f = 0.1$, $c = 5.0$.\n- 测试用例 5：$\\mathbf{r} = [0.9, -1.1, 0.8, -0.7, 0.6, -0.5, 0.4, -0.3, 0.2, -0.1, 0.05, -0.05, 0.0, 1.5, -1.4]$, $f = 0.2$, $c = 0.5$.\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个包含四个浮点数的嵌套列表，顺序为 $[\\Delta \\mathrm{RMSE}, \\Delta \\mathrm{MAE}, \\rho_{\\mathrm{RMSE}}, \\rho_{\\mathrm{MAE}}]$。每个浮点数必须四舍五入到恰好六位小数。例如，对于三个假设的用例，一个有效的输出格式将是\n[[0.123456,-0.000001,1.234567,0.999999],[0.000000,0.000000,1.000000,1.000000],[0.010000,0.005000,1.010000,1.005000]].",
            "solution": "该问题陈述是一项定义明确的数值敏感性分析练习，其基础是标准的统计度量。它在科学上是合理的，内容完整，且算法上已明确指定。因此，该问题是有效的，可以推导出解决方案。\n\n任务是在扰动给定残差向量的一个子集后，计算两种误差度量——均方根误差 (RMSE) 和平均绝对误差 (MAE)——的变化量和比率。设原始残差向量为 $\\mathbf{r} = (r_1, r_2, \\dots, r_n) \\in \\mathbb{R}^n$。RMSE 和 MAE 的定义如下：\n$$\n\\mathrm{RMSE}(\\mathbf{r}) = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} r_i^2}\n$$\n$$\n\\mathrm{MAE}(\\mathbf{r}) = \\frac{1}{n}\\sum_{i=1}^{n} |r_i|\n$$\n扰动向量 $\\mathbf{r}'$ 是基于比例 $f \\in [0,1]$ 和缩放因子 $c \\ge 0$ 构建的。待扰动元素的数量为 $m = \\lfloor f n \\rfloor$。这些元素的索引集（表示为 $\\mathcal{S}$）对应于 $|r_i|$ 的 $m$ 个最大值，若值相同则优先选择较小的索引。扰动定义如下：\n$$\nr'_i = \\begin{cases}\nc \\, r_i,  \\text{if } i \\in \\mathcal{S},\\\\\nr_i,  \\text{if } i \\notin \\mathcal{S}.\n\\end{cases}\n$$\n我们需要计算 $\\Delta \\mathrm{RMSE} = \\mathrm{RMSE}(\\mathbf{r}') - \\mathrm{RMSE}(\\mathbf{r})$、$\\Delta \\mathrm{MAE} = \\mathrm{MAE}(\\mathbf{r}') - \\mathrm{MAE}(\\mathbf{r})$、$\\rho_{\\mathrm{RMSE}} = \\mathrm{RMSE}(\\mathbf{r}') / \\mathrm{RMSE}(\\mathbf{r})$ 和 $\\rho_{\\mathrm{MAE}} = \\mathrm{MAE}(\\mathbf{r}') / \\mathrm{MAE}(\\mathbf{r})$。\n\n首先，让我们建立 $\\mathrm{RMSE}(\\mathbf{r}')$ 和 $\\mathrm{MAE}(\\mathbf{r}')$ 的表达式。为了高效地完成此任务，我们可以分析平方和与绝对值之和的变化。\n\n设 $S_2(\\mathbf{r}) = \\sum_{i=1}^{n} r_i^2$ 且 $S_1(\\mathbf{r}) = \\sum_{i=1}^{n} |r_i|$。\n那么，$\\mathrm{RMSE}(\\mathbf{r}) = \\sqrt{S_2(\\mathbf{r})/n}$ 且 $\\mathrm{MAE}(\\mathbf{r}) = S_1(\\mathbf{r})/n$。\n\n扰动向量 $\\mathbf{r}'$ 的平方和为：\n$$\nS_2(\\mathbf{r}') = \\sum_{i=1}^{n} (r'_i)^2 = \\sum_{i \\in \\mathcal{S}} (c r_i)^2 + \\sum_{i \\notin \\mathcal{S}} (r_i)^2\n$$\n$$\nS_2(\\mathbf{r}') = c^2 \\sum_{i \\in \\mathcal{S}} r_i^2 + \\left( \\sum_{i=1}^{n} r_i^2 - \\sum_{i \\in \\mathcal{S}} r_i^2 \\right) = \\sum_{i=1}^{n} r_i^2 + (c^2 - 1) \\sum_{i \\in \\mathcal{S}} r_i^2\n$$\n因此，$S_2(\\mathbf{r}') = S_2(\\mathbf{r}) + (c^2 - 1) \\sum_{i \\in \\mathcal{S}} r_i^2$。\n扰动后的 RMSE 为：\n$$\n\\mathrm{RMSE}(\\mathbf{r}') = \\sqrt{\\frac{S_2(\\mathbf{r}')}{n}} = \\sqrt{\\frac{S_2(\\mathbf{r}) + (c^2 - 1) \\sum_{i \\in \\mathcal{S}} r_i^2}{n}}\n$$\n\n类似地，$\\mathbf{r}'$ 的绝对值之和为（注意 $c \\ge 0$）：\n$$\nS_1(\\mathbf{r}') = \\sum_{i=1}^{n} |r'_i| = \\sum_{i \\in \\mathcal{S}} |c r_i| + \\sum_{i \\notin \\mathcal{S}} |r_i| = c \\sum_{i \\in \\mathcal{S}} |r_i| + \\sum_{i \\notin \\mathcal{S}} |r_i|\n$$\n$$\nS_1(\\mathbf{r}') = c \\sum_{i \\in \\mathcal{S}} |r_i| + \\left( \\sum_{i=1}^{n} |r_i| - \\sum_{i \\in \\mathcal{S}} |r_i| \\right) = \\sum_{i=1}^{n} |r_i| + (c - 1) \\sum_{i \\in \\mathcal{S}} |r_i|\n$$\n因此，$S_1(\\mathbf{r}') = S_1(\\mathbf{r}) + (c - 1) \\sum_{i \\in \\mathcal{S}} |r_i|$。\n扰动后的 MAE 为：\n$$\n\\mathrm{MAE}(\\mathbf{r}') = \\frac{S_1(\\mathbf{r}')}{n} = \\frac{S_1(\\mathbf{r}) + (c - 1) \\sum_{i \\in \\mathcal{S}} |r_i|}{n}\n$$\n\n每个测试用例的算法流程如下：\n1.  对于给定的残差向量 $\\mathbf{r}$、比例 $f$ 和缩放因子 $c$：\n2.  确定向量的大小 $n$。\n3.  计算要扰动的残差数量 $m = \\lfloor f n \\rfloor$。\n4.  如果 $m = 0$，则不发生扰动。$\\mathbf{r}' = \\mathbf{r}$，因此 $\\Delta \\mathrm{RMSE}=0$，$\\Delta \\mathrm{MAE}=0$，$\\rho_{\\mathrm{RMSE}}=1$，且 $\\rho_{\\mathrm{MAE}}=1$。\n5.  如果 $m > 0$，则识别索引集 $\\mathcal{S}$。这需要根据 $|r_i|$ 按降序对索引进行排序，并使用原始索引值作为升序的决胜规则。此排序列表中的前 $m$ 个索引构成 $\\mathcal{S}$。\n6.  计算基准度量：$\\mathrm{RMSE}(\\mathbf{r})$ 和 $\\mathrm{MAE}(\\mathbf{r})$。\n7.  计算子集 $\\mathcal{S}$ 上的总和：$\\sum_{i \\in \\mathcal{S}} r_i^2$ 和 $\\sum_{i \\in \\mathcal{S}} |r_i|$。\n8.  使用推导出的公式计算扰动后的度量：$\\mathrm{RMSE}(\\mathbf{r}')$ 和 $\\mathrm{MAE}(\\mathbf{r}')$。\n9.  计算差值 $\\Delta \\mathrm{RMSE}$ 和 $\\Delta \\mathrm{MAE}$。\n10. 计算比率 $\\rho_{\\mathrm{RMSE}}$ 和 $\\rho_{\\mathrm{MAE}}$。必须遵守除以零的规则：如果分母为 $0$，若分子也为 $0$，则比率为 $1$；若分子为正，则比率为 $+\\infty$。对于给定的问题，分母为零意味着原始向量 $\\mathbf{r}$ 是一个零向量，这反过来又意味着扰动后的向量 $\\mathbf{r}'$ 也是一个零向量。因此，分母为零而分子非零的情况不会发生，比率为 $1$。\n\n将为提供的每个测试用例实施此流程。最终的数值结果将四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes sensitivity of RMSE and MAE to outliers for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, f, c)\n        (np.array([0.2, -0.1, 0.3, -1.5, 0.7, 0.0, 1.2, -0.4, 0.6, -0.3, 2.5, -0.2, 0.1, -0.9, 0.8, -0.7, 0.4, -0.6, 0.05, -0.05]), 0.1, 3.0),\n        (np.array([-0.2, 0.2, -0.2, 0.2, 0.0, 0.0, 0.1, -0.1, 0.15, -0.15]), 0.0, 10.0),\n        (np.array([1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0]), 1.0, 2.0),\n        (np.array([0.05, -0.04, 0.06, -0.07, 0.08, -0.09, 0.1, -0.11, 0.12, -0.13, 5.0, -0.14]), 0.1, 5.0),\n        (np.array([0.9, -1.1, 0.8, -0.7, 0.6, -0.5, 0.4, -0.3, 0.2, -0.1, 0.05, -0.05, 0.0, 1.5, -1.4]), 0.2, 0.5),\n    ]\n\n    all_results = []\n    \n    for r, f, c in test_cases:\n        n = len(r)\n        \n        # Calculate baseline metrics\n        sum_sq_r = np.sum(r**2)\n        sum_abs_r = np.sum(np.abs(r))\n        \n        rmse_r = np.sqrt(sum_sq_r / n)\n        mae_r = sum_abs_r / n\n\n        # Determine the number of residuals to perturb\n        m = int(np.floor(f * n))\n        \n        if m == 0:\n            # No perturbation, so changes are 0 and ratios are 1\n            delta_rmse = 0.0\n            delta_mae = 0.0\n            rho_rmse = 1.0\n            rho_mae = 1.0\n        else:\n            # Identify the index set S\n            # Sort indices by descending |r_i| and then by ascending index for tie-breaking\n            indices = sorted(range(n), key=lambda i: (-np.abs(r[i]), i))\n            s_indices = indices[:m]\n            \n            # Get the residuals in S\n            r_s = r[s_indices]\n            \n            # Calculate sums over the subset S\n            sum_sq_s = np.sum(r_s**2)\n            sum_abs_s = np.sum(np.abs(r_s))\n            \n            # Calculate perturbed sums\n            sum_sq_r_prime = sum_sq_r + (c**2 - 1) * sum_sq_s\n            sum_abs_r_prime = sum_abs_r + (c - 1) * sum_abs_s\n            \n            # Calculate perturbed metrics\n            rmse_r_prime = np.sqrt(sum_sq_r_prime / n)\n            mae_r_prime = sum_abs_r_prime / n\n            \n            # Calculate changes\n            delta_rmse = rmse_r_prime - rmse_r\n            delta_mae = mae_r_prime - mae_r\n\n            # Calculate ratios, handling zero denominator case\n            if rmse_r == 0:\n                # If rmse_r is 0, r is a zero vector, so r' is also zero vector, and rmse_r_prime is 0.\n                # Per problem spec, ratio is 1 if both are 0.\n                rho_rmse = 1.0\n            else:\n                rho_rmse = rmse_r_prime / rmse_r\n\n            if mae_r == 0:\n                # Same logic for MAE\n                rho_mae = 1.0\n            else:\n                rho_mae = mae_r_prime / mae_r\n\n        # Store results for this case, formatted to 6 decimal places\n        case_results = [\n            f\"{delta_rmse:.6f}\",\n            f\"{delta_mae:.6f}\",\n            f\"{rho_rmse:.6f}\",\n            f\"{rho_mae:.6f}\"\n        ]\n        all_results.append(f\"[{','.join(case_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了评估模型的整体性能外，诊断单个数据点对回归模型的影响也至关重要。这个高级实践将指导您计算关键的诊断统计量——杠杆值（$h_{ii}$）、学生化残差（$t_i$）和库克距离（$D_i$）——以识别营养物负荷模型中的强影响点。掌握这些技术将使您能够精确定位可能是异常值或具有高杠杆作用的数据点，从而确保您的模型结论是稳健的，并且不被少数异常测量值所扭曲。",
            "id": "3862109",
            "problem": "您正在分析一个用于环境与地球系统建模的线性普通最小二乘 (OLS) 回归的残差，该回归模型用于根据河流流量和水温估计每日的河流营养物负荷。考虑一个带截距的线性模型，其中响应变量是每日营养物负荷（单位：千克/天），预测变量是流量（单位：立方米/秒）和水温（单位：摄氏度）。使用以下模型设定：\n给定 $n$ 个观测值，定义设计矩阵 $X \\in \\mathbb{R}^{n \\times p}$，其中有 $p = 3$ 列（一个截距项、流量和温度），响应向量 $y \\in \\mathbb{R}^n$，并假设线性模型为 $y = X \\beta + \\varepsilon$，其中 $\\beta \\in \\mathbb{R}^p$ 是未知的，$\\varepsilon$ 是均值为零、方差恒定的独立误差。\n\n从 OLS 估计量和残差的定义出发，为每个观测值 $i \\in \\{1,\\dots,n\\}$ 计算：\n- 杠杆值 $h_{ii}$（帽子矩阵的第 $i$ 个对角元素）。\n- 外学生化残差 $t_i$。\n- 库克距离 $D_i$。\n\n然后，使用以下决策规则识别影响斜率估计的强影响点：\n如果满足以下任一条件，观测值 $i$ 将被标记为强影响点：\n1) $D_i > \\frac{4}{n}$，或\n2) $h_{ii} > \\frac{2p}{n}$ 且 $|t_i| > t_{0.975}(n - p - 1)$，其中 $t_{0.975}(\\cdot)$ 表示具有指定自由度的学生t分布的上 $0.975$ 分位数。\n\n所有量 $h_{ii}$、$t_i$ 和 $D_i$ 都是无量纲的，并且必须报告为四舍五入到六位小数的浮点数。强影响点的索引必须使用从零开始的索引进行报告。\n\n使用以下三个测试用例。对于每个用例，构造一个包含一列1（截距）、流量向量和温度向量的矩阵 $X$，并使用提供的营养物负荷向量 $y$。单位的指定是为了科学真实性，但输出是无量纲的。\n\n测试用例1（正常路径，中等变异性，$n=8$）：\n- 流量向量（单位：$\\mathrm{m}^3/\\mathrm{s}$）：$[80, 95, 110, 125, 140, 155, 170, 185]$。\n- 温度向量（单位：$^{\\circ}\\mathrm{C}$）：$[10, 12, 11, 13, 15, 14, 16, 12]$。\n- 营养物负荷向量（单位：$\\mathrm{kg/day}$）：$[255, 292, 327, 370, 418, 450, 491, 520]$。\n\n测试用例2（边界条件，含高杠杆值候选点，$n=9$）：\n- 流量向量（单位：$\\mathrm{m}^3/\\mathrm{s}$）：$[80, 90, 100, 110, 120, 130, 140, 150, 350]$。\n- 温度向量（单位：$^{\\circ}\\mathrm{C}$）：$[10, 11, 12, 13, 14, 12, 11, 13, 10]$。\n- 营养物负荷向量（单位：$\\mathrm{kg/day}$）：$[218, 241, 266, 290, 315, 332, 351, 378, 812]$。\n\n测试用例3（边缘情况，响应变量中存在离群值，$n=10$）：\n- 流量向量（单位：$\\mathrm{m}^3/\\mathrm{s}$）：$[100, 110, 120, 130, 140, 150, 160, 170, 180, 140]$。\n- 温度向量（单位：$^{\\circ}\\mathrm{C}$）：$[12, 13, 14, 12, 13, 15, 14, 16, 15, 13]$。\n- 营养物负荷向量（单位：$\\mathrm{kg/day}$）：$[262, 284, 307, 322, 345, 370, 388, 415, 431, 420]$（注意最后一个值是相对于典型模式的有意设置的离群值）。\n\n算法要求：\n- 计算 OLS 估计量 $\\hat{\\beta} = (X^\\top X)^{-1} X^\\top y$。\n- 计算残差 $r = y - X \\hat{\\beta}$。\n- 计算帽子矩阵 $H = X (X^\\top X)^{-1} X^\\top$ 及其对角线元素 $h_{ii}$。\n- 计算残差方差估计 $s^2 = \\frac{\\sum_{i=1}^{n} r_i^2}{n - p}$。\n- 通过恒等式计算留一均方误差 $s_{(i)}^2$ $$s_{(i)}^2 = \\frac{(n - p) s^2 - \\frac{r_i^2}{1 - h_{ii}}}{n - p - 1},$$ 以及外学生化残差 $$t_i = \\frac{r_i}{s_{(i)} \\sqrt{1 - h_{ii}}}.$$\n- 计算库克距离 $$D_i = \\frac{r_i^2}{p s^2} \\cdot \\frac{h_{ii}}{(1 - h_{ii})^2}.$$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个包含四个元素的嵌套列表：$h_{ii}$ 值列表、$t_i$ 值列表、$D_i$ 值列表以及由决策规则确定的强影响点索引列表。所有浮点数必须四舍五入到六位小数。总输出必须是一个顶级列表，其中包含三个按用例排列的列表，例如：$[[h\\_1,t\\_1,D\\_1,I\\_1],[h\\_2,t\\_2,D\\_2,I\\_2],[h\\_3,t\\_3,D\\_3,I\\_3]]$，其中每个 $h\\_k$、$t\\_k$ 和 $D\\_k$ 本身是一个浮点数列表，每个 $I\\_k$ 是一个整数列表。",
            "solution": "该问题要求计算普通最小二乘（OLS）线性回归的几个关键诊断统计量，并随后根据既定标准识别强影响点。分析将在环境建模背景下对三个不同的测试用例进行。解决方案首先定义理论框架，然后将其算法化地应用于所提供的数据。\n\n多元线性回归模型的一般形式由下式给出：\n$$ y = X \\beta + \\varepsilon $$\n其中 $y \\in \\mathbb{R}^n$ 是观测响应向量（营养物负荷），$X \\in \\mathbb{R}^{n \\times p}$ 是设计矩阵，$\\beta \\in \\mathbb{R}^p$ 是未知模型系数向量，$\\varepsilon \\in \\mathbb{R}^n$ 是随机误差向量。设计矩阵 $X$ 由预测变量（河流流量和水温）和一列代表模型截距的全1前导列构成。因此，对于这个问题，参数数量 $p$ 为 $3$。\n\n计算所需诊断统计量的分步过程如下：\n\n1.  **OLS 系数估计**：OLS 估计量 $\\hat{\\beta}$ 最小化残差平方和。它使用正规方程计算：\n    $$ \\hat{\\beta} = (X^\\top X)^{-1} X^\\top y $$\n    这要求矩阵 $X^\\top X$ 是可逆的，如果 $X$ 的列是线性无关的，则此条件成立。\n\n2.  **拟合值和残差**：一旦找到 $\\hat{\\beta}$，拟合（或预测）值向量 $\\hat{y}$ 由下式给出：\n    $$ \\hat{y} = X \\hat{\\beta} $$\n    残差向量 $r$ 代表观测值与拟合值之间的差异，则为：\n    $$ r = y - \\hat{y} = y - X \\hat{\\beta} $$\n\n3.  **帽子矩阵和杠杆值**：帽子矩阵 $H$ 将观测响应向量 $y$ 映射到拟合值向量 $\\hat{y}$：\n    $$ \\hat{y} = X (X^\\top X)^{-1} X^\\top y = H y $$\n    帽子矩阵定义为 $H = X (X^\\top X)^{-1} X^\\top$。它是一个对称且幂等（$H^2=H$）的投影矩阵。帽子矩阵的对角元素 $h_{ii}$ 是每个观测值 $i$ 的杠杆值。杠杆值 $h_{ii}$ 衡量了响应值 $y_i$ 对其自身拟合值 $\\hat{y}_i$ 的影响，因为 $\\frac{\\partial \\hat{y}_i}{\\partial y_i} = h_{ii}$。它也反映了观测值 $i$ 的预测变量向量与预测变量空间中心的距离。$h_{ii}$ 的值被限制在 $1/n \\le h_{ii} \\le 1$ 的范围内。\n\n4.  **残差方差估计**：误差方差 $\\sigma^2$ 的一个无偏估计量是均方误差（MSE），也表示为 $s^2$：\n    $$ s^2 = \\frac{r^\\top r}{n - p} = \\frac{\\sum_{i=1}^{n} r_i^2}{n - p} $$\n    其中 $n-p$ 是残差自由度。\n\n5.  **外学生化残差**：观测值 $i$ 的外学生化残差 $t_i$ 是通过将残差 $r_i$ 与其标准误进行比较来计算的，其中标准误是根据拟合除观测值 $i$ 之外的所有数据点得到的模型来估计的。令 $s_{(i)}^2$ 为不包含观测值 $i$ 计算出的均方误差。学生化残差为：\n    $$ t_i = \\frac{r_i}{s_{(i)} \\sqrt{1 - h_{ii}}} $$\n    一个计算上高效的 $s_{(i)}^2$ 公式避免了重新拟合模型 $n$ 次：\n    $$ s_{(i)}^2 = \\frac{(n - p) s^2 - \\frac{r_i^2}{1 - h_{ii}}}{n - p - 1} $$\n    在标准的 OLS 假设下，这些残差服从具有 $n - p - 1$ 个自由度的学生t分布。\n\n6.  **库克距离**：库克距离 $D_i$ 衡量了当从数据集中移除观测值 $i$ 时所有估计系数的总体变化。它是衡量一个观测值对模型拟合值的总体影响的指标。其计算公式为：\n    $$ D_i = \\frac{r_i^2}{p s^2} \\cdot \\frac{h_{ii}}{(1 - h_{ii})^2} $$\n    该公式结合了残差大小（通过 $r_i^2$）和杠杆值（$h_{ii}$）来量化影响。\n\n7.  **强影响点的识别**：如果一个观测值满足以下两个常用诊断标准中的任何一个，则被标记为强影响点：\n    a.  其库克距离很大。一个常用的阈值是 $D_i > \\frac{4}{n}$。\n    b.  它同时具有高杠杆值和大的残差。高杠杆值的一个常用阈值是 $h_{ii} > \\frac{2p}{n}$。当满足此条件时，还需检查其外学生化残差的绝对值是否超过学生t分布的临界值。具体规则是 $|t_i| > t_{\\alpha/2}(n - p - 1)$，对于 $95\\%$ 置信水平，$\\alpha=0.05$，所以我们使用 $0.975$ 分位数 $t_{0.975}(n - p - 1)$。\n\n算法通过对三个测试用例分别应用这些步骤来执行，根据提供的数据构建相应的 $X$ 和 $y$，计算 $h_{ii}$、$t_i$ 和 $D_i$ 的向量，然后应用决策规则来识别强影响点的索引。所有浮点数结果都按要求四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"discharge\": [80, 95, 110, 125, 140, 155, 170, 185],\n            \"temperature\": [10, 12, 11, 13, 15, 14, 16, 12],\n            \"load\": [255, 292, 327, 370, 418, 450, 491, 520],\n        },\n        {\n            \"discharge\": [80, 90, 100, 110, 120, 130, 140, 150, 350],\n            \"temperature\": [10, 11, 12, 13, 14, 12, 11, 13, 10],\n            \"load\": [218, 241, 266, 290, 315, 332, 351, 378, 812],\n        },\n        {\n            \"discharge\": [100, 110, 120, 130, 140, 150, 160, 170, 180, 140],\n            \"temperature\": [12, 13, 14, 12, 13, 15, 14, 16, 15, 13],\n            \"load\": [262, 284, 307, 322, 345, 370, 388, 415, 431, 420],\n        }\n    ]\n\n    all_results = []\n    \n    for case_data in test_cases:\n        discharge_vec = np.array(case_data[\"discharge\"])\n        temp_vec = np.array(case_data[\"temperature\"])\n        y = np.array(case_data[\"load\"])\n        n = len(y)\n        p = 3  # Intercept, discharge, temperature\n\n        # Construct the design matrix X\n        X = np.ones((n, p))\n        X[:, 1] = discharge_vec\n        X[:, 2] = temp_vec\n\n        # Calculate diagnostics\n        h_values, t_values, D_values, influential_indices = _calculate_diagnostics(X, y, n, p)\n        \n        # Format results for output\n        case_result = [\n            list(np.round(h_values, 6)),\n            list(np.round(t_values, 6)),\n            list(np.round(D_values, 6)),\n            influential_indices\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # str() on a list creates a string like '[1, 2, 3]'.\n    # Joining these with commas and enclosing in brackets creates the desired format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef _calculate_diagnostics(X, y, n, p):\n    \"\"\"\n    Calculate regression diagnostics for a given design matrix X and response y.\n    \n    Args:\n        X (np.ndarray): Design matrix of shape (n, p).\n        y (np.ndarray): Response vector of shape (n,).\n        n (int): Number of observations.\n        p (int): Number of parameters.\n        \n    Returns:\n        tuple: A tuple containing:\n            - h_values (np.ndarray): Leverage values.\n            - t_values (np.ndarray): Externally studentized residuals.\n            - D_values (np.ndarray): Cook's distances.\n            - influential_indices (list): List of zero-based indices of influential points.\n    \"\"\"\n    # OLS estimator: beta_hat = (X.T @ X)^-1 @ X.T @ y\n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n    except np.linalg.LinAlgError:\n        # This case should not happen with the provided test data\n        return [], [], [], []\n\n    beta_hat = XTX_inv @ X.T @ y\n    \n    # Residuals: r = y - X @ beta_hat\n    residuals = y - X @ beta_hat\n    \n    # Hat matrix diagonal (leverages): H = X @ (X.T @ X)^-1 @ X.T\n    # Efficient calculation of the diagonal h_ii\n    h_values = np.sum((X @ XTX_inv) * X, axis=1)\n\n    # Residual variance estimate: s^2\n    df_residual = n - p\n    ssr = np.sum(residuals**2)\n    s2 = ssr / df_residual\n    \n    # Externally studentized residuals (t_i) and Cook's distance (D_i)\n    t_values = np.zeros(n)\n    D_values = np.zeros(n)\n    \n    # Small value to prevent division by zero in 1 - h_ii\n    epsilon = 1e-12 \n\n    for i in range(n):\n        # Leave-one-out mean squared error: s_(i)^2\n        s2_i = (df_residual * s2 - residuals[i]**2 / (1 - h_values[i] + epsilon)) / (df_residual - 1)\n        # Avoid sqrt of negative number if s2_i is slightly negative due to precision\n        if s2_i < 0: s2_i = 0\n        \n        # Externally studentized residual: t_i\n        t_values[i] = residuals[i] / (np.sqrt(s2_i) * np.sqrt(1 - h_values[i] + epsilon))\n        \n        # Cook's distance: D_i\n        D_values[i] = (residuals[i]**2 / (p * s2)) * (h_values[i] / (1 - h_values[i] + epsilon)**2)\n\n    # Identify influential points\n    influential_indices = []\n    \n    # Rule 1 threshold\n    cook_threshold = 4 / n\n    \n    # Rule 2 thresholds\n    leverage_threshold = 2 * p / n\n    df_t = n - p - 1\n    if df_t > 0:\n        t_critical = t.ppf(0.975, df=df_t)\n    else: # Should not happen for valid n, p\n        t_critical = float('inf')\n\n    for i in range(n):\n        # Check rule 1\n        rule1_triggered = D_values[i] > cook_threshold\n        \n        # Check rule 2\n        rule2_triggered = (h_values[i] > leverage_threshold) and (np.abs(t_values[i]) > t_critical)\n        \n        if rule1_triggered or rule2_triggered:\n            influential_indices.append(i)\n            \n    return h_values, t_values, D_values, influential_indices\n\nsolve()\n```"
        }
    ]
}