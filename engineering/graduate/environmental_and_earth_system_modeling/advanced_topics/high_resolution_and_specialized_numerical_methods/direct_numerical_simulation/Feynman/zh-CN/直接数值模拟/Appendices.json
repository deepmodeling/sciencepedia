{
    "hands_on_practices": [
        {
            "introduction": "任何直接数值模拟（DNS）的第一步都是规划。这涉及到估算巨大的计算成本，而这又始于确定所需的空间和时间分辨率。本练习  将指导您完成一项基本计算：通过解析湍流中最小的涡旋——柯尔莫哥洛夫（Kolmogorov）微尺度，将大尺度流动特征转化为DNS所必需的网格间距和时间步长。",
            "id": "3874580",
            "problem": "一个研究团队正在准备进行一次直接数值模拟（DNS），该模拟代表了小尺度海洋混合中的均匀各向同性湍流。流体是海水，其运动粘度 $\\nu$ 等于 $1.0 \\times 10^{-6}$ $\\text{m}^2\\,\\text{s}^{-1}$。大尺度的均方根速度 $U$ 和积分长度 $L$ 分别为 $U = 0.2$ $\\text{m}\\,\\text{s}^{-1}$ 和 $L = 0.5$ $\\text{m}$。假设流动是统计定常的高雷诺数流动，从而一个正向能量级串已充分建立。\n\n从不可压缩Navier-Stokes方程和动能平衡出发，并引用适用于惯性级串的Kolmogorov相似性理论，推导大尺度上平均耗散率 $\\epsilon$ 与 $U$ 和 $L$ 的标度关系。然后，使用量纲分析得到Kolmogorov微尺度（Kolmogorov长度尺度 $\\eta$、时间尺度 $\\tau_{\\eta}$ 和速度尺度 $u_{\\eta}$）的表达式，并用 $\\nu$ 和 $\\epsilon$ 表示。对于DNS的分辨率标准，施加以下约束：网格间距 $\\Delta x$ 需解析Kolmogorov长度，时间步长 $\\Delta t$ 需解析Kolmogorov时间，安全因子 $c=1$，即设置 $\\Delta x = c\\,\\eta$ 和 $\\Delta t = c\\,\\tau_{\\eta}$，其中 $c=1$。\n\n使用给定的 $U$、$L$ 和 $\\nu$，计算 $\\eta$、$\\tau_{\\eta}$、$u_{\\eta}$、$\\Delta x$ 和 $\\Delta t$ 的数值。将每个值四舍五入到四位有效数字。将 $\\eta$ 和 $\\Delta x$ 以米为单位表示，将 $\\tau_{\\eta}$ 和 $\\Delta t$ 以秒为单位表示，将 $u_{\\eta}$ 以米/秒为单位表示。最终答案必须是一个单行矩阵，按 $(\\eta, \\tau_{\\eta}, u_{\\eta}, \\Delta x, \\Delta t)$ 的顺序包含这五个数字。",
            "solution": "问题陈述已经过验证，被认为具有科学依据、适定且客观。它提出了湍流理论及其数值模拟领域的一个标准问题，为求得唯一解提供了所有必要信息。\n\n该问题要求进行两部分的推导，然后进行数值计算。首先，我们推导平均湍动能耗散率 $\\epsilon$ 的标度关系。其次，我们推导Kolmogorov微尺度的表达式。最后，我们计算这些尺度的数值以及相应的DNS网格参数。\n\n出发点是统计定常的均匀湍流中的能量平衡。在大的含能运动尺度上，单位质量的湍动能生成率 $P$ 必须与小的耗散尺度上的粘性耗散率 $\\epsilon$ 相平衡。这表示为 $P = \\epsilon$。生成率 $P$ 由大涡的动力学决定。这些涡的特征速度是均方根速度 $U$，其特征尺寸是积分长度尺度 $L$。大涡的特征时间尺度，称为涡翻转时间，为 $T_L \\sim L/U$。在这些尺度上，单位质量的动能的量级为 $k \\sim U^2$。能量沿级串向下传递的速率是能量除以特征时间，因此 $P \\sim k/T_L$。代入 $k$ 和 $T_L$ 的标度关系，得到生成率的标度关系：\n$$ P \\sim \\frac{U^2}{L/U} = \\frac{U^3}{L} $$\n在统计定常状态下，这个生成率等于耗散率 $\\epsilon$。因此，平均耗散率的标度关系是：\n$$ \\epsilon \\propto \\frac{U^3}{L} $$\n为了进行量级估算，我们假设比例常数为1，得到 $\\epsilon \\approx \\frac{U^3}{L}$。\n\n接下来，我们使用量纲分析来推导Kolmogorov微尺度。根据Kolmogorov的第一相似性假设，小尺度湍流运动由耗散率 $\\epsilon$ 和运动粘度 $\\nu$ 普遍且唯一地确定。它们的量纲是 $[\\epsilon] = L^2 T^{-3}$ 和 $[\\nu] = L^2 T^{-1}$。\n\n1.  Kolmogorov长度尺度 $\\eta$ 是通过组合 $\\epsilon$ 和 $\\nu$ 得到一个具有长度量纲 $[L]$ 的量。我们设 $\\eta = \\epsilon^a \\nu^b$。在量纲方面：\n    $$ [L]^1 [T]^0 = (L^2 T^{-3})^a (L^2 T^{-1})^b = L^{2a+2b} T^{-3a-b} $$\n    这导出了关于指数 $a$ 和 $b$ 的一个线性方程组：\n    $$ \\begin{cases} 2a + 2b = 1 \\\\ -3a - b = 0 \\end{cases} $$\n    从第二个方程可得 $b = -3a$。代入第一个方程得到 $2a + 2(-3a) = 1$，化简为 $-4a = 1$，所以 $a = -1/4$。因此，$b = -3(-1/4) = 3/4$。Kolmogorov长度尺度的表达式是：\n    $$ \\eta = \\epsilon^{-1/4} \\nu^{3/4} = \\left(\\frac{\\nu^3}{\\epsilon}\\right)^{1/4} $$\n\n2.  Kolmogorov时间尺度 $\\tau_{\\eta}$ 是通过构造一个具有时间量纲 $[T]$ 的量来找到的。我们设 $\\tau_{\\eta} = \\epsilon^a \\nu^b$。\n    $$ [L]^0 [T]^1 = L^{2a+2b} T^{-3a-b} $$\n    这给出了方程组：\n    $$ \\begin{cases} 2a + 2b = 0 \\\\ -3a - b = 1 \\end{cases} $$\n    从第一个方程可得 $b = -a$。代入第二个方程得到 $-3a - (-a) = 1$，化简为 $-2a = 1$，所以 $a = -1/2$。因此，$b = 1/2$。Kolmogorov时间尺度的表达式是：\n    $$ \\tau_{\\eta} = \\epsilon^{-1/2} \\nu^{1/2} = \\left(\\frac{\\nu}{\\epsilon}\\right)^{1/2} $$\n\n3.  Kolmogorov速度尺度 $u_{\\eta}$ 可以通过量纲分析找到，或者简单地通过取比值 $u_{\\eta} = \\eta / \\tau_{\\eta}$ 来得到。使用后一种方法：\n    $$ u_{\\eta} = \\frac{(\\nu^3/\\epsilon)^{1/4}}{(\\nu/\\epsilon)^{1/2}} = \\frac{\\nu^{3/4}\\epsilon^{-1/4}}{\\nu^{1/2}\\epsilon^{-1/2}} = \\nu^{3/4 - 1/2} \\epsilon^{-1/4 - (-1/2)} = \\nu^{1/4} \\epsilon^{1/4} $$\n    Kolmogorov速度尺度的表达式是：\n    $$ u_{\\eta} = (\\nu\\epsilon)^{1/4} $$\n\n现在，我们使用给定的数据计算数值：$U = 0.2 \\, \\text{m}\\,\\text{s}^{-1}$，$L = 0.5 \\, \\text{m}$，以及 $\\nu = 1.0 \\times 10^{-6} \\, \\text{m}^2\\,\\text{s}^{-1}$。\n\n首先，我们计算耗散率 $\\epsilon$：\n$$ \\epsilon = \\frac{U^3}{L} = \\frac{(0.2 \\, \\text{m}\\,\\text{s}^{-1})^3}{0.5 \\, \\text{m}} = \\frac{0.008 \\, \\text{m}^3\\,\\text{s}^{-3}}{0.5 \\, \\text{m}} = 0.016 \\, \\text{m}^2\\,\\text{s}^{-3} $$\n\n使用这个 $\\epsilon$ 的值和给定的 $\\nu$，我们计算Kolmogorov尺度：\n-   $\\eta = \\left(\\frac{\\nu^3}{\\epsilon}\\right)^{1/4} = \\left(\\frac{(1.0 \\times 10^{-6})^3}{0.016}\\right)^{1/4} = \\left(\\frac{1.0 \\times 10^{-18}}{1.6 \\times 10^{-2}}\\right)^{1/4} = (6.25 \\times 10^{-17})^{1/4} \\approx 8.89552 \\times 10^{-5} \\, \\text{m}$。\n    四舍五入到四位有效数字，$\\eta \\approx 8.896 \\times 10^{-5} \\, \\text{m}$。\n-   $\\tau_{\\eta} = \\left(\\frac{\\nu}{\\epsilon}\\right)^{1/2} = \\left(\\frac{1.0 \\times 10^{-6}}{0.016}\\right)^{1/2} = (6.25 \\times 10^{-5})^{1/2} \\approx 7.90569 \\times 10^{-3} \\, \\text{s}$。\n    四舍五入到四位有效数字，$\\tau_{\\eta} \\approx 7.906 \\times 10^{-3} \\, \\text{s}$。\n-   $u_{\\eta} = (\\nu\\epsilon)^{1/4} = ((1.0 \\times 10^{-6})(0.016))^{1/4} = (1.6 \\times 10^{-8})^{1/4} \\approx 0.0112468 \\, \\text{m}\\,\\text{s}^{-1}$。\n    四舍五入到四位有效数字，$u_{\\eta} \\approx 0.01125 \\, \\text{m}\\,\\text{s}^{-1}$，即 $1.125 \\times 10^{-2} \\, \\text{m}\\,\\text{s}^{-1}$。\n\n最后，我们根据问题约束确定DNS分辨率参数：$\\Delta x = c\\,\\eta$ 和 $\\Delta t = c\\,\\tau_{\\eta}$，安全因子 $c=1$。\n-   网格间距：$\\Delta x = 1 \\times \\eta \\approx 8.896 \\times 10^{-5} \\, \\text{m}$。\n-   时间步长：$\\Delta t = 1 \\times \\tau_{\\eta} \\approx 7.906 \\times 10^{-3} \\, \\text{s}$。\n\n按指定顺序 $(\\eta, \\tau_{\\eta}, u_{\\eta}, \\Delta x, \\Delta t)$ 并四舍五入到四位有效数字的五个所需数值是：$(8.896 \\times 10^{-5}, 7.906 \\times 10^{-3}, 1.125 \\times 10^{-2}, 8.896 \\times 10^{-5}, 7.906 \\times 10^{-3})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n8.896 \\times 10^{-5}  & 7.906 \\times 10^{-3}  & 1.125 \\times 10^{-2}  & 8.896 \\times 10^{-5}  & 7.906 \\times 10^{-3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "许多不可压缩流求解器的核心是投影法，它确保速度场在每个时间步都满足无散度约束（$ \\nabla \\cdot \\mathbf{u} = 0 $）。这个动手编程练习  将让您通过实现压力泊松方程的谱方法求解器来揭开这一关键过程的神秘面纱。通过使用快速傅里叶变换（FFT），您将构建一个用于周期性流动的、许多先进DNS代码中的核心算法组件。",
            "id": "3874551",
            "problem": "考虑在环境与地球系统建模中，用于不可压缩流直接数值模拟（DNS）的投影步。投影的目的是通过消除暂定速度场的散度来强制实现不可压缩性。从不可压缩流的质量守恒定律（要求 $ \\nabla \\cdot \\mathbf{u} = 0 $）出发，并利用亥姆霍兹分解的思想（将一个矢量场分解为一个无散分量和一个标量势的梯度），构建压力泊松方程在周期性盒子中的数值解，并用它来计算校正后的无散速度场。\n\n您必须在一个程序中使用基于快速傅里叶变换（FFT）和周期性边界条件的谱方法实现以下内容：\n\n- 域：一个 $ 2 $ 维周期性盒子 $ [0, 2\\pi] \\times [0, 2\\pi] $，具有 $ N \\times N $ 个点的均匀网格。\n- 三角函数的角度必须以弧度为单位进行计算。\n- 给定定义在网格上的暂定速度场 $ \\mathbf{u}^{\\ast}(x,y) = (u_x^{\\ast}(x,y), u_y^{\\ast}(x,y)) $，使用谱微分计算其散度 $ \\nabla \\cdot \\mathbf{u}^{\\ast} $。\n- 在谱空间中求解标量场 $ p(x,y) $ 的压力泊松方程，使得校正后的速度 $ \\mathbf{u} = \\mathbf{u}^{\\ast} - \\nabla p $ 满足 $ \\nabla \\cdot \\mathbf{u} = 0 $。使用将域上 $ p $ 的平均值设为 $ 0 $ 的约定，以使解唯一。\n- 使用校正后散度场的 $ L^{\\infty} $ 范数（定义为 $ \\max_{x,y} \\left| \\nabla \\cdot \\mathbf{u}(x,y) \\right| $）来量化投影所实现的不可压缩程度。\n\n所有量均为无量纲。唯一涉及的角度单位是弧度，且必须始终如一地使用。不需要物理单位。\n\n实现以下测试套件。对于每种情况，按规定构造 $ \\mathbf{u}^{\\ast} $，执行谱投影，并以浮点数形式输出校正后散度的 $ L^{\\infty} $ 范数。\n\n- 情况 1（一般“理想”情况）：$ N = 16 $，$ u_x^{\\ast}(x,y) = \\sin(x) $，$ u_y^{\\ast}(x,y) = \\cos(y) $。\n- 情况 2（已为无散场）：$ N = 33 $，令 $ \\psi(x,y) = \\sin(x)\\sin(y) $，定义 $ \\mathbf{u}^{\\ast} = \\left(-\\frac{\\partial \\psi}{\\partial y}, \\frac{\\partial \\psi}{\\partial x}\\right) = \\left(-\\cos(y)\\sin(x), \\cos(x)\\sin(y)\\right) $，其满足 $ \\nabla \\cdot \\mathbf{u}^{\\ast} = 0 $。\n- 情况 3（多模态场）：$ N = 64 $，$ u_x^{\\ast}(x,y) = \\sin(3x) + \\frac{1}{2}\\sin(y) $，$ u_y^{\\ast}(x,y) = 2\\sin(2y) - \\sin(x) $。\n- 情况 4（边界情况，平凡场）：$ N = 8 $，$ u_x^{\\ast}(x,y) = 0 $，$ u_y^{\\ast}(x,y) = 0 $。\n\n您的程序必须：\n- 在周期性域上通过 FFT 和逆 FFT 使用谱微分来计算 $ \\nabla \\cdot \\mathbf{u}^{\\ast} $ 和 $ \\nabla p $。\n- 通过将零频率傅里叶模态设置为 $ 0 $ 来强制执行 $ p $ 的零均值条件。\n- 将每种情况下校正后散度的 $ L^{\\infty} $ 范数作为浮点数返回。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$ [result_1, result_2, result_3, result_4] $）。每个 $ result_i $ 都必须是一个浮点数，对应于情况 $ i $ 的校正后散度的 $ L^{\\infty} $ 范数。\n\n不允许外部输入；所有定义和计算必须包含在程序内部。",
            "solution": "该问题要求实现一种谱投影方法，以在二维周期性域上对暂定速度场强制执行不可压缩条件。这是不可压缩流直接数值模拟（DNS）中的一个基本步骤。该解决方案涉及使用快速傅里叶变换（FFT）求解压力泊松方程。\n\n其核心原理是不可压缩流体的质量守恒，数学上表示为速度场 $ \\mathbf{u} $ 的散度为零：\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n投影方法从一个不一定是无散的暂定速度场 $ \\mathbf{u}^{\\ast} $ 开始。然后，通过一个标量势（通常认为是压力 $ p $）的梯度来校正该场，以获得一个无散速度场 $ \\mathbf{u} $。其关系由下式给出：\n$$ \\mathbf{u} = \\mathbf{u}^{\\ast} - \\nabla p $$\n对此方程应用散度算子并强制执行不可压缩约束 $ \\nabla \\cdot \\mathbf{u} = 0 $，可得到压力泊松方程：\n$$ \\nabla \\cdot (\\mathbf{u}^{\\ast} - \\nabla p) = 0 $$\n$$ \\nabla \\cdot \\mathbf{u}^{\\ast} - \\nabla \\cdot (\\nabla p) = 0 $$\n$$ \\nabla^2 p = \\nabla \\cdot \\mathbf{u}^{\\ast} $$\n其中 $ \\nabla^2 $ 是拉普拉斯算子。任务是求解该方程以得到 $ p $，然后用它来找到校正后的无散速度场。对于周期性域，此问题在谱空间中可以被高效求解。\n\n周期域 $ [0, 2\\pi] \\times [0, 2\\pi] $ 上的函数 $ f(x,y) $ 可以由其离散傅里叶系数 $ \\hat{f}(k_x, k_y) $ 表示。物理空间中的空间微分对应于傅里叶空间中的代数乘法。具体来说，对于函数 $ f(x,y) $ 及其傅里叶变换 $ \\hat{f}(k_x, k_y) $：\n$$ \\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f}(k_x, k_y) $$\n$$ \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}(k_x, k_y) $$\n其中 $ \\mathcal{F} $ 表示傅里叶变换，$ k_x, k_y $ 分别是 $ x $ 和 $ y $ 方向的波数。因此，拉普拉斯算子变换如下：\n$$ \\mathcal{F}(\\nabla^2 f) = \\mathcal{F}\\left(\\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2}\\right) = \\left((i k_x)^2 + (i k_y)^2\\right)\\hat{f}(k_x, k_y) = -(k_x^2 + k_y^2)\\hat{f}(k_x, k_y) $$\n类似地，矢量场 $ \\mathbf{v} = (v_x, v_y) $ 的散度变换如下：\n$$ \\mathcal{F}(\\nabla \\cdot \\mathbf{v}) = i k_x \\hat{v}_x(k_x, k_y) + i k_y \\hat{v}_y(k_x, k_y) $$\n对压力泊松方程 $ \\nabla^2 p = \\nabla \\cdot \\mathbf{u}^{\\ast} $ 应用傅里叶变换，我们得到：\n$$ -(k_x^2 + k_y^2) \\hat{p}(k_x, k_y) = i k_x \\hat{u}_x^{\\ast}(k_x, k_y) + i k_y \\hat{u}_y^{\\ast}(k_x, k_y) $$\n压力的傅里叶系数 $ \\hat{p} $ 可以通过代数方法求解：\n$$ \\hat{p}(k_x, k_y) = - \\frac{i k_x \\hat{u}_x^{\\ast} + i k_y \\hat{u}_y^{\\ast}}{k_x^2 + k_y^2} $$\n在零波数模态处会出现奇异点，即 $ k_x = k_y = 0 $ 时，分母为零。该模态对应于场的平均值。为了使泊松方程在周期性域上有解，源项 $ \\nabla \\cdot \\mathbf{u}^{\\ast} $ 的积分必须为零。根据散度定理，此条件是满足的。对于平均模态，该方程变为 $ 0/0 $，意味着 $ \\hat{p}(0, 0) $ 是不确定的。为确保压力的解唯一，问题指定 $ p $ 的平均值为零，这等效于将其零频傅里叶系数设为零：$ \\hat{p}(0, 0) = 0 $。\n\n算法流程如下：\n$1$. 在域 $ [0, 2\\pi] \\times [0, 2\\pi] $ 上定义一个 $ N \\times N $ 点的计算网格。网格点为 $ (x_j, y_l) $，其中 $ x_j = \\frac{2\\pi j}{N} $ 且 $ y_l = \\frac{2\\pi l}{N} $，对于 $ j, l \\in \\{0, \\dots, N-1\\} $。相应的整数波数可从 `numpy.fft.fftfreq` 中获得。\n$2$. 在此网格上计算暂定速度场分量 $ u_x^{\\ast}(x,y) $ 和 $ u_y^{\\ast}(x,y) $。\n$3$. 使用 FFT 算法计算它们的二维傅里叶变换 $ \\hat{u}_x^{\\ast}(k_x, k_y) $ 和 $ \\hat{u}_y^{\\ast}(k_x, k_y) $。\n$4$. 计算暂定场散度的傅里叶变换：$ \\widehat{\\nabla \\cdot \\mathbf{u}^{\\ast}} = i k_x \\hat{u}_x^{\\ast} + i k_y \\hat{u}_y^{\\ast} $。\n$5$. 使用推导出的表达式求解压力的傅里叶系数 $ \\hat{p}(k_x, k_y) $，并强制 $ \\hat{p}(0,0) = 0 $。\n$6$. 校正后速度场的散度 $ \\nabla \\cdot \\mathbf{u} $ 可以直接在傅里叶空间中计算。其傅里叶变换为 $ \\widehat{\\nabla \\cdot \\mathbf{u}} = \\widehat{\\nabla \\cdot \\mathbf{u}^{\\ast}} - \\mathcal{F}(\\nabla^2 p) = \\widehat{\\nabla \\cdot \\mathbf{u}^{\\ast}} + (k_x^2 + k_y^2)\\hat{p} $。根据构造，对于所有波数，该式的值在浮点数值精度范围内应为零。\n$7$. 通过对 $ \\widehat{\\nabla \\cdot \\mathbf{u}}(k_x, k_y) $ 应用二维逆 FFT，可以得到物理场 $ \\nabla \\cdot \\mathbf{u}(x,y) $。\n$8$. 最后，通过校正后散度的 $ L^{\\infty} $ 范数 $ \\max_{x,y} \\left| \\nabla \\cdot \\mathbf{u}(x,y) \\right| $ 来衡量不可压缩性强制执行的质量。\n必须对指定的四个测试用例中的每一个应用此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pressure Poisson equation on a 2D periodic domain\n    using a spectral method to enforce incompressibility on a\n    tentative velocity field.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, u_x function, u_y function)\n    test_cases = [\n        (16, lambda x, y: np.sin(x), lambda x, y: np.cos(y)),\n        (33, lambda x, y: -np.cos(y) * np.sin(x), lambda x, y: np.cos(x) * np.sin(y)),\n        (64, lambda x, y: np.sin(3 * x) + 0.5 * np.sin(y), lambda x, y: 2 * np.sin(2 * y) - np.sin(x)),\n        (8, lambda x, y: 0.0, lambda x, y: 0.0)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, ux_func, uy_func = case\n\n        # 1. Define the computational grid and wavenumbers\n        # Domain is [0, 2*pi] x [0, 2*pi]\n        L = 2 * np.pi\n        # Grid points x_j = j * L/N. np.linspace is used for clarity.\n        x = np.linspace(0, L, N, endpoint=False)\n        y = np.linspace(0, L, N, endpoint=False)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        # Wavenumbers: For a domain of size L=2*pi, the physical wavenumbers k\n        # are integers m. The integer wavenumbers m are given by np.fft.fftfreq(N) * N.\n        k_int = np.fft.fftfreq(N) * N\n        KX, KY = np.meshgrid(k_int, k_int, indexing='ij')\n\n        # 2. Evaluate the tentative velocity field u* on the grid\n        ux_star = ux_func(X, Y)\n        uy_star = uy_func(X, Y)\n        # Ensure arrays are float type even for zero-field case\n        if not isinstance(ux_star, np.ndarray):\n            ux_star = np.full((N, N), ux_star, dtype=float)\n        if not isinstance(uy_star, np.ndarray):\n            uy_star = np.full((N, N), uy_star, dtype=float)\n\n\n        # 3. Compute the 2D FFT of the velocity components\n        ux_star_hat = np.fft.fft2(ux_star)\n        uy_star_hat = np.fft.fft2(uy_star)\n\n        # 4. Compute the divergence of u* in spectral space\n        # F(div(u*)) = i*kx*F(ux*) + i*ky*F(uy*)\n        div_u_star_hat = 1j * KX * ux_star_hat + 1j * KY * uy_star_hat\n\n        # 5. Solve the pressure Poisson equation in spectral space\n        # F(nabla^2 p) = F(div(u*))  =>  -(kx^2+ky^2)*p_hat = div_u_star_hat\n        # p_hat = -div_u_star_hat / (kx^2+ky^2)\n        k_squared = KX**2 + KY**2\n\n        # Initialize p_hat with zeros. This automatically sets p_hat(0,0)=0,\n        # enforcing the mean-zero pressure condition.\n        p_hat = np.zeros_like(k_squared, dtype=complex)\n        \n        # Avoid division by zero at k=0\n        non_zero_k = k_squared != 0\n        p_hat[non_zero_k] = -div_u_star_hat[non_zero_k] / k_squared[non_zero_k]\n\n        # 6. Compute the divergence of the corrected velocity field u in spectral space\n        # F(div(u)) = F(div(u*)) - F(div(grad(p)))\n        #           = F(div(u*)) - F(nabla^2 p)\n        #           = div_u_star_hat - (-(kx^2+ky^2)*p_hat)\n        #           = div_u_star_hat + (kx^2+ky^2)*p_hat\n        div_u_hat = div_u_star_hat + k_squared * p_hat\n        \n        # By construction, div_u_hat should be zero to machine precision.\n        # Let's verify for the k=0 mode:\n        # div_u_hat[0,0] = div_u_star_hat[0,0] + 0 * p_hat[0,0] = div_u_star_hat[0,0]\n        # div_u_star_hat[0,0] is the mean of the divergence, which should be numerically zero\n        # for a periodic domain. The operation div_u_hat = ... will correctly handle this.\n        \n        # 7. Transform the corrected divergence back to physical space\n        div_u = np.fft.ifft2(div_u_hat)\n\n        # 8. Calculate the L-infinity norm of the result.\n        # The result should be a real field, but small imaginary parts can exist due\n        # to floating point errors. np.abs handles complex numbers correctly.\n        linf_norm_div_u = np.max(np.abs(div_u))\n        \n        results.append(linf_norm_div_u)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个模拟的价值取决于其验证的严谨性。这最后一个练习  聚焦于定量评估DNS结果准确性的基本任务。您将编写代码，通过几个关键的诊断指标——能量谱、积分量和平均剖面——将模拟输出与基准数据进行比较，并学习如何量化比较中的不确定性，这是现代计算科学的基石之一。",
            "id": "3874571",
            "problem": "考虑湍流直接数值模拟（DNS）的验证，这对于环境和地球系统建模至关重要。目标是评估计算得到的DNS输出与基准数据集在三个诊断类别上的一致性：能谱、积分量和平均剖面。所有计算都必须以无量纲形式进行，所有输出都必须表示为十进制数（无单位、无百分号）。假设计算量具有已知的标准差，其不确定度为独立高斯不确定度。\n\n从基本定义开始：\n- 单位质量的湍动能定义为 $K = \\frac{1}{2} \\langle u_i u_i \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示系综平均，$u_i$ 是速度分量。\n- 一维能谱 $E(k)$ 满足方差是谱在波数 $k$ 上的积分，并且对于所有已解析的 $k$，谱均为正值。\n- 平均速度剖面 $U(y)$ 是在高度 $y$ 处的水平面上的空间平均值。\n\n验证任务：\n1. 对于能谱，计算离散波数上的加权均方根相对误差。对于波数 $k_i$ 处的样本，给定基准值 $E_b(k_i)$、计算值 $E_c(k_i)$ 和计算标准差 $\\sigma_{E_c}(k_i)$，将每个频带的相对误差计算为 $(E_c(k_i) - E_b(k_i))/E_b(k_i)$。使用与基准能量成正比的权重对它们进行聚合，并计算这些相对误差的加权均方根。在独立性假设下，使用一阶高斯误差传播来量化此聚合误差的不确定度，并使用 $1.96$ 的高斯乘子报告双边 $95\\%$ 置信区间的半宽度。\n2. 对于积分量，计算总动能和耗散率的相对误差，然后将它们聚合为单个欧几里得范数差异量级。给定基准值 $K_b$ 和 $\\varepsilon_b$、计算值 $K_c$ 和 $\\varepsilon_c$ 以及计算标准差 $\\sigma_K$ 和 $\\sigma_\\varepsilon$，计算 $(K_c - K_b)/K_b$ 和 $(\\varepsilon_c - \\varepsilon_b)/\\varepsilon_b$，然后计算这两个相对误差的欧几里得范数。在独立性假设下，使用一阶高斯误差传播来量化此聚合差异的不确定度，并报告相应的双边 $95\\%$ 置信区间半宽度。\n3. 对于平均速度剖面，计算离散高度 $y_i$ 上的均匀加权均方根相对误差。给定基准值 $U_b(y_i)$、计算值 $U_c(y_i)$ 和计算标准差 $\\sigma_{U_c}(y_i)$，计算相对误差 $(U_c(y_i) - U_b(y_i))/U_b(y_i)$ 并计算其均匀加权均方根。在独立性假设下，使用一阶高斯误差传播来量化此聚合误差的不确定度，并报告双边 $95\\%$ 置信区间半宽度。\n\n测试套件：\n提供三个测试用例，每个用例都包含三个诊断所需的所有输入。所有量均为无量纲，所有数组都应视为有序列表。\n\n- 测试用例 1：\n  - 能谱数组：$k = [2,3,4,6,8,12]$, $E_b = [0.8,0.52,0.38,0.24,0.18,0.12]$, $E_c = [0.816,0.529,0.372,0.254,0.171,0.126]$, $\\sigma_{E_c} = [0.02,0.02,0.02,0.02,0.02,0.02]$.\n  - 积分量：$K_b = 0.75$, $K_c = 0.77$, $\\sigma_K = 0.01$, $\\varepsilon_b = 0.45$, $\\varepsilon_c = 0.44$, $\\sigma_\\varepsilon = 0.015$.\n  - 平均剖面数组：$y = [0.0,0.15,0.30,0.45,0.60,0.75,0.90]$, $U_b = [0.10,0.22,0.35,0.49,0.63,0.78,0.92]$, $U_c = [0.105,0.218,0.348,0.500,0.618,0.790,0.910]$, $\\sigma_{U_c} = [0.01,0.01,0.01,0.01,0.01,0.01,0.01]$.\n- 测试用例 2：\n  - 能谱数组：$k = [1,2,4,8,16,32]$, $E_b = [1.2,0.9,0.5,0.25,0.12,0.05]$, $E_c = [1.32,0.81,0.55,0.20,0.15,0.04]$, $\\sigma_{E_c} = [0.05,0.05,0.04,0.03,0.02,0.01]$.\n  - 积分量：$K_b = 1.10$, $K_c = 1.30$, $\\sigma_K = 0.05$, $\\varepsilon_b = 0.80$, $\\varepsilon_c = 0.70$, $\\sigma_\\varepsilon = 0.04$.\n  - 平均剖面数组：$y = [0.05,0.15,0.30,0.50,0.70,0.85]$, $U_b = [0.12,0.28,0.48,0.70,0.88,1.00]$, $U_c = [0.11,0.31,0.44,0.73,0.84,1.05]$, $\\sigma_{U_c} = [0.02,0.02,0.02,0.02,0.02,0.03]$.\n- 测试用例 3：\n  - 能谱数组：$k = [3,6,9,12,15,18]$, $E_b = [0.60,0.35,0.25,0.18,0.14,0.10]$, $E_c = [0.601,0.349,0.252,0.181,0.139,0.101]$, $\\sigma_{E_c} = [0.06,0.04,0.03,0.03,0.02,0.02]$.\n  - 积分量：$K_b = 0.50$, $K_c = 0.505$, $\\sigma_K = 0.05$, $\\varepsilon_b = 0.60$, $\\varepsilon_c = 0.595$, $\\sigma_\\varepsilon = 0.06$.\n  - 平均剖面数组：$y = [0.10,0.25,0.40,0.60,0.80,0.95]$, $U_b = [0.15,0.32,0.50,0.70,0.85,0.95]$, $U_c = [0.148,0.325,0.495,0.705,0.848,0.952]$, $\\sigma_{U_c} = [0.05,0.05,0.05,0.05,0.05,0.05]$.\n\n您的程序必须为每个测试用例执行以下操作：\n- 计算能谱的加权均方根相对误差，使用与 $E_b(k_i)$ 成正比的权重，并返回点估计和双边 $95\\%$ 置信区间的半宽度。\n- 计算积分量的欧几里得范数聚合差异，并返回点估计和双边 $95\\%$ 置信区间的半宽度。\n- 计算平均剖面的均匀加权均方根相对误差，并返回点估计和双边 $95\\%$ 置信区间的半宽度。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的串联结果，格式为方括号括起来的逗号分隔列表，并严格遵循以下顺序：\n$[$case1 spectrum RMS, case1 spectrum CI$_{95}$, case1 integral discrepancy, case1 integral CI$_{95}$, case1 profile RMS, case1 profile CI$_{95}$, case2 spectrum RMS, case2 spectrum CI$_{95}$, case2 integral discrepancy, case2 integral CI$_{95}$, case2 profile RMS, case2 profile CI$_{95}$, case3 spectrum RMS, case3 spectrum CI$_{95}$, case3 integral discrepancy, case3 integral CI$_{95}$, case3 profile RMS, case3 profile CI$_{95}]$.",
            "solution": "验证直接数值模拟（DNS）的问题是一个适定且有科学依据的任务。它要求计算特定的统计指标，以量化模拟结果与既定基准数据之间的差异。该解决方案涉及三个不同的验证任务，每个任务都有其自身的误差度量和基于一阶高斯误差传播的不确定度量化方法。我们将系统地处理每个任务。\n\n设 $z=1.96$ 为双边 $95\\%$ 置信区间的高斯乘子。\n\n**1. 能谱验证**\n\n目标是计算一维能谱 $E(k)$ 的加权均方根（RMS）相对误差。\n\n设离散数据集由 $N_k$ 个波数 $k_i$ 组成。输入为基准谱 $E_b(k_i)$、计算谱 $E_c(k_i)$ 以及计算谱的标准差 $\\sigma_{E_c}(k_i)$，其中 $i=1, \\dots, N_k$。\n\n每个波数处的相对误差定义为：\n$$ r_i = \\frac{E_c(k_i) - E_b(k_i)}{E_b(k_i)} $$\n\n问题指定权重 $w_i$ 与基准能量成正比，并进行归一化，使其总和为1：\n$$ w_i = \\frac{E_b(k_i)}{\\sum_{j=1}^{N_k} E_b(k_j)} $$\n\n加权 RMS 相对误差（记为 $S_{RMS}$）是相对误差平方的加权平均值的平方根：\n$$ S_{RMS} = \\sqrt{\\sum_{i=1}^{N_k} w_i r_i^2} = \\sqrt{\\frac{\\sum_{i=1}^{N_k} E_b(k_i) \\left(\\frac{E_c(k_i) - E_b(k_i)}{E_b(k_i)}\\right)^2}{\\sum_{j=1}^{N_k} E_b(k_j)}} $$\n\n为了量化 $S_{RMS}$ 中的不确定度，我们使用一阶误差传播。不确定度的唯一来源是计算值 $E_c(k_i)$，假设它们是独立的高斯随机变量。$S_{RMS}$ 的方差由下式给出：\n$$ \\sigma_{S_{RMS}}^2 = \\sum_{i=1}^{N_k} \\left( \\frac{\\partial S_{RMS}}{\\partial E_c(k_i)} \\right)^2 \\sigma_{E_c}(k_i)^2 $$\n\n$S_{RMS}$ 相对于 $E_c(k_i)$ 的偏导数为：\n$$ \\frac{\\partial S_{RMS}}{\\partial E_c(k_i)} = \\frac{1}{2 S_{RMS}} \\frac{\\partial}{\\partial E_c(k_i)} \\left( \\sum_{j=1}^{N_k} w_j r_j^2 \\right) = \\frac{1}{2 S_{RMS}} \\left( w_i \\cdot 2 r_i \\cdot \\frac{\\partial r_i}{\\partial E_c(k_i)} \\right) = \\frac{w_i r_i}{S_{RMS}} \\frac{1}{E_b(k_i)} $$\n此推导在 $S_{RMS} \\neq 0$ 时有效。如果 $S_{RMS} = 0$，则意味着所有 $r_i=0$，逻辑上不确定度为 $0$。\n\n将偏导数代入方差公式可得：\n$$ \\sigma_{S_{RMS}}^2 = \\sum_{i=1}^{N_k} \\left( \\frac{w_i r_i}{S_{RMS} E_b(k_i)} \\right)^2 \\sigma_{E_c}(k_i)^2 = \\frac{1}{S_{RMS}^2} \\sum_{i=1}^{N_k} \\frac{w_i^2 r_i^2}{E_b(k_i)^2} \\sigma_{E_c}(k_i)^2 $$\n标准差为 $\\sigma_{S_{RMS}} = \\sqrt{\\sigma_{S_{RMS}}^2}$。双边 $95\\%$ 置信区间的半宽度为 $CI_{95, S} = z \\cdot \\sigma_{S_{RMS}}$。\n\n**2. 积分量验证**\n\n目标是计算积分量（总动能 $K$ 和耗散率 $\\varepsilon$）的聚合差异。\n\n输入为基准值 $K_b, \\varepsilon_b$、计算值 $K_c, \\varepsilon_c$ 及其各自的标准差 $\\sigma_K, \\sigma_\\varepsilon$。\n\n动能和耗散率的相对误差为：\n$$ r_K = \\frac{K_c - K_b}{K_b}, \\quad r_\\varepsilon = \\frac{\\varepsilon_c - \\varepsilon_b}{\\varepsilon_b} $$\n\n聚合差异 $D$ 是这两个相对误差的欧几里得范数：\n$$ D = \\sqrt{r_K^2 + r_\\varepsilon^2} = \\sqrt{\\left(\\frac{K_c - K_b}{K_b}\\right)^2 + \\left(\\frac{\\varepsilon_c - \\varepsilon_b}{\\varepsilon_b}\\right)^2} $$\n\n通过传播来自 $K_c$ 和 $\\varepsilon_c$（假设独立）的不确定度来找到 $D$ 的不确定度。$D$ 的方差为：\n$$ \\sigma_D^2 = \\left( \\frac{\\partial D}{\\partial K_c} \\right)^2 \\sigma_K^2 + \\left( \\frac{\\partial D}{\\partial \\varepsilon_c} \\right)^2 \\sigma_\\varepsilon^2 $$\n\n$D$ 的偏导数为（对于 $D \\neq 0$）：\n$$ \\frac{\\partial D}{\\partial K_c} = \\frac{1}{2D} \\frac{\\partial D^2}{\\partial K_c} = \\frac{1}{2D} \\cdot 2 r_K \\frac{\\partial r_K}{\\partial K_c} = \\frac{r_K}{D} \\frac{1}{K_b} $$\n$$ \\frac{\\partial D}{\\partial \\varepsilon_c} = \\frac{1}{2D} \\frac{\\partial D^2}{\\partial \\varepsilon_c} = \\frac{1}{2D} \\cdot 2 r_\\varepsilon \\frac{\\partial r_\\varepsilon}{\\partial \\varepsilon_c} = \\frac{r_\\varepsilon}{D} \\frac{1}{\\varepsilon_b} $$\n如果 $D=0$，则 $r_K=0$ 和 $r_\\varepsilon=0$ 同时成立，不确定度为 $0$。\n\n因此，$D$ 的方差为：\n$$ \\sigma_D^2 = \\left(\\frac{r_K \\sigma_K}{D K_b}\\right)^2 + \\left(\\frac{r_\\varepsilon \\sigma_\\varepsilon}{D \\varepsilon_b}\\right)^2 = \\frac{1}{D^2} \\left[ \\left(\\frac{r_K \\sigma_K}{K_b}\\right)^2 + \\left(\\frac{r_\\varepsilon \\sigma_\\varepsilon}{\\varepsilon_b}\\right)^2 \\right] $$\n标准差为 $\\sigma_D = \\sqrt{\\sigma_D^2}$。双边 $95\\%$ 置信区间的半宽度为 $CI_{95, D} = z \\cdot \\sigma_D$。\n\n**3. 平均速度剖面验证**\n\n目标是计算平均速度剖面 $U(y)$ 的均匀加权 RMS 相对误差。\n\n设数据集由高度 $y_i$ 处的 $N_y$ 个点组成。输入为基准剖面 $U_b(y_i)$、计算剖面 $U_c(y_i)$ 和标准差 $\\sigma_{U_c}(y_i)$，其中 $i=1, \\dots, N_y$。\n\n每个高度处的相对误差为：\n$$ r_i = \\frac{U_c(y_i) - U_b(y_i)}{U_b(y_i)} $$\n\n均匀加权 RMS 相对误差 $P_{RMS}$ 是相对误差的标准 RMS：\n$$ P_{RMS} = \\sqrt{\\frac{1}{N_y} \\sum_{i=1}^{N_y} r_i^2} = \\sqrt{\\frac{1}{N_y} \\sum_{i=1}^{N_y} \\left( \\frac{U_c(y_i) - U_b(y_i)}{U_b(y_i)} \\right)^2} $$\n\n不确定度计算与能谱情况类似，但使用均匀权重 $w_i = 1/N_y$。$P_{RMS}$ 的方差为：\n$$ \\sigma_{P_{RMS}}^2 = \\sum_{i=1}^{N_y} \\left( \\frac{\\partial P_{RMS}}{\\partial U_c(y_i)} \\right)^2 \\sigma_{U_c}(y_i)^2 $$\n\n$P_{RMS}$ 相对于 $U_c(y_i)$ 的偏导数为（对于 $P_{RMS} \\neq 0$）：\n$$ \\frac{\\partial P_{RMS}}{\\partial U_c(y_i)} = \\frac{1}{2 P_{RMS}} \\frac{\\partial}{\\partial U_c(y_i)} \\left( \\frac{1}{N_y} \\sum_{j=1}^{N_y} r_j^2 \\right) = \\frac{1}{2 P_{RMS} N_y} \\cdot 2 r_i \\frac{\\partial r_i}{\\partial U_c(y_i)} = \\frac{r_i}{P_{RMS} N_y U_b(y_i)} $$\n如果 $P_{RMS} = 0$，则所有 $r_i=0$，不确定度必须为 $0$。\n\n方差变为：\n$$ \\sigma_{P_{RMS}}^2 = \\sum_{i=1}^{N_y} \\left( \\frac{r_i}{P_{RMS} N_y U_b(y_i)} \\right)^2 \\sigma_{U_c}(y_i)^2 = \\frac{1}{(P_{RMS} N_y)^2} \\sum_{i=1}^{N_y} \\frac{r_i^2}{U_b(y_i)^2} \\sigma_{U_c}(y_i)^2 $$\n标准差为 $\\sigma_{P_{RMS}} = \\sqrt{\\sigma_{P_{RMS}}^2}$。双边 $95\\%$ 置信区间的半宽度为 $CI_{95, P} = z \\cdot \\sigma_{P_{RMS}}$。\n\n将为每个提供的测试用例实施这些公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spectrum_metrics(E_b, E_c, sigma_Ec):\n    \"\"\"\n    Computes weighted RMS relative error for the spectrum and its 95% CI.\n    \"\"\"\n    E_b, E_c, sigma_Ec = np.array(E_b), np.array(E_c), np.array(sigma_Ec)\n    z_95 = 1.96\n\n    # Check for division by zero in benchmark data\n    if np.any(E_b == 0):\n        raise ValueError(\"Benchmark spectrum E_b contains zero values.\")\n\n    # 1. Compute relative errors\n    r = (E_c - E_b) / E_b\n\n    # 2. Compute weights proportional to benchmark energy\n    sum_Eb = np.sum(E_b)\n    if sum_Eb == 0:\n        # This case is unlikely if E_b has non-zero positive values.\n        return 0.0, 0.0\n    w = E_b / sum_Eb\n    \n    # 3. Compute weighted RMS relative error (S_rms)\n    S_rms_sq = np.sum(w * r**2)\n    S_rms = np.sqrt(S_rms_sq)\n\n    # 4. Compute uncertainty and CI half-width\n    if S_rms == 0:\n        # If the error is zero, the uncertainty is zero.\n        ci_half_width = 0.0\n    else:\n        # Variance of S_rms using first-order error propagation\n        # sigma_S_rms^2 = (1/S_rms^2) * sum( (w_i*r_i/E_b_i)^2 * sigma_Ec_i^2 )\n        # Corrected: S_rms^2 should be in denominator of variance, not S_rms\n        variance_sum_term = np.sum(((w * r / E_b)**2) * (sigma_Ec**2))\n        sigma_S_rms_sq = (1 / S_rms_sq) * variance_sum_term\n        sigma_S_rms = np.sqrt(sigma_S_rms_sq)\n        ci_half_width = z_95 * sigma_S_rms\n        \n    return S_rms, ci_half_width\n\ndef compute_integral_metrics(K_b, K_c, sigma_K, eps_b, eps_c, sigma_eps):\n    \"\"\"\n    Computes Euclidean-norm discrepancy for integral quantities and its 95% CI.\n    \"\"\"\n    z_95 = 1.96\n\n    if K_b == 0 or eps_b == 0:\n        raise ValueError(\"Benchmark integral quantities K_b or eps_b are zero.\")\n        \n    # 1. Compute relative errors\n    r_K = (K_c - K_b) / K_b\n    r_eps = (eps_c - eps_b) / eps_b\n\n    # 2. Compute Euclidean-norm discrepancy (D)\n    D_sq = r_K**2 + r_eps**2\n    D = np.sqrt(D_sq)\n\n    # 3. Compute uncertainty and CI half-width\n    if D == 0:\n        ci_half_width = 0.0\n    else:\n        # Variance of D using first-order error propagation\n        # sigma_D^2 = (1/D^2) * [ (r_K*sigma_K/K_b)^2 + (r_eps*sigma_eps/eps_b)^2 ]\n        # Corrected: D^2 should be in denominator of variance, not D\n        variance_term_K = (r_K * sigma_K / K_b)**2\n        variance_term_eps = (r_eps * sigma_eps / eps_b)**2\n        sigma_D_sq = (1 / D_sq) * (variance_term_K + variance_term_eps)\n        sigma_D = np.sqrt(sigma_D_sq)\n        ci_half_width = z_95 * sigma_D\n        \n    return D, ci_half_width\n\ndef compute_profile_metrics(U_b, U_c, sigma_Uc):\n    \"\"\"\n    Computes uniformly weighted RMS relative error for the mean profile and its 95% CI.\n    \"\"\"\n    U_b, U_c, sigma_Uc = np.array(U_b), np.array(U_c), np.array(sigma_Uc)\n    z_95 = 1.96\n    N_y = len(U_b)\n\n    if np.any(U_b == 0):\n        # The problem statement for case 1 includes U_b=0.10, not 0.\n        # But as a safeguard:\n        if np.any(np.array(U_b) == 0.0):\n             raise ValueError(\"Benchmark profile U_b contains zero values, which would lead to division by zero.\")\n    if N_y == 0:\n        return 0.0, 0.0\n\n    # 1. Compute relative errors\n    r = (U_c - U_b) / U_b\n\n    # 2. Compute uniformly weighted RMS relative error (P_rms)\n    P_rms_sq = np.mean(r**2)\n    P_rms = np.sqrt(P_rms_sq)\n\n    # 3. Compute uncertainty and CI half-width\n    if P_rms == 0:\n        ci_half_width = 0.0\n    else:\n        # Variance of P_rms using first-order error propagation\n        # sigma_P_rms^2 = (1/(P_rms*N_y)^2) * sum( (r_i/U_b_i)^2 * sigma_Uc_i^2 )\n        # Corrected: P_rms^2 should be in denominator, not P_rms\n        variance_sum_term = np.sum(((r / U_b)**2) * (sigma_Uc**2))\n        sigma_P_rms_sq = (1 / (P_rms_sq * N_y**2)) * variance_sum_term\n        sigma_P_rms = np.sqrt(sigma_P_rms_sq)\n        ci_half_width = z_95 * sigma_P_rms\n        \n    return P_rms, ci_half_width\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"spectrum\": {\"E_b\": [0.8,0.52,0.38,0.24,0.18,0.12], \"E_c\": [0.816,0.529,0.372,0.254,0.171,0.126], \"sigma_Ec\": [0.02,0.02,0.02,0.02,0.02,0.02]},\n            \"integrals\": {\"K_b\": 0.75, \"K_c\": 0.77, \"sigma_K\": 0.01, \"eps_b\": 0.45, \"eps_c\": 0.44, \"sigma_eps\": 0.015},\n            \"profile\": {\"U_b\": [0.10,0.22,0.35,0.49,0.63,0.78,0.92], \"U_c\": [0.105,0.218,0.348,0.500,0.618,0.790,0.910], \"sigma_Uc\": [0.01,0.01,0.01,0.01,0.01,0.01,0.01]}\n        },\n        {\n            \"spectrum\": {\"E_b\": [1.2,0.9,0.5,0.25,0.12,0.05], \"E_c\": [1.32,0.81,0.55,0.20,0.15,0.04], \"sigma_Ec\": [0.05,0.05,0.04,0.03,0.02,0.01]},\n            \"integrals\": {\"K_b\": 1.10, \"K_c\": 1.30, \"sigma_K\": 0.05, \"eps_b\": 0.80, \"eps_c\": 0.70, \"sigma_eps\": 0.04},\n            \"profile\": {\"U_b\": [0.12,0.28,0.48,0.70,0.88,1.00], \"U_c\": [0.11,0.31,0.44,0.73,0.84,1.05], \"sigma_Uc\": [0.02,0.02,0.02,0.02,0.02,0.03]}\n        },\n        {\n            \"spectrum\": {\"E_b\": [0.60,0.35,0.25,0.18,0.14,0.10], \"E_c\": [0.601,0.349,0.252,0.181,0.139,0.101], \"sigma_Ec\": [0.06,0.04,0.03,0.03,0.02,0.02]},\n            \"integrals\": {\"K_b\": 0.50, \"K_c\": 0.505, \"sigma_K\": 0.05, \"eps_b\": 0.60, \"eps_c\": 0.595, \"sigma_eps\": 0.06},\n            \"profile\": {\"U_b\": [0.15,0.32,0.50,0.70,0.85,0.95], \"U_c\": [0.148,0.325,0.495,0.705,0.848,0.952], \"sigma_Uc\": [0.05,0.05,0.05,0.05,0.05,0.05]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Spectrum calculation\n        s_rms, s_ci = compute_spectrum_metrics(**case[\"spectrum\"])\n        results.extend([s_rms, s_ci])\n\n        # Integral quantities calculation\n        i_d, i_ci = compute_integral_metrics(**case[\"integrals\"])\n        results.extend([i_d, i_ci])\n\n        # Mean profile calculation\n        p_rms, p_ci = compute_profile_metrics(**case[\"profile\"])\n        results.extend([p_rms, p_ci])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.7f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}