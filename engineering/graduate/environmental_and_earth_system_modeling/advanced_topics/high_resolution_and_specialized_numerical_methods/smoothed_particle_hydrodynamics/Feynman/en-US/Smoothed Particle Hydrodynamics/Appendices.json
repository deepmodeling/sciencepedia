{
    "hands_on_practices": [
        {
            "introduction": "The smoothing length, $h$, is arguably the most critical parameter in any Smoothed Particle Hydrodynamics (SPH) simulation, as it defines the spatial extent of particle interactions. A proper choice of $h$ is essential for numerical stability and accuracy. This exercise guides you through a foundational calculation that connects the smoothing length to the physical properties of the fluid and the desired number of neighboring particles, providing a first-principles approach to setting up a simulation.",
            "id": "3806998",
            "problem": "Consider a uniform, incompressible fluid modeled by Smoothed Particle Hydrodynamics (SPH) in three-dimensional space. The fluid has constant mass density $\\rho$ and is discretized into equal-mass particles of mass $m$. The SPH kernel is radially symmetric and has compact support within $|\\mathbf{r}| \\leq 2h$, where $h$ is the smoothing length. In multiscale modeling, the smoothing length $h$ is often calibrated to achieve a target expected neighbor count $N_n$ within the kernel support. Assume a statistically uniform particle distribution and that the expected neighbor count is defined as the integral of the particle number density over the kernel support domain.\n\nStarting from first principles—namely, the definition of number density as $\\rho/m$ for a uniform particle distribution, and the geometric measure of the kernel’s support domain in 3D—derive the closed-form expression for the smoothing length $h$ that achieves the target neighbor count $N_n = 60$. Express your final result as a symbolic function of $m$ and $\\rho$. Express the smoothing length in meters. No rounding is required.",
            "solution": "The user has requested the derivation of the smoothing length $h$ in a Smoothed Particle Hydrodynamics (SPH) context.\n\n### Step 1: Extract Givens\n- The fluid is uniform, incompressible, and in 3D space.\n- The mass density is a constant, $\\rho$.\n- The fluid is discretized into particles of equal mass, $m$.\n- The SPH kernel is radially symmetric and has compact support within a radius of $2h$, i.e., for $|\\mathbf{r}| \\leq 2h$.\n- The particle distribution is statistically uniform.\n- The number density is defined as $\\rho/m$.\n- The expected neighbor count, $N_n$, is the integral of the particle number density over the kernel support domain.\n- The target expected neighbor count is $N_n = 60$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically grounded in the principles of computational fluid dynamics, specifically the SPH method. All terms like \"smoothing length,\" \"kernel support,\" \"mass density,\" and \"number density\" are standard in this field. The relationship between these quantities is a fundamental aspect of initializing an SPH simulation. The problem is well-posed, providing all necessary information—the definition of number density, the geometry of the kernel support, and the target neighbor count—to derive a unique symbolic expression for the smoothing length $h$. The problem is objective and free of ambiguities or contradictions. Therefore, the problem is deemed valid.\n\n### Step 3: Derivation\nThe derivation proceeds from the definitions provided.\n\nFirst, we establish the particle number density, denoted by $n$. For a medium with uniform mass density $\\rho$ composed of particles each of mass $m$, the number of particles per unit volume (number density) is given by:\n$$n = \\frac{\\rho}{m}$$\nThis relationship is provided in the problem statement.\n\nNext, we determine the volume of the kernel's support domain. The problem specifies that the kernel has compact support for $|\\mathbf{r}| \\leq 2h$. In three-dimensional space, this domain is a sphere centered at the origin with a radius of $R = 2h$. The volume $V$ of a sphere with radius $R$ is given by the formula:\n$$V = \\frac{4}{3}\\pi R^3$$\nSubstituting $R = 2h$ into this formula, we find the volume of the support domain:\n$$V = \\frac{4}{3}\\pi (2h)^3 = \\frac{4}{3}\\pi (8h^3) = \\frac{32\\pi}{3}h^3$$\n\nThe problem defines the expected neighbor count $N_n$ as the integral of the particle number density over the kernel support domain. Since the particle distribution is assumed to be statistically uniform, the number density $n$ is constant throughout the volume $V$. The integral thus simplifies to the product of the constant number density and the volume of a particle's neighborhood:\n$$N_n = \\int_V n \\, dV = n \\int_V dV = nV$$\n\nNow, we substitute the expressions for $n$ and $V$ into this equation:\n$$N_n = \\left(\\frac{\\rho}{m}\\right) \\left(\\frac{32\\pi}{3}h^3\\right)$$\nThis equation relates the neighbor count $N_n$ to the smoothing length $h$ and the physical parameters $m$ and $\\rho$. Our goal is to solve for $h$.\n$$N_n = \\frac{32\\pi\\rho}{3m} h^3$$\n\nTo find $h$, we rearrange the equation:\n$$h^3 = N_n \\frac{3m}{32\\pi\\rho}$$\n$$h = \\left(\\frac{3m N_n}{32\\pi\\rho}\\right)^{1/3}$$\n\nThe problem specifies a target neighbor count of $N_n = 60$. We substitute this value into the expression for $h$:\n$$h = \\left(\\frac{3m(60)}{32\\pi\\rho}\\right)^{1/3} = \\left(\\frac{180m}{32\\pi\\rho}\\right)^{1/3}$$\n\nFinally, we simplify the numerical fraction $\\frac{180}{32}$. Both the numerator and the denominator are divisible by $4$:\n$$\\frac{180}{32} = \\frac{180 \\div 4}{32 \\div 4} = \\frac{45}{8}$$\n\nSubstituting this simplified fraction back into the expression for $h$, we obtain the final closed-form expression:\n$$h = \\left(\\frac{45m}{8\\pi\\rho}\\right)^{1/3}$$\nThis expression gives the smoothing length $h$ as a function of particle mass $m$ and fluid density $\\rho$ required to achieve an expected neighbor count of $60$ in a uniform 3D SPH particle distribution.",
            "answer": "$$\\boxed{\\left(\\frac{45m}{8\\pi\\rho}\\right)^{1/3}}$$"
        },
        {
            "introduction": "The accuracy of the SPH method is intrinsically linked to the spatial arrangement of the particles themselves. While perfectly ordered lattices are useful for theoretical analysis, most fluid flows involve disordered particle configurations. This hands-on coding practice allows you to quantitatively investigate how particle disorder impacts the fundamental SPH density estimate, comparing the results from a regular lattice to those from a more realistic, glass-like arrangement.",
            "id": "2439536",
            "problem": "You are asked to quantitatively assess how particle disorder affects the accuracy of the Smoothed Particle Hydrodynamics (SPH) density estimate for a uniform, compressible fluid in two spatial dimensions. Consider a fluid occupying a periodic unit square domain with side length $L=1$ and area $A=L^2=1$. The fluid has constant surface density $\\rho_0=1$ expressed in dimensionless units. The domain is populated by $N$ equal-mass particles at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ with total mass $M=\\rho_0 A=1$, so each particle has mass $m=M/N=1/N$.\n\nFor any particle $i$, the SPH density estimate is defined by\n$$\n\\rho_i \\equiv \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right),\n$$\nwhere $\\|\\cdot\\|_\\mathrm{per}$ denotes the minimum-image periodic distance on the unit torus and $W(r,h)$ is the standard cubic spline SPH kernel in two spatial dimensions with compact support $2h$ and smoothing length $h$. The smoothing length must be chosen as\n$$\nh = \\eta \\,\\Delta, \\quad \\text{with} \\quad \\Delta = \\sqrt{\\frac{A}{N}} = \\frac{1}{\\sqrt{N}},\n$$\nfor a fixed constant $\\eta=1.2$.\n\nTwo distinct particle arrangements must be considered for each specified value of $N$:\n\n- Lattice arrangement: particles placed on a regular square lattice of size $\\sqrt{N}\\times\\sqrt{N}$ within the unit square with periodic boundaries.\n- Glass-like arrangement: particles placed at the first $N$ points of the two-dimensional Halton sequence with bases $2$ and $3$, i.e., for $k=1,2,\\ldots,N$, the position is $\\mathbf{r}_k=\\big(\\phi_2(k),\\,\\phi_3(k)\\big)$ where $\\phi_b(k)$ is the radical-inverse function in base $b$.\n\nFor each arrangement and for each $N$, compute the following dimensionless error metrics comparing the SPH density estimate $\\{\\rho_i\\}$ to the exact uniform density $\\rho_0$:\n- The mean absolute relative error,\n$$\nE_1 = \\frac{1}{N}\\sum_{i=1}^N \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n- The root-mean-square relative error,\n$$\nE_2 = \\frac{1}{\\sqrt{N}}\\left(\\sum_{i=1}^N \\left(\\frac{\\rho_i-\\rho_0}{\\rho_0}\\right)^2\\right)^{1/2}.\n$$\n- The maximum relative error,\n$$\nE_\\infty = \\max_{1\\le i\\le N} \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n\nUse strictly dimensionless units throughout, and express all error values as decimal numbers (not as percentages). For each error metric, round the result to six decimal places.\n\nTest Suite:\nEvaluate the triplet $\\big[E_1,E_2,E_\\infty\\big]$ for the following ordered list of test cases, where each case specifies a pair $(N,\\text{arrangement})$:\n- $(N=\\;100,\\;\\text{lattice})$\n- $(N=\\;100,\\;\\text{glass})$\n- $(N=\\;256,\\;\\text{lattice})$\n- $(N=\\;256,\\;\\text{glass})$\n- $(N=\\;441,\\;\\text{lattice})$\n- $(N=\\;441,\\;\\text{glass})$\n\nAdopt the minimum-image periodic distance on the unit square torus for all pairwise separations in the kernel evaluations. For each $N$ in the lattice arrangement, assume $N$ is a perfect square so that the lattice is $\\sqrt{N}\\times\\sqrt{N}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one test case in the specified order and containing the three rounded error values in the order $\\big[E_1,E_2,E_\\infty\\big]$. For example:\n\"[ [e11,e12,e13],[e21,e22,e23],... ]\"\nEnsure the numerical values are rounded to six decimal places and there is no additional text beyond this single line. Use dimensionless units for all computations and outputs.",
            "solution": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH density error problem.\n    \"\"\"\n    \n    # Define the problem constants and test cases.\n    RHO_0 = 1.0\n    ETA = 1.2\n    \n    test_cases = [\n        (100, 'lattice'),\n        (100, 'glass'),\n        (256, 'lattice'),\n        (256, 'glass'),\n        (441, 'lattice'),\n        (441, 'glass'),\n    ]\n\n    # --- Helper functions ---\n\n    def radical_inverse(k, base):\n        \"\"\"Computes the radical inverse of k in a given base.\"\"\"\n        inv = 0.0\n        f = 1.0 / base\n        while k > 0:\n            inv += (k % base) * f\n            k //= base\n            f /= base\n        return inv\n\n    def generate_lattice(n_particles):\n        \"\"\"Generates particle positions on a regular square lattice.\"\"\"\n        n_side = int(np.sqrt(n_particles))\n        if n_side**2 != n_particles:\n            raise ValueError(\"N must be a perfect square for lattice arrangement\")\n        \n        points = np.zeros((n_particles, 2))\n        dx = 1.0 / n_side\n        \n        idx = 0\n        for i in range(n_side):\n            for j in range(n_side):\n                points[idx, 0] = (i + 0.5) * dx\n                points[idx, 1] = (j + 0.5) * dx\n                idx += 1\n        return points\n\n    def generate_glass(n_particles):\n        \"\"\"Generates particle positions from a Halton sequence.\"\"\"\n        points = np.zeros((n_particles, 2))\n        for k in range(1, n_particles + 1):\n            points[k-1, 0] = radical_inverse(k, 2)\n            points[k-1, 1] = radical_inverse(k, 3)\n        return points\n\n    def W_cubic_spline_vectorized(r, h):\n        \"\"\"Vectorized 2D cubic spline SPH kernel.\"\"\"\n        alpha_d = 10.0 / (7.0 * np.pi * h**2)\n        q = r / h\n        \n        res = np.zeros_like(q)\n        \n        # Condition: 1  q = 2\n        mask1 = (q > 1.0)  (q = 2.0)\n        q1 = q[mask1]\n        res[mask1] = alpha_d * 0.25 * (2.0 - q1)**3\n        \n        # Condition: 0 = q = 1\n        mask2 = q = 1.0\n        q2 = q[mask2]\n        res[mask2] = alpha_d * (1.0 - 1.5 * q2**2 + 0.75 * q2**3)\n        \n        return res\n\n    def compute_errors(n_particles, arrangement_type):\n        \"\"\"\n        Computes the SPH density and error metrics for a given configuration.\n        \"\"\"\n        # 1. Set parameters\n        m = 1.0 / n_particles\n        delta = 1.0 / np.sqrt(n_particles)\n        h = ETA * delta\n\n        # 2. Generate particle positions\n        if arrangement_type == 'lattice':\n            positions = generate_lattice(n_particles)\n        elif arrangement_type == 'glass':\n            positions = generate_glass(n_particles)\n        else:\n            raise ValueError(f\"Unknown arrangement type: {arrangement_type}\")\n            \n        # 3. Compute pairwise periodic distances (vectorized)\n        delta_r = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        delta_r -= np.round(delta_r)  # Minimum image convention for unit domain\n        distances = np.linalg.norm(delta_r, axis=2)\n\n        # 4. Evaluate kernel for all pairs\n        kernel_values = W_cubic_spline_vectorized(distances, h)\n\n        # 5. Sum contributions to get densities\n        densities = m * np.sum(kernel_values, axis=1)\n\n        # 6. Compute error metrics\n        relative_errors = (densities - RHO_0) / RHO_0\n        \n        e1 = np.mean(np.abs(relative_errors))\n        e2 = np.sqrt(np.mean(relative_errors**2))\n        e_inf = np.max(np.abs(relative_errors))\n        \n        return [round(e1, 6), round(e2, 6), round(e_inf, 6)]\n\n    # --- Main execution loop ---\n    \n    all_results = []\n    for n, arr_type in test_cases:\n        errors = compute_errors(n, arr_type)\n        all_results.append(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```",
            "answer": "[[0.0, 0.0, 0.0],[0.02115, 0.026786, 0.076816],[0.0, 0.0, 0.0],[0.008451, 0.010729, 0.038161],[0.0, 0.0, 0.0],[0.004813, 0.006112, 0.024505]]"
        },
        {
            "introduction": "Moving from static field estimation to dynamic simulation is a major step in computational physics. A crucial test for any numerical dynamics code is its ability to respect the fundamental conservation laws of the physical system it models. This exercise challenges you to build a simple SPH simulator for a rotating, self-gravitating gas cloud and verify its conservation of angular momentum, a key hallmark of a robust, physically consistent implementation.",
            "id": "2439484",
            "problem": "You are to write a complete, runnable program that numerically evolves a two-dimensional, self-gravitating gas cloud using Smoothed Particle Hydrodynamics (SPH) in nondimensional units and analyzes the conservation of total angular momentum. Work in nondimensional units with gravitational constant $G=1$. Consider a barotropic gas with pressure given by $P(\\rho) = c_s^2 \\rho$, where $c_s$ is a constant sound speed, and treat self-gravity via Newtonian pairwise attraction with a softening length $\\epsilon$.\n\nLet there be $N$ particles in the plane with equal masses $m_i = M/N$, total mass $M=1$, positions $\\vec{r}_i(t) \\in \\mathbb{R}^2$, and velocities $\\vec{v}_i(t) \\in \\mathbb{R}^2$. The total angular momentum about the origin is\n$$\n\\vec{L}(t) = \\sum_{i=1}^{N} m_i \\, \\vec{r}_i(t) \\times \\vec{v}_i(t),\n$$\nwhere the cross product is the standard three-dimensional cross product; in two dimensions, its magnitude corresponds to the out-of-plane component. Evolve the system under the Euler momentum equation with the stated equation of state and self-gravity. Assume no external forces and no physical viscosity. Initialize the particles at $t=0$ as described in each test case below.\n\nYour task is to numerically integrate the equations of motion from $t=0$ to $t=T$ for each test case, track the magnitude $|\\vec{L}(t)|$ at discrete times including the initial and all subsequent time steps, and compute the following diagnostic for each case:\n- If $|\\vec{L}(0)|  0$, report\n$$\n\\max_{0 \\le t \\le T} \\frac{\\left|\\,|\\vec{L}(t)| - |\\vec{L}(0)|\\,\\right|}{|\\vec{L}(0)|}.\n$$\n- If $|\\vec{L}(0)| = 0$, report\n$$\n\\max_{0 \\le t \\le T} |\\vec{L}(t)|.\n$$\n\nUse the following test suite. In all cases, place particles uniformly on a circle of radius $R$ centered at the origin, at polar angles $\\theta_k = 2\\pi k/N$ for $k \\in \\{0,1,\\dots,N-1\\}$, with positions $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$. Set initial velocities to solid-body rotation with angular speed $\\Omega$ about the origin, $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$.\n\nTest suite (each tuple lists $(N, R, \\Omega, c_s, h, \\epsilon, T, \\Delta t)$):\n1. $(N=32, R=1.0, \\Omega=0.5, c_s=0.05, h=0.2, \\epsilon=0.02, T=2.0, \\Delta t=0.002)$\n2. $(N=1, R=1.0, \\Omega=1.0, c_s=0.0, h=0.1, \\epsilon=0.0, T=1.0, \\Delta t=0.005)$\n3. $(N=32, R=1.0, \\Omega=0.0, c_s=0.05, h=0.2, \\epsilon=0.02, T=1.0, \\Delta t=0.002)$\n\nFor each test case, use SPH to model pressure forces and pairwise softened Newtonian gravity to model self-gravity. You must use a spherically symmetric, compactly supported smoothing kernel with smoothing length $h$ and compute densities via standard SPH density summation, and compute pressure forces using a momentum-conserving symmetric form. Gravitational softening must be implemented so that the pairwise gravitational force between particles $i$ and $j$ is proportional to $(\\vec{r}_i - \\vec{r}_j)/\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}$.\n\nYour program must produce a single line of output containing the three diagnostic values for the three test cases, in order, as a comma-separated list enclosed in square brackets. For example, the output format must be exactly like:\n[diagnostic_case1,diagnostic_case2,diagnostic_case3]\nAll quantities are nondimensional; do not include any units in the output.",
            "solution": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numpy print options (not strictly necessary, but consistent output)\nnp.set_printoptions(precision=10, floatmode='maxprec')\n\ndef cubic_spline_W_2d(r, h):\n    \"\"\"\n    2D cubic spline (M4) kernel value W(r,h).\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    W = np.zeros_like(r)\n    mask1 = (q >= 0)  (q  1)\n    mask2 = (q >= 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    W[mask1] = 1 - 1.5*q1*q1 + 0.75*q1*q1*q1\n    W[mask2] = 0.25 * (2 - q2)**3\n    return sigma * W\n\ndef cubic_spline_dW_dr_2d(r, h):\n    \"\"\"\n    Derivative dW/dr for 2D cubic spline kernel.\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    dW_dq = np.zeros_like(r)\n    mask1 = (q >= 0)  (q  1)\n    mask2 = (q >= 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    # d/dq of 1 - 1.5 q^2 + 0.75 q^3 is -3 q + 2.25 q^2\n    dW_dq[mask1] = -3.0*q1 + 2.25*q1*q1\n    # d/dq of 0.25 (2 - q)^3 is -0.75 (2 - q)^2\n    dW_dq[mask2] = -0.75 * (2 - q2)**2\n    # dW/dr = (dW/dq) * (1/h) * sigma\n    return sigma * dW_dq / h\n\ndef compute_densities(positions, masses, h):\n    \"\"\"\n    Compute SPH densities by direct summation using the 2D cubic spline kernel.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n    W = cubic_spline_W_2d(dist, h)     # (N,N)\n    rho = W @ masses  # (N,)\n    return rho\n\ndef compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0):\n    \"\"\"\n    Compute accelerations from SPH pressure forces and softened self-gravity.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    N = positions.shape[0]\n    # Density and pressure\n    rho = compute_densities(positions, masses, h)\n    P = (cs * cs) * rho\n\n    # Pairwise vectors\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n\n    # Kernel gradient\n    dW_dr = cubic_spline_dW_dr_2d(dist, h)  # (N,N)\n    # Avoid division by zero\n    inv_r = 1.0 / (dist + 1e-16)\n    gradW = (dW_dr * inv_r)[..., None] * dx  # (N,N,2)\n\n    # Symmetric pressure force factor: (P_i/rho_i^2 + P_j/rho_j^2)\n    # Build matrices via broadcasting\n    Pi_over_rhoi2 = (P / (rho * rho + 1e-30))  # (N,)\n    Pj_over_rhoj2 = Pi_over_rhoi2              # same array, but we'll broadcast\n    term_ij = Pi_over_rhoi2[:, None] + Pj_over_rhoj2[None, :]  # (N,N)\n    # Multiply by masses of j\n    mj = masses[None, :]  # (1,N)\n    facP = term_ij * mj   # (N,N)\n\n    # Pressure acceleration\n    aP = -np.sum(facP[..., None] * gradW, axis=1)  # (N,2)\n\n    # Gravity: softened Newtonian\n    soft2 = eps_soft * eps_soft\n    inv_r3 = 1.0 / (dist*dist + soft2)**1.5  # (N,N)\n    # Exclude self-interaction\n    np.fill_diagonal(inv_r3, 0.0)\n    aG = -G * np.sum((mj[..., None] * inv_r3[..., None]) * dx, axis=1)  # (N,2)\n\n    return aP + aG\n\ndef angular_momentum_z(positions, velocities, masses):\n    \"\"\"\n    Compute total angular momentum (z-component) for 2D system: Lz = sum m (x vy - y vx)\n    \"\"\"\n    x = positions[:, 0]\n    y = positions[:, 1]\n    vx = velocities[:, 0]\n    vy = velocities[:, 1]\n    Lz = np.sum(masses * (x * vy - y * vx))\n    return Lz\n\ndef simulate_case(N, R, Omega, cs, h, eps_soft, T, dt):\n    \"\"\"\n    Simulate one test case and return the diagnostic:\n    - If |L0| > 0: max_t | |L(t)| - |L0| | / |L0|\n    - If |L0| == 0: max_t |L(t)|\n    \"\"\"\n    # Initialize masses\n    M = 1.0\n    masses = np.full(N, M / N)\n    # Initialize positions on a circle\n    if N == 1:\n        thetas = np.array([0.0])\n    else:\n        thetas = 2.0 * np.pi * np.arange(N) / N\n    positions = np.column_stack([R * np.cos(thetas), R * np.sin(thetas)])\n    # Solid-body rotation velocities v = Omega * (-y, x)\n    velocities = Omega * np.column_stack([-positions[:, 1], positions[:, 0]])\n\n    # Initial acceleration\n    acc = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n\n    # Track angular momentum magnitude over time\n    L0 = angular_momentum_z(positions, velocities, masses)\n    L_mags = [abs(L0)]\n\n    steps = int(np.round(T / dt))\n    # Velocity Verlet integration\n    for _ in range(steps):\n        # r_{n+1} = r_n + v_n dt + 0.5 a_n dt^2\n        positions = positions + velocities * dt + 0.5 * acc * (dt * dt)\n        # a_{n+1}\n        acc_new = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n        # v_{n+1} = v_n + 0.5 (a_n + a_{n+1}) dt\n        velocities = velocities + 0.5 * (acc + acc_new) * dt\n        # Prepare for next step\n        acc = acc_new\n        # Record angular momentum magnitude\n        L_mags.append(abs(angular_momentum_z(positions, velocities, masses)))\n\n    L0_abs = abs(L0)\n    if L0_abs > 1e-14:\n        deviations = np.abs(np.array(L_mags) - L0_abs) / L0_abs\n        diagnostic = float(np.max(deviations))\n    else:\n        diagnostic = float(np.max(L_mags))\n    return diagnostic\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, Omega, cs, h, eps, T, dt)\n        (32, 1.0, 0.5, 0.05, 0.2, 0.02, 2.0, 0.002),\n        (1,  1.0, 1.0, 0.0,  0.1, 0.0,  1.0, 0.005),\n        (32, 1.0, 0.0, 0.05, 0.2, 0.02, 1.0, 0.002),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, Omega, cs, h, eps_soft, T, dt = case\n        result = simulate_case(N, R, Omega, cs, h, eps_soft, T, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "answer": "[1.3259926955e-05,1.1102230246e-16,4.7214352134e-16]"
        }
    ]
}