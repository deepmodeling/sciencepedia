{
    "hands_on_practices": [
        {
            "introduction": "任何SPH模拟都始于定义粒子与其所代表的连续体之间的关系。平滑长度$h$是定义这种相互作用尺度的关键参数。本练习将从第一性原理出发，演示如何选择$h$以确保每个粒子与期望数量的邻近粒子相互作用，这是保证模拟稳定性和准确性的基础校准步骤。",
            "id": "3806998",
            "problem": "考虑一种由光滑粒子流体动力学（SPH，Smoothed Particle Hydrodynamics）建模的均匀、不可压缩流体，该流体处于三维（$3$D）空间中。该流体具有恒定的质量密度 $\\rho$，并被离散化为质量为 $m$ 的等质量粒子。SPH 核函数是径向对称的，并在 $|\\mathbf{r}| \\leq 2h$ 范围内具有紧支集，其中 $h$ 是光滑长度。在多尺度建模中，光滑长度 $h$ 通常被校准以在核函数支撑域内达到一个目标期望邻居数 $N_n$。假设粒子分布在统计上是均匀的，并且期望邻居数定义为粒子数密度在核函数支撑域上的积分。\n\n从第一性原理出发——即对于均匀粒子分布，数密度定义为 $\\rho/m$，以及核函数在三维空间中支撑域的几何测度——推导能够实现目标邻居数 $N_n = 60$ 的光滑长度 $h$ 的闭式表达式。将您的最终结果表示为关于 $m$ 和 $\\rho$ 的符号函数。以米为单位表示光滑长度。无需四舍五入。",
            "solution": "用户要求在光滑粒子流体动力学 (SPH) 的背景下推导光滑长度 $h$。\n\n### 第一步：提取已知条件\n- 流体是均匀、不可压缩的，且位于三维空间中。\n- 质量密度为常数 $\\rho$。\n- 流体被离散化为质量相等的粒子，质量为 $m$。\n- SPH 核函数是径向对称的，并在半径为 $2h$ 的范围内具有紧支集，即对于 $|\\mathbf{r}| \\leq 2h$。\n- 粒子分布在统计上是均匀的。\n- 数密度定义为 $\\rho/m$。\n- 期望邻居数 $N_n$ 是粒子数密度在核函数支撑域上的积分。\n- 目标期望邻居数为 $N_n = 60$。\n\n### 第二步：使用提取的已知条件进行验证\n该问题陈述的科学依据在于计算流体动力学的原理，特别是 SPH 方法。诸如“光滑长度”、“核函数支撑域”、“质量密度”和“数密度”等术语在该领域都是标准术语。这些量之间的关系是初始化 SPH 模拟的一个基本方面。该问题是适定的，提供了推导光滑长度 $h$ 的唯一符号表达式所需的所有信息——数密度的定义、核函数支撑域的几何形状以及目标邻居数。该问题客观且没有歧义或矛盾。因此，该问题被认为是有效的。\n\n### 第三步：推导\n推导过程从所给的定义出发。\n\n首先，我们确定粒子数密度，记为 $n$。对于一个由质量均为 $m$ 的粒子组成的、具有均匀质量密度 $\\rho$ 的介质，单位体积内的粒子数（即数密度）由下式给出：\n$$n = \\frac{\\rho}{m}$$\n这个关系在问题陈述中已经给出。\n\n接下来，我们确定核函数支撑域的体积。问题指明核函数在 $|\\mathbf{r}| \\leq 2h$ 内具有紧支集。在三维空间中，这个区域是一个以原点为中心、半径为 $R = 2h$ 的球体。半径为 $R$ 的球体体积 $V$ 由以下公式给出：\n$$V = \\frac{4}{3}\\pi R^3$$\n将 $R = 2h$ 代入此公式，我们得到支撑域的体积：\n$$V = \\frac{4}{3}\\pi (2h)^3 = \\frac{4}{3}\\pi (8h^3) = \\frac{32\\pi}{3}h^3$$\n\n问题将期望邻居数 $N_n$ 定义为粒子数密度在核函数支撑域上的积分。由于假定粒子分布是统计均匀的，数密度 $n$ 在整个体积 $V$ 内是恒定的。因此，该积分简化为常数数密度与粒子邻域体积的乘积：\n$$N_n = \\int_V n \\, dV = n \\int_V dV = nV$$\n\n现在，我们将 $n$ 和 $V$ 的表达式代入此方程：\n$$N_n = \\left(\\frac{\\rho}{m}\\right) \\left(\\frac{32\\pi}{3}h^3\\right)$$\n这个方程将邻居数 $N_n$ 与光滑长度 $h$ 以及物理参数 $m$ 和 $\\rho$ 联系起来。我们的目标是解出 $h$。\n$$N_n = \\frac{32\\pi\\rho}{3m} h^3$$\n\n为了求得 $h$，我们重新整理方程：\n$$h^3 = N_n \\frac{3m}{32\\pi\\rho}$$\n$$h = \\left(\\frac{3m N_n}{32\\pi\\rho}\\right)^{1/3}$$\n\n问题指定了目标邻居数为 $N_n = 60$。我们将这个值代入 $h$ 的表达式中：\n$$h = \\left(\\frac{3m(60)}{32\\pi\\rho}\\right)^{1/3} = \\left(\\frac{180m}{32\\pi\\rho}\\right)^{1/3}$$\n\n最后，我们简化数值分数 $\\frac{180}{32}$。分子和分母都可以被 $4$ 整除：\n$$\\frac{180}{32} = \\frac{180 \\div 4}{32 \\div 4} = \\frac{45}{8}$$\n\n将这个简化的分数代回 $h$ 的表达式，我们得到最终的闭式表达式：\n$$h = \\left(\\frac{45m}{8\\pi\\rho}\\right)^{1/3}$$\n此表达式给出了在均匀三维 SPH 粒子分布中，为达到60的期望邻居数所需的光滑长度 $h$，它是粒子质量 $m$ 和流体密度 $\\rho$ 的函数。",
            "answer": "$$\\boxed{\\left(\\frac{45m}{8\\pi\\rho}\\right)^{1/3}}$$"
        },
        {
            "introduction": "SPH中的一个核心操作是从粒子分布中重建密度等物理场。这种重建的准确性不仅取决于分辨率，还关键性地依赖于粒子的空间排列。通过这个动手编程练习，您将定量地比较在规则晶格与无序的“类玻璃”排列下的密度误差，从而清晰、实践地理解为何在SPH中通常首选无序粒子配置以减少离散化误差。",
            "id": "2439536",
            "problem": "要求您定量评估粒子无序性如何影响二维空间中均匀、可压缩流体的平滑粒子流体动力学（SPH）密度估计的准确性。考虑一个流体，其占据一个边长为 $L=1$、面积为 $A=L^2=1$ 的周期性单位正方形域。该流体的恒定面密度为 $\\rho_0=1$（以无量纲单位表示）。该域中分布着 $N$ 个等质量粒子，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，总质量为 $M=\\rho_0 A=1$，因此每个粒子的质量为 $m=M/N=1/N$。\n\n对于任意粒子 $i$，其 SPH 密度估计定义为\n$$\n\\rho_i \\equiv \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right),\n$$\n其中 $\\|\\cdot\\|_\\mathrm{per}$ 表示单位环面上的最小镜像周期距离，$W(r,h)$ 是二维空间中标准的三次样条 SPH 核函数，其紧支集为 $2h$，平滑长度为 $h$。平滑长度必须选择为\n$$\nh = \\eta \\,\\Delta, \\quad \\text{with} \\quad \\Delta = \\sqrt{\\frac{A}{N}} = \\frac{1}{\\sqrt{N}},\n$$\n其中 $\\eta=1.2$ 为一个固定常数。\n\n对于每个指定的 $N$ 值，必须考虑两种不同的粒子排列方式：\n\n- 晶格排列：粒子放置在具有周期性边界的单位正方形内一个大小为 $\\sqrt{N}\\times\\sqrt{N}$ 的正方形晶格上。\n- 类玻璃体排列：粒子放置在以 2 和 3 为基数的二维 Halton 序列的前 $N$ 个点上，即对于 $k=1,2,\\ldots,N$，位置为 $\\mathbf{r}_k=\\big(\\phi_2(k),\\,\\phi_3(k)\\big)$，其中 $\\phi_b(k)$ 是以 $b$ 为基数的根倒数函数。\n\n对于每种排列方式和每个 $N$ 值，计算以下无量纲误差度量，以比较 SPH 密度估计 $\\{\\rho_i\\}$ 与精确的均匀密度 $\\rho_0$：\n- 平均绝对相对误差，\n$$\nE_1 = \\frac{1}{N}\\sum_{i=1}^N \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n- 均方根相对误差，\n$$\nE_2 = \\frac{1}{\\sqrt{N}}\\left(\\sum_{i=1}^N \\left(\\frac{\\rho_i-\\rho_0}{\\rho_0}\\right)^2\\right)^{1/2}.\n$$\n- 最大相对误差，\n$$\nE_\\infty = \\max_{1\\le i\\le N} \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n\n在整个计算过程中严格使用无量纲单位，并将所有误差值表示为小数（而非百分比）。对于每个误差度量，将结果四舍五入到六位小数。\n\n测试套件：\n为以下有序的测试用例列表评估三元组 $\\big[E_1,E_2,E_\\infty\\big]$，其中每个用例指定一个序对 $(N,\\text{arrangement})$：\n- $(N=\\;100,\\;\\text{晶格})$\n- $(N=\\;100,\\;\\text{类玻璃体})$\n- $(N=\\;256,\\;\\text{晶格})$\n- $(N=\\;256,\\;\\text{类玻璃体})$\n- $(N=\\;441,\\;\\text{晶格})$\n- $(N=\\;441,\\;\\text{类玻璃体})$\n\n在所有核函数评估中，对所有成对距离采用单位正方形环面上的最小镜像周期距离。对于晶格排列中的每个 $N$，假定 $N$ 是一个完全平方数，以便晶格为 $\\sqrt{N}\\times\\sqrt{N}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表对应一个指定顺序的测试用例，并按 $\\big[E_1,E_2,E_\\infty\\big]$ 的顺序包含三个四舍五入后的误差值。例如：\n\"[ [e11,e12,e13],[e21,e22,e23],... ]\"\n确保数值四舍五入到六位小数，并且除了这一行之外没有其他文本。所有计算和输出均使用无量纲单位。",
            "solution": "问题陈述已经过验证，被认定为科学上合理、适定且完整。它构成了计算物理学领域中的一个标准数值实验，旨在评估平滑粒子流体动力学（SPH）方法的准确性。任务是计算二维粒子分布的密度误差。将采用如下直接计算方法。\n\nSPH 方法的核心是通过对一组离散粒子进行求和来表示连续场 $A(\\mathbf{r})$。对于密度场 $\\rho$，这表示为：\n$$\n\\rho(\\mathbf{r}) = \\sum_{j} m_j W\\left(\\left\\|\\mathbf{r} - \\mathbf{r}_j\\right\\|,\\, h\\right)\n$$\n其中 $m_j$ 和 $\\mathbf{r}_j$ 分别是粒子 $j$ 的质量和位置，$W$ 是一个具有特征宽度 $h$（即平滑长度）的平滑核函数。问题将位于位置 $\\mathbf{r}_i$ 的粒子 $i$ 的 SPH 密度估计指定为：\n$$\n\\rho_i = \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right)\n$$\n计算域是一个二维单位正方形，具有周期性边界条件，面积 $A=1$，总质量 $M=1$。流体具有恒定的参考面密度 $\\rho_0=1$。对于 $N$ 个粒子，每个粒子的质量因此为 $m = M/N = 1/N$。距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$ 是单位环面上的最小镜像距离，对于位移矢量 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y)$，其计算公式为 $\\sqrt{(\\Delta x - \\text{round}(\\Delta x))^2 + (\\Delta y - \\text{round}(\\Delta y))^2}$。\n\n平滑长度 $h$ 与平均粒子间距 $\\Delta$ 相关联。对于一个面积为 $A=1$、包含 $N$ 个粒子的二维域，平均间距为 $\\Delta = \\sqrt{A/N} = 1/\\sqrt{N}$。平滑长度设为 $h = \\eta \\Delta$，常数 $\\eta = 1.2$。\n\n核函数 $W(r, h)$ 是二维标准三次样条函数，仅在 $r \\le 2h$ 时非零。其解析形式为：\n$$\nW(r,h) = \\frac{10}{7\\pi h^2} \\times \\begin{cases} 1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3  0 \\le q \\le 1 \\\\ \\frac{1}{4}(2-q)^3  1  q \\le 2 \\\\ 0  q > 2 \\end{cases}\n$$\n其中 $q = r/h$ 是归一化距离。\n\n该分析需要两种粒子配置：\n1.  **晶格排列**：粒子被放置在一个均匀的 $\\sqrt{N} \\times \\sqrt{N}$ 网格上。粒子 $(i,j)$ 的坐标取为 $(\\frac{i+0.5}{\\sqrt{N}}, \\frac{j+0.5}{\\sqrt{N}})$，其中 $i,j \\in \\{0, 1, \\dots, \\sqrt{N}-1\\}$。这确保了晶格在单位域内居中。\n2.  **类玻璃体排列**：粒子被放置在以 2 和 3 为基数的二维 Halton 序列的前 $N$ 个点上。第 $k$ 个粒子（$k=1, \\dots, N$）的位置是 $\\mathbf{r}_k = (\\phi_2(k), \\phi_3(k))$，其中 $\\phi_b(k)$ 是以 $b$ 为基数的根倒数函数。\n\n对于每种配置和指定的 $N$ 值，使用三种误差度量将 SPH 估计的密度 $\\{\\rho_i\\}_{i=1}^N$ 与精确密度 $\\rho_0=1$ 进行比较：\n-   平均绝对相对误差：$E_1 = \\frac{1}{N}\\sum_{i=1}^N |\\rho_i-1|$\n-   均方根相对误差：$E_2 = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N (\\rho_i-1)^2}$\n-   最大相对误差：$E_\\infty = \\max_{1\\le i\\le N} |\\rho_i-1|$\n\n计算流程如下：\n1.  对于由 $(N, \\text{arrangement})$ 指定的每个测试用例，生成粒子位置 $\\{\\mathbf{r}_i\\}$。\n2.  计算所有 $i,j \\in \\{1, \\dots, N\\}$ 的成对周期距离矩阵 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$。为提高效率，此计算被向量化。\n3.  对所有粒子对评估核函数 $W(d_{ij}, h)$，创建一个核函数值矩阵。\n4.  通过对核矩阵的第 $i$ 行求和，并乘以粒子质量 $m=1/N$，来计算每个粒子 $\\rho_i$ 的密度。\n5.  根据计算出的密度向量，计算误差度量 $E_1, E_2, E_\\infty$。\n6.  按要求将最终误差值四舍五入到六位小数。\n\n整个过程使用 Python 的 `numpy` 库实现，以高效处理数组操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH density error problem.\n    \"\"\"\n    \n    # Define the problem constants and test cases.\n    RHO_0 = 1.0\n    ETA = 1.2\n    \n    test_cases = [\n        (100, 'lattice'),\n        (100, 'glass'),\n        (256, 'lattice'),\n        (256, 'glass'),\n        (441, 'lattice'),\n        (441, 'glass'),\n    ]\n\n    # --- Helper functions ---\n\n    def radical_inverse(k, base):\n        \"\"\"Computes the radical inverse of k in a given base.\"\"\"\n        inv = 0.0\n        f = 1.0 / base\n        while k > 0:\n            inv += (k % base) * f\n            k //= base\n            f /= base\n        return inv\n\n    def generate_lattice(n_particles):\n        \"\"\"Generates particle positions on a regular square lattice.\"\"\"\n        n_side = int(np.sqrt(n_particles))\n        if n_side**2 != n_particles:\n            raise ValueError(\"N must be a perfect square for lattice arrangement\")\n        \n        points = np.zeros((n_particles, 2))\n        dx = 1.0 / n_side\n        \n        idx = 0\n        for i in range(n_side):\n            for j in range(n_side):\n                points[idx, 0] = (i + 0.5) * dx\n                points[idx, 1] = (j + 0.5) * dx\n                idx += 1\n        return points\n\n    def generate_glass(n_particles):\n        \"\"\"Generates particle positions from a Halton sequence.\"\"\"\n        points = np.zeros((n_particles, 2))\n        for k in range(1, n_particles + 1):\n            points[k-1, 0] = radical_inverse(k, 2)\n            points[k-1, 1] = radical_inverse(k, 3)\n        return points\n\n    def W_cubic_spline_vectorized(r, h):\n        \"\"\"Vectorized 2D cubic spline SPH kernel.\"\"\"\n        alpha_d = 10.0 / (7.0 * np.pi * h**2)\n        q = r / h\n        \n        res = np.zeros_like(q)\n        \n        # Condition: 1  q = 2\n        mask1 = (q > 1.0)  (q = 2.0)\n        q1 = q[mask1]\n        res[mask1] = alpha_d * 0.25 * (2.0 - q1)**3\n        \n        # Condition: 0 = q = 1\n        mask2 = q = 1.0\n        q2 = q[mask2]\n        res[mask2] = alpha_d * (1.0 - 1.5 * q2**2 + 0.75 * q2**3)\n        \n        return res\n\n    def compute_errors(n_particles, arrangement_type):\n        \"\"\"\n        Computes the SPH density and error metrics for a given configuration.\n        \"\"\"\n        # 1. Set parameters\n        m = 1.0 / n_particles\n        delta = 1.0 / np.sqrt(n_particles)\n        h = ETA * delta\n\n        # 2. Generate particle positions\n        if arrangement_type == 'lattice':\n            positions = generate_lattice(n_particles)\n        elif arrangement_type == 'glass':\n            positions = generate_glass(n_particles)\n        else:\n            raise ValueError(f\"Unknown arrangement type: {arrangement_type}\")\n            \n        # 3. Compute pairwise periodic distances (vectorized)\n        delta_r = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        delta_r -= np.round(delta_r)  # Minimum image convention for unit domain\n        distances = np.linalg.norm(delta_r, axis=2)\n\n        # 4. Evaluate kernel for all pairs\n        kernel_values = W_cubic_spline_vectorized(distances, h)\n\n        # 5. Sum contributions to get densities\n        densities = m * np.sum(kernel_values, axis=1)\n\n        # 6. Compute error metrics\n        relative_errors = (densities - RHO_0) / RHO_0\n        \n        e1 = np.mean(np.abs(relative_errors))\n        e2 = np.sqrt(np.mean(relative_errors**2))\n        e_inf = np.max(np.abs(relative_errors))\n        \n        return [round(e1, 6), round(e2, 6), round(e_inf, 6)]\n\n    # --- Main execution loop ---\n    \n    all_results = []\n    for n, arr_type in test_cases:\n        errors = compute_errors(n, arr_type)\n        all_results.append(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了精确表示静态场，一个用于物理学的数值方法还必须遵守基本的守恒定律，对于一个封闭系统，总角动量应该守恒。这个高级练习涉及模拟一个动态系统，以验证所选的SPH力离散化格式是否能正确地保持角动量守恒。本练习强调了力的数学公式与模拟的物理保真度之间的关键联系，这是构建可靠计算模型的基石。",
            "id": "2439484",
            "problem": "您需要编写一个完整、可运行的程序，在无量纲单位下使用光滑粒子流体动力学（SPH）方法对二维自引力气体云进行数值演化，并分析总角动量的守恒情况。在无量纲单位下进行计算，引力常数 $G=1$。考虑一个正压气体，其压强由 $P(\\rho) = c_s^2 \\rho$ 给出，其中 $c_s$ 是一个恒定的声速。通过带有软化长度 $\\epsilon$ 的牛顿成对引力来处理自引力。\n\n设平面上有 $N$ 个粒子，它们的质量相等，为 $m_i = M/N$，总质量 $M=1$，位置为 $\\vec{r}_i(t) \\in \\mathbb{R}^2$，速度为 $\\vec{v}_i(t) \\in \\mathbb{R}^2$。系统关于原点的总角动量为\n$$\n\\vec{L}(t) = \\sum_{i=1}^{N} m_i \\, \\vec{r}_i(t) \\times \\vec{v}_i(t),\n$$\n其中叉积是标准的三维叉积；在二维情况下，其大小对应于平面外分量。根据所述的状态方程和自引力，在欧拉动量方程下演化该系统。假设没有外力和物理粘性。在 $t=0$ 时，按照下面每个测试用例的描述来初始化粒子。\n\n您的任务是，对每个测试用例，将运动方程从 $t=0$ 数值积分到 $t=T$，在包括初始时刻和所有后续时间步的离散时间点上追踪角动量大小 $|\\vec{L}(t)|$，并为每个用例计算以下诊断量：\n- 如果 $|\\vec{L}(0)|  0$，报告\n$$\n\\max_{0 \\le t \\le T} \\frac{\\left|\\,|\\vec{L}(t)| - |\\vec{L}(0)|\\,\\right|}{|\\vec{L}(0)|}.\n$$\n- 如果 $|\\vec{L}(0)| = 0$，报告\n$$\n\\max_{0 \\le t \\le T} |\\vec{L}(t)|.\n$$\n\n使用以下测试套件。在所有情况下，将粒子均匀放置在以原点为中心、半径为 $R$ 的圆上，其极角为 $\\theta_k = 2\\pi k/N$（其中 $k \\in \\{0,1,\\dots,N-1\\}$），位置为 $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$。将初始速度设置为围绕原点的刚体转动，角速度为 $\\Omega$，即 $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$。\n\n测试套件（每个元组列出 $(N, R, \\Omega, c_s, h, \\epsilon, T, \\Delta t)$）：\n1. $(N=32, R=1.0, \\Omega=0.5, c_s=0.05, h=0.2, \\epsilon=0.02, T=2.0, \\Delta t=0.002)$\n2. $(N=1, R=1.0, \\Omega=1.0, c_s=0.0, h=0.1, \\epsilon=0.0, T=1.0, \\Delta t=0.005)$\n3. $(N=32, R=1.0, \\Omega=0.0, c_s=0.05, h=0.2, \\epsilon=0.02, T=1.0, \\Delta t=0.002)$\n\n对于每个测试用例，使用SPH来模拟压力，并使用成对软化的牛顿引力来模拟自引力。您必须使用球对称、紧支集的光滑核函数（光滑长度为 $h$），通过标准的SPH密度求和计算密度，并使用动量守恒的对称形式计算压力。引力软化的实现方式必须使粒子 $i$ 和 $j$ 之间的成对引力与 $(\\vec{r}_i - \\vec{r}_j)/\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}$ 成正比。\n\n您的程序必须生成单行输出，其中包含三个测试用例的三个诊断值，按顺序排列，形式为用方括号括起来的逗号分隔列表。例如，输出格式必须与此完全一样：\n[diagnostic_case1,diagnostic_case2,diagnostic_case3]\n所有量均为无量纲；输出中不要包含任何单位。",
            "solution": "我们需要在没有外力矩的情况下演化一个二维自引力正压气体，并分析角动量守恒。支配角动量的基本物理原理是，对于一个只受有心的、成对反对称的内力作用的封闭系统，其总力矩为零，从而导致总角动量守恒。对于一个粒子系统，其总角动量的时间导数的连续形式是\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\vec{a}_i.\n$$\n如果力是成对内力之和 $m_i \\vec{a}_i = \\sum_{j\\ne i} \\vec{F}_{ij}$，且满足 $\\vec{F}_{ij} = -\\vec{F}_{ji}$，并且每个 $\\vec{F}_{ij}$ 都平行于 $(\\vec{r}_i - \\vec{r}_j)$，那么总力矩\n$$\n\\sum_{i=1}^{N} \\vec{r}_i \\times \\sum_{j\\ne i} \\vec{F}_{ij} = \\frac{1}{2} \\sum_{i\\ne j} (\\vec{r}_i - \\vec{r}_j) \\times \\vec{F}_{ij} = \\vec{0},\n$$\n因为对于有心力，$(\\vec{r}_i - \\vec{r}_j)$ 平行于 $\\vec{F}_{ij}$，它们的叉积为零。因此，在没有外力矩和非有心力的情况下，$\\vec{L}(t)$ 在连续系统中是精确守恒的。\n\n光滑粒子流体动力学（SPH）将压力表示为成对相互作用之和，在对称的、动量守恒的离散化形式中，这些相互作用是反对称和有心的。粒子 $i$ 处的密度通过求和估算\n$$\n\\rho_i = \\sum_{j=1}^{N} m_j W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\n其中 $W$ 是一个具有紧支集和光滑长度 $h$ 的球对称核函数。正压气体的压强为 $P_i = c_s^2 \\rho_i$。一种能够保证线动量和角动量守恒的对称SPH压力加速度表示形式是\n$$\n\\vec{a}_i^{\\mathrm{(P)}} = - \\sum_{j=1}^{N} m_j \\left( \\frac{P_i}{\\rho_i^2} + \\frac{P_j}{\\rho_j^2} \\right) \\nabla W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\n其中，由于 $W$ 的球对称性，$\\nabla W$ 平行于 $(\\vec{r}_i - \\vec{r}_j)$，从而确保每对相互作用的贡献都是有心且反对称的。自引力通过带有软化长度 $\\epsilon$ 的牛顿引力来建模：\n$$\n\\vec{a}_i^{\\mathrm{(G)}} = - G \\sum_{j\\ne i} m_j \\frac{\\vec{r}_i - \\vec{r}_j}{\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}}.\n$$\n这也是成对有心力之和。因此，在精确计算中，总角动量是守恒的：\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\left( \\vec{a}_i^{\\mathrm{(P)}} + \\vec{a}_i^{\\mathrm{(G)}} \\right) = \\vec{0}.\n$$\n\n在数值模拟中，离散化和时间积分误差会引入微小的偏差。为了最小化类哈密顿系统中的长期漂移并保持不变量，可以使用一种辛二阶积分器，例如速度Verlet算法。给定在时间 $t_n$ 的位置 $\\vec{r}_i^n$、速度 $\\vec{v}_i^n$ 和加速度 $\\vec{a}_i^n$，速度Verlet算法按以下方式推进\n$$\n\\vec{r}_i^{n+1} = \\vec{r}_i^{n} + \\vec{v}_i^{n} \\Delta t + \\frac{1}{2} \\vec{a}_i^{n} \\Delta t^2,\n$$\n$$\n\\vec{a}_i^{n+1} = \\vec{a}_i\\big(\\{\\vec{r}_j^{n+1}\\}\\big),\n$$\n$$\n\\vec{v}_i^{n+1} = \\vec{v}_i^{n} + \\frac{1}{2}\\left(\\vec{a}_i^{n} + \\vec{a}_i^{n+1}\\right) \\Delta t,\n$$\n其中 $\\vec{a}_i(\\{\\vec{r}_j\\})$ 是根据当前位置的SPH压力和引力相互作用计算得出的。在每个离散时间点，角动量的大小为\n$$\n|\\vec{L}(t_n)| = \\left| \\sum_{i=1}^{N} m_i \\, \\vec{r}_i^n \\times \\vec{v}_i^n \\right|.\n$$\n\n程序算法设计：\n1. 对于每个测试用例，在半径为 $R$ 的圆上初始化 $N$ 个粒子，它们的质量相等，为 $m_i = 1/N$，角度为 $\\theta_k = 2\\pi k/N$，位置为 $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$。设置速度为 $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$，这对应于角速度为 $\\Omega$ 的刚体转动。\n2. 在每个时间步，使用球对称的紧支集核函数通过SPH求和计算密度。然后计算压强 $P_i = c_s^2 \\rho_i$ 和通过对称SPH力表达式计算压力加速度。使用软化的牛顿公式（$G=1$ 和给定的 $\\epsilon$）计算引力加速度。\n3. 使用速度Verlet方案，以时间步长 $\\Delta t$ 在时间 $T$ 内推进位置和速度。\n4. 从 $t=0$ 开始追踪所有时间步的 $|\\vec{L}(t)|$。对于 $|\\vec{L}(0)|  0$ 的情况，计算最大相对偏差 $\\max_t \\big||\\vec{L}(t)| - |\\vec{L}(0)|\\big|/|\\vec{L}(0)|$。对于 $|\\vec{L}(0)| = 0$ 的情况，计算 $\\max_t |\\vec{L}(t)|$。\n5. 将三个诊断值按测试用例的顺序列在单行中，作为用方括号括起来的逗号分隔列表输出。\n\n预期的定性结果：\n- 对于旋转的自引力云（$N=32$, $R=1.0$, $\\Omega=0.5$），内部的SPH压力和引力是有心的且成对对称的，因此总角动量应在小的积分和离散化误差范围内守恒；因此最大相对偏差应该很小。\n- 对于单个自由粒子（$N=1$）且 $\\Omega=1.0$ 的情况，没有内力，因此 $\\vec{a}=\\vec{0}$ 且 $\\vec{L}(t)$ 是精确恒定的；在数值上，任何偏差都源于浮点运算，应该极小。\n- 对于不旋转的云（$\\Omega=0.0$），初始角动量大小为零；根据对称性和有心力，它应保持在零附近，因此最大值应该很小。\n\n这些计算直接源于牛顿力学、正压流体的欧拉方程，以及SPH离散化方法。该离散化方法保留了成对内力的反对称性和有心性，从而在没有外力矩的情况下保证了角动量守恒。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numpy print options (not strictly necessary, but consistent output)\nnp.set_printoptions(precision=10, floatmode='maxprec')\n\ndef cubic_spline_W_2d(r, h):\n    \"\"\"\n    2D cubic spline (M4) kernel value W(r,h).\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    W = np.zeros_like(r)\n    mask1 = (q >= 0)  (q  1)\n    mask2 = (q >= 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    W[mask1] = 1 - 1.5*q1*q1 + 0.75*q1*q1*q1\n    W[mask2] = 0.25 * (2 - q2)**3\n    return sigma * W\n\ndef cubic_spline_dW_dr_2d(r, h):\n    \"\"\"\n    Derivative dW/dr for 2D cubic spline kernel.\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    dW_dq = np.zeros_like(r)\n    mask1 = (q >= 0)  (q  1)\n    mask2 = (q >= 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    # d/dq of 1 - 1.5 q^2 + 0.75 q^3 is -3 q + 2.25 q^2\n    dW_dq[mask1] = -3.0*q1 + 2.25*q1*q1\n    # d/dq of 0.25 (2 - q)^3 is -0.75 (2 - q)^2\n    dW_dq[mask2] = -0.75 * (2 - q2)**2\n    # dW/dr = (dW/dq) * (1/h) * sigma\n    return sigma * dW_dq / h\n\ndef compute_densities(positions, masses, h):\n    \"\"\"\n    Compute SPH densities by direct summation using the 2D cubic spline kernel.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n    W = cubic_spline_W_2d(dist, h)     # (N,N)\n    rho = W @ masses  # (N,)\n    return rho\n\ndef compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0):\n    \"\"\"\n    Compute accelerations from SPH pressure forces and softened self-gravity.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    N = positions.shape[0]\n    # Density and pressure\n    rho = compute_densities(positions, masses, h)\n    P = (cs * cs) * rho\n\n    # Pairwise vectors\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n\n    # Kernel gradient\n    dW_dr = cubic_spline_dW_dr_2d(dist, h)  # (N,N)\n    # Avoid division by zero\n    inv_r = 1.0 / (dist + 1e-16)\n    gradW = (dW_dr * inv_r)[..., None] * dx  # (N,N,2)\n\n    # Symmetric pressure force factor: (P_i/rho_i^2 + P_j/rho_j^2)\n    # Build matrices via broadcasting\n    Pi_over_rhoi2 = (P / (rho * rho + 1e-30))  # (N,)\n    Pj_over_rhoj2 = Pi_over_rhoi2              # same array, but we'll broadcast\n    term_ij = Pi_over_rhoi2[:, None] + Pj_over_rhoj2[None, :]  # (N,N)\n    # Multiply by masses of j\n    mj = masses[None, :]  # (1,N)\n    facP = term_ij * mj   # (N,N)\n\n    # Pressure acceleration\n    aP = -np.sum(facP[..., None] * gradW, axis=1)  # (N,2)\n\n    # Gravity: softened Newtonian\n    soft2 = eps_soft * eps_soft\n    inv_r3 = 1.0 / (dist*dist + soft2)**1.5  # (N,N)\n    # Exclude self-interaction\n    np.fill_diagonal(inv_r3, 0.0)\n    aG = -G * np.sum((mj[..., None] * inv_r3[..., None]) * dx, axis=1)  # (N,2)\n\n    return aP + aG\n\ndef angular_momentum_z(positions, velocities, masses):\n    \"\"\"\n    Compute total angular momentum (z-component) for 2D system: Lz = sum m (x vy - y vx)\n    \"\"\"\n    x = positions[:, 0]\n    y = positions[:, 1]\n    vx = velocities[:, 0]\n    vy = velocities[:, 1]\n    Lz = np.sum(masses * (x * vy - y * vx))\n    return Lz\n\ndef simulate_case(N, R, Omega, cs, h, eps_soft, T, dt):\n    \"\"\"\n    Simulate one test case and return the diagnostic:\n    - If |L0| > 0: max_t | |L(t)| - |L0| | / |L0|\n    - If |L0| == 0: max_t |L(t)|\n    \"\"\"\n    # Initialize masses\n    M = 1.0\n    masses = np.full(N, M / N)\n    # Initialize positions on a circle\n    if N == 1:\n        thetas = np.array([0.0])\n    else:\n        thetas = 2.0 * np.pi * np.arange(N) / N\n    positions = np.column_stack([R * np.cos(thetas), R * np.sin(thetas)])\n    # Solid-body rotation velocities v = Omega * (-y, x)\n    velocities = Omega * np.column_stack([-positions[:, 1], positions[:, 0]])\n\n    # Initial acceleration\n    acc = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n\n    # Track angular momentum magnitude over time\n    L0 = angular_momentum_z(positions, velocities, masses)\n    L_mags = [abs(L0)]\n\n    steps = int(np.round(T / dt))\n    # Velocity Verlet integration\n    for _ in range(steps):\n        # r_{n+1} = r_n + v_n dt + 0.5 a_n dt^2\n        positions = positions + velocities * dt + 0.5 * acc * (dt * dt)\n        # a_{n+1}\n        acc_new = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n        # v_{n+1} = v_n + 0.5 (a_n + a_{n+1}) dt\n        velocities = velocities + 0.5 * (acc + acc_new) * dt\n        # Prepare for next step\n        acc = acc_new\n        # Record angular momentum magnitude\n        L_mags.append(abs(angular_momentum_z(positions, velocities, masses)))\n\n    L0_abs = abs(L0)\n    if L0_abs > 1e-14:\n        deviations = np.abs(np.array(L_mags) - L0_abs) / L0_abs\n        diagnostic = float(np.max(deviations))\n    else:\n        diagnostic = float(np.max(L_mags))\n    return diagnostic\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, Omega, cs, h, eps, T, dt)\n        (32, 1.0, 0.5, 0.05, 0.2, 0.02, 2.0, 0.002),\n        (1,  1.0, 1.0, 0.0,  0.1, 0.0,  1.0, 0.005),\n        (32, 1.0, 0.0, 0.05, 0.2, 0.02, 1.0, 0.002),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, Omega, cs, h, eps_soft, T, dt = case\n        result = simulate_case(N, R, Omega, cs, h, eps_soft, T, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}