{
    "hands_on_practices": [
        {
            "introduction": "The stability of explicit numerical schemes is governed by the Courant-Friedrichs-Lewy (CFL) condition, which links the time step $\\Delta t$ to the grid spacing $h$. In Adaptive Mesh Refinement, this fundamental constraint implies that finer grids require smaller time steps for stability. This exercise  guides you through deriving the CFL condition from physical principles and extending it to determine the appropriate level-dependent time steps in an AMR hierarchy that uses subcycling.",
            "id": "3730525",
            "problem": "Consider a one-dimensional linear hyperbolic system of conservation laws $u_{t} + A u_{x} = 0$, where $A \\in \\mathbb{R}^{m \\times m}$ is diagonalizable with real eigenvalues, and let the maximum magnitude of the characteristic speeds be $|\\lambda_{\\max}| = \\max_{k} |\\lambda_{k}|$. A first-order explicit finite volume discretization with a monotone numerical flux updates cell averages using information propagating at most one cell per time step on a uniform grid of spacing $h$. For stability of such explicit schemes, ensure that the discrete domain of dependence contains the continuous domain of dependence. Now consider an Adaptive Mesh Refinement (AMR) hierarchy with levels $\\ell = 0, 1, \\dots, L-1$, where level $\\ell$ has uniform cell spacing $h_{\\ell}$ and $h_{\\ell+1} = h_{\\ell}/r$ for a fixed integer refinement ratio $r \\ge 2$. Suppose subcycling-in-time is used so that level $\\ell$ advances with its own time step $\\Delta t_{\\ell}$ while maintaining a common dimensionless Courant number across all levels.\n\nTasks:\n1. Starting from the hyperbolic character of the system and the requirement that waves traveling at speed $|\\lambda_{\\max}|$ do not cross more than one cell per time step on the grid of spacing $h$, derive the stability restriction for the explicit discretization in terms of a dimensionless factor $\\mathrm{C} \\in (0,1)$, the grid spacing $h$, and the characteristic speed bound $|\\lambda_{\\max}|$. Clearly state the form of the restriction on $\\Delta t$ without invoking any pre-given formula.\n2. Using the AMR hierarchy definition and subcycling assumption, derive the per-level relation for the time steps $\\Delta t_{\\ell}$ in terms of a base coarse-level time step $\\Delta t_{0}$ and the refinement ratio $r$.\n3. For a specific three-level hierarchy with $L=3$, coarse-level spacing $h_{0} = 0.04\\,\\mathrm{m}$, refinement ratio $r = 2$, maximum characteristic speed $|\\lambda_{\\max}| = 5\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$, and common dimensionless Courant factor $\\mathrm{C} = 0.8$, compute the level-$\\ell=2$ time step $\\Delta t_{2}$ in seconds. Round your answer to four significant figures and express the time in seconds.\n\nDefinitions: Courant–Friedrichs–Lewy (CFL) condition refers to the stability constraint relating $\\Delta t$, $h$, and characteristic speeds in explicit schemes. Adaptive Mesh Refinement (AMR) refers to hierarchical grids with spatial refinement by integer ratios.",
            "solution": "The problem presents a multi-part task concerning the stability of numerical schemes for hyperbolic partial differential equations within an Adaptive Mesh Refinement (AMR) framework. The solution is structured into three sequential derivations and calculations as requested.\n\n### Part 1: Derivation of the Stability Restriction\n\nThe problem concerns a one-dimensional linear hyperbolic system of conservation laws, $u_{t} + A u_{x} = 0$, where the eigenvalues $\\lambda_k$ of the matrix $A$ represent the characteristic speeds at which information propagates through the domain. The maximum speed of propagation is denoted by $|\\lambda_{\\max}| = \\max_{k} |\\lambda_{k}|$.\n\nFor an explicit numerical scheme to be stable, the Courant–Friedrichs–Lewy (CFL) condition must be satisfied. This condition is a necessary condition for convergence and ensures that the numerical domain of dependence of a point in the discretized spacetime grid contains the physical (or continuous) domain of dependence of that same point.\n\nThe problem statement provides a direct physical interpretation of this condition: \"waves traveling at speed $|\\lambda_{\\max}|$ do not cross more than one cell per time step on the grid of spacing $h$.\" Let's formalize this. In a time interval $\\Delta t$, the maximum distance a physical wave can travel is $|\\lambda_{\\max}| \\Delta t$. For a first-order explicit scheme on a grid with uniform cell spacing $h$, the numerical solution at a cell centered at $x_i$ at time $t_{n+1} = t_n + \\Delta t$ depends on information from cells $i-1$, $i$, and $i+1$ at time $t_n$. This implies that the numerical method can only propagate information by a distance on the order of the cell size $h$ in one time step. For stability, the physical propagation distance must not exceed the distance the numerical scheme can \"see\". Thus, the distance traveled by the fastest physical wave must be less than or equal to the width of one grid cell:\n$$|\\lambda_{\\max}| \\Delta t \\le h$$\nThis inequality ensures that a characteristic line originating from any point within the numerical stencil at time $t_n$ does not exit that stencil by time $t_n + \\Delta t$.\n\nThe problem introduces a dimensionless factor $\\mathrm{C} \\in (0,1)$, which serves as a safety factor and is known as the Courant number. The stability condition is expressed by requiring that the ratio of the physical advection distance to the grid cell size be bounded by this factor:\n$$\\frac{|\\lambda_{\\max}| \\Delta t}{h} \\le \\mathrm{C}$$\nBy rearranging this inequality, we obtain the stability restriction on the time step $\\Delta t$ for a grid with spacing $h$:\n$$\\Delta t \\le \\mathrm{C} \\frac{h}{|\\lambda_{\\max}|}$$\n\n### Part 2: Derivation of the Per-Level Time Step Relation\n\nThe AMR hierarchy comprises levels $\\ell = 0, 1, \\dots, L-1$. The cell spacing $h_{\\ell}$ on level $\\ell$ is related to the spacing on the next coarser level $\\ell-1$ by a constant integer refinement ratio $r \\ge 2$, such that $h_{\\ell} = h_{\\ell-1}/r$. This leads to a general expression for the grid spacing on level $\\ell$ in terms of the base coarse-level spacing $h_0$:\n$$h_{\\ell} = \\frac{h_0}{r^{\\ell}}$$\nThe simulation employs subcycling-in-time, where each level $\\ell$ uses its own time step $\\Delta t_{\\ell}$. A critical constraint is that a common dimensionless Courant number $\\mathrm{C}$ is maintained across all levels. To maximize computational efficiency, the time step on each level is chosen to be at the stability limit derived in Part 1. For any level $\\ell$, this gives:\n$$\\Delta t_{\\ell} = \\mathrm{C} \\frac{h_{\\ell}}{|\\lambda_{\\max}|}$$\nWe aim to find a relationship between $\\Delta t_{\\ell}$ and the base coarse-level time step $\\Delta t_0$. For the coarsest level, $\\ell=0$, the time step is:\n$$\\Delta t_0 = \\mathrm{C} \\frac{h_0}{|\\lambda_{\\max}|}$$\nNow, we substitute the expression for $h_{\\ell}$ into the general formula for $\\Delta t_{\\ell}$:\n$$\\Delta t_{\\ell} = \\mathrm{C} \\frac{(h_0/r^{\\ell})}{|\\lambda_{\\max}|} = \\frac{1}{r^{\\ell}} \\left(\\mathrm{C} \\frac{h_0}{|\\lambda_{\\max}|}\\right)$$\nThe term in parentheses is precisely the expression for $\\Delta t_0$. Therefore, we arrive at the sought-after relation:\n$$\\Delta t_{\\ell} = \\frac{\\Delta t_0}{r^{\\ell}}$$\nThis result shows that in a subcycling AMR scheme with a constant Courant number, the time step on a given level is inversely proportional to $r^{\\ell}$, meaning finer levels require proportionally smaller time steps.\n\n### Part 3: Calculation of $\\Delta t_{2}$\n\nThe task is to calculate the time step $\\Delta t_2$ for a specific three-level hierarchy ($\\ell=0, 1, 2$) with the following given parameters:\n- Coarse-level spacing: $h_0 = 0.04\\,\\mathrm{m}$\n- Refinement ratio: $r = 2$\n- Maximum characteristic speed: $|\\lambda_{\\max}| = 5\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$\n- Common Courant factor: $\\mathrm{C} = 0.8$\n\nFirst, we must determine the grid spacing on the finest level, $\\ell=2$. Using the formula for $h_{\\ell}$:\n$$h_2 = \\frac{h_0}{r^2}$$\nSubstituting the numerical values:\n$$h_2 = \\frac{0.04\\,\\mathrm{m}}{2^2} = \\frac{0.04\\,\\mathrm{m}}{4} = 0.01\\,\\mathrm{m}$$\nNext, we use the formula for the per-level time step at the stability limit for $\\ell=2$:\n$$\\Delta t_2 = \\mathrm{C} \\frac{h_2}{|\\lambda_{\\max}|}$$\nPlugging in the given values and the calculated $h_2$:\n$$\\Delta t_2 = 0.8 \\times \\frac{0.01\\,\\mathrm{m}}{5\\,\\mathrm{m}\\,\\mathrm{s}^{-1}} = 0.8 \\times (0.002\\,\\mathrm{s})$$\n$$\\Delta t_2 = 0.0016\\,\\mathrm{s}$$\nThe problem requires the answer to be expressed in seconds and rounded to four significant figures. The value $0.0016$ can be written with four significant figures as $0.001600$. In standard scientific notation, this is $1.600 \\times 10^{-3}$.",
            "answer": "$$\\boxed{1.600 \\times 10^{-3}}$$"
        },
        {
            "introduction": "A cornerstone of high-quality AMR simulations is the strict conservation of physical quantities like mass and energy across the interfaces between coarse and fine grids. This is achieved through a procedure known as flux correction, or refluxing, which adjusts the coarse grid solution to account for the more accurate fluxes computed on the fine grid. This practice  provides a concrete, step-by-step calculation of the refluxing algorithm, demystifying how conservation is maintained at coarse-fine boundaries.",
            "id": "4006196",
            "problem": "Consider a one-dimensional advection–diffusion substep for a single species mass fraction $Y$ in a reacting flow, formulated within the Adaptive Mesh Refinement (AMR) framework, where reaction is handled by operator splitting and is inactive during this substep (i.e., the reaction source is zero). The governing conservation law for the species during this substep is\n$$\n\\frac{\\partial (\\rho Y)}{\\partial t} + \\frac{\\partial F}{\\partial x} = 0,\n$$\nwith the total species flux\n$$\nF = \\rho u Y - \\rho D \\frac{\\partial Y}{\\partial x},\n$$\nwhere $\\rho$ is the mass density, $u$ is the advection velocity, and $D$ is the molecular diffusivity. Assume a constant density $\\rho$ and a uniform cross-sectional area of $1$ so that cell volumes are lengths.\n\nA coarse grid consists of two coarse cells $C0$ and $C1$ covering $x \\in [0, 2\\Delta x_c]$ with coarse cell width $\\Delta x_c$. A fine grid with refinement ratio $r = 2$ covers the entire spatial extent of coarse cell $C1$, consisting of two fine cells $F1$ and $F2$ of width $\\Delta x_f = \\Delta x_c/2$. The interface between $C0$ and the fine grid is at $x = \\Delta x_c$. The face at $x = \\Delta x_c$ is shared between coarse cell $C0$ and fine cell $F1$. The left boundary at $x = 0$ is an inflow with a fixed Dirichlet mass fraction.\n\nThe parameters and initial data are:\n- Density $\\rho = 1.0 \\ \\mathrm{kg/m^3}$,\n- Advection velocity $u = 0.8 \\ \\mathrm{m/s}$ (positive $x$ direction),\n- Diffusivity $D = 1.0 \\times 10^{-4} \\ \\mathrm{m^2/s}$,\n- Coarse width $\\Delta x_c = 2.0 \\times 10^{-3} \\ \\mathrm{m}$,\n- Fine width $\\Delta x_f = 1.0 \\times 10^{-3} \\ \\mathrm{m}$,\n- Time step $\\Delta t = 5.0 \\times 10^{-4} \\ \\mathrm{s}$,\n- Inflow mass fraction at $x=0$: $Y_{\\text{in}} = 0.20$,\n- Initial mass fractions: $Y_{C0}^n = 0.06$, $Y_{F1}^n = 0.12$, $Y_{F2}^n = 0.08$.\n\nOn the coarse level, the covered coarse neighbor $C1$ is defined by conservative restriction of the fine data, so its coarse mass fraction is the average $Y_{C1}^n = (Y_{F1}^n + Y_{F2}^n)/2$.\n\nUse the following physically standard discretization principles derived from the conservation law and constitutive flux:\n- Upwind selection for the advective face state $Y$ based on the sign of $u$,\n- Centered difference for the diffusive flux using the distance between adjacent cell centers; for a face between two cells of widths $\\Delta x_L$ and $\\Delta x_R$, the center-to-center distance is $\\Delta x_L/2 + \\Delta x_R/2$.\n\nTasks:\n1. Compute the coarse-level advective–diffusive flux at the right face of $C0$ (located at $x = \\Delta x_c$) using $Y_{C0}^n$ and the coarse neighbor $Y_{C1}^n$, with center-to-center distance $\\Delta x_c$. Also compute the face flux at the left boundary of $C0$ (located at $x=0$) using $Y_{\\text{in}}$ and $Y_{C0}^n$, with center-to-center distance $\\Delta x_c/2$.\n2. Update $Y_{C0}$ over the time step $\\Delta t$ using the coarse-level fluxes at the left and right faces via the finite-volume update implied by the conservation law.\n3. Compute the fine-level flux at the interface face $x = \\Delta x_c$ between $C0$ and $F1$ using the upwind state from $C0$ and the fine state from $F1$, and the center-to-center distance $\\Delta x_c/2 + \\Delta x_f/2$.\n4. Populate a flux register with the fine-level interface flux and apply the reflux correction to the coarse cell $C0$ so that its final updated state is consistent with the fine-level interface flux through $x = \\Delta x_c$.\n5. From the corrected $Y_{C0}^{n+1}$, compute the final species mass in $C0$ per unit cross-sectional area, defined as $m_{C0}^{n+1} = \\rho \\, Y_{C0}^{n+1} \\, \\Delta x_c$, and express it in $\\mathrm{kg/m^2}$.\n\nRound your final answer to four significant figures and express the final mass in $\\mathrm{kg/m^2}$.",
            "solution": "The finite volume discretization of the governing equation for a generic cell $i$ with constant density $\\rho$ and volume $\\Delta x_i$ (per unit area) is:\n$$ Y_i^{n+1} = Y_i^n - \\frac{\\Delta t}{\\rho \\Delta x_i} (F_{i+1/2} - F_{i-1/2}) $$\nThe flux $F$ at a face between a left cell $L$ and a right cell $R$ is discretized as the sum of an advective flux and a diffusive flux. Given $u > 0$, the advective part uses the state from the left cell, $Y_L$. The diffusive flux is a centered difference.\n$$ F_{face} = (\\rho u Y_L) - (\\rho D) \\frac{Y_R - Y_L}{d_{centers}} $$\nwhere $d_{centers}$ is the distance between the cell centers.\n\nFirst, we determine the state of the coarse neighbor $C1$. It is the volume-weighted average (restriction) of the fine cells covering it.\n$$ Y_{C1}^n = \\frac{Y_{F1}^n \\Delta x_f + Y_{F2}^n \\Delta x_f}{\\Delta x_c} = \\frac{Y_{F1}^n + Y_{F2}^n}{r} $$\nWith $r=2$, this is a simple average:\n$$ Y_{C1}^n = \\frac{0.12 + 0.08}{2} = 0.10 $$\n\n**Task 1: Compute Coarse-Level Fluxes for $C0$**\n\nThe cell $C0$ has a left face at $x=0$ and a right face at $x=\\Delta x_c$.\n\n- **Flux at the left face of $C0$ ($F_{C0,left}$ at $x=0$):**\nThe left \"cell\" is the boundary condition $Y_{\\text{in}}$, and the right cell is $C0$. The center-to-center distance is given as $d_{centers} = \\Delta x_c / 2$.\nAdvection uses the upstream state $Y_{\\text{in}}$.\n$$ F_{C0,left} = \\rho u Y_{\\text{in}} - \\rho D \\frac{Y_{C0}^n - Y_{\\text{in}}}{\\Delta x_c / 2} $$\n$$ F_{C0,left} = (1.0)(0.8)(0.20) - (1.0)(1.0 \\times 10^{-4}) \\frac{0.06 - 0.20}{2.0 \\times 10^{-3} / 2} $$\n$$ F_{C0,left} = 0.16 - (1.0 \\times 10^{-4}) \\frac{-0.14}{1.0 \\times 10^{-3}} = 0.16 - (1.0 \\times 10^{-4})(-140) = 0.16 + 0.014 = 0.174 $$\n\n- **Flux at the right face of $C0$ ($F_{C0,right}^c$ at $x=\\Delta x_c$), coarse-level:**\nThe left cell is $C0$, and the right cell is $C1$. The center-to-center distance is given as $d_{centers} = \\Delta x_c$.\nAdvection uses the left state $Y_{C0}^n$.\n$$ F_{C0,right}^c = \\rho u Y_{C0}^n - \\rho D \\frac{Y_{C1}^n - Y_{C0}^n}{\\Delta x_c} $$\n$$ F_{C0,right}^c = (1.0)(0.8)(0.06) - (1.0)(1.0 \\times 10^{-4}) \\frac{0.10 - 0.06}{2.0 \\times 10^{-3}} $$\n$$ F_{C0,right}^c = 0.048 - (1.0 \\times 10^{-4}) \\frac{0.04}{2.0 \\times 10^{-3}} = 0.048 - (1.0 \\times 10^{-4})(20) = 0.048 - 0.002 = 0.046 $$\n\n**Task 2: Update $Y_{C0}$ using coarse fluxes**\n\nThis is a provisional update for $C0$ using only coarse-level information.\n$$ Y_{C0}^{n+1, \\text{coarse}} = Y_{C0}^n - \\frac{\\Delta t}{\\rho \\Delta x_c} (F_{C0,right}^c - F_{C0,left}) $$\n$$ Y_{C0}^{n+1, \\text{coarse}} = 0.06 - \\frac{5.0 \\times 10^{-4}}{(1.0)(2.0 \\times 10^{-3})} (0.046 - 0.174) $$\n$$ Y_{C0}^{n+1, \\text{coarse}} = 0.06 - (0.25) (-0.128) = 0.06 + 0.032 = 0.092 $$\n\n**Task 3: Compute Fine-Level Interface Flux**\n\nThis is the more accurate flux at the coarse-fine interface $x=\\Delta x_c$. The left cell is $C0$ and the right cell is the fine cell $F1$. The center-to-center distance is $d_{centers} = \\Delta x_c/2 + \\Delta x_f/2$.\n$$ d_{centers} = \\frac{2.0 \\times 10^{-3}}{2} + \\frac{1.0 \\times 10^{-3}}{2} = 1.0 \\times 10^{-3} + 0.5 \\times 10^{-3} = 1.5 \\times 10^{-3} \\ \\mathrm{m} $$\nThe fine-level flux $F_{C0,right}^f$ is:\n$$ F_{C0,right}^f = \\rho u Y_{C0}^n - \\rho D \\frac{Y_{F1}^n - Y_{C0}^n}{\\Delta x_c/2 + \\Delta x_f/2} $$\n$$ F_{C0,right}^f = (1.0)(0.8)(0.06) - (1.0)(1.0 \\times 10^{-4}) \\frac{0.12 - 0.06}{1.5 \\times 10^{-3}} $$\n$$ F_{C0,right}^f = 0.048 - (1.0 \\times 10^{-4}) \\frac{0.06}{1.5 \\times 10^{-3}} = 0.048 - (1.0 \\times 10^{-4})(40) = 0.048 - 0.004 = 0.044 $$\n\n**Task 4: Apply Reflux Correction**\n\nThe flux refluxing procedure corrects the coarse cell state to ensure conservation at the coarse-fine interface. The update to $Y_{C0}^{n+1, \\text{coarse}}$ is based on the difference between the coarse-level flux and the fine-level flux at the interface.\nThe change in species mass in $C0$ due to the flux discrepancy is $\\Delta m = (F_{C0,right}^c - F_{C0,right}^f) \\Delta t A$. Since area $A=1$, the correction to the state variable $Y_{C0}$ is:\n$$ \\Delta Y_{C0}^{\\text{reflux}} = \\frac{(F_{C0,right}^c - F_{C0,right}^f) \\Delta t}{\\rho \\Delta x_c} $$\n$$ \\Delta Y_{C0}^{\\text{reflux}} = \\frac{(0.046 - 0.044) (5.0 \\times 10^{-4})}{(1.0) (2.0 \\times 10^{-3})} = \\frac{(0.002) (5.0 \\times 10^{-4})}{2.0 \\times 10^{-3}} = \\frac{1.0 \\times 10^{-6}}{2.0 \\times 10^{-3}} = 0.0005 $$\nThe final, corrected state for $C0$ is:\n$$ Y_{C0}^{n+1} = Y_{C0}^{n+1, \\text{coarse}} + \\Delta Y_{C0}^{\\text{reflux}} $$\n$$ Y_{C0}^{n+1} = 0.092 + 0.0005 = 0.0925 $$\n\n**Task 5: Compute Final Species Mass in $C0$**\n\nThe final species mass in cell $C0$ per unit cross-sectional area is:\n$$ m_{C0}^{n+1} = \\rho \\, Y_{C0}^{n+1} \\, \\Delta x_c $$\n$$ m_{C0}^{n+1} = (1.0 \\ \\mathrm{kg/m^3}) \\times (0.0925) \\times (2.0 \\times 10^{-3} \\ \\mathrm{m}) $$\n$$ m_{C0}^{n+1} = 0.185 \\times 10^{-3} \\ \\mathrm{kg/m^2} = 1.85 \\times 10^{-4} \\ \\mathrm{kg/m^2} $$\nThe problem requires the answer to be rounded to four significant figures.\n$$ m_{C0}^{n+1} = 1.850 \\times 10^{-4} \\ \\mathrm{kg/m^2} $$",
            "answer": "$$\\boxed{1.850 \\times 10^{-4}}$$"
        },
        {
            "introduction": "Beyond physical laws, a robust AMR framework must satisfy a purely mathematical constraint known as the Geometric Conservation Law (GCL). The GCL ensures that the operations of refining and coarsening the mesh do not, by themselves, create spurious sources or sinks of a conserved quantity. This hands-on practice  involves building an algorithmic test to verify that a series of mesh changes correctly preserves a uniform state, a direct and powerful method for diagnosing GCL violations in a code.",
            "id": "3730527",
            "problem": "Consider a one-dimensional conservative scalar field with cell averages defined over a partition of the unit interval $[0,1]$. Let the initial state be spatially uniform with value $u(x) \\equiv U_0$. Adaptive Mesh Refinement (AMR) is applied through successive refine and coarsen operations without advancing physical time or introducing any source terms. The operational requirement is that a uniform state remains uniform under mesh adaptation if and only if the discrete Geometric Conservation Law (GCL) holds. Geometric Conservation Law (GCL) is defined as the condition that the remapping of a constant field across changing mesh geometry preserves constants exactly via volume-consistent overlap integrals. The task is to construct a test that algorithmically verifies the uniform-state invariance through multiple refine/coarsen cycles and to compute diagnostics that quantify any violation of GCL.\n\nFundamental base:\n- Conservation of cell averages: for a partition of $[0,1]$ into cells $C_i = [x_{i-1/2},x_{i+1/2}]$ with lengths $\\Delta x_i = x_{i+1/2} - x_{i-1/2}$ and piecewise constant cell values $u_i$, the integral of the scalar field over $[0,1]$ is $\\sum_i u_i \\Delta x_i$.\n- Conservative remap between an old mesh $\\{C_i\\}$ and a new mesh $\\{C'_j\\}$ uses overlap integrals: for each new cell $C'_j$ with length $\\Delta x'_j$, one defines its cell average $u'_j$ by the conservation requirement\n$$\nu'_j \\Delta x'_j \\;=\\; \\sum_i u_i \\, |C_i \\cap C'_j| \\,,\n$$\nwhere $|C_i \\cap C'_j|$ denotes the length of the intersection of $C_i$ and $C'_j$. This ensures global conservation $\\sum_j u'_j \\Delta x'_j = \\sum_i u_i \\Delta x_i$.\n- Uniform-state invariance under mesh changes is equivalent to the discrete GCL condition that for $u_i \\equiv U_0$, the remap yields $u'_j \\equiv U_0$ for all $j$; equivalently,\n$$\n\\Delta x'_j = \\sum_i |C_i \\cap C'_j| \\quad \\text{for all } j \\,,\n$$\nso that the geometric overlaps exactly reconstruct new cell measures. Any deviation from this identity is a GCL violation due to geometric inconsistency or numerical error.\n\nImplement the following algorithmic test:\n- Domain: $[0,1]$, initial mesh consisting of $N$ uniform cells, i.e., $x_{k} = k/N$ for $k=0,1,\\dots,N$.\n- Initial state: $u_i \\equiv U_0$ for all cells $i$.\n- Refine predicate: for cycle index $t \\in \\{0,1,\\dots,C-1\\}$, a coarse cell $C_i = [x_{i-1/2},x_{i+1/2}]$ with center $x_i = (x_{i-1/2}+x_{i+1/2})/2$ is marked for refinement if\n$$\n\\left\\lfloor \\alpha \\, x_i + t \\right\\rfloor \\bmod m \\;=\\; 0 \\,,\n$$\nwhere $\\lfloor \\cdot \\rfloor$ is the floor function and $\\bmod$ is the remainder modulo $m$ for positive integers $m$.\n- Refine operation: marked cells are split into two children by bisecting at their midpoint; unmarked cells remain unchanged. The refined mesh is the union of all unrefined original cells plus the children of refined cells.\n- Conservative remap to refined mesh: use overlap integrals to compute $u'_j$ for the refined mesh cells from the original coarse mesh cell values $u_i$.\n- Coarsen operation: remap back to the original $N$-cell uniform coarse mesh using overlap integrals from the refined mesh values. This completes one refine/coarsen cycle and returns the mesh to its original configuration without time advancement.\n- Repeat refine/coarsen cycles for $C$ iterations, each with the cycle-dependent predicate.\n\nDiagnostics to compute:\n- Uniform-invariance deviation after the final cycle:\n$$\nE_{\\infty} \\;=\\; \\max_j \\left|u^{(C)}_j - U_0\\right| \\,,\n$$\nwhere $u^{(C)}_j$ are the coarse-mesh values after $C$ cycles.\n- Mass-conservation error after the final cycle:\n$$\nE_{\\text{mass}} \\;=\\; \\left| \\sum_j u^{(C)}_j \\Delta x_j - U_0 \\cdot 1 \\right| \\,,\n$$\nwith $\\Delta x_j = 1/N$ for all coarse cells and domain length equal to $1$.\n- Discrete-GCL residual during refinement, computed per cycle on the refined mesh:\n$$\nr^{(t)}_k \\;=\\; \\Delta x^{\\prime (t)}_k - \\sum_i |C_i \\cap C^{\\prime (t)}_k| \\,,\n$$\nand report the maximum absolute residual across all refined cells and cycles:\n$$\nE_{\\text{GCL}} \\;=\\; \\max_{t,k} \\left| r^{(t)}_k \\right| \\,.\n$$\nEach of these diagnostics is a nonnegative real number; exact zero indicates perfect invariance or conservation.\n\nImplement the program to compute these diagnostics for the following test suite of parameter sets $(N,C,U_0,\\alpha,m)$:\n- Test case A (general case): $(N,C,U_0,\\alpha,m) = (16,8,1.0,10,2)$.\n- Test case B (boundary case with single cell and many cycles): $(N,C,U_0,\\alpha,m) = (1,16,\\pi,1000,3)$, where $\\pi$ denotes the circle constant.\n- Test case C (small-magnitude uniform state): $(N,C,U_0,\\alpha,m) = (32,10,10^{-12},7,5)$.\n- Test case D (large-magnitude uniform state): $(N,C,U_0,\\alpha,m) = (8,12,10^{6},13,4)$.\n\nYour program must:\n- Construct the initial uniform coarse mesh for each test case.\n- Execute $C$ refine/coarsen cycles, with conservative remaps via overlap integrals in both directions.\n- Accumulate the maximum discrete-GCL residual $E_{\\text{GCL}}$ across all cycles and refined cells.\n- Compute $E_{\\infty}$ and $E_{\\text{mass}}$ on the coarse mesh after the final cycle.",
            "solution": "The problem requires the implementation of an algorithmic test to verify the uniform-state-invariance property of an adaptive mesh refinement (AMR) scheme. This property is guaranteed if and only if the discrete Geometric Conservation Law (GCL) holds. The solution involves simulating a series of mesh refinement and coarsening operations on a uniform scalar field and measuring the resulting deviations from uniformity, mass conservation, and the GCL itself.\n\nThe core of the implementation is a set of functions that manage mesh data structures and perform conservative remapping between different meshes. A one-dimensional mesh is represented by a `NumPy` array of shape $(N, 2)$, where $N$ is the number of cells, and each row contains the start and end coordinates of a cell, $[x_{i-1/2}, x_{i+1/2}]$. The cell-averaged scalar values are stored in a corresponding one-dimensional `NumPy` array of length $N$.\n\nThe central operation is the conservative remap, which projects data from an old mesh, $\\{C_i\\}$, to a new mesh, $\\{C'_j\\}$. This is implemented in a general-purpose function. For each new cell $C'_j$, the new cell-averaged value $u'_j$ is computed according to the provided overlap integral formula:\n$$\nu'_j = \\frac{1}{\\Delta x'_j} \\sum_i u_i \\, |C_i \\cap C'_j|\n$$\nwhere $\\Delta x'_j$ is the length of the new cell $C'_j$, $u_i$ is the value in the old cell $C_i$, and $|C_i \\cap C'_j|$ is the length of the intersection of the two cells. The intersection of two intervals $[a, b]$ and $[c, d]$ is calculated as $\\max(0, \\min(b, d) - \\max(a, c))$. This formula ensures that the total integrated quantity (mass) is conserved during the remapping process, i.e., $\\sum_j u'_j \\Delta x'_j = \\sum_i u_i \\Delta x_i$.\n\nThe GCL states that the geometry of the mesh must be conserved during remapping, meaning the sum of overlap lengths with the old mesh must equal the new cell's length:\n$$\n\\Delta x'_j = \\sum_i |C_i \\cap C'_j|\n$$\nThe problem requires computing the discrete GCL residual, $r^{(t)}_k$, during the refinement step of each cycle $t$. This is calculated for each cell $C^{\\prime (t)}_k$ in the refined mesh as:\n$$\nr^{(t)}_k = \\Delta x^{\\prime (t)}_k - \\sum_i |C_i \\cap C^{\\prime (t)}_k|\n$$\nThe final GCL error, $E_{\\text{GCL}}$, is the maximum absolute residual observed across all cycles and all refined cells. Since all cell boundaries in this problem are dyadic rationals (resulting from bisections of an initial uniform grid), these geometric calculations should be exact in binary floating-point arithmetic. Therefore, any non-zero $E_{\\text{GCL}}$ will be on the order of machine precision, resulting from floating-point round-off error accumulation.\n\nThe main algorithm proceeds by iterating through $C$ cycles for each test case $(N, C, U_0, \\alpha, m)$. In each cycle $t \\in \\{0, 1, \\dots, C-1\\}$:\n1.  The initial uniform coarse mesh of $N$ cells is evaluated. Cells are marked for refinement based on their center coordinate $x_i$ and the cycle-dependent predicate: $\\lfloor \\alpha x_i + t \\rfloor \\bmod m = 0$.\n2.  A new, refined mesh is constructed. It consists of the children of marked cells (each split into two) and the original unmarked cells.\n3.  A conservative remap is performed from the coarse mesh (with its current state $u^{(t-1)}$) to the newly constructed refined mesh. During this step, the GCL residuals $r^{(t)}_k$ are computed and the overall maximum $E_{\\text{GCL}}$ is updated. This yields the state on the refined mesh, $u'_{\\text{refined}}$.\n4.  A second conservative remap is performed, this time from the refined mesh back to the original uniform coarse mesh. This \"coarsening\" step projects the refined data back onto the base grid, yielding the state for the next cycle, $u^{(t)}$.\n    \nAfter $C$ cycles, the final state on the coarse mesh, $u^{(C)}$, is used to compute the final diagnostics:\n-   The uniform-invariance deviation, $E_{\\infty} = \\max_j |u^{(C)}_j - U_0|$.\n-   The mass-conservation error, $E_{\\text{mass}} = |\\sum_j u^{(C)}_j \\Delta x_j - U_0|$, since the domain has total length $1$.\n\nGiven that the GCL should hold to machine precision, the uniform state $u_i \\equiv U_0$ is expected to be preserved through all remap operations, up to floating-point error. Consequently, the diagnostics $E_{\\infty}$ and $E_{\\text{mass}}$ should also be very small, non-zero values close to machine precision, scaled by the magnitude of $U_0$. The implementation uses standard double-precision (`float64`) floating-point numbers provided by `NumPy`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef remap_conservative(old_mesh_bounds, old_u, new_mesh_bounds, compute_gcl=False):\n    \"\"\"\n    Performs a conservative remap from an old mesh to a new mesh.\n\n    Args:\n        old_mesh_bounds (np.ndarray): Array of shape (N_old, 2) for old cell boundaries.\n        old_u (np.ndarray): Array of shape (N_old,) for old cell values.\n        new_mesh_bounds (np.ndarray): Array of shape (N_new, 2) for new cell boundaries.\n        compute_gcl (bool): If True, compute and return GCL residuals.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The new cell values.\n            - np.ndarray or None: GCL residuals if compute_gcl is True, else None.\n    \"\"\"\n    n_old_cells = old_mesh_bounds.shape[0]\n    n_new_cells = new_mesh_bounds.shape[0]\n    new_u = np.zeros(n_new_cells, dtype=float)\n    gcl_residuals = np.zeros(n_new_cells, dtype=float) if compute_gcl else None\n\n    for j in range(n_new_cells):\n        new_cell_start, new_cell_end = new_mesh_bounds[j]\n        new_cell_length = new_cell_end - new_cell_start\n\n        total_mass_in_new_cell = 0.0\n        total_overlap_length = 0.0\n\n        for i in range(n_old_cells):\n            old_cell_start, old_cell_end = old_mesh_bounds[i]\n\n            overlap_start = max(old_cell_start, new_cell_start)\n            overlap_end = min(old_cell_end, new_cell_end)\n            \n            overlap_length = max(0.0, overlap_end - overlap_start)\n\n            if overlap_length > 0:\n                total_mass_in_new_cell += old_u[i] * overlap_length\n            \n            if compute_gcl:\n                total_overlap_length += overlap_length\n\n        if new_cell_length > 1e-15: # Avoid division by zero\n            new_u[j] = total_mass_in_new_cell / new_cell_length\n        else:\n            new_u[j] = 0.0\n\n        if compute_gcl:\n            gcl_residuals[j] = new_cell_length - total_overlap_length\n\n    if compute_gcl:\n        return new_u, gcl_residuals\n    return new_u, None\n\ndef run_simulation(N, C, U0, alpha, m):\n    \"\"\"\n    Runs one test case of the AMR GCL verification test.\n\n    Args:\n        N (int): Number of initial uniform cells.\n        C (int): Number of refine/coarsen cycles.\n        U0 (float): Initial uniform state value.\n        alpha (float): Parameter for the refinement predicate.\n        m (int): Parameter for the refinement predicate.\n\n    Returns:\n        tuple: A tuple containing (E_inf, E_mass, E_GCL).\n    \"\"\"\n    # 1. Initialize original mesh and state\n    dx = 1.0 / N\n    original_mesh_bounds = np.array([[i * dx, (i + 1) * dx] for i in range(N)], dtype=float)\n    original_mesh_centers = (original_mesh_bounds[:, 0] + original_mesh_bounds[:, 1]) / 2.0\n    u_coarse = np.full(N, U0, dtype=float)\n\n    E_GCL_max = 0.0\n\n    # 2. Main loop over C cycles\n    for t in range(C):\n        # a. Determine which cells to refine\n        refine_flags = (np.floor(alpha * original_mesh_centers + t) % m) == 0\n        \n        # b. Build refined mesh\n        refined_mesh_bounds_list = []\n        for i in range(N):\n            if refine_flags[i]:\n                start, end = original_mesh_bounds[i]\n                mid = (start + end) / 2.0\n                refined_mesh_bounds_list.append([start, mid])\n                refined_mesh_bounds_list.append([mid, end])\n            else:\n                refined_mesh_bounds_list.append(list(original_mesh_bounds[i]))\n        refined_mesh_bounds = np.array(refined_mesh_bounds_list, dtype=float)\n\n        # c. Remap coarse-to-fine (and compute GCL)\n        u_refined, gcl_residuals = remap_conservative(\n            original_mesh_bounds, u_coarse, refined_mesh_bounds, compute_gcl=True\n        )\n        if gcl_residuals is not None:\n            max_res_in_cycle = np.max(np.abs(gcl_residuals))\n            if max_res_in_cycle > E_GCL_max:\n                E_GCL_max = max_res_in_cycle\n        \n        # d. Remap fine-to-coarse\n        u_coarse_new, _ = remap_conservative(\n            refined_mesh_bounds, u_refined, original_mesh_bounds, compute_gcl=False\n        )\n        \n        # e. Update state\n        u_coarse = u_coarse_new\n    \n    u_final = u_coarse\n    \n    # 3. Calculate final diagnostics\n    E_inf = np.max(np.abs(u_final - U0))\n    # Total initial mass is U0 * domain_length = U0 * 1.0\n    E_mass = np.abs(np.sum(u_final * dx) - U0)\n    E_GCL = E_GCL_max\n\n    return E_inf, E_mass, E_GCL\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A: (N, C, U0, alpha, m) = (16, 8, 1.0, 10, 2)\n        (16, 8, 1.0, 10, 2),\n        # Test case B: (N, C, U0, alpha, m) = (1, 16, pi, 1000, 3)\n        (1, 16, np.pi, 1000, 3),\n        # Test case C: (N, C, U0, alpha, m) = (32, 10, 10^-12, 7, 5)\n        (32, 10, 1e-12, 7, 5),\n        # Test case D: (N, C, U0, alpha, m) = (8, 12, 10^6, 13, 4)\n        (8, 12, 1e6, 13, 4),\n    ]\n\n    results = []\n    for params in test_cases:\n        E_inf, E_mass, E_GCL = run_simulation(*params)\n        results.append(f\"[{E_inf},{E_mass},{E_GCL}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}