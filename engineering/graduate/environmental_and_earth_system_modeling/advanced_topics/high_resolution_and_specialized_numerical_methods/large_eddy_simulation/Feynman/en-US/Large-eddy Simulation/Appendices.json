{
    "hands_on_practices": [
        {
            "introduction": "The Smagorinsky model serves as a foundational subgrid-scale (SGS) closure in Large-Eddy Simulation. This first practice focuses on implementing this model from first principles to compute the eddy viscosity ($ \\nu_t $) and the resulting subgrid-scale dissipation ($ \\varepsilon_{\\mathrm{sgs}} $), which are the core outputs of the model. This exercise  is essential for translating the abstract theory of SGS modeling into a concrete computational tool that parameterizes the energetic effects of unresolved turbulent scales.",
            "id": "4058479",
            "problem": "You are tasked with implementing a computational module, expressed as a complete and runnable program, that applies the Smagorinsky subgrid-scale closure within Large-Eddy Simulation (LES) for shear-driven flow relevant to numerical weather prediction and climate modeling. Starting from the filtered momentum equations of incompressible flow and the definition of the resolved rate-of-strain, derive from first principles the expressions needed to compute the turbulent eddy viscosity and the subgrid-scale dissipation per unit mass at discrete sample points. The program must then apply these expressions to a well-defined test suite and produce outputs in the exact format specified.\n\nUse the following foundational bases and definitions:\n- Begin from the filtered incompressible Navier–Stokes equations and the definition of the Subgrid-Scale (SGS) stress tensor. The filtered momentum equation introduces an SGS stress $ \\tau_{ij} $ representing the effect of unresolved scales on resolved scales.\n- The resolved symmetric rate-of-strain tensor is defined as $ S_{ij} = \\tfrac{1}{2}\\left( \\partial u_i / \\partial x_j + \\partial u_j / \\partial x_i \\right) $, and the second invariant of $ S_{ij} $ is $ S_{ij} S_{ij} $.\n- For anisotropic grids, the effective filter width is $ \\Delta = (\\Delta_x \\Delta_y \\Delta_z)^{1/3} $ expressed in meters, a widely used geometric mean that is consistent with three-dimensional top-hat filters in Large-Eddy Simulation (LES).\n\nYour program shall implement the following tasks:\n1. From first principles, derive an algorithm to compute the turbulent eddy viscosity $ \\nu_t $ based on a mixing-length argument consistent with the Smagorinsky model, in terms of a constant Smagorinsky coefficient $ C_s $, an effective filter width $ \\Delta $, and the invariant magnitude of the resolved strain-rate tensor $ S_{ij} $. Do not assume any shortcut formulas; the derivation must follow from dimensional analysis and the eddy-viscosity closure for the deviatoric part of the Subgrid-Scale (SGS) stress.\n2. From the derived closure, obtain an expression for the subgrid-scale dissipation per unit mass, $ \\varepsilon_{\\mathrm{sgs}} $, defined as $ -\\tau_{ij} S_{ij} $, ensuring the dissipative property is preserved under the chosen closure and correctly accounting for the isotropic contribution.\n\nUnits and output requirements:\n- All given and computed quantities must consistently use International System of Units (SI). Strain-rate components $ S_{ij} $ are in $ \\mathrm{s}^{-1} $, grid spacings $ \\Delta_x $, $ \\Delta_y $, $ \\Delta_z $ are in $ \\mathrm{m} $, the Smagorinsky coefficient $ C_s $ is dimensionless, the eddy viscosity $ \\nu_t $ must be expressed in $ \\mathrm{m}^2\\,\\mathrm{s}^{-1} $, and the dissipation $ \\varepsilon_{\\mathrm{sgs}} $ must be expressed in $ \\mathrm{m}^2\\,\\mathrm{s}^{-3} $ per unit mass.\n- Angles do not appear in this problem.\n- Your final numerical outputs must be rounded to six decimal places.\n\nTest suite:\nCompute $ \\nu_t $ and $ \\varepsilon_{\\mathrm{sgs}} $ for each of the following five independent cases. Each case provides a symmetric resolved strain-rate tensor $ S_{ij} $ at a sample point and grid spacings, along with the Smagorinsky coefficient $ C_s $:\n- Case $A$ (general shear, anisotropic grid):\n  - $ \\Delta_x = 10\\,\\mathrm{m} $, $ \\Delta_y = 10\\,\\mathrm{m} $, $ \\Delta_z = 5\\,\\mathrm{m} $, $ C_s = 0.17 $.\n  - $ S_{ij} $ components in $ \\mathrm{s}^{-1} $: $ S_{11} = 0 $, $ S_{22} = 0 $, $ S_{33} = 0 $, $ S_{12} = S_{21} = 0.5 $, $ S_{23} = S_{32} = 0.2 $, $ S_{13} = S_{31} = 0 $.\n- Case $B$ (zero strain edge case):\n  - $ \\Delta_x = 20\\,\\mathrm{m} $, $ \\Delta_y = 20\\,\\mathrm{m} $, $ \\Delta_z = 20\\,\\mathrm{m} $, $ C_s = 0.17 $.\n  - $ S_{ij} $ components: all entries are $ 0\\,\\mathrm{s}^{-1} $.\n- Case $C$ (strong anisotropy and stronger shear):\n  - $ \\Delta_x = 50\\,\\mathrm{m} $, $ \\Delta_y = 50\\,\\mathrm{m} $, $ \\Delta_z = 5\\,\\mathrm{m} $, $ C_s = 0.17 $.\n  - $ S_{ij} $ components: $ S_{11} = 0 $, $ S_{22} = 0 $, $ S_{33} = 0 $, $ S_{12} = S_{21} = 1.0 $, $ S_{23} = S_{32} = -0.5 $, $ S_{13} = S_{31} = 0.3 $.\n- Case $D$ (refined isotropic grid with moderate shear):\n  - $ \\Delta_x = 1\\,\\mathrm{m} $, $ \\Delta_y = 1\\,\\mathrm{m} $, $ \\Delta_z = 1\\,\\mathrm{m} $, $ C_s = 0.17 $.\n  - $ S_{ij} $ components: $ S_{11} = 0 $, $ S_{22} = 0 $, $ S_{33} = 0 $, $ S_{12} = S_{21} = 0.4 $, $ S_{23} = S_{32} = 0.1 $, $ S_{13} = S_{31} = 0 $.\n- Case $E$ (variation in Smagorinsky coefficient and mixed shear):\n  - $ \\Delta_x = 10\\,\\mathrm{m} $, $ \\Delta_y = 15\\,\\mathrm{m} $, $ \\Delta_z = 7.5\\,\\mathrm{m} $, $ C_s = 0.23 $.\n  - $ S_{ij} $ components: $ S_{11} = 0 $, $ S_{22} = 0 $, $ S_{33} = 0 $, $ S_{12} = S_{21} = 0.6 $, $ S_{23} = S_{32} = 0.3 $, $ S_{13} = S_{31} = 0.2 $.\n\nProgram output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one case and must be a two-element list $ [\\nu_t, \\varepsilon_{\\mathrm{sgs}}] $ with both values rounded to six decimal places, in SI units, for example: $ [[\\nu_{t,A},\\varepsilon_{\\mathrm{sgs},A}],[\\nu_{t,B},\\varepsilon_{\\mathrm{sgs},B}],\\dots] $.",
            "solution": "We begin with the filtered incompressible Navier–Stokes equations appropriate for Large-Eddy Simulation (LES). Filtering the momentum equation yields a term involving the Subgrid-Scale (SGS) stress tensor $ \\tau_{ij} = \\overline{u_i u_j} - \\overline{u}_i \\, \\overline{u}_j $, where the overbar denotes filtering. The filtered equation for the resolved velocity $ \\overline{u}_i $ includes $ \\partial_j \\tau_{ij} $ and requires closure.\n\nThe resolved symmetric rate-of-strain tensor is defined as\n$$\nS_{ij} = \\frac{1}{2}\\left( \\frac{\\partial \\overline{u}_i}{\\partial x_j} + \\frac{\\partial \\overline{u}_j}{\\partial x_i} \\right),\n$$\nwith units $ \\mathrm{s}^{-1} $. A physically consistent eddy-viscosity closure models the deviatoric part of the SGS stress tensor as proportional to the resolved strain-rate:\n$$\n\\tau_{ij} - \\frac{1}{3}\\tau_{kk}\\delta_{ij} = -2 \\nu_t S_{ij},\n$$\nwhere $ \\nu_t $ is the eddy viscosity. This closure enforces symmetry and ensures that $ \\tau_{ij} $ is aligned with $ S_{ij} $, consistent with the idea that unresolved motions act as an effective viscosity on the resolved field.\n\nDimensional analysis and mixing-length theory motivate the Smagorinsky form for the eddy viscosity. The mixing length $ \\ell_s $ is taken to scale with the filter width such that $ \\ell_s = C_s \\Delta $, where $ C_s $ is a dimensionless Smagorinsky coefficient and $ \\Delta $ is an effective filter width. For anisotropic grids, a widely used choice for $ \\Delta $ consistent with three-dimensional top-hat filters is\n$$\n\\Delta = (\\Delta_x \\Delta_y \\Delta_z)^{1/3}.\n$$\nThe eddy viscosity must have units $ \\mathrm{m}^2\\,\\mathrm{s}^{-1} $, and combining a length scale $ \\ell_s $ with a velocity gradient scale derived from $ S_{ij} $ gives\n$$\n\\nu_t \\propto \\ell_s^2 \\, \\left| S \\right|.\n$$\nTo form a scalar magnitude from the tensor $ S_{ij} $, we use the invariant based on the second tensorial invariant of the rate-of-strain:\n$$\n\\left| S \\right| = \\sqrt{2 S_{ij} S_{ij}},\n$$\nwhere $ S_{ij} S_{ij} = \\sum_{i=1}^{3}\\sum_{j=1}^{3} S_{ij}^2 $ is the double contraction and the factor of $ 2 $ is conventional so that $ \\left| S \\right| $ reduces to the absolute shear rate in simple shear and preserves rotational invariance. Consequently, the Smagorinsky eddy viscosity becomes\n$$\n\\nu_t = (C_s \\Delta)^2 \\, \\sqrt{2 S_{ij} S_{ij}}.\n$$\n\nNext, we consider the subgrid-scale dissipation per unit mass. The resolved kinetic energy equation includes the SGS dissipation term\n$$\n\\varepsilon_{\\mathrm{sgs}} = -\\tau_{ij} S_{ij}.\n$$\nSubstituting the deviatoric closure and noting that the isotropic part $ \\tfrac{1}{3}\\tau_{kk}\\delta_{ij} $ does not contribute to $ -\\tau_{ij} S_{ij} $ because $ \\delta_{ij} S_{ij} = S_{kk} $ and for incompressible resolved flow $ S_{kk} = 0 $, we obtain\n$$\n\\varepsilon_{\\mathrm{sgs}} = -\\left( -2 \\nu_t S_{ij} \\right) S_{ij} = 2 \\nu_t S_{ij} S_{ij}.\n$$\nThis expression is strictly nonnegative because $ \\nu_t \\ge 0 $ and $ S_{ij} S_{ij} \\ge 0 $, thereby enforcing the dissipative nature of the SGS closure.\n\nAlgorithmic steps for each test case:\n1. Compute the effective filter width $ \\Delta = (\\Delta_x \\Delta_y \\Delta_z)^{1/3} $ using the provided grid spacings $ \\Delta_x $, $ \\Delta_y $, $ \\Delta_z $.\n2. Compute the invariant $ S_{ij} S_{ij} = \\sum_{i=1}^{3}\\sum_{j=1}^{3} S_{ij}^2 $ from the given symmetric $ S_{ij} $.\n3. Compute $ \\left| S \\right| = \\sqrt{2 S_{ij} S_{ij}} $.\n4. Compute the eddy viscosity $ \\nu_t = (C_s \\Delta)^2 \\left| S \\right| $ in $ \\mathrm{m}^2\\,\\mathrm{s}^{-1} $.\n5. Compute the subgrid-scale dissipation per unit mass $ \\varepsilon_{\\mathrm{sgs}} = 2 \\nu_t S_{ij} S_{ij} $ in $ \\mathrm{m}^2\\,\\mathrm{s}^{-3} $.\n6. Round both $ \\nu_t $ and $ \\varepsilon_{\\mathrm{sgs}} $ to six decimal places for output.\n\nScientific realism and edge-case behavior:\n- In Case $B$, $ S_{ij} = 0 $ implies $ \\nu_t = 0 $ and $ \\varepsilon_{\\mathrm{sgs}} = 0 $, as expected in the absence of shear.\n- In Case $C$, strong anisotropy with large $ \\Delta_x $ and $ \\Delta_y $ and small $ \\Delta_z $ enlarges $ \\Delta $, increasing $ \\nu_t $ and $ \\varepsilon_{\\mathrm{sgs}} $ under strong shear.\n- In Case $D$, refined grid reduces $ \\Delta $, reducing $ \\nu_t $ and $ \\varepsilon_{\\mathrm{sgs}} $ for the same resolved strain, reflecting enhanced resolution and diminished SGS activity.\n- In Case $E$, a larger $ C_s $ increases the mixing length $ \\ell_s $ and thus increases both $ \\nu_t $ and $ \\varepsilon_{\\mathrm{sgs}} $, illustrating parameter sensitivity.\n\nThe program implements these steps for the five specified cases and prints a single line containing a list of five two-element lists $ [\\nu_t, \\varepsilon_{\\mathrm{sgs}}] $, each rounded to six decimal places, with units implicitly SI as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_nu_t_and_epsilon(S, dx, dy, dz, Cs):\n    \"\"\"\n    Compute eddy viscosity nu_t and SGS dissipation epsilon_sgs\n    for a given symmetric strain-rate tensor S, grid spacings, and Smagorinsky coefficient.\n\n    Parameters:\n    - S: 3x3 numpy array for S_ij components [1/s]\n    - dx, dy, dz: grid spacings [m]\n    - Cs: Smagorinsky coefficient (dimensionless)\n\n    Returns:\n    - nu_t [m^2/s]\n    - epsilon_sgs [m^2/s^3]\n    \"\"\"\n    # Effective filter width using geometric mean for anisotropic grid\n    Delta = (dx * dy * dz) ** (1.0 / 3.0)\n\n    # Invariant S_ij S_ij = sum_{i,j} S_ij^2\n    s2 = float(np.sum(S**2))\n\n    # |S| = sqrt(2 * S_ij S_ij)\n    S_mag = np.sqrt(2.0 * s2)\n\n    # Eddy viscosity nu_t = (Cs * Delta)^2 * |S|\n    mixing_length_sq = (Cs * Delta) ** 2\n    nu_t = mixing_length_sq * S_mag\n\n    # Subgrid-scale dissipation per unit mass: epsilon_sgs = 2 * nu_t * (S_ij S_ij)\n    epsilon_sgs = 2.0 * nu_t * s2\n\n    return nu_t, epsilon_sgs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (S matrix, dx, dy, dz, Cs)\n    test_cases = [\n        # Case A: general shear, anisotropic grid\n        (\n            np.array([\n                [0.0, 0.5, 0.0],\n                [0.5, 0.0, 0.2],\n                [0.0, 0.2, 0.0]\n            ], dtype=float),\n            10.0, 10.0, 5.0, 0.17\n        ),\n        # Case B: zero strain edge case\n        (\n            np.zeros((3,3), dtype=float),\n            20.0, 20.0, 20.0, 0.17\n        ),\n        # Case C: strong anisotropy and stronger shear\n        (\n            np.array([\n                [0.0,  1.0,  0.3],\n                [1.0,  0.0, -0.5],\n                [0.3, -0.5,  0.0]\n            ], dtype=float),\n            50.0, 50.0, 5.0, 0.17\n        ),\n        # Case D: refined isotropic grid with moderate shear\n        (\n            np.array([\n                [0.0, 0.4, 0.0],\n                [0.4, 0.0, 0.1],\n                [0.0, 0.1, 0.0]\n            ], dtype=float),\n            1.0, 1.0, 1.0, 0.17\n        ),\n        # Case E: variation in C_s and mixed shear\n        (\n            np.array([\n                [0.0, 0.6, 0.2],\n                [0.6, 0.0, 0.3],\n                [0.2, 0.3, 0.0]\n            ], dtype=float),\n            10.0, 15.0, 7.5, 0.23\n        ),\n    ]\n\n    results_str = []\n\n    for S, dx, dy, dz, Cs in test_cases:\n        nu_t, epsilon_sgs = compute_nu_t_and_epsilon(S, dx, dy, dz, Cs)\n        # Round to six decimal places and format without spaces\n        nu_t_str = f\"{nu_t:.6f}\"\n        epsilon_str = f\"{epsilon_sgs:.6f}\"\n        results_str.append(f\"[{nu_t_str},{epsilon_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "An effective subgrid-scale model must not only be accurate but also physically consistent. A critical physical constraint is \"realizability,\" which requires that the model acts dissipatively on average and does not spontaneously generate kinetic energy at the subgrid scales. This practice  provides a direct, hands-on method for diagnosing a model's physical soundness by verifying that the subgrid-scale dissipation, $ \\epsilon_{\\mathrm{sgs}} $, is non-negative, a crucial step in model validation that highlights potential pitfalls like negative eddy viscosity.",
            "id": "4058404",
            "problem": "You are asked to design and implement a complete, runnable program that evaluates the consistency of a modeled subgrid-scale (SGS) stress tensor in Large-Eddy Simulation (LES) with the realizability condition that the SGS dissipation is nonnegative everywhere. Large-Eddy Simulation (LES) of atmospheric flows in numerical weather prediction and climate modeling filters the velocity field to separate resolved and unresolved scales. Let the filtered velocity field be denoted by $\\bar{u}_i$, where $i \\in \\{1,2,3\\}$ indexes the spatial components, and let the modeled SGS stress be denoted by $\\tau_{ij}$. The SGS dissipation density is defined as\n$$\\epsilon_{\\mathrm{sgs}} = - \\tau_{ij} \\,\\partial_j \\bar{u}_i.$$\nRealizability in this context is taken to mean that the modeled SGS dissipation is nonnegative everywhere in the domain, that is,\n$$\\epsilon_{\\mathrm{sgs}}(x,y,z) \\ge 0 \\quad \\text{for all points }(x,y,z)\\text{ in the domain}.$$\nYour program must compute $\\epsilon_{\\mathrm{sgs}}$ pointwise for each test case and return a boolean indicating whether $\\epsilon_{\\mathrm{sgs}} \\ge 0$ everywhere (within numerical tolerance). To account for floating point roundoff, treat values greater than or equal to $-10^{-12}$ as nonnegative.\n\nAll trigonometric functions must use angles in radians. The spatial domain for all test cases is the periodic cube $[0,L]^3$ with $L = 2\\pi$, discretized on a uniform grid of $N \\times N \\times N$ points with $N = 16$. Grid points are located at\n$$x_n = \\frac{n L}{N},\\quad y_m = \\frac{m L}{N},\\quad z_k = \\frac{k L}{N},\\quad n,m,k \\in \\{0,1,\\dots,N-1\\}.$$\nThe fluid density is constant, $\\rho = 1.0$ (in $\\mathrm{kg/m^3}$), and the kinematic reference magnitude is $\\nu_0 = 0.1$ (in $\\mathrm{m^2/s}$). The velocity amplitude is $U_0 = 1.0$ (in $\\mathrm{m/s}$). The modeled SGS stress is specified per test case below.\n\nYour program must implement the following three test cases. For each case, compute the filtered velocity field $\\bar{u}_i(x,y,z)$, its gradient $\\partial_j \\bar{u}_i(x,y,z)$ analytically, construct the modeled $\\tau_{ij}(x,y,z)$, and then compute $\\epsilon_{\\mathrm{sgs}}(x,y,z)$ and check nonnegativity across the grid.\n\nDefinitions used in all cases:\n- The symmetric resolved strain-rate tensor is defined by\n$$S_{ij} = \\frac{1}{2}\\left(\\partial_j \\bar{u}_i + \\partial_i \\bar{u}_j\\right).$$\n\nTest Case $1$ (eddy-viscosity model with nonnegative viscosity; expected to satisfy realizability):\n- Velocity field components:\n$$\\bar{u}_1(x,y,z) = U_0 \\sin x \\,\\cos y \\,\\cos z,$$\n$$\\bar{u}_2(x,y,z) = - U_0 \\cos x \\,\\sin y \\,\\cos z,$$\n$$\\bar{u}_3(x,y,z) = \\frac{1}{2} U_0 \\sin x \\,\\sin y \\,\\sin z.$$\n- Kinematic SGS viscosity:\n$$\\nu_t(x,y,z) = \\nu_0 \\left(1 + \\frac{1}{2} \\sin x \\,\\cos y \\,\\cos z\\right),$$\nwhich is nonnegative everywhere by construction.\n- Modeled SGS stress:\n$$\\tau_{ij}(x,y,z) = - 2 \\rho \\,\\nu_t(x,y,z)\\, S_{ij}(x,y,z).$$\n\nTest Case $2$ (dynamic eddy-viscosity with sign changes; expected to violate realizability at some points):\n- Velocity field components are the same as in Test Case $1$.\n- Kinematic SGS viscosity:\n$$\\nu_t(x,y,z) = \\nu_0 \\,\\frac{\\cos x + \\cos y + \\cos z}{3},$$\nwhich changes sign in the domain.\n- Modeled SGS stress:\n$$\\tau_{ij}(x,y,z) = - 2 \\rho \\,\\nu_t(x,y,z)\\, S_{ij}(x,y,z).$$\n\nTest Case $3$ (uniform flow; gradient identically zero; expected to satisfy realizability):\n- Velocity field components:\n$$\\bar{u}_1(x,y,z) = U_0,\\quad \\bar{u}_2(x,y,z) = 0,\\quad \\bar{u}_3(x,y,z) = 0.$$\n- Gradient is identically zero, so $S_{ij}(x,y,z) = 0$.\n- Modeled SGS stress:\n$$\\tau_{ij}(x,y,z) = 0.$$\n\nImplementation requirements:\n- Compute $\\partial_j \\bar{u}_i$ analytically from the specified $\\bar{u}_i$ for each test case.\n- For each test case, compute $\\epsilon_{\\mathrm{sgs}}(x,y,z) = - \\tau_{ij} \\,\\partial_j \\bar{u}_i$ at every grid point by summing over repeated indices $i$ and $j$.\n- A test case passes if $\\epsilon_{\\mathrm{sgs}}(x,y,z) \\ge -10^{-12}$ at all grid points; otherwise it fails.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one boolean per test case in order $[1,2,3]$; for example, if Test Case $1$ and $3$ pass and Test Case $2$ fails, the output should be\n$$[\\text{True},\\text{False},\\text{True}].$$\n\nYour program must be self-contained, require no user input, and use radians for all trigonometric evaluations. The final booleans are unitless.",
            "solution": "The problem requires the validation of a modeled subgrid-scale (SGS) stress tensor, $\\tau_{ij}$, against the realizability condition of non-negative SGS dissipation, $\\epsilon_{\\mathrm{sgs}} \\ge 0$, for three distinct test cases in the context of Large-Eddy Simulation (LES).\n\nFirst, we establish the theoretical foundation. The SGS dissipation density is defined as:\n$$\n\\epsilon_{\\mathrm{sgs}} = - \\tau_{ij} \\,\\partial_j \\bar{u}_i\n$$\nwhere $\\bar{u}_i$ is the filtered velocity field and $\\partial_j \\bar{u}_i$ is the filtered velocity gradient tensor, which we denote as $G_{ij}$. The summation convention over repeated indices $i,j \\in \\{1,2,3\\}$ is implied.\n\nFor the test cases involving an eddy-viscosity model, the SGS stress tensor is given by:\n$$\n\\tau_{ij} = - 2 \\rho \\nu_t S_{ij}\n$$\nHere, $\\rho$ is the fluid density, $\\nu_t$ is the kinematic SGS viscosity, and $S_{ij}$ is the symmetric resolved strain-rate tensor:\n$$\nS_{ij} = \\frac{1}{2}\\left(\\partial_j \\bar{u}_i + \\partial_i \\bar{u}_j\\right) = \\frac{1}{2}\\left(G_{ij} + G_{ji}\\right)\n$$\nSubstituting the expression for $\\tau_{ij}$ into the definition of $\\epsilon_{\\mathrm{sgs}}$, we obtain:\n$$\n\\epsilon_{\\mathrm{sgs}} = - \\left(- 2 \\rho \\nu_t S_{ij}\\right) G_{ij} = 2 \\rho \\nu_t S_{ij} G_{ij}\n$$\nThe velocity gradient tensor can be decomposed into its symmetric and anti-symmetric parts: $G_{ij} = S_{ij} + \\Omega_{ij}$, where $\\Omega_{ij} = \\frac{1}{2}(G_{ij} - G_{ji})$ is the rotation-rate tensor. The contraction $S_{ij} G_{ij}$ becomes:\n$$\nS_{ij} G_{ij} = S_{ij} (S_{ij} + \\Omega_{ij}) = S_{ij}S_{ij} + S_{ij}\\Omega_{ij}\n$$\nThe term $S_{ij}\\Omega_{ij}$ is a contraction of a symmetric tensor ($S_{ij}$) with an anti-symmetric tensor ($\\Omega_{ij}$), which is identically zero. Thus, $S_{ij} G_{ij} = S_{ij} S_{ij}$. The SGS dissipation simplifies to:\n$$\n\\epsilon_{\\mathrm{sgs}} = 2 \\rho \\nu_t S_{ij} S_{ij}\n$$\nThe term $S_{ij}S_{ij} = \\sum_{i=1}^3 \\sum_{j=1}^3 S_{ij}^2$ is the squared Frobenius norm of the strain-rate tensor. As a sum of squares of real numbers, it is always non-negative: $S_{ij}S_{ij} \\ge 0$. Consequently, for an eddy-viscosity model of this form, the sign of the SGS dissipation $\\epsilon_{\\mathrm{sgs}}$ is determined solely by the sign of the SGS viscosity $\\nu_t$. The realizability condition $\\epsilon_{\\mathrm{sgs}} \\ge 0$ is satisfied if and only if $\\nu_t \\ge 0$ at all points where $S_{ij}$ is not identically zero.\n\nThe computational procedure is as follows:\n1.  Define the physical and numerical constants: $L=2\\pi$, $N=16$, $\\rho=1.0$, $\\nu_0=0.1$, $U_0=1.0$.\n2.  Construct the 3D computational grid for the domain $[0, L]^3$ using $N^3$ points, with coordinates $x_n = \\frac{nL}{N}$, $y_m = \\frac{mL}{N}$, $z_k = \\frac{kL}{N}$ for $n,m,k \\in \\{0, 1, \\dots, N-1\\}$.\n3.  For each test case, perform the following steps:\n    a.  Analytically derive the nine components of the velocity gradient tensor $G_{ij} = \\partial_j \\bar{u}_i$ from the given velocity field $\\bar{u}_i(x,y,z)$.\n    b.  Numerically evaluate $G_{ij}$ at every point on the 3D grid.\n    c.  Compute the strain-rate tensor $S_{ij} = \\frac{1}{2}(G_{ij} + G_{ji})$ at each grid point.\n    d.  Evaluate the given SGS viscosity field $\\nu_t(x,y,z)$ at each grid point.\n    e.  Compute the SGS stress tensor $\\tau_{ij} = -2 \\rho \\nu_t S_{ij}$ at each grid point.\n    f.  Compute the SGS dissipation density $\\epsilon_{\\mathrm{sgs}} = - \\sum_{i,j} \\tau_{ij} G_{ij}$ at each grid point.\n    g.  Determine the minimum value of $\\epsilon_{\\mathrm{sgs}}$ over the entire grid.\n    h.  A test case is deemed consistent with realizability if this minimum value is greater than or equal to the specified numerical tolerance of $-10^{-12}$.\n\nThe analytical derivatives of the velocity field for Test Cases $1$ and $2$ ($\\bar{u}_1 = U_0 \\sin x \\cos y \\cos z$, $\\bar{u}_2 = -U_0 \\cos x \\sin y \\cos z$, $\\bar{u}_3 = \\frac{1}{2} U_0 \\sin x \\sin y \\sin z$) are:\n- $\\partial_1\\bar{u}_1 = U_0 \\cos x \\cos y \\cos z$, $\\partial_2\\bar{u}_1 = -U_0 \\sin x \\sin y \\cos z$, $\\partial_3\\bar{u}_1 = -U_0 \\sin x \\cos y \\sin z$\n- $\\partial_1\\bar{u}_2 = U_0 \\sin x \\sin y \\cos z$, $\\partial_2\\bar{u}_2 = -U_0 \\cos x \\cos y \\cos z$, $\\partial_3\\bar{u}_2 = U_0 \\cos x \\sin y \\sin z$\n- $\\partial_1\\bar{u}_3 = \\frac{1}{2} U_0 \\cos x \\sin y \\sin z$, $\\partial_2\\bar{u}_3 = \\frac{1}{2} U_0 \\sin x \\cos y \\sin z$, $\\partial_3\\bar{u}_3 = \\frac{1}{2} U_0 \\sin x \\sin y \\cos z$\n\n**Test Case 1**:\n- $\\nu_t(x,y,z) = \\nu_0 (1 + \\frac{1}{2} \\sin x \\cos y \\cos z)$. Since $|\\sin x \\cos y \\cos z| \\le 1$, the term in the parenthesis ranges from $1 - \\frac{1}{2} = \\frac{1}{2}$ to $1 + \\frac{1}{2} = \\frac{3}{2}$. Thus, $\\nu_t$ is strictly positive everywhere. As $\\epsilon_{\\mathrm{sgs}} = 2 \\rho \\nu_t S_{ij}S_{ij}$, and both $\\nu_t$ and $S_{ij}S_{ij}$ are non-negative, $\\epsilon_{\\mathrm{sgs}}$ must be non-negative. This case is expected to pass.\n\n**Test Case 2**:\n- $\\nu_t(x,y,z) = \\nu_0 (\\cos x + \\cos y + \\cos z)/3$. This expression for $\\nu_t$ can be negative. For example, at the grid point $(x,y,z) = (\\pi, \\pi, \\pi)$, $\\nu_t = \\nu_0(-1-1-1)/3 = -\\nu_0  0$. At this point, the strain-rate tensor $S_{ij}$ is non-zero, leading to $S_{ij}S_{ij} > 0$. Therefore, $\\epsilon_{\\mathrm{sgs}}$ will be negative at this point, violating the realizability condition. This case is expected to fail.\n\n**Test Case 3**:\n- The velocity field is uniform: $\\bar{u} = (U_0, 0, 0)$. The velocity gradient tensor $G_{ij}$ is identically zero everywhere. This implies that the strain-rate tensor $S_{ij}$ is also zero. The problem states $\\tau_{ij}=0$. Therefore, $\\epsilon_{\\mathrm{sgs}} = - \\tau_{ij} G_{ij} = - (0)(0) = 0$ everywhere. This satisfies the realizability condition $\\epsilon_{\\mathrm{sgs}} \\ge 0$. This case is expected to pass.\n\nThe program implements these calculations using NumPy for efficient vectorized operations on the 3D grid. The final output is a list of booleans indicating the outcome for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates the realizability of a subgrid-scale (SGS) stress tensor model\n    for three test cases in Large-Eddy Simulation (LES).\n    \"\"\"\n    # Define physical and numerical parameters\n    L = 2.0 * np.pi\n    N = 16\n    rho = 1.0\n    nu0 = 0.1\n    U0 = 1.0\n    TOL = -1.0e-12\n\n    # Create the computational grid\n    grid_points_1d = np.linspace(0.0, L, N, endpoint=False)\n    x, y, z = np.meshgrid(grid_points_1d, grid_points_1d, grid_points_1d, indexing='ij')\n\n    results = []\n\n    # --- Common calculations for Case 1 and Case 2 ---\n    # Analytically compute components of the velocity gradient tensor G_ij = d(u_i)/dx_j\n    G = np.zeros((N, N, N, 3, 3))\n    # Gradients of u1\n    G[..., 0, 0] = U0 * np.cos(x) * np.cos(y) * np.cos(z)\n    G[..., 0, 1] = -U0 * np.sin(x) * np.sin(y) * np.cos(z)\n    G[..., 0, 2] = -U0 * np.sin(x) * np.cos(y) * np.sin(z)\n    # Gradients of u2\n    G[..., 1, 0] = U0 * np.sin(x) * np.sin(y) * np.cos(z)\n    G[..., 1, 1] = -U0 * np.cos(x) * np.cos(y) * np.cos(z)\n    G[..., 1, 2] = U0 * np.cos(x) * np.sin(y) * np.sin(z)\n    # Gradients of u3\n    G[..., 2, 0] = 0.5 * U0 * np.cos(x) * np.sin(y) * np.sin(z)\n    G[..., 2, 1] = 0.5 * U0 * np.sin(x) * np.cos(y) * np.sin(z)\n    G[..., 2, 2] = 0.5 * U0 * np.sin(x) * np.sin(y) * np.cos(z)\n\n    # Compute the strain-rate tensor S_ij = 0.5 * (G_ij + G_ji)\n    S = 0.5 * (G + G.swapaxes(-1, -2))\n\n    # --- Test Case 1 ---\n    # Kinematic SGS viscosity\n    nu_t_1 = nu0 * (1.0 + 0.5 * np.sin(x) * np.cos(y) * np.cos(z))\n    # Modeled SGS stress tensor\n    tau_1 = -2.0 * rho * nu_t_1[..., np.newaxis, np.newaxis] * S\n    # SGS dissipation density\n    epsilon_sgs_1 = -np.sum(tau_1 * G, axis=(-1, -2))\n    # Check realizability condition\n    results.append(np.min(epsilon_sgs_1) >= TOL)\n\n    # --- Test Case 2 ---\n    # Kinematic SGS viscosity\n    nu_t_2 = nu0 * (np.cos(x) + np.cos(y) + np.cos(z)) / 3.0\n    # Modeled SGS stress tensor\n    tau_2 = -2.0 * rho * nu_t_2[..., np.newaxis, np.newaxis] * S\n    # SGS dissipation density\n    epsilon_sgs_2 = -np.sum(tau_2 * G, axis=(-1, -2))\n    # Check realizability condition\n    results.append(np.min(epsilon_sgs_2) >= TOL)\n\n    # --- Test Case 3 ---\n    # For uniform flow, velocity gradient is zero, so S_ij=0, tau_ij=0,\n    # and epsilon_sgs = 0 everywhere.\n    epsilon_sgs_3 = 0.0\n    # The condition 0.0 >= TOL is always true.\n    results.append(epsilon_sgs_3 >= TOL)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A major limitation of the basic Smagorinsky model is its constant coefficient, $ C_s $, which requires a priori specification and is not universally applicable to all flows. The dynamic procedure, a landmark advancement in LES, overcomes this by computing the coefficient locally based on the flow's instantaneous state. This advanced exercise  walks you through the core algebraic steps of the dynamic model, using the Germano identity and a least-squares minimization to determine the model coefficient $ C_s^2 $ from the resolved flow field, offering insight into how modern LES models adapt to complex turbulence.",
            "id": "3888513",
            "problem": "Consider a dynamic Large-Eddy Simulation (LES) framework for incompressible turbulent flow in environmental and earth system modeling. The filtered momentum equation implies a residual subgrid stress that must be modeled. In the Smagorinsky closure, the subgrid eddy viscosity is modeled as $\\nu_t = C_s^2 \\Delta^2 |S|$, where $C_s^2$ is a dimensionless model coefficient, $\\Delta$ is the grid filter width in $\\mathrm{m}$, and $|S|$ denotes the magnitude of the resolved-rate-of-strain tensor $S_{ij}$, with $S_{ij}$ defined from the resolved filtered velocity field by $S_{ij} = \\frac{1}{2}\\left(\\frac{\\partial \\tilde{u}_i}{\\partial x_j} + \\frac{\\partial \\tilde{u}_j}{\\partial x_i}\\right)$ in $\\mathrm{s}^{-1}$, and $|S| = \\sqrt{2 S_{ij} S_{ij}}$ in $\\mathrm{s}^{-1}$.\n\nUsing a test filter of width $\\tilde{\\Delta}$ in $\\mathrm{m}$, the Germano identity provides a resolved Leonard stress $L_{ij}$ that, under a modeled Smagorinsky-like closure at both grid and test-filter levels, yields the relation\n$$\nL_{ij} = 2\\left(C_s \\Delta\\right)^2 |S|\\, S_{ij} - 2\\left(C_s \\tilde{\\Delta}\\right)^2 |\\tilde{S}|\\, \\tilde{S}_{ij},\n$$\nwhere $\\tilde{S}_{ij}$ is the rate-of-strain tensor at the test-filter level and $|\\tilde{S}| = \\sqrt{2 \\tilde{S}_{ij} \\tilde{S}_{ij}}$. Define $M_{ij} = 2\\left(\\Delta^2 |S|\\, S_{ij} - \\tilde{\\Delta}^2 |\\tilde{S}|\\, \\tilde{S}_{ij}\\right)$ in $\\mathrm{m}^2 \\mathrm{s}^{-2}$. Then the task is to compute $C_s^2$ by minimizing the least-squares mismatch between the modeled and resolved Leonard stress, that is, determine the value of $C_s^2$ that minimizes\n$$\nJ(C_s^2) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} \\left(L_{ij} - C_s^2 M_{ij}\\right)^2.\n$$\n\nYour program must:\n- Implement the computation of $|S|$ and $|\\tilde{S}|$ from the given $S_{ij}$ and $\\tilde{S}_{ij}$.\n- Construct $M_{ij}$ from $\\Delta$, $\\tilde{\\Delta}$, $|S|$, $|\\tilde{S}|$, $S_{ij}$, and $\\tilde{S}_{ij}$.\n- Compute the least-squares minimizer $C_s^2$ for a given $L_{ij}$, $S_{ij}$, and $\\tilde{S}_{ij}$ as the value that minimizes $J(C_s^2)$.\n- Handle the degenerate case where $\\sum_{i,j} M_{ij}^2$ is zero or below a small tolerance by returning $C_s^2 = 0$.\n\nAll inputs and outputs must adhere to physical units. Specifically, $S_{ij}$ and $\\tilde{S}_{ij}$ are in $\\mathrm{s}^{-1}$, $\\Delta$ and $\\tilde{\\Delta}$ are in $\\mathrm{m}$, and $L_{ij}$, $M_{ij}$ are in $\\mathrm{m}^2 \\mathrm{s}^{-2}$. The computed $C_s^2$ must be reported as a dimensionless floating-point number.\n\nTest Suite:\nUse the following four test cases, which together exercise a general case, a noisy case, a degenerate case, and a sign-indefinite case.\n\n- Case $1$ (general \"happy path\"):\n  - $\\Delta = 10\\,\\mathrm{m}$, $\\tilde{\\Delta} = 20\\,\\mathrm{m}$.\n  - $S = \\begin{pmatrix} 0.06  0.02  -0.01 \\\\ 0.02  -0.03  0.03 \\\\ -0.01  0.03  -0.03 \\end{pmatrix}\\,\\mathrm{s}^{-1}$.\n  - $\\tilde{S} = \\begin{pmatrix} 0.054  0.018  -0.008 \\\\ 0.018  -0.028  0.025 \\\\ -0.008  0.025  -0.026 \\end{pmatrix}\\,\\mathrm{s}^{-1}$.\n  - Construct $L_{ij}$ from the above using a nominal coefficient $C_s^2 = 0.09$ and the given relation.\n- Case $2$ (noisy Leonard stress):\n  - Same $\\Delta$, $\\tilde{\\Delta}$, $S$, and $\\tilde{S}$ as Case $1$.\n  - Construct $L_{ij}$ as in Case $1$ with $C_s^2 = 0.09$, then add a fixed noise matrix $E$ in $\\mathrm{m}^2 \\mathrm{s}^{-2}$ defined by\n    $E = \\begin{pmatrix} 1\\times 10^{-3}  -2\\times 10^{-4}  3\\times 10^{-4} \\\\ -2\\times 10^{-4}  5\\times 10^{-4}  -1\\times 10^{-4} \\\\ 3\\times 10^{-4}  -1\\times 10^{-4}  -6\\times 10^{-4} \\end{pmatrix}$,\n    so that $L_{ij} \\leftarrow L_{ij} + E_{ij}$.\n- Case $3$ (degenerate $M_{ij}$):\n  - $\\Delta = 10\\,\\mathrm{m}$, $\\tilde{\\Delta} = 20\\,\\mathrm{m}$.\n  - $S = \\begin{pmatrix} 0.02  0.01  0.00 \\\\ 0.01  -0.015  0.005 \\\\ 0.00  0.005  -0.005 \\end{pmatrix}\\,\\mathrm{s}^{-1}$.\n  - $\\tilde{S} = 0.5 S$ (that is, each component of $\\tilde{S}$ equals $0.5$ times the corresponding component of $S$).\n  - Set $L_{ij} = 0$ (the zero matrix), which is consistent with $M_{ij} = 0$ under the given construction.\n- Case $4$ (sign-indefinite \"backscatter\"):\n  - $\\Delta = 10\\,\\mathrm{m}$, $\\tilde{\\Delta} = 20\\,\\mathrm{m}$.\n  - Same $S$ and $\\tilde{S}$ as Case $1$.\n  - Construct $L_{ij}$ using a nominal coefficient $C_s^2 = -0.04$ to test negative least-squares minimizers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$, that is, $[C_{s,1}^2,C_{s,2}^2,C_{s,3}^2,C_{s,4}^2]$. Each entry must be a floating-point number representing the computed $C_s^2$ for the respective case (dimensionless).",
            "solution": "The problem is subjected to validation and is deemed valid. It is scientifically grounded in the principles of turbulence modeling for Large-Eddy Simulation (LES), specifically the dynamic Smagorinsky model. The problem is well-posed, mathematically consistent, and all required data and definitions are provided.\n\nThe objective is to find the dimensionless model coefficient $C_s^2$ that minimizes the least-squares error between the resolved Leonard stress, $L_{ij}$, and its model, $C_s^2 M_{ij}$. The quantity to minimize is given by:\n$$\nJ(C_s^2) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} \\left(L_{ij} - C_s^2 M_{ij}\\right)^2\n$$\nTo find the value of $C_s^2$ that minimizes this sum of squares, we must find the root of the derivative of $J$ with respect to $C_s^2$. For notational convenience, let $c = C_s^2$. The objective function is $J(c) = \\sum_{i,j} (L_{ij} - c M_{ij})^2$. We differentiate $J(c)$ with respect to $c$ and set the result to zero:\n$$\n\\frac{dJ}{dc} = \\sum_{i=1}^{3}\\sum_{j=1}^{3} \\frac{d}{dc} \\left(L_{ij} - c M_{ij}\\right)^2 = 0\n$$\nApplying the chain rule:\n$$\n\\sum_{i,j} 2 \\left(L_{ij} - c M_{ij}\\right) \\cdot (-M_{ij}) = 0\n$$\nDistributing the terms:\n$$\n-2 \\sum_{i,j} L_{ij} M_{ij} + 2c \\sum_{i,j} M_{ij}^2 = 0\n$$\nSolving for $c$:\n$$\nc \\sum_{i,j} M_{ij}^2 = \\sum_{i,j} L_{ij} M_{ij}\n$$\nProvided that $\\sum_{i,j} M_{ij}^2 \\neq 0$, we can write the solution as:\n$$\nc = C_s^2 = \\frac{\\sum_{i,j} L_{ij} M_{ij}}{\\sum_{i,j} M_{ij}^2}\n$$\nThis expression is the classical solution to a linear least-squares problem. In terms of matrix operations, the numerator $\\sum_{i,j} L_{ij} M_{ij}$ is the Frobenius inner product of the tensors $L$ and $M$, denoted $\\langle L, M \\rangle_F$. The denominator $\\sum_{i,j} M_{ij}^2$ is the squared Frobenius norm of the tensor $M$, denoted $||M||_F^2$. Thus, the solution can be compactly written as:\n$$\nC_s^2 = \\frac{\\langle L, M \\rangle_F}{||M||_F^2}\n$$\nThe computational procedure for each test case is as follows:\n1.  Given the grid filter width $\\Delta$, the test filter width $\\tilde{\\Delta}$, the resolved-rate-of-strain tensor $S_{ij}$, and the test-filtered rate-of-strain tensor $\\tilde{S}_{ij}$.\n2.  Calculate the magnitudes of the strain-rate tensors. The magnitude $|S|$ is defined as $|S| = \\sqrt{2S_{ij}S_{ij}}$, where summation over repeated indices is implied. This corresponds to $|S| = \\sqrt{2 \\sum_{i,j} S_{ij}^2}$. Similarly, $|\\tilde{S}| = \\sqrt{2 \\sum_{i,j} \\tilde{S}_{ij}^2}$.\n3.  Construct the tensor $M_{ij}$ using its definition:\n    $$\n    M_{ij} = 2\\left(\\Delta^2 |S|\\, S_{ij} - \\tilde{\\Delta}^2 |\\tilde{S}|\\, \\tilde{S}_{ij}\\right)\n    $$\n    All inputs for this calculation, $\\Delta$, $\\tilde{\\Delta}$, $S_{ij}$, and $\\tilde{S}_{ij}$, are provided for each test case.\n4.  For each test case, the Leonard stress tensor $L_{ij}$ is also specified, either by construction from a nominal $C_s^2$ or given directly.\n5.  Calculate the denominator term $D = \\sum_{i,j} M_{ij}^2$. The problem specifies that if $D$ is zero or below a small numerical tolerance, the case is degenerate, and the result should be $C_s^2 = 0$.\n6.  If $D$ is larger than the tolerance, calculate the numerator term $N = \\sum_{i,j} L_{ij} M_{ij}$.\n7.  The final result for the test case is $C_s^2 = N/D$.\n\nThis algorithm is applied to each of the four test cases specified in the problem statement. The cases are designed to test the general functionality (Case $1$), robustness to noise (Case $2$), handling of degenerate conditions (Case $3$), and the possibility of a negative (backscatter) coefficient (Case $4$). Case $3$ is constructed such that $M_{ij}$ is the zero tensor, triggering the degenerate condition handler.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the Smagorinsky coefficient C_s^2 for four test cases\n    based on the dynamic LES procedure.\n    \"\"\"\n\n    def calculate_cs_squared(delta, delta_tilde, S, S_tilde, L, tol=1e-20):\n        \"\"\"\n        Calculates the Smagorinsky coefficient C_s^2 using a least-squares minimization.\n\n        Args:\n            delta (float): Grid filter width in m.\n            delta_tilde (float): Test filter width in m.\n            S (np.ndarray): Resolved-rate-of-strain tensor in s^-1.\n            S_tilde (np.ndarray): Test-filtered rate-of-strain tensor in s^-1.\n            L (np.ndarray): Resolved Leonard stress tensor in m^2/s^2.\n            tol (float): Tolerance for checking if the denominator is zero.\n\n        Returns:\n            float: The computed dimensionless C_s^2 value.\n        \"\"\"\n        # Calculate magnitudes of the strain-rate tensors, |T| = sqrt(2 * T_ij * T_ij).\n        # This is equivalent to sqrt(2) * ||T||_Frob.\n        S_mag = np.sqrt(2 * np.sum(S**2))\n        S_tilde_mag = np.sqrt(2 * np.sum(S_tilde**2))\n\n        # Construct the tensor M_ij.\n        # M_ij = 2 * (delta^2 * |S| * S_ij - delta_tilde^2 * |S_tilde| * S_tilde_ij)\n        M = 2 * (delta**2 * S_mag * S - delta_tilde**2 * S_tilde_mag * S_tilde)\n\n        # The least-squares solution for C_s^2 is L, M_F / ||M||_F^2.\n        # Numerator is the Frobenius inner product of L and M.\n        numerator = np.sum(L * M)\n        # Denominator is the squared Frobenius norm of M.\n        denominator = np.sum(M**2)\n\n        # Handle the degenerate case where the denominator is close to zero.\n        if denominator  tol:\n            return 0.0\n\n        # Compute C_s^2.\n        cs_squared = numerator / denominator\n        \n        return cs_squared\n\n    # === Define Test Cases ===\n\n    # Case 1: General \"happy path\"\n    delta_1 = 10.0\n    delta_tilde_1 = 20.0\n    S_1 = np.array([\n        [0.06, 0.02, -0.01],\n        [0.02, -0.03, 0.03],\n        [-0.01, 0.03, -0.03]\n    ])\n    S_tilde_1 = np.array([\n        [0.054, 0.018, -0.008],\n        [0.018, -0.028, 0.025],\n        [-0.008, 0.025, -0.026]\n    ])\n    # Construct L_1 for Case 1 based on a nominal C_s^2.\n    S_mag_1 = np.sqrt(2 * np.sum(S_1**2))\n    S_tilde_mag_1 = np.sqrt(2 * np.sum(S_tilde_1**2))\n    M_1 = 2 * (delta_1**2 * S_mag_1 * S_1 - delta_tilde_1**2 * S_tilde_mag_1 * S_tilde_1)\n    C_s_sq_nominal_1 = 0.09\n    L_1 = C_s_sq_nominal_1 * M_1\n\n    # Case 2: Noisy Leonard stress\n    # Uses the same parameters as Case 1, but with added noise to L_ij.\n    E_noise = np.array([\n        [1e-3, -2e-4, 3e-4],\n        [-2e-4, 5e-4, -1e-4],\n        [3e-4, -1e-4, -6e-4]\n    ])\n    L_2 = L_1 + E_noise\n\n    # Case 3: Degenerate M_ij\n    delta_3 = 10.0\n    delta_tilde_3 = 20.0\n    S_3 = np.array([\n        [0.02, 0.01, 0.0],\n        [0.01, -0.015, 0.005],\n        [0.0, 0.005, -0.005]\n    ])\n    # The special relation S_tilde = 0.5 S with delta_tilde = 2*delta makes M_ij = 0.\n    S_tilde_3 = 0.5 * S_3\n    L_3 = np.zeros((3, 3))\n\n    # Case 4: Sign-indefinite \"backscatter\" case\n    # Uses the same parameters as Case 1, but L_ij is constructed with a negative C_s^2.\n    C_s_sq_nominal_4 = -0.04\n    L_4 = C_s_sq_nominal_4 * M_1\n\n    # Package cases for processing\n    test_cases = [\n        {'delta': delta_1, 'delta_tilde': delta_tilde_1, 'S': S_1, 'S_tilde': S_tilde_1, 'L': L_1},\n        {'delta': delta_1, 'delta_tilde': delta_tilde_1, 'S': S_1, 'S_tilde': S_tilde_1, 'L': L_2},\n        {'delta': delta_3, 'delta_tilde': delta_tilde_3, 'S': S_3, 'S_tilde': S_tilde_3, 'L': L_3},\n        {'delta': delta_1, 'delta_tilde': delta_tilde_1, 'S': S_1, 'S_tilde': S_tilde_1, 'L': L_4}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_cs_squared(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}