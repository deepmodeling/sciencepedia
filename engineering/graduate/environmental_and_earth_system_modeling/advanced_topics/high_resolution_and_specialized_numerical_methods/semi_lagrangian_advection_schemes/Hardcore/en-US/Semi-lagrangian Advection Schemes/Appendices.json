{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a direct look at the core trade-off in designing semi-Lagrangian schemes: the choice of interpolation method. While higher-order interpolation can improve accuracy for smooth fields, it can also introduce unphysical oscillations, or a loss of monotonicity, when dealing with sharp gradients. By implementing several interpolation schemes for a 'top-hat' tracer, you will directly observe and quantify this behavior, a crucial first step in selecting the right scheme for a given physical problem .",
            "id": "3911345",
            "problem": "You are asked to design and implement a one-dimensional semi-Lagrangian advection test to assess monotonicity using a top-hat tracer, and to quantify the amplitude of spurious undershoots as a function of the Courant–Friedrichs–Lewy (CFL) number and interpolation order. The fundamental base you must use is the one-dimensional passive tracer advection equation and the definition of semi-Lagrangian transport.\n\nScenario and fundamentals:\n- Consider the one-dimensional passive tracer advection equation on a periodic domain of length $L$ in meters:\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\nwhere $c(x,t)$ is the tracer concentration (dimensionless), $u$ is the constant velocity in $\\mathrm{m/s}$, $x$ is the spatial coordinate in meters, and $t$ is time in seconds.\n- The semi-Lagrangian approach is based on the material derivative definition along trajectories, namely that the tracer is constant along trajectories for pure advection:\n$$\n\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0.\n$$\n- From this foundation, derive how to advance $c$ from time level $t^n$ to time level $t^{n+1} = t^n + \\Delta t$ at grid points $x_i$ by evaluating the previous-time tracer at the departure points. Your derivation must start from the above equations and core definitions without using or assuming any shortcut formulas.\n\nNumerical setup:\n- Use a uniform periodic grid with $N$ points, domain length $L = 1$ (meters), spatial step $\\Delta x = L/N$ (meters), velocity $u = 1$ (meters per second), and a single time step $\\Delta t$ (seconds) determined by the Courant–Friedrichs–Lewy number:\n$$\n\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}.\n$$\n- Initialize a top-hat tracer $c(x,0)$ with amplitude $1$ on an interval $[x_0, x_0+w)$ and $0$ elsewhere, with $x_0 = 0.33 L$ (meters) and $w = 0.20 L$ (meters). The tracer is dimensionless and strictly within $[0,1]$ initially.\n\nInterpolation and monotonicity assessment:\n- Implement three interpolation orders for evaluating the previous-time tracer at departure points:\n  1. Order $p=0$: nearest-neighbor interpolation.\n  2. Order $p=1$: linear interpolation.\n  3. Order $p=3$: cubic Lagrange interpolation using the four nearest grid values.\n- After one semi-Lagrangian time step, compute the amplitude of spurious undershoots, defined as\n$$\nA_{\\text{under}} = \\max\\left(0, -\\min_i c^{n+1}(x_i)\\right),\n$$\nwhich measures violations of the lower bound $0$. The amplitude is dimensionless (same unit as $c$). No angles are involved in this problem.\n\nAlgorithmic requirements:\n- Derive and implement the semi-Lagrangian update from first principles: compute the departure point for each grid point, then interpolate the previous-time tracer to that point using the chosen interpolation order, respecting periodic boundary conditions.\n- Ensure that the implementation is scientifically realistic and self-consistent. Use $N$ sufficiently large to resolve the top-hat and interpolation effects.\n\nTest suite:\n- Use $N = 2048$ (integer), $L = 1$ (meters), $u = 1$ (meters per second), and the top-hat parameters $x_0 = 0.33 L$ and $w = 0.20 L$.\n- For each test case, compute $\\Delta t$ from the specified $\\mathrm{CFL}$ via $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$ (seconds), perform exactly one semi-Lagrangian step, and return $A_{\\text{under}}$.\n- The test suite consists of the following $(p, \\mathrm{CFL})$ pairs:\n  1. $(0, 0.75)$,\n  2. $(1, 0.75)$,\n  3. $(3, 0.75)$,\n  4. $(3, 0.25)$,\n  5. $(3, 1.00)$,\n  6. $(3, 2.25)$,\n  7. $(3, 0.00)$,\n  8. $(1, 0.25)$,\n  9. $(0, 0.25)$.\n\nOutput specification:\n- Your program should produce a single line of output containing the nine amplitudes $A_{\\text{under}}$ for the above test cases as a comma-separated list enclosed in square brackets, in the same order as the test suite, with each amplitude rounded to six decimal places. For example:\n$$\n\\text{[0.000000,0.000000,0.012345,\\dots]}\n$$\nNo additional text should be printed.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It constitutes a standard numerical experiment for analyzing the properties of semi-Lagrangian advection schemes. We shall proceed with the derivation and solution.\n\n### Principle-Based Derivation of the Semi-Lagrangian Method\n\nThe one-dimensional passive tracer advection equation is given as:\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0\n$$\nwhere $c(x,t)$ is the tracer concentration, $u$ is a constant velocity, $x$ is the spatial coordinate, and $t$ is time. The expression on the left is the material derivative of the concentration $c$ along a trajectory $X(t)$ moving with the flow, defined as $\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x}$. The governing equation thus simplifies to:\n$$\n\\frac{D c}{D t} = 0\n$$\nThis equation states that the concentration $c$ is constant along the characteristic curves, which are the trajectories of fluid parcels. The characteristic curve $X(\\tau)$ is described by the ordinary differential equation:\n$$\n\\frac{dX(\\tau)}{d\\tau} = u\n$$\nTo find the concentration $c^{n+1}(x_i)$ at a grid point $x_i$ and time $t^{n+1} = t^n + \\Delta t$, we trace the characteristic curve backward in time from the arrival point $(x_i, t^{n+1})$ to find its departure point $(x_{d,i}, t^n)$ at the previous time level $t^n$. Since $u$ is constant, integrating the trajectory equation from $t^n$ to $t^{n+1}$ is straightforward:\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dX}{d\\tau} d\\tau = \\int_{t^n}^{t^{n+1}} u d\\tau\n$$\n$$\nX(t^{n+1}) - X(t^n) = u (t^{n+1} - t^n)\n$$\nSubstituting $X(t^{n+1}) = x_i$ and the definition of the departure point $x_{d,i} = X(t^n)$, we get:\n$$\nx_i - x_{d,i} = u \\Delta t\n$$\nThis yields the location of the departure point:\n$$\nx_{d,i} = x_i - u \\Delta t\n$$\nThe principle $\\frac{Dc}{Dt}=0$ implies that the concentration is conserved along this path:\n$$\nc(x_i, t^{n+1}) = c(x_{d,i}, t^n)\n$$\nIn a numerical context, $c(x, t^n)$ is only known at discrete grid points $x_j$. The departure point $x_{d,i}$ will, in general, not coincide with any grid point. Therefore, to find the value $c(x_{d,i}, t^n)$, we must interpolate the gridded data from time $t^n$. Denoting the interpolation operator by $\\mathcal{I}$, the semi-Lagrangian update rule is:\n$$\nc_i^{n+1} = \\mathcal{I}[c^n](x_{d,i}) = \\mathcal{I}[c^n](x_i - u \\Delta t)\n$$\n\n### Numerical Implementation\n\nThe domain of length $L=1$ is discretized into $N$ grid cells, with grid spacing $\\Delta x = L/N$. The grid points are $x_i = i \\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$. The velocity is $u=1$. We can express the time step $\\Delta t$ in terms of the Courant–Friedrichs–Lewy (CFL) number: $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$. Substituting these into the departure point equation:\n$$\nx_{d,i} = x_i - u \\left(\\frac{\\mathrm{CFL} \\cdot \\Delta x}{u}\\right) = i\\Delta x - \\mathrm{CFL} \\cdot \\Delta x = (i - \\mathrm{CFL})\\Delta x\n$$\nThis shows that the departure point, measured in grid units, is located at the non-dimensional coordinate $\\alpha_i = i - \\mathrm{CFL}$. Due to the periodic domain of size $N$ grid cells, we use this coordinate modulo $N$: $\\alpha_{\\text{p},i} = \\alpha_i \\pmod N$.\n\nLet $j = \\lfloor \\alpha_{\\text{p},i} \\rfloor$ be the index of the last grid point before the departure point, and let $s = \\alpha_{\\text{p},i} - j$ be the fractional distance into the interval $[x_j, x_{j+1})$, where $s \\in [0, 1)$. The value $c_i^{n+1}$ is obtained by interpolating the values $c_k^n$ using the stencil of points around index $j$.\n\n### Interpolation Schemes and Monotonicity\n\nThe initial condition is a top-hat function with values in $[0, 1]$. A numerical scheme is monotone if it does not introduce new extrema. For this problem, a monotone scheme would ensure that $c_i^{n+1} \\in [0, 1]$, and thus the undershoot amplitude $A_{\\text{under}} = \\max(0, -\\min_i c_i^{n+1})$ would be zero.\n\n1.  **Order $p=0$ (Nearest-Neighbor)**: The value is taken from the nearest grid point. $c_i^{n+1} = c_{j+\\text{round}(s)}^n$. Since this only selects existing values from the initial data, it is monotone. We expect $A_{\\text{under}}=0$.\n\n2.  **Order $p=1$ (Linear Interpolation)**: The value is a weighted average of the two bracketing grid points.\n    $$\n    c_i^{n+1} = (1-s)c_j^n + s c_{j+1}^n\n    $$\n    As a convex combination of two values in $[0, 1]$, the result is also in $[0, 1]$. This scheme is monotone, and we expect $A_{\\text{under}}=0$.\n\n3.  **Order $p=3$ (Cubic Lagrange Interpolation)**: We use the four nearest grid points, forming a stencil $\\{j-1, j, j+1, j+2\\}$ to construct a cubic polynomial. All indices must be handled periodically, e.g., index $j-1$ becomes $(j-1) \\pmod N$. The interpolated value is:\n    $$\n    c_i^{n+1} = c_{j-1}^n \\mathcal{L}_{-1}(s) + c_{j}^n \\mathcal{L}_{0}(s) + c_{j+1}^n \\mathcal{L}_{1}(s) + c_{j+2}^n \\mathcal{L}_{2}(s)\n    $$\n    where $\\mathcal{L}_k(s)$ are the Lagrange basis polynomials evaluated at the normalized local coordinate $s \\in [0,1)$ corresponding to the stencil points at $\\{-1, 0, 1, 2\\}$:\n    $$\n    \\begin{align*}\n    \\mathcal{L}_{-1}(s) = -\\frac{s(s-1)(s-2)}{6} \\\\\n    \\mathcal{L}_{0}(s) = \\frac{(s+1)(s-1)(s-2)}{2} \\\\\n    \\mathcal{L}_{1}(s) = -\\frac{(s+1)s(s-2)}{2} \\\\\n    \\mathcal{L}_{2}(s) = \\frac{(s+1)s(s-1)}{6}\n    \\end{align*}\n    $$\n    This scheme is not generally monotone. The basis polynomials can take on negative values, meaning the interpolated value is not a convex combination. This can lead to spurious oscillations (undershoots and overshoots) near sharp gradients, so we may expect $A_{\\text{under}}  0$ for non-integer CFL numbers. For integer CFL values, the departure point aligns with a grid point, $s=0$, interpolation becomes exact selection ($c_i^{n+1} = c_{i-\\mathrm{CFL}}^n$), and no undershoots are generated.\n\nThe algorithm proceeds by iterating through each test case $(p, \\mathrm{CFL})$, constructing the initial state $c^0$, computing the new state $c^1$ using the specified interpolation, and then calculating $A_{\\text{under}}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D semi-Lagrangian advection test for monotonicity.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    N = 2048\n    L = 1.0\n    u = 1.0\n    x0 = 0.33 * L\n    w = 0.20 * L\n    \n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # ------------------\n    # Initial Condition\n    # ------------------\n    c0 = np.zeros(N, dtype=np.float64)\n    # Define the top-hat tracer profile\n    # Use boolean indexing for clarity and efficiency\n    c0[(x = x0)  (x  (x0 + w))] = 1.0\n    \n    # ------------------\n    # Test Suite\n    # ------------------\n    test_cases = [\n        (0, 0.75),\n        (1, 0.75),\n        (3, 0.75),\n        (3, 0.25),\n        (3, 1.00),\n        (3, 2.25),\n        (3, 0.00),\n        (1, 0.25),\n        (0, 0.25),\n    ]\n    \n    results = []\n    \n    for p, cfl in test_cases:\n        # For CFL=0, there is no change, so no undershoot\n        if cfl == 0.0:\n            results.append(0.0)\n            continue\n            \n        c1 = np.zeros(N, dtype=np.float64)\n\n        for i in range(N):\n            # Calculate departure point in non-dimensional grid coordinates\n            alpha = float(i) - cfl\n            \n            # Apply periodic boundary conditions. Python's % operator handles\n            # negative numbers in a way that is suitable for this (e.g., -0.75 % N = N-0.75).\n            alpha_periodic = alpha % N\n            \n            j = int(np.floor(alpha_periodic))\n            s = alpha_periodic - j\n\n            # Perform interpolation based on order p\n            if p == 0:  # Nearest-neighbor\n                idx = (j + int(round(s))) % N\n                c1[i] = c0[idx]\n            \n            elif p == 1:  # Linear\n                j0 = j\n                j1 = (j + 1) % N\n                c1[i] = (1.0 - s) * c0[j0] + s * c0[j1]\n            \n            elif p == 3:  # Cubic Lagrange\n                # Stencil points are j-1, j, j+1, j+2\n                j_m1 = (j - 1) % N\n                j_0 = j\n                j_1 = (j + 1) % N\n                j_2 = (j + 2) % N\n                \n                # Get the concentrations at the stencil points\n                c_m1 = c0[j_m1]\n                c_0 = c0[j_0]\n                c_1 = c0[j_1]\n                c_2 = c0[j_2]\n                \n                # Evaluate the Lagrange basis polynomials at s\n                l_m1 = -s * (s - 1.0) * (s - 2.0) / 6.0\n                l_0  = (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n                l_1  = -(s + 1.0) * s * (s - 2.0) / 2.0\n                l_2  = (s + 1.0) * s * (s - 1.0) / 6.0\n                \n                c1[i] = l_m1 * c_m1 + l_0 * c_0 + l_1 * c_1 + l_2 * c_2\n        \n        # Calculate amplitude of spurious undershoots\n        min_c1 = np.min(c1)\n        a_under = max(0.0, -min_c1)\n        results.append(a_under)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the previous practice explored shape preservation, this exercise tackles another fundamental property: mass conservation. Standard semi-Lagrangian schemes based on pointwise interpolation are not inherently conservative, which can lead to a disastrous drift in total tracer mass over long simulations. Here, you will contrast such a scheme with a conservative geometric remapping approach, learning how to construct an algorithm that guarantees discrete mass conservation by design . This is an essential skill for developing robust and physically sound environmental models.",
            "id": "3911296",
            "problem": "Consider the one-dimensional linear advection equation on a periodic domain, which is a canonical model for tracer transport in environmental and Earth system modeling: $$\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,$$ posed on the interval $$x \\in [0,1)$$ with periodic boundary conditions and a constant velocity $$u$$. The quantity $$q(x,t)$$ is dimensionless. The Semi-Lagrangian (SL) method advances the solution by following characteristics backward in time: at each grid location $$x_i$$, one identifies the departure point $$x_d = x_i - u \\Delta t$$ and evaluates the previous-time solution at $$x_d$$. In a discrete implementation, this requires interpolation of the field $$q$$ and, depending on the representation, also a remapping of cell averages over geometrically shifted intervals. In continuous form, the total mass $$M(t) = \\int_0^1 q(x,t) \\, dx$$ is exactly conserved under the advection equation. In discrete SL implementations, interpolation choices and geometric remapping choices determine whether discrete total mass is conserved and how mass error accumulates over multiple time steps.\n\nYour task is to construct a quantitative diagnostic for global mass error over multiple steps and compute it for different interpolation and geometric remapping choices in a purely mathematical and computational setting. Work on a uniform periodic grid with $$N_x$$ cells, cell width $$\\Delta x = 1/N_x$$, and either pointwise values located at cell centers $$x_i = (i + 0.5)\\Delta x$$ or cell averages associated with the interval $$[i\\Delta x,(i+1)\\Delta x)$$. For each method and initial condition, define the discrete total mass at step $$n$$ by $$M^n = \\sum_{i=0}^{N_x-1} q_i^n \\, \\Delta x,$$ where $$q_i^n$$ denotes either the pointwise value approximating the local average or the cell average itself, depending on the method. After propagating for $$N_{\\text{steps}}$$ steps with constant time step $$\\Delta t$$, diagnose the global mass error $$E = M^{N_{\\text{steps}}} - M^0$$ as a real number. All quantities are dimensionless; no physical units are required. Assume all arithmetic is performed in exact real arithmetic except for floating-point roundoff inherent to computations.\n\nImplement two SL update paradigms:\n- Pointwise SL with interpolation: use either linear interpolation or cubic interpolation to evaluate $$q^n$$ at the departure point $$x_d = x_i - u \\Delta t$$ for each cell center $$x_i$$, producing the next step $$q^{n+1}$$.\n- Conservative geometric remapping of cell averages: treat $$q_i^n$$ as cell averages and produce $$q_i^{n+1}$$ by averaging the previous field over the departure interval $$[x_i - \\Delta x/2 - u \\Delta t, x_i + \\Delta x/2 - u \\Delta t]$$, which lies on the previous grid due to periodicity. This remapping must be mass-conservative by construction at the discrete level.\n\nConstruct a program that, for the following test suite, computes the global mass error $$E$$ after the prescribed number of steps. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets.\n\nTest Suite:\n- Case 1 (happy path, smooth field, small Courant number, pointwise linear interpolation): $$N_x = 128$$, $$\\Delta t = 1\\times 10^{-2}$$, $$u = 0.1$$, $$N_{\\text{steps}} = 100$$, initial condition $$q(x) = 1 + \\sin(2\\pi x)$$, method: pointwise SL with linear interpolation.\n- Case 2 (smooth field, small Courant number, higher-order interpolation): same parameters as Case 1 but using cubic interpolation, method: pointwise SL with cubic interpolation.\n- Case 3 (nonsmooth field, small Courant number, interpolation-induced mass error stress test): $$N_x = 128$$, $$\\Delta t = 1\\times 10^{-2}$$, $$u = 0.1$$, $$N_{\\text{steps}} = 100$$, initial condition $$q(x) = 1$$ for $$x \\in [0.25,0.75]$$ and $$q(x) = 0$$ otherwise (interpreted periodically), method: pointwise SL with linear interpolation.\n- Case 4 (nonsmooth field, conservative geometric remapping): same parameters as Case 3 but method: conservative geometric remapping of cell averages.\n- Case 5 (large effective shift per step, conservative geometric remapping, periodic wrap-around stress test): $$N_x = 128$$, $$\\Delta t = 0.1$$, $$u = 0.5$$, $$N_{\\text{steps}} = 25$$, initial condition $$q(x) = \\exp\\left(-\\left(\\frac{x - 0.3}{0.05}\\right)^2\\right)$$, method: conservative geometric remapping of cell averages.\n\nYour program must produce the output in the exact format: a single line with the list $$[E_1,E_2,E_3,E_4,E_5]$$, where each $$E_k$$ is the computed global mass error for Case $$k$$ as a floating-point number.",
            "solution": "The problem requires the computation of the global mass error for several semi-Lagrangian (SL) advection schemes applied to the one-dimensional linear advection equation, $\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0$, on a periodic domain $x \\in [0,1)$. The total mass, $M(t) = \\int_0^1 q(x,t) \\, dx$, is an invariant of the continuous equation. We will investigate how well this property is preserved by different discrete numerical methods.\n\nFirst, we establish the discrete framework. The domain is discretized into $N_x$ uniform cells, each of width $\\Delta x = 1/N_x$. The quantity $q(x,t)$ is represented by a vector of discrete values $q^n$ at time step $n$. Two representations are considered:\n1.  **Pointwise values**: $q_i^n$ represents the value of the field at the cell center, $x_i = (i + 0.5)\\Delta x$ for $i=0, \\dots, N_x-1$. Thus, $q_i^n \\approx q(x_i, n\\Delta t)$.\n2.  **Cell averages**: $q_i^n$ represents the average value over cell $i$, which spans the interval $[i\\Delta x, (i+1)\\Delta x)$. Thus, $q_i^n = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x, n\\Delta t) \\, dx$.\n\nThe initial discrete field, $q^0$, is obtained by projecting the given continuous initial condition, $q(x,0)$, onto the grid.\n- For the pointwise representation, we sample the function at cell centers: $q_i^0 = q(x_i, 0)$.\n- For the cell-average representation, we compute the true cell average: $q_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x,0) \\, dx$. This integral is computed analytically for the box function and using the error function `erf` for the Gaussian profile, which is the analytical integral of a Gaussian.\n\nThe discrete total mass at time step $n$ is defined as $M^n = \\Delta x \\sum_{i=0}^{N_x-1} q_i^n$. The global mass error after $N_{\\text{steps}}$ is the difference between the final and initial discrete mass: $E = M^{N_{\\text{steps}}} - M^0$.\n\nWe now detail the semi-Lagrangian time-stepping algorithms. The core idea of the SL method is to trace characteristics backward in time. To find the value $q^{n+1}$ at an arrival point $x_a$, we find its departure point $x_d = x_a - u\\Delta t$ and set $q^{n+1}(x_a) = q^n(x_d)$.\n\n**1. Pointwise SL with Interpolation**\n\nIn this paradigm, we update the pointwise values at each cell center $x_i$. The new value $q_i^{n+1}$ is determined by interpolating the field $q^n$ at the departure point $x_d = x_i - u\\Delta t$.\nThe departure point $x_d$ will generally not coincide with a grid point. Its position relative to the grid is used to perform interpolation. We define a continuous-like grid coordinate $p(x) = (x / \\Delta x) - 0.5$, such that grid point $x_i$ corresponds to integer coordinate $i$. The departure position for $x_i$ is $p_d = ((x_i - u\\Delta t) \\pmod{1}) / \\Delta x - 0.5$. Let $j = \\lfloor p_d \\rfloor$ be the integer part and $f = p_d - j$ be the fractional part, where $0 \\le f  1$.\n\n-   **Linear Interpolation**: We use the two nearest grid points, $j$ and $j+1$, to form a linear interpolant. The indices are handled periodically.\n    $$q_i^{n+1} = (1-f) q_{j \\pmod{N_x}}^n + f q_{(j+1) \\pmod{N_x}}^n$$\n    This method is simple and computationally efficient but is not inherently mass-conservative. The sum of interpolated values is not guaranteed to equal the sum of the original values.\n\n-   **Cubic Interpolation**: A higher-order, more accurate interpolation can be achieved using four grid points. We use the Lagrange form for a polynomial passing through the points $(j-1, q_{j-1}^n)$, $(j, q_j^n)$, $(j+1, q_{j+1}^n)$, and $(j+2, q_{j+2}^n)$. Evaluating this polynomial at the fractional position $f$ (relative to grid point $j$) gives:\n    $$q_i^{n+1} = L(f) = \\sum_{m=-1}^{2} q_{j+m}^n \\prod_{k=-1, k\\ne m}^{2} \\frac{f-k}{m-k}$$\n    Explicitly, this is:\n    $$q_i^{n+1} = q_{j-1}^n \\frac{f(f-1)(f-2)}{-6} + q_j^n \\frac{(f+1)(f-1)(f-2)}{2} + q_{j+1}^n \\frac{(f+1)f(f-2)}{-2} + q_{j+2}^n \\frac{(f+1)f(f-1)}{6}$$\n    All indices are periodic. Like linear interpolation, this method is not guaranteed to conserve mass.\n\n**2. Conservative Geometric Remapping**\n\nThis method is designed to be discretely mass-conservative. The field $q^n$ is interpreted as a piecewise constant function, where its value is $q_i^n$ over the cell $[i\\Delta x, (i+1)\\Delta x)$. The new cell average $q_i^{n+1}$ is found by calculating the average of $q^n$ over the departure region for cell $i$. This region is the interval $[i\\Delta x, (i+1)\\Delta x)$ shifted backward in time, i.e., $[i\\Delta x - u\\Delta t, (i+1)\\Delta x - u\\Delta t)$.\nThe new cell average is:\n$$q_i^{n+1} = \\frac{1}{\\Delta x} \\int_{i\\Delta x - u\\Delta t}^{(i+1)\\Delta x - u\\Delta t} q^n(x') \\, dx'$$\nLet $\\alpha = u\\Delta t / \\Delta x$ be the displacement in grid cell units. Let $k = \\lfloor \\alpha \\rfloor$ and $\\delta = \\alpha - k$. The departure interval for cell $i$ is $[(i-k-\\delta)\\Delta x, (i-k-\\delta+1)\\Delta x)$. Since $q^n$ is piecewise constant, the integral is a sum over the segments of this interval that overlap with the cells of the old grid. This calculation yields a simple-looking but powerful update rule:\n$$q_i^{n+1} = (1-\\delta) q_{(i-k) \\pmod{N_x}}^n + \\delta q_{(i-k-1) \\pmod{N_x}}^n$$\nThis scheme is conservative by construction. To verify, we sum over all cells:\n$$M^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} q_i^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} \\left( (1-\\delta) q_{i-k}^n + \\delta q_{i-k-1}^n \\right)$$\nBy re-indexing the sums (which is valid due to periodicity), we get:\n$$M^{n+1} = \\Delta x \\left( (1-\\delta) \\sum_{j=0}^{N_x-1} q_j^n + \\delta \\sum_{j=0}^{N_x-1} q_j^n \\right) = (1-\\delta) M^n + \\delta M^n = M^n$$\nThus, the discrete mass is exactly conserved at each time step. Any computed error $E$ for this method should be attributable solely to floating-point roundoff error.\n\nThe provided Python code implements these algorithms to compute the mass error for each specified test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef initialize_q(Nx, ic_name, method):\n    \"\"\"\n    Initializes the discrete field q0 based on the initial condition function\n    and the representation (pointwise or cell-average).\n    \"\"\"\n    dx = 1.0 / Nx\n    if method.startswith('pointwise'):\n        x = (np.arange(Nx) + 0.5) * dx\n        if ic_name == 'sin':\n            return 1.0 + np.sin(2 * np.pi * x)\n        elif ic_name == 'box':\n            return np.where((x = 0.25)  (x  0.75), 1.0, 0.0)\n    elif method.startswith('conservative'):\n        q0 = np.zeros(Nx)\n        if ic_name == 'box':\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                overlap = max(0.0, min(x_right, 0.75) - max(x_left, 0.25))\n                q0[i] = overlap / dx\n            return q0\n        elif ic_name == 'gauss':\n            mu, sigma = 0.3, 0.05\n            # Use the analytical integral of a Gaussian, which involves the error function (erf)\n            # ∫ exp(-((x-μ)/σ)²) dx = σ * sqrt(π)/2 * erf((x-μ)/σ)\n            sqrt_pi_half_sigma = sigma * np.sqrt(np.pi) / 2.0\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                integral = sqrt_pi_half_sigma * (erf((x_right - mu) / sigma) - erf((x_left - mu) / sigma))\n                q0[i] = integral / dx\n            return q0\n    return None\n\ndef advect_step(q, Nx, dx, u, dt, method):\n    \"\"\"\n    Performs a single time step of semi-Lagrangian advection.\n    \"\"\"\n    if method == 'pointwise_linear':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        # Calculate fractional grid positions for departure points\n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        f = p - j\n        \n        # Use np.take for efficient periodic boundary handling\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        \n        return (1.0 - f) * q_j + f * q_j1\n\n    elif method == 'pointwise_cubic':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        s = p - j  # Fractional part for Lagrange formula\n        \n        q_jm1 = np.take(q, j - 1, mode='wrap')\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        q_j2 = np.take(q, j + 2, mode='wrap')\n        \n        # 4-point Lagrange interpolation formula\n        term_m1 = q_jm1 * s * (s - 1.0) * (s - 2.0) / -6.0\n        term_0 = q_j * (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n        term_1 = q_j1 * (s + 1.0) * s * (s - 2.0) / -2.0\n        term_2 = q_j2 * (s + 1.0) * s * (s - 1.0) / 6.0\n        \n        return term_m1 + term_0 + term_1 + term_2\n\n    elif method == 'conservative_remapping':\n        alpha = u * dt / dx  # Displacement in grid cell units\n        k = np.floor(alpha).astype(int)\n        delta = alpha - k\n        \n        # Update rule derived from geometric remapping of cell averages\n        # q_new[i] = (1-delta)*q[i-k] + delta*q[i-(k+1)]\n        # This is vectorized using np.roll for periodic shifts\n        q_new = (1.0 - delta) * np.roll(q, k) + delta * np.roll(q, k + 1)\n        return q_new\n\n    else:\n        raise ValueError(f\"Unknown method: {method}\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute global mass errors.\n    \"\"\"\n    test_cases = [\n        # (Nx, dt, u, N_steps, ic_name, method)\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_cubic'),\n        (128, 1e-2, 0.1, 100, 'box', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'box', 'conservative_remapping'),\n        (128, 0.1, 0.5, 25, 'gauss', 'conservative_remapping'),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, dt, u, N_steps, ic_name, method = case\n        \n        dx = 1.0 / Nx\n        \n        # 1. Initialize the field q\n        q0 = initialize_q(Nx, ic_name, method)\n        \n        # 2. Compute initial mass\n        M0 = np.sum(q0) * dx\n        \n        # 3. Time-step the solution\n        q = q0.copy()\n        for _ in range(N_steps):\n            q = advect_step(q, Nx, dx, u, dt, method)\n            \n        # 4. Compute final mass and error\n        M_final = np.sum(q) * dx\n        error = M_final - M0\n        results.append(error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from one to multiple dimensions presents new challenges, and a common strategy is 'dimensional splitting'—handling each direction sequentially. While appealingly simple, this approach is not exact and can introduce significant errors, particularly for rotating flows common in geophysical and plasma systems. This practice guides you to isolate and analyze this splitting error for a solid-body rotation test case, revealing the spurious effects that arise from the non-commutativity of advection operators . This analysis is key to understanding the behavior of multi-dimensional advection schemes used in practice.",
            "id": "4199723",
            "problem": "Consider the two-dimensional passive-scalar advection equation in the plane with coordinates $x$ and $y$, governed by the velocity field $\\boldsymbol{u}(x,y,t)$, written as the first-order Partial Differential Equation (PDE)\n$$\n\\frac{\\partial f}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla f = 0,\n$$\nwhere $f(x,y,t)$ is the advected scalar. In semi-Lagrangian advection schemes, the scalar $f$ at an arrival point $(x,y)$ and time $t+\\Delta t$ is evaluated by backtracing along characteristics to a departure point $(x_d,y_d)$ at time $t$, and then sampling $f(x_d,y_d,t)$. The method avoids Eulerian Courant–Friedrichs–Lewy constraints by tracing characteristics rather than performing explicit flux updates.\n\nThis problem analyzes the error introduced by dimensional splitting for rotating flows and quantifies spurious cross-derivative effects on a solid-body rotation test relevant to Fusion Plasma Turbulence Simulation, where ExB rotation is a frequent motif. You must derive from first principles and implement a program that computes the error associated with splitting on a smooth test function, and then quantify the component of the error aligned with the mixed second derivative (cross-derivative) structure.\n\nFundamental base and setup:\n- The velocity is a solid-body rotation with angular velocity $\\Omega$ (in radians per second), given by\n$$\nu(x,y) = -\\Omega\\,y,\\qquad v(x,y) = \\Omega\\,x.\n$$\n- For a time step $\\Delta t$ (in seconds), the exact characteristic flow that maps an arrival location $(x,y)$ at time $t+\\Delta t$ to the departure location $(x_d,y_d)$ at time $t$ is a rotation by angle $\\theta=\\Omega\\,\\Delta t$ (in radians) backward in time. The exact departure mapping is\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad\ny_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n- A dimensionally split semi-Lagrangian method, using Lie splitting (first advect along $x$ then along $y$), computes the departure mapping by sequential one-dimensional backtraces:\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega\\,y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v(x^{(1)},y^{(1)})\\,\\Delta t = y - \\Omega\\,x^{(1)}\\,\\Delta t.\n$$\n- The initial condition $f_0(x,y)$ is a rotated elliptical Gaussian, a smooth test profile that breaks axisymmetry to expose cross-derivative couplings. Define the principal-axis coordinates by\n$$\nx' = x\\cos\\alpha + y\\sin\\alpha,\\qquad y' = -x\\sin\\alpha + y\\cos\\alpha,\n$$\nand let\n$$\nf_0(x,y) = \\exp\\!\\left(-\\left[\\frac{x'^2}{\\sigma_1^2} + \\frac{y'^2}{\\sigma_2^2}\\right]\\right),\n$$\nwith $\\alpha$ the rotation angle (in radians), and $\\sigma_1,\\sigma_2$ the semi-axes widths (in the same length units as $x$ and $y$). The exact semi-Lagrangian update yields $f^{\\mathrm{exact}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\right)$, while the split update yields $f^{\\mathrm{split}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}}\\right)$.\n\nError quantification:\n- Define the local error field\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y).\n$$\n- Define the mixed second derivative (cross-derivative) of the initial condition $f_0$ at the arrival grid as\n$$\nD_{xy}(x,y) = \\frac{\\partial^2 f_0}{\\partial x\\,\\partial y}(x,y),\n$$\ncomputed numerically by periodic central differences on the grid.\n- Compute the $L^2$ norm of the error\n$$\n\\|E\\|_{2} = \\left(\\int_{\\Omega_D} E(x,y)^2\\,\\mathrm{d}x\\,\\mathrm{d}y\\right)^{1/2},\n$$\nand the $L^\\infty$ norm $\\|E\\|_{\\infty} = \\max_{(x,y)\\in\\Omega_D} |E(x,y)|$, where $\\Omega_D$ denotes the computational domain.\n- Quantify the spurious cross-derivative effect by the orthogonal projection of $E$ onto $D_{xy}$ in the discrete inner product on the grid:\n$$\nC_{xy} = \\frac{\\langle E, D_{xy} \\rangle}{\\langle D_{xy}, D_{xy} \\rangle},\n$$\nwhere $\\langle A,B\\rangle = \\int_{\\Omega_D} A(x,y)\\,B(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$ is approximated by summation times the cell area. The fraction of the error energy aligned with the cross-derivative structure is\n$$\nR = \\frac{|C_{xy}|\\,\\|D_{xy}\\|_{2}}{\\|E\\|_{2}},\n$$\nwhich is dimensionless.\n\nDomain, units, and numerics:\n- Use a square periodic domain of side length $L$ (in meters), i.e., $x,y\\in[-L/2,L/2)$, discretized uniformly with $N_x\\times N_y$ points and spacings $\\Delta x = L/N_x$, $\\Delta y = L/N_y$.\n- Time is in seconds, $\\Omega$ is in radians per second, and angles such as $\\theta$ and $\\alpha$ are in radians.\n- All reported outputs are dimensionless floats. The scalar $f$ is unitless for this test.\n- The initial condition and all evaluations $f_0(x_d,y_d)$ must be computed analytically from the rotated Gaussian definition, not by grid interpolation, to isolate the splitting error from interpolation error.\n\nRequired program behavior:\n- Implement the above mappings and measures.\n- Use periodic central differences to compute $D_{xy}$.\n- For each test case, compute and return the four floats in the order $\\|E\\|_2$, $\\|E\\|_\\infty$, $C_{xy}$, and $R$.\n\nTest suite:\n- Let $N_x=N_y=128$, $L=1$, and $\\Omega=2\\pi$.\n- Three test cases covering different facets:\n    1. Happy path: $\\Delta t = 1/64$, $\\alpha = \\pi/6$, $\\sigma_1 = 0.15$, $\\sigma_2 = 0.25$.\n    2. Larger time step: $\\Delta t = 1/8$, $\\alpha = \\pi/6$, $\\sigma_1 = 0.15$, $\\sigma_2 = 0.25$.\n    3. Symmetry edge case (near-zero cross-derivative projection expected): $\\Delta t = 1/8$, $\\alpha = 0$, $\\sigma_1 = 0.2$, $\\sigma_2 = 0.2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots]$), where the entries are the $4$ floats for test case $1$, followed by the $4$ floats for test case $2$, followed by the $4$ floats for test case $3$; thus $12$ floats total in a single list.",
            "solution": "We begin from the passive scalar advection PDE $\\partial_t f + \\boldsymbol{u}\\cdot\\nabla f = 0$, which implies that $f$ is constant along characteristics. The characteristic curves $(x(t),y(t))$ satisfy the ordinary differential equations (ODEs)\n$$\n\\frac{dx}{dt} = u(x,y) = -\\Omega\\,y, \\qquad \\frac{dy}{dt} = v(x,y) = \\Omega\\,x,\n$$\nwith $\\Omega$ the angular frequency of rotation. The solution to these linear ODEs is a uniform rotation. Over a time step $\\Delta t$, the forward map from $(x_0,y_0)$ at time $t$ to $(x_1,y_1)$ at time $t+\\Delta t$ is\n$$\nx_1 = x_0\\cos\\theta - y_0\\sin\\theta,\\qquad y_1 = x_0\\sin\\theta + y_0\\cos\\theta,\\qquad \\theta = \\Omega\\,\\Delta t.\n$$\nThe semi-Lagrangian update demands the backtrace: given $(x,y)$ at time $t+\\Delta t$, find $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ at time $t$ so that $f(x,y,t+\\Delta t) = f(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}},t)$. Inverting the forward rotation yields the exact departure mapping\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad y_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n\nDimensional splitting approximates the two-dimensional advection by sequential one-dimensional solves. For Lie splitting (first moving along $x$, then along $y$) we define operators $\\mathcal{A} = u(x,y)\\,\\partial_x$ and $\\mathcal{B} = v(x,y)\\,\\partial_y$. One step applies the $x$-advection for $\\Delta t$ then the $y$-advection for $\\Delta t$. The corresponding semi-Lagrangian backtrace uses\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v\\big(x^{(1)},y^{(1)}\\big)\\,\\Delta t = y - \\Omega x^{(1)}\\,\\Delta t.\n$$\nThis mapping is exact for separable advections with commuting operators, but for rotation the operators do not commute. The Lie splitting local error can be analyzed using the Baker-Campbell-Hausdorff (BCH) expansion: for non-commuting operators $\\mathcal{A}$ and $\\mathcal{B}$, one step introduces an error $O(\\Delta t^2)$ proportional to the commutator $[\\mathcal{A},\\mathcal{B}]$. For our rotation field with $\\mathcal{A} = -\\Omega y\\,\\partial_x$ and $\\mathcal{B} = \\Omega x\\,\\partial_y$, applying the commutator to a smooth $f$ gives\n$$\n[\\mathcal{A},\\mathcal{B}] f = \\mathcal{A}(\\mathcal{B}f) - \\mathcal{B}(\\mathcal{A}f) = \\Omega^2\\left(x\\,\\partial_x f - y\\,\\partial_y f\\right).\n$$\nEquivalently, performing a Taylor expansion of the exact and split departure mappings for small $\\Delta t$ reveals\n$$\nx_d^{\\mathrm{exact}} = x + \\Omega y\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3),\\qquad\ny_d^{\\mathrm{exact}} = y - \\Omega x\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3),\n$$\nwhile\n$$\nx_d^{\\mathrm{split}} = x + \\Omega y\\,\\Delta t,\\qquad\ny_d^{\\mathrm{split}} = y - \\Omega x\\,\\Delta t - \\Omega^2 y\\,\\Delta t^2.\n$$\nSubtracting yields\n$$\n\\delta x_d = x_d^{\\mathrm{split}} - x_d^{\\mathrm{exact}} = \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3), \\qquad\n\\delta y_d = y_d^{\\mathrm{split}} - y_d^{\\mathrm{exact}} = -\\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3).\n$$\nThe leading-order error in the scalar is then\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y) \\approx \\partial_x f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta x_d + \\partial_y f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta y_d,\n$$\nwhich, to $O(\\Delta t^2)$, aligns with the commutator result,\n$$\nE(x,y) \\approx \\tfrac{1}{2}\\Omega^2\\,\\Delta t^2\\left(x\\,\\partial_x f_0 - y\\,\\partial_y f_0\\right),\n$$\nevaluated at appropriately close points. This shows the dominant error is a directional derivative imbalance rather than a pure mixed derivative. However, on a rotated anisotropic Gaussian $f_0$, the spatial structure couples these imbalances into basis components that include the mixed derivative $\\partial^2 f_0/(\\partial x\\,\\partial y)$, leading to a measurable projection onto $D_{xy}$.\n\nTo quantify this spurious cross-derivative effect, we compute:\n1. The error field $E(x,y)$ as the difference between split and exact semi-Lagrangian updates, where updates are performed by evaluating the analytic $f_0$ at the respective departure points. This isolates splitting error from interpolation error.\n2. The $L^2$ and $L^\\infty$ norms of $E$, namely $\\|E\\|_2$ and $\\|E\\|_\\infty$.\n3. The periodic central-difference approximation to $D_{xy}(x,y)$ on the grid.\n4. The projection coefficient $C_{xy} = \\langle E,D_{xy}\\rangle/\\langle D_{xy},D_{xy}\\rangle$, and the fraction $R = |C_{xy}|\\,\\|D_{xy}\\|_2/\\|E\\|_2$.\n\nAlgorithmic design:\n- Construct a uniform grid with $N_x=N_y=128$ over $x,y\\in[-L/2,L/2)$, with $L=1$ and spacings $\\Delta x = \\Delta y = L/N_x$.\n- Define the rotated coordinates $x' = x\\cos\\alpha + y\\sin\\alpha$, $y' = -x\\sin\\alpha + y\\cos\\alpha$, and $f_0(x,y) = \\exp\\!\\left(-\\left[x'^2/\\sigma_1^2 + y'^2/\\sigma_2^2\\right]\\right)$.\n- For each test case with angular speed $\\Omega=2\\pi$ and given $\\Delta t$, compute $\\theta=\\Omega\\Delta t$ (in radians).\n- Compute the exact and split departure mappings via the formulas above to obtain $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ and $(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}})$.\n- Evaluate $f_0$ analytically at these departure points to get $f^{\\mathrm{exact}}$ and $f^{\\mathrm{split}}$ on the arrival grid; compute $E=f^{\\mathrm{split}}-f^{\\mathrm{exact}}$.\n- Compute $D_{xy}$ by periodic central differences:\n$$\nD_{xy}(i,j) \\approx \\frac{f_0(i+1,j+1)-f_0(i+1,j-1)-f_0(i-1,j+1)+f_0(i-1,j-1)}{4\\,\\Delta x\\,\\Delta y}.\n$$\n- Compute the discrete inner products with cell area $\\Delta x\\,\\Delta y$ to obtain $\\|E\\|_2$, $\\|E\\|_\\infty$, $C_{xy}$, and $R$ for each test case.\n\nTest suite coverage:\n- A small $\\Delta t$ case ($\\Delta t=1/64$) demonstrates the expected $O(\\Delta t^2)$ scaling of $\\|E\\|_2$ and typically small $R$.\n- A larger $\\Delta t$ case ($\\Delta t=1/8$) amplifies splitting error and cross-derivative projection, increasing $\\|E\\|_\\infty$ and $R$.\n- A symmetry edge case with $\\alpha=0$ and $\\sigma_1=\\sigma_2$ makes the initial condition rotationally symmetric; although $D_{xy}$ is not identically zero, the projection coefficient $C_{xy}$ and fraction $R$ are expected to be comparatively small due to symmetry.\n\nThe final program follows these steps and reports for each test case the four floats $\\|E\\|_2$, $\\|E\\|_\\infty$, $C_{xy}$, and $R$ in order, aggregated into a single bracketed, comma-separated list as required. All angles are handled in radians, $\\Omega$ is in radians per second, $\\Delta t$ is in seconds, and outputs are unitless floats.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotated_gaussian(x, y, sigma1, sigma2, alpha):\n    # Compute rotated coordinates\n    xp = x * np.cos(alpha) + y * np.sin(alpha)\n    yp = -x * np.sin(alpha) + y * np.cos(alpha)\n    return np.exp(-((xp / sigma1) ** 2 + (yp / sigma2) ** 2))\n\ndef exact_departure(x, y, theta):\n    # Backward characteristic for solid-body rotation: inverse of forward rotation\n    xd = x * np.cos(theta) + y * np.sin(theta)\n    yd = -x * np.sin(theta) + y * np.cos(theta)\n    return xd, yd\n\ndef split_departure_lie(x, y, omega, dt):\n    # Lie splitting: first x-advection then y-advection\n    x1 = x + omega * y * dt\n    y1 = y\n    yd = y1 - omega * x1 * dt\n    xd = x1\n    return xd, yd\n\ndef mixed_derivative_periodic(f, dx, dy):\n    # Central mixed derivative with periodic boundary conditions:\n    # Dxy ≈ (f(i+1,j+1) - f(i+1,j-1) - f(i-1,j+1) + f(i-1,j-1)) / (4 dx dy)\n    f_ip_jp = np.roll(np.roll(f, -1, axis=0), -1, axis=1)\n    f_ip_jm = np.roll(np.roll(f, -1, axis=0),  1, axis=1)\n    f_im_jp = np.roll(np.roll(f,  1, axis=0), -1, axis=1)\n    f_im_jm = np.roll(np.roll(f,  1, axis=0),  1, axis=1)\n    dxy = (f_ip_jp - f_ip_jm - f_im_jp + f_im_jm) / (4.0 * dx * dy)\n    return dxy\n\ndef inner_product(a, b, cell_area):\n    return np.sum(a * b) * cell_area\n\ndef l2_norm(a, cell_area):\n    return np.sqrt(np.sum(a * a) * cell_area)\n\ndef linf_norm(a):\n    return float(np.max(np.abs(a)))\n\ndef run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2):\n    # Grid\n    x = (np.arange(nx) - nx/2) * (L / nx)\n    y = (np.arange(ny) - ny/2) * (L / ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    dx = L / nx\n    dy = L / ny\n    cell_area = dx * dy\n\n    # Initial condition\n    f0 = rotated_gaussian(X, Y, sigma1, sigma2, alpha)\n\n    # Exact and split departures\n    theta = omega * dt\n    xd_exact, yd_exact = exact_departure(X, Y, theta)\n    xd_split, yd_split = split_departure_lie(X, Y, omega, dt)\n\n    # Evaluate f0 analytically at departure points\n    f_exact = rotated_gaussian(xd_exact, yd_exact, sigma1, sigma2, alpha)\n    f_split = rotated_gaussian(xd_split, yd_split, sigma1, sigma2, alpha)\n\n    # Error field\n    E = f_split - f_exact\n\n    # Mixed derivative of initial field at arrival grid\n    Dxy = mixed_derivative_periodic(f0, dx, dy)\n\n    # Norms and projections\n    E_l2 = l2_norm(E, cell_area)\n    E_linf = linf_norm(E)\n\n    denom = inner_product(Dxy, Dxy, cell_area)\n    if denom  0:\n        Cxy = inner_product(E, Dxy, cell_area) / denom\n        Dxy_l2 = l2_norm(Dxy, cell_area)\n        R = (abs(Cxy) * Dxy_l2 / E_l2) if E_l2  0 else 0.0\n    else:\n        Cxy = 0.0\n        R = 0.0\n\n    return float(E_l2), float(E_linf), float(Cxy), float(R)\n\ndef solve():\n    # Define constants for all test cases\n    nx = 128\n    ny = 128\n    L = 1.0\n    omega = 2.0 * np.pi  # radians per second\n\n    # Test suite: (dt, alpha, sigma1, sigma2)\n    test_cases = [\n        (1.0/64.0, np.pi/6.0, 0.15, 0.25),  # Happy path\n        (1.0/8.0,  np.pi/6.0, 0.15, 0.25),  # Larger time step\n        (1.0/8.0,  0.0,       0.20, 0.20),  # Symmetry edge case\n    ]\n\n    results = []\n    for dt, alpha, sigma1, sigma2 in test_cases:\n        E_l2, E_linf, Cxy, R = run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2)\n        results.extend([E_l2, E_linf, Cxy, R])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}