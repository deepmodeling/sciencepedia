{
    "hands_on_practices": [
        {
            "introduction": "An ideal numerical scheme should transport a tracer without distorting its shape. This practice explores the crucial property of monotonicity by examining how different interpolation methods handle sharp gradients, as seen in the classic \"top-hat\" test case . By implementing and comparing interpolation of varying orders, you will gain firsthand experience with the trade-off between formal accuracy and the generation of non-physical oscillations, a key challenge in tracer transport modeling.",
            "id": "3911345",
            "problem": "You are asked to design and implement a one-dimensional semi-Lagrangian advection test to assess monotonicity using a top-hat tracer, and to quantify the amplitude of spurious undershoots as a function of the Courant–Friedrichs–Lewy (CFL) number and interpolation order. The fundamental base you must use is the one-dimensional passive tracer advection equation and the definition of semi-Lagrangian transport.\n\nScenario and fundamentals:\n- Consider the one-dimensional passive tracer advection equation on a periodic domain of length $L$ in meters:\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\nwhere $c(x,t)$ is the tracer concentration (dimensionless), $u$ is the constant velocity in $\\mathrm{m/s}$, $x$ is the spatial coordinate in meters, and $t$ is time in seconds.\n- The semi-Lagrangian approach is based on the material derivative definition along trajectories, namely that the tracer is constant along trajectories for pure advection:\n$$\n\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0.\n$$\n- From this foundation, derive how to advance $c$ from time level $t^n$ to time level $t^{n+1} = t^n + \\Delta t$ at grid points $x_i$ by evaluating the previous-time tracer at the departure points. Your derivation must start from the above equations and core definitions without using or assuming any shortcut formulas.\n\nNumerical setup:\n- Use a uniform periodic grid with $N$ points, domain length $L = 1$ (meters), spatial step $\\Delta x = L/N$ (meters), velocity $u = 1$ (meters per second), and a single time step $\\Delta t$ (seconds) determined by the Courant–Friedrichs–Lewy number:\n$$\n\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}.\n$$\n- Initialize a top-hat tracer $c(x,0)$ with amplitude $1$ on an interval $[x_0, x_0+w)$ and $0$ elsewhere, with $x_0 = 0.33 L$ (meters) and $w = 0.20 L$ (meters). The tracer is dimensionless and strictly within $[0,1]$ initially.\n\nInterpolation and monotonicity assessment:\n- Implement three interpolation orders for evaluating the previous-time tracer at departure points:\n  1. Order $p=0$: nearest-neighbor interpolation.\n  2. Order $p=1$: linear interpolation.\n  3. Order $p=3$: cubic Lagrange interpolation using the four nearest grid values.\n- After one semi-Lagrangian time step, compute the amplitude of spurious undershoots, defined as\n$$\nA_{\\text{under}} = \\max\\left(0, -\\min_i c^{n+1}(x_i)\\right),\n$$\nwhich measures violations of the lower bound $0$. The amplitude is dimensionless (same unit as $c$). No angles are involved in this problem.\n\nAlgorithmic requirements:\n- Derive and implement the semi-Lagrangian update from first principles: compute the departure point for each grid point, then interpolate the previous-time tracer to that point using the chosen interpolation order, respecting periodic boundary conditions.\n- Ensure that the implementation is scientifically realistic and self-consistent. Use $N$ sufficiently large to resolve the top-hat and interpolation effects.\n\nTest suite:\n- Use $N = 2048$ (integer), $L = 1$ (meters), $u = 1$ (meters per second), and the top-hat parameters $x_0 = 0.33 L$ and $w = 0.20 L$.\n- For each test case, compute $\\Delta t$ from the specified $\\mathrm{CFL}$ via $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$ (seconds), perform exactly one semi-Lagrangian step, and return $A_{\\text{under}}$.\n- The test suite consists of the following $(p, \\mathrm{CFL})$ pairs:\n  1. $(0, 0.75)$,\n  2. $(1, 0.75)$,\n  3. $(3, 0.75)$,\n  4. $(3, 0.25)$,\n  5. $(3, 1.00)$,\n  6. $(3, 2.25)$,\n  7. $(3, 0.00)$,\n  8. $(1, 0.25)$,\n  9. $(0, 0.25)$.\n\nOutput specification:\n- Your program should produce a single line of output containing the nine amplitudes $A_{\\text{under}}$ for the above test cases as a comma-separated list enclosed in square brackets, in the same order as the test suite, with each amplitude rounded to six decimal places. For example:\n$$\n\\text{[0.000000,0.000000,0.012345,\\dots]}\n$$\nNo additional text should be printed.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It constitutes a standard numerical experiment for analyzing the properties of semi-Lagrangian advection schemes. We shall proceed with the derivation and solution.\n\n### Principle-Based Derivation of the Semi-Lagrangian Method\n\nThe one-dimensional passive tracer advection equation is given as:\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0\n$$\nwhere $c(x,t)$ is the tracer concentration, $u$ is a constant velocity, $x$ is the spatial coordinate, and $t$ is time. The expression on the left is the material derivative of the concentration $c$ along a trajectory $X(t)$ moving with the flow, defined as $\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x}$. The governing equation thus simplifies to:\n$$\n\\frac{D c}{D t} = 0\n$$\nThis equation states that the concentration $c$ is constant along the characteristic curves, which are the trajectories of fluid parcels. The characteristic curve $X(\\tau)$ is described by the ordinary differential equation:\n$$\n\\frac{\\mathrm{d}X(\\tau)}{\\mathrm{d}\\tau} = u\n$$\nTo find the concentration $c^{n+1}(x_i)$ at a grid point $x_i$ and time $t^{n+1} = t^n + \\Delta t$, we trace the characteristic curve backward in time from the arrival point $(x_i, t^{n+1})$ to find its departure point $(x_{d,i}, t^n)$ at the previous time level $t^n$. Since $u$ is constant, integrating the trajectory equation from $t^n$ to $t^{n+1}$ is straightforward:\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{\\mathrm{d}X}{\\mathrm{d}\\tau} \\mathrm{d}\\tau = \\int_{t^n}^{t^{n+1}} u \\mathrm{d}\\tau\n$$\n$$\nX(t^{n+1}) - X(t^n) = u (t^{n+1} - t^n)\n$$\nSubstituting $X(t^{n+1}) = x_i$ and the definition of the departure point $x_{d,i} = X(t^n)$, we get:\n$$\nx_i - x_{d,i} = u \\Delta t\n$$\nThis yields the location of the departure point:\n$$\nx_{d,i} = x_i - u \\Delta t\n$$\nThe principle $\\frac{Dc}{Dt}=0$ implies that the concentration is conserved along this path:\n$$\nc(x_i, t^{n+1}) = c(x_{d,i}, t^n)\n$$\nIn a numerical context, $c(x, t^n)$ is only known at discrete grid points $x_j$. The departure point $x_{d,i}$ will, in general, not coincide with any grid point. Therefore, to find the value $c(x_{d,i}, t^n)$, we must interpolate the gridded data from time $t^n$. Denoting the interpolation operator by $\\mathcal{I}$, the semi-Lagrangian update rule is:\n$$\nc_i^{n+1} = \\mathcal{I}[c^n](x_{d,i}) = \\mathcal{I}[c^n](x_i - u \\Delta t)\n$$\n\n### Numerical Implementation\n\nThe domain of length $L=1$ is discretized into $N$ grid cells, with grid spacing $\\Delta x = L/N$. The grid points are $x_i = i \\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$. The velocity is $u=1$. We can express the time step $\\Delta t$ in terms of the Courant–Friedrichs–Lewy (CFL) number: $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$. Substituting these into the departure point equation:\n$$\nx_{d,i} = x_i - u \\left(\\frac{\\mathrm{CFL} \\cdot \\Delta x}{u}\\right) = i\\Delta x - \\mathrm{CFL} \\cdot \\Delta x = (i - \\mathrm{CFL})\\Delta x\n$$\nThis shows that the departure point, measured in grid units, is located at the non-dimensional coordinate $\\alpha_i = i - \\mathrm{CFL}$. Due to the periodic domain of size $N$ grid cells, we use this coordinate modulo $N$: $\\alpha_{\\text{p},i} = \\alpha_i \\pmod N$.\n\nLet $j = \\lfloor \\alpha_{\\text{p},i} \\rfloor$ be the index of the last grid point before the departure point, and let $s = \\alpha_{\\text{p},i} - j$ be the fractional distance into the interval $[x_j, x_{j+1})$, where $s \\in [0, 1)$. The value $c_i^{n+1}$ is obtained by interpolating the values $c_k^n$ using the stencil of points around index $j$.\n\n### Interpolation Schemes and Monotonicity\n\nThe initial condition is a top-hat function with values in $[0, 1]$. A numerical scheme is monotone if it does not introduce new extrema. For this problem, a monotone scheme would ensure that $c_i^{n+1} \\in [0, 1]$, and thus the undershoot amplitude $A_{\\text{under}} = \\max(0, -\\min_i c_i^{n+1})$ would be zero.\n\n1.  **Order $p=0$ (Nearest-Neighbor)**: The value is taken from the nearest grid point. $c_i^{n+1} = c_{j+\\text{round}(s)}^n$. Since this only selects existing values from the initial data, it is monotone. We expect $A_{\\text{under}}=0$.\n\n2.  **Order $p=1$ (Linear Interpolation)**: The value is a weighted average of the two bracketing grid points.\n    $$\n    c_i^{n+1} = (1-s)c_j^n + s c_{j+1}^n\n    $$\n    As a convex combination of two values in $[0, 1]$, the result is also in $[0, 1]$. This scheme is monotone, and we expect $A_{\\text{under}}=0$.\n\n3.  **Order $p=3$ (Cubic Lagrange Interpolation)**: We use the four nearest grid points, forming a stencil $\\{j-1, j, j+1, j+2\\}$ to construct a cubic polynomial. All indices must be handled periodically, e.g., index $j-1$ becomes $(j-1) \\pmod N$. The interpolated value is:\n    $$\n    c_i^{n+1} = c_{j-1}^n \\mathcal{L}_{-1}(s) + c_{j}^n \\mathcal{L}_{0}(s) + c_{j+1}^n \\mathcal{L}_{1}(s) + c_{j+2}^n \\mathcal{L}_{2}(s)\n    $$\n    where $\\mathcal{L}_k(s)$ are the Lagrange basis polynomials evaluated at the normalized local coordinate $s \\in [0,1)$ corresponding to the stencil points at $\\{-1, 0, 1, 2\\}$:\n    $$\n    \\begin{aligned}\n    \\mathcal{L}_{-1}(s) = -\\frac{s(s-1)(s-2)}{6} \\\\\n    \\mathcal{L}_{0}(s) = \\frac{(s+1)(s-1)(s-2)}{2} \\\\\n    \\mathcal{L}_{1}(s) = -\\frac{(s+1)s(s-2)}{2} \\\\\n    \\mathcal{L}_{2}(s) = \\frac{(s+1)s(s-1)}{6}\n    \\end{aligned}\n    $$\n    This scheme is not generally monotone. The basis polynomials can take on negative values, meaning the interpolated value is not a convex combination. This can lead to spurious oscillations (undershoots and overshoots) near sharp gradients, so we may expect $A_{\\text{under}} > 0$ for non-integer CFL numbers. For integer CFL values, the departure point aligns with a grid point, $s=0$, interpolation becomes exact selection ($c_i^{n+1} = c_{i-\\mathrm{CFL}}^n$), and no undershoots are generated.\n\nThe algorithm proceeds by iterating through each test case $(p, \\mathrm{CFL})$, constructing the initial state $c^0$, computing the new state $c^1$ using the specified interpolation, and then calculating $A_{\\text{under}}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D semi-Lagrangian advection test for monotonicity.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    N = 2048\n    L = 1.0\n    u = 1.0\n    x0 = 0.33 * L\n    w = 0.20 * L\n    \n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # ------------------\n    # Initial Condition\n    # ------------------\n    c0 = np.zeros(N, dtype=np.float64)\n    # Define the top-hat tracer profile\n    # Use boolean indexing for clarity and efficiency\n    c0[(x = x0)  (x  (x0 + w))] = 1.0\n    \n    # ------------------\n    # Test Suite\n    # ------------------\n    test_cases = [\n        (0, 0.75),\n        (1, 0.75),\n        (3, 0.75),\n        (3, 0.25),\n        (3, 1.00),\n        (3, 2.25),\n        (3, 0.00),\n        (1, 0.25),\n        (0, 0.25),\n    ]\n    \n    results = []\n    \n    for p, cfl in test_cases:\n        # For CFL=0, there is no change, so no undershoot\n        if cfl == 0.0:\n            results.append(0.0)\n            continue\n            \n        c1 = np.zeros(N, dtype=np.float64)\n\n        for i in range(N):\n            # Calculate departure point in non-dimensional grid coordinates\n            alpha = float(i) - cfl\n            \n            # Apply periodic boundary conditions. Python's % operator handles\n            # negative numbers in a way that is suitable for this (e.g., -0.75 % N = N-0.75).\n            alpha_periodic = alpha % N\n            \n            j = int(np.floor(alpha_periodic))\n            s = alpha_periodic - j\n\n            # Perform interpolation based on order p\n            if p == 0:  # Nearest-neighbor\n                idx = (j + int(round(s))) % N\n                c1[i] = c0[idx]\n            \n            elif p == 1:  # Linear\n                j0 = j\n                j1 = (j + 1) % N\n                c1[i] = (1.0 - s) * c0[j0] + s * c0[j1]\n            \n            elif p == 3:  # Cubic Lagrange\n                # Stencil points are j-1, j, j+1, j+2\n                j_m1 = (j - 1) % N\n                j_0 = j\n                j_1 = (j + 1) % N\n                j_2 = (j + 2) % N\n                \n                # Get the concentrations at the stencil points\n                c_m1 = c0[j_m1]\n                c_0 = c0[j_0]\n                c_1 = c0[j_1]\n                c_2 = c0[j_2]\n                \n                # Evaluate the Lagrange basis polynomials at s\n                l_m1 = -s * (s - 1.0) * (s - 2.0) / 6.0\n                l_0  = (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n                l_1  = -(s + 1.0) * s * (s - 2.0) / 2.0\n                l_2  = (s + 1.0) * s * (s - 1.0) / 6.0\n                \n                c1[i] = l_m1 * c_m1 + l_0 * c_0 + l_1 * c_1 + l_2 * c_2\n        \n        # Calculate amplitude of spurious undershoots\n        min_c1 = np.min(c1)\n        a_under = max(0.0, -min_c1)\n        results.append(a_under)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond preserving shape, many models must strictly conserve physical quantities like mass or energy over long simulations. This exercise  contrasts a standard pointwise semi-Lagrangian scheme, which is generally not conservative, with a cell-averaged geometric remapping method designed to be conservative by construction. Through this comparison, you will learn a fundamental technique for ensuring that your numerical model respects the underlying conservation laws of the physical system.",
            "id": "3911296",
            "problem": "Consider the one-dimensional linear advection equation on a periodic domain, which is a canonical model for tracer transport in environmental and Earth system modeling: $$\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,$$ posed on the interval $$x \\in [0,1)$$ with periodic boundary conditions and a constant velocity $u$. The quantity $q(x,t)$ is dimensionless. The Semi-Lagrangian (SL) method advances the solution by following characteristics backward in time: at each grid location $x_i$, one identifies the departure point $x_d = x_i - u \\Delta t$ and evaluates the previous-time solution at $x_d$. In a discrete implementation, this requires interpolation of the field $q$ and, depending on the representation, also a remapping of cell averages over geometrically shifted intervals. In continuous form, the total mass $M(t) = \\int_0^1 q(x,t) \\, \\mathrm{d}x$ is exactly conserved under the advection equation. In discrete SL implementations, interpolation choices and geometric remapping choices determine whether discrete total mass is conserved and how mass error accumulates over multiple time steps.\n\nYour task is to construct a quantitative diagnostic for global mass error over multiple steps and compute it for different interpolation and geometric remapping choices in a purely mathematical and computational setting. Work on a uniform periodic grid with $N_x$ cells, cell width $\\Delta x = 1/N_x$, and either pointwise values located at cell centers $x_i = (i + 0.5)\\Delta x$ or cell averages associated with the interval $[i\\Delta x,(i+1)\\Delta x)$. For each method and initial condition, define the discrete total mass at step $n$ by $M^n = \\sum_{i=0}^{N_x-1} q_i^n \\, \\Delta x,$ where $q_i^n$ denotes either the pointwise value approximating the local average or the cell average itself, depending on the method. After propagating for $N_{\\text{steps}}$ steps with constant time step $\\Delta t$, diagnose the global mass error $E = M^{N_{\\text{steps}}} - M^0$ as a real number. All quantities are dimensionless; no physical units are required. Assume all arithmetic is performed in exact real arithmetic except for floating-point roundoff inherent to computations.\n\nImplement two SL update paradigms:\n- Pointwise SL with interpolation: use either linear interpolation or cubic interpolation to evaluate $q^n$ at the departure point $x_d = x_i - u \\Delta t$ for each cell center $x_i$, producing the next step $q^{n+1}$.\n- Conservative geometric remapping of cell averages: treat $q_i^n$ as cell averages and produce $q_i^{n+1}$ by averaging the previous field over the departure interval $[x_i - \\Delta x/2 - u \\Delta t, x_i + \\Delta x/2 - u \\Delta t]$, which lies on the previous grid due to periodicity. This remapping must be mass-conservative by construction at the discrete level.\n\nConstruct a program that, for the following test suite, computes the global mass error $E$ after the prescribed number of steps. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets.\n\nTest Suite:\n- Case 1 (happy path, smooth field, small Courant number, pointwise linear interpolation): $N_x = 128$, $\\Delta t = 1\\times 10^{-2}$, $u = 0.1$, $N_{\\text{steps}} = 100$, initial condition $q(x) = 1 + \\sin(2\\pi x)$, method: pointwise SL with linear interpolation.\n- Case 2 (smooth field, small Courant number, higher-order interpolation): same parameters as Case 1 but using cubic interpolation, method: pointwise SL with cubic interpolation.\n- Case 3 (nonsmooth field, small Courant number, interpolation-induced mass error stress test): $N_x = 128$, $\\Delta t = 1\\times 10^{-2}$, $u = 0.1$, $N_{\\text{steps}} = 100$, initial condition $q(x) = 1$ for $x \\in [0.25,0.75]$ and $q(x) = 0$ otherwise (interpreted periodically), method: pointwise SL with linear interpolation.\n- Case 4 (nonsmooth field, conservative geometric remapping): same parameters as Case 3 but method: conservative geometric remapping of cell averages.\n- Case 5 (large effective shift per step, conservative geometric remapping, periodic wrap-around stress test): $N_x = 128$, $\\Delta t = 0.1$, $u = 0.5$, $N_{\\text{steps}} = 25$, initial condition $q(x) = \\exp\\left(-\\left(\\frac{x - 0.3}{0.05}\\right)^2\\right)$, method: conservative geometric remapping of cell averages.\n\nYour program must produce the output in the exact format: a single line with the list $[E_1,E_2,E_3,E_4,E_5]$, where each $E_k$ is the computed global mass error for Case $k$ as a floating-point number.",
            "solution": "The problem requires the computation of the global mass error for several semi-Lagrangian (SL) advection schemes applied to the one-dimensional linear advection equation, $\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0$, on a periodic domain $x \\in [0,1)$. The total mass, $M(t) = \\int_0^1 q(x,t) \\, \\mathrm{d}x$, is an invariant of the continuous equation. We will investigate how well this property is preserved by different discrete numerical methods.\n\nFirst, we establish the discrete framework. The domain is discretized into $N_x$ uniform cells, each of width $\\Delta x = 1/N_x$. The quantity $q(x,t)$ is represented by a vector of discrete values $q^n$ at time step $n$. Two representations are considered:\n1.  **Pointwise values**: $q_i^n$ represents the value of the field at the cell center, $x_i = (i + 0.5)\\Delta x$ for $i=0, \\dots, N_x-1$. Thus, $q_i^n \\approx q(x_i, n\\Delta t)$.\n2.  **Cell averages**: $q_i^n$ represents the average value over cell $i$, which spans the interval $[i\\Delta x, (i+1)\\Delta x)$. Thus, $q_i^n = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x, n\\Delta t) \\, \\mathrm{d}x$.\n\nThe initial discrete field, $q^0$, is obtained by projecting the given continuous initial condition, $q(x,0)$, onto the grid.\n- For the pointwise representation, we sample the function at cell centers: $q_i^0 = q(x_i, 0)$.\n- For the cell-average representation, we compute the true cell average: $q_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x,0) \\, \\mathrm{d}x$. This integral is computed analytically for the box function and using the error function `erf` for the Gaussian profile, which is the analytical integral of a Gaussian.\n\nThe discrete total mass at time step $n$ is defined as $M^n = \\Delta x \\sum_{i=0}^{N_x-1} q_i^n$. The global mass error after $N_{\\text{steps}}$ is the difference between the final and initial discrete mass: $E = M^{N_{\\text{steps}}} - M^0$.\n\nWe now detail the semi-Lagrangian time-stepping algorithms. The core idea of the SL method is to trace characteristics backward in time. To find the value $q^{n+1}$ at an arrival point $x_a$, we find its departure point $x_d = x_a - u\\Delta t$ and set $q^{n+1}(x_a) = q^n(x_d)$.\n\n**1. Pointwise SL with Interpolation**\n\nIn this paradigm, we update the pointwise values at each cell center $x_i$. The new value $q_i^{n+1}$ is determined by interpolating the field $q^n$ at the departure point $x_d = x_i - u\\Delta t$.\nThe departure point $x_d$ will generally not coincide with a grid point. Its position relative to the grid is used to perform interpolation. We define a continuous-like grid coordinate $p(x) = (x / \\Delta x) - 0.5$, such that grid point $x_i$ corresponds to integer coordinate $i$. The departure position for $x_i$ is $p_d = ((x_i - u\\Delta t) \\pmod{1}) / \\Delta x - 0.5$. Let $j = \\lfloor p_d \\rfloor$ be the integer part and $f = p_d - j$ be the fractional part, where $0 \\le f  1$.\n\n-   **Linear Interpolation**: We use the two nearest grid points, $j$ and $j+1$, to form a linear interpolant. The indices are handled periodically.\n    $$q_i^{n+1} = (1-f) q_{j \\pmod{N_x}}^n + f q_{(j+1) \\pmod{N_x}}^n$$\n    This method is simple and computationally efficient but is not inherently mass-conservative. The sum of interpolated values is not guaranteed to equal the sum of the original values.\n\n-   **Cubic Interpolation**: A higher-order, more accurate interpolation can be achieved using four grid points. We use the Lagrange form for a polynomial passing through the points $(j-1, q_{j-1}^n)$, $(j, q_j^n)$, $(j+1, q_{j+1}^n)$, and $(j+2, q_{j+2}^n)$. Evaluating this polynomial at the fractional position $f$ (relative to grid point $j$) gives:\n    $$q_i^{n+1} = L(f) = \\sum_{m=-1}^{2} q_{j+m}^n \\prod_{k=-1, k\\ne m}^{2} \\frac{f-k}{m-k}$$\n    Explicitly, this is:\n    $$q_i^{n+1} = q_{j-1}^n \\frac{f(f-1)(f-2)}{-6} + q_j^n \\frac{(f+1)(f-1)(f-2)}{2} + q_{j+1}^n \\frac{(f+1)f(f-2)}{-2} + q_{j+2}^n \\frac{(f+1)f(f-1)}{6}$$\n    All indices are periodic. Like linear interpolation, this method is not guaranteed to conserve mass.\n\n**2. Conservative Geometric Remapping**\n\nThis method is designed to be discretely mass-conservative. The field $q^n$ is interpreted as a piecewise constant function, where its value is $q_i^n$ over the cell $[i\\Delta x, (i+1)\\Delta x)$. The new cell average $q_i^{n+1}$ is found by calculating the average of $q^n$ over the departure region for cell $i$. This region is the interval $[i\\Delta x, (i+1)\\Delta x)$ shifted backward in time, i.e., $[i\\Delta x - u\\Delta t, (i+1)\\Delta x - u\\Delta t)$.\nThe new cell average is:\n$$q_i^{n+1} = \\frac{1}{\\Delta x} \\int_{i\\Delta x - u\\Delta t}^{(i+1)\\Delta x - u\\Delta t} q^n(x') \\, \\mathrm{d}x'$$\nLet $\\alpha = u\\Delta t / \\Delta x$ be the displacement in grid cell units. Let $k = \\lfloor \\alpha \\rfloor$ and $\\delta = \\alpha - k$. The departure interval for cell $i$ is $[(i-k-\\delta)\\Delta x, (i-k-\\delta+1)\\Delta x)$. Since $q^n$ is piecewise constant, the integral is a sum over the segments of this interval that overlap with the cells of the old grid. This calculation yields a simple-looking but powerful update rule:\n$$q_i^{n+1} = (1-\\delta) q_{(i-k) \\pmod{N_x}}^n + \\delta q_{(i-k-1) \\pmod{N_x}}^n$$\nThis scheme is conservative by construction. To verify, we sum over all cells:\n$$M^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} q_i^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} \\left( (1-\\delta) q_{i-k}^n + \\delta q_{i-k-1}^n \\right)$$\nBy re-indexing the sums (which is valid due to periodicity), we get:\n$$M^{n+1} = \\Delta x \\left( (1-\\delta) \\sum_{j=0}^{N_x-1} q_j^n + \\delta \\sum_{j=0}^{N_x-1} q_j^n \\right) = (1-\\delta) M^n + \\delta M^n = M^n$$\nThus, the discrete mass is exactly conserved at each time step. Any computed error $E$ for this method should be attributable solely to floating-point roundoff error.\n\nThe provided Python code implements these algorithms to compute the mass error for each specified test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef initialize_q(Nx, ic_name, method):\n    \"\"\"\n    Initializes the discrete field q0 based on the initial condition function\n    and the representation (pointwise or cell-average).\n    \"\"\"\n    dx = 1.0 / Nx\n    if method.startswith('pointwise'):\n        x = (np.arange(Nx) + 0.5) * dx\n        if ic_name == 'sin':\n            return 1.0 + np.sin(2 * np.pi * x)\n        elif ic_name == 'box':\n            return np.where((x = 0.25)  (x  0.75), 1.0, 0.0)\n    elif method.startswith('conservative'):\n        q0 = np.zeros(Nx)\n        if ic_name == 'box':\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                overlap = max(0.0, min(x_right, 0.75) - max(x_left, 0.25))\n                q0[i] = overlap / dx\n            return q0\n        elif ic_name == 'gauss':\n            mu, sigma = 0.3, 0.05\n            # Use the analytical integral of a Gaussian, which involves the error function (erf)\n            # ∫ exp(-((x-μ)/σ)²) dx = σ * sqrt(π)/2 * erf((x-μ)/σ)\n            sqrt_pi_half_sigma = sigma * np.sqrt(np.pi) / 2.0\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                integral = sqrt_pi_half_sigma * (erf((x_right - mu) / sigma) - erf((x_left - mu) / sigma))\n                q0[i] = integral / dx\n            return q0\n    return None\n\ndef advect_step(q, Nx, dx, u, dt, method):\n    \"\"\"\n    Performs a single time step of semi-Lagrangian advection.\n    \"\"\"\n    if method == 'pointwise_linear':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        # Calculate fractional grid positions for departure points\n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        f = p - j\n        \n        # Use np.take for efficient periodic boundary handling\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        \n        return (1.0 - f) * q_j + f * q_j1\n\n    elif method == 'pointwise_cubic':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        s = p - j  # Fractional part for Lagrange formula\n        \n        q_jm1 = np.take(q, j - 1, mode='wrap')\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        q_j2 = np.take(q, j + 2, mode='wrap')\n        \n        # 4-point Lagrange interpolation formula\n        term_m1 = q_jm1 * s * (s - 1.0) * (s - 2.0) / -6.0\n        term_0 = q_j * (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n        term_1 = q_j1 * (s + 1.0) * s * (s - 2.0) / -2.0\n        term_2 = q_j2 * (s + 1.0) * s * (s - 1.0) / 6.0\n        \n        return term_m1 + term_0 + term_1 + term_2\n\n    elif method == 'conservative_remapping':\n        alpha = u * dt / dx  # Displacement in grid cell units\n        k = np.floor(alpha).astype(int)\n        delta = alpha - k\n        \n        # Update rule derived from geometric remapping of cell averages\n        # q_new[i] = (1-delta)*q[i-k] + delta*q[i-(k+1)]\n        # This is vectorized using np.roll for periodic shifts\n        q_new = (1.0 - delta) * np.roll(q, k) + delta * np.roll(q, k + 1)\n        return q_new\n\n    else:\n        raise ValueError(f\"Unknown method: {method}\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute global mass errors.\n    \"\"\"\n    test_cases = [\n        # (Nx, dt, u, N_steps, ic_name, method)\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_cubic'),\n        (128, 1e-2, 0.1, 100, 'box', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'box', 'conservative_remapping'),\n        (128, 0.1, 0.5, 25, 'gauss', 'conservative_remapping'),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, dt, u, N_steps, ic_name, method = case\n        \n        dx = 1.0 / Nx\n        \n        # 1. Initialize the field q\n        q0 = initialize_q(Nx, ic_name, method)\n        \n        # 2. Compute initial mass\n        M0 = np.sum(q0) * dx\n        \n        # 3. Time-step the solution\n        q = q0.copy()\n        for _ in range(N_steps):\n            q = advect_step(q, Nx, dx, u, dt, method)\n            \n        # 4. Compute final mass and error\n        M_final = np.sum(q) * dx\n        error = M_final - M0\n        results.append(error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from one to two dimensions introduces new complexities, and a common artifact in semi-Lagrangian schemes is numerical diffusion, which artificially smooths the solution. This practice investigates this dissipative error within a 2D shear flow, a common feature in geophysical fluids . You will quantify the diffusion introduced by linear interpolation and observe how the scheme's unconditional stability allows for accurate solutions even at Courant numbers far exceeding one.",
            "id": "3911375",
            "problem": "Consider the linear advection of a passive scalar $\\phi(x,y,t)$ in a two-dimensional periodic domain with coordinates $x \\in [0,L_x]$ and $y \\in [0,L_y]$ and constant shear flow $\\boldsymbol{u}(x,y) = (Sy, 0)$, where $S$ is a constant shear rate. The scalar obeys the advection equation $\\partial_t \\phi + \\boldsymbol{u}\\cdot\\nabla \\phi = 0$. In a Semi-Lagrangian method, the update at time $t^{n+1} = t^n + \\Delta t$ at an Eulerian grid point $\\boldsymbol{x}_{i,j} = (x_i, y_j)$ is obtained by tracing characteristics backward in time to a departure point $\\boldsymbol{x}_d = (x_d, y_d)$ that satisfies $\\boldsymbol{x}_d = \\boldsymbol{x}_{i,j} - \\int_{t^n}^{t^{n+1}} \\boldsymbol{u}(\\boldsymbol{x}(s),s)\\,\\mathrm{d}s$ and then interpolating $\\phi^n$ at $\\boldsymbol{x}_d$.\n\nStarting from the fundamental kinematic relation $\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t} = \\boldsymbol{u}(\\boldsymbol{x},t)$, and using $\\boldsymbol{u}(x,y) = (S y, 0)$ with $S$ constant in time, derive the exact departure-point mapping for one time step $\\Delta t$. Implement a one-step Semi-Lagrangian update using piecewise-linear interpolation in the $x$-direction with periodic boundary conditions, and quantify interpolation-induced diffusion.\n\nAll quantities are non-dimensional. Use $L_x = 1$, $L_y = 1$, $S = 1$, a uniform grid with $N_x$ points in $x$ and $N_y$ points in $y$, with grid spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. Initialize the scalar field at $t^n$ as $\\phi^n(x,y) = \\sin(2\\pi m x)$ with an integer mode $m$. For a given nominal Courant–Friedrichs–Lewy (CFL) number $C$ defined by $C = \\max_{(x,y)} \\left( |u_x(x,y)| \\Delta t / \\Delta x \\right) = S y_{\\max} \\Delta t/\\Delta x$ with $y_{\\max} = L_y$, set $\\Delta t = C \\Delta x/S$.\n\nFor each specified $C$ value, perform one Semi-Lagrangian time step:\n- Compute the exact departure points $x_d = x_i - Sy_j \\Delta t$ and $y_d = y_j$.\n- Compute the exact advected field $\\phi^{\\mathrm{exact}}(x_i,y_j) = \\sin\\big(2\\pi m (x_i - Sy_j \\Delta t)\\big)$.\n- Compute the Semi-Lagrangian field $\\phi^{\\mathrm{SL}}(x_i,y_j)$ by linearly interpolating $\\phi^n$ at $x_d$ for each fixed $y_j$ using periodic boundary conditions in $x$.\n- Evaluate the interpolation-induced diffusion by the amplitude ratio $R = \\|\\phi^{\\mathrm{SL}}\\|_2 / \\|\\phi^{\\mathrm{exact}}\\|_2$, where $\\|\\cdot\\|_2$ is the discrete two-dimensional Euclidean norm over the grid.\n- Also compute the maximum grid-cell departure distance $D = \\max_{i,j} \\big(|x_i - x_d|/\\Delta x\\big)$, which measures the largest characteristic displacement in units of grid cells.\n\nTest suite and parameters:\n- Use $N_x = 128$, $N_y = 16$, and $m = 5$.\n- Evaluate four nominal CFL numbers $C \\in \\{0.8, 1.0, 3.5, 16.0\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[R(C{=}0.8),D(C{=}0.8),R(C{=}1.0),D(C{=}1.0),R(C{=}3.5),D(C{=}3.5),R(C{=}16.0),D(C{=}16.0)]$. All outputs are non-dimensional floats. No physical units are required, and angles are in radians by construction of the sinusoidal initial condition. The results must be reproducible without any external input.",
            "solution": "The problem statement is assessed to be **valid**. It is scientifically grounded in the principles of fluid dynamics and numerical analysis, specifically concerning the advection equation and semi-Lagrangian schemes. The problem is well-posed, providing a complete and consistent set of parameters, initial conditions, and numerical procedures. All terms are defined objectively and mathematically, allowing for a unique and verifiable solution.\n\nThe solution proceeds in two parts: first, the analytical derivation of the characteristic-based departure point mapping, and second, the design of the numerical algorithm to compute the semi-Lagrangian update and evaluate the specified metrics.\n\n**1. Derivation of the Departure Point Mapping**\n\nThe semi-Lagrangian method relies on tracing fluid parcel trajectories, or characteristics, backward in time. The trajectory $\\boldsymbol{x}(t)$ of a parcel is governed by the kinematic ordinary differential equation (ODE) system:\n$$\n\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t} = \\boldsymbol{u}(\\boldsymbol{x}, t)\n$$\nGiven the two-dimensional, time-independent shear flow $\\boldsymbol{u}(x,y) = (Sy, 0)$, the component-wise ODEs are:\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = Sy\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = 0\n$$\nWe seek the departure point $\\boldsymbol{x}_d = (x_d, y_d)$ at time $t^n$ that arrives at the Eulerian grid point $\\boldsymbol{x}_{i,j} = (x_i, y_j)$ at time $t^{n+1}$. This involves integrating the ODE system backward over a single time step $\\Delta t = t^{n+1} - t^n$.\n\nIntegrating the $y$-component equation from $t^{n+1}$ back to $t^n$:\n$$\n\\int_{y(t^{n+1})}^{y(t^n)} \\mathrm{d}y = \\int_{t^{n+1}}^{t^n} 0\\,\\mathrm{d}t \\implies y(t^n) - y(t^{n+1}) = 0\n$$\nSubstituting the arrival and departure coordinates, we have $y_d - y_j = 0$, which gives:\n$$\ny_d = y_j\n$$\nThis result indicates that the characteristics are straight horizontal lines; the $y$-coordinate of a fluid parcel remains constant in this flow.\n\nNow, we integrate the $x$-component equation. The formal solution for $x(t^n)$ is:\n$$\nx(t^n) = x(t^{n+1}) - \\int_{t^n}^{t^{n+1}} u_x(\\boldsymbol{x}(s))\\,\\mathrm{d}s\n$$\nSubstituting $u_x = Sy$ and the fact that $y(s) = y_j$ is constant along the characteristic path for a parcel arriving at $y_j$:\n$$\nx_d = x_i - \\int_{t^n}^{t^{n+1}} S y_j\\,\\mathrm{d}s\n$$\nSince $S$ and $y_j$ are constant with respect to the integration variable $s$, we can extract them from the integral:\n$$\nx_d = x_i - S y_j \\int_{t^n}^{t^{n+1}} \\mathrm{d}s = x_i - S y_j (t^{n+1} - t^n)\n$$\nUsing the definition $\\Delta t = t^{n+1} - t^n$, we obtain the departure point's $x$-coordinate:\n$$\nx_d = x_i - S y_j \\Delta t\n$$\nThus, the exact departure-point mapping for a single time step is $(x_d, y_d) = (x_i - S y_j \\Delta t, y_j)$, which confirms the expression provided in the problem statement.\n\n**2. Numerical Algorithm and Analysis**\n\nThe semi-Lagrangian update states that the advected scalar is conserved along characteristics, so $\\phi(\\boldsymbol{x}_{i,j}, t^{n+1}) = \\phi(\\boldsymbol{x}_d, t^n)$. We implement a one-step update based on this principle.\n\n**Grid and Parameters:**\n- Domain: $x \\in [0, L_x]$, $y \\in [0, L_y]$ with $L_x = 1$, $L_y = 1$.\n- Grid: $N_x = 128$, $N_y = 16$. The grid coordinates are $x_i = i \\cdot (L_x/N_x)$ for $i=0, \\dots, N_x-1$, and $y_j = j \\cdot (L_y/N_y)$ for $j=0, \\dots, N_y-1$.\n- Shear rate: $S=1$.\n- Initial condition: $\\phi^n(x,y) = \\sin(2\\pi m x)$ with mode number $m=5$. This field is independent of $y$.\n- Time step: $\\Delta t = C \\Delta x/S$ since $y_{\\max}$ for the CFL definition is taken as $L_y = 1$. With $S=1$, this is $\\Delta t = C \\Delta x$.\n\n**Exact Advected Field:**\nThe true solution at time $t^{n+1}$ is the initial condition evaluated at the departure point:\n$$\n\\phi^{\\mathrm{exact}}(x_i, y_j) = \\phi^n(x_d, y_d) = \\sin(2\\pi m x_d) = \\sin\\big(2\\pi m (x_i - S y_j \\Delta t)\\big)\n$$\n\n**Semi-Lagrangian Field with Linear Interpolation:**\nThe numerical solution, $\\phi^{\\mathrm{SL}}$, is computed by interpolating the values of the known field $\\phi^n$ at the departure coordinates $(x_d, y_d)$. Since $\\phi^n$ is a function of $x$ only, and $y_d = y_j$, this reduces to a one-dimensional interpolation of the function $f(x) = \\sin(2\\pi m x)$ at the coordinate $x_d$ for each grid row $j$.\n\nThe interpolation process for a single point $(x_i, y_j)$ is as follows:\n1.  Compute the departure $x$-coordinate: $x_d = x_i - S y_j \\Delta t$.\n2.  Apply periodic boundary conditions by mapping $x_d$ into the domain $[0, L_x)$: $x'_d = x_d \\pmod{L_x}$.\n3.  Normalize the coordinate to grid-spacing units: $\\xi = x'_d / \\Delta x$.\n4.  Identify the bounding grid indices and the interpolation weight. The lower index is $k_1 = \\lfloor \\xi \\rfloor$. The upper index, accounting for periodicity, is $k_2 = (k_1 + 1) \\pmod{N_x}$. The fractional part is the weight $\\alpha = \\xi - k_1$.\n5.  Perform the linear interpolation:\n    $$\n    \\phi^{\\mathrm{SL}}(x_i, y_j) = (1-\\alpha)\\phi^n(x_{k_1}) + \\alpha\\phi^n(x_{k_2})\n    $$\nThis procedure is applied to all grid points $(x_i, y_j)$.\n\n**Quantification of Numerical Error:**\nLinear interpolation is not perfect and introduces numerical errors, primarily in the form of numerical diffusion (dissipation), which damps the amplitude of waves.\n-   **Amplitude Ratio ($R$):** This is measured by the ratio of the discrete L2-norms of the numerical and exact solutions:\n    $$\n    R = \\frac{\\|\\phi^{\\mathrm{SL}}\\|_2}{\\|\\phi^{\\mathrm{exact}}\\|_2} \\quad \\text{where} \\quad \\|\\boldsymbol{A}\\|_2 = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} A_{i,j}^2}\n    $$\n    A value of $R  1$ indicates dissipative error.\n-   **Maximum Departure Distance ($D$):** This measures the largest advection distance in units of grid cells over one time step.\n    $$\n    D = \\max_{i,j} \\frac{|x_i - x_d|}{\\Delta x} = \\max_{i,j} \\frac{|x_i - (x_i - S y_j \\Delta t)|}{\\Delta x} = \\frac{S \\Delta t}{\\Delta x} \\max_j(y_j)\n    $$\n    Substituting $\\Delta t=C\\Delta x/S$ and $\\max_j(y_j) = (N_y-1)\\Delta y = (N_y-1)/N_y$, we get $D = C (N_y-1)/N_y$.\n\nThe algorithm is executed for each CFL number $C \\in \\{0.8, 1.0, 3.5, 16.0\\}$, and the resulting $(R, D)$ pairs are computed and reported.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the semi-Lagrangian advection for a sinusoidal scalar field in a\n    2D shear flow, and evaluates numerical diffusion and departure distance.\n    \"\"\"\n    # Define the test cases and parameters from the problem statement.\n    test_cases = [0.8, 1.0, 3.5, 16.0] # Nominal CFL numbers\n    \n    # Physical and numerical parameters\n    Lx = 1.0        # Domain length in x\n    Ly = 1.0        # Domain length in y\n    S = 1.0         # Shear rate\n    Nx = 128        # Number of grid points in x\n    Ny = 16         # Number of grid points in y\n    m = 5           # Wavenumber of initial condition\n\n    # Grid setup\n    dx = Lx / Nx\n    dy = Ly / Ny\n    x = np.arange(Nx) * dx\n    y = np.arange(Ny) * dy\n    xx, yy = np.meshgrid(x, y) # 'xy' indexing: xx shape (Ny, Nx), yy shape (Ny, Nx)\n\n    # Initial condition at time t^n\n    # The field is independent of y, so we only need the 1D profile for interpolation.\n    phi_n_1d = np.sin(2 * np.pi * m * x)\n\n    results = []\n    for C in test_cases:\n        # Calculate time step based on the nominal CFL number\n        dt = C * dx / S\n\n        # 1. Compute exact departure points (xd, yd) for all grid points (xx, yy)\n        # For shear flow u=(S*y, 0), the mapping is (x - S*y*dt, y)\n        xd = xx - S * yy * dt\n        # yd is implicitly yy, which is not needed as the field is y-independent.\n\n        # 2. Compute the exact advected field at t^{n+1}\n        # This is simply the initial condition evaluated at the departure points.\n        phi_exact = np.sin(2 * np.pi * m * xd)\n\n        # 3. Compute the Semi-Lagrangian field at t^{n+1} via interpolation\n        \n        # Map departure x-coordinates to the periodic domain [0, Lx)\n        xd_periodic = xd % Lx\n        \n        # Convert to grid-index units\n        xi = xd_periodic / dx\n        \n        # Find the bounding integer grid indices for linear interpolation\n        k1 = np.floor(xi).astype(int)\n        k2 = (k1 + 1) % Nx  # Handle periodicity at the domain edge\n        \n        # Calculate the interpolation weight (fractional part of the index)\n        alpha = xi - k1\n        \n        # Perform 1D linear interpolation for the entire 2D grid using numpy's\n        # advanced indexing. phi_n_1d is indexed by the 2D arrays k1 and k2.\n        phi_k1_vals = phi_n_1d[k1]\n        phi_k2_vals = phi_n_1d[k2]\n        \n        phi_sl = (1.0 - alpha) * phi_k1_vals + alpha * phi_k2_vals\n\n        # 4. Evaluate the metrics R and D\n\n        # Metric R: Amplitude ratio from discrete L2 norms\n        # np.linalg.norm for a 2D array computes the Frobenius norm, which is the\n        # required discrete L2 norm sqrt(sum of squares).\n        norm_sl = np.linalg.norm(phi_sl)\n        norm_exact = np.linalg.norm(phi_exact)\n        R = norm_sl / norm_exact\n        \n        # Metric D: Maximum grid-cell departure distance in x\n        # |x_i - x_d| = |S*y_j*dt|. We want the maximum over all j, divided by dx.\n        max_departure_physical = np.max(S * yy * dt)\n        D = max_departure_physical / dx\n\n        results.extend([R, D])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}