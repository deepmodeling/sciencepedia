{
    "hands_on_practices": [
        {
            "introduction": "半拉格朗日方法的核心在于插值，但不同的插值方案会带来不同的数值特性。本实践将通过一个经典的一维“方帽”廓线平流问题，引导您探索插值阶数与单调性之间的重要关系。您将亲手实现并对比不同阶数的插值方法，量化高阶格式在尖锐梯度附近产生的非物理振荡（或称“下冲”），从而深刻理解数值精度与物理真实性之间的权衡。",
            "id": "3911345",
            "problem": "要求您设计并实现一个一维半拉格朗日平流测试，以使用帽形示踪剂评估单调性，并量化伪下冲的振幅作为 Courant-Friedrichs-Lewy (CFL) 数和插值阶数的函数。您必须使用的基本依据是一维被动示踪剂平流方程和半拉格朗日输运的定义。\n\n情景与基本原理：\n- 考虑在一个长度为 $L$ 米的周期性域上的一维被动示踪剂平流方程：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\n其中 $c(x,t)$ 是示踪剂浓度（无量纲），$u$ 是恒定速度，单位为 $\\mathrm{m/s}$，$x$ 是空间坐标，单位为米，$t$ 是时间，单位为秒。\n- 半拉格朗日方法基于沿轨迹线的物质导数定义，即对于纯平流，示踪剂沿轨迹线是恒定的：\n$$\n\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0.\n$$\n- 基于此基础，通过计算出发点处前一时刻的示踪剂值，推导如何在网格点 $x_i$ 处将 $c$ 从时间层 $t^n$ 推进到时间层 $t^{n+1} = t^n + \\Delta t$。您的推导必须从上述方程和核心定义开始，不得使用或假设任何快捷公式。\n\n数值设置：\n- 使用一个具有 $N$ 个点的均匀周期性网格，域长度 $L = 1$（米），空间步长 $\\Delta x = L/N$（米），速度 $u = 1$（米/秒），以及由 Courant-Friedrichs-Lewy 数决定的单个时间步长 $\\Delta t$（秒）：\n$$\n\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}.\n$$\n- 初始化一个帽形示踪剂 $c(x,0)$，其在区间 $[x_0, x_0+w)$ 上的振幅为 $1$，在其他地方为 $0$，其中 $x_0 = 0.33 L$（米），$w = 0.20 L$（米）。示踪剂是无量纲的，初始时严格在 $[0,1]$ 范围内。\n\n插值与单调性评估：\n- 为计算出发点处的前一时刻示踪剂，实现三种插值阶数：\n  1. 阶数 $p=0$：最近邻插值。\n  2. 阶数 $p=1$：线性插值。\n  3. 阶数 $p=3$：使用四个最近的网格值进行三次拉格朗日插值。\n- 在一个半拉格朗日时间步后，计算伪下冲的振幅，定义为\n$$\nA_{\\text{under}} = \\max\\left(0, -\\min_i c^{n+1}(x_i)\\right),\n$$\n它衡量了对下界 $0$ 的违反程度。振幅是无量纲的（与 $c$ 的单位相同）。本问题不涉及角度。\n\n算法要求：\n- 从第一性原理推导并实现半拉格朗日更新：为每个网格点计算出发点，然后使用所选的插值阶数在该点对前一时刻的示踪剂进行插值，并遵守周期性边界条件。\n- 确保实现是科学上现实且自洽的。使用足够大的 $N$ 以解析帽形函数和插值效应。\n\n测试套件：\n- 使用 $N = 2048$（整数），$L = 1$（米），$u = 1$（米/秒），以及帽形参数 $x_0 = 0.33 L$ 和 $w = 0.20 L$。\n- 对于每个测试用例，通过 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$（秒）从指定的 $\\mathrm{CFL}$ 计算 $\\Delta t$，执行恰好一个半拉格朗日步长，并返回 $A_{\\text{under}}$。\n- 测试套件由以下 $(p, \\mathrm{CFL})$ 对组成：\n  1. $(0, 0.75)$,\n  2. $(1, 0.75)$,\n  3. $(3, 0.75)$,\n  4. $(3, 0.25)$,\n  5. $(3, 1.00)$,\n  6. $(3, 2.25)$,\n  7. $(3, 0.00)$,\n  8. $(1, 0.25)$,\n  9. $(0, 0.25)$.\n\n输出规范：\n- 您的程序应生成单行输出，其中包含上述测试用例的九个振幅 $A_{\\text{under}}$，格式为方括号内由逗号分隔的列表，顺序与测试套件相同，每个振幅四舍五入到小数点后六位。例如：\n$$\n\\text{[0.000000,0.000000,0.012345,\\dots]}\n$$\n不应打印任何额外文本。",
            "solution": "该问题被验证为具有科学依据、适定且客观。它构成了分析半拉格朗日平流方案性质的标准数值实验。我们将继续进行推导和求解。\n\n### 基于原理的半拉格朗日方法推导\n\n一维被动示踪剂平流方程为：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0\n$$\n其中 $c(x,t)$ 是示踪剂浓度，$u$ 是恒定速度，$x$ 是空间坐标，$t$ 是时间。左侧的表达式是浓度 $c$ 沿随流运动的轨迹 $X(t)$ 的物质导数，定义为 $\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x}$。因此，控制方程简化为：\n$$\n\\frac{D c}{D t} = 0\n$$\n该方程表明浓度 $c$ 沿着特征线是恒定的，特征线即流体质点的轨迹。特征线 $X(\\tau)$ 由以下常微分方程描述：\n$$\n\\frac{dX(\\tau)}{d\\tau} = u\n$$\n为了求出网格点 $x_i$ 在时间 $t^{n+1} = t^n + \\Delta t$ 时的浓度 $c^{n+1}(x_i)$，我们从到达点 $(x_i, t^{n+1})$ 沿特征线向后追溯，以找到其在上一时间层 $t^n$ 的出发点 $(x_{d,i}, t^n)$。由于 $u$ 是常数，从 $t^n$ 到 $t^{n+1}$ 积分轨迹方程非常直接：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dX}{d\\tau} d\\tau = \\int_{t^n}^{t^{n+1}} u d\\tau\n$$\n$$\nX(t^{n+1}) - X(t^n) = u (t^{n+1} - t^n)\n$$\n代入 $X(t^{n+1}) = x_i$ 和出发点定义 $x_{d,i} = X(t^n)$，我们得到：\n$$\nx_i - x_{d,i} = u \\Delta t\n$$\n这给出了出发点的位置：\n$$\nx_{d,i} = x_i - u \\Delta t\n$$\n原理 $\\frac{Dc}{Dt}=0$ 意味着浓度沿此路径守恒：\n$$\nc(x_i, t^{n+1}) = c(x_{d,i}, t^n)\n$$\n在数值计算的背景下，$c(x, t^n)$ 仅在离散的网格点 $x_j$ 上已知。通常情况下，出发点 $x_{d,i}$ 不会与任何网格点重合。因此，为了找到 $c(x_{d,i}, t^n)$ 的值，我们必须对时间 $t^n$ 的网格数据进行插值。将插值算子表示为 $\\mathcal{I}$，半拉格朗日更新规则为：\n$$\nc_i^{n+1} = \\mathcal{I}[c^n](x_{d,i}) = \\mathcal{I}[c^n](x_i - u \\Delta t)\n$$\n\n### 数值实现\n\n长度为 $L=1$ 的域被离散为 $N$ 个网格单元，网格间距为 $\\Delta x = L/N$。网格点为 $x_i = i \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。速度为 $u=1$。我们可以用库朗-弗里德里希-列维 (CFL) 数来表示时间步长：$\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$。将这些代入出发点方程：\n$$\nx_{d,i} = x_i - u \\left(\\frac{\\mathrm{CFL} \\cdot \\Delta x}{u}\\right) = i\\Delta x - \\mathrm{CFL} \\cdot \\Delta x = (i - \\mathrm{CFL})\\Delta x\n$$\n这表明，以网格单位衡量，出发点位于无量纲坐标 $\\alpha_i = i - \\mathrm{CFL}$ 处。由于域是周期性的，大小为 $N$ 个网格单元，我们使用此坐标对 $N$ 取模：$\\alpha_{\\text{p},i} = \\alpha_i \\pmod N$。\n\n令 $j = \\lfloor \\alpha_{\\text{p},i} \\rfloor$ 为出发点前最后一个网格点的索引，令 $s = \\alpha_{\\text{p},i} - j$ 为进入区间 $[x_j, x_{j+1})$ 的小数部分距离，其中 $s \\in [0, 1)$。值 $c_i^{n+1}$ 是通过使用索引 $j$ 周围的点构成的模板对 $c_k^n$ 的值进行插值得到的。\n\n### 插值方案与单调性\n\n初始条件是一个值在 $[0, 1]$ 内的帽形函数。如果一个数值方案不引入新的极值，则它是单调的。对于本问题，单调方案将确保 $c_i^{n+1} \\in [0, 1]$，因此下冲振幅 $A_{\\text{under}} = \\max(0, -\\min_i c_i^{n+1})$ 将为零。\n\n1.  **阶数 $p=0$ (最近邻插值)**：值取自最近的网格点。$c_i^{n+1} = c_{j+\\text{round}(s)}^n$。由于这仅从初始数据中选择现有值，因此它是单调的。我们预期 $A_{\\text{under}}=0$。\n\n2.  **阶数 $p=1$ (线性插值)**：该值为两个包围网格点的加权平均值。\n    $$\n    c_i^{n+1} = (1-s)c_j^n + s c_{j+1}^n\n    $$\n    作为两个在 $[0, 1]$ 范围内的值的凸组合，结果也在 $[0, 1]$ 范围内。此方案是单调的，我们预期 $A_{\\text{under}}=0$。\n\n3.  **阶数 $p=3$ (三次拉格朗日插值)**：我们使用四个最近的网格点，形成模板 $\\{j-1, j, j+1, j+2\\}$ 来构造一个三次多项式。所有索引都必须周期性处理，例如，索引 $j-1$ 变为 $(j-1) \\pmod N$。插值值为：\n    $$\n    c_i^{n+1} = c_{j-1}^n \\mathcal{L}_{-1}(s) + c_{j}^n \\mathcal{L}_{0}(s) + c_{j+1}^n \\mathcal{L}_{1}(s) + c_{j+2}^n \\mathcal{L}_{2}(s)\n    $$\n    其中 $\\mathcal{L}_k(s)$ 是在归一化局部坐标 $s \\in [0,1)$ 处求值的拉格朗日基多项式，对应于 $\\{-1, 0, 1, 2\\}$ 处的模板点：\n    $$\n    \\begin{align*}\n    \\mathcal{L}_{-1}(s) = -\\frac{s(s-1)(s-2)}{6} \\\\\n    \\mathcal{L}_{0}(s) = \\frac{(s+1)(s-1)(s-2)}{2} \\\\\n    \\mathcal{L}_{1}(s) = -\\frac{(s+1)s(s-2)}{2} \\\\\n    \\mathcal{L}_{2}(s) = \\frac{(s+1)s(s-1)}{6}\n    \\end{align*}\n    $$\n    此方案通常不是单调的。基多项式可以取负值，这意味着插值结果不是一个凸组合。这可能导致在陡峭梯度附近出现伪振荡（下冲和过冲），因此对于非整数的 CFL 数，我们可能预期 $A_{\\text{under}} > 0$。对于整数 CFL 值，出发点与网格点对齐，$s=0$，插值变为精确选择 ($c_i^{n+1} = c_{i-\\mathrm{CFL}}^n$)，且不会产生下冲。\n\n算法通过迭代每个测试用例 $(p, \\mathrm{CFL})$ 来执行，构造初始状态 $c^0$，使用指定的插值计算新状态 $c^1$，然后计算 $A_{\\text{under}}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D semi-Lagrangian advection test for monotonicity.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    N = 2048\n    L = 1.0\n    u = 1.0\n    x0 = 0.33 * L\n    w = 0.20 * L\n    \n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # ------------------\n    # Initial Condition\n    # ------------------\n    c0 = np.zeros(N, dtype=np.float64)\n    # Define the top-hat tracer profile\n    # Use boolean indexing for clarity and efficiency\n    c0[(x >= x0) & (x < (x0 + w))] = 1.0\n    \n    # ------------------\n    # Test Suite\n    # ------------------\n    test_cases = [\n        (0, 0.75),\n        (1, 0.75),\n        (3, 0.75),\n        (3, 0.25),\n        (3, 1.00),\n        (3, 2.25),\n        (3, 0.00),\n        (1, 0.25),\n        (0, 0.25),\n    ]\n    \n    results = []\n    \n    for p, cfl in test_cases:\n        # For CFL=0, there is no change, so no undershoot\n        if cfl == 0.0:\n            results.append(0.0)\n            continue\n            \n        c1 = np.zeros(N, dtype=np.float64)\n\n        for i in range(N):\n            # Calculate departure point in non-dimensional grid coordinates\n            alpha = float(i) - cfl\n            \n            # Apply periodic boundary conditions. Python's % operator handles\n            # negative numbers in a way that is suitable for this (e.g., -0.75 % N = N-0.75).\n            alpha_periodic = alpha % N\n            \n            j = int(np.floor(alpha_periodic))\n            s = alpha_periodic - j\n\n            # Perform interpolation based on order p\n            if p == 0:  # Nearest-neighbor\n                idx = (j + int(round(s))) % N\n                c1[i] = c0[idx]\n            \n            elif p == 1:  # Linear\n                j0 = j\n                j1 = (j + 1) % N\n                c1[i] = (1.0 - s) * c0[j0] + s * c0[j1]\n            \n            elif p == 3:  # Cubic Lagrange\n                # Stencil points are j-1, j, j+1, j+2\n                j_m1 = (j - 1) % N\n                j_0 = j\n                j_1 = (j + 1) % N\n                j_2 = (j + 2) % N\n                \n                # Get the concentrations at the stencil points\n                c_m1 = c0[j_m1]\n                c_0 = c0[j_0]\n                c_1 = c0[j_1]\n                c_2 = c0[j_2]\n                \n                # Evaluate the Lagrange basis polynomials at s\n                l_m1 = -s * (s - 1.0) * (s - 2.0) / 6.0\n                l_0  = (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n                l_1  = -(s + 1.0) * s * (s - 2.0) / 2.0\n                l_2  = (s + 1.0) * s * (s - 1.0) / 6.0\n                \n                c1[i] = l_m1 * c_m1 + l_0 * c_0 + l_1 * c_1 + l_2 * c_2\n        \n        # Calculate amplitude of spurious undershoots\n        min_c1 = np.min(c1)\n        a_under = max(0.0, -min_c1)\n        results.append(a_under)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在地球系统模型中，确保质量、能量等物理量的守恒至关重要。然而，上一实践中简单的逐点插值方案通常不具备守恒性。本实践将引导您区分“点值”与“单元平均”两种物理量表示方法，并对比非守恒的插值格式与一种内禀守恒的几何重映（remapping）格式。通过这项练习，您将掌握构造离散守恒格式的基本原理，这是开发可靠环境模型的关键一步。",
            "id": "3911296",
            "problem": "考虑周期域上的一维线性平流方程，这是环境和地球系统建模中示踪剂输运的典型模型：$$\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,$$ 该方程定义在区间 $x \\in [0,1)$ 上，具有周期性边界条件和恒定速度 $u$。量 $q(x,t)$ 是无量纲的。半拉格朗日（SL）方法通过沿特征线向后追溯来推进解：在每个网格位置 $x_i$，确定出发点 $x_d = x_i - u \\Delta t$，并计算 $x_d$ 处前一时刻的解。在离散实现中，这需要对场 $q$ 进行插值，并且根据表示方式，还可能需要对几何平移区间上的单元平均值进行重映射。在连续形式下，总质量 $M(t) = \\int_0^1 q(x,t) \\, dx$ 在平流方程下是精确守恒的。在离散 SL 实现中，插值和几何重映射的选择决定了离散总质量是否守恒，以及质量误差如何在多个时间步内累积。\n\n您的任务是为多个时间步上的全局质量误差构建一个定量诊断方法，并在纯粹的数学和计算环境中，针对不同的插值和几何重映射选择计算该误差。在一个具有 $N_x$ 个单元的均匀周期性网格上进行计算，单元宽度为 $\\Delta x = 1/N_x$。网格上的值可以是位于单元中心 $x_i = (i + 0.5)\\Delta x$ 处的点值，也可以是与区间 $[i\\Delta x,(i+1)\\Delta x)$ 相关联的单元平均值。对于每种方法和初始条件，将第 $n$ 步的离散总质量定义为 $$M^n = \\sum_{i=0}^{N_x-1} q_i^n \\, \\Delta x,$$，其中 $q_i^n$ 表示近似局部平均值的点值或单元平均值本身，具体取决于所用方法。在使用恒定时间步长 $\\Delta t$ 推进 $N_{\\text{steps}}$ 步后，将全局质量误差 $E = M^{N_{\\text{steps}}} - M^0$ 诊断为一个实数。所有量均为无量纲；不需要物理单位。假设除了计算中固有的浮点舍入误差外，所有算术运算均在精确实数算术下执行。\n\n实现两种 SL 更新范式：\n- 带插值的点式 SL：对每个单元中心 $x_i$，使用线性插值或三次插值来计算出发点 $x_d = x_i - u \\Delta t$ 处的 $q^n$ 值，从而生成下一步的解 $q^{n+1}$。\n- 单元平均值的守恒几何重映射：将 $q_i^n$ 视为单元平均值，并通过在出发区间 $[x_i - \\Delta x/2 - u \\Delta t, x_i + \\Delta x/2 - u \\Delta t]$ 上对前一时刻的场进行平均来生成 $q_i^{n+1}$。由于周期性，该区间位于前一网格上。这种重映射在离散层面上通过构造必须是质量守恒的。\n\n构建一个程序，对于以下测试套件，计算规定步数后的全局质量误差 $E$。最终输出必须是单行，包含一个方括号括起来的逗号分隔列表形式的结果。\n\n测试套件：\n- 案例 1（正常路径，光滑场，小库朗数，点式线性插值）：$N_x = 128$，$\\Delta t = 1\\times 10^{-2}$，$u = 0.1$，$N_{\\text{steps}} = 100$，初始条件 $q(x) = 1 + \\sin(2\\pi x)$，方法：带线性插值的点式 SL。\n- 案例 2（光滑场，小库朗数，高阶插值）：与案例 1 参数相同，但使用三次插值，方法：带三次插值的点式 SL。\n- 案例 3（非光滑场，小库朗数，插值引起的质量误差压力测试）：$N_x = 128$，$\\Delta t = 1\\times 10^{-2}$，$u = 0.1$，$N_{\\text{steps}} = 100$，初始条件为当 $x \\in [0.25,0.75]$ 时 $q(x) = 1$，否则 $q(x) = 0$（进行周期性解释），方法：带线性插值的点式 SL。\n- 案例 4（非光滑场，守恒几何重映射）：与案例 3 参数相同，但方法：单元平均值的守恒几何重映射。\n- 案例 5（每步有效位移大，守恒几何重映射，周期性回绕压力测试）：$N_x = 128$，$\\Delta t = 0.1$，$u = 0.5$，$N_{\\text{steps}} = 25$，初始条件 $q(x) = \\exp\\left(-\\left(\\frac{x - 0.3}{0.05}\\right)^2\\right)$，方法：单元平均值的守恒几何重映射。\n\n您的程序必须以确切的格式生成输出：一个单行列表 $[E_1,E_2,E_3,E_4,E_5]$，其中每个 $E_k$ 是为案例 $k$ 计算的全局质量误差，以浮点数表示。",
            "solution": "该问题要求计算几种半拉格朗日（SL）平流方案应用于周期域 $x \\in [0,1)$ 上的一维线性平流方程 $\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0$ 时的全局质量误差。总质量 $M(t) = \\int_0^1 q(x,t) \\, dx$ 是该连续方程的一个不变量。我们将研究不同的离散数值方法对该性质的保持程度。\n\n首先，我们建立离散框架。该域被离散化为 $N_x$ 个均匀单元，每个单元的宽度为 $\\Delta x = 1/N_x$。量 $q(x,t)$ 由时间步 $n$ 的离散值向量 $q^n$ 表示。考虑两种表示方法：\n1.  **点值**：$q_i^n$ 表示场在单元中心 $x_i = (i + 0.5)\\Delta x$（其中 $i=0, \\dots, N_x-1$）处的值。因此，$q_i^n \\approx q(x_i, n\\Delta t)$。\n2.  **单元平均值**：$q_i^n$ 表示在单元 $i$（即区间 $[i\\Delta x, (i+1)\\Delta x)$）上的平均值。因此，$q_i^n = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x, n\\Delta t) \\, dx$。\n\n初始离散场 $q^0$ 是通过将给定的连续初始条件 $q(x,0)$ 投影到网格上获得的。\n- 对于点值表示，我们在单元中心处对函数进行采样：$q_i^0 = q(x_i, 0)$。\n- 对于单元平均值表示，我们计算真实的单元平均值：$q_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} q(x,0) \\, dx$。对于箱形函数，该积分是解析计算的；对于高斯分布，则使用误差函数 `erf` 计算，因为 `erf` 是高斯函数的解析积分。\n\n时间步 $n$ 的离散总质量定义为 $M^n = \\Delta x \\sum_{i=0}^{N_x-1} q_i^n$。在 $N_{\\text{steps}}$ 步之后的全局质量误差是最终离散质量与初始离散质量之差：$E = M^{N_{\\text{steps}}} - M^0$。\n\n现在我们详细介绍半拉格朗日时间步进算法。SL 方法的核心思想是沿特征线向后追溯。为了找到在到达点 $x_a$ 的值 $q^{n+1}$，我们找到其出发点 $x_d = x_a - u\\Delta t$，并设 $q^{n+1}(x_a) = q^n(x_d)$。\n\n**1. 带插值的点式 SL**\n\n在此范式中，我们更新每个单元中心 $x_i$ 处的点值。新值 $q_i^{n+1}$ 是通过在出发点 $x_d = x_i - u\\Delta t$ 处对场 $q^n$ 进行插值来确定的。\n出发点 $x_d$ 通常不会与网格点重合。其相对于网格的位置用于执行插值。我们定义一个连续化的网格坐标 $p(x) = (x / \\Delta x) - 0.5$，使得网格点 $x_i$ 对应于整数坐标 $i$。$x_i$ 的出发位置是 $p_d = ((x_i - u\\Delta t) \\pmod{1}) / \\Delta x - 0.5$。令 $j = \\lfloor p_d \\rfloor$ 为其整数部分，$f = p_d - j$ 为其小数部分，其中 $0 \\le f  1$。\n\n-   **线性插值**：我们使用两个最近的网格点 $j$ 和 $j+1$ 来构造一个线性插值多项式。索引进行周期性处理。\n    $$q_i^{n+1} = (1-f) q_{j \\pmod{N_x}}^n + f q_{(j+1) \\pmod{N_x}}^n$$\n    此方法简单且计算效率高，但本质上不保证质量守恒。插值后值的总和不保证等于原始值的总和。\n\n-   **三次插值**：可以使用四个网格点实现更高阶、更精确的插值。我们使用一个通过点 $(j-1, q_{j-1}^n)$、$(j, q_j^n)$、$(j+1, q_{j+1}^n)$ 和 $(j+2, q_{j+2}^n)$ 的多项式的拉格朗日形式。在相对于网格点 $j$ 的小数位置 $f$ 处对该多项式求值，得到：\n    $$q_i^{n+1} = L(f) = \\sum_{m=-1}^{2} q_{j+m}^n \\prod_{k=-1, k\\ne m}^{2} \\frac{f-k}{m-k}$$\n    明确地，这是：\n    $$q_i^{n+1} = q_{j-1}^n \\frac{f(f-1)(f-2)}{-6} + q_j^n \\frac{(f+1)(f-1)(f-2)}{2} + q_{j+1}^n \\frac{(f+1)f(f-2)}{-2} + q_{j+2}^n \\frac{(f+1)f(f-1)}{6}$$\n    所有索引都是周期性的。与线性插值一样，此方法不保证质量守恒。\n\n**2. 守恒几何重映射**\n\n此方法被设计为离散质量守恒。场 $q^n$ 被解释为一个分段常数函数，其在区间 $[i\\Delta x, (i+1)\\Delta x)$ 上的值为 $q_i^n$。新的单元平均值 $q_i^{n+1}$ 是通过计算 $q^n$ 在单元 $i$ 的出发区域上的平均值得到的。该区域是向后平移的区间 $[i\\Delta x, (i+1)\\Delta x)$，即 $[i\\Delta x - u\\Delta t, (i+1)\\Delta x - u\\Delta t)$。\n新的单元平均值为：\n$$q_i^{n+1} = \\frac{1}{\\Delta x} \\int_{i\\Delta x - u\\Delta t}^{(i+1)\\Delta x - u\\Delta t} q^n(x') \\, dx'$$\n令 $\\alpha = u\\Delta t / \\Delta x$ 为以网格单元为单位的位移。令 $k = \\lfloor \\alpha \\rfloor$ 且 $\\delta = \\alpha - k$。单元 $i$ 的出发区间是 $[(i-k-\\delta)\\Delta x, (i-k-\\delta+1)\\Delta x)$。由于 $q^n$ 是分段常数，积分是在该区间与旧网格单元重叠的线段上的总和。此计算产生一个看似简单但功能强大的更新规则：\n$$q_i^{n+1} = (1-\\delta) q_{(i-k) \\pmod{N_x}}^n + \\delta q_{(i-k-1) \\pmod{N_x}}^n$$\n该方案通过构造是守恒的。为验证，我们对所有单元求和：\n$$M^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} q_i^{n+1} = \\Delta x \\sum_{i=0}^{N_x-1} \\left( (1-\\delta) q_{i-k}^n + \\delta q_{i-k-1}^n \\right)$$\n通过对求和重新索引（由于周期性这是有效的），我们得到：\n$$M^{n+1} = \\Delta x \\left( (1-\\delta) \\sum_{j=0}^{N_x-1} q_j^n + \\delta \\sum_{j=0}^{N_x-1} q_j^n \\right) = (1-\\delta) M^n + \\delta M^n = M^n$$\n因此，离散质量在每个时间步都精确守恒。对于此方法，任何计算出的误差 $E$ 都应仅归因于浮点舍入误差。\n\n提供的 Python 代码实现了这些算法，以计算每个指定测试案例的质量误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef initialize_q(Nx, ic_name, method):\n    \"\"\"\n    Initializes the discrete field q0 based on the initial condition function\n    and the representation (pointwise or cell-average).\n    \"\"\"\n    dx = 1.0 / Nx\n    if method.startswith('pointwise'):\n        x = (np.arange(Nx) + 0.5) * dx\n        if ic_name == 'sin':\n            return 1.0 + np.sin(2 * np.pi * x)\n        elif ic_name == 'box':\n            return np.where((x = 0.25)  (x = 0.75), 1.0, 0.0)\n    elif method.startswith('conservative'):\n        q0 = np.zeros(Nx)\n        if ic_name == 'box':\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                overlap = max(0.0, min(x_right, 0.75) - max(x_left, 0.25))\n                q0[i] = overlap / dx\n            return q0\n        elif ic_name == 'gauss':\n            mu, sigma = 0.3, 0.05\n            # Use the analytical integral of a Gaussian, which involves the error function (erf)\n            # ∫ exp(-((x-μ)/σ)²) dx = σ * sqrt(π)/2 * erf((x-μ)/σ)\n            sqrt_pi_half_sigma = sigma * np.sqrt(np.pi) / 2.0\n            for i in range(Nx):\n                x_left, x_right = i * dx, (i + 1) * dx\n                integral = sqrt_pi_half_sigma * (erf((x_right - mu) / sigma) - erf((x_left - mu) / sigma))\n                q0[i] = integral / dx\n            return q0\n    return None\n\ndef advect_step(q, Nx, dx, u, dt, method):\n    \"\"\"\n    Performs a single time step of semi-Lagrangian advection.\n    \"\"\"\n    if method == 'pointwise_linear':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        # Calculate fractional grid positions for departure points\n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        f = p - j\n        \n        # Use np.take for efficient periodic boundary handling\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        \n        return (1.0 - f) * q_j + f * q_j1\n\n    elif method == 'pointwise_cubic':\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        x_depart = x_centers - u * dt\n        \n        p = ((x_depart % 1.0) / dx) - 0.5\n        j = np.floor(p).astype(int)\n        s = p - j  # Fractional part for Lagrange formula\n        \n        q_jm1 = np.take(q, j - 1, mode='wrap')\n        q_j = np.take(q, j, mode='wrap')\n        q_j1 = np.take(q, j + 1, mode='wrap')\n        q_j2 = np.take(q, j + 2, mode='wrap')\n        \n        # 4-point Lagrange interpolation formula\n        term_m1 = q_jm1 * s * (s - 1.0) * (s - 2.0) / -6.0\n        term_0 = q_j * (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n        term_1 = q_j1 * (s + 1.0) * s * (s - 2.0) / -2.0\n        term_2 = q_j2 * (s + 1.0) * s * (s - 1.0) / 6.0\n        \n        return term_m1 + term_0 + term_1 + term_2\n\n    elif method == 'conservative_remapping':\n        alpha = u * dt / dx  # Displacement in grid cell units\n        k = np.floor(alpha).astype(int)\n        delta = alpha - k\n        \n        # Update rule derived from geometric remapping of cell averages\n        # q_new[i] = (1-delta)*q[i-k] + delta*q[i-(k+1)]\n        # This is vectorized using np.roll for periodic shifts\n        q_new = (1.0 - delta) * np.roll(q, k) + delta * np.roll(q, k + 1)\n        return q_new\n\n    else:\n        raise ValueError(f\"Unknown method: {method}\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute global mass errors.\n    \"\"\"\n    test_cases = [\n        # (Nx, dt, u, N_steps, ic_name, method)\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'sin', 'pointwise_cubic'),\n        (128, 1e-2, 0.1, 100, 'box', 'pointwise_linear'),\n        (128, 1e-2, 0.1, 100, 'box', 'conservative_remapping'),\n        (128, 0.1, 0.5, 25, 'gauss', 'conservative_remapping'),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, dt, u, N_steps, ic_name, method = case\n        \n        dx = 1.0 / Nx\n        \n        # 1. Initialize the field q\n        q0 = initialize_q(Nx, ic_name, method)\n        \n        # 2. Compute initial mass\n        M0 = np.sum(q0) * dx\n        \n        # 3. Time-step the solution\n        q = q0.copy()\n        for _ in range(N_steps):\n            q = advect_step(q, Nx, dx, u, dt, method)\n            \n        # 4. Compute final mass and error\n        M_final = np.sum(q) * dx\n        error = M_final - M0\n        results.append(error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将一维方案扩展到多维时，一个常见捷径是使用维度分裂（dimensional splitting）方法，但这种近似并非总是有效。本实践聚焦于二维固體旋转流场，这在等离子体湍流等领域十分常见，旨在揭示维度分裂在此类耦合流场中引入的特有误差。您将通过与精确解的对比，不仅量化分裂误差的大小，还将分析其误差结构，理解其与初始场的交叉导数项的关联，从而深入认识多维平流格式设计的复杂性。",
            "id": "4199723",
            "problem": "考虑在由坐标 $x$ 和 $y$ 构成的平面中，受速度场 $\\boldsymbol{u}(x,y,t)$ 控制的二维无源标量平流方程，该方程为一个一阶偏微分方程 (PDE)\n$$\n\\frac{\\partial f}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla f = 0,\n$$\n其中 $f(x,y,t)$ 是被平流的标量。在半拉格朗日平流格式中，标量 $f$ 在到达点 $(x,y)$ 和时间 $t+\\Delta t$ 的值，是通过沿特征线回溯到时间 $t$ 的出发点 $(x_d,y_d)$，然后对 $f(x_d,y_d,t)$ 进行采样来评估的。该方法通过追踪特征线而非执行显式的通量更新，从而避免了欧拉格式的 Courant–Friedrichs–Lewy 约束。\n\n本问题分析了维数分裂方法在旋转流中引入的误差，并量化了在与聚变等离子体湍流模拟相关的刚体旋转测试中产生的虚假交叉导数效应，其中 ExB 旋转是一种常见模式。你必须从第一性原理出发进行推导，并实现一个程序来计算分裂方法在一个光滑测试函数上产生的误差，然后量化误差中与混合二阶导数（交叉导数）结构对齐的分量。\n\n基本原理和设置：\n- 速度场是一个角速度为 $\\Omega$（单位：弧度/秒）的刚体旋转，由下式给出：\n$$\nu(x,y) = -\\Omega\\,y,\\qquad v(x,y) = \\Omega\\,x.\n$$\n- 对于一个时间步长 $\\Delta t$（单位：秒），将时间 $t+\\Delta t$ 的到达位置 $(x,y)$ 映射到时间 $t$ 的出发位置 $(x_d,y_d)$ 的精确特征流，是一个沿时间反向旋转角度 $\\theta=\\Omega\\,\\Delta t$（单位：弧度）的过程。精确的出发点映射为：\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad\ny_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n- 一个采用 Lie 分裂（先沿 $x$ 方向平流，再沿 $y$ 方向平流）的维数分裂半拉格朗日方法，通过序列化的一维回溯计算出发点映射：\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega\\,y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v(x^{(1)},y^{(1)})\\,\\Delta t = y - \\Omega\\,x^{(1)}\\,\\Delta t.\n$$\n- 初始条件 $f_0(x,y)$ 是一个旋转的椭圆高斯函数，这是一个光滑的测试剖面，它打破了轴对称性以揭示交叉导数耦合。定义主轴坐标为\n$$\nx' = x\\cos\\alpha + y\\sin\\alpha,\\qquad y' = -x\\sin\\alpha + y\\cos\\alpha,\n$$\n并令\n$$\nf_0(x,y) = \\exp\\!\\left(-\\left[\\frac{x'^2}{\\sigma_1^2} + \\frac{y'^2}{\\sigma_2^2}\\right]\\right),\n$$\n其中 $\\alpha$ 是旋转角（单位：弧度），$\\sigma_1, \\sigma_2$ 是半轴宽度（与 $x$ 和 $y$ 的长度单位相同）。精确的半拉格朗日更新得到 $f^{\\mathrm{exact}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\right)$，而分裂更新得到 $f^{\\mathrm{split}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}}\\right)$。\n\n误差量化：\n- 定义局部误差场\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y).\n$$\n- 将初始条件 $f_0$ 在到达网格上的混合二阶导数（交叉导数）定义为\n$$\nD_{xy}(x,y) = \\frac{\\partial^2 f_0}{\\partial x\\,\\partial y}(x,y),\n$$\n在网格上通过周期性中心差分进行数值计算。\n- 计算误差的 $L^2$ 范数\n$$\n\\|E\\|_{2} = \\left(\\int_{\\Omega_D} E(x,y)^2\\,\\mathrm{d}x\\,\\mathrm{d}y\\right)^{1/2},\n$$\n和 $L^\\infty$ 范数 $\\|E\\|_{\\infty} = \\max_{(x,y)\\in\\Omega_D} |E(x,y)|$，其中 $\\Omega_D$ 表示计算域。\n- 通过在网格上的离散内积中，将 $E$ 正交投影到 $D_{xy}$ 上，来量化虚假的交叉导数效应：\n$$\nC_{xy} = \\frac{\\langle E, D_{xy} \\rangle}{\\langle D_{xy}, D_{xy} \\rangle},\n$$\n其中 $\\langle A,B\\rangle = \\int_{\\Omega_D} A(x,y)\\,B(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$ 通过求和乘以网格单元面积来近似。与交叉导数结构对齐的误差能量的分数为\n$$\nR = \\frac{|C_{xy}|\\,\\|D_{xy}\\|_{2}}{\\|E\\|_{2}},\n$$\n这是无量纲的。\n\n区域、单位和数值方法：\n- 使用边长为 $L$（单位：米）的方形周期性区域，即 $x,y\\in[-L/2,L/2)$，用 $N_x\\times N_y$ 个点进行均匀离散化，间距为 $\\Delta x = L/N_x$，$\\Delta y = L/N_y$。\n- 时间单位为秒，$\\Omega$ 单位为弧度/秒，角度如 $\\theta$ 和 $\\alpha$ 单位为弧度。\n- 所有报告的输出均为无量纲浮点数。在此测试中，标量 $f$ 是无单位的。\n- 初始条件和所有的 $f_0(x_d,y_d)$ 求值都必须根据旋转高斯函数的定义进行解析计算，而不是通过网格插值，以便将分裂误差与插值误差分离开来。\n\n程序行为要求：\n- 实现上述映射和度量。\n- 使用周期性中心差分计算 $D_{xy}$。\n- 对每个测试用例，按 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$ 的顺序计算并返回这四个浮点数。\n\n测试套件：\n- 设 $N_x=N_y=128$，$L=1$，且 $\\Omega=2\\pi$。\n- 三个测试用例涵盖不同方面：\n    1. 理想情况：$\\Delta t = 1/64$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    2. 更大的时间步长：$\\Delta t = 1/8$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    3. 对称性边界情况（预计交叉导数投影接近于零）：$\\Delta t = 1/8$，$\\alpha = 0$，$\\sigma_1 = 0.2$，$\\sigma_2 = 0.2$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），其中的条目是测试用例1的4个浮点数，接着是测试用例2的4个浮点数，再接着是测试用例3的4个浮点数；因此，单个列表中总共有12个浮点数。",
            "solution": "我们从无源标量平流偏微分方程 $\\partial_t f + \\boldsymbol{u}\\cdot\\nabla f = 0$ 开始，该方程意味着 $f$ 沿着特征线为常数。特征曲线 $(x(t),y(t))$ 满足以下常微分方程 (ODE)：\n$$\n\\frac{dx}{dt} = u(x,y) = -\\Omega\\,y, \\qquad \\frac{dy}{dt} = v(x,y) = \\Omega\\,x,\n$$\n其中 $\\Omega$ 是旋转的角频率。这些线性常微分方程的解是一个匀速旋转。在一个时间步长 $\\Delta t$ 内，从时间 $t$ 的点 $(x_0,y_0)$ 到时间 $t+\\Delta t$ 的点 $(x_1,y_1)$ 的前向映射为\n$$\nx_1 = x_0\\cos\\theta - y_0\\sin\\theta,\\qquad y_1 = x_0\\sin\\theta + y_0\\cos\\theta,\\qquad \\theta = \\Omega\\,\\Delta t.\n$$\n半拉格朗日更新需要进行回溯：给定时间 $t+\\Delta t$ 的点 $(x,y)$，找到时间 $t$ 的点 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$，使得 $f(x,y,t+\\Delta t) = f(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}},t)$。对前向旋转求逆，得到精确的出发点映射\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad y_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n\n维数分裂通过序列化的一维求解来近似二维平流。对于 Lie 分裂（先沿 $x$ 移动，再沿 $y$ 移动），我们定义算子 $\\mathcal{A} = u(x,y)\\,\\partial_x$ 和 $\\mathcal{B} = v(x,y)\\,\\partial_y$。一个步长内先应用 $\\Delta t$ 时长的 $x$ 方向平流，然后应用 $\\Delta t$ 时长的 $y$ 方向平流。相应的半拉格朗日回溯使用\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v\\big(x^{(1)},y^{(1)}\\big)\\,\\Delta t = y - \\Omega x^{(1)}\\,\\Delta t.\n$$\n对于算子可对易的可分离平流，此映射是精确的，但对于旋转，这些算子不对易。Lie 分裂的局部误差可以使用 Baker-Campbell-Hausdorff (BCH) 展开进行分析：对于不对易的算子 $\\mathcal{A}$ 和 $\\mathcal{B}$，一个步长会引入一个与对易子 $[\\mathcal{A},\\mathcal{B}]$ 成正比的 $O(\\Delta t^2)$ 误差。对于我们的旋转场，其中 $\\mathcal{A} = -\\Omega y\\,\\partial_x$ 且 $\\mathcal{B} = \\Omega x\\,\\partial_y$，将对易子应用于光滑函数 $f$ 可得\n$$\n[\\mathcal{A},\\mathcal{B}] f = \\mathcal{A}(\\mathcal{B}f) - \\mathcal{B}(\\mathcal{A}f) = \\Omega^2\\left(x\\,\\partial_x f - y\\,\\partial_y f\\right).\n$$\n等价地，对精确和分裂的出发点映射针对小的 $\\Delta t$ 进行泰勒展开，可以揭示\n$$\nx_d^{\\mathrm{exact}} = x + \\Omega y\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3),\\qquad\ny_d^{\\mathrm{exact}} = y - \\Omega x\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3),\n$$\n而\n$$\nx_d^{\\mathrm{split}} = x + \\Omega y\\,\\Delta t,\\qquad\ny_d^{\\mathrm{split}} = y - \\Omega x\\,\\Delta t - \\Omega^2 y\\,\\Delta t^2.\n$$\n两者相减得到\n$$\n\\delta x_d = x_d^{\\mathrm{split}} - x_d^{\\mathrm{exact}} = \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3), \\qquad\n\\delta y_d = y_d^{\\mathrm{split}} - y_d^{\\mathrm{exact}} = -\\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3).\n$$\n于是，标量的领导阶误差为\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y) \\approx \\partial_x f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta x_d + \\partial_y f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta y_d,\n$$\n这在 $O(\\Delta t^2)$ 阶上与对易子的结果一致，\n$$\nE(x,y) \\approx \\tfrac{1}{2}\\Omega^2\\,\\Delta t^2\\left(x\\,\\partial_x f_0 - y\\,\\partial_y f_0\\right),\n$$\n在适当接近的点上求值。这表明主导误差是方向导数的不平衡，而不是纯粹的混合导数。然而，在一个旋转的各向异性高斯函数 $f_0$ 上，其空间结构会将这些不平衡耦合到包含混合导数 $\\partial^2 f_0/(\\partial x\\,\\partial y)$ 的基分量中，从而产生一个可测量的到 $D_{xy}$ 上的投影。\n\n为量化这种虚假的交叉导数效应，我们计算：\n1. 误差场 $E(x,y)$，作为分裂和精确半拉格朗日更新之间的差值。更新是通过在各自的出发点解析地计算 $f_0$ 来执行的。这能将分裂误差与插值误差分离开来。\n2. $E$ 的 $L^2$ 和 $L^\\infty$ 范数，即 $\\|E\\|_2$ 和 $\\|E\\|_\\infty$。\n3. 网格上 $D_{xy}(x,y)$ 的周期性中心差分近似。\n4. 投影系数 $C_{xy} = \\langle E,D_{xy}\\rangle/\\langle D_{xy},D_{xy}\\rangle$ 和分数 $R = |C_{xy}|\\,\\|D_{xy}\\|_2/\\|E\\|_2$。\n\n算法设计：\n- 在 $x,y\\in[-L/2,L/2)$ 上构建一个 $N_x=N_y=128$ 的均匀网格，其中 $L=1$，间距为 $\\Delta x = \\Delta y = L/N_x$。\n- 定义旋转坐标 $x' = x\\cos\\alpha + y\\sin\\alpha$, $y' = -x\\sin\\alpha + y\\cos\\alpha$ 和 $f_0(x,y) = \\exp\\!\\left(-\\left[x'^2/\\sigma_1^2 + y'^2/\\sigma_2^2\\right]\\right)$。\n- 对每个角速度为 $\\Omega=2\\pi$ 和给定 $\\Delta t$ 的测试用例，计算 $\\theta=\\Omega\\Delta t$（单位：弧度）。\n- 通过上述公式计算精确和分裂的出发点映射，得到 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ 和 $(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}})$。\n- 在这些出发点上解析地计算 $f_0$，从而在到达网格上得到 $f^{\\mathrm{exact}}$ 和 $f^{\\mathrm{split}}$；计算 $E=f^{\\mathrm{split}}-f^{\\mathrm{exact}}$。\n- 通过周期性中心差分计算 $D_{xy}$：\n$$\nD_{xy}(i,j) \\approx \\frac{f_0(i+1,j+1)-f_0(i+1,j-1)-f_0(i-1,j+1)+f_0(i-1,j-1)}{4\\,\\Delta x\\,\\Delta y}.\n$$\n- 使用网格单元面积 $\\Delta x\\,\\Delta y$ 计算离散内积，以获得每个测试用例的 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$。\n\n测试套件覆盖范围：\n- 一个小 $\\Delta t$ 的情况（$\\Delta t=1/64$）展示了 $\\|E\\|_2$ 预期的 $O(\\Delta t^2)$ 标度律和通常较小的 $R$ 值。\n- 一个较大 $\\Delta t$ 的情况（$\\Delta t=1/8$）放大了分裂误差和交叉导数投影，增加了 $\\|E\\|_\\infty$ 和 $R$。\n- 一个对称性边界情况，其中 $\\alpha=0$ 且 $\\sigma_1=\\sigma_2$，使得初始条件具有旋转对称性；尽管 $D_{xy}$ 不恒为零，但由于对称性，预计投影系数 $C_{xy}$ 和分数 $R$ 会相对较小。\n\n最终程序遵循这些步骤，并为每个测试用例按顺序报告四个浮点数 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$，并按要求将它们汇总到一个由方括号括起来的逗号分隔列表中。所有角度均以弧度处理，$\\Omega$ 的单位是弧度/秒，$\\Delta t$ 的单位是秒，输出为无量纲浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotated_gaussian(x, y, sigma1, sigma2, alpha):\n    # Compute rotated coordinates\n    xp = x * np.cos(alpha) + y * np.sin(alpha)\n    yp = -x * np.sin(alpha) + y * np.cos(alpha)\n    return np.exp(-((xp / sigma1) ** 2 + (yp / sigma2) ** 2))\n\ndef exact_departure(x, y, theta):\n    # Backward characteristic for solid-body rotation: inverse of forward rotation\n    xd = x * np.cos(theta) + y * np.sin(theta)\n    yd = -x * np.sin(theta) + y * np.cos(theta)\n    return xd, yd\n\ndef split_departure_lie(x, y, omega, dt):\n    # Lie splitting: first x-advection then y-advection\n    x1 = x + omega * y * dt\n    y1 = y\n    yd = y1 - omega * x1 * dt\n    xd = x1\n    return xd, yd\n\ndef mixed_derivative_periodic(f, dx, dy):\n    # Central mixed derivative with periodic boundary conditions:\n    # Dxy ≈ (f(i+1,j+1) - f(i+1,j-1) - f(i-1,j+1) + f(i-1,j-1)) / (4 dx dy)\n    f_ip_jp = np.roll(np.roll(f, -1, axis=0), -1, axis=1)\n    f_ip_jm = np.roll(np.roll(f, -1, axis=0),  1, axis=1)\n    f_im_jp = np.roll(np.roll(f,  1, axis=0), -1, axis=1)\n    f_im_jm = np.roll(np.roll(f,  1, axis=0),  1, axis=1)\n    dxy = (f_ip_jp - f_ip_jm - f_im_jp + f_im_jm) / (4.0 * dx * dy)\n    return dxy\n\ndef inner_product(a, b, cell_area):\n    return np.sum(a * b) * cell_area\n\ndef l2_norm(a, cell_area):\n    return np.sqrt(np.sum(a * a) * cell_area)\n\ndef linf_norm(a):\n    return float(np.max(np.abs(a)))\n\ndef run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2):\n    # Grid\n    x = (np.arange(nx) - nx/2) * (L / nx)\n    y = (np.arange(ny) - ny/2) * (L / ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    dx = L / nx\n    dy = L / ny\n    cell_area = dx * dy\n\n    # Initial condition\n    f0 = rotated_gaussian(X, Y, sigma1, sigma2, alpha)\n\n    # Exact and split departures\n    theta = omega * dt\n    xd_exact, yd_exact = exact_departure(X, Y, theta)\n    xd_split, yd_split = split_departure_lie(X, Y, omega, dt)\n\n    # Evaluate f0 analytically at departure points\n    f_exact = rotated_gaussian(xd_exact, yd_exact, sigma1, sigma2, alpha)\n    f_split = rotated_gaussian(xd_split, yd_split, sigma1, sigma2, alpha)\n\n    # Error field\n    E = f_split - f_exact\n\n    # Mixed derivative of initial field at arrival grid\n    Dxy = mixed_derivative_periodic(f0, dx, dy)\n\n    # Norms and projections\n    E_l2 = l2_norm(E, cell_area)\n    E_linf = linf_norm(E)\n\n    denom = inner_product(Dxy, Dxy, cell_area)\n    if denom > 0:\n        Cxy = inner_product(E, Dxy, cell_area) / denom\n        Dxy_l2 = l2_norm(Dxy, cell_area)\n        R = (abs(Cxy) * Dxy_l2 / E_l2) if E_l2 > 0 else 0.0\n    else:\n        Cxy = 0.0\n        R = 0.0\n\n    return float(E_l2), float(E_linf), float(Cxy), float(R)\n\ndef solve():\n    # Define constants for all test cases\n    nx = 128\n    ny = 128\n    L = 1.0\n    omega = 2.0 * np.pi  # radians per second\n\n    # Test suite: (dt, alpha, sigma1, sigma2)\n    test_cases = [\n        (1.0/64.0, np.pi/6.0, 0.15, 0.25),  # Happy path\n        (1.0/8.0,  np.pi/6.0, 0.15, 0.25),  # Larger time step\n        (1.0/8.0,  0.0,       0.20, 0.20),  # Symmetry edge case\n    ]\n\n    results = []\n    for dt, alpha, sigma1, sigma2 in test_cases:\n        E_l2, E_linf, Cxy, R = run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2)\n        results.extend([E_l2, E_linf, Cxy, R])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}