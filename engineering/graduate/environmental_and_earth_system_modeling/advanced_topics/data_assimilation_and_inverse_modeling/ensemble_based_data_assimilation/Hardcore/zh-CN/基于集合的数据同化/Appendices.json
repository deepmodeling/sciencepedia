{
    "hands_on_practices": [
        {
            "introduction": "在基于集合的数据同化中，预报误差协方差矩阵是通过有限的模式状态集合来估计的。在实际应用中（如天气预报），一个关键的挑战是集合成员的数量 $N$ 通常远小于模式状态的维度 $n$ ($N \\ll n$)。这个练习  探讨了这种差异所带来的一个基本数学后果。通过推导样本协方差矩阵的结构，你将揭示为何其秩受到严重限制，这一特性会导致伪相关，并使得像协方差局域化这样的先进技术成为必需。",
            "id": "3878313",
            "problem": "在用于环境与地球系统建模的集合数据同化中，通常会从一个模式状态集合中估计模式状态误差协方差。考虑一个由 $N$ 个模式状态组成的集合 $\\{x^{(i)}\\}_{i=1}^{N}$，其中 $x^{(i)} \\in \\mathbb{R}^{n}$，代表了集合卡尔曼滤波（EnKF）系统中使用的一个简化大气柱。设样本均值为 $\\,\\bar{x} \\in \\mathbb{R}^{n}\\,$，定义距平矩阵 $\\,A \\in \\mathbb{R}^{n \\times N}\\,$，其列为中心化距平，即 $\\,A = [x^{(1)} - \\bar{x}, \\dots, x^{(N)} - \\bar{x}]$。\n\n仅从多变量数据集的样本均值和样本协方差的基本定义，以及线性代数的基本事实（例如，秩和奇异值分解的性质）出发，完成以下任务：\n\n1. 推导集合的样本协方差矩阵 $\\,P \\in \\mathbb{R}^{n \\times n}\\,$ 关于距平矩阵 $\\,A\\,$ 的表达式，并解释为何在一般情况下 $\\,\\mathrm{rank}(P) \\leq N - 1\\,$ 成立。\n2. 提供一个具体的数值示例，其中 $\\,n = 3\\,$ 且 $\\,N = 2\\,$，以说明您的推导过程。考虑两个物理上合理的大气状态向量，其分量分别对应温度（单位：开尔文）、比湿（单位：$\\mathrm{kg\\,kg^{-1}}$）和地面气压（单位：帕斯卡）：\n$$\nx^{(1)} = \\begin{pmatrix} 300 \\\\ 0.010 \\\\ 101000 \\end{pmatrix}, \\qquad\nx^{(2)} = \\begin{pmatrix} 296 \\\\ 0.008 \\\\ 100800 \\end{pmatrix}.\n$$\n计算该集合的样本均值 $\\,\\bar{x}\\,$、距平矩阵 $\\,A\\,$ 和样本协方差矩阵 $\\,P\\,$。然后根据您的计算显式地确定 $\\,P\\,$ 的秩。\n\n将您从数值示例中得到的 $\\,P\\,$ 的秩作为最终答案。最终答案应表示为一个无单位整数。无需四舍五入。",
            "solution": "在尝试解答之前，将对问题进行验证。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- $N$ 个模式状态的集合：$\\{x^{(i)}\\}_{i=1}^{N}$，其中 $x^{(i)} \\in \\mathbb{R}^{n}$。\n- 样本均值：$\\bar{x} = \\frac{1}{N} \\sum_{i=1}^{N} x^{(i)}$。\n- 距平矩阵：$A \\in \\mathbb{R}^{n \\times N}$，其列为 $x^{(i)} - \\bar{x}$。\n- 样本协方差矩阵：$P \\in \\mathbb{R}^{n \\times n}$。\n- 任务分为理论推导和数值示例两部分。\n- 数值示例参数：状态空间维度 $n = 3$，集合大小 $N = 2$。\n- 数值示例状态向量：\n$$\nx^{(1)} = \\begin{pmatrix} 300 \\\\ 0.010 \\\\ 101000 \\end{pmatrix}, \\qquad\nx^{(2)} = \\begin{pmatrix} 296 \\\\ 0.008 \\\\ 100800 \\end{pmatrix}.\n$$\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题设置在集合数据同化（特别是集合卡尔曼滤波）的背景下，这是环境和地球系统建模中的一种标准技术。样本均值、距平和样本协方差的定义是标准的统计概念。为一个简化的大气柱（温度、湿度、气压）提供的数值是物理上合理的。该问题在科学上和数学上都是合理的。\n- **适定性：** 问题陈述清晰，任务具体。存在唯一的解析推导和唯一的数值结果。\n- **客观性：** 语言正式、精确，没有主观或含糊不清的术语。\n- **完整性：** 提供了解决问题所需的所有必要定义和数据。\n- **一致性：** 定义和数据之间没有矛盾。\n\n**第 3 步：结论与行动**\n该问题是有效的，因为它具有科学依据、适定、客观且自洽。将提供完整的解答。\n\n---\n\n### 解答\n\n根据问题陈述的要求，解答分为两部分。\n\n**第 1 部分：推导与秩分析**\n\n对于一个由 $N$ 个状态 $\\{x^{(i)}\\}_{i=1}^{N}$ 组成的集合，其样本协方差矩阵 $P$ 定义为距平外积的平均值。该公式使用 $\\frac{1}{N-1}$ 作为缩放因子以得到无偏估计。\n$$\nP = \\frac{1}{N-1} \\sum_{i=1}^{N} (x^{(i)} - \\bar{x})(x^{(i)} - \\bar{x})^{\\mathrm{T}}\n$$\n其中 $\\bar{x}$ 是样本均值，$\\bar{x} = \\frac{1}{N} \\sum_{i=1}^{N} x^{(i)}$。\n\n距平矩阵 $A$ 定义为一个 $n \\times N$ 矩阵，其列为中心化距平：\n$$\nA = [x^{(1)} - \\bar{x}, x^{(2)} - \\bar{x}, \\dots, x^{(N)} - \\bar{x}]\n$$\n为了用 $A$ 表示 $P$，我们考虑乘积 $AA^{\\mathrm{T}}$。\n$$\nA A^{\\mathrm{T}} = [x^{(1)} - \\bar{x}, \\dots, x^{(N)} - \\bar{x}]\n\\begin{pmatrix}\n(x^{(1)} - \\bar{x})^{\\mathrm{T}} \\\\\n\\vdots \\\\\n(x^{(N)} - \\bar{x})^{\\mathrm{T}}\n\\end{pmatrix}\n$$\n此矩阵乘法等价于 $A$ 的对应列向量与 $A^{\\mathrm{T}}$ 的对应行向量的外积之和。\n$$\nA A^{\\mathrm{T}} = \\sum_{i=1}^{N} (x^{(i)} - \\bar{x})(x^{(i)} - \\bar{x})^{\\mathrm{T}}\n$$\n通过将其与 $P$ 的定义进行比较，我们立即得到样本协方差矩阵关于距平矩阵 $A$ 的表达式：\n$$\nP = \\frac{1}{N-1} A A^{\\mathrm{T}}\n$$\n\n接下来，我们解释为何 $\\mathrm{rank}(P) \\leq N-1$。\n矩阵乘积的秩小于或等于乘积中各矩阵秩的最小值。\n$$\n\\mathrm{rank}(P) = \\mathrm{rank}\\left(\\frac{1}{N-1} A A^{\\mathrm{T}}\\right) = \\mathrm{rank}(A A^{\\mathrm{T}})\n$$\n线性代数中的一个基本定理指出 $\\mathrm{rank}(AA^{\\mathrm{T}}) = \\mathrm{rank}(A)$。因此，\n$$\n\\mathrm{rank}(P) = \\mathrm{rank}(A)\n$$\n矩阵 $A$ 是一个 $n \\times N$ 矩阵。任何矩阵的秩至多是其行数和列数的最小值，所以 $\\mathrm{rank}(A) \\leq \\min(n, N)$。然而，我们可以建立一个更紧的界。设 $A$ 的列为 $a_i = x^{(i)} - \\bar{x}$。我们来考察这些列的和：\n$$\n\\sum_{i=1}^{N} a_i = \\sum_{i=1}^{N} (x^{(i)} - \\bar{x}) = \\left(\\sum_{i=1}^{N} x^{(i)}\\right) - \\left(\\sum_{i=1}^{N} \\bar{x}\\right)\n$$\n根据样本均值的定义，$\\sum_{i=1}^{N} x^{(i)} = N\\bar{x}$。第二项是 $N$ 个相同向量 $\\bar{x}$ 的和，所以 $\\sum_{i=1}^{N} \\bar{x} = N\\bar{x}$。\n$$\n\\sum_{i=1}^{N} a_i = N\\bar{x} - N\\bar{x} = 0\n$$\n由于 $A$ 的列之和为零向量，所以这些列是线性相关的。这意味着至少有一列可以写成其他列的线性组合。因此，$A$ 的列空间维度（即其秩）必须严格小于列数 $N$。\n因此，$\\mathrm{rank}(A) \\leq N-1$。\n由于 $\\mathrm{rank}(P) = \\mathrm{rank}(A)$，可得：\n$$\n\\mathrm{rank}(P) \\leq N-1\n$$\n\n**第 2 部分：数值示例**\n\n给定 $n=3$，$N=2$ 以及状态向量：\n$$\nx^{(1)} = \\begin{pmatrix} 300 \\\\ 0.010 \\\\ 101000 \\end{pmatrix}, \\qquad\nx^{(2)} = \\begin{pmatrix} 296 \\\\ 0.008 \\\\ 100800 \\end{pmatrix}\n$$\n\n首先，我们计算样本均值 $\\bar{x}$：\n$$\n\\bar{x} = \\frac{1}{2} (x^{(1)} + x^{(2)}) = \\frac{1}{2} \\left( \\begin{pmatrix} 300 \\\\ 0.010 \\\\ 101000 \\end{pmatrix} + \\begin{pmatrix} 296 \\\\ 0.008 \\\\ 100800 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 596 \\\\ 0.018 \\\\ 201800 \\end{pmatrix} = \\begin{pmatrix} 298 \\\\ 0.009 \\\\ 100900 \\end{pmatrix}\n$$\n\n接下来，我们计算距平并构成距平矩阵 $A$：\n$$\nx^{(1)} - \\bar{x} = \\begin{pmatrix} 300 - 298 \\\\ 0.010 - 0.009 \\\\ 101000 - 100900 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 0.001 \\\\ 100 \\end{pmatrix}\n$$\n$$\nx^{(2)} - \\bar{x} = \\begin{pmatrix} 296 - 298 \\\\ 0.008 - 0.009 \\\\ 100800 - 100900 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -0.001 \\\\ -100 \\end{pmatrix}\n$$\n所以，距平矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix} 2  -2 \\\\ 0.001  -0.001 \\\\ 100  -100 \\end{pmatrix}\n$$\n\n现在，我们使用推导出的公式计算样本协方差矩阵 $P$：\n$$\nP = \\frac{1}{N-1} A A^{\\mathrm{T}} = \\frac{1}{2-1} A A^{\\mathrm{T}} = A A^{\\mathrm{T}}\n$$\n$$\nP = \\begin{pmatrix} 2  -2 \\\\ 0.001  -0.001 \\\\ 100  -100 \\end{pmatrix}\n\\begin{pmatrix} 2  0.001  100 \\\\ -2  -0.001  -100 \\end{pmatrix}\n$$\n$$\nP = \\begin{pmatrix}\n(2)(2) + (-2)(-2)  (2)(0.001) + (-2)(-0.001)  (2)(100) + (-2)(-100) \\\\\n(0.001)(2) + (-0.001)(-2)  (0.001)(0.001) + (-0.001)(-0.001)  (0.001)(100) + (-0.001)(-100) \\\\\n(100)(2) + (-100)(-2)  (100)(0.001) + (-100)(-0.001)  (100)(100) + (-100)(-100)\n\\end{pmatrix}\n$$\n$$\nP = \\begin{pmatrix}\n4 + 4  0.002 + 0.002  200 + 200 \\\\\n0.002 + 0.002  1 \\times 10^{-6} + 1 \\times 10^{-6}  0.1 + 0.1 \\\\\n200 + 200  0.1 + 0.1  10000 + 10000\n\\end{pmatrix}\n$$\n$$\nP = \\begin{pmatrix}\n8  0.004  400 \\\\\n0.004  2 \\times 10^{-6}  0.2 \\\\\n400  0.2  20000\n\\end{pmatrix}\n$$\n\n最后，我们确定 $P$ 的秩。从理论分析中我们知道 $\\mathrm{rank}(P) = \\mathrm{rank}(A)$。我们来求 $A$ 的秩：\n$$\nA = \\begin{pmatrix} 2  -2 \\\\ 0.001  -0.001 \\\\ 100  -100 \\end{pmatrix}\n$$\n设 $A$ 的列为 $c_1$ 和 $c_2$。我们观察到 $c_2 = -1 \\times c_1$。由于一列是另一列的标量倍数，所以这两列是线性相关的。列空间由单个非零向量（例如 $c_1$）张成。因此，列空间的维度是 $1$。\n$$\n\\mathrm{rank}(A) = 1\n$$\n由于 $\\mathrm{rank}(P) = \\mathrm{rank}(A)$，我们得出结论，$P$ 的秩为 $1$。这与一般性结论 $\\mathrm{rank}(P) \\leq N-1$ 一致，因为 $1 \\leq 2-1$。\n另外，也可以通过行化简直接求 $P$ 的秩。第 2 行是第 1 行的 $\\frac{0.004}{8} = 0.0005$ 倍。第 3 行是第 1 行的 $\\frac{400}{8} = 50$ 倍。因此，第二行和第三行都可以通过减去第一行的倍数来消去，只留下一行非零行。这证实了 $\\mathrm{rank}(P) = 1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "在明确了使用小集合的一个关键理论挑战之后，我们现在转向集合卡尔曼滤波器（EnKF）分析步骤的核心机制。EnKF 通过将从集合中估计出的卡尔曼增益应用于每个成员，来近似理想的贝叶斯更新。在这个练习  中，你将为一个简单的一维系统执行此更新，手动计算先验统计量，并使用扰动观测方法更新每个成员。这个练习使得滤波器的操作过程变得透明，揭示了观测值如何同时校正集合的均值和离散度。",
            "id": "3878336",
            "problem": "考虑一个一维环境状态变量，例如流域平均土壤湿度异常，由一个集合 $\\{x_{b}^{(i)}\\}_{i=1}^{3} = \\{0.8, 1.0, 1.2\\}$ 表示，该集合近似了给定时间状态的高斯先验（背景）。有一个单一的原位观测值 $y = 1.1$，其线性观测算子为 $H = 1$，观测误差被建模为零均值高斯分布，方差为 $R = 0.2$。使用集合卡尔曼滤波器 (EnKF) 在线性高斯设定下的随机形式，从贝叶斯线性高斯框架的第一性原理出发，推导分析更新。其中，分析均值和方差由卡尔曼更新得出，该更新用集合估计的先验统计量和扰动观测值表示。\n\n为确保随机EnKF更新的确定性，使用以下特定的观测扰动（每个扰动都独立地从均值为零、方差为 $R$ 的高斯分布中抽取）：$\\epsilon^{(1)} = 0.3$，$\\epsilon^{(2)} = -0.3$，以及 $\\epsilon^{(3)} = 0.0$，因此扰动观测值为 $y^{(i)} = y + \\epsilon^{(i)}$，其中 $i = 1,2,3$。使用无偏除数 $N-1$（其中 $N=3$）来处理集合样本方差。\n\n计算得到的分析集合成员，然后计算分析集合均值和分析集合样本方差。将最终答案表示为一个包含分析均值和分析方差的数对。不需要四舍五入，如果自然出现有理数值，可以保留它们。答案必须以 LaTeX `pmatrix` 格式的单个行向量形式报告，条目按 $\\{$分析均值$, $分析方差$\\}$ 的顺序排列，不带单位。",
            "solution": "对问题进行验证。提取所有给定条件：\n- 先验集合：$\\{x_{b}^{(i)}\\}_{i=1}^{3} = \\{0.8, 1.0, 1.2\\}$，集合大小 $N=3$。\n- 观测值：$y = 1.1$。\n- 观测算子：$H = 1$。\n- 观测误差方差：$R = 0.2$。\n- 观测扰动：$\\{\\epsilon^{(i)}\\}_{i=1}^{3} = \\{0.3, -0.3, 0.0\\}$。\n- 扰动观测定义：$y^{(i)} = y + \\epsilon^{(i)}$。\n- 样本方差除数：$N-1$。\n该问题是集合卡尔曼滤波器 (EnKF) 的一个适定、有科学依据且客观的应用。它提供了计算唯一确定性答案所需的所有数据和约束。这是一个标准的教科书示例，用于说明随机EnKF的机理。因此，该问题被认为是有效的，并将提供解答。\n\n解答从线性高斯背景下的贝叶斯推断的第一性原理出发，这是卡尔曼滤波器以及引申出的集合卡尔曼滤波器的理论基础。\n\n在贝叶斯框架中，分析（后验）概率密度函数 $p(x|y)$ 与先验（背景）密度 $p(x)$ 和似然 $p(y|x)$ 的乘积成正比：\n$$p(x|y) \\propto p(y|x) p(x)$$\n对于线性高斯系统，先验是均值为 $\\mu_b$、方差为 $P_b$ 的高斯分布，记为 $\\mathcal{N}(x | \\mu_b, P_b)$。观测值 $y$ 通过线性算子 $H$ 与状态 $x$ 相关，并被均值为零、方差为 $R$ 的高斯噪声所污染。因此，似然为 $p(y|x) = \\mathcal{N}(y | Hx, R)$。得到的后验分布也是高斯分布，$p(x|y) = \\mathcal{N}(x | \\mu_a, P_a)$，其分析均值 $\\mu_a$ 和分析方差 $P_a$ 由卡尔曼滤波器方程给出：\n$$\\mu_a = \\mu_b + K(y - H\\mu_b)$$\n$$P_a = (1 - KH)P_b$$\n其中卡尔曼增益 $K$ 为：\n$$K = P_b H^T (H P_b H^T + R)^{-1}$$\n\n集合卡尔曼滤波器 (EnKF) 使用预报集合 $\\{x_{b}^{(i)}\\}_{i=1}^{N}$ 的样本统计量来近似先验统计量 $\\mu_b$ 和 $P_b$。\n\n**第1步：从集合计算先验统计量**\n给定的先验集合为 $\\{x_{b}^{(i)}\\}_{i=1}^{3} = \\{0.8, 1.0, 1.2\\}$。集合大小为 $N=3$。\n集合均值 $\\bar{x}_b$ 估计先验均值 $\\mu_b$：\n$$\\bar{x}_b = \\frac{1}{N} \\sum_{i=1}^{N} x_b^{(i)} = \\frac{1}{3}(0.8 + 1.0 + 1.2) = \\frac{3.0}{3} = 1.0$$\n集合样本方差 $\\hat{P}_b$ 估计先验方差 $P_b$。使用无偏除数 $N-1$：\n$$\\hat{P}_b = \\frac{1}{N-1} \\sum_{i=1}^{N} (x_b^{(i)} - \\bar{x}_b)^2 = \\frac{1}{2} \\left[ (0.8 - 1.0)^2 + (1.0 - 1.0)^2 + (1.2 - 1.0)^2 \\right]$$\n$$\\hat{P}_b = \\frac{1}{2} \\left[ (-0.2)^2 + 0^2 + (0.2)^2 \\right] = \\frac{1}{2} [0.04 + 0 + 0.04] = \\frac{0.08}{2} = 0.04$$\n\n**第2步：计算集合卡尔曼增益**\n卡尔曼增益 $\\hat{K}$ 使用样本方差 $\\hat{P}_b$ 以及给定的观测算子 $H=1$ 和观测误差方差 $R=0.2$ 来计算：\n$$\\hat{K} = \\hat{P}_b H (H \\hat{P}_b H + R)^{-1} = \\frac{\\hat{P}_b}{H^2 \\hat{P}_b + R}$$\n$$\\hat{K} = \\frac{0.04}{1^2 \\cdot 0.04 + 0.2} = \\frac{0.04}{0.04 + 0.2} = \\frac{0.04}{0.24} = \\frac{4}{24} = \\frac{1}{6}$$\n\n**第3步：更新每个集合成员**\n随机EnKF使用唯一的扰动观测值 $y^{(i)} = y + \\epsilon^{(i)}$ 更新每个成员。第 $i$ 个成员的更新方程为：\n$$x_a^{(i)} = x_b^{(i)} + \\hat{K} (y^{(i)} - H x_b^{(i)})$$\n给定观测值 $y=1.1$ 和扰动 $\\{\\epsilon^{(i)}\\} = \\{0.3, -0.3, 0.0\\}$，扰动观测值为：\n$$y^{(1)} = 1.1 + 0.3 = 1.4$$\n$$y^{(2)} = 1.1 - 0.3 = 0.8$$\n$$y^{(3)} = 1.1 + 0.0 = 1.1$$\n现在我们使用 $H=1$ 和 $\\hat{K}=1/6$ 更新每个成员：\n对于 $i=1$：\n$$x_a^{(1)} = x_b^{(1)} + \\hat{K} (y^{(1)} - x_b^{(1)}) = 0.8 + \\frac{1}{6}(1.4 - 0.8) = 0.8 + \\frac{0.6}{6} = 0.8 + 0.1 = 0.9$$\n对于 $i=2$：\n$$x_a^{(2)} = x_b^{(2)} + \\hat{K} (y^{(2)} - x_b^{(2)}) = 1.0 + \\frac{1}{6}(0.8 - 1.0) = 1.0 + \\frac{-0.2}{6} = 1.0 - \\frac{1}{30} = \\frac{29}{30}$$\n对于 $i=3$：\n$$x_a^{(3)} = x_b^{(3)} + \\hat{K} (y^{(3)} - x_b^{(3)}) = 1.2 + \\frac{1}{6}(1.1 - 1.2) = 1.2 + \\frac{-0.1}{6} = 1.2 - \\frac{1}{60} = \\frac{72}{60} - \\frac{1}{60} = \\frac{71}{60}$$\n得到的分析集合为 $\\{x_a^{(i)}\\} = \\{0.9, \\frac{29}{30}, \\frac{71}{60}\\}$。\n\n**第4步：计算分析集合的均值和方差**\n分析均值 $\\bar{x}_a$ 是分析集合成员的平均值。为计算此值，我们将所有成员表示为公分母为60的分数：$0.9 = \\frac{9}{10} = \\frac{54}{60}$，$\\frac{29}{30} = \\frac{58}{60}$。\n$$\\bar{x}_a = \\frac{1}{3} \\left( \\frac{54}{60} + \\frac{58}{60} + \\frac{71}{60} \\right) = \\frac{1}{3} \\left( \\frac{54 + 58 + 71}{60} \\right) = \\frac{1}{3} \\left( \\frac{183}{60} \\right) = \\frac{61}{60}$$\n分析样本方差 $\\hat{P}_a$ 从分析集合计算得出：\n$$\\hat{P}_a = \\frac{1}{N-1} \\sum_{i=1}^{N} (x_a^{(i)} - \\bar{x}_a)^2$$\n首先，计算与分析均值 $\\bar{x}_a = 61/60$ 的偏差：\n$$x_a^{(1)} - \\bar{x}_a = \\frac{54}{60} - \\frac{61}{60} = -\\frac{7}{60}$$\n$$x_a^{(2)} - \\bar{x}_a = \\frac{58}{60} - \\frac{61}{60} = -\\frac{3}{60}$$\n$$x_a^{(3)} - \\bar{x}_a = \\frac{71}{60} - \\frac{61}{60} = \\frac{10}{60}$$\n_偏差之和：$(-\\frac{7}{60}) + (-\\frac{3}{60}) + (\\frac{10}{60}) = 0$，符合预期。_\n现在，计算平方偏差之和：\n$$\\sum (x_a^{(i)} - \\bar{x}_a)^2 = \\left(-\\frac{7}{60}\\right)^2 + \\left(-\\frac{3}{60}\\right)^2 + \\left(\\frac{10}{60}\\right)^2$$\n$$= \\frac{49}{3600} + \\frac{9}{3600} + \\frac{100}{3600} = \\frac{49+9+100}{3600} = \\frac{158}{3600}$$\n最后，用除数 $N-1=2$ 计算样本方差：\n$$\\hat{P}_a = \\frac{1}{2} \\left( \\frac{158}{3600} \\right) = \\frac{79}{3600}$$\n分析均值为 $\\frac{61}{60}$，分析方差为 $\\frac{79}{3600}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{61}{60}  \\frac{79}{3600}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "这最后一个练习将集合协方差的局限性和滤波器机制等概念综合到一个完整的计算实验中。你将为 Lorenz-96 模型  实现一个 EnKF，这是一个广泛用于模拟大气动力学的经典混沌系统。这个编程挑战将让你亲眼目睹滤波发散——这是我们之前讨论的采样误差的直接后果——然后通过实施和调整乘法膨胀和协方差局域化等关键技术来稳定系统。这种实践经验对于培养如何在实践中成功应用集合数据同化的直觉至关重要。",
            "id": "3878364",
            "problem": "考虑一个维度为 $n$、状态向量为 $x \\in \\mathbb{R}^n$ 的循环、常数强迫的 Lorenz–$96$ 系统，其演化遵循以下常微分方程\n$$\n\\frac{d x_i}{d t} = \\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F,\\quad i=1,\\dots,n,\n$$\n采用循环索引，使得 $x_{-1} \\equiv x_{n-1}$，$x_0 \\equiv x_n$，且 $x_{n+1} \\equiv x_1$。假设 $F$ 在时间和空间上是常数。在基于集合的数据同化中，集合卡尔曼滤波器 (EnKF) 通过将一组模型状态随时间向前演化，并在离散的同化时间点使用观测值通过线性分析步骤对其进行调整，来近似贝叶斯序贯估计。在有限集合中，为防止滤波器发散，两种广泛使用的正则化策略是协方差局地化和乘性膨胀。在协方差局地化中，使用一个空间上衰减的相关函数来降低预报误差协方差中长距离元素的影响。在乘性膨胀中，集合成员相对于集合均值的偏差会乘以一个严格大于一的因子，以维持足够的集合离散度。\n\n从上述微分方程和基于使用卡尔曼增益的线性更新的集合卡尔曼滤波器分析步骤的定义出发，实现一个计算实验，以演示滤波器发散的情景，以及如何通过调整局地化半径和膨胀参数来恢复稳定性。使用以下基本设置：\n\n- 上面定义的 Lorenz–$96$ 预报方程。\n- 带扰动观测的集合卡尔曼滤波器 (EnKF)：在每个同化时间，每个集合成员都使用基于从集合预报协方差和观测算子计算出的卡尔曼增益的线性分析步骤进行更新。\n- 使用各向同性相关函数 $\\rho(d) = \\exp\\!\\left(-(d / r_{\\text{loc}})^2\\right)$ 的高斯协方差局地化，其中 $d$ 是两个状态索引之间的循环格点距离，$r_{\\text{loc}}$ 是以格点为单位测量的局地化半径。\n- 在计算预报协方差之前，立即将集合异常乘以一个因子 $\\lambda > 1$ 的乘性膨胀。\n\n你的程序必须：\n\n1. 实现维度 $n = 40$、常数强迫 $F = 8$ 的 Lorenz–$96$ 模型，使用时间步长 $\\Delta t = 0.05$ 的四阶龙格-库塔时间离散化方法。\n2. 使用 $m = 8$ 个集合成员。\n3. 每 $\\Delta t_a = 0.4$ 时间单位（即每 $8$ 个模型时间步）同化一次观测，总共进行 $N_{\\text{cycles}} = 80$ 个同化循环。\n4. 观测是通过观测真实值的偶数索引分量（在零基索引中为索引 $0,2,4,\\dots,38$）并加上方差为 $\\sigma_o^2 = 1.5^2$ 的附加独立高斯噪声来构建的；观测算子 $H$ 是将 $\\mathbb{R}^{40}$ 映射到 $\\mathbb{R}^{20}$ 的选择矩阵，对应于这些索引。在 EnKF 扰动观测方案中，每个集合成员在每个分析步骤中使用同一观测值的独立扰动实现。\n5. 通过从分量标准正态分布中抽取初始条件 $x^{\\text{true}}(0)$，然后将常数 $F$ 加到每个分量上，并在第一个同化循环前将模型空转 $200$ 个时间步来生成真实轨迹。为保证可复现性，所有随机抽样必须使用固定的伪随机种子 $0$。\n6. 通过向空转后的真实状态添加独立的、分量上的高斯噪声 $\\mathcal{N}(0,\\sigma_{\\text{init}}^2)$（其中 $\\sigma_{\\text{init}} = 0.3$）来初始化集合。所有变量都是无量纲的；不需要物理单位。\n\n按如下方式定义滤波器发散和稳定性：\n\n- 在每个同化循环 $k$，计算集合分析均值 $\\bar{x}_k^{\\text{a}}$ 与真实值 $x_k^{\\text{true}}$ 之间的均方根误差 (RMSE)，\n$$\n\\text{RMSE}_k = \\sqrt{\\frac{1}{n}\\sum_{i=1}^n \\left(\\bar{x}_{k,i}^{\\text{a}} - x_{k,i}^{\\text{true}}\\right)^2 }.\n$$\n- 如果在任何时候，任何集合成员或真实值的任何状态分量的绝对值超过 $B_{\\max} = 100$，或者在同化窗口的后半部分（循环 $41$ 到 $80$）的时间平均 RMSE 超过阈值 $\\tau = 2.0$，则该次运行被标记为不稳定。否则，该次运行被标记为稳定。\n\n通过构建 $n \\times n$ 的局地化矩阵 $L$（其元素为 $L_{ij} = \\rho(d(i,j))$，其中 $d(i,j)$ 是长度为 $n$ 的环上索引 $i$ 和 $j$ 之间的最小循环距离）来实现高斯协方差局地化，并在形成卡尔曼增益之前，将 $L$ 按元素方式应用于从膨胀后的集合异常计算出的预报误差协方差。在计算预报协方差之前，立即将关于预报均值的集合异常乘以因子 $\\lambda$ 来实现乘性膨胀。\n\n你的程序必须评估以下参数值测试套件，每个测试由一对 $(r_{\\text{loc}}, \\lambda)$ 定义：\n\n- 测试 1（边缘情况：无局地化，无膨胀）：$(r_{\\text{loc}} = \\infty, \\lambda = 1.0)$。\n- 测试 2（边缘情况：无局地化，中度膨胀）：$(r_{\\text{loc}} = \\infty, \\lambda = 1.05)$。\n- 测试 3（理想情况：中度局地化和轻微膨胀）：$(r_{\\text{loc}} = 2.0, \\lambda = 1.02)$。\n- 测试 4（边界情况：非常小的局地化半径，无膨胀）：$(r_{\\text{loc}} = 1.0, \\lambda = 1.0)$。\n\n对每个测试，运行完整的同化实验并如上所述确定稳定性。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[b_1,b_2,b_3,b_4]$，其中每个 $b_i$ 是一个布尔值，表示滤波器在相应测试用例下是否保持稳定。",
            "solution": "该问题要求为 Lorenz-$96$ 模型实现一个集合卡尔曼滤波器 (EnKF) 数据同化实验。目标是演示滤波器稳定性如何受两种常见的正则化技术影响：乘性膨胀和协方差局地化。这涉及建立一个双生实验，其中生成一个“真实”轨迹，从中抽取合成观测，并更新一组模型状态以追踪该真实轨迹。滤波器的稳定性将在膨胀因子和局地化半径的四种不同参数组合下进行评估。\n\n解决方案的结构如下：首先，实现 Lorenz-$96$ 系统的数值模型。然后，构建 EnKF 的各个组成部分，包括同化循环、预报步骤和分析步骤。特别注意膨胀和局地化的正确实现。最后，为每个指定的参数集运行整个实验，并根据预定义的标准确定稳定性。\n\n**1. Lorenz-$96$ 模型和时间积分**\n\n系统的状态是一个向量 $x \\in \\mathbb{R}^n$，其中 $n=40$。其第 $i$ 个分量的演化由以下常微分方程决定：\n$$\n\\frac{d x_i}{d t} = \\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F\n$$\n强迫常数为 $F=8$ 并采用循环边界条件，意味着索引对 $n$ 取模。在实现中，这意味着 $x_0 \\equiv x_n$，$x_{-1} \\equiv x_{n-1}$ 等。该常微分方程组使用四阶龙格-库塔 (RK4) 方法以 $\\Delta t = 0.05$ 的时间步长向前积分。对于状态向量 $x$ 和常微分方程 $\\frac{dx}{dt} = f(x)$，RK4 方法为：\n$$\n\\begin{aligned}\nk_1 = f(x(t)) \\\\\nk_2 = f(x(t) + 0.5 \\Delta t k_1) \\\\\nk_3 = f(x(t) + 0.5 \\Delta t k_2) \\\\\nk_4 = f(x(t) + \\Delta t k_3) \\\\\nx(t+\\Delta t) = x(t) + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n\n**2. 实验设置：真实值、集合和观测**\n\n生成一个“真实运行”作为自然的参考状态。初始状态 $x^{\\text{true}}(0)$ 从分量标准正态分布 $\\mathcal{N}(0,1)$ 中抽取，然后加上常数强迫 $F$。随后通过将模型积分 $200$ 个时间步（$\\Delta t = 0.05 \\implies 10$ 时间单位）进行空转，以使轨迹稳定到模型的吸引子上。\n\n初始化一个由 $m = 8$ 个成员组成的集合，记为矩阵 $X \\in \\mathbb{R}^{n \\times m}$。$X$ 的每一列都是一个集合成员。初始集合是通过获取空转后的真实状态，并为每个成员添加独立的、分量上的高斯噪声 $\\mathcal{N}(0, \\sigma_{\\text{init}}^2)$（其中 $\\sigma_{\\text{init}} = 0.3$）来生成的。\n\n每隔 $\\Delta t_a = 0.4$ 时间单位（对应 $8$ 个模型积分步）同化一次观测。观测由真实状态向量的偶数索引分量（$x_0, x_2, \\dots, x_{38}$）组成。观测算子 $H \\in \\mathbb{R}^{p \\times n}$（其中 $p=20, n=40$）是选择这些分量的矩阵。通过将 $H$ 应用于真实状态并添加方差为 $\\sigma_o^2 = 1.5^2$ 的高斯噪声来创建观测向量 $y \\in \\mathbb{R}^p$。\n$$\ny = H x^{\\text{true}} + \\epsilon, \\quad \\epsilon \\sim \\mathcal{N}(0, R)\n$$\n其中 $R = \\sigma_o^2 I_p$ 是观测误差协方差矩阵，$I_p$ 是 $p \\times p$ 的单位矩阵。\n\n**3. 集合卡尔曼滤波器 (EnKF) 循环**\n\n实验进行 $N_{\\text{cycles}} = 80$ 个同化循环。每个循环包括一个预报步骤和一个分析步骤。设 $X_k^{\\text{a}}$ 为第 $k$ 个循环的分析集合。\n\n**预报步骤：** 每个集合成员（$X_k^{\\text{a}}$ 的列）使用 RK4 积分器从时间 $t_k$ 向前积分到 $t_{k+1}$。这会产生预报集合 $X_{k+1}^{\\text{f}}$。\n$$\nX_{k+1}^{\\text{f}} = \\mathcal{M}(X_k^{\\text{a}})\n$$\n其中 $\\mathcal{M}$ 代表在区间 $\\Delta t_a$ 上积分的 Lorenz-$96$ 模型。\n\n**分析步骤：** 在时间 $t_{k+1}$，使用观测 $y_{k+1}$ 更新预报集合 $X_{k+1}^{\\text{f}}$。\n\n**a. 膨胀：** 首先，应用乘性膨胀。通过从每个成员中减去集合均值 $\\bar{x}_{k+1}^{\\text{f}}$ 来计算集合预报异常 $A_{k+1}^{\\text{f}}$。然后将这些异常乘以膨胀因子 $\\lambda$。\n$$\n\\bar{x}_{k+1}^{\\text{f}} = \\frac{1}{m} \\sum_{i=1}^m x_{k+1, i}^{\\text{f}}\n$$\n$$\nA_{k+1}^{\\text{f}} = X_{k+1}^{\\text{f}} - \\bar{x}_{k+1}^{\\text{f}}\n$$\n$$\nA_{k+1}^{\\text{f, inflated}} = \\lambda A_{k+1}^{\\text{f}}\n$$\n膨胀后的预报集合为 $X_{k+1}^{\\text{f, inflated}} = \\bar{x}_{k+1}^{\\text{f}} + A_{k+1}^{\\text{f, inflated}}$。\n\n**b. 协方差建模与局地化：** 预报误差协方差 $P_{k+1}^{\\text{f}}$ 是根据膨胀后的异常估计的：\n$$\nP_{k+1}^{\\text{f}} = \\frac{1}{m-1} A_{k+1}^{\\text{f, inflated}} \\left(A_{k+1}^{\\text{f, inflated}}\\right)^T\n$$\n为了减轻因小集合规模导致的的虚假远程相关性的影响，应用了协方差局地化。构建一个局地化矩阵 $L \\in \\mathbb{R}^{n \\times n}$，其中每个元素 $L_{ij}$ 由一个依赖于格点 $i$ 和 $j$ 之间循环距离 $d(i,j)$ 的高斯相关函数给出：\n$$\nL_{ij} = \\exp\\left(-\\frac{d(i,j)^2}{r_{\\text{loc}}^2}\\right), \\quad d(i,j) = \\min(|i-j|, n - |i-j|)\n$$\n对于边缘情况 $r_{\\text{loc}} = \\infty$，$L$ 是一个全为 1 的矩阵。局地化的协方差通过逐元素（哈达玛）乘积获得：\n$$\nP_{k+1}^{\\text{f, loc}} = L \\circ P_{k+1}^{\\text{f}}\n$$\n\n**c. 卡尔曼增益和状态更新：** 卡尔曼增益 $K_{k+1}$ 的计算方法如下：\n$$\nK_{k+1} = P_{k+1}^{\\text{f, loc}} H^T \\left( H P_{k+1}^{\\text{f, loc}} H^T + R \\right)^{-1}\n$$\n对于 EnKF 的扰动观测变体，为每个集合成员 $i$ 生成一个唯一的扰动观测 $y_{k+1, i}$：\n$$\ny_{k+1, i} = y_{k+1} + \\epsilon_i, \\quad \\epsilon_i \\sim \\mathcal{N}(0, R)\n$$\n然后，每个膨胀后的预报成员 $x_{k+1, i}^{\\text{f, inflated}}$ 被更新为其分析状态 $x_{k+1, i}^{\\text{a}}$：\n$$\nx_{k+1, i}^{\\text{a}} = x_{k+1, i}^{\\text{f, inflated}} + K_{k+1} \\left( y_{k+1, i} - H x_{k+1, i}^{\\text{f, inflated}} \\right)\n$$\n这就得到了分析集合 $X_{k+1}^{\\text{a}}$。\n\n**4. 稳定性评估**\n\n对于每次实验运行，稳定性由两个条件确定：\n1.  **发散：** 在模拟过程中的任何时刻，如果真实状态或任何集合成员的任何分量的绝对值超过 $B_{\\max} = 100$，则该运行被视为不稳定。\n2.  **RMSE：** 在每个循环 $k$，计算分析集合均值 $\\bar{x}_k^{\\text{a}}$ 和真实值 $x_k^{\\text{true}}$ 之间的均方根误差 (RMSE)。如果该 RMSE 在同化窗口后半段（循环 $41-80$）的时间平均值超过阈值 $\\tau = 2.0$，则该运行被视为不稳定。\n一次运行只有在不违反任何一个条件的情况下才是稳定的。对四个 $(r_{\\text{loc}}, \\lambda)$ 测试对中的每一个重复此过程，并为每个测试记录一个布尔稳定性结果。通过为四个测试用例中的每一个都使用固定的种子 $0$ 重置随机数生成器来确保可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef lorenz96_rhs(x, F):\n    \"\"\"Computes the RHS of the Lorenz-96 system.\"\"\"\n    # x can be a 1D vector (state) or 2D matrix (ensemble)\n    # np.roll handles cyclic boundaries correctly\n    # axis=0 ensures rolls are along the state dimension for ensembles\n    x_plus_1 = np.roll(x, -1, axis=0)\n    x_minus_1 = np.roll(x, 1, axis=0)\n    x_minus_2 = np.roll(x, 2, axis=0)\n    return (x_plus_1 - x_minus_2) * x_minus_1 - x + F\n\ndef rk4_step(x, F, dt):\n    \"\"\"Performs one RK4 step for the Lorenz-96 model.\"\"\"\n    k1 = lorenz96_rhs(x, F)\n    k2 = lorenz96_rhs(x + 0.5 * dt * k1, F)\n    k3 = lorenz96_rhs(x + 0.5 * dt * k2, F)\n    k4 = lorenz96_rhs(x + dt * k3, F)\n    return x + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef create_localization_matrix(n, r_loc):\n    \"\"\"Creates the Gaspari-Cohn localization matrix L.\"\"\"\n    if r_loc == np.inf:\n        return np.ones((n, n))\n    \n    indices = np.arange(n)\n    dist_matrix = np.abs(indices[:, np.newaxis] - indices[np.newaxis, :])\n    cyclic_dist = np.minimum(dist_matrix, n - dist_matrix)\n    \n    return np.exp(-(cyclic_dist**2) / (r_loc**2))\n\ndef run_enkf_experiment(r_loc, lambda_inf):\n    \"\"\"Runs a full EnKF experiment for given parameters.\"\"\"\n    # Parameters\n    n = 40\n    F = 8.0\n    dt = 0.05\n    m = 8\n    dt_a = 0.4\n    n_cycles = 80\n    obs_var = 1.5**2\n    sigma_init = 0.3\n    b_max = 100.0\n    rmse_thresh = 2.0\n    seed = 0\n\n    n_steps_per_cycle = int(dt_a / dt)\n    \n    # Initialize RNG for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # --- 1. Generate Truth Run ---\n    x_truth = rng.normal(size=n) + F\n    for _ in range(200): # Spin-up\n        x_truth = rk4_step(x_truth, F, dt)\n    \n    # --- 2. Initialize Ensemble ---\n    X_ens = x_truth[:, np.newaxis] + rng.normal(scale=sigma_init, size=(n, m))\n\n    # --- 3. Observation Setup ---\n    obs_indices = np.arange(0, n, 2)\n    p = len(obs_indices)\n    H = np.zeros((p, n))\n    H[np.arange(p), obs_indices] = 1.0\n    R = np.eye(p) * obs_var\n\n    # --- 4. Localization Matrix ---\n    L = create_localization_matrix(n, r_loc)\n    \n    rmses = []\n\n    # --- 5. Assimilation Loop ---\n    for k in range(n_cycles):\n        # Forecast step\n        for _ in range(n_steps_per_cycle):\n            x_truth = rk4_step(x_truth, F, dt)\n            X_ens = rk4_step(X_ens, F, dt)\n            if np.any(np.abs(x_truth) > b_max) or np.any(np.abs(X_ens) > b_max):\n                return False\n\n        # Analysis step\n        # Create observation\n        y_obs = H @ x_truth + rng.normal(scale=np.sqrt(obs_var), size=p)\n\n        # Inflation\n        x_mean_f = np.mean(X_ens, axis=1)\n        A_f = X_ens - x_mean_f[:, np.newaxis]\n        A_f_inflated = A_f * lambda_inf\n        X_ens_f_inflated = x_mean_f[:, np.newaxis] + A_f_inflated\n        \n        # Forecast error covariance\n        P_f = (1.0 / (m - 1)) * (A_f_inflated @ A_f_inflated.T)\n\n        # Localization\n        P_f_loc = L * P_f\n        \n        # Kalman Gain\n        S = H @ P_f_loc @ H.T + R\n        K = P_f_loc @ H.T @ np.linalg.inv(S)\n\n        # Update each member with perturbed observations\n        y_pert = y_obs[:, np.newaxis] + rng.normal(scale=np.sqrt(obs_var), size=(p, m))\n        \n        X_ens_a = X_ens_f_inflated + K @ (y_pert - H @ X_ens_f_inflated)\n        X_ens = X_ens_a\n        \n        if np.any(np.abs(X_ens) > b_max):\n            return False\n\n        # Calculate analysis RMSE\n        x_mean_a = np.mean(X_ens, axis=1)\n        rmse = np.sqrt(np.mean((x_mean_a - x_truth)**2))\n        rmses.append(rmse)\n\n    # --- 6. Final Stability Check ---\n    mean_rmse_last_half = np.mean(rmses[n_cycles // 2:])\n    if mean_rmse_last_half > rmse_thresh:\n        return False\n        \n    return True\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem, running experiments for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test 1: no localization, no inflation\n        {'r_loc': np.inf, 'lambda_inf': 1.0},\n        # Test 2: no localization, moderate inflation\n        {'r_loc': np.inf, 'lambda_inf': 1.05},\n        # Test 3: moderate localization, slight inflation\n        {'r_loc': 2.0, 'lambda_inf': 1.02},\n        # Test 4: very small localization, no inflation\n        {'r_loc': 1.0, 'lambda_inf': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        is_stable = run_enkf_experiment(r_loc=case['r_loc'], lambda_inf=case['lambda_inf'])\n        results.append(is_stable)\n\n    # Format the final output as a comma-separated list of booleans\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}