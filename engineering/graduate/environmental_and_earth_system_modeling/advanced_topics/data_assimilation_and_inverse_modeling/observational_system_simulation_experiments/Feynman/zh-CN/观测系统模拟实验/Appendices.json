{
    "hands_on_practices": [
        {
            "introduction": "任何观测系统模拟实验（OSSE）的核心都是前向算子 $H$，它模拟了观测过程。本练习将超越简单的插值，为一个Argo剖面浮标构建一个物理上真实的前向算子 。通过对仪器的上升过程和传感器响应进行建模，您将获得将理想化的模型状态转化为反映真实世界测量复杂性的合成观测的实践经验。",
            "id": "3805663",
            "problem": "你的任务是在计算海洋学领域为观测系统模拟实验 (OSSEs) 设计并实现一个正向算子，该算子将一维海洋模型状态映射到类似于 Argo 剖面浮标温度测量的合成观测值。该正向算子必须包含从模型网格到连续深度的垂直插值，并考虑仪器沿上升轨迹的测量响应特性。\n\n使用的基本假设和定义：\n- 观测系统模拟实验 (OSSE) 将观测值表示为作用于模型状态的正向算子的输出，并加上潜在的测量误差和代表性误差。正向算子以物理上一致的方式将状态变量映射到观测物理量。\n- 一个 Argo 剖面浮标以恒定的垂直速度在水体中上升，并使用具有有限响应时间的一阶传感器测量原位温度。因此，在给定深度报告的温度不是一个完美的瞬时样本，而是一个受浮标运动和传感器动力学影响的、经过垂直滤波的量。\n\n模型状态与海洋情景：\n- 考虑一个一维垂直模型，其深度坐标 $z$ 的单位为米，其中 $z=0$ 对应海面，$z$ 值的增加对应更深的水域。\n- 合成的“真实”海洋温度剖面定义在一个离散的模型网格上，其 $z$ 值范围从 $z_{\\min} = 0$ 到 $z_{\\max} = 2000$，均匀间距为 $\\Delta z = 20$ 米。温度场由下式给出：\n$$\nT(z) = T_0 - \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{z - z_0}{w}\\right)\\right),\n$$\n参数为 $T_0 = 20$ (摄氏度)，$\\Delta T = 16$ (摄氏度)，$z_0 = 300$ (米)，以及 $w = 80$ (米)。这代表了一个从温暖表层水到较冷深层水的现实温跃层过渡。\n\n测量响应与正向算子要求：\n- 在观测深度 $d$ 处，正向算子必须是根据一个具有物理动机的测量核对 $T(z)$ 进行垂直滤波后的值。两个独立的物理效应对该核有贡献：\n  1. 一个对称的空间平均分量，由标准差为 $\\sigma_g$（单位：米）的高斯核建模，\n  $$\n  G_\\sigma(z - d) = \\exp\\!\\left(-\\frac{(z - d)^2}{2\\sigma_g^2}\\right).\n  $$\n  2. 一个单边指数分量，源于时间常数为 $\\tau$（单位：秒）、上升速度为 $v$（单位：米/秒）的一阶传感器响应。乘积 $L = v\\tau$（单位：米）是特征垂直响应长度。对于一个上升的浮标，其在深度 $d$ 的测量值会受到更深处 $z \\ge d$ 水体的影响，权重如下\n  $$\n  E_L(z - d) = \n  \\begin{cases}\n  \\exp\\!\\left(-\\frac{z - d}{L}\\right),  & z \\ge d, \\\\\n  0,  & z  d.\n  \\end{cases}\n  $$\n- 在深度 $d$ 处的组合测量核是以下两项的乘积：\n$$\nK(d, z) = G_\\sigma(z - d)\\,E_L(z - d),\n$$\n它必须在计算的有限域上进行归一化。\n- 在深度 $d$ 处的合成观测值必须计算为 $T(z)$ 与 $K(d, z)$ 在 $z$ 上的归一化加权积分：\n$$\ny(d) = \\frac{\\int_{z_{\\min}}^{z_{\\max}} T(z)\\,K(d, z)\\,dz}{\\int_{z_{\\min}}^{z_{\\max}} K(d, z)\\,dz}.\n$$\n- 垂直插值：由于 $T(z)$ 是在离散的模型层上定义的，你的正向算子必须在应用核积分之前，首先将 $T(z)$ 垂直插值到一个更精细的计算网格上。使用分段线性插值在一个能充分解析核函数的精细网格上生成 $T(z)$。你可以选择一个精细网格间距 $\\delta z$（单位：米）来确保数值精度。\n- 必须处理的极限情况：\n  - 如果 $\\tau = 0$，则 $L = 0$，指数分量退化为无滤波；核函数必须退化为仅有高斯分量。如果此外 $\\sigma_g = 0$，核函数将退化为狄拉克 $\\delta$ 函数，而正向算子则退化为在 $d$ 处对 $T(z)$ 进行简单的线性插值。\n  - 如果 $\\sigma_g = 0$ 且 $\\tau  0$，核函数纯粹是由仪器响应引起的单边指数形式。\n\n数值单位和输出要求：\n- 深度单位为米。速度 $v$ 单位为米/秒。时间常数 $\\tau$ 单位为秒。温度必须以摄氏度为单位计算和报告，并表示为浮点小数。\n- 本问题不涉及角度。\n- 本问题不涉及百分比。\n\n测试套件：\n实现您的程序，为以下参数集和观测深度计算合成观测值。对于每个参数集，计算所有指定深度 $d_j$ 的合成观测值 $y(d_j)$，并将所有结果（按下列顺序列出）汇总到一个扁平列表中。\n\n1. 正常路径情况：中等仪器平滑。\n   - 上升速度 $v = 0.08$ (米/秒)，响应时间 $\\tau = 10$ (秒)，高斯宽度 $\\sigma_g = 2$ (米)，精细网格间距 $\\delta z = 1$ (米)，深度 $[50, 300, 1000]$ (米)。\n2. 边界近表层情况：纯指数核（无高斯）。\n   - 上升速度 $v = 0.06$ (米/秒)，响应时间 $\\tau = 30$ (秒)，高斯宽度 $\\sigma_g = 0$ (米)，精细网格间距 $\\delta z = 1$ (米)，深度 $[5]$ (米)。\n3. 退化核情况：纯插值（无平滑）。\n   - 上升速度 $v = 0.10$ (米/秒)，响应时间 $\\tau = 0$ (秒)，高斯宽度 $\\sigma_g = 0$ (米)，精细网格间距 $\\delta z = 1$ (米)，深度 $[123.4]$ (米)。\n4. 强平滑和近底情况：组合高斯和指数，包括近域边界。\n   - 上升速度 $v = 0.08$ (米/秒)，响应时间 $\\tau = 60$ (秒)，高斯宽度 $\\sigma_g = 8$ (米)，精细网格间距 $\\delta z = 1$ (米)，深度 $[800, 1500, 1950]$ (米)。\n\n算法设计约束：\n- 您必须完全按照描述实现正向算子：将离散的模型温度剖面 $T(z)$ 插值到一个精细网格上，并在截断的域上对归一化的核积分进行数值评估。在实际使用的域上对核函数进行重新归一化，以避免边界附近的偏差。\n- 明确地处理所有极限情况，并与物理推理保持一致。\n- 不要使用任何外部数据；必须按原样使用提供的合成温度剖面和参数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有计算出的合成观测值，以摄氏度表示，并按照所有参数集中描述的深度顺序汇总成一个用方括号括起来的逗号分隔列表（例如，$[y_1,y_2,\\dots,y_N]$）。每个值都必须是浮点小数。不得打印任何其他文本。",
            "solution": "所提出的问题陈述是有效的。它在科学上基于物理海洋学和仪器测量的原理，问题定义明确，提供了所有必要的信息和约束，并且其表述是客观的。任务是为一个观测系统模拟实验 (OSSE) 构建一个数值正向算子，这是地球科学中用于评估观测系统潜在影响的一种标准技术。\n\n正向算子（记为 $y(d)$）将模型状态——一个垂直温度剖面 $T(z)$——映射到指定深度 $d$ 处的合成观测值。此过程模拟了上升中的 Argo 剖面浮标所进行的测量，并包含了空间平均和传感器时间响应的物理效应。\n\n将根据所提供的数学和算法规范来实现正向算子，从而解决该问题。步骤如下：\n1.  在离散模型网格上定义合成的“真实”海洋状态。\n2.  实现一个分段线性插值方案，以在一个更精细的计算网格上表示温度剖面。\n3.  通过组合其高斯和指数分量来构建测量核 $K(d, z)$，并仔细处理指定的极限情况。\n4.  通过对插值后的温度剖面与核函数进行归一化加权积分的数值评估，来计算合成观测值 $y(d)$。\n\n**1. 海洋模型状态**\n\n合成海洋由一维垂直温度剖面 $T(z)$ 描述，其中 $z$ 是以米为单位的深度。海面位于 $z=0$。“真实”温度由以下函数给出：\n$$\nT(z) = T_0 - \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{z - z_0}{w}\\right)\\right)\n$$\n提供的参数为 $T_0 = 20 \\,^{\\circ}\\text{C}$，$\\Delta T = 16 \\,^{\\circ}\\text{C}$，$z_0 = 300 \\, \\text{m}$ 和 $w = 80 \\, \\text{m}$。该函数模拟了一个以深度 $z_0$ 为中心的温跃层，即一个温度快速变化的区域。\n\n该连续剖面最初定义在一个离散模型网格上，其深度 $z_m$ 范围从 $z_{\\min} = 0 \\, \\text{m}$ 到 $z_{\\max} = 2000 \\, \\text{m}$，均匀间距为 $\\Delta z = 20 \\, \\text{m}$。\n\n**2. 正向算子与测量核**\n\n在观测深度 $d$ 处的合成观测值 $y(d)$ 是温度剖面 $T(z)$ 经过测量核 $K(d, z)$ 滤波的结果，数学上表示为一个归一化积分：\n$$\ny(d) = \\frac{\\int_{z_{\\min}}^{z_{\\max}} T(z)\\,K(d, z)\\,dz}{\\int_{z_{\\min}}^{z_{\\max}} K(d, z)\\,dz}\n$$\n通过在计算域 $[z_{\\min}, z_{\\max}]$ 上对核函数积分进行归一化，对于防止偏差至关重要，特别是对于域边界附近的观测，因为在这些地方核函数可能会被截断。\n\n核函数 $K(d, z)$ 是两个分量的乘积：$K(d, z) = G_\\sigma(z - d) \\cdot E_L(z - d)$。\n\n-   高斯分量 $G_\\sigma$ 模拟对称空间平均：\n    $$\n    G_\\sigma(z - d) = \\exp\\!\\left(-\\frac{(z - d)^2}{2\\sigma_g^2}\\right)\n    $$\n    其中 $\\sigma_g$ 是以米为单位的标准差。\n\n-   单边指数分量 $E_L$ 模拟上升传感器的一阶响应：\n    $$\n    E_L(z - d) = \n    \\begin{cases}\n    \\exp\\!\\left(-\\frac{z - d}{L}\\right),   \\text{for } z \\ge d \\\\\n    0,   \\text{for } z  d\n    \\end{cases}\n    $$\n    这里，$L = v\\tau$ 是特征响应长度，其中 $v$ 是浮标的上升速度，$\\tau$ 是传感器的时间常数。这一项反映了在深度 $d$ 处的测量受到浮标刚刚经过的更深水域 ($z \\ge d$) 的影响。\n\n**3. 数值实现**\n\n$y(d)$ 的连续积分通过数值方法进行近似。\n\n**步骤 A：插值到精细网格**\n模型仅在离散深度 $z_m$ 处提供温度值。为了精确解析核函数，我们首先创建一个间距很小（例如 $\\delta z = 1 \\, \\text{m}$）的精细计算网格 $z_{fine}$。然后，使用分段线性插值将温度剖面从粗糙的模型网格插值到这个精细网格上。这样，对于精细网格上的每个点 $z_i$，我们都得到了一个高分辨率的剖面 $T_{fine}(z_i)$。\n\n**步骤 B：核函数评估与极限情况**\n对于给定的观测深度 $d$，在精细网格的每个点 $z_i$ 处评估核函数 $K(d, z_i)$。实现过程必须正确处理规定的极限情况：\n-   **一般情况 ($\\sigma_g  0, \\tau  0$):** 计算高斯和指数分量并将它们相乘以形成核函数。\n-   **纯指数情况 ($\\sigma_g = 0, \\tau  0$):** 问题陈述指出核函数退化为指数分量 $E_L(z-d)$。这通过将高斯因子视为一来处理。\n-   **纯高斯情况 ($\\sigma_g  0, \\tau = 0$):** 问题陈述指出指数分量退化为“无滤波”。这通过将指数因子视为一来处理。\n-   **退化情况 ($\\sigma_g = 0, \\tau = 0$):** 问题明确指出核函数退化为狄拉克 $\\delta$ 函数，而正向算子则退化为在深度 $d$ 处对 $T(z)$ 进行简单的线性插值。这种情况必须单独处理，绕过核积分，直接从原始模型网格插值温度。\n\n**步骤 C：数值积分（加权平均）**\n归一化积分近似为在精细网格点 $z_i$ 上的离散加权和：\n$$\ny(d) \\approx \\frac{\\sum_{i} T_{fine}(z_i) \\cdot K(d, z_i) \\cdot \\delta z}{\\sum_{i} K(d, z_i) \\cdot \\delta z} = \\frac{\\sum_{i} T_{fine}(z_i) \\cdot K(d, z_i)}{\\sum_{i} K(d, z_i)}\n$$\n这等同于对精细网格上的温度进行加权平均，其中权重由核函数的值给出。此计算将针对每个所需的观测深度 $d$ 和每组参数 $(v, \\tau, \\sigma_g)$ 执行。然后按要求将结果汇总到单个列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute synthetic observations for all test cases.\n    \"\"\"\n    \n    # Define model parameters as specified in the problem statement.\n    T0 = 20.0     # degrees Celsius\n    DT = 16.0     # degrees Celsius\n    z0 = 300.0    # meters\n    w = 80.0      # meters\n    z_min = 0.0   # meters\n    z_max = 2000.0 # meters\n    dz_model = 20.0 # meters\n\n    # Create the discrete model grid and compute the \"true\" temperature profile on it.\n    z_model = np.arange(z_min, z_max + dz_model, dz_model)\n    T_model = T0 - DT * 0.5 * (1 + np.tanh((z_model - z0) / w))\n    \n    # Define a reusable function for the forward operator.\n    def forward_operator(obs_depths, v, tau, sigma_g, dz_fine, z_model_grid, T_model_profile):\n        \"\"\"\n        Computes synthetic observations for a set of depths and parameters.\n\n        Args:\n            obs_depths (list): List of observation depths in meters.\n            v (float): Ascent speed in m/s.\n            tau (float): Sensor time constant in seconds.\n            sigma_g (float): Gaussian standard deviation in meters.\n            dz_fine (float): Fine-grid spacing in meters.\n            z_model_grid (np.ndarray): The model depth grid.\n            T_model_profile (np.ndarray): The temperature profile on the model grid.\n\n        Returns:\n            list: A list of computed synthetic observation values.\n        \"\"\"\n        \n        # Handle the degenerate case: pure interpolation (no smoothing)\n        if tau == 0.0 and sigma_g == 0.0:\n            # As per problem, this reduces to simple linear interpolation of T(z) at d.\n            return [np.interp(d, z_model_grid, T_model_profile) for d in obs_depths]\n\n        # Create the fine evaluation grid\n        z_fine = np.arange(z_model_grid[0], z_model_grid[-1] + dz_fine, dz_fine)\n        \n        # Interpolate the model temperature to the fine grid\n        T_fine = np.interp(z_fine, z_model_grid, T_model_profile)\n        \n        results = []\n        for d in obs_depths:\n            # Initialize kernel as an array of ones\n            kernel = np.ones_like(z_fine)\n            \n            # 1. Gaussian component\n            if sigma_g  0:\n                gaussian_term = np.exp(-((z_fine - d)**2) / (2 * sigma_g**2))\n                kernel *= gaussian_term\n            \n            # 2. Exponential component\n            if tau  0:\n                L = v * tau\n                if L  0: # Avoid division by zero if v=0\n                    exp_term = np.zeros_like(z_fine)\n                    # Apply for z = d, as per definition of E_L(z-d)\n                    mask = z_fine = d\n                    exp_term[mask] = np.exp(-(z_fine[mask] - d) / L)\n                    kernel *= exp_term\n                # if L=0 (from v=0, tau0), exp_term remains zero, effectively nullifying the signal, which is physically consistent.\n            \n            # Compute the normalized weighted average\n            numerator = np.sum(T_fine * kernel)\n            denominator = np.sum(kernel)\n            \n            # Avoid division by zero, though unlikely with the given parameters.\n            if denominator  0:\n                y_d = numerator / denominator\n            else:\n                # If kernel is zero everywhere, interpolate as a fallback.\n                y_d = np.interp(d, z_fine, T_fine)\n            \n            results.append(y_d)\n            \n        return results\n\n    # Test suite parameters\n    test_cases = [\n        # 1. Happy-path case: Moderate instrument smoothing.\n        {'v': 0.08, 'tau': 10, 'sigma_g': 2, 'dz_fine': 1, 'depths': [50, 300, 1000]},\n        # 2. Boundary near-surface case: Purely exponential kernel (no Gaussian).\n        {'v': 0.06, 'tau': 30, 'sigma_g': 0, 'dz_fine': 1, 'depths': [5]},\n        # 3. Degenerate kernel case: Pure interpolation (no smoothing).\n        {'v': 0.10, 'tau': 0, 'sigma_g': 0, 'dz_fine': 1, 'depths': [123.4]},\n        # 4. Strong smoothing and near-bottom case: Combined Gaussian and exponential.\n        {'v': 0.08, 'tau': 60, 'sigma_g': 8, 'dz_fine': 1, 'depths': [800, 1500, 1950]},\n    ]\n    \n    all_results = []\n    for case in test_cases:\n        results_for_case = forward_operator(\n            obs_depths=case['depths'], \n            v=case['v'], \n            tau=case['tau'], \n            sigma_g=case['sigma_g'],\n            dz_fine=case['dz_fine'],\n            z_model_grid=z_model, \n            T_model_profile=T_model\n        )\n        all_results.extend(results_for_case)\n\n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个真实的OSSE需要一个复杂的观测误差模型，该模型封装在误差协方差矩阵 $R$ 中。本练习  侧重于通过组合不相关的仪器噪声和空间相关的代表性误差来构建 $R$ 矩阵。您将通过使用斜压变形半径来定义误差相关长度，从而将抽象的统计概念与物理海洋学联系起来，这是设计可靠的模拟实验的一项关键技能。",
            "id": "3805690",
            "problem": "在观测系统模拟实验 (OSSEs) 的背景下，考虑一个一维沿轨集合，包含三个海面高度观测位置，其坐标分别为 $x_1=0\\,\\mathrm{km}$、$x_2=20\\,\\mathrm{km}$ 和 $x_3=50\\,\\mathrm{km}$。观测系统是一个沿轨卫星高度计，它对一个高分辨率海洋模型进行采样，其数据随后被稀疏化到一个较粗的分析网格上。总观测误差被建模为两个分量的和：一个是空间不相关且方差已知的仪器噪声 $\\sigma^2$，另一个是由未分辨的中尺度变率引起的空间相关的代表性误差。假设仪器噪声方差为 $\\sigma^2=4.0\\times 10^{-4}\\,\\mathrm{m}^2$，代表性误差协方差函数是各向同性的，由下式给出\n$$\nC(r)=\\sigma_r^2 \\exp\\!\\left(-\\frac{r}{L}\\right),\n$$\n其中代表性误差方差为 $\\sigma_r^2=2.5\\times 10^{-3}\\,\\mathrm{m}^2$，相关长度 $L$ 未知。\n\n在约化重力、第一斜压模框架下，利用相速度 $c$ 和科里奥利参数 $f$ 估算斜压变形半径 $R_1$，其中 $c=\\sqrt{g' H}$ 且 $R_1=c/f$。取约化重力 $g'=2.0\\times 10^{-2}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，上层厚度 $H=100\\,\\mathrm{m}$，以及中纬度科里奥利参数 $f=1.0\\times 10^{-4}\\,\\mathrm{s}^{-1}$。从第一性原理出发，论证在此 OSSE 配置中，对于中尺度主导的代表性误差，将代表性相关长度 $L$ 设置为等于斜压变形半径 $R_1$ 的物理合理性。\n\n然后，对于给定的观测位置，构建完整的 $3\\times 3$ 观测误差协方差矩阵 $R$，该矩阵结合了不相关的仪器噪声和相关的代表性误差。将 $R$ 的所有元素以 $\\mathrm{m}^2$ 为单位表示，并将每个元素四舍五入到四位有效数字。你的最终答案必须仅为矩阵 $R$。",
            "solution": "该问题被评估为有效。它在科学上基于物理海洋学和数据同化的原理，问题陈述清晰且信息充分，可得到唯一解，并以客观、正式的语言表述。解题过程分三个阶段：首先，计算斜压变形半径 $R_1$；其次，为将代表性误差相关长度 $L$ 等同于 $R_1$ 提供物理解释；第三，构建总观测误差协方差矩阵 $R$。\n\n阶段1：计算斜压变形半径 $R_1$\n\n第一斜压罗斯贝变形半径 $R_1$ 定义为第一斜压模重力波相速度 $c$ 与科里奥利参数 $f$ 之比。已知条件为：\n- 约化重力 $g' = 2.0 \\times 10^{-2}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$\n- 上层厚度 $H = 100\\,\\mathrm{m}$\n- 科里奥利参数 $f = 1.0 \\times 10^{-4}\\,\\mathrm{s}^{-1}$\n\n首先，我们计算相速度 $c$：\n$$\nc = \\sqrt{g' H} = \\sqrt{(2.0 \\times 10^{-2}\\,\\mathrm{m}\\,\\mathrm{s}^{-2}) \\times (100\\,\\mathrm{m})} = \\sqrt{2.0}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}\n$$\n接着，我们计算变形半径 $R_1$：\n$$\nR_1 = \\frac{c}{f} = \\frac{\\sqrt{2.0}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}}{1.0 \\times 10^{-4}\\,\\mathrm{s}^{-1}} = \\sqrt{2.0} \\times 10^4\\,\\mathrm{m}\n$$\n为了在协方差计算中方便使用，我们将其转换为千米：\n$$\nR_1 = \\sqrt{2.0} \\times 10^4\\,\\mathrm{m} = 10\\sqrt{2}\\,\\mathrm{km} \\approx 14.14\\,\\mathrm{km}\n$$\n\n阶段2：将 $L = R_1$ 的物理解释\n\n问题指出，代表性误差源于未分辨的中尺度变率。这个误差分量量化了点观测与代表更大面积或体积的粗分辨率模型状态变量值之间的差异。在 OSSE 的背景下，“真实情况”是一个解析了中尺度特征的高分辨率自然运行（nature run），而分析则是在一个无法解析这些特征的较粗网格上进行的。\n\n在中纬度海洋中，数十至数百公里尺度上动能变率的主要形式与中尺度涡和流弯有关。控制这些特征大小的基本水平长度尺度是第一斜压罗斯贝变形半径 $R_1$。斜压不稳定性是产生中尺度涡的主要机制，在与 $R_1$ 成正比的波长上最为有效。由此产生的涡旋具有一个特征半径，因此其空间相干尺度也在 $R_1$ 的量级。\n\n由于本问题中的代表性误差明确归因于未分辨的中尺度变率，其统计特性，特别是其空间相关结构，必须反映该变率的物理机制。因此，误差场的相关长度尺度 $L$ 应对应于未分辨特征的特征尺寸。由于 $R_1$ 是这些中尺度涡的自然长度尺度，在海洋数据同化中，将代表性误差相关长度 $L$ 设置为等于第一斜压变形半径 $R_1$ 是一种行之有效且物理上合理的做法。因此，我们设定 $L=R_1=10\\sqrt{2}\\,\\mathrm{km}$。\n\n阶段3：构建观测误差协方差矩阵 $R$\n\n总观测误差协方差矩阵 $R$ 是仪器噪声协方差矩阵 $R_{instr}$ 和代表性误差协方差矩阵 $R_{rep}$ 的和：\n$$\nR = R_{instr} + R_{rep}\n$$\n观测位置为 $x_1=0\\,\\mathrm{km}$、$x_2=20\\,\\mathrm{km}$ 和 $x_3=50\\,\\mathrm{km}$。\n\n仪器噪声是空间不相关的，其方差为 $\\sigma^2 = 4.0 \\times 10^{-4}\\,\\mathrm{m}^2$。其协方差矩阵为对角矩阵：\n$$\nR_{instr} = \\sigma^2 I_3 = \\begin{pmatrix} \\sigma^2  0  0 \\\\ 0  \\sigma^2  0 \\\\ 0  0  \\sigma^2 \\end{pmatrix} = \\begin{pmatrix} 4.0 \\times 10^{-4}  0  0 \\\\ 0  4.0 \\times 10^{-4}  0 \\\\ 0  0  4.0 \\times 10^{-4} \\end{pmatrix}\\,\\mathrm{m}^2\n$$\n\n代表性误差是空间相关的。其协方差矩阵的元素 $(R_{rep})_{ij}$ 由协方差函数 $C(r_{ij}) = \\sigma_r^2 \\exp(-r_{ij}/L)$ 给出，其中 $r_{ij} = |x_i - x_j|$ 是观测点 $i$ 和 $j$ 之间的距离。我们有 $\\sigma_r^2 = 2.5 \\times 10^{-3}\\,\\mathrm{m}^2$ 和 $L=10\\sqrt{2}\\,\\mathrm{km}$。\n首先，我们以千米为单位计算距离矩阵 $r_{ij}$：\n$$\nr_{12} = |x_1 - x_2| = |0 - 20| = 20\\,\\mathrm{km}\n$$\n$$\nr_{13} = |x_1 - x_3| = |0 - 50| = 50\\,\\mathrm{km}\n$$\n$$\nr_{23} = |x_2 - x_3| = |20 - 50| = 30\\,\\mathrm{km}\n$$\n根据对称性，$r_{ji}=r_{ij}$，且 $r_{ii}=0$。\n\n$R_{rep}$ 的对角元素是方差 $\\sigma_r^2$：\n$$\n(R_{rep})_{11} = (R_{rep})_{22} = (R_{rep})_{33} = C(0) = \\sigma_r^2 \\exp(0) = 2.5 \\times 10^{-3}\\,\\mathrm{m}^2\n$$\n非对角元素为：\n$$\n(R_{rep})_{12} = (R_{rep})_{21} = C(20) = (2.5 \\times 10^{-3}) \\exp\\left(-\\frac{20}{10\\sqrt{2}}\\right) = (2.5 \\times 10^{-3}) \\exp(-\\sqrt{2}) \\approx 6.07796 \\times 10^{-4}\\,\\mathrm{m}^2\n$$\n$$\n(R_{rep})_{13} = (R_{rep})_{31} = C(50) = (2.5 \\times 10^{-3}) \\exp\\left(-\\frac{50}{10\\sqrt{2}}\\right) = (2.5 \\times 10^{-3}) \\exp\\left(-\\frac{5}{\\sqrt{2}}\\right) \\approx 7.28601 \\times 10^{-5}\\,\\mathrm{m}^2\n$$\n$$\n(R_{rep})_{23} = (R_{rep})_{32} = C(30) = (2.5 \\times 10^{-3}) \\exp\\left(-\\frac{30}{10\\sqrt{2}}\\right) = (2.5 \\times 10^{-3}) \\exp\\left(-\\frac{3}{\\sqrt{2}}\\right) \\approx 2.99651 \\times 10^{-4}\\,\\mathrm{m}^2\n$$\n\n现在我们将 $R_{instr}$ 和 $R_{rep}$ 相加得到 $R$。元素 $R_{ij}$ 由 $R_{ij} = (R_{instr})_{ij} + (R_{rep})_{ij}$ 给出。\n对角元素为：\n$$\nR_{11} = R_{22} = R_{33} = \\sigma^2 + \\sigma_r^2 = (4.0 \\times 10^{-4}) + (2.5 \\times 10^{-3}) = (0.4 \\times 10^{-3}) + (2.5 \\times 10^{-3}) = 2.9 \\times 10^{-3}\\,\\mathrm{m}^2\n$$\n由于 $R_{instr}$ 是对角矩阵，非对角元素就是 $R_{rep}$ 的元素。将所有元素四舍五入到四位有效数字：\n$R_{11} = R_{22} = R_{33} = 2.900 \\times 10^{-3}\\,\\mathrm{m}^2$\n$R_{12} = R_{21} \\approx 6.078 \\times 10^{-4}\\,\\mathrm{m}^2$\n$R_{13} = R_{31} \\approx 7.286 \\times 10^{-5}\\,\\mathrm{m}^2$\n$R_{23} = R_{32} \\approx 2.997 \\times 10^{-4}\\,\\mathrm{m}^2$\n\n最终的观测误差协方差矩阵 $R$ 是：\n$$\nR = \\begin{pmatrix}\n2.900 \\times 10^{-3}  6.078 \\times 10^{-4}  7.286 \\times 10^{-5} \\\\\n6.078 \\times 10^{-4}  2.900 \\times 10^{-3}  2.997 \\times 10^{-4} \\\\\n7.286 \\times 10^{-5}  2.997 \\times 10^{-4}  2.900 \\times 10^{-3}\n\\end{pmatrix}\n$$\n所有元素的单位都是 $\\mathrm{m}^2$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.900 \\times 10^{-3}  6.078 \\times 10^{-4}  7.286 \\times 10^{-5} \\\\\n6.078 \\times 10^{-4}  2.900 \\times 10^{-3}  2.997 \\times 10^{-4} \\\\\n7.286 \\times 10^{-5}  2.997 \\times 10^{-4}  2.900 \\times 10^{-3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "要真正掌握OSSE的设计，必须理解误差的基本来源。这项高级练习  将引导您从第一性原理出发，推导由观测足迹和模型网格单元之间的尺度不匹配引起的代表性误差。通过使用谱分析，您将对不同空间尺度如何导致观测不确定性形成严谨的、定量的理解，这是评估和改进观测系统设计的有力工具。",
            "id": "3900285",
            "problem": "您将实现并评估一个观测系统模拟实验（OSSE）计算，该计算针对一个平稳地球物理场，分析由观测仪器足迹与模型网格单元平均之间的尺度不匹配所引起的代表性误差。请从平稳随机场和谱表示的第一性原理出发。\n\n假设在二维平面上有一个标量、零均值、统计均匀且各向同性的地球物理场，其协方差函数由高斯核给出，\n$$\nC(\\mathbf{r}) = \\sigma^{2} \\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{2 \\ell^{2}}\\right),\n$$\n其中 $\\sigma$ 是以 $\\mathrm{K}$ 为单位的逐点标准差，$\\ell$ 是以 $\\mathrm{km}$ 为单位的相关长度。观测值是该场与一个归一化高斯足迹的卷积，\n$$\nh_{o}(\\mathbf{x}) = \\frac{1}{2\\pi s_{o}^{2}} \\exp\\!\\left(-\\frac{\\|\\mathbf{x}\\|^{2}}{2 s_{o}^{2}}\\right),\n$$\n而模型值是与代表模型网格单元有效平均的归一化高斯的卷积，\n$$\nh_{m}(\\mathbf{x}) = \\frac{1}{2\\pi s_{m}^{2}} \\exp\\!\\left(-\\frac{\\|\\mathbf{x}\\|^{2}}{2 s_{m}^{2}}\\right),\n$$\n其中 $s_{o}$ 和 $s_{m}$ 的单位均为 $\\mathrm{km}$。代表性误差定义为在同一位置这两个滤波后场的差值，\n$$\n\\varepsilon = (h_{o} \\ast X)(\\mathbf{0}) - (h_{m} \\ast X)(\\mathbf{0}).\n$$\n\n任务：\n- 仅使用平稳随机场、卷积、二维傅里叶变换和 Parseval 定理的基本定义，推导代表性误差方差的一个显式闭合形式表达式，\n$$\n\\mathrm{Var}[\\varepsilon] = \\mathbb{E}[\\varepsilon^{2}],\n$$\n该表达式是关于 $\\sigma$、$\\ell$、$s_{o}$ 和 $s_{m}$ 的函数。您的推导必须按照上述规定处理协方差和平均核，并且必须对任何非负的 $s_{o}$ 和 $s_{m}$ 以及正的 $\\ell$ 和 $\\sigma$ 都有效。\n- 实现一个程序，用于评估均方根代表性误差，\n$$\ne = \\sqrt{\\mathrm{Var}[\\varepsilon]},\n$$\n该误差以 $\\mathrm{K}$ 为单位表示，并针对一个提供的测试套件进行计算。所有距离（$\\ell$、$s_{o}$、$s_{m}$）的单位均为 $\\mathrm{km}$。将报告的每个 $e$ 值四舍五入到恰好 $6$ 位小数。\n\n测试套件（每个元组为 $(\\sigma \\ \\mathrm{K}, \\ \\ell \\ \\mathrm{km}, \\ s_{o} \\ \\mathrm{km}, \\ s_{m} \\ \\mathrm{km})$）：\n- 案例 A（一般不匹配）：$(1.5, \\ 50, \\ 10, \\ 30)$\n- 案例 B（无不匹配，边界情况）：$(2.0, \\ 100, \\ 20, \\ 20)$\n- 案例 C（模型点值与足迹对比）：$(1.0, \\ 30, \\ 15, \\ 0)$\n- 案例 D（非常大的相关长度）：$(1.2, \\ 500, \\ 25, \\ 40)$\n- 案例 E（非常短的相关长度）：$(2.5, \\ 5, \\ 20, \\ 40)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述案例相同。例如，包含三个案例的输出应类似于 $[e_{1},e_{2},e_{3}]$，但每个 $e_{i}$ 都需四舍五入到 $6$ 位小数，且无任何附加文本。\n\n覆盖性设计：\n- 案例 A 测试典型的尺度不匹配。\n- 案例 B 是一个边界条件，对于任何 $\\sigma$ 和 $\\ell$，代表性误差必须恰好为零。\n- 案例 C 测试使用点状模型值与平均后观测值进行对比的效果。\n- 案例 D 探究 $\\ell \\gg s_{o}, s_{m}$ 的极限情况。\n- 案例 E 探究 $\\ell \\ll s_{o}, s_{m}$ 的极限情况。\n\n所有输出均须以 $\\mathrm{K}$ 为单位，并四舍五入到恰好 $6$ 位小数。",
            "solution": "我们对一个观测系统模拟实验（OSSE）的代表性误差进行建模，该误差是同个平稳场经过两种不同滤波后的版本之间的差异。设 $X(\\mathbf{x})$ 是 $\\mathbb{R}^{2}$ 上的一个零均值、统计均匀且各向同性的场，其协方差为\n$$\nC(\\mathbf{r}) = \\mathbb{E}[X(\\mathbf{x}) X(\\mathbf{x}+\\mathbf{r})] = \\sigma^{2} \\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{2 \\ell^{2}}\\right).\n$$\n观测值和模型值是高斯平均场：\n$$\nY_{o}(\\mathbf{x}) = (h_{o} \\ast X)(\\mathbf{x}), \\quad Y_{m}(\\mathbf{x}) = (h_{m} \\ast X)(\\mathbf{x}),\n$$\n其中\n$$\nh_{o}(\\mathbf{x}) = \\frac{1}{2\\pi s_{o}^{2}} \\exp\\!\\left(-\\frac{\\|\\mathbf{x}\\|^{2}}{2 s_{o}^{2}}\\right), \\quad\nh_{m}(\\mathbf{x}) = \\frac{1}{2\\pi s_{m}^{2}} \\exp\\!\\left(-\\frac{\\|\\mathbf{x}\\|^{2}}{2 s_{m}^{2}}\\right),\n$$\n在原点处的代表性误差为\n$$\n\\varepsilon = Y_{o}(\\mathbf{0}) - Y_{m}(\\mathbf{0}).\n$$\n\n我们使用二维傅里叶变换，其约定如下\n$$\n\\mathcal{F}\\{f\\}(\\mathbf{k}) = \\int_{\\mathbb{R}^{2}} f(\\mathbf{x}) \\, e^{-i \\mathbf{k}\\cdot\\mathbf{x}} \\, d^{2}\\mathbf{x}, \\quad\nf(\\mathbf{x}) = \\frac{1}{(2\\pi)^{2}} \\int_{\\mathbb{R}^{2}} \\mathcal{F}\\{f\\}(\\mathbf{k}) \\, e^{i \\mathbf{k}\\cdot\\mathbf{x}} \\, d^{2}\\mathbf{k}.\n$$\n对于一个平稳场，功率谱密度 $S(\\mathbf{k})$ 是协方差 $C(\\mathbf{r})$ 的傅里叶变换：\n$$\nS(\\mathbf{k}) = \\int_{\\mathbb{R}^{2}} C(\\mathbf{r}) \\, e^{-i \\mathbf{k}\\cdot\\mathbf{r}} \\, d^{2}\\mathbf{r}.\n$$\n对于高斯协方差，\n$$\nC(\\mathbf{r}) = \\sigma^{2} \\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{2 \\ell^{2}}\\right),\n$$\n其二维傅里叶变换为\n$$\nS(\\mathbf{k}) = 2\\pi \\, \\sigma^{2} \\, \\ell^{2} \\exp\\!\\left(-\\frac{\\ell^{2} \\|\\mathbf{k}\\|^{2}}{2}\\right).\n$$\n归一化高斯平均核的傅里叶变换为\n$$\nH_{o}(\\mathbf{k}) = \\exp\\!\\left(-\\frac{s_{o}^{2} \\|\\mathbf{k}\\|^{2}}{2}\\right), \\quad\nH_{m}(\\mathbf{k}) = \\exp\\!\\left(-\\frac{s_{m}^{2} \\|\\mathbf{k}\\|^{2}}{2}\\right).\n$$\n\n代表性误差是两个滤波后场的差，因此在傅里叶空间中，有效滤波器为\n$$\nG(\\mathbf{k}) = H_{o}(\\mathbf{k}) - H_{m}(\\mathbf{k}) = \\exp\\!\\left(-\\frac{s_{o}^{2} \\|\\mathbf{k}\\|^{2}}{2}\\right) - \\exp\\!\\left(-\\frac{s_{m}^{2} \\|\\mathbf{k}\\|^{2}}{2}\\right).\n$$\n根据此傅里叶变换约定下的 Parseval 定理，一个零均值滤波后平稳场的方差为\n$$\n\\mathrm{Var}[\\varepsilon] = \\frac{1}{(2\\pi)^{2}} \\int_{\\mathbb{R}^{2}} |G(\\mathbf{k})|^{2} \\, S(\\mathbf{k}) \\, d^{2}\\mathbf{k}.\n$$\n利用各向同性，转换为极坐标，其中 $k = \\|\\mathbf{k}\\|$ 且 $d^{2}\\mathbf{k} = 2\\pi k \\, dk$，可得\n$$\n\\mathrm{Var}[\\varepsilon] = \\frac{1}{(2\\pi)^{2}} \\int_{0}^{\\infty} \\left[\\exp\\!\\left(-\\frac{s_{o}^{2} k^{2}}{2}\\right) - \\exp\\!\\left(-\\frac{s_{m}^{2} k^{2}}{2}\\right)\\right]^{2} \\, \\left(2\\pi \\sigma^{2} \\ell^{2} \\exp\\!\\left(-\\frac{\\ell^{2} k^{2}}{2}\\right)\\right) \\, 2\\pi k \\, dk.\n$$\n常数项简化为\n$$\n\\mathrm{Var}[\\varepsilon] = \\sigma^{2} \\ell^{2} \\int_{0}^{\\infty} \\left[\\exp\\!\\left(-\\frac{s_{o}^{2} k^{2}}{2}\\right) - \\exp\\!\\left(-\\frac{s_{m}^{2} k^{2}}{2}\\right)\\right]^{2} \\exp\\!\\left(-\\frac{\\ell^{2} k^{2}}{2}\\right) k \\, dk.\n$$\n展开平方项：\n$$\n\\left[\\exp\\!\\left(-\\frac{s_{o}^{2} k^{2}}{2}\\right) - \\exp\\!\\left(-\\frac{s_{m}^{2} k^{2}}{2}\\right)\\right]^{2}\n= \\exp\\!\\left(- s_{o}^{2} k^{2}\\right) - 2 \\exp\\!\\left(-\\frac{(s_{o}^{2}+s_{m}^{2}) k^{2}}{2}\\right) + \\exp\\!\\left(- s_{m}^{2} k^{2}\\right).\n$$\n因此\n$$\n\\mathrm{Var}[\\varepsilon] = \\sigma^{2} \\ell^{2} \\int_{0}^{\\infty} \\left[\n\\exp\\!\\left(-\\frac{(2 s_{o}^{2}+\\ell^{2}) k^{2}}{2}\\right)\n- 2 \\exp\\!\\left(-\\frac{(s_{o}^{2}+s_{m}^{2}+\\ell^{2}) k^{2}}{2}\\right)\n+ \\exp\\!\\left(-\\frac{(2 s_{m}^{2}+\\ell^{2}) k^{2}}{2}\\right)\n\\right] k \\, dk.\n$$\n使用标准积分 $\\int_{0}^{\\infty} k \\, e^{-a k^{2}} \\, dk = \\frac{1}{2a}$（其中 $a  0$）。确定\n$$\na_{1} = \\frac{2 s_{o}^{2}+\\ell^{2}}{2}, \\quad a_{2} = \\frac{s_{o}^{2}+s_{m}^{2}+\\ell^{2}}{2}, \\quad a_{3} = \\frac{2 s_{m}^{2}+\\ell^{2}}{2}.\n$$\n因此，\n$$\n\\mathrm{Var}[\\varepsilon] = \\sigma^{2} \\ell^{2} \\left( \\frac{1}{2 a_{1}} - \\frac{2}{2 a_{2}} + \\frac{1}{2 a_{3}} \\right)\n= \\sigma^{2} \\ell^{2} \\left( \\frac{1}{2 s_{o}^{2}+\\ell^{2}} - \\frac{2}{s_{o}^{2}+s_{m}^{2}+\\ell^{2}} + \\frac{1}{2 s_{m}^{2}+\\ell^{2}} \\right).\n$$\n此闭合形式表达式对于所有 $s_{o} \\ge 0$、$s_{m} \\ge 0$、$\\ell  0$ 和 $\\sigma  0$ 都是非负的，并且当 $s_{o} = s_{m}$ 时恒为零，这与等尺度下代表性误差为零的情况相符。\n\n所要求的均方根（RMS）代表性误差为\n$$\ne = \\sqrt{\\mathrm{Var}[\\varepsilon]} = \\sqrt{ \\sigma^{2} \\ell^{2} \\left( \\frac{1}{2 s_{o}^{2}+\\ell^{2}} - \\frac{2}{s_{o}^{2}+s_{m}^{2}+\\ell^{2}} + \\frac{1}{2 s_{m}^{2}+\\ell^{2}} \\right) }.\n$$\n\n实现算法：\n- 对于每个测试案例 $(\\sigma, \\ell, s_{o}, s_{m})$，计算\n$$\nv = \\sigma^{2} \\ell^{2} \\left( \\frac{1}{2 s_{o}^{2}+\\ell^{2}} - \\frac{2}{s_{o}^{2}+s_{m}^{2}+\\ell^{2}} + \\frac{1}{2 s_{m}^{2}+\\ell^{2}} \\right).\n$$\n- 将 $v$ 截断至不小于 $0$，以防止舍入误差。\n- 计算 $e = \\sqrt{v}$。\n- 将 $e$ 四舍五入到恰好 $6$ 位小数。\n- 按规定，在单行中以 $\\mathrm{K}$ 为单位输出列表 $[e_{A}, e_{B}, e_{C}, e_{D}, e_{E}]$。\n\n单位：\n- $\\sigma$ 的单位为 $\\mathrm{K}$，$\\ell$、$s_{o}$、$s_{m}$ 的单位为 $\\mathrm{km}$。\n- 输出 $e$ 的单位为 $\\mathrm{K}$，四舍五入到 $6$ 位小数。\n\n该方法仅依赖于平稳随机场的基本性质、高斯函数的傅里叶变换和 Parseval 定理，从而得出一个精确且计算上稳健的表达式，适用于该测试套件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rms_representativeness_error(sigma, ell, so, sm):\n    \"\"\"\n    Compute RMS representativeness error (in K) for Gaussian field covariance and Gaussian filters.\n\n    Parameters:\n        sigma (float): pointwise standard deviation (K)\n        ell   (float): correlation length (km)\n        so    (float): observation footprint std dev (km)\n        sm    (float): model grid averaging std dev (km)\n\n    Returns:\n        float: RMS representativeness error (K)\n    \"\"\"\n    # Variance formula derived in solution:\n    # Var = sigma^2 * ell^2 * [ 1/(2*so^2 + ell^2) - 2/(so^2 + sm^2 + ell^2) + 1/(2*sm^2 + ell^2) ]\n    denom1 = 2.0 * so * so + ell * ell\n    denom2 = so * so + sm * sm + ell * ell\n    denom3 = 2.0 * sm * sm + ell * ell\n\n    var = (sigma * sigma) * (ell * ell) * (1.0 / denom1 - 2.0 / denom2 + 1.0 / denom3)\n    # Guard against tiny negative values from floating point arithmetic\n    if var  0 and var  -1e-18:\n        var = 0.0\n    # Ensure non-negative\n    var = max(var, 0.0)\n    return float(np.sqrt(var))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (sigma K, ell km, so km, sm km)\n    test_cases = [\n        (1.5, 50.0, 10.0, 30.0),  # Case A\n        (2.0, 100.0, 20.0, 20.0), # Case B\n        (1.0, 30.0, 15.0, 0.0),   # Case C\n        (1.2, 500.0, 25.0, 40.0), # Case D\n        (2.5, 5.0, 20.0, 40.0),   # Case E\n    ]\n\n    results = []\n    for sigma, ell, so, sm in test_cases:\n        e = rms_representativeness_error(sigma, ell, so, sm)\n        # Round to exactly 6 decimal places\n        results.append(f\"{e:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}