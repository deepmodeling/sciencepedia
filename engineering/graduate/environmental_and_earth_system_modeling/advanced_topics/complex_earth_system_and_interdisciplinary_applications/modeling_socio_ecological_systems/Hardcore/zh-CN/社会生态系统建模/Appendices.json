{
    "hands_on_practices": [
        {
            "introduction": "在模拟复杂的相互作用之前，我们必须首先理解系统的内在动态。第一个练习使用一个简化的社会变迁模型，引导您进行分岔分析。通过寻找平衡点及其稳定性，您将揭示系统可能从一种状态突然转变为另一种状态的临界阈值——即“临界点”，这是社会-生态恢复力研究中的一个核心概念。",
            "id": "3896255",
            "problem": "考虑一个简化的社会生态临界模型，用于描述采纳亲环境行为的家庭比例，该比例由状态变量 $x$ 表示。其采纳动态由以下一维常微分方程 (ODE) 表示：\n$$\n\\dot{x} = \\mu - x + x^{3},\n$$\n其中 $\\mu$ 是一个无量纲的外生驱动力，代表支持采纳行为的净社会政治压力（例如，激励减去成本）。三次非线性项捕捉了增强的社会反馈（例如，模仿和规范内化），而线性损失项则捕捉了自发放弃或饱和效应。\n\n从动力学系统的基本概念出发——平衡点是使 $\\dot{x} = 0$ 的点，一维系统中的局部稳定性由右侧函数对 $x$ 的导数在平衡点处求得的符号决定，而鞍结分岔发生在两个平衡点以零斜率合并时——对该系统随 $\\mu$ 变化进行分岔分析：\n\n- 通过求解 $\\mu - x + x^{3} = 0$，找出所有作为 $\\mu$ 函数的平衡点 $x^{\\ast}$。\n- 使用一维线性化判据确定这些平衡点的局部稳定性。\n- 找出发生鞍结分岔的 $\\mu$ 的临界值。\n\n最终的临界 $\\mu$ 值必须以精确值表示（不要四舍五入）。最终答案必须以单行矩阵的形式报告临界值集合。$\\mu$ 是无量纲的。",
            "solution": "本题要求对由以下常微分方程 (ODE) 给出的动力学系统进行分岔分析：\n$$\n\\dot{x} = \\mu - x + x^{3}\n$$\n其中 $x$ 是状态变量，$\\mu$ 是控制参数。分析包括识别平衡点，确定其稳定性，以及找出发生鞍结分岔的 $\\mu$ 的临界值。\n\n设该常微分方程的右侧函数为 $f(x, \\mu)$，即 $\\dot{x} = f(x, \\mu) = \\mu - x + x^{3}$。\n\n**步骤 1：平衡点**\n\n平衡点，记为 $x^{\\ast}$，是系统处于静止状态时的 $x$ 值，即 $\\dot{x} = 0$。我们通过解方程 $f(x^{\\ast}, \\mu) = 0$ 来找到这些点。\n$$\n\\mu - x^{\\ast} + (x^{\\ast})^{3} = 0\n$$\n这个方程可以重新整理，将 $\\mu$ 表示为平衡态 $x^{\\ast}$ 的函数：\n$$\n\\mu = x^{\\ast} - (x^{\\ast})^{3}\n$$\n这个三次关系表明，对于给定的 $\\mu$ 值，可以有一个或三个实数平衡点 $x^{\\ast}$。\n\n**步骤 2：稳定性分析**\n\n在一维系统中，平衡点 $x^{\\ast}$ 的局部稳定性由函数 $f(x, \\mu)$ 对 $x$ 的导数在 $x^{\\ast}$ 处求得的符号决定。我们来计算这个导数：\n$$\nf'(x) = \\frac{d}{dx}f(x, \\mu) = \\frac{d}{dx}(\\mu - x + x^{3}) = -1 + 3x^{2}\n$$\n稳定性判据如下：\n- 如果 $f'(x^{\\ast})  0$，平衡点是局部稳定的（吸引子）。\n- 如果 $f'(x^{\\ast})  0$，平衡点是局部不稳定的（排斥子）。\n- 如果 $f'(x^{\\ast}) = 0$，平衡点是临界稳定的，可能发生分岔。\n\n从 $f'(x)$ 的表达式，我们可以根据 $x^{\\ast}$ 的值来确定稳定性：\n- 稳定 ($f'(x^{\\ast})  0$)：$-1 + 3(x^{\\ast})^{2}  0 \\implies 3(x^{\\ast})^{2}  1 \\implies (x^{\\ast})^{2}  \\frac{1}{3}$。这对应于 $-\\frac{1}{\\sqrt{3}}  x^{\\ast}  \\frac{1}{\\sqrt{3}}$。\n- 不稳定 ($f'(x^{\\ast})0$)：$-1 + 3(x^{\\ast})^{2}  0 \\implies (x^{\\ast})^{2}  \\frac{1}{3}$。这对应于 $x^{\\ast}  \\frac{1}{\\sqrt{3}}$ 或 $x^{\\ast}  -\\frac{1}{\\sqrt{3}}$。\n\n**步骤 3：鞍结分岔**\n\n鞍结（或折叠）分岔发生在一对平衡点——一个稳定点和一个不稳定点——合并并消失时。这发生在平衡点处于临界稳定状态的点，即 $f'(x^{\\ast})=0$。为了找到发生这些分岔的参数 $\\mu$ 的临界值，我们必须同时求解两个方程：平衡条件和临界稳定条件。\n\n临界点 $(x_c, \\mu_c)$ 的方程组为：\n$$\n\\begin{cases}\n\\mu_c - x_c + x_c^3 = 0  \\quad (\\text{平衡条件: } f(x_c, \\mu_c) = 0) \\\\\n-1 + 3x_c^2 = 0  \\quad (\\text{临界稳定条件: } f'(x_c) = 0)\n\\end{cases}\n$$\n\n从第二个方程，我们找到发生分岔的 $x$ 值：\n$$\n3x_c^2 = 1 \\implies x_c^2 = \\frac{1}{3} \\implies x_c = \\pm\\frac{1}{\\sqrt{3}}\n$$\n这是发生分岔的两个平衡点。现在，我们将这些 $x_c$ 的值代入第一个方程（或整理后的平衡条件 $\\mu_c = x_c - x_c^3$）中，以找到相应的 $\\mu$ 的临界值，记为 $\\mu_c$。\n\n情况 1: $x_c = +\\frac{1}{\\sqrt{3}}$\n$$\n\\mu_{c1} = x_c - x_c^3 = \\frac{1}{\\sqrt{3}} - \\left(\\frac{1}{\\sqrt{3}}\\right)^3 = \\frac{1}{\\sqrt{3}} - \\frac{1}{3\\sqrt{3}} = \\frac{3 - 1}{3\\sqrt{3}} = \\frac{2}{3\\sqrt{3}}\n$$\n\n情况 2: $x_c = -\\frac{1}{\\sqrt{3}}$\n$$\n\\mu_{c2} = x_c - x_c^3 = -\\frac{1}{\\sqrt{3}} - \\left(-\\frac{1}{\\sqrt{3}}\\right)^3 = -\\frac{1}{\\sqrt{3}} - \\left(-\\frac{1}{3\\sqrt{3}}\\right) = -\\frac{1}{\\sqrt{3}} + \\frac{1}{3\\sqrt{3}} = \\frac{-3 + 1}{3\\sqrt{3}} = -\\frac{2}{3\\sqrt{3}}\n$$\n\n发生鞍结分岔的 $\\mu$ 的临界值为 $\\mu_c = \\pm\\frac{2}{3\\sqrt{3}}$。这些值在分母有理化后可以写成 $\\mu_c = \\pm\\frac{2\\sqrt{3}}{9}$。当 $\\mu$ 的值在 $-\\frac{2\\sqrt{3}}{9}$ 和 $\\frac{2\\sqrt{3}}{9}$ 之间时，系统有三个平衡点（两个稳定，一个不稳定）。当 $|\\mu|  \\frac{2\\sqrt{3}}{9}$ 时，系统只有一个稳定的平衡点。在临界值 $\\mu_c$ 处，两个平衡点合并。\n\n$\\mu$ 的两个临界值是 $-\\frac{2\\sqrt{3}}{9}$ 和 $\\frac{2\\sqrt{3}}{9}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{2\\sqrt{3}}{9}  \\frac{2\\sqrt{3}}{9} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "社会-生态系统的决定性特征在于人类行为与生态响应之间的相互作用。本练习超越了简单的动态学，转而模拟多个主体在开采共同资源时的策略性决策。您将运用博弈论，对比分散的、自利行为（纳什均衡）的后果与集中规划的社会最优方案，从而对经典的“公地悲剧”问题进行量化分析。",
            "id": "3896254",
            "problem": "考虑一个社会-生态系统中的可再生资源，由 $N$ 个相同的代理人进行捕捞，其生态生物量状态 $B(t)$ 根据带有捕捞的逻辑斯蒂增长模型演变：\n$$\n\\frac{dB}{dt} \\;=\\; r\\,B\\left(1 - \\frac{B}{K}\\right) \\;-\\; q\\,E\\,B,\n$$\n其中 $r0$ 是内在增长率，$K0$ 是环境承载力，$q0$ 是可捕系数，$E \\equiv \\sum_{i=1}^{N} E_i$ 是总捕捞努力量。每个代理人 $i$ 选择努力量 $E_i \\ge 0$ 并获得瞬时效用\n$$\nu_i(E_i, B) \\;=\\; p\\,q\\,E_i\\,B \\;-\\; c\\,E_i \\;-\\; \\phi\\,q\\,E_i\\,B,\n$$\n其中 $p0$ 是外生的单位捕捞价格，$c0$ 是努力量的边际成本，$\\phi \\ge 0$ 是参数化了的每单位捕捞的内化生态惩罚。假设系统在一种稳态机制下进行管理，代理人预期到由上述动态所决定的长期可持续生物量，并且参数满足 $(p - \\phi)\\,q\\,K  c$，从而存在内部正努力量解。\n\n将此互动建模为一个同期对称纳什博弈，其中 $N$ 个相同的代理人同时选择 $\\{E_i\\}$，并将其他代理人的努力量视为给定，同时认识到可持续生物量通过生态动态依赖于总努力量。然后，推导：\n\n1. 每个代理人的对称纳什均衡努力量 $E_i^{\\ast}$，其中所有代理人选择相同的努力量。\n2. 社会计划者的最优总努力量 $E^{\\mathrm{SP}}$，该努力量在可持续生物量水平上，受相同生态动态的约束，最大化总瞬时净收益 $\\sum_{i=1}^{N} u_i(E_i, B)$。\n\n最后，将分散式和集中式结果之间的比较表示为在可持续生物量水平下，分散式总努力量与集中式总努力量的比率：\n$$\nR \\;\\equiv\\; \\frac{E_{\\mathrm{tot}}^{\\mathrm{Nash}}}{E_{\\mathrm{tot}}^{\\mathrm{SP}}},\n$$\n其中 $E_{\\mathrm{tot}}^{\\mathrm{Nash}} \\equiv \\sum_{i=1}^{N} E_i^{\\ast}$ 且 $E_{\\mathrm{tot}}^{\\mathrm{SP}} \\equiv E^{\\mathrm{SP}}$。请提供 $R$ 作为一个仅含 $N$ 的闭式解析表达式。不需要数值近似。最终答案应为无量纲，且不应包含单位。",
            "solution": "求解过程分四个步骤：\n1.  确定可持续生物量水平作为总努力量的函数。\n2.  推导分散式情景下的对称纳什均衡努力量。\n3.  推导集中式社会计划者情景下的最优努力量。\n4.  计算两种情景下总努力量的比率。\n\n步骤1：可持续生物量\n生态动态由带有捕捞的逻辑斯蒂增长模型给出：\n$$ \\frac{dB}{dt} = rB\\left(1 - \\frac{B}{K}\\right) - qEB $$\n其中 $E$ 是总捕捞努力量，$E = \\sum_{i=1}^{N} E_i$。假设系统处于稳态，这意味着生物量水平是恒定的，即 $\\frac{dB}{dt} = 0$。\n$$ rB\\left(1 - \\frac{B}{K}\\right) - qEB = 0 $$\n该方程对于 $B$ 有两个可能的稳态解。一个是平凡解 $B=0$，对应于资源枯竭。另一个是我们所求的非平凡正生物量水平。我们可以通过两边同除以 $B$ 来找到它（假设 $B0$）：\n$$ r\\left(1 - \\frac{B}{K}\\right) - qE = 0 $$\n解出 $B$ 作为总努力量 $E$ 的函数：\n$$ 1 - \\frac{B}{K} = \\frac{qE}{r} $$\n$$ \\frac{B}{K} = 1 - \\frac{qE}{r} $$\n$$ B(E) = K\\left(1 - \\frac{qE}{r}\\right) $$\n此表达式表示在给定总努力量 $E$ 下的可持续生物量水平。为了生物量为正，要求 $E  \\frac{r}{q}$。\n\n步骤2：对称纳什均衡（分散式结果）\n在分散式情景中，$N$ 个相同的代理人各自选择其努力量 $E_i$ 以最大化其自身个体效用，同时将其他代理人的努力量 $E_{-i} = \\sum_{j \\neq i} E_j$ 视为给定。代理人 $i$ 的效用为：\n$$ u_i(E_i, B) = p\\,q\\,E_i\\,B - c\\,E_i - \\phi\\,q\\,E_i\\,B = ((p - \\phi)qB - c)E_i $$\n每个代理人都认识到可持续生物量 $B$ 依赖于总努力量 $E = E_i + E_{-i}$。将 $B(E)$ 的表达式代入效用函数，我们得到代理人 $i$ 的效用仅作为努力量的函数：\n$$ u_i(E_i, E_{-i}) = \\left((p - \\phi)qK\\left(1 - \\frac{q(E_i + E_{-i})}{r}\\right) - c\\right)E_i $$\n为了找到最优努力量 $E_i$，我们将 $u_i$ 对 $E_i$ 求导，并令导数为零。\n$$ \\frac{\\partial u_i}{\\partial E_i} = (p - \\phi)qK\\left(1 - \\frac{q(E_i + E_{-i})}{r}\\right) - c + E_i\\left((p - \\phi)qK\\left(-\\frac{q}{r}\\right)\\right) = 0 $$\n$$ (p - \\phi)qK\\left(1 - \\frac{q(E_i + E_{-i})}{r} - \\frac{qE_i}{r}\\right) - c = 0 $$\n$$ (p - \\phi)qK\\left(1 - \\frac{q(2E_i + E_{-i})}{r}\\right) = c $$\n这个方程给出了代理人 $i$ 的反应函数。我们寻求一个对称纳什均衡，其中所有代理人都选择相同的努力水平，$E_i = E^*$ 对所有 $i=1, \\dots, N$ 成立。在这种情况下，$E_{-i} = (N-1)E^*$。将此代入一阶条件：\n$$ (p - \\phi)qK\\left(1 - \\frac{q(2E^* + (N-1)E^*)}{r}\\right) = c $$\n$$ (p - \\phi)qK\\left(1 - \\frac{q(N+1)E^*}{r}\\right) = c $$\n现在，我们求解对称均衡努力量 $E^*$：\n$$ 1 - \\frac{q(N+1)E^*}{r} = \\frac{c}{(p - \\phi)qK} $$\n$$ \\frac{q(N+1)E^*}{r} = 1 - \\frac{c}{(p - \\phi)qK} $$\n$$ E^* = \\frac{r}{q(N+1)}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right) $$\n在分散式纳什均衡中的总努力量是个体努力量之和：\n$$ E_{\\mathrm{tot}}^{\\mathrm{Nash}} = \\sum_{i=1}^{N} E^* = N E^* = \\frac{Nr}{q(N+1)}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right) $$\n\n步骤3：社会计划者最优（集中式结果）\n社会计划者旨在最大化所有代理人的总净收益，即他们效用的总和。设 $U_{SP}$ 为总社会福利。\n$$ U_{SP} = \\sum_{i=1}^{N} u_i = \\sum_{i=1}^{N} \\left(((p - \\phi)qB - c)E_i\\right) = ((p - \\phi)qB - c) \\sum_{i=1}^{N} E_i $$\n设 $E^{\\mathrm{SP}}$ 为社会计划者选择的总努力量。那么 $U_{SP}$ 变为：\n$$ U_{SP}(E^{\\mathrm{SP}}) = ((p - \\phi)qB - c)E^{\\mathrm{SP}} $$\n计划者同样受到生态动态的约束，因此我们代入 $B(E^{\\mathrm{SP}}) = K\\left(1 - \\frac{qE^{\\mathrm{SP}}}{r}\\right)$：\n$$ U_{SP}(E^{\\mathrm{SP}}) = \\left((p - \\phi)qK\\left(1 - \\frac{qE^{\\mathrm{SP}}}{r}\\right) - c\\right)E^{\\mathrm{SP}} $$\n为了找到最优总努力量 $E^{\\mathrm{SP}}$，我们将 $U_{SP}$ 对 $E^{\\mathrm{SP}}$ 求导，并令导数为零。\n$$ \\frac{d U_{SP}}{d E^{\\mathrm{SP}}} = (p - \\phi)qK\\left(1 - \\frac{qE^{\\mathrm{SP}}}{r}\\right) - c + E^{\\mathrm{SP}}\\left((p - \\phi)qK\\left(-\\frac{q}{r}\\right)\\right) = 0 $$\n$$ (p - \\phi)qK\\left(1 - \\frac{2qE^{\\mathrm{SP}}}{r}\\right) - c = 0 $$\n求解社会最优总努力量，我们记为 $E_{\\mathrm{tot}}^{\\mathrm{SP}} = E^{\\mathrm{SP}}$：\n$$ 1 - \\frac{2qE_{\\mathrm{tot}}^{\\mathrm{SP}}}{r} = \\frac{c}{(p - \\phi)qK} $$\n$$ \\frac{2qE_{\\mathrm{tot}}^{\\mathrm{SP}}}{r} = 1 - \\frac{c}{(p - \\phi)qK} $$\n$$ E_{\\mathrm{tot}}^{\\mathrm{SP}} = \\frac{r}{2q}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right) $$\n\n步骤4：分散式与集中式努力量的比率\n最后，我们计算分散式总努力量与集中式总努力量的比率 $R$。\n$$ R = \\frac{E_{\\mathrm{tot}}^{\\mathrm{Nash}}}{E_{\\mathrm{tot}}^{\\mathrm{SP}}} = \\frac{\\frac{Nr}{q(N+1)}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right)}{\\frac{r}{2q}\\left(1 - \\frac{c}{(p - \\phi)qK}\\right)} $$\n条件 $(p - \\phi)qK  c$ 确保了项 $\\left(1 - \\frac{c}{(p - \\phi)qK}\\right)$ 为正且非零，因此可以从分子和分母中约去。\n$$ R = \\frac{\\frac{Nr}{q(N+1)}}{\\frac{r}{2q}} = \\frac{Nr}{q(N+1)} \\cdot \\frac{2q}{r} $$\n$$ R = \\frac{2N}{N+1} $$\n此表达式给出了仅作为代理人数量 $N$ 的函数的比率，正如所要求。此结果量化了该模型中的“公地悲剧”：随着 $N$ 的增加，分散式与集中式努力量的比率接近 2，表明对资源的严重过度开采。",
            "answer": "$$\\boxed{\\frac{2N}{N+1}}$$"
        },
        {
            "introduction": "人类的互动并非随机发生，而是被社会网络所结构化。最后一个计算实践练习要求您模拟一种行为如何基于阈值规则在网络中传播。通过实现该模型并在不同的网络结构上运行，您将获得模拟的实践经验，并直观地理解网络拓扑结构（如聚类特性）如何影响大规模的社会级联效应。",
            "id": "3896268",
            "problem": "考虑一个社会-生态互动网络上的累进阈值传染过程，该网络由一个无向、简单、二元的邻接矩阵 $A \\in \\{0,1\\}^{N \\times N}$ 表示，其中 $N$ 是节点数量。设 $S \\subset \\{0,1,\\dots,N-1\\}$ 为初始激活节点的种子集合，阈值向量为 $\\boldsymbol{\\theta} \\in [0,1]^N$。将节点 $i$ 的度定义为 $d_i = \\sum_{j=0}^{N-1} A_{ij}$。设离散时间 $t$ 的二元状态向量为 $\\mathbf{x}(t) \\in \\{0,1\\}^N$，如果节点 $i$ 在时间 $t$ 是激活的，则 $x_i(t)=1$，否则 $x_i(t)=0$。初始条件为：对于 $i \\in S$，有 $x_i(0)=1$；对于 $i \\notin S$，有 $x_i(0)=0$。\n\n对于所有节点 $i \\in \\{0,1,\\dots,N-1\\}$，同步更新规则是累进的，定义如下：\n$$\nx_i(t+1) =\n\\begin{cases}\n1,  \\text{if } x_i(t)=1, \\\\\n1,  \\text{if } d_i0 \\text{ and } \\dfrac{1}{d_i}\\sum_{j=0}^{N-1} A_{ij} x_j(t) \\ge \\theta_i, \\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n对于度为零的节点（$d_i=0$），约定在上述规则中将 $\\dfrac{1}{d_i}\\sum_{j} A_{ij} x_j(t)$ 视为 $0$。\n\n级联规模 $C$ 定义为收敛时的激活节点数量：\n$$\nC = \\sum_{i=0}^{N-1} x_i(\\infty),\n$$\n其中 $\\mathbf{x}(t)$ 在同步、累进规则下收敛到一个不动点 $\\mathbf{x}(\\infty)$。\n\n你需要为每个测试用例计算 $C$。此外，应通过比较具有相似度但聚类水平不同的网络之间的级联规模，来检验聚类敏感性。聚类通过节点 $i$ 的局部聚类系数来量化，\n$$\nC_i = \\frac{2 T_i}{d_i(d_i-1)},\n$$\n其中 $T_i$ 是与节点 $i$ 相关的三角形数量，当 $d_i  2$ 时 $C_i=0$。全局聚类系数是平均值 $\\bar{C} = \\dfrac{1}{N}\\sum_{i=0}^{N-1} C_i$。在解决方案中，讨论在同步阈值动态下，$\\bar{C}$ 的变化如何影响级联规模。\n\n测试套件包括以下案例。对于每个案例，阈值向量是恒定的，即对所有 $i$ 都有 $\\theta_i=\\theta$。\n\n- 案例 1：一个 Watts–Strogatz (WS) 小世界环状晶格，参数为 $N=20$，平均度 $k=4$，重连概率 $p=0$，阈值 $\\theta=0.25$，种子集合 $S=\\{0\\}$。通过使用节点索引的模运算，将每个节点 $i$ 与其两侧各 $k/2=2$ 个最近的邻居连接起来，以构建初始环。\n\n- 案例 2：与案例1相同的 WS 环状晶格参数，$N=20$, $k=4$, $p=0$，但阈值为 $\\theta=0.5$，种子集合为 $S=\\{0,1\\}$。\n\n- 案例 3：一个 WS 网络，参数为 $N=20$, $k=4$, $p=0.8$，阈值 $\\theta=0.5$，种子集合 $S=\\{0,1\\}$。使用固定的随机数生成器种子 $42$ 进行重连。对于每个有向环边 $(i, i+r)$（其中 $r \\in \\{1,2\\}$），以概率 $p$ 独立地将其重连到一个新的端点 $w$，该端点从 $\\{0,1,\\dots,N-1\\} \\setminus \\left(\\{i\\} \\cup \\mathcal{N}(i)\\right)$ 中均匀随机选择，其中 $\\mathcal{N}(i)$ 是 $i$ 的当前邻居集合，以避免自环和重复边。\n\n- 案例 4：一个自定义网络，包含 $N=5$ 个节点，由节点 $\\{0,1,2,3\\}$ 上的路径和孤立节点 $\\{4\\}$ 组成。非零邻接项为 $A_{01}=A_{10}=A_{12}=A_{21}=A_{23}=A_{32}=1$，所有其他项为 $0$。阈值为 $\\theta=0.25$，种子集合为 $S=\\{0\\}$。\n\n- 案例 5：WS 环状晶格，参数为 $N=20$, $k=4$, $p=0$，阈值 $\\theta=1.0$，种子集合 $S=\\{0,1\\}$。\n\n您的任务是编写一个完整的、可运行的程序，该程序能够：\n- 构建指定的邻接矩阵。\n- 模拟同步阈值动态直至收敛。\n- 为每个案例计算级联规模 $C$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），其中每个结果是按上述顺序列出的相应案例的整数级联规模 $C$。此问题不涉及物理单位。不涉及角度。百分比应如 $\\theta$ 所指定的那样，以小数形式表示。",
            "solution": "我们从社会-生态互动网络的表示开始，该网络表示为一个无向简单图，由二元邻接矩阵 $A \\in \\{0,1\\}^{N \\times N}$ 编码，其中如果节点 $i$ 和 $j$ 之间存在互动边，则 $A_{ij}=1$，否则 $A_{ij}=0$。节点 $i$ 的度为 $d_i = \\sum_{j=0}^{N-1} A_{ij}$，即其互动伙伴的数量。\n\n阈值传染规则是社会和社会-生态系统中采纳动态的一个经过充分检验的模型。设阈值向量为 $\\boldsymbol{\\theta} \\in [0,1]^N$，初始种子集合为 $S \\subset \\{0,1,\\dots,N-1\\}$。同步、累进的更新规则为：\n$$\nx_i(t+1) =\n\\begin{cases}\n1,  \\text{if } x_i(t)=1, \\\\\n1,  \\text{if } d_i0 \\text{ and } \\dfrac{1}{d_i}\\sum_{j=0}^{N-1} A_{ij} x_j(t) \\ge \\theta_i, \\\\\n0,  \\text{otherwise,}\n\\end{cases}\n$$\n并约定对于度为零的节点（$d_i=0$），分数 $\\dfrac{1}{d_i}\\sum_{j} A_{ij} x_j(t)$ 被视为 $0$。该约定反映了孤立节点无法从邻居那里获得社会或生态强化，因此除非最初被选为种子，否则保持非激活状态。\n\n该规则是累进的，意味着一旦一个节点被激活（$x_i(t)=1$），它在所有后续时间里都保持激活状态。从根本上说，其关键属性是：\n- 单调性：由于更新只会将 $x_i$ 从 $0$ 翻转到 $1$，而绝不会从 $1$ 翻转到 $0$，因此序列 $\\{\\mathbf{x}(t)\\}_{t=0}^{\\infty}$ 在分量上是单调不减的。\n- 有限收敛：因为状态空间是有限的（$\\{0,1\\}^N$），并且序列是单调的，所以它必须在最多 $N$ 步内收敛到一个不动点 $\\mathbf{x}(\\infty)$，在该点上，更新规则不会再引起任何变化。\n\n因此，可以直接设计出如下算法：\n- 初始化 $\\mathbf{x}(0)$，如果 $i \\in S$ 则 $x_i(0)=1$，否则 $x_i(0)=0$。\n- 同步重复以下步骤：\n  - 对每个 $x_i(t)=0$ 的节点 $i$，如果 $d_i0$，计算分数 $f_i(t) = \\dfrac{1}{d_i}\\sum_{j=0}^{N-1} A_{ij} x_j(t)$，否则 $f_i(t)=0$。\n  - 如果 $f_i(t) \\ge \\theta_i$，则设置 $x_i(t+1)=1$，否则保持 $x_i(t+1)=x_i(t)$。\n- 当 $\\mathbf{x}(t+1)=\\mathbf{x}(t)$ 时停止，并计算级联规模 $C = \\sum_{i=0}^{N-1} x_i(\\infty)$。\n\n为了构建网络，我们采用 Watts–Strogatz (WS) 小世界模型，在保持度近似恒定的同时控制聚类：\n- 从一个规则的环状晶格开始：对每个节点 $i$，将其连接到其两侧各 $k/2$ 个最近的邻居，即对于 $r \\in \\{1,2,\\dots,k/2\\}$ 添加边 $(i, (i+r) \\bmod N)$ 和 $(i, (i-r) \\bmod N)$。\n- 对每个有向环边 $(i, i+r)$（其中 $r \\in \\{1,2,\\dots,k/2\\}$），以概率 $p$ 独立地将其端点 $i+r$ 重连到一个从 $w \\in \\{0,1,\\dots,N-1\\} \\setminus \\left(\\{i\\} \\cup \\mathcal{N}(i)\\right)$ 中均匀随机选择的节点，其中 $\\mathcal{N}(i)$ 是 $i$ 的当前邻居集合。这避免了自环和多重边。生成的无向图的平均度近似为 $k$，且对于较大的 $p$，聚类程度降低。\n\n聚类敏感性通过局部聚类系数来理解，\n$$\nC_i = \\frac{2 T_i}{d_i(d_i-1)},\n$$\n其中 $T_i$ 计算与 $i$ 相关的三角形数量。全局聚类系数为 $\\bar{C} = \\dfrac{1}{N}\\sum_{i=0}^{N-1} C_i$。在阈值传染中，较高的 $\\bar{C}$ 增加了种子的邻居共享共同联系人的概率，从而增加了同步强化。例如，在度为 $d_i=4$ 的网络上，阈值为 $\\theta=0.5$ 时，激活需要至少 $2$ 个激活的邻居。在一个有许多三角形的晶格中，两个相邻的种子通常共享邻居，使其邻居能够满足 2 个邻居的要求并传播激活。相比之下，在使用较大的 $p$ （较低的聚类）进行重连后，两个种子共享的邻居较少，因此仅与一个种子相邻的节点将不会达到阈值，从而使级联停滞。\n\n我们现在对这些测试用例进行分析：\n- 案例 1 中，$N=20$, $k=4$, $p=0$，且 $\\theta=0.25$（对于 $d_i=4$ 来说一个邻居就足够），激活将在环上传播，因为与激活节点相邻的每个边界节点至少有一个激活的邻居，从而在同步累进下导致完全激活。\n- 案例 2 中，$N=20$, $k=4$, $p=0$，且 $\\theta=0.5$（需要两个邻居），从两个相邻的种子开始。在环状晶格中，许多节点与这些种子处于三角形中，因此从两个激活的邻居那里获得强化，使得激活波得以传播，并在累进动态下遍及整个网络。\n- 案例 3 中，$N=20$, $k=4$, $p=0.8$，且 $\\theta=0.5$，使用相同的度但由于重连（为保证可复现性，随机种子固定为42）而具有较低的聚类。在这里，三角形的稀缺性减少了种子的共享邻居，常常阻止节点达到两个邻居的阈值，与案例2相比，这限制了级联规模。\n- 案例 4 中，$N=5$ 且路径为 $\\{0,1,2,3\\}$ 外加孤立节点 $\\{4\\}$，阈值为 $\\theta=0.25$，将从节点 $0$ 的种子开始逐步激活路径（每一步需要一个激活的邻居），但度为 $d_4=0$ 的孤立节点除非被初始设定为种子，否则保持非激活状态，从而产生一个不包括节点 $4$ 的级联。\n- 案例 5 中，$N=20$, $k=4$, $p=0$，且 $\\theta=1.0$ 要求所有邻居都必须被激活才能采纳。从 $S=\\{0,1\\}$ 开始，没有其他节点最初满足此要求，累进过程停滞，导致在收敛时只有种子节点是激活的。\n\n在算法上，同步更新可以高效实现：\n- 计算一次度向量 $\\mathbf{d} = A \\mathbf{1}$。\n- 在每次迭代中，通过 $A \\mathbf{x}(t)$ 计算邻居激活计数，在 $d_i0$ 的地方按元素除以 $\\mathbf{d}$，与 $\\boldsymbol{\\theta}$ 比较，并相应地更新非激活节点。\n- 当激活集合稳定时终止。每次迭代的复杂度对于稀疏计算是 $O(|E|)$，对于密集矩阵是 $O(N^2)$；由于单调累进，迭代次数最多为 $N$。\n\n该程序将构建指定的邻接矩阵（包括具有给定参数的WS网络），为每个案例模拟同步阈值动态直至收敛，并以要求的单行格式输出级联规模。案例2和案例3的比较说明了对聚类的敏感性：案例2中较高的 $\\bar{C}$ 通过共享邻居和三角形促进了阈值的满足，从而产生更大的级联；而案例3中较低的 $\\bar{C}$ 抑制了这种强化，减小了级联规模。",
            "answer": "```python\nimport numpy as np\n\ndef watts_strogatz_adjacency(n: int, k: int, p: float, seed: int | None = None) - np.ndarray:\n    \"\"\"\n    Construct an undirected Watts-Strogatz small-world graph adjacency matrix.\n    - n: number of nodes (must be = 3)\n    - k: mean degree (must be even and  n)\n    - p: rewiring probability in [0,1]\n    - seed: RNG seed for reproducibility\n    Returns adjacency matrix A (n x n) with 0/1 entries, no self-loops, no multi-edges.\n    \"\"\"\n    assert n = 3, \"n must be at least 3\"\n    assert k % 2 == 0 and 0  k  n, \"k must be even and 0  k  n\"\n    rng = np.random.default_rng(seed)\n\n    # Start with ring lattice: connect i to i±r for r = 1..k/2\n    A = np.zeros((n, n), dtype=np.int64)\n    half_k = k // 2\n    # Add undirected edges (i, (i+r) % n) and (i, (i-r) % n)\n    for i in range(n):\n        for r in range(1, half_k + 1):\n            j = (i + r) % n\n            A[i, j] = 1\n            A[j, i] = 1\n\n    # Rewire each directed \"clockwise\" edge (i, i+r) for r=1..k/2 independently\n    # Process edges only in one direction to avoid double rewiring\n    for i in range(n):\n        for r in range(1, half_k + 1):\n            j = (i + r) % n\n            if rng.random()  p:\n                # Attempt to rewire (i, j) to (i, w)\n                # Remove edge (i, j)\n                A[i, j] = 0\n                A[j, i] = 0\n                # Choose new w uniformly from nodes excluding i and current neighbors of i\n                neighbors_i = set(np.where(A[i] == 1)[0])\n                forbidden = neighbors_i.union({i})\n                candidates = [w for w in range(n) if w not in forbidden]\n                if len(candidates) == 0:\n                    # No possible rewiring; restore original edge\n                    A[i, j] = 1\n                    A[j, i] = 1\n                else:\n                    w = rng.choice(candidates)\n                    A[i, w] = 1\n                    A[w, i] = 1\n    return A\n\ndef cascade_size(A: np.ndarray, theta: np.ndarray, seeds: list[int]) - int:\n    \"\"\"\n    Compute cascade size under synchronous progressive threshold dynamics.\n    - A: adjacency matrix (n x n), assumed undirected, simple\n    - theta: threshold vector (length n)\n    - seeds: list of initially active node indices\n    Returns integer cascade size (number of active nodes at convergence).\n    \"\"\"\n    n = A.shape[0]\n    # Binary state vector\n    x = np.zeros(n, dtype=bool)\n    x[seeds] = True\n    degrees = A.sum(axis=1).astype(np.int64)\n\n    # Iteratively update until convergence\n    max_iters = n  # progressive dynamics converge in at most n steps\n    for _ in range(max_iters):\n        prev_x = x.copy()\n        # Compute fraction of active neighbors; handle degree zero separately\n        active_counts = A @ x.astype(np.int64)  # number of active neighbors\n        frac = np.zeros(n, dtype=float)\n        # For nodes with degree  0\n        mask_deg_pos = degrees  0\n        frac[mask_deg_pos] = active_counts[mask_deg_pos] / degrees[mask_deg_pos]\n        # Progressive: already active remain active\n        new_x = prev_x.copy()\n        # Nodes that are inactive but meet threshold become active\n        adopt_mask = (~prev_x)  (frac = theta)\n        new_x[adopt_mask] = True\n        x = new_x\n        if np.array_equal(x, prev_x):\n            break\n    return int(x.sum())\n\ndef solve():\n    # Define test cases as tuples specifying how to build A, theta, seeds\n    # Case 1: WS ring lattice N=20, k=4, p=0.0, theta=0.25, seeds={0}\n    case1 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.0, \"seed\": None}, {\"theta\": 0.25, \"seeds\": [0]})\n    # Case 2: WS ring lattice N=20, k=4, p=0.0, theta=0.5, seeds={0,1}\n    case2 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.0, \"seed\": None}, {\"theta\": 0.5, \"seeds\": [0, 1]})\n    # Case 3: WS N=20, k=4, p=0.8, theta=0.5, seeds={0,1}, RNG seed=42\n    case3 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.8, \"seed\": 42}, {\"theta\": 0.5, \"seeds\": [0, 1]})\n    # Case 4: Custom path on nodes {0,1,2,3} and isolated node {4}, theta=0.25, seeds={0}\n    case4 = (\"custom\", {\"n\": 5, \"edges\": [(0, 1), (1, 2), (2, 3)]}, {\"theta\": 0.25, \"seeds\": [0]})\n    # Case 5: WS ring lattice N=20, k=4, p=0.0, theta=1.0, seeds={0,1}\n    case5 = (\"ws\", {\"n\": 20, \"k\": 4, \"p\": 0.0, \"seed\": None}, {\"theta\": 1.0, \"seeds\": [0, 1]})\n\n    test_cases = [case1, case2, case3, case4, case5]\n\n    results = []\n    for kind, params, dyn in test_cases:\n        theta_val = dyn[\"theta\"]\n        seeds = dyn[\"seeds\"]\n        if kind == \"ws\":\n            A = watts_strogatz_adjacency(n=params[\"n\"], k=params[\"k\"], p=params[\"p\"], seed=params[\"seed\"])\n            theta = np.full(params[\"n\"], theta_val, dtype=float)\n        elif kind == \"custom\":\n            n = params[\"n\"]\n            A = np.zeros((n, n), dtype=np.int64)\n            for (u, v) in params[\"edges\"]:\n                A[u, v] = 1\n                A[v, u] = 1\n            theta = np.full(n, theta_val, dtype=float)\n        else:\n            raise ValueError(\"Unknown test case kind.\")\n        csize = cascade_size(A, theta, seeds)\n        results.append(csize)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}