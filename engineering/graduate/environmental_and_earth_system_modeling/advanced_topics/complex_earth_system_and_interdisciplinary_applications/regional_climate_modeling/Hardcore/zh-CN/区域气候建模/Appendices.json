{
    "hands_on_practices": [
        {
            "introduction": "在区域气候模型（RCM）的设置中，一个关键的决策是选择水平网格间距，因为它直接决定了像深对流这样的关键尺度过程是需要被参数化，还是可以被模型直接解析。本练习将指导你如何应用基本的物理原理（湍流浮力羽流理论）来估算显式解析对流上升气流所需的模型分辨率。掌握这种尺度分析方法是设计对流解析模拟（convection-permitting simulation）的基石，有助于在计算资源和物理过程的真实性之间做出合理的权衡。",
            "id": "3909097",
            "problem": "一个旨在显式表示深对流的区域气候模型（RCM）必须配置足够精细的水平网格间距，以解析对流云中的主上升气流核心。将对流上升气流核心视为在Boussinesq近似下具有不可压缩流动的轴对称湍流浮力羽流。该核心在高度 $z$ 处具有平顶垂直速度剖面 $w(z)$ 和半径 $r(z)$。其体积通量为 $Q(z) = \\pi r(z)^{2} w(z)$。在湍流浮力羽流理论中，Morton–Taylor–Turner 的经典卷吸假说假设，羽流边缘的运动学卷吸速度 $u_{e}(z)$ 与当地垂直速度大小成比例，即 $u_{e}(z) = \\alpha w(z)$，其中 $\\alpha$ 是一个无量纲卷吸系数，表征湍流混入羽流的程度。利用轴对称连续性和卷吸假说，进行尺度分析，以获得上升气流半径 $r(z)$ 的主导阶高度依赖关系，并由此评估在指定对流层中层高度的上升气流直径。\n\n假设在一个区域气候模型框架中嵌入的深对流羽流具有以下科学上合理的参数：\n- 云底高度 $z_{0} = 1.5$ km。\n- 云底处的初始核心半径 $r_{0} = 0.30$ km。\n- 对流层中层分析高度 $z_{m} = 6.0$ km。\n- 恒定卷吸系数 $\\alpha = 0.12$。\n\n采用广泛使用的数值解析度准则，即显式解析一个相干的上升气流需要在其直径上至少有 $m = 6$ 个网格点。推导满足此准则的最小水平网格间距 $\\Delta x_{\\min}$ 的闭式表达式（用 $r(z_{m})$ 和 $m$ 表示），然后使用上述参数计算 $\\Delta x_{\\min}$ 的数值。\n\n将最终数值答案四舍五入至三位有效数字。以 km 为单位表示 $\\Delta x_{\\min}$。",
            "solution": "问题陈述已经过严格验证，被认为是科学可靠、定义明确且客观的。它基于经典的 Morton-Taylor-Turner 湍流浮力羽流理论，这是流体动力学和大气科学中的一个标准模型。所有必要的参数和条件都已提供，并且对于深层大气对流来说是物理上合理的。因此，该问题是有效的，并将提供解答。\n\n主要目标是确定在区域气候模型（RCM）中显式解析对流上升气流核心所需的最小水平网格间距（问题中称为 $\\Delta x_{\\min}$）。这需要将模型的网格解析度与上升气流的物理尺寸联系起来。解答过程分四个阶段进行：(1) 推导上升气流半径 $r(z)$ 的高度依赖关系；(2) 计算在指定分析高度 $z_m$ 处的上升气流直径；(3) 建立网格解析度要求；以及 (4) 计算网格间距的最终数值。\n\n首先，我们将上升气流核心建模为轴对称湍流浮力羽流。体积通量 $Q(z) = \\pi r(z)^2 w(z)$ 随高度 $z$ 的变化是由于周围空气的卷吸。单位高度上卷吸的体积流率是羽流周长 $2\\pi r(z)$ 与卷吸速度 $u_e(z)$ 的乘积。因此，质量守恒（或在不可压缩假设下的体积守恒）表示为：\n$$\n\\frac{dQ}{dz} = 2\\pi r u_e\n$$\n问题指定了 Morton-Taylor-Turner 卷吸假说，该假说假设卷吸速度与当地上升气流速度 $w(z)$ 成正比：\n$$\nu_e(z) = \\alpha w(z)\n$$\n其中 $\\alpha$ 是无量纲卷吸系数。\n\n将 $Q(z)$ 和 $u_e(z)$ 的表达式代入守恒方程，得到：\n$$\n\\frac{d}{dz}(\\pi r^2 w) = 2\\pi r (\\alpha w)\n$$\n两边除以 $\\pi$ 并简化，得到羽流演变的基本方程：\n$$\n\\frac{d}{dz}(r^2 w) = 2 \\alpha r w\n$$\n要得到 $r(z)$ 和 $w(z)$ 的完整解，还需要一个额外的方程，通常是垂直动量守恒方程。然而，问题要求进行“尺度分析以获得主导阶高度依赖关系”。浮力羽流理论的一个基本结果（可从对控制方程进行更详细的分析中推导得出）是，羽流随高度线性扩展。这对应于一个圆锥形状，其半径随高度的变化率是恒定的。这个恒定的扩展率与卷吸系数 $\\alpha$ 直接成正比。对于平顶剖面，此关系的主导阶由下式给出：\n$$\n\\frac{dr}{dz} = \\alpha\n$$\n这个线性常微分方程描述了圆锥的半径。我们可以通过从云底条件（在 $z=z_0$ 处，$r=r_0$）到一般高度 $z$ 进行直接积分来求解它。\n$$\n\\int_{r_0}^{r(z)} dr' = \\int_{z_0}^{z} \\alpha dz'\n$$\n由于 $\\alpha$ 为给定常数，积分得到：\n$$\nr(z) - r_0 = \\alpha (z - z_0)\n$$\n因此，上升气流半径随高度变化的表达式为：\n$$\nr(z) = r_0 + \\alpha (z - z_0)\n$$\n接下来，我们计算在指定的对流层中层分析高度 $z_m = 6.0$ km 处的半径。给定参数为云底高度 $z_0 = 1.5$ km，初始半径 $r_0 = 0.30$ km，以及卷吸系数 $\\alpha = 0.12$。\n$$\nr(z_m) = 0.30 \\text{ km} + 0.12 \\times (6.0 \\text{ km} - 1.5 \\text{ km})\n$$\n$$\nr(z_m) = 0.30 + 0.12 \\times 4.5\n$$\n$$\nr(z_m) = 0.30 + 0.54 = 0.84 \\text{ km}\n$$\n在此高度的上升气流直径 $D(z_m)$ 是半径的两倍：\n$$\nD(z_m) = 2 r(z_m) = 2 \\times 0.84 \\text{ km} = 1.68 \\text{ km}\n$$\n然后，问题引入了一个数值解析度准则：至少需要 $m = 6$ 个网格点跨越上升气流的直径。如果 $\\Delta x$ 是水平网格间距，则跨越直径 $D(z_m)$ 的网格点数为 $D(z_m) / \\Delta x$。因此，准则为：\n$$\n\\frac{D(z_m)}{\\Delta x} \\ge m\n$$\n求解 $\\Delta x$，我们得到对网格间距的约束条件：\n$$\n\\Delta x \\le \\frac{D(z_m)}{m}\n$$\n这个不等式定义了满足解析度要求的最大允许网格间距 $\\Delta x_{\\max} = D(z_m)/m$。任何大于 $\\Delta x_{\\max}$ 的网格间距 $\\Delta x$ 都会对该特征解析不足。问题中的术语 $\\Delta x_{\\min}$ 被解释为这个临界阈值，代表了勉强可接受的最粗（最大）网格间距。\n\n通过代入我们对 $D(z_m)$ 和 $r(z_m)$ 的表达式，可以得到该网格间距的闭式表达式：\n$$\n\\Delta x_{\\min} = \\frac{D(z_m)}{m} = \\frac{2 r(z_m)}{m} = \\frac{2 [r_0 + \\alpha (z_m - z_0)]}{m}\n$$\n最后，我们使用先前计算的直径 $D(z_m) = 1.68$ km 和给定的值 $m=6$ 来计算 $\\Delta x_{\\min}$ 的数值：\n$$\n\\Delta x_{\\min} = \\frac{1.68 \\text{ km}}{6} = 0.28 \\text{ km}\n$$\n问题要求最终答案四舍五入至三位有效数字。因此，我们将结果表示为 $0.280$ km。",
            "answer": "$$\n\\boxed{0.280}\n$$"
        },
        {
            "introduction": "一个物理上自洽的数值模型必须严格遵守基本的守恒定律，例如质量守恒和能量守恒。本练习介绍了一种至关重要的模式诊断技术：检验模式大气水柱中的水物质收支是否闭合。你将学习如何利用模式输出的各个水文分量，计算水收支方程的残差，这是识别模式动力框架或物理参数化方案中可能存在的不一致性或数值误差的关键技能。",
            "id": "3909119",
            "problem": "考虑由区域气候模型（Regional Climate Model, RCM）所表示的固定区域范围上的大气水柱收支。该收支受水物质质量守恒定律的制约，其中总水柱储水量（单位面积的质量）因地表源汇和水平输送而变化。设 $W$ 表示单位面积上大气水物质（例如，水汽加凝结物）的整层积分质量，$P$ 为降水率（单位面积和时间的质量通量），$E$ 为蒸发率（或表示为等效质量通量的地表潜热通量）（单位面积和时间的质量通量），$\\nabla \\cdot \\mathbf{F}_q$ 为垂直积分水汽通量的水平散度（单位面积和时间的质量通量，正值表示净输出）。本问题的基本依据是整层积分水物质连续性方程：\n$$\n\\frac{dW}{dt} \\;=\\; E \\;-\\; P \\;-\\; \\nabla \\cdot \\mathbf{F}_q.\n$$\n给你提供了几个综合测试案例的模型输出时间序列，包括 $P$、$E$、$\\frac{dW}{dt}$ 和 $\\nabla \\cdot \\mathbf{F}_q$。你的任务是利用上述守恒原理，为水柱收支推导并实现一个诊断性残差闭合误差，该误差用以量化所报告的模型项在时间上闭合收支的程度。残差闭合误差应仅根据给定的模型时间序列定义，不使用任何外部数据。对每个测试案例，计算一个单一的总结性指标：在所提供的时间指数上残差的均方根误差（RMSE）。\n\n所有量均以毫米/天（mm/day）为单位提供，并通过液态水的密度等效于千克/平方米/天。你的程序必须使用基本依据所隐含的收支方程，为每个案例计算残差闭合误差时间序列，然后计算该案例随时间变化的RMSE。将每个RMSE以毫米/天（mm/day）为单位表示，并四舍五入到三位小数。本问题不涉及角度，因此不需要角度单位。\n\n测试套件：\n- 案例 $1$（理想情况下的精确闭合）：\n  - $P = [4.0, 1.5, 0.0, 2.3]$\n  - $E = [2.0, 1.2, 0.8, 2.0]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [-0.5, -0.3, 0.1, -0.2]$\n  - $\\frac{dW}{dt} = [-1.5, 0.0, 0.7, -0.1]$\n- 案例 $2$（储水倾向中的系统性偏差）：\n  - $P = [3.0, 4.5, 2.0, 5.0, 1.5]$\n  - $E = [3.0, 4.5, 2.0, 5.0, 1.5]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [0.0, -0.5, 0.1, 0.3, -0.2]$\n  - $\\frac{dW}{dt} = [0.2, 0.7, 0.1, -0.1, 0.4]$\n- 案例 $3$（对所有项的微小独立扰动；混合正负号和大小）：\n  - 精确闭合的基础数组：\n    - $P_{\\text{base}} = [2.0, 10.0, 0.5, 5.0, 3.0, 8.0]$\n    - $E_{\\text{base}} = [1.5, 7.0, 0.7, 3.5, 2.5, 6.5]$\n    - $\\nabla \\cdot \\mathbf{F}_{q,\\text{base}} = [0.1, -1.0, 0.0, 0.4, -0.2, -0.5]$\n    - $\\left(\\frac{dW}{dt}\\right)_{\\text{base}} = [-0.6, -2.0, 0.2, -1.9, -0.3, -1.0]$\n  - 应用扰动（逐元素相加）以获得模型输出：\n    - $\\Delta P = [0.05, -0.10, 0.00, 0.20, -0.15, 0.10]$\n    - $\\Delta E = [-0.05, 0.00, 0.10, -0.10, 0.00, -0.20]$\n    - $\\Delta(\\nabla \\cdot \\mathbf{F}_q) = [0.02, -0.05, 0.00, 0.03, -0.01, 0.04]$\n    - $\\Delta\\left(\\frac{dW}{dt}\\right) = [0.00, 0.10, -0.05, 0.00, 0.05, -0.10]$\n  - 最终模型数组：\n    - $P = P_{\\text{base}} + \\Delta P$\n    - $E = E_{\\text{base}} + \\Delta E$\n    - $\\nabla \\cdot \\mathbf{F}_q = \\nabla \\cdot \\mathbf{F}_{q,\\text{base}} + \\Delta(\\nabla \\cdot \\mathbf{F}_q)$\n    - $\\frac{dW}{dt} = \\left(\\frac{dW}{dt}\\right)_{\\text{base}} + \\Delta\\left(\\frac{dW}{dt}\\right)$\n- 案例 $4$（带有一个时间步长不匹配的极端事件）：\n  - $P = [100.0, 0.0, 25.0]$\n  - $E = [5.0, 2.0, 10.0]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [-10.0, 0.0, 5.0]$\n  - $\\frac{dW}{dt} = [-84.5, 2.0, -20.0]$\n- 案例 $5$（所有项均为零，精确闭合）：\n  - $P = [0.0, 0.0, 0.0, 0.0]$\n  - $E = [0.0, 0.0, 0.0, 0.0]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [0.0, 0.0, 0.0, 0.0]$\n  - $\\frac{dW}{dt} = [0.0, 0.0, 0.0, 0.0]$\n\n你的程序必须：\n- 为每个测试案例实现上述守恒定律所隐含的残差闭合误差时间序列。\n- 对每个案例，计算在所提供的时间指数上的残差的RMSE。\n- 输出一行，包含案例 $1$ 到 $5$ 的RMSE值，形式为用方括号括起来的逗号分隔列表，每个值以毫米/天（mm/day）为单位，四舍五入到三位小数，例如 $[x_1,x_2,x_3,x_4,x_5]$。\n\n你的最终输出必须以毫米/天（mm/day）为单位，并且是包含 $5$ 个浮点数的列表，四舍五入到三位小数，并按指定格式打印在单行上。",
            "solution": "问题已经过验证。\n\n### 第1步：提取已知信息\n整层积分水物质连续性的基本控制方程如下：\n$$\n\\frac{dW}{dt} \\;=\\; E \\;-\\; P \\;-\\; \\nabla \\cdot \\mathbf{F}_q\n$$\n其中：\n- $W$ 是单位面积上大气水物质的整层积分质量。\n- $\\frac{dW}{dt}$ 是 $W$ 的变化率。\n- $E$ 是蒸发率（单位面积和时间的质量通量）。\n- $P$ 是降水率（单位面积和时间的质量通量）。\n- $\\nabla \\cdot \\mathbf{F}_q$ 是垂直积分水汽通量的水平散度（单位面积和时间的质量通量）。\n所有量均以毫米/天（mm/day）为单位给出。\n\n提供了五个测试案例，每个案例都包含 $P$、$E$、$\\frac{dW}{dt}$ 和 $\\nabla \\cdot \\mathbf{F}_q$ 的时间序列数据。\n- **案例1**：\n  - $P = [4.0, 1.5, 0.0, 2.3]$\n  - $E = [2.0, 1.2, 0.8, 2.0]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [-0.5, -0.3, 0.1, -0.2]$\n  - $\\frac{dW}{dt} = [-1.5, 0.0, 0.7, -0.1]$\n- **案例2**：\n  - $P = [3.0, 4.5, 2.0, 5.0, 1.5]$\n  - $E = [3.0, 4.5, 2.0, 5.0, 1.5]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [0.0, -0.5, 0.1, 0.3, -0.2]$\n  - $\\frac{dW}{dt} = [0.2, 0.7, 0.1, -0.1, 0.4]$\n- **案例3**：数据以基础数组和扰动的形式提供，必须将它们组合起来。\n  - $P_{\\text{base}} = [2.0, 10.0, 0.5, 5.0, 3.0, 8.0]$, $\\Delta P = [0.05, -0.10, 0.00, 0.20, -0.15, 0.10]$\n  - $E_{\\text{base}} = [1.5, 7.0, 0.7, 3.5, 2.5, 6.5]$, $\\Delta E = [-0.05, 0.00, 0.10, -0.10, 0.00, -0.20]$\n  - $\\nabla \\cdot \\mathbf{F}_{q,\\text{base}} = [0.1, -1.0, 0.0, 0.4, -0.2, -0.5]$, $\\Delta(\\nabla \\cdot \\mathbf{F}_q) = [0.02, -0.05, 0.00, 0.03, -0.01, 0.04]$\n  - $(\\frac{dW}{dt})_{\\text{base}} = [-0.6, -2.0, 0.2, -1.9, -0.3, -1.0]$, $\\Delta(\\frac{dW}{dt}) = [0.00, 0.10, -0.05, 0.00, 0.05, -0.10]$\n- **案例4**：\n  - $P = [100.0, 0.0, 25.0]$\n  - $E = [5.0, 2.0, 10.0]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [-10.0, 0.0, 5.0]$\n  - $\\frac{dW}{dt} = [-84.5, 2.0, -20.0]$\n- **案例5**：\n  - $P = [0.0, 0.0, 0.0, 0.0]$\n  - $E = [0.0, 0.0, 0.0, 0.0]$\n  - $\\nabla \\cdot \\mathbf{F}_q = [0.0, 0.0, 0.0, 0.0]$\n  - $\\frac{dW}{dt} = [0.0, 0.0, 0.0, 0.0]$\n\n任务是计算每个案例的残差闭合误差的均方根误差（RMSE），并四舍五入到三位小数。\n\n### 第2步：使用提取的已知信息进行验证\n1.  **科学依据**：该问题基于大气水柱中水的质量守恒原理。控制方程是大气科学和区域气候模拟中的一个标准、基本关系。它在科学上是合理的。\n2.  **适定性**：该问题要求根据给定的数据集计算一个诊断指标（RMSE）。残差的定义可以从控制方程中明确地推导出来。对于每组输入时间序列，都可以计算出一个唯一的RMSE值。该问题是适定的。\n3.  **客观性**：该问题使用精确、标准的科学术语进行陈述。数据是数值型的，要求的计算是标准的统计操作。问题不含主观或基于观点的内容。\n4.  **完整性和一致性**：为每个测试案例提供了所有必要的数据和定义。所有项的单位（mm/day）是一致的。所提供的信息中没有矛盾之处。\n5.  **无其他缺陷**：该问题是将物理原理直接应用于数值数据，是典型的模型评估任务。它不是比喻性的、琐碎的、不适定的或无法验证的。\n\n### 第3步：结论与行动\n问题有效。将着手制定解决方案。\n\n这个问题的核心是质量守恒原理。所提供的方程，\n$$\n\\frac{dW}{dt} \\;=\\; E \\;-\\; P \\;-\\; \\nabla \\cdot \\mathbf{F}_q\n$$\n表明大气水柱中水储量的变化率 $\\frac{dW}{dt}$ 必须与进入水柱的净水通量完全平衡。这些通量包括地表蒸发（$E$）、水柱中的降水（$P$）以及水汽移出水柱的净水平输送（$\\nabla \\cdot \\mathbf{F}_q$）。\n\n在一个完美的数值模型中，独立计算的各项在每个时间步长都应满足此方程。然而，由于数值方案、时空离散化或物理参数化中的近似，收支可能无法完美闭合。我们用 $R$ 表示的残差闭合误差，量化了这种不平衡。\n\n为了定义 $R$，我们将守恒方程重排为在完美闭合时等于零的形式：\n$$\n\\frac{dW}{dt} - (E - P - \\nabla \\cdot \\mathbf{F}_q) = 0\n$$\n残差 $R$ 是用模型的输出项计算时左侧的值：\n$$\nR = \\frac{dW}{dt} - E + P + \\nabla \\cdot \\mathbf{F}_q\n$$\n由于输入是时间序列，我们为序列中的每个时间指数 $i$ 计算一个残差值 $R_i$：\n$$\nR_i = \\left(\\frac{dW}{dt}\\right)_i - E_i + P_i + (\\nabla \\cdot \\mathbf{F}_q)_i\n$$\n问题要求对该残差时间序列使用一个单一的总结性指标，即均方根误差（RMSE）。对于长度为 $N$ 的残差时间序列 $R$，RMSE 的计算公式为：\n$$\nRMSE = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} R_i^2}\n$$\n该指标提供了在时间段内收支不平衡的平均幅度的度量，单位为毫米/天（mm/day）。\n\n要实现的算法如下：\n1.  对每个测试案例，获取 $P$、$E$、$\\frac{dW}{dt}$ 和 $\\nabla \\cdot \\mathbf{F}_q$ 的时间序列。对于案例3，这需要将基础数组和扰动数组相加。\n2.  对于案例中的每个时间指数 $i$，使用推导出的公式计算残差 $R_i$。\n3.  获得完整的残差时间序列 $R = [R_1, R_2, ..., R_N]$ 后，计算其RMSE。\n4.  将最终的RMSE四舍五入到三位小数。\n5.  收集所有案例的结果并按指定格式进行格式化。\n\n举个例子，我们来计算案例1第一个时间步长的残差：\n- $P_1 = 4.0$\n- $E_1 = 2.0$\n- $(\\nabla \\cdot \\mathbf{F}_q)_1 = -0.5$\n- $(\\frac{dW}{dt})_1 = -1.5$\n残差为：\n$$\nR_1 = (-1.5) - (2.0) + (4.0) + (-0.5) = -1.5 - 2.0 + 4.0 - 0.5 = 0.0\n$$\n对所有时间步长重复此操作。对于案例1，所有残差均为 $0.0$，表示完美闭合，因此RMSE为 $0.0$。\n\n对于案例2，在第一个时间步长：\n- $P_1 = 3.0$\n- $E_1 = 3.0$\n- $(\\nabla \\cdot \\mathbf{F}_q)_1 = 0.0$\n- $(\\frac{dW}{dt})_1 = 0.2$\n残差为：\n$$\nR_1 = (0.2) - (3.0) + (3.0) + (0.0) = 0.2\n$$\n在此案例中，所有时间步长的残差始终为 $0.2$，因此RMSE也为 $0.2$。\n\n实现过程将对所有五个案例应用此程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the RMSE of the water budget residual for five test cases.\n    \"\"\"\n\n    def calculate_rmse(P, E, divFq, dWdt):\n        \"\"\"\n        Calculates the RMSE of the water budget residual for a single case.\n        Args:\n            P (list or np.ndarray): Precipitation time series.\n            E (list or np.ndarray): Evaporation time series.\n            divFq (list or np.ndarray): Moisture flux divergence time series.\n            dWdt (list or np.ndarray): Water storage tendency time series.\n        Returns:\n            float: The calculated RMSE.\n        \"\"\"\n        P_arr = np.array(P)\n        E_arr = np.array(E)\n        divFq_arr = np.array(divFq)\n        dWdt_arr = np.array(dWdt)\n\n        # R = dW/dt - (E - P - divFq) = dW/dt - E + P + divFq\n        residual = dWdt_arr - E_arr + P_arr + divFq_arr\n        \n        # RMSE = sqrt(mean(residual^2))\n        rmse = np.sqrt(np.mean(np.square(residual)))\n        \n        return rmse\n\n    # --- Test Case Definitions ---\n\n    # Case 1 (happy path exact closure)\n    case1_data = {\n        \"P\": [4.0, 1.5, 0.0, 2.3],\n        \"E\": [2.0, 1.2, 0.8, 2.0],\n        \"divFq\": [-0.5, -0.3, 0.1, -0.2],\n        \"dWdt\": [-1.5, 0.0, 0.7, -0.1]\n    }\n\n    # Case 2 (systematic bias in storage tendency)\n    case2_data = {\n        \"P\": [3.0, 4.5, 2.0, 5.0, 1.5],\n        \"E\": [3.0, 4.5, 2.0, 5.0, 1.5],\n        \"divFq\": [0.0, -0.5, 0.1, 0.3, -0.2],\n        \"dWdt\": [0.2, 0.7, 0.1, -0.1, 0.4]\n    }\n\n    # Case 3 (small independent perturbations)\n    # Construct final model arrays from base and perturbation arrays.\n    P_base_3 = np.array([2.0, 10.0, 0.5, 5.0, 3.0, 8.0])\n    delta_P_3 = np.array([0.05, -0.10, 0.00, 0.20, -0.15, 0.10])\n    \n    E_base_3 = np.array([1.5, 7.0, 0.7, 3.5, 2.5, 6.5])\n    delta_E_3 = np.array([-0.05, 0.00, 0.10, -0.10, 0.00, -0.20])\n\n    divFq_base_3 = np.array([0.1, -1.0, 0.0, 0.4, -0.2, -0.5])\n    delta_divFq_3 = np.array([0.02, -0.05, 0.00, 0.03, -0.01, 0.04])\n    \n    dWdt_base_3 = np.array([-0.6, -2.0, 0.2, -1.9, -0.3, -1.0])\n    delta_dWdt_3 = np.array([0.00, 0.10, -0.05, 0.00, 0.05, -0.10])\n    \n    case3_data = {\n        \"P\": (P_base_3 + delta_P_3).tolist(),\n        \"E\": (E_base_3 + delta_E_3).tolist(),\n        \"divFq\": (divFq_base_3 + delta_divFq_3).tolist(),\n        \"dWdt\": (dWdt_base_3 + delta_dWdt_3).tolist()\n    }\n\n    # Case 4 (extreme event with one-step mismatch)\n    case4_data = {\n        \"P\": [100.0, 0.0, 25.0],\n        \"E\": [5.0, 2.0, 10.0],\n        \"divFq\": [-10.0, 0.0, 5.0],\n        \"dWdt\": [-84.5, 2.0, -20.0]\n    }\n\n    # Case 5 (all zero terms, exact closure)\n    case5_data = {\n        \"P\": [0.0, 0.0, 0.0, 0.0],\n        \"E\": [0.0, 0.0, 0.0, 0.0],\n        \"divFq\": [0.0, 0.0, 0.0, 0.0],\n        \"dWdt\": [0.0, 0.0, 0.0, 0.0]\n    }\n\n    test_cases = [case1_data, case2_data, case3_data, case4_data, case5_data]\n\n    results = []\n    for case in test_cases:\n        rmse_val = calculate_rmse(\n            P=case[\"P\"],\n            E=case[\"E\"],\n            divFq=case[\"divFq\"],\n            dWdt=case[\"dWdt\"]\n        )\n        results.append(rmse_val)\n\n    # Format the final output as a comma-separated list of strings,\n    # each rounded to three decimal places.\n    formatted_results = [f\"{val:.3f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "区域气候模拟的最终目的之一是评估模型再现真实世界气候特征的能力。本练习将引导你完成一个标准的模型评估流程，即计算泰勒图（Taylor Diagram）所需的核心统计指标。通过将模拟的温度场与观测数据进行定量比较，你将学会计算相关系数、标准差比率和中心化均方根误差，从而客观地评价模型在捕捉气候空间格局和变率方面的性能。",
            "id": "3909096",
            "problem": "给定来自模型的合成季节性区域温度场和相应的观测数据，每个案例代表两个季节。您的任务是计算每个测试案例中每个季节的泰勒图统计量：模型和观测异常场之间的皮尔逊积矩相关系数（PPMCC）、标准差比率以及中心化均方根（RMS）误差。这些统计量是泰勒图（TD）的基础，在区域气候模型中用于评估模型相对于观测的表现。\n\n每个季节性温度场必须被视为一个网格化数值的有限集合，具有以下基本定义：\n- 季节性异常场是通过从场的每个元素中减去该场的季节性平均值来构建的。也就是说，给定一个季节场 $X = \\{x_i\\}_{i=1}^n$，其季节性平均值为 $\\mu_X$，其异常场为每个元素的 $x_i - \\mu_X$。\n- 所有统计数据均使用总体归一化，意味着归一化因子为 $n$，而不是 $n-1$。\n- 标准差比率定义为模型异常的总体标准差与观测异常的总体标准差之比，是无量纲的。\n- 皮尔逊积矩相关系数（PPMCC）是在模型和观测异常场之间计算的总体相关性。\n- 中心化 RMS 误差是模型和观测异常场之间差异的总体均方根。中心化 RMS 误差必须以开尔文（$K$）表示。\n\n科学真实性与一致性：在区域气候模型中，泰勒图汇集这三个统计数据来总结模型技巧。使用异常可以消除平均偏差，因此中心化 RMS 误差强调的是变率和模式上的差异，而不是平均偏移。所有提供的温度值都以开尔文（$K$）为单位，这是一个物理上合适的单位。相关性和标准差比率是无量纲的。中心化 RMS 误差必须以开尔文（$K$）报告。\n\n算法要求：\n- 对于每个测试案例中的每个季节，分别为模型和观测计算季节性平均值，减去这些平均值以获得异常，然后使用总体归一化计算三个统计量。\n- 相关性和标准差比率必须根据异常计算。中心化 RMS 误差必须计算为异常差异的均方根，并必须以开尔文（$K$）表示。\n- 不涉及角度单位。如果在您的中间推理中出现任何类似百分比的量，请确保它以小数形式表示，而不是百分比；但是，您的最终输出不包含任何百分比。\n\n测试套件：\n为以下五个测试案例计算统计数据。每个测试案例包含两个季节：“冬季”和“夏季”。数组列出了以开尔文（$K$）为单位的季节性网格化温度。对于每个季节，第一个数组是观测值，第二个数组是模型值。\n\n- 测试案例 $1$（完美匹配）：\n  - 冬季：观测值 $[270, 272, 271, 273]$，模型值 $[270, 272, 271, 273]$。\n  - 夏季：观测值 $[300, 301, 299, 302]$，模型值 $[300, 301, 299, 302]$。\n\n- 测试案例 $2$（均匀偏差；模型值为观测值加上一个恒定的 $2\\,\\text{K}$ 偏移）：\n  - 冬季：观测值 $[270, 272, 271, 273]$，模型值 $[272, 274, 273, 275]$。\n  - 夏季：观测值 $[300, 301, 299, 302]$，模型值 $[302, 303, 301, 304]$。\n\n- 测试案例 $3$（方差放大；模型异常是观测异常的 $1.5$ 倍）：\n  - 冬季：观测值 $[270, 272, 271, 273]$，模型值 $[269.25, 272.25, 270.75, 273.75]$。\n  - 夏季：观测值 $[300, 301, 299, 302]$，模型值 $[299.75, 301.25, 298.25, 302.75]$。\n\n- 测试案例 $4$（负相关；模型异常是观测异常的负值）：\n  - 冬季：观测值 $[270, 272, 271, 273]$，模型值 $[273, 271, 272, 270]$。\n  - 夏季：观测值 $[300, 301, 299, 302]$，模型值 $[301, 300, 302, 299]$。\n\n- 测试案例 $5$（混合现实变率）：\n  - 冬季：观测值 $[271.2, 272.5, 270.9, 273.1, 271.8]$，模型值 $[270.8, 272.0, 271.1, 272.9, 272.2]$。\n  - 夏季：观测值 $[300.3, 301.7, 299.5, 302.1, 300.9]$，模型值 $[300.1, 301.2, 299.9, 301.8, 300.7]$。\n\n最终输出规范：\n- 对于每个测试案例，按 $[r_{\\text{winter}}, s_{\\text{winter}}, e_{\\text{winter}}, r_{\\text{summer}}, s_{\\text{summer}}, e_{\\text{summer}}]$ 的顺序输出一个包含六个浮点值的列表，其中 $r$ 是相关系数（无量纲），$s$ 是标准差比率（无量纲），$e$ 是以开尔文（$K$）为单位的中心化 RMS 误差。\n- 将所有五个测试案例的结果汇总到一个单一的外部列表中，以便程序产生仅包含一行输出，该输出为用方括号括起来的逗号分隔列表，例如 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题被评估为有效。它在科学上基于区域气候模型评估的既定实践，使用构成泰勒图的标准统计指标。问题陈述清晰，提供了所有必要的数据和明确的计算定义。术语精确，设置自洽且内部一致。\n\n任务是计算用于模型评估的三个统计量：皮尔逊积矩相关系数（$r$）、标准差比率（$s$）和中心化均方根（RMS）误差（$e$）。这些统计量需要针对五个不同的测试案例中的两个季节（“冬季”和“夏季”）进行计算。所提供的数据包括模型（$M$）和相应观测（$O$）的网格化温度场。\n\n假设一个给定的季节场，无论是模型场还是观测场，都表示为一组 $n$ 个值，$\\{x_i\\}_{i=1}^n$。\n\n首先，我们定义季节性异常场。季节性平均值 $\\mu_x$ 计算如下：\n$$\n\\mu_x = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n然后，通过从每个数据点中减去平均值来构建异常场 $\\{x'_i\\}_{i=1}^n$：\n$$\nx'_i = x_i - \\mu_x\n$$\n此过程独立应用于模型场（产生模型异常 $\\{m'_i\\}$）和观测场（产生观测异常 $\\{o'_i\\}$）。\n\n接下来，我们使用总体归一化（即除以 $n$）来定义所需的三个统计量。\n\n一个异常场 $\\{x'_i\\}$ 的总体标准差 $\\sigma$ 由下式给出：\n$$\n\\sigma_x = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (x'_i)^2}\n$$\n请注意，因为异常场的平均值为零，这等同于在原始场 $\\{x_i\\}$ 上计算标准差：\n$$\n\\sigma_x = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (x_i - \\mu_x)^2}\n$$\n我们计算模型异常的标准差 $\\sigma_m$ 和观测异常的标准差 $\\sigma_o$。\n\n1.  **标准差比率（$s$）**：这是模型标准差与观测标准差的无量纲比率。\n    $$\n    s = \\frac{\\sigma_m}{\\sigma_o}\n    $$\n    $s  1$ 的值表示模型高估了空间变率，而 $s  1$ 表示低估。\n\n2.  **皮尔逊积矩相关系数（$r$）**：这衡量了模型和观测异常模式之间的线性相关性。它定义为异常的协方差除以它们标准差的乘积。\n    $$\n    r = \\frac{\\frac{1}{n} \\sum_{i=1}^{n} (m'_i \\cdot o'_i)}{\\sigma_m \\sigma_o} = \\frac{\\sum_{i=1}^{n} (m_i - \\mu_m)(o_i - \\mu_o)}{\\sqrt{\\sum_{i=1}^{n} (m_i - \\mu_m)^2} \\sqrt{\\sum_{i=1}^{n} (o_i - \\mu_o)^2}}\n    $$\n    $r$ 的值范围从 $-1$ 到 $1$，其中 $1$ 表示模型和观测模式之间存在完美的正线性关系，$-1$ 表示完美的负线性关系。\n\n3.  **中心化均方根误差（$e$）**：此指标量化了模型和观测异常场之间差异的典型幅度。它以与原始数据相同的单位表示，在此问题中为开尔文（$K$）。\n    $$\n    e = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (m'_i - o'_i)^2}\n    $$\n    通过使用异常，该指标关注于模式误差，而不受模型和观测之间任何总体平均偏差的影响。\n\n在泰勒图的抽象空间中，这三个统计量通过余弦定律在几何上相关联：\n$$\ne^2 = \\sigma_m^2 + \\sigma_o^2 - 2 \\sigma_m \\sigma_o r\n$$\n这种关系为计算提供了一个有用的检验。例如，在测试案例 2 中，模型有一个 $+2\\,\\text{K}$ 的均匀偏差。当计算异常时，这个偏差被完全移除（$m'_i = o'_i$）。因此，我们期望 $\\sigma_m = \\sigma_o$（所以 $s=1$），完美相关（$r=1$），以及零中心化 RMS 误差（$e=0$），这证明了分析异常的实用性。\n\n解决该问题的算法如下：\n对于每个测试案例及其中的每个季节：\na. 获取所提供的观测和模型温度数组。\nb. 计算观测数组的平均值（$\\mu_o$）和模型数组的平均值（$\\mu_m$）。\nc. 计算观测异常（$o'_i = o_i - \\mu_o$）和模型异常（$m'_i = m_i - \\mu_m$）。\nd. 计算两个异常场的总体标准差 $\\sigma_o$ 和 $\\sigma_m$。\ne. 计算标准差比率 $s = \\sigma_m / \\sigma_o$。\nf. 计算两个异常场之间的皮尔逊相关系数 $r$。\ng. 根据异常场之间的差异计算中心化 RMS 误差 $e$。\nh. 收集该季节的三个统计数据 $[r, s, e]$。\n最后，将所有季节和测试案例的结果组合成指定的嵌套列表结构作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes Taylor diagram statistics for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Test Case 1 (perfect match)\",\n            \"winter\": {\n                \"observations\": [270, 272, 271, 273],\n                \"model\": [270, 272, 271, 273]\n            },\n            \"summer\": {\n                \"observations\": [300, 301, 299, 302],\n                \"model\": [300, 301, 299, 302]\n            }\n        },\n        {\n            \"name\": \"Test Case 2 (uniform bias)\",\n            \"winter\": {\n                \"observations\": [270, 272, 271, 273],\n                \"model\": [272, 274, 273, 275]\n            },\n            \"summer\": {\n                \"observations\": [300, 301, 299, 302],\n                \"model\": [302, 303, 301, 304]\n            }\n        },\n        {\n            \"name\": \"Test Case 3 (variance amplification)\",\n            \"winter\": {\n                \"observations\": [270, 272, 271, 273],\n                \"model\": [269.25, 272.25, 270.75, 273.75]\n            },\n            \"summer\": {\n                \"observations\": [300, 301, 299, 302],\n                \"model\": [299.75, 301.25, 298.25, 302.75]\n            }\n        },\n        {\n            \"name\": \"Test Case 4 (negative correlation)\",\n            \"winter\": {\n                \"observations\": [270, 272, 271, 273],\n                \"model\": [273, 271, 272, 270]\n            },\n            \"summer\": {\n                \"observations\": [300, 301, 299, 302],\n                \"model\": [301, 300, 302, 299]\n            }\n        },\n        {\n            \"name\": \"Test Case 5 (mixed realistic variability)\",\n            \"winter\": {\n                \"observations\": [271.2, 272.5, 270.9, 273.1, 271.8],\n                \"model\": [270.8, 272.0, 271.1, 272.9, 272.2]\n            },\n            \"summer\": {\n                \"observations\": [300.3, 301.7, 299.5, 302.1, 300.9],\n                \"model\": [300.1, 301.2, 299.9, 301.8, 300.7]\n            }\n        }\n    ]\n\n    def calculate_statistics(observations, model):\n        \"\"\"\n        Calculates r, s, and e for a given pair of observation and model fields.\n        \n        Uses population normalization (ddof=0) as specified.\n        \"\"\"\n        obs_np = np.array(observations, dtype=np.float64)\n        mod_np = np.array(model, dtype=np.float64)\n\n        # Calculate anomalies (deviations from the mean)\n        obs_anom = obs_np - np.mean(obs_np)\n        mod_anom = mod_np - np.mean(mod_np)\n\n        # Standard deviations (np.std uses population normalization by default, ddof=0)\n        sigma_obs = np.std(obs_np)\n        sigma_mod = np.std(mod_np)\n\n        # Correlation coefficient (r)\n        # np.corrcoef on original data is identical to on anomaly data\n        # Handle case where standard deviation is zero causing division by zero in correlation\n        if sigma_obs == 0 or sigma_mod == 0:\n            # If one field is constant, correlation is undefined.\n            # In perfect match cases where model==obs and both are constant,\n            # this would be 1, but we can set it to a conventional value like 1\n            # if model anomalies mirror observation anomalies (which they would if both 0).\n            # If one is constant and other is not, it should be 0 or NaN.\n            # However, problem data avoids this. We'll handle it robustly.\n            # If both are constant, anomalies are all 0, correlation is perfect.\n            if sigma_obs == 0 and sigma_mod == 0:\n                 r = 1.0\n            else: # one is constant, other is not\n                 r = np.nan # Or 0, depending on convention. NaN is mathematically sound.\n                           # Let's trust corrcoef's behavior, it will return NaN.\n                 corr_matrix = np.corrcoef(obs_np, mod_np)\n                 r = corr_matrix[0, 1] # will be nan, let's fix to 0 if that happens\n                 if np.isnan(r):\n                     r = 0.0 # A reasonable default for an uncorrelated constant.\n        else:\n            corr_matrix = np.corrcoef(obs_np, mod_np)\n            r = corr_matrix[0, 1]\n\n        # Standard deviation ratio (s)\n        # Handle case where observation standard deviation is zero\n        if sigma_obs == 0:\n            if sigma_mod == 0:\n                s = 1.0 # Both constant, so they have same variability\n            else:\n                s = np.inf # Model has variability, obs has none\n        else:\n            s = sigma_mod / sigma_obs\n\n        # Centered RMS error (e)\n        e = np.sqrt(np.mean((mod_anom - obs_anom)**2))\n\n        return r, s, e\n    \n    all_results = []\n    for case in test_cases:\n        case_results = []\n        \n        # Winter\n        r_w, s_w, e_w = calculate_statistics(case[\"winter\"][\"observations\"], case[\"winter\"][\"model\"])\n        case_results.extend([r_w, s_w, e_w])\n\n        # Summer\n        r_s, s_s, e_s = calculate_statistics(case[\"summer\"][\"observations\"], case[\"summer\"][\"model\"])\n        case_results.extend([r_s, s_s, e_s])\n        \n        all_results.append(case_results)\n\n    # Format the final output string to match the required format `[[...],[...]]`\n    inner_list_strings = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        inner_list_strings.append(inner_str)\n    \n    final_output = f\"[{','.join(inner_list_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}