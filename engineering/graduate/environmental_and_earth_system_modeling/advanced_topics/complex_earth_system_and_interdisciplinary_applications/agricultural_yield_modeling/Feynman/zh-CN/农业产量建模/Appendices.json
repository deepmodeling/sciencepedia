{
    "hands_on_practices": [
        {
            "introduction": "准确模拟作物的发育阶段（即物候）是农业产量模型的基础，因为它决定了整个生长季的时间框架。本练习  将指导你将温度、光周期和春化作用等关键环境驱动因素，编码成一个预测冬小麦开花时间的动态模型。通过实现这一核心模块，你将掌握把生物物理原理转化为算法的基本技能，这是构建任何过程型作物模型的关键一步。",
            "id": "3860938",
            "problem": "实现一个程序，该程序在温度、光周期和春化温度的每日驱动下，计算一个冬小麦品种从播种到开花的持续时间。该品种由基点温度、光周期敏感性、春化需求和一个内在发育时间尺度来表征。计算必须遵循以下基于物理和生物学基础的原理和定义，并且所有输出必须以天为单位，作为整数天数返回。\n\n使用以下基本依据：\n\n1. 每日发育速率定义：朝向开花的瞬时进展速率与乘性环境响应标量和一个内在时间尺度成正比。设 $r(d)$ 为第 $d$ 天的日指数速率。则\n$$\nr(d) = k \\cdot f_T(T(d)) \\cdot f_P(P(d)) \\cdot f_V(V(d)),\n$$\n其中 $k$ 是内在速率常数，单位为 $\\text{day}^{-1}$，$f_T$ 是温度响应标量，范围在 $[0,1]$，$f_P$ 是光周期响应标量，范围在 $[0,1]$，$f_V$ 是春化完成度标量，范围在 $[0,1]$。\n\n2. 事件标准：开花发生在最早的一天 $D$，使得累积发育量达到品种特定的阈值 $D_{\\text{req}}$：\n$$\n\\sum_{i=1}^{D} r(i) \\ge D_{\\text{req}}.\n$$\n如果在提供的每日序列中不存在这样的 $D$，则该情况的输出必须为 $-1$。\n\n3. 使用基点温度的温度响应：设基点温度为基温 $T_b$、最适温度 $T_o$ 和上限温度 $T_c$，单位为 $\\,^{\\circ}\\text{C}$。通过分段线性函数定义 $f_T(T)$：\n- 如果 $T \\le T_b$，$f_T(T) = 0$。\n- 如果 $T_b  T \\le T_o$，$f_T(T) = \\dfrac{T - T_b}{T_o - T_b}$。\n- 如果 $T_o  T  T_c$，$f_T(T) = \\dfrac{T_c - T}{T_c - T_o}$。\n- 如果 $T \\ge T_c$，$f_T(T) = 0$。\n\n4. 长日照谷物的光周期响应：设临界光周期为 $P_{\\text{crit}}$，饱和光周期为 $P_{\\text{opt}}$，单位为 $\\text{hours}$。引入一个最小光周期因子 $s_{P,\\min}$，表示在极短日照下的残余发育。将 $f_P(P)$ 定义为一个有界线性标量：\n- 如果 $P \\le P_{\\text{crit}}$，$f_P(P) = s_{P,\\min}$。\n- 如果 $P_{\\text{crit}}  P  P_{\\text{opt}}$，\n$$\nf_P(P) = s_{P,\\min} + \\left( \\frac{P - P_{\\text{crit}}}{P_{\\text{opt}} - P_{\\text{crit}}} \\right) \\cdot (1 - s_{P,\\min}).\n$$\n- 如果 $P \\ge P_{\\text{opt}}$，$f_P(P) = 1$。\n\n5. 春化累积与效应：每日春化单位累积量 $a_V(T_v)$ 是春化温度 $T_v$（单位为 $\\,^{\\circ}\\text{C}$）的三角函数，其参数为 $T_{v,\\min}$、$T_{v,\\opt}$ 和 $T_{v,\\max}$：\n- 如果 $T_v \\le T_{v,\\min}$，$a_V(T_v) = 0$。\n- 如果 $T_{v,\\min}  T_v \\le T_{v,\\opt}$，\n$$\na_V(T_v) = \\frac{T_v - T_{v,\\min}}{T_{v,\\opt} - T_{v,\\min}}.\n$$\n- 如果 $T_{v,\\opt}  T_v  T_{v,\\max}$，\n$$\na_V(T_v) = \\frac{T_{v,\\max} - T_v}{T_{v,\\max} - T_{v,\\opt}}.\n$$\n- 如果 $T_v \\ge T_{v,\\max}$，$a_V(T_v) = 0$。\n\n累积春化量为\n$$\nV(d) = \\min\\left(V_{\\text{req}}, \\sum_{i=1}^{d} a_V(T_v(i))\\right),\n$$\n而春化效应标量为\n$$\nf_V(V(d)) = \\frac{V(d)}{V_{\\text{req}}}.\n$$\n\n品种参数（除非在各测试案例中另有说明，否则为常数）：\n- 基点温度：$T_b = 0\\,^{\\circ}\\text{C}$，$T_o = 18\\,^{\\circ}\\text{C}$，$T_c = 35\\,^{\\circ}\\text{C}$。\n- 光周期敏感性：$P_{\\text{crit}} = 8 \\ \\text{hours}$，$P_{\\text{opt}} = 16 \\ \\text{hours}$，$s_{P,\\min} = 0.5$。\n- 春化参数：$T_{v,\\min} = 0\\,^{\\circ}\\text{C}$，$T_{v,\\opt} = 6\\,^{\\circ}\\text{C}$，$T_{v,\\max} = 15\\,^{\\circ}\\text{C}$，$V_{\\text{req}} = 40$（无量纲单位）。\n- 发育阈值：$D_{\\text{req}} = 1.0$（无量纲）。\n\n内在发育速率常数 $k$（在各测试案例中指定）：见下文测试套件。$k$ 的单位是 $\\text{day}^{-1}$。\n\n每日序列生成和单位：\n- 所有温度 $T(d)$ 和 $T_v(d)$ 单位为 $\\,^{\\circ}\\text{C}$。\n- 所有光周期 $P(d)$ 单位为 $\\text{hours}$。\n- 所有天数计数必须以 $\\text{days}$ 为单位，作为整数报告。\n\n测试套件（四个案例；每个案例定义 $N$ 天和每日序列）：\n\n- 案例 1 (温带季节性进展，典型冬小麦，理想路径)：\n    - $N = 220$。\n    - $T(d) = 6 + 7 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 20)}{365}\\right)$ 对于 $d = 1,2,\\dots,N$。\n    - $P(d) = 12 + 4 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 20)}{365}\\right)$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.012$。\n\n- 案例 2 (边界光周期处于临界阈值；相同的热力驱动)：\n    - $N = 220$。\n    - $T(d) = 6 + 7 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 20)}{365}\\right)$。\n    - $P(d) = P_{\\text{crit}} = 8$ 对于所有 $d$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.012$。\n\n- 案例 3 (因温度过高导致春化不足)：\n    - $N = 200$。\n    - $T(d) = 20 + 4 \\cdot \\sin\\left(\\dfrac{2\\pi d}{365}\\right)$。\n    - $P(d) = 12 + 2 \\cdot \\sin\\left(\\dfrac{2\\pi d}{365}\\right)$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.012$。\n\n- 案例 4 (在适宜温度下发育较慢的品种)：\n    - $N = 250$。\n    - $T(d) = 14 + 6 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 60)}{365}\\right)$。\n    - $P(d) = 11 + 3 \\cdot \\sin\\left(\\dfrac{2\\pi (d - 60)}{365}\\right)$。\n    - $T_v(d) = T(d)$。\n    - $k = 0.008$。\n\n算法任务：\n- 对于每个案例，计算 $f_T(T(d))$, $f_P(P(d))$, $a_V(T_v(d))$, $V(d)$, $f_V(V(d))$ 和 $r(d)$ 对所有 $d$ 进行计算，然后确定满足 $\\sum_{i=1}^{D} r(i) \\ge D_{\\text{req}}$ 的最小天数 $D$。如果对于 $d \\in \\{1,\\dots,N\\}$ 不存在这样的 $D$，则报告 $-1$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个案例的结果，格式为方括号内以逗号分隔的列表（例如，`[result1,result2,result3,result4]`），其中每个结果是从播种到开花的整数天数（单位为 $\\text{days}$），如果在给定的 $N$ 天内未发生开花，则为 $-1$。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于环境和地球系统模拟（特别是作物物候学）的原理，并且在数学上是适定的、客观的、自洽的。所有必需的方程、参数和环境驱动数据都已提供，从而能够得出唯一且可验证的解。\n\n解决方案是通过为四个测试案例中的每一个实施一个离散时间日步长模拟模型来找到的。该模型根据每日环境输入计算冬小麦品种朝向开花的进展。模型的核心是计算每日发育速率 $r(d)$，然后将其随时间积分，直到达到指定的发育阈值。\n\n第 $d$ 天的每日发育速率由以下方程给出：\n$$\nr(d) = k \\cdot f_T(T(d)) \\cdot f_P(P(d)) \\cdot f_V(V(d))\n$$\n在此，$k$ 是品种的内在发育速率常数，单位为 $\\text{day}^{-1}$。项 $f_T$、$f_P$ 和 $f_V$ 是介于 $0$ 和 $1$ 之间的无量纲标量，分别代表温度、光周期和春化的限制效应。\n\n在模拟的每一天 $d$（从 $d=1$ 到案例指定的最大天数 $N$），执行以下步骤：\n\n1.  **环境驱动计算**：根据每个测试案例提供的正弦函数，计算日平均温度 $T(d)$、光周期 $P(d)$ 和春化温度 $T_v(d)$。对于所有案例，指定 $T_v(d) = T(d)$。\n\n2.  **温度响应标量 $f_T(T(d))$**：此标量是使用日温 $T(d)$ 和品种的基点温度：基温 $T_b = 0\\,^{\\circ}\\text{C}$、最适温度 $T_o = 18\\,^{\\circ}\\text{C}$ 和上限温度 $T_c = 35\\,^{\\circ}\\text{C}$ 的分段线性（三角）函数计算得出的。该函数定义为：\n    -   如果 $T \\le T_b$ 或 $T \\ge T_c$，则 $f_T(T) = 0$。\n    -   如果 $T_b  T \\le T_o$，则 $f_T(T) = (T - T_b) / (T_o - T_b)$。\n    -   如果 $T_o  T  T_c$，则 $f_T(T) = (T_c - T) / (T_c - T_o)$。\n    该函数在允许生长的温度范围之外取值为 $0$，并在最适温度下线性扩展到最大值 $1$。\n\n3.  **光周期响应标量 $f_P(P(d))$**：此标量量化了植物对日长 $P(d)$ 的响应。对于像冬小麦这样的长日照植物，发育会随着日照变长而加速。该函数是一个基于临界光周期 $P_{\\text{crit}} = 8 \\ \\text{hours}$、饱和光周期 $P_{\\text{opt}} = 16 \\ \\text{hours}$ 和最小响应因子 $s_{P,\\min} = 0.5$ 的有界线性模型。\n    -   如果 $P \\le P_{\\text{crit}}$，发育以基线速率进行，因此 $f_P(P) = s_{P,\\min}$。\n    -   如果 $P \\ge P_{\\text{opt}}$，光周期需求完全满足，因此 $f_P(P) = 1$。\n    -   如果 $P_{\\text{crit}}  P  P_{\\text{opt}}$，响应线性插值：$f_P(P) = s_{P,\\min} + ( (P - P_{\\text{crit}}) / (P_{\\text{opt}} - P_{\\text{crit}}) ) \\cdot (1 - s_{P,\\min})$。\n\n4.  **春化响应标量 $f_V(V(d))$**：该分量模拟低温需求的满足过程，这对于冬小麦获得开花能力至关重要。计算是一个涉及状态累积的两步过程。\n    -   首先，根据春化温度 $T_v(d)$ 计算每日春化单位累积量 $a_V(T_v(d))$。这也遵循一个三角响应函数，其春化基点温度为 $T_{v,\\min} = 0\\,^{\\circ}\\text{C}$，$T_{v,\\opt} = 6\\,^{\\circ}\\text{C}$ 和 $T_{v,\\max} = 15\\,^{\\circ}\\text{C}$。如果温度低于 $T_{v,\\min}$ 或高于 $T_{v,\\max}$，则不发生春化，最大累积速率（每天 $1$ 个单位）发生在 $T_{v,\\opt}$。\n    -   这些每日单位随时间累积：$V_{\\text{accum}}(d) = \\sum_{i=1}^{d} a_V(T_v(i))$。\n    -   有效累积春化量 $V(d)$ 是累积总量与总需求量 $V_{\\text{req}} = 40$ 单位中的较小者：$V(d) = \\min(V_{\\text{req}}, V_{\\text{accum}}(d))$。\n    -   最后，春化标量 $f_V(V(d))$ 是已满足的春化需求的比例：$f_V(V(d)) = V(d) / V_{\\text{req}}$。该值随着低温需求的满足从 $0$ 增加到 $1$。\n\n5.  **累积发育与事件标准**：通过将内在速率 $k$ 与三个环境标量相乘来计算每日速率 $r(d)$。该速率被添加到一个运行总和 `cumulative_development_sum` 中。模拟在每一天 $d$ 检查该总和是否已达到或超过总发育需求 $D_{\\text{req}} = 1.0$。首次满足此条件 $\\sum_{i=1}^{D} r(i) \\ge D_{\\text{req}}$ 的那一天 $D$ 即为预测的开花日期。\n\n6.  **终止**：给定案例的模拟以两种方式之一终止。如果在第 $D$ 天满足开花标准，则整数 $D$ 被记录为结果。如果模拟完成所有 $N$ 天而未满足标准，则表示未发生开花，结果记录为 $-1$。\n\n这整个过程独立地应用于问题陈述中定义的四个测试案例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sowing-to-flowering duration for a winter wheat cultivar\n    based on a daily-time-step phenology model.\n    \"\"\"\n\n    # Cultivar parameters (constant across all cases)\n    T_b, T_o, T_c = 0.0, 18.0, 35.0  # Cardinal temperatures for growth\n    P_crit, P_opt, s_P_min = 8.0, 16.0, 0.5  # Photoperiod parameters\n    T_v_min, T_v_opt, T_v_max = 0.0, 6.0, 15.0  # Cardinal vernalization temperatures\n    V_req = 40.0  # Vernalization requirement\n    D_req = 1.0  # Development threshold\n\n    def calculate_f_T(T):\n        \"\"\"Calculates the temperature response scalar f_T.\"\"\"\n        if T = T_b or T = T_c:\n            return 0.0\n        elif T_b  T = T_o:\n            return (T - T_b) / (T_o - T_b)\n        else:  # T_o  T  T_c\n            return (T_c - T) / (T_c - T_o)\n\n    def calculate_f_P(P):\n        \"\"\"Calculates the photoperiod response scalar f_P.\"\"\"\n        if P = P_crit:\n            return s_P_min\n        elif P = P_opt:\n            return 1.0\n        else:  # P_crit  P  P_opt\n            return s_P_min + ((P - P_crit) / (P_opt - P_crit)) * (1.0 - s_P_min)\n            \n    def calculate_a_V(T_v):\n        \"\"\"Calculates the daily vernalization unit accrual a_V.\"\"\"\n        if T_v = T_v_min or T_v = T_v_max:\n            return 0.0\n        elif T_v_min  T_v = T_v_opt:\n            return (T_v - T_v_min) / (T_v_opt - T_v_min)\n        else: # T_v_opt  T_v  T_v_max\n            return (T_v_max - T_v) / (T_v_max - T_v_opt)\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"N\": 220, \"k\": 0.012,\n            \"T_func\": lambda d: 6.0 + 7.0 * np.sin(2 * np.pi * (d - 20) / 365.0),\n            \"P_func\": lambda d: 12.0 + 4.0 * np.sin(2 * np.pi * (d - 20) / 365.0),\n        },\n        {\n            \"N\": 220, \"k\": 0.012,\n            \"T_func\": lambda d: 6.0 + 7.0 * np.sin(2 * np.pi * (d - 20) / 365.0),\n            \"P_func\": lambda d: P_crit,\n        },\n        {\n            \"N\": 200, \"k\": 0.012,\n            \"T_func\": lambda d: 20.0 + 4.0 * np.sin(2 * np.pi * d / 365.0),\n            \"P_func\": lambda d: 12.0 + 2.0 * np.sin(2 * nppi * d / 365.0),\n        },\n        {\n            \"N\": 250, \"k\": 0.008,\n            \"T_func\": lambda d: 14.0 + 6.0 * np.sin(2 * np.pi * (d - 60) / 365.0),\n            \"P_func\": lambda d: 11.0 + 3.0 * np.sin(2 * np.pi * (d - 60) / 365.0),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        k = case[\"k\"]\n        T_func = case[\"T_func\"]\n        P_func = case[\"P_func\"]\n\n        cumulative_development_sum = 0.0\n        cumulative_vernalization_units = 0.0\n        flowering_day = -1\n\n        for d in range(1, N + 1):\n            # Calculate daily environmental drivers\n            T_d = T_func(d)\n            P_d = P_func(d)\n            T_v_d = T_d\n\n            # Calculate response scalars\n            f_T_d = calculate_f_T(T_d)\n            f_P_d = calculate_f_P(P_d)\n\n            # Update vernalization status and calculate f_V\n            a_V_d = calculate_a_V(T_v_d)\n            cumulative_vernalization_units += a_V_d\n            V_d = min(V_req, cumulative_vernalization_units)\n            f_V_d = V_d / V_req if V_req  0 else 1.0\n\n            # Calculate daily development rate\n            r_d = k * f_T_d * f_P_d * f_V_d\n\n            # Update cumulative development sum\n            cumulative_development_sum += r_d\n\n            # Check for flowering\n            if cumulative_development_sum = D_req:\n                flowering_day = d\n                break\n        \n        results.append(flowering_day)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "过程模型通常由常微分方程组（ODEs）描述，并通过时间步进方案进行数值求解。本练习  深入探讨了模型数值积分的核心问题：稳定性，特别是当模型包含不同时间尺度的过程时。你将通过分析一个耦合了快（物候）慢（土壤水分）过程的系统，推导出前向欧拉法保持稳定的条件，并理解为何不恰当的时间步长会导致模拟失败。",
            "id": "3860911",
            "problem": "在一个用于环境与地球系统模拟中农业产量模拟的机理作物模型中，考虑一个关于物候进展和土壤水分异常相对于日平均平衡态的微小偏差的双状态连续时间表示。令 $p(t)$ 表示物候阶段的无量纲偏差，$s(t)$ 表示植物有效含水量的无量纲偏差。假设在平衡态附近，该动力学行为可由一个线性时不变常微分方程(ODE)组很好地近似\n$$\n\\frac{d}{dt}\\begin{pmatrix} p \\\\ s \\end{pmatrix} = A \\begin{pmatrix} p \\\\ s \\end{pmatrix}, \\quad A = \\begin{pmatrix} -\\frac{1}{\\tau_p}  \\gamma \\\\ \\delta  -\\frac{1}{\\tau_s} \\end{pmatrix},\n$$\n其中 $\\tau_p$ 是表示快速转变的物候调整时间尺度，$\\tau_s$ 是表示慢过程的土壤湿度调整时间尺度，$\\gamma$ 和 $\\delta$ 是捕捉物候与土壤湿度之间线性化耦合的交叉耦合灵敏度。假设参数为\n$$\n\\tau_p = 0.5 \\text{ 天}, \\quad \\tau_s = 40 \\text{ 天}, \\quad \\gamma = 0.2 \\text{ 天}^{-1}, \\quad \\delta = 0.01 \\text{ 天}^{-1}.\n$$\n你将使用前向（显式）欧拉时间步进格式进行每日状态更新。\n\n任务：\n1) 从时间导数作为有限差分极限的定义以及时间上的一阶泰勒展开出发，推导该系统在通用步长 $h$（单位为天）下的前向欧拉离散时间更新，将更新表示为\n$$\n\\begin{pmatrix} p_{n+1} \\\\ s_{n+1} \\end{pmatrix} = M(h) \\begin{pmatrix} p_n \\\\ s_n \\end{pmatrix},\n$$\n并用 $A$ 和 $h$ 显式地给出 $M(h)$。\n\n2) 使用离散时间线性系统的线性稳定性定义，推导一个保证前向欧拉方法下平衡点渐近稳定的关于 $h$ 的条件，该条件用 $A$ 的特征值表示。\n\n3) 对于给定的参数值，计算使得前向欧拉更新是线性稳定的最大时间步长 $h_{\\max}$（单位为天）。将你的答案四舍五入到四位有效数字。以天为单位表示最终答案。",
            "solution": "该问题要求对一个描述作物模型中物候和土壤水分偏差的线性常微分方程(ODE)组进行三部分分析。分析内容包括：使用前向欧拉方法离散化该系统，确定数值稳定性的条件，以及为给定参数集计算最大稳定时间步长。\n\n设状态向量为 $\\mathbf{x}(t) = \\begin{pmatrix} p(t) \\\\ s(t) \\end{pmatrix}$。控制ODE系统为 $\\frac{d\\mathbf{x}}{dt} = A\\mathbf{x}$。\n\n### 任务1：前向欧拉更新的推导\n\n前向欧拉方法使用状态向量 $\\mathbf{x}(t)$ 在时间 $t_n$ 附近的一阶泰勒展开来近似时间 $t_{n+1} = t_n + h$ 的状态：\n$$\n\\mathbf{x}(t_n + h) = \\mathbf{x}(t_n) + h \\frac{d\\mathbf{x}}{dt}\\bigg|_{t=t_n} + O(h^2)\n$$\n此处，$h$ 是时间步长。令 $\\mathbf{x}_n \\equiv \\mathbf{x}(t_n)$ 和 $\\mathbf{x}_{n+1} \\equiv \\mathbf{x}(t_n + h)$。连续时间ODE系统由 $\\frac{d\\mathbf{x}}{dt} = A\\mathbf{x}$ 给出。将此代入泰勒展开式，得到：\n$$\n\\mathbf{x}(t_{n+1}) = \\mathbf{x}(t_n) + h (A\\mathbf{x}(t_n)) + O(h^2)\n$$\n前向欧拉格式是通过截断此展开式，忽略 $h^2$ 及更高阶的项推导得出的。这就得出了离散时间更新规则：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + h A\\mathbf{x}_n\n$$\n提取公因子 $\\mathbf{x}_n$，我们得到所需矩阵形式的更新：\n$$\n\\mathbf{x}_{n+1} = (I + hA) \\mathbf{x}_n\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。因此，更新矩阵 $M(h)$ 由下式给出：\n$$\nM(h) = I + hA\n$$\n代入给定的矩阵 $A = \\begin{pmatrix} -1/\\tau_p  \\gamma \\\\ \\delta  -1/\\tau_s \\end{pmatrix}$ 和 $I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$：\n$$\nM(h) = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + h \\begin{pmatrix} -1/\\tau_p  \\gamma \\\\ \\delta  -1/\\tau_s \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{h}{\\tau_p}  h\\gamma \\\\ h\\delta  1 - \\frac{h}{\\tau_s} \\end{pmatrix}\n$$\n这就是更新矩阵 $M(h)$ 的显式形式。\n\n### 任务2：稳定性条件的推导\n\n离散时间系统由 $\\mathbf{x}_{n+1} = M(h) \\mathbf{x}_n$ 给出。平衡点为 $\\mathbf{x}_{\\text{eq}} = \\mathbf{0}$。为使该平衡点渐近稳定，任何从平衡点出发的初始偏差 $\\mathbf{x}_0$ 都必须随时间推移衰减到零，即 $\\lim_{n \\to \\infty} \\mathbf{x}_n = \\mathbf{0}$。\n重复应用更新规则，我们发现第 $n$ 步的状态与初始状态 $\\mathbf{x}_0$ 的关系为：\n$$\n\\mathbf{x}_n = (M(h))^n \\mathbf{x}_0\n$$\n对于任意 $\\mathbf{x}_0$，条件 $\\mathbf{x}_n \\to \\mathbf{0}$ 成立的充要条件是，迭代矩阵 $M(h)$ 的所有特征值（我们将其记为 $\\lambda_M$）的模长都小于1。也就是说，$M(h)$ 的谱半径必须小于1：\n$$\n\\rho(M(h)) = \\max_i |\\lambda_{M,i}|  1\n$$\n设 $\\lambda_A$ 是矩阵 $A$ 的一个特征值，其对应的特征向量为 $\\mathbf{v}$，使得 $A\\mathbf{v} = \\lambda_A \\mathbf{v}$。我们可以通过将 $M(h)$ 应用于特征向量 $\\mathbf{v}$ 来找到 $A$ 和 $M(h)$ 的特征值之间的关系：\n$$\nM(h)\\mathbf{v} = (I + hA)\\mathbf{v} = I\\mathbf{v} + hA\\mathbf{v} = \\mathbf{v} + h(\\lambda_A \\mathbf{v}) = (1 + h\\lambda_A)\\mathbf{v}\n$$\n这表明 $\\mathbf{v}$ 也是 $M(h)$ 的特征向量，其对应的特征值为 $\\lambda_M = 1 + h\\lambda_A$。\n因此，稳定性条件 $|\\lambda_M|  1$ 可以用 $A$ 的特征值表示为：\n$$\n|1 + h\\lambda_A|  1 \\quad \\forall \\lambda_A \\in \\text{eig}(A)\n$$\n这就是保证该系统的前向欧拉方法渐近稳定的关于步长 $h$ 的通用条件。特征值 $\\lambda_A$ 可能是复数。\n\n### 任务3：最大稳定时间步长 $h_{\\max}$ 的计算\n\n首先，我们将给定的参数值代入矩阵 $A$：\n$$\n\\tau_p = 0.5 \\text{ 天}, \\quad \\tau_s = 40 \\text{ 天}, \\quad \\gamma = 0.2 \\text{ 天}^{-1}, \\quad \\delta = 0.01 \\text{ 天}^{-1}\n$$\n$$\nA = \\begin{pmatrix} -\\frac{1}{0.5}  0.2 \\\\ 0.01  -\\frac{1}{40} \\end{pmatrix} = \\begin{pmatrix} -2  0.2 \\\\ 0.01  -0.025 \\end{pmatrix}\n$$\n矩阵 $A$ 中所有元素的单位都是 天$^{-1}$。$A$ 的特征值（记为 $\\lambda_A$）是特征方程 $\\det(A - \\lambda_A I) = 0$ 的根：\n$$\n\\det\\begin{pmatrix} -2 - \\lambda_A  0.2 \\\\ 0.01  -0.025 - \\lambda_A \\end{pmatrix} = 0\n$$\n$$\n(-2 - \\lambda_A)(-0.025 - \\lambda_A) - (0.2)(0.01) = 0\n$$\n$$\n\\lambda_A^2 + 2.025\\lambda_A + 0.05 - 0.002 = 0\n$$\n$$\n\\lambda_A^2 + 2.025\\lambda_A + 0.048 = 0\n$$\n我们使用求根公式 $\\lambda_A = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来解这个关于 $\\lambda_A$ 的二次方程：\n$$\n\\lambda_A = \\frac{-2.025 \\pm \\sqrt{(2.025)^2 - 4(1)(0.048)}}{2(1)}\n$$\n$$\n\\lambda_A = \\frac{-2.025 \\pm \\sqrt{4.100625 - 0.192}}{2} = \\frac{-2.025 \\pm \\sqrt{3.908625}}{2}\n$$\n由于判别式为正且 $\\sqrt{3.908625} \\approx 1.977024  2.025$，特征值为实数且为负。\n$$\n\\lambda_{A,1} = \\frac{-2.025 + 1.9770242...}{2} \\approx -0.0239878... \\text{ 天}^{-1}\n$$\n$$\n\\lambda_{A,2} = \\frac{-2.025 - 1.9770242...}{2} \\approx -2.0010121... \\text{ 天}^{-1}\n$$\n对于实的负特征值 $\\lambda_A = -k$（其中 $k>0$），稳定性条件 $|1 + h\\lambda_A|  1$ 变为 $|1 - hk|  1$。这个不等式等价于 $-1  1 - hk  1$，化简为 $0  hk  2$，或 $0  h  2/k = 2/|\\lambda_A|$。\n\n这个条件必须对两个特征值都成立。对 $h$ 最严格的约束来自模长最大的特征值，即 $\\lambda_{A,2} \\approx -2.0010121...$ 天$^{-1}$。\n$$\nh  \\frac{2}{|\\lambda_{A,1}|} \\approx \\frac{2}{0.0239878...} \\approx 83.375... \\text{ 天}\n$$\n$$\nh  \\frac{2}{|\\lambda_{A,2}|} \\approx \\frac{2}{2.0010121...} \\approx 0.999494... \\text{ 天}\n$$\n为了同时满足两个条件，$h$ 必须小于这两个上界的最小值。因此，最大稳定时间步长 $h_{\\max}$ 由模长最大的特征值决定：\n$$\nh_{\\max} = \\frac{2}{\\max_i|\\lambda_{A,i}|} = \\frac{2}{|-2.0010121...|} \\approx 0.999494... \\text{ 天}\n$$\n按要求将结果四舍五入到四位有效数字：\n$$\nh_{\\max} \\approx 0.9995 \\text{ 天}\n$$\n这意味着根据此线性稳定性分析，每日时间步长（$h=1$ 天）将是临界不稳定的。",
            "answer": "$$\n\\boxed{0.9995}\n$$"
        },
        {
            "introduction": "一个模型的价值最终取决于其预测新数据的能力。本练习  将引导你完成模型验证的关键步骤，使用k折交叉验证来严格评估模型的泛化性能。你将从头开始实现一个完整的交叉验证工作流，包括数据划分、迭代训练、和在汇总测试集上计算性能指标，这项实践对于培养构建可靠、可信的环境模型的严谨思维至关重要。",
            "id": "3860914",
            "problem": "提供给您两个跨越多年和多个地点的农业产量数据集。在每个数据集中，都有模拟产量和观测产量的成对观测值。对于样本索引 $i$，设观测产量表示为 $o_i$（单位：吨/公顷，t/ha），模拟产量表示为 $s_i$（单位：吨/公顷，t/ha）。为评估一个简单偏差校正模型的泛化能力并评价其预测性能，您必须对每个数据集中的所有样本执行确定性的 $k$ 折交叉验证，并在合并的测试集预测上计算指定的评估指标。交叉验证过程必须满足以下约束：\n- 样本按站点标识符（升序）排序，然后按年份（升序）排序。\n- 样本 $i$ 的折数索引为 $f_i = i \\bmod k$，其中 $i$ 在排序后从 $0$ 开始，而 $k$ 是折数。\n- 对于每个折 $j \\in \\{0,1,\\dots,k-1\\}$，训练集由所有满足 $f_i \\neq j$ 的样本组成，测试集由所有满足 $f_i = j$ 的样本组成。\n\n要在每个训练集上拟合的预测模型是一个从模拟产量到观测产量的线性偏差校正映射，\n$$\n\\hat{o}_i = a\\, s_i + b,\n$$\n其标量参数为 $a$ 和 $b$。这些参数必须通过最小化训练集上残差平方和的普通最小二乘法来估计。拟合后，您必须在相应的测试集上生成预测值 $\\hat{o}_i$，最后将所有折的测试集预测合并，以在合并的测试集上计算所要求的评估指标。\n\n评估指标基于误差 $e_i = \\hat{o}_i - o_i$ 从第一性原理定义如下：\n- 均方根误差 (RMSE，单位：t/ha)：$$\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} e_i^2}.$$\n- 平均绝对误差 (MAE，单位：t/ha)：$$\\mathrm{MAE} = \\frac{1}{n}\\sum_{i=1}^{n} |e_i|.$$\n- 偏差 (Bias，单位：t/ha)：$$\\mathrm{Bias} = \\frac{1}{n}\\sum_{i=1}^{n} e_i.$$\n- Nash–Sutcliffe 效率 (NSE，无量纲)：$$\\mathrm{NSE} = 1 - \\frac{\\sum_{i=1}^{n} e_i^2}{\\sum_{i=1}^{n} (o_i - \\bar{o})^2},$$ 其中 $\\bar{o}$ 是合并测试集上观测产量的平均值。\n\n所有产量单位均为吨/公顷 (t/ha)。任何中间值或最终值都必须使用这些单位进行一致性计算，任何具有物理单位的指标都必须以 t/ha 表示。Nash–Sutcliffe 效率是无单位的。\n\n您的程序必须为以下测试套件实现上述过程。每个数据集以下文的 $(\\text{站点}, \\text{年份}, s, o)$ 元组形式完整指定，其中 $s$ 和 $o$ 的单位为 t/ha：\n\n数据集 A (多站点，多年)：\n- 站点 $0$：年份 $2015$ 至 $2018$\n  - $(0, 2015, 4.9, 5.2)$, $(0, 2016, 5.7, 5.6)$, $(0, 2017, 6.0, 6.1)$, $(0, 2018, 5.5, 5.8)$\n- 站点 $1$：年份 $2015$ 至 $2018$\n  - $(1, 2015, 6.5, 7.1)$, $(1, 2016, 7.0, 6.8)$, $(1, 2017, 7.3, 7.4)$, $(1, 2018, 7.2, 7.0)$\n- 站点 $2$：年份 $2015$ 至 $2018$\n  - $(2, 2015, 3.5, 3.8)$, $(2, 2016, 4.0, 4.2)$, $(2, 2017, 4.7, 4.5)$, $(2, 2018, 3.9, 4.0)$\n\n数据集 B (单站点，多年)：\n- 站点 $3$：年份 $2015$ 至 $2019$\n  - $(3, 2015, 3.5, 4.0)$, $(3, 2016, 4.2, 4.0)$, $(3, 2017, 3.8, 4.0)$, $(3, 2018, 4.5, 4.0)$, $(3, 2019, 4.0, 4.0)$\n\n对于以下每个测试用例，请实现上述确定性 $k$ 折交叉验证程序，并在合并的测试集预测上计算指标：\n- 用例 1：数据集 A，$k=3$，指标 $\\mathrm{NSE}$ (无量纲)。将结果报告为小数点后保留六位的小数。\n- 用例 2：数据集 A，$k=4$，指标 $\\mathrm{RMSE}$ (单位：t/ha)。将结果报告为小数点后保留六位的小数。\n- 用例 3：数据集 B，$k=5$，指标 $\\mathrm{Bias}$ (单位：t/ha)。将结果报告为小数点后保留六位的小数。\n\n您的程序应生成单行输出，其中包含按用例 1、用例 2、用例 3 顺序排列的结果，形式为方括号括起来的逗号分隔列表，每个数字格式化为小数点后恰好六位（例如，`[0.123456,0.654321,-0.000100]`）。",
            "solution": "我们从环境与地球系统建模中用于确定性评估预测模型的基本定义开始。产量预测通过使用基于误差的指标将模拟产量与观测产量进行比较来评估。设观测产量为 $o_i \\in \\mathbb{R}$，模拟产量为 $s_i \\in \\mathbb{R}$，两者均以吨/公顷 (t/ha) 为单位。我们将预测模型定义为一个线性偏差校正映射，\n$$\n\\hat{o}_i = a\\, s_i + b,\n$$\n其中 $a \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$ 是待从数据中估计的参数。建模假设是，模拟产量与观测产量之间的关系可以通过仿射变换来近似，随机误差由残差 $\\epsilon_i = o_i - \\hat{o}_i$ 捕获。\n\n为从训练集中估计 $a$ 和 $b$，我们援引经过充分检验的最小化残差平方和原理，采用普通最小二乘法。设训练集由 $m$ 个样本组成，索引为 $i \\in \\{1,\\dots,m\\}$。定义设计矩阵\n$$\nX = \n\\begin{bmatrix}\ns_1  1 \\\\\ns_2  1 \\\\\n\\vdots  \\vdots \\\\\ns_m  1\n\\end{bmatrix},\n$$\n参数矢量\n$$\n\\theta = \n\\begin{bmatrix}\na \\\\ b\n\\end{bmatrix},\n$$\n以及响应矢量\n$$\ny = \n\\begin{bmatrix}\no_1 \\\\ o_2 \\\\ \\vdots \\\\ o_m\n\\end{bmatrix}.\n$$\n残差矢量为 $r = y - X \\theta$。普通最小二乘估计 $\\hat{\\theta}$ 最小化目标函数\n$$\nJ(\\theta) = \\| y - X \\theta \\|_2^2 = \\sum_{i=1}^{m} \\left(o_i - a s_i - b\\right)^2.\n$$\n一个经过充分检验的解由正规方程组给出\n$$\nX^\\top X \\hat{\\theta} = X^\\top y,\n$$\n其解为\n$$\n\\hat{\\theta} = (X^\\top X)^{-1} X^\\top y,\n$$\n前提是 $X^\\top X$ 可逆。在数值上，为确保稳定性，我们使用最小二乘求解器计算 $\\hat{\\theta}$，即使 $X^\\top X$ 是病态的，该求解器也能找到在欧几里得范数意义下最小化 $J(\\theta)$ 的 $\\hat{\\theta}$。\n\n一旦得到 $\\hat{\\theta} = (\\hat{a}, \\hat{b})^\\top$，对任何具有模拟产量 $s$ 的测试样本的预测值计算为 $\\hat{o} = \\hat{a} s + \\hat{b}$。一个测试样本的误差为\n$$\ne = \\hat{o} - o.\n$$\n为评估在包含 $n$ 个样本的合并测试集上的性能，我们从第一性原理计算以下指标：\n- 均方根误差，\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} e_i^2},\n$$\n其单位为 t/ha，因为它是根据单位为 t/ha 的平方差导出，然后取平方根。\n- 平均绝对误差，\n$$\n\\mathrm{MAE} = \\frac{1}{n}\\sum_{i=1}^{n} |e_i|,\n$$\n其单位同样为 t/ha。\n- 偏差，\n$$\n\\mathrm{Bias} = \\frac{1}{n}\\sum_{i=1}^{n} e_i,\n$$\n单位为 t/ha。\n- Nash–Sutcliffe 效率，\n$$\n\\mathrm{NSE} = 1 - \\frac{\\sum_{i=1}^{n} e_i^2}{\\sum_{i=1}^{n} (o_i - \\bar{o})^2},\n$$\n其中 $\\bar{o} = \\frac{1}{n}\\sum_{i=1}^{n} o_i$。此指标是无量纲的，因为它是相同单位的平方量之和的比率。\n\n对于交叉验证，我们使用确定性的划分规则以确保跨年份和站点的可复现性。设样本按站点标识符（升序）排序，然后按年份（升序）排序。为每个样本分配一个折数索引\n$$\nf_i = i \\bmod k,\n$$\n其中 $i$ 是排序顺序中从 0 开始的索引，$k$ 是折数。对于每个折 $j \\in \\{0,1,\\dots,k-1\\}$，定义训练集 $\\mathcal{T}_j = \\{ i \\mid f_i \\neq j \\}$ 和测试集 $\\mathcal{S}_j = \\{ i \\mid f_i = j \\}$。在 $\\mathcal{T}_j$ 上，通过普通最小二乘法拟合 $\\hat{a}_j$ 和 $\\hat{b}_j$。然后，在 $\\mathcal{S}_j$ 上生成预测值，公式为 $\\hat{o}_i = \\hat{a}_j s_i + \\hat{b}_j$。将所有折的测试集预测合并收集到一个集合 $\\{(\\hat{o}_i, o_i)\\}_{i=1}^{n}$ 中用于指标计算，其中 $n$ 是数据集中的总样本数。\n\n每个测试用例的算法设计：\n1. 加载数据集并按站点和年份对样本进行排序，以建立确定性索引 $i$。\n2. 对指定的 $k$ 计算折数索引 $f_i = i \\bmod k$。\n3. 对于每个折 $j$，从 $\\mathcal{T}_j$ 构建训练矩阵 $X$ 和矢量 $y$，通过最小二乘法求解 $\\hat{\\theta}_j$，并在 $\\mathcal{S}_j$ 上计算测试预测值。\n4. 拼接所有测试预测值，以获得合并测试集的数组 $(\\hat{o}_i)$ 和 $(o_i)$。\n5. 使用其上述基本定义计算所要求的指标。\n6. 将结果格式化为小数点后恰好六位。\n\n对于该测试套件：\n- 用例 1 使用数据集 A，$k=3$，以及 $\\mathrm{NSE}$。Nash–Sutcliffe 效率评估了经偏差校正的预测相对于观测产量平均值，在多大程度上再现了观测产量的变异性。\n- 用例 2 使用数据集 A，$k=4$，以及单位为 t/ha 的 $\\mathrm{RMSE}$。此项评估偏差校正后预测误差的典型大小。\n- 用例 3 使用数据集 B，$k=5$，以及单位为 t/ha 的 $\\mathrm{Bias}$。由于观测产量在各年份间保持不变，偏差量化了预测值与观测值之间以 t/ha 为单位的平均有符号偏差，并且在 $o_i$ 的方差为零的情况下是稳健的。\n\n最后，程序以 `[v1,v2,v3]` 的格式单行输出用例 1、用例 2、用例 3 的三个指标值，其中 $v1$、$v2$ 和 $v3$ 是四舍五入到小数点后六位的小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assign_folds(sorted_samples, k):\n    \"\"\"\n    Assign fold indices deterministically using i % k, where i is the index\n    after sorting by (site, year).\n    \"\"\"\n    folds = []\n    for i, _ in enumerate(sorted_samples):\n        folds.append(i % k)\n    return np.array(folds, dtype=int)\n\ndef fit_linear_least_squares(s_train, o_train):\n    \"\"\"\n    Fit a linear model o_hat = a*s + b using ordinary least squares.\n    Returns (a, b).\n    \"\"\"\n    # Design matrix with columns [s, 1]\n    X = np.column_stack([s_train, np.ones_like(s_train)])\n    # Solve least squares: minimize ||X*[a,b] - o||\n    theta, _, _, _ = np.linalg.lstsq(X, o_train, rcond=None)\n    a, b = theta[0], theta[1]\n    return a, b\n\ndef predict_linear(a, b, s):\n    \"\"\"\n    Predict observed yield from simulated yield using o_hat = a*s + b.\n    \"\"\"\n    return a * s + b\n\ndef metric_rmse(o_hat, o_true):\n    \"\"\"\n    Root Mean Squared Error (t/ha).\n    \"\"\"\n    e = o_hat - o_true\n    return float(np.sqrt(np.mean(e**2)))\n\ndef metric_bias(o_hat, o_true):\n    \"\"\"\n    Bias (t/ha).\n    \"\"\"\n    e = o_hat - o_true\n    return float(np.mean(e))\n\ndef metric_nse(o_hat, o_true):\n    \"\"\"\n    Nash–Sutcliffe efficiency (dimensionless).\n    \"\"\"\n    e = o_hat - o_true\n    denom = np.sum((o_true - np.mean(o_true))**2)\n    num = np.sum(e**2)\n    # If denom is zero (no variability), NSE is undefined; set to 1 - num/0 - -inf.\n    # For robustness, we return -inf in that case.\n    if denom == 0.0:\n        return float(\"-inf\")\n    return float(1.0 - num / denom)\n\ndef cross_validate(samples, k, metric_name):\n    \"\"\"\n    Perform deterministic k-fold cross-validation on given samples.\n    samples: list of tuples (site, year, s, o)\n    k: number of folds\n    metric_name: one of 'NSE', 'RMSE', 'Bias'\n    Returns computed metric on pooled test predictions.\n    \"\"\"\n    # Sort samples by (site, year)\n    sorted_samples = sorted(samples, key=lambda x: (x[0], x[1]))\n    folds = assign_folds(sorted_samples, k)\n    # Collect pooled predictions and observations\n    o_hat_pooled = []\n    o_true_pooled = []\n\n    for j in range(k):\n        # Indices for training and test\n        test_idx = np.where(folds == j)[0]\n        train_idx = np.where(folds != j)[0]\n\n        # Extract training data\n        s_train = np.array([sorted_samples[idx][2] for idx in train_idx], dtype=float)\n        o_train = np.array([sorted_samples[idx][3] for idx in train_idx], dtype=float)\n\n        # Fit linear model\n        a, b = fit_linear_least_squares(s_train, o_train)\n\n        # Predict on test data\n        s_test = np.array([sorted_samples[idx][2] for idx in test_idx], dtype=float)\n        o_test = np.array([sorted_samples[idx][3] for idx in test_idx], dtype=float)\n\n        o_hat = predict_linear(a, b, s_test)\n\n        o_hat_pooled.append(o_hat)\n        o_true_pooled.append(o_test)\n\n    # Concatenate pooled arrays\n    o_hat_pooled = np.concatenate(o_hat_pooled) if len(o_hat_pooled)  0 else np.array([], dtype=float)\n    o_true_pooled = np.concatenate(o_true_pooled) if len(o_true_pooled)  0 else np.array([], dtype=float)\n\n    # Compute requested metric\n    if metric_name == 'NSE':\n        return metric_nse(o_hat_pooled, o_true_pooled)\n    elif metric_name == 'RMSE':\n        return metric_rmse(o_hat_pooled, o_true_pooled)\n    elif metric_name == 'Bias':\n        return metric_bias(o_hat_pooled, o_true_pooled)\n    else:\n        raise ValueError(\"Unsupported metric_name\")\n\ndef solve():\n    # Define Dataset A (multi-site, multi-year): (site, year, s, o) with yields in t/ha.\n    dataset_a = [\n        (0, 2015, 4.9, 5.2), (0, 2016, 5.7, 5.6), (0, 2017, 6.0, 6.1), (0, 2018, 5.5, 5.8),\n        (1, 2015, 6.5, 7.1), (1, 2016, 7.0, 6.8), (1, 2017, 7.3, 7.4), (1, 2018, 7.2, 7.0),\n        (2, 2015, 3.5, 3.8), (2, 2016, 4.0, 4.2), (2, 2017, 4.7, 4.5), (2, 2018, 3.9, 4.0),\n    ]\n\n    # Define Dataset B (single-site, multi-year): (site, year, s, o) with yields in t/ha.\n    dataset_b = [\n        (3, 2015, 3.5, 4.0), (3, 2016, 4.2, 4.0), (3, 2017, 3.8, 4.0), (3, 2018, 4.5, 4.0), (3, 2019, 4.0, 4.0),\n    ]\n\n    # Test cases: (dataset, k, metric_name)\n    test_cases = [\n        (dataset_a, 3, 'NSE'),   # Case 1\n        (dataset_a, 4, 'RMSE'),  # Case 2\n        (dataset_b, 5, 'Bias'),  # Case 3\n    ]\n\n    results = []\n    for dataset, k, metric_name in test_cases:\n        value = cross_validate(dataset, k, metric_name)\n        # Format to six decimal places; handle infinities explicitly\n        if np.isneginf(value):\n            formatted = \"-inf\"\n        elif np.isposinf(value):\n            formatted = \"inf\"\n        elif np.isnan(value):\n            formatted = \"nan\"\n        else:\n            formatted = f\"{value:.6f}\"\n        results.append(formatted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}