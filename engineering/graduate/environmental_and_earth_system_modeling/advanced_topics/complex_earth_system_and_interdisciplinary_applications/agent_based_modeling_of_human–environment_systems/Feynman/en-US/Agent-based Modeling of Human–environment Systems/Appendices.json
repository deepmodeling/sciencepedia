{
    "hands_on_practices": [
        {
            "introduction": "Modeling the physical environment is a foundational step in building any human-environment system model. This exercise focuses on implementing mass conservation and rule-based resource allocation within a network, common components of hydrological and infrastructural models. By building a model of an irrigation network, you will gain hands-on experience in representing spatially explicit resource flows and understanding how local agent actions, such as controlling gate openings, propagate to cause non-local, system-wide effects .",
            "id": "3860567",
            "problem": "Consider a directed acyclic graph representing an irrigation network with nodes $\\mathcal{N}$ and edges $\\mathcal{E}$. Each edge $(i \\rightarrow j) \\in \\mathcal{E}$ represents a canal from upstream node $i$ to downstream node $j$. Agents control gate openings on edges, influencing effective throughput. You must implement a program that computes the allocation of water flows under agent-controlled gate settings subject to physical and social constraints, and reports quantitative outcomes for specified test cases.\n\nFundamental base and constraints:\n- Mass conservation (continuity): For each node $i \\in \\mathcal{N}$, let $S_i$ be exogenous inflow (source term), $I_i$ the sum of inflows arriving from upstream edges, $D_i$ the local environmental demand, and $L_i \\in [0,1)$ a dimensionless loss fraction representing outflow reduction due to infiltration and evaporation. The water available at node $i$ is $A_i = S_i + I_i$. The demand satisfied at node $i$ is $E_i = \\min(D_i, A_i)$, and the remaining allocable water before losses is $R_i = A_i - E_i$. The budget available for downstream allocation (after applying losses) is $B_i = (1 - L_i) R_i$.\n- Capacity and control: Each edge $e \\in \\mathcal{E}$ has a nominal capacity $C_e$ in $m^3/s$. An agent-controlled gate opening fraction $g_e \\in [0,1]$ modifies the effective capacity to $C^{\\text{eff}}_e = g_e C_e$. Flows must satisfy $0 \\leq F_e \\leq C^{\\text{eff}}_e$ for every edge $e$.\n- Fairness weights: Each edge $e$ originating at node $i$ has a nonnegative priority weight $w_e \\geq 0$ that governs proportional allocation among outgoing edges from node $i$. When $B_i$ is less than the sum of effective capacities of outgoing edges from $i$, flows from $i$ should be allocated proportionally to $\\{w_e\\}$ while respecting the capacity bounds; when $B_i$ exceeds the sum of effective capacities, edges are saturated at their effective capacities and any residual $B_i$ is not transported downstream (it is locally spilled and does not contribute to downstream demand satisfaction).\n- Topological computation: Because the graph is acyclic, the allocation can be performed in a topological order starting from sources and proceeding downstream, ensuring that $I_i$ is known when computing $A_i$, $E_i$, $R_i$, $B_i$, and the outgoing edge allocations.\n\nAllocation requirement at a node:\n- For each node $i$, let $\\mathcal{E}^+_i$ denote the set of outgoing edges with effective capacities $\\{C^{\\text{eff}}_e\\}$ and weights $\\{w_e\\}$. Allocate $B_i$ across $\\mathcal{E}^+_i$ such that:\n    1. $\\sum_{e \\in \\mathcal{E}^+_i} F_e = \\min\\left(B_i, \\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e\\right)$,\n    2. $0 \\leq F_e \\leq C^{\\text{eff}}_e$ for all $e \\in \\mathcal{E}^+_i$,\n    3. If $\\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e \\ge B_i$, then among unsaturated edges the ratio $F_e$ is proportional to $w_e$.\n\nYour program must implement a capacity-respecting weighted proportional allocation scheme at each node consistent with the above, using only the provided numerical inputs and the base principles. After computing flows and satisfied demands for all nodes, output the total unmet demand, defined as $\\sum_{i \\in \\mathcal{N}} (D_i - E_i)$, in $m^3/s$ for each test case.\n\nGraph and parameterization:\n- Nodes: $\\mathcal{N} = \\{0, 1, 2, 3\\}$.\n- Edges $\\mathcal{E}$ with nominal capacities $C_e$ in $m^3/s$, agent-controlled gate openings $g_e$ (unitless), and priority weights $w_e$ (unitless) are:\n    - Edge $e_0$: $0 \\rightarrow 1$, $C_{e_0} = 5$, $w_{e_0} = 1.0$.\n    - Edge $e_1$: $0 \\rightarrow 2$, $C_{e_1} = 6$, $w_{e_1} = 2.0$.\n    - Edge $e_2$: $1 \\rightarrow 3$, $C_{e_2} = 4$, $w_{e_2} = 1.0$.\n    - Edge $e_3$: $2 \\rightarrow 3$, $C_{e_3} = 3$, $w_{e_3} = 1.0$.\n- Loss fractions: $L_0 = 0.1$, $L_1 = 0.05$, $L_2 = 0.05$, $L_3 = 0$.\n- The graph is acyclic with topological order consistent with upstream-to-downstream traversal $0 \\rightarrow \\{1,2\\} \\rightarrow 3$.\n\nTest suite:\n- Case $1$ (happy path): exogenous inflows $S_0 = 10$, $S_1 = 0$, $S_2 = 0$, $S_3 = 0$; demands $D_0 = 2$, $D_1 = 3$, $D_2 = 1$, $D_3 = 4$; gate openings $g_{e_0} = 0.8$, $g_{e_1} = 0.5$, $g_{e_2} = 1.0$, $g_{e_3} = 1.0$.\n- Case $2$ (boundary with closed gate): exogenous inflows $S_0 = 10$, $S_1 = 0$, $S_2 = 0$, $S_3 = 0$; demands $D_0 = 2$, $D_1 = 3$, $D_2 = 1$, $D_3 = 4$; gate openings $g_{e_0} = 0.8$, $g_{e_1} = 0.0$, $g_{e_2} = 1.0$, $g_{e_3} = 1.0$.\n- Case $3$ (edge case with limited supply): exogenous inflows $S_0 = 3$, $S_1 = 0$, $S_2 = 0$, $S_3 = 0$; demands $D_0 = 1.5$, $D_1 = 2$, $D_2 = 1$, $D_3 = 4$; gate openings $g_{e_0} = 0.8$, $g_{e_1} = 0.5$, $g_{e_2} = 1.0$, $g_{e_3} = 1.0$.\n\nAngle units are not applicable. All reported quantities must be in $m^3/s$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$), where each entry is the total unmet demand for the corresponding case, expressed as a float in $m^3/s$.",
            "solution": "The problem requires the computation of water allocation and resulting unmet demand in a simulated irrigation network. The network is modeled as a directed acyclic graph (DAG), which permits a sequential, node-by-node calculation following a specified topological order. The solution is derived by applying principles of mass conservation and a capacity-constrained weighted proportional allocation rule at each node.\n\n### Fundamental Principles and Algorithm\n\nThe calculation proceeds by processing each node in the specified topological order: $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$. For each node $i$, a water budget is calculated and then distributed according to physical and social constraints.\n\n**1. Mass Conservation at each Node:**\nFor any given node $i \\in \\mathcal{N}$, the water balance is calculated as follows:\n- **Total Inflow ($I_i$):** The sum of flows from all incoming edges. For a source node like node $0$, $I_0 = 0$. For other nodes, $I_i = \\sum_{j \\to i} F_{j \\to i}$, where $F_{j \\to i}$ is the flow on the edge from node $j$ to node $i$.\n- **Available Water ($A_i$):** The sum of exogenous inflow $S_i$ and total inflow $I_i$: $A_i = S_i + I_i$.\n- **Satisfied Demand ($E_i$):** The local environmental demand $D_i$ is met as much as possible by the available water: $E_i = \\min(D_i, A_i)$. The unmet demand at this node is $D_i - E_i$.\n- **Remaining Allocable Water ($R_i$):** The water left after satisfying local demand: $R_i = A_i - E_i$.\n- **Downstream Budget ($B_i$):** This is the water available for allocation to downstream nodes after accounting for local losses (e.g., infiltration, evaporation), given by the loss fraction $L_i$: $B_i = (1 - L_i) R_i$.\n\n**2. Downstream Flow Allocation:**\nThe budget $B_i$ is allocated among the set of outgoing edges from node $i$, denoted $\\mathcal{E}^+_i$. Each edge $e \\in \\mathcal{E}^+_i$ has an effective capacity $C^{\\text{eff}}_e = g_e C_e$, where $g_e$ is an agent-controlled gate opening, and a priority weight $w_e$. The total flow leaving node $i$ is constrained by the total effective capacity of its outgoing edges, $\\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e$.\nThe total allocated flow from node $i$ is $\\sum_{e \\in \\mathcal{E}^+_i} F_e = \\min\\left(B_i, \\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e\\right)$.\nThe allocation of this total flow among individual edges follows a capacity-respecting weighted proportional scheme:\n\n- **Oversupply Case:** If the budget $B_i$ is greater than or equal to the total outgoing effective capacity ($\\sum C^{\\text{eff}}_e$), each outgoing edge $e$ is saturated to its effective capacity: $F_e = C^{\\text{eff}}_e$. Any remaining budget ($B_i - \\sum C^{\\text{eff}}_e$) is considered spilled and is not transported downstream.\n- **Undersupply Case:** If the budget $B_i$ is less than the total outgoing effective capacity, the flow is distributed proportionally to the weights $\\{w_e\\}$, subject to the capacity constraints $\\{C^{\\text{eff}}_e\\}$. This is handled with an iterative algorithm:\n    1. Initialize the set of active edges to all outgoing edges from node $i$.\n    2. In a loop, with the remaining budget and active edges:\n        a. Calculate a provisional flow for each active edge, proportional to its weight.\n        b. If any provisional flow exceeds its edge's effective capacity, that edge is deemed a \"saturating candidate\".\n        c. If there are saturating candidates, fix their flows to their effective capacities, subtract these flows from the budget, remove them from the set of active edges, and repeat the process with the reduced budget and remaining edges.\n        d. If no edge's provisional flow exceeds its capacity, allocate the remaining budget proportionally among the remaining active edges, and the process for this node is complete.\n\n**3. Total Unmet Demand:**\nAfter processing all nodes in topological order and determining all flows and satisfied demands, the primary output is the total unmet demand across the entire network, calculated as $\\sum_{i \\in \\mathcal{N}} (D_i - E_i)$.\n\n### Worked Example: Case 1\n\n**Parameters:**\n- Exogenous Inflows: $S = \\{10, 0, 0, 0\\}$ $m^3/s$\n- Demands: $D = \\{2, 3, 1, 4\\}$ $m^3/s$\n- Gate Openings: $g = \\{g_{e_0}=0.8, g_{e_1}=0.5, g_{e_2}=1.0, g_{e_3}=1.0\\}$\n- Nominal Capacities: $C = \\{C_{e_0}=5, C_{e_1}=6, C_{e_2}=4, C_{e_3}=3\\}$ $m^3/s$\n- Weights: $w = \\{w_{e_0}=1.0, w_{e_1}=2.0, w_{e_2}=1.0, w_{e_3}=1.0\\}$\n- Loss Fractions: $L = \\{0.1, 0.05, 0.05, 0\\}$\n\n**Step 0: Pre-computation**\n- Effective Capacities:\n  - $C^{\\text{eff}}_{e_0} = 0.8 \\times 5 = 4.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_1} = 0.5 \\times 6 = 3.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_2} = 1.0 \\times 4 = 4.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_3} = 1.0 \\times 3 = 3.0$ $m^3/s$\n\n**Step 1: Process Node $0$**\n- $I_0 = 0$. $A_0 = S_0 + I_0 = 10 + 0 = 10$.\n- $E_0 = \\min(D_0, A_0) = \\min(2, 10) = 2$. Unmet demand at node $0$ is $0$.\n- $R_0 = A_0 - E_0 = 10 - 2 = 8$.\n- $B_0 = (1 - L_0) R_0 = (1 - 0.1) \\times 8 = 7.2$.\n- Allocate $B_0=7.2$ to edges $e_0$ ($0 \\to 1$) and $e_1$ ($0 \\to 2$).\n- Total outgoing capacity from node $0$ is $C^{\\text{eff}}_{e_0} + C^{\\text{eff}}_{e_1} = 4.0 + 3.0 = 7.0$.\n- Since $B_0=7.2 > 7.0$ (oversupply), edges are saturated.\n- $F_{e_0} = 4.0$. $F_{e_1} = 3.0$. A volume of $7.2 - 7.0 = 0.2$ $m^3/s$ is spilled.\n\n**Step 2: Process Node $1$**\n- $I_1 = F_{e_0} = 4.0$. $A_1 = S_1 + I_1 = 0 + 4.0 = 4.0$.\n- $E_1 = \\min(D_1, A_1) = \\min(3, 4.0) = 3$. Unmet demand at node $1$ is $0$.\n- $R_1 = A_1 - E_1 = 4.0 - 3 = 1.0$.\n- $B_1 = (1 - L_1) R_1 = (1 - 0.05) \\times 1.0 = 0.95$.\n- Allocate $B_1=0.95$ to edge $e_2$ ($1 \\to 3$).\n- $F_{e_2} = \\min(B_1, C^{\\text{eff}}_{e_2}) = \\min(0.95, 4.0) = 0.95$.\n\n**Step 3: Process Node $2$**\n- $I_2 = F_{e_1} = 3.0$. $A_2 = S_2 + I_2 = 0 + 3.0 = 3.0$.\n- $E_2 = \\min(D_2, A_2) = \\min(1, 3.0) = 1$. Unmet demand at node $2$ is $0$.\n- $R_2 = A_2 - E_2 = 3.0 - 1 = 2.0$.\n- $B_2 = (1 - L_2) R_2 = (1 - 0.05) \\times 2.0 = 1.9$.\n- Allocate $B_2=1.9$ to edge $e_3$ ($2 \\to 3$).\n- $F_{e_3} = \\min(B_2, C^{\\text{eff}}_{e_3}) = \\min(1.9, 3.0) = 1.9$.\n\n**Step 4: Process Node $3$**\n- $I_3 = F_{e_2} + F_{e_3} = 0.95 + 1.9 = 2.85$.\n- $A_3 = S_3 + I_3 = 0 + 2.85 = 2.85$.\n- $E_3 = \\min(D_3, A_3) = \\min(4, 2.85) = 2.85$. Unmet demand at node $3$ is $4 - 2.85 = 1.15$.\n- Node $3$ is a sink node with no outgoing edges.\n\n**Step 5: Final Calculation**\n- Total Unmet Demand = $\\sum (D_i - E_i) = 0 (\\text{node } 0) + 0 (\\text{node } 1) + 0 (\\text{node } 2) + 1.15 (\\text{node } 3) = 1.15$ $m^3/s$.\nThis same procedure is applied to all test cases to obtain their respective results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef allocate_flow(budget, capacities, weights):\n    \"\"\"\n    Allocates a budget of water flow across outgoing edges based on a\n    capacity-constrained weighted proportional rule.\n\n    Args:\n        budget (float): The total available water budget to allocate.\n        capacities (dict): A dictionary mapping edge index to its effective capacity.\n        weights (dict): A dictionary mapping edge index to its priority weight.\n\n    Returns:\n        dict: A dictionary mapping edge index to its allocated flow.\n    \"\"\"\n    flows = {edge: 0.0 for edge in capacities}\n    \n    total_capacity = sum(capacities.values())\n    if budget >= total_capacity:\n        return capacities.copy()\n\n    if budget = 1e-9:\n        return flows\n\n    # Iterative allocation for the undersupply case\n    b_rem = budget\n    active_edges = list(capacities.keys())\n    temp_caps = capacities.copy()\n\n    while active_edges and b_rem > 1e-9:\n        total_weight_active = sum(weights[e] for e in active_edges)\n        if total_weight_active = 1e-9:\n            break\n\n        prop_flows_active = {e: b_rem * weights[e] / total_weight_active for e in active_edges}\n        \n        overshot_edges = [e for e in active_edges if prop_flows_active[e] > temp_caps.get(e, 0)]\n\n        if not overshot_edges:\n            # Final allocation for remaining edges\n            for e in active_edges:\n                flows[e] = prop_flows_active[e]\n            break\n        else:\n            # Set saturated edges to capacity, reduce budget, and loop\n            for e in overshot_edges:\n                flows[e] = temp_caps[e]\n                b_rem -= temp_caps[e]\n            \n            active_edges = [e for e in active_edges if e not in overshot_edges]\n    \n    return flows\n\n\ndef solve():\n    # --- Static problem definition ---\n    # Graph structure\n    nodes = [0, 1, 2, 3]\n    edges = [(0, 1), (0, 2), (1, 3), (2, 3)] # edge_idx: 0, 1, 2, 3\n\n    # Adjacency lists for graph traversal\n    out_edges = {i: [] for i in nodes}\n    in_edges = {i: [] for i in nodes}\n    for i, (u, v) in enumerate(edges):\n        out_edges[u].append(i)\n        in_edges[v].append(i)\n        \n    topological_order = [0, 1, 2, 3]\n\n    # Parameters\n    C_nominal = np.array([5.0, 6.0, 4.0, 3.0])\n    weights = np.array([1.0, 2.0, 1.0, 1.0])\n    L = np.array([0.1, 0.05, 0.05, 0.0])\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"S\": np.array([10.0, 0.0, 0.0, 0.0]),\n            \"D\": np.array([2.0, 3.0, 1.0, 4.0]),\n            \"g\": np.array([0.8, 0.5, 1.0, 1.0])\n        },\n        {\n            \"S\": np.array([10.0, 0.0, 0.0, 0.0]),\n            \"D\": np.array([2.0, 3.0, 1.0, 4.0]),\n            \"g\": np.array([0.8, 0.0, 1.0, 1.0])\n        },\n        {\n            \"S\": np.array([3.0, 0.0, 0.0, 0.0]),\n            \"D\": np.array([1.5, 2.0, 1.0, 4.0]),\n            \"g\": np.array([0.8, 0.5, 1.0, 1.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        S = case[\"S\"]\n        D = case[\"D\"]\n        g = case[\"g\"]\n        \n        C_eff = C_nominal * g\n        \n        # State variables\n        F = np.zeros(len(edges))\n        E = np.zeros(len(nodes))\n        \n        # Simulation loop\n        for i in topological_order:\n            # 1. Calculate water available at node i\n            inflow_I = sum(F[edge_idx] for edge_idx in in_edges[i])\n            available_A = S[i] + inflow_I\n            \n            # 2. Satisfy local demand\n            satisfied_E = min(D[i], available_A)\n            E[i] = satisfied_E\n            \n            # 3. Calculate remaining water and budget for downstream\n            remaining_R = available_A - satisfied_E\n            budget_B = (1 - L[i]) * remaining_R\n            \n            # 4. Allocate budget to outgoing edges\n            if out_edges[i]:\n                # Prepare inputs for allocation function\n                node_out_edges = out_edges[i]\n                sub_capacities = {e: C_eff[e] for e in node_out_edges}\n                sub_weights = {e: weights[e] for e in node_out_edges}\n                \n                # Call the robust allocation function\n                allocated_flows = allocate_flow(budget_B, sub_capacities, sub_weights)\n\n                # Update global flow array\n                for edge_idx, flow_val in allocated_flows.items():\n                    F[edge_idx] = flow_val\n        \n        # Calculate total unmet demand for the case\n        total_unmet_demand = np.sum(D - E)\n        results.append(total_unmet_demand)\n        \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A core strength of agent-based modeling is its ability to explore how heterogeneity among individual agents leads to emergent patterns at the population level. This problem applies mean-variance utility theory, a classic framework for decision-making under uncertainty, to a population of farmers with varying levels of risk aversion. By analytically deriving the steady-state fraction of farmers choosing a particular crop, you will connect micro-level agent attributes—in this case, risk aversion $\\lambda$—to macro-scale outcomes, providing a powerful technique for model analysis and validation without relying on direct simulation .",
            "id": "3860659",
            "problem": "You are to construct and analyze a minimal Agent-Based Model (ABM) of agricultural decision-making in a human–environment system in purely mathematical terms. The environment is characterized by a fixed stochastic rainfall distribution, and each agent (farmer) chooses one of two crops at the beginning of a season based on expected profit and its variability. Your task is to compute the steady-state fraction of farmers who grow crop $A$ under the specified distributions, parameter values, and decision rules. All quantities are dimensionless. The final outputs must be expressed as decimal fractions rounded to six decimal places.\n\nModel setup:\n- There are $N$ agents (farmers), each with a risk aversion parameter $\\lambda$ drawn independently from a specified distribution over a bounded interval. Agents choose the crop that maximizes their mean–variance expected utility in each season, defined as $U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$ for crop $i \\in \\{A,B\\}$, where $\\Pi_i$ denotes profit.\n- Rainfall $R$ is a random variable with a fixed Lognormal distribution parameterized by $(\\mu_R, \\sigma_R)$, so that $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$ and all moments $\\mathbb{E}[R^k]$ exist for $k \\geq 0$.\n- Crop $i$ has yield function $Y_i(R) = a_i R - b_i R^2$, unit output price $P_i$, and fixed cost $c_i$. Profit equals $\\Pi_i = P_i Y_i(R) - c_i$.\n- Each agent adopts the crop that maximizes $U_i(\\lambda)$ given the fixed rainfall distribution and the fixed crop parameters. Because the distributions are constant over time, agent choices do not change across seasons once expectations reflect the fixed environment, and the macro-level state converges to a steady-state fraction of agents growing crop $A$.\n\nFoundational base to be used:\n- Mean–variance decision theory: $U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$.\n- Definitions of moments and variance: for a random variable $X$, $\\operatorname{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$, covariance $\\operatorname{Cov}(X,Y) = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y]$.\n- Lognormal moments: if $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$, then $\\mathbb{E}[R^k] = \\exp\\!\\left(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2\\right)$, for $k \\in \\{1,2,3,4\\}$.\n- Law of large numbers: the steady-state fraction equals the probability measure of the set of agents who choose crop $A$ under the specified $\\lambda$ distribution.\n\nYour task:\n- Derive an algorithm to compute the steady-state fraction $f_A$ of farmers choosing crop $A$ given $(\\mu_R, \\sigma_R)$, $(a_A, b_A, P_A, c_A)$, $(a_B, b_B, P_B, c_B)$, and a specified distribution for $\\lambda$. You should assume either a Uniform distribution on $[\\lambda_{\\min}, \\lambda_{\\max}]$ or a scaled Beta distribution on $[0, \\lambda_{\\max}]$ with shape parameters $(\\alpha, \\beta)$. The steady-state fraction must be computed without simulation by using the analytical moments of the Lognormal distribution and the mean–variance utility rule.\n\n- Specifically, compute $\\mathbb{E}[Y_i]$ and $\\operatorname{Var}(Y_i)$ from $(\\mu_R, \\sigma_R, a_i, b_i)$ using moments up to $k=4$, then obtain $\\mathbb{E}[\\Pi_i]$ and $\\operatorname{Var}(\\Pi_i)$ for $i\\in\\{A,B\\}$. Define $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$ and $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$, and use the decision inequality $U_A(\\lambda)  U_B(\\lambda)$ to determine the threshold on $\\lambda$ that separates agents choosing $A$ from those choosing $B$.\n\n- Handle boundary conditions rigorously:\n    - If $\\Delta V  0$, then agents choose crop $A$ when $\\lambda  \\Delta E / \\Delta V$.\n    - If $\\Delta V  0$, then agents choose crop $A$ when $\\lambda  \\Delta E / \\Delta V$.\n    - If $\\Delta V = 0$, then choices are independent of $\\lambda$; if $\\Delta E  0$ then $f_A = 1$, if $\\Delta E  0$ then $f_A = 0$, and if $\\Delta E = 0$ then $f_A = 1/2$.\n\n- For Uniform $\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$, evaluate the fraction by measuring the appropriate interval length. For scaled Beta on $[0, \\lambda_{\\max}]$, evaluate using the Beta cumulative distribution function on the normalized threshold $z = (\\Delta E / \\Delta V) / \\lambda_{\\max}$, with the direction of the inequality determined by the sign of $\\Delta V$.\n\nTest suite:\nCompute $f_A$ for the following four parameter sets. Each test case is independent and should yield a single float (the fraction of farmers choosing crop $A$), rounded to six decimal places, not expressed as a percentage.\n\n- Test case $1$ (happy path, Uniform):\n    - Rainfall parameters: $\\mu_R = 0.5$, $\\sigma_R = 0.3$.\n    - Crop $A$: $a_A = 2.0$, $b_A = 0.15$, $P_A = 1.0$, $c_A = 0.2$.\n    - Crop $B$: $a_B = 1.6$, $b_B = 0.05$, $P_B = 1.1$, $c_B = 0.25$.\n    - $\\lambda$ distribution: Uniform with $\\lambda_{\\min} = 0.0$, $\\lambda_{\\max} = 2.0$.\n\n- Test case $2$ (boundary, equal variance, Uniform):\n    - Rainfall parameters: $\\mu_R = 0.3$, $\\sigma_R = 0.2$.\n    - Crop $A$: $a_A = 1.5$, $b_A = 0.08$, $P_A = 1.0$, $c_A = 0.1$.\n    - Crop $B$: $a_B = 1.5$, $b_B = 0.08$, $P_B = 1.0$, $c_B = 0.3$.\n    - $\\lambda$ distribution: Uniform with $\\lambda_{\\min} = 0.0$, $\\lambda_{\\max} = 3.0$.\n\n- Test case $3$ (edge case, negative threshold, Uniform):\n    - Rainfall parameters: $\\mu_R = 0.4$, $\\sigma_R = 0.6$.\n    - Crop $A$: $a_A = 1.8$, $b_A = 0.1$, $P_A = 2.0$, $c_A = 5.0$.\n    - Crop $B$: $a_B = 1.8$, $b_B = 0.1$, $P_B = 0.5$, $c_B = 0.0$.\n    - $\\lambda$ distribution: Uniform with $\\lambda_{\\min} = 0.0$, $\\lambda_{\\max} = 10.0$.\n\n- Test case $4$ (inequality flips, Beta on $[0,1]$):\n    - Rainfall parameters: $\\mu_R = 0.7$, $\\sigma_R = 0.4$.\n    - Crop $A$: $a_A = 1.5$, $b_A = 0.07$, $P_A = 0.8$, $c_A = 0.05$.\n    - Crop $B$: $a_B = 1.5$, $b_B = 0.07$, $P_B = 2.0$, $c_B = 0.2$.\n    - $\\lambda$ distribution: scaled Beta on $[0, \\lambda_{\\max}]$ with $\\lambda_{\\max} = 1.0$, shape parameters $\\alpha = 2.0$, $\\beta = 5.0$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$. Each number must be rounded to six decimal places. For example, $[0.742857,0.500000,0.000000,0.123456]$.",
            "solution": "The user-provided problem has been analyzed according to the specified validation protocol.\n\n### Step 1: Extract Givens\n- **Task**: Compute the steady-state fraction ($f_A$) of farmers choosing crop $A$.\n- **Agents**: $N$ farmers with risk aversion parameter $\\lambda$.\n- **Utility Function**: $U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$ for crop $i \\in \\{A, B\\}$.\n- **Decision Rule**: Choose the crop that maximizes $U_i(\\lambda)$.\n- **Environment**: Rainfall $R$ is a random variable following a Lognormal distribution, $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$.\n- **Lognormal Moments**: $\\mathbb{E}[R^k] = \\exp(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2)$ for $k \\in \\{1, 2, 3, 4\\}$.\n- **Yield Function**: $Y_i(R) = a_i R - b_i R^2$.\n- **Profit Function**: $\\Pi_i = P_i Y_i(R) - c_i$.\n- **$\\lambda$ Distributions**:\n    1. Uniform: $\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$.\n    2. Scaled Beta: on $[0, \\lambda_{\\max}]$ with shape parameters $(\\alpha, \\beta)$.\n- **Decision Logic**: The choice depends on the sign of $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$ and the threshold $\\lambda_c = \\Delta E / \\Delta V$, where $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$.\n    - If $\\Delta V  0$, choose $A$ if $\\lambda  \\lambda_c$.\n    - If $\\Delta V  0$, choose $A$ if $\\lambda  \\lambda_c$.\n    - If $\\Delta V = 0$, the choice depends only on the sign of $\\Delta E$.\n- **Test Cases**: Four specific parameter sets are provided for calculation.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on standard economic theory (mean-variance analysis), statistical theory (properties of Lognormal, Uniform, and Beta distributions), and core concepts of agent-based modeling. The yield function is a common simplification. This is valid.\n- **Well-Posed**: The problem is well-defined, providing all necessary parameters, equations, and decision rules to compute a unique solution for each test case. This is valid.\n- **Objective**: The problem is stated in precise, mathematical terms, free from ambiguity or subjective content. This is valid.\n- **Completeness and Consistency**: The problem is self-contained and its components are logically consistent. The rules for all cases (e.g., $\\Delta V  0$, $\\Delta V  0$, $\\Delta V = 0$) are fully specified. This is valid.\n- **Realism**: While an abstraction, the model captures a fundamental tradeoff between expected return and risk, which is a realistic aspect of agricultural decision-making. This is valid.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a rigorous and well-posed exercise in applied mathematics and modeling. I will proceed with providing a complete solution.\n\n### Analytical Solution Derivation\nThe objective is to find the steady-state fraction of agents, $f_A$, who choose crop $A$. This fraction is equivalent to the probability that a randomly selected agent's risk aversion parameter, $\\lambda$, falls within the range that favors crop $A$. The derivation proceeds in four steps.\n\n**1. Moments of Rainfall ($R$)**\nGiven that rainfall $R$ follows a lognormal distribution such that $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$, the $k$-th raw moment of $R$ is given by:\n$$M_k = \\mathbb{E}[R^k] = \\exp\\left(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2\\right)$$\nWe will require the first four moments ($M_1, M_2, M_3, M_4$) to calculate the mean and variance of the quadratic profit function.\n\n**2. Expected Profit and Variance of Profit ($\\mathbb{E}[\\Pi_i]$ and $\\operatorname{Var}(\\Pi_i)$)**\nThe profit for crop $i$ is a function of rainfall $R$: $\\Pi_i(R) = P_i(a_i R - b_i R^2) - c_i$.\n\nThe expected profit, $\\mathbb{E}[\\Pi_i]$, is found using the linearity of expectation:\n$$ \\mathbb{E}[\\Pi_i] = \\mathbb{E}[P_i(a_i R - b_i R^2) - c_i] = P_i a_i \\mathbb{E}[R] - P_i b_i \\mathbb{E}[R^2] - c_i $$\nIn terms of the moments of $R$:\n$$ \\mathbb{E}[\\Pi_i] = P_i a_i M_1 - P_i b_i M_2 - c_i $$\n\nThe variance of profit, $\\operatorname{Var}(\\Pi_i)$, is calculated as:\n$$ \\operatorname{Var}(\\Pi_i) = \\operatorname{Var}(P_i(a_i R - b_i R^2) - c_i) = P_i^2 \\operatorname{Var}(a_i R - b_i R^2) = P_i^2 \\operatorname{Var}(Y_i) $$\nwhere $Y_i = a_i R - b_i R^2$ is the yield. The variance of the yield, $\\operatorname{Var}(Y_i)$, is given by:\n$$ \\operatorname{Var}(Y_i) = \\operatorname{Var}(a_i R - b_i R^2) = a_i^2 \\operatorname{Var}(R) + b_i^2 \\operatorname{Var}(R^2) - 2 a_i b_i \\operatorname{Cov}(R, R^2) $$\nThe required variance and covariance terms can be expressed using the moments of $R$:\n- $\\operatorname{Var}(R) = \\mathbb{E}[R^2] - (\\mathbb{E}[R])^2 = M_2 - M_1^2$\n- $\\operatorname{Var}(R^2) = \\mathbb{E}[(R^2)^2] - (\\mathbb{E}[R^2])^2 = M_4 - M_2^2$\n- $\\operatorname{Cov}(R, R^2) = \\mathbb{E}[R \\cdot R^2] - \\mathbb{E}[R]\\mathbb{E}[R^2] = M_3 - M_1 M_2$\nSubstituting these into the expression for $\\operatorname{Var}(Y_i)$:\n$$ \\operatorname{Var}(Y_i) = a_i^2 (M_2 - M_1^2) + b_i^2 (M_4 - M_2^2) - 2 a_i b_i (M_3 - M_1 M_2) $$\nThis allows for the complete calculation of $\\mathbb{E}[\\Pi_i]$ and $\\operatorname{Var}(\\Pi_i)$ for both crops $A$ and $B$.\n\n**3. Decision Threshold**\nAn agent chooses crop $A$ if its utility is higher than that of crop $B$: $U_A(\\lambda)  U_B(\\lambda)$.\n$$ \\mathbb{E}[\\Pi_A] - \\lambda \\operatorname{Var}(\\Pi_A)  \\mathbb{E}[\\Pi_B] - \\lambda \\operatorname{Var}(\\Pi_B) $$\nRearranging the terms gives:\n$$ \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]  \\lambda (\\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)) $$\nLet $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$ and $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$. The inequality becomes $\\Delta E  \\lambda \\Delta V$. Let the critical threshold be $\\lambda_c = \\Delta E / \\Delta V$. The preferred crop depends on the agent's $\\lambda$ relative to $\\lambda_c$, with the direction of the inequality depending on the sign of $\\Delta V$:\n- Case 1: $\\Delta V  0$. The inequality is $\\lambda  \\lambda_c$. Less risk-averse agents (small $\\lambda$) prefer Crop A.\n- Case 2: $\\Delta V  0$. The inequality becomes $\\lambda  \\lambda_c$. More risk-averse agents (large $\\lambda$) prefer Crop A.\n- Case 3: $\\Delta V = 0$. The choice is independent of $\\lambda$. If $\\Delta E  0$, all agents choose $A$ ($f_A=1$). If $\\Delta E  0$, all agents choose $B$ ($f_A=0$). If $\\Delta E = 0$, agents are indifferent, and by convention $f_A = 1/2$.\n\n**4. Calculation of Fraction $f_A$**\nThe fraction $f_A$ is the measure of the set of $\\lambda$ values that satisfy the preference condition, according to the specified probability distribution for $\\lambda$.\n\n- **For $\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$**:\nThe fraction $f_A$ is the length of the preference interval for A that intersects with $[\\lambda_{\\min}, \\lambda_{\\max}]$, divided by the total range length $(\\lambda_{\\max} - \\lambda_{\\min})$.\n  - If $\\Delta V  0$: $f_A = P(\\lambda  \\lambda_c) = \\frac{\\max(0, \\min(\\lambda_c, \\lambda_{\\max}) - \\lambda_{\\min})}{\\lambda_{\\max} - \\lambda_{\\min}}$.\n  - If $\\Delta V  0$: $f_A = P(\\lambda  \\lambda_c) = \\frac{\\max(0, \\lambda_{\\max} - \\max(\\lambda_c, \\lambda_{\\min}))}{\\lambda_{\\max} - \\lambda_{\\min}}$.\n\n- **For scaled Beta $\\lambda$ on $[0, \\lambda_{\\max}]$ with shapes $(\\alpha, \\beta)$**:\nThe CDF of $\\lambda$ is $F_{\\lambda}(v) = I_{v/\\lambda_{\\max}}(\\alpha, \\beta)$, where $I_z(\\alpha, \\beta)$ is the regularized incomplete beta function. The support for $\\lambda$ is $[0, \\lambda_{\\max}]$. Let the normalized threshold be $z_c = \\lambda_c / \\lambda_{\\max}$.\n  - If $\\Delta V  0$: $f_A = P(\\lambda  \\lambda_c) = F_{\\lambda}(\\lambda_c)$. This is calculated as $I_{\\text{clip}(z_c, 0, 1)}(\\alpha, \\beta)$, where $\\text{clip}$ confines $z_c$ to the interval $[0, 1]$.\n  - If $\\Delta V  0$: $f_A = P(\\lambda  \\lambda_c) = 1 - F_{\\lambda}(\\lambda_c)$. This is calculated as $1 - I_{\\text{clip}(z_c, 0, 1)}(\\alpha, \\beta)$.\n\nThese derived formulas provide a complete algorithm for computing $f_A$ for any given set of valid parameters.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import betainc\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, Uniform)\n        {\n            \"rain\": (0.5, 0.3),\n            \"crop_a\": (2.0, 0.15, 1.0, 0.2),\n            \"crop_b\": (1.6, 0.05, 1.1, 0.25),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 2.0)},\n        },\n        # Test case 2 (boundary, equal variance, Uniform)\n        {\n            \"rain\": (0.3, 0.2),\n            \"crop_a\": (1.5, 0.08, 1.0, 0.1),\n            \"crop_b\": (1.5, 0.08, 1.0, 0.3),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 3.0)},\n        },\n        # Test case 3 (edge case, negative threshold, Uniform)\n        {\n            \"rain\": (0.4, 0.6),\n            \"crop_a\": (1.8, 0.1, 2.0, 5.0),\n            \"crop_b\": (1.8, 0.1, 0.5, 0.0),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 10.0)},\n        },\n        # Test case 4 (inequality flips, Beta on [0,1])\n        {\n            \"rain\": (0.7, 0.4),\n            \"crop_a\": (1.5, 0.07, 0.8, 0.05),\n            \"crop_b\": (1.5, 0.07, 2.0, 0.2),\n            \"dist\": {\"type\": \"beta\", \"params\": (1.0, 2.0, 5.0)},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        f_a = compute_f_a(case)\n        results.append(f\"{f_a:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\ndef get_profit_stats(crop_params, moments):\n    \"\"\"\n    Calculates the expected profit and variance of profit for a single crop.\n    \n    Args:\n        crop_params (tuple): (a, b, P, c) for the crop.\n        moments (tuple): First four moments of the rainfall distribution (m1, m2, m3, m4).\n        \n    Returns:\n        tuple: (E_Pi, Var_Pi), the expected profit and variance of profit.\n    \"\"\"\n    a, b, P, c = crop_params\n    m1, m2, m3, m4 = moments\n\n    # Expected yield\n    E_Y = a * m1 - b * m2\n    \n    # Expected profit\n    E_Pi = P * E_Y - c\n\n    # Variance of yield\n    var_R = m2 - m1**2\n    var_R2 = m4 - m2**2\n    cov_R_R2 = m3 - m1 * m2\n    \n    var_Y = a**2 * var_R + b**2 * var_R2 - 2 * a * b * cov_R_R2\n    \n    # Variance of profit\n    var_Pi = P**2 * var_Y\n    \n    return E_Pi, var_Pi\n\ndef compute_f_a(case_params):\n    \"\"\"\n    Computes the steady-state fraction of farmers choosing crop A.\n    \n    Args:\n        case_params (dict): A dictionary containing all parameters for a test case.\n        \n    Returns:\n        float: The fraction of farmers choosing crop A.\n    \"\"\"\n    dist_type = case_params['dist']['type']\n    dist_params = case_params['dist']['params']\n    mu_r, sigma_r = case_params['rain']\n    crop_a_params = case_params['crop_a']\n    crop_b_params = case_params['crop_b']\n\n    # 1. Calculate moments of rainfall R\n    m1 = np.exp(mu_r + 0.5 * sigma_r**2)\n    m2 = np.exp(2 * mu_r + 2 * sigma_r**2)\n    m3 = np.exp(3 * mu_r + 4.5 * sigma_r**2)\n    m4 = np.exp(4 * mu_r + 8 * sigma_r**2)\n    moments = (m1, m2, m3, m4)\n\n    # 2. Compute profit statistics for each crop\n    E_Pi_A, Var_Pi_A = get_profit_stats(crop_a_params, moments)\n    E_Pi_B, Var_Pi_B = get_profit_stats(crop_b_params, moments)\n\n    # 3. Calculate differences in expectation (delta_E) and variance (delta_V)\n    delta_E = E_Pi_A - E_Pi_B\n    delta_V = Var_Pi_A - Var_Pi_B\n\n    # 4. Handle the case of zero variance difference\n    if np.isclose(delta_V, 0):\n        if delta_E  0:\n            return 1.0\n        elif delta_E  0:\n            return 0.0\n        else: # delta_E is also zero, agents are indifferent\n            return 0.5\n\n    # 5. Compute the critical risk aversion threshold\n    lambda_c = delta_E / delta_V\n\n    # 6. Calculate the fraction f_A based on the distribution of lambda\n    if dist_type == 'uniform':\n        lambda_min, lambda_max = dist_params\n        range_len = lambda_max - lambda_min\n        if range_len = 0: return 0.0 if delta_E  0 else 1.0\n        \n        # Clip the threshold to the support of lambda\n        lambda_c_clipped = np.clip(lambda_c, lambda_min, lambda_max)\n        \n        if delta_V  0: # Choose A if lambda  lambda_c\n            effective_length = lambda_c_clipped - lambda_min\n            return effective_length / range_len\n        else: # delta_V  0, choose A if lambda  lambda_c\n            effective_length = lambda_max - lambda_c_clipped\n            return effective_length / range_len\n\n    elif dist_type == 'beta':\n        lambda_max, alpha, beta = dist_params\n        lambda_min = 0.0 # Scaled Beta is on [0, lambda_max]\n        \n        if lambda_max = 0: return 0.0 if delta_E  0 else 1.0\n        \n        # Normalize threshold to the standard Beta domain [0, 1]\n        z_c = lambda_c / lambda_max\n        z_c_clipped = np.clip(z_c, 0, 1)\n\n        cdf_at_threshold = betainc(alpha, beta, z_c_clipped)\n\n        if delta_V  0: # Choose A if lambda  lambda_c\n            return cdf_at_threshold\n        else: # delta_V  0, choose A if lambda  lambda_c\n            return 1.0 - cdf_at_threshold\n            \n    return 0.0 # Should not be reached\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "The most insightful human-environment models capture the co-evolution of agents and their surroundings through learning and adaptation. This practice explores a fully coupled system where agents use reinforcement learning to make choices that impact a shared resource, and the state of that resource, in turn, influences their future rewards and decisions. Deriving and solving the self-consistent equation for the system's steady state provides deep insight into the feedback loops that govern complex adaptive systems and allows you to model how emergent norms of behavior, such as the level of exploitation, arise from individual learning in a shared environment .",
            "id": "3860641",
            "problem": "Consider a population of identical agents embedded in a single-resource environment. Each agent faces a binary choice at each discrete time step: conservation ($C$) versus exploitation ($E$). The environment is represented by a normalized resource stock $s_t \\in [0,1]$ that evolves according to a discrete-time mean-field logistic replenishment with linear depletion caused by exploitation:\n$$\ns_{t+1} = s_t + \\rho (1 - s_t) - \\xi \\, \\pi_E \\, s_t,\n$$\nwhere $\\rho  0$ is the intrinsic replenishment rate, $\\xi \\ge 0$ is the exploitation impact coefficient, and $\\pi_E \\in [0,1]$ is the steady-state probability of choosing exploitation in the population (the mean-field approximation assumes each agent is negligibly small relative to the population).\n\nEach agent receives instantaneous rewards that depend on the current stock $s_t$:\n$$\nr_C(s_t) = g \\, s_t, \\qquad r_E(s_t) = f \\, s_t - c,\n$$\nwhere $f  0$ and $g \\ge 0$ are action-specific benefit coefficients and $c \\ge 0$ is an externalized exploitation cost measured in utility units.\n\nAgents learn action values using the on-policy Expected State–Action–Reward–State–Action (Expected-SARSA) update with softmax action selection. Let $Q_C$ and $Q_E$ denote the action-value estimates. The policy is the softmax with temperature $\\tau  0$:\n$$\n\\pi_a = \\frac{\\exp(Q_a / \\tau)}{\\exp(Q_C / \\tau) + \\exp(Q_E / \\tau)}, \\quad a \\in \\{C,E\\},\n$$\nand the Expected-SARSA fixed-point consistency for a single stationary state yields\n$$\nQ_a = r_a + \\gamma \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b,\n$$\nwhere $\\gamma \\in [0,1)$ is the discount factor. At steady state, the resource stock $s^*$ and the exploitation probability $\\pi_E$ must be jointly self-consistent with the above definitions.\n\nStarting only from the foregoing core definitions and laws, derive a self-consistent scalar fixed-point equation for the steady-state exploitation probability $\\pi_E$ under the softmax policy with temperature $\\tau$, expressed in terms of the parameters $(\\tau,\\rho,\\xi,f,g,c,\\gamma)$. Implement an algorithm to compute the unique steady-state solution $\\pi_E \\in [0,1]$ for each parameter set and produce the final exploitation probability as a floating-point number. There is no need to compute $Q_C$, $Q_E$, or $s^*$ explicitly in the output, but your derivation must justify the final algorithmic form.\n\nAll quantities are dimensionless except the reward, which is measured in utility units; report the final exploitation probability as a unitless decimal. Angles are not involved. \n\nYour program must solve the following test suite, which is designed to exercise typical behavior, low and high temperature limits, and environmental edge cases. For each case, compute the steady-state exploitation probability $\\pi_E$ and round to six decimal places:\n\n- Case A (moderate temperature, baseline environment): $\\tau = 0.25$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$.\n- Case B (near-deterministic policy): $\\tau = 10^{-3}$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$.\n- Case C (high-temperature, near-random policy): $\\tau = 100.0$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$.\n- Case D (no exploitation impact on the resource): $\\tau = 0.5$, $\\rho = 0.6$, $\\xi = 0.0$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$.\n- Case E (high exploitation cost favoring conservation): $\\tau = 0.25$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.8$, $\\gamma = 0.9$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, [$x_1,x_2,x_3,x_4,x_5$]), with each $x_i$ equal to the steady-state exploitation probability for the corresponding case, rounded to six decimal places.",
            "solution": "We begin from the agent-based learning and environmental dynamics definitions. There is a single stationary environmental state characterized by the resource stock $s_t \\in [0,1]$, with mean-field evolution\n$$\ns_{t+1} = s_t + \\rho (1 - s_t) - \\xi \\, \\pi_E \\, s_t,\n$$\nwhere $\\rho  0$ is the replenishment rate, $\\xi \\ge 0$ is the exploitation impact on the stock, and $\\pi_E$ is the steady exploitation probability. At steady state, set $s_{t+1} = s_t = s^*$ and solve for $s^*$:\n$$\n0 = \\rho (1 - s^*) - \\xi \\, \\pi_E \\, s^*, \\quad \\Rightarrow \\quad s^* = \\frac{\\rho}{\\rho + \\xi \\pi_E}.\n$$\n\nAgents receive instantaneous rewards depending on $s_t$:\n$$\nr_C(s) = g s, \\qquad r_E(s) = f s - c,\n$$\nwith $f  0$ and $g \\ge 0$ action-specific benefits, and $c \\ge 0$ the exploitation cost in utility units.\n\nAgents employ Expected State–Action–Reward–State–Action (Expected-SARSA) learning, with action values $Q_C,Q_E$ and a softmax policy at temperature $\\tau$:\n$$\n\\pi_a = \\frac{\\exp(Q_a/\\tau)}{\\exp(Q_C/\\tau) + \\exp(Q_E/\\tau)}, \\quad a \\in \\{C,E\\},\n$$\nand the Expected-SARSA fixed-point consistency for the single stationary state yields:\n$$\nQ_a = r_a + \\gamma \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b, \\quad \\gamma \\in [0,1).\n$$\n\nDefine the soft value\n$$\nV = \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b.\n$$\nSubstitute the Expected-SARSA form to express $V$:\n$$\nV = \\sum_b \\pi_b \\left(r_b + \\gamma V\\right) = \\sum_b \\pi_b r_b + \\gamma V.\n$$\nSolve for $V$:\n$$\nV = \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}.\n$$\nThen each action value is\n$$\nQ_a = r_a + \\gamma V = r_a + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}.\n$$\n\nConsider the difference of action values, which enters the softmax:\n$$\n\\Delta \\equiv Q_E - Q_C = \\left(r_E + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}\\right) - \\left(r_C + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}\\right) = r_E - r_C.\n$$\nTherefore, the learning dynamics with Expected-SARSA and softmax yield a stationary policy difference solely determined by the instantaneous reward difference. This cancellation is intuitive in a single stationary state because expected future returns contribute equally to both action values via $\\gamma V$.\n\nUsing the softmax form for two actions, the exploitation probability is the logistic function of $Q_E - Q_C$:\n$$\n\\pi_E = \\frac{1}{1 + \\exp\\left(-\\frac{Q_E - Q_C}{\\tau}\\right)} = \\frac{1}{1 + \\exp\\left(-\\frac{r_E - r_C}{\\tau}\\right)}.\n$$\nSubstitute $r_E(s^*) = f s^* - c$ and $r_C(s^*) = g s^*$:\n$$\nr_E - r_C = (f - g) s^* - c.\n$$\nUsing the steady-state stock $s^* = \\frac{\\rho}{\\rho + \\xi \\pi_E}$, we obtain the scalar fixed-point equation in $\\pi_E$:\n$$\n\\pi_E = \\frac{1}{1 + \\exp\\left(-\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi_E} - c}{\\tau}\\right)}.\n$$\n\nThis equation is well-defined on the interval $\\pi_E \\in [0,1]$ for $\\rho  0$, $\\xi \\ge 0$, $f  0$, $g \\ge 0$, $c \\ge 0$, and $\\tau  0$. The right-hand side is continuous and strictly bounded in $(0,1)$. Define the function\n$$\nh(\\pi) = \\frac{1}{1 + \\exp\\left(-\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi} - c}{\\tau}\\right)}.\n$$\nWe seek $\\pi^*$ such that $h(\\pi^*) = \\pi^*$. Consider $g(\\pi) = h(\\pi) - \\pi$. Then $g(0) = h(0) - 0  0$, since $h(0) \\in (0,1)$. Also $g(1) = h(1) - 1  0$, since $h(1) \\in (0,1)$. By the Intermediate Value Theorem, there exists at least one root in $[0,1]$. Monotonicity of $h(\\pi)$ under the stated parameter ranges implies uniqueness, because increasing $\\pi$ weakens the stock $s^*$ and often reduces $(f - g) s^* - c$, making $h(\\pi)$ nonincreasing for $(f - g) \\rho  0$ and $\\xi \\ge 0$. Thus a unique fixed point exists and can be found by a robust bracketing root finder on $g(\\pi)$ over $[0,1]$.\n\nAlgorithmic steps to compute $\\pi_E$ for a given parameter set:\n1. Define the logistic function $\\sigma(x) = \\frac{1}{1 + e^{-x}}$.\n2. For given $(\\tau,\\rho,\\xi,f,g,c)$, define $h(\\pi) = \\sigma\\left(\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi} - c}{\\tau}\\right)$ and $g(\\pi) = h(\\pi) - \\pi$.\n3. Use a bracketing root finder on $g(\\pi)$ over $[0,1]$ to obtain the unique fixed point $\\pi^*$.\n4. Round $\\pi^*$ to six decimal places.\n5. Repeat for each test case.\n\nNote that the discount factor $\\gamma$ cancels out of the exploitation probability due to the single stationary state and Expected-SARSA structure; the softmax depends only on $Q_E - Q_C = r_E - r_C$. Nevertheless, $\\gamma$ remains part of the foundational derivation.\n\nApply this to the test suite specified in the problem. For each case, the program computes the steady-state exploitation probability $\\pi_E$ by solving the fixed-point equation and returns the rounded values as a single comma-separated list in brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef steady_state_exploitation_probability(tau, rho, xi, f, g, c, gamma):\n    \"\"\"\n    Compute steady-state exploitation probability pi_E under a softmax policy\n    with temperature tau, in a mean-field single-state environment with\n    logistic replenishment and linear depletion from exploitation.\n\n    Although gamma is part of the RL setup, pi_E depends only on reward\n    differences in the single stationary state and thus is independent of gamma.\n    \"\"\"\n    # Logistic function\n    def logistic(x):\n        # Use stable computation\n        # For large negative x, exp(-x) may overflow; handle with np.where\n        return 1.0 / (1.0 + np.exp(-x))\n\n    # Define the fixed-point function g(pi) = h(pi) - pi\n    def g_fun(pi):\n        # Steady-state stock s* = rho / (rho + xi * pi)\n        denom = rho + xi * pi\n        # Avoid division by zero; denom = rho  0 under given parameters\n        s_star = rho / denom\n        # Reward difference delta = (f - g) * s* - c\n        delta = (f - g) * s_star - c\n        # Softmax exploitation probability under two actions: logistic(delta / tau)\n        h_pi = logistic(delta / tau)\n        return h_pi - pi\n\n    # Root finding on interval [0,1]; g(0)  0 and g(1)  0 typically\n    # To ensure robustness, clip extreme tau values are still handled by brentq.\n    pi_star = brentq(g_fun, 0.0, 1.0, maxiter=1000, rtol=1e-12)\n    return pi_star\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (tau, rho, xi, f, g, c, gamma)\n    test_cases = [\n        (0.25, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),   # Case A\n        (1e-3, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),   # Case B\n        (100.0, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),  # Case C\n        (0.5, 0.6, 0.0, 1.0, 0.4, 0.2, 0.9),    # Case D\n        (0.25, 0.6, 0.8, 1.0, 0.4, 0.8, 0.9),   # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, rho, xi, f, g, c, gamma = case\n        pi_e = steady_state_exploitation_probability(tau, rho, xi, f, g, c, gamma)\n        results.append(f\"{pi_e:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}