{
    "hands_on_practices": [
        {
            "introduction": "构建智能体模型的第一步通常是定义智能体的决策规则。本练习将指导您建立一个基于经典经济学理论的模型，其中智能体（农户）在面临环境不确定性（降雨量）时，根据预期收益和风险来做出理性选择。通过这个练习 ，您将掌握如何从微观的智能体异质性（风险规避程度不同）和环境因素，推导出宏观层面的系统性结果，这是理解复杂人地系统的关键一步。",
            "id": "3860659",
            "problem": "您需要以纯数学术语构建和分析一个关于人类—环境系统中农业决策的最小化代理人基模型（Agent-Based Model, ABM）。该环境的特征是固定的随机降雨分布，每个代理人（农户）在每个季节开始时，根据预期利润及其变异性选择两种作物之一。您的任务是计算在指定的分布、参数值和决策规则下，种植作物 $A$ 的农户所占的稳态比例。所有量均为无量纲。最终输出必须表示为四舍五入到六位小数的小数分数。\n\n模型设置：\n- 共有 $N$ 个代理人（农户），每个代理人都有一个风险规避参数 $\\lambda$，该参数从一个有界区间上的指定分布中独立抽取。代理人在每个季节选择能使其均值—方差期望效用最大化的作物，该效用对作物 $i \\in \\{A,B\\}$ 定义为 $U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$，其中 $\\Pi_i$ 表示利润。\n- 降雨量 $R$ 是一个随机变量，服从由 $(\\mu_R, \\sigma_R)$ 参数化的固定对数正态分布，因此 $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$ 且对于 $k \\geq 0$，所有矩 $\\mathbb{E}[R^k]$ 都存在。\n- 作物 $i$ 的产量函数为 $Y_i(R) = a_i R - b_i R^2$，单位产出价格为 $P_i$，固定成本为 $c_i$。利润等于 $\\Pi_i = P_i Y_i(R) - c_i$。\n- 每个代理人在给定的固定降雨分布和固定作物参数下，采纳能使 $U_i(\\lambda)$ 最大化的作物。由于分布随时间恒定，一旦期望反映了固定的环境，代理人的选择在不同季节间不会改变，宏观层面的状态会收敛到一个种植作物 $A$ 的代理人所占的稳态比例。\n\n使用的基础理论：\n- 均值—方差决策理论：$U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$。\n- 矩和方差的定义：对于一个随机变量 $X$，$\\operatorname{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$，协方差 $\\operatorname{Cov}(X,Y) = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y]$。\n- 对数正态分布的矩：如果 $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$，则 $\\mathbb{E}[R^k] = \\exp\\!\\left(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2\\right)$，对于 $k \\in \\{1,2,3,4\\}$。\n- 大数定律：稳态比例等于在指定的 $\\lambda$ 分布下，选择作物 $A$ 的代理人集合的概率测度。\n\n您的任务：\n- 推导一个算法，用以在给定 $(\\mu_R, \\sigma_R)$、$(a_A, b_A, P_A, c_A)$、$(a_B, b_B, P_B, c_B)$ 以及一个指定的 $\\lambda$ 分布的情况下，计算种植作物 $A$ 的农户所占的稳态比例 $f_A$。您应假设 $\\lambda$ 服从 $[\\lambda_{\\min}, \\lambda_{\\max}]$ 上的均匀分布，或 $[0, \\lambda_{\\max}]$ 上形状参数为 $(\\alpha, \\beta)$ 的缩放贝塔分布。必须通过使用对数正态分布的解析矩和均值—方差效用规则来计算稳态比例，而非通过模拟。\n\n- 具体来说，根据 $(\\mu_R, \\sigma_R, a_i, b_i)$ 使用最高至 $k=4$ 的矩计算 $\\mathbb{E}[Y_i]$ 和 $\\operatorname{Var}(Y_i)$，然后对于 $i\\in\\{A,B\\}$ 获得 $\\mathbb{E}[\\Pi_i]$ 和 $\\operatorname{Var}(\\Pi_i)$。定义 $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$ 和 $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$，并使用决策不等式 $U_A(\\lambda) > U_B(\\lambda)$ 来确定将选择作物 $A$ 的代理人与选择作物 $B$ 的代理人分开的 $\\lambda$ 阈值。\n\n- 严格处理边界条件：\n    - 如果 $\\Delta V > 0$，则当 $\\lambda  \\Delta E / \\Delta V$ 时，代理人选择作物 $A$。\n    - 如果 $\\Delta V  0$，则当 $\\lambda > \\Delta E / \\Delta V$ 时，代理人选择作物 $A$。\n    - 如果 $\\Delta V = 0$，则选择与 $\\lambda$ 无关；如果 $\\Delta E > 0$，则 $f_A = 1$；如果 $\\Delta E  0$，则 $f_A = 0$；如果 $\\Delta E = 0$，则 $f_A = 1/2$。\n\n- 对于均匀分布 $\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$，通过测量适当的区间长度来评估该比例。对于 $[0, \\lambda_{\\max}]$ 上的缩放贝塔分布，使用贝塔累积分布函数在归一化阈值 $z = (\\Delta E / \\Delta V) / \\lambda_{\\max}$ 上进行评估，不等式的方向由 $\\Delta V$ 的符号决定。\n\n测试套件：\n为以下四个参数集计算 $f_A$。每个测试用例都是独立的，应产生一个浮点数（选择作物 $A$ 的农户比例），四舍五入到六位小数，不以百分比形式表示。\n\n- 测试用例 1（理想情况，均匀分布）：\n    - 降雨参数：$\\mu_R = 0.5$，$\\sigma_R = 0.3$。\n    - 作物 $A$：$a_A = 2.0$， $b_A = 0.15$， $P_A = 1.0$， $c_A = 0.2$。\n    - 作物 $B$：$a_B = 1.6$， $b_B = 0.05$， $P_B = 1.1$， $c_B = 0.25$。\n    - $\\lambda$ 分布：均匀分布，$\\lambda_{\\min} = 0.0$，$\\lambda_{\\max} = 2.0$。\n\n- 测试用例 2（边界情况，方差相等，均匀分布）：\n    - 降雨参数：$\\mu_R = 0.3$，$\\sigma_R = 0.2$。\n    - 作物 $A$：$a_A = 1.5$， $b_A = 0.08$， $P_A = 1.0$， $c_A = 0.1$。\n    - 作物 $B$：$a_B = 1.5$， $b_B = 0.08$， $P_B = 1.0$， $c_B = 0.3$。\n    - $\\lambda$ 分布：均匀分布，$\\lambda_{\\min} = 0.0$，$\\lambda_{\\max} = 3.0$。\n\n- 测试用例 3（边缘情况，负阈值，均匀分布）：\n    - 降雨参数：$\\mu_R = 0.4$，$\\sigma_R = 0.6$。\n    - 作物 $A$：$a_A = 1.8$， $b_A = 0.1$， $P_A = 2.0$， $c_A = 5.0$。\n    - 作物 $B$：$a_B = 1.8$， $b_B = 0.1$， $P_B = 0.5$， $c_B = 0.0$。\n    - $\\lambda$ 分布：均匀分布，$\\lambda_{\\min} = 0.0$，$\\lambda_{\\max} = 10.0$。\n\n- 测试用例 4（不等式反转，$[0,1]$ 上的贝塔分布）：\n    - 降雨参数：$\\mu_R = 0.7$，$\\sigma_R = 0.4$。\n    - 作物 $A$：$a_A = 1.5$， $b_A = 0.07$， $P_A = 0.8$， $c_A = 0.05$。\n    - 作物 $B$：$a_B = 1.5$， $b_B = 0.07$， $P_B = 2.0$， $c_B = 0.2$。\n    - $\\lambda$ 分布：$[0, \\lambda_{\\max}]$ 上的缩放贝塔分布，其中 $\\lambda_{\\max} = 1.0$，形状参数 $\\alpha = 2.0$，$\\beta = 5.0$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，按测试用例 1 到 4 的顺序排列。每个数字必须四舍五入到六位小数。例如，$[0.742857,0.500000,0.000000,0.123456]$。",
            "solution": "用户提供的问题已根据指定的验证协议进行了分析。\n\n### 步骤 1：提取已知条件\n- **任务**：计算选择作物 $A$ 的农户的稳态比例 ($f_A$)。\n- **代理人**：$N$ 个农户，其风险规避参数为 $\\lambda$。\n- **效用函数**：对于作物 $i \\in \\{A, B\\}$，为 $U_i(\\lambda) = \\mathbb{E}[\\Pi_i] - \\lambda \\operatorname{Var}(\\Pi_i)$。\n- **决策规则**：选择使 $U_i(\\lambda)$ 最大化的作物。\n- **环境**：降雨量 $R$ 是一个随机变量，服从对数正态分布，$\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$。\n- **对数正态分布的矩**：对于 $k \\in \\{1, 2, 3, 4\\}$，$\\mathbb{E}[R^k] = \\exp(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2)$。\n- **产量函数**：$Y_i(R) = a_i R - b_i R^2$。\n- **利润函数**：$\\Pi_i = P_i Y_i(R) - c_i$。\n- **$\\lambda$ 的分布**：\n    1. 均匀分布：$\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$。\n    2. 缩放贝塔分布：在 $[0, \\lambda_{\\max}]$ 上，形状参数为 $(\\alpha, \\beta)$。\n- **决策逻辑**：选择取决于 $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$ 的符号以及阈值 $\\lambda_c = \\Delta E / \\Delta V$，其中 $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$。\n    - 如果 $\\Delta V > 0$，当 $\\lambda  \\lambda_c$ 时选择 $A$。\n    - 如果 $\\Delta V  0$，当 $\\lambda > \\lambda_c$ 时选择 $A$。\n    - 如果 $\\Delta V = 0$，选择仅取决于 $\\Delta E$ 的符号。\n- **测试用例**：提供了四个特定的参数集用于计算。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于标准的经济学理论（均值-方差分析）、统计理论（对数正态、均匀和贝塔分布的性质）以及代理人基建模的核心概念。产量函数是一种常见的简化方法。这是有效的。\n- **适定性**：该问题定义明确，提供了所有必要的参数、方程和决策规则，以便为每个测试用例计算出唯一的解。这是有效的。\n- **客观性**：该问题以精确的数学术语陈述，没有歧义或主观内容。这是有效的。\n- **完整性与一致性**：该问题是自洽的，其各组成部分在逻辑上是一致的。所有情况（例如 $\\Delta V > 0$、$\\Delta V  0$、$\\Delta V = 0$）的规则都已完全指定。这是有效的。\n- **现实性**：虽然是一个抽象模型，但该模型捕捉了预期回报与风险之间的基本权衡，这是农业决策的一个现实方面。这是有效的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是一个严谨且适定的应用数学和建模练习。我将继续提供完整的解决方案。\n\n### 解析解推导\n目标是找到选择作物 $A$ 的代理人所占的稳态比例 $f_A$。该比例等同于一个随机选择的代理人的风险规避参数 $\\lambda$ 落入偏好作物 $A$ 的范围内的概率。推导过程分四步进行。\n\n**1. 降雨量 ($R$) 的矩**\n鉴于降雨量 $R$ 服从对数正态分布，使得 $\\ln R \\sim \\mathcal{N}(\\mu_R, \\sigma_R^2)$，其 $k$ 阶原点矩由下式给出：\n$$M_k = \\mathbb{E}[R^k] = \\exp\\left(k\\mu_R + \\frac{1}{2}k^2 \\sigma_R^2\\right)$$\n我们需要前四个矩 ($M_1, M_2, M_3, M_4$) 来计算二次利润函数的均值和方差。\n\n**2. 预期利润和利润方差 ($\\mathbb{E}[\\Pi_i]$ 和 $\\operatorname{Var}(\\Pi_i)$)**\n作物 $i$ 的利润是降雨量 $R$ 的函数：$\\Pi_i(R) = P_i(a_i R - b_i R^2) - c_i$。\n\n预期利润 $\\mathbb{E}[\\Pi_i]$ 通过期望的线性性质求得：\n$$ \\mathbb{E}[\\Pi_i] = \\mathbb{E}[P_i(a_i R - b_i R^2) - c_i] = P_i a_i \\mathbb{E}[R] - P_i b_i \\mathbb{E}[R^2] - c_i $$\n用 $R$ 的矩表示：\n$$ \\mathbb{E}[\\Pi_i] = P_i a_i M_1 - P_i b_i M_2 - c_i $$\n\n利润的方差 $\\operatorname{Var}(\\Pi_i)$ 计算如下：\n$$ \\operatorname{Var}(\\Pi_i) = \\operatorname{Var}(P_i(a_i R - b_i R^2) - c_i) = P_i^2 \\operatorname{Var}(a_i R - b_i R^2) = P_i^2 \\operatorname{Var}(Y_i) $$\n其中 $Y_i = a_i R - b_i R^2$ 是产量。产量的方差 $\\operatorname{Var}(Y_i)$ 由下式给出：\n$$ \\operatorname{Var}(Y_i) = \\operatorname{Var}(a_i R - b_i R^2) = a_i^2 \\operatorname{Var}(R) + b_i^2 \\operatorname{Var}(R^2) - 2 a_i b_i \\operatorname{Cov}(R, R^2) $$\n所需的方差和协方差项可以用 $R$ 的矩表示：\n- $\\operatorname{Var}(R) = \\mathbb{E}[R^2] - (\\mathbb{E}[R])^2 = M_2 - M_1^2$\n- $\\operatorname{Var}(R^2) = \\mathbb{E}[(R^2)^2] - (\\mathbb{E}[R^2])^2 = M_4 - M_2^2$\n- $\\operatorname{Cov}(R, R^2) = \\mathbb{E}[R \\cdot R^2] - \\mathbb{E}[R]\\mathbb{E}[R^2] = M_3 - M_1 M_2$\n将这些代入 $\\operatorname{Var}(Y_i)$ 的表达式中：\n$$ \\operatorname{Var}(Y_i) = a_i^2 (M_2 - M_1^2) + b_i^2 (M_4 - M_2^2) - 2 a_i b_i (M_3 - M_1 M_2) $$\n这使得对作物 $A$ 和 $B$ 的 $\\mathbb{E}[\\Pi_i]$ 和 $\\operatorname{Var}(\\Pi_i)$ 的完整计算成为可能。\n\n**3. 决策阈值**\n如果作物 $A$ 的效用高于作物 $B$，代理人则选择作物 $A$：$U_A(\\lambda) > U_B(\\lambda)$。\n$$ \\mathbb{E}[\\Pi_A] - \\lambda \\operatorname{Var}(\\Pi_A) > \\mathbb{E}[\\Pi_B] - \\lambda \\operatorname{Var}(\\Pi_B) $$\n整理各项得：\n$$ \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B] > \\lambda (\\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)) $$\n令 $\\Delta E = \\mathbb{E}[\\Pi_A] - \\mathbb{E}[\\Pi_B]$ 和 $\\Delta V = \\operatorname{Var}(\\Pi_A) - \\operatorname{Var}(\\Pi_B)$。不等式变为 $\\Delta E > \\lambda \\Delta V$。设临界阈值为 $\\lambda_c = \\Delta E / \\Delta V$。偏好的作物取决于代理人的 $\\lambda$ 相对于 $\\lambda_c$ 的大小，不等式的方向取决于 $\\Delta V$ 的符号：\n- 情况 1：$\\Delta V > 0$。不等式为 $\\lambda  \\lambda_c$。风险规避程度较低的代理人（小的 $\\lambda$）偏好作物 A。\n- 情况 2：$\\Delta V  0$。不等式变为 $\\lambda > \\lambda_c$。风险规避程度较高的代理人（大的 $\\lambda$）偏好作物 A。\n- 情况 3：$\\Delta V = 0$。选择与 $\\lambda$ 无关。如果 $\\Delta E > 0$，所有代理人都选择 $A$ ($f_A=1$)。如果 $\\Delta E  0$，所有代理人都选择 $B$ ($f_A=0$)。如果 $\\Delta E = 0$，代理人无差异，按惯例 $f_A = 1/2$。\n\n**4. 比例 $f_A$ 的计算**\n比例 $f_A$ 是根据指定的 $\\lambda$ 概率分布，满足偏好条件的 $\\lambda$ 值集合的测度。\n\n- **对于 $\\lambda \\sim \\mathcal{U}([\\lambda_{\\min}, \\lambda_{\\max}])$**：\n比例 $f_A$ 是偏好 A 的区间与 $[\\lambda_{\\min}, \\lambda_{\\max}]$ 相交部分的长度，除以总范围长度 $(\\lambda_{\\max} - \\lambda_{\\min})$。\n  - 如果 $\\Delta V > 0$：$f_A = P(\\lambda  \\lambda_c) = \\frac{\\max(0, \\min(\\lambda_c, \\lambda_{\\max}) - \\lambda_{\\min})}{\\lambda_{\\max} - \\lambda_{\\min}}$。\n  - 如果 $\\Delta V  0$：$f_A = P(\\lambda > \\lambda_c) = \\frac{\\max(0, \\lambda_{\\max} - \\max(\\lambda_c, \\lambda_{\\min}))}{\\lambda_{\\max} - \\lambda_{\\min}}$。\n\n- **对于 $[0, \\lambda_{\\max}]$ 上形状参数为 $(\\alpha, \\beta)$ 的缩放贝塔分布 $\\lambda$**：\n$\\lambda$ 的累积分布函数（CDF）是 $F_{\\lambda}(v) = I_{v/\\lambda_{\\max}}(\\alpha, \\beta)$，其中 $I_z(\\alpha, \\beta)$ 是正则化不完全贝塔函数。$\\lambda$ 的支撑集是 $[0, \\lambda_{\\max}]$。设归一化阈值为 $z_c = \\lambda_c / \\lambda_{\\max}$。\n  - 如果 $\\Delta V > 0$：$f_A = P(\\lambda  \\lambda_c) = F_{\\lambda}(\\lambda_c)$。这计算为 $I_{\\text{clip}(z_c, 0, 1)}(\\alpha, \\beta)$，其中 $\\text{clip}$ 将 $z_c$ 限制在区间 $[0, 1]$ 内。\n  - 如果 $\\Delta V  0$：$f_A = P(\\lambda > \\lambda_c) = 1 - F_{\\lambda}(\\lambda_c)$。这计算为 $1 - I_{\\text{clip}(z_c, 0, 1)}(\\alpha, \\beta)$。\n\n这些推导出的公式为计算任何给定有效参数集的 $f_A$ 提供了一个完整的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import betainc\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, Uniform)\n        {\n            \"rain\": (0.5, 0.3),\n            \"crop_a\": (2.0, 0.15, 1.0, 0.2),\n            \"crop_b\": (1.6, 0.05, 1.1, 0.25),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 2.0)},\n        },\n        # Test case 2 (boundary, equal variance, Uniform)\n        {\n            \"rain\": (0.3, 0.2),\n            \"crop_a\": (1.5, 0.08, 1.0, 0.1),\n            \"crop_b\": (1.5, 0.08, 1.0, 0.3),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 3.0)},\n        },\n        # Test case 3 (edge case, negative threshold, Uniform)\n        {\n            \"rain\": (0.4, 0.6),\n            \"crop_a\": (1.8, 0.1, 2.0, 5.0),\n            \"crop_b\": (1.8, 0.1, 0.5, 0.0),\n            \"dist\": {\"type\": \"uniform\", \"params\": (0.0, 10.0)},\n        },\n        # Test case 4 (inequality flips, Beta on [0,1])\n        {\n            \"rain\": (0.7, 0.4),\n            \"crop_a\": (1.5, 0.07, 0.8, 0.05),\n            \"crop_b\": (1.5, 0.07, 2.0, 0.2),\n            \"dist\": {\"type\": \"beta\", \"params\": (1.0, 2.0, 5.0)},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        f_a = compute_f_a(case)\n        results.append(f\"{f_a:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\ndef get_profit_stats(crop_params, moments):\n    \"\"\"\n    Calculates the expected profit and variance of profit for a single crop.\n    \n    Args:\n        crop_params (tuple): (a, b, P, c) for the crop.\n        moments (tuple): First four moments of the rainfall distribution (m1, m2, m3, m4).\n        \n    Returns:\n        tuple: (E_Pi, Var_Pi), the expected profit and variance of profit.\n    \"\"\"\n    a, b, P, c = crop_params\n    m1, m2, m3, m4 = moments\n\n    # Expected yield\n    E_Y = a * m1 - b * m2\n    \n    # Expected profit\n    E_Pi = P * E_Y - c\n\n    # Variance of yield\n    var_R = m2 - m1**2\n    var_R2 = m4 - m2**2\n    cov_R_R2 = m3 - m1 * m2\n    \n    var_Y = a**2 * var_R + b**2 * var_R2 - 2 * a * b * cov_R_R2\n    \n    # Variance of profit\n    var_Pi = P**2 * var_Y\n    \n    return E_Pi, var_Pi\n\ndef compute_f_a(case_params):\n    \"\"\"\n    Computes the steady-state fraction of farmers choosing crop A.\n    \n    Args:\n        case_params (dict): A dictionary containing all parameters for a test case.\n        \n    Returns:\n        float: The fraction of farmers choosing crop A.\n    \"\"\"\n    dist_type = case_params['dist']['type']\n    dist_params = case_params['dist']['params']\n    mu_r, sigma_r = case_params['rain']\n    crop_a_params = case_params['crop_a']\n    crop_b_params = case_params['crop_b']\n\n    # 1. Calculate moments of rainfall R\n    m1 = np.exp(mu_r + 0.5 * sigma_r**2)\n    m2 = np.exp(2 * mu_r + 2 * sigma_r**2)\n    m3 = np.exp(3 * mu_r + 4.5 * sigma_r**2)\n    m4 = np.exp(4 * mu_r + 8 * sigma_r**2)\n    moments = (m1, m2, m3, m4)\n\n    # 2. Compute profit statistics for each crop\n    E_Pi_A, Var_Pi_A = get_profit_stats(crop_a_params, moments)\n    E_Pi_B, Var_Pi_B = get_profit_stats(crop_b_params, moments)\n\n    # 3. Calculate differences in expectation (delta_E) and variance (delta_V)\n    delta_E = E_Pi_A - E_Pi_B\n    delta_V = Var_Pi_A - Var_Pi_B\n\n    # 4. Handle the case of zero variance difference\n    if np.isclose(delta_V, 0):\n        if delta_E > 0:\n            return 1.0\n        elif delta_E  0:\n            return 0.0\n        else: # delta_E is also zero, agents are indifferent\n            return 0.5\n\n    # 5. Compute the critical risk aversion threshold\n    lambda_c = delta_E / delta_V\n\n    # 6. Calculate the fraction f_A based on the distribution of lambda\n    if dist_type == 'uniform':\n        lambda_min, lambda_max = dist_params\n        range_len = lambda_max - lambda_min\n        if range_len = 0: return 0.0 if delta_E  0 else 1.0\n        \n        if delta_V > 0: # Choose A if lambda  lambda_c\n            # Calculate length of intersection of [lambda_min, lambda_max] and (-inf, lambda_c)\n            intersect_len = max(0, min(lambda_c, lambda_max) - lambda_min)\n            return intersect_len / range_len\n        else: # delta_V  0, choose A if lambda > lambda_c\n            # Calculate length of intersection of [lambda_min, lambda_max] and (lambda_c, +inf)\n            intersect_len = max(0, lambda_max - max(lambda_c, lambda_min))\n            return intersect_len / range_len\n\n    elif dist_type == 'beta':\n        lambda_max, alpha, beta = dist_params\n        lambda_min = 0.0 # Scaled Beta is on [0, lambda_max]\n        \n        if lambda_max = 0: return 0.0 if delta_E  0 else 1.0\n        \n        # Normalize threshold to the standard Beta domain [0, 1]\n        z_c = lambda_c / lambda_max\n        z_c_clipped = np.clip(z_c, 0, 1)\n\n        cdf_at_threshold = betainc(alpha, beta, z_c_clipped)\n\n        if delta_V > 0: # Choose A if lambda  lambda_c\n            return cdf_at_threshold\n        else: # delta_V  0, choose A if lambda > lambda_c\n            return 1.0 - cdf_at_threshold\n            \n    return 0.0 # Should not be reached\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "人类-环境系统的模型通常需要一个明确的空间或网络结构来表示资源流动。本练习将带您进入一个更具实践性的层面：为一个灌溉网络编写资源分配算法。您将学习如何在一个有向无环图上，根据物理守恒定律（质量守恒）、智能体控制（闸门开启度）和社会规则（权重），精确计算水流的分配。这项练习  是构建许多环境ABM（如水资源管理或基础设施模型）的核心计算任务。",
            "id": "3860567",
            "problem": "考虑一个代表灌溉网络的有向无环图，其节点为 $\\mathcal{N}$，边为 $\\mathcal{E}$。每条边 $(i \\rightarrow j) \\in \\mathcal{E}$ 代表一条从上游节点 $i$ 到下游节点 $j$ 的渠道。代理控制边上的闸门开启度，从而影响有效吞吐量。您必须实现一个程序，该程序在代理控制的闸门设置下，根据物理和社会约束条件计算水流分配，并为指定的测试用例报告量化结果。\n\n基本原理和约束：\n- 质量守恒（连续性）：对于每个节点 $i \\in \\mathcal{N}$，设 $S_i$ 为外源入流（源项），$I_i$ 为来自上游边的入流总和，$D_i$ 为本地环境需水量，$L_i \\in [0,1)$ 为一个无量纲损失分数，代表因渗透和蒸发导致的流出量减少。节点 $i$ 的可用水量为 $A_i = S_i + I_i$。在节点 $i$ 处满足的需水量为 $E_i = \\min(D_i, A_i)$，扣除损失前的剩余可分配水量为 $R_i = A_i - E_i$。可用于下游分配的预算（应用损失后）为 $B_i = (1 - L_i) R_i$。\n- 容量和控制：每条边 $e \\in \\mathcal{E}$ 都有一个标称容量 $C_e$（单位为 $m^3/s$）。一个由代理控制的闸门开启分数 $g_e \\in [0,1]$ 将有效容量修正为 $C^{\\text{eff}}_e = g_e C_e$。对于每条边 $e$，流量 $F_e$ 必须满足 $0 \\leq F_e \\leq C^{\\text{eff}}_e$。\n- 公平性权重：从节点 $i$ 出发的每条边 $e$ 都有一个非负优先级权重 $w_e \\geq 0$，该权重决定了从节点 $i$ 出发的各条出边之间的按比例分配。当 $B_i$ 小于从 $i$ 出发的各条出边的有效容量之和时，从 $i$ 出发的流量应在遵守容量限制的前提下，按 $\\{w_e\\}$ 成比例分配；当 $B_i$ 超过有效容量之和时，各条边将以其有效容量饱和，任何剩余的 $B_i$ 都不会被输送到下游（它在本地溢出，不用于满足下游的需水量）。\n- 拓扑计算：由于该图是无环的，分配可以按照拓扑顺序，从源头开始向下游进行，从而确保在计算 $A_i$、$E_i$、$R_i$、$B_i$ 和出边分配时，$I_i$ 是已知的。\n\n节点分配要求：\n- 对于每个节点 $i$，设 $\\mathcal{E}^+_i$ 表示出边的集合，其有效容量为 $\\{C^{\\text{eff}}_e\\}$，权重为 $\\{w_e\\}$。在 $\\mathcal{E}^+_i$ 上分配 $B_i$ 以满足：\n    1. $\\sum_{e \\in \\mathcal{E}^+_i} F_e = \\min\\left(B_i, \\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e\\right)$，\n    2. 对于所有的 $e \\in \\mathcal{E}^+_i$，有 $0 \\leq F_e \\leq C^{\\text{eff}}_e$，\n    3. 如果 $\\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e \\ge B_i$，则在未饱和的边中，流量 $F_e$ 与 $w_e$ 成比例。\n\n您的程序必须在每个节点实现一个与上述要求一致、尊重容量的加权比例分配方案，并且仅使用提供的数值输入和基本原理。在计算完所有节点的流量和已满足的需水量后，为每个测试用例输出未满足的总需水量，其定义为 $\\sum_{i \\in \\mathcal{N}} (D_i - E_i)$，单位为 $m^3/s$。\n\n图与参数化：\n- 节点：$\\mathcal{N} = \\{0, 1, 2, 3\\}$。\n- 边 $\\mathcal{E}$ 及其标称容量 $C_e$（单位 $m^3/s$）、代理控制的闸门开启度 $g_e$（无单位）和优先级权重 $w_e$（无单位）如下：\n    - 边 $e_0$：$0 \\rightarrow 1$，$C_{e_0} = 5$，$w_{e_0} = 1.0$。\n    - 边 $e_1$：$0 \\rightarrow 2$，$C_{e_1} = 6$，$w_{e_1} = 2.0$。\n    - 边 $e_2$：$1 \\rightarrow 3$，$C_{e_2} = 4$，$w_{e_2} = 1.0$。\n    - 边 $e_3$：$2 \\rightarrow 3$，$C_{e_3} = 3$，$w_{e_3} = 1.0$。\n- 损失分数：$L_0 = 0.1$，$L_1 = 0.05$，$L_2 = 0.05$，$L_3 = 0$。\n- 该图是无环的，其拓扑顺序与从上游到下游的遍历 $0 \\rightarrow \\{1,2\\} \\rightarrow 3$ 一致。\n\n测试套件：\n- 案例1（理想情况）：外源入流 $S_0 = 10$, $S_1 = 0$, $S_2 = 0$, $S_3 = 0$；需水量 $D_0 = 2$, $D_1 = 3$, $D_2 = 1$, $D_3 = 4$；闸门开启度 $g_{e_0} = 0.8$, $g_{e_1} = 0.5$, $g_{e_2} = 1.0$, $g_{e_3} = 1.0$。\n- 案例2（边界情况，含关闭的闸门）：外源入流 $S_0 = 10$, $S_1 = 0$, $S_2 = 0$, $S_3 = 0$；需水量 $D_0 = 2$, $D_1 = 3$, $D_2 = 1$, $D_3 = 4$；闸门开启度 $g_{e_0} = 0.8$, $g_{e_1} = 0.0$, $g_{e_2} = 1.0$, $g_{e_3} = 1.0$。\n- 案例3（边缘情况，供应有限）：外源入流 $S_0 = 3$, $S_1 = 0$, $S_2 = 0$, $S_3 = 0$；需水量 $D_0 = 1.5$, $D_1 = 2$, $D_2 = 1$, $D_3 = 4$；闸门开启度 $g_{e_0} = 0.8$, $g_{e_1} = 0.5$, $g_{e_2} = 1.0$, $g_{e_3} = 1.0$。\n\n角度单位不适用。所有报告的量都必须以 $m^3/s$ 为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$），其中每个条目是相应案例的未满足总需水量，以浮点数形式表示，单位为 $m^3/s$。",
            "solution": "该问题要求在一个模拟的灌溉网络中计算水量分配和由此产生的未满足需水量。该网络被建模为有向无环图（DAG），这允许按照指定的拓扑顺序进行逐个节点的顺序计算。解决方案是通过在每个节点应用质量守恒原理和容量约束的加权比例分配规则得出的。\n\n### 基本原理和算法\n\n计算过程是按指定的拓扑顺序 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$ 依次处理每个节点。对于每个节点 $i$，会计算一个水量预算，然后根据物理和社会约束进行分配。\n\n**1. 每个节点的质量守恒：**\n对于任何给定的节点 $i \\in \\mathcal{N}$，水量平衡计算如下：\n- **总入流 ($I_i$)：** 所有入边的流量总和。对于像节点0这样的源节点，$I_0 = 0$。对于其他节点，$I_i = \\sum_{j \\to i} F_{j \\to i}$，其中 $F_{j \\to i}$ 是从节点 $j$到节点 $i$ 的边上的流量。\n- **可用水量 ($A_i$)：** 外源入流 $S_i$ 和总入流 $I_i$ 的总和：$A_i = S_i + I_i$。\n- **满足的需水量 ($E_i$)：** 尽可能用可用水量满足本地环境需水量 $D_i$：$E_i = \\min(D_i, A_i)$。此节点的未满足需水量是 $D_i - E_i$。\n- **剩余可分配水量 ($R_i$)：** 满足本地需水量后剩余的水量：$R_i = A_i - E_i$。\n- **下游预算 ($B_i$)：** 这是在考虑本地损失（例如，渗透、蒸发）后可用于分配给下游节点的水量，由损失分数 $L_i$ 给出：$B_i = (1 - L_i) R_i$。\n\n**2. 下游流量分配：**\n预算 $B_i$ 在从节点 $i$ 出发的出边集合（记为 $\\mathcal{E}^+_i$）中进行分配。每条边 $e \\in \\mathcal{E}^+_i$ 都有一个有效容量 $C^{\\text{eff}}_e = g_e C_e$（其中 $g_e$ 是代理控制的闸门开启度）和一个优先级权重 $w_e$。离开节点 $i$ 的总流量受其出边总有效容量 $\\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e$ 的约束。\n从节点 $i$ 分配出的总流量为 $\\sum_{e \\in \\mathcal{E}^+_i} F_e = \\min\\left(B_i, \\sum_{e \\in \\mathcal{E}^+_i} C^{\\text{eff}}_e\\right)$。\n这个总流量在各条单独的边之间的分配遵循一个尊重容量的加权比例方案：\n\n- **超额供应情况：** 如果预算 $B_i$ 大于或等于总出边有效容量（$\\sum C^{\\text{eff}}_e$），则每条出边 $e$ 都以其有效容量饱和：$F_e = C^{\\text{eff}}_e$。任何剩余的预算（$B_i - \\sum C^{\\text{eff}}_e$）被视为溢出，不输送到下游。\n- **供应不足情况：** 如果预算 $B_i$ 小于总出边有效容量，流量将根据权重 $\\{w_e\\}$ 按比例分配，同时受容量约束 $\\{C^{\\text{eff}}_e\\}$ 的限制。这通过一个迭代算法来处理：\n    1. 将活动边集合初始化为从节点 $i$ 出发的所有出边。\n    2. 在一个循环中，使用剩余预算和活动边：\n        a. 为每个活动边计算一个临时流量，该流量与其权重成比例。\n        b. 如果任何临时流量超过其边的有效容量，则该边被视为“饱和候选边”。\n        c. 如果存在饱和候选边，则将其流量固定为其有效容量，从预算中减去这些流量，将它们从活动边集合中移除，并用减少后的预算和剩余的边重复此过程。\n        d. 如果没有边的临时流量超过其容量，则在剩余的活动边之间按比例分配剩余预算，该节点的过程完成。\n\n**3. 未满足的总需水量：**\n在按拓扑顺序处理完所有节点并确定所有流量和已满足的需水量后，主要输出是整个网络未满足的总需水量，计算公式为 $\\sum_{i \\in \\mathcal{N}} (D_i - E_i)$。\n\n### 计算示例：案例1\n\n**参数：**\n- 外源入流：$S = \\{10, 0, 0, 0\\}$ $m^3/s$\n- 需水量：$D = \\{2, 3, 1, 4\\}$ $m^3/s$\n- 闸门开启度：$g = \\{g_{e_0}=0.8, g_{e_1}=0.5, g_{e_2}=1.0, g_{e_3}=1.0\\}$\n- 标称容量：$C = \\{C_{e_0}=5, C_{e_1}=6, C_{e_2}=4, C_{e_3}=3\\}$ $m^3/s$\n- 权重：$w = \\{w_{e_0}=1.0, w_{e_1}=2.0, w_{e_2}=1.0, w_{e_3}=1.0\\}$\n- 损失分数：$L = \\{0.1, 0.05, 0.05, 0\\}$\n\n**第0步：预计算**\n- 有效容量：\n  - $C^{\\text{eff}}_{e_0} = 0.8 \\times 5 = 4.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_1} = 0.5 \\times 6 = 3.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_2} = 1.0 \\times 4 = 4.0$ $m^3/s$\n  - $C^{\\text{eff}}_{e_3} = 1.0 \\times 3 = 3.0$ $m^3/s$\n\n**第1步：处理节点0**\n- $I_0 = 0$。$A_0 = S_0 + I_0 = 10 + 0 = 10$。\n- $E_0 = \\min(D_0, A_0) = \\min(2, 10) = 2$。节点0的未满足需水量为0。\n- $R_0 = A_0 - E_0 = 10 - 2 = 8$。\n- $B_0 = (1 - L_0) R_0 = (1 - 0.1) \\times 8 = 7.2$。\n- 将 $B_0=7.2$ 分配给边 $e_0$ ($0 \\to 1$) 和 $e_1$ ($0 \\to 2$)。\n- 从节点0流出的总容量为 $C^{\\text{eff}}_{e_0} + C^{\\text{eff}}_{e_1} = 4.0 + 3.0 = 7.0$。\n- 由于 $B_0=7.2 > 7.0$（超额供应），边被饱和。\n- $F_{e_0} = 4.0$。$F_{e_1} = 3.0$。$7.2 - 7.0 = 0.2$ $m^3/s$ 的水量溢出。\n\n**第2步：处理节点1**\n- $I_1 = F_{e_0} = 4.0$。$A_1 = S_1 + I_1 = 0 + 4.0 = 4.0$。\n- $E_1 = \\min(D_1, A_1) = \\min(3, 4.0) = 3$。节点1的未满足需水量为0。\n- $R_1 = A_1 - E_1 = 4.0 - 3 = 1.0$。\n- $B_1 = (1 - L_1) R_1 = (1 - 0.05) \\times 1.0 = 0.95$。\n- 将 $B_1=0.95$ 分配给边 $e_2$ ($1 \\to 3$)。\n- $F_{e_2} = \\min(B_1, C^{\\text{eff}}_{e_2}) = \\min(0.95, 4.0) = 0.95$。\n\n**第3步：处理节点2**\n- $I_2 = F_{e_1} = 3.0$。$A_2 = S_2 + I_2 = 0 + 3.0 = 3.0$。\n- $E_2 = \\min(D_2, A_2) = \\min(1, 3.0) = 1$。节点2的未满足需水量为0。\n- $R_2 = A_2 - E_2 = 3.0 - 1 = 2.0$。\n- $B_2 = (1 - L_2) R_2 = (1 - 0.05) \\times 2.0 = 1.9$。\n- 将 $B_2=1.9$ 分配给边 $e_3$ ($2 \\to 3$)。\n- $F_{e_3} = \\min(B_2, C^{\\text{eff}}_{e_3}) = \\min(1.9, 3.0) = 1.9$。\n\n**第4步：处理节点3**\n- $I_3 = F_{e_2} + F_{e_3} = 0.95 + 1.9 = 2.85$。\n- $A_3 = S_3 + I_3 = 0 + 2.85 = 2.85$。\n- $E_3 = \\min(D_3, A_3) = \\min(4, 2.85) = 2.85$。节点3的未满足需水量为 $4 - 2.85 = 1.15$。\n- 节点3是汇点，没有出边。\n\n**第5步：最终计算**\n- 未满足的总需水量 = $\\sum (D_i - E_i) = 0 (\\text{节点 } 0) + 0 (\\text{节点 } 1) + 0 (\\text{节点 } 2) + 1.15 (\\text{节点 } 3) = 1.15$ $m^3/s$。\n将此相同过程应用于所有测试用例，以获得各自的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef capacity_constrained_proportional_allocation(budget, capacities, weights):\n    \"\"\"\n    Allocates a budget of water flow across outgoing edges with capacity constraints\n    and proportional to weights. This is a \"fill and spill\" or priority-based logic.\n    \n    Args:\n        budget (float): The total available water budget.\n        capacities (dict): {edge_id: capacity}.\n        weights (dict): {edge_id: weight}.\n        \n    Returns:\n        dict: {edge_id: allocated flow}.\n    \"\"\"\n    if budget = 1e-9:\n        return {e: 0.0 for e in capacities}\n\n    total_capacity = sum(capacities.values())\n    if budget >= total_capacity:\n        return capacities.copy()\n        \n    flows = {e: 0.0 for e in capacities}\n    active_edges = list(capacities.keys())\n    budget_rem = budget\n    \n    # Make copies to modify during iteration\n    temp_capacities = capacities.copy()\n    \n    while budget_rem > 1e-9 and active_edges:\n        active_weights_sum = sum(weights[e] for e in active_edges)\n        if active_weights_sum = 1e-9:\n            break\n\n        # Provisional flows if there were no capacity constraints\n        provisional_flows = {e: budget_rem * weights[e] / active_weights_sum for e in active_edges}\n        \n        # Check which edges would be saturated by this provisional flow\n        saturating_edges = [e for e in active_edges if provisional_flows[e] >= temp_capacities[e]]\n        \n        if not saturating_edges:\n            # No edge saturates, distribute the rest of the budget proportionally and finish\n            for e in active_edges:\n                flows[e] = provisional_flows[e]\n            budget_rem = 0.0\n            break\n        else:\n            # Some edges saturate. Fill them to their capacity, reduce budget, and repeat.\n            for e in saturating_edges:\n                flows[e] = temp_capacities[e]\n                budget_rem -= temp_capacities[e]\n            \n            # Remove saturated edges from the next iteration\n            active_edges = [e for e in active_edges if e not in saturating_edges]\n\n    return flows\n\ndef solve():\n    # --- Static problem definition ---\n    nodes = [0, 1, 2, 3]\n    edges = [(0, 1), (0, 2), (1, 3), (2, 3)] # edge_idx: 0, 1, 2, 3\n\n    out_edges = {i: [] for i in nodes}\n    in_edges = {i: [] for i in nodes}\n    for i, (u, v) in enumerate(edges):\n        out_edges[u].append(i)\n        in_edges[v].append(i)\n        \n    topological_order = [0, 1, 2, 3]\n\n    # Parameters\n    C_nominal_base = np.array([5.0, 6.0, 4.0, 3.0])\n    weights_base = {0: 1.0, 1: 2.0, 2: 1.0, 3: 1.0}\n    L_base = np.array([0.1, 0.05, 0.05, 0.0])\n\n    # --- Test Cases ---\n    test_cases = [\n        {\"S\": np.array([10.0, 0.0, 0.0, 0.0]), \"D\": np.array([2.0, 3.0, 1.0, 4.0]), \"g\": np.array([0.8, 0.5, 1.0, 1.0])},\n        {\"S\": np.array([10.0, 0.0, 0.0, 0.0]), \"D\": np.array([2.0, 3.0, 1.0, 4.0]), \"g\": np.array([0.8, 0.0, 1.0, 1.0])},\n        {\"S\": np.array([3.0, 0.0, 0.0, 0.0]), \"D\": np.array([1.5, 2.0, 1.0, 4.0]), \"g\": np.array([0.8, 0.5, 1.0, 1.0])}\n    ]\n\n    results = []\n    for case in test_cases:\n        S, D, g = case[\"S\"], case[\"D\"], case[\"g\"]\n        C_eff = C_nominal_base * g\n        \n        # State variables\n        F = np.zeros(len(edges))\n        E = np.zeros(len(nodes))\n        \n        # Simulation loop\n        for i in topological_order:\n            inflow_I = sum(F[edge_idx] for edge_idx in in_edges[i])\n            available_A = S[i] + inflow_I\n            \n            satisfied_E = min(D[i], available_A)\n            E[i] = satisfied_E\n            \n            remaining_R = available_A - satisfied_E\n            budget_B = (1 - L_base[i]) * remaining_R\n            \n            if out_edges[i]:\n                node_out_edges = out_edges[i]\n                sub_capacities = {e: C_eff[e] for e in node_out_edges}\n                sub_weights = {e: weights_base[e] for e in node_out_edges}\n                \n                allocated_flows = capacity_constrained_proportional_allocation(\n                    budget_B, sub_capacities, sub_weights\n                )\n                \n                for edge_idx, flow_val in allocated_flows.items():\n                    F[edge_idx] = flow_val\n        \n        total_unmet_demand = np.sum(D - E)\n        results.append(f\"{total_unmet_demand:.6f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在真实世界中，智能体的行为不是一成不变的，他们会根据经验学习和调整策略。本练习将引导您探索一个更高级的主题：将强化学习机制整合到人类-环境系统中。您将推导出一个自洽的不动点方程，用以描述智能体策略（保护或开采）与环境状态（资源存量）之间相互影响、共同演化的动态平衡。通过这个练习 ，您将理解智能体适应性行为如何塑造环境的长期动态，这是耦合系统建模中的一个前沿和核心概念。",
            "id": "3860641",
            "problem": "考虑一个处于单一资源环境中的同质智能体种群。在每个离散时间步，每个智能体都面临一个二元选择：保护 ($C$) 与开发 ($E$)。环境由一个归一化的资源存量 $s_t \\in [0,1]$ 表示，该存量根据一个离散时间的平均场逻辑斯蒂补给和由开发引起的线性耗减模型进行演化：\n$$\ns_{t+1} = s_t + \\rho (1 - s_t) - \\xi \\, \\pi_E \\, s_t,\n$$\n其中 $\\rho > 0$ 是内在补给率，$\\xi \\ge 0$ 是开发影响系数，$\\pi_E \\in [0,1]$ 是种群中选择开发的稳态概率（平均场近似假设每个智能体相对于整个种群来说是微不足道的）。\n\n每个智能体接收的即时奖励取决于当前存量 $s_t$：\n$$\nr_C(s_t) = g \\, s_t, \\qquad r_E(s_t) = f \\, s_t - c,\n$$\n其中 $f > 0$ 和 $g \\ge 0$ 是特定于动作的收益系数，$c \\ge 0$ 是以效用单位衡量的外部化开发成本。\n\n智能体使用同策略的 Expected State–Action–Reward–State–Action (Expected-SARSA) 更新和 softmax 动作选择来学习动作价值。令 $Q_C$ 和 $Q_E$ 表示动作价值的估计值。策略是温度为 $\\tau > 0$ 的 softmax 函数：\n$$\n\\pi_a = \\frac{\\exp(Q_a / \\tau)}{\\exp(Q_C / \\tau) + \\exp(Q_E / \\tau)}, \\quad a \\in \\{C,E\\},\n$$\n且对于单一稳态，Expected-SARSA 的不动点一致性条件给出\n$$\nQ_a = r_a + \\gamma \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b,\n$$\n其中 $\\gamma \\in [0,1)$ 是折扣因子。在稳态下，资源存量 $s^*$ 和开发概率 $\\pi_E$ 必须与上述定义联合自洽。\n\n仅从上述核心定义和定律出发，推导在温度为 $\\tau$ 的 softmax 策略下，稳态开发概率 $\\pi_E$ 的自洽标量不动点方程，并用参数 $(\\tau,\\rho,\\xi,f,g,c,\\gamma)$ 表示。实现一个算法，为每组参数计算唯一的稳态解 $\\pi_E \\in [0,1]$，并以浮点数形式输出最终的开发概率。无需在输出中显式计算 $Q_C$、$Q_E$ 或 $s^*$，但你的推导必须证明最终算法形式的合理性。\n\n除奖励（以效用单位衡量）外，所有量均为无量纲；请将最终的开发概率报告为无单位小数。不涉及角度。\n\n你的程序必须解决以下测试套件，该套件旨在检验典型行为、低温和高温极限以及环境边缘情况。对于每种情况，计算稳态开发概率 $\\pi_E$ 并四舍五入到六位小数：\n\n- 情况 A (中等温度，基准环境): $\\tau = 0.25$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 B (近确定性策略): $\\tau = 10^{-3}$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 C (高温，近随机策略): $\\tau = 100.0$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 D (开发对资源无影响): $\\tau = 0.5$, $\\rho = 0.6$, $\\xi = 0.0$, $f = 1.0$, $g = 0.4$, $c = 0.2$, $\\gamma = 0.9$。\n- 情况 E (高昂的开发成本有利于保护): $\\tau = 0.25$, $\\rho = 0.6$, $\\xi = 0.8$, $f = 1.0$, $g = 0.4$, $c = 0.8$, $\\gamma = 0.9$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，[$x_1,x_2,x_3,x_4,x_5$]），每个 $x_i$ 等于相应情况下的稳态开发概率，并四舍五入到六位小数。",
            "solution": "我们从基于智能体的学习和环境动态定义开始。存在一个单一的稳态环境状态，由资源存量 $s_t \\in [0,1]$ 表征，其平均场演化如下\n$$\ns_{t+1} = s_t + \\rho (1 - s_t) - \\xi \\, \\pi_E \\, s_t,\n$$\n其中 $\\rho > 0$ 是补给率，$\\xi \\ge 0$ 是对存量的开发影响，$\\pi_E$ 是稳态开发概率。在稳态下，令 $s_{t+1} = s_t = s^*$，解出 $s^*$：\n$$\n0 = \\rho (1 - s^*) - \\xi \\, \\pi_E \\, s^*, \\quad \\Rightarrow \\quad s^* = \\frac{\\rho}{\\rho + \\xi \\pi_E}.\n$$\n\n智能体接收的即时奖励取决于 $s_t$：\n$$\nr_C(s) = g s, \\qquad r_E(s) = f s - c,\n$$\n其中 $f > 0$ 和 $g \\ge 0$ 是特定于动作的收益，$c \\ge 0$ 是以效用单位计量的开发成本。\n\n智能体采用 Expected State–Action–Reward–State–Action (Expected-SARSA) 学习，动作价值为 $Q_C, Q_E$，策略为温度是 $\\tau$ 的 softmax 函数：\n$$\n\\pi_a = \\frac{\\exp(Q_a/\\tau)}{\\exp(Q_C/\\tau) + \\exp(Q_E/\\tau)}, \\quad a \\in \\{C,E\\},\n$$\n且对于单一稳态，Expected-SARSA 的不动点一致性条件给出：\n$$\nQ_a = r_a + \\gamma \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b, \\quad \\gamma \\in [0,1).\n$$\n\n定义软价值\n$$\nV = \\sum_{b \\in \\{C,E\\}} \\pi_b Q_b.\n$$\n代入 Expected-SARSA 的形式来表示 $V$：\n$$\nV = \\sum_b \\pi_b \\left(r_b + \\gamma V\\right) = \\sum_b \\pi_b r_b + \\gamma V.\n$$\n解出 $V$：\n$$\nV = \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}.\n$$\n于是每个动作价值为\n$$\nQ_a = r_a + \\gamma V = r_a + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}.\n$$\n\n考虑进入 softmax 函数的动作价值之差：\n$$\n\\Delta \\equiv Q_E - Q_C = \\left(r_E + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}\\right) - \\left(r_C + \\gamma \\frac{\\sum_b \\pi_b r_b}{1 - \\gamma}\\right) = r_E - r_C.\n$$\n因此，使用 Expected-SARSA 和 softmax 的学习动态所产生的稳态策略差异仅由即时奖励差异决定。这种抵消在单一稳态下是直观的，因为期望未来回报通过 $\\gamma V$ 对两个动作价值的贡献是相等的。\n\n使用两个动作的 softmax 形式，开发概率是 $Q_E - Q_C$ 的逻辑斯蒂函数：\n$$\n\\pi_E = \\frac{1}{1 + \\exp\\left(-\\frac{Q_E - Q_C}{\\tau}\\right)} = \\frac{1}{1 + \\exp\\left(-\\frac{r_E - r_C}{\\tau}\\right)}.\n$$\n代入 $r_E(s^*) = f s^* - c$ 和 $r_C(s^*) = g s^*$：\n$$\nr_E - r_C = (f - g) s^* - c.\n$$\n使用稳态存量 $s^* = \\frac{\\rho}{\\rho + \\xi \\pi_E}$，我们得到关于 $\\pi_E$ 的标量不动点方程：\n$$\n\\pi_E = \\frac{1}{1 + \\exp\\left(-\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi_E} - c}{\\tau}\\right)}.\n$$\n\n对于 $\\rho > 0$, $\\xi \\ge 0$, $f > 0$, $g \\ge 0$, $c \\ge 0$ 和 $\\tau > 0$，此方程在区间 $\\pi_E \\in [0,1]$ 上是良定义的。方程右侧在 $(0,1)$ 内是连续且严格有界的。定义函数\n$$\nh(\\pi) = \\frac{1}{1 + \\exp\\left(-\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi} - c}{\\tau}\\right)}.\n$$\n我们寻找满足 $h(\\pi^*) = \\pi^*$ 的 $\\pi^*$。考虑 $g(\\pi) = h(\\pi) - \\pi$。由于 $h(0) \\in (0,1)$，所以 $g(0) = h(0) - 0 > 0$。同样，由于 $h(1) \\in (0,1)$，所以 $g(1) = h(1) - 1  0$。根据介值定理，在 $[0,1]$ 中至少存在一个根。在所述参数范围内 $h(\\pi)$ 的单调性保证了解的唯一性，因为增加 $\\pi$ 会削弱存量 $s^*$，并通常会减少 $(f - g) s^* - c$，使得当 $(f - g) \\rho > 0$ 和 $\\xi \\ge 0$ 时 $h(\\pi)$ 是非增的。因此，存在唯一的不动点，可以通过在 $[0,1]$ 上对 $g(\\pi)$ 使用稳健的区间求根法找到。\n\n为给定参数集计算 $\\pi_E$ 的算法步骤如下：\n1. 定义逻辑斯蒂函数 $\\sigma(x) = \\frac{1}{1 + e^{-x}}$。\n2. 对于给定的 $(\\tau,\\rho,\\xi,f,g,c)$，定义 $h(\\pi) = \\sigma\\left(\\frac{(f - g)\\, \\frac{\\rho}{\\rho + \\xi \\pi} - c}{\\tau}\\right)$ 和 $g(\\pi) = h(\\pi) - \\pi$。\n3. 在 $[0,1]$ 上对 $g(\\pi)$ 使用区间求根法，以获得唯一的不动点 $\\pi^*$。\n4. 将 $\\pi^*$ 四舍五入到六位小数。\n5. 对每个测试用例重复此过程。\n\n注意，由于单一稳态和 Expected-SARSA 结构，折扣因子 $\\gamma$ 在开发概率的表达式中被抵消了；softmax 函数仅依赖于 $Q_E - Q_C = r_E - r_C$。尽管如此，$\\gamma$ 仍然是基础推导的一部分。\n\n将此方法应用于问题中指定的测试套件。对于每种情况，程序通过求解不动点方程来计算稳态开发概率 $\\pi_E$，并以方括号内的逗号分隔列表形式返回四舍五入后的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef steady_state_exploitation_probability(tau, rho, xi, f, g, c, gamma):\n    \"\"\"\n    Compute steady-state exploitation probability pi_E under a softmax policy\n    with temperature tau, in a mean-field single-state environment with\n    logistic replenishment and linear depletion from exploitation.\n\n    Although gamma is part of the RL setup, pi_E depends only on reward\n    differences in the single stationary state and thus is independent of gamma.\n    \"\"\"\n    # Logistic function\n    def logistic(x):\n        # Use stable computation to avoid overflow\n        return 1.0 / (1.0 + np.exp(-x))\n\n    # Define the fixed-point function g(pi) = h(pi) - pi, where h(pi) is the\n    # exploitation probability as a function of itself. We seek g(pi) = 0.\n    def g_fun(pi):\n        # Steady-state stock s* = rho / (rho + xi * pi)\n        # Denominator is always positive since rho > 0 and xi*pi >= 0\n        s_star = rho / (rho + xi * pi)\n        \n        # Reward difference delta = r_E - r_C = (f - g) * s* - c\n        delta = (f - g) * s_star - c\n        \n        # Softmax exploitation probability under two actions is logistic(delta / tau)\n        h_pi = logistic(delta / tau)\n        \n        return h_pi - pi\n\n    # Use a robust root-finding algorithm on the interval [0, 1].\n    # The function g_fun(pi) is continuous and g(0) > 0, g(1)  0,\n    # so a root is guaranteed to exist.\n    pi_star = brentq(g_fun, 0.0, 1.0, maxiter=1000, rtol=1e-12)\n    return pi_star\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (tau, rho, xi, f, g, c, gamma)\n    test_cases = [\n        (0.25, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),   # Case A\n        (1e-3, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),   # Case B\n        (100.0, 0.6, 0.8, 1.0, 0.4, 0.2, 0.9),  # Case C\n        (0.5, 0.6, 0.0, 1.0, 0.4, 0.2, 0.9),    # Case D\n        (0.25, 0.6, 0.8, 1.0, 0.4, 0.8, 0.9),   # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, rho, xi, f, g, c, gamma = case\n        pi_e = steady_state_exploitation_probability(tau, rho, xi, f, g, c, gamma)\n        results.append(f\"{pi_e:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}