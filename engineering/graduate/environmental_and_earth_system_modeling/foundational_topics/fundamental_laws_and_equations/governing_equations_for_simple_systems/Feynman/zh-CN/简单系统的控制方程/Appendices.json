{
    "hands_on_practices": [
        {
            "introduction": "本练习将通过一个经典的水文地质学问题，引导你从基本物理原理出发，推导并求解控制方程。你将运用质量守恒和达西定律，为一个非承压含水层系统建立数学模型，并解析地求解出稳态下的地下水水位剖面。这个过程不仅能让你深入理解如何从第一性原理构建模型，也展示了数学在精确描述物理现象中的力量。",
            "id": "3883626",
            "problem": "考虑一个在稳定流条件下，沿水平坐标 $x$ 延伸于区间 $[0,L]$ 上的无压含水层。该系统是一维（$1$D）的，并以恒定速率 $R>0$ 接受均匀的面状补给（累积）。假设 Dupuit–Forchheimer (DF) 近似（垂直水力梯度可忽略不计，水流主要为水平方向）和 Darcy 定律成立。令 $H(x)$ 表示从不透水基底量起的含水层饱和厚度，令 $q(x)$ 表示沿 $+x$ 方向的单位宽度特定流量（单位宽度的体积通量）。导水系数 $K$ 为常数。两条河流将边界处的地下水位固定，施加了 Dirichlet 条件 $H(0)=H_{0}>0$ 和 $H(L)=H_{L}>0$。\n\n从稳态下的局部质量平衡和仅在 DF 近似下的 Darcy 定律出发，推导控制方程，并求解与这些边界条件一致的地下水位剖面 $H(x)$。将最终答案表示为关于 $x$、$L$、$K$、$R$、$H_{0}$ 和 $H_{L}$ 的单一闭式解析表达式 $H(x)$。无需进行数值计算。",
            "solution": "该问题是有效的，因为它在科学上基于水文地质学原理，在数学上是适定的，并且是对一个标准边值问题的客观陈述。我们可以开始推导求解。\n\n推导始于稳态下的质量守恒原理。考虑一个沿 $x$ 轴、长度为无穷小 $dx$、单位宽度的含水层一维控制体。水流由单位宽度特定流量 $q(x)$ 控制，它表示单位时间内流过 $x$ 处横截面的水量。含水层以速率 $R$ 接受均匀的面状补给，其单位为单位面积单位时间内的体积。对于我们的单位宽度一维系统，此补给为控制体贡献了一个大小为 $R \\cdot dx$ 的源项。\n\n控制体的稳态质量平衡方程为：\n$$ \\text{Flow in} + \\text{Source} = \\text{Flow out} $$\n$$ q(x) + R \\, dx = q(x+dx) $$\n重新整理各项，我们得到：\n$$ q(x+dx) - q(x) = R \\, dx $$\n两边除以 $dx$ 并取 $dx \\to 0$ 的极限，得到质量守恒方程的微分形式：\n$$ \\frac{dq}{dx} = R $$\n该方程表明，沿流路径的特定流量变化率等于补给速率。\n\n接下来，我们应用经 Dupuit-Forchheimer (DF) 近似调整后的 Darcy 定律。DF 近似假设水流基本是水平的，因此在任意点 $x$ 的水头 $h$ 可以被认为等于含水层的饱和厚度 $H(x)$。因此，$h(x) = H(x)$。\n\n根据 Darcy 定律，特定流量（单位含水层面积的通量），我们称之为 $q'$，由下式给出：\n$$ q'(x) = -K \\frac{dh}{dx} = -K \\frac{dH}{dx} $$\n其中 $K$ 是恒定的导水系数。问题陈述中的量 $q(x)$ 是单位宽度特定流量，它是 Darcy 通量 $q'(x)$ 在饱和厚度 $H(x)$ 上的积分：\n$$ q(x) = q'(x) \\cdot H(x) = \\left(-K \\frac{dH}{dx}\\right) H(x) = -K H(x) \\frac{dH}{dx} $$\n使用链式法则恒等式 $\\frac{d}{dx}(H^2) = 2H \\frac{dH}{dx}$，该表达式可以更方便地写成：\n$$ q(x) = -\\frac{K}{2} \\frac{d}{dx}\\left(H(x)^2\\right) $$\n\n现在，我们将 $q(x)$ 的这个表达式代入质量守恒方程 $\\frac{dq}{dx} = R$ 中：\n$$ \\frac{d}{dx} \\left(-\\frac{K}{2} \\frac{d}{dx}\\left(H(x)^2\\right)\\right) = R $$\n由于 $K$ 是常数，我们可以将其移到导数符号外面：\n$$ -\\frac{K}{2} \\frac{d^2}{dx^2}\\left(H(x)^2\\right) = R $$\n这是关于 $H(x)^2$ 的控制性二阶常微分方程。让我们定义一个新变量 $Y(x) = H(x)^2$。方程变为：\n$$ \\frac{d^2Y}{dx^2} = -\\frac{2R}{K} $$\n这是一个简单的线性常微分方程（ODE），可以通过直接积分求解。对 $x$ 积分一次，得到：\n$$ \\frac{dY}{dx} = -\\frac{2R}{K}x + C_1 $$\n其中 $C_1$ 是一个积分常数。再次积分，得到 $Y(x)$ 的通解：\n$$ Y(x) = -\\frac{R}{K}x^2 + C_1 x + C_2 $$\n其中 $C_2$ 是第二个积分常数。将 $Y(x) = H(x)^2$ 代回：\n$$ H(x)^2 = -\\frac{R}{K}x^2 + C_1 x + C_2 $$\n\n常数 $C_1$ 和 $C_2$ 通过应用给定的 Dirichlet 边界条件确定：$H(0) = H_0$ 和 $H(L) = H_L$。用 $Y(x)$ 表示，这些条件是 $Y(0) = H_0^2$ 和 $Y(L) = H_L^2$。\n\n在 $x=0$ 处应用第一个边界条件：\n$$ Y(0) = H_0^2 = -\\frac{R}{K}(0)^2 + C_1(0) + C_2 $$\n这立即得出 $C_2 = H_0^2$。解现在具有以下形式：\n$$ H(x)^2 = -\\frac{R}{K}x^2 + C_1 x + H_0^2 $$\n\n在 $x=L$ 处应用第二个边界条件：\n$$ Y(L) = H_L^2 = -\\frac{R}{K}L^2 + C_1 L + H_0^2 $$\n我们求解这个方程得到 $C_1$：\n$$ C_1 L = H_L^2 - H_0^2 + \\frac{R}{K}L^2 $$\n$$ C_1 = \\frac{H_L^2 - H_0^2}{L} + \\frac{RL}{K} $$\n\n最后，我们将 $C_1$ 和 $C_2$ 的表达式代回到 $H(x)^2$ 的通解中：\n$$ H(x)^2 = -\\frac{R}{K}x^2 + \\left(\\frac{H_L^2 - H_0^2}{L} + \\frac{RL}{K}\\right)x + H_0^2 $$\n为了得到一个更有条理的表达式，我们可以对各项进行分组：\n$$ H(x)^2 = H_0^2 + \\frac{H_L^2 - H_0^2}{L}x + \\frac{RL}{K}x - \\frac{R}{K}x^2 $$\n$$ H(x)^2 = H_0^2 + \\left(\\frac{H_L^2 - H_0^2}{L}\\right)x + \\frac{R}{K}(Lx - x^2) $$\n由于 $H(x)$ 代表物理上的饱和厚度，它必须是非负的。因此，我们取正平方根以获得地下水位剖面的最终表达式：\n$$ H(x) = \\sqrt{H_0^2 + \\frac{H_L^2 - H_0^2}{L}x + \\frac{R}{K}(Lx - x^2)} $$\n该解描述了一个抛物线形的地下水位剖面，它叠加在一个线性剖面上，后者是在没有补给（$R=0$）时存在的情况。",
            "answer": "$$ \\boxed{H(x) = \\sqrt{H_0^2 + \\frac{H_L^2 - H_0^2}{L}x + \\frac{R}{K}(Lx - x^2)}} $$"
        },
        {
            "introduction": "解析解虽然深刻，但通常仅限于理想化的简单情景，因此数值方法是解决实际环境问题的关键。本练习聚焦于扩散方程的数值求解，这是许多环境输运过程的核心。通过实现Crank-Nicolson格式，你将亲手探索计算模型中至关重要的数值稳定性与精度问题，这些是开发可靠环境模型的必备技能。",
            "id": "3883646",
            "problem": "考虑一个由菲克第一定律和质量守恒控制的无源示踪剂浓度的一维扩散问题。通量由 $J(x,t)=-D\\,\\partial_x c(x,t)$ 给出，其中 $D$ 是一个恒定的分子扩散系数，而守恒定律是 $\\partial_t c(x,t)+\\partial_x J(x,t)=0$。将这两者结合，得到抛物线型偏微分方程 (PDE) $\\partial_t c(x,t)=D\\,\\partial_{xx}c(x,t)$。\n\n您将为该 PDE 在均匀周期性网格上的空间离散形式实现 Crank-Nicolson 时间步进格式，然后使用您的实现来数值评估其无条件稳定性和数值阻尼特性。区域为 $[0,L]$，具有周期性边界条件和 $N$ 个均匀分布的网格点，间距为 $\\Delta x=L/N$。对离散拉普拉斯算子使用标准的二阶中心差分，并在时间上使用梯形 (Crank-Nicolson) 法则，以在时间层级 $n$ 和 $n+1$ 之间进行半隐式更新。\n\n从菲克第一定律和质量守恒的基本原理出发，推导您所实现的格式。不要使用问题陈述中的任何简便公式。您的程序应以一种能让您执行以下操作的方式应用该格式：\n- 计算周期性网格上任何离散傅里叶模式的每步放大因子。\n- 将 Crank-Nicolson 放大因子与空间离散化后的常微分方程的半离散精确时间演化进行比较。\n\n在您的推理和实现中使用的定义：\n- 具有 $N$ 个点的周期性网格上的离散傅里叶模式由整数 $m\\in\\{0,1,\\dots,N-1\\}$ 索引，其在网格索引 $j$ 处的值与 $\\cos\\!\\big(2\\pi m\\, j/N\\big)$ 或 $\\sin\\!\\big(2\\pi m\\, j/N\\big)$ 成正比。\n- 半离散精确时间演化指的是解析地积分空间离散化后得到的常微分方程组，对于每个离散本征模，得到 $c(t)=\\exp\\!\\big(\\lambda_m\\, t\\big)\\,c(0)$，其中 $\\lambda_m$ 是对应于模式 $m$ 的离散拉普拉斯算子的本征值。\n\n物理和数值单位：\n- 使用 $L$（单位：米，$\\mathrm{m}$）、$D$（单位：平方米/秒，$\\mathrm{m}^2/\\mathrm{s}$）、时间 $t$（单位：秒，$\\mathrm{s}$），以及波数（单位：弧度/米，$\\mathrm{rad}/\\mathrm{m}$）。\n- 所有要求的输出都是无量纲数，并应按指定报告为纯浮点值或布尔值。\n\n测试套件和输出：\n实现您的程序以评估以下三个测试用例。在每个用例中，假设初始条件为 $c(x,0)=A\\cos\\!\\big(2\\pi m\\,x/L\\big)$，振幅 $A=1$，这样动力学完全由模式 $m$ 的放大因子捕获。\n\n- 测试用例 1（非刚性区域的准确性）：\n    - 参数：$L=1\\,\\mathrm{m}$，$N=128$，$D=10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t=10^{-3}\\,\\mathrm{s}$，最终时间 $T=0.1\\,\\mathrm{s}$，模式索引 $m=4$。\n    - 任务：计算 $T$ 秒后，模式 $m$ 的 Crank-Nicolson 放大后的幅值与半离散精确幅值之间的绝对差。将此绝对差作为浮点数返回。\n\n- 测试用例 2（大时间步下所有模式的无条件稳定性）：\n    - 参数：$L=1\\,\\mathrm{m}$，$N=128$，$D=10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t=5\\,\\mathrm{s}$。\n    - 任务：对于所有离散模式 $m\\in\\{0,\\dots,N-1\\}$，计算每步 Crank-Nicolson 放大因子的幅值。当且仅当每个模式都满足 $|G_m|\\le 1$（无条件稳定性）时，返回布尔值 $True$，否则返回 $False$。\n\n- 测试用例 3（刚性高频模式的数值阻尼不足和时间振荡）：\n    - 参数：$L=1\\,\\mathrm{m}$，$N=128$，$D=1\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t=0.1\\,\\mathrm{s}$，最终时间 $T=10\\,\\mathrm{s}$，模式索引 $m=N/2$（奈奎斯特模式）。\n    - 任务：计算 $T$ 秒后，模式 $m$ 的 Crank-Nicolson 放大后的幅值与半离散精确幅值之比的以 10 为底的对数。将此值作为浮点数返回。一个大的正值表示相对于半离散精确衰减，Crank-Nicolson 格式存在严重的阻尼不足。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为逗号分隔的列表，并用方括号括起来，顺序为测试用例 1、测试用例 2、测试用例 3。例如，输出应类似于 $[x_1,x_2,x_3]$，其中 $x_1$ 和 $x_3$ 是浮点值，$x_2$ 是布尔值。",
            "solution": "用户提供的问题经评估为**有效**。它在科学上基于质量守恒和菲克扩散原理，数学上是适定的，并以客观、精确的语言呈现。为三个指定的测试用例提供了所有必要的数据和定义，该问题是偏微分方程数值分析中的一个标准且非平凡的练习。\n\n### 1. 控制方程和数值格式的推导\n\n问题始于两个基本原理：示踪剂浓度 $c(x,t)$ 的质量守恒和关于扩散通量 $J(x,t)$ 的菲克第一定律。\n\n一维的守恒定律表示为一个连续性方程：\n$$\n\\partial_t c(x,t) + \\partial_x J(x,t) = 0\n$$\n其中 $\\partial_t$ 是关于时间 $t$ 的偏导数，$\\partial_x$ 是关于空间 $x$ 的偏导数。\n\n菲克第一定律指出，通量与浓度梯度的负值成正比，描述了一个顺梯度输运过程：\n$$\nJ(x,t) = -D \\, \\partial_x c(x,t)\n$$\n其中 $D$ 是恒定的分子扩散系数。\n\n将 $J(x,t)$ 的表达式代入守恒定律，得到：\n$$\n\\partial_t c(x,t) + \\partial_x \\left(-D \\, \\partial_x c(x,t)\\right) = 0\n$$\n由于给定的扩散系数 $D$ 是一个常数，可以将其从空间导数中提出，从而得到一维扩散方程，这是一个抛物线型偏微分方程 (PDE)：\n$$\n\\partial_t c(x,t) = D \\, \\partial_{xx} c(x,t)\n$$\n\n### 2. 空间和时间离散化\n\n为了数值求解这个 PDE，我们首先进行空间离散化（方法线法）。区域 $[0, L]$ 被划分为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀区间，网格点位于 $x_j = j \\Delta x$，$j = 0, 1, \\dots, N-1$。令 $c_j(t)$ 表示浓度 $c(x_j, t)$ 的数值近似。\n\n在网格点 $x_j$ 处的二阶空间导数 $\\partial_{xx} c$ 使用二阶中心差分公式进行近似。这对于指定的周期性边界条件是合适的：\n$$\n\\partial_{xx} c(x_j, t) \\approx \\frac{c_{j+1}(t) - 2c_j(t) + c_{j-1}(t)}{\\Delta x^2}\n$$\n其中索引对 $N$ 取模（例如，$c_N = c_0$ 和 $c_{-1} = c_{N-1}$）。将此代入 PDE，得到一个耦合常微分方程 (ODE) 组，即半离散形式：\n$$\n\\frac{d c_j(t)}{dt} = \\frac{D}{\\Delta x^2} \\left( c_{j+1}(t) - 2c_j(t) + c_{j-1}(t) \\right)\n$$\n该方程组可以写成向量形式 $\\frac{d\\vec{c}}{dt} = \\mathbf{L}\\vec{c}$，其中 $\\vec{c} = [c_0, c_1, \\dots, c_{N-1}]^T$，$\\mathbf{L}$ 是表示离散拉普拉斯算子乘以 $D$ 的矩阵。\n\n对于时间积分，我们应用 Crank-Nicolson 方法，这等同于梯形法则。对于时间步长 $\\Delta t$，$\\vec{c}^n \\approx \\vec{c}(n\\Delta t)$，格式为：\n$$\n\\frac{\\vec{c}^{n+1} - \\vec{c}^n}{\\Delta t} = \\frac{1}{2} \\left( \\mathbf{L}\\vec{c}^{n+1} + \\mathbf{L}\\vec{c}^n \\right)\n$$\n这是一个隐式方法。为方便计算，我们重新整理方程，将未知状态 $\\vec{c}^{n+1}$ 分离到一边：\n$$\n\\vec{c}^{n+1} - \\frac{\\Delta t}{2} \\mathbf{L}\\vec{c}^{n+1} = \\vec{c}^n + \\frac{\\Delta t}{2} \\mathbf{L}\\vec{c}^n\n$$\n将状态向量因子化，得到 Crank-Nicolson 格式的标准形式，这需要在每个时间步求解一个线性系统：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{L}\\right) \\vec{c}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{L}\\right) \\vec{c}^n\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。\n\n### 3. 傅里叶模式分析（冯·诺依曼稳定性分析）\n\n为了分析格式的准确性和稳定性，我们研究其在离散傅里叶模式上的行为，这些模式是循环矩阵 $\\mathbf{L}$ 的特征向量。网格上索引为 $m$ 的复傅里叶模式由 $c_j = \\exp(i k x_j) = \\exp(i 2\\pi m j / N)$ 给出，其中 $k = 2\\pi m / L$ 是波数。\n\n将离散空间算子应用于此模式，揭示其对应的本征值 $\\lambda_m$：\n$$\n(\\mathbf{L} \\vec{c})_j = \\frac{D}{\\Delta x^2} \\left( e^{i 2\\pi m (j+1)/N} - 2e^{i 2\\pi m j/N} + e^{i 2\\pi m (j-1)/N} \\right) = \\frac{D}{\\Delta x^2} c_j \\left( e^{i 2\\pi m/N} - 2 + e^{-i 2\\pi m/N} \\right)\n$$\n使用欧拉公式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，上式简化为：\n$$\n(\\mathbf{L} \\vec{c})_j = \\frac{2D}{\\Delta x^2} c_j \\left( \\cos\\left(\\frac{2\\pi m}{N}\\right) - 1 \\right)\n$$\n使用恒等式 $1 - \\cos(2\\theta) = 2\\sin^2(\\theta)$，本征值 $\\lambda_m$ 为：\n$$\n\\lambda_m = \\frac{-4D}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n这些本征值是实数且非正（$\\lambda_m \\le 0$），这与纯粹耗散的物理过程一致。\n\n模式 $m$ 的“半离散精确”演化遵循 ODE $\\frac{dc_m(t)}{dt} = \\lambda_m c_m(t)$，其解为 $c_m(t) = c_m(0) \\exp(\\lambda_m t)$。此模式在时间 $T$ 内的放大为 $\\exp(\\lambda_m T)$。\n\nCrank-Nicolson 格式的数值放大因子 $G_m$ 可通过将 $\\vec{c}^{n+1} = G_m \\vec{c}^n$ 和 $\\mathbf{L}\\vec{c} = \\lambda_m \\vec{c}$ 代入格式方程得到：\n$$\n\\left(1 - \\frac{\\Delta t}{2} \\lambda_m\\right) G_m = \\left(1 + \\frac{\\Delta t}{2} \\lambda_m\\right) \\implies G_m = \\frac{1 + \\lambda_m \\Delta t / 2}{1 - \\lambda_m \\Delta t / 2}\n$$\n\n### 4. 测试用例的实现策略\n\n推导出的 $\\lambda_m$ 和 $G_m$ 公式用于评估测试用例。\n\n**测试用例 1：** 目标是计算格式的准确性。我们计算在 $N_{steps} = T / \\Delta t$ 步后的总数值放大与时间 $T$ 内的总半离散精确放大之间的绝对差。该量为 $\\left| |G_m|^{N_{steps}} - \\exp(\\lambda_m T) \\right|$。\n\n**测试用例 2：** 此测试验证 Crank-Nicolson 格式对于扩散方程的无条件稳定性。我们必须检查对于所有模式 $m \\in \\{0, \\dots, N-1\\}$ 是否都有 $|G_m| \\le 1$。由于 $\\lambda_m \\le 0$ 且 $\\Delta t > 0$，项 $z_m = \\lambda_m \\Delta t / 2$ 是非正的。令 $z_m = -a_m$ 其中 $a_m \\ge 0$。则 $|G_m| = |(1-a_m)/(1+a_m)|$。如初等分析所示，对于 $a_m \\ge 0$，该量总是小于或等于 $1$。因此，该格式是 A-稳定的，测试必须评估为 `True`。\n\n**测试用例 3：** 此用例突显了 Crank-Nicolson 格式的一个已知缺陷：其对高频（刚性）模式缺乏强阻尼。我们分析奈奎斯特模式 $m=N/2$，该模式具有最大幅值的本征值，因此具有最快的物理衰减率。我们计算数值放大幅值与精确放大幅值之比的以 10 为底的对数：$\\log_{10}\\left( |G_m|^{N_{steps}} / \\exp(\\lambda_m T) \\right)$。对于大的 $\\Delta t$， $G_{N/2}$ 的值接近 $-1$，这意味着数值解几乎不衰减并且符号振荡，而精确解几乎是瞬时衰减的。这导致对数比为一个非常大的正值。为保证数值稳定性，此计算在对数空间中执行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the Crank-Nicolson scheme analysis and print the results.\n    \"\"\"\n\n    # --- Helper function for core physics/numerics calculation ---\n    def get_modal_properties(L, N, D, dt, m):\n        \"\"\"\n        Computes the eigenvalue lambda_m of the discrete Laplacian and the \n        Crank-Nicolson amplification factor G_m for a given mode m.\n        \n        Args:\n            L (float): Domain length.\n            N (int): Number of grid points.\n            D (float): Diffusivity.\n            dt (float): Time step.\n            m (int): Fourier mode index.\n            \n        Returns:\n            tuple: (lambda_m, G_m)\n        \"\"\"\n        dx = L / N\n        \n        # Eigenvalue lambda_m. Handle the m=0 (constant) mode explicitly\n        # to ensure it is exactly zero.\n        if m % N == 0:\n            lambda_m = 0.0\n        else:\n            # Formula derived from centered difference operator on a periodic grid.\n            lambda_m = (-4.0 * D / dx**2) * np.sin(np.pi * m / N)**2\n\n        # Crank-Nicolson per-step amplification factor G_m.\n        numerator = 1.0 + 0.5 * dt * lambda_m\n        denominator = 1.0 - 0.5 * dt * lambda_m\n        # Denominator is guaranteed to be positive as D>=0, dt>0, and lambda_m=0.\n        G_m = numerator / denominator\n        \n        return lambda_m, G_m\n\n    # --- Container for results ---\n    results = []\n\n    # =========================================================================\n    # Test Case 1: Accuracy in a non-stiff regime\n    # =========================================================================\n    params1 = {'L': 1.0, 'N': 128, 'D': 1e-4, 'dt': 1e-3, 'T': 0.1, 'm': 4}\n    \n    lambda_m1, G_m1 = get_modal_properties(params1['L'], params1['N'], params1['D'], params1['dt'], params1['m'])\n    \n    num_steps1 = int(round(params1['T'] / params1['dt']))\n    \n    # Final magnitude from Crank-Nicolson scheme after T seconds.\n    cn_magnitude1 = np.abs(G_m1)**num_steps1\n    \n    # Final magnitude from semi-discrete exact solution after T seconds.\n    exact_magnitude1 = np.exp(lambda_m1 * params1['T'])\n    \n    result1 = np.abs(cn_magnitude1 - exact_magnitude1)\n    results.append(result1)\n\n    # =========================================================================\n    # Test Case 2: Unconditional stability\n    # =========================================================================\n    params2 = {'L': 1.0, 'N': 128, 'D': 1e-4, 'dt': 5.0}\n\n    is_stable = True\n    # Theory guarantees stability (|G_m| = 1). This is a numerical verification.\n    for m_idx in range(params2['N']):\n        _, G_m_val = get_modal_properties(params2['L'], params2['N'], params2['D'], params2['dt'], m_idx)\n        # Allow a small floating-point tolerance for the check.\n        if np.abs(G_m_val) > 1.0 + 1e-12:\n            is_stable = False\n            break\n    \n    result2 = is_stable\n    results.append(result2)\n\n    # =========================================================================\n    # Test Case 3: Numerical damping deficiency for stiff modes\n    # =========================================================================\n    params3 = {'L': 1.0, 'N': 128, 'D': 1.0, 'dt': 0.1, 'T': 10.0, 'm': 128 // 2}\n\n    lambda_m3, G_m3 = get_modal_properties(params3['L'], params3['N'], params3['D'], params3['dt'], params3['m'])\n    \n    num_steps3 = int(round(params3['T'] / params3['dt']))\n\n    # To avoid potential underflow/overflow from direct ratio computation,\n    # the log of the ratio is computed in log space: log10(a/b) = log10(a) - log10(b).\n    # log10(|G|**N_steps) = N_steps * log10(|G|)\n    # log10(exp(lambda*T)) = (lambda*T) / ln(10)\n    \n    log10_cn_mag = num_steps3 * np.log10(np.abs(G_m3))\n    log10_exact_mag = (lambda_m3 * params3['T']) / np.log(10)\n    \n    result3 = log10_cn_mag - log10_exact_mag\n    results.append(result3)\n\n    # =========================================================================\n    # Final Output Formatting\n    # =========================================================================\n    # The format must be exactly [val1,val2,val3] with no extra spaces or text.\n    output_str = f\"[{results[0]},{results[1]},{results[2]}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "环境模型的最终目标是利用观测数据来理解真实世界。本练习将视角从正向模拟（预测结果）转向反演模拟（推断原因）。你将学习如何根据一组浓度观测数据来估算未知的污染源分布，并通过推导和应用吉洪诺夫正则化（Tikhonov regularization）这一关键技术，来解决地球科学中常见的病态反问题（ill-posed inverse problems）。",
            "id": "3883625",
            "problem": "考虑一个稳态环境中的环境逆问题，其中一个标量源场 $S(\\mathbf{x})$ 通过线性正向响应，在一组有限的监测点上产生观测浓度。在 $n$ 个网格单元上进行离散化后，未知源向量为 $\\mathbf{s} \\in \\mathbb{R}^n$，单位为千克/秒 (kg/s)。在 $m$ 个监测点收集观测数据，表示为浓度向量 $\\mathbf{c} \\in \\mathbb{R}^m$，单位为毫克/立方米 (mg/m$^3$)。线性正向算子是矩阵 $\\mathbf{G} \\in \\mathbb{R}^{m \\times n}$，其元素编码了每个监测点对每个网格单元单位源排放的响应；物理上，$\\mathbf{G}$ 的元素单位为 mg m$^{-3}$ / (kg s$^{-1}$)。测量误差被建模为加性、独立、零均值的高斯噪声，其方差已知。这定义了一个对角权重矩阵 $\\mathbf{W} \\in \\mathbb{R}^{m \\times m}$，其元素为 $w_i = 1/\\sigma_i^2$，其中 $\\sigma_i$ 是监测点 $i$ 的标准差，单位为 mg/m$^3$。为了减轻不适定性并编码平滑性或其他约束，通过罚算子 $\\mathbf{L} \\in \\mathbb{R}^{p \\times n}$ 和正则化强度 $\\lambda \\ge 0$ 引入 Tikhonov 正则化。\n\n从以下基本原理出发：\n- 质量守恒和稳态响应的线性特性意味着离散关系 $\\mathbf{c} = \\mathbf{G}\\mathbf{s} + \\boldsymbol{\\epsilon}$，其中 $\\boldsymbol{\\epsilon}$ 是测量误差向量。\n- 在高斯误差模型下，最小化加权最小二乘目标等价于最大似然估计 (MLE)。\n- Tikhonov 正则化对 $\\mathbf{L}\\mathbf{s}$ 施加二次罚项以稳定反演过程。\n\n使用结合了加权数据失配和二次正则化罚项的目标函数，从第一性原理推导确定 $\\mathbf{s}$ 的 Tikhonov 正则化估计量的正规方程。清晰地陈述每个数学步骤和所使用的任何假设。\n\n然后，实现一个程序，针对下面指定的每个测试用例，通过求解推导出的正规方程来计算 Tikhonov 正则化估计值 $\\widehat{\\mathbf{s}}$。所有最终的源强度必须以千克/秒 (kg/s) 为单位报告。每个条目必须四舍五入到六位小数。\n\n使用以下测试套件。在所有情况下，$\\mathbf{L}$ 要么是适当大小的单位矩阵，要么是在一维网格上定义的离散一阶差分算子，定义如下\n$$\n\\mathbf{L}_{\\text{diff}} = \\begin{bmatrix}\n-1  1  0  \\cdots  0 \\\\\n0  -1  1  \\cdots  0 \\\\\n\\vdots    \\ddots  \\vdots \\\\\n0  \\cdots  0  -1  1\n\\end{bmatrix} \\in \\mathbb{R}^{(n-1) \\times n}.\n$$\n对于每个案例，权重矩阵为 $\\mathbf{W} = \\mathrm{diag}(w_1,\\ldots,w_m)$。\n\n- 案例 1 (一般适定且具平滑性):\n  - $n = 3$, $m = 3$.\n  - $\\mathbf{G} = \\begin{bmatrix} 1.0  0.5  0.0 \\\\ 0.2  1.0  0.3 \\\\ 0.0  0.3  0.8 \\end{bmatrix}$.\n  - $\\mathbf{c} = \\begin{bmatrix} 1.5 \\\\ 2.0 \\\\ 1.0 \\end{bmatrix}$ mg/m$^3$.\n  - 测量不确定度: $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0.10 \\\\ 0.20 \\\\ 0.15 \\end{bmatrix}$ mg/m$^3$，因此 $\\mathbf{W} = \\mathrm{diag}(100.0, 25.0, 44.\\overline{4})$。\n  - $\\mathbf{L} = \\mathbf{L}_{\\text{diff}}$ (当 $n=3$ 时)。\n  - $\\lambda = 0.1$.\n\n- 案例 2 (边界情况：无正则化，正向算子可逆):\n  - $n = 4$, $m = 4$.\n  - $\\mathbf{G} = \\mathrm{diag}(2.0, 2.0, 2.0, 2.0) \\text{ mg m}^{-3} / (\\text{kg s}^{-1})$.\n  - $\\mathbf{c} = \\begin{bmatrix} 0.5 \\\\ 0.1 \\\\ 0.0 \\\\ 0.9 \\end{bmatrix}$ mg/m$^3$.\n  - $\\mathbf{W} = \\mathbf{I}_4$.\n  - $\\mathbf{L} = \\mathbf{L}_{\\text{diff}}$ (当 $n=4$ 时，由于 $\\lambda=0$ 它被忽略)。\n  - $\\lambda = 0$.\n\n- 案例 3 (秩亏正向算子，单位罚项):\n  - $n = 3$, $m = 2$.\n  - $\\mathbf{G} = \\begin{bmatrix} 1.0  0.0  0.0 \\\\ 0.0  1.0  0.0 \\end{bmatrix}$.\n  - $\\mathbf{c} = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix}$ mg/m$^3$.\n  - $\\mathbf{W} = \\mathbf{I}_2$.\n  - $\\mathbf{L} = \\mathbf{I}_3$.\n  - $\\lambda = 0.5$.\n\n- 案例 4 (异方差加权，平滑性罚项):\n  - $n = 3$, $m = 3$.\n  - $\\mathbf{G} = \\begin{bmatrix} 1.0  0.2  0.0 \\\\ 0.0  1.5  0.1 \\\\ 0.1  0.0  0.8 \\end{bmatrix}$.\n  - $\\mathbf{c} = \\begin{bmatrix} 0.8 \\\\ 1.2 \\\\ 0.6 \\end{bmatrix}$ mg/m$^3$.\n  - 测量不确定度: $\\boldsymbol{\\sigma} = \\begin{bmatrix} 0.05 \\\\ 0.20 \\\\ 0.10 \\end{bmatrix}$ mg/m$^3$，因此 $\\mathbf{W} = \\mathrm{diag}(400.0, 25.0, 100.0)$。\n  - $\\mathbf{L} = \\mathbf{L}_{\\text{diff}}$ (当 $n=3$ 时)。\n  - $\\lambda = 0.01$.\n\n- 案例 5 (强平滑):\n  - 与案例 1 相同，但 $\\lambda = 100.0$。\n\n您的程序应生成单行输出，其中包含所有五个测试用例的结果，聚合为一个由方括号括起来的逗号分隔列表，其中每个元素本身是另一个方括号括起来的逗号分隔列表，表示估计的源强度（单位：kg/s），四舍五入到六位小数。例如，总体格式应类似于 $[ [\\cdots], [\\cdots], [\\cdots], [\\cdots], [\\cdots] ]$，逗号后没有空格。程序不得读取输入，也不得打印任何附加文本。",
            "solution": "该问题要求推导 Tikhonov 正则化逆问题的正规方程，并随后实现它们以求解未知源向量 $\\mathbf{s}$。推导从问题描述中概述的基本原理开始。\n\n物理系统由线性模型 $\\mathbf{c} = \\mathbf{G}\\mathbf{s} + \\boldsymbol{\\epsilon}$ 描述，其中 $\\mathbf{s} \\in \\mathbb{R}^n$ 是未知源向量，$\\mathbf{c} \\in \\mathbb{R}^m$ 是观测向量，$\\mathbf{G} \\in \\mathbb{R}^{m \\times n}$ 是线性正向算子，$\\boldsymbol{\\epsilon} \\in \\mathbb{R}^m$ 是测量误差。\n\n测量误差被假设为独立的、零均值的、具有已知方差 $\\sigma_i^2$ 的高斯变量。基于此，最大似然估计 (MLE) 原理要求最大化似然函数 $p(\\mathbf{c}|\\mathbf{s})$。对于高斯噪声，这等价于最小化负对数似然，该值与加权残差平方和成正比。这给出了数据失配项 $J_{\\text{misfit}}(\\mathbf{s})$：\n$$ J_{\\text{misfit}}(\\mathbf{s}) = (\\mathbf{G}\\mathbf{s} - \\mathbf{c})^T \\mathbf{W} (\\mathbf{G}\\mathbf{s} - \\mathbf{c}) $$\n此处，$\\mathbf{W} \\in \\mathbb{R}^{m \\times m}$ 是权重矩阵，它是一个对角矩阵，元素为 $w_{ii} = 1/\\sigma_i^2$。该矩阵是误差协方差矩阵的逆矩阵。\n\n为对逆问题进行正则化，将一个罚项 $J_{\\text{reg}}(\\mathbf{s})$ 添加到目标函数中。该项对不符合物理实际（例如，不平滑）的解施加惩罚。Tikhonov 正则化罚项是二次形式的：\n$$ J_{\\text{reg}}(\\mathbf{s}) = \\lambda (\\mathbf{L}\\mathbf{s})^T (\\mathbf{L}\\mathbf{s}) $$\n其中 $\\mathbf{L} \\in \\mathbb{R}^{p \\times n}$ 是正则化算子，$\\lambda \\ge 0$ 是一个标量正则化参数，用于控制数据拟合与罚项之间的权衡。\n\n要最小化的总目标函数 $J(\\mathbf{s})$ 是数据失配项和正则化罚项之和：\n$$ J(\\mathbf{s}) = J_{\\text{misfit}}(\\mathbf{s}) + J_{\\text{reg}}(\\mathbf{s}) = (\\mathbf{G}\\mathbf{s} - \\mathbf{c})^T \\mathbf{W} (\\mathbf{G}\\mathbf{s} - \\mathbf{c}) + \\lambda (\\mathbf{L}\\mathbf{s})^T (\\mathbf{L}\\mathbf{s}) $$\n\n为了找到最小化 $J(\\mathbf{s})$ 的源向量估计值 $\\widehat{\\mathbf{s}}$，我们必须找到使 $J(\\mathbf{s})$ 相对于 $\\mathbf{s}$ 的梯度为零向量的点，即 $\\nabla_{\\mathbf{s}} J(\\mathbf{s}) = \\mathbf{0}$。我们首先展开 $J(\\mathbf{s})$ 的各项：\n$$ (\\mathbf{G}\\mathbf{s} - \\mathbf{c})^T \\mathbf{W} (\\mathbf{G}\\mathbf{s} - \\mathbf{c}) = (\\mathbf{s}^T\\mathbf{G}^T - \\mathbf{c}^T)\\mathbf{W}(\\mathbf{G}\\mathbf{s} - \\mathbf{c}) = \\mathbf{s}^T\\mathbf{G}^T\\mathbf{W}\\mathbf{G}\\mathbf{s} - \\mathbf{s}^T\\mathbf{G}^T\\mathbf{W}\\mathbf{c} - \\mathbf{c}^T\\mathbf{W}\\mathbf{G}\\mathbf{s} + \\mathbf{c}^T\\mathbf{W}\\mathbf{c} $$\n项 $\\mathbf{c}^T\\mathbf{W}\\mathbf{G}\\mathbf{s}$ 是一个标量，因此等于其转置。由于 $\\mathbf{W}$ 是对角矩阵，它是一个对称矩阵，即 $\\mathbf{W}^T = \\mathbf{W}$。这使我们可以写出 $(\\mathbf{c}^T\\mathbf{W}\\mathbf{G}\\mathbf{s})^T = \\mathbf{s}^T\\mathbf{G}^T\\mathbf{W}^T\\mathbf{c} = \\mathbf{s}^T\\mathbf{G}^T\\mathbf{W}\\mathbf{c}$。因此，失配项简化为：\n$$ J_{\\text{misfit}}(\\mathbf{s}) = \\mathbf{s}^T(\\mathbf{G}^T\\mathbf{W}\\mathbf{G})\\mathbf{s} - 2\\mathbf{s}^T(\\mathbf{G}^T\\mathbf{W}\\mathbf{c}) + \\mathbf{c}^T\\mathbf{W}\\mathbf{c} $$\n\n正则化项可以写为：\n$$ J_{\\text{reg}}(\\mathbf{s}) = \\lambda \\mathbf{s}^T\\mathbf{L}^T\\mathbf{L}\\mathbf{s} $$\n\n结合这些表达式，完整的总目标函数为：\n$$ J(\\mathbf{s}) = \\mathbf{s}^T(\\mathbf{G}^T\\mathbf{W}\\mathbf{G} + \\lambda\\mathbf{L}^T\\mathbf{L})\\mathbf{s} - 2\\mathbf{s}^T(\\mathbf{G}^T\\mathbf{W}\\mathbf{c}) + \\mathbf{c}^T\\mathbf{W}\\mathbf{c} $$\n这是关于 $\\mathbf{s}$ 的二次函数。我们使用标准向量微积分恒等式来计算其梯度：对于对称矩阵 $\\mathbf{A}$，有 $\\nabla_{\\mathbf{x}}(\\mathbf{x}^T\\mathbf{A}\\mathbf{x}) = 2\\mathbf{A}\\mathbf{x}$；以及 $\\nabla_{\\mathbf{x}}(\\mathbf{b}^T\\mathbf{x}) = \\mathbf{b}$。矩阵 $(\\mathbf{G}^T\\mathbf{W}\\mathbf{G} + \\lambda\\mathbf{L}^T\\mathbf{L})$ 是对称的。项 $\\mathbf{c}^T\\mathbf{W}\\mathbf{c}$ 相对于 $\\mathbf{s}$ 是常数，因此其梯度为零。$J(\\mathbf{s})$ 的梯度为：\n$$ \\nabla_{\\mathbf{s}} J(\\mathbf{s}) = 2(\\mathbf{G}^T\\mathbf{W}\\mathbf{G} + \\lambda\\mathbf{L}^T\\mathbf{L})\\mathbf{s} - 2(\\mathbf{G}^T\\mathbf{W}\\mathbf{c}) $$\n\n将梯度设为零，即 $\\nabla_{\\mathbf{s}} J(\\widehat{\\mathbf{s}}) = \\mathbf{0}$，得到最优估计值 $\\widehat{\\mathbf{s}}$：\n$$ 2(\\mathbf{G}^T\\mathbf{W}\\mathbf{G} + \\lambda\\mathbf{L}^T\\mathbf{L})\\widehat{\\mathbf{s}} - 2(\\mathbf{G}^T\\mathbf{W}\\mathbf{c}) = \\mathbf{0} $$\n$$ (\\mathbf{G}^T\\mathbf{W}\\mathbf{G} + \\lambda\\mathbf{L}^T\\mathbf{L})\\widehat{\\mathbf{s}} = \\mathbf{G}^T\\mathbf{W}\\mathbf{c} $$\n\n这个最终方程是线性方程组，被称为 Tikhonov 正则化加权最小二乘问题的**正规方程**。通过求解该方程组，可以得到估计的源向量 $\\widehat{\\mathbf{s}}$。如果矩阵 $(\\mathbf{G}^T\\mathbf{W}\\mathbf{G} + \\lambda\\mathbf{L}^T\\mathbf{L})$ 是可逆的，则该系统有唯一解。对于 $\\lambda > 0$，如果 $\\mathbf{G}$ 和 $\\mathbf{L}$ 的零空间仅在原点相交（$\\text{ker}(\\mathbf{G}) \\cap \\text{ker}(\\mathbf{L}) = \\{\\mathbf{0}\\}$），这个条件通常成立，所提供的测试用例均满足此条件。\n\n所提供的 Python 代码实现了此解法。对于每个测试用例，它会构建正规方程的矩阵和向量，并使用 `numpy.linalg.solve` 求解系统以得到 $\\widehat{\\mathbf{s}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Tikhonov regularization problem for all test cases.\n    \"\"\"\n\n    def create_L_diff(n):\n        \"\"\"\n        Creates the discrete first-difference operator L_diff of size (n-1) x n.\n        \"\"\"\n        if n  2:\n            return np.zeros((0, n))\n        p = n - 1\n        L = np.zeros((p, n))\n        rows = np.arange(p)\n        cols1 = np.arange(p)\n        cols2 = np.arange(1, n)\n        L[rows, cols1] = -1.0\n        L[rows, cols2] = 1.0\n        return L\n\n    def solve_tikhonov(G, c, W, L, lam):\n        \"\"\"\n        Solves the Tikhonov-regularized normal equations:\n        (G.T @ W @ G + lam * L.T @ L) @ s = G.T @ W @ c\n        \"\"\"\n        # Ensure c is a column vector (m x 1)\n        c = c.reshape(-1, 1)\n\n        # G is m x n, W is m x m, L is p x n\n        GT = G.T\n        LT = L.T\n\n        # Left-hand side of the normal equations (n x n)\n        LHS = GT @ W @ G + lam * (LT @ L)\n        \n        # Right-hand side of the normal equations (n x 1)\n        RHS = GT @ W @ c\n        \n        # Solve the linear system for s_hat\n        s_hat = np.linalg.solve(LHS, RHS)\n        \n        # Return as a 1D array\n        return s_hat.flatten()\n\n    # Define the test cases from the problem statement.\n    test_cases_data = [\n        {\n            # Case 1\n            \"G\": np.array([[1.0, 0.5, 0.0], [0.2, 1.0, 0.3], [0.0, 0.3, 0.8]]),\n            \"c\": np.array([1.5, 2.0, 1.0]),\n            \"sigma\": np.array([0.10, 0.20, 0.15]),\n            \"L\": create_L_diff(3),\n            \"lam\": 0.1,\n        },\n        {\n            # Case 2\n            \"G\": np.diag([2.0, 2.0, 2.0, 2.0]),\n            \"c\": np.array([0.5, 0.1, 0.0, 0.9]),\n            \"sigma\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"L\": create_L_diff(4),\n            \"lam\": 0.0,\n        },\n        {\n            # Case 3\n            \"G\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"c\": np.array([1.0, 0.5]),\n            \"sigma\": np.array([1.0, 1.0]),\n            \"L\": np.eye(3),\n            \"lam\": 0.5,\n        },\n        {\n            # Case 4\n            \"G\": np.array([[1.0, 0.2, 0.0], [0.0, 1.5, 0.1], [0.1, 0.0, 0.8]]),\n            \"c\": np.array([0.8, 1.2, 0.6]),\n            \"sigma\": np.array([0.05, 0.20, 0.10]),\n            \"L\": create_L_diff(3),\n            \"lam\": 0.01,\n        },\n        {\n            # Case 5 (Same as Case 1 but with lambda = 100.0)\n            \"G\": np.array([[1.0, 0.5, 0.0], [0.2, 1.0, 0.3], [0.0, 0.3, 0.8]]),\n            \"c\": np.array([1.5, 2.0, 1.0]),\n            \"sigma\": np.array([0.10, 0.20, 0.15]),\n            \"L\": create_L_diff(3),\n            \"lam\": 100.0,\n        },\n    ]\n\n    results = []\n    for case_data in test_cases_data:\n        G = case_data[\"G\"]\n        c = case_data[\"c\"]\n        sigma = case_data[\"sigma\"]\n        L = case_data[\"L\"]\n        lam = case_data[\"lam\"]\n\n        # Construct the weight matrix W\n        W = np.diag(1.0 / sigma**2)\n\n        # Solve for the source strengths s_hat\n        s_hat = solve_tikhonov(G, c, W, L, lam)\n        \n        # Format the result vector for this case\n        s_hat_formatted = [f\"{x:.6f}\" for x in s_hat]\n        case_result_str = f\"[{','.join(s_hat_formatted)}]\"\n        results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}