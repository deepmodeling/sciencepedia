{
    "hands_on_practices": [
        {
            "introduction": "数值积分方案并非凭空出现的神秘公式，理解它们的构造是有效应用和开发新方法的第一步。本练习将指导你从第一性原理出发，推导经典的二阶Adams-Bashforth方法。通过对常微分方程（ODE）的右侧函数进行多项式外插并进行精确积分，你将掌握构建多步法的一项核心技术，这对于理解更高级的积分方案至关重要。",
            "id": "3879044",
            "problem": "在一个固定的欧拉网格单元上，扇区平均的大气示踪物浓度 $y(t)$ 满足一个半离散常微分方程 (ODE) $y'(t)=f(t,y(t))$，其通量和源项由平流、扩散和化学作用产生，且物理上是一致的。考虑在大小为 $\\Delta t>0$ 的均匀时间步长上进行显式时间积分，时间层为 $t^{n-1}=t^{n}-\\Delta t$、$t^{n}$ 和 $t^{n+1}=t^{n}+\\Delta t$。假设模型已经计算出 $y^{n-1}$ 和 $y^{n}$，以及相应的右端项值 $f^{n-1}=f(t^{n-1},y^{n-1})$ 和 $f^{n}=f(t^{n},y^{n})$。\n\n从基本原理出发——具体来说，即 Newton–Leibniz 表示法 $y^{n+1}=y^{n}+\\int_{t^{n}}^{t^{n+1}} f(t,y(t))\\,\\mathrm{d}t$——通过在 $[t^{n},t^{n+1}]$ 区间上使用基于 $t^{n-1}$ 和 $t^{n}$ 处数据、关于时间的一阶 Lagrange 插值多项式来近似 $f(t,y(t))$，从而构造一个二阶显式两步多步更新格式。在该步长上对此插值多项式进行精确积分，以获得定义增量的 $f^{n}$ 和 $f^{n-1}$ 的线性组合。对于光滑的 $f$，您的推导必须与保持 $\\Delta t$ 的二阶精度相一致。\n\n报告在一个时间步长内加到 $y^{n}$ 上的增量中，分别乘以 $f^{n}$ 和 $f^{n-1}$ 的系数有序对 $(\\alpha,\\beta)$。将您的最终答案表示为一个包含精确有理数的行矩阵，不要进行舍入。",
            "solution": "用户提供了一个有效的问题陈述。任务是为常微分方程 $y'(t)=f(t,y(t))$ 推导一个二阶显式两步时间积分格式的系数。推导需要从第一性原理出发，从解的积分形式开始，并用一个线性多项式来近似被积函数。\n\n微积分基本定理，也称为 Newton–Leibniz 表示法，指出时间 $t^{n+1}$ 处的解可以通过对导数 $y'(t) = f(t,y(t))$ 积分，用前一时间 $t^n$ 处的解来表示：\n$$y^{n+1} = y^{n} + \\int_{t^{n}}^{t^{n+1}} f(t,y(t))\\,\\mathrm{d}t$$\n问题要求我们使用一个从时间 $t^{n-1}$ 和 $t^n$ 处的已知数据外推的一阶多项式，来近似在区间 $[t^{n}, t^{n+1}]$ 上的被积函数 $f(t,y(t))$。设此多项式为 $P_1(t)$。函数 $f$ 在时间层 $t^{n-1}$ 和 $t^n$ 处的值被给出为 $f^{n-1} = f(t^{n-1}, y^{n-1})$ 和 $f^n = f(t^n, y^n)$。多项式 $P_1(t)$ 必须对这两点进行插值，即 $P_1(t^{n-1}) = f^{n-1}$ 和 $P_1(t^n) = f^n$。\n\n我们使用 Lagrange 基多项式来构造此多项式。对于点 $(t^{n-1}, f^{n-1})$ 和 $(t^n, f^n)$，一阶插值多项式 $P_1(t)$ 由下式给出：\n$$P_1(t) = f^{n-1} L_{n-1}(t) + f^n L_{n}(t)$$\n其中 $L_{n-1}(t)$ 和 $L_{n}(t)$ 是 Lagrange 基多项式：\n$$L_{n-1}(t) = \\frac{t - t^n}{t^{n-1} - t^n} \\quad \\text{和} \\quad L_{n}(t) = \\frac{t - t^{n-1}}{t^n - t^{n-1}}$$\n给定均匀时间步长 $\\Delta t = t^n - t^{n-1} = t^{n+1} - t^n > 0$，我们有 $t^{n-1} - t^n = -\\Delta t$ 和 $t^n - t^{n-1} = \\Delta t$。将这些代入基多项式得到：\n$$L_{n-1}(t) = \\frac{t - t^n}{-\\Delta t} \\quad \\text{和} \\quad L_{n}(t) = \\frac{t - t^{n-1}}{\\Delta t}$$\n因此，插值多项式的显式形式为：\n$$P_1(t) = f^{n-1} \\left( \\frac{t - t^n}{-\\Delta t} \\right) + f^n \\left( \\frac{t - t^{n-1}}{\\Delta t} \\right)$$\n然后通过在积分中用 $P_1(t)$ 替代 $f(t,y(t))$ 来获得数值积分格式：\n$$y^{n+1} \\approx y^n + \\int_{t^{n}}^{t^{n+1}} P_1(t)\\,\\mathrm{d}t$$\n积分项即为增量。我们计算此积分：\n$$\\text{增量} = \\int_{t^{n}}^{t^{n+1}} \\left[ f^n \\left( \\frac{t - t^{n-1}}{\\Delta t} \\right) - f^{n-1} \\left( \\frac{t - t^n}{\\Delta t} \\right) \\right] \\,\\mathrm{d}t$$\n由于 $f^n$ 和 $f^{n-1}$ 相对于积分变量 $t$ 是常数，我们可以写出：\n$$\\text{增量} = \\frac{f^n}{\\Delta t} \\int_{t^{n}}^{t^{n+1}} (t - t^{n-1})\\,\\mathrm{d}t - \\frac{f^{n-1}}{\\Delta t} \\int_{t^{n}}^{t^{n+1}} (t - t^n)\\,\\mathrm{d}t$$\n为了简化积分，我们进行变量替换。令 $s = \\frac{t-t^n}{\\Delta t}$。这意味着 $t = t^n + s\\Delta t$ 且 $\\mathrm{d}t = \\Delta t \\, \\mathrm{d}s$。积分上下限变化如下：当 $t=t^n$ 时，$s=0$；当 $t=t^{n+1}$ 时，$s=1$。同样注意到 $t-t^{n-1} = (t-t^n) + (t^n-t^{n-1}) = s\\Delta t + \\Delta t = (s+1)\\Delta t$。\n\n将此代入积分中：\n第一个积分变为：\n$$\\int_{t^{n}}^{t^{n+1}} (t - t^{n-1})\\,\\mathrm{d}t = \\int_{0}^{1} (s+1)\\Delta t \\cdot (\\Delta t \\, \\mathrm{d}s) = (\\Delta t)^2 \\int_{0}^{1} (s+1)\\,\\mathrm{d}s = (\\Delta t)^2 \\left[ \\frac{s^2}{2} + s \\right]_0^1 = (\\Delta t)^2 \\left( \\frac{1}{2} + 1 \\right) = \\frac{3}{2}(\\Delta t)^2$$\n第二个积分变为：\n$$\\int_{t^{n}}^{t^{n+1}} (t - t^n)\\,\\mathrm{d}t = \\int_{0}^{1} s\\Delta t \\cdot (\\Delta t \\, \\mathrm{d}s) = (\\Delta t)^2 \\int_{0}^{1} s\\,\\mathrm{d}s = (\\Delta t)^2 \\left[ \\frac{s^2}{2} \\right]_0^1 = \\frac{1}{2}(\\Delta t)^2$$\n将这些结果代回增量的表达式中：\n$$\\text{增量} = \\frac{f^n}{\\Delta t} \\left( \\frac{3}{2}(\\Delta t)^2 \\right) - \\frac{f^{n-1}}{\\Delta t} \\left( \\frac{1}{2}(\\Delta t)^2 \\right)$$\n$$\\text{增量} = \\frac{3}{2} f^n \\Delta t - \\frac{1}{2} f^{n-1} \\Delta t = \\Delta t \\left( \\frac{3}{2} f^n - \\frac{1}{2} f^{n-1} \\right)$$\n得到的更新法则为：\n$$y^{n+1} = y^n + \\Delta t \\left( \\frac{3}{2} f^n - \\frac{1}{2} f^{n-1} \\right)$$\n这是二阶 Adams-Bashforth 方法。问题要求给出分别乘以 $f^n$ 和 $f^{n-1}$ 的系数有序对 $(\\alpha, \\beta)$。增量是由 $f^n$ 和 $f^{n-1}$ 的线性组合在时间步长上积分定义的。线性多步法的标准惯例是将时间步长 $\\Delta t$ 因子提出来。括号中的表达式 $\\frac{3}{2} f^n - \\frac{1}{2} f^{n-1}$ 代表了导数在区间 $[t^n, t^{n+1}]$ 上的外推平均值，其系数是无量纲有理数，符合问题输出格式的约束。\n\n因此，在这个定义性的线性组合中，乘以 $f^n$ 和 $f^{n-1}$ 的系数分别是：\n$$\\alpha = \\frac{3}{2}$$\n$$\\beta = -\\frac{1}{2}$$\n有序对为 $(\\alpha, \\beta) = (\\frac{3}{2}, -\\frac{1}{2})$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{3}{2} & -\\frac{1}{2} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在构建了一个数值格式之后，下一个关键步骤是分析其稳定性，因为一个不稳定的格式在实际应用中是无用的。本练习将直接带你探索数值稳定性的核心概念，要求你从头推导最简单显式方法——前向欧拉法——的绝对稳定域。更进一步，你将把这个理论结果应用于一个模型系统，计算其所允许的最大稳定时间步长，这是数值模拟中的一项基本技能。",
            "id": "3879008",
            "problem": "一个由耦合海洋-大气柱在稳定平衡态附近线性化产生的线性半离散扰动模型可写作 $y'(t)=A\\,y(t)$，其中 $y(t)\\in\\mathbb{R}^3$ 且 $A\\in\\mathbb{R}^{3\\times 3}$ 是一个不随时间变化的常数矩阵。矩阵 $A$ 包含了湍流阻尼和旋转波动样动力学的综合效应，并且在 $\\mathbb{C}$ 上可对角化，其特征值为 $\\lambda_1,\\lambda_2,\\lambda_3$。考虑使用显式前向欧拉法以恒定时间步长 $\\Delta t>0$ 来推进求解。\n\n从第一性原理出发，不引用任何预先制表的稳定性结果，通过要求在单步前向欧拉法下没有任何本征模的幅值被放大，来分析其线性稳定性。由此，推导无量纲参数 $z=\\lambda\\,\\Delta t$ 在复平面上使前向欧拉法线性稳定的区域。\n\n现在假设线性算子 $A$ 具有以下特征值（单位为 $\\mathrm{s}^{-1}$）：\n$\\lambda_1=-0.8$，$\\lambda_2=-0.5+1.2\\,\\mathrm{i}$，$\\lambda_3=-1.3-0.4\\,\\mathrm{i}$，其中 $\\mathrm{i}^2=-1$。\n确定最大时间步长 $\\Delta t_{\\max}$（以秒为单位），使得前向欧拉法对所有三个本征模同时保持线性稳定。以秒为单位给出您的最终数值，并四舍五入到四位有效数字，同时假设 $\\Delta t_{\\max}>0$。",
            "solution": "所给问题在科学上是合理的，提法恰当，客观且完整。它代表了将一种数值方法应用于常微分方程组（ODEs）的标准线性稳定性分析。因此，我将开始解答。\n\n该问题要求得到两个主要结果：首先，推导前向欧拉法的线性稳定性区域；其次，计算一个特定系统的最大稳定时间步长。\n\n控制线性常微分方程组由下式给出：\n$$\ny'(t) = A y(t)\n$$\n其中 $y(t) \\in \\mathbb{R}^3$ 且 $A \\in \\mathbb{R}^{3\\times3}$ 是一个常数矩阵。\n应用时间步长为 $\\Delta t > 0$ 的显式前向欧拉法，我们对该方程进行离散化。时间步 $n+1$ 处的解值（记为 $y_{n+1}$）使用时间步 $n$ 处的值（记为 $y_n$）来近似：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = A y_n\n$$\n重新整理该式，得到前向欧拉格式的更新规则：\n$$\ny_{n+1} = y_n + \\Delta t A y_n = (I + \\Delta t A) y_n\n$$\n此处，$I$ 是单位矩阵。矩阵 $G = I + \\Delta t A$ 被称为放大矩阵，因为它将解从一个时间步映射到下一个时间步。\n\n为分析该方法的稳定性，我们考察它对系统本征模的影响。问题中指出 $A$ 是可对角化的，因此存在一个可逆矩阵 $P$（其列是 $A$ 的特征向量）和一个对角矩阵 $\\Lambda$（其对角线元素是 $A$ 的特征值 $\\lambda_j$），使得 $A = P \\Lambda P^{-1}$。\n我们可以将解向量 $y_n$ 在特征向量基中表示为：$y_n = P c_n$，其中 $c_n$ 是在时间步 $n$ 的本征模系数向量。将此代入欧拉更新规则：\n$$\nP c_{n+1} = (I + \\Delta t A) P c_n = (I + \\Delta t P \\Lambda P^{-1}) P c_n\n$$\n利用性质 $P P^{-1} = I$，我们可以将 $I$ 写为 $I = P I P^{-1}$。\n$$\nP c_{n+1} = (P I P^{-1} + \\Delta t P \\Lambda P^{-1}) P c_n = P (I + \\Delta t \\Lambda) P^{-1} P c_n = P (I + \\Delta t \\Lambda) c_n\n$$\n从左侧乘以 $P^{-1}$，得到关于系数 $c_n$ 的解耦系统：\n$$\nc_{n+1} = (I + \\Delta t \\Lambda) c_n\n$$\n由于 $\\Lambda$ 是对角矩阵，这表示对每个单独的本征模系数 $c_{j,n}$ 的一组标量方程：\n$$\nc_{j, n+1} = (1 + \\lambda_j \\Delta t) c_{j, n}\n$$\n项 $g_j = 1 + \\lambda_j \\Delta t$ 是第 $j$ 个本征模的标量放大因子。线性稳定性要求从一个步长到下一个步长，本征模的幅值不被放大。这意味着放大因子的模不得超过1：\n$$\n|g_j| \\le 1 \\quad \\implies \\quad |1 + \\lambda_j \\Delta t| \\le 1 \\quad \\text{for all } j\n$$\n问题的第一部分要求得到无量纲参数 $z = \\lambda \\Delta t$ 在复平面上的稳定区域。将其代入稳定性条件得到：\n$$\n|1 + z| \\le 1\n$$\n为了描述这个区域，我们设 $z = x + \\mathrm{i}y$，其中 $x$ 和 $y$ 分别是 $z$ 的实部和虚部。\n$$\n|1 + (x + \\mathrm{i}y)| \\le 1 \\quad \\implies \\quad |(1+x) + \\mathrm{i}y| \\le 1\n$$\n复数 $a+\\mathrm{i}b$ 的模是 $\\sqrt{a^2+b^2}$。因此：\n$$\n\\sqrt{(1+x)^2 + y^2} \\le 1\n$$\n对两边进行平方（这是允许的，因为两边都是非负的）得到：\n$$\n(1+x)^2 + y^2 \\le 1^2\n$$\n这个不等式描述了复平面上所有位于以点 $(-1, 0)$ 为中心、半径为 1 的圆上或圆内的点 $(x, y)$ 的集合。这个闭圆盘就是前向欧拉法的绝对稳定区域。\n\n问题的第二部分是找到使该方法对给定的特征值集合 $\\lambda_1 = -0.8$、$\\lambda_2 = -0.5 + 1.2\\,\\mathrm{i}$ 和 $\\lambda_3 = -1.3 - 0.4\\,\\mathrm{i}$（单位均为 $\\mathrm{s}^{-1}$）保持稳定的最大时间步长 $\\Delta t_{\\max}$。\n为了使数值格式稳定，条件 $|1 + \\lambda_j \\Delta t| \\le 1$ 必须对所有三个特征值同时成立。\n让我们分析一个一般复特征值 $\\lambda = \\alpha + \\mathrm{i}\\beta$ 的情况。参数 $z$ 为 $z = \\lambda \\Delta t = (\\alpha + \\mathrm{i}\\beta)\\Delta t = \\alpha\\Delta t + \\mathrm{i}\\beta\\Delta t$。所以 $x = \\alpha\\Delta t$ 且 $y = \\beta\\Delta t$。代入稳定性不等式：\n$$\n(1 + \\alpha \\Delta t)^2 + (\\beta \\Delta t)^2 \\le 1\n$$\n$$\n1 + 2\\alpha\\Delta t + \\alpha^2 (\\Delta t)^2 + \\beta^2 (\\Delta t)^2 \\le 1\n$$\n$$\n2\\alpha\\Delta t + (\\alpha^2 + \\beta^2)(\\Delta t)^2 \\le 0\n$$\n由于 $\\Delta t > 0$，我们可以用 $\\Delta t$ 除以该不等式：\n$$\n2\\alpha + (\\alpha^2 + \\beta^2)\\Delta t \\le 0\n$$\n原始物理系统被描述为处于稳定平衡态，这意味着所有特征值的实部都是负数或零，即 $\\alpha = \\mathrm{Re}(\\lambda) \\le 0$。给定的特征值都满足 $\\alpha < 0$。我们可以重新整理不等式来求解 $\\Delta t$：\n$$\n(\\alpha^2 + \\beta^2)\\Delta t \\le -2\\alpha\n$$\n由于对于非零特征值有 $\\alpha^2 + \\beta^2 = |\\lambda|^2 > 0$，我们可以用它来除：\n$$\n\\Delta t \\le \\frac{-2\\alpha}{\\alpha^2 + \\beta^2} = \\frac{-2\\mathrm{Re}(\\lambda)}{|\\lambda|^2}\n$$\n这个不等式必须对每个特征值都成立。为确保整个系统的稳定性，$\\Delta t$ 必须小于或等于每个特征值所施加的上限中的最小值。因此，最大稳定时间步长为：\n$$\n\\Delta t_{\\max} = \\min_{j=1,2,3} \\left( \\frac{-2\\mathrm{Re}(\\lambda_j)}{|\\lambda_j|^2} \\right)\n$$\n我们现在为给定的三个特征值分别计算这个值。\n\n对于 $\\lambda_1 = -0.8$：\n$\\mathrm{Re}(\\lambda_1) = -0.8$ 且 $|\\lambda_1|^2 = (-0.8)^2 + 0^2 = 0.64$。\n约束条件是 $\\Delta t \\le \\frac{-2(-0.8)}{0.64} = \\frac{1.6}{0.64} = 2.5$。因此，$\\Delta t_1 = 2.5 \\, \\mathrm{s}$。\n\n对于 $\\lambda_2 = -0.5 + 1.2\\,\\mathrm{i}$：\n$\\mathrm{Re}(\\lambda_2) = -0.5$ 且 $|\\lambda_2|^2 = (-0.5)^2 + (1.2)^2 = 0.25 + 1.44 = 1.69$。\n约束条件是 $\\Delta t \\le \\frac{-2(-0.5)}{1.69} = \\frac{1}{1.69}$。因此，$\\Delta t_2 = \\frac{1}{1.69} \\, \\mathrm{s}$。\n\n对于 $\\lambda_3 = -1.3 - 0.4\\,\\mathrm{i}$：\n$\\mathrm{Re}(\\lambda_3) = -1.3$ 且 $|\\lambda_3|^2 = (-1.3)^2 + (-0.4)^2 = 1.69 + 0.16 = 1.85$。\n约束条件是 $\\Delta t \\le \\frac{-2(-1.3)}{1.85} = \\frac{2.6}{1.85}$。因此，$\\Delta t_3 = \\frac{2.6}{1.85} \\, \\mathrm{s}$。\n\n我们必须找到这三个值中的最小值来确定 $\\Delta t_{\\max}$：\n$\\Delta t_1 = 2.5$\n$\\Delta t_2 = \\frac{1}{1.69} \\approx 0.5917159...$\n$\\Delta t_3 = \\frac{2.6}{1.85} \\approx 1.4054054...$\n最小值为 $\\Delta t_2 = \\frac{1}{1.69}$。\n因此，$\\Delta t_{\\max} = \\frac{1}{1.69} \\, \\mathrm{s}$。\n\n问题要求一个四舍五入到四位有效数字的数值。\n$$\n\\Delta t_{\\max} = \\frac{1}{1.69} \\, \\mathrm{s} \\approx 0.591715976... \\, \\mathrm{s}\n$$\n四舍五入到四位有效数字得到 $0.5917 \\, \\mathrm{s}$。",
            "answer": "$$\n\\boxed{0.5917}\n$$"
        },
        {
            "introduction": "线性稳定性是保证数值方法有效性的必要条件，但它是否就是全部呢？对于环境模型中常见的示踪剂平流等问题，我们还关心解的物理特性，例如保持正定性（浓度不能为负）。本编程练习旨在揭示一个更精细但至关重要的性质：强稳定保持（SSP）。通过对比经典的四阶龙格-库塔法（RK4）和三阶强稳定保持龙格-库塔法（SSPRK3），你将亲眼见证非SSP格式如何即便在线性稳定条件下也会产生非物理的伪振荡，从而深刻理解SSP方法在求解双曲型守恒律时的优越性。",
            "id": "3879058",
            "problem": "考虑由偏微分方程 (PDE) 控制的被动示踪剂的一维标量线性平流：$$\\frac{\\partial q(x,t)}{\\partial t} + a \\frac{\\partial q(x,t)}{\\partial x} = 0,$$ 其中 $q(x,t)$ 是无量纲示踪剂浓度，$x \\in [0,1]$ 是周期性域上的无量纲空间坐标，$t \\ge 0$ 是无量纲时间，$a > 0$ 是一个常数无量纲平流速度，设为 $a=1$。使用方法线法，对 $a > 0$ 的情况采用一阶迎风空间通量对该 PDE 进行离散化，得到一个半离散系统：$$\\frac{d q_i(t)}{dt} = -\\frac{a}{\\Delta x} \\left(q_i(t) - q_{i-1}(t)\\right),$$ 对于网格索引 $i = 0,1,\\dots,N-1$，并采用周期性环绕 $q_{-1} \\equiv q_{N-1}$，其中 $\\Delta x = 1/N$。将库朗数记为 $$\\lambda = \\frac{a \\Delta t}{\\Delta x},$$ 其中 $\\Delta t$ 是时间步长。对于欧拉前向时间步进，相应的全离散更新为 $$q_i^{n+1} = (1 - \\lambda)\\, q_i^n + \\lambda\\, q_{i-1}^n.$$ 在强稳定性保持 (SSP) 时间积分的背景下，如果一个显式龙格-库塔 (RK) 方法的每个完整步长都可以写成应用于相同半离散算子的欧拉前向步长的凸组合，那么该方法就被称为 SSP 方法。这确保了在与欧拉前向方法相同的时间步长限制下（至多相差一个常数因子），能够保持正定性保持和总变差递减 (TVD) 等性质。一个非 SSP 的显式 RK 方法不满足此凸性要求，并且可能产生伪振荡，包括下冲和过冲，即使当半离散算子是单调的且库朗数在欧拉前向方法的稳定性边界内时也是如此。\n\n您的任务是构建并分析一个无量纲数值实验，该实验通过违反凸性约束来演示非 SSP 显式 RK 方法如何在示踪剂平流中引起伪振荡。请按以下步骤进行：\n\n- 在周期性域上将示踪剂初始化为分段常数阶跃剖面：$$q(x,0) = \\begin{cases} 1, & x \\in [0.1,\\,0.4], \\\\ 0, & \\text{otherwise.} \\end{cases}$$ 在 $N$ 个等距点上离散化此初始条件，其中 $N \\ge 100$。\n\n- 完全按照上面所示，为 $a = 1$ 实现带有周期性边界条件的半离散迎风算子。\n\n- 实现三种显式时间积分器：\n  1. 欧拉前向 (FE) 方法，如上式所示。已知该方法在 $\\lambda \\le 1$ 时是单调的，因此可作为对照组。\n  2. 强稳定性保持三阶龙格-库塔方法 (SSPRK$3$)，也称为 Shu–Osher RK$3$，当 $\\lambda \\le 1$ 时，其各个阶段可以写成欧拉前向步长的凸组合。\n  3. 经典四阶显式龙格-库塔方法 (RK$4$)，它不是强稳定性保持的。\n\n- 使用每种积分器将系统演化到最终无量纲时间 $T$。使用在最终时间计算的以下指标来量化伪振荡：\n  1. 下冲幅度：$$U = \\max\\left(0,\\, -\\min_i q_i(T)\\right).$$\n  2. 过冲幅度：$$V = \\max\\left(0,\\, \\max_i q_i(T) - 1\\right).$$\n  3. 总变差增量：$$\\Delta \\mathrm{TV} = \\max\\left(0,\\, \\mathrm{TV}(q(T)) - \\mathrm{TV}(q(0))\\right),$$ 其中 $$\\mathrm{TV}(q) = \\sum_{i=0}^{N-1} \\left|q_{i+1} - q_i\\right|,$$ 其中采用周期性环绕 $q_N \\equiv q_0$。\n\n- 根据凸性约束，解释为什么 SSPRK$3$ 和欧拉前向方法在 $\\lambda \\le 1$ 时能避免伪振荡，而 RK$4$ 即使在较小的 $\\lambda$ 值下也可能产生伪振荡。\n\n设计一套参数值测试组，以检验不同的机制和边界情况。全过程使用无量纲量，因此不需要物理单位。该测试组必须包含以下案例：\n- 案例 1：方法 = SSPRK$3$, $\\lambda = 0.95$, $N = 200$, $T = 0.5$。\n- 案例 2：方法 = RK$4$, $\\lambda = 0.95$, $N = 200$, $T = 0.5$。\n- 案例 3：方法 = RK$4$, $\\lambda = 0.20$, $N = 200$, $T = 0.5$。\n- 案例 4：方法 = 欧拉前向, $\\lambda = 0.95$, $N = 200$, $T = 0.5$。\n- 案例 5：方法 = SSPRK$3$, $\\lambda = 1.00$, $N = 200$, $T = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例的结果本身都是一个按 $[U, V, \\Delta \\mathrm{TV}]$ 顺序排列的包含三个浮点数的列表。对于以上所有五个案例，最终输出格式必须严格遵循\n$$\\bigl[\\,[U_1, V_1, \\Delta \\mathrm{TV}_1],\\, [U_2, V_2, \\Delta \\mathrm{TV}_2],\\, [U_3, V_3, \\Delta \\mathrm{TV}_3],\\, [U_4, V_4, \\Delta \\mathrm{TV}_4],\\, [U_5, V_5, \\Delta \\mathrm{TV}_5]\\,\\bigr].$$",
            "solution": "该问题要求演示和解释当非强稳定性保持 (non-SSP) 时间积分格式应用于双曲守恒律时所产生的伪振荡。我们将分析三种显式时间积分器——欧拉前向 (FE) 方法、三阶强稳定性保持龙格-库塔方法 (SSPRK$3$) 和经典四阶龙格-库塔方法 (RK$4$)——在一维线性平流方程上的行为。\n\n控制偏微分方程 (PDE) 是被动示踪剂浓度 `$q(x,t)$` 的线性平流方程：\n$$\n\\frac{\\partial q(x,t)}{\\partial t} + a \\frac{\\partial q(x,t)}{\\partial x} = 0\n$$\n该方程定义在周期性空间域 `$x \\in [0,1]$` 上，时间 `$t \\ge 0$`。平流速度是一个正常数，设为 `$a = 1$`。\n\n我们使用方法线法，首先在空间上进行离散化。空间域被离散化为 `$N$` 个宽度为 `$\\Delta x = 1/N$` 的均匀网格单元。示踪剂浓度 `$q(x,t)$` 由其在网格点上的值 `$q_i(t)$` 表示，其中 `$i = 0, 1, \\dots, N-1$`。对空间导数 `$\\partial q/\\partial x$` 使用一阶迎风格式（适用于 `$a > 0$`），我们得到常微分方程 (ODE) 的半离散系统：\n$$\n\\frac{d q_i(t)}{dt} = -\\frac{a}{\\Delta x} \\left(q_i(t) - q_{i-1}(t)\\right) \\equiv \\mathcal{L}(q)_i\n$$\n这里，`$\\mathcal{L}$` 表示半离散空间算子。边界条件是周期性的，因此索引 `$i-1$` 通过环绕处理，即 `$q_{-1} \\equiv q_{N-1}$`。然后使用显式时间积分格式求解该 ODE 系统。\n\n问题的核心在于所选时间积分器的性质。关键概念是强稳定性保持 (SSP)。该性质将高阶龙格-库塔方法的稳定性与简单的欧拉前向方法的稳定性联系起来。\n\n将欧拉前向 (FE) 方法应用于半离散系统，得到全离散更新规则：\n$$\nq_i^{n+1} = q_i^n + \\Delta t \\, \\mathcal{L}(q^n)_i = q_i^n - \\frac{a \\Delta t}{\\Delta x} (q_i^n - q_{i-1}^n)\n$$\n定义库朗数 `$\\lambda = a \\Delta t / \\Delta x$`，FE 更新可以写成：\n$$\nq_i^{n+1} = (1 - \\lambda) q_i^n + \\lambda q_{i-1}^n\n$$\n这个更新将新值 `$q_i^{n+1}$` 表示为前一时间步值的线性组合。要使此组合成为**凸组合**，其系数必须为非负且总和为 `$1$`。总和为 `$(1-\\lambda) + \\lambda = 1$`。非负性条件要求 `$1-\\lambda \\ge 0$` 和 `$\\lambda \\ge 0$`。由于 `$a, \\Delta t, \\Delta x$` 均为正数，`$\\lambda \\ge 0$` 得到满足，因此关键条件是 `$\\lambda \\le 1$`。\n\n当 `$0 \\le \\lambda \\le 1$` 时，FE 步长是一个凸组合。凸组合的一个基本性质是它们不能产生超出输入值范围的值。如果对所有 `$j$` 都有 `$\\min(q^n) \\le q_j^n \\le \\max(q^n)$`，那么 `$\\min(q^n) \\le q_i^{n+1} \\le \\max(q^n)$`。这保证了不会产生新的极值（伪振荡）。该性质也称为单调性或正定性保持。对于给定的初始条件 `$q(x,0) \\in [0,1]$`，采用 `$\\lambda \\le 1$` 的 FE 格式可确保对所有 `$n$` 和 `$i$` 都有 `$q_i^n \\in [0,1]$`。这也意味着解的总变差 (TV) `$\\mathrm{TV}(q) = \\sum_i |q_{i+1} - q_i|$` 不会增加，即 `$\\mathrm{TV}(q^{n+1}) \\le \\mathrm{TV}(q^n)$`。\n\n如果一个显式龙格-库塔方法的完整时间步可以写成欧拉前向步长的凸组合，则该方法被定义为**强稳定性保持 (SSP)** 方法。SSPRK$3$ 方法 (Shu-Osher) 就是为此性质设计的。其分步形式为：\n\\begin{align*}\nq^{(1)} = q^n + \\Delta t \\mathcal{L}(q^n) \\\\\nq^{(2)} = \\frac{3}{4}q^n + \\frac{1}{4}\\left(q^{(1)} + \\Delta t \\mathcal{L}(q^{(1)})\\right) \\\\\nq^{n+1} = \\frac{1}{3}q^n + \\frac{2}{3}\\left(q^{(2)} + \\Delta t \\mathcal{L}(q^{(2)})\\right)\n\\end{align*}\n每个阶段都是前一个状态与应用于前一个状态的欧拉前向步长的凸组合。如果欧拉前向步长是单调的（对于 `$\\lambda \\le 1$` 确实如此），并且每个阶段都是一个凸组合，那么整个 SSPRK$3$ 步长就继承了单调性。在与欧拉前向方法相同的时间步长限制下，即 `$\\lambda \\le 1$`，SSPRK$3$ 方法是 TVD 的。因此，与 FE 一样，对于给定的问题，它不应产生伪振荡、下冲或过冲。\n\n相比之下，经典四阶龙格-库塔 (RK$4$) 方法**不是** SSP 方法。其更新公式为：\n\\begin{align*}\nk_1 = \\Delta t \\mathcal{L}(q^n) \\\\\nk_2 = \\Delta t \\mathcal{L}(q^n + \\frac{1}{2}k_1) \\\\\nk_3 = \\Delta t \\mathcal{L}(q^n + \\frac{1}{2}k_2) \\\\\nk_4 = \\Delta t \\mathcal{L}(q^n + k_3) \\\\\nq^{n+1} = q^n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n该公式不能表示为欧拉前向步长的凸组合。其内部阶段和最终的重组不保证保持单调性。当以规范的 Shu-Osher 形式书写时，凸组合中的某些系数为负。负系数的存在意味着该格式可能产生超出前一步数据范围的值，从而导致新极小值和极大值的产生。这表现为伪振荡，例如低于 `$0$` 的下冲和高于 `$1$` 的过冲。即使当库朗数 `$\\lambda$` 远在 RK$4$ 格式的线性稳定性极限内（对于此问题，`$\\lambda \\approx 2.785$`）时，这种情况也可能发生。通过使用 `$\\lambda \\le 1$`，本数值实验旨在将这种凸性失效与线性不稳定性分离开来。\n\n数值实验设置如下：初始条件是一个阶跃函数：`$q(x,0) = 1$` 对于 `$x \\in [0.1, 0.4]$`，其他情况为 `$0$`。该剖面在一个包含 `$N=200$` 个点的网格上被离散化。系统演化至最终时间 `$T=0.5$`。当 `$a=1$` 时，精确解是初始剖面向右平移 `$0.5$` 个单位，成为在 `$[0.6, 0.9]$` 上的一个阶跃函数。我们将比较来自 FE、SSPRK$3$ 和 RK$4$ 在不同库朗数 `$\\lambda$` 下的数值解。我们使用在 `$t=T$` 时评估的三个指标来量化伪振荡：\n1.  下冲幅度：`$U = \\max(0, -\\min_i q_i(T))$`。任何低于 `$0$` 的值都会对 `$U$` 产生贡献。\n2.  过冲幅度：`$V = \\max(0, \\max_i q_i(T) - 1)$`。任何高于 `$1$` 的值都会对 `$V$` 产生贡献。\n3.  总变差增量：`$\\Delta \\mathrm{TV} = \\max(0, \\mathrm{TV}(q(T)) - \\mathrm{TV}(q(0)))$`。总变差的增加意味着新局部极值的产生。\n\n算法的流程是首先初始化网格和示踪剂剖面。对于每个测试案例，它根据给定的 `$\\lambda$`、`$N$` 和 `$a$` 计算时间步长 `$\\Delta t$`。然后，它迭代所选的时间步进格式，执行达到 `$T$` 所需的步数。最后，它计算并记录指标 `$U$`、`$V$` 和 `$\\Delta \\mathrm{TV}$`。测试案例的结果预计将证实理论分析：对于 `$\\lambda \\le 1$`，FE 和 SSPRK$3$ 应产生等于 `$0$` 的 `$U, V, \\Delta \\mathrm{TV}$`，而 RK$4$ 应为这些指标产生非零值，表明存在伪振荡。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection problem using different time integrators\n    to demonstrate the properties of Strong Stability Preserving (SSP) methods.\n    \"\"\"\n\n    test_cases = [\n        {'method': 'SSPRK3', 'lambda': 0.95, 'N': 200, 'T': 0.5},\n        {'method': 'RK4', 'lambda': 0.95, 'N': 200, 'T': 0.5},\n        {'method': 'RK4', 'lambda': 0.20, 'N': 200, 'T': 0.5},\n        {'method': 'Forward Euler', 'lambda': 0.95, 'N': 200, 'T': 0.5},\n        {'method': 'SSPRK3', 'lambda': 1.00, 'N': 200, 'T': 0.5},\n    ]\n\n    results = []\n\n    def L(q, a, dx):\n        \"\"\"\n        Computes the semi-discrete spatial operator L(q) for 1st-order upwind.\n        L(q)_i = -a/dx * (q_i - q_{i-1})\n        \"\"\"\n        q_prev = np.roll(q, 1)\n        return -a / dx * (q - q_prev)\n\n    def fe_step(q, dt, a, dx):\n        \"\"\"A single Forward Euler step.\"\"\"\n        return q + dt * L(q, a, dx)\n\n    def ssp_rk3_step(q, dt, a, dx):\n        \"\"\"A single SSPRK3 (Shu-Osher) step.\"\"\"\n        q1 = q + dt * L(q, a, dx)\n        q2 = 0.75 * q + 0.25 * (q1 + dt * L(q1, a, dx))\n        q_new = (1./3.) * q + (2./3.) * (q2 + dt * L(q2, a, dx))\n        return q_new\n\n    def rk4_step(q, dt, a, dx):\n        \"\"\"A single classical RK4 step.\"\"\"\n        k1 = dt * L(q, a, dx)\n        k2 = dt * L(q + 0.5 * k1, a, dx)\n        k3 = dt * L(q + 0.5 * k2, a, dx)\n        k4 = dt * L(q + k3, a, dx)\n        return q + (1./6.) * (k1 + 2*k2 + 2*k3 + k4)\n\n    def tv(q):\n        \"\"\"Computes the total variation of a periodic array q.\"\"\"\n        # |q_{i+1} - q_i| summed over all i, with q_N = q_0.\n        # np.roll(q, -1) gives q_{i+1} at index i.\n        return np.sum(np.abs(np.roll(q, -1) - q))\n\n    integrators = {\n        'Forward Euler': fe_step,\n        'SSPRK3': ssp_rk3_step,\n        'RK4': rk4_step,\n    }\n\n    for case in test_cases:\n        N = case['N']\n        T = case['T']\n        lam = case['lambda']\n        method_name = case['method']\n\n        a = 1.0\n        dx = 1.0 / N\n        dt = lam * dx / a\n\n        x = np.linspace(0.0, 1.0, N, endpoint=False)\n        q0 = np.zeros(N)\n        q0[(x >= 0.1)  (x = 0.4)] = 1.0\n\n        q = q0.copy()\n        \n        tv0 = tv(q0)\n\n        num_steps = int(np.ceil(T / dt))\n        integrator = integrators[method_name]\n        \n        for _ in range(num_steps):\n            q = integrator(q, dt, a, dx)\n\n        # Ensure final time is exactly T if dt doesn't divide T\n        # This is a minor correction but good practice for precise comparison.\n        # However, the problem implies a fixed number of steps.\n        # We will stick to the specified logic of `ceil(T/dt)` steps.\n        # The problem is nondimensional and cares about the behavior of the scheme,\n        # slight variations in final time across methods are acceptable.\n\n        q_final = q\n\n        undershoot = np.maximum(0.0, -np.min(q_final))\n        overshoot = np.maximum(0.0, np.max(q_final) - 1.0)\n        \n        tv_final = tv(q_final)\n        delta_tv = np.maximum(0.0, tv_final - tv0)\n\n        results.append([undershoot, overshoot, delta_tv])\n    \n    # Format the final output string exactly as specified.\n    # The str() representation of a list is `[item1, item2, ...]`.\n    # Joining these with commas and enclosing in brackets gives the desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}