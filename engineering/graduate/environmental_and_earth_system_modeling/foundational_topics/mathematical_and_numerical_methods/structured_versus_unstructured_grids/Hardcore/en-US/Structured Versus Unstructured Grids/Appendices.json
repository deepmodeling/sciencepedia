{
    "hands_on_practices": [
        {
            "introduction": "The choice between a structured and unstructured grid has profound implications for a model's performance, starting with the fundamental task of identifying a cell's neighbors. This exercise explores the computational and data structure differences between implicit, index-based neighbor finding on structured grids and explicit, adjacency-list-based methods on unstructured grids. By implementing and comparing these approaches, you will quantify a key performance trade-off governed by mesh connectivity, providing a practical foundation for understanding algorithm complexity in numerical modeling .",
            "id": "3918718",
            "problem": "You are tasked with designing and analyzing an efficient neighbor search data structure for unstructured meshes and comparing its access complexity against direct index-based neighbor queries on structured grids, in the context of environmental and earth system modeling. The goal is to articulate the mathematical basis of the design and to implement a program that quantifies the practical consequences of the differing data structures via well-defined metrics.\n\nConsider two mesh types:\n- A structured two-dimensional grid with $N_x$ columns and $N_y$ rows and a $4$-neighborhood (North, South, East, West) for interior nodes.\n- An unstructured two-dimensional mesh formed by triangulation of a point set in the plane.\n\nDefinitions and fundamental bases:\n- A mesh can be represented as a graph where vertices are mesh points and edges connect neighboring points. The neighbor set of a vertex $v$ is denoted $\\mathcal{N}(v)$.\n- In a structured grid, each vertex can be indexed by integer coordinates $(i,j)$ with $0 \\le i \\lt N_x$ and $0 \\le j \\lt N_y$. Direct neighbor derivation is performed via index arithmetic on $(i,j)$ and boundary checks.\n- In an unstructured mesh, a common storage format for adjacency is Compressed Sparse Row (CSR), consisting of an integer array $row\\_ptr$ of length $N+1$ and an integer array $col\\_idx$ of length equal to the number of adjacency entries. For a vertex $v$, its neighbors occupy the slice $col\\_idx[row\\_ptr[v]:row\\_ptr[v+1]]$. A coordinate index is a map from spatial coordinates to vertex indices, used to locate vertices by position in expected constant time.\n\nThe program must:\n1. Construct for each test case both a structured grid and an unstructured mesh. For the unstructured mesh, perform a planar triangulation of the given point set and build the CSR neighbor structure. For the structured grid, base neighbor access on index arithmetic.\n2. Compute the average neighbor count $\\overline{d}$ in each mesh type. For the structured grid with $N_x \\ge 2$ and $N_y \\ge 2$, the average degree is\n$$\n\\overline{d}_{\\text{struct}} = \\frac{1}{N_x N_y} \\Big(2 \\cdot 4 + 3 \\cdot \\left[2(N_x-2) + 2(N_y-2)\\right] + 4 \\cdot (N_x-2)(N_y-2)\\Big) = 4 - \\frac{2}{N_x} - \\frac{2}{N_y}.\n$$\nFor degenerate dimensions, use chain formulas: if $N_x = 1, N_y \\ge 2$, then $\\overline{d}_{\\text{struct}} = 2 - \\frac{2}{N_y}$; if $N_y = 1, N_x \\ge 2$, then $\\overline{d}_{\\text{struct}} = 2 - \\frac{2}{N_x}$; and $\\overline{d}_{\\text{struct}} = 0$ if $N_x = N_y = 1$.\n3. Compute the average degree $\\overline{d}_{\\text{unstruct}}$ of the unstructured mesh from the CSR adjacency. For a triangulation with $N$ vertices and no holes, the edge count $E$ satisfies $E = 3N - 3 - h$, where $h$ is the number of vertices on the convex hull. Consequently, the average degree satisfies\n$$\n\\overline{d}_{\\text{unstruct}} = \\frac{2E}{N} = 6 - \\frac{6 + 2h}{N},\n$$\nwhich approaches $6$ as $N$ grows when $h$ grows sublinearly. The program must compute $\\overline{d}_{\\text{unstruct}}$ empirically from CSR and may also compute $h$ to verify the planar bound.\n4. Define a cost model for the neighbor queries:\n   - Structured grid direct index-based access: computing the neighbor list of a vertex has cost proportional to its degree $|\\mathcal{N}(v)|$, since each neighbor index is derived by constant-time arithmetic with a constant number of boundary checks per neighbor.\n   - Unstructured mesh CSR access: computing the neighbor list of a vertex has cost $O(1 + |\\mathcal{N}(v)|)$ due to fetching the two pointers in $row\\_ptr$ and then scanning the neighbor slice in $col\\_idx$.\n   Therefore, the asymptotic cost per vertex for listing all neighbors in both cases is $O(|\\mathcal{N}(v)|)$, with a constant-factor difference owing to CSR pointer access. The ratio of average costs across the graph is approximated by the ratio of average degrees $\\overline{d}_{\\text{unstruct}} / \\overline{d}_{\\text{struct}}$.\n5. For each test case, compute and output the tuple of three floats:\n   - The structured grid average degree $\\overline{d}_{\\text{struct}}$.\n   - The unstructured mesh average degree $\\overline{d}_{\\text{unstruct}}$.\n   - The ratio $r = \\overline{d}_{\\text{unstruct}} / \\overline{d}_{\\text{struct}}$.\n\nTest suite:\n- Test Case A (general case): $N_x = 50$, $N_y = 50$, and an unstructured mesh built from $N = 2500$ points sampled uniformly from $[0,1]^2$ with a fixed random seed $42$.\n- Test Case B (boundary small grid): $N_x = 2$, $N_y = 2$, and an unstructured mesh built from $N = 4$ points sampled uniformly from $[0,1]^2$ with seed $7$.\n- Test Case C (anisotropic edge case): $N_x = 100$, $N_y = 1$, and an unstructured mesh built from $N = 100$ points with $x$ sampled uniformly from $[0,1]$ and $y$ sampled as small zero-mean noise $y \\sim \\mathcal{N}(0, \\sigma^2)$ with $\\sigma = 10^{-3}$, using seed $123$.\n\nYour program must produce a single line of output containing the results as a comma-separated list of the three test case results, each itself a list of three floats in the order specified above, rounded to six decimal places, e.g.,\n\"[[d_struct_A,d_unstruct_A,ratio_A],[d_struct_B,d_unstruct_B,ratio_B],[d_struct_C,d_unstruct_C,ratio_C]]\".\n\nAll computed values are dimensionless; do not include any physical units. Angles are not used. No percentages are used anywhere; all ratios must be decimal numbers.\n\nThe program must be self-contained and must not read any external input. It must deterministically construct the meshes and carry out the computations exactly as specified.",
            "solution": "The problem requires a comparative analysis of neighbor-finding complexity between structured and unstructured computational meshes, a foundational topic in environmental and earth system modeling where numerical methods like the finite volume or finite element method are employed. The analysis is to be grounded in the mathematical properties of the respective graph representations of the meshes and quantified through an implementation that computes specific metrics for defined test cases.\n\n### Structured Grid: Index-Based Adjacency\n\nA two-dimensional structured grid is defined by $N_x \\times N_y$ vertices arranged in a regular Cartesian layout. Each vertex can be uniquely identified by an integer coordinate pair $(i, j)$, where $0 \\le i < N_x$ and $0 \\le j < N_y$. The neighborhood relationship is implicitly defined by index arithmetic. For an interior vertex $(i, j)$, the neighbors in a $4$-neighborhood (or von Neumann neighborhood) are $(i-1, j)$, $(i+1, j)$, $(i, j-1)$, and $(i, j+1)$. The degree $|\\mathcal{N}(v)|$ of an interior vertex is therefore $4$. Vertices on the boundaries and corners have fewer neighbors.\n\nThe average degree $\\overline{d}_{\\text{struct}}$ of the graph representing the structured grid is the total sum of degrees divided by the total number of vertices, $N = N_x N_y$. For a grid with $N_x, N_y \\ge 2$, there are:\n- $4$ corner vertices with degree $2$.\n- $2(N_x-2) + 2(N_y-2)$ edge vertices (not corners) with degree $3$.\n- $(N_x-2)(N_y-2)$ interior vertices with degree $4$.\n\nThe sum of degrees is $2 \\cdot 4 + 3 \\cdot [2(N_x-2) + 2(N_y-2)] + 4(N_x-2)(N_y-2)$. Dividing by $N_x N_y$ and simplifying yields the provided formula:\n$$\n\\overline{d}_{\\text{struct}} = 4 - \\frac{2}{N_x} - \\frac{2}{N_y}\n$$\nFor degenerate one-dimensional cases, such as when $N_y=1$ and $N_x \\ge 2$, the grid is a chain of $N_x$ vertices. There are $2$ endpoints of degree $1$ and $N_x-2$ interior points of degree $2$. The average degree is $\\frac{2 \\cdot 1 + (N_x-2) \\cdot 2}{N_x} = \\frac{2N_x-2}{N_x} = 2 - \\frac{2}{N_x}$, which matches the problem statement. The case for $N_x=1$ is symmetric. For a single point ($N_x=1, N_y=1$), the degree is $0$.\n\nThe cost of finding neighbors for a vertex is proportional to its degree, as it involves a constant number of arithmetic operations and boundary checks for each potential neighbor.\n\n### Unstructured Grid: Explicit Adjacency via CSR\n\nAn unstructured mesh lacks the implicit coordinate-based regularity of a structured grid. Vertex locations are arbitrary, and connectivity must be stored explicitly. A standard method for this is a planar triangulation (e.g., Delaunay triangulation) of the vertex point set. The adjacency information (the graph) derived from this triangulation can be efficiently stored using the Compressed Sparse Row (CSR) format. This format uses two arrays:\n- $\\text{col\\_idx}$: A contiguous array containing the indices of all neighbors for all vertices.\n- $\\text{row\\_ptr}$: An array of length $N+1$ (where $N$ is the number of vertices) where the slice $\\text{col\\_idx}[\\text{row\\_ptr}[v] : \\text{row\\_ptr}[v+1]]$ contains the neighbors of vertex $v$.\n\nThe degree of vertex $v$ is simply $|\\mathcal{N}(v)| = \\text{row\\_ptr}[v+1] - \\text{row\\_ptr}[v]$. The total sum of degrees is the length of the $\\text{col\\_idx}$ array. The average degree is therefore:\n$$\n\\overline{d}_{\\text{unstruct}} = \\frac{\\text{length}(\\text{col\\_idx})}{N}\n$$\nFor a planar triangulation with $N$ vertices and no holes, Euler's formula for planar graphs implies that the number of edges $E$ is related to the number of vertices on the convex hull, $h$, by $E = 3N - 3 - h$. Since the sum of degrees is $2E$, the average degree is $\\overline{d}_{\\text{unstruct}} = \\frac{2E}{N} = \\frac{2(3N - 3 - h)}{N} = 6 - \\frac{6 + 2h}{N}$. For large $N$ where $h$ is small relative to $N$ (e.g., $h \\sim O(\\log N)$ for points sampled from a convex domain), $\\overline{d}_{\\text{unstruct}}$ approaches $6$.\n\nThe cost of finding neighbors for a vertex $v$ using CSR is $O(1 + |\\mathcal{N}(v)|)$, reflecting the two lookups in $\\text{row\\_ptr}$ and the scan through the corresponding segment of $\\text{col\\_idx}$.\n\n### Comparative Cost Analysis and Algorithmic Strategy\n\nThe asymptotic cost for retrieving neighbors of a single vertex is $O(|\\mathcal{N}(v)|)$ in both cases, assuming $|\\mathcal{N}(v)| \\ge 1$. A key difference in performance arises from the constants involved (memory indirection for CSR vs. direct arithmetic for structured grids) and, more significantly, from the difference in average degree. The ratio of average costs for a full sweep over the mesh can be approximated by the ratio of the average degrees, $r = \\overline{d}_{\\text{unstruct}} / \\overline{d}_{\\text{struct}}$. This ratio quantifies the overhead in connectivity for an unstructured mesh compared to a structured one of similar vertex count.\n\nThe implementation will proceed as follows:\n1.  For each test case, the structured grid average degree, $\\overline{d}_{\\text{struct}}$, will be calculated analytically using the provided formulas based on $N_x$ and $N_y$.\n2.  For the unstructured mesh, a set of $N$ points will be generated according to the specified distribution (uniform or anisotropic) using a seeded `numpy` random number generator for reproducibility.\n3.  A Delaunay triangulation of these points will be computed using `scipy.spatial.Delaunay`. This choice represents a standard, high-quality \"planar triangulation\".\n4.  The method `Delaunay.vertex_neighbor_vertices` provides the graph adjacency directly in a CSR-like format (indices and index pointers).\n5.  The empirical average degree, $\\overline{d}_{\\text{unstruct}}$, will be calculated by dividing the total number of neighbor entries (the length of the `indices` array) by the number of vertices, $N$.\n6.  The ratio $r = \\overline{d}_{\\text{unstruct}} / \\overline{d}_{\\text{struct}}$ is then computed.\n7.  The three resulting floating-point numbers ($\\overline{d}_{\\text{struct}}$, $\\overline{d}_{\\text{unstruct}}$, $r$) will be collected for each test case and formatted into the final output string.",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial import Delaunay\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing and comparing average degrees for structured and\n    unstructured grids across a suite of test cases.\n    \"\"\"\n\n    def calculate_d_struct(nx, ny):\n        \"\"\"\n        Calculates the average degree of a structured grid using the analytical formula.\n        \"\"\"\n        if nx <= 0 or ny <= 0:\n            return 0.0\n        if nx == 1 and ny == 1:\n            return 0.0\n        if nx == 1:\n            return 2.0 - 2.0 / ny\n        if ny == 1:\n            return 2.0 - 2.0 / nx\n        return 4.0 - 2.0 / nx - 2.0 / ny\n\n    def get_unstructured_avg_degree(N, seed, point_config):\n        \"\"\"\n        Generates an unstructured mesh, computes its CSR-like adjacency, and returns\n        the average degree.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        if point_config == 'uniform':\n            # Uniform sampling in [0,1]^2\n            points = rng.uniform(0.0, 1.0, size=(N, 2))\n        elif point_config == 'anisotropic':\n            # Anisotropic sampling: x uniform, y noisy near zero\n            x = rng.uniform(0.0, 1.0, size=N)\n            sigma = 1e-3\n            y = rng.normal(0.0, sigma, size=N)\n            points = np.vstack((x, y)).T\n        else:\n            raise ValueError(\"Unknown point configuration\")\n\n        # Delaunay triangulation requires at least d+1 points in d-dimensions.\n        # All test cases satisfy N >= 4 for 2D.\n        if N < 3:\n            if N <= 1: return 0.0\n            if N == 2: return 1.0 # One edge, two vertices, sum of degrees = 2\n\n        tri = Delaunay(points)\n        \n        # vertex_neighbor_vertices returns a CSR-like representation of the graph\n        # where neighbors of vertex `i` are `indices[indptr[i]:indptr[i+1]]`.\n        indptr, indices = tri.vertex_neighbor_vertices\n        \n        # The sum of all vertex degrees is the total number of entries in `indices`.\n        total_degree_sum = len(indices)\n        \n        # The average degree is the total sum divided by the number of vertices.\n        avg_degree = total_degree_sum / N\n        \n        return avg_degree\n\n    test_cases = [\n        # (Nx, Ny, N, seed, point_config_type)\n        (50, 50, 2500, 42, 'uniform'),      # Test Case A\n        (2, 2, 4, 7, 'uniform'),          # Test Case B\n        (100, 1, 100, 123, 'anisotropic') # Test Case C\n    ]\n    \n    all_results = []\n    \n    for nx, ny, N, seed, point_config in test_cases:\n        d_struct = calculate_d_struct(nx, ny)\n        d_unstruct = get_unstructured_avg_degree(N, seed, point_config)\n        \n        # Calculate the ratio, handling the case where d_struct might be zero.\n        if d_struct == 0:\n            ratio = float('inf') if d_unstruct > 0 else 0.0\n        else:\n            ratio = d_unstruct / d_struct\n        \n        all_results.append([d_struct, d_unstruct, ratio])\n\n    # Format the final output string exactly as specified.\n    # \"[[d_struct_A,d_unstruct_A,ratio_A],[d_struct_B,...],...]\"\n    # with all numbers rounded to six decimal places.\n    \n    outer_list_parts = []\n    for result_set in all_results:\n        inner_list_str = \",\".join([f\"{x:.6f}\" for x in result_set])\n        outer_list_parts.append(f\"[{inner_list_str}]\")\n    \n    final_output_str = f\"[{','.join(outer_list_parts)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While unstructured grids offer geometric flexibility, this freedom can introduce numerical errors not present in simple orthogonal grids. This practice provides a rigorous, first-principles derivation of the error in the common Two-Point Flux Approximation ($TPFA$) that arises directly from grid skewness. By analyzing how non-orthogonality corrupts the discrete flux calculation, you will gain a deeper understanding of a primary source of inaccuracy in finite volume methods and the motivation for higher-order, skewness-correction schemes .",
            "id": "3918644",
            "problem": "Consider a two-dimensional unstructured finite volume discretization used in environmental and earth system modeling. A single planar polygonal cell is defined by $m \\geq 3$ vertices $\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_{m-1} \\in \\mathbb{R}^2$, ordered counterclockwise around the cell. For each face $f_i$ connecting consecutive vertices $\\mathbf{x}_i$ to $\\mathbf{x}_{i+1}$ (with index arithmetic modulo $m$), define the edge vector $\\mathbf{e}_i = \\mathbf{x}_{i+1} - \\mathbf{x}_i$, the face length $s_i = \\|\\mathbf{e}_i\\|$, the unit tangent $\\mathbf{t}_i = \\mathbf{e}_i / \\|\\mathbf{e}_i\\|$, and the outward unit normal $\\mathbf{n}_i = R_{\\mathrm{cw}} \\mathbf{t}_i$ where $R_{\\mathrm{cw}} = \\begin{pmatrix}0  1 \\\\ -1  0\\end{pmatrix}$ rotates by $90^{\\circ}$ clockwise.\n\nA scalar field $\\phi(x,y)$ is governed by steady diffusion with constant isotropic diffusion coefficient $K  0$ and no sources. The diffusive flux density is defined by Fickâ€™s law as $-K \\nabla \\phi$, and the exact integrated diffusive flux across a straight face $f$ of length $s_f$ with unit normal $\\mathbf{n}_f$ is $F_{\\mathrm{exact}} = -K\\, s_f\\, \\nabla \\phi \\cdot \\mathbf{n}_f$ when $\\nabla \\phi$ is constant.\n\nBetween two adjacent polygonal cells with centroids $\\mathbf{x}_P$ and $\\mathbf{x}_N$, consider a shared face $f$ with unit normal $\\mathbf{n}_f$ pointing from cell $P$ to cell $N$ and unit tangent $\\mathbf{t}_f$ consistent with the counterclockwise ordering of cell $P$. Define the center-to-center vector $\\mathbf{r} = \\mathbf{x}_N - \\mathbf{x}_P$, and the signed skewness angle $\\theta$ between $\\mathbf{r}$ and $\\mathbf{n}_f$ by $\\cos(\\theta) = \\dfrac{\\mathbf{r} \\cdot \\mathbf{n}_f}{\\|\\mathbf{r}\\|}$, $\\sin(\\theta) = \\dfrac{\\mathbf{r} \\cdot \\mathbf{t}_f}{\\|\\mathbf{r}\\|}$, with $\\theta = 0$ corresponding to an orthogonal structured configuration.\n\nIn the Two-Point Flux Approximation (TPFA), the diffusive flux across $f$ is approximated by\n$$\nF_{\\mathrm{TPFA}} = -K\\, s_f\\, \\frac{\\phi_N - \\phi_P}{\\mathbf{r} \\cdot \\mathbf{n}_f},\n$$\nwhere $\\phi_P = \\phi(\\mathbf{x}_P)$ and $\\phi_N = \\phi(\\mathbf{x}_N)$. Assume $\\nabla \\phi$ is constant and the face is planar so that the above exact flux expression applies, and that the vertices of the polygon satisfy the stated orientation.\n\nTasks:\n- Using only the vertex coordinates $\\{\\mathbf{x}_i\\}_{i=0}^{m-1}$, express $s_i$, $\\mathbf{t}_i$, and $\\mathbf{n}_i$ for each face $f_i$. Also, express the cell area $A$ in terms of $\\{\\mathbf{x}_i\\}$.\n- Starting from the fundamental definitions provided, derive an expression for the skewness-induced flux error $E = F_{\\mathrm{TPFA}} - F_{\\mathrm{exact}}$ in terms of $K$, $s_f$, $\\theta$, and the projections of $\\nabla \\phi$ onto $\\mathbf{n}_f$ and $\\mathbf{t}_f$. Simplify the expression to a closed form that isolates the dependence on the skewness angle $\\theta$.\n- State the magnitude of the skewness-induced error $|E|$ as a single closed-form analytic expression in terms of $K$, $s_f$, $\\theta$, and the tangential component of $\\nabla \\phi$ along $\\mathbf{t}_f$.\n\nYour final answer must be the single analytic expression for $|E|$. No numerical rounding is required, and no units should be included in the final boxed expression. The derivation must rely only on the core definitions and well-tested formulas stated above, and be scientifically realistic for general polygonal unstructured grids. Do not provide shortcut formulas beyond what is specified.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded in the principles of numerical methods for transport phenomena, specifically the finite volume method. The problem is well-posed, with all necessary definitions, variables, and constraints provided to derive the requested quantities. The terminology is precise and objective, and the setup is internally consistent and physically realistic within the context of analyzing numerical discretization error.\n\nWe proceed with the derivation as requested.\n\nThe problem is divided into three tasks. We will address them in sequence.\n\nTask 1: Express geometric quantities in terms of vertex coordinates.\nLet the vertices of the polygonal cell be given by their coordinate vectors $\\mathbf{x}_i = (x_i, y_i)$ for $i=0, 1, \\dots, m-1$. The indices are taken modulo $m$.\n\nThe edge vector for face $f_i$, connecting vertex $\\mathbf{x}_i$ to $\\mathbf{x}_{i+1}$, is defined as:\n$$\n\\mathbf{e}_i = \\mathbf{x}_{i+1} - \\mathbf{x}_i = (x_{i+1} - x_i)\\mathbf{\\hat{i}} + (y_{i+1} - y_i)\\mathbf{\\hat{j}}\n$$\n\nThe length of face $f_i$, denoted $s_i$, is the Euclidean norm of the edge vector $\\mathbf{e}_i$:\n$$\ns_i = \\|\\mathbf{e}_i\\| = \\sqrt{(x_{i+1} - x_i)^2 + (y_{i+1} - y_i)^2}\n$$\n\nThe unit tangent vector $\\mathbf{t}_i$ is the edge vector normalized by its length:\n$$\n\\mathbf{t}_i = \\frac{\\mathbf{e}_i}{\\|\\mathbf{e}_i\\|} = \\frac{1}{s_i} ((x_{i+1} - x_i)\\mathbf{\\hat{i}} + (y_{i+1} - y_i)\\mathbf{\\hat{j}})\n$$\n\nThe outward unit normal vector $\\mathbf{n}_i$ is obtained by a $90^{\\circ}$ clockwise rotation of the unit tangent vector $\\mathbf{t}_i$. The rotation matrix is given as $R_{\\mathrm{cw}} = \\begin{pmatrix}0  1 \\\\ -1  0\\end{pmatrix}$. Applying this to the components of $\\mathbf{t}_i = (t_{ix}, t_{iy})$ gives $\\mathbf{n}_i = (t_{iy}, -t_{ix})$. Substituting the components of $\\mathbf{t}_i$:\n$$\n\\mathbf{n}_i = \\frac{1}{s_i} ((y_{i+1} - y_i)\\mathbf{\\hat{i}} - (x_{i+1} - x_i)\\mathbf{\\hat{j}})\n$$\nThis direction is indeed outward because the vertices are ordered counterclockwise.\n\nThe area of the planar polygon, $A$, can be calculated using the shoelace formula (also known as the Surveyor's formula), which follows from Green's theorem. Given the counterclockwise ordering of the vertices, the signed area is positive:\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{m-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n\nTask 2: Derive the skewness-induced flux error $E = F_{\\mathrm{TPFA}} - F_{\\mathrm{exact}}$.\nWe are given the expressions for the Two-Point Flux Approximation and the exact flux:\n$$\nF_{\\mathrm{TPFA}} = -K\\, s_f\\, \\frac{\\phi_N - \\phi_P}{\\mathbf{r} \\cdot \\mathbf{n}_f}\n$$\n$$\nF_{\\mathrm{exact}} = -K\\, s_f\\, (\\nabla \\phi \\cdot \\mathbf{n}_f)\n$$\nThe problem states that the gradient of the scalar field, $\\nabla \\phi$, is constant. This allows us to relate the values of $\\phi$ at two points, $\\mathbf{x}_P$ and $\\mathbf{x}_N$, exactly using a first-order Taylor expansion:\n$$\n\\phi(\\mathbf{x}_N) = \\phi(\\mathbf{x}_P) + \\nabla \\phi \\cdot (\\mathbf{x}_N - \\mathbf{x}_P)\n$$\nDenoting $\\phi_N = \\phi(\\mathbf{x}_N)$, $\\phi_P = \\phi(\\mathbf{x}_P)$, and $\\mathbf{r} = \\mathbf{x}_N - \\mathbf{x}_P$, we have:\n$$\n\\phi_N - \\phi_P = \\nabla \\phi \\cdot \\mathbf{r}\n$$\nSubstituting this exact relationship into the expression for $F_{\\mathrm{TPFA}}$:\n$$\nF_{\\mathrm{TPFA}} = -K\\, s_f\\, \\frac{\\nabla \\phi \\cdot \\mathbf{r}}{\\mathbf{r} \\cdot \\mathbf{n}_f}\n$$\nNow we compute the error $E$ by subtracting the exact flux:\n$$\nE = F_{\\mathrm{TPFA}} - F_{\\mathrm{exact}} = \\left(-K\\, s_f\\, \\frac{\\nabla \\phi \\cdot \\mathbf{r}}{\\mathbf{r} \\cdot \\mathbf{n}_f}\\right) - \\left(-K\\, s_f\\, (\\nabla \\phi \\cdot \\mathbf{n}_f)\\right)\n$$\nFactoring out the common term $-K s_f$:\n$$\nE = -K\\, s_f \\left( \\frac{\\nabla \\phi \\cdot \\mathbf{r}}{\\mathbf{r} \\cdot \\mathbf{n}_f} - \\nabla \\phi \\cdot \\mathbf{n}_f \\right)\n$$\nTo simplify this, we place both terms over a common denominator:\n$$\nE = -K\\, s_f \\left( \\frac{(\\nabla \\phi \\cdot \\mathbf{r}) - (\\nabla \\phi \\cdot \\mathbf{n}_f)(\\mathbf{r} \\cdot \\mathbf{n}_f)}{\\mathbf{r} \\cdot \\mathbf{n}_f} \\right)\n$$\nTo analyze the numerator, we decompose the vectors $\\mathbf{r}$ and $\\nabla \\phi$ in the orthonormal basis defined by the face normal $\\mathbf{n}_f$ and face tangent $\\mathbf{t}_f$.\nThe vector $\\nabla \\phi$ is decomposed as:\n$$\n\\nabla \\phi = (\\nabla \\phi \\cdot \\mathbf{n}_f) \\mathbf{n}_f + (\\nabla \\phi \\cdot \\mathbf{t}_f) \\mathbf{t}_f\n$$\nThe vector $\\mathbf{r}$ is decomposed using the given definition of the skewness angle $\\theta$:\n$$\n\\cos(\\theta) = \\frac{\\mathbf{r} \\cdot \\mathbf{n}_f}{\\|\\mathbf{r}\\|} \\quad \\text{and} \\quad \\sin(\\theta) = \\frac{\\mathbf{r} \\cdot \\mathbf{t}_f}{\\|\\mathbf{r}\\|}\n$$\nThis implies $\\mathbf{r} \\cdot \\mathbf{n}_f = \\|\\mathbf{r}\\| \\cos(\\theta)$ and $\\mathbf{r} \\cdot \\mathbf{t}_f = \\|\\mathbf{r}\\| \\sin(\\theta)$. Therefore, the decomposition of $\\mathbf{r}$ is:\n$$\n\\mathbf{r} = (\\mathbf{r} \\cdot \\mathbf{n}_f) \\mathbf{n}_f + (\\mathbf{r} \\cdot \\mathbf{t}_f) \\mathbf{t}_f = \\|\\mathbf{r}\\| \\cos(\\theta) \\mathbf{n}_f + \\|\\mathbf{r}\\| \\sin(\\theta) \\mathbf{t}_f\n$$\nNow we compute the dot product $\\nabla \\phi \\cdot \\mathbf{r}$ using these decompositions:\n$$\n\\nabla \\phi \\cdot \\mathbf{r} = \\left( (\\nabla \\phi \\cdot \\mathbf{n}_f) \\mathbf{n}_f + (\\nabla \\phi \\cdot \\mathbf{t}_f) \\mathbf{t}_f \\right) \\cdot \\left( \\|\\mathbf{r}\\| \\cos(\\theta) \\mathbf{n}_f + \\|\\mathbf{r}\\| \\sin(\\theta) \\mathbf{t}_f \\right)\n$$\nUsing the orthonormality of the basis ($\\mathbf{n}_f \\cdot \\mathbf{n}_f = 1$, $\\mathbf{t}_f \\cdot \\mathbf{t}_f = 1$, $\\mathbf{n}_f \\cdot \\mathbf{t}_f = 0$):\n$$\n\\nabla \\phi \\cdot \\mathbf{r} = (\\nabla \\phi \\cdot \\mathbf{n}_f) (\\|\\mathbf{r}\\| \\cos(\\theta)) + (\\nabla \\phi \\cdot \\mathbf{t}_f) (\\|\\mathbf{r}\\| \\sin(\\theta))\n$$\nSubstitute this into the numerator of the expression for $E$:\n$$\n\\text{Numerator} = [(\\nabla \\phi \\cdot \\mathbf{n}_f) (\\|\\mathbf{r}\\| \\cos(\\theta)) + (\\nabla \\phi \\cdot \\mathbf{t}_f) (\\|\\mathbf{r}\\| \\sin(\\theta))] - (\\nabla \\phi \\cdot \\mathbf{n}_f)(\\|\\mathbf{r}\\| \\cos(\\theta))\n$$\nThe first and last terms cancel, leaving:\n$$\n\\text{Numerator} = (\\nabla \\phi \\cdot \\mathbf{t}_f) (\\|\\mathbf{r}\\| \\sin(\\theta))\n$$\nThe denominator of the expression for $E$ is $\\mathbf{r} \\cdot \\mathbf{n}_f = \\|\\mathbf{r}\\| \\cos(\\theta)$.\nSubstituting the simplified numerator and the denominator back into the expression for $E$:\n$$\nE = -K\\, s_f \\left( \\frac{(\\nabla \\phi \\cdot \\mathbf{t}_f) (\\|\\mathbf{r}\\| \\sin(\\theta))}{\\|\\mathbf{r}\\| \\cos(\\theta)} \\right)\n$$\nAssuming $\\theta \\neq \\pm \\frac{\\pi}{2}$ (i.e., $\\cos(\\theta) \\neq 0$), the $\\|\\mathbf{r}\\|$ terms cancel, and we can replace the ratio of sine and cosine with the tangent function:\n$$\nE = -K\\, s_f (\\nabla \\phi \\cdot \\mathbf{t}_f) \\tan(\\theta)\n$$\nThis expression isolates the dependence on the skewness angle $\\theta$ in the $\\tan(\\theta)$ term. The error is zero if the grid is orthogonal ($\\theta=0$) or if the gradient is normal to the face ($\\nabla \\phi \\cdot \\mathbf{t}_f=0$).\n\nTask 3: State the magnitude of the skewness-induced error $|E|$.\nThe magnitude of the error is the absolute value of the expression derived for $E$:\n$$\n|E| = |-K\\, s_f (\\nabla \\phi \\cdot \\mathbf{t}_f) \\tan(\\theta)|\n$$\nSince $K  0$ and the face length $s_f$ is a positive quantity, we can take them out of the absolute value:\n$$\n|E| = K\\, s_f |(\\nabla \\phi \\cdot \\mathbf{t}_f) \\tan(\\theta)|\n$$\nHere, $(\\nabla \\phi \\cdot \\mathbf{t}_f)$ is the scalar value of the tangential component of $\\nabla \\phi$ along the unit vector $\\mathbf{t}_f$. The expression is the required single closed-form analytic expression.",
            "answer": "$$\n\\boxed{K s_f |(\\nabla \\phi \\cdot \\mathbf{t}_f) \\tan(\\theta)|}\n$$"
        },
        {
            "introduction": "A physically consistent numerical scheme must correctly replicate fundamental properties of continuous operators, and a crucial verification test is to ensure a constant, divergence-free field remains so after discretization. This exercise guides you through implementing a test to verify that your discrete divergence operator satisfies the geometric conservation law on both structured and unstructured grids. Successfully demonstrating that the discrete divergence of a constant field is zero (to machine precision) confirms the geometric integrity of your discretization, a foundational requirement for any reliable environmental model .",
            "id": "3918705",
            "problem": "You are tasked with designing and implementing a verification test, rooted in first principles, to confirm the exact preservation of a constant divergence-free velocity field under a discrete divergence operator on both structured and unstructured grids commonly used in environmental and earth system modeling. The design must start from the Divergence Theorem and proceed to a discrete, control-volume-based divergence consistent with the Finite Volume Method (FVM). Your program must compute residuals that quantify deviations from zero divergence and aggregate these residuals for several test cases.\n\nFundamental base:\n- The Divergence Theorem (Gauss's theorem) states that for a sufficiently smooth vector field $\\mathbf{u}(\\mathbf{x})$ and a closed control volume $V$ with boundary $\\partial V$ and outward unit normal $\\mathbf{n}$,\n$$\n\\int_V \\nabla \\cdot \\mathbf{u} \\, dV = \\int_{\\partial V} \\mathbf{u} \\cdot \\mathbf{n} \\, dS.\n$$\n- The Finite Volume Method (FVM) discretizes the divergence by approximating the boundary integral as a sum of face fluxes. For a single control volume (cell) $c$ of volume $|V_c|$ with faces indexed by $f$ and areas $|S_f|$, the discrete divergence is derived from the flux balance:\n$$\n\\left(\\nabla \\cdot \\mathbf{u}\\right)_c \\approx \\frac{1}{|V_c|} \\sum_{f \\in \\partial c} \\left( \\mathbf{u}_f \\cdot \\mathbf{n}_f \\right) |S_f|.\n$$\n- A constant velocity field $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}_0$ has $\\nabla \\cdot \\mathbf{u} = 0$ in the continuous setting, and the exact flux over any closed surface must be zero because the sum of outward area vectors over a closed surface (or the sum of outward normal-length vectors over a closed polygon in two dimensions) vanishes.\n\nYour tasks:\n1. For a structured Cartesian grid in two dimensions, define cells of width $dx$ and height $dy$, with faces aligned to the coordinate axes. Use the FVM control-volume flux balance with the exact geometry of faces to compute the discrete divergence at every cell for a constant velocity $\\mathbf{u}_0 = (u_x, u_y)$, using the outward normal directions on each face. Compute the residual defined as the maximum absolute value of the discrete divergence over all cells. Divergence has units of $\\mathrm{s}^{-1}$ when velocity is in $\\mathrm{m/s}$ and lengths are in $\\mathrm{m}$. Report residuals in $\\mathrm{s}^{-1}$.\n2. For an unstructured polygonal grid in two dimensions, define each cell as a simple polygon by its vertices $(x_i, y_i)$ in $\\mathrm{m}$, ordered to form a closed loop (your program must ensure counterclockwise ordering if needed). Compute the polygon area $|V_c|$ using the shoelace formula and the outward unit normals $\\mathbf{n}_f$ along each edge by rotating the edge vectors by $-90^\\circ$ to obtain outward normals for counterclockwise orientation. Use the FVM flux balance to compute the discrete divergence for a constant velocity $\\mathbf{u}_0 = (u_x, u_y)$ and the corresponding residual as in the structured case. Report residuals in $\\mathrm{s}^{-1}$.\n\nConstraints and expectations:\n- Use only exact geometric quantities for faces and cell volumes; do not introduce numerical quadrature for the flux on faces since $\\mathbf{u}$ is constant.\n- The calculation must be local per cell and must not rely on boundary conditions or ghost cells, as the flux balance is computed on closed control volumes.\n- Residuals should be extremely close to zero, with any nonzero value attributable only to floating-point rounding.\n\nTest suite:\nProvide and compute residuals for the following five test cases. All distances are in $\\mathrm{m}$, velocities in $\\mathrm{m/s}$, and report residuals in $\\mathrm{s}^{-1}$.\n\n- Test case $1$ (structured, general case):\n  - Grid: $N_x = 10$, $N_y = 8$, $dx = 3700$, $dy = 2100$.\n  - Constant velocity: $\\mathbf{u}_0 = (3.2, -5.4)$.\n- Test case $2$ (structured, boundary-sized single cell):\n  - Grid: $N_x = 1$, $N_y = 1$, $dx = 0.001$, $dy = 0.001$.\n  - Constant velocity: $\\mathbf{u}_0 = (123.456, -654.321)$.\n- Test case $3$ (structured, anisotropic cell size with irrational-like components):\n  - Grid: $N_x = 45$, $N_y = 60$, $dx = 1.0$, $dy = 1000.0$.\n  - Constant velocity: $\\mathbf{u}_0 = (1.41421356237, 3.14159265359)$.\n- Test case $4$ (unstructured, triangles):\n  - Polygons (each cell is a triangle with counterclockwise vertices specified in $\\mathrm{m}$):\n    - Triangle $1$: $(0, 0)$, $(2, 0)$, $(0, 1)$.\n    - Triangle $2$: $(1, 1)$, $(3, 1)$, $(2, 3)$.\n    - Triangle $3$: $(5, 0)$, $(6, 2)$, $(4, 2)$.\n  - Constant velocity: $\\mathbf{u}_0 = (1.41421356237, 3.14159265359)$.\n- Test case $5$ (unstructured, highly skewed quadrilaterals to probe numerical robustness):\n  - Polygons (each cell is a quadrilateral with vertices in $\\mathrm{m}$):\n    - Quadrilateral $1$: $(0, 0)$, $(10, 0.1)$, $(10.2, 50)$, $(0, 49.9)$.\n    - Quadrilateral $2$: $(20, 0)$, $(30, 0.05)$, $(30.05, 100)$, $(20, 99.95)$.\n  - Constant velocity: $\\mathbf{u}_0 = (3.2, -5.4)$.\n\nFinal output format:\nYour program should produce a single line of output containing the residuals for the five test cases, in order, as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is a floating-point number in $\\mathrm{s}^{-1}$ representing the maximum absolute discrete divergence over all cells in that test case. No additional text should be printed.",
            "solution": "The problem is valid. It presents a well-posed, scientifically grounded verification exercise from the field of computational fluid dynamics, specifically concerning the properties of discrete operators on structured and unstructured grids. All necessary data and definitions are provided, and the problem is internally consistent.\n\nThe core of this problem lies in verifying a fundamental property of a Finite Volume Method (FVM) discretization: the exact preservation of a constant, divergence-free velocity field. This is a crucial test for any numerical scheme intended for conservation laws, as it demonstrates that the discrete operator correctly mimics the properties of its continuous counterpart in the simplest non-trivial case.\n\nThe governing principle is the Divergence Theorem, which relates the volume integral of the divergence of a vector field $\\mathbf{u}$ to the flux of that field through the volume's closed boundary $\\partial V$:\n$$\n\\int_V \\nabla \\cdot \\mathbf{u} \\, dV = \\oint_{\\partial V} \\mathbf{u} \\cdot \\mathbf{n} \\, dS\n$$\nHere, $\\mathbf{n}$ is the outward unit normal to the boundary surface element $dS$.\n\nIn the FVM, we consider a single control volume (a cell $c$) and approximate the average divergence over that cell. The integral form is divided by the cell volume $|V_c|$:\n$$\n\\frac{1}{|V_c|} \\int_{V_c} \\nabla \\cdot \\mathbf{u} \\, dV = \\frac{1}{|V_c|} \\oint_{\\partial V_c} \\mathbf{u} \\cdot \\mathbf{n} \\, dS\n$$\nThe left side represents the cell-averaged divergence, $(\\nabla \\cdot \\mathbf{u})_c$. The right side's integral is discretized as a sum of fluxes over the faces $f$ of the cell:\n$$\n(\\nabla \\cdot \\mathbf{u})_c \\approx \\frac{1}{|V_c|} \\sum_{f \\in \\partial c} \\left( \\mathbf{u}_f \\cdot \\mathbf{n}_f \\right) |S_f|\n$$\nwhere $\\mathbf{u}_f$ is the velocity at the face, $\\mathbf{n}_f$ is the outward unit normal to the face, and $|S_f|$ is the face area (or length in 2D).\n\nThe problem specifies a constant velocity field, $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}_0$. For such a field, the continuous divergence is identically zero: $\\nabla \\cdot \\mathbf{u}_0 = 0$. Since the velocity is constant, the velocity at any face $\\mathbf{u}_f$ is simply $\\mathbf{u}_0$. The discrete divergence formula becomes:\n$$\n(\\nabla \\cdot \\mathbf{u})_c \\approx \\frac{1}{|V_c|} \\sum_{f \\in \\partial c} \\left( \\mathbf{u}_0 \\cdot \\mathbf{n}_f \\right) |S_f| = \\frac{1}{|V_c|} \\mathbf{u}_0 \\cdot \\left( \\sum_{f \\in \\partial c} \\mathbf{n}_f |S_f| \\right)\n$$\nThis equation reveals that the discrete divergence of a constant field is zero if and only if the sum of the outward normal vectors scaled by their face areas is the zero vector. This is a purely geometric property known as the geometric conservation law: for any closed volume, the sum of its outward-pointing face-normal-area vectors must be zero. A valid FVM discretization must satisfy this condition exactly.\n$$\n\\sum_{f \\in \\partial c} \\mathbf{n}_f |S_f| = \\mathbf{0}\n$$\nOur task is to verify this property numerically for both structured and unstructured grids. The computed residual will be the maximum absolute value of the discrete divergence over all cells, which should ideally be zero, with any non-zero value being attributable to floating-point arithmetic error.\n\n**1. Structured Cartesian Grid (2D)**\n\nFor a 2D structured grid, a cell is a rectangle of width $dx$ and height $dy$. Its area is $|V_c| = dx \\cdot dy$. The cell has four faces (East, North, West, South). We define the outward normal-length vectors, which are the product $\\mathbf{n}_f |S_f|$:\n- East face: normal $\\mathbf{n}_e=(1, 0)$, length $|S_e|=dy$. Vector: $(dy, 0)$.\n- North face: normal $\\mathbf{n}_n=(0, 1)$, length $|S_n|=dx$. Vector: $(0, dx)$.\n- West face: normal $\\mathbf{n}_w=(-1, 0)$, length $|S_w|=dy$. Vector: $(-dy, 0)$.\n- South face: normal $\\mathbf{n}_s=(0, -1)$, length $|S_s|=dx$. Vector: $(0, -dx)$.\n\nThe sum of these vectors is:\n$$\n\\sum_{f \\in \\partial c} \\mathbf{n}_f |S_f| = (dy, 0) + (0, dx) + (-dy, 0) + (0, -dx) = (dy - dy, dx - dx) = (0, 0)\n$$\nThe geometric conservation law is satisfied. The total flux is calculated by summing the dot products of the constant velocity $\\mathbf{u}_0 = (u_x, u_y)$ with each normal-length vector:\n$$\n\\text{Flux}_{total} = u_x \\cdot dy + u_y \\cdot dx + u_x \\cdot (-dy) + u_y \\cdot (-dx) = (u_x dy - u_x dy) + (u_y dx - u_y dx) = 0\n$$\nThe discrete divergence is $\\frac{\\text{Flux}_{total}}{|V_c|} = \\frac{0}{dx \\cdot dy} = 0$. This holds for every cell in the grid.\n\n**2. Unstructured Polygonal Grid (2D)**\n\nFor a 2D unstructured grid, a cell is a simple polygon defined by a sequence of $N$ vertices $(x_i, y_i)$ for $i=0, \\dots, N-1$, ordered counter-clockwise (CCW).\nThe cell area $|V_c|$ is calculated using the shoelace formula:\n$$\n|V_c| = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\nwhere the vertex index $N$ is equivalent to $0$. A positive result confirms CCW ordering.\n\nA face $f_i$ is the edge connecting vertex $i$ to vertex $i+1$. The edge vector is $\\Delta\\mathbf{s}_i = (x_{i+1} - x_i, y_{i+1} - y_i) = (\\Delta x_i, \\Delta y_i)$. For a CCW-ordered polygon, the outward normal-length vector is obtained by rotating the edge vector by $-90^\\circ$:\n$$\n\\mathbf{n}_{f_i} |S_{f_i}| = (\\Delta y_i, -\\Delta x_i)\n$$\nThe sum of these vectors over all faces of the closed polygon is:\n$$\n\\sum_{i=0}^{N-1} (\\Delta y_i, -\\Delta x_i) = \\left( \\sum_{i=0}^{N-1} (y_{i+1} - y_i), -\\sum_{i=0}^{N-1} (x_{i+1} - x_i) \\right)\n$$\nThese are telescoping sums. For a closed polygon where $(x_N, y_N) = (x_0, y_0)$:\n$$\n\\sum_{i=0}^{N-1} (y_{i+1} - y_i) = y_N - y_0 = 0 \\quad \\text{and} \\quad \\sum_{i=0}^{N-1} (x_{i+1} - x_i) = x_N - x_0 = 0\n$$\nThe sum of the normal-length vectors is therefore $(0, 0)$, again satisfying the geometric conservation law. The total flux is calculated by summing the dot products $\\mathbf{u}_0 \\cdot (\\mathbf{n}_{f_i} |S_{f_i}|)$:\n$$\n\\text{Flux}_{total} = \\sum_{i=0}^{N-1} \\mathbf{u}_0 \\cdot (\\Delta y_i, -\\Delta x_i) = \\sum_{i=0}^{N-1} (u_x \\Delta y_i - u_y \\Delta x_i) = u_x \\sum \\Delta y_i - u_y \\sum \\Delta x_i = u_x \\cdot 0 - u_y \\cdot 0 = 0\n$$\nThe discrete divergence for each polygonal cell is $\\frac{\\text{Flux}_{total}}{|V_c|} = 0$. The implementation will calculate this for each specified cell and report the maximum absolute value as the residual.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_structured_residual(dx, dy, u0):\n    \"\"\"\n    Computes the discrete divergence for a single cell in a structured grid.\n    For a constant velocity field on a uniform Cartesian grid, the result\n    is identical for all cells.\n    \n    Args:\n        dx (float): Cell width in meters.\n        dy (float): Cell height in meters.\n        u0 (tuple): Constant velocity vector (ux, uy) in m/s.\n        \n    Returns:\n        float: The absolute value of the discrete divergence in s^-1.\n    \"\"\"\n    ux, uy = u0\n    \n    # Cell area (which is the 2D volume)\n    cell_area = dx * dy\n    if cell_area == 0:\n        return 0.0\n\n    # Fluxes across a cell's four faces (East, North, West, South).\n    # The flux for a face f is (u0 . n_f) * |S_f|, where n_f is the outward\n    # unit normal and |S_f| is the face length. This is equivalent to\n    # u0 . (n_f * |S_f|), where (n_f * |S_f|) is the normal-length vector.\n    # East face: normal-length vector is (dy, 0)\n    # North face: normal-length vector is (0, dx)\n    # West face: normal-length vector is (-dy, 0)\n    # South face: normal-length vector is (0, -dx)\n    \n    flux_east = ux * dy\n    flux_north = uy * dx\n    flux_west = -ux * dy\n    flux_south = -uy * dx\n    \n    # Summing the fluxes. Grouping identical terms to improve numerical stability.\n    total_flux = (flux_east + flux_west) + (flux_north + flux_south)\n    \n    divergence = total_flux / cell_area\n    \n    return abs(divergence)\n\ndef calculate_unstructured_residual(polygons, u0):\n    \"\"\"\n    Computes the maximum absolute discrete divergence over a set of \n    unstructured polygonal cells.\n    \n    Args:\n        polygons (list): A list of numpy arrays, where each array contains the\n                         (x, y) vertices of a cell in meters.\n        u0 (tuple): Constant velocity vector (ux, uy) in m/s.\n        \n    Returns:\n        float: The maximum absolute discrete divergence over all cells in s^-1.\n    \"\"\"\n    ux, uy = u0\n    all_divergences = []\n    \n    for poly_verts in polygons:\n        # Ensure vertices are in counter-clockwise (CCW) order by checking\n        # the sign of the shoelace formula for area.\n        num_verts = len(poly_verts)\n        signed_area = 0.5 * sum(\n            poly_verts[i, 0] * poly_verts[(i + 1) % num_verts, 1] -\n            poly_verts[(i + 1) % num_verts, 0] * poly_verts[i, 1]\n            for i in range(num_verts)\n        )\n        \n        if signed_area  0:\n            # Reverse vertices if clockwise (CW)\n            poly_verts = np.flip(poly_verts, axis=0)\n            cell_area = -signed_area\n        else:\n            cell_area = signed_area\n\n        if cell_area == 0:\n            all_divergences.append(0.0)\n            continue\n            \n        total_flux = 0.0\n        # Loop over polygon edges (faces) to compute total flux\n        for i in range(num_verts):\n            p1 = poly_verts[i]\n            p2 = poly_verts[(i + 1) % num_verts]\n            \n            # Edge vector (dx, dy)\n            dx = p2[0] - p1[0]\n            dy = p2[1] - p1[1]\n\n            # Outward normal-length vector (dy, -dx) for CCW.\n            # Flux for this edge is u0 . (normal-length vector)\n            flux = ux * dy - uy * dx\n            total_flux += flux\n            \n        divergence = total_flux / cell_area\n        all_divergences.append(divergence)\n        \n    if not all_divergences:\n        return 0.0\n        \n    return np.max(np.abs(all_divergences))\n\ndef solve():\n    \"\"\"\n    Runs the verification tests for both structured and unstructured grids\n    and prints the residuals in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (structured)\n        {'type': 'structured', 'params': {'dx': 3700.0, 'dy': 2100.0, 'u0': (3.2, -5.4)}},\n        # Test case 2 (structured)\n        {'type': 'structured', 'params': {'dx': 0.001, 'dy': 0.001, 'u0': (123.456, -654.321)}},\n        # Test case 3 (structured)\n        {'type': 'structured', 'params': {'dx': 1.0, 'dy': 1000.0, 'u0': (1.41421356237, 3.14159265359)}},\n        # Test case 4 (unstructured)\n        {'type': 'unstructured', 'params': {\n            'polygons': [\n                np.array([(0., 0.), (2., 0.), (0., 1.)]),\n                np.array([(1., 1.), (3., 1.), (2., 3.)]),\n                np.array([(5., 0.), (6., 2.), (4., 2.)])\n            ],\n            'u0': (1.41421356237, 3.14159265359)\n        }},\n        # Test case 5 (unstructured)\n        {'type': 'unstructured', 'params': {\n            'polygons': [\n                np.array([(0., 0.), (10., 0.1), (10.2, 50.), (0., 49.9)]),\n                np.array([(20., 0.), (30., 0.05), (30.05, 100.), (20., 99.95)])\n            ],\n            'u0': (3.2, -5.4)\n        }}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'structured':\n            residual = calculate_structured_residual(**case['params'])\n            results.append(residual)\n        elif case['type'] == 'unstructured':\n            residual = calculate_unstructured_residual(**case['params'])\n            results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}