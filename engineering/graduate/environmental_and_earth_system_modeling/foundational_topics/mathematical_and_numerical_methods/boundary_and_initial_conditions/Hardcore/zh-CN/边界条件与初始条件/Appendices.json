{
    "hands_on_practices": [
        {
            "introduction": "在构建数值模型时，边界条件的处理方式直接影响模型的准确性和稳定性。本练习通过一个经典的一维平流扩散问题，引导您动手比较两种主流离散方法——有限差分法（FD）和有限体积法（FV）——在计算边界通量时的差异。通过从头推导并实现这些方法，您将深入理解不同数值格式（例如，基于节点的二阶差分与基于单元中心的迎风格式）如何影响模型对边界物理过程的表述，这对于任何模型开发者或使用者来说都是一项核心技能。",
            "id": "3866398",
            "problem": "考虑一个长度为 $L$、具有恒定横截面积 $A$ 的一维、均匀、棱柱形河道。浓度为 $c(x,t)$ 的被动示踪剂通过平流以恒定速度 $u$（假定空间均匀）输运，并以恒定的分子扩散系数 $K$（假定空间均匀）进行扩散。其控制守恒定律为平流-扩散偏微分方程（PDE）\n$$\n\\frac{\\partial (A\\,c)}{\\partial t} + \\frac{\\partial F}{\\partial x} = 0,\n$$\n其中总通量 $F(x,t)$ 结合了平流和扩散的贡献，\n$$\nF(x,t) = A\\big(u\\,c(x,t) - K\\,\\frac{\\partial c}{\\partial x}(x,t)\\big).\n$$\n假设在时间 $t=0$ 时的初始条件为闭区间 $x\\in[0,L]$ 上的线性浓度剖面 $c(x,0) = c_0 + \\alpha\\,x$，并带有与线性剖面一致的 Dirichlet 边界条件 $c(0,t)=c_L$ 和 $c(L,t)=c_R$，即 $c_L = c_0$ 和 $c_R = c_0 + \\alpha\\,L$。在整个问题中，取 $A$ 为常数且等于 $A=1\\,\\text{m}^2$。\n\n您的任务是使用两种离散化方法，在 $t=0$ 时推导、实现并评估边界通量 $F(0,t)$ 和 $F(L,t)$：\n\n1. 有限差分（FD）：使用基于节点的网格，其间距均匀为 $\\Delta x$，节点位于 $x_j=j\\,\\Delta x$，其中 $j\\in\\{0,1,\\dots,N\\}$ 且 $N\\,\\Delta x=L$。在每个边界处，仅基于边界节点及其最近的内部邻居节点的值，使用二阶单边差分来近似空间梯度 $\\frac{\\partial c}{\\partial x}$。在平流贡献中使用 $c(0)$ 和 $c(L)$ 的 Dirichlet 边界值。通过 Taylor 级数展开从第一性原理出发，推导在 $x=0$ 和 $x=L$ 处 $\\frac{\\partial c}{\\partial x}$ 的二阶单边差分公式，并用这些公式在 $t=0$ 时近似计算 $F(0)$ 和 $F(L)$。\n\n2. 有限体积（FV）：使用包含 $N$ 个均匀单元的单元中心网格，单元宽度为 $\\Delta x=L/N$，中心位于 $x_i=(i+\\tfrac{1}{2})\\,\\Delta x$，其中 $i\\in\\{0,1,\\dots,N-1\\}$。使用以下方法评估边界面通量：\n   - 在边界面处对平流通量使用迎风重构：\n     - 在 $x=0$ 处，如果 $u>0$，在面上使用边界入流值 $c_L$；如果 $u<0$，在面上使用相邻的内部单元中心值 $c_0$。\n     - 在 $x=L$ 处，如果 $u>0$，使用相邻的内部单元中心值 $c_{N-1}$；如果 $u<0$，使用边界入流值 $c_R$。\n   - 在边界面处，基于 Dirichlet 边界值和相邻内部单元中心值，对扩散通量梯度进行线性重构，这与 Fick 定律一致。利用边界与最近单元中心之间呈线性剖面的假设，推导在 $x=0$ 和 $x=L$ 处的界面梯度表达式。\n\n从守恒定律和上述定义出发，推导在 $t=0$ 时域内由边界通量引起的质量净变化率的表达式，\n$$\n\\dot{M}_{\\text{boundary}} = F(0) - F(L),\n$$\n对有限差分和有限体积两种方法都进行推导。从第一性原理出发，解释并证明所有近似。\n\n实现要求：\n- 根据每种方法，使用相同的细分数 $N$ 和长度 $L$ 对域进行离散化。\n- 根据 $c(x,0)=c_0+\\alpha\\,x$ 构建初始浓度场，并强制 $c_L=c_0$ 和 $c_R=c_0+\\alpha\\,L$。\n- 对两种方法，在 $t=0$ 时计算 $F(0)$ 和 $F(L)$，然后计算如上定义的 $\\dot{M}_{\\text{boundary}}$。\n- 将每个最终结果以 $\\text{kg/s}$ 为单位表示。\n\n测试套件：\n对于下面的每个测试用例，使用指定的参数并计算两个结果：有限差分净边界质量速率 $\\dot{M}_{\\text{FD}}$ 和有限体积净边界质量速率 $\\dot{M}_{\\text{FV}}$，两者均在 $t=0$ 时计算。在所有情况下，均使用 $A=1\\,\\text{m}^2$。\n\n- 用例1（基准线性剖面，正平流，非零扩散）：\n  - $N=100$, $L=10\\,\\text{m}$, $u=0.5\\,\\text{m/s}$, $K=0.1\\,\\text{m}^2/\\text{s}$, $c_0=1.0\\,\\text{kg/m}^3$, $\\alpha=0.05\\,\\text{kg/m}^4$。\n\n- 用例2（纯平流，负线性斜率）：\n  - $N=50$, $L=20\\,\\text{m}$, $u=1.2\\,\\text{m/s}$, $K=0.0\\,\\text{m}^2/\\text{s}$, $c_0=0.8\\,\\text{kg/m}^3$, $\\alpha=-0.02\\,\\text{kg/m}^4$。\n\n- 用例3（负平流，正扩散）：\n  - $N=80$, $L=8\\,\\text{m}$, $u=-0.4\\,\\text{m/s}$, $K=0.05\\,\\text{m}^2/\\text{s}$, $c_0=2.0\\,\\text{kg/m}^3$, $\\alpha=0.1\\,\\text{kg/m}^4$。\n\n- 用例4（退化情况，零平流和零斜率）：\n  - $N=2$, $L=1\\,\\text{m}$, $u=0.0\\,\\text{m/s}$, $K=0.2\\,\\text{m}^2/\\text{s}$, $c_0=1.0\\,\\text{kg/m}^3$, $\\alpha=0.0\\,\\text{kg/m}^4$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，八个值按以下顺序排列，并以 $\\text{kg/s}$ 为单位表示：\n$$\n[\\dot{M}_{\\text{FD},1},\\dot{M}_{\\text{FV},1},\\dot{M}_{\\text{FD},2},\\dot{M}_{\\text{FV},2},\\dot{M}_{\\text{FD},3},\\dot{M}_{\\text{FV},3},\\dot{M}_{\\text{FD},4},\\dot{M}_{\\text{FV},4}]\n$$\n其中下标表示测试用例编号。数值结果必须是浮点数。",
            "solution": "该问题要求针对一维平流-扩散过程，在时间 $t=0$ 时，推导并计算由边界通量引起的质量净变化率 $\\dot{M}_{\\text{boundary}} = F(0,t) - F(L,t)$。初始浓度为线性剖面 $c(x,0) = c_0 + \\alpha x$。面积 $A$ 是恒定的，等于 $1\\,\\text{m}^2$。通量由 $F(x,t) = A\\big(u\\,c(x,t) - K\\,\\frac{\\partial c}{\\partial x}(x,t)\\big)$ 给出。我们将分析两种数值离散化方法：有限差分（FD）和有限体积（FV）。\n\n首先，我们确定在 $t=0$ 时的精确解析值。初始浓度剖面为 $c(x,0) = c_0 + \\alpha x$。在 $t=0$ 时，精确的空间梯度在整个域内是常数：$\\frac{\\partial c}{\\partial x}(x,0) = \\alpha$。\n在 $t=0$ 时的精确边界通量为：\n$F(0,0) = A(u\\,c(0,0) - K\\,\\frac{\\partial c}{\\partial x}|_{x=0}) = A(u\\,c_0 - K\\,\\alpha)$。\n$F(L,0) = A(u\\,c(L,0) - K\\,\\frac{\\partial c}{\\partial x}|_{x=L}) = A(u\\,(c_0 + \\alpha L) - K\\,\\alpha)$。\n由边界通量引起的精确质量净变化率为：\n$\\dot{M}_{\\text{exact}} = F(0,0) - F(L,0) = A(u\\,c_0 - K\\,\\alpha) - A(u\\,(c_0+\\alpha L) - K\\,\\alpha) = A(u c_0 - K\\alpha - u c_0 - u\\alpha L + K\\alpha) = -A u \\alpha L$。\n\n**1. 有限差分（FD）方法**\n\nFD 方法使用一个基于节点的网格，有 $N+1$ 个节点 $x_j = j\\,\\Delta x$，其中 $j \\in \\{0, 1, \\dots, N\\}$，且 $\\Delta x = L/N$。在 $t=0$ 时的节点浓度为 $c_j = c(x_j,0) = c_0 + \\alpha x_j = c_0 + \\alpha j \\Delta x$。边界值为 $c_0 = c_L$ 和 $c_N = c_R$。\n\n我们必须推导在边界处梯度 $\\frac{\\partial c}{\\partial x}$ 的二阶单边有限差分公式。\n\n在左边界 $x=x_0=0$ 处，我们使用节点 $x_0$、$x_1$ 和 $x_2$。$c(x)$ 在 $x_0$ 附近的 Taylor 级数展开为：\n$c(x_1) = c(x_0+\\Delta x) = c_0 + \\Delta x \\left(\\frac{\\partial c}{\\partial x}\\right)_0 + \\frac{\\Delta x^2}{2} \\left(\\frac{\\partial^2 c}{\\partial x^2}\\right)_0 + O(\\Delta x^3)$\n$c(x_2) = c(x_0+2\\Delta x) = c_0 + 2\\Delta x \\left(\\frac{\\partial c}{\\partial x}\\right)_0 + \\frac{(2\\Delta x)^2}{2} \\left(\\frac{\\partial^2 c}{\\partial x^2}\\right)_0 + O(\\Delta x^3)$\n为了消去二阶导数项，我们计算 $4c(x_1) - c(x_2)$：\n$4c(x_1) - c(x_2) = (4c_0 + 4\\Delta x (\\frac{\\partial c}{\\partial x})_0 + 2\\Delta x^2 (\\frac{\\partial^2 c}{\\partial x^2})_0) - (c_0 + 2\\Delta x (\\frac{\\partial c}{\\partial x})_0 + 2\\Delta x^2 (\\frac{\\partial^2 c}{\\partial x^2})_0) + O(\\Delta x^3)$\n$4c(x_1) - c(x_2) = 3c_0 + 2\\Delta x \\left(\\frac{\\partial c}{\\partial x}\\right)_0 + O(\\Delta x^3)$\n求解梯度可得二阶向前差分公式：\n$\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=0, \\text{FD}} = \\frac{-3c(x_0,0) + 4c(x_1,0) - c(x_2,0)}{2\\Delta x} + O(\\Delta x^2)$。\n\n在右边界 $x=x_N=L$ 处，我们使用节点 $x_N$、$x_{N-1}$ 和 $x_{N-2}$。通过在 $x_N$ 附近进行类似的 Taylor 展开，我们推导出二阶向后差分公式：\n$\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=L, \\text{FD}} = \\frac{3c(x_N,0) - 4c(x_{N-1},0) + c(x_{N-2},0)}{2\\Delta x} + O(\\Delta x^2)$。\n\n对于初始线性剖面 $c(x,0) = c_0 + \\alpha x$，我们来评估这些梯度近似值：\n在 $x=0$ 处：$c(x_0,0)=c_0$, $c(x_1,0)=c_0+\\alpha\\Delta x$, $c(x_2,0)=c_0+2\\alpha\\Delta x$。\n$\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=0, \\text{FD}} = \\frac{-3c_0 + 4(c_0+\\alpha\\Delta x) - (c_0+2\\alpha\\Delta x)}{2\\Delta x} = \\frac{(-3+4-1)c_0 + (4\\alpha-2\\alpha)\\Delta x}{2\\Delta x} = \\frac{2\\alpha\\Delta x}{2\\Delta x} = \\alpha$。\n该近似是精确的，因为二阶公式对于最高为2次的多项式是精确的。\n\n在 $x=L$ 处：$c(x_N,0)=c_0+\\alpha L$, $c(x_{N-1},0)=c_0+\\alpha(L-\\Delta x)$, $c(x_{N-2},0)=c_0+\\alpha(L-2\\Delta x)$。\n$\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=L, \\text{FD}} = \\frac{3(c_0+\\alpha L) - 4(c_0+\\alpha(L-\\Delta x)) + (c_0+\\alpha(L-2\\Delta x))}{2\\Delta x} = \\frac{(3-4+1)(c_0+\\alpha L) + (4\\alpha-2\\alpha)\\Delta x}{2\\Delta x} = \\frac{2\\alpha\\Delta x}{2\\Delta x} = \\alpha$。\n该近似同样是精确的。\n\nFD 方法在 $t=0$ 时的边界通量为：\n$F_{\\text{FD}}(0,0) = A(u\\,c(0,0) - K\\,\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=0, \\text{FD}}) = A(u\\,c_0 - K\\,\\alpha)$。\n$F_{\\text{FD}}(L,0) = A(u\\,c(L,0) - K\\,\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=L, \\text{FD}}) = A(u\\,(c_0+\\alpha L) - K\\,\\alpha)$。\n质量净变化率为：\n$\\dot{M}_{\\text{FD}} = F_{\\text{FD}}(0,0) - F_{\\text{FD}}(L,0) = A(u\\,c_0-K\\alpha) - A(u(c_0+\\alpha L)-K\\alpha) = -A u \\alpha L$。\n这与解析结果相同。\n\n**2. 有限体积（FV）方法**\n\nFV 方法使用一个包含 $N$ 个单元的单元中心网格，其中单元 $i$ 的宽度为 $\\Delta x = L/N$，中心位于 $x_i = (i+1/2)\\Delta x$，其中 $i \\in \\{0, \\dots, N-1\\}$。域边界是位于 $x=0$ 和 $x=L$ 的单元面。单元 $i$ 在 $t=0$ 时的单元平均浓度为：\n$c_i = \\frac{1}{\\Delta x}\\int_{i\\Delta x}^{(i+1)\\Delta x} (c_0+\\alpha x)dx = c_0 + \\alpha (i+1/2)\\Delta x = c(x_i, 0)$。\n对于线性剖面，单元平均值等于单元中心处的值。\n\n面上的总通量是平流通量和扩散通量之和，$F = F_{adv} + F_{diff}$。我们在边界面 $x=0$ 和 $x=L$ 处计算这些通量。\n\n扩散通量 $F_{diff} = -A K \\frac{\\partial c}{\\partial x}$ 需要在面上进行梯度近似。问题指定在边界和最近的单元中心之间进行线性重构。\n在左侧面 $x=0$ 处，梯度使用 $x=0$ 处的边界值 $c_L=c_0$ 和 $x_{cell,0}=\\Delta x/2$ 处的单元中心值 $c_{cell,0}$ 来近似。\n$c_{cell,0} = c_0 + \\alpha (\\Delta x/2)$。\n$\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=0, \\text{FV}} = \\frac{c_{cell,0} - c_L}{x_{cell,0} - 0} = \\frac{(c_0+\\alpha\\Delta x/2) - c_0}{\\Delta x/2} = \\alpha$。\n在右侧面 $x=L$ 处，梯度使用 $x=L$ 处的边界值 $c_R=c_0+\\alpha L$ 和 $x_{cell,N-1}=L-\\Delta x/2$ 处的单元中心值 $c_{cell,N-1}$。\n$c_{cell,N-1} = c_0 + \\alpha(L-\\Delta x/2)$。\n$\\left(\\frac{\\partial c}{\\partial x}\\right)_{x=L, \\text{FV}} = \\frac{c_R - c_{cell,N-1}}{L - x_{cell,N-1}} = \\frac{(c_0+\\alpha L) - (c_0+\\alpha(L-\\Delta x/2))}{\\Delta x/2} = \\alpha$。\n对于线性初始剖面，FV 方法的扩散通量梯度近似是精确的。\n\n平流通量 $F_{adv} = A u c_{face}$ 对面上的浓度 $c_{face}$ 使用迎风格式。\n在左侧面 $x=0$ 处：\n如果 $u \\ge 0$ （从边界流入），则 $c_{face,0} = c_L = c_0$。\n如果 $u  0$ （从域内流出），则 $c_{face,0} = c_{cell,0} = c_0 + \\alpha \\Delta x/2$。\n在右侧面 $x=L$ 处：\n如果 $u > 0$ （从域内流出），则 $c_{face,L} = c_{cell,N-1} = c_0 + \\alpha(L - \\Delta x/2)$。\n如果 $u \\le 0$ （从边界流入），则 $c_{face,L} = c_R = c_0 + \\alpha L$。\n\nFV 方法在 $t=0$ 时的总边界通量为：\n$F_{\\text{FV}}(0,0) = A(u\\,c_{face,0} - K\\,\\alpha)$。\n$F_{\\text{FV}}(L,0) = A(u\\,c_{face,L} - K\\,\\alpha)$。\n质量净变化率为：\n$\\dot{M}_{\\text{FV}} = F_{\\text{FV}}(0,0) - F_{\\text{FV}}(L,0) = A u (c_{face,0} - c_{face,L})$。\n\n我们根据 $u$ 的符号对此进行分析：\n$u > 0$ 的情况：$\\dot{M}_{\\text{FV}} = A u (c_L - c_{cell,N-1}) = A u (c_0 - (c_0 + \\alpha(L - \\Delta x/2))) = -A u \\alpha(L - \\Delta x/2)$。\n$u  0$ 的情况：$\\dot{M}_{\\text{FV}} = A u (c_{cell,0} - c_R) = A u ((c_0 + \\alpha \\Delta x/2) - (c_0 + \\alpha L)) = A u \\alpha(\\Delta x/2 - L) = -A u \\alpha(L - \\Delta x/2)$。\n$u = 0$ 的情况：$\\dot{M}_{\\text{FV}} = 0$。\n\n所有情况都可用一个公式描述，代入 $\\Delta x = L/N$：\n$\\dot{M}_{\\text{FV}} = -A u \\alpha (L - \\frac{\\Delta x}{2}) = -A u \\alpha L (1 - \\frac{1}{2N})$。\n此结果与精确解不同，这是由于对平流通量项采用了一阶迎风近似。误差与 $1/N$ 成正比，并在 $N \\to \\infty$ 时消失。\n\n**用于实现的公式总结**\n给定 $A=1\\,\\text{m}^2$。\n对于有限差分方法：\n$\\dot{M}_{\\text{FD}} = -u \\alpha L$\n对于有限体积方法：\n$\\dot{M}_{\\text{FV}} = -u \\alpha L (1 - \\frac{1}{2N})$\n\n这些公式将用于计算给定测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net rate of mass change due to boundary fluxes at t=0\n    for an advection-diffusion problem using Finite Difference and Finite Volume methods.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, L, u, K, c0, alpha)\n    test_cases = [\n        # Case 1 (baseline linear profile, positive advection, nonzero diffusion)\n        (100, 10.0, 0.5, 0.1, 1.0, 0.05),\n        # Case 2 (pure advection, negative linear slope)\n        (50, 20.0, 1.2, 0.0, 0.8, -0.02),\n        # Case 3 (negative advection, positive diffusion)\n        (80, 8.0, -0.4, 0.05, 2.0, 0.1),\n        # Case 4 (degenerate case, zero advection and zero slope)\n        (2, 1.0, 0.0, 0.2, 1.0, 0.0),\n    ]\n\n    # Area A is constant and equal to 1 m^2.\n    A = 1.0\n\n    results = []\n    for N, L, u, K, c0, alpha in test_cases:\n        # --- Finite Difference (FD) Calculation ---\n        # The net rate of mass change due to boundary fluxes is M_dot = F(0) - F(L).\n        # For the FD method with second-order one-sided differences, the gradient\n        # approximation for a linear profile is exact. The resulting formula is:\n        # M_dot_FD = -A * u * alpha * L\n        M_dot_FD = -A * u * alpha * L\n\n        # --- Finite Volume (FV) Calculation ---\n        # For the FV method with upwinding for advection and linear reconstruction\n        # for the diffusive gradient, the formula is:\n        # M_dot_FV = -A * u * alpha * L * (1 - 1/(2*N))\n        # This formula holds for u > 0, u  0, and u = 0.\n        if N > 0:\n            M_dot_FV = -A * u * alpha * L * (1.0 - 1.0 / (2.0 * N))\n        else:\n            # This case should not be reached with the given test data,\n            # but as a fallback, we can consider the limit N -> infinity,\n            # though an N of 0 is physically meaningless here.\n            M_dot_FV = -A * u * alpha * L\n\n        results.append(M_dot_FD)\n        results.append(M_dot_FV)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论模型中的参数在现实世界中往往是未知或不确定的，尤其是描述复杂边界过程的参数。本练习将引导您解决一个在环境建模中普遍存在的核心问题：模型校准。通过一个稳态示踪剂输运模型，您将学习如何利用内部观测数据，通过最小二乘法来估计和校准上游的狄利克雷（Dirichlet）边界浓度 $C_0$ 和下游的罗宾（Robin）边界交换系数 $k$。这项实践将理论与实际应用联系起来，是利用模型解释和预测环境系统的关键一步。",
            "id": "3866378",
            "problem": "考虑在区间 $x \\in [0,L]$ 上建模的一维稳态、保守反应示踪剂在均匀明渠流段中的输运。其控制方程由质量守恒和菲克弥散（伴随一阶衰减）推导得出。在平流速度 $u$、弥散系数 $D$ 和一阶衰减率 $\\lambda$ 均为常数的假设下，稳态浓度 $C(x)$ 满足\n$$\nD \\frac{d^2 C}{dx^2} - u \\frac{d C}{dx} - \\lambda C = 0.\n$$\n在上游边界 $x=0$ 处，浓度由狄利克雷边界条件 $C(0)=C_0$ 给出，其中 $C_0$ 未知，必须进行校准。在下游边界 $x=L$ 处，与浓度为 $C_{\\mathrm{ext}}$ 的外部水库的交换施加了一个罗宾边界条件\n$$\n- D \\frac{dC}{dx}(L) = k \\left( C(L) - C_{\\mathrm{ext}} \\right),\n$$\n其中 $k$ 是一个非负的边界交换系数（单位为米/秒），该系数未知，必须进行校准。\n\n基本原理：从一维明渠流中标量示踪剂的质量守恒（受平流、弥散和一阶衰减影响）以及标准的狄利克雷和罗宾边界条件出发，对于常数系数，解 $C(x)$ 呈指数形式。与该线性常微分方程相关的特征方程会产生两个实特征速率 $r_1$ 和 $r_2$（或在退化情况下为重根 $r$），由此可以构建通解。边界条件决定了积分常数。校准被设定为一个最小二乘法最小化问题，通过调整未知的边界参数来最佳地复现内部浓度观测值。\n\n任务：推导解析解的结构，展示边界条件如何确定积分常数，并实现一个计算程序，通过最小化模型预测值与所提供的内部观测值之间的拟合误差平方和来校准参数对 $(C_0, k)$。校准必须遵守具有物理意义的界限：$C_0 \\ge 0$ 和 $k \\ge 0$。\n\n解析结构（请勿将其用作捷径；您必须从控制方程和边界条件推导）：对于不同的特征速率 $r_1$ 和 $r_2$，解的形式为 $C(x) = A e^{r_1 x} + B e^{r_2 x}$，其中常数 $A$ 和 $B$ 由边界条件确定。对于重特征速率 $r$，解的形式为 $C(x) = (A + B x) e^{r x}$。\n\n校准目标：给定特定位置的观测值 $\\{ (x_i, y_i ) \\}$，定义最小二乘目标函数\n$$\nJ(C_0, k) = \\sum_{i} \\left[ C_{\\text{model}}(x_i; C_0, k) - y_i \\right]^2,\n$$\n并计算满足 $C_0 \\ge 0$ 和 $k \\ge 0$ 的最小化参数 $(C_0, k)$。\n\n单位：所有距离单位必须是米，时间单位是秒，速度单位是米/秒，弥散系数单位是平方米/秒，衰减率单位是1/秒，交换系数单位是米/秒，浓度单位是毫克/升。您的程序必须返回以毫克/升为单位的 $C_0$ 和以米/秒为单位的 $k$。不涉及角度。不涉及百分比。\n\n测试套件：使用以下三个具有不同机制的科学上合理的案例来测试不同方面（理想情况、弱交换边界情况、强交换边界情况）。对于每个案例，观测值都是合成的，并与正向模型一致。\n\n- 案例 A（理想情况，中等平流和弥散，非零下游交换）：\n  - $u = 0.1$ $\\mathrm{m/s}$，$D = 10$ $\\mathrm{m^2/s}$，$\\lambda = 1\\times 10^{-4}$ $\\mathrm{s^{-1}}$，$L = 1000$ $\\mathrm{m}$，$C_{\\mathrm{ext}} = 0$ $\\mathrm{mg/L}$。\n  - 观测位置 $x$ 为 $[200, 500, 800]$ $\\mathrm{m}$。\n  - 观测浓度 $y$ 为 $[4.1630, 3.1630, 2.4171]$ $\\mathrm{mg/L}$。\n  - 用于校准的物理合理界限是 $0 \\le C_0 \\le 10$ 和 $0 \\le k \\le 0.01$。\n\n- 案例 B（边界情况，下游交换为零，即由于 $k=0$ 导致下游端为纯零通量诺伊曼边界）：\n  - $u = 0.05$ $\\mathrm{m/s}$，$D = 5$ $\\mathrm{m^2/s}$，$\\lambda = 2\\times 10^{-4}$ $\\mathrm{s^{-1}}$，$L = 200$ $\\mathrm{m}$，$C_{\\mathrm{ext}} = 0$ $\\mathrm{mg/L}$。\n  - 观测位置 $x$ 为 $[50, 120, 180]$ $\\mathrm{m}$。\n  - 观测浓度 $y$ 为 $[2.6045, 2.1921, 2.0047]$ $\\mathrm{mg/L}$。\n  - 用于校准的物理合理界限是 $0 \\le C_0 \\le 5$ 和 $0 \\le k \\le 0.01$。\n\n- 案例 C（强下游交换，罗宾边界近似于朝向外部水库的狄利克雷条件）：\n  - $u = 0.05$ $\\mathrm{m/s}$，$D = 1$ $\\mathrm{m^2/s}$，$\\lambda = 1\\times 10^{-3}$ $\\mathrm{s^{-1}}$，$L = 80$ $\\mathrm{m}$，$C_{\\mathrm{ext}} = 1$ $\\mathrm{mg/L}$。\n  - 观测位置 $x$ 为 $[10, 40, 80]$ $\\mathrm{m}$。\n  - 观测浓度 $y$ 为 $[0.4291, 0.2788, 0.2550]$ $\\mathrm{mg/L}$。\n  - 用于校准的物理合理界限是 $0 \\le C_0 \\le 2$ 和 $0 \\le k \\le 0.1$。\n\n您的程序应通过使用上述控制方程和边界条件推导出的正向模型，最小化 $J(C_0, k)$ 来为每个案例校准 $(C_0, k)$。仅使用提供的观测值和指定的参数界限。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是代表一个案例校准参数对的二元列表 $[C_0, k]$。例如，输出格式必须为 $[[C_{0,A},k_A],[C_{0,B},k_B],[C_{0,C},k_C]]$。所有返回的 $C_0$ 值单位必须是 $\\mathrm{mg/L}$，所有返回的 $k$ 值单位必须是 $\\mathrm{m/s}$。",
            "solution": "我们从一维明渠流中标量示踪剂在平流、弥散和一阶衰减作用下的基本质量守恒定律开始。在区间 $x \\in [0,L]$ 上的稳态平衡方程为\n$$\n\\frac{d}{dx} \\left( - D \\frac{d C}{dx} + u C \\right) - \\lambda C = 0,\n$$\n对于常数 $u$、$D$ 和 $\\lambda$，该方程简化为线性常微分方程\n$$\nD \\frac{d^2 C}{dx^2} - u \\frac{d C}{dx} - \\lambda C = 0.\n$$\n我们寻求形如 $C(x) = e^{r x}$ 乘以一个常数的指数形式解；代入可得特征方程\n$$\nD r^2 - u r - \\lambda = 0.\n$$\n判别式为 $\\Delta = u^2 + 4 D \\lambda \\ge 0$，因此存在两个不同的实根\n$$\nr_1 = \\frac{u + \\sqrt{u^2 + 4 D \\lambda}}{2D}, \\quad r_2 = \\frac{u - \\sqrt{u^2 + 4 D \\lambda}}{2D},\n$$\n除非 $\\Delta = 0$，此时 $r_1 = r_2 = r = \\frac{u}{2D}$ 是一个重根。对于不同根的一般情况，解为\n$$\nC(x) = A e^{r_1 x} + B e^{r_2 x},\n$$\n其中常数 $A$ 和 $B$ 由边界条件确定。上游的狄利克雷条件 $C(0)=C_0$ 指明\n$$\nA + B = C_0.\n$$\n下游的罗宾条件 $- D C'(L) = k \\left( C(L) - C_{\\mathrm{ext}} \\right)$ 给出\n$$\n- D \\left( A r_1 e^{r_1 L} + B r_2 e^{r_2 L} \\right) = k \\left( A e^{r_1 L} + B e^{r_2 L} - C_{\\mathrm{ext}} \\right).\n$$\n整理各项得到一个关于 $(A,B)$ 的 $2\\times 2$ 线性系统：\n$$\n\\begin{bmatrix}\n1  1 \\\\\n- e^{r_1 L} \\left( D r_1 + k \\right)  - e^{r_2 L} \\left( D r_2 + k \\right)\n\\end{bmatrix}\n\\begin{bmatrix}\nA \\\\ B\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nC_0 \\\\ - k C_{\\mathrm{ext}}\n\\end{bmatrix}.\n$$\n对于退化的重根情况（$r_1 = r_2 = r$），通解为\n$$\nC(x) = (A + B x) e^{r x},\n$$\n其中根据上游狄利克雷边界条件有 $A = C_0$。下游的罗宾边界条件得出\n$$\n- D \\left( B + r (A + B L) \\right) e^{r L} = k \\left( (A + B L) e^{r L} - C_{\\mathrm{ext}} \\right).\n$$\n两边同除以 $e^{r L}$ 并代入 $A = C_0$，得到一个关于 $B$ 的线性方程：\n$$\n- D \\left( B + r C_0 + r B L \\right) = k \\left( C_0 + B L - C_{\\mathrm{ext}} e^{- r L} \\right),\n$$\n该方程可以明确地解出\n$$\nB = \\frac{k \\left( C_0 - C_{\\mathrm{ext}} e^{- r L} \\right) + D r C_0}{- D (1 + r L) - k L}.\n$$\n\n在确定 $(A,B)$ 后，正向模型将 $(C_0,k)$ 映射到内部浓度。对于不同根的情况：\n$$\nC_{\\text{model}}(x; C_0, k) = A(C_0,k) e^{r_1 x} + B(C_0,k) e^{r_2 x}.\n$$\n对于重根：\n$$\nC_{\\text{model}}(x; C_0, k) = \\left( C_0 + B(C_0,k) x \\right) e^{r x}.\n$$\n\n校准问题：给定观测值 $\\{ (x_i, y_i) \\}$，定义最小二乘目标函数\n$$\nJ(C_0, k) = \\sum_{i} \\left[ C_{\\text{model}}(x_i; C_0, k) - y_i \\right]^2,\n$$\n并计算\n$$\n(C_0^\\star, k^\\star) = \\arg \\min_{C_0 \\ge 0,\\, k \\ge 0} J(C_0, k),\n$$\n同时受限于反映物理合理性的特定案例界限。\n\n算法设计：\n- 对每个案例，根据 $u$、$D$ 和 $\\lambda$ 计算 $r_1$ 和 $r_2$。如果 $|r_1 - r_2|$ 小于某个数值容差，则按重根情况处理；否则，使用不同根的情况。\n- 给定一个试验的 $(C_0, k)$，在不同根的情况下，构建并求解关于 $(A,B)$ 的 $2\\times 2$ 线性系统；或在重根情况下，直接计算 $B$。\n- 计算 $C_{\\text{model}}(x_i; C_0, k)$ 并组合残差 $r_i = C_{\\text{model}}(x_i; C_0, k) - y_i$。\n- 使用适用于有界约束非线性最小二乘问题的信赖域反射方法，在边界约束下最小化 $J(C_0,k) = \\sum_i r_i^2$。\n- 使用初始猜测值，令 $C_0$ 等于观测到的最大浓度，令 $k$ 等于一个小的正值。应用特定于案例的 $C_0$ 和 $k$ 的界限。\n\n科学真实性与可识别性考量：\n- 指数解结构严格源于常系数线性常微分方程，并与平流-弥散-反应物理过程一致。\n- 所选案例涵盖了中等平流和弥散（案例 A）、导致诺伊曼边界的零下游交换（案例 B）以及近似于朝向外部水库的狄利克雷边界的强下游交换（案例 C）等不同机制。\n- 每个案例至少有三个内部观测位置，为两个边界参数提供了一个超定系统，从而确保了稳定的最小二乘校准。\n\n输出：\n- 返回一行包含校准参数对列表的数据，格式为 $[[C_{0,A},k_A],[C_{0,B},k_B],[C_{0,C},k_C]]$，其中 $C_0$ 的单位是 $\\mathrm{mg/L}$，$k$ 的单位是 $\\mathrm{m/s}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef characteristic_rates(u, D, lam):\n    # Compute characteristic rates r1, r2 for the ODE: D r^2 - u r - lam = 0\n    disc = u*u + 4.0*D*lam\n    sqrt_disc = np.sqrt(disc)\n    r1 = (u + sqrt_disc) / (2.0*D)\n    r2 = (u - sqrt_disc) / (2.0*D)\n    return r1, r2\n\ndef forward_profile_distinct_roots(u, D, lam, L, Cext, C0, k, xs):\n    # Distinct roots case: C(x) = A e^{r1 x} + B e^{r2 x}\n    r1, r2 = characteristic_rates(u, D, lam)\n    # If roots are nearly equal, delegate to repeated root handler\n    if abs(r1 - r2)  1e-12:\n        return forward_profile_repeated_root(u, D, lam, L, Cext, C0, k, xs)\n    E1L = np.exp(r1 * L)\n    E2L = np.exp(r2 * L)\n    # Construct and solve for A, B from boundary conditions\n    # Row1: A + B = C0\n    # Row2: -D * (A*r1*e^{r1 L} + B*r2*e^{r2 L}) = k * (A*e^{r1 L} + B*e^{r2 L} - Cext)\n    M = np.array([\n        [1.0, 1.0],\n        [-E1L * (D * r1 + k), -E2L * (D * r2 + k)]\n    ])\n    rhs = np.array([C0, -k * Cext])\n    # Solve linear system robustly\n    try:\n        AB = np.linalg.solve(M, rhs)\n    except np.linalg.LinAlgError:\n        # Fallback to least-squares solve if singular\n        AB, *_ = np.linalg.lstsq(M, rhs, rcond=None)\n    A, B = AB[0], AB[1]\n    xs = np.asarray(xs)\n    Cx = A * np.exp(r1 * xs) + B * np.exp(r2 * xs)\n    return Cx\n\ndef forward_profile_repeated_root(u, D, lam, L, Cext, C0, k, xs):\n    # Repeated root case: r1 == r2 == r, solution C(x) = (A + B x) e^{r x}, with A = C0\n    r1, r2 = characteristic_rates(u, D, lam)\n    r = 0.5 * (r1 + r2)\n    A = C0\n    e_rL = np.exp(r * L)\n    denom = -D * (1.0 + r * L) - k * L\n    # To avoid division by zero, perturb denominator slightly if nearly zero\n    if abs(denom)  1e-18:\n        denom = np.sign(denom) * 1e-18 if denom != 0 else 1e-18\n    B = (k * (C0 - Cext * np.exp(-r * L)) + D * r * C0) / denom\n    xs = np.asarray(xs)\n    Cx = (A + B * xs) * np.exp(r * xs)\n    return Cx\n\ndef forward_model(u, D, lam, L, Cext, C0, k, xs):\n    r1, r2 = characteristic_rates(u, D, lam)\n    if abs(r1 - r2)  1e-12:\n        return forward_profile_repeated_root(u, D, lam, L, Cext, C0, k, xs)\n    else:\n        return forward_profile_distinct_roots(u, D, lam, L, Cext, C0, k, xs)\n\ndef calibrate_case(u, D, lam, L, Cext, xs, ys, bounds_C0, bounds_k):\n    xs = np.asarray(xs, dtype=float)\n    ys = np.asarray(ys, dtype=float)\n\n    # Initial guess: C0 ~ max observed concentration, k ~ small positive\n    C0_init = max(float(np.max(ys)), bounds_C0[0])\n    C0_init = min(C0_init, bounds_C0[1])\n    k_init = max(1e-3, bounds_k[0])\n    k_init = min(k_init, bounds_k[1])\n\n    def residuals(params):\n        C0, k = params\n        Cpred = forward_model(u, D, lam, L, Cext, C0, k, xs)\n        return Cpred - ys\n\n    # Bounds for least_squares\n    lower_bounds = [bounds_C0[0], bounds_k[0]]\n    upper_bounds = [bounds_C0[1], bounds_k[1]]\n\n    res = least_squares(\n        residuals,\n        x0=np.array([C0_init, k_init]),\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-12,\n        xtol=1e-12,\n        gtol=1e-12,\n        max_nfev=10000\n    )\n    C0_hat, k_hat = float(res.x[0]), float(res.x[1])\n    return C0_hat, k_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Moderate advection/dispersion, nonzero downstream exchange\n        {\n            \"u\": 0.1, \"D\": 10.0, \"lam\": 1e-4, \"L\": 1000.0, \"Cext\": 0.0,\n            \"xs\": [200.0, 500.0, 800.0],\n            \"ys\": [4.1630, 3.1630, 2.4171],\n            \"bounds_C0\": (0.0, 10.0),\n            \"bounds_k\": (0.0, 0.01),\n        },\n        # Case B: Zero downstream exchange (Neumann zero-flux at downstream)\n        {\n            \"u\": 0.05, \"D\": 5.0, \"lam\": 2e-4, \"L\": 200.0, \"Cext\": 0.0,\n            \"xs\": [50.0, 120.0, 180.0],\n            \"ys\": [2.6045, 2.1921, 2.0047],\n            \"bounds_C0\": (0.0, 5.0),\n            \"bounds_k\": (0.0, 0.01),\n        },\n        # Case C: Strong downstream exchange (Robin close to Dirichlet at downstream)\n        {\n            \"u\": 0.05, \"D\": 1.0, \"lam\": 1e-3, \"L\": 80.0, \"Cext\": 1.0,\n            \"xs\": [10.0, 40.0, 80.0],\n            \"ys\": [0.4291, 0.2788, 0.2550],\n            \"bounds_C0\": (0.0, 2.0),\n            \"bounds_k\": (0.0, 0.1),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        C0_hat, k_hat = calibrate_case(\n            u=case[\"u\"], D=case[\"D\"], lam=case[\"lam\"], L=case[\"L\"], Cext=case[\"Cext\"],\n            xs=case[\"xs\"], ys=case[\"ys\"],\n            bounds_C0=case[\"bounds_C0\"], bounds_k=case[\"bounds_k\"]\n        )\n        # Round results to a reasonable number of decimals for clean output\n        C0_hat_r = round(C0_hat, 6)\n        k_hat_r = round(k_hat, 6)\n        results.append([C0_hat_r, k_hat_r])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在复杂的环境系统中，确定哪些初始或边界条件对模型的预测结果影响最大，是进行有效预测和控制的关键。本练习将带您进入高级模型分析领域，介绍并实践伴随方法（Adjoint Method）这一强大的敏感性分析工具。您将通过拉格朗日乘子法从一个离散的平流扩散模型出发，亲手推导并实现其伴随模型，从而高效地计算出模型预测结果相对于所有初始条件和边界参数的精确梯度。这项技能是大规模数据同化、参数优化和模型诊断（例如在天气和气候模型中）的基石。",
            "id": "3866393",
            "problem": "考虑一个一维被动示踪剂，其由线性平流扩散守恒律控制，并在均匀网格上通过一阶迎风平流和二阶中心扩散格式进行离散化。计算域为区间 $[0,L]$，具有 $N$ 个内部自由度。设空间网格间距为 $\\Delta x = L/(N-1)$，时间步长为 $\\Delta t$。平流速度为 $u$，扩散系数为 $\\kappa$。定义 Courant–Friedrichs–Lewy 参数 $\\text{CFL} = u\\,\\Delta t/\\Delta x$ 和扩散参数 $\\mu = \\kappa\\,\\Delta t/\\Delta x^2$。在时间步 $n$，内部浓度 $\\mathbf{c}^n \\in \\mathbb{R}^N$ 的离散正演模型为\n$$\nc_i^{n+1} = c_i^n - \\text{CFL}\\,(c_i^n - c_{i-1}^n) + \\mu\\,(c_{i+1}^n - 2c_i^n + c_{i-1}^n),\n$$\n对于 $i=0,1,\\dots,N-1$，其中通过虚拟值 $c_{-1}^n = b^n$ 强制施加 Dirichlet 入流边界条件，并通过 $c_N^n = c_{N-1}^n$ 实现零梯度出流。标量边界强迫 $b^n$ 由 $b^n = \\alpha\\,g_n$ 给出，其中 $\\alpha$ 是一个恒定振幅，$g_n$ 是一个给定的无量纲时间序列。该离散模型可以写成仿射线性形式\n$$\n\\mathbf{c}^{n+1} = A\\,\\mathbf{c}^n + \\mathbf{s}\\,b^n,\n$$\n其中 $A \\in \\mathbb{R}^{N\\times N}$ 是由该格式和边界封闭所导出的时不变更新矩阵，$\\mathbf{s} \\in \\mathbb{R}^N$ 表示入流边界 $b^n$ 如何进入离散模板的第一行。\n\n定义目标泛函\n$$\nJ(\\mathbf{c}^0,\\alpha) = c_j^{N_t},\n$$\n即在最终时间步 $N_t$ 时，指定网格索引 $j$ 处的浓度。任务是：\n- 从第一性原理出发，以离散守恒更新和变分法为起点，推导线性时间步进系统对应的离散伴随方程，包括终端条件和递推关系，并获得敏感度 $\\nabla_{\\mathbf{c}^0} J$ 和 $\\frac{dJ}{d\\alpha}$ 的表达式。\n- 实现一个程序，使用伴随方程计算这些敏感度，并与有限差分近似进行验证。使用无量纲量，并将所有输出表示为不带单位的十进制浮点数。\n\n请将您的推导建立在基本的物理和数学原理之上：质量守恒、对线性平流和扩散的有限差分近似的一致性，以及离散时间步进系统的线性代数。不要引用或从任何现成的伴随公式开始；通过对由正演模型和目标泛函构造的适当的拉格朗日量强制施加驻定性来推导它们。\n\n使用以下三个科学上合理的参数集组成的测试套件，这些参数集涵盖了不同的输运机制以及边界/初始条件影响。对于每种情况，计算两个量：(i) 关于初始条件的伴随敏感度与有限差分近似在所有网格分量上的最大绝对差，以及 (ii) 关于 $\\alpha$ 的伴随敏感度与有限差分近似的绝对差。在所有情况下，通过一个稳定性感知安全因子来选择 $\\Delta t$，该因子等于平流和扩散显式限制中较小者的 $0.8$ 倍，即，\n$$\n\\Delta t = 0.8 \\times \\min\\left(\\frac{\\Delta x}{u}, \\frac{\\Delta x^2}{2\\kappa}\\right)\n$$\n当 $u0$ 时，以及\n$$\n\\Delta t = 0.8 \\times \\frac{\\Delta x^2}{2\\kappa}\n$$\n当 $u=0$ 时。使用 $N_t = \\lceil T / \\Delta t \\rceil$，然后重置 $\\Delta t = T/N_t$。\n\n情况 1（中等平流扩散，恒定入流）：\n- $N = 50$，$L = 1$，$T = 0.3$，$u = 0.6$，$\\kappa = 0.01$，$j = 35$。\n- 初始条件：对于所有 $i$，$c_i^0 = 0$。\n- 边界时间序列：对于所有 $n$，$g_n = 1$。\n- 振幅：$\\alpha = 0.8$。\n\n情况 2（扩散主导，非平凡初始条件，三角波入流）：\n- $N = 60$，$L = 1$，$T = 0.2$，$u = 0$，$\\kappa = 0.02$，$j = 10$。\n- 初始条件：$c_i^0 = \\exp\\!\\big(-((x_i - 0.3)^2)/0.01\\big)$，其中 $x_i = i\\,\\Delta x$。\n- 边界时间序列：$g_n = 1 - 2\\left| \\frac{n}{N_t} - \\frac{1}{2} \\right|$，对于 $n=0,1,\\dots,N_t-1$。\n- 振幅：$\\alpha = 0.5$。\n\n情况 3（平流主导，振荡入流）：\n- $N = 80$，$L = 1$，$T = 0.25$，$u = 1.0$，$\\kappa = 10^{-4}$，$j = 70$。\n- 初始条件：对于所有 $i$，$c_i^0 = 0$。\n- 边界时间序列：$g_n = \\sin\\!\\left(2\\pi\\,\\frac{n}{N_t}\\right)$，对于 $n=0,1,\\dots,N_t-1$。\n- 振幅：$\\alpha = 1.2$。\n\n用于验证的有限差分应使用一个小的增量 $\\varepsilon$ 应用于 $\\mathbf{c}^0$ 的每个分量和 $\\alpha$，计算单边差分。您的程序应生成单行输出，其中包含结果，格式为每个案例列表的逗号分隔列表，严格遵循以下格式：\n$$\n[[e_1^{\\text{init}},e_1^{\\alpha}],[e_2^{\\text{init}},e_2^{\\alpha}],[e_3^{\\text{init}},e_3^{\\alpha}]]\n$$\n其中 $e_k^{\\text{init}}$ 是案例 $k$ 中与 $\\nabla_{\\mathbf{c}^0} J$ 相关的最大绝对差，而 $e_k^{\\alpha}$ 是案例 $k$ 中与 $\\frac{dJ}{d\\alpha}$ 相关的绝对差。所有输出必须是无量纲的十进制浮点数，不带单位，并严格按照带括号的列表的列表格式打印在单行上，使用逗号且无空格。",
            "solution": "该问题要求推导一维平流扩散模型的离散伴随方程，并实现一个程序来计算关于初始条件 $\\mathbf{c}^0$ 和边界振幅参数 $\\alpha$ 的敏感度。推导将使用拉格朗日乘子法从第一性原理进行，其结果将与有限差分近似进行验证。\n\n### 步骤 1：问题陈述的验证\n\n该问题经过了严格的验证程序。\n\n#### 步骤 1.1：提取给定条件\n- **控制定律**：一维线性平流扩散，$c_t + u c_x = (\\kappa c_x)_x$。\n- **离散化**：均匀网格上的一阶迎风平流，二阶中心扩散。\n- **域和网格**：$[0,L]$，有 $N$ 个内部点，$\\Delta x = L/(N-1)$。\n- **参数**：速度 $u$，扩散系数 $\\kappa$。\n- **无量纲数**：$\\text{CFL} = u\\Delta t/\\Delta x$，$\\mu = \\kappa\\Delta t/\\Delta x^2$。\n- **离散更新规则**：对于 $i=0, \\dots, N-1$，$c_i^{n+1} = c_i^n - \\text{CFL}(c_i^n - c_{i-1}^n) + \\mu(c_{i+1}^n - 2c_i^n + c_{i-1}^n)$。\n- **边界条件**：\n  - 入流（左侧）：Dirichlet，通过虚拟单元 $c_{-1}^n = b^n$ 实现。\n  - 出流（右侧）：零梯度，通过 $c_N^n = c_{N-1}^n$ 实现。\n- **边界强迫**：$b^n = \\alpha g_n$，其中 $\\alpha$ 为常数，$g_n$ 为给定的时间序列。\n- **矩阵形式**：$\\mathbf{c}^{n+1} = A\\mathbf{c}^n + \\mathbf{s}b^n$。\n- **目标泛函**：$J(\\mathbf{c}^0,\\alpha) = c_j^{N_t}$，对于给定的索引 $j$ 和最终时间步 $N_t$。\n- **任务**：\n  1.  使用变分法推导离散伴随方程。\n  2.  获得 $\\nabla_{\\mathbf{c}^0} J$ 和 $\\frac{dJ}{d\\alpha}$ 的表达式。\n  3.  实现一个程序来计算敏感度，并与有限差分进行验证。\n- **时间步计算**：\n  - 对于 $u0$：$\\Delta t = 0.8 \\times \\min(\\frac{\\Delta x}{u}, \\frac{\\Delta x^2}{2\\kappa})$。\n  - 对于 $u=0$：$\\Delta t = 0.8 \\times \\frac{\\Delta x^2}{2\\kappa}$。\n  - 最终确定：$N_t = \\lceil T / \\Delta t \\rceil$，然后 $\\Delta t := T/N_t$。\n- **测试案例**：提供了三个具体的参数集。\n- **输出**：关于 $\\nabla_{\\mathbf{c}^0}J$ 敏感度的最大绝对差和关于 $\\frac{dJ}{d\\alpha}$ 敏感度的绝对差，格式为列表的列表。\n\n#### 步骤 1.2：验证与结论\n对问题的有效性进行评估：\n- **有科学依据**：该问题涉及离散偏微分方程的伴随敏感度分析，这是科学计算、优化和数据同化中一种基础且广泛使用的技术。物理模型和数值格式都是标准的。此标准已满足。\n- **适定的**：提供了所有必要的参数、初始/边界条件和定义。目标陈述清晰。问题是自洽的，并允许唯一解。此标准已满足。\n- **客观的**：问题以精确的数学和计算术语表述，没有模糊性或主观解释。此标准已满足。\n\n不存在科学上不健全、不完整、矛盾或不可行等缺陷。该问题是计算科学中一个标准的、非平凡的练习。\n\n**结论**：该问题是有效的。\n\n### 步骤 2：离散伴随模型的推导\n\n推导通过构建一个拉格朗日量并应用变分法从第一性原理进行。\n\n#### 2.1. 拉格朗日公式化\n系统受一组约束控制，这些约束表示从时间步 $n=0$ 到 $N_t-1$ 的时间演化：\n$$ \\mathbf{c}^{n+1} - A\\mathbf{c}^n - \\mathbf{s}b^n = \\mathbf{0} \\quad \\text{for } n = 0, 1, \\dots, N_t-1 $$\n其中 $b^n = \\alpha g_n$。目标是 $J = c_j^{N_t} = \\mathbf{e}_j^T \\mathbf{c}^{N_t}$，其中 $\\mathbf{e}_j$ 是 $\\mathbb{R}^N$ 中的第 $j$ 个标准基向量。\n\n我们为每个约束引入一个拉格朗日乘子（伴随变量）向量 $\\boldsymbol{\\lambda}^{n+1} \\in \\mathbb{R}^N$。拉格朗日量 $\\mathcal{L}$ 是由约束增广的目标泛函：\n$$ \\mathcal{L}(\\{\\mathbf{c}^n\\}, \\alpha, \\{\\boldsymbol{\\lambda}^n\\}) = J(\\mathbf{c}^{N_t}) - \\sum_{n=0}^{N_t-1} (\\boldsymbol{\\lambda}^{n+1})^T \\left( \\mathbf{c}^{n+1} - A\\mathbf{c}^n - \\mathbf{s}\\alpha g_n \\right) $$\n\n#### 2.2. 变分分析\n为了找到敏感度，我们计算 $\\mathcal{L}$ 关于状态变量 $\\{\\mathbf{c}^n\\}$ 以及参数 $\\mathbf{c}^0$ 和 $\\alpha$ 的一阶变分。\n$$ \\delta\\mathcal{L} = \\frac{\\partial J}{\\partial \\mathbf{c}^{N_t}} \\delta\\mathbf{c}^{N_t} - \\sum_{n=0}^{N_t-1} (\\boldsymbol{\\lambda}^{n+1})^T \\left( \\delta\\mathbf{c}^{n+1} - A\\delta\\mathbf{c}^n - \\mathbf{s} g_n \\delta\\alpha \\right) $$\n我们展开求和并按变分类型（$\\delta\\mathbf{c}^n$, $\\delta\\alpha$）收集各项：\n$$ \\delta\\mathcal{L} = \\frac{\\partial J}{\\partial \\mathbf{c}^{N_t}} \\delta\\mathbf{c}^{N_t} - \\sum_{n=0}^{N_t-1} (\\boldsymbol{\\lambda}^{n+1})^T \\delta\\mathbf{c}^{n+1} + \\sum_{n=0}^{N_t-1} (\\boldsymbol{\\lambda}^{n+1})^T A\\delta\\mathbf{c}^n + \\delta\\alpha \\sum_{n=0}^{N_t-1} g_n (\\boldsymbol{\\lambda}^{n+1})^T \\mathbf{s} $$\n为了分离每个 $\\delta\\mathbf{c}^n$ 的系数，我们通过令 $k=n+1$ 对第一个求和重新索引：\n$$ \\sum_{n=0}^{N_t-1} (\\boldsymbol{\\lambda}^{n+1})^T \\delta\\mathbf{c}^{n+1} = \\sum_{k=1}^{N_t} (\\boldsymbol{\\lambda}^k)^T \\delta\\mathbf{c}^k = (\\boldsymbol{\\lambda}^{N_t})^T \\delta\\mathbf{c}^{N_t} + \\sum_{n=1}^{N_t-1} (\\boldsymbol{\\lambda}^n)^T \\delta\\mathbf{c}^n $$\n第二个求和在 $n=0$ 处分开：\n$$ \\sum_{n=0}^{N_t-1} (\\boldsymbol{\\lambda}^{n+1})^T A\\delta\\mathbf{c}^n = (\\boldsymbol{\\lambda}^1)^T A\\delta\\mathbf{c}^0 + \\sum_{n=1}^{N_t-1} (\\boldsymbol{\\lambda}^{n+1})^T A\\delta\\mathbf{c}^n $$\n将这些代回 $\\delta\\mathcal{L}$ 并按变分组项：\n$$ \\delta\\mathcal{L} = \\left(\\frac{\\partial J}{\\partial \\mathbf{c}^{N_t}} - (\\boldsymbol{\\lambda}^{N_t})^T\\right)\\delta\\mathbf{c}^{N_t} + \\sum_{n=1}^{N_t-1} \\left((A^T\\boldsymbol{\\lambda}^{n+1})^T - (\\boldsymbol{\\lambda}^n)^T\\right) \\delta\\mathbf{c}^n  + (A^T\\boldsymbol{\\lambda}^1)^T \\delta\\mathbf{c}^0 + \\delta\\alpha \\left(\\sum_{n=0}^{N_t-1} g_n \\mathbf{s}^T \\boldsymbol{\\lambda}^{n+1} \\right) $$\n\n#### 2.3. 伴随方程\n伴随方法定义拉格朗日乘子 $\\boldsymbol{\\lambda}^n$，使得乘以中间状态变分 $\\delta\\mathbf{c}^n$（对于 $n=1, \\dots, N_t$）的项为零。这导致一个沿时间向后求解的方程组。\n\n1.  **终端条件**：从 $\\delta\\mathbf{c}^{N_t}$ 的系数得到：\n    $$ (\\boldsymbol{\\lambda}^{N_t})^T = \\frac{\\partial J}{\\partial \\mathbf{c}^{N_t}} = (\\mathbf{e}_j)^T \\implies \\boldsymbol{\\lambda}^{N_t} = \\mathbf{e}_j $$\n\n2.  **伴随递推**：从 $\\delta\\mathbf{c}^n$ 的系数（对于 $n=N_t-1, \\dots, 1$）得到：\n    $$ (\\boldsymbol{\\lambda}^n)^T = (A^T\\boldsymbol{\\lambda}^{n+1})^T \\implies \\boldsymbol{\\lambda}^n = A^T \\boldsymbol{\\lambda}^{n+1} $$\n\n#### 2.4. 敏感度表达式\n通过满足伴随方程，变分 $\\delta\\mathcal{L}$ 简化为仅依赖于参数 $\\mathbf{c}^0$ 和 $\\alpha$ 的变分。对于正演模型的一个解，目标泛函的全导数等于拉格朗日量相对于参数的变分：\n$$ dJ = \\delta\\mathcal{L} = (A^T\\boldsymbol{\\lambda}^1)^T \\delta\\mathbf{c}^0 + \\delta\\alpha \\left(\\sum_{n=0}^{N_t-1} g_n \\mathbf{s}^T \\boldsymbol{\\lambda}^{n+1} \\right) $$\n由此，我们确定梯度：\n1.  **关于 $\\mathbf{c}^0$ 的敏感度**：梯度 $\\nabla_{\\mathbf{c}^0} J$ 是一个向量，其与 $\\delta\\mathbf{c}^0$ 的点积给出第一项。\n    $$ \\nabla_{\\mathbf{c}^0} J = (A^T \\boldsymbol{\\lambda}^1)^T = (\\boldsymbol{\\lambda}^1)^T A $$\n    转置后得到 $\\nabla_{\\mathbf{c}^0} J = A^T \\boldsymbol{\\lambda}^1$。通过将伴随递推再向前推一步以找到 $\\boldsymbol{\\lambda}^0 = A^T \\boldsymbol{\\lambda}^1$，我们得到简洁的形式：\n    $$ \\nabla_{\\mathbf{c}^0} J = \\boldsymbol{\\lambda}^0 $$\n\n2.  **关于 $\\alpha$ 的敏感度**：\n    $$ \\frac{dJ}{d\\alpha} = \\sum_{n=0}^{N_t-1} g_n \\mathbf{s}^T \\boldsymbol{\\lambda}^{n+1} $$\n    该敏感度在伴随模型的后向积分过程中累积。\n\n### 步骤 3：系统矩阵的显式形式\n矩阵 $A \\in \\mathbb{R}^{N\\times N}$ 和向量 $\\mathbf{s} \\in \\mathbb{R}^N$ 是通过写出每个网格索引 $i=0, \\dots, N-1$ 的更新方程来推导的。\n\n通用模板是 $c_i^{n+1} = (\\mu-\\text{CFL}) c_{i-1}^n + (1 - \\text{CFL} - 2\\mu) c_i^n + \\mu c_{i+1}^n$。\n\n-   **节点 $i=0$ (入流边界)**：我们使用虚拟单元条件 $c_{-1}^n = b^n$：\n    $c_0^{n+1} = c_0^n - \\text{CFL}(c_0^n - b^n) + \\mu(c_1^n - 2c_0^n + b^n)$\n    $c_0^{n+1} = (1 - \\text{CFL} - 2\\mu) c_0^n + \\mu c_1^n + (\\text{CFL} + \\mu)b^n$。\n    这给出了 $A$ 的第一行：$A_{0,0} = 1-\\text{CFL}-2\\mu$，$A_{0,1} = \\mu$。\n    它也定义了向量 $\\mathbf{s}$：$\\mathbf{s} = [\\text{CFL}+\\mu, 0, \\dots, 0]^T$。\n\n-   **节点 $i=1, \\dots, N-2$ (内部)**：直接应用模板：\n    $A_{i, i-1} = \\mu - \\text{CFL}$。\n    $A_{i, i} = 1 - \\text{CFL} - 2\\mu$。\n    $A_{i, i+1} = \\mu$。\n\n-   **节点 $i=N-1$ (出流边界)**：我们使用零梯度条件 $c_N^n = c_{N-1}^n$：\n    $c_{N-1}^{n+1} = c_{N-1}^n - \\text{CFL}(c_{N-1}^n - c_{N-2}^n) + \\mu(c_{N-1}^n - 2c_{N-1}^n + c_{N-2}^n)$\n    $c_{N-1}^{n+1} = (\\mu - \\text{CFL})c_{N-2}^n + (1 - \\text{CFL} - \\mu)c_{N-1}^n$。\n    这给出了 $A$ 的最后一行：$A_{N-1, N-2} = \\mu - \\text{CFL}$，$A_{N-1, N-1} = 1 - \\text{CFL} - \\mu$。\n\n### 步骤 4：计算算法\n对于每个测试案例，执行以下程序：\n1.  **设置**：计算 $\\Delta x$，基于稳定性规则的初始 $\\Delta t$，$N_t$，以及最终的 $\\Delta t=T/N_t$。然后计算 CFL 和 $\\mu$。构造矩阵 $A$ 和向量 $\\mathbf{s}$。\n2.  **正演模拟**：从给定的 $\\mathbf{c}^0$ 和 $\\alpha$ 开始，对 $n=0, \\dots, N_t-1$ 迭代正演模型 $\\mathbf{c}^{n+1} = A\\mathbf{c}^n + \\mathbf{s}\\alpha g_n$。结果是基础目标泛函值 $J = c_j^{N_t}$。\n3.  **伴随模拟**：\n    - 初始化终端伴随状态 $\\boldsymbol{\\lambda}^{N_t} = \\mathbf{e}_j$。\n    - 初始化敏感度 $\\frac{dJ}{d\\alpha} = 0$。\n    - 从 $n=N_t-1$ 向下迭代至 $0$：\n        - 累积敏感度：$\\frac{dJ}{d\\alpha} \\leftarrow \\frac{dJ}{d\\alpha} + g_n \\mathbf{s}^T \\boldsymbol{\\lambda}^{n+1}$。\n        - 更新伴随状态：$\\boldsymbol{\\lambda}^n = A^T \\boldsymbol{\\lambda}^{n+1}$。\n    - 最终的伴随状态 $\\boldsymbol{\\lambda}^0$ 即为敏感度 $\\nabla_{\\mathbf{c}^0} J$。\n4.  **有限差分验证**：\n    - 对于 $\\nabla_{\\mathbf{c}^0} J$：对每个分量 $k=0, \\dots, N-1$，扰动初始条件 $\\mathbf{c}^0_{pert} = \\mathbf{c}^0 + \\varepsilon \\mathbf{e}_k$，重新运行正演模型得到 $J_{pert}$，并计算有限差分导数 $(J_{pert} - J)/\\varepsilon$。\n    - 对于 $\\frac{dJ}{d\\alpha}$：扰动振幅 $\\alpha_{pert} = \\alpha + \\varepsilon$，重新运行正演模型得到 $J_{pert}$，并计算 $(J_{pert}-J)/\\varepsilon$。\n5.  **误差计算**：计算伴随敏感度与有限差分敏感度之间关于 $\\nabla_{\\mathbf{c}^0}J$ 的最大绝对差，以及关于 $\\frac{dJ}{d\\alpha}$ 的绝对差。\n至此，完成了所需计算过程的推导和说明。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and verifies adjoint sensitivities for a 1D advection-diffusion problem.\n    \"\"\"\n    \n    def run_forward_model(c0, alpha, g_series, Nt, A, s):\n        \"\"\"Runs the forward time-stepping model.\"\"\"\n        c = c0.copy()\n        for n in range(Nt):\n            bn = alpha * g_series[n]\n            c = A @ c + s * bn\n        return c\n\n    def compute_and_verify(params):\n        \"\"\"\n        Main logic for a single test case: sets up, runs forward/adjoint, \n        verifies with finite differences, and computes errors.\n        \"\"\"\n        N = params['N']\n        L = params['L']\n        T = params['T']\n        u = params['u']\n        kappa = params['kappa']\n        j = params['j']\n        c0_func = params['c0_func']\n        g_func = params['g_func']\n        alpha = params['alpha']\n        \n        # 1. Setup\n        dx = L / (N - 1)\n        \n        # Calculate dt based on stability\n        if u > 0:\n            dt_pre = 0.8 * min(dx / u, dx**2 / (2 * kappa))\n        else: # u == 0\n            dt_pre = 0.8 * (dx**2 / (2 * kappa))\n\n        Nt = int(np.ceil(T / dt_pre))\n        dt = T / Nt\n\n        cfl = u * dt / dx\n        mu = kappa * dt / dx**2\n        \n        # Construct matrix A and vector s\n        A = np.zeros((N, N))\n        s = np.zeros(N)\n        \n        # Row i=0\n        A[0, 0] = 1.0 - cfl - 2.0 * mu\n        A[0, 1] = mu\n        s[0] = cfl + mu\n        \n        # Rows i=1 to N-2\n        for i in range(1, N - 1):\n            A[i, i-1] = mu - cfl\n            A[i, i]   = 1.0 - cfl - 2.0 * mu\n            A[i, i+1] = mu\n        \n        # Row i=N-1\n        A[N-1, N-2] = mu - cfl\n        A[N-1, N-1] = 1.0 - cfl - mu\n        \n        At = A.T\n        \n        # Initial condition and boundary forcing time series\n        x = np.linspace(0, L, N)\n        c0 = c0_func(x, N)\n        g_series = g_func(Nt)\n        \n        # 2. Forward Simulation (Base run)\n        c_final_base = run_forward_model(c0, alpha, g_series, Nt, A, s)\n        J_base = c_final_base[j]\n\n        # 3. Adjoint Simulation\n        lambda_next = np.zeros(N)\n        lambda_next[j] = 1.0\n        \n        dJ_dalpha_adj = 0.0\n        \n        for n in range(Nt - 1, -1, -1):\n            dJ_dalpha_adj += g_series[n] * np.dot(s, lambda_next)\n            lambda_curr = At @ lambda_next\n            lambda_next = lambda_curr\n        \n        dJ_dc0_adj = lambda_next\n\n        # 4. Finite-Difference Verification\n        epsilon = 1e-7\n\n        # Verification for dJ/dc0\n        dJ_dc0_fd = np.zeros(N)\n        for k in range(N):\n            c0_pert = c0.copy()\n            c0_pert[k] += epsilon\n            c_final_pert = run_forward_model(c0_pert, alpha, g_series, Nt, A, s)\n            J_pert = c_final_pert[j]\n            dJ_dc0_fd[k] = (J_pert - J_base) / epsilon\n            \n        # Verification for dJ/dalpha\n        alpha_pert = alpha + epsilon\n        c_final_pert_alpha = run_forward_model(c0, alpha_pert, g_series, Nt, A, s)\n        J_pert_alpha = c_final_pert_alpha[j]\n        dJ_dalpha_fd = (J_pert_alpha - J_base) / epsilon\n        \n        # 5. Error Calculation\n        e_init = np.max(np.abs(dJ_dc0_adj - dJ_dc0_fd))\n        e_alpha = np.abs(dJ_dalpha_adj - dJ_dalpha_fd)\n        \n        return [e_init, e_alpha]\n\n    test_cases = [\n        {\n            'N': 50, 'L': 1.0, 'T': 0.3, 'u': 0.6, 'kappa': 0.01, 'j': 35,\n            'c0_func': lambda x, N: np.zeros(N),\n            'g_func': lambda Nt: np.ones(Nt),\n            'alpha': 0.8\n        },\n        {\n            'N': 60, 'L': 1.0, 'T': 0.2, 'u': 0.0, 'kappa': 0.02, 'j': 10,\n            'c0_func': lambda x, N: np.exp(-((x - 0.3)**2) / 0.01),\n            'g_func': lambda Nt: 1.0 - 2.0 * np.abs(np.arange(Nt) / Nt - 0.5),\n            'alpha': 0.5\n        },\n        {\n            'N': 80, 'L': 1.0, 'T': 0.25, 'u': 1.0, 'kappa': 1e-4, 'j': 70,\n            'c0_func': lambda x, N: np.zeros(N),\n            'g_func': lambda Nt: np.sin(2.0 * np.pi * np.arange(Nt) / Nt),\n            'alpha': 1.2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = compute_and_verify(case)\n        results.append(f\"[{errors[0]},{errors[1]}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}