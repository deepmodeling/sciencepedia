{
    "hands_on_practices": [
        {
            "introduction": "冯·诺依曼稳定性分析是评估线性偏微分方程有限差分格式稳定性的基本工具。通过分析数值误差的各个傅里叶模式如何随时间演化，我们可以推导出稳定模拟所需的时间步长和网格间距的严格条件。这个基础练习将指导您将此分析应用于线性平流方程的一阶迎风格式 ，这是地球系统科学中许多输运模型的核心构建模块。",
            "id": "3950212",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其平流速度 $a > 0$ 为常数，该方程是计算流体力学（CFD）中的一个典型输运模型。区域被视为周期性或无限大，空间网格是均匀的，节点为 $x_{j} = j\\,\\Delta x$（$j$ 为整数），时间层为 $t^{n} = n\\,\\Delta t$（$n$ 为整数）。定义 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。使用适用于 $a>0$ 的一阶迎风空间差分和前向欧拉时间积分来离散该方程，形成将 $u_{j}^{n}$ 更新至 $u_{j}^{n+1}$ 的显式格式。从线性平流模型以及时间上的前向差分和空间上的迎风差分的定义出发，通过代入单个傅里叶模 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$（其中 $i = \\sqrt{-1}$，$\\theta$ 是无量纲波数）来进行 von Neumann (傅里叶) 稳定性分析。推导由 $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$ 定义的放大因子 $G(\\theta)$，并确定能使格式对所有 $\\theta$ 都稳定的 CFL 数 $\\nu$ 的最大允许值。你的最终答案必须依次包含 $G(\\theta)$ 的闭式表达式和最大允许 $\\nu$ 值的单个数字。无需四舍五入。",
            "solution": "问题陈述经评估有效。这是一个科学上成立、适定且客观的计算流体力学领域的问题，具体涉及数值格式的稳定性分析。所有必要信息均已提供，不存在矛盾或歧义。\n\n给定的偏微分方程（PDE）是一维线性平流方程：\n$$u_{t} + a\\,u_{x} = 0$$\n其中平流速度 $a$ 是一个正常数 ($a > 0$)。\n\n指定的数值格式使用前向欧拉法进行时间积分，并使用一阶迎风法进行空间离散。\n\n时间导数项 $u_t$ 通过一阶前向差分近似：\n$$\\frac{\\partial u}{\\partial t} \\approx \\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t}$$\n其中 $u_j^n$ 表示在空间节点 $x_j = j\\,\\Delta x$ 和时间层 $t^n = n\\,\\Delta t$ 的数值解。\n\n空间导数项 $u_x$ 通过一阶迎风差分近似。由于 $a > 0$，“迎风”方向来自左侧（即信息从较小的 $x$ 传播到较大的 $x$）。这对应于一阶后向差分：\n$$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{j}^{n} - u_{j-1}^{n}}{\\Delta x}$$\n将这些离散近似代入偏微分方程，得到完全离散的方程：\n$$\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} + a \\left(\\frac{u_{j}^{n} - u_{j-1}^{n}}{\\Delta x}\\right) = 0$$\n为了获得 $u_{j}^{n+1}$ 的显式更新格式，我们重新整理各项：\n$$u_{j}^{n+1} - u_{j}^{n} = -a \\frac{\\Delta t}{\\Delta x} \\left(u_{j}^{n} - u_{j-1}^{n}\\right)$$\n我们引入 Courant–Friedrichs–Lewy (CFL) 数，定义为 $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$。将 $\\nu$ 代入方程得到：\n$$u_{j}^{n+1} = u_{j}^{n} - \\nu \\left(u_{j}^{n} - u_{j-1}^{n}\\right)$$\n$$u_{j}^{n+1} = (1 - \\nu)u_{j}^{n} + \\nu u_{j-1}^{n}$$\n这就是我们必须对其进行 von Neumann 稳定性分析的有限差分格式。分析过程通过将单个傅里叶模 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$ 代入格式来进行。这里，$\\hat{u}^{n}$ 是在时间步 $n$ 的模的振幅，$i=\\sqrt{-1}$，$\\theta = k_x \\Delta x$ 是无量纲波数，其中 $k_x$ 是波数。\n\n格式中的各项变为：\n$$u_{j}^{n+1} = \\hat{u}^{n+1}\\,\\exp(i\\,j\\,\\theta)$$\n$$u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$$\n$$u_{j-1}^{n} = \\hat{u}^{n}\\,\\exp(i\\,(j-1)\\,\\theta) = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)\\,\\exp(-i\\,\\theta)$$\n将这些代入离散方程：\n$$\\hat{u}^{n+1}\\,\\exp(i\\,j\\,\\theta) = (1 - \\nu)\\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta) + \\nu \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)\\,\\exp(-i\\,\\theta)$$\n我们可以用非零的公因子 $\\exp(i\\,j\\,\\theta)$ 除以整个方程：\n$$\\hat{u}^{n+1} = (1 - \\nu)\\hat{u}^{n} + \\nu \\hat{u}^{n}\\,\\exp(-i\\,\\theta)$$\n在右侧提出因子 $\\hat{u}^n$ 得到：\n$$\\hat{u}^{n+1} = [1 - \\nu + \\nu \\exp(-i\\,\\theta)]\\,\\hat{u}^{n}$$\n放大因子 $G(\\theta)$ 由关系式 $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$ 定义。通过比较，我们得到 $G(\\theta)$ 的表达式：\n$$G(\\theta) = 1 - \\nu + \\nu \\exp(-i\\,\\theta)$$\n这是所需答案的第一部分。\n\n为使格式稳定，对于无量纲波数 $\\theta$ 的任何值，放大因子的模都不能超过1。von Neumann 稳定性条件是：\n$$|G(\\theta)| \\le 1 \\quad \\forall \\theta \\in [-\\pi, \\pi]$$\n为了分析这个条件，我们计算模的平方 $|G(\\theta)|^2$。使用欧拉公式 $\\exp(-i\\,\\theta) = \\cos(\\theta) - i\\,\\sin(\\theta)$，我们可以用其实部和虚部来表示 $G(\\theta)$：\n$$G(\\theta) = (1 - \\nu + \\nu \\cos(\\theta)) - i\\,(\\nu \\sin(\\theta))$$\n模的平方是实部和虚部的平方和：\n$$|G(\\theta)|^2 = (1 - \\nu + \\nu \\cos(\\theta))^2 + (-\\nu \\sin(\\theta))^2$$\n$$|G(\\theta)|^2 = (1 - \\nu(1 - \\cos(\\theta)))^2 + \\nu^2 \\sin^2(\\theta)$$\n展开平方项：\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - \\cos(\\theta))^2 + \\nu^2 \\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta)) + \\nu^2 \\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta) + \\sin^2(\\theta))$$\n使用恒等式 $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$：\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + 1)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(2 - 2\\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + 2\\nu^2(1 - \\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 + (2\\nu^2 - 2\\nu)(1 - \\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 + 2\\nu(\\nu - 1)(1 - \\cos(\\theta))$$\n稳定性条件 $|G(\\theta)|^2 \\le 1$ 变为：\n$$1 + 2\\nu(\\nu - 1)(1 - \\cos(\\theta)) \\le 1$$\n$$2\\nu(\\nu - 1)(1 - \\cos(\\theta)) \\le 0$$\n我们分析这个不等式中的因子：\n1.  CFL 数 $\\nu = a\\,\\Delta t / \\Delta x$ 是正的，因为 $a > 0$, $\\Delta t > 0$, 且 $\\Delta x > 0$。因此，$\\nu > 0$。\n2.  项 $(1 - \\cos(\\theta))$ 对于任何实数 $\\theta$ 总是非负的，因为 $-1 \\le \\cos(\\theta) \\le 1$。其取值范围为从 $0$ 到 $2$。\n由于 $2\\nu > 0$ 且 $(1 - \\cos(\\theta)) \\ge 0$，只有当剩下的因子 $(\\nu-1)$ 为非正数时，该不等式才能对所有 $\\theta$ 成立。\n$$\\nu - 1 \\le 0 \\implies \\nu \\le 1$$\n将其与 $\\nu > 0$ 结合，该格式的稳定性条件是 $0  \\le \\nu \\le 1$。\n问题要求的是格式保持稳定时 CFL 数 $\\nu$ 的最大允许值。这对应于稳定区间的上界。\n$$\\nu_{\\text{max}} = 1$$\n这是所需答案的第二部分。",
            "answer": "$$\\boxed{G(\\theta) = 1 - \\nu + \\nu \\exp(-i\\theta), \\quad \\nu_{\\text{max}} = 1}$$"
        },
        {
            "introduction": "在气候模拟等典型的长期模拟中，守恒像能量这样的物理量是至关重要的。本练习探讨了“弱不稳定性”的概念，即一种数值方法即使在有限区间上是形式上收敛的，也可能导致能量缓慢但持续的漂移。通过分析和实现一个简谐振子的显式中点法 ，您将直接观察到这种数值能量的增长，并理解为什么看似稳定的方法可能不适用于守恒系统。",
            "id": "3217024",
            "problem": "考虑使用显式中点法求解常微分方程 (ODE)。该方法使用速度场的中点来定义单步更新。请从数值稳定性的第一性原理出发，分析其在振荡问题上的行为，然后通过计算来展示观察到的行为。\n\n您必须从以下基本依据出发：\n- 用于稳定性分析的线性检验方程：$y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。\n- 简谐振子模型：$x''(t) + \\omega^2 x(t) = 0$，角频率 $\\omega > 0$。\n- 单位质量的简谐振子的能量：$E(t) = \\tfrac{1}{2}\\left(v(t)^2 + \\omega^2 x(t)^2\\right)$，其中 $v(t) = x'(t)$。\n\n任务：\n1. 根据显式中点法的定义和线性检验方程 $y'(t) = \\lambda y(t)$，推导出单步放大因子 $R(z)$ 作为 $z = h\\lambda$ 的函数，其中 $h > 0$ 是时间步长。将其特化到纯虚数情况 $\\lambda = i\\omega$（其中 $\\omega > 0$）。证明对于任何非零步长 $h$，模 $\\lvert R(i\\omega h)\\rvert$ 都超过 $1$，并解释为什么这意味着即使该方法在有限区间上是相容和收敛的，它对于振荡动力学也表现出弱不稳定性。\n2. 实现一个程序，通过将简谐振子方程 $x''(t) + \\omega^2 x(t) = 0$ 重写为一阶系统 $y'(t) = f(y(t))$（其中 $y(t) = \\begin{bmatrix}x(t) \\\\ v(t)\\end{bmatrix}$ 且 $f(y) = \\begin{bmatrix}v \\\\ -\\omega^2 x\\end{bmatrix}$）来进行积分。使用显式中点法更新状态：\n   - 计算 $k_1 = f(y_n)$，\n   - 计算中点状态 $y_{n+\\frac{1}{2}} = y_n + \\tfrac{h}{2}k_1$，\n   - 计算 $k_2 = f(y_{n+\\frac{1}{2}})$，\n   - 更新 $y_{n+1} = y_n + h k_2$。\n3. 对于每次模拟，使用初始条件 $x(0) = 1$ 和 $v(0) = 0$。设一个周期为 $T_p = \\tfrac{2\\pi}{\\omega}$。对于给定的周期数 $M$，使用固定步长 $h$ 和整数步数 $N = \\left\\lfloor \\tfrac{T}{h} \\right\\rfloor$ 对总时间 $T = M T_p$ 进行积分。计算并返回能量比 $r = \\tfrac{E_N}{E_0}$，其中 $E_0 = \\tfrac{1}{2}(\\omega^2 x(0)^2 + v(0)^2)$ 是初始能量，$E_N$ 是 $N$ 步后的能量。所有量都是无量纲的；不需要物理单位。\n\n测试组：\n- 情况 1：$\\omega = 1$，$h = 0.5$，$M = 50$。\n- 情况 2：$\\omega = 1$，$h = 0.1$，$M = 200$。\n- 情况 3：$\\omega = 1$，$h = 0.01$，$M = 200$。\n- 情况 4：$\\omega = 2$，$h = 0.05$，$M = 200$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 `[r_1,r_2,r_3,r_4]`），其中每个 $r_j$ 是对应测试情况（按上述顺序）的能量比。",
            "solution": "在尝试提供解决方案之前，对问题陈述进行了严格验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **方法**：用于常微分方程的显式中点法。\n- **更新步骤**：\n  1. $k_1 = f(y_n)$\n  2. $y_{n+\\frac{1}{2}} = y_n + \\tfrac{h}{2}k_1$\n  3. $k_2 = f(y_{n+\\frac{1}{2}})$\n  4. $y_{n+1} = y_n + h k_2$\n- **线性检验方程**：$y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。\n- **简谐振子 (SHO)**：$x''(t) + \\omega^2 x(t) = 0$，角频率 $\\omega > 0$。\n- **SHO 能量**：$E(t) = \\tfrac{1}{2}\\left(v(t)^2 + \\omega^2 x(t)^2\\right)$，其中 $v(t) = x'(t)$ 且质量为单位1。\n- **任务 1**：推导放大因子 $R(z)$（$z = h\\lambda$），证明对于 $\\lambda = i\\omega$，模 $\\lvert R(i\\omega h)\\rvert > 1$（$h > 0$），并解释其弱不稳定性的含义。\n- **任务 2**：为 SHO 实现该方法，将其作为一阶系统 $y'(t) = f(y(t))$，其中 $y(t) = \\begin{bmatrix}x(t) \\\\ v(t)\\end{bmatrix}$ 且 $f(y) = \\begin{bmatrix}v \\\\ -\\omega^2 x\\end{bmatrix}$。\n- **任务 3**：使用初始条件 $x(0) = 1$，$v(0) = 0$ 运行模拟。在 $M$ 个周期内进行积分，总时间 $T = M T_p = M \\frac{2\\pi}{\\omega}$，使用 $N = \\left\\lfloor \\tfrac{T}{h} \\right\\rfloor$ 个步长为 $h$ 的步骤。计算能量比 $r = E_N / E_0$。\n- **测试组**：\n  - 情况 1：$\\omega = 1$，$h = 0.5$，$M = 50$。\n  - 情况 2：$\\omega = 1$，$h = 0.1$，$M = 200$。\n  - 情况 3：$\\omega = 1$，$h = 0.01$，$M = 200$。\n  - 情况 4：$\\omega = 2$，$h = 0.05$，$M = 200$。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估：\n- **科学依据**：该问题在根本上是合理的。它涉及将一种标准的显式龙格-库塔方法（即显式中点法，RK2）应用于典型的线性检验方程和简谐振子，并对其进行稳定性分析。这些都是数值常微分方程领域的基石性课题。\n- **良构性**：该问题是良构的。它提供了完整的算法描述、一组特定的初始条件和参数，以及对解析推导和计算实验的明确目标。任务是明确的，可以得出一个唯一的、可验证的解。\n- **客观性**：该问题以客观、正式的语言陈述，没有任何主观性或偏见。所有术语在数学和科学计算领域都是标准术语。\n- **缺陷清单**：该问题没有表现出任何使其无效的缺陷。它在科学上不是不合理的，也不是不完整、矛盾、不现实或非良构的。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将提供完整的解决方案。\n\n### 解决方案\n\n这个问题要求对显式中点法进行两部分分析：使用线性检验方程进行理论稳定性分析，以及对其在简谐振子（一个动力学行为纯属振荡的系统）上的行为进行计算演示。\n\n**1. 稳定性分析与放大因子**\n\n我们首先分析该方法在线性检验方程 $y'(t) = \\lambda y(t)$ 上的行为。第 $n$ 步的数值解（记为 $y_n$）理想情况下应遵循精确解 $y(t_n)$ 的行为。显式中点法的应用如下：\n\n设 $f(y) = \\lambda y$。从 $y_n$推进到 $y_{n+1}$ 的步骤如下：\n1.  计算第一阶段斜率：$k_1 = f(y_n) = \\lambda y_n$。\n2.  使用斜率 $k_1$ 计算时间中点的状态：$y_{n+\\frac{1}{2}} = y_n + \\frac{h}{2}k_1 = y_n + \\frac{h}{2}(\\lambda y_n) = (1 + \\frac{h\\lambda}{2})y_n$。\n3.  计算中点状态处的斜率：$k_2 = f(y_{n+\\frac{1}{2}}) = \\lambda y_{n+\\frac{1}{2}} = \\lambda(1 + \\frac{h\\lambda}{2})y_n$。\n4.  使用中点斜率 $k_2$ 更新状态：$y_{n+1} = y_n + h k_2 = y_n + h \\left[\\lambda(1 + \\frac{h\\lambda}{2})y_n\\right]$。\n\n从最终表达式中提出公因子 $y_n$ 得到单步更新规则：\n$$y_{n+1} = \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2}\\right) y_n$$\n\n括号中的项是放大因子 $R(z)$，它决定了数值解在每一步如何被缩放。它是 $z = h\\lambda$ 的多项式函数。\n$$R(z) = 1 + z + \\frac{z^2}{2}$$\n这可以看作是 $e^z$ 的二阶泰勒级数展开，这与该方法的二阶精度相符。\n\n对于振荡问题，系统雅可比矩阵的特征值位于虚轴上。我们通过设置 $\\lambda = i\\omega$ 来模拟这种情况，其中 $\\omega > 0$ 是一个实频率。因此，$z = i\\omega h$。我们将此代入放大因子：\n$$R(i\\omega h) = 1 + (i\\omega h) + \\frac{(i\\omega h)^2}{2} = 1 + i\\omega h - \\frac{(\\omega h)^2}{2}$$\n这个复数可以写成其实部和虚部的形式：\n$$R(i\\omega h) = \\left(1 - \\frac{(\\omega h)^2}{2}\\right) + i(\\omega h)$$\n\n对于振荡问题，该方法的稳定性取决于此放大因子的模。如果 $\\lvert R(i\\omega h) \\rvert \\le 1$，则该方法是稳定的；否则，数值解的振幅将被人为地放大。我们计算其模的平方：\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(\\text{Re}[R(i\\omega h)]\\right)^2 + \\left(\\text{Im}[R(i\\omega h)]\\right)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(1 - \\frac{(\\omega h)^2}{2}\\right)^2 + (\\omega h)^2$$\n展开平方项：\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(1 - 2 \\cdot \\frac{(\\omega h)^2}{2} + \\frac{(\\omega h)^4}{4}\\right) + (\\omega h)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = 1 - (\\omega h)^2 + \\frac{(\\omega h)^4}{4} + (\\omega h)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = 1 + \\frac{(\\omega h)^4}{4}$$\n因此，模为：\n$$\\lvert R(i\\omega h) \\rvert = \\sqrt{1 + \\frac{(\\omega h)^4}{4}}$$\n对于任何非零步长 $h > 0$ 和频率 $\\omega > 0$，项 $(\\omega h)^4$ 严格为正。因此，$\\frac{(\\omega h)^4}{4} > 0$，这意味着 $1 + \\frac{(\\omega h)^4}{4} > 1$，所以 $\\lvert R(i\\omega h) \\rvert > 1$。\n\n这个结果证明了显式中点法在虚轴上是无条件不稳定的。数值解的振幅在每一步都被一个大于 1 的因子放大。这导致解的范数在长的积分时间内呈指数增长，这种现象被称为弱不稳定性。虽然该方法是相容的（局部误差为 $\\mathcal{O}(h^3)$），因此在任何有限时间区间 $[0, T]$ 上都是收敛的，但误差常数随 $T$ 指数增长，使得该方法不适用于像简谐振子这样的保守系统的长期模拟，因为在这些系统中能量应该是守恒的。数值能量将系统性地增加，这一点将通过计算得到证明。\n\n**2. 计算实现与能量分析**\n\n二阶简谐振子方程 $x''(t) + \\omega^2 x(t) = 0$ 通过定义状态向量 $y(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$（其中 $v(t) = x'(t)$）转换为一阶系统。系统动力学由下式给出：\n$$y'(t) = \\begin{bmatrix} x'(t) \\\\ v'(t) \\end{bmatrix} = \\begin{bmatrix} v(t) \\\\ -\\omega^2 x(t) \\end{bmatrix} = f(y(t))$$\n我们将使用显式中点法和指定的测试用例参数来对该系统进行积分。在从 $y_n = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix}$ 到 $y_{n+1}$ 的每一步中：\n1.  $k_1 = \\begin{bmatrix} k_{1,x} \\\\ k_{1,v} \\end{bmatrix} = \\begin{bmatrix} v_n \\\\ -\\omega^2 x_n \\end{bmatrix}$。\n2.  $y_{n+\\frac{1}{2}} = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix} + \\frac{h}{2} \\begin{bmatrix} v_n \\\\ -\\omega^2 x_n \\end{bmatrix} = \\begin{bmatrix} x_n + \\frac{h}{2}v_n \\\\ v_n - \\frac{h}{2}\\omega^2 x_n \\end{bmatrix}$。\n3.  $k_2 = \\begin{bmatrix} k_{2,x} \\\\ k_{2,v} \\end{bmatrix} = f(y_{n+\\frac{1}{2}}) = \\begin{bmatrix} v_n - \\frac{h}{2}\\omega^2 x_n \\\\ -\\omega^2(x_n + \\frac{h}{2}v_n) \\end{bmatrix}$。\n4.  $y_{n+1} = \\begin{bmatrix} x_{n+1} \\\\ v_{n+1} \\end{bmatrix} = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix} + h k_2 = \\begin{bmatrix} x_n + h(v_n - \\frac{h}{2}\\omega^2 x_n) \\\\ v_n - h\\omega^2(x_n + \\frac{h}{2}v_n) \\end{bmatrix}$。\n\n初始状态为 $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。初始能量为 $E_0 = \\frac{1}{2}(v(0)^2 + \\omega^2 x(0)^2) = \\frac{1}{2}(0^2 + \\omega^2 \\cdot 1^2) = \\frac{\\omega^2}{2}$。\n经过 $N$ 步后，最终状态为 $y_N = \\begin{bmatrix} x_N \\\\ v_N \\end{bmatrix}$。最终能量为 $E_N = \\frac{1}{2}(v_N^2 + \\omega^2 x_N^2)$。程序将为每个测试用例计算比率 $r = E_N/E_0$。该比率量化了稳定性分析所预测的数值能量漂移。\n对于较大的无量纲乘积 $\\omega h$ 和较多的积分步数 $N$，能量的增长预计会更加显著。\n具体来说，能量比 $r_N = E_N/E_0$ 预计大约以 $(1 + \\frac{(\\omega h)^4}{4})^N$ 的形式增长。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the explicit midpoint method on the simple harmonic oscillator.\n\n    This function implements the explicit midpoint method to solve the\n    simple harmonic oscillator equation system for four different test cases.\n    It calculates the ratio of the final numerical energy to the initial\n    analytical energy, demonstrating the method's weak instability for\n    oscillatory problems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, h, M)\n    test_cases = [\n        (1.0, 0.5, 50),\n        (1.0, 0.1, 200),\n        (1.0, 0.01, 200),\n        (2.0, 0.05, 200),\n    ]\n\n    results = []\n    for omega, h, M in test_cases:\n        # Initial conditions\n        x0 = 1.0\n        v0 = 0.0\n        y = np.array([x0, v0], dtype=np.float64)\n\n        # System definition f(y) = [v, -omega^2 * x]\n        def f(state_vec, omega_val):\n            x, v = state_vec\n            return np.array([v, -omega_val**2 * x], dtype=np.float64)\n\n        # Simulation time parameters\n        # T_p is one period\n        T_p = 2.0 * np.pi / omega\n        # T is total integration time\n        T = M * T_p\n        # N is the total number of integer steps\n        N = int(np.floor(T / h))\n\n        # Calculate initial energy E_0\n        # E(t) = 0.5 * (v(t)^2 + omega^2 * x(t)^2)\n        E0 = 0.5 * (y[1]**2 + omega**2 * y[0]**2)\n\n        # Integration loop using explicit midpoint method\n        for _ in range(N):\n            # k1 = f(y_n)\n            k1 = f(y, omega)\n            \n            # y_mid = y_n + (h/2) * k1\n            y_mid = y + (h / 2.0) * k1\n            \n            # k2 = f(y_mid)\n            k2 = f(y_mid, omega)\n            \n            # y_{n+1} = y_n + h * k2\n            y = y + h * k2\n\n        # Calculate final energy E_N\n        EN = 0.5 * (y[1]**2 + omega**2 * y[0]**2)\n        \n        # Avoid division by zero if initial energy is zero, though not possible\n        # with the given ICs.\n        if E0 == 0:\n            energy_ratio = np.inf\n        else:\n            energy_ratio = EN / E0\n        \n        results.append(energy_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Lax等价定理指出，对于一个线性格式，相容性加稳定性等价于收敛性，这是偏微分方程数值分析的理论基石。本练习在与地球系统建模高度相关的背景下——非均匀网格——对该定理进行了实践检验 。您将研究一个相容的格式，如果其稳定性条件（由*最小*网格单元决定）被不当选择的时间步长所违反，将如何导致其无法收敛，从而揭示了网格结构、稳定性和可靠模拟结果之间的关键联系。",
            "id": "3217060",
            "problem": "考虑一维热方程 $u_t = u_{xx}$，其空间区间为 $x \\in (0,1)$，具有齐次Dirichlet边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$，以及光滑的初始条件 $u(x,0) = \\sin(\\pi x)$。目标是检验非均匀网格上显式时间步进格式的一致性、稳定性和收敛性之间的相互作用，并在实践中检验Lax等价定理。\n\n从核心定义开始：\n- 一致性：当空间步长 $h_i$ 和时间步长 $\\Delta t$ 趋于零时，局部截断误差趋于零。\n- 稳定性：离散解算子对于输入数据或舍入误差的扰动是有界的，通常通过对放大因子的界来表征。\n- 收敛性：在选定的范数（此处为平方可积范数）下，数值解逼近原始连续模型的精确解。\n\n构建显式向前欧拉线法格式，在内部节点 $x_i$ 处使用非均匀二阶导数有限差分，如下所示：\n$$u^{n+1}_i = u^n_i + \\Delta t \\, D^{(2)}u^n_i,$$\n其中 $D^{(2)}$ 是在具有间距 $h_{i-1} = x_i - x_{i-1}$ 和 $h_{i} = x_{i+1} - x_i$ 的非均匀网格上通过泰勒展开推导的三点二阶导数近似：\n$$D^{(2)}u_i \\approx 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)。$$\n通过设置 $u^n_0 = 0$ 和 $u^n_{N+1} = 0$ 来施加边界条件。\n\n将离散空间算子 $L$ 定义为作用于内部节点值向量 $\\mathbf{u}^n = (u^n_1,\\dots,u^n_N)^\\top$ 的 $D^{(2)}$ 的矩阵表示，从而该方法可以写成 $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$。对于给定的初始条件，精确解为 $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$。\n\n您必须：\n1. 在严格递增的网格 $\\{x_i\\}_{i=0}^{N+1}$（其中 $x_0 = 0$ 和 $x_{N+1} = 1$）上实现非均匀网格二阶导数算子 $L$。\n2. 对于每个测试用例，计算：\n   - 最大单步放大因子 $a_{\\max} = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$，其中 $\\mathrm{spec}(L)$ 表示 $L$ 的谱（特征值集合）。\n   - 与 $u(x,\\Delta t)$ 相比的单步误差的离散平方可积范数（$L^2$ 范数），内部节点使用求积权重 $w_i = \\tfrac{h_{i-1} + h_i}{2}$，并定义范数 $\\|\\mathbf{v}\\|_{L^2} = \\left(\\sum_{i=1}^N w_i v_i^2\\right)^{1/2}$。\n   - 加密误差比 $r = E_{2N} / E_{N}$，其中 $E_{N}$ 是在具有 $N$ 个内部点的网格上的单步离散 $L^2$ 误差，而 $E_{2N}$ 是在具有 $2N$ 个内部点的网格上的类似误差，两者均使用下述相同的步长选择策略。\n   - 由 $a_{\\max} \\le 1$ 定义的稳定性布尔值。\n3. 通过计算出的值解释，如果时间步长不与最小网格尺寸成比例，该格式如何能够逐点一致（即当 $N \\to \\infty$ 和 $\\Delta t \\to 0$ 时局部截断误差趋于零），但却在 $L^2$ 范数下不稳定并因此不收敛。具体来说，展示当网格是强非均匀时，将 $\\Delta t$ 与平均步长的平方成比例缩放可以导致 $a_{\\max} > 1$，从而违反稳定性，并根据Lax等价定理阻止收敛。\n\n使用以下测试套件。对于每种情况，根据指定的策略构建网格并选择时间步长：\n- 情况A（理想情况，均匀且稳定）：$N = 64$，均匀网格 $x_i = i/(N+1)$，选择 $\\Delta t = 0.45\\, h_{\\min}^2$，其中 $h_{\\min} = \\min_i (x_{i+1} - x_i)$。\n- 情况B（边界情况，因平均缩放导致非均匀且不稳定）：$N = 64$，分级网格 $x_i = \\left(\\frac{i}{N+1}\\right)^p$，其中 $p = 2$，选择 $\\Delta t = 0.45\\, \\bar{h}^2$，其中 $\\bar{h} = \\frac{1}{N+1}\\sum_{i=0}^N (x_{i+1} - x_i)$。\n- 情况C（非均匀但因最小缩放而稳定）：$N = 64$，分级网格 $x_i = \\left(\\frac{i}{N+1}\\right)^p$，其中 $p = 2$，选择 $\\Delta t = 0.45\\, h_{\\min}^2$。\n\n对于每种情况，通过在相同策略下比较 $E_N$ 和 $E_{2N}$，计算 $a_{\\max}$、稳定性布尔值和加密误差比 $r$。所有量均为无量纲。\n\n您的程序应产生单行输出，包含一个逗号分隔的列表，该列表用方括号括起来，不含空格，其中每种情况贡献一个形式为 $[$stable\\_boolean$,a_{\\max},r]$ 的子列表。例如，一个包含三种情况的输出应类似于 $[[\\mathrm{True},0.9,0.5],[\\mathrm{False},3.1,1.8],[\\mathrm{True},0.8,0.6]]$，该行中任何地方都无空格。",
            "solution": "所述问题是数值分析领域中一个适定且科学上合理的练习，旨在研究求解一维热方程的数值格式的一致性、稳定性和收敛性之间的相互依赖关系。所有给出的方程、条件和定义都是标准的和正确的。该问题是有效的。\n\n该问题的核心在于Lax等价定理，该定理指出：对于一个一致的线性有限差分格式，稳定性是其收敛的充分必要条件。我们将通过在非均匀网格上应用一个时间向前、空间居中（FTCS）的显式格式来求解热方程 $u_t = u_{xx}$，以演示这一原理。\n\n该数值方法由更新规则 $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$ 定义，其中 $\\mathbf{u}^n$ 是在时间步 $n$ 时内部网格点上数值解的向量，$I$ 是单位矩阵，$\\Delta t$ 是时间步长，$L$ 是二阶导数算子 $D^{(2)}$ 的矩阵表示，其形式为：\n$$D^{(2)}u_i = 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)$$\n对于一个间距为 $h_{i-1} = x_i - x_{i-1}$ 和 $h_i = x_{i+1} - x_i$ 的网格。该算子与连续二阶导数 $u_{xx}$ 是一致的；当网格间距趋于零时，其局部截断误差也趋于零。\n\n这种显式格式的稳定性由放大矩阵 $G = I + \\Delta t\\, L$ 的谱半径决定。稳定性要求单步放大因子 $a_{\\max} = \\rho(G) = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$ 不得超过 $1$。离散拉普拉斯算子 $L$ 的特征值 $\\lambda$ 是实数且非正的。设 $\\lambda_{\\min}$ 是 $L$ 的最负特征值。稳定性条件简化为 $1 + \\Delta t\\, \\lambda_{\\min} \\ge -1$，从而得出约束条件：\n$$\\Delta t \\le \\frac{-2}{\\lambda_{\\min}}$$\n对于非均匀网格，$\\lambda_{\\min}$ 的大小由最小网格间距 $h_{\\min}$ 决定。可以证明 $|\\lambda_{\\min}|$ 的尺度与 $1/h_{\\min}^2$ 相当。这导出了显式格式著名的稳定性要求：\n$$\\Delta t \\le C \\cdot h_{\\min}^2$$\n其中 $C$ 是某个常数（对于均匀网格情况，$C=1/2$）。一个关键的洞见是，稳定性取决于*最小*间距 $h_{\\min}$，而非平均间距 $\\bar{h}$。该问题的测试用例旨在说明这一点。\n\n对于每种情况，我们将计算最大放大因子 $a_{\\max}$，通过条件 $a_{\\max} \\le 1$ 来判断稳定性，并通过单步误差加密比 $r = E_{2N} / E_N$ 来评估收敛行为。比率 $r  1$ 表示收敛，而 $r \\ge 1$ 则意味着发散。\n\n**情况A：均匀网格，稳定时间步长**\n网格是均匀的，意味着对于所有 $i$，$h_i = h = \\bar{h} = h_{\\min}$。时间步长选择为 $\\Delta t = 0.45\\, h_{\\min}^2 = 0.45\\, h^2$。这满足稳定性条件 $\\Delta t \\le 0.5\\, h^2$。因此，我们期望该格式是稳定的，即 $a_{\\max} \\le 1$。由于格式是一致且稳定的，Lax等价定理保证了其收敛性。这应该通过加密比 $r  1$ 来反映。\n\n**情况B：非均匀网格，不稳定时间步长**\n采用分级网格 $x_i = (i/(N+1))^2$，该网格在 $x=0$ 附近加密点，导致最小间距 $h_{\\min}$ 远小于平均间距 $\\bar{h}$。时间步长设置为 $\\Delta t = 0.45\\, \\bar{h}^2$。由于 $\\bar{h} \\gg h_{\\min}$，这个 $\\Delta t$ 的选择将远大于基于 $h_{\\min}^2$ 的稳定性条件所允许的值。\n$$\\Delta t = 0.45\\, \\bar{h}^2 = 0.45 \\left(\\frac{\\bar{h}}{h_{\\min}}\\right)^2 h_{\\min}^2 \\gg h_{\\min}^2$$\n因此，我们预测该格式将是不稳定的，即 $a_{\\max}  1$。尽管这是一个一致的格式，但这种不稳定性将导致不收敛，这应由误差比 $r \\ge 1$ 来证明。\n\n**情况C：非均匀网格，稳定时间步长**\n这种情况使用与情况B相同的分级网格，但修正了时间步长选择策略中的缺陷。时间步长选择为 $\\Delta t = 0.45\\, h_{\\min}^2$。这个选择遵守了由最小网格单元施加的约束，旨在满足稳定性条件。我们期望找到 $a_{\\max} \\le 1$。在一致性和稳定性都重新建立的情况下，该格式应再次收敛，从而得到加密比 $r  1$。\n\n实现过程将构建矩阵 $L$，计算其特征值以找到 $a_{\\max}$，并计算相对于精确解 $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$ 的单步 $L^2$ 误差，以确定加密比 $r$。这些结果将为Lax等价定理以及根据最严格的局部网格间距选择时间步长的关键重要性提供一个实践演示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case_metrics(N, p, dt_policy):\n    \"\"\"\n    Computes stability and error metrics for a given grid and time step policy.\n\n    Args:\n        N (int): Number of interior grid points.\n        p (float): Power for graded grid generation. p=1 gives a uniform grid.\n        dt_policy (str): Time step policy, either 'min' or 'avg'.\n\n    Returns:\n        tuple: A tuple containing:\n            - l2_error (float): The discrete L2 norm of the one-step error.\n            - a_max (float): The maximum one-step amplification factor.\n            - is_stable (bool): True if the scheme is stable, False otherwise.\n    \"\"\"\n    # 1. Grid Generation\n    i_vals = np.arange(N + 2, dtype=float)\n    x = (i_vals / (N + 1))**p\n    h = np.diff(x)  # h has length N+1, h_i = x_{i+1} - x_i\n\n    # 2. Time Step Calculation\n    h_min = np.min(h)\n    # The problem defines h_bar as the sum over N+1 spacings divided by N+1\n    h_bar = np.mean(h)\n    \n    if dt_policy == 'min':\n        dt = 0.45 * h_min**2\n    elif dt_policy == 'avg':\n        dt = 0.45 * h_bar**2\n    else:\n        raise ValueError(\"Invalid dt_policy specified.\")\n\n    # 3. Construct the discrete operator matrix L\n    L = np.zeros((N, N))\n    # Loop over interior nodes i = 1, ..., N\n    # Matrix row j = i - 1 corresponds to node i\n    for j in range(N):\n        h_im1 = h[j]      # This is h_{i-1}\n        h_i   = h[j + 1]  # This is h_i\n        \n        # Diagonal term (coefficient of u_i)\n        L[j, j] = 2.0 * (-1.0 / (h_im1 * h_i))\n        \n        # Sub-diagonal term (coefficient of u_{i-1})\n        if j  0:\n            L[j, j - 1] = 2.0 / (h_im1 * (h_im1 + h_i))\n        \n        # Super-diagonal term (coefficient of u_{i+1})\n        if j  N - 1:\n            L[j, j + 1] = 2.0 / (h_i * (h_im1 + h_i))\n\n    # 4. Compute stability metrics\n    eigenvalues = np.linalg.eigvals(L)\n    a_max = np.max(np.abs(1.0 + dt * eigenvalues))\n    is_stable = a_max = 1.0\n\n    # 5. Compute one-step L2 error\n    x_interior = x[1:N + 1]\n    \n    # Initial condition at interior nodes\n    u0 = np.sin(np.pi * x_interior)\n    \n    # Numerical solution at t = dt\n    u1_num = u0 + dt * (L @ u0)\n    \n    # Exact solution at t = dt\n    u1_exact = np.exp(-np.pi**2 * dt) * np.sin(np.pi * x_interior)\n    \n    # Error vector\n    error_vec = u1_num - u1_exact\n    \n    # Quadrature weights for L2 norm\n    # w_i = (h_{i-1} + h_i)/2. For interior nodes i=1..N, these are h_0..h_{N-1} + h_1..h_N\n    weights = 0.5 * (h[0:N] + h[1:N + 1])\n    \n    l2_error = np.sqrt(np.sum(weights * error_vec**2))\n    \n    return l2_error, a_max, is_stable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # (N_base, p, dt_policy) for each case\n    # p=1 represents a uniform grid as (i/(N+1))^1.\n    test_cases_params = [\n        (64, 1.0, 'min'),  # Case A: Uniform grid, stable by h_min\n        (64, 2.0, 'avg'),  # Case B: Graded grid, unstable by h_bar\n        (64, 2.0, 'min'),  # Case C: Graded grid, stable by h_min\n    ]\n\n    final_results = []\n    for N_base, p, policy in test_cases_params:\n        # Calculate metrics for the base grid N\n        E_N, a_max, is_stable = compute_case_metrics(N_base, p, policy)\n        \n        # Calculate error for the refined grid 2N to find the ratio\n        E_2N, _, _ = compute_case_metrics(2 * N_base, p, policy)\n        \n        # Refinement error ratio\n        if E_N == 0:\n            r = np.inf if E_2N > 0 else 0\n        else:\n            r = E_2N / E_N\n        \n        final_results.append([is_stable, a_max, r])\n    \n    # Format the output string exactly as specified: [[val,val,val],[val,val,val],...]\n    case_strings = []\n    for s_bool, a_val, r_val in final_results:\n        # Python's bool __str__ is 'True' or 'False'\n        case_strings.append(f\"[{str(s_bool)},{a_val},{r_val}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}