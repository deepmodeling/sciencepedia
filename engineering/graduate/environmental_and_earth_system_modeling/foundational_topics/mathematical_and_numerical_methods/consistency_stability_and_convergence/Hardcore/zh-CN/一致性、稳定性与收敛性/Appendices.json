{
    "hands_on_practices": [
        {
            "introduction": "冯·诺依曼稳定性分析是评估线性数值格式稳定性的基石。本练习将指导您完成一阶迎风格式的放大因子和稳定性条件的推导，该格式被广泛用于模拟大气和海洋模型中的平流等输运现象。掌握这种分析方法  对于理解数值误差如何演变以及确保模拟保持稳定至关重要。",
            "id": "3950212",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中平流速度 $a  0$ 为常数，该方程是计算流体力学 (CFD) 中的一个经典输运模型。区域取为周期性或无限，空间网格是均匀的，节点为 $x_{j} = j\\,\\Delta x$（其中 $j$ 为整数），时间层为 $t^{n} = n\\,\\Delta t$（其中 $n$ 为整数）。定义 Courant–Friedrichs–Lewy (CFL) 数为 $\\nu = a\\,\\Delta t/\\Delta x$。使用一阶迎风空间差分（适用于 $a0$）和前向欧拉时间积分将方程离散化，形成将 $u_{j}^{n}$ 更新至 $u_{j}^{n+1}$ 的显式格式。从线性平流模型以及时间前向差分和空间迎风差分的定义出发，通过代入单个傅里叶模态 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$（其中 $i = \\sqrt{-1}$，$\\theta$ 是无量纲波数）来进行 von Neumann (傅里叶) 稳定性分析。推导由 $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$ 定义的放大因子 $G(\\theta)$，并确定使该格式对所有 $\\theta$ 都稳定的 CFL 数 $\\nu$ 的最大允许值。你的最终答案必须依次包含 $G(\\theta)$ 的闭式表达式和给出最大允许 $\\nu$ 值的单个数字。无需四舍五入。",
            "solution": "问题陈述经评估有效。这是一个源于计算流体力学领域的、有科学依据的、适定的、客观的问题，具体涉及一个数值格式的稳定性分析。所有必要信息都已提供，没有矛盾或含糊之处。\n\n给定的偏微分方程 (PDE) 是一维线性平流方程：\n$$u_{t} + a\\,u_{x} = 0$$\n其中平流速度 $a$ 是一个正常数 ($a  0$)。\n\n指定的数值格式使用前向欧拉方法进行时间积分，并使用一阶迎风方法进行空间离散化。\n\n时间导数项 $u_t$ 由一阶前向差分近似：\n$$\\frac{\\partial u}{\\partial t} \\approx \\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t}$$\n其中 $u_j^n$ 表示在空间节点 $x_j = j\\,\\Delta x$ 和时间层 $t^n = n\\,\\Delta t$ 处的数值解。\n\n空间导数项 $u_x$ 由一阶迎风差分近似。由于 $a  0$，“迎风”方向是来自左侧（即信息从较小的 $x$ 传播到较大的 $x$）。这对应于一阶后向差分：\n$$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{j}^{n} - u_{j-1}^{n}}{\\Delta x}$$\n将这些离散近似代入 PDE，得到完全离散化的方程：\n$$\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} + a \\left(\\frac{u_{j}^{n} - u_{j-1}^{n}}{\\Delta x}\\right) = 0$$\n为了获得 $u_{j}^{n+1}$ 的显式更新格式，我们重新整理各项：\n$$u_{j}^{n+1} - u_{j}^{n} = -a \\frac{\\Delta t}{\\Delta x} \\left(u_{j}^{n} - u_{j-1}^{n}\\right)$$\n我们引入 Courant–Friedrichs–Lewy (CFL) 数，定义为 $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$。将 $\\nu$ 代入方程得到：\n$$u_{j}^{n+1} = u_{j}^{n} - \\nu \\left(u_{j}^{n} - u_{j-1}^{n}\\right)$$\n$$u_{j}^{n+1} = (1 - \\nu)u_{j}^{n} + \\nu u_{j-1}^{n}$$\n这就是我们必须对其进行 von Neumann 稳定性分析的有限差分格式。分析过程是将单个傅里叶模态 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$ 代入该格式。此处，$\\hat{u}^{n}$ 是时间步 $n$ 时模态的振幅，$i=\\sqrt{-1}$，$\\theta = k_x \\Delta x$ 是无量纲波数，其中 $k_x$ 是波数。\n\n格式中的各项变为：\n$$u_{j}^{n+1} = \\hat{u}^{n+1}\\,\\exp(i\\,j\\,\\theta)$$\n$$u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$$\n$$u_{j-1}^{n} = \\hat{u}^{n}\\,\\exp(i\\,(j-1)\\,\\theta) = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)\\,\\exp(-i\\,\\theta)$$\n将这些代入离散方程中：\n$$\\hat{u}^{n+1}\\,\\exp(i\\,j\\,\\theta) = (1 - \\nu)\\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta) + \\nu \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)\\,\\exp(-i\\,\\theta)$$\n我们可以用公因子 $\\exp(i\\,j\\,\\theta)$（其非零）除以整个方程：\n$$\\hat{u}^{n+1} = (1 - \\nu)\\hat{u}^{n} + \\nu \\hat{u}^{n}\\,\\exp(-i\\,\\theta)$$\n在右侧提出因子 $\\hat{u}^n$ 得到：\n$$\\hat{u}^{n+1} = [1 - \\nu + \\nu \\exp(-i\\,\\theta)]\\,\\hat{u}^{n}$$\n放大因子 $G(\\theta)$ 由关系式 $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$ 定义。通过比较，我们得到 $G(\\theta)$ 的表达式：\n$$G(\\theta) = 1 - \\nu + \\nu \\exp(-i\\,\\theta)$$\n这是所要求答案的第一部分。\n\n为使格式稳定，对于无量纲波数 $\\theta$ 的任何值，放大因子的模都不得超过1。von Neumann 稳定性条件是：\n$$|G(\\theta)| \\le 1 \\quad \\forall \\theta \\in [-\\pi, \\pi]$$\n为了分析此条件，我们计算模的平方 $|G(\\theta)|^2$。使用欧拉公式 $\\exp(-i\\,\\theta) = \\cos(\\theta) - i\\,\\sin(\\theta)$，我们可以用其实部和虚部表示 $G(\\theta)$：\n$$G(\\theta) = (1 - \\nu + \\nu \\cos(\\theta)) - i\\,(\\nu \\sin(\\theta))$$\n模的平方是实部和虚部的平方和：\n$$|G(\\theta)|^2 = (1 - \\nu + \\nu \\cos(\\theta))^2 + (-\\nu \\sin(\\theta))^2$$\n$$|G(\\theta)|^2 = (1 - \\nu(1 - \\cos(\\theta)))^2 + \\nu^2 \\sin^2(\\theta)$$\n展开平方项：\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - \\cos(\\theta))^2 + \\nu^2 \\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta)) + \\nu^2 \\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta) + \\sin^2(\\theta))$$\n使用恒等式 $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$：\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(1 - 2\\cos(\\theta) + 1)$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + \\nu^2(2 - 2\\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 - 2\\nu(1 - \\cos(\\theta)) + 2\\nu^2(1 - \\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 + (2\\nu^2 - 2\\nu)(1 - \\cos(\\theta))$$\n$$|G(\\theta)|^2 = 1 + 2\\nu(\\nu - 1)(1 - \\cos(\\theta))$$\n稳定性条件 $|G(\\theta)|^2 \\le 1$ 变为：\n$$1 + 2\\nu(\\nu - 1)(1 - \\cos(\\theta)) \\le 1$$\n$$2\\nu(\\nu - 1)(1 - \\cos(\\theta)) \\le 0$$\n我们分析这个不等式中的因子：\n1.  CFL 数 $\\nu = a\\,\\Delta t / \\Delta x$ 是正的，因为 $a  0$、$\\Delta t  0$ 且 $\\Delta x  0$。因此，$\\nu  0$。\n2.  对于任何实数 $\\theta$，项 $(1 - \\cos(\\theta))$ 总是非负的，因为 $-1 \\le \\cos(\\theta) \\le 1$。它的取值范围是从 $0$ 到 $2$。\n由于 $2\\nu  0$ 且 $(1 - \\cos(\\theta)) \\ge 0$，要使不等式对所有 $\\theta$ 都成立，当且仅当剩余的因子 $(\\nu-1)$ 是非正的。\n$$\\nu - 1 \\le 0 \\implies \\nu \\le 1$$\n将此与 $\\nu  0$ 结合，该格式的稳定性条件是 $0  \\nu \\le 1$。\n问题要求的是使格式稳定的 CFL 数 $\\nu$ 的最大允许值。这对应于稳定范围的上界。\n$$\\nu_{\\text{max}} = 1$$\n这是所要求答案的第二部分。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 - \\nu + \\nu \\exp(-i\\theta)  1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "拉克斯等价定理为连接数值格式的一致性、稳定性与收敛性提供了理论基石。这个动手编程练习  通过一个在地球系统建模中常见的情景——在非均匀网格上求解热方程——将该定理付诸实践。您将亲身体验一个一致的格式如果时间步长的选择忽略了最小的网格单元，会如何变得不稳定并最终无法收敛，这为实际模型开发提供了至关重要的一课。",
            "id": "3217060",
            "problem": "考虑空间区间 $x \\in (0,1)$ 上的一维热方程 $u_t = u_{xx}$，其边界条件为齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$，初始条件为光滑函数 $u(x,0) = \\sin(\\pi x)$。目标是研究在非均匀网格上，一个显式时间步进格式的相容性、稳定性和收敛性之间的相互作用，并在实践中检验 Lax 等价定理。\n\n从核心定义开始：\n- 相容性：当空间步长 $h_i$ 和时间步长 $\\Delta t$ 趋于零时，局部截断误差趋于零。\n- 稳定性：离散解算子对于输入数据或舍入误差的扰动是有界的，通常通过放大因子的界来表征。\n- 收敛性：在选定的范数（此处为平方可积范数）下，数值解逼近原始连续模型的精确解。\n\n使用非均匀网格上内部节点 $x_i$ 处的二阶导数有限差分来构建显式前向欧拉线法格式\n$$u^{n+1}_i = u^n_i + \\Delta t \\, D^{(2)}u^n_i,$$\n其中 $D^{(2)}$ 是在间距为 $h_{i-1} = x_i - x_{i-1}$ 和 $h_{i} = x_{i+1} - x_i$ 的非均匀网格上，通过泰勒展开推导出的三点二阶导数近似\n$$D^{(2)}u_i \\approx 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)。$$\n通过设置 $u^n_0 = 0$ 和 $u^n_{N+1} = 0$ 来施加边界条件。\n\n将离散空间算子 $L$ 定义为 $D^{(2)}$ 作用于内部节点值向量 $\\mathbf{u}^n = (u^n_1,\\dots,u^n_N)^\\top$ 的矩阵表示，从而该方法可以写成 $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$。对于给定初始条件的精确解，有 $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$。\n\n您必须：\n1. 在严格递增的网格 $\\{x_i\\}_{i=0}^{N+1}$（其中 $x_0 = 0$ 和 $x_{N+1} = 1$）上，实现非均匀网格二阶导数算子 $L$。\n2. 对每个测试用例，计算：\n   - 最大单步放大因子 $a_{\\max} = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$，其中 $\\mathrm{spec}(L)$ 表示 $L$ 的谱（特征值集合）。\n   - 与 $u(x,\\Delta t)$ 相比的单步误差的离散平方可积范数（$L^2$ 范数），内部节点使用求积权重 $w_i = \\tfrac{h_{i-1} + h_i}{2}$，并定义范数 $\\|\\mathbf{v}\\|_{L^2} = \\left(\\sum_{i=1}^N w_i v_i^2\\right)^{1/2}$。\n   - 加密误差比 $r = E_{2N} / E_{N}$，其中 $E_{N}$ 是在具有 $N$ 个内部点的网格上的单步离散 $L^2$ 误差，$E_{2N}$ 是在具有 $2N$ 个内部点的网格上的类似误差，两者均使用下述相同的步长选择策略。\n   - 由 $a_{\\max} \\le 1$ 定义的稳定性布尔值。\n3. 通过计算出的值解释，如果时间步长不与最小网格尺寸成比例，该格式如何能够逐点相容（即当 $N \\to \\infty$ 和 $\\Delta t \\to 0$ 时局部截断误差趋于零）却不稳定，并因此在 $L^2$ 范数下不收敛。具体来说，证明当网格是强非均匀时，将 $\\Delta t$ 与平均步长的平方进行缩放会导致 $a_{\\max}  1$，这违反了稳定性，并根据 Lax 等价定理阻止了收敛。\n\n使用以下测试套件。对于每个案例，根据指定的策略构建网格并选择时间步长：\n- 案例 A (理想情况，均匀且稳定)：$N = 64$，均匀网格 $x_i = i/(N+1)$，选择 $\\Delta t = 0.45\\, h_{\\min}^2$ 其中 $h_{\\min} = \\min_i (x_{i+1} - x_i)$。\n- 案例 B (边缘情况，因平均尺度缩放导致的非均匀且不稳定)：$N = 64$，分级网格 $x_i = \\left(\\frac{i}{N+1}\\right)^p$ 其中 $p = 2$，选择 $\\Delta t = 0.45\\, \\bar{h}^2$ 其中 $\\bar{h} = \\frac{1}{N+1}\\sum_{i=0}^N (x_{i+1} - x_i)$。\n- 案例 C (因最小尺度缩放导致的非均匀但稳定)：$N = 64$，分级网格 $x_i = \\left(\\frac{i}{N+1}\\right)^p$ 其中 $p = 2$，选择 $\\Delta t = 0.45\\, h_{\\min}^2$。\n\n对于每个案例，通过在相同策略下比较 $E_N$ 和 $E_{2N}$ 来计算 $a_{\\max}$、稳定性布尔值和加密误差比 $r$。所有量都是无量纲的。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号内由逗号分隔的列表，且无空格。每个案例贡献一个形如 $[$stable\\_boolean$,a_{\\max},r]$ 的子列表。例如，包含三个案例的输出应类似于 $[[\\mathrm{True},0.9,0.5],[\\mathrm{False},3.1,1.8],[\\mathrm{True},0.8,0.6]]$，该行中任何地方都不能有空格。",
            "solution": "所陈述的问题是一个适定且在科学上合理的数值分析练习，旨在研究求解一维热方程的数值格式的相容性、稳定性和收敛性之间的相互依赖关系。所有提供的方程、条件和定义都是标准且正确的。该问题是有效的。\n\n此问题的核心在于 Lax 等价定理，该定理指出，对于一个相容的线性有限差分格式，稳定性是其收敛的充分必要条件。我们将通过将一个时间前向、空间中心 (FTCS) 的显式格式应用于非均匀网格上的热方程 $u_t = u_{xx}$ 来展示这一原理。\n\n该数值方法由更新规则 $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$ 定义，其中 $\\mathbf{u}^n$ 是时间步 $n$ 时内部网格点上数值解的向量，$I$ 是单位矩阵，$\\Delta t$ 是时间步长，$L$ 是由下式给出的二阶导数算子 $D^{(2)}$ 的矩阵表示：\n$$D^{(2)}u_i = 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)$$\n对于一个网格间距为 $h_{i-1} = x_i - x_{i-1}$ 和 $h_i = x_{i+1} - x_i$ 的网格。该算子与连续二阶导数 $u_{xx}$ 是相容的；其局部截断误差随着网格间距趋于零而趋于零。\n\n这个显式格式的稳定性由放大矩阵 $G = I + \\Delta t\\, L$ 的谱半径决定。稳定性要求单步放大因子 $a_{\\max} = \\rho(G) = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$ 不得超过 $1$。离散拉普拉斯算子 $L$ 的特征值 $\\lambda$ 是实数且非正的。设 $\\lambda_{\\min}$ 是 $L$ 的最负特征值。稳定性条件简化为 $1 + \\Delta t\\, \\lambda_{\\min} \\ge -1$，从而得到约束条件：\n$$\\Delta t \\le \\frac{-2}{\\lambda_{\\min}}$$\n对于非均匀网格，$\\lambda_{\\min}$ 的量级由最小网格间距 $h_{\\min}$ 决定。可以证明 $|\\lambda_{\\min}|$ 按 $1/h_{\\min}^2$ 的比例变化。这导出了显式格式众所周知的稳定性要求：\n$$\\Delta t \\le C \\cdot h_{\\min}^2$$\n对于某个常数 $C$（对于均匀网格情况，$C=1/2$）。一个关键的见解是，稳定性取决于*最小*间距 $h_{\\min}$，而不是平均间距 $\\bar{h}$。问题的测试用例旨在说明这一点。\n\n对于每个案例，我们将计算最大放大因子 $a_{\\max}$，通过条件 $a_{\\max} \\le 1$ 来确定稳定性，并通过单步误差加密比 $r = E_{2N} / E_N$ 来评估收敛行为。比率 $r  1$ 表明收敛，而 $r \\ge 1$ 则暗示发散。\n\n**案例 A：均匀网格，稳定时间步长**\n网格是均匀的，意味着对所有 $i$ 都有 $h_i = h = \\bar{h} = h_{\\min}$。时间步长选择为 $\\Delta t = 0.45\\, h_{\\min}^2 = 0.45\\, h^2$。这满足稳定性条件 $\\Delta t \\le 0.5\\, h^2$。因此，我们预期该格式是稳定的，即 $a_{\\max} \\le 1$。由于格式是相容且稳定的，Lax 等价定理保证了其收敛性。这应该会反映为一个小于 1 的加密比 $r$。\n\n**案例 B：非均匀网格，不稳定时间步长**\n采用分级网格 $x_i = (i/(N+1))^2$，这使得网格点在 $x=0$ 附近集中，导致 $h_{\\min}$ 相对于平均间距 $\\bar{h}$ 非常小。时间步长设置为 $\\Delta t = 0.45\\, \\bar{h}^2$。由于 $\\bar{h} \\gg h_{\\min}$，这个 $\\Delta t$ 的选择将远大于基于 $h_{\\min}^2$ 的稳定性条件所允许的值。\n$$\\Delta t = 0.45\\, \\bar{h}^2 = 0.45 \\left(\\frac{\\bar{h}}{h_{\\min}}\\right)^2 h_{\\min}^2 \\gg h_{\\min}^2$$\n因此我们预测该格式将是不稳定的，即 $a_{\\max}  1$。尽管这是一个相容的格式，但这种不稳定性将导致不收敛，这应该由一个大于等于 1 的误差比 $r$ 来证明。\n\n**案例 C：非均匀网格，稳定时间步长**\n此案例使用与案例 B 相同的分级网格，但修正了时间步长策略中的缺陷。时间步长选择为 $\\Delta t = 0.45\\, h_{\\min}^2$。这个选择遵守了由最小网格单元施加的约束，并且旨在满足稳定性条件。我们预期会发现 $a_{\\max} \\le 1$。随着相容性和稳定性都重新建立，该格式应该再次收敛，从而得到一个小于 1 的加密比 $r$。\n\n实现过程将构造矩阵 $L$，计算其特征值以找到 $a_{\\max}$，并计算相对于精确解 $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$ 的单步 $L^2$ 误差，以确定加密比 $r$。这些结果将为 Lax 等价定理以及根据最严格的局部网格间距选择时间步长的至关重要性提供一个实践演示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case_metrics(N, p, dt_policy):\n    \"\"\"\n    Computes stability and error metrics for a given grid and time step policy.\n\n    Args:\n        N (int): Number of interior grid points.\n        p (float): Power for graded grid generation. p=1 gives a uniform grid.\n        dt_policy (str): Time step policy, either 'min' or 'avg'.\n\n    Returns:\n        tuple: A tuple containing:\n            - l2_error (float): The discrete L2 norm of the one-step error.\n            - a_max (float): The maximum one-step amplification factor.\n            - is_stable (bool): True if the scheme is stable, False otherwise.\n    \"\"\"\n    # 1. Grid Generation\n    i_vals = np.arange(N + 2, dtype=float)\n    x = (i_vals / (N + 1))**p\n    h = np.diff(x)  # h has length N+1, h_i = x_{i+1} - x_i\n\n    # 2. Time Step Calculation\n    h_min = np.min(h)\n    # The problem defines h_bar as the sum over N+1 spacings divided by N+1\n    h_bar = np.mean(h)\n    \n    if dt_policy == 'min':\n        dt = 0.45 * h_min**2\n    elif dt_policy == 'avg':\n        dt = 0.45 * h_bar**2\n    else:\n        raise ValueError(\"Invalid dt_policy specified.\")\n\n    # 3. Construct the discrete operator matrix L\n    L = np.zeros((N, N))\n    # Loop over interior nodes i = 1, ..., N\n    # Matrix row j = i - 1 corresponds to node i\n    for j in range(N):\n        h_im1 = h[j]      # This is h_{i-1}\n        h_i   = h[j + 1]  # This is h_i\n        \n        # Diagonal term (coefficient of u_i)\n        L[j, j] = 2.0 * (-1.0 / (h_im1 * h_i))\n        \n        # Sub-diagonal term (coefficient of u_{i-1})\n        if j > 0:\n            L[j, j - 1] = 2.0 / (h_im1 * (h_im1 + h_i))\n        \n        # Super-diagonal term (coefficient of u_{i+1})\n        if j  N - 1:\n            L[j, j + 1] = 2.0 / (h_i * (h_im1 + h_i))\n\n    # 4. Compute stability metrics\n    eigenvalues = np.linalg.eigvals(L)\n    a_max = np.max(np.abs(1.0 + dt * eigenvalues))\n    is_stable = a_max = 1.0\n\n    # 5. Compute one-step L2 error\n    x_interior = x[1:N + 1]\n    \n    # Initial condition at interior nodes\n    u0 = np.sin(np.pi * x_interior)\n    \n    # Numerical solution at t = dt\n    u1_num = u0 + dt * (L @ u0)\n    \n    # Exact solution at t = dt\n    u1_exact = np.exp(-np.pi**2 * dt) * np.sin(np.pi * x_interior)\n    \n    # Error vector\n    error_vec = u1_num - u1_exact\n    \n    # Quadrature weights for L2 norm\n    # w_i = (h_{i-1} + h_i)/2. For interior nodes i=1..N, these are h_0..h_{N-1} + h_1..h_N\n    weights = 0.5 * (h[0:N] + h[1:N + 1])\n    \n    l2_error = np.sqrt(np.sum(weights * error_vec**2))\n    \n    return l2_error, a_max, is_stable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # (N_base, p, dt_policy) for each case\n    # p=1 represents a uniform grid as (i/(N+1))^1.\n    test_cases_params = [\n        (64, 1.0, 'min'),  # Case A: Uniform grid, stable by h_min\n        (64, 2.0, 'avg'),  # Case B: Graded grid, unstable by h_bar\n        (64, 2.0, 'min'),  # Case C: Graded grid, stable by h_min\n    ]\n\n    final_results = []\n    for N_base, p, policy in test_cases_params:\n        # Calculate metrics for the base grid N\n        E_N, a_max, is_stable = compute_case_metrics(N_base, p, policy)\n        \n        # Calculate error for the refined grid 2N to find the ratio\n        E_2N, _, _ = compute_case_metrics(2 * N_base, p, policy)\n        \n        # Refinement error ratio\n        r = E_2N / E_N\n        \n        final_results.append([is_stable, a_max, r])\n    \n    # Format the output string exactly as specified: [[val,val,val],[val,val,val],...]\n    case_strings = []\n    for s_bool, a_val, r_val in final_results:\n        # Python's bool __str__ is 'True' or 'False'\n        case_strings.append(f\"[{str(s_bool)},{a_val},{r_val}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于气候科学中常见的长期模拟而言，仅仅满足标准的稳定性条件有时是不够的。本练习探讨了一个微妙但关键的问题——“弱不稳定性”，即数值格式会随着时间的推移人为地放大振荡系统的能量。通过理论分析和编程练习  相结合，您将研究显式中点法的这种行为，并理解为什么在开发可靠的地球系统模型时，保持物理守恒律是至关重要的问题。",
            "id": "3217024",
            "problem": "考虑使用显式中点法求解常微分方程（ODE）。该方法利用速度场的中点来定义单步更新。从数值稳定性的第一性原理分析其在振荡问题上的行为，然后通过计算来验证观察到的行为。\n\n您必须从以下基本依据出发：\n- 用于稳定性分析的线性测试方程：$y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。\n- 简谐振子模型：$x''(t) + \\omega^2 x(t) = 0$，角频率 $\\omega  0$。\n- 单位质量的简谐振子的能量：$E(t) = \\tfrac{1}{2}\\left(v(t)^2 + \\omega^2 x(t)^2\\right)$，其中 $v(t) = x'(t)$。\n\n任务：\n1. 根据显式中点法的定义和线性测试方程 $y'(t) = \\lambda y(t)$，推导出单步放大因子 $R(z)$，它是 $z = h\\lambda$ 的函数，其中 $h  0$ 是时间步长。将其特化到纯虚数情况 $\\lambda = i\\omega$，其中 $\\omega  0$。证明对于任何非零步长 $h$，模 $\\lvert R(i\\omega h)\\rvert$ 都大于 $1$，并解释为何这意味着对于振荡动力学系统存在弱不稳定性，尽管该方法在有限区间上是一致且收敛的。\n2. 编写一个程序，通过将简谐振子方程 $x''(t) + \\omega^2 x(t) = 0$ 重写为一阶系统 $y'(t) = f(y(t))$（其中 $y(t) = \\begin{bmatrix}x(t) \\\\ v(t)\\end{bmatrix}$ 且 $f(y) = \\begin{bmatrix}v \\\\ -\\omega^2 x\\end{bmatrix}$）来进行积分。使用显式中点法更新状态：\n   - 计算 $k_1 = f(y_n)$，\n   - 计算中点状态 $y_{n+\\frac{1}{2}} = y_n + \\tfrac{h}{2}k_1$，\n   - 计算 $k_2 = f(y_{n+\\frac{1}{2}})$，\n   - 更新 $y_{n+1} = y_n + h k_2$。\n3. 对于每次模拟，使用初始条件 $x(0) = 1$ 和 $v(0) = 0$。设一个周期为 $T_p = \\tfrac{2\\pi}{\\omega}$。对于给定的周期数 $M$，使用固定步长 $h$ 和整数步数 $N = \\left\\lfloor \\tfrac{T}{h} \\right\\rfloor$ 对总时间 $T = M T_p$ 进行积分。计算并返回能量比 $r = \\tfrac{E_N}{E_0}$，其中 $E_0 = \\tfrac{1}{2}(\\omega^2 x(0)^2 + v(0)^2)$，$E_N$ 是 $N$ 步后的能量。所有量均为无量纲量；不需要物理单位。\n\n测试组：\n- 情况 1：$\\omega = 1$, $h = 0.5$, $M = 50$。\n- 情况 2：$\\omega = 1$, $h = 0.1$, $M = 200$。\n- 情况 3：$\\omega = 1$, $h = 0.01$, $M = 200$。\n- 情况 4：$\\omega = 2$, $h = 0.05$, $M = 200$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_j$ 是按上述顺序对应的测试用例的能量比。",
            "solution": "在尝试给出解答之前，对问题陈述进行了严格验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **方法**：用于常微分方程的显式中点法。\n- **更新步骤**：\n  1. $k_1 = f(y_n)$\n  2. $y_{n+\\frac{1}{2}} = y_n + \\tfrac{h}{2}k_1$\n  3. $k_2 = f(y_{n+\\frac{1}{2}})$\n  4. $y_{n+1} = y_n + h k_2$\n- **线性测试方程**：$y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。\n- **简谐振子 (SHO)**：$x''(t) + \\omega^2 x(t) = 0$，角频率 $\\omega  0$。\n- **SHO 能量**：$E(t) = \\tfrac{1}{2}\\left(v(t)^2 + \\omega^2 x(t)^2\\right)$，其中 $v(t) = x'(t)$ 且质量为单位1。\n- **任务 1**：推导 $z = h\\lambda$ 的放大因子 $R(z)$，证明对于 $\\lambda = i\\omega$，当 $h  0$ 时模 $\\lvert R(i\\omega h)\\rvert  1$，并解释其对弱不稳定性的影响。\n- **任务 2**：将 SHO 实现为一阶系统 $y'(t) = f(y(t))$（其中 $y(t) = \\begin{bmatrix}x(t) \\\\ v(t)\\end{bmatrix}$ 且 $f(y) = \\begin{bmatrix}v \\\\ -\\omega^2 x\\end{bmatrix}$）并应用该方法。\n- **任务 3**：使用初始条件 $x(0) = 1$, $v(0) = 0$ 运行模拟。在 $M$ 个周期内进行积分，总时间 $T = M T_p = M \\frac{2\\pi}{\\omega}$，使用步长为 $h$ 的 $N = \\left\\lfloor \\tfrac{T}{h} \\right\\rfloor$ 步。计算能量比 $r = E_N / E_0$。\n- **测试组**：\n  - 情况 1：$\\omega = 1$, $h = 0.5$, $M = 50$。\n  - 情况 2：$\\omega = 1$, $h = 0.1$, $M = 200$。\n  - 情况 3：$\\omega = 1$, $h = 0.01$, $M = 200$。\n  - 情况 4：$\\omega = 2$, $h = 0.05$, $M = 200$。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估：\n- **科学依据**：该问题在根本上是合理的。它涉及对一个标准的显式 Runge-Kutta 方法（显式中点法，RK2）应用于典型的线性测试方程和简谐振子的稳定性分析。这些都是数值常微分方程领域的基石性课题。\n- **适定性**：该问题是适定的。它提供了完整的算法描述、一组特定的初始条件和参数，以及对解析推导和计算实验的明确目标。任务明确，能够得出一个唯一的、可验证的解。\n- **客观性**：问题以客观、正式的语言陈述，没有任何主观性或偏见。所有术语在数学和科学计算领域都是标准术语。\n- **缺陷检查表**：该问题没有表现出任何使其无效的缺陷。它并非科学上不合理、不完整、自相矛盾、不切实际或不适定。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将提供完整的解答。\n\n### 解答\n\n此问题要求对显式中点法进行两部分分析：使用线性测试方程进行理论稳定性分析，以及对其在简谐振子（一个动力学行为纯粹是振荡的系统）上的行为进行计算验证。\n\n**1. 稳定性分析与放大因子**\n\n我们首先分析该方法在线性测试方程 $y'(t) = \\lambda y(t)$ 上的行为。在第 $n$ 步的数值解（记为 $y_n$）理想情况下应遵循精确解 $y(t_n)$ 的行为。显式中点法的应用如下：\n\n设 $f(y) = \\lambda y$。从 $y_n$推进到 $y_{n+1}$ 的步骤是：\n1.  计算第一阶段的斜率：$k_1 = f(y_n) = \\lambda y_n$。\n2.  使用斜率 $k_1$ 计算时间中点处的状态：$y_{n+\\frac{1}{2}} = y_n + \\frac{h}{2}k_1 = y_n + \\frac{h}{2}(\\lambda y_n) = (1 + \\frac{h\\lambda}{2})y_n$。\n3.  计算中点状态处的斜率：$k_2 = f(y_{n+\\frac{1}{2}}) = \\lambda y_{n+\\frac{1}{2}} = \\lambda(1 + \\frac{h\\lambda}{2})y_n$。\n4.  使用中点斜率 $k_2$ 更新状态：$y_{n+1} = y_n + h k_2 = y_n + h \\left[\\lambda(1 + \\frac{h\\lambda}{2})y_n\\right]$。\n\n从最终表达式中提出 $y_n$ 因子，得到单步更新规则：\n$$y_{n+1} = \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2}\\right) y_n$$\n\n括号中的项是放大因子 $R(z)$，它决定了数值解在每一步中如何被缩放。它是 $z = h\\lambda$ 的多项式函数。\n$$R(z) = 1 + z + \\frac{z^2}{2}$$\n这可以看作是 $e^z$ 的二阶泰勒级数展开，与该方法的二阶精度相符。\n\n对于振荡问题，系统雅可比矩阵的特征值位于虚轴上。我们通过设置 $\\lambda = i\\omega$ 来对此进行建模，其中 $\\omega  0$ 是一个实数频率。因此，$z = i\\omega h$。我们将此代入放大因子：\n$$R(i\\omega h) = 1 + (i\\omega h) + \\frac{(i\\omega h)^2}{2} = 1 + i\\omega h - \\frac{(\\omega h)^2}{2}$$\n这个复数可以写成其实部和虚部的形式：\n$$R(i\\omega h) = \\left(1 - \\frac{(\\omega h)^2}{2}\\right) + i(\\omega h)$$\n\n该方法对于振荡问题的稳定性取决于此放大因子的模。如果 $\\lvert R(i\\omega h) \\rvert \\le 1$，则该方法是稳定的；否则，数值解的振幅将被人为地放大。我们计算模的平方：\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(\\text{Re}[R(i\\omega h)]\\right)^2 + \\left(\\text{Im}[R(i\\omega h)]\\right)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(1 - \\frac{(\\omega h)^2}{2}\\right)^2 + (\\omega h)^2$$\n展开平方项：\n$$\\lvert R(i\\omega h) \\rvert^2 = \\left(1 - 2 \\cdot \\frac{(\\omega h)^2}{2} + \\frac{(\\omega h)^4}{4}\\right) + (\\omega h)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = 1 - (\\omega h)^2 + \\frac{(\\omega h)^4}{4} + (\\omega h)^2$$\n$$\\lvert R(i\\omega h) \\rvert^2 = 1 + \\frac{(\\omega h)^4}{4}$$\n因此，模为：\n$$\\lvert R(i\\omega h) \\rvert = \\sqrt{1 + \\frac{(\\omega h)^4}{4}}$$\n对于任何非零步长 $h  0$ 和频率 $\\omega  0$，项 $(\\omega h)^4$ 严格为正。因此，$\\frac{(\\omega h)^4}{4}  0$，这意味着 $1 + \\frac{(\\omega h)^4}{4}  1$，所以 $\\lvert R(i\\omega h) \\rvert  1$。\n\n这个结果证明了显式中点法在虚轴上是无条件不稳定的。数值解的振幅在每一步都被一个大于1的因子放大。这导致解的范数在长时间积分后呈指数增长，这种现象被称为弱不稳定性。虽然该方法是一致的（局部误差为 $\\mathcal{O}(h^3)$），因此在任何有限时间区间 $[0, T]$ 上都是收敛的，但误差常数随 $T$呈指数增长，这使得该方法不适用于像简谐振子这样的保守系统的长期模拟，因为在这些系统中能量应该是守恒的。数值能量将系统性地增加，这一点将通过计算得到验证。\n\n**2. 计算实现与能量分析**\n\n通过定义状态向量 $y(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$（其中 $v(t) = x'(t)$），二阶 SHO 方程 $x''(t) + \\omega^2 x(t) = 0$ 被转换为一阶系统。系统动力学由以下公式给出：\n$$y'(t) = \\begin{bmatrix} x'(t) \\\\ v'(t) \\end{bmatrix} = \\begin{bmatrix} v(t) \\\\ -\\omega^2 x(t) \\end{bmatrix} = f(y(t))$$\n我们将使用显式中点法和指定的测试用例参数来对该系统进行积分。从 $y_n = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix}$ 到 $y_{n+1}$ 的每一步：\n1.  $k_1 = \\begin{bmatrix} k_{1,x} \\\\ k_{1,v} \\end{bmatrix} = \\begin{bmatrix} v_n \\\\ -\\omega^2 x_n \\end{bmatrix}$。\n2.  $y_{n+\\frac{1}{2}} = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix} + \\frac{h}{2} \\begin{bmatrix} v_n \\\\ -\\omega^2 x_n \\end{bmatrix} = \\begin{bmatrix} x_n + \\frac{h}{2}v_n \\\\ v_n - \\frac{h}{2}\\omega^2 x_n \\end{bmatrix}$。\n3.  $k_2 = \\begin{bmatrix} k_{2,x} \\\\ k_{2,v} \\end{bmatrix} = f(y_{n+\\frac{1}{2}}) = \\begin{bmatrix} v_n - \\frac{h}{2}\\omega^2 x_n \\\\ -\\omega^2(x_n + \\frac{h}{2}v_n) \\end{bmatrix}$。\n4.  $y_{n+1} = \\begin{bmatrix} x_{n+1} \\\\ v_{n+1} \\end{bmatrix} = \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix} + h k_2 = \\begin{bmatrix} x_n + h(v_n - \\frac{h}{2}\\omega^2 x_n) \\\\ v_n - h\\omega^2(x_n + \\frac{h}{2}v_n) \\end{bmatrix}$。\n\n初始状态为 $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。初始能量为 $E_0 = \\frac{1}{2}(v(0)^2 + \\omega^2 x(0)^2) = \\frac{1}{2}(0^2 + \\omega^2 \\cdot 1^2) = \\frac{\\omega^2}{2}$。\n经过 $N$ 步后，最终状态为 $y_N = \\begin{bmatrix} x_N \\\\ v_N \\end{bmatrix}$。最终能量为 $E_N = \\frac{1}{2}(v_N^2 + \\omega^2 x_N^2)$。程序将为每个测试用例计算比率 $r = E_N/E_0$。该比率量化了由稳定性分析预测的数值能量漂移。\n对于无量纲积 $\\omega h$ 的较大值和较大的积分步数 $N$，能量的增长预计会更加显著。\n具体而言，能量比 $r_N = E_N/E_0$ 预计将近似按 $(1 + \\frac{(\\omega h)^4}{4})^N$ 增长。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the explicit midpoint method on the simple harmonic oscillator.\n\n    This function implements the explicit midpoint method to solve the\n    simple harmonic oscillator equation system for four different test cases.\n    It calculates the ratio of the final numerical energy to the initial\n    analytical energy, demonstrating the method's weak instability for\n    oscillatory problems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, h, M)\n    test_cases = [\n        (1.0, 0.5, 50),\n        (1.0, 0.1, 200),\n        (1.0, 0.01, 200),\n        (2.0, 0.05, 200),\n    ]\n\n    results = []\n    for omega, h, M in test_cases:\n        # Initial conditions\n        x0 = 1.0\n        v0 = 0.0\n        y = np.array([x0, v0], dtype=np.float64)\n\n        # System definition f(y) = [v, -omega^2 * x]\n        def f(state_vec, omega_val):\n            x, v = state_vec\n            return np.array([v, -omega_val**2 * x], dtype=np.float64)\n\n        # Simulation time parameters\n        # T_p is one period\n        T_p = 2.0 * np.pi / omega\n        # T is total integration time\n        T = M * T_p\n        # N is the total number of integer steps\n        N = int(np.floor(T / h))\n\n        # Calculate initial energy E_0\n        # E(t) = 0.5 * (v(t)^2 + omega^2 * x(t)^2)\n        E0 = 0.5 * (y[1]**2 + omega**2 * y[0]**2)\n\n        # Integration loop using explicit midpoint method\n        for _ in range(N):\n            # k1 = f(y_n)\n            k1 = f(y, omega)\n            \n            # y_mid = y_n + (h/2) * k1\n            y_mid = y + (h / 2.0) * k1\n            \n            # k2 = f(y_mid)\n            k2 = f(y_mid, omega)\n            \n            # y_{n+1} = y_n + h * k2\n            y = y + h * k2\n\n        # Calculate final energy E_N\n        EN = 0.5 * (y[1]**2 + omega**2 * y[0]**2)\n        \n        # Avoid division by zero if initial energy is zero, though not possible\n        # with the given ICs.\n        if E0 == 0:\n            energy_ratio = np.inf\n        else:\n            energy_ratio = EN / E0\n        \n        results.append(energy_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}