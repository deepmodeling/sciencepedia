{
    "hands_on_practices": [
        {
            "introduction": "精确地近似导数是许多数值模型的基础。对于给定的网格间距，高阶格式可以提供更高的精度，这对于提高计算效率至关重要。本练习  将引导你走过一个基本过程：使用泰勒级数推导高阶差分格式的系数，这是数值分析中的一项基石技术。",
            "id": "3913939",
            "problem": "在求解平流-扩散偏微分方程的大尺度环境和地球系统模型的数值核心中，诸如 $\\partial_{x} u$ 的梯度是在结构化网格上计算的。考虑一个均匀的一维网格，其节点为 $x_i = x_0 + i h$（其中 $i$ 为整数），间距为 $h > 0$。在内部节点 $x_i$ 处，仅使用模板 $\\{x_i - 2h, x_i - h, x_i, x_i + h, x_i + 2h\\}$，通过以下形式的中心有限差分算子来近似 $\\partial_{x} u(x_i)$：\n$$\n\\left.\\partial_{x} u\\right|_{x_i} \\approx \\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k\\, u(x_i + k h),\n$$\n其中系数 $\\alpha_k$ 与 $u$ 和 $h$ 无关。\n\n从关于 $x_i$ 的泰勒级数展开式出发，并强制要求该离散算子对足够低阶的多项式能够重现精确导数，推导出一组唯一的系数 $\\{\\alpha_{-2}, \\alpha_{-1}, \\alpha_{0}, \\alpha_{1}, \\alpha_{2}\\}$，使得此模板上的 $\\partial_{x} u(x_i)$ 的中心差分格式具有关于 $h$ 的四阶精度。然后，通过确定展开式中的精确常数 $C$ 来量化主截断误差：\n$$\n\\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k\\, u(x_i + k h) \\;=\\; \\partial_{x} u(x_i) \\;+\\; C\\, h^{4}\\, \\partial_{x}^{5} u(x_i) \\;+\\; \\mathcal{O}(h^{6}).\n$$\n\n仅使用泰勒级数和通过匹配 $x_i$ 处的导数所得到的代数一致性条件。将你的最终结果以行向量 $(\\alpha_{-2}, \\alpha_{-1}, \\alpha_{0}, \\alpha_{1}, \\alpha_{2}, C)$ 的形式报告。提供精确的有理数值。不需要四舍五入，最终答案不应报告任何单位。",
            "solution": "该问题要求为一个五点中心有限差分算子推导系数 $\\{\\alpha_k\\}$，该算子以四阶精度近似一阶导数 $\\partial_x u(x_i)$，并确定主截断误差项的常数 $C$。\n\n有限差分算子由下式给出：\n$$\nD_h[u](x_i) = \\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k u(x_i + k h)\n$$\n我们使用泰勒级数将每一项 $u(x_i + k h)$ 在点 $x_i$ 附近展开。令 $u^{(n)}(x_i) \\equiv \\partial_x^n u(x_i)$。展开式为：\n$$\nu(x_i + k h) = \\sum_{n=0}^{\\infty} \\frac{(k h)^n}{n!} u^{(n)}(x_i) = u(x_i) + (kh)u^{(1)}(x_i) + \\frac{(kh)^2}{2!}u^{(2)}(x_i) + \\dots\n$$\n将此代入算子表达式中，得到：\n$$\nD_h[u](x_i) = \\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k \\left( \\sum_{n=0}^{\\infty} \\frac{(k h)^n}{n!} u^{(n)}(x_i) \\right)\n$$\n通过交换求和顺序，我们可以按 $u$ 的导数阶数对各项进行分组：\n$$\nD_h[u](x_i) = \\sum_{n=0}^{\\infty} \\left( \\frac{h^{n-1}}{n!} \\sum_{k=-2}^{2} k^n \\alpha_k \\right) u^{(n)}(x_i)\n$$\n我们定义系数的矩为 $M_n = \\sum_{k=-2}^{2} k^n \\alpha_k$。展开式变为：\n$$\nD_h[u](x_i) = \\frac{M_0}{h} u(x_i) + M_1 u^{(1)}(x_i) + \\frac{M_2}{2} h u^{(2)}(x_i) + \\frac{M_3}{6} h^2 u^{(3)}(x_i) + \\frac{M_4}{24} h^3 u^{(4)}(x_i) + \\frac{M_5}{120} h^4 u^{(5)}(x_i) + \\mathcal{O}(h^5)\n$$\n我们希望这个算子能够以 $\\mathcal{O}(h^4)$ 的误差近似 $\\partial_x u(x_i) = u^{(1)}(x_i)$。这意味着 $D_h[u](x_i)$ 的表达式必须与 $u^{(1)}(x_i)$ 匹配，直到 $h^3$ 阶项。这就产生了一个关于系数 $\\alpha_k$ 的线性方程组：\n1.  $u(x_i)$ 的系数必须为零：$\\frac{M_0}{h} = 0 \\implies M_0 = \\sum_{k=-2}^{2} \\alpha_k = 0$。\n2.  $u^{(1)}(x_i)$ 的系数必须为一：$M_1 = \\sum_{k=-2}^{2} k \\alpha_k = 1$。\n3.  $h u^{(2)}(x_i)$ 的系数必须为零：$\\frac{M_2}{2} = 0 \\implies M_2 = \\sum_{k=-2}^{2} k^2 \\alpha_k = 0$。\n4.  $h^2 u^{(3)}(x_i)$ 的系数必须为零：$\\frac{M_3}{6} = 0 \\implies M_3 = \\sum_{k=-2}^{2} k^3 \\alpha_k = 0$。\n5.  为达到四阶精度，$h^3 u^{(4)}(x_i)$ 的系数必须为零：$\\frac{M_4}{24} = 0 \\implies M_4 = \\sum_{k=-2}^{2} k^4 \\alpha_k = 0$。\n\n这就得到了一个包含五个未知系数 $\\alpha_{-2}, \\alpha_{-1}, \\alpha_0, \\alpha_1, \\alpha_2$ 的五元线性方程组。\n由于这是对称模板上的一阶导数中心差分格式，我们可以预期系数是反对称的，即 $\\alpha_0 = 0$ 和 $\\alpha_{-k} = -\\alpha_k$。让我们从方程中验证这一点。\n对偶数阶矩 $M_2$ 和 $M_4$ 的条件是：\n$M_2 = 4\\alpha_{-2} + \\alpha_{-1} + \\alpha_1 + 4\\alpha_2 = 4(\\alpha_2 + \\alpha_{-2}) + (\\alpha_1 + \\alpha_{-1}) = 0$\n$M_4 = 16\\alpha_{-2} + \\alpha_{-1} + \\alpha_1 + 16\\alpha_2 = 16(\\alpha_2 + \\alpha_{-2}) + (\\alpha_1 + \\alpha_{-1}) = 0$\n用第二个方程减去第一个方程得到 $12(\\alpha_2+\\alpha_{-2}) = 0$，这意味着 $\\alpha_{-2} = -\\alpha_2$。将其代回任一方程，可得 $\\alpha_{-1} = -\\alpha_1$。\n最后，条件 $M_0=0$ 给出 $\\alpha_{-2}+\\alpha_{-1}+\\alpha_0+\\alpha_1+\\alpha_2 = 0$。利用反对称性，该式简化为 $(-\\alpha_2) + (-\\alpha_1) + \\alpha_0 + \\alpha_1 + \\alpha_2 = 0$，这意味着 $\\alpha_0=0$。\n\n使用这些反对称关系可以简化奇数阶矩 $M_1$ 和 $M_3$ 的剩余方程：\n$M_1 = -2\\alpha_{-2} - \\alpha_{-1} + \\alpha_1 + 2\\alpha_2 = 1$\n$\\implies -2(-\\alpha_2) - (-\\alpha_1) + \\alpha_1 + 2\\alpha_2 = 2\\alpha_1 + 4\\alpha_2 = 1$。\n\n$M_3 = (-2)^3\\alpha_{-2} + (-1)^3\\alpha_{-1} + (1)^3\\alpha_1 + (2)^3\\alpha_2 = 0$\n$\\implies -8(-\\alpha_2) - (-\\alpha_1) + \\alpha_1 + 8\\alpha_2 = 2\\alpha_1 + 16\\alpha_2 = 0$。\n\n我们现在有一个关于 $\\alpha_1$ 和 $\\alpha_2$ 的二元方程组：\n1. $2\\alpha_1 + 4\\alpha_2 = 1$\n2. $2\\alpha_1 + 16\\alpha_2 = 0$\n\n用第二个方程减去第一个方程得到 $12\\alpha_2 = -1$，所以 $\\alpha_2 = -\\frac{1}{12}$。\n将此值代回第二个方程：$2\\alpha_1 + 16(-\\frac{1}{12}) = 0 \\implies 2\\alpha_1 = \\frac{16}{12} = \\frac{4}{3} \\implies \\alpha_1 = \\frac{2}{3}$。\n\n完整的系数集为：\n$\\alpha_2 = -\\frac{1}{12}$\n$\\alpha_1 = \\frac{2}{3}$\n$\\alpha_0 = 0$\n$\\alpha_{-1} = -\\alpha_1 = -\\frac{2}{3}$\n$\\alpha_{-2} = -\\alpha_2 = \\frac{1}{12}$\n\n因此，离散算子为：\n$$\nD_h[u](x_i) = \\frac{1}{12h} \\left( u(x_i-2h) - 8u(x_i-h) + 8u(x_i+h) - u(x_i+2h) \\right)\n$$\n问题指明，所得展开式的形式为：\n$$\nD_h[u](x_i) = \\partial_{x} u(x_i) + C h^{4} \\partial_{x}^{5} u(x_i) + \\mathcal{O}(h^{6})\n$$\n主误差项对应于我们泰勒级数展开式中 $M_1 u^{(1)}(x_i)$ 之后的第一个非零项。根据构造，带有 $u^{(2)}, u^{(3)}, u^{(4)}$ 的项都为零。下一项是 $n=5$ 的情况：\n$$\n\\text{Error} = \\frac{M_5}{5!} h^4 u^{(5)}(x_i) + \\mathcal{O}(h^5)\n$$\n问题陈述指出，在 $h^4$ 项之后，误差为 $\\mathcal{O}(h^6)$。这是因为对于一阶导数的对称中心差分算子，所有偶数阶误差项的系数都为零（由于对称性，导致奇数阶矩 $M_{2n+1}$ 的模板系数不全为零，但偶数阶矩 $M_{2n}$ 为零），这消除了所有偶数阶导数误差项（例如 $u^{(6)}$，其阶数为 $h^5$）。因此，常数 $C$ 是 $h^4 u^{(5)}(x_i)$ 的系数，所以 $C = \\frac{M_5}{5!}$。我们必须计算 $M_5$：\n$$\nM_5 = \\sum_{k=-2}^{2} k^5 \\alpha_k = (-2)^5\\alpha_{-2} + (-1)^5\\alpha_{-1} + (0)^5\\alpha_0 + (1)^5\\alpha_1 + (2)^5\\alpha_2\n$$\n代入系数值：\n$$\nM_5 = (-32)\\left(\\frac{1}{12}\\right) + (-1)\\left(-\\frac{2}{3}\\right) + (1)\\left(\\frac{2}{3}\\right) + (32)\\left(-\\frac{1}{12}\\right)\n$$\n$$\nM_5 = -\\frac{32}{12} + \\frac{2}{3} + \\frac{2}{3} - \\frac{32}{12} = -\\frac{64}{12} + \\frac{4}{3} = -\\frac{16}{3} + \\frac{4}{3} = -\\frac{12}{3} = -4\n$$\n现在我们可以计算 $C$：\n$$\nC = \\frac{M_5}{5!} = \\frac{-4}{120} = -\\frac{1}{30}\n$$\n所要求的最终结果是行向量 $(\\alpha_{-2}, \\alpha_{-1}, \\alpha_{0}, \\alpha_{1}, \\alpha_{2}, C)$。\n\n各分量为：\n$\\alpha_{-2} = \\frac{1}{12}$\n$\\alpha_{-1} = -\\frac{2}{3}$\n$\\alpha_{0} = 0$\n$\\alpha_{1} = \\frac{2}{3}$\n$\\alpha_{2} = -\\frac{1}{12}$\n$C = -\\frac{1}{30}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{12} & -\\frac{2}{3} & 0 & \\frac{2}{3} & -\\frac{1}{12} & -\\frac{1}{30}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "数值格式不仅会产生数学误差，还可能在模拟中引入非物理行为。本练习  探讨了一种简单的一阶“迎风”平流格式如何引入人为的数值耗散，这是一种数值混合的形式。通过推导“修正方程”，我们可以量化这种效应，并理解离散化方案的选择如何直接影响模型输出的物理真实性。",
            "id": "3913901",
            "problem": "考虑一个长度为 $L$ 的周期性域上，具有恒定速度 $u$ 的被动示踪剂的一维纯平流。连续控制方程是线性平流方程 $\\,\\partial_t c + u \\,\\partial_x c = 0\\,$。在一个包含 $N$ 个单元的均匀网格上，一个采用间距 $\\Delta x = L/N$ 和显式时间步长 $\\Delta t$ 的数值格式使用 Courant-Friedrichs-Lewy (CFL) 数 $\\,\\nu = u \\Delta t / \\Delta x\\,$。示踪剂被初始化为单个傅里叶模式 $\\,c(x,0) = \\sin(k x)\\,$，其中波数为 $\\,k = 2\\pi m/L\\,$，模式指数 $m$ 为整数。对于时间层 $n$ 的离散状态 $\\,\\{c_i^n\\}_{i=0}^{N-1}\\,$，定义离散空间平均值 $\\,\\bar{c}^n = \\frac{1}{N}\\sum_{i=0}^{N-1} c_i^n\\,$ 和离散方差 $\\,\\mathrm{Var}^n = \\frac{1}{N}\\sum_{i=0}^{N-1} (c_i^n - \\bar{c}^n)^2\\,$。在连续平流动力学下，方差在时间上是精确守恒的；然而，在离散网格上，由于截断误差，方差可能会发生伪衰减，这是网格引发的数值混合的一种表现。\n\n从平流方程和对于 $\\,u>0\\,$ 的一阶迎风显式格式的定义出发，\n$$\nc_i^{n+1} = c_i^{n} - \\nu \\left(c_i^{n} - c_{i-1}^{n}\\right),\n$$\n推导出该格式所求解的主阶修正方程，表示为平流方程加上一个由截断误差产生的最低阶修正项。使用这个结果来获得单个傅里叶模式离散方差的瞬时衰减率的主阶预测值，记为 $\\,r_{\\mathrm{pred}}\\,$, 作为 $\\,u\\,$, $\\,\\Delta x\\,$, $\\,\\nu\\,$ 和 $\\,k\\,$ 的函数。然后，使用相同的一阶迎风格式实现一个单步模拟，以计算测得的方差瞬时衰减率，\n$$\nr_{\\mathrm{meas}} = - \\frac{\\mathrm{Var}^{n+1} - \\mathrm{Var}^{n}}{\\Delta t\\,\\mathrm{Var}^{n}},\n$$\n在 $\\,n=0\\,$ 时，通过循环索引施加周期性边界条件。假设使用无量纲单位，其中 $\\,L=1\\,$ 且 $\\,u=1\\,$，因此速率的单位是无量纲时间的倒数。\n\n您的程序必须：\n- 构建均匀网格，并将示踪剂在具有周期性的 $[0,1)$ 上初始化为 $\\,c(x) = \\sin(2\\pi m x)\\,$。\n- 对于 $\\,u>0\\,$，使用一阶迎风格式推进一个显式时间步。\n- 从离散状态计算 $\\,\\mathrm{Var}^{0}\\,$ 和 $\\,\\mathrm{Var}^{1}\\,$，然后计算 $\\,r_{\\mathrm{meas}}\\,$。\n- 根据您的修正方程分析计算主阶预测值 $\\,r_{\\mathrm{pred}}\\,$。\n- 报告每个测试用例的绝对误差 $\\,|r_{\\mathrm{meas}} - r_{\\mathrm{pred}}|\\,$。\n\n测试套件规范 (所有情况均使用 $\\,L=1\\,$ 和 $\\,u=1\\,$):\n- 情况 1: $N=128$, $m=4$, $\\nu=0.3$。\n- 情况 2: $N=128$, $m=32$, $\\nu=0.3$。\n- 情况 3: $N=128$, $m=4$, $\\nu=1.0$。\n- 情况 4: $N=64$, $m=16$, $\\nu=0.7$。\n- 情况 5: $N=64$, $m=8$, $\\nu=0.05$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按五个测试用例的顺序排列结果，其中每个条目是作为浮点数的绝对误差 $\\,|r_{\\mathrm{meas}} - r_{\\mathrm{pred}}|\\,$。例如，输出格式必须与 $[a_1,a_2,a_3,a_4,a_5]$ 完全一样，不含任何额外文本。",
            "solution": "目标是推导由一阶迎风格式平流的单个傅里叶模式的方差瞬时衰减率的主阶理论预测值 $r_{\\mathrm{pred}}$，并将其与数值测量的速率 $r_{\\mathrm{meas}}$ 进行比较。分析始于推导数值格式隐式求解的修正方程。\n\n对于正速度 $u>0$ 的一维一阶迎风格式由下式给出：\n$$\nc_i^{n+1} = c_i^{n} - \\nu \\left(c_i^{n} - c_{i-1}^{n}\\right)\n$$\n其中 $c_i^n$ 是网格单元 $i$ 和时间层 $n$ 处的离散示踪剂浓度，$\\nu = u \\Delta t / \\Delta x$ 是 Courant-Friedrichs-Lewy (CFL) 数，$\\Delta t$ 为时间步长，$\\Delta x$ 为网格间距。\n\n为了推导修正方程，我们将格式中的每一项围绕点 $(x_i, t_n)$ 进行泰勒级数展开，将 $c$ 视为一个光滑函数 $c(x,t)$。\n\\begin{align*}\nc_i^{n+1} = c(x_i, t_n + \\Delta t) \\approx c + \\Delta t \\, \\partial_t c + \\frac{(\\Delta t)^2}{2} \\, \\partial_{tt} c + O((\\Delta t)^3) \\\\\nc_i^{n} = c(x_i, t_n) = c \\\\\nc_{i-1}^{n} = c(x_i - \\Delta x, t_n) \\approx c - \\Delta x \\, \\partial_x c + \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c - \\frac{(\\Delta x)^3}{6} \\, \\partial_{xxx} c + O((\\Delta x)^4)\n\\end{align*}\n将这些展开式代入数值格式得到：\n$$\nc + \\Delta t \\, \\partial_t c + \\frac{(\\Delta t)^2}{2} \\, \\partial_{tt} c + \\dots = c - \\nu \\left[c - \\left(c - \\Delta x \\, \\partial_x c + \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c - \\dots\\right)\\right]\n$$\n化简右侧：\n$$\nc + \\Delta t \\, \\partial_t c + \\frac{(\\Delta t)^2}{2} \\, \\partial_{tt} c + \\dots = c - \\nu \\left(\\Delta x \\, \\partial_x c - \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c + \\dots\\right)\n$$\n两边除以 $\\Delta t$ 并代入 $\\nu/\\Delta t = u/\\Delta x$：\n$$\n\\partial_t c + \\frac{\\Delta t}{2} \\, \\partial_{tt} c + \\dots = - \\frac{u}{\\Delta x} \\left(\\Delta x \\, \\partial_x c - \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c + \\dots\\right)\n$$\n$$\n\\partial_t c + \\frac{\\Delta t}{2} \\, \\partial_{tt} c + \\dots = -u \\, \\partial_x c + \\frac{u \\Delta x}{2} \\, \\partial_{xx} c + \\dots\n$$\n重新整理以匹配原始平流方程 $\\partial_t c + u \\partial_x c = 0$ 的形式：\n$$\n\\partial_t c + u \\, \\partial_x c = \\frac{u \\Delta x}{2} \\, \\partial_{xx} c - \\frac{\\Delta t}{2} \\, \\partial_{tt} c + O(\\Delta x^2, (\\Delta t)^2)\n$$\n这个方程包含一个高阶时间导数 $\\partial_{tt}c$。为了获得仅用空间导数表示的主阶修正方程，我们对 $\\partial_{tt}c$ 进行近似。从原始偏微分方程（PDE）可知，主阶上 $\\partial_t c = -u \\partial_x c$。对时间求导得到 $\\partial_{tt} c = \\partial_t(-u \\partial_x c) = -u \\partial_x (\\partial_t c)$。再次代入 PDE 得到 $\\partial_{tt} c \\approx -u \\partial_x (-u \\partial_x c) = u^2 \\partial_{xx} c$。将此结果代回我们的方程中：\n$$\n\\partial_t c + u \\, \\partial_x c = \\frac{u \\Delta x}{2} \\, \\partial_{xx} c - \\frac{\\Delta t}{2} (u^2 \\partial_{xx} c) + \\dots\n$$\n$$\n\\partial_t c + u \\, \\partial_x c = \\left(\\frac{u \\Delta x}{2} - \\frac{u^2 \\Delta t}{2}\\right) \\partial_{xx} c + \\dots\n$$\n提出公因子并回顾 $\\nu = u \\Delta t / \\Delta x$：\n$$\n\\partial_t c + u \\, \\partial_x c = \\frac{u \\Delta x}{2} \\left(1 - \\frac{u \\Delta t}{\\Delta x}\\right) \\partial_{xx} c + \\dots = \\frac{u \\Delta x}{2} (1 - \\nu) \\partial_{xx} c + \\dots\n$$\n这就是主阶修正方程。它是一个平流-扩散方程，其中数值格式引入了一个人工扩散项，其数值扩散系数为 $D_{\\mathrm{num}} = \\frac{u \\Delta x}{2} (1 - \\nu)$。这个扩散项是导致方差伪衰减的原因。\n\n现在我们推导方差的预测衰减率。在长度为 $L$ 的周期域上，连续场 $c(x,t)$ 的方差为 $\\mathrm{Var}(t) = \\frac{1}{L} \\int_0^L (c(x,t) - \\bar{c})^2 dx$，其中 $\\bar{c}$ 是空间平均值。对于初始条件 $c(x,0) = \\sin(kx)$，其中 $k=2\\pi m/L$，对于任何整数 $m \\neq 0$，平均值为零。由于平流-扩散方程是线性的并且守恒平均值，$\\bar{c}$ 保持为零。因此，$\\mathrm{Var}(t) = \\frac{1}{L} \\int_0^L c^2 dx$。\n\n方差的时间变化率为：\n$$\n\\frac{d\\mathrm{Var}}{dt} = \\frac{1}{L} \\int_0^L 2c \\, \\frac{\\partial c}{\\partial t} \\, dx\n$$\n从修正方程代入 $\\partial_t c$：\n$$\n\\frac{d\\mathrm{Var}}{dt} = \\frac{1}{L} \\int_0^L 2c \\left( -u \\partial_x c + D_{\\mathrm{num}} \\partial_{xx} c \\right) dx = -\\frac{2u}{L} \\int_0^L c \\, \\partial_x c \\, dx + \\frac{2D_{\\mathrm{num}}}{L} \\int_0^L c \\, \\partial_{xx} c \\, dx\n$$\n第一个积分 $\\int_0^L c \\, \\partial_x c \\, dx = \\frac{1}{2} \\int_0^L \\partial_x(c^2) dx = \\frac{1}{2}[c^2]_0^L$ 由于周期性而为零。第二个积分，使用分部积分法，为 $\\int_0^L c \\, \\partial_{xx} c \\, dx = [c \\, \\partial_x c]_0^L - \\int_0^L (\\partial_x c)^2 dx$。边界项 $[c \\, \\partial_x c]_0^L$ 也由于周期性而为零，剩下 $\\int_0^L c \\, \\partial_{xx} c \\, dx = - \\int_0^L (\\partial_x c)^2 dx$。\n因此，方差的变化率为：\n$$\n\\frac{d\\mathrm{Var}}{dt} = - \\frac{2 D_{\\mathrm{num}}}{L} \\int_0^L (\\partial_x c)^2 dx\n$$\n方差的瞬时相对衰减率为 $r = - \\frac{1}{\\mathrm{Var}} \\frac{d\\mathrm{Var}}{dt}$。在时间 $t=0$ 时，对于 $c(x,0) = \\sin(kx)$：\n\\begin{align*}\n\\mathrm{Var}^0 = \\frac{1}{L} \\int_0^L \\sin^2(kx) dx = \\frac{1}{2} \\\\\n\\int_0^L (\\partial_x c)^2 dx = \\int_0^L (k \\cos(kx))^2 dx = k^2 \\int_0^L \\cos^2(kx) dx = k^2 \\frac{L}{2}\n\\end{align*}\n所以，在 $t=0$ 时，$\\frac{d\\mathrm{Var}}{dt} = - \\frac{2 D_{\\mathrm{num}}}{L} \\left( k^2 \\frac{L}{2} \\right) = -D_{\\mathrm{num}} k^2$。\n预测的衰减率为：\n$$\nr_{\\mathrm{pred}} = - \\frac{1}{\\mathrm{Var}^0} \\left. \\frac{d\\mathrm{Var}}{dt} \\right|_{t=0} = - \\frac{-D_{\\mathrm{num}} k^2}{1/2} = 2 D_{\\mathrm{num}} k^2\n$$\n代入 $D_{\\mathrm{num}}$ 的表达式：\n$$\nr_{\\mathrm{pred}} = 2 \\left( \\frac{u \\Delta x}{2} (1 - \\nu) \\right) k^2 = u \\Delta x (1 - \\nu) k^2\n$$\n这就是要计算的理论预测值。\n\n对于数值测量，我们计算 $r_{\\mathrm{meas}} = - \\frac{\\mathrm{Var}^{1} - \\mathrm{Var}^{0}}{\\Delta t\\,\\mathrm{Var}^{0}}$。步骤如下：\n1. 对于每个测试用例（$N, m, \\nu$），设置常数 $L=1$ 和 $u=1$。\n2. 计算网格参数：$\\Delta x = L/N$，$\\Delta t = \\nu \\Delta x / u$，以及波数 $k = 2\\pi m / L$。\n3. 在网格 $x_i = i \\Delta x$ 上初始化离散场，其中 $i=0, \\dots, N-1$：$c_i^0 = \\sin(k x_i)$。\n4. 计算初始离散方差 $\\mathrm{Var}^0 = \\frac{1}{N}\\sum_{i=0}^{N-1} (c_i^0 - \\bar{c}^0)^2$。\n5. 使用迎风格式 $c_i^1 = c_i^0 - \\nu(c_i^0 - c_{i-1}^0)$ 将解推进一个时间步，其中周期性边界为 $c_{-1}^0 = c_{N-1}^0$。\n6. 计算新的方差 $\\mathrm{Var}^1 = \\frac{1}{N}\\sum_{i=0}^{N-1} (c_i^1 - \\bar{c}^1)^2$。\n7. 根据其定义计算测量的衰减率 $r_{\\mathrm{meas}}$。\n8. 最后，计算绝对误差 $|r_{\\mathrm{meas}} - r_{\\mathrm{pred}}|$ 用于比较。这个误差量化了主阶分析未捕捉到的高阶截断误差项的贡献。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between measured and predicted variance decay rates\n    for the first-order upwind scheme applied to a single Fourier mode.\n    \"\"\"\n    # Test suite specification (all cases use L=1 and u=1):\n    # (N, m, nu)\n    test_cases = [\n        (128, 4, 0.3),   # Case 1\n        (128, 32, 0.3),  # Case 2\n        (128, 4, 1.0),   # Case 3\n        (64, 16, 0.7),   # Case 4\n        (64, 8, 0.05),   # Case 5\n    ]\n\n    results = []\n    for N, m, nu in test_cases:\n        # Define simulation parameters\n        L = 1.0\n        u = 1.0\n\n        # Calculate derived parameters\n        dx = L / N\n        dt = nu * dx / u\n        k = 2 * np.pi * m / L\n\n        # --- Theoretical Prediction (r_pred) ---\n        # The leading-order predicted decay rate from modified equation analysis is:\n        # r_pred = u * dx * (1 - nu) * k^2\n        r_pred = u * dx * (1.0 - nu) * k**2\n\n        # --- Numerical Measurement (r_meas) ---\n        # 1. Set up the grid and initial condition c^0\n        x = np.arange(N) * dx\n        c0 = np.sin(k * x)\n\n        # 2. Compute initial variance Var^0\n        # np.var calculates the mean of the squared deviations from the mean,\n        # which matches the problem's definition of discrete variance.\n        var0 = np.var(c0)\n\n        # 3. Advance one time step to get c^1 using the upwind scheme\n        # c_i^{n+1} = c_i^n - nu * (c_i^n - c_{i-1}^n)\n        # Periodic boundary is handled by np.roll for c_{i-1}\n        c0_shifted = np.roll(c0, 1)\n        c1 = c0 - nu * (c0 - c0_shifted)\n\n        # 4. Compute the new variance Var^1\n        var1 = np.var(c1)\n\n        # 5. Compute the measured decay rate r_meas\n        # r_meas = - (Var^{n+1} - Var^n) / (dt * Var^n)\n        # Special handling for dt=0 or var0=0 to avoid division by zero,\n        # although not expected with the given test cases.\n        if dt == 0.0 or var0 == 0.0:\n            # If there's no time step, there's no decay in time.\n            # If initial variance is zero, the concept of relative decay is ill-defined.\n            # For nu=1.0, var1 == var0 so r_meas is 0. This is handled correctly.\n            r_meas = 0.0\n        else:\n            r_meas = - (var1 - var0) / (dt * var0)\n\n        # --- Calculate Absolute Error ---\n        absolute_error = np.abs(r_meas - r_pred)\n        results.append(absolute_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6f}' for err in results)}]\")\n\nsolve()\n```"
        }
    ]
}