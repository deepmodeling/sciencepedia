{
    "hands_on_practices": [
        {
            "introduction": "Numerical models hinge on accurately approximating continuous derivatives with discrete operators. This exercise delves into the foundational technique of using Taylor series expansions to systematically derive the coefficients for a high-order finite-difference scheme. By completing this derivation , you will not only construct a fourth-order accurate operator but also quantify its leading error, providing a concrete understanding of how numerical accuracy is defined and achieved.",
            "id": "3913939",
            "problem": "In the numerical core of large-scale environmental and Earth system models that solve advection-diffusion partial differential equations, gradients such as $\\partial_{x} u$ are evaluated on structured grids. Consider a uniform one-dimensional grid with nodes $x_i = x_0 + i h$ for integer $i$ and spacing $h > 0$. At an interior node $x_i$, approximate $\\partial_{x} u(x_i)$ using only the stencil $\\{x_i - 2h, x_i - h, x_i, x_i + h, x_i + 2h\\}$ via a central finite-difference operator of the form\n$$\n\\left.\\partial_{x} u\\right|_{x_i} \\approx \\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k\\, u(x_i + k h),\n$$\nwhere the coefficients $\\alpha_k$ are independent of $u$ and $h$.\n\nStarting from Taylor series expansions about $x_i$ and enforcing that the discrete operator reproduces the exact derivative for sufficiently low-order polynomials, derive the unique set of coefficients $\\{\\alpha_{-2}, \\alpha_{-1}, \\alpha_{0}, \\alpha_{1}, \\alpha_{2}\\}$ that yields a central scheme with fourth-order accuracy in $h$ for $\\partial_{x} u(x_i)$ on this stencil. Then, quantify the leading truncation error by determining the exact constant $C$ in the expansion\n$$\n\\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k\\, u(x_i + k h) \\;=\\; \\partial_{x} u(x_i) \\;+\\; C\\, h^{4}\\, \\partial_{x}^{5} u(x_i) \\;+\\; \\mathcal{O}(h^{6}).\n$$\n\nUse only Taylor series and algebraic consistency conditions implied by matching derivatives at $x_i$. Report your final result as the row vector $(\\alpha_{-2}, \\alpha_{-1}, \\alpha_{0}, \\alpha_{1}, \\alpha_{2}, C)$. Provide exact rational values. No rounding is required, and no units should be reported with the final answer.",
            "solution": "The problem requires the derivation of the coefficients $\\{\\alpha_k\\}$ for a five-point central finite-difference operator that approximates the first derivative $\\partial_x u(x_i)$ with fourth-order accuracy, and the determination of the constant $C$ for the leading truncation error term.\n\nThe finite-difference operator is given by\n$$\nD_h[u](x_i) = \\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k u(x_i + k h)\n$$\nWe use Taylor series to expand each term $u(x_i + k h)$ around the point $x_i$. Let $u^{(n)}(x_i) \\equiv \\partial_x^n u(x_i)$. The expansion is:\n$$\nu(x_i + k h) = \\sum_{n=0}^{\\infty} \\frac{(k h)^n}{n!} u^{(n)}(x_i) = u(x_i) + (kh)u^{(1)}(x_i) + \\frac{(kh)^2}{2!}u^{(2)}(x_i) + \\dots\n$$\nSubstituting this into the operator expression gives:\n$$\nD_h[u](x_i) = \\frac{1}{h} \\sum_{k=-2}^{2} \\alpha_k \\left( \\sum_{n=0}^{\\infty} \\frac{(k h)^n}{n!} u^{(n)}(x_i) \\right)\n$$\nBy interchanging the order of summation, we can group terms by the order of the derivative of $u$:\n$$\nD_h[u](x_i) = \\sum_{n=0}^{\\infty} \\left( \\frac{h^{n-1}}{n!} \\sum_{k=-2}^{2} k^n \\alpha_k \\right) u^{(n)}(x_i)\n$$\nLet's define the moments of the coefficients as $M_n = \\sum_{k=-2}^{2} k^n \\alpha_k$. The expansion becomes:\n$$\nD_h[u](x_i) = \\frac{M_0}{h} u(x_i) + M_1 u^{(1)}(x_i) + \\frac{M_2}{2} h u^{(2)}(x_i) + \\frac{M_3}{6} h^2 u^{(3)}(x_i) + \\frac{M_4}{24} h^3 u^{(4)}(x_i) + \\frac{M_5}{120} h^4 u^{(5)}(x_i) + \\mathcal{O}(h^5)\n$$\nWe want this operator to approximate $\\partial_x u(x_i) = u^{(1)}(x_i)$ with an error of $\\mathcal{O}(h^4)$. This means the expression for $D_h[u](x_i)$ must match $u^{(1)}(x_i)$ up to terms of order $h^3$. This yields a system of linear equations for the coefficients $\\alpha_k$:\n1.  The coefficient of $u(x_i)$ must be zero: $\\frac{M_0}{h} = 0 \\implies M_0 = \\sum_{k=-2}^{2} \\alpha_k = 0$.\n2.  The coefficient of $u^{(1)}(x_i)$ must be one: $M_1 = \\sum_{k=-2}^{2} k \\alpha_k = 1$.\n3.  The coefficient of $h u^{(2)}(x_i)$ must be zero: $\\frac{M_2}{2} = 0 \\implies M_2 = \\sum_{k=-2}^{2} k^2 \\alpha_k = 0$.\n4.  The coefficient of $h^2 u^{(3)}(x_i)$ must be zero: $\\frac{M_3}{6} = 0 \\implies M_3 = \\sum_{k=-2}^{2} k^3 \\alpha_k = 0$.\n5.  The coefficient of $h^3 u^{(4)}(x_i)$ must be zero to achieve fourth-order accuracy: $\\frac{M_4}{24} = 0 \\implies M_4 = \\sum_{k=-2}^{2} k^4 \\alpha_k = 0$.\n\nThis gives a system of five linear equations for the five unknown coefficients $\\alpha_{-2}, \\alpha_{-1}, \\alpha_0, \\alpha_1, \\alpha_2$.\nAs this is a central difference scheme for a first derivative on a symmetric stencil, we can expect anti-symmetric coefficients, i.e., $\\alpha_0 = 0$ and $\\alpha_{-k} = -\\alpha_k$. Let's verify this from the equations.\nThe conditions on the even moments $M_2$ and $M_4$ are:\n$M_2 = 4\\alpha_{-2} + \\alpha_{-1} + \\alpha_1 + 4\\alpha_2 = 4(\\alpha_2 + \\alpha_{-2}) + (\\alpha_1 + \\alpha_{-1}) = 0$\n$M_4 = 16\\alpha_{-2} + \\alpha_{-1} + \\alpha_1 + 16\\alpha_2 = 16(\\alpha_2 + \\alpha_{-2}) + (\\alpha_1 + \\alpha_{-1}) = 0$\nSubtracting the first from the second gives $12(\\alpha_2+\\alpha_{-2}) = 0$, which implies $\\alpha_{-2} = -\\alpha_2$. Substituting this back into either equation yields $\\alpha_{-1} = -\\alpha_1$.\nFinally, the condition $M_0=0$ gives $\\alpha_{-2}+\\alpha_{-1}+\\alpha_0+\\alpha_1+\\alpha_2 = 0$. With the anti-symmetry, this simplifies to $(-\\alpha_2) + (-\\alpha_1) + \\alpha_0 + \\alpha_1 + \\alpha_2 = 0$, which implies $\\alpha_0=0$.\n\nUsing these anti-symmetry relations simplifies the remaining equations for the odd moments $M_1$ and $M_3$:\n$M_1 = -2\\alpha_{-2} - \\alpha_{-1} + \\alpha_1 + 2\\alpha_2 = 1$\n$\\implies -2(-\\alpha_2) - (-\\alpha_1) + \\alpha_1 + 2\\alpha_2 = 2\\alpha_1 + 4\\alpha_2 = 1$.\n\n$M_3 = (-2)^3\\alpha_{-2} + (-1)^3\\alpha_{-1} + (1)^3\\alpha_1 + (2)^3\\alpha_2 = 0$\n$\\implies -8(-\\alpha_2) - (-\\alpha_1) + \\alpha_1 + 8\\alpha_2 = 2\\alpha_1 + 16\\alpha_2 = 0$.\n\nWe now have a system of two equations for $\\alpha_1$ and $\\alpha_2$:\n1. $2\\alpha_1 + 4\\alpha_2 = 1$\n2. $2\\alpha_1 + 16\\alpha_2 = 0$\n\nSubtracting the first equation from the second yields $12\\alpha_2 = -1$, so $\\alpha_2 = -\\frac{1}{12}$.\nSubstituting this value back into the second equation: $2\\alpha_1 + 16(-\\frac{1}{12}) = 0 \\implies 2\\alpha_1 = \\frac{16}{12} = \\frac{4}{3} \\implies \\alpha_1 = \\frac{2}{3}$.\n\nThe full set of coefficients is:\n$\\alpha_2 = -\\frac{1}{12}$\n$\\alpha_1 = \\frac{2}{3}$\n$\\alpha_0 = 0$\n$\\alpha_{-1} = -\\alpha_1 = -\\frac{2}{3}$\n$\\alpha_{-2} = -\\alpha_2 = \\frac{1}{12}$\n\nThe discrete operator is therefore:\n$$\nD_h[u](x_i) = \\frac{1}{12h} \\left( u(x_i-2h) - 8u(x_i-h) + 8u(x_i+h) - u(x_i+2h) \\right)\n$$\nThe problem specifies that the resulting expansion is of the form:\n$$\nD_h[u](x_i) = \\partial_{x} u(x_i) + C h^{4} \\partial_{x}^{5} u(x_i) + \\mathcal{O}(h^{6})\n$$\nThe leading error term corresponds to the first non-zero term in our Taylor series expansion after $M_1 u^{(1)}(x_i)$. By construction, the terms with $u^{(2)}, u^{(3)}, u^{(4)}$ are zero. The next term is for $n=5$:\n$$\n\\text{Error} = \\frac{M_5}{5!} h^4 u^{(5)}(x_i) + \\mathcal{O}(h^5)\n$$\nThe problem statement indicates the error is $\\mathcal{O}(h^6)$ following the $h^4$ term. This is because for a symmetric central-difference operator for the first derivative, all even moments $M_{2n}$ are zero, which eliminates all odd-derivative error terms (like $u^{(6)}$ which would be order $h^5$).\nThe constant $C$ is thus the coefficient of $h^4 u^{(5)}(x_i)$, so $C = \\frac{M_5}{5!}$. We must calculate $M_5$:\n$$\nM_5 = \\sum_{k=-2}^{2} k^5 \\alpha_k = (-2)^5\\alpha_{-2} + (-1)^5\\alpha_{-1} + (0)^5\\alpha_0 + (1)^5\\alpha_1 + (2)^5\\alpha_2\n$$\nSubstituting the coefficient values:\n$$\nM_5 = (-32)\\left(\\frac{1}{12}\\right) + (-1)\\left(-\\frac{2}{3}\\right) + (1)\\left(\\frac{2}{3}\\right) + (32)\\left(-\\frac{1}{12}\\right)\n$$\n$$\nM_5 = -\\frac{32}{12} + \\frac{2}{3} + \\frac{2}{3} - \\frac{32}{12} = -\\frac{64}{12} + \\frac{4}{3} = -\\frac{16}{3} + \\frac{4}{3} = -\\frac{12}{3} = -4\n$$\nNow we can compute $C$:\n$$\nC = \\frac{M_5}{5!} = \\frac{-4}{120} = -\\frac{1}{30}\n$$\nThe requested final result is the row vector $(\\alpha_{-2}, \\alpha_{-1}, \\alpha_{0}, \\alpha_{1}, \\alpha_{2}, C)$.\n\nThe components are:\n$\\alpha_{-2} = \\frac{1}{12}$\n$\\alpha_{-1} = -\\frac{2}{3}$\n$\\alpha_{0} = 0$\n$\\alpha_{1} = \\frac{2}{3}$\n$\\alpha_{2} = -\\frac{1}{12}$\n$C = -\\frac{1}{30}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{12} & -\\frac{2}{3} & 0 & \\frac{2}{3} & -\\frac{1}{12} & -\\frac{1}{30}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The choice of a discretization scheme has consequences that go beyond its formal order of accuracy, often introducing non-physical behaviors. This practice explores the concept of numerical diffusion, a common artifact where the numerical method artificially smooths sharp gradients. Through a combination of theoretical analysis and a simple coding exercise , you will see how the truncation error of a first-order upwind scheme manifests as a diffusive term, causing a spurious decay in the variance of a tracer field.",
            "id": "3913901",
            "problem": "Consider one-dimensional pure advection of a passive tracer on a periodic domain of length $L$ with constant velocity $u$. The continuous governing equation is the linear advection equation $\\,\\partial_t c + u \\,\\partial_x c = 0\\,$. A numerical scheme on a uniform grid of $N$ cells with spacing $\\Delta x = L/N$ and explicit time step $\\Delta t$ uses the Courant-Friedrichs-Lewy (CFL) number $\\,\\nu = u \\Delta t / \\Delta x\\,$. The tracer is initialized as a single Fourier mode $\\,c(x,0) = \\sin(k x)\\,$ with wavenumber $\\,k = 2\\pi m/L\\,$ for integer mode index $m$. For a discrete state $\\,\\{c_i^n\\}_{i=0}^{N-1}\\,$ at time level $n$, define the discrete spatial mean $\\,\\bar{c}^n = \\frac{1}{N}\\sum_{i=0}^{N-1} c_i^n\\,$ and the discrete variance $\\,\\mathrm{Var}^n = \\frac{1}{N}\\sum_{i=0}^{N-1} (c_i^n - \\bar{c}^n)^2\\,$. Under the continuous advection dynamics, the variance is exactly preserved in time; however, on a discrete grid the variance may decay spuriously due to truncation errors, which is a manifestation of grid-induced numerical mixing.\n\nStarting from the advection equation and the definition of the first-order upwind explicit scheme for $\\,u>0\\,$,\n$$\nc_i^{n+1} = c_i^{n} - \\nu \\left(c_i^{n} - c_{i-1}^{n}\\right),\n$$\nderive the leading-order modified equation that the scheme solves, expressed as the advection equation plus a lowest-order correction term arising from truncation error. Use this to obtain the leading-order prediction for the instantaneous decay rate of the discrete variance for a single Fourier mode, denoted $\\,r_{\\mathrm{pred}}\\,$, as a function of $\\,u\\,$, $\\,\\Delta x\\,$, $\\,\\nu\\,$, and $\\,k\\,$. Then, implement a single-step simulation using the same upwind scheme to compute the measured instantaneous decay rate of variance,\n$$\nr_{\\mathrm{meas}} = - \\frac{\\mathrm{Var}^{n+1} - \\mathrm{Var}^{n}}{\\Delta t\\,\\mathrm{Var}^{n}},\n$$\nfor $\\,n=0\\,$, with periodic boundary conditions enforced via circular indexing. Assume nondimensional units with $\\,L=1\\,$ and $\\,u=1\\,$, so rates are in inverse nondimensional time units.\n\nYour program must:\n- Construct the uniform grid and initialize the tracer as $\\,c(x) = \\sin(2\\pi m x)\\,$ on $[0,1)$ with periodicity.\n- Advance one explicit time step with the first-order upwind scheme for $\\,u>0\\,$.\n- Compute $\\,\\mathrm{Var}^{0}\\,$ and $\\,\\mathrm{Var}^{1}\\,$ from the discrete states and then compute $\\,r_{\\mathrm{meas}}\\,$.\n- Compute the leading-order prediction $\\,r_{\\mathrm{pred}}\\,$ from your modified-equation analysis.\n- Report the absolute error $\\,|r_{\\mathrm{meas}} - r_{\\mathrm{pred}}|\\,$ for each test case.\n\nTest suite specification (all cases use $\\,L=1\\,$ and $\\,u=1\\,$):\n- Case $1$: $N=128$, $m=4$, $\\nu=0.3$.\n- Case $2$: $N=128$, $m=32$, $\\nu=0.3$.\n- Case $3$: $N=128$, $m=4$, $\\nu=1.0$.\n- Case $4$: $N=64$, $m=16$, $\\nu=0.7$.\n- Case $5$: $N=64$, $m=8$, $\\nu=0.05$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five cases, where each entry is the absolute error $\\,|r_{\\mathrm{meas}} - r_{\\mathrm{pred}}|\\,$ as a floating-point number. For example, the output format must be exactly like $[a_1,a_2,a_3,a_4,a_5]$ with no additional text.",
            "solution": "The objective is to derive the leading-order theoretical prediction for the instantaneous decay rate of variance, $r_{\\mathrm{pred}}$, for a single Fourier mode advected by the first-order upwind scheme, and to compare it with the numerically measured rate, $r_{\\mathrm{meas}}$. The analysis begins with deriving the modified equation that the numerical scheme implicitly solves.\n\nThe one-dimensional first-order upwind scheme for a positive velocity $u>0$ is given by:\n$$\nc_i^{n+1} = c_i^{n} - \\nu \\left(c_i^{n} - c_{i-1}^{n}\\right)\n$$\nwhere $c_i^n$ is the discrete tracer concentration at grid cell $i$ and time level $n$, and $\\nu = u \\Delta t / \\Delta x$ is the Courant-Friedrichs-Lewy (CFL) number, with time step $\\Delta t$ and grid spacing $\\Delta x$.\n\nTo derive the modified equation, we perform a Taylor series expansion of each term in the scheme around the point $(x_i, t_n)$, treating $c$ as a smooth function $c(x,t)$.\n\\begin{align*}\nc_i^{n+1} &= c(x_i, t_n + \\Delta t) \\approx c + \\Delta t \\, \\partial_t c + \\frac{(\\Delta t)^2}{2} \\, \\partial_{tt} c + O((\\Delta t)^3) \\\\\nc_i^{n} &= c(x_i, t_n) = c \\\\\nc_{i-1}^{n} &= c(x_i - \\Delta x, t_n) \\approx c - \\Delta x \\, \\partial_x c + \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c - \\frac{(\\Delta x)^3}{6} \\, \\partial_{xxx} c + O((\\Delta x)^4)\n\\end{align*}\nSubstituting these expansions into the numerical scheme gives:\n$$\nc + \\Delta t \\, \\partial_t c + \\frac{(\\Delta t)^2}{2} \\, \\partial_{tt} c + \\dots = c - \\nu \\left[c - \\left(c - \\Delta x \\, \\partial_x c + \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c - \\dots\\right)\\right]\n$$\nSimplifying the right-hand side:\n$$\nc + \\Delta t \\, \\partial_t c + \\frac{(\\Delta t)^2}{2} \\, \\partial_{tt} c + \\dots = c - \\nu \\left(\\Delta x \\, \\partial_x c - \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c + \\dots\\right)\n$$\nDividing by $\\Delta t$ and substituting $\\nu/\\Delta t = u/\\Delta x$:\n$$\n\\partial_t c + \\frac{\\Delta t}{2} \\, \\partial_{tt} c + \\dots = - \\frac{u}{\\Delta x} \\left(\\Delta x \\, \\partial_x c - \\frac{(\\Delta x)^2}{2} \\, \\partial_{xx} c + \\dots\\right)\n$$\n$$\n\\partial_t c + \\frac{\\Delta t}{2} \\, \\partial_{tt} c + \\dots = -u \\, \\partial_x c + \\frac{u \\Delta x}{2} \\, \\partial_{xx} c + \\dots\n$$\nRearranging to match the form of the original advection equation, $\\partial_t c + u \\partial_x c = 0$:\n$$\n\\partial_t c + u \\, \\partial_x c = \\frac{u \\Delta x}{2} \\, \\partial_{xx} c - \\frac{\\Delta t}{2} \\, \\partial_{tt} c + O(\\Delta x^2, (\\Delta t)^2)\n$$\nThis equation contains a higher-order time derivative, $\\partial_{tt}c$. To obtain the leading-order modified equation in terms of spatial derivatives only, we approximate $\\partial_{tt}c$. From the original PDE, $\\partial_t c = -u \\partial_x c$ to leading order. Differentiating with respect to time gives $\\partial_{tt} c = \\partial_t(-u \\partial_x c) = -u \\partial_x (\\partial_t c)$. Substituting the PDE again yields $\\partial_{tt} c \\approx -u \\partial_x (-u \\partial_x c) = u^2 \\partial_{xx} c$. Substituting this back into our equation:\n$$\n\\partial_t c + u \\, \\partial_x c = \\frac{u \\Delta x}{2} \\, \\partial_{xx} c - \\frac{\\Delta t}{2} (u^2 \\partial_{xx} c) + \\dots\n$$\n$$\n\\partial_t c + u \\, \\partial_x c = \\left(\\frac{u \\Delta x}{2} - \\frac{u^2 \\Delta t}{2}\\right) \\partial_{xx} c + \\dots\n$$\nFactoring out a common term and recalling $\\nu = u \\Delta t / \\Delta x$:\n$$\n\\partial_t c + u \\, \\partial_x c = \\frac{u \\Delta x}{2} \\left(1 - \\frac{u \\Delta t}{\\Delta x}\\right) \\partial_{xx} c + \\dots = \\frac{u \\Delta x}{2} (1 - \\nu) \\partial_{xx} c + \\dots\n$$\nThis is the leading-order modified equation. It is an advection-diffusion equation where the numerical scheme has introduced an artificial diffusion term with numerical diffusivity $D_{\\mathrm{num}} = \\frac{u \\Delta x}{2} (1 - \\nu)$. This diffusive term is responsible for the spurious decay of variance.\n\nNow we derive the predicted decay rate of variance. The variance of the continuous field $c(x,t)$ on a periodic domain of length $L$ is $\\mathrm{Var}(t) = \\frac{1}{L} \\int_0^L (c(x,t) - \\bar{c})^2 dx$, where $\\bar{c}$ is the spatial mean. For an initial condition $c(x,0) = \\sin(kx)$ where $k=2\\pi m/L$, the mean is zero for any integer $m \\neq 0$. Since the advection-diffusion equation is linear and conserves the mean, $\\bar{c}$ remains zero. Thus, $\\mathrm{Var}(t) = \\frac{1}{L} \\int_0^L c^2 dx$.\n\nThe time rate of change of variance is:\n$$\n\\frac{d\\mathrm{Var}}{dt} = \\frac{1}{L} \\int_0^L 2c \\, \\frac{\\partial c}{\\partial t} \\, dx\n$$\nSubstituting $\\partial_t c$ from the modified equation:\n$$\n\\frac{d\\mathrm{Var}}{dt} = \\frac{1}{L} \\int_0^L 2c \\left( -u \\partial_x c + D_{\\mathrm{num}} \\partial_{xx} c \\right) dx = -\\frac{2u}{L} \\int_0^L c \\, \\partial_x c \\, dx + \\frac{2D_{\\mathrm{num}}}{L} \\int_0^L c \\, \\partial_{xx} c \\, dx\n$$\nThe first integral, $\\int_0^L c \\, \\partial_x c \\, dx = \\frac{1}{2} \\int_0^L \\partial_x(c^2) dx = \\frac{1}{2}[c^2]_0^L$, is zero due to periodicity. The second integral, using integration by parts, is $\\int_0^L c \\, \\partial_{xx} c \\, dx = [c \\, \\partial_x c]_0^L - \\int_0^L (\\partial_x c)^2 dx$. The boundary term $[c \\, \\partial_x c]_0^L$ is also zero due to periodicity, leaving $\\int_0^L c \\, \\partial_{xx} c \\, dx = - \\int_0^L (\\partial_x c)^2 dx$.\nThus, the rate of change of variance is:\n$$\n\\frac{d\\mathrm{Var}}{dt} = - \\frac{2 D_{\\mathrm{num}}}{L} \\int_0^L (\\partial_x c)^2 dx\n$$\nThe instantaneous relative decay rate of variance is $r = - \\frac{1}{\\mathrm{Var}} \\frac{d\\mathrm{Var}}{dt}$. At time $t=0$, with $c(x,0) = \\sin(kx)$:\n\\begin{align*}\n\\mathrm{Var}^0 &= \\frac{1}{L} \\int_0^L \\sin^2(kx) dx = \\frac{1}{2} \\\\\n\\int_0^L (\\partial_x c)^2 dx &= \\int_0^L (k \\cos(kx))^2 dx = k^2 \\int_0^L \\cos^2(kx) dx = k^2 \\frac{L}{2}\n\\end{align*}\nSo, at $t=0$, $\\frac{d\\mathrm{Var}}{dt} = - \\frac{2 D_{\\mathrm{num}}}{L} \\left( k^2 \\frac{L}{2} \\right) = -D_{\\mathrm{num}} k^2$.\nThe predicted decay rate is:\n$$\nr_{\\mathrm{pred}} = - \\frac{1}{\\mathrm{Var}^0} \\left. \\frac{d\\mathrm{Var}}{dt} \\right|_{t=0} = - \\frac{-D_{\\mathrm{num}} k^2}{1/2} = 2 D_{\\mathrm{num}} k^2\n$$\nSubstituting the expression for $D_{\\mathrm{num}}$:\n$$\nr_{\\mathrm{pred}} = 2 \\left( \\frac{u \\Delta x}{2} (1 - \\nu) \\right) k^2 = u \\Delta x (1 - \\nu) k^2\n$$\nThis is the theoretical prediction to be computed.\n\nFor the numerical measurement, we compute $r_{\\mathrm{meas}} = - \\frac{\\mathrm{Var}^{1} - \\mathrm{Var}^{0}}{\\Delta t\\,\\mathrm{Var}^{0}}$. The procedure is as follows:\n$1$. For each test case ($N, m, \\nu$), set constants $L=1$ and $u=1$.\n$2$. Calculate grid parameters: $\\Delta x = L/N$, $\\Delta t = \\nu \\Delta x / u$, and wavenumber $k = 2\\pi m / L$.\n$3$. Initialize the discrete field on the grid $x_i = i \\Delta x$ for $i=0, \\dots, N-1$: $c_i^0 = \\sin(k x_i)$.\n$4$. Compute the initial discrete variance $\\mathrm{Var}^0 = \\frac{1}{N}\\sum_{i=0}^{N-1} (c_i^0 - \\bar{c}^0)^2$.\n$5$. Advance the solution one time step using the upwind scheme $c_i^1 = c_i^0 - \\nu(c_i^0 - c_{i-1}^0)$, with periodic boundaries where $c_{-1}^0 = c_{N-1}^0$.\n$6$. Compute the new variance $\\mathrm{Var}^1 = \\frac{1}{N}\\sum_{i=0}^{N-1} (c_i^1 - \\bar{c}^1)^2$.\n$7$. Calculate the measured decay rate $r_{\\mathrm{meas}}$ using its definition.\n$8$. Finally, compute the absolute error $|r_{\\mathrm{meas}} - r_{\\mathrm{pred}}|$ for comparison. This error quantifies the contribution of higher-order truncation error terms not captured by the leading-order analysis.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between measured and predicted variance decay rates\n    for the first-order upwind scheme applied to a single Fourier mode.\n    \"\"\"\n    # Test suite specification (all cases use L=1 and u=1):\n    # (N, m, nu)\n    test_cases = [\n        (128, 4, 0.3),   # Case 1\n        (128, 32, 0.3),  # Case 2\n        (128, 4, 1.0),   # Case 3\n        (64, 16, 0.7),   # Case 4\n        (64, 8, 0.05),   # Case 5\n    ]\n\n    results = []\n    for N, m, nu in test_cases:\n        # Define simulation parameters\n        L = 1.0\n        u = 1.0\n\n        # Calculate derived parameters\n        dx = L / N\n        dt = nu * dx / u\n        k = 2 * np.pi * m / L\n\n        # --- Theoretical Prediction (r_pred) ---\n        # The leading-order predicted decay rate from modified equation analysis is:\n        # r_pred = u * dx * (1 - nu) * k^2\n        r_pred = u * dx * (1.0 - nu) * k**2\n\n        # --- Numerical Measurement (r_meas) ---\n        # 1. Set up the grid and initial condition c^0\n        x = np.arange(N) * dx\n        c0 = np.sin(k * x)\n\n        # 2. Compute initial variance Var^0\n        # np.var calculates the mean of the squared deviations from the mean,\n        # which matches the problem's definition of discrete variance.\n        var0 = np.var(c0)\n\n        # 3. Advance one time step to get c^1 using the upwind scheme\n        # c_i^{n+1} = c_i^n - nu * (c_i^n - c_{i-1}^n)\n        # Periodic boundary is handled by np.roll for c_{i-1}\n        c0_shifted = np.roll(c0, 1)\n        c1 = c0 - nu * (c0 - c0_shifted)\n\n        # 4. Compute the new variance Var^1\n        var1 = np.var(c1)\n\n        # 5. Compute the measured decay rate r_meas\n        # r_meas = - (Var^{n+1} - Var^n) / (dt * Var^n)\n        # Special handling for dt=0 or var0=0 to avoid division by zero,\n        # although not expected with the given test cases.\n        if dt == 0.0 or var0 == 0.0:\n            # If there's no time step, there's no decay in time.\n            # If initial variance is zero, the concept of relative decay is ill-defined.\n            # For nu=1.0, var1 == var0 so r_meas is 0. This is handled correctly.\n            r_meas = 0.0\n        else:\n            r_meas = - (var1 - var0) / (dt * var0)\n\n        # --- Calculate Absolute Error ---\n        absolute_error = np.abs(r_meas - r_pred)\n        results.append(absolute_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6f}' for err in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many fundamental laws of nature are conservation laws, and for a numerical model to be physically meaningful, its discretization must respect these principles. This exercise focuses on implementing a conservative finite-volume scheme for an unstructured mesh, a cornerstone of modern environmental modeling. By correctly accounting for fluxes between cells , you will verify to machine precision that the total mass in the domain changes only in response to fluxes across its external boundaries, demonstrating the power of a conservative formulation.",
            "id": "3913919",
            "problem": "You are given a two-dimensional finite-volume discretization for scalar advection on an unstructured mesh with variable cell areas. The fundamental base is the local conservation law of mass for a passive scalar under advection, expressed as the partial differential equation $\\partial c / \\partial t + \\nabla \\cdot (\\mathbf{u} c) = 0$, where $c$ is scalar concentration (in kilograms per square meter), $\\mathbf{u}$ is velocity (in meters per second), and $t$ is time (in seconds). Integrating over a control volume and using the divergence theorem yields the finite-volume balance for each cell $i$ of area $A_i$: \n$$\n\\frac{d}{dt}\\left(A_i c_i\\right) = \\sum_{f \\in \\partial i} \\int_{f} \\mathbf{u} \\cdot \\mathbf{n}_f \\, c \\, ds,\n$$\nwhere $\\mathbf{n}_f$ is the unit normal on face $f$ pointing outward of cell $i$, and $ds$ is the face line element. The face-integrated flux is discretized as $F_f = u_n L_f c_f$, where $u_n$ is the face-normal velocity (in meters per second) oriented from the \"left\" cell to the \"right\" cell (or outward for boundary faces), $L_f$ is the face length (in meters), and $c_f$ is the reconstructed face concentration (in kilograms per square meter). A conservative discretization is achieved when each internal face $f$ produces a single $F_f$ that contributes $-F_f$ to the left cell and $+F_f$ to the right cell, ensuring pairwise cancellation in the global sum.\n\nConstruct a program that, for the provided test suite of unstructured meshes, performs a conservative flux reconstruction and computes the one-step total mass change. Use an upwind face reconstruction for advection: for an internal face with left cell index $\\ell$ and right cell index $r$, compute the face concentration as $c_f = c_\\ell$ if $u_n \\ge 0$, and $c_f = c_r$ if $u_n < 0$. For a boundary face with interior cell index $\\ell$ and outward normal, use $c_f = c_\\ell$ if $u_n \\ge 0$ (outflow), and $c_f = c_b$ if $u_n < 0$ (inflow), where $c_b$ is the specified boundary concentration (in kilograms per square meter). For each face, compute $F_f = u_n L_f c_f$. Update cell mass rates as $dM_\\ell/dt \\mathrel{+}= -F_f$ and, for internal faces, $dM_r/dt \\mathrel{+}= +F_f$. Define the net boundary mass inflow rate as the sum over boundary faces of $-F_f$ (positive when mass enters the domain). Over a time step of duration $\\Delta t$ (in seconds), the expected change in total mass is $\\Delta M_{\\text{expected}} = \\Delta t \\sum_{\\text{boundary } f} (-F_f)$.\n\nYour program must, for each test case, compute the scalar difference \n$$\n\\Delta M_{\\text{computed}} - \\Delta M_{\\text{expected}},\n$$\nwhere $\\Delta M_{\\text{computed}} = \\Delta t \\sum_i \\frac{dM_i}{dt}$ is the total mass change computed from the conservative face contributions and $\\Delta M_{\\text{expected}}$ is the mass change obtained from the net boundary inflow. This difference must be expressed in kilograms and returned as a float. The design must ensure that internal face contributions cancel exactly to machine precision by using a single face flux shared by both adjacent cells.\n\nTest suite definition:\n- Case $1$ (closed domain, happy path):\n  - Cells: areas $[1000, 500, 800]$ $\\text{m}^2$, with initial concentrations $[2.0, 1.0, 3.0]$ $\\text{kg}/\\text{m}^2$.\n  - Internal faces:\n    - Face between cells $0$ and $1$: length $50$ $\\text{m}$, $u_n = 0.1$ $\\text{m}/\\text{s}$, oriented from $0$ to $1$.\n    - Face between cells $1$ and $2$: length $30$ $\\text{m}$, $u_n = -0.05$ $\\text{m}/\\text{s}$, oriented from $1$ to $2$.\n  - Boundary faces:\n    - Cell $0$ boundary: length $40$ $\\text{m}$, $u_n = 0.0$ $\\text{m}/\\text{s}$, $c_b = 5.0$ $\\text{kg}/\\text{m}^2$.\n    - Cell $2$ boundary: length $40$ $\\text{m}$, $u_n = 0.0$ $\\text{m}/\\text{s}$, $c_b = 3.0$ $\\text{kg}/\\text{m}^2$.\n  - Time step: $\\Delta t = 60$ $\\text{s}$.\n- Case $2$ (open boundaries with inflow and outflow):\n  - Cells: areas $[1000, 500, 800]$ $\\text{m}^2$, with initial concentrations $[2.0, 1.0, 3.0]$ $\\text{kg}/\\text{m}^2$.\n  - Internal faces identical to Case $1$.\n  - Boundary faces:\n    - Cell $0$ boundary: length $40$ $\\text{m}$, $u_n = -0.2$ $\\text{m}/\\text{s}$, $c_b = 5.0$ $\\text{kg}/\\text{m}^2$.\n    - Cell $2$ boundary: length $40$ $\\text{m}$, $u_n = 0.1$ $\\text{m}/\\text{s}$, $c_b = 0.0$ $\\text{kg}/\\text{m}^2$.\n  - Time step: $\\Delta t = 60$ $\\text{s}$.\n- Case $3$ (single-cell edge case):\n  - Cells: areas $[1000]$ $\\text{m}^2$, with initial concentrations $[1.5]$ $\\text{kg}/\\text{m}^2$.\n  - Boundary faces:\n    - Face $A$: length $10$ $\\text{m}$, $u_n = 0.5$ $\\text{m}/\\text{s}$, $c_b = 2.0$ $\\text{kg}/\\text{m}^2$ (outflow).\n    - Face $B$: length $100$ $\\text{m}$, $u_n = -0.05$ $\\text{m}/\\text{s}$, $c_b = 2.0$ $\\text{kg}/\\text{m}^2$ (inflow).\n  - Time step: $\\Delta t = 100$ $\\text{s}$.\n- Case $4$ (extreme scaling of areas and concentrations):\n  - Cells: areas $[0.01, 2000000.0]$ $\\text{m}^2$, with initial concentrations $[10^8, 10^{-6}]$ $\\text{kg}/\\text{m}^2$.\n  - Internal face:\n    - Face between cells $0$ and $1$: length $1000$ $\\text{m}$, $u_n = 100$ $\\text{m}/\\text{s}$, oriented from $0$ to $1$.\n  - Boundary face:\n    - Cell $1$ boundary: length $50$ $\\text{m}$, $u_n = -0.001$ $\\text{m}/\\text{s}$, $c_b = 3.0$ $\\text{kg}/\\text{m}^2$ (inflow).\n  - Time step: $\\Delta t = 1$ $\\text{s}$.\n\nYour program must produce for the above test suite a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be the float difference $\\Delta M_{\\text{computed}} - \\Delta M_{\\text{expected}}$ in kilograms, rounded only by machine arithmetic, without explicit rounding applied.",
            "solution": "` part. The `<final_answer>` will be the Python code I've outlined. I'm ready to write both.\nThe problem is valid. It is scientifically sound, well-posed, and objective, providing a clear test of the implementation of a conservative finite-volume scheme. The underlying principles are standard in computational fluid dynamics and environmental modeling. All necessary data and definitions for a unique solution are provided.\n\nThe core of this problem lies in the principle of conservation in a finite-volume discretization. The rate of change of the total mass of a scalar $c$ within a computational domain is determined solely by the net flux across the domain's boundaries. The fluxes across internal faces, which represent mass exchange between adjacent control volumes, must cancel out perfectly when summed over the entire domain. An algorithm that correctly implements this is termed \"conservative.\" This problem requires the design of such an algorithm and the verification of its conservative property.\n\nLet $M_{total}$ be the total mass in the domain, defined as the sum of mass in each cell $i$: $M_{total} = \\sum_i M_i$. The rate of change of the total mass is $\\frac{dM_{total}}{dt} = \\sum_i \\frac{dM_i}{dt}$.\n\nThe finite-volume method provides the rate of change of mass for a single cell, $M_i = A_i c_i$, as a sum of fluxes over its faces:\n$$\n\\frac{dM_i}{dt} = \\sum_{f \\in \\partial i} \\text{flux}_f\n$$\nThe problem specifies the flux contributions. For an internal face $f$ shared by a \"left\" cell $\\ell$ and a \"right\" cell $r$, the mass rate update for cell $\\ell$ is $\\frac{dM_\\ell}{dt} \\mathrel{+}= -F_f$, and for cell $r$ it is $\\frac{dM_r}{dt} \\mathrel{+}= +F_f$. The sign convention depends on the arbitrary but fixed orientation of the face normal used to define the velocity $u_n$.\n\nFor a boundary face $f$ belonging to an interior cell $\\ell$, the update is $\\frac{dM_\\ell}{dt} \\mathrel{+}= -F_f$, where the flux $F_f$ is computed using an outward-pointing normal.\n\nWhen we sum the mass rate changes over all cells in the domain, we get:\n$$\n\\sum_i \\frac{dM_i}{dt} = \\sum_{\\text{internal faces } f} (-F_f + F_f) + \\sum_{\\text{boundary faces } f} (-F_f)\n$$\nThe contribution from each internal face appears twice with opposite signs because each internal face is a boundary to exactly two cells. This leads to a perfect cancellation:\n$$\n\\sum_i \\frac{dM_i}{dt} = 0 + \\sum_{\\text{boundary faces } f} (-F_f) = \\sum_{\\text{boundary faces } f} (-F_f)\n$$\nThis equation is the discrete statement of mass conservation: the rate of change of total mass within the domain is equal to the net rate of mass inflow across its boundaries. The term $-F_f$ for a boundary face represents the mass inflow rate through that face (it is positive for inflow, since $u_n < 0$ and $F_f < 0$).\n\nThe problem asks to compute the difference between two quantities over a time step $\\Delta t$:\n1.  The computed total mass change, $\\Delta M_{\\text{computed}} = \\Delta t \\sum_i \\frac{dM_i}{dt}$. This is obtained by first calculating the mass rate of change for each cell by summing all its face flux contributions, and then summing these rates over all cells.\n2.  The expected total mass change, $\\Delta M_{\\text{expected}} = \\Delta t \\sum_{\\text{boundary faces } f} (-F_f)$. This is obtained by summing the flux contributions from boundary faces only.\n\nBased on the derivation above, a conservative scheme must ensure that $\\sum_i \\frac{dM_i}{dt} = \\sum_{\\text{boundary faces } f} (-F_f)$. Therefore, it is a mathematical identity that $\\Delta M_{\\text{computed}} = \\Delta M_{\\text{expected}}$, and their difference must be zero. The problem is thus a verification exercise to confirm that the numerical implementation is indeed conservative.\n\nThe algorithmic design must enforce this cancellation. This is achieved by iterating through each internal face *once*, calculating a single flux value $F_f$, and applying it with opposite signs to the two adjacent cells. This guarantees that the sum is exactly zero to machine precision.\n\nThe face flux $F_f$ is given by $F_f = u_n L_f c_f$. The face concentration $c_f$ is determined by an upwind scheme:\n- For an internal face between cells $\\ell$ and $r$ with normal velocity $u_n$ oriented from $\\ell$ to $r$:\n  - If $u_n \\ge 0$, the flow is from $\\ell$ to $r$, so the upwind concentration is $c_f = c_\\ell$.\n  - If $u_n < 0$, the flow is from $r$ to $\\ell$, so the upwind concentration is $c_f = c_r$.\n- For a boundary face of cell $\\ell$ with outward normal velocity $u_n$:\n  - If $u_n \\ge 0$ (outflow), the upwind concentration is from inside the domain, so $c_f = c_\\ell$.\n  - If $u_n < 0$ (inflow), the upwind concentration is from outside the domain, so $c_f = c_b$.\n\nThe algorithm will proceed as follows for each test case:\n1. Initialize an array `dM_dt` of size equal to the number of cells to all zeros.\n2. Initialize a scalar `net_boundary_inflow_rate` to zero.\n3. Loop through all internal faces. For each face, compute its flux $F_f$ and apply the updates $-F_f$ and $+F_f$ to the `dM_dt` entries of the two adjacent cells.\n4. Loop through all boundary faces. For each face, compute its flux $F_f$, apply the update $-F_f$ to the `dM_dt` entry of the adjacent cell, and add $-F_f$ to `net_boundary_inflow_rate`.\n5. Compute $\\Delta M_{\\text{computed}} = \\Delta t \\times \\sum(\\text{dM\\_dt})$.\n6. Compute $\\Delta M_{\\text{expected}} = \\Delta t \\times \\text{net\\_boundary\\_inflow\\_rate}$.\n7. The result is the difference $\\Delta M_{\\text{computed}} - \\Delta M_{\\text{expected}}$. This difference must be $0.0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Closed domain\n        {\n            \"concentrations\": np.array([2.0, 1.0, 3.0], dtype=np.float64),\n            \"internal_faces\": [\n                # (left_cell, right_cell, length, normal_velocity)\n                (0, 1, 50.0, 0.1),\n                (1, 2, 30.0, -0.05),\n            ],\n            \"boundary_faces\": [\n                # (cell_idx, length, normal_velocity, boundary_concentration)\n                (0, 40.0, 0.0, 5.0),\n                (2, 40.0, 0.0, 3.0),\n            ],\n            \"dt\": 60.0,\n        },\n        # Case 2: Open boundaries with inflow and outflow\n        {\n            \"concentrations\": np.array([2.0, 1.0, 3.0], dtype=np.float64),\n            \"internal_faces\": [\n                (0, 1, 50.0, 0.1),\n                (1, 2, 30.0, -0.05),\n            ],\n            \"boundary_faces\": [\n                (0, 40.0, -0.2, 5.0),\n                (2, 40.0, 0.1, 0.0),\n            ],\n            \"dt\": 60.0,\n        },\n        # Case 3: Single-cell edge case\n        {\n            \"concentrations\": np.array([1.5], dtype=np.float64),\n            \"internal_faces\": [],\n            \"boundary_faces\": [\n                (0, 10.0, 0.5, 2.0),\n                (0, 100.0, -0.05, 2.0),\n            ],\n            \"dt\": 100.0,\n        },\n        # Case 4: Extreme scaling\n        {\n            \"concentrations\": np.array([1e8, 1e-6], dtype=np.float64),\n            \"internal_faces\": [\n                (0, 1, 1000.0, 100.0),\n            ],\n            \"boundary_faces\": [\n                (1, 50.0, -0.001, 3.0),\n            ],\n            \"dt\": 1.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_conservation_error(\n            case[\"concentrations\"],\n            case[\"internal_faces\"],\n            case[\"boundary_faces\"],\n            case[\"dt\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_conservation_error(concentrations, internal_faces, boundary_faces, dt):\n    \"\"\"\n    Computes the difference between total mass change calculated from cell-wise\n    sums and from boundary fluxes alone, verifying the conservative property.\n\n    Args:\n        concentrations (np.ndarray): Array of initial cell concentrations.\n        internal_faces (list): List of tuples for internal faces \n                               (cell_l, cell_r, length, u_normal).\n        boundary_faces (list): List of tuples for boundary faces \n                               (cell_idx, length, u_normal, c_boundary).\n        dt (float): The time step duration.\n\n    Returns:\n        float: The difference delta_M_computed - delta_M_expected.\n    \"\"\"\n    n_cells = len(concentrations)\n    dM_dt = np.zeros(n_cells, dtype=np.float64)\n    net_boundary_mass_inflow_rate = 0.0\n\n    # Process internal faces\n    for l_idx, r_idx, L_f, u_n in internal_faces:\n        c_l = concentrations[l_idx]\n        c_r = concentrations[r_idx]\n\n        # Upwind reconstruction for face concentration\n        if u_n >= 0:\n            c_f = c_l\n        else:\n            c_f = c_r\n        \n        # Face flux computation\n        F_f = u_n * L_f * c_f\n        \n        # Conservative update to cell mass rates\n        dM_dt[l_idx] -= F_f\n        dM_dt[r_idx] += F_f\n\n    # Process boundary faces\n    for l_idx, L_f, u_n, c_b in boundary_faces:\n        c_l = concentrations[l_idx]\n\n        # Upwind reconstruction for face concentration\n        if u_n >= 0:  # Outflow\n            c_f = c_l\n        else:  # Inflow\n            c_f = c_b\n            \n        # Face flux computation\n        F_f = u_n * L_f * c_f\n        \n        # Update cell mass rate\n        dM_dt[l_idx] -= F_f\n        \n        # Accumulate net boundary inflow rate\n        # (-F_f) is the inflow rate through the face.\n        net_boundary_mass_inflow_rate += -F_f\n\n    # Total mass change computed by summing all cell dM/dt contributions\n    total_mass_change_rate_computed = np.sum(dM_dt)\n    delta_M_computed = dt * total_mass_change_rate_computed\n\n    # Total mass change expected from boundary fluxes only\n    delta_M_expected = dt * net_boundary_mass_inflow_rate\n    \n    # This difference must be zero for a conservative scheme\n    return delta_M_computed - delta_M_expected\n\nsolve()\n```"
        }
    ]
}