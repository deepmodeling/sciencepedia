{
    "hands_on_practices": [
        {
            "introduction": "并非所有的数值近似方法都具有相同的性能。本练习将探讨一种特定的有限差分格式——中心差分，以帮助您理解“精度阶数”这一核心概念。我们将通过一个思想实验揭示为何中心差分格式对于二次多项式是精确无误的，这突显了截断误差项的结构对于选择高效离散格式的重要性。",
            "id": "2224247",
            "problem": "在数值分析中，一个足够光滑的函数 $f(x)$ 的一阶导数可以用中心差分公式来近似，该公式如下：\n$$D_h f(x) = \\frac{f(x+h) - f(x-h)}{2h}$$\n其中 $h$ 是一个很小的步长。此近似的局部截断误差定义为真实导数与近似值之间的差：\n$$T_h(x) = f'(x) - D_h f(x)$$\n\n考虑特定的二次多项式 $P(x) = \\frac{7}{2}x^2 - \\frac{11}{3}x + \\sqrt{5}$。\n\n当中心差分公式应用于此多项式 $P(x)$ 时，局部截断误差 $T_h(x)$ 的精确表达式是什么？\n\nA. $0$\n\nB. $-\\frac{7h^2}{6}$\n\nC. $\\frac{7h}{2}$\n\nD. $7h$\n\nE. $\\sqrt{5}$",
            "solution": "题意是为特定的二次多项式 $P(x)=\\frac{7}{2}x^{2}-\\frac{11}{3}x+\\sqrt{5}$，使用中心差分算子 $D_{h}f(x)=\\frac{f(x+h)-f(x-h)}{2h}$，计算其局部截断误差 $T_{h}(x)=f'(x)-D_{h}f(x)$。\n\n首先，回想一下一个足够光滑的函数在 $x$ 点的泰勒展开：\n$$\nf(x+h)=f(x)+h f'(x)+\\frac{h^{2}}{2}f''(x)+\\frac{h^{3}}{6}f^{(3)}(x)+\\cdots,\n$$\n$$\nf(x-h)=f(x)-h f'(x)+\\frac{h^{2}}{2}f''(x)-\\frac{h^{3}}{6}f^{(3)}(x)+\\cdots.\n$$\n两式相减得到\n$$\nf(x+h)-f(x-h)=2h f'(x)+\\frac{h^{3}}{3}f^{(3)}(x)+\\cdots,\n$$\n所以\n$$\nD_{h}f(x)=\\frac{f(x+h)-f(x-h)}{2h}=f'(x)+\\frac{h^{2}}{6}f^{(3)}(x)+\\cdots.\n$$\n因此，局部截断误差为\n$$\nT_{h}(x)=f'(x)-D_{h}f(x)=-\\frac{h^{2}}{6}f^{(3)}(x)+\\cdots.\n$$\n对于二次多项式 $P(x)=\\frac{7}{2}x^{2}-\\frac{11}{3}x+\\sqrt{5}$，我们有 $P^{(3)}(x)$ 恒等于 $0$。因此所有高阶项都消失了，中心差分是精确的：\n$$\nT_{h}(x)=0.\n$$\n\n或者，我们可以直接验证。计算导数：\n$$\nP'(x)=7x-\\frac{11}{3}.\n$$\n计算中心差分：\n$$\nP(x+h)=\\frac{7}{2}(x+h)^{2}-\\frac{11}{3}(x+h)+\\sqrt{5}=\\frac{7}{2}x^{2}+7xh+\\frac{7}{2}h^{2}-\\frac{11}{3}x-\\frac{11}{3}h+\\sqrt{5},\n$$\n$$\nP(x-h)=\\frac{7}{2}(x-h)^{2}-\\frac{11}{3}(x-h)+\\sqrt{5}=\\frac{7}{2}x^{2}-7xh+\\frac{7}{2}h^{2}-\\frac{11}{3}x+\\frac{11}{3}h+\\sqrt{5}.\n$$\n相减，\n$$\nP(x+h)-P(x-h)=14xh-\\frac{22}{3}h.\n$$\n除以 $2h$：\n$$\nD_{h}P(x)=\\frac{P(x+h)-P(x-h)}{2h}=7x-\\frac{11}{3}=P'(x).\n$$\n因此\n$$\nT_{h}(x)=P'(x)-D_{h}P(x)=0.\n$$\n因此，正确选项是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "既然我们知道截断误差可预测地依赖于网格间距 $\\Delta x$，我们就可以利用这一特性。本练习将指导您推导理查森外推法（Richardson extrapolation），这是一种在实际建模中广泛应用的强大技术，它利用在不同分辨率网格上得到的解来消除主导的误差项，从而获得更高精度的解，并且能够估算误差大小。对于任何希望评估其结果可靠性的计算科学家来说，这都是一项基本技能。",
            "id": "3927311",
            "problem": "在一个由稳态平流-扩散偏微分方程（PDE）控制的一维河口通道模型中，我们关注一个标量诊断值，记为 $J$。该值是通过在间距为 $\\Delta x$ 的均匀网格上采用二阶精度的空间离散化方法获得的数值解计算得出的。假设该方法是相容的，并且在渐进网格细化的情况下，该诊断值满足误差展开式 $J(\\Delta x) = J^{\\ast} + \\text{TE}(\\Delta x)$，其中 $J^{\\ast}$ 是精确（连续）诊断值，而截断误差 $\\text{TE}(\\Delta x)$ 可表示为一个关于 $\\Delta x$ 偶次幂的光滑类泰勒渐进级数，由于二阶精度，该级数从 $\\Delta x^{2}$ 阶开始。从相容性和精度阶的核心定义出发，并以该渐进误差展开式为基础，回答以下问题：\n1) 利用在网格间距 $\\Delta x$ 和 $\\Delta x/2$ 下的两次模拟来消除主阶截断误差项，从而推导出一个对 $J^{\\ast}$ 的Richardson外推估计量 $J_{R}$ 的闭式表达式，该估计量比原始的二阶格式具有更高阶的精度。\n2) 证明差值 $J(\\Delta x/2) - J(\\Delta x)$ 如何为较细网格诊断值 $J(\\Delta x/2)$ 的截断误差大小提供一个主阶估计量，并显式地推导出其比例常数。\n3) 一个近岸海洋应用中使用相同的二阶格式，在两种网格间距下得到了如下数值计算的表面热通量诊断值（单位：瓦/平方米）：$J(\\Delta x) = 1.372 \\times 10^{-3}$ 和 $J(\\Delta x/2) = 1.401 \\times 10^{-3}$。使用你推导出的公式，计算Richardson外推估计值 $J_{R}$ 和 $J(\\Delta x/2)$ 的主阶绝对截断误差估计值。将最终数值结果四舍五入至四位有效数字。以瓦/平方米为单位表示最终答案，并将其报告为行向量 $\\big[ J_{R}, \\widehat{E}_{\\Delta x/2} \\big]$。",
            "solution": "问题陈述已经过严格验证，被认为是科学上可靠、适定且自洽的。它提出了一个数值分析中的标准且可形式化的问题，具体涉及离散化偏微分方程的误差估计和通过Richardson外推法进行的收敛加速。所有提供的信息都是一致且足以推导出唯一解的。\n\n问题的核心在于，对于一个通过二阶精度格式获得的数值计算诊断值 $J(\\Delta x)$，其给定的渐进误差展开式。该展开式被表述为网格间距 $\\Delta x$ 的偶次幂级数：\n$$\nJ(\\Delta x) = J^{\\ast} + c_{2}(\\Delta x)^2 + c_{4}(\\Delta x)^4 + c_{6}(\\Delta x)^6 + \\dots\n$$\n这里，$J^{\\ast}$ 代表在连续极限（$\\Delta x \\to 0$）下诊断值的精确值，而 $c_{2}, c_{4}, c_{6}, \\dots$ 是与 $\\Delta x$ 无关的常数。项 $c_{2}(\\Delta x)^2$ 是主阶截断误差，与二阶精度方法相符。\n\n1) Richardson外推估计量 $J_{R}$ 的推导\n\n我们有两个数值解，一个是用网格间距 $\\Delta x$ 计算的，另一个是用更细的网格间距 $\\Delta x/2$ 计算的。我们为两者写出误差展开式：\n$$\nJ(\\Delta x) = J^{\\ast} + c_{2}(\\Delta x)^2 + c_{4}(\\Delta x)^4 + \\mathcal{O}((\\Delta x)^6) \\quad (1)\n$$\n$$\nJ(\\frac{\\Delta x}{2}) = J^{\\ast} + c_{2}\\left(\\frac{\\Delta x}{2}\\right)^2 + c_{4}\\left(\\frac{\\Delta x}{2}\\right)^4 + \\mathcal{O}((\\Delta x)^6) = J^{\\ast} + \\frac{1}{4}c_{2}(\\Delta x)^2 + \\frac{1}{16}c_{4}(\\Delta x)^4 + \\mathcal{O}((\\Delta x)^6) \\quad (2)\n$$\nRichardson外推的目标是构造 $J(\\Delta x)$ 和 $J(\\Delta x/2)$ 的一个线性组合，以消除主阶误差项 $c_{2}(\\Delta x)^2$。为此，我们可以将方程 $(2)$ 乘以 $4$，使其主阶误差项的系数与方程 $(1)$ 中的相匹配：\n$$\n4 J(\\frac{\\Delta x}{2}) = 4J^{\\ast} + c_{2}(\\Delta x)^2 + \\frac{4}{16}c_{4}(\\Delta x)^4 + \\mathcal{O}((\\Delta x)^6) = 4J^{\\ast} + c_{2}(\\Delta x)^2 + \\frac{1}{4}c_{4}(\\Delta x)^4 + \\mathcal{O}((\\Delta x)^6) \\quad (3)\n$$\n现在，我们从方程 $(3)$ 中减去方程 $(1)$：\n$$\n4 J(\\frac{\\Delta x}{2}) - J(\\Delta x) = (4J^{\\ast} - J^{\\ast}) + (c_{2}(\\Delta x)^2 - c_{2}(\\Delta x)^2) + (\\frac{1}{4}c_{4}(\\Delta x)^4 - c_{4}(\\Delta x)^4) + \\mathcal{O}((\\Delta x)^6)\n$$\n$$\n4 J(\\frac{\\Delta x}{2}) - J(\\Delta x) = 3J^{\\ast} - \\frac{3}{4}c_{4}(\\Delta x)^4 + \\mathcal{O}((\\Delta x)^6)\n$$\n对此代数方程求解 $J^{\\ast}$ 可得：\n$$\nJ^{\\ast} = \\frac{4 J(\\frac{\\Delta x}{2}) - J(\\Delta x)}{3} + \\frac{1}{4}c_{4}(\\Delta x)^4 + \\mathcal{O}((\\Delta x)^6)\n$$\nRichardson外推估计量 $J_{R}$ 定义为此表达式的主项，它提供了对 $J^{\\ast}$ 的一个更高阶的估计：\n$$\nJ_{R} = \\frac{4 J(\\frac{\\Delta x}{2}) - J(\\Delta x)}{3}\n$$\n这个新估计量的误差为 $J_{R} - J^{\\ast} = -\\frac{1}{4}c_{4}(\\Delta x)^4 + \\mathcal{O}((\\Delta x)^6)$。由于误差现在与 $(\\Delta x)^4$ 成正比，估计量 $J_{R}$ 是四阶精度的，相较于原始的二阶格式有所改进。\n\n2) $J(\\Delta x/2)$ 的截断误差估计量的推导\n\n目标是估计较细网格解的截断误差 $E_{\\Delta x/2} = J(\\Delta x/2) - J^{\\ast}$。该误差的主阶项为 $E_{\\Delta x/2} \\approx \\frac{1}{4}c_{2}(\\Delta x)^2$。我们需要利用两个数值解之间的可观测差异 $J(\\Delta x/2) - J(\\Delta x)$ 来找到此数量的表达式。\n\n让我们从方程 $(1)$ 中减去方程 $(2)$，只保留主阶误差项：\n$$\nJ(\\Delta x) - J(\\frac{\\Delta x}{2}) \\approx (J^{\\ast} + c_{2}(\\Delta x)^2) - (J^{\\ast} + \\frac{1}{4}c_{2}(\\Delta x)^2)\n$$\n$$\nJ(\\Delta x) - J(\\frac{\\Delta x}{2}) \\approx \\frac{3}{4}c_{2}(\\Delta x)^2\n$$\n这使我们可以根据计算值来估计未知项 $c_{2}(\\Delta x)^2$：\n$$\nc_{2}(\\Delta x)^2 \\approx \\frac{4}{3}\\left(J(\\Delta x) - J(\\frac{\\Delta x}{2})\\right)\n$$\n对于较细网格的诊断值 $J(\\Delta x/2)$，其主阶截断误差为 $E_{\\Delta x/2} \\approx \\frac{1}{4}c_{2}(\\Delta x)^2$。代入我们对 $c_{2}(\\Delta x)^2$ 的估计：\n$$\nE_{\\Delta x/2} \\approx \\frac{1}{4} \\left[ \\frac{4}{3}\\left(J(\\Delta x) - J(\\frac{\\Delta x}{2})\\right) \\right] = \\frac{1}{3}\\left(J(\\Delta x) - J(\\frac{\\Delta x}{2})\\right)\n$$\n这个表达式为 $J(\\Delta x/2)$ 的带符号截断误差提供了一个主阶估计。问题要求一个基于差值 $J(\\Delta x/2) - J(\\Delta x)$ 的估计量，这得到：\n$$\nE_{\\Delta x/2} \\approx -\\frac{1}{3}\\left(J(\\frac{\\Delta x}{2}) - J(\\Delta x)\\right)\n$$\n因此，截断误差的大小估计为：\n$$\n|E_{\\Delta x/2}| \\approx \\frac{1}{3}\\left|J(\\frac{\\Delta x}{2}) - J(\\Delta x)\\right|\n$$\n这表明差值 $J(\\Delta x/2) - J(\\Delta x)$ 确实可以作为细网格解截断误差的一个代理，并且其大小与误差大小相关的比例常数为 $1/3$。\n\n3) 数值计算\n\n我们得到了表面热通量诊断值的以下数值：\n$$\nJ(\\Delta x) = 1.372 \\times 10^{-3} \\, \\text{W m}^{-2}\n$$\n$$\nJ(\\frac{\\Delta x}{2}) = 1.401 \\times 10^{-3} \\, \\text{W m}^{-2}\n$$\n首先，我们使用第 $(1)$ 部分的公式计算Richardson外推估计值 $J_{R}$：\n$$\nJ_{R} = \\frac{4 J(\\frac{\\Delta x}{2}) - J(\\Delta x)}{3} = \\frac{4(1.401 \\times 10^{-3}) - 1.372 \\times 10^{-3}}{3}\n$$\n$$\nJ_{R} = \\frac{(5.604 - 1.372) \\times 10^{-3}}{3} = \\frac{4.232 \\times 10^{-3}}{3} \\approx 1.410666... \\times 10^{-3}\n$$\n四舍五入到四位有效数字，我们得到 $J_{R} = 1.411 \\times 10^{-3}$。\n\n接下来，我们使用第 $(2)$ 部分的公式计算 $J(\\Delta x/2)$ 的主阶绝对截断误差估计值，我们将其记为 $\\widehat{E}_{\\Delta x/2}$：\n$$\n\\widehat{E}_{\\Delta x/2} = \\frac{\\left|J(\\frac{\\Delta x}{2}) - J(\\Delta x)\\right|}{3} = \\frac{\\left| (1.401 \\times 10^{-3}) - (1.372 \\times 10^{-3}) \\right|}{3}\n$$\n$$\n\\widehat{E}_{\\Delta x/2} = \\frac{|0.029 \\times 10^{-3}|}{3} = \\frac{0.029 \\times 10^{-3}}{3} \\approx 0.009666... \\times 10^{-3} = 9.666... \\times 10^{-6}\n$$\n四舍五入到四位有效数字，我们得到 $\\widehat{E}_{\\Delta x/2} = 9.667 \\times 10^{-6}$。\n\n最终要求的量，以瓦/平方米表示，为 $J_R \\approx 1.411 \\times 10^{-3}$ 和 $\\widehat{E}_{\\Delta x/2} \\approx 9.667 \\times 10^{-6}$。",
            "answer": "$$\n\\boxed{[1.411 \\times 10^{-3}, 9.667 \\times 10^{-6}]}\n$$"
        },
        {
            "introduction": "最后的练习将误差估计过程形式化，介绍了一套在科学与工程领域中用于代码验证的严谨流程。您将学习如何计算网格收敛指数（Grid Convergence Index, GCI），它为模拟中的离散误差提供了一个标准化的量化度量。这个练习将截断误差的理论与复杂环境模型的实际验证工作联系起来。",
            "id": "3927276",
            "problem": "您正在对一个输运-扩散模拟中的惰性示踪剂浓度进行建模，该模拟是环境和地球系统建模的典型代表。考虑一系列嵌套的结构化网格，其间距分别为 $h_1$、$h_2$、$h_3$（其中 $h_1 < h_2 < h_3$），在这些网格上计算一个标量 $Q(h)$。其中，$Q(h)$ 是一个具有物理意义的诊断量，例如以千克/立方米（$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）表示的区域平均示踪剂浓度。假设数值方法处于渐近区，因此截断误差随网格间距的变化遵循幂律关系：$$Q(h) = Q^\\ast + C\\,h^p + \\mathcal{O}\\!\\left(h^{p+1}\\right),$$ 其中 $Q^\\ast$ 是网格无关解，$C$ 是一个取决于方法和解的正则性的常数，$p$ 是观测到的精度阶。\n\n从第一性原理出发，利用上述缩放关系：\n-   根据三套网格数据 $(h_1,h_2,h_3)$ 和 $(Q_1,Q_2,Q_3)$（其中 $Q_i = Q(h_i)$），通过消去未知常数 $C$ 和未知网格无关解值 $Q^\\ast$，推导出观测到的精度阶 $p$。\n-   使用相同的缩放关系和一个固定的安全因子 $F_s = 1.25$（适用于三网格、单调收敛性研究），计算细-中网格对和中-粗网格对的网格收敛指数（GCI）。GCI 应以无量纲小数（而非百分比）的形式报告，用以量化所报告的解在网格对中较细网格上的估计相对不确定度。您的程序必须将细-中网格对的 GCI 处理为 $$\\mathrm{GCI}_{21} = F_s \\,\\frac{\\left|Q_2 - Q_1\\right|}{\\left|Q_1\\right|\\left(r_{21}^p - 1\\right)},$$ 对中-粗网格对也类似处理 $$\\mathrm{GCI}_{32} = F_s \\,\\frac{\\left|Q_3 - Q_2\\right|}{\\left|Q_2\\right|\\left(r_{32}^p - 1\\right)},$$ 其中 $r_{21} = h_2/h_1$ 且 $r_{32} = h_3/h_2$。\n\n您的程序必须实现一个有原则的步骤，以利用三套网格数据从截断误差缩放关系中推断出 $p$。该程序必须对 $Q_i$ 的正负差值都具有鲁棒性，并且必须在适当之处使用绝对差值，以避免观测阶数出现符号模糊性。如果 $r_{21} \\neq r_{32}$，您的程序应求解由缩放关系所隐含的非线性方程，而不是假设一个公共的加密比。\n\n物理单位和输出要求：\n-   输入 $Q_i$ 必须解释为示踪剂浓度，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，网格间距 $h_i$ 的单位必须为米（$\\mathrm{m}$）。\n-   输出 $p$、$\\mathrm{GCI}_{21}$ 和 $\\mathrm{GCI}_{32}$ 是无量纲的。请以小数形式（而非百分比）报告 $\\mathrm{GCI}_{21}$ 和 $\\mathrm{GCI}_{32}$。\n\n测试套件：\n使用以下五个测试用例，每个用例由 $(h_1,h_2,h_3)$（单位：米）和 $(Q_1,Q_2,Q_3)$（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）定义：\n1.  用例 1（公共加密比 $r=2$，单调收敛，二阶截断误差）：$h_1 = 0.01$, $h_2 = 0.02$, $h_3 = 0.04$；$Q_1 = 1.00005$, $Q_2 = 1.0002$, $Q_3 = 1.0008$。\n2.  用例 2（公共加密比 $r=2$，单调收敛，非整数阶）：$h_1 = 0.02$, $h_2 = 0.04$, $h_3 = 0.08$；$Q_1 = 1.9994343146$, $Q_2 = 1.9984$, $Q_3 = 1.9954745166$。\n3.  用例 3（公共加密比 $r=2$，近渐近区，带有少量高阶项污染）：$h_1 = 0.01$, $h_2 = 0.02$, $h_3 = 0.04$；$Q_1 = 0.80003005$, $Q_2 = 0.8001204$, $Q_3 = 0.8004832$。\n4.  用例 4（公共加密比 $r=2$，极小差值，测试数值鲁棒性）：$h_1 = 0.001$, $h_2 = 0.002$, $h_3 = 0.004$；$Q_1 = 1.5000001$, $Q_2 = 1.5000004$, $Q_3 = 1.5000016$。\n5.  用例 5（不等加密比，单调收敛）：$h_1 = 0.01$, $h_2 = 0.015$, $h_3 = 0.027$；$Q_1 = 0.7500159247$, $Q_2 = 0.7500388040$, $Q_3 = 0.7501413000$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由逗号分隔的列表，该列表包含五个内部列表，每个内部列表为对应测试用例存放三个浮点数 $[p,\\mathrm{GCI}_{21},\\mathrm{GCI}_{32}]$。总体格式必须严格如下：\n$$\\text{[}[p_1,\\mathrm{GCI}_{21,1},\\mathrm{GCI}_{32,1}], [p_2,\\mathrm{GCI}_{21,2},\\mathrm{GCI}_{32,2}], [p_3,\\mathrm{GCI}_{21,3},\\mathrm{GCI}_{32,3}], [p_4,\\mathrm{GCI}_{21,4},\\mathrm{GCI}_{32,4}], [p_5,\\mathrm{GCI}_{21,5},\\mathrm{GCI}_{32,5}]\\text{]}.$$\n所有数值都必须打印为标准的Python浮点字面量。不应打印任何额外文本。",
            "solution": "用户提供的问题陈述已经过分析并被认定为有效。它在科学上基于数值分析和验证与确认的原理，特别是关于网格收敛性研究。该问题是适定的、客观的，并包含了推导和计算所需量所必需的所有信息。\n\n解决方案分两个阶段进行：首先，有原则地推导观测到的精度阶（$p$）和网格收敛指数（GCI）的公式；其次，在Python脚本中实现这些公式，以解决给定的测试用例。\n\n### 推导观测到的精度阶（$p$）\n\n出发点是，对于一个计算出的标量 $Q(h)$，其截断误差随网格间距 $h$ 的变化遵循假设的幂律缩放关系：\n$$Q(h) = Q^\\ast + C\\,h^p + \\mathcal{O}\\!\\left(h^{p+1}\\right)$$\n这里，$Q^\\ast$ 是精确的、网格无关的解，$C$ 是一个常数，$p$ 是数值方法的精度阶。给定在三个间距分别为 $h_1$、$h_2$ 和 $h_3$（其中 $h_1  h_2  h_3$）的网格上计算出的三个解 $Q_1$、$Q_2$ 和 $Q_3$，我们可以通过忽略高阶项 $\\mathcal{O}(h^{p+1})$ 来写出一个包含三个方程的方程组。当网格足够精细以至于处于渐近区时，这是一个有效的近似。\n\n$$Q_1 \\approx Q^\\ast + C h_1^p \\quad (1)$$\n$$Q_2 \\approx Q^\\ast + C h_2^p \\quad (2)$$\n$$Q_3 \\approx Q^\\ast + C h_3^p \\quad (3)$$\n\n我们的目标是通过消去未知数 $Q^\\ast$ 和 $C$ 来确定 $p$。首先，我们通过连续方程相减来消去 $Q^\\ast$：\n$$Q_2 - Q_1 = C (h_2^p - h_1^p) \\quad (4)$$\n$$Q_3 - Q_2 = C (h_3^p - h_2^p) \\quad (5)$$\n\n接下来，我们通过将方程（$5$）与方程（$4$）相除来消去常数 $C$。为确保该比值是良定义且为正（特别是在单调收敛的情况下，差值 $(Q_2 - Q_1)$ 和 $(Q_3 - Q_2)$ 具有相同的符号），我们按照问题中的规定使用绝对值：\n$$\\frac{|Q_3 - Q_2|}{|Q_2 - Q_1|} = \\frac{|C (h_3^p - h_2^p)|}{|C (h_2^p - h_1^p)|} = \\frac{|h_3^p - h_2^p|}{|h_2^p - h_1^p|}$$\n由于对于一个收敛方法，$h_1  h_2  h_3$ 且 $p  0$，因此 $(h_2^p - h_1^p)$ 和 $(h_3^p - h_2^p)$ 两项都为正。所以，右侧的绝对值符号可以去掉。\n我们定义网格加密比 $r_{21} = h_2/h_1$ 和 $r_{32} = h_3/h_2$。方程变为：\n$$\\frac{|Q_3 - Q_2|}{|Q_2 - Q_1|} = \\frac{h_2^p(r_{32}^p - 1)}{h_1^p(r_{21}^p - 1)} = \\left(\\frac{h_2}{h_1}\\right)^p \\frac{r_{32}^p - 1}{r_{21}^p - 1} = r_{21}^p \\frac{r_{32}^p - 1}{r_{21}^p - 1}$$\n\n这是观测到的精度阶 $p$ 的一般方程。\n\n**特殊情况：恒定加密比**\n在许多实际研究中，网格是以一个恒定因子进行加密的，即 $r_{21} = r_{32} = r$。在这种特殊情况下，一般方程会显著简化。设 $R = \\frac{|Q_3 - Q_2|}{|Q_2 - Q_1|}$。\n$$R = r^p \\frac{r^p - 1}{r^p - 1} = r^p$$\n我们可以通过对两边取自然对数来解出 $p$：\n$$\\ln(R) = \\ln(r^p) = p \\ln(r)$$\n$$p = \\frac{\\ln(R)}{\\ln(r)} = \\frac{\\ln\\left(\\frac{|Q_3 - Q_2|}{|Q_2 - Q_1|}\\right)}{\\ln(r)}$$\n\n**一般情况：不等加密比**\n当 $r_{21} \\neq r_{32}$ 时，我们必须求解关于 $p$ 的一般非线性方程：\n$$R = r_{21}^p \\frac{r_{32}^p - 1}{r_{21}^p - 1}$$\n这个方程无法以简单的闭式解形式解析地求解 $p$。它必须通过数值方法求解。我们可以将其重排为一个求根问题，$f(p) = 0$：\n$$f(p) = r_{21}^p (r_{32}^p - 1) - R (r_{21}^p - 1) = 0$$\n利用 $h_3 = r_{32}h_2 = r_{32}r_{21}h_1$，我们可以用一个公共底数重写这些项：\n$$f(p) = (r_{21}r_{32})^p - r_{21}^p - R(r_{21}^p - 1) = \\left(\\frac{h_3}{h_1}\\right)^p - (1+R)\\left(\\frac{h_2}{h_1}\\right)^p + R = 0$$\n可以应用一个数值求根算法（如 Brent 方法）于此函数来找到 $p$ 的值。通常会使用一个合适的 $p$ 的搜索区间（例如 $[0.1, 8]$），因为常见的数值方法的精度阶都在这个范围内。\n\n### 网格收敛指数（GCI）的计算\n\nGCI 是解的相对数值不确定度的一个估计。问题给出了要使用的公式，这些公式在该领域是标准的。对于一个固定的安全因子 $F_s = 1.25$，细-中网格对（$1,2$）和中-粗网格对（$2,3$）的 GCI 分别为：\n$$\\mathrm{GCI}_{21} = F_s \\,\\frac{\\left|Q_2 - Q_1\\right|}{\\left|Q_1\\right|\\left(r_{21}^p - 1\\right)}$$\n$$\\mathrm{GCI}_{32} = F_s \\,\\frac{\\left|Q_3 - Q_2\\right|}{\\left|Q_2\\right|\\left(r_{32}^p - 1\\right)}$$\n一旦根据三套网格数据确定了精度阶 $p$，这些指数就可以直接计算出来。这些值是无量纲的，并以小数形式报告。\n\n### 算法步骤\n\n每个测试用例的计算步骤如下：\n1.  给定 $(h_1, h_2, h_3)$ 和 $(Q_1, Q_2, Q_3)$，计算网格加密比 $r_{21} = h_2/h_1$ 和 $r_{32} = h_3/h_2$。\n2.  计算解的差值之比，$R = |Q_3 - Q_2|/|Q_2 - Q_1|$。\n3.  比较 $r_{21}$ 和 $r_{32}$。\n    -   如果它们相等（在小的数值容差范围内），则使用简化的对数公式计算 $p$：$p = \\ln(R) / \\ln(r_{21})$。\n    -   如果它们不相等，则使用数值求根算法求解非线性方程 $f(p) = (h_3/h_1)^p - (1+R)(h_2/h_1)^p + R = 0$ 来得到 $p$。\n4.  使用计算出的 $p$ 值，根据各自的公式计算 $\\mathrm{GCI}_{21}$ 和 $\\mathrm{GCI}_{32}$。\n5.  返回三元组 $[p, \\mathrm{GCI}_{21}, \\mathrm{GCI}_{32}]$。\n对所提供的五个测试用例中的每一个都执行此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the grid convergence problem for all test cases.\n    \"\"\"\n    \n    # Safety factor for GCI calculation\n    F_s = 1.25\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: r=2, p=2\n        {'h': (0.01, 0.02, 0.04), 'Q': (1.00005, 1.0002, 1.0008)},\n        # Case 2: r=2, non-integer p\n        {'h': (0.02, 0.04, 0.08), 'Q': (1.9994343146, 1.9984, 1.9954745166)},\n        # Case 3: r=2, near-asymptotic\n        {'h': (0.01, 0.02, 0.04), 'Q': (0.80003005, 0.8001204, 0.8004832)},\n        # Case 4: r=2, small differences\n        {'h': (0.001, 0.002, 0.004), 'Q': (1.5000001, 1.5000004, 1.5000016)},\n        # Case 5: unequal refinement ratios\n        {'h': (0.01, 0.015, 0.027), 'Q': (0.7500159247, 0.7500388040, 0.7501413000)},\n    ]\n\n    def process_case(h_vals, Q_vals):\n        \"\"\"\n        Calculates p, GCI_21, and GCI_32 for a single case.\n        \n        Args:\n            h_vals (tuple): Grid spacings (h1, h2, h3).\n            Q_vals (tuple): Scalar solutions (Q1, Q2, Q3).\n            \n        Returns:\n            list: A list containing [p, GCI_21, GCI_32].\n        \"\"\"\n        h1, h2, h3 = h_vals\n        q1, q2, q3 = Q_vals\n\n        # Calculate refinement ratios\n        r21 = h2 / h1\n        r32 = h3 / h2\n\n        # Calculate differences in solutions\n        # A small epsilon is added to the denominator to prevent division by zero,\n        # though not strictly necessary for the given test cases.\n        dq21 = q2 - q1\n        dq32 = q3 - q2\n        \n        if np.isclose(dq21, 0):\n            # This case indicates either perfect solution or insufficient precision.\n            # p cannot be determined. This is an invalid state for this problem's context.\n            # For this problem, we assume dq21 is never zero.\n            pass\n            \n        R = abs(dq32 / dq21)\n\n        # Determine the order of accuracy, p\n        if np.isclose(r21, r32):\n            # Special case: constant refinement ratio\n            # p = ln(|(Q3-Q2)/(Q2-Q1)|) / ln(r)\n            p = np.log(R) / np.log(r21)\n        else:\n            # General case: unequal refinement ratios\n            # Solve the nonlinear equation for p:\n            # (h3/h1)^p - (1+R)*(h2/h1)^p + R = 0\n            \n            r31 = h3 / h1 # This is also r21 * r32\n            \n            # The function to find the root of\n            def p_equation(p_var):\n                return r31**p_var - (1.0 + R) * r21**p_var + R\n\n            # Find the root for p > 0.\n            # We use a bracket that avoids the trivial p=0 root.\n            try:\n                sol = root_scalar(p_equation, bracket=[0.1, 8.0], method='brentq')\n                p = sol.root\n            except ValueError:\n                # If no root is found in the bracket, something is wrong.\n                # This may happen with non-monotonic convergence.\n                p = np.nan\n\n        # Calculate Grid Convergence Indices (GCI)\n        if (r21**p - 1.0) == 0.0:\n            gci21 = np.inf\n        else:\n            gci21 = F_s * abs(dq21) / (abs(q1) * (r21**p - 1.0))\n        \n        if (r32**p - 1.0) == 0.0:\n            gci32 = np.inf\n        else:\n            gci32 = F_s * abs(dq32) / (abs(q2) * (r32**p - 1.0))\n\n        return [p, gci21, gci32]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['h'], case['Q'])\n        all_results.append(result)\n\n    # Format the output string to be a compact representation of a list of lists,\n    # with no spaces, as suggested by the problem's output format example.\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}