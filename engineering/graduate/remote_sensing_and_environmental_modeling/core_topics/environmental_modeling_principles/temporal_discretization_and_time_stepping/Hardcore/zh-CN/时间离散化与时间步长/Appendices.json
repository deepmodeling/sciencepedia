{
    "hands_on_practices": [
        {
            "introduction": "选择数值方法的基础是理解其精度和稳定性。本练习提供了一种通过经验性测量来评估这些属性的动手方法。通过在一个典型的测试问题上实现和测试几种标准方法（如显式/隐式欧拉法和休恩法），您将对这些理论概念获得实践直觉，并亲眼观察到刚性问题如何影响数值表现。",
            "id": "3859481",
            "problem": "考虑线性常微分方程 (ODE) 初值问题 $y'(t)=-\\lambda y(t)$，其中 $t \\in [0,T]$，初始条件为 $y(0)=y_0$，且 $\\lambda>0$。其精确解为 $y(t)=y_0 \\exp(-\\lambda t)$。这个线性测试问题是环境模型中线性化松弛过程时间行为的标准代表，用于评估数值时间步进格式，这些格式也用于由遥感信息驱动的数据驱动状态估计。您的任务是设计一个程序，对于给定的参数集，通过比较以下三种方法在连续两次步长减半时的全局误差，计算在最终时间的观测精度阶：\n\n- 显式（前向）欧拉法：$y_{n+1} = y_n + h f(t_n,y_n)$。\n- 隐式（后向）欧拉法：$y_{n+1} = y_n + h f(t_{n+1},y_{n+1})$。\n- Heun 法（显式梯形法，一种二阶龙格-库塔法）：$y_{n+1} = y_n + \\dfrac{h}{2}\\left(f(t_n,y_n)+f(t_n+h,y_n+h f(t_n,y_n))\\right)$。\n\n这里 $f(t,y)=-\\lambda y$，$h$ 是时间步长，最终时间 $T$ 的数值解在 $N$ 步后得到，其中 $h = T/N$。对于给定的基础步数 $N_0$，通过每次将步数加倍来定义两次加密，即使用 $N_0$、$2N_0$ 和 $4N_0$，对应步长为 $h$、$h/2$ 和 $h/4$。对于每种方法和每个参数集，计算最终时间 $T$ 的全局误差 $E(h)=\\lvert y_N - y(T)\\rvert$，分别对应步长 $h$、$h/2$ 和 $h/4$。然后通过比较连续加密之间的误差来估计观测精度阶，并对从 $(h,h/2)$ 和 $(h/2,h/4)$ 这两对步长中得到的两个估计值取平均。在您的实现中，不要使用任何解析误差常数或预先推导的误差阶公式；相反，您的估计应仅基于在三种分辨率下进行数值运算所得到的误差。\n\n您必须遵守的科学依据：\n- 使用在固定最终时间 $T$ 的全局误差定义，以及对于一个相容方法，存在常数 $C$ 和阶数 $p>0$ 使得当 $h \\to 0$ 时 $E(h) \\approx C h^p$ 的概念。\n- 仅使用问题的精确解 $y(T)=y_0 \\exp(-\\lambda T)$ 来计算误差；不要使用构造解析或内部误差估计器。\n\n测试套件：\n所有情况均使用 $y_0 = 1$。对于每种情况，程序必须首先将基础步数 $N_0$ 设置为与 $T/h_0$ 最接近的整数，即 $N_0 = \\operatorname{round}(T/h_0)$，然后使用 $N_0$、$2N_0$ 和 $4N_0$。这保证了在每个分辨率下都能精确达到最终时间 $T$。\n\n为以下四个参数集提供观测精度阶，这些参数集旨在探究非刚性、中度刚性、稳定域内的刚性以及接近不稳定域的刚性情况：\n- 情况 A（非刚性）：$\\lambda = 1$，$T = 1$，$h_0 = 0.2$。\n- 情况 B（中度刚性，显式方法的边界）：$\\lambda = 20$，$T = 1$，$h_0 = 0.1$。\n- 情况 C（刚性但在加密后显式方法稳定域内）：$\\lambda = 100$，$T = 1$，$h_0 = 0.015$。\n- 情况 D（非常刚性，粗略步长下显式方法不稳定，但时间范围短）：$\\lambda = 500$，$T = 0.1$，$h_0 = 0.05$。\n\n您的程序必须：\n- 完全按照上述定义实现这三种方法。\n- 对于每种情况，通过对从三个分辨率 $N_0$、$2N_0$ 和 $4N_0$ 获得的两组基于加密的估计值取平均，计算每种方法的观测精度阶。\n- 返回一行输出，包含一个由逗号分隔的 $12$ 个浮点数结果列表，并用方括号括起来。序列必须是，按 A、B、C、D 的顺序，每种情况下显式欧拉法、隐式欧拉法和 Heun 法的观测阶，在每种情况下也按此顺序。例如，输出格式为 $[\\text{A\\_EE},\\text{A\\_IE},\\text{A\\_HM},\\text{B\\_EE},\\text{B\\_IE},\\text{B\\_HM},\\text{C\\_EE},\\text{C\\_IE},\\text{C\\_HM},\\text{D\\_EE},\\text{D\\_IE},\\text{D\\_HM}]$，其中 $\\text{EE}$ 表示显式欧拉法，$\\text{IE}$ 表示隐式欧拉法，$\\text{HM}$ 表示 Heun 法。在输出前，将每个报告值数值上四舍五入到 $6$ 位小数。\n\n角度单位不适用。不涉及物理单位；所有量均为无量纲。最终输出必须是单行，且具有上面所示的精确列表语法。",
            "solution": "### **问题验证**\n\n#### **第一步：提取已知条件**\n\n问题陈述提供了以下信息：\n- **ODE**：$y'(t)=-\\lambda y(t)$，其中 $t \\in [0,T]$。\n- **初始条件**：$y(0)=y_0$。\n- **参数约束**：$\\lambda>0$。\n- **精确解**：$y(t)=y_0 \\exp(-\\lambda t)$。\n- **函数定义**：$f(t,y)=-\\lambda y$。\n- **数值方法**：\n    1.  **显式（前向）欧拉法**：$y_{n+1} = y_n + h f(t_n,y_n)$。\n    2.  **隐式（后向）欧拉法**：$y_{n+1} = y_n + h f(t_{n+1},y_{n+1})$。\n    3.  **Heun 法（显式梯形法）**：$y_{n+1} = y_n + \\dfrac{h}{2}\\left(f(t_n,y_n)+f(t_n+h,y_n+h f(t_n,y_n))\\right)$。\n- **时间离散化**：$h = T/N$，其中 $N$ 是步数。\n- **误差计算**：最终时间 $T$ 的全局误差 $E(h)=\\lvert y_N - y(T)\\rvert$。\n- **精度阶估计**：对于步数为 $N_0, 2N_0, 4N_0$ 的分辨率，观测阶是两个估计值的平均值。\n- **科学依据**：对于小 $h$，$E(h) \\approx C h^p$，且误差计算必须使用给定的精确解。\n- **测试套件设置**：所有情况均使用 $y_0 = 1$。基础步数 $N_0 = \\operatorname{round}(T/h_0)$。\n- **参数集**：\n    -   情况 A：$\\lambda = 1$，$T = 1$，$h_0 = 0.2$。\n    -   情况 B：$\\lambda = 20$，$T = 1$，$h_0 = 0.1$。\n    -   情况 C：$\\lambda = 100$，$T = 1$，$h_0 = 0.015$。\n    -   情况 D：$\\lambda = 500$，$T = 0.1$，$h_0 = 0.05$。\n- **输出格式**：单行输出，包含一个由逗号分隔的 $12$ 个浮点数结果列表，四舍五入到 $6$ 位小数，并用方括号括起来。顺序指定为 (A_EE, A_IE, A_HM, B_EE, B_IE, B_HM, C_EE, C_IE, C_HM, D_EE, D_IE, D_HM)。\n\n#### **第二步：使用提取的已知条件进行验证**\n\n- **科学上可靠**：问题基于线性测试方程 $y' = -\\lambda y$，这是常微分方程数值分析中研究时间积分格式稳定性和精度的基本工具。所提供的方法（显式欧拉法、隐式欧拉法、Heun 法）是标准的、经典的数值积分器示例。此问题牢固地植根于已建立的数值分析原理。\n- **适定的**：问题描述精确。所有常数、方程、初始条件和步骤都明确定义。对于每个参数集，指令都能导出一个单一、唯一且有意义的数值结果（观测精度阶）。\n- **客观的**：问题以精确的数学和计算术语陈述，没有任何主观性、模糊性或基于观点的断言。\n\n该问题不表现出任何无效性缺陷：\n1.  **科学/事实上的不健全**：不存在违反数学逻辑或科学原理的情况。\n2.  **非形式化/不相关**：问题是一个形式化的、可量化的任务，与建模中的时间离散化直接相关。\n3.  **不完整/矛盾的设置**：提供了所有必要信息，且没有矛盾之处。\n4.  **不现实/不可行**：参数的选择是为了探索不同的刚性区域，这在数值分析的背景下是现实的。计算是可行的。\n5.  **不适定/结构不良**：计算观测阶的程序定义明确，并能得出唯一结果。\n6.  **伪深刻/琐碎**：该问题需要正确实现数值方法，并理解如何评估其经验性能，这是一项非琐碎的任务，展示了稳定性和收敛性的重要概念。\n7.  **超出科学可验证性**：结果是可通过计算验证的。\n\n#### **第三步：结论与行动**\n\n问题陈述是**有效的**。将提供一个解决方案。\n\n### **解决方案**\n\n该问题要求我们为三种数值方法——显式欧拉法、隐式欧拉法和 Heun 法——在求解线性测试 ODE $y'(t) = -\\lambda y(t)$（其中 $y(0) = y_0$）时计算观测精度阶。精确解为 $y(t) = y_0 \\exp(-\\lambda t)$。\n\n对于给定的方法，经过一个时间步长 $h$ 后的数值解可以写成 $y_{n+1} = g(h\\lambda) y_n$，其中 $g(z)$ 是方法的放大因子，$z=h\\lambda$。我们为每种方法推导 $g(z)$，其中 $f(t,y) = -\\lambda y$：\n\n1.  **显式欧拉法**：\n    $y_{n+1} = y_n + h(-\\lambda y_n) = (1 - h\\lambda) y_n$。\n    放大因子为 $g_{EE}(z) = 1 - z$。\n\n2.  **隐式欧拉法**：\n    $y_{n+1} = y_n + h(-\\lambda y_{n+1}) \\implies y_{n+1}(1+h\\lambda) = y_n \\implies y_{n+1} = \\frac{1}{1+h\\lambda} y_n$。\n    放大因子为 $g_{IE}(z) = \\frac{1}{1+z}$。\n\n3.  **Heun 法**：\n    $y_{n+1} = y_n + \\frac{h}{2} \\left( (-\\lambda y_n) + (-\\lambda(y_n + h(-\\lambda y_n))) \\right)$\n    $y_{n+1} = y_n + \\frac{h}{2} \\left( -\\lambda y_n - \\lambda y_n + h\\lambda^2 y_n \\right)$\n    $y_{n+1} = y_n \\left( 1 - h\\lambda + \\frac{h^2\\lambda^2}{2} \\right)$。\n    放大因子为 $g_{HM}(z) = 1 - z + \\frac{z^2}{2}$。\n\n经过 $N$ 步到达最终时间 $T=Nh$ 后，数值解为 $y_N = y_0 \\cdot [g(h\\lambda)]^N$。对于这个线性问题，这个闭式表达式比分步循环更高效且数值上更稳健。\n\n任务的核心是找到观测精度阶 $p$。对于一个 $p$ 阶方法，在固定的最终时间 $T$，全局误差 $E(h)$ 在步长 $h$ 足够小时表现为 $E(h) \\approx C h^p$。给定来自两个不同步长 $h_1$ 和 $h_2$ 的误差，我们有：\n$$ \\frac{E(h_1)}{E(h_2)} \\approx \\frac{C h_1^p}{C h_2^p} = \\left(\\frac{h_1}{h_2}\\right)^p $$\n解出 $p$ 得：\n$$ p \\approx \\frac{\\log(E(h_1)/E(h_2))}{\\log(h_1/h_2)} $$\n在我们的情况下，我们执行一系列的步长减半，所以 $h_1/h_2 = 2$。这简化为 $p \\approx \\log_2(E(h_1)/E(h_2))$。\n\n对于每个测试用例和方法，程序如下：\n1.  给定 $(\\lambda, T, h_0)$ 和 $y_0 = 1$，计算基础步数 $N_0 = \\operatorname{round}(T/h_0)$。\n2.  定义三个分辨率，步数分别为 $N_1 = N_0$，$N_2 = 2N_0$ 和 $N_3 = 4N_0$。\n3.  对于每个分辨率 $k \\in \\{1,2,3\\}$，计算步长 $h_k = T/N_k$ 和数值解 $y_{N_k}$。\n4.  计算每个分辨率的全局误差：$E_k = |y_{N_k} - y(T)|$，其中 $y(T) = y_0 \\exp(-\\lambda T)$。\n5.  计算两个精度阶的估计值：\n    $p_1 = \\log_2(E_1/E_2)$\n    $p_2 = \\log_2(E_2/E_3)$\n6.  最终的观测阶是这两个估计值的平均值：$p_{obs} = (p_1 + p_2)/2$。\n\n此过程将应用于所有十二个测试用例和方法的组合。参数集的设计旨在测试从非刚性到非常刚性区域的方法。对于刚性问题（大 $\\lambda$），如果步长 $h$ 太大（特别是如果 $h\\lambda > 2$），像前向欧拉法和 Heun 法这样的显式方法可能会变得不稳定。在这种不稳定情况下，误差会随着 $h$ 的减小而增大，导致观测到的精度阶为负。隐式欧拉法是 A-稳定的，对于任何 $h > 0$ 都保持稳定，能正确处理刚性方程，尽管其精度特性可能偏离经典的非刚性理论。计算将捕捉到这些行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed order of accuracy for three numerical methods\n    on the linear test ODE y' = -lambda*y across four different parameter sets.\n    \"\"\"\n\n    def compute_numerical_solution(method_name, lam, y0, T, N):\n        \"\"\"\n        Calculates the numerical solution y(T) using the amplification factor.\n        \n        Args:\n            method_name (str): Identifier for the method ('EE', 'IE', 'HM').\n            lam (float): The lambda parameter of the ODE.\n            y0 (float): Initial condition y(0).\n            T (float): Final time.\n            N (int): Number of time steps.\n        \n        Returns:\n            float: The numerical solution at time T.\n        \"\"\"\n        h = T / N\n        z = h * lam\n        \n        if method_name == 'EE': # Explicit Euler\n            # Amplification factor: g(z) = 1 - z\n            # Solution: y_N = y_0 * (1 - h*lam)^N\n            amp_factor = 1.0 - z\n        elif method_name == 'IE': # Implicit Euler\n            # Amplification factor: g(z) = 1 / (1 + z)\n            # Solution: y_N = y_0 * (1 + h*lam)^(-N)\n            amp_factor = 1.0 / (1.0 + z)\n        elif method_name == 'HM': # Heun's Method\n            # Amplification factor: g(z) = 1 - z + z^2/2\n            # Solution: y_N = y_0 * (1 - h*lam + 0.5*(h*lam)^2)^N\n            amp_factor = 1.0 - z + 0.5 * z**2\n        else:\n            raise ValueError(\"Unknown method name\")\n        \n        # Using the power of the amplification factor can be unstable for large N\n        # with negative bases. We must handle complex numbers that arise from\n        # negative bases in the amplification factor for explicit methods.\n        # The result of y_N should be real.\n        if isinstance(amp_factor, complex) or amp_factor  0:\n            # y_N = y_0 * (g)^N. If g is negative, result is y_0 * |g|^N * (-1)^N\n            # We take the real part, which is y_0 * g^N\n            return y0 * (amp_factor**N).real\n        else:\n            return y0 * amp_factor**N\n\n    def calculate_observed_order(method_name, lam, y0, T, h0):\n        \"\"\"\n        Calculates the observed order of accuracy for a given method and parameters.\n        \n        Args:\n            method_name (str): Identifier for the method ('EE', 'IE', 'HM').\n            lam (float): The lambda parameter of the ODE.\n            y0 (float): Initial condition y(0).\n            T (float): Final time.\n            h0 (float): Base step size parameter.\n        \n        Returns:\n            float: The observed order of accuracy.\n        \"\"\"\n        N0 = int(round(T / h0))\n        Ns = [N0, 2 * N0, 4 * N0]\n        \n        y_exact = y0 * np.exp(-lam * T)\n        \n        errors = []\n        for N in Ns:\n            if N == 0:\n                # Avoid division by zero if T/h0 rounds to 0. Not expected for given test cases.\n                errors.append(np.inf)\n                continue\n            y_num = compute_numerical_solution(method_name, lam, y0, T, N)\n            error = np.abs(y_num - y_exact)\n            errors.append(error)\n            \n        E1, E2, E3 = errors\n\n        # Handle cases where error is zero to avoid division by zero or log(0)\n        if E2 == 0 or E3 == 0:\n            # If error becomes 0, this implies very fast convergence or machine precision limit.\n            # The order is effectively infinite, but the problem's formula would break down.\n            # We return a large number or NaN as a sentinel. For this problem, it is not expected.\n            return np.nan\n\n        p1 = np.log2(E1 / E2)\n        p2 = np.log2(E2 / E3)\n        \n        p_obs = (p1 + p2) / 2.0\n        return p_obs\n\n    y0 = 1.0 # Initial condition y(0)=1 for all cases.\n\n    # Test cases: (lambda, T, h0)\n    test_cases = [\n        (1.0, 1.0, 0.2),      # Case A: nonstiff\n        (20.0, 1.0, 0.1),     # Case B: moderately stiff\n        (100.0, 1.0, 0.015),  # Case C: stiff but stable\n        (500.0, 0.1, 0.05),   # Case D: very stiff, unstable explicit\n    ]\n    \n    method_names = ['EE', 'IE', 'HM']\n    \n    results = []\n    for lam, T, h0 in test_cases:\n        for method_name in method_names:\n            order = calculate_observed_order(method_name, lam, y0, T, h0)\n            results.append(round(order, 6))\n\n    # Format the final output string as per the requirements\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了基本的数值属性之后，下一步是将这些方法应用于物理模型。环境模型通常处理必须保持物理合理性的量，例如非负的污染物浓度。本练习演示了标准显式时间格式如何可能导致非物理的负值，并指导您推导出保证非负性的时间步长限制或设计一个限制器策略，这些都是确保模型物理真实性的关键技术。",
            "id": "3859476",
            "problem": "使用单网格单元大气质量平衡模型来模拟一种化学反应性污染物的非负浓度 $y(t)$，该污染物的排放量由星载遥感观测推断得出。其时间演变遵循质量守恒定律：变化率等于源项减去汇项。具体来说，假设\n$$\\frac{dy}{dt} = e(t) - \\lambda\\, y(t),$$\n其中 $e(t) \\ge 0$ 代表从遥感反演得出的排放源项，$0  \\lambda$ 是一个恒定的一阶损失率，代表总的沉降和化学清除。时间推进采用单步显式方法，该方法在前一个时间层上计算右侧项，时间步长为 $\\Delta t_n  0$。已知在当前步，浓度为非负，$y_n \\ge 0$，且排放估算值满足 $e_n \\ge 0$。\n\n从守恒方程和导数的定义出发，推导出一个关于显式时间步长 $\\Delta t_n$ 的严格限制条件（用 $\\lambda$ 表示），该条件能保证更新过程中的正定性保持，即当 $y_n \\ge 0$ 和 $e_n \\ge 0$ 时，有 $y_{n+1} \\ge 0$。此外，对于一个通用的显式更新 $y_{n+1} = y_n + \\Delta t_n f(y_n)$，推导一个形式为 $y_{n+1}^{\\mathrm{lim}} = y_n + \\phi\\,\\Delta t_n\\,f(y_n)$ 的单行正定性保持限制器策略，该策略在 $y_n \\ge 0$ 时能确保 $y_{n+1}^{\\mathrm{lim}} \\ge 0$，而无需减小 $\\Delta t_n$。你必须证明该时间步长限制条件的严格性。\n\n最后，计算当 $\\lambda = 1.25 \\times 10^{-5}\\,\\mathrm{s}^{-1}$ 时的最大允许时间步长 $\\Delta t_{\\max}$。用秒表示你的最终数值答案，并四舍五入到四位有效数字。",
            "solution": "所述问题具有科学依据、是良定的且客观的。它提出了一个来自环境建模的标准质量平衡方程，并要求严格推导数值时间步进格式的正定性约束、构建一个正定性保持限制器，最后进行数值计算。所有提供的信息都是自洽且一致的。因此，该问题是有效的，我将开始解答。\n\n污染物浓度 $y(t)$ 的时间演变由以下线性一阶常微分方程给出：\n$$\n\\frac{dy}{dt} = e(t) - \\lambda y(t)\n$$\n约束条件为 $y(t) \\ge 0$，$e(t) \\ge 0$ 和 $\\lambda  0$。\n\n数值格式是一种单步显式方法，它在前一个时间层 $t_n$ 计算右侧项 $f(t, y) = e(t) - \\lambda y(t)$。这对应于前向欧拉法或显式欧拉法。离散更新规则为：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t_n} = e_n - \\lambda y_n\n$$\n其中 $y_n \\equiv y(t_n)$，$e_n \\equiv e(t_n)$，且 $\\Delta t_n = t_{n+1} - t_n  0$。对 $y_{n+1}$ 进行整理，我们得到：\n$$\ny_{n+1} = y_n + \\Delta t_n (e_n - \\lambda y_n)\n$$\n我们可以合并包含 $y_n$ 的项：\n$$\ny_{n+1} = y_n(1 - \\lambda \\Delta t_n) + e_n \\Delta t_n\n$$\n给定在当前步，浓度 $y_n \\ge 0$ 且排放项 $e_n \\ge 0$。时间步长 $\\Delta t_n$ 也是正的。因此，项 $e_n \\Delta t_n$ 总是非负的。\n\n**第一部分：时间步长限制的推导**\n\n为了保证正定性保持，我们必须确保对于任何有效输入（$y_n \\ge 0, e_n \\ge 0$），都有 $y_{n+1} \\ge 0$。由于 $e_n \\Delta t_n \\ge 0$，只要项 $y_n(1 - \\lambda \\Delta t_n)$ 也为非负，那么 $y_{n+1} \\ge 0$ 的条件就能得到保证。因为我们必须对任意 $y_n \\ge 0$ 都保证这一点，所以 $y_n$ 的系数必须为非负。\n$$\n1 - \\lambda \\Delta t_n \\ge 0\n$$\n解出 $\\Delta t_n$：\n$$\n1 \\ge \\lambda \\Delta t_n \\implies \\Delta t_n \\le \\frac{1}{\\lambda}\n$$\n这就是无条件保证 $y_{n+1} \\ge 0$ 所需的时间步长限制条件。\n\n为了证明该限制是严格的，我们必须表明如果违反该条件，则存在至少一组有效输入使得 $y_{n+1}  0$。让我们假设 $\\Delta t_n  1/\\lambda$。我们可以写成 $\\Delta t_n = (1+\\epsilon)/\\lambda$，其中 $\\epsilon  0$ 是某个小的正数。将此代入更新方程：\n$$\ny_{n+1} = y_n\\left(1 - \\lambda \\frac{1+\\epsilon}{\\lambda}\\right) + e_n \\Delta t_n = y_n(1 - (1+\\epsilon)) + e_n \\Delta t_n = - \\epsilon y_n + e_n \\Delta t_n\n$$\n现在，考虑一个物理上可能的情景，即没有排放（$e_n = 0$）且初始浓度非零（$y_n  0$）。在这种情况下，$y_{n+1}$ 的方程简化为：\n$$\ny_{n+1} = - \\epsilon y_n\n$$\n由于 $\\epsilon  0$ 且 $y_n  0$，显然 $y_{n+1}  0$。这违反了浓度非负的物理要求。因此，条件 $\\Delta t_n \\le 1/\\lambda$ 不仅是充分的，而且是保证在所有可能的有效条件下都具有正定性的必要条件，从而确立了其严格性。\n\n**第二部分：正定性保持限制器策略的推导**\n\n题目要求我们为通用显式更新 $y_{n+1} = y_n + \\Delta t_n f(y_n)$ 推导一个限制器，当 $y_n \\ge 0$ 时，该限制器能强制 $y_{n+1}^{\\mathrm{lim}} \\ge 0$。该限制器必须具有形式 $y_{n+1}^{\\mathrm{lim}} = y_n + \\phi\\,\\Delta t_n\\,f(y_n)$。\n\n目标是找到一个缩放因子 $\\phi$，它能修改更新步 $\\Delta y_n = \\Delta t_n f(y_n)$ 以防止 $y_{n+1}$ 变为负数。我们要求 $y_{n+1}^{\\mathrm{lim}} \\ge 0$，这意味着：\n$$\ny_n + \\phi \\Delta t_n f(y_n) \\ge 0\n$$\n我们根据趋势项 $f(y_n)$ 的符号分两种情况进行分析：\n\n情况1：$f(y_n) \\ge 0$。\n浓度是非递减的。由于 $y_n \\ge 0$ 且 $\\Delta t_n  0$，未经限制的更新 $y_{n+1} = y_n + \\Delta t_n f(y_n)$ 将总是大于或等于 $y_n$，因此保持非负。无需进行限制。为了保持原始格式的精度，我们不应改变更新。这可以通过设置 $\\phi = 1$ 来实现。\n\n情况2：$f(y_n)  0$。\n浓度是递减的，如果时间步长过大，$y_{n+1}$ 可能会变为负数。我们必须强制 $y_n + \\phi \\Delta t_n f(y_n) \\ge 0$。对 $\\phi$ 进行整理：\n$$\n\\phi \\Delta t_n f(y_n) \\ge -y_n\n$$\n由于 $\\Delta t_n  0$ 且 $f(y_n)  0$，项 $\\Delta t_n f(y_n)$ 是负的。除以这个负量会使不等号反向：\n$$\n\\phi \\le \\frac{-y_n}{\\Delta t_n f(y_n)}\n$$\n让我们定义比率 $r = \\frac{-y_n}{\\Delta t_n f(y_n)}$。注意，由于 $y_n \\ge 0$ 且分母为负，所以 $r \\ge 0$。正定性条件是 $\\phi \\le r$。为了尽可能接近原始的、未限制的格式（其中 $\\phi = 1$），我们应该选择满足此约束的 $\\phi$ 的最大可能值。\n\n如果 $r \\ge 1$，这意味着 $\\frac{-y_n}{\\Delta t_n f(y_n)} \\ge 1$，这等价于 $-y_n \\ge \\Delta t_n f(y_n)$ 或 $y_n + \\Delta t_n f(y_n) \\ge 0$。未经限制的步长已经能保持正定性。在这种情况下，我们可以选择 $\\phi = 1$，这满足 $\\phi \\le r$。\n\n如果 $0 \\le r  1$，未经限制的步长将导致负浓度。为了在保证正定性的同时对更新做尽可能小的修改，我们必须选择 $\\phi$ 的最大允许值，即 $\\phi = r$。这个选择导致 $y_{n+1}^{\\mathrm{lim}} = y_n + r (\\Delta t_n f(y_n)) = y_n + \\frac{-y_n}{\\Delta t_n f(y_n)} (\\Delta t_n f(y_n)) = y_n - y_n = 0$。\n\n结合这些 $f(y_n)  0$ 的子情况，尽可能保持精度的最优选择是 $\\phi = \\min(1, r)$。\n\n因此，完整的“单行”正定性保持限制器策略是 $y_{n+1}^{\\mathrm{lim}} = y_n + \\phi\\,\\Delta t_n\\,f(y_n)$，其中因子 $\\phi$ 定义如下：\n$$\n\\phi = \\begin{cases} 1  \\text{如果 } f(y_n) \\ge 0 \\\\ \\min\\left(1, \\frac{-y_n}{\\Delta t_n f(y_n)}\\right)  \\text{如果 } f(y_n)  0 \\end{cases}\n$$\n这个策略能确保对于任何时间步长 $\\Delta t_n  0$ 都有 $y_{n+1}^{\\mathrm{lim}} \\ge 0$，而无需减小时间步长。\n\n**第三部分：数值计算**\n\n最后，题目要求我们计算在没有限制器的情况下保证正定性的最大允许时间步长 $\\Delta t_{\\max}$。从第一部分可知，这由以下严格界限给出：\n$$\n\\Delta t_{\\max} = \\frac{1}{\\lambda}\n$$\n给定损失率常数 $\\lambda = 1.25 \\times 10^{-5}\\,\\mathrm{s}^{-1}$：\n$$\n\\Delta t_{\\max} = \\frac{1}{1.25 \\times 10^{-5}\\,\\mathrm{s}^{-1}} = \\frac{1}{1.25} \\times 10^5\\,\\mathrm{s}\n$$\n因为 $1.25 = 5/4$，我们有 $1/1.25 = 4/5 = 0.8$。\n$$\n\\Delta t_{\\max} = 0.8 \\times 10^5\\,\\mathrm{s} = 80000\\,\\mathrm{s}\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\Delta t_{\\max} = 8.000 \\times 10^4\\,\\mathrm{s}\n$$",
            "answer": "$$\\boxed{8.000 \\times 10^4}$$"
        },
        {
            "introduction": "许多环境现象，从日温变化到季节性植被周期，都具有振荡性。准确模拟这些周期的时机（相位）与模拟其振幅同样重要。本练习着重于量化一个典型振荡系统的数值相位误差，并探索如何选择时间步长以满足特定的相位精度要求，这对于由周期性遥感数据驱动或与之比较的模型至关重要。",
            "id": "3859494",
            "problem": "考虑一个典型的线性振荡初值问题，它模拟了环境变量中的季节性周期：$u'(t) = i \\, \\omega \\, u(t)$，其精确解为 $u(t) = u(0)\\, e^{i \\omega t}$，其中 $i$ 是虚数单位，$\\omega = 2\\pi/P$ 是角频率，$P$ 是以天为单位的周期。一个步长为 $\\Delta t$ 的均匀时间步进方法被应用于该系统，以随时间推进其状态。对于固定的整数阶 $p \\ge 1$，考虑 $p$ 阶泰勒方法，其定义为截断指数级数，使得大小为 $\\Delta t$ 的一个步骤通过在 $z = i\\, \\omega\\, \\Delta t$ 处求值的线性因子 $R(z) = \\sum_{k=0}^{p} \\frac{z^k}{k!}$ 将 $u_{n}$ 映射到 $u_{n+1}$。精确的单步因子是 $E(z) = e^{z}$。\n\n将每步的数值相位定义为 $\\theta_{\\mathrm{num}}(\\Delta t) = \\arg\\left(R(i\\, \\omega\\, \\Delta t)\\right)$，其中 $\\arg(\\cdot)$ 表示区间 $(-\\pi, \\pi]$ 内以弧度为单位的主辐角。每步的精确相位是 $\\theta_{\\mathrm{ex}}(\\Delta t) = \\omega\\, \\Delta t$。在一个完整周期 $P$ 内，假设积分使用整数个 $N$ 个均匀步骤，即 $\\Delta t = P/N$。$N$ 步后的累积数值相位是 $N\\, \\theta_{\\mathrm{num}}(\\Delta t)$，而精确的累积相位是 $2\\pi$。一个周期内的相位误差定义为缠绕差\n$$\n\\varepsilon(N; p, P) \\equiv \\mathrm{wrap}\\Big(N\\, \\theta_{\\mathrm{num}}(P/N) - 2\\pi\\Big),\n$$\n其中缠绕算子 $\\mathrm{wrap}(\\alpha)$ 返回在 $(-\\pi, \\pi]$ 区间内与 $\\alpha$ 模 $2\\pi$ 同余的唯一值。等效地，可以定义\n$$\n\\mathrm{wrap}(\\alpha) = \\alpha - 2\\pi \\cdot \\mathrm{round}\\!\\left(\\frac{\\alpha}{2\\pi}\\right)\n$$\n其中 round 是四舍五入到最近的整数，若平分则取偶数。那么每个周期的绝对相位误差为 $|\\varepsilon(N; p, P)|$。\n\n您的任务是设计一个程序，为下面指定的每个测试用例，选择满足一个周期 $P$ 内目标相位精度要求的最大容许时间步长 $\\Delta t$（以天为单位）。具体来说，对于给定的方法阶数 $p$、周期 $P$（以天为单位）和目标界限 $\\delta$（以弧度为单位），找到满足\n$$\n|\\varepsilon(N; p, P)| \\le \\delta,\n$$\n的最小正整数 $N$，然后报告相应的最大 $\\Delta t = P/N$（以天为单位）。如果 $N=1$ 已经满足不等式，则 $\\Delta t = P$ 天是容许的，并应被报告。您必须假设使用 $p$ 阶泰勒方法，并且每步的数值相位是使用如上所述的 $R(i\\, \\omega\\, \\Delta t)$ 的主辐角计算的。角度必须以弧度为单位。时间步长输出必须以天为单位表示。\n\n科学和数值要求：\n- 您的推理必须基于微分方程 $u'(t) = i \\omega u(t)$ 的基本性质、其精确解 $e^{i \\omega t}$，以及通过截断指数级数定义的 $p$ 阶泰勒方法。\n- 在检查目标精度界限时，您必须使用如上定义的单个周期内的缠绕相位误差。\n- 因为步数 $N$ 必须是整数，所以您必须在整数 $N$ 上进行搜索，并为满足界限的最小 $N$ 返回 $\\Delta t = P/N$，这对应于最大的容许 $\\Delta t$。\n\n测试套件：\n- 用例1：$p = 4$，$P = 365$ 天，$\\delta = 0.01$ 弧度。\n- 用例2：$p = 2$，$P = 365$ 天，$\\delta = 0.01$ 弧度。\n- 用例3：$p = 4$，$P = 30$ 天，$\\delta = 0.005$ 弧度。\n- 用例4：$p = 4$，$P = 365$ 天，$\\delta = 10^{-6}$ 弧度。\n\n您的程序应生成单行输出，其中包含四个容许时间步长 $\\Delta t$（以天为单位）的结果，以逗号分隔的列表形式，每个值四舍五入到六位小数，并用方括号括起来（例如，“[365.000000,12.000000, ... ]”）。不应打印任何其他文本。所有角度必须以弧度为单位，所有时间步长必须以天为单位报告。",
            "solution": "该问题要求我们确定将 $p$ 阶泰勒级数方法应用于模型振荡问题 $u'(t) = i \\omega u(t)$ 时，在一个周期 $P$ 内满足特定相位精度要求的最大容许时间步长 $\\Delta t$。最大的时间步长对应于满足精度约束的最小正整数步数 $N$。\n\n我们的第一步是形式化相位误差的表达式。角频率为 $\\omega = 2\\pi/P$。数值积分使用 $N$ 个大小为 $\\Delta t = P/N$ 的均匀时间步来覆盖一个周期。该方法的稳定性函数的关键宗量 $z$ 由以下公式给出：\n$$\nz = i \\omega \\Delta t = i \\left(\\frac{2\\pi}{P}\\right) \\left(\\frac{P}{N}\\right) = \\frac{2\\pi i}{N}\n$$\n这一简化意义重大：它表明复宗量 $z$ 仅取决于每个周期的步数 $N$，而不取决于周期 $P$ 本身。\n\n$p$ 阶泰勒方法通过一个因子 $R(z)$ 来推进解，其中 $R(z)$ 是由截断的指数级数定义的稳定性函数：\n$$\nR(z) = \\sum_{k=0}^{p} \\frac{z^k}{k!}\n$$\n对于给定的 $N$ 和 $p$，我们在 $z = 2\\pi i/N$ 处计算这个复值多项式。\n\n单步累积的数值相位是此因子的主辐角，$\\theta_{\\mathrm{num}} = \\arg(R(2\\pi i/N))$，其中辐角函数映射到区间 $(-\\pi, \\pi]$。在一个完整周期内，模拟进行 $N$ 个这样的步骤，因此总数值相位为 $N \\theta_{\\mathrm{num}}$。精确解 $u(t) = u(0)e^{i\\omega t}$ 在一个周期内累积的相位为 $\\omega P = (2\\pi/P)P = 2\\pi$。\n\n一个周期内的相位误差被定义为累积数值相位与精确相位之间的缠绕差：\n$$\n\\varepsilon(N; p) \\equiv \\mathrm{wrap}\\Big(N \\theta_{\\mathrm{num}}(P/N) - 2\\pi\\Big)\n$$\n注意，由于 $\\theta_{\\mathrm{num}}$ 的计算仅取决于 $N$，因此误差 $\\varepsilon$ 实际上只是 $N$ 和 $p$ 的函数，与 $P$ 无关。缠绕函数 $\\mathrm{wrap}(\\alpha) = \\alpha - 2\\pi \\cdot \\mathrm{round}(\\alpha/(2\\pi))$ 确保报告的误差在区间 $(-\\pi, \\pi]$ 内。\n\n任务的核心是找到最小的正整数 $N$，使其绝对相位误差满足给定的容差 $\\delta$：\n$$\n|\\varepsilon(N; p)| \\le \\delta\n$$\n对于应用于此问题的稳定显式时间步进方法（如泰勒级数方法），数值误差（包括相位误差）通常随着步数 $N$ 的增加（从而 $\\Delta t$ 减小）而减小。这种单调行为允许我们采用一种直接的算法方法：我们可以对满足标准的最小整数 $N$ 进行线性搜索。\n\n对于每个测试用例 $(p, P, \\delta)$，算法流程如下：\n1. 初始化步数 $N=1$。\n2. 进入一个循环，只要误差标准未满足就继续。\n3. 在循环内部，对于当前的 $N$ 值，执行以下子步骤：\n    a. 计算宗量 $z = 2\\pi i / N$。\n    b. 计算稳定性函数 $R(z) = \\sum_{k=0}^{p} z^k/k!$ 的复数值。为保证数值稳定性和效率，此和式通过迭代计算，其中第 $k$ 项由第 $k-1$ 项乘以 $z/k$ 得到。\n    c. 确定每步的数值相位 $\\theta_{\\mathrm{num}} = \\arg(R(z))$。\n    d. 计算绝对缠绕相位误差 $|\\varepsilon(N; p)| = |\\mathrm{wrap}(N\\theta_{\\mathrm{num}} - 2\\pi)|$。\n4. 检查是否满足 $|\\varepsilon(N; p)| \\le \\delta$。\n    a. 如果满足条件，则已找到最小整数 $N$。循环终止。\n    b. 如果不满足条件，则将 $N$ 增加 1 并重复该过程。\n5. 一旦确定了最小的 $N$，就计算相应的最大容许时间步长 $\\Delta t = P/N$。该值即为该测试用例的结果。\n\n将此过程应用于所提供的四个测试用例中的每一个，并报告所得的 $\\Delta t$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the largest admissible time step for the Taylor method\n    applied to u'(t) = i*omega*u(t) based on a phase error criterion.\n    \"\"\"\n\n    def calculate_abs_phase_error(N, p):\n        \"\"\"\n        Calculates the absolute wrapped cumulative phase error over one period.\n\n        Args:\n            N (int): Number of time steps per period.\n            p (int): Order of the Taylor method.\n\n        Returns:\n            float: The absolute wrapped phase error in radians.\n        \"\"\"\n        # The argument for the stability function, z, simplifies to i*2*pi/N.\n        alpha = 2.0 * np.pi / N\n        z = 1j * alpha\n\n        # Iteratively calculate R(z) = sum_{k=0 to p} z^k / k!\n        # This is more numerically stable and efficient than direct computation.\n        # R_z corresponds to the stability function R(z).\n        # Term_k = z^k / k!, so Term_k = Term_{k-1} * z / k.\n        R_z = 1.0 + 0.0j  # Term for k=0\n        term = 1.0 + 0.0j\n        if p > 0:\n            for k in range(1, p + 1):\n                term = term * z / k\n                R_z += term\n\n        # Numerical phase per step, using the principal argument.\n        # np.angle returns values in (-pi, pi].\n        theta_num = np.angle(R_z)\n\n        # Cumulative raw phase error over one period (N steps).\n        # The exact cumulative phase is 2*pi.\n        raw_error = N * theta_num - 2.0 * np.pi\n\n        # Apply the wrapping function as defined in the problem:\n        # wrap(alpha) = alpha - 2*pi * round(alpha / (2*pi)),\n        # where round is to nearest integer, ties to even.\n        # np.round implements this rounding behavior.\n        wrapped_error = raw_error - 2.0 * np.pi * np.round(raw_error / (2.0 * np.pi))\n\n        return np.abs(wrapped_error)\n\n    def find_min_N(p, delta):\n        \"\"\"\n        Finds the minimal positive integer N that satisfies the error bound.\n\n        Args:\n            p (int): Order of the Taylor method.\n            delta (float): The target phase error bound in radians.\n\n        Returns:\n            int: The minimal number of steps N.\n        \"\"\"\n        N = 1\n        while True:\n            # The phase error generally decreases as N increases.\n            # A linear search starting from N=1 is guaranteed to find the minimum.\n            error = calculate_abs_phase_error(N, p)\n            if error = delta:\n                return N\n            N += 1\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (order p, period P, error bound delta)\n    test_cases = [\n        (4, 365.0, 0.01),\n        (2, 365.0, 0.01),\n        (4, 30.0, 0.005),\n        (4, 365.0, 1e-6),\n    ]\n\n    results = []\n    for p, P, delta in test_cases:\n        # For each case, find the minimal N satisfying the criterion.\n        min_N = find_min_N(p, delta)\n        # The corresponding maximal time step is P / N.\n        max_dt = P / min_N\n        results.append(max_dt)\n\n    # Format the final results as a comma-separated list of strings,\n    # with each float rounded to six decimal places, enclosed in brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}