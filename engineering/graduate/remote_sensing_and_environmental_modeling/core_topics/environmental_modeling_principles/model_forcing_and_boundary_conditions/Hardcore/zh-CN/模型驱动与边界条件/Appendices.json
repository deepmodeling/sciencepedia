{
    "hands_on_practices": [
        {
            "introduction": "在数值上实现边界条件之前，理解其所代表的物理原理至关重要。本练习使用线性平流方程 $u_t + c u_x = 0$，一个基本的双曲型偏微分方程，来探讨信息如何沿特征曲线传播。你将推导流入边界的适当边界条件，并解释为何流出边界不需要任何条件，从而巩固你对双曲系统如何由输入信息驱动的理解。",
            "id": "3828052",
            "problem": "一个一维被动示踪场 $u(x,t)$ 沿着长度为 $L$ 的直线海岸段演变，其过程由线性平流方程 $u_t + c\\,u_x = 0$ 在时空域 $x \\in [0,L]$，$t \\ge 0$ 上建模。恒定的沿岸流速 $c$ 可通过现场流速计得知，一个卫星导出的时间序列在该岸段的上游端提供了边界强迫。在用于环境建模和遥感数据同化的双曲型偏微分方程的背景下，模型强迫是通过适当的特征变量在边界上施加的，对于标量平流方程，这些特征变量与黎曼不变量（Riemann invariant(s)）重合。\n\n从守恒律形式和基本定义出发，通过识别和指定传入的黎曼不变量，推导在流入边界处应施加的正确边界条件。使用特征结构和依赖域，论证为何在流出边界处不需要边界条件。\n\n然后，考虑具体情况：$L = 3000\\ \\mathrm{m}$，$c = 1.5\\ \\mathrm{m\\,s^{-1}}$，初始条件为 $u(x,0) = \\exp\\!\\big(-\\frac{(x-600\\ \\mathrm{m})^2}{2\\,(150\\ \\mathrm{m})^2}\\big)$，其中 $x \\in [0,L]$；流入边界 $x=0$ 处的边界强迫为 $u(0,t) = 2\\cos\\!\\big(\\frac{\\pi}{400}\\,t\\big)$，其中 $t \\ge 0$。将 $u$ 视为无量纲。计算 $u$ 在查询点 $(x^\\ast,t^\\ast) = (1800\\ \\mathrm{m}, 2000\\ \\mathrm{s})$ 的值。\n\n以无单位的纯数形式给出 $u(x^\\ast,t^\\ast)$ 的最终值。如果需要近似，请四舍五入到四位有效数字。",
            "solution": "问题陈述具有科学依据、适定且客观。它描述了一个一维线性平流方程的标准初边值问题，这是输运现象中的一个基本模型。所有参数和函数都定义清晰且一致。因此，我们可以进行完整的求解。\n\n该问题分为两部分：一个关于双曲型方程边界条件的通用理论推导，以及一个基于给定数据的具体计算。\n\n**第一部分：边界条件和特征线的一般理论**\n\n控制被动示踪剂浓度 $u(x,t)$ 的偏微分方程（PDE）是线性平流方程：\n$$u_t + c\\,u_x = 0$$\n其中 $u_t = \\frac{\\partial u}{\\partial t}$，$u_x = \\frac{\\partial u}{\\partial x}$。这是一个一阶双曲型偏微分方程。此类方程的行为由信息沿特征线的传播所控制。\n\n特征线是 $(x,t)$ 平面中的一条路径，在该路径上，偏微分方程可以简化为常微分方程（ODE）。如果我们用 $s$ 将一条曲线参数化为 $(x(s), t(s))$，那么 $u$ 沿此曲线的全导数为：\n$$\\frac{du}{ds} = \\frac{\\partial u}{\\partial t}\\frac{dt}{ds} + \\frac{\\partial u}{\\partial x}\\frac{dx}{ds}$$\n将此与偏微分方程进行比较，我们可以选择特征方程为：\n$$\\frac{dt}{ds} = 1, \\quad \\frac{dx}{ds} = c, \\quad \\frac{du}{ds} = 0$$\n从前两个方程，我们得到 $(x,t)$ 平面中特征线的斜率：\n$$\\frac{dx}{dt} = c$$\n由于 $c$ 是常数，这些曲线是直线。积分此方程可得：\n$$x - ct = k$$\n其中 $k$ 是标记每条独立特征线的常数。第三个特征方程 $\\frac{du}{ds} = 0$ 意味着解 $u$ 沿着这些特征线是常数。因此，由 $u$ 的值所代表的信息，就是沿着这些线传播的。\n\n对于双曲型系统，黎曼不变量是沿特征线保持不变的量。对于标量平流方程，解 $u$ 本身是唯一的黎曼不变量。\n\n边界条件的设定取决于信息相对于区域边界的传播方向。问题陈述中 $c$ 是一个正常数，代表沿岸流。因此我们可以不失一般性地假设 $c > 0$。这意味着特征线 $x = ct + k$ 在 $(t,x)$ 平面中具有正斜率（或在 $(x,t)$ 平面中斜率为 $1/c$），表明信息在 $x$ 增大的方向上传播。\n\n考虑空间域 $x \\in [0,L]$。\n1.  **流入边界 ($x=0$):** 在此边界处，特征线 $x = c(t-t_0)$（起始于 $(0, t_0)$）进入区域。沿任何这样一条特征线的 $u$ 值由其进入区域那一点的值所决定。为了求解区域内的问题，必须在该边界上为所有 $t > 0$ 指定 $u$ 的值。这在物理上等同于知道被水流带入区域的示踪剂浓度。因此，需要一个形如 $u(0,t) = g(t)$ 的边界条件。规定 $u(0,t)$ 的这一行为，正是在流入边界处规定传入的黎曼不变量（$u$）。\n\n2.  **流出边界 ($x=L$):** 在此边界处，特征线离开区域。区域内部任意点 $(x,t)$ 的依赖域仅包含其特征线起源的那个边界点。对于 $c>0$，这个起源点总是在一个位置 $x_0 \\le x$ 和时间 $t_0 \\le t$。具体来说，通过任意点 $(x,t)$ 的特征线可以追溯到初始线（$t=0$ 处的一点 $x_0 = x - ct > 0$）或流入边界（$x=0$ 处的一个时间 $t_0 = t - x/c > 0$）。在这两种情况下，依赖域都不包含 $x=L$ 处的流出边界。流出边界处的 $u$ 值是由从区域内部传播过来的值决定的。在 $x=L$ 处施加一个条件，将是试图指定一个已经被确定的值，这通常会过度约束系统，导致解不存在或不连续。因此，在流出边界处不需要也不允许施加边界条件。\n\n**第二部分：具体计算**\n\n我们有以下具体情况：\n-   岸段长度：$L = 3000 \\ \\mathrm{m}$\n-   流速：$c = 1.5 \\ \\mathrm{m\\,s^{-1}}$\n-   初始条件：$u(x,0) = \\exp\\left(-\\frac{(x-600)^2}{2 \\cdot 150^2}\\right)$，其中 $x \\in [0, 3000]$\n-   流入边界 ($x=0$) 处的边界条件：$u(0,t) = 2\\cos\\left(\\frac{\\pi}{400}t\\right)$，其中 $t \\ge 0$\n-   查询点：$(x^\\ast, t^\\ast) = (1800 \\ \\mathrm{m}, 2000 \\ \\mathrm{s})$\n\n我们需要找到 $u(x^\\ast, t^\\ast)$ 的值。如前所述， $u$ 的值沿着通过点 $(x^\\ast, t^\\ast)$ 的特征线是恒定的。该特征线的方程为 $x - ct = k$，其中常数 $k$ 由查询点确定：\n$$k = x^\\ast - c t^\\ast = 1800 - (1.5)(2000) = 1800 - 3000 = -1200$$\n所以，特征线是 $x - 1.5t = -1200$。\n\n为了找到这条线上的 $u$ 值，我们必须将其追溯到它在解域边界（即 $t=0$ 或 $x=0$ 的地方）的起源点。\n-   与初始线 ($t=0$) 的交点：\n    $$x - 1.5(0) = -1200 \\implies x = -1200 \\ \\mathrm{m}$$\n    该点位于空间域 $x \\in [0, 3000]$ 之外，因此查询点的值不是由初始条件决定的。\n\n-   与流入边界 ($x=0$) 的交点：\n    $$0 - 1.5t = -1200 \\implies 1.5t = 1200 \\implies t = \\frac{1200}{1.5} = 800 \\ \\mathrm{s}$$\n    交点是 $(0, 800)$。该点位于指定了边界条件的流入边界上。\n\n由于 $u$ 的值沿特征线守恒，查询点 $(1800, 2000)$ 的值必须与边界点 $(0, 800)$ 的值相同。\n$$u(1800, 2000) = u(0, 800)$$\n我们使用给定的边界强迫函数 $u(0,t) = 2\\cos\\left(\\frac{\\pi}{400}t\\right)$ 并计算其在 $t = 800$ 处的值：\n$$u(0, 800) = 2\\cos\\left(\\frac{\\pi}{400} \\cdot 800\\right) = 2\\cos(2\\pi)$$\n$2\\pi$ 的余弦值为 $1$。因此：\n$$u(1800, 2000) = 2 \\times 1 = 2$$\n在指定的点和时间，示踪场的值精确为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "从理论转向数值实践，本练习专注于使用有限差分法为抛物型扩散方程 $u_t = D u_{xx}$ 实现边界条件。你将使用“幽灵单元”技术，这是一种处理狄利克雷（Dirichlet）和诺伊曼（Neumann）条件的通用方法。本练习还介绍了“人造解法”（Method of Manufactured Solutions），这是一个用于验证代码准确性的强大工具。",
            "id": "3828127",
            "problem": "考虑一维热方程（一种线性抛物型偏微分方程 (PDE)），其定义域为 $[0,L]$，扩散系数 $D$ 为常数，方程为 $u_t = D\\,u_{xx}$。在环境建模中，边界条件代表了在域边界上的模型强迫（例如，对于 Dirichlet 条件，是来自遥感的表面温度；对于 Neumann 条件，是来自能量平衡的表面通量）。您必须实现 $u_{xx}$ 的二阶有限差分 (FD) 空间离散化，并使用虚拟单元来施加边界条件。然后，使用一个构造的光滑、无量纲的解析解 $u(x)$，推导并验证边界节点上的截断误差。\n\n您将使用由网格节点 $i$ 上的标准二阶中心差分定义的半离散空间算子（离散拉普拉斯算子）：\n$$\n\\mathcal{L}_h[u]_i \\equiv \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\n网格为均匀网格 $x_i = i\\,\\Delta x$，$i=0,1,\\dots,N$，且 $\\Delta x = L/N$。对于边界处理，使用位于 $i=-1$ 和 $i=N+1$ 的虚拟单元来编码边界条件。\n\n使用虚拟单元的边界条件实现：\n- 在 $x=0$ 处的 Dirichlet 条件：$u(0,t) = g_L(t)$。为在内部节点计算 $\\mathcal{L}_h$，使用精确的边界值 $u_0 = g_L(t)$；在 $i=1$ 处计算 $\\mathcal{L}_h$ 时不需要虚拟单元。类似地，在 $x=L$ 处的 Dirichlet 条件：$u(L,t) = g_R(t)$ 意味着 $u_N = g_R(t)$；在 $i=N-1$ 处计算 $\\mathcal{L}_h$ 时不需要虚拟单元。\n- 在 $x=0$ 处的 Neumann 条件：$u_x(0,t) = q_L(t)$。使用左侧虚拟单元，通过二阶中心差分来施加此条件：\n$$\n\\frac{u_1 - u_{-1}}{2\\,\\Delta x} = q_L(t) \\quad \\Rightarrow \\quad u_{-1} = u_1 - 2\\,\\Delta x\\,q_L(t).\n$$\n使用这个 $u_{-1}$ 来计算边界节点 $i=0$ 处的 $\\mathcal{L}_h$。\n- 在 $x=L$ 处的 Neumann 条件：$u_x(L,t) = q_R(t)$。使用右侧虚拟单元来施加此条件：\n$$\n\\frac{u_{N+1} - u_{N-1}}{2\\,\\Delta x} = q_R(t) \\quad \\Rightarrow \\quad u_{N+1} = u_{N-1} + 2\\,\\Delta x\\,q_R(t).\n$$\n使用这个 $u_{N+1}$ 来计算边界节点 $i=N$ 处的 $\\mathcal{L}_h$。\n\n用于验证的构造解析解（无量纲）：\n$$\nu(x) = e^{x} + \\sin(2x), \\quad u_x(x) = e^{x} + 2\\cos(2x), \\quad u_{xx}(x) = e^{x} - 4\\sin(2x).\n$$\n这一致地定义了边界强迫：对于 Dirichlet 条件，$g_L(t) = u(0)$ 或 $g_R(t) = u(L)$；对于 Neumann 条件，$q_L(t) = u_x(0)$ 或 $q_R(t) = u_x(L)$。\n\n目标：对于每种指定的边界情景，通过将精确解 $u(x)$ 代入离散算子来计算指定边界相关节点的局部截断误差：\n$$\n\\text{TE}(x_i; \\Delta x) \\equiv \\mathcal{L}_h[u]_i - u_{xx}(x_i).\n$$\n您将通过计算比率来凭经验验证收敛阶：\n$$\nR \\equiv \\frac{\\big|\\text{TE}(x_i; \\Delta x)\\big|}{\\big|\\text{TE}(x_i; \\Delta x/2)\\big|}.\n$$\n对于二阶精确的截断误差，$R$ 应趋近于 $4$；对于一阶精确的截断误差，$R$ 应趋近于 $2$。\n\n单位：在此验证任务中，所有量都是无量纲的。正弦和余弦函数中的角度以弧度为单位。\n\n测试套件规范（每个测试用例返回一个浮点数 $R$）：\n- 测试用例 $1$ (Dirichlet-left, Dirichlet-right)：$L = 1$，$N_{\\text{coarse}} = 20$，$N_{\\text{fine}} = 40$。在左边界相邻节点 $i=1$ 处计算 $\\text{TE}$。\n- 测试用例 $2$ (Neumann-left, Dirichlet-right)：$L = 1$，$N_{\\text{coarse}} = 20$，$N_{\\text{fine}} = 40$。使用由 $q_L$ 构成的虚拟单元 $u_{-1}$，在左边界节点 $i=0$ 处计算 $\\text{TE}$。\n- 测试用例 $3$ (Dirichlet-left, Neumann-right)：$L = 1$，$N_{\\text{coarse}} = 20$，$N_{\\text{fine}} = 40$。使用由 $q_R$ 构成的虚拟单元 $u_{N+1}$，在右边界节点 $i=N$ 处计算 $\\text{TE}$。\n\n您的程序必须：\n- 实现上述离散算子和虚拟单元边界条件。\n- 对于每个测试用例，计算所定义的比率 $R$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[r1,r2,r3]”）。\n\n不允许外部输入；请对上述参数进行硬编码。最终输出必须是数值浮点数。",
            "solution": "用户提供了一个来自数值分析领域的有效、适定的问题陈述，具体涉及偏微分方程有限差分格式的验证。\n\n目标是确定拉普拉斯算子 ($u_{xx}$) 的二阶中心差分近似在一维域的边界处及附近的精度阶。这是通过为已知解析函数计算局部截断误差 (TE) 来实现的，即人工解方法。然后通过计算在相继加密的网格上的截断误差之比来凭经验验证收敛阶。\n\n给定的构造解析解及其导数为：\n$$\nu(x) = e^{x} + \\sin(2x)\n$$\n$$\nu_x(x) = e^{x} + 2\\cos(2x)\n$$\n$$\nu_{xx}(x) = e^{x} - 4\\sin(2x)\n$$\n在网格节点 $x_i = i\\Delta x$ 处的离散拉普拉斯算子为：\n$$\n\\mathcal{L}_h[u]_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}\n$$\n局部截断误差定义为将精确解代入有限差分格式时产生的余项：\n$$\n\\text{TE}(x_i; \\Delta x) = \\mathcal{L}_h[u(x)]_i - u_{xx}(x_i)\n$$\n用于验证收敛阶 $p$（其中 $\\text{TE} \\propto (\\Delta x)^p$）的比率 $R$ 为：\n$$\nR = \\frac{|\\text{TE}(x_i; \\Delta x)|}{|\\text{TE}(x_i; \\Delta x/2)|} \\approx \\frac{|C(\\Delta x)^p|}{|C(\\Delta x/2)^p|} = 2^p\n$$\n对于一阶精确方法 ($p=1$)，我们预期 $R \\approx 2$。对于二阶精确方法 ($p=2$)，我们预期 $R \\approx 4$。\n\n我们现在将分析每个测试用例。\n\n**测试用例 1：Dirichlet-Dirichlet 边界条件，在内部节点 $i=1$ 处求值。**\n截断误差在节点 $x_1 = \\Delta x$ 处计算，该节点与左边界 $x_0=0$ 相邻。离散算子为：\n$$\n\\mathcal{L}_h[u]_1 = \\frac{u_2 - 2u_1 + u_0}{\\Delta x^2}\n$$\n由于这是一个使用解析解的验证练习，我们在网格点上使用精确的函数值：$u_j = u(x_j)$。通过使用 $u_0 = u(x_0)$，在 $x_0=0$ 处的 Dirichlet 条件被隐式满足。\n为求截断误差，我们将 $u(x_2) = u(x_1 + \\Delta x)$ 和 $u(x_0) = u(x_1 - \\Delta x)$ 在点 $x_1$ 附近进行泰勒级数展开：\n$$\nu(x_1 \\pm \\Delta x) = u(x_1) \\pm u_x(x_1)\\Delta x + \\frac{u_{xx}(x_1)}{2!}\\Delta x^2 \\pm \\frac{u_{xxx}(x_1)}{3!}\\Delta x^3 + \\frac{u^{(4)}(x_1)}{4!}\\Delta x^4 \\pm \\dots\n$$\n将这些代入 $\\mathcal{L}_h[u]_1$ 的表达式中：\n$$\n\\mathcal{L}_h[u]_1 = \\frac{1}{\\Delta x^2} \\left[ (u(x_1) + u_x(x_1)\\Delta x + \\dots) - 2u(x_1) + (u(x_1) - u_x(x_1)\\Delta x + \\dots) \\right]\n$$\n奇次幂项相互抵消，剩下：\n$$\n\\mathcal{L}_h[u]_1 = \\frac{1}{\\Delta x^2} \\left[ 2\\left(\\frac{u_{xx}(x_1)\\Delta x^2}{2}\\right) + 2\\left(\\frac{u^{(4)}(x_1)\\Delta x^4}{24}\\right) + \\mathcal{O}(\\Delta x^6) \\right] = u_{xx}(x_1) + \\frac{u^{(4)}(x_1)}{12}\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\n截断误差为：\n$$\n\\text{TE}(x_1; \\Delta x) = \\mathcal{L}_h[u]_1 - u_{xx}(x_1) = \\frac{u^{(4)}(x_1)}{12}\\Delta x^2 + \\mathcal{O}(\\Delta x^4)\n$$\n这是一个二阶精确的近似，$\\text{TE} = \\mathcal{O}(\\Delta x^2)$。因此，我们预期比率 $R_1$ 约等于 $4$。\n\n**测试用例 2：左侧 Neumann 边界条件，在边界节点 $i=0$ 处求值。**\n在 $x_0=0$ 处的离散算子需要一个虚拟单元值 $u_{-1}$：\n$$\n\\mathcal{L}_h[u]_0 = \\frac{u_1 - 2u_0 + u_{-1}}{\\Delta x^2}\n$$\nNeumann 条件 $u_x(0) = q_L$ 是通过一个涉及虚拟单元的二阶中心差分来施加的：\n$$\n\\frac{u_1 - u_{-1}}{2\\Delta x} = q_L \\implies u_{-1} = u_1 - 2\\Delta x q_L\n$$\n将虚拟单元值代入离散拉普拉斯算子中：\n$$\n\\mathcal{L}_h[u]_0 = \\frac{u_1 - 2u_0 + (u_1 - 2\\Delta x q_L)}{\\Delta x^2} = \\frac{2u_1 - 2u_0 - 2\\Delta x q_L}{\\Delta x^2}\n$$\n为了验证，我们使用精确解：$u_1=u(x_1)=u(\\Delta x)$，$u_0=u(x_0)=u(0)$，以及 $q_L=u_x(0)$。\n$$\n\\mathcal{L}_h[u]_0 = \\frac{2u(\\Delta x) - 2u(0) - 2\\Delta x u_x(0)}{\\Delta x^2}\n$$\n我们将 $u(\\Delta x)$ 在 $x=0$ 附近展开为泰勒级数：\n$$\nu(\\Delta x) = u(0) + u_x(0)\\Delta x + \\frac{u_{xx}(0)}{2}\\Delta x^2 + \\frac{u_{xxx}(0)}{6}\\Delta x^3 + \\mathcal{O}(\\Delta x^4)\n$$\n将此代入算子中：\n$$\n\\mathcal{L}_h[u]_0 = \\frac{2(u(0) + u_x(0)\\Delta x + \\frac{u_{xx}(0)}{2}\\Delta x^2 + \\frac{u_{xxx}(0)}{6}\\Delta x^3 + \\mathcal{O}(\\Delta x^4)) - 2u(0) - 2\\Delta x u_x(0)}{\\Delta x^2}\n$$\n$$\n\\mathcal{L}_h[u]_0 = \\frac{ u_{xx}(0)\\Delta x^2 + \\frac{u_{xxx}(0)}{3}\\Delta x^3 + \\mathcal{O}(\\Delta x^4) }{\\Delta x^2} = u_{xx}(0) + \\frac{u_{xxx}(0)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\n截断误差为：\n$$\n\\text{TE}(x_0; \\Delta x) = \\mathcal{L}_h[u]_0 - u_{xx}(0) = \\frac{u_{xxx}(0)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\n这个近似只是一阶精确的，$\\text{TE} = \\mathcal{O}(\\Delta x)$。我们预期比率 $R_2$ 约等于 $2$。\n\n**测试用例 3：右侧 Neumann 边界条件，在边界节点 $i=N$ 处求值。**\n该分析与案例 2 对称。在 $x_N=L$ 处的算子使用一个虚拟单元 $u_{N+1}$：\n$$\n\\mathcal{L}_h[u]_N = \\frac{u_{N+1} - 2u_N + u_{N-1}}{\\Delta x^2}\n$$\nNeumann 条件 $u_x(L) = q_R$ 给出虚拟单元值：\n$$\n\\frac{u_{N+1} - u_{N-1}}{2\\Delta x} = q_R \\implies u_{N+1} = u_{N-1} + 2\\Delta x q_R\n$$\n代入拉普拉斯算子并使用精确值 ($u_j = u(x_j)=u(L+(j-N)\\Delta x)$，$q_R=u_x(L)$)：\n$$\n\\mathcal{L}_h[u]_N = \\frac{2u(L-\\Delta x) - 2u(L) + 2\\Delta x u_x(L)}{\\Delta x^2}\n$$\n将 $u(L-\\Delta x)$ 在 $x=L$ 附近展开：\n$$\nu(L-\\Delta x) = u(L) - u_x(L)\\Delta x + \\frac{u_{xx}(L)}{2}\\Delta x^2 - \\frac{u_{xxx}(L)}{6}\\Delta x^3 + \\mathcal{O}(\\Delta x^4)\n$$\n将此代入算子中：\n$$\n\\mathcal{L}_h[u]_N = \\frac{2(u(L) - u_x(L)\\Delta x + \\frac{u_{xx}(L)}{2}\\Delta x^2 - \\frac{u_{xxx}(L)}{6}\\Delta x^3 + \\dots) - 2u(L) + 2\\Delta x u_x(L)}{\\Delta x^2}\n$$\n$$\n\\mathcal{L}_h[u]_N = \\frac{ u_{xx}(L)\\Delta x^2 - \\frac{u_{xxx}(L)}{3}\\Delta x^3 + \\mathcal{O}(\\Delta x^4) }{\\Delta x^2} = u_{xx}(L) - \\frac{u_{xxx}(L)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\n截断误差为：\n$$\n\\text{TE}(x_N; \\Delta x) = \\mathcal{L}_h[u]_N - u_{xx}(L) = -\\frac{u_{xxx}(L)}{3}\\Delta x + \\mathcal{O}(\\Delta x^2)\n$$\n这个近似也是一阶精确的，$\\text{TE} = \\mathcal{O}(\\Delta x)$。我们预期比率 $R_3$ 约等于 $2$。\n\nPython 代码将实现这些计算，以求得 $R_1, R_2, R_3$ 的数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Manufactured Analytic Solution and its Derivatives ---\ndef u_analytic(x):\n    \"\"\"Analytic solution u(x).\"\"\"\n    return np.exp(x) + np.sin(2 * x)\n\ndef ux_analytic(x):\n    \"\"\"First derivative u_x(x).\"\"\"\n    return np.exp(x) + 2 * np.cos(2 * x)\n\ndef uxx_analytic(x):\n    \"\"\"Second derivative u_xx(x).\"\"\"\n    return np.exp(x) - 4 * np.sin(2 * x)\n\ndef calculate_te(L, N, case_type):\n    \"\"\"\n    Calculates the local truncation error for a given case configuration.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of grid intervals.\n        case_type (int): The test case number (1, 2, or 3).\n\n    Returns:\n        float: The calculated local truncation error.\n    \"\"\"\n    dx = L / N\n\n    if case_type == 1:\n        # Case 1: Dirichlet-Dirichlet, TE at i=1\n        # Grid points needed: x_0, x_1, x_2\n        # The node of interest is x_1\n        i = 1\n        x_i = i * dx\n        x_im1 = (i - 1) * dx\n        x_ip1 = (i + 1) * dx\n\n        # Values of u from the analytic solution\n        u_i = u_analytic(x_i)\n        u_im1 = u_analytic(x_im1) # This is the boundary value u(0)\n        u_ip1 = u_analytic(x_ip1)\n\n        # Discrete and exact Laplacians\n        lap_h = (u_ip1 - 2 * u_i + u_im1) / (dx**2)\n        lap_exact = uxx_analytic(x_i)\n\n        return lap_h - lap_exact\n\n    elif case_type == 2:\n        # Case 2: Neumann-Left, TE at i=0\n        # The node of interest is x_0\n        i = 0\n        x_i = i * dx # x_0 = 0\n        x_ip1 = (i + 1) * dx # x_1\n\n        # Values of u from the analytic solution\n        u_i = u_analytic(x_i)\n        u_ip1 = u_analytic(x_ip1)\n\n        # Neumann boundary condition value q_L = u_x(0)\n        q_L = ux_analytic(x_i)\n\n        # Ghost cell value u_{-1}\n        u_im1_ghost = u_ip1 - 2 * dx * q_L\n\n        # Discrete and exact Laplacians at x_0\n        lap_h = (u_ip1 - 2 * u_i + u_im1_ghost) / (dx**2)\n        lap_exact = uxx_analytic(x_i)\n\n        return lap_h - lap_exact\n\n    elif case_type == 3:\n        # Case 3: Neumann-Right, TE at i=N\n        # The node of interest is x_N = L\n        i = N\n        x_i = i * dx # x_N = L\n        x_im1 = (i - 1) * dx # x_{N-1}\n\n        # Values of u from the analytic solution\n        u_i = u_analytic(x_i)\n        u_im1 = u_analytic(x_im1)\n\n        # Neumann boundary condition value q_R = u_x(L)\n        q_R = ux_analytic(x_i)\n\n        # Ghost cell value u_{N+1}\n        u_ip1_ghost = u_im1 + 2 * dx * q_R\n        \n        # Discrete and exact Laplacians at x_N\n        lap_h = (u_ip1_ghost - 2 * u_i + u_im1) / (dx**2)\n        lap_exact = uxx_analytic(x_i)\n\n        return lap_h - lap_exact\n    \n    else:\n        raise ValueError(\"Invalid case_type specified.\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N_coarse, N_fine, case_type)\n        (1.0, 20, 40, 1), # Case 1: D-D, at i=1\n        (1.0, 20, 40, 2), # Case 2: N-D, at i=0\n        (1.0, 20, 40, 3)  # Case 3: D-N, at i=N\n    ]\n\n    results = []\n    for L, N_coarse, N_fine, case_type in test_cases:\n        # Calculate truncation error for coarse grid\n        te_coarse = calculate_te(L, N_coarse, case_type)\n        \n        # Calculate truncation error for fine grid\n        te_fine = calculate_te(L, N_fine, case_type)\n        \n        # Calculate the ratio R. Handle potential division by zero.\n        if abs(te_fine)  1e-15:\n             # If fine error is virtually zero, ratio is effectively infinite or undefined.\n             # This shouldn't happen for this problem, but is good practice.\n            R = float('inf') \n        else:\n            R = abs(te_coarse) / abs(te_fine)\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    # The format specified is [r1,r2,r3] without spaces.\n    print(_format_results(results))\n\ndef _format_results(results):\n    \"\"\"\n    Formats the list of float results into the required string format \" [r1,r2,r3] \".\n    e.g., [4.000001,2.000001,2.000001]\n    Note: The problem example `[r1, r2, r3]` has spaces, but the final output format\n    description in the `solve` function template does not. Adhering to the template's\n    `','.join` which produces no spaces.\n    \"\"\"\n    return f\"[{','.join(map(str, results))}]\"\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项练习介绍了有限体积法（Finite Volume Method, FVM），该方法因其内在的守恒特性而备受推崇。你将学习如何通过为一个平流-扩散组合问题在边界面上构建一致的数值通量 $\\hat{F}$ 来施加诺伊曼（Neumann）边界条件。本练习强调了有限体积法将边界条件视作将物质输运进出区域的通量的核心思想，从而确保模型严格遵守标量的守恒性。",
            "id": "3828100",
            "problem": "考虑一个一维标量浓度场的守恒输运，采用有限体积法（FVM, Finite Volume Method），其中区域被离散为宽度为 $\\Delta x$ 的均匀控制体，左边界位于 $x=0$。未知量是单元平均浓度 $u$，单位为 $\\mathrm{kg}/\\mathrm{m}^3$。结合了平流和扩散的总物理通量 $F(u)$（单位为 $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$）是平流贡献和扩散贡献之和。平流速度 $a$ 的单位是 $\\mathrm{m}/\\mathrm{s}$，扩散系数 $\\kappa$ 的单位是 $\\mathrm{m}^2/\\mathrm{s}$。在左边界上指定了一个 Neumann 边界条件，规定了在 $x=0$ 处的空间导数 $\\partial u/\\partial x$（单位为 $\\mathrm{kg}/\\mathrm{m}^4$），记为 $g$。\n\n从积分守恒定律和跨面通量连续性的定义出发，推导在第一个单元的左边界界面上保证守恒的一致性数值通量 $\\hat{F}(u)$。使用以下建模和离散化假设：\n\n- 控制平衡律是一个标准的守恒定律，写作在一个控制体上的积分形式，其法向通量必须被计算以确保守恒。\n- Neumann 边界条件指定了边界上的 $\\partial u/\\partial x$；从物理上将其解释为对通量扩散分量的一个约束。\n- 对于扩散贡献，通过构建一个与边界相邻的虚拟单元状态，并在边界界面上使用与规定导数一致的梯度二阶中心近似来施加 Neumann 边界条件。\n- 对于平流贡献，在边界界面上使用基于平流速度 $a$ 符号的一阶迎风数值通量，并认识到当左边界处 $a0$ 时，上游状态可能位于域外，必须由虚拟单元表示。\n- 边界界面上的总数值通量是平流数值通量和扩散数值通量之和，方向指向正 $x$ 方向。\n\n你的程序必须实现所推导的数值通量函数，并为下面的每个测试用例计算 $\\hat{F}(u)$。将每个最终通量以 $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$ 为单位表示，并四舍五入到六位小数。\n\n测试套件：\n- A案（理想情况，纯扩散）：$u_1=1.0\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=10\\,\\mathrm{m}$, $a=0.0\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=5\\times 10^{-3}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=2.0\\times 10^{-2}\\,\\mathrm{kg}/\\mathrm{m}^4$。\n- B案（入流平流-扩散，小负梯度）：$u_1=3.0\\times 10^{-1}\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=5.0\\times 10^{2}\\,\\mathrm{m}$, $a=5.0\\times 10^{-2}\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=1.0\\times 10^{-4}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=-1.0\\times 10^{-5}\\,\\mathrm{kg}/\\mathrm{m}^4$。\n- C案（出流平流-扩散，正梯度）：$u_1=2.0\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=1.0\\times 10^{2}\\,\\mathrm{m}$, $a=-1.0\\times 10^{-1}\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=2.0\\times 10^{-3}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=1.0\\times 10^{-3}\\,\\mathrm{kg}/\\mathrm{m}^4$。\n- D案（零梯度，入流平流）：$u_1=0.0\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=1.0\\,\\mathrm{m}$, $a=1.0\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=1.0\\times 10^{-2}\\,\\mathrm{m}^2/\\mathrm{s}$, $g=0.0\\,\\mathrm{kg}/\\mathrm{m}^4$。\n- E案（仅平流入流，零扩散）：$u_1=5.0\\times 10^{-1}\\,\\mathrm{kg}/\\mathrm{m}^3$, $\\Delta x=2.0\\times 10^{1}\\,\\mathrm{m}$, $a=2.0\\times 10^{-1}\\,\\mathrm{m}/\\mathrm{s}$, $\\kappa=0.0\\,\\mathrm{m}^2/\\mathrm{s}$, $g=1.0\\times 10^{-2}\\,\\mathrm{kg}/\\mathrm{m}^4$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E\\right]$），其中每个 $\\text{result}$ 是相应测试用例的数值通量，单位为 $\\mathrm{kg}/(\\mathrm{m}^2\\cdot\\mathrm{s})$，并已四舍五入。",
            "solution": "问题陈述经评估具有科学依据、良定、客观且完整。所有提供的数据和约束条件都是一致的，并且在物理和数学上是合理的。因此，我们可以进行推导和求解。\n\n目标是推导一维有限体积法（FVM）网格左边界界面上的数值通量 $\\hat{F}_{1/2}$。边界位于 $x=0$。该区域被离散为宽度均匀的单元格 $\\Delta x$。第一个单元格，索引为 $i=1$，跨越区间 $[0, \\Delta x]$，其单元平均浓度 $u_1$ 的中心位于 $x_1 = \\Delta x/2$。为了处理边界条件，我们引入一个虚拟单元，索引为 $i=0$，其中心位于 $x_0 = -\\Delta x/2$。边界界面本身位于 $x_{1/2}=0$，分隔虚拟单元和第一个内部单元。\n\n总物理通量 $F(u)$ 是平流通量 $F_{adv} = au$ 和扩散通量 $F_{diff} = -\\kappa \\frac{\\partial u}{\\partial x}$ 的和。单元界面上的总数值通量 $\\hat{F}$ 是数值平流通量 $\\hat{F}_{adv}$ 和数值扩散通量 $\\hat{F}_{diff}$ 的和：\n$$\n\\hat{F}_{1/2} = \\hat{F}_{adv, 1/2} + \\hat{F}_{diff, 1/2}\n$$\n我们将根据问题的具体要求分别推导每个分量。\n\n首先，我们处理扩散通量分量 $\\hat{F}_{diff, 1/2}$。问题指定了在 $x=0$ 处的 Neumann 边界条件，由 $\\frac{\\partial u}{\\partial x} \\big|_{x=0} = g$ 给出。要求是通过在边界界面上使用梯度的二阶中心差分近似来强制执行此条件。此近似涉及相邻单元中的单元平均值，$u_0$（虚拟单元）和 $u_1$（第一个单元）：\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x=0} \\approx \\frac{u_1 - u_0}{x_1 - x_0} = \\frac{u_1 - u_0}{\\Delta x}\n$$\n将此近似值与给定的梯度 $g$ 相等，使我们能够定义虚拟单元的状态：\n$$\n\\frac{u_1 - u_0}{\\Delta x} = g \\implies u_0 = u_1 - g \\Delta x\n$$\n这个 $u_0$ 的表达式是构建平流通量的必要组成部分，下文将说明。对于扩散通量本身，问题陈述要求将 Neumann 条件解释为对扩散通量的直接约束。边界上的物理扩散通量是 $F_{diff} \\big|_{x=0} = -\\kappa \\frac{\\partial u}{\\partial x} \\big|_{x=0}$。通过代入给定的边界条件，我们直接得到界面上的数值扩散通量：\n$$\n\\hat{F}_{diff, 1/2} = -\\kappa g\n$$\n这种方法是一致的，并直接强制执行了指定的通量条件。使用虚拟单元模板来定义梯度 $\\frac{u_1-u_0}{\\Delta x}$，然后将其用于通量公式 $-\\kappa\\frac{u_1-u_0}{\\Delta x}$，会得到相同的结果 $-\\kappa g$，从而证实了该方法的正确性。\n\n接下来，我们推导平流通量分量 $\\hat{F}_{adv, 1/2}$。问题要求采用一阶迎风格式。该格式从“迎风”方向选择单元平均值来计算通量。方向由平流速度 $a$ 的符号决定。\n- 如果 $a \\ge 0$，流动方向为从左到右（正 $x$ 方向），这是左边界上的一个入流条件。迎风状态是界面 $x_{1/2}=0$ 左侧的状态，即虚拟单元的值 $u_0$。因此，平流通量为：\n  $$\n  \\hat{F}_{adv, 1/2} = a u_0 \\quad (\\text{for } a \\ge 0)\n  $$\n- 如果 $a  0$，流动方向为从右到左（负 $x$ 方向），这是左边界上的一个出流条件。迎风状态是界面右侧的状态，即第一个内部单元的值 $u_1$。平流通量为：\n  $$\n  \\hat{F}_{adv, 1/2} = a u_1 \\quad (\\text{for } a  0)\n  $$\n\n最后，我们通过对每种情况的平流和扩散分量求和来合成总数值通量 $\\hat{F}_{1/2}$。\n\n情况1：入流 ($a \\ge 0$)\n总通量是入流平流通量和扩散通量之和。我们将虚拟单元值 $u_0 = u_1 - g \\Delta x$ 的表达式代入平流通量项。\n$$\n\\hat{F}_{1/2} = \\hat{F}_{adv, 1/2} + \\hat{F}_{diff, 1/2} = a u_0 - \\kappa g = a(u_1 - g \\Delta x) - \\kappa g\n$$\n\n情况2：出流 ($a  0$)\n总通量是出流平流通量和扩散通量之和。\n$$\n\\hat{F}_{1/2} = \\hat{F}_{adv, 1/2} + \\hat{F}_{diff, 1/2} = a u_1 - \\kappa g\n$$\n\n总之，左边界界面上数值通量的完整公式是：\n$$\n\\hat{F}(u_1, \\Delta x, a, \\kappa, g) = \\begin{cases} a (u_1 - g \\Delta x) - \\kappa g  \\text{如果 } a \\ge 0 \\\\ a u_1 - \\kappa g  \\text{如果 } a  0 \\end{cases}\n$$\n现在将实施此公式以计算给定测试用例的通量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical flux at the left boundary of a 1D FVM domain\n    for a series of test cases, based on a derived formula for a\n    Neumann boundary condition.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (u1, delta_x, a, kappa, g)\n    test_cases = [\n        # Case A: happy path, pure diffusion\n        (1.0, 10.0, 0.0, 5e-3, 2e-2),\n        # Case B: inflow advection-diffusion, small negative gradient\n        (3.0e-1, 5.0e2, 5.0e-2, 1.0e-4, -1.0e-5),\n        # Case C: outflow advection-diffusion, positive gradient\n        (2.0, 1.0e2, -1.0e-1, 2.0e-3, 1.0e-3),\n        # Case D: zero gradient, inflow advection\n        (0.0, 1.0, 1.0, 1.0e-2, 0.0),\n        # Case E: advective-only inflow, zero diffusion\n        (5.0e-1, 2.0e1, 2.0e-1, 0.0, 1.0e-2),\n    ]\n\n    results = []\n    for case in test_cases:\n        u1, delta_x, a, kappa, g = case\n\n        # The numerical flux at the left boundary is derived as:\n        # F_hat = a * u_upwind - kappa * g\n        # where u_upwind is determined by the sign of 'a'.\n        # For a = 0 (inflow): u_upwind is the ghost cell value u0.\n        #    u0 is defined by the Neumann BC: (u1 - u0) / delta_x = g\n        #    = u0 = u1 - g * delta_x\n        # For a  0 (outflow): u_upwind is the first cell value u1.\n\n        if a = 0:\n            # Inflow or zero advection case\n            # Flux = a * (u1 - g * delta_x) - kappa * g\n            flux = a * (u1 - g * delta_x) - kappa * g\n        else:\n            # Outflow case\n            # Flux = a * u1 - kappa * g\n            flux = a * u1 - kappa * g\n        \n        results.append(flux)\n\n    # Format the results to 6 decimal places and join into the final string.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}