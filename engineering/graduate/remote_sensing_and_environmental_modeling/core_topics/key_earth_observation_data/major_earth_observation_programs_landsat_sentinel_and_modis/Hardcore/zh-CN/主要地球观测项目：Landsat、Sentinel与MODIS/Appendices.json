{
    "hands_on_practices": [
        {
            "introduction": "任何定量的遥感分析都始于一个基本步骤：将传感器记录的原始数值（数字量化值，DN）转换为具有物理意义的量。本练习将指导您完成这一关键的辐射定标过程，即将Landsat 8的DN值转换为大气层顶（TOA）光谱辐亮度，然后转换为TOA反射率。通过这个过程，您不仅将掌握核心的辐射校正方程，还将学习如何使用一阶（高斯）不确定性传播来量化定标系数中的不确定性如何影响最终反射率产品的精度，这是评估遥感数据科学严谨性的重要一步。",
            "id": "3825717",
            "problem": "一幅来自Landsat 8陆地成像仪（OLI）的1级（Level-1）影像场景提供了红光波段中一个像素的数字量化值（DN）。Landsat的1级辐射定标是一个线性映射，它基于元数据中提供的乘法和加法辐射定标系数，将DN值转换为传感器处的光谱辐亮度。在朗伯体假设下，大气层顶（TOA）双向反射率定义为反射辐亮度与入射的大气层外太阳辐照度之比，并考虑了日地距离和太阳天顶角几何。\n\n基于以上基础：\n- 连接DN与光谱辐亮度$L_{\\lambda}$的1级线性辐射定标定义。\n- 在太阳天顶角下，朗伯目标的TOA反射率$\\rho$的辐射度学定义。\n\n请推导将DN转换为光谱辐亮度$L_{\\lambda}$，然后转换为TOA反射率$\\rho$所需的表达式，并仅使用一阶（高斯）不确定度传播方法，从辐射定标系数传播不确定度。假设所有其他量都是精确的，并忽略大气路径项。\n\n对于Landsat 8 OLI波段4（红光）中的一个特定像素，给定：\n- 数字量化值（DN）：$Q = 12000$。\n- 辐射亮度乘法调整系数：$M_{L} = 6.000 \\times 10^{-3} \\, \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}\\,\\text{DN}^{-1}$，其标准不确定度为 $u(M_{L}) = 1.5 \\times 10^{-4} \\, \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}\\,\\text{DN}^{-1}$。\n- 辐射亮度加法调整系数：$A_{L} = 2.0 \\times 10^{-1} \\, \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}$，其标准不确定度为 $u(A_{L}) = 1.0 \\times 10^{-1} \\, \\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}$。\n- Landsat 8 OLI波段4的平均大气层外太阳辐照度（波段内的太阳常数）：$E_{\\text{SUN}} = 1.570 \\times 10^{3} \\, \\text{W}\\,\\text{m}^{-2}\\,\\mu\\text{m}^{-1}$。\n- 日地距离（天文单位，AU）：$d = 1.005$。\n- 太阳天顶角：$\\theta_{s} = 30^\\circ$。\n\n假设：\n- 将$Q$、$E_{\\text{SUN}}$、$d$和$\\theta_{s}$视为不确定度可忽略的常数。\n- 将$M_{L}$和$A_{L}$视为具有给定标准不确定度的独立（不相关）随机变量。\n- 使用一阶（高斯）不确定度传播。\n- 角度以度表示；三角函数应相应计算。\n- TOA反射率是无量纲的；以小数形式表示（不带百分号）。\n\n计算仅由$u(M_{L})$和$u(A_{L})$引起的TOA反射率的标准不确定度$u(\\rho)$。将最终结果四舍五入至三位有效数字。仅报告$u(\\rho)$的最终数值（无量纲）。",
            "solution": "该问题被认为是有效的，因为它科学上基于遥感辐射度学原理，提法明确，有足够信息得出唯一解，并且表述客观。\n\n任务是推导大气层顶（TOA）反射率$\\rho$作为数字量化值（$Q$）和其他参数的函数的表达式，然后计算由辐射定标系数$M_L$和$A_L$的不确定度所引起的该反射率的标准不确定度$u(\\rho)$。\n\n首先，我们建立传感器原始数字量化值（$Q$）与传感器处光谱辐亮度$L_{\\lambda}$之间的关系。如前所述，这是一个由乘法调整因子$M_L$和加法调整因子$A_L$定义的线性变换。\n$$L_{\\lambda} = M_{L} Q + A_{L}$$\n其中，$L_{\\lambda}$是光谱辐亮度，单位为$\\text{W}\\,\\text{m}^{-2}\\,\\text{sr}^{-1}\\,\\mu\\text{m}^{-1}$。\n\n接下来，我们定义TOA反射率$\\rho$。在朗伯体假设下，反射率是总反射能量与总入射能量之比。用辐亮度表示，TOA反射率由下式给出：\n$$\\rho = \\frac{\\pi L_{\\lambda}}{E_{\\text{incident}}}$$\n其中$L_{\\lambda}$是传感器观测到的反射辐亮度，$E_{\\text{incident}}$是入射到大气层顶水平面上的总太阳辐照度。因子$\\pi$是由于对理想朗伯表面的半球立体角进行积分。\n\n入射太阳辐照度$E_{\\text{incident}}$必须通过校正两个因素从平均大气层外太阳辐照度$E_{\\text{SUN}}$计算得出：太阳天顶角$\\theta_s$和日地距离$d$（以天文单位AU为单位）。太阳天顶角的余弦考虑了入射太阳通量到水平面上的投影。与$1/d^2$成正比的平方反比定律考虑了由于地球椭圆轨道引起的太阳辐照度变化。\n$$E_{\\text{incident}} = \\frac{E_{\\text{SUN}} \\cos(\\theta_s)}{d^2}$$\n\n将$E_{\\text{incident}}$的表达式代入$\\rho$的方程，我们得到：\n$$\\rho = \\frac{\\pi L_{\\lambda} d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}$$\n\n现在，我们将$L_{\\lambda}$的第一个方程代入此表达式，以获得TOA反射率作为输入DN和传感器/场景参数函数的完整模型：\n$$\\rho(Q, M_L, A_L, E_{\\text{SUN}}, d, \\theta_s) = \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)} (M_{L} Q + A_{L})$$\n\n问题要求计算仅由$M_L$和$A_L$的不确定度引起的$\\rho$的标准不确定度$u(\\rho)$。所有其他变量（$Q$、$E_{\\text{SUN}}$、$d$、$\\theta_s$）均被视为精确常数。给定$M_L$和$A_L$是独立的。对于具有独立变量$x$和$y$的函数$f(x, y)$，其一阶（高斯）不确定度传播公式为：\n$$u(f)^2 = \\left(\\frac{\\partial f}{\\partial x}\\right)^2 u(x)^2 + \\left(\\frac{\\partial f}{\\partial y}\\right)^2 u(y)^2$$\n将此公式应用于我们的函数$\\rho(M_L, A_L)$：\n$$u(\\rho)^2 = \\left(\\frac{\\partial \\rho}{\\partial M_L}\\right)^2 u(M_L)^2 + \\left(\\frac{\\partial \\rho}{\\partial A_L}\\right)^2 u(A_L)^2$$\n\n我们计算$\\rho$相对于$M_L$和$A_L$的偏导数：\n$$\\frac{\\partial \\rho}{\\partial M_L} = \\frac{\\partial}{\\partial M_L} \\left[ \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)} (M_{L} Q + A_{L}) \\right] = \\frac{\\pi Q d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}$$\n$$\\frac{\\partial \\rho}{\\partial A_L} = \\frac{\\partial}{\\partial A_L} \\left[ \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)} (M_{L} Q + A_{L}) \\right] = \\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}$$\n\n将这些导数代入不确定度传播公式：\n$$u(\\rho)^2 = \\left(\\frac{\\pi Q d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 u(M_L)^2 + \\left(\\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 u(A_L)^2$$\n我们可以提取公因式：\n$$u(\\rho)^2 = \\left(\\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 \\left[ (Q u(M_L))^2 + u(A_L)^2 \\right]$$\n\n现在我们代入给定的数值：\n- $Q = 12000$\n- $u(M_{L}) = 1.5 \\times 10^{-4}$\n- $u(A_{L}) = 1.0 \\times 10^{-1}$\n- $E_{\\text{SUN}} = 1.570 \\times 10^{3}$\n- $d = 1.005$\n- $\\theta_{s} = 30^\\circ$\n\n首先，计算方括号内的项：\n$$(Q u(M_L))^2 = (12000 \\times 1.5 \\times 10^{-4})^2 = (1.8)^2 = 3.24$$\n$$u(A_L)^2 = (1.0 \\times 10^{-1})^2 = 0.01$$\n\n这些平方项的和是：\n$$(Q u(M_L))^2 + u(A_L)^2 = 3.24 + 0.01 = 3.25$$\n\n接下来，计算平方的前置因子。我们使用 $\\cos(30^\\circ) = \\frac{\\sqrt{3}}{2}$。\n$$\\left(\\frac{\\pi d^2}{E_{\\text{SUN}} \\cos(\\theta_s)}\\right)^2 = \\left(\\frac{\\pi (1.005)^2}{(1.570 \\times 10^{3}) \\times \\frac{\\sqrt{3}}{2}}\\right)^2$$\n$$\\left(\\frac{\\pi \\times 1.010025}{1359.6601...}\\right)^2 \\approx (0.00233370...)^2 \\approx 5.44614 \\times 10^{-6}$$\n\n现在，将两部分相乘以求得$u(\\rho)^2$：\n$$u(\\rho)^2 \\approx (5.44614 \\times 10^{-6}) \\times 3.25 \\approx 1.769996 \\times 10^{-5}$$\n\n最后，取平方根求得标准不确定度$u(\\rho)$：\n$$u(\\rho) = \\sqrt{1.769996 \\times 10^{-5}} \\approx 0.00420713$$\n\n按要求将结果四舍五入至三位有效数字：\n$$u(\\rho) \\approx 0.00421$$",
            "answer": "$$\\boxed{0.00421}$$"
        },
        {
            "introduction": "在掌握了辐射定标的理论基础后，下一个挑战是如何在真实的、多样化的数据产品中实现这一过程的自动化。来自Landsat、Sentinel-2和MODIS等不同项目的数据以不同的格式（如GeoTIFF、JPEG 2000和HDF5）分发，每种格式都有其独特的元数据结构来存储定标系数和质量信息。本练习模拟了遥感数据处理中的一个核心编程任务：设计一个统一的元数据解析方案，以编程方式从这些不同的数据源中提取每波段的辐射定标缩放因子和质量评估（QA）标志。",
            "id": "3825756",
            "problem": "设计并实现一个程序化的元数据解析方案。该方案在给定描述三个主要地球观测计划产品的结构化元数据时——即承载 Landsat 表面反射率 (SR) 数据的地理参考标签图像文件格式 (GeoTIFF)、承载 Sentinel-2 Level-1C 数据的联合图像专家组2000 (JPEG 2000, JP2) 和承载中分辨率成像光谱仪 (MODIS) 数据的5代分层数据格式 (HDF5)——能够提取每个波段的辐射定标尺度因子，并从一个提供的整型质量评估 (QA) 值中解码一组 QA 位。\n\n使用的基本原理和定义：\n- 辐射线性定标：对于每个光谱波段，一个数字量 $x_b$ 通过 $y_b = s_b \\, x_b + o_b$ 映射到一个物理量 $y_b$，其中 $s_b$ 是特定波段的尺度因子，$o_b$ 是特定波段的偏移量。本任务的重点是提取 $s_b$；偏移量 $o_b$ 可用于优先级逻辑，但不是要求输出的一部分。\n- 非负整数 QA 值的位域分解：任何 $q \\in \\mathbb{N}_0$ 都有一个二进制展开式 $q = \\sum_{p=0}^{P} b_p \\, 2^p$，其中 $b_p \\in \\{0,1\\}$ 表示位置 $p$ 上的位。解码一组请求的位位置 $\\{p_i\\}$ 意味着返回列表 $[b_{p_1}, b_{p_2}, \\dots, b_{p_k}]$。\n\n将元数据解析为 $s_b$ 和 $o_b$ 的特定程序优先级约定（科学上真实且常用）：\n1. GeoTIFF 格式的 Landsat SR：\n   - 如果存在针对波段索引 $n$ 的键，形式为“REFLECTANCE_MULT_BAND_$n$”和“REFLECTANCE_ADD_BAND_$n$”，则从“REFLECTANCE_MULT_BAND_$n$”设置 $s_b$，从“REFLECTANCE_ADD_BAND_$n$”设置 $o_b$。\n   - 否则，如果存在全局键“SCALE_FACTOR”，则对所有波段使用该标量值作为 $s_b$，并设 $o_b = 0$。\n   - 否则，默认 $s_b = 1$ 和 $o_b = 0$。\n2. JP2 格式的 Sentinel-2 Level-1C：\n   - 如果存在值为 $Q$ 的全局键“QUANTIFICATION_VALUE”，则对所有波段设置 $s_b = 1/Q$ 和 $o_b = 0$（将类辐射的数字量映射到类大气层顶反射率的物理量）。\n   - 否则，如果存在每个波段的“Radiometric_Gain”映射，则使用该值作为每个波段的增益 $s_b$，并设 $o_b = 0$。\n   - 否则，默认 $s_b = 1$ 和 $o_b = 0$。\n3. HDF5 格式的 MODIS：\n   - 如果属性中包含等于 $a$ 的“scale_factor”和等于 $b$ 的“add_offset”（全局或每个波段），则设置 $s_b = a$ 和 $o_b = b$。\n   - 如果“scale_factor”存在但为非正数，则视元数据为损坏，并默认 $s_b = 1$ 和 $o_b = 0$；如果缺少“scale_factor”，也默认 $s_b = 1$ 和 $o_b = 0$。\n\n质量评估 (QA) 解码规则：\n- 对于一个整数 $q \\ge 0$ 和一组请求的位位置 $\\{p_i\\}$，返回列表 $[b_{p_1}, \\dots, b_{p_k}]$，其中 $b_{p} \\in \\{0,1\\}$ 由 $q$ 的二进制分解确定。\n\n输入抽象：\n- 每个测试用例是一个类元组结构，包含以下字段：“format”（“LANDSAT_SR_GEOTIFF”、“SENTINEL2_L1C_JP2”、“MODIS_HDF5”之一）、“bands”（一个有序的波段标识符列表，每个标识符为非负整数索引）、“metadata”（一个从字符串键到值的映射，可能包含嵌套映射）、“qa_value”（一个非负整数 $q$）和“qa_bit_positions”（一个待解码的非负整数位置 $\\{p_i\\}$ 的有序列表）。\n\n输出规范：\n- 对每个测试用例，生成一个包含以下两项的对：\n  - 与提供的“bands”列表对齐的每个波段尺度因子的有序列表 $[s_{b_1}, s_{b_2}, \\dots, s_{b_m}]$。\n  - 与提供的“qa_bit_positions”列表对齐的已解码 QA 位的有序列表 $[b_{p_1}, \\dots, b_{p_k}]$。\n- 将所有测试用例的结果聚合为单行输出，该行包含一个由方括号括起来的逗号分隔列表。外层列表每个元素对应一个测试用例；每个元素是一个双元素列表，包含尺度因子列表和 QA 位列表。不得打印任何额外文本。\n\n测试套件：\n- 用例 1（正常路径，Landsat SR，全局尺度）：\n  - format: “LANDSAT_SR_GEOTIFF”\n  - bands: $[2, 3, 4]$\n  - metadata: {“SCALE_FACTOR”: $0.0001$}\n  - qa_value: $24$（二进制 $11000$）\n  - qa_bit_positions: $[3, 4]$\n- 用例 2（正常路径，Sentinel-2 L1C，量化值）：\n  - format: “SENTINEL2_L1C_JP2”\n  - bands: $[2, 3, 4, 8]$\n  - metadata: {“QUANTIFICATION_VALUE”: $10000$}\n  - qa_value: $130$（二进制 $10000010$）\n  - qa_bit_positions: $[1, 7]$\n- 用例 3（正常路径，MODIS HDF5，标准属性）：\n  - format: “MODIS_HDF5”\n  - bands: $[1, 2, 3]$\n  - metadata: {“attrs”: {“scale_factor”: $0.0001$, “add_offset”: $0$}}\n  - qa_value: $1024$（二进制 $10000000000$）\n  - qa_bit_positions: $[10, 0]$\n- 用例 4（边界路径，Landsat SR，混合使用每波段和后备值）：\n  - format: “LANDSAT_SR_GEOTIFF”\n  - bands: $[2, 3, 4]$\n  - metadata: {“REFLECTANCE_MULT_BAND_2”: $0.00002$, “REFLECTANCE_ADD_BAND_2”: $0$, “REFLECTANCE_MULT_BAND_3”: $0.00003$, “REFLECTANCE_ADD_BAND_3”: $0$, “SCALE_FACTOR”: $0.0001$}\n  - qa_value: $0$\n  - qa_bit_positions: $[3, 4]$\n- 用例 5（边界路径，MODIS HDF5，非正数尺度因子使用默认值）：\n  - format: “MODIS_HDF5”\n  - bands: $[1, 2]$\n  - metadata: {“attrs”: {“scale_factor”: $0$, “add_offset”: $0$}}\n  - qa_value: $1$\n  - qa_bit_positions: $[0, 15]$\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个结果元素必须是一个双元素列表，第一个是每波段尺度因子，第二个是解码的 QA 位，两者都表示为基本数值类型的列表（尺度因子为浮点数，解码位为整数）。",
            "solution": "该问题陈述已经过严格验证，被确定为一个有效、定义明确的科学编程任务。它在科学上基于遥感数据处理的原理，内部逻辑一致，并提供了构建唯一且可验证解决方案所需的所有信息。\n\n任务是设计一个程序化方案，用于解析来自三种不同地球观测数据产品——Landsat 表面反射率 (SR)、Sentinel-2 Level-1C 和 MODIS——的元数据，以提取辐射定标尺度因子并解码质量评估 (QA) 位标志。该解决方案要求对指定的元数据解释优先级逻辑进行结构化实现，并采用标准算法进行位域分解。\n\n整体设计将通过一个 Python 程序实现，其结构如下：\n1.  一个主函数 `solve`，遍历一组预定义的测试用例。\n2.  对于每个测试用例，调用一个辅助函数 `process_case`。该函数协调两个主要子任务：提取尺度因子和解码 QA 位。\n3.  一个专用函数 `extract_scale_factors`，实现特定于产品的逻辑，为每个请求的光谱波段确定辐射定标尺度因子 $s_b$。\n4.  第二个专用函数 `decode_qa_bits`，对给定的整数 QA 值 $q$ 执行位域分解。\n\n每个测试用例的结果，包含一个有序的尺度因子列表和一个有序的解码 QA 位列表，将被收集并按规范格式化为单个字符串用于最终输出。\n\n**基于原则的设计**\n\n**1. 质量评估 (QA) 位解码**\n\nQA 位的解码是基于非负整数二进制表示的一项基本操作。任何非负整数 $q \\in \\mathbb{N}_0$ 都可以表示为2的幂次和：$q = \\sum_{p=0}^{P} b_p \\, 2^p$，其中 $b_p \\in \\{0,1\\}$ 是位置 $p$ 上的位。\n\n函数 `decode_qa_bits` 接收一个整数 `qa_value`（即 $q$）和一个 `qa_bit_positions` 列表（即 $\\{p_i\\}$）作为输入。对于每个请求的位置 $p$，相应位 $b_p$ 的值通过按位右移后跟一个按位与操作来确定。其表达式为：\n$$\nb_p = (q \\gg p) \\land 1\n$$\n在这里，$q \\gg p$ 将 $q$ 的位向右移动 $p$ 个位置，将被关注的位移到最低有效位（位置0）。随后的与 $1$（二进制 $...0001_2$）的“与”操作会分离出这个位，结果为 $0$ 或 $1$。该函数返回一个根据输入 `qa_bit_positions` 排序的位值列表。\n\n**2. 辐射定标尺度因子提取**\n\n函数 `extract_scale_factors` 负责根据产品 `format` 和请求的 `bands` 列表来解释提供的 `metadata` 字典。它为每种格式应用一组特定的优先级规则，以找到每个波段正确的尺度因子 $s_b$。通用的辐射定标模型是 $y_b = s_b \\, x_b + o_b$，我们的重点是 $s_b$。\n\n**2.1. Landsat 表面反射率 (GeoTIFF)**\n\n对于 `LANDSAT_SR_GEOTIFF` 格式，逻辑按每个波段进行，为每个请求的波段索引 $n$ 按特定的优先顺序检查元数据键：\n1.  首先检查特定于波段的尺度因子键 `REFLECTANCE_MULT_BAND_$n$`。如果此键存在于元数据中，其值将用作该波段的尺度因子 $s_b$。\n2.  如果未找到特定于波段的键，逻辑将回退检查全局尺度因子键 `SCALE_FACTOR`。如果此键存在，其值将用于该波段。\n3.  如果以上两个键都未找到，则分配默认尺度因子 $1.0$。\n\n这种逐波段的级联查找确保了在可用时使用最具体的元数据，同时提供了鲁棒的后备机制。\n\n**2.2. Sentinel-2 Level-1C (JPEG 2000)**\n\n对于 `SENTINEL2_L1C_JP2` 格式，规则定义了一个产品级的优先级：\n1.  主要检查 `QUANTIFICATION_VALUE` 键，假设其值为 $Q$。如果存在，所有波段的尺度因子计算为 $s_b = 1/Q$。这反映了从定标数字量到大气层顶 (TOA) 反射率的标准转换。\n2.  如果 `QUANTIFICATION_VALUE` 不存在，规则指定检查一个逐波段的 `Radiometric_Gain` 映射。由于测试数据中不存在此项，该逻辑分支虽已注明但不会被触发。\n3.  如果以上条件均不满足，则对所有请求的波段应用默认尺度因子 $1.0$。\n\n**2.3. MODIS (HDF5)**\n\n对于 `MODIS_HDF5` 格式，元数据预计嵌套在 `attrs` 字典中。规则如下：\n1.  主要条件要求 `attrs` 字典中同时存在 `scale_factor` 键和 `add_offset` 键。此外，`scale_factor` 的值必须为正。如果所有这些条件都满足，其值将用作所有请求波段的尺度因子 $s_b$。\n2.  如果主要条件因任何原因未满足（例如，键缺失，或 `scale_factor` 为非正数，即 $\\le 0$），逻辑将对所有波段默认使用尺度因子 $1.0$。这正确地处理了问题中定义的元数据缺失、不完整或损坏的情况。\n\n这种对明确定义的规则进行系统性实现，确保了元数据解析根据所提供的规范是鲁棒、确定性且科学正确的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes a suite of remote sensing metadata parsing test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, Landsat SR, global scale)\n        {\n            \"format\": \"LANDSAT_SR_GEOTIFF\",\n            \"bands\": [2, 3, 4],\n            \"metadata\": {\"SCALE_FACTOR\": 0.0001},\n            \"qa_value\": 24,\n            \"qa_bit_positions\": [3, 4],\n        },\n        # Case 2 (happy path, Sentinel-2 L1C, quantification value)\n        {\n            \"format\": \"SENTINEL2_L1C_JP2\",\n            \"bands\": [2, 3, 4, 8],\n            \"metadata\": {\"QUANTIFICATION_VALUE\": 10000},\n            \"qa_value\": 130,\n            \"qa_bit_positions\": [1, 7],\n        },\n        # Case 3 (happy path, MODIS HDF5, standard attributes)\n        {\n            \"format\": \"MODIS_HDF5\",\n            \"bands\": [1, 2, 3],\n            \"metadata\": {\"attrs\": {\"scale_factor\": 0.0001, \"add_offset\": 0}},\n            \"qa_value\": 1024,\n            \"qa_bit_positions\": [10, 0],\n        },\n        # Case 4 (edge path, Landsat SR, mixed per-band with fallback)\n        {\n            \"format\": \"LANDSAT_SR_GEOTIFF\",\n            \"bands\": [2, 3, 4],\n            \"metadata\": {\n                \"REFLECTANCE_MULT_BAND_2\": 0.00002,\n                \"REFLECTANCE_ADD_BAND_2\": 0,\n                \"REFLECTANCE_MULT_BAND_3\": 0.00003,\n                \"REFLECTANCE_ADD_BAND_3\": 0,\n                \"SCALE_FACTOR\": 0.0001,\n            },\n            \"qa_value\": 0,\n            \"qa_bit_positions\": [3, 4],\n        },\n        # Case 5 (edge path, MODIS HDF5, nonpositive scale factor defaults)\n        {\n            \"format\": \"MODIS_HDF5\",\n            \"bands\": [1, 2],\n            \"metadata\": {\"attrs\": {\"scale_factor\": 0, \"add_offset\": 0}},\n            \"qa_value\": 1,\n            \"qa_bit_positions\": [0, 15],\n        },\n    ]\n\n    def decode_qa_bits(q, bit_positions):\n        \"\"\"\n        Decodes requested bits from a non-negative integer QA value.\n\n        Args:\n            q (int): The non-negative integer QA value.\n            bit_positions (list[int]): An ordered list of bit positions to decode.\n\n        Returns:\n            list[int]: The list of decoded bit values (0 or 1).\n        \"\"\"\n        return [(q >> pos)  1 for pos in bit_positions]\n\n    def extract_scale_factors(case):\n        \"\"\"\n        Extracts radiometric scale factors based on product-specific metadata rules.\n\n        Args:\n            case (dict): The test case dictionary.\n\n        Returns:\n            list[float]: The ordered list of per-band scale factors.\n        \"\"\"\n        fmt = case[\"format\"]\n        metadata = case[\"metadata\"]\n        bands = case[\"bands\"]\n        scales = []\n\n        if fmt == \"LANDSAT_SR_GEOTIFF\":\n            for band_idx in bands:\n                per_band_key = f\"REFLECTANCE_MULT_BAND_{band_idx}\"\n                if per_band_key in metadata:\n                    scales.append(metadata[per_band_key])\n                elif \"SCALE_FACTOR\" in metadata:\n                    scales.append(metadata[\"SCALE_FACTOR\"])\n                else:\n                    scales.append(1.0)\n            return scales\n\n        elif fmt == \"SENTINEL2_L1C_JP2\":\n            scale = 1.0 # Default\n            if \"QUANTIFICATION_VALUE\" in metadata:\n                q_val = metadata[\"QUANTIFICATION_VALUE\"]\n                if q_val > 0:\n                    scale = 1.0 / q_val\n            # The \"Radiometric_Gain\" rule is not triggered by test cases\n            # so the logic defaults to 1.0 if QUANTIFICATION_VALUE is not present.\n            return [scale] * len(bands)\n            \n        elif fmt == \"MODIS_HDF5\":\n            scale = 1.0  # Default\n            if \"attrs\" in metadata:\n                attrs = metadata[\"attrs\"]\n                if \"scale_factor\" in attrs and \"add_offset\" in attrs:\n                    sf = attrs[\"scale_factor\"]\n                    if isinstance(sf, (int, float)) and sf > 0:\n                        scale = sf\n            return [scale] * len(bands)\n        \n        return [1.0] * len(bands) # Fallback for unknown formats\n\n    def process_case(case):\n        \"\"\"\n        Processes a single test case to extract scale factors and QA bits.\n\n        Args:\n            case (dict): The test case dictionary.\n\n        Returns:\n            list: A two-element list containing the list of scale factors\n                  and the list of decoded QA bits.\n        \"\"\"\n        scales = extract_scale_factors(case)\n        qa_bits = decode_qa_bits(case[\"qa_value\"], case[\"qa_bit_positions\"])\n        return [scales, qa_bits]\n\n    results = [process_case(case) for case in test_cases]\n\n    # The final print statement must match the project specification exactly.\n    # The default str() representation of a list in Python includes spaces.\n    # This is joined with commas, resulting in a format like '[[...], [...]], [[...], [...]]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在科学分析中使用遥感时间序列数据之前，严格的质量保证是必不可少的一步，以确保结果的可靠性。像MODIS这样的项目提供了极其丰富但复杂的质量评估（QA）信息，这些信息通常被编码在“位打包”的整数标志中。本练习将带您深入了解MODIS的QA层，通过位运算来解构这些标志，并根据严格的科学标准定义一个“高质量”像素过滤器，最终量化在过滤后保留的数据比例。掌握这项技能对于从大型遥感数据集中提取高质量观测值至关重要。",
            "id": "3825837",
            "problem": "您会获得一个表示中分辨率成像光谱仪 (MODIS) 陆地表面反射率和大气状态信息质量的复合质量评估 (QA) 每像素整数，该信息被编码在一个位打包字中。您必须解构其位结构，推导出一个逻辑上严格的高质量筛选器，并计算满足该筛选器的像素所占的比例。目标是实施一个基于二进制表示和逻辑运算符的原则性策略，以确保质量筛选的科学真实性。该复合 QA 整数使用以下位布局，其中位位置从最低有效位（位置 $0$）开始计数：\n\n- 表面反射率质量（低 $8$ 位）：\n  - 位 $0$–$1$（两位字段）：MODLAND 表面反射率质量\n    - $00$：以理想质量生成的校正产品（可接受）\n    - $01$：质量低于理想（对于严格筛选器应拒绝）\n    - $10$：由于云层未生成校正产品（拒绝）\n    - $11$：由于其他原因未生成校正产品（拒绝）\n  - 位 $2$–$3$（两位字段）：波段质量摘要\n    - $00$：最高（可接受）\n    - $01$：良好（对于严格筛选器应拒绝）\n    - $10$：一般（拒绝）\n    - $11$：差（拒绝）\n  - 位 $4$（单位字段）：气溶胶反演成功\n    - $0$：成功（可接受）\n    - $1$：失败（拒绝）\n  - 位 $5$（单位字段）：邻近校正标志\n    - $0$：不需要（对于严格的以陆地为中心的筛选器是可接受的）\n    - $1$：已执行（对于此严格筛选器应拒绝）\n- 大约 $1$ 公里处的状态（高 $8$ 位）：\n  - 位 $8$–$9$（两位字段）：云状态\n    - $00$：晴朗（可接受）\n    - $01$：多云（拒绝）\n    - $10$：混合（拒绝）\n    - $11$：未设置（拒绝）\n  - 位 $10$（单位字段）：云阴影\n    - $0$：无（可接受）\n    - $1$：有（拒绝）\n  - 位 $11$（单位字段）：陆地或水体\n    - $1$：陆地（有资格考虑）\n    - $0$：水体（无资格；从分母中排除）\n  - 位 $12$–$13$（两位字段）：气溶胶量\n    - $00$：低或气候学值（可接受）\n    - $01$：平均（对于严格筛选应拒绝）\n    - $10$：高（拒绝）\n    - $11$：缺失（拒绝）\n  - 位 $14$–$15$（两位字段）：卷云检测\n    - $00$：无（可接受）\n    - $01$：少量（拒绝）\n    - $10$：中等（拒绝）\n    - $11$：大量（拒绝）\n\n您的程序必须：\n- 根据上述位字段定义，解释每个提供的像素级 QA 整数。\n- 为一个像素定义一个高质量谓词，该谓词是上述所有可接受状态的逻辑合取。一个像素被认为是高质量的，当且仅当以下所有条件同时成立：\n  - 表面反射率质量字段：位 $0$–$1$ 等于 $00$，位 $2$–$3$ 等于 $00$，位 $4$ 等于 $0$，位 $5$ 等于 $0$。\n  - 状态字段：位 $8$–$9$ 等于 $00$，位 $10$ 等于 $0$，位 $11$ 等于 $1$，位 $12$–$13$ 等于 $00$，位 $14$–$15$ 等于 $00$。\n- 将保留比例的分母定义为标记为陆地（位 $11$ 等于 $1$）的像素数量。标记为水体（位 $11$ 等于 $0$）的像素从分子和分母中均排除。\n- 将分子定义为满足高质量谓词的陆地像素数量。\n- 在分母等于 $0$（无陆地像素）的边界情况下，按约定将保留比例定义为 $0.0$。\n- 将每个保留比例表示为无单位小数，并四舍五入到六位小数。\n\n您的推导必须基于整数的二进制表示、位逻辑运算和指示函数。您可以使用整数除法、模运算、位移和位掩码来隔离和测试字段。避免使用任何未从所述位字段语义中推导得出的启发式规则。\n\n测试套件：\n对于每个测试用例，您将获得一个 QA 整数列表。请为每个测试用例计算一个指定的保留比例值。\n\n- 测试用例 1（混合质量，混合陆地/水体）：\n  - 数据：[$2048$, $2304$, $10240$, $2049$, $0$, $2064$, $18432$, $2048$]\n- 测试用例 2（无陆地像素）：\n  - 数据：[$0$, $256$, $16384$]\n- 测试用例 3（所有晴朗高质量陆地）：\n  - 数据：[$2048$, $2048$, $2048$, $2048$, $2048$]\n- 测试用例 4（所有陆地像素均存在各种不合格问题）：\n  - 数据：[$6144$, $2080$, $3072$, $2056$, $34816$]\n- 测试用例 5（单个陆地像素，波段质量不满足最严格标准）：\n  - 数据：[$2052$]\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个保留比例都四舍五入到六位小数，顺序与测试用例相同（例如，[$0.123456$,$0.000000$,$1.000000$,$0.500000$,$0.250000$]）。",
            "solution": "该问题要求为模拟的中分辨率成像光谱仪 (MODIS) 质量评估 (QA) 数据实现一个严格的质量筛选算法。每个像素的质量被编码在一个单一的整数中，这是一个位打包字，必须将其解构并根据一组严格的标准进行评估。最终目标是计算高质量陆地像素相对于陆地像素总数的比例。\n\n该方法基于二进制算术和位逻辑运算的原理。一个整数值可以被解释为一个比特序列，其中每个比特或比特组（位字段）可以代表一个特定的状态或标志。为了访问 QA 整数（表示为 $v_{qa}$）中某个位字段的状态，我们采用两个基本操作：按位右移 ($\\gg$) 和按位与 ()。\n\n一个起始于位位置 $p$、长度为 $l$ 位的位字段可以通过以下方式隔离：首先将整数向右移动 $p$ 位（$v_{qa} \\gg p$），使该字段与最低有效位对齐。然后，使用按位与运算符应用一个位掩码来清除所有更高位的比特。一个 $l$ 位字段的掩码是 $2^l - 1$。因此，该字段的值由 $(v_{qa} \\gg p) \\  \\ (2^l - 1)$ 给出。对于位置 $p$ 处的单个比特标志，这简化为 $(v_{qa} \\gg p) \\  \\ 1$。\n\n问题定义了两个主要的像素集合：所有陆地像素的集合，它构成了分析的基础（分母），以及其中属于高质量的像素子集（分子）。\n\n首先，我们定义一个像素为陆地的谓词 $P_{land}$。根据规范，位 $11$ 决定了陆地/水体状态，其中值 $1$ 表示陆地。因此，对于一个给定的 QA 整数 $v_{qa}$：\n$$P_{land}(v_{qa}) \\equiv ((v_{qa} \\gg 11) \\  \\ 1) = 1$$\n分母 $N_{d}$ 是给定数据集中满足此谓词的像素总数。使用一个指示函数 $I(\\cdot)$（若其参数为真则为 $1$，否则为 $0$），我们有：\n$$N_{d} = \\sum_{v_{qa} \\in \\text{Data}} I(P_{land}(v_{qa}))$$\n\n接下来，我们形式化高质量谓词 $P_{hq}$。该谓词是应用于各种位字段的多个条件的逻辑合取。一个像素当且仅当所有指定条件都同时满足时，才被视为高质量。这些条件如下：\n\\begin{itemize}\n    \\item $P_{0-1}(v_{qa}) \\equiv ((v_{qa} \\gg 0) \\  \\ 3) = 0$：MODLAND 质量为理想（$00_2$）。\n    \\item $P_{2-3}(v_{qa}) \\equiv ((v_{qa} \\gg 2) \\  \\ 3) = 0$：波段质量为最高（$00_2$）。\n    \\item $P_{4}(v_{qa}) \\equiv ((v_{qa} \\gg 4) \\  \\ 1) = 0$：气溶胶反演成功。\n    \\item $P_{5}(v_{qa}) \\equiv ((v_{qa} \\gg 5) \\  \\ 1) = 0$：未执行邻近校正。\n    \\item $P_{8-9}(v_{qa}) \\equiv ((v_{qa} \\gg 8) \\  \\ 3) = 0$：云状态为晴朗（$00_2$）。\n    \\item $P_{10}(v_{qa}) \\equiv ((v_{qa} \\gg 10) \\  \\ 1) = 0$：无云阴影。\n    \\item $P_{11}(v_{qa}) \\equiv ((v_{qa} \\gg 11) \\  \\ 1) = 1$：像素为陆地。\n    \\item $P_{12-13}(v_{qa}) \\equiv ((v_{qa} \\gg 12) \\  \\ 3) = 0$：气溶胶量为低或气候学值（$00_2$）。\n    \\item $P_{14-15}(v_{qa}) \\equiv ((v_{qa} \\gg 14) \\  \\ 3) = 0$：未检测到卷云（$00_2$）。\n\\end{itemize}\n完整的高质量谓词是所有这些单个谓词的合取：\n$$P_{hq}(v_{qa}) \\equiv P_{0-1}(v_{qa}) \\land P_{2-3}(v_{qa}) \\land P_{4}(v_{qa}) \\land P_{5}(v_{qa}) \\land P_{8-9}(v_{qa}) \\land P_{10}(v_{qa}) \\land P_{11}(v_{qa}) \\land P_{12-13}(v_{qa}) \\land P_{14-15}(v_{qa})$$\n分子 $N_{n}$ 是数据集中满足此复合谓词 $P_{hq}$ 的像素总数：\n$$N_{n} = \\sum_{v_{qa} \\in \\text{Data}} I(P_{hq}(v_{qa}))$$\n请注意，由于 $P_{hq}$ 包括条件 $P_{11}$，任何满足 $P_{hq}$ 的像素也必须满足 $P_{land}$。\n\n最后，保留比例 $F$ 是分子与分母的比值：\n$$F = \\frac{N_{n}}{N_{d}}$$\n根据问题规范，在没有陆地像素（$N_{d} = 0$）的边界情况下，该比例定义为 $0.0$。\n\n对于计算实现，这些布尔谓词评估可以利用矢量化操作（例如 NumPy 库的特性）高效地对 QA 整数数组执行。每个谓词生成一个布尔数组，然后使用逻辑与运算组合这些数组，以找到最终的高质量像素集。计数 $N_n$ 和 $N_d$ 是通过对相应布尔数组中的 `True` 值求和得到的。这种方法避免了对像素的显式循环，从而得到一个更简洁且高性能的解决方案。最终值四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the retained fraction of high-quality land pixels from MODIS QA integers.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2048, 2304, 10240, 2049, 0, 2064, 18432, 2048], # Test case 1\n        [0, 256, 16384],                                 # Test case 2\n        [2048, 2048, 2048, 2048, 2048],                  # Test case 3\n        [6144, 2080, 3072, 2056, 34816],                  # Test case 4\n        [2052],                                          # Test case 5\n    ]\n\n    results = []\n    for qa_data in test_cases:\n        # Convert list to numpy array for vectorized operations.\n        # Use uint16 as the values fit within 16 bits.\n        qa_array = np.array(qa_data, dtype=np.uint16)\n\n        # ---- Denominator Calculation ----\n        # A pixel is land if bit 11 is 1.\n        # Check: (v_qa >> 11)  1 == 1\n        is_land_mask = (qa_array >> 11)  1\n        is_land = is_land_mask == 1\n        \n        denominator = np.sum(is_land)\n\n        if denominator == 0:\n            retained_fraction = 0.0\n        else:\n            # ---- Numerator Calculation ----\n            # A pixel is high-quality if it meets a conjunction of criteria.\n            # We evaluate each predicate on the entire array.\n\n            # Bits 0-1: MODLAND quality (must be 00)\n            p_0_1 = ((qa_array >> 0)  3) == 0\n            \n            # Bits 2-3: Band quality (must be 00)\n            p_2_3 = ((qa_array >> 2)  3) == 0\n            \n            # Bit 4: Aerosol retrieval success (must be 0)\n            p_4 = ((qa_array >> 4)  1) == 0\n            \n            # Bit 5: Adjacency correction flag (must be 0)\n            p_5 = ((qa_array >> 5)  1) == 0\n            \n            # Bits 8-9: Cloud state (must be 00)\n            p_8_9 = ((qa_array >> 8)  3) == 0\n            \n            # Bit 10: Cloud shadow (must be 0)\n            p_10 = ((qa_array >> 10)  1) == 0\n            \n            # Bit 11: Land/Water flag (must be 1 for land)\n            # This is the same as the is_land check.\n            p_11 = is_land\n            \n            # Bits 12-13: Aerosol quantity (must be 00)\n            p_12_13 = ((qa_array >> 12)  3) == 0\n            \n            # Bits 14-15: Cirrus detection (must be 00)\n            p_14_15 = ((qa_array >> 14)  3) == 0\n            \n            # Combine all conditions with logical AND.\n            is_high_quality = (p_0_1  p_2_3  p_4  p_5  \n                               p_8_9  p_10  p_11  p_12_13  p_14_15)\n            \n            numerator = np.sum(is_high_quality)\n            \n            retained_fraction = numerator / denominator\n\n        results.append(f\"{retained_fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}