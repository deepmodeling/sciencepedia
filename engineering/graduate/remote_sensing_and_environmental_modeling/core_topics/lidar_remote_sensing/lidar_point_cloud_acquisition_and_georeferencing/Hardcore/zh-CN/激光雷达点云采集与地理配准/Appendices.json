{
    "hands_on_practices": [
        {
            "introduction": "LiDAR系统最基本的测量值是距离，它由激光脉冲的飞行时间确定。然而，该测量的精度并非无限，它受到激光脉冲的持续时间以及接收器电子器件的计时精度等物理因素的根本限制。本练习  将演示如何使用基本的统计学原理对这些不确定性进行建模和组合，从而推导出系统的有效距离分辨率，这是理解LiDAR数据质量的基石。",
            "id": "3824599",
            "problem": "机载激光雷达（LiDAR）系统通过测量光脉冲的飞行时间来估算到目标的距离。距离估算是通过相对于参考时钟对接收到的波形进行时间戳记，并利用光速将经过的时间转换为距离来形成的。假设单次测量的时间不确定性遵循以下具有物理基础的模型。\n\n1. 发射的光脉冲具有有限的时间宽度。将由脉冲形状和匹配滤波引起的系统有效冲激响应建模为一个零均值高斯时间随机变量，其标准差为 $\\tau$，代表了由脉冲时间宽度带来的不可约时间展宽。\n\n2. 接收器的时钟和鉴别器引入了时间抖动，该抖动在统计上与脉冲形状引起的时间展宽无关。将此接收器时间抖动建模为一个零均值高斯随机变量，其标准差为 $\\sigma_{t}$。\n\n3. 飞行时间估算是通过线性时间戳操作形成的，而距离是通过基于光速 $c$ 的标准飞行时间映射从时间获得的。\n\n将有效距离分辨率定义为单次距离估算的一个标准差不确定性（标准差），并假设两个独立的高斯时间不确定性通过其时间分布的卷积相结合。仅从距离和传播时间之间的飞行时间关系以及独立高斯随机变量在卷积和线性缩放下的性质出发，推导有效距离分辨率关于 $c$、$\\tau$ 和 $\\sigma_{t}$ 的封闭形式解析表达式。请以关于 $c$、$\\tau$ 和 $\\sigma_{t}$ 的单个简化解析表达式的形式提供最终答案，不进行任何数值代入。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，提法恰当且客观。它提出了一个标准的、尽管简化的LiDAR测距不确定性模型，为推导唯一且有意义的解提供了所有必要的定义和约束。\n\n该问题要求推导有效距离分辨率，其定义为单次距离估算的一个标准差不确定性。此推导将基于所提供的时间不确定性模型和LiDAR的基本飞行时间原理。\n\n设 $T_p$ 是表示由光脉冲的有限时间宽度和系统冲激响应引入的时间不确定性的随机变量。根据问题陈述，这是一个标准差为 $\\tau$ 的零均值高斯随机变量。其概率密度函数为 $\\mathcal{N}(0, \\tau^2)$，其方差为 $Var(T_p) = \\tau^2$。\n\n设 $T_j$ 是表示来自接收器时钟和鉴别器的时间抖动的随机变量。这也是一个标准差为 $\\sigma_t$ 的零均值高斯随机变量。其概率密度函数为 $\\mathcal{N}(0, \\sigma_t^2)$，其方差为 $Var(T_j) = \\sigma_t^2$。\n\n问题陈述指出，这两个时间不确定性来源在统计上是独立的。单次测量中的总时间不确定性，我们称此随机变量为 $T_{total}$，是各个不确定性之和：\n$$T_{total} = T_p + T_j$$\n\n独立高斯随机变量的一个基本性质是它们的和也是一个高斯随机变量。和的均值是均值之和，和的方差是方差之和。\n\n总时间不确定性的均值为：\n$$E[T_{total}] = E[T_p] + E[T_j] = 0 + 0 = 0$$\n\n由于 $T_p$ 和 $T_j$ 的独立性，总时间不确定性的方差为：\n$$Var(T_{total}) = Var(T_p) + Var(T_j) = \\tau^2 + \\sigma_t^2$$\n\n总时间不确定性的标准差 $\\sigma_{T_{total}}$ 是其方差的平方根：\n$$\\sigma_{T_{total}} = \\sqrt{Var(T_{total})} = \\sqrt{\\tau^2 + \\sigma_t^2}$$\n\n接下来，我们必须将此时间不确定性与距离不确定性联系起来。LiDAR系统测量的距离 $R$ 由光脉冲的往返飞行时间 $t$ 决定，其关系如下：\n$$R = \\frac{c \\cdot t}{2}$$\n其中 $c$ 是光速。因子 $\\frac{1}{2}$ 是因为测量的时间 $t$ 对应于脉冲传播到目标再返回的过程。\n\n测量的飞行时间 $t_{meas}$ 可以建模为真实的、确定性的飞行时间 $t_{true}$ 与随机的总时间误差 $T_{total}$ 之和：\n$$t_{meas} = t_{true} + T_{total}$$\n\n因此，估算的距离 $R_{est}$ 是一个随机变量，通过将飞行时间公式应用于测量时间得到：\n$$R_{est} = \\frac{c \\cdot t_{meas}}{2} = \\frac{c}{2} (t_{true} + T_{total})$$\n展开此表达式，我们得到：\n$$R_{est} = \\frac{c \\cdot t_{true}}{2} + \\frac{c}{2} T_{total}$$\n项 $\\frac{c \\cdot t_{true}}{2}$ 是真实距离 $R_{true}$，对于给定的测量，它是一个常数。因此，估算的距离为：\n$$R_{est} = R_{true} + \\frac{c}{2} T_{total}$$\n\n问题将有效距离分辨率定义为距离估算的一个标准差不确定性，我们记为 $\\sigma_R$。这等于 $std(R_{est})$。为了求得此值，我们首先计算 $R_{est}$ 的方差。我们使用线性变换随机变量 $X$ 的方差性质，即对于常数 $a$ 和 $b$，$Var(aX + b) = a^2 Var(X)$。\n\n在我们的例子中，随机变量是 $T_{total}$，缩放常数是 $a = \\frac{c}{2}$，加性常数是 $b = R_{true}$。\n$$Var(R_{est}) = Var\\left(R_{true} + \\frac{c}{2} T_{total}\\right) = \\left(\\frac{c}{2}\\right)^2 Var(T_{total})$$\n代入我们之前求得的 $Var(T_{total})$ 的表达式：\n$$Var(R_{est}) = \\frac{c^2}{4} (\\tau^2 + \\sigma_t^2)$$\n\n有效距离分辨率 $\\sigma_R$ 是标准差，即方差的平方根：\n$$\\sigma_R = std(R_{est}) = \\sqrt{Var(R_{est})} = \\sqrt{\\frac{c^2}{4} (\\tau^2 + \\sigma_t^2)}$$\n\n最后，简化此表达式得到距离分辨率的封闭形式解析表达式：\n$$\\sigma_R = \\frac{c}{2} \\sqrt{\\tau^2 + \\sigma_t^2}$$\n该表达式表示基于所提供参数的单次距离测量中的一个标准差不确定性。",
            "answer": "$$\\boxed{\\frac{c}{2} \\sqrt{\\tau^2 + \\sigma_{t}^{2}}}$$"
        },
        {
            "introduction": "精确的地理配准要求每个LiDAR回波的时间戳必须与GNSS/IMU时间基准保持同步。在实际应用中，LiDAR传感器的内部时钟相对于参考时钟可能存在恒定偏移和线性漂移。本实践练习  采用线性最小二乘法，通过观测固定目标（后向反射器）来估计这些时间同步参数。这个动手编程练习将一个现实世界中的校准问题转化为一个可解的线性代数问题，为您提供了实施关键传感器校准程序的宝贵经验。",
            "id": "3824548",
            "problem": "您的任务是设计一个用于激光雷达 (LiDAR) 传感器时间同步的校准程序，该程序使用逆向反射器来估计 LiDAR 时钟与参考时间基准之间的恒定和线性时间偏移。该程序必须通过拟合观测返回时间与预期返回时间，来推导、实现并计算出恒定偏移量（单位为秒）和线性漂移（无量纲比率）的估计值。\n\n此问题的基本原理是脉冲激光雷达的飞行时间方程，该方程表明激光脉冲的往返传播时间与两倍距离除以光速成正比。设光速为 $c = 299{,}792{,}458 \\ \\mathrm{m/s}$。对于距离为 $R$ 的逆向反射器，其预期往返时间由下式给出：\n$$\n\\tau = \\frac{2 R}{c}.\n$$\n\n假设 LiDAR 设备在已知的参考发射时间 $t_i$ 发射脉冲，这些时间记录在全球导航卫星系统 (GNSS)/惯性测量单元 (IMU) 的时间基准上。LiDAR 设备在其自己的内部时钟上记录观测到的返回时间戳 $t_i^{\\mathrm{obs}}$，该时钟相对于参考时间基准存在未知的恒定偏移和线性漂移。将观测到的返回时间建模为：\n$$\nt_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i,\n$$\n其中 $c_0$ 是恒定偏移量（单位为秒），$c_1$ 是线性漂移（无量纲比率），$\\varepsilon_i$ 代表测量噪声。校准问题简化为通过最小化观测到达时间与预期到达时间之间的残差平方和来估计 $c_0$ 和 $c_1$。\n\n对于一组 $n$ 个观测值，定义残差\n$$\ny_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i.\n$$\n您必须通过求解线性最小二乘问题来估计 $c_0$ 和 $c_1$：\n$$\n\\min_{c_0, c_1} \\sum_{i=1}^{n} \\left( y_i - (c_0 + c_1 t_i) \\right)^2,\n$$\n这等效于使用设计矩阵通过正规方程求解：\n$$\n\\mathbf{X} = \\begin{bmatrix}\n1  t_1 \\\\\n1  t_2 \\\\\n\\vdots  \\vdots \\\\\n1  t_n\n\\end{bmatrix},\n\\quad\n\\mathbf{y} = \\begin{bmatrix}\ny_1 \\\\\ny_2 \\\\\n\\vdots \\\\\ny_n\n\\end{bmatrix}.\n$$\n解满足\n$$\n\\begin{bmatrix}\n\\hat{c}_0 \\\\\n\\hat{c}_1\n\\end{bmatrix}\n= (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}.\n$$\n\n单位与输出要求：\n- 以秒为单位报告 $\\hat{c}_0$，以无量纲比率报告 $\\hat{c}_1$。\n- 将每个报告值四舍五入到 $12$ 位小数。\n- 此问题不使用角度；无需角度单位。\n- 您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，该列表按 $[\\hat{c}_{0,1},\\hat{c}_{1,1},\\hat{c}_{0,2},\\hat{c}_{1,2},\\hat{c}_{0,3},\\hat{c}_{1,3}]$ 的顺序将所有测试用例的结果展平，其中下标表示测试用例索引。\n\n测试套件：\n对于每个测试用例，LiDAR 发射器位于坐标原点 $(0,0,0)$，逆向反射器位于已知位置。欧几里得距离定义为：\n$$\nR = \\sqrt{(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2}.\n$$\n使用光速 $c = 299{,}792{,}458 \\ \\mathrm{m/s}$。\n\n- 测试用例 1 (正常路径，多个反射器，小的确定性噪声)：\n  - 发射时间 (秒)：$[0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0]$。\n  - 逆向反射器位置 (米)：$[(50.0, 0.0, 0.0), (0.0, 120.0, 0.0), (0.0, 0.0, 300.0)]$。\n  - 每次发射对应的反射器分配：索引 $[0, 1, 2, 0, 1, 2, 0]$。\n  - 真实偏移量：$c_0 = 0.000008000000 \\ \\mathrm{s}$，$c_1 = 0.000000100000$。\n  - 确定性噪声序列 (秒)：$[0.000000001000, -0.000000002000, 0.000000003000, -0.000000001000, 0.000000002000, 0.000000000000, -0.000000003000]$。\n\n- 测试用例 2 (边界条件，最少两个观测值，精确数据)：\n  - 发射时间 (秒)：$[0.0, 10.0]$。\n  - 单个逆向反射器位置 (米)：$[(0.0, 123.0, 0.0)]$ 用于两次发射。\n  - 每次发射对应的反射器分配：索引 $[0, 0]$。\n  - 真实偏移量：$c_0 = 0.000005000000 \\ \\mathrm{s}$，$c_1 = -0.000000200000$。\n  - 确定性噪声序列 (秒)：$[0.000000000000, 0.000000000000]$。\n\n- 测试用例 3 (长基线，混合距离，小的确定性噪声，负常数偏移)：\n  - 发射时间 (秒)：$[10.0, 20.0, 50.0, 80.0, 120.0]$。\n  - 逆向反射器位置 (米)：$[(30.0, 40.0, 0.0), (0.0, 200.0, 0.0), (100.0, 100.0, 0.0)]$。\n  - 每次发射对应的反射器分配：索引 $[0, 1, 2, 0, 1]$。\n  - 真实偏移量：$c_0 = -0.000010000000 \\ \\mathrm{s}$，$c_1 = 0.000000050000$。\n  - 确定性噪声序列 (秒)：$[0.000000000000, -0.000000001000, 0.000000002000, -0.000000002000, 0.000000001000]$。\n\n对于每个测试用例：\n1. 根据提供的几何信息计算距离 $R_i$。\n2. 计算预期往返时间 $\\tau_i = 2R_i/c$。\n3. 构建观测时间 $t_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i$。\n4. 计算残差 $y_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i$。\n5. 通过线性最小二乘法估计 $\\hat{c}_0$ 和 $\\hat{c}_1$，即最小化 $\\sum_i (y_i - (c_0 + c_1 t_i))^2$。\n6. 将每个估计值四舍五入到 12 位小数，并如上所述输出所有测试用例的展平列表。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\hat{c}_{0,1},\\hat{c}_{1,1},\\hat{c}_{0,2},\\hat{c}_{1,2},\\hat{c}_{0,3},\\hat{c}_{1,3}]$，其中 $\\hat{c}_0$ 的单位是秒，$\\hat{c}_1$ 是无量纲的，每个值都四舍五入到 12 位小数。",
            "solution": "该问题经过了严格的验证过程。\n\n### 步骤 1：提取已知条件\n\n-   **常量**：光速，$c = 299{,}792{,}458 \\ \\mathrm{m/s}$。\n-   **预期往返时间方程**：$\\tau = \\frac{2 R}{c}$，其中 $R$ 是距离。\n-   **观测返回时间模型**：$t_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i$，其中 $t_i$ 是参考发射时间，$c_0$ 是恒定时间偏移 (s)，$c_1$ 是线性时间漂移 (无量纲)，$\\varepsilon_i$ 是测量噪声。\n-   **残差定义**：$y_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i$。\n-   **估计的目标函数**：最小化 $\\sum_{i=1}^{n} \\left( y_i - (c_0 + c_1 t_i) \\right)^2$。\n-   **矩阵形式**：\n    $$\n    \\mathbf{X} = \\begin{bmatrix}\n    1  t_1 \\\\\n    1  t_2 \\\\\n    \\vdots  \\vdots \\\\\n    1  t_n\n    \\end{bmatrix},\n    \\quad\n    \\mathbf{y} = \\begin{bmatrix}\n    y_1 \\\\\n    y_2 \\\\\n    \\vdots \\\\\n    y_n\n    \\end{bmatrix}.\n    $$\n-   **最小二乘解**：$\\begin{bmatrix} \\hat{c}_0 \\\\ \\hat{c}_1 \\end{bmatrix} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}$。\n-   **LiDAR 发射器位置**：$(0,0,0)$。\n-   **距离定义**：欧几里得距离，$R = \\sqrt{(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2}$。\n-   **输出要求**：\n    -   $\\hat{c}_0$ 单位为秒，$\\hat{c}_1$ 无量纲。\n    -   四舍五入到 12 位小数。\n    -   最终输出格式：`[ĉ_0,1,ĉ_1,1,ĉ_0,2,ĉ_1,2,ĉ_0,3,ĉ_1,3]`。\n-   **测试用例 1 数据**：\n    -   发射时间：$[0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0]$ s。\n    -   逆向反射器位置：$[(50.0, 0.0, 0.0), (0.0, 120.0, 0.0), (0.0, 0.0, 300.0)]$ m。\n    -   反射器分配索引：$[0, 1, 2, 0, 1, 2, 0]$。\n    -   真实偏移量：$c_0 = 0.000008000000$ s，$c_1 = 0.000000100000$。\n    -   噪声：$[0.000000001, -0.000000002, 0.000000003, -0.000000001, 0.000000002, 0.0, -0.000000003]$ s。\n-   **测试用例 2 数据**：\n    -   发射时间：$[0.0, 10.0]$ s。\n    -   逆向反射器位置：$[(0.0, 123.0, 0.0)]$ m。\n    -   反射器分配索引：$[0, 0]$。\n    -   真实偏移量：$c_0 = 0.000005000000$ s，$c_1 = -0.000000200000$。\n    -   噪声：$[0.0, 0.0]$ s。\n-   **测试用例 3 数据**：\n    -   发射时间：$[10.0, 20.0, 50.0, 80.0, 120.0]$ s。\n    -   逆向反射器位置：$[(30.0, 40.0, 0.0), (0.0, 200.0, 0.0), (100.0, 100.0, 0.0)]$ m。\n    -   反射器分配索引：$[0, 1, 2, 0, 1]$。\n    -   真实偏移量：$c_0 = -0.000010000000$ s，$c_1 = 0.000000050000$。\n    -   噪声：$[0.0, -0.000000001, 0.000000002, -0.000000002, 0.000000001]$ s。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题基于公认的 LiDAR 飞行时间原理，并使用标准线性模型来描述时钟漂移。最小二乘法是此背景下参数估计的典型方法。物理和数学模型都是合理的。\n-   **适定性**：该问题需要求解一个线性最小二乘系统。如果设计矩阵 $\\mathbf{X}$ 具有满列秩，则存在唯一解，而这在发射时间 $t_i$ 不完全相同时成立。检查所有三个测试用例可以确认发射时间是不同的，从而确保矩阵 $\\mathbf{X}^\\top\\mathbf{X}$ 是可逆的。因此，该问题是适定的。\n-   **客观性**：问题陈述使用了精确、定量的语言，没有主观性或模糊性。\n-   **完整性**：所有必需的数据、模型和常量都已提供。从数据生成到参数估计的整个过程都得到了明确定义。\n-   **一致性**：没有矛盾之处。使用真实参数生成模拟的“观测”数据是验证估计算法的标准技术。\n\n### 步骤 3：结论与行动\n该问题科学合理、适定、客观且完整。因此，它被判定为 **有效**。将提供解决方案。\n\n目标是估计 LiDAR 系统的恒定时间偏移 $c_0$ 和线性时间漂移 $c_1$。该估计是通过对 LiDAR 内部时钟与参考时间基准之间的关系进行建模，然后应用线性最小二乘法来执行的。\n\n问题的核心在于为第 $i$ 个激光脉冲的观测返回时间 $t_i^{\\mathrm{obs}}$ 所提供的模型：\n$$\nt_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i\n$$\n在这里，$t_i$ 是参考时钟上已知的发射时间，$\\tau_i$ 是激光脉冲的物理往返飞行时间，$\\varepsilon_i$ 是随机测量噪声。项 $c_0 + c_1 t_i$ 代表了在时间 $t_i$ 时 LiDAR 时钟与参考时钟之间的总时间差异。\n\n为了分离出我们感兴趣的参数 $c_0$ 和 $c_1$，我们重新排列方程。问题定义了一个量 $y_i$，即观测返回时间与确定性已知分量（发射时间和理想传播时间）之间的差值：\n$$\ny_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i\n$$\n将 $t_i^{\\mathrm{obs}}$ 的模型代入此定义中，得到：\n$$\ny_i = (t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i) - t_i - \\tau_i = c_0 + c_1 t_i + \\varepsilon_i\n$$\n这个方程揭示了可计算量 $y_i$ 与发射时间 $t_i$ 之间的简单线性关系。参数 $c_0$ 和 $c_1$ 分别是该线性模型的截距和斜率。\n\n任务是找到能最好地拟合观测数据集 $(t_i, y_i)$ 的估计值 $\\hat{c}_0$ 和 $\\hat{c}_1$。最小二乘法原理要求我们找到使观测值 $y_i$ 与模型预测值 $\\hat{y}_i = c_0 + c_1 t_i$ 之间差值的平方和最小的参数。需要最小化的目标函数是：\n$$\nS(c_0, c_1) = \\sum_{i=1}^{n} (y_i - (c_0 + c_1 t_i))^2\n$$\n这是一个标准的线性回归问题。用矩阵表示法，我们可以将所有 $n$ 个观测的方程组写成：\n$$\n\\mathbf{y} = \\mathbf{X}\\mathbf{c} + \\boldsymbol{\\varepsilon}\n$$\n其中 $\\mathbf{y} = [y_1, y_2, \\ldots, y_n]^\\top$ 是观测向量，$\\mathbf{c} = [c_0, c_1]^\\top$ 是待估计的参数向量，$\\boldsymbol{\\varepsilon}$ 是噪声项向量，$\\mathbf{X}$ 是设计矩阵：\n$$\n\\mathbf{X} = \\begin{bmatrix}\n1  t_1 \\\\\n1  t_2 \\\\\n\\vdots  \\vdots \\\\\n1  t_n\n\\end{bmatrix}\n$$\n最小化 $||\\mathbf{y} - \\mathbf{X}\\mathbf{c}||^2$ 的最小二乘解 $\\hat{\\mathbf{c}}$ 由正规方程的解给出：\n$$\n(\\mathbf{X}^\\top \\mathbf{X}) \\hat{\\mathbf{c}} = \\mathbf{X}^\\top \\mathbf{y}\n$$\n如果 $\\mathbf{X}^\\top \\mathbf{X}$ 是可逆的（对于给定的测试用例，由于 $\\mathbf{X}$ 的列是线性无关的，所以它是可逆的），那么解可以正式写作：\n$$\n\\hat{\\mathbf{c}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}\n$$\n虽然这个方程提供了解析解，但稳健的数值实现通常使用 QR 分解或奇异值分解等方法来求解该系统，以获得比显式求逆更优越的数值稳定性。\n\n每个测试用例的算法步骤如下：\n1.  定义光速常量 $c = 299{,}792{,}458 \\ \\mathrm{m/s}$。\n2.  对于测试用例中的 $n$ 个测量值中的每一个：\n    a. 确定发射时间 $t_i$、分配的逆向反射器位置 $(x, y, z)$、真实偏移量 $c_0$ 和 $c_1$ 以及噪声项 $\\varepsilon_i$。\n    b. 计算到逆向反射器的距离 $R_i = \\sqrt{x^2 + y^2 + z^2}$，因为发射器在原点。\n    c. 计算理想往返时间 $\\tau_i = 2 R_i / c$。\n    d. 使用提供的模型合成“观测”返回时间：$t_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i$。\n    e. 计算回归变量 $y_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i$。\n3.  构建 $n \\times 2$ 的设计矩阵 $\\mathbf{X}$，其中第一列全为 1，第二列为发射时间 $t_i$。\n4.  构建由元素 $y_i$ 组成的 $n \\times 1$ 观测向量 $\\mathbf{y}$。\n5.  求解线性最小二乘问题得到 $\\hat{\\mathbf{c}} = [\\hat{c}_0, \\hat{c}_1]^\\top$。\n6.  根据最终输出要求，将估计参数 $\\hat{c}_0$ 和 $\\hat{c}_1$ 四舍五入到 12 位小数。然后连接所有测试用例的结果。\n\n此过程应用于每个测试用例以推导出所需的估计值。对于测试用例 2，它恰好有两个数据点且没有噪声，最小二乘拟合将是一条精确穿过这两点的直线，从而完美恢复真实参数 $c_0$ 和 $c_1$。对于测试用例 1 和 3，由于存在非零噪声项 $\\varepsilon_i$，估计的参数将接近但不会完全等于真实值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LiDAR time synchronization calibration problem for three test cases.\n    \"\"\"\n    # Speed of light in m/s\n    C_LIGHT = 299792458.0\n\n    test_cases = [\n        {\n            \"emission_times\": np.array([0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0]),\n            \"reflector_positions\": np.array([(50.0, 0.0, 0.0), (0.0, 120.0, 0.0), (0.0, 0.0, 300.0)]),\n            \"assignment_indices\": [0, 1, 2, 0, 1, 2, 0],\n            \"c0_true\": 8.0e-6,\n            \"c1_true\": 1.0e-7,\n            \"noise\": np.array([1.0e-9, -2.0e-9, 3.0e-9, -1.0e-9, 2.0e-9, 0.0, -3.0e-9]),\n        },\n        {\n            \"emission_times\": np.array([0.0, 10.0]),\n            \"reflector_positions\": np.array([(0.0, 123.0, 0.0)]),\n            \"assignment_indices\": [0, 0],\n            \"c0_true\": 5.0e-6,\n            \"c1_true\": -2.0e-7,\n            \"noise\": np.array([0.0, 0.0]),\n        },\n        {\n            \"emission_times\": np.array([10.0, 20.0, 50.0, 80.0, 120.0]),\n            \"reflector_positions\": np.array([(30.0, 40.0, 0.0), (0.0, 200.0, 0.0), (100.0, 100.0, 0.0)]),\n            \"assignment_indices\": [0, 1, 2, 0, 1],\n            \"c0_true\": -1.0e-5,\n            \"c1_true\": 5.0e-8,\n            \"noise\": np.array([0.0, -1.0e-9, 2.0e-9, -2.0e-9, 1.0e-9]),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        t = case[\"emission_times\"]\n        reflector_pos = case[\"reflector_positions\"]\n        assign_idx = case[\"assignment_indices\"]\n        c0_true = case[\"c0_true\"]\n        c1_true = case[\"c1_true\"]\n        epsilon = case[\"noise\"]\n\n        n_obs = len(t)\n        y = np.zeros(n_obs)\n\n        for i in range(n_obs):\n            # 1. Compute range Ri\n            pos = reflector_pos[assign_idx[i]]\n            # LiDAR emitter is at origin (0,0,0)\n            range_i = np.linalg.norm(pos)\n\n            # 2. Compute expected round-trip time tau_i\n            tau_i = 2.0 * range_i / C_LIGHT\n\n            # 3. Form observed times t_obs_i\n            t_obs_i = t[i] + tau_i + c0_true + c1_true * t[i] + epsilon[i]\n\n            # 4. Compute residuals y_i\n            y[i] = t_obs_i - t[i] - tau_i\n            \n        # 5. Estimate c0 and c1 via linear least squares\n        # The model is y_i = c0 + c1 * t_i\n        # We solve y = X * c_hat\n        # where X is the design matrix and c_hat = [c0, c1]^T.\n        X = np.ones((n_obs, 2))\n        X[:, 1] = t\n\n        # Solve the least-squares problem using numpy.linalg.lstsq\n        # It's more numerically stable than computing the inverse of X.T @ X\n        c_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        c0_hat = c_hat[0]\n        c1_hat = c_hat[1]\n\n        # 6. Append rounded results. The formatting string handles rounding.\n        results.append(c0_hat)\n        results.append(c1_hat)\n\n    # Final print statement in the exact required format.\n    # The format string '{:.12f}' correctly rounds to 12 decimal places for printing.\n    print(f\"[{','.join([f'{val:.12f}' for val in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了将LiDAR的距离测量值转换成全局坐标系下的三维点云，我们需要传感器在每次发射脉冲瞬间的精确姿态。然而，IMU的姿态数据采样率通常与LiDAR的发射频率不同，这就需要对姿态进行插值。由于旋转在几何上很特殊，我们必须采用一种正确的方法，即单位四元数的球面线性插值（Slerp），它能在旋转超球面上找到最短的恒速路径。这个高级编程练习  将指导您实现Slerp算法，这是机器人学、航空航天和遥感领域的核心算法，用于精确确定传感器在任意给定时间的姿态。",
            "id": "3824565",
            "problem": "在遥感和环境建模中，激光雷达（Light Detection and Ranging, LiDAR）需要将每个发射的激光脉冲精确地地理配准到地球固定坐标系。这种地理配准依赖于惯性测量单元（Inertial Measurement Unit, IMU）提供的平台姿态。由于 IMU 姿态是在离散时刻采样的，而 LiDAR 的发射时间是异步的，因此需要在旋转流形上采用一种插值方案。将姿态表示为单位四元数，并使用单位四元数超球面上的球面线性插值在 IMU 时刻之间进行插值。通过将 LiDAR 发射时刻的插值姿态与已知的、解析定义的地面真值姿态函数进行比较，来量化插值误差。\n\n从以下基本原理开始：\n- 三维空间中的旋转构成了特殊正交群 $\\mathrm{SO}(3)$。单位四元数 $q(t)$ 是 $3$-球面 $S^3$ 上的一个点，代表 $\\mathrm{SO}(3)$ 中的一个元素，并满足单位范数约束 $\\lVert q(t) \\rVert = 1$。四元数 $q$ 和 $-q$ 代表相同的物理旋转。\n- 两个单位四元数之间的最短旋转对应于 $S^3$ 上的大圆弧。沿此弧线进行插值可以保持单位范数和恒定的角速度。\n- 两个旋转之间的角度差可以通过它们相对旋转的角度来衡量，该角度与四元数 $q_{\\text{rel}} = q_{\\text{est}}^{-1} q_{\\text{true}}$ 相关联。\n\n您的任务是实现 IMU 时刻之间的四元数球面线性插值，以与 LiDAR 发射时间对齐，并计算一组测试用例的平均角度插值误差。所有三角函数的计算在内部必须以弧度为单位执行。要求的输出是角度误差，单位为度。从欧拉角构造四元数的旋转约定必须是标准的偏航-俯仰-滚转，即依次绕 $z-y-x$ 轴旋转。\n\n定义和要求：\n- 单位四元数是一个有序元组 $q = (w, x, y, z)$，其中 $\\lVert q \\rVert = 1$，$w$ 是标量部分，$(x, y, z)$ 是向量部分。\n- 使用偏航-俯仰-滚转角 $(\\psi(t), \\theta(t), \\phi(t))$ 将地面真值方向定义为时间 $t$ 的解析函数。\n- 给定 IMU 时刻 $t_0, t_1, \\dots$ 和 LiDAR 发射时间 $\\tau_1, \\tau_2, \\dots$，对于区间 $[t_k, t_{k+1}]$ 中的每个 $\\tau$，使用球面线性插值在 $q(t_k)$ 和 $q(t_{k+1})$ 之间进行姿态插值，并与时间 $\\tau$ 的地面真值四元数进行比较。\n\n角度单位规范：\n- 内部计算角度时使用弧度。\n- 以度为单位表示最终的平均角度插值误差，四舍五入到六位小数。\n\n误差计算：\n- 对于每个 LiDAR 发射时间 $\\tau$，计算插值得到的四元数 $\\hat{q}(\\tau)$ 和地面真值四元数 $q(\\tau)$。构建相对旋转 $q_{\\text{rel}}(\\tau) = \\hat{q}(\\tau)^{-1} q(\\tau)$ 并计算其旋转角 $\\Delta(\\tau)$。\n- 对于每个测试用例，报告所有 LiDAR 发射时间的 $\\Delta(\\tau)$ 的平均值，单位为度。\n\n测试套件：\n- 用例 A（平滑运动，理想路径）：\n  - IMU 时刻（秒）：$0.0, 0.5, 1.0, 1.5, 2.0$。\n  - LiDAR 发射时间（秒）：$0.05, 0.10, 0.15, \\dots, 1.95$，增量为 $0.05$（含）。\n  - 地面真值偏航、俯仰、滚转（度）：$\\psi(t) = 12 t$，$\\theta(t) = 2 \\sin(2 \\pi t)$，$\\phi(t) = 0.5 \\cos(\\pi t)$。\n- 用例 B（对跖四元数符号边缘情况）：\n  - IMU 时刻（秒）：$0.0, 1.0$。\n  - LiDAR 发射时间（秒）：$0.0, 0.1, 0.2, \\dots, 1.0$，增量为 $0.1$（含）。\n  - 地面真值偏航、俯仰、滚转（度）：$\\psi(t) = 179$，$\\theta(t) = 0$，$\\phi(t) = 0$（恒定方向）。\n  - IMU 四元数：设 $q(0.0)$ 等于 $t = 0.0$ 时的地面真值；设 $q(1.0)$ 为 $t = 1.0$ 时地面真值四元数的负值，以模拟符号模糊性，它代表相同的旋转。\n- 用例 C（边界条件和极小区间）：\n  - IMU 时刻（秒）：$0.0, 0.001$。\n  - LiDAR 发射时间（秒）：$0.0, 0.00025, 0.0005, 0.00075, 0.001$。\n  - 地面真值偏航、俯仰、滚转（度）：$\\psi(t) = 100 t$，$\\theta(t) = 0$，$\\phi(t) = 0$。\n\n程序要求：\n- 对于每个测试用例，根据指定的偏航-俯仰-滚转函数构造地面真值四元数 $q(t)$。\n- 对于每个 LiDAR 时间 $\\tau$，找到相邻的 IMU 时刻区间 $[t_k, t_{k+1}]$，使得 $t_k \\le \\tau \\le t_{k+1}$，并使用球面线性插值在 $q(t_k)$ 和 $q(t_{k+1})$ 之间进行插值。\n- 从相对四元数计算 $\\Delta(\\tau)$（以弧度为单位），并将其转换为度。\n- 对于每个测试用例，计算所有 LiDAR 发射时间的 $\\Delta(\\tau)$ 的平均值。\n- 输出必须是单行文本，包含用例 A、B 和 C 的三个平均误差（单位为度），四舍五入到六位小数，以逗号分隔并用方括号括起来（例如，$[\\text{A},\\text{B},\\text{C}]$）。\n\n您的程序应生成一行输出，其中包含用逗号分隔并用方括号括起来的结果列表（例如，$[0.012345,0.000001,0.000100]$）。这些值必须是指定格式的浮点数。不允许有其他输出。",
            "solution": "三维空间中刚体的旋转可以用一个单位四元数 $q \\in S^3 \\subset \\mathbb{R}^4$ 来表示，它映射到特殊正交群 $\\mathrm{SO}(3)$ 的一个元素。该四元数编码了一个绕单位轴 $\\hat{\\mathbf{u}}$ 的旋转角 $\\theta$，其对应关系为 $q = (\\cos(\\theta/2), \\sin(\\theta/2) \\hat{\\mathbf{u}})$，这确保了单位范数约束 $\\lVert q \\rVert = 1$。两个四元数 $q$ 和 $-q$ 代表相同的物理旋转，因为它们在 $S^3$ 上以符号翻转的方式编码了相同的轴-角对。\n\n我们需要一种插值方法，该方法能保持单位范数并沿两个方向之间在 $S^3$ 上的最短路径，即大圆弧。球面线性插值（Slerp）源于 $S^3$ 的测地线结构。给定两个单位四元数 $q_0$ 和 $q_1$，其点积为 $d = q_0 \\cdot q_1$，它们在 $S^3$ 上的夹角为 $\\theta = \\arccos(d)$，其中 $d \\in [-1, 1]$。由 $u \\in [0, 1]$ 参数化的测地线弧被构造成使得插值四元数 $q(u)$ 满足 $q(0) = q_0$，$q(1) = q_1$，保持单位范数，并以恒定的角速度沿弧线演化。\n\n为确保路径最短，如果 $d  0$，我们将第二个四元数翻转为 $q_1 \\leftarrow -q_1$，使其点积变为非负值 $d \\leftarrow -d$，因为 $q_1$ 和 $-q_1$ 代表相同的旋转，但这样选择了 $S^3$ 上更近的点。对于一般情况 $|d|  1$ 且不太接近 $\\pm 1$，插值是通过切空间中的线性组合，再通过球面三角学映射回来构造的：\n$$\nq(u) = \\frac{\\sin((1-u)\\theta)}{\\sin(\\theta)} q_0 + \\frac{\\sin(u \\theta)}{\\sin(\\theta)} q_1,\n$$\n根据构造，该结果是单位范数的，因为它位于大圆上。如果 $d$ 非常接近 $1$，即 $\\theta \\approx 0$，极限情况将简化为 $\\mathbb{R}^4$ 中的直线，然后进行重新归一化：\n$$\nq(u) \\approx \\frac{(1-u) q_0 + u q_1}{\\lVert (1-u) q_0 + u q_1 \\rVert}.\n$$\n这为接近重合的旋转提供了数值稳定性。\n\n为了量化在 IMU 时刻区间 $[t_k, t_{k+1}]$ 内的 LiDAR 发射时间 $\\tau$ 处的插值误差，我们设置 $u = \\frac{\\tau - t_k}{t_{k+1} - t_k} \\in [0,1]$，计算 $\\hat{q}(\\tau) = \\mathrm{Slerp}(q(t_k), q(t_{k+1}), u)$，并与地面真值四元数 $q(\\tau)$ 进行比较。相对旋转四元数为\n$$\nq_{\\text{rel}}(\\tau) = \\hat{q}(\\tau)^{-1} q(\\tau),\n$$\n对于单位四元数，其逆是其共轭：$q^{-1} = (w, -x, -y, -z)$。$q_{\\text{rel}}$ 的旋转角为\n$$\n\\Delta(\\tau) = 2 \\arctan2\\left(\\sqrt{x^2 + y^2 + z^2}, \\, |w|\\right),\n$$\n这等于 $2 \\arccos(w)$，但需要适当的钳位以保证数值稳定性。我们以弧度计算 $\\Delta(\\tau)$，通过乘以 $\\frac{180}{\\pi}$ 将其转换为度，并对所有 LiDAR 发射时间取平均，从而为每个测试用例生成一个标量平均误差。\n\n为了从偏航-俯仰-滚转角 $(\\psi, \\theta, \\phi)$ 构造地面真值四元数，我们采用标准的 $z-y-x$ 旋转约定（先绕 $z$ 轴偏航，然后绕 $y$ 轴俯仰，最后绕 $x$ 轴滚转）。设 $q_z(\\psi)$、$q_y(\\theta)$ 和 $q_x(\\phi)$ 分别为纯轴旋转的单位四元数。组合旋转的四元数为\n$$\nq(\\psi, \\theta, \\phi) = q_z(\\psi) \\, q_y(\\theta) \\, q_x(\\phi),\n$$\n使用汉密尔顿积进行四元数乘法。每个基本四元数由其轴-角定义：对于轴 $\\hat{\\mathbf{e}}$ 和角 $\\alpha$，有 $q = \\left( \\cos(\\alpha/2), \\, \\sin(\\alpha/2) \\hat{\\mathbf{e}} \\right)$，其中 $\\hat{\\mathbf{e}}$ 是笛卡尔坐标轴之一。数值实现时，所有三角函数计算前都将角度从度转换为弧度。\n\n算法：\n- 定义四元数运算：归一化、汉密尔顿积、共轭/逆、点积。\n- 实现 Slerp，并处理点积符号及接近零角度时的线性回退。\n- 实现从偏航-俯仰-滚转角到单位四元数的转换，遵循 $z-y-x$ 约定。\n- 对于每个测试用例，按规定定义 IMU 时刻和 LiDAR 发射时间；定义地面真值偏航-俯仰-滚转角函数（单位为度），并转换为弧度以计算四元数。\n- 对于用例 A：IMU 时刻为 $0.0, 0.5, 1.0, 1.5, 2.0$ 秒；LiDAR 时间以 $0.05$ 秒为增量；地面真值角度为 $\\psi(t) = 12 t$，$\\theta(t) = 2 \\sin(2 \\pi t)$，$\\phi(t) = 0.5 \\cos(\\pi t)$（度）。\n- 对于用例 B：IMU 时刻为 $0.0, 1.0$ 秒，其中 $q(1.0)$ 设置为 $t=1.0$ 时地面真值四元数的负值，以模拟对跖符号；LiDAR 时间以 $0.1$ 秒为增量；地面真值恒定角度为 $\\psi(t) = 179$，$\\theta(t) = 0$，$\\phi(t) = 0$（度）。\n- 对于用例 C：IMU 时刻为 $0.0, 0.001$ 秒；LiDAR 时间为 $0.0, 0.00025, 0.0005, 0.00075, 0.001$ 秒；地面真值角度为 $\\psi(t) = 100 t$，$\\theta(t) = 0$，$\\phi(t) = 0$（度）。\n- 对于每个 LiDAR 时间 $\\tau$，通过 IMU 时刻将其框定，计算 $u$，插值得到 $\\hat{q}(\\tau)$，计算 $q(\\tau)$，形成 $q_{\\text{rel}}(\\tau)$，计算 $\\Delta(\\tau)$（以弧度为单位），转换为度，并求平均值。\n\n最后，将用例 A、B 和 C 的平均误差输出到单行文本中，格式为逗号分隔的列表并用方括号括起来，每个值四舍五入到六位小数。此程序设计遵循了 $S^3$ 上的旋转几何，并量化了四元数球面插值如何将 IMU 姿态与 LiDAR 事件时间对齐，展示了采样、符号模糊性和边界条件的影响。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef quat_normalize(q: np.ndarray) - np.ndarray:\n    \"\"\"Normalize a quaternion to unit norm.\"\"\"\n    norm = np.linalg.norm(q)\n    if norm == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n    return q / norm\n\ndef quat_multiply(q1: np.ndarray, q2: np.ndarray) - np.ndarray:\n    \"\"\"Hamilton product of two quaternions (w,x,y,z).\"\"\"\n    w1, x1, y1, z1 = q1\n    w2, x2, y2, z2 = q2\n    w = w1*w2 - x1*x2 - y1*y2 - z1*z2\n    x = w1*x2 + x1*w2 + y1*z2 - z1*y2\n    y = w1*y2 - x1*z2 + y1*w2 + z1*x2\n    z = w1*z2 + x1*y2 - y1*x2 + z1*w2\n    return np.array([w, x, y, z])\n\ndef quat_conjugate(q: np.ndarray) - np.ndarray:\n    \"\"\"Conjugate of a quaternion (inverse for unit quaternion).\"\"\"\n    w, x, y, z = q\n    return np.array([w, -x, -y, -z])\n\ndef quat_dot(q1: np.ndarray, q2: np.ndarray) - float:\n    \"\"\"Dot product of two quaternions.\"\"\"\n    return float(np.dot(q1, q2))\n\ndef slerp(q0: np.ndarray, q1: np.ndarray, u: float) - np.ndarray:\n    \"\"\"\n    Spherical linear interpolation between unit quaternions q0 and q1 for parameter u in [0,1].\n    Handles antipodal quaternions and near-zero angles with linear fallback.\n    \"\"\"\n    q0 = quat_normalize(q0)\n    q1 = quat_normalize(q1)\n    dot = quat_dot(q0, q1)\n\n    # If dot is negative, flip sign of q1 to ensure shortest path\n    if dot  0.0:\n        q1 = -q1\n        dot = -dot\n\n    # Clamp dot for numerical stability\n    dot = max(min(dot, 1.0), -1.0)\n\n    # If the quaternions are very close, use linear interpolation\n    if dot  0.9995:\n        q = (1.0 - u) * q0 + u * q1\n        return quat_normalize(q)\n\n    theta = np.arccos(dot)\n    sin_theta = np.sin(theta)\n    a = np.sin((1.0 - u) * theta) / sin_theta\n    b = np.sin(u * theta) / sin_theta\n    q = a * q0 + b * q1\n    return quat_normalize(q)\n\ndef euler_zyx_to_quat(roll: float, pitch: float, yaw: float) - np.ndarray:\n    \"\"\"\n    Convert yaw-pitch-roll (ZYX order) angles in radians to a unit quaternion.\n    yaw about z, then pitch about y, then roll about x.\n    \"\"\"\n    cz = np.cos(yaw / 2.0)\n    sz = np.sin(yaw / 2.0)\n    cy = np.cos(pitch / 2.0)\n    sy = np.sin(pitch / 2.0)\n    cx = np.cos(roll / 2.0)\n    sx = np.sin(roll / 2.0)\n\n    # q = qz * qy * qx\n    qz = np.array([cz, 0.0, 0.0, sz])\n    qy = np.array([cy, 0.0, sy, 0.0])\n    qx = np.array([cx, sx, 0.0, 0.0])\n\n    q = quat_multiply(quat_multiply(qz, qy), qx)\n    return quat_normalize(q)\n\ndef quat_angle_deg(q_est: np.ndarray, q_true: np.ndarray) - float:\n    \"\"\"\n    Compute the angular difference between two unit quaternions in degrees.\n    \"\"\"\n    q_est = quat_normalize(q_est)\n    q_true = quat_normalize(q_true)\n    q_rel = quat_multiply(quat_conjugate(q_est), q_true)\n    w, x, y, z = q_rel\n    # Clamp w to valid range for arccos\n    w = max(min(w, 1.0), -1.0)\n    # Robust relative angle using atan2 of vector norm and scalar part\n    angle_rad = 2.0 * np.arctan2(np.linalg.norm([x, y, z]), abs(w))\n    angle_deg = angle_rad * (180.0 / np.pi)\n    return angle_deg\n\ndef ground_truth_case_A(t: float) - np.ndarray:\n    \"\"\"\n    Case A ground truth quaternion at time t (seconds).\n    Angles: yaw=12*t deg, pitch=2*sin(2*pi*t) deg, roll=0.5*cos(pi*t) deg.\n    \"\"\"\n    yaw_deg = 12.0 * t\n    pitch_deg = 2.0 * np.sin(2.0 * np.pi * t)\n    roll_deg = 0.5 * np.cos(np.pi * t)\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef ground_truth_case_B(t: float) - np.ndarray:\n    \"\"\"\n    Case B ground truth quaternion at time t (seconds).\n    Constant orientation: yaw=179 deg, pitch=0 deg, roll=0 deg.\n    \"\"\"\n    yaw_deg = 179.0\n    pitch_deg = 0.0\n    roll_deg = 0.0\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef ground_truth_case_C(t: float) - np.ndarray:\n    \"\"\"\n    Case C ground truth quaternion at time t (seconds).\n    Yaw=100*t deg, pitch=0 deg, roll=0 deg.\n    \"\"\"\n    yaw_deg = 100.0 * t\n    pitch_deg = 0.0\n    roll_deg = 0.0\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef mean_interpolation_error_deg(imu_times, lidar_times, gt_func, imu_quat_override=None):\n    \"\"\"\n    Compute mean angular error in degrees by Slerp interpolation between IMU epoch quaternions.\n    Optionally override IMU quaternions for edge-case simulation.\n    \"\"\"\n    # Convert to numpy arrays for efficient processing\n    imu_times = np.array(imu_times)\n    lidar_times = np.array(lidar_times)\n\n    # Compute IMU quaternions from ground truth unless overridden\n    imu_quats = []\n    for t in imu_times:\n        if imu_quat_override is not None and t in imu_quat_override:\n            imu_quats.append(imu_quat_override[t])\n        else:\n            imu_quats.append(gt_func(t))\n    imu_quats = [quat_normalize(q) for q in imu_quats]\n\n    errors = []\n    for tau in lidar_times:\n        # Find bracketing IMU index k such that imu_times[k] = tau = imu_times[k+1]\n        k = np.searchsorted(imu_times, tau, side='right') - 1\n        k = np.clip(k, 0, len(imu_times) - 2)\n\n        t0 = imu_times[k]\n        t1 = imu_times[k+1]\n        q0 = imu_quats[k]\n        q1 = imu_quats[k+1]\n\n        # Handle exact epoch times or zero interval\n        if t1 == t0:\n            u = 0.0\n        else:\n            u = (tau - t0) / (t1 - t0)\n\n        q_interp = slerp(q0, q1, u)\n        q_true = gt_func(tau)\n        err_deg = quat_angle_deg(q_interp, q_true)\n        errors.append(err_deg)\n        \n    return float(np.mean(errors))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    imu_times_A = [0.0, 0.5, 1.0, 1.5, 2.0]\n    lidar_times_A = [round(x, 2) for x in np.arange(0.05, 2.0, 0.05)]\n    # Case B\n    imu_times_B = [0.0, 1.0]\n    lidar_times_B = [round(x, 1) for x in np.arange(0.0, 1.0 + 1e-12, 0.1)]\n    # Override IMU quaternions: q(1.0) = -q_true(1.0)\n    imu_quat_override_B = {\n        0.0: ground_truth_case_B(0.0),\n        1.0: -ground_truth_case_B(1.0)\n    }\n    # Case C\n    imu_times_C = [0.0, 0.001]\n    lidar_times_C = [0.0, 0.00025, 0.0005, 0.00075, 0.001]\n\n    results = []\n    # Case A mean error\n    err_A = mean_interpolation_error_deg(imu_times_A, lidar_times_A, ground_truth_case_A)\n    # Case B mean error with antipodal override\n    err_B = mean_interpolation_error_deg(imu_times_B, lidar_times_B, ground_truth_case_B, imu_quat_override=imu_quat_override_B)\n    # Case C mean error\n    err_C = mean_interpolation_error_deg(imu_times_C, lidar_times_C, ground_truth_case_C)\n\n    # Round to six decimal places as required\n    formatted = [f\"{x:.6f}\" for x in [err_A, err_B, err_C]]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}