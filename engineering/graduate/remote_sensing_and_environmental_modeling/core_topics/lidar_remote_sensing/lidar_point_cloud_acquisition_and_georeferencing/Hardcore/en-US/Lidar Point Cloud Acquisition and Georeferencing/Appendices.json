{
    "hands_on_practices": [
        {
            "introduction": "The journey of a LiDAR point from sensor to ground begins with the precise orientation of the laser beam within the scanner's own coordinate system. This exercise challenges you to derive the beam's line-of-sight vector from first principles, using the law of reflection and 3D rotation matrices to model an oscillating mirror scanner . By contrasting this physically rigorous derivation with a common simplified calibration model, you will gain critical insight into the subtle geometric errors that can arise from model approximations in georeferencing.",
            "id": "3824516",
            "problem": "A Light Detection and Ranging (LiDAR) scanner uses a planar oscillating mirror to deflect a laser beam emitted along a fixed axis in the scanner frame. Consider the scanner coordinate frame $\\mathcal{S}$ with axes $(x_{\\mathcal{S}}, y_{\\mathcal{S}}, z_{\\mathcal{S}})$, where the incident ray direction is the unit vector $d_{\\mathrm{in}} = [0,\\,0,\\,1]^{\\top}$. The mirror’s nominal unit normal at zero scan is $n_{0} = [\\sin\\beta,\\,0,\\,\\cos\\beta]^{\\top}$, with $\\beta = \\pi/4$. The mirror rotates about the $y_{\\mathcal{S}}$-axis by a scan angle $\\theta$, and the mirror mount has a small fixed elevation offset $\\delta$ realized as a rotation about the $x_{\\mathcal{S}}$-axis. The mirror normal under scan is therefore $n(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(\\theta)\\,n_{0}$, where $R_{x}$ and $R_{y}$ are standard right-handed rotation matrices about the $x$ and $y$ axes, respectively. The outgoing beam direction (the unit line-of-sight vector) is obtained from the law of reflection: $u_{s}(\\theta,\\delta) = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n(\\theta,\\delta))\\,n(\\theta,\\delta)$.\n\nA sensor calibration model used in georeferencing approximates the mapping from mirror scan angle to outgoing direction by applying a yaw rotation of $2\\theta$ about $y_{\\mathcal{S}}$ to the nominal reflected direction at zero scan, followed by the elevation offset $\\delta$ about $x_{\\mathcal{S}}$. That is, with $u_{0} = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n_{0})\\,n_{0}$, the calibration-predicted unit vector is $u_{\\mathrm{cal}}(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(2\\theta)\\,u_{0}$.\n\nStarting from the fundamental law of reflection and the definitions of $R_{x}$ and $R_{y}$, derive the explicit expression for $u_{s}(\\theta,\\delta)$ in the scanner frame, and then form $u_{\\mathrm{cal}}(\\theta,\\delta)$. Using these, compute the angular residual $\\Delta\\varphi(\\theta,\\delta)$ between $u_{s}$ and $u_{\\mathrm{cal}}$ defined by $\\Delta\\varphi(\\theta,\\delta) = \\arccos\\!\\big(u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta)\\big)$. Evaluate $\\Delta\\varphi$ for $\\theta = 30^{\\circ}$ and $\\delta = 2^{\\circ}$, and express the final angle in degrees. Round your answer to four significant figures.",
            "solution": "The principal task is to determine the angular residual $\\Delta\\varphi(\\theta,\\delta)$ between the physically correct line-of-sight vector, $u_{s}(\\theta,\\delta)$, and an approximate vector derived from a calibration model, $u_{\\mathrm{cal}}(\\theta,\\delta)$. The residual is defined by $\\Delta\\varphi(\\theta,\\delta) = \\arccos\\!\\big(u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta)\\big)$. The analysis requires deriving explicit expressions for both vectors, computing their dot product, and then evaluating the result for the given angles $\\theta = 30^{\\circ}$ and $\\delta = 2^{\\circ}$.\n\nFirst, we establish the fundamental mathematical entities. The standard right-handed rotation matrices about the $x$- and $y$-axes are given by:\n$$ R_{x}(\\alpha) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{pmatrix}, \\quad R_{y}(\\alpha) = \\begin{pmatrix} \\cos\\alpha & 0 & \\sin\\alpha \\\\ 0 & 1 & 0 \\\\ -\\sin\\alpha & 0 & \\cos\\alpha \\end{pmatrix} $$\nThe incident laser beam direction is $d_{\\mathrm{in}} = [0,\\,0,\\,1]^{\\top}$. The nominal mirror normal is $n_{0} = [\\sin\\beta,\\,0,\\,\\cos\\beta]^{\\top}$ with $\\beta = \\pi/4$.\nSubstituting $\\beta = \\pi/4$, we get $\\sin(\\pi/4) = 1/\\sqrt{2}$ and $\\cos(\\pi/4) = 1/\\sqrt{2}$. Thus,\n$$ n_{0} = \\begin{pmatrix} 1/\\sqrt{2} \\\\ 0 \\\\ 1/\\sqrt{2} \\end{pmatrix} $$\nWe begin by calculating the nominal reflected direction at zero scan, $u_{0}$, using the law of reflection:\n$$ u_{0} = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n_{0})\\,n_{0} $$\nThe dot product is $d_{\\mathrm{in}}\\cdot n_{0} = (0)(1/\\sqrt{2}) + (0)(0) + (1)(1/\\sqrt{2}) = 1/\\sqrt{2}$.\nSubstituting this into the expression for $u_0$:\n$$ u_{0} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - 2\\left(\\frac{1}{\\sqrt{2}}\\right) \\begin{pmatrix} 1/\\sqrt{2} \\\\ 0 \\\\ 1/\\sqrt{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n\nNext, we derive the expression for the physically correct reflected vector $u_{s}(\\theta,\\delta)$. This requires first finding the mirror normal under scan, $n(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(\\theta)\\,n_{0}$.\n$$ R_{y}(\\theta)n_{0} = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} 1/\\sqrt{2} \\\\ 0 \\\\ 1/\\sqrt{2} \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ 0 \\\\ \\cos\\theta - \\sin\\theta \\end{pmatrix} $$\n$$ n(\\theta,\\delta) = R_{x}(\\delta)(R_{y}(\\theta)n_{0}) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\delta & -\\sin\\delta \\\\ 0 & \\sin\\delta & \\cos\\delta \\end{pmatrix} \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ 0 \\\\ \\cos\\theta - \\sin\\theta \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ -\\sin\\delta(\\cos\\theta - \\sin\\theta) \\\\ \\cos\\delta(\\cos\\theta - \\sin\\theta) \\end{pmatrix} $$\nThe dot product with the incident ray is $d_{\\mathrm{in}}\\cdot n(\\theta,\\delta) = n_z(\\theta,\\delta) = \\frac{1}{\\sqrt{2}}\\cos\\delta(\\cos\\theta - \\sin\\theta)$.\nNow, we compute $u_{s}(\\theta,\\delta) = d_{\\mathrm{in}} - 2\\,(d_{\\mathrm{in}}\\cdot n(\\theta,\\delta))\\,n(\\theta,\\delta)$:\n$$ u_{s} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - 2\\left(\\frac{1}{\\sqrt{2}}\\cos\\delta(\\cos\\theta - \\sin\\theta)\\right) \\left(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ -\\sin\\delta(\\cos\\theta - \\sin\\theta) \\\\ \\cos\\delta(\\cos\\theta - \\sin\\theta) \\end{pmatrix}\\right) $$\n$$ u_{s} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} - \\cos\\delta(\\cos\\theta - \\sin\\theta) \\begin{pmatrix} \\cos\\theta + \\sin\\theta \\\\ -\\sin\\delta(\\cos\\theta - \\sin\\theta) \\\\ \\cos\\delta(\\cos\\theta - \\sin\\theta) \\end{pmatrix} $$\nThe components of $u_s$ are:\n$(u_{s})_x = -\\cos\\delta(\\cos\\theta - \\sin\\theta)(\\cos\\theta + \\sin\\theta) = -\\cos\\delta(\\cos^2\\theta - \\sin^2\\theta) = -\\cos\\delta\\cos(2\\theta)$.\n$(u_{s})_y = \\sin\\delta\\cos\\delta(\\cos\\theta - \\sin\\theta)^2 = \\sin\\delta\\cos\\delta(\\cos^2\\theta - 2\\sin\\theta\\cos\\theta + \\sin^2\\theta) = \\frac{1}{2}\\sin(2\\delta)(1 - \\sin(2\\theta))$.\n$(u_{s})_z = 1 - \\cos^2\\delta(\\cos\\theta - \\sin\\theta)^2 = 1 - \\cos^2\\delta(1 - \\sin(2\\theta)) = \\sin^2\\delta + \\cos^2\\delta\\sin(2\\theta)$.\nSo, $u_{s}(\\theta,\\delta) = \\begin{pmatrix} -\\cos\\delta\\cos(2\\theta) \\\\ \\frac{1}{2}\\sin(2\\delta)(1 - \\sin(2\\theta)) \\\\ \\sin^2\\delta + \\cos^2\\delta\\sin(2\\theta) \\end{pmatrix}$.\n\nNow, we derive the calibration-predicted vector $u_{\\mathrm{cal}}(\\theta,\\delta) = R_{x}(\\delta)\\,R_{y}(2\\theta)\\,u_{0}$.\n$$ R_{y}(2\\theta)u_{0} = \\begin{pmatrix} \\cos(2\\theta) & 0 & \\sin(2\\theta) \\\\ 0 & 1 & 0 \\\\ -\\sin(2\\theta) & 0 & \\cos(2\\theta) \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\cos(2\\theta) \\\\ 0 \\\\ \\sin(2\\theta) \\end{pmatrix} $$\n$$ u_{\\mathrm{cal}}(\\theta,\\delta) = R_{x}(\\delta) (R_{y}(2\\theta)u_{0}) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\delta & -\\sin\\delta \\\\ 0 & \\sin\\delta & \\cos\\delta \\end{pmatrix} \\begin{pmatrix} -\\cos(2\\theta) \\\\ 0 \\\\ \\sin(2\\theta) \\end{pmatrix} = \\begin{pmatrix} -\\cos(2\\theta) \\\\ -\\sin\\delta\\sin(2\\theta) \\\\ \\cos\\delta\\sin(2\\theta) \\end{pmatrix} $$\n\nThe next step is to compute the dot product $u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta)$.\n$$ (u_s \\cdot u_{\\mathrm{cal}}) = (-\\cos\\delta\\cos(2\\theta))(-\\cos(2\\theta)) + \\left(\\frac{1}{2}\\sin(2\\delta)(1 - \\sin(2\\theta))\\right)(-\\sin\\delta\\sin(2\\theta)) + (\\sin^2\\delta + \\cos^2\\delta\\sin(2\\theta))(\\cos\\delta\\sin(2\\theta)) $$\nLet's expand and simplify this expression term by term:\nTerm 1: $\\cos\\delta\\cos^2(2\\theta)$.\nTerm 2: Using $\\frac{1}{2}\\sin(2\\delta) = \\sin\\delta\\cos\\delta$, this becomes $-\\sin^2\\delta\\cos\\delta\\sin(2\\theta)(1 - \\sin(2\\theta)) = -\\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin^2(2\\theta)$.\nTerm 3: $\\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\cos^3\\delta\\sin^2(2\\theta)$.\nSumming all terms:\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) - \\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin^2(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin(2\\theta) + \\cos^3\\delta\\sin^2(2\\theta) $$\nThe terms $-\\sin^2\\delta\\cos\\delta\\sin(2\\theta)$ and $+\\sin^2\\delta\\cos\\delta\\sin(2\\theta)$ cancel.\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) + \\sin^2\\delta\\cos\\delta\\sin^2(2\\theta) + \\cos^3\\delta\\sin^2(2\\theta) $$\nFactor out $\\cos\\delta$ from the first term and $\\cos\\delta\\sin^2(2\\theta)$ from the last two:\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) + (\\sin^2\\delta + \\cos^2\\delta)\\cos\\delta\\sin^2(2\\theta) $$\nUsing the identity $\\sin^2\\delta + \\cos^2\\delta = 1$:\n$$ u_s \\cdot u_{\\mathrm{cal}} = \\cos\\delta\\cos^2(2\\theta) + \\cos\\delta\\sin^2(2\\theta) = \\cos\\delta(\\cos^2(2\\theta) + \\sin^2(2\\theta)) $$\nUsing the identity $\\cos^2(2\\theta) + \\sin^2(2\\theta) = 1$:\n$$ u_{s}(\\theta,\\delta)\\cdot u_{\\mathrm{cal}}(\\theta,\\delta) = \\cos\\delta $$\nThis remarkably simple result can be understood geometrically. The calibration model $u_{\\mathrm{cal}} = R_x(\\delta) R_y(2\\theta) u_0$ is equivalent to $R_x(\\delta) u_s(\\theta,0)$. Using the identity for reflections behaving under rotation, $R_x(\\delta) u_s(\\theta,0) = R_x(\\delta) \\mathrm{Refl}_{R_y(\\theta)n_0}(d_{in}) = \\mathrm{Refl}_{R_x(\\delta)R_y(\\theta)n_0}(R_x(\\delta)d_{in})$. The true vector is $u_s(\\theta,\\delta) = \\mathrm{Refl}_{R_x(\\delta)R_y(\\theta)n_0}(d_{in})$. Since reflection is an isometry, it preserves the angle between vectors. Therefore, the angle between $u_s$ and $u_{\\mathrm{cal}}$ is equal to the angle between the pre-image vectors $d_{in}$ and $R_x(\\delta)d_{in}$. Their dot product is $d_{in} \\cdot (R_x(\\delta)d_{in}) = [0,0,1]^\\top \\cdot [0, -\\sin\\delta, \\cos\\delta]^\\top = \\cos\\delta$.\n\nThe angular residual is thus:\n$$ \\Delta\\varphi(\\theta,\\delta) = \\arccos(u_s \\cdot u_{\\mathrm{cal}}) = \\arccos(\\cos\\delta) $$\nFor any physically realistic small offset angle $\\delta$, we can take the principal value, so $\\Delta\\varphi(\\theta,\\delta) = \\delta$.\nThe residual angle is independent of the scan angle $\\theta$ and is equal to the elevation offset angle $\\delta$.\n\nThe problem asks for the evaluation at $\\theta = 30^{\\circ}$ and $\\delta = 2^{\\circ}$.\n$$ \\Delta\\varphi = 2^{\\circ} $$\nRounding to four significant figures gives $2.000^{\\circ}$.",
            "answer": "$$ \\boxed{2.000} $$"
        },
        {
            "introduction": "A georeferenced point cloud is the product of fusing high-frequency laser measurements with lower-frequency navigation data from an Inertial Measurement Unit (IMU). This hands-on coding practice tackles the critical challenge of determining the sensor's precise attitude at each LiDAR pulse's firing time, which typically falls between IMU measurement epochs . You will implement quaternion spherical linear interpolation (Slerp), the geometrically correct method for interpolating rotations, to bridge this temporal gap and quantify the resulting interpolation error, a fundamental task in any high-precision mobile mapping workflow.",
            "id": "3824565",
            "problem": "In remote sensing and environmental modeling, Light Detection and Ranging (LiDAR) requires accurate georeferencing of each emitted laser pulse to the Earth-fixed frame. This georeferencing depends on the platform attitude provided by the Inertial Measurement Unit (IMU). Because IMU attitude is sampled at discrete epochs while LiDAR firing times are asynchronous, an interpolation scheme on the rotation manifold is required. Represent attitude as unit quaternions and interpolate between IMU epochs using spherical linear interpolation on the unit quaternion hypersphere. Quantify interpolation error by comparing the interpolated attitude at LiDAR firing times to a known, analytically defined ground-truth attitude function.\n\nStart from the following fundamental base:\n- Rotations in three dimensions form the special orthogonal group $\\mathrm{SO}(3)$. A unit quaternion $q(t)$ is a point on the $3$-sphere $S^3$ representing an element of $\\mathrm{SO}(3)$, with the unit-norm constraint $\\lVert q(t) \\rVert = 1$. Quaternions $q$ and $-q$ represent the same physical rotation.\n- The shortest rotation between two unit quaternions corresponds to the great-circle arc on $S^3$. Interpolation along this arc maintains unit norm and constant angular speed.\n- The angular difference between two rotations can be measured by the angle of their relative rotation, which is the angle associated with the quaternion $q_{\\text{rel}} = q_{\\text{est}}^{-1} q_{\\text{true}}$.\n\nYour task is to implement quaternion spherical linear interpolation between IMU epochs to align with LiDAR firing times and compute mean angular interpolation error for a set of test cases. All computations of trigonometric functions must be performed in radians internally. The requested output is angular errors in degrees. The rotation convention to construct quaternions from Euler angles must be the standard yaw–pitch–roll about the $z$–$y$–$x$ axes, applied in that order.\n\nDefinitions and requirements:\n- A unit quaternion is an ordered tuple $q = (w, x, y, z)$ with $\\lVert q \\rVert = 1$, where $w$ is the scalar part and $(x, y, z)$ is the vector part.\n- Use the yaw–pitch–roll angles $(\\psi(t), \\theta(t), \\phi(t))$ to define ground-truth orientation as an analytic function of time $t$.\n- Given IMU epoch times $t_0, t_1, \\dots$ and LiDAR firing times $\\tau_1, \\tau_2, \\dots$, for each $\\tau$ in an interval $[t_k, t_{k+1}]$, interpolate attitude between $q(t_k)$ and $q(t_{k+1})$ using spherical linear interpolation, and compare to the ground-truth quaternion at time $\\tau$.\n\nAngle unit specification:\n- Internally compute angles in radians.\n- Express final mean angular interpolation errors in degrees, rounded to six decimal places.\n\nError computation:\n- For each LiDAR firing time $\\tau$, compute the interpolated quaternion $\\hat{q}(\\tau)$ and the ground-truth quaternion $q(\\tau)$. Form the relative rotation $q_{\\text{rel}}(\\tau) = \\hat{q}(\\tau)^{-1} q(\\tau)$ and compute its rotation angle $\\Delta(\\tau)$.\n- For each test case, report the mean of $\\Delta(\\tau)$ across all LiDAR firing times in degrees.\n\nTest suite:\n- Case A (smooth motion, happy path):\n  - IMU epoch times in seconds: $0.0, 0.5, 1.0, 1.5, 2.0$.\n  - LiDAR firing times in seconds: $0.05, 0.10, 0.15, \\dots, 1.95$ in increments of $0.05$ (inclusive).\n  - Ground truth yaw, pitch, roll in degrees: $\\psi(t) = 12 t$, $\\theta(t) = 2 \\sin(2 \\pi t)$, $\\phi(t) = 0.5 \\cos(\\pi t)$.\n- Case B (antipodal quaternion sign edge case):\n  - IMU epoch times in seconds: $0.0, 1.0$.\n  - LiDAR firing times in seconds: $0.0, 0.1, 0.2, \\dots, 1.0$ in increments of $0.1$ (inclusive).\n  - Ground truth yaw, pitch, roll in degrees: $\\psi(t) = 179$, $\\theta(t) = 0$, $\\phi(t) = 0$ (constant orientation).\n  - IMU quaternions: set $q(0.0)$ equal to the ground truth at $t = 0.0$; set $q(1.0)$ to the negative of the ground truth quaternion at $t = 1.0$ to simulate the sign ambiguity, which represents the same rotation.\n- Case C (boundary condition and very small interval):\n  - IMU epoch times in seconds: $0.0, 0.001$.\n  - LiDAR firing times in seconds: $0.0, 0.00025, 0.0005, 0.00075, 0.001$.\n  - Ground truth yaw, pitch, roll in degrees: $\\psi(t) = 100 t$, $\\theta(t) = 0$, $\\phi(t) = 0$.\n\nProgram requirements:\n- Construct ground-truth quaternions $q(t)$ from the specified yaw–pitch–roll functions for each test case.\n- For each LiDAR time $\\tau$, find the adjacent IMU epoch interval $[t_k, t_{k+1}]$ such that $t_k \\le \\tau \\le t_{k+1}$ and interpolate with spherical linear interpolation between $q(t_k)$ and $q(t_{k+1})$.\n- Compute $\\Delta(\\tau)$ in radians from the relative quaternion and convert it to degrees.\n- For each test case, compute the mean of $\\Delta(\\tau)$ over all LiDAR firing times.\n- The output must be a single line containing the three mean errors for Cases A, B, and C, in degrees, rounded to six decimal places, as a comma-separated list enclosed in square brackets (for example, $[\\text{A},\\text{B},\\text{C}]$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[0.012345,0.000001,0.000100]$). The values must be floats as specified. No other output is permitted.",
            "solution": "The rotation of a rigid body in three dimensions can be represented by a unit quaternion $q \\in S^3 \\subset \\mathbb{R}^4$ that maps to an element of the special orthogonal group $\\mathrm{SO}(3)$. The quaternion encodes a rotation angle $\\theta$ about a unit axis $\\hat{\\mathbf{u}}$, with the correspondence $q = (\\cos(\\theta/2), \\sin(\\theta/2) \\hat{\\mathbf{u}})$, ensuring the unit-norm constraint $\\lVert q \\rVert = 1$. Two quaternions $q$ and $-q$ represent the same physical rotation because they encode the same axis-angle pair with a sign flip across $S^3$.\n\nWe require an interpolation method that preserves unit norm and follows the shortest path on $S^3$ between two orientations, i.e., the great-circle arc. Spherical linear interpolation (Slerp) arises from the geodesic structure of $S^3$. Given two unit quaternions $q_0$ and $q_1$ with dot product $d = q_0 \\cdot q_1$, the angle between them on $S^3$ is $\\theta = \\arccos(d)$ for $d \\in [-1, 1]$. The geodesic arc parameterized by $u \\in [0, 1]$ is constructed such that the interpolated quaternion $q(u)$ satisfies $q(0) = q_0$, $q(1) = q_1$, maintains unit norm, and evolves with constant angular velocity along the arc.\n\nTo ensure the shortest path, if $d < 0$ we flip the second quaternion $q_1 \\leftarrow -q_1$ so that the dot product becomes nonnegative, $d \\leftarrow -d$, because $q_1$ and $-q_1$ represent identical rotations but choose the nearer point on $S^3$. For the general case $|d| < 1$ and not too close to $\\pm 1$, the interpolation is constructed from the linear combination in the tangent space mapped back via spherical trigonometry:\n$$\nq(u) = \\frac{\\sin((1-u)\\theta)}{\\sin(\\theta)} q_0 + \\frac{\\sin(u \\theta)}{\\sin(\\theta)} q_1,\n$$\nwhich is unit-norm by construction since it lies on the great circle. If $d$ is very close to $1$, i.e., $\\theta \\approx 0$, the limit reduces to the straight line in $\\mathbb{R}^4$ followed by renormalization:\n$$\nq(u) \\approx \\frac{(1-u) q_0 + u q_1}{\\lVert (1-u) q_0 + u q_1 \\rVert}.\n$$\nThis yields numerical stability for near-coincident rotations.\n\nTo quantify interpolation error at a LiDAR firing time $\\tau$ within an IMU epoch interval $[t_k, t_{k+1}]$, set $u = \\frac{\\tau - t_k}{t_{k+1} - t_k} \\in [0,1]$, compute $\\hat{q}(\\tau) = \\mathrm{Slerp}(q(t_k), q(t_{k+1}), u)$, and compare to the ground-truth quaternion $q(\\tau)$. The relative rotation quaternion is\n$$\nq_{\\text{rel}}(\\tau) = \\hat{q}(\\tau)^{-1} q(\\tau),\n$$\nwhere for unit quaternions the inverse is the conjugate: $q^{-1} = (w, -x, -y, -z)$. The rotation angle of $q_{\\text{rel}}$ is\n$$\n\\Delta(\\tau) = 2 \\arctan2\\left(\\sqrt{x^2 + y^2 + z^2}, \\, |w|\\right),\n$$\nwhich equals $2 \\arccos(w)$ with appropriate clamping for numerical stability. We compute $\\Delta(\\tau)$ in radians, convert it to degrees by multiplication with $\\frac{180}{\\pi}$, and average over all LiDAR firing times to produce a scalar mean error per test case.\n\nFor constructing ground-truth quaternions from yaw–pitch–roll $(\\psi, \\theta, \\phi)$, we adopt the standard $z$–$y$–$x$ rotation convention (yaw about $z$, then pitch about $y$, then roll about $x$). Let $q_z(\\psi)$, $q_y(\\theta)$, and $q_x(\\phi)$ be the unit quaternions for pure-axis rotations. The composed rotation quaternion is\n$$\nq(\\psi, \\theta, \\phi) = q_z(\\psi) \\, q_y(\\theta) \\, q_x(\\phi),\n$$\nusing the Hamilton product for quaternion multiplication. Each elemental quaternion is defined by its axis-angle: for axis $\\hat{\\mathbf{e}}$ and angle $\\alpha$, $q = \\left( \\cos(\\alpha/2), \\, \\sin(\\alpha/2) \\hat{\\mathbf{e}} \\right)$, where $\\hat{\\mathbf{e}}$ is one of the Cartesian axes. Numerical implementation proceeds by converting degrees to radians for all trigonometric computations.\n\nThe algorithm:\n- Define quaternion operations: normalization, Hamilton product, conjugate/inverse, dot product.\n- Implement Slerp with dot-product sign handling and linear fallback near-zero angle.\n- Implement conversion from yaw–pitch–roll angles to a unit quaternion under the $z$–$y$–$x$ convention.\n- For each test case, define IMU epochs and LiDAR firing times as specified; define ground-truth yaw–pitch–roll angle functions in degrees, convert to radians to compute quaternions.\n- For Case A: IMU epochs at $0.0, 0.5, 1.0, 1.5, 2.0$ seconds; LiDAR times in increments of $0.05$ seconds; ground truth angles $\\psi(t) = 12 t$, $\\theta(t) = 2 \\sin(2 \\pi t)$, $\\phi(t) = 0.5 \\cos(\\pi t)$ (degrees).\n- For Case B: IMU epochs at $0.0, 1.0$ seconds with $q(1.0)$ set to the negative of the ground-truth quaternion at $t = 1.0$ to simulate the antipodal sign; LiDAR times in increments of $0.1$ seconds; ground truth constant angles $\\psi(t) = 179$, $\\theta(t) = 0$, $\\phi(t) = 0$ (degrees).\n- For Case C: IMU epochs at $0.0, 0.001$ seconds; LiDAR times at $0.0, 0.00025, 0.0005, 0.00075, 0.001$ seconds; ground truth angles $\\psi(t) = 100 t$, $\\theta(t) = 0$, $\\phi(t) = 0$ (degrees).\n- For each LiDAR time $\\tau$, bracket by IMU epochs, compute $u$, interpolate $\\hat{q}(\\tau)$, compute $q(\\tau)$, form $q_{\\text{rel}}(\\tau)$, compute $\\Delta(\\tau)$ in radians, convert to degrees, and average.\n\nFinally, output the mean errors for Cases A, B, and C in a single line as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places. This program design adheres to the rotation geometry on $S^3$ and quantifies how quaternion spherical interpolation aligns IMU attitude with LiDAR event times, demonstrating effects of sampling, sign ambiguity, and boundary conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef quat_normalize(q: np.ndarray) -> np.ndarray:\n    \"\"\"Normalize a quaternion to unit norm.\"\"\"\n    norm = np.linalg.norm(q)\n    if norm == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n    return q / norm\n\ndef quat_multiply(q1: np.ndarray, q2: np.ndarray) -> np.ndarray:\n    \"\"\"Hamilton product of two quaternions (w,x,y,z).\"\"\"\n    w1, x1, y1, z1 = q1\n    w2, x2, y2, z2 = q2\n    w = w1*w2 - x1*x2 - y1*y2 - z1*z2\n    x = w1*x2 + x1*w2 + y1*z2 - z1*y2\n    y = w1*y2 - x1*z2 + y1*w2 + z1*x2\n    z = w1*z2 + x1*y2 - y1*x2 + z1*w2\n    return np.array([w, x, y, z])\n\ndef quat_conjugate(q: npndarray) -> np.ndarray:\n    \"\"\"Conjugate of a quaternion (inverse for unit quaternion).\"\"\"\n    w, x, y, z = q\n    return np.array([w, -x, -y, -z])\n\ndef quat_dot(q1: np.ndarray, q2: np.ndarray) -> float:\n    \"\"\"Dot product of two quaternions.\"\"\"\n    return float(np.dot(q1, q2))\n\ndef slerp(q0: np.ndarray, q1: np.ndarray, u: float) -> np.ndarray:\n    \"\"\"\n    Spherical linear interpolation between unit quaternions q0 and q1 for parameter u in [0,1].\n    Handles antipodal quaternions and near-zero angles with linear fallback.\n    \"\"\"\n    q0 = quat_normalize(q0)\n    q1 = quat_normalize(q1)\n    dot = quat_dot(q0, q1)\n\n    # If dot is negative, flip sign of q1 to ensure shortest path\n    if dot < 0.0:\n        q1 = -q1\n        dot = -dot\n\n    # Clamp dot for numerical stability\n    dot = max(min(dot, 1.0), -1.0)\n\n    # If the quaternions are very close, use linear interpolation\n    if dot > 0.9995:\n        q = (1.0 - u) * q0 + u * q1\n        return quat_normalize(q)\n\n    theta = np.arccos(dot)\n    sin_theta = np.sin(theta)\n    a = np.sin((1.0 - u) * theta) / sin_theta\n    b = np.sin(u * theta) / sin_theta\n    q = a * q0 + b * q1\n    return quat_normalize(q)\n\ndef euler_zyx_to_quat(roll: float, pitch: float, yaw: float) -> np.ndarray:\n    \"\"\"\n    Convert yaw-pitch-roll (ZYX order) angles in radians to a unit quaternion.\n    yaw about z, then pitch about y, then roll about x.\n    \"\"\"\n    cz = np.cos(yaw / 2.0)\n    sz = np.sin(yaw / 2.0)\n    cy = np.cos(pitch / 2.0)\n    sy = np.sin(pitch / 2.0)\n    cx = np.cos(roll / 2.0)\n    sx = np.sin(roll / 2.0)\n\n    # q = qz * qy * qx\n    qz = np.array([cz, 0.0, 0.0, sz])\n    qy = np.array([cy, 0.0, sy, 0.0])\n    qx = np.array([cx, sx, 0.0, 0.0])\n\n    q = quat_multiply(quat_multiply(qz, qy), qx)\n    return quat_normalize(q)\n\ndef quat_angle_deg(q_est: np.ndarray, q_true: np.ndarray) -> float:\n    \"\"\"\n    Compute the angular difference between two unit quaternions in degrees.\n    \"\"\"\n    q_est = quat_normalize(q_est)\n    q_true = quat_normalize(q_true)\n    q_rel = quat_multiply(quat_conjugate(q_est), q_true)\n    w, x, y, z = q_rel\n    # Clamp w to valid range for arccos\n    w = max(min(w, 1.0), -1.0)\n    # Robust relative angle using atan2 of vector norm and scalar part\n    angle_rad = 2.0 * np.arctan2(np.linalg.norm([x, y, z]), abs(w))\n    angle_deg = angle_rad * (180.0 / np.pi)\n    return angle_deg\n\ndef ground_truth_case_A(t: float) -> np.ndarray:\n    \"\"\"\n    Case A ground truth quaternion at time t (seconds).\n    Angles: yaw=12*t deg, pitch=2*sin(2*pi*t) deg, roll=0.5*cos(pi*t) deg.\n    \"\"\"\n    yaw_deg = 12.0 * t\n    pitch_deg = 2.0 * np.sin(2.0 * np.pi * t)\n    roll_deg = 0.5 * np.cos(np.pi * t)\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef ground_truth_case_B(t: float) -> np.ndarray:\n    \"\"\"\n    Case B ground truth quaternion at time t (seconds).\n    Constant orientation: yaw=179 deg, pitch=0 deg, roll=0 deg.\n    \"\"\"\n    yaw_deg = 179.0\n    pitch_deg = 0.0\n    roll_deg = 0.0\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef ground_truth_case_C(t: float) -> np.ndarray:\n    \"\"\"\n    Case C ground truth quaternion at time t (seconds).\n    Yaw=100*t deg, pitch=0 deg, roll=0 deg.\n    \"\"\"\n    yaw_deg = 100.0 * t\n    pitch_deg = 0.0\n    roll_deg = 0.0\n    yaw = np.deg2rad(yaw_deg)\n    pitch = np.deg2rad(pitch_deg)\n    roll = np.deg2rad(roll_deg)\n    return euler_zyx_to_quat(roll, pitch, yaw)\n\ndef mean_interpolation_error_deg(imu_times, lidar_times, gt_func, imu_quat_override=None):\n    \"\"\"\n    Compute mean angular error in degrees by Slerp interpolation between IMU epoch quaternions.\n    Optionally override IMU quaternions for edge-case simulation.\n    \"\"\"\n    # Compute IMU quaternions from ground truth unless overridden\n    imu_quats = []\n    for t in imu_times:\n        if imu_quat_override is not None and t in imu_quat_override:\n            imu_quats.append(imu_quat_override[t])\n        else:\n            imu_quats.append(gt_func(t))\n    imu_quats = [quat_normalize(q) for q in imu_quats]\n\n    # Build intervals for bracketing\n    errors = []\n    for tau in lidar_times:\n        # Find bracketing IMU indices\n        if tau <= imu_times[0]:\n            k = 0\n        elif tau >= imu_times[-1]:\n            k = len(imu_times) - 2\n        else:\n            # k such that imu_times[k] <= tau <= imu_times[k+1]\n            k = max(i for i in range(len(imu_times) - 1) if imu_times[i] <= tau)\n            # ensure tau <= imu_times[k+1]\n            if tau > imu_times[k+1]:\n                k = k + 1 if k + 1 < len(imu_times) - 1 else k\n\n        t0 = imu_times[k]\n        t1 = imu_times[k+1]\n        q0 = imu_quats[k]\n        q1 = imu_quats[k+1]\n        # Handle exact epoch times\n        if t1 == t0:\n            u = 0.0\n        else:\n            u = (tau - t0) / (t1 - t0)\n            u = max(0.0, min(1.0, u))\n        q_interp = slerp(q0, q1, u)\n        q_true = gt_func(tau)\n        err_deg = quat_angle_deg(q_interp, q_true)\n        errors.append(err_deg)\n    return float(np.mean(errors))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    imu_times_A = [0.0, 0.5, 1.0, 1.5, 2.0]\n    lidar_times_A = [round(x, 2) for x in np.arange(0.05, 2.0, 0.05)]\n    # Case B\n    imu_times_B = [0.0, 1.0]\n    lidar_times_B = [round(x, 1) for x in np.arange(0.0, 1.0 + 1e-12, 0.1)]\n    # Override IMU quaternions: q(1.0) = -q_true(1.0)\n    imu_quat_override_B = {\n        0.0: ground_truth_case_B(0.0),\n        1.0: -ground_truth_case_B(1.0)\n    }\n    # Case C\n    imu_times_C = [0.0, 0.001]\n    lidar_times_C = [0.0, 0.00025, 0.0005, 0.00075, 0.001]\n\n    results = []\n    # Case A mean error\n    err_A = mean_interpolation_error_deg(imu_times_A, lidar_times_A, ground_truth_case_A)\n    # Case B mean error with antipodal override\n    err_B = mean_interpolation_error_deg(imu_times_B, lidar_times_B, ground_truth_case_B, imu_quat_override=imu_quat_override_B)\n    # Case C mean error\n    err_C = mean_interpolation_error_deg(imu_times_C, lidar_times_C, ground_truth_case_C)\n\n    # Round to six decimal places as required\n    formatted = [f\"{x:.6f}\" for x in [err_A, err_B, err_C]]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The foundation of LiDAR's distance measurement is the precise timing of a laser pulse's round trip, but this assumes perfect synchronization between the sensor's clock and the master system clock. In reality, constant and time-varying offsets exist and must be calibrated for. This exercise guides you through a realistic calibration procedure, where you will use simulated measurements from known retroreflector targets to estimate and correct for these timing biases using linear least-squares analysis . This practice is essential for understanding how raw instrument data is transformed into a high-accuracy, reliable dataset.",
            "id": "3824548",
            "problem": "You are tasked with designing a calibration procedure for Light Detection and Ranging (LiDAR) sensor time synchronization using retroreflectors to estimate constant and linear time offsets between the LiDAR clock and a reference time base. The procedure must derive, implement, and compute the estimates in seconds for the constant offset and as a dimensionless ratio for the linear drift by fitting observed versus expected return times.\n\nThe fundamental base for this problem is the time-of-flight equation for pulsed LiDAR, which states that the round-trip travel time of a laser pulse is proportional to twice the range divided by the speed of light. Let the speed of light be $c = 299{,}792{,}458 \\ \\mathrm{m/s}$. The expected round-trip time for a retroreflector at range $R$ is given by\n$$\n\\tau = \\frac{2 R}{c}.\n$$\n\nAssume the LiDAR device emits pulses at known reference emission times $t_i$ recorded on a Global Navigation Satellite System (GNSS)/Inertial Measurement Unit (IMU) time base. The LiDAR device records observed return timestamps $t_i^{\\mathrm{obs}}$ on its own internal clock, which is subject to unknown constant offset and linear drift relative to the reference time base. Model the observed return time as\n$$\nt_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i,\n$$\nwhere $c_0$ is the constant offset in seconds, $c_1$ is the linear drift (dimensionless ratio per second), and $\\varepsilon_i$ represents measurement noise. The calibration problem reduces to estimating $c_0$ and $c_1$ by minimizing the sum of squared residuals between the observed and expected arrival times.\n\nFor a set of $n$ observations, define the residuals\n$$\ny_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i.\n$$\nYou must estimate $c_0$ and $c_1$ by solving the linear least-squares problem\n$$\n\\min_{c_0, c_1} \\sum_{i=1}^{n} \\left( y_i - (c_0 + c_1 t_i) \\right)^2,\n$$\nwhich equivalently can be solved using the normal equations with the design matrix\n$$\n\\mathbf{X} = \\begin{bmatrix}\n1 & t_1 \\\\\n1 & t_2 \\\\\n\\vdots & \\vdots \\\\\n1 & t_n\n\\end{bmatrix},\n\\quad\n\\mathbf{y} = \\begin{bmatrix}\ny_1 \\\\\ny_2 \\\\\n\\vdots \\\\\ny_n\n\\end{bmatrix}.\n$$\nThe solution satisfies\n$$\n\\begin{bmatrix}\n\\hat{c}_0 \\\\\n\\hat{c}_1\n\\end{bmatrix}\n= (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}.\n$$\n\nUnits and output requirements:\n- Report $\\hat{c}_0$ in seconds, and $\\hat{c}_1$ as a dimensionless ratio.\n- Round each reported value to $12$ decimal places.\n- Angles are not used in this problem; no angle unit is required.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, flattened across all test cases in order as $[\\hat{c}_{0,1},\\hat{c}_{1,1},\\hat{c}_{0,2},\\hat{c}_{1,2},\\hat{c}_{0,3},\\hat{c}_{1,3}]$, where the subscript denotes test case index.\n\nTest suite:\nFor each test case, the LiDAR emitter is at the origin with coordinates $(0,0,0)$, and retroreflectors are at known positions. The Euclidean range is defined as\n$$\nR = \\sqrt{(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2}.\n$$\nUse the speed of light $c = 299{,}792{,}458 \\ \\mathrm{m/s}$.\n\n- Test Case $1$ (happy path, multiple reflectors, small deterministic noise):\n  - Emission times (seconds): $[0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0]$.\n  - Retroreflector positions (meters): $[(50.0, 0.0, 0.0), (0.0, 120.0, 0.0), (0.0, 0.0, 300.0)]$.\n  - Assignment of reflectors per emission: indices $[0, 1, 2, 0, 1, 2, 0]$.\n  - Ground-truth offsets: $c_0 = 0.000008000000 \\ \\mathrm{s}$, $c_1 = 0.000000100000$.\n  - Deterministic noise sequence (seconds): $[0.000000001000, -0.000000002000, 0.000000003000, -0.000000001000, 0.000000002000, 0.000000000000, -0.000000003000]$.\n\n- Test Case $2$ (boundary condition, minimal two observations, exact data):\n  - Emission times (seconds): $[0.0, 10.0]$.\n  - Single retroreflector position (meters): $[(0.0, 123.0, 0.0)]$ used for both emissions.\n  - Assignment of reflectors per emission: indices $[0, 0]$.\n  - Ground-truth offsets: $c_0 = 0.000005000000 \\ \\mathrm{s}$, $c_1 = -0.000000200000$.\n  - Deterministic noise sequence (seconds): $[0.000000000000, 0.000000000000]$.\n\n- Test Case $3$ (long baseline, mixed ranges, small deterministic noise, negative constant offset):\n  - Emission times (seconds): $[10.0, 20.0, 50.0, 80.0, 120.0]$.\n  - Retroreflector positions (meters): $[(30.0, 40.0, 0.0), (0.0, 200.0, 0.0), (100.0, 100.0, 0.0)]$.\n  - Assignment of reflectors per emission: indices $[0, 1, 2, 0, 1]$.\n  - Ground-truth offsets: $c_0 = -0.000010000000 \\ \\mathrm{s}$, $c_1 = 0.000000050000$.\n  - Deterministic noise sequence (seconds): $[0.000000000000, -0.000000001000, 0.000000002000, -0.000000002000, 0.000000001000]$.\n\nFor each test case:\n1. Compute ranges $R_i$ from the provided geometry.\n2. Compute expected round-trip times $\\tau_i = 2R_i/c$.\n3. Form observed times $t_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i$.\n4. Compute residuals $y_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i$.\n5. Estimate $\\hat{c}_0$ and $\\hat{c}_1$ via linear least squares in the sense of minimizing $\\sum_i (y_i - (c_0 + c_1 t_i))^2$.\n6. Round each estimate to $12$ decimal places and output the flattened list across all test cases as described above.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[\\hat{c}_{0,1},\\hat{c}_{1,1},\\hat{c}_{0,2},\\hat{c}_{1,2},\\hat{c}_{0,3},\\hat{c}_{1,3}]$, with $\\hat{c}_0$ in seconds and $\\hat{c}_1$ dimensionless, each rounded to $12$ decimal places.",
            "solution": "The problem is subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n\n-   **Constant**: Speed of light, $c = 299{,}792{,}458 \\ \\mathrm{m/s}$.\n-   **Equation for Expected Round-Trip Time**: $\\tau = \\frac{2 R}{c}$, where $R$ is the range.\n-   **Model for Observed Return Time**: $t_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i$, where $t_i$ is the reference emission time, $c_0$ is the constant time offset (s), $c_1$ is the linear time drift (dimensionless), and $\\varepsilon_i$ is measurement noise.\n-   **Definition of Residuals**: $y_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i$.\n-   **Objective Function for Estimation**: Minimize $\\sum_{i=1}^{n} \\left( y_i - (c_0 + c_1 t_i) \\right)^2$.\n-   **Matrix Formulation**:\n    $$\n    \\mathbf{X} = \\begin{bmatrix}\n    1 & t_1 \\\\\n    1 & t_2 \\\\\n    \\vdots & \\vdots \\\\\n    1 & t_n\n    \\end{bmatrix},\n    \\quad\n    \\mathbf{y} = \\begin{bmatrix}\n    y_1 \\\\\n    y_2 \\\\\n    \\vdots \\\\\n    y_n\n    \\end{bmatrix}.\n    $$\n-   **Least-Squares Solution**: $\\begin{bmatrix} \\hat{c}_0 \\\\ \\hat{c}_1 \\end{bmatrix} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}$.\n-   **LiDAR Emitter Position**: $(0,0,0)$.\n-   **Range Definition**: Euclidean range, $R = \\sqrt{(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2}$.\n-   **Output Requirements**:\n    -   $\\hat{c}_0$ in seconds, $\\hat{c}_1$ dimensionless.\n    -   Round to $12$ decimal places.\n    -   Final output format: `[ĉ_0,1,ĉ_1,1,ĉ_0,2,ĉ_1,2,ĉ_0,3,ĉ_1,3]`.\n-   **Test Case 1 Data**:\n    -   Emission times: $[0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0]$ s.\n    -   Retroreflector positions: $[(50.0, 0.0, 0.0), (0.0, 120.0, 0.0), (0.0, 0.0, 300.0)]$ m.\n    -   Reflector assignment indices: $[0, 1, 2, 0, 1, 2, 0]$.\n    -   Ground-truth offsets: $c_0 = 0.000008000000$ s, $c_1 = 0.000000100000$.\n    -   Noise: $[0.000000001, -0.000000002, 0.000000003, -0.000000001, 0.000000002, 0.0, -0.000000003]$ s.\n-   **Test Case 2 Data**:\n    -   Emission times: $[0.0, 10.0]$ s.\n    -   Retroreflector position: $[(0.0, 123.0, 0.0)]$ m.\n    -   Reflector assignment indices: $[0, 0]$.\n    -   Ground-truth offsets: $c_0 = 0.000005000000$ s, $c_1 = -0.000000200000$.\n    -   Noise: $[0.0, 0.0]$ s.\n-   **Test Case 3 Data**:\n    -   Emission times: $[10.0, 20.0, 50.0, 80.0, 120.0]$ s.\n    -   Retroreflector positions: $[(30.0, 40.0, 0.0), (0.0, 200.0, 0.0), (100.0, 100.0, 0.0)]$ m.\n    -   Reflector assignment indices: $[0, 1, 2, 0, 1]$.\n    -   Ground-truth offsets: $c_0 = -0.000010000000$ s, $c_1 = 0.000000050000$.\n    -   Noise: $[0.0, -0.000000001, 0.000000002, -0.000000002, 0.000000001]$ s.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is based on the well-established time-of-flight principle of LiDAR and uses a standard linear model for clock drift. The method of least squares is the canonical approach for parameter estimation in this context. The physical and mathematical models are sound.\n-   **Well-Posed**: The problem requires solving a linear least-squares system. A unique solution exists if the design matrix $\\mathbf{X}$ has full column rank, which is true if the emission times $t_i$ are not all identical. Examination of all three test cases confirms that the emission times are distinct, ensuring the matrix $\\mathbf{X}^\\top\\mathbf{X}$ is invertible. The problem is therefore well-posed.\n-   **Objective**: The problem is stated using precise, quantitative language, and is free of subjectivity or ambiguity.\n-   **Completeness**: All necessary data, models, and constants are provided. The procedure is explicitly defined, from data generation to parameter estimation.\n-   **Consistency**: There are no contradictions. The use of ground-truth parameters to generate simulated \"observed\" data is a standard technique for validating an estimation algorithm.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, objective, and complete. It is therefore deemed **valid**. A solution will be provided.\n\nThe objective is to estimate the constant time offset, $c_0$, and the linear time drift, $c_1$, for a LiDAR system. The estimation is performed by modeling the relationship between the LiDAR's internal clock and a reference time base and then applying the method of linear least squares.\n\nThe core of the problem lies in the provided model for the observed return time, $t_i^{\\mathrm{obs}}$, for the $i$-th laser pulse:\n$$\nt_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i\n$$\nHere, $t_i$ is the known emission time on the reference clock, $\\tau_i$ is the physical round-trip time of flight of the laser pulse, and $\\varepsilon_i$ is random measurement noise. The term $c_0 + c_1 t_i$ represents the total time discrepancy at time $t_i$ between the LiDAR's clock and the reference clock.\n\nTo isolate the parameters of interest, $c_0$ and $c_1$, we rearrange the equation. The problem defines a quantity $y_i$ as the difference between the observed return time and the deterministically known components (emission time and ideal travel time):\n$$\ny_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i\n$$\nSubstituting the model for $t_i^{\\mathrm{obs}}$ into this definition yields:\n$$\ny_i = (t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i) - t_i - \\tau_i = c_0 + c_1 t_i + \\varepsilon_i\n$$\nThis equation reveals a simple linear relationship between the computable quantity $y_i$ and the emission time $t_i$. The parameters $c_0$ and $c_1$ are the intercept and slope, respectively, of this linear model.\n\nThe task is to find the estimates, $\\hat{c}_0$ and $\\hat{c}_1$, that best fit the set of observations $(t_i, y_i)$. The principle of least squares dictates that we find the parameters that minimize the sum of the squared differences between the observed $y_i$ and the values predicted by the model, $\\hat{y}_i = c_0 + c_1 t_i$. The objective function to minimize is:\n$$\nS(c_0, c_1) = \\sum_{i=1}^{n} (y_i - (c_0 + c_1 t_i))^2\n$$\nThis is a standard linear regression problem. In matrix notation, we can write the system of equations for all $n$ observations as:\n$$\n\\mathbf{y} = \\mathbf{X}\\mathbf{c} + \\boldsymbol{\\varepsilon}\n$$\nwhere $\\mathbf{y} = [y_1, y_2, \\ldots, y_n]^\\top$ is the vector of observations, $\\mathbf{c} = [c_0, c_1]^\\top$ is the vector of parameters to be estimated, $\\boldsymbol{\\varepsilon}$ is the vector of noise terms, and $\\mathbf{X}$ is the design matrix:\n$$\n\\mathbf{X} = \\begin{bmatrix}\n1 & t_1 \\\\\n1 & t_2 \\\\\n\\vdots & \\vdots \\\\\n1 & t_n\n\\end{bmatrix}\n$$\nThe least-squares solution $\\hat{\\mathbf{c}}$ that minimizes $||\\mathbf{y} - \\mathbf{X}\\mathbf{c}||^2$ is given by the solution to the normal equations:\n$$\n(\\mathbf{X}^\\top \\mathbf{X}) \\hat{\\mathbf{c}} = \\mathbf{X}^\\top \\mathbf{y}\n$$\nProvided that $\\mathbf{X}^\\top \\mathbf{X}$ is invertible (which it is, as the columns of $\\mathbf{X}$ are linearly independent for the given test cases), the solution is formally written as:\n$$\n\\hat{\\mathbf{c}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}\n$$\nWhile this equation provides the analytical solution, robust numerical implementations typically solve the system using methods like QR decomposition or Singular Value Decomposition for superior numerical stability compared to explicitly forming the inverse.\n\nThe algorithmic procedure for each test case is as follows:\n1.  Define the constant speed of light $c = 299{,}792{,}458 \\ \\mathrm{m/s}$.\n2.  For each of the $n$ measurements in a test case:\n    a. Identify the emission time $t_i$, the assigned retroreflector's position $(x, y, z)$, the ground-truth offsets $c_0$ and $c_1$, and the noise term $\\varepsilon_i$.\n    b. Calculate the range to the retroreflector, $R_i = \\sqrt{x^2 + y^2 + z^2}$, as the emitter is at the origin.\n    c. Compute the ideal round-trip time $\\tau_i = 2 R_i / c$.\n    d. Synthesize the \"observed\" return time using the provided model: $t_i^{\\mathrm{obs}} = t_i + \\tau_i + c_0 + c_1 t_i + \\varepsilon_i$.\n    e. Calculate the regression variable $y_i = t_i^{\\mathrm{obs}} - t_i - \\tau_i$.\n3.  Construct the $n \\times 2$ design matrix $\\mathbf{X}$ where the first column consists of ones and the second column consists of the emission times $t_i$.\n4.  Construct the $n \\times 1$ observation vector $\\mathbf{y}$ with elements $y_i$.\n5.  Solve the linear least-squares problem for $\\hat{\\mathbf{c}} = [\\hat{c}_0, \\hat{c}_1]^\\top$.\n6.  Round the estimated parameters $\\hat{c}_0$ and $\\hat{c}_1$ to $12$ decimal places as required for the final output. The results from all test cases are then concatenated.\n\nThis procedure is applied to each test case to derive the required estimates. For Test Case 2, which has exactly two data points and no noise, the least-squares fit will be an exact line passing through the two points, resulting in perfect recovery of the ground-truth parameters $c_0$ and $c_1$. For Test Cases 1 and 3, the presence of non-zero noise terms $\\varepsilon_i$ means the estimated parameters will be close to, but not exactly equal to, the ground-truth values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LiDAR time synchronization calibration problem for three test cases.\n    \"\"\"\n    # Speed of light in m/s\n    C_LIGHT = 299792458.0\n\n    test_cases = [\n        {\n            \"emission_times\": np.array([0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0]),\n            \"reflector_positions\": np.array([(50.0, 0.0, 0.0), (0.0, 120.0, 0.0), (0.0, 0.0, 300.0)]),\n            \"assignment_indices\": [0, 1, 2, 0, 1, 2, 0],\n            \"c0_true\": 8.0e-6,\n            \"c1_true\": 1.0e-7,\n            \"noise\": np.array([1.0e-9, -2.0e-9, 3.0e-9, -1.0e-9, 2.0e-9, 0.0, -3.0e-9]),\n        },\n        {\n            \"emission_times\": np.array([0.0, 10.0]),\n            \"reflector_positions\": np.array([(0.0, 123.0, 0.0)]),\n            \"assignment_indices\": [0, 0],\n            \"c0_true\": 5.0e-6,\n            \"c1_true\": -2.0e-7,\n            \"noise\": np.array([0.0, 0.0]),\n        },\n        {\n            \"emission_times\": np.array([10.0, 20.0, 50.0, 80.0, 120.0]),\n            \"reflector_positions\": np.array([(30.0, 40.0, 0.0), (0.0, 200.0, 0.0), (100.0, 100.0, 0.0)]),\n            \"assignment_indices\": [0, 1, 2, 0, 1],\n            \"c0_true\": -1.0e-5,\n            \"c1_true\": 5.0e-8,\n            \"noise\": np.array([0.0, -1.0e-9, 2.0e-9, -2.0e-9, 1.0e-9]),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        t = case[\"emission_times\"]\n        reflector_pos = case[\"reflector_positions\"]\n        assign_idx = case[\"assignment_indices\"]\n        c0_true = case[\"c0_true\"]\n        c1_true = case[\"c1_true\"]\n        epsilon = case[\"noise\"]\n\n        n_obs = len(t)\n        y = np.zeros(n_obs)\n\n        for i in range(n_obs):\n            # 1. Compute range Ri\n            pos = reflector_pos[assign_idx[i]]\n            # LiDAR emitter is at origin (0,0,0)\n            range_i = np.linalg.norm(pos)\n\n            # 2. Compute expected round-trip time tau_i\n            tau_i = 2.0 * range_i / C_LIGHT\n\n            # 3. Form observed times t_obs_i\n            t_obs_i = t[i] + tau_i + c0_true + c1_true * t[i] + epsilon[i]\n\n            # 4. Compute residuals y_i\n            y[i] = t_obs_i - t[i] - tau_i\n            \n        # 5. Estimate c0 and c1 via linear least squares\n        # The model is y_i = c0 + c1 * t_i\n        # We solve y = X * c_hat\n        # where X is the design matrix and c_hat = [c0, c1]^T.\n        X = np.ones((n_obs, 2))\n        X[:, 1] = t\n\n        # Solve the least-squares problem using numpy.linalg.lstsq\n        # It's more numerically stable than computing the inverse of X.T @ X\n        c_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        c0_hat = c_hat[0]\n        c1_hat = c_hat[1]\n\n        # 6. Append rounded results. The formatting string handles rounding.\n        results.append(c0_hat)\n        results.append(c1_hat)\n\n    # Final print statement in the exact required format.\n    # The format string '{:.12f}' correctly rounds to 12 decimal places for printing.\n    print(f\"[{','.join([f'{val:.12f}' for val in results])}]\")\n\nsolve()\n```"
        }
    ]
}