{
    "hands_on_practices": [
        {
            "introduction": "栖息地适宜性建模的第一步通常是基于物种已知的生理耐受性来构建基本模型。本练习将指导您通过组合气候包络（如温度和降水范围）与生物相互作用因子，来创建一个基于规则的适宜性指数。通过这个实践 ，您将掌握将生态学原理转化为空间明确的量化地图的核心技能，这是理解更复杂模型的基础。",
            "id": "3818680",
            "problem": "您会获得一个景观的网格化环境数据，表示为气温、年降水量和生物排斥因子的形状相同的数组。目标是计算逐像元的生境适宜度指数，根据阈值对像元进行分类，并汇总满足该阈值的景观比例。适宜度指数必须严格遵循以下基本原则构建。\n\n基本原理和定义：\n- 设像元位置由符号 $x$ 表示。每个像元包含三个值：气温 $T(x)$、年降水量 $P(x)$ 和生物排斥因子 $b(x)$。\n- 该物种受气候限制，其适宜区间为摄氏 $[10,30]$ 度和 $[500,1500]$ 毫米的闭区间。所有温度必须以摄氏度为单位处理和报告，所有降水量必须以毫米为单位处理和报告。\n- 使用指示函数的定义。对于任意陈述 $A$，定义指示函数 $\\mathbb{I}(A)$ 为：如果 $A$ 为真，则 $\\mathbb{I}(A)=1$；否则 $\\mathbb{I}(A)=0$。\n- 生物排斥由 $b(x)$ 表示，作为单位区间 $[0,1]$ 内的一个不可用比例，其中 $b(x)=0$ 表示没有生物排斥，$b(x)=1$ 表示完全排斥。如果任何 $b(x)$ 的值位于 $[0,1]$ 之外，则在进一步计算之前将其裁剪到 $[0,1]$ 区间内。\n- 无效或缺失的像元由特殊值 $\\mathrm{NaN}$ (非数值) 表示。一个像元 $x$ 被认为是有效的，当且仅当 $T(x)$、$P(x)$ 和 $b(x)$ 都是有限实数（即，没有一个是 $\\mathrm{NaN}$）。在计算任何分数时，无效像元必须同时从分子和分母中排除。\n\n任务：\n1. 对于每个像元 $x$，通过区间约束的交集定义一个气候可行性指示函数：\n   - 温度可行性指示函数为 $\\mathbb{I}\\left(10 \\leq T(x) \\leq 30\\right)$。\n   - 降水可行性指示函数为 $\\mathbb{I}\\left(500 \\leq P(x) \\leq 1500\\right)$。\n   - 气候可行性指示函数是两者的乘积 $\\mathbb{I}\\left(10 \\leq T(x) \\leq 30\\right)\\cdot \\mathbb{I}\\left(500 \\leq P(x) \\leq 1500\\right)$。\n2. 对于每个有效像元 $x$，通过气候可行性与生物排斥补集的组合来定义适宜度指数 $s(x)$：\n   - 如果气候可行性指示函数等于 $0$，则 $s(x)=0$。\n   - 如果气候可行性指示函数等于 $1$，则 $s(x)=1-b(x)$，其中 $b(x)$ 已被裁剪到 $[0,1]$ 区间。\n3. 使用适宜度阈值 $\\tau_s=0.8$ (无量纲)，统计有多少有效像元满足 $s(x)\\geq \\tau_s$。按如下方式计算满足该阈值的景观比例：\n   $$f=\\frac{\\text{number of valid pixels with } s(x)\\geq \\tau_s}{\\text{number of valid pixels}}.$$\n   按照约定，如果没有有效像元，则定义 $f=0.0$。\n4. 对于每个提供的测试用例，计算 $f$ 并将结果报告为四舍五入到六位小数的浮点数。\n\n本问题不涉及角度单位。所有百分比必须以小数形式报告。\n\n测试套件：\n使用以下四个案例。在每个案例中，所有数组都具有相同的维度，并指向同一个像元网格。在所示位置精确使用 $\\mathrm{NaN}$ 表示缺失值。\n\n- 测试用例1 (一般混合情况)：\n  - 温度 $T^{(1)}$ (摄氏度):\n    $\\begin{bmatrix}\n    12  & 25 & 5 & 31 \\\\\n    10  & 30 & 20 & \\mathrm{NaN} \\\\\n    15  & 9 & 28 & 11\n    \\end{bmatrix}$\n  - 降水量 $P^{(1)}$ (毫米):\n    $\\begin{bmatrix}\n    600  & 1400 & 600 & 600 \\\\\n    500  & 1500 & 1000 & 900 \\\\\n    499  & 800 & 1600 & \\mathrm{NaN}\n    \\end{bmatrix}$\n  - 生物排斥因子 $b^{(1)}$ (分数，使用前需裁剪到 $[0,1]$ 区间):\n    $\\begin{bmatrix}\n    0.1  & 0.05 & 0.3 & 0.1 \\\\\n    0.2  & 0.0 & 0.19 & 0.9 \\\\\n    0.0  & 0.15 & 0.2 & 0.1\n    \\end{bmatrix}$\n\n- 测试用例2 (边界条件与裁剪)：\n  - 温度 $T^{(2)}$ (摄氏度):\n    $\\begin{bmatrix}\n    10  & 30 & 20 & 10 \\\\\n    30  & 10 & 30 & 25\n    \\end{bmatrix}$\n  - 降水量 $P^{(2)}$ (毫米):\n    $\\begin{bmatrix}\n    500  & 1500 & 1000 & 500 \\\\\n    1500  & 500 & 1500 & 700\n    \\end{bmatrix}$\n  - 生物排斥因子 $b^{(2)}$ (分数，裁剪到 $[0,1]$):\n    $\\begin{bmatrix}\n    0.2  & 0.2 & 0.8 & 0.0 \\\\\n    0.2000001  & -0.1 & 1.2 & 0.2\n    \\end{bmatrix}$\n\n- 测试用例3 (所有气候条件均不可行)：\n  - 温度 $T^{(3)}$ (摄氏度):\n    $\\begin{bmatrix}\n    9  & 35 \\\\\n    8  & 31\n    \\end{bmatrix}$\n  - 降水量 $P^{(3)}$ (毫米):\n    $\\begin{bmatrix}\n    400  & 1600 \\\\\n    200  & 2000\n    \\end{bmatrix}$\n  - 生物排斥因子 $b^{(3)}$ (分数):\n    $\\begin{bmatrix}\n    0.0  & 0.0 \\\\\n    0.0  & 0.0\n    \\end{bmatrix}$\n\n- 测试用例4 (无有效像元)：\n  - 温度 $T^{(4)}$ (摄氏度):\n    $\\begin{bmatrix}\n    \\mathrm{NaN}  & \\mathrm{NaN} \\\\\n    \\mathrm{NaN}  & \\mathrm{NaN}\n    \\end{bmatrix}$\n  - 降水量 $P^{(4)}$ (毫米):\n    $\\begin{bmatrix}\n    \\mathrm{NaN}  & \\mathrm{NaN} \\\\\n    \\mathrm{NaN}  & \\mathrm{NaN}\n    \\end{bmatrix}$\n  - 生物排斥因子 $b^{(4)}$ (分数):\n    $\\begin{bmatrix}\n    \\mathrm{NaN}  & \\mathrm{NaN} \\\\\n    \\mathrm{NaN}  & \\mathrm{NaN}\n    \\end{bmatrix}$\n\n最终输出格式要求：\n您的程序必须按顺序为四个测试用例计算 $f$，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个浮点数结果四舍五入到六位小数。例如，包含四个结果的输出必须类似于\n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$。",
            "solution": "问题陈述已经过评估并被确定为有效。它有科学依据，提法明确，客观，并为一个标准的生境适宜度建模练习提供了完整且一致的定义和数据集。\n\n解决方案通过为任意一组网格化数据层逐步实现指定的算法来展开。设温度、降水量和生物排斥的输入数组分别表示为 $T$、$P$ 和 $b$。\n\n1.  **识别有效像元**：第一步是确定网格中哪些像元包含有效数据。根据问题定义，一个位于位置 $x$ 的像元是有效的，当且仅当温度 $T(x)$、降水量 $P(x)$ 和生物因子 $b(x)$ 的值都是有限实数（即非 $\\mathrm{NaN}$）。这可以通过创建一个布尔掩码来实现，我们称之为 $M_{valid}$，其中如果对应的像元有效，则元素为 `True`，否则为 `False`。有效像元的总数 $N_{valid}$ 是此掩码中 `True` 元素的总和。\n    $$M_{valid}(x) = \\mathbb{I}(\\neg\\mathrm{isNaN}(T(x)) \\land \\neg\\mathrm{isNaN}(P(x)) \\land \\neg\\mathrm{isNaN}(b(x)))$$\n    $$N_{valid} = \\sum_{x} M_{valid}(x)$$\n    如果 $N_{valid} = 0$，问题规定分数 $f$ 定义为 $0.0$，计算终止。\n\n2.  **裁剪生物排斥因子**：生物排斥因子 $b(x)$ 被定义为一个不可用比例，并且必须在闭合的单位区间 $[0, 1]$ 内。问题要求裁剪任何在此范围之外的值。我们定义一个新的网格 $b_{clipped}$，其中对于每个像元 $x$：\n    $$b_{clipped}(x) = \\max(0, \\min(1, b(x)))$$\n    此操作应用于整个 $b$ 网格，包括那些稍后可能被识别为无效的像元；无效像元掩码 $M_{valid}$ 将确保这些位置在最终计算中被正确忽略。\n\n3.  **计算气候可行性**：为每个像元计算气候可行性指示函数 $C(x)$。如果温度和降水量都在其指定的有利范围内，该指示函数为 $1$，否则为 $0$。\n    温度可行性由指示掩码 $C_T(x) = \\mathbb{I}(10 \\leq T(x) \\leq 30)$ 给出。\n    降水可行性由指示掩码 $C_P(x) = \\mathbb{I}(500 \\leq P(x) \\leq 1500)$ 给出。\n    组合的气候可行性是这两个指示函数的乘积：\n    $$C(x) = C_T(x) \\cdot C_P(x) = \\mathbb{I}\\left((10 \\leq T(x) \\leq 30) \\land (500 \\leq P(x) \\leq 1500)\\right)$$\n\n4.  **计算适宜度指数**：现在基于气候可行性 $C(x)$ 和裁剪后的生物因子 $b_{clipped}(x)$ 为每个像元计算生境适宜度指数 $s(x)$。\n    - 如果 $C(x) = 0$，则气候不适宜，因此 $s(x) = 0$。\n    - 如果 $C(x) = 1$，则气候适宜，适宜度由生物因子决定：$s(x) = 1 - b_{clipped}(x)$。\n    这个逻辑可以为整个网格简明地表示为：\n    $$s(x) = C(x) \\cdot (1 - b_{clipped}(x))$$\n\n5.  **分类与聚合**：最后一步是确定高度适宜的有效景观的比例。如果一个像元的适宜度指数 $s(x)$ 大于或等于阈值 $\\tau_s = 0.8$，则该像元被分类为高度适宜。我们统计满足此条件*且*有效的像元数量。设此计数为 $N_{suitable}$。\n    $$N_{suitable} = \\sum_{x} \\mathbb{I}(s(x) \\geq \\tau_s) \\cdot M_{valid}(x)$$\n    注意与 $M_{valid}(x)$ 的乘法，这确保了按问题规定，只有有效的像元才在分子中计数。\n\n6.  **计算最终比例**：分数 $f$ 是高度适宜的有效像元数量与有效像元总数的比率。\n    $$f = \\frac{N_{suitable}}{N_{valid}}$$\n    如步骤1所确立，如果 $N_{valid} = 0$，则 $f = 0.0$。最终结果四舍五入到六位小数。\n\n让我们将此逻辑应用于测试用例1：\n-   $T^{(1)} = \\begin{bmatrix} 12  & 25 & 5 & 31 \\\\ 10  & 30 & 20 & \\mathrm{NaN} \\\\ 15  & 9 & 28 & 11 \\end{bmatrix}$\n-   $P^{(1)} = \\begin{bmatrix} 600  & 1400 & 600 & 600 \\\\ 500  & 1500 & 1000 & 900 \\\\ 499  & 800 & 1600 & \\mathrm{NaN} \\end{bmatrix}$\n-   $b^{(1)} = \\begin{bmatrix} 0.1  & 0.05 & 0.3 & 0.1 \\\\ 0.2  & 0.0 & 0.19 & 0.9 \\\\ 0.0  & 0.15 & 0.2 & 0.1 \\end{bmatrix}$\n\n1.  **有效像元**：有两个像元具有 $\\mathrm{NaN}$ 值：分别是 $T^{(1)}$ 中索引为 $(1, 3)$ 的像元和 $P^{(1)}$ 中索引为 $(2, 3)$ 的像元。所有其他 $12-2=10$ 个像元都是有效的。因此，$N_{valid} = 10$。\n2.  **裁剪生物因子**：$b^{(1)}$ 中的所有值都已在 $[0, 1]$ 区间内，所以 $b_{clipped}^{(1)} = b^{(1)}$。\n3.  **气候可行性**：\n    $C_T = \\begin{bmatrix} 1  & 1 & 0 & 0 \\\\ 1  & 1 & 1 & 0 \\\\ 1  & 0 & 1 & 1 \\end{bmatrix}$, $C_P = \\begin{bmatrix} 1  & 1 & 1 & 1 \\\\ 1  & 1 & 1 & 1 \\\\ 0  & 1 & 0 & 0 \\end{bmatrix}$。\n    $C = C_T \\cdot C_P = \\begin{bmatrix} 1  & 1 & 0 & 0 \\\\ 1  & 1 & 1 & 0 \\\\ 0  & 0 & 0 & 0 \\end{bmatrix}$。\n4.  **适宜度指数**：$s(x) = C(x) \\cdot (1 - b_{clipped}(x))$。\n    $s = \\begin{bmatrix} 1\\cdot(1-0.1)  & 1\\cdot(1-0.05) & 0 & 0 \\\\ 1\\cdot(1-0.2)  & 1\\cdot(1-0.0) & 1\\cdot(1-0.19) & 0 \\\\ 0  & 0 & 0 & 0 \\end{bmatrix} = \\begin{bmatrix} 0.9  & 0.95 & 0 & 0 \\\\ 0.8  & 1.0 & 0.81 & 0 \\\\ 0  & 0 & 0 & 0 \\end{bmatrix}$。\n5.  **分类**：找到 $s(x) \\geq 0.8$ 的位置。\n    $\\mathbb{I}(s(x) \\geq 0.8) = \\begin{bmatrix} 1  & 1 & 0 & 0 \\\\ 1  & 1 & 1 & 0 \\\\ 0  & 0 & 0 & 0 \\end{bmatrix}$。\n    高度适宜的有效像元数量 $N_{suitable}$ 是此网格中 `1` 的数量，不包括无效像元的位置（此处没有重叠）。有5个这样的像元。$N_{suitable} = 5$。\n6.  **最终比例**：$f = \\frac{N_{suitable}}{N_{valid}} = \\frac{5}{10} = 0.5$。四舍五入到六位小数，结果是 $0.500000$。\n对所有其他测试用例应用相同的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fraction of a landscape satisfying a habitat suitability threshold\n    for several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: General mixed case\n        {\n            \"T\": np.array([\n                [12, 25, 5, 31],\n                [10, 30, 20, np.nan],\n                [15, 9, 28, 11]\n            ]),\n            \"P\": np.array([\n                [600, 1400, 600, 600],\n                [500, 1500, 1000, 900],\n                [499, 800, 1600, np.nan]\n            ]),\n            \"b\": np.array([\n                [0.1, 0.05, 0.3, 0.1],\n                [0.2, 0.0, 0.19, 0.9],\n                [0.0, 0.15, 0.2, 0.1]\n            ])\n        },\n        # Test Case 2: Boundary conditions and clipping\n        {\n            \"T\": np.array([\n                [10, 30, 20, 10],\n                [30, 10, 30, 25]\n            ]),\n            \"P\": np.array([\n                [500, 1500, 1000, 500],\n                [1500, 500, 1500, 700]\n            ]),\n            \"b\": np.array([\n                [0.2, 0.2, 0.8, 0.0],\n                [0.2000001, -0.1, 1.2, 0.2]\n            ])\n        },\n        # Test Case 3: All climate-infeasible\n        {\n            \"T\": np.array([\n                [9, 35],\n                [8, 31]\n            ]),\n            \"P\": np.array([\n                [400, 1600],\n                [200, 2000]\n            ]),\n            \"b\": np.array([\n                [0.0, 0.0],\n                [0.0, 0.0]\n            ])\n        },\n        # Test Case 4: No valid pixels\n        {\n            \"T\": np.array([\n                [np.nan, np.nan],\n                [np.nan, np.nan]\n            ]),\n            \"P\": np.array([\n                [np.nan, np.nan],\n                [np.nan, np.nan]\n            ]),\n            \"b\": np.array([\n                [np.nan, np.nan],\n                [np.nan, np.nan]\n            ])\n        }\n    ]\n\n    results = []\n    # Suitability threshold\n    tau_s = 0.8\n\n    for case in test_cases:\n        T, P, b = case[\"T\"], case[\"P\"], case[\"b\"]\n        \n        # 1. Identify valid pixels (not NaN in any layer)\n        valid_pixels_mask = ~np.isnan(T) & ~np.isnan(P) & ~np.isnan(b)\n        num_valid_pixels = np.sum(valid_pixels_mask)\n\n        # Handle case with no valid pixels\n        if num_valid_pixels == 0:\n            results.append(0.0)\n            continue\n\n        # 2. Clip biotic exclusion factor b to [0, 1]\n        b_clipped = np.clip(b, 0, 1)\n\n        # 3. Calculate climate feasibility indicator C(x)\n        # C(x) is 1 if T and P are within bounds, 0 otherwise.\n        temp_feasibility = (T >= 10) & (T <= 30)\n        precip_feasibility = (P >= 500) & (P <= 1500)\n        climate_feasibility_mask = temp_feasibility & precip_feasibility\n\n        # 4. Compute the suitability index s(x)\n        # s(x) = C(x) * (1 - b_clipped)\n        # This works because the boolean mask acts as 0s and 1s.\n        suitability_grid = climate_feasibility_mask * (1 - b_clipped)\n        \n        # 5. Count pixels where s(x) >= tau_s, but only for valid pixels\n        suitable_mask = suitability_grid >= tau_s\n        # The number of suitable pixels is the sum of pixels that are\n        # both suitable AND valid.\n        num_suitable_pixels = np.sum(suitable_mask & valid_pixels_mask)\n\n        # 6. Compute the final fraction f\n        f = num_suitable_pixels / num_valid_pixels\n        \n        # Store the result, rounded to six decimal places\n        results.append(round(f, 6))\n\n    # Format the final output string exactly as required, ensuring six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当拥有物种存在-缺失的观测数据时，我们可以从基于规则的模型转向更为强大的数据驱动统计模型。本练习的核心是应用广义线性模型（GLM）中的逻辑斯谛回归，根据环境变量来预测物种的出现概率。您将亲手实现一个带有正则化项的模型拟合过程 ，这对于处理现实世界生态数据中常见的共线性和准分离问题至关重要，并最终用所建模型生成预测适宜性图。",
            "id": "3818652",
            "problem": "给定一个二元存在-缺失数据集和来自遥感技术的环境变量，用于栖息地适宜性建模。假设每个观测值 $(y_i, x_i)$ 满足一个伯努利数据生成过程，其概率为 $p_i$ 并使用逻辑斯蒂链接函数：$y_i \\sim \\mathrm{Bernoulli}(p_i)$，其中 $p_i = \\mathrm{logit}^{-1}(\\eta_i)$ 且 $\\eta_i = \\beta_0 + \\beta^\\top x_i$。此处，$x_i \\in \\mathbb{R}^d$ 是协变量（不含截距项），$\\beta_0 \\in \\mathbb{R}$ 是截距，$\\beta \\in \\mathbb{R}^d$ 是斜率系数。逆 logit 函数定义为 $\\mathrm{logit}^{-1}(z) = \\frac{1}{1 + e^{-z}}$。\n\n您的任务是编写一个完整的程序，对于下面提供的每个测试用例，通过最大化逻辑斯蒂链接下的伯努利对数似然来拟合系数向量 $(\\beta_0, \\beta)$，在提供的协变量测试网格上计算预测的适宜性值，并报告拟合的系数估计值和整个网格的平均预测适宜性。为确保在准分离或共线性情况下的可识别性和数值稳定性，请对斜率（而非截距）使用各向同性高斯先验，这等同于仅对斜率添加强度为 $\\lambda$ 的 $\\ell_2$ 岭惩罚。具体而言，目标是惩罚对数似然\n$$\n\\ell(\\beta_0,\\beta) = \\sum_{i=1}^n \\left[ y_i \\,\\eta_i - \\log\\left(1 + e^{\\eta_i}\\right) \\right] - \\frac{\\lambda}{2}\\,\\|\\beta\\|_2^2,\n$$\n其中 $\\beta_0$ 没有惩罚项。使用 $\\lambda = 10^{-4}$。请勿应用任何其他正则化、加权或特征变换。\n\n使用的基本原理：伯努利似然、逻辑斯蒂链接的定义以及最大似然估计原则（可选地，高斯先验下的最大后验估计，它会产生指定的 $\\ell_2$ 惩罚）。\n\n基于第一性原理实现一个数值稳定且收敛的求解器，例如用于广义线性模型 (GLM) 的 Newton–Raphson 方法，并确保对 Hessian 矩阵进行调整以仅包含对斜率的惩罚。您可以假设由于岭惩罚，Hessian 矩阵是严格正定的，并且可以通过参数的最大绝对变化来检验收敛性。\n\n对于每个测试用例，计算：\n- 拟合的系数 $(\\hat{\\beta}_0, \\hat{\\beta})$。\n- 对于给定的每个网格协变量 $x_g$，计算预测的适宜性值 $p_g = \\mathrm{logit}^{-1}(\\hat{\\beta}_0 + \\hat{\\beta}^\\top x_g)$。\n- 整个网格的平均预测适宜性 $\\bar{p} = \\frac{1}{m} \\sum_{g=1}^m p_g$。\n\n所有输出都是无量纲的概率，因此不需要物理单位。如果任何量可以解释为比率或比例，请以 $[0,1]$ 范围的小数表示。\n\n数据集和网格的测试套件：\n- 测试用例 1（理想情况，两个协变量）：\n  - 每个观测值的协变量 $(\\mathrm{NDVI}, \\mathrm{distance\\_to\\_water})$：\n    - $x_1 = (0.75, 0.2),\\; x_2 = (0.68, 0.5),\\; x_3 = (0.80, 1.2),\\; x_4 = (0.55, 2.0),$\n    - $x_5 = (0.40, 3.5),\\; x_6 = (0.30, 4.0),\\; x_7 = (0.62, 1.5),\\; x_8 = (0.48, 2.8),$\n    - $x_9 = (0.72, 0.8),\\; x_{10} = (0.66, 1.0)$。\n  - 存在-缺失响应：\n    - $y = (1, 1, 1, 0, 0, 0, 1, 0, 1, 1)$。\n  - 测试网格协变量：\n    - $g_1 = (0.60, 1.0),\\; g_2 = (0.50, 3.0),\\; g_3 = (0.80, 0.5),\\; g_4 = (0.35, 4.5)$。\n- 测试用例 2（准分离，两个协变量）：\n  - 协变量：\n    - $x_1 = (0.82, 3.0),\\; x_2 = (0.78, 2.5),\\; x_3 = (0.76, 1.0),\\; x_4 = (0.20, 0.8),$\n    - $x_5 = (0.30, 1.5),\\; x_6 = (0.35, 2.0),\\; x_7 = (0.70, 4.0),\\; x_8 = (0.45, 3.5)$。\n  - 响应：\n    - $y = (1, 1, 1, 0, 0, 0, 1, 0)$。\n  - 测试网格：\n    - $g_1 = (0.25, 1.0),\\; g_2 = (0.65, 2.0),\\; g_3 = (0.85, 0.5)$。\n- 测试用例 3（高度共线性，两个协变量）：\n  - 协变量：\n    - $x_1 = (0.20, 0.402),\\; x_2 = (0.25, 0.499),\\; x_3 = (0.30, 0.601),\\; x_4 = (0.35, 0.699),$\n    - $x_5 = (0.40, 0.800),\\; x_6 = (0.45, 0.901),\\; x_7 = (0.50, 1.001),\\; x_8 = (0.55, 1.099),$\n    - $x_9 = (0.60, 1.199),\\; x_{10} = (0.65, 1.300)$。\n  - 响应：\n    - $y = (0, 0, 0, 0, 1, 1, 1, 1, 1, 1)$。\n  - 测试网格：\n    - $g_1 = (0.33, 0.66),\\; g_2 = (0.58, 1.16)$。\n\n程序要求：\n- 使用 Newton–Raphson 过程实现惩罚伯努利对数似然的最大化，其中 Hessian 矩阵等于 $X^\\top W X + \\Lambda$，$W$ 是对角矩阵，其元素为 $p_i (1 - p_i)$，$\\Lambda$ 是对角矩阵，其元素为 $(0, \\lambda, \\lambda, \\dots, \\lambda)$，这样只有斜率被惩罚。\n- 使用 $\\lambda = 10^{-4}$ 并将 $(\\beta_0, \\beta)$ 初始化为零。\n- 收敛准则：当参数的最大绝对更新值小于 $10^{-9}$ 或在 100 次迭代后停止，以先到者为准。\n- 对于每个测试用例，计算并报告一个包含 4 个值的列表：$[\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\bar{p}]$，其中 $\\bar{p}$ 是该测试用例在网格上的平均预测适宜性。\n- 最终输出格式：您的程序应生成单行输出，其中包含结果，格式为列表的列表，以逗号分隔，每个值四舍五入到 $6$ 位小数，例如 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4]]$。",
            "solution": "我们从二元存在-缺失数据的伯努利似然和逻辑斯蒂链接开始。对于每个观测值 $i \\in \\{1,\\dots,n\\}$，其响应为 $y_i \\in \\{0,1\\}$，协变量向量为 $x_i \\in \\mathbb{R}^d$（不含截距），模型假设 $y_i \\sim \\mathrm{Bernoulli}(p_i)$，其中 $p_i = \\mathrm{logit}^{-1}(\\eta_i)$ 且 $\\eta_i = \\beta_0 + \\beta^\\top x_i$。逆 logit 函数为 $\\mathrm{logit}^{-1}(z) = \\frac{1}{1 + e^{-z}}$，它将 $\\mathbb{R}$ 映射到 $(0,1)$。\n\n参数 $(\\beta_0, \\beta)$ 的对数似然是\n$$\n\\ell_{\\text{ll}}(\\beta_0,\\beta) = \\sum_{i=1}^n \\left[ y_i \\,\\eta_i - \\log\\!\\left(1 + e^{\\eta_i}\\right) \\right].\n$$\n为了处理准分离和共线性问题并确保数值稳定性，我们对斜率（而非截距）采用高斯先验，这等同于仅对斜率添加 $\\ell_2$ 惩罚。令 $\\lambda > 0$ 表示惩罚强度，并定义惩罚对数似然\n$$\n\\ell(\\beta_0,\\beta) = \\ell_{\\text{ll}}(\\beta_0,\\beta) - \\frac{\\lambda}{2}\\,\\|\\beta\\|_2^2.\n$$\n这等同于在 $\\beta \\sim \\mathcal{N}(0, \\lambda^{-1} I)$ 条件下的最大后验估计，其中对 $\\beta_0$ 没有先验惩罚。最大化因子 $(\\hat{\\beta}_0,\\hat{\\beta})$ 可以通过 Newton–Raphson 迭代获得，该方法使用 $\\ell$ 的梯度和 Hessian 矩阵。\n\n令 $X \\in \\mathbb{R}^{n \\times (d+1)}$ 表示设计矩阵，其第一列全为 1（截距项），其余 $d$ 列为协变量。将完整的参数向量表示为 $\\theta = (\\beta_0, \\beta_1, \\dots, \\beta_d)^\\top \\in \\mathbb{R}^{d+1}$。令 $p \\in \\mathbb{R}^n$ 为一个向量，其元素为 $p_i = \\mathrm{logit}^{-1}(x_i^\\top \\theta)$，其中 $x_i$ 现在指代 $X$ 中包含截距的完整行。未惩罚的对数似然的梯度是\n$$\n\\nabla \\ell_{\\text{ll}}(\\theta) = X^\\top (y - p),\n$$\n其中 $y \\in \\mathbb{R}^n$ 是响应向量，减法是逐元素进行的。未惩罚的对数似然的 Hessian 矩阵是\n$$\n\\nabla^2 \\ell_{\\text{ll}}(\\theta) = -X^\\top W X,\n$$\n其中 $W \\in \\mathbb{R}^{n \\times n}$ 是一个对角矩阵，其对角元素为 $W_{ii} = p_i (1 - p_i)$。对于仅对斜率施加惩罚的惩罚目标函数，定义 $\\Lambda \\in \\mathbb{R}^{(d+1) \\times (d+1)}$ 为一个对角矩阵，其对角元素为 $(0, \\lambda, \\dots, \\lambda)$，其中第一个元素为零确保了对截距没有惩罚。惩罚对数后验的梯度和 Hessian 矩阵则为\n$$\n\\nabla \\ell(\\theta) = X^\\top (y - p) - \\Lambda \\theta,\\quad\n\\nabla^2 \\ell(\\theta) = -X^\\top W X - \\Lambda.\n$$\nNewton–Raphson 更新通过求解线性系统\n$$\n\\big(X^\\top W X + \\Lambda\\big)\\, \\Delta \\theta = X^\\top (y - p) - \\Lambda \\theta,\n$$\n来获得增量 $\\Delta \\theta$，然后更新 $\\theta \\leftarrow \\theta + \\Delta \\theta$。这是一种适用于岭惩罚广义线性模型 (GLM) 的迭代重加权最小二乘法 (IRLS) 风格的更新。由于 $\\Lambda$ 是半正定的，并且斜率分量对应的元素是严格正的，只要至少有一个观测值的 $p_i \\in (0,1)$ 并且 $\\lambda > 0$，$X^\\top W X + \\Lambda$ 就将是正定的，这保证了 $\\Delta \\theta$ 的唯一解和良好的数值条件。\n\n每个测试用例的算法步骤：\n- 通过将一列 1 与协变量矩阵连接起来，构成 $X$。\n- 初始化 $\\theta^{(0)} = 0 \\in \\mathbb{R}^{d+1}$。\n- 对于迭代 $t = 0, 1, \\dots$，最多 100 次：\n  - 计算 $\\eta^{(t)} = X \\theta^{(t)}$，然后 $p^{(t)} = \\mathrm{logit}^{-1}(\\eta^{(t)})$。\n  - 构成 $W^{(t)}$，其中 $W_{ii}^{(t)} = p_i^{(t)} \\big( 1 - p_i^{(t)} \\big)$。\n  - 计算梯度 $g^{(t)} = X^\\top \\big( y - p^{(t)} \\big) - \\Lambda \\theta^{(t)}$。\n  - 计算类 Hessian 矩阵 $H^{(t)} = X^\\top W^{(t)} X + \\Lambda$。\n  - 求解 $H^{(t)} \\Delta \\theta^{(t)} = g^{(t)}$ 并更新 $\\theta^{(t+1)} = \\theta^{(t)} + \\Delta \\theta^{(t)}$。\n  - 当 $\\|\\Delta \\theta^{(t)}\\|_\\infty < 10^{-9}$ 时停止。\n- 令 $(\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2)$ 为当 $d = 2$ 个协变量时 $\\hat{\\theta}$ 的分量。\n- 对于每个网格协变量 $x_g \\in \\mathbb{R}^2$，计算 $p_g = \\mathrm{logit}^{-1}\\big(\\hat{\\beta}_0 + \\hat{\\beta}_1 x_{g1} + \\hat{\\beta}_2 x_{g2}\\big)$。\n- 计算 $\\bar{p} = \\frac{1}{m} \\sum_{g=1}^m p_g$，其中 $m$ 是网格点的数量，且所有权重相等。\n\n数值稳定性考虑：\n- 为避免在计算 $\\mathrm{logit}^{-1}(z)$ 时发生溢出，应以数值稳定的方式进行计算，例如在应用 $1/(1+e^{-z})$ 之前将 $z$ 裁剪到一个有界区间，如 $[-35, 35]$，或者使用一个稳定的逻辑斯蒂函数实现。\n- 带有 $\\lambda = 10^{-4}$ 的岭惩罚可以在存在高度共线性或近分离的情况下避免 $H^{(t)}$ 的奇异性，从而确保每次迭代中线性求解的可逆性。\n- 截距项不被惩罚，这与正则化 GLM 中的标准做法一致。\n\n输出规格：\n- 对于每个测试用例，生成列表 $[\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\bar{p}]$，所有值四舍五入到 6 位小数。\n- 将所有测试用例的结果汇总到一个列表的列表中，并将该列表作为程序的唯一输出打印在单行上，例如：$[[b_{01}, b_{11}, b_{21}, \\bar{p}_1], [b_{02}, b_{12}, b_{22}, \\bar{p}_2], [b_{03}, b_{13}, b_{23}, \\bar{p}_3]]$。\n\n此过程直接将栖息地适宜性建模实现为对遥感协变量的逻辑斯蒂回归，计算代表研究区域的测试网格上的预测适宜性，并报告拟合的系数和平均预测适宜性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef stable_logistic(z):\n    # Compute logistic function in a numerically stable way.\n    # Clip z to avoid overflow in exp.\n    z = np.clip(z, -35.0, 35.0)\n    return 1.0 / (1.0 + np.exp(-z))\n\ndef fit_logistic_ridge(X, y, lam=1e-4, tol=1e-9, max_iter=100):\n    \"\"\"\n    Fit penalized logistic regression with ridge penalty on slopes only.\n    X: (n, d+1) design matrix with intercept in the first column (ones).\n    y: (n,) binary responses.\n    lam: ridge penalty strength applied to slopes only.\n    Returns theta of shape (d+1,).\n    \"\"\"\n    n, p = X.shape\n    theta = np.zeros(p, dtype=float)\n    # Penalty matrix: 0 on intercept, lam on slopes.\n    Lambda = np.diag([0.0] + [lam] * (p - 1))\n\n    for _ in range(max_iter):\n        eta = X @ theta\n        p_hat = stable_logistic(eta)\n        W = p_hat * (1.0 - p_hat)  # (n,)\n        # Form X^T W X efficiently\n        # H = X^T W X + Lambda\n        # Use broadcasting to multiply rows of X by W\n        XW = X * W[:, None]\n        H = X.T @ XW + Lambda\n        # gradient: X^T(y - p) - Lambda theta\n        g = X.T @ (y - p_hat) - Lambda @ theta\n        try:\n            delta = np.linalg.solve(H, g)\n        except np.linalg.LinAlgError:\n            # Fallback to least squares solution if needed\n            delta = np.linalg.lstsq(H, g, rcond=None)[0]\n        theta_new = theta + delta\n        if np.max(np.abs(delta)) < tol:\n            theta = theta_new\n            break\n        theta = theta_new\n    return theta\n\ndef predict_logistic(theta, X_grid):\n    \"\"\"\n    Predict probabilities for grid covariates without intercept column.\n    theta: (d+1,), X_grid: (m, d)\n    \"\"\"\n    intercept = theta[0]\n    beta = theta[1:]\n    eta = intercept + X_grid @ beta\n    return stable_logistic(eta)\n\ndef solve():\n    lam = 1e-4\n\n    # Test case 1\n    X1_cov = np.array([\n        [0.75, 0.2],\n        [0.68, 0.5],\n        [0.80, 1.2],\n        [0.55, 2.0],\n        [0.40, 3.5],\n        [0.30, 4.0],\n        [0.62, 1.5],\n        [0.48, 2.8],\n        [0.72, 0.8],\n        [0.66, 1.0],\n    ], dtype=float)\n    y1 = np.array([1,1,1,0,0,0,1,0,1,1], dtype=float)\n    G1 = np.array([\n        [0.60, 1.0],\n        [0.50, 3.0],\n        [0.80, 0.5],\n        [0.35, 4.5],\n    ], dtype=float)\n\n    # Test case 2\n    X2_cov = np.array([\n        [0.82, 3.0],\n        [0.78, 2.5],\n        [0.76, 1.0],\n        [0.20, 0.8],\n        [0.30, 1.5],\n        [0.35, 2.0],\n        [0.70, 4.0],\n        [0.45, 3.5],\n    ], dtype=float)\n    y2 = np.array([1,1,1,0,0,0,1,0], dtype=float)\n    G2 = np.array([\n        [0.25, 1.0],\n        [0.65, 2.0],\n        [0.85, 0.5],\n    ], dtype=float)\n\n    # Test case 3\n    X3_cov = np.array([\n        [0.20, 0.402],\n        [0.25, 0.499],\n        [0.30, 0.601],\n        [0.35, 0.699],\n        [0.40, 0.800],\n        [0.45, 0.901],\n        [0.50, 1.001],\n        [0.55, 1.099],\n        [0.60, 1.199],\n        [0.65, 1.300],\n    ], dtype=float)\n    y3 = np.array([0,0,0,0,1,1,1,1,1,1], dtype=float)\n    G3 = np.array([\n        [0.33, 0.66],\n        [0.58, 1.16],\n    ], dtype=float)\n\n    test_cases = [\n        (X1_cov, y1, G1),\n        (X2_cov, y2, G2),\n        (X3_cov, y3, G3),\n    ]\n\n    results = []\n    for X_cov, y, G in test_cases:\n        n, d = X_cov.shape\n        # Build design matrix with intercept\n        X = np.hstack([np.ones((n, 1)), X_cov])\n        theta_hat = fit_logistic_ridge(X, y, lam=lam, tol=1e-9, max_iter=100)\n        # Predictions on grid\n        p_grid = predict_logistic(theta_hat, G)\n        avg_p = float(np.mean(p_grid))\n        # Collect [beta0, beta1, beta2, avg_p]\n        res = [float(theta_hat[0]), float(theta_hat[1]), float(theta_hat[2]), avg_p]\n        results.append(res)\n\n    # Format results: each value rounded to 6 decimals\n    def fmt(x):\n        return f\"{x:.6f}\"\n\n    out = \"[\" + \",\".join(\"[\" + \",\".join(fmt(v) for v in row) + \"]\" for row in results) + \"]\"\n    print(out)\n\nsolve()\n```"
        },
        {
            "introduction": "任何预测模型的价值最终取决于其在新的环境（例如，不同的地理区域或未来的气候情景）中的表现和可靠性。本练习旨在解决模型外推这一关键问题，即在超出训练数据范围的条件下进行预测。您将学习计算多变量环境相似性表面（MESS）来量化环境的新颖性，并应用“钳位”（clamping）技术来约束模型的预测 ，从而培养对预测模型局限性的批判性认识。",
            "id": "3818689",
            "problem": "您正在使用一组源自遥感和气候数据的环境预测因子来为某一物种建模其栖息地适宜性，以评估未来的预测情景。您将实施一个严谨的程序来计算多变量环境相似性表面 (MESS) 图，识别外推，对预测因子应用训练范围内的钳制，并量化未来情景下预测适宜性的变化。所有计算都必须基于有界区间上的归一化和逻辑斯谛变换的基本定义，并且必须以数学方式表达。\n\n设预测因子向量为 $\\mathbf{z} = (z_1, z_2, z_3)$，其中 $z_1$ 是年平均温度，单位为摄氏度；$z_2$ 是年降水量，单位为毫米/年；$z_3$ 是归一化植被指数 (NDVI，无单位)。训练环境空间由下界 $\\mathbf{a} = (a_1, a_2, a_3)$ 和上界 $\\mathbf{b} = (b_1, b_2, b_3)$、训练均值 $\\boldsymbol{\\mu} = (\\mu_1, \\mu_2, \\mu_3)$ 以及训练标准差 $\\boldsymbol{\\sigma} = (\\sigma_1, \\sigma_2, \\sigma_3)$ 概括。各元素如下：\n- 温度：$a_1 = 12$ 摄氏度, $b_1 = 20$ 摄氏度, $\\mu_1 = 16$ 摄氏度, $\\sigma_1 = 2.5$ 摄氏度。\n- 降水量：$a_2 = 800$ 毫米/年, $b_2 = 1200$ 毫米/年, $\\mu_2 = 1000$ 毫米/年, $\\sigma_2 = 120$ 毫米/年。\n- NDVI：$a_3 = 0.4$ (无单位), $b_3 = 0.7$ (无单位), $\\mu_3 = 0.55$ (无单位), $\\sigma_3 = 0.08$ (无单位)。\n\n为每个预测因子 $i \\in \\{1,2,3\\}$，定义其在训练区间内的归一化位置为\n$$\ns_i(z_i) = \\frac{z_i - a_i}{b_i - a_i}.\n$$\n通过分段表达式定义每个变量基于中心性的相似度函数 $c_i(z_i)$\n$$\nc_i(z_i) =\n\\begin{cases}\n1 - 2\\left| s_i(z_i) - \\frac{1}{2} \\right|,  \\text{if } a_i \\le z_i \\le b_i, \\\\\n-\\dfrac{a_i - z_i}{b_i - a_i},  \\text{if } z_i < a_i, \\\\\n-\\dfrac{z_i - b_i}{b_i - a_i},  \\text{if } z_i > b_i.\n\\end{cases}\n$$\n该函数产生的值在区间 $[-1,1]$ 内，在区间中心等于 $1$，在边界处等于 $0$，在训练范围外为负值，其大小与超出距离相对于区间宽度的比例成正比。\n\n定义多变量环境相似性表面 (MESS) 得分为\n$$\nM(\\mathbf{z}) = \\min\\{c_1(z_1), c_2(z_2), c_3(z_3)\\}.\n$$\n定义外推为以下条件\n$$\nE(\\mathbf{z}) = \\left( \\exists i \\in \\{1,2,3\\} \\text{ such that } z_i < a_i \\text{ or } z_i > b_i \\right),\n$$\n等价地，$E(\\mathbf{z})$ 为真当且仅当 $M(\\mathbf{z}) < 0$。\n\n为限制外推对预测的影响，为每个预测因子定义到训练区间的钳制：\n$$\n\\tilde{z}_i = \\min\\{ \\max\\{ z_i, a_i \\}, b_i \\}, \\quad i \\in \\{1,2,3\\}.\n$$\n设标准化后的预测因子为\n$$\nz_i^{\\star} = \\frac{z_i - \\mu_i}{\\sigma_i}, \\quad \\tilde{z}_i^{\\star} = \\frac{\\tilde{z}_i - \\mu_i}{\\sigma_i}.\n$$\n假设适宜性由一个使用固定系数 $\\boldsymbol{\\beta} = (\\beta_0, \\beta_1, \\beta_2, \\beta_3)$ 的逻辑斯谛函数（一个带有 logit 连接的广义线性模型 (GLM)）建模：\n$$\n\\beta_0 = -0.5, \\quad \\beta_1 = 0.9, \\quad \\beta_2 = 0.6, \\quad \\beta_3 = 1.2.\n$$\n定义线性预测器\n$$\nf(\\mathbf{z}) = \\beta_0 + \\beta_1 z_1^{\\star} + \\beta_2 z_2^{\\star} + \\beta_3 z_3^{\\star}, \\quad\nf(\\tilde{\\mathbf{z}}) = \\beta_0 + \\beta_1 \\tilde{z}_1^{\\star} + \\beta_2 \\tilde{z}_2^{\\star} + \\beta_3 \\tilde{z}_3^{\\star},\n$$\n以及适宜性值\n$$\nS(\\mathbf{z}) = \\frac{1}{1 + e^{-f(\\mathbf{z})}}, \\quad S(\\tilde{\\mathbf{z}}) = \\frac{1}{1 + e^{-f(\\tilde{\\mathbf{z}})}}.\n$$\n将钳制引起的预测适宜性变化量化为\n$$\n\\Delta S = S(\\tilde{\\mathbf{z}}) - S(\\mathbf{z}).\n$$\n\n实现一个程序，对于一组未来气候情景的像素点，计算 $M(\\mathbf{z})$、$E(\\mathbf{z})$ 和 $\\Delta S$。所有原始预测因子必须使用上述指定的物理单位进行处理。报告浮点数答案，四舍五入至6位小数。本题不涉及角度。不使用百分比。\n\n使用以下未来预测因子向量 $\\mathbf{z}$ 的测试集：\n- 测试 $1$：$\\mathbf{z} = (16, 1000, 0.55)$，单位如上所述。\n- 测试 $2$：$\\mathbf{z} = (24, 900, 0.60)$，单位如上所述。\n- 测试 $3$：$\\mathbf{z} = (12, 800, 0.40)$，单位如上所述。\n- 测试 $4$：$\\mathbf{z} = (10, 1300, 0.20)$，单位如上所述。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例贡献一个形式为 $[M(\\mathbf{z}), E(\\mathbf{z}), \\Delta S]$ 的列表。例如，输出格式必须为 $[[m_1,e_1,d_1],[m_2,e_2,d_2],[m_3,e_3,d_3],[m_4,e_4,d_4]]$，所有浮点值都四舍五入到6位小数。",
            "solution": "该问题要求实施一个程序来评估未来环境情景下的栖息地适宜性，包括计算多变量环境相似性表面 (MESS)、识别外推、应用预测因子钳制，以及量化由此导致的预测适宜性变化。该问题在科学上是合理的，定义明确，并提供了所有必要的参数和定义。\n\n首先，我们确定所提供的常数和参数。环境预测因子为 $\\mathbf{z} = (z_1, z_2, z_3)$。训练数据由下界 $\\mathbf{a} = (12, 800, 0.4)$、上界 $\\mathbf{b} = (20, 1200, 0.7)$、均值 $\\boldsymbol{\\mu} = (16, 1000, 0.55)$ 和标准差 $\\boldsymbol{\\sigma} = (2.5, 120, 0.08)$ 概括。逻辑斯谛模型系数为 $\\boldsymbol{\\beta} = (\\beta_0, \\beta_1, \\beta_2, \\beta_3) = (-0.5, 0.9, 0.6, 1.2)$。\n\n对于任何给定的未来预测因子向量 $\\mathbf{z}$，求解过程包括以下顺序步骤：\n\n1.  **计算每个变量的相似度得分 $c_i(z_i)$，其中 $i \\in \\{1,2,3\\}$。**\n    这首先需要计算归一化位置 $s_i(z_i) = \\frac{z_i - a_i}{b_i - a_i}$。然后通过分段函数确定相似度 $c_i(z_i)$：\n    $$\n    c_i(z_i) =\n    \\begin{cases}\n    1 - 2\\left| s_i(z_i) - \\frac{1}{2} \\right|,  \\text{if } a_i \\le z_i \\le b_i \\\\\n    -\\dfrac{a_i - z_i}{b_i - a_i} = s_i(z_i),  \\text{if } z_i < a_i \\\\\n    -\\dfrac{z_i - b_i}{b_i - a_i} = -(s_i(z_i) - 1),  \\text{if } z_i > b_i\n    \\end{cases}\n    $$\n    注意，对于 $z_i < a_i$ 和 $z_i > b_i$ 的表达式也可以用 $s_i(z_i)$ 来表示。对于 $z_i < a_i$，$s_i(z_i) = \\frac{z_i-a_i}{b_i-a_i} < 0$，且 $-\\frac{a_i-z_i}{b_i-a_i} = \\frac{z_i-a_i}{b_i-a_i} = s_i(z_i)$。\n\n2.  **计算 MESS 得分 $M(\\mathbf{z})$ 并确定外推 $E(\\mathbf{z})$。**\n    MESS 得分是各独立相似度得分的最小值：\n    $$\n    M(\\mathbf{z}) = \\min\\{c_1(z_1), c_2(z_2), c_3(z_3)\\}\n    $$\n    如果任何预测因子超出其训练范围，则发生外推 $E(\\mathbf{z})$，这等同于 MESS 得分为负。我们将 $E(\\mathbf{z})$ 表示为 $1$（如果为真，即外推）和 $0$（如果为假，即内插或在边界上）。\n    $$\n    E(\\mathbf{z}) =\n    \\begin{cases}\n    1  \\text{if } M(\\mathbf{z}) < 0 \\\\\n    0  \\text{if } M(\\mathbf{z}) \\ge 0\n    \\end{cases}\n    $$\n\n3.  **执行预测因子钳制。**\n    为减轻外推的影响，将每个预测因子 $z_i$ 钳制到其训练范围 $[a_i, b_i]$ 内：\n    $$\n    \\tilde{z}_i = \\min\\{ \\max\\{ z_i, a_i \\}, b_i \\}\n    $$\n    这样就创建了一个钳制后的预测因子向量 $\\tilde{\\mathbf{z}} = (\\tilde{z}_1, \\tilde{z}_2, \\tilde{z}_3)$。\n\n4.  **对原始和钳制后的预测因子进行标准化。**\n    使用训练均值 $\\boldsymbol{\\mu}$ 和标准差 $\\boldsymbol{\\sigma}$ 对原始向量 $\\mathbf{z}$ 和钳制后的向量 $\\tilde{\\mathbf{z}}$进行标准化：\n    $$\n    z_i^{\\star} = \\frac{z_i - \\mu_i}{\\sigma_i}, \\quad \\tilde{z}_i^{\\star} = \\frac{\\tilde{z}_i - \\mu_i}{\\sigma_i}\n    $$\n\n5.  **计算适宜性得分 $S(\\mathbf{z})$ 和 $S(\\tilde{\\mathbf{z}})$。**\n    首先，使用系数 $\\boldsymbol{\\beta}$ 计算线性预测器：\n    $$\n    f(\\mathbf{z}) = \\beta_0 + \\beta_1 z_1^{\\star} + \\beta_2 z_2^{\\star} + \\beta_3 z_3^{\\star}\n    $$\n    $$\n    f(\\tilde{\\mathbf{z}}) = \\beta_0 + \\beta_1 \\tilde{z}_1^{\\star} + \\beta_2 \\tilde{z}_2^{\\star} + \\beta_3 \\tilde{z}_3^{\\star}\n    $$\n    然后，应用逻辑斯谛函数获得适宜性得分：\n    $$\n    S(\\mathbf{z}) = \\frac{1}{1 + e^{-f(\\mathbf{z})}}, \\quad S(\\tilde{\\mathbf{z}}) = \\frac{1}{1 + e^{-f(\\tilde{\\mathbf{z}})}}\n    $$\n\n6.  **量化适宜性的变化 $\\Delta S$。**\n    该变化是钳制后和原始适宜性预测值之间的差：\n    $$\n    \\Delta S = S(\\tilde{\\mathbf{z}}) - S(\\mathbf{z})\n    $$\n\n我们来逐步演算**测试用例2**的计算过程：$\\mathbf{z} = (24, 900, 0.60)$。\n\n1.  **相似度得分 $c_i(z_i)$**：\n    *   $z_1 = 24 > b_1 = 20$。外推。$c_1(24) = -\\frac{24 - 20}{20 - 12} = -\\frac{4}{8} = -0.5$。\n    *   $a_2 = 800 \\le z_2 = 900 \\le b_2 = 1200$。内插。$s_2(900) = \\frac{900 - 800}{1200 - 800} = \\frac{100}{400} = 0.25$。\n        $c_2(900) = 1 - 2|0.25 - 0.5| = 1 - 2(0.25) = 0.5$。\n    *   $a_3 = 0.4 \\le z_3 = 0.6 \\le b_3 = 0.7$。内插。$s_3(0.6) = \\frac{0.6 - 0.4}{0.7 - 0.4} = \\frac{0.2}{0.3} = \\frac{2}{3}$。\n        $c_3(0.6) = 1 - 2|\\frac{2}{3} - 0.5| = 1 - 2(\\frac{1}{6}) = \\frac{2}{3} \\approx 0.666667$。\n\n2.  **MESS 得分 $M(\\mathbf{z})$ 和外推 $E(\\mathbf{z})$**：\n    *   $M(\\mathbf{z}) = \\min\\{-0.5, 0.5, \\frac{2}{3}\\} = -0.5$。\n    *   由于 $M(\\mathbf{z}) < 0$，存在外推，因此 $E(\\mathbf{z}) = 1$。\n\n3.  **预测因子钳制**：\n    *   $\\tilde{z}_1 = \\min\\{\\max\\{24, 12\\}, 20\\} = \\min\\{24, 20\\} = 20$。\n    *   $\\tilde{z}_2 = \\min\\{\\max\\{900, 800\\}, 1200\\} = \\min\\{900, 1200\\} = 900$。\n    *   $\\tilde{z}_3 = \\min\\{\\max\\{0.6, 0.4\\}, 0.7\\} = \\min\\{0.6, 0.7\\} = 0.6$。\n    *   $\\tilde{\\mathbf{z}} = (20, 900, 0.6)$。\n\n4.  **标准化**：\n    *   $z_1^{\\star} = \\frac{24 - 16}{2.5} = 3.2$, $z_2^{\\star} = \\frac{900 - 1000}{120} = -\\frac{5}{6}$, $z_3^{\\star} = \\frac{0.6 - 0.55}{0.08} = 0.625$。\n    *   $\\tilde{z}_1^{\\star} = \\frac{20 - 16}{2.5} = 1.6$, $\\tilde{z}_2^{\\star} = \\frac{900 - 1000}{120} = -\\frac{5}{6}$, $\\tilde{z}_3^{\\star} = \\frac{0.6 - 0.55}{0.08} = 0.625$。\n\n5.  **适宜性计算**：\n    *   $f(\\mathbf{z}) = -0.5 + 0.9(3.2) + 0.6(-\\frac{5}{6}) + 1.2(0.625) = -0.5 + 2.88 - 0.5 + 0.75 = 2.63$。\n    *   $S(\\mathbf{z}) = \\frac{1}{1 + e^{-2.63}} \\approx 0.932717$。\n    *   $f(\\tilde{\\mathbf{z}}) = -0.5 + 0.9(1.6) + 0.6(-\\frac{5}{6}) + 1.2(0.625) = -0.5 + 1.44 - 0.5 + 0.75 = 1.19$。\n    *   $S(\\tilde{\\mathbf{z}}) = \\frac{1}{1 + e^{-1.19}} \\approx 0.766755$。\n\n6.  **变化 $\\Delta S$**：\n    *   $\\Delta S = S(\\tilde{\\mathbf{z}}) - S(\\mathbf{z}) \\approx 0.766755 - 0.932717 = -0.165962$。\n\n该测试用例的最终结果，在四舍五入到6位小数后，是 $[M(\\mathbf{z}), E(\\mathbf{z}), \\Delta S] = [-0.5, 1, -0.165962]$。对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes habitat suitability metrics for a set of future climate scenarios.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    # Lower bounds [temperature, precipitation, NDVI]\n    a = np.array([12.0, 800.0, 0.4])\n    # Upper bounds\n    b = np.array([20.0, 1200.0, 0.7])\n    # Training means\n    mu = np.array([16.0, 1000.0, 0.55])\n    # Training standard deviations\n    sigma = np.array([2.5, 120.0, 0.08])\n    # GLM coefficients [intercept, beta1, beta2, beta3]\n    beta = np.array([-0.5, 0.9, 0.6, 1.2])\n\n    test_cases = [\n        np.array([16.0, 1000.0, 0.55]),  # Test 1\n        np.array([24.0, 900.0, 0.60]),   # Test 2\n        np.array([12.0, 800.0, 0.40]),   # Test 3\n        np.array([10.0, 1300.0, 0.20])   # Test 4\n    ]\n\n    all_results = []\n\n    for z in test_cases:\n        # Step 1: Compute per-variable centrality-based similarity c_i(z_i)\n        c = np.zeros(3)\n        interval_width = b - a\n        \n        for i in range(3):\n            if z[i] < a[i]:\n                # Extrapolation below the lower bound\n                c[i] = -(a[i] - z[i]) / interval_width[i]\n            elif z[i] > b[i]:\n                # Extrapolation above the upper bound\n                c[i] = -(z[i] - b[i]) / interval_width[i]\n            else:\n                # Interpolation within the training range\n                s_i = (z[i] - a[i]) / interval_width[i]\n                c[i] = 1.0 - 2.0 * np.abs(s_i - 0.5)\n\n        # Step 2: Compute MESS score M(z) and determine extrapolation E(z)\n        m_z = np.min(c)\n        e_z = 1 if m_z < 0 else 0\n\n        # Step 3: Perform predictor clamping\n        z_clamped = np.clip(z, a, b)\n        \n        # Step 4: Standardize original and clamped predictors\n        z_star = (z - mu) / sigma\n        z_clamped_star = (z_clamped - mu) / sigma\n\n        # Step 5: Calculate suitability scores S(z) and S(~z)\n        # Add intercept term for linear predictor calculation\n        z_star_with_intercept = np.insert(z_star, 0, 1)\n        z_clamped_star_with_intercept = np.insert(z_clamped_star, 0, 1)\n        \n        # We need to adjust the beta vector to use with the inserted '1'\n        # f(z) = beta0 + beta1*z1* + ...\n        # Let's compute manually to avoid confusion\n        f_z = beta[0] + np.dot(beta[1:], z_star)\n        f_z_clamped = beta[0] + np.dot(beta[1:], z_clamped_star)\n\n        # Logistic function S(x) = 1 / (1 + exp(-f(x)))\n        s_z = 1.0 / (1.0 + np.exp(-f_z))\n        s_z_clamped = 1.0 / (1.0 + np.exp(-f_z_clamped))\n\n        # Step 6: Quantify clamping-induced change\n        delta_s = s_z_clamped - s_z\n        \n        # Round results to 6 decimal places\n        result_tuple = [\n            round(m_z, 6),\n            e_z,\n            round(delta_s, 6)\n        ]\n        all_results.append(result_tuple)\n        \n    # Final print statement in the exact required format.\n    # The requirement `[[m1,e1,d1],[m2,e2,d2],...]` is the default string representation of a list of lists.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}