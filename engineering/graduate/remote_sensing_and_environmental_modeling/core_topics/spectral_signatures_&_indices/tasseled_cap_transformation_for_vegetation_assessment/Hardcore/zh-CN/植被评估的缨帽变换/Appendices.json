{
    "hands_on_practices": [
        {
            "introduction": "为了真正掌握缨帽变换，我们必须从其数学核心入手。本练习将剥离复杂的应用背景，引导您回归到基本的线性代数原理。您将通过一个具体案例，从第一性原理出发，推导并计算一个像素的光谱反射率向量在一个预设的“亮度”方向上的投影，从而将抽象的向量投影概念与遥感中具体的物理量（如亮度指数）直接联系起来。这项基础练习旨在巩固您对缨帽变换作为一种几何投影的理解。",
            "id": "3858323",
            "problem": "一台六波段光学成像光谱辐射计获取了某异构农业生态系统从可见光到短波红外波段、经过大气校正的地表方向反射率。设单个像元的光谱反射率由列向量 $\\mathbf{r} \\in \\mathbb{R}^{6}$ 表示，其波段顺序为蓝、绿、红、近红外、短波红外1和短波红外2：\n$$\n\\mathbf{r} = \\begin{pmatrix}\n0.066 \\\\\n0.089 \\\\\n0.215 \\\\\n0.402 \\\\\n0.356 \\\\\n0.112\n\\end{pmatrix}.\n$$\n一个仪器团队将缨帽变换（Tasseled Cap, TC）的亮度分量定义为这个六维波段空间中的一个固定方向，由向量 $\\mathbf{b} \\in \\mathbb{R}^{6}$ 表示：\n$$\n\\mathbf{b} = \\begin{pmatrix}\n0.3029 \\\\\n0.2786 \\\\\n0.4733 \\\\\n0.5599 \\\\\n0.5080 \\\\\n0.1872\n\\end{pmatrix}.\n$$\n假设在 $\\mathbb{R}^{6}$ 上使用标准欧几里得内积，并将 $\\mathbf{r}$ 在由 $\\mathbf{b}$ 张成的一维子空间上的投影解释为与场景亮度成正比的单变量指标。请仅从内积空间中欧几里得内积、向量范数和正交投影的定义出发，推导 $\\mathbf{r}$ 在由 $\\mathbf{b}$ 定义的轴上投影的有符号长度的表达式，并计算给定 $\\mathbf{r}$ 和 $\\mathbf{b}$ 的数值。最终答案以无单位小数表示，并四舍五入到五位有效数字。",
            "solution": "用户想要解决以下问题：\n一台六波段光学成像光谱辐射计获取了某异构农业生态系统从可见光到短波红外波段、经过大气校正的地表方向反射率。设单个像元的光谱反射率由列向量 $\\mathbf{r} \\in \\mathbb{R}^{6}$ 表示，其波段顺序为蓝、绿、红、近红外、短波红外1和短波红外2：\n$$\n\\mathbf{r} = \\begin{pmatrix}\n0.066 \\\\\n0.089 \\\\\n0.215 \\\\\n0.402 \\\\\n0.356 \\\\\n0.112\n\\end{pmatrix}.\n$$\n一个仪器团队将缨帽变换（Tasseled Cap, TC）的亮度分量定义为这个六维波段空间中的一个固定方向，由向量 $\\mathbf{b} \\in \\mathbb{R}^{6}$ 表示：\n$$\n\\mathbf{b} = \\begin{pmatrix}\n0.3029 \\\\\n0.2786 \\\\\n0.4733 \\\\\n0.5599 \\\\\n0.5080 \\\\\n0.1872\n\\end{pmatrix}.\n$$\n假设在 $\\mathbb{R}^{6}$ 上使用标准欧几里得内积，并将 $\\mathbf{r}$ 在由 $\\mathbf{b}$ 张成的一维子空间上的投影解释为与场景亮度成正比的单变量指标。请仅从内积空间中欧几里得内积、向量范数和正交投影的定义出发，推导 $\\mathbf{r}$ 在由 $\\mathbf{b}$ 定义的轴上投影的有符号长度的表达式，并计算给定 $\\mathbf{r}$ 和 $\\mathbf{b}$ 的数值。最终答案以无单位小数表示，并四舍五入到五位有效数字。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n-   反射率向量：$\\mathbf{r} = \\begin{pmatrix} 0.066 \\\\ 0.089 \\\\ 0.215 \\\\ 0.402 \\\\ 0.356 \\\\ 0.112 \\end{pmatrix} \\in \\mathbb{R}^{6}$\n-   缨帽变换亮度向量：$\\mathbf{b} = \\begin{pmatrix} 0.3029 \\\\ 0.2786 \\\\ 0.4733 \\\\ 0.5599 \\\\ 0.5080 \\\\ 0.1872 \\end{pmatrix} \\in \\mathbb{R}^{6}$\n-   数学框架：$\\mathbb{R}^{6}$ 上的标准欧几里得内积。\n-   任务：从第一性原理（内积、范数和正交投影的定义）出发，推导向量 $\\mathbf{r}$ 在由 $\\mathbf{b}$ 定义的轴上的投影的有符号长度的表达式。\n-   任务：计算给定 $\\mathbf{r}$ 和 $\\mathbf{b}$ 的数值。\n-   输出要求：一个无单位小数，四舍五入到五位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n\n1.  **科学依据**：该问题基于缨帽变换，这是遥感领域中分析多光谱数据的一种成熟的标准技术。反射率值对于有植被覆盖的地表是物理上现实的。亮度向量的系数与为Landsat等卫星传感器推导出的系数一致。其底层数学框架是线性代数。该问题在科学上和数学上都是合理的。\n2.  **适定性**：该问题要求计算一个向量在另一个向量上的标量投影，这是线性代数中唯一定义的量。所有必要的数据（两个向量）和数学背景（欧几里得内积空间）都已提供。\n3.  **客观性**：该问题使用精确、客观的数学和科学术语陈述。没有歧义或主观内容。\n4.  **完整性和一致性**：该问题是自洽的。向量的维度（6）是一致的。没有缺少必要信息，也没有相互矛盾的约束。\n5.  **现实性和可行性**：反射率和缨帽变换向量的数值是现实的。所需的计算是可行的。\n\n**步骤3：结论与行动**\n\n问题有效。它有科学依据，适定、客观且完整。我将继续进行推导和求解。\n\n### 解答\n\n目标是求出向量 $\\mathbf{r} \\in \\mathbb{R}^{6}$ 在由向量 $\\mathbf{b} \\in \\mathbb{R}^{6}$ 张成的一维子空间上的正交投影的有符号长度。这个量也称为 $\\mathbf{r}$ 在 $\\mathbf{b}$ 上的标量投影。我们将按要求从第一性原理推导该表达式。\n\n设内积空间为 $\\mathbb{R}^{6}$，其上赋有标准欧几里得内积，对任意两个向量 $\\mathbf{u} = (u_1, \\dots, u_6)^T$ 和 $\\mathbf{v} = (v_1, \\dots, v_6)^T$ 定义为：\n$$\n\\langle \\mathbf{u}, \\mathbf{v} \\rangle = \\mathbf{u}^T \\mathbf{v} = \\sum_{i=1}^{6} u_i v_i\n$$\n向量 $\\mathbf{u}$ 的范数通过内积定义为 $\\|\\mathbf{u}\\| = \\sqrt{\\langle \\mathbf{u}, \\mathbf{u} \\rangle}$。\n\n向量 $\\mathbf{r}$ 在由 $\\mathbf{b}$ 张成的子空间上的正交投影是一个向量，我们记为 $\\mathbf{p}$。因为 $\\mathbf{p}$ 位于由 $\\mathbf{b}$ 张成的子空间中，所以它必然是 $\\mathbf{b}$ 的标量倍：\n$$\n\\mathbf{p} = c \\mathbf{b}\n$$\n对于某个标量 $c$。\n\n正交投影的定义特征是误差向量 $\\mathbf{r} - \\mathbf{p}$ 与我们投影到的子空间正交。在本例中，这意味着 $\\mathbf{r} - \\mathbf{p}$ 必须与由 $\\mathbf{b}$ 张成的子空间中的每个向量都正交，这等价于与 $\\mathbf{b}$ 本身正交。正交条件用内积表示为：\n$$\n\\langle \\mathbf{r} - \\mathbf{p}, \\mathbf{b} \\rangle = 0\n$$\n将 $\\mathbf{p} = c \\mathbf{b}$ 代入正交条件，我们得到：\n$$\n\\langle \\mathbf{r} - c \\mathbf{b}, \\mathbf{b} \\rangle = 0\n$$\n利用内积对其第一个参数的线性性质：\n$$\n\\langle \\mathbf{r}, \\mathbf{b} \\rangle - \\langle c \\mathbf{b}, \\mathbf{b} \\rangle = 0\n$$\n利用性质 $\\langle k \\mathbf{u}, \\mathbf{v} \\rangle = k \\langle \\mathbf{u}, \\mathbf{v} \\rangle$：\n$$\n\\langle \\mathbf{r}, \\mathbf{b} \\rangle - c \\langle \\mathbf{b}, \\mathbf{b} \\rangle = 0\n$$\n求解标量 $c$：\n$$\nc = \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\langle \\mathbf{b}, \\mathbf{b} \\rangle}\n$$\n因此，投影向量为 $\\mathbf{p} = \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\langle \\mathbf{b}, \\mathbf{b} \\rangle} \\mathbf{b}$。\n\n投影的“有符号长度”是 $\\mathbf{r}$ 沿 $\\mathbf{b}$ 方向的标量分量。当投影向量 $\\mathbf{p}$ 表示为 $\\mathbf{b}$ 方向上的单位向量的倍数时，该标量分量就是其系数。令 $\\hat{\\mathbf{b}}$ 为 $\\mathbf{b}$ 方向上的单位向量：\n$$\n\\hat{\\mathbf{b}} = \\frac{\\mathbf{b}}{\\|\\mathbf{b}\\|}\n$$\n其中 $\\|\\mathbf{b}\\| = \\sqrt{\\langle \\mathbf{b}, \\mathbf{b} \\rangle}$。\n\n设 $L$ 为有符号长度。那么根据定义，$\\mathbf{p} = L \\hat{\\mathbf{b}}$。我们可以通过重写 $\\mathbf{p}$ 的表达式来求得 $L$：\n$$\n\\mathbf{p} = \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\langle \\mathbf{b}, \\mathbf{b} \\rangle} \\mathbf{b} = \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\|\\mathbf{b}\\|^2} \\mathbf{b} = \\left( \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\|\\mathbf{b}\\|} \\right) \\frac{\\mathbf{b}}{\\|\\mathbf{b}\\|} = \\left( \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\|\\mathbf{b}\\|} \\right) \\hat{\\mathbf{b}}\n$$\n通过与 $\\mathbf{p} = L \\hat{\\mathbf{b}}$ 进行比较，我们确定有符号长度 $L$ 为：\n$$\nL = \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\|\\mathbf{b}\\|} = \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\sqrt{\\langle \\mathbf{b}, \\mathbf{b} \\rangle}}\n$$\n这就是推导出的有符号长度的表达式。\n\n现在，我们计算给定向量的数值：\n$$\n\\mathbf{r} = \\begin{pmatrix} 0.066 \\\\ 0.089 \\\\ 0.215 \\\\ 0.402 \\\\ 0.356 \\\\ 0.112 \\end{pmatrix}, \\quad \\mathbf{b} = \\begin{pmatrix} 0.3029 \\\\ 0.2786 \\\\ 0.4733 \\\\ 0.5599 \\\\ 0.5080 \\\\ 0.1872 \\end{pmatrix}\n$$\n首先，我们计算内积 $\\langle \\mathbf{r}, \\mathbf{b} \\rangle$：\n$$\n\\langle \\mathbf{r}, \\mathbf{b} \\rangle = (0.066)(0.3029) + (0.089)(0.2786) + (0.215)(0.4733) + (0.402)(0.5599) + (0.356)(0.5080) + (0.112)(0.1872)\n$$\n$$\n\\langle \\mathbf{r}, \\mathbf{b} \\rangle = 0.0199914 + 0.0247954 + 0.1017595 + 0.2250798 + 0.1808480 + 0.0209664\n$$\n$$\n\\langle \\mathbf{r}, \\mathbf{b} \\rangle = 0.5734405\n$$\n接下来，我们计算 $\\mathbf{b}$ 的范数的平方，即 $\\langle \\mathbf{b}, \\mathbf{b} \\rangle$：\n$$\n\\langle \\mathbf{b}, \\mathbf{b} \\rangle = (0.3029)^2 + (0.2786)^2 + (0.4733)^2 + (0.5599)^2 + (0.5080)^2 + (0.1872)^2\n$$\n$$\n\\langle \\mathbf{b}, \\mathbf{b} \\rangle = 0.09174841 + 0.07761796 + 0.22401289 + 0.31348801 + 0.25806400 + 0.03504384\n$$\n$$\n\\langle \\mathbf{b}, \\mathbf{b} \\rangle = 0.99997511\n$$\n$\\mathbf{b}$ 的范数是该值的平方根：\n$$\n\\|\\mathbf{b}\\| = \\sqrt{0.99997511} \\approx 0.9999875549\n$$\n最后，我们计算有符号长度 $L$：\n$$\nL = \\frac{\\langle \\mathbf{r}, \\mathbf{b} \\rangle}{\\|\\mathbf{b}\\|} = \\frac{0.5734405}{0.9999875549} \\approx 0.573447668\n$$\n题目要求结果四舍五入到五位有效数字。前五位有效数字是 $5, 7, 3, 4, 4$。第六位数字是 $7$，因此我们将第五位数字向上取整。\n$$\nL \\approx 0.57345\n$$\n这就是给定像元的缨帽变换亮度指数的计算数值。",
            "answer": "$$\n\\boxed{0.57345}\n$$"
        },
        {
            "introduction": "本章的最终实践将理论与大规模应用融为一体，要求您从头开始构建一个完整的缨帽变换处理流程。这项综合性练习不仅要求您使用格拉姆-施密特过程从物理上合理的端元光谱中推导出变换矩阵，还挑战您为处理大型遥感影像编写高效的、考虑内存限制的代码。通过实施分块处理策略，您将体验到真实世界中遥感分析师和环境建模师在处理海量数据时所面临的计算挑战。这个顶点练习将您在前面练习中学到的所有概念——从数学原理到实际应用——整合到一个实际的编程任务中。",
            "id": "3858325",
            "problem": "给定一个多光谱图像，它是一个二维像素阵列，其中每个像素由一个固定数量光谱波段下的反射率向量表示。您的任务是形式化计算缨帽变换 (Tasseled Cap Transformation, TCT) 分量以进行植被评估所需的矩阵乘法，并为处理大型图像实现一种内存高效的分块策略。缨帽变换 (TCT) 是将每个像素的反射率向量线性投影到一个标准正交基上的过程，该基编码了亮度、绿度和湿度信息。该标准正交基将根据线性代数的基本原理，从物理上合理的光谱端元推导得出。\n\n从以下基础开始：\n- 反射率是一个位于区间 $[0,1]$ 内的无量纲辐射量，可以表示为一个向量 $x \\in \\mathbb{R}^b$，其中 $b$ 是光谱波段的数量。对于一个具有 $n_r$ 行和 $n_c$ 列的多光谱图像，该图像可以表示为一个数组 $X \\in \\mathbb{R}^{n_r \\times n_c \\times b}$。\n- 缨帽变换 (TCT) 可以推导为将 $x$ 投影到 $\\mathbb{R}^b$ 中的一个标准正交基 $\\{u_1,u_2,u_3\\}$ 上的过程，该基代表亮度、绿度和湿度。如果 $U \\in \\mathbb{R}^{b \\times 3}$ 的列为 $u_1,u_2,u_3$，则 TCT 分量 $y \\in \\mathbb{R}^3$ 可通过 $y = U^\\top x$（如果 $x$ 是列向量）计算，或者等效地，如果 $x$ 是行向量，则为 $y^\\top = x^\\top U$。\n\n您必须从以下在 $b=6$ 个波段（蓝、绿、红、近红外、短波红外1、短波红外2）中给出的物理上合理的光谱端元推导出标准正交基 $\\{u_1,u_2,u_3\\}$。令 $v,s,w \\in \\mathbb{R}^6$ 分别表示植被、土壤和水的反射光谱：\n- 植被 $v = [0.05, 0.06, 0.04, 0.50, 0.20, 0.10]$，\n- 土壤 $s = [0.20, 0.30, 0.35, 0.45, 0.40, 0.30]$，\n- 水 $w = [0.06, 0.04, 0.02, 0.01, 0.01, 0.00]$。\n\n构建矩阵 $V \\in \\mathbb{R}^{b \\times 3}$，其列为 $v$、$s$、$w$。使用 Gram-Schmidt 过程对 $V$ 的列进行处理，推导出标准正交基 $U \\in \\mathbb{R}^{b \\times 3}$：\n- 令 $e_1 = v$, $e_2 = s$, $e_3 = w$。\n- 计算\n$$\nu_1 = \\frac{e_1}{\\|e_1\\|_2}, \\quad\n\\tilde{e}_2 = e_2 - (u_1^\\top e_2) u_1, \\quad\nu_2 = \\frac{\\tilde{e}_2}{\\|\\tilde{e}_2\\|_2},\n$$\n$$\n\\tilde{e}_3 = e_3 - (u_1^\\top e_3) u_1 - (u_2^\\top e_3) u_2, \\quad\nu_3 = \\frac{\\tilde{e}_3}{\\|\\tilde{e}_3\\|_2}.\n$$\n组合成 $U = [u_1 \\; u_2 \\; u_3]$。\n\n对于每个像素反射率向量 $x \\in \\mathbb{R}^6$，通过投影计算 TCT 分量 $y \\in \\mathbb{R}^3$\n$$\ny = U^\\top x,\n$$\n对于排列在矩阵 $B \\in \\mathbb{R}^{m \\times b}$（每行为一个像素）中的一个像素块，计算\n$$\nY = B U \\in \\mathbb{R}^{m \\times 3},\n$$\n其中 $Y$ 的第 $i$ 行包含该块中第 $i$ 个像素的三个 TCT 分量。\n\n您必须为整个图像 $X \\in \\mathbb{R}^{n_r \\times n_c \\times b}$ 实现一种内存高效的分块策略，一次处理一个高度为 $h$（分块大小）的连续行块，以避免超出内存限制。在每一步中，提取一个分块 $T \\in \\mathbb{R}^{h \\times n_c \\times b}$（或最后一个分块的剩余部分），将其重塑为 $B \\in \\mathbb{R}^{h \\cdot n_c \\times b}$，计算 $Y = B U$，并将每个分块的结果累加到一个图像级摘要中。在进行任何计算之前，超出物理实际区间 $[0,1]$ 的反射率必须被裁剪到 $[0,1]$。本问题不涉及角度。\n\n您的程序必须：\n- 根据提供的 $v,s,w$ 通过 Gram-Schmidt 过程推导出 $U$。\n- 在提供的测试图像和分块大小上实现上述分块策略。\n- 对于每个测试用例，计算三个 TCT 分量（亮度、绿度、湿度）在整幅图像上的平均值，即图像所有像素的平均值，表示为十进制浮点数。\n\n测试套件。使用以下测试用例，这些用例共同评估投影和分块机制的正确性。在所有情况下，波段数 $b = 6$，且如上所述，需要裁剪到 $[0,1]$：\n- 用例1（一般情况）：$n_r = 8$, $n_c = 8$，分块高度 $h = 3$。按行定义像素反射率：对于行索引 $i$ 满足 $0 \\le i \\le 3$ 的行，设置 $x_{i,j} = \\alpha_1 v + (1-\\alpha_1) s$，其中 $\\alpha_1 = 0.7$; 对于行 $4 \\le i \\le 7$，设置 $x_{i,j} = \\alpha_2 v + (1-\\alpha_2) s$，其中 $\\alpha_2 = 0.4$。这会产生植被和土壤的分段混合。\n- 用例2（边界分块）：$n_r = 2$, $n_c = 3$，分块高度 $h = 1$。对所有像素，设置 $x_{i,j} = \\beta v + (1-\\beta) w$，其中 $\\beta = 0.5$。\n- 用例3（分块大小大于图像）：$n_r = 5$, $n_c = 5$，分块高度 $h = 100$。对所有像素，设置 $x_{i,j} = s$。\n- 用例4（不可整除的分块和交替的端元）：$n_r = 7$, $n_c = 4$，分块高度 $h = 3$。对每个像素，如果行索引 $i$ 是偶数（即 $i \\bmod 2 = 0$），设置 $x_{i,j} = v$；否则设置 $x_{i,j} = w$。\n- 用例5（裁剪的边界情况）：$n_r = 3$, $n_c = 3$，分块高度 $h = 2$。设置 $x_{i,j} = \\gamma w - \\delta s$，其中 $\\gamma = 1.2$ 和 $\\delta = 0.1$，然后将 $x_{i,j}$ 的每个分量裁剪到区间 $[0,1]$。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且必须是该用例的三个十进制浮点数列表（平均亮度、平均绿度、平均湿度）。例如，输出应如下所示：\n$[\\, [y_{1,1},y_{1,2},y_{1,3}], [y_{2,1},y_{2,2},y_{2,3}], \\dots \\,]$。",
            "solution": "这个问题是有效的，因为它科学上合理、定义明确且完整。它提出了一个标准的遥感任务——缨帽变换（TCT），该任务基于线性代数的基本原理，并为得到唯一的、可验证的解提供了所有必要的数据和约束。\n\n问题的核心是将像素反射率数据投影到一个新的、具有物理意义的基上，该基代表亮度、绿度和湿度。这是一个线性变换。解决方案包括两个主要阶段：首先，根据给定的光谱端元构建变换矩阵；其次，使用内存高效的分块策略将此变换应用于大型图像。\n\n**1. 标准正交基和变换矩阵的推导**\n\n缨帽变换是反射率向量 $x \\in \\mathbb{R}^b$ 的一次基变换，其中 $b=6$ 是光谱波段的数量。我们得到了三个具有物理意义但非正交的端元向量：植被 $v$、土壤 $s$ 和水 $w$。这些向量构成了矩阵 $V = [v \\, s \\, w] \\in \\mathbb{R}^{6 \\times 3}$ 的列。我们的目标是从这些向量中推导出一个标准正交基 $\\{u_1, u_2, u_3\\}$，它将构成变换矩阵 $U \\in \\mathbb{R}^{6 \\times 3}$ 的列。向量 $u_1$ 在概念上与亮度对齐，$u_2$ 与绿度对齐，$u_3$ 与湿度对齐。\n\n我们使用 Gram-Schmidt 过程来构建这个标准正交基。设初始向量为 $e_1 = v$、$e_2 = s$ 和 $e_3 = w$。\n\n第一个基向量 $u_1$ 是通过归一化 $e_1$ 得到的：\n$$\nu_1 = \\frac{e_1}{\\|e_1\\|_2}\n$$\n在这里，$u_1$ 代表了光谱变化的主要方向，即跨波段反射率的加权平均值，这对应于亮度。\n\n第二个基向量 $u_2$ 必须与 $u_1$ 正交。我们首先减去 $e_2$ 在 $u_1$ 方向上的分量，得到一个向量 $\\tilde{e}_2$。然后将该向量归一化。\n$$\n\\tilde{e}_2 = e_2 - (u_1^\\top e_2) u_1\n$$\n$$\nu_2 = \\frac{\\tilde{e}_2}{\\|\\tilde{e}_2\\|_2}\n$$\n这个向量 $u_2$ 是在移除亮度分量后由土壤向量 $s$ 构建的。它通常捕捉近红外波段与可见光波段之间的对比，这是植被健康（绿度）的关键指标。\n\n第三个基向量 $u_3$ 必须与 $u_1$ 和 $u_2$ 都正交。我们减去 $e_3$ 在由 $u_1$ 和 $u_2$ 张成的平面上的分量，得到 $\\tilde{e}_3$，然后将其归一化。\n$$\n\\tilde{e}_3 = e_3 - (u_1^\\top e_3) u_1 - (u_2^\\top e_3) u_2\n$$\n$$\nu_3 = \\frac{\\tilde{e}_3}{\\|\\tilde{e}_3\\|_2}\n$$\n这个向量 $u_3$ 是在移除亮度和绿度分量后由水向量 $w$ 推导出来的，它通常捕捉与湿度相关的信息（湿度）。\n\n得到的矩阵 $U = [u_1 \\, u_2 \\, u_3]$ 的列是这些标准正交基向量。\n\n**2. 变换和分块策略**\n\n对于具有反射率向量 $x \\in \\mathbb{R}^6$ 的单个像素，其 TCT 分量 $y \\in \\mathbb{R}^3$ 是通过将 $x$ 投影到新基上计算得到的。如果将 $x$ 视为行向量（$1 \\times b$），该变换是一个矩阵乘法：\n$$\ny^\\top = x U\n$$\n对于一个由 $m$ 个像素排列成的矩阵 $B \\in \\mathbb{R}^{m \\times b}$，其中每行是一个像素的反射率向量，该变换会同时应用于所有像素：\n$$\nY = B U\n$$\n结果矩阵 $Y \\in \\mathbb{R}^{m \\times 3}$ 包含了这 $m$ 个像素各自的亮度、绿度和湿度分量。\n\n一次性处理整个图像 $X \\in \\mathbb{R}^{n_r \\times n_c \\times b}$ 可能会需要过高的内存量。因此采用分块策略，将图像分成可管理的小块进行处理。图像按高度为 $h$ 的连续水平块（分块）进行处理。\n\n算法如下：\n1. 为 TCT 分量初始化一个总和向量，`total_tct_sum = [0, 0, 0]`。\n2. 以步长 $h$ 遍历图像的行。对于从行索引 $i$ 开始的每一步：\n    a. 提取一个大小为 $h' \\times n_c \\times b$ 的分块 $T$，其中对于完整的分块 $h' = h$，对于最后一个不完整的分块 $h'  h$。这对应于切片 $X[i : i+h, :, :]$。\n    b. 将分块中所有的反射率值裁剪到物理有效的范围 $[0, 1]$ 内。\n    c. 将 3D 分块 $T \\in \\mathbb{R}^{h' \\times n_c \\times b}$ 重塑为一个 2D 像素向量矩阵 $B \\in \\mathbb{R}^{(h' \\cdot n_c) \\times b}$。\n    d. 计算该块的 TCT 分量：$Y = B U$。\n    e. 对当前分块的分量沿像素轴（`axis=0`）求和，并将此和加到 `total_tct_sum` 中。\n3. 遍历完所有分块后，像素总数为 $N = n_r \\cdot n_c$。通过将最终累积的总和除以 $N$ 来计算每个 TCT 分量的全图平均值：\n$$\n\\text{mean\\_TCT} = \\frac{\\text{total\\_tct\\_sum}}{N}\n$$\n该方法确保了内存占用由单个分块的大小决定，而不是整个图像的大小，同时能产出正确的全图平均统计数据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives the TCT matrix, processes test images using a tiling strategy,\n    and computes the mean TCT components for each image.\n    \"\"\"\n    \n    # 1. Define Endmember Vectors\n    # v: vegetation, s: soil, w: water in 6 bands\n    v = np.array([0.05, 0.06, 0.04, 0.50, 0.20, 0.10])\n    s = np.array([0.20, 0.30, 0.35, 0.45, 0.40, 0.30])\n    w = np.array([0.06, 0.04, 0.02, 0.01, 0.01, 0.00])\n\n    # 2. Derive Orthonormal Basis U via Gram-Schmidt\n    e1 = v\n    e2 = s\n    e3 = w\n\n    u1 = e1 / np.linalg.norm(e1)\n\n    e2_tilde = e2 - np.dot(u1, e2) * u1\n    u2 = e2_tilde / np.linalg.norm(e2_tilde)\n\n    e3_tilde = e3 - np.dot(u1, e3) * u1 - np.dot(u2, e3) * u2\n    u3 = e3_tilde / np.linalg.norm(e3_tilde)\n    \n    # U has orthonormal vectors as columns\n    U = np.stack([u1, u2, u3], axis=1)\n\n    def process_image(X, h):\n        \"\"\"\n        Applies TCT to an image X using a tiling strategy with tile height h.\n        Returns the mean TCT components [brightness, greenness, wetness].\n        \"\"\"\n        n_r, n_c, _ = X.shape\n        total_pixels = n_r * n_c\n        \n        # Accumulator for the SUM of TCT components over the whole image\n        total_tct_sum = np.zeros(3)\n\n        # Iterate through the image in row-wise tiles\n        for i in range(0, n_r, h):\n            # Extract tile, handling the last partial tile\n            tile = X[i:i+h, :, :]\n            th, tc, tb = tile.shape\n\n            # Clip reflectances to the valid [0, 1] range\n            clipped_tile = np.clip(tile, 0, 1)\n            \n            # Reshape tile from 3D to 2D block of pixels\n            B = clipped_tile.reshape(th * tc, tb)\n            \n            # Apply Tasseled Cap Transformation\n            Y = B @ U  # Resulting shape: (th * tc, 3)\n\n            # Sum TCT components for the current tile and accumulate\n            tile_tct_sum = np.sum(Y, axis=0)\n            total_tct_sum += tile_tct_sum\n        \n        # Calculate mean TCT components for the entire image\n        mean_tct = total_tct_sum / total_pixels\n        return mean_tct.tolist()\n\n    # Define test cases\n    test_params = [\n        {'nr': 8, 'nc': 8, 'h': 3, 'type': 'case1'},\n        {'nr': 2, 'nc': 3, 'h': 1, 'type': 'case2'},\n        {'nr': 5, 'nc': 5, 'h': 100, 'type': 'case3'},\n        {'nr': 7, 'nc': 4, 'h': 3, 'type': 'case4'},\n        {'nr': 3, 'nc': 3, 'h': 2, 'type': 'case5'},\n    ]\n\n    results = []\n    for params in test_params:\n        nr, nc, h = params['nr'], params['nc'], params['h']\n        \n        if params['type'] == 'case1':\n            alpha1 = 0.7\n            alpha2 = 0.4\n            row_type1 = alpha1 * v + (1 - alpha1) * s\n            row_type2 = alpha2 * v + (1 - alpha2) * s\n            X = np.zeros((nr, nc, v.shape[0]))\n            X[0:4, :, :] = row_type1\n            X[4:8, :, :] = row_type2\n        \n        elif params['type'] == 'case2':\n            beta = 0.5\n            pixel_val = beta * v + (1 - beta) * w\n            X = np.full((nr, nc, v.shape[0]), pixel_val)\n\n        elif params['type'] == 'case3':\n            X = np.full((nr, nc, v.shape[0]), s)\n\n        elif params['type'] == 'case4':\n            X = np.zeros((nr, nc, v.shape[0]))\n            X[0::2, :, :] = v  # Even rows\n            X[1::2, :, :] = w  # Odd rows\n        \n        elif params['type'] == 'case5':\n            gamma = 1.2\n            delta = 0.1\n            pixel_val = gamma * w - delta * s\n            X = np.full((nr, nc, v.shape[0]), pixel_val)\n\n        # Process the generated image and store the result\n        result = process_image(X, h)\n        results.append(result)\n        \n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}