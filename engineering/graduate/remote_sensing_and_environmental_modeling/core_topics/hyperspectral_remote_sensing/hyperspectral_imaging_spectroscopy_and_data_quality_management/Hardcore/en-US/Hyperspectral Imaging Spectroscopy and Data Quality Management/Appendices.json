{
    "hands_on_practices": [
        {
            "introduction": "To derive quantitative information from hyperspectral data, we must first have confidence in the instrument itself. This practice delves into the foundational process of radiometric calibration, a critical step in data quality management. By analyzing simulated laboratory measurements from an integrating sphere, you will characterize a sensor's response, estimate its gain, and critically assess its linearity—skills that are essential for ensuring the accuracy and reliability of any subsequent scientific analysis. ",
            "id": "3820376",
            "problem": "A hyperspectral imaging spectrometer is calibrated in the laboratory using an integrating sphere that provides spectrally varying but spatially uniform radiance. The instrument records Digital Number (DN) values per spectral band under controlled radiance levels. Let $L_{\\lambda}$ denote spectral radiance at wavelength $\\lambda$ in units of $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$. The instrument response per band is modeled as a polynomial in radiance,\n$$\nDN(\\lambda, L_{\\lambda}) = a(\\lambda) + b(\\lambda)\\,L_{\\lambda} + c(\\lambda)\\,L_{\\lambda}^{2} + \\epsilon,\n$$\nwhere $a(\\lambda)$ is the dark offset, $b(\\lambda)$ is the first-order gain, $c(\\lambda)$ is a quadratic nonlinearity coefficient, and $\\epsilon$ represents measurement noise. The unknown gain to be reported is $g(\\lambda) \\equiv b(\\lambda)$, in units of $\\mathrm{DN}\\,\\big/\\,\\left(\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}\\right)$. Laboratory data provide, for each band, two integrating sphere radiance levels $L_{\\lambda,1}$ and $L_{\\lambda,2}$ and the corresponding DN histograms for three acquisition conditions: dark (closed shutter, which implies $L_{\\lambda}=0$), low radiance at $L_{\\lambda,1}$, and high radiance at $L_{\\lambda,2}$. Each histogram is given as pairs of bin centers and counts. Assume measurement noise is independent across frames, and that the dark acquisition contributes a shared uncertainty to both radiance-level means when forming differences.\n\nStarting from fundamental radiometric calibration principles and statistical estimation, derive an algorithm that:\n- Computes the sample mean $\\bar{DN}$ and unbiased sample variance $s^{2}$ from each DN histogram,\n- Estimates $a(\\lambda)$ as the dark mean,\n- Solves for $b(\\lambda)$ and $c(\\lambda)$ by treating\n$$\n\\begin{bmatrix}\n\\bar{DN}_{1} - a(\\lambda) \\\\\n\\bar{DN}_{2} - a(\\lambda)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nL_{\\lambda,1} & L_{\\lambda,1}^{2} \\\\\nL_{\\lambda,2} & L_{\\lambda,2}^{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nb(\\lambda) \\\\\nc(\\lambda)\n\\end{bmatrix},\n$$\n- Propagates uncertainty to obtain the covariance of $\\begin{bmatrix} b(\\lambda) \\\\ c(\\lambda) \\end{bmatrix}$, using the covariance of $\\begin{bmatrix} \\bar{DN}_{1}-a(\\lambda) \\\\ \\bar{DN}_{2}-a(\\lambda) \\end{bmatrix}$ with entries\n$$\n\\mathrm{Var}\\left(\\bar{DN}_{i}-a(\\lambda)\\right)=\\frac{s_{i}^{2}}{N_{i}}+\\frac{s_{a}^{2}}{N_{a}}, \\quad\n\\mathrm{Cov}\\left(\\bar{DN}_{1}-a(\\lambda),\\bar{DN}_{2}-a(\\lambda)\\right)=\\frac{s_{a}^{2}}{N_{a}},\n$$\nwhere $N_{i}$ is the total count in histogram $i$ and $s_{i}^{2}$ is the unbiased sample variance computed from histogram $i$ for $i\\in\\{1,2,a\\}$,\n- Assesses nonlinearity by computing a $z$-score for $c(\\lambda)$, defined as $z = \\left|c(\\lambda)\\right|/\\sigma_{c}$, where $\\sigma_{c}$ is the standard deviation obtained from the covariance matrix of $\\begin{bmatrix} b(\\lambda) \\\\ c(\\lambda) \\end{bmatrix}$,\n- Decides whether a linear or quadratic calibration is warranted per band by the rule: use quadratic if $z \\geq 2$; otherwise use linear.\n\nAll angles, if any, must be in radians. Radiance must be treated in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$. Report $g(\\lambda)=b(\\lambda)$ in $\\mathrm{DN}\\,\\big/\\,\\left(\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}\\right)$, and $c(\\lambda)$ in $\\mathrm{DN}\\,\\big/\\,\\left(\\mathrm{W^{2}\\,m^{-4}\\,sr^{-2}\\,\\mu m^{-2}}\\right)$. Round all floating-point outputs to six decimal places.\n\nYour program must implement this algorithm and apply it to the following test suite of four spectral bands. For each band $k$, the data include wavelength $\\lambda_{k}$ (in $\\mathrm{nm}$), radiance levels $L_{\\lambda,k,1}$ and $L_{\\lambda,k,2}$ (in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$), and three DN histograms given by bin centers and counts for dark, low radiance, and high radiance respectively. Each histogram uses three bin centers equal to $[\\mu-1,\\mu,\\mu+1]$ with counts that sum to the number of frames $N$.\n\nBand $1$:\n- $\\lambda_{1} = 550\\,\\mathrm{nm}$, $L_{\\lambda,1,1} = 10$, $L_{\\lambda,1,2} = 50$,\n- Dark histogram: centers $[99,100,101]$, counts $[125,250,125]$,\n- Low radiance histogram: centers $[199,200,201]$, counts $[125,250,125]$,\n- High radiance histogram: centers $[599,600,601]$, counts $[125,250,125]$.\n\nBand $2$:\n- $\\lambda_{2} = 850\\,\\mathrm{nm}$, $L_{\\lambda,2,1} = 10$, $L_{\\lambda,2,2} = 50$,\n- Dark histogram: centers $[99,100,101]$, counts $[125,250,125]$,\n- Low radiance histogram: centers $[201,202,203]$, counts $[125,250,125]$,\n- High radiance histogram: centers $[649,650,651]$, counts $[125,250,125]$.\n\nBand $3$:\n- $\\lambda_{3} = 1600\\,\\mathrm{nm}$, $L_{\\lambda,3,1} = 10$, $L_{\\lambda,3,2} = 50$,\n- Dark histogram: centers $[199,200,201]$, counts $[125,250,125]$,\n- Low radiance histogram: centers $[277.5,278.5,279.5]$, counts $[125,250,125]$,\n- High radiance histogram: centers $[561.5,562.5,563.5]$, counts $[125,250,125]$.\n\nBand $4$:\n- $\\lambda_{4} = 700\\,\\mathrm{nm}$, $L_{\\lambda,4,1} = 30$, $L_{\\lambda,4,2} = 35$,\n- Dark histogram: centers $[149,150,151]$, counts $[12,26,12]$,\n- Low radiance histogram: centers $[419.9,420.9,421.9]$, counts $[12,26,12]$,\n- High radiance histogram: centers $[465.225,466.225,467.225]$, counts $[12,26,12]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each band’s result is a list of the form $[g(\\lambda),c(\\lambda),\\text{decision}]$ with $g(\\lambda)$ and $c(\\lambda)$ rounded to six decimals and decision a boolean. For example, the final output format must be\n$$\n\\big[[g_{1},c_{1},d_{1}],[g_{2},c_{2},d_{2}],[g_{3},c_{3},d_{3}],[g_{4},c_{4},d_{4}]\\big],\n$$\nwith no spaces anywhere in the printed line.",
            "solution": "The problem is evaluated for validity.\n\n### Step 1: Extract Givens\n- **Instrument Response Model**: The Digital Number ($DN$) is a function of spectral radiance $L_{\\lambda}$:\n$$DN(\\lambda, L_{\\lambda}) = a(\\lambda) + b(\\lambda)\\,L_{\\lambda} + c(\\lambda)\\,L_{\\lambda}^{2} + \\epsilon$$\nwhere $a(\\lambda)$ is the dark offset, $b(\\lambda)$ is the first-order gain, $c(\\lambda)$ is the quadratic nonlinearity coefficient, and $\\epsilon$ is measurement noise.\n- **Quantity to Report**: The gain $g(\\lambda) \\equiv b(\\lambda)$.\n- **Calibration Data**: For each spectral band, the following are provided:\n    1.  Two known radiance levels: $L_{\\lambda,1}$ and $L_{\\lambda,2}$.\n    2.  Three $DN$ histograms for acquisitions at:\n        -   Dark (shutter closed, $L_{\\lambda}=0$).\n        -   Low radiance ($L_{\\lambda,1}$).\n        -   High radiance ($L_{\\lambda,2}$).\n    3.  Each histogram is defined by pairs of (bin center, count).\n- **Algorithm Steps**:\n    1.  Compute sample mean $\\bar{DN}$ and unbiased sample variance $s^{2}$ from each histogram.\n    2.  Estimate $a(\\lambda)$ as the mean of the dark histogram, $\\bar{DN}_a$.\n    3.  Solve the linear system for the coefficient vector $\\begin{bmatrix} b(\\lambda) \\\\ c(\\lambda) \\end{bmatrix}$:\n        $$\n        \\begin{bmatrix}\n        \\bar{DN}_{1} - a(\\lambda) \\\\\n        \\bar{DN}_{2} - a(\\lambda)\n        \\end{bmatrix}\n        =\n        \\begin{bmatrix}\n        L_{\\lambda,1} & L_{\\lambda,1}^{2} \\\\\n        L_{\\lambda,2} & L_{\\lambda,2}^{2}\n        \\end{bmatrix}\n        \\begin{bmatrix}\n        b(\\lambda) \\\\\n        c(\\lambda)\n        \\end{bmatrix}\n        $$\n    4.  Propagate uncertainty to find the covariance matrix of $\\begin{bmatrix} b(\\lambda) \\\\ c(\\lambda) \\end{bmatrix}$. The covariance matrix for the dark-subtracted mean $DN$s is given by:\n        $$\n        \\mathrm{Var}\\left(\\bar{DN}_{i}-a(\\lambda)\\right)=\\frac{s_{i}^{2}}{N_{i}}+\\frac{s_{a}^{2}}{N_{a}}, \\quad \\text{for } i \\in \\{1,2\\}\n        $$\n        $$\n        \\mathrm{Cov}\\left(\\bar{DN}_{1}-a(\\lambda),\\bar{DN}_{2}-a(\\lambda)\\right)=\\frac{s_{a}^{2}}{N_{a}}\n        $$\n        where $N_i$ is the total count and $s_i^2$ is the unbiased sample variance for histogram $i \\in \\{1, 2, a\\}$.\n    5.  Assess nonlinearity by computing a $z$-score for $c(\\lambda)$: $z = |c(\\lambda)|/\\sigma_{c}$, where $\\sigma_{c}$ is the standard deviation of $c(\\lambda)$.\n    6.  Decision Rule: If $z \\geq 2$, a quadratic model is warranted. Otherwise, a linear model is sufficient. This is reported as a boolean value.\n- **Reporting Format**: Report $g(\\lambda)$ and $c(\\lambda)$ rounded to six decimal places. The final output must be a single line: `[[g1,c1,d1],[g2,c2,d2],[g3,c3,d3],[g4,c4,d4]]`.\n- **Test Data**: Four bands with specified $\\lambda_k$, $L_{\\lambda,k,1}$, $L_{\\lambda,k,2}$, and three histograms each.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is grounded in the principles of radiometric calibration for optical sensors. Polynomial models for sensor response, statistical estimation from repeated measurements (histograms), and linear error propagation are standard and accepted methods in experimental physics and remote sensing.\n2.  **Well-Posed**: The problem is well-posed. It provides all necessary data and a complete, step-by-step algorithm. The central linear system for $b(\\lambda)$ and $c(\\lambda)$ is solvable if the matrix $\\mathbf{X} = \\begin{bmatrix} L_{\\lambda,1} & L_{\\lambda,1}^2 \\\\ L_{\\lambda,2} & L_{\\lambda,2}^2 \\end{bmatrix}$ is invertible. Its determinant is $\\det(\\mathbf{X}) = L_{\\lambda,1}L_{\\lambda,2}(L_{\\lambda,2} - L_{\\lambda,1})$. For all test cases, $L_{\\lambda,1}$ and $L_{\\lambda,2}$ are positive and distinct, ensuring $\\det(\\mathbf{X}) \\neq 0$. This guarantees a unique solution for the calibration coefficients.\n3.  **Objective**: The problem is stated in precise, objective, and scientific terms. The criteria for analysis (e.g., the $z$-score threshold) are explicitly defined, leaving no room for subjective interpretation.\n4.  **Flaw Checklist**: The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, realistic, well-posed, non-trivial, and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Solution Derivation\n\nThe objective is to determine a sensor's radiometric calibration coefficients, $b(\\lambda)$ and $c(\\lambda)$, from laboratory measurements and assess the nonlinearity of the response. The solution follows the prescribed algorithm.\n\n**1. Statistical Characterization of Measurements**\nFor each acquisition condition (dark, low radiance, high radiance), we are given a histogram of $DN$ values, consisting of bin centers $\\{d_j\\}$ and corresponding counts $\\{n_j\\}$.\nThe total number of measurements (frames) is $N = \\sum_j n_j$.\nFrom these, we compute the sample mean $\\bar{DN}$ and the unbiased sample variance $s^2$.\nThe sample mean is the first moment of the distribution:\n$$\\bar{DN} = \\frac{1}{N} \\sum_j n_j d_j$$\nThe unbiased sample variance, which accounts for the estimation of the mean from the data, is:\n$$s^2 = \\frac{1}{N-1} \\sum_j n_j (d_j - \\bar{DN})^2$$\nThese calculations are performed for the dark ($i=a$), low radiance ($i=1$), and high radiance ($i=2$) acquisitions, yielding $(\\bar{DN}_a, s_a^2, N_a)$, $(\\bar{DN}_1, s_1^2, N_1)$, and $(\\bar{DN}_2, s_2^2, N_2)$.\n\n**2. Estimation of Calibration Coefficients**\nThe instrument response model, when averaged over many frames, relates the mean $DN$ to the radiance:\n$$\\bar{DN}_i \\approx a(\\lambda) + b(\\lambda)L_{\\lambda,i} + c(\\lambda)L_{\\lambda,i}^2$$\nThe dark offset $a(\\lambda)$ is directly estimated from the mean of the dark acquisition, where $L_{\\lambda} = 0$:\n$$a(\\lambda) = \\bar{DN}_a$$\nSubtracting the dark offset from the radiance measurements yields the dark-subtracted signals, $y_i = \\bar{DN}_i - a(\\lambda)$:\n$$y_1 = b(\\lambda)L_{\\lambda,1} + c(\\lambda)L_{\\lambda,1}^2$$\n$$y_2 = b(\\lambda)L_{\\lambda,2} + c(\\lambda)L_{\\lambda,2}^2$$\nThis forms a system of two linear equations for the two unknown coefficients, $b(\\lambda)$ and $c(\\lambda)$. In matrix form, $\\mathbf{y} = \\mathbf{X}\\mathbf{p}$:\n$$\n\\underbrace{\n\\begin{bmatrix}\ny_1 \\\\\ny_2\n\\end{bmatrix}\n}_{\\mathbf{y}}\n=\n\\underbrace{\n\\begin{bmatrix}\nL_{\\lambda,1} & L_{\\lambda,1}^{2} \\\\\nL_{\\lambda,2} & L_{\\lambda,2}^{2}\n\\end{bmatrix}\n}_{\\mathbf{X}}\n\\underbrace{\n\\begin{bmatrix}\nb(\\lambda) \\\\\nc(\\lambda)\n\\end{bmatrix}\n}_{\\mathbf{p}}\n$$\nThe solution for the parameter vector $\\mathbf{p}$ is obtained by matrix inversion:\n$$\\mathbf{p} = \\mathbf{X}^{-1}\\mathbf{y}$$\nThe required gain is $g(\\lambda) \\equiv b(\\lambda)$, the first element of $\\mathbf{p}$.\n\n**3. Propagation of Uncertainty**\nThe estimates for $b(\\lambda)$ and $c(\\lambda)$ have uncertainties that depend on the noise in the mean $DN$ measurements. We use the law of propagation of uncertainty for a linear transformation. The covariance matrix of the estimated parameters, $\\mathbf{C_p}$, is related to the covariance matrix of the input measurements, $\\mathbf{C_y}$, by:\n$$\\mathbf{C_p} = (\\mathbf{X}^{-1}) \\mathbf{C_y} (\\mathbf{X}^{-1})^T$$\nwhere $\\mathbf{X}^{-1}$ is the Jacobian of the transformation $\\mathbf{p} = \\mathbf{X}^{-1}\\mathbf{y}$ and the radiance values in $\\mathbf{X}$ are assumed to be known constants.\n\nThe covariance matrix $\\mathbf{C_y}$ of the dark-subtracted signals, $\\mathbf{y} = \\begin{bmatrix} \\bar{DN}_1 - \\bar{DN}_a \\\\ \\bar{DN}_2 - \\bar{DN}_a \\end{bmatrix}$, is constructed based on the provided variance and covariance formulas. The variance of a sample mean $\\bar{DN}_i$ is $\\mathrm{Var}(\\bar{DN}_i) = s_i^2/N_i$. Since the dark measurement $\\bar{DN}_a$ is subtracted from both $\\bar{DN}_1$ and $\\bar{DN}_2$, its uncertainty contributes to the variance of both differences and introduces a covariance between them.\nThe components of $\\mathbf{C_y}$ are:\n$$(\\mathbf{C_y})_{11} = \\mathrm{Var}(\\bar{DN}_1 - \\bar{DN}_a) = \\mathrm{Var}(\\bar{DN}_1) + \\mathrm{Var}(\\bar{DN}_a) = \\frac{s_1^2}{N_1} + \\frac{s_a^2}{N_a}$$\n$$(\\mathbf{C_y})_{22} = \\mathrm{Var}(\\bar{DN}_2 - \\bar{DN}_a) = \\mathrm{Var}(\\bar{DN}_2) + \\mathrm{Var}(\\bar{DN}_a) = \\frac{s_2^2}{N_2} + \\frac{s_a^2}{N_a}$$\n$$(\\mathbf{C_y})_{12} = (\\mathbf{C_y})_{21} = \\mathrm{Cov}(\\bar{DN}_1 - \\bar{DN}_a, \\bar{DN}_2 - \\bar{DN}_a) = \\mathrm{Var}(\\bar{DN}_a) = \\frac{s_a^2}{N_a}$$\nThe covariance arises because the same random variable, $-\\bar{DN}_a$, is part of both terms.\n\n**4. Nonlinearity Assessment**\nAfter computing $\\mathbf{C_p}$, the variances of the estimated parameters are found on its diagonal: $\\sigma_b^2 = (\\mathbf{C_p})_{11}$ and $\\sigma_c^2 = (\\mathbf{C_p})_{22}$.\nThe statistical significance of the nonlinearity coefficient $c(\\lambda)$ is assessed by a $z$-score, which measures how many standard deviations the estimate is from zero:\n$$z = \\frac{|c(\\lambda)|}{\\sigma_c} = \\frac{|c(\\lambda)|}{\\sqrt{(\\mathbf{C_p})_{22}}}$$\nA large $z$-score indicates that the coefficient $c(\\lambda)$ is statistically significant and not just a result of measurement noise. The problem specifies a threshold of $z=2$, which corresponds to approximately a $95\\%$ confidence level for a two-tailed test, to decide if the quadratic term is necessary. The decision is `True` for a quadratic model if $z \\geq 2$, and `False` otherwise.\n\nThis completes the derivation of the algorithm to be implemented.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full radiometric calibration algorithm for a set of test bands.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"band\": 1,\n            \"lambda_nm\": 550,\n            \"L1\": 10.0,\n            \"L2\": 50.0,\n            \"hist_dark\": (np.array([99, 100, 101]), np.array([125, 250, 125])),\n            \"hist_low\": (np.array([199, 200, 201]), np.array([125, 250, 125])),\n            \"hist_high\": (np.array([599, 600, 601]), np.array([125, 250, 125])),\n        },\n        {\n            \"band\": 2,\n            \"lambda_nm\": 850,\n            \"L1\": 10.0,\n            \"L2\": 50.0,\n            \"hist_dark\": (np.array([99, 100, 101]), np.array([125, 250, 125])),\n            \"hist_low\": (np.array([201, 202, 203]), np.array([125, 250, 125])),\n            \"hist_high\": (np.array([649, 650, 651]), np.array([125, 250, 125])),\n        },\n        {\n            \"band\": 3,\n            \"lambda_nm\": 1600,\n            \"L1\": 10.0,\n            \"L2\": 50.0,\n            \"hist_dark\": (np.array([199, 200, 201]), np.array([125, 250, 125])),\n            \"hist_low\": (np.array([277.5, 278.5, 279.5]), np.array([125, 250, 125])),\n            \"hist_high\": (np.array([561.5, 562.5, 563.5]), np.array([125, 250, 125])),\n        },\n        {\n            \"band\": 4,\n            \"lambda_nm\": 700,\n            \"L1\": 30.0,\n            \"L2\": 35.0,\n            \"hist_dark\": (np.array([149, 150, 151]), np.array([12, 26, 12])),\n            \"hist_low\": (np.array([419.9, 420.9, 421.9]), np.array([12, 26, 12])),\n            \"hist_high\": (np.array([465.225, 466.225, 467.225]), np.array([12, 26, 12])),\n        },\n    ]\n\n    def compute_stats(centers, counts):\n        \"\"\"\n        Computes sample mean and unbiased sample variance from a histogram.\n        \n        Args:\n            centers (np.ndarray): Array of histogram bin centers.\n            counts (np.ndarray): Array of histogram bin counts.\n            \n        Returns:\n            tuple: (total_count, mean, unbiased_variance)\n        \"\"\"\n        N = np.sum(counts)\n        if N <= 1:\n            return N, np.nan, np.nan\n        \n        mean = np.sum(centers * counts) / N\n        # Unbiased sample variance: sum(n_k * (d_k - mean)^2) / (N - 1)\n        variance = np.sum(counts * (centers - mean)**2) / (N - 1)\n        return N, mean, variance\n\n    results_list = []\n    \n    for case in test_cases:\n        # Step 1: Compute statistics from histograms\n        Na, DN_a, s2_a = compute_stats(*case[\"hist_dark\"])\n        N1, DN_1, s2_1 = compute_stats(*case[\"hist_low\"])\n        N2, DN_2, s2_2 = compute_stats(*case[\"hist_high\"])\n\n        # Step 2: Estimate dark offset and set up the linear system\n        a = DN_a\n        L1, L2 = case[\"L1\"], case[\"L2\"]\n\n        # Vector of dark-subtracted mean DNs\n        y = np.array([\n            [DN_1 - a],\n            [DN_2 - a]\n        ])\n\n        # Radiance matrix (design matrix)\n        X = np.array([\n            [L1, L1**2],\n            [L2, L2**2]\n        ])\n\n        # Step 3: Solve for coefficients b and c\n        X_inv = np.linalg.inv(X)\n        p = X_inv @ y\n        b = p[0, 0]\n        c = p[1, 0]\n        g = b # The gain g(lambda) is defined as b(lambda)\n\n        # Step 4: Propagate uncertainty\n        # Covariance matrix of the dark-subtracted means\n        var_DN_a = s2_a / Na\n        C_y = np.array([\n            [s2_1/N1 + var_DN_a, var_DN_a],\n            [var_DN_a, s2_2/N2 + var_DN_a]\n        ])\n        \n        # Propagate to find covariance matrix of parameters [b, c]\n        C_p = X_inv @ C_y @ X_inv.T\n        \n        # Extract variance of c\n        var_c = C_p[1, 1]\n        std_c = np.sqrt(var_c) if var_c >= 0 else 0\n\n        # Step 5: Assess nonlinearity with z-score\n        if std_c > 0:\n            z_score = np.abs(c) / std_c\n        else:\n            # If standard deviation is zero, c is either exactly zero (z=0) or not (z=inf)\n            z_score = 0.0 if np.isclose(c, 0.0) else np.inf\n        \n        # Step 6: Decide if quadratic model is warranted\n        is_quadratic_warranted = z_score >= 2.0\n        \n        # Format the result for this band\n        # Final output requires 6 decimal places and lowercase boolean\n        g_str = f\"{g:.6f}\"\n        c_str = f\"{c:.6f}\"\n        dec_str = str(is_quadratic_warranted).lower()\n        results_list.append(f\"[{g_str},{c_str},{dec_str}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key aspect of data quality management is the ability to predict instrument performance before a single image is acquired. This exercise guides you through the construction of a physically-based forward model, starting from the fundamental principles of radiometry and sensor physics. You will simulate the entire signal chain—from solar illumination to detected electrons—to calculate essential performance metrics like the Signal-to-Noise Ratio ($SNR$) and Noise Equivalent Delta Reflectance ($NE\\Delta R$), providing a robust framework for mission planning and data quality assessment. ",
            "id": "3820399",
            "problem": "You are given a physically realistic forward model for a hyperspectral imaging spectrometer observing a spatially uniform bright desert target. The task is to compute per-band Signal-to-Noise Ratio (SNR), estimate the Noise Equivalent Delta Reflectance (NEΔR) for each band, and evaluate whether the data meet a target $SNR>300$ in the Visible and Near-Infrared (VNIR; $400$ to $1000$ $\\mathrm{nm}$). The derivation and computation must start from fundamental definitions and laws. Use the Lambertian reflectance model and photon counting statistics.\n\nAssumptions and fundamental bases to use:\n- The target is Lambertian with reflectance $\\,\\rho(\\lambda)\\,$, where $\\,\\lambda\\,$ is the wavelength in $\\mathrm{nm}$. For a horizontal surface, the upwelling spectral radiance $\\,L(\\lambda)\\,$ is related to the downwelling spectral irradiance $\\,E_d(\\lambda)\\,$ by\n$$\nL(\\lambda) = \\frac{\\rho(\\lambda)\\,E_d(\\lambda)}{\\pi}.\n$$\n- The downwelling irradiance at the surface is modeled as\n$$\nE_d(\\lambda) = E_0(\\lambda)\\,\\tau_{\\mathrm{atm}}(\\lambda)\\,\\cos(\\theta_s),\n$$\nwhere $\\,E_0(\\lambda)\\,$ is the extraterrestrial solar spectral irradiance, $\\,\\tau_{\\mathrm{atm}}(\\lambda)\\,$ is the atmospheric transmittance, and $\\,\\theta_s\\,$ is the Solar Zenith Angle (SZA). All angles must be treated in degrees in inputs and converted to radians internally as needed for trigonometric functions.\n- Photon energy is given by Planck’s relation\n$$\n\\varepsilon(\\lambda) = \\frac{h\\,c}{\\lambda_m},\n$$\nwhere $\\,h\\,$ is Planck’s constant, $\\,c\\,$ is the speed of light, and $\\,\\lambda_m\\,$ is the wavelength in meters (i.e., $\\,\\lambda_m = \\lambda\\times 10^{-9}\\,$).\n- The detected signal electrons per band are given by the photon rate times integration time and overall efficiency, with étendue $\\,G = A\\Omega\\,$ (aperture area times acceptance solid angle), spectral sampling width $\\,\\Delta\\lambda\\,$, optical throughput $\\,\\tau_{\\mathrm{opt}}\\,$, and detector quantum efficiency $\\,QE(\\lambda)\\,$:\n$$\nN_{\\mathrm{sig}}(\\lambda) = t\\,\\Delta\\lambda\\,L(\\lambda)\\,G\\,\\frac{\\lambda_m}{h\\,c}\\,\\tau_{\\mathrm{opt}}\\,QE(\\lambda).\n$$\n- Total noise electrons combine independent sources in quadrature: shot noise from the signal, dark current noise, and read noise,\n$$\n\\sigma_{\\mathrm{tot}}(\\lambda) = \\sqrt{N_{\\mathrm{sig}}(\\lambda) + I_{\\mathrm{dark}}\\,t + \\sigma_{\\mathrm{read}}^2}.\n$$\n- Signal-to-Noise Ratio (SNR) per band is\n$$\nSNR(\\lambda) = \\frac{N_{\\mathrm{sig}}(\\lambda)}{\\sigma_{\\mathrm{tot}}(\\lambda)}.\n$$\n- The Noise Equivalent Delta Reflectance (NEΔR) per band is defined as the reflectance change that yields unit SNR under linear scaling, which for a uniform target reduces to\n$$\nNE\\Delta R_{\\lambda} = \\frac{\\rho(\\lambda)}{SNR(\\lambda)}.\n$$\nThese are the only allowable bases; you must not introduce shortcut formulas beyond these definitions.\n\nInstrument and illumination models to use:\n- Extraterrestrial solar spectral irradiance is approximated by a smooth function centered in the visible:\n$$\nE_0(\\lambda) = E_{\\max}\\,\\exp\\!\\left(-\\frac{(\\lambda-\\lambda_0)^2}{2\\,\\sigma^2}\\right),\n$$\nwith $\\,E_{\\max} = 1.9\\,\\mathrm{W\\,m^{-2}\\,nm^{-1}}\\,$, $\\,\\lambda_0 = 550\\,\\mathrm{nm}\\,$, and $\\,\\sigma = 140\\,\\mathrm{nm}\\,$.\n- Atmospheric transmittance is approximated by a wavelength-dependent function:\n$$\n\\tau_{\\mathrm{atm}}(\\lambda) = \\exp\\!\\big(-\\alpha\\cdot \\tfrac{400}{\\lambda}\\big),\n$$\nwith $\\,\\alpha = 0.1\\,$.\n- Detector quantum efficiency is approximated by\n$$\nQE(\\lambda) = 0.9\\,\\exp\\!\\left(-\\frac{(\\lambda-550)^2}{2\\cdot 200^2}\\right) + 0.1.\n$$\n- Optical throughput $\\,\\tau_{\\mathrm{opt}}\\,$ is a band-independent scalar multiplier.\n\nConstants:\n- Planck’s constant $\\,h = 6.62607015\\times 10^{-34}\\,\\mathrm{J\\,s}\\,$.\n- Speed of light $\\,c = 2.99792458\\times 10^{8}\\,\\mathrm{m\\,s^{-1}}\\,$.\n- Use $\\,\\pi\\,$ in its mathematical sense.\n\nSpectral sampling:\n- Use the following wavelengths (in $\\mathrm{nm}$) for the computation across the Visible and Near-Infrared (VNIR), with one Short-Wave Infrared (SWIR) band included to test handling outside VNIR: $[400,450,500,550,600,650,700,750,800,850,900,950,1000,1600]$.\n- VNIR evaluation must include only bands with $\\,\\lambda \\in [400,1000]\\,$ $\\mathrm{nm}$.\n\nRequired outputs and units:\n- Compute per-band $\\,SNR(\\lambda)\\,$ (dimensionless) and $\\,NE\\Delta R_{\\lambda}\\,$ (dimensionless reflectance increment).\n- Evaluate the boolean criterion “meets target” defined as $\\,\\min_{\\lambda \\in \\mathrm{VNIR}} SNR(\\lambda) > 300\\,$. This is a strict inequality.\n- For each test case, output a list containing three elements: the minimum VNIR $\\,SNR\\,$ as a float rounded to two decimals, the maximum VNIR $\\,NE\\Delta R_{\\lambda}\\,$ as a float rounded to six decimals, and the boolean evaluation of the criterion.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, where each test case result is a list in the exact format\n$$\n[[m_1,n_1,b_1],[m_2,n_2,b_2],\\dots],\n$$\nwith $\\,m_i\\,$ the minimum VNIR $\\,SNR\\,$ rounded to two decimals, $\\,n_i\\,$ the maximum VNIR $\\,NE\\Delta R_{\\lambda}\\,$ rounded to six decimals, and $\\,b_i\\,$ the boolean.\n\nTest suite:\nProvide computations for the following four scientifically plausible parameter sets to exercise happy path, boundary, and edge conditions. All angles are in degrees, time in seconds, wavelengths in $\\mathrm{nm}$, irradiance in $\\mathrm{W\\,m^{-2}\\,nm^{-1}}$, radiance in $\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,nm^{-1}}$, and electrons are dimensionless counts.\n\n- Case $1$ (happy path):\n  - $\\,\\rho(\\lambda)=0.4\\,$ (constant).\n  - $\\,t=0.01\\,$.\n  - $\\,\\Delta\\lambda=5\\,$.\n  - $\\,G = 1.0\\times 10^{-11}\\,$ $\\mathrm{m^2\\,sr}$.\n  - $\\,\\tau_{\\mathrm{opt}}=0.65\\,$.\n  - $\\,\\theta_s=30\\,$.\n  - $\\,I_{\\mathrm{dark}}=200\\,$ $\\mathrm{e^{-}\\,s^{-1}}$.\n  - $\\,\\sigma_{\\mathrm{read}}=50\\,$ $\\mathrm{e^{-}}$.\n\n- Case $2$ (lower integration time, boundary behavior):\n  - Same as Case $1$ except $\\,t=0.004\\,$.\n\n- Case $3$ (darker target, compensated by longer integration):\n  - $\\,\\rho(\\lambda)=0.1\\,$ (constant).\n  - $\\,t=0.02\\,$.\n  - $\\,\\Delta\\lambda=5\\,$.\n  - $\\,G = 1.0\\times 10^{-11}\\,$ $\\mathrm{m^2\\,sr}$.\n  - $\\,\\tau_{\\mathrm{opt}}=0.65\\,$.\n  - $\\,\\theta_s=30\\,$.\n  - $\\,I_{\\mathrm{dark}}=200\\,$ $\\mathrm{e^{-}\\,s^{-1}}$.\n  - $\\,\\sigma_{\\mathrm{read}}=80\\,$ $\\mathrm{e^{-}}$.\n\n- Case $4$ (read-noise dominated edge case):\n  - $\\,\\rho(\\lambda)=0.4\\,$ (constant).\n  - $\\,t=0.002\\,$.\n  - $\\,\\Delta\\lambda=5\\,$.\n  - $\\,G = 1.0\\times 10^{-11}\\,$ $\\mathrm{m^2\\,sr}$.\n  - $\\,\\tau_{\\mathrm{opt}}=0.65\\,$.\n  - $\\,\\theta_s=30\\,$.\n  - $\\,I_{\\mathrm{dark}}=200\\,$ $\\mathrm{e^{-}\\,s^{-1}}$.\n  - $\\,\\sigma_{\\mathrm{read}}=500\\,$ $\\mathrm{e^{-}}$.\n\nAlgorithmic requirements:\n- Implement the computations exactly as specified using the fundamental relations above.\n- Use the given spectral model functions for $\\,E_0(\\lambda)\\,$, $\\,\\tau_{\\mathrm{atm}}(\\lambda)\\,$, and $\\,QE(\\lambda)\\,$; do not substitute other models.\n- Compute $\\,SNR(\\lambda)\\,$, $\\,NE\\Delta R_{\\lambda}\\,$, and the VNIR evaluation exactly as defined.\n\nFinal output format:\n- A single line string in the exact format\n$$\n[[m_1,n_1,b_1],[m_2,n_2,b_2],[m_3,n_3,b_3],[m_4,n_4,b_4]],\n$$\nwith no spaces, where each $\\,m_i\\,$ is rounded to two decimals and each $\\,n_i\\,$ to six decimals.",
            "solution": "The problem statement has been validated and is deemed scientifically sound, well-posed, objective, and complete. It provides a clear set of fundamental principles, physical models, and parameters to perform a forward simulation of a hyperspectral sensor's performance. The task is to compute the Signal-to-Noise Ratio ($SNR$) and Noise Equivalent Delta Reflectance ($NE\\Delta R$) on a per-band basis and evaluate the sensor's performance against a specified data quality criterion. The solution proceeds by systematically implementing the provided physical-mathematical framework.\n\nThe procedure is executed for each spectral band, defined by its central wavelength $\\lambda$.\n\n**Step 1: Upwelling Spectral Radiance Calculation**\n\nThe analysis begins with the determination of the spectral radiance $L(\\lambda)$ entering the sensor's aperture. This quantity depends on the solar illumination, atmospheric attenuation, and the target's reflective properties.\n\nFirst, the downwelling spectral irradiance at the Earth's surface, $E_d(\\lambda)$, is calculated. It is a product of the extraterrestrial solar spectral irradiance, $E_0(\\lambda)$, the atmospheric transmittance, $\\tau_{\\mathrm{atm}}(\\lambda)$, and a geometric factor accounting for the solar illumination angle, $\\cos(\\theta_s)$, where $\\theta_s$ is the Solar Zenith Angle.\n$$\nE_d(\\lambda) = E_0(\\lambda)\\,\\tau_{\\mathrm{atm}}(\\lambda)\\,\\cos(\\theta_s)\n$$\nThe models for $E_0(\\lambda)$ and $\\tau_{\\mathrm{atm}}(\\lambda)$ are specified as:\n$$\nE_0(\\lambda) = E_{\\max}\\,\\exp\\!\\left(-\\frac{(\\lambda-\\lambda_0)^2}{2\\,\\sigma^2}\\right)\n$$\n$$\n\\tau_{\\mathrm{atm}}(\\lambda) = \\exp\\!\\big(-\\alpha\\cdot \\tfrac{400}{\\lambda}\\big)\n$$\nwhere all parameters ($E_{\\max}$, $\\lambda_0$, $\\sigma$, $\\alpha$) are given constants. Note that the angle $\\theta_s$, provided in degrees, must be converted to radians for use in the trigonometric cosine function.\n\nNext, the upwelling spectral radiance $L(\\lambda)$ from a horizontal, Lambertian target is found using the given relationship, where $\\rho(\\lambda)$ is the spectral reflectance and the factor of $\\pi$ accounts for the isotropic scattering from a Lambertian surface.\n$$\nL(\\lambda) = \\frac{\\rho(\\lambda)\\,E_d(\\lambda)}{\\pi}\n$$\n\n**Step 2: Signal Electron Calculation**\n\nThe sensor converts the incoming radiance into a measurable signal, which is a quantity of electrons. The number of signal electrons, $N_{\\mathrm{sig}}(\\lambda)$, detected in a spectral band is a function of the radiance $L(\\lambda)$, the energy per photon $\\varepsilon(\\lambda)$, and several instrument parameters. The energy of a single photon at wavelength $\\lambda$ is given by the Planck-Einstein relation:\n$$\n\\varepsilon(\\lambda) = \\frac{h\\,c}{\\lambda_m}\n$$\nwhere $h$ is Planck's constant, $c$ is the speed of light, and $\\lambda_m$ is the wavelength in meters ($\\lambda_m = \\lambda \\times 10^{-9}$).\n\nThe number of signal electrons is then determined by integrating the incoming photon flux over the integration time $t$, the spectral bandwidth $\\Delta\\lambda$, and the instrument's light-collecting power (étendue $G$), and accounting for system efficiencies (optical throughput $\\tau_{\\mathrm{opt}}$ and detector quantum efficiency $QE(\\lambda)$). The complete expression provided is:\n$$\nN_{\\mathrm{sig}}(\\lambda) = t\\,\\Delta\\lambda\\,L(\\lambda)\\,G\\,\\frac{\\lambda_m}{h\\,c}\\,\\tau_{\\mathrm{opt}}\\,QE(\\lambda)\n$$\nThe quantum efficiency $QE(\\lambda)$ is itself a function of wavelength, modeled as:\n$$\nQE(\\lambda) = 0.9\\,\\exp\\!\\left(-\\frac{(\\lambda-550)^2}{2\\cdot 200^2}\\right) + 0.1\n$$\n\n**Step 3: Total Noise Calculation**\n\nThe total noise in the measurement is the statistical uncertainty, which arises from several independent sources. The problem specifies three primary noise sources: signal shot noise, dark current noise, and read noise.\n\n1.  **Signal Shot Noise ($\\sigma_{\\mathrm{shot}}$)**: This noise is inherent to the quantum nature of light detection. The arrival of photons is a Poisson process, for which the variance is equal to the mean number of events. Thus, the noise (standard deviation) in the signal electrons is $\\sqrt{N_{\\mathrm{sig}}(\\lambda)}$.\n2.  **Dark Current Noise ($\\sigma_{\\mathrm{dark}}$)**: This is shot noise from thermally generated electrons in the detector. The number of dark electrons is $I_{\\mathrm{dark}} \\cdot t$, where $I_{\\mathrm{dark}}$ is the dark current rate. Following Poisson statistics, the noise is $\\sqrt{I_{\\mathrm{dark}}t}$.\n3.  **Read Noise ($\\sigma_{\\mathrm{read}}$)**: This is a fixed noise floor introduced by the detector readout electronics, given as a constant standard deviation.\n\nSince these noise sources are statistically independent, their variances add. The total noise in electrons, $\\sigma_{\\mathrm{tot}}(\\lambda)$, is the square root of the sum of the variances (i.e., they are added in quadrature):\n$$\n\\sigma_{\\mathrm{tot}}(\\lambda) = \\sqrt{N_{\\mathrm{sig}}(\\lambda) + I_{\\mathrm{dark}}\\,t + \\sigma_{\\mathrm{read}}^2}\n$$\n\n**Step 4: Performance Metrics and Evaluation**\n\nWith the signal and total noise quantified, the primary performance metrics are calculated.\n\nThe Signal-to-Noise Ratio ($SNR$) is the ratio of the signal to the total noise:\n$$\nSNR(\\lambda) = \\frac{N_{\\mathrm{sig}}(\\lambda)}{\\sigma_{\\mathrm{tot}}(\\lambda)}\n$$\n\nThe Noise Equivalent Delta Reflectance ($NE\\Delta R_{\\lambda}$) is a measure of the smallest change in reflectance that the sensor can detect. It is defined as the reflectance that produces a signal equal to the noise (i.e., $SNR = 1$). For a uniform target, it is derived from the calculated $SNR(\\lambda)$ as:\n$$\nNE\\Delta R_{\\lambda} = \\frac{\\rho(\\lambda)}{SNR(\\lambda)}\n$$\nA lower $NE\\Delta R$ indicates better performance (higher sensitivity to reflectance changes).\n\nFinally, the data quality criterion is evaluated. This requires isolating the results for the Visible and Near-Infrared (VNIR) spectral range, defined as wavelengths $\\lambda \\in [400, 1000]\\,\\mathrm{nm}$. Within this range, we find the minimum $SNR$, which typically occurs at the edges of the spectral range where illumination and/or sensor efficiency are lowest. The boolean criterion is a strict inequality check:\n$$\n\\min_{\\lambda \\in \\mathrm{VNIR}} SNR(\\lambda) > 300\n$$\nThe maximum $NE\\Delta R$ in the VNIR range is also determined, as it represents the worst-case performance in that spectral region.\n\nThis complete, sequential procedure is implemented for each of the four specified test cases to generate the required output, which consists of the minimum VNIR $SNR$, the maximum VNIR $NE\\Delta R$, and the boolean evaluation result for each case.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes hyperspectral sensor performance metrics (SNR, NEΔR) based on a\n    physically-grounded forward model.\n    \"\"\"\n\n    # Constants\n    h = 6.62607015e-34  # Planck's constant in J*s\n    c = 2.99792458e8   # Speed of light in m/s\n    hc = h * c\n\n    # Spectral sampling\n    wavelengths_nm = np.array([400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000, 1600])\n    wavelengths_m = wavelengths_nm * 1e-9\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case 1 (happy path)\n        {'rho': 0.4, 't': 0.01, 'delta_lambda': 5, 'G': 1.0e-11, 'tau_opt': 0.65, 'theta_s': 30, 'I_dark': 200, 'sigma_read': 50},\n        # Case 2 (lower integration time)\n        {'rho': 0.4, 't': 0.004, 'delta_lambda': 5, 'G': 1.0e-11, 'tau_opt': 0.65, 'theta_s': 30, 'I_dark': 200, 'sigma_read': 50},\n        # Case 3 (darker target)\n        {'rho': 0.1, 't': 0.02, 'delta_lambda': 5, 'G': 1.0e-11, 'tau_opt': 0.65, 'theta_s': 30, 'I_dark': 200, 'sigma_read': 80},\n        # Case 4 (read-noise dominated)\n        {'rho': 0.4, 't': 0.002, 'delta_lambda': 5, 'G': 1.0e-11, 'tau_opt': 0.65, 'theta_s': 30, 'I_dark': 200, 'sigma_read': 500},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        rho = case['rho']\n        t = case['t']\n        delta_lambda = case['delta_lambda']\n        G = case['G']\n        tau_opt = case['tau_opt']\n        theta_s_deg = case['theta_s']\n        I_dark = case['I_dark']\n        sigma_read = case['sigma_read']\n\n        # Step 1: Upwelling Spectral Radiance Calculation\n        \n        # Extraterrestrial solar irradiance model\n        E_max = 1.9\n        lambda0_E0 = 550\n        sigma_E0 = 140\n        E0_lambda = E_max * np.exp(-((wavelengths_nm - lambda0_E0)**2) / (2 * sigma_E0**2))\n        \n        # Atmospheric transmittance model\n        alpha_atm = 0.1\n        tau_atm_lambda = np.exp(-alpha_atm * (400.0 / wavelengths_nm))\n        \n        # Downwelling spectral irradiance\n        theta_s_rad = math.radians(theta_s_deg)\n        Ed_lambda = E0_lambda * tau_atm_lambda * math.cos(theta_s_rad)\n        \n        # Upwelling spectral radiance\n        L_lambda = (rho * Ed_lambda) / math.pi\n        \n        # Step 2: Signal Electron Calculation\n        \n        # Quantum Efficiency model\n        QE_lambda = 0.9 * np.exp(-((wavelengths_nm - 550)**2) / (2 * 200**2)) + 0.1\n        \n        # Signal electrons\n        N_sig_lambda = t * delta_lambda * L_lambda * G * (wavelengths_m / hc) * tau_opt * QE_lambda\n        \n        # Step 3: Total Noise Calculation\n        \n        # Noise terms (variances)\n        shot_noise_var = N_sig_lambda\n        dark_noise_var = I_dark * t\n        read_noise_var = sigma_read**2\n        \n        # Total noise in electrons (standard deviation)\n        sigma_tot_lambda = np.sqrt(shot_noise_var + dark_noise_var + read_noise_var)\n        \n        # Step 4: Performance Metrics and Evaluation\n        \n        # Signal-to-Noise Ratio (SNR)\n        # Avoid division by zero in case of zero signal and noise\n        SNR_lambda = np.divide(N_sig_lambda, sigma_tot_lambda, out=np.zeros_like(N_sig_lambda), where=sigma_tot_lambda!=0)\n\n        # Noise Equivalent Delta Reflectance (NEΔR)\n        NEDR_lambda = np.divide(rho, SNR_lambda, out=np.full_like(SNR_lambda, np.inf), where=SNR_lambda!=0)\n        \n        # VNIR evaluation\n        vnir_mask = (wavelengths_nm >= 400) & (wavelengths_nm <= 1000)\n        \n        snr_vnir = SNR_lambda[vnir_mask]\n        nedr_vnir = NEDR_lambda[vnir_mask]\n        \n        min_vnir_snr = np.min(snr_vnir)\n        max_vnir_nedr = np.max(nedr_vnir)\n        \n        meets_target = min_vnir_snr > 300\n        \n        all_results.append([min_vnir_snr, max_vnir_nedr, meets_target])\n\n    # Format the final output string as specified, with no spaces.\n    output_parts = []\n    for m, n, b in all_results:\n        m_str = f\"{m:.2f}\"\n        n_str = f\"{n:.6f}\"\n        b_str = str(b).lower()\n        output_parts.append(f\"[{m_str},{n_str},{b_str}]\")\n    \n    final_output_str = f\"[{','.join(output_parts)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Raw at-sensor radiance is a convolution of surface properties and atmospheric effects; to retrieve the true reflectance of the Earth's surface, we must apply an atmospheric correction. This practice compares two of the most common approaches: the data-driven Empirical Line Method (ELM) and a physics-based inversion. By applying both methods to simulated scenes and evaluating their accuracy against ground truth, you will gain practical insight into their respective strengths, weaknesses, and the real-world trade-offs involved in producing high-quality, analysis-ready data. ",
            "id": "3820361",
            "problem": "Consider a nadir-viewing airborne hyperspectral imaging spectroscopy system operating under the Lambertian surface assumption in a plane-parallel atmosphere. The at-sensor spectral radiance $L_{\\lambda}$ (in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mu\\mathrm{m}^{-1}$) for a surface with bottom-of-atmosphere directional–hemispherical reflectance $\\rho_{\\lambda}$ is modeled by the single-scattering radiative transfer relation\n$$\nL_{\\lambda} \\;=\\; L_{p,\\lambda} \\;+\\; \\frac{E_{0,\\lambda}\\,\\cos(\\theta_s)\\,T_{s,\\lambda}\\,T_{v,\\lambda}}{\\pi}\\,\\rho_{\\lambda},\n$$\nwhere $L_{p,\\lambda}$ is the path radiance (in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mu\\mathrm{m}^{-1}$), $E_{0,\\lambda}$ is the extraterrestrial solar spectral irradiance at the top of atmosphere (in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mu\\mathrm{m}^{-1}$), $\\theta_s$ is the solar zenith angle (in degrees), $T_{s,\\lambda}$ and $T_{v,\\lambda}$ are the downward and upward atmospheric transmittances (unitless), respectively, and $\\pi$ is the circle constant. The Empirical Line Method (ELM) constructs, for each spectral band $\\lambda$, a linear calibration $L_{\\lambda} \\approx a_{\\lambda} + b_{\\lambda}\\,\\rho_{\\lambda}$ using field-calibrated reference tarps with known $\\rho_{\\lambda}$ and measured $L_{\\lambda}$, and then inverts this relation to estimate $\\rho_{\\lambda}$ for unknown targets. A physics-based atmospheric correction inverts the above radiative transfer relation using assumed atmospheric parameters to estimate $\\rho_{\\lambda}$ as\n$$\n\\widehat{\\rho}_{\\lambda}^{\\text{phys}} \\;=\\; \\frac{\\pi\\,\\left(L_{\\lambda} - L_{p,\\lambda}^{\\text{assumed}}\\right)}{E_{0,\\lambda}\\,\\cos(\\theta_s)\\,T_{s,\\lambda}^{\\text{assumed}}\\,T_{v,\\lambda}^{\\text{assumed}}}.\n$$\n\nStarting from the definitions above, implement a program that, for each of the three scenarios in the test suite below, performs the following steps entirely in the spectral domain (per band):\n\n- Derive the per-band ELM calibration coefficients $a_{\\lambda}$ and $b_{\\lambda}$ using least squares from three field-calibrated tarps with known $\\rho_{\\lambda}$ and measured $L_{\\lambda}$.\n- Apply the ELM inversion $\\widehat{\\rho}_{\\lambda}^{\\text{ELM}} = (L_{\\lambda} - a_{\\lambda})/b_{\\lambda}$ to independent targets to estimate their $\\rho_{\\lambda}$.\n- Apply the physics-based inversion $\\widehat{\\rho}_{\\lambda}^{\\text{phys}}$ to the same independent targets using the assumed atmospheric parameters for that scenario.\n- Compute the root-mean-square error (RMSE) across all independent targets and bands for each method:\n$$\n\\mathrm{RMSE}^{\\text{ELM}} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\widehat{\\rho}_{i}^{\\text{ELM}} - \\rho_{i}^{\\text{true}}\\right)^2}, \\quad\n\\mathrm{RMSE}^{\\text{phys}} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\widehat{\\rho}_{i}^{\\text{phys}} - \\rho_{i}^{\\text{true}}\\right)^2},\n$$\nwhere $N$ is the total number of target–band pairs aggregated across all independent targets and all bands in the scenario, and $\\rho_{i}^{\\text{true}}$ is the ground-truth reflectance.\n- Report a boolean $B$ that is $1$ if $\\mathrm{RMSE}^{\\text{ELM}} < \\mathrm{RMSE}^{\\text{phys}}$ and $0$ otherwise.\n\nPhysical units and angle specification:\n- Report RMSEs as unitless decimals (reflectance is unitless). Do not use the percentage sign.\n- Use degrees for all angles.\n\nThe scene comprises $5$ spectral bands centered nominally near $450\\,\\mathrm{nm}$, $550\\,\\mathrm{nm}$, $650\\,\\mathrm{nm}$, $850\\,\\mathrm{nm}$, and $1050\\,\\mathrm{nm}$, but you must treat each band purely by its provided numerical parameters without relying on wavelengths.\n\nIndependent targets with ground-truth bottom-of-atmosphere reflectances per band are:\n- Vegetation: $[\\,0.05,\\,0.10,\\,0.05,\\,0.45,\\,0.35\\,]$,\n- Soil: $[\\,0.15,\\,0.20,\\,0.25,\\,0.30,\\,0.32\\,]$,\n- Water: $[\\,0.02,\\,0.01,\\,0.005,\\,0.02,\\,0.02\\,]$.\n\nField-calibrated tarps with known reflectances per band are:\n- Dark tarp: $[\\,0.04,\\,0.05,\\,0.05,\\,0.06,\\,0.07\\,]$,\n- Medium tarp: $[\\,0.20,\\,0.22,\\,0.23,\\,0.25,\\,0.28\\,]$,\n- Bright tarp: $[\\,0.60,\\,0.62,\\,0.63,\\,0.65,\\,0.68\\,]$.\n\nFor each scenario, construct the measured at-sensor radiances for tarps and independent targets using the “true” atmospheric parameters via\n$$\nL_{\\lambda}^{\\text{true}} \\;=\\; L_{p,\\lambda}^{\\text{true}} \\;+\\; \\frac{E_{0,\\lambda}\\,\\cos(\\theta_s)\\,T_{s,\\lambda}^{\\text{true}}\\,T_{v,\\lambda}^{\\text{true}}}{\\pi}\\,\\rho_{\\lambda}^{\\text{true}},\n$$\nthen add the specified band-dependent additive measurement noise offsets $\\Delta L_{\\lambda}^{\\text{tarps}}$ and $\\Delta L_{\\lambda}^{\\text{targets}}$ (in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mu\\mathrm{m}^{-1}$) to the tarps and independent targets radiances, respectively.\n\nTest suite scenarios:\n\n- Scenario A (clear atmosphere, small biases):\n  - $E_{0,\\lambda} = [\\,1900,\\,1850,\\,1700,\\,1350,\\,900\\,]$.\n  - $\\theta_s = 30$ degrees.\n  - $T_{s,\\lambda}^{\\text{true}} = [\\,0.76,\\,0.84,\\,0.90,\\,0.95,\\,0.96\\,]$.\n  - $T_{v,\\lambda}^{\\text{true}} = [\\,0.78,\\,0.85,\\,0.90,\\,0.94,\\,0.95\\,]$.\n  - $L_{p,\\lambda}^{\\text{true}} = [\\,10,\\,7,\\,5,\\,2,\\,1\\,]$.\n  - $\\Delta L_{\\lambda}^{\\text{tarps}} = [\\,0.20,\\,0.15,\\,0.10,\\,0.08,\\,0.05\\,]$.\n  - $\\Delta L_{\\lambda}^{\\text{targets}} = [\\,0.10,\\,0.08,\\,0.06,\\,0.05,\\,0.04\\,]$.\n  - Physics-based assumed parameters:\n    - $T_{s,\\lambda}^{\\text{assumed}} = [\\,0.74,\\,0.83,\\,0.88,\\,0.94,\\,0.95\\,]$.\n    - $T_{v,\\lambda}^{\\text{assumed}} = [\\,0.79,\\,0.86,\\,0.89,\\,0.93,\\,0.94\\,]$.\n    - $L_{p,\\lambda}^{\\text{assumed}} = [\\,10.5,\\,7.5,\\,4.5,\\,2.2,\\,1.1\\,]$.\n\n- Scenario B (hazy atmosphere, larger biases):\n  - $E_{0,\\lambda} = [\\,1900,\\,1850,\\,1700,\\,1350,\\,900\\,]$.\n  - $\\theta_s = 30$ degrees.\n  - $T_{s,\\lambda}^{\\text{true}} = [\\,0.60,\\,0.70,\\,0.75,\\,0.85,\\,0.90\\,]$.\n  - $T_{v,\\lambda}^{\\text{true}} = [\\,0.65,\\,0.72,\\,0.77,\\,0.86,\\,0.90\\,]$.\n  - $L_{p,\\lambda}^{\\text{true}} = [\\,18,\\,12,\\,9,\\,4,\\,2\\,]$.\n  - $\\Delta L_{\\lambda}^{\\text{tarps}} = [\\,0.50,\\,0.40,\\,0.30,\\,0.20,\\,0.15\\,]$.\n  - $\\Delta L_{\\lambda}^{\\text{targets}} = [\\,0.30,\\,0.25,\\,0.20,\\,0.15,\\,0.10\\,]$.\n  - Physics-based assumed parameters:\n    - $T_{s,\\lambda}^{\\text{assumed}} = [\\,0.62,\\,0.73,\\,0.78,\\,0.88,\\,0.92\\,]$.\n    - $T_{v,\\lambda}^{\\text{assumed}} = [\\,0.66,\\,0.73,\\,0.78,\\,0.85,\\,0.89\\,]$.\n    - $L_{p,\\lambda}^{\\text{assumed}} = [\\,16,\\,11,\\,7,\\,3.5,\\,1.8\\,]$.\n\n- Scenario C (edge case with low blue transmittance and different solar geometry):\n  - $E_{0,\\lambda} = [\\,1900,\\,1850,\\,1700,\\,1350,\\,900\\,]$.\n  - $\\theta_s = 60$ degrees.\n  - $T_{s,\\lambda}^{\\text{true}} = [\\,0.50,\\,0.80,\\,0.88,\\,0.93,\\,0.95\\,]$.\n  - $T_{v,\\lambda}^{\\text{true}} = [\\,0.52,\\,0.82,\\,0.88,\\,0.93,\\,0.95\\,]$.\n  - $L_{p,\\lambda}^{\\text{true}} = [\\,25,\\,9,\\,6,\\,3,\\,1.5\\,]$.\n  - $\\Delta L_{\\lambda}^{\\text{tarps}} = [\\,0.25,\\,0.20,\\,0.10,\\,0.08,\\,0.06\\,]$.\n  - $\\Delta L_{\\lambda}^{\\text{targets}} = [\\,0.15,\\,0.12,\\,0.08,\\,0.06,\\,0.05\\,]$.\n  - Physics-based assumed parameters:\n    - $T_{s,\\lambda}^{\\text{assumed}} = [\\,0.55,\\,0.78,\\,0.86,\\,0.92,\\,0.94\\,]$.\n    - $T_{v,\\lambda}^{\\text{assumed}} = [\\,0.50,\\,0.80,\\,0.86,\\,0.92,\\,0.94\\,]$.\n    - $L_{p,\\lambda}^{\\text{assumed}} = [\\,23,\\,8,\\,5.5,\\,2.8,\\,1.4\\,]$.\n\nImplementation details and requirements:\n\n- Use the tarps’ ground-truth reflectances to generate their measured radiances per band with the formula for $L_{\\lambda}^{\\text{true}}$ using the scenario’s “true” parameters, then add $\\Delta L_{\\lambda}^{\\text{tarps}}$ to obtain $L_{\\lambda}^{\\text{tarps,meas}}$.\n- Use each independent target’s ground-truth reflectances to generate their measured radiances per band with the formula for $L_{\\lambda}^{\\text{true}}$ using the scenario’s “true” parameters, then add $\\Delta L_{\\lambda}^{\\text{targets}}$ to obtain $L_{\\lambda}^{\\text{targets,meas}}$.\n- Fit ELM per band using $L_{\\lambda}^{\\text{tarps,meas}}$ and $\\rho_{\\lambda}^{\\text{tarps}}$ by least squares over the $3$ tarps to produce $a_{\\lambda}$ and $b_{\\lambda}$, then invert for independent targets.\n- Invert the physics-based relation per band using the scenario’s assumed parameters for $T_{s,\\lambda}^{\\text{assumed}}$, $T_{v,\\lambda}^{\\text{assumed}}$, and $L_{p,\\lambda}^{\\text{assumed}}$.\n- Compute $\\mathrm{RMSE}^{\\text{ELM}}$ and $\\mathrm{RMSE}^{\\text{phys}}$ as unitless decimals.\n- For each scenario, return the triplet $[\\,\\mathrm{RMSE}^{\\text{ELM}},\\,\\mathrm{RMSE}^{\\text{phys}},\\,B\\,]$ with $B$ as $1$ if $\\mathrm{RMSE}^{\\text{ELM}} < \\mathrm{RMSE}^{\\text{phys}}$ and $0$ otherwise.\n\nFinal output format:\n\nYour program should produce a single line of output containing the nine results, ordered by scenarios A, B, C, as a comma-separated list enclosed in square brackets, with the RMSE values rounded to six decimal places, and booleans expressed as integers $0$ or $1$. The exact output format is:\n$$\n[\\,\\mathrm{RMSE}_A^{\\text{ELM}},\\,\\mathrm{RMSE}_A^{\\text{phys}},\\,B_A,\\,\\mathrm{RMSE}_B^{\\text{ELM}},\\,\\mathrm{RMSE}_B^{\\text{phys}},\\,B_B,\\,\\mathrm{RMSE}_C^{\\text{ELM}},\\,\\mathrm{RMSE}_C^{\\text{phys}},\\,B_C\\,].\n$$",
            "solution": "The problem is well-posed, scientifically grounded, and provides all necessary information to perform a comparative analysis of two standard atmospheric correction methods in hyperspectral remote sensing: the Empirical Line Method (ELM) and a physics-based inversion. The analysis will be performed for three distinct scenarios, and the steps are meticulously laid out.\n\nThe core of the problem lies in the radiative transfer equation for at-sensor spectral radiance, $L_{\\lambda}$, under the specified assumptions of a nadir-viewing sensor, a Lambertian surface, and a plane-parallel atmosphere:\n$$\nL_{\\lambda} \\;=\\; L_{p,\\lambda} \\;+\\; \\frac{E_{0,\\lambda}\\,\\cos(\\theta_s)\\,T_{s,\\lambda}\\,T_{v,\\lambda}}{\\pi}\\,\\rho_{\\lambda}\n$$\nHere, $L_{p,\\lambda}$ is the path radiance, representing atmospheric scattering into the sensor's path, and the second term represents the surface-reflected solar radiance that reaches the sensor. For conciseness, we can define a gain factor, $G_{\\lambda}$, such that the equation becomes a simple linear relationship between radiance and reflectance: $L_{\\lambda} = L_{p,\\lambda} + G_{\\lambda} \\rho_{\\lambda}$, where $G_{\\lambda} = \\frac{E_{0,\\lambda}\\,\\cos(\\theta_s)\\,T_{s,\\lambda}\\,T_{v,\\lambda}}{\\pi}$.\n\nThe methodological steps for each scenario are as follows:\n\n**Step 1: Simulation of Measured At-Sensor Radiance**\n\nFirst, we simulate the \"measured\" at-sensor radiances, $L_{\\lambda}^{\\text{meas}}$, for both the calibration tarps and the independent targets. This is done using the \"true\" atmospheric parameters provided for each scenario. The solar zenith angle, $\\theta_s$, must be converted from degrees to radians for use in trigonometric functions. The true gain factor, $G_{\\lambda}^{\\text{true}}$, for each spectral band $\\lambda$ is:\n$$\nG_{\\lambda}^{\\text{true}} = \\frac{E_{0,\\lambda}\\,\\cos(\\theta_s)\\,T_{s,\\lambda}^{\\text{true}}\\,T_{v,\\lambda}^{\\text{true}}}{\\pi}\n$$\nThe \"true\" noiseless radiance for a material with true reflectance $\\rho_{\\lambda}^{\\text{true}}$ is then:\n$$\nL_{\\lambda}^{\\text{true}} = L_{p,\\lambda}^{\\text{true}} + G_{\\lambda}^{\\text{true}}\\,\\rho_{\\lambda}^{\\text{true}}\n$$\nWe apply this formula to the known reflectances of the $3$ calibration tarps and the $3$ independent targets. Finally, we add the specified band-dependent additive measurement noise, $\\Delta L_{\\lambda}$, to obtain the simulated measured radiances:\n$$\nL_{\\lambda}^{\\text{tarps,meas}} = L_{\\lambda}^{\\text{tarps,true}} + \\Delta L_{\\lambda}^{\\text{tarps}}\n$$\n$$\nL_{\\lambda}^{\\text{targets,meas}} = L_{\\lambda}^{\\text{targets,true}} + \\Delta L_{\\lambda}^{\\text{targets}}\n$$\n\n**Step 2: Empirical Line Method (ELM) Calibration and Inversion**\n\nThe ELM establishes a direct empirical relationship between measured radiance and known surface reflectance. For each spectral band $\\lambda$, we perform a linear regression on the data from the three calibration tarps: $(\\rho_{\\lambda, \\text{tarp}_1}, L_{\\lambda, \\text{tarp}_1}^{\\text{meas}})$, $(\\rho_{\\lambda, \\text{tarp}_2}, L_{\\lambda, \\text{tarp}_2}^{\\text{meas}})$, and $(\\rho_{\\lambda, \\text{tarp}_3}, L_{\\lambda, \\text{tarp}_3}^{\\text{meas}})$. This yields the ELM coefficients $a_{\\lambda}$ (intercept) and $b_{\\lambda}$ (slope) for the model $L_{\\lambda} \\approx a_{\\lambda} + b_{\\lambda}\\rho_{\\lambda}$. These coefficients are determined by minimizing the sum of squared errors.\n\nOnce the coefficients $a_{\\lambda}$ and $b_{\\lambda}$ are known for each band, we can invert the model to estimate the reflectance of the independent targets from their measured radiances:\n$$\n\\widehat{\\rho}_{\\lambda}^{\\text{ELM}} = \\frac{L_{\\lambda}^{\\text{targets,meas}} - a_{\\lambda}}{b_{\\lambda}}\n$$\n\n**Step 3: Physics-Based Inversion**\n\nThe physics-based method directly inverts the radiative transfer equation using a set of *assumed* atmospheric parameters, which may differ from the \"true\" parameters used to generate the data, simulating real-world uncertainty. The estimated reflectance for each independent target and band is calculated as:\n$$\n\\widehat{\\rho}_{\\lambda}^{\\text{phys}} \\;=\\; \\frac{\\pi\\,\\left(L_{\\lambda}^{\\text{targets,meas}} - L_{p,\\lambda}^{\\text{assumed}}\\right)}{E_{0,\\lambda}\\,\\cos(\\theta_s)\\,T_{s,\\lambda}^{\\text{assumed}}\\,T_{v,\\lambda}^{\\text{assumed}}}\n$$\nThis calculation is performed for each of the $3$ independent targets across all $5$ spectral bands.\n\n**Step 4: Error Calculation and Comparison**\n\nTo evaluate the performance of both methods, we compute the Root-Mean-Square Error (RMSE) for each. The error is calculated over the entire set of retrieved reflectances for the independent targets, which comprises $N = 3 \\text{ targets} \\times 5 \\text{ bands} = 15$ data points per scenario.\nThe true reflectances, $\\rho_{i}^{\\text{true}}$, are taken from the provided data for Vegetation, Soil, and Water. The estimated reflectances are $\\widehat{\\rho}_{i}^{\\text{ELM}}$ and $\\widehat{\\rho}_{i}^{\\text{phys}}$.\n\nThe RMSE formulas are:\n$$\n\\mathrm{RMSE}^{\\text{ELM}} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\widehat{\\rho}_{i}^{\\text{ELM}} - \\rho_{i}^{\\text{true}}\\right)^2}\n$$\n$$\n\\mathrm{RMSE}^{\\text{phys}} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\widehat{\\rho}_{i}^{\\text{phys}} - \\rho_{i}^{\\text{true}}\\right)^2}\n$$\nFinally, we determine the boolean indicator $B$ by comparing the two RMSE values. $B$ is set to $1$ if $\\mathrm{RMSE}^{\\text{ELM}} < \\mathrm{RMSE}^{\\text{phys}}$, indicating that the ELM performed better under the given scenario's conditions, and $0$ otherwise.\n\nThis entire procedure is repeated for each of the three scenarios (A, B, and C), and the nine resulting values (three per scenario: $\\mathrm{RMSE}^{\\text{ELM}}$, $\\mathrm{RMSE}^{\\text{phys}}$, and $B$) are aggregated into a single list for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the remote sensing problem for all scenarios.\n    \"\"\"\n\n    # Ground-truth reflectances for independent targets and calibration tarps\n    RHO_TARGETS_TRUE = np.array([\n        [0.05, 0.10, 0.05, 0.45, 0.35],  # Vegetation\n        [0.15, 0.20, 0.25, 0.30, 0.32],  # Soil\n        [0.02, 0.01, 0.005, 0.02, 0.02], # Water\n    ])\n\n    RHO_TARPS = np.array([\n        [0.04, 0.05, 0.05, 0.06, 0.07],  # Dark tarp\n        [0.20, 0.22, 0.23, 0.25, 0.28],  # Medium tarp\n        [0.60, 0.62, 0.63, 0.65, 0.68],  # Bright tarp\n    ])\n\n    scenarios = [\n        # Scenario A\n        {\n            \"E0\": np.array([1900, 1850, 1700, 1350, 900]),\n            \"theta_s\": 30,\n            \"T_s_true\": np.array([0.76, 0.84, 0.90, 0.95, 0.96]),\n            \"T_v_true\": np.array([0.78, 0.85, 0.90, 0.94, 0.95]),\n            \"L_p_true\": np.array([10, 7, 5, 2, 1]),\n            \"delta_L_tarps\": np.array([0.20, 0.15, 0.10, 0.08, 0.05]),\n            \"delta_L_targets\": np.array([0.10, 0.08, 0.06, 0.05, 0.04]),\n            \"T_s_assumed\": np.array([0.74, 0.83, 0.88, 0.94, 0.95]),\n            \"T_v_assumed\": np.array([0.79, 0.86, 0.89, 0.93, 0.94]),\n            \"L_p_assumed\": np.array([10.5, 7.5, 4.5, 2.2, 1.1]),\n        },\n        # Scenario B\n        {\n            \"E0\": np.array([1900, 1850, 1700, 1350, 900]),\n            \"theta_s\": 30,\n            \"T_s_true\": np.array([0.60, 0.70, 0.75, 0.85, 0.90]),\n            \"T_v_true\": np.array([0.65, 0.72, 0.77, 0.86, 0.90]),\n            \"L_p_true\": np.array([18, 12, 9, 4, 2]),\n            \"delta_L_tarps\": np.array([0.50, 0.40, 0.30, 0.20, 0.15]),\n            \"delta_L_targets\": np.array([0.30, 0.25, 0.20, 0.15, 0.10]),\n            \"T_s_assumed\": np.array([0.62, 0.73, 0.78, 0.88, 0.92]),\n            \"T_v_assumed\": np.array([0.66, 0.73, 0.78, 0.85, 0.89]),\n            \"L_p_assumed\": np.array([16, 11, 7, 3.5, 1.8]),\n        },\n        # Scenario C\n        {\n            \"E0\": np.array([1900, 1850, 1700, 1350, 900]),\n            \"theta_s\": 60,\n            \"T_s_true\": np.array([0.50, 0.80, 0.88, 0.93, 0.95]),\n            \"T_v_true\": np.array([0.52, 0.82, 0.88, 0.93, 0.95]),\n            \"L_p_true\": np.array([25, 9, 6, 3, 1.5]),\n            \"delta_L_tarps\": np.array([0.25, 0.20, 0.10, 0.08, 0.06]),\n            \"delta_L_targets\": np.array([0.15, 0.12, 0.08, 0.06, 0.05]),\n            \"T_s_assumed\": np.array([0.55, 0.78, 0.86, 0.92, 0.94]),\n            \"T_v_assumed\": np.array([0.50, 0.80, 0.86, 0.92, 0.94]),\n            \"L_p_assumed\": np.array([23, 8, 5.5, 2.8, 1.4]),\n        },\n    ]\n\n    all_results = []\n    for scenario_data in scenarios:\n        result_triplet = process_scenario(scenario_data, RHO_TARGETS_TRUE, RHO_TARPS)\n        all_results.extend(result_triplet)\n    \n    # Format the final list for printing\n    formatted_results = []\n    for i, res in enumerate(all_results):\n        if i % 3 in [0, 1]:  # RMSE values\n            formatted_results.append(f\"{res:.6f}\")\n        else:  # Boolean flag\n            formatted_results.append(str(res))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_scenario(data, rho_targets_true, rho_tarps):\n    \"\"\"\n    Processes a single scenario to calculate RMSEs and the comparison boolean.\n    \"\"\"\n    E0, theta_s = data[\"E0\"], data[\"theta_s\"]\n    T_s_true, T_v_true, L_p_true = data[\"T_s_true\"], data[\"T_v_true\"], data[\"L_p_true\"]\n    delta_L_tarps, delta_L_targets = data[\"delta_L_tarps\"], data[\"delta_L_targets\"]\n    T_s_assumed, T_v_assumed, L_p_assumed = data[\"T_s_assumed\"], data[\"T_v_assumed\"], data[\"L_p_assumed\"]\n    \n    theta_s_rad = np.deg2rad(theta_s)\n    cos_theta_s = np.cos(theta_s_rad)\n\n    # --- 1. Simulate Measured Radiance ---\n    def calculate_radiance(rho, Lp, Ts, Tv):\n        atmos_term = (E0 * cos_theta_s * Ts * Tv) / np.pi\n        # Broadcasting: (n_materials, n_bands) * (n_bands,) + (n_bands,)\n        radiance = Lp + atmos_term * rho\n        return radiance\n\n    L_tarps_true = calculate_radiance(rho_tarps, L_p_true, T_s_true, T_v_true)\n    L_targets_true = calculate_radiance(rho_targets_true, L_p_true, T_s_true, T_v_true)\n\n    L_tarps_meas = L_tarps_true + delta_L_tarps\n    L_targets_meas = L_targets_true + delta_L_targets\n\n    # --- 2. Empirical Line Method (ELM) ---\n    num_bands = rho_tarps.shape[1]\n    a_coeffs = np.zeros(num_bands)\n    b_coeffs = np.zeros(num_bands)\n\n    for i in range(num_bands):\n        rho_vals = rho_tarps[:, i]\n        L_vals = L_tarps_meas[:, i]\n        # slope (b), intercept (a)\n        b, a = np.polyfit(rho_vals, L_vals, 1)\n        a_coeffs[i] = a\n        b_coeffs[i] = b\n\n    # Invert ELM for independent targets\n    # Broadcasting: (n_targets, n_bands) - (n_bands,) / (n_bands,)\n    rho_elm_est = (L_targets_meas - a_coeffs) / b_coeffs\n\n    # --- 3. Physics-Based Inversion ---\n    atmos_term_assumed = (E0 * cos_theta_s * T_s_assumed * T_v_assumed) / np.pi\n    # Broadcasting: ( (n_targets, n_bands) - (n_bands,) ) / (n_bands,)\n    rho_phys_est = (L_targets_meas - L_p_assumed) / atmos_term_assumed\n\n    # --- 4. Error Calculation ---\n    N = rho_targets_true.size\n    \n    # Calculate RMSE for ELM\n    errors_elm = rho_elm_est - rho_targets_true\n    rmse_elm = np.sqrt(np.sum(errors_elm**2) / N)\n\n    # Calculate RMSE for Physics-based method\n    errors_phys = rho_phys_est - rho_targets_true\n    rmse_phys = np.sqrt(np.sum(errors_phys**2) / N)\n    \n    # Compare RMSEs\n    B = 1 if rmse_elm < rmse_phys else 0\n    \n    return [rmse_elm, rmse_phys, B]\n\nsolve()\n```"
        }
    ]
}