{
    "hands_on_practices": [
        {
            "introduction": "To efficiently store vast amounts of scientific data, physical measurements are often scaled and offset into smaller integer types. This practice, known as data packing and standardized by the Climate and Forecast (CF) Conventions, relies entirely on metadata for correct interpretation. This exercise  walks you through the fundamental process of unpacking a stored integer value to recover its true physical meaning, a critical first step in nearly all geospatial data analysis.",
            "id": "3817005",
            "problem": "A Network Common Data Form (netCDF) file adheres to the Climate and Forecast (CF) Metadata Conventions and contains a packed integer variable representing sea surface temperature. The variable is named \"sst\" and is stored as a signed 16-bit integer. The CF packing attributes are provided as follows: the attribute \"scale\\_factor\" equals $0.01$ and the attribute \"add\\_offset\" equals $175.00$. The \"units\" attribute for \"sst\" is \"K\" (kelvin), consistent with the Unidata Units (UDUNITS) library, indicating that unpacked physical values are in kelvin. The packed value at pixel index $(i,j)=(512,1024)$ at time $t_{0}$ is $x_{\\mathrm{packed}}=12485$.\n\nStarting from the CF definition of data packing and the UDUNITS definition of the Celsius–kelvin relationship, perform the following:\n\n- Unpack the value to obtain the physical sea surface temperature $x_{\\mathrm{unpacked}}$ in kelvin at $(i,j,t_{0})$.\n- Convert the unpacked temperature from kelvin to degrees Celsius.\n- Round your final temperature in degrees Celsius to four significant figures, and express the answer in degrees Celsius.\n\nAdditionally, based on CF metadata standards, identify the necessary updates to the metadata to reflect the units conversion from kelvin to degrees Celsius for the variable \"sst\" after unpacking the data to floating-point values. Describe these updates in words, not as a calculation.\n\nYour final submitted answer must be a single real-valued number corresponding to the temperature at $(i,j,t_{0})$ in degrees Celsius, rounded to four significant figures. Do not include units in your final numeric answer box.",
            "solution": "The problem is scientifically grounded, well-posed, and objective. It is based on established geospatial data standards, specifically the Network Common Data Form (netCDF) and the Climate and Forecast (CF) Metadata Conventions. All necessary data and definitions for a unique solution are provided. The process involves a direct application of the CF-defined formula for unpacking data and a standard physical unit conversion.\n\nFirst, we unpack the packed integer value to obtain the true physical value. The CF Metadata Conventions define the relationship between the packed value ($x_{\\mathrm{packed}}$) and the unpacked physical value ($x_{\\mathrm{unpacked}}$) using two attributes, `scale_factor` and `add_offset`, as follows:\n$$x_{\\mathrm{unpacked}} = x_{\\mathrm{packed}} \\times \\text{scale\\_factor} + \\text{add\\_offset}$$\nThe problem provides the following values:\n- The packed value for the sea surface temperature variable \"sst\" at the specified location is $x_{\\mathrm{packed}} = 12485$.\n- The `scale_factor` attribute is $0.01$.\n- The `add_offset` attribute is $175.00$.\n\nSubstituting these values into the formula yields the unpacked temperature in kelvin ($K$), as specified by the `\"units\"` attribute in the metadata:\n$$x_{\\mathrm{unpacked}} = 12485 \\times 0.01 + 175.00$$\n$$x_{\\mathrm{unpacked}} = 124.85 + 175.00$$\n$$x_{\\mathrm{unpacked}} = 299.85$$\nThus, the sea surface temperature in kelvin is $T_{\\mathrm{K}} = 299.85 \\, \\mathrm{K}$.\n\nNext, we convert this temperature from kelvin to degrees Celsius ($^{\\circ}\\mathrm{C}$). The relationship between the Kelvin scale ($T_{\\mathrm{K}}$) and the Celsius scale ($T_{^{\\circ}\\mathrm{C}}$) is defined as:\n$$T_{^{\\circ}\\mathrm{C}} = T_{\\mathrm{K}} - 273.15$$\nThis definition is standardized and is the basis for conversions in libraries such as UDUNITS.\n\nSubstituting the unpacked kelvin temperature into this equation:\n$$T_{^{\\circ}\\mathrm{C}} = 299.85 - 273.15$$\n$$T_{^{\\circ}\\mathrm{C}} = 26.70$$\n\nThe problem requires the final answer to be rounded to four significant figures. The calculated value is $26.70$. The digits $2$, $6$, $7$, and $0$ are all significant. The trailing zero is significant because the subtraction involves two numbers both known to two decimal places, so the result is also precise to two decimal places. Therefore, the value $26.70$ already has exactly four significant figures and requires no further rounding.\n\nFinally, the problem asks for the necessary metadata updates to reflect the unit conversion. If a new variable is created containing the sea surface temperature in degrees Celsius (or if the original variable is overwritten), the following metadata changes are required according to the CF conventions:\n1.  **Update the `units` attribute**: The `units` attribute for the variable \"sst\" must be changed from `\"K\"` to a string representing degrees Celsius. A standard and compliant choice would be `\"Celsius\"` or `\"degree_C\"`.\n2.  **Remove packing attributes**: The `scale_factor` and `add_offset` attributes are exclusively for packed data. Since the new data are unpacked floating-point values, these attributes are no longer applicable and must be removed from the variable's metadata.\n3.  **Update data type**: Implicit in this operation is a change in the variable's data type. It would be converted from a signed 16-bit integer to a floating-point type, such as a 32-bit float (`float`) or a 64-bit float (`double`), to accurately store the unpacked values.\n\nThe requested numerical answer is the temperature in degrees Celsius, rounded to four significant figures.",
            "answer": "$$\n\\boxed{26.70}\n$$"
        },
        {
            "introduction": "The value of a geospatial dataset is fundamentally tied to its positional accuracy—how well locations in the data correspond to their true locations on Earth. The ISO 19157 standard provides a framework for quantifying and reporting this quality aspect. In this practice , you will calculate the Root Mean Square Error ($RMSE$), the most common metric for absolute positional accuracy, from a set of ground control point residuals, thereby translating a collection of error vectors into a single, understandable quality indicator.",
            "id": "3816999",
            "problem": "A remote sensing team georeferences a multispectral satellite image to a projected, metric coordinate reference system. To evaluate horizontal positional accuracy for environmental modeling, they collect ground control points measured with high-precision Global Navigation Satellite System (GNSS) and compute residual vectors between the image-derived positions and the GNSS reference. The International Organization for Standardization (ISO) standard $19157$ defines a data quality element, “positional accuracy,” whose quantitative result must be a scalar, unit-bearing value suitable for metadata encoding.\n\nStarting from fundamental Euclidean geometry and the definition of mean squared error as an estimator of random error magnitude, derive a single scalar accuracy statistic appropriate under the assumptions that horizontal errors are unbiased, independent across points, and isotropic in the two planar axes. Then compute this statistic from the following residuals (each residual $i$ is given in meters as $(dx_i, dy_i)$):\n\n- $i=1$: $(0.35,-0.42)$\n- $i=2$: $(-0.28,0.31)$\n- $i=3$: $(0.12,-0.08)$\n- $i=4$: $(-0.50,-0.55)$\n- $i=5$: $(0.18,0.26)$\n- $i=6$: $(-0.04,0.10)$\n- $i=7$: $(0.67,-0.73)$\n- $i=8$: $(-0.22,-0.19)$\n- $i=9$: $(0.05,0.02)$\n- $i=10$: $(-0.39,0.44)$\n\nUnder the ISO $19157$ framework, this scalar will be encoded as the quantitative result of “positional accuracy” (absolute external positional accuracy) with unit meters. Report the final numeric value to be encoded. Express your answer in meters and round to four significant figures.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of statistics and geodesy, well-posed with sufficient data and unambiguous constraints, and objective in its language. The task is to derive and compute a standard positional accuracy metric.\n\nThe problem requires the derivation of a single scalar accuracy statistic from a set of $N$ horizontal residual vectors, $\\mathbf{r}_i = (dx_i, dy_i)$, for $i = 1, \\dots, N$. The derivation must be based on fundamental Euclidean geometry and the definition of Mean Squared Error (MSE), under the assumptions that the errors are unbiased, independent, and isotropic.\n\nFrom Euclidean geometry, the magnitude of the error for each individual point $i$, known as the radial error $e_i$, is the Euclidean norm of its residual vector:\n$$e_i = \\sqrt{dx_i^2 + dy_i^2}$$\nThis represents the straight-line distance between the image-derived position and the true ground position.\n\nThe problem specifies using the concept of Mean Squared Error. The squared error for the $i$-th point is $e_i^2$:\n$$e_i^2 = dx_i^2 + dy_i^2$$\nThe Mean Squared Error for the set of $N$ points is the arithmetic mean of these individual squared errors. In this context, it is the Mean Squared Radial Error, which we can denote as $MSRE$.\n$$MSRE = \\frac{1}{N} \\sum_{i=1}^{N} e_i^2 = \\frac{1}{N} \\sum_{i=1}^{N} (dx_i^2 + dy_i^2)$$\nThe assumption that errors are unbiased (i.e., the population mean error is zero) justifies calculating the MSE with respect to a reference value of $0$. The assumption of independence between points validates the summation of squared errors in this manner. The assumption of isotropy (equal error variance in all directions) is a condition under which this statistic is commonly interpreted, but it is not strictly required for its calculation.\n\nThe $MSRE$ statistic has units of length squared (e.g., meters squared). ISO $19157$ requires a scalar statistic with the same units as the original measurements (meters). To achieve this, we take the square root of the $MSRE$. The resulting quantity is the Root Mean Square Error of the radial errors, denoted as $RMSE_r$:\n$$RMSE_r = \\sqrt{MSRE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (dx_i^2 + dy_i^2)}$$\nThis statistic, often called the horizontal or total RMSE, is the standard single-value measure for positional accuracy in geospatial applications and fulfills all the requirements of the problem.\n\nWe now compute this value for the given data. We have $N=10$ residual vectors. First, we compute the sum of the squared components, $\\sum dx_i^2$ and $\\sum dy_i^2$.\n\nThe given residuals $(dx_i, dy_i)$ in meters are:\n1: $(0.35, -0.42)$\n2: $(-0.28, 0.31)$\n3: $(0.12, -0.08)$\n4: $(-0.50, -0.55)$\n5: $(0.18, 0.26)$\n6: $(-0.04, 0.10)$\n7: $(0.67, -0.73)$\n8: $(-0.22, -0.19)$\n9: $(0.05, 0.02)$\n10: $(-0.39, 0.44)$\n\nThe sum of the squares of the $dx$ components is:\n$$ \\sum_{i=1}^{10} dx_i^2 = (0.35)^2 + (-0.28)^2 + (0.12)^2 + (-0.50)^2 + (0.18)^2 + (-0.04)^2 + (0.67)^2 + (-0.22)^2 + (0.05)^2 + (-0.39)^2 $$\n$$ \\sum_{i=1}^{10} dx_i^2 = 0.1225 + 0.0784 + 0.0144 + 0.2500 + 0.0324 + 0.0016 + 0.4489 + 0.0484 + 0.0025 + 0.1521 = 1.1512 $$\n\nThe sum of the squares of the $dy$ components is:\n$$ \\sum_{i=1}^{10} dy_i^2 = (-0.42)^2 + (0.31)^2 + (-0.08)^2 + (-0.55)^2 + (0.26)^2 + (0.10)^2 + (-0.73)^2 + (-0.19)^2 + (0.02)^2 + (0.44)^2 $$\n$$ \\sum_{i=1}^{10} dy_i^2 = 0.1764 + 0.0961 + 0.0064 + 0.3025 + 0.0676 + 0.0100 + 0.5329 + 0.0361 + 0.0004 + 0.1936 = 1.4220 $$\n\nThe total sum of squared radial errors is:\n$$ \\sum_{i=1}^{10} e_i^2 = \\sum_{i=1}^{10} dx_i^2 + \\sum_{i=1}^{10} dy_i^2 = 1.1512 + 1.4220 = 2.5732 $$\n\nNow we calculate the $RMSE_r$ using $N=10$:\n$$ RMSE_r = \\sqrt{\\frac{2.5732}{10}} = \\sqrt{0.25732} \\approx 0.50726718... $$\n\nThe problem requires the final answer to be reported to four significant figures. The first four significant figures are $5$, $0$, $7$, $2$. The fifth significant figure is $6$, which is $5$ or greater, so we round up the fourth significant figure.\n$$ RMSE_r \\approx 0.5073 $$\nThis is the single scalar accuracy statistic to be encoded in meters.",
            "answer": "$$\\boxed{0.5073}$$"
        },
        {
            "introduction": "Synchronizing data from different satellites, sensors, and ground systems requires an unambiguous and universal representation of time. However, different systems use different clocks, such as the continuous timescale of the Global Positioning System (GPS) versus Coordinated Universal Time (UTC) with its leap seconds. This hands-on problem  will guide you through the essential conversion between GPS time and UTC, and how to encode it using the ISO 8601 standard to ensure temporal interoperability.",
            "id": "3817009",
            "problem": "A satellite-borne imaging spectrometer used in remote sensing produces acquisition times in Global Positioning System (GPS) seconds counted from the GPS epoch. The Level-1 product must be documented according to International Organization for Standardization (ISO) 19115 metadata standards and use ISO 8601 date-time encoding with Coordinated Universal Time (UTC), specifically the format `YYYY-MM-DDThh:mm:ssZ`. The instrument reports an acquisition timestamp of $t_{\\mathrm{GPS}} = 1{,}284{,}035{,}218$ seconds, and the dataset declares a GPS–UTC offset of $N_{\\mathrm{leap}} = 18$ leap seconds.\n\nStarting from foundational definitions, derive the relationship between GPS time and UTC time. Then compute the UTC instant corresponding to $t_{\\mathrm{GPS}}$ and write its ISO 8601 encoding in the required format `YYYY-MM-DDThh:mm:ssZ` for inclusion in the metadata field. Finally, convert that UTC instant to Modified Julian Date (MJD) and provide the value rounded to seven significant figures. Express the final numerical value in days.\n\nUse the following well-tested facts as the base for your derivation:\n- The GPS epoch is `1980-01-06T00:00:00Z`.\n- GPS time is continuous without leap seconds and satisfies $t_{\\mathrm{GPS}} - t_{\\mathrm{UTC}} = N_{\\mathrm{leap}}$ at any instant.\n- The UNIX epoch is `1970-01-01T00:00:00Z`, and the offset from UNIX epoch to GPS epoch is $t_{0} = 315{,}964{,}800$ seconds.\n- Modified Julian Date is related to UNIX time by $\\mathrm{MJD} = \\mathrm{MJD}_{0} + \\frac{t_{\\mathrm{UNIX}}}{86400}$, where $\\mathrm{MJD}_{0} = 40{,}587$ corresponds to `1970-01-01T00:00:00Z`, and $86400$ is the number of seconds in one day.\n\nRound the final MJD to seven significant figures and express it in days. No other rounding should be applied unless explicitly necessitated by the specified format for the metadata encoding.",
            "solution": "The problem statement is evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n- Instrument acquisition timestamp in GPS seconds: $t_{\\mathrm{GPS}} = 1{,}284{,}035{,}218$ seconds\n- GPS–UTC offset (leap seconds): $N_{\\mathrm{leap}} = 18$ seconds\n- Required output format for UTC time: ISO 8601, `YYYY-MM-DDThh:mm:ssZ`\n- GPS epoch: `1980-01-06T00:00:00Z`\n- Relationship between GPS time and UTC time: $t_{\\mathrm{GPS}} - t_{\\mathrm{UTC}} = N_{\\mathrm{leap}}$\n- UNIX epoch: `1970-01-01T00:00:00Z`\n- Offset from UNIX epoch to GPS epoch: $t_{0} = 315{,}964{,}800$ seconds\n- Relationship between Modified Julian Date (MJD) and UNIX time ($t_{\\mathrm{UNIX}}$): $\\mathrm{MJD} = \\mathrm{MJD}_{0} + \\frac{t_{\\mathrm{UNIX}}}{86400}$\n- MJD at UNIX epoch: $\\mathrm{MJD}_{0} = 40587$\n- Seconds in one day: $86400$\n- Final MJD value rounding: to seven significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded. It concerns the conversion between well-defined, standard time systems (GPS, UTC, UNIX, MJD) used extensively in science and engineering. The provided constants and relationships are standard and factually correct. For example, the number of seconds between the UNIX epoch and the GPS epoch is indeed $315,964,800$. The problem is well-posed, providing all necessary data for a unique solution. The language is objective and precise. Therefore, the problem is valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete, reasoned solution follows.\n\nThe solution involves a three-step process: First, we determine the number of seconds elapsed since the UNIX epoch for the given UTC instant. Second, we convert this continuous count of seconds into the standard ISO 8601 calendar date and time format. Third, we convert the continuous second count into Modified Julian Date (MJD).\n\n**1. Derivation of UTC time in seconds from the UNIX epoch**\n\nThe problem provides a relationship between GPS time, $t_{\\mathrm{GPS}}$, and UTC time, $t_{\\mathrm{UTC}}$, as $t_{\\mathrm{GPS}} - t_{\\mathrm{UTC}} = N_{\\mathrm{leap}}$. In this context, $t_{\\mathrm{GPS}}$ represents the continuous count of seconds since the GPS epoch (`1980-01-06T00:00:00Z`). The term $t_{\\mathrm{UTC}}$ is to be interpreted as the corresponding continuous count of SI seconds in the UTC time scale from the same GPS epoch. Therefore, the number of UTC seconds elapsed since the GPS epoch is:\n$$ \\Delta t_{\\mathrm{UTC, from \\ GPS \\ epoch}} = t_{\\mathrm{GPS}} - N_{\\mathrm{leap}} $$\nSubstituting the given values:\n$$ \\Delta t_{\\mathrm{UTC, from \\ GPS \\ epoch}} = 1{,}284{,}035{,}218 - 18 = 1{,}284{,}035{,}200 \\text{ seconds} $$\n\nTo find the time relative to the UNIX epoch (`1970-01-01T00:00:00Z`), we must add the offset between the UNIX and GPS epochs. The GPS epoch occurred $t_{0} = 315{,}964{,}800$ seconds after the UNIX epoch. The total elapsed time in UTC seconds since the UNIX epoch, denoted as $t_{\\mathrm{UNIX}}$, is the sum of this offset and the time elapsed since the GPS epoch.\n$$ t_{\\mathrm{UNIX}} = t_{0} + \\Delta t_{\\mathrm{UTC, from \\ GPS \\ epoch}} $$\n$$ t_{\\mathrm{UNIX}} = 315{,}964{,}800 + 1{,}284{,}035{,}200 = 1{,}600{,}000{,}000 \\text{ seconds} $$\nThis value, $t_{\\mathrm{UNIX}}$, is the UNIX timestamp corresponding to the satellite observation.\n\n**2. Conversion to ISO 8601 UTC representation**\n\nNow we convert $t_{\\mathrm{UNIX}} = 1{,}600{,}000{,}000$ seconds into the `YYYY-MM-DDThh:mm:ssZ` format. First, we separate the total seconds into full days and the remaining seconds within the current day. One day contains $86400$ seconds.\nThe number of full days passed since the UNIX epoch is:\n$$ N_{\\mathrm{days}} = \\left\\lfloor \\frac{t_{\\mathrm{UNIX}}}{86400} \\right\\rfloor = \\left\\lfloor \\frac{1{,}600{,}000{,}000}{86400} \\right\\rfloor = \\lfloor 18518.5185... \\rfloor = 18518 \\text{ days} $$\nThe number of seconds into the current day is:\n$$ S_{\\mathrm{day}} = t_{\\mathrm{UNIX}} \\pmod{86400} = 1{,}600{,}000{,}000 \\pmod{86400} = 44800 \\text{ seconds} $$\nNext, we convert $S_{\\mathrm{day}}$ into hours, minutes, and seconds:\n- Hours ($hh$): $\\left\\lfloor \\frac{44800}{3600} \\right\\rfloor = 12$\n- Remaining seconds: $44800 - 12 \\times 3600 = 1600$\n- Minutes ($mm$): $\\left\\lfloor \\frac{1600}{60} \\right\\rfloor = 26$\n- Remaining seconds ($ss$): $1600 - 26 \\times 60 = 40$\nThe time of day is $12$:$26$:$40$ UTC.\n\nTo find the date, we determine the calendar date corresponding to $18518$ days after the UNIX epoch day, `1970-01-01`. Years 1970 through 2019 span 50 years. The leap years in this interval are $1972$, $1976$, $1980$, $1984$, $1988$, $1992$, $1996$, $2000$, $2004$, $2008$, $2012$, and $2016$. There are $12$ leap years. The number of days from `1970-01-01` to `2019-12-31` is $50 \\times 365 + 12 = 18262$ days.\nThe number of days into the year 2020 is $18518 - 18262 = 256$ days. The current day is therefore the 257th day of 2020.\nThe year 2020 is a leap year. The number of days in the months are: Jan ($31$), Feb ($29$), Mar ($31$), Apr ($30$), May ($31$), Jun ($30$), Jul ($31$), Aug ($31$). The cumulative days to the end of August are $244$.\nThe day in September is $257 - 244 = 13$.\nThus, the date is `2020-09-13`.\n\nCombining the date and time, the ISO 8601 representation is `2020-09-13T12:26:40Z`.\n\n**3. Conversion to Modified Julian Date (MJD)**\n\nThe problem provides the formula for converting a UNIX timestamp to MJD:\n$$ \\mathrm{MJD} = \\mathrm{MJD}_{0} + \\frac{t_{\\mathrm{UNIX}}}{86400} $$\nSubstituting the known values:\n$$ \\mathrm{MJD} = 40587 + \\frac{1{,}600{,}000{,}000}{86400} $$\n$$ \\mathrm{MJD} = 40587 + 18518.5185185... $$\n$$ \\mathrm{MJD} = 59105.5185185... \\text{ days} $$\nThe problem requires rounding this value to seven significant figures. The first seven digits of the number are $5, 9, 1, 0, 5, 5, 1$. The eighth digit is $8$, which is $\\ge 5$, so we round up the seventh digit ($1$) to $2$.\n$$ \\mathrm{MJD}_{\\mathrm{rounded}} = 59105.52 \\text{ days} $$\nThis is the final numerical value.",
            "answer": "$$\n\\boxed{59105.52}\n$$"
        }
    ]
}