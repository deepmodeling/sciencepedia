{
    "hands_on_practices": [
        {
            "introduction": "The foundation of orthorectification is the precise mapping between the output image grid and the ground. This exercise provides hands-on practice with the fundamental georeferencing calculations that underpin this process. By calculating the ground coordinates of a specific pixel and then interpolating its elevation from a Digital Elevation Model (DEM), you will engage directly with the core mechanics of the indirect orthorectification method, where we work backward from the desired output to find the corresponding source data.",
            "id": "3832016",
            "problem": "An orthorectified image is produced on the Universal Transverse Mercator (UTM) grid, North-oriented, using the World Geodetic System 1984 (WGS84) datum. The output raster grid has pixel size $s_{\\text{out}} = 1\\,\\text{m}$ and is referenced by the coordinates of the upper-left pixel corner $(x_{0}^{\\text{out}}, y_{0}^{\\text{out}}) = (450000.0\\,\\text{m},\\,4640000.0\\,\\text{m})$. Pixel indices $(i,j)$ follow the standard image convention: $i$ increases to the right (east) and $j$ increases downward (south). The ground coordinate of a pixel is taken at its center.\n\nA Digital Elevation Model (DEM) on the same UTM grid has square cells of size $s_{\\text{DEM}} = 10\\,\\text{m}$, referenced by the upper-left cell corner coordinates $(x_{0}^{\\text{DEM}}, y_{0}^{\\text{DEM}}) = (449990.0\\,\\text{m},\\,4640010.0\\,\\text{m})$. Elevations are stored at DEM grid nodes located at cell corners. Elevations at the four DEM nodes surrounding the orthorectified pixel center are:\n- $Z_{00}$ at $(i_{\\text{DEM}}, j_{\\text{DEM}})$ equals $348.2\\,\\text{m}$,\n- $Z_{10}$ at $(i_{\\text{DEM}}+1, j_{\\text{DEM}})$ equals $349.0\\,\\text{m}$,\n- $Z_{01}$ at $(i_{\\text{DEM}}, j_{\\text{DEM}}+1)$ equals $347.6\\,\\text{m}$,\n- $Z_{11}$ at $(i_{\\text{DEM}}+1, j_{\\text{DEM}}+1)$ equals $348.5\\,\\text{m}$,\n\nwhere $(i_{\\text{DEM}}, j_{\\text{DEM}})$ are the integer indices of the DEM node just northwest (upper-left) of the pixel center.\n\nStarting from core definitions of raster georeferencing on projected Cartesian coordinates and linear interpolation on grids, derive the expressions that map the orthorectified pixel index $(i,j)$ to its UTM ground coordinates $(x,y)$ at the pixel center and then derive the bilinear interpolation expression to fetch the elevation $Z$ at that center from the DEM using the four surrounding node elevations. For the specific pixel $(i,j) = (1234, 567)$, compute the numerical values of $(x,y)$ and the bilinearly interpolated elevation $Z$. Express all coordinates and elevation in meters. Provide exact values; no rounding is required. The final answer must contain the computed $(x,y)$ and $Z$.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of remote sensing and geomatics, is well-posed with sufficient and consistent data, and is expressed in objective, formal language. We will proceed by first deriving the general expressions for calculating the ground coordinates from pixel indices, then deriving the expression for bilinear interpolation of elevation from a Digital Elevation Model (DEM), and finally applying these expressions to compute the required numerical values.\n\nFirst, we derive the mapping from the orthorectified pixel index $(i,j)$ to its UTM ground coordinates $(x,y)$ at the pixel center. The problem states that the grid is North-oriented. The origin of the output raster is given by the coordinates of the upper-left corner of the pixel $(i,j) = (0,0)$, which are $(x_{0}^{\\text{out}}, y_{0}^{\\text{out}})$. The pixel size is $s_{\\text{out}}$. The index $i$ increases to the right, which corresponds to the Easting (x-coordinate) direction in a North-oriented UTM system. The index $j$ increases downward, which corresponds to the southerly direction, opposite to the Northing (y-coordinate).\n\nThe coordinate of a pixel is taken at its center. For a pixel at index $i$, its center is displaced from the grid origin by $i$ full pixel widths plus half a pixel width. Therefore, the x-coordinate (Easting) $x$ of the center of pixel $(i,j)$ is:\n$$x = x_{0}^{\\text{out}} + i \\cdot s_{\\text{out}} + \\frac{1}{2} s_{\\text{out}} = x_{0}^{\\text{out}} + \\left(i + 0.5\\right) s_{\\text{out}}$$\n\nSimilarly, for a pixel at index $j$, its center is displaced from the grid origin. Since $j$ increases downwards (south), this corresponds to a decrease in the y-coordinate (Northing). The displacement is $j$ full pixel heights plus half a pixel height. Thus, the y-coordinate (Northing) $y$ is:\n$$y = y_{0}^{\\text{out}} - j \\cdot s_{\\text{out}} - \\frac{1}{2} s_{\\text{out}} = y_{0}^{\\text{out}} - \\left(j + 0.5\\right) s_{\\text{out}}$$\n\nWe are given the specific pixel $(i,j) = (1234, 567)$. The other parameters are $(x_{0}^{\\text{out}}, y_{0}^{\\text{out}}) = (450000.0\\,\\text{m}, 4640000.0\\,\\text{m})$ and $s_{\\text{out}} = 1\\,\\text{m}$.\nSubstituting these values:\n$$x = 450000.0 + (1234 + 0.5) \\times 1.0 = 450000.0 + 1234.5 = 451234.5\\,\\text{m}$$\n$$y = 4640000.0 - (567 + 0.5) \\times 1.0 = 4640000.0 - 567.5 = 4639432.5\\,\\text{m}$$\nThe ground coordinates of the center of pixel $(1234, 567)$ are $(x, y) = (451234.5\\,\\text{m}, 4639432.5\\,\\text{m})$.\n\nNext, we derive the expression for bilinear interpolation to find the elevation $Z$ at the point $(x,y)$ using the DEM. The DEM is a grid where elevations are provided at the grid nodes (corners of the cells). To find the elevation at an arbitrary point within a grid cell, we use bilinear interpolation. This involves two successive linear interpolations.\n\nLet the four DEM nodes surrounding the point $(x,y)$ form a rectangle. The problem provides the elevations at these nodes. Let the coordinates of the upper-left (northwest) node be $(x_{\\text{ul}}, y_{\\text{ul}})$ and its elevation be $Z_{\\text{ul}}$. The other nodes are upper-right $(x_{\\text{ur}}, y_{\\text{ur}})$ with elevation $Z_{\\text{ur}}$, lower-left $(x_{\\text{ll}}, y_{\\text{ll}})$ with elevation $Z_{\\text{ll}}$, and lower-right $(x_{\\text{lr}}, y_{\\text{lr}})$ with elevation $Z_{\\text{lr}}$. In the given problem's notation, with DEM cell size $s_{\\text{DEM}}$:\n$Z_{00}$ is at the NW corner $(x_{\\text{ul}}, y_{\\text{ul}})$, which the problem maps to DEM index $(i_{\\text{DEM}}, j_{\\text{DEM}})$.\n$Z_{10}$ is at the NE corner $(x_{\\text{ul}}+s_{\\text{DEM}}, y_{\\text{ul}})$, mapped to $(i_{\\text{DEM}}+1, j_{\\text{DEM}})$.\n$Z_{01}$ is at the SW corner $(x_{\\text{ul}}, y_{\\text{ul}}-s_{\\text{DEM}})$, mapped to $(i_{\\text{DEM}}, j_{\\text{DEM}}+1)$.\n$Z_{11}$ is at the SE corner $(x_{\\text{ul}}+s_{\\text{DEM}}, y_{\\text{ul}}-s_{\\text{DEM}})$, mapped to $(i_{\\text{DEM}}+1, j_{\\text{DEM}}+1)$.\n\nFirst, we define normalized fractional distances of the point $(x,y)$ within the cell, relative to the upper-left corner $(x_{\\text{ul}}, y_{\\text{ul}})$:\n$$\\Delta x = \\frac{x - x_{\\text{ul}}}{s_{\\text{DEM}}}$$\n$$\\Delta y = \\frac{y_{\\text{ul}} - y}{s_{\\text{DEM}}}$$\nNote that $\\Delta x$ and $\\Delta y$ are dimensionless and range from $0$ to $1$.\n\nThe interpolation proceeds in two steps. First, we linearly interpolate along the x-axis at the top and bottom edges of the cell:\nAn intermediate elevation $Z_{\\text{top}}$ along the top edge at the x-coordinate of our point is:\n$$Z_{\\text{top}} = Z_{00}(1 - \\Delta x) + Z_{10} \\Delta x$$\nAn intermediate elevation $Z_{\\text{bottom}}$ along the bottom edge is:\n$$Z_{\\text{bottom}} = Z_{01}(1 - \\Delta x) + Z_{11} \\Delta x$$\n\nSecond, we linearly interpolate along the y-axis between these two intermediate values:\n$$Z = Z_{\\text{top}}(1 - \\Delta y) + Z_{\\text{bottom}} \\Delta y$$\nSubstituting the expressions for $Z_{\\text{top}}$ and $Z_{\\text{bottom}}$ gives the complete bilinear interpolation formula:\n$$Z = \\left(Z_{00}(1 - \\Delta x) + Z_{10} \\Delta x\\right)(1 - \\Delta y) + \\left(Z_{01}(1 - \\Delta x) + Z_{11} \\Delta x\\right) \\Delta y$$\nThis can be expanded to:\n$$Z = Z_{00}(1-\\Delta x)(1-\\Delta y) + Z_{10}\\Delta x(1-\\Delta y) + Z_{01}(1-\\Delta x)\\Delta y + Z_{11}\\Delta x\\Delta y$$\n\nNow we compute the numerical value for $Z$. First, we need to find the coordinates of the upper-left DEM node that contains our point $(x,y)$. The DEM origin is $(x_{0}^{\\text{DEM}}, y_{0}^{\\text{DEM}}) = (449990.0\\,\\text{m}, 4640010.0\\,\\text{m})$ and cell size is $s_{\\text{DEM}}=10\\,\\text{m}$. The indices $(i_{\\text{DEM}}, j_{\\text{DEM}})$ of the upper-left node are:\n$$i_{\\text{DEM}} = \\left\\lfloor \\frac{x - x_{0}^{\\text{DEM}}}{s_{\\text{DEM}}} \\right\\rfloor = \\left\\lfloor \\frac{451234.5 - 449990.0}{10.0} \\right\\rfloor = \\lfloor 124.45 \\rfloor = 124$$\n$$j_{\\text{DEM}} = \\left\\lfloor \\frac{y_{0}^{\\text{DEM}} - y}{s_{\\text{DEM}}} \\right\\rfloor = \\left\\lfloor \\frac{4640010.0 - 4639432.5}{10.0} \\right\\rfloor = \\lfloor 57.75 \\rfloor = 57$$\nThe coordinates of this node $(124, 57)$ are:\n$$x_{\\text{ul}} = x_{0}^{\\text{DEM}} + i_{\\text{DEM}} \\cdot s_{\\text{DEM}} = 449990.0 + 124 \\times 10.0 = 451230.0\\,\\text{m}$$\n$$y_{\\text{ul}} = y_{0}^{\\text{DEM}} - j_{\\text{DEM}} \\cdot s_{\\text{DEM}} = 4640010.0 - 57 \\times 10.0 = 4639440.0\\,\\text{m}$$\n\nNow we can compute the fractional distances:\n$$\\Delta x = \\frac{451234.5 - 451230.0}{10.0} = \\frac{4.5}{10.0} = 0.45$$\n$$\\Delta y = \\frac{4639440.0 - 4639432.5}{10.0} = \\frac{7.5}{10.0} = 0.75$$\n\nThe given elevations are $Z_{00} = 348.2\\,\\text{m}$, $Z_{10} = 349.0\\,\\text{m}$, $Z_{01} = 347.6\\,\\text{m}$, and $Z_{11} = 348.5\\,\\text{m}$.\nWe compute the intermediate elevations:\n$$Z_{\\text{top}} = (348.2)(1 - 0.45) + (349.0)(0.45) = (348.2)(0.55) + (349.0)(0.45) = 191.51 + 157.05 = 348.56\\,\\text{m}$$\n$$Z_{\\text{bottom}} = (347.6)(1 - 0.45) + (348.5)(0.45) = (347.6)(0.55) + (348.5)(0.45) = 191.18 + 156.825 = 348.005\\,\\text{m}$$\nFinally, we compute the elevation $Z$ at the point:\n$$Z = Z_{\\text{top}}(1 - 0.75) + Z_{\\text{bottom}}(0.75) = (348.56)(0.25) + (348.005)(0.75) = 87.14 + 261.00375 = 348.14375\\,\\text{m}$$\n\nThe computed values for the pixel $(i,j)=(1234, 567)$ are:\nGround coordinates $(x,y) = (451234.5\\,\\text{m}, 4639432.5\\,\\text{m})$.\nBilinearly interpolated elevation $Z = 348.14375\\,\\text{m}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n451234.5 & 4639432.5 & 348.14375\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The accuracy of an orthorectified product is critically dependent on the quality of the inputs, particularly the DEM. This practice explores a common but subtle source of error: the mismatch between vertical datums. By analyzing the planimetric displacement caused by using orthometric heights where ellipsoidal heights are required, you will quantify how a vertical error propagates into a horizontal positional error—a crucial concept for understanding and assessing the geometric fidelity of remote sensing products .",
            "id": "3832064",
            "problem": "A pushbroom optical satellite operating under a central-perspective sensor model is used to orthorectify imagery with a Digital Elevation Model (DEM) that stores orthometric heights. The sensor model expects ellipsoidal heights referenced to the World Geodetic System 1984 (WGS84) ellipsoid. Let the orthometric height be denoted by $H$, the ellipsoidal height by $h$, and the geoid undulation by $N$, defined as the geoid’s height above the ellipsoid. The scene is in moderate terrain, meaning local slopes are small enough that the ground can be approximated locally as a horizontal plane normal to the ellipsoid, and the sensor view geometry can be described by a single off-nadir angle.\n\nStarting from first principles of geodetic height definitions and the collinearity relation in central projection, analyze the geometric consequences of providing the sensor model with $H$ when it requires $h$. Then, under the following scientifically plausible conditions, quantify the magnitude of the horizontal positional bias on the ground caused solely by this vertical datum mismatch:\n- The geoid undulation is $N = 30\\,\\text{m}$ at the target location.\n- The sensor’s off-nadir look angle at the target is $\\theta = 25^\\circ$ (angle specified in degrees).\n- The local terrain is sufficiently moderate to justify the small-slope approximation inherent in linearizing the intersection of the sensor line-of-sight with the local ground surface.\n\nExpress your final answer as the magnitude of the horizontal positional bias in meters. Round your answer to four significant figures. Use meters as the unit.",
            "solution": "The problem asks for the quantification of the horizontal positional bias ($\\Delta p$) introduced during orthorectification when an incorrect vertical datum is used. This bias is a form of relief displacement caused by a vertical error ($\\Delta z$) in the context of a central-perspective imaging system. We can derive the solution from first principles.\n\n1.  **Quantify the Vertical Error**:\n    The relationship between ellipsoidal height ($h$), orthometric height ($H$), and geoid undulation ($N$) is defined as:\n    $$h = H + N$$\n    The sensor model requires ellipsoidal height ($h$), but is supplied with orthometric height ($H$). The resulting vertical error, $\\Delta z$, is the difference between the provided height and the required height:\n    $$\\Delta z = H - h = H - (H + N) = -N$$\n    The magnitude of this vertical error is therefore $|\\Delta z| = |N|$.\n\n2.  **Model the Geometric Displacement**:\n    The problem specifies a central-perspective sensor with an off-nadir look angle, $\\theta$, measured from the local vertical. The simplifying assumption of a locally horizontal ground plane allows us to model the geometry as a right-angled triangle where:\n    - The **adjacent** side is the magnitude of the vertical error, $|N|$.\n    - The **opposite** side is the horizontal positional bias, $\\Delta p$.\n    - The angle between the hypotenuse (the sensor's line-of-sight) and the adjacent side is the off-nadir angle, $\\theta$.\n\n    From the definition of the tangent function:\n    $$\\tan(\\theta) = \\frac{\\text{opposite}}{\\text{adjacent}} = \\frac{\\Delta p}{|N|}$$\n\n3.  **Calculate the Horizontal Bias**:\n    Rearranging the equation gives the classic formula for relief displacement:\n    $$\\Delta p = |N| \\tan(\\theta)$$\n    Substituting the given numerical values:\n    - $|N| = |30\\,\\text{m}| = 30\\,\\text{m}$\n    - $\\theta = 25^\\circ$\n\n    The calculation is:\n    $$\\Delta p = 30 \\times \\tan(25^\\circ)$$\n    $$\\Delta p \\approx 30 \\times 0.466307658 \\approx 13.98922974\\,\\text{m}$$\n\n4.  **Final Answer Formatting**:\n    Rounding the result to four significant figures as requested:\n    $$\\Delta p \\approx 13.99\\,\\text{m}$$",
            "answer": "$$\n\\boxed{13.99}\n$$"
        },
        {
            "introduction": "In rugged terrain, the simple line-of-sight from a sensor to a ground point may be blocked by intervening landforms, a phenomenon known as occlusion. This exercise challenges you to move beyond simple projection and implement a visibility test, a core component of sophisticated orthorectification algorithms. By building an algorithm that samples a ray path and compares its elevation to the DEM surface, you will gain a deeper, practical understanding of how 3D terrain geometry is modeled and its consequences for image generation .",
            "id": "3832012",
            "problem": "You are tasked with deriving and implementing, from first principles, a line-of-sight visibility test for orthorectification using a Digital Elevation Model (DEM). The goal is to determine, for each given scenario, whether the line segment (ray) from a sensor position to a ground point is unobstructed by terrain whose elevation is higher than the ray at any point along the path. Your implementation must operate on a gridded DEM and use bilinear interpolation of elevations from grid nodes.\n\nThe fundamental base for this problem is as follows:\n- The DEM is a height field defined over a rectangular grid of nodes with known spacing. The DEM provides terrain elevation at grid node positions, and terrain elevation between nodes must be estimated by bilinear interpolation using the four nearest grid nodes.\n- The sensor emits a straight-line path in three-dimensional Euclidean space to the ground point. The path can be parameterized as a segment with a scalar parameter that monotonically progresses from the sensor to the ground point.\n\nFrom these bases, derive an algorithm that determines whether the terrain is strictly higher than the path’s elevation at any point along the segment. The algorithm must be designed to be numerically robust and computationally efficient for gridded data.\n\nYour program must:\n- Accept no external input and use the provided test suite.\n- Model the DEM as a piecewise-bilinear function over a grid, with node locations at $x_i = x_0 + i p$ and $y_j = y_0 + j p$ for integer indices $i$ and $j$, where $p$ is the grid spacing.\n- Parameterize the line segment from the sensor position $\\mathbf{s} = (x_s, y_s, z_s)$ to the ground position $\\mathbf{g} = (x_g, y_g, z_g)$ using a scalar parameter $t \\in [0, 1]$. The three-dimensional position along the segment is $(x(t), y(t), z(t))$, and the path elevation at parameter $t$ is $z(t)$.\n- Use bilinear interpolation from the four nearest grid nodes to evaluate the DEM elevation at $(x(t), y(t))$ for each sample point along the segment.\n- Declare the path as occluded (not visible) if there exists any sample where the terrain elevation is strictly greater than the path elevation, that is, if $z_{\\mathrm{DEM}}(x(t), y(t)) > z(t)$. Equality does not count as higher elevation.\n- Use a uniform sampling step along the planimetric segment in the horizontal plane, with step size $s = p/2$. The number of samples must be $N = \\lceil D / s \\rceil + 1$, where $D$ is the Euclidean distance in the horizontal plane given by $D = \\sqrt{(x_g - x_s)^2 + (y_g - y_s)^2}$, and the samples must include both endpoints at $t = 0$ and $t = 1$.\n- Count the number of samples evaluated, and report it along with the visibility decision.\n\nPhysical and numerical units:\n- All coordinates and elevations are in meters. Use the unit meter, and ensure all numeric values are handled in meters.\n- Angles are not used; do not introduce angular units.\n\nTest suite:\nUse the following parameters for four scenarios. The DEM grid origin is $(x_0, y_0) = (0, 0)$ and the grid spacing is $p = 10$ meters. The DEM arrays are $5 \\times 5$ grids, where entry at row $j$ and column $i$ corresponds to the node at $(x_0 + i p, y_0 + j p)$.\n\n- Case $1$ (flat terrain, happy path):\n  - DEM:\n    - Row $0$: $[0, 0, 0, 0, 0]$\n    - Row $1$: $[0, 0, 0, 0, 0]$\n    - Row $2$: $[0, 0, 0, 0, 0]$\n    - Row $3$: $[0, 0, 0, 0, 0]$\n    - Row $4$: $[0, 0, 0, 0, 0]$\n  - Sensor $\\mathbf{s} = (0, 0, 100)$\n  - Ground $\\mathbf{g} = (40, 0, 0)$\n\n- Case $2$ (occluded by a hill between sensor and ground, significant case):\n  - DEM:\n    - Row $0$: $[0, 0, 120, 0, 0]$\n    - Row $1$: $[0, 0, 0, 0, 0]$\n    - Row $2$: $[0, 0, 0, 0, 0]$\n    - Row $3$: $[0, 0, 0, 0, 0]$\n    - Row $4$: $[0, 0, 0, 0, 0]$\n  - Sensor $\\mathbf{s} = (0, 0, 100)$\n  - Ground $\\mathbf{g} = (40, 0, 0)$\n\n- Case $3$ (boundary: grazing equality, should be visible because not strictly higher):\n  - DEM:\n    - Row $0$: $[0, 0, 50, 0, 0]$\n    - Row $1$: $[0, 0, 0, 0, 0]$\n    - Row $2$: $[0, 0, 0, 0, 0]$\n    - Row $3$: $[0, 0, 0, 0, 0]$\n    - Row $4$: $[0, 0, 0, 0, 0]$\n  - Sensor $\\mathbf{s} = (0, 0, 100)$\n  - Ground $\\mathbf{g} = (40, 0, 0)$\n\n- Case $4$ (diagonal path, near-grazing over a central ridge, edge case):\n  - DEM:\n    - Row $0$: $[0, 0, 0, 0, 0]$\n    - Row $1$: $[0, 5, 8, 5, 0]$\n    - Row $2$: $[0, 8, 24.9, 8, 0]$\n    - Row $3$: $[0, 5, 8, 5, 0]$\n    - Row $4$: $[0, 0, 0, 0, 0]$\n  - Sensor $\\mathbf{s} = (0, 0, 50)$\n  - Ground $\\mathbf{g} = (40, 40, 0)$\n\nFinal output format:\n- For each case, output a pair consisting of the visibility decision and the number of samples evaluated. Encode visibility as an integer $1$ if visible and $0$ if not visible, and the sample count as an integer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a two-element list in the form $[v, n]$. For example: $[[1,9],[0,9],[1,9],[1,13]]$.",
            "solution": "The problem requires the derivation and implementation of a line-of-sight visibility test between a sensor and a ground point, considering terrain obstructions defined by a Digital Elevation Model (DEM). The solution will be developed from first principles, establishing the mathematical models for the path and terrain, and then formulating a discrete algorithm to test for visibility.\n\n### 1. Mathematical Formulation\n\nThe analysis is performed in a $3$-dimensional Cartesian coordinate system. Let the sensor position be $\\mathbf{s} = (x_s, y_s, z_s)$ and the ground target position be $\\mathbf{g} = (x_g, y_g, z_g)$.\n\n#### 1.1. Line-of-Sight Path Parameterization\n\nThe line-of-sight (LOS) path is a straight line segment between $\\mathbf{s}$ and $\\mathbf{g}$. We can parameterize any point $\\mathbf{P}(t)$ on this segment using a scalar parameter $t \\in [0, 1]$:\n$$\n\\mathbf{P}(t) = (1-t)\\mathbf{s} + t\\mathbf{g}\n$$\nwhere $\\mathbf{P}(0) = \\mathbf{s}$ and $\\mathbf{P}(1) = \\mathbf{g}$.\nExpanding this into coordinate components gives the position $(x(t), y(t), z(t))$ along the path:\n$$\nx(t) = (1-t)x_s + t x_g = x_s + t(x_g - x_s)\n$$\n$$\ny(t) = (1-t)y_s + t y_g = y_s + t(y_g - y_s)\n$$\n$$\nz(t) = (1-t)z_s + t z_g = z_s + t(z_g - z_s)\n$$\nFor any given $t$, $z(t)$ represents the elevation of the LOS path.\n\n#### 1.2. Digital Elevation Model (DEM) Representation\n\nThe DEM is a discrete representation of the terrain height field. It is provided as a $2$D grid of elevation values. The grid nodes are located at coordinates $(x_i, y_j) = (x_0 + i p, y_0 + j p)$ for non-negative integer indices $i$ and $j$, where $(x_0, y_0)$ is the grid origin and $p$ is the uniform grid spacing. The elevation at node $(i, j)$ is given by the DEM array, denoted as $\\mathrm{DEM}[j, i]$. In this problem, $(x_0, y_0) = (0, 0)$.\n\n#### 1.3. Terrain Elevation via Bilinear Interpolation\n\nTo find the terrain elevation $z_{\\mathrm{DEM}}(x, y)$ at an arbitrary point $(x, y)$ that does not lie on a grid node, we use bilinear interpolation from the four nearest grid nodes.\nLet the point $(x, y)$ fall within the grid cell defined by the corner nodes $(x_i, y_j)$, $(x_{i+1}, y_j)$, $(x_i, y_{j+1})$, and $(x_{i+1}, y_{j+1})$. The corresponding grid indices are found by:\n$$\ni = \\lfloor x/p \\rfloor\n$$\n$$\nj = \\lfloor y/p \\rfloor\n$$\nThe elevations at these four corners are $z_{ij} = \\mathrm{DEM}[j, i]$, $z_{i+1,j} = \\mathrm{DEM}[j, i+1]$, $z_{i,j+1} = \\mathrm{DEM}[j+1, i]$, and $z_{i+1,j+1} = \\mathrm{DEM}[j+1, i+1]$.\n\nWe define normalized coordinates $(u, v)$ within the cell, where $u, v \\in [0, 1)$:\n$$\nu = \\frac{x - x_i}{p} = (x/p) - i\n$$\n$$\nv = \\frac{y - y_j}{p} = (y/p) - j\n$$\nFirst, we linearly interpolate along the $x$-direction at the bottom and top edges of the cell:\n$$\nz_{y_j}(x) = (1-u)z_{ij} + u z_{i+1,j}\n$$\n$$\nz_{y_{j+1}}(x) = (1-u)z_{i,j+1} + u z_{i+1,j+1}\n$$\nThen, we linearly interpolate these two values along the $y$-direction to find the final elevation:\n$$\nz_{\\mathrm{DEM}}(x, y) = (1-v)z_{y_j}(x) + v z_{y_{j+1}}(x)\n$$\nSubstituting the expressions yields the full bilinear interpolation formula:\n$$\nz_{\\mathrm{DEM}}(x, y) = (1-u)(1-v)z_{ij} + u(1-v)z_{i+1,j} + (1-u)vz_{i,j+1} + uvz_{i+1,j+1}\n$$\n\n### 2. Algorithmic Procedure\n\nThe continuous LOS path must be checked against the continuous terrain surface. Since an analytical solution is complex, we discretize the problem by sampling the path at a series of points and performing the check at each sample.\n\n#### 2.1. Sampling Strategy\n\nThe problem specifies a uniform sampling strategy in the horizontal ($XY$) plane.\n1.  Calculate the planimetric distance $D$ between the sensor and ground points:\n    $$\n    D = \\sqrt{(x_g - x_s)^2 + (y_g - y_s)^2}\n    $$\n2.  Determine the number of samples, $N$, based on the desired step size $s = p/2$:\n    $$\n    N = \\lceil D / s \\rceil + 1\n    $$\n    This ensures that the distance between consecutive sample points in the $XY$ plane is at most $s$. The sample set includes the start ($t=0$) and end ($t=1$) points of the path.\n3.  Generate $N$ equally spaced values of the parameter $t$ in the interval $[0, 1]$. Let the sample index be $k \\in \\{0, 1, \\dots, N-1\\}$. The parameter value for the $k$-th sample is:\n    $$\n    t_k = \\frac{k}{N-1}\n    $$\n    This method ensures that $t_0=0$ and $t_{N-1}=1$.\n\n#### 2.2. Visibility Check\n\nThe core of the algorithm is to iterate through each of the $N$ sample points and check for occlusion.\nFor each sample $k = 0, 1, \\dots, N-1$:\n1.  **Compute sample point coordinates**: Calculate the path parameter $t_k = k / (N-1)$. Use this to find the sample point's coordinates $(x_k, y_k, z_k) = (x(t_k), y(t_k), z(t_k))$.\n2.  **Compute terrain elevation**: Use the bilinear interpolation method described in Section 1.3 to calculate the terrain elevation $z_{\\mathrm{DEM},k} = z_{\\mathrm{DEM}}(x_k, y_k)$. Special care must be taken for points lying on the boundaries of the DEM grid to ensure grid indices remain valid. For a point on the maximum boundary (e.g., $x_k = x_{\\max}$), the lower-left corner index of the cell is adjusted, and the normalized coordinate is set to $1$.\n3.  **Perform occlusion test**: Compare the terrain elevation with the LOS path elevation. The path is occluded if, for any sample $k$, the following strict inequality holds:\n    $$\n    z_{\\mathrm{DEM},k} > z_k\n    $$\n    If this condition is met, the path is declared \"not visible\" ($0$), and the algorithm can in principle terminate. However, as per the problem's implicit requirement to report the total number of samples $N$, we complete the loop to maintain a consistent sample count.\n\nIf the loop completes without the occlusion condition ever being met, the path is declared \"visible\" ($1$). The final output for each scenario is a pair containing the visibility status ($1$ or $0$) and the total number of samples evaluated, $N$.\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the line-of-sight visibility tests for all scenarios.\n    \"\"\"\n    \n    # Common parameters\n    p = 10.0  # Grid spacing in meters\n    x0, y0 = 0.0, 0.0 # Grid origin\n\n    test_cases = [\n        {\n            \"dem\": np.array([\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0]\n            ], dtype=float),\n            \"s\": (0.0, 0.0, 100.0),\n            \"g\": (40.0, 0.0, 0.0)\n        },\n        {\n            \"dem\": np.array([\n                [0, 0, 120, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0]\n            ], dtype=float),\n            \"s\": (0.0, 0.0, 100.0),\n            \"g\": (40.0, 0.0, 0.0)\n        },\n        {\n            \"dem\": np.array([\n                [0, 0, 50, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0]\n            ], dtype=float),\n            \"s\": (0.0, 0.0, 100.0),\n            \"g\": (40.0, 0.0, 0.0)\n        },\n        {\n            \"dem\": np.array([\n                [0, 0, 0, 0, 0],\n                [0, 5, 8, 5, 0],\n                [0, 8, 24.9, 8, 0],\n                [0, 5, 8, 5, 0],\n                [0, 0, 0, 0, 0]\n            ], dtype=float),\n            \"s\": (0.0, 0.0, 50.0),\n            \"g\": (40.0, 40.0, 0.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_visibility(case[\"dem\"], p, case[\"s\"], case[\"g\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef check_visibility(dem, p, s, g):\n    \"\"\"\n    Checks line-of-sight visibility between a sensor and a ground point.\n\n    Args:\n        dem (np.ndarray): The Digital Elevation Model grid.\n        p (float): The grid spacing.\n        s (tuple): The sensor position (x_s, y_s, z_s).\n        g (tuple): The ground position (x_g, y_g, z_g).\n\n    Returns:\n        list: A list containing the visibility status [1 for visible, 0 for not visible]\n              and the number of samples evaluated.\n    \"\"\"\n    xs, ys, zs = s\n    xg, yg, zg = g\n\n    # 1. Calculate the number of samples N\n    dx = xg - xs\n    dy = yg - ys\n    D = np.sqrt(dx**2 + dy**2)\n    s_step = p / 2.0\n    \n    if D == 0:\n        N = 1\n    else:\n        N = int(np.ceil(D / s_step)) + 1\n    \n    is_visible = 1\n    \n    # Handle the case of a single sample to avoid division by zero\n    if N <= 1:\n        num_intervals = 1.0\n    else:\n        num_intervals = float(N - 1)\n\n    # 2. Iterate through N samples\n    for i in range(N):\n        t = i / num_intervals\n        \n        # 3. Calculate path coordinates for sample i\n        x_path = xs + t * dx\n        y_path = ys + t * dy\n        z_path = zs + t * (zg - zs)\n        \n        # 4. Calculate DEM elevation at (x_path, y_path) using bilinear interpolation\n        j_max, i_max = dem.shape[0] - 1, dem.shape[1] - 1\n        \n        xf = x_path / p\n        yf = y_path / p\n        \n        i1 = int(np.floor(xf))\n        j1 = int(np.floor(yf))\n        \n        u = xf - i1\n        v = yf - j1\n        \n        # Handle points on the far boundaries of the DEM grid\n        if i1 >= i_max:\n            i1 = i_max - 1\n            u = 1.0\n        if j1 >= j_max:\n            j1 = j_max - 1\n            v = 1.0\n            \n        i2 = i1 + 1\n        j2 = j1 + 1\n\n        # Elevations of the four corner nodes of the cell\n        z11 = dem[j1, i1]\n        z21 = dem[j1, i2]\n        z12 = dem[j2, i1]\n        z22 = dem[j2, i2]\n        \n        # Perform bilinear interpolation\n        z_interp1 = (1.0 - u) * z11 + u * z21\n        z_interp2 = (1.0 - u) * z12 + u * z22\n        z_dem = (1.0 - v) * z_interp1 + v * z_interp2\n        \n        # 5. Check for occlusion\n        if z_dem > z_path:\n            is_visible = 0\n            # According to the problem formulation, we report the total\n            # number of samples (N), so we don't break the loop.\n            # break\n            \n    return [is_visible, N]\n\nsolve()\n```",
            "answer": "[[1,9],[0,9],[1,9],[1,13]]"
        }
    ]
}