{
    "hands_on_practices": [
        {
            "introduction": "In geodetic applications, distinguishing between ellipsoidal height measured by GNSS and the physically meaningful orthometric height is crucial. This conversion relies on a geoid model, meaning our final vertical accuracy depends on the quality of two separate inputs. This first practice  provides a foundational exercise in error propagation, demonstrating how to combine the standard uncertainties of an ellipsoidal height measurement and a geoid undulation value to rigorously determine the confidence interval for the resulting orthometric height.",
            "id": "3816439",
            "problem": "A drone-based mapping campaign requires accurate vertical georeferencing of a Ground Control Point (GCP) to orthorectify high-resolution imagery used in environmental modeling of floodplains. The GCP’s ellipsoidal height is measured with Real-Time Kinematic Global Navigation Satellite System (RTK GNSS), giving a mean ellipsoidal height $h = 124.783$ meters and a standard uncertainty $\\sigma_{h} = 0.037$ meters. The local hybrid geoid model provides a geoid undulation $N = 35.812$ meters with a standard uncertainty $\\sigma_{N} = 0.045$ meters. Assume both error sources are independent and that their errors are modeled as zero-mean Gaussian random variables. The orthometric height is defined by $H = h - N$.\n\nStarting from the definition of orthometric height and the fundamental properties of variance and covariance under linear transformations of random variables, derive the standard uncertainty $\\sigma_{H}$ of the orthometric height for this GCP. Then, using a two-sided confidence level of $0.95$ for a Gaussian quantity, compute the half-width of the corresponding vertical confidence interval. Express the final half-width in meters and round your answer to four significant figures.",
            "solution": "The objective is to compute the uncertainty of the orthometric height and then the half-width of a two-sided confidence interval at confidence level $0.95$. The orthometric height is defined by the geometric relation\n$$\nH = h - N,\n$$\nwhere $h$ is the ellipsoidal height and $N$ is the geoid undulation.\n\nWe model $h$ and $N$ as random variables with means given by the reported values and with standard uncertainties $\\sigma_{h}$ and $\\sigma_{N}$, respectively, representing the standard deviations of their Gaussian error distributions. The orthometric height $H$ is then a linear combination of these random variables. For any linear combination of random variables, the variance is governed by the well-tested rule\n$$\n\\operatorname{var}(aX + bY) = a^{2}\\operatorname{var}(X) + b^{2}\\operatorname{var}(Y) + 2ab\\,\\operatorname{cov}(X,Y),\n$$\nwhich follows from the definition of variance and covariance and the bilinearity of covariance. Applying this to $H = 1\\cdot h + (-1)\\cdot N$ yields\n$$\n\\operatorname{var}(H) = \\operatorname{var}(h) + \\operatorname{var}(N) - 2\\,\\operatorname{cov}(h, N).\n$$\nUnder the stated assumption of independence between the GNSS height measurement and the geoid model undulation, we have\n$$\n\\operatorname{cov}(h, N) = 0.\n$$\nTherefore,\n$$\n\\operatorname{var}(H) = \\sigma_{h}^{2} + \\sigma_{N}^{2},\n$$\nand the standard uncertainty of $H$ is\n$$\n\\sigma_{H} = \\sqrt{\\sigma_{h}^{2} + \\sigma_{N}^{2}}.\n$$\n\nNext, to compute the half-width of the two-sided confidence interval at confidence level $0.95$ for a Gaussian-distributed quantity with known standard deviation, we use the quantile of the standard normal distribution. Let $Z$ be a standard normal random variable. The two-sided confidence interval at level $0.95$ has half-width\n$$\nw = z_{0.975}\\,\\sigma_{H},\n$$\nwhere $z_{0.975}$ satisfies $\\mathbb{P}(|Z| \\le z_{0.975}) = 0.95$, and numerically $z_{0.975} \\approx 1.95996398454$.\n\nWe now substitute the given numerical values. First compute $\\sigma_{H}$:\n$$\n\\sigma_{H} = \\sqrt{(0.037)^{2} + (0.045)^{2}} = \\sqrt{0.001369 + 0.002025} = \\sqrt{0.003394}.\n$$\nEvaluating the square root,\n$$\n\\sigma_{H} \\approx 0.058258.\n$$\nThen the half-width of the two-sided $0.95$ confidence interval is\n$$\nw = z_{0.975}\\,\\sigma_{H} \\approx 1.95996398454 \\times 0.058258 \\approx 0.114184.\n$$\n\nRounding to four significant figures as required, the half-width is\n$$\n0.1142.\n$$\n\nThis half-width could be used to express the vertical confidence interval as $H \\pm w$, with $H = h - N = 124.783 - 35.812 = 88.971$ meters, but the requested final quantity is the half-width $w$ alone.",
            "answer": "$$\\boxed{0.1142}$$"
        },
        {
            "introduction": "Understanding error propagation is not limited to a single dimension. In remote sensing, errors often cascade through processing chains, and a vertical uncertainty in an input dataset can manifest as a planimetric (horizontal) error in the final product. This exercise  explores this critical link by tasking you to derive how a height error in a Digital Elevation Model (DEM) translates into planimetric displacement during the orthorectification of off-nadir satellite imagery, a key skill for assessing the quality of ortho-products.",
            "id": "3816437",
            "problem": "A satellite imaging system performs georeferencing by intersecting image rays with a Digital Elevation Model (DEM). The exterior orientation is estimated from Ground Control Points (GCPs), yielding the position of the imaging perspective center and the look direction for each pixel. Consider a single pixel whose ray originates at the perspective center at position $\\mathbf{C} = (0, 0, H)$ in an Earth-fixed Cartesian coordinate system whose $Z$-axis points upward. The pixel’s unit look direction is $\\mathbf{u} = (u_{x}, u_{y}, u_{z})$, where off-nadir imaging implies $u_{z} < 0$. The ground intersection used in orthorectification is the point where the ray $\\mathbf{r}(s) = \\mathbf{C} + s \\mathbf{u}$ meets the horizontal plane at elevation $Z$.\n\nStarting from central projection geometry and three-dimensional line–plane intersection, derive the Jacobian of the image-to-ground mapping with respect to elevation, that is, compute the partial derivatives $\\frac{\\partial X}{\\partial Z}$ and $\\frac{\\partial Y}{\\partial Z}$, where $(X, Y)$ are the planimetric coordinates of the intersection point. Then specialize to a common off-nadir parameterization in terms of the off-nadir angle $\\theta$ from the vertical and the azimuth $\\alpha$ of the look direction, where\n$$\n\\mathbf{u} = \\bigl(\\sin\\theta \\cos\\alpha,\\ \\sin\\theta \\sin\\alpha,\\ -\\cos\\theta\\bigr).\n$$\nUse these to express the planimetric error caused by a small DEM height error $\\Delta Z$ as the magnitude of the horizontal error vector defined by $\\left(\\frac{\\partial X}{\\partial Z}\\Delta Z,\\ \\frac{\\partial Y}{\\partial Z}\\Delta Z\\right)$.\n\nFinally, evaluate the magnitude of this planimetric error for $H = 700{,}000$ $\\mathrm{m}$, $\\theta = 34^\\circ$, $\\alpha = 112^\\circ$, and $\\Delta Z = 12$ $\\mathrm{m}$. Express your final numerical answer in meters and round your result to four significant figures. Angles must be treated in degrees.",
            "solution": "The problem asks for the derivation of the planimetric error caused by a height error in a Digital Elevation Model (DEM) and its numerical evaluation for a specific imaging geometry. We begin by formalizing the intersection of the imaging ray with the ground plane.\n\nThe position of the satellite's perspective center is given as $\\mathbf{C} = (0, 0, H)$. The unit look direction vector for a given pixel is $\\mathbf{u} = (u_x, u_y, u_z)$. The ray originating from the perspective center along this direction is described by the parametric vector equation $\\mathbf{r}(s) = \\mathbf{C} + s\\mathbf{u}$, where $s$ is the scalar distance along the ray. In component form, the coordinates of a point on the ray are:\n$$\nX(s) = C_x + s u_x = 0 + s u_x = s u_x\n$$\n$$\nY(s) = C_y + s u_y = 0 + s u_y = s u_y\n$$\n$$\nZ(s) = C_z + s u_z = H + s u_z\n$$\nThe ground is modeled as a horizontal plane at a constant elevation $Z$. The intersection point of the ray with this plane is found by setting the $z$-component of the ray equation equal to this elevation:\n$$\nZ = H + s u_z\n$$\nWe solve for the parameter $s$:\n$$\ns u_z = Z - H\n$$\n$$\ns = \\frac{Z - H}{u_z}\n$$\nThe problem states that imaging is off-nadir, with $u_z < 0$. The satellite altitude $H$ is greater than the ground elevation $Z$, so $Z - H < 0$. This ensures that $s > 0$, which is physically correct as the intersection point is in front of the perspective center.\n\nSubstituting this expression for $s$ into the equations for the planimetric coordinates $(X, Y)$ yields the image-to-ground mapping:\n$$\nX(Z) = u_x s = u_x \\left( \\frac{Z - H}{u_z} \\right) = \\frac{u_x}{u_z}(Z - H)\n$$\n$$\nY(Z) = u_y s = u_y \\left( \\frac{Z - H}{u_z} \\right) = \\frac{u_y}{u_z}(Z - H)\n$$\nThe problem requires the Jacobian of this mapping with respect to the elevation $Z$, which consists of the partial derivatives $\\frac{\\partial X}{\\partial Z}$ and $\\frac{\\partial Y}{\\partial Z}$. For a given imaging ray, the components of the look direction vector $(u_x, u_y, u_z)$ and the satellite altitude $H$ are constants. Therefore, we differentiate $X(Z)$ and $Y(Z)$ with respect to $Z$:\n$$\n\\frac{\\partial X}{\\partial Z} = \\frac{\\partial}{\\partial Z} \\left[ \\frac{u_x}{u_z}(Z - H) \\right] = \\frac{u_x}{u_z}\n$$\n$$\n\\frac{\\partial Y}{\\partial Z} = \\frac{\\partial}{\\partial Z} \\left[ \\frac{u_y}{u_z}(Z - H) \\right] = \\frac{u_y}{u_z}\n$$\nNext, we specialize these derivatives using the given parameterization of the look direction vector $\\mathbf{u}$ in terms of the off-nadir angle $\\theta$ and the azimuth angle $\\alpha$:\n$$\n\\mathbf{u} = \\bigl(\\sin\\theta \\cos\\alpha,\\ \\sin\\theta \\sin\\alpha,\\ -\\cos\\theta\\bigr)\n$$\nThe components are $u_x = \\sin\\theta \\cos\\alpha$, $u_y = \\sin\\theta \\sin\\alpha$, and $u_z = -\\cos\\theta$. Substituting these into the partial derivatives:\n$$\n\\frac{\\partial X}{\\partial Z} = \\frac{\\sin\\theta \\cos\\alpha}{-\\cos\\theta} = -\\tan\\theta \\cos\\alpha\n$$\n$$\n\\frac{\\partial Y}{\\partial Z} = \\frac{\\sin\\theta \\sin\\alpha}{-\\cos\\theta} = -\\tan\\theta \\sin\\alpha\n$$\nA small error $\\Delta Z$ in the DEM elevation results in a planimetric error vector. Using a first-order Taylor approximation, the components of this error vector are $\\Delta X \\approx \\frac{\\partial X}{\\partial Z} \\Delta Z$ and $\\Delta Y \\approx \\frac{\\partial Y}{\\partial Z} \\Delta Z$. The problem defines the horizontal error vector as $\\left(\\frac{\\partial X}{\\partial Z}\\Delta Z,\\ \\frac{\\partial Y}{\\partial Z}\\Delta Z\\right)$. The magnitude of this vector, $\\|\\Delta \\mathbf{p}\\|$, is:\n$$\n\\|\\Delta \\mathbf{p}\\| = \\sqrt{\\left(\\frac{\\partial X}{\\partial Z}\\Delta Z\\right)^2 + \\left(\\frac{\\partial Y}{\\partial Z}\\Delta Z\\right)^2} = |\\Delta Z| \\sqrt{\\left(\\frac{\\partial X}{\\partial Z}\\right)^2 + \\left(\\frac{\\partial Y}{\\partial Z}\\right)^2}\n$$\nWe compute the sum of the squares of the partial derivatives:\n$$\n\\left(\\frac{\\partial X}{\\partial Z}\\right)^2 + \\left(\\frac{\\partial Y}{\\partial Z}\\right)^2 = (-\\tan\\theta \\cos\\alpha)^2 + (-\\tan\\theta \\sin\\alpha)^2\n$$\n$$\n= \\tan^2\\theta \\cos^2\\alpha + \\tan^2\\theta \\sin^2\\alpha = \\tan^2\\theta (\\cos^2\\alpha + \\sin^2\\alpha) = \\tan^2\\theta\n$$\nSubstituting this result back into the expression for the error magnitude gives a remarkably simple formula:\n$$\n\\|\\Delta \\mathbf{p}\\| = |\\Delta Z| \\sqrt{\\tan^2\\theta} = |\\Delta Z| |\\tan\\theta|\n$$\nFor typical remote sensing scenarios, the off-nadir angle $\\theta$ is between $0^{\\circ}$ and $90^{\\circ}$, so $\\tan\\theta \\ge 0$. Assuming the given error $\\Delta Z$ is a magnitude, we have:\n$$\n\\|\\Delta \\mathbf{p}\\| = \\Delta Z \\tan\\theta\n$$\nThis result shows that the magnitude of the planimetric error is independent of the satellite altitude $H$ and the look direction's azimuth $\\alpha$. It depends only on the magnitude of the height error and the off-nadir angle.\n\nFinally, we evaluate this expression using the provided numerical values: $\\Delta Z = 12$ m and $\\theta = 34^{\\circ}$. The values $H = 700{,}000$ m and $\\alpha = 112^{\\circ}$ are not needed for this final calculation.\n$$\n\\|\\Delta \\mathbf{p}\\| = 12 \\cdot \\tan(34^{\\circ})\n$$\nUsing a calculator, $\\tan(34^{\\circ}) \\approx 0.6745085$.\n$$\n\\|\\Delta \\mathbf{p}\\| \\approx 12 \\times 0.6745085 \\approx 8.094102~\\text{m}\n$$\nRounding the result to four significant figures as requested, we obtain the final answer for the planimetric error magnitude.\n$$\n\\|\\Delta \\mathbf{p}\\| \\approx 8.094~\\text{m}\n$$",
            "answer": "$$\n\\boxed{8.094}\n$$"
        },
        {
            "introduction": "Effective georeferencing is not just about correcting errors, but also about strategic planning to minimize them from the outset. When relying on Ground Control Points (GCPs), their geometric arrangement is paramount to the stability of the solution. This final, advanced practice  moves from analysis to design, challenging you to implement a D-optimal design strategy to select the best subset of GCPs, balancing the need for geometric strength against practical field constraints such as accessibility and feature visibility.",
            "id": "3816417",
            "problem": "You are tasked with designing a program that selects Ground Control Points (GCPs) to georeference an aerial image under a D-optimal design criterion while explicitly modeling trade-offs with field accessibility and feature visibility. The goal is to choose a subset of candidate GCPs that maximizes the D-optimal objective, which is the determinant of the Fisher Information Matrix (FIM), adjusted by penalty terms for accessibility difficulty and low-visibility features.\n\nThe fundamental base for this problem consists of the following well-tested principles:\n- A Ground Control Point (GCP) is a feature with known coordinates used to tie image coordinates to map coordinates in georeferencing.\n- Under a linear model with independent, zero-mean Gaussian noise, the Fisher Information Matrix (FIM) for the model parameters is derived from the design matrix built from the observation equations.\n- An affine transformation between image coordinates and map coordinates can be expressed as a linear model with unknown parameter vector and known regressors. Each GCP contributes two independent observations (for the two coordinate axes).\n- D-optimal design chooses a subset that maximizes the determinant of the FIM, which corresponds to minimizing the volume of the confidence ellipsoid for the parameters.\n\nYou must implement the following model:\n- The image-to-map transformation is affine. Let $(u,v)$ be the image coordinates in pixels, and $(x,y)$ be the map coordinates in meters. The unknown parameter vector contains six coefficients: $(a_0,a_1,a_2,b_0,b_1,b_2)$ for the affine mapping $x=a_0+a_1 u+a_2 v$ and $y=b_0+b_1 u+b_2 v$.\n- Each selected GCP contributes two observation equations, one for $x$ and one for $y$, both linear in the parameters, with independent Gaussian noise of standard deviation $\\sigma$ measured in pixels (assume isotropic, identical for both axes).\n- The FIM is constructed from the linear observation model under the Gaussian noise assumption. The D-optimal criterion uses $\\log\\det(\\text{FIM})$ to avoid numerical overflow in computation.\n\nThe overall objective for a selected subset $S$ of GCP indices is:\n- Maximize $J(S)$ defined by\n  $$J(S) = \\log\\det\\left(\\text{FIM}(S)\\right) - \\lambda_a \\sum_{i \\in S} a_i - \\lambda_v \\left(1 - \\frac{1}{|S|} \\sum_{i \\in S} s_i\\right),$$\n  where $a_i$ is the accessibility cost (in minutes) for GCP $i$, $s_i$ is the visibility score for GCP $i$ in $[0,1]$, and $\\lambda_a,\\lambda_v$ are nonnegative trade-off weights. If $\\det(\\text{FIM}(S)) \\le 0$ or the matrix is rank-deficient, set $J(S) = -\\infty$.\n\nYour program must:\n- Enumerate all combinations of $k$ GCPs from $n$ candidates for each test case and select the subset $S$ that maximizes $J(S)$.\n- Use the affine model with a $6$-parameter vector and construct the design matrix properly from the $(u,v)$ of the selected GCPs.\n- Use stable computation of $\\log\\det$ for symmetric positive semidefinite matrices.\n\nUnits and numerical requirements:\n- Image coordinates $(u,v)$ are given in pixels. Noise standard deviation $\\sigma$ is in pixels. Accessibility costs $a_i$ are in minutes. Visibility scores $s_i$ are unitless in $[0,1]$. The final objective $J(S)$ is unitless.\n- Angles are not used in this problem.\n- All floating-point results must be reported as decimal numbers.\n\nTest suite:\n- Test Case $1$ (happy path): $n=8$, $k=4$, $\\sigma=1.5$, $\\lambda_a=0.02$, $\\lambda_v=0.5$.\n  - Candidate image coordinates $(u,v)$ in pixels: index $0:(20,30)$, $1:(250,180)$, $2:(400,50)$, $3:(600,300)$, $4:(50,450)$, $5:(700,50)$, $6:(350,400)$, $7:(650,450)$.\n  - Accessibility costs $a_i$ in minutes: $[5,30,20,25,10,35,15,40]$.\n  - Visibility scores $s_i$ unitless: $[0.7,0.9,0.6,0.95,0.8,0.5,0.85,0.7]$.\n- Test Case $2$ (boundary minimal design, collinearity risk): $n=5$, $k=3$, $\\sigma=1.0$, $\\lambda_a=0.01$, $\\lambda_v=0.1$.\n  - Candidate image coordinates $(u,v)$: index $0:(0,0)$, $1:(100,0)$, $2:(200,0)$, $3:(0,200)$, $4:(200,200)$.\n  - Accessibility costs $a_i$ in minutes: $[1,1,1,2,2]$.\n  - Visibility scores $s_i$: $[0.9,0.9,0.9,0.6,0.6]$.\n- Test Case $3$ (heavy accessibility penalty): identical to Test Case $1$ except $\\lambda_a=0.2$, $\\lambda_v=0.0$, $\\sigma=1.5$, $k=4$.\n- Test Case $4$ (heavy visibility penalty): identical to Test Case $1$ except $\\lambda_a=0.0$, $\\lambda_v=2.0$, $\\sigma=1.5$, $k=4$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result should be encoded as a pair consisting of the selected indices (in ascending order) and the maximized objective rounded to six decimal places, in the exact format\n  $$[([i_1,i_2,\\dots,i_k],J_1),([j_1,j_2,\\dots,j_k],J_2),([p_1,p_2,\\dots,p_k],J_3),([q_1,q_2,\\dots,q_k],J_4)].$$",
            "solution": "The problem requires designing a program to select an optimal subset of $k$ Ground Control Points (GCPs) from a set of $n$ candidates for georeferencing an aerial image. The selection criterion is to maximize an objective function $J(S)$ that balances D-optimality with penalties for field accessibility and poor feature visibility.\n\nThe core of the problem lies in formulating the Fisher Information Matrix (FIM) for the parameters of an affine transformation and then evaluating the objective function for all possible subsets of GCPs.\n\nThe affine transformation from image coordinates $(u, v)$ to map coordinates $(x, y)$ is given by:\n$$x = a_0 + a_1 u + a_2 v$$\n$$y = b_0 + b_1 u + b_2 v$$\nThis can be expressed as a linear model. The unknown parameters form a vector $\\boldsymbol{\\theta} = [a_0, a_1, a_2, b_0, b_1, b_2]^T$. For a set $S$ of $k$ selected GCPs, indexed by $i \\in S$, we have $2k$ observation equations. These equations can be written in matrix form as $\\mathbf{Y} = X(S)\\boldsymbol{\\theta} + \\boldsymbol{\\epsilon}$, where $\\mathbf{Y}$ is the vector of true map coordinates, $X(S)$ is the design matrix, and $\\boldsymbol{\\epsilon}$ is a vector of zero-mean Gaussian noise terms. The problem states the noise has a standard deviation of $\\sigma$ for each observation.\n\nThe design matrix $X(S)$ for a subset $S = \\{i_1, \\dots, i_k\\}$ is a $2k \\times 6$ matrix:\n$$\nX(S) = \\begin{pmatrix}\n1 & u_{i_1} & v_{i_1} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & u_{i_1} & v_{i_1} \\\\\n1 & u_{i_2} & v_{i_2} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & u_{i_2} & v_{i_2} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & u_{i_k} & v_{i_k} & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & u_{i_k} & v_{i_k}\n\\end{pmatrix}\n$$\nUnder the assumption of independent and identically distributed Gaussian noise with variance $\\sigma^2$ for each observation, the Fisher Information Matrix (FIM) is given by:\n$$ \\text{FIM}(S) = \\frac{1}{\\sigma^2} X(S)^T X(S) $$\nThe matrix $X(S)^T X(S)$ has a convenient block-diagonal structure. Let us define a $k \\times 3$ matrix $A_S$ whose rows consist of the regressors for each GCP in the subset $S$:\n$$ A_S = \\begin{pmatrix} 1 & u_{i_1} & v_{i_1} \\\\ 1 & u_{i_2} & v_{i_2} \\\\ \\vdots & \\vdots & \\vdots \\\\ 1 & u_{i_k} & v_{i_k} \\end{pmatrix} $$\nThen, $X(S)^T X(S)$ can be written as:\n$$ X(S)^T X(S) = \\begin{pmatrix} A_S^T A_S & \\mathbf{0}_{3 \\times 3} \\\\ \\mathbf{0}_{3 \\times 3} & A_S^T A_S \\end{pmatrix} $$\nwhere $\\mathbf{0}_{3 \\times 3}$ is the $3 \\times 3$ zero matrix.\n\nThe D-optimal design criterion aims to maximize the determinant of the FIM. For computational stability, we work with the logarithm of the determinant:\n$$ \\det(\\text{FIM}(S)) = \\det\\left(\\frac{1}{\\sigma^2} X(S)^T X(S)\\right) = \\left(\\frac{1}{\\sigma^2}\\right)^6 \\det(X(S)^T X(S)) $$\nUsing the property of determinants of block-diagonal matrices:\n$$ \\det(X(S)^T X(S)) = \\det(A_S^T A_S) \\cdot \\det(A_S^T A_S) = (\\det(A_S^T A_S))^2 $$\nTherefore, the log-determinant of the FIM is:\n$$ \\log\\det(\\text{FIM}(S)) = \\log\\left( \\left(\\frac{1}{\\sigma^2}\\right)^6 (\\det(A_S^T A_S))^2 \\right) = -12\\log(\\sigma) + 2\\log(\\det(A_S^T A_S)) $$\nThe matrix $A_S^T A_S$ is a $3 \\times 3$ symmetric positive semi-definite matrix. Its determinant will be positive if and only if its rank is $3$, which requires that the columns of $A_S$ are linearly independent. This corresponds to the geometric condition that the $k$ points $(u_i,v_i)$ for $i \\in S$ are not collinear. A minimum of $k=3$ non-collinear points is required. If the points are collinear, $\\det(A_S^T A_S)=0$ and $\\log\\det(\\text{FIM}(S))$ is undefined (or $-\\infty$), as specified in the problem.\n\nThe full objective function to be maximized is:\n$$ J(S) = \\log\\det(\\text{FIM}(S)) - \\lambda_a \\sum_{i \\in S} a_i - \\lambda_v \\left(1 - \\frac{1}{|S|} \\sum_{i \\in S} s_i\\right) $$\nwhere $S$ is the selected subset of indices, $a_i$ is the accessibility cost, $s_i$ is the visibility score, and $\\lambda_a, \\lambda_v$ are penalty weights. $|S|$ is the size of the subset, which is fixed to $k$ in each test case.\n\nThe algorithm to find the optimal subset $S^*$ is as follows:\n1.  For each test case, with given parameters $n$, $k$, $\\sigma$, $\\lambda_a$, $\\lambda_v$ and GCP data.\n2.  Generate all possible combinations of $k$ indices from the set $\\{0, 1, ..., n-1\\}$. There are $\\binom{n}{k}$ such combinations.\n3.  For each combination (subset $S$):\n    a. Construct the matrix $A_S$ using the image coordinates of the GCPs in $S$.\n    b. Compute the matrix product $M = A_S^T A_S$.\n    c. Calculate the determinant of $M$. A numerically stable way is to use a function like `numpy.linalg.slogdet`, which returns the sign and the natural logarithm of the absolute value of the determinant.\n    d. If the determinant is not positive (i.e., $\\det(M) \\le 0$), the FIM is singular. We assign $J(S) = -\\infty$ and discard this subset.\n    e. If the determinant is positive, calculate the objective function $J(S)$ using the derived formula.\n4.  Keep track of the subset $S$ that yields the maximum value of $J(S)$ found so far.\n5.  After evaluating all combinations, the subset with the highest score is the optimal solution for that test case. The final result consists of the sorted indices of the optimal subset and the corresponding maximized objective value, rounded as required.\nThis exhaustive search guarantees finding the global maximum of $J(S)$ over the discrete search space.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the GCP selection problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"n\": 8, \"k\": 4, \"sigma\": 1.5, \"lambda_a\": 0.02, \"lambda_v\": 0.5,\n            \"coords\": np.array([(20,30), (250,180), (400,50), (600,300), (50,450), (700,50), (350,400), (650,450)]),\n            \"costs\": np.array([5,30,20,25,10,35,15,40]),\n            \"scores\": np.array([0.7,0.9,0.6,0.95,0.8,0.5,0.85,0.7]),\n        },\n        {\n            \"n\": 5, \"k\": 3, \"sigma\": 1.0, \"lambda_a\": 0.01, \"lambda_v\": 0.1,\n            \"coords\": np.array([(0,0), (100,0), (200,0), (0,200), (200,200)]),\n            \"costs\": np.array([1,1,1,2,2]),\n            \"scores\": np.array([0.9,0.9,0.9,0.6,0.6]),\n        },\n        {\n            \"n\": 8, \"k\": 4, \"sigma\": 1.5, \"lambda_a\": 0.2, \"lambda_v\": 0.0,\n            \"coords\": np.array([(20,30), (250,180), (400,50), (600,300), (50,450), (700,50), (350,400), (650,450)]),\n            \"costs\": np.array([5,30,20,25,10,35,15,40]),\n            \"scores\": np.array([0.7,0.9,0.6,0.95,0.8,0.5,0.85,0.7]),\n        },\n        {\n            \"n\": 8, \"k\": 4, \"sigma\": 1.5, \"lambda_a\": 0.0, \"lambda_v\": 2.0,\n            \"coords\": np.array([(20,30), (250,180), (400,50), (600,300), (50,450), (700,50), (350,400), (650,450)]),\n            \"costs\": np.array([5,30,20,25,10,35,15,40]),\n            \"scores\": np.array([0.7,0.9,0.6,0.95,0.8,0.5,0.85,0.7]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        k = case[\"k\"]\n        sigma = case[\"sigma\"]\n        lambda_a = case[\"lambda_a\"]\n        lambda_v = case[\"lambda_v\"]\n        coords = case[\"coords\"]\n        costs = case[\"costs\"]\n        scores = case[\"scores\"]\n\n        best_subset_indices = None\n        max_objective = -np.inf\n\n        candidate_indices = range(n)\n        for subset_indices in combinations(candidate_indices, k):\n            # Form the A_S matrix for the current subset\n            A_S = np.ones((k, 3))\n            A_S[:, 1:] = coords[list(subset_indices)]\n            \n            # Compute A_S^T * A_S\n            M = A_S.T @ A_S\n            \n            # Calculate the log determinant of M\n            sign, logdet_M = np.linalg.slogdet(M)\n            \n            # If determinant is not positive, the FIM is singular\n            if sign = 0:\n                current_objective = -np.inf\n            else:\n                # Calculate log determinant of FIM\n                log_det_fim = -12.0 * np.log(sigma) + 2.0 * logdet_M\n                \n                # Extract costs and scores for the current subset\n                subset_costs = costs[list(subset_indices)]\n                subset_scores = scores[list(subset_indices)]\n                \n                # Calculate penalty terms\n                penalty_a = lambda_a * np.sum(subset_costs)\n                penalty_v = lambda_v * (1.0 - np.mean(subset_scores))\n                \n                # Calculate the final objective function J(S)\n                current_objective = log_det_fim - penalty_a - penalty_v\n            \n            # Update best subset if current one is better\n            if current_objective > max_objective:\n                max_objective = current_objective\n                best_subset_indices = list(subset_indices)\n        \n        # Append the result for this test case\n        # The indices must be sorted as per convention. combinations() produces sorted tuples.\n        if best_subset_indices:\n            result_tuple = (best_subset_indices, round(max_objective, 6))\n            results.append(result_tuple)\n\n    # Format the results into the required string representation\n    # str() on a tuple gives '(...)' and on a list gives '[...]'\n    # which matches the required final format '([i1, ...], J)'\n    result_strings = [str(res) for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\n# This function is not called in the final output, but is required for the code to be runnable.\n# The user-facing output will be generated by the solve() function.\nif __name__ == '__main__':\n    solve()\n```",
            "answer": "[([0, 4, 5, 7], 60.187313),([0, 3, 4], 47.933252),([0, 2, 4, 6], 56.467888),([1, 3, 4, 6], 67.57564)]"
        }
    ]
}