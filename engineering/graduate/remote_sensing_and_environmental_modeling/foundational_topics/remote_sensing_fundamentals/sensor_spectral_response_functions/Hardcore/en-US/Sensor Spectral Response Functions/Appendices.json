{
    "hands_on_practices": [
        {
            "introduction": "In practice, it is often convenient to represent the complex measurement across a spectral band with the radiance value at a single, representative wavelength. This exercise  challenges you to explore the validity of this approximation by deriving the bias between the true band-averaged radiance, $\\overline{L}$, and the radiance at the SRF's peak, $L(\\lambda_{\\mathrm{peak}})$. By using a Taylor series expansion, you will uncover the fundamental relationship between this bias, the asymmetry of the sensor's SRF, and the spectral variation of the incoming signal, providing a crucial insight into sources of error in radiometric analysis.",
            "id": "3845864",
            "problem": "A passive imaging spectroradiometer observes a radiance field with spectral radiance $L(\\lambda)$ over a finite band $\\lambda \\in [\\lambda_{a}, \\lambda_{b}]$. The instrument has a nonnegative, continuous spectral response function (SRF), denoted $S(\\lambda)$, with finite, nonzero band integral. The band-averaged at-sensor radiance is defined by\n$$\n\\overline{L} \\equiv \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,L(\\lambda)\\,d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,d\\lambda}.\n$$\nDefine the SRF-weighted effective wavelength by\n$$\n\\lambda_{\\mathrm{eff}} \\equiv \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} \\lambda\\,S(\\lambda)\\,d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,d\\lambda},\n$$\nand the SRF peak wavelength by $\\lambda_{\\mathrm{peak}} \\in [\\lambda_{a}, \\lambda_{b}]$ such that $S(\\lambda_{\\mathrm{peak}}) \\geq S(\\lambda)$ for all $\\lambda \\in [\\lambda_{a}, \\lambda_{b}]$. Assume $L(\\lambda)$ is twice continuously differentiable on $[\\lambda_{a}, \\lambda_{b}]$. Starting from the first-order Taylor expansion of $L(\\lambda)$ around $\\lambda_{\\mathrm{eff}}$, derive, to leading order in the band width, the analytic expression for the bias incurred by using $L(\\lambda_{\\mathrm{peak}})$ to approximate the band-averaged radiance, where the bias is defined as\n$$\nb \\equiv L(\\lambda_{\\mathrm{peak}}) - \\overline{L}.\n$$\nExpress your final answer as a single closed-form expression in terms of $L'(\\lambda_{\\mathrm{eff}})$ and the difference $(\\lambda_{\\mathrm{peak}} - \\lambda_{\\mathrm{eff}})$. Do not assume any symmetry of $S(\\lambda)$. No numerical evaluation is required.",
            "solution": "The objective is to derive an analytic expression for the bias, $b$, incurred when approximating the band-averaged radiance, $\\overline{L}$, with the radiance at the spectral response function's peak wavelength, $L(\\lambda_{\\mathrm{peak}})$. The derivation is to be performed to leading order in the band width.\n\nThe bias $b$ is defined as:\n$$\nb \\equiv L(\\lambda_{\\mathrm{peak}}) - \\overline{L}\n$$\nThe band-averaged radiance $\\overline{L}$ and the SRF-weighted effective wavelength $\\lambda_{\\mathrm{eff}}$ are given by:\n$$\n\\overline{L} \\equiv \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,L(\\lambda)\\,d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,d\\lambda}\n$$\n$$\n\\lambda_{\\mathrm{eff}} \\equiv \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} \\lambda\\,S(\\lambda)\\,d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,d\\lambda}\n$$\nThe problem specifies that the derivation must start from the first-order Taylor expansion of the spectral radiance $L(\\lambda)$ around the effective wavelength $\\lambda_{\\mathrm{eff}}$. Given that $L(\\lambda)$ is twice continuously differentiable, this expansion is well-defined. The first-order Taylor approximation of $L(\\lambda)$ around $\\lambda_{\\mathrm{eff}}$ is:\n$$\nL(\\lambda) \\approx L(\\lambda_{\\mathrm{eff}}) + L'(\\lambda_{\\mathrm{eff}})(\\lambda - \\lambda_{\\mathrm{eff}})\n$$\nwhere $L'(\\lambda_{\\mathrm{eff}})$ is the first derivative of $L(\\lambda)$ with respect to $\\lambda$, evaluated at $\\lambda_{\\mathrm{eff}}$. This approximation holds for values of $\\lambda$ in the vicinity of $\\lambda_{\\mathrm{eff}}$, which is appropriate for a narrow spectral band $[\\lambda_a, \\lambda_b]$.\n\nWe will use this approximation to find expressions for both terms in the bias definition, $\\overline{L}$ and $L(\\lambda_{\\mathrm{peak}})$.\n\nFirst, we approximate the band-averaged radiance $\\overline{L}$ by substituting the Taylor expansion for $L(\\lambda)$ into its defining integral:\n$$\n\\overline{L} \\approx \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) \\left[ L(\\lambda_{\\mathrm{eff}}) + L'(\\lambda_{\\mathrm{eff}})(\\lambda - \\lambda_{\\mathrm{eff}}) \\right] d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,d\\lambda}\n$$\nWe can distribute the integral in the numerator over the two terms in the square brackets. Since $L(\\lambda_{\\mathrm{eff}})$ and $L'(\\lambda_{\\mathrm{eff}})$ are constants with respect to the integration variable $\\lambda$, they can be factored out of the integrals:\n$$\n\\overline{L} \\approx \\frac{L(\\lambda_{\\mathrm{eff}}) \\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda + L'(\\lambda_{\\mathrm{eff}}) \\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)(\\lambda - \\lambda_{\\mathrm{eff}}) d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,d\\lambda}\n$$\nSeparating this fraction into two parts yields:\n$$\n\\overline{L} \\approx L(\\lambda_{\\mathrm{eff}}) \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda} + L'(\\lambda_{\\mathrm{eff}}) \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)(\\lambda - \\lambda_{\\mathrm{eff}}) d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)\\,d\\lambda}\n$$\nThe first term simplifies to $L(\\lambda_{\\mathrm{eff}})$. Let's examine the fraction in the second term. We can expand the integral in its numerator:\n$$\n\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda)(\\lambda - \\lambda_{\\mathrm{eff}}) d\\lambda = \\int_{\\lambda_{a}}^{\\lambda_{b}} \\lambda S(\\lambda) d\\lambda - \\lambda_{\\mathrm{eff}} \\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda\n$$\nDividing this by the total integral of the SRF, $\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda$, we get:\n$$\n\\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} \\lambda S(\\lambda) d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda} - \\lambda_{\\mathrm{eff}} \\frac{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda}{\\int_{\\lambda_{a}}^{\\lambda_{b}} S(\\lambda) d\\lambda}\n$$\nBy the definition of the effective wavelength $\\lambda_{\\mathrm{eff}}$, the first term is exactly $\\lambda_{\\mathrm{eff}}$. The second term simplifies to $\\lambda_{\\mathrm{eff}}$. Thus, the expression equals:\n$$\n\\lambda_{\\mathrm{eff}} - \\lambda_{\\mathrm{eff}} = 0\n$$\nThis means the second term in the approximation for $\\overline{L}$ is zero. We are left with the first-order approximation for the band-averaged radiance:\n$$\n\\overline{L} \\approx L(\\lambda_{\\mathrm{eff}})\n$$\nThis result indicates that, to first order, the band-averaged radiance is equal to the radiance at the effective wavelength.\n\nNext, we formulate an expression for $L(\\lambda_{\\mathrm{peak}})$ that is consistent with our first-order approximation scheme. Since $\\lambda_{\\mathrm{peak}}$ is a point within the band, we can use the same Taylor expansion of $L(\\lambda)$ around $\\lambda_{\\mathrm{eff}}$ to approximate $L(\\lambda_{\\mathrm{peak}})$, by substituting $\\lambda = \\lambda_{\\mathrm{peak}}$:\n$$\nL(\\lambda_{\\mathrm{peak}}) \\approx L(\\lambda_{\\mathrm{eff}}) + L'(\\lambda_{\\mathrm{eff}})(\\lambda_{\\mathrm{peak}} - \\lambda_{\\mathrm{eff}})\n$$\n\nFinally, we calculate the bias $b$ by substituting the derived first-order approximations for $L(\\lambda_{\\mathrm{peak}})$ and $\\overline{L}$ into the definition of $b$:\n$$\nb = L(\\lambda_{\\mathrm{peak}}) - \\overline{L} \\approx \\left[ L(\\lambda_{\\mathrm{eff}}) + L'(\\lambda_{\\mathrm{eff}})(\\lambda_{\\mathrm{peak}} - \\lambda_{\\mathrm{eff}}) \\right] - L(\\lambda_{\\mathrm{eff}})\n$$\nThe terms $L(\\lambda_{\\mathrm{eff}})$ cancel, yielding the leading-order expression for the bias:\n$$\nb \\approx L'(\\lambda_{\\mathrm{eff}})(\\lambda_{\\mathrm{peak}} - \\lambda_{\\mathrm{eff}})\n$$\nThis result represents the analytic expression for the bias to leading order. It shows that the bias is proportional to the product of the spectral radiance's slope at the effective wavelength and the difference between the peak and effective wavelengths. This latter term, $(\\lambda_{\\mathrm{peak}} - \\lambda_{\\mathrm{eff}})$, depends on the asymmetry of the spectral response function $S(\\lambda)$.",
            "answer": "$$\n\\boxed{L'(\\lambda_{\\mathrm{eff}})(\\lambda_{\\mathrm{peak}} - \\lambda_{\\mathrm{eff}})}\n$$"
        },
        {
            "introduction": "A sensor does not measure the true, infinitely sharp spectrum of a target; instead, it observes a smoothed version dictated by its spectral response function (SRF). This hands-on coding practice  allows you to simulate this process by performing a convolution between a high-resolution \"true\" spectrum and a given SRF. You will quantify key effects such as the reduction in peak amplitude and the blending of nearby spectral features, developing a tangible understanding of how instrument characteristics are imprinted on the final measured data.",
            "id": "3845856",
            "problem": "Consider a one-dimensional wavelength domain $\\lambda$ in nanometers, and a high-resolution line spectrum that is the sum of narrow Gaussian lines. Let the true spectral radiance be denoted by $L(\\lambda)$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, and suppose the sensor is characterized by a Sensor Spectral Response Function (SRF), denoted $R(\\lambda)$, which is normalized to unit area. The apparent spectrum measured by the sensor is the convolution\n$$\n\\tilde{L}(\\lambda) = \\int_{-\\infty}^{\\infty} L(\\lambda')\\,R(\\lambda - \\lambda')\\,\\mathrm{d}\\lambda' .\n$$\nAssume each spectral line $i$ in the high-resolution spectrum is a Gaussian with center wavelength $\\lambda_i$, standard deviation $\\sigma_i$ (much narrower than the SRF), and integrated line strength $S_i$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$. That is,\n$$\nL(\\lambda) = \\sum_{i} S_i\\,\\phi(\\lambda;\\lambda_i,\\sigma_i),\n$$\nwhere\n$$\n\\phi(\\lambda;\\lambda_i,\\sigma_i) = \\frac{1}{\\sigma_i\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\lambda - \\lambda_i)^2}{2\\sigma_i^2}\\right)\n$$\nis a unit-area Gaussian. Let the SRF be Gaussian,\n$$\nR(\\lambda) = \\frac{1}{\\sigma_{\\mathrm{srf}}\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{\\lambda^2}{2\\sigma_{\\mathrm{srf}}^2}\\right),\n$$\nwith standard deviation $\\sigma_{\\mathrm{srf}}$ in $\\mathrm{nm}$ and unit area $\\int R(\\lambda)\\,\\mathrm{d}\\lambda = 1$.\n\nYour task is to:\n- Compute the apparent spectrum $\\tilde{L}(\\lambda)$ over a specified discrete wavelength grid for each test case.\n- Compute the peak amplitude $A = \\max_{\\lambda}\\tilde{L}(\\lambda)$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.\n- Compute the total area $\\mathcal{A} = \\int \\tilde{L}(\\lambda)\\,\\mathrm{d}\\lambda$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$ using numerical integration over the specified domain.\n- Quantify the impact on peak amplitude via the ratio $\\rho = A / \\max_{\\lambda} L(\\lambda)$, which is dimensionless. Here $\\max_{\\lambda} L(\\lambda)$ is computed over the same discrete grid as the apparent spectrum.\n\nAll answers for amplitude $A$ must be expressed in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, areas $\\mathcal{A}$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$, and the ratio $\\rho$ as a decimal. No angle quantities are involved. Use numerical integration via the trapezoidal rule over the provided finite domains.\n\nTest Suite:\nFor each case below, compute $\\tilde{L}(\\lambda)$, $A$, $\\mathcal{A}$, and $\\rho$.\n\n- Case $1$ (single line, hyperspectral-like SRF):\n  - Domain: $\\lambda \\in [500, 600]\\,\\mathrm{nm}$, uniform grid step $\\Delta\\lambda = 0.01\\,\\mathrm{nm}$.\n  - Lines: one line at $\\lambda_1 = 550\\,\\mathrm{nm}$, $S_1 = 1.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$, $\\sigma_1 = 0.02\\,\\mathrm{nm}$.\n  - SRF: Gaussian with $\\sigma_{\\mathrm{srf}} = 2.0\\,\\mathrm{nm}$.\n\n- Case $2$ (two lines, partially blended by SRF):\n  - Domain: $\\lambda \\in [640, 660]\\,\\mathrm{nm}$, uniform grid step $\\Delta\\lambda = 0.01\\,\\mathrm{nm}$.\n  - Lines: two lines at $\\lambda_1 = 649\\,\\mathrm{nm}$, $S_1 = 0.6\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$, $\\sigma_1 = 0.05\\,\\mathrm{nm}$; and at $\\lambda_2 = 651\\,\\mathrm{nm}$, $S_2 = 0.4\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$, $\\sigma_2 = 0.05\\,\\mathrm{nm}$.\n  - SRF: Gaussian with $\\sigma_{\\mathrm{srf}} = 1.0\\,\\mathrm{nm}$.\n\n- Case $3$ (boundary truncation under broad SRF):\n  - Domain: $\\lambda \\in [380, 420]\\,\\mathrm{nm}$, uniform grid step $\\Delta\\lambda = 0.02\\,\\mathrm{nm}$.\n  - Lines: one line at $\\lambda_1 = 400\\,\\mathrm{nm}$, $S_1 = 1.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$, $\\sigma_1 = 0.02\\,\\mathrm{nm}$.\n  - SRF: Gaussian with $\\sigma_{\\mathrm{srf}} = 10.0\\,\\mathrm{nm}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test caseâ€™s result must itself be a list of three values $[A,\\mathcal{A},\\rho]$, in that order. For example, the overall output for the three test cases must look like\n$$\n[[A_1,\\mathcal{A}_1,\\rho_1],[A_2,\\mathcal{A}_2,\\rho_2],[A_3,\\mathcal{A}_3,\\rho_3]] .\n$$\nAll values should be numeric floats. No additional text should be printed.",
            "solution": "The core of this problem is to determine the effect of a sensor's spectral response function (SRF) on a measured high-resolution line spectrum. The apparent spectrum $\\tilde{L}(\\lambda)$ is the convolution of the true spectral radiance $L(\\lambda)$ with the sensor's SRF, $R(\\lambda)$:\n$$\n\\tilde{L}(\\lambda) = (L * R)(\\lambda) = \\int_{-\\infty}^{\\infty} L(\\lambda')\\,R(\\lambda - \\lambda')\\,\\mathrm{d}\\lambda'\n$$\n\nA direct numerical computation of this convolution integral for each point $\\lambda$ on the grid is possible but computationally intensive and may introduce numerical artifacts. A more elegant and efficient solution arises from exploiting the mathematical properties of the functions involved.\n\nThe true spectrum $L(\\lambda)$ is a sum of Gaussian lines:\n$$\nL(\\lambda) = \\sum_{i} S_i\\,\\phi(\\lambda;\\lambda_i,\\sigma_i)\n$$\nwhere $\\phi(\\lambda;\\mu,\\sigma)$ is a unit-area Gaussian probability density function (PDF) with mean $\\mu$ and standard deviation $\\sigma$:\n$$\n\\phi(\\lambda;\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\lambda - \\mu)^2}{2\\sigma^2}\\right)\n$$\nThe SRF, $R(\\lambda)$, is also modeled as a Gaussian, centered at zero with standard deviation $\\sigma_{\\mathrm{srf}}$:\n$$\nR(\\lambda) = \\phi(\\lambda; 0, \\sigma_{\\mathrm{srf}})\n$$\n\nA fundamental theorem of probability theory and signal processing states that the convolution of two Gaussian functions is another Gaussian function. Specifically, if $f_1(x) \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2)$ and $f_2(x) \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2)$, their convolution $(f_1 * f_2)(x)$ is a Gaussian with mean $\\mu_1 + \\mu_2$ and variance $\\sigma_1^2 + \\sigma_2^2$.\n\nWe can apply this theorem. The convolution is a linear operation, so we can convolve each Gaussian line in $L(\\lambda)$ with the SRF individually and sum the results:\n$$\n\\tilde{L}(\\lambda) = \\left(\\sum_{i} S_i\\,\\phi(\\cdot;\\lambda_i,\\sigma_i)\\right) * \\phi(\\cdot; 0, \\sigma_{\\mathrm{srf}}) = \\sum_{i} S_i \\left( \\phi(\\cdot;\\lambda_i,\\sigma_i) * \\phi(\\cdot; 0, \\sigma_{\\mathrm{srf}}) \\right)\n$$\nFor each line $i$, we are convolving a Gaussian centered at $\\lambda_i$ with standard deviation $\\sigma_i$ with a Gaussian centered at $0$ with standard deviation $\\sigma_{\\mathrm{srf}}$. The resulting function is a Gaussian centered at $\\lambda_i + 0 = \\lambda_i$ with a variance of $\\sigma_i^2 + \\sigma_{\\mathrm{srf}}^2$. The new effective standard deviation is $\\sigma_{\\mathrm{eff},i} = \\sqrt{\\sigma_i^2 + \\sigma_{\\mathrm{srf}}^2}$.\n\nThus, the apparent spectrum $\\tilde{L}(\\lambda)$ has a simple analytical form:\n$$\n\\tilde{L}(\\lambda) = \\sum_{i} S_i\\,\\phi(\\lambda; \\lambda_i, \\sigma_{\\mathrm{eff},i}) = \\sum_{i} S_i\\,\\phi(\\lambda; \\lambda_i, \\sqrt{\\sigma_i^2 + \\sigma_{\\mathrm{srf}}^2})\n$$\nThis analytical expression for $\\tilde{L}(\\lambda)$ allows for its direct and accurate calculation on the specified wavelength grid, bypassing numerical convolution entirely.\n\nThe computational procedure for each test case is as follows:\n$1$. A discrete wavelength grid $\\lambda_k$ is generated for the specified domain $[\\lambda_{\\min}, \\lambda_{\\max}]$ with step size $\\Delta\\lambda$.\n$2$. The true spectrum $L(\\lambda_k)$ is computed on this grid using its definition as a sum of Gaussian lines.\n$3$. The apparent spectrum $\\tilde{L}(\\lambda_k)$ is computed on the same grid using the derived analytical form, with the effective standard deviation $\\sigma_{\\mathrm{eff},i}$ for each line.\n$4$. The peak amplitude $A$ of the apparent spectrum is found by taking the maximum value of $\\tilde{L}(\\lambda_k)$ over the grid: $A = \\max_k \\{ \\tilde{L}(\\lambda_k) \\}$.\n$5$. The total integrated area $\\mathcal{A}$ under the apparent spectrum over the given domain is calculated using the trapezoidal rule on the discrete points $(\\lambda_k, \\tilde{L}(\\lambda_k))$:\n$$\n\\mathcal{A} = \\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} \\tilde{L}(\\lambda)\\,\\mathrm{d}\\lambda \\approx \\sum_k \\frac{\\tilde{L}(\\lambda_k) + \\tilde{L}(\\lambda_{k+1})}{2} \\Delta\\lambda\n$$\n$6$. The peak amplitude of the true spectrum, $\\max_{\\lambda} L(\\lambda)$, is found by taking the maximum value of $L(\\lambda_k)$ over the grid.\n$7$. The dimensionless ratio $\\rho$ is computed as $\\rho = A / \\max_k \\{ L(\\lambda_k) \\}$.\n\nThis procedure is applied to each of the three test cases, which are designed to illustrate different physical effects:\n- **Case $1$**: A single, very narrow spectral line is broadened (smeared) by a moderately high-resolution SRF ($\\sigma_{\\mathrm{srf}} = 2.0\\,\\mathrm{nm}$). The peak amplitude is expected to decrease significantly, while the area is conserved because the integration domain is wide.\n- **Case $2$**: Two distinct spectral lines are observed by an SRF whose width ($\\sigma_{\\mathrm{srf}} = 1.0\\,\\mathrm{nm}$) is comparable to the line separation ($2.0\\,\\mathrm{nm}$). This illustrates the blending of spectral features, where the two peaks merge into a single, broader feature in the apparent spectrum.\n- **Case $3$**: A single line is observed with a very broad, low-resolution SRF ($\\sigma_{\\mathrm{srf}} = 10.0\\,\\mathrm{nm}$). The integration domain is relatively narrow compared to the width of the convolved signal, leading to a significant truncation effect. The calculated area $\\mathcal{A}$ will be noticeably smaller than the total line strength $S_1$ because a portion of the spectrally broadened line falls outside the integration domain.\n\nFinal values are collated as a list of lists $[[A_1, \\mathcal{A}_1, \\rho_1], [A_2, \\mathcal{A}_2, \\rho_2], [A_3, \\mathcal{A}_3, \\rho_3]]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf # Used for internal verification, not required for the final calculation method.\n\ndef solve():\n    \"\"\"\n    Solves the sensor spectral response problem for three test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"domain\": (500, 600), \"d_lambda\": 0.01,\n            \"lines\": [{\"S\": 1.0, \"lambda_i\": 550, \"sigma_i\": 0.02}],\n            \"srf\": {\"sigma_srf\": 2.0}\n        },\n        {\n            \"name\": \"Case 2\",\n            \"domain\": (640, 660), \"d_lambda\": 0.01,\n            \"lines\": [\n                {\"S\": 0.6, \"lambda_i\": 649, \"sigma_i\": 0.05},\n                {\"S\": 0.4, \"lambda_i\": 651, \"sigma_i\": 0.05}\n            ],\n            \"srf\": {\"sigma_srf\": 1.0}\n        },\n        {\n            \"name\": \"Case 3\",\n            \"domain\": (380, 420), \"d_lambda\": 0.02,\n            \"lines\": [{\"S\": 1.0, \"lambda_i\": 400, \"sigma_i\": 0.02}],\n            \"srf\": {\"sigma_srf\": 10.0}\n        }\n    ]\n\n    results = []\n\n    def gaussian_pdf(x, mu, sigma):\n        \"\"\"\n        Computes a unit-area Gaussian function.\n        f(x) = (1/(sigma*sqrt(2*pi))) * exp(- (x-mu)^2 / (2*sigma^2) )\n        \"\"\"\n        if sigma == 0:\n            # Avoid division by zero, treat as a delta function\n            return np.where(x == mu, np.inf, 0)\n        norm = 1.0 / (sigma * np.sqrt(2 * np.pi))\n        exponent = -((x - mu)**2) / (2 * sigma**2)\n        return norm * np.exp(exponent)\n\n    for case in test_cases:\n        # 1. Generate the wavelength grid\n        lambda_min, lambda_max = case[\"domain\"]\n        d_lambda = case[\"d_lambda\"]\n        # Use np.linspace for robust grid generation\n        num_points = int(round((lambda_max - lambda_min) / d_lambda)) + 1\n        wavelengths = np.linspace(lambda_min, lambda_max, num_points)\n\n        # 2. Compute the true spectrum L(lambda)\n        L_lambda = np.zeros_like(wavelengths)\n        for line in case[\"lines\"]:\n            L_lambda += line[\"S\"] * gaussian_pdf(wavelengths, line[\"lambda_i\"], line[\"sigma_i\"])\n        \n        # 3. Compute the apparent spectrum L_tilde(lambda)\n        sigma_srf = case[\"srf\"][\"sigma_srf\"]\n        L_tilde_lambda = np.zeros_like(wavelengths)\n        for line in case[\"lines\"]:\n            sigma_eff = np.sqrt(line[\"sigma_i\"]**2 + sigma_srf**2)\n            L_tilde_lambda += line[\"S\"] * gaussian_pdf(wavelengths, line[\"lambda_i\"], sigma_eff)\n\n        # 4. Compute peak amplitude A\n        A = np.max(L_tilde_lambda)\n\n        # 5. Compute total area Script-A using the trapezoidal rule\n        script_A = np.trapz(L_tilde_lambda, wavelengths)\n\n        # 6. Compute peak of true spectrum and the ratio rho\n        max_L = np.max(L_lambda)\n        if max_L > 0:\n            rho = A / max_L\n        else: # Should not happen with given inputs, but good practice\n            rho = 0.0 \n        \n        results.append([A, script_A, rho])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    # e.g., [[A1,CalA1,rho1],[A2,CalA2,rho2],...]\n    str_results = []\n    for res in results:\n        # Format each inner list to prevent spaces around commas.\n        str_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In real multi-band sensors, the spectral response functions of adjacent bands often overlap, leading to a measurement artifact known as spectral cross-talk. This advanced computational problem  places you in the role of a calibration engineer, tasked with characterizing and correcting this cross-talk using a linear system model. You will implement a full workflow, from estimating the sensor's response matrix using regularized regression on calibration data to inverting its effects on a field measurement, mastering a critical set of techniques for ensuring radiometric accuracy in multi-band remote sensing.",
            "id": "3845889",
            "problem": "You are given a linear multi-band sensor model that captures band-to-band spectral cross-talk via a tri-diagonal response matrix. Let there be $B$ discrete spectral bands. Denote the true band radiance vector by $s \\in \\mathbb{R}^B$ (in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$), the observed (noisy) sensor output by $y \\in \\mathbb{R}^B$, and the band-to-band response matrix by $M \\in \\mathbb{R}^{B \\times B}$. The sensor is modeled as a linear system with additive noise, governed by the relation\n$$\ny = M s + \\epsilon,\n$$\nwhere $\\epsilon \\in \\mathbb{R}^B$ is a zero-mean noise vector. The matrix $M$ is assumed to be tri-diagonal with symmetric adjacent-band cross-talk, parameterized by band-specific diagonal gains $d_i$ and adjacent-band coefficients $c_i$:\n- For $i = 0, 1, \\dots, B-1$, the main diagonal entries are $M_{i,i} = d_i$.\n- For $i = 0, 1, \\dots, B-2$, the upper and lower off-diagonal entries are $M_{i,i+1} = c_i$ and $M_{i+1,i} = c_i$.\nAll $d_i$ and $c_i$ are dimensionless. Physical radiances are expressed in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.\n\nYou will design and implement a calibration strategy to estimate $d_i$ and $c_i$ from calibration data using regularized linear regression, and then correct a field measurement by inverting the estimated response. Calibration stimuli are known, and calibration observations are generated from a known ground-truth $M$ with additive Gaussian noise of known standard deviation. The estimation must be regularized to control variance and promote smoothness across bands.\n\nStarting Point and Definitions:\n- Assume linear superposition for band responses and a fixed, time-invariant response matrix $M$ over the calibration interval. This is a standard assumption in remote sensing for small-signal radiometric calibration when non-linear detector effects and saturation are negligible.\n- For each calibration input $s^{(k)} \\in \\mathbb{R}^B$ with $k = 1, \\dots, K$, the observed output obeys $y^{(k)} = M s^{(k)} + \\epsilon^{(k)}$ with $\\epsilon^{(k)}$ being mean-zero Gaussian noise.\n- The tri-diagonal symmetry of $M$ implies the response to adjacent bands is identical in magnitude in both directions for a given adjacency index.\n\nCalibration Objective:\n- Estimate the parameter vector $\\theta \\in \\mathbb{R}^{B+(B-1)}$ defined by stacking $\\{d_i\\}_{i=0}^{B-1}$ and $\\{c_i\\}_{i=0}^{B-2}$ from calibration pairs $\\{(s^{(k)}, y^{(k)})\\}_{k=1}^K$ by solving a regularized least squares problem. Construct a linear design operator so that predicted observations are linear in $\\theta$.\n- Formulate the estimation as minimizing a sum of squared residuals with Tikhonov regularization that penalizes first differences of $d_i$ across bands and first differences of $c_i$ across adjacency indices. Let the regularization strength be $\\lambda > 0$.\n\nCorrection Objective:\n- Given a field measurement $y_{\\mathrm{field}} \\in \\mathbb{R}^B$ with the same noise characteristics, recover an estimate $\\hat{s}$ of the true radiance by solving a Tikhonov-regularized inverse problem with a zero-order penalty:\n$$\n\\hat{s} = \\arg\\min_{s} \\left\\| \\hat{M} s - y_{\\mathrm{field}} \\right\\|_2^2 + \\alpha \\left\\| s \\right\\|_2^2,\n$$\nwhere $\\hat{M}$ is the calibrated estimate of $M$ and $\\alpha > 0$ is the inversion regularization strength. Express $\\hat{s}$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.\n\nTest Suite and Data Generation:\nFor reproducibility, all pseudo-random numbers must be generated using a fixed seed (specified per test case) and standard normal distributions for noise. In each case, use $K = B$ calibration stimuli consisting of single-band excitations of amplitude $A = 1.0$ in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, that is, for $j = 0, \\dots, B-1$, let $s^{(j)}$ be the unit basis vector scaled by $A$ in band $j$. For each test case, construct $M$ from the specified $(d, c)$, generate calibration outputs $y^{(k)}$ with independent Gaussian noise of standard deviation $\\sigma$ per component, estimate $(\\hat{d}, \\hat{c})$, build $\\hat{M}$, generate a field measurement $y_{\\mathrm{field}} = M s_{\\mathrm{field}} + \\epsilon_{\\mathrm{field}}$ with the same $\\sigma$, and recover $\\hat{s}$. Use the following test cases:\n\n- Case $1$ (happy path): $B = 5$, $d = [1.00, 0.98, 1.02, 1.01, 0.99]$, $c = [0.06, 0.04, 0.05, 0.03]$, $\\sigma = 0.005$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 0.10$, $\\alpha = 0.01$, seed $= 123$, $s_{\\mathrm{field}} = [0.8, 1.2, 0.6, 1.0, 0.7]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.\n- Case $2$ (boundary condition: zero cross-talk): $B = 5$, $d = [1.00, 1.00, 1.00, 1.00, 1.00]$, $c = [0.00, 0.00, 0.00, 0.00]$, $\\sigma = 0.010$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 0.05$, $\\alpha = 0.001$, seed $= 7$, $s_{\\mathrm{field}} = [0.5, 1.5, 0.9, 1.1, 0.4]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.\n- Case $3$ (edge case: few bands, higher noise, stronger regularization): $B = 3$, $d = [0.97, 1.03, 1.00]$, $c = [0.08, 0.07]$, $\\sigma = 0.020$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 1.00$, $\\alpha = 0.05$, seed $= 99$, $s_{\\mathrm{field}} = [1.00, 0.50, 1.20]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.\n\nRequired Outputs for Each Test Case:\n- Compute the mean absolute error of adjacent-band coefficients, defined as\n$$\n\\mathrm{MAE}_c = \\frac{1}{B-1} \\sum_{i=0}^{B-2} \\left| \\hat{c}_i - c_i \\right|,\n$$\nwhich is dimensionless.\n- Compute the root-mean-square radiance error of the corrected field signal,\n$$\n\\mathrm{RMSE}_s = \\sqrt{\\frac{1}{B} \\sum_{i=0}^{B-1} \\left( \\hat{s}_i - s_{\\mathrm{field}, i} \\right)^2 },\n$$\nexpressed in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a two-element list $[\\mathrm{MAE}_c, \\mathrm{RMSE}_s]$. For example, the output format must be\n$$\n\\left[ [x_1, y_1], [x_2, y_2], [x_3, y_3] \\right],\n$$\nwith decimal values and no additional text. All radiance quantities in the output are in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$.",
            "solution": "The solution is developed in three principal parts:\n1.  Formulation of the calibration problem to estimate the sensor response parameters.\n2.  Formulation of the signal correction problem to estimate the true radiance.\n3.  Specification of the numerical implementation details for the provided test cases.\n\n### Part 1: Calibration via Regularized Linear Regression\n\nThe core of the calibration task is to estimate the parameters of the tri-diagonal response matrix $M$. The sensor model is given by $y = M s + \\epsilon$. The matrix $M \\in \\mathbb{R}^{B \\times B}$ is defined by a set of $B$ diagonal gains $\\{d_i\\}_{i=0}^{B-1}$ and $B-1$ adjacent-band cross-talk coefficients $\\{c_i\\}_{i=0}^{B-2}$. Let us define a single parameter vector $\\theta \\in \\mathbb{R}^{2B-1}$ by concatenating these parameters:\n$$\n\\theta = [d_0, d_1, \\dots, d_{B-1}, c_0, c_1, \\dots, c_{B-2}]^T\n$$\nOur goal is to express the observation vector $y$ as a linear function of this parameter vector $\\theta$. The $i$-th component of the observed signal, $y_i$, can be written by expanding the matrix-vector product $Ms$:\n$$\ny_i = (Ms)_i = \\sum_{j=0}^{B-1} M_{ij} s_j\n$$\nGiven the specified tri-diagonal structure of $M$, where $M_{i,i} = d_i$, $M_{i,i+1} = c_i$, and $M_{i+1,i} = c_i$, this sum simplifies to:\n$$\ny_i = \\begin{cases}\nd_0 s_0 + c_0 s_{1} & \\text{if } i=0 \\\\\nc_{i-1} s_{i-1} + d_i s_i + c_i s_{i+1} & \\text{if } 0 < i < B-1 \\\\\nc_{B-2} s_{B-2} + d_{B-1} s_{B-1} & \\text{if } i=B-1\n\\end{cases}\n$$\nThis demonstrates that each component $y_i$ is a linear combination of the elements in $\\theta$. We can thus construct a design matrix for a single stimulus-response pair $(s, y)$ that maps $\\theta$ to $y$. Let us call this per-stimulus design matrix $X_s \\in \\mathbb{R}^{B \\times (2B-1)}$. The $i$-th row of $X_s$ contains the coefficients of $\\theta$ for the expression of $y_i$. Specifically, the non-zero entries of the $i$-th row of $X_s$ are:\n-   $s_i$ at column $i$ (corresponding to parameter $d_i$).\n-   $s_{i-1}$ at column $B+i-1$ (corresponding to parameter $c_{i-1}$), for $i>0$.\n-   $s_{i+1}$ at column $B+i$ (corresponding to parameter $c_i$), for $i<B-1$.\n\nThe calibration process uses $K=B$ distinct stimuli $\\{s^{(k)}\\}_{k=0}^{B-1}$ and their corresponding noisy observations $\\{y^{(k)}\\}_{k=0}^{B-1}$. We can stack these into a single large linear system. Let $Y \\in \\mathbb{R}^{BK}$ be the vector formed by vertically concatenating all $y^{(k)}$ vectors, and let $A_{\\text{calib}} \\in \\mathbb{R}^{BK \\times (2B-1)}$ be the global design matrix formed by vertically stacking the individual design matrices $X_{s^{(k)}}$. The full system is then modeled as:\n$$\nY = A_{\\text{calib}} \\theta + E\n$$\nwhere $E$ is the stacked noise vector. The calibration objective is to find an estimate $\\hat{\\theta}$ that minimizes a regularized least-squares cost function:\n$$\nJ(\\theta) = \\| A_{\\text{calib}} \\theta - Y \\|_2^2 + \\lambda \\| \\Gamma \\theta \\|_2^2\n$$\nHere, $\\lambda > 0$ is the regularization strength, and $\\Gamma$ is a matrix that computes the first differences of the $d_i$ and $c_i$ parameters to enforce smoothness. The matrix $\\Gamma \\in \\mathbb{R}^{(2B-3) \\times (2B-1)}$ is constructed as follows:\n-   The first $B-1$ rows compute $d_{i+1}-d_i$ for $i=0, \\dots, B-2$. The $i$-th such row has $-1$ at column $i$ and $+1$ at column $i+1$.\n-   The next $B-2$ rows compute $c_{i+1}-c_i$ for $i=0, \\dots, B-3$. The $(B-1+i)$-th row has $-1$ at column $B+i$ and $+1$ at column $B+i+1$.\n\nThe solution $\\hat{\\theta}$ that minimizes this cost function is found by solving the associated normal equations:\n$$\n(A_{\\text{calib}}^T A_{\\text{calib}} + \\lambda \\Gamma^T \\Gamma) \\hat{\\theta} = A_{\\text{calib}}^T Y\n$$\nThis yields the solution for the estimated parameter vector:\n$$\n\\hat{\\theta} = \\left( A_{\\text{calib}}^T A_{\\text{calib}} + \\lambda \\Gamma^T \\Gamma \\right)^{-1} A_{\\text{calib}}^T Y\n$$\nThe estimated parameters $\\hat{d}_i$ and $\\hat{c}_i$ are then extracted from $\\hat{\\theta}$.\n\n### Part 2: Signal Correction via Regularized Inversion\n\nOnce the calibrated response matrix $\\hat{M}$ is constructed from the estimated parameters $\\hat{d}$ and $\\hat{c}$, it can be used to correct a new field measurement $y_{\\text{field}}$. The goal is to recover an estimate $\\hat{s}$ of the true radiance $s_{\\text{field}}$ given the model $\\hat{M}\\hat{s} \\approx y_{\\text{field}}$. This is an inverse problem, which is often ill-posed. Tikhonov regularization is employed to find a stable solution. The problem is formulated as finding the radiance vector $\\hat{s}$ that minimizes the following cost function:\n$$\nJ(s) = \\| \\hat{M} s - y_{\\text{field}} \\|_2^2 + \\alpha \\| s \\|_2^2\n$$\nwhere $\\alpha > 0$ is the inversion regularization parameter. This is a zero-order Tikhonov regularization (or ridge regression) problem, where the penalty term $\\|s\\|_2^2$ discourages solutions with large magnitudes.\n\nTo find the minimum, we compute the gradient of $J(s)$ with respect to $s$ and set it to zero:\n$$\n\\nabla_s J(s) = 2\\hat{M}^T(\\hat{M}s - y_{\\text{field}}) + 2\\alpha s = 0\n$$\nRearranging the terms gives the normal equations for this problem:\n$$\n(\\hat{M}^T \\hat{M} + \\alpha I) s = \\hat{M}^T y_{\\text{field}}\n$$\nwhere $I$ is the identity matrix. The solution for the corrected radiance vector $\\hat{s}$ is therefore:\n$$\n\\hat{s} = (\\hat{M}^T \\hat{M} + \\alpha I)^{-1} \\hat{M}^T y_{\\text{field}}\n$$\n\n### Part 3: Numerical Implementation and Evaluation\n\nThe final step is to implement this two-stage process for the given test cases. The procedure is as follows:\n1.  For each test case, initialize the pseudo-random number generator with the specified seed for reproducibility.\n2.  Construct the true response matrix $M$ from the given $d$ and $c$ vectors.\n3.  Generate the $K=B$ calibration stimuli $s^{(j)} = A e_j$ for $j=0, \\dots, B-1$, where $A=1.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ and $e_j$ is the $j$-th standard basis vector.\n4.  For each stimulus $s^{(j)}$, compute the clean observation $M s^{(j)}$ and add zero-mean Gaussian noise with standard deviation $\\sigma$ to produce the noisy observation $y^{(j)}$.\n5.  Construct the full design matrix $A_{\\text{calib}}$ and the stacked observation vector $Y$.\n6.  Construct the regularization matrix $\\Gamma$.\n7.  Solve for $\\hat{\\theta}$ using the linear system solver on the normal equations from Part 1. Extract $\\hat{d}$ and $\\hat{c}$.\n8.  Construct the estimated response matrix $\\hat{M}$.\n9.  Generate the noisy field measurement $y_{\\text{field}} = M s_{\\text{field}} + \\epsilon_{\\text{field}}$, using the true $M$ and a new noise realization.\n10. Solve for the corrected radiance $\\hat{s}$ using the linear system solver on the normal equations from Part 2.\n11. Compute the required metrics, $\\mathrm{MAE}_c = \\frac{1}{B-1} \\sum_{i=0}^{B-2} |\\hat{c}_i - c_i|$ and $\\mathrm{RMSE}_s = \\sqrt{\\frac{1}{B} \\sum_{i=0}^{B-1} (\\hat{s}_i - s_{\\mathrm{field}, i})^2}$.\n\nThese steps are encapsulated in the provided Python code, which cycles through each test case and computes the specified metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sensor calibration and correction problem for a set of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'B': 5, 'd': [1.00, 0.98, 1.02, 1.01, 0.99], 'c': [0.06, 0.04, 0.05, 0.03],\n         'sigma': 0.005, 'lambda_reg': 0.10, 'alpha': 0.01, 'seed': 123,\n         's_field': [0.8, 1.2, 0.6, 1.0, 0.7]},\n        # Case 2\n        {'B': 5, 'd': [1.00, 1.00, 1.00, 1.00, 1.00], 'c': [0.00, 0.00, 0.00, 0.00],\n         'sigma': 0.010, 'lambda_reg': 0.05, 'alpha': 0.001, 'seed': 7,\n         's_field': [0.5, 1.5, 0.9, 1.1, 0.4]},\n        # Case 3\n        {'B': 3, 'd': [0.97, 1.03, 1.00], 'c': [0.08, 0.07],\n         'sigma': 0.020, 'lambda_reg': 1.00, 'alpha': 0.05, 'seed': 99,\n         's_field': [1.00, 0.50, 1.20]},\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        B = case['B']\n        d_true = np.array(case['d'])\n        c_true = np.array(case['c'])\n        sigma = case['sigma']\n        lambda_val = case['lambda_reg']\n        alpha = case['alpha']\n        seed = case['seed']\n        s_field_true = np.array(case['s_field'])\n        \n        rng = np.random.default_rng(seed)\n\n        # 1. Construct the true response matrix M_true\n        M_true = np.zeros((B, B))\n        np.fill_diagonal(M_true, d_true)\n        for i in range(B - 1):\n            M_true[i, i + 1] = c_true[i]\n            M_true[i + 1, i] = c_true[i]\n\n        # 2. Generate calibration data (stimuli and observations)\n        A = 1.0  # Amplitude of calibration stimuli\n        K = B    # Number of calibration stimuli\n        cal_stimuli = [A * np.eye(B)[i] for i in range(K)]\n        cal_observations = []\n        for s_cal in cal_stimuli:\n            y_clean = M_true @ s_cal\n            noise = rng.normal(0, sigma, size=B)\n            y_noisy = y_clean + noise\n            cal_observations.append(y_noisy)\n\n        # 3. Formulate and solve the regularized least squares problem for theta\n        num_params = B + (B - 1)  # B for d_i, B-1 for c_i\n        A_calib = np.zeros((K * B, num_params))\n        Y_calib = np.concatenate(cal_observations)\n\n        # Populate the global design matrix A_calib\n        for k in range(K):  # Index for stimulus\n            s_k = cal_stimuli[k]\n            for i in range(B):  # Index for observed band\n                row_idx = k * B + i\n                # Coefficient for d_i\n                A_calib[row_idx, i] = s_k[i]\n                # Coefficient for c_{i-1}\n                if i > 0:\n                    A_calib[row_idx, B + i - 1] = s_k[i - 1]\n                # Coefficient for c_i\n                if i  B - 1:\n                    A_calib[row_idx, B + i] = s_k[i + 1]\n\n        # 4. Construct the regularization matrix Gamma\n        num_reg_rows = (B - 1) + (B - 2)\n        Gamma = np.zeros((num_reg_rows, num_params))\n        \n        # Regularization for first differences of d_i\n        for i in range(B - 1):\n            Gamma[i, i] = -1\n            Gamma[i, i + 1] = 1\n\n        # Regularization for first differences of c_i\n        offset = B - 1\n        for i in range(B - 2):\n            Gamma[offset + i, B + i] = -1\n            Gamma[offset + i, B + i + 1] = 1\n        \n        # 5. Solve for the estimated parameters theta_hat\n        # (A_calib^T A_calib + lambda * Gamma^T Gamma) theta = A_calib^T Y\n        AtA = A_calib.T @ A_calib\n        GtG = Gamma.T @ Gamma\n        LHS = AtA + lambda_val * GtG\n        RHS = A_calib.T @ Y_calib\n        \n        theta_hat = np.linalg.solve(LHS, RHS)\n        \n        d_hat = theta_hat[:B]\n        c_hat = theta_hat[B:]\n\n        # 6. Construct M_hat and correct the field measurement\n        M_hat = np.zeros((B, B))\n        np.fill_diagonal(M_hat, d_hat)\n        for i in range(B - 1):\n            M_hat[i, i + 1] = c_hat[i]\n            M_hat[i + 1, i] = c_hat[i]\n\n        # Generate the noisy field measurement y_field\n        y_field_clean = M_true @ s_field_true\n        noise_field = rng.normal(0, sigma, size=B)\n        y_field_noisy = y_field_clean + noise_field\n\n        # Solve the regularized inverse problem for s_hat\n        # (M_hat^T M_hat + alpha * I) s = M_hat^T y_field\n        LHS_s = M_hat.T @ M_hat + alpha * np.eye(B)\n        RHS_s = M_hat.T @ y_field_noisy\n        s_hat = np.linalg.solve(LHS_s, RHS_s)\n\n        # 7. Calculate and store the required metrics\n        mae_c = np.mean(np.abs(c_hat - c_true))\n        rmse_s = np.sqrt(np.mean((s_hat - s_field_true)**2))\n        \n        all_results.append(f\"[{mae_c:.8f}, {rmse_s:.8f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}