{
    "hands_on_practices": [
        {
            "introduction": "SRF 的形状，通常称为仪器线型 (ILS)，是决定光谱仪性能的关键设计选择，不同的 ILS 数学形式有不同的权衡。本练习将从观察转向分析，要求您比较两种常见的 ILS 模型——高斯函数和sinc平方函数。通过在等效宽度相等的约束下推导和比较它们的分辨能力，您将深入了解仪器设计选择的实际影响。",
            "id": "3845869",
            "problem": "星载遥感系统中的高光谱成像光谱仪可以为其光谱响应函数设计不同的仪器线型（ILS）。考虑两种候选的ILS模型，每种模型都在谱线中心 $\\lambda_{0}$ 处归一化至峰值为1，并以零光谱偏移 $x \\equiv \\lambda - \\lambda_{0}$ 为中心：\n- 高斯响应 $g(x) = \\exp\\!\\big(-x^{2}/(2\\sigma^{2})\\big)$，其标准差为 $\\sigma$。\n- sinc平方响应 $s(x) = \\big(\\sin(x/b)/(x/b)\\big)^2$，其尺度参数为 $b$，其中正弦函数的参数以弧度为单位。\n\n假设两种ILS的实现方式使得它们具有相同的等效宽度（以波长单位计），其定义为（对于单位峰值响应）$W_{\\mathrm{eq}} = \\int_{-\\infty}^{\\infty} R(x)\\,dx$。光谱仪的分辨本领定义为 $R \\equiv \\lambda_{0}/\\Delta\\lambda_{\\mathrm{FWHM}}$，其中 $\\Delta\\lambda_{\\mathrm{FWHM}}$ 是ILS的半峰全宽（FWHM）。\n\n仅从等效宽度、FWHM的基本定义，以及高斯函数和sinc平方函数面积的公认积分公式出发，且不使用任何预先制表的FWHM结果，推导每种ILS的FWHM（用其形状参数表示），然后应用等效宽度相等的条件来消去形状参数，最后计算分辨本领之比 $R_{\\mathrm{sinc}^{2}}/R_{\\mathrm{Gauss}}$。\n\n请将最终答案表示为一个无量纲数，四舍五入到四位有效数字。最终答案中不要包含任何单位，并在任何三角函数参数中使用弧度制。",
            "solution": "首先对问题进行验证，以确保其自洽、有科学依据且为良态问题。\n\n### 步骤1：提取已知条件\n- 高斯仪器线型（ILS）：$g(x) = \\exp(-x^2/(2\\sigma^2))$，其中 $x \\equiv \\lambda - \\lambda_{0}$，形状参数为 $\\sigma$。\n- sinc平方ILS：$s(x) = (\\sin(x/b)/(x/b))^2$，形状参数为 $b$。\n- 两种ILS都在 $x=0$ 处归一化至峰值为 $1$。\n- 等效宽度定义：$W_{\\mathrm{eq}} = \\int_{-\\infty}^{\\infty} R(x)\\,dx$，其中 $R(x)$ 是ILS函数。\n- 两种ILS的等效宽度相等：$W_{\\mathrm{eq,Gauss}} = W_{\\mathrm{eq,sinc^2}}$。\n- 分辨本领定义：$R \\equiv \\lambda_{0}/\\Delta\\lambda_{\\mathrm{FWHM}}$，其中 $\\Delta\\lambda_{\\mathrm{FWHM}}$ 是ILS的半峰全宽。\n- 任务是计算分辨本领之比 $R_{\\mathrm{sinc}^{2}}/R_{\\mathrm{Gauss}}$。\n- 推导过程不得使用预先制表的FWHM结果，必须从基本定义和公认的面积积分公式出发。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题使用了光谱学中仪器线型的标准数学模型（高斯函数和sinc平方函数），这是遥感和光学的核心概念。FWHM、等效宽度和分辨本领的定义都是标准的、具有物理意义的。该问题牢固地建立在物理学和数学的既定原理之上。\n- **良态问题**：该问题提供了推导所要求比率所需的所有必要定义、函数和约束。存在一个唯一的、稳定的数值解。\n- **客观性**：该问题以精确的数学语言陈述，没有主观性或歧义。\n- **结论**：该问题有效。这是一个应用光谱学和微积分基本原理的明确定义的练习。\n\n### 步骤3：结论与行动\n该问题被认定为有效。将提供一个完整的、附带推理过程的解法。\n\n### 解题推导\n\n目标是求出比率 $R_{\\mathrm{sinc}^{2}}/R_{\\mathrm{Gauss}}$。根据分辨本领的定义 $R = \\lambda_0 / \\Delta\\lambda_{\\mathrm{FWHM}}$，该比率可以表示为两种ILS函数的半峰全宽（FWHM）之比：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\frac{\\lambda_0 / \\Delta\\lambda_{\\mathrm{FWHM, sinc^2}}}{\\lambda_0 / \\Delta\\lambda_{\\mathrm{FWHM, Gauss}}} = \\frac{\\Delta\\lambda_{\\mathrm{FWHM, Gauss}}}{\\Delta\\lambda_{\\mathrm{FWHM, sinc^2}}}\n$$\n因此，我们必须推导每种ILS的FWHM，利用等效宽度相等的条件关联它们的形状参数，然后计算所得的比率。\n\n**1. 高斯ILS $g(x)$ 的分析**\n\n首先，我们确定高斯响应 $g(x) = \\exp(-x^2/(2\\sigma^2))$ 的FWHM。FWHM，记为 $\\Delta x_{\\mathrm{Gauss}}$，是函数在其最大值一半处的宽度。由于最大值为 $1$，我们设 $g(x) = 1/2$：\n$$\n\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) = \\frac{1}{2}\n$$\n对两边取自然对数：\n$$\n-\\frac{x^2}{2\\sigma^2} = \\ln\\left(\\frac{1}{2}\\right) = -\\ln(2)\n$$\n解出 $x^2$：\n$$\nx^2 = 2\\sigma^2 \\ln(2)\n$$\n这给出了函数处于半最大值时的 $x$ 值：$x_{\\mathrm{h}} = \\pm \\sigma \\sqrt{2 \\ln(2)}$。FWHM是这两点之间的距离：\n$$\n\\Delta\\lambda_{\\mathrm{FWHM, Gauss}} = \\Delta x_{\\mathrm{Gauss}} = (\\sigma \\sqrt{2\\ln(2)}) - (-\\sigma \\sqrt{2\\ln(2)}) = 2\\sigma\\sqrt{2\\ln(2)}\n$$\n接下来，我们使用给定的定义计算等效宽度 $W_{\\mathrm{eq, Gauss}}$：\n$$\nW_{\\mathrm{eq, Gauss}} = \\int_{-\\infty}^{\\infty} g(x)\\,dx = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\,dx\n$$\n这是一个标准的高斯积分，其形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^2)\\,dx = \\sqrt{\\pi/a}$。此处，$a = 1/(2\\sigma^2)$，所以积分结果为：\n$$\nW_{\\mathrm{eq, Gauss}} = \\sqrt{\\frac{\\pi}{1/(2\\sigma^2)}} = \\sqrt{2\\pi\\sigma^2} = \\sigma\\sqrt{2\\pi}\n$$\n\n**2. sinc平方ILS $s(x)$ 的分析**\n\n现在我们对sinc平方响应 $s(x) = (\\sin(x/b)/(x/b))^2$ 重复此过程。我们通过设 $s(x) = 1/2$ 来找到其FWHM，即 $\\Delta x_{\\mathrm{sinc^2}}$：\n$$\n\\left(\\frac{\\sin(x/b)}{x/b}\\right)^2 = \\frac{1}{2}\n$$\n我们定义一个无量纲变量 $u = x/b$。方程变为：\n$$\n\\left(\\frac{\\sin(u)}{u}\\right)^2 = \\frac{1}{2} \\implies \\frac{|\\sin(u)|}{|u|} = \\frac{1}{\\sqrt{2}}\n$$\n我们关心的是离中心最大值 $u=0$ 点的第一个交点。对于小的 $u>0$，$\\sin(u)$ 是正的，所以我们求解 $\\sin(u)/u = 1/\\sqrt{2}$，即 $\\sin(u) = u/\\sqrt{2}$。这是一个必须通过数值方法求解的超越方程。设正解为 $u_h$。使用数值方法（例如，Newton-Raphson）可得：\n$$\nu_h \\approx 1.391559\n$$\n半最大值点位于 $x_h = \\pm b u_h$。FWHM是它们之间的距离：\n$$\n\\Delta\\lambda_{\\mathrm{FWHM, sinc^2}} = \\Delta x_{\\mathrm{sinc^2}} = (b u_h) - (-b u_h) = 2 b u_h\n$$\n接下来，我们计算等效宽度 $W_{\\mathrm{eq, sinc^2}}$：\n$$\nW_{\\mathrm{eq, sinc^2}} = \\int_{-\\infty}^{\\infty} s(x)\\,dx = \\int_{-\\infty}^{\\infty} \\left(\\frac{\\sin(x/b)}{x/b}\\right)^2 \\,dx\n$$\n使用换元法 $u = x/b$，这意味着 $x = bu$ 且 $dx = b\\,du$：\n$$\nW_{\\mathrm{eq, sinc^2}} = \\int_{-\\infty}^{\\infty} \\left(\\frac{\\sin(u)}{u}\\right)^2 b\\,du = b \\int_{-\\infty}^{\\infty} \\frac{\\sin^2(u)}{u^2} \\,du\n$$\n这是一个公认的定积分，其已知值为 $\\int_{-\\infty}^{\\infty} (\\sin^2(u)/u^2)\\,du = \\pi$。因此：\n$$\nW_{\\mathrm{eq, sinc^2}} = b \\pi\n$$\n\n**3. 应用等效宽度相等的条件**\n\n问题陈述，等效宽度相等：$W_{\\mathrm{eq, Gauss}} = W_{\\mathrm{eq, sinc^2}}$。\n$$\n\\sigma\\sqrt{2\\pi} = b\\pi\n$$\n这使我们能够找到形状参数 $\\sigma$ 和 $b$ 的比率：\n$$\n\\frac{\\sigma}{b} = \\frac{\\pi}{\\sqrt{2\\pi}} = \\sqrt{\\frac{\\pi^2}{2\\pi}} = \\sqrt{\\frac{\\pi}{2}}\n$$\n\n**4. 计算分辨本领之比**\n\n现在我们可以将推导出的FWHM表达式和形状参数的比率代入分辨本领之比的表达式中：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\frac{\\Delta\\lambda_{\\mathrm{FWHM, Gauss}}}{\\Delta\\lambda_{\\mathrm{FWHM, sinc^2}}} = \\frac{2\\sigma\\sqrt{2\\ln(2)}}{2 b u_h} = \\left(\\frac{\\sigma}{b}\\right) \\frac{\\sqrt{2\\ln(2)}}{u_h}\n$$\n代入 $\\sigma/b$ 的表达式：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\left(\\sqrt{\\frac{\\pi}{2}}\\right) \\frac{\\sqrt{2\\ln(2)}}{u_h} = \\frac{\\sqrt{\\pi} \\sqrt{2\\ln(2)}}{\\sqrt{2} u_h} = \\frac{\\sqrt{2\\pi\\ln(2)}}{ \\sqrt{2} u_h} = \\frac{\\sqrt{\\pi\\ln(2)}}{u_h}\n$$\n最后，我们代入常数的数值：\n$$\n\\frac{R_{\\mathrm{sinc}^{2}}}{R_{\\mathrm{Gauss}}} = \\frac{\\sqrt{\\pi \\ln(2)}}{u_h} \\approx \\frac{\\sqrt{(3.14159...)(0.693147...)}}{1.391559...} \\approx \\frac{\\sqrt{2.177586...}}{1.391559...} \\approx \\frac{1.475698...}{1.391559...} \\approx 1.060470...\n$$\n按要求四舍五入到四位有效数字，我们得到最终答案。",
            "answer": "$$\n\\boxed{1.060}\n$$"
        },
        {
            "introduction": "在实际的多波段传感器中，一个光谱波段的响应通常会受到来自相邻波段光的污染，这种现象称为光谱串扰。校正这种串扰是辐射定标中的一个关键步骤。这项高级练习模拟了一个完整而真实的定标工作流程，您将使用正则化线性回归从定标数据中估计传感器的串扰矩阵，然后应用此定标模型来校正外场测量，从而解决遥感领域中一个常见且具有挑战性的反演问题。",
            "id": "3845889",
            "problem": "给定一个线性多波段传感器模型，该模型通过一个三对角响应矩阵来捕捉波段间的光谱串扰。假设有 $B$ 个离散的光谱波段。将真实的波段辐射亮度向量表示为 $s \\in \\mathbb{R}^B$ （单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$），将观测到的（含噪声的）传感器输出表示为 $y \\in \\mathbb{R}^B$，将波段间响应矩阵表示为 $M \\in \\mathbb{R}^{B \\times B}$。该传感器被建模为一个带有加性噪声的线性系统，其关系由下式决定\n$$\ny = M s + \\epsilon,\n$$\n其中 $\\epsilon \\in \\mathbb{R}^B$ 是一个零均值噪声向量。矩阵 $M$ 被假定为三对角矩阵，具有对称的相邻波段串扰，并由波段特定的对角增益 $d_i$ 和相邻波段系数 $c_i$ 参数化：\n- 对于 $i = 0, 1, \\dots, B-1$，主对角线元素为 $M_{i,i} = d_i$。\n- 对于 $i = 0, 1, \\dots, B-2$，上、下副对角线元素为 $M_{i,i+1} = c_i$ 和 $M_{i+1,i} = c_i$。\n所有的 $d_i$ 和 $c_i$ 都是无量纲的。物理辐射亮度的单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n\n您将设计并实现一种定标策略，使用正则化线性回归从定标数据中估计 $d_i$ 和 $c_i$，然后通过反演估计的响应来校正外场测量值。定标激励是已知的，定标观测值由一个已知的真实 $M$ 和已知标准差的加性高斯噪声生成。估计过程必须进行正则化，以控制方差并促进波段间的平滑性。\n\n起点和定义：\n- 假设波段响应满足线性叠加原理，并且在定标期间响应矩阵 $M$ 是固定的、时不变的。这是遥感中小信号辐射定标的一个标准假设，此时非线性探测器效应和饱和效应可以忽略不计。\n- 对于每个定标输入 $s^{(k)} \\in \\mathbb{R}^B$（其中 $k = 1, \\dots, K$），其观测输出遵循 $y^{(k)} = M s^{(k)} + \\epsilon^{(k)}$，其中 $\\epsilon^{(k)}$ 是零均值高斯噪声。\n- $M$ 的三对角对称性意味着，对于给定的邻接索引，对相邻波段的响应在两个方向上的大小是相同的。\n\n定标目标：\n- 通过求解一个正则化最小二乘问题，从定标数据对 $\\{(s^{(k)}, y^{(k)})\\}_{k=1}^K$ 中估计由堆叠 $\\{d_i\\}_{i=0}^{B-1}$ 和 $\\{c_i\\}_{i=0}^{B-2}$ 定义的参数向量 $\\theta \\in \\mathbb{R}^{B+(B-1)}$。构建一个线性设计算子，使得预测的观测值是 $\\theta$ 的线性函数。\n- 将估计问题表述为最小化带有 Tikhonov 正则化的残差平方和，该正则化项惩罚 $d_i$ 在波段间的一阶差分以及 $c_i$ 在邻接索引间的一阶差分。设正则化强度为 $\\lambda > 0$。\n\n校正目标：\n- 给定一个具有相同噪声特性的外场测量值 $y_{\\mathrm{field}} \\in \\mathbb{R}^B$，通过求解一个带有零阶惩罚项的 Tikhonov 正则化逆问题来恢复真实辐射亮度 $s$ 的一个估计值 $\\hat{s}$：\n$$\n\\hat{s} = \\arg\\min_{s} \\left\\| \\hat{M} s - y_{\\mathrm{field}} \\right\\|_2^2 + \\alpha \\left\\| s \\right\\|_2^2,\n$$\n其中 $\\hat{M}$ 是 $M$ 的定标估计值，$\\alpha > 0$ 是反演正则化强度。将 $\\hat{s}$ 以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位表示。\n\n测试套件和数据生成：\n为保证可复现性，所有伪随机数必须使用固定的种子（每个测试用例指定）和标准正态分布生成噪声。在每个案例中，使用 $K = B$ 个定标激励，这些激励由振幅为 $A = 1.0$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 的单波段激发组成，也就是说，对于 $j = 0, \\dots, B-1$，令 $s^{(j)}$ 为在波段 $j$ 上由 $A$ 缩放的单位基向量。对于每个测试用例，根据指定的 $(d, c)$ 构建 $M$，生成每个分量上标准差为 $\\sigma$ 的独立高斯噪声的定标输出 $y^{(k)}$，估计 $(\\hat{d}, \\hat{c})$，建立 $\\hat{M}$，生成一个外场测量值 $y_{\\mathrm{field}} = M s_{\\mathrm{field}} + \\epsilon_{\\mathrm{field}}$（具有相同的 $\\sigma$），并恢复 $\\hat{s}$。使用以下测试用例：\n\n- 案例 $1$ (正常路径)：$B = 5$, $d = [1.00, 0.98, 1.02, 1.01, 0.99]$, $c = [0.06, 0.04, 0.05, 0.03]$, $\\sigma = 0.005$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 0.10$, $\\alpha = 0.01$, 种子 $= 123$, $s_{\\mathrm{field}} = [0.8, 1.2, 0.6, 1.0, 0.7]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n- 案例 $2$ (边界条件：零串扰)：$B = 5$, $d = [1.00, 1.00, 1.00, 1.00, 1.00]$, $c = [0.00, 0.00, 0.00, 0.00]$, $\\sigma = 0.010$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 0.05$, $\\alpha = 0.001$, 种子 $= 7$, $s_{\\mathrm{field}} = [0.5, 1.5, 0.9, 1.1, 0.4]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n- 案例 $3$ (边缘情况：波段数少，噪声较高，正则化较强)：$B = 3$, $d = [0.97, 1.03, 1.00]$, $c = [0.08, 0.07]$, $\\sigma = 0.020$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$, $\\lambda = 1.00$, $\\alpha = 0.05$, 种子 $= 99$, $s_{\\mathrm{field}} = [1.00, 0.50, 1.20]$ $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$。\n\n每个测试用例的必需输出：\n- 计算相邻波段系数的平均绝对误差，定义为\n$$\n\\mathrm{MAE}_c = \\frac{1}{B-1} \\sum_{i=0}^{B-2} \\left| \\hat{c}_i - c_i \\right|,\n$$\n该值是无量纲的。\n- 计算校正后外场信号的辐射亮度均方根误差，\n$$\n\\mathrm{RMSE}_s = \\sqrt{\\frac{1}{B} \\sum_{i=0}^{B-1} \\left( \\hat{s}_i - s_{\\mathrm{field}, i} \\right)^2 },\n$$\n以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个双元素列表 $[\\mathrm{MAE}_c, \\mathrm{RMSE}_s]$。例如，输出格式必须为\n$$\n\\left[ [x_1, y_1], [x_2, y_2], [x_3, y_3] \\right],\n$$\n使用小数值，不含额外文本。输出中的所有辐射亮度量纲均以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位。",
            "solution": "已对用户提供的问题进行了分析，并确认其有效。该问题具有科学依据，提法明确，客观，并包含了推导唯一、可验证解所需的所有必要信息。该问题要求实现一个两阶段过程：首先，使用正则化线性回归从含噪声数据中定标传感器的光谱响应矩阵；其次，通过正则化反演使用定标后的矩阵校正外场测量值。\n\n解决方案分三个主要部分展开：\n1.  定标问题的公式化，以估计传感器响应参数。\n2.  信号校正问题的公式化，以估计真实辐射亮度。\n3.  所提供测试用例的数值实现细节说明。\n\n### 第 1 部分：通过正则化线性回归进行定标\n\n定标任务的核心是估计三对角响应矩阵 $M$ 的参数。传感器模型由 $y = M s + \\epsilon$ 给出。矩阵 $M \\in \\mathbb{R}^{B \\times B}$ 由一组 $B$ 个对角增益 $\\{d_i\\}_{i=0}^{B-1}$ 和 $B-1$ 个相邻波段串扰系数 $\\{c_i\\}_{i=0}^{B-2}$ 定义。我们通过串联这些参数来定义一个单一的参数向量 $\\theta \\in \\mathbb{R}^{2B-1}$：\n$$\n\\theta = [d_0, d_1, \\dots, d_{B-1}, c_0, c_1, \\dots, c_{B-2}]^T\n$$\n我们的目标是将观测向量 $y$ 表示为该参数向量 $\\theta$ 的线性函数。观测信号的第 $i$ 个分量 $y_i$ 可以通过展开矩阵向量积 $Ms$ 写出：\n$$\ny_i = (Ms)_i = \\sum_{j=0}^{B-1} M_{ij} s_j\n$$\n给定 $M$ 的指定三对角结构，其中 $M_{i,i} = d_i$，$M_{i,i+1} = c_i$ 且 $M_{i+1,i} = c_i$，该和简化为：\n$$\ny_i = \\begin{cases}\nd_0 s_0 + c_0 s_{1} & \\text{若 } i=0 \\\\\nc_{i-1} s_{i-1} + d_i s_i + c_i s_{i+1} & \\text{若 } 0 < i < B-1 \\\\\nc_{B-2} s_{B-2} + d_{B-1} s_{B-1} & \\text{若 } i=B-1\n\\end{cases}\n$$\n这表明每个分量 $y_i$ 都是 $\\theta$ 中元素的线性组合。因此，我们可以为单个激励-响应对 $(s, y)$ 构建一个设计矩阵，将 $\\theta$ 映射到 $y$。我们称这个针对单个激励的设计矩阵为 $X_s \\in \\mathbb{R}^{B \\times (2B-1)}$。$X_s$ 的第 $i$ 行包含了表达式 $y_i$ 中 $\\theta$ 的系数。具体来说，$X_s$ 第 $i$ 行的非零项是：\n-   第 $i$ 列的 $s_i$（对应参数 $d_i$）。\n-   第 $B+i-1$ 列的 $s_{i-1}$（对应参数 $c_{i-1}$），适用于 $i>0$。\n-   第 $B+i$ 列的 $s_{i+1}$（对应参数 $c_i$），适用于 $i<B-1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sensor calibration and correction problem for a set of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'B': 5, 'd': [1.00, 0.98, 1.02, 1.01, 0.99], 'c': [0.06, 0.04, 0.05, 0.03],\n         'sigma': 0.005, 'lambda_reg': 0.10, 'alpha': 0.01, 'seed': 123,\n         's_field': [0.8, 1.2, 0.6, 1.0, 0.7]},\n        # Case 2\n        {'B': 5, 'd': [1.00, 1.00, 1.00, 1.00, 1.00], 'c': [0.00, 0.00, 0.00, 0.00],\n         'sigma': 0.010, 'lambda_reg': 0.05, 'alpha': 0.001, 'seed': 7,\n         's_field': [0.5, 1.5, 0.9, 1.1, 0.4]},\n        # Case 3\n        {'B': 3, 'd': [0.97, 1.03, 1.00], 'c': [0.08, 0.07],\n         'sigma': 0.020, 'lambda_reg': 1.00, 'alpha': 0.05, 'seed': 99,\n         's_field': [1.00, 0.50, 1.20]},\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        B = case['B']\n        d_true = np.array(case['d'])\n        c_true = np.array(case['c'])\n        sigma = case['sigma']\n        lambda_val = case['lambda_reg']\n        alpha = case['alpha']\n        seed = case['seed']\n        s_field_true = np.array(case['s_field'])\n        \n        rng = np.random.default_rng(seed)\n\n        # 1. Construct the true response matrix M_true\n        M_true = np.zeros((B, B))\n        np.fill_diagonal(M_true, d_true)\n        for i in range(B - 1):\n            M_true[i, i + 1] = c_true[i]\n            M_true[i + 1, i] = c_true[i]\n\n        # 2. Generate calibration data (stimuli and observations)\n        A = 1.0  # Amplitude of calibration stimuli\n        K = B    # Number of calibration stimuli\n        cal_stimuli = [A * np.eye(B)[i] for i in range(K)]\n        cal_observations = []\n        for s_cal in cal_stimuli:\n            y_clean = M_true @ s_cal\n            noise = rng.normal(0, sigma, size=B)\n            y_noisy = y_clean + noise\n            cal_observations.append(y_noisy)\n\n        # 3. Formulate and solve the regularized least squares problem for theta\n        num_params = B + (B - 1)  # B for d_i, B-1 for c_i\n        A_calib = np.zeros((K * B, num_params))\n        Y_calib = np.concatenate(cal_observations)\n\n        # Populate the global design matrix A_calib\n        for k in range(K):  # Index for stimulus\n            s_k = cal_stimuli[k]\n            for i in range(B):  # Index for observed band\n                row_idx = k * B + i\n                # Coefficient for d_i\n                A_calib[row_idx, i] = s_k[i]\n                # Coefficient for c_{i-1}\n                if i > 0:\n                    A_calib[row_idx, B + i - 1] = s_k[i - 1]\n                # Coefficient for c_i\n                if i  B - 1:\n                    A_calib[row_idx, B + i] = s_k[i + 1]\n\n        # 4. Construct the regularization matrix Gamma\n        num_reg_rows = (B - 1) + (B - 2)\n        Gamma = np.zeros((num_reg_rows, num_params))\n        \n        # Regularization for first differences of d_i\n        for i in range(B - 1):\n            Gamma[i, i] = -1\n            Gamma[i, i + 1] = 1\n\n        # Regularization for first differences of c_i\n        offset = B - 1\n        for i in range(B - 2):\n            Gamma[offset + i, B + i] = -1\n            Gamma[offset + i, B + i + 1] = 1\n        \n        # 5. Solve for the estimated parameters theta_hat\n        # (A_calib^T A_calib + lambda * Gamma^T Gamma) theta = A_calib^T Y\n        AtA = A_calib.T @ A_calib\n        GtG = Gamma.T @ Gamma\n        LHS = AtA + lambda_val * GtG\n        RHS = A_calib.T @ Y_calib\n        \n        theta_hat = np.linalg.solve(LHS, RHS)\n        \n        d_hat = theta_hat[:B]\n        c_hat = theta_hat[B:]\n\n        # 6. Construct M_hat and correct the field measurement\n        M_hat = np.zeros((B, B))\n        np.fill_diagonal(M_hat, d_hat)\n        for i in range(B - 1):\n            M_hat[i, i + 1] = c_hat[i]\n            M_hat[i + 1, i] = c_hat[i]\n\n        # Generate the noisy field measurement y_field\n        y_field_clean = M_true @ s_field_true\n        noise_field = rng.normal(0, sigma, size=B)\n        y_field_noisy = y_field_clean + noise_field\n\n        # Solve the regularized inverse problem for s_hat\n        # (M_hat^T M_hat + alpha * I) s = M_hat^T y_field\n        LHS_s = M_hat.T @ M_hat + alpha * np.eye(B)\n        RHS_s = M_hat.T @ y_field_noisy\n        s_hat = np.linalg.solve(LHS_s, RHS_s)\n\n        # 7. Calculate and store the required metrics\n        mae_c = np.mean(np.abs(c_hat - c_true))\n        rmse_s = np.sqrt(np.mean((s_hat - s_field_true)**2))\n        \n        all_results.append(f\"[{mae_c:.8f}, {rmse_s:.8f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}