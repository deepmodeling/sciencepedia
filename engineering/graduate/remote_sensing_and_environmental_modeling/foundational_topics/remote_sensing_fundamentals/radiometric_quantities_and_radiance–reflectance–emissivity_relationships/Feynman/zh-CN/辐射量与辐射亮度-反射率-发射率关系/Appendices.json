{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在从头开始构建您对核心辐射度量值的理解。通过推导辐亮度、辐照度、反射率和发射率之间的关系，您将巩固遥感领域的理论基础。最后的单位转换任务  是一项实用技能检验，强调了在处理真实传感器数据时进行严谨量纲分析的重要性。",
            "id": "3839555",
            "problem": "一个平面平行、水平均匀的表面被一个空间均匀的下行辐射场照射。考虑基本辐射度学量：辐射通量 $\\Phi$、辐射亮度 $L$、辐射照度 $E$ 和辐射出射度 $M$。从这些量在几何和方向度量方面的微分定义出发，仔细区分它们的（按单位波长定义的）光谱形式 $L_{\\lambda}$、$E_{\\lambda}$ 和 $M_{\\lambda}$ 与它们的（在波长上积分的）宽带形式 $L$、$E$ 和 $M$，并将这些区别与处于热平衡状态的不透明朗伯表面的辐射亮度-反射率-发射率关系联系起来。\n\n您的推导应 (i) 从根据元立体角和投影面积定义 $L$、$E$ 和 $M$ 的第一性原理开始，(ii) 阐明 $L_{\\lambda}$、$E_{\\lambda}$ 和 $M_{\\lambda}$ 如何在有限光谱区间上积分得到其宽带对应量，以及 (iii) 引用双向反射分布函数 (BRDF) 框架，以获得各向同性反射下上行光谱辐射亮度 $L_{\\lambda}$ 和下行光谱辐射照度 $E_{\\lambda}$ 之间的关系，并通过 Kirchhoff 定律阐述光谱发射率 $\\epsilon_{\\lambda}$ 对于不透明表面的作用。\n\n最后，为进行单位分析的实际应用，假设一个高光谱辐射计报告了在 $\\lambda_0 = 650\\,\\mathrm{nm}$ 处的窄带测量值，测得的光谱辐射亮度为 $L_{\\lambda}(\\lambda_0) = 6.314\\,W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}$。请将此报告值转换为相应的 $W\\,m^{-2}\\,sr^{-1}\\,nm^{-1}$ 单位，并明确说明用于证明转换合理性的变量变换和量纲分析。将最终数值答案四舍五入至四位有效数字，并以 $W\\,m^{-2}\\,sr^{-1}\\,nm^{-1}$ 为单位表示。",
            "solution": "辐射度学量源于辐射能量在空间、表面和方向上的传输。辐射通量 $\\Phi$ 是辐射能量传输的速率，定义为 $dQ/dt$，单位为 $W$。辐射亮度 $L$ 量化了在给定方向上穿过一个微分面积元的辐射通量，该通量已按投影面积和元立体角归一化。辐射亮度的基本微分定义是\n$$\nL \\equiv \\frac{d^{2}\\Phi}{dA \\cos\\theta\\, d\\omega},\n$$\n其中 $dA$ 是微分面积，$\\theta$ 是表面法线与传播方向之间的夹角，$d\\omega$ 是微分立体角。$L$ 的单位是 $W\\,m^{-2}\\,sr^{-1}$。\n\n辐射照度 $E$ 是入射到表面上单位面积的辐射通量，\n$$\nE \\equiv \\frac{d\\Phi_{\\text{inc}}}{dA},\n$$\n单位为 $W\\,m^{-2}$。辐射出射度 $M$ 是离开表面单位面积的辐射通量，\n$$\nM \\equiv \\frac{d\\Phi_{\\text{exit}}}{dA},\n$$\n单位也是 $W\\,m^{-2}$。\n\n光谱形式将这些量按单位波长进行分解。引入波长 $\\lambda$ 作为连续变量，光谱辐射亮度、光谱辐射照度和光谱辐射出射度通过对波长进行额外微分来定义：\n$$\nL_{\\lambda} \\equiv \\frac{d^{3}\\Phi}{dA \\cos\\theta\\, d\\omega\\, d\\lambda}, \\quad\nE_{\\lambda} \\equiv \\frac{d^{2}\\Phi_{\\text{inc}}}{dA\\, d\\lambda}, \\quad\nM_{\\lambda} \\equiv \\frac{d^{2}\\Phi_{\\text{exit}}}{dA\\, d\\lambda}.\n$$\n$L_{\\lambda}$ 的单位是 $W\\,m^{-2}\\,sr^{-1}\\,m^{-1}$，$E_{\\lambda}$ 和 $M_{\\lambda}$ 的单位是 $W\\,m^{-2}\\,m^{-1}$。在实践中，通常用 $\\,\\mu m^{-1}$ 或 $\\,nm^{-1}$ 来表示“每波长”这个维度，它们是 $m^{-1}$ 的缩放形式。\n\n宽带量是在波长上对光谱形式进行积分。在一个有限的光谱区间 $\\Lambda = [\\lambda_{1}, \\lambda_{2}]$ 上，宽带量为\n$$\nL = \\int_{\\lambda_{1}}^{\\lambda_{2}} L_{\\lambda}\\, d\\lambda, \\quad\nE = \\int_{\\lambda_{1}}^{\\lambda_{2}} E_{\\lambda}\\, d\\lambda, \\quad\nM = \\int_{\\lambda_{1}}^{\\lambda_{2}} M_{\\lambda}\\, d\\lambda.\n$$\n如果一个传感器具有光谱响应函数 $b(\\lambda)$（无量纲且通常经过归一化），则波段平均辐射亮度可以表示为\n$$\nL_{\\Delta\\lambda} = \\int_{\\Lambda} L_{\\lambda}(\\lambda)\\, b(\\lambda)\\, d\\lambda,\n$$\n在波段中心 $\\lambda_{0}$ 附近的窄带和均匀响应近似下，该式可简化为 $L_{\\Delta\\lambda} \\approx L_{\\lambda}(\\lambda_{0})\\, \\Delta\\lambda$。\n\n为将辐射亮度与反射率和发射率联系起来，我们引入双向反射分布函数 (BRDF)，其定义为\n$$\nf_{r}(\\lambda, \\mathbf{\\omega}_{i} \\rightarrow \\mathbf{\\omega}_{o}) \\equiv \\frac{dL_{o,\\lambda}(\\lambda, \\mathbf{\\omega}_{o})}{dE_{i,\\lambda}(\\lambda, \\mathbf{\\omega}_{i})},\n$$\n单位为 $sr^{-1}$。对于一个理想的各向同性（朗伯）反射体，$f_{r}$ 为常数且等于 $\\rho_{\\lambda}/\\pi$，其中 $\\rho_{\\lambda}$ 是光谱反射率（无量纲）。在入射方向的半球上积分，由反射产生的上行光谱辐射亮度为\n$$\nL_{\\lambda}^{\\text{refl}} = \\frac{\\rho_{\\lambda}}{\\pi}\\, E_{\\lambda}^{\\downarrow},\n$$\n其中 $E_{\\lambda}^{\\downarrow}$ 是下行光谱辐射照度。这源于 $f_{r}$ 的定义以及朗伯 BRDF 将入射能量均匀地重新分布到各个出射方向的事实。\n\n对于发射，考虑一个处于热平衡状态的不透明表面。Kirchhoff 定律指出，光谱发射率 $\\epsilon_{\\lambda}$ 等于光谱吸收率 $\\alpha_{\\lambda}$，对于透射可忽略不计的不透明介质，有 $\\alpha_{\\lambda} = 1 - \\rho_{\\lambda}$，因此\n$$\n\\epsilon_{\\lambda} = 1 - \\rho_{\\lambda}.\n$$\n黑体的方向光谱辐射亮度由 Planck 定律 $B_{\\lambda}(T)$ 给出（单位为 $W\\,m^{-2}\\,sr^{-1}\\,m^{-1}$）。一个灰体朗伯表面发射\n$$\nL_{\\lambda}^{\\text{emit}} = \\epsilon_{\\lambda}\\, B_{\\lambda}(T),\n$$\n其对应的光谱出射度为\n$$\nM_{\\lambda}^{\\text{emit}} = \\int_{\\Omega^{+}} L_{\\lambda}^{\\text{emit}} \\cos\\theta\\, d\\omega = \\epsilon_{\\lambda}\\, \\pi\\, B_{\\lambda}(T),\n$$\n这恢复了各向同性发射中出射度与辐射亮度之间经典的 $\\pi$ 因子关系。总上行光谱辐射亮度是 $L_{\\lambda} = L_{\\lambda}^{\\text{refl}} + L_{\\lambda}^{\\text{emit}}$ 之和，而总宽带辐射亮度则是对 $L_{\\lambda}$ 在波长上进行积分。\n\n我们现在进行所要求的单位转换。报告的测量值为 $L_{\\lambda}(\\lambda_{0}) = 6.314\\,W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}$。根据定义，\n$$\nL_{\\lambda} = \\frac{dL}{d\\lambda},\n$$\n所以 $L_{\\lambda}$ 的数值取决于所使用的波长单位。设 $\\lambda_{\\mu}$ 表示以微米为单位的波长，$\\lambda_{n}$ 表示以纳米为单位的波长。导数的变量变换法则给出\n$$\n\\frac{dL}{d\\lambda_{n}} = \\frac{dL}{d\\lambda_{\\mu}} \\cdot \\frac{d\\lambda_{\\mu}}{d\\lambda_{n}}.\n$$\n由于 $1\\,\\mathrm{nm} = 10^{-3}\\,\\mathrm{\\mu m}$，我们有 $d\\lambda_{\\mu}/d\\lambda_{n} = 10^{-3}$。因此，\n$$\n\\left[L_{\\lambda}\\right]_{nm^{-1}} = \\left[L_{\\lambda}\\right]_{\\mu m^{-1}} \\times 10^{-3}.\n$$\n将此应用于给定值，\n$$\n6.314\\,W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1} \\times 10^{-3} = 6.314 \\times 10^{-3}\\,W\\,m^{-2}\\,sr^{-1}\\,nm^{-1}.\n$$\n数值上，这等于\n$$\n0.006314\\,W\\,m^{-2}\\,sr^{-1}\\,nm^{-1}.\n$$\n四舍五入至四位有效数字得到 $0.006314\\,W\\,m^{-2}\\,sr^{-1}\\,nm^{-1}$，因为给定的数字本身就已是四位有效数字。",
            "answer": "$$\\boxed{0.006314}$$"
        },
        {
            "introduction": "理想的朗伯面是一个有用的理论构造，但大多数真实世界地表的反射特性都具有方向性。本练习通过分析一个由核驱动的BRDF模型描述的各向异性表面，来弥合理论与现实之间的差距。您将推导并量化当此种表面被错误地假设为朗伯体时所产生的误差 ，这是从卫星数据反演地表反射率时一个常见且重要的问题。",
            "id": "3839583",
            "problem": "一个遥感仪器观测一个在来自太阳的准直光照下的表面。下行辐照度为 $E_0$（单位 $\\mathrm{W}\\,\\mathrm{m}^{-2}$），来自太阳天顶角 $\\theta_i$ 和太阳方位角 $\\phi_i$。该仪器在观测天顶角 $\\theta_v$ 和观测方位角 $\\phi_v$ 处测量反射辐亮度 $L_r(\\theta_v,\\phi_v)$（单位 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$）。双向反射分布函数（BRDF）的定义是，对于准直光照，反射辐亮度满足 $L_r(\\theta_v,\\phi_v) = f_r(\\theta_i,\\phi_i;\\theta_v,\\phi_v)\\,E_0$，其中 $f_r$ 的单位是 $\\mathrm{sr}^{-1}$。\n\n基本上，一个朗伯表面的 BRDF 是常数 $f_r = \\rho/\\pi$，其中 $\\rho$ 是方向-半球反射率（无量纲）。对于一个轻度各向异性的表面，考虑核驱动的 BRDF\n$$\nf_r(\\theta_i,\\phi_i;\\theta_v,\\phi_v) = \\frac{\\rho}{\\pi}\\left[1 + \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi)\\right],\n$$\n其中 $\\Delta\\phi = \\phi_v - \\phi_i$，$\\alpha$ 和 $\\beta$ 是满足 $|\\alpha| \\leq 0.2$ 和 $|\\beta| \\leq 0.2$ 的无量纲各向异性系数，所有角度均以度为单位。假设在这种轻度各向异性条件下，互易性和能量守恒条件均得到满足。\n\n假设一个反演算法错误地假定为朗伯行为，并使用 $f_r = \\rho/\\pi$ 从测量的辐亮度 $L_r$ 来反演估算 $\\rho$。仅从上述核心定义出发，推导由此错误假设引起的 $\\rho$ 的反演偏差表达式，该表达式是 $\\theta_i$、$\\theta_v$、$\\Delta\\phi$、$\\alpha$ 和 $\\beta$ 的函数。将偏差表示为反演得到的 $\\rho$ 与真实的 $\\rho$ 之间的差值（无量纲，无单位），其符号表示高估（$>0$）或低估（$0$）。\n\n然后实现一个程序，为以下每个测试用例计算此偏差。所有角度均以度为单位提供，并且必须使用内部转换为弧度的角度来计算余弦和正弦。将每个偏差报告为四舍五入到六位小数的浮点数。程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,...]”）。\n\n测试套件（角度单位为度，辐照度单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$，反射率为无量纲）：\n- 案例 A（一般后向散射，轻度各向异性）：$E_0 = 800$, $\\rho = 0.2$, $\\theta_i = 30$, $\\theta_v = 20$, $\\Delta\\phi = 0$, $\\alpha = 0.1$, $\\beta = 0.05$。\n- 案例 B（朗伯边界）：$E_0 = 800$, $\\rho = 0.2$, $\\theta_i = 30$, $\\theta_v = 20$, $\\Delta\\phi = 0$, $\\alpha = 0$, $\\beta = 0$。\n- 案例 C（前向散射，近掠射角观测）：$E_0 = 600$, $\\rho = 0.3$, $\\theta_i = 40$, $\\theta_v = 75$, $\\Delta\\phi = 180$, $\\alpha = 0.1$, $\\beta = 0.1$。\n- 案例 D（交叉平面，各向异性由 $\\alpha$ 主导）：$E_0 = 900$, $\\rho = 0.25$, $\\theta_i = 50$, $\\theta_v = 40$, $\\Delta\\phi = 90$, $\\alpha = 0.12$, $\\beta = 0.2$。\n- 案例 E（高太阳天顶角，天底观测）：$E_0 = 1000$, $\\rho = 0.1$, $\\theta_i = 80$, $\\theta_v = 0$, $\\Delta\\phi = 0$, $\\alpha = 0.05$, $\\beta = 0.05$。\n- 案例 F（混合各向异性符号）：$E_0 = 700$, $\\rho = 0.22$, $\\theta_i = 55$, $\\theta_v = 65$, $\\Delta\\phi = 45$, $\\alpha = -0.05$, $\\beta = 0.07$。\n\n您的程序应生成单行输出，其中包含按 A 到 F 顺序排列的六个偏差，格式为用方括号括起来的逗号分隔列表，并四舍五入到六位小数。",
            "solution": "该问题要求推导当各向异性表面被错误地视为朗伯表面时，表面反射率 $\\rho$ 的反演偏差。偏差定义为反演反射率 $\\rho_{\\text{retrieved}}$ 与真实反射率 $\\rho_{\\text{true}}$ 之间的差值。\n\n设真实的表面反射率为 $\\rho_{\\text{true}}$。该表面由所提供的核驱动双向反射分布函数（BRDF）表征，我们将其表示为 $f_{r, \\text{true}}$。此 BRDF 将下行准直辐照度 $E_0$ 与仪器测量的反射辐亮度 $L_r$ 联系起来。光照方向由太阳天顶角 $\\theta_i$ 和太阳方位角 $\\phi_i$ 给出，观测方向由观测天顶角 $\\theta_v$ 和观测方位角 $\\phi_v$ 给出。相对方位角为 $\\Delta\\phi = \\phi_v - \\phi_i$。\n\n首先，我们写出从表面反射的真实辐亮度的表达式，这是仪器测量的量。根据问题陈述，该表达式为：\n$$\nL_r = f_{r, \\text{true}}(\\theta_i, \\phi_i; \\theta_v, \\phi_v) E_0\n$$\n各向异性 BRDF 的具体模型如下：\n$$\nf_{r, \\text{true}}(\\theta_i, \\phi_i; \\theta_v, \\phi_v) = \\frac{\\rho_{\\text{true}}}{\\pi}\\left[1 + \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi)\\right]\n$$\n这里，$\\alpha$ 和 $\\beta$ 是无量纲的各向异性系数。将此代入辐亮度方程，得到测量的辐亮度：\n$$\nL_r = \\frac{\\rho_{\\text{true}}}{\\pi}\\left[1 + \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi)\\right] E_0\n$$\n\n接下来，我们考虑反演过程。该算法错误地假设表面是朗伯体。朗伯表面的 BRDF 是一个常数 $f_{r, \\text{Lambert}}$，由下式给出：\n$$\nf_{r, \\text{Lambert}} = \\frac{\\rho}{\\pi}\n$$\n反演算法使用此朗伯模型对测量的辐亮度 $L_r$ 进行反演，以找到反射率的估计值，我们称之为 $\\rho_{\\text{retrieved}}$。该算法的基本模型方程是：\n$$\nL_r = f_{r, \\text{Lambert}} E_0 = \\frac{\\rho_{\\text{retrieved}}}{\\pi} E_0\n$$\n为了求出 $\\rho_{\\text{retrieved}}$ 的值，算法对其求解该方程：\n$$\n\\rho_{\\text{retrieved}} = \\frac{L_r \\pi}{E_0}\n$$\n\n现在，我们将实际测量的辐亮度 $L_r$（来自真实的各向异性表面）的表达式代入算法的反演方程中：\n$$\n\\rho_{\\text{retrieved}} = \\frac{\\pi}{E_0} \\left( \\frac{\\rho_{\\text{true}}}{\\pi}\\left[1 + \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi)\\right] E_0 \\right)\n$$\n分子和分母中的项 $\\pi$ 消掉了，下行辐照度 $E_0$ 也是如此。这表明，对于此特定问题公式，反演的反射率以及因此产生的偏差与入射辐照度水平无关。反演反射率的简化表达式为：\n$$\n\\rho_{\\text{retrieved}} = \\rho_{\\text{true}}\\left[1 + \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi)\\right]\n$$\n\n最后，我们推导反演偏差，其定义为 $\\rho_{\\text{retrieved}} - \\rho_{\\text{true}}$。正偏差表示高估，负偏差表示低估。\n$$\n\\text{Bias} = \\rho_{\\text{retrieved}} - \\rho_{\\text{true}}\n$$\n代入 $\\rho_{\\text{retrieved}}$ 的表达式：\n$$\n\\text{Bias} = \\left( \\rho_{\\text{true}}\\left[1 + \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi)\\right] \\right) - \\rho_{\\text{true}}\n$$\n我们可以从两项中提出公因式 $\\rho_{\\text{true}}$：\n$$\n\\text{Bias} = \\rho_{\\text{true}} \\left( [1 + \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi)] - 1 \\right)\n$$\n$1$ 和 $-1$ 项相互抵消，得到反演偏差的最终表达式：\n$$\n\\text{Bias} = \\rho_{\\text{true}} \\left[ \\alpha \\cos\\theta_i \\cos\\theta_v + \\beta \\sin\\theta_i \\sin\\theta_v \\cos(\\Delta\\phi) \\right]\n$$\n将实现此表达式来计算每个测试用例的偏差。以度为单位给出的角度 $\\theta_i$、$\\theta_v$ 和 $\\Delta\\phi$ 必须转换为弧度，才能在三角函数 $\\cos$ 和 $\\sin$ 中使用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the retrieval bias in surface reflectance for a series of test cases.\n    \n    The bias results from assuming a Lambertian surface model to invert radiance\n    measurements from a surface that is actually mildly anisotropic.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (E0, rho_true, theta_i, theta_v, delta_phi, alpha, beta)\n    # E0 is not needed for the bias calculation, but included for completeness.\n    test_cases = [\n        # Case A\n        (800, 0.2, 30, 20, 0, 0.1, 0.05),\n        # Case B\n        (800, 0.2, 30, 20, 0, 0, 0),\n        # Case C\n        (600, 0.3, 40, 75, 180, 0.1, 0.1),\n        # Case D\n        (900, 0.25, 50, 40, 90, 0.12, 0.2),\n        # Case E\n        (1000, 0.1, 80, 0, 0, 0.05, 0.05),\n        # Case F\n        (700, 0.22, 55, 65, 45, -0.05, 0.07),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        # E0 is case[0], which we can ignore as it cancels out in the bias derivation.\n        rho_true = case[1]\n        theta_i_deg = case[2]\n        theta_v_deg = case[3]\n        delta_phi_deg = case[4]\n        alpha = case[5]\n        beta = case[6]\n\n        # Convert angles from degrees to radians for trigonometric functions\n        theta_i_rad = np.deg2rad(theta_i_deg)\n        theta_v_rad = np.deg2rad(theta_v_deg)\n        delta_phi_rad = np.deg2rad(delta_phi_deg)\n\n        # Calculate the bias using the derived formula:\n        # Bias = rho_true * [alpha * cos(theta_i) * cos(theta_v) + \n        #                   beta * sin(theta_i) * sin(theta_v) * cos(delta_phi)]\n        term1 = alpha * np.cos(theta_i_rad) * np.cos(theta_v_rad)\n        term2 = beta * np.sin(theta_i_rad) * np.sin(theta_v_rad) * np.cos(delta_phi_rad)\n        \n        bias = rho_true * (term1 + term2)\n\n        # Round the result to six decimal places as required\n        results.append(round(bias, 6))\n\n    # Format the final output as a comma-separated list in square brackets\n    # The map(str,...) ensures correct string conversion for all float values.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "除了简化地表特性外，遥感算法也常常简化传感器本身的特性。本练习深入热红外领域，探讨一个关键的误差来源：将传感器在有限带宽内的测量值近似为单一的单色读数。通过计算由此导致的温度反演偏差 ，您将深入了解仪器设计和数据处理假设如何影响热遥感的准确性。",
            "id": "3839559",
            "problem": "您需要实现一个程序，量化因使用光谱辐射的单色近似而对具有有限带宽的传感器造成的温度反演偏差。该场景属于热遥感，其中一个在中心波长附近具有有限光谱响应的辐射计测量一个发射表面在真实物理温度下的波段平均光谱辐射。然后，反演算法错误地假设在中心波长处为单色普朗克光谱辐射，以推断温度。您的任务是针对指定的测试用例，计算此近似引起的偏差。\n\n从以下与上下文相符的基本定义和核心定义开始：\n\n- 理想黑体单位波长的光谱辐射由普朗克定律给出，\n$$\nB_{\\lambda}(T) = \\frac{2 h c^2}{\\lambda^5}\\,\\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k T}\\right)-1},\n$$\n其中 $h$ 是普朗克常数，$c$ 是真空中的光速，$k$ 是玻尔兹曼常数，$\\lambda$ 是波长，$T$ 是以开尔文为单位的绝对温度。\n\n- 真实表面的发射光谱辐射为 $L_{\\lambda}(T) = \\varepsilon(\\lambda)\\,B_{\\lambda}(T)$，其中 $\\varepsilon(\\lambda)$ 是光谱发射率，假设为各向同性的朗伯发射，并且在热红外中忽略了反射的贡献。\n\n- 辐射计在有限带宽上的波段平均光谱辐射为\n$$\n\\overline{L}(T) = \\frac{\\int_{\\lambda_0 - \\Delta\\lambda/2}^{\\lambda_0 + \\Delta\\lambda/2} S(\\lambda)\\,\\varepsilon(\\lambda)\\,B_{\\lambda}(T)\\,\\mathrm{d}\\lambda}{\\int_{\\lambda_0 - \\Delta\\lambda/2}^{\\lambda_0 + \\Delta\\lambda/2} S(\\lambda)\\,\\mathrm{d}\\lambda},\n$$\n其中 $S(\\lambda)$ 是光谱响应。在此问题中，$S(\\lambda)$ 是一个以 $\\lambda_0$ 为中心、宽度为 $\\Delta\\lambda$ 的矩形“顶帽”响应，因此 $S(\\lambda)$ 是恒定的，归一化平均值简化为在该区间上的平均值。\n\n- 单色反演算法假设\n$$\n\\overline{L}(T) \\approx \\varepsilon(\\lambda_0)\\,B_{\\lambda_0}(T_{\\mathrm{ret}}),\n$$\n并通过使用 $\\overline{L}(T)$ 除以 $\\varepsilon(\\lambda_0)$ 的值，在 $\\lambda_0$ 处反演普朗克函数来反演出 $T_{\\mathrm{ret}}$。偏差则为\n$$\n\\Delta T = T_{\\mathrm{ret}} - T_{\\mathrm{true}}.\n$$\n\n请从第一性原理出发，实现以下内容：\n\n1. 对于每个测试用例，通过在区间 $[\\lambda_0 - \\Delta\\lambda/2,\\,\\lambda_0 + \\Delta\\lambda/2]$ 上对 $L_{\\lambda}(T_{\\mathrm{true}}) = \\varepsilon(\\lambda)\\,B_{\\lambda}(T_{\\mathrm{true}})$ 进行数值积分，并用带宽 $\\Delta\\lambda$进行归一化，来计算波段平均光谱辐射 $\\overline{L}(T_{\\mathrm{true}})$。\n\n2. 利用普朗克定律的解析反演，通过求解 $B_{\\lambda_0}(T_{\\mathrm{ret}}) = \\overline{L}(T_{\\mathrm{true}})/\\varepsilon(\\lambda_0)$ 来推导 $T_{\\mathrm{ret}}$。\n\n3. 计算偏差 $\\Delta T = T_{\\mathrm{ret}} - T_{\\mathrm{true}}$。\n\n所有物理量必须使用国际单位制处理：波长单位为米，光谱辐射单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{m}^{-1}$，温度单位为开尔文。您的程序必须为每个案例生成以开尔文为单位的偏差，并四舍五入到六位小数。\n\n使用以下测试套件，旨在涵盖一般情况、近单色边界、宽带边缘情况、发射率变化以及高温维恩区情况。在所有情况下，均使用指定的矩形顶帽光谱响应。\n\n- 案例 $1$ (通用热红外): $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 11\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 1\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 0.98$ (恒定)。\n\n- 案例 $2$ (近单色边界): $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 11\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 0.01\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 0.98$ (恒定)。\n\n- 案例 $3$ (宽带边缘): $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 11\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 3\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 1.0$ (恒定)。\n\n- 案例 $4$ (波段内发射率斜坡): $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 8\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 2\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = \\varepsilon_0 + s \\, \\frac{\\lambda - \\lambda_0}{\\Delta\\lambda/2}$，其中 $\\varepsilon_0 = 0.96$, $s = 0.02$，裁剪到区间 $[0,1]$。\n\n- 案例 $5$ (中波红外，高温): $T_{\\mathrm{true}} = 1000\\,\\mathrm{K}$, $\\lambda_0 = 3.9\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 0.6\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 1.0$ (恒定)。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按案例$1$到$5$的顺序排列，每个偏差都作为浮点数四舍五入到六位小数。例如，输出格式必须像 $[\\Delta T_1,\\Delta T_2,\\Delta T_3,\\Delta T_4,\\Delta T_5]$，其中每个 $\\Delta T_i$ 的单位是开尔文。不应打印其他任何文本。",
            "solution": "在尝试任何解决方案之前，问题陈述都经过了严格的验证过程。\n\n### 第1步：提取给定条件\n- **普朗克定律：** 理想黑体的光谱辐射由 $B_{\\lambda}(T) = \\frac{2 h c^2}{\\lambda^5}\\,\\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k T}\\right)-1}$ 给出，其中 $h$ 是普朗克常数，$c$ 是光速，$k$ 是玻尔兹曼常数，$\\lambda$ 是波长，$T$ 是绝对温度。\n- **发射光谱辐射：** $L_{\\lambda}(T) = \\varepsilon(\\lambda)\\,B_{\\lambda}(T)$，其中 $\\varepsilon(\\lambda)$ 是光谱发射率。\n- **波段平均光谱辐射：** 对于一个以 $\\lambda_0$ 为中心、宽度为 $\\Delta\\lambda$ 的矩形“顶帽”光谱响应 $S(\\lambda)$，这简化为区间内的平均值：$\\overline{L}(T) = \\frac{1}{\\Delta\\lambda} \\int_{\\lambda_0 - \\Delta\\lambda/2}^{\\lambda_0 + \\Delta\\lambda/2} \\varepsilon(\\lambda)\\,B_{\\lambda}(T)\\,\\mathrm{d}\\lambda$。\n- **单色反演假设：** $\\overline{L}(T) \\approx \\varepsilon(\\lambda_0)\\,B_{\\lambda_0}(T_{\\mathrm{ret}})$。反演的温度 $T_{\\mathrm{ret}}$ 通过反演此关系得到。\n- **偏差定义：** $\\Delta T = T_{\\mathrm{ret}} - T_{\\mathrm{true}}$。\n- **单位：** 所有量都必须采用国际单位制。输出偏差 $\\Delta T$ 以开尔文为单位。\n- **测试用例：**\n    - **案例 1:** $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 11\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 1\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 0.98$ (恒定)。\n    - **案例 2:** $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 11\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 0.01\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 0.98$ (恒定)。\n    - **案例 3:** $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 11\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 3\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 1.0$ (恒定)。\n    - **案例 4:** $T_{\\mathrm{true}} = 300\\,\\mathrm{K}$, $\\lambda_0 = 8\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 2\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = \\varepsilon_0 + s \\, \\frac{\\lambda - \\lambda_0}{\\Delta\\lambda/2}$，其中 $\\varepsilon_0 = 0.96$, $s = 0.02$，裁剪到 $[0,1]$。\n    - **案例 5:** $T_{\\mathrm{true}} = 1000\\,\\mathrm{K}$, $\\lambda_0 = 3.9\\,\\mu\\mathrm{m}$, $\\Delta\\lambda = 0.6\\,\\mu\\mathrm{m}$, $\\varepsilon(\\lambda) = 1.0$ (恒定)。\n\n### 第2步：使用提取的给定条件进行验证\n- **科学依据：** 该问题牢固地基于黑体辐射（普朗克定律）和辐射测量的基本原理。所描述的场景——由于传感器带宽有限而导致的温度反演偏差——是热遥感中一个公认且具有实际意义的问题。物理学原理是可靠的。\n- **适定性：** 提供了所有必要的方程、参数和条件。程序被明确定义：通过数值积分求得真实的波段平均辐射，然后通过近似模型的解析反演求得反演温度。该问题对每个测试用例都有一个唯一且稳定的解。\n- **客观性：** 问题使用精确、正式的语言和定量定义来陈述。没有主观或含糊不清的术语。\n- **其他缺陷：**\n    - 问题是可形式化的，并与指定主题直接相关。\n    - 设置是完整和一致的。\n    - 参数（$T$, $\\lambda_0$, $\\Delta\\lambda$）对于环境和工业遥感应用是物理上现实的。\n    - 问题结构是逻辑的，并能导出一个有意义的结果。\n    - 该问题是物理原理的非平凡应用，需要数值和分析步骤。\n    - 结果可以通过独立计算进行科学验证。\n\n### 第3步：结论与行动\n问题是**有效的**。它在科学上是可靠的，适定的，无歧义的，并且在计算上是可行的。将提供一个解决方案。\n\n### 解决方案\n该问题要求计算因使用单色模型近似波段平均辐射测量而产生的温度偏差 $\\Delta T = T_{\\mathrm{ret}} - T_{\\mathrm{true}}$。该解决方案按规定从第一性原理推导。\n\n**理论公式**\n\n问题的核心在于真实波段平均辐射与用于温度反演的简化单色模型之间的相互作用。\n\n首先，我们用国际单位制定义物理常数：\n- 普朗克常数：$h \\approx 6.62607015 \\times 10^{-34}\\,\\mathrm{J} \\cdot \\mathrm{s}$\n- 真空中的光速：$c \\approx 2.99792458 \\times 10^{8}\\,\\mathrm{m} \\cdot \\mathrm{s}^{-1}$\n- 玻尔兹曼常数：$k \\approx 1.380649 \\times 10^{-23}\\,\\mathrm{J} \\cdot \\mathrm{K}^{-1}$\n\n为方便计算，我们定义两个复合常数，第一和第二辐射常数，$C_1$ 和 $C_2$：\n- $C_1 = 2 h c^2$\n- $C_2 = h c / k$\n\n光谱辐射 $B_{\\lambda}(T)$ (单位 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,\\mathrm{m}^{-1}$) 的普朗克定律可以写为：\n$$\nB_{\\lambda}(\\lambda, T) = \\frac{C_1}{\\lambda^5} \\frac{1}{\\exp\\left(\\frac{C_2}{\\lambda T}\\right) - 1}\n$$\n\n该过程对每个测试用例包括三个主要步骤。\n\n**第1步：计算真实的波段平均光谱辐射 $\\overline{L}(T_{\\mathrm{true}})$**\n\n传感器测量由一个处于真实温度 $T_{\\mathrm{true}}$ 的表面发射的辐射。此辐射 $L_{\\lambda}(T) = \\varepsilon(\\lambda) B_{\\lambda}(T)$ 在传感器的光谱带上进行平均。对于指定的顶帽光谱响应，波段平均辐射是在区间 $[\\lambda_1, \\lambda_2]$ 上的 $L_{\\lambda}(T_{\\mathrm{true}})$ 的平均值，其中 $\\lambda_1 = \\lambda_0 - \\Delta\\lambda/2$ 和 $\\lambda_2 = \\lambda_0 + \\Delta\\lambda/2$：\n$$\n\\overline{L}(T_{\\mathrm{true}}) = \\frac{1}{\\Delta\\lambda} \\int_{\\lambda_1}^{\\lambda_2} \\varepsilon(\\lambda) B_{\\lambda}(\\lambda, T_{\\mathrm{true}}) \\, \\mathrm{d}\\lambda\n$$\n该积分没有通用的解析解，必须进行数值计算。\n\n**第2步：计算反演温度 $T_{\\mathrm{ret}}$**\n\n反演算法错误地假设测量的波段平均辐射 $\\overline{L}(T_{\\mathrm{true}})$ 等于在中心波长 $\\lambda_0$ 处，由一个处于反演温度 $T_{\\mathrm{ret}}$ 且发射率为 $\\varepsilon(\\lambda_0)$ 的物体发射的单色辐射：\n$$\n\\overline{L}(T_{\\mathrm{true}}) \\approx \\varepsilon(\\lambda_0) B_{\\lambda_0}(\\lambda_0, T_{\\mathrm{ret}})\n$$\n为了找到 $T_{\\mathrm{ret}}$，我们首先计算算法假定它为黑体测得的有效单色辐射：\n$$\nL_{\\mathrm{mono}} = \\frac{\\overline{L}(T_{\\mathrm{true}})}{\\varepsilon(\\lambda_0)}\n$$\n然后我们求解方程 $L_{\\mathrm{mono}} = B_{\\lambda_0}(\\lambda_0, T_{\\mathrm{ret}})$ 以得到 $T_{\\mathrm{ret}}$。这涉及反演普朗克定律：\n$$\nL_{\\mathrm{mono}} = \\frac{C_1}{\\lambda_0^5} \\frac{1}{\\exp\\left(\\frac{C_2}{\\lambda_0 T_{\\mathrm{ret}}}\\right) - 1}\n$$\n重新整理以求解 $T_{\\mathrm{ret}}$，得到解析解：\n$$\n\\exp\\left(\\frac{C_2}{\\lambda_0 T_{\\mathrm{ret}}}\\right) = \\frac{C_1}{\\lambda_0^5 L_{\\mathrm{mono}}} + 1\n$$\n$$\n\\frac{C_2}{\\lambda_0 T_{\\mathrm{ret}}} = \\ln\\left(\\frac{C_1}{\\lambda_0^5 L_{\\mathrm{mono}}} + 1\\right)\n$$\n$$\nT_{\\mathrm{ret}} = \\frac{C_2}{\\lambda_0} \\left[ \\ln\\left(\\frac{C_1}{\\lambda_0^5 L_{\\mathrm{mono}}} + 1\\right) \\right]^{-1}\n$$\n\n**第3步：计算偏差 $\\Delta T$**\n\n最后一步是计算反演温度与真实温度之间的差值作为偏差：\n$$\n\\Delta T = T_{\\mathrm{ret}} - T_{\\mathrm{true}}\n$$\n\n这个三步过程将对五个测试用例中的每一个进行实施。发射率函数 $\\varepsilon(\\lambda)$ 将根据每个案例的规范来定义，值得注意的是，对于案例4，$\\varepsilon(\\lambda)$ 是 $\\lambda$ 的线性函数，其在中心波长 $\\lambda_0$ 的值就是 $\\varepsilon(\\lambda_0) = \\varepsilon_0 = 0.96$。所有计算都将以国际单位制进行，波长从微米转换为米。每个案例的最终结果将是偏差 $\\Delta T$，单位为开尔文，四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Computes the temperature retrieval bias caused by using a monochromatic\n    approximation for a sensor with a finite bandwidth.\n    \"\"\"\n\n    # Physical constants from scipy.constants in SI units\n    h = constants.h  # Planck constant (J.s)\n    c = constants.c  # Speed of light (m/s)\n    k = constants.k  # Boltzmann constant (J/K)\n\n    # Derived radiation constants\n    C1 = 2 * h * c**2  # First radiation constant (W.m^2)\n    C2 = h * c / k     # Second radiation constant (m.K)\n\n    def planck_radiance(wavelength, temp):\n        \"\"\"\n        Calculates spectral radiance using Planck's law.\n        :param wavelength: Wavelength in meters.\n        :param temp: Temperature in Kelvin.\n        :return: Spectral radiance in W.m^-2.sr^-1.m^-1.\n        \"\"\"\n        # Ensure inputs are numpy arrays for vectorization\n        wavelength = np.asarray(wavelength)\n        temp = np.asarray(temp)\n        \n        # Avoid division by zero or overflow\n        # The exponential term is large, so exp(...) - 1 is approx exp(...)\n        # We handle this by checking if the argument is large.\n        arg = C2 / (wavelength * temp)\n        # For large arguments, exp(arg) is very large, so 1/exp(arg) is near zero.\n        # np.exp handles large arguments by returning inf, so we don't need special handling here.\n        radiance = (C1 / wavelength**5) / (np.exp(arg) - 1.0)\n        return radiance\n\n    def invert_planck(radiance, wavelength):\n        \"\"\"\n        Inverts Planck's law to find temperature.\n        :param radiance: Spectral radiance in W.m^-2.sr^-1.m^-1.\n        :param wavelength: Wavelength in meters.\n        :return: Temperature in Kelvin.\n        \"\"\"\n        # T_ret = (C2 / lambda_0) / ln( (C1 / (lambda_0^5 * L_mono)) + 1 )\n        temp = C2 / (wavelength * np.log(C1 / (wavelength**5 * radiance) + 1.0))\n        return temp\n\n    # Define test cases as a list of dictionaries for clarity\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"T_true\": 300.0,\n            \"lambda_0_um\": 11.0,\n            \"delta_lambda_um\": 1.0,\n            \"emissivity_func\": lambda l, l0, dl: 0.98,\n            \"emissivity_at_lambda0\": 0.98,\n        },\n        {\n            \"name\": \"Case 2\",\n            \"T_true\": 300.0,\n            \"lambda_0_um\": 11.0,\n            \"delta_lambda_um\": 0.01,\n            \"emissivity_func\": lambda l, l0, dl: 0.98,\n            \"emissivity_at_lambda0\": 0.98,\n        },\n        {\n            \"name\": \"Case 3\",\n            \"T_true\": 300.0,\n            \"lambda_0_um\": 11.0,\n            \"delta_lambda_um\": 3.0,\n            \"emissivity_func\": lambda l, l0, dl: 1.0,\n            \"emissivity_at_lambda0\": 1.0,\n        },\n        {\n            \"name\": \"Case 4\",\n            \"T_true\": 300.0,\n            \"lambda_0_um\": 8.0,\n            \"delta_lambda_um\": 2.0,\n            \"emissivity_func\": lambda l, l0, dl: np.clip(0.96 + 0.02 * (l - l0) / (dl / 2), 0, 1),\n            \"emissivity_at_lambda0\": 0.96, # At l = l0, the second term is 0\n        },\n        {\n            \"name\": \"Case 5\",\n            \"T_true\": 1000.0,\n            \"lambda_0_um\": 3.9,\n            \"delta_lambda_um\": 0.6,\n            \"emissivity_func\": lambda l, l0, dl: 1.0,\n            \"emissivity_at_lambda0\": 1.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and convert to SI units\n        T_true = case[\"T_true\"]\n        lambda_0 = case[\"lambda_0_um\"] * 1e-6\n        delta_lambda = case[\"delta_lambda_um\"] * 1e-6\n\n        # Define integration limits\n        lambda_1 = lambda_0 - delta_lambda / 2.0\n        lambda_2 = lambda_0 + delta_lambda / 2.0\n\n        # Define the integrand: L_lambda(T_true) = eps(lambda) * B_lambda(T_true)\n        def integrand(wavelength):\n            eps = case[\"emissivity_func\"](wavelength, lambda_0, delta_lambda)\n            B = planck_radiance(wavelength, T_true)\n            return eps * B\n\n        # Step 1: Numerically integrate to find band-integrated radiance\n        # quad returns a tuple (result, error_estimate)\n        integrated_radiance, _ = integrate.quad(integrand, lambda_1, lambda_2)\n        \n        # Calculate band-averaged radiance\n        L_bar = integrated_radiance / delta_lambda\n\n        # Step 2: Compute retrieved temperature\n        # First, find the monochromatic-equivalent blackbody radiance\n        eps_lambda0 = case[\"emissivity_at_lambda0\"]\n        L_mono = L_bar / eps_lambda0\n        \n        # Invert Planck's law to get the retrieved temperature\n        T_ret = invert_planck(L_mono, lambda_0)\n\n        # Step 3: Compute the bias\n        delta_T = T_ret - T_true\n        \n        # Round to 6 decimal places and store\n        results.append(round(delta_T, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}