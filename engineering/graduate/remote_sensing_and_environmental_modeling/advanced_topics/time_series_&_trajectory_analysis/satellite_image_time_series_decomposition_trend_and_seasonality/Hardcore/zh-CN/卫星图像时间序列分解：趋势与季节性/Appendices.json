{
    "hands_on_practices": [
        {
            "introduction": "时间序列中的季节性成分本质上是一种周期性信号。谐波回归利用傅里叶级数的基本思想，将这种复杂的周期性行为分解为一系列简单的正弦和余弦波，是描述和量化植被物候等季节性现象的基石。本练习将引导你从第一性原理出发，推导谐波回归模型，并将模型系数与具有物理意义的振幅和相位联系起来，从而深入理解季节性模式的数学表达 。",
            "id": "3843828",
            "problem": "从Sentinel-2地表反射率数据中提取的单个像素的归一化植被指数（NDVI；Normalized Difference Vegetation Index）时间序列，以每日为固定间隔进行了多年观测。假设一个加性分解形式为 $Y_t = \\mu(t) + S(t) + \\varepsilon_t$，其中 $Y_t$ 是在第 $t$ 天观测到的NDVI值，$\\mu(t)$ 是一个平滑趋势，$S(t)$ 是一个严格周期性的季节性分量，其基本周期为 $P$，而 $\\varepsilon_t$ 是一个均值为零、方差有限且在时间上不相关的噪声项。季节性分量 $S(t)$ 被假定可以由基频的有限个谐波很好地近似。\n\n从周期函数的定义和三角函数在基本周期整数倍上的正交性出发，并在独立同分布高斯误差的假设下使用最小二乘法原理，推导出一个基于基本周期有限数量 $K$ 个谐波的 $S(t)$ 的谐波回归表示。然后，展示每个谐波的振幅和相位如何用最小二乘法得到的回归系数来表示。\n\n在给出推导后，使用以下针对 $K = 3$ 个谐波的值（这些值是通过首先对 $Y_t$ 进行去趋势处理，在跨越整数年且周期 $P = 365$ 天的 $N$ 个日采样点上通过最小二乘法来估计 $S(t)$ 而获得的）：\n- 对于 $k = 1$：$a_1 = 0.12$, $b_1 = -0.05$。\n- 对于 $k = 2$：$a_2 = 0.08$, $b_2 = 0.02$。\n- 对于 $k = 3$：$a_3 = 0.03$, $b_3 = -0.01$。\n\n按 $k = 1, 2, 3$ 的顺序计算每个谐波的振幅和相位。振幅以反射率（无单位）表示，相位以弧度表示。通过适当的映射将相位约束在区间 $[0, 2\\pi)$ 内。将最终的数值结果四舍五入到四位有效数字。\n\n您的最终答案必须是一个单行矩阵，按顺序包含六个值 $(A_1, \\phi_1, A_2, \\phi_2, A_3, \\phi_3)$，其中 $A_k$ 表示第 $k$ 个谐波的振幅，$\\phi_k$ 表示相位。",
            "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据，提法明确，客观，并包含完整解答所需的所有信息。它描述了谐波分析在遥感时间序列数据中的一个标准应用，这是一个成熟的科学方法。\n\n该问题要求两个主要部分：首先，从第一性原理推导周期性季节分量的谐波回归模型；其次，根据给定的回归系数进行振幅和相位的数值计算。\n\n**第1部分：谐波回归及振幅-相位表示的推导**\n\n我们从时间序列 $Y_t$ 的加性分解模型开始：\n$$ Y_t = \\mu(t) + S(t) + \\varepsilon_t $$\n其中 $t$ 代表时间，$\\mu(t)$ 是趋势项，$S(t)$ 是季节性分量，而 $\\varepsilon_t$ 是一个随机误差项。问题陈述 $S(t)$ 是严格周期的，其基本周期为 $P$。任何此类良态周期函数都可以用傅里叶级数表示。基本角频率为 $\\omega = \\frac{2\\pi}{P}$。季节性分量 $S(t)$ 由 $K$ 个谐波的有限和来近似：\n$$ S(t) \\approx \\sum_{k=1}^{K} \\left( a_k \\cos(k \\omega t) + b_k \\sin(k \\omega t) \\right) $$\n问题陈述时间序列 $Y_t$ 已经过去趋势化以得到季节性分量的估计值。我们将这些去趋势后的观测值表示为 $s_t = Y_t - \\hat{\\mu}(t)$。我们的目标是找到系数 $a_k$ 和 $b_k$ 以使模型最佳拟合这些观测值。在独立同分布高斯误差的假设下，最小二乘法原理等价于最大似然估计。观测值 $s_t$ 与模型之间的残差平方和（$SSR$）为：\n$$ SSR(a_1, ..., a_K, b_1, ..., b_K) = \\sum_{t=1}^{N} \\left( s_t - \\sum_{k=1}^{K} \\left[ a_k \\cos\\left(\\frac{2\\pi k t}{P}\\right) + b_k \\sin\\left(\\frac{2\\pi k t}{P}\\right) \\right] \\right)^2 $$\n为使 $SSR$ 最小化，我们对每个系数求偏导数并令其为零。对于任意系数 $a_j$（其中 $j \\in \\{1, ..., K\\}$）：\n$$ \\frac{\\partial SSR}{\\partial a_j} = \\sum_{t=1}^{N} 2 \\left( s_t - \\sum_{k=1}^{K} [...] \\right) \\left( - \\cos\\left(\\frac{2\\pi j t}{P}\\right) \\right) = 0 $$\n$$ \\sum_{t=1}^{N} s_t \\cos\\left(\\frac{2\\pi j t}{P}\\right) = \\sum_{t=1}^{N} \\cos\\left(\\frac{2\\pi j t}{P}\\right) \\sum_{k=1}^{K} \\left[ a_k \\cos\\left(\\frac{2\\pi k t}{P}\\right) + b_k \\sin\\left(\\frac{2\\pi k t}{P}\\right) \\right] $$\n问题指明数据跨越整数年，即 $N = mP$（其中 $m$ 为某个整数）。在这种情况下，离散三角函数在区间 $t \\in \\{1, ..., N\\}$ 上表现出正交性。相关的恒等式为：\n$$ \\sum_{t=1}^{N} \\cos\\left(\\frac{2\\pi k t}{P}\\right) \\sin\\left(\\frac{2\\pi j t}{P}\\right) = 0 \\quad \\text{对所有 } k, j $$\n$$ \\sum_{t=1}^{N} \\cos\\left(\\frac{2\\pi k t}{P}\\right) \\cos\\left(\\frac{2\\pi j t}{P}\\right) = \\begin{cases} \\frac{N}{2}  \\text{若 } k=j \\neq 0, P/2 \\\\ 0  \\text{若 } k \\neq j \\end{cases} $$\n$$ \\sum_{t=1}^{N} \\sin\\left(\\frac{2\\pi k t}{P}\\right) \\sin\\left(\\frac{2\\pi j t}{P}\\right) = \\begin{cases} \\frac{N}{2}  \\text{若 } k=j \\neq 0, P/2 \\\\ 0  \\text{若 } k \\neq j \\end{cases} $$\n将这些正交关系应用于 $\\frac{\\partial SSR}{\\partial a_j}$ 的展开和式，所有 $k \\neq j$ 的项都变为零。我们剩下：\n$$ \\sum_{t=1}^{N} s_t \\cos\\left(\\frac{2\\pi j t}{P}\\right) = \\sum_{t=1}^{N} a_j \\cos^2\\left(\\frac{2\\pi j t}{P}\\right) = a_j \\frac{N}{2} $$\n求解 $a_j$ 得到最小二乘估计值：\n$$ a_j = \\frac{2}{N} \\sum_{t=1}^{N} s_t \\cos\\left(\\frac{2\\pi j t}{P}\\right) $$\n类似地，对 $b_j$ 求导：\n$$ \\frac{\\partial SSR}{\\partial b_j} = \\sum_{t=1}^{N} 2 \\left( s_t - \\sum_{k=1}^{K} [...] \\right) \\left( - \\sin\\left(\\frac{2\\pi j t}{P}\\right) \\right) = 0 $$\n应用正交性得到：\n$$ \\sum_{t=1}^{N} s_t \\sin\\left(\\frac{2\\pi j t}{P}\\right) = \\sum_{t=1}^{N} b_j \\sin^2\\left(\\frac{2\\pi j t}{P}\\right) = b_j \\frac{N}{2} $$\n$$ b_j = \\frac{2}{N} \\sum_{t=1}^{N} s_t \\sin\\left(\\frac{2pi j t}{P}\\right) $$\n这样就完成了谐波回归系数的推导。\n\n接下来，我们将第 $k$ 个谐波 $S_k(t) = a_k \\cos(k \\omega t) + b_k \\sin(k \\omega t)$ 转换为振幅-相位形式 $S_k(t) = A_k \\cos(k \\omega t - \\phi_k)$。\n使用三角恒等式 $\\cos(X - Y) = \\cos(X)\\cos(Y) + \\sin(X)\\sin(Y)$，我们展开振幅-相位形式：\n$$ A_k \\cos(k \\omega t - \\phi_k) = A_k (\\cos(k \\omega t)\\cos(\\phi_k) + \\sin(k \\omega t)\\sin(\\phi_k)) $$\n$$ S_k(t) = (A_k \\cos(\\phi_k)) \\cos(k \\omega t) + (A_k \\sin(\\phi_k)) \\sin(k \\omega t) $$\n通过将 $\\cos(k \\omega t)$ 和 $\\sin(k \\omega t)$ 的系数与原始形式进行比较，我们建立以下关系：\n$$ a_k = A_k \\cos(\\phi_k) $$\n$$ b_k = A_k \\sin(\\phi_k) $$\n为了求出振幅 $A_k$，我们将这两个方程平方后相加：\n$$ a_k^2 + b_k^2 = A_k^2 \\cos^2(\\phi_k) + A_k^2 \\sin^2(\\phi_k) = A_k^2 (\\cos^2(\\phi_k) + \\sin^2(\\phi_k)) = A_k^2 $$\n由于振幅是非负量，我们有：\n$$ A_k = \\sqrt{a_k^2 + b_k^2} $$\n为了求出相位 $\\phi_k$，我们将第二个方程除以第一个方程：\n$$ \\frac{b_k}{a_k} = \\frac{A_k \\sin(\\phi_k)}{A_k \\cos(\\phi_k)} = \\tan(\\phi_k) $$\n相位角 $\\phi_k$ 必须通过同时考虑 $a_k$（余弦系数，类似于x坐标）和 $b_k$（正弦系数，类似于y坐标）的符号来确定，以将角度置于正确的象限。这可以通过使用双参数反正切函数（通常表示为 $\\text{atan2}(y, x)$）来实现。因此，$\\phi_k' = \\text{atan2}(b_k, a_k)$，其返回值通常在 $(-\\pi, \\pi]$ 区间内。\n问题要求相位在区间 $[0, 2\\pi)$ 内。我们通过以下映射实现这一点：\n$$ \\phi_k = \\begin{cases} \\phi_k'  \\text{若 } \\phi_k' \\ge 0 \\\\ \\phi_k' + 2\\pi  \\text{若 } \\phi_k'  0 \\end{cases} $$\n\n**第2部分：数值计算**\n\n我们已知 $K=3$ 个谐波和 $P=365$ 的系数。我们计算每个谐波的振幅 $A_k$ 和相位 $\\phi_k$，并四舍五入到四位有效数字。\n\n对于 $k=1$：$a_1 = 0.12$, $b_1 = -0.05$。\n$$ A_1 = \\sqrt{(0.12)^2 + (-0.05)^2} = \\sqrt{0.0144 + 0.0025} = \\sqrt{0.0169} = 0.13 $$\n保留四位有效数字，$A_1 = 0.1300$。\n相位由 $\\phi_1' = \\text{atan2}(-0.05, 0.12)$ 给出。由于 $a_1  0$ 且 $b_1  0$，角度位于第四象限。\n$$ \\phi_1' \\approx -0.39479 \\text{ 弧度} $$\n映射到 $[0, 2\\pi)$：\n$$ \\phi_1 = -0.39479 + 2\\pi \\approx 5.88839... $$\n保留四位有效数字，$\\phi_1 = 5.888$。\n\n对于 $k=2$：$a_2 = 0.08$, $b_2 = 0.02$。\n$$ A_2 = \\sqrt{(0.08)^2 + (0.02)^2} = \\sqrt{0.0064 + 0.0004} = \\sqrt{0.0068} \\approx 0.082462... $$\n保留四位有效数字，$A_2 = 0.08246$。\n相位由 $\\phi_2' = \\text{atan2}(0.02, 0.08)$ 给出。由于 $a_2  0$ 且 $b_2  0$，角度位于第一象限。\n$$ \\phi_2' = \\arctan(0.25) \\approx 0.244978... \\text{ 弧度} $$\n该值已在 $[0, 2\\pi)$ 范围内，因此无需映射。\n保留四位有效数字，$\\phi_2 = 0.2450$。\n\n对于 $k=3$：$a_3 = 0.03$, $b_3 = -0.01$。\n$$ A_3 = \\sqrt{(0.03)^2 + (-0.01)^2} = \\sqrt{0.0009 + 0.0001} = \\sqrt{0.0010} \\approx 0.031622... $$\n保留四位有效数字，$A_3 = 0.03162$。\n相位由 $\\phi_3' = \\text{atan2}(-0.01, 0.03)$ 给出。由于 $a_3  0$ 且 $b_3  0$，角度位于第四象限。\n$$ \\phi_3' \\approx -0.32175... \\text{ 弧度} $$\n映射到 $[0, 2\\pi)$：\n$$ \\phi_3 = -0.32175 + 2\\pi \\approx 5.96143... $$\n保留四位有效数字，$\\phi_3 = 5.961$。\n\n最终结果 $(A_1, \\phi_1, A_2, \\phi_2, A_3, \\phi_3)$ 为 $(0.1300, 5.888, 0.08246, 0.2450, 0.03162, 5.961)$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0.1300  5.888  0.08246  0.2450  0.03162  5.961 \\end{pmatrix} } $$"
        },
        {
            "introduction": "卫星时间序列数据常常受到残余云、云阴影或传感器噪声的污染，产生破坏模型拟合的异常值。本练习将介绍一种稳健的趋势估计算法——基于Huber损失的迭代重加权最小二乘法（IRLS），它能有效降低异常值对趋势线的影响。通过编程实现并比较稳健方法与传统最小二乘法的结果，你将直观地看到一个更准确的趋势估计如何改善后续季节性振幅提取的精度 。",
            "id": "3843866",
            "problem": "地表反射率（无量纲小数）的卫星影像时间序列被建模为一个加性分解，包含一个缓慢变化的趋势分量和一个周期性的季节分量。设时间索引 $t \\in \\{0,1,\\dots,N-1\\}$ 处的观测值为 $y_t$，并假设\n$$\ny_t = \\tau(t) + s(t) + \\varepsilon_t + o_t,\n$$\n其中 $\\tau(t)$ 是趋势分量，$s(t)$ 是季节分量，$\\varepsilon_t$ 是零均值噪声，$o_t$ 代表偶然的异常值，例如，由未完全校正的残余云或双向反射效应引起。季节分量被假设具有已知周期 $P$（以采样点数为单位），并且可由单个谐波表示，\n$$\ns(t) = a \\cos\\left(\\frac{2\\pi t}{P}\\right) + b \\sin\\left(\\frac{2\\pi t}{P}\\right),\n$$\n其振幅为 $A = \\sqrt{a^2 + b^2}$，角度以弧度为单位。\n\n为了减小异常值对趋势估计的影响，您需要使用Huber损失为 $\\tau(t)$ 构建一个稳健的估计器。具体来说，用一阶多项式 $\\tau(t) = \\beta_0 + \\beta_1 t$ 表示趋势，并通过最小化Huber目标函数来估计参数 $\\beta_0, \\beta_1$：\n$$\nJ(\\beta_0,\\beta_1) = \\sum_{t=0}^{N-1} \\rho_\\delta\\!\\left(y_t - \\beta_0 - \\beta_1 t\\right),\n$$\n其中 $\\rho_\\delta(r)$ 是阈值为 $\\delta  0$ 的Huber损失，\n$$\n\\rho_\\delta(r) = \n\\begin{cases}\n\\frac{1}{2} r^2,  \\text{如果 } |r| \\le \\delta, \\\\\n\\delta \\left(|r| - \\frac{1}{2}\\delta\\right),  \\text{如果 } |r|  \\delta.\n\\end{cases}\n$$\n估计趋势后，通过对序列进行去趋势处理，并对 $\\cos\\left(\\frac{2\\pi t}{P}\\right)$ 和 $\\sin\\left(\\frac{2\\pi t}{P}\\right)$ 进行最小二乘谐波回归，来获得季节振幅 $A$。使用非稳健的普通最小二乘趋势估计重复振幅估计过程以进行比较。任务是实现迭代重加权最小二乘法（IRLS）来解决稳健的Huber趋势估计问题，然后量化稳健趋势相对于最小二乘趋势对估计的季节振幅的影响。\n\n您的程序必须：\n- 为每个测试用例，根据指定的加性模型生成合成时间序列 $y_t$，包含以下分量：\n  - 趋势 $\\tau(t) = \\beta_0 + \\beta_1 t$。\n  - 季节分量 $s(t) = A_{\\text{true}} \\cos\\left(\\frac{2\\pi t}{P}\\right)$（数据生成时使用零相位）。\n  - 标准差为 $\\sigma$ 的高斯噪声 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n  - 在指定比例的索引处均匀随机注入异常值 $o_t$，其大小由一个独立的符号乘以指定的异常值幅值得到。\n- 使用以下方法估计趋势系数 $(\\beta_0,\\beta_1)$：\n  - 对 $\\{(t,y_t)\\}$ 使用普通最小二乘法（非稳健）。\n  - 对 $\\{(t,y_t)\\}$ 使用迭代重加权最小二乘法进行阈值为 $\\delta$ 的稳健Huber回归。\n- 对于两种趋势估计，使用已知周期 $P$，通过对去趋势后的序列进行最小二乘谐波回归来计算季节振幅 $A$。\n- 对于每个测试用例，返回一个浮点数，等于 $A_{\\text{Huber}} - A_{\\text{OLS}}$，以反射率单位表示，形式为十进制数（非百分比）。\n\n使用以下参数值测试套件，其选择旨在覆盖卫星影像时间序列分解中的典型和边缘情况。对于每个元组，参数为 $(N, P, \\beta_0, \\beta_1, A_{\\text{true}}, \\sigma, f_{\\text{out}}, M_{\\text{out}}, \\delta)$：\n1. $(N,P,\\beta_0,\\beta_1,A_{\\text{true}},\\sigma,f_{\\text{out}},M_{\\text{out}},\\delta) = (60, 12, 0.4, 0.0015, 0.15, 0.02, 0.10, 0.35, 0.05)$。\n2. $(N,P,\\beta_0,\\beta_1,A_{\\text{true}},\\sigma,f_{\\text{out}},M_{\\text{out}},\\delta) = (60, 12, 0.5, 0.0000, 0.12, 0.01, 0.00, 0.00, 0.05)$。\n3. $(N,P,\\beta_0,\\beta_1,A_{\\text{true}},\\sigma,f_{\\text{out}},M_{\\text{out}},\\delta) = (48, 12, 0.3, 0.0020, 0.08, 0.03, 0.25, 0.50, 0.03)$。\n4. $(N,P,\\beta_0,\\beta_1,A_{\\text{true}},\\sigma,f_{\\text{out}},M_{\\text{out}},\\delta) = (36, 12, 0.6, -0.0010, 0.10, 0.015, 0.15, 0.40, 0.005)$。\n5. $(N,P,\\beta_0,\\beta_1A_{\\text{true}},\\sigma,f_{\\text{out}},M_{\\text{out}},\\delta) = (24, 12, 0.45, 0.0010, 0.00, 0.02, 0.20, 0.30, 0.05)$。\n\n所有振幅和差值都必须以反射率单位（无量纲小数）表示。角度以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中 $r_i$ 是测试用例 $i$ 的振幅差 $A_{\\text{Huber}} - A_{\\text{OLS}}$。",
            "solution": "所提出的问题是有效的，因为它在统计信号处理方面有科学依据，定义明确，目标清晰，并提供了构建唯一、可验证解决方案所需的所有信息。其基础方法——加性时间序列分解、普通最小二乘法（OLS）、Huber回归和迭代重加权最小二乘法（IRLS）——都是标准的，并且在数学上是合理的。我们将进行详细的解答。\n\n问题的核心是比较非稳健与稳健的趋势估计对后续季节信号振幅估计的影响。时间序列建模如下：\n$$\ny_t = \\tau(t) + s(t) + \\varepsilon_t + o_t\n$$\n其中 $y_t$ 是时间 $t$ 的观测值，$\\tau(t)$ 是线性趋势，$s(t)$ 是正弦季节分量，$\\varepsilon_t$ 是高斯噪声，$o_t$ 代表零星的异常值。\n\n**步骤1：合成数据生成**\n对于每个测试用例，我们合成一个长度为 $N$ 的时间序列。时间向量为 $\\mathbf{t} = [0, 1, \\dots, N-1]^T$。\n1.  **趋势分量**：线性趋势由 $\\tau(t) = \\beta_0 + \\beta_1 t$ 给出。\n2.  **季节分量**：问题指定了一个季节信号，其周期为已知的 $P$，数据生成时使用零相位，$s(t) = A_{\\text{true}} \\cos(2\\pi t/P)$。\n3.  **噪声分量**：独立同分布（I.i.d.）的高斯噪声样本 $\\varepsilon_t$ 从 $\\mathcal{N}(0, \\sigma^2)$ 中抽取。\n4.  **异常值分量**：将异常值添加到比例为 $f_{\\text{out}}$ 的数据点上。我们计算异常值的数量 $N_{\\text{out}} = \\text{round}(N \\cdot f_{\\text{out}})$，随机选择 $N_{\\text{out}}$ 个唯一的时间索引，并在这些索引处设置 $o_t = \\pm M_{\\text{out}}$，符号随机选择。对于所有其他索引，$o_t = 0$。\n\n最终观测到的时间序列是这四个分量的总和：$\\mathbf{y} = \\boldsymbol{\\tau} + \\mathbf{s} + \\boldsymbol{\\varepsilon} + \\mathbf{o}$。所有随机数生成均使用固定种子，以确保解决方案是可复现的。\n\n**步骤2：趋势估计**\n趋势被建模为线性函数 $\\tau(t) = \\beta_0 + \\beta_1 t$。在矩阵形式中，我们在模型 $\\mathbf{y} \\approx \\mathbf{X}\\boldsymbol{\\beta}$ 中寻找参数向量 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]^T$，其中 $\\mathbf{X}$ 是一个 $N \\times 2$ 的设计矩阵，其列分别为截距项和线性项：\n$$\n\\mathbf{X} = \\begin{pmatrix} 1  0 \\\\ 1  1 \\\\ \\vdots  \\vdots \\\\ 1  N-1 \\end{pmatrix}\n$$\n\n**A. 普通最小二乘（OLS）趋势估计**\nOLS方法寻找使残差平方和 $\\|\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}\\|_2^2$ 最小化的参数 $\\boldsymbol{\\beta}$。这是一个标准的线性回归问题，其解由正规方程给出：\n$$\n\\hat{\\boldsymbol{\\beta}}_{\\text{OLS}} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}\n$$\n这个解对异常值很敏感，因为大的残差会被平方，从而对拟合产生不成比例的高影响。估计的趋势为 $\\hat{\\boldsymbol{\\tau}}_{\\text{OLS}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}_{\\text{OLS}}$。\n\n**B. 通过迭代重加权最小二乘法（IRLS）进行稳健Huber趋势估计**\nHuber M-估计器通过使用Huber损失 $\\rho_\\delta(r)$ 来最小化一个不同的目标函数 $J(\\boldsymbol{\\beta}) = \\sum_{t=0}^{N-1} \\rho_\\delta(y_t - (\\mathbf{X}\\boldsymbol{\\beta})_t)$。对于小残差（$|r| \\le \\delta$），该损失函数的行为与OLS类似，呈二次方关系；但对于大残差（$|r|  \\delta$），其行为呈线性关系，这减少了异常值的影响。\n\n这个优化问题使用IRLS求解。该算法迭代地解决一个加权最小二乘问题，其中权重根据前一次迭代的残差进行调整。参数的更新步骤是：\n$$\n\\hat{\\boldsymbol{\\beta}}^{(k+1)} = (\\mathbf{X}^T\\mathbf{W}^{(k)}\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{W}^{(k)}\\mathbf{y}\n$$\n矩阵 $\\mathbf{W}^{(k)}$ 是在第 $k$ 次迭代时权重 $w_t^{(k)}$ 的对角矩阵。每个权重是相应残差 $r_t^{(k)} = y_t - (\\mathbf{X}\\hat{\\boldsymbol{\\beta}}^{(k)})_t$ 的函数：\n$$\nw_t^{(k)} = \\begin{cases} 1,  \\text{如果 } |r_t^{(k)}| \\le \\delta \\\\ \\delta/|r_t^{(k)}|,  \\text{如果 } |r_t^{(k)}|  \\delta \\end{cases}\n$$\n该算法按以下步骤进行：\n1.  初始化参数 $\\hat{\\boldsymbol{\\beta}}^{(0)}$，通常使用OLS解 $\\hat{\\boldsymbol{\\beta}}_{\\text{OLS}}$。\n2.  迭代计算残差、更新权重并解决加权最小二乘问题。为了数值稳定性，更新不是通过矩阵求逆执行，而是通过解决一个等价的标准最小二乘问题来执行。\n3.  迭代持续进行，直到连续迭代之间参数向量 $\\hat{\\boldsymbol{\\beta}}$ 的变化小于指定的容差，或者达到最大迭代次数。\n收敛解 $\\hat{\\boldsymbol{\\beta}}_{\\text{Huber}}$ 给出稳健估计的趋势 $\\hat{\\boldsymbol{\\tau}}_{\\text{Huber}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}_{\\text{Huber}}$。\n\n**步骤3：季节振幅估计**\n从原始数据中减去估计的趋势以获得去趋势序列。对两种趋势估计都执行此操作：\n$\\mathbf{d}_{\\text{OLS}} = \\mathbf{y} - \\hat{\\boldsymbol{\\tau}}_{\\text{OLS}}$ 和 $\\mathbf{d}_{\\text{Huber}} = \\mathbf{y} - \\hat{\\boldsymbol{\\tau}}_{\\text{Huber}}$\n然后，我们将一个谐波模型拟合到每个去趋势序列。该模型为 $d(t) \\approx a \\cos(2\\pi t/P) + b \\sin(2\\pi t/P)$。系数 $\\boldsymbol{\\gamma} = [a, b]^T$ 通过最小二乘法找到。此回归的设计矩阵为：\n$$\n\\mathbf{S} = \\begin{pmatrix}\n\\cos\\left(\\frac{2\\pi \\cdot 0}{P}\\right)  \\sin\\left(\\frac{2\\pi \\cdot 0}{P}\\right) \\\\\n\\vdots  \\vdots \\\\\n\\cos\\left(\\frac{2\\pi \\cdot (N-1)}{P}\\right)  \\sin\\left(\\frac{2\\pi \\cdot (N-1)}{P}\\right)\n\\end{pmatrix}\n$$\n系数的解为 $\\hat{\\boldsymbol{\\gamma}} = (\\mathbf{S}^T\\mathbf{S})^{-1}\\mathbf{S}^T\\mathbf{d}$。这将产生系数向量 $\\hat{\\boldsymbol{\\gamma}}_{\\text{OLS}}$ 和 $\\hat{\\boldsymbol{\\gamma}}_{\\text{Huber}}$。相应的振幅是这些向量的欧几里得范数：\n$A_{\\text{OLS}} = \\|\\hat{\\boldsymbol{\\gamma}}_{\\text{OLS}}\\|_2$ 和 $A_{\\text{Huber}} = \\|\\hat{\\boldsymbol{\\gamma}}_{\\text{Huber}}\\|_2$\n\n**步骤4：最终比较**\n每个测试用例的最终度量指标是两个估计振幅之间的差异，它量化了稳健趋势估计的效果：\n$$\n\\Delta A = A_{\\text{Huber}} - A_{\\text{OLS}}\n$$\n非零值表明去趋势方法的选择会影响季节性分析。在存在异常值的情况下，OLS趋势可能存在显著偏差，导致去趋势序列受到污染，振幅估计不准确。Huber回归是稳健的，因此应能产生更准确的趋势，从而得到更可靠的季节振幅。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lstsq\n\ndef generate_time_series(N, P, beta0, beta1, A_true, sigma, f_out, M_out, rng):\n    \"\"\"Generates a synthetic time series based on the additive model.\"\"\"\n    t = np.arange(N)\n    \n    # 1. Trend component\n    trend = beta0 + beta1 * t\n    \n    # 2. Seasonal component\n    seasonal = A_true * np.cos(2 * np.pi * t / P)\n    \n    # 3. Noise component\n    noise = rng.normal(0, sigma, N)\n    \n    # 4. Outlier component\n    outliers = np.zeros(N)\n    n_outliers = int(round(f_out * N))\n    if n_outliers > 0:\n        outlier_indices = rng.choice(N, size=n_outliers, replace=False)\n        outlier_signs = rng.choice([-1, 1], size=n_outliers)\n        outliers[outlier_indices] = outlier_signs * M_out\n        \n    y = trend + seasonal + noise + outliers\n    return t, y\n\ndef estimate_trend_ols(t, y):\n    \"\"\"Estimates trend coefficients using Ordinary Least Squares.\"\"\"\n    X = np.stack([np.ones_like(t), t], axis=1)\n    beta_ols, _, _, _ = lstsq(X, y)\n    return beta_ols\n\ndef estimate_trend_huber_irls(t, y, delta, max_iter=100, tol=1e-6):\n    \"\"\"Estimates trend coefficients using Huber regression via IRLS.\"\"\"\n    X = np.stack([np.ones_like(t), t], axis=1)\n    \n    # Initialize with OLS solution\n    beta = estimate_trend_ols(t, y)\n    \n    for _ in range(max_iter):\n        residuals = y - X @ beta\n        abs_residuals = np.abs(residuals)\n        \n        # Calculate weights based on Huber's psi-function/residual\n        # w(r) = min(1, delta/|r|)\n        # Add a small epsilon to avoid division by zero\n        weights = np.minimum(1.0, delta / (abs_residuals + 1e-8))\n        \n        # Perform weighted least squares\n        # This is equivalent to solving lstsq for L*y and L*X where L = sqrt(W)\n        L = np.sqrt(weights)\n        X_w = X * L[:, np.newaxis]\n        y_w = y * L\n        \n        beta_new, _, _, _ = lstsq(X_w, y_w)\n        \n        if np.linalg.norm(beta_new - beta)  tol:\n            break\n        beta = beta_new\n        \n    return beta\n\ndef estimate_seasonal_amplitude(t, detrended_y, P):\n    \"\"\"Estimates seasonal amplitude from a detrended series.\"\"\"\n    S = np.stack([\n        np.cos(2 * np.pi * t / P),\n        np.sin(2 * np.pi * t / P)\n    ], axis=1)\n    \n    gamma, _, _, _ = lstsq(S, detrended_y)\n    amplitude = np.linalg.norm(gamma)\n    return amplitude\n\ndef solve():\n    \"\"\"\n    Main function to run the time series decomposition for all test cases.\n    \"\"\"\n    test_cases = [\n        # (N, P, beta0, beta1, A_true, sigma, f_out, M_out, delta)\n        (60, 12, 0.4, 0.0015, 0.15, 0.02, 0.10, 0.35, 0.05),\n        (60, 12, 0.5, 0.0000, 0.12, 0.01, 0.00, 0.00, 0.05),\n        (48, 12, 0.3, 0.0020, 0.08, 0.03, 0.25, 0.50, 0.03),\n        (36, 12, 0.6, -0.0010, 0.10, 0.015, 0.15, 0.40, 0.005),\n        (24, 12, 0.45, 0.0010, 0.00, 0.02, 0.20, 0.30, 0.05),\n    ]\n\n    results = []\n    # Use a fixed seed for reproducibility of random components.\n    seed = 42\n    rng = np.random.default_rng(seed)\n\n    for params in test_cases:\n        N, P, beta0, beta1, A_true, sigma, f_out, M_out, delta = params\n        \n        # 1. Generate synthetic time series data\n        t, y = generate_time_series(N, P, beta0, beta1, A_true, sigma, f_out, M_out, rng)\n        \n        # 2. Estimate trend using OLS\n        beta_ols = estimate_trend_ols(t, y)\n        tau_ols = beta_ols[0] + beta_ols[1] * t\n        d_ols = y - tau_ols\n        A_ols = estimate_seasonal_amplitude(t, d_ols, P)\n\n        # 3. Estimate trend using Huber regression (IRLS)\n        beta_huber = estimate_trend_huber_irls(t, y, delta)\n        tau_huber = beta_huber[0] + beta_huber[1] * t\n        d_huber = y - tau_huber\n        A_huber = estimate_seasonal_amplitude(t, d_huber, P)\n\n        # 4. Calculate and store the difference\n        results.append(A_huber - A_ols)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "时间序列分解的准确性不仅取决于模型本身，还严重依赖于输入数据的质量。在多云地区，最大值合成（MVC）是生成无云图像时间序列的常用技术，但它也可能引入系统性偏差。本练习通过一个概率模型，引导你推导MVC如何在不同季节差异性的云量影响下，人为地夸大季节性振幅，从而培养对整个遥感数据处理链的批判性思维 。",
            "id": "3843784",
            "problem": "一位遥感研究员使用最大值合成（MVC）方法，构建了湿润热带森林地区归一化植被指数（NDVI）时间序列的月度合成数据。最大值合成（MVC）在每个月内，从该月所有的卫星采集中选择观测到的最大NDVI值。某一季节的潜在NDVI信号通过典型时间序列分解建模，表示为一个恒定趋势、该季节特有的季节平均值以及残余测量误差之和。假设所考虑的两个季节的趋势是恒定的，因此季节平均值控制着一年内的逐月变化。设雨季和干季的季节平均值分别为 $S_{\\mathrm{wet}}$ 和 $S_{\\mathrm{dry}}$，并定义真实的季节振幅为 $A_{\\mathrm{true}} = S_{\\mathrm{dry}} - S_{\\mathrm{wet}}$。\n\n在季节 $s \\in \\{\\mathrm{wet}, \\mathrm{dry}\\}$ 的任何给定月份内，假设有 $n$ 次独立的卫星采集。每次采集要么是无云的（概率为 $p_{s}$），要么是受云污染的（概率为 $1 - p_{s}$）。相对于该次采集的无云观测值，云污染会使观测到的NDVI减少一个加性衰减量 $c  0$。忽略测量噪声和双向反射效应，并假设一个月内各次采集的云出现情况是相互独立的。\n\n从上述模型假设和MVC作为 $n$ 次月度观测值最大值的定义出发，推导雨季和干季的期望MVC合成值，然后推导期望的MVC估计的季节振幅 $A_{\\mathrm{MVC}}$。利用这些结果求得振幅偏差 $\\Delta A = A_{\\mathrm{MVC}} - A_{\\mathrm{true}}$。在你的推理中，解释当无云概率因季节而异时，为什么MVC会夸大湿润热带地区的表观季节性。\n\n以包含 $c$、$p_{\\mathrm{wet}}$、$p_{\\mathrm{dry}}$ 和 $n$ 的单个闭式解析表达式的形式，给出振幅偏差 $\\Delta A$ 的最终答案。无需进行数值计算。",
            "solution": "经评估，该问题陈述有效。它在科学上基于遥感和统计建模的原理，问题提出得当，目标明确，信息充分，并使用了客观、正式的语言。不存在矛盾、歧义或违反科学原理之处。因此，我们可以进行正式求解。\n\n问题的核心是确定最大值合成（MVC）方法如何因季节间云量差异而在季节振幅估计中引入系统性偏差。我们将推导每个季节的NDVI合成值的期望值，然后计算由此产生的振幅及其偏差。\n\n设 $S_s$ 为季节 $s \\in \\{\\mathrm{wet}, \\mathrm{dry}\\}$ 的真实季节平均归一化植被指数（NDVI），相对于一个恒定的趋势分量，该分量在所有差异计算中都将被抵消。在季节 $s$ 的某个月份内，单次卫星采集要么是无云的，要么是受云污染的。\n单次采集的观测NDVI，我们记为随机变量 $X_s$，可以取两个值之一：\n1.  如果采集是无云的（概率为 $p_s$），观测到的NDVI是 $S_s$。\n2.  如果采集是受云污染的（概率为 $1 - p_s$），观测到的NDVI会减少一个衰减因子 $c$，观测结果为 $S_s - c$。\n\n因此，单次观测 $X_s$ 的概率分布为：\n$$\nP(X_s = S_s) = p_s \\\\\nP(X_s = S_s - c) = 1 - p_s\n$$\n其中 $c  0$。\n\n最大值合成（MVC）从一个月内的 $n$ 次独立采集中选择最大值。设这 $n$ 次独立同分布的观测值为 $X_{s,1}, X_{s,2}, \\dots, X_{s,n}$。该月的MVC合成值，记为 $M_s$，由下式给出：\n$$\nM_s = \\max(X_{s,1}, X_{s,2}, \\dots, X_{s,n})\n$$\n随机变量 $M_s$ 也只能取两个可能的值：$S_s$ 或 $S_s - c$。如果 $n$ 次采集中至少有一次是无云的，则 $M_s$ 的值为 $S_s$。只有当所有 $n$ 次采集都受云污染时，$M_s$ 的值才会是 $S_s - c$。\n\n单次采集受云污染的概率是 $1 - p_s$。由于 $n$ 次采集中的云出现是相互独立的，因此所有 $n$ 次采集都受云污染的概率是 $(1 - p_s)^n$。\n$$\nP(M_s = S_s - c) = P(\\text{all } n \\text{ acquisitions are cloudy}) = (1 - p_s)^n\n$$\n$M_s = S_s$ 事件是其补集，即至少有一次采集是无云的。该事件的概率是：\n$$\nP(M_s = S_s) = 1 - P(M_s = S_s - c) = 1 - (1 - p_s)^n\n$$\n现在，我们可以计算季节 $s$ 的MVC合成值的期望值，记为 $E[M_s]$。\n$$\nE[M_s] = (S_s) \\cdot P(M_s = S_s) + (S_s - c) \\cdot P(M_s = S_s - c)\n$$\n代入我们推导出的概率：\n$$\nE[M_s] = S_s \\left( 1 - (1 - p_s)^n \\right) + (S_s - c) \\left( (1 - p_s)^n \\right)\n$$\n展开各项：\n$$\nE[M_s] = S_s - S_s (1 - p_s)^n + S_s (1 - p_s)^n - c (1 - p_s)^n\n$$\n$S_s (1 - p_s)^n$ 项相互抵消，剩下：\n$$\nE[M_s] = S_s - c (1 - p_s)^n\n$$\n这个表达式代表了季节 $s$ 的期望月度NDVI合成值。它表明，期望合成值是真实的季节平均值 $S_s$ 减去一个负偏差项 $c (1 - p_s)^n$，该偏差项取决于云衰减量 $c$、观测次数 $n$ 和晴空观测概率 $p_s$。\n\n我们将此一般性结果应用于雨季和干季。设 $p_{\\mathrm{wet}}$ 和 $p_{\\mathrm{dry}}$ 分别为雨季和干季的无云概率。\n雨季的期望MVC合成值为：\n$$\nE[M_{\\mathrm{wet}}] = S_{\\mathrm{wet}} - c (1 - p_{\\mathrm{wet}})^n\n$$\n干季的期望MVC合成值为：\n$$\nE[M_{\\mathrm{dry}}] = S_{\\mathrm{dry}} - c (1 - p_{\\mathrm{dry}})^n\n$$\n期望的MVC估计的季节振幅 $A_{\\mathrm{MVC}}$ 是这些期望合成值之间的差值：\n$$\nA_{\\mathrm{MVC}} = E[M_{\\mathrm{dry}}] - E[M_{\\mathrm{wet}}]\n$$\n$$\nA_{\\mathrm{MVC}} = \\left( S_{\\mathrm{dry}} - c (1 - p_{\\mathrm{dry}})^n \\right) - \\left( S_{\\mathrm{wet}} - c (1 - p_{\\mathrm{wet}})^n \\right)\n$$\n重新整理各项，将真实的季节平均值和偏差项分组：\n$$\nA_{\\mathrm{MVC}} = (S_{\\mathrm{dry}} - S_{\\mathrm{wet}}) - c \\left( (1 - p_{\\mathrm{dry}})^n - (1 - p_{\\mathrm{wet}})^n \\right)\n$$\n真实的季节振幅定义为 $A_{\\mathrm{true}} = S_{\\mathrm{dry}} - S_{\\mathrm{wet}}$。将其代入 $A_{\\mathrm{MVC}}$ 的表达式中，得到：\n$$\nA_{\\mathrm{MVC}} = A_{\\mathrm{true}} - c \\left( (1 - p_{\\mathrm{dry}})^n - (1 - p_{\\mathrm{wet}})^n \\right)\n$$\n振幅偏差 $\\Delta A$ 定义为 $\\Delta A = A_{\\mathrm{MVC}} - A_{\\mathrm{true}}$。\n$$\n\\Delta A = \\left( A_{\\mathrm{true}} - c \\left( (1 - p_{\\mathrm{dry}})^n - (1 - p_{\\mathrm{wet}})^n \\right) \\right) - A_{\\mathrm{true}}\n$$\n$$\n\\Delta A = - c \\left( (1 - p_{\\mathrm{dry}})^n - (1 - p_{\\mathrm{wet}})^n \\right)\n$$\n通过反转括号内的项，可以更简洁地写为：\n$$\n\\Delta A = c \\left( (1 - p_{\\mathrm{wet}})^n - (1 - p_{\\mathrm{dry}})^n \\right)\n$$\n这就是振幅偏差的最终表达式。\n\n为了解释为什么季节性被夸大，我们考虑湿润热带森林的典型情况，即雨季的云量明显多于干季。这意味着 $p_{\\mathrm{wet}}  p_{\\mathrm{dry}}$。\n由于 $p_{\\mathrm{wet}}  p_{\\mathrm{dry}}$，因此有 $(1 - p_{\\mathrm{wet}})  (1 - p_{\\mathrm{dry}})$。\n对于 $n \\geq 1$，当取 $n$ 次方时，这个不等式关系保持不变：$(1 - p_{\\mathrm{wet}})^n  (1 - p_{\\mathrm{dry}})^n$。\n量 $(1 - p_s)^n$ 是在季节 $s$ 未能获得一次无云观测的概率。这种失败在云量较多的雨季更有可能发生。\n项 $c (1 - p_s)^n$ 代表了季节 $s$ 的MVC合成值中负偏差的大小（即期望的减少量）。由于 $(1 - p_{\\mathrm{wet}})^n  (1 - p_{\\mathrm{dry}})^n$ 且 $c  0$，雨季的负偏差幅度大于干季。\n这意味着MVC方法对雨季NDVI的系统性低估比对干季NDVI的低估更为严重。\n当通过用受抑制较少的干季值减去受抑制更严重的雨季值来计算估计振幅 $A_{\\mathrm{MVC}}$ 时，得到的差值会比真实差值 $A_{\\mathrm{true}}$更大。\n从数学上讲，由于 $(1 - p_{\\mathrm{wet}})^n  (1 - p_{\\mathrm{dry}})^n$，项 $(1 - p_{\\mathrm{wet}})^n - (1 - p_{\\mathrm{dry}})^n$ 是正的。又因为 $c$ 也是正的，所以振幅偏差 $\\Delta A = c \\left( (1 - p_{\\mathrm{wet}})^n - (1 - p_{\\mathrm{dry}})^n \\right)$ 是正的。正偏差意味着 $A_{\\mathrm{MVC}}  A_{\\mathrm{true}}$，即季节振幅被夸大或放大了。",
            "answer": "$$\n\\boxed{c \\left( (1 - p_{\\mathrm{wet}})^{n} - (1 - p_{\\mathrm{dry}})^{n} \\right)}\n$$"
        }
    ]
}