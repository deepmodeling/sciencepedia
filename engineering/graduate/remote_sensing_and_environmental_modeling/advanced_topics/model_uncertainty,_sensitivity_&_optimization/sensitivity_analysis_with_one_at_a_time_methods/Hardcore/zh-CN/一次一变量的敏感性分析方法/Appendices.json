{
    "hands_on_practices": [
        {
            "introduction": "计算参数敏感度有两种主要方法：直接对模型的解析解求导，或求解一组派生出的“敏感度方程”。本练习将通过一个简单且可解析求解的模型，来验证这两种方法是等价的。通过证明两种方法得到相同的结果，您将对敏感度方程方法建立起基础的理解和信心，这对于处理那些没有解析解的复杂模型至关重要。",
            "id": "3926758",
            "problem": "考虑一个理想化的药代动力学单室模型，其具有指数消除特性，由常微分方程 (ODE) $ \\dot{x}(t) = -k\\,x(t) $ 和初始条件 $ x(0) = x_0 $ 描述，其中 $ k $ 是一个正的消除速率常数，$ x(t) $ 是房室内的药物量。令可测量的输出为 $ y(t) = x(t) $。使用关于参数 $ k $ 的局部一次一参数（one-at-a-time）敏感度分析，将未归一化的局部敏感度函数定义为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。仅从该 ODE、基本微分法则以及 $ s_k(t) $ 的定义出发，推导 $ s_k(t) $ 的控制 ODE，在假设 $ x_0 $不依赖于 $ k $ 的情况下确定初始条件 $ s_k(0) $，并解析求解 $ s_k(t) $。独立地，通过对闭式解 $ x(t) = x_0 \\exp(-k t) $ 直接关于 $ k $ 求导来验证该解，并证明两者一致。以单个闭式解析表达式的形式报告最终的敏感度 $ s_k(t) $。不需要进行数值近似或四舍五入，最终表达式中也不应包含物理单位。",
            "solution": "首先验证问题陈述的科学合理性、自洽性和适定性。\n\n### 步骤 1：提取已知条件\n- 系统的控制常微分方程 (ODE) 是 $ \\dot{x}(t) = -k\\,x(t) $。\n- 状态的初始条件是 $ x(0) = x_0 $。\n- 消除速率常数 $ k $ 是一个正参数，即 $ k > 0 $。\n- 可测量的输出定义为 $ y(t) = x(t) $。\n- 关于 $ k $ 的未归一化局部敏感度函数定义为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。\n- 提供了一个假设：初始条件 $ x_0 $ 不依赖于参数 $ k $。\n\n任务是：\n1.  推导 $ s_k(t) $ 的控制 ODE。\n2.  确定初始条件 $ s_k(0) $。\n3.  求解得到的 $ s_k(t) $ 的初值问题。\n4.  通过对 $ x(t) $ 的解析解求导，独立地验证结果。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题描述了一个具有一级消除的单室模型，这是药代动力学模型的基础。使用敏感度分析来研究参数 ($k$) 对状态 ($x(t)$) 的影响是系统生物学和工程学中的一种标准、严谨的技术。该问题基于已建立的数学和科学原理。\n- **适定性：** 问题陈述清晰，包含一个线性 ODE、一个明确的初始条件和一个精确的敏感度函数定义。所有必需的信息都已提供，且没有矛盾之处。预计存在唯一的解析解。\n- **客观性：** 问题以精确的数学语言表述，没有任何主观或模棱两可的术语。\n\n### 步骤 3：结论与行动\n该问题是有效的。它在科学上是合理的、适定的、客观的和完整的。我将继续进行求解。\n\n### 求解推导\n\n根据要求，分析分两部分进行：首先，通过推导和求解敏感度 ODE；其次，通过直接微分进行验证。\n\n**第一部分：敏感度 ODE 的推导与求解**\n\n系统由以下 ODE 描述：\n$$ \\dot{x}(t) = -k\\,x(t) $$\n由于输出为 $ y(t) = x(t) $，该方程可以写成关于输出的形式：\n$$ \\dot{y}(t) = -k\\,y(t) $$\n敏感度函数定义为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。为了找到 $ s_k(t) $ 的控制 ODE，我们将系统的 ODE 对参数 $ k $ 求导。假设函数 $ y(t, k) $ 足够光滑，我们可以交换关于 $ t $ 和 $ k $ 的求导顺序：\n$$ \\frac{\\partial}{\\partial k} \\left( \\frac{d y(t)}{dt} \\right) = \\frac{d}{dt} \\left( \\frac{\\partial y(t)}{\\partial k} \\right) = \\frac{d s_k(t)}{dt} = \\dot{s}_k(t) $$\n将此应用于系统 ODE：\n$$ \\frac{\\partial}{\\partial k} (\\dot{y}(t)) = \\frac{\\partial}{\\partial k} (-k\\,y(t)) $$\n$$ \\dot{s}_k(t) = \\frac{\\partial}{\\partial k} (-k\\,y(t)) $$\n对右侧使用乘法法则求导：\n$$ \\dot{s}_k(t) = - \\left( \\frac{\\partial k}{\\partial k} \\cdot y(t) + k \\cdot \\frac{\\partial y(t)}{\\partial k} \\right) $$\n$$ \\dot{s}_k(t) = - \\left( 1 \\cdot y(t) + k \\cdot s_k(t) \\right) $$\n这给出了敏感度函数的线性非齐次 ODE：\n$$ \\dot{s}_k(t) = -k\\,s_k(t) - y(t) $$\n接下来，我们确定 $ s_k(t) $ 的初始条件。状态的初始条件是 $ y(0) = x(0) = x_0 $。初始敏感度通过对初始状态关于 $ k $ 求导得到：\n$$ s_k(0) = \\left. \\frac{\\partial y(t)}{\\partial k} \\right|_{t=0} = \\frac{\\partial y(0)}{\\partial k} = \\frac{\\partial x_0}{\\partial k} $$\n问题陈述 $ x_0 $ 独立于 $ k $，因此 $ \\frac{\\partial x_0}{\\partial k} = 0 $。所以，敏感度的初始条件是：\n$$ s_k(0) = 0 $$\n为了求解敏感度 ODE，我们必须首先代入 $ y(t) $ 的解。原始 ODE $ \\dot{y}(t) = -k\\,y(t) $ 和 $ y(0) = x_0 $ 的解析解是：\n$$ y(t) = x_0 \\exp(-kt) $$\n将此代入敏感度 ODE，得到：\n$$ \\dot{s}_k(t) = -k\\,s_k(t) - x_0 \\exp(-kt) $$\n这可以重排为一阶线性 ODE 的标准形式：\n$$ \\dot{s}_k(t) + k\\,s_k(t) = -x_0 \\exp(-kt) $$\n我们使用积分因子 $ I(t) $ 来求解。\n$$ I(t) = \\exp\\left(\\int k \\, dt\\right) = \\exp(kt) $$\n将 ODE 乘以 $ I(t) $：\n$$ \\exp(kt) \\dot{s}_k(t) + k \\exp(kt) s_k(t) = -x_0 \\exp(-kt) \\exp(kt) $$\n左边是乘积 $ I(t) s_k(t) $ 的导数：\n$$ \\frac{d}{dt} \\left( s_k(t) \\exp(kt) \\right) = -x_0 \\exp(0) = -x_0 $$\n两边对 $ t $ 积分：\n$$ \\int \\frac{d}{dt} \\left( s_k(t) \\exp(kt) \\right) dt = \\int -x_0 \\, dt $$\n$$ s_k(t) \\exp(kt) = -x_0 t + C $$\n其中 $ C $ 是积分常数。我们求解 $ s_k(t) $：\n$$ s_k(t) = (-x_0 t + C) \\exp(-kt) $$\n现在，我们应用初始条件 $ s_k(0) = 0 $：\n$$ s_k(0) = (-x_0 \\cdot 0 + C) \\exp(-k \\cdot 0) = (0 + C) \\cdot 1 = C $$\n因此，$ C = 0 $。敏感度函数的解析解是：\n$$ s_k(t) = -x_0 t \\exp(-kt) $$\n\n**第二部分：独立验证**\n\n我们被要求通过对状态变量的闭式解 $ x(t) = x_0 \\exp(-kt) $ 直接关于 $ k $ 求导来验证此结果。\n已知 $ y(t) = x(t) = x_0 \\exp(-kt) $。\n敏感度为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。\n$$ s_k(t) = \\frac{\\partial}{\\partial k} \\left( x_0 \\exp(-kt) \\right) $$\n由于 $ x_0 $ 独立于 $ k $，我们将其视为常数：\n$$ s_k(t) = x_0 \\frac{\\partial}{\\partial k} \\left( \\exp(-kt) \\right) $$\n使用链式法则求导，令 $ u = -kt $。则 $ \\frac{\\partial u}{\\partial k} = -t $。\n$$ s_k(t) = x_0 \\cdot \\exp(-kt) \\cdot \\frac{\\partial}{\\partial k}(-kt) $$\n$$ s_k(t) = x_0 \\exp(-kt) (-t) $$\n$$ s_k(t) = -x_0 t \\exp(-kt) $$\n此表达式与通过求解敏感度 ODE 推导出的表达式完全相同。两种方法结果的一致性证实了结果的正确性。敏感度的最终表达式为 $ s_k(t) = -x_0 t \\exp(-kt) $。",
            "answer": "$$ \\boxed{-x_0 t \\exp(-kt)} $$"
        },
        {
            "introduction": "当模型的解析解无法获得时，我们通常使用有限差分等数值方法来近似计算敏感度。然而，选择合适的扰动步长对于获得准确结果至关重要，并非一件易事。本练习旨在挑战您对数值OAT分析中实际问题的批判性思考，例如参数尺度的差异、参数的物理边界（如正值约束）以及模型输出的饱和效应。通过评估不同的扰动策略，您将培养在真实世界模型上进行稳健数值敏感度分析所需的实践判断力。",
            "id": "3926736",
            "problem": "一个受体-配体结合系统通过质量作用动力学下的常微分方程 (ODEs) 进行建模。令 $R$ 表示游离受体，$L$ 表示配体（假定为常数），$C$ 表示复合物。总受体为 $R_{\\mathrm{T}}$，因此 $R = R_{\\mathrm{T}} - C$。结合动力学由严格为正的速率常数 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 控制，复合物的演化遵循\n$$\n\\frac{dC}{dt} = k_{\\mathrm{on}}\\,L\\,(R_{\\mathrm{T}} - C) - k_{\\mathrm{off}}\\,C,\\quad C(0) = 0,\\quad k_{\\mathrm{on}} > 0,\\; k_{\\mathrm{off}} > 0.\n$$\n一项实验报告了在固定时间 $t^\\ast > 0$ 时的占有率 $y(t^\\ast) = C(t^\\ast)/R_{\\mathrm{T}}$。对于一个标称参数矢量 $\\theta_0 = (k_{\\mathrm{on},0}, k_{\\mathrm{off},0})$，计划对 $y(t^\\ast)$ 关于每个参数进行局部的“一次一参数”敏感度分析，使用有限差分法来近似偏导数。已知该系统在 $k_{\\mathrm{on}}\\,L/k_{\\mathrm{off}}$ 较大时会表现出占有率饱和现象，并且数值求解器可能会在扰动非常小时引入有限精度效应。\n\n在 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 在扰动期间必须保持严格为正的约束下，并认识到 $y(t^\\ast)$ 可能处于饱和状态，以下哪种步长选择策略在理论上基于第一性原理是合理的，并且在实践中对于估计在 $\\theta_0$ 处的局部、“一次一参数”的参数敏感度是鲁棒的？选择所有适用项。\n\nA. 对每个参数 $\\theta_i \\in \\{k_{\\mathrm{on}}, k_{\\mathrm{off}}\\}$，转换为 $\\phi_i = \\ln \\theta_i$，并在将另一参数固定在其标称值的情况下，在 $\\phi_i$ 中使用一个小的对称扰动 $\\pm h$，其中对两个参数选择相同的 $h$（例如，$h$ 在 $0.01$ 到 $0.1$ 的范围内），然后计算并报告相对于 $\\phi_i$ 的敏感度。\n\nB. 对每个参数，在原始参数中使用一个固定的绝对中心差分步长 $\\pm \\delta$，对 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 使用相同的 $\\delta$，无论标称参数的大小如何，都选择 $\\delta = 10^{-6}$（在相应单位下）。\n\nC. 在对数参数中使用一个因子为 $10$ 的乘性步长（即，$+h$ 对应于乘以 $10$，$-h$ 对应于除以 $10$）以避免下溢，理由是较大的步长可以提高数值稳定性并克服饱和引起的平坦性。\n\nD. 自适应地选择 $\\phi_i = \\ln \\theta_i$ 中的扰动，使得当在 $\\phi_i$ 中步进 $\\pm h$ 时（其他参数固定），产生的占有率幅度变化满足 $|\\Delta y| \\approx 0.01\\,\\max\\{1, |y|\\}$，并验证 $+h$ 和 $-h$ 响应之间的近似对称性；如果不对称性很显著，则减小 $h$ 直到响应近似对称。\n\nE. 通过重新参数化为 $\\psi_i = \\theta_i^2$ 来强制正性，并在 $\\psi_i$ 中应用一个对称中心差分 $\\pm \\eta$，对两个参数使用相同的 $\\eta$，然后将得到的导数映射回原始参数。",
            "solution": "问题陈述经过验证，被确认为一个在系统生物学数值方法领域中有效且适定的问题。\n\n目标是为输出 $y(t^\\ast)$ 相对于参数 $\\theta_i \\in \\{k_{\\mathrm{on}}, k_{\\mathrm{off}}\\}$ 的局部、“一次一参数”敏感度分析，确定理论上合理且实践中鲁棒的策略。估计将使用有限差分近似来完成。需要解决的关键挑战是：\n1.  正性约束：$k_{\\mathrm{on}} > 0$ 和 $k_{\\mathrm{off}} > 0$。\n2.  $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 可能具有极大差异的参数尺度（数量级）。\n3.  输出饱和的可能性，此时输出 $y(t^\\ast)$ 相对于参数变化几乎是平坦的，使得数值微分容易出现灾难性抵消错误。\n4.  分析需要是*局部*的，意味着导数是在标称点 $\\theta_0$ 处近似，而不是在一个大区间上。\n\n我们现在将根据这些原则评估每种提出的策略。\n\nA. 对每个参数 $\\theta_i \\in \\{k_{\\mathrm{on}}, k_{\\mathrm{off}}\\}$，转换为 $\\phi_i = \\ln \\theta_i$，并在将另一参数固定在其标称值的情况下，在 $\\phi_i$ 中使用一个小的对称扰动 $\\pm h$，其中对两个参数选择相同的 $h$（例如，$h$ 在 $0.01$ 到 $0.1$ 的范围内），然后计算并报告相对于 $\\phi_i$ 的敏感度。\n\n*   **分析**：该策略采用参数的对数变换。在原始参数空间中，一个 $\\phi_i \\pm h$ 的扰动对应于一个乘性扰动 $\\theta_i' = e^{\\phi_i \\pm h} = e^{\\phi_i}e^{\\pm h} = \\theta_i e^{\\pm h}$。\n    *   **正性**：由于对于任何实数 $x$，$e^x > 0$ 恒成立，这种变换自然地强制了正性约束。这是一个主要优点。\n    *   **参数尺度**：在对数空间中使用固定步长 $h$ 对应于原始参数中的固定*相对*扰动。对于小的 $h$，$e^h \\approx 1+h$，因此扰动约为 $(1 \\pm h)\\theta_i$。这是处理可能跨越多个数量级的参数的标准且正确的方法，因为无论参数是 $10^6$ 还是 $10^{-3}$，一个 $1\\%$ 的变化都是有意义的。\n    *   **局部性**：建议的 $h$ 范围从 $0.01$ 到 $0.1$ 对应于大约 $1\\%$ 到 $10\\%$ 的相对扰动，这通常被认为足够小，可以近似一个局部导数。\n    *   **报告**：计算相对于 $\\phi_i$ 的敏感度会得到对数敏感度 $\\frac{\\partial y}{\\partial \\ln \\theta_i} = \\theta_i \\frac{\\partial y}{\\partial \\theta_i}$，这是一个与尺度无关的敏感度度量，通常比绝对敏感度 $\\frac{\\partial y}{\\partial \\theta_i}$ 更有用。\n    *   这是一种标准、鲁棒且理论上合理的方法。\n*   **结论**：**正确**。\n\nB. 对每个参数，在原始参数中使用一个固定的绝对中心差分步长 $\\pm \\delta$，对 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 使用相同的 $\\delta$，无论标称参数的大小如何，都选择 $\\delta = 10^{-6}$（在相应单位下）。\n\n*   **分析**：该策略使用一个固定的绝对扰动 $\\theta_i \\pm \\delta$。\n    *   **正性**：对于标称值 $\\theta_{i,0}$ 与 $\\delta$ 同阶或更小的参数，扰动 $\\theta_{i,0} - \\delta$ 可能会变为非正数，违反模型的物理约束。\n    *   **参数尺度**：这是最严重的缺陷。如果 $k_{\\mathrm{on},0} \\sim 10^6$ 且 $k_{\\mathrm{off},0} \\sim 10^{-2}$，一个步长 $\\delta = 10^{-6}$ 对 $k_{\\mathrm{on}}$ 来说代表了 $10^{-12}$ 的相对变化，对 $k_{\\mathrm{off}}$ 来说则是 $10^{-4}$ 的相对变化。对 $k_{\\mathrm{on}}$ 的扰动可能非常小，以至于 $y(t^\\ast)$ 的变化将小于数值精度，导致有限差分分子中的灾难性抵消错误，从而产生无意义的结果。对不同数量级的参数使用相同的绝对步长，这在根本上是不合理的。\n*   **结论**：**不正确**。\n\nC. 在对数参数中使用一个因子为 $10$ 的乘性步长（即，$+h$ 对应于乘以 $10$，$-h$ 对应于除以 $10$）以避免下溢，理由是较大的步长可以提高数值稳定性并克服饱和引起的平坦性。\n\n*   **分析**：该策略建议将参数 $\\theta_i$ 扰动到 $10\\theta_i$ 和 $0.1\\theta_i$。这对应于在对数参数 $\\phi_i = \\ln \\theta_i$ 中一个非常大的步长 $h = \\ln(10) \\approx 2.3$。\n    *   **局部性**：局部敏感度分析的主要目的是计算偏导数，即在单一点处的切线斜率。在每个方向上一个数量级的扰动不是局部分析。它计算的是一个巨大区间上的割线斜率。其结果并不能近似在 $\\theta_0$ 处的 $\\frac{\\partial y}{\\partial \\theta_i}$。\n    *   **数值稳定性**：其理由是有缺陷的。虽然大步长可以克服由平坦响应面引起的抵消误差，但它在有限差分近似中引入了巨大的*截断误差*。近似式 $\\frac{y(\\theta_0+h\\theta_0)-y(\\theta_0-h\\theta_0)}{2h\\theta_0} \\approx \\frac{\\partial y}{\\partial \\theta_i}$ 仅对小 $h$ 有效。该策略放弃了计算局部导数的目标。\n*   **结论**：**不正确**。\n\nD. 自适应地选择 $\\phi_i = \\ln \\theta_i$ 中的扰动，使得当在 $\\phi_i$ 中步进 $\\pm h$ 时（其他参数固定），产生的占有率幅度变化满足 $|\\Delta y| \\approx 0.01\\,\\max\\{1, |y|\\}$，并验证 $+h$ 和 $-h$ 响应之间的近似对称性；如果不对称性很显著，则减小 $h$ 直到响应近似对称。\n\n*   **分析**：这描述了一种先进的自适应策略。\n    *   **变换**：它正确地从对数变换 $\\phi_i = \\ln \\theta_i$ 开始，继承了 A 中描述的正性和尺度调整的优点。\n    *   **自适应步长**：它不使用固定的步长 $h$，而是寻找一个能产生目标输出变化的步长（大约为 $0.01$，因为 $y \\in [0,1]$ 因此 $\\max\\{1, |y|\\}=1$）。这是对抗饱和问题的绝佳方法：如果响应是平坦的，算法将自动选择一个较大的 $h$ 以获得有意义的信号，但仅在需要的范围内增大。这平衡了截断误差和舍入/抵消误差之间的权衡。\n    *   **对称性检查**：这是一个至关重要的自洽性检查。中心差分近似的有效性取决于函数的局部线性度。前向（$+h$）和后向（$-h$）响应之间的显著不对称性表明步长 $h$ 太大，已进入非线性区域。该策略正确地规定在这种情况下减小 $h$，以确保分析保持局部性。\n    *   这代表了一种理论上合理且实践中鲁棒的最佳实践方法。\n*   **结论**：**正确**。\n\nE. 通过重新参数化为 $\\psi_i = \\theta_i^2$ 来强制正性，并在 $\\psi_i$ 中应用一个对称中心差分 $\\pm \\eta$，对两个参数使用相同的 $\\eta$，然后将得到的导数映射回原始参数。\n\n*   **分析**：这建议了一种二次重新参数化，$\\theta_i = \\sqrt{\\psi_i}$（对于 $\\theta_i > 0$）。\n    *   **正性**：这种重新参数化不能保证扰动后参数的正性。如果 $\\psi_{i,0}$ 很小，$\\psi_{i,0} - \\eta$ 可能为负，导致 $\\theta_i$ 为虚数，这在物理上是无意义的。因此，它不如对数变换鲁棒。\n    *   **参数尺度**：这是最严重的缺陷。在 $\\psi_i$ 中一个固定的扰动 $\\eta$ 导致的在 $\\theta_i$ 中的扰动大小为 $\\Delta\\theta_i = \\sqrt{\\theta_i^2 \\pm \\eta} - \\theta_i \\approx \\theta_i(1 \\pm \\frac{\\eta}{2\\theta_i^2}) - \\theta_i = \\pm \\frac{\\eta}{2\\theta_i}$。原始参数中的步长与它的数量级*成反比*。对于一个大的参数值（例如 $k_{\\mathrm{on},0}$），步长是微不足道的。对于一个小的参数值（例如 $k_{\\mathrm{off},0}$），步长是巨大的。这与处理跨尺度参数的要求完全相反，是比选项 B 中的固定绝对步长策略更糟糕的策略。\n*   **结论**：**不正确**。\n\n综上所述，策略 A 和 D 都是理论上合理且实践中鲁棒的方法，可以执行所要求的敏感度分析。策略 A 是一种广泛使用的标准实践，而策略 D 是 A 的一种更先进、自适应的版本，它甚至更为鲁棒，特别是在面对输出饱和时。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "敏感度分析的一个核心应用是评估模型参数能否被实验数据唯一确定，即参数的可识别性问题。在本练习中，您将把从前面练习中学到的敏感度方程方法，应用于一个实际的、多状态的生理学模型（Bergman最小模型）。您将构建敏感度矩阵（雅可比矩阵），并通过计算其秩来评估参数的可识别性。这个综合性练习融合了理论与计算，展示了敏感度分析如何作为模型验证和指导实验设计的强大工具。",
            "id": "3926762",
            "problem": "考虑用于静脉葡萄糖耐量试验的 Bergman 葡萄糖-胰岛素最小模型，其中血浆葡萄糖浓度由状态变量 $G(t)$ 表示，远程胰岛素效应由状态变量 $X(t)$ 表示。其控制常微分方程为\n$$\n\\frac{dG}{dt} = -p_1\\,(G - G_b) - X\\,G,\n$$\n$$\n\\frac{dX}{dt} = -p_2\\,X + p_3\\,(I(t) - I_b),\n$$\n其中 $p_1, p_2, p_3$ 是待分析的未知参数，$G_b$ 是基础葡萄糖浓度，$I_b$ 是基础胰岛素浓度，$I(t)$ 是已知的外源胰岛素输入函数。假设初始条件 $G(0) = G_0$ 和 $X(0) = X_0$ 与参数 $p_1, p_2, p_3$ 无关。关注的测量输出是在指定时间采样的葡萄糖轨迹，即 $y_j = G(t_j)$。\n\n需要通过敏感度方程对参数 $p_1, p_2, p_3$ 进行局部一次一参数敏感度分析。对每个参数 $p_i$，定义敏感度变量 $S_{G,p_i}(t) = \\frac{\\partial G(t)}{\\partial p_i}$ 和 $S_{X,p_i}(t) = \\frac{\\partial X(t)}{\\partial p_i}$。这些敏感度满足通过模型对 $p_i$ 求导得到的一阶常微分方程。利用这些敏感度方程，数值构建雅可比矩阵 $J(\\theta^*) \\in \\mathbb{R}^{m \\times 3}$，其中 $\\theta^* = (p_1, p_2, p_3)$，$m$ 是采样次数，矩阵元素为\n$$\nJ_{j,i}(\\theta^*) = \\left.\\frac{\\partial G(t_j)}{\\partial p_i}\\right|_{\\theta = \\theta^*} = S_{G,p_i}(t_j).\n$$\n确定矩阵 $J(\\theta^*)$ 的秩。\n\n您的程序必须严格地实现敏感度方程（而不是通过有限差分），并基于由原始状态方程和敏感度方程组成的增广系统的积分来计算 $J(\\theta^*)$。根据需要，使用适用于刚性或非刚性系统的精确数值积分方法。\n\n对于以下所有情况，设置基础值为 $G_b = 90$ 和 $I_b = 10$，并使用参数向量 $\\theta^* = (p_1, p_2, p_3) = (0.01, 0.02, 0.0005)$。胰岛素输入模型为\n$$\nI(t) = I_b + A\\,e^{-\\alpha t},\n$$\n其中 $A$ 和 $\\alpha$ 由每个测试案例指定。\n\n测试套件：\n- 案例1（一般情况）：采样时间 $t_j = [5, 10, 20, 40, 60]$（分钟），初始条件 $G_0 = 180$，$X_0 = 0$，胰岛素参数 $A = 50$，$\\alpha = 0.1$。\n- 案例2（无胰岛素变化的边界情况）：采样时间 $t_j = [5, 10, 20, 40, 60]$，初始条件 $G_0 = 150$，$X_0 = 0$，胰岛素参数 $A = 0$，$\\alpha = 0.1$。\n- 案例3（稀疏采样的边缘情况）：采样时间 $t_j = [1, 2]$，初始条件 $G_0 = 200$，$X_0 = 0$，胰岛素参数 $A = 50$，$\\alpha = 0.1$。\n- 案例4（早期采样且胰岛素扰动较小的情况）：采样时间 $t_j = [0.5, 1.0, 1.5, 2.0, 3.0]$，初始条件 $G_0 = 90$，$X_0 = 0$，胰岛素参数 $A = 1$，$\\alpha = 0.2$。\n\n对于每个案例，根据在指定采样时间计算出的敏感度构建 $J(\\theta^*)$，并以整数形式返回矩阵的秩。最终输出必须是单行文本，包含四个案例的秩，格式为逗号分隔的列表并用方括号括起（例如，“[r1,r2,r3,r4]”），其中每个 $r_k$ 都是整数。输出中不需要物理单位，也不涉及角度或百分比。程序必须是完整的，无需任何外部输入即可直接运行。",
            "solution": "下面对用户提供的问题进行严格验证。\n\n### 步骤1：提取给定信息\n- **模型方程**:\n  - $\\frac{dG}{dt} = -p_1\\,(G - G_b) - X\\,G$\n  - $\\frac{dX}{dt} = -p_2\\,X + p_3\\,(I(t) - I_b)$\n- **状态变量**: $G(t)$, $X(t)$\n- **待分析参数**: $\\theta = (p_1, p_2, p_3)$\n- **常数和已知量**:\n  - 基础葡萄糖浓度: $G_b = 90$\n  - 基础胰岛素浓度: $I_b = 10$\n  - 用于分析的参数向量: $\\theta^* = (p_1, p_2, p_3) = (0.01, 0.02, 0.0005)$\n  - 外源胰岛素输入: $I(t) = I_b + A\\,e^{-\\alpha t}$\n- **初始条件**:\n  - $G(0) = G_0$\n  - $X(0) = X_0$\n  - 初始条件被声明为与参数 $p_1, p_2, p_3$ 无关。\n- **测量输出**: $y_j = G(t_j)$ 在指定的采样时间 $t_j$。\n- **敏感度变量**:\n  - $S_{G,p_i}(t) = \\frac{\\partial G(t)}{\\partial p_i}$\n  - $S_{X,p_i}(t) = \\frac{\\partial X(t)}{\\partial p_i}$\n- **任务**:\n  - 构建雅可比矩阵 $J(\\theta^*)$，其元素为 $J_{j,i} = S_{G,p_i}(t_j)$。\n  - 确定四个具体测试案例中 $J(\\theta^*)$ 的矩阵秩。\n- **测试案例**:\n  - 案例1: $t_j = [5, 10, 20, 40, 60]$, $G_0 = 180$, $X_0 = 0$, $A = 50$, $\\alpha = 0.1$.\n  - 案例2: $t_j = [5, 10, 20, 40, 60]$, $G_0 = 150$, $X_0 = 0$, $A = 0$, $\\alpha = 0.1$.\n  - 案例3: $t_j = [1, 2]$, $G_0 = 200$, $X_0 = 0$, $A = 50$, $\\alpha = 0.1$.\n  - 案例4: $t_j = [0.5, 1.0, 1.5, 2.0, 3.0]$, $G_0 = 90$, $X_0 = 0$, $A = 1$, $\\alpha = 0.2$.\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估。\n\n- **科学基础**：该问题使用了 Bergman 最小模型，这是生理学和生物医学工程中葡萄糖-胰岛素动力学建模的基石。敏感度方程法是系统理论和参数估计中的一种标准、严谨的技术。该问题牢固地植根于既定的科学和数学原理。\n- **适定性**：该问题定义明确。它提供了一整套常微分方程（ODE）、所有必要的参数值、初始条件和输入函数。任务是计算一个确定性量，即矩阵的秩，这是一个明确定义的数学运算。对于每个测试案例，设置都是完整的，可以得出一个唯一的解。\n- **客观性**：语言精确且量化。所有指令都清晰明确，没有主观或基于观点的陈述。\n- **完整性**：问题是自包含的。求解所需的所有值和函数都已明确提供。\n- **一致性**：给定信息在内部是一致的。模型方程、参数或条件中没有矛盾。\n- **相关性**：该问题直接关乎生物医学系统模型的局部一次一参数敏感度分析主题。\n\n该问题没有表现出验证标准中列出的任何缺陷。它在科学上是合理的、适定的、客观的和完整的。\n\n### 步骤3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的设计\n这个问题的核心是针对 Bergman 最小模型的参数 $p_1, p_2, p_3$ 进行局部敏感度分析。状态变量对这些参数的灵敏度通过它们的偏导数来量化，而这些偏导数本身也是时间的函数。这些灵敏度函数的控制方程是通过对原始模型的常微分方程（ODE）关于每个参数求导得出的。这就产生了一个更大的、可以进行数值求解的增广常微分方程组。\n\n状态变量为 $G(t)$ 和 $X(t)$，受以下方程控制：\n$$\n\\frac{dG}{dt} = f_G(G, X, p_1, p_2, p_3) = -p_1(G - G_b) - XG\n$$\n$$\n\\frac{dX}{dt} = f_X(X, p_1, p_2, p_3, t) = -p_2 X + p_3(I(t) - I_b)\n$$\n敏感度变量定义为 $S_{G,p_i} = \\frac{\\partial G}{\\partial p_i}$ 和 $S_{X,p_i} = \\frac{\\partial X}{\\partial p_i}$，其中 $i=1,2,3$。它们的动力学通过应用链式法则找到，例如 $\\frac{d}{dt} S_{G,p_i} = \\frac{\\partial f_G}{\\partial G}S_{G,p_i} + \\frac{\\partial f_G}{\\partial X}S_{X,p_i} + \\frac{\\partial f_G}{\\partial p_i}$。所需的右侧函数的偏导数是：\n- $\\frac{\\partial f_G}{\\partial G} = -p_1 - X$\n- $\\frac{\\partial f_G}{\\partial X} = -G$\n- $\\frac{\\partial f_G}{\\partial p_1} = -(G - G_b)$\n- $\\frac{\\partial f_G}{\\partial p_2} = 0$\n- $\\frac{\\partial f_G}{\\partial p_3} = 0$\n- $\\frac{\\partial f_X}{\\partial G} = 0$\n- $\\frac{\\partial f_X}{\\partial X} = -p_2$\n- $\\frac{\\partial f_X}{\\partial p_1} = 0$\n- $\\frac{\\partial f_X}{\\partial p_2} = -X$\n- $\\frac{\\partial f_X}{\\partial p_3} = I(t) - I_b$\n\n利用这些，我们推导出敏感度的常微分方程组：\n1.  **对 $p_1$ 的敏感度**：\n    $$\n    \\frac{dS_{G,p_1}}{dt} = (-p_1 - X)S_{G,p_1} - G S_{X,p_1} - (G - G_b)\n    $$\n    $$\n    \\frac{dS_{X,p_1}}{dt} = -p_2 S_{X,p_1}\n    $$\n2.  **对 $p_2$ 的敏感度**：\n    $$\n    \\frac{dS_{G,p_2}}{dt} = (-p_1 - X)S_{G,p_2} - G S_{X,p_2}\n    $$\n    $$\n    \\frac{dS_{X,p_2}}{dt} = -p_2 S_{X,p_2} - X\n    $$\n3.  **对 $p_3$ 的敏感度**：\n    $$\n    \\frac{dS_{G,p_3}}{dt} = (-p_1 - X)S_{G,p_3} - G S_{X,p_3}\n    $$\n    $$\n    \\frac{dS_{X,p_3}}{dt} = -p_2 S_{X,p_3} + (I(t) - I_b)\n    $$\n问题陈述初始条件 $G(0)=G_0$ 和 $X(0)=X_0$ 与参数 $p_i$ 无关。这意味着初始敏感度为零：\n$$\nS_{G,p_i}(0) = \\frac{\\partial G_0}{\\partial p_i} = 0\n$$\n$$\nS_{X,p_i}(0) = \\frac{\\partial X_0}{\\partial p_i} = 0\n$$\n对于 $i=1, 2, 3$。\n\n现在我们构建一个增广状态向量 $Y(t) \\in \\mathbb{R}^8$：\n$$\nY(t) = [G, X, S_{G,p_1}, S_{X,p_1}, S_{G,p_2}, S_{X,p_2}, S_{G,p_3}, S_{X,p_3}]^T\n$$\n这个增广系统的动力学 $\\frac{dY}{dt} = F(t, Y)$ 由两个原始状态方程和六个敏感度方程给出。初始条件向量为 $Y(0) = [G_0, X_0, 0, 0, 0, 0, 0, 0]^T$。\n\n为了解决这个问题，我们对每个测试案例，将这个 $8$ 维常微分方程组从 $t=0$ 积分到最晚的采样时间。我们使用一个鲁棒的数值求解器，例如可以处理系统潜在刚性的 `scipy.integrate.solve_ivp`。求解器被配置为在特定的采样时间 $t_j$ 输出解。\n\n从数值解中，我们提取在每个采样时间 $t_j$（其中 $j=1, \\dots, m$）下葡萄糖对 $p_i$（其中 $i=1,2,3$）的敏感度值 $S_{G,p_i}(t_j)$。这些值构成了 $m \\times 3$ 的雅可比矩阵 $J$：\n$$\nJ = \n\\begin{pmatrix}\n S_{G,p_1}(t_1)  S_{G,p_2}(t_1)  S_{G,p_3}(t_1) \\\\\n S_{G,p_1}(t_2)  S_{G,p_2}(t_2)  S_{G,p_3}(t_2) \\\\\n \\vdots  \\vdots  \\vdots \\\\\n S_{G,p_1}(t_m)  S_{G,p_2}(t_m)  S_{G,p_3}(t_m)\n\\end{pmatrix}\n$$\n最后一步是使用标准的数值线性代数程序（如 `numpy.linalg.matrix_rank`）计算该矩阵 $J$ 的秩，该程序通常采用奇异值分解（SVD）以实现数值稳定的计算。对四个测试案例中的每一个都重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Bergman minimal model sensitivity analysis problem for four test cases.\n    \"\"\"\n    \n    # Global parameters and constants\n    p1_star, p2_star, p3_star = 0.01, 0.02, 0.0005\n    Gb, Ib = 90.0, 10.0\n\n    # Test cases as defined in the problem statement\n    test_cases = [\n        {\n            \"t_j\": [5, 10, 20, 40, 60],\n            \"G0\": 180.0, \"X0\": 0.0,\n            \"A\": 50.0, \"alpha\": 0.1\n        },\n        {\n            \"t_j\": [5, 10, 20, 40, 60],\n            \"G0\": 150.0, \"X0\": 0.0,\n            \"A\": 0.0, \"alpha\": 0.1\n        },\n        {\n            \"t_j\": [1.0, 2.0],\n            \"G0\": 200.0, \"X0\": 0.0,\n            \"A\": 50.0, \"alpha\": 0.1\n        },\n        {\n            \"t_j\": [0.5, 1.0, 1.5, 2.0, 3.0],\n            \"G0\": 90.0, \"X0\": 0.0,\n            \"A\": 1.0, \"alpha\": 0.2\n        }\n    ]\n\n    def ode_system(t, y, p1, p2, p3, Gb_val, Ib_val, A_val, alpha_val):\n        \"\"\"\n        Defines the augmented ODE system including states and sensitivities.\n        State vector y:\n        y[0]: G(t)\n        y[1]: X(t)\n        y[2]: S_G,p1(t)\n        y[3]: S_X,p1(t)\n        y[4]: S_G,p2(t)\n        y[5]: S_X,p2(t)\n        y[6]: S_G,p3(t)\n        y[7]: S_X,p3(t)\n        \"\"\"\n        G, X, SGp1, SXp1, SGp2, SXp2, SGp3, SXp3 = y\n        \n        # Insulin input\n        I_minus_Ib = A_val * np.exp(-alpha_val * t)\n\n        # Original state equations\n        dG_dt = -p1 * (G - Gb_val) - X * G\n        dX_dt = -p2 * X + p3 * I_minus_Ib\n        \n        # Sensitivity equations\n        # w.r.t p1\n        dSGp1_dt = (-p1 - X) * SGp1 - G * SXp1 - (G - Gb_val)\n        dS_Xp1_dt = -p2 * SXp1\n        \n        # w.r.t p2\n        dSGp2_dt = (-p1 - X) * SGp2 - G * SXp2\n        dSXp2_dt = -p2 * SXp2 - X\n\n        # w.r t p3\n        dSGp3_dt = (-p1 - X) * SGp3 - G * SXp3\n        dSXp3_dt = -p2 * SXp3 + I_minus_Ib\n\n        return [dG_dt, dX_dt, dSGp1_dt, dS_Xp1_dt, dSGp2_dt, dSXp2_dt, dSGp3_dt, dSXp3_dt]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack case parameters\n        t_j = case[\"t_j\"]\n        G0, X0 = case[\"G0\"], case[\"X0\"]\n        A, alpha = case[\"A\"], case[\"alpha\"]\n\n        # Initial conditions for the augmented system\n        y0 = [G0, X0, 0, 0, 0, 0, 0, 0]\n        \n        # Time span for integration\n        t_span = (0, max(t_j))\n        \n        # Parameters to pass to the ODE function\n        args = (p1_star, p2_star, p3_star, Gb, Ib, A, alpha)\n        \n        # Solve the augmented ODE system\n        # LSODA is a good choice for systems that may be stiff or non-stiff.\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            method='LSODA', \n            t_eval=t_j, \n            args=args,\n            rtol=1e-6, \n            atol=1e-9\n        )\n        \n        # Extract sensitivities for glucose w.r.t. p1, p2, p3\n        # SGp1 is at index 2, SGp2 at 4, SGp3 at 6\n        SGp1_vals = sol.y[2]\n        SGp2_vals = sol.y[4]\n        SGp3_vals = sol.y[6]\n        \n        # Construct the Jacobian (Sensitivity) matrix J\n        J = np.vstack([SGp1_vals, SGp2_vals, SGp3_vals]).T\n        \n        # Compute the rank of J\n        rank = np.linalg.matrix_rank(J)\n        results.append(rank)\n\n    # Print the final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}