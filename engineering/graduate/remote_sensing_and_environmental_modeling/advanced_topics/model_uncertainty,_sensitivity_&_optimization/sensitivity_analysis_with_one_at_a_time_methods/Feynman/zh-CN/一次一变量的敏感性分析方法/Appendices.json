{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳方式莫过于通过一个简单的模型来亲手实践。这个练习将带我们回到敏感性分析的数学核心。我们将通过一个基础的一阶动力学模型，探索计算模型输出对参数变化的响应程度的两种基本方法：直接对解析解求导，以及通过构建并求解“敏感性方程”。通过解决这个问题，你将能直观地理解敏感性函数的由来，并为处理无法求得解析解的复杂模型打下坚实的理论基础。",
            "id": "3926758",
            "problem": "考虑一个理想化为单房室并具有指数消除的药代动力学房室模型，该模型由常微分方程 (ODE) $ \\dot{x}(t) = -k\\,x(t) $ 及其初始条件 $ x(0) = x_0 $ 描述，其中 $ k $ 是一个正的消除速率常数，$ x(t) $ 是房室内的药量。令可测量的输出为 $ y(t) = x(t) $。使用关于参数 $ k $ 的局部一次一参数敏感性分析，将未归一化的局部敏感性函数定义为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。请仅从该 ODE、基本微分法则以及 $ s_k(t) $ 的定义出发，推导出 $ s_k(t) $ 的控制 ODE，在假设 $ x_0 $ 不依赖于 $ k $ 的前提下确定初始条件 $ s_k(0) $，并解析求解 $ s_k(t) $。之后，通过对闭式解 $ x(t) = x_0 \\exp(-k t) $ 直接关于 $ k $ 求导来独立验证该解，并证明两者一致。请将最终的敏感性 $ s_k(t) $ 以单一闭式解析表达式的形式报告。无需进行数值近似或四舍五入，最终表达式中也不应包含任何物理单位。",
            "solution": "首先对问题陈述的科学合理性、自洽性和适定性进行验证。\n\n### 第1步：提取已知条件\n- 系统的控制常微分方程 (ODE) 是 $ \\dot{x}(t) = -k\\,x(t) $。\n- 状态的初始条件是 $ x(0) = x_0 $。\n- 消除速率常数 $ k $ 是一个正参数，即 $ k > 0 $。\n- 可测量的输出定义为 $ y(t) = x(t) $。\n- 关于 $ k $ 的未归一化局部敏感性函数定义为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。\n- 提供了一个假设：初始条件 $ x_0 $ 不依赖于参数 $ k $。\n\n任务如下：\n1.  推导 $ s_k(t) $ 的控制 ODE。\n2.  确定初始条件 $ s_k(0) $。\n3.  求解所得的 $ s_k(t) $ 的初值问题。\n4.  通过对 $ x(t) $ 的解析解进行微分来独立验证该解。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据：** 该问题描述了一个具有一级消除的单房室模型，这是药代动力学建模的基石。使用敏感性分析来研究参数（$k$）对状态（$x(t)$）的影响是系统生物学和工程学中一种标准、严谨的技术。该问题基于既定的数学和科学原理。\n- **适定性：** 该问题用一个线性 ODE、一个明确定义的初始条件以及敏感性函数的精确定义清晰地陈述。所有必需的信息都已提供，且没有矛盾之处。预期存在唯一的解析解。\n- **客观性：** 该问题以精确的数学语言表达，没有任何主观或模糊的术语。\n\n### 第3步：结论与行动\n该问题有效。它在科学上合理、适定、客观且完整。我将继续进行求解。\n\n### 解的推导\n\n按要求，分析分两部分进行：首先，通过推导和求解敏感性 ODE；其次，通过直接微分进行验证。\n\n**第1部分：敏感性 ODE 的推导与求解**\n\n系统由以下 ODE 描述：\n$$ \\dot{x}(t) = -k\\,x(t) $$\n由于输出为 $ y(t) = x(t) $，该方程可以写成关于输出的形式：\n$$ \\dot{y}(t) = -k\\,y(t) $$\n敏感性函数定义为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。为了找到 $ s_k(t) $ 的控制 ODE，我们对系统的 ODE 关于参数 $ k $ 进行微分。假设函数 $ y(t, k) $ 足够平滑，我们可以交换关于 $ t $ 和 $ k $ 的微分顺序：\n$$ \\frac{\\partial}{\\partial k} \\left( \\frac{d y(t)}{dt} \\right) = \\frac{d}{dt} \\left( \\frac{\\partial y(t)}{\\partial k} \\right) = \\frac{d s_k(t)}{dt} = \\dot{s}_k(t) $$\n将此应用于系统 ODE：\n$$ \\frac{\\partial}{\\partial k} (\\dot{y}(t)) = \\frac{\\partial}{\\partial k} (-k\\,y(t)) $$\n$$ \\dot{s}_k(t) = \\frac{\\partial}{\\partial k} (-k\\,y(t)) $$\n对右侧使用乘法法则进行微分：\n$$ \\dot{s}_k(t) = - \\left( \\frac{\\partial k}{\\partial k} \\cdot y(t) + k \\cdot \\frac{\\partial y(t)}{\\partial k} \\right) $$\n$$ \\dot{s}_k(t) = - \\left( 1 \\cdot y(t) + k \\cdot s_k(t) \\right) $$\n这就得到了敏感性函数的线性非齐次 ODE：\n$$ \\dot{s}_k(t) = -k\\,s_k(t) - y(t) $$\n接下来，我们确定 $ s_k(t) $ 的初始条件。状态的初始条件是 $ y(0) = x(0) = x_0 $。初始敏感性通过对初始状态关于 $ k $ 进行微分得到：\n$$ s_k(0) = \\left. \\frac{\\partial y(t)}{\\partial k} \\right|_{t=0} = \\frac{\\partial y(0)}{\\partial k} = \\frac{\\partial x_0}{\\partial k} $$\n问题陈述 $ x_0 $ 不依赖于 $ k $，所以 $ \\frac{\\partial x_0}{\\partial k} = 0 $。因此，敏感性的初始条件是：\n$$ s_k(0) = 0 $$\n为了求解敏感性 ODE，我们必须首先代入 $ y(t) $ 的解。原始 ODE $ \\dot{y}(t) = -k\\,y(t) $ 及初始条件 $ y(0) = x_0 $ 的解析解为：\n$$ y(t) = x_0 \\exp(-kt) $$\n将此代入敏感性 ODE，得到：\n$$ \\dot{s}_k(t) = -k\\,s_k(t) - x_0 \\exp(-kt) $$\n这可以重排为一阶线性 ODE 的标准形式：\n$$ \\dot{s}_k(t) + k\\,s_k(t) = -x_0 \\exp(-kt) $$\n我们使用积分因子 $ I(t) $ 来求解。\n$$ I(t) = \\exp\\left(\\int k \\, dt\\right) = \\exp(kt) $$\n将 ODE 乘以 $ I(t) $：\n$$ \\exp(kt) \\dot{s}_k(t) + k \\exp(kt) s_k(t) = -x_0 \\exp(-kt) \\exp(kt) $$\n左边是乘积 $ I(t) s_k(t) $ 的导数：\n$$ \\frac{d}{dt} \\left( s_k(t) \\exp(kt) \\right) = -x_0 \\exp(0) = -x_0 $$\n对两边关于 $ t $ 积分：\n$$ \\int \\frac{d}{dt} \\left( s_k(t) \\exp(kt) \\right) dt = \\int -x_0 \\, dt $$\n$$ s_k(t) \\exp(kt) = -x_0 t + C $$\n其中 $ C $ 是积分常数。我们求解 $ s_k(t) $：\n$$ s_k(t) = (-x_0 t + C) \\exp(-kt) $$\n现在，我们应用初始条件 $ s_k(0) = 0 $：\n$$ s_k(0) = (-x_0 \\cdot 0 + C) \\exp(-k \\cdot 0) = (0 + C) \\cdot 1 = C $$\n因此，$ C = 0 $。敏感性函数的解析解是：\n$$ s_k(t) = -x_0 t \\exp(-kt) $$\n\n**第2部分：独立验证**\n\n题目要求我们通过直接对状态变量的闭式解 $ x(t) = x_0 \\exp(-kt) $ 关于 $ k $ 进行微分来验证此结果。\n已知 $ y(t) = x(t) = x_0 \\exp(-kt) $。\n敏感性为 $ s_k(t) = \\frac{\\partial y(t)}{\\partial k} $。\n$$ s_k(t) = \\frac{\\partial}{\\partial k} \\left( x_0 \\exp(-kt) \\right) $$\n由于 $ x_0 $ 不依赖于 $ k $，我们将其视为常数：\n$$ s_k(t) = x_0 \\frac{\\partial}{\\partial k} \\left( \\exp(-kt) \\right) $$\n使用链式法则进行微分，令 $ u = -kt $。则 $ \\frac{\\partial u}{\\partial k} = -t $。\n$$ s_k(t) = x_0 \\cdot \\exp(-kt) \\cdot \\frac{\\partial}{\\partial k}(-kt) $$\n$$ s_k(t) = x_0 \\exp(-kt) (-t) $$\n$$ s_k(t) = -x_0 t \\exp(-kt) $$\n这个表达式与通过求解敏感性 ODE 推导出的表达式相同。两种方法之间的一致性证实了结果的正确性。敏感性的最终表达式是 $ s_k(t) = -x_0 t \\exp(-kt) $。",
            "answer": "$$ \\boxed{-x_0 t \\exp(-kt)} $$"
        },
        {
            "introduction": "在现实世界中，环境模型往往极其复杂，无法像上一个练习那样轻易获得解析解。因此，我们必须依赖数值方法（如有限差分）来近似计算敏感性。然而，数值计算充满了“陷阱”，其中最关键的挑战之一便是选择合适的扰动步长。这个练习模拟了一个真实的研究场景，探讨了在参数具有物理约束（如必须为正）和数量级差异巨大时，如何设计稳健的数值扰动策略，以避免得到错误的或充满噪声的敏感性估计。",
            "id": "3926736",
            "problem": "一个受体-配体结合系统由基于质量作用动力学的常微分方程（ODE）建模。设 $R$ 表示游离受体，$L$ 表示配体（假定为常数），$C$ 表示复合物。总受体为 $R_{\\mathrm{T}}$，因此 $R = R_{\\mathrm{T}} - C$。该结合动力学由严格为正的速率常数 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 控制，复合物的演化遵循以下方程：\n$$\n\\frac{dC}{dt} = k_{\\mathrm{on}}\\,L\\,(R_{\\mathrm{T}} - C) - k_{\\mathrm{off}}\\,C,\\quad C(0) = 0,\\quad k_{\\mathrm{on}} > 0,\\; k_{\\mathrm{off}} > 0.\n$$\n一项实验报告了在固定时间 $t^\\ast > 0$ 时的占有率 $y(t^\\ast) = C(t^\\ast)/R_{\\mathrm{T}}$。对于一个标称参数矢量 $\\theta_0 = (k_{\\mathrm{on},0}, k_{\\mathrm{off},0})$，计划对 $y(t^\\ast)$ 关于每个参数进行一次一参数（one-at-a-time）的局部敏感性分析，使用有限差分法来近似偏导数。已知当 $k_{\\mathrm{on}}\\,L/k_{\\mathrm{off}}$ 很大时，系统会表现出占有率饱和现象，并且对于非常小的扰动，数值求解器可能会引入有限精度效应。\n\n在 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 在扰动期间必须保持严格为正的约束下，并认识到 $y(t^\\ast)$ 可能处于饱和状态，以下哪种步长选择策略在理论上基于第一性原理是合理的，并且在实践中对于估计在 $\\theta_0$ 处的局部、一次一参数敏感性是鲁棒的？选择所有适用的选项。\n\nA. 对于每个参数 $\\theta_i \\in \\{k_{\\mathrm{on}}, k_{\\mathrm{off}}\\}$，变换为 $\\phi_i = \\ln \\theta_i$，并在 $\\phi_i$ 中使用一个小的对称扰动 $\\pm h$（其他参数固定在其标称值），其中对两个参数选择相同的 $h$（例如，$h$ 在 $0.01$ 到 $0.1$ 的范围内），然后计算并报告关于 $\\phi_i$ 的敏感性。\n\nB. 对于每个参数，在原始参数中使用一个固定的绝对中心差分步长 $\\pm \\delta$，对 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 使用相同的 $\\delta$，选择 $\\delta = 10^{-6}$（在相应单位下），而不管标称参数的大小。\n\nC. 在对数参数中使用一个因子为 $10$ 的乘性步长（即，$+h$ 对应于乘以 $10$，$-h$ 对应于除以 $10$），以避免下溢，理由是较大的步长能提高数值稳定性并克服饱和引起的平坦性。\n\nD. 自适应地选择 $\\phi_i = \\ln \\theta_i$ 中的扰动，使得当在 $\\phi_i$ 中步进 $\\pm h$ 时（其他参数固定），所产生的占有率大小变化满足 $|\\Delta y| \\approx 0.01\\,\\max\\{1, |y|\\}$，并验证 $+h$ 和 $-h$ 响应之间的近似对称性；如果不对称性很显著，则减小 $h$ 直到响应近似对称。\n\nE. 通过重新参数化为 $\\psi_i = \\theta_i^2$ 来强制正性，并在 $\\psi_i$ 中对两个参数应用相同的对称中心差分 $\\pm \\eta$，然后将所得导数映射回原始参数。",
            "solution": "该问题陈述已经过验证，被确认为一个在系统生物学数值方法领域中有效且适定的问题。\n\n目标是为输出 $y(t^\\ast)$ 相对于参数 $\\theta_i \\in \\{k_{\\mathrm{on}}, k_{\\mathrm{off}}\\}$ 的局部一次一参数敏感性分析，找出理论上合理且实践中鲁棒的策略。该估计将使用有限差分近似来完成。需要解决的关键挑战是：\n1.  正性约束：$k_{\\mathrm{on}} > 0$ 和 $k_{\\mathrm{off}} > 0$。\n2.  $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 可能存在巨大差异的参数尺度（数量级）。\n3.  输出饱和的可能性，此时输出 $y(t^\\ast)$ 相对于参数变化几乎是平坦的，这使得数值微分容易出现灾难性的相消误差。\n4.  分析需要是*局部*的，意味着导数是在标称点 $\\theta_0$ 处近似，而不是在一个大区间上。\n\n我们现在将根据这些原则评估每种提出的策略。\n\nA. 对于每个参数 $\\theta_i \\in \\{k_{\\mathrm{on}}, k_{\\mathrm{off}}\\}$，变换为 $\\phi_i = \\ln \\theta_i$，并在 $\\phi_i$ 中使用一个小的对称扰动 $\\pm h$（其他参数固定在其标称值），其中对两个参数选择相同的 $h$（例如，$h$ 在 $0.01$ 到 $0.1$ 的范围内），然后计算并报告关于 $\\phi_i$ 的敏感性。\n\n*   **分析**：此策略采用参数的对数变换。扰动 $\\phi_i \\pm h$ 对应于原始参数空间中的乘性扰动 $\\theta_i' = e^{\\phi_i \\pm h} = e^{\\phi_i}e^{\\pm h} = \\theta_i e^{\\pm h}$。\n    *   **正性**：这种变换自然地强制执行了正性约束，因为对于任何实数 $x$，$e^x > 0$。这是一个主要优点。\n    *   **参数尺度**：在对数空间中使用固定的步长 $h$ 对应于原始参数中的固定*相对*扰动。对于小的 $h$，$e^h \\approx 1+h$，所以扰动约为 $(1 \\pm h)\\theta_i$。这是处理可能跨越几个数量级的参数的标准且正确的方法，因为无论参数是 $10^6$ 还是 $10^{-3}$，1% 的变化都是有意义的。\n    *   **局部性**：建议的 $h$ 范围从 $0.01$ 到 $0.1$ 对应于大约 $1\\%$ 到 $10\\%$ 的相对扰动，这通常被认为足够小，可以近似局部导数。\n    *   **报告**：计算关于 $\\phi_i$ 的敏感性，得到对数敏感性 $\\frac{\\partial y}{\\partial \\ln \\theta_i} = \\theta_i \\frac{\\partial y}{\\partial \\theta_i}$，这是一个无尺度的敏感性度量，通常比绝对敏感性 $\\frac{\\partial y}{\\partial \\theta_i}$ 更有用。\n    *   这是一种标准的、鲁棒的、理论上合理的方法。\n*   **结论**：**正确**。\n\nB. 对于每个参数，在原始参数中使用一个固定的绝对中心差分步长 $\\pm \\delta$，对 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 使用相同的 $\\delta$，选择 $\\delta = 10^{-6}$（在相应单位下），而不管标称参数的大小。\n\n*   **分析**：此策略使用固定的绝对扰动 $\\theta_i \\pm \\delta$。\n    *   **正性**：对于一个标称值 $\\theta_{i,0}$ 与 $\\delta$ 同阶或更小的参数，扰动 $\\theta_{i,0} - \\delta$ 可能变为非正数，违反了模型的物理约束。\n    *   **参数尺度**：这是最严重的缺陷。如果 $k_{\\mathrm{on},0} \\sim 10^6$ 且 $k_{\\mathrm{off},0} \\sim 10^{-2}$，步长 $\\delta = 10^{-6}$ 对 $k_{\\mathrm{on}}$ 来说代表了 $10^{-12}$ 的相对变化，对 $k_{\\mathrm{off}}$ 则是 $10^{-4}$ 的相对变化。对 $k_{\\mathrm{on}}$ 的扰动可能太小，以至于 $y(t^\\ast)$ 的变化小于数值精度，导致有限差分分子中出现灾难性相消误差，从而产生无用的结果。对不同数量级的参数使用相同的绝对步长在根本上是不合理的。\n*   **结论**：**错误**。\n\nC. 在对数参数中使用一个因子为 $10$ 的乘性步长（即，$+h$ 对应于乘以 $10$，$-h$ 对应于除以 $10$），以避免下溢，理由是较大的步长能提高数值稳定性并克服饱和引起的平坦性。\n\n*   **分析**：此策略建议将参数 $\\theta_i$ 扰动到 $10\\theta_i$ 和 $0.1\\theta_i$。这对应于在对数参数 $\\phi_i = \\ln \\theta_i$ 中一个非常大的步长 $h = \\ln(10) \\approx 2.3$。\n    *   **局部性**：局部敏感性分析的主要目的是计算偏导数，即在单一点处的切线斜率。在每个方向上一个数量级的扰动不是局部分析。它计算的是一个巨大区间上的割线斜率。其结果并不能近似于在 $\\theta_0$ 处的 $\\frac{\\partial y}{\\partial \\theta_i}$。\n    *   **数值稳定性**：其理由是有缺陷的。虽然大步长克服了由平坦响应曲面引起的相消误差，但它在有限差分近似中引入了巨大的*截断误差*。近似式 $\\frac{y(\\theta_0+h\\theta_0)-y(\\theta_0-h\\theta_0)}{2h\\theta_0} \\approx \\frac{\\partial y}{\\partial \\theta_i}$ 仅对小的 $h$ 有效。该策略放弃了计算局部导数的目标。\n*   **结论**：**错误**。\n\nD. 自适应地选择 $\\phi_i = \\ln \\theta_i$ 中的扰动，使得当在 $\\phi_i$ 中步进 $\\pm h$ 时（其他参数固定），所产生的占有率大小变化满足 $|\\Delta y| \\approx 0.01\\,\\max\\{1, |y|\\}$，并验证 $+h$ 和 $-h$ 响应之间的近似对称性；如果不对称性很显著，则减小 $h$ 直到响应近似对称。\n\n*   **分析**：这描述了一种精密的自适应策略。\n    *   **变换**：它正确地从对数变换 $\\phi_i = \\ln \\theta_i$ 开始，继承了A中所述的正性和尺度调整的优点。\n    *   **自适应步长**：它不使用固定的步长 $h$，而是寻找一个能产生目标输出变化的步长（大约为 $0.01$，因为 $y \\in [0,1]$，因此 $\\max\\{1, |y|\\}=1$）。这是对抗饱和问题的绝佳方法：如果响应平坦，算法将自动选择一个较大的 $h$ 以获得有意义的信号，但仅在需要的程度上增大。这平衡了截断误差和舍入/相消误差之间的权衡。\n    *   **对称性检查**：这是一个关键的自洽性检查。中心差分近似的有效性取决于函数的局部线性。正向（$+h$）和反向（$-h$）响应之间的显著不对称性表明步长 $h$ 太大，已进入非线性区域。该策略正确地规定在这种情况下减小 $h$，以确保分析保持局部性。\n    *   这代表了一种既有理论依据又在实践中鲁棒的最佳实践方法。\n*   **结论**：**正确**。\n\nE. 通过重新参数化为 $\\psi_i = \\theta_i^2$ 来强制正性，并在 $\\psi_i$ 中对两个参数应用相同的对称中心差分 $\\pm \\eta$，然后将所得导数映射回原始参数。\n\n*   **分析**：这建议使用二次重参数化，$\\theta_i = \\sqrt{\\psi_i}$（对于 $\\theta_i > 0$）。\n    *   **正性**：这种重参数化可能无法确保扰动后参数的正性。如果 $\\psi_{i,0}$ 很小，$\\psi_{i,0} - \\eta$ 可能为负，导致 $\\theta_i$ 变为虚数，这在物理上是无意义的。因此，它不如对数变换鲁棒。\n    *   **参数尺度**：这是最严重的缺陷。在 $\\psi_i$ 中一个固定的扰动 $\\eta$ 导致在 $\\theta_i$ 中大小为 $\\Delta\\theta_i = \\sqrt{\\theta_i^2 \\pm \\eta} - \\theta_i \\approx \\theta_i(1 \\pm \\frac{\\eta}{2\\theta_i^2}) - \\theta_i = \\pm \\frac{\\eta}{2\\theta_i}$ 的扰动。原始参数中的步长与它的数量级*成反比*。对于一个大的参数值（例如 $k_{\\mathrm{on},0}$），步长会极小。对于一个小的参数值（例如 $k_{\\mathrm{off},0}$），步长会极大。这与处理跨尺度参数的要求完全相反，是比选项 B 中固定绝对步长更糟糕的策略。\n*   **结论**：**错误**。\n\n总而言之，策略 A 和 D 都是用于执行所要求的敏感性分析的理论上合理且实践中鲁棒的方法。策略 A 是一种广泛使用的标准实践，而策略 D 是 A 的一个更高级的自适应版本，它甚至更加鲁棒，特别是在面对输出饱和时。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "现在，让我们将前面学到的理论和数值技巧综合运用到一个更接近实际研究的计算问题中。这个练习要求我们为一个多参数的生物动力学模型（其原理与许多环境模型相通）编写代码，通过数值积分来求解其敏感性方程。这项实践不仅能让你掌握如何从理论走向代码实现，还将引导你构建完整的敏感性矩阵（即雅可比矩阵），并利用其“秩”来判断模型参数的可识别性——这是模型校准和不确定性分析中的一个核心概念。",
            "id": "3926762",
            "problem": "考虑用于静脉葡萄糖耐量试验的 Bergman 葡萄糖-胰岛素最小模型，其中血浆葡萄糖浓度由状态变量 $G(t)$ 表示，远程胰岛素效应由状态变量 $X(t)$ 表示。其控制常微分方程为\n$$\n\\frac{dG}{dt} = -p_1\\,(G - G_b) - X\\,G,\n$$\n$$\n\\frac{dX}{dt} = -p_2\\,X + p_3\\,(I(t) - I_b),\n$$\n其中 $p_1, p_2, p_3$ 是待分析的未知参数，$G_b$ 是基础葡萄糖浓度，$I_b$ 是基础胰岛素浓度，$I(t)$ 是已知的外源性胰岛素输入函数。假设初始条件 $G(0) = G_0$ 和 $X(0) = X_0$ 与参数 $p_1, p_2, p_3$ 无关。感兴趣的测量输出是在指定时间采样的葡萄糖轨迹，即 $y_j = G(t_j)$。\n\n需要通过敏感性方程对参数 $p_1, p_2, p_3$ 进行局部一次一参数（one-at-a-time）敏感性分析。对每个参数 $p_i$，定义敏感性变量 $S_{G,p_i}(t) = \\frac{\\partial G(t)}{\\partial p_i}$ 和 $S_{X,p_i}(t) = \\frac{\\partial X(t)}{\\partial p_i}$。这些敏感性函数满足通过模型对 $p_i$ 求导得到的一阶常微分方程。利用这些敏感性方程，数值构建雅可比矩阵 $J(\\theta^*) \\in \\mathbb{R}^{m \\times 3}$，其中 $\\theta^* = (p_1, p_2, p_3)$，$m$ 是采样次数，矩阵元素为\n$$\nJ_{j,i}(\\theta^*) = \\left.\\frac{\\partial G(t_j)}{\\partial p_i}\\right|_{\\theta = \\theta^*} = S_{G,p_i}(t_j).\n$$\n确定矩阵 $J(\\theta^*)$ 的秩。\n\n您的程序必须严格地（而不是通过有限差分）实现敏感性方程，并通过对由原始状态方程和敏感性方程组成的增广系统进行积分来计算 $J(\\theta^*)$。根据需要，使用适合刚性或非刚性系统的精确数值积分方法。\n\n对于以下所有案例，将基础值设为 $G_b = 90$ 和 $I_b = 10$，并使用参数向量 $\\theta^* = (p_1, p_2, p_3) = (0.01, 0.02, 0.0005)$。胰岛素输入模型为\n$$\nI(t) = I_b + A\\,e^{-\\alpha t},\n$$\n其中 $A$ 和 $\\alpha$ 由每个测试案例指定。\n\n测试套件：\n- 案例1（一般情况）：采样时间 $t_j = [5, 10, 20, 40, 60]$ （分钟），初始条件 $G_0 = 180$，$X_0 = 0$，胰岛素参数 $A = 50$，$\\alpha = 0.1$。\n- 案例2（无胰岛素变化的边界情况）：采样时间 $t_j = [5, 10, 20, 40, 60]$，初始条件 $G_0 = 150$，$X_0 = 0$，胰岛素参数 $A = 0$，$\\alpha = 0.1$。\n- 案例3（稀疏采样的边缘情况）：采样时间 $t_j = [1, 2]$，初始条件 $G_0 = 200$，$X_0 = 0$，胰岛素参数 $A = 50$，$\\alpha = 0.1$。\n- 案例4（早期采样且胰岛素扰动小）：采样时间 $t_j = [0.5, 1.0, 1.5, 2.0, 3.0]$，初始条件 $G_0 = 90$，$X_0 = 0$，胰岛素参数 $A = 1$，$\\alpha = 0.2$。\n\n对于每个案例，根据在指定采样时间计算出的敏感性构建 $J(\\theta^*)$，并返回矩阵的秩（一个整数）。最终输出必须是单行文本，包含四个案例的秩，形式为方括号内以逗号分隔的列表（例如，“[r1,r2,r3,r4]”），其中每个 $r_k$ 是一个整数。输出中不需要物理单位，也不涉及角度或百分比。程序必须是完整且可直接运行的，无需外部输入。",
            "solution": "下面对用户提供的问题进行严格验证。\n\n### 步骤1：提取已知条件\n- **模型方程**:\n  - $\\frac{dG}{dt} = -p_1\\,(G - G_b) - X\\,G$\n  - $\\frac{dX}{dt} = -p_2\\,X + p_3\\,(I(t) - I_b)$\n- **状态变量**: $G(t)$, $X(t)$\n- **待分析参数**: $\\theta = (p_1, p_2, p_3)$\n- **常数和已知量**:\n  - 基础葡萄糖浓度: $G_b = 90$\n  - 基础胰岛素浓度: $I_b = 10$\n  - 用于分析的参数向量: $\\theta^* = (p_1, p_2, p_3) = (0.01, 0.02, 0.0005)$\n  - 外源性胰岛素输入: $I(t) = I_b + A\\,e^{-\\alpha t}$\n- **初始条件**:\n  - $G(0) = G_0$\n  - $X(0) = X_0$\n  - 初始条件被声明为与参数 $p_1, p_2, p_3$ 无关。\n- **测量输出**: 在指定采样时间 $t_j$ 的 $y_j = G(t_j)$。\n- **敏感性变量**:\n  - $S_{G,p_i}(t) = \\frac{\\partial G(t)}{\\partial p_i}$\n  - $S_{X,p_i}(t) = \\frac{\\partial X(t)}{\\partial p_i}$\n- **任务**:\n  - 构建雅可比矩阵 $J(\\theta^*)$，其元素为 $J_{j,i} = S_{G,p_i}(t_j)$。\n  - 确定四个特定测试案例中矩阵 $J(\\theta^*)$ 的秩。\n- **测试案例**:\n  - 案例1: $t_j = [5, 10, 20, 40, 60]$, $G_0 = 180$, $X_0 = 0$, $A = 50$, $\\alpha = 0.1$。\n  - 案例2: $t_j = [5, 10, 20, 40, 60]$, $G_0 = 150$, $X_0 = 0$, $A = 0$, $\\alpha = 0.1$。\n  - 案例3: $t_j = [1, 2]$, $G_0 = 200$, $X_0 = 0$, $A = 50$, $\\alpha = 0.1$。\n  - 案例4: $t_j = [0.5, 1.0, 1.5, 2.0, 3.0]$, $G_0 = 90$, $X_0 = 0$, $A = 1$, $\\alpha = 0.2$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n- **科学性**：该问题使用了 Bergman 最小模型，这是生理学和生物医学工程中葡萄糖-胰岛素动力学建模的基石。敏感性方程方法是系统理论和参数估计中的标准、严谨的技术。该问题牢固地植根于已建立的科学和数学原理。\n- **适定性**：问题定义明确。它提供了一整套常微分方程（ODE）、所有必需的参数值、初始条件和输入函数。任务是计算一个确定性量，即矩阵的秩，这是一个明确定义的数学运算。对于每个测试案例，设置都是完整的，可以得出唯一的解。\n- **客观性**：语言精确且量化。所有指令都清晰明确。没有主观或基于意见的陈述。\n- **完整性**：问题是自洽的。求解所需的所有值和函数都已明确提供。\n- **一致性**：给出的条件是内部一致的。模型方程、参数或条件之间没有矛盾。\n- **相关性**：该问题直接涉及生物医学系统模型的局部一次一参数敏感性分析主题。\n\n该问题没有验证标准中列出的任何缺陷。它在科学上是合理的、适定的、客观的和完整的。\n\n### 步骤3：结论与行动\n问题是**有效的**。将提供解决方案。\n\n### 基于原理的设计\n这个问题的核心是对其参数 $p_1, p_2, p_3$ 对 Bergman 最小模型进行局部敏感性分析。状态变量对这些参数的敏感性由它们的偏导数来量化，这些偏导数本身是时间的函数。这些敏感性函数的控制方程是通过对原始模型的常微分方程（ODE）关于每个参数求导得出的。这就构成了一个更大的增广常微分方程系统，可以进行数值求解。\n\n状态变量 $G(t)$ 和 $X(t)$ 由以下方程控制：\n$$\n\\frac{dG}{dt} = f_G(G, X, p_1, p_2, p_3) = -p_1(G - G_b) - XG\n$$\n$$\n\\frac{dX}{dt} = f_X(X, p_1, p_2, p_3, t) = -p_2 X + p_3(I(t) - I_b)\n$$\n敏感性变量定义为 $S_{G,p_i} = \\frac{\\partial G}{\\partial p_i}$ 和 $S_{X,p_i} = \\frac{\\partial X}{\\partial p_i}$，其中 $i=1,2,3$。它们的动态特性通过应用链式法则得出，例如 $\\frac{d}{dt} S_{G,p_i} = \\frac{\\partial f_G}{\\partial G}S_{G,p_i} + \\frac{\\partial f_G}{\\partial X}S_{X,p_i} + \\frac{\\partial f_G}{\\partial p_i}$。所需的右侧函数的偏导数是：\n- $\\frac{\\partial f_G}{\\partial G} = -p_1 - X$\n- $\\frac{\\partial f_G}{\\partial X} = -G$\n- $\\frac{\\partial f_G}{\\partial p_1} = -(G - G_b)$\n- $\\frac{\\partial f_G}{\\partial p_2} = 0$\n- $\\frac{\\partial f_G}{\\partial p_3} = 0$\n- $\\frac{\\partial f_X}{\\partial G} = 0$\n- $\\frac{\\partial f_X}{\\partial X} = -p_2$\n- $\\frac{\\partial f_X}{\\partial p_1} = 0$\n- $\\frac{\\partial f_X}{\\partial p_2} = -X$\n- $\\frac{\\partial f_X}{\\partial p_3} = I(t) - I_b$\n\n利用这些偏导数，我们推导出敏感性的常微分方程组：\n1.  **对 $p_1$ 的敏感性**：\n    $$\n    \\frac{dS_{G,p_1}}{dt} = (-p_1 - X)S_{G,p_1} - G S_{X,p_1} - (G - G_b)\n    $$\n    $$\n    \\frac{dS_{X,p_1}}{dt} = -p_2 S_{X,p_1}\n    $$\n2.  **对 $p_2$ 的敏感性**：\n    $$\n    \\frac{dS_{G,p_2}}{dt} = (-p_1 - X)S_{G,p_2} - G S_{X,p_2}\n    $$\n    $$\n    \\frac{dS_{X,p_2}}{dt} = -p_2 S_{X,p_2} - X\n    $$\n3.  **对 $p_3$ 的敏感性**：\n    $$\n    \\frac{dS_{G,p_3}}{dt} = (-p_1 - X)S_{G,p_3} - G S_{X,p_3}\n    $$\n    $$\n    \\frac{dS_{X,p_3}}{dt} = -p_2 S_{X,p_3} + (I(t) - I_b)\n    $$\n问题陈述，初始条件 $G(0)=G_0$ 和 $X(0)=X_0$ 与参数 $p_i$ 无关。这意味着初始敏感性为零：\n$$\nS_{G,p_i}(0) = \\frac{\\partial G_0}{\\partial p_i} = 0\n$$\n$$\nS_{X,p_i}(0) = \\frac{\\partial X_0}{\\partial p_i} = 0\n$$\n对于 $i=1, 2, 3$。\n\n现在我们构建一个增广状态向量 $Y(t) \\in \\mathbb{R}^8$：\n$$\nY(t) = [G, X, S_{G,p_1}, S_{X,p_1}, S_{G,p_2}, S_{X,p_2}, S_{G,p_3}, S_{X,p_3}]^T\n$$\n这个增广系统的动力学 $\\frac{dY}{dt} = F(t, Y)$ 由两个原始状态方程和六个敏感性方程给出。初始条件向量是 $Y(0) = [G_0, X_0, 0, 0, 0, 0, 0, 0]^T$。\n\n为解决该问题，我们对每个测试案例，将这个8维常微分方程系统从 $t=0$ 积分到最晚的采样时间。我们使用一个稳健的数值求解器，例如`scipy.integrate.solve_ivp`，它可以处理系统中潜在的刚性问题。求解器被配置为在指定的采样时间 $t_j$ 输出解。\n\n从数值解中，我们提取在每个采样时间 $t_j$ （其中 $j=1, \\dots, m$）葡萄糖对 $p_i$ （其中 $i=1,2,3$）的敏感性值 $S_{G,p_i}(t_j)$。这些值构成了 $m \\times 3$ 的雅可比矩阵 $J$：\n$$\nJ = \n\\begin{pmatrix}\n S_{G,p_1}(t_1)  S_{G,p_2}(t_1)  S_{G,p_3}(t_1) \\\\\n S_{G,p_1}(t_2)  S_{G,p_2}(t_2)  S_{G,p_3}(t_2) \\\\\n \\vdots  \\vdots  \\vdots \\\\\n S_{G,p_1}(t_m)  S_{G,p_2}(t_m)  S_{G,p_3}(t_m)\n\\end{pmatrix}\n$$\n最后一步是使用标准的数值线性代数程序（如 `numpy.linalg.matrix_rank`）计算该矩阵 $J$ 的秩，该程序通常采用奇异值分解（SVD）以获得数值稳定的计算结果。对四个测试案例中的每一个都重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Bergman minimal model sensitivity analysis problem for four test cases.\n    \"\"\"\n    \n    # Global parameters and constants\n    p1_star, p2_star, p3_star = 0.01, 0.02, 0.0005\n    Gb, Ib = 90.0, 10.0\n\n    # Test cases as defined in the problem statement\n    test_cases = [\n        {\n            \"t_j\": [5, 10, 20, 40, 60],\n            \"G0\": 180.0, \"X0\": 0.0,\n            \"A\": 50.0, \"alpha\": 0.1\n        },\n        {\n            \"t_j\": [5, 10, 20, 40, 60],\n            \"G0\": 150.0, \"X0\": 0.0,\n            \"A\": 0.0, \"alpha\": 0.1\n        },\n        {\n            \"t_j\": [1.0, 2.0],\n            \"G0\": 200.0, \"X0\": 0.0,\n            \"A\": 50.0, \"alpha\": 0.1\n        },\n        {\n            \"t_j\": [0.5, 1.0, 1.5, 2.0, 3.0],\n            \"G0\": 90.0, \"X0\": 0.0,\n            \"A\": 1.0, \"alpha\": 0.2\n        }\n    ]\n\n    def ode_system(t, y, p1, p2, p3, Gb_val, Ib_val, A_val, alpha_val):\n        \"\"\"\n        Defines the augmented ODE system including states and sensitivities.\n        State vector y:\n        y[0]: G(t)\n        y[1]: X(t)\n        y[2]: S_G,p1(t)\n        y[3]: S_X,p1(t)\n        y[4]: S_G,p2(t)\n        y[5]: S_X,p2(t)\n        y[6]: S_G,p3(t)\n        y[7]: S_X,p3(t)\n        \"\"\"\n        G, X, SGp1, SXp1, SGp2, SXp2, SGp3, SXp3 = y\n        \n        # Insulin input\n        I_minus_Ib = A_val * np.exp(-alpha_val * t)\n\n        # Original state equations\n        dG_dt = -p1 * (G - Gb_val) - X * G\n        dX_dt = -p2 * X + p3 * I_minus_Ib\n        \n        # Sensitivity equations\n        # w.r.t p1\n        dSGp1_dt = (-p1 - X) * SGp1 - G * SXp1 - (G - Gb_val)\n        dS_Xp1_dt = -p2 * SXp1\n        \n        # w.r.t p2\n        dSGp2_dt = (-p1 - X) * SGp2 - G * SXp2\n        dSXp2_dt = -p2 * SXp2 - X\n\n        # w.r t p3\n        dSGp3_dt = (-p1 - X) * SGp3 - G * SXp3\n        dSXp3_dt = -p2 * SXp3 + I_minus_Ib\n\n        return [dG_dt, dX_dt, dSGp1_dt, dS_Xp1_dt, dSGp2_dt, dSXp2_dt, dSGp3_dt, dSXp3_dt]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack case parameters\n        t_j = case[\"t_j\"]\n        G0, X0 = case[\"G0\"], case[\"X0\"]\n        A, alpha = case[\"A\"], case[\"alpha\"]\n\n        # Initial conditions for the augmented system\n        y0 = [G0, X0, 0, 0, 0, 0, 0, 0]\n        \n        # Time span for integration\n        t_span = (0, max(t_j))\n        \n        # Parameters to pass to the ODE function\n        args = (p1_star, p2_star, p3_star, Gb, Ib, A, alpha)\n        \n        # Solve the augmented ODE system\n        # LSODA is a good choice for systems that may be stiff or non-stiff.\n        sol = solve_ivp(\n            ode_system, \n            t_span, \n            y0, \n            method='LSODA', \n            t_eval=t_j, \n            args=args,\n            rtol=1e-6, \n            atol=1e-9\n        )\n        \n        # Extract sensitivities for glucose w.r.t. p1, p2, p3\n        # SGp1 is at index 2, SGp2 at 4, SGp3 at 6\n        SGp1_vals = sol.y[2]\n        SGp2_vals = sol.y[4]\n        SGp3_vals = sol.y[6]\n        \n        # Construct the Jacobian (Sensitivity) matrix J\n        J = np.vstack([SGp1_vals, SGp2_vals, SGp3_vals]).T\n        \n        # Compute the rank of J\n        rank = np.linalg.matrix_rank(J)\n        results.append(rank)\n\n    # Print the final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}