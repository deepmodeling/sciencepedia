{
    "hands_on_practices": [
        {
            "introduction": "在我们将数学框架应用于光谱解混之前，理解其物理基础至关重要。第一个实践将应用广泛的线性混合模型（Linear Mixing Model）植根于辐射传输的基本原理之中。通过从理想朗伯体（Lambertian surfaces）的辐射率和反射率定义出发推导该模型，您将巩固对像素复合光谱如何由其内部物质混合而成的理解，并明白为何丰度“和为一”约束是面积守恒的自然结果。",
            "id": "3855555",
            "problem": "考虑一个天底观测、经大气校正的多光谱传感器，它观测的单个图像像元视场足迹中包含两个由朗伯体材料组成的、独立的、互不作用的水平地表斑块。对于朗伯体表面，其双向反射分布函数（BRDF）为常数，因此出射辐射亮度与观测方向无关，且与入射辐照度成正比。假设向下辐照度在空间上是均匀的，子像元斑块上的光照和观测几何条件相同，邻近效应可以忽略，且不存在界面间的多重散射。这两种材料具有特定波段的反射率，分别为 $r_1=0.3$ 和 $r_2=0.6$，其面积覆盖度分数分别为 $f_1=0.4$ 和 $f_2=0.6$。从朗伯体表面的辐射亮度和反射率的核心定义，以及在均匀光照下不相交区域上辐射亮度的可加性出发，推导出像元波段反射率的线性面积混合表达式，然后根据给定值计算混合反射率。在推导过程中，请解释面积守恒如何导致面积覆盖度分数的隐含和为一约束，并指出在何种条件下该约束会被违反，以及届时混合模型中需要加入什么项。将最终反射率表示为无量纲小数，并四舍五入至四位有效数字。",
            "solution": "问题陈述经解析和验证，是科学上合理、提法恰当且内部一致的。它基于遥感和辐射传输的既定原理，特别是线性混合模型。所提供的数据对于所要求的推导和计算是充分且合适的。因此，我们可以开始求解。\n\n问题要求从朗伯体表面的辐射亮度和反射率的基本原理出发，推导像元反射率的线性混合模型。然后，我们将使用这个推导出的模型来计算给定参数下的混合反射率。还需要对面积覆盖度分数的和为一约束进行解释。\n\n令 $L$ 代表辐射亮度，即单位立体角、单位投影源面积上的辐射通量，单位为 $\\text{W} \\cdot \\text{m}^{-2} \\cdot \\text{sr}^{-1}$。令 $E$ 为向下辐照度，即入射到单位面积表面上的辐射通量，单位为 $\\text{W} \\cdot \\text{m}^{-2}$。朗伯体表面是一种理想的漫反射体，意味着它向各个方向均匀地反射入射辐射。对于朗伯体表面，其双向反射分布函数（BRDF），记为 $f_r$，是一个常数。从朗伯体表面反射的辐射亮度 $L_r$ 与入射辐照度成正比，由下式给出：\n$$L_r = f_r E$$\n半球反射率 $r$ 是总反射辐射通量与总入射辐射通量之比的无量纲值。对于朗伯体表面，反射率 $r$ 与BRDF的关系为 $r = \\pi f_r$。将 $f_r = r/\\pi$ 代入辐射亮度方程，我们得到在均匀辐照度 $E$ 下，反射率为 $r$ 的朗伯体表面所反射的辐射亮度表达式：\n$$L_r = \\frac{r}{\\pi} E$$\n问题考虑一个总面积为 $A$ 的传感器像元。该区域由材料1和材料2的两个独立的、互不作用的水平地表斑块组成。设它们的面积分别为 $A_1$ 和 $A_2$，朗伯反射率分别为 $r_1$ 和 $r_2$。面积覆盖度分数定义为 $f_1 = A_1 / A$ 和 $f_2 = A_2 / A$。\n\n由于辐射亮度在不相交区域上是可加的，离开像元朝向传感器方向的总辐射通量 $\\Phi_{pix}$ 是每个斑块通量之和。传感器测量整个像元的平均辐射亮度 $L_{pix}$。在天底观测传感器和水平斑块的假设下，投影面积等于物理面积。总辐射亮度是各独立斑块辐射亮度的面积加权平均值：\n$$L_{pix} = \\frac{L_1 A_1 + L_2 A_2}{A}$$\n其中 $L_1$ 和 $L_2$ 分别是斑块1和斑块2的辐射亮度。通过代入面积覆盖度分数的定义 $A_1 = f_1 A$ 和 $A_2 = f_2 A$，我们得到：\n$$L_{pix} = \\frac{L_1 (f_1 A) + L_2 (f_2 A)}{A} = f_1 L_1 + f_2 L_2$$\n这个方程表示辐射亮度的线性混合。\n\n问题陈述光照在子像元斑块上是空间均匀的。因此，两个斑块都受到相同的向下辐照度 $E$ 的照射。使用朗伯体辐射亮度-反射率关系，两个斑块的辐射亮度为：\n$$L_1 = \\frac{r_1}{\\pi} E$$\n$$L_2 = \\frac{r_2}{\\pi} E$$\n整个像元被视为一个具有有效（或混合）反射率 $r_{pix}$ 的单一实体。从该像元测得的辐射亮度 $L_{pix}$ 可以用这个有效反射率表示：\n$$L_{pix} = \\frac{r_{pix}}{\\pi} E$$\n现在，我们将 $L_{pix}$、$L_1$ 和 $L_2$ 的表达式代入线性辐射亮度混合方程：\n$$\\frac{r_{pix}}{\\pi} E = f_1 \\left(\\frac{r_1}{\\pi} E\\right) + f_2 \\left(\\frac{r_2}{\\pi} E\\right)$$\n假设辐照度不为零 ($E > 0$)，我们可以从方程的所有项中消去 $E/\\pi$ 项。这就得出了像元波段反射率的线性面积混合表达式：\n$$r_{pix} = f_1 r_1 + f_2 r_2$$\n这个推导可以推广到 $N$ 种组成材料（端元），从而得到标准的线性混合模型：\n$$r_{pix} = \\sum_{i=1}^{N} f_i r_i$$\n\n接下来，我们讨论面积覆盖度分数的和为一约束。面积覆盖度分数 $f_i$ 定义为材料 $i$ 占据的面积 $A_i$ 与像元总面积 $A$ 的比值，即 $f_i = A_i/A$。面积守恒原理要求，如果 $N$ 种材料的集合完全覆盖了像元区域，那么各子区域的面积之和必须等于总面积：\n$$\\sum_{i=1}^{N} A_i = A$$\n将整个方程除以总面积 $A$（非零），得到：\n$$\\frac{\\sum_{i=1}^{N} A_i}{A} = \\frac{A}{A}$$\n$$\\sum_{i=1}^{N} \\frac{A_i}{A} = 1$$\n根据面积覆盖度分数的定义，这变成了和为一约束：\n$$\\sum_{i=1}^{N} f_i = 1$$\n这个约束是一个隐含的推论，它源于所选端元完全覆盖像元内全部地表区域的假设。\n\n如果模型中使用的端元集合不完整，这个约束就会被违反。例如，如果像元的一部分被第三种材料覆盖，或者处于阴影中，但模型只包含了材料1和2的端元，那么面积的真实总和 $A_1+A_2$ 将小于 $A$。这意味着 $f_1 + f_2  1$。在实际的解混应用中，如果不强制执行和为一约束，得出的分数之和可能不等于1，这表明存在未建模的组分。为了纠正这一点，必须扩展模型。需要为每个未建模的组分 $k$ 添加一个额外的乘积项 $f_k r_k$。一个常见的例子是引入一个“阴影端元”（$r_{shade} \\approx 0$），其分数为 $f_{shade}$。那么模型将变为 $r_{pix} = \\sum_{i=1}^{N} f_i r_i + f_{shade} r_{shade}$，而约束将变为 $\\sum_{i=1}^{N} f_i + f_{shade} = 1$。\n\n最后，我们计算给定值的混合反射率：$r_1 = 0.3$，$r_2 = 0.6$，$f_1 = 0.4$，和 $f_2 = 0.6$。注意到 $f_1 + f_2 = 0.4 + 0.6 = 1.0$，满足和为一约束，这与问题陈述中像元仅包含这两种材料的说法是一致的。\n使用推导出的公式：\n$$r_{pix} = f_1 r_1 + f_2 r_2$$\n$$r_{pix} = (0.4)(0.3) + (0.6)(0.6)$$\n$$r_{pix} = 0.12 + 0.36$$\n$$r_{pix} = 0.48$$\n问题要求将结果表示为无量纲小数，并四舍五入至四位有效数字。因此，我们将 $0.48$ 表示为 $0.4800$。",
            "answer": "$$\n\\boxed{0.4800}\n$$"
        },
        {
            "introduction": "建立了线性模型后 ()，我们的下一个任务是估算未知的物质丰度。本练习要求您应用一种直接的数学方法——无约束最小二乘法（Unconstrained Least Squares, ULS）——来求解丰度。通过分析其结果，您将发现该方法的致命缺陷：其解可能在物理上是无意义的，违背了基本约束，这凸显了将物理约束直接整合到反演过程中的必要性。",
            "id": "3855536",
            "problem": "考虑遥感中光谱解混的线性混合模型 (LMM)：一个观测光谱 $x \\in \\mathbb{R}^{L}$ 表示为矩阵 $M \\in \\mathbb{R}^{L \\times P}$ 中收集的 $P$ 个端元光谱的线性组合，即 $x = M a + n$，其中 $a \\in \\mathbb{R}^{P}$ 是丰度向量，$n \\in \\mathbb{R}^{L}$ 是测量噪声。在没有约束的情况下，无约束最小二乘 (ULS) 丰度估计旨在最小化重构误差的平方 $\\|x - M a\\|_{2}^{2}$。\n\n一个高光谱像元在 $L = 3$ 个波段上进行测量，有 $P = 3$ 个候选端元。端元矩阵和像元光谱由下式给出\n$$\nM =\n\\begin{bmatrix}\n0.2  0.7  0.1 \\\\\n0.3  0.1  0.6 \\\\\n0.5  0.2  0.4\n\\end{bmatrix},\n\\quad\nx =\n\\begin{bmatrix}\n0.35 \\\\\n0.25 \\\\\n0.4\n\\end{bmatrix},\n\\quad\nn = 0.\n$$\n从 LMM 下的 ULS 问题定义出发，不引用任何丰度约束，推导正规方程并计算 ULS 丰度估计 $\\hat{a} \\in \\mathbb{R}^{3}$。然后，使用线性光谱解混的标准物理丰度约束（非负性和和为一），判断 $\\hat{a}$ 是否违反了这些约束，并将任何违规量化为小数。将 $\\hat{a}$ 的条目四舍五入到 4 位有效数字，并以小数形式表示。最终答案必须仅为丰度向量（无单位）。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **模型**：线性混合模型 (LMM)，$x = M a + n$。\n*   $x \\in \\mathbb{R}^{L}$ 是观测光谱。\n*   $M \\in \\mathbb{R}^{L \\times P}$ 是端元矩阵。\n*   $a \\in \\mathbb{R}^{P}$ 是丰度向量。\n*   $n \\in \\mathbb{R}^{L}$ 是测量噪声。\n*   **估计器**：无约束最小二乘 (ULS)，它最小化代价函数 $J(a) = \\|x - M a\\|_{2}^{2}$。\n*   **维度**：光谱波段数 $L=3$，端元数 $P=3$。\n*   **端元矩阵**：\n    $$\n    M =\n    \\begin{bmatrix}\n    0.2  0.7  0.1 \\\\\n    0.3  0.1  0.6 \\\\\n    0.5  0.2  0.4\n    \\end{bmatrix}\n    $$\n*   **观测光谱**：\n    $$\n    x =\n    \\begin{bmatrix}\n    0.35 \\\\\n    0.25 \\\\\n    0.4\n    \\end{bmatrix}\n    $$\n*   **噪声向量**：$n = 0$。\n*   **任务**：\n    1.  推导正规方程。\n    2.  计算 ULS 丰度估计 $\\hat{a}$。\n    3.  检查是否违反非负性 ($a_i \\ge 0$) 和和为一 ($\\sum a_i = 1$) 约束。\n    4.  量化任何违规。\n    5.  将 $\\hat{a}$ 的条目四舍五入到 4 位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学依据**：该问题是线性代数在遥感领域，特别是高光谱解混中的一个标准应用。LMM 和 ULS 是基础且广泛使用的概念。该问题在科学上是合理的。\n*   **适定性**：该问题需要求解一个线性方程组。由于端元矩阵 $M$ 是一个方阵 ($L=P=3$)，当且仅当 $M$ 可逆时，丰度向量 $a$ 存在唯一解。$M$ 的行列式为 $\\det(M) = 0.2(0.1 \\cdot 0.4 - 0.6 \\cdot 0.2) - 0.7(0.3 \\cdot 0.4 - 0.6 \\cdot 0.5) + 0.1(0.3 \\cdot 0.2 - 0.1 \\cdot 0.5) = 0.2(-0.08) - 0.7(-0.18) + 0.1(0.01) = -0.016 + 0.126 + 0.001 = 0.111$。由于 $\\det(M) \\neq 0$，矩阵 $M$ 可逆，存在唯一解。该问题是适定的。\n*   **客观性**：该问题使用精确的数学语言和定义进行陈述，没有任何主观性或歧义。\n*   **其他缺陷**：该问题不违反任何其他标准。它是自包含的、一致的，并且可以科学地形式化。\n\n**步骤 3：结论和行动**\n\n问题**有效**。将提供完整解答。\n\n### 解答\n\n无约束最小二乘 (ULS) 问题定义为找到丰度向量 $\\hat{a}$，以最小化残差的平方欧几里得范数：\n$$\n\\hat{a} = \\arg\\min_{a} \\|x - Ma\\|_{2}^{2}\n$$\n需要最小化的代价函数是 $J(a) = \\|x - Ma\\|_{2}^{2}$。我们可以展开这个表达式：\n$$\nJ(a) = (x - Ma)^{T}(x - Ma) = (x^T - a^T M^T)(x - Ma) = x^T x - x^T Ma - a^T M^T x + a^T M^T M a\n$$\n由于 $x^T Ma$ 是标量，它等于其转置，$(x^T Ma)^T = a^T M^T x$。因此，代价函数简化为：\n$$\nJ(a) = x^T x - 2a^T M^T x + a^T M^T M a\n$$\n为了找到最小值，我们计算 $J(a)$ 关于 $a$ 的梯度并将其设为零：\n$$\n\\nabla_{a} J(a) = \\nabla_{a} (x^T x - 2a^T M^T x + a^T M^T M a) = 0 - 2M^T x + 2M^T M a\n$$\n将梯度设为零可得：\n$$\n2M^T M a = 2M^T x\n$$\n这就得到了**正规方程**：\n$$\nM^T M a = M^T x\n$$\nULS 估计的通解是 $\\hat{a} = (M^T M)^{-1} M^T x$。\n\n在这个具体问题中，给定噪声项 $n$ 为零，且矩阵 $M$ 是方的 ($3 \\times 3$) 且可逆。模型 $x = Ma + n$ 简化为 $x = Ma$。我们可以通过左乘 $M$ 的逆矩阵直接求解 $a$：\n$$\n\\hat{a} = M^{-1}x\n$$\n当 $M$ 可逆时，这等价于求解正规方程：$M^T M a = M^T x \\implies (M^T)^{-1}M^T M a = (M^T)^{-1}M^T x \\implies Ma = x \\implies a = M^{-1}x$。\n\n我们接着计算 $M^{-1}$。矩阵 $M$ 的逆由 $M^{-1} = \\frac{1}{\\det(M)}\\text{adj}(M)$ 给出，其中 $\\text{adj}(M)$ 是 $M$ 的伴随矩阵。\n行列式先前已计算为 $\\det(M) = 0.111$。\n余子式矩阵 $C$ 为：\n$$\nC_{11} = +(0.1 \\cdot 0.4 - 0.6 \\cdot 0.2) = -0.08 \\\\\nC_{12} = -(0.3 \\cdot 0.4 - 0.6 \\cdot 0.5) = 0.18 \\\\\nC_{13} = +(0.3 \\cdot 0.2 - 0.1 \\cdot 0.5) = 0.01 \\\\\nC_{21} = -(0.7 \\cdot 0.4 - 0.1 \\cdot 0.2) = -0.26 \\\\\nC_{22} = +(0.2 \\cdot 0.4 - 0.1 \\cdot 0.5) = 0.03 \\\\\nC_{23} = -(0.2 \\cdot 0.2 - 0.7 \\cdot 0.5) = 0.31 \\\\\nC_{31} = +(0.7 \\cdot 0.6 - 0.1 \\cdot 0.1) = 0.41 \\\\\nC_{32} = -(0.2 \\cdot 0.6 - 0.1 \\cdot 0.3) = -0.09 \\\\\nC_{33} = +(0.2 \\cdot 0.1 - 0.7 \\cdot 0.3) = -0.19\n$$\n所以，余子式矩阵是 $C = \\begin{bmatrix} -0.08  0.18  0.01 \\\\ -0.26  0.03  0.31 \\\\ 0.41  -0.09  -0.19 \\end{bmatrix}$。\n伴随矩阵是余子式矩阵的转置，$\\text{adj}(M) = C^T$：\n$$\n\\text{adj}(M) = \\begin{bmatrix} -0.08  -0.26  0.41 \\\\ 0.18  0.03  -0.09 \\\\ 0.01  0.31  -0.19 \\end{bmatrix}\n$$\n逆矩阵是：\n$$\nM^{-1} = \\frac{1}{0.111} \\begin{bmatrix} -0.08  -0.26  0.41 \\\\ 0.18  0.03  -0.09 \\\\ 0.01  0.31  -0.19 \\end{bmatrix}\n$$\n现在我们计算丰度向量 $\\hat{a} = M^{-1}x$：\n$$\n\\hat{a} = \\frac{1}{0.111} \\begin{bmatrix} -0.08  -0.26  0.41 \\\\ 0.18  0.03  -0.09 \\\\ 0.01  0.31  -0.19 \\end{bmatrix} \\begin{bmatrix} 0.35 \\\\ 0.25 \\\\ 0.4 \\end{bmatrix}\n$$\n$$\n\\hat{a} = \\frac{1}{0.111} \\begin{bmatrix} (-0.08)(0.35) + (-0.26)(0.25) + (0.41)(0.4) \\\\ (0.18)(0.35) + (0.03)(0.25) + (-0.09)(0.4) \\\\ (0.01)(0.35) + (0.31)(0.25) + (-0.19)(0.4) \\end{bmatrix}\n$$\n$$\n\\hat{a} = \\frac{1}{0.111} \\begin{bmatrix} -0.028 - 0.065 + 0.164 \\\\ 0.063 + 0.0075 - 0.036 \\\\ 0.0035 + 0.0775 - 0.076 \\end{bmatrix} = \\frac{1}{0.111} \\begin{bmatrix} 0.071 \\\\ 0.0345 \\\\ 0.005 \\end{bmatrix} = \\begin{bmatrix} \\frac{0.071}{0.111} \\\\ \\frac{0.0345}{0.111} \\\\ \\frac{0.005}{0.111} \\end{bmatrix}\n$$\n计算各分量：\n$$\n\\hat{a}_1 = 0.63963963... \\\\\n\\hat{a}_2 = 0.31081081... \\\\\n\\hat{a}_3 = 0.04504504...\n$$\n四舍五入到 4 位有效数字，我们得到：\n$$\n\\hat{a} \\approx \\begin{bmatrix} 0.6396 \\\\ 0.3108 \\\\ 0.04505 \\end{bmatrix}\n$$\n\n接下来，我们检查是否违反物理丰度约束。\n1.  **非负性约束 (ANC)**：对于所有 $i=1, 2, 3$，$a_i \\ge 0$。\n    *   $\\hat{a}_1 \\approx 0.6396 > 0$\n    *   $\\hat{a}_2 \\approx 0.3108 > 0$\n    *   $\\hat{a}_3 \\approx 0.04505 > 0$\n    所有分量都满足此约束。没有违反非负性。\n\n2.  **和为一约束 (ASC)**：$\\sum_{i=1}^{3} a_i = 1$。\n    为了更高的精度，使用未四舍五入的值，其和为：\n    $$\n    \\sum_{i=1}^{3} \\hat{a}_i = \\frac{0.071 + 0.0345 + 0.005}{0.111} = \\frac{0.1105}{0.111} \\approx 0.995495...\n    $$\n    和不等于 1。此约束被违反。\n    违背量是和与 1 之间的差：\n    $$\n    \\text{Violation} = \\sum_{i=1}^{3} \\hat{a}_i - 1 = \\frac{0.1105}{0.111} - 1 = \\frac{0.1105 - 0.111}{0.111} = \\frac{-0.0005}{0.111} \\approx -0.0045045...\n    $$\n    丰度之和约为 $0.9955$，相对于和为一的要求，存在约 $0.0045$ 的亏缺。\n\n最终要求的答案是丰度向量 $\\hat{a}$，其条目四舍五入到 4 位有效数字。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.6396 \\\\\n0.3108 \\\\\n0.04505\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "为了获得物理上真实的丰度估计，需要求解一个同时满足非负性和“和为一”约束的优化问题，而诸如无约束最小二乘法这样的简单解析解无法胜任此任务 ()。最后一个实践将带您从理论走向实现，指导您构建投影梯度下降算法——这是一种在光谱解混中解决此类约束优化问题的强大而通用的方法。通过编码和测试该求解器，您将获得构建现代解混框架核心计算引擎的实践经验。",
            "id": "3855511",
            "problem": "考虑一个在遥感和环境建模中常见的线性光谱混合场景。一个具有 $L$ 个光谱波段的单一像素被建模为 $p$ 个端元光谱的线性组合，并带有加性测量噪声，同时满足丰度非负且总和为一的物理约束。令 $\\boldsymbol{y} \\in \\mathbb{R}^{L}$ 表示观测到的光谱向量，令 $\\boldsymbol{E} \\in \\mathbb{R}^{L \\times p}$ 表示端元矩阵，其列为端元光谱。未知丰度向量为 $\\boldsymbol{a} \\in \\mathbb{R}^{p}$，其约束集为 $\\mathcal{S} = \\left\\{ \\boldsymbol{a} \\in \\mathbb{R}^{p} \\,\\middle|\\, \\boldsymbol{a} \\ge \\boldsymbol{0}, \\ \\boldsymbol{1}^{\\top}\\boldsymbol{a} = 1 \\right\\}$。数据模型是经过充分检验的线性混合模型 $\\boldsymbol{y} = \\boldsymbol{E}\\boldsymbol{a} + \\boldsymbol{n}$，其中 $\\boldsymbol{n}$ 是加性噪声。\n\n以此为基础，推导并实现一种投影梯度下降迭代方法，通过最小化受约束的平方数据失配来估计 $\\boldsymbol{a}$，即求解优化问题 $\\min_{\\boldsymbol{a} \\in \\mathcal{S}} \\tfrac{1}{2}\\lVert \\boldsymbol{E}\\boldsymbol{a} - \\boldsymbol{y} \\rVert_{2}^{2}$。使用一个由光滑凸优化的基本原理保证收敛的恒定步长，并使用到单位单纯形上的欧几里得投影来强制执行约束 $\\mathcal{S}$。基于通过投影梯度映射定义的投影残差的范数建立一个收敛准则，当满足此准则时终止。\n\n您必须生成一个单一程序，为以下参数值的测试套件计算丰度估计，并打印包含结果的单行输出：\n\n该测试套件包含 $4$ 个案例，具有 $L = 5$ 个光谱波段和 $p = 3$ 个端元。所有反射率和丰度都是无量纲分数，必须表示为小数（而非百分比）。\n\n案例 1（“顺利”路径，内部解）：\n$$\n\\boldsymbol{E}^{(1)} = \\begin{bmatrix}\n0.52  0.31  0.10 \\\\\n0.48  0.35  0.12 \\\\\n0.50  0.40  0.15 \\\\\n0.55  0.45  0.20 \\\\\n0.53  0.42  0.18\n\\end{bmatrix}, \\quad\n\\boldsymbol{a}_{\\text{true}}^{(1)} = \\begin{bmatrix} 0.20 \\\\ 0.50 \\\\ 0.30 \\end{bmatrix}, \\quad\n\\boldsymbol{y}^{(1)} = \\boldsymbol{E}^{(1)}\\boldsymbol{a}_{\\text{true}}^{(1)} + \\begin{bmatrix} 0.001 \\\\ -0.002 \\\\ 0.000 \\\\ 0.001 \\\\ -0.001 \\end{bmatrix}.\n$$\n\n案例 2（具有激活非负性约束的边界解）：\n$$\n\\boldsymbol{E}^{(2)} = \\boldsymbol{E}^{(1)}, \\quad\n\\boldsymbol{a}_{\\text{true}}^{(2)} = \\begin{bmatrix} 0.00 \\\\ 0.60 \\\\ 0.40 \\end{bmatrix}, \\quad\n\\boldsymbol{y}^{(2)} = \\boldsymbol{E}^{(2)}\\boldsymbol{a}_{\\text{true}}^{(2)} + \\begin{bmatrix} 0.0005 \\\\ 0.0000 \\\\ -0.0005 \\\\ 0.0005 \\\\ -0.0005 \\end{bmatrix}.\n$$\n\n案例 3（因高反射率导致凸包外的不一致数据向量；约束最小二乘解位于 $\\mathcal{S}$ 的边界上）：\n$$\n\\boldsymbol{E}^{(3)} = \\boldsymbol{E}^{(1)}, \\quad\n\\boldsymbol{y}^{(3)} = \\begin{bmatrix} 0.60 \\\\ 0.62 \\\\ 0.66 \\\\ 0.70 \\\\ 0.75 \\end{bmatrix}.\n$$\n\n案例 4（具有近共线列的病态端元集，用以测试数值稳定性）：\n$$\n\\boldsymbol{E}^{(4)} = \\begin{bmatrix}\n0.50  0.50  0.20 \\\\\n0.52  0.51  0.22 \\\\\n0.54  0.53  0.24 \\\\\n0.56  0.55  0.26 \\\\\n0.58  0.57  0.28\n\\end{bmatrix}, \\quad\n\\boldsymbol{a}_{\\text{true}}^{(4)} = \\begin{bmatrix} 0.10 \\\\ 0.70 \\\\ 0.20 \\end{bmatrix}, \\quad\n\\boldsymbol{y}^{(4)} = \\boldsymbol{E}^{(4)}\\boldsymbol{a}_{\\text{true}}^{(4)} + \\begin{bmatrix} -0.001 \\\\ 0.001 \\\\ 0.000 \\\\ -0.001 \\\\ 0.001 \\end{bmatrix}.\n$$\n\n源于基本原理的实现要求：\n您必须使用一个恒定步长 $\\gamma$，该步长取决于目标函数梯度的 Lipschitz 连续性。将 $\\boldsymbol{a}$ 在 $\\mathcal{S}$ 中均匀初始化为 $\\boldsymbol{a}^{(0)} = \\tfrac{1}{p}\\boldsymbol{1}$。在每次迭代中，对光滑目标函数执行一次梯度步进，然后投影到 $\\mathcal{S}$ 上。对 $\\mathcal{S}$ 使用到单位单纯形上的欧几里得投影。通过投影梯度映射定义投影残差，当残差范数除以 $\\max\\!\\left(1, \\lVert \\boldsymbol{a}^{(k)} \\rVert_{2}\\right)$ 小于指定容差时终止。\n\n对于所有案例，将容差设置为 $10^{-8}$，最大迭代次数设置为 $5000$。将每个丰度分量以小数形式打印到 $6$ 位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个项目本身是表示一个案例的丰度向量的 $p$ 个小数的列表，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不含空格。",
            "solution": "该问题要求推导并实现一种投影梯度下降算法，以解决由线性光谱解混模型产生的约束最小二乘问题。该优化问题是找到丰度向量 $\\boldsymbol{a}$，使其在满足物理约束的同时最小化数据失配。\n\n要最小化的目标函数是数据残差的平方欧几里得范数：\n$$\nf(\\boldsymbol{a}) = \\frac{1}{2}\\lVert \\boldsymbol{E}\\boldsymbol{a} - \\boldsymbol{y} \\rVert_{2}^{2}\n$$\n其约束条件是丰度非负且总和为一。这个约束集 $\\mathcal{S} = \\left\\{ \\boldsymbol{a} \\in \\mathbb{R}^{p} \\,\\middle|\\, \\boldsymbol{a} \\ge \\boldsymbol{0}, \\ \\boldsymbol{1}^{\\top}\\boldsymbol{a} = 1 \\right\\}$ 是单位单纯形，它是一个闭凸集。目标函数 $f(\\boldsymbol{a})$ 是关于 $\\boldsymbol{a}$ 的二次函数，因此是凸且连续可微的。在凸集上最小化凸函数是一个凸优化问题，对于这类问题，诸如投影梯度下降之类的标准方法保证能收敛到全局最小值。\n\n投影梯度下降法是一种迭代算法，它通过首先沿无约束目标函数的负梯度方向移动一步，然后将结果投影回可行集 $\\mathcal{S}$ 来更新当前估计 $\\boldsymbol{a}^{(k)}$。更新规则为：\n$$\n\\boldsymbol{a}^{(k+1)} = \\mathcal{P}_{\\mathcal{S}}\\left(\\boldsymbol{a}^{(k)} - \\gamma \\nabla f(\\boldsymbol{a}^{(k)})\\right)\n$$\n其中 $\\boldsymbol{a}^{(k)}$ 是第 $k$ 次迭代的估计值，$\\gamma  0$ 是步长，$\\nabla f(\\boldsymbol{a}^{(k)})$ 是在 $\\boldsymbol{a}^{(k)}$ 处计算的目标函数梯度，而 $\\mathcal{P}_{\\mathcal{S}}(\\cdot)$ 是到单纯形 $\\mathcal{S}$ 上的欧几里得投影算子。\n\n首先，我们推导 $f(\\boldsymbol{a})$ 的梯度。目标函数可以展开为：\n$$\nf(\\boldsymbol{a}) = \\frac{1}{2}(\\boldsymbol{E}\\boldsymbol{a} - \\boldsymbol{y})^{\\top}(\\boldsymbol{E}\\boldsymbol{a} - \\boldsymbol{y}) = \\frac{1}{2}(\\boldsymbol{a}^{\\top}\\boldsymbol{E}^{\\top}\\boldsymbol{E}\\boldsymbol{a} - 2\\boldsymbol{y}^{\\top}\\boldsymbol{E}\\boldsymbol{a} + \\boldsymbol{y}^{\\top}\\boldsymbol{y})\n$$\n关于向量 $\\boldsymbol{a}$ 的梯度是：\n$$\n\\nabla f(\\boldsymbol{a}) = \\boldsymbol{E}^{\\top}\\boldsymbol{E}\\boldsymbol{a} - \\boldsymbol{E}^{\\top}\\boldsymbol{y} = \\boldsymbol{E}^{\\top}(\\boldsymbol{E}\\boldsymbol{a} - \\boldsymbol{y})\n$$\n\n接下来，我们确定一个能保证收敛的步长 $\\gamma$。对于具有 Lipschitz 连续梯度的凸函数，如果步长 $\\gamma$ 的选择满足 $0  \\gamma  2/L_f$，则投影梯度下降的收敛性得到保证，其中 $L_f$ 是梯度 $\\nabla f(\\boldsymbol{a})$ 的 Lipschitz 常数。如果存在一个常数 $L_f$ 使得对于任意两个向量 $\\boldsymbol{a}_1, \\boldsymbol{a}_2$ 都满足以下条件，则梯度 $\\nabla f(\\boldsymbol{a})$ 是 Lipschitz 连续的：\n$$\n\\lVert \\nabla f(\\boldsymbol{a}_1) - \\nabla f(\\boldsymbol{a}_2) \\rVert_2 \\le L_f \\lVert \\boldsymbol{a}_1 - \\boldsymbol{a}_2 \\rVert_2\n$$\n对于我们的梯度，我们有：\n$$\n\\lVert \\nabla f(\\boldsymbol{a}_1) - \\nabla f(\\boldsymbol{a}_2) \\rVert_2 = \\lVert (\\boldsymbol{E}^{\\top}\\boldsymbol{E}\\boldsymbol{a}_1 - \\boldsymbol{E}^{\\top}\\boldsymbol{y}) - (\\boldsymbol{E}^{\\top}\\boldsymbol{E}\\boldsymbol{a}_2 - \\boldsymbol{E}^{\\top}\\boldsymbol{y}) \\rVert_2 = \\lVert \\boldsymbol{E}^{\\top}\\boldsymbol{E}(\\boldsymbol{a}_1 - \\boldsymbol{a}_2) \\rVert_2 \\le \\lVert \\boldsymbol{E}^{\\top}\\boldsymbol{E} \\rVert_2 \\lVert \\boldsymbol{a}_1 - \\boldsymbol{a}_2 \\rVert_2\n$$\n因此，Lipschitz 常数为 $L_f = \\lVert \\boldsymbol{E}^{\\top}\\boldsymbol{E} \\rVert_2$，其中 $\\lVert \\cdot \\rVert_2$ 表示谱范数（最大奇异值）。由于 $\\boldsymbol{E}^{\\top}\\boldsymbol{E}$ 是一个半正定矩阵，其谱范数等于其最大特征值 $\\lambda_{\\max}(\\boldsymbol{E}^{\\top}\\boldsymbol{E})$。这也等于 $\\boldsymbol{E}$ 的最大奇异值的平方，即 $\\sigma_{\\max}(\\boldsymbol{E})^2$。一个能保证收敛的安全且标准的选择是步长 $\\gamma = 1/L_f = 1/\\sigma_{\\max}(\\boldsymbol{E})^2$。\n\n到单位单纯形上的投影 $\\boldsymbol{x} = \\mathcal{P}_{\\mathcal{S}}(\\boldsymbol{v})$ 是二次规划问题 $\\min_{\\boldsymbol{x} \\in \\mathcal{S}} \\frac{1}{2}\\lVert \\boldsymbol{x} - \\boldsymbol{v} \\rVert_2^2$ 的解。这个问题可以被高效求解。一个标准算法包括将 $\\boldsymbol{v}$ 的分量降序排序，并找到一个阈值 $\\theta$，使得投影由 $x_i = \\max(v_i - \\theta, 0)$ 给出。\n\n该算法流程如下：\n1. 初始化 $\\boldsymbol{a}^{(0)} = \\frac{1}{p}\\boldsymbol{1}$。\n2. 计算步长 $\\gamma = 1 / \\sigma_{\\max}(\\boldsymbol{E})^2$。\n3. 对于 $k = 0, 1, 2, \\dots$ 直到收敛或达到最大迭代次数：\n    a. 计算梯度：$\\boldsymbol{g}^{(k)} = \\boldsymbol{E}^{\\top}(\\boldsymbol{E}\\boldsymbol{a}^{(k)} - \\boldsymbol{y})$。\n    b. 更新估计值：$\\boldsymbol{a}^{(k+1)} = \\mathcal{P}_{\\mathcal{S}}(\\boldsymbol{a}^{(k)} - \\gamma \\boldsymbol{g}^{(k)})$。\n    c. 检查收敛性。\n\n终止准则基于投影梯度的范数，对于一个驻点 $\\boldsymbol{a}^*$ 来说，该范数必须为零。一个点 $\\boldsymbol{a}^*$ 是解，当且仅当它满足不动点方程 $\\boldsymbol{a}^* = \\mathcal{P}_{\\mathcal{S}}(\\boldsymbol{a}^* - \\gamma \\nabla f(\\boldsymbol{a}^*))$。投影梯度映射定义为 $\\nabla f_{\\text{proj}}(\\boldsymbol{a}) = \\frac{1}{\\gamma}(\\boldsymbol{a} - \\mathcal{P}_{\\mathcal{S}}(\\boldsymbol{a} - \\gamma \\nabla f(\\boldsymbol{a})))$。当这个量的相对范数低于容差 $\\epsilon$ 时，我们终止迭代：\n$$\n\\frac{\\lVert \\nabla f_{\\text{proj}}(\\boldsymbol{a}^{(k)}) \\rVert_2}{\\max(1, \\lVert \\boldsymbol{a}^{(k)} \\rVert_2)} = \\frac{\\frac{1}{\\gamma} \\lVert \\boldsymbol{a}^{(k)} - \\boldsymbol{a}^{(k+1)} \\rVert_2}{\\max(1, \\lVert \\boldsymbol{a}^{(k)} \\rVert_2)}  \\epsilon\n$$\n对于本实现，我们使用指定的容差 $\\epsilon = 10^{-8}$ 和最大 $5000$ 次迭代。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the spectral unmixing problem for all test cases.\n    \"\"\"\n\n    def project_to_simplex(v):\n        \"\"\"\n        Projects a vector v onto the unit simplex using the algorithm\n        by Duchi et al. (2008).\n        \n        Args:\n            v (np.ndarray): The vector to project.\n        \n        Returns:\n            np.ndarray: The projected vector.\n        \"\"\"\n        p = len(v)\n        u = np.sort(v)[::-1]\n        cssv = np.cumsum(u)\n        \n        ind = np.arange(1, p + 1)\n        cond = u - (cssv - 1.0) / ind\n        \n        rho_candidates = np.where(cond  0)[0]\n        if len(rho_candidates) == 0:\n            # This can happen for vectors with all components very small or negative\n            rho = p \n        else:\n            rho = rho_candidates[-1] + 1\n        \n        theta = (cssv[rho - 1] - 1.0) / rho\n        x = np.maximum(v - theta, 0)\n        \n        return x\n\n    def solve_abundances(E, y, tol=1e-8, max_iter=5000):\n        \"\"\"\n        Solves the constrained least squares problem for spectral unmixing\n        using projected gradient descent.\n        \n        Args:\n            E (np.ndarray): The endmember matrix (L x p).\n            y (np.ndarray): The observed pixel vector (L).\n            tol (float): The convergence tolerance.\n            max_iter (int): The maximum number of iterations.\n            \n        Returns:\n            np.ndarray: The estimated abundance vector (p).\n        \"\"\"\n        L, p = E.shape\n        \n        # Calculate step size gamma from the Lipschitz constant of the gradient.\n        # L_f is the squared largest singular value of E.\n        L_f = np.linalg.norm(E, 2)**2\n        gamma = 1.0 / L_f\n        \n        # Initialize abundance vector 'a' uniformly on the simplex.\n        a = np.full(p, 1.0 / p)\n        \n        for k in range(max_iter):\n            # Compute the gradient of the objective function.\n            grad_f = E.T @ (E @ a - y)\n            \n            # Perform the gradient descent step.\n            a_unproj = a - gamma * grad_f\n            \n            # Project the result back onto the unit simplex.\n            a_next = project_to_simplex(a_unproj)\n            \n            # Check for convergence using the norm of the projected gradient.\n            # projected_gradient = (1/gamma) * (a - a_next)\n            projected_gradient_norm = np.linalg.norm(a - a_next) / gamma\n            norm_a = np.linalg.norm(a)\n            \n            if projected_gradient_norm / max(1.0, norm_a)  tol:\n                a = a_next\n                break\n            \n            a = a_next\n\n        return a\n\n    # Define the test cases from the problem statement.\n    E1 = np.array([\n        [0.52, 0.31, 0.10],\n        [0.48, 0.35, 0.12],\n        [0.50, 0.40, 0.15],\n        [0.55, 0.45, 0.20],\n        [0.53, 0.42, 0.18]\n    ])\n    \n    # Case 1\n    a_true1 = np.array([0.20, 0.50, 0.30])\n    n1 = np.array([0.001, -0.002, 0.000, 0.001, -0.001])\n    y1 = E1 @ a_true1 + n1\n\n    # Case 2\n    E2 = E1\n    a_true2 = np.array([0.00, 0.60, 0.40])\n    n2 = np.array([0.0005, 0.0000, -0.0005, 0.0005, -0.0005])\n    y2 = E2 @ a_true2 + n2\n    \n    # Case 3\n    E3 = E1\n    y3 = np.array([0.60, 0.62, 0.66, 0.70, 0.75])\n\n    # Case 4\n    E4 = np.array([\n        [0.50, 0.50, 0.20],\n        [0.52, 0.51, 0.22],\n        [0.54, 0.53, 0.24],\n        [0.56, 0.55, 0.26],\n        [0.58, 0.57, 0.28]\n    ])\n    a_true4 = np.array([0.10, 0.70, 0.20])\n    n4 = np.array([-0.001, 0.001, 0.000, -0.001, 0.001])\n    y4 = E4 @ a_true4 + n4\n    \n    test_cases = [\n        (E1, y1),\n        (E2, y2),\n        (E3, y3),\n        (E4, y4),\n    ]\n\n    results = []\n    for E, y in test_cases:\n        a_est = solve_abundances(E, y)\n        results.append(a_est)\n\n    # Format the final output string according to the problem specification.\n    # e.g., [[val1,val2,...],[val1,val2,...],...]\n    # Abundances are formatted to 6 decimal places.\n    formatted_results = []\n    for res_vec in results:\n        formatted_vec = ','.join([f'{x:.6f}' for x in res_vec])\n        formatted_results.append(f'[{formatted_vec}]')\n    \n    final_output = f\"[[{','.join(formatted_results)}]]\"\n    \n    print(final_output.replace(\"],[\", \"],[\"))\n\nsolve()\n```"
        }
    ]
}