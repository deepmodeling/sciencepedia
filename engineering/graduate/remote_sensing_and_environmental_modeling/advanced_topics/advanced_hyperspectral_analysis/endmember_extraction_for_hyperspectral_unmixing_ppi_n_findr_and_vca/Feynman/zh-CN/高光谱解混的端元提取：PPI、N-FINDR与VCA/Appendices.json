{
    "hands_on_practices": [
        {
            "introduction": "像元纯度指数 (PPI) 算法是基于一个直观的几何思想：光谱混合空间中的端元通常对应于数据云的顶点或“最纯”的像元。该算法通过将所有像元投影到大量随机生成的单位向量上，并记录落在投影方向最远端的像元来识别这些极值点。本练习  将带您深入 PPI 算法的核心机制，要求您从第一性原理出发，推导其关键步骤——生成随机投影方向并将像元投影到这些方向上以获得“纯度”分数。",
            "id": "3808886",
            "problem": "考虑在高光谱解混中使用的线性光谱混合模型，其中每个观测到的像素向量 $\\mathbf{x}_i \\in \\mathbb{R}^{L}$ 被建模为端元光谱的凸组合加上加性噪声。诸如像素纯度指数（PPI）、$N$-FINDR和顶点成分分析（VCA）等端元提取算法，旨在识别光谱空间中数据云的极值点。PPI的一个关键步骤是在$\\mathbb{R}^{L}$的单位球面上均匀选择随机方向，并计算每个像素在该方向上的标量投影得分，以评估其极值程度。\n\n从基本的概率论和线性代数原理出发——具体来说，是多元正态分布的旋转不变性以及有限维实向量空间中内积的定义——推导一个数学上有效的方法，用于在$\\mathbb{R}^{L}$的单位球面上生成均匀分布的随机单位方向。然后，利用内积结构，推导一个像素向量在给定单位方向上的标量投影，作为PPI使用的得分。\n\n完成这些推导后，计算以下特定案例的标量投影得分，该案例代表在一个$L=4$波段的高光谱图像中的一次PPI试验。设像素为 $\\mathbf{x}_i = \\begin{bmatrix}4 \\\\ -1 \\\\ 0 \\\\ 3\\end{bmatrix}$，随机向量为 $\\mathbf{z} = \\begin{bmatrix}2 \\\\ -1 \\\\ 2 \\\\ 1\\end{bmatrix}$，其中$\\mathbf{z}$是根据您推导的随机单位方向生成过程构建的。使用您的推导将$\\mathbf{z}$转换为一个单位方向，然后计算$\\mathbf{x}_i$在该方向上的标量得分。\n\n将您的答案四舍五入到$5$位有效数字。您的最终答案应表示为纯标量（无单位）。",
            "solution": "该问题要求推导与高光谱解混的像素纯度指数（PPI）算法相关的两个基本组成部分，然后进行一次具体计算。我将首先验证问题陈述的有效性。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   **模型：** 线性光谱混合模型，其中每个像素 $\\mathbf{x}_i \\in \\mathbb{R}^{L}$ 是端元的凸组合加上加性噪声。\n-   **背景：** 端元提取算法（PPI, $N$-FINDR, VCA）识别数据云的极值点。\n-   **PPI流程元素：** 在$\\mathbb{R}^{L}$的单位球面上均匀选择随机方向，并计算一个标量投影得分。\n-   **推导任务1：** 基于多元正态分布的旋转不变性和内积，推导一个在$\\mathbb{R}^{L}$的单位球面上生成均匀随机单位方向的方法。\n-   **推导任务2：** 推导一个像素向量在给定单位方向上的标量投影。\n-   **计算任务：** 对一次PPI试验，使用以下数据计算标量投影得分：\n    -   波段数（维度）：$L=4$。\n    -   像素向量：$\\mathbf{x}_i = \\begin{bmatrix}4 \\\\ -1 \\\\ 0 \\\\ 3\\end{bmatrix}$。\n    -   随机向量（待归一化）：$\\mathbf{z} = \\begin{bmatrix}2 \\\\ -1 \\\\ 2 \\\\ 1\\end{bmatrix}$。\n-   **四舍五入：** 最终答案必须四舍五入到$5$位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。它正确地引用了高光谱分析中的线性混合模型和标准算法（PPI、N-FINDR、VCA）。核心数学任务依赖于一种已确立的在球面上生成均匀分布随机向量的方法——对一组独立同分布（i.i.d.）高斯随机变量组成的向量进行归一化。如题目所要求，该方法由多元正态分布的旋转对称性直接证明其合理性。标量投影（内积）的使用对线性代数和PPI的工作原理都是基础。问题是适定的，为最终计算提供了所有必要的数据。术语精确客观。该问题不违反任何无效标准。\n\n**步骤3：结论与行动**\n问题是有效的。我现在开始进行解答。\n\n### 推导与解答\n\n#### 第1部分：生成均匀随机单位方向的方法\n目标是生成一个随机向量 $\\mathbf{u} \\in \\mathbb{R}^{L}$，使其方向在单位超球面 $S^{L-1} = \\{ \\mathbf{v} \\in \\mathbb{R}^{L} : ||\\mathbf{v}|| = 1 \\}$ 上均匀分布。推导过程基于多元标准正态分布的旋转不变性。\n\n设 $\\mathbf{z} = [Z_1, Z_2, \\dots, Z_L]^T$ 是 $\\mathbb{R}^L$ 中的一个随机向量，其中每个分量 $Z_j$ 是从标准正态分布 $Z_j \\sim \\mathcal{N}(0, 1)$ 中抽取的独立同分布（i.i.d.）随机变量。每个 $Z_j$ 的概率密度函数（PDF）为 $p(z_j) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{z_j^2}{2})$。\n\n由于独立性，向量 $\\mathbf{z}$ 的联合概率密度函数是各分量概率密度函数的乘积：\n$$ f(\\mathbf{z}) = \\prod_{j=1}^{L} p(z_j) = \\prod_{j=1}^{L} \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{z_j^2}{2}\\right) $$\n这可以简化为：\n$$ f(\\mathbf{z}) = \\left(\\frac{1}{2\\pi}\\right)^{L/2} \\exp\\left(-\\frac{1}{2} \\sum_{j=1}^{L} z_j^2\\right) $$\n指数中的和是向量 $\\mathbf{z}$ 的欧几里得范数的平方，也即它与自身的内积：$\\sum_{j=1}^{L} z_j^2 = \\mathbf{z}^T\\mathbf{z} = ||\\mathbf{z}||^2$。因此，联合概率密度函数可以写为：\n$$ f(\\mathbf{z}) = (2\\pi)^{-L/2} \\exp\\left(-\\frac{1}{2} ||\\mathbf{z}||^2\\right) $$\n这个函数 $f(\\mathbf{z})$ 仅依赖于 $\\mathbf{z}$ 的大小（范数），而与其方向无关。具有此性质的分布称为球对称或旋转不变。因此，向量 $\\mathbf{z}$ 的方向，由单位向量 $\\mathbf{u} = \\frac{\\mathbf{z}}{||\\mathbf{z}||}$ 表示，在 $\\mathbb{R}^L$ 中所有可能的方向上是均匀分布的。\n\n这就得出了以下数学上有效的方法：\n1.  从标准正态分布 $\\mathcal{N}(0, 1)$ 中生成 $L$ 个独立样本 $\\{z_1, z_2, \\dots, z_L\\}$。\n2.  构建向量 $\\mathbf{z} = [z_1, z_2, \\dots, z_L]^T$。该向量为非零向量的概率为1。\n3.  计算 $\\mathbf{z}$ 的欧几里得范数：$||\\mathbf{z}|| = \\sqrt{\\sum_{j=1}^L z_j^2}$。\n4.  将该向量归一化以获得随机单位方向：$\\mathbf{u} = \\frac{\\mathbf{z}}{||\\mathbf{z}||}$。这个向量 $\\mathbf{u}$ 在单位球面 $S^{L-1}$ 上是均匀分布的。\n\n#### 第2部分：标量投影得分的推导\n在配备了标准内积（点积）的有限维实向量空间 $\\mathbb{R}^L$ 中，一个向量到另一个向量的投影是一个基本概念。设 $\\mathbf{x}$ 是一个像素向量，$\\mathbf{u}$ 是一个单位方向向量，两者都在 $\\mathbb{R}^L$ 中。\n\n$\\mathbf{x}$ 和 $\\mathbf{u}$ 的内积定义为：\n$$ \\langle \\mathbf{x}, \\mathbf{u} \\rangle = \\mathbf{x}^T \\mathbf{u} = \\sum_{j=1}^{L} x_j u_j $$\n从几何上看，这个内积也由以下关系式给出：\n$$ \\langle \\mathbf{x}, \\mathbf{u} \\rangle = ||\\mathbf{x}|| \\cdot ||\\mathbf{u}|| \\cos(\\theta) $$\n其中 $\\theta$ 是向量 $\\mathbf{x}$ 和 $\\mathbf{u}$ 之间的夹角。\n\n$\\mathbf{x}$ 在 $\\mathbf{u}$ 方向上的标量投影是 $\\mathbf{x}$ 在由 $\\mathbf{u}$ 张成的直线上的正交投影的有符号大小。该量由 $||\\mathbf{x}|| \\cos(\\theta)$ 给出。\n\n由于 $\\mathbf{u}$ 根据构造是一个单位向量，其范数为 $||\\mathbf{u}|| = 1$。将此代入内积的几何定义中，得到：\n$$ \\langle \\mathbf{x}, \\mathbf{u} \\rangle = ||\\mathbf{x}|| \\cdot (1) \\cdot \\cos(\\theta) = ||\\mathbf{x}|| \\cos(\\theta) $$\n因此，在PPI中用于衡量像素 $\\mathbf{x}$ 沿方向 $\\mathbf{u}$ 的“极值程度”的标量投影得分，恰好就是 $\\mathbf{x}$ 和 $\\mathbf{u}$ 的内积。\n$$ \\text{得分} = \\langle \\mathbf{x}, \\mathbf{u} \\rangle = \\mathbf{x}^T \\mathbf{u} $$\n\n#### 第3部分：具体计算\n对于一个 $L=4$ 波段图像中的一次特定PPI试验，我们有以下数据：\n-   像素向量：$\\mathbf{x}_i = \\begin{bmatrix}4 \\\\ -1 \\\\ 0 \\\\ 3\\end{bmatrix}$\n-   随机向量实现：$\\mathbf{z} = \\begin{bmatrix}2 \\\\ -1 \\\\ 2 \\\\ 1\\end{bmatrix}$\n\n首先，我们必须应用第1部分中推导的方法，将给定的随机向量 $\\mathbf{z}$ 转换为一个单位方向向量 $\\mathbf{u}$。我们计算 $\\mathbf{z}$ 的欧几里得范数：\n$$ ||\\mathbf{z}|| = \\sqrt{2^2 + (-1)^2 + 2^2 + 1^2} = \\sqrt{4 + 1 + 4 + 1} = \\sqrt{10} $$\n那么单位方向向量 $\\mathbf{u}$ 为：\n$$ \\mathbf{u} = \\frac{\\mathbf{z}}{||\\mathbf{z}||} = \\frac{1}{\\sqrt{10}} \\begin{bmatrix}2 \\\\ -1 \\\\ 2 \\\\ 1\\end{bmatrix} $$\n接下来，我们使用第2部分推导的公式计算标量投影得分。得分是像素向量 $\\mathbf{x}_i$ 和单位方向向量 $\\mathbf{u}$ 的内积：\n$$ \\text{得分} = \\langle \\mathbf{x}_i, \\mathbf{u} \\rangle = \\mathbf{x}_i^T \\mathbf{u} $$\n$$ \\text{得分} = \\begin{bmatrix}4  -1  0  3\\end{bmatrix} \\left( \\frac{1}{\\sqrt{10}} \\begin{bmatrix}2 \\\\ -1 \\\\ 2 \\\\ 1\\end{bmatrix} \\right) $$\n我们可以将标量项 $\\frac{1}{\\sqrt{10}}$ 提取出来：\n$$ \\text{得分} = \\frac{1}{\\sqrt{10}} \\left[ (4)(2) + (-1)(-1) + (0)(2) + (3)(1) \\right] $$\n$$ \\text{得分} = \\frac{1}{\\sqrt{10}} [8 + 1 + 0 + 3] = \\frac{12}{\\sqrt{10}} $$\n为了获得最终的数值，我们计算结果并四舍五入到5位有效数字：\n$$ \\text{得分} = \\frac{12}{\\sqrt{10}} \\approx \\frac{12}{3.16227766} \\approx 3.79473319... $$\n四舍五入到5位有效数字得到3.7947。",
            "answer": "$$ \\boxed{3.7947} $$"
        },
        {
            "introduction": "在实际应用中，高光谱数据不可避免地会受到噪声的干扰，特别是当噪声在不同波段具有不同方差（即“有色”噪声）时，会扭曲数据云的几何形状，从而影响顶点寻找算法的性能。噪声白化是一种至关重要的预处理技术，它通过线性变换将数据重塑到一个新的空间，在该空间中噪声变得各向同性（即协方差变为单位矩阵）。本练习  将指导您为一个假设的数据集构建白化变换，并分析其如何帮助分离信号子空间与噪声子空间，这对于提升如顶点成分分析 (VCA) 等几何算法的鲁棒性和准确性至关重要。",
            "id": "3808939",
            "problem": "一个高光谱场景由线性混合模型建模，其中每个观测到的像素向量 $x \\in \\mathbb{R}^{d}$ 由 $x = M a + n$ 给出，其中 $M \\in \\mathbb{R}^{d \\times p}$ 是端元矩阵，$a \\in \\mathbb{R}^{p}$ 是满足非负性和和为一约束的丰度向量，$n \\in \\mathbb{R}^{d}$ 是均值为零且具有已知协方差 $C_{n} \\in \\mathbb{R}^{d \\times d}$ 的加性噪声。$x$ 的观测样本协方差为 $S_{x} \\approx S_{s} + C_{n}$，其中 $S_{s}$ 是混合信号 $M a$ 的协方差。噪声白化使用一个满足 $W C_{n} W^{\\top} = I$ 的矩阵 $W \\in \\mathbb{R}^{d \\times d}$，白化后的协方差为 $S_{w} = W S_{x} W^{\\top}$。白化空间中的信号子空间由 $S_{w}$ 的超过 1 的特征值确定，因为白化使噪声协方差变为单位矩阵。\n\n考虑一个具有 $d = 3$ 个光谱波段的高光谱传感器。已知的噪声协方差为\n$$\nC_{n} = \\begin{pmatrix}\n4  0  0 \\\\\n0  1  0 \\\\\n0  0  9\n\\end{pmatrix},\n$$\n观测数据的样本协方差为\n$$\nS_{x} = \\begin{pmatrix}\n64  0  0 \\\\\n0  4  0 \\\\\n0  0  9\n\\end{pmatrix}.\n$$\n\n任务：\n1) 基于基础线性代数，构造一个满足 $W C_{n} W^{\\top} = I$ 的噪声白化矩阵 $W$，并计算白化协方差 $S_{w} = W S_{x} W^{\\top}$。\n2) 使用 $S_{w}$ 的特征分解，根据特征值严格大于 $1$ 表示信号的准则，确定白化信号子空间的维度 $r$，并写出该白化信号子空间的一个标准正交基。\n3) 从线性混合和凸几何的角度，解释为什么在有色噪声存在的情况下，白化和子空间投影对顶点成分分析 (Vertex Component Analysis, VCA) 有益，重点关注白化如何影响噪声的几何形状以及与端元对应的极值点的检测。\n4) 令 $P_{r}$ 表示到你所确定的白化信号子空间的正交投影算子。计算标量诊断值\n$$\n\\det\\!\\big(P_{r} \\,(S_{w} - I)\\, P_{r}\\big),\n$$\n它等于限制在信号子空间上的白化纯信号协方差的行列式。给出你的最终答案，形式为一个无单位的精确值。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于高光谱信号处理的原理，信息完备、问题适定，并且表述客观。我们可以开始解答。\n\n该问题要求对给定特定协方差矩阵的高光谱信号模型进行四部分分析。\n\n**1) 噪声白化矩阵和白化协方差**\n\n噪声白化变换矩阵 $W$ 由属性 $W C_{n} W^{\\top} = I$ 定义，其中 $I$ 是单位矩阵。当 $C_{n}$ 是正定矩阵时，一个常见且直接的选择是 $W = C_{n}^{-1/2}$。由于给定的噪声协方差矩阵 $C_{n}$ 是对角矩阵，其逆和平方根很容易计算。\n\n噪声协方差矩阵为：\n$$\nC_{n} = \\begin{pmatrix}\n4  0  0 \\\\\n0  1  0 \\\\\n0  0  9\n\\end{pmatrix}\n$$\n$C_n$ 的平方根是：\n$$\nC_{n}^{1/2} = \\begin{pmatrix}\n\\sqrt{4}  0  0 \\\\\n0  \\sqrt{1}  0 \\\\\n0  0  \\sqrt{9}\n\\end{pmatrix} = \\begin{pmatrix}\n2  0  0 \\\\\n0  1  0 \\\\\n0  0  3\n\\end{pmatrix}\n$$\n$C_{n}^{1/2}$ 的逆矩阵即为白化矩阵 $W$：\n$$\nW = C_{n}^{-1/2} = \\begin{pmatrix}\n1/2  0  0 \\\\\n0  1  0 \\\\\n0  0  1/3\n\\end{pmatrix}\n$$\n我们可以验证这个选择：$W C_{n} W^{\\top} = C_{n}^{-1/2} C_{n} (C_{n}^{-1/2})^{\\top} = C_{n}^{-1/2} C_{n} C_{n}^{-1/2} = C_{n}^{-1/2} C_{n}^{1/2} = I$。\n\n接下来，我们计算白化数据协方差矩阵 $S_{w} = W S_{x} W^{\\top}$。给定的观测数据协方差 $S_{x}$ 为：\n$$\nS_{x} = \\begin{pmatrix}\n64  0  0 \\\\\n0  4  0 \\\\\n0  0  9\n\\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\nS_{w} = \\begin{pmatrix}\n1/2  0  0 \\\\\n0  1  0 \\\\\n0  0  1/3\n\\end{pmatrix}\n\\begin{pmatrix}\n64  0  0 \\\\\n0  4  0 \\\\\n0  0  9\n\\end{pmatrix}\n\\begin{pmatrix}\n1/2  0  0 \\\\\n0  1  0 \\\\\n0  0  1/3\n\\end{pmatrix}\n$$\n$$\nS_{w} = \\begin{pmatrix}\n(1/2)(64)(1/2)  0  0 \\\\\n0  (1)(4)(1)  0 \\\\\n0  0  (1/3)(9)(1/3)\n\\end{pmatrix} = \\begin{pmatrix}\n16  0  0 \\\\\n0  4  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n\n**2) 白化信号子空间的维度和基**\n\n白化信号子空间的维度 $r$ 由 $S_{w}$ 的严格大于 1 的特征值的数量确定。由于 $S_{w}$ 是一个对角矩阵，其特征值是其对角线上的元素，其特征向量是标准基向量。\n$S_{w}$ 的特征值为 $\\lambda_1 = 16$，$\\lambda_2 = 4$ 和 $\\lambda_3 = 1$。\n对应的特征向量是：\n$$\nv_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad v_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad v_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n应用准则 $\\lambda > 1$：\n- $\\lambda_1 = 16 > 1$，表示一个信号分量。\n- $\\lambda_2 = 4 > 1$，表示一个信号分量。\n- $\\lambda_3 = 1$，不严格大于 $1$，表示该维度只包含白化噪声。\n\n因此，白化信号子空间的维度是 $r=2$。该子空间的一个标准正交基由对应于信号特征值的特征向量 $v_1$ 和 $v_2$ 组成。\n基为 $\\{u_1, u_2\\}$，其中：\n$$\nu_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad u_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n这个基已经是标准正交的。\n\n**3) 白化和投影对 VCA 的益处**\n\n顶点成分分析 (VCA) 是一种用于端元提取的几何算法。它基于一个假设进行操作，即观测到的像素向量是少数几个纯端元向量的凸组合，在数据空间中形成一个单纯形。VCA 通过寻找该单纯形的顶点来识别端元。VCA 的有效性高度依赖于这个单纯形的几何纯度。\n\n- **有色噪声的影响**：在原始数据空间中，噪声是“有色的”，其协方差为 $C_n = \\mathrm{diag}(4, 1, 9)$。这意味着噪声不是各向同性的；它在每个光谱波段的方差都不同（方差分别为 $4$、$1$ 和 $9$）。在几何上，这对应于围绕任何数据点的噪声云是一个与坐标轴对齐的椭球体，其半轴长度分别为 $\\sqrt{4}=2$、$\\sqrt{1}=1$ 和 $\\sqrt{9}=3$。这种各向异性的噪声会扭曲观测到的数据单纯形，沿不同轴向对其进行拉伸和压缩。因此，噪声数据云的顶点可能不再对应于真实的端元，这会损害 VCA 通过投影数据和识别极值点来寻找它们的能力。\n\n- **白化的影响**：白化变换 $y=Wx$ 将数据重映射到一个新空间，在该空间中噪声协方差变为单位矩阵 ($W C_n W^\\top = I$)。这种白化噪声是各向同性的（在所有方向上单位方差）且不相关的。在几何上，噪声云变成一个球体。通过消除噪声的方向性偏差，白化恢复了信号单纯形的底层几何结构。在这个白化空间中，数据云的顶点更有可能是真实的端元，因为所有数据点都以一种均匀的、球形的方式受到噪声的扰动。这使得像 VCA 这样的几何算法显著地更加鲁棒和准确。\n\n- **子空间投影的影响**：白化之后，$S_w$ 的特征分解将由信号主导的维度（特征值 > 1）与由噪声主导的维度（特征值 ≈ 1）分离开来。将白化数据投影到信号子空间（在本例中为二维子空间）上，有效地移除了仅由噪声构成的维度。这有两个好处：（i）通过丢弃纯噪声维度，它进一步提高了信噪比，从而得到更干净的数据集；（ii）它降低了问题的维度，使得 VCA 随后搜索顶点的计算效率更高。\n\n总之，白化规范了噪声的几何形状，而子空间投影隔离了富含信号的维度，为 VCA 精确提取端元创造了更有利的问题结构。\n\n**4) 标量诊断值的计算**\n\n任务是计算 $\\det(P_{r} \\,(S_{w} - I)\\, P_{r})$，它表示限制在信号子空间上的白化纯信号协方差的行列式。\n\n令 $A = P_{r} \\,(S_{w} - I)\\, P_{r}$。算子 $P_{r}$ 是到 $r=2$ 维信号子空间的正交投影算子，该子空间由标准正交基 $\\{u_1, u_2\\}$ 张成。投影算子可以写为 $P_r = u_1 u_1^\\top + u_2 u_2^\\top$。\n以矩阵形式表示，其中 $U = [u_1 | u_2]$，则 $P_r = U U^\\top$。\n$$\nU = \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\end{pmatrix} \\implies P_r = \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\end{pmatrix} = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n算子 $A$ 是 $\\mathbb{R}^3$ 中的一个秩为2的算子。短语“限制在信号子空间上”意味着我们应该求出该算子在该子空间内作用的行列式。该受限算子的行列式是其特征值的乘积，而这些特征值就是 A 的非零特征值。\n\n让我们求 $A$ 的特征值。向量 $u_1$, $u_2$ 和 $u_3=v_3$ 构成了 $P_r$ 和 $S_w - I$ 的一个共同的特征基。\n对于 $u_1$，它是 $S_w$ 的特征向量，特征值为 $\\lambda_1=16$：\n$A u_1 = P_r (S_w - I) P_r u_1$。由于 $u_1$ 在信号子空间中，所以 $P_r u_1 = u_1$。\n$A u_1 = P_r (S_w u_1 - u_1) = P_r (\\lambda_1 u_1 - u_1) = (\\lambda_1 - 1) P_r u_1 = (\\lambda_1 - 1) u_1 = (16-1) u_1 = 15 u_1$。\n对应于 $u_1$ 的 $A$ 的特征值是 $15$。\n\n对于 $u_2$，它是 $S_w$ 的特征向量，特征值为 $\\lambda_2=4$：\n$A u_2 = P_r (S_w - I) P_r u_2 = (\\lambda_2 - 1) u_2 = (4-1) u_2 = 3 u_2$。\n对应于 $u_2$ 的 $A$ 的特征值是 $3$。\n\n对于 $u_3$，它张成了 $P_r$ 的零空间：\n$A u_3 = P_r (S_w - I) P_r u_3 = P_r (S_w - I) (0) = 0$。\n对应于 $u_3$ 的 $A$ 的特征值是 $0$。\n\n矩阵 $A$ 的特征值为 $15$、$3$ 和 $0$。作为 $\\mathbb{R}^{3 \\times 3}$ 中的矩阵，$A$ 的行列式是 $15 \\times 3 \\times 0 = 0$。然而，限制在信号子空间上的算子的行列式是其在该子空间上的特征值的乘积。对应于信号子空间的特征值是 $15$ 和 $3$。\n\n因此，所需的标量诊断值是这些特征值的乘积：\n$$\n\\det\\nolimits_{\\text{restricted}} = 15 \\times 3 = 45\n$$\n另外，也可以计算该算子限制在子空间上的矩阵表示 $U^\\top (S_w - I) U$，然后求其行列式。\n$$\nU^\\top (S_w - I) U = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\left( \\begin{pmatrix} 16  0  0 \\\\ 0  4  0 \\\\ 0  0  1 \\end{pmatrix} - \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\right) \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 15  0  0 \\\\ 0  3  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 15  0 \\\\ 0  3 \\end{pmatrix}\n$$\n这个 $2 \\times 2$ 矩阵的行列式是 $\\det \\begin{pmatrix} 15  0 \\\\ 0  3 \\end{pmatrix} = (15)(3) - (0)(0) = 45$。",
            "answer": "$$\n\\boxed{45}\n$$"
        },
        {
            "introduction": "与 PPI 的随机搜索方法不同，N-FINDR 算法采用了一个更为明确的几何准则来寻找端元：它试图在数据集中找到一组像元，使其构成的单形体体积最大化。这个体积是衡量端元之间光谱差异性的一个良好指标。然而，直接使用行列式计算高维单形体的体积在数值上可能非常不稳定，尤其是在端元光谱相似（即向量近似共线）的情况下。本编程练习  要求您实现并对比两种体积计算方法——一种是基于格拉姆行列式的朴素方法，另一种是基于 QR 分解的数值稳定方法，从而让您深刻体会到在实现几何算法时必须考虑的实际计算挑战。",
            "id": "3808949",
            "problem": "考虑在线性混合模型下的高光谱解混，其中每个像素光谱被建模为一组有限端元光谱的凸组合。设光谱波段数为 $L$，端元数为 $p$，端元光谱表示为 $\\mathbb{R}^L$ 中的列向量。在 N-FINDR（N-FINDR 是一种端元提取算法，它选择的端元集能够使其构成的单纯形体积最大化）框架中，由 $p$ 个端元光谱张成的单纯形体积是指导选择的核心量。基于行列式的体积计算通常通过构造端元光谱之差的矩阵并将体积与一个行列式关联起来进行，但对病态矩阵直接计算行列式可能在数值上是不稳定的。本任务要求使用正交三角分解（QR分解）实现一种数值稳定的体积计算方法，以避免这种不稳定性。\n\n从适用于高光谱解混的线性代数基本原理出发，完成以下任务：\n\n1.  给定 $p$ 个端元光谱 $e_1, e_2, \\dots, e_p \\in \\mathbb{R}^L$，定义一个 $L \\times (p-1)$ 矩阵 $B$，其列为差值 $e_i - e_1$（$i = 2, \\dots, p$）。仅使用基本定义，将单纯形体积计算为矩阵 $B$ 和 $(p-1)$ 的阶乘的函数。\n\n2.  实现两种计算单纯形体积的方法：\n    *   一种朴素的基于行列式的方法，该方法直接计算格拉姆矩阵 $B^\\top B$ 的行列式，然后用此行列式计算体积。\n    *   一种数值稳定的方法，该方法使用QR分解获得 $B$ 的正交-上三角分解，然后从上三角因子计算体积。\n\n3.  您的实现必须处理高矩阵情况（$L > p-1$）和方阵情况（$L = p-1$），并必须确保当 $B$ 的列向量近似线性相关时行为稳健。对于朴素方法中因浮点误差产生的、绝对值小于 $10^{-16}$ 的负行列式，在取平方根之前将其截断为 $0$。\n\n4.  使用以下端元集测试套件。对于每种情况，都指定了 $L$ 和 $p$，以及明确的端元光谱。所有值都是无量纲的，应被视为实数。\n\n    *   情况1（一般情况，中等条件数）：$L = 4$, $p = 3$，其中\n        $e_1 = [\\,0.90,\\,0.20,\\,0.10,\\,0.00\\,]$,\n        $e_2 = [\\,0.80,\\,0.30,\\,0.15,\\,0.05\\,]$,\n        $e_3 = [\\,0.85,\\,0.25,\\,0.05,\\,0.02\\,]$。\n    *   情况2（近共线边界）：$L = 3$, $p = 3$，其中\n        $e_1 = [\\,1.000000,\\,0.000000,\\,0.000000\\,]$,\n        $e_2 = [\\,0.999999,\\,0.000001,\\,0.000000\\,]$,\n        $e_3 = [\\,0.999998,\\,0.000002,\\,0.000000\\,]$。\n    *   情况3（高矩阵，跨波段的极大动态范围）：$L = 6$, $p = 4$，其中\n        $e_1 = [\\,0.90,\\,0.01,\\,0.000001,\\,0.50,\\,0.20,\\,0.000003\\,]$,\n        $e_2 = [\\,0.91,\\,0.015,\\,0.0000015,\\,0.49,\\,0.19,\\,0.0000032\\,]$,\n        $e_3 = [\\,0.89,\\,0.012,\\,0.0000009,\\,0.51,\\,0.21,\\,0.0000028\\,]$,\n        $e_4 = [\\,0.92,\\,0.02,\\,0.0000012,\\,0.48,\\,0.18,\\,0.0000035\\,]$。\n    *   情况4（方阵，已知参考体积）：$L = 3$, $p = 4$，其中\n        $e_1 = [\\,0.00,\\,0.00,\\,0.00\\,]$,\n        $e_2 = [\\,1.00,\\,0.00,\\,0.00\\,]$,\n        $e_3 = [\\,0.00,\\,1.00,\\,0.00\\,]$,\n        $e_4 = [\\,0.00,\\,0.00,\\,1.00\\,]$。\n\n5.  对于每种情况，计算两个浮点数：基于QR的体积和朴素的基于行列式的体积，每个都四舍五入到 $12$ 位小数。最终输出是无量纲数。\n\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，不含空格，按每种情况排序为 $[\\,V^{\\mathrm{QR}}_1, V^{\\mathrm{naive}}_1, V^{\\mathrm{QR}}_2, V^{\\mathrm{naive}}_2, V^{\\mathrm{QR}}_3, V^{\\mathrm{naive}}_3, V^{\\mathrm{QR}}_4, V^{\\mathrm{naive}}_4\\,]$，其中每个 $V$ 是一个四舍五入到 $12$ 位小数的浮点数。例如，格式应如下所示：$[\\,0.123456789012,0.123456789012,0.000000000000,0.000000000000, \\dots\\,]$。",
            "solution": "在尝试任何解决方案之前，问题陈述都经过了严格的验证过程。\n\n### 步骤1：提取已知条件\n从问题陈述中逐字提取的已知条件如下：\n- **模型**：线性混合模型下的高光谱解混。每个像素是端元光谱的凸组合。\n- **变量**：$L$ 是光谱波段数。$p$ 是端元数。端元光谱是列向量 $e_1, e_2, \\dots, e_p \\in \\mathbb{R}^L$。\n- **算法背景**：N-FINDR（N-FINDR 是一种端元提取算法，它选择的端元集能够使其构成的单纯形体积最大化）。\n- **矩阵定义**：$B$ 是一个 $L \\times (p-1)$ 矩阵，其列为 $e_i - e_1$（$i = 2, \\dots, p$）。\n- **任务1**：仅使用基本定义，将单纯形体积计算为矩阵 $B$ 和 $(p-1)$ 的阶乘的函数。\n- **任务2**：实现两种计算体积的方法：\n    1.  使用格拉姆矩阵 $B^\\top B$ 的行列式的朴素方法。\n    2.  使用 $B$ 的 QR 分解的数值稳定方法。\n- **任务3（约束）**：\n    - 实现必须处理高矩阵（$L > p-1$）和方阵（$L = p-1$）两种情况。\n    - 对于朴素方法，如果行列式为负且其绝对值小于 $10^{-16}$，则必须将其截断为 $0$。\n- **任务4（测试套件）**：\n    - **情况1**：$L = 4$, $p = 3$, $e_1 = [\\,0.90,\\,0.20,\\,0.10,\\,0.00\\,]$, $e_2 = [\\,0.80,\\,0.30,\\,0.15,\\,0.05\\,]$, $e_3 = [\\,0.85,\\,0.25,\\,0.05,\\,0.02\\,]$。\n    - **情况2**：$L = 3$, $p = 3$, $e_1 = [\\,1.000000,\\,0.000000,\\,0.000000\\,]$, $e_2 = [\\,0.999999,\\,0.000001,\\,0.000000\\,]$, $e_3 = [\\,0.999998,\\,0.000002,\\,0.000000\\,]$。\n    - **情况3**：$L = 6$, $p = 4$, $e_1 = [\\,0.90,\\,0.01,\\,0.000001,\\,0.50,\\,0.20,\\,0.000003\\,]$, $e_2 = [\\,0.91,\\,0.015,\\,0.0000015,\\,0.49,\\,0.19,\\,0.0000032\\,]$, $e_3 = [\\,0.89,\\,0.012,\\,0.0000009,\\,0.51,\\,0.21,\\,0.0000028\\,]$, $e_4 = [\\,0.92,\\,0.02,\\,0.0000012,\\,0.48,\\,0.18,\\,0.0000035\\,]$。\n    - **情况4**：$L = 3$, $p = 4$, $e_1 = [\\,0.00,\\,0.00,\\,0.00\\,]$, $e_2 = [\\,1.00,\\,0.00,\\,0.00\\,]$, $e_3 = [\\,0.00,\\,1.00,\\,0.00\\,]$, $e_4 = [\\,0.00,\\,0.00,\\,1.00\\,]$。\n- **任务5（输出格式）**：对于每种情况，计算两个浮点数（QR体积，朴素体积），四舍五入到 $12$ 位小数。最终输出为单行：$[\\,V^{\\mathrm{QR}}_1, V^{\\mathrm{naive}}_1, V^{\\mathrm{QR}}_2, V^{\\mathrm{naive}}_2, \\dots\\,]$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学基础**：问题根植于成熟的高光谱遥感领域，并利用了标准的线性代数原理。线性混合模型、N-FINDR算法、单纯形体积计算、格拉姆行列式和QR分解都是标准且有效的科学概念。\n- **适定性**：问题是适定的。它提供了所有必要的输入（端元光谱、维度），明确定义了要计算的量，指定了要实现的算法，并给出了明确的输出格式。对于给定的顶点集，单纯形体积的存在性和唯一性是有保证的。\n- **客观性**：问题以精确、客观和数学化的语言陈述，没有任何主观或有偏见的措辞。\n- **完整性和一致性**：问题是自洽的。提供了测试用例的所有数据和参数。维度 $L$ 和 $p$ 与一般情况下非退化单纯形的 $L \\ge p-1$ 要求一致，或者恰当地定义了一个方阵系统。处理小负行列式的特殊情况解决了实际的数值问题，使问题规范更加稳健。情况4提供了一个体积已知的著名几何对象（标准单纯形），可用于验证。\n- **无其他缺陷**：问题没有表现出任何其他列举的缺陷，如非形式化、不切实际、病态、微不足道或无法验证。朴素数值方法与稳定数值方法之间的比较是计算科学中一个经典且重要的话题。\n\n### 步骤3：结论与行动\n问题是**有效的**。将提供解决方案。\n\n### 解法推导\n\n#### 1. 单纯形体积公式\n$\\mathbb{R}^L$ 中的一个单纯形是 $p$ 个仿射无关点（即其顶点）的凸包。在这个问题中，顶点是端元光谱 $e_1, e_2, \\dots, e_p \\in \\mathbb{R}^L$。这样的单纯形是一个 $(p-1)$ 维对象。\n\n为了计算其体积，我们首先考虑由从一个共同顶点出发的边向量定义的 $(p-1)$ 维平行多面体。我们选择 $e_1$ 作为参考顶点。那么边向量为 $v_i = e_{i+1} - e_1$（$i = 1, \\dots, p-1$）。这些向量是问题中定义的矩阵 $B$ 的列，其中 $B$ 是一个 $L \\times (p-1)$ 矩阵：\n$$\nB = [\\, e_2 - e_1 \\mid e_3 - e_1 \\mid \\dots \\mid e_p - e_1 \\,]\n$$\n由 $B$ 的列向量张成的平行多面体的体积平方由格拉姆矩阵 $B^\\top B$ 的行列式给出。这是线性代数中的一个基本结果，称为格拉姆行列式。\n$$\nV_{\\text{parallelotope}}^2 = \\det(B^\\top B)\n$$\n一个 $k$-单纯形的体积与由相同边向量张成的 $k$ 维平行多面体的体积之比为 $1/k!$。在我们的例子中，$k = p-1$。因此，单纯形的体积 $V_{\\text{simplex}}$ 是：\n$$\nV_{\\text{simplex}} = \\frac{1}{(p-1)!} V_{\\text{parallelotope}} = \\frac{1}{(p-1)!} \\sqrt{\\det(B^\\top B)}\n$$\n这个公式提供了单纯形体积、矩阵 $B$ 和 $(p-1)$ 的阶乘之间的所需关系。\n\n#### 2. 计算方法\n\n##### 朴素的基于行列式的方法\n此方法直接实现上面推导的公式。\n1.  根据给定的端元构造 $L \\times (p-1)$ 矩阵 $B$。\n2.  计算 $(p-1) \\times (p-1)$ 的格拉姆矩阵 $G = B^\\top B$。\n3.  计算行列式 $d = \\det(G)$。\n4.  理论上，$G$ 是一个半正定矩阵，所以其行列式必须是非负的。然而，当矩阵是奇异或接近奇异时，浮点不精确性可能导致小的负值。根据问题规范，如果 $d  0$ 且 $|d|  10^{-16}$，我们设置 $d = 0$。\n5.  计算体积为 $V_{\\text{naive}} = \\frac{\\sqrt{d}}{(p-1)!}$。\n\n该方法的主要缺点是其数值不稳定性。$B^\\top B$ 的条件数是 $B$ 的条件数的平方，即 $\\kappa(B^\\top B) = (\\kappa(B))^2$。如果 $B$ 是病态的（即其列近似线性相关），形成 $B^\\top B$ 会导致严重的精度损失，使得计算出的行列式非常不准确。\n\n##### 数值稳定的基于QR的方法\n此方法通过使用正交三角分解来避免显式构造格拉姆矩阵 $B^\\top B$。\n1.  构造 $L \\times (p-1)$ 矩阵 $B$。\n2.  对 $B$ 进行 QR 分解，使得 $B = QR$。这里，$Q$ 是一个 $L \\times (p-1)$ 的矩阵，其列是标准正交的（$Q^\\top Q = I_{p-1}$，其中 $I_{p-1}$ 是 $(p-1) \\times (p-1)$ 的单位矩阵），$R$ 是一个 $(p-1) \\times (p-1)$ 的上三角矩阵。这种分解可以使用如 Householder 反射或 Givens 旋转等方法稳定地计算。\n3.  将 $B = QR$ 代入格拉姆行列式表达式中：\n    $$\n    \\det(B^\\top B) = \\det((QR)^\\top(QR)) = \\det(R^\\top Q^\\top Q R)\n    $$\n4.  利用 $Q^\\top Q = I_{p-1}$ 的性质，这可以简化为：\n    $$\n    \\det(B^\\top B) = \\det(R^\\top I_{p-1} R) = \\det(R^\\top R) = \\det(R^\\top) \\det(R) = (\\det(R))^2\n    $$\n5.  现在，将此代回体积公式：\n    $$\n    V_{\\text{simplex}} = \\frac{1}{(p-1)!} \\sqrt{(\\det(R))^2} = \\frac{1}{(p-1)!} |\\det(R)|\n    $$\n6.  因为 $R$ 是一个上三角矩阵，其行列式是其对角元素的乘积：$\\det(R) = \\prod_{i=1}^{p-1} R_{ii}$。\n7.  最终，数值稳定的体积公式是：\n    $$\n    V_{\\text{QR}} = \\frac{1}{(p-1)!} \\left| \\prod_{i=1}^{p-1} R_{ii} \\right|\n    $$\n这种方法在数值上更优越，因为 QR 分解算法是后向稳定的，并且计算避免了对条件数进行平方。对于病态的 $B$ 矩阵，$R$ 的对角元素乘积通常比直接计算 $\\det(B^\\top B)$ 要准确得多。\n\n实现将把这两种方法应用于四个提供的测试用例，这些用例旨在探测算法在各种条件下的性能和稳定性。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import factorial\n\ndef solve():\n    \"\"\"\n    Computes simplex volumes using two different methods for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"L\": 4,\n            \"p\": 3,\n            \"endmembers\": np.array([\n                [0.90, 0.20, 0.10, 0.00],\n                [0.80, 0.30, 0.15, 0.05],\n                [0.85, 0.25, 0.05, 0.02],\n            ]),\n        },\n        {\n            \"case_id\": 2,\n            \"L\": 3,\n            \"p\": 3,\n            \"endmembers\": np.array([\n                [1.000000, 0.000000, 0.000000],\n                [0.999999, 0.000001, 0.000000],\n                [0.999998, 0.000002, 0.000000],\n            ]),\n        },\n        {\n            \"case_id\": 3,\n            \"L\": 6,\n            \"p\": 4,\n            \"endmembers\": np.array([\n                [0.90, 0.01, 0.000001, 0.50, 0.20, 0.000003],\n                [0.91, 0.015, 0.0000015, 0.49, 0.19, 0.0000032],\n                [0.89, 0.012, 0.0000009, 0.51, 0.21, 0.0000028],\n                [0.92, 0.02, 0.0000012, 0.48, 0.18, 0.0000035],\n            ]),\n        },\n        {\n            \"case_id\": 4,\n            \"L\": 3,\n            \"p\": 4,\n            \"endmembers\": np.array([\n                [0.00, 0.00, 0.00],\n                [1.00, 0.00, 0.00],\n                [0.00, 1.00, 0.00],\n                [0.00, 0.00, 1.00],\n            ]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        p = case[\"p\"]\n        endmembers = case[\"endmembers\"]\n\n        # Step 1: Form the matrix B of difference vectors\n        # Endmembers are rows in the input array, so we transpose them to be column vectors\n        e = endmembers.T  # Shape: (L, p)\n        e1 = e[:, 0].reshape(-1, 1)  # Reference endmember\n        \n        if p > 1:\n            B = e[:, 1:] - e1\n        else:\n            # If p=1, the simplex is a point or empty, volume is 0\n            # B would be empty, handle this gracefully\n            vol_qr = 0.0\n            vol_naive = 0.0\n            results.extend([vol_qr, vol_naive])\n            continue\n        \n        # Denominator for the volume formula\n        fact_p_minus_1 = factorial(p - 1)\n\n        # Approach 1: Naive determinant-based method\n        gram_matrix = B.T @ B\n        det_gram = np.linalg.det(gram_matrix)\n        \n        # Clip small negative determinants due to floating point error\n        if det_gram  0 and abs(det_gram)  1e-16:\n            det_gram = 0.0\n\n        if det_gram  0:\n            # Should not happen for a Gram matrix in theory, but handle it.\n            # Could indicate severe numerical issues. Volume is ill-defined. Report 0 or NaN.\n            # For this problem, we can assume non-negativity after clipping.\n            vol_naive = 0.0\n        else:\n            vol_naive = np.sqrt(det_gram) / fact_p_minus_1\n\n        # Approach 2: Numerically stable QR-based method\n        # numpy.linalg.qr returns Q and R. R is (min(L, p-1), p-1).\n        # We need the \"reduced\" QR decomposition, which is the default.\n        # Q will be L x (p-1), R will be (p-1) x (p-1)\n        _Q, R = np.linalg.qr(B)\n        \n        # Determinant of R is the product of its diagonal elements\n        # The absolute value handles potential negative diagonal elements\n        # that can arise from QR implementation details.\n        abs_det_R = np.abs(np.prod(np.diag(R)))\n        \n        vol_qr = abs_det_R / fact_p_minus_1\n\n        results.append(\"{:.12f}\".format(vol_qr))\n        results.append(\"{:.12f}\".format(vol_naive))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```",
            "answer": "[0.005595756972,0.005595756972,0.000000000000,0.000000000000,0.000000001099,0.000000001099,0.166666666667,0.166666666667]"
        }
    ]
}