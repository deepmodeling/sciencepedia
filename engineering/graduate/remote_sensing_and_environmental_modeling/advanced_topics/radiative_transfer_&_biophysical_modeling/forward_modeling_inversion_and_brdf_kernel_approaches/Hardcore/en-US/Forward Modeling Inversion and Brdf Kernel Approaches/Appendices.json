{
    "hands_on_practices": [
        {
            "introduction": "A fundamental concept in remote sensing is that most natural surfaces are not perfect Lambertian scatterers; their apparent brightness depends on the viewing and illumination geometry. This exercise provides a first-principles look at this anisotropy by tasking you with analytically deriving the bias that occurs when using a single nadir reflectance measurement as a proxy for the true hemispherical albedo. By working through the integration of a simple kernel-driven BRDF model, you will gain a concrete understanding of why multi-angle observations are essential for accurately characterizing surface energy balance. ",
            "id": "3813265",
            "problem": "A non-Lambertian surface exhibits angular dependence in its bidirectional reflectance distribution function (BRDF), meaning that its apparent reflectance varies with both illumination and viewing geometry. Using nadir reflectance as a proxy for albedo can therefore introduce bias. Starting from the definition of the Bidirectional Reflectance Distribution Function (BRDF), denoted by $f_{r}(\\theta_{s}, \\theta_{v}, \\phi)$, where $\\theta_{s}$ is the solar zenith angle, $\\theta_{v}$ is the viewing zenith angle, and $\\phi$ is the relative azimuth angle, the directional-hemispherical reflectance (also called black-sky albedo) for a fixed $\\theta_{s}$ is defined by\n$$\nA(\\theta_{s}) = \\int_{\\Omega} f_{r}(\\theta_{s}, \\theta_{v}, \\phi)\\, \\cos\\theta_{v}\\, d\\omega,\n$$\nwhere $d\\omega = \\sin\\theta_{v}\\, d\\theta_{v}\\, d\\phi$ is the differential solid angle and the integration is over the viewing hemisphere $\\Omega$. The Bidirectional Reflectance Factor (BRF) is defined as $\\rho(\\theta_{s}, \\theta_{v}, \\phi) = \\pi\\, f_{r}(\\theta_{s}, \\theta_{v}, \\phi)$ under collimated illumination, and is dimensionless.\n\nConsider the following symmetric kernel-driven BRDF model that satisfies reciprocity:\n$$\nf_{r}(\\theta_{s}, \\theta_{v}, \\phi) = b_{0} + b_{1}\\big(\\cos\\theta_{s} + \\cos\\theta_{v}\\big) + b_{2}\\,\\cos\\theta_{s}\\,\\cos\\theta_{v},\n$$\nwith kernel coefficients $b_{0} = 0.02\\,\\text{sr}^{-1}$, $b_{1} = 0.03\\,\\text{sr}^{-1}$, and $b_{2} = 0.015\\,\\text{sr}^{-1}$.\n\n1. Using the above definitions and model, derive the bias incurred by using the nadir BRF as a proxy for the directional-hemispherical reflectance at solar zenith angle $\\theta_{s}$, defined as\n$$\nB(\\theta_{s}) = \\rho(\\theta_{s}, 0, \\phi) - A(\\theta_{s}).\n$$\n2. Evaluate $B(\\theta_{s})$ numerically for $\\theta_{s} = 50^\\circ$. Angles must be treated in radians when evaluating trigonometric functions. Express your final answer as a decimal (dimensionless), and round your answer to four significant figures.",
            "solution": "The problem requires the derivation and evaluation of the bias, $B(\\theta_{s})$, incurred by using the nadir Bidirectional Reflectance Factor (BRF), $\\rho(\\theta_{s}, 0, \\phi)$, as a proxy for the directional-hemispherical reflectance, $A(\\theta_{s})$. The bias is defined as $B(\\theta_{s}) = \\rho(\\theta_{s}, 0, \\phi) - A(\\theta_{s})$.\n\nFirst, we will find the expression for the nadir BRF, $\\rho(\\theta_{s}, 0, \\phi)$. The nadir viewing condition corresponds to a viewing zenith angle $\\theta_{v} = 0$. The given BRDF model is:\n$$\nf_{r}(\\theta_{s}, \\theta_{v}, \\phi) = b_{0} + b_{1}\\big(\\cos\\theta_{s} + \\cos\\theta_{v}\\big) + b_{2}\\,\\cos\\theta_{s}\\,\\cos\\theta_{v}\n$$\nSubstituting $\\theta_{v} = 0$ into this model, and using $\\cos(0) = 1$, we get the BRDF for a nadir view:\n$$\nf_{r}(\\theta_{s}, 0, \\phi) = b_{0} + b_{1}\\big(\\cos\\theta_{s} + 1\\big) + b_{2}\\,\\cos\\theta_{s}\\,(1)\n$$\n$$\nf_{r}(\\theta_{s}, 0, \\phi) = (b_{0} + b_{1}) + (b_{1} + b_{2})\\,\\cos\\theta_{s}\n$$\nThe BRF is defined as $\\rho(\\theta_{s}, \\theta_{v}, \\phi) = \\pi\\, f_{r}(\\theta_{s}, \\theta_{v}, \\phi)$. Therefore, the nadir BRF is:\n$$\n\\rho(\\theta_{s}, 0, \\phi) = \\pi \\left[ (b_{0} + b_{1}) + (b_{1} + b_{2})\\,\\cos\\theta_{s} \\right]\n$$\n\nNext, we derive the expression for the directional-hemispherical reflectance, $A(\\theta_{s})$, also known as the black-sky albedo. The definition is:\n$$\nA(\\theta_{s}) = \\int_{\\Omega} f_{r}(\\theta_{s}, \\theta_{v}, \\phi)\\, \\cos\\theta_{v}\\, d\\omega\n$$\nwhere the differential solid angle is $d\\omega = \\sin\\theta_{v}\\, d\\theta_{v}\\, d\\phi$. The integration is over the viewing hemisphere $\\Omega$, which corresponds to $\\theta_v$ from $0$ to $\\frac{\\pi}{2}$ and $\\phi$ from $0$ to $2\\pi$.\n$$\nA(\\theta_{s}) = \\int_{0}^{2\\pi} \\int_{0}^{\\pi/2} f_{r}(\\theta_{s}, \\theta_{v}, \\phi)\\, \\cos\\theta_{v}\\, \\sin\\theta_{v}\\, d\\theta_{v}\\, d\\phi\n$$\nWe substitute the BRDF model into the integral. To simplify integration, we group the BRDF terms by their dependence on $\\theta_{v}$:\n$$\nf_{r}(\\theta_{s}, \\theta_{v}, \\phi) = (b_{0} + b_{1}\\cos\\theta_{s}) + (b_{1} + b_{2}\\cos\\theta_{s})\\cos\\theta_{v}\n$$\nThe BRDF model is independent of the relative azimuth angle $\\phi$, so the integration over $\\phi$ yields a factor of $2\\pi$:\n$$\nA(\\theta_{s}) = 2\\pi \\int_{0}^{\\pi/2} \\left[ (b_{0} + b_{1}\\cos\\theta_{s}) + (b_{1} + b_{2}\\cos\\theta_{s})\\cos\\theta_{v} \\right] \\cos\\theta_{v}\\, \\sin\\theta_{v}\\, d\\theta_{v}\n$$\nWe can split this into two integrals:\n$$\nA(\\theta_{s}) = 2\\pi(b_{0} + b_{1}\\cos\\theta_{s}) \\int_{0}^{\\pi/2} \\cos\\theta_{v}\\,\\sin\\theta_{v}\\,d\\theta_{v} + 2\\pi(b_{1} + b_{2}\\cos\\theta_{s}) \\int_{0}^{\\pi/2} \\cos^2\\theta_{v}\\,\\sin\\theta_{v}\\,d\\theta_{v}\n$$\nLet's evaluate the integrals over $\\theta_v$:\nThe first integral is:\n$$\n\\int_{0}^{\\pi/2} \\cos\\theta_{v}\\,\\sin\\theta_{v}\\,d\\theta_{v} = \\int_{0}^{\\pi/2} \\frac{1}{2}\\sin(2\\theta_{v})\\,d\\theta_{v} = \\frac{1}{2} \\left[ -\\frac{\\cos(2\\theta_{v})}{2} \\right]_{0}^{\\pi/2} = -\\frac{1}{4}(\\cos(\\pi) - \\cos(0)) = -\\frac{1}{4}(-1 - 1) = \\frac{1}{2}\n$$\nThe second integral is, using the substitution $u = \\cos\\theta_{v}$, $du = -\\sin\\theta_{v}\\,d\\theta_{v}$:\n$$\n\\int_{0}^{\\pi/2} \\cos^2\\theta_{v}\\,\\sin\\theta_{v}\\,d\\theta_{v} = \\int_{1}^{0} u^2 (-du) = \\int_{0}^{1} u^2\\,du = \\left[ \\frac{u^3}{3} \\right]_{0}^{1} = \\frac{1}{3}\n$$\nSubstituting these results back into the expression for $A(\\theta_{s})$:\n$$\nA(\\theta_{s}) = 2\\pi(b_{0} + b_{1}\\cos\\theta_{s}) \\left(\\frac{1}{2}\\right) + 2\\pi(b_{1} + b_{2}\\cos\\theta_{s}) \\left(\\frac{1}{3}\\right)\n$$\n$$\nA(\\theta_{s}) = \\pi(b_{0} + b_{1}\\cos\\theta_{s}) + \\frac{2\\pi}{3}(b_{1} + b_{2}\\cos\\theta_{s})\n$$\n$$\nA(\\theta_{s}) = \\pi\\left(b_{0} + \\frac{2}{3}b_{1}\\right) + \\pi\\left(b_{1} + \\frac{2}{3}b_{2}\\right)\\cos\\theta_{s}\n$$\nNow we can compute the bias $B(\\theta_{s})$:\n$$\nB(\\theta_{s}) = \\rho(\\theta_{s}, 0, \\phi) - A(\\theta_{s})\n$$\n$$\nB(\\theta_{s}) = \\pi\\left[ (b_{0} + b_{1}) + (b_{1} + b_{2})\\cos\\theta_{s} \\right] - \\left[ \\pi\\left(b_{0} + \\frac{2}{3}b_{1}\\right) + \\pi\\left(b_{1} + \\frac{2}{3}b_{2}\\right)\\cos\\theta_{s} \\right]\n$$\nGrouping the constant terms and the $\\cos\\theta_{s}$ terms:\n$$\nB(\\theta_{s}) = \\pi\\left( (b_{0} + b_{1}) - (b_{0} + \\frac{2}{3}b_{1}) \\right) + \\pi\\left( (b_{1} + b_{2}) - (b_{1} + \\frac{2}{3}b_{2}) \\right)\\cos\\theta_{s}\n$$\n$$\nB(\\theta_{s}) = \\pi\\left( \\frac{1}{3}b_{1} \\right) + \\pi\\left( \\frac{1}{3}b_{2} \\right)\\cos\\theta_{s}\n$$\nThe final analytical expression for the bias is:\n$$\nB(\\theta_{s}) = \\frac{\\pi}{3}(b_{1} + b_{2}\\cos\\theta_{s})\n$$\nThis completes the first part of the problem.\n\nFor the second part, we must evaluate $B(\\theta_{s})$ for $\\theta_{s} = 50^\\circ$. We use the given coefficients $b_{1} = 0.03\\,\\text{sr}^{-1}$ and $b_{2} = 0.015\\,\\text{sr}^{-1}$. The angle must be treated in radians for trigonometric function evaluation, although $\\cos(50^\\circ)$ has the same value as $\\cos(\\frac{50\\pi}{180})$.\n$$\n\\cos(50^\\circ) \\approx 0.6427876\n$$\nSubstituting the numerical values into the bias expression:\n$$\nB(50^\\circ) = \\frac{\\pi}{3}(0.03 + 0.015 \\times \\cos(50^\\circ))\n$$\n$$\nB(50^\\circ) \\approx \\frac{\\pi}{3}(0.03 + 0.015 \\times 0.6427876)\n$$\n$$\nB(50^\\circ) \\approx \\frac{\\pi}{3}(0.03 + 0.009641814)\n$$\n$$\nB(50^\\circ) \\approx \\frac{\\pi}{3}(0.039641814)\n$$\n$$\nB(50^\\circ) \\approx 1.04719755 \\times 0.039641814 \\approx 0.04151253\n$$\nRounding the result to four significant figures gives $0.04151$.",
            "answer": "$$\n\\boxed{0.04151}\n$$"
        },
        {
            "introduction": "While forward models predict reflectance from known surface properties, the inverse problem—retrieving those properties from measurements—presents significant challenges. This hands-on coding exercise delves into the critical issue of ill-posedness, where different combinations of model parameters can yield nearly identical reflectance predictions, leading to unstable and non-unique solutions. You will use Singular Value Decomposition (SVD) to analyze the structure of the forward model and discover how the distribution of angular measurements directly impacts the stability of the inversion, providing insight into the practical difficulties of retrieving BRDF parameters from satellite or field data. ",
            "id": "3813298",
            "problem": "A bidirectional reflectance distribution function (BRDF) kernel-driven forward model assumes that the directional surface reflectance $r$ depends linearly on a set of kernels that encode geometric dependence. Consider the three-kernel linear model\n$$\nr(\\theta_s,\\theta_v,\\phi) \\;=\\; f_{\\mathrm{iso}}\\,K_{\\mathrm{iso}}(\\theta_s,\\theta_v,\\phi) \\;+\\; f_{\\mathrm{vol}}\\,K_{\\mathrm{vol}}(\\theta_s,\\theta_v,\\phi) \\;+\\; f_{\\mathrm{geo}}\\,K_{\\mathrm{geo}}(\\theta_s,\\theta_v,\\phi),\n$$\nwhere $\\theta_s$ is the solar zenith angle (in degrees), $\\theta_v$ is the view zenith angle (in degrees), and $\\phi$ is the relative azimuth angle (in degrees). The three kernels are defined as follows:\n- Isotropic kernel: $K_{\\mathrm{iso}}(\\theta_s,\\theta_v,\\phi) = 1$.\n- Volumetric (RossThick-like) kernel: define the scattering angle $\\xi$ via\n$$\n\\cos \\xi \\;=\\; \\cos \\theta_s \\cos \\theta_v \\;+\\; \\sin \\theta_s \\sin \\theta_v \\cos \\phi,\n$$\nwhere all trigonometric functions use angles converted from degrees to radians. Then set\n$$\nK_{\\mathrm{vol}}(\\theta_s,\\theta_v,\\phi) \\;=\\; \\frac{\\left(\\frac{\\pi}{2} - \\xi\\right)\\cos \\xi \\;+\\; \\sin \\xi}{\\cos \\theta_s \\;+\\; \\cos \\theta_v} \\;-\\; \\frac{\\pi}{4}.\n$$\n- Geometric (symmetric, reciprocity-preserving) kernel surrogate:\n$$\nK_{\\mathrm{geo}}(\\theta_s,\\theta_v,\\phi) \\;=\\; \\sin \\theta_s \\,\\sin \\theta_v \\,\\cos \\phi.\n$$\n\nThe linear forward model for a finite set of observation geometries $\\{(\\theta_{s,i},\\theta_{v,i},\\phi_i)\\}_{i=1}^N$ can be written in matrix form as\n$$\n\\mathbf{r} \\;=\\; \\mathbf{G}\\,\\mathbf{f},\n$$\nwhere $\\mathbf{r}\\in\\mathbb{R}^N$ is the vector of reflectances, $\\mathbf{f}\\in\\mathbb{R}^3$ is the kernel coefficient vector with components $\\mathbf{f} = \\begin{bmatrix} f_{\\mathrm{iso}} & f_{\\mathrm{vol}} & f_{\\mathrm{geo}} \\end{bmatrix}^{\\mathsf{T}}$, and $\\mathbf{G}\\in\\mathbb{R}^{N\\times 3}$ is the design (kernel) matrix with rows\n$$\n\\mathbf{g}_i^{\\mathsf{T}} \\;=\\; \\begin{bmatrix} K_{\\mathrm{iso}}(\\theta_{s,i},\\theta_{v,i},\\phi_i) & K_{\\mathrm{vol}}(\\theta_{s,i},\\theta_{v,i},\\phi_i) & K_{\\mathrm{geo}}(\\theta_{s,i},\\theta_{v,i},\\phi_i) \\end{bmatrix}.\n$$\n\nTask: Construct an explicit numerical example demonstrating non-uniqueness (ill-posedness) in the inversion by finding two distinct coefficient vectors $\\mathbf{f}$ and $\\mathbf{f}'$ that produce identical or nearly identical forward-modeled reflectance predictions over the provided observation geometries. Use the singular value decomposition (SVD) of $\\mathbf{G}$ to identify a direction in coefficient space $\\Delta \\mathbf{f}$ associated with the smallest singular value $\\sigma_{\\min}$; take $\\mathbf{f}' = \\mathbf{f} + \\alpha\\,\\Delta \\mathbf{f}$ for a prescribed scalar $\\alpha > 0$ and quantify how close $\\mathbf{G}\\mathbf{f}$ and $\\mathbf{G}\\mathbf{f}'$ are. The baseline coefficient vector is fixed to\n$$\n\\mathbf{f} \\;=\\; \\begin{bmatrix} 0.05 \\\\ 0.02 \\\\ 0.01 \\end{bmatrix}.\n$$\nYou must:\n- Build $\\mathbf{G}$ for each test geometry set.\n- Compute the $2$-norm condition number $\\kappa(\\mathbf{G}) = \\sigma_{\\max}/\\sigma_{\\min}$, where $\\sigma_{\\max}$ and $\\sigma_{\\min}$ are the largest and smallest singular values of $\\mathbf{G}$. If $\\sigma_{\\min} = 0$ (within numerical tolerance), report $\\kappa(\\mathbf{G})$ as $+\\infty$.\n- Let $\\Delta \\mathbf{f}$ be the right singular vector associated with $\\sigma_{\\min}$, scaled to have Euclidean norm $\\|\\Delta \\mathbf{f}\\|_2 = \\alpha$ with $\\alpha = 0.05$ (dimensionless). Define $\\mathbf{f}' = \\mathbf{f} + \\Delta \\mathbf{f}$.\n- Compute the root-mean-square error (RMSE) between the forward predictions $\\mathbf{G}\\mathbf{f}$ and $\\mathbf{G}\\mathbf{f}'$:\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\left( (\\mathbf{G}\\mathbf{f})_i - (\\mathbf{G}\\mathbf{f}')_i \\right)^2 }.\n$$\nAngles in all inputs are given in degrees but trigonometric functions must use radians; ensure correct conversion. Reflectance is dimensionless. Report the condition number (dimensionless) and RMSE (dimensionless) as plain decimal numbers.\n\nTest suite: For each of the following three geometry sets, compute the pair $\\big(\\kappa(\\mathbf{G}), \\mathrm{RMSE}\\big)$ using the above procedure.\n- Case A (underdetermined, perfect non-uniqueness expected): $N=2$ with $\\theta_s=30^\\circ$ for both observations, and\n  - Observation $1$: $(\\theta_v,\\phi) = (20^\\circ, 0^\\circ)$,\n  - Observation $2$: $(\\theta_v,\\phi) = (40^\\circ, 0^\\circ)$.\n- Case B (ill-conditioned, near-non-uniqueness expected): $N=6$ with $\\theta_s=30^\\circ$ and $(\\theta_v,\\phi) \\in \\{(5^\\circ,0^\\circ),(10^\\circ,0^\\circ),(15^\\circ,0^\\circ),(20^\\circ,0^\\circ),(25^\\circ,0^\\circ),(30^\\circ,0^\\circ)\\}$.\n- Case C (well-conditioned, reduced non-uniqueness expected): $N=12$ with $\\theta_s=30^\\circ$, $\\theta_v \\in \\{0^\\circ,30^\\circ,60^\\circ\\}$, and $\\phi \\in \\{0^\\circ,60^\\circ,120^\\circ,180^\\circ\\}$ using all combinations $(\\theta_v,\\phi)$.\n\nYour program must:\n- Use the above kernels and definitions exactly.\n- Compute $\\kappa(\\mathbf{G})$ and $\\mathrm{RMSE}$ for each case with $\\alpha = 0.05$.\n- Express angles in degrees in the input, converting to radians for computations.\n- Produce a single line of output containing a comma-separated flat list of $6$ values in the order $[\\kappa_A, \\mathrm{RMSE}_A, \\kappa_B, \\mathrm{RMSE}_B, \\kappa_C, \\mathrm{RMSE}_C]$. Each finite float must be rounded to six decimal places. If a condition number is infinite, print it as the string \"inf\" without quotes.\n\nAll outputs are dimensionless. The output must be exactly one line containing the list, for example: \"[123.456789,0.000001,789.123456,0.000010,12.345678,0.001234]\".",
            "solution": "The problem requires an analysis of the ill-posedness of a linear inverse problem in the context of a kernel-driven Bidirectional Reflectance Distribution Function (BRDF) forward model. We will construct the design matrix for three different sets of observation geometries, quantify the ill-conditioning using the matrix condition number derived from its Singular Value Decomposition (SVD), and demonstrate the effect of this ill-conditioning by showing that two distinct sets of model parameters can produce nearly identical reflectance predictions.\n\nThe forward model for surface reflectance $r$ is a linear combination of three kernels:\n$$\nr(\\theta_s,\\theta_v,\\phi) \\;=\\; f_{\\mathrm{iso}}\\,K_{\\mathrm{iso}}(\\theta_s,\\theta_v,\\phi) \\;+\\; f_{\\mathrm{vol}}\\,K_{\\mathrm{vol}}(\\theta_s,\\theta_v,\\phi) \\;+\\; f_{\\mathrm{geo}}\\,K_{\\mathrm{geo}}(\\theta_s,\\theta_v,\\phi)\n$$\nwhere $f_{\\mathrm{iso}}$, $f_{\\mathrm{vol}}$, and $f_{\\mathrm{geo}}$ are the model parameters (coefficients), and $\\theta_s$, $\\theta_v$, and $\\phi$ are the solar zenith, view zenith, and relative azimuth angles, respectively. All angles are provided in degrees but must be converted to radians for use in trigonometric functions.\n\nThe three kernels are defined as:\n1.  **Isotropic Kernel**: $K_{\\mathrm{iso}}(\\theta_s,\\theta_v,\\phi) = 1$. This kernel is constant and represents isotropic scattering.\n2.  **Volumetric Kernel**: This kernel models scattering from a canopy of randomly oriented leaves and is a variant of the Ross-Thick kernel. It depends on the scattering angle $\\xi$, which is the angle between the illumination and viewing vectors. The cosine of the scattering angle is given by the law of cosines on the sphere:\n    $$\n    \\cos \\xi \\;=\\; \\cos \\theta_s \\cos \\theta_v \\;+\\; \\sin \\theta_s \\sin \\theta_v \\cos \\phi\n    $$\n    From this, the scattering angle $\\xi = \\arccos(\\cos \\xi)$ is found, where $\\xi \\in [0, \\pi]$. The kernel is then:\n    $$\n    K_{\\mathrm{vol}}(\\theta_s,\\theta_v,\\phi) \\;=\\; \\frac{\\left(\\frac{\\pi}{2} - \\xi\\right)\\cos \\xi \\;+\\; \\sin \\xi}{\\cos \\theta_s \\;+\\; \\cos \\theta_v} \\;-\\; \\frac{\\pi}{4}\n    $$\n3.  **Geometric Kernel**: This kernel is a simplified representation of geometric-optical effects like mutual shadowing.\n    $$\n    K_{\\mathrm{geo}}(\\theta_s,\\theta_v,\\phi) \\;=\\; \\sin \\theta_s \\,\\sin \\theta_v \\,\\cos \\phi\n    $$\n\nFor a set of $N$ observations, the forward model is expressed in matrix form as $\\mathbf{r} = \\mathbf{G}\\mathbf{f}$, where $\\mathbf{r} \\in \\mathbb{R}^N$ is the vector of reflectances, $\\mathbf{f} \\in \\mathbb{R}^3$ is the parameter vector $\\mathbf{f} = [f_{\\mathrm{iso}}, f_{\\mathrm{vol}}, f_{\\mathrm{geo}}]^{\\mathsf{T}}$, and $\\mathbf{G} \\in \\mathbb{R}^{N\\times 3}$ is the design matrix. Each row $i$ of $\\mathbf{G}$ consists of the three kernel values for the $i$-th observation geometry: $\\mathbf{g}_i^{\\mathsf{T}} = [K_{\\mathrm{iso},i}, K_{\\mathrm{vol},i}, K_{\\mathrm{geo},i}]$.\n\nThe core of the analysis is the Singular Value Decomposition (SVD) of the design matrix $\\mathbf{G} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^{\\mathsf{T}}$, where $\\mathbf{U}$ and $\\mathbf{V}$ are orthogonal matrices containing the left and right singular vectors, respectively, and $\\mathbf{\\Sigma}$ is a diagonal matrix of singular values $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$.\n\nThe procedure for each test case is as follows:\n1.  **Construct $\\mathbf{G}$**: For the given set of $N$ geometries, compute the kernel values for each observation and populate the $N \\times 3$ matrix $\\mathbf{G}$.\n2.  **Compute SVD and Condition Number**: Use a numerical library to find the singular values $s_1, s_2, s_3$ of $\\mathbf{G}$. The $2$-norm condition number is $\\kappa(\\mathbf{G}) = \\sigma_{\\max}/\\sigma_{\\min} = \\sigma_1/\\sigma_3$. If $\\sigma_3 = 0$ (or is numerically indistinguishable from zero), the matrix is singular, the problem is underdetermined or rank-deficient, and $\\kappa(\\mathbf{G})$ is infinite.\n3.  **Find Perturbation Vector**: The right singular vector $\\mathbf{v}_3$ (the third column of $\\mathbf{V}$) corresponds to the smallest singular value $\\sigma_3$. It represents the direction in parameter space to which the model output is least sensitive. We define a perturbation vector $\\Delta \\mathbf{f}$ along this direction, scaled by a factor $\\alpha = 0.05$: $\\Delta \\mathbf{f} = \\alpha \\mathbf{v}_3$. Note that $\\mathbf{v}_3$ from a standard SVD is a unit vector, so $\\|\\Delta \\mathbf{f}\\|_2 = \\alpha$.\n4.  **Compare Predictions**: Given the baseline parameter vector $\\mathbf{f} = [0.05, 0.02, 0.01]^{\\mathsf{T}}$, we define a perturbed vector $\\mathbf{f}' = \\mathbf{f} + \\Delta\\mathbf{f}$. We then compute the reflectance predictions for both: $\\mathbf{r} = \\mathbf{G}\\mathbf{f}$ and $\\mathbf{r}' = \\mathbf{G}\\mathbf{f}'$.\n5.  **Calculate RMSE**: The discrepancy between the two sets of predictions is quantified by the Root-Mean-Square Error:\n    $$\n    \\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (r_i - r'_i)^2} = \\sqrt{\\frac{1}{N} \\|\\mathbf{r} - \\mathbf{r}'\\|_2^2}\n    $$\n    The difference vector is $\\mathbf{r} - \\mathbf{r}' = \\mathbf{G}(\\mathbf{f} - \\mathbf{f}') = -\\mathbf{G}\\Delta\\mathbf{f}$. Since $\\mathbf{G}\\mathbf{v}_3 = \\sigma_3 \\mathbf{u}_3$ (where $\\mathbf{u}_3$ is the third left singular vector and a unit vector), we have $\\|\\mathbf{G}\\Delta\\mathbf{f}\\|_2 = \\|\\alpha \\sigma_3 \\mathbf{u}_3\\|_2 = \\alpha \\sigma_3$. Therefore, the RMSE can be calculated directly as $\\mathrm{RMSE} = \\frac{\\alpha \\sigma_3}{\\sqrt{N}}$. A small $\\sigma_3$ implies a small RMSE, meaning a substantial change in parameters ($\\Delta \\mathbf{f}$) leads to a small change in predictions, which is the hallmark of an ill-posed inverse problem.\n\nWe apply this procedure to the three specified test cases.\n\n**Case A**: $N=2$ observations to determine $3$ parameters. This is an underdetermined system. We expect $\\mathbf{G}$ to be rank-deficient, meaning $\\sigma_3=0$. This leads to an infinite condition number and an RMSE of exactly $0$, indicating perfect non-uniqueness: $\\mathbf{G}\\Delta\\mathbf{f} = \\mathbf{0}$, so $\\mathbf{Gf} = \\mathbf{Gf}'$.\n\n**Case B**: $N=6$ observations, but all are confined to the principal plane ($\\phi=0^\\circ$) with a small range of view zenith angles. This geometrical alignment is known to cause near-collinearity between the volumetric and geometric kernels, making the columns of $\\mathbf{G}$ nearly linearly dependent. We expect a very small but non-zero $\\sigma_3$, a large condition number, and a very small RMSE.\n\n**Case C**: $N=12$ observations with diverse view zenith and relative azimuth angles. This rich sampling of the viewing hemisphere should provide stronger constraints on the parameters, making the columns of $\\mathbf{G}$ more linearly independent. We expect a larger $\\sigma_3$ (compared to Case B), a smaller (healthier) condition number, and consequently a larger RMSE for the same size of parameter perturbation $\\alpha$.\n\nThe final output values are computed by implementing these steps numerically.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the BRDF kernel model inversion problem for three test cases.\n    \"\"\"\n\n    def calculate_kernels(thetas_deg, thetav_deg, phi_deg):\n        \"\"\"\n        Calculates the three BRDF kernel values for given angles.\n        Angles are scalars in degrees.\n        \"\"\"\n        # Convert degrees to radians for trigonometric functions\n        thetas_rad = np.deg2rad(thetas_deg)\n        thetav_rad = np.deg2rad(thetav_deg)\n        phi_rad = np.deg2rad(phi_deg)\n\n        # Isotropic kernel\n        k_iso = 1.0\n\n        # Geometric kernel\n        k_geo = np.sin(thetas_rad) * np.sin(thetav_rad) * np.cos(phi_rad)\n\n        # Volumetric kernel (RossThick-like)\n        cos_thetas = np.cos(thetas_rad)\n        sin_thetas = np.sin(thetas_rad)\n        cos_thetav = np.cos(thetav_rad)\n        sin_thetav = np.sin(thetav_rad)\n        cos_phi = np.cos(phi_rad)\n\n        # Scattering angle xi\n        cos_xi = cos_thetas * cos_thetav + sin_thetas * sin_thetav * cos_phi\n        # Clip to handle potential floating point inaccuracies outside [-1, 1]\n        cos_xi = np.clip(cos_xi, -1.0, 1.0)\n        xi = np.arccos(cos_xi)\n        sin_xi = np.sin(xi)\n        \n        denominator = cos_thetas + cos_thetav\n        # The problem statement guarantees this denominator is not zero for the given inputs.\n        k_vol = ((np.pi / 2.0 - xi) * cos_xi + sin_xi) / denominator - np.pi / 4.0\n\n        return k_iso, k_vol, k_geo\n\n    def process_case(geometries, thetas_deg, f_base, alpha):\n        \"\"\"\n        Processes a single test case to compute condition number and RMSE.\n        \"\"\"\n        N = len(geometries)\n        G = np.zeros((N, 3))\n\n        for i, (thetav_deg, phi_deg) in enumerate(geometries):\n            kernels = calculate_kernels(thetas_deg, thetav_deg, phi_deg)\n            G[i, :] = kernels\n\n        # Compute Singular Value Decomposition\n        # full_matrices=False is more efficient as we only need the singular values\n        # and right singular vectors for a N x 3 matrix.\n        try:\n            U, s, Vt = np.linalg.svd(G, full_matrices=False)\n        except np.linalg.LinAlgError:\n            # This should not happen for the given problem setup\n            return \"error\", \"error\"\n        \n        # Singular values are sorted in descending order\n        sigma_max = s[0]\n        # For underdetermined systems (N  3), s will have only N elements.\n        if len(s)  3:\n            sigma_min = 0.0\n        else:\n            sigma_min = s[-1]\n\n        # Calculate condition number\n        # A small tolerance is used to check for numerical zero.\n        if sigma_min  1e-15:\n            kappa = \"inf\"\n        else:\n            kappa = sigma_max / sigma_min\n\n        # Calculate RMSE\n        # Method 1: Using the formula derived from SVD properties\n        # This is more direct and numerically stable.\n        rmse_direct = (alpha * sigma_min) / np.sqrt(N)\n        \n        # Method 2: Explicitly compute as per problem description to verify\n        # v_min is the right singular vector for sigma_min (last row of Vt)\n        v_min = Vt[-1, :]\n        delta_f = alpha * v_min\n        f_prime = f_base + delta_f\n        \n        r = G @ f_base\n        r_prime = G @ f_prime\n        \n        rmse_explicit = np.sqrt(np.mean((r - r_prime)**2))\n\n        # We use the explicit calculation as defined by the problem steps\n        # but the direct calculation serves as a good check.\n        # np.testing.assert_almost_equal(rmse_direct, rmse_explicit)\n        \n        return kappa, rmse_explicit\n\n    # --- Main Execution ---\n    \n    # Baseline coefficient vector\n    f_base = np.array([0.05, 0.02, 0.01])\n    # Scaling factor for perturbation\n    alpha = 0.05\n\n    # Test Case A\n    case_A_thetas = 30.0\n    case_A_geometries = [\n        (20.0, 0.0),  # (theta_v, phi)\n        (40.0, 0.0),\n    ]\n\n    # Test Case B\n    case_B_thetas = 30.0\n    case_B_geometries = [\n        (5.0, 0.0), (10.0, 0.0), (15.0, 0.0),\n        (20.0, 0.0), (25.0, 0.0), (30.0, 0.0),\n    ]\n\n    # Test Case C\n    case_C_thetas = 30.0\n    case_C_geometries = []\n    thetav_vals = [0.0, 30.0, 60.0]\n    phi_vals = [0.0, 60.0, 120.0, 180.0]\n    for tv in thetav_vals:\n        for p in phi_vals:\n            case_C_geometries.append((tv, p))\n\n    test_cases = [\n        (case_A_geometries, case_A_thetas),\n        (case_B_geometries, case_B_thetas),\n        (case_C_geometries, case_C_thetas),\n    ]\n    \n    results = []\n    for geometries, thetas in test_cases:\n        kappa, rmse = process_case(geometries, thetas, f_base, alpha)\n        \n        if isinstance(kappa, str) and kappa == \"inf\":\n            results.append(kappa)\n        else:\n            results.append(f\"{kappa:.6f}\")\n        \n        results.append(f\"{rmse:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon the understanding that BRDF inversion can be ill-posed, this advanced practice shifts the focus from analysis to proactive design. If the quality of a retrieval depends on the angular sampling, how can we design an experiment to get the best possible data? This exercise introduces the principles of optimal experimental design, where you will implement a search for a set of viewing geometries that maximizes the stability of the inversion by minimizing the condition number of the Fisher information matrix, a powerful technique used to plan field campaigns and assess the capabilities of satellite missions. ",
            "id": "3813269",
            "problem": "You are tasked with designing angular measurement geometries for a Bidirectional Reflectance Distribution Function (BRDF) kernel-based forward model in remote sensing, and selecting designs that minimize instability in inversion under a fixed number of views. Assume the standard linear kernel BRDF formulation in which the directional reflectance is modeled as a linear combination of basis kernels evaluated at viewing-solar geometry:\n$$\n\\rho(\\theta_s,\\theta_v,\\phi) = \\mathbf{K}(\\theta_s,\\theta_v,\\phi)^\\top \\mathbf{c},\n$$\nwhere $\\theta_s$ is the solar zenith angle, $\\theta_v$ is the view zenith angle, $\\phi$ is the relative azimuth angle, $\\mathbf{K}(\\theta_s,\\theta_v,\\phi)$ is a column vector of kernel functions evaluated at the measurement geometry, and $\\mathbf{c}$ are unknown kernel coefficients to be estimated. Use a three-kernel basis of dimension $3$ defined by\n$$\nK_1(\\theta_s,\\theta_v,\\phi) = 1,\\quad K_2(\\theta_s,\\theta_v,\\phi) = \\cos \\xi,\\quad K_3(\\theta_s,\\theta_v,\\phi) = \\sin\\theta_s \\sin\\theta_v \\cos\\phi,\n$$\nwith the scattering angle $\\xi$ defined via spherical trigonometry as\n$$\n\\cos \\xi = \\cos\\theta_s\\cos\\theta_v + \\sin\\theta_s \\sin\\theta_v \\cos\\phi.\n$$\nLet $\\mathbf{K}\\in\\mathbb{R}^{m\\times 3}$ denote the design matrix comprising $m$ rows, one per measurement, each row being $\\mathbf{K}(\\theta_s,\\theta_v,\\phi)^\\top$ at the selected geometry. Assume Gaussian measurement noise with diagonal weighting matrix $\\mathbf{W}\\in\\mathbb{R}^{m\\times m}$ such that the weighted normal matrix (Fisher information matrix) is\n$$\n\\mathbf{G} = \\mathbf{K}^\\top \\mathbf{W}\\mathbf{K}.\n$$\nYour design objective is to select a subset of $n$ measurement geometries from a candidate set to minimize the $2$-norm condition number of $\\mathbf{G}$, denoted $\\kappa_2(\\mathbf{G})$, subject to the matrix being full rank ($3$). In the event of ties in $\\kappa_2(\\mathbf{G})$ within a small numerical tolerance, resolve the tie by maximizing the determinant $\\det(\\mathbf{G})$ (D-optimality), which reduces the volume of the parameter uncertainty ellipsoid under Gaussian noise.\n\nAll angles must be handled and reported in radians. If no full-rank design exists for the given number of views, return an empty list for that case.\n\nImplement a search over all combinations of the specified candidate measurement geometries, constructing $\\mathbf{G}$ for each design using the above kernels and weighting, and selecting the design that minimizes $\\kappa_2(\\mathbf{G})$ with the D-optimality tie-breaker.\n\nThe program must process the following test suite. For each case, the solar zenith angle $\\theta_s$ is fixed, and the candidate set consists of pairs $(\\theta_v,\\phi)$. The diagonal weights are provided per candidate measurement as positive scalars and must be applied to the corresponding selected measurements.\n\n- Test Case 1 (general feasibility):\n    - Solar zenith angle: $\\theta_s = \\pi/6$.\n    - Number of views to select: $n=3$.\n    - Candidate set: all pairs $(\\theta_v,\\phi)$ with $\\theta_v \\in \\{0.0, 0.3, 0.6, 1.0\\}$ and $\\phi \\in \\{0.0, \\pi/3, 2\\pi/3, \\pi\\}$, resulting in $16$ candidates.\n    - Weights: all candidates have weight $1.0$.\n- Test Case 2 (weighted design and larger set):\n    - Solar zenith angle: $\\theta_s = 50\\pi/180$.\n    - Number of views to select: $n=4$.\n    - Candidate set (explicitly given): $(0.1,0.0)$, $(0.2,0.8)$, $(0.3,1.6)$, $(0.4,\\pi)$, $(0.5,0.4)$, $(0.6,1.2)$, $(0.7,2.4)$, $(0.8,\\pi)$, $(0.9,0.9)$, $(1.0,2.2)$.\n    - Weights corresponding to the above order: $[1.0, 0.5, 1.2, 0.8, 1.5, 0.7, 1.1, 0.9, 0.6, 1.3]$.\n- Test Case 3 (boundary case with insufficient views):\n    - Solar zenith angle: $\\theta_s = 40\\pi/180$.\n    - Number of views to select: $n=2$.\n    - Candidate set (explicitly given): $(0.2,0.0)$, $(0.4,1.0)$, $(0.6,2.0)$, $(0.8,\\pi)$, $(1.0,0.5)$, $(1.1,2.5)$.\n    - Weights: all candidates have weight $1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the selected design as a flat list of angles in radians in the order $[\\theta_{v,1}, \\phi_1, \\theta_{v,2}, \\phi_2, \\ldots, \\theta_{v,n}, \\phi_n]$. If no full-rank design exists, output an empty list for that case. For example, the final output must be of the form $[[\\ldots],[\\ldots],[]]$ (with actual numeric values in radians).",
            "solution": "The problem presented requires the determination of an optimal set of angular measurement geometries for a remote sensing application involving Bidirectional Reflectance Distribution Function (BRDF) modeling. The goal is to select a subset of $n$ viewing geometries from a larger candidate set that minimizes instabilities when inverting a linear BRDF model to retrieve surface properties. This is a classic problem in optimal experimental design, where the quality of the design is assessed through metrics derived from the Fisher information matrix.\n\nThe BRDF model is specified as a linear combination of three kernel functions:\n$$\n\\rho(\\theta_s,\\theta_v,\\phi) = \\mathbf{K}(\\theta_s,\\theta_v,\\phi)^\\top \\mathbf{c}\n$$\nHere, $\\rho$ is the directional reflectance, $(\\theta_s, \\theta_v, \\phi)$ represent the solar zenith, view zenith, and relative azimuth angles, respectively. The vector $\\mathbf{c} \\in \\mathbb{R}^3$ contains the unknown model coefficients to be determined through inversion. The vector of kernel functions, $\\mathbf{K}(\\theta_s,\\theta_v,\\phi)$, is given by:\n$$\n\\mathbf{K}(\\theta_s,\\theta_v,\\phi) = \\begin{bmatrix} K_1(\\theta_s,\\theta_v,\\phi) \\\\ K_2(\\theta_s,\\theta_v,\\phi) \\\\ K_3(\\theta_s,\\theta_v,\\phi) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ \\cos\\theta_s\\cos\\theta_v + \\sin\\theta_s \\sin\\theta_v \\cos\\phi \\\\ \\sin\\theta_s \\sin\\theta_v \\cos\\phi \\end{bmatrix}\n$$\nwhere the second kernel, $K_2$, is defined in terms of the scattering angle $\\xi$ as $K_2 = \\cos\\xi$. These kernels represent an isotropic scattering component ($K_1$), a volumetric scattering component ($K_2$), and a geometric-optical scattering component ($K_3$), characteristic of semi-empirical BRDF models used in satellite remote sensing.\n\nFor a set of $n$ measurements, the forward model can be expressed in matrix form as $\\mathbf{y} = \\mathbf{K}\\mathbf{c} + \\mathbf{\\epsilon}$, where $\\mathbf{y} \\in \\mathbb{R}^n$ is the vector of reflectance measurements, $\\mathbf{K} \\in \\mathbb{R}^{n \\times 3}$ is the design matrix, and $\\mathbf{\\epsilon}$ is the measurement noise. Each row $i$ of the matrix $\\mathbf{K}$ consists of the kernel vector $[K_1, K_2, K_3]$ evaluated at the $i$-th measurement geometry $(\\theta_{s}, \\theta_{v,i}, \\phi_i)$.\n\nAssuming the measurement noise is Gaussian with a covariance matrix proportional to $\\mathbf{W}^{-1}$, where $\\mathbf{W}$ is a diagonal matrix of weights, the Fisher information matrix for the coefficients $\\mathbf{c}$ is given by:\n$$\n\\mathbf{G} = \\mathbf{K}^\\top \\mathbf{W}\\mathbf{K}\n$$\nThis $3 \\times 3$ matrix is fundamental to assessing the quality of an experimental design. The inverse of $\\mathbf{G}$ is proportional to the covariance matrix of the estimated coefficients $\\hat{\\mathbf{c}}$. Thus, a \"large\" $\\mathbf{G}$ corresponds to a \"small\" parameter uncertainty.\n\nThe primary design objective is to select $n$ geometries that minimize the $2$-norm condition number of $\\mathbf{G}$, denoted $\\kappa_2(\\mathbf{G})$.\n$$\n\\kappa_2(\\mathbf{G}) = \\frac{\\lambda_{\\max}(\\mathbf{G})}{\\lambda_{\\min}(\\mathbf{G})}\n$$\nwhere $\\lambda_{\\max}$ and $\\lambda_{\\min}$ are the maximum and minimum eigenvalues of $\\mathbf{G}$, respectively. A large condition number indicates an ill-conditioned problem, where small perturbations in the measurements (due to noise) can lead to large variations in the estimated parameters $\\hat{\\mathbf{c}}$. This metric can only be computed if $\\mathbf{G}$ is invertible, which requires it to be of full rank ($3$). A necessary, but not sufficient, condition for $\\mathbf{G}$ to be full rank is that the number of linearly independent measurements, $n$, must be at least equal to the number of model parameters, which is $3$.\n\nIn case of a tie, where multiple designs yield condition numbers that are equal within a small numerical tolerance, a secondary criterion is invoked: maximization of the determinant of $\\mathbf{G}$, $\\det(\\mathbf{G})$. This is the principle of D-optimality, which aims to minimize the volume of the confidence ellipsoid for the estimated parameters.\n\nThe solution strategy is a combinatorial search over all possible designs. For each test case, we are given a fixed solar zenith angle $\\theta_s$, a number of views to select $n$, a set of $N$ candidate viewing geometries $\\{(\\theta_{v,i}, \\phi_i)\\}_{i=1}^N$, and their corresponding weights $\\{w_i\\}_{i=1}^N$.\n\nThe algorithm proceeds as follows:\n1.  Generate all combinations of $n$ indices from the set of $N$ candidate geometries. The total number of such combinations is $\\binom{N}{n}$.\n2.  For each combination:\n    a. Construct the $n \\times 3$ design matrix $\\mathbf{K}$ by evaluating the three kernel functions for each selected geometry.\n    b. Construct the $n \\times n$ diagonal weight matrix $\\mathbf{W}$ from the weights of the selected geometries.\n    c. Compute the $3 \\times 3$ Fisher information matrix $\\mathbf{G} = \\mathbf{K}^\\top \\mathbf{W} \\mathbf{K}$.\n    d. Check if $\\mathbf{G}$ is of full rank, i.e., $\\text{rank}(\\mathbf{G}) = 3$. This is a critical prerequisite. If not, the design is invalid and is discarded. A necessary condition is $n \\ge 3$, as a matrix product $\\mathbf{K}^\\top \\mathbf{W} \\mathbf{K}$ cannot have a rank greater than the rank of $\\mathbf{K}$, which is at most $\\min(n, 3)$.\n    e. If $\\mathbf{G}$ is full-rank, compute its $2$-norm condition number $\\kappa_2(\\mathbf{G})$ and its determinant $\\det(\\mathbf{G})$.\n3.  Maintain a record of the best design found so far. The initial \"best\" condition number is set to infinity. Iterate through all valid designs, updating the best design based on the specified criteria: first, a lower condition number, and second (for ties), a higher determinant.\n4.  If, after checking all combinations, no full-rank design was found (as will be the case if $n  3$), the result for that test case is an empty list. Otherwise, the result is the set of optimal geometries, formatted as a flat list of angles.\n\nThis exhaustive search guarantees finding the globally optimal design within the discrete space of candidate subsets. The provided test cases are computationally feasible with this approach. Specifically, Test Case 3 with $n=2$ views to estimate $3$ parameters will demonstrably fail to produce any full-rank design, as dictated by the principles of linear algebra.",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases for optimal BRDF measurement geometry design.\n    \"\"\"\n\n    def calculate_kernels(theta_s: float, theta_v: float, phi: float) - np.ndarray:\n        \"\"\"\n        Calculates the three kernel values for a given geometry.\n\n        Args:\n            theta_s: Solar zenith angle in radians.\n            theta_v: View zenith angle in radians.\n            phi: Relative azimuth angle in radians.\n\n        Returns:\n            A 1D numpy array of shape (3,) containing [K1, K2, K3].\n        \"\"\"\n        sin_ts = np.sin(theta_s)\n        cos_ts = np.cos(theta_s)\n        sin_tv = np.sin(theta_v)\n        cos_tv = np.cos(theta_v)\n        cos_phi = np.cos(phi)\n\n        k1 = 1.0\n        # cos_xi = cos(theta_s)cos(theta_v) + sin(theta_s)sin(theta_v)cos(phi)\n        k2 = cos_ts * cos_tv + sin_ts * sin_tv * cos_phi\n        k3 = sin_ts * sin_tv * cos_phi\n\n        return np.array([k1, k2, k3])\n\n    def find_optimal_design(theta_s: float, n: int, candidates: list, weights: list) - list:\n        \"\"\"\n        Finds the optimal measurement design by searching all combinations.\n\n        Args:\n            theta_s: Solar zenith angle in radians.\n            n: Number of views to select.\n            candidates: List of (theta_v, phi) tuples for candidate geometries.\n            weights: List of weights for each candidate.\n\n        Returns:\n            A flat list of the optimal [theta_v1, phi1, theta_v2, phi2, ...] angles,\n            or an empty list if no full-rank design is possible.\n        \"\"\"\n        num_params = 3\n        if n  num_params:\n            return []\n\n        best_design_indices = None\n        min_cond_num = float('inf')\n        max_det = -1.0\n        \n        # Tolerance for comparing condition numbers for a tie\n        cond_tol = 1e-9\n\n        candidate_indices = range(len(candidates))\n\n        for combo_indices in combinations(candidate_indices, n):\n            K_rows = []\n            W_diag = []\n            for idx in combo_indices:\n                theta_v, phi = candidates[idx]\n                K_rows.append(calculate_kernels(theta_s, theta_v, phi))\n                W_diag.append(weights[idx])\n\n            K = np.array(K_rows)\n            W = np.diag(W_diag)\n            \n            # Check if K itself can possibly lead to a full rank G.\n            # This is automatically handled by the G rank check, but is a good conceptual point.\n            # Rank of K must be num_params for G to be full rank.\n            if np.linalg.matrix_rank(K)  num_params:\n                continue\n\n            G = K.T @ W @ K\n\n            # G must be full rank to be invertible and have a meaningful condition number.\n            if np.linalg.matrix_rank(G)  num_params:\n                continue\n\n            cond_num = np.linalg.cond(G, 2)\n            \n            is_better = False\n            # If the new condition number is significantly better, update.\n            if cond_num  min_cond_num - cond_tol:\n                is_better = True\n            # If there is a tie in condition number, use the determinant as a tie-breaker.\n            elif abs(cond_num - min_cond_num) = cond_tol:\n                det_G = np.linalg.det(G)\n                if det_G  max_det:\n                    is_better = True\n\n            if is_better:\n                min_cond_num = cond_num\n                max_det = np.linalg.det(G) # Recompute or store determinant\n                best_design_indices = combo_indices\n\n        if best_design_indices is None:\n            return []\n        \n        # Format the best design for output\n        optimal_design_flat = []\n        # Sort indices to ensure deterministic output if multiple combinations have the same geometry set\n        sorted_indices = sorted(list(best_design_indices))\n        for idx in sorted_indices:\n            optimal_design_flat.extend(candidates[idx])\n        return optimal_design_flat\n\n    # Test Case 1\n    theta_s1 = math.pi / 6\n    n1 = 3\n    theta_v_opts1 = [0.0, 0.3, 0.6, 1.0]\n    phi_opts1 = [0.0, math.pi / 3, 2 * math.pi / 3, math.pi]\n    candidates1 = [(tv, p) for tv in theta_v_opts1 for p in phi_opts1]\n    weights1 = [1.0] * len(candidates1)\n\n    # Test Case 2\n    theta_s2 = 50 * math.pi / 180\n    n2 = 4\n    candidates2 = [\n        (0.1, 0.0), (0.2, 0.8), (0.3, 1.6), (0.4, math.pi), (0.5, 0.4),\n        (0.6, 1.2), (0.7, 2.4), (0.8, math.pi), (0.9, 0.9), (1.0, 2.2)\n    ]\n    weights2 = [1.0, 0.5, 1.2, 0.8, 1.5, 0.7, 1.1, 0.9, 0.6, 1.3]\n\n    # Test Case 3\n    theta_s3 = 40 * math.pi / 180\n    n3 = 2\n    candidates3 = [\n        (0.2, 0.0), (0.4, 1.0), (0.6, 2.0), (0.8, math.pi), (1.0, 0.5), (1.1, 2.5)\n    ]\n    weights3 = [1.0] * len(candidates3)\n\n    test_cases = [\n        (theta_s1, n1, candidates1, weights1),\n        (theta_s2, n2, candidates2, weights2),\n        (theta_s3, n3, candidates3, weights3),\n    ]\n\n    results_str = []\n    for ts, n, cands, wts in test_cases:\n        result = find_optimal_design(ts, n, cands, wts)\n        results_str.append(str(result))\n\n    # The problem asks for comma-separated output, including for empty lists. `str` does this.\n    final_output = f\"[{','.join(results_str)}]\"\n    # A final replacement to ensure the exact format of [[],[]] instead of ['[]', '[]']\n    final_output = final_output.replace(\"'\",\"\")\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}