{
    "hands_on_practices": [
        {
            "introduction": "遥感影像的空间分辨率是决定其能否胜任特定灾害监测任务（如滑坡编目）的根本参数。本练习将引导你从基本的针孔相机模型出发，建立卫星高度、传感器视场角与地面采样距离（$GSD$）之间的联系，并进一步将其转化为一个实际的测绘指标——能够被可靠描绘的最小滑坡面积。这项实践旨在培养评估遥感数据适用性的核心能力。",
            "id": "3819344",
            "problem": "一颗卫星上搭载的正下视光学帧幅传感器用于绘制山区滑坡图。假设观测点的地形为局部平坦，镜头畸变可忽略不计，且探测器像素为正方形，因此在正下方的地面投影为正方形。该平台在离地 $H = 700{,}000\\,\\mathrm{m}$ 的恒定高度飞行。该传感器的全水平视场为 $\\Phi_{x} = 15^\\circ$，并拥有一个正方形探测器阵列，其水平（跨轨）方向有 $N_{x} = 6000$ 个像素，垂直（沿轨）方向有 $N_{y} = 6000$ 个像素。角度以度为单位。\n\n从针孔相机模型和基本三角关系出发，根据 $H$、$\\Phi_{x}$ 和 $N_{x}$ 推导正下方水平方向的地面采样距离（Ground Sampling Distance (GSD)）。然后，采用业务化遥感中多边形特征的保守最小制图单元标准，即滑坡必须至少占据一个 $3 \\times 3$ 的连续像素簇才能被可靠地描绘，计算可绘制的最小滑坡面积（以平方米为单位）。\n\n用 $\\mathrm{m^2}$ 表示最终面积，并将答案四舍五入到四位有效数字。最终的数值答案必须是一个单独的数字。",
            "solution": "该问题要求推导星载光学传感器在正下方的地面采样距离（GSD），并根据指定标准计算最小可绘制滑坡面积。该问题提法明确且有科学依据。我们将首先使用针孔相机模型推导所需公式，然后计算数值结果。\n\n设 $H$ 为卫星离地的恒定高度。设 $\\Phi_{x}$ 为传感器的全水平视场， $N_{x}$ 为相应水平（跨轨）方向上的探测器像素数。我们假设观测点的地形为局部平坦。\n\n根据针孔相机模型，在高度 $H$ 处的传感器观测到的地面总幅宽，我们记为 $W_x$。传感器、地面上的星下点以及刈幅的一侧边缘构成一个直角三角形。在传感器处，星下点方向线与到刈幅边缘的视线之间的夹角是全视场的一半，即 $\\frac{\\Phi_{x}}{2}$。此角的对边是地面上半幅宽，即 $\\frac{W_x}{2}$。此角的邻边是高度 $H$。\n\n根据基本三角关系，我们可以写出：\n$$\n\\tan\\left(\\frac{\\Phi_{x}}{2}\\right) = \\frac{\\frac{W_x}{2}}{H}\n$$\n求解总幅宽 $W_x$，我们得到：\n$$\nW_x = 2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)\n$$\n地面采样距离（GSD）是单个探测器像素所覆盖的地面区域的尺寸。对于正下视情况，我们可以通过将总幅宽 $W_x$ 除以该方向上的像素数 $N_x$ 来求得水平方向的 GSD，即 $GSD_x$。\n$$\nGSD_x = \\frac{W_x}{N_x}\n$$\n代入 $W_x$ 的表达式，我们得到用给定参数表示的正下方 GSD 的推导公式：\n$$\nGSD_x = \\frac{2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)}{N_{x}}\n$$\n这样就完成了问题的推导部分。\n\n接下来，我们被要求计算最小可绘制滑坡面积。问题指明，滑坡必须至少占据一个 $3 \\times 3$ 的连续像素簇才能被可靠地描绘。问题还指出，在正下方的地面投影是正方形，这意味着水平（跨轨）和垂直（沿轨）方向的 GSD 是相同的。我们将这个共同的 GSD 记为 $GSD = GSD_x$。因此，单个像素的地面投影面积为 $A_{\\text{pixel}} = GSD^2$。\n\n最小可绘制面积 $A_{\\min}$ 对应于一个 $3 \\times 3$ 像素簇的面积。该像素簇由 $3 \\times 3 = 9$ 个像素组成。因此，最小面积为：\n$$\nA_{\\min} = 9 \\times A_{\\text{pixel}} = 9 \\times GSD^2\n$$\n代入推导出的 $GSD = GSD_x$ 表达式：\n$$\nA_{\\min} = 9 \\left( \\frac{2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)}{N_{x}} \\right)^2\n$$\n现在我们代入给定的数值：\n- 高度：$H = 700000\\,\\mathrm{m}$\n- 全水平视场：$\\Phi_{x} = 15^\\circ$\n- 水平像素数：$N_{x} = 6000$\n\n首先，让我们计算 GSD 的值：\n$$\nGSD = \\frac{2 \\times 700000 \\times \\tan\\left(\\frac{15^\\circ}{2}\\right)}{6000} = \\frac{1400000 \\times \\tan(7.5^\\circ)}{6000} = \\frac{700}{3} \\tan(7.5^\\circ)\n$$\n现在，我们计算最小可绘制面积 $A_{\\min}$：\n$$\nA_{\\min} = 9 \\times \\left( \\frac{700}{3} \\tan(7.5^\\circ) \\right)^2\n$$\n$$\nA_{\\min} = 9 \\times \\frac{700^2}{3^2} \\times (\\tan(7.5^\\circ))^2\n$$\n$$\nA_{\\min} = 9 \\times \\frac{490000}{9} \\times (\\tan(7.5^\\circ))^2\n$$\n$$\nA_{\\min} = 490000 \\times (\\tan(7.5^\\circ))^2\n$$\n使用计算器计算 $\\tan(7.5^\\circ)$ 的值：\n$$\n\\tan(7.5^\\circ) \\approx 0.13165249758\n$$\n$$\n(\\tan(7.5^\\circ))^2 \\approx 0.01733238622\n$$\n将此值代回 $A_{\\min}$ 的表达式中：\n$$\nA_{\\min} \\approx 490000 \\times 0.01733238622 \\approx 8492.869248\\,\\mathrm{m^2}\n$$\n问题要求将最终答案四舍五入到四位有效数字。计算出的值为 $8492.869248$。第五位有效数字是 $8$，所以我们将第四位数字向上取整。\n$$\nA_{\\min} \\approx 8493\\,\\mathrm{m^2}\n$$",
            "answer": "$$\\boxed{8493}$$"
        },
        {
            "introduction": "合成孔径雷达（SAR）是一种强大的全天候、全天时对地观测工具，在灾害监测中应用广泛。然而，其独特的侧视成像几何会在地形复杂区域产生特殊的几何畸变。本练习旨在挑战你根据地形坡度与雷达视角，准确识别并理解这些畸变（透视收缩、叠掩和阴影），这对于解译滑坡多发山区的SAR影像至关重要。",
            "id": "3819345",
            "problem": "一个最近遭受严重野火影响的山区流域正在使用合成孔径雷达（SAR）进行火后滑坡灾害监测。SAR平台以$\\,\\theta_i = 35^{\\circ}\\,$的入射角（相对于平坦地形上的局部垂直方向测量）采集一条带数据，其视线方向为从东向西。考虑五个大致沿SAR距离方向排列的连续地形段（即，它们的最陡下降/上升方向朝向、背离或垂直于雷达视线方向）：\n\n- 段 $S1$：一个坡度角为$\\,\\alpha_1 = 20^{\\circ}\\,$、坡向为$\\,90^{\\circ}\\,$（朝东，因此朝向雷达）的烧毁山坡。\n- 段 $S2$：一个坡度角为$\\,\\alpha_2 = 40^{\\circ}\\,$、坡向为$\\,90^{\\circ}\\,$（朝向雷达）的新滑坡壁。\n- 段 $S3$：一个坡度角为$\\,\\alpha_3 = 20^{\\circ}\\,$、坡向为$\\,270^{\\circ}\\,$（朝西，因此背离雷达）的烧毁反坡。\n- 段 $S4$：一个坡度角为$\\,\\alpha_4 = 60^{\\circ}\\,$、坡向为$\\,270^{\\circ}\\,$（背离雷达）的岩石悬崖。\n- 段 $S5$：一个坡度角为$\\,\\alpha_5 = 30^{\\circ}\\,$、坡向为$\\,0^{\\circ}\\,$（朝北，大致垂直于雷达视线方向）的山脊。\n\n为进行几何推理，假设在雷达视线平面内存在一个二维垂直剖面，并且与距离向畸变相关的局部坡度分量是坡度在雷达视线方向上的投影。忽略野火引起的植被散射变化；仅关注距离向的几何畸变。\n\n哪个选项正确地根据局部入射角和坡度几何形状定义了SAR成像中的叠掩、透视收缩和阴影，并正确地指出了在所述采集条件下，五个地形段中哪一个表现出每种畸变？\n\nA. 叠掩是指由于距离向顺序的反转，沿雷达视线的较高点的回波比较低点的回波先到达；当沿视线方向的坡度分量超过入射角时发生，即$\\,\\alpha_{\\parallel} > \\theta_i\\,$。透视收缩是指坡面朝向雷达，但距离向顺序得以保持，同时斜距距离被压缩；当$\\,0  \\alpha_{\\parallel}  \\theta_i\\,$时发生。阴影是指由于雷达波束未照射到地表（局部入射角$\\,\\theta_{\\mathrm{loc}} \\ge 90^{\\circ}\\,$）而没有回波的现象，对于背离雷达的坡面，当$\\,\\alpha_{\\parallel} > 90^{\\circ} - \\theta_i\\,$时发生。在这些条件下：$S2$表现出叠掩，$S1$表现出透视收缩，$S4$处于雷达阴影区，$S3$既不表现出叠掩也不表现出阴影，$S5$的距离向畸变可忽略不计，因为$\\,\\alpha_{\\parallel} \\approx 0\\,$。\n\nB. 无论坡向如何，只要坡度角大于$\\,90^{\\circ} - \\theta_i\\,$就会发生叠掩；透视收缩仅发生在$\\,\\alpha_{\\parallel}  \\theta_i\\,$的背离雷达坡面上；当朝向雷达的坡面$\\,\\alpha_{\\parallel}  \\theta_i\\,$时发生阴影。在这些条件下：$S1$无畸变，$S2$被阴影遮挡，$S3$发生透视收缩，$S4$无畸变，$S5$发生叠掩。\n\nC. 叠掩由$\\,\\alpha_{\\parallel} = 0\\,$（垂直坡向）定义，因为此时雷达无法分辨高程变化；透视收缩要求$\\,\\alpha_{\\parallel} > 90^{\\circ}\\,$；当$\\,\\alpha_{\\parallel}  0\\,$时发生阴影。在这些条件下：$S5$发生叠掩，$S1$被阴影遮挡，$S2$发生透视收缩，$S3$被阴影遮挡，$S4$发生透视收缩。\n\nD. 当朝向雷达的坡面$\\,\\alpha_{\\parallel}  \\theta_i\\,$时发生叠掩；当背离雷达的坡面$\\,\\alpha_{\\parallel} > \\theta_i\\,$时要求发生透视收缩；无论坡向如何，只要坡度$\\,\\alpha_{\\parallel} > \\theta_i\\,$就会发生阴影。在这些条件下：$S1$发生叠掩，$S2$发生透视收缩，$S3$被阴影遮挡，$S4$被阴影遮挡，$S5$无畸变。\n\n选择唯一的最佳选项。",
            "solution": "该问题是一个定义明确的SAR几何问题。为了找到正确的答案，我们将逐步分析每种几何畸变的条件，并将这些条件应用于问题中描述的五个地形段。\n\n**1. SAR几何畸变原理**\n\n雷达是一种侧视成像系统，这导致其图像几何对地形非常敏感。主要的几何畸变类型有：\n- **透视收缩 (Foreshortening):** 当地表坡面朝向雷达时（即坡向与雷达视线方向相对），该坡面在图像上的投影会被压缩。这种情况发生在朝向雷达的坡度（$\\alpha_{\\parallel}$）小于雷达入射角（$\\theta_i$）时。条件：$0  \\alpha_{\\parallel}  \\theta_i$。\n- **叠掩 (Layover):** 这是透视收缩的极端情况。当朝向雷达的坡度陡于雷达入射角时，山顶的雷达回波会比山脚的回波更早到达传感器。这导致图像中地物的距离向顺序发生颠倒。条件：$\\alpha_{\\parallel} > \\theta_i$。\n- **阴影 (Shadow):** 当地表坡面背离雷达且非常陡峭，以至于雷达波束无法照射到该坡面时，就会产生阴影。这导致图像上出现没有信号的黑色区域。对于背离雷达的坡面，条件是其坡度大于雷达波束的俯视角，即 $\\alpha > 90^{\\circ} - \\theta_i$。\n\n**2. 将原理应用于各地形段**\n\n给定的雷达入射角为 $\\theta_i = 35^{\\circ}$。雷达视线方向为从东向西。\n\n- **计算阴影条件:** 对于背离雷达的坡面（朝西），发生阴影的坡度阈值为 $\\alpha > 90^{\\circ} - 35^{\\circ} = 55^{\\circ}$。\n\n- **分析各地形段:**\n    - **段 S1:** 坡度 $\\alpha_1 = 20^{\\circ}$，坡向朝东（朝向雷达）。因为 $0  20^{\\circ}  35^{\\circ}$（即 $\\alpha_1  \\theta_i$），该段表现出**透视收缩**。\n    - **段 S2:** 坡度 $\\alpha_2 = 40^{\\circ}$，坡向朝东（朝向雷达）。因为 $40^{\\circ} > 35^{\\circ}$（即 $\\alpha_2 > \\theta_i$），该段表现出**叠掩**。\n    - **段 S3:** 坡度 $\\alpha_3 = 20^{\\circ}$，坡向朝西（背离雷达）。因为 $20^{\\circ}  55^{\\circ}$（即 $\\alpha_3$ 未达到阴影阈值），该段将被正常成像，只是在斜距图像上看起来比实际更长。它既不发生叠掩也不发生阴影。\n    - **段 S4:** 坡度 $\\alpha_4 = 60^{\\circ}$，坡向朝西（背离雷达）。因为 $60^{\\circ} > 55^{\\circ}$（即 $\\alpha_4$ 超过阴影阈值），该段将处于**雷达阴影区**。\n    - **段 S5:** 坡度 $\\alpha_5 = 30^{\\circ}$，坡向朝北（垂直于雷达视线方向）。由于其坡向几乎垂直于距离向，其在距离向的坡度分量 $\\alpha_{\\parallel} \\approx 0$。因此，它几乎不产生距离向的几何畸变。\n\n**3. 评估选项**\n\n- **选项 A:**\n    - 定义：正确定义了叠掩（$\\alpha_{\\parallel} > \\theta_i$）、透视收缩（$0  \\alpha_{\\parallel}  \\theta_i$）和阴影（对于背离雷达的坡面，$\\alpha > 90^{\\circ} - \\theta_i$）。\n    - 应用：S2 叠掩，S1 透视收缩，S4 阴影，S3 无特殊畸变，S5 畸变可忽略。这与我们的分析完全吻合。\n\n- **选项 B, C, D:** 均包含错误的定义或错误的地形段与畸变类型的对应关系。例如，选项B错误地将阴影与朝向雷达的坡面联系起来；选项C对叠掩的定义完全错误；选项D对叠掩和透视收缩的条件应用错误。\n\n因此，选项A是唯一正确的描述。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在利用光学遥感影像定量评估野火燃烧烈度时，地形引起的太阳光照差异是一个主要的误差来源。本综合实践将指导你编写一个程序，利用数字高程模型（DEM）来模拟地形阴影，并量化这些阴影如何影响燃烧烈度评估（如归一化燃烧指数NBR）。通过实施地形校正，你将体验从原始数据到更可靠的灾害评估产品的完整工作流程。",
            "id": "3819382",
            "problem": "你的任务是设计并实现一个完整的、可运行的程序，该程序使用数字高程模型（DEM）和太阳几何学为光学影像构建地形阴影掩膜，然后量化其对基于光谱指数的燃烧严重程度估算的影响。该程序必须计算一个物理上一致的地形阴影掩膜，该掩膜能捕捉由地形引起的自阴影和投射阴影，并且必须评估阴影如何使火后光谱测量产生偏差，以及在一个有物理动机的模型下如何进行校正。工作应完全在一个二维网格（栅格）域中进行，该域采用右手笛卡尔坐标系，其中$x$轴指向地理东， $y$轴指向地理北，$z$轴指向上。角度必须以度为单位提供和使用。所有量必须使用此处定义的单位表示：距离单位为米，角度单位为度，反射率则为无单位的小数值。\n\n从以下基本基础开始：\n\n- 地形由数字高程模型（DEM）网格化表面 $z(x,y)$ 表示，该表面在间距为 $\\Delta$ 的规则网格上采样，其中 $\\Delta$ 是像素大小（假设 $\\Delta$ 是恒定的）。\n- 对于平滑表面，局部单位法向量 $\\mathbf{n}(x,y)$ 可通过偏导数 $\\partial z / \\partial x$ 和 $\\partial z / \\partial y$ 导出，即 $\\mathbf{n} \\propto \\left(-\\frac{\\partial z}{\\partial x}, -\\frac{\\partial z}{\\partial y}, 1\\right)$，然后进行归一化。\n- 太阳几何由太阳高度角 $\\theta_e$（地平线以上的角度）和太阳方位角 $\\phi$（从地理北向顺时针测量的角度）表示。指向太阳的单位方向向量 $\\mathbf{s}$（从地表位置指向太阳）由太阳天顶角 $\\theta_z = 90^\\circ - \\theta_e$ 和方位角 $\\phi$ 通过与所述坐标轴约定一致的标准方向余弦定义。\n- 局部入射余弦为 $\\cos i = \\mathbf{n} \\cdot \\mathbf{s}$。如果 $\\cos i \\le 0$，则表面处于自阴影中（无直接光照）。\n- 当沿太阳方位角方向的地形阻挡了太阳的视线时，会产生投射阴影。对于一个高程为 $z_0$ 的给定像素，沿上太阳方向的水平地面投影距离为 $d$，定义其地平线角为 $\\alpha(d) = \\arctan\\left( \\frac{z(d) - z_0}{d} \\right)$。如果沿朝向太阳的光线遇到的最大地平线角 $\\alpha_{\\max}$ 满足 $\\alpha_{\\max} > \\theta_e$，则该像素处于投射阴影中。\n- 根据 Lambert 余弦定律，近朗伯表面的直接光照下光学表面反射率与 $\\cos i$ 成比例。一种广泛使用的一阶地形校正方法是通过乘以一个与 $1/\\cos i$ 成比例的因子来重定标反射率 $R$，并通过场景平均光照进行归一化，以保持整体亮度。\n\n仅使用这些基础，实现一个算法，该算法：\n\n1. 根据所提供的 DEM，使用尊重所述坐标轴方向和像素间距 $\\Delta$ 的有限差分法，计算每个网格单元的局部地形单位法向量 $\\mathbf{n}$。\n2. 通过结合自阴影和投射阴影来构建一个二元地形阴影掩膜。对于自阴影，使用准则 $\\cos i \\le 0$。对于投射阴影，通过沿太阳方位角方向追踪，并使用 DEM 的双线性插值来评估 $\\alpha(d)$ 并与 $\\theta_e$ 进行比较，从而估计地平线角。\n3. 以小数形式量化阴影像素的比例。\n4. 使用近红外（NIR）和短波红外（SWIR）反射率计算火前和火后两种情况下的归一化燃烧指数（NBR），然后计算增量归一化燃烧指数（dNBR），即火前 NBR 减去火后 NBR。使用 NBR 的常规定义，该定义源自植被和炭黑在 NIR 和 SWIR 反射率上经过充分验证的对比度，即 $ \\mathrm{NBR} = \\frac{\\mathrm{NIR} - \\mathrm{SWIR}}{\\mathrm{NIR} + \\mathrm{SWIR}} $，以及 $ \\mathrm{dNBR} = \\mathrm{NBR}_{\\text{pre}} - \\mathrm{NBR}_{\\text{post}} $。如果分母 $\\mathrm{NIR} + \\mathrm{SWIR}$ 等于零，则将该像素的结果视为未定义。\n5. 对火后反射率应用基于余弦的地形校正，使用 $\\cos i$ 使得 $R_{\\text{corr}} = R \\cdot \\frac{\\overline{\\cos i}}{\\cos i}$，其中 $\\overline{\\cos i}$ 是所有 $\\cos i > 0$ 的光照像素的 $\\cos i$ 平均值，然后重新计算 NBR 和 dNBR。为避免不符合物理的缩放，将校正后的反射率限制在闭区间 $[0,1]$ 内，并用一个小的正常数替换 $\\cos i \\le 0$ 的情况以避免除以零。这代表了地形引起的阴影会降低观测到的反射率并可能夸大燃烧严重程度估算的一阶影响；该校正旨在减轻这种偏差。\n\n测试套件规范：\n\n为三个测试用例实现该算法，这些用例共同涵盖了典型条件、边界行为和边缘情况。对于所有用例，像素大小为 $\\Delta = 30\\ \\text{m}$。\n\n- 用例1（中等坡度，中等太阳高度）：\n  - 太阳方位角 $\\phi = 135^\\circ$，太阳高度角 $\\theta_e = 35^\\circ$。\n  - DEM 为一个 $5\\times 5$ 的高程网格，单位为米：\n    $$\n    \\begin{bmatrix}\n    100  102  104  106  108 \\\\\n    100  103  106  109  112 \\\\\n    100  104  108  112  116 \\\\\n    100  105  110  115  120 \\\\\n    100  106  112  118  124\n    \\end{bmatrix}\n    $$\n  - 火前 NIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.52  0.50  0.48  0.46  0.44 \\\\\n    0.53  0.51  0.49  0.47  0.45 \\\\\n    0.54  0.52  0.50  0.48  0.46 \\\\\n    0.55  0.53  0.51  0.49  0.47 \\\\\n    0.56  0.54  0.52  0.50  0.48\n    \\end{bmatrix}\n    $$\n  - 火前 SWIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.22  0.22  0.23  0.24  0.25 \\\\\n    0.21  0.21  0.22  0.23  0.24 \\\\\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.18  0.18  0.19  0.20  0.21\n    \\end{bmatrix}\n    $$\n  - 火后 NIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.36  0.34  0.32  0.30  0.28 \\\\\n    0.35  0.33  0.31  0.29  0.27 \\\\\n    0.34  0.32  0.30  0.28  0.26 \\\\\n    0.33  0.31  0.29  0.27  0.25 \\\\\n    0.32  0.30  0.28  0.26  0.24\n    \\end{bmatrix}\n    $$\n  - 火后 SWIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.30  0.31  0.32  0.33  0.34 \\\\\n    0.31  0.32  0.33  0.34  0.35 \\\\\n    0.32  0.33  0.34  0.35  0.36 \\\\\n    0.33  0.34  0.35  0.36  0.37 \\\\\n    0.34  0.35  0.36  0.37  0.38\n    \\end{bmatrix}\n    $$\n\n- 用例2（陡坡，太阳高度极低，预计有大量阴影）：\n  - 太阳方位角 $\\phi = 270^\\circ$，太阳高度角 $\\theta_e = 5^\\circ$。\n  - DEM 为一个 $5\\times 5$ 的高程网格，单位为米：\n    $$\n    \\begin{bmatrix}\n    120  118  116  114  112 \\\\\n    122  120  118  116  114 \\\\\n    124  122  120  118  116 \\\\\n    126  124  122  120  118 \\\\\n    128  126  124  122  120\n    \\end{bmatrix}\n    $$\n  - 火前 NIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.60  0.58  0.56  0.54  0.52 \\\\\n    0.61  0.59  0.57  0.55  0.53 \\\\\n    0.62  0.60  0.58  0.56  0.54 \\\\\n    0.63  0.61  0.59  0.57  0.55 \\\\\n    0.64  0.62  0.60  0.58  0.56\n    \\end{bmatrix}\n    $$\n  - 火前 SWIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.18  0.18  0.19  0.20  0.21\n    \\end{bmatrix}\n    $$\n  - 火后 NIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.40  0.38  0.36  0.34  0.32 \\\\\n    0.41  0.39  0.37  0.35  0.33 \\\\\n    0.42  0.40  0.38  0.36  0.34 \\\\\n    0.43  0.41  0.39  0.37  0.35 \\\\\n    0.44  0.42  0.40  0.38  0.36\n    \\end{bmatrix}\n    $$\n  - 火后 SWIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.32  0.33  0.34  0.35  0.36 \\\\\n    0.33  0.34  0.35  0.36  0.37 \\\\\n    0.34  0.35  0.36  0.37  0.38 \\\\\n    0.35  0.36  0.37  0.38  0.39 \\\\\n    0.36  0.37  0.38  0.39  0.40\n    \\end{bmatrix}\n    $$\n\n- 用例3（平坦地形，太阳高度角高，预计阴影最少）：\n  - 太阳方位角 $\\phi = 0^\\circ$，太阳高度角 $\\theta_e = 80^\\circ$。\n  - DEM 为一个 $5\\times 5$ 的高程网格，单位为米：\n    $$\n    \\begin{bmatrix}\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100\n    \\end{bmatrix}\n    $$\n  - 火前 NIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55\n    \\end{bmatrix}\n    $$\n  - 火前 SWIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20\n    \\end{bmatrix}\n    $$\n  - 火后 NIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35\n    \\end{bmatrix}\n    $$\n  - 火后 SWIR 反射率：\n    $$\n    \\begin{bmatrix}\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33\n    \\end{bmatrix}\n    $$\n\n要求的输出和格式：\n\n对于三个用例中的每一个，计算并返回一个三元组值：\n\n- 阴影像素的比例，以 $[0,1]$ 范围的小数表示。\n- 根据未校正的火后反射率计算的 $\\mathrm{dNBR}$ 空间平均值，以浮点数表示。\n- 根据地形校正后的火后反射率计算的 $\\mathrm{dNBR}$ 空间平均值，以浮点数表示。\n\n您的程序应生成单行输出，其中包含九个结果（每个用例三个，按用例1、用例2、用例3的顺序排列），形式为用逗号分隔并用方括号括起来的列表，例如 $[\\text{结果}_1,\\text{结果}_2,\\dots,\\text{结果}_9]$。",
            "solution": "用户提供了一个在遥感和地貌分析领域定义明确的问题。任务是模拟地形阴影并评估其对一种常用光谱指数——增量归一化燃烧指数（dNBR）的影响，该指数用于量化野火燃烧严重程度。该问题科学上合理、内部一致，并包含所有必要的数据和物理公式，以推进一个唯一且可验证的解决方案。\n\n解决方案将通过实施一系列基于物理的计算步骤来开发：\n1.  **几何设置**：我们首先将建立几何框架。这包括根据给定的太阳方位角和高度角定义太阳方向向量，并从数字高程模型（DEM）计算地形表面法向量。\n2.  **阴影建模**：然后我们将构建一个二元阴影掩膜。这涉及两种不同的物理机制：\n    *   **自阴影**：如果局部表面法线背离太阳，则表面元素处于自阴影中。这通过检查表面法向量和太阳方向向量的点积是否为非正值来确定。\n    *   **投射阴影**：如果朝向太阳的视线被中间的高地阻挡，则表面元素处于投射阴影中。这通过从感兴趣的像素向太阳方向追踪光线，并检查沿此光线遇到的最大地形地平线角是否超过太阳的高度角来确定。\n3.  **光谱指数计算（未校正）**：我们将使用提供的反射率数据计算火前和火后的归一化燃烧指数（NBR）。然后，变化量 dNBR 被计算为火前 NBR 与火后 NBR 之间的差值。\n4.  **地形校正**：为了减轻阴影对反射率的偏置效应，将对火后反射率数据应用一阶余弦校正。此方法通过局部太阳光照角重新调整观测到的反射率。\n5.  **光谱指数计算（已校正）**：使用经过地形校正的火后反射率重新计算 NBR 和 dNBR。\n6.  **分析**：最后，对于每个测试用例，我们将报告阴影像素的总比例、校正前的平均 dNBR 和校正后的平均 dNBR。这将展示地形校正的定量影响。\n\n每个步骤的实现细节如下：\n\n**步骤 1：地形和太阳几何**\n\n*   **坐标系**：我们在右手笛卡尔坐标系中操作，其中 $x$ 轴指向东，$y$ 轴指向北，$z$ 轴指向上。带有索引 `(row, col)` 的输入 DEM 矩阵映射到该系统，使得增加的列索引对应于增加的 $x$（东），而增加的行索引对应于减少的 $y$（南）。\n*   **太阳向量 ($\\mathbf{s}$)**: 太阳方位角 $\\phi$（从北向顺时针）和高度角 $\\theta_e$ 被转换为指向太阳的单位向量 $\\mathbf{s}$。太阳天顶角为 $\\theta_z = 90^\\circ - \\theta_e$。在我们的坐标系中，$\\mathbf{s}$ 的分量是：\n    $$\n    s_x = \\sin(\\theta_z) \\sin(\\phi) \\\\\n    s_y = \\sin(\\theta_z) \\cos(\\phi) \\\\\n    s_z = \\cos(\\theta_z)\n    $$\n*   **表面法向量 ($\\mathbf{n}$)**: 高程表面的偏导数 $\\frac{\\partial z}{\\partial x}$ 和 $\\frac{\\partial z}{\\partial y}$ 使用二阶中心有限差分方案进行近似，如 `numpy.gradient` 所实现。考虑到我们的网格方向，其中行索引与 $y$ 方向反平行，我们有 $\\frac{\\partial z}{\\partial y} = -\\frac{\\partial z}{\\partial(\\text{row} \\cdot \\Delta)}$。未归一化的法向量是 $\\mathbf{n}' = (-\\frac{\\partial z}{\\partial x}, -\\frac{\\partial z}{\\partial y}, 1)$，然后对每个像素归一化为单位长度。\n\n**步骤 2：阴影掩膜构建**\n\n*   **自阴影掩膜**：局部太阳入射角的余弦计算为 $\\cos i = \\mathbf{n} \\cdot \\mathbf{s}$。$\\cos i \\le 0$ 的像素被标记为自阴影。\n*   **投射阴影掩膜**：对于每个具有初始高程 $z_0$ 的像素 $(r,c)$，我们在 DEM 上沿上太阳方向追踪一条光线。上太阳方向的地面投影方向是 $( -s_x, -s_y )$。我们使用双线性插值（`scipy.ndimage.map_coordinates`）沿此光线在距离 $d$ 处采样高程 $z(d)$。对于光线上的每个点，计算地平线角 $\\alpha(d) = \\arctan\\left( \\frac{z(d) - z_0}{d} \\right)$。如果找到的最大地平线角 $\\alpha_{\\max}$ 大于太阳高度角 $\\theta_e$，则像素 $(r,c)$ 处于投射阴影中。\n*   **最终阴影掩膜**：最终阴影掩膜是自阴影掩膜和投射阴影掩膜的逻辑或。阴影比例是此布尔掩膜的平均值。\n\n**步骤 3 和 4：NBR 计算和地形校正**\n\n*   **NBR 和 dNBR**：这些指数使用其标准定义计算：\n    $$ \\mathrm{NBR} = \\frac{\\mathrm{NIR} - \\mathrm{SWIR}}{\\mathrm{NIR} + \\mathrm{SWIR}}, \\quad \\mathrm{dNBR} = \\mathrm{NBR}_{\\text{pre}} - \\mathrm{NBR}_{\\text{post}} $$\n    当 $\\mathrm{NIR} + \\mathrm{SWIR} = 0$ 时，像素的 NBR 结果未定义（`NaN`），在计算平均值时将被忽略。\n*   **余弦校正**：火后反射率 ($R$) 使用以下公式进行校正：\n    $$ R_{\\text{corr}} = R \\cdot \\frac{\\overline{\\cos i}}{\\cos i} $$\n    此处，$\\overline{\\cos i}$ 是所有光照像素（$\\cos i > 0$）的 $\\cos i$ 平均值。为防止对阴影像素进行零除运算，`cos i` 值 $\\le 0$ 被替换为一个小的正常数（$\\epsilon=10^{-6}$）。由此产生的校正后反射率被裁剪到物理上有意义的范围 $[0, 1]$。\n\n**步骤 5：校正后的 dNBR 计算**\n然后使用校正后的火后 NIR 和 SWIR 反射率重新计算 NBR 和 dNBR，并找到新的平均 dNBR。整个过程将应用于问题中指定的三个测试用例。",
            "answer": "```python\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and aggregate results for all test cases.\n    \"\"\"\n\n    def calculate_nbr(nir, swir):\n        \"\"\"Computes the Normalized Burn Ratio (NBR).\"\"\"\n        numerator = nir - swir\n        denominator = nir + swir\n        # Handle division by zero by setting result to NaN\n        nbr = np.divide(numerator, denominator, out=np.full_like(numerator, np.nan, dtype=float), where=denominator != 0)\n        return nbr\n\n    def solve_single_case(dem, pre_nir, pre_swir, post_nir, post_swir, phi_deg, theta_e_deg, delta):\n        \"\"\"\n        Processes a single test case to compute shadow fraction and dNBR values.\n        \"\"\"\n        N_rows, N_cols = dem.shape\n        epsilon = 1e-6\n\n        # Step 1: Compute terrain and solar geometry\n        # Solar vector s (pointing towards the sun)\n        phi_rad = np.deg2rad(phi_deg)\n        theta_e_rad = np.deg2rad(theta_e_deg)\n        theta_z_rad = np.pi / 2.0 - theta_e_rad\n\n        s_x = np.sin(theta_z_rad) * np.sin(phi_rad)\n        s_y = np.sin(theta_z_rad) * np.cos(phi_rad)\n        s_z = np.cos(theta_z_rad)\n        \n        # Surface normal vector n\n        # np.gradient returns gradients along each axis.\n        # axis 0 (rows) corresponds to the -y (South) direction.\n        # axis 1 (cols) corresponds to the +x (East) direction.\n        grad_y_neg, grad_x = np.gradient(dem, delta)\n        dz_dx = grad_x\n        dz_dy = -grad_y_neg\n\n        nx_un = -dz_dx\n        ny_un = -dz_dy\n        nz_un = np.ones_like(dem)\n        \n        norm = np.sqrt(nx_un**2 + ny_un**2 + nz_un**2)\n        nx = nx_un / norm\n        ny = ny_un / norm\n        nz = nz_un / norm\n\n        # Step 2: Construct shadow mask\n        # Self-shadowing\n        cos_i = nx * s_x + ny * s_y + nz * s_z\n        self_shadow_mask = cos_i = 0\n\n        # Cast-shadowing\n        cast_shadow_mask = np.zeros_like(dem, dtype=bool)\n        \n        # Ray-tracing direction in pixel coordinates (col, row)\n        # up-sun direction in world coords is (-sx, -sy)\n        # map to pixel-coord direction: col maps to x, row maps to -y\n        # change in col is proportional to -sx; change in row is proportional to sy\n        ray_dir_pix = np.array([-s_x, s_y])\n        ray_norm = np.linalg.norm(ray_dir_pix)\n\n        if ray_norm > epsilon:\n            ray_dir_norm = ray_dir_pix / ray_norm\n            \n            for r in range(N_rows):\n                for c in range(N_cols):\n                    z0 = dem[r, c]\n                    max_horizon_angle = -np.pi  # rad\n                    \n                    dist_pix = 0.5  # start tracing half a pixel away\n                    while True:\n                        # Position to sample in pixel coordinates\n                        c_trace = c + dist_pix * ray_dir_norm[0]\n                        r_trace = r + dist_pix * ray_dir_norm[1]\n\n                        if not (0 = c_trace  N_cols and 0 = r_trace  N_rows):\n                            break\n                        \n                        # Use bilinear interpolation (order=1)\n                        z_trace = ndimage.map_coordinates(dem, [[r_trace], [c_trace]], order=1, cval=-np.inf)[0]\n\n                        if z_trace == -np.inf:\n                            break\n\n                        dist_world = dist_pix * delta\n                        \n                        # arctan2 handles quadrants, but dist_world is always positive\n                        horizon_angle = np.arctan2(z_trace - z0, dist_world)\n                        if horizon_angle > max_horizon_angle:\n                            max_horizon_angle = horizon_angle\n\n                        dist_pix += 0.5 # step size of half a pixel\n\n                    if np.rad2deg(max_horizon_angle) > theta_e_deg:\n                        cast_shadow_mask[r, c] = True\n        \n        shadow_mask = np.logical_or(self_shadow_mask, cast_shadow_mask)\n        shadow_fraction = np.mean(shadow_mask)\n\n        # Step 3: Compute uncorrected dNBR\n        nbr_pre = calculate_nbr(pre_nir, pre_swir)\n        nbr_post_uncorr = calculate_nbr(post_nir, post_swir)\n        dnbr_uncorr = nbr_pre - nbr_post_uncorr\n        mean_dnbr_uncorr = np.nanmean(dnbr_uncorr)\n\n        # Step 4  5: Apply correction and compute corrected dNBR\n        illuminated_mask = cos_i > 0\n        mean_cos_i = np.mean(cos_i[illuminated_mask]) if np.any(illuminated_mask) else 1.0\n\n        cos_i_corr = np.copy(cos_i)\n        cos_i_corr[cos_i = 0] = epsilon \n\n        correction_factor = mean_cos_i / cos_i_corr\n\n        post_nir_corr = np.clip(post_nir * correction_factor, 0, 1)\n        post_swir_corr = np.clip(post_swir * correction_factor, 0, 1)\n        \n        nbr_post_corr = calculate_nbr(post_nir_corr, post_swir_corr)\n        dnbr_corr = nbr_pre - nbr_post_corr\n        mean_dnbr_corr = np.nanmean(dnbr_corr)\n        \n        return shadow_fraction, mean_dnbr_uncorr, mean_dnbr_corr\n\n    # Define test cases from the problem statement\n    delta = 30.0\n    \n    test_cases = [\n        # Case 1 (moderate slopes, moderate sun)\n        {\n            \"phi_deg\": 135.0, \"theta_e_deg\": 35.0, \"delta\": delta,\n            \"dem\": np.array([\n                [100, 102, 104, 106, 108], [100, 103, 106, 109, 112], [100, 104, 108, 112, 116],\n                [100, 105, 110, 115, 120], [100, 106, 112, 118, 124]], dtype=float),\n            \"pre_nir\": np.array([\n                [0.52, 0.50, 0.48, 0.46, 0.44], [0.53, 0.51, 0.49, 0.47, 0.45], [0.54, 0.52, 0.50, 0.48, 0.46],\n                [0.55, 0.53, 0.51, 0.49, 0.47], [0.56, 0.54, 0.52, 0.50, 0.48]], dtype=float),\n            \"pre_swir\": np.array([\n                [0.22, 0.22, 0.23, 0.24, 0.25], [0.21, 0.21, 0.22, 0.23, 0.24], [0.20, 0.20, 0.21, 0.22, 0.23],\n                [0.19, 0.19, 0.20, 0.21, 0.22], [0.18, 0.18, 0.19, 0.20, 0.21]], dtype=float),\n            \"post_nir\": np.array([\n                [0.36, 0.34, 0.32, 0.30, 0.28], [0.35, 0.33, 0.31, 0.29, 0.27], [0.34, 0.32, 0.30, 0.28, 0.26],\n                [0.33, 0.31, 0.29, 0.27, 0.25], [0.32, 0.30, 0.28, 0.26, 0.24]], dtype=float),\n            \"post_swir\": np.array([\n                [0.30, 0.31, 0.32, 0.33, 0.34], [0.31, 0.32, 0.33, 0.34, 0.35], [0.32, 0.33, 0.34, 0.35, 0.36],\n                [0.33, 0.34, 0.35, 0.36, 0.37], [0.34, 0.35, 0.36, 0.37, 0.38]], dtype=float)\n        },\n        # Case 2 (steep slopes, low sun)\n        {\n            \"phi_deg\": 270.0, \"theta_e_deg\": 5.0, \"delta\": delta,\n            \"dem\": np.array([\n                [120, 118, 116, 114, 112], [122, 120, 118, 116, 114], [124, 122, 120, 118, 116],\n                [126, 124, 122, 120, 118], [128, 126, 124, 122, 120]], dtype=float),\n            \"pre_nir\": np.array([\n                [0.60, 0.58, 0.56, 0.54, 0.52], [0.61, 0.59, 0.57, 0.55, 0.53], [0.62, 0.60, 0.58, 0.56, 0.54],\n                [0.63, 0.61, 0.59, 0.57, 0.55], [0.64, 0.62, 0.60, 0.58, 0.56]], dtype=float),\n            \"pre_swir\": np.array([\n                [0.20, 0.20, 0.21, 0.22, 0.23], [0.20, 0.20, 0.21, 0.22, 0.23], [0.19, 0.19, 0.20, 0.21, 0.22],\n                [0.19, 0.19, 0.20, 0.21, 0.22], [0.18, 0.18, 0.19, 0.20, 0.21]], dtype=float),\n            \"post_nir\": np.array([\n                [0.40, 0.38, 0.36, 0.34, 0.32], [0.41, 0.39, 0.37, 0.35, 0.33], [0.42, 0.40, 0.38, 0.36, 0.34],\n                [0.43, 0.41, 0.39, 0.37, 0.35], [0.44, 0.42, 0.40, 0.38, 0.36]], dtype=float),\n            \"post_swir\": np.array([\n                [0.32, 0.33, 0.34, 0.35, 0.36], [0.33, 0.34, 0.35, 0.36, 0.37], [0.34, 0.35, 0.36, 0.37, 0.38],\n                [0.35, 0.36, 0.37, 0.38, 0.39], [0.36, 0.37, 0.38, 0.39, 0.40]], dtype=float)\n        },\n        # Case 3 (flat terrain, high sun)\n        {\n            \"phi_deg\": 0.0, \"theta_e_deg\": 80.0, \"delta\": delta,\n            \"dem\": np.full((5, 5), 100.0),\n            \"pre_nir\": np.full((5, 5), 0.55),\n            \"pre_swir\": np.full((5, 5), 0.20),\n            \"post_nir\": np.full((5, 5), 0.35),\n            \"post_swir\": np.full((5, 5), 0.33),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack dictionary to function arguments\n        case_results = solve_single_case(**case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}