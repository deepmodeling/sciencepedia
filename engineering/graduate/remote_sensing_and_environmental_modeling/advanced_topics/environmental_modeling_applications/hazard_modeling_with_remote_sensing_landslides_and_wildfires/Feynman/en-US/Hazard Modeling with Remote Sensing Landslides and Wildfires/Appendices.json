{
    "hands_on_practices": [
        {
            "introduction": "Before we can model hazards, we must first understand the fundamental capabilities and limitations of our remote sensing instruments. This exercise grounds our work in the physical reality of satellite imaging by connecting core sensor specifications—altitude, field of view, and detector size—to the resolution on the ground. By deriving and calculating the Ground Sampling Distance (GSD), you will develop a crucial skill for assessing whether a sensor is suitable for a specific task, such as mapping landslides of a certain minimum size .",
            "id": "3819344",
            "problem": "A nadir-viewing optical frame sensor onboard a satellite is used to map landslides over mountainous terrain. Assume locally flat terrain at the observation point, negligible lens distortion, and square detector pixels so that the ground projection at nadir is square. The platform flies at a constant altitude above ground of $H = 700{,}000\\,\\mathrm{m}$. The sensor has a full horizontal field of view of $\\Phi_{x} = 15^{\\circ}$ and a square detector array with $N_{x} = 6000$ pixels along the horizontal (cross-track) direction and $N_{y} = 6000$ pixels along the vertical (along-track) direction. Angles are specified in degrees.\n\nStarting from the pinhole camera model and basic trigonometric relations, derive the ground sampling distance (GSD) at nadir in the horizontal direction from $H$, $\\Phi_{x}$, and $N_{x}$. Then, adopting a conservative minimum mapping unit standard for polygonal features in operational remote sensing whereby a landslide must occupy at least a $3 \\times 3$ contiguous pixel cluster to be reliably delineated, compute the minimal mappable landslide area in square meters.\n\nExpress your final area in $\\mathrm{m^2}$ and round your answer to four significant figures. The final numerical answer must be a single number.",
            "solution": "The problem requires the derivation of the ground sampling distance (GSD) at nadir for a satellite-borne optical sensor and the subsequent calculation of the minimal mappable landslide area based on a specified criterion. The problem is well-posed and scientifically grounded. We will proceed by first deriving the required formula using the pinhole camera model and then computing the numerical result.\n\nLet $H$ be the constant altitude of the satellite above the ground. Let $\\Phi_{x}$ be the full horizontal field of view of the sensor, and $N_{x}$ be the number of detector pixels in the corresponding horizontal direction (cross-track). We assume the terrain is locally flat at the point of observation.\n\nAccording to the pinhole camera model, the sensor at altitude $H$ observes a total ground swath width, which we denote as $W_x$. A right-angled triangle is formed by the sensor, the nadir point on the ground, and one edge of the swath. The angle at the sensor between the nadir line and the line of sight to the edge of the swath is half of the full field of view, i.e., $\\frac{\\Phi_{x}}{2}$. The side opposite to this angle is the half-swath width on the ground, $\\frac{W_x}{2}$. The side adjacent to the angle is the altitude $H$.\n\nFrom basic trigonometric relations, we can write:\n$$\n\\tan\\left(\\frac{\\Phi_{x}}{2}\\right) = \\frac{\\frac{W_x}{2}}{H}\n$$\nSolving for the total swath width $W_x$, we get:\n$$\nW_x = 2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)\n$$\nThe Ground Sampling Distance (GSD) is the dimension of the ground area covered by a single detector pixel. For the nadir-viewing case, we can find the GSD in the horizontal direction, $GSD_x$, by dividing the total swath width $W_x$ by the number of pixels $N_x$ along that direction.\n$$\nGSD_x = \\frac{W_x}{N_x}\n$$\nSubstituting the expression for $W_x$, we arrive at the derived formula for the GSD at nadir in terms of the given parameters:\n$$\nGSD_x = \\frac{2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)}{N_{x}}\n$$\nThis completes the derivation part of the problem.\n\nNext, we are asked to compute the minimal mappable landslide area. The problem specifies that a landslide must occupy at least a $3 \\times 3$ contiguous pixel cluster to be reliably delineated. The problem also states that the ground projection at nadir is square, which implies that the GSD is the same in both the horizontal (cross-track) and vertical (along-track) directions. Let's denote this common GSD as $GSD = GSD_x$. The area of the ground projection of a single pixel is therefore $A_{\\text{pixel}} = GSD^2$.\n\nThe minimal mappable area, $A_{\\min}$, corresponds to the area of a $3 \\times 3$ pixel cluster. This cluster consists of $3 \\times 3 = 9$ pixels. Therefore, the minimal area is:\n$$\nA_{\\min} = 9 \\times A_{\\text{pixel}} = 9 \\times GSD^2\n$$\nSubstituting the derived expression for $GSD = GSD_x$:\n$$\nA_{\\min} = 9 \\left( \\frac{2 H \\tan\\left(\\frac{\\Phi_{x}}{2}\\right)}{N_{x}} \\right)^2\n$$\nNow we substitute the given numerical values:\n- Altitude: $H = 700000\\,\\mathrm{m}$\n- Full horizontal field of view: $\\Phi_{x} = 15^{\\circ}$\n- Number of horizontal pixels: $N_{x} = 6000$\n\nFirst, let's calculate the value of the GSD:\n$$\nGSD = \\frac{2 \\times 700000 \\times \\tan\\left(\\frac{15^{\\circ}}{2}\\right)}{6000} = \\frac{1400000 \\times \\tan(7.5^{\\circ})}{6000} = \\frac{700}{3} \\tan(7.5^{\\circ})\n$$\nNow, we calculate the minimal mappable area, $A_{\\min}$:\n$$\nA_{\\min} = 9 \\times \\left( \\frac{700}{3} \\tan(7.5^{\\circ}) \\right)^2\n$$\n$$\nA_{\\min} = 9 \\times \\frac{700^2}{3^2} \\times (\\tan(7.5^{\\circ}))^2\n$$\n$$\nA_{\\min} = 9 \\times \\frac{490000}{9} \\times (\\tan(7.5^{\\circ}))^2\n$$\n$$\nA_{\\min} = 490000 \\times (\\tan(7.5^{\\circ}))^2\n$$\nUsing a calculator for the value of $\\tan(7.5^{\\circ})$:\n$$\n\\tan(7.5^{\\circ}) \\approx 0.13165249758\n$$\n$$\n(\\tan(7.5^{\\circ}))^2 \\approx 0.01733238622\n$$\nSubstituting this value back into the expression for $A_{\\min}$:\n$$\nA_{\\min} \\approx 490000 \\times 0.01733238622 \\approx 8492.869248\\,\\mathrm{m^2}\n$$\nThe problem requires the final answer to be rounded to four significant figures. The calculated value is $8492.869248$. The fifth significant digit is $8$, so we round up the fourth digit.\n$$\nA_{\\min} \\approx 8493\\,\\mathrm{m^2}\n$$",
            "answer": "$$\\boxed{8493}$$"
        },
        {
            "introduction": "While optical sensors provide intuitive, photo-like images, Synthetic Aperture Radar (SAR) offers the powerful ability to see through clouds and darkness, making it invaluable for rapid hazard response. However, SAR's side-looking imaging geometry introduces unique and often dramatic geometric distortions that can be misinterpreted as ground features. This practice challenges you to master the concepts of foreshortening, layover, and radar shadow, learning to identify the specific terrain configurations that cause them . A firm grasp of these geometric effects is non-negotiable for correctly interpreting SAR data in mountainous hazard-prone environments.",
            "id": "3819345",
            "problem": "A mountain watershed recently affected by a severe wildfire is being monitored for post-fire landslide hazard using Synthetic Aperture Radar (SAR). The SAR platform acquires a strip with incidence angle $\\theta_i = 35^{\\circ}$ (measured relative to the local vertical on flat terrain) and looks from east toward west. Consider five contiguous terrain segments aligned approximately along the SAR range direction (that is, their steepest descent/ascent directions are either toward, away from, or perpendicular to the radar look):\n\n- Segment $S1$: a burned hillslope with slope angle $\\alpha_1 = 20^{\\circ}$ with aspect $90^{\\circ}$ (facing east, thus toward the radar).\n- Segment $S2$: a fresh landslide headscarp with slope angle $\\alpha_2 = 40^{\\circ}$ with aspect $90^{\\circ}$ (toward the radar).\n- Segment $S3$: a burned backslope with slope angle $\\alpha_3 = 20^{\\circ}$ with aspect $270^{\\circ}$ (facing west, thus away from the radar).\n- Segment $S4$: a rocky cliff with slope angle $\\alpha_4 = 60^{\\circ}$ with aspect $270^{\\circ}$ (away from the radar).\n- Segment $S5$: a spur ridge with slope angle $\\alpha_5 = 30^{\\circ}$ with aspect $0^{\\circ}$ (facing north, approximately perpendicular to the radar look).\n\nAssume a two-dimensional vertical cross-section in the radar look plane for the purpose of geometric reasoning and that the local slope component relevant to range distortions is the projection of the slope onto the radar look direction. Ignore vegetation scattering changes from the wildfire; focus only on geometric distortions in range.\n\nWhich option correctly defines layover, foreshortening, and shadow in SAR imaging in terms of local incidence and slope geometry, and correctly identifies which of the five segments exhibit each distortion under the stated acquisition?\n\nA. Layover is when returns from higher points arrive earlier than returns from lower points along the radar line-of-sight due to reversal of range order; it occurs when the along-look slope component exceeds the incidence angle, i.e., $\\alpha_{\\parallel} > \\theta_i$. Foreshortening is when the slope faces the radar but the range order is preserved while distances in slant range are compressed; it occurs for $0  \\alpha_{\\parallel}  \\theta_i$. Shadow is the absence of returns because the radar beam does not illuminate the surface (local incidence $\\theta_{\\mathrm{loc}} \\ge 90^{\\circ}$), which for away-facing slopes occurs when $\\alpha_{\\parallel} > 90^{\\circ} - \\theta_i$. Under these conditions: $S2$ exhibits layover, $S1$ exhibits foreshortening, $S4$ is in radar shadow, $S3$ exhibits neither layover nor shadow, and $S5$ has negligible range distortion because $\\alpha_{\\parallel} \\approx 0$.\n\nB. Layover occurs whenever the slope angle is greater than $90^{\\circ} - \\theta_i$ regardless of slope aspect; foreshortening occurs only on away-facing slopes with $\\alpha_{\\parallel}  \\theta_i$; shadow occurs when $\\alpha_{\\parallel}  \\theta_i$ on toward-facing slopes. Under these conditions: $S1$ is undistorted, $S2$ is shadowed, $S3$ is foreshortened, $S4$ is undistorted, and $S5$ is layover.\n\nC. Layover is defined by $\\alpha_{\\parallel} = 0$ (perpendicular aspect) because the radar cannot resolve elevation changes then; foreshortening requires $\\alpha_{\\parallel} > 90^{\\circ}$; shadow happens when $\\alpha_{\\parallel}  0$. Under these conditions: $S5$ is layover, $S1$ is shadow, $S2$ is foreshortened, $S3$ is shadow, and $S4$ is foreshortened.\n\nD. Layover is when $\\alpha_{\\parallel}  \\theta_i$ on toward-facing slopes; foreshortening requires $\\alpha_{\\parallel} > \\theta_i$ on away-facing slopes; shadow occurs for any slope $\\alpha_{\\parallel} > \\theta_i$ regardless of aspect. Under these conditions: $S1$ is layover, $S2$ is foreshortened, $S3$ is shadow, $S4$ is shadow, and $S5$ is undistorted.\n\nSelect the single best option.",
            "solution": "The problem is well-posed and tests the core understanding of geometric distortions in side-looking airborne radar (SAR) imagery, a critical skill for interpreting SAR data in non-flat terrain. The solution requires a correct definition of foreshortening, layover, and radar shadow, and the application of these definitions to the five specified terrain segments.\n\n**1. Definitions of SAR Geometric Distortions**\n\nLet's first define the key geometric distortions in terms of the radar incidence angle, $\\theta_i$, and the component of the local terrain slope in the radar's range direction, $\\alpha_{\\parallel}$. The slope is considered positive for both toward-facing and away-facing slopes.\n\n-   **Foreshortening**: This occurs on slopes facing the radar (toward-facing slopes) where the slope angle is less than the incidence angle ($0  \\alpha_{\\parallel}  \\theta_i$). The ground range distance of the slope appears compressed in the slant-range image because the top of the slope is only slightly farther from the sensor than the bottom. The range order (bottom of slope imaged before top of slope) is preserved.\n\n-   **Layover**: This is an extreme form of foreshortening that occurs on steep toward-facing slopes where the slope angle is greater than the incidence angle ($\\alpha_{\\parallel} > \\theta_i$). In this case, the top of the slope is physically closer to the sensor in slant range than the bottom. Consequently, the radar returns from the top of the slope arrive *before* the returns from the bottom, causing a reversal of the terrain's topography in the image.\n\n-   **Shadow**: This occurs on slopes facing away from the radar (away-facing slopes) that are so steep that the radar beam cannot illuminate them. The condition for shadow is that the local incidence angle exceeds $90^{\\circ}$. For an away-facing slope, the local incidence angle is $\\theta_{\\text{loc}} = \\theta_i + \\alpha_{\\parallel}$. The back side of the slope is shadowed if it is steeper than the look angle from horizontal, which translates to the condition $\\alpha_{\\parallel} > 90^{\\circ} - \\theta_i$.\n\n-   **No Distortion**: For slopes oriented perpendicular to the look direction ($\\alpha_{\\parallel} \\approx 0$), there is no significant range distortion, although radiometric effects (brightness changes) will still occur. For gentle away-facing slopes that do not meet the shadow condition, the ground range is simply elongated in the image.\n\n**2. Application to the Terrain Segments**\n\nThe SAR has an incidence angle of $\\theta_i = 35^{\\circ}$ and looks from East to West.\n\n-   **Segment S1**: This is a toward-facing slope (aspect $90^{\\circ}$) with a slope angle $\\alpha_1 = 20^{\\circ}$. The slope component in the range direction is $\\alpha_{\\parallel} = 20^{\\circ}$. Since $0  20^{\\circ}  35^{\\circ}$ ($0  \\alpha_1  \\theta_i$), this segment will exhibit **foreshortening**.\n\n-   **Segment S2**: This is a toward-facing slope (aspect $90^{\\circ}$) with a slope angle $\\alpha_2 = 40^{\\circ}$. The slope component is $\\alpha_{\\parallel} = 40^{\\circ}$. Since $40^{\\circ} > 35^{\\circ}$ ($\\alpha_2 > \\theta_i$), this segment will exhibit **layover**.\n\n-   **Segment S3**: This is an away-facing slope (aspect $270^{\\circ}$) with a slope angle $\\alpha_3 = 20^{\\circ}$. The slope component is $\\alpha_{\\parallel} = 20^{\\circ}$. To check for shadow, we evaluate the condition $\\alpha_3 > 90^{\\circ} - \\theta_i$, which is $20^{\\circ} > 90^{\\circ} - 35^{\\circ} = 55^{\\circ}$. This is false. Therefore, the segment is illuminated and will exhibit elongation, but it is **neither in layover nor shadow**.\n\n-   **Segment S4**: This is an away-facing slope (aspect $270^{\\circ}$) with a slope angle $\\alpha_4 = 60^{\\circ}$. The slope component is $\\alpha_{\\parallel} = 60^{\\circ}$. We check the shadow condition: $60^{\\circ} > 90^{\\circ} - 35^{\\circ} = 55^{\\circ}$. This is true. Therefore, this segment will be in **radar shadow**.\n\n-   **Segment S5**: This is a north-facing slope. Since the radar look direction is East-West, the slope is approximately perpendicular to the range direction. Thus, $\\alpha_{\\parallel} \\approx 0^{\\circ}$. This segment will have **negligible range distortion**.\n\n**3. Conclusion**\n\nThe analysis shows that:\n- S1 exhibits foreshortening.\n- S2 exhibits layover.\n- S3 is neither in layover nor shadow.\n- S4 is in radar shadow.\n- S5 has negligible range distortion.\n\nThis set of outcomes perfectly matches the descriptions provided in option A. The definitions of layover, foreshortening, and shadow given in option A are also correct. Therefore, option A is the correct answer. The other options provide incorrect definitions or misapply them to the segments.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Moving from theory to application, we now tackle one of the most common challenges in quantitative remote sensing for hazard assessment: the influence of topography on image brightness. In mountainous terrain, the angle of the sun relative to the slope can create bright, sunlit faces and dark, shadowed ones, biasing spectral indices used to map wildfire burn severity. This coding exercise guides you through the process of building a physically-based topographic shadow model from a Digital Elevation Model (DEM), allowing you to quantify how shadows affect the Normalized Burn Ratio (NBR) and to implement a first-order correction . This practice is a key step toward developing robust, automated hazard analysis workflows.",
            "id": "3819382",
            "problem": "You are tasked with designing and implementing a complete, runnable program that constructs a topographic shadow mask for optical imagery using a Digital Elevation Model (DEM) and solar geometry, and then quantifies the implications for burn severity estimation based on spectrally derived indices. The program must compute a physically consistent topographic shadow mask that captures both self-shading and cast-shading caused by terrain, and must assess how shadows bias post-fire spectral measurements and their correction under a physically motivated model. Work entirely in a two-dimensional grid (raster) domain with a right-handed Cartesian coordinate system where the $x$-axis points to geographic east, the $y$-axis points to geographic north, and the $z$-axis points upward. Angles must be provided and used in degrees. All quantities must be expressed using the units defined here: distances in meters, angles in degrees, and reflectances as unitless decimal values.\n\nBegin from the following fundamental base:\n\n- The terrain is represented by a Digital Elevation Model (DEM) gridded surface $z(x,y)$ sampled on a regular grid with spacing $\\Delta$ where $\\Delta$ is the pixel size (assume $\\Delta$ is constant).\n- For a smooth surface, the local unit normal vector $\\mathbf{n}(x,y)$ can be derived from the partial derivatives $\\partial z / \\partial x$ and $\\partial z / \\partial y$ via $\\mathbf{n} \\propto \\left(-\\frac{\\partial z}{\\partial x}, -\\frac{\\partial z}{\\partial y}, 1\\right)$ followed by normalization.\n- Solar geometry is represented by solar elevation $\\theta_e$ (angle above the horizon) and solar azimuth $\\phi$ (angle measured clockwise from geographic north). The sun direction unit vector $\\mathbf{s}$, pointing from the surface location toward the sun, is defined by the solar zenith $\\theta_z = 90^\\circ - \\theta_e$ and azimuth $\\phi$ through the standard directional cosines consistent with the stated axis conventions.\n- The local incidence cosine is $\\cos i = \\mathbf{n} \\cdot \\mathbf{s}$. If $\\cos i \\le 0$, the surface is self-shadowed (no direct illumination).\n- Cast shadows arise when terrain blocks the line-of-sight of the sun along the solar azimuth direction. For a given pixel at elevation $z_0$ and horizontal ground-projected distance $d$ along the up-sun direction, define the horizon angle $\\alpha(d) = \\arctan\\left( \\frac{z(d) - z_0}{d} \\right)$. The pixel is in cast shadow if the maximum horizon angle $\\alpha_{\\max}$ encountered along the ray toward the sun satisfies $\\alpha_{\\max}  \\theta_e$.\n- Optical surface reflectance under direct illumination for a near-Lambertian surface scales with $\\cos i$ under the Lambert cosine law. A widely used first-order topographic correction for reflectance $R$ rescales by a factor proportional to $1/\\cos i$ with a normalization by the scene-average illumination to preserve overall brightness.\n\nUsing only these bases, implement an algorithm that:\n\n1. Computes the local terrain unit normal $\\mathbf{n}$ for every grid cell from the provided DEM using finite differences that respect the stated axis orientation and pixel spacing $\\Delta$.\n2. Constructs a binary topographic shadow mask by combining self-shadowing and cast-shadowing. For self-shadowing, use the criterion $\\cos i \\le 0$. For cast-shadowing, estimate a horizon angle by tracing along the solar azimuth direction with bilinear interpolation of the DEM to evaluate $\\alpha(d)$ and compare against $\\theta_e$.\n3. Quantifies the fraction of shadowed pixels as a decimal.\n4. Computes the Normalized Burn Ratio (NBR) for both pre-fire and post-fire conditions using Near-Infrared (NIR) and Shortwave-Infrared (SWIR) reflectances, and then computes the Delta Normalized Burn Ratio (dNBR) as pre-fire NBR minus post-fire NBR. Use the conventional definition of NBR, derived from the well-tested contrast in NIR and SWIR reflectance of vegetation and char, as $ \\mathrm{NBR} = \\frac{\\mathrm{NIR} - \\mathrm{SWIR}}{\\mathrm{NIR} + \\mathrm{SWIR}} $, and $ \\mathrm{dNBR} = \\mathrm{NBR}_{\\text{pre}} - \\mathrm{NBR}_{\\text{post}} $. If the denominator $\\mathrm{NIR} + \\mathrm{SWIR}$ equals zero, treat the result as undefined for that pixel.\n5. Applies a cosine-based topographic correction to the post-fire reflectances using $\\cos i$ such that $R_{\\text{corr}} = R \\cdot \\frac{\\overline{\\cos i}}{\\cos i}$, where $\\overline{\\cos i}$ is the mean $\\cos i$ over all illuminated pixels with $\\cos i  0$, and then recomputes NBR and dNBR. To avoid unphysical scaling, constrain corrected reflectances to the closed interval $[0,1]$ and replace $\\cos i \\le 0$ by a small positive constant to avoid division by zero. This represents the first-order implication that terrain-induced shading reduces observed reflectance and can inflate estimated burn severity; the correction seeks to mitigate this bias.\n\nTest Suite Specification:\n\nImplement the algorithm for three test cases that collectively exercise typical conditions, boundary behavior, and an edge case. For all cases, the pixel size is $\\Delta = 30\\ \\text{m}$.\n\n- Case $1$ (moderate slopes, moderate sun):\n  - Solar azimuth $\\phi = 135^\\circ$, solar elevation $\\theta_e = 35^\\circ$.\n  - DEM as a $5\\times 5$ grid of elevations in meters:\n    $$\n    \\begin{bmatrix}\n    100  102  104  106  108 \\\\\n    100  103  106  109  112 \\\\\n    100  104  108  112  116 \\\\\n    100  105  110  115  120 \\\\\n    100  106  112  118  124\n    \\end{bmatrix}\n    $$\n  - Pre-fire NIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.52  0.50  0.48  0.46  0.44 \\\\\n    0.53  0.51  0.49  0.47  0.45 \\\\\n    0.54  0.52  0.50  0.48  0.46 \\\\\n    0.55  0.53  0.51  0.49  0.47 \\\\\n    0.56  0.54  0.52  0.50  0.48\n    \\end{bmatrix}\n    $$\n  - Pre-fire SWIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.22  0.22  0.23  0.24  0.25 \\\\\n    0.21  0.21  0.22  0.23  0.24 \\\\\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.18  0.18  0.19  0.20  0.21\n    \\end{bmatrix}\n    $$\n  - Post-fire NIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.36  0.34  0.32  0.30  0.28 \\\\\n    0.35  0.33  0.31  0.29  0.27 \\\\\n    0.34  0.32  0.30  0.28  0.26 \\\\\n    0.33  0.31  0.29  0.27  0.25 \\\\\n    0.32  0.30  0.28  0.26  0.24\n    \\end{bmatrix}\n    $$\n  - Post-fire SWIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.30  0.31  0.32  0.33  0.34 \\\\\n    0.31  0.32  0.33  0.34  0.35 \\\\\n    0.32  0.33  0.34  0.35  0.36 \\\\\n    0.33  0.34  0.35  0.36  0.37 \\\\\n    0.34  0.35  0.36  0.37  0.38\n    \\end{bmatrix}\n    $$\n\n- Case $2$ (steep slopes, very low sun elevation, many shadows expected):\n  - Solar azimuth $\\phi = 270^\\circ$, solar elevation $\\theta_e = 5^\\circ$.\n  - DEM as a $5\\times 5$ grid of elevations in meters:\n    $$\n    \\begin{bmatrix}\n    120  118  116  114  112 \\\\\n    122  120  118  116  114 \\\\\n    124  122  120  118  116 \\\\\n    126  124  122  120  118 \\\\\n    128  126  124  122  120\n    \\end{bmatrix}\n    $$\n  - Pre-fire NIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.60  0.58  0.56  0.54  0.52 \\\\\n    0.61  0.59  0.57  0.55  0.53 \\\\\n    0.62  0.60  0.58  0.56  0.54 \\\\\n    0.63  0.61  0.59  0.57  0.55 \\\\\n    0.64  0.62  0.60  0.58  0.56\n    \\end{bmatrix}\n    $$\n  - Pre-fire SWIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.20  0.20  0.21  0.22  0.23 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.19  0.19  0.20  0.21  0.22 \\\\\n    0.18  0.18  0.19  0.20  0.21\n    \\end{bmatrix}\n    $$\n  - Post-fire NIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.40  0.38  0.36  0.34  0.32 \\\\\n    0.41  0.39  0.37  0.35  0.33 \\\\\n    0.42  0.40  0.38  0.36  0.34 \\\\\n    0.43  0.41  0.39  0.37  0.35 \\\\\n    0.44  0.42  0.40  0.38  0.36\n    \\end{bmatrix}\n    $$\n  - Post-fire SWIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.32  0.33  0.34  0.35  0.36 \\\\\n    0.33  0.34  0.35  0.36  0.37 \\\\\n    0.34  0.35  0.36  0.37  0.38 \\\\\n    0.35  0.36  0.37  0.38  0.39 \\\\\n    0.36  0.37  0.38  0.39  0.40\n    \\end{bmatrix}\n    $$\n\n- Case $3$ (flat terrain, high sun elevation, minimal shadows expected):\n  - Solar azimuth $\\phi = 0^\\circ$, solar elevation $\\theta_e = 80^\\circ$.\n  - DEM as a $5\\times 5$ grid of elevations in meters:\n    $$\n    \\begin{bmatrix}\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100 \\\\\n    100  100  100  100  100\n    \\end{bmatrix}\n    $$\n  - Pre-fire NIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55 \\\\\n    0.55  0.55  0.55  0.55  0.55\n    \\end{bmatrix}\n    $$\n  - Pre-fire SWIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20 \\\\\n    0.20  0.20  0.20  0.20  0.20\n    \\end{bmatrix}\n    $$\n  - Post-fire NIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35 \\\\\n    0.35  0.35  0.35  0.35  0.35\n    \\end{bmatrix}\n    $$\n  - Post-fire SWIR reflectance:\n    $$\n    \\begin{bmatrix}\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33 \\\\\n    0.33  0.33  0.33  0.33  0.33\n    \\end{bmatrix}\n    $$\n\nRequired Outputs and Format:\n\nFor each of the three cases, compute and return a triplet of values:\n\n- The fraction of shadowed pixels as a decimal in $[0,1]$.\n- The spatial mean of $\\mathrm{dNBR}$ computed from the uncorrected post-fire reflectances as a float.\n- The spatial mean of $\\mathrm{dNBR}$ computed from the topographically corrected post-fire reflectances as a float.\n\nYour program should produce a single line of output containing the nine results (three per case, ordered by Case $1$, Case $2$, Case $3$) as a comma-separated list enclosed in square brackets, for example $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_9]$.",
            "solution": "The user has provided a well-defined problem in the domain of remote sensing and geomorphological analysis. The task is to model topographic shadows and assess their impact on a common spectral index, the Delta Normalized Burn Ratio (dNBR), used for quantifying wildfire burn severity. The problem is scientifically sound, internally consistent, and contains all necessary data and physical formulations to proceed with a unique and verifiable solution.\n\nThe solution will be developed by implementing a series of physically-based computational steps:\n1.  **Geometric Setup**: We will first establish the geometric framework. This includes defining the sun direction vector from the given solar azimuth and elevation, and computing the terrain surface normal vectors from the Digital Elevation Model (DEM).\n2.  **Shadow Modeling**: We will then construct a binary shadow mask. This involves two distinct physical mechanisms:\n    *   **Self-shadowing**: A surface element is self-shadowed if the local surface normal points away from the sun. This is determined by checking if the dot product of the surface normal vector and the sun direction vector is non-positive.\n    *   **Cast-shadowing**: A surface element is in a cast shadow if the line-of-sight to the sun is blocked by intervening high terrain. This is determined by tracing a ray from the pixel of interest towards the sun and checking if the maximum topographic horizon angle encountered along this ray exceeds the sun's elevation angle.\n3.  **Spectral Index Calculation (Uncorrected)**: We will compute the Normalized Burn Ratio (NBR) for both pre- and post-fire conditions using the provided reflectance data. The change, dNBR, is then calculated as the difference between pre-fire NBR and post-fire NBR.\n4.  **Topographic Correction**: To mitigate the biasing effect of shadows on reflectance, a first-order cosine correction will be applied to the post-fire reflectance data. This method rescales the observed reflectance by the local solar illumination angle.\n5.  **Spectral Index Calculation (Corrected)**: The NBR and dNBR are recomputed using the topographically corrected post-fire reflectances.\n6.  **Analysis**: Finally, for each test case, we will report the total fraction of shadowed pixels, the mean dNBR before correction, and the mean dNBR after correction. This will demonstrate the quantitative impact of the topographic correction.\n\nThe implementation details for each step are as follows:\n\n**Step 1: Terrain and Solar Geometry**\n\n*   **Coordinate System**: We operate in a right-handed Cartesian system where the $x$-axis points East, the $y$-axis points North, and the $z$-axis points Up. The input DEM matrix with indices `(row, col)` maps to this system such that an increasing column index corresponds to increasing $x$ (East), and an increasing row index corresponds to decreasing $y$ (South).\n*   **Solar Vector ($\\mathbf{s}$)**: The solar azimuth $\\phi$ (clockwise from North) and elevation $\\theta_e$ are converted to a unit vector $\\mathbf{s}$ pointing towards the sun. The solar zenith angle is $\\theta_z = 90^\\circ - \\theta_e$. In our coordinate system, the components of $\\mathbf{s}$ are:\n    $$\n    s_x = \\sin(\\theta_z) \\sin(\\phi) \\\\\n    s_y = \\sin(\\theta_z) \\cos(\\phi) \\\\\n    s_z = \\cos(\\theta_z)\n    $$\n*   **Surface Normal Vector ($\\mathbf{n}$)**: The partial derivatives of the elevation surface, $\\frac{\\partial z}{\\partial x}$ and $\\frac{\\partial z}{\\partial y}$, are approximated using a second-order central finite difference scheme, as implemented by `numpy.gradient`. Considering our grid orientation, where the row index is anti-parallel to the $y$-direction, we have $\\frac{\\partial z}{\\partial y} = -\\frac{\\partial z}{\\partial(\\text{row} \\cdot \\Delta)}$. The unnormalized normal vector is $\\mathbf{n}' = (-\\frac{\\partial z}{\\partial x}, -\\frac{\\partial z}{\\partial y}, 1)$, which is then normalized to unit length for each pixel.\n\n**Step 2: Shadow Mask Construction**\n\n*   **Self-Shadow Mask**: The local cosine of the solar incidence angle is calculated as $\\cos i = \\mathbf{n} \\cdot \\mathbf{s}$. Pixels where $\\cos i \\le 0$ are flagged as self-shadowed.\n*   **Cast-Shadow Mask**: For each pixel $(r,c)$ with initial elevation $z_0$, we trace a ray in the up-sun direction across the DEM. The up-sun ground-projected direction is $( -s_x, -s_y )$. We sample elevations $z(d)$ at distances $d$ along this ray using bilinear interpolation (`scipy.ndimage.map_coordinates`). For each point along the ray, the horizon angle $\\alpha(d) = \\arctan\\left( \\frac{z(d) - z_0}{d} \\right)$ is computed. If the maximum horizon angle found, $\\alpha_{\\max}$, is greater than the solar elevation $\\theta_e$, the pixel $(r,c)$ is in a cast shadow.\n*   **Final Shadow Mask**: The final shadow mask is the logical OR of the self-shadow and cast-shadow masks. The shadow fraction is the mean of this boolean mask.\n\n**Step 3  4: NBR Calculation and Topographic Correction**\n\n*   **NBR and dNBR**: The indices are computed using their standard definitions:\n    $$ \\mathrm{NBR} = \\frac{\\mathrm{NIR} - \\mathrm{SWIR}}{\\mathrm{NIR} + \\mathrm{SWIR}}, \\quad \\mathrm{dNBR} = \\mathrm{NBR}_{\\text{pre}} - \\mathrm{NBR}_{\\text{post}} $$\n    Pixels where $\\mathrm{NIR} + \\mathrm{SWIR} = 0$ result in an undefined NBR (`NaN`), which are ignored when computing the mean.\n*   **Cosine Correction**: The post-fire reflectances ($R$) are corrected using the formula:\n    $$ R_{\\text{corr}} = R \\cdot \\frac{\\overline{\\cos i}}{\\cos i} $$\n    Here, $\\overline{\\cos i}$ is the mean of $\\cos i$ over all illuminated pixels ($\\cos i > 0$). To prevent division by zero for shadowed pixels, `cos i` values $\\le 0$ are replaced by a small positive constant ($\\epsilon=10^{-6}$). The resulting corrected reflectances are clipped to the physically meaningful range of $[0, 1]$.\n\n**Step 5: Corrected dNBR Calculation**\nThe NBR and dNBR are then re-calculated using the corrected post-fire NIR and SWIR reflectances, and the new mean dNBR is found. This entire procedure is applied to each of the three test cases specified in the problem.",
            "answer": "```python\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and aggregate results for all test cases.\n    \"\"\"\n\n    def calculate_nbr(nir, swir):\n        \"\"\"Computes the Normalized Burn Ratio (NBR).\"\"\"\n        numerator = nir - swir\n        denominator = nir + swir\n        # Handle division by zero by setting result to NaN\n        nbr = np.divide(numerator, denominator, out=np.full_like(numerator, np.nan, dtype=float), where=denominator != 0)\n        return nbr\n\n    def solve_single_case(dem, pre_nir, pre_swir, post_nir, post_swir, phi_deg, theta_e_deg, delta):\n        \"\"\"\n        Processes a single test case to compute shadow fraction and dNBR values.\n        \"\"\"\n        N_rows, N_cols = dem.shape\n        epsilon = 1e-6\n\n        # Step 1: Compute terrain and solar geometry\n        # Solar vector s (pointing towards the sun)\n        phi_rad = np.deg2rad(phi_deg)\n        theta_e_rad = np.deg2rad(theta_e_deg)\n        theta_z_rad = np.pi / 2.0 - theta_e_rad\n\n        s_x = np.sin(theta_z_rad) * np.sin(phi_rad)\n        s_y = np.sin(theta_z_rad) * np.cos(phi_rad)\n        s_z = np.cos(theta_z_rad)\n        \n        # Surface normal vector n\n        # np.gradient returns gradients along each axis.\n        # axis 0 (rows) corresponds to the -y (South) direction.\n        # axis 1 (cols) corresponds to the +x (East) direction.\n        grad_y_neg, grad_x = np.gradient(dem, delta)\n        dz_dx = grad_x\n        dz_dy = -grad_y_neg\n\n        nx_un = -dz_dx\n        ny_un = -dz_dy\n        nz_un = np.ones_like(dem)\n        \n        norm = np.sqrt(nx_un**2 + ny_un**2 + nz_un**2)\n        nx = nx_un / norm\n        ny = ny_un / norm\n        nz = nz_un / norm\n\n        # Step 2: Construct shadow mask\n        # Self-shadowing\n        cos_i = nx * s_x + ny * s_y + nz * s_z\n        self_shadow_mask = cos_i = 0\n\n        # Cast-shadowing\n        cast_shadow_mask = np.zeros_like(dem, dtype=bool)\n        \n        # Ray-tracing direction in pixel coordinates (col, row)\n        # up-sun direction in world coords is (-sx, -sy)\n        # map to pixel-coord direction: col maps to x, row maps to -y\n        # change in col is proportional to -sx; change in row is proportional to sy\n        ray_dir_pix = np.array([-s_x, s_y])\n        ray_norm = np.linalg.norm(ray_dir_pix)\n\n        if ray_norm  epsilon:\n            ray_dir_norm = ray_dir_pix / ray_norm\n            \n            for r in range(N_rows):\n                for c in range(N_cols):\n                    z0 = dem[r, c]\n                    max_horizon_angle = -np.pi  # rad\n                    \n                    dist_pix = 0.5  # start tracing half a pixel away\n                    while True:\n                        # Position to sample in pixel coordinates\n                        c_trace = c + dist_pix * ray_dir_norm[0]\n                        r_trace = r + dist_pix * ray_dir_norm[1]\n\n                        if not (0 = c_trace  N_cols and 0 = r_trace  N_rows):\n                            break\n                        \n                        # Use bilinear interpolation (order=1)\n                        z_trace = ndimage.map_coordinates(dem, [[r_trace], [c_trace]], order=1, cval=-np.inf)[0]\n\n                        if z_trace == -np.inf:\n                            break\n\n                        dist_world = dist_pix * delta\n                        \n                        # arctan2 handles quadrants, but dist_world is always positive\n                        horizon_angle = np.arctan2(z_trace - z0, dist_world)\n                        if horizon_angle  max_horizon_angle:\n                            max_horizon_angle = horizon_angle\n\n                        dist_pix += 0.5 # step size of half a pixel\n\n                    if np.rad2deg(max_horizon_angle)  theta_e_deg:\n                        cast_shadow_mask[r, c] = True\n        \n        shadow_mask = np.logical_or(self_shadow_mask, cast_shadow_mask)\n        shadow_fraction = np.mean(shadow_mask)\n\n        # Step 3: Compute uncorrected dNBR\n        nbr_pre = calculate_nbr(pre_nir, pre_swir)\n        nbr_post_uncorr = calculate_nbr(post_nir, post_swir)\n        dnbr_uncorr = nbr_pre - nbr_post_uncorr\n        mean_dnbr_uncorr = np.nanmean(dnbr_uncorr)\n\n        # Step 4  5: Apply correction and compute corrected dNBR\n        illuminated_mask = cos_i  0\n        mean_cos_i = np.mean(cos_i[illuminated_mask]) if np.any(illuminated_mask) else 1.0\n\n        cos_i_corr = np.copy(cos_i)\n        cos_i_corr[cos_i = 0] = epsilon \n\n        correction_factor = mean_cos_i / cos_i_corr\n\n        post_nir_corr = np.clip(post_nir * correction_factor, 0, 1)\n        post_swir_corr = np.clip(post_swir * correction_factor, 0, 1)\n        \n        nbr_post_corr = calculate_nbr(post_nir_corr, post_swir_corr)\n        dnbr_corr = nbr_pre - nbr_post_corr\n        mean_dnbr_corr = np.nanmean(dnbr_corr)\n        \n        return shadow_fraction, mean_dnbr_uncorr, mean_dnbr_corr\n\n    # Define test cases from the problem statement\n    delta = 30.0\n    \n    test_cases = [\n        # Case 1 (moderate slopes, moderate sun)\n        {\n            \"phi_deg\": 135.0, \"theta_e_deg\": 35.0, \"delta\": delta,\n            \"dem\": np.array([\n                [100, 102, 104, 106, 108], [100, 103, 106, 109, 112], [100, 104, 108, 112, 116],\n                [100, 105, 110, 115, 120], [100, 106, 112, 118, 124]], dtype=float),\n            \"pre_nir\": np.array([\n                [0.52, 0.50, 0.48, 0.46, 0.44], [0.53, 0.51, 0.49, 0.47, 0.45], [0.54, 0.52, 0.50, 0.48, 0.46],\n                [0.55, 0.53, 0.51, 0.49, 0.47], [0.56, 0.54, 0.52, 0.50, 0.48]], dtype=float),\n            \"pre_swir\": np.array([\n                [0.22, 0.22, 0.23, 0.24, 0.25], [0.21, 0.21, 0.22, 0.23, 0.24], [0.20, 0.20, 0.21, 0.22, 0.23],\n                [0.19, 0.19, 0.20, 0.21, 0.22], [0.18, 0.18, 0.19, 0.20, 0.21]], dtype=float),\n            \"post_nir\": np.array([\n                [0.36, 0.34, 0.32, 0.30, 0.28], [0.35, 0.33, 0.31, 0.29, 0.27], [0.34, 0.32, 0.30, 0.28, 0.26],\n                [0.33, 0.31, 0.29, 0.27, 0.25], [0.32, 0.30, 0.28, 0.26, 0.24]], dtype=float),\n            \"post_swir\": np.array([\n                [0.30, 0.31, 0.32, 0.33, 0.34], [0.31, 0.32, 0.33, 0.34, 0.35], [0.32, 0.33, 0.34, 0.35, 0.36],\n                [0.33, 0.34, 0.35, 0.36, 0.37], [0.34, 0.35, 0.36, 0.37, 0.38]], dtype=float)\n        },\n        # Case 2 (steep slopes, low sun)\n        {\n            \"phi_deg\": 270.0, \"theta_e_deg\": 5.0, \"delta\": delta,\n            \"dem\": np.array([\n                [120, 118, 116, 114, 112], [122, 120, 118, 116, 114], [124, 122, 120, 118, 116],\n                [126, 124, 122, 120, 118], [128, 126, 124, 122, 120]], dtype=float),\n            \"pre_nir\": np.array([\n                [0.60, 0.58, 0.56, 0.54, 0.52], [0.61, 0.59, 0.57, 0.55, 0.53], [0.62, 0.60, 0.58, 0.56, 0.54],\n                [0.63, 0.61, 0.59, 0.57, 0.55], [0.64, 0.62, 0.60, 0.58, 0.56]], dtype=float),\n            \"pre_swir\": np.array([\n                [0.20, 0.20, 0.21, 0.22, 0.23], [0.20, 0.20, 0.21, 0.22, 0.23], [0.19, 0.19, 0.20, 0.21, 0.22],\n                [0.19, 0.19, 0.20, 0.21, 0.22], [0.18, 0.18, 0.19, 0.20, 0.21]], dtype=float),\n            \"post_nir\": np.array([\n                [0.40, 0.38, 0.36, 0.34, 0.32], [0.41, 0.39, 0.37, 0.35, 0.33], [0.42, 0.40, 0.38, 0.36, 0.34],\n                [0.43, 0.41, 0.39, 0.37, 0.35], [0.44, 0.42, 0.40, 0.38, 0.36]], dtype=float),\n            \"post_swir\": np.array([\n                [0.32, 0.33, 0.34, 0.35, 0.36], [0.33, 0.34, 0.35, 0.36, 0.37], [0.34, 0.35, 0.36, 0.37, 0.38],\n                [0.35, 0.36, 0.37, 0.38, 0.39], [0.36, 0.37, 0.38, 0.39, 0.40]], dtype=float)\n        },\n        # Case 3 (flat terrain, high sun)\n        {\n            \"phi_deg\": 0.0, \"theta_e_deg\": 80.0, \"delta\": delta,\n            \"dem\": np.full((5, 5), 100.0),\n            \"pre_nir\": np.full((5, 5), 0.55),\n            \"pre_swir\": np.full((5, 5), 0.20),\n            \"post_nir\": np.full((5, 5), 0.35),\n            \"post_swir\": np.full((5, 5), 0.33),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack dictionary to function arguments\n        case_results = solve_single_case(**case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}