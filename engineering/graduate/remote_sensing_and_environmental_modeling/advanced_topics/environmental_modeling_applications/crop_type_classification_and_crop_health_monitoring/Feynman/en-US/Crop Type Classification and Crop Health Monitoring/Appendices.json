{
    "hands_on_practices": [
        {
            "introduction": "The core of crop monitoring is translating raw reflectance data into meaningful biophysical metrics, with vegetation indices being the primary tools for this task. This exercise explores the formulation and application of three key indices: the Normalized Difference Vegetation Index ($NDVI$), the Soil-Adjusted Vegetation Index ($SAVI$), and the Enhanced Vegetation Index ($EVI$). By calculating and comparing these indices for different surfaces, you will gain a practical understanding of how their mathematical construction addresses confounding factors like soil brightness and atmospheric haze, a critical skill for selecting the right tool for a specific monitoring application .",
            "id": "3803509",
            "problem": "A multispectral remote sensing campaign is conducted to monitor crop health and discriminate sparse vegetation from bare soil using normalized vegetation indices. Consider two adjacent fields observed at local solar noon under clear sky. Atmospheric correction has been applied to yield surface reflectances. Field $\\mathrm{S}$ is a sparse emerging crop canopy, and Field $\\mathrm{B}$ is bare soil. For each field, the band reflectances are measured as follows: Field $\\mathrm{S}$ has $R_{\\mathrm{NIR}}=0.42$, $R_{\\mathrm{Red}}=0.15$, $R_{\\mathrm{Blue}}=0.07$. Field $\\mathrm{B}$ has $R_{\\mathrm{NIR}}=0.30$, $R_{\\mathrm{Red}}=0.22$, $R_{\\mathrm{Blue}}=0.19$. Starting from the fundamental definition of surface reflectance as a dimensionless ratio of upwelling radiance to downwelling irradiance integrated over a spectral band, and the principle that normalized spectral contrasts suppress multiplicative illumination and sensor gain effects, derive explicit expressions for the Normalized Difference Vegetation Index (NDVI), the Soil Adjusted Vegetation Index (SAVI), and the Enhanced Vegetation Index (EVI). In your derivations, incorporate a canopy background adjustment parameter $L$ for SAVI and an aerosol resistance term for EVI that leverages the blue band. Use the standard operational constants for EVI defined in the Moderate Resolution Imaging Spectroradiometer (MODIS) literature, namely $G=2.5$, $C_{1}=6$, $C_{2}=7.5$, and $L=1$ in the EVI denominator, and take $L=0.5$ for SAVI. Then compute the NDVI, SAVI, and EVI for Fields $\\mathrm{S}$ and $\\mathrm{B}$. To assess which index best separates the sparse crop from bare soil, compute for each index the absolute inter-class difference defined as $|I_{\\mathrm{S}}-I_{\\mathrm{B}}|$, where $I_{\\mathrm{S}}$ and $I_{\\mathrm{B}}$ denote the index value for Fields $\\mathrm{S}$ and $\\mathrm{B}$, respectively. Report the maximum absolute difference across NDVI, SAVI, and EVI as a single decimal value, rounded to four significant figures. Express the final result without units.",
            "solution": "The foundational concept is that of surface reflectance, $R$, which is a dimensionless quantity representing the fraction of incident solar radiation reflected by a surface in a given spectral band. For a band centered at wavelength $\\lambda$, the reflectance $R_{\\lambda}$ is defined as the ratio of the upwelling spectral radiance, $L_{\\uparrow, \\lambda}$, to the downwelling spectral irradiance, $E_{\\downarrow, \\lambda}$. Multiplicative factors, such as illumination variations due to solar angle or atmospheric haze, and sensor gain artifacts, tend to affect reflectances in different spectral bands in a correlated manner. Vegetation indices are designed to exploit spectral contrasts while suppressing these confounding factors. Ratios, particularly normalized differences, are effective for this purpose.\n\nThe primary spectral feature of healthy, photosynthetically active vegetation is strong absorption of radiation in the red portion of the spectrum by chlorophyll and strong reflection in the near-infrared (NIR) portion due to the internal cellular structure of leaves. Bare soil, in contrast, typically exhibits a more gradual increase in reflectance from the red to the NIR. Vegetation indices are formulated to quantify this contrast.\n\n1.  **Normalized Difference Vegetation Index (NDVI)**\n    The NDVI is designed to enhance the red-NIR contrast while normalizing for illumination conditions. It is constructed as a normalized difference between the NIR and red reflectances. Taking $R_{\\mathrm{NIR}}$ and $R_{\\mathrm{Red}}$ as the reflectances in the respective bands, the NDVI is defined as:\n    $$\n    \\mathrm{NDVI} = \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{Red}}}{R_{\\mathrm{NIR}} + R_{\\mathrm{Red}}}\n    $$\n    This formulation bounds the index between $-1$ and $+1$ and mitigates the effects of multiplicative noise.\n\n2.  **Soil Adjusted Vegetation Index (SAVI)**\n    In scenes with sparse vegetation, the spectral signal is a mixture of vegetation and the underlying soil background. The NDVI can be sensitive to soil brightness, which can lead to ambiguity in interpreting NDVI values. The SAVI modifies the NDVI equation by introducing a canopy background adjustment parameter, $L$, to minimize this soil-induced variation. The parameter $L$ is a constant that depends on canopy density; a value of $L=0.5$ is commonly used for intermediate vegetation cover, as specified in the problem. The expression for SAVI is:\n    $$\n    \\mathrm{SAVI} = \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{Red}}}{R_{\\mathrm{NIR}} + R_{\\mathrm{Red}} + L} (1+L)\n    $$\n    For this problem, we use $L=0.5$.\n\n3.  **Enhanced Vegetation Index (EVI)**\n    The EVI was developed to improve upon the NDVI's sensitivity in high biomass regions (where NDVI saturates) and to further reduce both soil background and atmospheric influences. EVI incorporates the blue band reflectance, $R_{\\mathrm{Blue}}$, to correct for aerosol scattering, which affects the red band more than the NIR band. The EVI expression includes a gain factor $G$, two aerosol resistance coefficients $C_1$ and $C_2$, and a soil adjustment term $L$. The standard MODIS operational formula for EVI is:\n    $$\n    \\mathrm{EVI} = G \\times \\frac{R_{\\mathrm{NIR}} - R_{\\mathrm{Red}}}{R_{\\mathrm{NIR}} + C_1 R_{\\mathrm{Red}} - C_2 R_{\\mathrm{Blue}} + L}\n    $$\n    The problem provides the standard MODIS constants: $G=2.5$, $C_1=6$, $C_2=7.5$, and $L=1$.\n\nNow, we compute the values of these three indices for the sparse crop (Field $\\mathrm{S}$) and bare soil (Field $\\mathrm{B}$).\n\n**Given Reflectances:**\n-   Field $\\mathrm{S}$: $R_{\\mathrm{NIR,S}}=0.42$, $R_{\\mathrm{Red,S}}=0.15$, $R_{\\mathrm{Blue,S}}=0.07$.\n-   Field $\\mathrm{B}$: $R_{\\mathrm{NIR,B}}=0.30$, $R_{\\mathrm{Red,B}}=0.22$, $R_{\\mathrm{Blue,B}}=0.19$.\n\n**Calculations for Field S (Sparse Crop):**\n-   $\\mathrm{NDVI}_{\\mathrm{S}} = \\frac{0.42 - 0.15}{0.42 + 0.15} = \\frac{0.27}{0.57} \\approx 0.473684$\n-   $\\mathrm{SAVI}_{\\mathrm{S}} = \\frac{0.42 - 0.15}{0.42 + 0.15 + 0.5} (1+0.5) = \\frac{0.27}{1.07} \\times 1.5 \\approx 0.378505$\n-   $\\mathrm{EVI}_{\\mathrm{S}} = 2.5 \\times \\frac{0.42 - 0.15}{0.42 + (6 \\times 0.15) - (7.5 \\times 0.07) + 1} = 2.5 \\times \\frac{0.27}{0.42 + 0.90 - 0.525 + 1} = 2.5 \\times \\frac{0.27}{1.795} \\approx 0.376045$\n\n**Calculations for Field B (Bare Soil):**\n-   $\\mathrm{NDVI}_{\\mathrm{B}} = \\frac{0.30 - 0.22}{0.30 + 0.22} = \\frac{0.08}{0.52} \\approx 0.153846$\n-   $\\mathrm{SAVI}_{\\mathrm{B}} = \\frac{0.30 - 0.22}{0.30 + 0.22 + 0.5} (1+0.5) = \\frac{0.08}{1.02} \\times 1.5 \\approx 0.117647$\n-   $\\mathrm{EVI}_{\\mathrm{B}} = 2.5 \\times \\frac{0.30 - 0.22}{0.30 + (6 \\times 0.22) - (7.5 \\times 0.19) + 1} = 2.5 \\times \\frac{0.08}{0.30 + 1.32 - 1.425 + 1} = 2.5 \\times \\frac{0.08}{1.195} \\approx 0.167364$\n\nFinally, we compute the absolute inter-class difference, $|I_{\\mathrm{S}} - I_{\\mathrm{B}}|$, for each index to determine which provides the best separation between the two fields.\n-   $\\Delta_{\\mathrm{NDVI}} = |\\mathrm{NDVI}_{\\mathrm{S}} - \\mathrm{NDVI}_{\\mathrm{B}}| = |0.473684 - 0.153846| \\approx 0.319838$\n-   $\\Delta_{\\mathrm{SAVI}} = |\\mathrm{SAVI}_{\\mathrm{S}} - \\mathrm{SAVI}_{\\mathrm{B}}| = |0.378505 - 0.117647| \\approx 0.260858$\n-   $\\Delta_{\\mathrm{EVI}} = |\\mathrm{EVI}_{\\mathrm{S}} - \\mathrm{EVI}_{\\mathrm{B}}| = |0.376045 - 0.167364| \\approx 0.208681$\n\nComparing the three differences:\n$\\max(\\Delta_{\\mathrm{NDVI}}, \\Delta_{\\mathrm{SAVI}}, \\Delta_{\\mathrm{EVI}}) = \\max(0.319838, 0.260858, 0.208681) = 0.319838$.\nThe maximum absolute difference is provided by the NDVI. The problem asks for this value rounded to four significant figures.\n$0.319838 \\approx 0.3198$.",
            "answer": "$$\\boxed{0.3198}$$"
        },
        {
            "introduction": "The accuracy of any supervised classification model is fundamentally limited by the quality of its training data. In remote sensing, collecting ground-truth labels via field visits is a critical step, but one that has its own sources of error. This practice delves into a common source of such error: Global Positioning System (GPS) positional uncertainty, which can lead to \"label noise\" by incorrectly attributing a sample to an adjacent field. By modeling this process, you will gain vital insight into how to design robust data collection campaigns and appreciate the inherent uncertainties in reference datasets that ultimately impact classifier performance .",
            "id": "3803531",
            "problem": "A remote sensing team is building a crop type classification and crop health monitoring dataset by geotagging field observations with Global Positioning System (GPS). Labels are assigned by overlaying each GPS point on parcel polygons to inherit the crop type of the polygon containing the point. Consider a smallholder landscape approximated by a planar tiling of identical, axis-aligned square fields of side length $L$; the true observation location is uniformly distributed over the interior of a randomly chosen square. The GPS positional error is modeled as an isotropic bivariate normal random vector $E \\sim \\mathcal{N}( (0,0), \\sigma^{2} I)$, where $I$ is the identity matrix and $\\sigma$ is the one-dimensional standard deviation. A mislabeled observation is defined as one whose error-displaced point lies outside the true square and inside a neighboring square whose crop type differs from the true square. Assume the probability that a randomly encountered neighboring square has a different crop type than the true square is $f$, and that this crop-type difference is independent of the error displacement.\n\nStarting from fundamental definitions of probability and the Gaussian model for GPS error, derive an analytic expression for the expected mislabeling probability as a function of $L$, $\\sigma$, and $f$. Then evaluate this probability numerically for $L = 50\\,\\mathrm{m}$, $\\sigma = 3\\,\\mathrm{m}$, and $f = 0.75$. Express the final answer as a unitless decimal, and round your answer to four significant figures.",
            "solution": "The problem asks for the expected mislabeling probability for a geotagged field observation, accounting for GPS positional error. The solution involves integrating the probability of a labeling error over all possible true locations within a field.\n\nLet the true square field, $S_0$, be centered at the origin, so it covers the area $[-L/2, L/2] \\times [-L/2, L/2]$. The true observation location $(X_0, Y_0)$ is uniformly distributed within this square. The GPS error vector $E = (E_x, E_y)$ has independent components, each following a normal distribution $\\mathcal{N}(0, \\sigma^2)$. The measured location is $(X, Y) = (X_0, Y_0) + E$.\n\nA mislabeling event occurs if the measured point $(X, Y)$ falls outside $S_0$ and into a neighboring field with a different crop type. The probability of a neighboring field having a different crop type is $f$. We assume that the error is small enough that the displaced point lands in an immediately adjacent field, not further away. The probability of mislabeling is the product of the probability of landing outside the true square, $P_{\\text{out}}$, and the probability $f$.\n$$ P_{\\text{mislabel}} = f \\cdot P_{\\text{out}} $$\n$P_{\\text{out}}$ is the average probability of the error displacing the point outside the square, averaged over all possible true locations $(X_0, Y_0)$. This is $1 - \\bar{P}_{\\text{in}}$, where $\\bar{P}_{\\text{in}}$ is the average probability of the measured point remaining *inside* the square.\n$$ \\bar{P}_{\\text{in}} = \\mathbb{E}_{(X_0, Y_0)} [P((X_0+E_x, Y_0+E_y) \\in S_0 | X_0, Y_0)] $$\nDue to the independence of the $x$ and $y$ components of both the location and the error, this can be separated:\n$$ \\bar{P}_{\\text{in}} = \\left( \\mathbb{E}_{X_0}[P(X_0+E_x \\in [-L/2, L/2] | X_0)] \\right)^2 = (P_{1\\text{D-in}})^2 $$\nwhere $P_{1\\text{D-in}}$ is the average probability of staying within the 1D interval $[-L/2, L/2]$. This is calculated by integrating over the uniform distribution of the true position $x_0$:\n$$ P_{1\\text{D-in}} = \\frac{1}{L} \\int_{-L/2}^{L/2} P(-L/2 \\le x_0+E_x \\le L/2) \\,dx_0 $$\nThe inner probability is given by the Gaussian CDF, $\\Phi$:\n$$ P(-L/2-x_0 \\le E_x \\le L/2-x_0) = \\Phi\\left(\\frac{L/2-x_0}{\\sigma}\\right) - \\Phi\\left(\\frac{-L/2-x_0}{\\sigma}\\right) $$\nThe integral of this expression over $x_0$ yields the known result:\n$$ P_{1\\text{D-in}} = \\text{erf}\\left(\\frac{L}{\\sigma\\sqrt{2}}\\right) - \\sqrt{\\frac{2}{\\pi}} \\frac{\\sigma}{L} \\left(1 - \\exp\\left(-\\frac{L^2}{2\\sigma^2}\\right)\\right) $$\nwhere $\\text{erf}$ is the error function.\nThe total mislabeling probability is therefore:\n$$ P_{\\text{mislabel}}(L, \\sigma, f) = f \\cdot (1 - \\bar{P}_{\\text{in}}) = f \\left(1 - \\left[ \\text{erf}\\left(\\frac{L}{\\sigma\\sqrt{2}}\\right) - \\sqrt{\\frac{2}{\\pi}} \\frac{\\sigma}{L} \\left(1 - \\exp\\left(-\\frac{L^2}{2\\sigma^2}\\right)\\right) \\right]^2 \\right) $$\nNow, we evaluate this for $L = 50\\,\\mathrm{m}$, $\\sigma = 3\\,\\mathrm{m}$, and $f = 0.75$.\nThe ratio $L/\\sigma = 50/3 \\approx 16.67$. The argument of the error function, $L/(\\sigma\\sqrt{2})$, is large, so $\\text{erf}(\\cdot) \\approx 1$. The argument of the exponential, $-L^2/(2\\sigma^2)$, is large and negative, so $\\exp(\\cdot) \\approx 0$. The expression for $P_{1\\text{D-in}}$ simplifies significantly:\n$$ P_{1\\text{D-in}} \\approx 1 - \\sqrt{\\frac{2}{\\pi}} \\frac{\\sigma}{L} $$\nPlugging in the values:\n$$ P_{1\\text{D-in}} \\approx 1 - \\sqrt{\\frac{2}{\\pi}} \\frac{3}{50} \\approx 1 - 0.79788 \\times 0.06 = 1 - 0.047873 = 0.952127 $$\nThe average probability of remaining in the 2D square is:\n$$ \\bar{P}_{\\text{in}} = (P_{1\\text{D-in}})^2 \\approx (0.952127)^2 \\approx 0.906546 $$\nThe probability of the observation falling outside the true square is:\n$$ P_{\\text{out}} = 1 - \\bar{P}_{\\text{in}} \\approx 1 - 0.906546 = 0.093454 $$\nFinally, the mislabeling probability is:\n$$ P_{\\text{mislabel}} = f \\cdot P_{\\text{out}} \\approx 0.75 \\times 0.093454 \\approx 0.0700905 $$\nRounding the result to four significant figures gives $0.07009$.",
            "answer": "$$\\boxed{0.07009}$$"
        },
        {
            "introduction": "A final classification map often presents a single, \"best-guess\" label for each pixel, but this deterministic output masks a cascade of uncertainties from the entire analysis chain. This advanced practice guides you through a Monte Carlo simulation to propagate uncertainty from atmospheric correction parameters all the way to the final map's accuracy. By implementing this workflow, you will learn a powerful method for moving beyond a single accuracy number to producing a full confidence interval, providing a more honest and useful assessment of your classification product .",
            "id": "3803451",
            "problem": "You are tasked with designing and implementing a complete, runnable program that propagates uncertainties in atmospheric correction parameters through a supervised crop type classification, and reports confidence intervals on map accuracy using Monte Carlo sampling. The scenario is in optical remote sensing for agricultural monitoring.\n\nFundamental base to use:\n- The linearized radiative transfer relationship between top-of-atmosphere reflectance and surface reflectance is modeled as $\\,\\rho^{\\mathrm{TOA}}_{b} = \\rho_{b}\\,T_{b} + \\rho^{\\mathrm{path}}_{b}\\,$, where $\\,\\rho^{\\mathrm{TOA}}_{b}\\,$ is the measured top-of-atmosphere reflectance in band $\\,b\\,$, $\\,\\rho_{b}\\,$ is the desired surface reflectance in band $\\,b\\,$, $\\,T_{b}\\,$ is the downward-plus-upward atmospheric transmittance factor in band $\\,b\\,$, and $\\,\\rho^{\\mathrm{path}}_{b}\\,$ is the path reflectance contribution in band $\\,b\\,$. This relationship is a widely used and scientifically sound simplification for optical bands under moderate aerosol loads.\n- Bayes decision theory under multivariate normal class-conditional densities with a shared covariance matrix, a valid and well-tested model for linear discriminant classification in reflectance-feature space. You must use the Bayes classifier consistent with this assumption but do not assume any shortcut formulas that bypass derivation from this base.\n- Monte Carlo sampling for uncertainty propagation. Treat atmospheric parameters as random variables with given distributions. Generate independent samples, perform atmospheric correction, classify, and compute the empirical distribution of map accuracy.\n\nYour program must implement the following, starting from the above fundamental base:\n\n1. Atmospheric correction. For each Monte Carlo draw, treat the atmospheric parameters $\\,T_{R}\\,$, $\\,T_{N}\\,$, $\\,\\rho^{\\mathrm{path}}_{R}\\,$, and $\\,\\rho^{\\mathrm{path}}_{N}\\,$ as scene-wide constants drawn from specified distributions. For each pixel $\\,i\\,$ and band $\\,b \\in \\{R,N\\}\\,$, compute the corrected surface reflectance using the physically consistent inversion $\\,\\rho_{i,b} = (\\rho^{\\mathrm{TOA}}_{i,b} - \\rho^{\\mathrm{path}}_{b}) / T_{b}\\,$, and constrain $\\,\\rho_{i,b}\\,$ to the physically valid interval $\\,[0,1]\\,$ by clipping.\n2. Classification. Represent each pixel by the two-dimensional feature vector $\\,\\mathbf{x}_{i} = [\\rho_{i,R},\\,\\rho_{i,N}]^{\\top}\\,$. Assume three crop classes indexed by $\\,k \\in \\{0,1,2\\}\\,$ with class-conditional multivariate normal densities sharing a covariance matrix. Use the Bayes classifier implied by these assumptions (with class priors given below) to label each pixel in each Monte Carlo draw.\n3. Map accuracy. For each Monte Carlo draw, compute the overall accuracy $\\,\\mathrm{OA}\\,$ as the fraction of pixels whose predicted class equals the provided ground truth label. Across all draws, report the empirical $\\,0.025\\,$ and $\\,0.975\\,$ quantiles of $\\,\\mathrm{OA}\\,$ as the lower and upper bounds of a $\\,95\\,$-level confidence interval. Express accuracy values as decimals (for example, use $\\,0.92\\,$ instead of a percentage). No physical units are required for reflectance as it is a unitless fraction.\n\nUse the following fixed scene data for all test cases:\n- Number of pixels $\\,N = 12\\,$.\n- Bands: $\\,R\\,$ (red) and $\\,N\\,$ (near-infrared).\n- Measured top-of-atmosphere reflectances $\\,\\rho^{\\mathrm{TOA}}_{i,R}\\,$ for $\\,i=1,\\dots,12\\,$: $[\\,0.0938,\\,0.0902,\\,0.0965,\\,0.0920,\\,0.0749,\\,0.0722,\\,0.0767,\\,0.0740,\\,0.1091,\\,0.1127,\\,0.1073,\\,0.1109\\,]$.\n- Measured top-of-atmosphere reflectances $\\,\\rho^{\\mathrm{TOA}}_{i,N}\\,$ for $\\,i=1,\\dots,12\\,$: $[\\,0.4444,\\,0.43965,\\,0.4501,\\,0.43585,\\,0.5394,\\,0.5356,\\,0.54415,\\,0.53275,\\,0.3969,\\,0.3931,\\,0.39975,\\,0.39025\\,]$.\n- Ground truth crop class labels $\\,y_{i}\\,$ for $\\,i=1,\\dots,12\\,$: $[\\,0,\\,0,\\,0,\\,0,\\,1,\\,1,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2\\,]$.\n- Class means $\\,\\boldsymbol{\\mu}_{0} = [\\,0.08,\\,0.45\\,]^{\\top}\\,$, $\\,\\boldsymbol{\\mu}_{1} = [\\,0.06,\\,0.55\\,]^{\\top}\\,$, $\\,\\boldsymbol{\\mu}_{2} = [\\,0.10,\\,0.40\\,]^{\\top}\\,$.\n- Shared covariance matrix $\\,\\boldsymbol{\\Sigma} = \\begin{bmatrix} 0.0004 & 0.0001 \\\\ 0.0001 & 0.0016 \\end{bmatrix}\\,$. This is symmetric and positive definite.\n- Class priors $\\,\\pi_{0} = \\pi_{1} = \\pi_{2} = 1/3\\,$.\n\nMonte Carlo sampling details:\n- For each test case, draw $\\,N_{s}\\,$ independent samples of $\\,T_{R}\\,$, $\\,T_{N}\\,$, $\\,\\rho^{\\mathrm{path}}_{R}\\,$, and $\\,\\rho^{\\mathrm{path}}_{N}\\,$ from normal distributions with specified means and standard deviations, and then clip each draw to specified bounds to maintain physical plausibility. Each draw is treated as scene-wide and applied to all pixels in that draw.\n- Use the random seed $\\,42\\,$ for reproducibility.\n- Compute the empirical $\\,0.025\\,$ and $\\,0.975\\,$ quantiles of the set of $\\,\\mathrm{OA}\\,$ values.\n\nTest suite:\nProvide results for the following four parameter sets, each representing a different atmospheric scenario:\n- Case $\\,1\\,$ (moderate uncertainty, typical aerosol):\n  - $\\,T_{R}\\,$ mean $\\,0.90\\,$, standard deviation $\\,0.03\\,$.\n  - $\\,T_{N}\\,$ mean $\\,0.95\\,$, standard deviation $\\,0.02\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ mean $\\,0.02\\,$, standard deviation $\\,0.005\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ mean $\\,0.015\\,$, standard deviation $\\,0.005\\,$.\n  - Bounds: $\\,T_{R}, T_{N}\\,$ clipped to $[\\,0.70,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ clipped to $[\\,0.0,\\,0.10\\,]$.\n  - $\\,N_{s} = 5000\\,$.\n- Case $\\,2\\,$ (higher aerosol load and uncertainty):\n  - $\\,T_{R}\\,$ mean $\\,0.85\\,$, standard deviation $\\,0.07\\,$.\n  - $\\,T_{N}\\,$ mean $\\,0.92\\,$, standard deviation $\\,0.05\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ mean $\\,0.03\\,$, standard deviation $\\,0.01\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ mean $\\,0.025\\,$, standard deviation $\\,0.01\\,$.\n  - Bounds: $\\,T_{R}, T_{N}\\,$ clipped to $[\\,0.60,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ clipped to $[\\,0.0,\\,0.10\\,]$.\n  - $\\,N_{s} = 6000\\,$.\n- Case $\\,3\\,$ (low uncertainty, well-characterized atmosphere):\n  - $\\,T_{R}\\,$ mean $\\,0.90\\,$, standard deviation $\\,0.005\\,$.\n  - $\\,T_{N}\\,$ mean $\\,0.95\\,$, standard deviation $\\,0.005\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ mean $\\,0.02\\,$, standard deviation $\\,0.001\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ mean $\\,0.015\\,$, standard deviation $\\,0.001\\,$.\n  - Bounds: $\\,T_{R}, T_{N}\\,$ clipped to $[\\,0.80,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ clipped to $[\\,0.0,\\,0.05\\,]$.\n  - $\\,N_{s} = 5000\\,$.\n- Case $\\,4\\,$ (very clear atmosphere, small but nonzero path reflectance):\n  - $\\,T_{R}\\,$ mean $\\,0.98\\,$, standard deviation $\\,0.01\\,$.\n  - $\\,T_{N}\\,$ mean $\\,0.99\\,$, standard deviation $\\,0.01\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{R}\\,$ mean $\\,0.005\\,$, standard deviation $\\,0.003\\,$.\n  - $\\,\\rho^{\\mathrm{path}}_{N}\\,$ mean $\\,0.005\\,$, standard deviation $\\,0.003\\,$.\n  - Bounds: $\\,T_{R}, T_{N}\\,$ clipped to $[\\,0.85,\\,1.00\\,]$, $\\,\\rho^{\\mathrm{path}}_{R}, \\rho^{\\mathrm{path}}_{N}\\,$ clipped to $[\\,0.0,\\,0.02\\,]$.\n  - $\\,N_{s} = 4000\\,$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element should be a two-element list $[\\,\\text{lower},\\,\\text{upper}\\,]$ giving the lower and upper bounds of the empirical $\\,95\\,$-level confidence interval for $\\,\\mathrm{OA}\\,$ for the corresponding test case. For example, your output must look like $[[l_{1},u_{1}],[l_{2},u_{2}],[l_{3},u_{3}],[l_{4},u_{4}]]$ with numeric values substituted.",
            "solution": "The problem requires the implementation of a Monte Carlo simulation to propagate uncertainties from atmospheric parameters through a remote sensing analysis workflow. This workflow consists of atmospheric correction followed by supervised crop type classification. The final output is the $95\\%$ confidence interval on the overall classification accuracy. The solution is structured as a sequence of procedural steps, each grounded in established scientific principles.\n\nFirst, we establish the data and parameters provided. The scene consists of $N=12$ pixels, each with measured top-of-atmosphere reflectance $\\rho^{\\mathrm{TOA}}$ in two spectral bands: Red ($R$) and Near-Infrared ($N$). The ground truth class label $y_i$ for each pixel $i$ is known. The classification model assumes three crop classes ($k \\in \\{0,1,2\\}$) with class-conditional densities that are two-dimensional multivariate normal distributions, $p(\\mathbf{x}|C_k) \\sim \\mathcal{N}(\\boldsymbol{\\mu}_k, \\boldsymbol{\\Sigma})$, with known means $\\boldsymbol{\\mu}_k$ and a shared covariance matrix $\\boldsymbol{\\Sigma}$. The class priors $\\pi_k$ are given as equal, $\\pi_0 = \\pi_1 = \\pi_2 = 1/3$.\n\nThe overall process is as follows:\n$1$. For each of the $N_s$ Monte Carlo simulations and for each atmospheric scenario (test case), we generate random samples of the atmospheric parameters.\n$2$. In each simulation, these parameters are used to perform atmospheric correction on the $\\rho^{\\mathrm{TOA}}$ data, yielding surface reflectance $\\rho$ for all pixels.\n$3$. The resulting surface reflectance vectors are then classified using a Bayes classifier derived from the given statistical model.\n$4$. The overall accuracy ($\\mathrm{OA}$) of the classification map is computed by comparing the predicted labels to the ground truth.\n$5$. The collection of $N_s$ overall accuracy values forms an empirical distribution, from which the $0.025$ and $0.975$ quantiles are calculated to form the $95\\%$ confidence interval.\n\nA detailed, step-by-step derivation and procedural outline is provided below.\n\nStep 1: Monte Carlo Sampling of Atmospheric Parameters\nThe atmospheric parameters are transmittance ($T_R$, $T_N$) and path reflectance ($\\rho^{\\mathrm{path}}_R$, $\\rho^{\\mathrm{path}}_N$). For each test case and for each of the $N_s$ simulations, a set of these four parameters is drawn. The problem specifies that each parameter is drawn from a normal distribution with a given mean and standard deviation, and then clipped to a specified physically plausible range. For a single simulation run $s$, we generate the parameter set $\\{\\,T_{R}^{(s)}, T_{N}^{(s)}, \\rho^{\\mathrm{path},(s)}_{R}, \\rho^{\\mathrm{path},(s)}_{N}\\,\\}$. This set is constant for all pixels within that simulation run. The random number generator is seeded with $42$ for reproducibility for each test case.\n\nStep 2: Atmospheric Correction\nThe relationship between top-of-atmosphere reflectance $\\rho^{\\mathrm{TOA}}_{b}$ and surface reflectance $\\rho_{b}$ is given by the linearized model $\\rho^{\\mathrm{TOA}}_{b} = \\rho_{b}\\,T_{b} + \\rho^{\\mathrm{path}}_{b}$. To find the surface reflectance, we must invert this equation. For each simulation $s$, each pixel $i$, and each band $b \\in \\{R, N\\}$, the surface reflectance is calculated as:\n$$\n\\rho^{(s)}_{i,b} = \\frac{\\rho^{\\mathrm{TOA}}_{i,b} - \\rho^{\\mathrm{path},(s)}_{b}}{T^{(s)}_{b}}\n$$\nReflectance is a ratio of fluxes and must physically be constrained to the interval $[0, 1]$. Therefore, the computed value $\\rho^{(s)}_{i,b}$ is clipped to this range. The corrected data for each pixel $i$ in simulation $s$ forms a two-dimensional feature vector $\\mathbf{x}^{(s)}_{i} = [\\rho^{(s)}_{i,R}, \\rho^{(s)}_{i,N}]^{\\top}$.\n\nStep 3: Bayesian Classification\nThe classification of each pixel vector $\\mathbf{x}$ into one of the $K=3$ classes is performed using Bayes' decision rule, which aims to minimize the probability of misclassification. The rule is to assign the class $k$ that maximizes the posterior probability $P(C_k | \\mathbf{x})$.\n$$\n\\hat{k} = \\arg\\max_{k \\in \\{0,1,2\\}} P(C_k | \\mathbf{x})\n$$\nUsing Bayes' theorem, the posterior is $P(C_k | \\mathbf{x}) = \\frac{p(\\mathbf{x} | C_k)P(C_k)}{p(\\mathbf{x})}$, where $p(\\mathbf{x} | C_k)$ is the class-conditional probability density, $P(C_k) = \\pi_k$ is the class prior, and $p(\\mathbf{x})$ is the evidence. Since $p(\\mathbf{x})$ is the same for all classes, it can be ignored in the maximization. Maximizing the posterior is equivalent to maximizing its logarithm:\n$$\n\\hat{k} = \\arg\\max_{k} \\left( \\ln p(\\mathbf{x} | C_k) + \\ln \\pi_k \\right)\n$$\nThe problem states that the class-conditional densities are multivariate normal with a shared covariance matrix $\\boldsymbol{\\Sigma}$:\n$$\np(\\mathbf{x} | C_k) = \\frac{1}{(2\\pi)^{d/2} |\\boldsymbol{\\Sigma}|^{1/2}} \\exp\\left(-\\frac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu}_k)^\\top \\boldsymbol{\\Sigma}^{-1} (\\mathbf{x} - \\boldsymbol{\\mu}_k)\\right)\n$$\nwhere $d=2$ is the dimensionality of the feature space. Substituting this into the log-posterior expression gives the discriminant function $g_k(\\mathbf{x})$:\n$$\ng_k(\\mathbf{x}) = -\\frac{1}{2}\\ln\\left((2\\pi)^{d}|\\boldsymbol{\\Sigma}|\\right) - \\frac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu}_k)^\\top \\boldsymbol{\\Sigma}^{-1} (\\mathbf{x} - \\boldsymbol{\\mu}_k) + \\ln \\pi_k\n$$\nTerms that are constant across all classes $k$ can be dropped from the maximization. These include $-\\frac{1}{2}\\ln\\left((2\\pi)^{d}|\\boldsymbol{\\Sigma}|\\right)$. Expanding the quadratic form:\n$$\ng_k(\\mathbf{x}) = -\\frac{1}{2} \\left( \\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\mathbf{x} - 2\\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k + \\boldsymbol{\\mu}_k^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k \\right) + \\ln \\pi_k\n$$\nThe term $-\\frac{1}{2}\\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\mathbf{x}$ is also common to all classes and can be dropped. This leads to a simplified, linear discriminant function:\n$$\ng_k(\\mathbf{x}) = \\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k - \\frac{1}{2} \\boldsymbol{\\mu}_k^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k + \\ln \\pi_k\n$$\nFurthermore, the problem specifies equal priors $\\pi_k = 1/3$, so the term $\\ln \\pi_k$ is also constant and can be discarded. The final decision rule is to classify $\\mathbf{x}$ to the class $k$ that maximizes the function:\n$$\ng_k(\\mathbf{x}) = \\mathbf{x}^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k - \\frac{1}{2} \\boldsymbol{\\mu}_k^\\top\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_k\n$$\nThis function is computed for each pixel vector $\\mathbf{x}^{(s)}_{i}$ and for each class $k$, yielding the predicted label $\\hat{y}^{(s)}_{i} = \\arg\\max_k g_k(\\mathbf{x}^{(s)}_{i})$.\n\nStep 4: Overall Accuracy Calculation\nFor each Monte Carlo simulation $s$, the overall accuracy $\\mathrm{OA}^{(s)}$ is calculated as the fraction of correctly classified pixels.\n$$\n\\mathrm{OA}^{(s)} = \\frac{1}{N} \\sum_{i=1}^{N} I(\\hat{y}^{(s)}_{i} = y_i)\n$$\nwhere $N=12$ is the total number of pixels and $I(\\cdot)$ is the indicator function, which is $1$ if its argument is true and $0$ otherwise.\n\nStep 5: Confidence Interval Estimation\nAfter running all $N_s$ simulations for a given test case, we obtain a set of accuracy values $\\{\\mathrm{OA}^{(1)}, \\mathrm{OA}^{(2)}, \\dots, \\mathrm{OA}^{(N_s)}\\}$. This set represents the empirical probability distribution of the overall accuracy under the given uncertainty model for the atmospheric parameters. The $95\\%$ confidence interval is determined by finding the empirical $0.025$ and $0.975$ quantiles of this distribution. These quantiles correspond to the lower and upper bounds of the confidence interval, respectively. The entire procedure is repeated for each of the four test cases specified in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Propagates atmospheric parameter uncertainties through a remote sensing\n    classification workflow using Monte Carlo simulation to find confidence\n    intervals on overall map accuracy.\n    \"\"\"\n\n    # --- Fixed Scene Data ---\n    N_pixels = 12\n    rho_toa_r = np.array([0.0938, 0.0902, 0.0965, 0.0920, 0.0749, 0.0722, 0.0767, 0.0740, 0.1091, 0.1127, 0.1073, 0.1109])\n    rho_toa_n = np.array([0.4444, 0.43965, 0.4501, 0.43585, 0.5394, 0.5356, 0.54415, 0.53275, 0.3969, 0.3931, 0.39975, 0.39025])\n    # Shape: (N_pixels, 2) for [R, N] bands\n    rho_toa = np.stack([rho_toa_r, rho_toa_n], axis=1)\n\n    y_true = np.array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2], dtype=int)\n\n    # --- Classifier Parameters ---\n    mus = np.array([\n        [0.08, 0.45],  # Class 0\n        [0.06, 0.55],  # Class 1\n        [0.10, 0.40]   # Class 2\n    ])\n    Sigma = np.array([\n        [0.0004, 0.0001],\n        [0.0001, 0.0016]\n    ])\n    # Priors are equal, so log(pi_k) term can be dropped from discriminant.\n\n    # --- Pre-calculate parts of the linear discriminant function ---\n    # g_k(x) = x^T @ Sigma^-1 @ mu_k - 0.5 * mu_k^T @ Sigma^-1 @ mu_k\n    # Let W = mu_k @ Sigma^-1 (shape 3x2)\n    # Let W0 = -0.5 * diag(mu_k @ Sigma^-1 @ mu_k^T) (shape 3,)\n    # scores = x @ W.T + W0\n    inv_Sigma = np.linalg.inv(Sigma)\n    W = mus @ inv_Sigma  # Shape (3, 2)\n    W0 = -0.5 * np.sum((mus @ inv_Sigma) * mus, axis=1) # Shape (3,)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1\n        {'Ns': 5000,\n         'params': {\n             'T_R': {'mean': 0.90, 'std': 0.03, 'clip': [0.70, 1.00]},\n             'T_N': {'mean': 0.95, 'std': 0.02, 'clip': [0.70, 1.00]},\n             'rho_path_R': {'mean': 0.02, 'std': 0.005, 'clip': [0.0, 0.10]},\n             'rho_path_N': {'mean': 0.015, 'std': 0.005, 'clip': [0.0, 0.10]}\n         }},\n        # Case 2\n        {'Ns': 6000,\n         'params': {\n             'T_R': {'mean': 0.85, 'std': 0.07, 'clip': [0.60, 1.00]},\n             'T_N': {'mean': 0.92, 'std': 0.05, 'clip': [0.60, 1.00]},\n             'rho_path_R': {'mean': 0.03, 'std': 0.01, 'clip': [0.0, 0.10]},\n             'rho_path_N': {'mean': 0.025, 'std': 0.01, 'clip': [0.0, 0.10]}\n         }},\n        # Case 3\n        {'Ns': 5000,\n         'params': {\n             'T_R': {'mean': 0.90, 'std': 0.005, 'clip': [0.80, 1.00]},\n             'T_N': {'mean': 0.95, 'std': 0.005, 'clip': [0.80, 1.00]},\n             'rho_path_R': {'mean': 0.02, 'std': 0.001, 'clip': [0.0, 0.05]},\n             'rho_path_N': {'mean': 0.015, 'std': 0.001, 'clip': [0.0, 0.05]}\n         }},\n        # Case 4\n        {'Ns': 4000,\n         'params': {\n             'T_R': {'mean': 0.98, 'std': 0.01, 'clip': [0.85, 1.00]},\n             'T_N': {'mean': 0.99, 'std': 0.01, 'clip': [0.85, 1.00]},\n             'rho_path_R': {'mean': 0.005, 'std': 0.003, 'clip': [0.0, 0.02]},\n             'rho_path_N': {'mean': 0.005, 'std': 0.003, 'clip': [0.0, 0.02]}\n         }}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        Ns = case['Ns']\n        params = case['params']\n        \n        #\n        # For reproducibility, reset seed for each independent case\n        #\n        rng = np.random.default_rng(42)\n\n        #_ --- Step 1: Monte Carlo Sampling of Atmospheric Parameters ---\n        # Draw Ns samples for each of the 4 parameters\n        T_R_samples = rng.normal(params['T_R']['mean'], params['T_R']['std'], Ns)\n        T_N_samples = rng.normal(params['T_N']['mean'], params['T_N']['std'], Ns)\n        rho_path_R_samples = rng.normal(params['rho_path_R']['mean'], params['rho_path_R']['std'], Ns)\n        rho_path_N_samples = rng.normal(params['rho_path_N']['mean'], params['rho_path_N']['std'], Ns)\n\n        # Clip samples to physically plausible bounds\n        T_R_samples = np.clip(T_R_samples, params['T_R']['clip'][0], params['T_R']['clip'][1])\n        T_N_samples = np.clip(T_N_samples, params['T_N']['clip'][0], params['T_N']['clip'][1])\n        rho_path_R_samples = np.clip(rho_path_R_samples, params['rho_path_R']['clip'][0], params['rho_path_R']['clip'][1])\n        rho_path_N_samples = np.clip(rho_path_N_samples, params['rho_path_N']['clip'][0], params['rho_path_N']['clip'][1])\n\n        # Reshape for broadcasting: (Ns, 1, 2)\n        T_samples = np.stack([T_R_samples, T_N_samples], axis=1)[:, np.newaxis, :]\n        rho_path_samples = np.stack([rho_path_R_samples, rho_path_N_samples], axis=1)[:, np.newaxis, :]\n        \n        # --- Step 2: Atmospheric Correction (Vectorized) ---\n        # rho_toa shape (1, N_pixels, 2) for broadcasting\n        # Result rho_surf_all shape (Ns, N_pixels, 2)\n        rho_surf_all = (rho_toa[np.newaxis, :, :] - rho_path_samples) / T_samples\n        rho_surf_all = np.clip(rho_surf_all, 0.0, 1.0)\n        \n        # --- Step 3: Bayesian Classification (Vectorized) ---\n        # rho_surf_all (Ns, 12, 2) @ W.T (2, 3) -> scores_all (Ns, 12, 3)\n        # W0 (3,) is broadcast\n        scores_all = rho_surf_all @ W.T + W0\n        predicted_labels_all = np.argmax(scores_all, axis=2) # Shape (Ns, 12)\n        \n        # --- Step 4: Overall Accuracy Calculation (Vectorized) ---\n        # y_true (12,) is broadcast against predicted_labels_all (Ns, 12)\n        correct_classifications = (predicted_labels_all == y_true)\n        oa_samples = np.mean(correct_classifications, axis=1) # Shape (Ns,)\n\n        # --- Step 5: Confidence Interval Estimation ---\n        ci_bounds = np.quantile(oa_samples, [0.025, 0.975])\n        all_results.append(ci_bounds.tolist())\n\n    # Format the final output string exactly as specified\n    # e.g., \"[[l1,u1],[l2,u2]]\" with no spaces\n    print(f\"[[{all_results[0][0]},{all_results[0][1]}],[{all_results[1][0]},{all_results[1][1]}],[{all_results[2][0]},{all_results[2][1]}],[{all_results[3][0]},{all_results[3][1]}]]\")\n\nsolve()\n```"
        }
    ]
}