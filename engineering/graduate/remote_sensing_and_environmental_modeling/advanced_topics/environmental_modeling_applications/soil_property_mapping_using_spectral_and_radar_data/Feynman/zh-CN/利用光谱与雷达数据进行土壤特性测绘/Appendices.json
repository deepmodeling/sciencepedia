{
    "hands_on_practices": [
        {
            "introduction": "原始的土壤光谱数据包含了丰富的信息，但直接将其与土壤属性关联可能具有挑战性。一个关键的初始步骤是从光谱中提取特定且有意义的特征。本练习侧重于计算“波段深度”，这是一种量化吸收特征（例如由粘土矿物引起的吸收特征）的标准技术，同时对土壤整体亮度的变化具有稳健性，是定量光谱学中的一项基本技能。",
            "id": "3848675",
            "problem": "给定在多个波长位置采样的离散土壤反射光谱，以及每个光谱的一组上凸包顶点。目标是推导目标波长处的凸包连续统，并计算每种情况下该波长处的吸收带深度。您的程序必须为每个测试用例实现以下任务。\n\n基础和定义：\n- 令 $R(\\lambda)$ 表示在波长 $\\lambda$（单位：微米，$\\mu m$）处测量的土壤表面的双向反射因子（无量纲）。吸收特征表现为 $R(\\lambda)$ 相对于一个平滑、缓变的基线（称为连续统）的局部凹陷。\n- 在光谱分析中，连续统定义为点集 $\\{(\\lambda_i, R(\\lambda_i))\\}$ 在 $\\lambda$-$R$ 平面上的凸包的上边界。凸包是包含所有点的最小凸集；其上边界是一个分段线性凹包络，由连接选定的凸包顶点 $\\{(\\lambda_{h,j}, R_{h,j})\\}$ 的直线段形成。\n- 对于目标波长 $\\lambda^\\star$，连续统 $C(\\lambda^\\star)$ 通过在包含 $\\lambda^\\star$ 的凸包线段上进行线性插值得到。如果 $\\lambda^\\star$ 与某个凸包顶点重合，则该顶点的 $C(\\lambda^\\star) = R_{h,j}$。\n- 在 $\\lambda^\\star$ 处的吸收带深度定义为去除连续统的吸收度量\n$$\nBD(\\lambda^\\star) = 1 - \\frac{R(\\lambda^\\star)}{C(\\lambda^\\star)} ,\n$$\n表示为一个无单位的小数。\n\n每个测试用例的算法要求：\n1. 输入：\n   - 一个严格递增的波长列表 $\\Lambda = [\\lambda_1, \\lambda_2, \\dots, \\lambda_n]$，单位为微米 ($\\mu m$)。\n   - 一个反射率列表 $\\mathcal{R} = [R(\\lambda_1), R(\\lambda_2), \\dots, R(\\lambda_n)]$，每个值都是在 $[0,1]$ 范围内的无量纲数。\n   - 一个凸包顶点列表 $\\mathcal{H} = [(\\lambda_{h,1}, R_{h,1}), (\\lambda_{h,2}, R_{h,2}), \\dots, (\\lambda_{h,m}, R_{h,m})]$，按 $\\lambda_{h,j}$ 递增排序，这些顶点通过连续顶点之间的直线段定义了上凸包连续统。\n   - 目标波长 $\\lambda^\\star = 2.20\\,\\mu m$。\n2. 计算 $R(\\lambda^\\star)$:\n   - 如果 $\\lambda^\\star$ 正好是 $\\lambda_i$ 中的一个，则将 $R(\\lambda^\\star)$ 设为相应的反射率值。\n   - 否则，找到索引 $i$ 和 $i+1$ 使得 $\\lambda_i \\le \\lambda^\\star \\le \\lambda_{i+1}$，并进行线性插值\n   $$\n   R(\\lambda^\\star) = R(\\lambda_i) + \\left( \\frac{\\lambda^\\star - \\lambda_i}{\\lambda_{i+1} - \\lambda_i} \\right) \\left( R(\\lambda_{i+1}) - R(\\lambda_i) \\right) .\n   $$\n3. 计算 $C(\\lambda^\\star)$:\n   - 如果 $\\lambda^\\star$ 正好是 $\\lambda_{h,j}$ 中的一个，则设 $C(\\lambda^\\star) = R_{h,j}$。\n   - 否则，找到连续的凸包顶点 $(\\lambda_{h,j}, R_{h,j})$ 和 $(\\lambda_{h,j+1}, R_{h,j+1})$ 使得 $\\lambda_{h,j} \\le \\lambda^\\star \\le \\lambda_{h,j+1}$，并进行线性插值\n   $$\n   C(\\lambda^\\star) = R_{h,j} + \\left( \\frac{\\lambda^\\star - \\lambda_{h,j}}{\\lambda_{h,j+1} - \\lambda_{h,j}} \\right) \\left( R_{h,j+1} - R_{h,j} \\right) .\n   $$\n4. 使用上述公式计算 $BD(\\lambda^\\star)$。输出必须表示为小数（无百分号），无量纲。\n\n科学真实性与适用性：在 $\\lambda^\\star = 2.20\\,\\mu m$ 处的吸收带深度通常用于量化与土壤中粘土含量相关的 $Al$-$OH$ 吸收特征。凸包连续统可以稳定该测量值，使其不受大尺度反照率变化的影响。该过程是纯粹的几何和数值计算，基于插值和凸性。\n\n测试套件：\n- 第一个案例（具有显式 $\\lambda^\\star$ 样本的一般吸收特征）：\n  - $\\Lambda = [2.00, 2.10, 2.15, 2.20, 2.25, 2.30, 2.40]$，单位 $\\mu m$。\n  - $\\mathcal{R} = [0.52, 0.50, 0.48, 0.35, 0.47, 0.52, 0.55]$。\n  - $\\mathcal{H} = [(2.00, 0.52), (2.40, 0.55)]$。\n- 第二个案例（边界情况，其中 $\\lambda^\\star$ 与凸包顶点重合，产生零吸收带深度）：\n  - $\\Lambda = [2.18, 2.20, 2.22, 2.24]$，单位 $\\mu m$。\n  - $\\mathcal{R} = [0.49, 0.52, 0.51, 0.50]$。\n  - $\\mathcal{H} = [(2.18, 0.49), (2.20, 0.52), (2.24, 0.50)]$。\n- 第三个案例（具有三个样本且端点为凸包顶点的最小光谱）：\n  - $\\Lambda = [2.10, 2.20, 2.30]$，单位 $\\mu m$。\n  - $\\mathcal{R} = [0.60, 0.40, 0.62]$。\n  - $\\mathcal{H} = [(2.10, 0.60), (2.30, 0.62)]$。\n- 第四个案例（目标未采样；$R(\\lambda^\\star)$ 必须从相邻点插值得到）：\n  - $\\Lambda = [2.17, 2.19, 2.21, 2.23, 2.26, 2.30]$，单位 $\\mu m$。\n  - $\\mathcal{R} = [0.53, 0.51, 0.46, 0.49, 0.52, 0.54]$。\n  - $\\mathcal{H} = [(2.17, 0.53), (2.30, 0.54)]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的吸收带深度，形式为一个用方括号括起来的逗号分隔列表，例如 $[b_1,b_2,b_3,b_4]$，其中每个 $b_k$ 是按上述规定计算的浮点数。波长必须以 $\\mu m$ 为单位处理，吸收带深度必须作为无量纲小数返回。",
            "solution": "所述问题是有效的。它在科学上基于定量光谱学的原理，定义清晰完整，数据充分，表述客观。未发现矛盾、歧义或事实错误。该问题可以通过直接应用所提供的算法来解决。\n\n核心任务是为几个土壤反射光谱计算在指定目标波长 $\\lambda^\\star$ 处的吸收带深度，记为 $BD(\\lambda^\\star)$。吸收带深度是光谱学中用于量化吸收特征强度的标准度量。它被定义为一个去除连续统的量，通过一个连续统基线 $C(\\lambda)$ 对反射光谱进行归一化。\n\n吸收带深度的计算公式如下：\n$$\nBD(\\lambda^\\star) = 1 - \\frac{R(\\lambda^\\star)}{C(\\lambda^\\star)}\n$$\n其中 $R(\\lambda^\\star)$ 是目标波长 $\\lambda^\\star$ 处的反射率值，而 $C(\\lambda^\\star)$ 是同一波长处光谱连续统的值。因此，计算过程涉及为每个测试用例确定这两个值。\n\n**1. 确定反射率 $R(\\lambda^\\star)$**\n\n反射光谱以离散测量点集 $(\\lambda_i, R(\\lambda_i))$ 的形式提供，其中 $\\Lambda = [\\lambda_1, \\lambda_2, \\dots, \\lambda_n]$ 是一个严格递增的波长列表。目标波长指定为 $\\lambda^\\star = 2.20 \\, \\mu m$。\n\n$R(\\lambda^\\star)$ 的值按以下方式获得：\n- **情况 A：完全匹配：** 如果目标波长 $\\lambda^\\star$ 与列表 $\\Lambda$ 中的某个采样波长 $\\lambda_i$ 完全重合，则 $R(\\lambda^\\star)$ 就是对应的测量反射率值 $R(\\lambda_i)$。\n- **情况 B：插值：** 如果 $\\lambda^\\star$ 落在两个采样波长之间，即 $\\lambda_i  \\lambda^\\star  \\lambda_{i+1}$，则其反射率 $R(\\lambda^\\star)$ 通过在两个相邻点 $(\\lambda_i, R(\\lambda_i))$ 和 $(\\lambda_{i+1}, R(\\lambda_{i+1}))$ 之间进行线性插值来估算。线性插值公式为：\n$$\nR(\\lambda^\\star) = R(\\lambda_i) + \\left( \\frac{\\lambda^\\star - \\lambda_i}{\\lambda_{i+1} - \\lambda_i} \\right) \\left( R(\\lambda_{i+1}) - R(\\lambda_i) \\right)\n$$\n这假设光谱在采样点之间具有局部线性行为，这是高分辨率光谱数据的标准做法。\n\n**2. 确定连续统 $C(\\lambda^\\star)$**\n\n连续统 $C(\\lambda)$ 被定义为光谱的上包络线，由一组给定的上凸包顶点 $\\mathcal{H} = [(\\lambda_{h,1}, R_{h,1}), \\dots, (\\lambda_{h,m}, R_{h,m})]$ 构建。该包络线是连接连续顶点的分段线性函数。\n\n$C(\\lambda^\\star)$ 的值确定方式与 $R(\\lambda^\\star)$ 类似，但使用的是凸包顶点而非完整的光谱数据：\n- **情况 A：完全匹配：** 如果目标波长 $\\lambda^\\star$ 与某个凸包顶点的波长重合，即 $\\lambda^\\star = \\lambda_{h,j}$，则连续统值就是该顶点的反射率，$C(\\lambda^\\star) = R_{h,j}$。\n- **情况 B：插值：** 如果 $\\lambda^\\star$ 落在两个连续的凸包顶点之间，即 $\\lambda_{h,j}  \\lambda^\\star  \\lambda_{h,j+1}$，则连续统值 $C(\\lambda^\\star)$ 通过在这两个顶点 $(\\lambda_{h,j}, R_{h,j})$ 和 $(\\lambda_{h,j+1}, R_{h,j+1})$ 连接的线段上进行线性插值得到：\n$$\nC(\\lambda^\\star) = R_{h,j} + \\left( \\frac{\\lambda^\\star - \\lambda_{h,j}}{\\lambda_{h,j+1} - \\lambda_{h,j}} \\right) \\left( R_{h,j+1} - R_{h,j} \\right)\n$$\n此过程提供了用于测量吸收的平滑上边界参考。\n\n**3. 算法实现**\n\n对于每个测试用例，总体算法如下：\n1.  定义输入数据：波长列表 $\\Lambda$、反射率列表 $\\mathcal{R}$ 和凸包顶点列表 $\\mathcal{H}$。目标波长恒定为 $\\lambda^\\star = 2.20 \\, \\mu m$。\n2.  实现一个通用的线性插值函数，给定一个目标 $x$ 坐标和一组排序好的 $(x,y)$ 点，返回相应的 $y$ 坐标。此函数必须处理完全匹配和插值两种情况。\n3.  使用 $\\lambda^\\star$ 和光谱点集 $\\{(\\lambda_i, R(\\lambda_i))\\}$ 调用此插值函数，以计算 $R(\\lambda^\\star)$。\n4.  使用 $\\lambda^\\star$ 和凸包顶点集 $\\{(\\lambda_{h,j}, R_{h,j})\\}$ 调用相同的插值函数，以计算 $C(\\lambda^\\star)$。\n5.  使用基本公式计算吸收带深度 $BD(\\lambda^\\star)$。由于所有反射率 $R(\\lambda_i)$ 都在 $[0, 1]$ 范围内，并且凸包位于光谱之上，因此对于非零光谱，$C(\\lambda^\\star)$ 将为正，从而避免除以零。\n6.  每个案例的最终结果是计算出的 $BD(\\lambda^\\star)$ 的无量纲小数值。\n\n此过程是确定性的，并直接遵循所提供的定义，确保了基于基本几何和数值原理的正确且可验证的解决方案。",
            "answer": "```python\nimport numpy as np\n\ndef _linear_interpolate(x_target, points):\n    \"\"\"\n    Performs linear interpolation on a set of 2D points.\n\n    Args:\n        x_target (float): The x-coordinate at which to interpolate.\n        points (list of tuple/list): A list of (x, y) points, sorted by x.\n\n    Returns:\n        float: The interpolated y-value.\n    \"\"\"\n    points_arr = np.array(points)\n    x_coords = points_arr[:, 0]\n    y_coords = points_arr[:, 1]\n    \n    # Case 1: x_target is one of the existing x-coordinates\n    match_indices = np.where(x_coords == x_target)[0]\n    if len(match_indices) > 0:\n        return y_coords[match_indices[0]]\n\n    # Case 2: x_target needs interpolation.\n    # np.searchsorted finds the index where x_target would be inserted to maintain order.\n    idx = np.searchsorted(x_coords, x_target)\n\n    # The problem setup ensures x_target is always bracketed by the given points.\n    # Therefore, we do not need to handle extrapolation cases.\n    x1, y1 = points_arr[idx - 1]\n    x2, y2 = points_arr[idx]\n    \n    # Standard linear interpolation formula\n    y_target = y1 + ((x_target - x1) * (y2 - y1) / (x2 - x1))\n    \n    return y_target\n\ndef calculate_band_depth(lmbda, R, H, lambda_star):\n    \"\"\"\n    Calculates the band depth at a target wavelength.\n\n    Args:\n        lmbda (list): List of wavelengths.\n        R (list): List of reflectances.\n        H (list of tuple): List of convex hull vertices.\n        lambda_star (float): The target wavelength.\n\n    Returns:\n        float: The calculated band depth.\n    \"\"\"\n    # 1. Compute R(lambda_star) by interpolating the spectrum\n    spectrum_points = list(zip(lmbda, R))\n    R_star = _linear_interpolate(lambda_star, spectrum_points)\n\n    # 2. Compute C(lambda_star) by interpolating the hull vertices\n    C_star = _linear_interpolate(lambda_star, H)\n\n    # 3. Compute BD(lambda_star)\n    # The problem context implies C_star will not be zero.\n    if C_star == 0:\n        return np.nan # Should not be reached with the given test cases\n\n    band_depth = 1.0 - (R_star / C_star)\n    return band_depth\n\ndef solve():\n    \"\"\"\n    Solves the band depth calculation problem for the given test cases.\n    \"\"\"\n    lambda_star = 2.20\n\n    test_cases = [\n        # Case 1: General absorption feature\n        (\n            [2.00, 2.10, 2.15, 2.20, 2.25, 2.30, 2.40],\n            [0.52, 0.50, 0.48, 0.35, 0.47, 0.52, 0.55],\n            [(2.00, 0.52), (2.40, 0.55)]\n        ),\n        # Case 2: Target wavelength is a hull vertex\n        (\n            [2.18, 2.20, 2.22, 2.24],\n            [0.49, 0.52, 0.51, 0.50],\n            [(2.18, 0.49), (2.20, 0.52), (2.24, 0.50)]\n        ),\n        # Case 3: Minimal spectrum\n        (\n            [2.10, 2.20, 2.30],\n            [0.60, 0.40, 0.62],\n            [(2.10, 0.60), (2.30, 0.62)]\n        ),\n        # Case 4: Target wavelength is not sampled\n        (\n            [2.17, 2.19, 2.21, 2.23, 2.26, 2.30],\n            [0.53, 0.51, 0.46, 0.49, 0.52, 0.54],\n            [(2.17, 0.53), (2.30, 0.54)]\n        )\n    ]\n\n    results = []\n    for lmbda, R, H in test_cases:\n        bd = calculate_band_depth(lmbda, R, H, lambda_star)\n        results.append(bd)\n\n    # Format the output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从光谱和雷达数据中提取了特征指数后，下一步是建立一个能够预测目标土壤属性的模型。本练习将指导您建立一个回归模型，并且至关重要的是，使用$k$-折交叉验证来评估其泛化性能。这是一种避免模型过拟合并获得对模型真实世界准确性可靠估计的标准方法。",
            "id": "3848679",
            "problem": "您的任务是使用光谱反射率和雷达后向散射数据，验证一个用于估算土壤粘土含量的线性指数到属性回归模型。背景是联合使用多光谱光学反射率和合成孔径雷达（SAR）后向散射来推断表层土壤的粘土含量。将使用的两个指数是：一个由近红外（NIR）和短波红外（SWIR）反射率构建的光谱指数，以及一个由共极化和交叉极化后向散射构建的极化雷达比率。\n\n请使用以下基本定义和事实作为起点：\n- 由两个正反射率 $r_1$ 和 $r_2$ 构建的归一化差异指数（NDI）定义为其差值与和值的比率。该比率是无量纲的，界于 $(-1,1)$ 之间，并能降低对乘性光照因子的敏感性。\n- 带有平方误差损失的线性回归通过在仿射假设类上最小化经验风险来求解，其唯一最小化解（当设计矩阵为满列秩时）满足正规方程。\n- 均方根误差（RMSE）、平均误差（偏差）和决定系数 $R^2$ 是评估模型在留出数据上预测性能的标准、单位一致的度量指标。\n\n数据集。给定 $n = 12$ 个独立样本。每个样本 $i$ 包含：\n- 近红外（NIR）反射率 $R_{\\mathrm{NIR},i}$ （无量纲分数），\n- 短波红外（SWIR）反射率 $R_{\\mathrm{SWIR},i}$ （无量纲分数），\n- 垂直-垂直极化的雷达后向散射（线性功率） $\\sigma^{0}_{\\mathrm{VV},i}$ （无量纲，线性尺度），\n- 垂直-水平极化的雷达后向散射（线性功率） $\\sigma^{0}_{\\mathrm{VH},i}$ （无量纲，线性尺度），\n- 粘土含量质量分数 $y_i$ （在 $[0,1]$ 区间内的无量纲分数）。\n\n对 $i = 1,\\dots,12$ 使用以下值：\n- $R_{\\mathrm{NIR}} = [\\,0.30,\\,0.35,\\,0.40,\\,0.25,\\,0.32,\\,0.28,\\,0.18,\\,0.45,\\,0.22,\\,0.50,\\,0.27,\\,0.33\\,]$。\n- $R_{\\mathrm{SWIR}} = [\\,0.20,\\,0.25,\\,0.20,\\,0.10,\\,0.12,\\,0.22,\\,0.12,\\,0.30,\\,0.18,\\,0.25,\\,0.09,\\,0.28\\,]$。\n- $\\sigma^{0}_{\\mathrm{VV}} = [\\,0.20,\\,0.18,\\,0.16,\\,0.22,\\,0.14,\\,0.24,\\,0.12,\\,0.10,\\,0.26,\\,0.15,\\,0.13,\\,0.21\\,]$。\n- $\\sigma^{0}_{\\mathrm{VH}} = [\\,0.050,\\,0.045,\\,0.032,\\,0.044,\\,0.021,\\,0.060,\\,0.036,\\,0.020,\\,0.052,\\,0.045,\\,0.026,\\,0.042\\,]$。\n- $y = [\\,0.515,\\,0.523,\\,0.415,\\,0.360,\\,0.330,\\,0.550,\\,0.515,\\,0.490,\\,0.555,\\,0.445,\\,0.315,\\,0.560\\,]$。\n\n为每个样本 $i$ 定义两个指数：\n- 光谱粘土指数（SCI）：$s_i = \\dfrac{R_{\\mathrm{NIR},i} - R_{\\mathrm{SWIR},i}}{R_{\\mathrm{NIR},i} + R_{\\mathrm{SWIR},i}}$。\n- 极化比（PR）：$p_i = \\dfrac{\\sigma^{0}_{\\mathrm{VH},i}}{\\sigma^{0}_{\\mathrm{VV},i}}$。\n\n模型类别。考虑形式为 $\\hat{y} = \\beta_0 + \\beta^\\top x$ 的仿射线性回归，其中根据特征选择模式，$x$ 可以是标量 $s$、标量 $p$，或二维向量 $[\\,s,\\,p\\,]^\\top$。\n\n验证设计。按如下方式实现$k$-折交叉验证：\n- 使用固定的伪随机数生成器种子 $137$ 来构建 $\\{0,1,\\dots,n-1\\}$ 的一个随机排列 $\\pi$。将 $\\pi$ 划分成 $k$ 个连续的折，使用等大小分割（最多相差一个索引，即各折的大小最多相差一），并保持 $\\pi$ 内部的顺序。\n- 对于每一折 $f$，通过在训练子集上最小化经验均方误差，对其他 $k-1$ 折的并集进行线性回归拟合，然后在留出的折 $f$ 上进行预测。\n- 汇总所有留出预测，形成长度为 $n$ 的汇集向量 $\\hat{y}_{\\mathrm{cv}}$ 和 $y$。\n\n指标。根据第一性原理，对汇集的留出预测计算以下量：\n- RMSE（均方根误差），\n\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\dfrac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{y}_{\\mathrm{cv},i} - y_i\\right)^2}.\n$$\n\n- 偏差（平均误差），\n\n$$\n\\mathrm{bias} \\;=\\; \\dfrac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{y}_{\\mathrm{cv},i} - y_i\\right).\n$$\n\n- 决定系数，\n\n$$\nR^2 \\;=\\; 1 \\;-\\; \\dfrac{\\sum_{i=1}^{n}\\left(y_i - \\hat{y}_{\\mathrm{cv},i}\\right)^2}{\\sum_{i=1}^{n}\\left(y_i - \\bar{y}\\right)^2}, \\quad \\bar{y} \\;=\\; \\dfrac{1}{n}\\sum_{i=1}^{n} y_i.\n$$\n\n\n所有粘土含量和误差都必须作为无量纲分数处理。所有最终指标值都以小数形式报告（而非百分比）。\n\n测试套件。您的程序必须对以下参数情况执行上述操作：\n- 情况 A：$k = 3$，特征 $=$ 仅 SCI。\n- 情况 B：$k = 6$，特征 $=$ 仅 PR。\n- 情况 C：$k = 12$，特征 $=$ SCI 和 PR 联合。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每种情况应贡献一个列表 $[\\,\\mathrm{RMSE},\\,\\mathrm{bias},\\,R^2\\,]$，其中每个数字都四舍五入到恰好六位小数。因此，总体输出必须是按情况 A、情况 B、情况 C 顺序排列的三个列表的列表。例如，格式必须是\n\n$$\n[\\,[r_1,b_1,R_1],\\,[r_2,b_2,R_2],\\,[r_3,b_3,R_3]\\,],\n$$\n\n其中每个 $r_j,b_j,R_j$ 都以四舍五入到六位小数的小数形式显示。",
            "solution": "该问题陈述被认为是有效的。它在遥感领域有科学依据，在数学上是适定的、客观的，并为可复现的计算任务提供了一套完整且一致的数据和程序。\n\n目标是评估三个仿射线性回归模型，这些模型用于从派生的光谱和雷达指数估算土壤粘土含量 ($y$)。评估将使用 $k$ 折交叉验证在一个包含 $n=12$ 个样本的数据集上进行。该过程涉及特征派生、通过普通最小二乘法 (OLS) 进行模型训练、交叉验证预测，以及计算三个性能指标：均方根误差 (RMSE)、偏差 (bias) 和决定系数 ($R^2$)。\n\n首先，我们从提供的原始数据中定义并计算输入特征。对于每个样本 $i=1, \\dots, 12$，原始数据是近红外（NIR）反射率 $R_{\\mathrm{NIR},i}$、短波红外（SWIR）反射率 $R_{\\mathrm{SWIR},i}$、共极化雷达后向散射 $\\sigma^{0}_{\\mathrm{VV},i}$ 和交叉极化雷达后向散射 $\\sigma^{0}_{\\mathrm{VH},i}$。\n\n两个特征是光谱粘土指数 (SCI) $s_i$ 和极化比 (PR) $p_i$。它们的定义是：\n$$\ns_i = \\dfrac{R_{\\mathrm{NIR},i} - R_{\\mathrm{SWIR},i}}{R_{\\mathrm{NIR},i} + R_{\\mathrm{SWIR},i}}\n$$\n$$\np_i = \\dfrac{\\sigma^{0}_{\\mathrm{VH},i}}{\\sigma^{0}_{\\mathrm{VV},i}}\n$$\n为所有 $n=12$ 个样本计算这些指数，得到两个长度为 12 的向量 $\\mathbf{s}$ 和 $\\mathbf{p}$。\n\n分析的核心是 $k$-折交叉验证程序。对于给定的折数 $k$ 和指定的特征集，执行以下步骤：\n1.  使用固定的种子 $137$ 生成样本索引 $\\{0, 1, \\dots, 11\\}$ 的伪随机排列 $\\pi$，以确保可复现性。\n2.  将排列后的索引集 $\\pi$ 划分成 $k$ 个连续、不重叠的子集（折），大小几乎相等。由于 $n=12$，对于 $k=3, 6, 12$，折的大小将分别相等，为 $12/3=4$、$12/6=2$ 和 $12/12=1$。\n3.  对于每一折 $f \\in \\{1, \\dots, k\\}$，该折中索引对应的样本被指定为留出测试集。其余的 $k-1$ 折构成训练集。\n\n对于交叉验证的 $k$ 次迭代中的每一次，将一个形式为 $\\hat{y} = \\beta_0 + \\boldsymbol{\\beta}^\\top \\mathbf{x}$ 的仿射线性模型拟合到训练数据。这里，$\\mathbf{x}$ 代表特征向量，可以是一个标量（$s_i$ 或 $p_i$）或一个二维向量 $([s_i, p_i]^\\top)$。对于整个训练集，该模型可以以矩阵形式表示为 $\\mathbf{y}_{\\text{train}} \\approx \\mathbf{X}_{\\text{train}}\\boldsymbol{\\beta}_{\\text{model}}$，其中 $\\mathbf{X}_{\\text{train}}$ 是设计矩阵（为截距 $\\beta_0$ 在特征矩阵前追加一列 1），$\\boldsymbol{\\beta}_{\\text{model}}$ 是模型系数的向量。\n\n系数 $\\boldsymbol{\\beta}_{\\text{model}}$ 通过最小化训练数据上的平方误差和来确定，这是普通最小二乘法 (OLS) 的原理。唯一解由正规方程给出：\n$$\n\\boldsymbol{\\beta}_{\\text{model}} = (\\mathbf{X}_{\\text{train}}^\\top \\mathbf{X}_{\\text{train}})^{-1} \\mathbf{X}_{\\text{train}}^\\top \\mathbf{y}_{\\text{train}}\n$$\n这个线性系统最好通过数值方法求解，而不是显式计算矩阵的逆，例如可以使用 `np.linalg.solve`。\n\n一旦找到系数 $\\boldsymbol{\\beta}_{\\text{model}}$，就用它们来预测留出测试集的粘土含量：$\\hat{\\mathbf{y}}_{\\text{test}} = \\mathbf{X}_{\\text{test}}\\boldsymbol{\\beta}_{\\text{model}}$。这些预测在所有 $k$ 折中被收集起来。交叉验证循环完成后，我们得到一个长度为 $n=12$ 的完整汇集预测向量 $\\hat{\\mathbf{y}}_{\\mathrm{cv}}$，其中每个样本的预测都是由一个未使用该样本进行训练的模型生成的。\n\n最后，通过将汇集预测 $\\hat{\\mathbf{y}}_{\\mathrm{cv}}$ 与真实的粘土含量值 $\\mathbf{y}$ 进行比较来计算性能指标。\n均方根误差 (RMSE) 为：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(\\hat{y}_{\\mathrm{cv},i} - y_i)^2}\n$$\n偏差，或称平均误差，为：\n$$\n\\mathrm{bias} = \\frac{1}{n}\\sum_{i=1}^{n}(\\hat{y}_{\\mathrm{cv},i} - y_i)\n$$\n决定系数 $R^2$ 衡量因变量方差中可由自变量预测的比例。基于汇集的交叉验证结果，其计算公式为：\n$$\nR^2 = 1 - \\frac{\\sum_{i=1}^{n}(y_i - \\hat{y}_{\\mathrm{cv},i})^2}{\\sum_{i=1}^{n}(y_i - \\bar{y})^2}, \\quad \\text{其中 } \\bar{y} = \\frac{1}{n}\\sum_{i=1}^{n} y_i\n$$\n\n对三个指定的情况执行这整个程序：\n- 情况 A：$k = 3$，特征 = 仅 SCI。\n- 情况 B：$k = 6$，特征 = 仅 PR。\n- 情况 C：$k = 12$（等同于留一法交叉验证），特征 = SCI 和 PR 联合。\n\n最终输出将包含为每种情况计算的 $[\\mathrm{RMSE}, \\mathrm{bias}, R^2]$，并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs k-fold cross-validation for linear regression models\n    to predict soil clay content from spectral and radar data.\n    \"\"\"\n    # Dataset as specified in the problem statement.\n    R_nir_data = np.array([0.30, 0.35, 0.40, 0.25, 0.32, 0.28, 0.18, 0.45, 0.22, 0.50, 0.27, 0.33])\n    R_swir_data = np.array([0.20, 0.25, 0.20, 0.10, 0.12, 0.22, 0.12, 0.30, 0.18, 0.25, 0.09, 0.28])\n    sigma_vv_data = np.array([0.20, 0.18, 0.16, 0.22, 0.14, 0.24, 0.12, 0.10, 0.26, 0.15, 0.13, 0.21])\n    sigma_vh_data = np.array([0.050, 0.045, 0.032, 0.044, 0.021, 0.060, 0.036, 0.020, 0.052, 0.045, 0.026, 0.042])\n    y_data = np.array([0.515, 0.523, 0.415, 0.360, 0.330, 0.550, 0.515, 0.490, 0.555, 0.445, 0.315, 0.560])\n    \n    n_samples = len(y_data)\n\n    # Feature Engineering: Calculate SCI and PR\n    sci = (R_nir_data - R_swir_data) / (R_nir_data + R_swir_data)\n    pr = sigma_vh_data / sigma_vv_data\n\n    # Test cases defined in the problem\n    test_cases = [\n        {'k': 3, 'features': 'sci', 'label': 'A'},\n        {'k': 6, 'features': 'pr', 'label': 'B'},\n        {'k': 12, 'features': 'sci_pr', 'label': 'C'},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        k = case['k']\n        \n        # Select features for the current case\n        if case['features'] == 'sci':\n            X = sci.reshape(-1, 1)\n        elif case['features'] == 'pr':\n            X = pr.reshape(-1, 1)\n        elif case['features'] == 'sci_pr':\n            X = np.column_stack((sci, pr))\n        \n        # Cross-validation setup\n        indices = np.arange(n_samples)\n        rng = np.random.default_rng(seed=137)\n        permuted_indices = rng.permutation(indices)\n        \n        # np.array_split correctly partitions into contiguous folds\n        folds = np.array_split(permuted_indices, k)\n        \n        # Array to store pooled cross-validated predictions\n        y_cv_pooled = np.zeros(n_samples)\n        \n        for i in range(k):\n            test_indices = folds[i]\n            \n            # setdiff1d can be used to get train_indices\n            train_indices = np.setdiff1d(permuted_indices, test_indices)\n\n            # Prepare training and test sets\n            X_train, y_train = X[train_indices], y_data[train_indices]\n            X_test, y_test = X[test_indices], y_data[test_indices]\n            \n            # Construct design matrices with an intercept term\n            X_train_design = np.c_[np.ones(len(X_train)), X_train]\n            X_test_design = np.c_[np.ones(len(X_test)), X_test]\n            \n            # Solve the normal equations for OLS: (X'X)b = X'y\n            # np.linalg.solve is numerically more stable than using np.linalg.inv\n            try:\n                beta = np.linalg.solve(X_train_design.T @ X_train_design, X_train_design.T @ y_train)\n            except np.linalg.LinAlgError:\n                # Fallback to pseudoinverse if matrix is singular, though unlikely here\n                beta = np.linalg.pinv(X_train_design) @ y_train\n\n            # Predict on the held-out fold\n            y_pred = X_test_design @ beta\n            \n            # Store predictions in the correct positions of the pooled array\n            y_cv_pooled[test_indices] = y_pred\n\n        # After CV, compute metrics on the pooled predictions\n        # The true y_data vector is already in the correct order corresponding to y_cv_pooled\n        residuals = y_cv_pooled - y_data\n        \n        # RMSE\n        rmse = np.sqrt(np.mean(residuals**2))\n        \n        # Bias\n        bias = np.mean(residuals)\n        \n        # R^2\n        ss_res = np.sum(residuals**2)\n        ss_tot = np.sum((y_data - np.mean(y_data))**2)\n        if ss_tot == 0:\n            # Handle case where target variance is zero\n            r2 = 1.0 if ss_res == 0 else 0.0\n        else:\n            r2 = 1 - (ss_res / ss_tot)\n            \n        all_results.append([rmse, bias, r2])\n\n    # Format the final output string exactly as required.\n    # Each sublist is formatted, then joined by commas.\n    # The outer list is then enclosed in brackets.\n    output_parts = []\n    for result_set in all_results:\n        formatted_set = f\"[{result_set[0]:.6f},{result_set[1]:.6f},{result_set[2]:.6f}]\"\n        output_parts.append(formatted_set)\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "遥感通常提供多个信息源，但每个信息源都伴随着不确定性。这个高级练习介绍了一个强大的贝叶斯框架，用于将有噪声的SAR测量与先验知识（例如，可能来自光学指数）相结合，以获得更准确、更稳健的土壤湿度估算。该练习揭示了数据融合的核心思想：最终的估计结果优于任何单一数据源所能提供的结果。",
            "id": "3848603",
            "problem": "一个农田上空的土壤像素由C波段的合成孔径雷达（SAR）观测。在低植被覆盖的裸土上，由于有效介电常数随含水量单调增加，SAR后向散射（以分贝计）与体积土壤湿度近似呈线性关系。对于小范围的土壤湿度，假设正演模型 $y$（以分贝计）为 $y = \\alpha\\, m_v + \\beta + \\epsilon$，其中 $m_v \\in [0,1]$ 是无量纲的体积土壤湿度，$\\alpha$ 和 $\\beta$ 是针对该地点和入射几何的已知校准系数，$\\epsilon$ 是随机传感器和模型误差，满足 $\\epsilon \\sim \\mathcal{N}(0,\\sigma_{\\epsilon}^{2})$。来自归一化差异红外指数（NDII）的高光谱成像通过回归分析提供了 $m_v$ 的先验估计，该回归产生一个高斯先验 $m_v \\sim \\mathcal{N}(m_0,\\sigma_{m,0}^{2})$。\n\n从贝叶斯定理和高斯密度的定义出发，推导后验分布 $p(m_v \\mid y)$ 并证明其为高斯分布。然后，利用后验分布，推导 $m_v$ 的双边 $0.95$ 置信区间的通用表达式，用后验均值和方差表示。最后，对于具有以下参数的特定像素：$\\alpha = 10$ （分贝/单位 $m_v$），$\\beta = -15$ （分贝），$y = -12.3$ （分贝），$\\sigma_{\\epsilon}^{2} = 0.64$ （平方分贝），$m_0 = 0.24$，以及 $\\sigma_{m,0}^{2} = 0.0016$，计算 $m_v$ 的 $0.95$ 置信区间界限。使用 LaTeX $\\texttt{pmatrix}$ 环境，将最终界限表示为单行中的一对数值，形式为无量纲的小数，并将两个界限均四舍五入至四位有效数字。",
            "solution": "问题陈述经过验证。\n\n### 第1步：提取已知条件\n- SAR后向散射 $y$（以分贝计）的正演模型：$y = \\alpha\\, m_v + \\beta + \\epsilon$。\n- $m_v$：体积土壤湿度，$m_v \\in [0,1]$，无量纲。\n- $\\alpha$, $\\beta$：已知校准系数。\n- $\\epsilon$：随机误差项，其分布为 $\\epsilon \\sim \\mathcal{N}(0,\\sigma_{\\epsilon}^{2})$。\n- 土壤湿度的先验分布：$m_v \\sim \\mathcal{N}(m_0,\\sigma_{m,0}^{2})$。\n- 任务1：推导后验分布 $p(m_v \\mid y)$ 并证明其为高斯分布。\n- 任务2：推导 $m_v$ 的双边 $0.95$ 置信区间的通用表达式。\n- 任务3：对于具有以下参数的特定像素，计算其 $0.95$ 置信区间的界限：\n    - $\\alpha = 10$ （分贝/单位 $m_v$）\n    - $\\beta = -15$ （分贝）\n    - $y = -12.3$ （分贝）\n    - $\\sigma_{\\epsilon}^{2} = 0.64$ （平方分贝）\n    - $m_0 = 0.24$ （无量纲）\n    - $\\sigma_{m,0}^{2} = 0.0016$ （平方无量纲）\n- 最终答案格式：在 `pmatrix` 中的一对界限，以小数形式表示，并四舍五入至四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题描述了一种遥感中用于估计物理参数（土壤湿度）的标准贝叶斯数据融合方法。SAR后向散射的线性模型是在特定条件下（例如，C波段，低植被）一种常用且有物理动机的近似。使用来自独立数据源（高光谱指数）的高斯先验是数据同化中一种有效且成熟的技术。\n2.  **适定性：** 该问题提供了一个明确的目标、一个正演模型（似然）、一个先验分布以及推导后验分布和计算所要求的置信区间所需的所有参数。这是贝叶斯统计中的一个标准问题，存在唯一且稳定的解。\n3.  **客观性：** 问题陈述使用了精确、无歧义的数学和科学语言。\n4.  **完整性与一致性：** 该问题是自洽的。符号推导和数值计算所需的所有常数和初始条件都已提供。这些值对于所描述的情景是物理上合理的。虽然 $m_v$ 在物理上被限制在 $[0,1]$ 区间内，但使用高斯分布（定义在整个实数线上）是一种常见且可接受的近似，前提是得到的后验分布很好地集中在物理界限内。计算后检查可以验证这一点。\n\n### 第3步：结论与行动\n该问题具有科学合理性、数学适定性和完整性。因此，该问题被视为**有效**。将按要求推导解答。\n\n### 后验分布的推导\n\n根据贝叶斯定理，给定测量值 $y$ 的体积土壤湿度 $m_v$ 的后验概率密度函数（PDF）与似然函数和先验PDF的乘积成正比：\n$$p(m_v \\mid y) \\propto p(y \\mid m_v) \\, p(m_v)$$\n先验分布给定为高斯分布：\n$$p(m_v) = \\frac{1}{\\sqrt{2\\pi\\sigma_{m,0}^{2}}} \\exp\\left(-\\frac{(m_v - m_0)^2}{2\\sigma_{m,0}^{2}}\\right)$$\n正演模型为 $y = \\alpha m_v + \\beta + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma_{\\epsilon}^{2})$。由此可以构建似然函数 $p(y \\mid m_v)$。对于给定的 $m_v$，$y$ 是一个随机变量，其均值为 $\\mathbb{E}[y \\mid m_v] = \\alpha m_v + \\beta$，方差为 $\\text{Var}(y \\mid m_v) = \\sigma_{\\epsilon}^2$。因此，似然函数也是一个高斯PDF：\n$$p(y \\mid m_v) = \\frac{1}{\\sqrt{2\\pi\\sigma_{\\epsilon}^{2}}} \\exp\\left(-\\frac{(y - (\\alpha m_v + \\beta))^2}{2\\sigma_{\\epsilon}^{2}}\\right)$$\n后验PDF与这两个高斯函数的乘积成正比。我们可以忽略归一化常数，因为它们不依赖于 $m_v$。\n$$p(m_v \\mid y) \\propto \\exp\\left( -\\frac{(y - \\alpha m_v - \\beta)^2}{2\\sigma_{\\epsilon}^{2}} - \\frac{(m_v - m_0)^2}{2\\sigma_{m,0}^{2}} \\right)$$\n为了证明后验是高斯分布，我们必须证明指数中的表达式是 $m_v$ 的二次函数，形式为 $-\\frac{(m_v - \\mu_{post})^2}{2\\sigma_{post}^2}$。让我们展开指数的参数：\n$$S(m_v) = -\\frac{1}{2} \\left[ \\frac{(\\alpha m_v - (y - \\beta))^2}{\\sigma_{\\epsilon}^{2}} + \\frac{(m_v - m_0)^2}{\\sigma_{m,0}^{2}} \\right]$$\n$$S(m_v) = -\\frac{1}{2} \\left[ \\frac{\\alpha^2 m_v^2 - 2\\alpha(y-\\beta)m_v + (y-\\beta)^2}{\\sigma_{\\epsilon}^{2}} + \\frac{m_v^2 - 2m_0 m_v + m_0^2}{\\sigma_{m,0}^{2}} \\right]$$\n我们收集 $m_v^2$ 和 $m_v$ 的项：\n$$S(m_v) = -\\frac{1}{2} \\left[ m_v^2 \\left( \\frac{\\alpha^2}{\\sigma_{\\epsilon}^2} + \\frac{1}{\\sigma_{m,0}^2} \\right) - 2m_v \\left( \\frac{\\alpha(y-\\beta)}{\\sigma_{\\epsilon}^2} + \\frac{m_0}{\\sigma_{m,0}^2} \\right) + C \\right]$$\n其中 $C$ 包含不依赖于 $m_v$ 的项。这是 $m_v$ 的一个二次型。通过配方法，我们可以确定得到的高斯后验的均值和方差。一个均值为 $\\mu$、方差为 $\\sigma^2$ 的变量 $x$ 的高斯PDF的指数部分为 $-\\frac{x^2 - 2\\mu x + \\mu^2}{2\\sigma^2} = -\\frac{1}{2\\sigma^2}x^2 + \\frac{\\mu}{\\sigma^2}x - \\frac{\\mu^2}{2\\sigma^2}$。\n\n通过比较 $m_v^2$ 项的系数，我们找到后验方差的倒数 $\\sigma_{post}^{-2}$：\n$$\\frac{1}{\\sigma_{post}^2} = \\frac{\\alpha^2}{\\sigma_{\\epsilon}^2} + \\frac{1}{\\sigma_{m,0}^2}$$\n这意味着后验方差为：\n$$\\sigma_{post}^2 = \\left( \\frac{\\alpha^2}{\\sigma_{\\epsilon}^2} + \\frac{1}{\\sigma_{m,0}^2} \\right)^{-1}$$\n通过比较 $m_v$ 项的系数，我们找到后验均值 $\\mu_{post}$ 的表达式：\n$$\\frac{\\mu_{post}}{\\sigma_{post}^2} = \\frac{\\alpha(y-\\beta)}{\\sigma_{\\epsilon}^2} + \\frac{m_0}{\\sigma_{m,0}^2}$$\n$$\\mu_{post} = \\sigma_{post}^2 \\left( \\frac{\\alpha(y-\\beta)}{\\sigma_{\\epsilon}^2} + \\frac{m_0}{\\sigma_{m,0}^2} \\right)$$\n由于指数是 $m_v$ 的二次函数，后验分布 $p(m_v \\mid y)$ 确实是高斯分布，其均值为 $\\mu_{post}$，方差为 $\\sigma_{post}^2$。\n$$p(m_v \\mid y) \\sim \\mathcal{N}(\\mu_{post}, \\sigma_{post}^2)$$\n\n### 置信区间的推导\n\n参数的双边置信区间包含后验分布的指定概率质量。对于来自高斯后验分布 $\\mathcal{N}(\\mu, \\sigma^2)$ 的 $(1-\\gamma)$ 置信区间，该区间关于均值 $\\mu$ 对称，并由下式给出：\n$$[\\mu - z_{\\gamma/2}\\sigma, \\mu + z_{\\gamma/2}\\sigma]$$\n其中 $z_{\\gamma/2}$ 是标准正态分布的临界值，使得 $P(Z > z_{\\gamma/2}) = \\gamma/2$，其中 $Z \\sim \\mathcal{N}(0,1)$。\n\n对于 $0.95$ 的置信区间，我们有 $1-\\gamma = 0.95$，所以 $\\gamma=0.05$ 且 $\\gamma/2 = 0.025$。临界值 $z_{0.025}$ 是使累积分布函数（CDF）为 $1-0.025=0.975$ 的值。从标准统计表中，这个值约为 $z_{0.025} \\approx 1.96$。\n因此，$m_v$ 的 $0.95$ 置信区间的通用表达式为：\n$$[\\mu_{post} - z_{0.025}\\,\\sigma_{post}, \\mu_{post} + z_{0.025}\\,\\sigma_{post}]$$\n其中 $\\mu_{post}$ 和 $\\sigma_{post}$ 是上面推导出的后验均值和后验标准差。\n\n### 数值计算\n\n给定以下参数：\n$\\alpha = 10$, $\\beta = -15$, $y = -12.3$, $\\sigma_{\\epsilon}^{2} = 0.64$, $m_0 = 0.24$, 以及 $\\sigma_{m,0}^{2} = 0.0016$。\n\n首先，我们计算后验方差 $\\sigma_{post}^2$：\n$$\\frac{1}{\\sigma_{post}^2} = \\frac{\\alpha^2}{\\sigma_{\\epsilon}^2} + \\frac{1}{\\sigma_{m,0}^2} = \\frac{10^2}{0.64} + \\frac{1}{0.0016} = \\frac{100}{0.64} + \\frac{1}{0.0016}$$\n$$\\frac{1}{\\sigma_{post}^2} = 156.25 + 625 = 781.25$$\n$$\\sigma_{post}^2 = \\frac{1}{781.25} = 0.00128$$\n后验标准差为 $\\sigma_{post} = \\sqrt{0.00128}$。\n\n接下来，我们计算后验均值 $\\mu_{post}$：\n$$\\mu_{post} = \\sigma_{post}^2 \\left( \\frac{\\alpha(y-\\beta)}{\\sigma_{\\epsilon}^2} + \\frac{m_0}{\\sigma_{m,0}^2} \\right)$$\n$$\\mu_{post} = 0.00128 \\left( \\frac{10(-12.3 - (-15))}{0.64} + \\frac{0.24}{0.0016} \\right)$$\n$$\\mu_{post} = 0.00128 \\left( \\frac{10(2.7)}{0.64} + 150 \\right)$$\n$$\\mu_{post} = 0.00128 \\left( \\frac{27}{0.64} + 150 \\right)$$\n$$\\mu_{post} = 0.00128 (42.1875 + 150) = 0.00128 (192.1875) = 0.246$$\n\n现在，我们使用 $\\mu_{post}=0.246$、$\\sigma_{post}=\\sqrt{0.00128}$ 和临界值 $z_{0.025} \\approx 1.959964$ 来计算 $0.95$ 的置信区间界限。\n$$\\sigma_{post} = \\sqrt{0.00128} \\approx 0.0357770876$$\n误差范围是：\n$$E = z_{0.025} \\cdot \\sigma_{post} \\approx 1.959964 \\times 0.0357770876 \\approx 0.07012164$$\n\n下界：\n$$L = \\mu_{post} - E \\approx 0.246 - 0.07012164 = 0.17587836$$\n上界：\n$$U = \\mu_{post} + E \\approx 0.246 + 0.07012164 = 0.31612164$$\n\n将两个界限四舍五入至四位有效数字：\n下界 $\\approx 0.1759$\n上界 $\\approx 0.3161$\n\n区间 $[0.1759, 0.3161]$ 远在物理域 $[0,1]$ 之内，这证明了使用高斯近似的合理性。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.1759  0.3161 \\end{pmatrix}}$$"
        }
    ]
}