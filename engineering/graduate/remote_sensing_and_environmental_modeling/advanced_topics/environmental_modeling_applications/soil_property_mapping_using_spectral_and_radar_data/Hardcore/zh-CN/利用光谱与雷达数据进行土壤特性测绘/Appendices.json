{
    "hands_on_practices": [
        {
            "introduction": "为了从土壤反射光谱中提取定量信息，我们必须首先对数据进行归一化，以将特定的吸收特征与整体亮度变化分离开来。本练习将指导您实现一种标准技术——连续统去除法，以计算光谱特征的波段深度。通过应用这种基于几何学的方法 ，您将掌握一项实用技能，用于量化粘土矿物等在短波红外区域具有特征吸收的物质含量。",
            "id": "3848675",
            "problem": "给定在特定波长位置采样的离散土壤反射光谱，以及每个光谱的一组上凸包顶点。目标是推导出目标波长处的凸包连续体，并计算每个案例在该波长处的吸收带深度。您的程序必须为每个测试案例实现以下任务。\n\n基础和定义：\n- 设 $R(\\lambda)$ 表示在波长 $\\lambda$ (单位为微米，$\\mu\\text{m}$) 处测量的土壤表面的双向反射因子（无量纲）。吸收特征表现为 $R(\\lambda)$ 相对于一个称为连续体的平滑、缓慢变化的基线的局部凹陷。\n- 在光谱分析中，连续体定义为 $\\lambda$-$R$ 平面中点集 $\\{(\\lambda_i, R(\\lambda_i))\\}$ 的凸包的上边界。凸包是包含所有点的最小凸集；其上边界是一个分段线性的凹包络，由连接选定的凸包顶点 $\\{(\\lambda_{h,j}, R_{h,j})\\}$ 的直线段构成。\n- 对于目标波长 $\\lambda^\\star$，连续体 $C(\\lambda^\\star)$ 是通过对包含 $\\lambda^\\star$ 的凸包线段进行线性插值得到的。如果 $\\lambda^\\star$ 与一个凸包顶点重合，则该顶点的 $C(\\lambda^\\star) = R_{h,j}$。\n- $\\lambda^\\star$ 处的吸收带深度定义为去除连续体后的吸收度量\n$$\nBD(\\lambda^\\star) = 1 - \\frac{R(\\lambda^\\star)}{C(\\lambda^\\star)} ,\n$$\n表示为无单位的小数。\n\n每个测试案例的算法要求：\n1. 输入：\n   - 一个严格递增的波长列表 $\\Lambda = [\\lambda_1, \\lambda_2, \\dots, \\lambda_n]$，单位为微米 ($\\mu\\text{m}$)。\n   - 一个反射率列表 $\\mathcal{R} = [R(\\lambda_1), R(\\lambda_2), \\dots, R(\\lambda_n)]$，每个值都是在 $[0,1]$ 范围内的无量纲数。\n   - 一个凸包顶点列表 $\\mathcal{H} = [(\\lambda_{h,1}, R_{h,1}), (\\lambda_{h,2}, R_{h,2}), \\dots, (\\lambda_{h,m}, R_{h,m})]$，按 $\\lambda_{h,j}$ 递增排序，这些顶点通过连续顶点之间的直线段定义了上凸包连续体。\n   - 一个目标波长 $\\lambda^\\star = 2.20\\,\\mu\\text{m}$。\n2. 计算 $R(\\lambda^\\star)$：\n   - 如果 $\\lambda^\\star$ 正好是 $\\lambda_i$ 中的一个，则将 $R(\\lambda^\\star)$ 设置为相应的反射率值。\n   - 否则，找到索引 $i$ 和 $i+1$ 使得 $\\lambda_i \\le \\lambda^\\star \\le \\lambda_{i+1}$，并进行线性插值\n   $$\n   R(\\lambda^\\star) = R(\\lambda_i) + \\left( \\frac{\\lambda^\\star - \\lambda_i}{\\lambda_{i+1} - \\lambda_i} \\right) \\left( R(\\lambda_{i+1}) - R(\\lambda_i) \\right) .\n   $$\n3. 计算 $C(\\lambda^\\star)$：\n   - 如果 $\\lambda^\\star$ 正好是 $\\lambda_{h,j}$ 中的一个，则设置 $C(\\lambda^\\star) = R_{h,j}$。\n   - 否则，找到连续的凸包顶点 $(\\lambda_{h,j}, R_{h,j})$ 和 $(\\lambda_{h,j+1}, R_{h,j+1})$ 使得 $\\lambda_{h,j} \\le \\lambda^\\star \\le \\lambda_{h,j+1}$，并进行线性插值\n   $$\n   C(\\lambda^\\star) = R_{h,j} + \\left( \\frac{\\lambda^\\star - \\lambda_{h,j}}{\\lambda_{h,j+1} - \\lambda_{h,j}} \\right) \\left( R_{h,j+1} - R_{h,j} \\right) .\n   $$\n4. 使用上述公式计算 $BD(\\lambda^\\star)$。输出必须表示为无量纲的小数（不带百分号）。\n\n科学真实性与适用性：$\\lambda^\\star = 2.20\\,\\mu\\text{m}$ 处的吸收带深度通常用于量化与土壤中粘土含量相关的 $Al$-$OH$ 吸收特征。凸包连续体使得该测量值能够稳定地抵抗大尺度反照率变化的影响。该过程是纯粹几何和数值的，基于插值和凸性原理。\n\n测试套件：\n- 第一个案例（具有显式 $\\lambda^\\star$ 采样点的一般吸收特征）：\n  - $\\Lambda = [2.00, 2.10, 2.15, 2.20, 2.25, 2.30, 2.40]$，单位 $\\mu\\text{m}$。\n  - $\\mathcal{R} = [0.52, 0.50, 0.48, 0.35, 0.47, 0.52, 0.55]$。\n  - $\\mathcal{H} = [(2.00, 0.52), (2.40, 0.55)]$。\n- 第二个案例（边界情况，$\\lambda^\\star$ 与凸包顶点重合，产生零吸收深度）：\n  - $\\Lambda = [2.18, 2.20, 2.22, 2.24]$，单位 $\\mu\\text{m}$。\n  - $\\mathcal{R} = [0.49, 0.52, 0.51, 0.50]$。\n  - $\\mathcal{H} = [(2.18, 0.49), (2.20, 0.52), (2.24, 0.50)]$。\n- 第三个案例（最小光谱，包含三个样本，且端点为凸包顶点）：\n  - $\\Lambda = [2.10, 2.20, 2.30]$，单位 $\\mu\\text{m}$。\n  - $\\mathcal{R} = [0.60, 0.40, 0.62]$。\n  - $\\mathcal{H} = [(2.10, 0.60), (2.30, 0.62)]$。\n- 第四个案例（目标波长未被采样；$R(\\lambda^\\star)$ 必须通过相邻点插值得到）：\n  - $\\Lambda = [2.17, 2.19, 2.21, 2.23, 2.26, 2.30]$，单位 $\\mu\\text{m}$。\n  - $\\mathcal{R} = [0.53, 0.51, 0.46, 0.49, 0.52, 0.54]$。\n  - $\\mathcal{H} = [(2.17, 0.53), (2.30, 0.54)]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试案例的吸收带深度，格式为用方括号括起来的逗号分隔列表，例如 $[b_1,b_2,b_3,b_4]$，其中每个 $b_k$ 是按上述规定计算的浮点数。波长必须以 $\\mu\\text{m}$ 为单位处理，吸收带深度必须作为无量纲小数返回。",
            "solution": "所述问题是有效的。它在科学上基于定量光谱学的原理，定义清晰完整，数据充分，表述客观。未发现矛盾、歧义或事实错误。该问题可以通过直接应用所提供的算法来解决。\n\n核心任务是为几个土壤反射光谱计算在指定目标波长 $\\lambda^\\star$ 处的吸收带深度，表示为 $BD(\\lambda^\\star)$。吸收带深度是光谱学中用于量化吸收特征强度的标准度量。它被定义为一个去连续体的量，通过相对于连续体基线 $C(\\lambda)$ 对反射光谱进行归一化。\n\n吸收带深度的公式如下：\n$$\nBD(\\lambda^\\star) = 1 - \\frac{R(\\lambda^\\star)}{C(\\lambda^\\star)}\n$$\n其中 $R(\\lambda^\\star)$ 是目标波长 $\\lambda^\\star$ 处的反射率值，$C(\\lambda^\\star)$ 是同一波长处的光谱连续体值。因此，计算过程涉及为每个测试案例确定这两个值。\n\n**1. 反射率 $R(\\lambda^\\star)$ 的确定**\n\n反射光谱以离散测量集 $(\\lambda_i, R(\\lambda_i))$ 的形式提供，其中 $\\Lambda = [\\lambda_1, \\lambda_2, \\dots, \\lambda_n]$ 是一个严格递增的波长列表。目标波长指定为 $\\lambda^\\star = 2.20\\,\\mu\\text{m}$。\n\n$R(\\lambda^\\star)$ 的值按以下方式获得：\n- **情况 A：完全匹配：** 如果目标波长 $\\lambda^\\star$ 与列表 $\\Lambda$ 中的某个采样波长 $\\lambda_i$ 完全重合，则 $R(\\lambda^\\star)$ 就是相应的测量反射率值 $R(\\lambda_i)$。\n- **情况 B：插值：** 如果 $\\lambda^\\star$ 落在两个采样波长之间，即 $\\lambda_i  \\lambda^\\star  \\lambda_{i+1}$，则其反射率 $R(\\lambda^\\star)$ 通过在两个相邻点 $(\\lambda_i, R(\\lambda_i))$ 和 $(\\lambda_{i+1}, R(\\lambda_{i+1}))$ 之间进行线性插值来估计。线性插值的公式为：\n$$\nR(\\lambda^\\star) = R(\\lambda_i) + \\left( \\frac{\\lambda^\\star - \\lambda_i}{\\lambda_{i+1} - \\lambda_i} \\right) \\left( R(\\lambda_{i+1}) - R(\\lambda_i) \\right)\n$$\n这假设光谱在采样点之间具有局部线性行为，这是高分辨率光谱数据的标准做法。\n\n**2. 连续体 $C(\\lambda^\\star)$ 的确定**\n\n连续体 $C(\\lambda)$ 定义为光谱的上包络线，由一组给定的上凸包顶点 $\\mathcal{H} = [(\\lambda_{h,1}, R_{h,1}), \\dots, (\\lambda_{h,m}, R_{h,m})]$ 构建。该包络线是连接连续顶点的分段线性函数。\n\n$C(\\lambda^\\star)$ 的确定方式与 $R(\\lambda^\\star)$ 类似，但使用的是凸包顶点而非全部光谱数据：\n- **情况 A：完全匹配：** 如果目标波长 $\\lambda^\\star$ 与某个凸包顶点的波长重合，即 $\\lambda^\\star = \\lambda_{h,j}$，则连续体值为该顶点的反射率，$C(\\lambda^\\star) = R_{h,j}$。\n- **情况 B：插值：** 如果 $\\lambda^\\star$ 落在两个连续的凸包顶点之间，即 $\\lambda_{h,j}  \\lambda^\\star  \\lambda_{h,j+1}$，则连续体值 $C(\\lambda^\\star)$ 通过在这两个顶点 $(\\lambda_{h,j}, R_{h,j})$ 和 $(\\lambda_{h,j+1}, R_{h,j+1})$ 连接的线段上进行线性插值得到：\n$$\nC(\\lambda^\\star) = R_{h,j} + \\left( \\frac{\\lambda^\\star - \\lambda_{h,j}}{\\lambda_{h,j+1} - \\lambda_{h,j}} \\right) \\left( R_{h,j+1} - R_{h,j} \\right)\n$$\n此过程提供了用于测量吸收强度的平滑上边界参考值。\n\n**3. 算法实现**\n\n对于每个测试案例，总体算法流程如下：\n1.  定义输入数据：波长列表 $\\Lambda$、反射率列表 $\\mathcal{R}$ 和凸包顶点列表 $\\mathcal{H}$。目标波长恒定为 $\\lambda^\\star = 2.20\\,\\mu\\text{m}$。\n2.  实现一个通用的线性插值函数，给定一个目标 $x$ 坐标和一组排序的 $(x,y)$ 点，返回相应的 $y$ 坐标。该函数必须处理完全匹配和插值两种情况。\n3.  使用 $\\lambda^\\star$ 和光谱点 $\\{(\\lambda_i, R(\\lambda_i))\\}$ 调用此插值函数以计算 $R(\\lambda^\\star)$。\n4.  使用 $\\lambda^\\star$ 和凸包顶点 $\\{(\\lambda_{h,j}, R_{h,j})\\}$ 调用相同的插值函数以计算 $C(\\lambda^\\star)$。\n5.  使用基本公式计算吸收带深度 $BD(\\lambda^\\star)$。由于所有反射率 $R(\\lambda_i)$ 都在 $[0, 1]$ 范围内，并且凸包位于光谱之上，因此对于非零光谱，$C(\\lambda^\\star)$ 将为正，从而避免了除以零的错误。\n6.  每个案例的最终结果是计算出的 $BD(\\lambda^\\star)$ 的无量纲小数值。\n\n此过程是确定性的，并直接遵循所提供的定义，确保了基于基本几何和数值原理的正确且可验证的解决方案。",
            "answer": "```python\nimport numpy as np\n\ndef _linear_interpolate(x_target, points):\n    \"\"\"\n    Performs linear interpolation on a set of 2D points.\n\n    Args:\n        x_target (float): The x-coordinate at which to interpolate.\n        points (list of tuple/list): A list of (x, y) points, sorted by x.\n\n    Returns:\n        float: The interpolated y-value.\n    \"\"\"\n    points_arr = np.array(points)\n    x_coords = points_arr[:, 0]\n    y_coords = points_arr[:, 1]\n    \n    # Case 1: x_target is one of the existing x-coordinates\n    match_indices = np.where(x_coords == x_target)[0]\n    if len(match_indices) > 0:\n        return y_coords[match_indices[0]]\n\n    # Case 2: x_target needs interpolation.\n    # np.searchsorted finds the index where x_target would be inserted to maintain order.\n    idx = np.searchsorted(x_coords, x_target)\n\n    # The problem setup ensures x_target is always bracketed by the given points.\n    # Therefore, we do not need to handle extrapolation cases.\n    x1, y1 = points_arr[idx - 1]\n    x2, y2 = points_arr[idx]\n    \n    # Standard linear interpolation formula\n    y_target = y1 + ((x_target - x1) * (y2 - y1) / (x2 - x1))\n    \n    return y_target\n\ndef calculate_band_depth(lmbda, R, H, lambda_star):\n    \"\"\"\n    Calculates the band depth at a target wavelength.\n\n    Args:\n        lmbda (list): List of wavelengths.\n        R (list): List of reflectances.\n        H (list of tuple): List of convex hull vertices.\n        lambda_star (float): The target wavelength.\n\n    Returns:\n        float: The calculated band depth.\n    \"\"\"\n    # 1. Compute R(lambda_star) by interpolating the spectrum\n    spectrum_points = list(zip(lmbda, R))\n    R_star = _linear_interpolate(lambda_star, spectrum_points)\n\n    # 2. Compute C(lambda_star) by interpolating the hull vertices\n    C_star = _linear_interpolate(lambda_star, H)\n\n    # 3. Compute BD(lambda_star)\n    # The problem context implies C_star will not be zero.\n    if C_star == 0:\n        return np.nan # Should not be reached with the given test cases\n\n    band_depth = 1.0 - (R_star / C_star)\n    return band_depth\n\ndef solve():\n    \"\"\"\n    Solves the band depth calculation problem for the given test cases.\n    \"\"\"\n    lambda_star = 2.20\n\n    test_cases = [\n        # Case 1: General absorption feature\n        (\n            [2.00, 2.10, 2.15, 2.20, 2.25, 2.30, 2.40],\n            [0.52, 0.50, 0.48, 0.35, 0.47, 0.52, 0.55],\n            [(2.00, 0.52), (2.40, 0.55)]\n        ),\n        # Case 2: Target wavelength is a hull vertex\n        (\n            [2.18, 2.20, 2.22, 2.24],\n            [0.49, 0.52, 0.51, 0.50],\n            [(2.18, 0.49), (2.20, 0.52), (2.24, 0.50)]\n        ),\n        # Case 3: Minimal spectrum\n        (\n            [2.10, 2.20, 2.30],\n            [0.60, 0.40, 0.62],\n            [(2.10, 0.60), (2.30, 0.62)]\n        ),\n        # Case 4: Target wavelength is not sampled\n        (\n            [2.17, 2.19, 2.21, 2.23, 2.26, 2.30],\n            [0.53, 0.51, 0.46, 0.49, 0.52, 0.54],\n            [(2.17, 0.53), (2.30, 0.54)]\n        )\n    ]\n\n    results = []\n    for lmbda, R, H in test_cases:\n        bd = calculate_band_depth(lmbda, R, H, lambda_star)\n        results.append(bd)\n\n    # Format the output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "遥感领域中一种强大的方法是融合来自光学和雷达等多种传感器的数据，以建立更稳健的模型。然而，对这些模型进行严格验证，以确保其对新数据的泛化能力，是至关重要的。此实践问题  要求您实施 $k$ 折交叉验证——模型评估的黄金标准——来评估和比较用于预测粘土含量的不同模型。",
            "id": "3848679",
            "problem": "您的任务是验证一个用于估算土壤粘土含量的线性指数-属性回归模型，该模型使用光谱反射率和雷达后向散射数据。其背景是联合使用多光谱光学反射率和合成孔径雷达（SAR）后向散射来推断地表土壤的粘土含量。将使用的两个指数是：一个由近红外（NIR）和短波红外（SWIR）反射率构建的光谱指数，以及一个由同极化和交叉极化后向散射构建的极化雷达比率。\n\n请使用以下基本定义和事实作为起点：\n- 由两个正反射率 $r_1$ 和 $r_2$ 构建的归一化差异指数（NDI）定义为其差值与和值的比率。该比率无量纲，界于 $(-1,1)$ 之间，并能降低对乘性光照因子的敏感度。\n- 带有平方误差损失的线性回归通过在仿射假设类上最小化经验风险来求解，其唯一最小化子（当设计矩阵为满列秩时）满足正规方程组。\n- 均方根误差（RMSE）、平均误差（偏差）和决定系数 $R^2$ 是用于评估在留出数据上的预测性能的标准、单位一致的度量指标。\n\n数据集。您将获得 $n = 12$ 个独立样本。每个样本 $i$ 包括：\n- NIR反射率 $R_{\\mathrm{NIR},i}$（无量纲分数），\n- SWIR反射率 $R_{\\mathrm{SWIR},i}$（无量纲分数），\n- 垂直-垂直极化的线性功率雷达后向散射 $\\sigma^{0}_{\\mathrm{VV},i}$（无量纲，线性尺度），\n- 垂直-水平极化的线性功率雷达后向散射 $\\sigma^{0}_{\\mathrm{VH},i}$（无量纲，线性尺度），\n- 粘土含量质量分数 $y_i$（无量纲分数，在 $[0,1]$ 区间内）。\n\n对于 $i = 1,\\dots,12$，使用以下数值：\n- $R_{\\mathrm{NIR}} = [\\,0.30,\\,0.35,\\,0.40,\\,0.25,\\,0.32,\\,0.28,\\,0.18,\\,0.45,\\,0.22,\\,0.50,\\,0.27,\\,0.33\\,]$.\n- $R_{\\mathrm{SWIR}} = [\\,0.20,\\,0.25,\\,0.20,\\,0.10,\\,0.12,\\,0.22,\\,0.12,\\,0.30,\\,0.18,\\,0.25,\\,0.09,\\,0.28\\,]$.\n- $\\sigma^{0}_{\\mathrm{VV}} = [\\,0.20,\\,0.18,\\,0.16,\\,0.22,\\,0.14,\\,0.24,\\,0.12,\\,0.10,\\,0.26,\\,0.15,\\,0.13,\\,0.21\\,]$.\n- $\\sigma^{0}_{\\mathrm{VH}} = [\\,0.050,\\,0.045,\\,0.032,\\,0.044,\\,0.021,\\,0.060,\\,0.036,\\,0.020,\\,0.052,\\,0.045,\\,0.026,\\,0.042\\,]$.\n- $y = [\\,0.515,\\,0.523,\\,0.415,\\,0.360,\\,0.330,\\,0.550,\\,0.515,\\,0.490,\\,0.555,\\,0.445,\\,0.315,\\,0.560\\,]$.\n\n为每个样本 $i$ 定义两个指数：\n- 光谱粘土指数（SCI）：$s_i = \\dfrac{R_{\\mathrm{NIR},i} - R_{\\mathrm{SWIR},i}}{R_{\\mathrm{NIR},i} + R_{\\mathrm{SWIR},i}}$。\n- 极化比（PR）：$p_i = \\dfrac{\\sigma^{0}_{\\mathrm{VH},i}}{\\sigma^{0}_{\\mathrm{VV},i}}$。\n\n模型类。考虑形式为 $\\hat{y} = \\beta_0 + \\beta^\\top x$ 的仿射线性回归，其中 $x$ 可以是标量 $s$、标量 $p$，或二维向量 $[\\,s,\\,p\\,]^\\top$，具体取决于特征选择模式。\n\n验证设计。按如下方式实现 $k$-折交叉验证：\n- 使用固定的伪随机数生成器种子（等于 $137$）构建 $\\{0,1,\\dots,n-1\\}$ 的一个随机排列 $\\pi$。将 $\\pi$ 划分成 $k$ 个连续的折，使用等大小分割（最多相差一个索引），即各折的大小最多相差一，并保持 $\\pi$ 内部的顺序。\n- 对于每个折 $f$，通过最小化训练子集上的经验均方误差，在其他 $k-1$ 个折的并集上拟合线性回归模型，然后对留出的折 $f$ 进行预测。\n- 聚合所有留出预测，形成长度为 $n$ 的合并向量 $\\hat{y}_{\\mathrm{cv}}$ 和 $y$。\n\n指标。从基本原理出发，对合并的留出预测计算以下量：\n- RMSE，\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\dfrac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{y}_{\\mathrm{cv},i} - y_i\\right)^2}.\n$$\n\n- 偏差（平均误差），\n$$\n\\mathrm{bias} \\;=\\; \\dfrac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{y}_{\\mathrm{cv},i} - y_i\\right).\n$$\n\n- 决定系数，\n$$\nR^2 \\;=\\; 1 \\;-\\; \\dfrac{\\sum_{i=1}^{n}\\left(y_i - \\hat{y}_{\\mathrm{cv},i}\\right)^2}{\\sum_{i=1}^{n}\\left(y_i - \\bar{y}\\right)^2}, \\quad \\bar{y} \\;=\\; \\dfrac{1}{n}\\sum_{i=1}^{n} y_i.\n$$\n\n所有粘土含量和误差都必须视为无量纲分数。所有最终指标值均以小数形式报告（而非百分比）。\n\n测试套件。您的程序必须对以下参数情况执行上述操作：\n- 情况 A：$k = 3$，特征 = 仅 SCI。\n- 情况 B：$k = 6$，特征 = 仅 PR。\n- 情况 C：$k = 12$，特征 = SCI 和 PR 联合。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个逗号分隔的列表，并用方括号括起来。每种情况应贡献一个 $[\\,\\mathrm{RMSE},\\,\\mathrm{bias},\\,R^2\\,]$ 列表，其中每个数字都四舍五入到恰好六位小数。因此，整体输出必须是按情况 A、情况 B、情况 C 顺序排列的包含三个列表的列表。例如，格式必须为\n$$\n[[\\,r_1,b_1,R_1],\\,[r_2,b_2,R_2],\\,[r_3,b_3,R_3]\\,],\n$$\n其中每个 $r_j,b_j,R_j$ 都显示为四舍五入到六位的小数。",
            "solution": "该问题陈述被认为是有效的。它在遥感领域具有科学依据，在数学上是适定的、客观的，并为可复现的计算任务提供了一套完整且一致的数据和程序。\n\n目标是评估三种仿射线性回归模型，这些模型用于从派生的光谱和雷达指数估算土壤粘土含量 ($y$)。评估将使用 $k$-折交叉验证在 $n=12$ 个样本的数据集上进行。该过程涉及特征派生、通过普通最小二乘法 (OLS) 进行模型训练、交叉验证预测，以及计算三个性能指标：均方根误差 (RMSE)、偏差和决定系数 ($R^2$)。\n\n首先，我们根据提供的原始数据定义和计算输入特征。每个样本 $i=1, \\dots, 12$ 的原始数据包括 NIR 反射率 $R_{\\mathrm{NIR},i}$、SWIR 反射率 $R_{\\mathrm{SWIR},i}$、同极化雷达后向散射 $\\sigma^{0}_{\\mathrm{VV},i}$ 和交叉极化雷达后向散射 $\\sigma^{0}_{\\mathrm{VH},i}$。\n\n两个特征分别是光谱粘土指数 (SCI) $s_i$ 和极化比 (PR) $p_i$。它们的定义是：\n$$\ns_i = \\dfrac{R_{\\mathrm{NIR},i} - R_{\\mathrm{SWIR},i}}{R_{\\mathrm{NIR},i} + R_{\\mathrm{SWIR},i}}\n$$\n$$\np_i = \\dfrac{\\sigma^{0}_{\\mathrm{VH},i}}{\\sigma^{0}_{\\mathrm{VV},i}}\n$$\n为所有 $n=12$ 个样本计算这些指数，得到两个长度为 12 的向量 $\\mathbf{s}$ 和 $\\mathbf{p}$。\n\n分析的核心是 $k$-折交叉验证程序。对于给定的折数 $k$ 和指定的特征集，执行以下步骤：\n1.  使用固定的种子 $137$ 生成样本索引 $\\{0, 1, \\dots, 11\\}$ 的伪随机排列 $\\pi$，以确保可复现性。\n2.  将排列后的索引集 $\\pi$ 划分为 $k$ 个连续、不重叠的子集（折），这些子集的大小近似相等。由于 $n=12$，对于 $k=3, 6, 12$，折的大小将分别为 $12/3=4$，$12/6=2$ 和 $12/12=1$。\n3.  对于每个折 $f \\in \\{1, \\dots, k\\}$，将该折中索引对应的样本指定为留出测试集。其余 $k-1$ 个折构成训练集。\n\n在交叉验证的 $k$ 次迭代中，每次都将一个形式为 $\\hat{y} = \\beta_0 + \\boldsymbol{\\beta}^\\top \\mathbf{x}$ 的仿射线性模型拟合到训练数据上。这里，$\\mathbf{x}$ 代表特征向量，可以是一个标量（$s_i$ 或 $p_i$）或一个二维向量（$[s_i, p_i]^\\top$）。对于整个训练集，该模型可以用矩阵形式表示为 $\\mathbf{y}_{\\text{train}} \\approx \\mathbf{X}_{\\text{train}}\\boldsymbol{\\beta}_{\\text{model}}$，其中 $\\mathbf{X}_{\\text{train}}$ 是设计矩阵（特征矩阵前加一列全为1的列，用于截距 $\\beta_0$），$\\boldsymbol{\\beta}_{\\text{model}}$ 是模型系数向量。\n\n系数 $\\boldsymbol{\\beta}_{\\text{model}}$ 是通过最小化训练数据上的平方误差和来确定的，这是普通最小二乘法 (OLS) 的原则。唯一解由正规方程组给出：\n$$\n\\boldsymbol{\\beta}_{\\text{model}} = (\\mathbf{X}_{\\text{train}}^\\top \\mathbf{X}_{\\text{train}})^{-1} \\mathbf{X}_{\\text{train}}^\\top \\mathbf{y}_{\\text{train}}\n$$\n为获得数值稳定性，最好通过例如 `np.linalg.solve` 来数值求解这个线性系统，而不是显式计算矩阵的逆。\n\n一旦找到系数 $\\boldsymbol{\\beta}_{\\text{model}}$，就用它们来预测留出测试集的粘土含量：$\\hat{\\mathbf{y}}_{\\text{test}} = \\mathbf{X}_{\\text{test}}\\boldsymbol{\\beta}_{\\text{model}}$。在所有 $k$ 个折上收集这些预测。交叉验证循环完成后，我们得到一个长度为 $n=12$ 的完整合并预测向量 $\\hat{\\mathbf{y}}_{\\mathrm{cv}}$，其中每个样本的预测都是由未在其上训练的模型生成的。\n\n最后，通过将合并预测 $\\hat{\\mathbf{y}}_{\\mathrm{cv}}$ 与真实的粘土含量值 $\\mathbf{y}$进行比较来计算性能指标。\n均方根误差 (RMSE) 为：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(\\hat{y}_{\\mathrm{cv},i} - y_i)^2}\n$$\n偏差，或平均误差，为：\n$$\n\\mathrm{bias} = \\frac{1}{n}\\sum_{i=1}^{n}(\\hat{y}_{\\mathrm{cv},i} - y_i)\n$$\n决定系数 $R^2$ 衡量因变量中可由自变量预测的方差比例。基于合并的交叉验证结果，其计算公式为：\n$$\nR^2 = 1 - \\frac{\\sum_{i=1}^{n}(y_i - \\hat{y}_{\\mathrm{cv},i})^2}{\\sum_{i=1}^{n}(y_i - \\bar{y})^2}, \\quad \\text{其中 } \\bar{y} = \\frac{1}{n}\\sum_{i=1}^{n} y_i\n$$\n\n对三种指定情况执行此完整过程：\n-   情况 A：$k = 3$，特征 = 仅 SCI。\n-   情况 B：$k = 6$，特征 = 仅 PR。\n-   情况 C：$k = 12$（等同于留一法交叉验证），特征 = SCI 和 PR 联合。\n\n最终输出将包含为每种情况计算的 $[\\mathrm{RMSE}, \\mathrm{bias}, R^2]$，并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs k-fold cross-validation for linear regression models\n    to predict soil clay content from spectral and radar data.\n    \"\"\"\n    # Dataset as specified in the problem statement.\n    R_nir_data = np.array([0.30, 0.35, 0.40, 0.25, 0.32, 0.28, 0.18, 0.45, 0.22, 0.50, 0.27, 0.33])\n    R_swir_data = np.array([0.20, 0.25, 0.20, 0.10, 0.12, 0.22, 0.12, 0.30, 0.18, 0.25, 0.09, 0.28])\n    sigma_vv_data = np.array([0.20, 0.18, 0.16, 0.22, 0.14, 0.24, 0.12, 0.10, 0.26, 0.15, 0.13, 0.21])\n    sigma_vh_data = np.array([0.050, 0.045, 0.032, 0.044, 0.021, 0.060, 0.036, 0.020, 0.052, 0.045, 0.026, 0.042])\n    y_data = np.array([0.515, 0.523, 0.415, 0.360, 0.330, 0.550, 0.515, 0.490, 0.555, 0.445, 0.315, 0.560])\n    \n    n_samples = len(y_data)\n\n    # Feature Engineering: Calculate SCI and PR\n    sci = (R_nir_data - R_swir_data) / (R_nir_data + R_swir_data)\n    pr = sigma_vh_data / sigma_vv_data\n\n    # Test cases defined in the problem\n    test_cases = [\n        {'k': 3, 'features': 'sci', 'label': 'A'},\n        {'k': 6, 'features': 'pr', 'label': 'B'},\n        {'k': 12, 'features': 'sci_pr', 'label': 'C'},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        k = case['k']\n        \n        # Select features for the current case\n        if case['features'] == 'sci':\n            X = sci.reshape(-1, 1)\n        elif case['features'] == 'pr':\n            X = pr.reshape(-1, 1)\n        elif case['features'] == 'sci_pr':\n            X = np.column_stack((sci, pr))\n        \n        # Cross-validation setup\n        indices = np.arange(n_samples)\n        rng = np.random.default_rng(seed=137)\n        permuted_indices = rng.permutation(indices)\n        \n        # np.array_split correctly partitions into contiguous folds\n        folds = np.array_split(permuted_indices, k)\n        \n        # Array to store pooled cross-validated predictions\n        y_cv_pooled = np.zeros(n_samples)\n        \n        for i in range(k):\n            test_indices = folds[i]\n            \n            # setdiff1d can be used to get train_indices\n            train_indices = np.setdiff1d(permuted_indices, test_indices)\n\n            # Prepare training and test sets\n            X_train, y_train = X[train_indices], y_data[train_indices]\n            X_test, y_test = X[test_indices], y_data[test_indices]\n            \n            # Construct design matrices with an intercept term\n            X_train_design = np.c_[np.ones(len(X_train)), X_train]\n            X_test_design = np.c_[np.ones(len(X_test)), X_test]\n            \n            # Solve the normal equations for OLS: (X'X)b = X'y\n            # np.linalg.solve is numerically more stable than using np.linalg.inv\n            try:\n                beta = np.linalg.solve(X_train_design.T @ X_train_design, X_train_design.T @ y_train)\n            except np.linalg.LinAlgError:\n                # Fallback to pseudoinverse if matrix is singular, though unlikely here\n                beta = np.linalg.pinv(X_train_design) @ y_train\n\n            # Predict on the held-out fold\n            y_pred = X_test_design @ beta\n            \n            # Store predictions in the correct positions of the pooled array\n            y_cv_pooled[test_indices] = y_pred\n\n        # After CV, compute metrics on the pooled predictions\n        # The true y_data vector is already in the correct order corresponding to y_cv_pooled\n        residuals = y_cv_pooled - y_data\n        \n        # RMSE\n        rmse = np.sqrt(np.mean(residuals**2))\n        \n        # Bias\n        bias = np.mean(residuals)\n        \n        # R^2\n        ss_res = np.sum(residuals**2)\n        ss_tot = np.sum((y_data - np.mean(y_data))**2)\n        if ss_tot == 0:\n            # Handle case where target variance is zero\n            r2 = 1.0 if ss_res == 0 else 0.0\n        else:\n            r2 = 1 - (ss_res / ss_tot)\n            \n        all_results.append([rmse, bias, r2])\n\n    # Format the final output string exactly as required.\n    # Each sublist is formatted, then joined by commas.\n    # The outer list is then enclosed in brackets.\n    output_parts = []\n    for result_set in all_results:\n        formatted_set = f\"[{result_set[0]:.6f},{result_set[1]:.6f},{result_set[2]:.6f}]\"\n        output_parts.append(formatted_set)\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "遥感中的许多反演任务在数学上是“不适定的”(ill-posed)，这意味着对物理模型的直接反演是不稳定的或非唯一的，尤其是在存在噪声的情况下。本练习通过演示吉洪诺夫正则化 (Tikhonov regularization) 如何稳定土壤水分雷达数据的反演过程，深入探讨了这一根本性挑战。通过探索偏差和方差之间的权衡 ，您将深入了解如何利用先验信息来获得具有物理意义的解。",
            "id": "3848656",
            "problem": "您的任务是论证为何反演土壤水分的归一化雷达散射截面是不适定的，以及吉洪诺夫正则化如何稳定该反演过程。考虑一个简化的粗分辨率合成孔径雷达（SAR）观测模型，其中多个精细尺度的土壤水分状态在一个雷达足迹内混合。以线性单位表示的归一化雷达散射截面（常写作 $\\sigma^{0}$）被建模为精细尺度土壤水分状态与加性噪声的线性混合。该估计过程借助一个从光学光谱指数（例如，对植被敏感的指数）派生的先验，该先验被视为土壤水分高斯先验的均值。\n\n假设以下模型和定义为基本出发点：\n- 正演模型为 $y = H m + \\varepsilon$，其中 $y \\in \\mathbb{R}^{p}$ 是观测到的粗分辨率归一化雷达散射截面值（线性单位），$H \\in \\mathbb{R}^{p \\times n}$ 是一个已知的混合/灵敏度矩阵，$m \\in \\mathbb{R}^{n}$ 是未知的精细尺度体积土壤水分状态（以 $\\mathrm{m^{3}/m^{3}}$ 表示），$\\varepsilon \\sim \\mathcal{N}(0, \\sigma^{2} I_{p})$ 是加性高斯噪声，其方差为 $\\sigma^{2}$（以线性后向散射单位计）。\n- 从光学光谱数据派生的先验表示为高斯先验 $m \\sim \\mathcal{N}(m_{0}, \\tau^{2} I_{n})$，其中 $m_{0} \\in \\mathbb{R}^{n}$ 是给定的。正则化参数为 $\\lambda = \\sigma^{2}/\\tau^{2}$，惩罚算子为单位矩阵，对应于以 $m_{0}$ 为中心的零阶吉洪诺夫正则化。\n- 不适定性源于 $p  n$ 且 $H$ 的列向量区分度不高，这使得反演对噪声敏感并导致解的非唯一性。\n\n您的任务如下：\n1. 从上述正演模型的高斯似然和高斯先验出发，仅使用线性代数和高斯模型概率论的基本原理，推导出 $m$ 的最大后验（MAP）估计量，该估计量是 $H$、$y$、$m_{0}$ 和 $\\lambda$ 的函数。由此，推导出期望估计偏差 $b_{\\lambda} = \\mathbb{E}[\\hat{m}_{\\lambda}] - m_{\\text{true}}$ 和协方差矩阵 $\\mathrm{Cov}(\\hat{m}_{\\lambda})$ 的表达式，这些表达式是 $H$、$\\sigma^{2}$、$m_{0}$、$m_{\\text{true}}$ 和 $\\lambda$ 的函数。\n2. 处理 $\\lambda = 0$ 的退化情况，使用基于摩尔-彭若斯伪逆的最小范数最小二乘解（适用于欠定系统），并推导出此情况下偏差和协方差的相应表达式。\n3. 实现一个程序，该程序为每个测试用例计算两个作为 $\\lambda$ 的函数的标量诊断指标：偏差向量的欧几里得范数 $\\|b_{\\lambda}\\|_{2}$（单位为 $\\mathrm{m^{3}/m^{3}}$）和协方差矩阵的迹 $\\mathrm{tr}(\\mathrm{Cov}(\\hat{m}_{\\lambda}))$（单位为 $\\mathrm{(m^{3}/m^{3})^{2}}$）。不允许进行蒙特卡洛模拟；请使用步骤 $1$ 和 $2$ 中推导出的闭式表达式。\n\n使用以下测试套件。物理单位如上所述：所有土壤水分值及其偏差的单位必须是 $\\mathrm{m^{3}/m^{3}}$，方差的单位必须是 $\\mathrm{(m^{3}/m^{3})^{2}}$。归一化雷达散射截面在线性单位下是无量纲的。\n\n- 测试用例 1（欠定混合，中等噪声）：\n  - $p = 3$， $n = 5$，\n  - $H = \\begin{bmatrix}\n  0.48   0.46   0.06   0.00   0.00 \\\\\n  0.26   0.22   0.52   0.00   0.00 \\\\\n  0.10   0.12   0.18   0.30   0.30\n  \\end{bmatrix}$，\n  - $m_{\\text{true}} = \\begin{bmatrix} 0.12 \\\\ 0.18 \\\\ 0.22 \\\\ 0.30 \\\\ 0.35 \\end{bmatrix}$，单位为 $\\mathrm{m^{3}/m^{3}}$，\n  - $m_{0} = \\begin{bmatrix} 0.15 \\\\ 0.20 \\\\ 0.25 \\\\ 0.25 \\\\ 0.30 \\end{bmatrix}$，单位为 $\\mathrm{m^{3}/m^{3}}$，\n  - $\\sigma = 0.004$，\n  - $\\lambda$ 值： $[0.0, 0.01, 0.1, 1.0, 10.0, 100.0]$。\n\n- 测试用例 2（相同混合，更高噪声）：\n  - $H$、$m_{\\text{true}}$ 和 $m_{0}$ 与测试用例 1 相同，\n  - $\\sigma = 0.02$，\n  - $\\lambda$ 值： $[1.0, 10.0]$。\n\n- 测试用例 3（更严重的不适定性）：\n  - $p = 3$， $n = 5$，\n  - $H = \\begin{bmatrix}\n  0.50   0.49   0.01   0.00   0.00 \\\\\n  0.25   0.245   0.505   0.00   0.00 \\\\\n  0.125   0.1225   0.2525   0.25   0.25\n  \\end{bmatrix}$，\n  - $m_{\\text{true}} = \\begin{bmatrix} 0.12 \\\\ 0.18 \\\\ 0.22 \\\\ 0.30 \\\\ 0.35 \\end{bmatrix}$，单位为 $\\mathrm{m^{3}/m^{3}}$，\n  - $m_{0} = \\begin{bmatrix} 0.15 \\\\ 0.20 \\\\ 0.25 \\\\ 0.25 \\\\ 0.30 \\end{bmatrix}$，单位为 $\\mathrm{m^{3}/m^{3}}$，\n  - $\\sigma = 0.004$，\n  - $\\lambda$ 值： $[0.0, 0.1, 1000.0]$。\n\n您的程序必须：\n- 对每个测试用例及其列表中的每个 $\\lambda$，使用步骤 $1$ 和 $2$ 中推导的解析表达式计算诊断对 $\\left(\\|b_{\\lambda}\\|_{2}, \\mathrm{tr}(\\mathrm{Cov}(\\hat{m}_{\\lambda}))\\right)$。\n- 将所有给定测试用例的结果汇总为单行输出，格式如下：一个列表的列表，其中每个内部列表对应一个测试用例，并包含该用例中每个 $\\lambda$ 的三个数字组成的列表 $\\left[\\lambda, \\|b_{\\lambda}\\|_{2}, \\mathrm{tr}(\\mathrm{Cov}(\\hat{m}_{\\lambda}))\\right]$。例如，输出必须类似于 $[[[\\lambda_{1},b_{1},v_{1}],\\ldots],[\\ldots],[\\ldots]]$，所有数字均为十进制形式。\n- 将 $\\|b_{\\lambda}\\|_{2}$ 以 $\\mathrm{m^{3}/m^{3}}$ 表示，将 $\\mathrm{tr}(\\mathrm{Cov}(\\hat{m}_{\\lambda}))$ 以 $\\mathrm{(m^{3}/m^{3})^{2}}$ 表示。\n\n最终输出必须是包含所描述的确切列表结构的单行内容，不含任何附加文本。不允许进行任何随机化；解必须完全由给定的输入确定性地得出。",
            "solution": "我们从线性正演模型 $y = H m + \\varepsilon$（其中 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^{2} I_{p})$）开始。$y$ 在给定 $m$ 下的似然是高斯的，均值为 $H m$，协方差为 $\\sigma^{2} I_{p}$。基于光学光谱信息的先验表示为 $m \\sim \\mathcal{N}(m_{0}, \\tau^{2} I_{n})$。最大后验（MAP）估计量通过最大化后验密度得到，这等价于最小化负对数后验。在不考虑与 $m$ 无关的加性常数的情况下，目标函数为\n$$\nJ(m) = \\frac{1}{\\sigma^{2}} \\| H m - y \\|_{2}^{2} + \\frac{1}{\\tau^{2}} \\| m - m_{0} \\|_{2}^{2}.\n$$\n使用正则化参数 $\\lambda = \\sigma^{2}/\\tau^{2}$，该式（在不考虑一个常数因子的情况下）变为零阶吉洪诺夫目标函数\n$$\n\\tilde{J}(m) = \\| H m - y \\|_{2}^{2} + \\lambda \\| m - m_{0} \\|_{2}^{2}.\n$$\n对 $m$ 求梯度并令其为零，得到正规方程\n$$\n(H^{\\top} H + \\lambda I_{n}) m = H^{\\top} y + \\lambda m_{0}.\n$$\n假设 $\\lambda > 0$，系数矩阵 $H^{\\top} H + \\lambda I_{n}$ 是正定的，因此可逆。MAP估计量为\n$$\n\\hat{m}_{\\lambda} = (H^{\\top} H + \\lambda I_{n})^{-1} (H^{\\top} y + \\lambda m_{0}).\n$$\n为计算偏差，代入 $y = H m_{\\text{true}} + \\varepsilon$ 并对 $\\varepsilon$ 求期望：\n$$\n\\mathbb{E}[\\hat{m}_{\\lambda}] = (H^{\\top} H + \\lambda I_{n})^{-1} (H^{\\top} H\\, m_{\\text{true}} + \\lambda m_{0}).\n$$\n因此，偏差向量为\n$$\nb_{\\lambda} = \\mathbb{E}[\\hat{m}_{\\lambda}] - m_{\\text{true}} = \\left[(H^{\\top} H + \\lambda I_{n})^{-1} (H^{\\top} H) - I_{n}\\right] m_{\\text{true}} + (H^{\\top} H + \\lambda I_{n})^{-1} \\lambda (m_{0} - m_{\\text{true}}).\n$$\n使用恒等式 $(H^{\\top} H + \\lambda I_{n})^{-1} (H^{\\top} H) = I_{n} - \\lambda (H^{\\top} H + \\lambda I_{n})^{-1}$，上式可简化为\n$$\nb_{\\lambda} = \\lambda (H^{\\top} H + \\lambda I_{n})^{-1} (m_{0} - m_{\\text{true}}).\n$$\n因此，当 $m_{0} = m_{\\text{true}}$ 时，偏差为零；而对于有偏的先验，偏差的大小随 $\\lambda$ 的增加而增加。\n\n$\\hat{m}_{\\lambda}$ 的协方差可以从其与 $y$ 的线性关系中得出：\n$$\n\\hat{m}_{\\lambda} = (H^{\\top} H + \\lambda I_{n})^{-1} H^{\\top} y + (H^{\\top} H + \\lambda I_{n})^{-1} \\lambda m_{0}.\n$$\n第二项是确定性的，所以\n$$\n\\mathrm{Cov}(\\hat{m}_{\\lambda}) = (H^{\\top} H + \\lambda I_{n})^{-1} H^{\\top} \\mathrm{Cov}(y) H (H^{\\top} H + \\lambda I_{n})^{-1}.\n$$\n由于 $\\mathrm{Cov}(y) = \\sigma^{2} I_{p}$，我们得到\n$$\n\\mathrm{Cov}(\\hat{m}_{\\lambda}) = \\sigma^{2} (H^{\\top} H + \\lambda I_{n})^{-1} H^{\\top} H (H^{\\top} H + \\lambda I_{n})^{-1}.\n$$\n这些表达式量化了随着 $\\lambda$ 增大而带来的方差减小，其代价是偏差向 $m_{0}$ 的增加。\n\n对于 $\\lambda = 0$ 的退化情况，优化问题简化为最小二乘法，由于 $p  n$，可能存在无限多个解。常规选择是由摩尔-彭若斯伪逆给出的最小范数解：\n$$\n\\hat{m}_{0} = H^{+} y \\quad \\text{其中} \\quad H^{+} = H^{\\top} (H H^{\\top})^{-1},\n$$\n假设 $H$ 具有满行秩（即 $H H^{\\top}$ 可逆，在给定的测试用例中此条件满足）。其期望和协方差为\n$$\n\\mathbb{E}[\\hat{m}_{0}] = H^{+} H m_{\\text{true}}, \\quad \\mathrm{Cov}(\\hat{m}_{0}) = \\sigma^{2} H^{+} (H^{+})^{\\top}.\n$$\n因此，在 $\\lambda = 0$ 时的偏差为\n$$\nb_{0} = \\mathbb{E}[\\hat{m}_{0}] - m_{\\text{true}} = (H^{+} H - I_{n}) m_{\\text{true}},\n$$\n只要 $m_{\\text{true}}$ 在 $H$ 的零空间中有分量，该偏差就非零；这体现了不适定性以及雷达混合中未观测到的分量的不可辨识性。\n\n所要求的诊断指标是偏差的欧几里得范数 $\\|b_{\\lambda}\\|_{2}$（单位 $\\mathrm{m^{3}/m^{3}}$）和协方差的迹 $\\mathrm{tr}(\\mathrm{Cov}(\\hat{m}_{\\lambda}))$（单位 $\\mathrm{(m^{3}/m^{3})^{2}}$）。对于 $\\lambda > 0$，我们从上述闭式解计算 $b_{\\lambda}$ 和 $\\mathrm{Cov}(\\hat{m}_{\\lambda})$。对于 $\\lambda = 0$，我们使用基于伪逆的公式。这样，无需任何模拟，即可为每个测试用例和每个指定的 $\\lambda$ 生成确定性结果。\n\n为了高效且稳定地实现：\n- 对于 $\\lambda > 0$，通过求解线性系统 $(H^{\\top} H + \\lambda I_{n})$ 而不是在可能的情况下显式地构造矩阵的逆。由于 $n = 5$，通过求解与单位矩阵的方程来计算显式逆在这里也是数值稳定的。\n- 对于 $\\lambda = 0$，在给定满行秩的情况下，通过 $H^{\\top} (H H^{\\top})^{-1}$ 计算 $H^{+}$。然后直接计算 $b_{0}$ 和 $\\mathrm{Cov}(\\hat{m}_{0})$。\n\n程序评估所有测试用例：\n- 测试用例 1 演示了欠定、中等噪声的情景，使用一系列 $\\lambda$ 值，包括 $\\lambda = 0$ 来展示不稳定性和方差，以及较大的 $\\lambda$ 来显示以偏差增加为代价的稳定性。\n- 测试用例 2 增加了 $\\sigma$ 以表明方差与 $\\sigma^{2}$ 成比例，并且需要更大的 $\\lambda$ 来稳定。\n- 测试用例 3 使用了一个条件更差的 $H$ 来强调列向量区分度差的影响以及 $\\lambda$ 的作用。\n\n输出将每个测试用例的结果，即由三元组 $[\\lambda, \\|b_{\\lambda}\\|_{2}, \\mathrm{tr}(\\mathrm{Cov}(\\hat{m}_{\\lambda}))]$ 组成的列表，汇总到一个顶层列表中，并按要求打印在单行上。",
            "answer": "```python\nimport numpy as np\nimport json\n\ndef bias_and_var_metrics(H, sigma, m_true, m0, lambdas):\n    \"\"\"\n    Compute [lambda, ||bias||2, trace(covariance)] for each lambda.\n    Units:\n      - ||bias||2 in m^3/m^3\n      - trace(covariance) in (m^3/m^3)^2\n    \"\"\"\n    H = np.array(H, dtype=float)\n    m_true = np.array(m_true, dtype=float).reshape(-1, 1)\n    m0 = np.array(m0, dtype=float).reshape(-1, 1)\n    p, n = H.shape\n\n    Ht = H.T\n    HtH = Ht @ H\n    I_n = np.eye(n)\n\n    results = []\n\n    # Precompute pseudoinverse components for lambda=0 case\n    # Assume full row rank: H H^T invertible\n    HHt = H @ Ht\n    # Slight regularization if needed (not expected for given test cases)\n    HHt_inv = np.linalg.inv(HHt)\n    H_pinv = Ht @ HHt_inv  # Moore-Penrose for full row-rank H\n\n    for lam in lambdas:\n        if lam == 0.0:\n            # Minimum-norm LS solution\n            # Bias: (H^+ H - I) m_true\n            # Cov: sigma^2 H^+ (H^+)^T\n            P = H_pinv @ H  # projector onto row-space of H\n            bias_vec = (P - I_n) @ m_true\n            cov = (sigma ** 2) * (H_pinv @ H_pinv.T)\n        else:\n            A = HtH + lam * I_n\n            # Compute A_inv stably by solving A X = I\n            A_inv = np.linalg.inv(A)\n\n            # Bias: lam * A_inv @ (m0 - m_true)\n            bias_vec = lam * (A_inv @ (m0 - m_true))\n\n            # Cov: sigma^2 * A_inv @ HtH @ A_inv\n            cov = (sigma ** 2) * (A_inv @ HtH @ A_inv)\n\n        bias_norm = float(np.linalg.norm(bias_vec, 2))\n        var_trace = float(np.trace(cov))\n        results.append([float(lam), bias_norm, var_trace])\n\n    return results\n\ndef solve():\n    # Test case 1\n    H1 = [\n        [0.48, 0.46, 0.06, 0.00, 0.00],\n        [0.26, 0.22, 0.52, 0.00, 0.00],\n        [0.10, 0.12, 0.18, 0.30, 0.30],\n    ]\n    m_true = [0.12, 0.18, 0.22, 0.30, 0.35]  # m^3/m^3\n    m0 = [0.15, 0.20, 0.25, 0.25, 0.30]      # m^3/m^3\n\n    sigma1 = 0.004\n    lambdas1 = [0.0, 0.01, 0.1, 1.0, 10.0, 100.0]\n\n    # Test case 2: higher noise\n    sigma2 = 0.02\n    lambdas2 = [1.0, 10.0]\n\n    # Test case 3: more severe ill-conditioning\n    H2 = [\n        [0.50, 0.49, 0.01, 0.00, 0.00],\n        [0.25, 0.245, 0.505, 0.00, 0.00],\n        [0.125, 0.1225, 0.2525, 0.25, 0.25],\n    ]\n    sigma3 = 0.004\n    lambdas3 = [0.0, 0.1, 1000.0]\n\n    res1 = bias_and_var_metrics(H1, sigma1, m_true, m0, lambdas1)\n    res2 = bias_and_var_metrics(H1, sigma2, m_true, m0, lambdas2)\n    res3 = bias_and_var_metrics(H2, sigma3, m_true, m0, lambdas3)\n\n    all_results = [res1, res2, res3]\n    print(json.dumps(all_results))\n\nsolve()\n```"
        }
    ]
}