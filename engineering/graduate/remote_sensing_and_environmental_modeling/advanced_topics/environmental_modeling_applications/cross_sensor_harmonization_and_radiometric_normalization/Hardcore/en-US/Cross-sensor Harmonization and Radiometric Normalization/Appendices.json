{
    "hands_on_practices": [
        {
            "introduction": "The first step in comparing data from different satellite sensors is to convert their raw measurements into a standardized physical quantity. This practice guides you through the fundamental derivation of Top-of-Atmosphere (TOA) reflectance from spectral radiance, grounding the process in first principles of physics . By normalizing for solar geometry and the variable Earth-Sun distance, you will transform a sensor-specific measurement into an intrinsic property of the Earth-atmosphere system, creating a solid foundation for cross-sensor analysis.",
            "id": "3804140",
            "problem": "A regional water body is observed quasi-simultaneously by two orbital imaging spectrometers having different radiometric calibrations and spectral response functions. To enable cross-sensor harmonization, both instruments’ observations are converted to Top-of-Atmosphere (TOA) reflectance, defined as a unitless quantity that normalizes out the effects of Solar geometry and Earth–Sun distance. Assume a spectrally narrow band centered at $0.65\\,\\mathrm{\\mu m}$ with negligible variation in extraterrestrial solar spectral irradiance across the band, and assume the water surface is locally approximated as Lambertian so that directional effects described by the Bidirectional Reflectance Distribution Function (BRDF) can be neglected for the derivation.\n\nStarting only from the following well-tested bases:\n- The definition of spectral radiance $L_{\\lambda}$ and spectral irradiance $E_{\\lambda}$, and the definition of reflectance as the ratio of upwelling to downwelling flux for a Lambertian surface.\n- Conservation of energy for a Lambertian surface relating $L_{\\lambda}$, $E_{\\lambda}$, and reflectance through an angular integration over the hemisphere.\n- The inverse-square law for Solar radiation, which states that irradiance scales as $1/d^{2}$ with Earth–Sun distance $d$ (in astronomical units).\n\nDerive the expression used to compute TOA reflectance $R_{\\mathrm{TOA}}$ from spectral radiance $L_{\\lambda}$, extraterrestrial spectral irradiance at one astronomical unit $E_{0,\\lambda}$, Solar zenith angle $\\theta_{s}$, and Earth–Sun distance $d$, and then compute $R_{\\mathrm{TOA}}$ numerically for the following observation by Sensor A:\n- $L_{\\lambda} = 7.5\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$,\n- $E_{0,\\lambda} = 1850\\,\\mathrm{W\\,m^{-2}\\,\\mu m^{-1}}$,\n- $\\theta_{s} = 31^{\\circ}$ (angle given in degrees),\n- $d = 0.989$ (dimensionless, in astronomical units).\n\nNext, quantify the effect of a $1\\%$ error in Earth–Sun distance on the computed reflectance by reporting the fractional change, defined as $(R' - R)/R$, where $R'$ is the reflectance computed with $d' = 1.01\\,d$.\n\nExpress $R_{\\mathrm{TOA}}$ as a unitless decimal between $0$ and $1$, and express the fractional change as a unitless decimal. Round both reported quantities to four significant figures.",
            "solution": "The solution involves three main steps: first, deriving the formula for Top-of-Atmosphere (TOA) reflectance from fundamental radiometric principles; second, applying this formula to compute the TOA reflectance for the given sensor data; and third, quantifying the effect of a known error in the Earth-Sun distance on the result.\n\n**Part 1: Derivation of the TOA Reflectance Expression**\n\nThe TOA reflectance, $R_{\\mathrm{TOA}}$, is defined as the ratio of the solar radiation flux reflected by the Earth-atmosphere system to the solar radiation flux incident upon it. Since the problem specifies a narrow spectral band, we use spectral quantities.\n\n1.  The downwelling spectral irradiance at the top of the atmosphere, $E_{\\lambda, \\text{down}}$, is the solar flux incident on a horizontal surface. It is derived from the extraterrestrial solar spectral irradiance at a mean Earth-Sun distance of one astronomical unit ($1$ AU), $E_{0,\\lambda}$. We must account for two factors:\n    *   The actual Earth-Sun distance, $d$, in astronomical units. According to the inverse-square law, irradiance scales as $1/d^2$. The solar flux at distance $d$ is therefore $\\frac{E_{0,\\lambda}}{d^2}$. This is the flux on a surface oriented perpendicular to the sun's rays.\n    *   The solar zenith angle, $\\theta_s$. To find the irradiance on a horizontal surface at the TOA, we must project this perpendicular flux using the cosine of the incidence angle, which is $\\theta_s$.\n    Combining these, the incident spectral irradiance is:\n    $$E_{\\lambda, \\text{down}} = \\frac{E_{0,\\lambda}}{d^2} \\cos(\\theta_s)$$\n\n2.  The upwelling flux is characterized by the upwelling spectral radiance, $L_{\\lambda}$, measured by the satellite sensor. To compute reflectance, this radiance must be converted to a spectral exitance, $M_{\\lambda}$ (flux per unit area). The problem states we can model the Earth-atmosphere system as a Lambertian surface. For a Lambertian radiator/reflector, the radiance $L_{\\lambda}$ is isotropic (uniform in all directions), and the spectral exitance is related to the spectral radiance by:\n    $$M_{\\lambda} = \\pi L_{\\lambda}$$\n    This relation arises from integrating the radiance over the entire viewing hemisphere: $M_{\\lambda} = \\int_{\\Omega} L_{\\lambda} \\cos(\\theta) d\\Omega = L_{\\lambda} \\int_{0}^{2\\pi} \\int_{0}^{\\pi/2} \\cos(\\theta)\\sin(\\theta)d\\theta d\\phi = \\pi L_{\\lambda}$.\n\n3.  The TOA reflectance, $R_{\\mathrm{TOA}}$, is the ratio of the upwelling spectral exitance to the downwelling spectral irradiance. As the problem is for a single narrow band, we can drop the $\\lambda$ subscript for notational simplicity.\n    $$R_{\\mathrm{TOA}} = \\frac{M_{\\lambda}}{E_{\\lambda, \\text{down}}}$$\n    Substituting the expressions from steps $1$ and $2$:\n    $$R_{\\mathrm{TOA}} = \\frac{\\pi L_{\\lambda}}{\\frac{E_{0,\\lambda}}{d^2} \\cos(\\theta_s)}$$\n    Rearranging gives the final derived expression for TOA reflectance:\n    $$R_{\\mathrm{TOA}} = \\frac{\\pi L_{\\lambda} d^2}{E_{0,\\lambda} \\cos(\\theta_s)}$$\n\n**Part 2: Numerical Computation of TOA Reflectance**\n\nWe now compute $R_{\\mathrm{TOA}}$ using the provided data for Sensor A:\n*   $L_{\\lambda} = 7.5\\,\\mathrm{W\\,m^{-2}\\,sr^{-1}\\,\\mu m^{-1}}$\n*   $E_{0,\\lambda} = 1850\\,\\mathrm{W\\,m^{-2}\\,\\mu m^{-1}}$\n*   $\\theta_{s} = 31^{\\circ}$\n*   $d = 0.989$\n\nSubstituting these values into our derived formula:\n$$R_{\\mathrm{TOA}} = \\frac{\\pi (7.5) (0.989)^2}{(1850) \\cos(31^{\\circ})}$$\nWe perform the calculation:\n$$R_{\\mathrm{TOA}} = \\frac{(3.14159...) \\times (7.5) \\times (0.978121)}{(1850) \\times (0.857167...)}$$\n$$R_{\\mathrm{TOA}} = \\frac{23.0454...}{1585.759...} \\approx 0.0145326$$\nRounding to four significant figures, we get:\n$$R_{\\mathrm{TOA}} \\approx 0.01453$$\n\n**Part 3: Quantifying the Effect of an Error in Earth-Sun Distance**\n\nWe are asked to find the fractional change, $\\frac{R' - R}{R}$, where $R$ is the reflectance at distance $d$ and $R'$ is the reflectance at a new distance $d' = 1.01\\,d$.\n\nFrom the derived formula, we can see that $R_{\\mathrm{TOA}}$ is proportional to the square of the distance, $d^2$. Let $C$ be the constant of proportionality, such that $C = \\frac{\\pi L_{\\lambda}}{E_{0,\\lambda} \\cos(\\theta_s)}$.\nThen, the original reflectance is $R = C d^2$.\nThe new reflectance $R'$ at distance $d' = 1.01\\,d$ is:\n$$R' = C (d')^2 = C (1.01\\,d)^2 = C (1.01)^2 d^2 = (1.01)^2 (C d^2) = (1.01)^2 R$$\nNow, we compute the fractional change:\n$$\\frac{R' - R}{R} = \\frac{(1.01)^2 R - R}{R} = \\frac{R((1.01)^2 - 1)}{R} = (1.01)^2 - 1$$\nCalculating the numerical value:\n$$(1.01)^2 - 1 = 1.0201 - 1 = 0.0201$$\nThe problem requires this result to be reported to four significant figures. To express $0.0201$ with four significant figures, we add a trailing zero.\n$$\\text{Fractional Change} = 0.02010$$\nThis represents a $2.01\\%$ increase in the computed reflectance due to a $1\\%$ increase in the assumed Earth-Sun distance.",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.01453 & 0.02010 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Even after converting to reflectance, observations from different satellites are not directly comparable if their viewing and illumination geometries differ. This exercise tackles this challenge by introducing the Bidirectional Reflectance Distribution Function (BRDF), which models the anisotropic nature of surface reflectance . You will apply a kernel-driven BRDF model to estimate and apply the correction needed to harmonize a Landsat observation to the geometry of a Sentinel-2 acquisition, a crucial skill for generating consistent time-series data from multiple sensors.",
            "id": "3804144",
            "problem": "You are given two satellite observation geometries corresponding to Landsat and Sentinel-2 for the same surface target, along with a semi-empirical Bidirectional Reflectance Distribution Function (BRDF) parameterization. The task is to estimate the additive BRDF correction needed to harmonize the Landsat-measured surface reflectance to the Sentinel-2 viewing and illumination geometry using a kernel-driven model. This harmonization is part of cross-sensor radiometric normalization.\n\nFundamental base and definitions:\n- The Bidirectional Reflectance Distribution Function (BRDF) $f_r(\\theta_s,\\theta_v,\\phi)$ characterizes the directional dependence of surface reflectance, where $\\theta_s$ is the solar zenith angle, $\\theta_v$ is the view zenith angle, and $\\phi$ is the relative azimuth angle between the solar and viewing directions.\n- In a kernel-driven linear BRDF model, the surface reflectance factor $R$ for a given geometry $(\\theta_s,\\theta_v,\\phi)$ is approximated by\n$$\nR(\\theta_s,\\theta_v,\\phi) = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s,\\theta_v,\\phi),\n$$\nwhere $f_{\\text{iso}}$ is the isotropic (Lambertian) coefficient and $f_{\\text{vol}}$ is the volumetric scattering coefficient. The volumetric kernel $K_{\\text{vol}}$ is taken as the Ross–Thick kernel:\n$$\n\\cos \\xi = \\cos \\theta_s \\cos \\theta_v + \\sin \\theta_s \\sin \\theta_v \\cos \\phi,\n$$\n$$\n\\xi = \\arccos(\\cos \\xi),\n$$\n$$ K_{\\text{vol}}(\\theta_s,\\theta_v,\\phi) = \\left(\\frac{\\pi}{2} - \\xi\\right)\\cos \\xi + \\sin \\xi - \\frac{\\pi}{4}. $$\nThis kernel emerges from the spherical law of cosines applied to the phase angle $\\xi$ between solar and viewing directions and is widely used to model volume scattering in vegetation canopies.\n\nObjective:\n- For each test case, compute the harmonized reflectance $R^{\\text{harm}}$ by applying the additive BRDF correction to the Landsat-measured reflectance $R^{L}_{\\text{meas}}$, transferring it to the Sentinel-2 geometry. Use the fact that the isotropic term $f_{\\text{iso}}$ is geometry-independent and the anisotropic (volumetric) dependence is captured by $K_{\\text{vol}}$.\n\nInputs and units:\n- Angles $\\theta_s$, $\\theta_v$, and $\\phi$ are provided in degrees. Convert degrees to radians using $\\text{radians} = \\text{degrees} \\times \\pi/180$.\n- Reflectance is a dimensionless ratio and must be expressed as a decimal fraction.\n- The final harmonized reflectance values must be reported as floats rounded to $6$ decimal places.\n\nComputation requirement:\n- For each test case with Landsat geometry $(\\theta_s^L,\\theta_v^L,\\phi^L)$, Sentinel-2 geometry $(\\theta_s^S,\\theta_v^S,\\phi^S)$, coefficients $(f_{\\text{iso}}, f_{\\text{vol}})$, and Landsat-measured reflectance $R_{\\text{meas}}^{L}$, compute:\n  1. $K_{\\text{vol}}^L = K_{\\text{vol}}(\\theta_s^L,\\theta_v^L,\\phi^L)$,\n  2. $K_{\\text{vol}}^S = K_{\\text{vol}}(\\theta_s^S,\\theta_v^S,\\phi^S)$,\n  3. $R_{\\text{model}}^L = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}^L$,\n  4. $R_{\\text{model}}^S = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}^S$,\n  5. $R^{\\text{harm}} = R_{\\text{meas}}^{L} + (R_{\\text{model}}^S - R_{\\text{model}}^L)$.\n\nTest suite:\nProvide computations for the following five test cases. All angles are in degrees, and reflectance is dimensionless:\n\n- Test case $1$ (general case): $\\theta_s^L = 30$, $\\theta_v^L = 7$, $\\phi^L = 20$; $\\theta_s^S = 32$, $\\theta_v^S = 5$, $\\phi^S = 25$; $f_{\\text{iso}} = 0.05$, $f_{\\text{vol}} = 0.10$; $R_{\\text{meas}}^{L} = 0.18$.\n- Test case $2$ (boundary, identical geometries): $\\theta_s^L = 35$, $\\theta_v^L = 10$, $\\phi^L = 60$; $\\theta_s^S = 35$, $\\theta_v^S = 10$, $\\phi^S = 60$; $f_{\\text{iso}} = 0.03$, $f_{\\text{vol}} = 0.08$; $R_{\\text{meas}}^{L} = 0.20$.\n- Test case $3$ (edge, nadir vs off-nadir): $\\theta_s^L = 10$, $\\theta_v^L = 20$, $\\phi^L = 180$; $\\theta_s^S = 10$, $\\theta_v^S = 0$, $\\phi^S = 180$; $f_{\\text{iso}} = 0.04$, $f_{\\text{vol}} = 0.12$; $R_{\\text{meas}}^{L} = 0.10$.\n- Test case $4$ (edge, large solar zenith): $\\theta_s^L = 70$, $\\theta_v^L = 15$, $\\phi^L = 120$; $\\theta_s^S = 65$, $\\theta_v^S = 10$, $\\phi^S = 100$; $f_{\\text{iso}} = 0.06$, $f_{\\text{vol}} = 0.09$; $R_{\\text{meas}}^{L} = 0.15$.\n- Test case $5$ (edge, extreme relative azimuth change): $\\theta_s^L = 45$, $\\theta_v^L = 10$, $\\phi^L = 0$; $\\theta_s^S = 45$, $\\theta_v^S = 10$, $\\phi^S = 180$; $f_{\\text{iso}} = 0.05$, $f_{\\text{vol}} = 0.11$; $R_{\\text{meas}}^{L} = 0.22$.\n\nFinal output format:\nYour program should produce a single line of output containing the harmonized reflectance results for the five test cases as a comma-separated list enclosed in square brackets, with each value rounded to $6$ decimal places (e.g., $\\text{[result1,result2,result3,result4,result5]}$).",
            "solution": "The objective is to compute a BRDF (Bidirectional Reflectance Distribution Function) correction to harmonize a surface reflectance measurement from a Landsat sensor ($R_{\\text{meas}}^{L}$) to the viewing and illumination geometry of a Sentinel-2 sensor. This is achieved using a simplified linear kernel-driven BRDF model.\n\nThe model approximates the surface reflectance factor, $R$, as a sum of an isotropic component and a volumetric scattering component:\n$$\nR(\\theta_s, \\theta_v, \\phi) = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s, \\theta_v, \\phi)\n$$\nHere, $f_{\\text{iso}}$ is the isotropic scattering coefficient, representing Lambertian reflectance, and $f_{\\text{vol}}$ is the volumetric scattering coefficient, which weights the contribution of the volumetric scattering kernel, $K_{\\text{vol}}$. The angles $\\theta_s$, $\\theta_v$, and $\\phi$ represent the solar zenith, view zenith, and relative azimuth angles, respectively.\n\nThe volumetric scattering is described by the Ross–Thick kernel, which is derived from radiative transfer theory for a homogeneous plant canopy. Its formulation depends on the phase angle, $\\xi$, between the illumination and viewing vectors. The cosine of the phase angle is given by the spherical law of cosines:\n$$\n\\cos \\xi = \\cos \\theta_s \\cos \\theta_v + \\sin \\theta_s \\sin \\theta_v \\cos \\phi\n$$\nThe phase angle $\\xi$ is then $\\xi = \\arccos(\\cos \\xi)$. The Ross–Thick kernel, $K_{\\text{vol}}$, is then calculated as:\n$$\nK_{\\text{vol}}(\\theta_s, \\theta_v, \\phi) = \\frac{(\\frac{\\pi}{2} - \\xi)\\cos \\xi + \\sin \\xi}{\\cos \\theta_s + \\cos \\theta_v} - \\frac{\\pi}{4}\n$$\nHowever, the problem statement provides a slightly simplified, but common, form of the Ross-Thick kernel which omits the normalization factor $(\\cos \\theta_s + \\cos \\theta_v)^{-1}$. We will strictly adhere to the provided definition:\n$$\nK_{\\text{vol}}(\\theta_s,\\theta_v,\\phi) = \\left(\\frac{\\pi}{2} - \\xi\\right)\\cos \\xi + \\sin \\xi - \\frac{\\pi}{4}\n$$\nAll angle inputs are provided in degrees and must be converted to radians for use in trigonometric functions, via the relation: $\\text{radians} = \\text{degrees} \\times (\\pi / 180)$.\n\nThe harmonization process is based on an additive correction. The core assumption is that the model accurately captures the *change* in reflectance due to the change in geometry, even if it does not perfectly predict the absolute reflectance. The harmonized reflectance, $R^{\\text{harm}}$, is calculated by adjusting the measured Landsat reflectance, $R_{\\text{meas}}^{L}$, by the difference in the modeled reflectance between the Sentinel-2 geometry and the Landsat geometry.\nLet the Landsat and Sentinel-2 geometries be $(\\theta_s^L, \\theta_v^L, \\phi^L)$ and $(\\theta_s^S, \\theta_v^S, \\phi^S)$, respectively. The model-predicted reflectances for each geometry are:\n$$\nR_{\\text{model}}^L = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s^L, \\theta_v^L, \\phi^L)\n$$\n$$\nR_{\\text{model}}^S = f_{\\text{iso}} + f_{\\text{vol}}\\,K_{\\text{vol}}(\\theta_s^S, \\theta_v^S, \\phi^S)\n$$\nThe harmonized reflectance is then given by:\n$$\nR^{\\text{harm}} = R_{\\text{meas}}^{L} + (R_{\\text{model}}^S - R_{\\text{model}}^L)\n$$\nBy substituting the model equations, we can simplify this expression. The isotropic term, $f_{\\text{iso}}$, being independent of geometry, cancels out:\n$$\nR^{\\text{harm}} = R_{\\text{meas}}^{L} + (f_{\\text{iso}} + f_{\\text{vol}}K_{\\text{vol}}^S) - (f_{\\text{iso}} + f_{\\text{vol}}K_{\\text{vol}}^L)\n$$\n$$\nR^{\\text{harm}} = R_{\\text{meas}}^{L} + f_{\\text{vol}}(K_{\\text{vol}}^S - K_{\\text{vol}}^L)\n$$\nThis simplified formula is computationally more direct and is used for the solution. The procedure for each test case is as follows:\n1.  For the given Landsat geometry $(\\theta_s^L, \\theta_v^L, \\phi^L)$, compute the kernel value $K_{\\text{vol}}^L$.\n2.  For the given Sentinel-2 geometry $(\\theta_s^S, \\theta_v^S, \\phi^S)$, compute the kernel value $K_{\\text{vol}}^S$.\n3.  Using the provided coefficients $f_{\\text{vol}}$ and the measured Landsat reflectance $R_{\\text{meas}}^L$, compute the harmonized reflectance $R^{\\text{harm}}$ using the simplified formula above.\n4.  Round the final result to $6$ decimal places as required.\nThis process will be systematically applied to each of the five test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the harmonized surface reflectance for a series of test cases based on a kernel-driven BRDF model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: ((theta_s_L, theta_v_L, phi_L), (theta_s_S, theta_v_S, phi_S), f_iso, f_vol, R_meas_L)\n    test_cases = [\n        # Test case 1 (general case)\n        ((30, 7, 20), (32, 5, 25), 0.05, 0.10, 0.18),\n        # Test case 2 (boundary, identical geometries)\n        ((35, 10, 60), (35, 10, 60), 0.03, 0.08, 0.20),\n        # Test case 3 (edge, nadir vs off-nadir)\n        ((10, 20, 180), (10, 0, 180), 0.04, 0.12, 0.10),\n        # Test case 4 (edge, large solar zenith)\n        ((70, 15, 120), (65, 10, 100), 0.06, 0.09, 0.15),\n        # Test case 5 (edge, extreme relative azimuth change)\n        ((45, 10, 0), (45, 10, 180), 0.05, 0.11, 0.22),\n    ]\n\n    def calculate_k_vol(theta_s_deg, theta_v_deg, phi_deg):\n        \"\"\"\n        Calculates the Ross–Thick volumetric kernel K_vol.\n\n        Args:\n            theta_s_deg (float): Solar zenith angle in degrees.\n            theta_v_deg (float): View zenith angle in degrees.\n            phi_deg (float): Relative azimuth angle in degrees.\n\n        Returns:\n            float: The value of the K_vol kernel.\n        \"\"\"\n        # Convert degrees to radians\n        theta_s = np.deg2rad(theta_s_deg)\n        theta_v = np.deg2rad(theta_v_deg)\n        phi = np.deg2rad(phi_deg)\n\n        # Calculate the cosine of the phase angle (xi)\n        cos_xi = np.cos(theta_s) * np.cos(theta_v) + np.sin(theta_s) * np.sin(theta_v) * np.cos(phi)\n        \n        # Clamp cos_xi to the valid range [-1, 1] for arccos to avoid floating point issues\n        cos_xi = np.clip(cos_xi, -1.0, 1.0)\n        \n        # Calculate the phase angle (xi)\n        xi = np.arccos(cos_xi)\n\n        # Calculate the Ross–Thick kernel as defined in the problem\n        k_vol = (np.pi / 2 - xi) * cos_xi + np.sin(xi) - (np.pi / 4)\n        \n        return k_vol\n\n    results = []\n    for case in test_cases:\n        geom_L, geom_S, f_iso, f_vol, R_meas_L = case\n        theta_s_L, theta_v_L, phi_L = geom_L\n        theta_s_S, theta_v_S, phi_S = geom_S\n\n        # 1. Compute K_vol for Landsat geometry\n        k_vol_L = calculate_k_vol(theta_s_L, theta_v_L, phi_L)\n        \n        # 2. Compute K_vol for Sentinel-2 geometry\n        k_vol_S = calculate_k_vol(theta_s_S, theta_v_S, phi_S)\n        \n        # 3. Compute the harmonized reflectance R_harm\n        # R_harm = R_meas_L + (R_model_S - R_model_L)\n        # R_harm = R_meas_L + (f_iso + f_vol*k_vol_S) - (f_iso + f_vol*k_vol_L)\n        # This simplifies to:\n        r_harm = R_meas_L + f_vol * (k_vol_S - k_vol_L)\n        \n        results.append(r_harm)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A final major source of discrepancy between sensors arises from differences in their Spectral Response Functions (SRFs), which dictate how each instrument 'sees' the spectrum of reflected light. In this computational exercise, you will develop a linear transformation to map the reflectance of one sensor to another by leveraging a training set of diverse, known surface reflectance spectra . This practice demonstrates how to solve the spectral mismatch problem using numerical integration and linear regression, allowing you to quantify the model's performance and understand how its accuracy can vary across different surface types like vegetation and soil.",
            "id": "3804157",
            "problem": "You are given two discrete-band remote sensing instruments with known Spectral Response Functions (SRFs) and a set of physically plausible surface reflectance spectra. The objective is to compute a cross-sensor reflectance mapping and evaluate the class-wise bias for vegetation and soil across multiple scenarios. Use the following fundamental base to derive the computation.\n\nRadiance measured by a band-limited sensor with SRF $S(\\lambda)$ observing a surface with spectral reflectance $\\rho(\\lambda)$ under incident spectral irradiance $I(\\lambda)$ is proportional to the integral of $I(\\lambda)\\rho(\\lambda)$ weighted by $S(\\lambda)$ over wavelength. The effective band reflectance for a sensor $X$ is therefore defined as the weighted average\n$$\nR_X = \\frac{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} \\rho(\\lambda) S_X(\\lambda) I(\\lambda) \\, d\\lambda}{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} S_X(\\lambda) I(\\lambda) \\, d\\lambda}.\n$$\nFor two sensors $A$ and $B$, define a linear cross-sensor mapping $R_B \\approx \\alpha R_A + \\beta$. Determine the mapping coefficients $\\alpha$ and $\\beta$ from a training set of reflectance spectra by minimizing the sum of squared residuals across the training spectra. Then, compute the bias $b = \\hat{R}_B - R_B$ for evaluation spectra in two classes (vegetation and soil), where $\\hat{R}_B = \\alpha R_A + \\beta$ is the mapped reflectance from sensor $A$ to sensor $B$.\n\nAll quantities are dimensionless except wavelength, which must be expressed in nanometers. There is no angle quantity in this problem. The final outputs should be the class-wise biases, which are dimensionless numbers. Use a wavelength grid $\\lambda \\in [400,900]$ in nanometers with $1$ nanometer resolution. Approximations to integrals must be performed numerically using the trapezoidal rule on this grid.\n\nAcronym definitions:\n- Spectral Response Function (SRF): $S(\\lambda)$, the relative sensitivity of a sensor as a function of wavelength.\n- Solar Irradiance (SI): $I(\\lambda)$, the incident spectral irradiance at the surface.\n\nSensor SRFs and irradiance are defined using Gaussian parametric forms:\n- SRF for sensor $X \\in \\{A,B\\}$: $S_X(\\lambda) \\propto \\exp\\!\\left(-\\frac{(\\lambda-\\mu_X)^2}{2\\sigma_X^2}\\right)$, normalized so that the discrete integral over the grid is $1$.\n- Irradiance: $I(\\lambda) = \\exp\\!\\left(-\\frac{(\\lambda-\\mu_I)^2}{2\\sigma_I^2}\\right)$.\n\nReflectance spectra are defined using the following parametric functions, each clipped to the interval $[0,1]$:\n- Vegetation: \n$$\n\\rho_{\\text{veg}}(\\lambda; \\lambda_0, s, a_g) = 0.05 + \\frac{0.45}{1+\\exp\\!\\left(-\\frac{\\lambda-\\lambda_0}{s}\\right)} + a_g \\exp\\!\\left(-\\frac{(\\lambda-550)^2}{2\\cdot 30^2}\\right).\n$$\n- Soil:\n$$\n\\rho_{\\text{soil}}(\\lambda; a, b, a_c) = a + b(\\lambda-400) + a_c \\exp\\!\\left(-\\frac{(\\lambda-700)^2}{2\\cdot 150^2}\\right).\n$$\n- Flat (constant reflectance):\n$$\n\\rho_{\\text{flat}}(\\lambda; c) = c.\n$$\n\nFor each test case below, you must:\n1. Construct $S_A(\\lambda)$, $S_B(\\lambda)$ and $I(\\lambda)$ from the given parameters.\n2. Construct training reflectance spectra and compute $R_A$ and $R_B$ for each training spectrum.\n3. Solve for $\\alpha$ and $\\beta$ by minimizing $\\sum_i \\left(\\alpha R_{A,i} + \\beta - R_{B,i}\\right)^2$ over the training set.\n4. Construct evaluation spectra for vegetation and soil and compute $b_{\\text{veg}}$ and $b_{\\text{soil}}$ using $b = \\alpha R_A + \\beta - R_B$.\n\nUse the following three test cases. In all cases, $\\lambda \\in [400,900]$ nanometers with $1$ nanometer spacing and trapezoidal integration.\n\nTest Case 1 (happy path; red band alignment with moderate mismatch):\n- Irradiance parameters: $\\mu_I = 550$ nanometers, $\\sigma_I = 130$ nanometers.\n- Sensor $A$ SRF parameters: $\\mu_A = 650$ nanometers, $\\sigma_A = 20$ nanometers.\n- Sensor $B$ SRF parameters: $\\mu_B = 660$ nanometers, $\\sigma_B = 25$ nanometers.\n- Training reflectance spectra:\n    - Vegetation 1: $\\lambda_0 = 700$ nanometers, $s = 20$ nanometers, $a_g = 0.08$.\n    - Vegetation 2: $\\lambda_0 = 710$ nanometers, $s = 15$ nanometers, $a_g = 0.10$.\n    - Soil 1: $a = 0.12$, $b = 1.5\\times 10^{-4}$ per nanometer, $a_c = -0.02$.\n    - Soil 2: $a = 0.18$, $b = 1.0\\times 10^{-4}$ per nanometer, $a_c = 0.015$.\n- Evaluation reflectance spectra:\n    - Vegetation eval: $\\lambda_0 = 705$ nanometers, $s = 18$ nanometers, $a_g = 0.09$.\n    - Soil eval: $a = 0.14$, $b = 1.4\\times 10^{-4}$ per nanometer, $a_c = -0.01$.\n\nTest Case 2 (boundary condition; green band alignment):\n- Irradiance parameters: $\\mu_I = 560$ nanometers, $\\sigma_I = 100$ nanometers.\n- Sensor $A$ SRF parameters: $\\mu_A = 550$ nanometers, $\\sigma_A = 30$ nanometers.\n- Sensor $B$ SRF parameters: $\\mu_B = 560$ nanometers, $\\sigma_B = 30$ nanometers.\n- Training reflectance spectra:\n    - Vegetation 1: $\\lambda_0 = 690$ nanometers, $s = 25$ nanometers, $a_g = 0.12$.\n    - Vegetation 2: $\\lambda_0 = 695$ nanometers, $s = 22$ nanometers, $a_g = 0.09$.\n    - Soil 1: $a = 0.10$, $b = 2.0\\times 10^{-4}$ per nanometer, $a_c = -0.02$.\n    - Soil 2: $a = 0.20$, $b = 1.5\\times 10^{-4}$ per nanometer, $a_c = 0.01$.\n- Evaluation reflectance spectra:\n    - Vegetation eval: $\\lambda_0 = 692$ nanometers, $s = 20$ nanometers, $a_g = 0.11$.\n    - Soil eval: $a = 0.12$, $b = 1.8\\times 10^{-4}$ per nanometer, $a_c = -0.015$.\n\nTest Case 3 (edge case; red band with narrow versus wide SRF and inclusion of flat spectra in training):\n- Irradiance parameters: $\\mu_I = 650$ nanometers, $\\sigma_I = 120$ nanometers.\n- Sensor $A$ SRF parameters: $\\mu_A = 680$ nanometers, $\\sigma_A = 10$ nanometers.\n- Sensor $B$ SRF parameters: $\\mu_B = 680$ nanometers, $\\sigma_B = 40$ nanometers.\n- Training reflectance spectra:\n    - Vegetation 1: $\\lambda_0 = 700$ nanometers, $s = 12$ nanometers, $a_g = 0.08$.\n    - Vegetation 2: $\\lambda_0 = 710$ nanometers, $s = 10$ nanometers, $a_g = 0.07$.\n    - Soil 1: $a = 0.15$, $b = 1.0\\times 10^{-4}$ per nanometer, $a_c = -0.01$.\n    - Flat 1: $c = 0.30$.\n    - Flat 2: $c = 0.50$.\n- Evaluation reflectance spectra:\n    - Vegetation eval: $\\lambda_0 = 705$ nanometers, $s = 10$ nanometers, $a_g = 0.09$.\n    - Soil eval: $a = 0.13$, $b = 1.0\\times 10^{-4}$ per nanometer, $a_c = -0.005$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[b_{\\text{veg, case 1}}, b_{\\text{soil, case 1}}, b_{\\text{veg, case 2}}, b_{\\text{soil, case 2}}, b_{\\text{veg, case 3}}, b_{\\text{soil, case 3}}].\n$$\nAll entries must be decimal numbers. No units should be printed.",
            "solution": "The problem requires the computation of cross-sensor harmonization coefficients and the subsequent evaluation of class-specific bias. The solution is derived from first principles of radiometry and statistical regression, implemented numerically.\n\nThe fundamental quantity is the effective band reflectance, $R_X$, for a sensor $X$. This is defined as the spectrally-weighted average of the surface reflectance $\\rho(\\lambda)$, where the weighting function is the product of the sensor's Spectral Response Function (SRF), $S_X(\\lambda)$, and the incident solar irradiance, $I(\\lambda)$. The formal definition is:\n$$\nR_X = \\frac{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} \\rho(\\lambda) S_X(\\lambda) I(\\lambda) \\, d\\lambda}{\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} S_X(\\lambda) I(\\lambda) \\, d\\lambda}\n$$\nThe problem specifies that all integrals must be approximated numerically using the trapezoidal rule on a discrete wavelength grid, $\\lambda$, from $400$ nm to $900$ nm with a spacing of $\\Delta\\lambda = 1$ nm.\n\nFirst, we must construct the necessary spectral functions for each test case.\nThe incident irradiance, $I(\\lambda)$, is modeled as a Gaussian function:\n$$\nI(\\lambda) = \\exp\\!\\left(-\\frac{(\\lambda-\\mu_I)^2}{2\\sigma_I^2}\\right)\n$$\nThe SRFs for sensors $A$ and $B$, $S_A(\\lambda)$ and $S_B(\\lambda)$, are also modeled as Gaussian functions. A critical step is normalization. The problem states that the discrete integral of the SRF over the wavelength grid must equal $1$. We first compute the un-normalized SRF, $S'_X(\\lambda) \\propto \\exp\\!\\left(-\\frac{(\\lambda-\\mu_X)^2}{2\\sigma_X^2}\\right)$, and then find its trapezoidal integral, $C_X = \\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} S'_X(\\lambda) d\\lambda$. The normalized SRF is then $S_X(\\lambda) = S'_X(\\lambda) / C_X$. This ensures that $S_X(\\lambda)$ acts as a proper probability density function over the wavelength grid, preventing the introduction of arbitrary scaling factors.\n\nThe surface reflectance spectra, $\\rho(\\lambda)$, are given by parametric models for vegetation, soil, and flat surfaces. For instance, the vegetation model is:\n$$\n\\rho_{\\text{veg}}(\\lambda; \\lambda_0, s, a_g) = 0.05 + \\frac{0.45}{1+\\exp\\!\\left(-\\frac{\\lambda-\\lambda_0}{s}\\right)} + a_g \\exp\\!\\left(-\\frac{(\\lambda-550)^2}{2\\cdot 30^2}\\right)\n$$\nAs reflectance is a ratio of reflected to incident flux, its value must be physically constrained to the interval $[0,1]$. Therefore, after computing the value from the parametric function, we clip the resulting spectral reflectance vector to lie within this range.\n\nWith these functions defined, we can compute the band-averaged reflectance $R_X$ for any given surface $\\rho(\\lambda)$ by numerically integrating the numerator $\\rho(\\lambda) S_X(\\lambda) I(\\lambda)$ and the denominator $S_X(\\lambda) I(\\lambda)$ using the trapezoidal rule and then taking their ratio.\n\nThe next step is to determine the linear cross-sensor mapping, $R_B \\approx \\alpha R_A + \\beta$. The coefficients $\\alpha$ (slope) and $\\beta$ (offset) are found by minimizing the sum of squared residuals over a set of $N$ training spectra:\n$$\n\\text{minimize} \\sum_{i=1}^{N} \\left( (\\alpha R_{A,i} + \\beta) - R_{B,i} \\right)^2\n$$\nThis is a standard ordinary least squares (OLS) linear regression problem. We can formulate this in matrix terms. Let $\\mathbf{y}$ be the $N \\times 1$ column vector of target reflectances $\\{R_{B,i}\\}$, and let $\\mathbf{M}$ be the $N \\times 2$ design matrix where the first column is the vector of predictor reflectances $\\{R_{A,i}\\}$ and the second column is a vector of ones. Let $\\mathbf{c} = [\\alpha, \\beta]^T$ be the vector of coefficients. The OLS problem is to solve the linear system $\\mathbf{M}\\mathbf{c} = \\mathbf{y}$ in a least-squares sense. A numerically stable and robust method for this is to use a function like `numpy.linalg.lstsq`, which typically employs QR decomposition or SVD.\n\nAfter obtaining the mapping coefficients $\\alpha$ and $\\beta$ from the training set, we proceed to the evaluation phase. For a given evaluation spectrum (e.g., vegetation), we compute its \"true\" band reflectances for both sensors, $R_{A,\\text{eval}}$ and $R_{B,\\text{eval}}$. We then use the derived mapping to predict the sensor $B$ reflectance from the sensor $A$ measurement:\n$$\n\\hat{R}_{B,\\text{eval}} = \\alpha R_{A,\\text{eval}} + \\beta\n$$\nThe bias, $b$, is the difference between the predicted and the true reflectance for sensor $B$:\n$$\nb = \\hat{R}_{B,\\text{eval}} - R_{B,\\text{eval}}\n$$\nThis bias quantifies the systematic error of the linear model for a particular surface type that was not included in the training data. We compute this bias for both the vegetation and soil evaluation spectra in each test case.\n\nThe overall algorithm proceeds as follows for each test case:\n1. Define the wavelength grid, $\\lambda$.\n2. Generate the irradiance spectrum $I(\\lambda)$ and the normalized SRFs $S_A(\\lambda)$ and $S_B(\\lambda)$ using the specified parameters.\n3. For each spectrum in the training set:\n   a. Generate the reflectance spectrum $\\rho_i(\\lambda)$ using its parametric formula and clip to $[0, 1]$.\n   b. Compute the corresponding band reflectances $R_{A,i}$ and $R_{B,i}$.\n4. Assemble the collections $\\{R_{A,i}\\}$ and $\\{R_{B,i}\\}$ and perform linear regression to find $\\alpha$ and $\\beta$.\n5. For each evaluation spectrum (vegetation and soil):\n   a. Generate its reflectance spectrum $\\rho_{\\text{eval}}(\\lambda)$.\n   b. Compute its band reflectances $R_{A,\\text{eval}}$ and $R_{B,\\text{eval}}$.\n   c. Calculate the predicted reflectance $\\hat{R}_{B,\\text{eval}} = \\alpha R_{A,\\text{eval}} + \\beta$.\n   d. Compute the bias $b = \\hat{R}_{B,\\text{eval}} - R_{B,\\text{eval}}$.\n6. Collect the resulting biases $b_{\\text{veg}}$ and $b_{\\text{soil}}$ for the final output.\nThis entire procedure is repeated for all three test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes cross-sensor reflectance mapping and evaluates class-wise bias\n    for three test cases as specified in the problem statement.\n    \"\"\"\n    \n    # Define the wavelength grid as a constant.\n    # Wavelength lambda is in nanometers.\n    LMBDA = np.arange(400, 901, 1)\n\n    # --- Helper functions for spectral models and calculations ---\n\n    def gaussian(lmbda, mu, sigma):\n        \"\"\"Computes a Gaussian function over the wavelength grid.\"\"\"\n        return np.exp(-(lmbda - mu)**2 / (2 * sigma**2))\n\n    def normalize_srf(srf, lmbda):\n        \"\"\"Normalizes an SRF so its discrete trapezoidal integral is 1.\"\"\"\n        integral = np.trapz(srf, lmbda)\n        if integral == 0:\n            return srf # Avoid division by zero, though unlikely.\n        return srf / integral\n\n    def rho_veg(lmbda, l0, s, ag):\n        \"\"\"Computes vegetation reflectance spectrum.\"\"\"\n        term1 = 0.05\n        term2 = 0.45 / (1.0 + np.exp(-(lmbda - l0) / s))\n        term3 = ag * np.exp(-(lmbda - 550)**2 / (2 * 30**2))\n        rho = term1 + term2 + term3\n        return np.clip(rho, 0, 1)\n\n    def rho_soil(lmbda, a, b, ac):\n        \"\"\"Computes soil reflectance spectrum.\"\"\"\n        rho = a + b * (lmbda - 400) + ac * np.exp(-(lmbda - 700)**2 / (2 * 150**2))\n        return np.clip(rho, 0, 1)\n\n    def rho_flat(lmbda, c):\n        \"\"\"Computes a flat reflectance spectrum.\"\"\"\n        # Use np.full_like to ensure the output array has the same shape as the input lambda grid.\n        return np.clip(np.full_like(lmbda, c, dtype=float), 0, 1)\n\n    def calculate_R(rho, srf, irradiance, lmbda):\n        \"\"\"Calculates the effective band reflectance R_X.\"\"\"\n        integrand_num = rho * srf * irradiance\n        integrand_den = srf * irradiance\n        numerator = np.trapz(integrand_num, lmbda)\n        denominator = np.trapz(integrand_den, lmbda)\n        # Denominator should be positive, but handle for robustness.\n        if denominator == 0:\n            return 0.0\n        return numerator / denominator\n\n    # --- Test Case Data Definition ---\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"irradiance\": {\"mu_I\": 550, \"sigma_I\": 130},\n            \"sensor_A\": {\"mu_A\": 650, \"sigma_A\": 20},\n            \"sensor_B\": {\"mu_B\": 660, \"sigma_B\": 25},\n            \"training_spectra\": [\n                {\"type\": \"veg\", \"params\": {\"l0\": 700, \"s\": 20, \"ag\": 0.08}},\n                {\"type\": \"veg\", \"params\": {\"l0\": 710, \"s\": 15, \"ag\": 0.10}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.12, \"b\": 1.5e-4, \"ac\": -0.02}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.18, \"b\": 1.0e-4, \"ac\": 0.015}},\n            ],\n            \"eval_spectra\": {\n                \"veg\": {\"l0\": 705, \"s\": 18, \"ag\": 0.09},\n                \"soil\": {\"a\": 0.14, \"b\": 1.4e-4, \"ac\": -0.01},\n            }\n        },\n        # Test Case 2\n        {\n            \"irradiance\": {\"mu_I\": 560, \"sigma_I\": 100},\n            \"sensor_A\": {\"mu_A\": 550, \"sigma_A\": 30},\n            \"sensor_B\": {\"mu_B\": 560, \"sigma_B\": 30},\n            \"training_spectra\": [\n                {\"type\": \"veg\", \"params\": {\"l0\": 690, \"s\": 25, \"ag\": 0.12}},\n                {\"type\": \"veg\", \"params\": {\"l0\": 695, \"s\": 22, \"ag\": 0.09}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.10, \"b\": 2.0e-4, \"ac\": -0.02}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.20, \"b\": 1.5e-4, \"ac\": 0.01}},\n            ],\n            \"eval_spectra\": {\n                \"veg\": {\"l0\": 692, \"s\": 20, \"ag\": 0.11},\n                \"soil\": {\"a\": 0.12, \"b\": 1.8e-4, \"ac\": -0.015},\n            }\n        },\n        # Test Case 3\n        {\n            \"irradiance\": {\"mu_I\": 650, \"sigma_I\": 120},\n            \"sensor_A\": {\"mu_A\": 680, \"sigma_A\": 10},\n            \"sensor_B\": {\"mu_B\": 680, \"sigma_B\": 40},\n            \"training_spectra\": [\n                {\"type\": \"veg\", \"params\": {\"l0\": 700, \"s\": 12, \"ag\": 0.08}},\n                {\"type\": \"veg\", \"params\": {\"l0\": 710, \"s\": 10, \"ag\": 0.07}},\n                {\"type\": \"soil\", \"params\": {\"a\": 0.15, \"b\": 1.0e-4, \"ac\": -0.01}},\n                {\"type\": \"flat\", \"params\": {\"c\": 0.30}},\n                {\"type\": \"flat\", \"params\": {\"c\": 0.50}},\n            ],\n            \"eval_spectra\": {\n                \"veg\": {\"l0\": 705, \"s\": 10, \"ag\": 0.09},\n                \"soil\": {\"a\": 0.13, \"b\": 1.0e-4, \"ac\": -0.005},\n            }\n        }\n    ]\n\n    # --- Main Processing Loop ---\n\n    all_results = []\n    \n    for case in test_cases:\n        # 1. Construct spectral functions (Irradiance and SRFs)\n        I = gaussian(LMBDA, case[\"irradiance\"][\"mu_I\"], case[\"irradiance\"][\"sigma_I\"])\n        S_A_unnorm = gaussian(LMBDA, case[\"sensor_A\"][\"mu_A\"], case[\"sensor_A\"][\"sigma_A\"])\n        S_A = normalize_srf(S_A_unnorm, LMBDA)\n        S_B_unnorm = gaussian(LMBDA, case[\"sensor_B\"][\"mu_B\"], case[\"sensor_B\"][\"sigma_B\"])\n        S_B = normalize_srf(S_B_unnorm, LMBDA)\n        \n        # 2. Compute band reflectances for the training set\n        R_A_train = []\n        R_B_train = []\n        for spec_def in case[\"training_spectra\"]:\n            if spec_def[\"type\"] == \"veg\":\n                rho = rho_veg(LMBDA, **spec_def[\"params\"])\n            elif spec_def[\"type\"] == \"soil\":\n                rho = rho_soil(LMBDA, **spec_def[\"params\"])\n            else: # flat\n                rho = rho_flat(LMBDA, **spec_def[\"params\"])\n\n            R_A_train.append(calculate_R(rho, S_A, I, LMBDA))\n            R_B_train.append(calculate_R(rho, S_B, I, LMBDA))\n\n        R_A_train = np.array(R_A_train)\n        R_B_train = np.array(R_B_train)\n        \n        # 3. Solve for alpha and beta using linear least squares\n        # Design matrix M for M*c=y, where c = [alpha, beta]^T\n        M = np.vstack([R_A_train, np.ones(len(R_A_train))]).T\n        alpha, beta = np.linalg.lstsq(M, R_B_train, rcond=None)[0]\n\n        # 4. Compute biases for evaluation spectra\n        \n        # Vegetation evaluation\n        params_veg = case[\"eval_spectra\"][\"veg\"]\n        rho_veg_eval = rho_veg(LMBDA, **params_veg)\n        R_A_veg_eval = calculate_R(rho_veg_eval, S_A, I, LMBDA)\n        R_B_veg_eval = calculate_R(rho_veg_eval, S_B, I, LMBDA)\n        R_B_veg_hat = alpha * R_A_veg_eval + beta\n        b_veg = R_B_veg_hat - R_B_veg_eval\n        all_results.append(b_veg)\n\n        # Soil evaluation\n        params_soil = case[\"eval_spectra\"][\"soil\"]\n        rho_soil_eval = rho_soil(LMBDA, **params_soil)\n        R_A_soil_eval = calculate_R(rho_soil_eval, S_A, I, LMBDA)\n        R_B_soil_eval = calculate_R(rho_soil_eval, S_B, I, LMBDA)\n        R_B_soil_hat = alpha * R_A_soil_eval + beta\n        b_soil = R_B_soil_hat - R_B_soil_eval\n        all_results.append(b_soil)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}