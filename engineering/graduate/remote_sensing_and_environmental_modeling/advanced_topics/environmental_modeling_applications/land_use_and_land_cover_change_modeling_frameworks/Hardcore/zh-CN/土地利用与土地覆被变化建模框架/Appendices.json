{
    "hands_on_practices": [
        {
            "introduction": "在模拟景观变化之前，我们必须首先学习如何定量地描述其当前状态。源于信息论的度量指标，如香农熵，为总结景观的组分多样性与复杂性提供了一种强有力的方法。本练习  将通过一个具体的计算，帮助您理解类别比例和熵作为动态模型中状态描述符的角色。",
            "id": "3824215",
            "problem": "一幅土地利用和土地覆盖（LULC）的遥感栅格数据被用来定义景观的组分状态，以用于动态土地变化建模。考虑一个单一图块，其包含一个 $105 \\times 100$ 像素的网格，空间分辨率为 $30\\,\\text{m}$。一个质量控制掩膜将 $500$ 个像素标记为无效（NoData），这些像素必须从所有计算中排除。剩余的有效像素被划分为 $K=4$ 个LULC类别，其各类别的像素计数如下：耕地 $4000$，森林 $3000$，城市 $2000$，以及水体 $1000$。假设每个有效像素代表相等的面积。将类别比例 $\\{p_{k}\\}_{k=1}^{K}$ 视为类别上的离散概率质量函数，并在土地利用和土地覆盖变化建模框架中，将 $\\{p_{k}\\}$ 和使用自然对数计算的相关香农熵解释为状态描述符。使用自然对数的标准公式计算类别比例 $p_{k}$ 和该分布的香农熵，并讨论它们作为离散状态模型的状态描述符的解释。仅报告熵值 $H$，四舍五入至四位有效数字，单位为奈特（nats）。",
            "solution": "问题陈述已经过验证，是自洽、科学合理且定义明确的。所有提供的数值在内部是一致的。任务是计算给定土地利用和土地覆盖（LULC）分布的类别比例和相关的香农熵，并讨论它们在土地变化建模框架内的解释。\n\n首先，我们确定栅格图块中有效像素的总数 $N$。网格的尺寸为 $105 \\times 100$ 像素，总计 $105 \\times 100 = 10500$ 个像素。问题陈述指出有 $500$ 个像素被标记为无效（NoData）。因此，有效像素的数量为：\n$$\nN = 10500 - 500 = 10000\n$$\n问题提供了 $K=4$ 个LULC类别中每个类别的像素计数：$n_1 = 4000$（耕地），$n_2 = 3000$（森林），$n_3 = 2000$（城市），以及 $n_4 = 1000$（水体）。一致性检查确认，这些按类别计数的总和等于有效像素的总数：\n$$\n\\sum_{k=1}^{4} n_k = 4000 + 3000 + 2000 + 1000 = 10000 = N\n$$\n这证实了数据是一致的。\n\n问题要求将类别比例（表示为 $\\{p_k\\}_{k=1}^{K}$）视为一个离散概率质量函数。每个类别 $k$ 的比例计算为该类别中的像素数 $n_k$ 与有效像素总数 $N$ 的比值。\n$$\np_k = \\frac{n_k}{N}\n$$\n我们为每个类别计算这些比例：\n对于耕地（$k=1$）：\n$$\np_1 = \\frac{4000}{10000} = 0.4\n$$\n对于森林（$k=2$）：\n$$\np_2 = \\frac{3000}{10000} = 0.3\n$$\n对于城市（$k=3$）：\n$$\np_3 = \\frac{2000}{10000} = 0.2\n$$\n对于水体（$k=4$）：\n$$\np_4 = \\frac{1000}{10000} = 0.1\n$$\n根据概率质量函数的要求，这些比例的总和为1：$\\sum_{k=1}^{4} p_k = 0.4 + 0.3 + 0.2 + 0.1 = 1$。\n\n这些比例 $\\{p_k\\}$ 构成一个状态向量 $S = [p_1, p_2, p_3, p_4] = [0.4, 0.3, 0.2, 0.1]$，它描述了观测时景观的组分状态。在动态土地变化模型中，该向量代表了系统在时间 $t$ 的状态。模型接着会根据一套转换规则，模拟该向量向未来状态 $S(t+\\Delta t)$ 的演变。\n\n接下来，我们计算该分布的香农熵 $H$。香农熵衡量由概率分布描述的系统的不确定性或信息复杂度。对于一个具有 $K$ 个状态的离散系统，使用自然对数（单位为奈特，nats）的公式是：\n$$\nH = - \\sum_{k=1}^{K} p_k \\ln(p_k)\n$$\n将计算出的比例代入此方程：\n$$\nH = - \\left( p_1 \\ln(p_1) + p_2 \\ln(p_2) + p_3 \\ln(p_3) + p_4 \\ln(p_4) \\right)\n$$\n$$\nH = - \\left( 0.4 \\ln(0.4) + 0.3 \\ln(0.3) + 0.2 \\ln(0.2) + 0.1 \\ln(0.1) \\right)\n$$\n我们现在计算各项的值：\n$$\n0.4 \\ln(0.4) \\approx 0.4 \\times (-0.91629073) \\approx -0.36651629\n$$\n$$\n0.3 \\ln(0.3) \\approx 0.3 \\times (-1.20397280) \\approx -0.36119184\n$$\n$$\n0.2 \\ln(0.2) \\approx 0.2 \\times (-1.60943791) \\approx -0.32188758\n$$\n$$\n0.1 \\ln(0.1) \\approx 0.1 \\times (-2.30258509) \\approx -0.23025851\n$$\n将这些值相加：\n$$\n\\sum p_k \\ln(p_k) \\approx -0.36651629 - 0.36119184 - 0.32188758 - 0.23025851 \\approx -1.27985422\n$$\n因此，熵为：\n$$\nH = -(-1.27985422) \\approx 1.27985422 \\, \\text{nats}\n$$\n作为一个状态描述符，香农熵 $H$ 提供了景观组分多样性的单一标量度量。它量化了从景观中随机选择一个像素时，预测其LULC类别的不确定性程度。$H=0$ 的值意味着一个完全同质的景观（只有一个类别，$p_k=1$）。对于 $K=4$ 个类别，当所有类别等概率时（$p_k = 1/4 = 0.25$），可能的最大熵为 $H_{\\text{max}} = \\ln(K) = \\ln(4) \\approx 1.386$ 奈特。计算出的值 $H \\approx 1.280$ 接近这个最大值，表明景观具有高度的组分异质性，没有单个类别占绝对主导地位。在动态建模中，追踪 $H(t)$ 可以分析景观层面的趋势，例如多样性增加（破碎化）或多样性减少（同质化）。\n\n问题要求熵值 $H$ 四舍五入至四位有效数字。\n$$\nH \\approx 1.280 \\, \\text{nats}\n$$",
            "answer": "$$\n\\boxed{1.280}\n$$"
        },
        {
            "introduction": "土地利用/覆盖变化模型的核心是描述不同地物类别之间转化速率的转移概率矩阵。这个练习  将引导您完成一个基础但至关重要的统计推导，展示如何运用最大似然估计（MLE）原理从观测数据中获得这些概率，从而揭示许多基于马尔可夫模型的理论基础。",
            "id": "3824196",
            "problem": "一位遥感分析师正在对在同一空间域上于时间 $t$ 和 $t+1$ 获取的两幅分类栅格地图之间的土地利用和土地覆盖（LULC）转移进行建模。假设在时间 $t$ 有 $C$ 个类别，由 $i \\in \\{1,\\dots,C\\}$ 索引；在时间 $t+1$ 有 $C$ 个类别，由 $j \\in \\{1,\\dots,C\\}$ 索引。在一个齐次一阶马尔可夫模型下，转移概率由一个矩阵 $T \\in \\mathbb{R}^{C \\times C}$ 表示，其元素为 $T_{ij}$，其中 $T_{ij}$ 表示在时间 $t$ 处于类别 $i$ 的一个像元在时间 $t+1$ 转移到类别 $j$ 的概率。假设如下：\n- 给定像元在时间 $t$ 的类别，其转移是条件独立的。\n- 对于每个源类别 $i$，通过叠加两幅地图得到的向目标类别的转移计数向量 $(N_{i1},\\dots,N_{iC})$，服从参数为 $(T_{i1},\\dots,T_{iC})$ 且总数为 $N_{i+} = \\sum_{j=1}^{C} N_{ij}$ 的多项分布。\n- 分类误差可以忽略不计，且空间域对齐是精确的。\n\n仅使用这些模型假设和多项似然的定义，推导 $T$ 的最大似然估计（MLE），并满足对于每个 $i$，$\\sum_{j=1}^{C} T_{ij} = 1$ 和 $T_{ij} \\ge 0$ 的约束条件。请将您的最终结果表示为通用元素 $T_{ij}^{\\star}$ 关于观测计数 $N_{ij}$ 的单一闭式解析表达式。此外，在您的推导中解释行和为一的约束是如何施加的，以及在何种计数条件下估计量不是唯一确定的。最终答案必须是单一的解析表达式；不要在最终答案框中包含任何单位或额外的评论。",
            "solution": "该问题要求在给定的一组模型假设下，推导转移概率矩阵 $T$ 的元素 $T_{ij}$ 的最大似然估计（MLE）。矩阵 $T$ 描述了两个时间点 $t$ 和 $t+1$ 之间土地利用和土地覆盖（LULC）变化的概率。\n\n推导过程通过在给定的概率 $T_{ij}$ 约束条件下，最大化观测到的转移计数 $N_{ij}$ 的似然函数来进行。\n\n首先，我们建立似然函数。问题陈述，对于每个源类别 $i \\in \\{1, \\dots, C\\}$，观测到的向所有目标类别 $j \\in \\{1, \\dots, C\\}$ 的转移计数向量，记为 $(N_{i1}, \\dots, N_{iC})$，服从多项分布。该分布的参数是该源类别的转移概率向量 $(T_{i1}, \\dots, T_{iC})$ 和源类别中的像元总数 $N_{i+} = \\sum_{j=1}^{C} N_{ij}$。\n\n单行 $i$ 的计数的概率质量函数由多项式公式给出：\n$$ P(N_{i1}, \\dots, N_{iC} | T_{i1}, \\dots, T_{iC}) = \\frac{N_{i+}!}{\\prod_{j=1}^{C} N_{ij}!} \\prod_{j=1}^{C} T_{ij}^{N_{ij}} $$\n“给定像元在时刻 $t$ 的类别，其转移是条件独立的”这一假设意味着来自不同源类别的转移是独立事件。因此，总似然函数 $L(T | N)$ 是从 1 到 $C$ 的每个源类别 $i$ 的似然的乘积：\n$$ L(T | N) = \\prod_{i=1}^{C} \\left( \\frac{N_{i+}!}{\\prod_{j=1}^{C} N_{ij}!} \\prod_{j=1}^{C} T_{ij}^{N_{ij}} \\right) $$\n为了找到 MLE，我们必须在对于每个类别 $i$，$\\sum_{j=1}^{C} T_{ij} = 1$ 且对于所有 $j \\in \\{1, \\dots, C\\}$，$T_{ij} \\ge 0$ 的约束条件下，最大化 $L(T|N)$ 关于参数 $T_{ij}$ 的值。\n\n在数学上，最大化似然函数的自然对数，即对数似然 $\\mathcal{L} = \\ln(L)$，更为方便，因为对数是单调递增函数，并且会产生相同的最大化参数。\n$$ \\mathcal{L}(T|N) = \\ln(L(T|N)) = \\sum_{i=1}^{C} \\ln\\left( \\frac{N_{i+}!}{\\prod_{j=1}^{C} N_{ij}!} \\right) + \\sum_{i=1}^{C} \\sum_{j=1}^{C} N_{ij} \\ln(T_{ij}) $$\n为了对 $T_{ij}$ 进行最大化，涉及阶乘的项是一个常数，可以忽略。因此，我们寻求最大化：\n$$ \\mathcal{L}'(T) = \\sum_{i=1}^{C} \\sum_{j=1}^{C} N_{ij} \\ln(T_{ij}) $$\n至关重要的是，目标函数 $\\mathcal{L}'(T)$ 是各项之和，其中每一项 $\\sum_{j=1}^{C} N_{ij} \\ln(T_{ij})$ 仅依赖于矩阵 $T$ 的单行 $i$ 的参数。类似地，约束 $\\sum_{j=1}^{C} T_{ij} = 1$ 独立地应用于每一行。这意味着整个优化问题可以分解为 $C$ 个独立的优化问题，每个源类别 $i$ 对应一个。\n\n对于每一行 $i$，我们必须在约束 $g_i = \\sum_{j=1}^{C} T_{ij} - 1 = 0$ 下最大化 $\\mathcal{L}_i = \\sum_{j=1}^{C} N_{ij} \\ln(T_{ij})$。这个约束优化问题可以使用拉格朗日乘数法来解决。因此，通过为 $C$ 个约束中的每一个引入一个拉格朗日乘数 $\\lambda_i$，来施加行和为一的约束。行 $i$ 的拉格朗日函数为：\n$$ \\Lambda_i(T_{i1}, \\dots, T_{iC}, \\lambda_i) = \\sum_{j=1}^{C} N_{ij} \\ln(T_{ij}) - \\lambda_i \\left( \\sum_{j=1}^{C} T_{ij} - 1 \\right) $$\n为了找到驻点，我们对 $\\Lambda_i$ 关于每个变量 $T_{ij}$ (对于 $j=1, \\dots, C$) 和乘数 $\\lambda_i$ 求偏导数，并令它们为零。对于一个通用的 $T_{ij}$：\n$$ \\frac{\\partial \\Lambda_i}{\\partial T_{ij}} = \\frac{N_{ij}}{T_{ij}} - \\lambda_i = 0 $$\n解出 $T_{ij}$ 得到：\n$$ T_{ij} = \\frac{N_{ij}}{\\lambda_i} $$\n这必须对所有的 $j \\in \\{1, \\dots, C\\}$ 成立。这个结果表明，估计的概率 $T_{ij}$ 与观测到的计数 $N_{ij}$ 成正比。对于给定的源类别 $i$，比例常数 $1/\\lambda_i$ 对所有目标类别 $j$ 都是相同的。\n\n为了确定 $\\lambda_i$，我们将 $T_{ij}$ 的这个表达式代入约束方程 $\\sum_{j=1}^{C} T_{ij} = 1$：\n$$ \\sum_{j=1}^{C} \\frac{N_{ij}}{\\lambda_i} = 1 $$\n$$ \\frac{1}{\\lambda_i} \\sum_{j=1}^{C} N_{ij} = 1 $$\n总和 $\\sum_{j=1}^{C} N_{ij}$ 是最初属于类别 $i$ 的像元总数，我们已将其表示为 $N_{i+}$。因此：\n$$ \\frac{N_{i+}}{\\lambda_i} = 1 \\implies \\lambda_i = N_{i+} $$\n现在，我们将 $\\lambda_i$ 的这个值代回到 $T_{ij}$ 的表达式中，以获得最大似然估计量，我们将其表示为 $T_{ij}^{\\star}$：\n$$ T_{ij}^{\\star} = \\frac{N_{ij}}{N_{i+}} = \\frac{N_{ij}}{\\sum_{k=1}^{C} N_{ik}} $$\n这里，我们在分母的求和中使用索引 $k$ 以避免与特定项 $N_{ij}$ 中的索引 $j$ 混淆。非负性约束 $T_{ij} \\ge 0$ 得到了满足，因为计数 $N_{ij}$ 及其总和 $N_{i+}$ 本质上是非负的。\n\n$T_{ij}^{\\star}$ 的估计量是唯一确定的，当且仅当分母不为零。分母是 $N_{i+} = \\sum_{k=1}^{C} N_{ik}$。如果对于给定的源类别 $i$，$N_{i+} = 0$，这意味着类别 $i$ 在时刻 $t$ 的栅格地图中不存在。在这种情况下，数据没有提供关于类别 $i$ 转移行为的任何信息。行 $i$ 的似然贡献将是 $\\prod_j T_{ij}^{0} = 1$，无论 $T_{ij}$ 的值是多少（只要它们不为零，或者我们定义 $0^0=1$）。任何和为 1 的概率向量 $(T_{i1}, \\dots, T_{iC})$ 都会使这个常数似然项最大化。因此，如果在时刻 $t$ 没有观测到类别 $i$ 的像元，则转移矩阵第 $i$ 行的 MLE 不是唯一确定的。",
            "answer": "$$ \\boxed{\\frac{N_{ij}}{\\sum_{k=1}^{C} N_{ik}}} $$"
        },
        {
            "introduction": "本节将理论付诸实践，指导您构建一个可运行的元胞自动机（CA）分配模型，这是空间建模中的一个常用框架。这个动手编程练习  将需求、适宜性、邻域效应和约束等关键概念整合到一个贪心算法中，用于模拟土地变化的动态空间格局。通过完成此任务，您将掌握将抽象模型概念转化为具体计算步骤的核心技能。",
            "id": "3824230",
            "problem": "给定一个土地覆盖图的离散栅格网格表示、一组目标类别数量的净变化（需求）、特定类别的适宜性场、一个编码了禁止变化的硬约束的排除掩码，以及一个允许转换矩阵。您的任务是为土地利用和土地覆盖（LULC）变化实现一个元胞自动机（CA）分配过程，该过程基于遥感和环境建模原理，通过迭代选择单元格进行转换以满足需求，同时遵守约束并最大化局部定义的转换倾向性。\n\n从以下基本基础开始：\n\n- 元胞自动机（CA）是一种格网上的空间显式模型，其中每个单元格的状态根据局部规则和邻域影响进行演变。\n- 在LULC变化建模中，每个单元格属于 $K$ 个离散类别之一。转换受到允许的源-目标对和硬性排除的约束。需求指定了目标年份各类别总数的净变化，并且必须满足单元格总数守恒的原则。\n- 邻域影响可以通过在有限核上定义的局部统计量来表示，而适宜性是一个特定类别的标量场，反映了与位置相关的吸引力。\n\n定义：\n\n- 设网格的形状为 $H \\times W$，其中 $H = 5$ 且 $W = 5$。设类别由 $k \\in \\{0,1,2\\}$（$K = 3$）索引。\n- 设初始土地覆盖图为一个整数数组 $M \\in \\{0,1,2\\}^{H \\times W}$，其中 $M_{i,j}$ 是单元格 $(i,j)$ 的类别。所有测试用例的地图如下：\n  - 第 0 行：$[2,2,1,0,0]$\n  - 第 1 行：$[2,2,1,1,0]$\n  - 第 2 行：$[2,0,0,1,1]$\n  - 第 3 行：$[2,2,0,0,1]$\n  - 第 4 行：$[0,0,0,2,2]$\n- 设排除掩码为 $E \\in \\{0,1\\}^{H \\times W}$，其中 $E_{i,j} = 1$ 表示禁止在 $(i,j)$ 处发生任何变化；$E_{i,j} = 0$ 表示允许变化。\n- 设允许转换矩阵为 $T \\in \\{0,1\\}^{K \\times K}$，其中 $T_{o,k} = 1$ 表示从源类别 $o$ 到目标类别 $k$ 的转换是允许的，否则 $T_{o,k} = 0$。不允许自我转换，因此对于所有 $k$，$T_{k,k} = 0$。使用：\n  - $T$ 的行（源 $0$, $1$, $2$）到列（目标 $0$, $1$, $2$）：\n    - 源 $0$：$[0,1,0]$\n    - 源 $1$：$[1,0,0]$\n    - 源 $2$：$[1,1,0]$\n- 设适宜性场为 $S \\in \\mathbb{R}^{K \\times H \\times W}$，其中 $S_{k,i,j} \\in [0,1]$ 编码了单元格 $(i,j)$ 对目标类别 $k$ 的位置相关适宜性。使用：\n  - $S_{0}$ 的行：\n    - 第 0 行：$[0.4,0.3,0.2,0.6,0.5]$\n    - 第 1 行：$[0.3,0.2,0.3,0.5,0.4]$\n    - 第 2 行：$[0.2,0.4,0.5,0.3,0.2]$\n    - 第 3 行：$[0.3,0.3,0.4,0.6,0.6]$\n    - 第 4 行：$[0.5,0.5,0.4,0.3,0.2]$\n  - $S_{1}$ 的行：\n    - 第 0 行：$[0.7,0.6,0.8,0.3,0.2]$\n    - 第 1 行：$[0.6,0.5,0.7,0.4,0.3]$\n    - 第 2 行：$[0.5,0.6,0.7,0.5,0.4]$\n    - 第 3 行：$[0.4,0.5,0.6,0.7,0.6]$\n    - 第 4 行：$[0.3,0.4,0.5,0.6,0.7]$\n  - $S_{2}$ 的行：\n    - 第 0 行：$[0.2,0.3,0.4,0.6,0.7]$\n    - 第 1 行：$[0.3,0.4,0.5,0.6,0.7]$\n    - 第 2 行：$[0.4,0.5,0.6,0.5,0.4]$\n    - 第 3 行：$[0.5,0.6,0.5,0.4,0.3]$\n    - 第 4 行：$[0.6,0.7,0.6,0.5,0.4]$\n- 设邻域核为排除中心的 $3 \\times 3$ 摩尔核 $K$：\n  - $K = \\begin{bmatrix}1  1  1 \\\\ 1  0  1 \\\\ 1  1  1\\end{bmatrix}$。\n- 设单元格 $(i,j)$ 对目标类别 $k$ 的邻域分数 $N_{k,i,j}$ 定义为 $(i,j)$ 周围类别为 $k$ 的邻居数量除以由 $K$ 在 $(i,j)$ 处指示的有效邻居数量，使用边界感知归一化，以便边缘单元格除以实际边界内的邻居数量。\n- 设转换倾向性是适宜性和邻域分数的凸组合：对于单元格 $(i,j)$ 的目标类别 $k$，$P_{k,i,j} = w_s \\, S_{k,i,j} + w_n \\, N_{k,i,j}$，权重为 $w_s = 0.7$ 和 $w_n = 0.3$。\n\n分配规则：\n\n- 设需求向量为 $d \\in \\mathbb{Z}^{K}$，其中 $d_k$ 是类别 $k$ 的数量所需的净变化。单元格总数守恒意味着 $\\sum_{k=0}^{K-1} d_k = 0$。正数 $d_k$ 表示类别 $k$ 必须增加 $d_k$ 个单元格；负数 $d_k$ 表示类别 $k$ 必须减少 $|d_k|$ 个单元格。\n- 硬约束：具有 $E_{i,j} = 1$ 的单元格 $(i,j)$ 不能改变类别。从源类别 $o$ 到目标类别 $k$ 的提议转换仅在 $T_{o,k} = 1$ 时才被允许。\n- 迭代贪婪选择：当存在 $d_k > 0$ 的 $k$ 时，选择一个单元格 $(i,j)$ 变为类别 $k$，使得：\n  - 该单元格当前属于某个源类别 $o \\neq k$，且 $d_o  0$（即只从必须减少单元格的类别中抽取）。\n  - $E_{i,j} = 0$ 且 $T_{o,k} = 1$。\n  - 在所有符合条件的 $(k,i,j)$ 三元组中，选择使 $P_{k,i,j}$ 最大化的那一个。如果出现平局，则按较小的目标类别索引 $k$ 打破平局，然后按较小的行主序索引 $(i,j)$ 打破平局。\n  - 应用变化：设置 $M_{i,j} \\leftarrow k$，更新 $d_k \\leftarrow d_k - 1$ 和 $d_o \\leftarrow d_o + 1$。\n- 当所有 $d_k \\le 0$（即所有正需求都得到满足）或没有满足约束的合格单元格时终止。在后一种情况下，部分需求仍未得到满足。\n\n测试套件：\n\n实现上述算法，并将其应用于以下三个参数集：\n\n- 测试用例 1（理想路径）：\n  - 需求 $d = [0,4,-4]$。\n  - 排除掩码 E 的行：\n    - 第 0 行：$[0,0,0,0,0]$\n    - 第 1 行：$[0,1,0,0,0]$\n    - 第 2 行：$[0,0,0,1,0]$\n    - 第 3 行：$[0,0,0,0,0]$\n    - 第 4 行：$[0,0,1,0,0]$\n- 测试用例 2（边界：零需求）：\n  - 需求 $d = [0,0,0]$。\n  - 排除掩码 E 与测试用例 1 相同。\n- 测试用例 3（边缘情况：需求超过约束下合格的供应量）：\n  - 需求 $d = [0,10,-10]$。\n  - 排除掩码 E 的行：\n    - 第 0 行：$[1,1,0,0,0]$\n    - 第 1 行：$[1,1,1,0,0]$\n    - 第 2 行：$[0,0,0,0,0]$\n    - 第 3 行：$[1,1,0,0,0]$\n    - 第 4 行：$[0,0,0,1,1]$\n\n输出规范：\n\n- 对于每个测试用例，计算分配后的最终类别数量，形式为列表 $[c_0,c_1,c_2]$，其中 $c_k$ 是最终地图中类别 $k$ 的数量。同时计算一个布尔值，指示所有正需求是否已完全满足。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个元素都是测试用例的列表 $[c_0,c_1,c_2,b]$，其中 $b$ 是表示需求是否完全满足的布尔值。例如，输出格式为 $[[c_{0}^{(1)},c_{1}^{(1)},c_{2}^{(1)},b^{(1)}],[c_{0}^{(2)},c_{1}^{(2)},c_{2}^{(2)},b^{(2)}],[c_{0}^{(3)},c_{1}^{(3)},c_{2}^{(3)},b^{(3)}]]$。",
            "solution": "用户提供了一个使用元胞自动机（CA）模型进行土地利用和土地覆盖（LULC）变化模拟的问题陈述。第一步是验证此问题陈述。\n\n### 步骤1：提取给定信息\n- **网格几何**：一个形状为 $H \\times W$ 的离散栅格网格，其中 $H=5$ 且 $W=5$。\n- **类别数量 ($K$)**：$K=3$，由 $k \\in \\{0, 1, 2\\}$ 索引。\n- **初始土地覆盖图 ($M$)**：一个 $5 \\times 5$ 的整数数组 $M \\in \\{0,1,2\\}^{H \\times W}$。\n  - `[[2,2,1,0,0], [2,2,1,1,0], [2,0,0,1,1], [2,2,0,0,1], [0,0,0,2,2]]`\n- **排除掩码 ($E$)**：一个二元数组 $E \\in \\{0,1\\}^{H \\times W}$，其中 $E_{i,j}=1$ 禁止变化。为每个测试用例提供了特定的掩码。\n- **允许转换矩阵 ($T$)**：一个二元矩阵 $T \\in \\{0,1\\}^{K \\times K}$，其中 $T_{o,k}=1$ 允许从源类别 $o$ 到目标类别 $k$ 的转换。$T_{k,k}=0$。\n  - `[[0,1,0], [1,0,0], [1,1,0]]`\n- **适宜性场 ($S$)**：一个实值数组 $S \\in \\mathbb{R}^{K \\times H \\times W}$，其中 $S_{k,i,j} \\in [0,1]$。提供了 $S_0, S_1, S_2$ 的具体场。\n- **邻域核**：一个 $3 \\times 3$ 的摩尔核，中心被排除：$K = \\begin{bmatrix}1  1  1 \\\\ 1  0  1 \\\\ 1  1  1\\end{bmatrix}$。\n- **邻域分数 ($N_{k,i,j}$)**：一个单元格邻居中属于类别 $k$ 的分数，具有边界感知归一化。\n- **转换倾向性 ($P_{k,i,j}$)**：一个凸组合 $P_{k,i,j} = w_s S_{k,i,j} + w_n N_{k,i,j}$。\n- **权重**：$w_s = 0.7$，$w_n = 0.3$。\n- **需求向量 ($d$)**：一个整数向量 $d \\in \\mathbb{Z}^{K}$，指定每个类别单元格计数的净变化。守恒成立：$\\sum_{k} d_k = 0$。\n- **分配规则**：一种迭代贪婪选择过程，每次迭代改变一个单元格。选择单元格变化 $(i,j): o \\to k$ 以最大化 $P_{k,i,j}$，并满足约束条件（$d_k  0$, $d_o  0$, $E_{i,j}=0$, $T_{o,k}=1$）。\n- **平局打破规则**：对于相等的倾向性，选择具有较小目标类别索引 $k$ 的转换，然后是单元格 $(i,j)$ 的较小行主序索引。\n- **终止条件**：当所有正需求都得到满足（所有 $d_k \\le 0$）或找不到符合条件的转换时，过程停止。\n- **测试用例**：定义了三个具有不同需求向量和排除掩码的特定测试用例。\n- **输出规范**：对于每个案例，提供最终的类别计数 $[c_0, c_1, c_2]$ 和一个布尔值，指示需求是否完全满足，格式为 `[[c0,c1,c2,b], ...]`。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：该模型是地理信息学和LULC建模中一个成熟的公式。它在一个CA框架内结合了常见的组成部分，如适宜性、邻域效应和约束。这些概念是标准的，并且科学上是合理的。\n- **适定性**：问题定义精确。迭代贪婪算法结合严格的平局打破规则，确保对于任何给定的输入，单元格变化的序列是确定性的，从而产生唯一且稳定的最终地图。\n- **客观性**：所有术语都经过数学上的严格定义。语言正式，没有歧义或主观陈述。\n- **完整性与一致性**：所有必要的数据（地图、矩阵、参数、规则）都已提供。需求向量满足守恒约束（$\\sum d_k=0$）。设置中没有矛盾之处。测试用例3深刻地探讨了需求可能超过可用、无约束的单元格供应量的情况，这是这类模型的一个有效且重要的行为。\n- **可行性与现实性**：所提供的数据和参数在数值上对于一个计算问题是合理的。规模较小，适合作为测试用例。\n\n### 步骤3：结论与行动\n问题是有效的。这是一个适定的、计算上可解的问题，其基础是环境建模的既定原则。我将继续进行解答。\n\n### 基于原则的解决方案设计\n该问题要求实现一个带约束的元胞自动机分配算法。模型的核心是一个迭代过程，该过程在每一步中贪婪地选择“最佳”单元格进行类别变化，直到需求被满足或无法再进行变化为止。\n\n**1. 整体结构**\n模拟以离散步骤进行。只要还有任何剩余的正需求（即 $\\sum_{k \\text{ s.t. } d_k0} d_k  0$），主循环就会继续。在循环的每次迭代中，执行单个单元格的转换。\n\n**2. 转换倾向性的计算**\n选择哪个单元格进行变化是基于最大化转换倾向性 $P_{k,i,j}$。该值量化了单元格 $(i,j)$ 变为目标类别 $k$ 的期望程度。它被定义为一个加权和：\n$$P_{k,i,j} = w_s S_{k,i,j} + w_n N_{k,i,j}$$\n其中 $S_{k,i,j}$ 是单元格 $(i,j)$ 对类别 $k$ 的静态适宜性，而 $N_{k,i,j}$ 是动态的邻域影响。给定的权重为 $w_s=0.7$ 和 $w_n=0.3$。\n\n邻域分数 $N_{k,i,j}$ 必须在每次迭代开始时重新计算，因为土地覆盖图 $M$ 会发生变化，这反过来又会改变所有单元格的邻域构成。$N_{k,i,j}$ 是类别为 $k$ 的邻居数与单元格 $(i,j)$ 的总邻居数之比。这可以使用2D卷积对所有单元格同时进行高效计算。对于每个类别 $k$，我们创建一个二元图，指示该类别的位置。将此图与摩尔核 $K$ 进行卷积，可以在每个单元格处产生属于类别 $k$ 的邻居数。对一个全为1的地图与核进行单独的卷积，可以得到每个单元格的总邻居数，从而正确处理边界条件。\n\n**3. 贪婪选择算法**\n在每次迭代中，算法通过执行以下步骤来确定最优转换：\n- **识别候选转换**：编译所有可能且有效的转换列表。如果单元格 $(i,j)$ 从其当前源类别 $o=M_{i,j}$ 到目标类别 $k$ 的转换满足以下所有“硬”约束，则它是一个候选转换：\n    1. 目标类别 $k$ 有正需求：$d_k > 0$。\n    2. 源类别 $o$ 有负需求（即它是一个“源”类别）：$d_o  0$。\n    3. 从 $o$ 到 $k$ 的转换被转换矩阵所允许：$T_{o,k} = 1$。\n    4. 单元格 $(i,j)$ 未被排除掩码锁定，可以改变：$E_{i,j} = 0$。\n- **评估候选者**：对于每个候选转换，计算其倾向性 $P_{k,i,j}$。\n- **选择最佳候选者**：在候选者列表中搜索具有最高倾向性值的那个。问题提供了一个严格的平局打破程序：\n    1. 最高的倾向性 $P_{k,i,j}$。\n    2. 如果平局，选择最小的目标类别索引 $k$。\n    3. 如果仍然平局，选择最小的行主序索引，计算为 $i \\times W + j$。\n    一种稳健的实现方法是将候选者存储为元组 $(P_{k,i,j}, k, i, j)$ 并对其进行排序。排序键将优先考虑高倾向性（降序），然后是低 $k$（升序），最后是低行主序索引（升序）。\n\n**4. 状态更新与终止**\n- **更新**：一旦确定了最佳的单个转换——比如说，单元格 $(i^*, j^*)$ 从类别 $o^*$ 变为 $k^*$：\n    1. 土地覆盖图被更新：$M_{i^*,j^*} \\leftarrow k^*$。\n    2. 需求向量被调整以反映变化：$d_{k^*} \\leftarrow d_{k^*} - 1$ 和 $d_{o^*} \\leftarrow d_{o^*} + 1$。\n- **终止**：主循环在以下两种情况之一终止：\n    1. 总正需求降至零（即 $\\sum_{k | d_k0} d_k = 0$）。在这种情况下，分配成功，所有需求都得到满足。\n    2. 在某次迭代中，找不到候选转换。如果来自源类别的可变单元格供应在需求完全满足之前耗尽或被约束所阻挡，就会发生这种情况。在这种情况下，分配因需求未满足而停止。\n\n最后，在循环终止后，从修改后的地图 $M$ 计算每个类别的最终数量 $[c_0, c_1, c_2]$，并设置一个布尔标志以指示总正需求是否已降至 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\nimport json\n\ndef run_ca_allocation(M_initial, S, T, E, d_initial):\n    \"\"\"\n    Implements the Cellular Automata allocation procedure for LULC change.\n    \"\"\"\n    # Defensive copies to avoid modifying inputs across test cases\n    M = M_initial.copy()\n    d = d_initial.copy()\n    \n    H, W = M.shape\n    K_classes = len(d)\n    w_s, w_n = 0.7, 0.3\n    \n    kernel = np.array([[1, 1, 1],\n                       [1, 0, 1],\n                       [1, 1, 1]], dtype=np.uint8)\n\n    # Pre-calculate the number of neighbors for each cell, which is static\n    ones_map = np.ones_like(M, dtype=int)\n    num_neighbors = convolve2d(ones_map, kernel, mode='same', boundary='fill', fillvalue=0)\n    # Avoid division by zero for isolated cells, though not expected here\n    num_neighbors[num_neighbors == 0] = 1 \n\n    # Main iterative allocation loop\n    while np.sum(d[d > 0]) > 0:\n        # 1. Calculate neighborhood fractions N_k,i,j for the current map M\n        N = np.zeros_like(S)\n        for k in range(K_classes):\n            class_map_k = (M == k).astype(int)\n            neighbor_counts_k = convolve2d(class_map_k, kernel, mode='same', boundary='fill', fillvalue=0)\n            N[k, :, :] = neighbor_counts_k / num_neighbors\n\n        # 2. Calculate transition propensity P_k,i,j\n        P = w_s * S + w_n * N\n\n        # 3. Find all eligible transitions and their propensities\n        candidates = []\n        source_classes_idx = np.where(d  0)[0]\n        target_classes_idx = np.where(d > 0)[0]\n\n        for i in range(H):\n            for j in range(W):\n                # Hard constraint: exclusion mask\n                if E[i, j] == 1:\n                    continue\n                \n                origin_class = M[i, j]\n                \n                # Hard constraint: must be a source class\n                if origin_class not in source_classes_idx:\n                    continue\n\n                for k_target in target_classes_idx:\n                    # Hard constraint: transition must be allowed\n                    if T[origin_class, k_target] == 1:\n                        propensity = P[k_target, i, j]\n                        candidates.append((propensity, k_target, i, j))\n        \n        # 4. If no candidates, terminate\n        if not candidates:\n            break\n\n        # 5. Select the best candidate based on propensity and tie-breaking rules\n        # Sort by: -propensity (desc), k_target (asc), row_major_index (asc)\n        candidates.sort(key=lambda x: (-x[0], x[1], x[2] * W + x[3]))\n        \n        best_prop, best_k, best_i, best_j = candidates[0]\n\n        # 6. Apply the change\n        origin_class = M[best_i, best_j]\n        M[best_i, best_j] = best_k\n        d[best_k] -= 1\n        d[origin_class] += 1\n    \n    # 7. Post-processing: calculate final counts and check if demand was met\n    final_counts = [np.sum(M == k) for k in range(K_classes)]\n    demand_met = np.sum(d[d > 0]) == 0\n    \n    return [final_counts, demand_met]\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the simulation, printing the final result.\n    \"\"\"\n    # Common data for all test cases\n    M_initial = np.array([\n        [2, 2, 1, 0, 0],\n        [2, 2, 1, 1, 0],\n        [2, 0, 0, 1, 1],\n        [2, 2, 0, 0, 1],\n        [0, 0, 0, 2, 2]\n    ])\n\n    T = np.array([\n        [0, 1, 0],\n        [1, 0, 0],\n        [1, 1, 0]\n    ])\n\n    S = np.array([\n        # S0\n        [[0.4, 0.3, 0.2, 0.6, 0.5],\n         [0.3, 0.2, 0.3, 0.5, 0.4],\n         [0.2, 0.4, 0.5, 0.3, 0.2],\n         [0.3, 0.3, 0.4, 0.6, 0.6],\n         [0.5, 0.5, 0.4, 0.3, 0.2]],\n        # S1\n        [[0.7, 0.6, 0.8, 0.3, 0.2],\n         [0.6, 0.5, 0.7, 0.4, 0.3],\n         [0.5, 0.6, 0.7, 0.5, 0.4],\n         [0.4, 0.5, 0.6, 0.7, 0.6],\n         [0.3, 0.4, 0.5, 0.6, 0.7]],\n        # S2\n        [[0.2, 0.3, 0.4, 0.6, 0.7],\n         [0.3, 0.4, 0.5, 0.6, 0.7],\n         [0.4, 0.5, 0.6, 0.5, 0.4],\n         [0.5, 0.6, 0.5, 0.4, 0.3],\n         [0.6, 0.7, 0.6, 0.5, 0.4]]\n    ])\n\n    test_cases = [\n        # Test case 1\n        {\n            \"d\": np.array([0, 4, -4]),\n            \"E\": np.array([\n                [0, 0, 0, 0, 0],\n                [0, 1, 0, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 1, 0, 0]\n            ])\n        },\n        # Test case 2\n        {\n            \"d\": np.array([0, 0, 0]),\n            \"E\": np.array([\n                [0, 0, 0, 0, 0],\n                [0, 1, 0, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 0],\n                [0, 0, 1, 0, 0]\n            ])\n        },\n        # Test case 3\n        {\n            \"d\": np.array([0, 10, -10]),\n            \"E\": np.array([\n                [1, 1, 0, 0, 0],\n                [1, 1, 1, 0, 0],\n                [0, 0, 0, 0, 0],\n                [1, 1, 0, 0, 0],\n                [0, 0, 0, 1, 1]\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        counts, met = run_ca_allocation(M_initial, S, T, case[\"E\"], case[\"d\"])\n        # Format [c0, c1, c2, b]\n        all_results.append(counts + [met])\n\n    # Using json.dumps ensures correct boolean formatting (true/false) and spacing\n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```"
        }
    ]
}