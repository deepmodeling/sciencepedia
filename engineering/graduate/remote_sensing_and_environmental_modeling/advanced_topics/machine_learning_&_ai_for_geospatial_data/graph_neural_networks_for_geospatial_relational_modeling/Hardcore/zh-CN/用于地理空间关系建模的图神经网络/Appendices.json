{
    "hands_on_practices": [
        {
            "introduction": "在将图神经网络（GNN）应用于新的地理空间问题时，首要且最关键的步骤是定义图的结构，这个过程决定了模型如何“看待”空间实体之间的关系。本练习 () 将指导你完成一个基于物理原理的实践：如何将遥感传感器数据（在此例中为LiDAR）转换为一个代表林冠连续性的图，这对于火灾蔓延或生态廊道建模至关重要。通过改变阈值参数，你将亲身体会图的拓扑结构如何响应物理假设的变化，这是地理空间建模中一项核心的探索性技能。",
            "id": "3818275",
            "problem": "我们使用沿共享地块边界聚合的激光雷达 (LiDAR) 点云数据，为一组地块构建一个地理空间关系模型。目标是使用高度阈值，基于冠层连续性在无向图中定义边，并计算不同阈值下的邻接统计数据。预期的应用是生成一个适用于图神经网络 (GNN) 的邻接结构，该网络用于建模地理空间相互作用。\n\n基本原理：\n- LiDAR 测量的是地面以上的冠层高度，这是一个以米为单位的物理量。设采样点的冠层高度表示为 $h \\in \\mathbb{R}_{\\ge 0}$，单位为米。\n- 图定义为 $G = (V, E)$，其中 $V$ 是节点集，$E$ 是无向边集。邻接矩阵 $A \\in \\{0,1\\}^{|V| \\times |V|}$ 表示边的存在，当且仅当 $(i,j) \\in E$ 且 $i \\ne j$ 时，$A_{ij} = 1$，并且 $A_{ii} = 0$。\n- 对于无向图，平均度定义为 $\\bar{d} = \\frac{2|E|}{|V|}$。\n\n基于冠层连续性的边定义：\n- 考虑共享一条边界的两个地块 $i$ 和 $j$。沿共享边界的 LiDAR 派生样本序列以每个地块的高度列表形式给出，$H_{i \\to j} = [h_{i,0}, h_{i,1}, \\dots, h_{i,L-1}]$ 和 $H_{j \\to i} = [h_{j,0}, h_{j,1}, \\dots, h_{j,L-1}]$，其中 $L$ 是边界对齐的样本数，每个 $h_{i,k}$ 和 $h_{j,k}$ 的单位都是米。\n- 给定以米为单位的冠层高度阈值 $T$ 和连续性游程长度要求 $R \\in \\mathbb{N}$，为 $k = 0, 1, \\dots, L-1$ 定义二元序列 $b_{i,k} = \\mathbb{I}(h_{i,k} \\ge T)$ 和 $b_{j,k} = \\mathbb{I}(h_{j,k} \\ge T)$，其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n- 为 $k = 0, 1, \\dots, L-1$ 定义连续性序列 $c_k = b_{i,k} \\land b_{j,k}$。当且仅当在 $\\{0,1,\\dots,L-1\\}$ 中存在一个长度至少为 $R$ 的连续索引游程，使得 $c_k = 1$ 时，存在一条无向边 $(i,j)$。\n\n数据规格：\n- 地块数量为 $N = 5$，索引为 $0, 1, 2, 3, 4$。\n- 相邻地块对（共享边界）和 LiDAR 边界序列（单位：米）如下：\n    - 对 $(0,1)$: $H_{0 \\to 1} = [9,11,12,13,8]$, $H_{1 \\to 0} = [10,12,11,14,7]$。\n    - 对 $(1,2)$: $H_{1 \\to 2} = [5,6,7,8]$, $H_{2 \\to 1} = [5,6,7,8]$。\n    - 对 $(2,3)$: $H_{2 \\to 3} = [20,22,25,27,19,16]$, $H_{3 \\to 2} = [18,21,24,26,20,15]$。\n    - 对 $(3,4)$: $H_{3 \\to 4} = [0,0,0,2]$, $H_{4 \\to 3} = [0,1,0,3]$。\n    - 对 $(0,4)$: $H_{0 \\to 4} = [10,10,10,10]$, $H_{4 \\to 0} = [9,11,12,10]$。\n    - 对 $(1,4)$: $H_{1 \\to 4} = [14,16,18,19]$, $H_{4 \\to 1} = [13,15,17,18]$。\n    - 对 $(1,3)$: $H_{1 \\to 3} = [8,9,10,11,12]$, $H_{3 \\to 1} = [7,8,9,10,11]$。\n- 所有高度均以米为单位。所有阈值 $T$ 必须以米为单位指定。\n\n任务：\n1. 对于测试套件中的每个 $(T, R)$ 对，使用定义的边规则构建无向图 $G = (V, E)$，其中 $V = \\{0,1,2,3,4\\}$。\n2. 计算：\n   - 边的数量 $|E|$。\n   - 平均度 $\\bar{d}$，为浮点数，四舍五入到三位小数。\n   - 连通分量的数量（整数）。\n   - 最大连通分量的大小（整数）。\n\n测试套件：\n- 待评估的 $(T, R)$ 对集合为 $[(0,3), (10,3), (15,3), (25,3), (10,4)]$。所有 $T$ 值单位为米，$R$ 是样本数的整数值。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身应为一个 $[|E|, \\bar{d}, \\text{n\\_components}, \\text{lcc\\_size}]$ 形式的列表，其中 $|E|$ 是整数，$\\bar{d}$ 是四舍五入到三位小数的浮点数，$\\text{n\\_components}$ 是整数，$\\text{lcc\\_size}$ 是整数。\n- 例如，输出格式必须类似于 $[[e_1,\\bar{d}_1,c_1,l_1],[e_2,\\bar{d}_2,c_2,l_2],\\dots]$，不含任何额外文本。\n\n科学真实性与约束：\n- 将图视为无向图。\n- 使用包含性阈值规则 $h \\ge T$。\n- 连续性要求 $R$ 是样本索引中严格的最小游程长度。\n- 除提供的序列外，不应使用任何外部数据。所有高度和阈值均以米为单位，所有计算出的统计数据均为无量纲的计数或浮点数。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于地理空间数据分析和图论的原理，定义清晰，数据充分，表述客观。问题没有矛盾、歧义和事实错误。因此，我们可以进行正式的求解。\n\n问题的核心是基于一个特定的“冠层连续性”规则构建一个无向图 $G = (V, E)$，然后为该规则的不同参数化计算一组标准的图论统计量。节点集固定为 $V = \\{0, 1, 2, 3, 4\\}$，代表 $N=5$ 个地块。\n\n步骤如下：\n1.  对于每个测试用例，由冠层高度阈值 $T$（单位：米）和连续性游程长度要求 $R$（一个无量纲的计数）定义，我们确定边集 $E$。\n2.  当且仅当地块 $i$ 和 $j$ 被列为相邻对并满足冠层连续性准则时，才将边 $(i, j)$ 添加到 $E$ 中。\n3.  一旦为给定的 $(T, R)$ 对完全构建了图 $G$，我们就计算所需的统计数据：边的数量 $|E|$、平均度 $\\bar{d}$、连通分量的数量以及最大连通分量的大小。\n\n**边定义算法**\n\n对于给定的相邻地块对 $(i, j)$，其对应的 LiDAR 高度样本序列为 $H_{i \\to j} = [h_{i,0}, \\dots, h_{i,L-1}]$ 和 $H_{j \\to i} = [h_{j,0}, \\dots, h_{j,L-1}]$，以及给定的参数 $(T, R)$：\n\n1.  **阈值处理**：创建两个二元序列 $b_i = [b_{i,0}, \\dots, b_{i,L-1}]$ 和 $b_j = [b_{j,0}, \\dots, b_{j,L-1}]$，其元素由指示函数 $\\mathbb{I}(\\cdot)$ 确定：\n    $$b_{i,k} = \\mathbb{I}(h_{i,k} \\ge T)$$\n    $$b_{j,k} = \\mathbb{I}(h_{j,k} \\ge T)$$\n    对于每个样本索引 $k \\in \\{0, 1, \\dots, L-1\\}$。\n\n2.  **连续性检查**：通过对二元序列按元素应用逻辑与 ($\\land$) 运算，计算单个连续性序列 $c = [c_0, \\dots, c_{L-1}]$：\n    $$c_k = b_{i,k} \\land b_{j,k}$$\n    这意味着只有当样本位置 $k$ 处*两个*地块的冠层高度都高于阈值 $T$ 时，$c_k = 1$。\n\n3.  **游程长度评估**：在连续性序列 $c$ 中搜索长度至少为 $R$ 的连续 $1$ 子序列。如果存在这样的游程，则形成一条无向边 $(i, j)$。否则，在地块 $i$ 和 $j$ 之间不形成边。\n\n**图统计量计算**\n\n对于一个构建好的、拥有 $|V|=N=5$ 个节点的图 $G=(V, E)$：\n\n1.  **边的数量 $|E|$**：这是算法创建的唯一边的总数。\n2.  **平均度 $\\bar{d}$**：对于无向图，这由公式 $\\bar{d} = \\frac{2|E|}{|V|}$ 给出。\n3.  **连通分量**：连通分量的数量和最大分量的大小通过遍历图来确定。采用标准算法，如广度优先搜索 (BFS) 或深度优先搜索 (DFS)。我们遍历从 $0$ 到 $N-1$ 的所有节点。如果一个节点尚未被访问，我们从它开始一个新的遍历，增加分量计数，并探索所有可达节点，对它们进行计数以确定这个新分量的大小。记录所有分量中发现的最大尺寸。\n\n**每个测试用例的执行**\n\n我们将此方法应用于提供的测试套件中的每个 $(T, R)$ 对。\n\n**测试用例 1: $(T, R) = (0, 3)$**\n- 当 $T=0$ 米时，任何高度 $h \\ge 0$ 都满足阈值。由于所有提供的高度都是非负的，因此对于所有样本，$b_{i,k}=1$ 且 $b_{j,k}=1$。\n- 任何一对的连续性序列 $c$ 都将是一个全为 $1$ 的序列。\n- 如果边界序列的长度 $L$ 至少为 $R=3$，则存在一条边。\n- 对 $(0,1), L=5 \\ge 3 \\implies$ 存在边。\n- 对 $(1,2), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(2,3), L=6 \\ge 3 \\implies$ 存在边。\n- 对 $(3,4), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(0,4), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(1,4), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(1,3), L=5 \\ge 3 \\implies$ 存在边。\n- 所有 7 个潜在的相邻对都形成边。\n- $|E| = 7$。$\\bar{d} = \\frac{2 \\times 7}{5} = 2.8$。\n- 得到的图是全连接的。连通分量数为 $1$。最大连通分量的大小为 $5$。\n- 结果：$[7, 2.800, 1, 5]$\n\n**测试用例 2: $(T, R) = (10, 3)$**\n- 我们用 $T=10$ 米和 $R=3$ 检查每一对。\n- $(0,1)$: $c = [0,1,1,1,0]$。最大游程长度为 $3$。$3 \\ge 3 \\implies$ 存在边。\n- $(1,2)$: $c = [0,0,0,0]$。最大游程为 $0  3 \\implies$ 不存在边。\n- $(2,3)$: $c = [1,1,1,1,1,1]$。最大游程为 $6 \\ge 3 \\implies$ 存在边。\n- $(3,4)$: $c = [0,0,0,0]$。最大游程为 $0  3 \\implies$ 不存在边。\n- $(0,4)$: $c = [0,1,1,1]$。最大游程为 $3 \\ge 3 \\implies$ 存在边。\n- $(1,4)$: $c = [1,1,1,1]$。最大游程为 $4 \\ge 3 \\implies$ 存在边。\n- $(1,3)$: $c = [0,0,0,1,1]$。最大游程为 $2  3 \\implies$ 不存在边。\n- 边：$(0,1), (2,3), (0,4), (1,4)$。\n- $|E| = 4$。$\\bar{d} = \\frac{2 \\times 4}{5} = 1.6$。\n- 连通分量：节点 $0$ 连接到 $1$ 和 $4$。节点 $1$ 连接到 $4$。这形成了分量 $\\{0,1,4\\}$。节点 $2$ 连接到 $3$，形成了分量 $\\{2,3\\}$。\n- 连通分量数为 $2$。最大连通分量的大小为 $3$。\n- 结果：$[4, 1.600, 2, 3]$\n\n**测试用例 3: $(T, R) = (15, 3)$**\n- 我们用 $T=15$ 米和 $R=3$ 检查每一对。\n- $(0,1)$: 没有高度 $\\ge 15$。不存在边。\n- $(1,2)$: 没有高度 $\\ge 15$。不存在边。\n- $(2,3)$: $c = [1,1,1,1,1,1]$。最大游程为 $6 \\ge 3 \\implies$ 存在边。\n- $(3,4)$: 没有高度 $\\ge 15$。不存在边。\n- $(0,4)$: 没有高度 $\\ge 15$。不存在边。\n- $(1,4)$: $c = [0,1,1,1]$。最大游程为 $3 \\ge 3 \\implies$ 存在边。\n- $(1,3)$: 高度都 $\\le 12$。不存在边。\n- 边：$(2,3), (1,4)$。\n- $|E| = 2$。$\\bar{d} = \\frac{2 \\times 2}{5} = 0.8$。\n- 连通分量：$\\{0\\}, \\{1,4\\}, \\{2,3\\}$。\n- 连通分量数为 $3$。最大连通分量的大小为 $2$。\n- 结果：$[2, 0.800, 3, 2]$\n\n**测试用例 4: $(T, R) = (25, 3)$**\n- 我们用 $T=25$ 米和 $R=3$ 检查每一对。\n- $(2,3)$: $H_{2 \\to 3} = [20,22,25,27,19,16]$, $H_{3 \\to 2} = [18,21,24,26,20,15]$。\n  $b_2 = [0,0,1,1,0,0]$, $b_3 = [0,0,0,1,0,0]$。$c = [0,0,0,1,0,0]$。最大游程为 $1  3 \\implies$ 不存在边。\n- 没有其他对的高度达到 $25$ 米。\n- 没有形成边。$|E| = 0$。$\\bar{d} = 0.0$。\n- 连通分量：$5$ 个孤立节点 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}$。\n- 连通分量数为 $5$。最大连通分量的大小为 $1$。\n- 结果：$[0, 0.000, 5, 1]$\n\n**测试用例 5: $(T, R) = (10, 4)$**\n- 此用例使用 $T=10$ 米，与用例 2 相同，但要求更严格，$R=4$。我们重新评估用例 2 中的边。\n- $(0,1)$: 最大游程为 $3  4 \\implies$ 不存在边。\n- $(2,3)$: 最大游程为 $6 \\ge 4 \\implies$ 存在边。\n- $(0,4)$: 最大游程为 $3  4 \\implies$ 不存在边。\n- $(1,4)$: 最大游程为 $4 \\ge 4 \\implies$ 存在边。\n- 边：$(2,3), (1,4)$。这与用例 3 的边集相同。\n- $|E| = 2$。$\\bar{d} = \\frac{2 \\times 2}{5} = 0.8$。\n- 连通分量：$\\{0\\}, \\{1,4\\}, \\{2,3\\}$。\n- 连通分量数为 $3$。最大连通分量的大小为 $2$。\n- 结果：$[2, 0.800, 3, 2]$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the geospatial relational modeling problem by constructing graphs\n    and computing statistics for a set of test cases.\n    \"\"\"\n    \n    # Number of parcels (nodes in the graph)\n    N = 5\n\n    # LiDAR boundary sequences for all neighbor pairs.\n    # Format: (parcel_i, parcel_j, Heights_i-j, Heights_j-i)\n    neighbor_data = [\n        (0, 1, [9, 11, 12, 13, 8], [10, 12, 11, 14, 7]),\n        (1, 2, [5, 6, 7, 8], [5, 6, 7, 8]),\n        (2, 3, [20, 22, 25, 27, 19, 16], [18, 21, 24, 26, 20, 15]),\n        (3, 4, [0, 0, 0, 2], [0, 1, 0, 3]),\n        (0, 4, [10, 10, 10, 10], [9, 11, 12, 10]),\n        (1, 4, [14, 16, 18, 19], [13, 15, 17, 18]),\n        (1, 3, [8, 9, 10, 11, 12], [7, 8, 9, 10, 11]),\n    ]\n    \n    # Test suite of (Threshold, Run-length) pairs.\n    test_cases = [(0, 3), (10, 3), (15, 3), (25, 3), (10, 4)]\n    \n    final_results = []\n\n    def check_edge(h1, h2, T, R):\n        \"\"\"\n        Determines if an edge exists between two parcels based on canopy continuity.\n        \"\"\"\n        # Convert height sequences to binary based on threshold T.\n        b1 = np.greater_equal(h1, T)\n        b2 = np.greater_equal(h2, T)\n        \n        # Compute the continuity sequence via logical AND.\n        c = np.logical_and(b1, b2)\n        \n        # Find the longest contiguous run of 1s in the continuity sequence.\n        max_run = 0\n        current_run = 0\n        for val in c:\n            if val:\n                current_run += 1\n            else:\n                max_run = max(max_run, current_run)\n                current_run = 0\n        max_run = max(max_run, current_run) # Account for a run at the end.\n        \n        return max_run = R\n\n    def get_graph_stats(adj, num_nodes):\n        \"\"\"\n        Calculates the number of connected components and the size of the largest one.\n        \"\"\"\n        if not any(adj.values()): # Handle graph with no edges\n            return num_nodes, 1\n\n        visited = [False] * num_nodes\n        num_components = 0\n        largest_component_size = 0\n        \n        for i in range(num_nodes):\n            if not visited[i]:\n                num_components += 1\n                current_component_size = 0\n                q = [i]\n                visited[i] = True\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    current_component_size += 1\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                largest_component_size = max(largest_component_size, current_component_size)\n        \n        return num_components, largest_component_size\n\n    for T, R in test_cases:\n        # Initialize an adjacency list for the graph.\n        adj = {i: [] for i in range(N)}\n        num_edges = 0\n        \n        # Iterate through all potential neighbor pairs to build the graph.\n        for u, v, h_u, h_v in neighbor_data:\n            if check_edge(h_u, h_v, T, R):\n                adj[u].append(v)\n                adj[v].append(u)\n                num_edges += 1\n        \n        # Compute the required statistics.\n        avg_degree = round(2 * num_edges / N, 3)\n        n_components, lcc_size = get_graph_stats(adj, N)\n        \n        # Store the results for this test case.\n        final_results.append([num_edges, avg_degree, n_components, lcc_size])\n\n    # Format the final output string exactly as specified.\n    result_str = \",\".join(map(str, final_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在部署大规模地理空间GNN模型之前，预先评估其计算和内存成本是至关重要的。本练习 () 聚焦于GNN训练的核心算法——邻居采样，并让你通过第一性原理推导其复杂性。通过建立一个简化的计算图模型（$k$-ary tree），你将推导出模型深度 $L$ 和邻居采样数 $k$ 如何指数级地影响内存占用和计算量，从而掌握进行“信封背面”计算以规划实验资源的核心能力。",
            "id": "3818280",
            "problem": "一个水文信息地理空间图 $G=(V,E)$ 是根据一个流域的遥感影像构建的。$V$ 中的每个节点代表一个从卫星分割中提取的连续地块，并带有一个维度为 $d_f$ 的特征向量，该向量编码了光谱指数、地形属性和土壤描述符。$E$ 中的每条边连接相邻的地块，并带有一个维度为 $d_e$ 的边特征向量，该向量编码了根据流量累积和坡度估算出的水文连通性。一个具有 $L$ 个消息传递层的图神经网络（GNN）被训练用于洪水易感性建模。在每次前向传播过程中，GNN 使用无放回的均匀邻居采样：对于参与给定层的每个节点，从其邻接列表中精确采样 $k$ 个邻居，以构建下一层的计算子图。一个训练批次由 $B$ 个不同的种子节点组成。假设 $k \\geq 2$。\n\n为了实现物理一致性建模和易于处理的分析，采用以下假设：\n- 在 $L$ 层上，不同种子节点之间以及同一种子节点的后代之间的邻域重叠可以忽略不计，因此每个种子节点的计算子图可以被视为一个深度为 $L$ 的有根 $k$ 叉树。\n- 前向传播的内存占用主要由同时存储所有层中每个深度存在的所有节点的节点特征张量，以及连续深度之间所有采样边的边特征张量所决定。以标量特征槽为单位计算内存（即，特征向量中存储的每个标量分量计为一个槽）。忽略参数、梯度、优化器状态和任何常数开销。\n\n仅从这些假设以及图、邻居采样和有限几何级数的定义出发，推导以下内容的解析表达式：\n1. 批次采样计算子图存储所有节点和边特征所需的总前向传播内存占用 $M(B,k,L,d_f,d_e)$（以标量特征槽为单位）。\n2. 在所有 $L$ 层上，整个批次的预期节点扩展总数 $E(B,k,L)$，其中扩展定义为将一个新采样的邻居节点包含到计算子图中（不包括原始种子节点）。\n\n将你的最终答案表示为一对封闭形式的表达式。不需要进行数值计算，最终答案中也不应包含单位。",
            "solution": "该问题要求在一组特定的简化假设下，为 GNN 前向传播的总内存占用和节点扩展总数提供解析表达式。在图神经网络的理论分析背景下，这是一个定义明确且具有科学依据的问题。\n\n核心假设是，一个包含 $B$ 个种子节点的批次的计算子图可以建模为一个由 $B$ 棵不相交的、有根的、深度为 $L$ 的满 $k$ 叉树组成的森林。\n- $B$ 个种子节点中的每一个都是这样一棵树的根（在深度 $l=0$ 处）。\n- 一个具有 $L$ 层的 GNN 会探索距离种子节点最多 $L$ 跳的图。在我们的树模型中，这对应于包含从根（深度 $l=0$）到深度为 $l=L$ 的叶子的所有节点。\n- 在每一步中，深度为 $l$ 的一个节点在深度 $l+1$ 处有 $k$ 个子节点，代表 $k$ 个被采样的邻居。\n\n我们将首先推导内存占用 $M(B,k,L,d_f,d_e)$ 的表达式，然后推导节点扩展总数 $E(B,k,L)$ 的表达式。\n\n### 第一部分：总前向传播内存占用 $M(B,k,L,d_f,d_e)$\n\n规定的总内存占用 $M$ 是在整个批次的计算子图中存储所有节点特征（$M_{\\text{nodes}}$）和所有边特征（$M_{\\text{edges}}$）所需内存的总和。\n$$M = M_{\\text{nodes}} + M_{\\text{edges}}$$\n我们首先分析单个种子节点（一棵树）的结构，然后乘以 $B$。\n\n**节点特征内存 ($M_{\\text{nodes}}$)**\n一棵深度为 $L$ 的单个 $k$ 叉树中的节点总数是每个深度 $l$ (从 $l=0$ 到 $l=L$) 的节点数之和。\n深度为 $l$ 的节点数是 $k^l$。\n因此，每个种子的节点总数 $N_{\\text{nodes\\_per\\_seed}}$ 由以下总和给出：\n$$N_{\\text{nodes\\_per\\_seed}} = \\sum_{l=0}^{L} k^l = k^0 + k^1 + \\dots + k^L$$\n这是一个首项 $a=1$，公比 $r=k$，共有 $L+1$ 项的有限几何级数。其和由公式 $\\frac{a(r^{n}-1)}{r-1}$ 给出。使用我们的参数，这变成：\n$$N_{\\text{nodes\\_per\\_seed}} = \\frac{1(k^{L+1}-1)}{k-1} = \\frac{k^{L+1}-1}{k-1}$$\n整个批次 $B$ 个种子的节点总数是 $B \\times N_{\\text{nodes\\_per\\_seed}}$。\n节点特征的内存占用是这个总数乘以节点特征向量的维度 $d_f$。\n$$M_{\\text{nodes}} = B \\cdot d_f \\cdot N_{\\text{nodes\\_per\\_seed}} = B d_f \\frac{k^{L+1}-1}{k-1}$$\n\n**边特征内存 ($M_{\\text{edges}}$)**\n计算树中的边存在于深度为 $l-1$ 的节点与其在深度为 $l$ 的子节点之间，其中 $l$ 从 $1$ 到 $L$。\n对于单棵树，深度 $l-1$ 有 $k^{l-1}$ 个节点。这些节点中的每一个都连接到深度 $l$ 的 $k$ 个子节点。因此，在深度 $l-1$ 和 $l$ 之间有 $k^{l-1} \\times k = k^l$ 条边。\n每个种子的总边数 $N_{\\text{edges\\_per\\_seed}}$ 是从 $l=1$ 到 $L$ 的这些计数的总和：\n$$N_{\\text{edges\\_per\\_seed}} = \\sum_{l=1}^{L} k^l = k^1 + k^2 + \\dots + k^L$$\n这是一个首项为 $a=k$，公比为 $r=k$，共有 $L$ 项的有限几何级数。其和为：\n$$N_{\\text{edges\\_per\\_seed}} = \\frac{k(k^L-1)}{k-1}$$\n批次 $B$ 个种子的总边数是 $B \\times N_{\\text{edges\\_per\\_seed}}$。\n边特征的内存占用是这个总数乘以边特征向量的维度 $d_e$。\n$$M_{\\text{edges}} = B \\cdot d_e \\cdot N_{\\text{edges\\_per\\_seed}} = B d_e \\frac{k(k^L-1)}{k-1}$$\n$k \\geq 2$ 的条件确保了分母 $k-1$ 不为零。\n\n**总内存占用**\n将节点和边内存分量相加，得到总内存占用 $M$：\n$$M(B,k,L,d_f,d_e) = M_{\\text{nodes}} + M_{\\text{edges}} = B d_f \\frac{k^{L+1}-1}{k-1} + B d_e k \\frac{k^L-1}{k-1}$$\n通过提出公因式 $\\frac{B}{k-1}$，可以将其写成更紧凑的形式：\n$$M(B,k,L,d_f,d_e) = \\frac{B}{k-1} \\left( d_f(k^{L+1}-1) + d_e k(k^L-1) \\right)$$\n\n### 第二部分：预期节点扩展总数 $E(B,k,L)$\n\n“节点扩展”定义为包含一个新采样的邻居节点，不包括原始种子节点。\n这对应于计算计算子图中的所有节点，除了根节点（深度 $l=0$ 处的种子节点）。\n对于单个种子节点，扩展数是其树中节点总数减去根节点本身。\n$$N_{\\text{expansions\\_per\\_seed}} = N_{\\text{nodes\\_per\\_seed}} - 1 = \\left(\\sum_{l=0}^{L} k^l\\right) - k^0 = \\sum_{l=1}^{L} k^l$$\n这个和与我们之前计算的边数相同。这是合乎逻辑的，因为树中的每个非种子节点都是通过其父节点的一条入边被“扩展”或添加的。\n使用几何级数公式计算这个和：\n$$N_{\\text{expansions\\_per\\_seed}} = k \\frac{k^L-1}{k-1}$$\n批次的扩展总数 $E(B,k,L)$ 是这个数量的 $B$ 倍。\n$$E(B,k,L) = B \\cdot N_{\\text{expansions\\_per\\_seed}} = B k \\frac{k^L-1}{k-1}$$\n问题要求的是“预期”总数。在给定的重叠可忽略不计的假设下，计算图的结构是确定性的。因此，扩展数是一个固定量，其期望值就是该量本身。\n\n最终答案是推导出的 $M(B,k,L,d_f,d_e)$ 和 $E(B,k,L)$ 的封闭形式表达式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{B}{k-1} \\left( d_f(k^{L+1}-1) + d_e k(k^L-1) \\right)  B k \\frac{k^L - 1}{k-1}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一个模型的价值最终取决于其评估的严谨性。在地理空间领域，数据普遍存在的空间自相关性（即“邻近的事物更相似”）使得标准交叉验证方法失效，并常常导致对模型泛化能力的虚高估计。这项高级实践 () 将引导你实现一种健壮的评估技术——空间分块交叉验证（spatially blocked cross-validation），以有效防止信息泄露。掌握这种方法对于构建真正可靠并能在未知区域成功应用的地理空间预测模型至关重要。",
            "id": "3818318",
            "problem": "考虑一个表示遥感观测的地理空间节点集，该节点集将使用图神经网络 (GNN) 进行建模。目标是通过使用空间分块折来设计交叉验证 (CV) 折，以防止空间泄漏。当验证节点位于训练节点的空间自相关范围内或图消息传递半径内时，会发生泄漏。假设目标场服从一个二阶平稳、各向同性的高斯过程，且空间自相关由一个仅依赖于分离距离 $h$ 的相关函数 $\\rho(h)$ 给出。有效独立范围 $d_{\\mathrm{eff}}$ 定义为使得 $\\rho(h) \\le \\tau$ 成立的最小 $h$，其中 $\\tau \\in (0,1)$ 是用户指定的可忽略相关性阈值。为避免泄漏所需的块-缓冲距离为 $d_{\\mathrm{block}} = \\max\\{d_{\\mathrm{eff}}, r_g\\}$，其中 $r_g$ 是 GNN 图的连接性/消息传递半径。\n\n使用以下来自地理统计学的经过充分检验的相关模型作为基础：\n- 指数相关: $\\rho(h) = \\exp\\{-h / \\ell\\}$，其中 $\\ell  0$ 是长度尺度。\n- Matérn 相关: $\\rho(h) = \\dfrac{2^{1 - \\nu}}{\\Gamma(\\nu)} \\left(\\dfrac{h}{\\ell}\\right)^{\\nu} K_{\\nu}\\!\\left(\\dfrac{h}{\\ell}\\right)$，其中 $\\nu  0$ 是平滑度，$\\ell  0$ 是长度尺度，$\\Gamma(\\cdot)$ 是伽马函数，而 $K_{\\nu}(\\cdot)$ 是第二类修正贝塞尔函数。\n\n按如下方式构建 $k$ 个空间分块折：\n1. 对于给定的相关模型和参数，计算 $d_{\\mathrm{eff}}$ 作为满足 $\\rho(h) \\le \\tau$ 的最小 $h$。\n2. 设置 $d_{\\mathrm{block}} = \\max\\{d_{\\mathrm{eff}}, r_g\\}$。\n3. 将空间域离散化为边长为 $b$ 的正方形块，其中 $b \\ge d_{\\mathrm{block}}$。通过将其坐标（以公里为单位）除以 $b$ 并取整，将每个节点分配到一个块中。\n4. 使用块索引的确定性哈希将每个唯一的块映射到 $\\{0,1,\\dots,k-1\\}$ 中的一个折索引。对于给定的折 $f$，验证集由其所在块映射到 $f$ 的所有节点组成。\n5. 为防止泄漏，从训练集中排除任何与任一验证节点的欧几里得距离严格小于 $d_{\\mathrm{block}}$ 的节点。\n\n对于每个折，计算最终训练集和验证集之间的最小集间距离 $d_{\\min}$。如果 $d_{\\min} \\ge d_{\\mathrm{block}}$，则该折是无泄漏的。如果所有折都无泄漏，则该测试用例是无泄漏的。\n\n所有距离必须以公里 (km) 计算和报告。将 $d_{\\mathrm{eff}}$ 四舍五入到三位小数。不使用角度。将任何分数表示为十进制数。\n\n实现一个完整的、可运行的程序，该程序针对以下测试套件，计算 $d_{\\mathrm{eff}}$ 并按上述方法评估无泄漏的分块交叉验证：\n\n测试套件（每个案例指定域、网格、相关模型和参数、阈值、图半径和折数）：\n- 案例1 (正常路径)：域 $[0,50] \\times [0,50]$ km，节点位于 $10 \\times 10$ 网格上，间距为 $5$ km；模型为指数模型，$\\ell = 5$ km；阈值 $\\tau = 0.05$；图半径 $r_g = 8$ km；折数 $k = 5$。\n- 案例2 (通用 Matérn)：域 $[0,60] \\times [0,60]$ km，节点位于 $11 \\times 11$ 网格上，间距为 $6$ km；模型为 Matérn 模型，$\\nu = 1.5$，$\\ell = 7$ km；阈值 $\\tau = 0.10$；图半径 $r_g = 10$ km；折数 $k = 4$。\n- 案例3 (当 $\\nu = 0.5$ 时 Matérn 等价于指数模型)：域 $[0,100] \\times [0,100]$ km，节点位于 $11 \\times 11$ 网格上，间距为 $10$ km；模型为 Matérn 模型，$\\nu = 0.5$，$\\ell = 12$ km；阈值 $\\tau = 0.20$；图半径 $r_g = 5$ km；折数 $k = 6$。\n- 案例4 (边缘情况：域太小)：域 $[0,20] \\times [0,20]$ km，节点位于 $5 \\times 5$ 网格上，间距为 $5$ km；模型为指数模型，$\\ell = 8$ km；阈值 $\\tau = 0.05$；图半径 $r_g = 3$ km；折数 $k = 3$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每一项是形如 $[d_{\\mathrm{eff}}, \\text{leak\\_free}]$ 的列表，其中 $d_{\\mathrm{eff}}$ 四舍五入到三位小数，而 $\\text{leak\\_free}$ 是一个布尔值，指示该案例中所有折是否无泄漏，例如：$[[14.979,True],[...,False],...]$。",
            "solution": "用户提供的问题经评估有效。它在科学上基于地理统计学和机器学习的原理，问题定义明确，具有清晰的算法流程，并包含唯一解所需的所有数据。因此，我将继续提供完整的解决方案。\n\n该问题要求为应用于地理空间数据的图神经网络 (GNN) 模型设计和评估一种空间分块交叉验证 (CV) 策略。核心原则是防止训练集和验证集之间的信息泄漏，这种泄漏可能由空间自相关引起。当数据点彼此靠近时，它们的值通常是相关的。如果训练集和验证集包含空间上邻近的点，模型可能会仅仅通过与训练数据的邻近性来学习预测验证目标，从而导致对其泛化性能的过于乐观的估计。\n\n我们的方法结构如下：\n1.  量化空间自相关范围。\n2.  定义一个同时考虑此自相关和 GNN 消息传递半径的缓冲距离。\n3.  使用由此缓冲距离分隔的空间块来构建 CV 折。\n4.  验证每个折产生的训练集和验证集确实是空间分离的。\n\n**1. 量化空间自相关：有效独立范围 ($d_{\\mathrm{eff}}$)**\n\n问题假定潜在的地理空间场服从一个二阶平稳且各向同性的高斯过程。这意味着两个位置的观测值之间的相关性仅取决于它们之间的欧几里得距离 $h$，由相关函数 $\\rho(h)$ 描述。我们将有效独立范围 $d_{\\mathrm{eff}}$ 定义为空间相关性降至指定的可忽略阈值 $\\tau$ 以下的最小距离。数学上，$d_{\\mathrm{eff}}$ 是方程：\n$$\n\\rho(h) = \\tau\n$$\n的解。由于相关函数 $\\rho(h)$ 对于 $h \\ge 0$ 是单调递减的，因此对于任何 $\\tau \\in (0,1)$，都存在唯一的 $h$ 解。\n\n问题指定了两种相关模型：\n-   **指数模型 (Exponential Model)**：相关性由 $\\rho(h) = \\exp\\{-h / \\ell\\}$ 给出，其中 $\\ell$ 是长度尺度。我们可以解析地求解 $d_{\\mathrm{eff}}$：\n    $$\n    \\exp\\{-d_{\\mathrm{eff}} / \\ell\\} = \\tau \\implies -d_{\\mathrm{eff}} / \\ell = \\ln(\\tau) \\implies d_{\\mathrm{eff}} = -\\ell \\ln(\\tau)\n    $$\n-   **Matérn 模型 (Matérn Model)**：相关性为 $\\rho(h) = \\dfrac{2^{1 - \\nu}}{\\Gamma(\\nu)} \\left(\\dfrac{h}{\\ell}\\right)^{\\nu} K_{\\nu}\\!\\left(\\dfrac{h}{\\ell}\\right)$，其中 $\\nu$ 是平滑度参数，$\\ell$ 是长度尺度，$\\Gamma(\\cdot)$ 是伽马函数，而 $K_{\\nu}(\\cdot)$ 是第二类修正贝塞尔函数。对于此模型，通常无法得到 $h$ 的解析解。我们必须使用数值方法找到函数 $f(h) = \\rho(h) - \\tau$ 的根。鉴于 $f(h)$ 是单调的，像 `Brent-Dekker` 方法 (`brentq`) 这样的稳健求根算法是合适的。\n\nMatérn 模型的一个特例是当 $\\nu=0.5$ 时，它简化为指数模型 $\\rho(h) = \\exp(-h/\\ell)$，此时可以使用解析解。\n\n**2. 定义块-缓冲距离 ($d_{\\mathrm{block}}$)**\n\n泄漏可能通过两种机制发生：底层场中的隐式相关和 GNN 中的显式信息流。GNN 在节点之间传播信息，传播距离由其层数和图连接性决定，我们将其表示为消息传递半径 $r_g$。为防止这两种类型的泄漏，我们必须强制实施一个分离距离，该距离考虑了这两个范围中较大的一个。因此，所需的块-缓冲距离 $d_{\\mathrm{block}}$ 定义为：\n$$\nd_{\\mathrm{block}} = \\max\\{d_{\\mathrm{eff}}, r_g\\}\n$$\n\n**3. 空间分块交叉验证算法**\n\n在确定了 $d_{\\mathrm{block}}$ 之后，我们使用以下确定性过程构建 $k$ 个 CV 折：\n1.  **节点生成**：首先，我们根据指定的网格大小和在给定域内的间距生成节点坐标集。\n2.  **域离散化**：将空间域划分为一个正方形块网格。为确保块足够大以便于分离，我们将每个块的边长 $b$ 设置为等于 $d_{\\mathrm{block}}$。位于坐标 $(x, y)$ 的节点被分配到整数索引为 $(\\lfloor x/b \\rfloor, \\lfloor y/b \\rfloor)$ 的块中。\n3.  **折分配**：每个由其索引元组标识的唯一块被确定性地映射到 $k$ 个折中的一个。这是通过对其块索引元组应用哈希函数，然后对 $k$ 取模来实现的。因此，同一块内的所有节点都被分配到同一个折中。\n4.  **带缓冲的训练集构建**：对于每个折 $f \\in \\{0, 1, \\dots, k-1\\}$：\n    a. **验证集**由分配给折 $f$ 的所有节点组成。\n    b. 初始**训练集**由不在验证集中的所有节点组成。\n    c. 为防止泄漏，我们围绕验证集创建一个缓冲区。初始训练集中任何与*任一*验证节点的欧几里得距离严格小于 $d_{\\mathrm{block}}$ 的节点都将被移除。剩余的节点构成了最终的、带缓冲的训练集。\n\n**4. 泄漏预防的验证**\n\n最后一步是验证该过程是否成功。对于每个折，我们计算最小集间距离 $d_{\\min}$，即最终训练集中的任何节点与验证集中的任何节点之间的最小欧几里得距离。\n$$\nd_{\\min} = \\min_{\\mathbf{x}_{\\text{train}} \\in \\text{TrainSet}, \\mathbf{x}_{\\text{val}} \\in \\text{ValSet}} ||\\mathbf{x}_{\\text{train}} - \\mathbf{x}_{\\text{val}}||_2\n$$\n如果 $d_{\\min} \\ge d_{\\mathrm{block}}$，则认为该折是**无泄漏的**。根据我们构建带缓冲训练集的方式，只要最终的训练集和验证集都非空，此条件就必须成立。如果任一集合为空，则距离实际上是无限大，该折也被认为是无泄漏的。当且仅当一个测试用例的所有 $k$ 个折都是无泄漏时，该测试用例才是无泄漏的。实现将为每个折计算此值，以确认过程的完整性。\n\n以下 Python 代码为提供的测试套件实现了这整个过程，使用 `numpy` 进行高效的数组操作，并使用 `scipy` 中 Matérn 模型所需的特殊函数和数值求根功能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, kv\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Exponential model\n        {'domain_max': 50, 'grid_n': 10, 'spacing': 5, 'model': 'exponential', \n         'params': {'ell': 5}, 'tau': 0.05, 'r_g': 8, 'k': 5},\n        # Case 2: Matérn model (general)\n        {'domain_max': 60, 'grid_n': 11, 'spacing': 6, 'model': 'matern', \n         'params': {'nu': 1.5, 'ell': 7}, 'tau': 0.10, 'r_g': 10, 'k': 4},\n        # Case 3: Matérn model (nu=0.5, equivalent to exponential)\n        {'domain_max': 100, 'grid_n': 11, 'spacing': 10, 'model': 'matern', \n         'params': {'nu': 0.5, 'ell': 12}, 'tau': 0.20, 'r_g': 5, 'k': 6},\n        # Case 4: Edge case where d_block is large relative to domain\n        {'domain_max': 20, 'grid_n': 5, 'spacing': 5, 'model': 'exponential', \n         'params': {'ell': 8}, 'tau': 0.05, 'r_g': 3, 'k': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    output_parts = []\n    for res_item in results:\n        # Format d_eff to 3 decimal places, even with trailing zeros.\n        d_eff_str = f\"{res_item[0]:.3f}\"\n        leak_free_str = str(res_item[1])\n        output_parts.append(f\"[{d_eff_str},{leak_free_str}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef _process_case(case_params):\n    \"\"\"\n    Processes a single test case from the suite.\n    \"\"\"\n    # 1. Generate node coordinates\n    coords = np.arange(case_params['grid_n']) * case_params['spacing']\n    xv, yv = np.meshgrid(coords, coords)\n    nodes = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    # 2. Compute effective independence range d_eff\n    if case_params['model'] == 'exponential':\n        d_eff = _d_eff_exponential(case_params['params']['ell'], case_params['tau'])\n    elif case_params['model'] == 'matern':\n        d_eff = _d_eff_matern(case_params['params']['nu'], case_params['params']['ell'], case_params['tau'])\n    \n    d_eff_rounded = round(d_eff, 3)\n\n    # 3. Compute block-buffer distance d_block\n    d_block = max(d_eff_rounded, case_params['r_g'])\n    \n    # 4. Assign nodes to blocks and then to folds\n    # Use b = d_block as the block side length.\n    # Handle the case where d_block is zero or negative (though unlikely).\n    b = d_block if d_block  0 else 1.0 \n    block_indices = np.floor(nodes / b).astype(int)\n    \n    k = case_params['k']\n    fold_assignments = np.array([hash(tuple(bi)) % k for bi in block_indices])\n\n    # 5. Iterate through folds, build buffered sets, and check for leakage\n    is_case_leak_free = True\n    for f in range(k):\n        val_mask = fold_assignments == f\n        train_mask_potential = ~val_mask\n\n        validation_nodes = nodes[val_mask]\n        train_nodes_potential = nodes[train_mask_potential]\n        \n        # If no nodes in validation set for this fold, it's trivially leakage-free.\n        if validation_nodes.shape[0] == 0:\n            continue\n            \n        # If no potential training nodes, also trivially leakage-free.\n        if train_nodes_potential.shape[0] == 0:\n            continue\n\n        # Exclude training nodes within d_block of any validation node\n        # Using squared distances for efficiency\n        dist_sq = np.sum((train_nodes_potential[:, np.newaxis, :] - validation_nodes[np.newaxis, :, :])**2, axis=-1)\n        min_dist_sq_to_val = np.min(dist_sq, axis=1)\n        \n        # The condition for keeping a node is that its minimum distance to any validation node\n        # is GREATER THAN OR EQUAL TO d_block.\n        keep_mask = min_dist_sq_to_val = d_block**2\n        \n        final_train_nodes = train_nodes_potential[keep_mask]\n        \n        # Verify leakage-free condition\n        # This is a verification step. By construction, this should always be true\n        # unless one of the final sets is empty.\n        is_fold_leak_free = True\n        if final_train_nodes.shape[0]  0 and validation_nodes.shape[0]  0:\n            final_dist_sq = np.sum((final_train_nodes[:, np.newaxis, :] - validation_nodes[np.newaxis, :, :])**2, axis=-1)\n            d_min_sq = np.min(final_dist_sq)\n            d_min = np.sqrt(d_min_sq)\n            \n            # Use a small tolerance for floating point comparisons\n            if not np.isclose(d_min, d_block) and d_min  d_block:\n                is_fold_leak_free = False\n        \n        if not is_fold_leak_free:\n            is_case_leak_free = False\n            break\n\n    return [d_eff_rounded, is_case_leak_free]\n\ndef _d_eff_exponential(ell, tau):\n    \"\"\"Calculates d_eff for the Exponential correlation model.\"\"\"\n    return -ell * np.log(tau)\n\ndef _matern_corr(h, nu, ell):\n    \"\"\"Computes the Matérn correlation.\"\"\"\n    if h == 0:\n        return 1.0\n    # To prevent division by zero or negative inputs for h\n    h = np.maximum(h, 1e-9)\n        \n    const = 2**(1 - nu) / gamma(nu)\n    arg = h / ell\n    \n    return const * (arg**nu) * kv(nu, arg)\n\ndef _d_eff_matern(nu, ell, tau):\n    \"\"\"Calculates d_eff for the Matérn model using a numerical solver.\"\"\"\n    # Special case for nu=0.5, which is equivalent to exponential\n    if np.isclose(nu, 0.5):\n        return _d_eff_exponential(ell, tau)\n    \n    # Objective function for the root finder\n    objective = lambda h: _matern_corr(h, nu, ell) - tau\n    \n    # Find the root h where the correlation equals the threshold tau.\n    # The function is monotonic, so a root is guaranteed.\n    # Bracket [1e-9, large_number] is safe.\n    try:\n        d_eff = brentq(objective, 1e-9, ell * 50)\n    except ValueError:\n        # Fallback if root is not in bracket, though unlikely with this large range\n        d_eff = brentq(objective, 1e-9, ell * 500)\n    \n    return d_eff\n\nsolve()\n\n```"
        }
    ]
}