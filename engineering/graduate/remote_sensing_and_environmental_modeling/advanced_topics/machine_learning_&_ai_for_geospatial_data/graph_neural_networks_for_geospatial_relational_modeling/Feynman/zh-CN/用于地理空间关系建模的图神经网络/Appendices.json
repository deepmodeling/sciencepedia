{
    "hands_on_practices": [
        {
            "introduction": "在任何地理空间图神经网络（GNN）应用中，首要任务都是将现实世界的空间关系转化为图结构。本练习提供了一个具体的实践，指导您如何使用LiDAR数据，基于物理上有意义的标准（如冠层连续性）来定义图的边。通过这个练习，您将掌握参数化图构建规则并理解其对图拓扑影响的核心技能。",
            "id": "3818275",
            "problem": "我们使用沿共享地块边界聚合的激光雷达 (LiDAR) 点云数据，为一组地块构建了一个地理空间关系模型。其目标是基于冠层连续性，使用高度阈值来定义无向图中的边，并计算不同阈值下的邻接统计数据。预期的应用是生成一个适用于图神经网络 (GNN) 的邻接结构，该网络用于建模地理空间交互。\n\n基本原理：\n- LiDAR 测量的是地面以上的冠层高度，这是一个以米为单位的物理量。设采样点的冠层高度表示为 $h \\in \\mathbb{R}_{\\ge 0}$，单位为米。\n- 图定义为 $G = (V, E)$，其中 $V$ 是节点集，$E$ 是无向边集。邻接矩阵 $A \\in \\{0,1\\}^{|V| \\times |V|}$ 表示边的存在，当且仅当 $(i,j) \\in E$ (其中 $i \\ne j$) 时，$A_{ij} = 1$，且 $A_{ii} = 0$。\n- 对于无向图，平均度定义为 $\\bar{d} = \\frac{2|E|}{|V|}$。\n\n基于冠层连续性的边定义：\n- 考虑两个共享边界的地块 $i$ 和 $j$。沿共享边界的 LiDAR 派生样本序列以每个地块的高度列表形式给出，$H_{i \\to j} = [h_{i,0}, h_{i,1}, \\dots, h_{i,L-1}]$ 和 $H_{j \\to i} = [h_{j,0}, h_{j,1}, \\dots, h_{j,L-1}]$，其中 $L$ 是边界对齐样本的数量，每个 $h_{i,k}$ 和 $h_{j,k}$ 的单位都是米。\n- 给定以米为单位的冠层高度阈值 $T$ 和一个连续游程长度要求 $R \\in \\mathbb{N}$，定义二元序列 $b_{i,k} = \\mathbb{I}(h_{i,k} \\ge T)$ 和 $b_{j,k} = \\mathbb{I}(h_{j,k} \\ge T)$，其中 $k = 0, 1, \\dots, L-1$，$\\mathbb{I}(\\cdot)$ 是指示函数。\n- 定义连续性序列 $c_k = b_{i,k} \\land b_{j,k}$，其中 $k = 0, 1, \\dots, L-1$。当且仅当在 $\\{0,1,\\dots,L-1\\}$ 中存在一个长度至少为 $R$ 的连续索引游程，使得这些索引对应的 $c_k = 1$ 时，无向边 $(i,j)$ 存在。\n\n数据规格：\n- 地块数量为 $N = 5$，索引为 $0, 1, 2, 3, 4$。\n- 邻居对（共享边界）和 LiDAR 边界序列（单位：米）如下：\n    - 对 $(0,1)$: $H_{0 \\to 1} = [9,11,12,13,8]$, $H_{1 \\to 0} = [10,12,11,14,7]$。\n    - 对 $(1,2)$: $H_{1 \\to 2} = [5,6,7,8]$, $H_{2 \\to 1} = [5,6,7,8]$。\n    - 对 $(2,3)$: $H_{2 \\to 3} = [20,22,25,27,19,16]$, $H_{3 \\to 2} = [18,21,24,26,20,15]$。\n    - 对 $(3,4)$: $H_{3 \\to 4} = [0,0,0,2]$, $H_{4 \\to 3} = [0,1,0,3]$。\n    - 对 $(0,4)$: $H_{0 \\to 4} = [10,10,10,10]$, $H_{4 \\to 0} = [9,11,12,10]$。\n    - 对 $(1,4)$: $H_{1 \\to 4} = [14,16,18,19]$, $H_{4 \\to 1} = [13,15,17,18]$。\n    - 对 $(1,3)$: $H_{1 \\to 3} = [8,9,10,11,12]$, $H_{3 \\to 1} = [7,8,9,10,11]$。\n- 所有高度的单位均为米。所有阈值 $T$ 必须以米为单位指定。\n\n任务：\n1. 对于测试套件中的每个 $(T, R)$ 对，使用定义的边规则构建无向图 $G = (V, E)$，其中 $V = \\{0,1,2,3,4\\}$。\n2. 计算：\n   - 边的数量 $|E|$。\n   - 平均度 $\\bar{d}$，为浮点数，保留三位小数。\n   - 连通分量的数量（整数）。\n   - 最大连通分量的大小（整数）。\n\n测试套件：\n- 待评估的 $(T, R)$ 对集合为 $[(0,3), (10,3), (15,3), (25,3), (10,4)]$。所有 $T$ 值的单位都是米，$R$ 是整数样本数。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身应该是一个形式为 $[|E|, \\bar{d}, \\text{连通分量数}, \\text{最大连通分量大小}]$ 的列表，其中 $|E|$ 是一个整数，$\\bar{d}$ 是一个保留三位小数的浮点数，$\\text{连通分量数}$ 是一个整数，而 $\\text{最大连通分量大小}$ 也是一个整数。\n- 例如，输出格式必须类似于 `[[e_1,\\bar{d}_1,c_1,l_1],[e_2,\\bar{d}_2,c_2,l_2],\\dots]`，不得包含额外文本。\n\n科学真实性和约束条件：\n- 将图视为无向图。\n- 使用包含性阈值规则 $h \\ge T$。\n- 连续性要求 $R$ 是样本索引中的严格最小游程长度。\n- 除提供的序列外，不应使用任何外部数据。所有高度和阈值的单位均为米，所有计算出的统计数据均为无量纲的计数或浮点数。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于地理空间数据分析和图论的原理，定义清晰，数据充分，问题提出得当，表述客观。该问题没有矛盾、歧义和事实错误。因此，我们可以进行正式的求解。\n\n问题的核心是根据“冠层连续性”的特定规则构建一个无向图 $G = (V, E)$，然后为该规则的不同参数化计算一组标准的图论统计量。节点集合是固定的 $V = \\{0, 1, 2, 3, 4\\}$，代表 $N=5$ 个地块。\n\n步骤如下：\n1.  对于每个由冠层高度阈值 $T$（单位：米）和连续游程长度要求 $R$（无量纲计数）定义的测试用例，我们确定边集 $E$。\n2.  当且仅当地块 $i$ 和 $j$ 是一个邻居对并且满足冠层连续性准则时，才将边 $(i, j)$ 添加到 $E$ 中。\n3.  一旦为给定的 $(T, R)$ 对完全构建了图 $G$，我们就计算所需的统计数据：边的数量 $|E|$、平均度 $\\bar{d}$、连通分量的数量以及最大连通分量的大小。\n\n**边定义算法**\n\n对于给定的一对相邻地块 $(i, j)$，其对应的 LiDAR 高度样本序列为 $H_{i \\to j} = [h_{i,0}, \\dots, h_{i,L-1}]$ 和 $H_{j \\to i} = [h_{j,0}, \\dots, h_{j,L-1}]$，以及给定的参数 $(T, R)$：\n\n1.  **阈值化处理**：创建两个二元序列 $b_i = [b_{i,0}, \\dots, b_{i,L-1}]$ 和 $b_j = [b_{j,0}, \\dots, b_{j,L-1}]$，其元素由指示函数 $\\mathbb{I}(\\cdot)$ 确定：\n    $$b_{i,k} = \\mathbb{I}(h_{i,k} \\ge T)$$\n    $$b_{j,k} = \\mathbb{I}(h_{j,k} \\ge T)$$\n    对于每个样本索引 $k \\in \\{0, 1, \\dots, L-1\\}$。\n\n2.  **连续性检查**：通过对二元序列按元素应用逻辑与操作（$\\land$）来计算单个连续性序列 $c = [c_0, \\dots, c_{L-1}]$：\n    $$c_k = b_{i,k} \\land b_{j,k}$$\n    这意味着，只有当样本位置 $k$ 处*两个*地块的冠层高度都高于阈值 $T$ 时，$c_k$ 才为 1。\n\n3.  **游程长度评估**：在连续性序列 $c$ 中搜索长度至少为 $R$ 的任何连续的 1 子序列。如果存在这样的游程，则形成一条无向边 $(i, j)$。否则，在地块 $i$ 和 $j$ 之间不形成边。\n\n**图统计量计算**\n\n对于一个已构建的具有 $|V|=N=5$ 个节点的图 $G=(V, E)$：\n\n1.  **边的数量 $|E|$**：这是算法创建的唯一边的总数。\n2.  **平均度 $\\bar{d}$**：对于无向图，它由公式 $\\bar{d} = \\frac{2|E|}{|V|}$ 给出。\n3.  **连通分量**：连通分量的数量和最大分量的大小通过遍历图来确定。可以采用标准算法，如广度优先搜索 (BFS) 或深度优先搜索 (DFS)。我们遍历从 $0$ 到 $N-1$ 的所有节点。如果一个节点尚未被访问，我们从它开始一个新的遍历，增加分量计数，并探索所有可达节点，对它们进行计数以确定这个新分量的大小。记录所有分量中找到的最大尺寸。\n\n**对每个测试用例的执行**\n\n我们将此方法应用于所提供测试套件中的每个 $(T, R)$ 对。\n\n**测试用例 1: $(T, R) = (0, 3)$**\n- 当 $T=0$ 米时，任何高度 $h \\ge 0$ 都满足阈值条件。由于所有提供的高度都是非负的，因此对于所有样本，$b_{i,k}=1$ 和 $b_{j,k}=1$。\n- 任何地块对的连续性序列 $c$ 都将是一个全为 1 的序列。\n- 如果边界序列的长度 $L$ 至少为 $R=3$，则存在一条边。\n- 对 $(0,1), L=5 \\ge 3 \\implies$ 存在边。\n- 对 $(1,2), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(2,3), L=6 \\ge 3 \\implies$ 存在边。\n- 对 $(3,4), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(0,4), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(1,4), L=4 \\ge 3 \\implies$ 存在边。\n- 对 $(1,3), L=5 \\ge 3 \\implies$ 存在边。\n- 所有 7 个潜在的邻居对都形成边。\n- $|E| = 7$。$\\bar{d} = \\frac{2 \\times 7}{5} = 2.8$。\n- 生成的图是全连接的。连通分量数为 $1$。最大连通分量的大小为 $5$。\n- 结果: $[7, 2.800, 1, 5]$\n\n**测试用例 2: $(T, R) = (10, 3)$**\n- 我们检查每个地块对，参数为 $T=10$ 米和 $R=3$。\n- $(0,1)$: $c = [0,1,1,1,0]$。最大游程长度为 $3$。$3 \\ge 3 \\implies$ 存在边。\n- $(1,2)$: $c = [0,0,0,0]$。最大游程为 $0  3 \\implies$ 不存在边。\n- $(2,3)$: $c = [1,1,1,1,1,1]$。最大游程为 $6 \\ge 3 \\implies$ 存在边。\n- $(3,4)$: $c = [0,0,0,0]$。最大游程为 $0  3 \\implies$ 不存在边。\n- $(0,4)$: $c = [0,1,1,1]$。最大游程为 $3 \\ge 3 \\implies$ 存在边。\n- $(1,4)$: $c = [1,1,1,1]$。最大游程为 $4 \\ge 3 \\implies$ 存在边。\n- $(1,3)$: $c = [0,0,0,1,1]$。最大游程为 $2  3 \\implies$ 不存在边。\n- 存在的边: $(0,1), (2,3), (0,4), (1,4)$。\n- $|E| = 4$。$\\bar{d} = \\frac{2 \\times 4}{5} = 1.6$。\n- 连通分量：节点 $0$ 连接到 $1$ 和 $4$。节点 $1$ 连接到 $4$。这形成了分量 $\\{0,1,4\\}$。节点 $2$ 连接到 $3$，形成分量 $\\{2,3\\}$。\n- 连通分量数为 $2$。最大连通分量的大小为 $3$。\n- 结果: $[4, 1.600, 2, 3]$\n\n**测试用例 3: $(T, R) = (15, 3)$**\n- 我们检查每个地块对，参数为 $T=15$ 米和 $R=3$。\n- $(0,1)$: 没有高度 $\\ge 15$。不存在边。\n- $(1,2)$: 没有高度 $\\ge 15$。不存在边。\n- $(2,3)$: $c = [1,1,1,1,1,1]$。最大游程为 $6 \\ge 3 \\implies$ 存在边。\n- $(3,4)$: 没有高度 $\\ge 15$。不存在边。\n- $(0,4)$: 没有高度 $\\ge 15$。不存在边。\n- $(1,4)$: $c = [0,1,1,1]$。最大游程为 $3 \\ge 3 \\implies$ 存在边。\n- $(1,3)$: 所有高度都 $\\le 12$。不存在边。\n- 存在的边: $(2,3), (1,4)$。\n- $|E| = 2$。$\\bar{d} = \\frac{2 \\times 2}{5} = 0.8$。\n- 连通分量: $\\{0\\}$, $\\{1,4\\}$, $\\{2,3\\}$。\n- 连通分量数为 $3$。最大连通分量的大小为 $2$。\n- 结果: $[2, 0.800, 3, 2]$\n\n**测试用例 4: $(T, R) = (25, 3)$**\n- 我们检查每个地块对，参数为 $T=25$ 米和 $R=3$。\n- $(2,3)$: $H_{2 \\to 3} = [20,22,25,27,19,16]$, $H_{3 \\to 2} = [18,21,24,26,20,15]$。\n  $b_2 = [0,0,1,1,0,0]$, $b_3 = [0,0,0,1,0,0]$。$c = [0,0,0,1,0,0]$。最大游程为 $1  3 \\implies$ 不存在边。\n- 没有其他地块对的高度达到 $25$ 米。\n- 没有形成任何边。$|E| = 0$。$\\bar{d} = 0.0$。\n- 连通分量：5 个孤立节点 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}$。\n- 连通分量数为 $5$。最大连通分量的大小为 $1$。\n- 结果: $[0, 0.000, 5, 1]$\n\n**测试用例 5: $(T, R) = (10, 4)$**\n- 此用例使用与用例 2 相同的 $T=10$ 米，但要求更严格，$R=4$。我们重新评估用例 2 中的边。\n- $(0,1)$: 最大游程为 $3  4 \\implies$ 不存在边。\n- $(2,3)$: 最大游程为 $6 \\ge 4 \\implies$ 存在边。\n- $(0,4)$: 最大游程为 $3  4 \\implies$ 不存在边。\n- $(1,4)$: 最大游程为 $4 \\ge 4 \\implies$ 存在边。\n- 存在的边: $(2,3), (1,4)$。这与用例 3 的边集相同。\n- $|E| = 2$。$\\bar{d} = \\frac{2 \\times 2}{5} = 0.8$。\n- 连通分量: $\\{0\\}$, $\\{1,4\\}$, $\\{2,3\\}$。\n- 连通分量数为 $3$。最大连通分量的大小为 $2$。\n- 结果: $[2, 0.800, 3, 2]$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the geospatial relational modeling problem by constructing graphs\n    and computing statistics for a set of test cases.\n    \"\"\"\n    \n    # Number of parcels (nodes in the graph)\n    N = 5\n\n    # LiDAR boundary sequences for all neighbor pairs.\n    # Format: (parcel_i, parcel_j, Heights_i-j, Heights_j-i)\n    neighbor_data = [\n        (0, 1, [9, 11, 12, 13, 8], [10, 12, 11, 14, 7]),\n        (1, 2, [5, 6, 7, 8], [5, 6, 7, 8]),\n        (2, 3, [20, 22, 25, 27, 19, 16], [18, 21, 24, 26, 20, 15]),\n        (3, 4, [0, 0, 0, 2], [0, 1, 0, 3]),\n        (0, 4, [10, 10, 10, 10], [9, 11, 12, 10]),\n        (1, 4, [14, 16, 18, 19], [13, 15, 17, 18]),\n        (1, 3, [8, 9, 10, 11, 12], [7, 8, 9, 10, 11]),\n    ]\n    \n    # Test suite of (Threshold, Run-length) pairs.\n    test_cases = [(0, 3), (10, 3), (15, 3), (25, 3), (10, 4)]\n    \n    final_results = []\n\n    def check_edge(h1, h2, T, R):\n        \"\"\"\n        Determines if an edge exists between two parcels based on canopy continuity.\n        \"\"\"\n        # Convert height sequences to binary based on threshold T.\n        b1 = np.greater_equal(h1, T)\n        b2 = np.greater_equal(h2, T)\n        \n        # Compute the continuity sequence via logical AND.\n        c = np.logical_and(b1, b2)\n        \n        # Find the longest contiguous run of 1s in the continuity sequence.\n        max_run = 0\n        current_run = 0\n        for val in c:\n            if val:\n                current_run += 1\n            else:\n                max_run = max(max_run, current_run)\n                current_run = 0\n        max_run = max(max_run, current_run) # Account for a run at the end.\n        \n        return max_run >= R\n\n    def get_graph_stats(adj, num_nodes):\n        \"\"\"\n        Calculates the number of connected components and the size of the largest one.\n        \"\"\"\n        if not any(adj.values()): # Handle graph with no edges\n            return num_nodes, 1\n\n        visited = [False] * num_nodes\n        num_components = 0\n        largest_component_size = 0\n        \n        for i in range(num_nodes):\n            if not visited[i]:\n                num_components += 1\n                current_component_size = 0\n                q = [i]\n                visited[i] = True\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    current_component_size += 1\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                largest_component_size = max(largest_component_size, current_component_size)\n        \n        return num_components, largest_component_size\n\n    for T, R in test_cases:\n        # Initialize an adjacency list for the graph.\n        adj = {i: [] for i in range(N)}\n        num_edges = 0\n        \n        # Iterate through all potential neighbor pairs to build the graph.\n        for u, v, h_u, h_v in neighbor_data:\n            if check_edge(h_u, h_v, T, R):\n                adj[u].append(v)\n                adj[v].append(u)\n                num_edges += 1\n        \n        # Compute the required statistics.\n        avg_degree = round(2 * num_edges / N, 3)\n        n_components, lcc_size = get_graph_stats(adj, N)\n        \n        # Store the results for this test case.\n        final_results.append([num_edges, avg_degree, n_components, lcc_size])\n\n    # Format the final output string exactly as specified.\n    result_str = \",\".join(map(str, final_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "构建好图之后，理解其拓扑特性至关重要，因为这直接影响GNN中的信息传播。本练习将对比两种常用于全球环境建模的图结构：基于二十面体的球面三角剖分图和经纬度网格图。通过从第一性原理推导平均节点度和聚类系数等关键指标，您将深入理解不同图结构选择如何影响模型的行为，例如信息流的各向同性。",
            "id": "3818288",
            "problem": "您正在为用于全球环境建模的图神经网络 (GNN) 中的消息传递建立两种备选的地理空间图构造的模型：一种是通过细分正二十面体得到的三角化球面图，另一种是矩形索引域上的经纬度网格图。您将纯粹以组合方式（无需距离）构造这两个图，计算它们的平均节点度和平均聚类系数，然后在一个小的测试套件中比较这些指标。所有量都是无量纲的。\n\n使用的基本原理：对于一个连通的闭合三角化曲面，球体的 Euler 特征为 $V - E + F = 2$；对于无边界的三角剖分，组合关系为 $3F = 2E$；平均节点度的定义为 $\\bar{k} = \\frac{1}{V} \\sum_{i=1}^{V} k_i = \\frac{2E}{V}$；对于度 $k_i \\ge 2$ 的节点，局部聚类系数的定义为 $C_i = \\frac{m_i}{\\binom{k_i}{2}}$，其中 $m_i$ 是节点 $i$ 的邻居之间的边数，如果 $k_i  2$ 则 $C_i = 0$。除了这些基本原理，您不得假设或使用任何快捷公式。\n\n要实现的图构造：\n- 由细分二十面体得到的球面三角剖分：从一个嵌入在 $\\mathbb{R}^3$ 中的正二十面体（$12$ 个顶点，$20$ 个三角面）开始。通过引入边的中点并将每个三角面细分为 $4$ 个更小的三角形，然后将这些中点投影回单位球面上（即归一化向量），来构建测地线细化。重复此细分过程 $s$ 次。通过连接在最终三角剖分中共享一条边的顶点来构造无向图。\n- 经纬度网格图：考虑一个具有 $L$ 个纬度行和 $M$ 个经度列的矩形索引网格。节点集为 $\\{(i,j): i \\in \\{0,\\dots,L-1\\}, j \\in \\{0,\\dots,M-1\\}\\}$，每个节点代表一个不包括地理两极的独特网格交叉点。使用 4-邻域连接构造无向边：对于每个节点 $(i,j)$，连接到 $(i,(j-1) \\bmod M)$、$(i,(j+1) \\bmod M)$，如果 $i0$ 则连接到 $(i-1,j)$，如果 $iL-1$ 则连接到 $(i+1,j)$。这会在经度方向上产生周期性环绕，在纬度方向上产生开放边界。\n\n每个图需要执行的计算：\n- 平均节点度 $\\bar{k}$，计算公式为 $\\frac{2E}{V}$。\n- 平均聚类系数，计算公式为 $\\bar{C} = \\frac{1}{V} \\sum_{i=1}^{V} C_i$，其中 $C_i$ 的定义如上。\n\n测试套件：\n- 案例 1：细分级别 $s = 0$；经纬度网格参数 $L = 5$, $M = 8$。\n- 案例 2：细分级别 $s = 1$；经纬度网格参数 $L = 10$, $M = 20$。\n- 案例 3：细分级别 $s = 2$；经纬度网格参数 $L = 30$, $M = 60$。\n- 案例 4：细分级别 $s = 3$；经纬度网格参数 $L = 45$, $M = 90$。\n\n所需输出：\n- 对于每个测试案例，按以下顺序计算并返回一个包含五个浮点数的列表：$[\\bar{k}_{\\text{ico}}, \\bar{C}_{\\text{ico}}, \\bar{k}_{\\text{latlon}}, \\bar{C}_{\\text{latlon}}, \\Delta \\bar{k}]$，其中 $\\Delta \\bar{k} = \\bar{k}_{\\text{ico}} - \\bar{k}_{\\text{latlon}}$。\n- 您的程序应生成单行输出，其中包含结果，形式为每个案例列表的逗号分隔列表，不含空格，并用方括号括起来，例如：\"[[a1,b1,c1,d1,e1],[a2,b2,c2,d2,e2],[a3,b3,c3,d3,e3],[a4,b4,c4,d4,e4]]\"。",
            "solution": "该问题要求为地理空间建模中使用的两种不同类型的图计算和比较其拓扑属性——平均节点度和平均聚类系数。验证证实该问题是科学合理的、良构的且客观的。我们接下来对每种图类型所需的量进行有原则的推导。\n\n### 1. 球面二十面体图的分析\n\n第一个图是通过递归细分正二十面体的面生成的。设 $V_s$、$E_s$ 和 $F_s$ 分别为细分级别 $s$ 时的顶点数、边数和面数。\n\n**1.1. 组合属性 ($V_s, E_s, \\bar{k}_{\\text{ico}}$)**\n\n当 $s=0$ 时，该图是一个正二十面体，它是一个球体的三角剖分，具有 $V_0=12$ 个顶点，$E_0=30$ 条边和 $F_0=20$ 个三角面。这些值满足球体的 Euler 特征，$V - E + F = 12 - 30 + 20 = 2$，以及三角剖分的条件，$3F = 3(20) = 60 = 2E = 2(30)$。\n\n细分过程将级别 $s$ 的图转换为级别 $s+1$。$F_s$ 个三角面中的每一个都被分成 $4$ 个更小的三角形，因此 $F_{s+1} = 4F_s$。这意味着 $F_s = F_0 \\cdot 4^s = 20 \\cdot 4^s$。由于生成的图也是球体的三角剖分，关系式 $3F_s = 2E_s$ 对所有 $s$ 都成立。因此，$E_s = \\frac{3}{2}F_s = \\frac{3}{2}(20 \\cdot 4^s) = 30 \\cdot 4^s$。\n\n为了求顶点数 $V_s$，我们使用 Euler 特征 $V_s - E_s + F_s = 2$。\n$$V_s = 2 + E_s - F_s = 2 + 30 \\cdot 4^s - 20 \\cdot 4^s = 10 \\cdot 4^s + 2$$\n平均节点度 $\\bar{k}_{\\text{ico}}(s)$ 定义为 $\\frac{2E}{V}$。\n$$\\bar{k}_{\\text{ico}}(s) = \\frac{2E_s}{V_s} = \\frac{2 \\cdot (30 \\cdot 4^s)}{10 \\cdot 4^s + 2} = \\frac{60 \\cdot 4^s}{10 \\cdot 4^s + 2}$$\n当 $s \\to \\infty$ 时，度趋近于 $\\frac{60}{10} = 6$，这是一个大型六边形网格（三角形网格的对偶）的特征。\n\n**1.2. 平均聚类系数 ($\\bar{C}_{\\text{ico}}$)**\n\n平均聚类系数为 $\\bar{C} = \\frac{1}{V}\\sum_{i=1}^{V} C_i$，其中对于度 $k_i \\ge 2$ 的节点 $i$，$C_i = m_i / \\binom{k_i}{2}$，而 $m_i$ 是其邻居之间的边数。\n\n细分过程创建了两种不同类型的顶点。\n1.  二十面体最初的 $12$ 个顶点。根据构造的对称性，这些顶点始终保持与原始二十面体相同的邻域结构。每个顶点连接到 $5$ 个邻居，这些邻居形成一个包含 $5$ 条边的闭合环路。因此，对于这 $12$ 个顶点，度为 $k_i = 5$，邻居之间的边数为 $m_i = 5$。局部聚类系数对所有 $s$ 都是常数：\n    $$C_{\\text{penta}} = \\frac{5}{\\binom{5}{2}} = \\frac{5}{10} = 0.5$$\n2.  在细分过程中引入的顶点。这些顶点创建在先前边的中点上。任何此类顶点都被 $6$ 个三角面包围，因此有 $6$ 个邻居。这些邻居形成一个包含 $6$ 条边的闭合环路。对于这些顶点，度为 $k_i=6$ 且 $m_i=6$。它们的局部聚类系数为：\n    $$C_{\\text{hexa}} = \\frac{6}{\\binom{6}{2}} = \\frac{6}{15} = 0.4$$\n在级别 $s$ 时，这些“六边形”顶点的数量是 $V_s - 12 = (10 \\cdot 4^s + 2) - 12 = 10 \\cdot 4^s - 10$。\n\n平均聚类系数 $\\bar{C}_{\\text{ico}}(s)$ 是这两个值的加权平均值：\n$$\\bar{C}_{\\text{ico}}(s) = \\frac{1}{V_s} \\left( 12 \\cdot C_{\\text{penta}} + (V_s - 12) \\cdot C_{\\text{hexa}} \\right)$$\n$$\\bar{C}_{\\text{ico}}(s) = \\frac{1}{10 \\cdot 4^s + 2} \\left( 12 \\cdot 0.5 + (10 \\cdot 4^s - 10) \\cdot 0.4 \\right)$$\n$$\\bar{C}_{\\text{ico}}(s) = \\frac{6 + 4 \\cdot 4^s - 4}{10 \\cdot 4^s + 2} = \\frac{4 \\cdot 4^s + 2}{10 \\cdot 4^s + 2} = \\frac{4^{s+1} + 2}{10 \\cdot 4^s + 2}$$\n\n### 2. 经纬度网格图的分析\n\n这个图构建在一个具有 $L$ 行和 $M$ 列的矩形索引网格上。\n\n**2.1. 组合属性 ($V, E, \\bar{k}_{\\text{latlon}}$)**\n\n顶点数就是 $V = L \\cdot M$。边由具有经度周期性的 4-邻域规则定义。我们可以通过对水平和垂直边求和来计算总边数 $E$。\n-   **水平边**：$L$ 行中的每一行都是一个包含 $M$ 个顶点的环，每行贡献 $M$ 条边。总水平边数：$L \\cdot M$。\n-   **垂直边**：$M$ 列中的每一列都是一条包含 $L$ 个顶点的路径（无周期性），每列贡献 $L-1$ 条边。总垂直边数：$M \\cdot (L-1)$。\n\n总边数 $E = L \\cdot M + M \\cdot (L-1) = LM + LM - M = M(2L - 1)$。平均节点度 $\\bar{k}_{\\text{latlon}}$ 为：\n$$\\bar{k}_{\\text{latlon}}(L) = \\frac{2E}{V} = \\frac{2 \\cdot M(2L - 1)}{L \\cdot M} = \\frac{2(2L-1)}{L} = 4 - \\frac{2}{L}$$\n这个值只取决于 $L$。当 $L \\to \\infty$ 时，$\\bar{k} \\to 4$，这是一个无限方格的度。\n\n**2.2. 平均聚类系数 ($\\bar{C}_{\\text{latlon}}$)**\n\n聚类系数衡量图中三角形的密度。经纬度网格是一个二分图。我们可以为每个节点 $(i,j)$ 分配一种颜色 $(i+j) \\pmod 2$。边总是连接不同颜色的节点（例如，从 $(i,j)$ 到 $(i, j+1)$ 会导致颜色改变，因为 $(i+(j+1)) \\pmod 2 \\neq (i+j) \\pmod 2$）。长度为 2 的路径会返回到与起始节点颜色相同的节点。由于边只连接不同颜色的节点，因此任何给定节点的两个邻居之间都不能相互连接。这意味着该图中不包含三角形（3-环），所以任何节点 $i$ 的邻居之间的边数 $m_i$ 总是 $0$。\n对于任何度 $k_i \\ge 2$ 的节点 $i$（在给定的测试案例中，所有节点都满足此条件，因为 $L,M \\ge 3$），局部聚类系数为：\n$$C_i = \\frac{m_i}{\\binom{k_i}{2}} = \\frac{0}{\\binom{k_i}{2}} = 0$$\n因此，平均聚类系数也为零。\n$$\\bar{C}_{\\text{latlon}} = 0$$\n\n### 3. 测试套件的计算\n\n对每个案例，我们应用推导出的公式。\n- $\\bar{k}_{\\text{ico}}(s) = \\frac{60 \\cdot 4^s}{10 \\cdot 4^s + 2}$\n- $\\bar{C}_{\\text{ico}}(s) = \\frac{4^{s+1} + 2}{10 \\cdot 4^s + 2}$\n- $\\bar{k}_{\\text{latlon}}(L) = 4 - \\frac{2}{L}$\n- $\\bar{C}_{\\text{latlon}} = 0$\n- $\\Delta \\bar{k} = \\bar{k}_{\\text{ico}}(s) - \\bar{k}_{\\text{latlon}}(L)$\n\n**案例 1：** $s=0, L=5, M=8$\n- $\\bar{k}_{\\text{ico}} = \\frac{60}{12} = 5.0$\n- $\\bar{C}_{\\text{ico}} = \\frac{6}{12} = 0.5$\n- $\\bar{k}_{\\text{latlon}} = 4 - \\frac{2}{5} = 3.6$\n- $\\bar{C}_{\\text{latlon}} = 0.0$\n- $\\Delta \\bar{k} = 5.0 - 3.6 = 1.4$\n\n**案例 2：** $s=1, L=10, M=20$\n- $\\bar{k}_{\\text{ico}} = \\frac{60 \\cdot 4}{10 \\cdot 4 + 2} = \\frac{240}{42} \\approx 5.714$\n- $\\bar{C}_{\\text{ico}} = \\frac{4^2 + 2}{42} = \\frac{18}{42} \\approx 0.429$\n- $\\bar{k}_{\\text{latlon}} = 4 - \\frac{2}{10} = 3.8$\n- $\\bar{C}_{\\text{latlon}} = 0.0$\n- $\\Delta \\bar{k} = \\frac{240}{42} - 3.8 \\approx 1.914$\n\n**案例 3：** $s=2, L=30, M=60$\n- $\\bar{k}_{\\text{ico}} = \\frac{60 \\cdot 16}{10 \\cdot 16 + 2} = \\frac{960}{162} \\approx 5.926$\n- $\\bar{C}_{\\text{ico}} = \\frac{4^3 + 2}{162} = \\frac{66}{162} \\approx 0.407$\n- $\\bar{k}_{\\text{latlon}} = 4 - \\frac{2}{30} = 4 - \\frac{1}{15} \\approx 3.933$\n- $\\bar{C}_{\\text{latlon}} = 0.0$\n- $\\Delta \\bar{k} = \\frac{960}{162} - (4 - \\frac{1}{15}) \\approx 1.993$\n\n**案例 4：** $s=3, L=45, M=90$\n- $\\bar{k}_{\\text{ico}} = \\frac{60 \\cdot 64}{10 \\cdot 64 + 2} = \\frac{3840}{642} \\approx 5.981$\n- $\\bar{C}_{\\text{ico}} = \\frac{4^4 + 2}{642} = \\frac{258}{642} \\approx 0.402$\n- $\\bar{k}_{\\text{latlon}} = 4 - \\frac{2}{45} \\approx 3.956$\n- $\\bar{C}_{\\text{lon}} = 0.0$\n- $\\Delta \\bar{k} = \\frac{3840}{642} - (4 - \\frac{2}{45}) \\approx 2.026$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes graph metrics for icosahedral and lat-lon graphs\n    based on the derivations.\n    \"\"\"\n    test_cases = [\n        # (subdivision_level_s, lat_rows_L, lon_cols_M)\n        (0, 5, 8),\n        (1, 10, 20),\n        (2, 30, 60),\n        (3, 45, 90),\n    ]\n\n    all_results = []\n    for s, L, M in test_cases:\n        # Icosahedral graph calculations\n        power_of_4_s = 4**s\n        k_ico = (60.0 * power_of_4_s) / (10.0 * power_of_4_s + 2.0)\n        c_ico = (4.0 * power_of_4_s + 2.0) / (10.0 * power_of_4_s + 2.0)\n\n        # Latitude-Longitude grid graph calculations\n        k_latlon = 4.0 - 2.0 / L\n        c_latlon = 0.0\n\n        # Difference in average degree\n        delta_k = k_ico - k_latlon\n\n        result = [k_ico, c_ico, k_latlon, c_latlon, delta_k]\n        all_results.append(result)\n\n    # Format the final output string according to the problem specification.\n    # The output is a list of lists, represented as a string, with no whitespace.\n    # e.g., \"[[a1,b1,c1,d1,e1],[a2,b2,c2,d2,e2],...]\"\n    \n    list_of_list_strings = []\n    for inner_list in all_results:\n        # Convert each float in the inner list to its string representation\n        stringified_inner_list = map(str, inner_list)\n        # Join them with commas and enclose in square brackets\n        list_of_list_strings.append(f\"[{','.join(stringified_inner_list)}]\")\n    \n    # Join the string representations of inner lists and enclose in outer brackets\n    final_output_string = f\"[{','.join(list_of_list_strings)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "拥有了合适的图结构和模型后，最后但同样关键的一步是进行科学上严谨的评估。本练习聚焦于地理空间机器学习中的一个核心挑战——空间自相关（spatial autocorrelation），它可能导致模型性能被高估。您将学习如何设计并实现一种空间分块交叉验证方案以防止数据泄露，这是确保模型泛化能力评估结果可靠和有效的重要方法。",
            "id": "3818318",
            "problem": "考虑一个表示遥感观测的地理空间节点集，该节点集将使用图神经网络（GNN）进行建模。目标是通过使用空间分块折叠（spatially blocked folds）来设计交叉验证（CV）折叠，以防止空间泄漏。当验证节点位于训练节点的空间自相关范围内或图消息传递半径内时，会发生泄漏。假设目标场服从二阶平稳、各向同性的高斯过程，并且空间自相关由仅依赖于分离距离 $h$ 的相关函数 $\\rho(h)$ 给出。有效独立范围 $d_{\\mathrm{eff}}$ 定义为满足 $\\rho(h) \\le \\tau$ 的最小 $h$，其中 $\\tau \\in (0,1)$ 是用户指定的、可忽略相关性的阈值。为避免泄漏所需的块缓冲区距离为 $d_{\\mathrm{block}} = \\max\\{d_{\\mathrm{eff}}, r_g\\}$，其中 $r_g$ 是 GNN 图的连通性/消息传递半径。\n\n使用以下来自地质统计学的、经过充分检验的相关模型作为基础：\n- 指数相关模型：$\\rho(h) = \\exp\\{-h / \\ell\\}$，其中 $\\ell  0$ 是长度尺度。\n- Matérn 相关模型：$\\rho(h) = \\dfrac{2^{1 - \\nu}}{\\Gamma(\\nu)} \\left(\\dfrac{h}{\\ell}\\right)^{\\nu} K_{\\nu}\\!\\left(\\dfrac{h}{\\ell}\\right)$，其中 $\\nu  0$ 是平滑度参数，$\\ell  0$ 是长度尺度，$\\Gamma(\\cdot)$ 是伽马函数，而 $K_{\\nu}(\\cdot)$ 是第二类修正贝塞尔函数。\n\n按如下方式构建 $k$ 个空间分块折叠：\n1. 对于给定的相关模型和参数，计算 $d_{\\mathrm{eff}}$ 为满足 $\\rho(h) \\le \\tau$ 的最小 $h$。\n2. 设置 $d_{\\mathrm{block}} = \\max\\{d_{\\mathrm{eff}}, r_g\\}$。\n3. 将空间域离散化为边长为 $b$ 的正方形区块，其中 $b \\ge d_{\\mathrm{block}}$。通过将其坐标（单位为公里）除以 $b$ 并进行整数除法，将每个节点分配到一个区块。\n4. 使用区块索引的确定性哈希，将每个唯一的区块映射到一个折叠索引 $\\{0,1,\\dots,k-1\\}$。对于给定的折叠 $f$，验证集由其区块映射到 $f$ 的所有节点组成。\n5. 为防止泄漏，从训练集中排除任何与任一验证节点的欧几里得距离严格小于 $d_{\\mathrm{block}}$ 的节点。\n\n对于每个折叠，计算最终训练集和验证集之间的最小集间距离 $d_{\\min}$。如果 $d_{\\min} \\ge d_{\\mathrm{block}}$，则该折叠是无泄漏的。如果所有折叠都是无泄漏的，则该测试用例是无泄漏的。\n\n所有距离必须以公里（km）为单位计算和报告。将 $d_{\\mathrm{eff}}$ 四舍五入到三位小数。不使用角度。将所有分数表示为小数。\n\n实现一个完整的、可运行的程序，该程序针对以下测试套件，计算 $d_{\\mathrm{eff}}$ 并按上述方法评估无泄漏的分块交叉验证：\n\n测试套件（每个用例指定了域、网格、相关模型和参数、阈值、图半径以及折叠数）：\n- 用例 1 (正常路径)：域 $[0,50] \\times [0,50]$ km，节点位于间距为 $5$ km 的 $10 \\times 10$ 网格上；模型为指数模型，参数 $\\ell = 5$ km；阈值 $\\tau = 0.05$；图半径 $r_g = 8$ km；折叠数 $k = 5$。\n- 用例 2 (通用 Matérn)：域 $[0,60] \\times [0,60]$ km，节点位于间距为 $6$ km 的 $11 \\times 11$ 网格上；模型为 Matérn 模型，参数 $\\nu = 1.5$ 和 $\\ell = 7$ km；阈值 $\\tau = 0.10$；图半径 $r_g = 10$ km；折叠数 $k = 4$。\n- 用例 3 (Matérn $\\nu = 0.5$ 等价于指数模型)：域 $[0,100] \\times [0,100]$ km，节点位于间距为 $10$ km 的 $11 \\times 11$ 网格上；模型为 Matérn 模型，参数 $\\nu = 0.5$ 和 $\\ell = 12$ km；阈值 $\\tau = 0.20$；图半径 $r_g = 5$ km；折叠数 $k = 6$。\n- 用例 4 (边缘情况：域太小)：域 $[0,20] \\times [0,20]$ km，节点位于间距为 $5$ km 的 $5 \\times 5$ 网格上；模型为指数模型，参数 $\\ell = 8$ km；阈值 $\\tau = 0.05$；图半径 $r_g = 3$ km；折叠数 $k = 3$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每一项都是 $[d_{\\mathrm{eff}}, \\text{leak\\_free}]$ 形式的列表，其中 $d_{\\mathrm{eff}}$ 四舍五入到三位小数，$\\text{leak\\_free}$ 是一个布尔值，指示该用例中的所有折叠是否都无泄漏，例如：$[[14.979,\\text{True}],[\\dots,\\text{False}],\\dots]$。",
            "solution": "经评估，用户提供的问题是有效的。该问题在科学上基于地质统计学和机器学习的原理，问题陈述清晰，算法流程明确，并包含得出唯一解所需的所有数据。因此，我将继续提供完整的解决方案。\n\n该问题要求为应用于地理空间数据的图神经网络（GNN）模型设计和评估一种空间分块交叉验证（CV）策略。其核心原则是防止训练集和验证集之间的信息泄漏，这种泄漏可能由空间自相关引起。当数据点彼此邻近时，它们的值通常是相关的。如果训练集和验证集包含空间上邻近的点，模型可能会仅仅通过与训练数据的邻近性来学习预测验证目标，从而导致对其泛化性能的过分乐观估计。\n\n我们的方法结构如下：\n1.  量化空间自相关范围。\n2.  定义一个同时考虑此自相关和 GNN 消息传递半径的缓冲区距离。\n3.  使用由该缓冲区距离分隔的空间区块构建 CV 折叠。\n4.  验证每个折叠产生的训练集和验证集确实是空间分离的。\n\n**1. 量化空间自相关：有效独立范围（$d_{\\mathrm{eff}}$）**\n\n问题假定底层的地理空间场遵循二阶平稳和各向同性的高斯过程。这意味着两个位置的观测值之间的相关性仅取决于它们之间的欧几里得距离 $h$，并由相关函数 $\\rho(h)$ 描述。我们将有效独立范围 $d_{\\mathrm{eff}}$ 定义为空间相关性降至指定的可忽略阈值 $\\tau$ 以下的最小距离。在数学上，$d_{\\mathrm{eff}}$ 是方程的解：\n$$\n\\rho(h) = \\tau\n$$\n由于相关函数 $\\rho(h)$ 对于 $h \\ge 0$ 是单调递减的，因此对于任何 $\\tau \\in (0,1)$ 都存在唯一的 $h$ 解。\n\n问题指定了两种相关模型：\n-   **指数模型**：相关性由 $\\rho(h) = \\exp\\{-h / \\ell\\}$ 给出，其中 $\\ell$ 是长度尺度。我们可以解析地求解 $d_{\\mathrm{eff}}$：\n    $$\n    \\exp\\{-d_{\\mathrm{eff}} / \\ell\\} = \\tau \\implies -d_{\\mathrm{eff}} / \\ell = \\ln(\\tau) \\implies d_{\\mathrm{eff}} = -\\ell \\ln(\\tau)\n    $$\n-   **Matérn 模型**：相关性为 $\\rho(h) = \\dfrac{2^{1 - \\nu}}{\\Gamma(\\nu)} \\left(\\dfrac{h}{\\ell}\\right)^{\\nu} K_{\\nu}\\!\\left(\\dfrac{h}{\\ell}\\right)$，其中 $\\nu$ 是平滑度参数，$\\ell$ 是长度尺度，$\\Gamma(\\cdot)$ 是伽马函数，而 $K_{\\nu}(\\cdot)$ 是第二类修正贝塞尔函数。对于此模型，通常无法获得 $h$ 的解析解。我们必须使用数值方法找到函数 $f(h) = \\rho(h) - \\tau$ 的根。鉴于 $f(h)$ 是单调的，像 Brent-Dekker 方法（`brentq`）这样的稳健求根算法是合适的。\n\nMatérn 模型的一个特例是当 $\\nu=0.5$ 时，它简化为指数模型 $\\rho(h) = \\exp(-h/\\ell)$，此时可以使用解析解。\n\n**2. 定义块缓冲区距离（$d_{\\mathrm{block}}$）**\n\n泄漏可能通过两种机制发生：底层场中的隐式相关性和 GNN 中的显式信息流。GNN 在节点之间传播信息，其传播距离由其层数和图的连通性决定，我们将其表示为消息传递半径 $r_g$。为防止这两种类型的泄漏，我们必须强制实施一个分离距离，该距离取这两个范围中较大的一个。因此，所需的块缓冲区距离 $d_{\\mathrm{block}}$ 定义为：\n$$\nd_{\\mathrm{block}} = \\max\\{d_{\\mathrm{eff}}, r_g\\}\n$$\n\n**3. 空间分块交叉验证算法**\n\n在确定了 $d_{\\mathrm{block}}$ 后，我们使用以下确定性程序构建 $k$ 个 CV 折叠：\n1.  **节点生成**：首先，我们根据给定域内指定的网格大小和间距生成节点坐标集。\n2.  **域离散化**：将空间域划分为正方形区块网格。为确保区块足够大以便于分离，我们将每个区块的边长 $b$ 设置为等于 $d_{\\mathrm{block}}$。坐标为 $(x, y)$ 的节点被分配给整数索引为 $(\\lfloor x/b \\rfloor, \\lfloor y/b \\rfloor)$ 的区块。\n3.  **折叠分配**：每个由其索引元组标识的唯一区块，通过对其区块索引元组应用哈希函数并对 $k$ 取模，被确定性地映射到 $k$ 个折叠中的一个。因此，同一区块内的所有节点都被分配到同一个折叠。\n4.  **带缓冲区的训练集构建**：对于每个折叠 $f \\in \\{0, 1, \\dots, k-1\\}$：\n    a. **验证集**由分配给折叠 $f$ 的所有节点组成。\n    b. 初始**训练集**由不在验证集中的所有节点组成。\n    c. 为防止泄漏，我们在验证集周围创建一个缓冲区。初始训练集中任何与*任一*验证节点的欧几里得距离严格小于 $d_{\\mathrm{block}}$ 的节点都将被移除。剩余的节点构成最终的、带缓冲区的训练集。\n\n**4. 泄漏预防验证**\n\n最后一步是验证该过程是否成功。对于每个折叠，我们计算最小集间距离 $d_{\\min}$，即最终训练集中的任何节点与验证集中的任何节点之间的最小欧几里得距离。\n$$\nd_{\\min} = \\min_{\\mathbf{x}_{\\text{train}} \\in \\text{TrainSet}, \\mathbf{x}_{\\text{val}} \\in \\text{ValSet}} ||\\mathbf{x}_{\\text{train}} - \\mathbf{x}_{\\text{val}}||_2\n$$\n如果 $d_{\\min} \\ge d_{\\mathrm{block}}$，则认为该折叠是**无泄漏**的。根据我们带缓冲区的训练集的构建方法，只要最终的训练集和验证集都非空，此条件就必须成立。如果任一集合为空，则距离实际上是无限大，该折叠也被认为是无泄漏的。当且仅当其所有 $k$ 个折叠都无泄漏时，一个测试用例才是无泄漏的。实现将为每个折叠计算此值，以确认过程的完整性。\n\n以下 Python 代码使用 `numpy` 进行高效的数组操作，并使用 `scipy` 中 Matérn 模型所需的特殊函数和数值求根功能，为提供的测试套件实现了这整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma, kv\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Exponential model\n        {'domain_max': 50, 'grid_n': 10, 'spacing': 5, 'model': 'exponential', \n         'params': {'ell': 5}, 'tau': 0.05, 'r_g': 8, 'k': 5},\n        # Case 2: Matérn model (general)\n        {'domain_max': 60, 'grid_n': 11, 'spacing': 6, 'model': 'matern', \n         'params': {'nu': 1.5, 'ell': 7}, 'tau': 0.10, 'r_g': 10, 'k': 4},\n        # Case 3: Matérn model (nu=0.5, equivalent to exponential)\n        {'domain_max': 100, 'grid_n': 11, 'spacing': 10, 'model': 'matern', \n         'params': {'nu': 0.5, 'ell': 12}, 'tau': 0.20, 'r_g': 5, 'k': 6},\n        # Case 4: Edge case where d_block is large relative to domain\n        {'domain_max': 20, 'grid_n': 5, 'spacing': 5, 'model': 'exponential', \n         'params': {'ell': 8}, 'tau': 0.05, 'r_g': 3, 'k': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    output_parts = []\n    for res_item in results:\n        # Format d_eff to 3 decimal places, even with trailing zeros.\n        d_eff_str = f\"{res_item[0]:.3f}\"\n        leak_free_str = str(res_item[1])\n        output_parts.append(f\"[{d_eff_str},{leak_free_str}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef _process_case(case_params):\n    \"\"\"\n    Processes a single test case from the suite.\n    \"\"\"\n    # 1. Generate node coordinates\n    coords = np.arange(case_params['grid_n']) * case_params['spacing']\n    xv, yv = np.meshgrid(coords, coords)\n    nodes = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    # 2. Compute effective independence range d_eff\n    if case_params['model'] == 'exponential':\n        d_eff = _d_eff_exponential(case_params['params']['ell'], case_params['tau'])\n    elif case_params['model'] == 'matern':\n        d_eff = _d_eff_matern(case_params['params']['nu'], case_params['params']['ell'], case_params['tau'])\n    \n    d_eff_rounded = round(d_eff, 3)\n\n    # 3. Compute block-buffer distance d_block\n    d_block = max(d_eff_rounded, case_params['r_g'])\n    \n    # 4. Assign nodes to blocks and then to folds\n    # Use b = d_block as the block side length.\n    # Handle the case where d_block is zero or negative (though unlikely).\n    b = d_block if d_block > 0 else 1.0 \n    block_indices = np.floor(nodes / b).astype(int)\n    \n    k = case_params['k']\n    fold_assignments = np.array([hash(tuple(bi)) % k for bi in block_indices])\n\n    # 5. Iterate through folds, build buffered sets, and check for leakage\n    is_case_leak_free = True\n    for f in range(k):\n        val_mask = fold_assignments == f\n        train_mask_potential = ~val_mask\n\n        validation_nodes = nodes[val_mask]\n        train_nodes_potential = nodes[train_mask_potential]\n        \n        # If no nodes in validation set for this fold, it's trivially leakage-free.\n        if validation_nodes.shape[0] == 0:\n            continue\n            \n        # If no potential training nodes, also trivially leakage-free.\n        if train_nodes_potential.shape[0] == 0:\n            continue\n\n        # Exclude training nodes within d_block of any validation node\n        # Using squared distances for efficiency\n        dist_sq = np.sum((train_nodes_potential[:, np.newaxis, :] - validation_nodes[np.newaxis, :, :])**2, axis=-1)\n        min_dist_sq_to_val = np.min(dist_sq, axis=1)\n        \n        # The condition for keeping a node is that its minimum distance to any validation node\n        # is GREATER THAN OR EQUAL TO d_block.\n        keep_mask = min_dist_sq_to_val >= d_block**2\n        \n        final_train_nodes = train_nodes_potential[keep_mask]\n        \n        # Verify leakage-free condition\n        # This is a verification step. By construction, this should always be true\n        # unless one of the final sets is empty.\n        is_fold_leak_free = True\n        if final_train_nodes.shape[0] > 0 and validation_nodes.shape[0] > 0:\n            final_dist_sq = np.sum((final_train_nodes[:, np.newaxis, :] - validation_nodes[np.newaxis, :, :])**2, axis=-1)\n            d_min_sq = np.min(final_dist_sq)\n            d_min = np.sqrt(d_min_sq)\n            \n            # Use a small tolerance for floating point comparisons\n            if not np.isclose(d_min, d_block) and d_min  d_block:\n                is_fold_leak_free = False\n        \n        if not is_fold_leak_free:\n            is_case_leak_free = False\n            break\n\n    return [d_eff_rounded, is_case_leak_free]\n\ndef _d_eff_exponential(ell, tau):\n    \"\"\"Calculates d_eff for the Exponential correlation model.\"\"\"\n    return -ell * np.log(tau)\n\ndef _matern_corr(h, nu, ell):\n    \"\"\"Computes the Matérn correlation.\"\"\"\n    if h == 0:\n        return 1.0\n    # To prevent division by zero or negative inputs for h\n    h = np.maximum(h, 1e-9)\n        \n    const = 2**(1 - nu) / gamma(nu)\n    arg = h / ell\n    \n    return const * (arg**nu) * kv(nu, arg)\n\ndef _d_eff_matern(nu, ell, tau):\n    \"\"\"Calculates d_eff for the Matérn model using a numerical solver.\"\"\"\n    # Special case for nu=0.5, which is equivalent to exponential\n    if np.isclose(nu, 0.5):\n        return _d_eff_exponential(ell, tau)\n    \n    # Objective function for the root finder\n    objective = lambda h: _matern_corr(h, nu, ell) - tau\n    \n    # Find the root h where the correlation equals the threshold tau.\n    # The function is monotonic, so a root is guaranteed.\n    # Bracket [1e-9, large_number] is safe.\n    try:\n        d_eff = brentq(objective, 1e-9, ell * 50)\n    except ValueError:\n        # Fallback if root is not in bracket, though unlikely with this large range\n        d_eff = brentq(objective, 1e-9, ell * 500)\n    \n    return d_eff\n\nsolve()\n\n```"
        }
    ]
}