{
    "hands_on_practices": [
        {
            "introduction": "在我们信任任何生成性模型的宏观结果之前，必须确保其底层逻辑是健全的。在基于主体的计算经济学（Agent-Based Computational Economics, ACE）模型中，这意味着要严格遵守会计准则，特别是存量-流量一致性原则。这个练习将指导你设计一个运行时验证测试，以确保基于主体的支付系统能正确地实现货币守恒，这是构建可信经济模型的关键一步。",
            "id": "4124530",
            "problem": "考虑一个基于主体的计算经济学（ACE）模型，其中一个由 $i \\in \\{1,\\dots,N\\}$ 索引的有限代理人集合持有货币余额 $B_i(t)$，并在离散时间索引 $t$ 进行双边支付。令 $T_{ij}(t) \\ge 0$ 表示在步骤 $t$ 期间从代理人 $i$ 到代理人 $j$ 的支付流，其中 $T_{ii}(t) = 0$。令 $X_i(t)$ 代表对代理人 $i$ 的外生注入（例如，来自政府部门的转移支付），并令 $Z_i(t)$ 代表从代理人 $i$ 的外生提取（例如，税收），两者均以相同的货币单位计量。基于规则的交互步骤根据实现支付和外生流的代理人规则来更新余额。该模型对于私人双边支付是封闭的，聚合货币的任何净变化都必须归因于外生流。目标是解决以下问题：\n\n用数学术语解释为何必须在代理人规则中强制执行显式会计恒等式，以防止虚假的货币创造。具体来说，论证确保每笔记录的支付都表示为支付方的减少和收款方的相应增加的必要性，从而使聚合货币除了已知的外生注入和提取外是守恒的。然后，设计一个运行时验证测试，在给定步骤 $t$ 的已实现支付 $T_{ij}(t)$ 和外生流 $X_i(t)$ 和 $Z_i(t)$ 的情况下，检测代理人规则的执行是否违反了会计恒等式。\n\n您的验证测试必须源自基本的预算约束和存量-流量一致性，而不是来自快捷公式。它必须通过计算由该步骤记录的交易和外生流引起的每个代理人的余额变化来运行，然后检查聚合变化是否与一个除了外生流之外的封闭系统一致。您必须指定并实现一个容差以考虑浮点运算，并且您必须选择该容差以稳健地区分真实违规与可忽略的数值漂移。\n\n实现一个完整的、可运行的程序，该程序：\n- 为下面套件中的每个测试用例模拟一个清算步骤。\n- 根据指定的故障模式，应用强制执行或故意违反精确复式记账更新的代理人规则。\n- 计算已实现的规则执行所隐含的聚合残差，并使用指定的容差将其与已知的净外生流进行比较。\n- 为每个测试用例输出一个布尔值，如果检测到违规则为 `True` ，否则为 `False` 。\n\n测试套件。使用以下 $N$、支付矩阵 $T$、外生注入 $X$、外生提取 $Z$、故障模式和容差：\n- 案例 $1$（正常路径，封闭系统，正确规则）：$N = 3$，\n  $T = \\begin{bmatrix} 0 & 10 & 0 \\\\ 0 & 0 & 5 \\\\ 7 & 0 & 0 \\end{bmatrix}$，\n  $X = [0,0,0]$，$Z = [0,0,0]$，\n  无故障，容差 $ \\varepsilon = 10^{-12} $。\n- 案例 $2$（单一规则违规，封闭系统）：$N = 3$，\n  $T = \\begin{bmatrix} 0 & 10 & 0 \\\\ 0 & 0 & 5 \\\\ 7 & 0 & 0 \\end{bmatrix}$，\n  $X = [0,0,0]$，$Z = [0,0,0]$，\n  故障模式为在边 $(i=1,j=2)$ 上“跳过扣款”，容差 $ \\varepsilon = 10^{-12} $。\n- 案例 $3$（临界数值漂移）：$N = 2$，\n  $T = \\begin{bmatrix} 0 & 0.1 \\\\ 0.1 & 0 \\end{bmatrix}$，\n  $X = [0,0]$，$Z = [0,0]$，\n  故障模式为“漂移”，向代理人 $1$ 的变化量中增加 $10^{-12}$，容差 $ \\varepsilon = 10^{-9} $。\n- 案例 $4$（与规则一致的外生注入）：$N = 4$，\n  $T = \\begin{bmatrix} 0 & 20 & 0 & 0 \\\\ 0 & 0 & 15 & 0 \\\\ 5 & 0 & 0 & 10 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix}$，\n  $X = [100,0,0,0]$，$Z = [0,0,0,0]$，\n  无故障，容差 $ \\varepsilon = 10^{-12} $。\n- 案例 $5$（外生注入加规则违规）：$N = 4$，\n  $T = \\begin{bmatrix} 0 & 20 & 0 & 0 \\\\ 0 & 0 & 15 & 0 \\\\ 5 & 0 & 0 & 10 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix}$，\n  $X = [100,0,0,0]$，$Z = [0,0,0,0]$，\n  故障模式为在边 $(i=3,j=4)$ 上“跳过扣款”，容差 $ \\varepsilon = 10^{-12} $。\n\n澄清说明：\n- “在边 $(i,j)$ 上跳过扣款”指支付方 $i$ 对于从 $i$ 到 $j$ 的支付的扣款被省略，而收款方 $j$ 的增量仍然应用。\n- “漂移”指应用于指定代理人的未建模的微小余额增量，该增量不被记录为外生流；这模拟了可忽略的数值误差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 `[r_1,r_2,...,r_5]`）的结果，其中每个 $r_k$ 是按上述顺序列出的案例 $k$ 的布尔结果。不涉及物理单位。角度不适用。任何地方都不得使用百分比；如有需要，请将任何比率或分数表示为小数或精确分数。",
            "solution": "核心原则是存量-流量一致性：每个流量都是存量的变化，在一个私人双边支付的封闭网络中，流量的记录方式必须在除了显式建模的外生来源之外，保持聚合货币守恒。在基于主体的计算经济学（ACE）中，实现支付的代理人规则必须满足预算约束的复式记账逻辑。对于每笔从代理人 $i$ 到代理人 $j$ 的金额为 $T_{ij}(t)$ 的支付，必须在 $B_i(t)$ 中有 $T_{ij}(t)$ 的减少，并在 $B_j(t)$ 中有相应的 $T_{ij}(t)$ 的增加。这种强制执行确保了所有代理人因私人双边支付而产生的余额变化之和为 $0$，反映了封闭货币流网络中的守恒性。\n\n形式化基础。令 $B_i(t)$ 表示代理人 $i$ 在时间 $t$ 的货币余额。令一步内的已实现变化为 $\\Delta B_i(t)$。在任何遵循复式记账和预算约束的模型中，每一步的变化是由收入、支出和外生流引起的。用 $R_i(t) = \\sum_{j=1}^{N} T_{ji}(t)$ 表示收入，用 $P_i(t) = \\sum_{j=1}^{N} T_{ij}(t)$ 表示支出。对于外生注入 $X_i(t)$ 和提取 $Z_i(t)$，代理人规则应实现\n$$\n\\Delta B_i(t) = R_i(t) - P_i(t) + X_i(t) - Z_i(t).\n$$\n对所有代理人求和，并利用私人双边支付中 $\\sum_{i=1}^{N} R_i(t) = \\sum_{i=1}^{N} P_i(t)$ 这一事实，可得出\n$$\n\\sum_{i=1}^{N} \\Delta B_i(t) = \\sum_{i=1}^{N} \\big(X_i(t) - Z_i(t)\\big).\n$$\n该恒等式体现了在封闭的私人支付系统下的存量-流量一致性。在规则层面强制执行它可以防止意外的货币创造（“虚假货币”）：例如，如果支付方的扣款被省略而收款方的增量被应用，那么变化的总和将超过净外生流，从而无中生有地创造货币。\n\n运行时验证。一个稳健的运行时测试必须检测一个步骤中代理人规则的已实现执行是否遵守聚合恒等式。使用规则执行语义（包括任何故障）构建每个代理人的变化量。计算聚合残差\n$$\n\\rho(t) \\equiv \\sum_{i=1}^{N} \\Delta B_i(t) - \\sum_{i=1}^{N} \\big(X_i(t) - Z_i(t)\\big).\n$$\n如果模型正确地为私人双边支付强制执行复式记账，那么 $\\rho(t)$ 在浮点数值误差范围内应等于 $0$。验证测试将 $|\\rho(t)|$ 与一个容差 $\\varepsilon > 0$ 进行比较：如果 $|\\rho(t)| > \\varepsilon$，则声明存在违规；否则，接受为一致。选择容差 $\\varepsilon$ 的大小应超过典型的机器舍入误差，同时相对于具有经济意义的流量大小而言仍然很小；例如，对于数量级在 $10^0$ 左右的流量，$\\varepsilon = 10^{-12}$，对于增加了数量级为 $10^{-12}$ 的微小漂移的情况，$\\varepsilon = 10^{-9}$。\n\n算法设计。对于每个测试用例：\n- 对所有 $i$ 初始化 $\\Delta B_i(t) = 0$。\n- 对于每个有支付 $T_{ij}(t)$ 的有序对 $(i,j)$：\n  - 将 $T_{ij}(t)$ 加到 $\\Delta B_j(t)$ 中以表示收款方的增量；如果存在“双重贷记”故障，则加两次。\n  - 从 $\\Delta B_i(t)$ 中减去 $T_{ij}(t)$ 以表示支付方的减量；如果为 $(i,j)$ 指定了“跳过扣款”故障，则省略此减法。\n- 处理完所有支付后，将外生注入 $X_i(t)$ 加到每个 $\\Delta B_i(t)$ 中，并从中减去外生提取 $Z_i(t)$。\n- 如果存在“漂移”故障，则将指定的微小漂移值加到相应的 $\\Delta B_i(t)$ 中，以模拟未建模的数值误差。\n- 通过从 $\\sum_i \\Delta B_i(t)$ 中减去已知的净外生流 $\\sum_i \\big(X_i(t) - Z_i(t)\\big)$ 来计算残差 $\\rho(t)$。\n- 如果 $|\\rho(t)| > \\varepsilon$ 则返回 `True` ，否则返回 `False` 。\n\n与 Leon Walras 定律的联系。在一般均衡理论中，Walras 定律断言，当除一个市场外所有市场都处于均衡状态时，所有市场的超额需求之和为零。用货币流的术语来说，强制执行每个代理人的预算恒等式与系统级约束是一致的，即总需求-供给失衡在没有外部来源的情况下不能产生净金融资产。因此，在代理人规则中实现复式记账约束可确保聚合货币守恒在封闭系统中成立，而残差测试则验证了这种守恒性没有被规则执行错误所违反。\n\n测试用例结果：\n- 案例 $1$：没有外生流的正确规则得出 $\\rho(t) = 0$；$|\\rho(t)| \\le \\varepsilon$；输出 `False` 。\n- 案例 $2$：在 $(i=1,j=2)$ 上跳过扣款会增加一个没有外生流支持的净额 $10$，因此 $\\rho(t) = 10$；$|\\rho(t)| > \\varepsilon$；输出 `True` 。\n- 案例 $3$：$10^{-12}$ 的漂移产生 $\\rho(t) = 10^{-12}$；当 $\\varepsilon = 10^{-9}$ 时，$|\\rho(t)| \\le \\varepsilon$；输出 `False` 。\n- 案例 $4$：净外生注入 $100$ 已被计入；聚合变化等于净外生流；$\\rho(t) = 0$；输出 `False` 。\n- 案例 $5$：存在外生注入 $100$，但在 $(i=3,j=4)$ 上跳过扣款会额外增加 $10$；$\\rho(t) = 10$；$|\\rho(t)| > \\varepsilon$；输出 `True` 。\n\n在计算上，由于需要为稠密支付矩阵遍历所有 $T_{ij}(t)$ 条目，该算法每步的运行时间为 $O(N^2)$；在稀疏情况下，运行时间为 $O(E)$，其中 $E$ 是非零支付的数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef detect_violation(n, payments, exog_inj, exog_tax, faults, epsilon):\n    \"\"\"\n    Compute per-agent balance changes Delta B induced by payments and exogenous flows,\n    apply specified faults to emulate rule violations, and detect aggregate identity violation.\n\n    Parameters:\n        n (int): Number of agents.\n        payments (np.ndarray): NxN matrix T where T[i,j] is payment from i to j.\n        exog_inj (np.ndarray): Length-N vector of exogenous injections X.\n        exog_tax (np.ndarray): Length-N vector of exogenous withdrawals Z.\n        faults (dict): Fault specification:\n            - 'skip_deduct': set of (i,j) edges where payer decrement is omitted.\n            - 'double_credit': set of (i,j) edges where receiver increment is applied twice.\n            - 'drift': length-N vector added to Delta B not counted as exogenous flows.\n        epsilon (float): Tolerance for violation detection.\n\n    Returns:\n        bool: True if violation is detected (abs(residual) > epsilon), else False.\n    \"\"\"\n    delta = np.zeros(n, dtype=float)\n\n    # Apply payments with potential faults.\n    # For each payment from i to j, add to receiver, subtract from payer unless skip_deduct fault.\n    skip = faults.get('skip_deduct', set())\n    dblc = faults.get('double_credit', set())\n    drift = faults.get('drift', np.zeros(n, dtype=float))\n\n    # Iterate over all possible edges\n    for i in range(n):\n        for j in range(n):\n            amt = payments[i, j]\n            if amt == 0.0:\n                continue\n            # Receiver increment\n            delta[j] += amt\n            if (i, j) in dblc:\n                delta[j] += amt  # apply double credit fault\n\n            # Payer decrement unless skipped\n            if (i, j) not in skip:\n                delta[i] -= amt\n            # else: skip deduction -> violation potential\n\n    # Add exogenous injections and subtract taxes\n    delta += exog_inj\n    delta -= exog_tax\n\n    # Apply drift fault (unmodeled small changes)\n    delta += drift\n\n    # Aggregate residual should be zero in a closed system except for net exogenous flows.\n    net_exog = float(np.sum(exog_inj) - np.sum(exog_tax))\n    residual = float(np.sum(delta) - net_exog)\n\n    return abs(residual) > epsilon\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1: N=3, closed system, correct rules\n    n1 = 3\n    T1 = np.array([[0.0, 10.0, 0.0],\n                   [0.0, 0.0, 5.0],\n                   [7.0, 0.0, 0.0]], dtype=float)\n    X1 = np.array([0.0, 0.0, 0.0], dtype=float)\n    Z1 = np.array([0.0, 0.0, 0.0], dtype=float)\n    faults1 = {'skip_deduct': set(), 'double_credit': set(), 'drift': np.zeros(n1, dtype=float)}\n    eps1 = 1e-12\n\n    # Case 2: N=3, single-rule violation (skip deduction on edge (0,1))\n    n2 = 3\n    T2 = T1.copy()\n    X2 = X1.copy()\n    Z2 = Z1.copy()\n    faults2 = {'skip_deduct': {(0, 1)}, 'double_credit': set(), 'drift': np.zeros(n2, dtype=float)}\n    eps2 = 1e-12\n\n    # Case 3: N=2, near-boundary numeric drift\n    n3 = 2\n    T3 = np.array([[0.0, 0.1],\n                   [0.1, 0.0]], dtype=float)\n    X3 = np.array([0.0, 0.0], dtype=float)\n    Z3 = np.array([0.0, 0.0], dtype=float)\n    drift3 = np.array([1e-12, 0.0], dtype=float)  # tiny unmodeled drift\n    faults3 = {'skip_deduct': set(), 'double_credit': set(), 'drift': drift3}\n    eps3 = 1e-9\n\n    # Case 4: N=4, exogenous injection consistent with rules\n    n4 = 4\n    T4 = np.array([[0.0, 20.0, 0.0, 0.0],\n                   [0.0, 0.0, 15.0, 0.0],\n                   [5.0, 0.0, 0.0, 10.0],\n                   [0.0, 0.0, 0.0, 0.0]], dtype=float)\n    X4 = np.array([100.0, 0.0, 0.0, 0.0], dtype=float)\n    Z4 = np.array([0.0, 0.0, 0.0, 0.0], dtype=float)\n    faults4 = {'skip_deduct': set(), 'double_credit': set(), 'drift': np.zeros(n4, dtype=float)}\n    eps4 = 1e-12\n\n    # Case 5: N=4, exogenous injection plus rule violation (skip deduction on edge (2,3))\n    n5 = 4\n    T5 = T4.copy()\n    X5 = X4.copy()\n    Z5 = Z4.copy()\n    faults5 = {'skip_deduct': {(2, 3)}, 'double_credit': set(), 'drift': np.zeros(n5, dtype=float)}\n    eps5 = 1e-12\n\n    test_cases = [\n        (n1, T1, X1, Z1, faults1, eps1),\n        (n2, T2, X2, Z2, faults2, eps2),\n        (n3, T3, X3, Z3, faults3, eps3),\n        (n4, T4, X4, Z4, faults4, eps4),\n        (n5, T5, X5, Z5, faults5, eps5),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, T, X, Z, faults, eps = case\n        result = detect_violation(n, T, X, Z, faults, eps)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个经过验证的模型是探索“假设-结果”关系的强大工具。模型中的一个基本但常被忽视的设计选择是主体的更新调度（同步 vs. 异步），这个选择可以极大地改变系统的动态行为。这个编码练习将通过模拟一个简单的市场，生动地展示异步更新中固有的信息延迟如何可能破坏一个原本稳定的市场均衡，从而揭示了时间建模在生成社会科学中的重要性。",
            "id": "4124559",
            "problem": "考虑一个基于代理的计算经济学（ACE）中的最小市场模型，其中单一总合价格 $p_t$ 在离散时间 $t \\in \\{0,1,2,\\dots\\}$ 内根据一个简单的超额需求引导的调整规则演化。设市场需求为 $D(p) = a - b p$，市场供给为 $S(p) = c + d p$，其中斜率严格为正 $b > 0$, $d > 0$，常数 $a, c \\in \\mathbb{R}$。将超额需求定义为 $Z(p) = D(p) - S(p) = (a - c) - (b + d) p$。瓦尔拉斯“摸索”原则（Walrasian tatonnement）指出，当超额需求为正时，价格向上调整；当超额需求为负时，价格向下调整。\n\n此问题的基本基础是瓦尔拉斯“摸索”规则和经过充分检验的线性需求与供给模型，该模型被广泛用于推导离散时间下的价格动态。市场出清的均衡价格 $p^\\star$ 满足 $Z(p^\\star) = 0$，这意味着\n$$\np^\\star = \\frac{a - c}{b + d}.\n$$\n定义 $K = b + d$ 并考虑两种更新机制，它们具有一个共同的正步长参数 $\\alpha > 0$：\n- 同步更新（无延迟）：所有代理基于当前的总合超额需求进行更新，\n$$\np_{t+1} = p_t + \\alpha Z(p_t).\n$$\n- 带有一步信息延迟的异步更新：代理基于前一个时间步测量的过时超额需求进行更新，\n$$\np_{t+1} = p_t + \\alpha Z(p_{t-1}).\n$$\n\n您的任务是编写一个完整的程序，对每个指定的测试用例，从给定的初始条件开始模拟这两种机制固定步数，并确定在每种机制下价格 $p_t$ 是否收敛到均衡价格 $p^\\star$。收敛的定义为：在模拟的最后 $W$ 步窗口内的所有时间里，绝对偏差 $|p_t - p^\\star|  \\varepsilon$。此问题中没有物理单位，也不出现角度。所有输出都必须是无量纲的。\n\n具体来说，对于每个测试用例，生成一个包含三个布尔值的列表：\n- 第一个布尔值表示同步更新是否收敛。\n- 第二个布尔值表示异步更新是否收敛。\n- 第三个布尔值表示异步更新是否相对于同步更新破坏了均衡，定义为逻辑条件“同步收敛且异步不收敛”。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，一个有效的输出行是 `[ [True,False,True], [True,True,False] ]`。\n\n使用以下测试套件，它涵盖了正常路径、边界和边缘情况。在每种情况下，模拟 $T$ 步，并使用指定的容差 $\\varepsilon$ 和窗口长度 $W$。对于异步更新，使用一步延迟，并在指定时将 $p_{-1}$ 设置为给定的初始条件。\n\n测试用例：\n- 案例 1（正常路径，两种机制都收敛）：\n  参数：$a = 10$，$b = 1$，$c = 2$，$d = 1$，$\\alpha = 0.2$，$T = 200$，$\\varepsilon = 10^{-6}$，$W = 25$，初始 $p_0 = 1$，以及 $p_{-1} = 1$。\n- 案例 2（异步破坏均衡而同步收敛）：\n  参数：$a = 10$，$b = 1$，$c = 2$，$d = 1$，$\\alpha = 0.9$，$T = 200$，$\\varepsilon = 10^{-6}$，$W = 25$，初始 $p_0 = 1$，以及 $p_{-1} = 1$。\n- 案例 3（两种机制都发散）：\n  参数：$a = 10$，$b = 1$，$c = 2$，$d = 1$，$\\alpha = 1.1$，$T = 200$，$\\varepsilon = 10^{-6}$，$W = 25$，初始 $p_0 = 1$，以及 $p_{-1} = 1$。\n- 案例 4（异步边界：幅度为 $1$ 的振荡，同步收敛）：\n  参数：$a = 10$，$b = 1$，$c = 2$，$d = 1$，$\\alpha = 0.5$，$T = 200$，$\\varepsilon = 10^{-6}$，$W = 25$，初始 $p_0 = 1$，以及 $p_{-1} = 1$。\n- 案例 5（初始处于均衡状态，两种机制立即收敛）：\n  参数：$a = 10$，$b = 1$，$c = 2$，$d = 1$，$\\alpha = 0.3$，$T = 200$，$\\varepsilon = 10^{-6}$，$W = 25$，初始 $p_0 = p^\\star$，以及 $p_{-1} = p^\\star$。\n\n您的程序必须实现以上要求，并以指定的单行格式输出结果。",
            "solution": "该问题要求在两种不同的信息机制——同步和异步——下模拟一个离散时间的瓦尔拉斯“摸索”价格调整模型，并评估它们的收敛特性。解决方案既包括对模型稳定性的理论分析，也包括一个数值实现，用以验证特定参数集下的行为。\n\n### 1. 模型设定与均衡\n\n该模型由线性需求和供给函数定义：\n- 需求：$D(p) = a - b p$\n- 供给：$S(p) = c + d p$\n\n参数 $b$ 和 $d$ 严格为正（$b > 0$，$d > 0$），确保了需求曲线向下倾斜和供给曲线向上倾斜。超额需求 $Z(p)$ 是需求与供给之差：\n$$Z(p) = D(p) - S(p) = (a - c) - (b + d) p$$\n\n市场出清或瓦尔拉斯均衡价格，记为 $p^\\star$，是使超额需求为零的价格，即 $Z(p^\\star) = 0$。求解 $p^\\star$ 可得：\n$$(a - c) - (b + d) p^\\star = 0 \\implies p^\\star = \\frac{a - c}{b + d}$$\n我们定义常数 $K = b + d$，它代表超额需求的总价格敏感度。那么，$p^\\star = (a-c)/K$ 且 $Z(p) = K(p^\\star - p)$。\n\n对于所提供的测试用例，其中 $a = 10$，$b = 1$，$c = 2$，$d = 1$，均衡价格为：\n$$p^\\star = \\frac{10 - 2}{1 + 1} = \\frac{8}{2} = 4$$\n\n### 2. 价格动态的稳定性分析\n\n问题的核心在于分析均衡价格 $p^\\star$ 在两种不同价格调整动态下的稳定性。我们分析与均衡的偏差 $\\delta_t = p_t - p^\\star$ 的演化。如果当 $t \\to \\infty$ 时 $\\delta_t \\to 0$，则该机制是稳定的。\n\n**2.1. 同步更新机制**\n\n价格根据以下规则更新：\n$$p_{t+1} = p_t + \\alpha Z(p_t)$$\n其中 $\\alpha > 0$ 是调整速度参数。为了分析稳定性，我们用偏差 $\\delta_t$ 来表示这个方程：\n$$p_{t+1} - p^\\star = p_t - p^\\star + \\alpha Z(p_t)$$\n$$\\delta_{t+1} = \\delta_t + \\alpha (K(p^\\star - p_t))$$\n$$\\delta_{t+1} = \\delta_t - \\alpha K (p_t - p^\\star)$$\n$$\\delta_{t+1} = (1 - \\alpha K) \\delta_t$$\n这是一个一阶线性齐次差分方程。其解为 $\\delta_t = (1 - \\alpha K)^t \\delta_0$。价格收敛到 $p^\\star$（即 $\\delta_t \\to 0$）的充要条件是乘数的绝对值小于 1：\n$$|1 - \\alpha K|  1$$\n这个不等式等价于 $-1  1 - \\alpha K  1$，可简化为 $0  \\alpha K  2$。由于 $\\alpha > 0$ 且 $K > 0$，收敛的条件是：\n$$\\alpha  \\frac{2}{K}$$\n\n**2.2. 异步更新机制**\n\n价格以一步信息延迟进行更新：\n$$p_{t+1} = p_t + \\alpha Z(p_{t-1})$$\n用与均衡的偏差表示：\n$$p_{t+1} - p^\\star = p_t - p^\\star + \\alpha Z(p_{t-1})$$\n$$\\delta_{t+1} = \\delta_t + \\alpha (K(p^\\star - p_{t-1}))$$\n$$\\delta_{t+1} = \\delta_t - \\alpha K (p_{t-1} - p^\\star)$$\n$$\\delta_{t+1} - \\delta_t + \\alpha K \\delta_{t-1} = 0$$\n这是一个二阶线性齐次差分方程。其稳定性由其特征方程 $r^2 - r + \\alpha K = 0$ 的根决定。系统收敛到均衡的充要条件是所有根 $r$ 的模都小于 1（$|r|  1$）。对于这种形式的二次方程，Jury 稳定性判据（或直接分析根）给出了稳定性的充要条件。这里的关键条件是 $\\alpha K  1$。因此，收敛的条件是：\n$$\\alpha  \\frac{1}{K}$$\n\n**2.3. 机制比较**\n\n稳定性分析表明，带有一步延迟的异步机制在调整参数 $\\alpha$ 的稳定范围上比同步机制要小。具体来说，在区域 $\\frac{1}{K} \\le \\alpha  \\frac{2}{K}$ 内，同步系统将收敛，而异步系统将振荡或发散。这展示了复杂系统中的一个关键原则：信息延迟可能是不稳定性的一个重要来源。\n\n### 3. 算法实现\n\n程序将对每个测试用例执行以下步骤：\n1.  读取参数：$a$，$b$，$c$，$d$，$\\alpha$，$T$，$\\varepsilon$，$W$，以及初始条件 $p_0$ 和 $p_{-1}$。\n2.  计算均衡价格 $p^\\star = (a - c) / (b + d)$。对于初始条件以 $p^\\star$ 给出的情况，代入此值。\n3.  定义超额需求函数 $Z(p) = (a - c) - (b + d)p$。\n4.  **同步模拟**：\n    -   初始化一个大小为 $T+1$ 的价格数组 $p_{sync}$，并设 $p_{sync}[0] = p_0$。\n    -   从 $t=0$ 到 $T-1$ 迭代，应用更新规则 $p_{sync}[t+1] = p_{sync}[t] + \\alpha Z(p_{sync}[t])$。\n5.  **异步模拟**：\n    -   初始化一个大小为 $T+1$ 的价格数组 $p_{async}$，并设 $p_{async}[0] = p_0$。\n    -   对于 $t=0$，计算 $p_{async}[1] = p_{async}[0] + \\alpha Z(p_{-1})$。\n    -   从 $t=1$ 到 $T-1$ 迭代，应用更新规则 $p_{async}[t+1] = p_{async}[t] + \\alpha Z(p_{async}[t-1])$。\n6.  **收敛性检查**：\n    -   对于两种模拟，通过检查条件 $|p_t - p^\\star|  \\varepsilon$ 是否在大小为 $W$ 的最终窗口中的所有时间步 $t$（即 $t \\in \\{T - W + 1, \\dots, T\\}$）上都成立来确定收敛性。\n    -   将结果存储为布尔值 `sync_converges` 和 `async_converges`。\n7.  **结果构建**：\n    -   计算第三个布尔值 `breaks_equilibrium = sync_converges and not async_converges`。\n    -   将这三个布尔值编译成当前测试用例的列表。\n8.  **最终输出**：将所有测试用例的结果收集到一个主列表中，并将其格式化为指定的单行字符串。\n对于所有测试用例，$K = b+d = 1+1=2$。理论上的稳定性边界是同步情况下的 $\\alpha  1$ 和异步情况下的 $\\alpha  0.5$。模拟结果将在数值上确认这些边界。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating price dynamics for a series of test cases.\n    \"\"\"\n\n    def process_case(a, b, c, d, alpha, T, epsilon, W, p0_spec, p_minus_1_spec):\n        \"\"\"\n        Processes a single test case for price dynamics simulation.\n\n        Args:\n            a, b, c, d (float): Parameters for demand and supply functions.\n            alpha (float): Step-size parameter for price adjustment.\n            T (int): Total number of simulation steps.\n            epsilon (float): Convergence tolerance.\n            W (int): Convergence window size.\n            p0_spec (float or str): Initial price p_0 or 'p_star'.\n            p_minus_1_spec (float or str): Initial price p_{-1} or 'p_star'.\n\n        Returns:\n            list: A list of three booleans: [sync_converges, async_converges, breaks_equilibrium].\n        \"\"\"\n        # 1. Calculate equilibrium price\n        p_star = (a - c) / (b + d)\n\n        # 2. Resolve initial conditions\n        p0 = p_star if p0_spec == 'p_star' else p0_spec\n        p_minus_1 = p_star if p_minus_1_spec == 'p_star' else p_minus_1_spec\n\n        # 3. Define excess demand function\n        K = b + d\n        def Z(p):\n            return (a - c) - K * p\n\n        # 4. Synchronous simulation\n        p_sync = np.zeros(T + 1)\n        p_sync[0] = p0\n        for t in range(T):\n            p_sync[t + 1] = p_sync[t] + alpha * Z(p_sync[t])\n\n        # 5. Check synchronous convergence\n        sync_window = p_sync[T - W + 1 : T + 1]\n        sync_converges = np.all(np.abs(sync_window - p_star)  epsilon)\n\n        # 6. Asynchronous simulation\n        p_async = np.zeros(T + 1)\n        p_async[0] = p0\n        if T >= 1:\n            # Step t=0 needs p_{-1} to calculate p_1\n            p_async[1] = p_async[0] + alpha * Z(p_minus_1)\n        for t in range(1, T):\n            # General step for t > 0\n            p_async[t + 1] = p_async[t] + alpha * Z(p_async[t - 1])\n\n        # 7. Check asynchronous convergence\n        async_window = p_async[T - W + 1 : T + 1]\n        async_converges = np.all(np.abs(async_window - p_star)  epsilon)\n\n        # 8. Determine if asynchronous updating breaks equilibrium\n        breaks_equilibrium = sync_converges and not async_converges\n\n        # Convert numpy.bool_ to Python's native bool for consistent string formatting\n        return [bool(sync_converges), bool(async_converges), bool(breaks_equilibrium)]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, both regimes converge)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.2, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 2 (asynchronous breaks equilibrium)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.9, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 3 (both regimes diverge)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 1.1, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 4 (boundary for asynchronous: oscillation)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.5, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 1, 'p_m1': 1},\n        # Case 5 (initial at equilibrium)\n        {'a': 10, 'b': 1, 'c': 2, 'd': 1, 'alpha': 0.3, 'T': 200, 'eps': 1e-6, 'W': 25, 'p0': 'p_star', 'p_m1': 'p_star'},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case['a'], case['b'], case['c'], case['d'],\n                              case['alpha'], case['T'], case['eps'], case['W'],\n                              case['p0'], case['p_m1'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Produces a string like \"[[True,False,True],[True,True,False]]\"\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成式社会科学的核心目标是解释宏观社会模式如何从微观互动中涌现。运行模拟后，我们需要定量工具来分析这些涌现出的模式。这个练习将教会你如何处理和分析一个简单的交换经济模型所产生的财富分布数据，并计算基尼系数——一个衡量不平等的标准指标。",
            "id": "4124558",
            "problem": "考虑一个在基于主体的计算经济学（ACE）框架内，使用基于主体的模型（ABM）模拟的极简交换经济。在这个经济体中，一个由 $N$ 个主体组成的封闭总体以固定的储蓄倾向进行随机双边交易。经过足够长的瞬态过程后，该模型在各主体间产生了一个稳态的离散财富分布。您观察到 $N=12$ 个主体在运行结束时的财富值（按非递减顺序排序）如下：\n$$\n1,\\; 1,\\; 2,\\; 3,\\; 3,\\; 4,\\; 5,\\; 8,\\; 12,\\; 15,\\; 30,\\; 36.\n$$\n请使用分布不平等性的第一性原理定义。洛伦兹曲线 $L(p)$ 定义为最底层的 $p \\in [0,1]$ 比例的主体所持有的总财富份额，基尼系数 $G$ 由基于洛伦兹曲线面积的连续公式定义。假设每个主体具有相等的总体权重，并通过对 $k=0,1,\\dots,N$ 时对应于累积份额 $p_k = k/N$ 的点进行分段线性插值来构建经验洛伦兹曲线。\n\n请根据此离散分布，使用上述定义和假设，计算基尼系数 $G$。请将您的最终答案表示为 $[0,1]$ 区间内的一个纯数字，并四舍五入至四位有效数字。",
            "solution": "该问题要求计算一个由 $N=12$ 个主体组成的总体的离散财富分布的基尼系数。解题过程必须遵循所提供的定义：基尼系数 $G$ 由经验洛伦兹曲线 $L(p)$ 下的面积导出，该曲线通过分段线性插值构建。\n\n首先，我们确立基本定义。洛伦兹曲线 $L(p)$ 表示最底层的 $p$ 比例人口所持有的累积财富份额，其中 $p \\in [0,1]$。基尼系数 $G$ 定义为完全平等线 ($y=p$) 与洛伦兹曲线 $L(p)$ 之间面积的两倍。该面积由 $\\int_0^1 (p - L(p)) dp = \\int_0^1 p dp - \\int_0^1 L(p) dp = \\frac{1}{2} - \\int_0^1 L(p) dp$ 给出。因此，基尼系数的公式为：\n$$\nG = 2 \\left( \\frac{1}{2} - \\int_0^1 L(p) dp \\right) = 1 - 2 \\int_0^1 L(p) dp\n$$\n问题指明，经验洛伦兹曲线是根据每个主体对应的离散数据点构建的。设按非递减顺序排列的主体财富为 $w_i$，其中 $i=1, 2, \\dots, N$。总体规模为 $N=12$。给定的财富值为：\n$w_1=1$, $w_2=1$, $w_3=2$, $w_4=3$, $w_5=3$, $w_6=4$, $w_7=5$, $w_8=8$, $w_9=12$, $w_{10}=15$, $w_{11}=30$, $w_{12}=36$。\n\n总体的总财富 $W_{total}$ 是个体财富的总和：\n$$\nW_{total} = \\sum_{i=1}^{N} w_i = 1+1+2+3+3+4+5+8+12+15+30+36 = 120\n$$\n洛伦兹曲线由点 $(p_k, L_k)$ 构建，其中 $p_k$ 是前 $k$ 个主体的累积人口比例，而 $L_k$ 是累积财富比例。由于每个主体具有相同的总体权重，累积人口比例为 $p_k = k/N$，其中 $k=0, 1, \\dots, N$。前 $k$ 个主体的累积财富为 $C_k = \\sum_{i=1}^k w_i$。累积财富比例为 $L_k = C_k / W_{total}$。\n\n我们构建洛伦兹曲线的点：\n- 当 $k=0$ 时：$p_0 = 0/12 = 0$。$C_0 = 0$。$L_0 = 0/120 = 0$。\n- 当 $k=1$ 时：$p_1 = 1/12$。$C_1 = 1$。$L_1 = 1/120$。\n- 当 $k=2$ 时：$p_2 = 2/12$。$C_2 = 1+1=2$。$L_2 = 2/120$。\n- 当 $k=3$ 时：$p_3 = 3/12$。$C_3 = 2+2=4$。$L_3 = 4/120$。\n- 当 $k=4$ 时：$p_4 = 4/12$。$C_4 = 4+3=7$。$L_4 = 7/120$。\n- 当 $k=5$ 时：$p_5 = 5/12$。$C_5 = 7+3=10$。$L_5 = 10/120$。\n- 当 $k=6$ 时：$p_6 = 6/12$。$C_6 = 10+4=14$。$L_6 = 14/120$。\n- 当 $k=7$ 时：$p_7 = 7/12$。$C_7 = 14+5=19$。$L_7 = 19/120$。\n- 当 $k=8$ 时：$p_8 = 8/12$。$C_8 = 19+8=27$。$L_8 = 27/120$。\n- 当 $k=9$ 时：$p_9 = 9/12$。$C_9 = 27+12=39$。$L_9 = 39/120$。\n- 当 $k=10$ 时：$p_{10} = 10/12$。$C_{10} = 39+15=54$。$L_{10} = 54/120$。\n- 当 $k=11$ 时：$p_{11} = 11/12$。$C_{11} = 54+30=84$。$L_{11} = 84/120$。\n- 当 $k=12$ 时：$p_{12} = 12/12 = 1$。$C_{12} = 84+36=120$。$L_{12} = 120/120 = 1$。\n\n积分 $\\int_0^1 L(p) dp$ 表示分段线性洛伦兹曲线下的面积。该面积可以计算为 $N$ 个梯形面积之和。第 $k$ 个梯形定义在区间 $[p_{k-1}, p_k]$ 上。其面积 $A_k$ 由下式给出：\n$$\nA_k = \\frac{1}{2} (L_{k-1} + L_k) (p_k - p_{k-1})\n$$\n由于 $p_k - p_{k-1} = (k/N) - ((k-1)/N) = 1/N$，总面积 $A$ 为：\n$$\nA = \\sum_{k=1}^{N} A_k = \\sum_{k=1}^{N} \\frac{1}{2} (L_{k-1} + L_k) \\frac{1}{N} = \\frac{1}{2N} \\sum_{k=1}^{N} (L_{k-1} + L_k)\n$$\n展开求和式：\n$$\nA = \\frac{1}{2N} ( (L_0+L_1) + (L_1+L_2) + \\dots + (L_{N-1}+L_N) ) = \\frac{1}{2N} (L_0 + 2\\sum_{k=1}^{N-1} L_k + L_N)\n$$\n给定 $N=12$，$L_0=0$，以及 $L_{12}=1$，我们有：\n$$\nA = \\frac{1}{2(12)} (0 + 2\\sum_{k=1}^{11} L_k + 1) = \\frac{1}{24} (1 + 2\\sum_{k=1}^{11} L_k)\n$$\n我们计算累积财富比例之和 $\\sum_{k=1}^{11} L_k$：\n$$\n\\sum_{k=1}^{11} L_k = \\frac{1}{W_{total}} \\sum_{k=1}^{11} C_k = \\frac{1}{120} (1+2+4+7+10+14+19+27+39+54+84)\n$$\n累积财富之和为：\n$$\n\\sum_{k=1}^{11} C_k = 261\n$$\n所以，比例之和为：\n$$\n\\sum_{k=1}^{11} L_k = \\frac{261}{120}\n$$\n现在，将此代入面积 $A$ 的表达式中：\n$$\nA = \\frac{1}{24} \\left(1 + 2 \\times \\frac{261}{120}\\right) = \\frac{1}{24} \\left(1 + \\frac{522}{120}\\right) = \\frac{1}{24} \\left(\\frac{120}{120} + \\frac{522}{120}\\right) = \\frac{1}{24} \\left(\\frac{642}{120}\\right) = \\frac{642}{2880}\n$$\n该分数可以化简。分子和分母均可被 $6$ 整除：$642/6 = 107$ 且 $2880/6 = 480$。\n$$\nA = \\frac{107}{480}\n$$\n最后，我们计算基尼系数 $G$：\n$$\nG = 1 - 2A = 1 - 2 \\left(\\frac{107}{480}\\right) = 1 - \\frac{214}{480} = 1 - \\frac{107}{240}\n$$\n$$\nG = \\frac{240}{240} - \\frac{107}{240} = \\frac{133}{240}\n$$\n为了给出最终答案，我们将此分数转换为小数，并四舍五入至四位有效数字。\n$$\nG = \\frac{133}{240} \\approx 0.5541666...\n$$\n四舍五入至四位有效数字得到 $0.5542$。",
            "answer": "$$\n\\boxed{0.5542}\n$$"
        }
    ]
}