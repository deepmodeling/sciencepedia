{
    "hands_on_practices": [
        {
            "introduction": "Before writing a single line of code, it is crucial to consider how an agent-based model will perform computationally. As the number of agents $N$ grows, the time required for a simulation can increase dramatically, limiting the scope of our research. This exercise provides a foundational method for analyzing the computational complexity of a model's core scheduler, breaking it down into private updates, pairwise interactions, and global aggregations . By deriving the scaling behavior from first principles, you will develop the essential skill of anticipating performance bottlenecks and designing models that are both scientifically meaningful and computationally feasible.",
            "id": "4124519",
            "problem": "Consider an Agent-Based Computational Economics (ACE) model with $N$ agents connected by a simple, undirected interaction network whose average degree is $\\langle k \\rangle$. In one synchronous time step, the scheduler performs the following three stages:\n- First, each agent performs a private state update that costs exactly $1$ primitive operation per agent.\n- Second, the scheduler processes every unordered adjacent pair of agents exactly once to compute a bilateral interaction (for example, a trade), and each such pairwise interaction costs exactly $1$ primitive operation.\n- Third, the model aggregates an economy-wide scalar (for example, total excess demand) by summing $N$ agent-reported scalars using a binary-reduction scheme, which consists of exactly $N - 1$ additions, each costing $1$ primitive operation.\n\nUsing only the fundamental definitions of degree, average degree, and undirected edges from graph theory, and the notion that total work is the sum of primitive operations, derive the exact total primitive-operation count $T(N, \\langle k \\rangle)$ for a single scheduler step in terms of $N$ and $\\langle k \\rangle$. Then, from first principles, deduce the asymptotic scaling in Big-O notation separately for (i) the pairwise interaction workload and (ii) the entire step, as functions of $N$ and $\\langle k \\rangle$. \n\nProvide your final answer as the single closed-form expression for $T(N, \\langle k \\rangle)$. Do not include Big-O notation in your final answer. No rounding is required.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in graph theory and computational complexity analysis, well-posed, and objective. It presents a solvable problem within the specified domain of Agent-Based Computational Economics (ACE) modeling without any factual or logical inconsistencies.\n\nThe total primitive-operation count for a single scheduler step, denoted as $T(N, \\langle k \\rangle)$, is the sum of the counts from the three sequential stages described. Let these be $W_1$, $W_2$, and $W_3$.\n$$ T(N, \\langle k \\rangle) = W_1 + W_2 + W_3 $$\n\nFirst, we analyze the workload for each stage based on the provided definitions.\n\n**Stage 1: Private State Update**\nThe problem states that each of the $N$ agents performs a private update, with each update costing exactly $1$ primitive operation. The total work for this stage, $W_1$, is therefore the number of agents multiplied by the cost per agent.\n$$ W_1 = N \\times 1 = N $$\n\n**Stage 2: Pairwise Interaction**\nThis stage involves processing every \"unordered adjacent pair of agents\" exactly once. In an undirected graph representing the interaction network, an unordered adjacent pair of vertices (agents) is precisely the definition of an edge. Therefore, the number of operations in this stage is equal to the number of edges, $|E|$, in the network, as each such interaction costs $1$ primitive operation.\n$$ W_2 = |E| \\times 1 = |E| $$\nTo relate $|E|$ to the given parameters $N$ (the number of vertices) and $\\langle k \\rangle$ (the average degree), we invoke the degree sum formula, also known as the handshaking lemma, from graph theory. It states that the sum of the degrees of all vertices in a graph is equal to twice the number of edges. If $k_i$ is the degree of agent $i$, then:\n$$ \\sum_{i=1}^{N} k_i = 2|E| $$\nThe average degree $\\langle k \\rangle$ is, by definition, the sum of all degrees divided by the number of vertices, $N$.\n$$ \\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i $$\nBy substituting the sum of degrees from the handshaking lemma into the definition of average degree, we establish a direct relationship between $|E|$, $N$, and $\\langle k \\rangle$.\n$$ \\langle k \\rangle = \\frac{2|E|}{N} $$\nSolving this equation for the number of edges $|E|$ yields:\n$$ |E| = \\frac{N \\langle k \\rangle}{2} $$\nThus, the workload for the pairwise interaction stage is:\n$$ W_2 = \\frac{N \\langle k \\rangle}{2} $$\n\n**Stage 3: Global Aggregation**\nThe problem specifies that this stage involves summing $N$ scalars using a binary-reduction scheme, which costs exactly $N - 1$ additions. Since each addition is $1$ primitive operation, the total work for this stage, $W_3$, is:\n$$ W_3 = (N - 1) \\times 1 = N - 1 $$\n\n**Total Operation Count**\nThe total primitive-operation count $T(N, \\langle k \\rangle)$ is the sum of the work from these three stages.\n$$ T(N, \\langle k \\rangle) = W_1 + W_2 + W_3 $$\nSubstituting the expressions derived for each stage:\n$$ T(N, \\langle k \\rangle) = N + \\frac{N \\langle k \\rangle}{2} + (N - 1) $$\nCombining the terms, we arrive at the final closed-form expression:\n$$ T(N, \\langle k \\rangle) = 2N - 1 + \\frac{N \\langle k \\rangle}{2} $$\n\n**Asymptotic Scaling Analysis**\nAs requested, we deduce the asymptotic scaling for the specified workloads.\n(i) The pairwise interaction workload is $W_2 = \\frac{N \\langle k \\rangle}{2}$. In Big-O notation, we disregard constant factors, so the scaling as a function of $N$ and $\\langle k \\rangle$ is:\n$$ W_2 \\in O(N \\langle k \\rangle) $$\n(ii) The workload for the entire step is $T(N, \\langle k \\rangle) = 2N - 1 + \\frac{N \\langle k \\rangle}{2}$. The asymptotic behavior is governed by the sum of the non-constant terms, $2N$ and $\\frac{N \\langle k \\rangle}{2}$. Therefore, the scaling is:\n$$ T(N, \\langle k \\rangle) \\in O(N + N\\langle k \\rangle) $$\nThis can be factored as $O(N(1 + \\langle k \\rangle))$. The final scaling depends on the nature of the graph's connectivity. For sparse graphs where $\\langle k \\rangle$ is a constant, the complexity is $O(N)$. For dense graphs where $\\langle k \\rangle$ grows proportionally to $N$, the complexity is $O(N^2)$. The expression $O(N+N\\langle k \\rangle)$ is the most general representation.",
            "answer": "$$ \\boxed{2N - 1 + \\frac{N \\langle k \\rangle}{2}} $$"
        },
        {
            "introduction": "A generative model is only as useful as it is valid, and a primary source of error in agent-based computational economics is the violation of fundamental accounting identities. In any model involving monetary flows, ensuring that 'money' is not accidentally created or destroyed by faulty agent rules—a principle known as stock-flow consistency—is paramount for the model's integrity. This practice challenges you to design and implement a runtime verification test that detects such violations by checking if aggregate balance changes align with specified exogenous flows . Mastering this technique is a critical step in building robust and credible economic simulations.",
            "id": "4124530",
            "problem": "Consider an Agent-Based Computational Economics (ACE) model where a finite set of agents indexed by $i \\in \\{1,\\dots,N\\}$ hold monetary balances $B_i(t)$ and engage in bilateral payments at discrete time index $t$. Let $T_{ij}(t) \\ge 0$ denote the payment flow during step $t$ from agent $i$ to agent $j$, with $T_{ii}(t) = 0$. Let $X_i(t)$ represent exogenous injections to agent $i$ (for example, transfers from a government sector) and let $Z_i(t)$ represent exogenous withdrawals from agent $i$ (for example, taxes), both measured in the same monetary unit. The rule-based interaction step updates the balances according to agent rules that implement payments and exogenous flows. The model is closed with respect to private bilateral payments, and any net change in aggregate money must be attributable to exogenous flows. The aim is to address the following:\n\nExplain, in mathematical terms, why explicit accounting identities must be enforced in the agent rules to prevent spurious money creation. Specifically, justify the necessity of ensuring that every recorded payment is represented as a decrement for the payer and a corresponding increment for the receiver, so that aggregate money is conserved except for known exogenous injections and withdrawals. Then, design a runtime verification test that, given the realized payments $T_{ij}(t)$ and exogenous flows $X_i(t)$ and $Z_i(t)$ at a step $t$, detects whether the agent rule execution violated the accounting identities.\n\nYour verification test must be derived from fundamental budget constraints and stock-flow consistency, not from shortcut formulas. It must operate by computing per-agent balance changes induced by the step’s recorded transactions and exogenous flows and then checking whether the aggregate change is consistent with a closed system except for exogenous flows. You must specify and implement a tolerance to account for floating-point arithmetic, and you must choose that tolerance to robustly distinguish genuine violations from negligible numerical drift.\n\nImplement a complete, runnable program that:\n- Simulates one clearing step for each test case in the suite below.\n- Applies agent rules that either enforce or deliberately violate exact double-entry updates, according to the specified fault patterns.\n- Computes the aggregate residual implied by the realized rule execution and compares it to the known net exogenous flows using a specified tolerance.\n- Outputs, for each test case, a boolean that is `True` if a violation is detected and `False` otherwise.\n\nTest suite. Use the following $N$, payment matrices $T$, exogenous injections $X$, exogenous withdrawals $Z$, fault patterns, and tolerances:\n- Case $1$ (happy path, closed system, correct rules): $N = 3$, \n  $T = \\begin{bmatrix} 0 & 10 & 0 \\\\ 0 & 0 & 5 \\\\ 7 & 0 & 0 \\end{bmatrix}$, \n  $X = [0,0,0]$, $Z = [0,0,0]$, \n  no faults, tolerance $ \\varepsilon = 10^{-12} $.\n- Case $2$ (single-rule violation, closed system): $N = 3$, \n  $T = \\begin{bmatrix} 0 & 10 & 0 \\\\ 0 & 0 & 5 \\\\ 7 & 0 & 0 \\end{bmatrix}$, \n  $X = [0,0,0]$, $Z = [0,0,0]$, \n  fault pattern “skip deduction” on edge $(i=1,j=2)$, tolerance $ \\varepsilon = 10^{-12} $.\n- Case $3$ (near-boundary numeric drift): $N = 2$, \n  $T = \\begin{bmatrix} 0 & 0.1 \\\\ 0.1 & 0 \\end{bmatrix}$, \n  $X = [0,0]$, $Z = [0,0]$, \n  fault pattern “drift” adding $10^{-12}$ to agent $1$’s change, tolerance $ \\varepsilon = 10^{-9} $.\n- Case $4$ (exogenous injection consistent with rules): $N = 4$, \n  $T = \\begin{bmatrix} 0 & 20 & 0 & 0 \\\\ 0 & 0 & 15 & 0 \\\\ 5 & 0 & 0 & 10 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix}$, \n  $X = [100,0,0,0]$, $Z = [0,0,0,0]$, \n  no faults, tolerance $ \\varepsilon = 10^{-12} $.\n- Case $5$ (exogenous injection plus rule violation): $N = 4$, \n  $T = \\begin{bmatrix} 0 & 20 & 0 & 0 \\\\ 0 & 0 & 15 & 0 \\\\ 5 & 0 & 0 & 10 \\\\ 0 & 0 & 0 & 0 \\end{bmatrix}$, \n  $X = [100,0,0,0]$, $Z = [0,0,0,0]$, \n  fault pattern “skip deduction” on edge $(i=3,j=4)$, tolerance $ \\varepsilon = 10^{-12} $.\n\nClarifications:\n- “Skip deduction on edge $(i,j)$” means the payer $i$’s decrement for the payment from $i$ to $j$ is omitted, while the receiver $j$’s increment is still applied.\n- “Drift” means an unmodeled, tiny balance increment applied to specified agents that is not recorded as exogenous flow; this models negligible numerical artifacts.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots,r_5]$), where each $r_k$ is the boolean result for case $k$ in the order listed above. No physical units are involved. Angles are not applicable. Percentages must not be used anywhere; express any ratio or fraction as decimals or exact fractions if needed.",
            "solution": "The core principle is stock-flow consistency: every flow is a change in a stock, and in a closed network of private bilateral payments, flows must be recorded in a way that conserves aggregate money except for explicitly modeled exogenous sources. In Agent-Based Computational Economics (ACE), agent rules that implement payments must satisfy the double-entry logic of budget constraints. For every payment from agent $i$ to agent $j$ of amount $T_{ij}(t)$, there must be a decrement of $T_{ij}(t)$ in $B_i(t)$ and a corresponding increment of $T_{ij}(t)$ in $B_j(t)$. This enforcement ensures that the sum of all agents’ balance changes due to private bilateral payments equals $0$, reflecting conservation in a closed monetary flow network.\n\nFormal base. Let $B_i(t)$ denote the monetary balance of agent $i$ at time $t$. Let the realized change over one step be $\\Delta B_i(t)$. In any model that adheres to double-entry accounting and budget constraints, the per-step change is induced by receipts, payments, and exogenous flows. Denote receipts by $R_i(t) = \\sum_{j=1}^{N} T_{ji}(t)$ and payments by $P_i(t) = \\sum_{j=1}^{N} T_{ij}(t)$. With exogenous injections $X_i(t)$ and withdrawals $Z_i(t)$, the agent rule should implement\n$$\n\\Delta B_i(t) = R_i(t) - P_i(t) + X_i(t) - Z_i(t).\n$$\nSumming across agents and using the fact that $\\sum_{i=1}^{N} R_i(t) = \\sum_{i=1}^{N} P_i(t)$ for private bilateral payments yields\n$$\n\\sum_{i=1}^{N} \\Delta B_i(t) = \\sum_{i=1}^{N} \\big(X_i(t) - Z_i(t)\\big).\n$$\nThis identity encodes stock-flow consistency under a closed private payment system. Enforcing it at the rule level prevents unintended money creation (“spurious money”): if, for example, a payer’s decrement is omitted while the receiver’s increment is applied, the aggregate sum of changes exceeds the net exogenous flows, creating money from nowhere.\n\nRuntime verification. A robust runtime test must detect whether the realized execution of agent rules in a step adheres to the aggregate identity. Construct per-agent changes using the rule execution semantics (including any faults). Compute the aggregate residual\n$$\n\\rho(t) \\equiv \\sum_{i=1}^{N} \\Delta B_i(t) - \\sum_{i=1}^{N} \\big(X_i(t) - Z_i(t)\\big).\n$$\nIf the model correctly enforces double-entry accounting for private bilateral payments, then $\\rho(t)$ equals $0$ up to floating-point numerical error. The verification test compares $|\\rho(t)|$ to a tolerance $\\varepsilon > 0$: if $|\\rho(t)| > \\varepsilon$, declare a violation; else, accept as consistent. The tolerance $\\varepsilon$ is chosen to exceed typical machine rounding while remaining small relative to economically meaningful flow magnitudes; for example, $\\varepsilon = 10^{-12}$ for flows around order $10^0$ and $\\varepsilon = 10^{-9}$ for cases with added micro-drift of order $10^{-12}$.\n\nAlgorithmic design. For each test case:\n- Initialize $\\Delta B_i(t) = 0$ for all $i$.\n- For each ordered pair $(i,j)$ with payment $T_{ij}(t)$:\n  - Add $T_{ij}(t)$ to $\\Delta B_j(t)$ to represent the receiver’s increment; if a “double credit” fault were present, add it twice.\n  - Subtract $T_{ij}(t)$ from $\\Delta B_i(t)$ to represent the payer’s decrement; if a “skip deduction” fault is specified for $(i,j)$, omit this subtraction.\n- After processing all payments, add exogenous injections $X_i(t)$ and subtract exogenous withdrawals $Z_i(t)$ to each $\\Delta B_i(t)$.\n- If a “drift” fault is present, add the specified tiny drift value to the corresponding $\\Delta B_i(t)$ to model unmodeled numerical artifacts.\n- Compute the residual $\\rho(t)$ by subtracting the known net exogenous flows $\\sum_i \\big(X_i(t) - Z_i(t)\\big)$ from $\\sum_i \\Delta B_i(t)$.\n- Return `True` if $|\\rho(t)| > \\varepsilon$, else `False`.\n\nConnection to Leon Walras’ law. In general equilibrium, Walras’ law asserts that the sum of excess demands across all markets is zero when all but possibly one market is in equilibrium. In monetary flow terms, enforcing per-agent budget identities aligns with the system-level constraint that aggregate demand-supply imbalances cannot generate net financial assets without an external source. Thus, implementing double-entry constraints within agent rules ensures that aggregate monetary conservation holds in a closed system, and the residual test verifies that this conservation is not violated by rule execution errors.\n\nTest case outcomes:\n- Case $1$: Correct rules with no exogenous flows give $\\rho(t) = 0$; $|\\rho(t)| \\le \\varepsilon$; output `False`.\n- Case $2$: Skipping deduction on $(i=1,j=2)$ adds a net $10$ not backed by exogenous flows, so $\\rho(t) = 10$; $|\\rho(t)| > \\varepsilon$; output `True`.\n- Case $3$: A drift of $10^{-12}$ yields $\\rho(t) = 10^{-12}$; with $\\varepsilon = 10^{-9}$, $|\\rho(t)| \\le \\varepsilon$; output `False`.\n- Case $4$: Net exogenous injection $100$ is accounted for; aggregate change equals net exogenous flows; $\\rho(t) = 0$; output `False`.\n- Case $5$: Exogenous injection $100$ is present, but skipping deduction on $(i=3,j=4)$ adds an extra $10$; $\\rho(t) = 10$; $|\\rho(t)| > \\varepsilon$; output `True`.\n\nComputationally, the algorithm runs in time $O(N^2)$ per step due to iterating over all $T_{ij}(t)$ entries for a dense payment matrix; in sparse cases, it is $O(E)$ where $E$ is the number of nonzero payments.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef detect_violation(n, payments, exog_inj, exog_tax, faults, epsilon):\n    \"\"\"\n    Compute per-agent balance changes Delta B induced by payments and exogenous flows,\n    apply specified faults to emulate rule violations, and detect aggregate identity violation.\n\n    Parameters:\n        n (int): Number of agents.\n        payments (np.ndarray): NxN matrix T where T[i,j] is payment from i to j.\n        exog_inj (np.ndarray): Length-N vector of exogenous injections X.\n        exog_tax (np.ndarray): Length-N vector of exogenous withdrawals Z.\n        faults (dict): Fault specification:\n            - 'skip_deduct': set of (i,j) edges where payer decrement is omitted.\n            - 'double_credit': set of (i,j) edges where receiver increment is applied twice.\n            - 'drift': length-N vector added to Delta B not counted as exogenous flows.\n        epsilon (float): Tolerance for violation detection.\n\n    Returns:\n        bool: True if violation is detected (abs(residual) > epsilon), else False.\n    \"\"\"\n    delta = np.zeros(n, dtype=float)\n\n    # Apply payments with potential faults.\n    # For each payment from i to j, add to receiver, subtract from payer unless skip_deduct fault.\n    skip = faults.get('skip_deduct', set())\n    dblc = faults.get('double_credit', set())\n    drift = faults.get('drift', np.zeros(n, dtype=float))\n\n    # Iterate over all possible edges\n    for i in range(n):\n        for j in range(n):\n            amt = payments[i, j]\n            if amt == 0.0:\n                continue\n            # Receiver increment\n            delta[j] += amt\n            if (i, j) in dblc:\n                delta[j] += amt  # apply double credit fault\n\n            # Payer decrement unless skipped\n            if (i, j) not in skip:\n                delta[i] -= amt\n            # else: skip deduction -> violation potential\n\n    # Add exogenous injections and subtract taxes\n    delta += exog_inj\n    delta -= exog_tax\n\n    # Apply drift fault (unmodeled small changes)\n    delta += drift\n\n    # Aggregate residual should be zero in a closed system except for net exogenous flows.\n    net_exog = float(np.sum(exog_inj) - np.sum(exog_tax))\n    residual = float(np.sum(delta) - net_exog)\n\n    return abs(residual) > epsilon\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case 1: N=3, closed system, correct rules\n    n1 = 3\n    T1 = np.array([[0.0, 10.0, 0.0],\n                   [0.0, 0.0, 5.0],\n                   [7.0, 0.0, 0.0]], dtype=float)\n    X1 = np.array([0.0, 0.0, 0.0], dtype=float)\n    Z1 = np.array([0.0, 0.0, 0.0], dtype=float)\n    faults1 = {'skip_deduct': set(), 'double_credit': set(), 'drift': np.zeros(n1, dtype=float)}\n    eps1 = 1e-12\n\n    # Case 2: N=3, single-rule violation (skip deduction on edge (i=1,j=2) -> (0,1) in 0-indexing)\n    n2 = 3\n    T2 = T1.copy()\n    X2 = X1.copy()\n    Z2 = Z1.copy()\n    faults2 = {'skip_deduct': {(0, 1)}, 'double_credit': set(), 'drift': np.zeros(n2, dtype=float)}\n    eps2 = 1e-12\n\n    # Case 3: N=2, near-boundary numeric drift\n    n3 = 2\n    T3 = np.array([[0.0, 0.1],\n                   [0.1, 0.0]], dtype=float)\n    X3 = np.array([0.0, 0.0], dtype=float)\n    Z3 = np.array([0.0, 0.0], dtype=float)\n    drift3 = np.array([1e-12, 0.0], dtype=float)  # tiny unmodeled drift\n    faults3 = {'skip_deduct': set(), 'double_credit': set(), 'drift': drift3}\n    eps3 = 1e-9\n\n    # Case 4: N=4, exogenous injection consistent with rules\n    n4 = 4\n    T4 = np.array([[0.0, 20.0, 0.0, 0.0],\n                   [0.0, 0.0, 15.0, 0.0],\n                   [5.0, 0.0, 0.0, 10.0],\n                   [0.0, 0.0, 0.0, 0.0]], dtype=float)\n    X4 = np.array([100.0, 0.0, 0.0, 0.0], dtype=float)\n    Z4 = np.array([0.0, 0.0, 0.0, 0.0], dtype=float)\n    faults4 = {'skip_deduct': set(), 'double_credit': set(), 'drift': np.zeros(n4, dtype=float)}\n    eps4 = 1e-12\n\n    # Case 5: N=4, exogenous injection plus rule violation (skip deduction on edge (i=3,j=4) -> (2,3) in 0-indexing)\n    n5 = 4\n    T5 = T4.copy()\n    X5 = X4.copy()\n    Z5 = Z4.copy()\n    faults5 = {'skip_deduct': {(2, 3)}, 'double_credit': set(), 'drift': np.zeros(n5, dtype=float)}\n    eps5 = 1e-12\n\n    test_cases = [\n        (n1, T1, X1, Z1, faults1, eps1),\n        (n2, T2, X2, Z2, faults2, eps2),\n        (n3, T3, X3, Z3, faults3, eps3),\n        (n4, T4, X4, Z4, faults4, eps4),\n        (n5, T5, X5, Z5, faults5, eps5),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, T, X, Z, faults, eps = case\n        result = detect_violation(n, T, X, Z, faults, eps)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate purpose of a generative social science model is often to explain how micro-level interactions give rise to stable, large-scale social patterns. One of the most studied emergent phenomena in economics is the distribution of wealth and its associated level of inequality. This exercise bridges the gap between raw simulation output and meaningful economic analysis by tasking you with computing the Gini coefficient, a standard measure of inequality, from a discrete wealth distribution generated by a simple agent-based model . This practice provides direct experience in transforming agent-level data into a key macroscopic statistic.",
            "id": "4124558",
            "problem": "Consider a minimal exchange economy simulated with an Agent-Based Model (ABM) within Agent-Based Computational Economics (ACE), in which a closed population of $N$ agents engages in random bilateral trades with a fixed savings propensity. After a sufficiently long transient, the model produces a stationary discrete wealth distribution across agents. You observe the end-of-run wealths (sorted in nondecreasing order) for $N=12$ agents:\n$$\n1,\\; 1,\\; 2,\\; 3,\\; 3,\\; 4,\\; 5,\\; 8,\\; 12,\\; 15,\\; 30,\\; 36.\n$$\nUse first-principles definitions of distributional inequality. The Lorenz curve $L(p)$ is defined as the share of total wealth held by the bottom $p \\in [0,1]$ fraction of agents, and the Gini coefficient $G$ is defined by the continuous formulation based on the Lorenz curve area. Assume each agent has equal population weight and construct the empirical Lorenz curve by piecewise-linear interpolation between the points corresponding to cumulative shares at $p_k = k/N$ for $k=0,1,\\dots,N$.\n\nCompute the Gini coefficient $G$ from this discrete distribution using the above definitions and assumptions. Express your final answer as a pure number in $[0,1]$, rounded to four significant figures.",
            "solution": "The problem requires the computation of the Gini coefficient for a discrete wealth distribution of a population of $N=12$ agents. The solution must adhere to the definitions provided: the Gini coefficient $G$ is derived from the area under the empirical Lorenz curve $L(p)$, which is constructed by piecewise-linear interpolation.\n\nFirst, we establish the fundamental definitions. The Lorenz curve, $L(p)$, represents the cumulative share of total wealth held by the bottom $p$ fraction of the population, where $p \\in [0,1]$. The Gini coefficient, $G$, is defined as twice the area between the line of perfect equality ($y=p$) and the Lorenz curve $L(p)$. This area is given by $\\int_0^1 (p - L(p)) dp = \\int_0^1 p dp - \\int_0^1 L(p) dp = \\frac{1}{2} - \\int_0^1 L(p) dp$. Therefore, the Gini coefficient is formulated as:\n$$\nG = 2 \\left( \\frac{1}{2} - \\int_0^1 L(p) dp \\right) = 1 - 2 \\int_0^1 L(p) dp\n$$\nThe problem specifies that the empirical Lorenz curve is constructed from the discrete data points corresponding to each agent. Let the wealth of the agents, sorted in non-decreasing order, be $w_i$ for $i=1, 2, \\dots, N$. The population size is $N=12$. The given wealths are:\n$w_1=1$, $w_2=1$, $w_3=2$, $w_4=3$, $w_5=3$, $w_6=4$, $w_7=5$, $w_8=8$, $w_9=12$, $w_{10}=15$, $w_{11}=30$, $w_{12}=36$.\n\nThe total wealth of the population, $W_{total}$, is the sum of individual wealths:\n$$\nW_{total} = \\sum_{i=1}^{N} w_i = 1+1+2+3+3+4+5+8+12+15+30+36 = 120\n$$\nThe Lorenz curve is constructed from points $(p_k, L_k)$, where $p_k$ is the cumulative population fraction and $L_k$ is the cumulative wealth fraction for the first $k$ agents. Since each agent has equal population weight, the cumulative population fractions are $p_k = k/N$ for $k=0, 1, \\dots, N$. The cumulative wealth of the first $k$ agents is $C_k = \\sum_{i=1}^k w_i$. The cumulative wealth fraction is $L_k = C_k / W_{total}$.\n\nWe construct the points for the Lorenz curve:\n- For $k=0$: $p_0 = 0/12 = 0$. $C_0 = 0$. $L_0 = 0/120 = 0$.\n- For $k=1$: $p_1 = 1/12$. $C_1 = 1$. $L_1 = 1/120$.\n- For $k=2$: $p_2 = 2/12$. $C_2 = 1+1=2$. $L_2 = 2/120$.\n- For $k=3$: $p_3 = 3/12$. $C_3 = 2+2=4$. $L_3 = 4/120$.\n- For $k=4$: $p_4 = 4/12$. $C_4 = 4+3=7$. $L_4 = 7/120$.\n- For $k=5$: $p_5 = 5/12$. $C_5 = 7+3=10$. $L_5 = 10/120$.\n- For $k=6$: $p_6 = 6/12$. $C_6 = 10+4=14$. $L_6 = 14/120$.\n- For $k=7$: $p_7 = 7/12$. $C_7 = 14+5=19$. $L_7 = 19/120$.\n- For $k=8$: $p_8 = 8/12$. $C_8 = 19+8=27$. $L_8 = 27/120$.\n- For $k=9$: $p_9 = 9/12$. $C_9 = 27+12=39$. $L_9 = 39/120$.\n- For $k=10$: $p_{10} = 10/12$. $C_{10} = 39+15=54$. $L_{10} = 54/120$.\n- For $k=11$: $p_{11} = 11/12$. $C_{11} = 54+30=84$. $L_{11} = 84/120$.\n- For $k=12$: $p_{12} = 12/12 = 1$. $C_{12} = 84+36=120$. $L_{12} = 120/120 = 1$.\n\nThe integral $\\int_0^1 L(p) dp$ represents the area under the piecewise-linear Lorenz curve. This area can be calculated as the sum of the areas of $N$ trapezoids. The $k$-th trapezoid is defined over the interval $[p_{k-1}, p_k]$. Its area $A_k$ is given by:\n$$\nA_k = \\frac{1}{2} (L_{k-1} + L_k) (p_k - p_{k-1})\n$$\nSince $p_k - p_{k-1} = (k/N) - ((k-1)/N) = 1/N$, the total area $A$ is:\n$$\nA = \\sum_{k=1}^{N} A_k = \\sum_{k=1}^{N} \\frac{1}{2} (L_{k-1} + L_k) \\frac{1}{N} = \\frac{1}{2N} \\sum_{k=1}^{N} (L_{k-1} + L_k)\n$$\nExpanding the sum:\n$$\nA = \\frac{1}{2N} ( (L_0+L_1) + (L_1+L_2) + \\dots + (L_{N-1}+L_N) ) = \\frac{1}{2N} (L_0 + 2\\sum_{k=1}^{N-1} L_k + L_N)\n$$\nGiven $N=12$, $L_0=0$, and $L_{12}=1$, we have:\n$$\nA = \\frac{1}{2(12)} (0 + 2\\sum_{k=1}^{11} L_k + 1) = \\frac{1}{24} (1 + 2\\sum_{k=1}^{11} L_k)\n$$\nWe compute the sum of the cumulative wealth fractions $\\sum_{k=1}^{11} L_k$:\n$$\n\\sum_{k=1}^{11} L_k = \\frac{1}{W_{total}} \\sum_{k=1}^{11} C_k = \\frac{1}{120} (1+2+4+7+10+14+19+27+39+54+84)\n$$\nThe sum of the cumulative wealths is:\n$$\n\\sum_{k=1}^{11} C_k = 261\n$$\nSo, the sum of the fractions is:\n$$\n\\sum_{k=1}^{11} L_k = \\frac{261}{120}\n$$\nNow, substitute this into the expression for the area $A$:\n$$\nA = \\frac{1}{24} \\left(1 + 2 \\times \\frac{261}{120}\\right) = \\frac{1}{24} \\left(1 + \\frac{522}{120}\\right) = \\frac{1}{24} \\left(\\frac{120}{120} + \\frac{522}{120}\\right) = \\frac{1}{24} \\left(\\frac{642}{120}\\right) = \\frac{642}{2880}\n$$\nThe fraction can be simplified. Both numerator and denominator are divisible by $6$: $642/6 = 107$ and $2880/6 = 480$.\n$$\nA = \\frac{107}{480}\n$$\nFinally, we compute the Gini coefficient $G$:\n$$\nG = 1 - 2A = 1 - 2 \\left(\\frac{107}{480}\\right) = 1 - \\frac{214}{480} = 1 - \\frac{107}{240}\n$$\n$$\nG = \\frac{240}{240} - \\frac{107}{240} = \\frac{133}{240}\n$$\nTo provide the final answer, we convert this fraction to a decimal and round to four significant figures.\n$$\nG = \\frac{133}{240} \\approx 0.5541666...\n$$\nRounding to four significant figures gives $0.5542$.",
            "answer": "$$\n\\boxed{0.5542}\n$$"
        }
    ]
}