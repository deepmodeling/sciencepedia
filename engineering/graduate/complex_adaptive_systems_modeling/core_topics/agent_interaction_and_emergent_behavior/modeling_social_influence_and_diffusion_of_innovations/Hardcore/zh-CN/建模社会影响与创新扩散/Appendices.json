{
    "hands_on_practices": [
        {
            "introduction": "度分布是网络分析的基石，它常常决定了大规模现象发生的潜力。在本练习中，我们将使用生成函数这一强大形式，推导网络中巨连接组件的大小。这个量至关重要，因为它代表了简单传染或仅需单次接触即可采纳的创新，其传播范围的理论上限。",
            "id": "4129714",
            "problem": "考虑一个由组态模型（CM）生成的非常大的社交网络，其中每个节点的度都是从给定的度分布 $P(k)$ 中独立抽取的。假设网络在大尺寸极限下是局部树状的。一种简单传染代表一种创新，一旦暴露，它会沿着每个社会联系以确定性的方式被采纳，传播概率等于 $1$。初始种子是无穷小的、随机散布的，因此任何宏观采纳都仅由网络的连通性结构产生。因此，渐近采纳者比例等于底层CM网络中巨大连通分量中的节点比例。\n\n设度分布定义在集合 $\\{0,1,2,5,10\\}$ 上，其概率为\n$P(0)=0.05$，$P(1)=0.15$，$P(2)=0.25$，$P(5)=0.30$，以及 $P(10)=0.25$。定义节点度生成函数（generating function (GF)）$G_{0}(x)=\\sum_{k=0}^{\\infty}P(k)x^{k}$ 和超额度生成函数 $G_{1}(x)=\\sum_{k=1}^{\\infty}\\frac{kP(k)}{\\langle k\\rangle}x^{k-1}$，其中 $\\langle k\\rangle=\\sum_{k}kP(k)$ 是平均度。\n\n从CM网络和局部树状传播的标准第一性原理（概率守恒、树状邻域中各分支的独立性，以及与用于邻域探索的Galton–Watson分支过程的等价性）出发，推导沿着一条均匀随机选择的边仅进入一个有限子树的概率的自洽关系，以及用 $G_{0}$ 和 $G_{1}$ 表示的渐近采纳者比例的相应表达式。然后计算给定 $P(k)$ 下渐近采纳者比例的数值。将最终答案四舍五入到四位有效数字。最终答案无需物理单位。",
            "solution": "用户希望在一个组态模型（CM）网络上，找到一个简单传染模型中的渐近采纳者比例。问题陈述明确地将此比例等同于网络巨大连通分量（GCC）的相对大小。我们将首先使用生成函数推导GCC大小的一般表达式，然后将它们应用于给定的特定度分布。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- 网络模型：组态模型（CM），非常大，局部树状。\n- 度分布：节点的度 $k$ 从一个分布 $P(k)$ 中独立抽取。\n- 传染模型：简单传染，传播概率为 $1$。\n- 初始条件：无穷小的随机种子。\n- 采纳者比例：渐近采纳者比例等于GCC中的节点比例。\n- 具体度分布：\n  - $P(0) = 0.05$\n  - $P(1) = 0.15$\n  - $P(2) = 0.25$\n  - $P(5) = 0.30$\n  - $P(10) = 0.25$\n- 定义：\n  - 节点度生成函数: $G_0(x) = \\sum_{k=0}^{\\infty} P(k) x^k$\n  - 超额度生成函数: $G_1(x) = \\sum_{k=1}^{\\infty} \\frac{k P(k)}{\\langle k \\rangle} x^{k-1}$\n  - 平均度: $\\langle k \\rangle = \\sum_k k P(k)$\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**：该问题使用了网络科学中标准的、成熟的概念，包括组态模型、度分布的生成函数，以及用于寻找巨大分量大小的分支过程形式化方法。这些方法是复杂网络研究的基础。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。度分布被完全指定，待推导的量有明确定义，最终的数值计算是无歧义的。问题给出了物理过程（传染）和网络结构属性（GCC大小）之间的明确联系，确保了唯一且有意义的解的存在。\n- **客观性**：问题以精确、客观的数学语言陈述。\n\n**1.3. 结论与行动**\n问题是有效的。它具有科学依据，是适定且客观的。没有可识别的缺陷。我们继续进行求解。\n\n### 步骤 2：推导自洽方程\n\n令 $S$ 为巨大连通分量（GCC）中的节点比例。问题要求计算这个值。通常，首先计算*不*在GCC中的节点比例会更容易，我们将其表示为 $u$。那么，$S = 1 - u$。如果一个节点属于一个有限分量，那么它就不在GCC中。\n\n我们引入两个概率：\n1. $u$：一个随机选择的节点属于有限分量的概率。\n2. $v$：沿着一条随机选择的边会进入一个有限分量的概率。\n\n网络规模巨大且局部树状的假设至关重要。这意味着节点的邻域是树状的，我们可以将从一个节点分支出去的路径视为独立的。这使我们能够将网络探索建模为Galton-Watson分支过程。\n\n首先，我们来推导 $v$ 的自洽关系。考虑一条随机选择的边。它通向某个节点，我们称之为节点 $A$。这条边进入一个有限分量的概率是 $v$。要使这种情况发生，节点 $A$ 本身以及可从其*其他*边到达的整个分量都必须是有限的。\n\n一条随机选择的边通向一个度为 $k$ 的节点的概率由 $\\frac{k P(k)}{\\langle k \\rangle}$ 给出。这是因为一个度为 $k$ 的节点有 $k$ 个“末梢”或边端，因此通过沿边选择它比选择一个度为 $1$ 的节点的可能性要大 $k$ 倍。分母 $\\langle k \\rangle = \\sum_j j P(j)$ 确保了归一化。\n\n如果这个目标节点 $A$ 的度为 $k$，那么除了我们到达的那条边之外，它还有 $k-1$ 条其他的边。要使节点 $A$ 从我们到达的边的视角看是有限分量的一部分，其所有 $k-1$ 个其他子分支也必须是有限的。根据定义，这些其他边中任何一条通向有限分量的概率都是 $v$。由于局部树状的假设，这 $k-1$ 个分支的命运是独立的。因此，所有 $k-1$ 个分支都是有限的概率是 $v^{k-1}$。\n\n为了得到总概率 $v$，我们必须对目标节点 $A$ 的所有可能的度 $k$ 进行平均：\n$$v = \\sum_{k=1}^{\\infty} \\left( \\frac{k P(k)}{\\langle k \\rangle} \\right) v^{k-1}$$\n这个求和项正是超额度生成函数 $G_1(x)$ 在 $x=v$ 处求值的定义。这就得到了第一个自洽关系：\n$$v = G_1(v)$$\n\n接下来，我们推导 $u$ 的表达式。一个随机选择的节点属于一个有限分量，当且仅当它的所有边都通向有限分量。一个随机选择的节点有 $P(k)$ 的概率度为 $k$。如果它的度为 $k$，它就有 $k$ 条边。其中任意一条边通向有限分量的概率是 $v$。由于各分支是独立的，所有 $k$ 条边都通向有限分量的概率是 $v^k$。\n\n为了找到总概率 $u$，我们将这个概率对初始节点所有可能的度 $k$ 进行平均：\n$$u = \\sum_{k=0}^{\\infty} P(k) v^k$$\n这个和是节点度生成函数 $G_0(x)$ 在 $x=v$ 处求值的定义。因此，我们有：\n$$u = G_0(v)$$\n\n结合这些结果，采纳者的比例 $S$，即GCC的大小，由下式给出：\n$$S = 1 - u = 1 - G_0(v)$$\n其中 $v$ 是方程 $v = G_1(v)$ 的最小非负解。一个解 $v=1$ 总是存在的。一个非平凡解 $v  1$ 存在当且仅当GCC存在，而如果 $G_1'(1) > 1$，则保证GCC存在。\n\n### 步骤 3：数值计算\n\n**3.1. 计算平均度和生成函数**\n度分布为 $P(0)=0.05$，$P(1)=0.15$，$P(2)=0.25$，$P(5)=0.30$，以及 $P(10)=0.25$。\n平均度 $\\langle k \\rangle$ 是：\n$$\\langle k \\rangle = \\sum_{k} k P(k) = (0)(0.05) + (1)(0.15) + (2)(0.25) + (5)(0.30) + (10)(0.25)$$\n$$\\langle k \\rangle = 0 + 0.15 + 0.50 + 1.50 + 2.50 = 4.65$$\n节点度生成函数是：\n$$G_0(x) = 0.05 + 0.15x + 0.25x^2 + 0.30x^5 + 0.25x^{10}$$\n超额度生成函数是：\n$$G_1(x) = \\frac{1}{\\langle k \\rangle} \\sum_{k=1}^{\\infty} k P(k) x^{k-1}$$\n$$G_1(x) = \\frac{1}{4.65} \\left( (1)(0.15)x^0 + (2)(0.25)x^1 + (5)(0.30)x^4 + (10)(0.25)x^9 \\right)$$\n$$G_1(x) = \\frac{1}{4.65} \\left( 0.15 + 0.5x + 1.5x^4 + 2.5x^9 \\right)$$\n\n**3.2. 求解 v**\n我们必须找到 $v = G_1(v)$ 的最小非负根。我们可以通过不动点迭代法 $v_{n+1} = G_1(v_n)$ 来求解，从 $v_0 = 0$ 开始。\n$v_0 = 0$\n$v_1 = G_1(v_0) = \\frac{1}{4.65} (0.15) \\approx 0.03225806$\n$v_2 = G_1(v_1) = \\frac{1}{4.65} \\left( 0.15 + 0.5(0.03225806) + 1.5(0.03225806)^4 + \\dots \\right) \\approx 0.03572669$\n$v_3 = G_1(v_2) = \\frac{1}{4.65} \\left( 0.15 + 0.5(0.03572669) + \\dots \\right) \\approx 0.03610029$\n$v_4 = G_1(v_3) \\approx 0.03614002$\n$v_5 = G_1(v_4) \\approx 0.03614449$\n$v_6 = G_1(v_5) \\approx 0.03614499$\n$v_7 = G_1(v_6) \\approx 0.03614505$\n迭代收敛得很快。我们取 $v \\approx 0.03614505$。\n\n**3.3. 计算采纳者比例 S**\n现在我们计算采纳者比例 $S = 1 - G_0(v)$。\n$$S = 1 - (0.05 + 0.15v + 0.25v^2 + 0.30v^5 + 0.25v^{10})$$\n使用 $v \\approx 0.03614505$：\n- $0.15v \\approx 0.15 \\times 0.03614505 = 0.0054217575$\n- $0.25v^2 \\approx 0.25 \\times (0.03614505)^2 = 0.25 \\times 0.0013064646 \\approx 0.0003266162$\n- $0.30v^5 \\approx 0.30 \\times (0.03614505)^5 = 0.30 \\times 6.104 \\times 10^{-8} \\approx 1.831 \\times 10^{-8}$\n包含 $v^{10}$ 的项小到可以忽略不计。\n$$G_0(v) \\approx 0.05 + 0.0054217575 + 0.0003266162 + 1.831 \\times 10^{-8} \\approx 0.05574839$$\n$$S = 1 - G_0(v) \\approx 1 - 0.05574839 = 0.94425161$$\n将结果四舍五入到四位有效数字，得到 $0.9443$。",
            "answer": "$$\\boxed{0.9443}$$"
        },
        {
            "introduction": "虽然度分布能很好地解释简单传染，但复杂行为（如采纳昂贵的技术或有争议的观点）的扩散通常需要社会强化。本练习生动地说明了为何超越度分布的网络结构，特别是局部聚类，对此类过程至关重要。通过比较两个度序列完全相同但聚类特性不同的网络，您将亲眼看到紧密连接的局部群组的存在与否，如何决定了级联扩散是会点燃还是熄灭。",
            "id": "4129695",
            "problem": "考虑两个简单的无向图，它们具有相同的度序列，但局部聚类特性不同。群体由 $12$ 个智能体组成，每个智能体由一个节点表示，且每个智能体恰好有 $4$ 个邻居。一项创新的采纳遵循一个确定性阈值规则：在离散时间 $t=0,1,2,\\dots$，一个节点在时间 $t+1$ 会永久采纳，当且仅当其邻居中至少有比例为 $\\phi$ 的节点在时间 $t$ 之前已经采纳。假设 $1/4  \\phi \\le 1/2$，因此当度为 $4$ 时，采纳需要至少 $2$ 个已采纳的邻居。初始种子由从边集合中均匀随机选择的恰好 $2$ 个相邻节点组成。\n\n明确定义这两个网络：\n\n- 高聚类网络 $\\mathcal{H}$：节点标记为 $0,1,\\dots,11$，边连接于 $i$ 和 $(i\\pm 1)\\bmod 12$ 之间，以及 $i$ 和 $(i\\pm 2)\\bmod 12$ 之间。每个节点的度都为 $4$。因为邻居的邻居通常本身也是邻居，所以该图包含许多三角形。\n\n- 低聚类网络 $\\mathcal{L}$：将 $12$ 个节点划分为两个集合 $L=\\{L_0,L_1,\\dots,L_5\\}$ 和 $R=\\{R_0,R_1,\\dots,R_5\\}$。对于每个 $i\\in\\{0,1,\\dots,5\\}$，包含从 $L_i$ 到 $R_i$、$R_{(i+1)\\bmod 6}$、$R_{(i+2)\\bmod 6}$ 和 $R_{(i+3)\\bmod 6}$ 的边。每个节点的度都为 $4$，并且该图是二分图，因此没有三角形。\n\n仅使用阈值采纳规则的基本定义和图结构的基本推论（例如，二分图中不存在三角形），在指定的 $1/4  \\phi \\le 1/2$ 条件和相邻对种子设定的情况下，推断级联概率的定性差异。下列哪个陈述是正确的？\n\nA. 对于 $1/4  \\phi \\le 1/2$，在 $\\mathcal{H}$ 中，一个相邻的种子对以概率 $1$ 触发全局级联，而在 $\\mathcal{L}$ 中，过程立即停止，全局级联的概率为 $0$。\n\nB. 因为两个网络具有相同的度序列，所以对于任何 $\\phi$ 和任何种子设定，它们的级联概率必须相同。\n\nC. 对于 $1/4  \\phi \\le 1/2$，在 $\\mathcal{L}$ 中，一个相邻的种子对产生的级联概率高于 $\\mathcal{H}$，因为较低的聚类增加了暴露多样性。\n\nD. 对于 $1/4  \\phi \\le 1/2$，一个相邻的种子对无法在任一网络上触发级联，因为在时间 $t=0$ 时，没有非种子节点拥有至少 $2$ 个活跃邻居。",
            "solution": "用户希望我解决一个问题。我需要以特定的格式输出我的答案。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- **图**：两个简单的无向图 $\\mathcal{H}$ 和 $\\mathcal{L}$，均具有相同的度序列。\n- **群体**：$12$ 个智能体（节点）。\n- **度**：每个节点的度 $k=4$。\n- **采纳规则**：确定性阈值规则。一个节点在时间 $t+1$ 永久采纳，当且仅当其邻居中至少有比例为 $\\phi$ 的节点在时间 $t$ 之前已经采纳。时间 $t=0,1,2,\\dots$。\n- **阈值**：$1/4  \\phi \\le 1/2$。对于度 $k=4$，所需的已采纳邻居数量为 $\\lceil k\\phi \\rceil = \\lceil 4\\phi \\rceil$。由于 $1  4\\phi \\le 2$，所需的已采纳邻居数量为 $2$。\n- **初始种子**：从边集合中均匀随机选择的恰好 $2$ 个相邻节点。\n- **网络 $\\mathcal{H}$ (高聚类)**：节点：$\\{0, 1, \\dots, 11\\}$。节点 $i$ 的边：$(i, (i \\pm 1) \\pmod{12})$ 和 $(i, (i \\pm 2) \\pmod{12})$。性质：包含许多三角形。\n- **网络 $\\mathcal{L}$ (低聚类)**：节点：划分为 $L=\\{L_0, \\dots, L_5\\}$ 和 $R=\\{R_0, \\dots, R_5\\}$。节点 $L_i$ 的边：$(L_i, R_i)$、$(L_i, R_{(i+1)\\pmod 6})$、$(L_i, R_{(i+2)\\pmod 6})$ 和 $(L_i, R_{(i+3)\\pmod 6})$，对于 $i \\in \\{0, 1, \\dots, 5\\}$。性质：二分图，无三角形。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题采用了网络扩散中成熟的阈值模型，这是复杂系统和网络科学中的一个标准课题。图 $\\mathcal{H}$ 和 $\\mathcal{L}$ 是明确定义的数学对象（$12$ 个顶点上的 $4$-正则图）。该前提在科学上和数学上都是合理的。\n- **适定性**：采纳规则是确定性的，种子设定是在一个明确定义的集合上的概率性事件。问题要求对级联概率进行定性比较，这可以从给定的参数和网络结构中推导出来。存在一个唯一的、有意义的解。\n- **客观性**：问题以精确、形式化的语言陈述。“高聚类”和“低聚类”的描述由明确的图构造来证明，这些构造分别保证了三角形的存在与否。该问题是客观的。\n- **缺陷检查清单**：该问题没有违反任何指定的无效标准。它是自包含的、一致的，并且可以用科学方法形式化。\n\n**步骤 3：结论与行动**\n- 该问题是**有效的**。现在开始解答过程。\n\n**推导**\n\n这个问题的核心在于理解局部网络结构如何与采纳阈值相互作用。采纳阈值是 $\\phi$，其中 $1/4  \\phi \\le 1/2$。对于一个度为 $k=4$ 的节点，触发其自身采纳所需的已采纳邻居数量为 $\\lceil k\\phi \\rceil = \\lceil 4\\phi \\rceil$。在给定的 $\\phi$ 范围内，我们有 $1  4\\phi \\le 2$，这意味着一个未采纳的节点必须至少有 $2$ 个已采纳的邻居才会采纳。\n\n过程在时间 $t=0$ 开始，种子是两个相邻的节点，我们称之为 $u$ 和 $v$。在时间 $t=1$，我们检查所有其他当前未采纳的节点。要使级联开始，至少要有一个未采纳的节点（比如 $w$）采纳。根据规则，节点 $w$ 必须至少有 $2$ 个在时间 $t=0$ 前已采纳的邻居。由于在 $t=0$ 时唯一已采纳的节点是 $u$ 和 $v$，所以节点 $w$ 必须同时是 $u$ 和 $v$ 的邻居。\n\n级联传播到初始种子之外的条件是，种子节点 $u$ 和 $v$ 存在一个共同的邻居。如果存在这样一个节点 $w$，那么边 $(u,v)$、$(v,w)$ 和 $(w,u)$ 必须都存在于图中。这三个节点和三条边构成了三角形，即一个 $3$-环。\n\n让我们在这种背景下分析这两个网络。\n\n**网络 $\\mathcal{L}$（低聚类）的分析：**\n网络 $\\mathcal{L}$ 被明确构造成一个二分图，其节点划分为 $L=\\{L_0, L_1, \\dots, L_5\\}$ 和 $R=\\{R_0, R_1, \\dots, R_5\\}$。$\\mathcal{L}$ 中的所有边都连接 $L$ 中的一个节点和 $R$ 中的一个节点。根据定义，二分图是一种其顶点可以被分成两个不相交的集合的图，使得每条边都连接第一个集合中的一个顶点和第二个集合中的一个顶点。二分图的一个基本性质是它们不包含任何奇数长度的环。由于三角形是一个长度为 $3$ 的环，网络 $\\mathcal{L}$ 不包含任何三角形。\n\n因此，对于 $\\mathcal{L}$ 中的任何相邻种子对 $(u,v)$，不可能存在一个共同邻居 $w$。如果存在这样的 $w$，$\\{u,v,w\\}$ 将形成一个三角形，这在 $\\mathcal{L}$ 中是不可能的。这意味着在 $t=0$ 时，没有一个未采纳的节点在已采纳集合 $\\{u,v\\}$ 中有超过一个邻居。由于采纳的阈值是 $2$，在 $t=1$ 时不会有新节点采纳。过程立即停止，已采纳节点的集合永久固定为 $\\{u,v\\}$。“全局级联”（定义为采纳范围超出初始种子，通常意味着网络中相当大一部分节点被采纳）不会发生。因此，全局级联的概率为 $0$。\n\n**网络 $\\mathcal{H}$（高聚类）的分析：**\n网络 $\\mathcal{H}$ 构建在节点 $\\{0, 1, \\dots, 11\\}$ 上，边连接节点 $i$ 到 $(i\\pm 1)\\bmod 12$ 和 $(i\\pm 2)\\bmod 12$。问题陈述该图有许多三角形。我们必须验证对于任何相邻的种子对，至少存在一个共同的邻居。此图中的边可以根据其端点之间的距离进行分类：距离为 $1$ 的边，如 $(i, i+1)$，和距离为 $2$ 的边，如 $(i, i+2)$。\n\n1.  **种子是距离为 $1$ 的边**：设种子是相邻对 $(0,1)$。我们确定它们的共同邻居。$0$ 的邻居：$N(0) = \\{11, 1, 2, 10\\}$。$1$ 的邻居：$N(1) = \\{0, 2, 3, 11\\}$。共同邻居的集合是 $N(0) \\cap N(1) = \\{2, 11\\}$。由于节点 $2$ 和 $11$ 都连接到初始采纳者 $0$ 和 $1$，它们都达到了 $2$ 个已采纳邻居的阈值。在 $t=1$ 时，节点 $2$ 和 $11$ 将会采纳。采纳者集合变为 $\\{0, 1, 2, 11\\}$。这会引发一个级联，通过进一步的逐步分析可以表明，最终将导致所有 $12$ 个节点的采纳。\n\n2.  **种子是距离为 $2$ 的边**：设种子是相邻对 $(0,2)$。我们确定它们的共同邻居。$0$ 的邻居：$N(0) = \\{11, 1, 2, 10\\}$。$2$ 的邻居：$N(2) = \\{0, 1, 3, 4\\}$。共同邻居的集合是 $N(0) \\cap N(2) = \\{1\\}$。节点 $1$ 连接到初始采纳者 $0$ 和 $2$。它达到了阈值，并将在 $t=1$ 时采纳。采纳者集合变为 $\\{0,1,2\\}$。这个更大的活跃集合足以触发进一步的采纳（例如，节点 $3$ 和 $11$ 将在 $t=2$ 时采纳），从而导致全局级联。\n\n由于图 $\\mathcal{H}$ 在这两种类型的边上是边传递的，并且两种类型的边都会引发全局级联，因此任何随机选择的边作为种子都将触发全局级联。在 $\\mathcal{H}$ 中发生全局级联的概率是 $1$。\n\n**逐项分析**\n\n**A. 对于 $1/4  \\phi \\le 1/2$，在 $\\mathcal{H}$ 中，一个相邻的种子对以概率 $1$ 触发全局级联，而在 $\\mathcal{L}$ 中，过程立即停止，全局级联的概率为 $0$。**\n这个陈述准确地总结了我们推导的结果。在 $\\mathcal{H}$ 中，大量的三角形确保任何种子边都能提供启动级联所必需的冗余连接，然后级联会全局传播。概率为 $1$。在 $\\mathcal{L}$ 中，三角形的缺失使得级联永远无法开始。概率为 $0$。\n结论：**正确**。\n\n**B. 因为两个网络具有相同的度序列，所以对于任何 $\\phi$ 和任何种子设定，它们的级联概率必须相同。**\n这个陈述是网络分析中常见的谬误。度序列是一阶属性，不足以确定像级联这样的动态过程。如我们的分析所示，像聚类（三角形）这样的高阶结构至关重要，即使度序列相同，也会导致截然不同的结果（级联概率为 $1$ 对比 $0$）。\n结论：**不正确**。\n\n**C. 对于 $1/4  \\phi \\le 1/2$，在 $\\mathcal{L}$ 中，一个相邻的种子对产生的级联概率高于 $\\mathcal{H}$，因为较低的聚类增加了暴露多样性。**\n我们的分析表明，在 $\\mathcal{L}$ 中的级联概率为 $0$，在 $\\mathcal{H}$ 中为 $1$。该陈述提出了相反的主张。其理由“较低的聚类增加了暴露多样性”是一个概念（与 Granovetter 的“弱关系的力量”有关），适用于简单传染或信息传播，其中单次暴露就足够了。对于阈值大于 $1$ 的复杂传染，来自高聚类（冗余关系）的社会强化是必要的。这个逻辑在这个情境下被误用了。\n结论：**不正确**。\n\n**D. 对于 $1/4  \\phi \\le 1/2$，一个相邻的种子对无法在任一网络上触发级联，因为在时间 $t=0$ 时，没有非种子节点拥有至少 $2$ 个活跃邻居。**\n这个陈述正确地描述了网络 $\\mathcal{L}$ 中的情况，但对于网络 $\\mathcal{H}$ 则不成立。在 $\\mathcal{H}$ 中，对于任何相邻的种子对，至少有一个非种子节点以两个种子节点为邻居（即，在 $t=0$ 时有 $2$ 个活跃邻居）。因此，在 $\\mathcal{H}$ 中会触发级联。由于该陈述声称这适用于“任一网络”，所以它是错误的。\n结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现实世界的社交网络并非静止不变，连接会随时间出现和消失。这种动态特性对影响力的传播施加了严格的因果约束——机会必须在正确的时间出现。本练习将我们从静态图带入时序网络的领域，挑战您开发一种算法，用于计算沿“时间尊重路径”的可达性，并捕捉时间在扩散过程中的根本性作用。",
            "id": "4129747",
            "problem": "考虑一个表示创新扩散中社会影响流动的时序网络。该网络由一个有限的、带有时间戳的有向接触列表指定，每个接触是一个三元组 $(i,j,t)$，表示主体 $i$ 在绝对时间 $t$ 影响主体 $j$。时间以秒为单位，接触发生在离散的时间点。假设接触上的传播是瞬时的，处理延迟可以忽略不计，并且影响不能在时间上向后传播。扩散过程由一个种子主体 $s$ 在时间 $0$ 引发，该主体在时间 $0$ 时已被影响。\n\n将从 $s$ 到节点 $v$ 的时间尊重路径（time-respecting path）定义为一个有限的接触序列 $((v_0,v_1,t_1), (v_1,v_2,t_2), \\ldots, (v_{k-1},v_k,t_k))$，其中 $v_0 = s$，$v_k = v$，$t_1 \\le t_2 \\le \\cdots \\le t_k$ 且 $t_1 \\ge 0$。如果存在至少一条从 $s$ 到 $v$ 的时间尊重路径，其最后一个时间戳 $t_k$ 满足 $t_k \\le T$，则称节点 $v$ 在时间窗口 $[0,T]$ 内可从 $s$ 时序可达。种子 $s$ 的时序可达性是集合 $R(T)$，它包含所有在 $[0,T]$ 内时序可达的节点 $v \\neq s$。\n\n从时序网络中的因果性和时间顺序的基本原则出发，并仅使用“影响能够通过一个接触 $(i,j,t)$ 传播当且仅当主体 $i$ 在时间 $t$ 之前或之时已被影响”这一假设，推导出一个算法，该算法能从给定的接触列表和种子 $s$ 计算出任意有限 $T \\ge 0$ 的 $R(T)$。该算法应能生成基数 $|R(T)|$，即时序可达节点（不包括种子）的整数计数。推导过程不得依赖于捷径公式，并且必须从第一性原理证明其正确性。\n\n您的程序必须实现此算法，并将其应用于以下测试套件（时间单位为秒）：\n\n- 测试用例 $1$：接触列表 $[(0,1,1),(1,2,2),(2,3,3)]$，种子 $s=0$，时间窗口 $T=3$。预期行为：一个时间严格递增的直接链条。\n- 测试用例 $2$：接触列表 $[(0,1,2),(1,2,2)]$，种子 $s=0$，时间窗口 $T=2$。预期行为：允许在边界 $t=T$ 处相等。\n- 测试用例 $3$：接触列表 $[(0,1,1),(1,2,1),(2,3,1)]$，种子 $s=0$，时间窗口 $T=1$。预期行为：同时的时间戳允许时间非递减的瞬时链式传播。\n- 测试用例 $4$：接触列表 $[(1,0,1)]$，种子 $s=0$，时间窗口 $T=10$。预期行为：反向的接触阻止了从种子的向外扩散。\n- 测试用例 $5$：接触列表 $[(0,1,5),(1,0,6),(1,2,7),(0,2,10)]$，种子 $s=0$，时间窗口 $T=8$。预期行为：存在循环和多条路径；只有在 $T$ 之前完成的路径才有贡献。\n\n每个测试用例仅由接触列表、种子 $s$ 和时间窗口 $T$ 定义。要求的输出为一行，包含一个逗号分隔的整数基数 $|R(T)|$ 列表，按上述测试用例的顺序列出，并用方括号括起来。例如，程序必须输出格式为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$ 的字符串。\n\n时间值以秒为单位；输出的计数是无单位的整数。不涉及角度或百分比。程序必须是自包含的，无需输入。最终输出行必须只包含指定的列表格式，不得有任何附加文本。",
            "solution": "问题陈述被验证为科学上合理、定义明确、客观且完整。它描述了一个在由定时事件序列定义的网络上的经典时序可达性问题。这是动态网络和复杂系统研究中的一个标准问题，所有术语和条件都得到了正式且无歧义的定义。因此，我将继续进行推导和求解。\n\n题目要求一个算法，用于计算在时间窗口 $[0, T]$ 内从一个种子节点 $s$ 出发的时序可达节点集合的大小 $|R(T)|$。推导必须基于因果性和时间顺序的基本原则。\n\n核心原则是因果性：一个主体 $j$ 只能通过一个接触 $(i,j,t)$ 被主体 $i$ 影响，前提是主体 $i$ 本身在时间 $t$ 或之前已经被影响。目标是找到所有能通过这样一系列因果有序的事件从种子 $s$ 到达的节点。这等同于找到每个节点能被影响的最早可能时间。\n\n设 $\\tau(v)$ 为主体 $v$ 能被影响的最早时间。题目指定种子主体 $s$ 在时间 $0$ 被影响，因此我们有初始条件：\n$$ \\tau(s) = 0 $$\n对于任何其他主体 $v \\neq s$，它最初未被影响。我们可以通过将其最早影响时间设置为无穷大来表示此状态：\n$$ \\tau(v) = \\infty \\quad \\forall v \\neq s $$\n\n扩散过程作为一系列离散事件展开，这些事件就是接触。时间尊重路径由一个接触序列 $((v_0,v_1,t_1), (v_1,v_2,t_2), \\ldots, (v_{k-1},v_k,t_k))$ 定义，其中 $v_0 = s$ 且时间戳非递减，$t_1 \\le t_2 \\le \\cdots \\le t_k$。这个非递减时间约束是因果性和时间顺序的数学形式化。一个遵守此结构的算法自然是正确的。\n\n对时间流进行建模的最直接方法是按事件发生的顺序处理它们。因此，我们算法的第一步必须是按时间戳 $t$ 的非递减顺序对所有接触的列表 $C$ 进行排序。设这个排序后的列表为 $C_{\\text{sorted}}$。\n\n现在我们可以遍历 $C_{\\text{sorted}}$ 并更新所有节点的最早影响时间 $\\tau(v)$。对于 $C_{\\text{sorted}}$ 中的每个接触 $(i, j, t)$，我们应用因果条件：如果源主体 $i$ 在时间 $t$ 或之前已被影响，即 $\\tau(i) \\le t$，那么影响可以传播到主体 $j$。由于传播是瞬时的，主体 $j$ 可以在时间 $t$ 被影响。这为 $j$ 提供了一个新的潜在影响时间。因为我们寻求的是*最早*的此类时间，所以只有当这个新时间 $t$ 小于当前已知的 $\\tau(j)$ 值时，我们才必须更新 $\\tau(j)$。这引出了更新规则：\n$$ \\text{如果 } \\tau(i) \\le t, \\text{ 那么 } \\tau(j) := \\min(\\tau(j), t) $$\n\n单次遍历按时间排序的接触就足以找到所有节点的最早影响时间。为了证明这一点，考虑从 $s$ 到某个节点 $v$ 的任意一条时间尊重路径。该路径由一系列时间戳非递减的接触组成。因为我们的算法以同样的非递减时间顺序处理接触，所以路径中的一个接触 $(v_{m}, v_{m+1}, t_{m+1})$ 将只会在其前一个接触 $(v_{m-1}, v_m, t_m)$ 之后或同时被处理（因为 $t_m \\le t_{m+1}$）。通过归纳法，当我们处理接触 $(v_m, v_{m+1}, t_{m+1})$ 时，$\\tau(v_m)$ 的值已经通过路径前缀的传播被正确地确定为不晚于 $t_m$。由于 $t_m \\le t_{m+1}$，条件 $\\tau(v_m) \\le t_{m+1}$ 将被满足，影响将正确地传播到 $v_{m+1}$。这对所有可能的时间尊重路径都成立。\n\n在遍历完 $C_{\\text{sorted}}$ 中的所有接触后，$\\tau$ 值的数组或映射将保存从 $s$ 可达的每个节点的最早可能影响时间。\n\n最后一步是计算所求的数量 $|R(T)|$。集合 $R(T)$ 由所有在时间窗口 $[0, T]$ 内时序可达的节点 $v \\neq s$ 组成。一个节点 $v$ 在此窗口内可达，当且仅当其最早影响时间小于或等于 $T$。因此，我们计算满足两个条件的节点 $v$ 的数量：$v \\neq s$ 且 $\\tau(v) \\le T$。\n\n完整的算法如下：\n\n1.  从接触列表中收集所有唯一的主体标识符集合 $V$。\n2.  初始化一个数据结构 `influence_times`，用于存储每个 $v \\in V$ 的 $\\tau(v)$。设置 $\\tau(s) = 0$ 并且对于所有 $v \\in V, v \\neq s$ 设置 $\\tau(v) = \\infty$。\n3.  按时间戳非递减顺序对接触列表 $C$ 进行排序，得到 $C_{\\text{sorted}}$。\n4.  对于 $C_{\\text{sorted}}$ 中的每个接触 $(i, j, t)$：\n    a. 检查源主体 $i$ 是否可能在时间 $t$ 之前或之时被影响：$\\tau(i) \\le t$。\n    b. 如果是，则更新目标主体的最早影响时间：$\\tau(j) = \\min(\\tau(j), t)$。\n5.  循环结束后，初始化一个计数器 `reachable_count` 为 $0$。\n6.  遍历所有主体 $v \\in V$：\n    a. 如果 $v \\neq s$ 且 $\\tau(v) \\le T$，则 `reachable_count` 加一。\n7.  最终结果是 `reachable_count`。\n\n该算法从指定的第一性原理正确地推导出解决方案，并将被实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the temporal reachability problem for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"contacts\": [(0, 1, 1), (1, 2, 2), (2, 3, 3)],\n            \"s\": 0,\n            \"T\": 3\n        },\n        {\n            \"contacts\": [(0, 1, 2), (1, 2, 2)],\n            \"s\": 0,\n            \"T\": 2\n        },\n        {\n            \"contacts\": [(0, 1, 1), (1, 2, 1), (2, 3, 1)],\n            \"s\": 0,\n            \"T\": 1\n        },\n        {\n            \"contacts\": [(1, 0, 1)],\n            \"s\": 0,\n            \"T\": 10\n        },\n        {\n            \"contacts\": [(0, 1, 5), (1, 0, 6), (1, 2, 7), (0, 2, 10)],\n            \"s\": 0,\n            \"T\": 8\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        contacts = case[\"contacts\"]\n        s = case[\"s\"]\n        T = case[\"T\"]\n\n        # 1. Gather all unique nodes from the contact list.\n        nodes = set()\n        for i, j, t in contacts:\n            nodes.add(i)\n            nodes.add(j)\n        if not nodes:\n            results.append(0)\n            continue\n        nodes.add(s) # Ensure the seed node is included.\n\n        # 2. Initialize influence times.\n        # tau[v] stores the earliest time agent v can be influenced.\n        # Initialize seed at time 0, others at infinity.\n        influence_times = {node: np.inf for node in nodes}\n        influence_times[s] = 0\n\n        # 3. Sort contacts by timestamp in non-decreasing order.\n        # The key to this algorithm, processing events as they occur in time.\n        sorted_contacts = sorted(contacts, key=lambda x: x[2])\n\n        # 4. Iterate through sorted contacts and propagate influence.\n        for i, j, t in sorted_contacts:\n            # Causal condition: If agent 'i' was influenced at or before time 't',\n            # influence can propagate.\n            # We use .get() to be safe, though 'i' should always be in the dict.\n            if influence_times.get(i, np.inf) = t:\n                # Update agent 'j's influence time if this path is faster.\n                current_time_j = influence_times.get(j, np.inf)\n                influence_times[j] = min(current_time_j, t)\n        \n        # 5. Count reachable nodes within the time window T.\n        # According to the problem, the set R(T) excludes the seed s.\n        reachable_count = 0\n        for node, time in influence_times.items():\n            if node != s and time = T:\n                reachable_count += 1\n        \n        results.append(reachable_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}