{
    "hands_on_practices": [
        {
            "introduction": "倍增映射 $f(x)=2x \\pmod 1$ 是混沌理论中最具代表性的简单模型之一。这个练习将引导我们从最大李雅普诺夫指数（LLE）的基本定义出发，通过直接计算来揭示一个简单的确定性规则如何导致指数级的轨道分离。掌握这个基础推导是理解和量化复杂系统中初始条件敏感依赖性（SDIC）的第一步。",
            "id": "4143062",
            "problem": "考虑一个主体在单位圆上的内部相位的程式化微观动力学，这是复杂自适应系统建模中的一个典型组成部分。状态空间是单位圆，表示为区间 $[0,1)$ 将端点等同后得到的商空间。设离散时间更新为倍增映射 $f:[0,1)\\to[0,1)$，定义为 $f(x)=2x \\bmod 1$。圆上的距离使用内蕴度量 $d(x,y)=\\min\\{|x-y|,\\,1-|x-y|\\}$ 来测量。从最大李雅普诺夫指数 (LLE) 的核心定义出发，对于一维离散时间映射 $f$ 沿轨迹 $\\{x_{n}\\}_{n\\geq 0}$ 的 LLE 由下式给出\n$$\n\\lambda(x_{0})=\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}\\ln\\big|f'(x_{k})\\big|\\quad\\text{其中 }x_{k}=f^{k}(x_{0}),\n$$\n推导倍增映射的 LLE。然后，利用由导数所蕴含的一阶（线性化）分离动力学，推断初始条件敏感依赖性 (SDIC)，此处其定义为：对于任意足够小的初始分离 $d_{0}>0$ 和任意容差 $\\varepsilon\\in(0,\\tfrac{1}{2})$，存在一个有限时间 $n$，使得对于初始条件为 $x_{0}$ 和 $y_{0}$ 且满足 $d(x_{0},y_{0})=d_{0}$ 的两个轨迹，有 $d(x_{n},y_{n})\\geq\\varepsilon$。你的最终答案必须是 LLE 的符号值。不需要四舍五入。使用自然对数表示对数。",
            "solution": "该问题要求推导倍增映射的最大李雅普诺夫指数 (LLE)，并从该结果推断出初始条件敏感依赖性 (SDIC)。\n\n首先，我们计算 LLE。系统的演化由离散时间映射 $f:[0,1) \\to [0,1)$ 控制，该映射定义为倍增映射，$f(x) = 2x \\pmod 1$。该函数可以表示为分段线性形式：\n$$\nf(x) =\n\\begin{cases}\n2x  \\text{若 } 0 \\le x  \\frac{1}{2} \\\\\n2x-1  \\text{若 } \\frac{1}{2} \\le x  1\n\\end{cases}\n$$\n对于从初始条件 $x_0$ 出发的轨迹 $\\{x_k\\}_{k\\geq0}$，其 LLE $\\lambda(x_0)$ 由以下公式定义：\n$$\n\\lambda(x_0) = \\lim_{n\\to\\infty} \\frac{1}{n} \\sum_{k=0}^{n-1} \\ln\\big|f'(x_k)\\big| \\quad \\text{其中 } x_k = f^k(x_0)\n$$\n为了计算这个表达式，我们首先需要映射的导数 $f'(x)$。通过对 $f(x)$ 的分段部分进行微分，我们得到：\n$$\nf'(x) = 2, \\quad \\text{对于 } x \\in [0,1) \\setminus \\{\\tfrac{1}{2}\\}\n$$\n导数在点 $x=\\frac{1}{2}$ 处未定义，在该点函数 $f(x)$ 在区间 $[0,1)$ 上的表示存在跳跃间断。对于导数有定义的轨迹中的任何点 $x_k$，其绝对值为 $|f'(x_k)|=2$。\n\nLLE 公式涉及对整个轨迹的平均。为了使这个平均值有明确的定义，轨迹必须避开不可微点 $x=\\frac{1}{2}$。使得轨道 $\\{x_k\\}$ 最终包含点 $\\frac{1}{2}$ 的初始条件 $x_0$ 集合，恰好是二进有理数集（形如 $\\frac{p}{2^q}$ 的数，其中 $p, q$ 为整数）。该集合是可数的，其勒贝格测度为零。对于几乎所有的初始条件 $x_0 \\in [0,1)$，包括所有无理数，轨迹 $x_k = f^k(x_0)$ 永远不会落在点 $x=\\frac{1}{2}$ 上。\n\n因此，对于一个典型的轨迹，求和中的项 $|f'(x_k)|$ 对所有 $k \\ge 0$ 都等于 $2$。我们现在可以将此代入 LLE 的定义中：\n$$\n\\lambda(x_0) = \\lim_{n\\to\\infty} \\frac{1}{n} \\sum_{k=0}^{n-1} \\ln(2)\n$$\n求和项是 $n$ 个相同常数的和：\n$$\n\\sum_{k=0}^{n-1} \\ln(2) = n \\ln(2)\n$$\n将此结果代回极限表达式，得到 LLE 的值：\n$$\n\\lambda(x_0) = \\lim_{n\\to\\infty} \\frac{1}{n} (n \\ln(2)) = \\ln(2)\n$$\n因此，对于几乎所有的初始条件 $x_0$，倍增映射的 LLE 为 $\\lambda = \\ln(2)$。\n\n接下来，我们从计算出的 LLE 推断出 SDIC。SDIC 是指初始相近的轨迹随时间发散的性质。LLE 量化了这种发散的平均指数率。考虑两个邻近的初始条件 $x_0$ 和 $y_0 = x_0 + \\delta_0$，其中 $\\delta_0$ 表示一个非常小的初始分离。一次迭代后的分离为 $\\delta_1 = f(y_0) - f(x_0)$。对于小的 $\\delta_0$，使用一阶泰勒展开（线性化），我们有 $f(x_0 + \\delta_0) \\approx f(x_0) + f'(x_0)\\delta_0$。这导致了线性化的分离动力学 $\\delta_1 \\approx f'(x_0)\\delta_0$。\n\n经过 $n$ 次迭代后，分离 $\\delta_n = y_n - x_n$ 近似为：\n$$\n\\delta_n \\approx \\left(\\prod_{k=0}^{n-1} f'(x_k)\\right) \\delta_0\n$$\n取绝对值，我们得到分离的大小：\n$$\n|\\delta_n| \\approx |\\delta_0| \\prod_{k=0}^{n-1} |f'(x_k)|\n$$\n通过取自然对数，除以 $n$，并考虑 $n \\to \\infty$ 的极限，我们恢复了 LLE 的定义：\n$$\n\\lim_{n\\to\\infty} \\frac{1}{n} \\ln\\left(\\frac{|\\delta_n|}{|\\delta_0|}\\right) = \\lim_{n\\to\\infty} \\frac{1}{n} \\sum_{k=0}^{n-1} \\ln|f'(x_k)| = \\lambda\n$$\n这种极限关系意味着对于大的 $n$，分离的大小根据 $|\\delta_n| \\approx |\\delta_0| \\exp(\\lambda n)$ 演化。由于我们发现 $\\lambda = \\ln(2) > 0$，分离呈指数级增长：\n$$\n|\\delta_n| \\approx |\\delta_0| \\exp(n \\ln(2)) = |\\delta_0| 2^n\n$$\n一个正的 LLE 表示邻近轨迹的指数级发散，这是 SDIC 的定义性特征。问题将 SDIC 定义为：对于任意足够小的初始分离 $d_0 = d(x_0, y_0) > 0$ 和任意容差 $\\varepsilon \\in (0, \\frac{1}{2})$，存在一个有限时间 $n$，使得 $d(x_n, y_n) \\ge \\varepsilon$。\n\n指数增长 $|\\delta_n| \\approx d_0 2^n$（其中 $d_0$ 是初始距离）确保任何微观的分离 $d_0$ 都会在有限时间内被放大到宏观尺度 $\\varepsilon$。我们可以通过求解线性化分离达到 $\\varepsilon$ 的时间来估计这个时间 $n$：$d_0 2^n = \\varepsilon$，这得出 $n = \\log_2(\\varepsilon/d_0)$。由于 $d_0$ 很小，$\\varepsilon/d_0 > 1$，所以 $n$ 是一个有限的正数。虽然线性近似仅对小分离有效，但指数增长的趋势确保了分离将持续增长，直到它不再小，并成为状态空间直径的一个显著部分。因此，正的 LLE $\\lambda = \\ln(2)$ 直接蕴含了 SDIC。",
            "answer": "$$\n\\boxed{\\ln(2)}\n$$"
        },
        {
            "introduction": "对于由常微分方程（ODE）如 $\\dot{x} = f(x)$ 描述的复杂系统，解析地求解李雅普诺夫指数通常是不可能的。本练习旨在推导并理解从切空间动力学 $\\dot{\\delta x} = Df(x(t))\\delta x$ 估计最大李雅普诺夫指数的标准化数值算法。我们将重点探讨周期性重正化（renormalization）为何是防止数值溢出并获得稳定估计的关键步骤，这是将理论应用于实际建模的基石。",
            "id": "4143157",
            "problem": "考虑一个复杂自适应系统，其模型为 $\\mathbb{R}^n$ 上的光滑自治常微分方程 (ODE) $\\dot{x} = f(x)$，其中 $f$ 是连续可微的，$x(t)$ 表示从一个典型初始条件 $x(0)$ 出发的系统轨迹。设 $\\delta x(t)$ 表示一个无穷小扰动，它沿着轨迹在线性化下演化，遵循变分方程 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$，其中 $Df(x(t))$ 是在轨迹上求值的 $f$ 的雅可比矩阵。对初始条件的敏感依赖性由最大李雅普诺夫指数 $\\lambda_{\\max}$ 来量化，它描述了在切动力学作用下 $\\|\\delta x(t)\\|$ 的渐近指数增长率。\n\n根据最大李雅普诺夫指数关于切流和范数的基本定义，\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t}\\,\\ln\\left(\\frac{\\|\\delta x(t)\\|}{\\|\\delta x(0)\\|}\\right),\n$$\n推导一个基于演化变分方程的实用估计量，并解释对 $\\delta x$ 的周期性重正化如何有助于获得一个数值稳定且渐近一致的估计。选择正确描述了从 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$ 估计 $\\lambda_{\\max}$ 的有效程序的选项，包括重正化的正确作用和效果。\n\nA. 初始化 $\\delta x(0)$，使其 $\\|\\delta x(0)\\| = 1$。对于固定的 $\\Delta t > 0$，对于 $i = 1,\\dots,k$，在区间 $[(i-1)\\Delta t, i\\Delta t]$ 上将 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$ 与 $\\dot{x} = f(x)$ 同步积分，以获得更新后的 $\\delta x$。令 $s_i = \\|\\delta x(i\\Delta t)\\|$ 为第 $i$ 个区间的拉伸因子。立即通过设置 $\\delta x(i\\Delta t) \\leftarrow \\delta x(i\\Delta t)/s_i$ 进行重正化，累加 $S \\leftarrow S + \\ln(s_i)$，然后继续。在总时间 $T = k\\,\\Delta t$ 后，估计 $\\lambda_{\\max} \\approx S/T$。重正化在保持渐近率的同时防止了数值上溢/下溢，并且重复应用使 $\\delta x$ 与扩张最快的 Oseledec 子空间对齐，从而使累积的 $\\ln(s_i)$ 沿主导方向对局部增长率求和，而不改变其单位时间的平均值。\n\nB. 初始化任意非零的 $\\delta x(0)$。使用 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$ 演化 $\\delta x$，并在每个长度为 $\\Delta t$ 的步骤中，将 $\\delta x$ 重正化为单位范数，但使用瞬时增长率 $\\frac{\\|\\delta x(i\\Delta t)\\| - \\|\\delta x((i-1)\\Delta t)\\|}{\\Delta t}$ 在 $i = 1,\\dots,k$ 上的算术平均来估计 $\\lambda_{\\max}$。重正化主要减少测量噪声，对渐近估计没有影响。\n\nC. 使用 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$ 演化 $\\delta x$，不进行重正化，并对于大的 $T$ 估计 $\\lambda_{\\max} \\approx \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta x(T)\\|}{\\|\\delta x(0)\\|}\\right)$。重正化是不必要的，因为 $Df(x(t))$ 的迹决定了 $\\|\\delta x(t)\\|$ 的渐近行为。\n\nD. 通过沿轨迹平均 $Df(x(t))$ 的最大瞬时特征值来估计 $\\lambda_{\\max}$，即设 $\\lambda_{\\max} \\approx \\frac{1}{T}\\int_0^T \\alpha(Df(x(\\tau)))\\,d\\tau$，其中 $\\alpha(M)$ 表示谱横坐标（$M$ 的特征值的最大实部）。不需要重正化，因为主导的瞬时特征值决定了 $\\|\\delta x(t)\\|$ 的渐近增长率。",
            "solution": "首先将验证问题陈述的科学性和数学合理性。\n\n**问题验证**\n\n**第 1 步：提取已知信息**\n- 系统模型：一个自治常微分方程 (ODE) $\\dot{x} = f(x)$ on $\\mathbb{R}^n$。\n- 光滑性条件：$f$ 是连续可微的。\n- 轨迹：$x(t)$ 是从初始条件 $x(0)$ 出发的系统轨迹。\n- 扰动：$\\delta x(t)$ 是一个无穷小扰动。\n- 变分方程：扰动的演化由线性化方程 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$ 控制，其中 $Df(x(t))$ 是在 $x(t)$ 处求值的 $f$ 的雅可比矩阵。\n- 最大李雅普诺夫指数的定义：$\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t}\\,\\ln\\left(\\frac{\\|\\delta x(t)\\|}{\\|\\delta x(0)\\|}\\right)$。\n- 任务：从变分方程推导出一个 $\\lambda_{\\max}$ 的实用估计量，解释周期性重正化的作用，并选择描述此过程的正确选项。\n\n**第 2 步：使用提取的已知信息进行验证**\n该问题具有科学依据。其设定是动力系统理论和混沌理论中定义和分析李雅普诺夫指数的标准框架。ODE 模型 $\\dot{x}=f(x)$、使用变分方程 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$ 描述切向量的演化，以及最大李雅普诺夫指数的极限定义，都是该领域基本且正确的概念。\n\n问题设定良好且客观。它要求基于所提供的基本定义，推导一个标准的数值算法（如 Benettin 等人的算法或等效算法）。语言精确且数学化，使用标准术语而无歧义。没有矛盾、缺失关键信息或不科学的假设。该问题不违反任何有效性标准。\n\n**第 3 步：结论与行动**\n问题陈述是**有效的**。将推导解答。\n\n**推导与分析**\n\n问题要求一个实用的方法来估计最大李雅普诺夫指数，其定义为：\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t}\\,\\ln\\left(\\frac{\\|\\delta x(t)\\|}{\\|\\delta x(0)\\|}\\right)\n$$\n直接对该公式进行数值实现充满了风险。如果系统是混沌的，则 $\\lambda_{\\max} > 0$，这意味着扰动向量的范数 $\\|\\delta x(t)\\|$ 会呈指数级增长。对于大的 $t$，这在任何有限精度计算机算法中都会迅速导致数值上溢。相反，对于 $\\lambda_{\\max}  0$ 的稳定系统，$\\|\\delta x(t)\\|$ 会呈指数级衰减，导致下溢和精度损失。\n\n为了规避这个问题，我们可以利用对数的性质。让我们将总积分时间 $T$ 分成 $k$ 个持续时间为 $\\Delta t$ 的小的相等区间，使得 $T = k\\Delta t$。范数之比可以表示为每个小区间上增长因子的乘积：\n$$\n\\frac{\\|\\delta x(T)\\|}{\\|\\delta x(0)\\|} = \\frac{\\|\\delta x(k\\Delta t)\\|}{\\|\\delta x(0)\\|} = \\left(\\frac{\\|\\delta x(k\\Delta t)\\|}{\\|\\delta x((k-1)\\Delta t)\\|}\\right) \\left(\\frac{\\|\\delta x((k-1)\\Delta t)\\|}{\\|\\delta x((k-2)\\Delta t)\\|}\\right) \\dots \\left(\\frac{\\|\\delta x(\\Delta t)\\|}{\\|\\delta x(0)\\|}\\right)\n$$\n令 $t_i = i\\Delta t$。如果我们将时间 $t_{i-1}$ 处的扰动向量表示为 $\\delta x(t_{i-1})$，并将其在时间 $t_i$ 演化成的向量表示为 $\\delta x(t_i)$，那么我们可以将其写成局部增长因子的乘积。然而，向量的模长仍然会不受控制地增长或缩小。\n\n标准且正确的程序引入了一个**重正化**步骤。设 $\\delta\\hat{x}_{i-1}$ 是一个单位向量，表示在第 $i$ 个区间开始时（时间 $t_{i-1}$）扰动的方向。\n算法如下：\n1. 用 $x(0)$ 初始化主系统，用一个随机单位向量 $\\delta\\hat{x}_0$ 初始化切向量（即 $\\|\\delta\\hat{x}_0\\| = 1$）。初始化一个对数增长的累加器 $S=0$。\n2. 对于每一步 $i = 1, 2, \\dots, k$：\n    a. 在时间区间 $[t_{i-1}, t_i]$ 上，同时积分系统方程 $\\dot{x} = f(x)$ 和变分方程 $\\dot{\\delta x} = Df(x(t))\\,\\delta x$。变分方程的初始条件是 $\\delta x(t_{i-1}) = \\delta\\hat{x}_{i-1}$。令区间结束时的解为 $\\delta x'$。\n    b. 计算这个演化后向量的范数 $s_i = \\|\\delta x'\\|$。这个值 $s_i$ 表示在 $\\Delta t$ 区间内扰动向量长度被拉伸的因子。\n    c. 将该拉伸因子的对数加到累加器中：$S \\leftarrow S + \\ln(s_i)$。\n    d. 将向量重正化为单位长度以用于下一次迭代：$\\delta\\hat{x}_i = \\delta x' / s_i$。这一步至关重要。它将模长重置为 1，同时保留向量的方向，从而防止上溢/下溢。\n3. 经过 $k$ 步后，总时间为 $T = k\\Delta t$。最大李雅普诺夫指数通过平均对数增长率来估计：\n$$\n\\lambda_{\\max} \\approx \\frac{S}{T} = \\frac{1}{k\\Delta t} \\sum_{i=1}^k \\ln(s_i)\n$$\n这个程序是数值稳定的。此外，根据 Oseledec 乘法遍历定理，对于一个典型的起始向量 $\\delta\\hat{x}_0$，重复应用线性化流和重正化将导致向量 $\\delta\\hat{x}_i$ 的方向与切空间中最不稳定的方向对齐，该方向被称为第一 Oseledec 子空间。因此，测得的增长因子 $s_i$ 对应于沿此主导方向的拉伸，它们的几何平均（对应于其对数的算术平均）正确地给出了最大李雅普诺夫指数。\n\n**选项评估**\n\n**A.** 此选项描述了上面推导的程序。\n- 它正确地指明了初始化一个单位向量，在区间 $\\Delta t$ 上积分，并计算拉伸因子 $s_i = \\|\\delta x(i\\Delta t)\\|$。\n- 它正确地描述了重正化步骤 $\\delta x(i\\Delta t) \\leftarrow \\delta x(i\\Delta t)/s_i$。\n- 它正确地指明了累加对数之和 $S \\leftarrow S + \\ln(s_i)$。\n- 它正确地给出了最终估计量 $\\lambda_{\\max} \\approx S/T$。\n- 其解释也无懈可击：重正化防止了上溢/下溢，重复应用使向量与扩张最快的 Oseledec 子空间对齐，该程序正确地对沿该主导方向的局部对数增长率求和，以找到正确的渐近平均值。\n**结论：正确。**\n\n**B.** 此选项建议使用诸如 $\\frac{\\|\\delta x(i\\Delta t)\\| - \\|\\delta x((i-1)\\Delta t)\\|}{\\Delta t}$ 之类的速率的算术平均来估计 $\\lambda_{\\max}$。这是不正确的。混沌系统中扰动的增长是指数级的，因此其增长率必须用对数来表征。给定的表达式是线性变化率的近似，而非指数增长率。应该平均的正确量是对数增长率 $\\frac{1}{\\Delta t}\\ln(\\|\\delta x(i\\Delta t)\\|/\\|\\delta x((i-1)\\Delta t)\\|)$。关于重正化“减少测量噪声”的解释也很模糊，并且没有抓住防止灾难性数值失败的要点。\n**结论：不正确。**\n\n**C.** 此选项建议直接使用定义公式，不进行重正化。如推导中所述，对于任何具有非零李雅普诺夫指数的系统，由于上溢或下溢，这种方法在数值上是不可行的。其提供的理由也从根本上是错误的。雅可比矩阵的迹 $\\text{tr}(Df(x(t)))$ 与相空间体积元的变化率有关。根据推广到非线性流的刘维尔定理，所有李雅普诺夫指数之和等于雅可比矩阵迹的时间平均值：$\\sum_{j=1}^n \\lambda_j = \\lim_{T\\to\\infty} \\frac{1}{T}\\int_0^T \\text{tr}(Df(x(\\tau))) d\\tau$。这决定了体积的演化，而不是单个向量的拉伸，后者由 $\\lambda_{\\max}$ 决定。\n**结论：不正确。**\n\n**D.** 此选项认为 $\\lambda_{\\max}$ 可以通过沿轨迹平均雅可比矩阵 $Df(x(t))$ 的最大瞬时特征值（或更准确地说，是任何特征值的最大实部，即谱横坐标）来估计。这是一个常见的误解。最大李雅普诺夫指数是非自治线性系统 $\\dot{\\delta x} = A(t)\\delta x$（其中 $A(t) = Df(x(t))$）的一个性质。此类系统解的渐近增长率通常不等于 $A(t)$ 最大特征值的时间平均值。原因在于 $A(t)$ 的特征向量随着系统沿轨迹演化而旋转。扰动向量 $\\delta x$ 在瞬时最扩张方向本身改变之前，没有足够的时间与该方向对齐。长期增长是流的累积、乘法作用的结果，这被选项 A 中的程序正确捕捉，而不是通过平均局部特征值。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "这个综合性练习将我们前面学到的理论和算法应用于著名的洛伦兹系统——一个混沌现象的经典范例。你不仅需要实现数值算法来计算最大李雅普诺夫指数，还需要系统地分析积分器阶数和步长等数值参数如何影响计算精度。此外，本练习还引入了“影子时间”（shadowing time）的概念，从而更深入地探讨数值轨迹在混沌系统中的有效性。",
            "id": "4143119",
            "problem": "您的任务是设计并实现一个数值实验，以量化固定步长和积分器阶数对混沌流中计算出的最大李雅普诺夫指数精度的影响，同时评估“影随”行为。该问题必须纯粹从数学和算法的角度来解决，使用经过充分检验的定义和公式作为基础。\n\n考虑三维 Lorenz 系统，其参数选定在经典的混沌区，由以下常微分方程定义\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\nx \\\\ y \\\\ z\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\sigma (y - x) \\\\\nx (\\rho - z) - y \\\\\nx y - \\beta z\n\\end{bmatrix},\n$$\n其中 $ (\\sigma, \\rho, \\beta) = (10, 28, 8/3) $，初始条件为 $x(0) = 1, y(0) = 1, z(0) = 1$。对初始条件的敏感性这一基本概念由最大李雅普诺夫指数来量化，对于一个连续时间动力系统，其定义为\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\lVert \\delta x(t) \\rVert}{\\lVert \\delta x(0) \\rVert},\n$$\n其中 $\\delta x(t)$ 根据变分（切线）方程演化\n$$\n\\frac{d}{dt}\\delta x = J(x(t))\\,\\delta x,\n$$\n其中 $J(x)$ 是沿轨迹 $x(t)$ 求值的矢量场的雅可比矩阵。\n\n您的程序必须：\n- 实现固定步长的显式 Runge-Kutta 积分器，以采用阶段一致 (stage-consistent) 的方式同时演化状态 $x(t)$ 和切向量 $\\delta x(t)$。具体来说，实现经典的 2 阶中点法（记为 $\\mathrm{RK2}$）和经典的 4 阶方法（记为 $\\mathrm{RK4}$）。\n- 在固定时间范围 $T = 20$ 内估计有限时间最大李雅普诺夫指数，方法是在每一步重复地对切向量进行归一化。对于步长为 $h$ 且总步数为 $N = T/h$ 的情况，估计量为\n$$\n\\hat{\\lambda}(h) = \\frac{1}{T} \\sum_{k=1}^{N} \\ln \\left( \\frac{\\lVert \\delta x_{k} \\rVert}{\\lVert \\delta x_{k-1} \\rVert} \\right),\n$$\n在每一步之后执行归一化操作 $\\delta x_{k} \\leftarrow \\delta x_{k} / \\lVert \\delta x_{k} \\rVert$。使用单位范数的 $\\delta x(0)$ 初始化切向量。\n- 构建一个高保真度的参考解，方法是使用 $\\mathrm{RK4}$ 方法和一个很小的固定步长 $h_{\\mathrm{ref}} = 2 \\times 10^{-4}$ 在相同的时间范围 $T = 20$ 内对同一系统和变分方程进行积分。用此结果计算参考指数 $\\lambda_{\\mathrm{ref}}$ 和一个密集的参考轨迹 $x_{\\mathrm{ref}}(t)$。\n- 对于每个数值实验，评估相对于参考轨迹的影随情况，定义如下。对于容差 $\\varepsilon = 0.1$，将影随时间 $\\tau(\\varepsilon)$ 定义为所有时间 $t \\in [0, T]$ 的上确界，使得对于所有 $s \\in [0, t]$，\n$$\n\\lVert x_{\\mathrm{num}}(s) - x_{\\mathrm{ref}}(s) \\rVert \\le \\varepsilon.\n$$\n在实践中，通过在数值解的离散时间点上检查该不等式，并将 $x_{\\mathrm{ref}}(t)$ 线性插值到这些时间点来近似该值；将 $\\tau(\\varepsilon)$ 定义为不等式首次被违反的时间（如果从未违反，则为 $T$）。\n- 通过绝对误差 $|\\hat{\\lambda}(h) - \\lambda_{\\mathrm{ref}}|$ 来量化精度。\n\n您的程序必须运行以下所有测试用例，每个用例由积分器方法和步长 $h$ 指定，使用的时间范围为 $T = 20$：\n1. ($\\mathrm{RK4}$, $h = 0.01$)，\n2. ($\\mathrm{RK4}$, $h = 0.005$)，\n3. ($\\mathrm{RK2}$, $h = 0.01$)，\n4. ($\\mathrm{RK2}$, $h = 0.005$)，\n5. ($\\mathrm{RK4}$, $h = 0.05$)。\n\n对于每个测试用例，计算并返回一个三元组，包含：\n- 估计的最大李雅普诺夫指数 $\\hat{\\lambda}(h)$，单位为逆时间单位，\n- 绝对误差 $|\\hat{\\lambda}(h) - \\lambda_{\\mathrm{ref}}|$，单位为逆时间单位，\n- 影随时间 $\\tau(\\varepsilon)$，时间单位与 $T$ 相同。\n\n此处所有量均为无量纲；不要附加物理单位，如米或秒。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例按上述顺序贡献一个子列表，每个子列表的格式为 $[\\hat{\\lambda},\\mathrm{error},\\tau]$。例如，最终输出格式必须是\n$$\n[\\,[\\hat{\\lambda}_1,\\mathrm{error}_1,\\tau_1],\\ldots,[\\hat{\\lambda}_5,\\mathrm{error}_5,\\tau_5]\\,].\n$$\n\n该实验必须科学上真实且自洽，并且您必须从上述定义开始构建所有推导，不得使用绕过混沌系统中关于对初始条件敏感依赖的核心推理的简化公式。测试套件涵盖了正常操作、更精细的步长、低阶积分效应，以及可能降低精度和影随行为的粗步长边缘情况。所有输出都必须是浮点数。",
            "solution": "用户要求进行一个数值实验，以评估不同数值积分器和步长在计算 Lorenz 系统的最大李雅普诺夫指数和影随时间方面的性能。该解决方案的制定过程是首先建立数学和算法框架，然后实现它来处理指定的测试用例。\n\n### 数学和算法构建\n\n问题的核心是 Lorenz 系统，这是一组描述大气对流简化模型的三个耦合非线性常微分方程（ODE）。系统在时间 $t$ 的状态由向量 $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$ 给出。运动方程为：\n$$\n\\frac{d\\mathbf{x}}{dt} = F(\\mathbf{x}) =\n\\begin{bmatrix}\n\\sigma (y - x) \\\\\nx (\\rho - z) - y \\\\\nx y - \\beta z\n\\end{bmatrix}\n$$\n参数设置为其经典的混沌值：$(\\sigma, \\rho, \\beta) = (10, 28, 8/3)$。初始条件为 $\\mathbf{x}(0) = [1, 1, 1]^T$。\n\n为了计算最大李雅普诺夫指数，我们必须追踪切空间中一个无穷小分离向量的演化，记为 $\\mathbf{v}(t) = \\delta \\mathbf{x}(t)$。其动力学由线性变分方程决定：\n$$\n\\frac{d\\mathbf{v}}{dt} = J(\\mathbf{x}(t)) \\mathbf{v}(t)\n$$\n其中 $J(\\mathbf{x})$ 是矢量场 $F(\\mathbf{x})$ 的雅可比矩阵，沿轨迹 $\\mathbf{x}(t)$ 进行求值。雅可比矩阵为：\n$$\nJ(\\mathbf{x}) = \\frac{\\partial F}{\\partial \\mathbf{x}} = \\begin{bmatrix}\n-\\sigma   \\sigma   0 \\\\\n\\rho-z   -1   -x \\\\\ny   x   -\\beta\n\\end{bmatrix}\n$$\n为了进行数值积分，我们将状态向量和切向量组合成一个单一的 $6$ 维状态向量 $Y(t) = [\\mathbf{x}(t)^T, \\mathbf{v}(t)^T]^T$。完整的 ODE 系统是：\n$$\n\\frac{dY}{dt} =\n\\begin{bmatrix}\nF(\\mathbf{x}(t)) \\\\\nJ(\\mathbf{x}(t))\\mathbf{v}(t)\n\\end{bmatrix}\n$$\n这个增广系统使用两种显式 Runge-Kutta 方法进行数值积分：2 阶中点法（$\\mathrm{RK2}$）和经典的 4 阶方法（$\\mathrm{RK4}$）。将积分器应用于此 6D 系统可确保状态 $\\mathbf{x}$ 和切向量 $\\mathbf{v}$ 的演化是以阶段一致的方式计算的，这意味着雅可比矩阵 $J$ 是在 Runge-Kutta 公式所要求的适当中间阶段进行求值的。\n\n### 最大李雅普诺夫指数估计\n\n最大李雅普诺夫指数 $\\lambda_{\\max}$ 量化了邻近轨迹发散的平均指数率。它是在一个有限的时间范围 $T$ 内进行估计的。对切向量 $\\mathbf{v}(t)$ 进行朴素的积分会因其指数级增长而导致数值溢出。为防止这种情况，切向量被周期性地重新归一化。算法流程如下：\n1. 将切向量 $\\mathbf{v}_0$ 初始化为一个单位向量，例如 $\\mathbf{v}_0 = [1, 0, 0]^T$。\n2. 对于每个积分步骤 $k=1, \\dots, N$，其中 $N=T/h$：\n   a. 将增广系统 $Y_{k-1} = [\\mathbf{x}_{k-1}^T, \\mathbf{v}_{k-1}^T]^T$ 向前推进一个步长 $h$，得到一个临时的下一个状态 $Y'_k = [(\\mathbf{x}'_k)^T, (\\mathbf{v}'_k)^T]^T$。\n   b. 更新状态向量：$\\mathbf{x}_k = \\mathbf{x}'_k$。\n   c. 计算未归一化的切向量的范数 $d_k = \\lVert \\mathbf{v}'_k \\rVert$。这代表了在区间 $[t_{k-1}, t_k]$ 上的局部拉伸因子。\n   d. 将该因子的对数添加到一个运行总和中。\n   e. 为下一步重新归一化切向量：$\\mathbf{v}_k = \\mathbf{v}'_k / d_k$。\n3. 有限时间最大李雅普诺夫指数的估计值 $\\hat{\\lambda}(h)$ 是对数增长因子的时间平均和：\n$$\n\\hat{\\lambda}(h) = \\frac{1}{T} \\sum_{k=1}^{N} \\ln(d_k)\n$$\n\n### 参考解与误差分析\n\n为了评估数值结果的准确性，需要生成一个高保真度的参考解。这涉及到使用 $\\mathrm{RK4}$ 方法和一个非常小的步长 $h_{\\mathrm{ref}} = 2 \\times 10^{-4}$，在时间范围 $T=20$ 内对增广系统进行积分，以计算参考指数 $\\lambda_{\\mathrm{ref}}$ 和参考轨迹 $\\mathbf{x}_{\\mathrm{ref}}(t)$。\n\n计算出的指数 $\\hat{\\lambda}(h)$ 的精度由绝对误差 $|\\hat{\\lambda}(h) - \\lambda_{\\mathrm{ref}}|$ 来量化。\n\n影随的概念解决的是一个数值轨迹，尽管它会偏离具有相同初始条件的真实轨迹，但它是否仍然接近于*某个*真实轨迹。我们通过测量数值轨迹 $\\mathbf{x}_{\\mathrm{num}}(t)$ 在参考轨迹 $\\mathbf{x}_{\\mathrm{ref}}(t)$ 周围一个半径为 $\\varepsilon$ 的小管内停留多长时间来近似这一点。影随时间 $\\tau(\\varepsilon)$ 定义为欧几里得距离超过给定容差 $\\varepsilon = 0.1$ 的第一个时间点 $t_k = k \\cdot h$：\n$$\n\\tau(\\varepsilon) = \\min \\{ t_k \\mid \\lVert \\mathbf{x}_{\\mathrm{num}}(t_k) - \\mathbf{x}_{\\mathrm{ref}}(t_k) \\rVert  \\varepsilon \\}\n$$\n如果在区间 $[0, T]$ 内距离从未超过 $\\varepsilon$，则 $\\tau(\\varepsilon) = T$。为了进行此比较，将密集的参考轨迹 $\\mathbf{x}_{\\mathrm{ref}}(t)$ 线性插值到数值轨迹 $\\mathbf{x}_{\\mathrm{num}}$ 的离散时间点 $t_k$ 上。\n\n### 实现细节\n\n解决方案以 Python 程序的形式提供，其结构如下：\n1. 一个函数 `lorenz_augmented_deriv` 用于计算 6D 增广状态向量 $Y$ 的导数。\n2. 函数 `rk2_step` 和 `rk4_step` 分别实现对应的 Runge-Kutta 积分步骤。\n3. 一个主函数 `run_simulation` 负责在整个时间范围 $T$ 内协调积分过程，执行切向量的逐次归一化，并累积计算李雅普诺夫指数所需的数据。它返回估计的指数和计算出的轨迹。\n4. 一个辅助函数 `calculate_shadowing_time` 通过插值参考轨迹并找到第一个违反点来计算 $\\tau(\\varepsilon)$。\n5. 主 `solve` 代码块首先生成参考解。然后，它遍历五个指定的测试用例，为每个用例调用 `run_simulation`，计算误差和影随时间，并收集结果。最后，它以指定的格式打印收集到的数据。所有计算均使用标准的双精度浮点运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Problem-defined constants and parameters\nSIGMA = 10.0\nRHO = 28.0\nBETA = 8.0 / 3.0\nT_HORIZON = 20.0\nEPSILON = 0.1\nH_REF = 2e-4\nX0 = np.array([1.0, 1.0, 1.0])\nV0 = np.array([1.0, 0.0, 0.0])  # Initial tangent vector, must be unit norm\n\ndef lorenz_augmented_deriv(t, y):\n    \"\"\"\n    Computes the derivative of the augmented 6D Lorenz system.\n    y = [x, y, z, vx, vy, vz]\n    \"\"\"\n    state = y[:3]\n    tangent = y[3:]\n    x, y_coord, z = state[0], state[1], state[2]\n\n    # State dynamics (F(x))\n    d_state = np.array([\n        SIGMA * (y_coord - x),\n        x * (RHO - z) - y_coord,\n        x * y_coord - BETA * z\n    ])\n\n    # Variational dynamics (J(x) * v)\n    jacobian = np.array([\n        [-SIGMA, SIGMA, 0.0],\n        [RHO - z, -1.0, -x],\n        [y_coord, x, -BETA]\n    ])\n    d_tangent = jacobian @ tangent\n\n    return np.concatenate((d_state, d_tangent))\n\ndef rk2_step(f, t, y, h):\n    \"\"\"Classical Runge-Kutta 2nd order (midpoint) step.\"\"\"\n    k1 = h * f(t, y)\n    k2 = h * f(t + h / 2.0, y + k1 / 2.0)\n    return y + k2\n\ndef rk4_step(f, t, y, h):\n    \"\"\"Classical Runge-Kutta 4th order step.\"\"\"\n    k1 = h * f(t, y)\n    k2 = h * f(t + h / 2.0, y + k1 / 2.0)\n    k3 = h * f(t + h / 2.0, y + k2 / 2.0)\n    k4 = h * f(t + h, y + k3)\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n\ndef run_simulation(method_str, h):\n    \"\"\"\n    Integrates the Lorenz system and computes the maximal Lyapunov exponent.\n    \"\"\"\n    if method_str == 'RK2':\n        step_func = rk2_step\n    elif method_str == 'RK4':\n        step_func = rk4_step\n    else:\n        raise ValueError(f\"Unknown integration method: {method_str}\")\n\n    n_steps = int(round(T_HORIZON / h))\n    # Using a fixed number of steps can slightly alter h, ensuring endpoint is T\n    h_actual = T_HORIZON / n_steps\n    \n    times = np.linspace(0.0, T_HORIZON, n_steps + 1)\n    \n    y_current = np.concatenate((X0, V0))\n    trajectory = [X0]\n    log_sum = 0.0\n    \n    for i in range(n_steps):\n        t_current = i * h_actual\n        # Note: the problem description uses a simplified LLE estimator formula\n        # that implies re-normalization at each step, based on the previous step's\n        # normalized vector. This requires using the un-normalized result from\n        # the previous step to calculate the stretch. A more common approach is\n        # to accumulate logs of norms after each step.\n        # Let's re-implement according to the problem formula for exactness.\n        \n        # y_current has a normalized tangent vector from the previous step.\n        y_next_unnorm = step_func(lorenz_augmented_deriv, t_current, y_current, h_actual)\n        \n        x_next = y_next_unnorm[:3]\n        v_next_unnorm = y_next_unnorm[3:]\n        \n        # The ratio is between the new unnormalized length and the old one (which was 1)\n        norm_v = np.linalg.norm(v_next_unnorm)\n        \n        # Add log of the stretching factor.\n        if norm_v > 0:\n            log_sum += np.log(norm_v)\n        \n        # Renormalize the tangent vector for the next step.\n        v_next_norm = v_next_unnorm / norm_v if norm_v > 0 else v_next_unnorm\n        \n        y_current = np.concatenate((x_next, v_next_norm))\n        trajectory.append(x_next)\n        \n    lambda_est = log_sum / T_HORIZON\n    \n    return lambda_est, times, np.array(trajectory)\n\ndef calculate_shadowing_time(num_times, num_traj, ref_times, ref_traj):\n    \"\"\"\n    Calculates the shadowing time of a numerical trajectory against a reference.\n    \"\"\"\n    # Linearly interpolate the reference trajectory to the numerical time points.\n    ref_x_interp = np.interp(num_times, ref_times, ref_traj[:, 0])\n    ref_y_interp = np.interp(num_times, ref_times, ref_traj[:, 1])\n    ref_z_interp = np.interp(num_times, ref_times, ref_traj[:, 2])\n    \n    ref_traj_interp = np.vstack((ref_x_interp, ref_y_interp, ref_z_interp)).T\n    \n    # Calculate the Euclidean distance at each time point.\n    distances = np.linalg.norm(num_traj - ref_traj_interp, axis=1)\n    \n    # Find the first index where distance > EPSILON.\n    # We search from index 1, since distance at index 0 (t=0) is 0.\n    violation_indices = np.where(distances[1:] > EPSILON)[0]\n    \n    if len(violation_indices) > 0:\n        # Get the time corresponding to the first violation.\n        # Add 1 to index to account for slicing from index 1.\n        first_violation_index = violation_indices[0] + 1\n        shadow_time = num_times[first_violation_index]\n    else:\n        # If the tolerance is never exceeded, shadowing time is the full horizon.\n        shadow_time = T_HORIZON\n        \n    return shadow_time\n\ndef solve():\n    \"\"\"\n    Main function to run the experiment and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('RK4', 0.01),\n        ('RK4', 0.005),\n        ('RK2', 0.01),\n        ('RK2', 0.005),\n        ('RK4', 0.05)\n    ]\n\n    # 1. Generate high-fidelity reference solution\n    lambda_ref, t_ref, traj_ref = run_simulation('RK4', H_REF)\n\n    # 2. Run all test cases and compute metrics\n    results = []\n    for method, h in test_cases:\n        # Run simulation for the current test case\n        lambda_hat, t_num, traj_num = run_simulation(method, h)\n        \n        # Calculate absolute error in Lyapunov exponent\n        error = np.abs(lambda_hat - lambda_ref)\n        \n        # Calculate shadowing time\n        shadow_time = calculate_shadowing_time(t_num, traj_num, t_ref, traj_ref)\n        \n        # Store the triplet of results\n        results.append([lambda_hat, error, shadow_time])\n\n    # 3. Final print statement in the exact required format.\n    # The str() representation of a Python list includes spaces, and joining\n    # them with a comma and enclosing in brackets matches the example format.\n    # The problem asks for float outputs.\n    formatted_results = []\n    for res in results:\n        formatted_results.append(f\"[{res[0]:.7f}, {res[1]:.7f}, {res[2]:.7f}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}