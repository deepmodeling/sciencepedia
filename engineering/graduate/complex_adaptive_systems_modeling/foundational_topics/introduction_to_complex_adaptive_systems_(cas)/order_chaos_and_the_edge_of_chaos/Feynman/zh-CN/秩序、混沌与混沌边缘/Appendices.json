{
    "hands_on_practices": [
        {
            "introduction": "混沌系统的一个核心特征是对初始条件的敏感依赖性，这使得长期预测变得不可能。然而，我们可以量化这种不可预测性。本练习将探讨如何使用最大李雅普诺夫指数（LLE）——衡量轨道发散速率的关键指标——来估算一个系统的“可预测性视界”，即我们能在多长时间内相信其预测的有效性 。这个实践将理论概念与实际限制直接联系起来。",
            "id": "4135136",
            "problem": "考虑一个具有自适应相互作用的高维基于主体的生态网络，其中宏观可观测量被粗粒化为一维有效流。该系统在混沌边缘运行，其最大李雅普诺夫指数 (LLE) 为正但不大，表明其对初始条件具有敏感依赖性，但又并非完全无序。该有效粗粒化流的最大李雅普诺夫指数 $\\lambda$ 定义为\n$$\n\\lambda \\equiv \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|},\n$$\n其中轨道在状态空间中以无穷小分离 $\\delta \\mathbf{x}(0)$ 开始，并遵循相同的动力学演化。假设分离动力学足够平滑，对于足够小的不确定性 $\\delta_0 \\equiv \\|\\delta \\mathbf{x}(0)\\|$，分离幅度以速率 $\\lambda$ 近似指数增长，直到在粗粒化可观测量中达到一个可容忍的宏观误差阈值 $\\Delta$。\n\n从上述定义和由最大李雅普诺夫指数主导的误差指数增长假设出发，推导可预测性时间跨度 $T$（即初始不确定性 $\\delta_0$ 达到阈值 $\\Delta$ 的时间）的表达式，然后为以下情景计算 $T$ 的值：\n- 测得的最大李雅普诺夫指数为 $\\lambda = 0.35$ $\\text{min}^{-1}$。\n- 初始不确定性为 $\\delta_0 = 2.5 \\times 10^{-6}$（以所选的状态空间单位计）。\n- 可容忍的宏观误差为 $\\Delta = 5.0 \\times 10^{-3}$（以相同的状态空间单位计）。\n\n以分钟为单位表示 $T$ 的最终答案，并将数值结果四舍五入到四位有效数字。",
            "solution": "该问题要求为一个表现出混沌动力学的系统推导可预测性时间跨度 $T$ 的表达式，并根据给定的特定参数计算其值。分析从最大李雅普诺夫指数 (LLE) $\\lambda$ 的定义开始，该指数用于量化状态空间中相邻轨道的平均指数发散率。\n\nLLE 的正式定义如下：\n$$\n\\lambda \\equiv \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|}\n$$\n其中 $\\|\\delta \\mathbf{x}(t)\\|$ 是两条无穷近轨道在时间 $t$ 的分离幅度，而 $\\|\\delta \\mathbf{x}(0)\\|$ 是它们的初始分离。\n\n问题指出，对于足够小的初始分离，该分离的演化可以近似为速率为 $\\lambda$ 的纯指数增长。令初始不确定性表示为 $\\delta_0 \\equiv \\|\\delta \\mathbf{x}(0)\\|$。在稍后时间 $t$ 的分离可以表示为：\n$$\n\\|\\delta \\mathbf{x}(t)\\| \\approx \\delta_0 \\exp(\\lambda t)\n$$\n该方程描述了在一个混沌系统中，一个微小的初始误差是如何随时间增长的。\n\n可预测性时间跨度 $T$ 定义为初始不确定性 $\\delta_0$ 增长到指定的可容忍宏观误差阈值 $\\Delta$ 所需的时间。为了推导 $T$ 的表达式，我们将时间 $T$ 时的分离设为等于阈值 $\\Delta$：\n$$\n\\|\\delta \\mathbf{x}(T)\\| = \\Delta\n$$\n将此代入我们的指数增长模型，我们得到：\n$$\n\\Delta = \\delta_0 \\exp(\\lambda T)\n$$\n我们的目标是解出该方程中的 $T$。我们首先通过将方程两边同时除以 $\\delta_0$（其不为零）来分离出指数项：\n$$\n\\frac{\\Delta}{\\delta_0} = \\exp(\\lambda T)\n$$\n为了解出指数 $\\lambda T$，我们对等式两边取自然对数 ($\\ln$)。自然对数是指数函数的反函数，即 $\\ln(\\exp(x)) = x$。\n$$\n\\ln\\left(\\frac{\\Delta}{\\delta_0}\\right) = \\ln(\\exp(\\lambda T))\n$$\n$$\n\\ln\\left(\\frac{\\Delta}{\\delta_0}\\right) = \\lambda T\n$$\n最后，通过除以最大李雅普诺夫指数 $\\lambda$（已知为正值），我们得到可预测性时间跨度 $T$ 的通用表达式：\n$$\nT = \\frac{1}{\\lambda} \\ln\\left(\\frac{\\Delta}{\\delta_0}\\right)\n$$\n这个推导出的公式给出了在一个以 $\\lambda$ 的 LLE 为特征的系统中，初始误差增长因子 $\\frac{\\Delta}{\\delta_0}$ 所需的时间。\n\n接下来，我们必须为所提供的具体情景计算 $T$ 的数值：\n- 最大李雅普诺夫指数：$\\lambda = 0.35 \\, \\text{min}^{-1}$\n- 初始不确定性：$\\delta_0 = 2.5 \\times 10^{-6}$\n- 可容忍的宏观误差：$\\Delta = 5.0 \\times 10^{-3}$\n\n$\\delta_0$ 和 $\\Delta$ 的单位相同，所以它们的比率将是一个无量纲的量。首先，我们计算这个比率：\n$$\n\\frac{\\Delta}{\\delta_0} = \\frac{5.0 \\times 10^{-3}}{2.5 \\times 10^{-6}} = \\frac{5.0}{2.5} \\times 10^{-3 - (-6)} = 2.0 \\times 10^{3} = 2000\n$$\n现在，我们将这个比率和 $\\lambda$ 的值代入我们关于 $T$ 的表达式中：\n$$\nT = \\frac{1}{0.35} \\ln(2000)\n$$\n$\\lambda$ 的单位是 $\\text{min}^{-1}$，所以 $T = 1/\\lambda$ 的单位将是分钟，这与问题的要求一致。我们现在对表达式进行数值计算：\n$$\n\\ln(2000) \\approx 7.60090246\n$$\n$$\nT \\approx \\frac{7.60090246}{0.35} \\, \\text{min} \\approx 21.71686417 \\, \\text{min}\n$$\n问题明确要求最终答案需四舍五入到四位有效数字。应用此舍入规则，我们得到：\n$$\nT \\approx 21.72 \\, \\text{min}\n$$\n这就是指定系统的可预测性时间跨度。",
            "answer": "$$\n\\boxed{21.72}\n$$"
        },
        {
            "introduction": "系统如何从有序转变为混沌？本练习通过研究随机布尔网络（RBNs）——一种用于模拟复杂自适应系统的通用模型——来探讨这一根本问题。您将推导出临界连接度 $K_c$，它定义了分隔有序（“冻结”）和混沌相的“混沌边缘” 。这个练习阐明了网络结构（由 $K$ 体现）如何控制系统宏观动力学行为的出现。",
            "id": "4135187",
            "problem": "考虑一个具有$N$个节点并同步更新的随机布尔网络（RBN）。在每个离散时间$t \\in \\mathbb{N}$，每个节点都从$N$个节点中均匀随机地选择$K$个输入，并且其布尔更新函数是从一个带有偏置$p \\in (0,1)$的系综中独立抽取的：对于任何$K$比特的输入，其输出为$1$的概率为$p$，输出为$0$的概率为$1-p$。采用退火近似，即在每个时间步，输入选择和布尔函数都从保持$K$和$p$不变的同一系综中独立地重新采样。\n\n设 $h_t \\in [0,1]$ 表示网络的两个副本之间的期望汉明距离（HD），即状态不同的节点所占的比例。这两个副本的初始条件仅在占比为无穷小的 $h_0 \\ll 1$ 的节点上有所不同。在$h_t$的一阶上，通过计算一个系综随机布尔函数对单个输入翻转的期望灵敏度，导出$h_{t+1}$关于$h_t$、$K$和$p$的线性化递推关系。使用这个递推关系，确定临界入度$K_c(p)$。在此临界值，一个无穷小的扰动平均而言既不收缩也不扩张，这定义了混沌边缘。\n\n请用一个关于$p$的简化解析表达式给出你的最终答案。\n\n在你的推导中，请明确陈述你所引用的概率假设，并证明在$h_t \\to 0$的极限下线性化的合理性。然后，简要地定性解释在退火近似下，$K  K_c(p)$、$K = K_c(p)$和$K > K_c(p)$这几种情况如何分别对应于冻结相、临界相和混沌相。你的最终答案必须仅为$K_c(p)$的表达式（不需要单位）。",
            "solution": "该问题要求在退火近似下，推导随机布尔网络（RBN）的临界入度$K_c(p)$。这个临界值区分了有序和混沌的动力学区域。推导过程通过分析一个小扰动在网络中的传播来进行。\n\n设$h_t$为在离散时间步$t$时，网络两个副本之间的期望汉明距离。对于一个有$N$个节点的大型网络，$h_t$可以解释为一个随机选择的节点在两个网络副本中状态不同的概率，这两个副本的初始条件只有无穷小比例$h_0 \\ll 1$的节点不同。我们的目标是推导出映射$h_t \\mapsto h_{t+1}$。\n\n考虑在时间$t+1$时的一个任意节点$i$。其状态$S_i(t+1)$由一个布尔函数$f_i$决定，该函数作用于其$K$个输入在时间$t$时的状态。设这两个网络副本用上标$A$和$B$表示。因此，我们有：\n$$S_i^A(t+1) = f_i(S_{j_1}^A(t), S_{j_2}^A(t), \\dots, S_{j_K}^A(t))$$\n$$S_i^B(t+1) = f_i(S_{j_1}^B(t), S_{j_2}^B(t), \\dots, S_{j_K}^B(t))$$\n$h_{t+1}$是在所有节点和网络系综的所有实现上平均后，$S_i^A(t+1) \\neq S_i^B(t+1)$的概率。由于退火近似，即输入连接$\\{j_1, \\dots, j_K\\}$和布尔函数$f_i$在每个时间步都重新随机抽取，因此这个概率对于所有节点都是相同的。\n\n只有当节点$i$在两个副本中接收到的输入向量不同，并且函数$f_i$对这个差异敏感时，在时间$t+1$时节点$i$才可能出现差异，即$S_i^A(t+1) \\neq S_i^B(t+1)$。根据定义，任何单个输入节点$j_k$在两个副本中状态不同的概率是$h_t$。由于$K$个输入是从$N$个节点中均匀随机选择的，我们可以将这$K$个输入的状态视为$K$次独立的伯努利试验，其中“成功”指的是状态不同，其概率为$h_t$。\n\n问题要求我们在$h_t$的一阶上进行计算，其合理性在于初始条件$h_0 \\ll 1$以及我们假设系统处于临界点附近，此时$h_t$保持很小。设$m$为节点$i$的$K$个输入中状态不同的输入的数量。有$m$个不同输入的概率服从二项分布：\n$$P(m) = \\binom{K}{m} h_t^m (1-h_t)^{K-m}$$\n对于$h_t \\to 0$，我们可以将其展开到一阶：\n-   $P(m=0) = (1-h_t)^K \\approx 1 - K h_t$。如果没有不同的输入，输出也将相同，因此在节点$i$处不会产生新的差异。\n-   $P(m=1) = K h_t (1-h_t)^{K-1} \\approx K h_t$。这是恰好有一个输入不同的事件。\n-   $P(m \\ge 2) = \\sum_{j=2}^K \\binom{K}{j} h_t^j (1-h_t)^{K-j} = O(h_t^2)$。在一阶（线性）近似中，这些项可以忽略不计。\n\n因此，对于$h_t \\ll 1$，只有当节点$i$的输入在两个副本之间恰好有一个不同时，才会在该节点有效地产生新的差异。这种情况发生的概率约为$K h_t$。\n\n接下来，我们必须计算在恰好一个输入翻转的情况下，函数输出也翻转的概率。这就是布尔函数的平均灵敏度。设输入向量为$\\vec{x}$和$\\vec{x}'$，它们仅在单个比特上不同。我们想求出概率$s = P(f(\\vec{x}) \\neq f(\\vec{x}'))$。\n布尔函数$f$是从一个系综中抽取的，对于任何$K$比特输入，其输出为$1$的概率为$p$，为$0$的概率为$1-p$。关键在于，对于不同的输入向量，其输出是独立的随机变量。因此，$f(\\vec{x})$和$f(\\vec{x}')$是成功概率为$p$的独立伯努利试验。\n事件$f(\\vec{x}) \\neq f(\\vec{x}')$可以通过两种互斥的方式发生：\n1.  $f(\\vec{x}) = 1$ 且 $f(\\vec{x}') = 0$。其概率为 $P(f(\\vec{x})=1)P(f(\\vec{x}')=0) = p(1-p)$。\n2.  $f(\\vec{x}) = 0$ 且 $f(\\vec{x}') = 1$。其概率为 $P(f(\\vec{x})=0)P(f(\\vec{x}')=1) = (1-p)p$。\n\n总概率，即灵敏度$s$，是这些概率之和：\n$$s = p(1-p) + (1-p)p = 2p(1-p)$$\n这个量$s$是单个输入翻转导致输出翻转的概率。\n\n现在，我们可以写出$h_{t+1}$的表达式。它等于恰好有一个不同输入的概率乘以这个单一差异通过函数传播的概率：\n$$h_{t+1} = P(m=1) \\times s + O(h_t^2)$$\n代入$P(m=1)$和$s$的表达式，我们得到线性化的递推关系：\n$$h_{t+1} \\approx (K h_t) \\times (2p(1-p))$$\n$$h_{t+1} = [2Kp(1-p)] h_t$$\n这个线性映射描述了小扰动的演化。因子$\\lambda = 2Kp(1-p)$决定了系统的稳定性。\n\n“混沌边缘”是小扰动平均而言既不扩张也不收缩的临界边界。这对应于线性映射是中性的情况，即$h_{t+1} = h_t$。这意味着乘数$\\lambda$必须等于$1$。临界入度$K_c(p)$是满足此条件的$K$的值：\n$$2K_c(p)p(1-p) = 1$$\n求解$K_c(p)$，我们得到：\n$$K_c(p) = \\frac{1}{2p(1-p)}$$\n\n基于这个结果，我们可以简要解释三种动力学区域：\n-   **有序相 ($K  K_c(p)$):** 在此情况下，$\\lambda = 2Kp(1-p)  1$。映射$h_{t+1} = \\lambda h_t$是一个收缩。任何小扰动$h_0$都将指数衰减到$0$。轨迹之间的差异会消失，导致稳定、可预测的动力学。这也称为冻结相。\n-   **混沌相 ($K > K_c(p)$):** 在此情况下，$\\lambda = 2Kp(1-p) > 1$。该映射是一个扩张。任何无穷小的扰动都将指数增长（直到线性近似失效）。这表示对初始条件的敏感依赖性，这是混沌的标志。\n-   **临界相 ($K = K_c(p)$):** 在此情况下，$\\lambda = 1$。小扰动平均而言是守恒的。系统处于“混沌边缘”，能够在长距离上传播信息而信息既不消失也不爆炸，这种状态通常与复杂计算和适应性相关联。\n\n问题要求给出$K_c(p)$的单一简化解析表达式。",
            "answer": "$$\\boxed{\\frac{1}{2p(1-p)}}$$"
        },
        {
            "introduction": "理论模型预测了有序、混沌和混沌边缘系统在统计特性上的差异，例如相关性的衰减方式。本计算练习旨在通过经验验证这些差异 。您将编写代码来模拟三种典型的动力学映射，并分析其时间序列，从而亲眼见证强混沌系统中的指数衰减与临界系统中的代数衰减之间的鲜明对比。",
            "id": "4135139",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，用于经验性地评估在复杂自适应系统建模中具有典范意义的离散时间一维映射的相关性衰减。科学目标是估计相关函数 $$C(n) = \\mathbb{E}\\left[g(x_{k+n}) h(x_k)\\right] - \\mathbb{E}[g] \\,\\mathbb{E}[h],$$ 将其衰减解释为指数衰减或代数衰减，并就与有序、混沌和混沌边缘相关的混合性质得出结论。数学期望是相对于映射的不变测度来计算的，而计算估计必须依赖于由 Glivenko–Cantelli 原理和 Birkhoff 遍历定理证明的时间平均。您的程序必须实现以下要求。\n\n推导的基本依据：\n- 使用由确定性映射 $T$ 驱动的平稳离散时间过程 $\\{x_k\\}_{k \\ge 0}$ 的相关函数 $C(n)$ 的定义，其中 $x_{k+1} = T(x_k)$ 且 $\\mathbb{E}[\\cdot]$ 表示关于 $T$ 的一个不变遍历测度 $\\mu$ 的期望。\n- 使用 Birkhoff 遍历定理，该定理指出对于 $\\mu$-可积的 $f$，对于 $\\mu$-几乎所有的初始条件，都有 $$\\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{k=0}^{N-1} f(x_k) = \\int f \\, d\\mu,$$。这为使用长轨迹的时间平均替代系综期望提供了依据。\n\n定义：\n- 如果对于零均值的可积观测量 $g$ 和 $h$，有 $$\\lim_{n \\to \\infty} C(n) = 0;$$，则映射 $T$ 是混合的。强混合通常意味着指数速率，而中性不动点附近的间歇性可能导致代数速率。\n- 指数衰减对应于经验拟合 $$|C(n)| \\approx A \\exp(-\\lambda n)$$，其中 $A  0$ 且 $\\lambda  0$；而代数衰减对应于 $$|C(n)| \\approx B n^{-\\beta}$$，其中 $B  0$ 且 $\\beta  0$。\n\n您的程序必须：\n1. 对每个指定的映射 $T$，使用规定的初始条件策略和必要的预烧（burn-in）长度，生成一条长轨迹 $\\{x_k\\}$，然后通过对长度为 $N$ 的轨迹段进行时间平均来计算经验均值和相关性。\n2. 对所有测试用例，使用观测量 $g(x) = x$ 和 $h(x) = \\cos(2\\pi x)$。\n3. 对每个映射，计算时滞 $n = 1, 2, \\dots, n_{\\max}$ 的 $$\\widehat{C}(n) = \\frac{1}{N-n} \\sum_{k=0}^{N-n-1} g(x_{k+n}) \\, h(x_k) - \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} g(x_k)\\right) \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} h(x_k)\\right),$$。\n4. 拟合 $\\log(|\\widehat{C}(n)|)$ 与 $n$ 的关系以检测指数衰减，并拟合 $\\log(|\\widehat{C}(n)|)$ 与 $\\log(n)$ 的关系以检测代数衰减。两种情况都使用线性回归，并使用决定系数 $R^2$ 来评估哪个模型能更好地解释衰减。剔除那些 $|\\widehat{C}(n)|$ 在数值上与零无法区分的点，以避免对数的不稳定性。\n5. 基于回归拟合和斜率符号对衰减类型进行分类，返回：\n   - 如果强力支持指数衰减，则返回 $2$；\n   - 如果强力支持代数衰减，则返回 $1$；\n   - 如果两种拟合都不充分（无混合或不确定），则返回 $0$。\n\n映射和参数化：\n- 映射 A（混沌，扩张）：逻辑斯谛映射 $T(x) = r x (1-x)$，其中 $r = 4$。为从不变测度中抽样而无需预烧，使用共轭关系 $x = \\sin^2(\\pi \\theta)$，其中 $\\theta$ 在初始步骤中均匀分布于 $[0,1)$，然后迭代 $T$ 以生成轨迹。使用 $N = 200000$ 和 $n_{\\max} = 50$。\n- 映射 B（间歇性，混沌边缘）：Pomeau–Manneville 映射 $T(x) = x + x^{1+\\alpha} \\bmod 1$，其中 $\\alpha = 0.5$。使用均匀初始条件 $x_0 \\in [0,1)$，应用 $B = 5000$ 的预烧，然后累积 $N = 200000$ 次迭代来评估相关性，其中 $n_{\\max} = 50$。\n- 映射 C（有序，非混合）：圆周旋转映射 $T(x) = x + \\varphi \\bmod 1$，其中 $\\varphi = (\\sqrt{5}-1)/2$。使用均匀初始条件 $x_0 \\in [0,1)$，应用 $B = 5000$ 的预烧，然后累积 $N = 200000$ 次迭代来评估相关性，其中 $n_{\\max} = 50$。\n\n角度单位和物理单位：\n- 不涉及物理单位。\n- 余弦函数的所有角度均使用弧度，即 $h(x) = \\cos(2\\pi x)$，其中 $2\\pi$ 以弧度为单位。\n\n测试套件：\n- 测试用例 1：映射 A，参数为 $r = 4$, $N = 200000$, $n_{\\max} = 50$。\n- 测试用例 2：映射 B，参数为 $\\alpha = 0.5$, $B = 5000$, $N = 200000$, $n_{\\max} = 50$。\n- 测试用例 3：映射 C，参数为 $\\varphi = (\\sqrt{5}-1)/2$, $B = 5000$, $N = 200000$, $n_{\\max} = 50$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $$[2,1,0],$$。列表中的每个条目对应于上述指定顺序的相应测试用例的分类代码。条目必须是整数，其中 $2$ 表示指数衰减，$1$ 表示代数衰减，$0$ 表示两者都不是。",
            "solution": "所提出的问题是动力系统和复杂自适应系统建模领域中一个明确定义的计算练习。它具有科学依据，内部一致，并要求应用已建立的理论原理和数值方法。其目标是经验性地研究三个典范一维映射的混合性质，每个映射代表一类独特的动力学行为：混沌（逻辑斯谛映射）、混沌边缘的间歇性（Pomeau-Manneville 映射）和有序/准周期性（圆周旋转映射）。验证确认所有必要的数据、定义和程序都已提供，从而可以得到一个唯一且可验证的解。因此，我们可以继续进行推导和实现。\n\n我们的任务是通过分析相关函数 $C(n)$ 的衰减来对这些系统的长期行为进行分类。对于由映射 $T$ 生成的平稳离散时间过程（$x_{k+1} = T(x_k)$），以及两个观测量 $g(x)$ 和 $h(x)$，相关函数定义为：\n$$\nC(n) = \\mathbb{E}\\left[g(x_{k+n}) h(x_k)\\right] - \\mathbb{E}[g] \\, \\mathbb{E}[h]\n$$\n在此，$\\mathbb{E}[\\cdot]$ 表示关于映射不变测度 $\\mu$ 的期望。如果当时间延迟 $n \\to \\infty$ 时 $C(n) \\to 0$，则系统被认为是混合的。这种衰减的速率是系统动力学的一个关键指标。\n\nBirkhoff 遍历定理为我们的计算方法提供了理论依据。它指出，对于一个遍历系统，沿典型轨迹的观测量的时间平均值收敛于系综平均值（即关于不变测度的期望）：\n$$\n\\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{k=0}^{N-1} f(x_k) = \\int f(x) \\, d\\mu(x) = \\mathbb{E}[f]\n$$\n这使我们能够使用长度为 $N$ 的单条长轨迹上的平均值来估计 $C(n)$ 中的期望。相关函数的估计量 $\\widehat{C}(n)$ 由下式给出：\n$$\n\\widehat{C}(n) = \\frac{1}{N-n} \\sum_{k=0}^{N-n-1} g(x_{k+n}) \\, h(x_k) - \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} g(x_k)\\right) \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} h(x_k)\\right)\n$$\n我们为时滞 $n = 1, 2, \\dots, n_{\\max}$ 计算此值。具体的观测量是 $g(x) = x$ 和 $h(x) = \\cos(2\\pi x)$。\n\n衰减的分类基于将计算出的 $|\\widehat{C}(n)|$ 拟合到两个模型：\n1.  **指数衰减**：强混沌、混合系统的特征。模型为 $|\\widehat{C}(n)| \\approx A \\exp(-\\lambda n)$，其中常数 $A, \\lambda  0$。取自然对数使该关系线性化：$\\log(|\\widehat{C}(n)|) \\approx \\log(A) - \\lambda n$。我们对 $\\log(|\\widehat{C}(n)|)$ 与 $n$ 进行线性回归。具有负斜率 ($-\\lambda$) 的良好拟合表明是指数衰减。\n2.  **代数（幂律）衰减**：常在具有间歇性、处于“混沌边缘”的系统中观察到。模型为 $|\\widehat{C}(n)| \\approx B n^{-\\beta}$，其中常数 $B, \\beta  0$。通过两边取对数将其线性化：$\\log(|\\widehat{C}(n)|) \\approx \\log(B) - \\beta \\log(n)$。我们对 $\\log(|\\widehat{C}(n)|)$ 与 $\\log(n)$ 进行线性回归。具有负斜率 ($-\\beta$) 的良好拟合表明是代数衰减。\n\n衰减类型的判定是通过比较两次线性回归的决定系数 $R^2$ 来做出的。较高的 $R^2$ 值（接近 1）表示拟合效果更好。使用一个阈值，如 $R^2  0.9$，以确保拟合具有统计显著性。斜率的符号必须为负，对应于衰减。如果两个模型都不能提供强拟合，或者相关性不衰减，则系统被分类为非混合或不确定。\n\n每个测试用例的计算过程如下：\n\n**步骤 1：轨迹生成**\n对于每个映射，在应用指定的预烧期 $B$ 之后，生成一条长度为 $N=200000$ 的轨迹 $\\{x_k\\}_{k=0}^{N-1}$。区间为 $[0,1)$。\n-   **映射 A (逻辑斯谛)**: $T(x) = 4x(1-x)$。使用共轭关系 $x_0 = \\sin^2(\\pi \\theta)$，其中 $\\theta \\sim U[0,1)$，从不变的反正弦分布中抽取初始条件 $x_0$。不需要预烧。该映射预计是强混合的。\n-   **映射 B (Pomeau-Manneville)**: $T(x) = x + x^{1+\\alpha} \\pmod 1$，其中 $\\alpha = 0.5$。使用一个随机初始条件 $x_0 \\sim U[0,1)$，然后进行 $B=5000$ 次迭代的预烧，让轨迹稳定在吸引子附近。该映射表现出间歇性，预计会呈现代数衰减。\n-   **映射 C (圆周旋转)**: $T(x) = x + \\varphi \\pmod 1$，其中 $\\varphi = (\\sqrt{5}-1)/2$。使用一个随机初始条件 $x_0 \\sim U[0,1)$，然后进行 $B=5000$ 次的预烧。这种无理数旋转是遍历的但不是混合的；相关性预计不会衰减到零。\n\n**步骤 2：相关性计算**\n对于每条轨迹，计算观测量 $g(x_k)=x_k$ 和 $h(x_k) = \\cos(2\\pi x_k)$ 的时间序列。计算它们在整个长度 $N$ 上的均值。然后，对于从 $1$ 到 $n_{\\max}=50$ 的每个时滞 $n$，使用提供的公式计算 $\\widehat{C}(n)$。\n\n**步骤 3：拟合与分类**\n对于计算出的相关性集合 $\\{\\widehat{C}(n)\\}_{n=1}^{n_{\\max}}$：\n-   过滤掉任何 $|\\widehat{C}(n)|$ 在数值上与零无法区分的点，以防止对数计算出错。\n-   对 $\\log(|\\widehat{C}(n)|)$ 与 $n$ 进行线性回归，得到斜率 $s_{exp}$ 和决定系数 $R^2_{exp}$。\n-   对 $\\log(|\\widehat{C}(n)|)$ 与 $\\log(n)$ 进行线性回归，得到斜率 $s_{alg}$ 和决定系数 $R^2_{alg}$。\n-   应用分类逻辑：\n    -   如果 $R^2_{exp}  0.9$ 且 $s_{exp}  0$，并且 $R^2_{exp}  R^2_{alg}$，则分类为指数衰减（代码 $2$）。\n    -   如果 $R^2_{alg}  0.9$ 且 $s_{alg}  0$，并且 $R^2_{alg}  R^2_{exp}$，则分类为代数衰减（代码 $1$）。\n    -   在所有其他情况下（拟合不佳、由 $s \\ge 0$ 证明的相关性不衰减，或存在歧义），分类为不确定（代码 $0$）。\n\n这种结构化的、基于原理的方法确保了对给定映射动力学性质的稳健且可复现的分析，为有序、混沌和混沌边缘之间提供了清晰的经验性区分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"map_type\": \"A\",\n            \"params\": {\"r\": 4.0},\n            \"N\": 200000,\n            \"B\": 0,\n            \"n_max\": 50,\n        },\n        {\n            \"map_type\": \"B\",\n            \"params\": {\"alpha\": 0.5},\n            \"N\": 200000,\n            \"B\": 5000,\n            \"n_max\": 50,\n        },\n        {\n            \"map_type\": \"C\",\n            \"params\": {\"phi\": (np.sqrt(5) - 1) / 2},\n            \"N\": 200000,\n            \"B\": 5000,\n            \"n_max\": 50,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        classification = analyze_map(\n            case[\"map_type\"],\n            case[\"params\"],\n            case[\"N\"],\n            case[\"B\"],\n            case[\"n_max\"],\n        )\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_trajectory(map_type, params, N, B):\n    \"\"\"\n    Generates a time series for a given map.\n    \n    Args:\n        map_type (str): 'A', 'B', or 'C'.\n        params (dict): Dictionary of map parameters.\n        N (int): Length of the trajectory for analysis.\n        B (int): Length of the burn-in period.\n        \n    Returns:\n        np.ndarray: The generated trajectory of length N.\n    \"\"\"\n    x = np.zeros(B + N)\n    \n    # Initial condition\n    if map_type == 'A':\n        # For logistic map r=4, use conjugacy to start on the attractor\n        theta0 = np.random.uniform(0.0, 1.0)\n        x[0] = np.sin(np.pi * theta0)**2\n    else:\n        # Uniform initial condition for other maps\n        x[0] = np.random.uniform(0.0, 1.0)\n\n    # Map definitions\n    if map_type == 'A':\n        r = params['r']\n        def T(val): return r * val * (1.0 - val)\n    elif map_type == 'B':\n        alpha = params['alpha']\n        def T(val): return (val + val**(1.0 + alpha)) % 1.0\n    elif map_type == 'C':\n        phi = params['phi']\n        def T(val): return (val + phi) % 1.0\n    else:\n        raise ValueError(\"Unknown map type\")\n\n    # Iterate map\n    for i in range(B + N - 1):\n        x[i+1] = T(x[i])\n        \n    return x[B:]\n\ndef analyze_map(map_type, params, N, B, n_max):\n    \"\"\"\n    Performs the full correlation analysis for a single map.\n    \n    Args:\n        map_type (str): The map identifier.\n        params (dict): Map-specific parameters.\n        N (int): Trajectory length.\n        B (int): Burn-in length.\n        n_max (int): Maximum lag for correlation.\n\n    Returns:\n        int: Classification code (2 for exponential, 1 for algebraic, 0 for other).\n    \"\"\"\n    \n    # Step 1: Generate trajectory\n    x_series = generate_trajectory(map_type, params, N, B)\n    \n    # Step 2: Compute observables and their means\n    g_series = x_series\n    h_series = np.cos(2.0 * np.pi * x_series)\n    \n    mean_g = np.mean(g_series)\n    mean_h = np.mean(h_series)\n    \n    # Step 3: Compute empirical correlation function C(n)\n    lags = np.arange(1, n_max + 1)\n    correlations = np.zeros_like(lags, dtype=float)\n    \n    for i, n in enumerate(lags):\n        # Estimator for E[g(x_{k+n})h(x_k)]\n        cross_term_est = np.mean(g_series[n:] * h_series[:-n])\n        correlations[i] = cross_term_est - mean_g * mean_h\n\n    # Step 4: Fit decay models\n    abs_corr = np.abs(correlations)\n    \n    # Filter out numerically zero correlations to avoid log(0)\n    valid_indices = abs_corr > np.finfo(float).eps * 10\n    if np.sum(valid_indices)  2: # Need at least 2 points for regression\n        return 0\n\n    lags_fit = lags[valid_indices]\n    abs_corr_fit = abs_corr[valid_indices]\n    log_abs_corr_fit = np.log(abs_corr_fit)\n\n    # --- Exponential fit: log|C(n)| vs n ---\n    try:\n        slope_exp, _, r_exp, _, _ = stats.linregress(lags_fit, log_abs_corr_fit)\n        r2_exp = r_exp**2\n    except ValueError:\n        slope_exp, r2_exp = 0.0, 0.0\n\n    # --- Algebraic fit: log|C(n)| vs log(n) ---\n    try:\n        slope_alg, _, r_alg, _, _ = stats.linregress(np.log(lags_fit), log_abs_corr_fit)\n        r2_alg = r_alg**2\n    except ValueError:\n        slope_alg, r2_alg = 0.0, 0.0\n    \n    # Step 5: Classify based on fits\n    R2_THRESHOLD = 0.90\n    \n    is_exp_good = r2_exp > R2_THRESHOLD and slope_exp  0\n    is_alg_good = r2_alg > R2_THRESHOLD and slope_alg  0\n\n    if is_exp_good and is_alg_good:\n        if r2_exp > r2_alg:\n            return 2  # Exponential\n        else:\n            return 1  # Algebraic\n    elif is_exp_good:\n        return 2  # Exponential\n    elif is_alg_good:\n        return 1  # Algebraic\n    else:\n        return 0  # Undetermined / No decay\n\nsolve()\n```"
        }
    ]
}