{
    "hands_on_practices": [
        {
            "introduction": "混沌系统的一个核心特征是对初始条件的敏感依赖性，这通常通过正的李雅普诺夫指数（$\\lambda \\gt 0$）来量化。本练习将此抽象概念转化为一个具体的、可计算的量：可预测性视界 。你将亲自计算一个初始微小误差增长到可容忍的宏观误差阈值所需的时间，从而深刻体会混沌系统内在的不可预测性。",
            "id": "4135136",
            "problem": "考虑一个具有自适应相互作用的高维基于智能体的生态网络，其中的宏观可观测量被粗粒化为一维有效流。该系统在混沌边缘运行，其最大李雅普诺夫指数（LLE）为正但不大，表明系统对初始条件具有敏感依赖性，但并未完全无序。有效粗粒化流的最大李雅普诺夫指数 $\\lambda$ 定义为\n$$\n\\lambda \\equiv \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|},\n$$\n其中轨迹在状态空间中以无穷小分离 $\\delta \\mathbf{x}(0)$ 开始，并遵循相同的动力学演化。假设分离动力学足够平滑，对于足够小的不确定性 $\\delta_0 \\equiv \\|\\delta \\mathbf{x}(0)\\|$，分离幅度以速率 $\\lambda$ 近似指数增长，直到在粗粒化可观测量中达到一个可容忍的宏观误差阈值 $\\Delta$。\n\n从上述定义和由最大李雅普诺夫指数控制的指数误差增长的假设出发，推导可预测性时间跨度 $T$（初始不确定性 $\\delta_0$ 达到阈值 $\\Delta$ 的时间）的表达式，然后为以下情景计算 $T$：\n- 测得的最大李雅普诺夫指数为 $\\lambda = 0.35$ $\\text{min}^{-1}$。\n- 初始不确定性为 $\\delta_0 = 2.5 \\times 10^{-6}$（以所选的状态空间单位计）。\n- 可容忍的宏观误差为 $\\Delta = 5.0 \\times 10^{-3}$（以相同的状态空间单位计）。\n\n将 $T$ 的最终答案以分钟表示，并将数值结果四舍五入到四位有效数字。",
            "solution": "本题要求为一个表现出混沌动力学的系统推导其可预测性时间跨度 $T$ 的表达式，并根据给定参数计算其值。分析始于最大李雅普诺夫指数（LLE）$\\lambda$ 的定义，该指数用以量化状态空间中邻近轨迹的指数发散的平均速率。\n\nLLE 的形式化定义如下：\n$$\n\\lambda \\equiv \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|}\n$$\n其中 $\\|\\delta \\mathbf{x}(t)\\|$ 是两条无穷小邻近轨迹在时间 $t$ 的分离幅度，而 $\\|\\delta \\mathbf{x}(0)\\|$ 是它们的初始分离。\n\n题目指出，对于足够小的初始分离，该分离的演化可以近似为以速率 $\\lambda$ 的纯指数增长。设初始不确定性表示为 $\\delta_0 \\equiv \\|\\delta \\mathbf{x}(0)\\|$。在稍后时间 $t$ 的分离可以表示为：\n$$\n\\|\\delta \\mathbf{x}(t)\\| \\approx \\delta_0 \\exp(\\lambda t)\n$$\n该方程描述了一个微小的初始误差在混沌系统中如何随时间增长。\n\n可预测性时间跨度 $T$ 定义为初始不确定性 $\\delta_0$ 增长到指定的可容忍宏观误差阈值 $\\Delta$ 所需的时间。为推导 $T$ 的表达式，我们将时间 $T$ 时的分离设为等于阈值 $\\Delta$：\n$$\n\\|\\delta \\mathbf{x}(T)\\| = \\Delta\n$$\n将此代入我们的指数增长模型，可得：\n$$\n\\Delta = \\delta_0 \\exp(\\lambda T)\n$$\n我们的目标是求解该方程以得到 $T$。我们首先通过将方程两边同除以 $\\delta_0$（非零）来分离指数项：\n$$\n\\frac{\\Delta}{\\delta_0} = \\exp(\\lambda T)\n$$\n为求解指数 $\\lambda T$，我们对两边取自然对数（$\\ln$）。自然对数是指数函数的反函数，即 $\\ln(\\exp(x)) = x$。\n$$\n\\ln\\left(\\frac{\\Delta}{\\delta_0}\\right) = \\ln(\\exp(\\lambda T))\n$$\n$$\n\\ln\\left(\\frac{\\Delta}{\\delta_0}\\right) = \\lambda T\n$$\n最后，通过除以最大李雅普诺夫指数 $\\lambda$（题目说明其为正），我们得到可预测性时间跨度 $T$ 的通用表达式：\n$$\nT = \\frac{1}{\\lambda} \\ln\\left(\\frac{\\Delta}{\\delta_0}\\right)\n$$\n这个推导出的公式给出了在一个以 LLE $\\lambda$ 为特征的系统中，初始误差增长因子为 $\\frac{\\Delta}{\\delta_0}$ 所需的时间。\n\n接下来，我们必须为所提供的特定情景计算 $T$ 的数值：\n- 最大李雅普诺夫指数：$\\lambda = 0.35 \\, \\text{min}^{-1}$\n- 初始不确定性：$\\delta_0 = 2.5 \\times 10^{-6}$\n- 可容忍的宏观误差：$\\Delta = 5.0 \\times 10^{-3}$\n\n$\\delta_0$ 和 $\\Delta$ 的单位相同，因此它们的比值将是一个无量纲的量。首先，我们计算这个比值：\n$$\n\\frac{\\Delta}{\\delta_0} = \\frac{5.0 \\times 10^{-3}}{2.5 \\times 10^{-6}} = \\frac{5.0}{2.5} \\times 10^{-3 - (-6)} = 2.0 \\times 10^{3} = 2000\n$$\n现在我们将这个比值和 $\\lambda$ 的值代入我们关于 $T$ 的表达式中：\n$$\nT = \\frac{1}{0.35} \\ln(2000)\n$$\n$\\lambda$ 的单位是 $\\text{min}^{-1}$，所以 $T = 1/\\lambda$ 的单位将是分钟，这与题目的要求一致。我们现在对该表达式进行数值计算：\n$$\n\\ln(2000) \\approx 7.60090246\n$$\n$$\nT \\approx \\frac{7.60090246}{0.35} \\, \\text{min} \\approx 21.71686417 \\, \\text{min}\n$$\n题目明确要求将最终答案四舍五入到四位有效数字。应用此舍入规则，我们得到：\n$$\nT \\approx 21.72 \\, \\text{min}\n$$\n这就是指定系统的可预测性时间跨度。",
            "answer": "$$\n\\boxed{21.72}\n$$"
        },
        {
            "introduction": "“混沌边缘”是复杂系统中的一个关键区域，它介于可预测的有序和完全不可预测的混沌之间，被认为对复杂计算和自适应能力至关重要。本练习让你通过分析离散网络模型来探索这一概念，展示了其普适性 。你将为一个具体的规则计算朗顿$\\lambda$参数，并推导将有序与混沌动力学分开的临界条件，从而将一个富有诗意的比喻转变为一个精确的数学度量。",
            "id": "4135119",
            "problem": "考虑一个随机布尔网络（RBN）的系综，其中每个节点恰好接收 $K=3$ 个输入，并基于一个相同的局部布尔规则进行同步更新。将该系统解释为一个元胞自动机（CA），其静止态定义为 $0$。Langton 参数 $\\lambda$ 定义为规则表输出中非静止（即不等于静止态）的比例。您需要为给定的局部规则量化 $\\lambda$ 值，然后使用第一性原理的退火近似来推导区分有序与混沌动力学的混沌边缘临界条件。\n\n局部更新规则由其对 $2^{3}$ 个输入三元组（按字典序列出）中每一个的输出指定。该映射为：\n$000 \\mapsto 0$， $001 \\mapsto 1$， $010 \\mapsto 0$， $011 \\mapsto 1$， $100 \\mapsto 0$， $101 \\mapsto 1$， $110 \\mapsto 0$， $111 \\mapsto 0$。\n\n任务：\n1. 计算此规则的 Langton 参数 $\\lambda$，即规则表中非静止输出的比例。\n2. 从对小扰动的敏感性定义和退火近似（即将相邻输入的输出视为由 $\\lambda$ 决定的具有固定偏差的独立抽样）出发，推导无穷小扰动的边际稳定性条件，并求解以获得 $K=3$ 时的临界值 $\\lambda_{c}$。\n3. 设 $\\Delta$ 为计算出的 $\\lambda$ 与下临界值 $\\lambda_{c}^{(\\text{lower})}$ 之间的有符号差值。以单一闭式解析表达式的形式给出 $\\Delta$。不要进行数值近似；给出精确表达式。\n\n您的最终答案必须是 $\\Delta$ 的单一闭式表达式，不带单位。如果进行任何数值近似，请将最终结果四舍五入到四位有效数字；然而，首选并接受精确的闭式形式。",
            "solution": "经评估，该问题在复杂系统理论领域内是有效的、适定的，并具有科学依据。解答按要求分三部分进行。\n\n首先，我们计算指定局部布尔规则的 Langton 参数 $\\lambda$。该系统的连接度为 $K=3$，这意味着规则表有 $2^K = 2^3 = 8$ 个条目。静止态定义为 $0$。Langton 参数 $\\lambda$ 是规则表中非静止（即等于 $1$）输出所占的比例。\n\n给定的规则表如下：\n$000 \\mapsto 0$\n$001 \\mapsto 1$\n$010 \\mapsto 0$\n$011 \\mapsto 1$\n$100 \\mapsto 0$\n$101 \\mapsto 1$\n$110 \\mapsto 0$\n$111 \\mapsto 0$\n\n通过计算非静止输出（$1$）的数量，我们发现有 $3$ 个这样的实例。可能的输入配置总数为 $8$。因此，该特定规则的 Langton 参数是非静止输出与总输出数量的比值：\n$$\n\\lambda = \\frac{3}{8}\n$$\n\n其次，我们推导 Langton 参数的临界值 $\\lambda_c$，该值标志着连接度为 $K=3$ 的网络中有序与混沌动力学之间的转变。该推导基于退火近似，该近似分析了小扰动在网络中的传播。\n\n设 $d(t)$ 为两个相同网络在时间 $t$ 的状态之间的归一化汉明距离，这两个网络最初因一个无穷小扰动而不同。$d(t)$ 代表处于不同状态的节点的比例。我们旨在找到这种扰动处于边际稳定状态的条件，即对于小的 $d(t)$，有 $d(t+1) \\approx d(t)$。\n\n在时间 $t+1$，仅当节点 $i$ 在时间 $t$ 接收到的输入使其布尔函数 $f$ 产生不同输出时，它才会在两个网络中处于不同状态。在退火近似中，我们假设节点的输入是随机且独立选择的。一个节点的任意给定输入在两个网络之间不同的概率是 $d(t)$。\n\n对于一个有 $K$ 个输入的节点，不同输入的数量 $m$ 服从二项分布 $B(K, d(t))$。节点在两个网络中的输入相同的概率（$m=0$）为 $(1-d(t))^K$。在这种情况下，输出也将相同。输入不同的概率（$m > 0$）为 $1 - (1-d(t))^K$。\n\n退火近似中的关键步骤是假设布尔规则 $f$ 是从具有固定偏差 $\\lambda$ 的规则系综中随机选择的。在此假设下，任何两个不同输入向量的输出在统计上是独立的。如果两个网络的输入向量 $I_A$ 和 $I_B$ 不同，则其输出不同的概率为：\n$$\nP(f(I_A) \\neq f(I_B)) = P(f(I_A)=1, f(I_B)=0) + P(f(I_A)=0, f(I_B)=1)\n$$\n根据 $\\lambda$ 的定义，$P(f(\\cdot)=1) = \\lambda$ 且 $P(f(\\cdot)=0) = 1-\\lambda$。由于独立性，这变为：\n$$\nP(f(I_A) \\neq f(I_B)) = \\lambda(1-\\lambda) + (1-\\lambda)\\lambda = 2\\lambda(1-\\lambda)\n$$\n这个量是在输入不同的条件下，输出不同的概率。一个节点的状态在时间 $t+1$ 发生变化的概率是其输入发生变化的概率与这导致输出变化的条件概率的乘积：\n$$\nd(t+1) = P(\\text{输入不同}) \\times P(\\text{输出不同 | 输入不同})\n$$\n$$\nd(t+1) = [1 - (1-d(t))^K] \\times [2\\lambda(1-\\lambda)]\n$$\n为了找到边际稳定性的条件，我们分析无穷小扰动下的行为，其中 $d(t) \\to 0$。我们在 $d(t)=0$ 附近对 $d(t+1)$ 的表达式进行线性化。对于小的 $d(t)$，使用二项式展开，$(1-d(t))^K \\approx 1 - K d(t)$。\n将此代入 $d(t+1)$ 的方程中：\n$$\nd(t+1) \\approx [1 - (1 - K d(t))] \\times [2\\lambda(1-\\lambda)] = K d(t) \\times 2\\lambda(1-\\lambda)\n$$\n当放大因子为 1 时，扰动是边际稳定的，即 $\\frac{d(t+1)}{d(t)} = 1$。因此，临界条件是：\n$$\n2K \\lambda_c (1-\\lambda_c) = 1\n$$\n其中 $\\lambda_c$ 表示 $\\lambda$ 的临界值。这是一个关于 $\\lambda_c$ 的二次方程：\n$$\n2K\\lambda_c^2 - 2K\\lambda_c + 1 = 0\n$$\n使用二次方程求根公式 $\\lambda_c = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$，其中 $a=2K$，$b=-2K$，$c=1$：\n$$\n\\lambda_c = \\frac{2K \\pm \\sqrt{(-2K)^2 - 4(2K)(1)}}{2(2K)} = \\frac{2K \\pm \\sqrt{4K^2 - 8K}}{4K} = \\frac{1}{2} \\pm \\frac{\\sqrt{K^2-2K}}{2K}\n$$\n对于给定的连接度 $K=3$：\n$$\n\\lambda_c = \\frac{1}{2} \\pm \\frac{\\sqrt{3^2 - 2(3)}}{2(3)} = \\frac{1}{2} \\pm \\frac{\\sqrt{9 - 6}}{6} = \\frac{1}{2} \\pm \\frac{\\sqrt{3}}{6}\n$$\n这得出了两个临界值，它们定义了混沌区域的边界。下临界值为：\n$$\n\\lambda_c^{(\\text{lower})} = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}\n$$\n\n第三，我们计算 $\\Delta$，即特定规则计算出的 $\\lambda$ 与下临界值 $\\lambda_c^{(\\text{lower})}$ 之间的有符号差。\n$$\n\\Delta = \\lambda - \\lambda_c^{(\\text{lower})} = \\frac{3}{8} - \\left(\\frac{1}{2} - \\frac{\\sqrt{3}}{6}\\right)\n$$\n$$\n\\Delta = \\frac{3}{8} - \\frac{1}{2} + \\frac{\\sqrt{3}}{6}\n$$\n为了合并这些项，我们找到一个公分母。对于有理数部分，公分母是 $8$：\n$$\n\\Delta = \\frac{3}{8} - \\frac{4}{8} + \\frac{\\sqrt{3}}{6} = -\\frac{1}{8} + \\frac{\\sqrt{3}}{6}\n$$\n为了将其表示为单个分数，我们使用 $8$ 和 $6$ 的最小公倍数，即 $24$：\n$$\n\\Delta = -\\frac{3}{24} + \\frac{4\\sqrt{3}}{24} = \\frac{4\\sqrt{3} - 3}{24}\n$$\n这就是所要求的 $\\Delta$ 的单一闭式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{4\\sqrt{3} - 3}{24}}\n$$"
        },
        {
            "introduction": "理论最终需要通过经验数据进行检验，而区分不同动态机制是建模的关键一步。这个综合性的计算练习将指导你通过分析时间序列数据，凭经验区分有序、混沌和混沌边缘这三种状态 。你将为代表这些机制的典范映射计算其关联函数的衰减，并学习如何通过关联衰减的特征（指数、代数或不衰减）来识别系统的动态“指纹”，这是复杂系统分析中的一项基本技能。",
            "id": "4135139",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，用于经验性地评估在复杂自适应系统建模中具有典范意义的离散时间一维映射的相关性衰减。其科学目标是估计相关函数 $$C(n) = \\mathbb{E}\\left[g(x_{k+n}) h(x_k)\\right] - \\mathbb{E}[g] \\mathbb{E}[h],$$ 将其衰减解释为指数衰减或代数衰减，并就与有序、混沌和混沌边缘相关的混合性质得出结论。数学期望是相对于映射的不变测度来计算的，而计算估计必须依赖于由 Glivenko–Cantelli 原理和 Birkhoff 遍历定理证明其合理性的时间平均。您的程序必须实现以下要求。\n\n推导的基本依据：\n- 使用由确定性映射 $T$ 驱动的平稳离散时间过程 $\\{x_k\\}_{k \\ge 0}$ 的相关函数 $C(n)$ 的定义，其中 $x_{k+1} = T(x_k)$，$\\mathbb{E}[\\cdot]$ 表示相对于 $T$ 的一个不变遍历测度 $\\mu$ 的期望。\n- 使用 Birkhoff 遍历定理，该定理指出对于 $\\mu$-可积的 $f$，$$\\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{k=0}^{N-1} f(x_k) = \\int f \\, d\\mu,$$ 对于 $\\mu$-几乎所有的初始条件都成立。这为使用长轨迹的时间平均替代系综期望提供了理论依据。\n\n定义：\n- 如果对于均值为零的可积观测量 $g$ 和 $h$，有 $$\\lim_{n \\to \\infty} C(n) = 0;$$ 则映射 $T$ 是混合的；强混合通常意味着指数速率，而中性不动点附近的间歇性可导致代数速率。\n- 指数衰减对应于经验拟合 $$|C(n)| \\approx A \\exp(-\\lambda n)$$，其中 $A > 0$ 且 $\\lambda > 0$；而代数衰减对应于 $$|C(n)| \\approx B n^{-\\beta}$$，其中 $B > 0$ 且 $\\beta > 0$。\n\n您的程序必须：\n1. 对于每个指定的映射 $T$，根据规定的初始条件策略和必要的“预烧”（burn-in）长度，生成一条长轨迹 $\\{x_k\\}$，然后使用长度为 $N$ 的轨迹段上的时间平均来计算经验均值和相关性。\n2. 对所有测试用例使用观测量 $g(x) = x$ 和 $h(x) = \\cos(2\\pi x)$。\n3. 对于每个映射，计算 $$\\widehat{C}(n) = \\frac{1}{N-n} \\sum_{k=0}^{N-n-1} g(x_{k+n}) \\, h(x_k) - \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} g(x_k)\\right) \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} h(x_k)\\right),$$ 其中滞后 $n = 1, 2, \\dots, n_{\\max}$。\n4. 拟合 $\\log(|\\widehat{C}(n)|)$ 与 $n$ 的关系以检测指数衰减，并拟合 $\\log(|\\widehat{C}(n)|)$ 与 $\\log(n)$ 的关系以检测代数衰减。两种情况都使用线性回归，并使用决定系数 $R^2$ 来评估哪个模型能更好地解释衰减。剔除那些 $|\\widehat{C}(n)|$ 在数值上与零无法区分的点，以避免对数的不稳定性。\n5. 根据回归拟合和斜率符号对衰减类型进行分类，并返回：\n   - 若强有力地支持指数衰减，则返回 $2$。\n   - 若强有力地支持代数衰减，则返回 $1$。\n   - 若两种拟合都不充分（无混合或不确定），则返回 $0$。\n\n映射和参数化：\n- 映射 A（混沌，扩张）：逻辑斯谛映射 $T(x) = r x (1-x)$，其中 $r = 4$。为从不变测度中采样而无需预烧，使用共轭关系 $x = \\sin^2(\\pi \\theta)$，其中 $\\theta$ 在初始步骤中在 $[0,1)$ 上均匀分布，然后迭代 $T$ 以生成轨迹。使用 $N = 200000$ 和 $n_{\\max} = 50$。\n- 映射 B（间歇性，混沌边缘）：Pomeau–Manneville 映射 $T(x) = x + x^{1+\\alpha} \\bmod 1$，其中 $\\alpha = 0.5$。使用一个均匀分布的初始条件 $x_0 \\in [0,1)$，应用 $B = 5000$ 次迭代的预烧，然后累积 $N = 200000$ 次迭代来评估相关性，其中 $n_{\\max} = 50$。\n- 映射 C（有序，非混合）：圆周旋转映射 $T(x) = x + \\varphi \\bmod 1$，其中 $\\varphi = (\\sqrt{5}-1)/2$。使用一个均匀分布的初始条件 $x_0 \\in [0,1)$，应用 $B = 5000$ 次迭代的预烧，然后累积 $N = 200000$ 次迭代来评估相关性，其中 $n_{\\max} = 50$。\n\n角度单位和物理单位：\n- 不涉及物理单位。\n- 余弦函数的所有角度均使用弧度，即 $h(x) = \\cos(2\\pi x)$，其中 $2\\pi$ 以弧度为单位。\n\n测试套件：\n- 测试用例 1：映射 A，参数为 $r = 4$, $N = 200000$, $n_{\\max} = 50$。\n- 测试用例 2：映射 B，参数为 $\\alpha = 0.5$, $B = 5000$, $N = 200000$, $n_{\\max} = 50$。\n- 测试用例 3：映射 C，参数为 $\\varphi = (\\sqrt{5}-1)/2$, $B = 5000$, $N = 200000$, $n_{\\max} = 50$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $$[2,1,0],$$ 其中每个条目对应于按上述顺序排列的相应测试用例的分类代码。这些条目必须是整数，其中 $2$ 表示指数衰减，$1$ 表示代数衰减，$0$ 表示两者都不是。",
            "solution": "所提出的问题是动力系统和复杂自适应系统建模领域中一个明确定义的计算练习。它具有科学依据、内部一致，并要求应用已建立的理论原理和数值方法。其目标是经验性地研究三个典型一维映射的混合性质，每个映射代表一类独特的动力学行为：混沌（逻辑斯谛映射）、混沌边缘的间歇性（Pomeau-Manneville 映射）和有序/准周期性（圆周旋转映射）。验证确认所有必要的数据、定义和程序都已提供，从而可以得到一个唯一且可验证的解。因此，我们可以继续进行推导和实现。\n\n我们的任务是通过分析相关函数 $C(n)$ 的衰减来对这些系统的长期行为进行分类。对于由映射 $T$（使得 $x_{k+1} = T(x_k)$）生成的平稳离散时间过程，以及两个观测量 $g(x)$ 和 $h(x)$，相关函数定义为：\n$$\nC(n) = \\mathbb{E}\\left[g(x_{k+n}) h(x_k)\\right] - \\mathbb{E}[g] \\mathbb{E}[h]\n$$\n这里，$\\mathbb{E}[\\cdot]$ 表示相对于映射不变测度 $\\mu$ 的期望。如果当时间滞后 $n \\to \\infty$ 时 $C(n) \\to 0$，则系统被认为是混合的。这种衰减的速率是系统动力学的一个关键指标。\n\nBirkhoff 遍历定理为我们的计算方法提供了理论依据。该定理指出，对于一个遍历系统，沿着一条典型轨迹的观测量的时间平均值会收敛到系综平均值（即相对于不变测度的期望）：\n$$\n\\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{k=0}^{N-1} f(x_k) = \\int f(x) \\, d\\mu(x) = \\mathbb{E}[f]\n$$\n这使我们能够使用长度为 $N$ 的单条长轨迹上的平均值来估计 $C(n)$ 中的期望。相关函数的估计量 $\\widehat{C}(n)$ 由下式给出：\n$$\n\\widehat{C}(n) = \\frac{1}{N-n} \\sum_{k=0}^{N-n-1} g(x_{k+n}) \\, h(x_k) - \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} g(x_k)\\right) \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} h(x_k)\\right)\n$$\n我们为滞后 $n = 1, 2, \\dots, n_{\\max}$ 计算该值。具体的观测量是 $g(x) = x$ 和 $h(x) = \\cos(2\\pi x)$。\n\n衰减的分类基于将计算出的 $|\\widehat{C}(n)|$ 拟合到两个模型：\n1.  **指数衰减**：强混沌、混合系统的特征。模型为 $|\\widehat{C}(n)| \\approx A \\exp(-\\lambda n)$，其中常数 $A, \\lambda > 0$。取自然对数使该关系线性化：$\\log(|\\widehat{C}(n)|) \\approx \\log(A) - \\lambda n$。我们对 $\\log(|\\widehat{C}(n)|)$ 与 $n$ 进行线性回归。一个具有负斜率 ($-\\lambda$) 的良好拟合表明指数衰减。\n2.  **代数（幂律）衰减**：常在具有间歇性、处于“混沌边缘”的系统中观察到。模型为 $|\\widehat{C}(n)| \\approx B n^{-\\beta}$，其中常数 $B, \\beta > 0$。通过两边取对数进行线性化：$\\log(|\\widehat{C}(n)|) \\approx \\log(B) - \\beta \\log(n)$。我们对 $\\log(|\\widehat{C}(n)|)$ 与 $\\log(n)$ 进行线性回归。一个具有负斜率 ($-\\beta$) 的良好拟合表明代数衰减。\n\n衰减类型的决定是通过比较两次线性回归的决定系数 $R^2$ 来做出的。更高的 $R^2$ 值（越接近 1）表示拟合效果越好。使用一个阈值，如 $R^2 > 0.9$，以确保拟合在统计上是显著的。斜率的符号必须为负，对应于衰减。如果两个模型都不能提供强有力的拟合，或者相关性不衰减，则系统被分类为非混合或不确定。\n\n每个测试用例的计算过程如下：\n\n**步骤 1：轨迹生成**\n对于每个映射，在应用指定的预烧期 $B$ 后，生成长度为 $N=200000$ 的轨迹 $\\{x_k\\}_{k=0}^{N-1}$。区间为 $[0,1)$。\n-   **映射 A (逻辑斯谛)**: $T(x) = 4x(1-x)$。使用共轭关系 $x_0 = \\sin^2(\\pi \\theta)$（其中 $\\theta \\sim U[0,1)$）从不变反正弦分布中抽取初始条件 $x_0$。不需要预烧。该映射预计是强混合的。\n-   **映射 B (Pomeau-Manneville)**: $T(x) = x + x^{1+\\alpha} \\pmod 1$，其中 $\\alpha = 0.5$。使用一个随机初始条件 $x_0 \\sim U[0,1)$，然后进行 $B=5000$ 次迭代的预烧，以使轨迹稳定在吸引子附近。该映射表现出间歇性，预计会呈现代数衰减。\n-   **映射 C (圆周旋转)**: $T(x) = x + \\varphi \\pmod 1$，其中 $\\varphi = (\\sqrt{5}-1)/2$。使用一个随机初始条件 $x_0 \\sim U[0,1)$，然后进行 $B=5000$ 次迭代的预烧。这种无理数旋转是遍历的但不是混合的；相关性预计不会衰减到零。\n\n**步骤 2：相关性计算**\n对于每条轨迹，计算观测量 $g(x_k)=x_k$ 和 $h(x_k) = \\cos(2\\pi x_k)$ 的时间序列。计算它们在整个长度 $N$ 上的均值。然后，对于从 $1$ 到 $n_{\\max}=50$ 的每个滞后 $n$，使用提供的公式计算 $\\widehat{C}(n)$。\n\n**步骤 3：拟合与分类**\n对于计算出的相关性集合 $\\{\\widehat{C}(n)\\}_{n=1}^{n_{\\max}}$：\n-   滤掉 $|\\widehat{C}(n)|$ 在数值上与零无法区分的任何点，以防止对数计算出错。\n-   对 $\\log(|\\widehat{C}(n)|)$ 与 $n$ 进行线性回归，得到斜率 $s_{exp}$ 和决定系数 $R^2_{exp}$。\n-   对 $\\log(|\\widehat{C}(n)|)$ 与 $\\log(n)$ 进行线性回归，得到斜率 $s_{alg}$ 和决定系数 $R^2_{alg}$。\n-   应用分类逻辑：\n    -   如果 $R^2_{exp} > 0.9$ 且 $s_{exp}  0$，并且 $R^2_{exp} > R^2_{alg}$，则分类为指数衰减（代码 $2$）。\n    -   如果 $R^2_{alg} > 0.9$ 且 $s_{alg}  0$，并且 $R^2_{alg} > R^2_{exp}$，则分类为代数衰减（代码 $1$）。\n    -   在所有其他情况下（拟合不佳、斜率 $s \\ge 0$ 表明相关性不衰减，或存在歧义），分类为不确定（代码 $0$）。\n\n这种结构化的、基于原理的方法确保了对给定映射动力学性质的稳健和可复现的分析，为有序、混沌和混沌边缘之间提供了清晰的经验区分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"map_type\": \"A\",\n            \"params\": {\"r\": 4.0},\n            \"N\": 200000,\n            \"B\": 0,\n            \"n_max\": 50,\n        },\n        {\n            \"map_type\": \"B\",\n            \"params\": {\"alpha\": 0.5},\n            \"N\": 200000,\n            \"B\": 5000,\n            \"n_max\": 50,\n        },\n        {\n            \"map_type\": \"C\",\n            \"params\": {\"phi\": (np.sqrt(5) - 1) / 2},\n            \"N\": 200000,\n            \"B\": 5000,\n            \"n_max\": 50,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        classification = analyze_map(\n            case[\"map_type\"],\n            case[\"params\"],\n            case[\"N\"],\n            case[\"B\"],\n            case[\"n_max\"],\n        )\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_trajectory(map_type, params, N, B):\n    \"\"\"\n    Generates a time series for a given map.\n    \n    Args:\n        map_type (str): 'A', 'B', or 'C'.\n        params (dict): Dictionary of map parameters.\n        N (int): Length of the trajectory for analysis.\n        B (int): Length of the burn-in period.\n        \n    Returns:\n        np.ndarray: The generated trajectory of length N.\n    \"\"\"\n    x = np.zeros(B + N)\n    \n    # Initial condition\n    if map_type == 'A':\n        # For logistic map r=4, use conjugacy to start on the attractor\n        theta0 = np.random.uniform(0.0, 1.0)\n        x[0] = np.sin(np.pi * theta0)**2\n    else:\n        # Uniform initial condition for other maps\n        x[0] = np.random.uniform(0.0, 1.0)\n\n    # Map definitions\n    if map_type == 'A':\n        r = params['r']\n        def T(val): return r * val * (1.0 - val)\n    elif map_type == 'B':\n        alpha = params['alpha']\n        def T(val): return (val + val**(1.0 + alpha)) % 1.0\n    elif map_type == 'C':\n        phi = params['phi']\n        def T(val): return (val + phi) % 1.0\n    else:\n        raise ValueError(\"Unknown map type\")\n\n    # Iterate map\n    for i in range(B + N - 1):\n        x[i+1] = T(x[i])\n        \n    return x[B:]\n\ndef analyze_map(map_type, params, N, B, n_max):\n    \"\"\"\n    Performs the full correlation analysis for a single map.\n    \n    Args:\n        map_type (str): The map identifier.\n        params (dict): Map-specific parameters.\n        N (int): Trajectory length.\n        B (int): Burn-in length.\n        n_max (int): Maximum lag for correlation.\n\n    Returns:\n        int: Classification code (2 for exponential, 1 for algebraic, 0 for other).\n    \"\"\"\n    \n    # Step 1: Generate trajectory\n    x_series = generate_trajectory(map_type, params, N, B)\n    \n    # Step 2: Compute observables and their means\n    g_series = x_series\n    h_series = np.cos(2.0 * np.pi * x_series)\n    \n    mean_g = np.mean(g_series)\n    mean_h = np.mean(h_series)\n    \n    # Step 3: Compute empirical correlation function C(n)\n    lags = np.arange(1, n_max + 1)\n    correlations = np.zeros_like(lags, dtype=float)\n    \n    for i, n in enumerate(lags):\n        # Estimator for E[g(x_{k+n})h(x_k)]\n        cross_term_est = np.mean(g_series[n:] * h_series[:-n])\n        correlations[i] = cross_term_est - mean_g * mean_h\n\n    # Step 4: Fit decay models\n    abs_corr = np.abs(correlations)\n    \n    # Filter out numerically zero correlations to avoid log(0)\n    valid_indices = abs_corr > np.finfo(float).eps * 10\n    if np.sum(valid_indices)  2: # Need at least 2 points for regression\n        return 0\n\n    lags_fit = lags[valid_indices]\n    abs_corr_fit = abs_corr[valid_indices]\n    log_abs_corr_fit = np.log(abs_corr_fit)\n\n    # --- Exponential fit: log|C(n)| vs n ---\n    try:\n        slope_exp, _, r_exp, _, _ = stats.linregress(lags_fit, log_abs_corr_fit)\n        r2_exp = r_exp**2\n    except ValueError:\n        slope_exp, r2_exp = 0.0, 0.0\n\n    # --- Algebraic fit: log|C(n)| vs log(n) ---\n    try:\n        slope_alg, _, r_alg, _, _ = stats.linregress(np.log(lags_fit), log_abs_corr_fit)\n        r2_alg = r_alg**2\n    except ValueError:\n        slope_alg, r2_alg = 0.0, 0.0\n    \n    # Step 5: Classify based on fits\n    R2_THRESHOLD = 0.90\n    \n    is_exp_good = r2_exp > R2_THRESHOLD and slope_exp  0\n    is_alg_good = r2_alg > R2_THRESHOLD and slope_alg  0\n\n    if is_exp_good and is_alg_good:\n        if r2_exp > r2_alg:\n            return 2  # Exponential\n        else:\n            return 1  # Algebraic\n    elif is_exp_good:\n        return 2  # Exponential\n    elif is_alg_good:\n        return 1  # Algebraic\n    else:\n        # Special check for non-decaying correlation (Map C)\n        if map_type == 'C':\n            if not is_exp_good and not is_alg_good:\n                return 0\n        \n        # Default for other cases\n        if not is_exp_good and not is_alg_good:\n             return 0 # Undetermined / No decay\n        \n        # Fallback for ambiguity\n        return 0\n        \n\nsolve()\n```"
        }
    ]
}