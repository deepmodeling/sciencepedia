{
    "hands_on_practices": [
        {
            "introduction": "在二维元胞自动机中，邻域的选择是定义系统基本交互的基石。摩尔（Moore）邻域和冯·诺依曼（von Neumann）邻域是两种最经典的定义，它们分别对应了不同的几何直觉和信息传播方式。本实践旨在通过第一性原理推导，精确计算并比较这两种邻域在不同半径下的规模，进而分析其渐进行为，帮助你从根本上理解它们在几何形态和计算代价上的本质差异。这项练习不仅能巩固你对邻域核心定义的理解，还能培养你在离散空间中进行组合分析的严谨数学思维 。",
            "id": "4150733",
            "problem": "考虑一个在无限整数格 $\\mathbb{Z}^{2}$ 上的二维元胞自动机（CA）。对于一个位于原点的固定中心元胞，为一个整数 $r \\geq 1$，基于标准范数定义两种半径为 $r$ 的邻域：\n- 半径为 $r$ 的摩尔邻域（Moore neighborhood）由所有格点 $\\{(i,j) \\in \\mathbb{Z}^{2} : \\max(|i|,|j|) \\leq r\\}$ 组成。\n- 半径为 $r$ 的冯·诺依曼邻域（von Neumann neighborhood）由所有格点 $\\{(i,j) \\in \\mathbb{Z}^{2} : |i| + |j| \\leq r\\}$ 组成。\n\n在元胞自动机建模中，一个元胞的邻域传统上不包括该元胞自身。仅使用上述核心定义和在 $\\mathbb{Z}^{2}$ 上的第一性原理计数论证（不援引任何预先推导的公式），推导出每种邻域中邻居数量作为 $r$ 的函数，构建摩尔邻域邻居数与冯·诺依曼邻域邻居数的比率，并分析当 $r \\to \\infty$ 时其渐近行为。将最终结果报告为一个单一的精确实数，该实数既能表示该比率，又能表示其渐近极限。无需四舍五入。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 域：一个在无限整数格 $\\mathbb{Z}^{2}$ 上的二维元胞自动机。\n- 中心元胞：位于原点 $(0,0)$。\n- 半径参数：$r$ 是一个整数，满足 $r \\geq 1$。\n- 半径为 $r$ 的摩尔邻域（包括中心元胞）：所有格点 $\\{(i,j) \\in \\mathbb{Z}^{2} : \\max(|i|,|j|) \\leq r\\}$ 的集合。\n- 半径为 $r$ 的冯·诺依曼邻域（包括中心元胞）：所有格点 $\\{(i,j) \\in \\mathbb{Z}^{2} : |i| + |j| \\leq r\\}$ 的集合。\n- 邻居的定义：一个元胞的邻域不包括该元胞自身。\n- 任务：推导出每种邻域类型中邻居的数量作为 $r$ 的函数，求出摩尔邻域计数与冯·诺依曼邻域计数的比率，并确定当 $r \\to \\infty$ 时此比率的渐近极限。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题在元胞自动机理论的背景下，使用了摩尔邻域和冯·诺依曼邻域的标准、公认定义。这些定义分别对应于切比雪夫（$L_\\infty$）和曼哈顿（$L_1$）范数下的半径为 $r$ 的球体。这些概念是离散数学和复杂系统建模的基础。该问题在科学上是合理的。\n- **适定性：** 该问题提供了清晰、明确的定义和一组精确的任务。约束条件是自洽的，并且可以从提供的信息中推导出一个唯一的、有意义的解。\n- **客观性：** 该问题以形式化的数学语言陈述，不含任何主观性或意见。\n\n### 步骤 3：结论与行动\n问题有效。它具有科学依据、适定性和客观性。可以开始求解过程。\n\n### 邻居数量的推导\n\n设 $N_M(r)$ 为半径为 $r$ 的摩尔邻域中的邻居数量，设 $N_V(r)$ 为半径为 $r$ 的冯·诺依曼邻域中的邻居数量。问题规定邻域不包括中心元胞。\n\n**1. 摩尔邻域计数**\n\n*包括*中心元胞的摩尔邻域是点集 $(i,j) \\in \\mathbb{Z}^{2}$，满足 $\\max(|i|, |j|) \\leq r$。此条件等价于要求 $|i| \\leq r$ 和 $|j| \\leq r$。\n这意味着坐标 $i$ 可以取从 $-r$ 到 $r$ 的任意整数值，坐标 $j$ 也类似。\n$i$ 的可能整数值的数量是 $r - (-r) + 1 = 2r+1$。\n$j$ 的可能整数值的数量也是 $2r+1$。\n包括中心在内的摩尔邻域中的总元胞数是这些坐标组合的总数，这在格点上形成一个方形网格。\n总元胞数（包括中心） = $(2r+1)(2r+1) = (2r+1)^{2}$。\n\n为了求得邻居数量 $N_M(r)$，我们减去中心元胞 $(0,0)$。\n$$N_M(r) = (2r+1)^{2} - 1$$\n$$N_M(r) = (4r^{2} + 4r + 1) - 1$$\n$$N_M(r) = 4r^{2} + 4r$$\n\n**2. 冯·诺依曼邻域计数**\n\n*包括*中心元胞的冯·诺依曼邻域是点集 $(i,j) \\in \\mathbb{Z}^{2}$，满足 $|i| + |j| \\leq r$。为了从第一性原理出发对这些点进行计数，我们可以对由 $|i| + |j| = k$（其中 $k$ 为从 $0$ 到 $r$ 的整数）定义的同心“菱形”壳层上的点数进行求和。\n\n对于 $k=0$，方程 $|i| + |j| = 0$ 的唯一解是 $(i,j)=(0,0)$。这给出了 $1$ 个元胞（中心）。\n\n对于任何 $k > 0$，我们计算满足 $|i| + |j| = k$ 的整数点数量。\n让我们考虑第一象限，其中 $i > 0$ 且 $j > 0$。方程为 $i+j=k$。解为 $(1, k-1), (2, k-2), \\dots, (k-1, 1)$。共有 $k-1$ 个这样的点。\n根据对称性，四个开放象限中各有 $k-1$ 个点。这给出了 $4(k-1)$ 个点。\n此外，坐标轴上也有点。它们是 $(\\pm k, 0)$ 和 $(0, \\pm k)$。共有 $4$ 个这样的点。\n对于给定的 $k>0$，壳层上的总点数是 $4(k-1) + 4 = 4k - 4 + 4 = 4k$。\n\n包括中心在内的冯·诺依曼邻域中的总元胞数是每个壳层从 $k=0$ 到 $k=r$ 的计数之和。\n总元胞数（包括中心）= ($k=0$ 时的计数) + $\\sum_{k=1}^{r}$ (壳层 $k$ 的计数)\n$$ \\text{总元胞数} = 1 + \\sum_{k=1}^{r} 4k $$\n使用前 $r$ 个整数的和的公式，$\\sum_{k=1}^{r} k = \\frac{r(r+1)}{2}$：\n$$ \\text{总元胞数} = 1 + 4 \\left( \\frac{r(r+1)}{2} \\right) = 1 + 2r(r+1) = 1 + 2r^{2} + 2r $$\n为了求得邻居数量 $N_V(r)$，我们减去中心元胞。\n$$ N_V(r) = (1 + 2r^{2} + 2r) - 1 $$\n$$ N_V(r) = 2r^{2} + 2r $$\n\n**3. 比率与渐近分析**\n\n现在，我们构建摩尔邻域邻居数与冯·诺依曼邻域邻居数的比率 $R(r)$，对于 $r \\geq 1$。\n$$ R(r) = \\frac{N_M(r)}{N_V(r)} = \\frac{4r^{2} + 4r}{2r^{2} + 2r} $$\n对于 $r \\geq 1$，分母 $2r^{2} + 2r = 2r(r+1)$ 非零。我们可以对分子和分母进行因式分解：\n$$ R(r) = \\frac{4r(r+1)}{2r(r+1)} $$\n因为 $r \\geq 1$，所以 $r$ 和 $r+1$ 都非零，可以进行约分：\n$$ R(r) = \\frac{4}{2} = 2 $$\n对于所有整数 $r \\geq 1$，该比率恰好为 $2$。\n\n最后，我们分析当 $r \\to \\infty$ 时这个比率的渐近行为。由于对于所有 $r \\geq 1$，该比率是一个常数函数 $R(r)=2$，其极限就是这个常数值。\n$$ \\lim_{r \\to \\infty} R(r) = \\lim_{r \\to \\infty} 2 = 2 $$\n这个结果也可以通过分析多项式的首项得到：\n$$ \\lim_{r \\to \\infty} \\frac{4r^{2} + 4r}{2r^{2} + 2r} = \\lim_{r \\to \\infty} \\frac{r^{2}(4 + \\frac{4}{r})}{r^{2}(2 + \\frac{2}{r})} = \\frac{4+0}{2+0} = 2 $$\n问题要求一个单一的精确实数，它既能表示该比率，又能表示其渐近极限。由于对于所有 $r \\geq 1$，该比率是常数且等于其极限，所以这个数是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "掌握了邻域的定义和边界处理后，我们便可以开始进行计算实验，探索元胞自动机规则所产生的复杂动力学。本实践引入了“损伤传播”（damage spreading）这一研究复杂系统动力学的经典方法，通过追踪一个微小扰动（单个细胞状态的翻转）在系统中的演化，来定量分析规则的宏观行为。你将通过编写程序模拟这一过程，并计算汉明距离（Hamming distance）的变化率，从而亲手揭示不同规则和邻域类型是如何将系统导向稳定、周期或混沌等不同状态的，这是理解元胞自动机中涌现行为的有力工具 。",
            "id": "4150687",
            "problem": "一个二维细胞自动机 (CA) 定义在一个大小为 $N \\times M$ 的有限矩形网格上，位点索引为 $(i,j)$，其中 $i \\in \\{0,1,\\dots,N-1\\}$ 且 $j \\in \\{0,1,\\dots,M-1\\}$。局部相互作用由半径为 $r=1$ 的 Moore 邻域给出，该邻域包含 8 个偏移量 $(\\Delta i,\\Delta j) \\in \\{-1,0,1\\} \\times \\{-1,0,1\\} \\setminus \\{(0,0)\\}$。边界条件是反射（镜像）边界：给定一个试探性邻居坐标 $(i+\\Delta i,j+\\Delta j)$，边界映射 $\\rho$ 对每个坐标独立作用，将其反射到有效范围内，即：\n$$\n\\rho_N(k) = \n\\begin{cases}\n0,  k  0,\\\\\nk,  0 \\leq k \\leq N-1,\\\\\nN-1,  k \\ge N,\n\\end{cases}\n\\qquad\n\\rho_M(\\ell) = \n\\begin{cases}\n0,  \\ell  0,\\\\\n\\ell,  0 \\leq \\ell \\leq M-1,\\\\\nM-1,  \\ell \\ge M,\n\\end{cases}\n$$\n映射后的邻居索引为 $\\big(\\rho_N(i+\\Delta i),\\rho_M(j+\\Delta j)\\big)$。在此映射下，多个不同的偏移量 $(\\Delta i,\\Delta j)$ 可能会映射到同一个网格索引，这在评估任何局部规则时会在邻域中产生重数。\n\n基于以上定义，计算对于半径 $r=1$ 且具有反射边界的 Moore 邻域，在一个角点位点、一个非角点边缘位点和一个内部位点上，不同邻居索引的数量（即映射后邻居索引集合的基数）。以 $(\\text{角点},\\ \\text{边缘},\\ \\text{内部})$ 的有序形式报告你的最终结果。\n\n此外，描述一个通过核 $w_{\\Delta i,\\Delta j}$ 聚合邻居状态的通用局部规则的应用应如何修改，以正确考虑反射边界映射。通过用原始核 $w_{\\Delta i,\\Delta j}$ 表示每个不同映射邻居索引 $(p,q)$ 上的有效权重 $\\widehat{w}_{p,q}$ 来实现。然后将你的描述特化到均匀 Moore 核，其中对于所有 8 个偏移量都有 $w_{\\Delta i,\\Delta j}=1$，并指明在半径 $r=1$ 的情况下，角点和非角点边缘处的重数模式。\n\n无需四舍五入。最终报告的计数必须按照答案规则中的规定，以单行矩阵的形式给出。",
            "solution": "问题陈述经过仔细验证，被认为是自洽的，在细胞自动机理论中有科学依据，并且在数学上是适定的。所有关于网格、邻域和边界条件的定义都足够清晰和精确，可以得出一个唯一且可验证的解。我们假设网格维度 $N$ 和 $M$ 足够大（例如，$N \\ge 3$ 且 $M \\ge 3$），以确保所有三种指定的位点类型（角点、非角点边缘和内部）都存在。\n\n问题的核心是确定位点 $(i,j)$ 的映射后邻居索引集合的基数，该集合由 $\\mathcal{V}_{i,j} = \\{(\\rho_N(i+\\Delta i), \\rho_M(j+\\Delta j)) \\mid (\\Delta i, \\Delta j) \\in \\mathcal{N}\\}$ 给出，其中 $\\mathcal{N} = \\{-1,0,1\\}^2 \\setminus \\{(0,0)\\}$。我们针对三种位点类型评估这个基数。\n\n**第一部分：不同邻居索引的数量**\n\n**1. 内部位点：**\n一个内部位点 $(i,j)$ 满足 $0  i  N-1$ 和 $0  j  M-1$。对于任何偏移量 $(\\Delta i, \\Delta j) \\in \\mathcal{N}$，试探性邻居坐标 $(i+\\Delta i, j+\\Delta j)$ 始终在网格边界内。具体来说，$i+\\Delta i \\in \\{i-1, i, i+1\\}$，并且由于 $1 \\le i \\le N-2$，我们有 $0 \\le i-1 \\le i+\\Delta i \\le N-1$。类似地，$0 \\le j+\\Delta j \\le M-1$。因此，边界映射作为恒等映射：$\\rho_N(k)=k$ 和 $\\rho_M(\\ell)=\\ell$。映射后的邻居索引就是 $(i+\\Delta i, j+\\Delta j)$。由于 $\\mathcal{N}$ 中的 8 个偏移量都是不同的，它们映射到 8 个不同的邻居索引。\n内部位点的不同邻居数量为 8。\n\n**2. 非角点边缘位点：**\n让我们考虑底部边缘上的一个位点 $(i,0)$，其中 $0  i  N-1$。对其他边缘的分析是对称的。\n任何试探性邻居的 i 坐标，$i+\\Delta i$，与内部位点一样，保持在 $[0, N-1]$ 的界限内，所以 $\\rho_N(i+\\Delta i) = i+\\Delta i$。\n试探性邻居的 j 坐标是 $j+\\Delta j = 0+\\Delta j$。\n边界映射 $\\rho_M$ 影响 j 坐标：\n- 对于 $\\Delta j = 1$，有 $0+1=1$，所以 $\\rho_M(1)=1$。\n- 对于 $\\Delta j = 0$，有 $0+0=0$，所以 $\\rho_M(0)=0$。\n- 对于 $\\Delta j = -1$，有 $0-1=-1$，所以 $\\rho_M(-1)=0$。\n\n我们列出 8 个偏移量 $(\\Delta i, \\Delta j)$ 中每一个的映射：\n- 行 $\\Delta j = 1$：$(-1,1) \\to (i-1,1)$；$(0,1) \\to (i,1)$；$(1,1) \\to (i+1,1)$。这给出了 3 个不同的邻居。\n- 行 $\\Delta j = 0$：$(-1,0) \\to (i-1,0)$；$(1,0) \\to (i+1,0)$。这给出了 2 个不同的邻居。\n- 行 $\\Delta j = -1$：$(-1,-1) \\to (i-1,0)$；$(0,-1) \\to (i,0)$；$(1,-1) \\to (i+1,0)$。这些映射到可能已经被列出的邻居。\n\n不同映射邻居索引的集合是：\n$\\{(i-1,1), (i,1), (i+1,1), (i-1,0), (i+1,0), (i,0)\\}$。\n索引 $(i-1,0)$ 是 $(-1,0)$ 和 $(-1,-1)$ 的像。\n索引 $(i+1,0)$ 是 $(1,0)$ 和 $(1,-1)$ 的像。\n索引 $(i,0)$（位点本身）是 $(0,-1)$ 的像。\n不同索引的总数是 $3+2+1 = 6$。\n非角点边缘位点的不同邻居数量为 6。\n\n**3. 角点位点：**\n让我们考虑角点位点 $(0,0)$。对其他角的分析是对称的。\n一个试探性邻居是 $(\\Delta i, \\Delta j)$。映射应用于两个坐标：$(\\rho_N(\\Delta i), \\rho_M(\\Delta j))$。\n- 对于 $\\Delta i \\in \\{-1,0,1\\}$：$\\rho_N(-1)=0, \\rho_N(0)=0, \\rho_N(1)=1$。\n- 对于 $\\Delta j \\in \\{-1,0,1\\}$：$\\rho_M(-1)=0, \\rho_M(0)=0, \\rho_M(1)=1$。\n\n我们列出 8 个偏移量中每一个的映射：\n- $(-1,1) \\to (\\rho_N(-1),\\rho_M(1))=(0,1)$\n- $(0,1) \\to (\\rho_N(0),\\rho_M(1))=(0,1)$\n- $(1,1) \\to (\\rho_N(1),\\rho_M(1))=(1,1)$\n- $(-1,0) \\to (\\rho_N(-1),\\rho_M(0))=(0,0)$\n- $(1,0) \\to (\\rho_N(1),\\rho_M(0))=(1,0)$\n- $(-1,-1) \\to (\\rho_N(-1),\\rho_M(-1))=(0,0)$\n- $(0,-1) \\to (\\rho_N(0),\\rho_M(-1))=(0,0)$\n- $(1,-1) \\to (\\rho_N(1),\\rho_M(-1))=(1,0)$\n\n不同映射邻居索引的集合是 $\\{(0,1), (1,1), (0,0), (1,0)\\}$。\n这个集合的基数是 4。\n角点位点的不同邻居数量为 4。\n\n总之，角点、非角点边缘和内部位点的不同邻居数量为 $(4, 6, 8)$。\n\n**第二部分：局部规则的修改和重数模式**\n\n依赖于邻居状态 $S$ 和权重 $w_{\\Delta i, \\Delta j}$ 的元胞 $(i,j)$ 的局部规则更新可以写成：\n$$\nS'_{i,j} = f\\left( \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}} w_{\\Delta i, \\Delta j} S(\\rho_N(i+\\Delta i), \\rho_M(j+\\Delta j)) \\right)\n$$\n为了用每个不同映射邻居 $(p,q)$ 的有效权重 $\\widehat{w}_{p,q}$ 来表示这个和，我们按目标索引对和中的项进行分组。设 $\\mathcal{V}_{i,j}$ 是位点 $(i,j)$ 的不同映射邻居的集合。设 $\\mathcal{N}_{i,j}(p,q)$ 是映射到特定邻居 $(p,q) \\in \\mathcal{V}_{i,j}$ 的偏移量集合：\n$$\n\\mathcal{N}_{i,j}(p,q) = \\{ (\\Delta i', \\Delta j') \\in \\mathcal{N} \\mid (\\rho_N(i+\\Delta i'), \\rho_M(j+\\Delta j')) = (p,q) \\}\n$$\n这个和可以重写为：\n$$\n\\sum_{(p,q) \\in \\mathcal{V}_{i,j}} \\left( \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}_{i,j}(p,q)} w_{\\Delta i, \\Delta j} \\right) S(p,q)\n$$\n通过将其与形式 $\\sum_{(p,q) \\in \\mathcal{V}_{i,j}} \\widehat{w}_{p,q} S(p,q)$ 进行比较，我们确定邻居 $(p,q)$ 上的有效权重为：\n$$\n\\widehat{w}_{p,q} = \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}_{i,j}(p,q)} w_{\\Delta i, \\Delta j}\n$$\n这个有效权重是所有映射到同一邻居索引 $(p,q)$ 的偏移量的原始权重之和。\n\n对于特化的均匀 Moore 核，$w_{\\Delta i, \\Delta j}=1$ 对所有 $(\\Delta i, \\Delta j) \\in \\mathcal{N}$ 成立。有效权重变成了映射后邻居 $(p,q)$ 的重数：\n$$\n\\widehat{w}_{p,q} = \\sum_{(\\Delta i, \\Delta j) \\in \\mathcal{N}_{i,j}(p,q)} 1 = |\\mathcal{N}_{i,j}(p,q)|\n$$\n\n使用第一部分中推导的映射，我们确定重数模式：\n\n**角点位点 $(0,0)$ 的重数模式：**\n不同的邻居是 $(0,0), (0,1), (1,0), (1,1)$。\n- $\\widehat{w}_{0,0}$：由 $(-1,0), (-1,-1), (0,-1)$ 映射而来。重数为 3。\n- $\\widehat{w}_{0,1}$：由 $(-1,1), (0,1)$ 映射而来。重数为 2。\n- $\\widehat{w}_{1,0}$：由 $(1,0), (1,-1)$ 映射而来。重数为 2。\n- $\\widehat{w}_{1,1}$：由 $(1,1)$ 映射而来。重数为 1。\n重数之和为 $3+2+2+1=8$。\n\n**非角点边缘位点 $(i,0)$ 的重数模式：**\n不同的邻居是 $\\{(i-1,1), (i,1), (i+1,1), (i-1,0), (i+1,0), (i,0)\\}$。\n- “远离边界”的邻居（行 $j=1$）：\n  - $\\widehat{w}_{i-1,1}$：由 $(-1,1)$ 映射而来。重数为 1。\n  - $\\widehat{w}_{i,1}$：由 $(0,1)$ 映射而来。重数为 1。\n  - $\\widehat{w}_{i+1,1}$：由 $(1,1)$ 映射而来。重数为 1。\n- “在边界上”的邻居（行 $j=0$）：\n  - $\\widehat{w}_{i-1,0}$：由 $(-1,0), (-1,-1)$ 映射而来。重数为 2。\n  - $\\widehat{w}_{i+1,0}$：由 $(1,0), (1,-1)$ 映射而来。重数为 2。\n  - $\\widehat{w}_{i,0}$：由 $(0,-1)$ 映射而来。重数为 1。\n重数之和为 $1+1+1+2+2+1=8$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  6  8\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了邻域的定义和边界处理后，我们便可以开始进行计算实验，探索元胞自动机规则所产生的复杂动力学。本实践引入了“损伤传播”（damage spreading）这一研究复杂系统动力学的经典方法，通过追踪一个微小扰动（单个细胞状态的翻转）在系统中的演化，来定量分析规则的宏观行为。你将通过编写程序模拟这一过程，并计算汉明距离（Hamming distance）的变化率，从而亲手揭示不同规则和邻域类型是如何将系统导向稳定、周期或混沌等不同状态的，这是理解元胞自动机中涌现行为的有力工具 。",
            "id": "4150722",
            "problem": "考虑一个在方形晶格上具有二元状态的二维细胞自动机 (CA)。一个细胞自动机 (CA) 由一个位点晶格、每个位点的邻域以及一个将邻域构型映射到位点新状态的局部更新规则来定义。在本问题中，位点取值为 $\\{0,1\\}$，晶格大小为 $N \\times N$，具有周期性边界条件（拓扑上是一个环面）。半径 $r=1$ 的 Moore 邻域包含其本身及 $8$ 个最近邻（共 $9$ 个位点），而半径 $r=1$ 的 von Neumann 邻域包含其本身及 $4$ 个正交邻居（共 $5$ 个位点）。两个二元构型之间的汉明距离 (HD) 是它们对应位点上状态不同的数量。损伤扩散通过演化两个初始仅在单个位点上存在差异的构型，并观察汉明距离随时间的变化来评估。\n\n基本定义：\n- 设晶格由 $(i,j)$ 索引，其中 $i \\in \\{0,1,\\dots,N-1\\}$ 且 $j \\in \\{0,1,\\dots,N-1\\}$，周期性边界条件意味着索引按模 $N$ 计算。\n- 设 $t$ 时刻的状态为 $X^{(t)} \\in \\{0,1\\}^{N \\times N}$，其受扰动的对应构型为 $Y^{(t)} \\in \\{0,1\\}^{N \\times N}$。\n- 将邻域和 $S_{\\mathcal{N}}(Z^{(t)},i,j)$ 定义为 $t$ 时刻位点 $(i,j)$ 邻域 $\\mathcal{N}$ 中所有位点（包括其自身）的状态之和。对于 Moore 邻域，邻域包含 $9$ 个位点；对于 von Neumann 邻域，邻域包含 $5$ 个位点。\n- 局部更新规则是总和性的：给定一个阈值 $\\theta$，更新函数 $f_{\\theta}$ 通过 $f_{\\theta}(s) = 1$（如果 $s \\ge \\theta$）和 $f_{\\theta}(s) = 0$（其他情况）将邻域和 $s$ 映射到一个新的位点值。\n- 演化是同步的：对所有 $(i,j)$，我们设置 $X^{(t+1)}_{i,j} = f_{\\theta}(S_{\\mathcal{N}}(X^{(t)},i,j))$ 和 $Y^{(t+1)}_{i,j} = f_{\\theta}(S_{\\mathcal{N}}(Y^{(t)},i,j))$。\n- $t$ 时刻的汉明距离为 $H(t) = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |X^{(t)}_{i,j} - Y^{(t)}_{i,j}|$。归一化汉明距离为 $h(t) = H(t)/N^2$。\n- 初始条件 $X^{(0)}$ 是一个确定性的棋盘格模式，定义为：如果 $(i+j) \\bmod 2 = 0$，则 $X^{(0)}_{i,j} = 1$；否则 $X^{(0)}_{i,j} = 0$。受扰动的构型 $Y^{(0)}$ 仅在中心位点 $(\\lfloor N/2 \\rfloor, \\lfloor N/2 \\rfloor)$ 与 $X^{(0)}$ 不同，其中 $Y^{(0)}_{\\lfloor N/2 \\rfloor,\\lfloor N/2 \\rfloor} = 1 - X^{(0)}_{\\lfloor N/2 \\rfloor,\\lfloor N/2 \\rfloor}$，而对于所有其他位点 $(i,j)$，$Y^{(0)}_{i,j} = X^{(0)}_{i,j}$。\n- 将 $T$ 个时间步内归一化损伤的线性增长率定义为 $g(N,T,\\theta,\\mathcal{N}) = \\big(h(T) - h(0)\\big)/T$。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 实现上述 CA，支持半径 $r=1$ 的 Moore 和 von Neumann 邻域、周期性边界以及带参数 $\\theta$ 的总和性阈值规则。\n- 将构型对 $X^{(t)}$ 和 $Y^{(t)}$ 从 $t=0$ 演化到 $t=T$，并计算 $h(0)$、$h(T)$ 和 $g(N,T,\\theta,\\mathcal{N})$。\n- 对于下面测试套件中的每个测试用例，以浮点数形式输出 $g(N,T,\\theta,\\mathcal{N})$ 的值。\n\n测试套件：\n- 用例 $1$：$N=64$， $T=50$， $\\theta=5$， $\\mathcal{N}=$ Moore。\n- 用例 $2$：$N=1$， $T=10$， $\\theta=5$， $\\mathcal{N}=$ Moore。\n- 用例 $3$：$N=32$， $T=10$， $\\theta=0$， $\\mathcal{N}=$ Moore。\n- 用例 $4$：$N=64$， $T=50$， $\\theta=3$， $\\mathcal{N}=$ von Neumann。\n- 用例 $5$：$N=32$， $T=100$， $\\theta=9$， $\\mathcal{N}=$ Moore。\n- 用例 $6$：$N=2$， $T=20$， $\\theta=4$， $\\mathcal{N}=$ Moore。\n\n覆盖性设计：\n- 用例 1 是一个一般情况，用于在一个相当大的晶格上，在中等时间内，测试 Moore 邻域的严格多数规则（$\\theta=5$）。\n- 用例 2 是一个边界情况，使用最小晶格 $N=1$。\n- 用例 3 使用一个极端阈值 $\\theta=0$，该阈值会立即将所有位点强制为 $1$。\n- 用例 4 使用 von Neumann 邻域与 Moore 邻域进行对比，其阈值为 $5$ 位点邻域的多数阈值。\n- 用例 5 使用一个极端阈值 $\\theta=9$，该规则仅在所有 $9$ 个位点都为 $1$ 时才激活。\n- 用例 6 使用一个小晶格 $N=2$，用以探查 Moore 邻域的环绕效应。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上面列出的测试用例顺序一致。例如，输出必须为 $\\big[ g_1, g_2, g_3, g_4, g_5, g_6 \\big]$ 的形式，其中 $g_k$ 是为用例 $k$ 计算出的浮点数。\n- 本问题不涉及物理单位。所有输出必须是无量纲的浮点数。",
            "solution": "用户提供了一个有效的问题陈述。任务是针对几个指定的参数集，计算一个二维细胞自动机 (CA) 中归一化损伤的线性增长率。该问题定义明确，科学上合理，并为确定性模拟提供了所有必要的组成部分。\n\n解决方案涉及在 $T$ 个时间步内模拟两个细胞自动机网格 $X$ 和 $Y$ 的演化。模拟的核心组件包括晶格表示、带周期性边界条件的邻域和的实现、更新规则的同步应用以及指定度量的计算。\n\n**1. 晶格、状态和邻域**\n\n该 CA 定义在一个 $N \\times N$ 的方形晶格上，其中每个位点 $(i,j)$ 可以处于两种状态 $\\{0, 1\\}$ 之一。原始构型 $X^{(t)}$ 和受扰动构型 $Y^{(t)}$ 这两个构型表示为 $N \\times N$ 的数值数组。\n\n更新规则是总和性的，意味着它仅取决于一个位点邻域内的状态之和。指定的两个邻域是半径 $r=1$ 的 Moore 邻域和 von Neumann 邻域：\n- **Moore 邻域**包括位点本身及其 $8$ 个相邻邻居（水平、垂直和对角线方向）。总和是针对 $9$ 个位点计算的。\n- **von Neumann 邻域**包括位点本身及其 $4$ 个正交邻居（水平和垂直方向）。总和是针对 $5$ 个位点计算的。\n\n**2. 通过卷积计算邻域和**\n\n对于整个晶格，每个位点 $(i,j)$ 的邻域和 $S_{\\mathcal{N}}(Z^{(t)},i,j)$ 可以通过二维卷积高效计算。晶格与一个代表邻域结构的核进行卷积。周期性边界条件通过执行循环或包裹卷积来处理。\n\n- 对于 Moore 邻域，卷积核是一个 $3 \\times 3$ 的全一矩阵：\n$$\nK_{\\text{Moore}} = \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix}\n$$\n- 对于 von Neumann 邻域，卷积核是一个表示十字形的 $3 \\times 3$ 矩阵：\n$$\nK_{\\text{vN}} = \\begin{pmatrix} 0  1  0 \\\\ 1  1  1 \\\\ 0  1  0 \\end{pmatrix}\n$$\n网格 $Z^{(t)}$ 与核 $K$ 的卷积产生一个新网格，其中每个元素 $(i,j)$ 是邻域和 $S_{\\mathcal{N}}(Z^{(t)},i,j)$。这是通过使用 `scipy.signal.convolve2d` 并设置 `mode='same'` 和 `boundary='wrap'` 来实现的。\n\n**3. 初始条件**\n\n在时间 $t=0$ 时，初始构型 $X^{(0)}$ 是一个棋盘格模式。对于一个位点 $(i,j)$，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$，其状态由以下公式给出：\n$$\nX^{(0)}_{i,j} = \\begin{cases} 1  \\text{if } (i+j) \\bmod 2 = 0 \\\\ 0  \\text{if } (i+j) \\bmod 2 = 1 \\end{cases}\n$$\n受扰动的构型 $Y^{(0)}$ 与 $X^{(0)}$ 完全相同，除了中心位点 $c = (\\lfloor N/2 \\rfloor, \\lfloor N/2 \\rfloor)$ 的状态被翻转：\n$$\nY^{(0)}_{c} = 1 - X^{(0)}_{c}\n$$\n\n**4. 同步演化**\n\nCA 以离散时间步进行演化。在每一步 $t$，所有位点 $(i,j)$ 在下一个时间步 $t+1$ 的状态都是基于晶格的当前状态同时计算的。更新规则是一个阈值函数 $f_{\\theta}$：\n$$\nZ^{(t+1)}_{i,j} = f_{\\theta}(S_{\\mathcal{N}}(Z^{(t)},i,j)) = \\begin{cases} 1  \\text{if } S_{\\mathcal{N}}(Z^{(t)},i,j) \\ge \\theta \\\\ 0  \\text{if } S_{\\mathcal{N}}(Z^{(t)},i,j)  \\theta \\end{cases}\n$$\n该规则应用于网格 $X^{(t)}$ 和 $Y^{(t)}$，以生成 $X^{(t+1)}$ 和 $Y^{(t+1)}$。模拟通过将此过程迭代 $T$ 步来进行。\n\n**5. 损伤增长率计算**\n\n损伤由汉明距离 $H(t)$ 量化，即 $X^{(t)}$ 和 $Y^{(t)}$ 之间状态不同的位点数。归一化汉明距离 $h(t)$ 是 $H(t)/N^2$。\n$$\nH(t) = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |X^{(t)}_{i,j} - Y^{(t)}_{i,j}|\n$$\n$$\nh(t) = \\frac{H(t)}{N^2}\n$$\n初始归一化损伤 $h(0)$ 是根据 $X^{(0)}$ 和 $Y^{(0)}$ 计算的。由于它们仅在一个位点上不同，因此 $H(0)=1$ 且 $h(0)=1/N^2$。经过 $T$ 步后，最终归一化损伤 $h(T)$ 是根据最终构型 $X^{(T)}$ 和 $Y^{(T)}$ 计算的。\n\n归一化损伤的线性增长率 $g$ 则计算如下：\n$$\ng(N,T,\\theta,\\mathcal{N}) = \\frac{h(T) - h(0)}{T}\n$$\n该度量表示在模拟周期内，每个时间步归一化损伤的平均变化。\n\n每个测试用例的整体算法如下：\n1.  根据邻域类型 $\\mathcal{N}$ 选择适当的卷积核。\n2.  根据晶格大小 $N$ 生成初始构型 $X^{(0)}$ 和 $Y^{(0)}$。\n3.  计算初始归一化汉明距离 $h(0)$。\n4.  循环 $T$ 个时间步：\n    a. 使用卷积为 $X^{(t)}$ 和 $Y^{(t)}$ 计算邻域和网格。\n    b. 应用带参数 $\\theta$ 的阈值规则得到 $X^{(t+1)}$ 和 $Y^{(t+1)}$。\n5.  循环结束后，计算最终归一化汉明距离 $h(T)$。\n6.  使用上述公式计算增长率 $g$。\n对问题陈述中提供的所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Computes the linear growth rate of normalized damage for a 2D cellular automaton\n    based on a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (N, T, theta, Neighborhood_type)\n    test_cases = [\n        (64, 50, 5, \"Moore\"),\n        (1, 10, 5, \"Moore\"),\n        (32, 10, 0, \"Moore\"),\n        (64, 50, 3, \"von Neumann\"),\n        (32, 100, 9, \"Moore\"),\n        (2, 20, 4, \"Moore\"),\n    ]\n\n    results = []\n    \n    # Define neighborhood kernels\n    kernels = {\n        \"Moore\": np.ones((3, 3), dtype=int),\n        \"von Neumann\": np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=int)\n    }\n\n    for N, T, theta, N_type in test_cases:\n        # 1. Select the appropriate kernel\n        kernel = kernels[N_type]\n\n        # 2. Generate initial configurations X_0 and Y_0\n        # The base configuration X_0 is a checkerboard pattern.\n        # X_ij = 1 if (i+j) is even, 0 otherwise.\n        if N > 0:\n            indices = np.arange(N)\n            i, j = np.meshgrid(indices, indices, indexing='ij')\n            X = ((i + j) % 2 == 0).astype(int)\n        else:\n            # Handle N=0 case if it were possible, though problem constraints imply N>=1\n            X = np.empty((0,0), dtype=int)\n\n        # The perturbed configuration Y_0 differs at the central site.\n        Y = X.copy()\n        if N > 0:\n            center_idx = N // 2\n            Y[center_idx, center_idx] = 1 - Y[center_idx, center_idx]\n        \n        # 3. Calculate initial normalized Hamming distance h(0)\n        n_squared = N * N\n        if n_squared > 0:\n            h0 = np.sum(np.abs(X - Y)) / n_squared\n        else:\n            h0 = 0.0\n\n        # If T=0, growth rate is ill-defined, but for compliance we can set it to 0.\n        # Problem statement implies T > 0.\n        if T == 0:\n            results.append(0.0)\n            continue\n\n        # 4. Evolve the configurations for T steps\n        X_t, Y_t = X, Y\n        for _ in range(T):\n            # Compute neighborhood sums using convolution with periodic boundaries\n            sum_X = convolve2d(X_t, kernel, mode='same', boundary='wrap')\n            sum_Y = convolve2d(Y_t, kernel, mode='same', boundary='wrap')\n            \n            # Apply the totalistic threshold rule\n            X_t = (sum_X >= theta).astype(int)\n            Y_t = (sum_Y >= theta).astype(int)\n\n        # 5. Calculate final normalized Hamming distance h(T)\n        if n_squared > 0:\n            hT = np.sum(np.abs(X_t - Y_t)) / n_squared\n        else:\n            hT = 0.0\n\n        # 6. Compute the linear growth rate g\n        g = (hT - h0) / T\n        results.append(g)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}