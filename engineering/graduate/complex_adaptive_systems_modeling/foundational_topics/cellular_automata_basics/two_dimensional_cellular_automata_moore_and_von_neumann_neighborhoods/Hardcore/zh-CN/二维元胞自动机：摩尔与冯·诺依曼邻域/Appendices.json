{
    "hands_on_practices": [
        {
            "introduction": "在深入研究元胞自动机的动态行为之前，首先必须对邻域的基本几何特性有一个牢固的理解。摩尔邻域（对应$L_\\infty$范数）和冯·诺依曼邻域（对应$L_1$范数）是二维元胞自动机中最常见的两种定义，它们在局部信息传播方面有着根本的不同。这项练习  旨在通过第一性原理推导，量化这两种邻域的大小，并分析其在不同尺度下的关系，为后续的动态建模打下坚实的数学基础。",
            "id": "4150733",
            "problem": "考虑一个在无限整数格 $\\mathbb{Z}^{2}$ 上的二维元胞自动机 (CA)。对于一个位于原点的固定中心元胞，基于标准范数定义两种半径为 $r$（$r \\geq 1$ 为整数）的邻域：\n- 半径为 $r$ 的摩尔邻域（Moore neighborhood）包含所有格点 $\\{(i,j) \\in \\mathbb{Z}^{2} : \\max(|i|,|j|) \\leq r\\}$。\n- 半径为 $r$ 的冯·诺依曼邻域（von Neumann neighborhood）包含所有格点 $\\{(i,j) \\in \\mathbb{Z}^{2} : |i| + |j| \\leq r\\}$。\n\n在元胞自动机模型中，一个元胞的邻域传统上不包括该元胞本身。仅使用上述核心定义和在 $\\mathbb{Z}^{2}$ 上的第一性原理计数论证（不调用任何预先推导的公式），推导出每种邻域中邻居数量作为 $r$ 的函数的精确值，构建摩尔邻域邻居数与冯·诺依曼邻域邻居数的比率，并分析当 $r \\to \\infty$ 时其渐近行为。将最终结果报告为一个精确的实数，该实数既能表示该比率，又能表示其渐近极限。无需四舍五入。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 定义域：一个在无限整数格 $\\mathbb{Z}^{2}$ 上的二维元胞自动机。\n- 中心元胞：位于原点 $(0,0)$。\n- 半径参数：$r$ 是一个整数，满足 $r \\geq 1$。\n- 半径为 $r$ 的摩尔邻域（包括中心元胞）：所有格点的集合 $\\{(i,j) \\in \\mathbb{Z}^{2} : \\max(|i|,|j|) \\leq r\\}$。\n- 半径为 $r$ 的冯·诺依曼邻域（包括中心元胞）：所有格点的集合 $\\{(i,j) \\in \\mathbb{Z}^{2} : |i| + |j| \\leq r\\}$。\n- 邻居的定义：一个元胞的邻域不包括该元胞本身。\n- 任务：推导出每种邻域类型的邻居数量作为 $r$ 的函数，求出摩尔邻域计数与冯·诺依曼邻域计数的比率，并确定当 $r \\to \\infty$ 时此比率的渐近极限。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题在元胞自动机理论的背景下，使用了摩尔邻域和冯·诺依曼邻域的标准、公认定义。这些定义分别对应于切比雪夫范数（$L_\\infty$）和曼哈顿范数（$L_1$）下的半径为 $r$ 的球体。这些概念是离散数学和复杂系统建模的基础。该问题具有科学合理性。\n- **适定性：** 该问题提供了清晰、明确的定义和一组精确的任务。约束条件是自洽的，并且可以从所提供的信息中推导出一个唯一且有意义的解。\n- **客观性：** 该问题以形式化的数学语言陈述，不含任何主观性或意见。\n\n### 步骤 3：结论与行动\n该问题是有效的。它具有科学依据，适定且客观。可以进行求解过程。\n\n### 邻居数量的推导\n\n设 $N_M(r)$ 为半径为 $r$ 的摩尔邻域中的邻居数量，设 $N_V(r)$ 为半径为 $r$ 的冯·诺依曼邻域中的邻居数量。问题规定邻域不包括中心元胞。\n\n**1. 摩尔邻域计数**\n\n*包括*中心元胞的摩尔邻域是点集 $(i,j) \\in \\mathbb{Z}^{2}$，满足 $\\max(|i|, |j|) \\leq r$。此条件等价于要求 $|i| \\leq r$ 和 $|j| \\leq r$ 同时成立。\n这意味着坐标 $i$ 可以取从 $-r$ 到 $r$ 的任意整数值，坐标 $j$ 也是如此。\n坐标 $i$ 可能的整数值的数量是 $r - (-r) + 1 = 2r+1$。\n坐标 $j$ 可能的整数值的数量也是 $2r+1$。\n包括中心在内的摩尔邻域中的总元胞数是这些坐标组合的总数，这在格上形成一个方形网格。\n总元胞数（包括中心）= $(2r+1)(2r+1) = (2r+1)^{2}$。\n\n为了求得邻居数量 $N_M(r)$，我们减去中心元胞 $(0,0)$。\n$$N_M(r) = (2r+1)^{2} - 1$$\n$$N_M(r) = (4r^{2} + 4r + 1) - 1$$\n$$N_M(r) = 4r^{2} + 4r$$\n\n**2. 冯·诺依曼邻域计数**\n\n*包括*中心元胞的冯·诺依曼邻域是点集 $(i,j) \\in \\mathbb{Z}^{2}$，满足 $|i| + |j| \\leq r$。为了从第一性原理出发对这些点进行计数，我们可以将定义为 $|i| + |j| = k$（$k$ 为从 $0$ 到 $r$ 的整数）的同心“菱形”壳层上的点数相加。\n\n对于 $k=0$，方程 $|i| + |j| = 0$ 的唯一解是 $(i,j)=(0,0)$。这给出了 $1$ 个元胞（中心）。\n\n对于任意 $k > 0$，我们计算满足 $|i| + |j| = k$ 的整数点数量。\n让我们考虑第一象限，其中 $i > 0$ 且 $j > 0$。方程为 $i+j=k$。解为 $(1, k-1), (2, k-2), \\dots, (k-1, 1)$。共有 $k-1$ 个这样的点。\n根据对称性，四个开放象限中各有 $k-1$ 个点。这给出了 $4(k-1)$ 个点。\n此外，坐标轴上也有点。它们是 $(\\pm k, 0)$ 和 $(0, \\pm k)$。共有 $4$ 个这样的点。\n对于给定的 $k>0$，壳层上的总点数为 $4(k-1) + 4 = 4k - 4 + 4 = 4k$。\n\n包括中心在内的冯·诺依曼邻域中的总元胞数是每个壳层（从 $k=0$ 到 $k=r$）的计数之和。\n总元胞数（包括中心）= ($k=0$ 的计数) + $\\sum_{k=1}^{r}$ (壳层 $k$ 的计数)\n$$ \\text{总元胞数} = 1 + \\sum_{k=1}^{r} 4k $$\n使用前 $r$ 个整数求和公式 $\\sum_{k=1}^{r} k = \\frac{r(r+1)}{2}$：\n$$ \\text{总元胞数} = 1 + 4 \\left( \\frac{r(r+1)}{2} \\right) = 1 + 2r(r+1) = 1 + 2r^{2} + 2r $$\n为了求得邻居数量 $N_V(r)$，我们减去中心元胞。\n$$ N_V(r) = (1 + 2r^{2} + 2r) - 1 $$\n$$ N_V(r) = 2r^{2} + 2r $$\n\n**3. 比率与渐近分析**\n\n现在，我们构建摩尔邻域邻居数与冯·诺依曼邻域邻居数的比率 $R(r)$，其中 $r \\geq 1$。\n$$ R(r) = \\frac{N_M(r)}{N_V(r)} = \\frac{4r^{2} + 4r}{2r^{2} + 2r} $$\n对于 $r \\geq 1$，分母 $2r^{2} + 2r = 2r(r+1)$ 非零。我们可以对分子和分母进行因式分解：\n$$ R(r) = \\frac{4r(r+1)}{2r(r+1)} $$\n由于 $r \\geq 1$，$r$ 和 $r+1$ 均非零，因此可以消去：\n$$ R(r) = \\frac{4}{2} = 2 $$\n对于所有整数 $r \\geq 1$，该比率恰好为 $2$。\n\n最后，我们分析当 $r \\to \\infty$ 时该比率的渐近行为。由于对于所有 $r \\geq 1$，该比率是一个常数函数 $R(r)=2$，其极限就是这个常数值。\n$$ \\lim_{r \\to \\infty} R(r) = \\lim_{r \\to \\infty} 2 = 2 $$\n这个结果也可以通过分析多项式的首项得到：\n$$ \\lim_{r \\to \\infty} \\frac{4r^{2} + 4r}{2r^{2} + 2r} = \\lim_{r \\to \\infty} \\frac{r^{2}(4 + \\frac{4}{r})}{r^{2}(2 + \\frac{2}{r})} = \\frac{4+0}{2+0} = 2 $$\n问题要求用一个单一的精确实数来表示该比率及其渐近极限。由于对于所有 $r \\geq 1$，该比率是恒定的且等于其极限，所以这个数是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "掌握了邻域的静态几何特性后，我们自然会转向探索其对系统动力学的影响。这项动手实践  将指导您构建一个元胞自动机模拟，以研究“损伤扩散”现象——这是衡量系统对微小扰动敏感度的关键概念。通过模拟并比较在不同邻域和规则下初始单点扰动的演化过程，您将亲眼见证局部相互作用结构如何塑造全局的涌现行为。",
            "id": "4150722",
            "problem": "考虑一个具有二进制状态的方形晶格上的二维元胞自动机（CA）。一个元胞自动机（CA）由一个由元胞组成的晶格、每个元胞的邻域以及一个将邻域配置映射到元胞新状态的局部更新规则来定义。在本问题中，元胞取值为 $\\{0,1\\}$，晶格大小为 $N \\times N$，具有周期性边界条件（拓扑上是一个环面）。半径 $r=1$ 的 Moore 邻域包含最近的 $8$ 个邻居及元胞本身（共 $9$ 个元胞），而半径 $r=1$ 的 von Neumann 邻域包含 $4$ 个正交邻居及元胞本身（共 $5$ 个元胞）。两个二进制配置之间的汉明距离（HD）是它们状态不同的元胞数量。损伤扩散通过演化两个初始仅在单个元胞上不同的配置，并观察汉明距离随时间的变化来评估。\n\n基本定义：\n- 设晶格由 $(i,j)$ 索引，其中 $i \\in \\{0,1,\\dots,N-1\\}$ 且 $j \\in \\{0,1,\\dots,N-1\\}$，周期性边界条件意味着索引按模 $N$ 计算。\n- 设时间 $t$ 的状态为 $X^{(t)} \\in \\{0,1\\}^{N \\times N}$，其扰动对应物为 $Y^{(t)} \\in \\{0,1\\}^{N \\times N}$。\n- 定义邻域和 $S_{\\mathcal{N}}(Z^{(t)},i,j)$ 为时间 $t$ 时 $(i,j)$ 邻域 $\\mathcal{N}$ 中（包括该元胞本身）的状态之和。对于 Moore 邻域，邻域包含 $9$ 个元胞；对于 von Neumann 邻域，邻域包含 $5$ 个元胞。\n- 局部更新规则是全同的（totalistic）：给定一个阈值 $\\theta$，更新函数 $f_{\\theta}$ 通过 $f_{\\theta}(s) = 1$ (如果 $s \\ge \\theta$) 和 $f_{\\theta}(s) = 0$ (其他情况) 将邻域和 $s$ 映射到一个新的元胞值。\n- 演化是同步的：对于所有 $(i,j)$，我们设置 $X^{(t+1)}_{i,j} = f_{\\theta}(S_{\\mathcal{N}}(X^{(t)},i,j))$ 和 $Y^{(t+1)}_{i,j} = f_{\\theta}(S_{\\mathcal{N}}(Y^{(t)},i,j))$。\n- 时间 $t$ 的汉明距离为 $H(t) = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |X^{(t)}_{i,j} - Y^{(t)}_{i,j}|$。归一化汉明距离为 $h(t) = H(t)/N^2$。\n- 初始条件 $X^{(0)}$ 是一个确定的棋盘格模式，定义为 $X^{(0)}_{i,j} = 1$ (如果 $(i+j) \\bmod 2 = 0$) 和 $X^{(0)}_{i,j} = 0$ (其他情况)。扰动配置 $Y^{(0)}$ 仅在中心元胞 $(\\lfloor N/2 \\rfloor, \\lfloor N/2 \\rfloor)$ 与 $X^{(0)}$ 不同，其中 $Y^{(0)}_{\\lfloor N/2 \\rfloor,\\lfloor N/2 \\rfloor} = 1 - X^{(0)}_{\\lfloor N/2 \\rfloor,\\lfloor N/2 \\rfloor}$，而对于所有其他 $(i,j)$，有 $Y^{(0)}_{i,j} = X^{(0)}_{i,j}$。\n- 定义归一化损伤在 $T$ 步内的线性增长率为 $g(N,T,\\theta,\\mathcal{N}) = \\big(h(T) - h(0)\\big)/T$。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 实现上述 CA，支持半径 $r=1$ 的 Moore 和 von Neumann 邻域、周期性边界以及带参数 $\\theta$ 的全同阈值规则。\n- 将配置对 $X^{(t)}$ 和 $Y^{(t)}$ 从 $t=0$ 演化到 $t=T$，并计算 $h(0)$、$h(T)$ 和 $g(N,T,\\theta,\\mathcal{N})$。\n- 对于下面测试套件中的每个测试用例，以浮点数形式输出 $g(N,T,\\theta,\\mathcal{N})$ 的值。\n\n测试套件：\n- 用例 $1$：$N=64$， $T=50$， $\\theta=5$， $\\mathcal{N}=$ Moore。\n- 用例 $2$：$N=1$， $T=10$， $\\theta=5$， $\\mathcal{N}=$ Moore。\n- 用例 $3$：$N=32$， $T=10$， $\\theta=0$， $\\mathcal{N}=$ Moore。\n- 用例 $4$：$N=64$， $T=50$， $\\theta=3$， $\\mathcal{N}=$ von Neumann。\n- 用例 $5$：$N=32$， $T=100$， $\\theta=9$， $\\mathcal{N}=$ Moore。\n- 用例 $6$：$N=2$， $T=20$， $\\theta=4$， $\\mathcal{N}=$ Moore。\n\n覆盖性设计：\n- 用例 1 是一个通用情况，在一个相当大的晶格上，在中等时间内，使用 Moore 邻域和严格多数阈值（$\\theta=5$）。\n- 用例 2 是一个边界情况，使用最小晶格 $N=1$。\n- 用例 3 是一个极端阈值 $\\theta=0$，会立即将所有元胞强制为 $1$。\n- 用例 4 使用 von Neumann 邻域与 Moore 邻域进行对比，采用适用于 $5$ 元胞邻域的多数阈值。\n- 用例 5 是一个极端阈值 $\\theta=9$，仅当所有 $9$ 个元胞都为 $1$ 时才会激活。\n- 用例 6 是一个小晶格 $N=2$，用于探测 Moore 邻域的环绕效应。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上面列出的测试用例相同。例如，输出必须是 $\\big[ g_1, g_2, g_3, g_4, g_5, g_6 \\big]$ 的形式，其中 $g_k$ 是为用例 $k$ 计算出的浮点数。\n- 本问题不涉及物理单位。所有输出必须是无量纲的浮点数。",
            "solution": "用户提供了一个有效的问题陈述。任务是为一个二维元胞自动机（CA）计算在几个指定参数集下的归一化损伤线性增长率。该问题定义明确，科学上合理，并为确定性模拟提供了所有必要的组件。\n\n解决方案涉及在 $T$ 个时间步长内模拟两个元胞自动机网格 $X$ 和 $Y$ 的演化。模拟的核心组件是晶格表示、带周期性边界条件的邻域和实现、更新规则的同步应用以及指定度量的计算。\n\n**1. 晶格、状态和邻域**\n\nCA 定义在一个 $N \\times N$ 的方形晶格上，其中每个元胞 $(i,j)$ 可以处于两种状态 $\\{0, 1\\}$ 之一。两种配置，原始的 $X^{(t)}$ 和扰动的 $Y^{(t)}$，被表示为 $N \\times N$ 的数值数组。\n\n更新规则是全同的，意味着它仅依赖于一个元胞邻域内的状态之和。指定的两个邻域是半径 $r=1$ 的 Moore 和 von Neumann 邻域：\n- **Moore 邻域**包含元胞本身及其 $8$ 个相邻邻居（水平、垂直和对角）。总和是对 $9$ 个元胞进行的。\n- **von Neumann 邻域**包含元胞本身及其 $4$ 个正交邻居（水平和垂直）。总和是对 $5$ 个元胞进行的。\n\n**2. 通过卷积计算邻域和**\n\n每个元胞 $(i,j)$ 的邻域和 $S_{\\mathcal{N}}(Z^{(t)},i,j)$ 可以通过二维卷积高效地为整个晶格计算。晶格与一个代表邻域结构的核（kernel）进行卷积。周期性边界条件通过执行循环或环绕卷积来处理。\n\n- 对于 Moore 邻域，卷积核是一个 $3 \\times 3$ 的全一矩阵：\n$$\nK_{\\text{Moore}} = \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix}\n$$\n- 对于 von Neumann 邻域，卷积核是一个代表十字形的 $3 \\times 3$ 矩阵：\n$$\nK_{\\text{vN}} = \\begin{pmatrix} 0  1  0 \\\\ 1  1  1 \\\\ 0  1  0 \\end{pmatrix}\n$$\n将网格 $Z^{(t)}$ 与核 $K$ 进行卷积，会得到一个新的网格，其中每个元素 $(i,j)$ 是邻域和 $S_{\\mathcal{N}}(Z^{(t)},i,j)$。这通过使用 `scipy.signal.convolve2d` 并设置 `mode='same'` 和 `boundary='wrap'` 来实现。\n\n**3. 初始条件**\n\n在时间 $t=0$ 时，初始配置 $X^{(0)}$ 是一个棋盘格模式。对于一个位于 $(i,j)$ 的元胞，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$，其状态由以下公式给出：\n$$\nX^{(0)}_{i,j} = \\begin{cases} 1  \\text{if } (i+j) \\bmod 2 = 0 \\\\ 0  \\text{if } (i+j) \\bmod 2 = 1 \\end{cases}\n$$\n扰动配置 $Y^{(0)}$ 与 $X^{(0)}$ 相同，除了中心元胞 $c = (\\lfloor N/2 \\rfloor, \\lfloor N/2 \\rfloor)$，其状态被翻转：\n$$\nY^{(0)}_{c} = 1 - X^{(0)}_{c}\n$$\n\n**4. 同步演化**\n\nCA 在离散的时间步长上演化。在每个步骤 $t$，下一个时间步 $t+1$ 的每个元胞 $(i,j)$ 的状态都基于晶格的当前状态同时计算。更新规则是一个阈值函数 $f_{\\theta}$：\n$$\nZ^{(t+1)}_{i,j} = f_{\\theta}(S_{\\mathcal{N}}(Z^{(t)},i,j)) = \\begin{cases} 1  \\text{if } S_{\\mathcal{N}}(Z^{(t)},i,j) \\ge \\theta \\\\ 0  \\text{if } S_{\\mathcal{N}}(Z^{(t)},i,j)  \\theta \\end{cases}\n$$\n此规则应用于两个网格 $X^{(t)}$ 和 $Y^{(t)}$，以生成 $X^{(t+1)}$ 和 $Y^{(t+1)}$。模拟通过迭代此过程 $T$ 步来进行。\n\n**5. 损伤增长率计算**\n\n损伤由汉明距离 $H(t)$ 量化，即 $X^{(t)}$ 和 $Y^{(t)}$ 状态不同的元胞数。归一化汉明距离 $h(t)$ 为 $H(t)/N^2$。\n$$\nH(t) = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |X^{(t)}_{i,j} - Y^{(t)}_{i,j}|\n$$\n$$\nh(t) = \\frac{H(t)}{N^2}\n$$\n初始归一化损伤 $h(0)$ 是从 $X^{(0)}$ 和 $Y^{(0)}$ 计算得出的。由于它们仅在一个元胞上不同，因此 $H(0)=1$ 且 $h(0)=1/N^2$。经过 $T$ 步后，最终的归一化损伤 $h(T)$ 是从最终配置 $X^{(T)}$ 和 $Y^{(T)}$ 计算得出的。\n\n然后，归一化损伤的线性增长率 $g$ 计算如下：\n$$\ng(N,T,\\theta,\\mathcal{N}) = \\frac{h(T) - h(0)}{T}\n$$\n此度量表示在模拟期间内每个时间步长归一化损伤的平均变化。\n\n每个测试用例的总体算法如下：\n1.  根据邻域类型 $\\mathcal{N}$ 选择合适的卷积核。\n2.  根据晶格大小 $N$ 生成初始配置 $X^{(0)}$ 和 $Y^{(0)}$。\n3.  计算初始归一化汉明距离 $h(0)$。\n4.  循环 $T$ 个时间步：\n    a. 使用卷积计算 $X^{(t)}$ 和 $Y^{(t)}$ 的邻域和网格。\n    b. 应用带参数 $\\theta$ 的阈值规则得到 $X^{(t+1)}$ 和 $Y^{(t+1)}$。\n5.  循环结束后，计算最终归一化汉明距离 $h(T)$。\n6.  使用上述公式计算增长率 $g$。\n对问题陈述中提供的所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Computes the linear growth rate of normalized damage for a 2D cellular automaton\n    based on a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (N, T, theta, Neighborhood_type)\n    test_cases = [\n        (64, 50, 5, \"Moore\"),\n        (1, 10, 5, \"Moore\"),\n        (32, 10, 0, \"Moore\"),\n        (64, 50, 3, \"von Neumann\"),\n        (32, 100, 9, \"Moore\"),\n        (2, 20, 4, \"Moore\"),\n    ]\n\n    results = []\n    \n    # Define neighborhood kernels\n    kernels = {\n        \"Moore\": np.ones((3, 3), dtype=int),\n        \"von Neumann\": np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=int)\n    }\n\n    for N, T, theta, N_type in test_cases:\n        # 1. Select the appropriate kernel\n        kernel = kernels[N_type]\n\n        # 2. Generate initial configurations X_0 and Y_0\n        # The base configuration X_0 is a checkerboard pattern.\n        # X_ij = 1 if (i+j) is even, 0 otherwise.\n        if N > 0:\n            indices = np.arange(N)\n            i, j = np.meshgrid(indices, indices, indexing='ij')\n            X = ((i + j) % 2 == 0).astype(int)\n        else:\n            # Handle N=0 case if it were possible, though problem constraints imply N>=1\n            X = np.empty((0,0), dtype=int)\n\n        # The perturbed configuration Y_0 differs at the central site.\n        Y = X.copy()\n        if N > 0:\n            center_idx = N // 2\n            Y[center_idx, center_idx] = 1 - Y[center_idx, center_idx]\n        \n        # 3. Calculate initial normalized Hamming distance h(0)\n        n_squared = N * N\n        if n_squared > 0:\n            h0 = np.sum(np.abs(X - Y)) / n_squared\n        else:\n            h0 = 0.0\n\n        # If T=0, growth rate is ill-defined, but for compliance we can set it to 0.\n        # Problem statement implies T > 0.\n        if T == 0:\n            results.append(0.0)\n            continue\n\n        # 4. Evolve the configurations for T steps\n        X_t, Y_t = X, Y\n        for _ in range(T):\n            # Compute neighborhood sums using convolution with periodic boundaries\n            sum_X = convolve2d(X_t, kernel, mode='same', boundary='wrap')\n            sum_Y = convolve2d(Y_t, kernel, mode='same', boundary='wrap')\n            \n            # Apply the totalistic threshold rule\n            X_t = (sum_X >= theta).astype(int)\n            Y_t = (sum_Y >= theta).astype(int)\n\n        # 5. Calculate final normalized Hamming distance h(T)\n        if n_squared > 0:\n            hT = np.sum(np.abs(X_t - Y_t)) / n_squared\n        else:\n            hT = 0.0\n\n        # 6. Compute the linear growth rate g\n        g = (hT - h0) / T\n        results.append(g)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "进行大规模元胞自动机模拟对计算效率提出了很高的要求，尤其是在复杂适应系统建模等研究领域。最后的这项练习  深入探讨了外总和规则（outer-totalistic rules）的高级实现技巧。您将学习如何利用离散卷积高效地计算邻域和，并使用向量化的位运算来应用更新规则，从而显著提升模拟性能，这对于任何严肃的元胞自动机建模工作都是一项至关重要的技能。",
            "id": "4150707",
            "problem": "考虑一个二维二进制元胞自动机（CA），其在离散时间 $t$ 的状态是一个矩阵 $X^{(t)} \\in \\{0,1\\}^{H \\times W}$，其中 $H$ 和 $W$ 是正整数。其更新规则是外总和型的：位置 $(i,j)$ 的下一状态取决于当前状态 $X^{(t)}_{i,j}$ 和存活邻居的总数 $S^{(t)}_{i,j}$，并根据诞生集和存活集来确定。使用以下基本概念：外总和型二维 CA 的定义，Moore 和 von Neumann 邻域的定义，以及与有限核的离散卷积。\n\n定义：\n- 半径为 $1$ 的 Moore 邻域包含以 $(i,j)$ 为中心的 $3 \\times 3$ 方块中的 $8$ 个周围位置。其关联的二进制核为\n$$\nK_{\\mathrm{M}} = \\begin{bmatrix}\n1  1  1 \\\\\n1  0  1 \\\\\n1  1  1\n\\end{bmatrix}.\n$$\n- 半径为 $1$ 的 von Neumann 邻域包含 $4$ 个基本方向上的邻居。其关联的二进制核为\n$$\nK_{\\mathrm{V}} = \\begin{bmatrix}\n0  1  0 \\\\\n1  0  1 \\\\\n0  1  0\n\\end{bmatrix}.\n$$\n- 邻居计数 $S^{(t)}$ 是 $X^{(t)}$ 与上述核之一的离散卷积，并使用指定的边界条件进行计算。对于一个核 $K$ 和状态 $X^{(t)}$，邻居计数满足\n$$\nS^{(t)} = X^{(t)} * K,\n$$\n其中 $*$ 表示二维离散卷积，边界处理方式为周期性环绕（wrap-around）或零填充（外部值等于 $0$）。\n\n外总和型更新规则：\n- 令 $\\mathcal{B} \\subset \\mathbb{N}$ 为诞生集，$\\mathcal{S} \\subset \\mathbb{N}$ 为存活集。下一状态定义如下\n$$\nX^{(t+1)}_{i,j} =\n\\begin{cases}\n1,  \\text{if } \\big(X^{(t)}_{i,j} = 0 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{B}\\big) \\text{ or } \\big(X^{(t)}_{i,j} = 1 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{S}\\big), \\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n\n任务：\n1. 通过将 $\\mathcal{B}$ 和 $\\mathcal{S}$ 编码为位掩码，推导出仅使用整数算术的外总和型更新表达式。具体来说，定义整数\n$$\nm_{\\mathcal{B}} = \\sum_{k \\in \\mathcal{B}} 2^k,\n\\quad\nm_{\\mathcal{S}} = \\sum_{k \\in \\mathcal{S}} 2^k,\n$$\n并证明对于每个位置 $(i,j)$，成员资格测试 $S^{(t)}_{i,j} \\in \\mathcal{B}$ 和 $S^{(t)}_{i,j} \\in \\mathcal{S}$ 可以通过使用每个位置的值 $b^{(t)}_{i,j} = 2^{S^{(t)}_{i,j}}$ 并进行位运算来实现。\n2. 使用上述方法，编写一个完整的程序，该程序：\n   - 使用整数算术通过与 $K_{\\mathrm{M}}$ 或 $K_{\\mathrm{V}}$ 进行离散卷积来计算 $S^{(t)}$，并遵守指定的边界条件：周期性环绕或零填充。\n   - 使用仅包含向量化整数运算的方式更新 CA 状态指定的步数：位与、位或、整数移位以及转换为二进制指示符的整数比较。\n   - 对每个提供的测试用例，返回 $T$ 步后存活元胞的总数（$X^{(T)}$ 中所有项的总和）。\n\n边界条件：\n- 周期性环绕：超出边界的索引对行应用模 $H$，对列应用模 $W$。\n- 零填充：任何在域外的访问均产生 $0$。\n\n角度单位和物理单位不适用，且不涉及任何物理量。\n\n测试套件：\n实现以下测试用例。对于每个用例，程序必须计算在指定的步数 $T$ 之后存活元胞的总数。\n\n- 用例 1（通用 Moore，周期性）：\n  - 邻域：Moore ($K_{\\mathrm{M}}$)。\n  - 边界：周期性环绕。\n  - 规则：Conway’s Game of Life 诞生/存活规则，$\\mathcal{B} = \\{3\\}$，$\\mathcal{S} = \\{2,3\\}$。\n  - 网格大小：$6 \\times 6$。\n  - 初始状态：一个滑翔机（glider）放置在远离边缘的位置，存活元胞坐标为 $(1,2)$, $(2,3)$, $(3,1)$, $(3,2)$, $(3,3)$；所有其他位置为 $0$。\n  - 步数：$T = 4$。\n\n- 用例 2（边界敏感性，Moore，零填充）：\n  - 邻域：Moore ($K_{\\mathrm{M}}$)。\n  - 边界：零填充。\n  - 规则：$\\mathcal{B} = \\{3\\}$，$\\mathcal{S} = \\{2,3\\}$。\n  - 网格大小：$6 \\times 6$。\n  - 初始状态：一个滑翔机（glider）靠近角落，存活元胞坐标为 $(0,1)$, $(1,2)$, $(2,0)$, $(2,1), (2,2)$；所有其他位置为 $0$。\n  - 步数：$T = 4$。\n\n- 用例 3（von Neumann，局部增长）：\n  - 邻域：von Neumann ($K_{\\mathrm{V}}$)。\n  - 边界：周期性环绕。\n  - 规则：$\\mathcal{B} = \\{1\\}$，$\\mathcal{S} = \\{1\\}$。\n  - 网格大小：$7 \\times 7$。\n  - 初始状态：中心 $(3,3)$ 处有一个存活元胞；所有其他位置为 $0$。\n  - 步数：$T = 2$。\n\n- 用例 4（空状态不变性）：\n  - 邻域：Moore ($K_{\\mathrm{M}}$)。\n  - 边界：周期性环绕。\n  - 规则：$\\mathcal{B} = \\{3\\}$，$\\mathcal{S} = \\{2,3\\}$。\n  - 网格大小：$5 \\times 5$。\n  - 初始状态：所有位置为 $0$。\n  - 步数：$T = 3$。\n\n- 用例 5（在 Game of Life 规则下完全灭绝）：\n  - 邻域：Moore ($K_{\\mathrm{M}}$)。\n  - 边界：周期性环绕。\n  - 规则：$\\mathcal{B} = \\{3\\}$，$\\mathcal{S} = \\{2,3\\}$。\n  - 网格大小：$4 \\times 4$。\n  - 初始状态：所有位置为 $1$。\n  - 步数：$T = 2$。\n\n- 用例 6（von Neumann，对称模式）：\n  - 邻域：von Neumann ($K_{\\mathrm{V}}$)。\n  - 边界：周期性环绕。\n  - 规则：$\\mathcal{B} = \\{2\\}$，$\\mathcal{S} = \\{2\\}$。\n  - 网格大小：$5 \\times 5$。\n  - 初始状态：一个以 $(2,2)$ 为中心的加号形状，存活元胞坐标为 $(2,2)$, $(1,2), $(3,2)$, $(2,1), $(2,3)$；所有其他位置为 $0$。\n  - 步数：$T = 1$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_k$ 是按上面列出的确切顺序，对应于用例 $k$ 在指定步数后存活元胞总数的整数值。输出中不允许包含任何额外文本。",
            "solution": "该问题是有效的，因为它在科学上基于元胞自动机理论，问题陈述清晰，所有必要参数均已指定，并使用客观、正式的语言进行阐述。它提出了一个标准的计算任务，并附带了具体的实现约束，这是对理解能力的一次有意义的测试。\n\n根据任务要求，解决方案分为两部分：首先推导整数算术更新规则，然后描述算法实现，该实现将在最终答案中提供。\n\n### 第一部分：位运算整数算术更新规则的推导\n\n在位置 $(i,j)$ 和时间 $t+1$ 的元胞状态，记为 $X^{(t+1)}_{i,j}$，由其当前状态 $X^{(t)}_{i,j} \\in \\{0, 1\\}$ 及其存活邻居的总数 $S^{(t)}_{i,j}$ 决定。更新由诞生集 $\\mathcal{B}$ 和存活集 $\\mathcal{S}$ 控制：\n$$\nX^{(t+1)}_{i,j} =\n\\begin{cases}\n1,  \\text{if } \\big(X^{(t)}_{i,j} = 0 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{B}\\big) \\text{ or } \\big(X^{(t)}_{i,j} = 1 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{S}\\big), \\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n这可以用逻辑运算符表示。设 $C_B$ 为诞生条件（$X^{(t)}_{i,j} = 0 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{B}$），$C_S$ 为存活条件（$X^{(t)}_{i,j} = 1 \\text{ and } S^{(t)}_{i,j} \\in \\mathcal{S}$）。由于一个元胞不能同时是死的（$X^{(t)}_{i,j} = 0$）和活的（$X^{(t)}_{i,j} = 1$），所以条件 $C_B$ 和 $C_S$ 是互斥的。因此，如果 $C_B \\lor C_S$ 为真，则下一状态为 $1$，否则为 $0$。\n\n我们的目标是仅使用整数算术和位运算来实现这些逻辑条件。问题引入了集合 $\\mathcal{B}$ 和 $\\mathcal{S}$ 的位掩码：\n$$\nm_{\\mathcal{B}} = \\sum_{k \\in \\mathcal{B}} 2^k, \\quad m_{\\mathcal{S}} = \\sum_{k \\in \\mathcal{S}} 2^k.\n$$\n以这种方式构造的整数 $m$，其第 $k$ 位为 $1$ 当且仅当 $k$ 是相应集合中的一个元素。例如，如果 $\\mathcal{B} = \\{3\\}$，那么 $m_{\\mathcal{B}} = 2^3 = 8$，其二进制表示为 `1000`。如果 $\\mathcal{S} = \\{2, 3\\}$，那么 $m_{\\mathcal{S}} = 2^2 + 2^3 = 4 + 8 = 12$，其二进制表示为 `1100`。\n\n成员资格测试 $s \\in \\mathcal{B}$ 可以通过检查 $m_{\\mathcal{B}}$ 的第 $s$ 位是否被置位来完成。设 $s = S^{(t)}_{i,j}$。我们可以构造一个只有第 $s$ 位被置位的整数：$b = 2^s$。这可以通过位移运算高效计算：$1 \\ll s$。\n$b$ 和 $m_{\\mathcal{B}}$ 之间的位与（AND）运算（用 `` 表示）将产生一个非零结果，当且仅当两个数的第 $s$ 位都被置位。由于 $b$ 只有第 $s$ 位被置位，这等价于检查 $m_{\\mathcal{B}}$ 中的第 $s$ 位是否被置位。因此，成员资格测试 $s \\in \\mathcal{B}$ 等价于整数表达式 $( (1 \\ll s) \\ \\text{}\\ \\ m_{\\mathcal{B}} ) \\neq 0$。\n\n我们定义两个指示函数，如果为真则值为 $1$，如果为假则值为 $0$：\n-   诞生资格指示函数：$I_{\\mathcal{B}}(s) = ((1 \\ll s) \\ \\text{}\\ \\ m_{\\mathcal{B}}) \\neq 0$\n-   存活资格指示函数：$I_{\\mathcal{S}}(s) = ((1 \\ll s) \\ \\text{}\\ \\ m_{\\mathcal{S}}) \\neq 0$\n\n现在，逻辑条件 $C_B$ 和 $C_S$ 可以使用整数状态 $\\{0,1\\}$ 上的算术运算来表示。如果一个元胞的状态是 $0$，则它是死的，这可以用 $(1 - X^{(t)}_{i,j})$ 来表示。如果一个元胞的状态是 $1$，则它是活的，这可以用 $X^{(t)}_{i,j}$ 来表示。\n\n-   诞生条件：一个死元胞在其邻居数在 $\\mathcal{B}$ 中时诞生。\n    $C_B \\equiv (1 - X^{(t)}_{i,j}) \\cdot I_{\\mathcal{B}}(S^{(t)}_{i,j})$\n-   存活条件：一个活元胞在其邻居数在 $\\mathcal{S}$ 中时存活。\n    $C_S \\equiv X^{(t)}_{i,j} \\cdot I_{\\mathcal{S}}(S^{(t)}_{i,j})$\n\n由于 $C_B$ 和 $C_S$ 是互斥的，下一状态 $X^{(t+1)}_{i,j}$ 是它们的和：\n$$\nX^{(t+1)}_{i,j} = (1 - X^{(t)}_{i,j}) \\cdot I_{\\mathcal{B}}(S^{(t)}_{i,j}) + X^{(t)}_{i,j} \\cdot I_{\\mathcal{S}}(S^{(t)}_{i,j})\n$$\n这个表达式只使用标准的整数算术（加法、减法、乘法）和隐藏在指示函数中的位运算。这个公式可以直接转换为对整个矩阵的向量化操作，从而实现高效计算。\n\n### 第二部分：算法设计\n\n该程序根据推导出的整数算术规则实现一个元胞自动机模拟器。算法的核心是一个迭代过程，该过程在指定的步数内更新网格状态。\n\n1.  **初始化**：对于每个测试用例，程序初始化一个大小为 $H \\times W$ 的二维整数数组 $X^{(0)}$，表示网格的初始状态。诞生集 $\\mathcal{B}$ 和存活集 $\\mathcal{S}$ 用于计算它们对应的整数位掩码 $m_{\\mathcal{B}}$ 和 $m_{\\mathcal{S}}$。选择合适的邻域核 $K_{\\mathrm{M}}$ 或 $K_{\\mathrm{V}}$。\n\n2.  **邻居计数**：在每一步 $t$，计算邻居总和矩阵 $S^{(t)}$。这是通过将当前状态矩阵 $X^{(t)}$ 与所选的核 $K$ 进行二维离散卷积来实现的。为此使用 `scipy.signal.convolve2d` 函数。该函数的 `mode` 参数设置为 `'same'` 以确保输出矩阵 $S^{(t)}$ 与 $X^{(t)}$ 具有相同的维度。边界条件由 `boundary` 参数处理：`'wrap'` 用于周期性边界，`'fill'` 和 `fillvalue=0` 用于零填充边界。\n\n3.  **状态更新**：使用 `numpy` 以向量化的方式，将推导出的位运算规则逐元素地应用于整个网格，从而将状态矩阵从 $X^{(t)}$ 更新到 $X^{(t+1)}$。操作序列如下：\n    a. 计算邻居计数矩阵 $S = S^{(t)}$。\n    b. 使用向量化的位移操作 `1  S` 计算位位置矩阵 $B = 2^S$。\n    c. 同时为所有位置评估诞生条件：`is_birth = ((B  m_B) != 0)`。\n    d. 为所有位置评估存活条件：`is_survival = ((B  m_S) != 0)`。\n    e. 通过将条件与当前状态 $X=X^{(t)}$ 相结合来计算下一状态矩阵 $X_{next}$。一个逻辑上清晰的方法是：\n    `born = (X == 0)  is_birth`\n    `survived = (X == 1)  is_survival`\n    `X_next = born | survived`\n    这可以转换为整数矩阵用于下一次迭代。\n\n4.  **迭代**：邻居计数和状态更新的过程重复 $T$ 次，其中 $T$ 是测试用例指定的步数。在每次迭代结束时，状态矩阵 $X$ 更新为 $X_{next}$。\n\n5.  **最终计算**：经过 $T$ 步后，获得最终状态矩阵 $X^{(T)}$。所需的结果是存活元胞的总数，通过对 $X^{(T)}$ 的所有元素求和来计算。\n\n对提供的六个测试用例中的每一个都执行此算法，并将得到的存活元胞计数收集并格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the cellular automata problem for all test cases.\n    \"\"\"\n\n    # Define neighborhood kernels.\n    K_M = np.array([\n        [1, 1, 1],\n        [1, 0, 1],\n        [1, 1, 1]\n    ], dtype=np.int8)\n\n    K_V = np.array([\n        [0, 1, 0],\n        [1, 0, 1],\n        [0, 1, 0]\n    ], dtype=np.int8)\n\n    kernels = {\n        'Moore': K_M,\n        'von Neumann': K_V\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'name': 'Case 1 (general Moore, periodic)',\n            'neighborhood': 'Moore',\n            'boundary': 'periodic',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (6, 6),\n            'initial_live_cells': [(1, 2), (2, 3), (3, 1), (3, 2), (3, 3)],\n            'steps': 4\n        },\n        {\n            'name': 'Case 2 (boundary sensitivity, Moore, zero-fill)',\n            'neighborhood': 'Moore',\n            'boundary': 'zero-fill',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (6, 6),\n            'initial_live_cells': [(0, 1), (1, 2), (2, 0), (2, 1), (2, 2)],\n            'steps': 4\n        },\n        {\n            'name': 'Case 3 (von Neumann, local growth)',\n            'neighborhood': 'von Neumann',\n            'boundary': 'periodic',\n            'rule_b': {1},\n            'rule_s': {1},\n            'grid_size': (7, 7),\n            'initial_live_cells': [(3, 3)],\n            'steps': 2\n        },\n        {\n            'name': 'Case 4 (empty invariance)',\n            'neighborhood': 'Moore',\n            'boundary': 'periodic',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (5, 5),\n            'initial_live_cells': [],\n            'steps': 3\n        },\n        {\n            'name': 'Case 5 (full extinction under Game of Life)',\n            'neighborhood': 'Moore',\n            'boundary': 'periodic',\n            'rule_b': {3},\n            'rule_s': {2, 3},\n            'grid_size': (4, 4),\n            'initial_live_cells': 'all',\n            'steps': 2\n        },\n        {\n            'name': 'Case 6 (von Neumann, symmetric pattern)',\n            'neighborhood': 'von Neumann',\n            'boundary': 'periodic',\n            'rule_b': {2},\n            'rule_s': {2},\n            'grid_size': (5, 5),\n            'initial_live_cells': [(2, 2), (1, 2), (3, 2), (2, 1), (2, 3)],\n            'steps': 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        H, W = case['grid_size']\n        \n        # Initialize the state grid\n        if case['initial_live_cells'] == 'all':\n            X = np.ones((H, W), dtype=np.int8)\n        else:\n            X = np.zeros((H, W), dtype=np.int8)\n            for r, c in case['initial_live_cells']:\n                X[r, c] = 1\n\n        # Get simulation parameters\n        kernel = kernels[case['neighborhood']]\n        T = case['steps']\n\n        # Create bit masks for birth and survival rules\n        m_B = sum(1  k for k in case['rule_b'])\n        m_S = sum(1  k for k in case['rule_s'])\n\n        # Set convolution boundary parameters\n        boundary_mode = 'wrap' if case['boundary'] == 'periodic' else 'fill'\n        fill_value = 0 if case['boundary'] == 'zero-fill' else None\n\n        # Run simulation for T steps\n        for _ in range(T):\n            # 1. Compute neighbor sum S via convolution\n            S = signal.convolve2d(X, kernel, mode='same', boundary=boundary_mode, fillvalue=fill_value)\n\n            # 2. Compute the per-site bit value b = 2^S\n            # Use a sufficiently large integer type to prevent overflow from 1  S\n            # S can be at most 8, so 2^8=256. np.uint16 is safe.\n            B = (1  S.astype(np.uint16))\n\n            # 3. Determine which cells are born or survive using bitwise operations\n            # A dead cell at (i,j) is born if S[i,j] is in the birth set B.\n            # (X == 0)  ((B  m_B) != 0)\n            birth_mask = (B  m_B) != 0\n            born = (1 - X) * birth_mask\n\n            # An alive cell at (i,j) survives if S[i,j] is in the survival set S.\n            # (X == 1)  ((B  m_S) != 0)\n            survival_mask = (B  m_S) != 0\n            survived = X * survival_mask\n\n            # 4. Compute the next state\n            X = born | survived\n\n        # Calculate the total number of live cells\n        total_live_cells = np.sum(X)\n        results.append(total_live_cells)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}