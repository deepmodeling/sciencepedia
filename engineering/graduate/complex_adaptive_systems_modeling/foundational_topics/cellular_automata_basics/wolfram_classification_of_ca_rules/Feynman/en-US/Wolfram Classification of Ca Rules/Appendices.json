{
    "hands_on_practices": [
        {
            "introduction": "This exercise grounds the abstract concept of surjectivity in a direct computational task. By enumerating the preimages for Wolfram's Rule 4, you will concretely identify \"Garden of Eden\" states—configurations that are unreachable, thereby gaining a practical understanding of how local update rules impose global constraints on the system's state space .",
            "id": "4151267",
            "problem": "You are given a one-dimensional, binary cellular automaton of the Elementary Cellular Automata (ECA) type in the sense of Stephen Wolfram, defined on a ring of $N$ cells with periodic boundary conditions. Each cell has state in $\\{0,1\\}$, and the global update map $F:\\{0,1\\}^N\\to\\{0,1\\}^N$ is induced by a local update function $\\phi:\\{0,1\\}^3\\to\\{0,1\\}$ that depends on the left neighbor, the cell itself, and the right neighbor. Wolfram’s rule numbering assigns to each ECA a number $r\\in\\{0,\\dots,255\\}$ whose binary expansion encodes $\\phi$ on the eight neighborhoods from $111$ down to $000$. A Garden of Eden (GoE) state is a configuration $y\\in\\{0,1\\}^N$ with no preimage under $F$, i.e., there is no $x\\in\\{0,1\\}^N$ such that $F(x)=y$. A global map $F$ is surjective if for every $y\\in\\{0,1\\}^N$ there exists at least one $x$ with $F(x)=y$. In complex adaptive systems modeling, identifying non-surjective rules and their Garden of Eden states is fundamental for understanding state-space accessibility and rule-induced constraints.\n\nStarting from the core definitions of functions, surjectivity, and the local-to-global construction of ECA, demonstrate the existence of Garden of Eden states for a non-surjective rule by explicit enumeration of preimages for Wolfram’s rule $4$. For rule $4$, the local update function $\\phi$ is defined by the binary encoding of $4$ which equals $00000100$; interpreting the least significant bit as the output for neighborhood $000$ and the most significant bit as the output for neighborhood $111$, this means $\\phi(0,1,0)=1$ and $\\phi$ is $0$ on all other neighborhoods.\n\nYour task is to write a complete, runnable program that, for each provided system size $N$, enumerates all $2^N$ configurations $x\\in\\{0,1\\}^N$, computes $y=F(x)$ under rule $4$ on the ring (periodic boundary conditions), accumulates the number of preimages of each $y\\in\\{0,1\\}^N$, and finally counts how many $y$ have zero preimages (i.e., are Garden of Eden states). You must not assume any pre-derived formulas for preimage counts; the enumeration must follow directly from the definitions.\n\nTest Suite:\n- Use the following system sizes $N$: $1$, $2$, $3$, $4$, $5$, $6$, $8$.\n\nAnswer Specification:\n- For each $N$ in the test suite, compute an integer equal to the number of Garden of Eden states for that $N$ under rule $4$.\n- Aggregate the results across all test cases into a single list of integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nNo physical units or angles are involved; all quantities are purely combinatorial and must be presented as integers as specified. The solution must rely strictly on the foundational definitions and logic of functions, surjectivity, and the local-to-global construction for ECA on finite rings.",
            "solution": "The problem asks for the number of Garden of Eden (GoE) states for Wolfram's Elementary Cellular Automaton (ECA) Rule $4$ on a one-dimensional ring of $N$ cells. A GoE state is a configuration that cannot be reached from any other configuration in one time step.\n\nLet the set of all possible configurations be $\\mathcal{C} = \\{0, 1\\}^N$. A configuration is a vector $x = (x_0, x_1, \\ldots, x_{N-1})$, where each $x_i \\in \\{0, 1\\}$. The total number of configurations is $|\\mathcal{C}| = 2^N$.\n\nThe global update map $F: \\mathcal{C} \\to \\mathcal{C}$ is determined by a local update function $\\phi: \\{0, 1\\}^3 \\to \\{0, 1\\}$. For a configuration $x$, the next configuration $y = F(x)$ is given by:\n$$y_i = \\phi(x_{i-1}, x_i, x_{i+1})$$\nfor $i = 0, 1, \\ldots, N-1$. The boundary conditions are periodic, so indices are interpreted modulo $N$. For example, $x_{-1} = x_{N-1}$ and $x_N = x_0$.\n\nThe problem specifies Wolfram Rule $4$. The number $4$ in binary is $00000100_2$. According to Wolfram's convention, this binary string defines the output of $\\phi$ for the eight possible neighborhoods, ordered from $(1,1,1)$ down to $(0,0,0)$:\n- $\\phi(1,1,1) = 0$\n- $\\phi(1,1,0) = 0$\n- $\\phi(1,0,1) = 0$\n- $\\phi(1,0,0) = 0$\n- $\\phi(0,1,1) = 0$\n- $\\phi(0,1,0) = 1$\n- $\\phi(0,0,1) = 0$\n- $\\phi(0,0,0) = 0$\n\nThus, the local rule is exceptionally simple: the new state of a cell is $1$ if and only if its neighborhood pattern is $(0,1,0)$ (left neighbor is $0$, cell is $1$, right neighbor is $0$). Otherwise, the new state is $0$.\n\nA configuration $y \\in \\mathcal{C}$ is a Garden of Eden state if it has no preimage under $F$. That is, the preimage set $F^{-1}(y) = \\{x \\in \\mathcal{C} \\mid F(x) = y\\}$ is empty. The task is to find the number of such states, $| \\{y \\in \\mathcal{C} \\mid |F^{-1}(y)|=0 \\} |$.\n\nThe problem requires a solution based on direct enumeration, not on pre-derived analytical formulas. The algorithm proceeds as follows for each given system size $N$:\n\n1.  **Initialize Preimage Counter**: Create an array, let's call it `preimage_counts`, of size $2^N$, with all entries initialized to $0$. Each index $j$ (from $0$ to $2^N-1$) of this array will correspond to a unique configuration $y \\in \\mathcal{C}$ (represented as the integer $j$) and will store the size of its preimage set, $|F^{-1}(y)|$.\n\n2.  **Iterate Through All Initial States**: Loop through all $2^N$ possible initial configurations $x \\in \\mathcal{C}$. A convenient way to do this is to iterate an integer $i$ from $0$ to $2^N-1$ and use its $N$-bit binary representation as the configuration $x$.\n\n3.  **Compute the Successor State**: For each configuration $x$, compute its successor state $y = F(x)$. This involves applying the Rule $4$ logic to each cell $x_i$ and its neighbors, respecting the periodic boundary conditions.\n    Using vectorized operations, this step is efficient. Given an array `x` representing the configuration:\n    - The array of left neighbors is `np.roll(x, 1)`.\n    - The array of right neighbors is `np.roll(x, -1)`.\n    - The successor configuration `y` is computed by checking where the neighborhood condition $(0,1,0)$ is met simultaneously for all cells.\n\n4.  **Update Preimage Count**: Convert the resulting configuration $y$ (an array of $0$s and $1$s) back into its unique integer representation, say $j$. Increment the counter at that index: `preimage_counts[j] += 1`.\n\n5.  **Count Garden of Eden States**: After iterating through all $2^N$ initial states $x$, the `preimage_counts` array is fully populated. The number of Garden of Eden states is the number of entries in this array that remain $0$.\n\nThis procedure is repeated for each value of $N$ in the test suite $\\{1, 2, 3, 4, 5, 6, 8\\}$, and the resulting counts are collected into a list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_goe_count(N):\n    \"\"\"\n    Calculates the number of Garden of Eden states for a given system size N\n    under Wolfram's Rule 4 with periodic boundary conditions.\n\n    The calculation is done by explicit enumeration as required by the problem.\n    \"\"\"\n    num_total_configs = 1 << N  # This is 2**N\n\n    # Array to store the number of preimages for each of the 2^N possible configurations.\n    # The index of the array corresponds to the integer representation of a configuration.\n    preimage_counts = np.zeros(num_total_configs, dtype=np.int64)\n\n    # Iterate through all 2^N possible initial configurations 'x'.\n    # Each integer 'i' from 0 to 2^N-1 corresponds to a unique configuration.\n    for i in range(num_total_configs):\n        # 1. Convert the integer 'i' to its N-bit binary representation (configuration x).\n        # The representation is created as a NumPy array of integers.\n        x = np.array([int(bit) for bit in np.binary_repr(i, width=N)])\n\n        # 2. Compute the next state 'y = F(x)' under Rule 4.\n        # This is done efficiently using NumPy's vectorized operations.\n        # np.roll provides periodic boundary conditions.\n        left_neighbors = np.roll(x, 1)\n        center_cells = x\n        right_neighbors = np.roll(x, -1)\n\n        # Rule 4: the output is 1 if and only if the neighborhood is (0, 1, 0).\n        y = ((left_neighbors == 0) & (center_cells == 1) & (right_neighbors == 0)).astype(np.int8)\n\n        # 3. Convert the resulting configuration 'y' to its integer representation.\n        # This is done by treating the binary array as a base-2 number.\n        y_int = 0\n        for bit in y:\n            y_int = (y_int << 1) | bit\n\n        # 4. Increment the preimage count for the computed configuration 'y'.\n        preimage_counts[y_int] += 1\n\n    # 5. The number of Garden of Eden states is the count of configurations 'y'\n    #    that have zero preimages.\n    goe_count = np.sum(preimage_counts == 0)\n    \n    return goe_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 5, 6, 8]\n\n    results = []\n    for N in test_cases:\n        # Calculate the number of GoE states for each system size N.\n        result = calculate_goe_count(N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from static state-space analysis to dynamics, this practice focuses on simulating the famously complex Rule 30. You will implement its evolution from a simple seed and track the emergence of complexity by measuring the diversity of local neighborhoods over time, providing hands-on experience with the mechanisms of Class III chaotic behavior in cellular automata .",
            "id": "4151322",
            "problem": "You are tasked with deriving and implementing a complete simulation of an Elementary Cellular Automaton (ECA) governed by Wolfram's rule classification, focusing specifically on rule $30$. The objective is to compute the space-time evolution for $T$ discrete time steps on a one-dimensional ring of length $L$ with periodic boundary conditions, starting from a single active cell, and then to rigorously summarize the growth in distinct neighborhood frequencies per time step.\n\nAssume the following fundamental base for the derivation and implementation:\n\n- An Elementary Cellular Automaton (ECA) is a discrete-time dynamical system on a binary state space $\\{0,1\\}^L$ with local update function $f : \\{0,1\\}^3 \\to \\{0,1\\}$. The global update is spatially translation-invariant and synchronously applied to all sites.\n- The configuration at time step $t$ is denoted $\\mathbf{x}^{(t)} = (x^{(t)}_0, x^{(t)}_1, \\ldots, x^{(t)}_{L-1}) \\in \\{0,1\\}^L$, with periodic boundary conditions $x^{(t)}_{i} = x^{(t)}_{i \\bmod L}$.\n- The local neighborhood at site $i$ and time $t$ is the triplet $\\left(x^{(t)}_{i-1}, x^{(t)}_{i}, x^{(t)}_{i+1}\\right)$, with indices interpreted modulo $L$.\n\nDefine the local rule for Elementary Cellular Automaton rule $30$ as follows. Let $R=30$ be the rule number. Associate each neighborhood triple $\\left(a,b,c\\right) \\in \\{0,1\\}^3$ with its code $n = 4a + 2b + c \\in \\{0,\\ldots,7\\}$. The output of rule $R$ on neighborhood code $n$ is the $n$-th bit of the $8$-bit binary expansion of $R$, where the least significant bit corresponds to neighborhood code $n=0$ (i.e., $\\left(0,0,0\\right)$) and the most significant bit corresponds to neighborhood code $n=7$ (i.e., $\\left(1,1,1\\right)$). Explicitly, for $R=30$, the binary pattern is $00011110$, so that\n$$\nf(1,1,1)=0,\\; f(1,1,0)=0,\\; f(1,0,1)=0,\\; f(1,0,0)=1,\\; f(0,1,1)=1,\\; f(0,1,0)=1,\\; f(0,0,1)=1,\\; f(0,0,0)=0.\n$$\n\nInitial condition: At time $t=0$, the configuration $\\mathbf{x}^{(0)}$ has a single active cell at index $i_0 = \\lfloor L/2 \\rfloor$, i.e., $x^{(0)}_{i_0} = 1$ and $x^{(0)}_{i} = 0$ for all $i \\neq i_0$.\n\nFor each time step $t \\in \\{0,1,\\ldots,T\\}$, define the neighborhood code field\n$$\nn^{(t)}_i = 4 x^{(t)}_{i-1} + 2 x^{(t)}_{i} + x^{(t)}_{i+1},\n$$\nand define the frequency vector $\\mathbf{F}^{(t)} \\in \\mathbb{N}^8$ whose $k$-th component $F^{(t)}_k$ is the count of indices $i \\in \\{0,\\ldots,L-1\\}$ such that $n^{(t)}_i = k$. Define the distinct neighborhood count at time $t$ as\n$$\nD^{(t)} = \\left|\\left\\{k \\in \\{0,\\ldots,7\\} \\,\\middle|\\, F^{(t)}_k > 0 \\right\\}\\right|.\n$$\nThe growth summary for the run is the integer list $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$.\n\nYour task is to implement a program that, for each test case $(L,T)$, computes the evolution under rule $30$ from the specified initial condition and returns the growth summary list $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$.\n\nDesign constraints:\n\n- All computations must be performed in purely mathematical terms with the above definitions and periodic boundary conditions. No physical units are involved in this problem.\n- Your implementation must be deterministic and translation-invariant, applying the local update function $f$ to all sites synchronously at each time step.\n\nTest suite:\n\nUse the following parameter values to validate the algorithm across typical and edge-case scenarios:\n\n1. A general scenario: $L=51$, $T=25$.\n2. Minimal ring size: $L=1$, $T=10$.\n3. Small even ring: $L=2$, $T=10$.\n4. Small odd ring: $L=3$, $T=12$.\n5. Larger even ring: $L=64$, $T=20$.\n6. Boundary condition on time steps: $L=13$, $T=0$.\n\nFinal output specification:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the $j$-th element is the growth summary list $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$ for the $j$-th test case in the order listed above. For example, an output line will have the form\n$$\n[\\,[d_{0,0}, d_{0,1}, \\ldots, d_{0,T_0}],\\,[d_{1,0}, \\ldots, d_{1,T_1}],\\,\\ldots\\,]\n$$\nwith no descriptive text. Each $d_{j,t}$ must be an integer.",
            "solution": "The core of the problem is to simulate the time evolution of a one-dimensional binary cellular automaton and, at each time step, to quantify the diversity of local neighborhoods. The solution can be decomposed into several logical steps: representing the system state, implementing the update rule, simulating the time evolution, and calculating the specified metric.\n\nFirst, we represent the state of the system at time $t$, denoted $\\mathbf{x}^{(t)}$, as a one-dimensional array of length $L$. The elements of this array, $x^{(t)}_i$, take values in $\\{0, 1\\}$. The initial condition at $t=0$ is a lattice of all zeros except for a single active cell at index $i_0 = \\lfloor L/2 \\rfloor$, where $x^{(0)}_{i_0} = 1$. In computational terms, this is an integer array of size $L$ initialized accordingly.\n\nSecond, we must implement the local update function $f$ for ECA Rule $30$. The rule determines the state $x^{(t+1)}_i$ based on the neighborhood $\\left(x^{(t)}_{i-1}, x^{(t)}_{i}, x^{(t)}_{i+1}\\right)$. The problem defines a standard mapping where each neighborhood triplet $(a,b,c)$ is converted to a numerical code $n = 4a + 2b + c$. The rule's output is the $n$-th bit of the binary representation of the rule number, $R=30$. The $8$-bit binary representation of $30$ is $00011110_2$. We construct a lookup table, which is an array of length $8$, that maps each neighborhood code $n \\in \\{0, \\dots, 7\\}$ to its output state $\\{0, 1\\}$. According to the problem's specification (least significant bit corresponds to $n=0$), the lookup table for Rule $30$ is $[0, 1, 1, 1, 1, 0, 0, 0]$. That is, $f(\\text{code}=0)=0, f(\\text{code}=1)=1, \\dots, f(\\text{code}=7)=0$.\n\nThird, we simulate the synchronous evolution of the system. To compute the configuration $\\mathbf{x}^{(t+1)}$ from $\\mathbf{x}^{(t)}$, we must first determine the neighborhood for every cell $i \\in \\{0, \\dots, L-1\\}$. The problem specifies periodic boundary conditions, meaning the lattice is treated as a ring. Computationally, this is efficiently handled by creating shifted versions of the state array $\\mathbf{x}^{(t)}$. The array of left neighbors is obtained by shifting $\\mathbf{x}^{(t)}$ one position to the right (e.g., `np.roll(x, 1)`), and the array of right neighbors is obtained by shifting one position to the left (e.g., `np.roll(x, -1)`). With the arrays for left neighbors, center cells, and right neighbors, we can compute the neighborhood code $n^{(t)}_i = 4x^{(t)}_{i-1} + 2x^{(t)}_{i} + x^{(t)}_{i+1}$ for all sites simultaneously using vectorized arithmetic. This yields an array of neighborhood codes, one for each site on the lattice. The next state $\\mathbf{x}^{(t+1)}$ is then found by applying the Rule $30$ lookup table to this array of codes.\n\nFourth, for each time step $t$ from $0$ to $T$, we must compute the distinct neighborhood count, $D^{(t)}$. This is defined as the number of unique neighborhood codes present across the entire lattice at that time step. Having already computed the array of neighborhood codes $n^{(t)}_i$ for all $i$ as part of the evolution step, we can find the set of unique values in this array and count its size. This count gives $D^{(t)}$.\n\nThe complete algorithm for a given test case $(L, T)$ is as follows:\n1. Initialize an empty list, `growth_summary`, to store the values $[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}]$.\n2. Create the initial state array $\\mathbf{x}^{(0)}$ of length $L$ with a single $1$ at index $\\lfloor L/2 \\rfloor$.\n3. Define the Rule $30$ lookup table as $[0, 1, 1, 1, 1, 0, 0, 0]$.\n4. Begin a loop for each time step $t$ from $0$ to $T$ (inclusive).\n5. Inside the loop, for the current configuration $\\mathbf{x}^{(t)}$:\n    a. Determine the array of neighborhood codes for all sites using periodic shifts and vectorized arithmetic.\n    b. Find the number of unique codes in this array and append this count, $D^{(t)}$, to `growth_summary`.\n    c. If $t < T$, compute the next state $\\mathbf{x}^{(t+1)}$ by applying the Rule $30$ lookup table to the array of neighborhood codes.\n6. After the loop completes, the `growth_summary` list contains the required output for the test case.\nThis procedure is repeated for all test cases provided in the problem statement, and the final results are formatted into a single output line as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the space-time evolution of Elementary Cellular Automaton (ECA) Rule 30\n    for a set of test cases and calculates the growth summary of distinct neighborhood frequencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (51, 25),   # A general scenario\n        (1, 10),    # Minimal ring size\n        (2, 10),    # Small even ring\n        (3, 12),    # Small odd ring\n        (64, 20),   # Larger even ring\n        (13, 0),    # Boundary condition on time steps\n    ]\n\n    # The local rule for ECA rule 30 is derived from its binary representation.\n    # R=30 in binary is 00011110.\n    # The output for a neighborhood code 'n' is the n-th bit, with n=0 being the LSB.\n    # The neighborhood code n is calculated as n = 4*left + 2*center + 1*right.\n    # Index 0 corresponds to code 0 (0,0,0) -> 0\n    # Index 1 corresponds to code 1 (0,0,1) -> 1\n    # ...\n    # Index 7 corresponds to code 7 (1,1,1) -> 0\n    rule_30_map = np.array([0, 1, 1, 1, 1, 0, 0, 0], dtype=np.int8)\n\n    all_results = []\n\n    for L, T in test_cases:\n        # Step 1: Initialize the configuration and result list.\n        # The configuration 'x' is a 1D numpy array representing the lattice.\n        # Initial condition: a single active cell at the center.\n        x = np.zeros(L, dtype=np.int8)\n        if L > 0:\n            i_0 = L // 2\n            x[i_0] = 1\n        \n        growth_summary = []\n\n        # Step 2: Loop through each time step from 0 to T.\n        for t in range(T + 1):\n            if L == 0:\n                # Edge case: for a lattice of size 0, there are no neighborhoods.\n                D_t = 0\n            else:\n                # Step 3: Compute neighborhood codes for the current configuration 'x'.\n                # np.roll handles periodic boundary conditions efficiently.\n                x_left = np.roll(x, 1)\n                x_right = np.roll(x, -1)\n                \n                # Vectorized calculation of neighborhood codes for all sites.\n                neighborhood_codes = 4 * x_left + 2 * x + x_right\n\n                # Step 4: Calculate D^(t), the count of distinct neighborhood codes.\n                unique_codes = np.unique(neighborhood_codes)\n                D_t = len(unique_codes)\n            \n            growth_summary.append(D_t)\n\n            # Step 5: Update the configuration for the next time step.\n            # This is skipped on the final iteration (t=T) as x^(T+1) is not needed.\n            if t < T and L > 0:\n                x = rule_30_map[neighborhood_codes]\n        \n        all_results.append(growth_summary)\n\n    # Step 6: Format the final output according to the problem specification.\n    # The output should be a single line: [[...],[...],...]\n    inner_lists_str = [f\"[{','.join(map(str, summary))}]\" for summary in all_results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "This advanced practice delves into the deeper structural connections between different cellular automata rules. You will develop an algorithm to detect emulation relationships, where one rule's dynamics can be mapped onto another's via a transformation known as a sliding block code . Successfully mapping this emulation graph reveals a hidden organization within the vast space of possible computational rules.",
            "id": "4151324",
            "problem": "You are to design and implement a complete program that, from first principles, constructs and applies an algorithm to detect emulation relationships between Elementary Cellular Automata (ECA) rules using symbolic dynamics (sliding block codes). The goal is to map the emulation graph over the rule set $\\{30,45,73,110\\}$ under the criterion that a rule $R$ emulates a rule $S$ if there exists a non-degenerate sliding block code $\\varphi$ such that the following commutation condition holds:\n$$\n\\varphi \\circ F_R = F_S \\circ \\varphi,\n$$\nfor all configurations on finite periodic rings of specified sizes. Here $F_R$ and $F_S$ are the global maps of ECA rules $R$ and $S$, respectively.\n\nFundamental base definitions and constraints:\n- An Elementary Cellular Automaton (ECA) is a one-dimensional, binary-state ($\\{0,1\\}$) cellular automaton with nearest-neighbor coupling and synchronous update. The global evolution map $F_R$ for a rule $R$ is defined by a local function $f_R:\\{0,1\\}^{3}\\to\\{0,1\\}$ of radius $1$ (depending on the left neighbor, the cell itself, and the right neighbor), applied uniformly across all sites with periodic boundary conditions. The Wolfram code for $R$ encodes $f_R$’s outputs for the neighborhoods in the order $\\{111,110,101,100,011,010,001,000\\}$.\n- A sliding block code (symbolic dynamics factor map) $\\varphi$ with window size $m=3$ is defined by a local function $h:\\{0,1\\}^{3}\\to\\{0,1\\}$ applied at each site, using the left neighbor, the site itself, and the right neighbor from the input configuration; thus $\\varphi$ is shift-commuting and translation-invariant.\n- Emulation criterion: A rule $R$ emulates a rule $S$ via $\\varphi$ if $\\varphi \\circ F_R(x) = F_S \\circ \\varphi(x)$ for all configurations $x$ in the configuration space on a finite ring. The search is restricted to sliding block codes of window size $m=3$ that are non-degenerate, meaning $h$ is surjective onto $\\{0,1\\}$ (it must produce both $0$ and $1$ on some neighborhood), thereby excluding constant maps. To avoid trivial identity cases, do not include edges where $R=S$ in the emulation graph output.\n- Validation scope: Because checking all bi-infinite configurations is not computationally feasible, your algorithm must verify the commutation condition for all configurations on two distinct periodic ring sizes, specifically $N=8$ and $N=10$. For each $N$, periodic boundary conditions must be used. Time validation is by one-step commutation ($t=1$), and this is sufficient because if $\\varphi \\circ F_R = F_S \\circ \\varphi$ holds for all $x$, then by induction it holds for all iterates.\n\nAlgorithmic requirements:\n1. Construct the global maps $F_R$ and $F_S$ from their Wolfram codes using only the definition of ECA local rules as functions $f_R:\\{0,1\\}^{3}\\to\\{0,1\\}$ and periodic boundary conditions on rings of size $N$.\n2. Enumerate all sliding block codes $\\varphi$ with window size $m=3$. There are $2^{2^3}=256$ candidate $h:\\{0,1\\}^{3}\\to\\{0,1\\}$ functions. Exclude degenerate $h$ that are constant ($0$ or $1$ everywhere). Each candidate $\\varphi$ must be tested for emulation.\n3. For each ordered pair $(R,S)$ in the set $\\{30,45,73,110\\}\\times\\{30,45,73,110\\}$ with $R\\neq S$, test if there exists at least one non-degenerate $\\varphi$ such that the commutation condition $\\varphi \\circ F_R = F_S \\circ \\varphi$ holds for all configurations on rings of sizes $N=8$ and $N=10$ (two sizes are required to reduce spurious finite-size coincidences).\n4. Construct the emulation graph as a directed edge set, where there is a directed edge $R\\to S$ if such a $\\varphi$ exists.\n\nTest suite specification:\n- Rule set: $\\{30,45,73,110\\}$.\n- Ordered pairs: all $16$ ordered pairs $(R,S)$ from the rule set; your algorithm must exclude self-pairs $(R,S)$ where $R=S$ when producing the final emulation graph output.\n- Ring sizes: $N=8$ and $N=10$; periodic boundary conditions must be used.\n- Sliding block code window size: $m=3$.\n- Verification time: one-step commutation ($t=1$) only.\n\nAnswer specification:\n- For each ordered pair $(R,S)$, the program must determine a boolean indicating whether an emulation exists; however, the final output must aggregate the successful emulations into a single directed edge list.\n- Final output format: Your program should produce a single line of output containing the directed edges as a comma-separated list of pairs enclosed in square brackets. For example, an empty graph is printed as `[]`, a graph with two edges $30\\to45$ and $45\\to73$ is printed as `[[30,45],[45,73]]`. No spaces are permitted in the output string.\n\nNo physical units or angles are involved; all outputs are unitless integers and lists. The program must be entirely self-contained, accept no input, and use only the specified libraries in the final answer section.",
            "solution": "The objective is to determine the emulation graph for a set of Elementary Cellular Automata (ECA) rules $R,S \\in \\{30, 45, 73, 110\\}$. An emulation from rule $R$ to rule $S$ exists if there is a non-degenerate sliding block code $\\varphi$ of window size $m=3$ that makes the following diagram commute for all configurations $x$ on finite rings of sizes $N=8$ and $N=10$:\n$$\n\\varphi \\circ F_R(x) = F_S \\circ \\varphi(x)\n$$\nHere, $F_R$ and $F_S$ are the global evolution operators for the respective ECA rules. The procedural steps to find this graph are outlined below.\n\n**1. Representation of Automata and Configurations**\n\nA configuration on a ring of size $N$ is a binary vector $x \\in \\{0,1\\}^N$, which can be represented by a one-dimensional NumPy array of integers.\n\nAn ECA rule, specified by its Wolfram code $R$ (an integer from $0$ to $255$), is fundamentally a local function $f_R:\\{0,1\\}^3 \\to \\{0,1\\}$. The problem defines the encoding such that the binary representation of $R$, denoted $b_7b_6...b_0$, corresponds to the outputs for neighborhoods $\\{111, 110, ..., 000\\}$. This is the standard convention where the integer value of a neighborhood triplet $(c_{i-1}, c_i, c_{i+1})$, taken as $k = 4c_{i-1} + 2c_i + c_{i+1}$, maps to an output given by the $k$-th bit of $R$. This allows us to create an $8$-element lookup table for any rule $R$, where `lut[k] = (R >> k) & 1`.\n\nA sliding block code $\\varphi$ with window size $m=3$ is defined by a similar local function $h:\\{0,1\\}^3 \\to \\{0,1\\}$. There are $2^{2^3}=256$ such functions, each representable by an integer code $H$ from $0$ to $255$ in the same manner as an ECA rule. The problem requires a non-degenerate code, meaning $h$ must be surjective. This excludes the constant maps where all outputs are $0$ (code $H=0$) or all outputs are $1$ (code $H=255$). Thus, our search space for block codes comprises integers $H \\in \\{1, \\dots, 254\\}$.\n\n**2. Implementation of Global Maps**\n\nThe global map $F_R$ updates a configuration $x$ to a new configuration $x'$ where each site $x'_i$ is computed as $x'_i = f_R(x_{i-1}, x_i, x_{i+1})$. The periodic boundary conditions imply that indices are evaluated modulo $N$. This operation can be efficiently vectorized. Given a batch of configurations (a $K \\times N$ matrix), we can generate the arrays for the left-shifted, center, and right-shifted sites for all configurations simultaneously using `numpy.roll` with `axis=1`.\n*   Let `configs` be the input matrix of configurations.\n*   `left = np.roll(configs, 1, axis=1)`\n*   `center = configs`\n*   `right = np.roll(configs, -1, axis=1)`\nThe neighborhood indices for every site in every configuration are then computed as `indices = 4 * left + 2 * center + 1 * right`. The output configurations are obtained by indexing the rule's lookup table with this `indices` matrix. The same function can be used to apply a sliding block code $\\varphi_H$ by simply using the lookup table derived from the integer code $H$.\n\n**3. Verification across Configuration Spaces**\n\nThe commutation condition must hold for all possible configurations. For a finite ring of size $N$, there are $2^N$ such configurations. The algorithm must verify the condition for all $2^8 = 256$ configurations for $N=8$ and all $2^{10} = 1024$ configurations for $N=10$. We can generate these configuration spaces by iterating an integer from $0$ to $2^N-1$ and taking its $N$-bit binary representation for each configuration.\n\n**4. The Search Algorithm**\n\nThe core of the solution is a systematic search over all valid parameters. The algorithm follows a nested loop structure:\n1.  Iterate through all ordered pairs $(R,S)$ from the set $\\{30, 45, 73, 110\\} \\times \\{30, 45, 73, 110\\}$, excluding pairs where $R=S$.\n2.  For each pair $(R,S)$, assume no emulation exists initially.\n3.  Iterate through all possible non-degenerate sliding block codes, i.e., for $H$ from $1$ to $254$.\n4.  For each candidate code $H$, test the commutation condition. This involves another loop over the specified ring sizes $N \\in \\{8, 10\\}$.\n5.  For a given $N$, compute the outcome for all $2^N$ configurations:\n    *   Let $X_N$ be the set of all $2^N$ configurations of size $N$.\n    *   Compute the left-hand side of the equation for all configurations: $LHS = \\varphi_H(F_R(X_N))$. This is done in two vectorized steps: first apply $F_R$ to $X_N$, then apply $\\varphi_H$ to the result.\n    *   Compute the right-hand side: $RHS = F_S(\\varphi_H(X_N))$.\n    *   If $LHS$ and $RHS$ are not identical, the code $H$ fails the test for this $N$. We break the loop over $N$ and proceed to the next code $H$.\n6.  If the code $H$ passes the test for both $N=8$ and $N=10$, an emulation $R \\to S$ has been found. We record the pair $(R,S)$ as a directed edge in the emulation graph and break the loop over $H$, as the existence of at least one such code is sufficient.\n7.  After iterating through all pairs $(R,S)$, the collected list of edges constitutes the desired emulation graph.\n\nThis comprehensive search guarantees finding all emulations that satisfy the problem's strict criteria. The final output is formatted as a string representation of the list of directed edges.",
            "answer": "```python\nimport numpy as np\n\ndef apply_map_batch(configs, map_code):\n    \"\"\"\n    Applies a local map (ECA rule or sliding block code) to a batch of configurations.\n\n    Args:\n        configs (np.ndarray): A (num_configs, N) array of configurations.\n        map_code (int): The integer code (0-255) for the map.\n\n    Returns:\n        np.ndarray: The array of resulting configurations.\n    \"\"\"\n    if configs.ndim == 1:\n        configs = configs[np.newaxis, :]\n    \n    N = configs.shape[1]\n    \n    # Get neighbors using periodic boundary conditions\n    left = np.roll(configs, 1, axis=1)\n    center = configs\n    right = np.roll(configs, -1, axis=1)\n    \n    # Convert neighborhoods to integer indices (0-7)\n    indices = 4 * left + 2 * center + 1 * right\n    \n    # Create an 8-element lookup table from the map code\n    lut = np.array([(map_code >> i) & 1 for i in range(8)], dtype=np.uint8)\n\n    # Apply the map using advanced indexing\n    return lut[indices]\n\ndef generate_configs(N):\n    \"\"\"\n    Generates all 2^N possible configurations for a ring of size N.\n\n    Args:\n        N (int): The size of the ring.\n\n    Returns:\n        np.ndarray: A (2^N, N) array containing all configurations.\n    \"\"\"\n    num_configs = 1 << N\n    # Use broadcasting to create all binary strings efficiently\n    powers_of_2 = 1 << np.arange(N - 1, -1, -1)\n    indices_matrix = np.arange(num_configs)[:, np.newaxis]\n    configs = (indices_matrix // powers_of_2) % 2\n    return configs.astype(np.uint8)\n\ndef solve():\n    \"\"\"\n    Main function to find and report ECA emulation relationships.\n    \"\"\"\n    rules = [30, 45, 73, 110]\n    ring_sizes = [8, 10]\n    emulation_edges = []\n\n    # Pre-generate all configurations for the specified ring sizes\n    all_configs = {N: generate_configs(N) for N in ring_sizes}\n\n    # Non-degenerate sliding block codes are represented by integers 1 to 254\n    map_codes = range(1, 255)\n\n    for R in rules:\n        for S in rules:\n            if R == S:\n                continue\n\n            emulation_found_for_pair = False\n            for H in map_codes:\n                commutes_for_H = True\n                for N in ring_sizes:\n                    configs = all_configs[N]\n\n                    # Left-hand side: phi(F_R(x))\n                    F_R_x = apply_map_batch(configs, R)\n                    phi_F_R_x = apply_map_batch(F_R_x, H)\n                    \n                    # Right-hand side: F_S(phi(x))\n                    phi_x = apply_map_batch(configs, H)\n                    F_S_phi_x = apply_map_batch(phi_x, S)\n\n                    # Check if the commutation holds for all configurations at this N\n                    if not np.array_equal(phi_F_R_x, F_S_phi_x):\n                        commutes_for_H = False\n                        break  # This H fails, try the next one\n                \n                if commutes_for_H:\n                    # An emulation map H was found that works for all specified N\n                    emulation_found_for_pair = True\n                    break  # Found a map for this (R,S) pair, move to the next pair\n            \n            if emulation_found_for_pair:\n                emulation_edges.append([R, S])\n    \n    # Format the final output string exactly as specified, with no spaces.\n    final_output = str(emulation_edges).replace(' ', '')\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}