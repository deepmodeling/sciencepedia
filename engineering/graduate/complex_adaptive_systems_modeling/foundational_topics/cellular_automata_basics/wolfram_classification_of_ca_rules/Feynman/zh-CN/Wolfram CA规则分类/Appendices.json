{
    "hands_on_practices": [
        {
            "introduction": "元胞自动机的局部规则看似简单，却能对整个系统的全局演化施加深刻的约束。一个基本问题是，是否所有可能的状态都能从某个前驱状态演化而来？这个练习通过一个具体的计算任务来探索这一问题，即寻找被称为“伊甸园”(Garden of Eden)态的状态——那些没有任何前驱、无法通过规则演化到达的孤立状态。通过对规则4（一个非满射规则）在小尺寸环上进行彻底的枚举，你将亲手验证这些状态的存在性，从而将满射性这一抽象的动力学概念转化为一个可触摸、可计算的现实。",
            "id": "4151267",
            "problem": "给定一个根据 Stephen Wolfram 定义的初等元胞自动机（ECA）类型的一维二进制元胞自动机，它定义在一个由 $N$ 个元胞组成的、具有周期性边界条件的环上。每个元胞的状态在 $\\{0,1\\}$ 中，全局更新映射 $F:\\{0,1\\}^N\\to\\{0,1\\}^N$ 由一个局部更新函数 $\\phi:\\{0,1\\}^3\\to\\{0,1\\}$ 导出，该函数取决于左邻居、元胞本身和右邻居。Wolfram 规则编号为每个 ECA 分配一个数字 $r\\in\\{0,\\dots,255\\}$，其二进制展开编码了 $\\phi$ 在从 $111$ 到 $000$ 的八个邻域上的输出。一个伊甸园（Garden of Eden, GoE）状态是一个在 $F$ 下没有原像的组态 $y\\in\\{0,1\\}^N$，即不存在 $x\\in\\{0,1\\}^N$ 使得 $F(x)=y$。如果对于每一个 $y\\in\\{0,1\\}^N$，都至少存在一个 $x$ 使得 $F(x)=y$，则全局映射 $F$ 是满射的。在复杂自适应系统建模中，识别非满射规则及其伊甸园状态对于理解状态空间可达性和规则引发的约束至关重要。\n\n从函数、满射性以及 ECA 的从局部到全局构造的核心定义出发，通过对 Wolfram 规则 $4$ 的原像进行显式枚举，来证明一个非满射规则存在伊甸园状态。对于规则 $４$，局部更新函数 $\\phi$ 由 $4$ 的二进制编码 $00000100$ 定义；将最低有效位解释为邻域 $000$ 的输出，最高有效位解释为邻域 $111$ 的输出，这意味着 $\\phi(0,1,0)=1$ 且 $\\phi$ 在所有其他邻域上均为 $0$。\n\n您的任务是编写一个完整的、可运行的程序，对于每个给定的系统大小 $N$，该程序会枚举所有 $2^N$ 个组态 $x\\in\\{0,1\\}^N$，在环（周期性边界条件）上根据规则 $4$ 计算 $y=F(x)$，累积每个 $y\\in\\{0,1\\}^N$ 的原像数量，最后计算有多少个 $y$ 具有零个原像（即为伊甸园状态）。您不能假设任何预先推导出的原像计数公式；枚举必须直接遵循定义。\n\n测试套件：\n- 使用以下系统大小 $N$：$1$，$2$，$3$，$4$，$5$，$6$，$8$。\n\n答案规格：\n- 对于测试套件中的每个 $N$，计算在该 $N$ 值下规则 $4$ 的伊甸园状态数量，结果为一个整数。\n- 将所有测试用例的结果汇总成一个整数列表。\n- 您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3]”）。\n\n不涉及物理单位或角度；所有量都是纯组合的，并且必须按规定以整数形式呈现。解决方案必须严格依赖于函数、满射性以及有限环上 ECA 的从局部到全局构造的基本定义和逻辑。",
            "solution": "问题陈述已分析并被视为有效。它在科学上植根于成熟的元胞自动机理论，问题设定良好，具有唯一且可计算的解，并使用客观、明确的语言进行表述。该任务是基础定义的直接应用，需要通过枚举状态转换来识别伊甸园组态。\n\n问题要求计算 Wolfram 初等元胞自动机（ECA）规则 $4$ 在一个由 $N$ 个元胞组成的一维环上的伊甸园（GoE）状态的数量。一个 GoE 状态是在一个时间步内无法从任何其他组态达到的组态。\n\n设所有可能组态的集合为 $\\mathcal{C} = \\{0, 1\\}^N$。一个组态是一个向量 $x = (x_0, x_1, \\ldots, x_{N-1})$，其中每个 $x_i \\in \\{0, 1\\}$。总组态数为 $|\\mathcal{C}| = 2^N$。\n\n全局更新映射 $F: \\mathcal{C} \\to \\mathcal{C}$ 由局部更新函数 $\\phi: \\{0, 1\\}^3 \\to \\{0, 1\\}$ 决定。对于一个组态 $x$，下一个组态 $y = F(x)$ 由下式给出：\n$$y_i = \\phi(x_{i-1}, x_i, x_{i+1})$$\n其中 $i = 0, 1, \\ldots, N-1$。边界条件是周期性的，因此索引在模 $N$ 意义下解释。例如，$x_{-1} = x_{N-1}$ 和 $x_N = x_0$。\n\n问题指定了 Wolfram 规则 $4$。数字 $4$ 的二进制是 $00000100_2$。根据 Wolfram 的约定，这个二进制字符串定义了 $\\phi$ 对于八种可能邻域的输出，顺序从 $(1,1,1)$ 到 $(0,0,0)$：\n- $\\phi(1,1,1) = 0$\n- $\\phi(1,1,0) = 0$\n- $\\phi(1,0,1) = 0$\n- $\\phi(1,0,0) = 0$\n- $\\phi(0,1,1) = 0$\n- $\\phi(0,1,0) = 1$\n- $\\phi(0,0,1) = 0$\n- $\\phi(0,0,0) = 0$\n\n因此，局部规则异常简单：一个元胞的新状态为 $1$ 当且仅当其邻域模式为 $(0,1,0)$（左邻居为 $0$，元胞为 $1$，右邻居为 $0$）。否则，新状态为 $0$。\n\n一个组态 $y \\in \\mathcal{C}$ 是伊甸园状态，如果它在 $F$ 下没有原像。也就是说，其原像集 $F^{-1}(y) = \\{x \\in \\mathcal{C} \\mid F(x) = y\\}$ 为空。任务是找到这类状态的数量，即 $| \\{y \\in \\mathcal{C} \\mid |F^{-1}(y)|=0 \\} |$。\n\n问题要求一个基于直接枚举的解决方案，而不是基于预先推导的解析公式。对于每个给定的系统大小 $N$，算法流程如下：\n\n1.  **初始化原像计数器**：创建一个大小为 $2^N$ 的数组，我们称之为 `preimage_counts`，所有条目初始化为 $0$。该数组的每个索引 $j$（从 $0$ 到 $2^N-1$）将对应一个唯一的组态 $y \\in \\mathcal{C}$（表示为整数 $j$），并将存储其原像集的大小 $|F^{-1}(y)|$。\n\n2.  **遍历所有初始状态**：遍历所有 $2^N$ 个可能的初始组态 $x \\in \\mathcal{C}$。一种方便的方法是迭代一个从 $0$ 到 $2^N-1$ 的整数 $i$，并使用其 $N$ 位二进制表示作为组态 $x$。\n\n3.  **计算后继状态**：对于每个组态 $x$，计算其后继状态 $y = F(x)$。这涉及对每个元胞 $x_i$ 及其邻居应用规则 $4$ 的逻辑，同时遵守周期性边界条件。\n    使用向量化操作，这一步是高效的。给定一个表示组态的数组 `x`：\n    - 左邻居数组为 `np.roll(x, 1)`。\n    - 右邻居数组为 `np.roll(x, -1)`。\n    - 后继组态 `y` 是通过检查所有元胞是否同时满足邻域条件 $(0,1,0)$ 来计算的。\n\n4.  **更新原像计数**：将得到的组态 $y$（一个由 $0$ 和 $1$ 组成的数组）转换回其唯一的整数表示，比如 $j$。在该索引处增加计数器：`preimage_counts[j]++`。\n\n5.  **计算伊甸园状态**：遍历所有 $2^N$ 个初始状态 $x$ 后，`preimage_counts` 数组被完全填充。伊甸园状态的数量就是此数组中保持为 $0$ 的条目数。\n\n对测试套件 $\\{1, 2, 3, 4, 5, 6, 8\\}$ 中的每个 $N$ 值重复此过程，并将得到的结果计数收集到一个列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_goe_count(N):\n    \"\"\"\n    Calculates the number of Garden of Eden states for a given system size N\n    under Wolfram's Rule 4 with periodic boundary conditions.\n\n    The calculation is done by explicit enumeration as required by the problem.\n    \"\"\"\n    num_total_configs = 1  N  # This is 2**N\n\n    # Array to store the number of preimages for each of the 2^N possible configurations.\n    # The index of the array corresponds to the integer representation of a configuration.\n    preimage_counts = np.zeros(num_total_configs, dtype=np.int64)\n\n    # Iterate through all 2^N possible initial configurations 'x'.\n    # Each integer 'i' from 0 to 2^N-1 corresponds to a unique configuration.\n    for i in range(num_total_configs):\n        # 1. Convert the integer 'i' to its N-bit binary representation (configuration x).\n        # The representation is created as a NumPy array of integers.\n        x = np.array([int(bit) for bit in np.binary_repr(i, width=N)])\n\n        # 2. Compute the next state 'y = F(x)' under Rule 4.\n        # This is done efficiently using NumPy's vectorized operations.\n        # np.roll provides periodic boundary conditions.\n        left_neighbors = np.roll(x, 1)\n        center_cells = x\n        right_neighbors = np.roll(x, -1)\n\n        # Rule 4: the output is 1 if and only if the neighborhood is (0, 1, 0).\n        y = ((left_neighbors == 0)  (center_cells == 1)  (right_neighbors == 0)).astype(np.int8)\n\n        # 3. Convert the resulting configuration 'y' to its integer representation.\n        # This is done by treating the binary array as a base-2 number.\n        y_int = 0\n        for bit in y:\n            y_int = (y_int  1) | bit\n\n        # 4. Increment the preimage count for the computed configuration 'y'.\n        preimage_counts[y_int] += 1\n\n    # 5. The number of Garden of Eden states is the count of configurations 'y'\n    #    that have zero preimages.\n    goe_count = np.sum(preimage_counts == 0)\n    \n    return goe_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 5, 6, 8]\n\n    results = []\n    for N in test_cases:\n        # Calculate the number of GoE states for each system size N.\n        result = calculate_goe_count(N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了基本的状态空间可达性分析后，我们将目光转向动态演化的复杂性。规则30是Wolfram分类中第三类（混沌类）自动机的典型代表，以其从简单初始条件生成高度不规则和不可预测模式的能力而闻名。本练习要求你模拟规则30的演化过程，并超越简单的视觉观察，通过量化一个关键指标——随时间变化的邻域类型数量——来分析其复杂性的增长。这项实践将使你深入理解元胞自动机如何成为一个生成复杂性的“引擎”，并锻炼你从系统演化数据中提取有意义模式的分析技能。",
            "id": "4151322",
            "problem": "您的任务是推导并实现一个由 Wolfram 规则分类所支配的初等元胞自动机 (ECA) 的完整模拟，特别要关注规则 $30$。目标是计算在一个长度为 $L$、具有周期性边界条件的一维环上，从单个活动元胞开始，在 $T$ 个离散时间步长内的时空演化，然后严格地总结每个时间步中不同邻域频率的增长情况。\n\n假设以下是推导和实现的基本依据：\n\n- 初等元胞自动机 (ECA) 是一个在二元状态空间 $\\{0,1\\}^L$ 上的离散时间动力系统，具有局部更新函数 $f : \\{0,1\\}^3 \\to \\{0,1\\}$。全局更新是空间平移不变的，并同步应用于所有位点。\n- 在时间步 $t$ 的构型表示为 $\\mathbf{x}^{(t)} = (x^{(t)}_0, x^{(t)}_1, \\ldots, x^{(t)}_{L-1}) \\in \\{0,1\\}^L$，具有周期性边界条件 $x^{(t)}_{i} = x^{(t)}_{i \\bmod L}$。\n- 在位点 $i$ 和时间 $t$ 的局部邻域是三元组 $\\left(x^{(t)}_{i-1}, x^{(t)}_{i}, x^{(t)}_{i+1}\\right)$，其索引按模 $L$ 解释。\n\n定义初等元胞自动机规则 $30$ 的局部规则如下。设 $R=30$ 为规则编号。将每个邻域三元组 $\\left(a,b,c\\right) \\in \\{0,1\\}^3$ 与其代码 $n = 4a + 2b + c \\in \\{0,\\ldots,7\\}$ 相关联。规则 $R$ 在邻域代码 $n$ 上的输出是 $R$ 的 8 位二进制展开的第 $n$ 位，其中最低有效位对应于邻域代码 $n=0$（即 $\\left(0,0,0\\right)$），最高有效位对应于邻域代码 $n=7$（即 $\\left(1,1,1\\right)$）。具体来说，对于 $R=30$，二进制模式为 $00011110$，因此\n$$\nf(1,1,1)=0,\\; f(1,1,0)=0,\\; f(1,0,1)=0,\\; f(1,0,0)=1,\\; f(0,1,1)=1,\\; f(0,1,0)=1,\\; f(0,0,1)=1,\\; f(0,0,0)=0.\n$$\n\n初始条件：在时间 $t=0$，构型 $\\mathbf{x}^{(0)}$ 在索引 $i_0 = \\lfloor L/2 \\rfloor$ 处有一个活动元胞，即 $x^{(0)}_{i_0} = 1$ 且对于所有 $i \\neq i_0$ 都有 $x^{(0)}_{i} = 0$。\n\n对于每个时间步 $t \\in \\{0,1,\\ldots,T\\}$，定义邻域代码场\n$$\nn^{(t)}_i = 4 x^{(t)}_{i-1} + 2 x^{(t)}_{i} + x^{(t)}_{i+1},\n$$\n并定义频率向量 $\\mathbf{F}^{(t)} \\in \\mathbb{N}^8$，其第 $k$ 个分量 $F^{(t)}_k$ 是满足 $n^{(t)}_i = k$ 的索引 $i \\in \\{0,\\ldots,L-1\\}$ 的计数。将在时间 $t$ 的不同邻域计数定义为\n$$\nD^{(t)} = \\left|\\left\\{k \\in \\{0,\\ldots,7\\} \\,\\middle|\\, F^{(t)}_k > 0 \\right\\}\\right|.\n$$\n该运行的增长摘要是整数列表 $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$。\n\n您的任务是实现一个程序，对于每个测试用例 $(L,T)$，从指定的初始条件开始计算规则 $30$ 下的演化，并返回增长摘要列表 $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$。\n\n设计约束：\n\n- 所有计算都必须使用上述定义和周期性边界条件，以纯数学术语进行。此问题不涉及任何物理单位。\n- 您的实现必须是确定性的和空间平移不变的，在每个时间步将局部更新函数 $f$ 同步应用于所有位点。\n\n测试套件：\n\n使用以下参数值在典型和边缘情况下验证算法：\n\n1. 一般场景：$L=51$, $T=25$。\n2. 最小环尺寸：$L=1$, $T=10$。\n3. 小的偶数尺寸环：$L=2$, $T=10$。\n4. 小的奇数尺寸环：$L=3$, $T=12$。\n5. 较大的偶数尺寸环：$L=64$, $T=20$。\n6. 时间步上的边界条件：$L=13$, $T=0$。\n\n最终输出规范：\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表形式的结果，其中第 $j$ 个元素是按上述顺序列出的第 $j$ 个测试用例的增长摘要列表 $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$。例如，输出行将具有以下形式\n$$\n[\\,[d_{0,0}, d_{0,1}, \\ldots, d_{0,T_0}],\\,[d_{1,0}, \\ldots, d_{1,T_1}],\\,\\ldots\\,]\n$$\n不带任何描述性文本。每个 $d_{j,t}$ 都必须是整数。",
            "solution": "问题陈述在形式上是合理的、自洽的，并且在数学上是适定的。它描述了初等元胞自动机 (ECA) 的确定性模拟，其中所有必要的参数、初始条件、边界条件和定义都得到了明确的规定。因此，该问题被认为是有效的，一个完整的解决方案推导和实现如下。\n\n问题的核心是模拟一维二元元胞自动机的时间演化，并在每个时间步量化局部邻域的多样性。该解决方案可以分解为几个逻辑步骤：表示系统状态、实现更新规则、模拟时间演化以及计算指定的度量。\n\n首先，我们将时间 $t$ 的系统状态（表示为 $\\mathbf{x}^{(t)}$）表示为一个长度为 $L$ 的一维数组。该数组的元素 $x^{(t)}_i$ 在 $\\{0, 1\\}$ 中取值。$t=0$ 时的初始条件是一个除了在索引 $i_0 = \\lfloor L/2 \\rfloor$ 处有一个活动元胞（$x^{(0)}_{i_0} = 1$）外，其余全为零的晶格。在计算术语中，这是一个相应初始化的、大小为 $L$ 的整数数组。\n\n其次，我们必须实现 ECA 规则 30 的局部更新函数 $f$。该规则根据邻域 $\\left(x^{(t)}_{i-1}, x^{(t)}_{i}, x^{(t)}_{i+1}\\right)$ 来确定状态 $x^{(t+1)}_i$。问题定义了一个标准映射，其中每个邻域三元组 $(a,b,c)$ 被转换为一个数值代码 $n = 4a + 2b + c$。规则的输出是规则编号 $R=30$ 的二进制表示的第 $n$ 位。30 的 8 位二进制表示是 $00011110_2$。我们构建一个长度为 8 的数组作为查找表，它将每个邻域代码 $n \\in \\{0, \\dots, 7\\}$ 映射到其输出状态 $\\{0, 1\\}$。根据问题的规范（最低有效位对应于 $n=0$），规则 30 的查找表是 $[0, 1, 1, 1, 1, 0, 0, 0]$。即 $f(\\text{code}=0)=0, f(\\text{code}=1)=1, \\dots, f(\\text{code}=7)=0$。\n\n第三，我们模拟系统的同步演化。为了从 $\\mathbf{x}^{(t)}$ 计算构型 $\\mathbf{x}^{(t+1)}$，我们必须首先确定每个元胞 $i \\in \\{0, \\dots, L-1\\}$ 的邻域。问题指定了周期性边界条件，这意味着晶格被视为一个环。在计算上，这可以通过创建状态数组 $\\mathbf{x}^{(t)}$ 的移位版本来高效处理。左邻居数组是通过将 $\\mathbf{x}^{(t)}$向右移动一个位置获得的（例如，`np.roll(x, 1)`），而右邻居数组是通过向左移动一个位置获得的（例如，`np.roll(x, -1)`）。有了左邻居、中心元胞和右邻居的数组，我们可以使用向量化算术同时为所有位点计算邻域代码 $n^{(t)}_i = 4x^{(t)}_{i-1} + 2x^{(t)}_{i} + x^{(t)}_{i+1}$。这将产生一个邻域代码数组，晶格上的每个位点都有一个。然后通过将规则 30 查找表应用于此代码数组来找到下一个状态 $\\mathbf{x}^{(t+1)}$。\n\n第四，对于从 $0$ 到 $T$ 的每个时间步 $t$，我们必须计算不同邻域的计数 $D^{(t)}$。这被定义为在该时间步整个晶格上出现的唯一邻域代码的数量。作为演化步骤的一部分，我们已经计算了所有 $i$ 的邻域代码数组 $n^{(t)}_i$，因此我们可以找到此数组中唯一值的集合并计算其大小。这个计数就是 $D^{(t)}$。\n\n对于给定的测试用例 $(L, T)$，完整的算法如下：\n1. 初始化一个空列表 `growth_summary`，用于存储值 $[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}]$。\n2. 创建长度为 $L$ 的初始状态数组 $\\mathbf{x}^{(0)}$，在索引 $\\lfloor L/2 \\rfloor$ 处有一个 1。\n3. 将规则 30 的查找表定义为 $[0, 1, 1, 1, 1, 0, 0, 0]$。\n4. 开始一个从 $0$ 到 $T$（含）的每个时间步 $t$ 的循环。\n5. 在循环内部，对于当前构型 $\\mathbf{x}^{(t)}$：\n    a. 使用周期性移位和向量化算术确定所有位点的邻域代码数组。\n    b. 找到此数组中唯一代码的数量，并将此计数 $D^{(t)}$ 附加到 `growth_summary`。\n    c. 如果 $t  T$，则通过将规则 30 查找表应用于邻域代码数组来计算下一个状态 $\\mathbf{x}^{(t+1)}$。\n6. 循环完成后，`growth_summary` 列表包含该测试用例所需的输出。\n对问题陈述中提供的所有测试用例重复此过程，并将最终结果按规定格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the space-time evolution of Elementary Cellular Automaton (ECA) Rule 30\n    for a set of test cases and calculates the growth summary of distinct neighborhood frequencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (51, 25),   # A general scenario\n        (1, 10),    # Minimal ring size\n        (2, 10),    # Small even ring\n        (3, 12),    # Small odd ring\n        (64, 20),   # Larger even ring\n        (13, 0),    # Boundary condition on time steps\n    ]\n\n    # The local rule for ECA rule 30 is derived from its binary representation.\n    # R=30 in binary is 00011110.\n    # The output for a neighborhood code 'n' is the n-th bit, with n=0 being the LSB.\n    # The neighborhood code n is calculated as n = 4*left + 2*center + 1*right.\n    # Index 0 corresponds to code 0 (0,0,0) - 0\n    # Index 1 corresponds to code 1 (0,0,1) - 1\n    # ...\n    # Index 7 corresponds to code 7 (1,1,1) - 0\n    rule_30_map = np.array([0, 1, 1, 1, 1, 0, 0, 0], dtype=np.int8)\n\n    all_results = []\n\n    for L, T in test_cases:\n        # Step 1: Initialize the configuration and result list.\n        # The configuration 'x' is a 1D numpy array representing the lattice.\n        # Initial condition: a single active cell at the center.\n        x = np.zeros(L, dtype=np.int8)\n        if L > 0:\n            i_0 = L // 2\n            x[i_0] = 1\n        \n        growth_summary = []\n\n        # Step 2: Loop through each time step from 0 to T.\n        for t in range(T + 1):\n            if L == 0:\n                # Edge case: for a lattice of size 0, there are no neighborhoods.\n                D_t = 0\n            else:\n                # Step 3: Compute neighborhood codes for the current configuration 'x'.\n                # np.roll handles periodic boundary conditions efficiently.\n                x_left = np.roll(x, 1)\n                x_right = np.roll(x, -1)\n                \n                # Vectorized calculation of neighborhood codes for all sites.\n                neighborhood_codes = 4 * x_left + 2 * x + x_right\n\n                # Step 4: Calculate D^(t), the count of distinct neighborhood codes.\n                unique_codes = np.unique(neighborhood_codes)\n                D_t = len(unique_codes)\n            \n            growth_summary.append(D_t)\n\n            # Step 5: Update the configuration for the next time step.\n            # This is skipped on the final iteration (t=T) as x^(T+1) is not needed.\n            if t  T and L > 0:\n                x = rule_30_map[neighborhood_codes]\n        \n        all_results.append(growth_summary)\n\n    # Step 6: Format the final output according to the problem specification.\n    # The output should be a single line: [[...],[...],...]\n    inner_lists_str = [f\"[{','.join(map(str, summary))}]\" for summary in all_results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "虽然计算实验为了解有限系统提供了宝贵的直觉，但要对无限系统作出严格的论断，我们需要更强大的形式化工具。本练习引入了德布鲁因图（De Bruijn graph），这是符号动力学中一个核心的分析工具，它能将元胞自动机的局部规则转化为一个有向图，从而揭示其全局性质。通过将此方法应用于规则90（一个具有线性结构的加性规则），你将学习如何严格证明满射性和单射性等属性，并将元胞自动机理论与图论和有限域上的线性代数联系起来。这个练习将极大地提升你从局部规则推断全局行为的理论分析能力。",
            "id": "4151338",
            "problem": "令 $f:\\{0,1\\}^{3}\\to\\{0,1\\}$ 为一个在一维双无限构型空间 $\\{0,1\\}^{\\mathbb{Z}}$ 上半径为 $1$ 的初等元胞自动机 (ECA) 的局部规则。其关联的全局映射 $F:\\{0,1\\}^{\\mathbb{Z}}\\to\\{0,1\\}^{\\mathbb{Z}}$ 定义为对所有 $i\\in\\mathbb{Z}$，有 $(F(x))_{i}=f(x_{i-1},x_{i},x_{i+1})$。该 ECA 的 2 阶德布鲁因图是一个有向图，其顶点集为 $\\{0,1\\}^{2}$，对于每个 $(a,b,c)\\in\\{0,1\\}^{3}$，都有一条从 $(a,b)$ 到 $(b,c)$ 的边，其标签为 $\\lambda(a,b,c)=f(a,b,c)$。在此标记图中，一条双无限路径会产生一个在 $\\{0,1\\}^{\\mathbb{Z}}$ 中的双无限标签序列，而每个双无限构型 $x\\in\\{0,1\\}^{\\mathbb{Z}}$ 会产生一个双无限顶点序列 $(x_{i},x_{i+1})_{i\\in\\mathbb{Z}}$ 和一个边标签序列 $(f(x_{i-1},x_{i},x_{i+1}))_{i\\in\\mathbb{Z}}$。\n\n从这些核心定义出发，基于符号动力学和 sofic 移位的图表示，进行以下推导：\n\n- 推导一个关于 $F$ 到 $\\{0,1\\}^{\\mathbb{Z}}$ 的满射性的图论检验方法，该方法需用标记的德布鲁因图来表述。你的检验方法必须仅使用上述基本定义和移位空间的标记图表示的既有性质来陈述和证明。\n\n- 推导一个关于 $F$ 的单射性的图论检验方法，该方法需根据标记的德布鲁因图中是否存在产生相同双无限标签序列的多条不同双无限路径来判断。同样，直接根据定义和标记表示的性质来证明该检验方法。\n\n- 将你的检验方法应用于 ECA 规则 $90$，其局部规则为 $f(a,b,c)=a\\oplus c$，其中 $\\oplus$ 表示模 2 加法。证明 $F$ 在 $\\{0,1\\}^{\\mathbb{Z}}$ 上是满射但非单射的。\n\n- 最后，将规则 90 视为在含两个元素的域 $\\mathbb{F}_{2}$ 上的线性元胞自动机，并计算 $F$ 作为 $\\mathbb{F}_{2}^{\\mathbb{Z}}$ 上线性映射的核 $\\ker(F)$ 的维数 $\\dim_{\\mathbb{F}_{2}}(\\ker(F))$。\n\n你最终报告的量必须是 $\\dim_{\\mathbb{F}_{2}}(\\ker(F))$ 的单个整数值。无需四舍五入，也无单位。以单个数字形式表示最终答案。",
            "solution": "所述问题是符号动力学、元胞自动机和有限域上线性代数领域中一个定义明确的数学练习。所有术语都得到了正式定义，所要求的推导在文献中是标准的，问题是自洽且逻辑一致的。没有科学或事实上的不健全之处，没有歧义，并且问题是可验证的。因此，该问题是有效的，将提供解答。\n\n解答按要求分为四个部分：推导满射性检验方法，推导单射性检验方法，将这些检验方法应用于初等元胞自动机 (ECA) 规则 90，以及计算将规则 90 视为线性映射时的核维数。\n\n### 第 1 部分：满射性的图论检验方法\n\n全局映射 $F:\\{0,1\\}^{\\mathbb{Z}}\\to\\{0,1\\}^{\\mathbb{Z}}$ 是满射的，如果对于每一个双无限标签序列 $y \\in \\{0,1\\}^{\\mathbb{Z}}$，都存在至少一个双无限构型 $x \\in \\{0,1\\}^{\\mathbb{Z}}$ 使得 $F(x) = y$。\n\n在标记的德布鲁因图框架中，一个构型 $x$ 对应于一条穿过图顶点的双无限路径，具体来说是顶点路径 $(v_i)_{i \\in \\mathbb{Z}} = ((x_i, x_{i+1}))_{i \\in \\mathbb{Z}}$。输出构型 $y=F(x)$ 是形成这条路径的边上的标签序列，其中 $y_i = (F(x))_i = f(x_{i-1}, x_i, x_{i+1})$ 是从顶点 $(x_{i-1}, x_i)$ 到顶点 $(x_i, x_{i+1})$ 的边的标签。\n\n由标记的德布鲁因图中的路径可以生成的所有可能的双无限标签序列的集合被称为 sofic 移位。映射 $F$ 是满射的，当且仅当这个 sofic 移位是“全移位”$\\{0,1\\}^{\\mathbb{Z}}$，这意味着可以产生来自 $\\{0,1\\}^{\\mathbb{Z}}$ 的任何任意标签序列。\n\n为了使任意标签序列 $y=(y_i)_{i\\in\\mathbb{Z}}$ 都能被产生，我们必须能够构建一个相应的顶点路径 $(v_i)_{i\\in\\mathbb{Z}}$。这意味着，对于路径构建中的任何给定状态（顶点）$v_i$ 和任何期望的下一个标签 $y_{i+1}$，必须存在一个下一个顶点 $v_{i+1}$，可以从 $v_i$ 通过一条带有标签 $y_{i+1}$ 的边到达。如果这个条件对所有顶点和所有可能的标签都成立，我们就可以将任何生成有限标签字符串的有限路径扩展为生成双无限标签序列的双无限路径。\n\n因此，满射性的图论检验方法如下：\n**满射性检验：** 全局映射 $F$ 是满射的，当且仅当在标记的德布鲁因图中，从每个顶点 $v$ 出发，对于 $\\{0,1\\}$ 中的每个可能标签，都至少有一条出边。\n\n### 第 2 部分：单射性的图论检验方法\n\n全局映射 $F$ 是单射的，如果对于任何两个不同的构型 $x, x' \\in \\{0,1\\}^{\\mathbb{Z}}$（即 $x \\neq x'$），它们的像也不同，$F(x) \\neq F(x')$。等价地，$F$ 不是单射的，如果存在 $x \\neq x'$ 使得 $F(x) = F(x')$。\n\n在图表示中，$x \\neq x'$ 意味着它们对应的双无限顶点路径 $(v_i)_{i\\in\\mathbb{Z}}$ 和 $(v'_i)_{i\\in\\mathbb{Z}}$ 是不同的。$F(x) = F(x')$ 意味着这两条不同的顶点路径产生了完全相同的双无限边标签序列。\n\n存在这样一对产生相同标签序列的不同路径，是此背景下非单射性的定义性特征。这种情况发生当且仅当图中包含所谓的“菱形”：一对不同的路径，它们共享一个共同的起始顶点和一个共同的结束顶点，并且沿着路径的边标签序列相同。如果存在这样的有限菱形结构，人们可以通过将菱形嵌入到一个周围共同约定的路径中，来构造两个具有相同像的不同双无限构型。\n\n因此，单射性的图论检验方法如下：\n**单射性检验：** 全局映射 $F$ 是单射的，当且仅当标记的德布鲁因图中不包含“菱形”。一个菱形是一对不同的有限路径 $\\pi_1$ 和 $\\pi_2$，它们从同一个顶点 $u$ 开始，到同一个顶点 $v$ 结束，并且 $\\pi_1$ 上的边标签序列与 $\\pi_2$ 上的边标签序列完全相同。对于任何顶点对 $u,v$ 和任何路径长度，不存在这样的结构，可以保证任何给定的标签序列最多只能由一条路径生成，从而确保单射性。\n\n### 第 3 部分：应用于规则 90\n\nECA 规则 90 由局部规则 $f(a,b,c) = a \\oplus c$ 定义，其中 $\\oplus$ 是模 2 加法。德布鲁因图的顶点集为 $\\{ (0,0), (0,1), (1,0), (1,1) \\}$。边形如 $(a,b)\\to(b,c)$，标签为 $a \\oplus c$。8 种可能的转移及其标签是：\n\\begin{itemize}\n    \\item $f(0,0,0) = 0 \\oplus 0 = 0$：边 $(0,0) \\to (0,0)$，标签为 $0$。\n    \\item $f(0,0,1) = 0 \\oplus 1 = 1$：边 $(0,0) \\to (0,1)$，标签为 $1$。\n    \\item $f(0,1,0) = 0 \\oplus 0 = 0$：边 $(0,1) \\to (1,0)$，标签为 $0$。\n    \\item $f(0,1,1) = 0 \\oplus 1 = 1$：边 $(0,1) \\to (1,1)$，标签为 $1$。\n    \\item $f(1,0,0) = 1 \\oplus 0 = 1$：边 $(1,0) \\to (0,0)$，标签为 $1$。\n    \\item $f(1,0,1) = 1 \\oplus 1 = 0$：边 $(1,0) \\to (0,1)$，标签为 $0$。\n    \\item $f(1,1,0) = 1 \\oplus 0 = 1$：边 $(1,1) \\to (1,0)$，标签为 $1$。\n    \\item $f(1,1,1) = 1 \\oplus 1 = 0$：边 $(1,1) \\to (1,1)$，标签为 $0$。\n\\end{itemize}\n\n**规则 90 的满射性：**\n我们应用满射性检验。我们检查每个顶点的出边标签：\n\\begin{itemize}\n    \\item 从顶点 $(0,0)$：出边标签为 $\\{0, 1\\}$。\n    \\item 从顶点 $(0,1)$：出边标签为 $\\{0, 1\\}$。\n    \\item 从顶点 $(1,0)$：出边标签为 $\\{0, 1\\}$。\n    \\item 从顶点 $(1,1)$：出边标签为 $\\{0, 1\\}$。\n\\end{itemize}\n因为每个顶点都有对应两个可能标签 $0$ 和 $1$ 的出边，所以满足满射性条件。因此，**对于规则 90，$F$ 是满射的**。\n\n**规则 90 的单射性：**\n我们通过寻找映射到相同输出的不同构型来应用单射性检验。\n考虑构型 $x = (\\dots, 0, 0, 0, \\dots)$，即全零构型。对于任何位置 $i$，其邻域为 $(0,0,0)$。输出为 $(F(x))_i = f(0,0,0) = 0 \\oplus 0 = 0$。所以，$F(x)$ 是全零构型。\n\n现在考虑构型 $x' = (\\dots, 1, 0, 1, 0, 1, 0, \\dots)$，即交替或“棋盘”构型。\n\\begin{itemize}\n    \\item 在一个位置 $i$ 其中 $x'_i = 0$，其邻域为 $(x'_{i-1}, x'_i, x'_{i+1}) = (1,0,1)$。输出为 $(F(x'))_i = f(1,0,1) = 1 \\oplus 1 = 0$。\n    \\item 在一个位置 $i$ 其中 $x'_i = 1$，其邻域为 $(x'_{i-1}, x'_i, x'_{i+1}) = (0,1,0)$。输出为 $(F(x'))_i = f(0,1,0) = 0 \\oplus 0 = 0$。\n\\end{itemize}\n在这两种情况下，输出都是 $0$。因此，$F(x')$ 也是全零构型。\n我们找到了两个不同的构型 $x \\neq x'$，使得 $F(x) = F(x') = (\\dots, 0, 0, 0, \\dots)$。\n在图表示中，这对应于两条不同的双无限路径产生全零标签序列：\n1.  $x$ 的路径：顶点 $(0,0)$ 处的自环。边为 $(0,0) \\to (0,0)$，标签为 $0$。\n2.  $x'$ 的路径：顶点 $(0,1)$ 和 $(1,0)$ 之间的 2-环。边 $(0,1) \\to (1,0)$ 的标签为 $0$，边 $(1,0) \\to (0,1)$ 的标签也为 $0$。\n这两条不同的路径/环路都生成序列 $(\\dots, 0, 0, 0, \\dots)$，这构成了一种菱形结构。\n因此，**对于规则 90，$F$ 不是单射的**。\n\n### 第 4 部分：规则 90 的核维数\n\n我们将 ECA 视为在域 $\\mathbb{F}_{2}$ 上的向量空间 $\\mathbb{F}_{2}^{\\mathbb{Z}}$ 上的一个线性映射 $F$。全局映射由 $(F(x))_i = x_{i-1} + x_{i+1}$ 给出，其中算术是模 2 的。$F$ 的核，记作 $\\ker(F)$，是所有构型 $x \\in \\mathbb{F}_{2}^{\\mathbb{Z}}$ 的集合，使得 $F(x) = \\mathbf{0}$，其中 $\\mathbf{0}$ 是全零构型。\n\n$x \\in \\ker(F)$ 的条件是对于所有 $i \\in \\mathbb{Z}$，有 $(F(x))_i = 0$。\n$$x_{i-1} + x_{i+1} = 0 \\pmod 2$$\n这等价于线性递推关系：\n$$x_{i+1} = x_{i-1} \\quad \\text{for all } i \\in \\mathbb{Z}$$\n这个关系意味着对所有 $i$ 都有 $x_{i+2} = x_i$。这意味着核中的任何序列都必须是周期为 2 的。\n\n一个周期为 2 的双无限序列 $x$ 完全由任何两个相邻元素的值确定，例如 $x_0$ 和 $x_1$。令 $x_0 = c_0$ 和 $x_1 = c_1$，其中 $c_0, c_1 \\in \\mathbb{F}_2$。那么整个序列的形式为：\n$$x = (\\dots, c_1, c_0, c_1, c_0, c_1, \\dots)$$\n所有此类序列的集合 $\\ker(F)$ 构成了 $\\mathbb{F}_{2}^{\\mathbb{Z}}$ 的一个向量子空间。我们可以定义一个向量空间同构 $\\phi: \\ker(F) \\to \\mathbb{F}_{2}^{2}$，通过将一个序列 $x$ 映射到定义它的那对值：$\\phi(x) = (x_0, x_1)$。\n由于 $\\ker(F)$ 同构于向量空间 $\\mathbb{F}_{2}^{2}$，它们的维数必须相等。$\\mathbb{F}_{2}^{2}$ 在 $\\mathbb{F}_{2}$ 上的维数是 $2$。\n\n另外，我们可以为 $\\ker(F)$ 确定一组基。令 $b_0$ 是由 $(x_0, x_1) = (1,0)$ 定义的序列。这是序列 $(\\dots, 0, 1, 0, 1, 0, \\dots)$，其中 $x_0=1$。令 $b_1$ 是由 $(x_0, x_1) = (0,1)$ 定义的序列。这是序列 $(\\dots, 1, 0, 1, 0, 1, \\dots)$，其中 $x_1=1$。向量 $b_0$ 和 $b_1$ 是线性无关的。任何序列 $x \\in \\ker(F)$ 及其 $(x_0, x_1) = (c_0, c_1)$ 都可以写成唯一的线性组合 $x = c_0 b_0 + c_1 b_1$。因此，$\\{b_0, b_1\\}$ 是 $\\ker(F)$ 的一组基，其维数是基向量的数量。\n\n核的维数是 $2$。核包含 $2^2=4$ 个元素：全零序列 $(c_0=0, c_1=0)$，全一序列 $(c_0=1, c_1=1)$，以及两个交替序列。\n\n因此，$F$ 的核的维数是 $2$。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}