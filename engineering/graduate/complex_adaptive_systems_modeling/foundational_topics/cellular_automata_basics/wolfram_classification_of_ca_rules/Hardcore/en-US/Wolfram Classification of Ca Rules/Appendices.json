{
    "hands_on_practices": [
        {
            "introduction": "The global transition map of a cellular automaton defines which configurations can evolve from others. A fundamental question is whether this map is surjective—can every possible configuration be reached in a single time step? This exercise  invites you to explore this question computationally by searching for \"Garden of Eden\" states, configurations with no preimages, for the non-surjective Rule 4, providing a concrete demonstration of constraints on a system's dynamics.",
            "id": "4151267",
            "problem": "You are given a one-dimensional, binary cellular automaton of the Elementary Cellular Automata (ECA) type in the sense of Stephen Wolfram, defined on a ring of $N$ cells with periodic boundary conditions. Each cell has state in $\\{0,1\\}$, and the global update map $F:\\{0,1\\}^N\\to\\{0,1\\}^N$ is induced by a local update function $\\phi:\\{0,1\\}^3\\to\\{0,1\\}$ that depends on the left neighbor, the cell itself, and the right neighbor. Wolfram’s rule numbering assigns to each ECA a number $r\\in\\{0,\\dots,255\\}$ whose binary expansion encodes $\\phi$ on the eight neighborhoods from $111$ down to $000$. A Garden of Eden (GoE) state is a configuration $y\\in\\{0,1\\}^N$ with no preimage under $F$, i.e., there is no $x\\in\\{0,1\\}^N$ such that $F(x)=y$. A global map $F$ is surjective if for every $y\\in\\{0,1\\}^N$ there exists at least one $x$ with $F(x)=y$. In complex adaptive systems modeling, identifying non-surjective rules and their Garden of Eden states is fundamental for understanding state-space accessibility and rule-induced constraints.\n\nStarting from the core definitions of functions, surjectivity, and the local-to-global construction of ECA, demonstrate the existence of Garden of Eden states for a non-surjective rule by explicit enumeration of preimages for Wolfram’s rule $4$. For rule $4$, the local update function $\\phi$ is defined by the binary encoding of $4$ which equals $00000100$; interpreting the least significant bit as the output for neighborhood $000$ and the most significant bit as the output for neighborhood $111$, this means $\\phi(0,1,0)=1$ and $\\phi$ is $0$ on all other neighborhoods.\n\nYour task is to write a complete, runnable program that, for each provided system size $N$, enumerates all $2^N$ configurations $x\\in\\{0,1\\}^N$, computes $y=F(x)$ under rule $4$ on the ring (periodic boundary conditions), accumulates the number of preimages of each $y\\in\\{0,1\\}^N$, and finally counts how many $y$ have zero preimages (i.e., are Garden of Eden states). You must not assume any pre-derived formulas for preimage counts; the enumeration must follow directly from the definitions.\n\nTest Suite:\n- Use the following system sizes $N$: $1$, $2$, $3$, $4$, $5$, $6$, $8$.\n\nAnswer Specification:\n- For each $N$ in the test suite, compute an integer equal to the number of Garden of Eden states for that $N$ under rule $4$.\n- Aggregate the results across all test cases into a single list of integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nNo physical units or angles are involved; all quantities are purely combinatorial and must be presented as integers as specified. The solution must rely strictly on the foundational definitions and logic of functions, surjectivity, and the local-to-global construction for ECA on finite rings.",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the established theory of cellular automata, is well-posed with a unique and computable solution, and is formulated using objective, unambiguous language. The task is a direct application of foundational definitions, requiring the enumeration of state transitions to identify Garden of Eden configurations.\n\nThe problem asks for the number of Garden of Eden (GoE) states for Wolfram's Elementary Cellular Automaton (ECA) Rule $4$ on a one-dimensional ring of $N$ cells. A GoE state is a configuration that cannot be reached from any other configuration in one time step.\n\nLet the set of all possible configurations be $\\mathcal{C} = \\{0, 1\\}^N$. A configuration is a vector $x = (x_0, x_1, \\ldots, x_{N-1})$, where each $x_i \\in \\{0, 1\\}$. The total number of configurations is $|\\mathcal{C}| = 2^N$.\n\nThe global update map $F: \\mathcal{C} \\to \\mathcal{C}$ is determined by a local update function $\\phi: \\{0, 1\\}^3 \\to \\{0, 1\\}$. For a configuration $x$, the next configuration $y = F(x)$ is given by:\n$$y_i = \\phi(x_{i-1}, x_i, x_{i+1})$$\nfor $i = 0, 1, \\ldots, N-1$. The boundary conditions are periodic, so indices are interpreted modulo $N$. For example, $x_{-1} = x_{N-1}$ and $x_N = x_0$.\n\nThe problem specifies Wolfram Rule $4$. The number $4$ in binary is $00000100_2$. According to Wolfram's convention, this binary string defines the output of $\\phi$ for the eight possible neighborhoods, ordered from $(1,1,1)$ down to $(0,0,0)$:\n- $\\phi(1,1,1) = 0$\n- $\\phi(1,1,0) = 0$\n- $\\phi(1,0,1) = 0$\n- $\\phi(1,0,0) = 0$\n- $\\phi(0,1,1) = 0$\n- $\\phi(0,1,0) = 1$\n- $\\phi(0,0,1) = 0$\n- $\\phi(0,0,0) = 0$\n\nThus, the local rule is exceptionally simple: the new state of a cell is $1$ if and only if its neighborhood pattern is $(0,1,0)$ (left neighbor is $0$, cell is $1$, right neighbor is $0$). Otherwise, the new state is $0$.\n\nA configuration $y \\in \\mathcal{C}$ is a Garden of Eden state if it has no preimage under $F$. That is, the preimage set $F^{-1}(y) = \\{x \\in \\mathcal{C} \\mid F(x) = y\\}$ is empty. The task is to find the number of such states, $| \\{y \\in \\mathcal{C} \\mid |F^{-1}(y)|=0 \\} |$.\n\nThe problem requires a solution based on direct enumeration, not on pre-derived analytical formulas. The algorithm proceeds as follows for each given system size $N$:\n\n1.  **Initialize Preimage Counter**: Create an array, let's call it `preimage_counts`, of size $2^N$, with all entries initialized to $0$. Each index $j$ (from $0$ to $2^N-1$) of this array will correspond to a unique configuration $y \\in \\mathcal{C}$ (represented as the integer $j$) and will store the size of its preimage set, $|F^{-1}(y)|$.\n\n2.  **Iterate Through All Initial States**: Loop through all $2^N$ possible initial configurations $x \\in \\mathcal{C}$. A convenient way to do this is to iterate an integer $i$ from $0$ to $2^N-1$ and use its $N$-bit binary representation as the configuration $x$.\n\n3.  **Compute the Successor State**: For each configuration $x$, compute its successor state $y = F(x)$. This involves applying the Rule $4$ logic to each cell $x_i$ and its neighbors, respecting the periodic boundary conditions.\n    Using vectorized operations, this step is efficient. Given an array `x` representing the configuration:\n    - The array of left neighbors is `np.roll(x, 1)`.\n    - The array of right neighbors is `np.roll(x, -1)`.\n    - The successor configuration `y` is computed by checking where the neighborhood condition $(0,1,0)$ is met simultaneously for all cells.\n\n4.  **Update Preimage Count**: Convert the resulting configuration $y$ (an array of $0$s and $1$s) back into its unique integer representation, say $j$. Increment the counter at that index: `preimage_counts[j]++`.\n\n5.  **Count Garden of Eden States**: After iterating through all $2^N$ initial states $x$, the `preimage_counts` array is fully populated. The number of Garden of Eden states is the number of entries in this array that remain $0$.\n\nThis procedure is repeated for each value of $N$ in the test suite $\\{1, 2, 3, 4, 5, 6, 8\\}$, and the resulting counts are collected into a list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_goe_count(N):\n    \"\"\"\n    Calculates the number of Garden of Eden states for a given system size N\n    under Wolfram's Rule 4 with periodic boundary conditions.\n\n    The calculation is done by explicit enumeration as required by the problem.\n    \"\"\"\n    num_total_configs = 1  N  # This is 2**N\n\n    # Array to store the number of preimages for each of the 2^N possible configurations.\n    # The index of the array corresponds to the integer representation of a configuration.\n    preimage_counts = np.zeros(num_total_configs, dtype=np.int64)\n\n    # Iterate through all 2^N possible initial configurations 'x'.\n    # Each integer 'i' from 0 to 2^N-1 corresponds to a unique configuration.\n    for i in range(num_total_configs):\n        # 1. Convert the integer 'i' to its N-bit binary representation (configuration x).\n        # The representation is created as a NumPy array of integers.\n        x = np.array([int(bit) for bit in np.binary_repr(i, width=N)])\n\n        # 2. Compute the next state 'y = F(x)' under Rule 4.\n        # This is done efficiently using NumPy's vectorized operations.\n        # np.roll provides periodic boundary conditions.\n        left_neighbors = np.roll(x, 1)\n        center_cells = x\n        right_neighbors = np.roll(x, -1)\n\n        # Rule 4: the output is 1 if and only if the neighborhood is (0, 1, 0).\n        y = ((left_neighbors == 0)  (center_cells == 1)  (right_neighbors == 0)).astype(np.int8)\n\n        # 3. Convert the resulting configuration 'y' to its integer representation.\n        # This is done by treating the binary array as a base-2 number.\n        y_int = 0\n        for bit in y:\n            y_int = (y_int  1) | bit\n\n        # 4. Increment the preimage count for the computed configuration 'y'.\n        preimage_counts[y_int] += 1\n\n    # 5. The number of Garden of Eden states is the count of configurations 'y'\n    #    that have zero preimages.\n    goe_count = np.sum(preimage_counts == 0)\n    \n    return goe_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 5, 6, 8]\n\n    results = []\n    for N in test_cases:\n        # Calculate the number of GoE states for each system size N.\n        result = calculate_goe_count(N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While brute-force enumeration can demonstrate non-surjectivity for small systems, a deeper understanding requires more abstract analytical tools. This practice  introduces the De Bruijn graph as a powerful representation of a cellular automaton's dynamics, allowing for formal proofs of properties like surjectivity and injectivity. By applying these graph-theoretic tests to the linear Rule 90, you will gain insight into the formal classification of CA behavior and its connections to symbolic dynamics.",
            "id": "4151338",
            "problem": "Let $f:\\{0,1\\}^{3}\\to\\{0,1\\}$ be the local rule of a one-dimensional Elementary Cellular Automaton (ECA) with radius $1$ on the bi-infinite configuration space $\\{0,1\\}^{\\mathbb{Z}}$. The associated global map $F:\\{0,1\\}^{\\mathbb{Z}}\\to\\{0,1\\}^{\\mathbb{Z}}$ is defined by $(F(x))_{i}=f(x_{i-1},x_{i},x_{i+1})$ for all $i\\in\\mathbb{Z}$. The De Bruijn graph of order $2$ for this ECA is the directed graph with vertex set $\\{0,1\\}^{2}$ and an edge from $(a,b)$ to $(b,c)$ labeled by $\\lambda(a,b,c)=f(a,b,c)$ for each $(a,b,c)\\in\\{0,1\\}^{3}$. A bi-infinite path in this labeled graph induces a bi-infinite label sequence in $\\{0,1\\}^{\\mathbb{Z}}$, and every bi-infinite configuration $x\\in\\{0,1\\}^{\\mathbb{Z}}$ induces a bi-infinite vertex sequence $(x_{i},x_{i+1})_{i\\in\\mathbb{Z}}$ and an edge-label sequence $(f(x_{i-1},x_{i},x_{i+1}))_{i\\in\\mathbb{Z}}$.\n\nStarting from these core definitions, perform the following derivations grounded in symbolic dynamics and graph presentations of sofic shifts:\n\n- Derive a graph-theoretic test for surjectivity of $F$ onto $\\{0,1\\}^{\\mathbb{Z}}$ in terms of the labeled De Bruijn graph. Your test must be stated and justified using only the foundational definitions above and established properties of labeled graph presentations of shift spaces.\n\n- Derive a graph-theoretic test for injectivity of $F$ in terms of the existence or non-existence of multiple distinct bi-infinite paths that produce the same bi-infinite label sequence in the labeled De Bruijn graph. Again, justify the test directly from the definitions and properties of the labeled presentation.\n\n- Apply your tests to the ECA rule $90$, which has local rule $f(a,b,c)=a\\oplus c$ where $\\oplus$ denotes addition modulo $2$. Prove that $F$ is surjective but not injective on $\\{0,1\\}^{\\mathbb{Z}}$.\n\n- Finally, treat rule $90$ as a linear cellular automaton over the field with two elements $\\mathbb{F}_{2}$ and compute the dimension $\\dim_{\\mathbb{F}_{2}}(\\ker(F))$ of the kernel of $F$ as a linear map on $\\mathbb{F}_{2}^{\\mathbb{Z}}$.\n\nYour final reported quantity must be the single integer value of $\\dim_{\\mathbb{F}_{2}}(\\ker(F))$. No rounding is required and no units apply. Express the final answer as a single number.",
            "solution": "The problem as stated is a well-defined mathematical exercise in the fields of symbolic dynamics, cellular automata, and linear algebra over finite fields. All terms are formally defined, the requested derivations are standard in the literature, and the problem is self-contained and logically consistent. There are no scientific or factual unsoundness, no ambiguity, and the problem is verifiable. Therefore, the problem is valid and a solution will be provided.\n\nThe solution is structured in four parts as requested: derivation of a surjectivity test, derivation of an injectivity test, application of these tests to Elementary Cellular Automaton (ECA) rule $90$, and computation of the dimension of the kernel for rule $90$ viewed as a linear map.\n\n### Part 1: Graph-Theoretic Test for Surjectivity\n\nThe global map $F:\\{0,1\\}^{\\mathbb{Z}}\\to\\{0,1\\}^{\\mathbb{Z}}$ is surjective if, for every bi-infinite sequence of labels $y \\in \\{0,1\\}^{\\mathbb{Z}}$, there exists at least one bi-infinite configuration $x \\in \\{0,1\\}^{\\mathbb{Z}}$ such that $F(x) = y$.\n\nIn the framework of the labeled De Bruijn graph, a configuration $x$ corresponds to a bi-infinite path through the graph's vertices, specifically the path of vertices $(v_i)_{i \\in \\mathbb{Z}} = ((x_i, x_{i+1}))_{i \\in \\mathbb{Z}}$. The output configuration $y=F(x)$ is the sequence of labels on the edges that form this path, where $y_i = (F(x))_i = f(x_{i-1}, x_i, x_{i+1})$ is the label of the edge from vertex $(x_{i-1}, x_i)$ to vertex $(x_i, x_{i+1})$.\n\nThe set of all possible bi-infinite label sequences that can be generated by paths in the labeled De Bruijn graph is known as a sofic shift. The map $F$ is surjective if and only if this sofic shift is the \"full shift\" $\\{0,1\\}^{\\mathbb{Z}}$, meaning any arbitrary sequence of labels from $\\{0,1\\}^{\\mathbb{Z}}$ can be produced.\n\nFor an arbitrary label sequence $y=(y_i)_{i\\in\\mathbb{Z}}$ to be producible, we must be able to construct a corresponding vertex path $(v_i)_{i\\in\\mathbb{Z}}$. This means that for any given state (vertex) $v_i$ in the path construction and any desired next label $y_{i+1}$, there must exist a next vertex $v_{i+1}$ reachable from $v_i$ via an edge carrying the label $y_{i+1}$. If this condition holds for all vertices and all possible labels, we can extend any finite path that generates a finite label string to a bi-infinite path that generates a bi-infinite label sequence.\n\nTherefore, the graph-theoretic test for surjectivity is as follows:\n**Test for Surjectivity:** The global map $F$ is surjective if and only if, from every vertex $v$ in the labeled De Bruijn graph, there is at least one outgoing edge for each possible label in $\\{0,1\\}$.\n\n### Part 2: Graph-Theoretic Test for Injectivity\n\nThe global map $F$ is injective if for any two distinct configurations $x, x' \\in \\{0,1\\}^{\\mathbb{Z}}$ (i.e., $x \\neq x'$), their images are also distinct, $F(x) \\neq F(x')$. Equivalently, $F$ is not injective if there exist $x \\neq x'$ such that $F(x) = F(x')$.\n\nIn the graph representation, $x \\neq x'$ means their corresponding bi-infinite vertex paths, $(v_i)_{i\\in\\mathbb{Z}}$ and $(v'_i)_{i\\in\\mathbb{Z}}$, are distinct. $F(x) = F(x')$ means that these two distinct vertex paths produce the exact same bi-infinite sequence of edge labels.\n\nThe existence of such a pair of distinct paths generating the same label sequence is the defining characteristic of non-injectivity in this context. Such a situation arises if and only if the graph contains what is known as a \"diamond\": a pair of distinct paths that share a common starting vertex and a common ending vertex, and have the same sequence of edge labels along the paths. If such a finite diamond structure exists, one can construct two distinct bi-infinite configurations with the same image by embedding the diamond into a surrounding, mutually agreed-upon path.\n\nTherefore, the graph-theoretic test for injectivity is as follows:\n**Test for Injectivity:** The global map $F$ is injective if and only if the labeled De Bruijn graph contains no \"diamonds\". A diamond is a pair of distinct finite paths, $\\pi_1$ and $\\pi_2$, that start at the same vertex $u$ and end at the same vertex $v$, and for which the sequence of edge labels along $\\pi_1$ is identical to the sequence of edge labels along $\\pi_2$. The absence of such structures for any pair of vertices $u,v$ and any path length guarantees that any given label sequence can be generated by at most one path, ensuring injectivity.\n\n### Part 3: Application to Rule 90\n\nThe ECA rule $90$ is defined by the local rule $f(a,b,c) = a \\oplus c$, where $\\oplus$ is addition modulo $2$. The vertex set of the De Bruijn graph is $\\{ (0,0), (0,1), (1,0), (1,1) \\}$. The edges are of the form $(a,b)\\to(b,c)$ with label $a \\oplus c$. The $8$ possible transitions and their labels are:\n\\begin{itemize}\n    \\item $f(0,0,0) = 0 \\oplus 0 = 0$: edge $(0,0) \\to (0,0)$ with label $0$.\n    \\item $f(0,0,1) = 0 \\oplus 1 = 1$: edge $(0,0) \\to (0,1)$ with label $1$.\n    \\item $f(0,1,0) = 0 \\oplus 0 = 0$: edge $(0,1) \\to (1,0)$ with label $0$.\n    \\item $f(0,1,1) = 0 \\oplus 1 = 1$: edge $(0,1) \\to (1,1)$ with label $1$.\n    \\item $f(1,0,0) = 1 \\oplus 0 = 1$: edge $(1,0) \\to (0,0)$ with label $1$.\n    \\item $f(1,0,1) = 1 \\oplus 1 = 0$: edge $(1,0) \\to (0,1)$ with label $0$.\n    \\item $f(1,1,0) = 1 \\oplus 0 = 1$: edge $(1,1) \\to (1,0)$ with label $1$.\n    \\item $f(1,1,1) = 1 \\oplus 1 = 0$: edge $(1,1) \\to (1,1)$ with label $0$.\n\\end{itemize}\n\n**Surjectivity of Rule 90:**\nWe apply the surjectivity test. We check the outgoing labels from each vertex:\n\\begin{itemize}\n    \\item From vertex $(0,0)$: outgoing labels are $\\{0, 1\\}$.\n    \\item From vertex $(0,1)$: outgoing labels are $\\{0, 1\\}$.\n    \\item From vertex $(1,0)$: outgoing labels are $\\{0, 1\\}$.\n    \\item From vertex $(1,1)$: outgoing labels are $\\{0, 1\\}$.\n\\end{itemize}\nSince every vertex has outgoing edges for both possible labels $0$ and $1$, the surjectivity condition is met. Thus, **$F$ is surjective for rule $90$**.\n\n**Injectivity of Rule 90:**\nWe apply the injectivity test by searching for distinct configurations that map to the same output.\nConsider the configuration $x = (\\dots, 0, 0, 0, \\dots)$, the all-zero configuration. For any site $i$, the neighborhood is $(0,0,0)$. The output is $(F(x))_i = f(0,0,0) = 0 \\oplus 0 = 0$. So, $F(x)$ is the all-zero configuration.\n\nNow consider the configuration $x' = (\\dots, 1, 0, 1, 0, 1, 0, \\dots)$, the alternating or \"checkerboard\" configuration.\n\\begin{itemize}\n    \\item At a site $i$ where $x'_i = 0$, the neighborhood is $(x'_{i-1}, x'_i, x'_{i+1}) = (1,0,1)$. The output is $(F(x'))_i = f(1,0,1) = 1 \\oplus 1 = 0$.\n    \\item At a site $i$ where $x'_i = 1$, the neighborhood is $(x'_{i-1}, x'_i, x'_{i+1}) = (0,1,0)$. The output is $(F(x'))_i = f(0,1,0) = 0 \\oplus 0 = 0$.\n\\end{itemize}\nIn both cases, the output is $0$. Therefore, $F(x')$ is also the all-zero configuration.\nWe have found two distinct configurations, $x \\neq x'$, such that $F(x) = F(x') = (\\dots, 0, 0, 0, \\dots)$.\nIn the graph representation, this corresponds to two distinct bi-infinite paths producing the all-zero label sequence:\n1.  The path for $x$: the self-loop at vertex $(0,0)$. The edge is $(0,0) \\to (0,0)$ with label $0$.\n2.  The path for $x'$: the 2-cycle between vertices $(0,1)$ and $(1,0)$. The edge $(0,1) \\to (1,0)$ has label $0$, and the edge $(1,0) \\to (0,1)$ also has label $0$.\nThese two distinct paths/cycles both generate the sequence $(\\dots, 0, 0, 0, \\dots)$, which constitutes a form of a diamond structure.\nThus, **$F$ is not injective for rule $90$**.\n\n### Part 4: Dimension of the Kernel for Rule 90\n\nWe treat the ECA as a linear map $F$ on the vector space $\\mathbb{F}_{2}^{\\mathbb{Z}}$ over the field $\\mathbb{F}_{2}$. The global map is given by $(F(x))_i = x_{i-1} + x_{i+1}$, where arithmetic is modulo $2$. The kernel of $F$, denoted $\\ker(F)$, is the set of all configurations $x \\in \\mathbb{F}_{2}^{\\mathbb{Z}}$ such that $F(x) = \\mathbf{0}$, where $\\mathbf{0}$ is the all-zero configuration.\n\nThe condition for $x \\in \\ker(F)$ is $(F(x))_i = 0$ for all $i \\in \\mathbb{Z}$.\n$$x_{i-1} + x_{i+1} = 0 \\pmod 2$$\nThis is equivalent to the linear recurrence relation:\n$$x_{i+1} = x_{i-1} \\quad \\text{for all } i \\in \\mathbb{Z}$$\nThis relation implies $x_{i+2} = x_i$ for all $i$. This means that any sequence in the kernel must be periodic with period $2$.\n\nA bi-infinite sequence $x$ that is periodic with period $2$ is completely determined by the values of any two adjacent elements, for instance, $x_0$ and $x_1$. Let $x_0 = c_0$ and $x_1 = c_1$, where $c_0, c_1 \\in \\mathbb{F}_2$. Then the entire sequence is of the form:\n$$x = (\\dots, c_1, c_0, c_1, c_0, c_1, \\dots)$$\nThe set of all such sequences, $\\ker(F)$, forms a vector subspace of $\\mathbb{F}_{2}^{\\mathbb{Z}}$. We can define a vector space isomorphism $\\phi: \\ker(F) \\to \\mathbb{F}_{2}^{2}$ by mapping a sequence $x$ to the pair of values that defines it: $\\phi(x) = (x_0, x_1)$.\nSince $\\ker(F)$ is isomorphic to the vector space $\\mathbb{F}_{2}^{2}$, their dimensions must be equal. The dimension of $\\mathbb{F}_{2}^{2}$ over $\\mathbb{F}_{2}$ is $2$.\n\nAlternatively, we can identify a basis for $\\ker(F)$. Let $b_0$ be the sequence defined by $(x_0, x_1) = (1,0)$. This is the sequence $(\\dots, 0, 1, 0, 1, 0, \\dots)$, with $x_0=1$. Let $b_1$ be the sequence defined by $(x_0, x_1) = (0,1)$. This is the sequence $(\\dots, 1, 0, 1, 0, 1, \\dots)$, with $x_1=1$. The vectors $b_0$ and $b_1$ are linearly independent. Any sequence $x \\in \\ker(F)$ with $(x_0, x_1) = (c_0, c_1)$ can be written as a unique linear combination $x = c_0 b_0 + c_1 b_1$. Therefore, $\\{b_0, b_1\\}$ is a basis for $\\ker(F)$, and its dimension is the number of basis vectors.\n\nThe dimension of the kernel is $2$. The kernel contains $2^2=4$ elements: the all-zero sequence $(c_0=0, c_1=0)$, the all-one sequence $(c_0=1, c_1=1)$, and the two alternating sequences.\n\nTherefore, the dimension of the kernel of $F$ is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "The vast space of cellular automata rules is not an unstructured collection; intricate relationships and hierarchies exist, where the dynamics of one rule can simulate another. This advanced practice  challenges you to build an algorithm that systematically searches for these \"emulation\" relationships, mediated by transformations known as sliding block codes. By mapping the emulation graph for a set of key rules, you will develop a practical understanding of how complex behaviors can be embedded within one another, a core concept in complex systems and the theory of computation.",
            "id": "4151324",
            "problem": "You are to design and implement a complete program that, from first principles, constructs and applies an algorithm to detect emulation relationships between Elementary Cellular Automata (ECA) rules using symbolic dynamics (sliding block codes). The goal is to map the emulation graph over the rule set $\\{30,45,73,110\\}$ under the criterion that a rule $R$ emulates a rule $S$ if there exists a non-degenerate sliding block code $\\varphi$ such that the following commutation condition holds:\n$$\n\\varphi \\circ F_R = F_S \\circ \\varphi,\n$$\nfor all configurations on finite periodic rings of specified sizes. Here $F_R$ and $F_S$ are the global maps of ECA rules $R$ and $S$, respectively.\n\nFundamental base definitions and constraints:\n- An Elementary Cellular Automaton (ECA) is a one-dimensional, binary-state ($\\{0,1\\}$) cellular automaton with nearest-neighbor coupling and synchronous update. The global evolution map $F_R$ for a rule $R$ is defined by a local function $f_R:\\{0,1\\}^{3}\\to\\{0,1\\}$ of radius $1$ (depending on the left neighbor, the cell itself, and the right neighbor), applied uniformly across all sites with periodic boundary conditions. The Wolfram code for $R$ encodes $f_R$’s outputs for the neighborhoods in the order $\\{111,110,101,100,011,010,001,000\\}$.\n- A sliding block code (symbolic dynamics factor map) $\\varphi$ with window size $m=3$ is defined by a local function $h:\\{0,1\\}^{3}\\to\\{0,1\\}$ applied at each site, using the left neighbor, the site itself, and the right neighbor from the input configuration; thus $\\varphi$ is shift-commuting and translation-invariant.\n- Emulation criterion: A rule $R$ emulates a rule $S$ via $\\varphi$ if $\\varphi \\circ F_R(x) = F_S \\circ \\varphi(x)$ for all configurations $x$ in the configuration space on a finite ring. The search is restricted to sliding block codes of window size $m=3$ that are non-degenerate, meaning $h$ is surjective onto $\\{0,1\\}$ (it must produce both $0$ and $1$ on some neighborhood), thereby excluding constant maps. To avoid trivial identity cases, do not include edges where $R=S$ in the emulation graph output.\n- Validation scope: Because checking all bi-infinite configurations is not computationally feasible, your algorithm must verify the commutation condition for all configurations on two distinct periodic ring sizes, specifically $N=8$ and $N=10$. For each $N$, periodic boundary conditions must be used. Time validation is by one-step commutation ($t=1$), and this is sufficient because if $\\varphi \\circ F_R = F_S \\circ \\varphi$ holds for all $x$, then by induction it holds for all iterates.\n\nAlgorithmic requirements:\n1. Construct the global maps $F_R$ and $F_S$ from their Wolfram codes using only the definition of ECA local rules as functions $f_R:\\{0,1\\}^{3}\\to\\{0,1\\}$ and periodic boundary conditions on rings of size $N$.\n2. Enumerate all sliding block codes $\\varphi$ with window size $m=3$. There are $2^{2^3}=256$ candidate $h:\\{0,1\\}^{3}\\to\\{0,1\\}$ functions. Exclude degenerate $h$ that are constant ($0$ or $1$ everywhere). Each candidate $\\varphi$ must be tested for emulation.\n3. For each ordered pair $(R,S)$ in the set $\\{30,45,73,110\\}\\times\\{30,45,73,110\\}$ with $R\\neq S$, test if there exists at least one non-degenerate $\\varphi$ such that the commutation condition $\\varphi \\circ F_R = F_S \\circ \\varphi$ holds for all configurations on rings of sizes $N=8$ and $N=10$ (two sizes are required to reduce spurious finite-size coincidences).\n4. Construct the emulation graph as a directed edge set, where there is a directed edge $R\\to S$ if such a $\\varphi$ exists.\n\nTest suite specification:\n- Rule set: $\\{30,45,73,110\\}$.\n- Ordered pairs: all $16$ ordered pairs $(R,S)$ from the rule set; your algorithm must exclude self-pairs $(R,S)$ where $R=S$ when producing the final emulation graph output.\n- Ring sizes: $N=8$ and $N=10$; periodic boundary conditions must be used.\n- Sliding block code window size: $m=3$.\n- Verification time: one-step commutation ($t=1$) only.\n\nAnswer specification:\n- For each ordered pair $(R,S)$, the program must determine a boolean indicating whether an emulation exists; however, the final output must aggregate the successful emulations into a single directed edge list.\n- Final output format: Your program should produce a single line of output containing the directed edges as a comma-separated list of pairs enclosed in square brackets. For example, an empty graph is printed as `[]`, a graph with two edges $30\\to45$ and $45\\to73$ is printed as `[[30,45],[45,73]]`. No spaces are permitted in the output string.\n\nNo physical units or angles are involved; all outputs are unitless integers and lists. The program must be entirely self-contained, accept no input, and use only the specified libraries in the final answer section.",
            "solution": "The problem is valid. It is a well-defined computational task rooted in the mathematical theory of cellular automata and symbolic dynamics. All definitions are precise, constraints are clearly stated, and the scope of the search is finite and computationally tractable. The problem is scientifically sound, objective, and self-contained.\n\nThe objective is to determine the emulation graph for a set of Elementary Cellular Automata (ECA) rules $R,S \\in \\{30, 45, 73, 110\\}$. An emulation from rule $R$ to rule $S$ exists if there is a non-degenerate sliding block code $\\varphi$ of window size $m=3$ that makes the following diagram commute for all configurations $x$ on finite rings of sizes $N=8$ and $N=10$:\n$$\n\\varphi \\circ F_R(x) = F_S \\circ \\varphi(x)\n$$\nHere, $F_R$ and $F_S$ are the global evolution operators for the respective ECA rules. The procedural steps to find this graph are outlined below.\n\n**1. Representation of Automata and Configurations**\n\nA configuration on a ring of size $N$ is a binary vector $x \\in \\{0,1\\}^N$, which can be represented by a one-dimensional NumPy array of integers.\n\nAn ECA rule, specified by its Wolfram code $R$ (an integer from $0$ to $255$), is fundamentally a local function $f_R:\\{0,1\\}^3 \\to \\{0,1\\}$. The problem defines the encoding such that the binary representation of $R$, denoted $b_7b_6...b_0$, corresponds to the outputs for neighborhoods $\\{111, 110, ..., 000\\}$. This is the standard convention where the integer value of a neighborhood triplet $(c_{i-1}, c_i, c_{i+1})$, taken as $k = 4c_{i-1} + 2c_i + c_{i+1}$, maps to an output given by the $k$-th bit of $R$. This allows us to create an $8$-element lookup table for any rule $R$, where `lut[k] = (R  k)  1`.\n\nA sliding block code $\\varphi$ with window size $m=3$ is defined by a similar local function $h:\\{0,1\\}^3 \\to \\{0,1\\}$. There are $2^{2^3}=256$ such functions, each representable by an integer code $H$ from $0$ to $255$ in the same manner as an ECA rule. The problem requires a non-degenerate code, meaning $h$ must be surjective. This excludes the constant maps where all outputs are $0$ (code $H=0$) or all outputs are $1$ (code $H=255$). Thus, our search space for block codes comprises integers $H \\in \\{1, \\dots, 254\\}$.\n\n**2. Implementation of Global Maps**\n\nThe global map $F_R$ updates a configuration $x$ to a new configuration $x'$ where each site $x'_i$ is computed as $x'_i = f_R(x_{i-1}, x_i, x_{i+1})$. The periodic boundary conditions imply that indices are evaluated modulo $N$. This operation can be efficiently vectorized. Given a batch of configurations (a $K \\times N$ matrix), we can generate the arrays for the left-shifted, center, and right-shifted sites for all configurations simultaneously using `numpy.roll` with `axis=1`.\n*   Let `configs` be the input matrix of configurations.\n*   `left = np.roll(configs, 1, axis=1)`\n*   `center = configs`\n*   `right = np.roll(configs, -1, axis=1)`\nThe neighborhood indices for every site in every configuration are then computed as `indices = 4 * left + 2 * center + 1 * right`. The output configurations are obtained by indexing the rule's lookup table with this `indices` matrix. The same function can be used to apply a sliding block code $\\varphi_H$ by simply using the lookup table derived from the integer code $H$.\n\n**3. Verification across Configuration Spaces**\n\nThe commutation condition must hold for all possible configurations. For a finite ring of size $N$, there are $2^N$ such configurations. The algorithm must verify the condition for all $2^8 = 256$ configurations for $N=8$ and all $2^{10} = 1024$ configurations for $N=10$. We can generate these configuration spaces by iterating an integer from $0$ to $2^N-1$ and taking its $N$-bit binary representation for each configuration.\n\n**4. The Search Algorithm**\n\nThe core of the solution is a systematic search over all valid parameters. The algorithm follows a nested loop structure:\n1.  Iterate through all ordered pairs $(R,S)$ from the set $\\{30, 45, 73, 110\\} \\times \\{30, 45, 73, 110\\}$, excluding pairs where $R=S$.\n2.  For each pair $(R,S)$, assume no emulation exists initially.\n3.  Iterate through all possible non-degenerate sliding block codes, i.e., for $H$ from $1$ to $254$.\n4.  For each candidate code $H$, test the commutation condition. This involves another loop over the specified ring sizes $N \\in \\{8, 10\\}$.\n5.  For a given $N$, compute the outcome for all $2^N$ configurations:\n    *   Let $X_N$ be the set of all $2^N$ configurations of size $N$.\n    *   Compute the left-hand side of the equation for all configurations: $LHS = \\varphi_H(F_R(X_N))$. This is done in two vectorized steps: first apply $F_R$ to $X_N$, then apply $\\varphi_H$ to the result.\n    *   Compute the right-hand side: $RHS = F_S(\\varphi_H(X_N))$.\n    *   If $LHS$ and $RHS$ are not identical, the code $H$ fails the test for this $N$. We break the loop over $N$ and proceed to the next code $H$.\n6.  If the code $H$ passes the test for both $N=8$ and $N=10$, an emulation $R \\to S$ has been found. We record the pair $(R,S)$ as a directed edge in the emulation graph and break the loop over $H$, as the existence of at least one such code is sufficient.\n7.  After iterating through all pairs $(R,S)$, the collected list of edges constitutes the desired emulation graph.\n\nThis comprehensive search guarantees finding all emulations that satisfy the problem's strict criteria. The final output is formatted as a string representation of the list of directed edges.",
            "answer": "```python\nimport numpy as np\n\ndef apply_map_batch(configs, map_code):\n    \"\"\"\n    Applies a local map (ECA rule or sliding block code) to a batch of configurations.\n\n    Args:\n        configs (np.ndarray): A (num_configs, N) array of configurations.\n        map_code (int): The integer code (0-255) for the map.\n\n    Returns:\n        np.ndarray: The array of resulting configurations.\n    \"\"\"\n    if configs.ndim == 1:\n        configs = configs[np.newaxis, :]\n    \n    N = configs.shape[1]\n    \n    # Get neighbors using periodic boundary conditions\n    left = np.roll(configs, 1, axis=1)\n    center = configs\n    right = np.roll(configs, -1, axis=1)\n    \n    # Convert neighborhoods to integer indices (0-7)\n    indices = 4 * left + 2 * center + 1 * right\n    \n    # Create an 8-element lookup table from the map code\n    lut = np.array([(map_code  i)  1 for i in range(8)], dtype=np.uint8)\n\n    # Apply the map using advanced indexing\n    return lut[indices]\n\ndef generate_configs(N):\n    \"\"\"\n    Generates all 2^N possible configurations for a ring of size N.\n\n    Args:\n        N (int): The size of the ring.\n\n    Returns:\n        np.ndarray: A (2^N, N) array containing all configurations.\n    \"\"\"\n    num_configs = 1  N\n    # Use broadcasting to create all binary strings efficiently\n    powers_of_2 = 1  np.arange(N - 1, -1, -1)\n    indices_matrix = np.arange(num_configs)[:, np.newaxis]\n    configs = (indices_matrix // powers_of_2) % 2\n    return configs.astype(np.uint8)\n\ndef solve():\n    \"\"\"\n    Main function to find and report ECA emulation relationships.\n    \"\"\"\n    rules = [30, 45, 73, 110]\n    ring_sizes = [8, 10]\n    emulation_edges = []\n\n    # Pre-generate all configurations for the specified ring sizes\n    all_configs = {N: generate_configs(N) for N in ring_sizes}\n\n    # Non-degenerate sliding block codes are represented by integers 1 to 254\n    map_codes = range(1, 255)\n\n    for R in rules:\n        for S in rules:\n            if R == S:\n                continue\n\n            emulation_found_for_pair = False\n            for H in map_codes:\n                commutes_for_H = True\n                for N in ring_sizes:\n                    configs = all_configs[N]\n\n                    # Left-hand side: phi(F_R(x))\n                    F_R_x = apply_map_batch(configs, R)\n                    phi_F_R_x = apply_map_batch(F_R_x, H)\n                    \n                    # Right-hand side: F_S(phi(x))\n                    phi_x = apply_map_batch(configs, H)\n                    F_S_phi_x = apply_map_batch(phi_x, S)\n\n                    # Check if the commutation holds for all configurations at this N\n                    if not np.array_equal(phi_F_R_x, F_S_phi_x):\n                        commutes_for_H = False\n                        break  # This H fails, try the next one\n                \n                if commutes_for_H:\n                    # An emulation map H was found that works for all specified N\n                    emulation_found_for_pair = True\n                    break  # Found a map for this (R,S) pair, move to the next pair\n            \n            if emulation_found_for_pair:\n                emulation_edges.append([R, S])\n    \n    # Format the final output string exactly as specified, with no spaces.\n    final_output = str(emulation_edges).replace(' ', '')\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}