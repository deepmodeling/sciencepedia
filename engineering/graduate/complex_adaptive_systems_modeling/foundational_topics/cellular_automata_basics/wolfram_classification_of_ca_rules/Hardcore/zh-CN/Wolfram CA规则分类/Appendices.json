{
    "hands_on_practices": [
        {
            "introduction": "要想真正理解元胞自动机，必须亲眼观察它们的运行。第一个实践练习将挑战你从零开始实现规则30的模拟，这是一个从简单初始状态生成复杂混沌行为而闻名遐迩的系统 ()。通过追踪局部邻域多样性随时间的变化，你将获得有关元胞自动机演化核心机制的动手经验，并亲眼见证“涌现”这一核心原则。",
            "id": "4151322",
            "problem": "您的任务是推导并实现一个遵循 Wolfram 规则分类的初级元胞自动机 (ECA) 的完整模拟，并特别关注规则 $30$。目标是计算在一个长度为 $L$、具有周期性边界条件的一维环上，从单个活动元胞开始，经过 $T$ 个离散时间步长的时空演化，然后严谨地总结每个时间步长中不同邻域频率的增长情况。\n\n假设推导和实现基于以下基本原理：\n\n- 初级元胞自动机 (ECA) 是一个在二元状态空间 $\\{0,1\\}^L$ 上的离散时间动力系统，其局部更新函数为 $f : \\{0,1\\}^3 \\to \\{0,1\\}$。全局更新在空间上是平移不变的，并同步应用于所有位点。\n- 在时间步长 $t$ 的构型表示为 $\\mathbf{x}^{(t)} = (x^{(t)}_0, x^{(t)}_1, \\ldots, x^{(t)}_{L-1}) \\in \\{0,1\\}^L$，具有周期性边界条件 $x^{(t)}_{i} = x^{(t)}_{i \\bmod L}$。\n- 在位点 $i$ 和时间 $t$ 的局部邻域是三元组 $\\left(x^{(t)}_{i-1}, x^{(t)}_{i}, x^{(t)}_{i+1}\\right)$，其中索引在模 $L$ 意义下解释。\n\n初级元胞自动机规则 $30$ 的局部规则定义如下。设规则编号为 $R=30$。将每个邻域三元组 $\\left(a,b,c\\right) \\in \\{0,1\\}^3$ 与其代码 $n = 4a + 2b + c \\in \\{0,\\ldots,7\\}$ 相关联。规则 $R$ 在邻域代码 $n$ 上的输出是 $R$ 的 $8$ 位二进制展开的第 $n$ 位，其中最低有效位对应邻域代码 $n=0$（即 $\\left(0,0,0\\right)$），最高有效位对应邻域代码 $n=7$（即 $\\left(1,1,1\\right)$）。具体来说，对于 $R=30$，二进制模式为 $00011110$，因此\n$$\nf(1,1,1)=0,\\; f(1,1,0)=0,\\; f(1,0,1)=0,\\; f(1,0,0)=1,\\; f(0,1,1)=1,\\; f(0,1,0)=1,\\; f(0,0,1)=1,\\; f(0,0,0)=0.\n$$\n\n初始条件：在时间 $t=0$ 时，构型 $\\mathbf{x}^{(0)}$ 在索引 $i_0 = \\lfloor L/2 \\rfloor$ 处有一个单一的活动元胞，即 $x^{(0)}_{i_0} = 1$，对于所有 $i \\neq i_0$，$x^{(0)}_{i} = 0$。\n\n对于每个时间步长 $t \\in \\{0,1,\\ldots,T\\}$，定义邻域代码场\n$$\nn^{(t)}_i = 4 x^{(t)}_{i-1} + 2 x^{(t)}_{i} + x^{(t)}_{i+1},\n$$\n并定义频率向量 $\\mathbf{F}^{(t)} \\in \\mathbb{N}^8$，其第 $k$ 个分量 $F^{(t)}_k$ 是索引 $i \\in \\{0,\\ldots,L-1\\}$ 的计数，使得 $n^{(t)}_i = k$。定义在时间 $t$ 的不同邻域计数为\n$$\nD^{(t)} = \\left|\\left\\{k \\in \\{0,\\ldots,7\\} \\,\\middle|\\, F^{(t)}_k > 0 \\right\\}\\right|.\n$$\n运行的增长摘要是整数列表 $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$。\n\n您的任务是实现一个程序，对于每个测试用例 $(L,T)$，根据指定的初始条件计算规则 $30$ 下的演化，并返回增长摘要列表 $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$。\n\n设计约束：\n\n- 所有计算必须使用上述定义和周期性边界条件，在纯数学术语下进行。此问题不涉及任何物理单位。\n- 您的实现必须是确定性的和平移不变的，在每个时间步长将局部更新函数 $f$ 同步应用于所有位点。\n\n测试套件：\n\n使用以下参数值在典型和边缘情况下验证算法：\n\n1. 一般情况：$L=51$, $T=25$。\n2. 最小环尺寸：$L=1$, $T=10$。\n3. 小型偶数环：$L=2$, $T=10$。\n4. 小型奇数环：$L=3$, $T=12$。\n5. 较大型偶数环：$L=64$, $T=20$。\n6. 时间步长的边界条件：$L=13$, $T=0$。\n\n最终输出规范：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中第 $j$ 个元素是上述顺序中第 $j$ 个测试用例的增长摘要列表 $\\left[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}\\right]$。例如，输出行将具有\n$$\n[\\,[d_{0,0}, d_{0,1}, \\ldots, d_{0,T_0}],\\,[d_{1,0}, \\ldots, d_{1,T_1}],\\,\\ldots\\,]\n$$\n的形式，不带任何描述性文本。每个 $d_{j,t}$ 都必须是整数。",
            "solution": "问题陈述在形式上是合理的、自洽的，并且在数学上是适定的。它描述了一个初级元胞自动机 (ECA) 的确定性模拟，其中所有必要的参数、初始条件、边界条件和定义都得到了明确的规定。因此，该问题被认为是有效的，完整的解决方案推导和实现如下。\n\n问题的核心是模拟一维二元元胞自动机的时间演化，并在每个时间步长量化局部邻域的多样性。解决方案可以分解为几个逻辑步骤：表示系统状态、实现更新规则、模拟时间演化以及计算指定的度量。\n\n首先，我们将时间 $t$ 的系统状态（表示为 $\\mathbf{x}^{(t)}$）表示为一个长度为 $L$ 的一维数组。该数组的元素 $x^{(t)}_i$ 取值于 $\\{0, 1\\}$。在 $t=0$ 时的初始条件是一个全零点阵，除了在索引 $i_0 = \\lfloor L/2 \\rfloor$ 处有一个活动元胞，$x^{(0)}_{i_0} = 1$。在计算上，这是一个大小为 $L$ 并相应初始化的整数数组。\n\n其次，我们必须实现 ECA 规则 $30$ 的局部更新函数 $f$。该规则根据邻域 $\\left(x^{(t)}_{i-1}, x^{(t)}_{i}, x^{(t)}_{i+1}\\right)$ 来确定状态 $x^{(t+1)}_i$。问题定义了一个标准映射，其中每个邻域三元组 $(a,b,c)$ 被转换为一个数值代码 $n = 4a + 2b + c$。规则的输出是规则编号 $R=30$ 的二进制表示的第 $n$ 位。$30$ 的 $8$ 位二进制表示是 $00011110_2$。我们构建一个长度为 $8$ 的查找表（一个数组），将每个邻域代码 $n \\in \\{0, \\dots, 7\\}$ 映射到其输出状态 $\\{0, 1\\}$。根据问题的规范（最低有效位对应 $n=0$），规则 $30$ 的查找表是 $[0, 1, 1, 1, 1, 0, 0, 0]$。即 $f(\\text{code}=0)=0, f(\\text{code}=1)=1, \\dots, f(\\text{code}=7)=0$。\n\n第三，我们模拟系统的同步演化。要从 $\\mathbf{x}^{(t)}$ 计算构型 $\\mathbf{x}^{(t+1)}$，我们必须首先确定每个元胞 $i \\in \\{0, \\dots, L-1\\}$ 的邻域。问题指定了周期性边界条件，意味着将点阵视为一个环。在计算上，这可以通过创建状态数组 $\\mathbf{x}^{(t)}$ 的移位版本来高效处理。左邻居数组通过将 $\\mathbf{x}^{(t)}$ 向右移动一个位置获得（例如，`np.roll(x, 1)`），右邻居数组通过向左移动一个位置获得（例如，`np.roll(x, -1)`）。有了左邻居、中心元胞和右邻居的数组，我们可以使用向量化算术同时计算所有位点的邻域代码 $n^{(t)}_i = 4x^{(t)}_{i-1} + 2x^{(t)}_{i} + x^{(t)}_{i+1}$。这将为点阵上的每个位点生成一个邻域代码数组。然后，通过将规则 $30$ 的查找表应用于此代码数组，可以找到下一个状态 $\\mathbf{x}^{(t+1)}$。\n\n第四，对于从 $0$ 到 $T$ 的每个时间步长 $t$，我们必须计算不同邻域计数 $D^{(t)}$。这被定义为在该时间步长整个点阵上存在的唯一邻域代码的数量。作为演化步骤的一部分，我们已经计算了所有 $i$ 的邻域代码数组 $n^{(t)}_i$，因此我们可以找到该数组中唯一值的集合并计算其大小。这个计数就是 $D^{(t)}$。\n\n对于给定的测试用例 $(L, T)$，完整的算法如下：\n1. 初始化一个空列表 `growth_summary`，用于存储值 $[D^{(0)}, D^{(1)}, \\ldots, D^{(T)}]$。\n2. 创建长度为 $L$ 的初始状态数组 $\\mathbf{x}^{(0)}$，在索引 $\\lfloor L/2 \\rfloor$ 处有一个单一的 $1$。\n3. 将规则 $30$ 的查找表定义为 $[0, 1, 1, 1, 1, 0, 0, 0]$。\n4. 开始一个循环，遍历从 $0$ 到 $T$（含）的每个时间步长 $t$。\n5. 在循环内部，对于当前构型 $\\mathbf{x}^{(t)}$：\n    a. 使用周期性移位和向量化算术确定所有位点的邻域代码数组。\n    b. 在此数组中找到唯一代码的数量，并将此计数 $D^{(t)}$ 附加到 `growth_summary`。\n    c. 如果 $t  T$，则通过将规则 $30$ 查找表应用于邻域代码数组来计算下一个状态 $\\mathbf{x}^{(t+1)}$。\n6. 循环完成后，`growth_summary` 列表包含该测试用例所需的输出。\n对问题陈述中提供的所有测试用例重复此过程，并将最终结果按规定格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the space-time evolution of Elementary Cellular Automaton (ECA) Rule 30\n    for a set of test cases and calculates the growth summary of distinct neighborhood frequencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (51, 25),   # A general scenario\n        (1, 10),    # Minimal ring size\n        (2, 10),    # Small even ring\n        (3, 12),    # Small odd ring\n        (64, 20),   # Larger even ring\n        (13, 0),    # Boundary condition on time steps\n    ]\n\n    # The local rule for ECA rule 30 is derived from its binary representation.\n    # R=30 in binary is 00011110.\n    # The output for a neighborhood code 'n' is the n-th bit, with n=0 being the LSB.\n    # The neighborhood code n is calculated as n = 4*left + 2*center + 1*right.\n    # Index 0 corresponds to code 0 (0,0,0) -> 0\n    # Index 1 corresponds to code 1 (0,0,1) -> 1\n    # ...\n    # Index 7 corresponds to code 7 (1,1,1) -> 0\n    rule_30_map = np.array([0, 1, 1, 1, 1, 0, 0, 0], dtype=np.int8)\n\n    all_results = []\n\n    for L, T in test_cases:\n        # Step 1: Initialize the configuration and result list.\n        # The configuration 'x' is a 1D numpy array representing the lattice.\n        # Initial condition: a single active cell at the center.\n        x = np.zeros(L, dtype=np.int8)\n        if L > 0:\n            i_0 = L // 2\n            x[i_0] = 1\n        \n        growth_summary = []\n\n        # Step 2: Loop through each time step from 0 to T.\n        for t in range(T + 1):\n            if L == 0:\n                # Edge case: for a lattice of size 0, there are no neighborhoods.\n                D_t = 0\n            else:\n                # Step 3: Compute neighborhood codes for the current configuration 'x'.\n                # np.roll handles periodic boundary conditions efficiently.\n                x_left = np.roll(x, 1)\n                x_right = np.roll(x, -1)\n                \n                # Vectorized calculation of neighborhood codes for all sites.\n                neighborhood_codes = 4 * x_left + 2 * x + x_right\n\n                # Step 4: Calculate D^(t), the count of distinct neighborhood codes.\n                unique_codes = np.unique(neighborhood_codes)\n                D_t = len(unique_codes)\n            \n            growth_summary.append(D_t)\n\n            # Step 5: Update the configuration for the next time step.\n            # This is skipped on the final iteration (t=T) as x^(T+1) is not needed.\n            if t  T and L > 0:\n                x = rule_30_map[neighborhood_codes]\n        \n        all_results.append(growth_summary)\n\n    # Step 6: Format the final output according to the problem specification.\n    # The output should be a single line: [[...],[...],...]\n    inner_lists_str = [f\"[{','.join(map(str, summary))}]\" for summary in all_results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在元胞自动机的状态空间中，并非所有构型都是可达的；有些是“演化的死胡同”，没有任何可能的“前身”。本练习要求你通过在小型网络上为规则4识别这些“伊甸园”状态，来对这一概念进行计算探索 ()。通过穷举枚举，你将对非满射性及其在动力系统中对信息丢失和不可逆性的影响，获得一个具体而深刻的理解。",
            "id": "4151267",
            "problem": "给定一个一维二进制元胞自动机，属于 Stephen Wolfram 定义的基本元胞自动机 (ECA) 类型，定义在一个由 $N$ 个元胞组成的环上，具有周期性边界条件。每个元胞的状态为 $\\{0,1\\}$，全局更新映射 $F:\\{0,1\\}^N\\to\\{0,1\\}^N$ 由一个局部更新函数 $\\phi:\\{0,1\\}^3\\to\\{0,1\\}$ 导出，该函数依赖于左邻居、元胞自身和右邻居。Wolfram 的规则编号系统为每个 ECA 分配一个数字 $r\\in\\{0,\\dots,255\\}$，其二进制展开编码了 $\\phi$ 在从 $111$ 到 $000$ 的八种邻域上的输出。一个伊甸园 (Garden of Eden, GoE) 态是一个在 $F$ 下没有原像的构型 $y\\in\\{0,1\\}^N$，即不存在 $x\\in\\{0,1\\}^N$ 使得 $F(x)=y$。如果对于每个 $y\\in\\{0,1\\}^N$，都存在至少一个 $x$ 使得 $F(x)=y$，则全局映射 $F$ 是满射的。在复杂自适应系统建模中，识别非满射规则及其伊甸园态对于理解状态空间的可达性和规则引发的约束至关重要。\n\n从函数、满射性以及 ECA 的局部到全局构造的核心定义出发，通过对 Wolfram 规则 $4$ 的原像进行显式枚举，证明一个非满射规则存在伊甸园态。对于规则 $4$，局部更新函数 $\\phi$ 由 $4$ 的二进制编码 $00000100$ 定义；将最低有效位解释为邻域 $000$ 的输出，最高有效位解释为邻域 $111$ 的输出，这意味着 $\\phi(0,1,0)=1$，而在所有其他邻域上 $\\phi$ 的输出均为 $0$。\n\n你的任务是编写一个完整的、可运行的程序。对于每个给定的系统大小 $N$，该程序需要枚举所有 $2^N$ 个构型 $x\\in\\{0,1\\}^N$，在环（周期性边界条件）上根据规则 $4$ 计算 $y=F(x)$，累加每个 $y\\in\\{0,1\\}^N$ 的原像数量，并最终计算有多少个 $y$ 的原像数量为零（即为伊甸园态）。你不能假定任何预先推导出的原像计数公式；枚举必须直接遵循定义。\n\n测试套件：\n- 使用以下系统大小 $N$：$1$、$2$、$3$、$4$、$5$、$6$、$8$。\n\n答案规格：\n- 对于测试套件中的每个 $N$，计算在该 $N$ 和规则 $4$ 下伊甸园态的数量，结果为一个整数。\n- 将所有测试用例的结果汇总成一个整数列表。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。\n\n不涉及物理单位或角度；所有量都是纯组合的，并且必须按规定以整数形式呈现。解决方案必须严格依赖于函数、满射性以及有限环上 ECA 的局部到全局构造的基本定义和逻辑。",
            "solution": "问题陈述已经过分析并被认为是有效的。它在科学上基于已建立的元胞自动机理论，问题定义良好，具有唯一且可计算的解，并使用客观、明确的语言表述。该任务是基础定义的直接应用，需要通过枚举状态转换来识别伊甸园构型。\n\n问题要求计算在由 $N$ 个元胞组成的一维环上，Wolfram 的基本元胞自动机 (ECA) 规则 $4$ 的伊甸园 (GoE) 态的数量。一个 GoE 态是在一个时间步内无法从任何其他构型达到的构型。\n\n设所有可能构型的集合为 $\\mathcal{C} = \\{0, 1\\}^N$。一个构型是一个向量 $x = (x_0, x_1, \\ldots, x_{N-1})$，其中每个 $x_i \\in \\{0, 1\\}$。构型的总数为 $|\\mathcal{C}| = 2^N$。\n\n全局更新映射 $F: \\mathcal{C} \\to \\mathcal{C}$ 由一个局部更新函数 $\\phi: \\{0, 1\\}^3 \\to \\{0, 1\\}$ 确定。对于一个构型 $x$，下一个构型 $y = F(x)$ 由以下公式给出：\n$$y_i = \\phi(x_{i-1}, x_i, x_{i+1})$$\n对于 $i = 0, 1, \\ldots, N-1$。边界条件是周期性的，因此索引在模 $N$ 的意义下解释。例如，$x_{-1} = x_{N-1}$ 且 $x_N = x_0$。\n\n问题指定了 Wolfram 规则 $4$。数字 $4$ 的二进制是 $00000100_2$。根据 Wolfram 的约定，这个二进制字符串定义了 $\\phi$ 对于从 $(1,1,1)$ 到 $(0,0,0)$ 排序的八个可能邻域的输出：\n- $\\phi(1,1,1) = 0$\n- $\\phi(1,1,0) = 0$\n- $\\phi(1,0,1) = 0$\n- $\\phi(1,0,0) = 0$\n- $\\phi(0,1,1) = 0$\n- $\\phi(0,1,0) = 1$\n- $\\phi(0,0,1) = 0$\n- $\\phi(0,0,0) = 0$\n\n因此，局部规则异常简单：一个元胞的新状态为 $1$ 当且仅当其邻域模式为 $(0,1,0)$（左邻居为 $0$，元胞为 $1$，右邻居为 $0$）。否则，新状态为 $0$。\n\n如果一个构型 $y \\in \\mathcal{C}$ 在 $F$ 下没有原像，那么它就是一个伊甸园态。也就是说，其原像集 $F^{-1}(y) = \\{x \\in \\mathcal{C} \\mid F(x) = y\\}$ 为空。任务是找到这类状态的数量，即 $| \\{y \\in \\mathcal{C} \\mid |F^{-1}(y)|=0 \\} |$。\n\n问题要求一个基于直接枚举的解决方案，而不是基于预先推导的解析公式。对于每个给定的系统大小 $N$，算法流程如下：\n\n1.  **初始化原像计数器**：创建一个大小为 $2^N$ 的数组，我们称之为 `preimage_counts`，所有条目初始化为 $0$。该数组的每个索引 $j$（从 $0$ 到 $2^N-1$）将对应一个唯一的构型 $y \\in \\mathcal{C}$（表示为整数 $j$），并存储其原像集的大小 $|F^{-1}(y)|$。\n\n2.  **遍历所有初始状态**：遍历所有 $2^N$ 个可能的初始构型 $x \\in \\mathcal{C}$。一个便捷的方法是迭代一个整数 $i$ 从 $0$ 到 $2^N-1$，并使用其 $N$ 位二进制表示作为构型 $x$。\n\n3.  **计算后继状态**：对于每个构型 $x$，计算其后继状态 $y = F(x)$。这涉及到对每个元胞 $x_i$ 及其邻居应用规则 $4$ 的逻辑，同时遵守周期性边界条件。使用向量化操作，这一步是高效的。给定一个表示构型的数组 `x`：左邻居数组是 `np.roll(x, 1)`。右邻居数组是 `np.roll(x, -1)`。后继构型 `y` 是通过检查所有元胞是否同时满足邻域条件 $(0,1,0)$ 来计算的。\n\n4.  **更新原像计数**：将得到的构型 $y$（一个由 $0$ 和 $1$ 组成的数组）转换回其唯一的整数表示，例如 $j$。增加该索引处的计数器：`preimage_counts[j]++`。\n\n5.  **计算伊甸园态数量**：在遍历所有 $2^N$ 个初始状态 $x$ 之后，`preimage_counts` 数组被完全填充。伊甸园态的数量是该数组中仍为 $0$ 的条目数。\n\n对测试套件 $\\{1, 2, 3, 4, 5, 6, 8\\}$ 中的每个 $N$ 值重复此过程，并将得到的结果计数收集到一个列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_goe_count(N):\n    \"\"\"\n    Calculates the number of Garden of Eden states for a given system size N\n    under Wolfram's Rule 4 with periodic boundary conditions.\n\n    The calculation is done by explicit enumeration as required by the problem.\n    \"\"\"\n    num_total_configs = 1  N  # This is 2**N\n\n    # Array to store the number of preimages for each of the 2^N possible configurations.\n    # The index of the array corresponds to the integer representation of a configuration.\n    preimage_counts = np.zeros(num_total_configs, dtype=np.int64)\n\n    # Iterate through all 2^N possible initial configurations 'x'.\n    # Each integer 'i' from 0 to 2^N-1 corresponds to a unique configuration.\n    for i in range(num_total_configs):\n        # 1. Convert the integer 'i' to its N-bit binary representation (configuration x).\n        # The representation is created as a NumPy array of integers.\n        x = np.array([int(bit) for bit in np.binary_repr(i, width=N)])\n\n        # 2. Compute the next state 'y = F(x)' under Rule 4.\n        # This is done efficiently using NumPy's vectorized operations.\n        # np.roll provides periodic boundary conditions.\n        left_neighbors = np.roll(x, 1)\n        center_cells = x\n        right_neighbors = np.roll(x, -1)\n\n        # Rule 4: the output is 1 if and only if the neighborhood is (0, 1, 0).\n        y = ((left_neighbors == 0)  (center_cells == 1)  (right_neighbors == 0)).astype(np.int8)\n\n        # 3. Convert the resulting configuration 'y' to its integer representation.\n        # This is done by treating the binary array as a base-2 number.\n        y_int = 0\n        for bit in y:\n            y_int = (y_int  1) | bit\n\n        # 4. Increment the preimage count for the computed configuration 'y'.\n        preimage_counts[y_int] += 1\n\n    # 5. The number of Garden of Eden states is the count of configurations 'y'\n    #    that have zero preimages.\n    goe_count = np.sum(preimage_counts == 0)\n    \n    return goe_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 5, 6, 8]\n\n    results = []\n    for N in test_cases:\n        # Calculate the number of GoE states for each system size N.\n        result = calculate_goe_count(N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管经验性的枚举可以揭示非满射性等性质的存在，但更深刻的理解需要形式化的数学工具。这个高级实践练习将引入德布鲁因图（De Bruijn graph），它是一个强大的框架，可以从元胞自动机的局部规则出发，分析其全局动力学 ()。你将推导并应用图论测试来判断规则90的单射性和满射性，从而将自动机的行为与符号动力学和线性代数的形式化结构联系起来。",
            "id": "4151338",
            "problem": "设 $f:\\{0,1\\}^{3}\\to\\{0,1\\}$ 为定义在双向无限构型空间 $\\{0,1\\}^{\\mathbb{Z}}$ 上，半径为 $1$ 的一维基本元胞自动机 (ECA) 的局部规则。其关联的全局映射 $F:\\{0,1\\}^{\\mathbb{Z}}\\to\\{0,1\\}^{\\mathbb{Z}}$ 定义为对所有 $i\\in\\mathbb{Z}$，有 $(F(x))_{i}=f(x_{i-1},x_{i},x_{i+1})$。该 ECA 的 2 阶 De Bruijn 图是一个有向图，其顶点集为 $\\{0,1\\}^{2}$，对于每个 $(a,b,c)\\in\\{0,1\\}^{3}$，都有一条从 $(a,b)$ 到 $(b,c)$ 的边，其标签为 $\\lambda(a,b,c)=f(a,b,c)$。此带标签图中的一条双向无限路径会导出一个在 $\\{0,1\\}^{\\mathbb{Z}}$ 中的双向无限标签序列，而每个双向无限构型 $x\\in\\{0,1\\}^{\\mathbb{Z}}$ 会导出一个双向无限顶点序列 $(x_{i},x_{i+1})_{i\\in\\mathbb{Z}}$ 和一个边标签序列 $(f(x_{i-1},x_{i},x_{i+1}))_{i\\in\\mathbb{Z}}$。\n\n从这些核心定义出发，基于符号动力学和 sofic 移动的图表示，进行以下推导：\n\n- 根据带标签的 De Bruijn 图，推导出一个关于 $F$ 到 $\\{0,1\\}^{\\mathbb{Z}}$ 的满射性的图论检验方法。你的检验方法必须仅使用上述基本定义和移动空间的带标签图表示的既有性质来陈述和证明。\n\n- 根据带标签的 De Bruijn 图中是否存在产生相同双向无限标签序列的多条不同双向无限路径，推导出一个关于 $F$ 的单射性的图论检验方法。同样，直接根据定义和带标签表示的性质来证明该检验方法。\n\n- 将你的检验方法应用于 ECA 规则 $90$，其局部规则为 $f(a,b,c)=a\\oplus c$，其中 $\\oplus$ 表示模 2 加法。证明 $F$ 在 $\\{0,1\\}^{\\mathbb{Z}}$ 上是满射的但不是单射的。\n\n- 最后，将规则 90 视为二元域 $\\mathbb{F}_{2}$ 上的线性元胞自动机，并计算 $F$ 作为 $\\mathbb{F}_{2}^{\\mathbb{Z}}$ 上的线性映射其核的维数 $\\dim_{\\mathbb{F}_{2}}(\\ker(F))$。\n\n你最终报告的量必须是 $\\dim_{\\mathbb{F}_{2}}(\\ker(F))$ 的单个整数值。无需四舍五入，无单位。将最终答案表示为单个数字。",
            "solution": "所述问题是符号动力学、元胞自动机和有限域上线性代数领域中一个明确定义的数学练习。所有术语都有正式定义，所要求的推导在文献中是标准的，并且问题是自洽且逻辑一致的。没有科学或事实上的不健全之处，没有歧义，且问题是可验证的。因此，问题是有效的，并将提供解答。\n\n解答按要求分为四个部分：满射性检验方法的推导，单射性检验方法的推导，将这些检验方法应用于基本元胞自动机（ECA）规则 90，以及将规则 90 视为线性映射时其核维数的计算。\n\n### 第一部分：满射性的图论检验方法\n\n全局映射 $F:\\{0,1\\}^{\\mathbb{Z}}\\to\\{0,1\\}^{\\mathbb{Z}}$ 是满射的，如果对于每一个双向无限标签序列 $y \\in \\{0,1\\}^{\\mathbb{Z}}$，都存在至少一个双向无限构型 $x \\in \\{0,1\\}^{\\mathbb{Z}}$ 使得 $F(x) = y$。\n\n在带标签的 De Bruijn 图的框架中，一个构型 $x$ 对应于一条穿过图顶点的双向无限路径，具体来说是顶点路径 $(v_i)_{i \\in \\mathbb{Z}} = ((x_i, x_{i+1}))_{i \\in \\mathbb{Z}}$。输出构型 $y=F(x)$ 是构成这条路径的边上的标签序列，其中 $y_i = (F(x))_i = f(x_{i-1}, x_i, x_{i+1})$ 是从顶点 $(x_{i-1}, x_i)$ 到顶点 $(x_i, x_{i+1})$ 的边的标签。\n\n所有可以由带标签的 De Bruijn 图中的路径生成的双向无限标签序列的集合被称为 sofic 移动。映射 $F$ 是满射的，当且仅当这个 sofic 移动是“完全移动” $\\{0,1\\}^{\\mathbb{Z}}$，意味着来自 $\\{0,1\\}^{\\mathbb{Z}}$ 的任何任意标签序列都可以被生成。\n\n为了使一个任意的标签序列 $y=(y_i)_{i\\in\\mathbb{Z}}$ 可以被生成，我们必须能够构造一个相应的顶点路径 $(v_i)_{i\\in\\mathbb{Z}}$。这意味着对于路径构造中的任何给定状态（顶点）$v_i$ 和任何期望的下一个标签 $y_{i+1}$，必须存在一个可以从 $v_i$ 通过带有标签 $y_{i+1}$ 的边到达的下一个顶点 $v_{i+1}$。如果这个条件对所有顶点和所有可能的标签都成立，我们就可以将任何生成有限标签字符串的有限路径扩展为生成双向无限标签序列的双向无限路径。\n\n因此，满射性的图论检验方法如下：\n**满射性检验：** 全局映射 $F$ 是满射的，当且仅当在带标签的 De Bruijn 图中，从每个顶点 $v$ 出发，对于 $\\{0,1\\}$ 中的每个可能标签，都至少有一条出边。\n\n### 第二部分：单射性的图论检验方法\n\n全局映射 $F$ 是单射的，如果对于任何两个不同的构型 $x, x' \\in \\{0,1\\}^{\\mathbb{Z}}$（即 $x \\neq x'$），它们的像也不同，$F(x) \\neq F(x')$。等价地，$F$ 不是单射的，如果存在 $x \\neq x'$ 使得 $F(x) = F(x')$。\n\n在图表示中，$x \\neq x'$ 意味着它们对应的双向无限顶点路径 $(v_i)_{i\\in\\mathbb{Z}}$ 和 $(v'_i)_{i\\in\\mathbb{Z}}$ 是不同的。$F(x) = F(x')$ 意味着这两条不同的顶点路径产生了完全相同的双向无限边标签序列。\n\n在这种情况下，存在这样一对产生相同标签序列的不同路径，是非单射性的定义特征。这种情况出现的当且仅当图中包含所谓的“菱形结构”：一对不同的路径，它们共享一个共同的起始顶点和一个共同的结束顶点，并且沿着路径的边标签序列相同。如果存在这样的有限菱形结构，人们可以通过将该菱形结构嵌入到一个周围共同约定的路径中，来构造两个具有相同像的不同双向无限构型。\n\n因此，单射性的图论检验方法如下：\n**单射性检验：** 全局映射 $F$ 是单射的，当且仅当带标签的 De Bruijn 图不包含任何“菱形结构”。一个菱形结构是一对不同的有限路径 $\\pi_1$ 和 $\\pi_2$，它们始于同一顶点 $u$ 并终于同一顶点 $v$，并且沿 $\\pi_1$ 的边标签序列与沿 $\\pi_2$ 的边标签序列完全相同。对于任何顶点对 $u,v$ 和任何路径长度，不存在此类结构可保证任何给定的标签序列最多只能由一条路径生成，从而确保单射性。\n\n### 第三部分：应用于规则 90\n\nECA 规则 90 由局部规则 $f(a,b,c) = a \\oplus c$ 定义，其中 $\\oplus$ 是模 2 加法。De Bruijn 图的顶点集是 $\\{ (0,0), (0,1), (1,0), (1,1) \\}$。边的形式为 $(a,b)\\to(b,c)$，标签为 $a \\oplus c$。8 种可能的转移及其标签是：\n\\begin{itemize}\n    \\item $f(0,0,0) = 0 \\oplus 0 = 0$：边 $(0,0) \\to (0,0)$，标签为 $0$。\n    \\item $f(0,0,1) = 0 \\oplus 1 = 1$：边 $(0,0) \\to (0,1)$，标签为 $1$。\n    \\item $f(0,1,0) = 0 \\oplus 0 = 0$：边 $(0,1) \\to (1,0)$，标签为 $0$。\n    \\item $f(0,1,1) = 0 \\oplus 1 = 1$：边 $(0,1) \\to (1,1)$，标签为 $1$。\n    \\item $f(1,0,0) = 1 \\oplus 0 = 1$：边 $(1,0) \\to (0,0)$，标签为 $1$。\n    \\item $f(1,0,1) = 1 \\oplus 1 = 0$：边 $(1,0) \\to (0,1)$，标签为 $0$。\n    \\item $f(1,1,0) = 1 \\oplus 0 = 1$：边 $(1,1) \\to (1,0)$，标签为 $1$。\n    \\item $f(1,1,1) = 1 \\oplus 1 = 0$：边 $(1,1) \\to (1,1)$，标签为 $0$。\n\\end{itemize}\n\n**规则 90 的满射性：**\n我们应用满射性检验。我们检查从每个顶点出发的标签：\n\\begin{itemize}\n    \\item 从顶点 $(0,0)$ 出发：出边标签为 $\\{0, 1\\}$。\n    \\item 从顶点 $(0,1)$ 出发：出边标签为 $\\{0, 1\\}$。\n    \\item 从顶点 $(1,0)$ 出发：出边标签为 $\\{0, 1\\}$。\n    \\item 从顶点 $(1,1)$ 出发：出边标签为 $\\{0, 1\\}$。\n\\end{itemize}\n由于每个顶点都有对应两种可能标签 0 和 1 的出边，因此满足满射性条件。因此，**对于规则 90，F 是满射的**。\n\n**规则 90 的单射性：**\n我们通过寻找映射到相同输出的不同构型来应用单射性检验。\n考虑构型 $x = (\\dots, 0, 0, 0, \\dots)$，即全零构型。对任何位点 $i$，其邻域为 $(0,0,0)$。输出为 $(F(x))_i = f(0,0,0) = 0 \\oplus 0 = 0$。因此，$F(x)$ 是全零构型。\n\n现在考虑构型 $x' = (\\dots, 1, 0, 1, 0, 1, 0, \\dots)$，即交错或“棋盘格”构型。\n\\begin{itemize}\n    \\item 在 $x'_i = 0$ 的位点 $i$，邻域为 $(x'_{i-1}, x'_i, x'_{i+1}) = (1,0,1)$。输出为 $(F(x'))_i = f(1,0,1) = 1 \\oplus 1 = 0$。\n    \\item 在 $x'_i = 1$ 的位点 $i$，邻域为 $(x'_{i-1}, x'_i, x'_{i+1}) = (0,1,0)$。输出为 $(F(x'))_i = f(0,1,0) = 0 \\oplus 0 = 0$。\n\\end{itemize}\n在这两种情况下，输出都是 0。因此，$F(x')$ 也是全零构型。\n我们找到了两个不同的构型 $x \\neq x'$，使得 $F(x) = F(x') = (\\dots, 0, 0, 0, \\dots)$。在图表示中，这对应于两条产生全零标签序列的不同双向无限路径：\n1.  对应 $x$ 的路径：顶点 $(0,0)$ 上的自环。边为 $(0,0) \\to (0,0)$，标签为 $0$。\n2.  对应 $x'$ 的路径：顶点 $(0,1)$ 和 $(1,0)$ 之间的 2-循环。边 $(0,1) \\to (1,0)$ 的标签为 0，边 $(1,0) \\to (0,1)$ 的标签也为 0。\n这两条不同的路径/循环都生成序列 $(\\dots, 0, 0, 0, \\dots)$，这构成了一种菱形结构。\n因此，**对于规则 90，F 不是单射的**。\n\n### 第四部分：规则 90 的核的维数\n\n我们将 ECA 视为在域 $\\mathbb{F}_{2}$ 上的向量空间 $\\mathbb{F}_{2}^{\\mathbb{Z}}$ 上的一个线性映射 $F$。全局映射由 $(F(x))_i = x_{i-1} + x_{i+1}$ 给出，其中算术是模 2 的。$F$ 的核，记作 $\\ker(F)$，是所有满足 $F(x) = \\mathbf{0}$ 的构型 $x \\in \\mathbb{F}_{2}^{\\mathbb{Z}}$ 的集合，其中 $\\mathbf{0}$ 是全零构型。\n\n$x \\in \\ker(F)$ 的条件是对于所有 $i \\in \\mathbb{Z}$，有 $(F(x))_i = 0$。\n$$x_{i-1} + x_{i+1} = 0 \\pmod 2$$\n这等价于线性递推关系：\n$$x_{i+1} = x_{i-1} \\quad \\text{对于所有 } i \\in \\mathbb{Z}$$\n这个关系意味着对所有 $i$，有 $x_{i+2} = x_i$。这意味着核中的任何序列都必须是周期为 2 的周期序列。\n\n一个周期为 2 的双向无限序列 $x$ 完全由任意两个相邻元素的值确定，例如 $x_0$ 和 $x_1$。设 $x_0 = c_0$ 和 $x_1 = c_1$，其中 $c_0, c_1 \\in \\mathbb{F}_2$。那么整个序列的形式为：\n$$x = (\\dots, c_1, c_0, c_1, c_0, c_1, \\dots)$$\n所有这些序列的集合 $\\ker(F)$ 构成了 $\\mathbb{F}_{2}^{\\mathbb{Z}}$ 的一个向量子空间。我们可以通过将一个序列 $x$ 映射到定义它的值对来定义一个向量空间同构 $\\phi: \\ker(F) \\to \\mathbb{F}_{2}^{2}$：$\\phi(x) = (x_0, x_1)$。由于 $\\ker(F)$ 与向量空间 $\\mathbb{F}_{2}^{2}$ 同构，它们的维数必须相等。$\\mathbb{F}_{2}^{2}$ 在 $\\mathbb{F}_{2}$ 上的维数是 2。\n\n或者，我们可以确定 $\\ker(F)$ 的一组基。令 $b_0$ 为由 $(x_0, x_1) = (1,0)$ 定义的序列。这是序列 $(\\dots, 0, 1, 0, 1, 0, \\dots)$，其中 $x_0=1$。令 $b_1$ 为由 $(x_0, x_1) = (0,1)$ 定义的序列。这是序列 $(\\dots, 1, 0, 1, 0, 1, \\dots)$，其中 $x_1=1$。向量 $b_0$ 和 $b_1$ 是线性无关的。任何满足 $(x_0, x_1) = (c_0, c_1)$ 的序列 $x \\in \\ker(F)$ 都可以写成唯一的线性组合 $x = c_0 b_0 + c_1 b_1$。因此，$\\{b_0, b_1\\}$ 是 $\\ker(F)$ 的一组基，其维数是基向量的数量。\n\n核的维数是 2。核包含 $2^2=4$ 个元素：全零序列 $(c_0=0, c_1=0)$，全一序列 $(c_0=1, c_1=1)$，以及两个交错序列。\n\n因此，$F$ 的核的维数是 2。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}