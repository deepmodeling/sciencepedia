{
    "hands_on_practices": [
        {
            "introduction": "在任何动力系统中，理解因果结构和信息传播的极限至关重要。在一维元胞自动机中，这个概念具体化为“光锥”，即单个细胞的状态能够影响到的未来时空区域。这个练习要求我们从局部规则这一基本原则出发，精确推导出单个初始扰动在 $t$ 个时间步后可能影响的细胞集合，从而加深对元胞自动机中信息动态传播极限的理解。",
            "id": "4134811",
            "problem": "考虑一个一维初等元胞自动机 (ECA)，它定义为一个由 $\\mathbb{Z}$ 索引的、二元状态、同步更新的格点系统，其中每个位置 $i \\in \\mathbb{Z}$ 在离散时间 $t \\in \\mathbb{N}$ 具有状态 $x_i(t) \\in \\{0,1\\}$，并根据一个均匀的、半径为 1 的局部更新规则 $f:\\{0,1\\}^3 \\to \\{0,1\\}$ 通过 $x_i(t+1) = f\\big(x_{i-1}(t), x_i(t), x_{i+1}(t)\\big)$ 进行演化。设初始条件为 $x_j(0)$，其中 $x_0(0) = 1$ 且对于所有 $j \\neq 0$ 有 $x_j(0) = 0$。将在 $t$ 步后可能受原点处单个非零种子影响的位置集合定义为\n$$A(t) = \\left\\{\\, i \\in \\mathbb{Z} \\ \\text{使得存在一个半径为}1\\ \\text{的ECA规则}\\ f\\ \\text{，对于该规则，位置}\\ i\\ \\text{在时间}\\ t\\ \\text{的构型取决于}\\ x_0(0) \\,\\right\\}.$$\n从半径为 1 的局部性和同步更新的核心原则出发，推导集合 $A(t)$ 的一个精确刻画，然后确定其基数 $\\left|A(t)\\right|$ 作为 $t$ 的函数的封闭形式表达式。作为示例，明确列出 $A(5)$。将 $\\left|A(t)\\right|$ 的最终公式以最简精确形式表示。不需要四舍五入。",
            "solution": "我们从初等元胞自动机 (ECA) 的定义属性开始：它是一个定义在 $\\mathbb{Z}$ 上的一维、二元状态、同步更新的系统，具有一个均匀的、半径为 1 的局部规则 $f:\\{0,1\\}^3 \\to \\{0,1\\}$，通过该规则更新每个位置：\n$$\nx_i(t+1) = f\\big(x_{i-1}(t), x_i(t), x_{i+1}(t)\\big).\n$$\n我们使用的基本依据是局部性：在每个时间步，位置 $i$ 的新状态仅取决于半径为 1 邻域内的先前状态，即位置 $i-1$、$i$ 和 $i+1$。\n\n我们通过光锥论证来形式化依赖关系的传播。定义依赖集 $D(i,t)$ 为其时间为 0 的值可以影响 $x_i(t)$ 的初始索引的集合。我们断言，对于半径为 1 的 ECA，\n$$\nD(i,t) \\subseteq \\{\\, j \\in \\mathbb{Z} : i - t \\leq j \\leq i + t \\,\\}.\n$$\n我们通过对 $t$ 进行数学归纳来证明这个断言。\n\n基础情形 ($t = 0$)：显然，$x_i(0)$ 只依赖于其自身，所以 $D(i,0) = \\{i\\}$，它是 $\\{\\, j : i \\leq j \\leq i \\,\\}$ 的子集。\n\n归纳步骤：假设 $D(i,t) \\subseteq \\{\\, j : i - t \\leq j \\leq i + t \\,\\}$。在时间 $t+1$，\n$$\nx_i(t+1) = f\\big(x_{i-1}(t), x_i(t), x_{i+1}(t)\\big),\n$$\n所以依赖集满足\n$$\nD(i,t+1) \\subseteq D(i-1,t) \\cup D(i,t) \\cup D(i+1,t).\n$$\n根据归纳假设，\n\\begin{align*}\nD(i-1,t) \\subseteq \\{\\, j : (i-1) - t \\leq j \\leq (i-1) + t \\,\\} = \\{\\, j : i - (t+1) \\leq j \\leq i + (t-1) \\,\\}, \\\\\nD(i,t) \\subseteq \\{\\, j : i - t \\leq j \\leq i + t \\,\\}, \\\\\nD(i+1,t) \\subseteq \\{\\, j : (i+1) - t \\leq j \\leq (i+1) + t \\,\\} = \\{\\, j : i - (t-1) \\leq j \\leq i + (t+1) \\,\\}.\n\\end{align*}\n这些集合的并集包含在\n$$\n\\{\\, j : i - (t+1) \\leq j \\leq i + (t+1) \\,\\},\n$$\n中，这便确立了归纳步骤。因此，对于所有 $t \\in \\mathbb{N}$，\n$$\nD(i,t) \\subseteq \\{\\, j \\in \\mathbb{Z} : i - t \\leq j \\leq i + t \\,\\}.\n$$\n\n现在考虑特定的初始条件 $x_0(0) = 1$ 且对于所有 $j \\neq 0$ 有 $x_j(0) = 0$。只有当 $0 \\in D(i,t)$ 时，时间 $t$ 的位置 $i$ 才会受到原点处种子的影响，根据依赖锥的刻画，这意味着\n$$\n|i - 0| \\leq t \\quad \\text{或等价地} \\quad |i| \\leq t.\n$$\n因此我们得到包含关系\n$$\nA(t) \\subseteq \\{\\, i \\in \\mathbb{Z} : |i| \\leq t \\,\\}.\n$$\n为了证明等式成立，我们展示对于每个满足 $|i| \\leq t$ 的 $i$，都存在某个半径为 1 的规则 $f$，在该规则下 $x_0(0)$ 的影响会到达 $x_i(t)$。一个构造性的例子是由以下规则定义\n$$\nf(a,b,c) = a \\lor b \\lor c,\n$$\n其中 $\\lor$ 表示逻辑或。在此规则下，从 $x_0(0) = 1$ 和对于 $j \\neq 0$ 有 $x_j(0) = 0$ 开始，在时间 $t$ 等于 1 的位置集合恰好是 $\\{\\, i : |i| \\leq t \\,\\}$，因为每个时间步都会将连续的 1 方块向左和向右各扩展一个位置。因此，每个满足 $|i| \\leq t$ 的位置 $i$ 确实受到了初始种子的影响，我们得出结论\n$$\nA(t) = \\{\\, i \\in \\mathbb{Z} : |i| \\leq t \\,\\}.\n$$\n\n$A(t)$ 的基数是 $-t$ 和 $t$ 之间（含两端）的整数个数，即\n$$\n|A(t)| = 2t + 1.\n$$\n\n$t = 5$ 的示例：我们有\n$$\nA(5) = \\{\\, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 \\,\\},\n$$\n因此\n$$\n|A(5)| = 11.\n$$\n\n所要求的基数的最终公式，以最简精确形式表示，是 $2t + 1$。",
            "answer": "$$\\boxed{2t+1}$$"
        },
        {
            "introduction": "掌握了信息传播的理论边界后，下一步便是亲手模拟一个具体构型的演化。本练习以著名的规则110为例，它因其复杂的行为和计算普适性而闻名。通过这个实践，您将学习如何将一个规则转换为便于计算的代数范式（ANF），处理有限边界这一实际问题，并完整执行一步演化，从而揭开模拟复杂非线性规则的神秘面纱。",
            "id": "4134796",
            "problem": "考虑一个半径为 $1$ 的一维二元基本元胞自动机 (ECA)，其建立在长度为 $n$ 的有限格点上，并具有零边界条件 $x_{0}(t)=x_{n+1}(t)=0$。局部更新由一个作用于最近邻三元组的布尔函数 $f:\\{0,1\\}^{3}\\to\\{0,1\\}$ 指定，因此对于内部格点 $i\\in\\{2,\\dots,n-1\\}$，有 $x_{i}(t+1)=f\\big(x_{i-1}(t),x_{i}(t),x_{i+1}(t)\\big)$。ECA 规则由 Wolfram 编码给出：规则数 $R$ 写成一个 8 位的二进制字 $b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}$，它分别编码了按字典序排列的邻域 $111,110,101,100,011,010,001,000$ 的输出，即 $f(1,1,1)=b_{7}$，$f(1,1,0)=b_{6}$，…，$f(0,0,0)=b_{0}$。所有布尔代数操作都在伽罗瓦域 $\\mathbb{F}_{2}$ 上进行。\n\n从这些定义出发，且不使用其他定义，对规则 $R=110$ 的特定情况执行以下操作：\n1. 推导局部规则 $f(a,b,c)$ 在 $\\mathbb{F}_{2}$ 上的代数范式（也称为 Zhegalkin 多项式），其中 $a$、$b$ 和 $c$ 分别表示左、中、右输入。\n2. 使用零边界条件 $x_{0}(t)=x_{n+1}(t)=0$，构造边界处的诱导局部邻域，并分别用 $x_{1}(t),x_{2}(t)$ 和 $x_{n-1}(t),x_{n}(t)$ 表示边界元胞 $i=1$ 和 $i=n$ 的精确更新函数。\n3. 取 $n=8$ 和初始构型 $x(0)=(x_{1}(0),\\dots,x_{8}(0))=(1,0,1,1,0,1,0,1)$。在零边界条件下，根据规则 $R=110$ 演化一个时间步，然后将得到的构型 $x(1)$ 解释为一个大端序二进制整数 $I=\\sum_{i=1}^{8} x_{i}(1)\\,2^{8-i}$，其中 $x_{1}(1)$ 是最高有效位。报告单个整数 $I$ 作为你的最终答案。无需四舍五入。",
            "solution": "该问题是良定的，具有科学依据，并包含唯一解所需的所有信息。我们按顺序处理这三个任务。所有计算都在伽罗瓦域 $\\mathbb{F}_{2}$ 上进行，其中加法对应于异或(XOR)运算，乘法对应于与(AND)运算。\n\n### 第一部分：规则110的代数范式\n\n首先将十进制的规则数 $R=110$ 转换为其 8 位二进制表示：\n$$110_{10} = 64 + 32 + 8 + 4 + 2 = 1 \\cdot 2^6 + 1 \\cdot 2^5 + 0 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0 = (01101110)_2$$\n问题指明，这个二进制字 $b_7 b_6 b_5 b_4 b_3 b_2 b_1 b_0 = 01101110$ 对应于局部函数 $f(a,b,c)$ 对于输入邻域 $(a,b,c)$ 从 $(1,1,1)$ 到 $(0,0,0)$ 按字典序排列的输出。这给出了 $f$ 的以下真值表：\n\\begin{itemize}\n    \\item $f(1,1,1) = b_7 = 0$\n    \\item $f(1,1,0) = b_6 = 1$\n    \\item $f(1,0,1) = b_5 = 1$\n    \\item $f(1,0,0) = b_4 = 0$\n    \\item $f(0,1,1) = b_3 = 1$\n    \\item $f(0,1,0) = b_2 = 1$\n    \\item $f(0,0,1) = b_1 = 1$\n    \\item $f(0,0,0) = b_0 = 0$\n\\end{itemize}\n一个三变量布尔函数 $f(a,b,c)$ 在 $\\mathbb{F}_2$ 上的代数范式(ANF)或 Zhegalkin 多项式，是以下形式的多项式：\n$$f(a,b,c) = k_0 + k_1 a + k_2 b + k_3 c + k_4 ab + k_5 ac + k_6 bc + k_7 abc$$\n系数 $k_i$ 可以从真值表中确定。\n\\begin{itemize}\n    \\item $f(0,0,0) = k_0 = 0$\n    \\item $f(0,0,1) = k_0 + k_3 = k_3 = 1$\n    \\item $f(0,1,0) = k_0 + k_2 = k_2 = 1$\n    \\item $f(1,0,0) = k_0 + k_1 = k_1 = 0$\n    \\item $f(0,1,1) = k_0 + k_2 + k_3 + k_6 = 0 + 1 + 1 + k_6 = k_6 = 1$\n    \\item $f(1,0,1) = k_0 + k_1 + k_3 + k_5 = 0 + 0 + 1 + k_5 = 1 + k_5 = 1 \\implies k_5 = 0$\n    \\item $f(1,1,0) = k_0 + k_1 + k_2 + k_4 = 0 + 0 + 1 + k_4 = 1 + k_4 = 1 \\implies k_4 = 0$\n    \\item $f(1,1,1) = k_0 + k_1 + k_2 + k_3 + k_4 + k_5 + k_6 + k_7 = 0+0+1+1+0+0+1+k_7 = 1+k_7 = 0 \\implies k_7 = 1$\n\\end{itemize}\n代入这些系数，规则110的代数范式为：\n$$f(a,b,c) = 0 + 0a + 1b + 1c + 0ab + 0ac + 1bc + 1abc = b + c + bc + abc$$\n\n### 第二部分：边界更新函数\n\n格点 $i$ 处元胞的更新规则是 $x_i(t+1) = f(x_{i-1}(t), x_i(t), x_{i+1}(t))$。问题指定了零边界条件，即对于所有时间步 $t$，都有 $x_0(t) = 0$ 和 $x_{n+1}(t) = 0$。\n\n对于左边界元胞 $i=1$，更新函数为：\n$$x_1(t+1) = f(x_0(t), x_1(t), x_2(t)) = f(0, x_1(t), x_2(t))$$\n我们将 $a=0$、$b=x_1(t)$ 和 $c=x_2(t)$ 代入推导出的代数范式：\n$$x_1(t+1) = x_1(t) + x_2(t) + x_1(t)x_2(t) + (0)x_1(t)x_2(t) = x_1(t) + x_2(t) + x_1(t)x_2(t)$$\n\n对于右边界元胞 $i=n$，更新函数为：\n$$x_n(t+1) = f(x_{n-1}(t), x_n(t), x_{n+1}(t)) = f(x_{n-1}(t), x_n(t), 0)$$\n我们将 $a=x_{n-1}(t)$、$b=x_n(t)$ 和 $c=0$ 代入代数范式：\n$$x_n(t+1) = x_n(t) + 0 + x_n(t)(0) + x_{n-1}(t)x_n(t)(0) = x_n(t)$$\n\n### 第三部分：演化与整数转换\n\n给定一个大小为 $n=8$ 的格点和初始构型 $x(0) = (1,0,1,1,0,1,0,1)$。我们应用零边界条件 $x_0(0)=0$ 和 $x_9(0)=0$。我们计算下一个时间步的状态 $x(1)$。\n\n\\begin{itemize}\n    \\item $x_1(1) = f(x_0(0), x_1(0), x_2(0)) = f(0,1,0) = 1$\n    \\item $x_2(1) = f(x_1(0), x_2(0), x_3(0)) = f(1,0,1) = 1$\n    \\item $x_3(1) = f(x_2(0), x_3(0), x_4(0)) = f(0,1,1) = 1$\n    \\item $x_4(1) = f(x_3(0), x_4(0), x_5(0)) = f(1,1,0) = 1$\n    \\item $x_5(1) = f(x_4(0), x_5(0), x_6(0)) = f(1,0,1) = 1$\n    \\item $x_6(1) = f(x_5(0), x_6(0), x_7(0)) = f(0,1,0) = 1$\n    \\item $x_7(1) = f(x_6(0), x_7(0), x_8(0)) = f(1,0,1) = 1$\n    \\item $x_8(1) = f(x_7(0), x_8(0), x_9(0)) = f(0,1,0) = 1$\n\\end{itemize}\n在 $t=1$ 时得到的构型是 $x(1) = (1,1,1,1,1,1,1,1)$。\n\n最后，我们将此构型解释为一个大端序二进制整数 $I$：\n$$I = \\sum_{i=1}^{8} x_i(1) \\, 2^{8-i}$$\n$$I = x_1(1) \\cdot 2^7 + x_2(1) \\cdot 2^6 + x_3(1) \\cdot 2^5 + x_4(1) \\cdot 2^4 + x_5(1) \\cdot 2^3 + x_6(1) \\cdot 2^2 + x_7(1) \\cdot 2^1 + x_8(1) \\cdot 2^0$$\n代入 $x(1)$ 的值：\n$$I = 1 \\cdot 2^7 + 1 \\cdot 2^6 + 1 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$$\n$$I = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1$$\n$$I = 2^8 - 1 = 255$$\n整数值为 $255$。",
            "answer": "$$\\boxed{255}$$"
        },
        {
            "introduction": "正向模拟可以从现在预测未来，而一个更深层次的挑战是——能否从现在追溯过去？这个“逆问题”，即寻找前像（preimage），对于理解系统的可逆性、信息损失和整体复杂性至关重要。这项高级练习将引导您运用德布鲁因图（de Bruijn graph）和线性代数的强大工具，为任意给定的构型精确计算其可能的前像数量，建立元胞自动机与符号动力学之间的深刻联系。",
            "id": "4134761",
            "problem": "考虑一个一维初等元胞自动机 (ECA)，它由一个局部更新规则 $f:\\{0,1\\}^{3}\\to\\{0,1\\}$ 定义，该规则同步作用于一个周长为 $L$ 且具有周期性边界条件的二进制环上。一个构型是一个限制在 $L$ 个格点环上的双向无限二进制序列，下一个构型是通过将 $f$ 应用于以每个格点为中心的长度为3的邻域来获得的。在二进制字母表上的2阶德布鲁因图是一个有向图，其顶点集是长度为2的二进制词的集合，并且当且仅当 $uv$ 的最后一个符号等于 $vw$ 的第一个符号时，从顶点 $uv$ 到顶点 $vw$ 存在一条有向边；每条这样的边对应于长度为3的词 $uvw$。为了将该图中的路径计数与ECA动力学联系起来，我们为每条有向边分配一个标签 $f(uvw)\\in\\{0,1\\}$，该标签对应于相关邻域的ECA输出。\n\n任务：从第一性原理和定义出发，推导一个算法，该算法用于计算在环上进行一次ECA时间步长演化后，给定有限二进制词 $w\\in\\{0,1\\}^{L}$ 的不同二进制原像的数量。你的算法必须通过将计数问题重构为在2阶德布鲁因图中对有标签约束的闭合路径进行计数，并将该计数表示为一个可以使用整数上的有限维线性代数精确计算的封闭形式。通过在原像与带标签的德布鲁因图中长度为 $L$ 的有标签约束的闭合路径之间建立双射，来证明你的算法的正确性。\n\n验证：将你推导的算法应用于称为规则110的ECA，其Wolfram代码按邻域 $uvw\\in\\{111,110,101,100,011,010,001,000\\}$ 的顺序产生的输出 $f(uvw)$ 为 $f(111)=0, f(110)=1, f(101)=1, f(100)=0, f(011)=1, f(010)=1, f(001)=1, f(000)=0$。在周长为 $L=5$ 的环上使用周期性边界条件，计算由规则110在环上产生的词 $w=1\\,0\\,1\\,1\\,0$ 的一步原像的确切数量。将你的最终答案表示为单个整数；不需要四舍五入。",
            "solution": "该问题是有效的。它是在元胞自动机和符号动力学的既定数学框架内一个适定问题。它在科学上是合理的、客观的，并包含了唯一解所需的所有必要信息。\n\n我们将首先推导通用算法并证明其正确性。然后，我们将其应用于规则110的特定情况。\n\n### 第一部分：原像计数算法的推导\n\n在周长为 $L$ 的环上的一个一维初等元胞自动机（ECA）的构型是一个二进制序列 $x = (x_0, x_1, \\dots, x_{L-1})$，其中 $x_i \\in \\{0,1\\}$ 且下标按模 $L$ 计算。其动力学由一个局部更新规则 $f:\\{0,1\\}^3 \\to \\{0,1\\}$ 控制。如果对于每个格点 $i \\in \\{0, 1, \\dots, L-1\\}$，以下条件成立，则构型 $x$ 是构型 $w = (w_0, w_1, \\dots, w_{L-1})$ 的一个原像：\n$$w_i = f(x_{i-1}, x_i, x_{i+1})$$\n\n问题的核心是计算对于给定的 $w$，这样的构型 $x$ 的数量。我们将此问题重构为在二进制字母表上的2阶德布鲁因图 $G$ 上的路径计数问题。\n\n$G$ 的顶点是四个长度为2的二进制词：$V = \\{00, 01, 10, 11\\}$。对于任意 $u,v,w \\in \\{0,1\\}$，从顶点 $uv$ 到顶点 $vw$ 存在一条有向边。这条边代表邻域 $uvw$。原像构型 $x = (x_0, \\dots, x_{L-1})$ 唯一对应于 $G$ 中一条长度为 $L$ 的闭合路径，其顶点序列为 $(x_{L-1}x_0), (x_0x_1), \\dots, (x_{L-2}x_{L-1})$。\n\n$w$ 构型对这条路径施加了标签约束。对于路径中的第 $i$ 条边，它连接顶点 $(x_{i-1}x_i)$ 和 $(x_ix_{i+1})$，代表邻域 $x_{i-1}x_ix_{i+1}$。这条边的标签必须等于 $w_i$。\n\n因此，计算原像的数量等价于计算 $G$ 中满足标签序列 $w$ 的长度为 $L$ 的闭合路径的数量。这个问题可以通过矩阵乘法解决。\n\n我们定义 $L$ 个 $4 \\times 4$ 的转移矩阵 $M_0, M_1, \\dots, M_{L-1}$，其中顶点集 $V$ 按字典序 $\\{00, 01, 10, 11\\}$ 排序。矩阵 $M_k$ 的元素 $(M_k)_{ij}$ 定义为：\n$$(M_k)_{ij} = \\begin{cases} 1  \\text{如果存在从顶点 } v_i \\text{ 到 } v_j \\text{ 的边，其标签为 } w_k \\\\ 0  \\text{否则} \\end{cases}$$\n其中 $v_i, v_j$ 是 $V$ 中的顶点。\n\n从顶点 $v_s$ 开始，经过 $L$ 步后到达顶点 $v_e$，且路径的标签序列为 $w = (w_0, \\dots, w_{L-1})$ 的路径数量由矩阵乘积 $P = M_{L-1} \\cdots M_1 M_0$ 的元素 $P_{es}$ 给出。\n\n我们寻找的是闭合路径，所以我们需要对所有可能的起始（也是结束）顶点求和。因此，原像的总数是 $P$ 的迹（trace）：\n$$N = \\text{Tr}(P) = \\text{Tr}(M_{L-1} \\cdots M_1 M_0)$$\n\n### 第二部分：应用于规则110\n\n**1. 建立标签矩阵**\n\n规则110的真值表（邻域 $\\to$ 输出）为：\n$111 \\to 0$, $110 \\to 1$, $101 \\to 1$, $100 \\to 0$, $011 \\to 1$, $010 \\to 1$, $001 \\to 1$, $000 \\to 0$.\n\n我们将为输出标签 $0$ 和 $1$ 分别构建两个基本转移矩阵，记为 $A_0$ 和 $A_1$。顶点排序为 $v_1=00, v_2=01, v_3=10, v_4=11$。\n\n-   **矩阵 $A_0$ (输出为0):**\n    -   $000 \\to 0$: 边 $00 \\to 00$。 $(A_0)_{1,1}=1$。\n    -   $100 \\to 0$: 边 $10 \\to 00$。 $(A_0)_{3,1}=1$。\n    -   $111 \\to 0$: 边 $11 \\to 11$。 $(A_0)_{4,4}=1$。\n    -   所有其他项为0。\n    $$ A_0 = \\begin{pmatrix} 1  0  0  0 \\\\ 0  0  0  0 \\\\ 1  0  0  0 \\\\ 0  0  0  1 \\end{pmatrix} $$\n\n-   **矩阵 $A_1$ (输出为1):**\n    -   $001 \\to 1$: 边 $00 \\to 01$。 $(A_1)_{1,2}=1$。\n    -   $010 \\to 1$: 边 $01 \\to 10$。 $(A_1)_{2,3}=1$。\n    -   $011 \\to 1$: 边 $01 \\to 11$。 $(A_1)_{2,4}=1$。\n    -   $101 \\to 1$: 边 $10 \\to 01$。 $(A_1)_{3,2}=1$。\n    -   $110 \\to 1$: 边 $11 \\to 10$。 $(A_1)_{4,3}=1$。\n    -   所有其他项为0。\n    $$ A_1 = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  1 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix} $$\n\n**2. 计算矩阵乘积**\n\n目标构型为 $w = 10110$，长度 $L=5$。对应的矩阵序列为 $M_0=A_1, M_1=A_0, M_2=A_1, M_3=A_1, M_4=A_0$。我们需要计算 $P = M_4 M_3 M_2 M_1 M_0 = A_0 A_1 A_1 A_0 A_1$ 的迹。\n\n-   $P_1 = M_1 M_0 = A_0 A_1 = \\begin{pmatrix} 1  0  0  0 \\\\ 0  0  0  0 \\\\ 1  0  0  0 \\\\ 0  0  0  1 \\end{pmatrix} \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  1 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix}$\n\n-   $P_2 = M_2 P_1 = A_1 P_1 = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  1 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  0 \\\\ 0  1  1  0 \\\\ 0  0  0  0 \\\\ 0  1  0  0 \\end{pmatrix}$\n\n-   $P_3 = M_3 P_2 = A_1 P_2 = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  1 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix} \\begin{pmatrix} 0  0  0  0 \\\\ 0  1  1  0 \\\\ 0  0  0  0 \\\\ 0  1  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  1  1  0 \\\\ 0  1  0  0 \\\\ 0  1  1  0 \\\\ 0  0  0  0 \\end{pmatrix}$\n\n-   $P = M_4 P_3 = A_0 P_3 = \\begin{pmatrix} 1  0  0  0 \\\\ 0  0  0  0 \\\\ 1  0  0  0 \\\\ 0  0  0  1 \\end{pmatrix} \\begin{pmatrix} 0  1  1  0 \\\\ 0  1  0  0 \\\\ 0  1  1  0 \\\\ 0  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  1  1  0 \\\\ 0  0  0  0 \\\\ 0  1  1  0 \\\\ 0  0  0  0 \\end{pmatrix}$\n\n**3. 计算迹**\n\n原像的数量是 $P$ 的迹：\n$$ N = \\text{Tr}(P) = P_{11} + P_{22} + P_{33} + P_{44} = 0 + 0 + 1 + 0 = 1 $$\n\n因此，构型 $w=10110$ 有且仅有 1 个原像。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}