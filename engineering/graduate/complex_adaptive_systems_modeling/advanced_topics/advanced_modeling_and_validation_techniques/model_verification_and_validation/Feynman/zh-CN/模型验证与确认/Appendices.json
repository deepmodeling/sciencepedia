{
    "hands_on_practices": [
        {
            "introduction": "为了有效地验证一个复杂模型，我们必须首先理解其不确定性的来源。本练习引入了一个基本的统计工具——全方差定律，它使我们能够从数学上分解模型输出的不确定性。通过完成这项练习 ()，您将学会如何推导一组特定参数对总输出方差贡献的严格界限，这对于指导敏感性分析和确定验证工作的优先顺序至关重要。",
            "id": "4127760",
            "problem": "考虑一个复杂自适应系统模型，其随机输出 $Y$ 依赖于一个不确定参数向量 $X = (X_{S}, X_{T})$，其中 $X_{S}$ 是为可能的定向验证而选择的参数子集，而 $X_{T}$ 表示其余参数。假设以下基本依据：方差的定义 $\\operatorname{Var}(Y) = \\mathbb{E}\\!\\left[(Y - \\mathbb{E}[Y])^{2}\\right]$，条件期望和条件方差 $\\mathbb{E}[Y \\mid X_{S}]$ 和 $\\operatorname{Var}(Y \\mid X_{S})$，以及全方差公式 $\\operatorname{Var}(Y) = \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] + \\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$。\n\n给定一个科学上合理的验证场景：一个大型、收敛的模拟运行系综产生了一个经验上稳定的总输出方差估计值 $\\operatorname{Var}(Y) = 4.50 \\times 10^{2}$。独立的验证实验在一个已校准的可信集 $\\mathcal{C}$（对于 $X_{S}$，$\\mathbb{P}(X_{S} \\in \\mathcal{C}) = 1$）上约束了条件方差，并确定对于每一个 $x_{s} \\in \\mathcal{C}$，条件方差满足 $v_{\\min} \\leq \\operatorname{Var}(Y \\mid X_{S} = x_{s}) \\leq v_{\\max}$，其中 $v_{\\min} = 1.40 \\times 10^{2}$ 且 $v_{\\max} = 2.20 \\times 10^{2}$。\n\n仅从这些基本依据出发，推导由 $X_{S}$ 引起的方差贡献（量化为 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$）的严格下界和上界，然后表示 $X_{S}$ 对总输出方差的比例贡献的相应界限，其定义为\n$$F_{S} \\equiv \\frac{\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)}{\\operatorname{Var}(Y)}.$$\n使用给定值计算 $F_{S}$ 的两个数值界限，并将结果四舍五入到四位有效数字。使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境将这两个界限表示为一个行矩阵。最后，简要解释这些界限如何为 $X_{S}$ 的定向验证决策提供信息，特别是在减少输出不确定性的潜力方面。该解释是您推理的一部分，但不属于最终答案输出规范的一部分。",
            "solution": "所述问题具有科学依据，是适定的，并包含了获得唯一解所需的所有信息。其前提基于全方差公式（概率论中的一个标准定理），所描述的场景是不确定性量化和模型验证领域中的一个常规应用。因此，该问题是有效的，我们着手解决它。\n\n我们的出发点是全方差公式，它根据一个条件变量（在本例中为参数向量子集 $X_{S}$）来分解随机变量 $Y$ 的总方差。该公式如下：\n$$\n\\operatorname{Var}(Y) = \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] + \\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)\n$$\n项 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 表示输出 $Y$ 中由参数 $X_{S}$ 的不确定性所解释的那部分方差。这是我们感兴趣的量。我们可以通过重新排列方程来分离它：\n$$\n\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right) = \\operatorname{Var}(Y) - \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]\n$$\n我们已知总方差 $\\operatorname{Var}(Y) = 4.50 \\times 10^{2}$。为了找到 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 的界限，我们必须首先确定项 $\\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]$ 的界限。\n\n问题指出，独立的验证实验已经确定，对于随机向量 $X_{S}$ 在其可信集 $\\mathcal{C}$（其中 $\\mathbb{P}(X_{S} \\in \\mathcal{C}) = 1$）内的任何实现 $x_{s}$，条件方差 $\\operatorname{Var}(Y \\mid X_{S} = x_{s})$ 是有界的。因此，随机变量 $Z \\equiv \\operatorname{Var}(Y \\mid X_{S})$ 几乎必然满足以下不等式：\n$$\nv_{\\min} \\leq Z \\leq v_{\\max}\n$$\n这些界限的值已知为 $v_{\\min} = 1.40 \\times 10^{2}$ 和 $v_{\\max} = 2.20 \\times 10^{2}$。\n\n期望算子是单调的。如果一个随机变量 $A$ 被常数 $c_{1}$ 和 $c_{2}$ 所界定，使得 $\\mathbb{P}(c_{1} \\leq A \\leq c_{2}) = 1$，那么它的期望也受同样的常数界定：$c_{1} \\leq \\mathbb{E}[A] \\leq c_{2}$。将此性质应用于随机变量 $Z = \\operatorname{Var}(Y \\mid X_{S})$，我们得到其期望的界限：\n$$\n\\mathbb{E}[v_{\\min}] \\leq \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] \\leq \\mathbb{E}[v_{\\max}]\n$$\n由于 $v_{\\min}$ 和 $v_{\\max}$ 是常数，它们的期望就是其自身的值。因此：\n$$\nv_{\\min} \\leq \\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right] \\leq v_{\\max}\n$$\n现在我们可以将这些界限代入我们关于 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 的表达式中。\n为了获得 $\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)$ 的下界，我们必须减去 $\\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]$ 的最大可能值，即 $v_{\\max}$：\n$$\n\\left(\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)\\right)_{\\min} = \\operatorname{Var}(Y) - v_{\\max}\n$$\n为了获得上界，我们必须减去 $\\mathbb{E}\\!\\left[\\operatorname{Var}(Y \\mid X_{S})\\right]$ 的最小可能值，即 $v_{\\min}$：\n$$\n\\left(\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)\\right)_{\\max} = \\operatorname{Var}(Y) - v_{\\min}\n$$\n这为来自 $X_{S}$ 的方差贡献建立了严格的不等式：\n$$\n\\operatorname{Var}(Y) - v_{\\max} \\leq \\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right) \\leq \\operatorname{Var}(Y) - v_{\\min}\n$$\n问题要求的是比例贡献 $F_{S}$ 的界限，其定义为：\n$$\nF_{S} \\equiv \\frac{\\operatorname{Var}\\!\\left(\\mathbb{E}[Y \\mid X_{S}]\\right)}{\\operatorname{Var}(Y)}\n$$\n由于 $\\operatorname{Var}(Y)$ 是一个正常数，我们可以将整个不等式除以它，而不会改变不等号的方向：\n$$\n\\frac{\\operatorname{Var}(Y) - v_{\\max}}{\\operatorname{Var}(Y)} \\leq F_{S} \\leq \\frac{\\operatorname{Var}(Y) - v_{\\min}}{\\operatorname{Var}(Y)}\n$$\n这可以简化为：\n$$\n1 - \\frac{v_{\\max}}{\\operatorname{Var}(Y)} \\leq F_{S} \\leq 1 - \\frac{v_{\\min}}{\\operatorname{Var}(Y)}\n$$\n现在，我们代入给定的数值：\n$\\operatorname{Var}(Y) = 4.50 \\times 10^{2} = 450$\n$v_{\\min} = 1.40 \\times 10^{2} = 140$\n$v_{\\max} = 2.20 \\times 10^{2} = 220$\n\n$F_{S}$ 的下界是：\n$$\n(F_{S})_{\\min} = 1 - \\frac{220}{450} = 1 - \\frac{22}{45} = \\frac{23}{45} \\approx 0.51111...\n$$\n四舍五入到四位有效数字，我们得到 $(F_{S})_{\\min} = 0.5111$。\n\n$F_{S}$ 的上界是：\n$$\n(F_{S})_{\\max} = 1 - \\frac{140}{450} = 1 - \\frac{14}{45} = \\frac{31}{45} \\approx 0.68888...\n$$\n四舍五入到四位有效数字，我们得到 $(F_{S})_{\\max} = 0.6889$。\n\n因此，参数 $X_S$ 对总输出方差的比例贡献位于区间 $[0.5111, 0.6889]$ 内。\n\n解释：$F_S$ 的界限为参数子集 $X_S$ 的重要性提供了定量评估。结果表明，$X_S$ 的不确定性导致了至少 $51.11\\%$ 至多 $68.89\\%$ 的总输出方差。这是一个显著的贡献。如果通过验证实验完全确定 $X_S$ 中参数的真实值，模型输出的总方差将减少一个在此范围内的量。这为优先投入进一步的实验和验证资源以减少参数 $X_S$ 的不确定性提供了有力的理由，因为这样做保证能显著降低整体模型的不确定性。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.5111 & 0.6889\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在识别了不确定性的关键来源之后，下一步是设计能够可靠地检测出模型与真实世界数据之间差异的实验。本练习深入探讨了统计功效（statistical power）的概念，即当差异真实存在时，验证检验能够正确识别出该差异的概率。您将通过编程实现一个功效分析 ()，该分析考虑了模拟运行次数和输出数据的时间自相关等因素，使您能够量化地论证为确保验证研究的严谨性并避免计算资源浪费所需的样本量。",
            "id": "4127738",
            "problem": "您的任务是开发一个程序，用于计算在涌现时间序列中检测指定差异的统计功效，并为复杂自适应系统建模下的验证实验论证样本量要求。每次实验运行的涌现观测是一个时间序列 $\\{Y_{r,t}\\}_{t=1}^{T}$，其中 $r \\in \\{1,\\ldots,R\\}$ 是独立运行的索引。假设每个序列由 $Y_{r,t} = \\mu + \\varepsilon_{r,t}$ 生成，其中 $\\{\\varepsilon_{r,t}\\}$ 是一阶平稳高斯自回归过程（AR(1)），其边际标准差为 $\\sigma$，自相关参数为 $\\rho \\in (-1,1)$。验证实验旨在检测参考模型与经验数据之间长期平均水平的差异 $\\delta$，这通过对两种条件下总均值差异的假设检验来形式化。假设两种条件下的运行是独立同分布的，具有相同的 $\\sigma$、$\\rho$ 和 $T$。使用显著性水平为 $\\alpha$ 的双边检验。\n\n从协方差和中心极限定理（CLT）的基本定义出发，将每次运行的时间平均值 $\\bar{Y}_{r} = \\frac{1}{T}\\sum_{t=1}^{T}Y_{r,t}$ 作为单次运行中均值的基本估计量。利用以下事实：对于平稳过程，时间平均值的方差可以通过自协方差函数表示；对于边际方差为 $\\sigma^{2}$、自相关参数为 $\\rho$ 的AR(1)过程，滞后项之间的自协方差满足 $\\operatorname{Cov}(\\varepsilon_{r,t},\\varepsilon_{r,t+k}) = \\sigma^{2}\\rho^{|k|}$。因此，时间平均值的方差必须包含自相关结构。$R$ 次独立运行的总均值为 $\\bar{M} = \\frac{1}{R}\\sum_{r=1}^{R}\\bar{Y}_{r}$。在两种条件的比较下，考虑总均值的差异，并推导在备择假设下（真实均值差异为 $\\delta \\neq 0$）统计功效的表达式。\n\n您的程序必须：\n- 使用协方差求和恒等式，计算AR(1)过程中每次运行时间平均值 $\\bar{Y}_{r}$ 的方差。\n- 利用运行和条件间的独立性，计算两种条件下总均值差异的方差。\n- 对于给定的 $(\\sigma,\\rho,T,R)$ 和指定的差异 $\\delta$，计算在显著性水平 $\\alpha$ 下双边检验的统计功效（以小数形式表示，而非百分比）。\n- 计算在显著性水平 $\\alpha$ 下检测差异 $\\delta$ 时，为达到至少为 $p_{\\star}$ 的目标功效所需的最小独立运行次数（整数）$R_{\\min}$（固定 $T$）。\n\n所有功效值均以小数单位表示（例如，$0.8$），而非百分比。不涉及物理单位，也不涉及角度。\n\n测试套件：\n使用以下参数集，每个参数集表示为 $(\\delta,\\sigma,\\rho,T,R,\\alpha,p_{\\star})$：\n1. $(0.5, 1.0, 0.3, 200, 10, 0.05, 0.8)$\n2. $(0.5, 1.0, 0.8, 10, 10, 0.05, 0.8)$\n3. $(0.1, 1.0, 0.95, 1000, 20, 0.05, 0.9)$\n4. $(0.2, 1.0, 0.0, 100, 5, 0.05, 0.8)$\n5. $(0.01, 1.0, 0.5, 10000, 50, 0.01, 0.9)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个包含两个元素的列表 $[\\text{power}, R_{\\min}]$，其中 $\\text{power}$ 是给定 $R$ 下的浮点数功效值，$R_{\\min}$ 是在相同 $(\\delta,\\sigma,\\rho,T,\\alpha)$ 条件下达到至少 $p_{\\star}$ 功效所需的最小整数运行次数。输出行的格式示例为 $[[0.812345,9],[0.123456,87],\\ldots]$，其中每个功效值四舍五入到六位小数。",
            "solution": "目标是计算用于检测来自复杂自适应系统的时间序列涌现均值中差异的统计功效，并根据独立运行的次数为样本量提供依据。我们从基本原理出发：平稳过程中的协方差定义和中心极限定理（CLT），然后推导运行级别时间平均值的方差，构建两种条件下总均值差异的方差，最后推导出备择假设下的统计功效。\n\n考虑单次运行 $r$，其时间序列为 $Y_{r,t} = \\mu + \\varepsilon_{r,t}$（$t = 1,\\ldots,T$），其中 $\\{\\varepsilon_{r,t}\\}$ 是一个一阶平稳高斯自回归过程（AR(1)），边际方差为 $\\sigma^{2}$，自相关参数为 $\\rho \\in (-1,1)$。每次运行的时间平均值为 $\\bar{Y}_{r} = \\frac{1}{T}\\sum_{t=1}^{T}Y_{r,t}$。由于 $\\varepsilon_{r,t}$ 的均值为零，所以 $\\mathbb{E}[\\bar{Y}_{r}] = \\mu$，且 $\\bar{Y}_{r}$ 的方差取决于自协方差结构。平稳过程的方差恒等式表明\n$$\n\\operatorname{Var}(\\bar{Y}_{r}) \\;=\\; \\operatorname{Var}\\left(\\frac{1}{T}\\sum_{t=1}^{T}Y_{r,t}\\right) \\;=\\; \\frac{1}{T^{2}} \\sum_{i=1}^{T} \\sum_{j=1}^{T} \\operatorname{Cov}(Y_{r,i}, Y_{r,j}).\n$$\n因为 $Y_{r,t}$ 与 $\\varepsilon_{r,t}$ 仅相差一个常数偏移量 $\\mu$，所以协方差完全来自 $\\varepsilon_{r,t}$。对于边际方差为 $\\sigma^{2}$ 的AR(1)过程，滞后 $k$ 阶的自协方差为 $\\operatorname{Cov}(\\varepsilon_{r,t},\\varepsilon_{r,t+k}) = \\sigma^{2}\\rho^{|k|}$。利用协方差的对称性并按滞后进行分组，我们得到\n$$\n\\operatorname{Var}(\\bar{Y}_{r}) \\;=\\; \\frac{1}{T^{2}} \\left( T \\cdot \\sigma^{2} + 2 \\sum_{k=1}^{T-1} (T - k) \\cdot \\sigma^{2} \\rho^{k} \\right)\n\\;=\\; \\frac{\\sigma^{2}}{T}\\left( 1 + 2 \\sum_{k=1}^{T-1}\\left(1 - \\frac{k}{T}\\right)\\rho^{k} \\right).\n$$\n该恒等式显示了相对于独立情况（对应 $\\rho = 0$ 且得出 $\\operatorname{Var}(\\bar{Y}_{r}) = \\sigma^{2}/T$），自相关如何增大了时间平均值的方差。\n\n假设有两个条件，记为 $A$ 和 $B$，每个条件都有 $R$ 次长度为 $T$ 的独立运行，并假设条件 $B$ 的长期均值与条件 $A$ 相差 $\\delta$，即 $\\mu_{B} = \\mu_{A} + \\delta$。在每个条件下，各次运行的总均值为\n$$\n\\bar{M}_{A} = \\frac{1}{R}\\sum_{r=1}^{R}\\bar{Y}^{(A)}_{r}, \\qquad \\bar{M}_{B} = \\frac{1}{R}\\sum_{r=1}^{R}\\bar{Y}^{(B)}_{r}.\n$$\n根据运行的独立性，当两个条件共享相同的 $\\sigma$、$\\rho$ 和 $T$ 时，$\\operatorname{Var}(\\bar{M}_{A}) = \\operatorname{Var}(\\bar{Y}_{r})/R$ 且 $\\operatorname{Var}(\\bar{M}_{B}) = \\operatorname{Var}(\\bar{Y}_{r})/R$。总均值的差异 $\\hat{\\Delta} = \\bar{M}_{B} - \\bar{M}_{A}$ 的方差为\n$$\n\\operatorname{Var}(\\hat{\\Delta}) \\;=\\; \\operatorname{Var}(\\bar{M}_{B}) + \\operatorname{Var}(\\bar{M}_{A})\n\\;=\\; \\frac{2}{R}\\operatorname{Var}(\\bar{Y}_{r})\n\\;=\\; \\frac{2\\sigma^{2}}{R T}\\left( 1 + 2 \\sum_{k=1}^{T-1}\\left(1 - \\frac{k}{T}\\right)\\rho^{k} \\right).\n$$\n在真实均值差异为 $\\delta \\neq 0$ 的备择假设下，根据适用于跨独立运行的弱相关序列平均值的中心极限定理（CLT），基于 $\\hat{\\Delta}$ 及其标准差的标准化统计量近似服从正态分布。将标准差记为\n$$\ns_{\\Delta} \\;=\\; \\sqrt{\\operatorname{Var}(\\hat{\\Delta})},\n$$\n非中心参数记为\n$$\n\\lambda \\;=\\; \\frac{|\\delta|}{s_{\\Delta}}.\n$$\n使用显著性水平为 $\\alpha$ 的双边检验，标准正态检验的临界值为 $z_{1-\\alpha/2}$（标准正态分布的 $(1-\\alpha/2)$-分位数）。在备择假设下，标准化统计量 $Z$ 近似服从 $\\mathcal{N}(\\lambda,1)$，因此统计功效（在备择假设下拒绝原假设的概率）为\n$$\n\\text{Power} \\;=\\; \\mathbb{P}\\left(|Z| > z_{1-\\alpha/2}\\right)\n\\;=\\; \\Phi\\left(-z_{1-\\alpha/2} - \\lambda\\right) + \\left(1 - \\Phi\\left(z_{1-\\alpha/2} - \\lambda\\right)\\right),\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。此形式直接源于双边拒绝域的定义以及 $Z$ 在备择假设下的分布。\n\n为了根据独立运行次数来论证样本量，注意到 $s_{\\Delta}$ 随 $R$ 单调递减（具体地，像 $R^{-1/2}$），因此功效随 $R$ 单调递增。因此，对于固定的 $(\\delta,\\sigma,\\rho,T,\\alpha)$ 和目标功效 $p_{\\star}$，存在一个最小整数 $R_{\\min}$，使得在 $R_{\\min}$ 处计算的功效至少为 $p_{\\star}$。我们通过以下方式高效计算 $R_{\\min}$：\n- 在 $R = 1$ 处评估功效，然后将 $R$ 加倍，直到功效超过 $p_{\\star}$ 或达到预设的大值上限（指数搜索以找到包含解的区间）。\n- 在找到的区间上执行二分搜索，以找到使功效至少为 $p_{\\star}$ 的最小整数 $R$。\n\n程序中实现的算法步骤：\n1. 使用AR(1)协方差求和公式计算 $\\operatorname{Var}(\\bar{Y}_{r})$：\n   $$\n   \\operatorname{Var}(\\bar{Y}_{r}) \\;=\\; \\frac{\\sigma^{2}}{T}\\left( 1 + 2 \\sum_{k=1}^{T-1}\\left(1 - \\frac{k}{T}\\right)\\rho^{k} \\right).\n   $$\n2. 计算 $\\operatorname{Var}(\\hat{\\Delta}) = \\frac{2}{R}\\operatorname{Var}(\\bar{Y}_{r})$ 和 $s_{\\Delta} = \\sqrt{\\operatorname{Var}(\\hat{\\Delta})}$。\n3. 计算 $\\lambda = \\frac{|\\delta|}{s_{\\Delta}}$ 和 $z_{1-\\alpha/2}$，然后通过以下公式评估功效：\n   $$\n   \\text{Power} \\;=\\; \\Phi\\left(-z_{1-\\alpha/2} - \\lambda\\right) + \\left(1 - \\Phi\\left(z_{1-\\alpha/2} - \\lambda\\right)\\right).\n   $$\n4. 对每个测试用例，计算给定 $R$ 下的功效，并按所述通过指数搜索和二分搜索计算 $R_{\\min}$。功效随 $R$ 的单调性保证了算法的正确性。\n5. 在单行上输出所有测试用例的结果列表 $[\\text{power}, R_{\\min}]$，每个功效值四舍五入到六位小数。\n\n该程序基于平稳高斯AR(1)过程的标准性质、基于协方差的时间平均值方差公式以及中心极限定理（CLT），从而产生科学上可靠且数值稳定的计算结果，适用于复杂自适应系统中的模型验证和确认。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef var_mean_ar1(T: int, rho: float, sigma: float) -> float:\n    \"\"\"\n    Compute Var(bar{Y}_r) for an AR(1) process with marginal std sigma and autocorrelation rho.\n    Var(bar{Y}_r) = (sigma^2 / T) * [1 + 2 * sum_{k=1}^{T-1} (1 - k/T) * rho^k]\n    \"\"\"\n    if T == 0:\n        raise ValueError(\"T must be a positive integer\")\n    if abs(rho) >= 1.0:\n        raise ValueError(\"rho must be in (-1,1) for stationarity\")\n    # Sum the weighted autocorrelation terms\n    if T == 1:\n        # No autocovariance terms when only one observation\n        return (sigma ** 2) / T\n    k = np.arange(1, T, dtype=np.float64)\n    weights = 1.0 - k / T\n    # Use power with float for stability\n    rho_powers = rho ** k\n    s = np.sum(weights * rho_powers)\n    return (sigma ** 2 / T) * (1.0 + 2.0 * s)\n\ndef two_sided_power(delta: float, sigma: float, rho: float, T: int, R: int, alpha: float) -> float:\n    \"\"\"\n    Compute the two-sided normal-approx power at significance alpha for discrepancy delta,\n    given AR(1) parameters (sigma, rho), time length T, and number of runs R.\n    \"\"\"\n    vmean = var_mean_ar1(T, rho, sigma)\n    vdiff = 2.0 * vmean / float(R)\n    sd = np.sqrt(vdiff)\n    lam = abs(delta) / sd if sd > 0 else np.inf\n    z = norm.ppf(1.0 - alpha / 2.0)\n    # Power = P(|Z| > z) with Z ~ N(lam, 1)\n    power = norm.cdf(-z - lam) + (1.0 - norm.cdf(z - lam))\n    return float(power)\n\ndef minimal_R_for_power(delta: float, sigma: float, rho: float, T: int, alpha: float, target_power: float,\n                        Rmax: int = 1_000_000) -> int:\n    \"\"\"\n    Find the minimal integer R such that two_sided_power(...) >= target_power,\n    using exponential search to bracket and then binary search to refine.\n    \"\"\"\n    # Handle degenerate case: if delta is zero, power equals alpha; require Rmin as 1 if target = alpha else Rmax\n    # However, we follow the general algorithm; as R grows, lam grows ~ sqrt(R), power increases.\n    # Exponential search to find an upper bound where power >= target_power.\n    upper = 1\n    p_upper = two_sided_power(delta, sigma, rho, T, upper, alpha)\n    if p_upper >= target_power:\n        return upper\n    while p_upper  target_power and upper  Rmax:\n        upper *= 2\n        p_upper = two_sided_power(delta, sigma, rho, T, upper, alpha)\n    if p_upper  target_power and upper = Rmax:\n        # Could not achieve target within Rmax; return Rmax as a conservative cap.\n        return Rmax\n    lower = upper // 2\n    if lower  1:\n        lower = 1\n    # Binary search for minimal R in [lower, upper]\n    rmin = upper\n    while lower = upper:\n        mid = (lower + upper) // 2\n        if mid == 0: # Avoid R=0\n            lower = 1\n            continue\n        p_mid = two_sided_power(delta, sigma, rho, T, mid, alpha)\n        if p_mid = target_power:\n            rmin = mid\n            upper = mid - 1\n        else:\n            lower = mid + 1\n    return int(rmin)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is (delta, sigma, rho, T, R, alpha, p_star)\n    test_cases = [\n        (0.5, 1.0, 0.3, 200, 10, 0.05, 0.8),\n        (0.5, 1.0, 0.8, 10, 10, 0.05, 0.8),\n        (0.1, 1.0, 0.95, 1000, 20, 0.05, 0.9),\n        (0.2, 1.0, 0.0, 100, 5, 0.05, 0.8),\n        (0.01, 1.0, 0.5, 10000, 50, 0.01, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta, sigma, rho, T, R, alpha, p_star = case\n        power = two_sided_power(delta, sigma, rho, T, R, alpha)\n        Rmin = minimal_R_for_power(delta, sigma, rho, T, alpha, p_star)\n        results.append((power, Rmin))\n\n    # Format the final result exactly as required: [[power,Rmin],...], with power rounded to 6 decimals.\n    formatted_results = \"[\" + \",\".join(\"[\" + f\"{p:.6f},\" + f\"{r}\" + \"]\" for p, r in results) + \"]\"\n    print(formatted_results)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个真正稳健的模型不仅应能拟合历史数据，还应对其基本假设或参数中的微小不准确性具有弹性。这最后一个练习介绍了一种现代的“压力测试”方法，即对抗性验证（adversarial validation），我们通过故意扰动模型的参数来发现其潜在的弱点。通过构建一个基于主体的模型并对其施加有界对抗性扰动 ()，您将获得评估模型稳健性的实践经验，从简单的点估计验证提升到确保模型结论的稳定性和可信度。",
            "id": "4127794",
            "problem": "您的任务是设计并实现一个严格的验证程序，用于验证一个简单但非平凡的基于主体的模型（Agent-Based Model, ABM），该模型需在主体决策规则受到对抗性扰动的情况下进行验证。此外，您还需要计算关键可观测量对由适当范数量化的有界扰动的敏感度。该 ABM 包含 $N$ 个主体，其连续动作状态为 $a_i^{(t)} \\in [0,1]$，在离散时间步 $t \\in \\{0,1,\\dots,T\\}$ 上演化。每个主体 $i$ 拥有一个固定的特征 $x_i \\in \\mathbb{R}$，该特征独立地从标准正态分布中抽取。决策规则是一个确定性的平均场更新：在每个时间步，所有主体根据以下公式同步更新：\n$$\na_i^{(t+1)} \\;=\\; \\sigma\\!\\left(\\theta_0 + \\theta_1 \\cdot m^{(t)} + \\theta_2 \\cdot x_i\\right),\n$$\n其中 $\\sigma(z) = \\frac{1}{1+e^{-z}}$ 是 logistic 函数，$\\theta = (\\theta_0,\\theta_1,\\theta_2) \\in \\mathbb{R}^3$ 是待验证的规则参数，而 $m^{(t)} = \\frac{1}{N}\\sum_{j=1}^N a_j^{(t)}$ 是在时间 $t$ 的种群平均值。所有主体的初始动作均设置为 $a_i^{(0)} = 0.5$，因此 $m^{(0)} = 0.5$。固定一个随机种子以确保特征抽取的复现性。\n\n定义两个待验证的可观测量：\n- 最终平均动作，\n$$\nO_1(\\theta) \\;=\\; m^{(T)}(\\theta).\n$$\n- 动作的时间平均横截面方差，\n$$\nO_2(\\theta) \\;=\\; \n\\begin{cases}\n\\frac{1}{T}\\sum_{t=1}^{T} \\mathrm{Var}\\!\\left(a^{(t)}(\\theta)\\right),  \\text{if } T  0,\\\\\n0.0,  \\text{if } T = 0,\n\\end{cases}\n$$\n其中 $\\mathrm{Var}(a^{(t)}(\\theta)) = \\frac{1}{N}\\sum_{i=1}^N \\left(a_i^{(t)}(\\theta) - m^{(t)}(\\theta)\\right)^2$。\n\n您必须实现对规则参数 $\\theta$ 的对抗性扰动下的验证，其中扰动在 $L_\\infty$ 范数下有界。具体来说，设 $\\delta \\in \\mathbb{R}^3$ 表示一个扰动向量，并施加边界 $\\|\\delta\\|_\\infty \\le \\varepsilon$，其中 $\\varepsilon  0$ 是给定的。请遵循以下要求：\n\n1. 模型模拟：实现一个用于 ABM 的确定性模拟器，在给定 $(N,T,\\theta,\\text{seed})$ 的情况下，返回如上定义的 $O_1(\\theta)$ 和 $O_2(\\theta)$ 的值。特征 $x_i$ 必须使用指定的随机种子从标准正态分布中独立抽取，并且所有初始动作必须为 $0.5$。\n\n2. 敏感度计算：在给定的基准 $\\theta$ 下，对 $\\theta$ 的每个坐标使用一个小的对称步长 $h$，通过中心有限差分格式数值估计梯度 $\\nabla O_k(\\theta)$ (对于 $k \\in \\{1,2\\}$)。然后，使用适当的对偶范数推理，计算在所有满足 $\\|\\delta\\|_\\infty \\le \\varepsilon$ 的扰动下 $O_k$ 的最坏情况一阶变化的上界。报告这两个敏感度上界。\n\n3. 对抗性验证：计算在一系列扰动下 $O_1$ 和 $O_2$ 的实际最坏情况变化，这些扰动是超立方体 $\\{-\\varepsilon,+\\varepsilon\\}^3$ 的顶点，即所有分量等于 $-\\varepsilon$ 或 $+\\varepsilon$ 的 $\\delta$。对于每个可观测量 $O_k$，报告最大绝对变化 $\\max_{\\delta \\in \\{-\\varepsilon,+\\varepsilon\\}^3} \\left|O_k(\\theta+\\delta) - O_k(\\theta)\\right|$。\n\n4. 验证决策：给定容差 $\\tau_1  0$ 和 $\\tau_2  0$，如果以下两个不等式都成立，则声明模型通过验证：\n$$\n\\max_{\\delta \\in \\{-\\varepsilon,+\\varepsilon\\}^3} \\left|O_1(\\theta+\\delta) - O_1(\\theta)\\right| \\le \\tau_1,\n\\qquad\n\\max_{\\delta \\in \\{-\\varepsilon,+\\varepsilon\\}^3} \\left|O_2(\\theta+\\delta) - O_2(\\theta)\\right| \\le \\tau_2.\n$$\n返回一个布尔值，指示通过或失败。\n\n您的程序必须实现上述逻辑，并将其应用于以下测试套件。对于每个测试用例，参数以 $(N,T,\\theta_0,\\theta_1,\\theta_2,\\varepsilon,\\tau_1,\\tau_2,\\text{seed})$ 的形式给出：\n\n- 测试用例 1：$(N=\\;500,\\;T=\\;50,\\;\\theta_0=\\;0.2,\\;\\theta_1=\\;1.1,\\;\\theta_2=\\;0.7,\\;\\varepsilon=\\;0.05,\\;\\tau_1=\\;0.03,\\;\\tau_2=\\;0.02,\\;\\text{seed}=\\;42)$。\n- 测试用例 2：$(N=\\;600,\\;T=\\;20,\\;\\theta_0=\\;-0.1,\\;\\theta_1=\\;0.9,\\;\\theta_2=\\;0.3,\\;\\varepsilon=\\;0.0,\\;\\tau_1=\\;0.0,\\;\\tau_2=\\;0.0,\\;\\text{seed}=\\;123)$。\n- 测试用例 3：$(N=\\;1000,\\;T=\\;100,\\;\\theta_0=\\;0.0,\\;\\theta_1=\\;1.5,\\;\\theta_2=\\;0.5,\\;\\varepsilon=\\;0.5,\\;\\tau_1=\\;0.05,\\;\\tau_2=\\;0.05,\\;\\text{seed}=\\;7)$。\n- 测试用例 4：$(N=\\;300,\\;T=\\;0,\\;\\theta_0=\\;0.4,\\;\\theta_1=\\;1.2,\\;\\theta_2=\\;-0.6,\\;\\varepsilon=\\;0.2,\\;\\tau_1=\\;10^{-6},\\;\\tau_2=\\;10^{-6},\\;\\text{seed}=\\;2025)$。\n- 测试用例 5：$(N=\\;10,\\;T=\\;10,\\;\\theta_0=\\;-0.5,\\;\\theta_1=\\;0.8,\\;\\theta_2=\\;1.1,\\;\\varepsilon=\\;0.01,\\;\\tau_1=\\;0.005,\\;\\tau_2=\\;0.005,\\;\\text{seed}=\\;999)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。列表中的每个元素对应一个测试用例，并且其本身必须是一个包含五个条目的列表：\n$[S_1^{\\text{bound}}, S_1^{\\text{corner}}, S_2^{\\text{bound}}, S_2^{\\text{corner}}, \\text{pass}]$,\n其中 $S_k^{\\text{bound}}$ 是 $O_k$ 的敏感度上界，$S_k^{\\text{corner}}$ 是观测到的 $O_k$ 的最坏情况顶点变化，而 $\\text{pass}$ 是一个布尔值。例如，最终输出行应如下所示\n$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$\n其中包含正好五个内部列表，每个测试用例一个。不应打印任何其他文本。",
            "solution": "问题陈述已经过评估，并被确定为 **有效**。它具有科学依据、问题定义明确、客观且内部一致。它在复杂自适应系统模型验证领域提出了一个清晰、可形式化的任务。唯一的小歧义是有限差分计算中未指定步长 $h$，这是一个标准的实现细节。为此将使用一个合理的值 $h=10^{-6}$。\n\n解决方案通过实现问题陈述中指定的四个要求来推进。这包括创建基于主体的模型（ABM）的确定性模拟，使用此模拟来计算两个关键可观测量对参数扰动的敏感度，并根据观测到的变化与给定容差的对比做出验证决策。\n\n### 1. 模型模拟\n\n首先，设计一个函数来模拟 ABM 动态。该函数接受主体数量 $N$、时间步数 $T$、参数向量 $\\theta = (\\theta_0, \\theta_1, \\theta_2)$ 和一个随机种子。\n\n- **初始化**：使用提供的种子初始化一个伪随机数生成器以确保可复现性。为 $N$ 个主体中的每一个独立地从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取固定特征 $x_i$。所有主体的初始动作状态均设置为 $a_i^{(0)} = 0.5$。\n\n- **时间演化**：模拟从 $t=0$ 到 $T-1$ 进行迭代。在每一步中，它对所有主体执行同步更新。\n    1.  计算种群平均动作 $m^{(t)} = \\frac{1}{N}\\sum_{j=1}^N a_j^{(t)}$。\n    2.  根据确定性更新规则计算每个主体 $i$ 在下一个时间步的动作状态 $a_i^{(t+1)}$：\n        $$\n        a_i^{(t+1)} = \\sigma(\\theta_0 + \\theta_1 \\cdot m^{(t)} + \\theta_2 \\cdot x_i)\n        $$\n        其中 $\\sigma(z) = \\frac{1}{1+e^{-z}}$ 是 logistic sigmoid 函数。\n    3.  计算并存储新计算出的动作的横截面方差 $\\mathrm{Var}(a^{(t+1)}(\\theta)) = \\frac{1}{N}\\sum_{i=1}^N (a_i^{(t+1)} - m^{(t+1)})^2$。请注意，$m^{(t+1)} = \\frac{1}{N}\\sum_{j=1}^N a_j^{(t+1)}$。\n\n- **可观测量计算**：在最后一个时间步 $T$ 之后，计算两个可观测量。\n    -   $O_1(\\theta) = m^{(T)}(\\theta)$，即在最后一个时间步 $T$ 的主体动作的平均值。\n    -   $O_2(\\theta) = \\frac{1}{T}\\sum_{t=1}^{T} \\mathrm{Var}(a^{(t)}(\\theta))$，即从步 $t=1$到$t=T$计算的横截面方差的时间平均值。\n    \n- **边界情况**：需要对 $T=0$ 进行特殊处理。在这种情况下，模拟循环不运行。最终状态即初始状态，因此 $O_1(\\theta) = m^{(0)} = 0.5$。根据定义，$O_2(\\theta) = 0.0$。当 $T=0$ 时，两个可观测量都是常数且与 $\\theta$ 无关。\n\n模拟逻辑被封装在一个函数 `run_simulation(N, T, theta, seed)` 中，该函数返回元组 $(O_1(\\theta), O_2(\\theta))$。\n\n### 2. 敏感度上界 ($S_k^{\\text{bound}}$)\n\n可观测量 $O_k$ 对 $\\theta$ 中小扰动的敏感度通过一阶泰勒展开进行分析：$\\Delta O_k \\approx \\nabla O_k(\\theta) \\cdot \\delta$，其中 $\\delta$ 是扰动向量。\n\n- **梯度估计**：对于每个可观测量 $k \\in \\{1, 2\\}$，使用中心有限差分法数值估计梯度 $\\nabla O_k(\\theta) \\in \\mathbb{R}^3$。关于每个参数分量 $\\theta_j$（对于 $j \\in \\{0, 1, 2\\}$）的偏导数近似为：\n    $$\n    \\frac{\\partial O_k}{\\partial \\theta_j} \\approx \\frac{O_k(\\theta + h \\cdot e_j) - O_k(\\theta - h \\cdot e_j)}{2h}\n    $$\n    其中 $e_j$ 是 $\\mathbb{R}^3$ 中的第 $j$ 个标准基向量，$h$ 是一个小的步长，选择为 $h=10^{-6}$。对于每对可观测量，这需要 $2 \\times 3 = 6$ 次调用模拟函数。\n\n- **边界计算**：我们需要为所有满足约束 $\\|\\delta\\|_\\infty \\le \\varepsilon$ 的扰动 $\\delta$ 找到变化量 $|\\Delta O_k|$ 的上界。在此约束下，$|\\nabla O_k(\\theta) \\cdot \\delta|$ 的最大值由 $\\varepsilon$ 和梯度的对偶范数的乘积给出。$L_\\infty$ 范数的对偶范数是 $L_1$ 范数。因此，敏感度上界为：\n    $$\n    S_k^{\\text{bound}} = \\max_{\\|\\delta\\|_\\infty \\le \\varepsilon} |\\nabla O_k(\\theta) \\cdot \\delta| = \\varepsilon \\cdot \\|\\nabla O_k(\\theta)\\|_1\n    $$\n    其中 $\\|\\vec{v}\\|_1 = \\sum_j |v_j|$。\n\n### 3. 对抗性顶点验证 ($S_k^{\\text{corner}}$)\n\n此步骤通过测试一个特定的、有限的对抗性扰动集来计算可观测量中的真实最大变化。该扰动集由 $L_\\infty$ 范数定义的超立方体的顶点组成，即 $\\delta \\in \\{-\\varepsilon, +\\varepsilon\\}^3$。这对应于 $2^3=8$ 种扰动，其中每个分量 $\\delta_j$ 要么是 $-\\varepsilon$，要么是 $+\\varepsilon$。\n\n其流程如下：\n1.  计算基准可观测量 $O_k(\\theta)$。\n2.  对于 8 个顶点扰动向量 $\\delta$ 中的每一个，计算受扰动的可观测量 $O_k(\\theta + \\delta)$。\n3.  每个可观测量 $O_k$ 的最坏情况顶点变化是找到的最大绝对差值：\n    $$\n    S_k^{\\text{corner}} = \\max_{\\delta \\in \\{-\\varepsilon, +\\varepsilon\\}^3} \\left|O_k(\\theta+\\delta) - O_k(\\theta)\\right|\n    $$\n\n这需要额外调用 8 次模拟函数。如果 $\\varepsilon=0$，则存在一个特殊情况，此时唯一的扰动是 $\\delta = (0, 0, 0)$，导致 $S_k^{\\text{corner}}=0$。\n\n### 4. 验证决策\n\n最后一步是做出二元验证决策。当且仅当两个可观测量的经验观测最坏情况变化都在其各自指定的容差 $\\tau_1$ 和 $\\tau_2$ 之内时，模型才被声明为通过验证。\n$$\n\\text{pass} = \\begin{cases} \\text{True},  \\text{if } S_1^{\\text{corner}} \\le \\tau_1 \\text{ and } S_2^{\\text{corner}} \\le \\tau_2 \\\\ \\text{False},  \\text{otherwise} \\end{cases}\n$$\n最终算法遍历每个测试用例，执行这四个步骤，并将五个结果值——$S_1^{\\text{bound}}$, $S_1^{\\text{corner}}$, $S_2^{\\text{bound}}$, $S_2^{\\text{corner}}$ 和布尔值 'pass'——编译成每个用例的一个列表。这些列表的集合构成了最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import expit  # Numerically stable logistic function\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Solves the ABM validation problem for all test cases.\n    \"\"\"\n    \n    # Test cases parameters:\n    # (N, T, theta_0, theta_1, theta_2, epsilon, tau_1, tau_2, seed)\n    test_cases = [\n        (500, 50, 0.2, 1.1, 0.7, 0.05, 0.03, 0.02, 42),\n        (600, 20, -0.1, 0.9, 0.3, 0.0, 0.0, 0.0, 123),\n        (1000, 100, 0.0, 1.5, 0.5, 0.5, 0.05, 0.05, 7),\n        (300, 0, 0.4, 1.2, -0.6, 0.2, 1e-6, 1e-6, 2025),\n        (10, 10, -0.5, 0.8, 1.1, 0.01, 0.005, 0.005, 999),\n    ]\n\n    h = 1e-6 # Step size for central finite difference\n\n    # Cache to avoid re-running simulations with identical parameters\n    simulation_cache = {}\n\n    def run_simulation(N, T, theta_tuple, seed):\n        \"\"\"\n        Runs the ABM simulation for a given set of parameters.\n        \"\"\"\n        # Create a tuple key for caching\n        cache_key = (N, T, theta_tuple, seed)\n        if cache_key in simulation_cache:\n            return simulation_cache[cache_key]\n\n        theta = np.array(theta_tuple)\n        \n        # Handle T=0 edge case\n        if T == 0:\n            o1_final_mean = 0.5\n            o2_avg_var = 0.0\n            simulation_cache[cache_key] = (o1_final_mean, o2_avg_var)\n            return o1_final_mean, o2_avg_var\n\n        # Initialization\n        rng = np.random.default_rng(seed)\n        traits_x = rng.standard_normal(N)\n        actions = np.full(N, 0.5)\n        \n        # Time evolution\n        variances = []\n        for _ in range(T):\n            mean_action = np.mean(actions)\n            z = theta[0] + theta[1] * mean_action + theta[2] * traits_x\n            actions = expit(z)\n            variances.append(np.var(actions))\n\n        # Calculate final observables\n        o1_final_mean = np.mean(actions)\n        o2_avg_var = np.mean(variances)\n        \n        simulation_cache[cache_key] = (o1_final_mean, o2_avg_var)\n        return o1_final_mean, o2_avg_var\n\n    results = []\n    for case in test_cases:\n        N, T, theta0, theta1, theta2, epsilon, tau1, tau2, seed = case\n        theta_base = np.array([theta0, theta1, theta2])\n\n        # Shortcut for T=0: observables are constant, so all changes are 0.\n        if T == 0:\n            s1_bound, s1_corner = 0.0, 0.0\n            s2_bound, s2_corner = 0.0, 0.0\n            passed = (s1_corner = tau1) and (s2_corner = tau2)\n            results.append([s1_bound, s1_corner, s2_bound, s2_corner, passed])\n            continue\n\n        # Shortcut for epsilon=0: no perturbation, so all changes are 0.\n        if epsilon == 0.0:\n            s1_bound, s1_corner = 0.0, 0.0\n            s2_bound, s2_corner = 0.0, 0.0\n            passed = (s1_corner = tau1) and (s2_corner = tau2)\n            results.append([s1_bound, s1_corner, s2_bound, s2_corner, passed])\n            continue\n            \n        # 1. Baseline calculation\n        o1_base, o2_base = run_simulation(N, T, tuple(theta_base), seed)\n\n        # 2. Sensitivity computation (gradient and bounds)\n        grad_o1 = np.zeros(3)\n        grad_o2 = np.zeros(3)\n        for i in range(3):\n            theta_plus = theta_base.copy()\n            theta_plus[i] += h\n            theta_minus = theta_base.copy()\n            theta_minus[i] -= h\n            \n            o1_plus, o2_plus = run_simulation(N, T, tuple(theta_plus), seed)\n            o1_minus, o2_minus = run_simulation(N, T, tuple(theta_minus), seed)\n            \n            grad_o1[i] = (o1_plus - o1_minus) / (2 * h)\n            grad_o2[i] = (o2_plus - o2_minus) / (2 * h)\n        \n        s1_bound = epsilon * np.linalg.norm(grad_o1, ord=1)\n        s2_bound = epsilon * np.linalg.norm(grad_o2, ord=1)\n\n        # 3. Adversarial validation (corner check)\n        max_abs_delta_o1 = 0.0\n        max_abs_delta_o2 = 0.0\n        \n        # Generate 2^3=8 corners of the perturbation hypercube\n        for signs in product([-1, 1], repeat=3):\n            delta = epsilon * np.array(signs)\n            theta_perturbed = theta_base + delta\n            \n            o1_pert, o2_pert = run_simulation(N, T, tuple(theta_perturbed), seed)\n            \n            max_abs_delta_o1 = max(max_abs_delta_o1, abs(o1_pert - o1_base))\n            max_abs_delta_o2 = max(max_abs_delta_o2, abs(o2_pert - o2_base))\n            \n        s1_corner = max_abs_delta_o1\n        s2_corner = max_abs_delta_o2\n        \n        # 4. Validation decision\n        passed = (s1_corner = tau1) and (s2_corner = tau2)\n        \n        results.append([s1_bound, s1_corner, s2_bound, s2_corner, passed])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}