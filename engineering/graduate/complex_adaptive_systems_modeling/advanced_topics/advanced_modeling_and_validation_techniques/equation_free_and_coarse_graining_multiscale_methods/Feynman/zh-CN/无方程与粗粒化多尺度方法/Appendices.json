{
    "hands_on_practices": [
        {
            "introduction": "任何多尺度方法的核心都在于建立微观和宏观尺度之间的信息桥梁。本练习将让你亲手构建这一桥梁的两个基本组成部分：限制算子（restriction operator）和提升算子（lifting operator）。你将通过对一个空间扩展系统实施这些算子，来深入理解限制算子如何从微观细节中提炼出宏观变量，以及提升算子如何从宏观数据中重构出合理的微观状态 。此练习中的具体方法——用于限制的块平均法和用于提升的约束插值法——是该领域中强大且常用的技术。",
            "id": "4121742",
            "problem": "考虑一个一维周期性晶格，其上有 $N$ 个格点，索引为 $j \\in \\{0,1,\\ldots,N-1\\}$，晶格间距设为无量纲值。设一个微观场由向量 $u \\in \\mathbb{R}^N$ 表示，其中 $u_j$ 表示格点 $j$ 处的场。一个粗粒化划分将晶格划分为 $K$ 个大小均匀的连续、不重叠的块，因此 $N = K m$，第 $i$ 个块为 $B_i = \\{i m, i m + 1, \\ldots, (i+1)m - 1\\}$，并理解为周期性索引，即模 $N$。\n\n限制（Restriction）通过块平均来定义：粗粒化变量向量 $\\bar{u} \\in \\mathbb{R}^K$ 的分量为\n$$\n\\bar{u}_i = \\frac{1}{m} \\sum_{j \\in B_i} u_j, \\quad i = 0,1,\\ldots,K-1.\n$$\n提升（Lifting）被定义为一个约束插值问题的解：给定目标块平均值 $\\bar{u} \\in \\mathbb{R}^K$，重构一个细粒度场 $u \\in \\mathbb{R}^N$，使其在满足粗粒化约束的条件下，最小化一个光滑性泛函。设离散二阶差分算子（环上的离散拉普拉斯算子）的作用方式为\n$$\n(\\Delta u)_j = u_{j+1} - 2 u_j + u_{j-1}, \\quad j \\in \\{0,1,\\ldots,N-1\\},\n$$\n其中周期性边界条件为 $u_{-1} = u_{N-1}$ 和 $u_N = u_0$。提升 $u^\\star$ 是曲率能量\n$$\nE(u) = \\sum_{j=0}^{N-1} \\left((\\Delta u)_j\\right)^2\n$$\n在块平均约束\n$$\n\\sum_{j \\in B_i} u_j = m \\, \\bar{u}_i, \\quad i = 0,1,\\ldots,K-1\n$$\n条件下的极小值点。\n三角函数内的角度必须解释为弧度。\n\n您的任务是：\n- 通过上述定义的块平均实现限制算子。\n- 通过求解约束插值问题来实现提升算子：在所有满足给定块平均约束的 $u \\in \\mathbb{R}^N$ 中，选择使 $E(u)$ 最小化的那一个。\n- 通过计算提升后的 $u^\\star$ 的粗粒化平均值并将其与给定的 $\\bar{u}$进行比较，来验证提升的一致性。使用块上的最大绝对偏差作为一致性度量。\n- 对于每个测试用例，报告一个布尔值，指示一致性度量是否超过规定的容差，最大绝对偏差本身，以及曲率能量 $E(u^\\star)$。\n\n使用的基本依据：\n- 如上所述的通过块平均进行限制和通过约束插值进行提升的定义。\n- 如上所述的周期性离散二阶差分算子。\n- 线性等式约束下的约束最小化原理，以及能量最小解在去除了由约束消除的零空间模态后存在且唯一。\n\n数值与算法要求：\n- 对索引进行模 $N$ 处理以强制周期性。\n- 确保 $N$ 和 $m$ 满足 $N = K m$，其中 $K$ 为整数。\n- 对一致性布尔值使用固定的容差 $\\varepsilon = 10^{-10}$。\n- 三角测试场内的角度以弧度为单位。\n- 不涉及物理单位；所有量均为无量纲。\n\n测试套件：\n- 情况 A：$N = 128$，$m = 8$，$u_j = \\sin\\!\\left(2\\pi \\cdot 3 \\cdot \\frac{j}{N}\\right) + 0.25 \\cos\\!\\left(2\\pi \\cdot 7 \\cdot \\frac{j}{N}\\right) + 0.05 \\frac{j}{N}$。\n- 情况 B：$N = 64$，$m = 1$，$u_j = \\sin\\!\\left(2\\pi \\cdot 5 \\cdot \\frac{j}{N}\\right)$。\n- 情况 C：$N = 96$，$m = 24$，$u_j = \\sin\\!\\left(2\\pi \\cdot 10 \\cdot \\frac{j}{N}\\right) + 0.1 \\cos\\!\\left(2\\pi \\cdot 12 \\cdot \\frac{j}{N}\\right)$。\n- 情况 D：$N = 72$，$m = 9$，$u_j$ 是分段常数：$u_j = 1$ 对于 $0 \\le j  N/3$，$u_j = -0.5$ 对于 $N/3 \\le j  2N/3$，$u_j = 0$ 对于 $2N/3 \\le j  N$。\n\n对于每种情况，通过对指定的 $u$ 应用限制来计算 $\\bar{u}$，执行提升以获得与 $\\bar{u}$ 一致的 $u^\\star$，然后计算：\n- 布尔值 $b$，指示是否 $\\max_i \\left| \\bar{u}^\\star_i - \\bar{u}_i \\right| \\le \\varepsilon$，其中 $\\bar{u}^\\star$ 表示 $u^\\star$ 的限制，且 $\\varepsilon = 10^{-10}$。\n- 最大绝对偏差 $d = \\max_i \\left| \\bar{u}^\\star_i - \\bar{u}_i \\right|$。\n- 所定义的曲率能量 $E(u^\\star)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[b, d, E]$ 形式的列表。因此，最后一行必须看起来像 $[\\,[b_A, d_A, E_A], [b_B, d_B, E_B], [b_C, d_C, E_C], [b_D, d_D, E_D]\\,]$，并替换为指定的值。",
            "solution": "用户提出了一个来自多尺度建模领域的有效问题，具体涉及无方程方法和粗粒化方法。任务是实现并测试一对算子：一个用于粗化细尺度场的**限制（restriction）**算子，以及一个用于从粗粒化数据重构细尺度场的**提升（lifting）**算子。\n\n该问题是一个适定的约束优化问题。核心任务是找到一个细粒度场 $u^\\star \\in \\mathbb{R}^N$，它在满足一组由给定块平均值施加的线性约束的同时，最小化一个“曲率能量”泛函 $E(u)$。这种方法在各种科学计算环境中，用于耦合不同尺度的模型，是一种标准方法。\n\n在此，我将详细阐述解决该问题的数学公式化和后续的算法途径。\n\n### 1. 数学公式化\n\n设微观场为一个向量 $u \\in \\mathbb{R}^N$。问题要求解以下约束最小化问题：\n$$\n\\text{最小化} \\quad E(u) = \\sum_{j=0}^{N-1} \\left((\\Delta u)_j\\right)^2 \\quad \\text{约束条件为} \\quad \\sum_{j \\in B_i} u_j = m \\bar{u}_i, \\quad \\text{对 } i=0, \\ldots, K-1.\n$$\n这里，$\\Delta$ 是离散周期拉普拉斯算子，$B_i$ 是粗粒化块。\n\n这个问题可以用矩阵向量表示法优雅地表达。\n目标函数是一个二次型：\n$$\nE(u) = \\|L u\\|_2^2 = u^T L^T L u\n$$\n其中 $L$ 是代表离散周期拉普拉斯算子 $\\Delta$ 的 $N \\times N$ 矩阵。对于一维周期晶格，这是一个对称循环矩阵，主对角线上为-2，相邻的两条对角线上为1（由于周期性，角点处也为1）。由于 $L$ 是对称的，$L^T=L$，目标函数变为 $u^T L^2 u$。矩阵 $L^2$ 代表离散双调和算子 $\\Delta^2$。\n\n约束是一组 $K$ 个线性方程。我们可以定义一个 $K \\times N$ 的“求和”矩阵 $C$，其中如果格点 $j$ 在块 $B_i$ 中，则 $C_{ij} = 1$，否则 $C_{ij}=0$。约束则由以下系统给出：\n$$\nC u = m \\bar{u}\n$$\n其中 $\\bar{u} \\in \\mathbb{R}^K$ 是给定的粗粒化平均值向量。\n\n### 2. 拉格朗日乘子法\n\n这个约束二次规划问题可以用拉格朗日乘子法解决。我们引入一个拉格朗日乘子向量 $\\lambda \\in \\mathbb{R}^K$，并构造拉格朗日函数：\n$$\n\\mathcal{L}(u, \\lambda) = u^T L^2 u - \\lambda^T (C u - m \\bar{u})\n$$\n为求最小值，我们通过将 $\\mathcal{L}$ 对 $u$ 和 $\\lambda$ 的梯度设为零来寻找其驻点。\n\n对 $u$ 的梯度是：\n$$\n\\nabla_u \\mathcal{L} = 2 L^2 u - C^T \\lambda = 0\n$$\n对 $\\lambda$ 的梯度恢复了约束条件：\n$$\n\\nabla_\\lambda \\mathcal{L} = -(C u - m \\bar{u}) = 0 \\implies C u = m \\bar{u}\n$$\n\n### 3. Karush-Kuhn-Tucker (KKT) 系统\n\n这两个方程构成一个单一、更大的线性系统，称为 Karush-Kuhn-Tucker (KKT) 系统。其分块矩阵形式为：\n$$\n\\begin{pmatrix}\n2 L^2  -C^T \\\\\nC  0_{K \\times K}\n\\end{pmatrix}\n\\begin{pmatrix}\nu^\\star \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0_{N \\times 1} \\\\\nm\\bar{u}\n\\end{pmatrix}\n$$\n其中 $u^\\star$ 是我们寻求的最优提升场。这是一个大小为 $(N+K) \\times (N+K)$ 的稀疏、对称不定线性系统。只要约束能适当地移除目标函数海森矩阵（$L^2$）的零空间，KKT 矩阵就是可逆的。$L^2$ 的零空间是常数场，而约束 $C u = m \\bar{u}$ 通常与常数 $u$ 不相容（除非所有 $\\bar{u}_i$ 都相等），从而确保解的唯一性。\n\n### 4. 算法实现\n\n对于每个测试用例，求解过程如下：\n1.  **初始化**：给定参数 $N$ 和 $m$，计算 $K = N/m$。根据提供的公式构造初始细尺度场 $u \\in \\mathbb{R}^N$。\n\n2.  **限制**：通过块平均计算粗尺度场 $\\bar{u} \\in \\mathbb{R}^K$。一种数值上高效的实现方式是将 $N$ 元向量 $u$ 重塑为 $K \\times m$ 的矩阵，然后计算每行的均值。\n\n3.  **提升构建**：构造矩阵 $L$ 和 $C$。矩阵 $L$ 是一个大小为 $N \\times N$ 的循环矩阵。矩阵 $C$ 是一个大小为 $K \\times N$ 的稀疏矩阵。利用这些构建块（$L^2$, $C$, $C^T$）组装 KKT 系统，并使用计算出的 $\\bar{u}$ 形成右端向量。\n\n4.  **提升求解**：求解 $(N+K) \\times (N+K)$ 的 KKT 线性系统，得到包含 $u^\\star$ 和 $\\lambda$ 的复合向量。解向量的前 $N$ 个分量构成了所期望的提升场 $u^\\star \\in \\mathbb{R}^N$。\n\n5.  **验证与分析**：\n    *   为验证一致性，将限制算子应用于计算出的提升场 $u^\\star$，得到新的粗粒化场 $\\bar{u}^\\star$。计算最大绝对偏差 $d = \\max_i |\\bar{u}^\\star_i - \\bar{u}_i|$。\n    *   如果 $d \\le \\varepsilon = 10^{-10}$，则一致性布尔值 $b$ 为真。\n    *   计算提升场的曲率能量 $E(u^\\star) = \\| L u^\\star \\|_2^2$。\n\n此过程基于约束优化的基本原理，被实现以确定每个指定测试用例所需的输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests restriction and lifting operators for a 1D periodic lattice.\n    The lifting operator is found by solving a constrained minimization problem\n    to find the smoothest field consistent with given coarse-grain averages.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 128, 'm': 8, 'u_func': 'trig_linear', 'params': (3, 7, 0.25, 0.05)},\n        {'N': 64,  'm': 1, 'u_func': 'trig', 'params': (5,)},\n        {'N': 96,  'm': 24, 'u_func': 'trig_cosine', 'params': (10, 12, 0.1)},\n        {'N': 72,  'm': 9, 'u_func': 'piecewise', 'params': None}\n    ]\n\n    epsilon = 1e-10\n    results = []\n\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        N = case['N']\n        m = case['m']\n        K = N // m\n        \n        # Generate the initial fine-grained field u\n        j = np.arange(N)\n        u_func = case['u_func']\n        params = case['params']\n        \n        if u_func == 'trig_linear':\n            k1, k2, c2, c3 = params\n            u = np.sin(2 * np.pi * k1 * j / N) + c2 * np.cos(2 * np.pi * k2 * j / N) + c3 * j / N\n        elif u_func == 'trig':\n            k1, = params\n            u = np.sin(2 * np.pi * k1 * j / N)\n        elif u_func == 'trig_cosine':\n            k1, k2, c2 = params\n            u = np.sin(2 * np.pi * k1 * j / N) + c2 * np.cos(2 * np.pi * k2 * j / N)\n        elif u_func == 'piecewise':\n            u = np.zeros(N)\n            n_third = N // 3\n            u[0:n_third] = 1.0\n            u[n_third : 2 * n_third] = -0.5\n            u[2 * n_third : N] = 0.0\n\n        # 1. Restriction: Compute coarse field ubar by block averaging\n        ubar = u.reshape((K, m)).mean(axis=1)\n\n        # 2. Lifting: Solve the constrained minimization problem via KKT system\n        \n        # Construct L, the N x N matrix for the periodic discrete Laplacian (Delta)\n        L = -2 * np.eye(N) + np.roll(np.eye(N), 1, axis=1) + np.roll(np.eye(N), -1, axis=1)\n        \n        # Construct L2, the N x N matrix for the biharmonic operator (Delta^2)\n        L2 = L @ L\n        \n        # Construct C, the K x N constraint matrix for block summation\n        C = np.zeros((K, N))\n        for i in range(K):\n            C[i, i*m:(i+1)*m] = 1.0\n        \n        # Assemble the (N+K) x (N+K) KKT matrix A and right-hand side vector b_vec\n        A_top = np.hstack([2 * L2, -C.T])\n        A_bot = np.hstack([C, np.zeros((K, K))])\n        A = np.vstack([A_top, A_bot])\n        \n        b_vec = np.concatenate([np.zeros(N), m * ubar])\n        \n        # Solve the linear system A * x = b_vec for x = [u_star, lambda]^T\n        x = np.linalg.solve(A, b_vec)\n        u_star = x[:N]\n\n        # 3. Verify consistency\n        # Restrict the lifted field u_star to get ubar_star\n        ubar_star = u_star.reshape((K, m)).mean(axis=1)\n        \n        # Compute the maximum absolute discrepancy d\n        d = np.max(np.abs(ubar_star - ubar))\n        \n        # Check if the discrepancy is within the tolerance epsilon\n        b_consistency = d = epsilon\n        \n        # 4. Calculate curvature energy E(u_star)\n        delta_u_star = L @ u_star\n        E = np.sum(delta_u_star**2)\n\n        results.append([bool(b_consistency), d, E])\n\n    # Final print statement in the exact required format.\n    formatted_results = ','.join(map(str, results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在动态模拟中，一个关键挑战是如何处理“提升不一致性”（lifting inconsistency）——即从宏观变量重构的微观状态可能并不位于系统自然演化的慢流形上。本练习  旨在探讨“愈合时间”（healing time, $ \\tau_h $）这一核心概念，它是在进行宏观预测之前，通过一段短暂的微观模拟让系统从不一致的初始状态“愈合”并弛豫回慢流形的关键步骤。通过这个计算实验，你将量化愈合时间对宏观预测精度的影响，从而掌握无方程方法中一个至关重要的实用技巧。",
            "id": "4121758",
            "problem": "您的任务是实现一个无方程粗粒化的计算实验，以分离修复时间参数 $ \\tau_h $ 对粗粒化预测的影响。考虑一个具有两个时间尺度的无量纲确定性微观模型，该模型由以下常微分方程 (ODE) 系统定义\n$$\n\\frac{dx}{dt} = -x + 0.5\\,y,\\quad\n\\frac{dy}{dt} = \\frac{1}{\\varepsilon}\\left(-y + x^2\\right),\n$$\n其中 $ x $ 是一个慢变量，$ y $ 是一个快变量，$ \\varepsilon $ 是一个控制时间尺度分离的微小正参数。所有量均为无量纲。无方程 (EF) 粗粒化的目的是在不推导闭合形式粗方程的情况下，为粗变量 $ U = x $ 近似一个粗时间步进器 $ M_{\\Delta t} $。带修复时间的 EF 粗时间步进器定义为\n$$\nM_{\\Delta t}^{(\\tau_h)}(U) \\equiv \\left(R \\circ S_{\\tau_h+\\Delta t} \\circ L\\right)(U),\n$$\n其中 $ L $ (提升) 通过选择 $ x = U $ 和 $ y = y_{\\text{lift}} $ (其中 $ y_{\\text{lift}} $ 在下文指定) 将 $ U $ 映射到一个微观状态；$ S_t $ 是将 ODE 向前推进时间 $ t $ 的微观模拟器；$ R(x,y) = x $ 是限制。修复时间 $ \\tau_h $ 是快变量向慢流形松弛的时间间隔，用于在粗报告时域 $ \\Delta t $ 之前减轻提升不一致性。\n\n请使用以下规范实现 EF 粗时间步进器：\n- 对所有提升操作使用 $ y_{\\text{lift}} = 0 $，以有意地引入与慢流形 $ y \\approx x^2 $ 的初始不一致性，从而揭示 $ \\tau_h $ 的作用。\n- 使用定步长四阶显式龙格-库塔方法（经典 RK4）确定性地积分微观 ODE。使用时间步长 $ h = \\min\\{0.001,\\; 0.05\\,\\varepsilon\\} $。\n- 定义参考修复时间 $ \\tau_{\\text{ref}} = 5.0 $，并通过绝对差来衡量粗粒化预测的敏感性\n$$\nD(U_0,\\Delta t,\\varepsilon,\\tau_h) = \\left|M_{\\Delta t}^{(\\tau_h)}(U_0) - M_{\\Delta t}^{(\\tau_{\\text{ref}})}(U_0)\\right|.\n$$\n\n您的程序必须为以下测试套件中的每个受控测试用例，计算指定列表中每个 $ \\tau_h $ 对应的 $ D(U_0,\\Delta t,\\varepsilon,\\tau_h) $。每个测试用例指定了 $ (U_0,\\Delta t,\\varepsilon) $ 和一个 $ \\tau_h $ 值列表：\n- 测试用例 1 (理想情况，强分离): $ U_0 = 0.7 $, $ \\Delta t = 1.0 $, $ \\varepsilon = 0.05 $, $ \\tau_h \\in \\{0.0, 0.1, 0.5, 1.0\\} $。\n- 测试用例 2 (边界情况：修复时间等于报告时间): $ U_0 = 0.2 $, $ \\Delta t = 0.2 $, $ \\varepsilon = 0.05 $, $ \\tau_h \\in \\{0.0, 0.2\\} $。\n- 测试用例 3 (较弱的分离): $ U_0 = -0.5 $, $ \\Delta t = 1.0 $, $ \\varepsilon = 0.3 $, $ \\tau_h \\in \\{0.0, 0.5, 1.0\\} $。\n- 测试用例 4 (小报告时域): $ U_0 = 1.0 $, $ \\Delta t = 0.01 $, $ \\varepsilon = 0.05 $, $ \\tau_h \\in \\{0.0, 0.01, 0.1\\} $。\n- 测试用例 5 (长报告时域): $ U_0 = 0.0 $, $ \\Delta t = 2.0 $, $ \\varepsilon = 0.05 $, $ \\tau_h \\in \\{0.0, 0.5, 1.0, 2.0\\} $。\n\n所有量均为无量纲。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。其中每个元素对应一个测试用例，并且本身是一个浮点数（绝对差）列表，其顺序与所列的 $ \\tau_h $ 值相同。例如，输出格式必须为 $ [[d_{1,1},d_{1,2},\\dots],[d_{2,1},\\dots],\\dots] $ 的形式，不得包含任何额外文本。每个 $ d_{i,j} $ 必须是一个浮点数。",
            "solution": "该问题是有效的，因为它在科学上是合理的、良态的，并为多尺度建模领域的标准计算练习提供了一套完整、明确的规范。\n\n目标是实现一个无方程 (EF) 粗粒化模拟，以分析修复时间参数 $\\tau_h$ 对粗粒化预测精度的影响。这是通过测量使用给定 $\\tau_h$ 所做预测与使用一个长的、假定足够长的修复时间 $\\tau_{\\text{ref}}$ 所做参考预测之间的偏差来实现的。\n\n问题的核心是一个微观模型，由一个包含两个耦合常微分方程 (ODE) 的系统描述：\n$$\n\\frac{dx}{dt} = -x + 0.5\\,y \\\\\n\\frac{dy}{dt} = \\frac{1}{\\varepsilon}\\left(-y + x^2\\right)\n$$\n这里，$x(t)$ 是慢变量，$y(t)$ 是快变量。参数 $\\varepsilon \\ll 1$ 控制着时间尺度的分离。$1/\\varepsilon$ 项导致 $y$ 的演化速度远快于 $x$。对于小的 $\\varepsilon$ 值，快变量 $y$ 会迅速松弛到由慢变量 $x$ 决定的准稳态。通过设 $dy/dt \\approx 0$，我们发现系统的动力学被吸引到一个慢流形上，这是状态空间中一个不变或近不变的低维曲面，近似由关系式 $y \\approx x^2$ 描述。\n\n无方程 (EF) 方法提供了一种模拟粗变量（此处为 $U=x$）演化的途径，而无需为其动力学推导显式的闭合形式方程。这种演化由一个粗时间步进器 $M_{\\Delta t}$ 捕获，它将粗状态推进一个时间步长 $\\Delta t$。问题定义了该算子的一种特定形式，其中包含修复时间 $\\tau_h$：\n$$\nM_{\\Delta t}^{(\\tau_h)}(U) \\equiv \\left(R \\circ S_{\\tau_h+\\Delta t} \\circ L\\right)(U)\n$$\n这个复合算子分三个阶段工作：\n\n1.  **提升 ($L$)：** 将粗状态 $U_0$ 映射到完整的微观状态 $(x_0, y_0)$。问题指定的提升规则为 $L(U_0) = (x_0, y_0) = (U_0, 0)$。这种选择是故意“不一致”的，因为对于一个泛型 $U_0 \\neq 0$，提升点 $(U_0, 0)$ 并不位于慢流形 $y \\approx x^2$ 上。这种不一致性会引入一个初始的瞬态误差。\n\n2.  **模拟 ($S_t$)：** 从提升的初始条件 $(x_0, y_0)$ 开始，对微观 ODE 系统进行数值前向积分，总时长为 $t = \\tau_h + \\Delta t$。此模拟的初始阶段，即时长为 $\\tau_h$ 的阶段，是“修复”期。在此期间，快变量 $y$ 从其不一致的初始值 ($y_0=0$) 迅速收敛到慢流形。修复之后，在“报告时域” $\\Delta t$ 内的后续演化被假定为能代表真实的粗动态。\n\n3.  **限制 ($R$)：** 总模拟时间结束后，将得到的微观状态 $(x_f, y_f)$ 映射回粗状态。问题指定的限制算子为 $R(x, y) = x$。因此，新的粗状态就是模拟结束时慢变量的值，$U_f = x_f$。\n\n微观 ODE 的数值积分必须使用经典的四阶龙格-库塔 (RK4) 方法，并采用固定的时间步长 $h = \\min\\{0.001, 0.05\\,\\varepsilon\\}$。对于向量形式的 ODE 系统 $\\frac{d\\vec{z}}{dt} = \\vec{f}(t, \\vec{z})$，其中 $\\vec{z} = [x, y]^T$，从时间步 $n$ 到 $n+1$ 的 RK4 更新为：\n$$\n\\vec{z}_{n+1} = \\vec{z}_n + \\frac{h}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\n其中中间斜率计算如下：\n$$\n\\vec{k}_1 = \\vec{f}(t_n, \\vec{z}_n) \\\\\n\\vec{k}_2 = \\vec{f}(t_n + h/2, \\vec{z}_n + h/2 \\cdot \\vec{k}_1) \\\\\n\\vec{k}_3 = \\vec{f}(t_n + h/2, \\vec{z}_n + h/2 \\cdot \\vec{k}_2) \\\\\n\\vec{k}_4 = \\vec{f}(t_n + h, \\vec{z}_n + h \\cdot \\vec{k}_3)\n$$\n对于总模拟时长 $T = \\tau_h + \\Delta t$，总积分步数 $N$ 必须足以覆盖此期间，即 $N = \\lceil T/h \\rceil$。\n\n粗预测对 $\\tau_h$ 选择的敏感性由绝对差 $D$ 来量化：\n$$\nD(U_0,\\Delta t,\\varepsilon,\\tau_h) = \\left|M_{\\Delta t}^{(\\tau_h)}(U_0) - M_{\\Delta t}^{(\\tau_{\\text{ref}})}(U_0)\\right|\n$$\n其中 $\\tau_{\\text{ref}} = 5.0$ 是一个参考修复时间，假定其足够长，以使初始瞬态完全消散。对于由 $(U_0, \\Delta t, \\varepsilon)$ 定义的每个测试用例，我们首先计算参考结果 $U_{\\text{ref}} = M_{\\Delta t}^{(\\tau_{\\text{ref}})}(U_0)$。然后，对于指定列表中的每个 $\\tau_h$，我们计算测试结果 $U_{\\text{test}} = M_{\\Delta t}^{(\\tau_h)}(U_0)$，并计算差值 $|U_{\\text{test}} - U_{\\text{ref}}|$。每个测试用例的这些差值的集合构成了最终结果。",
            "answer": "```python\nimport numpy as np\n# scipy is not used as the problem requires a custom RK4 implementation.\n\ndef get_derivatives(state, epsilon):\n    \"\"\"\n    Computes the derivatives for the microscopic ODE system.\n\n    Args:\n        state (np.ndarray): A 1D array [x, y] representing the current state.\n        epsilon (float): The time-scale separation parameter.\n\n    Returns:\n        np.ndarray: A 1D array [dx/dt, dy/dt].\n    \"\"\"\n    x, y = state\n    dx_dt = -x + 0.5 * y\n    dy_dt = (1.0 / epsilon) * (-y + x**2)\n    return np.array([dx_dt, dy_dt])\n\ndef rk4_step(state, h, epsilon):\n    \"\"\"\n    Performs a single step of the classical Runge-Kutta 4th order method.\n\n    Args:\n        state (np.ndarray): The current state vector [x, y].\n        h (float): The time step size.\n        epsilon (float): The time-scale separation parameter.\n\n    Returns:\n        np.ndarray: The state vector [x, y] at the next time step.\n    \"\"\"\n    k1 = get_derivatives(state, epsilon)\n    k2 = get_derivatives(state + 0.5 * h * k1, epsilon)\n    k3 = get_derivatives(state + 0.5 * h * k2, epsilon)\n    k4 = get_derivatives(state + h * k3, epsilon)\n    return state + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef coarse_stepper(U0, delta_t, tau_h, epsilon):\n    \"\"\"\n    Implements the Equation-Free coarse time-stepper M.\n\n    Args:\n        U0 (float): The initial coarse state.\n        delta_t (float): The coarse reporting horizon.\n        tau_h (float): The healing time.\n        epsilon (float): The time-scale separation parameter.\n\n    Returns:\n        float: The coarse state after one coarse time step.\n    \"\"\"\n    # Lifting: Map coarse state U0 to a microscopic state (x, y)\n    state = np.array([U0, 0.0])\n\n    # Simulation: Integrate the microscopic ODEs\n    # Determine the microscopic time step\n    h = min(0.001, 0.05 * epsilon)\n    \n    # Determine total simulation time and number of steps\n    total_time = tau_h + delta_t\n    if total_time == 0:\n        return U0\n\n    num_steps = int(np.ceil(total_time / h))\n\n    # Run the microscopic simulation\n    for _ in range(num_steps):\n        state = rk4_step(state, h, epsilon)\n\n    # Restriction: Return the slow variable x\n    return state[0]\n\ndef solve():\n    \"\"\"\n    Runs the full computational experiment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (U0, delta_t, epsilon, list_of_tau_h)\n        (0.7, 1.0, 0.05, [0.0, 0.1, 0.5, 1.0]),\n        (0.2, 0.2, 0.05, [0.0, 0.2]),\n        (-0.5, 1.0, 0.3, [0.0, 0.5, 1.0]),\n        (1.0, 0.01, 0.05, [0.0, 0.01, 0.1]),\n        (0.0, 2.0, 0.05, [0.0, 0.5, 1.0, 2.0]),\n    ]\n    \n    tau_ref = 5.0\n    all_results = []\n\n    for U0, delta_t, epsilon, tau_h_list in test_cases:\n        # Calculate the reference coarse prediction using tau_ref\n        U_ref = coarse_stepper(U0, delta_t, tau_ref, epsilon)\n        \n        case_results = []\n        for tau_h in tau_h_list:\n            # Calculate the test coarse prediction\n            U_test = coarse_stepper(U0, delta_t, tau_h, epsilon)\n            \n            # Compute the absolute difference\n            diff = abs(U_test - U_ref)\n            case_results.append(diff)\n            \n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists of floats.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(inner_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "对于空间扩展复杂系统，无方程方法常采用“斑块动力学”（patch dynamics）方案，即在多个局部小区域（斑块）内并行运行微观模拟器。然而，斑块的人工边界条件可能会污染内部的模拟结果。本练习  将引导你解决这一实际问题，推导并验证一个用于确定所需“缓冲区”宽度的规则，以确保斑块核心区域的模拟不受边界伪影的影响。这对于成功实现大规模空间系统的多尺度建模至关重要。",
            "id": "4121753",
            "problem": "您正在使用面向复杂自适应系统的无方程 (Equation-Free, EF) 方法对一维斑块动力学进行建模。在该方法中，微观模拟器在有限的斑块内运行，其内部数据被限制为粗略可观测量，斑块内部周围的缓冲区用于抑制边界伪影的污染。考虑一类晶格上的微观状态，其空间自协方差以已知的微观相关长度呈指数衰减。从第一性原理出发，推导出一个规则，用于计算在缓冲区内部边缘将边界伪影抑制到规定容差以下所需的最小缓冲区宽度。然后，使用由一阶自回归 (AR(1)) 空间递归驱动的简单高斯马尔可夫随机场 (Gaussian Markov random field)，通过数值实验验证所推导的规则。\n\n使用的基本假设：\n- 无方程 (EF) 方法使用的斑块内部，其微观状态通过平均化被限制为粗略可观测量，而在斑块边界附近插入宽度为 $w$ 的缓冲区，以在边界伪影到达发生限制的内部区域之前将其吸收。\n- 沿空间分布的微观状态具有一个空间自相关函数，该函数以相关长度 $ \\xi $ 呈指数衰减，这意味着在稳态下，相距为 $ d $ 的晶格点上的涨落协方差与 $ \\exp(-d/\\xi) $ 成比例。\n- 在斑块边界处引起的边界伪影在 $ d = 0 $ 处的振幅为 $ A_0 $，并且在指数相关衰减的情况下，它们在进入域内距离 $ d $ 处的预期主导阶振幅与 $ A(d) \\propto \\exp(-d/\\xi) $ 成比例。\n\n在一个完整的、可运行的程序中要实现的任务：\n1. 给定一组具有规定微观相关长度 $ \\xi $、伪影容差 $ \\varepsilon $ (以十进制表示) 和边界失配振幅 $ A_0 $ 的测试用例，推导出最小整数缓冲区宽度 $ w^\\star $ (以晶格点为单位)，使得缓冲区内部边缘处的伪影振幅小于或等于 $ \\varepsilon $。$ w^\\star $ 只允许为整数。\n2. 使用由一阶自回归 (AR(1)) 空间递归生成的一维高斯马尔可夫随机场 (GMRF) 通过数值实验验证推导出的 $ w^\\star $：\n   - 使用递归关系 $ u_0 \\sim \\mathcal{N}(0,\\sigma^2) $，对于 $ i \\ge 1 $，\n     $$ u_i = \\rho u_{i-1} + \\sqrt{1-\\rho^2}\\,\\sigma\\,\\eta_i, $$\n     其中 $ \\eta_i \\sim \\mathcal{N}(0,1) $ 是独立同分布的，$ \\sigma  0 $ 是平稳标准差，并且 $ \\rho = \\exp(-1/\\xi) $，因此空间协方差按 $ \\sigma^2 \\rho^{|d|} = \\sigma^2 \\exp(-|d|/\\xi) $ 衰减。\n   - 通过将边界点的值设置为 $ u_0 + A_0 $ 来施加边界伪影，同时在内部保持相同的随机新息 $ \\eta_i $ 以分离伪影效应。计算缓冲区内部边缘的伪影振幅，即在离边界距离为 $ w $ 处，受扰动和未受扰动实现之间的绝对差值。\n   - 在 $ K $ 次独立实现上重复测量，以获得在 $ w^\\star $ 处和 $ w^\\star - 1 $ 处 (当 $ w^\\star  0 $ 时) 伪影振幅的数值估计。使用 $ \\sigma = 1 $ 并报告所有实现的算术平均值。所有量都是无量纲的，并以晶格点为单位进行测量；将 $ w^\\star $ 报告为整数个晶格点。\n3. 对于每个测试用例，输出：\n   - 最小缓冲区宽度 $ w^\\star $ (整数，以晶格点为单位)。\n   - 在 $ w^\\star $ 处的平均测量伪影振幅 (浮点数)。\n   - 一个布尔值，指示在 $ w^\\star $ 处的平均测量伪影振幅是否小于或等于 $ \\varepsilon $。\n   - 在 $ w^\\star - 1 $ 处的平均测量伪影振幅 (浮点数)，如果 $ w^\\star = 0 $ 则为 $ 0.0 $。\n   - 一个布尔值，指示在 $ w^\\star - 1 $ 处的平均测量伪影振幅是否严格大于 $ \\varepsilon $ (如果 $ w^\\star = 0 $ 则为 $ \\text{False} $)。\n4. 最终输出格式必须是单行，包含一个逗号分隔的各测试用例结果列表，每个结果本身都是一个用方括号括起来的逗号分隔列表。例如，\n   $$ [ [w_1^\\star, a_1, b_1, c_1, d_1], [w_2^\\star, a_2, b_2, c_2, d_2], \\ldots ] $$\n   其中 $ w^\\star $ 是整数，$ a $ 和 $ c $ 是浮点数，$ b $ 和 $ d $ 是布尔值。\n\n要实现和评估的测试套件：\n- 案例 $ 1 $: $ \\xi = 5.0 $, $ \\varepsilon = 10^{-3} $, $ A_0 = 0.5 $, 晶格长度 $ N = 200 $, 重复次数 $ K = 20 $。\n- 案例 $ 2 $: $ \\xi = 0.5 $, $ \\varepsilon = 10^{-2} $, $ A_0 = 1.0 $, 晶格长度 $ N = 100 $, 重复次数 $ K = 20 $。\n- 案例 $ 3 $: $ \\xi = 10.0 $, $ \\varepsilon = 10^{-6} $, $ A_0 = 0.2 $, 晶格长度 $ N = 400 $, 重复次数 $ K = 20 $。\n- 案例 $ 4 $: $ \\xi = 1.0 $, $ \\varepsilon = 10^{-3} $, $ A_0 = 10^{-3} $, 晶格长度 $ N = 50 $, 重复次数 $ K = 20 $。\n- 案例 $ 5 $: $ \\xi = 2.0 $, $ \\varepsilon = 10^{-4} $, $ A_0 = 0.8 $, 晶格长度 $ N = 200 $, 重复次数 $ K = 20 $。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例的结果本身也是一个方括号内的逗号分隔列表，顺序为 $ [w^\\star,\\text{amp\\_at\\_}w^\\star,\\text{pass\\_at\\_}w^\\star,\\text{amp\\_at\\_}w^\\star\\!-\\!1,\\text{fail\\_prev}] $，如上所述。所有数值都是无量纲的，所有宽度都以晶格点为单位。将容差 $ \\varepsilon $ 表示为小数；不要使用百分号。此问题不涉及角度。",
            "solution": "该问题被评估为有效。它在科学上基于统计力学和多尺度建模的原理，问题设定良好，具有唯一且可验证的解，并以客观、正式的语言表述。为获得完整解，提供了所有必要的数据和定义。\n\n该问题要求完成两个主要任务：首先，推导在无方程 (EF) 斑块方案中所需的最小缓冲区宽度 $w^\\star$ 的理论公式；其次，使用基于特定随机过程的数值实验来验证该公式。\n\n### 第 1 部分：最小缓冲区宽度 $w^\\star$ 的推导\n\n我们已知微观状态具有空间自协方差，该自协方差以相关长度 $\\xi$ 呈指数衰减。在边界（距离 $d=0$）引入的初始振幅为 $A_0$ 的伪影，其在域内距离 $d$ 处的振幅 $A(d)$ 将遵循相同的标度律衰减。我们可以将此关系建模为：\n$$A(d) = A_0 \\exp\\left(-\\frac{d}{\\xi}\\right)$$\n目标是找到最小的整数缓冲区宽度，我们将其表示为 $w^\\star$，使得在缓冲区内部边缘（在 $d=w^\\star$ 处）的伪影振幅被衰减到小于或等于规定容差 $\\varepsilon$ 的值。条件是：\n$$A(w^\\star) \\le \\varepsilon$$\n代入 $A(d)$ 的表达式，我们得到关于 $w$ 的不等式：\n$$A_0 \\exp\\left(-\\frac{w}{\\xi}\\right) \\le \\varepsilon$$\n为了解出 $w$，我们首先处理初始伪影振幅 $A_0$ 已经小于等于容差的情况，即 $A_0 \\le \\varepsilon$。在这种情况下，不需要缓冲区，因此最小宽度为 $w^\\star = 0$。\n\n对于 $A_0  \\varepsilon$ 的情况，我们对不等式两边取自然对数：\n$$\\exp\\left(-\\frac{w}{\\xi}\\right) \\le \\frac{\\varepsilon}{A_0}$$\n$$-\\frac{w}{\\xi} \\le \\ln\\left(\\frac{\\varepsilon}{A_0}\\right)$$\n两边乘以 $-\\xi$（这是一个正数）会反转不等号：\n$$\\frac{w}{\\xi} \\ge -\\ln\\left(\\frac{\\varepsilon}{A_0}\\right)$$\n利用对数性质 $\\ln(1/x) = -\\ln(x)$，我们有：\n$$w \\ge \\xi \\ln\\left(\\frac{A_0}{\\varepsilon}\\right)$$\n由于缓冲区宽度 $w$ 必须是整数个晶格点，最小整数宽度 $w^\\star$ 是满足此条件的最小整数。这由向上取整函数（ceiling function）给出：\n$$w^\\star = \\left\\lceil \\xi \\ln\\left(\\frac{A_0}{\\varepsilon}\\right) \\right\\rceil$$\n结合两种情况（$A_0 \\le \\varepsilon$ 和 $A_0  \\varepsilon$），所需的最小缓冲区宽度的通用公式为：\n$$w^\\star = \\max\\left(0, \\left\\lceil \\xi \\ln\\left(\\frac{A_0}{\\varepsilon}\\right) \\right\\rceil\\right)$$\n\n### 第 2 部分：通过高斯马尔可夫随机场 (GMRF) 进行验证\n\n问题指定使用由一阶自回归 (AR(1)) 过程生成的一维 GMRF 进行验证。未受扰动的过程 $u_i$ 由以下递归关系定义：\n$$u_i = \\rho u_{i-1} + \\sqrt{1-\\rho^2}\\,\\sigma\\,\\eta_i \\quad \\text{for } i \\ge 1$$\n其中 $u_0 \\sim \\mathcal{N}(0, \\sigma^2)$，$\\eta_i \\sim \\mathcal{N}(0,1)$ 是独立同分布 (i.i.d.) 的随机变量，且 $\\rho = \\exp(-1/\\xi)$。这种对 $\\rho$ 的选择确保了空间协方差 $\\text{Cov}(u_i, u_j) = \\sigma^2 \\rho^{|i-j|} = \\sigma^2 \\exp(-|i-j|/\\xi)$，与问题的假设相符。我们使用 $\\sigma=1$。\n\n一个受扰动的过程 $u'_i$ 使用相同的新息 $\\eta_i$ 生成，但具有包含边界伪影 $A_0$ 的不同初始条件：\n$$u'_0 = u_0 + A_0$$\n$$u'_i = \\rho u'_{i-1} + \\sqrt{1-\\rho^2}\\,\\sigma\\,\\eta_i \\quad \\text{for } i \\ge 1$$\n伪影的传播由差值 $\\delta_i = u'_i - u_i$ 捕捉。\n对于 $i=0$：\n$$\\delta_0 = u'_0 - u_0 = (u_0 + A_0) - u_0 = A_0$$\n对于 $i \\ge 1$：\n$$\\delta_i = u'_i - u_i = (\\rho u'_{i-1} + \\sqrt{1-\\rho^2}\\,\\sigma\\,\\eta_i) - (\\rho u_{i-1} + \\sqrt{1-\\rho^2}\\,\\sigma\\,\\eta_i)$$\n$$\\delta_i = \\rho (u'_{i-1} - u_{i-1}) = \\rho \\delta_{i-1}$$\n这是一个关于伪影 $\\delta_i$ 的简单几何递归。其解为：\n$$\\delta_i = \\rho^i \\delta_0 = A_0 \\rho^i$$\n距离边界 $d$ 处（即在晶格点 $i=d$ 处）的伪影振幅是这个差值的绝对值：\n$$|\\delta_d| = |A_0 \\rho^d| = |A_0| \\left(\\exp\\left(-\\frac{1}{\\xi}\\right)\\right)^d = |A_0| \\exp\\left(-\\frac{d}{\\xi}\\right)$$\n由于问题指出 $A_0$ 是一个振幅，我们取 $A_0 \\ge 0$。因此，振幅为 $A_0 \\exp(-d/\\xi)$。\n\n关键的是，这个结果是确定性的，与具体的随机变量 $\\eta_i$ 和初始状态 $u_0$ 无关。因此，在 $K$ 个实现上进行实验并对结果求平均是多余的；测量的平均振幅将精确等于解析计算出的振幅 $A_0 \\exp(-d/\\xi)$。因此，数值验证变成了基于此推导表达式的直接计算。\n\n每个测试用例的验证过程如下：\n1.  使用第 1 部分推导的公式计算 $w^\\star$。\n2.  计算在 $d=w^\\star$ 处的“平均测量伪影振幅”：\n    $$\\text{amp\\_at\\_}w^\\star = A_0 \\exp(-w^\\star/\\xi)$$\n3.  验证此振幅小于或等于容差 $\\varepsilon$。根据 $w^\\star$ 的构造，条件 $\\text{amp\\_at\\_}w^\\star \\le \\varepsilon$ 必须成立。\n4.  如果 $w^\\star  0$，计算在 $d=w^\\star-1$ 处的“平均测量伪影振幅”：\n    $$\\text{amp\\_at\\_}w^\\star\\!-\\!1 = A_0 \\exp(-(w^\\star-1)/\\xi)$$\n5.  验证此振幅严格大于容差 $\\varepsilon$。同样，根据 $w^\\star$ 的构造，条件 $\\text{amp\\_at\\_}w^\\star\\!-\\!1  \\varepsilon$ 必须成立。\n6.  如果 $w^\\star = 0$，则在 $w^\\star-1$ 处的振幅定义为 $0.0$，相应的检查定义为 False。\n\n此过程证实了对于指定的 AR(1) 模型，$w^\\star$ 确实是满足容差要求的最小整数宽度。代码将实现这些直接计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates the minimal buffer width for an Equation-Free patch scheme.\n    \"\"\"\n    # Test cases: (xi, epsilon, A0, N, K)\n    # N and K are for the conceptual numerical experiment but are not needed for the\n    # final deterministic calculation.\n    test_cases = [\n        (5.0, 1e-3, 0.5, 200, 20),\n        (0.5, 1e-2, 1.0, 100, 20),\n        (10.0, 1e-6, 0.2, 400, 20),\n        (1.0, 1e-3, 1e-3, 50, 20),\n        (2.0, 1e-4, 0.8, 200, 20),\n    ]\n\n    results = []\n    for case in test_cases:\n        xi, eps, A0, N, K = case\n        \n        # Part 1: Derive the minimal integer buffer width w_star.\n        # w_star is the smallest integer w such that A0 * exp(-w/xi) = eps.\n        if A0 = eps:\n            w_star = 0\n        else:\n            # w >= xi * ln(A0 / eps)\n            w_star = int(np.ceil(xi * np.log(A0 / eps)))\n\n        # Part 2: Validate the rule.\n        # For the specified AR(1) process, the artifact propagation is deterministic.\n        # The difference delta_d = u'_d - u_d follows delta_d = A0 * rho^d,\n        # where rho = exp(-1/xi). The artifact amplitude is |delta_d|.\n        # Averaging over K realizations is redundant as the result is the same.\n        # We can calculate the \"mean measured amplitude\" directly.\n        # Since A0 is an amplitude, we assume A0 >= 0.\n        \n        rho = np.exp(-1.0 / xi)\n        \n        # Calculate amplitude at w_star\n        amp_at_w_star = A0 * (rho ** w_star)\n        \n        # Check if the artifact is suppressed at w_star\n        pass_at_w_star = amp_at_w_star = eps\n        \n        # Calculate amplitude at w_star - 1\n        if w_star > 0:\n            amp_at_w_star_minus_1 = A0 * (rho ** (w_star - 1))\n            # Check if the artifact is not suppressed at w_star - 1\n            fail_prev = amp_at_w_star_minus_1 > eps\n        else:\n            # Per problem specification for w_star = 0\n            amp_at_w_star_minus_1 = 0.0\n            fail_prev = False\n            \n        case_result = [\n            w_star,\n            amp_at_w_star,\n            pass_at_w_star,\n            amp_at_w_star_minus_1,\n            fail_prev\n        ]\n        results.append(case_result)\n\n    # Format the final output string as per problem specification.\n    # [[w1,a1,b1,c1,d1],[w2,a2,b2,c2,d2],...]\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item)\n        if isinstance(item, int):\n            return str(item)\n        return str(item) # Standard float representation\n\n    sublist_strings = [\n        \"[\" + \",\".join(map(format_item, res)) + \"]\"\n        for res in results\n    ]\n    \n    print(f\"[{','.join(sublist_strings)}]\")\n\nsolve()\n```"
        }
    ]
}