{
    "hands_on_practices": [
        {
            "introduction": "理解自组织临界性最好的方式莫过于亲眼见证其运作过程。本练习将提供一个直接的、分步式的体验，来模拟沙堆模型的核心机制：雪崩。通过在一个小型网格上手动计算“坍塌”序列，您将为局部不稳定如何传播并最终达到新的稳定状态建立起基础直觉，这个练习  可谓是大型复杂系统中动力学行为的一个缩影。",
            "id": "4142578",
            "problem": "考虑一个具有开放边界的二维方格上的阿贝尔沙堆模型（ASM）。设格点为一个 $3 \\times 3$ 的网格，其上的格点由坐标 $(i,j) \\in \\{-1,0,1\\} \\times \\{-1,0,1\\}$ 索引，原点为 $(0,0)$。每个格点 $(i,j)$ 上有一个整数高度 $h(i,j) \\in \\mathbb{Z}_{\\ge 0}$。如果一个格点的高度至少为 $4$，则该格点是不稳定的。在格点 $(i,j)$ 发生一次坍塌，会使 $h(i,j)$ 减少 $4$，并使其每个最近邻居的高度增加 $1$（内部格点最多有四个邻居，边界上则较少）。在开放边界条件下，任何将被送到 $3 \\times 3$ 网格之外的邻居的沙粒都会耗散并永久离开系统。\n\n从所有九个格点高度均为 $h(i,j) = 3$ 的最大稳定初始构型开始。在原点 $(0,0)$ 处添加一粒沙，然后通过迭代地坍塌不稳定格点来稳定构型，直到所有格点都变得稳定。通过明确列出您所应用的坍塌序列，并报告所有格点最终稳定后的高度，来展示稳定过程。\n\n在此稳定过程中，所有格点总共发生了多少次坍塌？请以单个整数形式提供您的答案。无需四舍五入，不涉及单位。",
            "solution": "问题陈述已经过验证，被认为是复杂自适应系统建模领域内，特别是阿贝尔沙堆模型（ASM）范畴下的一个适定且有科学依据的问题。\n\n该系统是一个 $3 \\times 3$ 的格点网格，由坐标 $(i,j)$ 索引，其中 $i, j \\in \\{-1, 0, 1\\}$。每个格点 $(i,j)$ 有一个整数高度 $h(i,j)$。如果一个格点的高度 $h(i,j) \\ge 4$，则它是不稳定的。在格点 $(i,j)$ 发生一次坍塌会导致高度发生如下变化：\n$h(i,j) \\to h(i,j) - 4$\n$h(\\text{neighbors}) \\to h(\\text{neighbors}) + 1$\n系统具有开放边界，因此任何会流向网格外格点的沙粒都会丢失。\n\n初始状态是最大稳定构型，即所有格点的高度均为 $3$。我们可以将高度构型表示为一个矩阵 $H$，其中矩阵索引 $(r,c)$ ($r,c \\in \\{1,2,3\\}$) 对应于网格坐标 $(c-2, 2-r)$。\n初始构型 $H_{init}$ 为：\n$$ H_{init} = \\begin{pmatrix} 3  3  3 \\\\ 3  3  3 \\\\ 3  3  3 \\end{pmatrix} $$\n\n过程始于在原点，即格点 $(0,0)$ 处添加一粒沙。这对应于网格的中心。$(0,0)$ 处的高度变为 $3+1=4$。现在的构型是：\n$$ H_0 = \\begin{pmatrix} 3  3  3 \\\\ 3  4  3 \\\\ 3  3  3 \\end{pmatrix} $$\n格点 $(0,0)$ 现在是不稳定的。稳定过程以一系列坍塌的形式进行。ASM 的一个关键特性是，最终构型和总坍塌次数与不稳定格点的坍塌顺序无关。\n\n**第1步：第一次坍塌**\n唯一不稳定的格点是 $(0,0)$，其高度 $h(0,0)=4$。我们坍塌这个格点。\n- $(0,0)$ 处的高度减少 $4$：$h(0,0) \\to 4-4=0$。\n- 其四个最近邻居 $(0,-1)$, $(0,1)$, $(-1,0)$ 和 $(1,0)$ 的高度各增加 $1$。它们的高度变为 $3+1=4$。\n得到的构型 $H_1$ 是：\n$$ H_1 = \\begin{pmatrix} 3  4  3 \\\\ 4  0  4 \\\\ 3  4  3 \\end{pmatrix} $$\n到目前为止的坍塌次数为 $1$。\n\n**第2步：第二轮坍塌**\n构型 $H_1$ 有四个不稳定的格点：四个边格点 $(0,-1)$, $(0,1)$, $(-1,0)$ 和 $(1,0)$，它们的高度都为 $4$。我们坍塌这四个格点。顺序无关紧要。让我们分析这四次坍塌的集体效应。\n- 这四个格点各坍塌一次。它们的高度减少 $4$：$h \\to 4-4=0$。\n- 格点 $(0,0)$：它是所有四个坍塌格点的邻居。其高度增加 $4$：$h(0,0) \\to 0+4=4$。\n- 角格点 $(\\pm 1, \\pm 1)$：每个角格点是两个坍塌边格点的邻居。例如，格点 $(-1,-1)$ 是 $(-1,0)$ 和 $(0,-1)$ 的邻居。因此，每个角格点的高度增加 $2$：$h \\to 3+2=5$。\n得到的构型 $H_2$ 是：\n$$ H_2 = \\begin{pmatrix} 5  0  5 \\\\ 0  4  0 \\\\ 5  0  5 \\end{pmatrix} $$\n这一轮的坍塌次数为 $4$。总坍塌次数现在是 $1+4=5$。\n\n**第3步：最后一轮坍塌**\n构型 $H_2$ 有五个不稳定的格点：四个高度为 $5$ 的角格点和高度为 $4$ 的中心格点。我们接着坍塌这些格点。\n1.  首先，让我们坍塌中心格点 $(0,0)$，其高度 $h(0,0)=4$。\n    - 其高度变为 $h(0,0) \\to 4-4=0$。\n    - 它的四个邻居，即边格点，当前高度为 $0$。它们的高度增加 $1$：$h \\to 0+1=1$。\n    这次坍塌是总共第 $6$ 次坍塌。构型变为：\n    $$ H_{2a} = \\begin{pmatrix} 5  1  5 \\\\ 1  0  1 \\\\ 5  1  5 \\end{pmatrix} $$\n2.  现在，四个角格点 $(\\pm 1, \\pm 1)$ 是不稳定的，高度为 $5$。我们坍塌这四个格点。\n    - 它们的高度减少 $4$：$h \\to 5-4=1$。\n    - 每个角格点在网格上有两个邻居。例如，坍塌 $(-1,-1)$ 会给 $(-1,0)$ 和 $(0,-1)$ 各增加一粒沙。\n    - 我们来看一个边格点，例如 $(-1,0)$ 受到的影响。其当前高度为 $1$。它从邻近的两个正在坍塌的角格点 $(-1,-1)$ 和 $(-1,1)$ 处各接收一粒沙，其新高度变为 $1+2=3$。\n    - 根据对称性，所有四个边格点的高度都将从 $1$ 变为 $3$。\n这一轮包含 $4$ 次坍塌，每个角格点一次。最终稳定构型 $H_f$ 为：\n$$ H_f = \\begin{pmatrix} 1  3  1 \\\\ 3  0  3 \\\\ 1  3  1 \\end{pmatrix} $$\n现在所有高度都小于 $4$，因此构型是稳定的。\n\n**坍塌总结**\n为了求出总坍塌次数，我们将每个阶段的坍塌次数相加：\n- 第1步：格点 $(0,0)$ 发生 $1$ 次坍塌。\n- 第2步：$4$ 次坍塌，四个边格点各一次。\n- 第3步：格点 $(0,0)$ 发生 $1$ 次坍塌，四个角格点各发生 $1$ 次坍塌。此步共计 $5$ 次坍塌。\n\n总坍塌次数 = $1 + 4 + 5 = 10$。\n\n所有格点 $(i,j)$ 的最终稳定高度为：\n- $h(0,0) = 0$\n- $h(\\pm 1, 0) = h(0, \\pm 1) = 3$\n- $h(\\pm 1, \\pm 1) = 1$\n\n在稳定过程中发生过的总坍塌次数为 $10$。",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "虽然手动模拟富有启发性，但其规模有限。本练习将引导您过渡到计算方法，以探索该模型最深刻的特性之一：阿贝尔性质（Abelian property）。该性质保证了最终的稳定状态与坍塌事件的发生顺序无关。本练习  要求您通过编程实现两种不同的更新方案（串行与并行），并验证它们可以得到完全相同的结果，从而具体地展示自组织临界态的稳健性。",
            "id": "4142585",
            "problem": "考虑一个具有开放边界条件的有限方格上的 Bak–Tang–Wiesenfeld (BTW) 阿贝尔沙堆模型。设该格子大小为 $L \\times L$，由坐标对 $(i,j)$ 索引，其中 $i \\in \\{0, \\ldots, L-1\\}$ 且 $j \\in \\{0, \\ldots, L-1\\}$。一个构型是一个非负整数数组 $z \\in \\mathbb{Z}_{\\ge 0}^{L \\times L}$，其中 $z_{i,j}$ 表示在格点 $(i,j)$ 上的沙粒数量。如果 $z_{i,j} \\ge 4$，则格点 $(i,j)$ 是不稳定的。在格点 $(i,j)$ 上的倾倒操作 $T_{i,j}$ 将构型 $z$ 转换为新构型 $z'$，其规则为 $z'_{i,j} = z_{i,j} - 4$。对于其四个最近邻 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 中位于格子内的格点，其沙粒数各增加 $1$（被送到格子外的沙粒将流失）。如果对所有 $(i,j)$ 都有 $z_{i,j}  4$，则该构型是稳定的。\n\n定义两种弛豫过程，它们通过重复应用倾倒操作直至达到稳定构型：\n- 并行弛豫：在每个离散时间步 $t$，同时对每个不稳定格点倾倒一次，即在该步中对所有满足 $z_{i,j} \\ge 4$ 的 $(i,j)$ 应用 $T_{i,j}$，并重复此过程直至稳定。\n- 顺序弛豫：在每一步中，选择字典序最前的不稳定格点（即在所有满足 $z_{i,j} \\ge 4$ 的格点中，字典序最小的 $(i,j)$），仅在该格点上应用 $T_{i,j}$，并重复此过程直至稳定。\n\n从 BTW 模型的基本定义出发，实现这两种弛豫过程，并在一个小的初始构型测试集上凭经验验证并行弛豫和顺序弛豫产生的最终稳定构型是相同的。使用开放边界条件（将被送到格子外的沙粒会流失），并在每个格点使用阈值 $4$（即当 $z_{i,j} \\ge 4$ 时格点发生倾倒）。\n\n您必须硬编码以下初始构型测试集，并用两种弛豫过程处理每种情况：\n\n- 情况 $1$ ($L = 3$): \n$$\nZ^{(1)} = \\begin{bmatrix}\n0  0  0 \\\\\n0  10  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n\n- 情况 $2$ ($L = 4$):\n$$\nZ^{(2)} = \\begin{bmatrix}\n3  4  0  1 \\\\\n2  5  2  3 \\\\\n0  1  4  0 \\\\\n7  0  0  2\n\\end{bmatrix}\n$$\n\n- 情况 $3$ ($L = 1$):\n$$\nZ^{(3)} = \\begin{bmatrix}\n100\n\\end{bmatrix}\n$$\n\n- 情况 $4$ ($L = 2$):\n$$\nZ^{(4)} = \\begin{bmatrix}\n0  0 \\\\\n0  0\n\\end{bmatrix}\n$$\n\n- 情况 $5$ ($L = 5$):\n$$\nZ^{(5)} = \\begin{bmatrix}\n0  4  0  4  0 \\\\\n4  3  3  3  4 \\\\\n0  3  12  3  0 \\\\\n4  3  3  3  4 \\\\\n0  4  0  4  0\n\\end{bmatrix}\n$$\n\n对于每种情况，计算由并行弛豫产生的最终稳定构型和由顺序弛豫产生的最终稳定构型。比较它们是否完全相等。要求的输出是布尔值，对于每种情况 $k \\in \\{1,2,3,4,5\\}$，指示两个最终构型是否相同。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况 1 到 5 的顺序列出结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 为 $True$ 或 $False$。不涉及物理单位或角度单位；所有结果均为无量纲。不需要百分比。",
            "solution": "该问题要求对 Bak–Tang–Wiesenfeld (BTW) 阿贝尔沙堆模型的一个基本性质进行经验性验证。具体来说，我们必须实现两种不同的弛豫过程——一种并行，一种顺序——并确认它们从相同的初始状态能产生相同的最终稳定构型。\n\n首先，我们如前所述将模型形式化。系统定义在一个大小为 $L \\times L$ 的方格上，格点由 $(i,j)$ 索引，其中 $i, j \\in \\{0, 1, \\ldots, L-1\\}$。每个格点 $(i,j)$ 拥有非负整数个“沙粒”，记为 $z_{i,j}$。整个系统的构型是矩阵 $Z = \\{z_{i,j}\\}$。\n\n如果一个格点 $(i,j)$ 的沙粒数达到或超过一个临界阈值，即 $z_{i,j} \\ge z_c$，则该格点被定义为不稳定的。对于本问题，所有格点的阈值均为 $z_c = 4$。当一个格点不稳定时，它可以“倾倒”。在格点 $(i,j)$ 上的倾倒操作 $T_{i,j}$ 会根据以下规则重新分配其沙粒：\n$$\nz_{i,j} \\rightarrow z_{i,j} - 4\n$$\n$$\nz_{k,l} \\rightarrow z_{k,l} + 1 \\quad \\text{for each nearest neighbor } (k,l) \\text{ of } (i,j)\n$$\n该模型使用开放边界条件，这意味着如果格子边缘上的一个格点倾倒，任何本应送到格子外的非存在邻居的沙粒都会从系统中流失。如果所有格点都是稳定的，即对所有 $(i,j)$ 都有 $z_{i,j}  4$，则构型是稳定的。\n\n该模型的一个关键定理是其阿贝尔性质。这意味着对于任何初始构型，在所有必要的倾倒事件发生后达到的最终稳定构型是唯一的，并且不依赖于倾倒操作的执行顺序。循环构型的集合形成一个阿贝尔群，因此得名。该问题要求我们通过比较两种特定的倾倒序列来验证这一性质：\n\n1.  **顺序弛豫：** 在此过程中，我们重复地找到字典序最前的不稳定格点（即通过先扫描行再扫描列），并仅倾倒该格点。重复此过程，直到没有不稳定的格点为止。算法如下：\n    - 步骤 1：用给定的构型 $Z$ 初始化系统。\n    - 步骤 2：扫描格子以找到所有不稳定格点的集合，其中 $z_{i,j} \\ge 4$。\n    - 步骤 3：如果该集合为空，则构型是稳定的，过程终止。\n    - 步骤 4：如果该集合不为空，选择字典序最前的格点 $(i,j)$。\n    - 步骤 5：对构型 $Z$ 应用倾倒操作 $T_{i,j}$。\n    - 步骤 6：返回步骤 2。\n\n2.  **并行弛豫：** 在此过程中，所有不稳定的格点在离散的时间步中同时倾倒。这意味着在时间 $t+1$ 的网格状态是由基于时间 $t$ 的状态发生的所有倾倒决定的。算法如下：\n    - 步骤 1：用给定的构型 $Z(t=0)$ 初始化系统。\n    - 步骤 2：在每个时间步 $t$，识别所有不稳定格点 $(i,j)$ 的集合 $U_t$，其中 $z_{i,j}(t) \\ge 4$。\n    - 步骤 3：如果 $U_t$ 为空，系统是稳定的，过程终止。\n    - 步骤 4：计算网格构型的变化 $\\Delta Z(t)$。集合 $U_t$ 中的每个格点 $(i,j)$ 失去 $4$ 个沙粒。每个格点 $(i,j)$ 从其属于 $U_t$ 的邻居 $(k,l)$ 处各获得一个沙粒。\n    - 步骤 5：新的构型为 $Z(t+1) = Z(t) + \\Delta Z(t)$。\n    - 步骤 6：将 $t$ 增加 1，然后返回步骤 2。\n\n并行弛豫的实现可以使用向量运算进行优化。更新规则可以表示为：\n$$\nz_{i,j}(t+1) = z_{i,j}(t) - 4 \\cdot \\mathbb{I}((i,j) \\in U_t) + \\sum_{(k,l) \\in N(i,j)} \\mathbb{I}((k,l) \\in U_t)\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，$N(i,j)$ 是 $(i,j)$ 的最近邻集合。求和项是一个离散卷积。如果我们定义一个矩阵 $S_t$，其中当 $(i,j) \\in U_t$ 时 $S_{t, i,j} = 1$，否则为 $0$，则更新可以使用卷积核 $K$ 写为：\n$$\nZ(t+1) = Z(t) - 4 S_t + (S_t * K) \\quad \\text{where} \\quad K = \\begin{pmatrix} 0  1  0 \\\\ 1  0  1 \\\\ 0  1  0 \\end{pmatrix}\n$$\n卷积必须处理开放边界条件，这对应于用零进行填充。\n\n解决方案将包括实现这两种算法，将它们应用于所提供的五个测试用例，并比较最终的稳定矩阵是否相等。基于 BTW 模型的阿贝尔性质，预期在所有测试用例中，两种方法得到的最终构型都是相同的。输出将是一个布尔值列表，表示每种情况下比较的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef parallel_relaxation(grid: np.ndarray) - np.ndarray:\n    \"\"\"\n    Relaxes a sandpile configuration using parallel updates.\n    In each step, all unstable sites topple simultaneously.\n    \"\"\"\n    # Make a copy to avoid modifying the original array from the test suite\n    grid = grid.copy()\n    L = grid.shape[0]\n    \n    # Kernel for convolution to distribute grains to neighbors\n    kernel = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]], dtype=np.int32)\n    threshold = 4\n\n    while np.any(grid = threshold):\n        # Identify sites that will topple in this step\n        # A site topples once if its height is = threshold\n        unstable_sites = (grid = threshold).astype(np.int32)\n        \n        # Grains lost from each site due to toppling\n        grains_out = threshold * unstable_sites\n        \n        # Grains received by each site from its toppling neighbors\n        # The convolution calculates this sum for all sites at once.\n        # 'fill' boundary condition with fillvalue=0 handles open boundaries.\n        grains_in = signal.convolve2d(unstable_sites, kernel, mode='same', boundary='fill', fillvalue=0)\n        \n        # Apply the net change to the grid\n        grid = grid - grains_out + grains_in\n        \n    return grid\n\ndef sequential_relaxation(grid: np.ndarray) - np.ndarray:\n    \"\"\"\n    Relaxes a sandpile configuration using sequential updates.\n    In each step, the lexicographically first unstable site topples.\n    \"\"\"\n    # Make a copy to avoid modifying the original array from the test suite\n    grid = grid.copy()\n    L = grid.shape[0]\n    threshold = 4\n\n    while True:\n        # np.argwhere finds indices of non-zero elements, which are True for unstable sites.\n        # The result is already in lexicographical (row-major) order.\n        unstable_indices = np.argwhere(grid = threshold)\n        \n        if unstable_indices.shape[0] == 0:\n            # No unstable sites, the configuration is stable\n            break\n        \n        # Get the lexicographically first unstable site\n        i, j = unstable_indices[0]\n        \n        # Perform the toppling operation\n        grid[i, j] -= threshold\n        \n        # Distribute grains to neighbors, checking for boundaries\n        if i  0:\n            grid[i - 1, j] += 1\n        if i  L - 1:\n            grid[i + 1, j] += 1\n        if j  0:\n            grid[i, j - 1] += 1\n        if j  L - 1:\n            grid[i, j + 1] += 1\n            \n    return grid\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify the Abelian property.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0, 0, 0],\n                  [0, 10, 0],\n                  [0, 0, 0]], dtype=np.int32),\n        np.array([[3, 4, 0, 1],\n                  [2, 5, 2, 3],\n                  [0, 1, 4, 0],\n                  [7, 0, 0, 2]], dtype=np.int32),\n        np.array([[100]], dtype=np.int32),\n        np.array([[0, 0],\n                  [0, 0]], dtype=np.int32),\n        np.array([[0, 4, 0, 4, 0],\n                  [4, 3, 3, 3, 4],\n                  [0, 3, 12, 3, 0],\n                  [4, 3, 3, 3, 4],\n                  [0, 4, 0, 4, 0]], dtype=np.int32),\n    ]\n\n    results = []\n    for initial_config in test_cases:\n        # Run parallel relaxation\n        stable_config_parallel = parallel_relaxation(initial_config)\n        \n        # Run sequential relaxation\n        stable_config_sequential = sequential_relaxation(initial_config)\n        \n        # Compare the final stable configurations for equality\n        are_identical = np.array_equal(stable_config_parallel, stable_config_sequential)\n        results.append(are_identical)\n\n    # Format and print the final results as specified.\n    # The expected output is [True,True,True,True,True] due to the Abelian property.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了动力学过程和阿贝尔性质之后，下一步自然是分析系统状态空间的结构。本练习将介绍Dhar的“燃烧算法”，这是一个区分暂态（系统离开后永不返回的状态）和循环态（构成持久临界态集合的状态）的强大工具。这个实践  提供了一种具体的、算法化的方法来对沙堆的构型进行分类，这对于理解沙堆群和临界吸引子的本质至关重要。",
            "id": "4142584",
            "problem": "考虑一个在 $2 \\times 2$ 方形晶格上的阿贝尔沙堆模型，该模型具有最近邻连接，并在右上角顶点处有一个指定的汇点。用坐标 $(i,j)$ 标记顶点，其中 $i,j \\in \\{1,2\\}$，并将汇点指定为 $(2,2)$。非汇点顶点为 $(1,1)$、$(1,2)$ 和 $(2,1)$。边存在于最近邻之间：$(1,1)$ 与 $(1,2)$ 和 $(2,1)$ 相邻；$(1,2)$ 与 $(1,1)$ 和汇点 $(2,2)$ 相邻；$(2,1)$ 与 $(1,1)$ 和汇点 $(2,2)$ 相邻。每个非汇点顶点的度（计算到汇点的边）为 $2$，因此一个稳定构型在每个非汇点顶点处的高度 $h(i,j) \\in \\{0,1\\}$。\n\n考虑一个特定的稳定构型，其高度为 $h(1,1)=1$、$h(1,2)=1$ 和 $h(2,1)=0$。应用 Dhar 燃烧算法来测试其递归性：从燃烧汇点开始；然后，在随后的每一轮中，燃烧每个满足 $h(v) \\geq d_{U}(v)$ 的未燃烧顶点 $v$，其中 $d_{U}(v)$ 表示从 $v$ 到当前未燃烧顶点的边的数量。持续此过程直到没有更多顶点可以被燃烧。\n\n确定该构型是递归的（所有非汇点顶点最终都燃烧）还是瞬态的（至少有一个非汇点顶点在终止时仍未燃烧）。报告指示值 $I$，如果构型是递归的，则 $I=1$；如果是瞬态的，则 $I=0$。最终答案必须是单个数字 $I$。无需四舍五入。",
            "solution": "该问题要求我们通过应用 Dhar 燃烧算法来确定一个给定的阿贝尔沙堆模型稳定构型是递归的还是瞬态的。结果以指示值 $I$ 表示，对于递归构型 $I=1$，对于瞬态构型 $I=0$。\n\n首先，我们建立所描述的系统的组成部分。\n顶点集为 $V = \\{(1,1), (1,2), (2,1), (2,2)\\}$。\n非汇点顶点为 $V_{ns} = \\{(1,1), (1,2), (2,1)\\}$。\n指定的汇点为顶点 $s = (2,2)$。\n连接性如下：\n- 顶点 $(1,1)$ 连接到 $(1,2)$ 和 $(2,1)$。\n- 顶点 $(1,2)$ 连接到 $(1,1)$ 和汇点 $(2,2)$。\n- 顶点 $(2,1)$ 连接到 $(1,1)$ 和汇点 $(2,2)$。\n每个非汇点顶点 $v$ 的度 $d(v)$ 为 $2$。\n初始高度构型如下：\n- $h(1,1) = 1$\n- $h(1,2) = 1$\n- $h(2,1) = 0$\n\nDhar 燃烧算法是测试递归性的一个迭代过程。设 $U$ 为未燃烧的非汇点顶点集，$B$ 为已燃烧的顶点集。算法按以下步骤进行：\n1. 通过燃烧汇点来初始化过程。因此，在第 $t=0$ 轮，$B_0 = \\{s\\}$ 且 $U_0 = V_{ns}$。\n2. 在随后的每一轮 $t>0$ 中，如果一个顶点 $v \\in U_{t-1}$ 的高度 $h(v)$ 大于或等于其未燃烧邻居的数量 $d_{U_{t-1}}(v)$，则该顶点被燃烧。\n3. 当一轮中没有更多顶点可以被燃烧时，该过程终止。\n4. 如果最终的未燃烧顶点集为空（$U_{final} = \\emptyset$），则该构型是递归的。否则，它是瞬态的。\n\n我们现在将此算法应用于给定的构型。\n\n**第0轮（初始化）：**\n汇点 $s=(2,2)$ 最初被燃烧。\n已燃烧顶点集为 $B_0 = \\{(2,2)\\}$。\n未燃烧顶点集为 $U_0 = \\{(1,1), (1,2), (2,1)\\}$。\n\n**第1轮：**\n我们对每个顶点 $v \\in U_0$ 检查燃烧条件 $h(v) \\geq d_{U_0}(v)$。$d_{U_0}(v)$ 项是 $v$ 在 $U_0$ 中的邻居数量。\n\n- 对于 $v = (1,1)$：高度为 $h(1,1) = 1$。其邻居是 $(1,2)$ 和 $(2,1)$。两者都在 $U_0$ 中。因此，$d_{U_0}(1,1) = 2$。条件是 $1 \\geq 2$，为假。顶点 $(1,1)$ 不燃烧。\n\n- 对于 $v = (1,2)$：高度为 $h(1,2) = 1$。其邻居是 $(1,1)$ 和 $(2,2)$。邻居 $(1,1)$ 在 $U_0$ 中，但 $(2,2)$ 在 $B_0$ 中。因此，$d_{U_0}(1,2) = 1$。条件是 $1 \\geq 1$，为真。顶点 $(1,2)$ 燃烧。\n\n- 对于 $v = (2,1)$：高度为 $h(2,1) = 0$。其邻居是 $(1,1)$ 和 $(2,2)$。邻居 $(1,1)$ 在 $U_0$ 中，但 $(2,2)$ 在 $B_0$ 中。因此，$d_{U_0}(2,1) = 1$。条件是 $0 \\geq 1$，为假。顶点 $(2,1)$ 不燃烧。\n\n在第1轮结束时，只有顶点 $(1,2)$ 新被燃烧。\n新的未燃烧顶点集为 $U_1 = U_0 \\setminus \\{(1,2)\\} = \\{(1,1), (2,1)\\}$。\n新的已燃烧顶点集为 $B_1 = B_0 \\cup \\{(1,2)\\} = \\{(2,2), (1,2)\\}$。\n\n**第2轮：**\n我们对每个剩余的未燃烧顶点 $v \\in U_1$ 检查燃烧条件 $h(v) \\geq d_{U_1}(v)$。\n\n- 对于 $v = (1,1)$：高度为 $h(1,1) = 1$。其邻居是 $(1,2)$ 和 $(2,1)$。邻居 $(1,2)$ 现在在 $B_1$ 中，而 $(2,1)$ 在 $U_1$ 中。因此，$d_{U_1}(1,1) = 1$。条件是 $1 \\geq 1$，为真。顶点 $(1,1)$ 燃烧。\n\n- 对于 $v = (2,1)$：高度为 $h(2,1) = 0$。其邻居是 $(1,1)$ 和 $(2,2)$。邻居 $(1,1)$ 当前在 $U_1$ 中，而 $(2,2)$ 在 $B_1$ 中。因此，$d_{U_1}(2,1) = 1$。条件是 $0 \\geq 1$，为假。顶点 $(2,1)$ 不燃烧。\n\n在第2轮结束时，顶点 $(1,1)$ 新被燃烧。\n新的未燃烧顶点集为 $U_2 = U_1 \\setminus \\{(1,1)\\} = \\{(2,1)\\}$。\n新的已燃烧顶点集为 $B_2 = B_1 \\cup \\{(1,1)\\} = \\{(2,2), (1,2), (1,1)\\}$。\n\n**第3轮：**\n我们为唯一剩下的未燃烧顶点 $v = (2,1) \\in U_2$ 检查燃烧条件。\n\n- 对于 $v = (2,1)$：高度为 $h(2,1) = 0$。其邻居是 $(1,1)$ 和 $(2,2)$。两个邻居现在都在 $B_2$ 中。因此，它在 $U_2$ 中没有邻居，所以 $d_{U_2}(2,1) = 0$。条件是 $0 \\geq 0$，为真。顶点 $(2,1)$ 燃烧。\n\n在第3轮结束时，顶点 $(2,1)$ 新被燃烧。\n新的未燃烧顶点集为 $U_3 = U_2 \\setminus \\{(2,1)\\} = \\emptyset$。\n最终的已燃烧顶点集是 $B_3 = B_2 \\cup \\{(2,1)\\} = \\{(2,2), (1,2), (1,1), (2,1)\\}$，包含了所有非汇点顶点。\n\n**结论：**\n算法终止，因为未燃烧顶点集为空。由于所有非汇点顶点——$(1,1)$、$(1,2)$ 和 $(2,1)$——最终都被燃烧，初始构型被定义为递归的。\n\n根据问题陈述，对于递归构型，指示值 $I$ 为 $1$。因此，$I=1$。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}