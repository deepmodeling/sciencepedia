{
    "hands_on_practices": [
        {
            "introduction": "The core dynamic of a sandpile model is the \"avalanche,\" a cascade of topplings that propagates through the system until stability is restored. This first exercise provides a direct, hands-on experience with this fundamental process. By manually tracing the addition of a single grain to a maximally stable grid , you will gain a concrete understanding of how local toppling rules lead to global reorganization and witness the system self-organizing into a new stable state.",
            "id": "4142578",
            "problem": "Consider the Abelian sandpile model (ASM) on a two-dimensional square lattice with open boundaries. Let the lattice be the $3 \\times 3$ grid with sites indexed by coordinates $(i,j) \\in \\{-1,0,1\\} \\times \\{-1,0,1\\}$, and let the origin be $(0,0)$. Each site $(i,j)$ carries an integer height $h(i,j) \\in \\mathbb{Z}_{\\ge 0}$. A site is unstable if its height is at least $4$. A toppling at site $(i,j)$ reduces $h(i,j)$ by $4$ and increases the height of each of its nearest neighbors (up to four of them in the interior, fewer on the boundary) by $1$. With open boundary conditions, any grains that would be sent to a neighbor outside the $3 \\times 3$ grid are dissipated and leave the system permanently.\n\nStart from the maximally stable initial configuration $h(i,j) = 3$ at all nine sites. Add a single grain at the origin $(0,0)$ and stabilize the configuration by iteratively toppling unstable sites until all sites are stable. Demonstrate the stabilization by explicitly enumerating the sequence of topplings you apply and reporting the final stabilized heights at all sites.\n\nWhat is the total number of topplings that occur over all sites during this stabilization process? Provide your answer as a single integer. No rounding is required and no units are involved.",
            "solution": "The problem statement has been validated and is deemed a well-posed, scientifically grounded problem within the domain of complex adaptive systems modeling, specifically the Abelian sandpile model (ASM).\n\nThe system is a $3 \\times 3$ grid of sites, indexed by coordinates $(i,j)$ where $i, j \\in \\{-1, 0, 1\\}$. Each site $(i,j)$ has an integer height $h(i,j)$. A site is unstable if its height $h(i,j) \\ge 4$. A toppling at site $(i,j)$ results in the height changes:\n$h(i,j) \\to h(i,j) - 4$\n$h(\\text{neighbors}) \\to h(\\text{neighbors}) + 1$\nThe system has open boundaries, so any grains that would go to a site outside the grid are lost.\n\nThe initial state is the maximally stable configuration, where all sites have a height of $3$. We can represent the height configuration as a matrix $H$, where the matrix indices $(r,c)$ with $r,c \\in \\{1,2,3\\}$ correspond to the grid coordinates $(j-2, 2-r)$.\nThe initial configuration $H_{init}$ is:\n$$ H_{init} = \\begin{pmatrix} 3 & 3 & 3 \\\\ 3 & 3 & 3 \\\\ 3 & 3 & 3 \\end{pmatrix} $$\n\nThe process begins by adding a single grain to the origin, site $(0,0)$. This corresponds to the center of the grid. The height at $(0,0)$ becomes $3+1=4$. The configuration is now:\n$$ H_0 = \\begin{pmatrix} 3 & 3 & 3 \\\\ 3 & 4 & 3 \\\\ 3 & 3 & 3 \\end{pmatrix} $$\nThe site $(0,0)$ is now unstable. The stabilization process proceeds as a sequence of topplings. A key property of the ASM is that the final configuration and the total number of topplings are independent of the order in which unstable sites are toppled.\n\n**Step 1: First Toppling**\nThe only unstable site is $(0,0)$ with $h(0,0)=4$. We topple this site.\n- The height at $(0,0)$ decreases by $4$: $h(0,0) \\to 4-4=0$.\n- The heights of its four nearest neighbors, $(0,-1)$, $(0,1)$, $(-1,0)$, and $(1,0)$, each increase by $1$. Their heights become $3+1=4$.\nThe resulting configuration, $H_1$, is:\n$$ H_1 = \\begin{pmatrix} 3 & 4 & 3 \\\\ 4 & 0 & 4 \\\\ 3 & 4 & 3 \\end{pmatrix} $$\nThe number of topplings thus far is $1$.\n\n**Step 2: Second Round of Topplings**\nThe configuration $H_1$ has four unstable sites: the four edge sites $(0,-1)$, $(0,1)$, $(-1,0)$, and $(1,0)$, all with height $4$. We topple these four sites. The order does not matter. Let's analyze the collective effect of these four topplings.\n- Each of the four sites topples once. Their heights decrease by $4$: $h \\to 4-4=0$.\n- Site $(0,0)$: It is a neighbor to all four toppling sites. Its height increases by $4$: $h(0,0) \\to 0+4=4$.\n- The corner sites, $(\\pm 1, \\pm 1)$: Each corner site is a neighbor to two of the toppling edge sites. For instance, site $(-1,-1)$ is a neighbor to $(-1,0)$ and $(0,-1)$. Therefore, the height of each corner site increases by $2$: $h \\to 3+2=5$.\nThe resulting configuration, $H_2$, is:\n$$ H_2 = \\begin{pmatrix} 5 & 0 & 5 \\\\ 0 & 4 & 0 \\\\ 5 & 0 & 5 \\end{pmatrix} $$\nThe number of topplings in this round is $4$. The total number of topplings is now $1+4=5$.\n\n**Step 3: Final Round of Topplings**\nThe configuration $H_2$ has five unstable sites: the four corners with height $5$ and the center with height $4$. We proceed to topple these sites.\n1.  First, let's topple the center site $(0,0)$, which has $h(0,0)=4$.\n    - Its height becomes $h(0,0) \\to 4-4=0$.\n    - Its four neighbors, the edge sites, currently have height $0$. Their heights increase by $1$: $h \\to 0+1=1$.\n    This toppling is the $6^{th}$ total toppling. The configuration becomes:\n    $$ H_{2a} = \\begin{pmatrix} 5 & 1 & 5 \\\\ 1 & 0 & 1 \\\\ 5 & 1 & 5 \\end{pmatrix} $$\n2.  Now, the four corner sites $(\\pm 1, \\pm 1)$ are unstable with height $5$. We topple these four sites.\n    - Their heights decrease by $4$: $h \\to 5-4=1$.\n    - Each corner site has two neighbors on the grid. For example, toppling $(-1,-1)$ adds one grain to $(-1,0)$ and one to $(0,-1)$.\n    - By symmetry, all four edge sites will have their heights change from $1$ to $3$.\nThis round involves $4$ more topplings, one for each corner. The final stabilized configuration, $H_f$, is:\n$$ H_f = \\begin{pmatrix} 1 & 3 & 1 \\\\ 3 & 0 & 3 \\\\ 1 & 3 & 1 \\end{pmatrix} $$\nAll heights are now less than $4$, so the configuration is stable.\n\n**Summary of Topplings**\nTo find the total number of topplings, we sum the topplings from each stage:\n- Step 1: $1$ toppling at site $(0,0)$.\n- Step 2: $4$ topplings, one at each of the four edge sites.\n- Step 3: $1$ toppling at site $(0,0)$ and $4$ topplings, one at each of the four corner sites. This is a total of $5$ topplings.\n\nTotal number of topplings = $1 + 4 + 5 = 10$.\n\nThe final stabilized heights at all sites $(i,j)$ are:\n- $h(0,0) = 0$\n- $h(\\pm 1, 0) = h(0, \\pm 1) = 3$\n- $h(\\pm 1, \\pm 1) = 1$\n\nThe total number of topplings that occurred during the stabilization process is $10$.",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "A remarkable and defining feature of the Bak-Tang-Wiesenfeld model is its Abelian property: the final stable state is independent of the sequence of topplings. This exercise challenges you to empirically verify this non-trivial theorem through computation . By implementing and comparing parallel and sequential relaxation schemes, you will gain a profound, practical understanding of what makes the sandpile model \"Abelian\" and why this property is so crucial to its mathematical analysis.",
            "id": "4142585",
            "problem": "Consider the Bak–Tang–Wiesenfeld (BTW) Abelian sandpile model on a finite square lattice with open boundary conditions. Let the lattice be of size $L \\times L$ and indexed by pairs $(i,j)$ with $i \\in \\{0, \\ldots, L-1\\}$ and $j \\in \\{0, \\ldots, L-1\\}$. A configuration is an array $z \\in \\mathbb{Z}_{\\ge 0}^{L \\times L}$ of nonnegative integers, where $z_{i,j}$ denotes the number of grains at site $(i,j)$. A site $(i,j)$ is unstable if $z_{i,j} \\ge 4$. The toppling operation $T_{i,j}$ at site $(i,j)$ transforms a configuration $z$ into a new configuration $z'$ by $z'_{i,j} = z_{i,j} - 4$, and for each of the four nearest neighbors $(i-1,j)$, $(i+1,j)$, $(i,j-1)$, $(i,j+1)$ that lie within the lattice, their heights increase by $1$ (grains sent to neighbors outside the lattice are lost to the sink). A configuration is stable if $z_{i,j} < 4$ for all $(i,j)$.\n\nDefine two relaxation procedures that repeatedly apply the toppling operation until a stable configuration is reached:\n- Parallel relaxation: at each discrete time step $t$, simultaneously topple each unstable site exactly once, meaning apply $T_{i,j}$ for all $(i,j)$ with $z_{i,j} \\ge 4$ in that step, and repeat until stable.\n- Sequential relaxation: at each step, select the lexicographically first unstable site (the smallest $(i,j)$ in lexicographic order among those with $z_{i,j} \\ge 4$), apply $T_{i,j}$ only at that site, and repeat until stable.\n\nStarting from the fundamental definition of the BTW model, implement both relaxation procedures and verify empirically, on a small test suite of initial configurations, that the final stable configurations produced by parallel and sequential relaxation are identical. Use open boundary conditions (grains that would be sent to off-lattice neighbors are lost), and use threshold $4$ at every site (that is, a site topples when $z_{i,j} \\ge 4$).\n\nYou must hard-code the following test suite of initial configurations and process each case with both relaxation procedures:\n\n- Case $1$ ($L = 3$): \n$$\nZ^{(1)} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 10 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n$$\n\n- Case $2$ ($L = 4$):\n$$\nZ^{(2)} = \\begin{bmatrix}\n3 & 4 & 0 & 1 \\\\\n2 & 5 & 2 & 3 \\\\\n0 & 1 & 4 & 0 \\\\\n7 & 0 & 0 & 2\n\\end{bmatrix}\n$$\n\n- Case $3$ ($L = 1$):\n$$\nZ^{(3)} = \\begin{bmatrix}\n100\n\\end{bmatrix}\n$$\n\n- Case $4$ ($L = 2$):\n$$\nZ^{(4)} = \\begin{bmatrix}\n0 & 0 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n- Case $5$ ($L = 5$):\n$$\nZ^{(5)} = \\begin{bmatrix}\n0 & 4 & 0 & 4 & 0 \\\\\n4 & 3 & 3 & 3 & 4 \\\\\n0 & 3 & 12 & 3 & 0 \\\\\n4 & 3 & 3 & 3 & 4 \\\\\n0 & 4 & 0 & 4 & 0\n\\end{bmatrix}\n$$\n\nFor each case, compute the final stable configuration produced by parallel relaxation and the final stable configuration produced by sequential relaxation. Compare them for exact equality. The required outputs are booleans that, for each case $k \\in \\{1,2,3,4,5\\}$, indicate whether the two final configurations are identical. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases $1$ through $5$, for example, $[r_1,r_2,r_3,r_4,r_5]$ where each $r_k$ is either $True$ or $False$. No physical units or angle units are involved; all results are dimensionless. No percentages are required.",
            "solution": "The problem requires an empirical verification of a fundamental property of the Bak–Tang–Wiesenfeld (BTW) Abelian sandpile model. Specifically, we must implement two different relaxation procedures—one parallel and one sequential—and confirm that they produce identical final stable configurations from the same initial state.\n\nFirst, we formalize the model as described. The system is defined on a square lattice of size $L \\times L$, with sites indexed by $(i,j)$ where $i, j \\in \\{0, 1, \\ldots, L-1\\}$. Each site $(i,j)$ holds a non-negative integer number of \"grains,\" denoted by $z_{i,j}$. A configuration of the entire system is the matrix $Z = \\{z_{i,j}\\}$.\n\nA site $(i,j)$ is defined as unstable if its height meets or exceeds a critical threshold, $z_{i,j} \\ge z_c$. For this problem, the threshold is $z_c = 4$ for all sites. When a site is unstable, it can \"topple.\" The toppling operation $T_{i,j}$ at site $(i,j)$ redistributes its grains according to the rule:\n$$\nz_{i,j} \\rightarrow z_{i,j} - 4\n$$\n$$\nz_{k,l} \\rightarrow z_{k,l} + 1 \\quad \\text{for each nearest neighbor } (k,l) \\text{ of } (i,j)\n$$\nThe model uses open boundary conditions, meaning that if a site on the edge of the lattice topples, any grains that would be sent to a non-existent neighbor off the lattice are lost from the system. A configuration is stable if all sites are stable, i.e., $z_{i,j} < 4$ for all $(i,j)$.\n\nA key theorem of this model is its Abelian property. This means that for any initial configuration, the final stable configuration reached after all necessary toppling events have occurred is unique and does not depend on the order in which the toppling operations were performed. The set of recurrent configurations forms an Abelian group, hence the name. The problem asks us to verify this property by comparing two specific toppling sequences:\n\n1.  **Sequential Relaxation:** In this procedure, we repeatedly find the first unstable site in lexicographical order (i.e., by scanning rows and then columns) and topple only that site. This process is repeated until no unstable sites remain. The algorithm is as follows:\n    - Step 1: Initialize the system with a given configuration $Z$.\n    - Step 2: Scan the lattice to find the set of all unstable sites, where $z_{i,j} \\ge 4$.\n    - Step 3: If this set is empty, the configuration is stable, and the process terminates.\n    - Step 4: If the set is not empty, select the site $(i,j)$ that comes first in lexicographical order.\n    - Step 5: Apply the toppling operation $T_{i,j}$ to the configuration $Z$.\n    - Step 6: Go back to Step 2.\n\n2.  **Parallel Relaxation:** In this procedure, all unstable sites topple simultaneously in discrete time steps. This means that the state of the grid at time $t+1$ is determined by all the topplings that occur based on the state at time $t$. The algorithm is as follows:\n    - Step 1: Initialize the system with a given configuration $Z(t=0)$.\n    - Step 2: At each time step $t$, identify the set $U_t$ of all unstable sites $(i,j)$ where $z_{i,j}(t) \\ge 4$.\n    - Step 3: If $U_t$ is empty, the system is stable, and the process terminates.\n    - Step 4: Calculate the change in grid configuration, $\\Delta Z(t)$. Every site $(i,j) \\in U_t$ loses $4$ grains. Every site $(i,j)$ gains one grain for each of its neighbors $(k,l)$ that is in $U_t$.\n    - Step 5: The new configuration is $Z(t+1) = Z(t) + \\Delta Z(t)$.\n    - Step 6: Increment $t$ and go back to Step 2.\n\nThe implementation of parallel relaxation can be optimized using vector operations. The update rule can be expressed as:\n$$\nz_{i,j}(t+1) = z_{i,j}(t) - 4 \\cdot \\mathbb{I}((i,j) \\in U_t) + \\sum_{(k,l) \\in N(i,j)} \\mathbb{I}((k,l) \\in U_t)\n$$\nwhere $\\mathbb{I}(\\cdot)$ is the indicator function and $N(i,j)$ is the set of nearest neighbors of $(i,j)$. The summation term is a discrete convolution. If we define a matrix $S_t$ where $S_{t, i,j} = 1$ if $(i,j) \\in U_t$ and $0$ otherwise, the update can be written using a convolution kernel $K$:\n$$\nZ(t+1) = Z(t) - 4 S_t + (S_t * K) \\quad \\text{where} \\quad K = \\begin{pmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{pmatrix}\n$$\nThe convolution must handle the open boundary conditions, which corresponds to padding with zeros.\n\nThe solution will consist of implementing both algorithms, applying them to the five provided test cases, and comparing the final stable matrices for equality. Based on the Abelian property of the BTW model, the expectation is that the final configurations will be identical for both methods in all test cases. The output will be a list of booleans representing the result of this comparison for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef parallel_relaxation(grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Relaxes a sandpile configuration using parallel updates.\n    In each step, all unstable sites topple simultaneously.\n    \"\"\"\n    # Make a copy to avoid modifying the original array from the test suite\n    grid = grid.copy()\n    L = grid.shape[0]\n    \n    # Kernel for convolution to distribute grains to neighbors\n    kernel = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]], dtype=np.int32)\n    threshold = 4\n\n    while np.any(grid >= threshold):\n        # Identify sites that will topple in this step\n        # A site topples once if its height is >= threshold\n        unstable_sites = (grid >= threshold).astype(np.int32)\n        \n        # Grains lost from each site due to toppling\n        grains_out = threshold * unstable_sites\n        \n        # Grains received by each site from its toppling neighbors\n        # The convolution calculates this sum for all sites at once.\n        # 'fill' boundary condition with fillvalue=0 handles open boundaries.\n        grains_in = signal.convolve2d(unstable_sites, kernel, mode='same', boundary='fill', fillvalue=0)\n        \n        # Apply the net change to the grid\n        grid = grid - grains_out + grains_in\n        \n    return grid\n\ndef sequential_relaxation(grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Relaxes a sandpile configuration using sequential updates.\n    In each step, the lexicographically first unstable site topples.\n    \"\"\"\n    # Make a copy to avoid modifying the original array from the test suite\n    grid = grid.copy()\n    L = grid.shape[0]\n    threshold = 4\n\n    while True:\n        # np.argwhere finds indices of non-zero elements, which are True for unstable sites.\n        # The result is already in lexicographical (row-major) order.\n        unstable_indices = np.argwhere(grid >= threshold)\n        \n        if unstable_indices.shape[0] == 0:\n            # No unstable sites, the configuration is stable\n            break\n        \n        # Get the lexicographically first unstable site\n        i, j = unstable_indices[0]\n        \n        # Perform the toppling operation\n        grid[i, j] -= threshold\n        \n        # Distribute grains to neighbors, checking for boundaries\n        if i > 0:\n            grid[i - 1, j] += 1\n        if i < L - 1:\n            grid[i + 1, j] += 1\n        if j > 0:\n            grid[i, j - 1] += 1\n        if j < L - 1:\n            grid[i, j + 1] += 1\n            \n    return grid\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify the Abelian property.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0, 0, 0],\n                  [0, 10, 0],\n                  [0, 0, 0]], dtype=np.int32),\n        np.array([[3, 4, 0, 1],\n                  [2, 5, 2, 3],\n                  [0, 1, 4, 0],\n                  [7, 0, 0, 2]], dtype=np.int32),\n        np.array([[100]], dtype=np.int32),\n        np.array([[0, 0],\n                  [0, 0]], dtype=np.int32),\n        np.array([[0, 4, 0, 4, 0],\n                  [4, 3, 3, 3, 4],\n                  [0, 3, 12, 3, 0],\n                  [4, 3, 3, 3, 4],\n                  [0, 4, 0, 4, 0]], dtype=np.int32),\n    ]\n\n    results = []\n    for initial_config in test_cases:\n        # Run parallel relaxation\n        stable_config_parallel = parallel_relaxation(initial_config)\n        \n        # Run sequential relaxation\n        stable_config_sequential = sequential_relaxation(initial_config)\n        \n        # Compare the final stable configurations for equality\n        are_identical = np.array_equal(stable_config_parallel, stable_config_sequential)\n        results.append(are_identical)\n\n    # Format and print the final results as specified.\n    # The expected output is [True,True,True,True,True] due to the Abelian property.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The state space of a sandpile model is partitioned into transient states and a set of recurrent states that form the system's long-term attractor. To understand the model's critical behavior, it is essential to be able to identify which configurations belong to this recurrent set. This practice introduces Dhar’s burning algorithm, an elegant and powerful tool for making this distinction , allowing you to classify configurations and probe the structure of the system's critical attractor.",
            "id": "4142584",
            "problem": "Consider the Abelian sandpile model on a $2 \\times 2$ square lattice with nearest-neighbor connectivity and a single designated sink at the top-right vertex. Label the vertices by their coordinates $(i,j)$ with $i,j \\in \\{1,2\\}$, and designate the sink as $(2,2)$. The non-sink vertices are $(1,1)$, $(1,2)$, and $(2,1)$. Edges exist between nearest neighbors: $(1,1)$ is adjacent to $(1,2)$ and $(2,1)$; $(1,2)$ is adjacent to $(1,1)$ and the sink $(2,2)$; $(2,1)$ is adjacent to $(1,1)$ and the sink $(2,2)$. The degree of each non-sink vertex (counting edges to the sink) is $2$, so a stable configuration has heights $h(i,j) \\in \\{0,1\\}$ at each non-sink vertex.\n\nConsider the specific stable configuration with heights $h(1,1)=1$, $h(1,2)=1$, and $h(2,1)=0$. Apply Dhar’s burning algorithm to test for recurrence: start by burning the sink; then, at each subsequent round, burn every unburnt vertex $v$ satisfying $h(v) \\geq d_{U}(v)$, where $d_{U}(v)$ denotes the number of edges from $v$ to currently unburnt vertices. Continue until no additional vertices can be burned.\n\nDetermine whether the configuration is recurrent (all non-sink vertices eventually burn) or transient (at least one non-sink vertex remains unburnt at termination). Report the indicator value $I$, where $I=1$ if the configuration is recurrent and $I=0$ if it is transient. The final answer must be a single number $I$. No rounding is required.",
            "solution": "The problem asks us to determine if a given stable configuration of an Abelian sandpile model is recurrent or transient by applying Dhar's burning algorithm. The result is to be expressed as an indicator value $I$, where $I=1$ for a recurrent configuration and $I=0$ for a transient one.\n\nFirst, we establish the components of the system as described.\nThe set of vertices is $V = \\{(1,1), (1,2), (2,1), (2,2)\\}$.\nThe non-sink vertices are $V_{ns} = \\{(1,1), (1,2), (2,1)\\}$.\nThe designated sink is the vertex $s = (2,2)$.\nThe connectivity is as follows:\n- Vertex $(1,1)$ is connected to $(1,2)$ and $(2,1)$.\n- Vertex $(1,2)$ is connected to $(1,1)$ and the sink $(2,2)$.\n- Vertex $(2,1)$ is connected to $(1,1)$ and the sink $(2,2)$.\nThe degree $d(v)$ of each non-sink vertex $v$ is $2$.\nThe initial height configuration is given as:\n- $h(1,1) = 1$\n- $h(1,2) = 1$\n- $h(2,1) = 0$\n\nDhar's burning algorithm is an iterative process to test for recurrence. Let $U$ be the set of unburnt non-sink vertices and $B$ be the set of burnt vertices. The algorithm proceeds as follows:\n1. Initialize the process by burning the sink. So, at round $t=0$, $B_0 = \\{s\\}$ and $U_0 = V_{ns}$.\n2. In each subsequent round $t>0$, a vertex $v \\in U_{t-1}$ is burned if its height $h(v)$ is greater than or equal to its number of unburnt neighbors, $d_{U_{t-1}}(v)$.\n3. The process terminates when no more vertices can be burned in a round.\n4. If the final set of unburnt vertices is empty ($U_{final} = \\emptyset$), the configuration is recurrent. Otherwise, it is transient.\n\nWe now apply this algorithm to the given configuration.\n\n**Round 0 (Initialization):**\nThe sink $s=(2,2)$ is initially burnt.\nThe set of burnt vertices is $B_0 = \\{(2,2)\\}$.\nThe set of unburnt vertices is $U_0 = \\{(1,1), (1,2), (2,1)\\}$.\n\n**Round 1:**\nWe check the burning condition $h(v) \\geq d_{U_0}(v)$ for each vertex $v \\in U_0$. The term $d_{U_0}(v)$ is the number of neighbors of $v$ that are in $U_0$.\n\n- For $v = (1,1)$: The height is $h(1,1) = 1$. Its neighbors are $(1,2)$ and $(2,1)$. Both are in $U_0$. Thus, $d_{U_0}(1,1) = 2$. The condition is $1 \\geq 2$, which is false. Vertex $(1,1)$ does not burn.\n\n- For $v = (1,2)$: The height is $h(1,2) = 1$. Its neighbors are $(1,1)$ and $(2,2)$. The neighbor $(1,1)$ is in $U_0$, but $(2,2)$ is in $B_0$. Thus, $d_{U_0}(1,2) = 1$. The condition is $1 \\geq 1$, which is true. Vertex $(1,2)$ burns.\n\n- For $v = (2,1)$: The height is $h(2,1) = 0$. Its neighbors are $(1,1)$ and $(2,2)$. The neighbor $(1,1)$ is in $U_0$, but $(2,2)$ is in $B_0$. Thus, $d_{U_0}(2,1) = 1$. The condition is $0 \\geq 1$, which is false. Vertex $(2,1)$ does not burn.\n\nAt the end of Round 1, only vertex $(1,2)$ is newly burned.\nThe new set of unburnt vertices is $U_1 = U_0 \\setminus \\{(1,2)\\} = \\{(1,1), (2,1)\\}$.\nThe new set of burnt vertices is $B_1 = B_0 \\cup \\{(1,2)\\} = \\{(2,2), (1,2)\\}$.\n\n**Round 2:**\nWe check the burning condition $h(v) \\geq d_{U_1}(v)$ for each remaining unburnt vertex $v \\in U_1$.\n\n- For $v = (1,1)$: The height is $h(1,1) = 1$. Its neighbors are $(1,2)$ and $(2,1)$. The neighbor $(1,2)$ is now in $B_1$, while $(2,1)$ is in $U_1$. Thus, $d_{U_1}(1,1) = 1$. The condition is $1 \\geq 1$, which is true. Vertex $(1,1)$ burns.\n\n- For $v = (2,1)$: The height is $h(2,1) = 0$. Its neighbors are $(1,1)$ and $(2,2)$. The neighbor $(1,1)$ is currently in $U_1$, while $(2,2)$ is in $B_1$. Thus, $d_{U_1}(2,1) = 1$. The condition is $0 \\geq 1$, which is false. Vertex $(2,1)$ does not burn.\n\nAt the end of Round 2, vertex $(1,1)$ is newly burned.\nThe new set of unburnt vertices is $U_2 = U_1 \\setminus \\{(1,1)\\} = \\{(2,1)\\}$.\nThe new set of burnt vertices is $B_2 = B_1 \\cup \\{(1,1)\\} = \\{(2,2), (1,2), (1,1)\\}$.\n\n**Round 3:**\nWe check the burning condition for the sole remaining unburnt vertex $v = (2,1) \\in U_2$.\n\n- For $v = (2,1)$: The height is $h(2,1) = 0$. Its neighbors are $(1,1)$ and $(2,2)$. Both neighbors are now in $B_2$. Thus, it has no neighbors in $U_2$, so $d_{U_2}(2,1) = 0$. The condition is $0 \\geq 0$, which is true. Vertex $(2,1)$ burns.\n\nAt the end of Round 3, vertex $(2,1)$ is newly burned.\nThe new set of unburnt vertices is $U_3 = U_2 \\setminus \\{(2,1)\\} = \\emptyset$.\nThe final set of burnt vertices is $B_3 = B_2 \\cup \\{(2,1)\\} = \\{(2,2), (1,2), (1,1), (2,1)\\}$, which includes all non-sink vertices.\n\n**Conclusion:**\nThe algorithm terminates because the set of unburnt vertices is empty. Since all non-sink vertices—$(1,1)$, $(1,2)$, and $(2,1)$—were eventually burned, the initial configuration is defined as recurrent.\n\nAccording to the problem statement, the indicator value $I$ is $1$ for a recurrent configuration. Therefore, $I=1$.",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}