{
    "hands_on_practices": [
        {
            "introduction": "对于大多数高维或非线性系统，其吸引盆的边界可能极其复杂，无法通过解析方法求解。这时，计算方法就显得至关重要。本练习将带你设计并实现一个网格采样蒙特卡洛程序，用于估算一个二维连续系统的吸引盆体积分数。通过这个实践，你将学会如何将状态空间“数字化”，并通过数值模拟和统计分析来量化多稳态系统的全局特性。",
            "id": "4144169",
            "problem": "考虑状态空间 $\\mathbb{R}^{2}$ 上的一个确定性连续时间动力系统，由以下常微分方程 (ODE) 定义：\n$$\n\\frac{d}{dt}\\begin{pmatrix}x(t)\\\\y(t)\\end{pmatrix} = \\begin{pmatrix}f_{x}(x(t))\\\\f_{y}(y(t))\\end{pmatrix}, \\quad \\text{其中} \\quad f_{x}(x) = -4\\,x\\,(x^{2}-1), \\quad f_{y}(y) = -4\\,y\\,(y^{2}-1).\n$$\n该系统是势函数 $V(x,y)=(x^{2}-1)^{2}+(y^{2}-1)^{2}$ 的一个梯度流，它在点 $(-1,-1)$、$(-1,+1)$、$(+1,-1)$、$(+1,+1)$ 处表现出多个稳定平衡点（吸引子）。一个吸引子的吸引盆是在流的作用下渐近趋近该吸引子的 $\\mathbb{R}^{2}$ 中所有初始条件的集合。给定一个有界矩形域 $\\Omega=[x_{\\min},x_{\\max}]\\times[y_{\\min},y_{\\max}]$，将吸引子 $a_{j}$ 的吸引盆体积分数定义为 $\\Omega$ 中属于 $a_{j}$ 吸引盆的部分的勒贝格测度除以 $\\Omega$ 的勒贝格测度。\n\n你的任务是设计并实现一个网格采样蒙特卡洛程序，以估计上述 ODE 在指定域上的四个吸引子的吸引盆体积分数，并为给定固定样本数量的估计值推导置信区间。请使用以下原则和约束：\n\n- 基本依据：使用状态空间、吸引子、吸引盆的核心定义，以及用于无偏估计的大数定律。将每个网格单元内的采样视为均匀采样。对于置信区间，对每个吸引子的分数使用二项比例推断，采用置信水平为 $1-\\alpha$ 的 Wilson 得分区间。\n- 网格采样蒙特卡洛设计：将 $\\Omega$ 划分为一个 $G\\times G$ 的等面积单元网格。使用带有固定种子的伪随机数生成器，从每个单元中均匀随机地抽取一个初始条件，以确保可复现性。当 $G$ 固定时，总样本数为 $N=G^{2}$。\n- 轨迹分类：对于每个采样到的初始条件 $(x_{0},y_{0})$，将 ODE 从 $t=0$ 数值积分到一个有限的终端时间 $T>0$。通过将终端状态 $(x(T),y(T))$ 分配给欧几里得距离最近的吸引子来进行分类。如果轨迹进入任何吸引子周围半径为 $\\varepsilon$ 的小邻域，可以提前终止积分。使用具有合理容差的求解器，并通过避免绕过积分的任意捷径来确保科学真实性。\n- 估计和置信区间：令 $n_{j}$ 为分类到吸引子 $a_{j}$ 的样本数，因此估计量 $\\hat{p}_{j}=n_{j}/N$ 是 $a_{j}$ 吸引盆体积分数的网格采样蒙特卡洛估计。为每个 $\\hat{p}_{j}$ 推导并实现置信水平为 $1-\\alpha$ 的 Wilson 得分区间 $[\\ell_{j},u_{j}]$。使用标准正态分位数 $z_{1-\\alpha/2}$。\n- 最终输出格式：对于每个测试用例，输出一个包含四个子列表的列表，对应于固定顺序 $[(-1,-1),(-1,+1),(+1,-1),(+1,+1)]$ 的吸引子。每个子列表必须包含三个浮点数 $[\\hat{p}_{j},\\ell_{j},u_{j}]$。将所有提供的测试用例的结果汇总到单行中，作为一个用方括号括起来的逗号分隔列表，例如 $[[\\cdots],[\\cdots],[\\cdots]]$。\n\n实现程序以解决以下测试套件。每个测试用例是一个元组 $(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)$，使用固定的伪随机种子 $s=1729$：\n\n- 测试用例 1 (正常路径)：$(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)=(-1.5,0.7,-0.9,1.1,20,5.0,10^{-3},0.05)$。这测试了跨越分界线的非对称域。\n- 测试用例 2 (小样本量边缘情况)：$(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)=(-1.2,1.2,-1.2,1.2,5,4.0,10^{-3},0.05)$。这测试了小样本量和更宽的置信区间。\n- 测试用例 3 (主导吸引盆)：$(x_{\\min},x_{\\max},y_{\\min},y_{\\max},G,T,\\varepsilon,\\alpha)=(0.1,1.5,0.2,1.1,10,3.0,10^{-3},0.05)$。这测试了其中一个吸引盆极大概率出现的近简并多项分布结果。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[[\\hat{p}_{1},\\ell_{1},u_{1},\\ldots],[\\cdots],\\ldots]$），但需严格遵循每个测试用例四个 $[\\hat{p}_{j},\\ell_{j},u_{j}]$ 子列表的结构、指定的吸引子顺序，且不含任何其他文本。所有数值输出必须是浮点数。不涉及物理单位或角度；请将所有分数和界限表示为十进制浮点数。",
            "solution": "该问题被评估为有效。它在科学上基于动力系统理论，提供了一个与梯度流对应的定义明确的常微分方程（ODE）。数值程序的所有参数都已指定，确保了问题的适定性和自洽性。任务是实现一个特定的、标准的计算方法（网格采样蒙特卡洛），以估计具有物理意义的量（吸引盆体积分数），并提供统计置信区间（Wilson得分区间），这是一项具体且客观的任务。该问题不违反任何无效标准。\n\n问题的核心是确定给定的初始条件 $(x_0, y_0)$ 在由该 ODE 系统定义的动力学作用下将流向哪个吸引子：\n$$\n\\frac{dx}{dt} = -4x(x^2-1)\n$$\n$$\n\\frac{dy}{dt} = -4y(y^2-1)\n$$\n该系统有四个稳定不动点（吸引子），分别位于 $a_1=(-1,-1)$、$a_2=(-1,+1)$、$a_3=(+1,-1)$ 和 $a_4=(+1,+1)$。每个 $a_j$ 的吸引盆是所有初始条件的集合，其轨迹在 $t \\to \\infty$ 时收敛到 $a_j$。吸引盆的边界是鞍点的稳定流形，在这个解耦系统中，即为直线 $x=0$ 和 $y=0$。\n\n解决方案将以一个 Python 程序的形式实现，其结构如下：\n\n1.  **主循环**：一个主函数 `solve()` 将遍历所有提供的测试用例。对于每个测试用例，它将协调模拟和计算过程。\n\n2.  **各用例模拟**：对于每组参数 $(x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}, G, T, \\varepsilon, \\alpha)$，一个专用函数将执行网格采样蒙特卡洛估计。\n    *   **可复现性**：将为每个测试用例使用指定的固定种子 $s=1729$ 初始化一个伪随机数生成器，以确保结果是确定性的和可复现的。\n    *   **网格与采样**：域 $\\Omega=[x_{\\min}, x_{\\max}]\\times[y_{\\min}, y_{\\max}]$ 被划分为一个 $G \\times G$ 的网格。总样本数将为 $N=G^2$。对于 $N$ 个单元中的每一个，从该单元上的均匀分布中抽取一个初始条件 $(x_0, y_0)$。\n    *   **数值积分**：对于每个初始条件，通过使用 `scipy.integrate.solve_ivp` 对 ODE 系统进行数值积分来计算轨迹。积分从 $t=0$ 运行到最大时间 $T$。\n    *   **提前终止**：如果轨迹进入四个吸引子中任意一个的 $\\varepsilon$-邻域，积分将提前终止。这是通过 `solve_ivp` 的 `events` 特性实现的。定义一个事件函数，用于检测到最近吸引子的欧几里得距离是否小于 $\\varepsilon$。\n    *   **吸引盆分类**：积分结束后（无论是达到时间 $T$ 还是事件被触发），轨迹的最终状态将被分类。它被分配到欧几里得距离最近的吸引子的吸引盆中。该吸引子的计数器 $n_j$ 将递增。\n\n3.  **估计与置信区间**：在一个测试用例的所有 $N$ 个样本都被处理后，每个吸引子 $a_j$ 的吸引盆体积分数被估计为 $\\hat{p}_j = n_j / N$。\n    *   使用 Wilson 得分区间公式计算每个比例 $p_j$ 的 $1-\\alpha$ 置信区间。令 $z = z_{1-\\alpha/2}$ 为标准正态分布的 $(1-\\alpha/2)$-分位数。区间 $[\\ell_j, u_j]$ 由下式给出：\n        $$\n        [\\ell_j, u_j] = \\frac{1}{1 + z^2/N} \\left( \\hat{p}_j + \\frac{z^2}{2N} \\mp z \\sqrt{\\frac{\\hat{p}_j(1-\\hat{p}_j)}{N} + \\frac{z^2}{4N^2}} \\right)\n        $$\n    *   所需的分位数 $z$ 通过 `scipy.stats.norm.ppf` 获得。\n\n4.  **输出格式化**：每个测试用例的结果，由四个形如 $[\\hat{p}_j, \\ell_j, u_j]$ 的子列表组成，将被汇总。最终输出是一个表示所有测试用例结果列表的单个字符串，其格式严格按照问题陈述中的规定。\n\n这个分步过程忠实地实现了要求，将动力系统、数值方法和统计推断的原理结合成一个内聚且正确的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (xmin, xmax, ymin, ymax, G, T, epsilon, alpha)\n        (-1.5, 0.7, -0.9, 1.1, 20, 5.0, 1e-3, 0.05), # Test Case 1\n        (-1.2, 1.2, -1.2, 1.2, 5, 4.0, 1e-3, 0.05),  # Test Case 2\n        (0.1, 1.5, 0.2, 1.1, 10, 3.0, 1e-3, 0.05),   # Test Case 3\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result = run_simulation(*case_params)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list includes spaces, e.g., '[1.0, 2.0]'.\n    # The template `print(f\"[{','.join(map(str, results))}]\")` generates a string\n    # like '[[[...]],[[...]]]', which is a valid representation.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_simulation(x_min, x_max, y_min, y_max, G, T, epsilon, alpha):\n    \"\"\"\n    Performs the grid-sampling Monte Carlo simulation for a single test case.\n    \"\"\"\n    # Fixed parameters\n    seed = 1729\n    attractors = np.array([\n        [-1.0, -1.0],\n        [-1.0, 1.0],\n        [1.0, -1.0],\n        [1.0, 1.0]\n    ])\n\n    # Initialize PRNG for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Define the ODE system\n    def ode_system(t, y):\n        x, y_val = y\n        dxdt = -4.0 * x * (x**2 - 1.0)\n        dydt = -4.0 * y_val * (y_val**2 - 1.0)\n        return np.array([dxdt, dydt])\n\n    # Define the event for early termination\n    def convergence_event(t, y):\n        # Calculate distance to nearest attractor\n        min_dist = np.min([np.linalg.norm(y - a) for a in attractors])\n        return min_dist - epsilon\n    convergence_event.terminal = True\n\n    # Simulation setup\n    N = G * G\n    counts = np.zeros(len(attractors), dtype=int)\n    \n    dx_cell = (x_max - x_min) / G\n    dy_cell = (y_max - y_min) / G\n\n    # Iterate over the grid\n    for i in range(G):\n        for j in range(G):\n            # Define cell boundaries\n            cell_x_min = x_min + i * dx_cell\n            cell_x_max = x_min + (i + 1) * dx_cell\n            cell_y_min = y_min + j * dy_cell\n            cell_y_max = y_min + (j + 1) * dy_cell\n\n            # Sample one initial condition from the cell\n            x0 = rng.uniform(cell_x_min, cell_x_max)\n            y0 = rng.uniform(cell_y_min, cell_y_max)\n            \n            # Integrate the ODE\n            sol = solve_ivp(\n                fun=ode_system,\n                t_span=[0, T],\n                y0=[x0, y0],\n                events=convergence_event,\n                rtol=1e-6,\n                atol=1e-6\n            )\n            \n            # Get the final state\n            final_state = sol.y[:, -1]\n\n            # Classify the trajectory\n            distances = [np.linalg.norm(final_state - a) for a in attractors]\n            closest_attractor_idx = np.argmin(distances)\n            counts[closest_attractor_idx] += 1\n            \n    # Calculate fractions and confidence intervals\n    case_results = []\n    z = norm.ppf(1.0 - alpha / 2.0)\n    \n    for i in range(len(attractors)):\n        n = counts[i]\n        p_hat = n / N\n        \n        # Wilson score interval calculation\n        denominator = 1.0 + z**2 / N\n        center_shifted = p_hat + z**2 / (2.0 * N)\n        spread = z * np.sqrt((p_hat * (1.0 - p_hat)) / N + z**2 / (4.0 * N**2))\n        \n        l_j = (center_shifted - spread) / denominator\n        u_j = (center_shifted + spread) / denominator\n        \n        case_results.append([p_hat, l_j, u_j])\n        \n    return case_results\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在掌握了吸引盆的整体映射之后，我们进一步挑战一个更精细且在复杂自适应系统建模中至关重要的问题：精确地定位不同吸引子之间的边界。本练习将以经典的 FitzHugh-Nagumo 模型为对象，该模型可以同时存在稳定的不动点和极限环这两种不同类型的吸引子。你将设计一个数值方案，通过沿特定方向进行二分法搜索，来找出区分这两种动力学行为的临界边界，这对于理解系统的临界转换和鲁棒性至关重要。",
            "id": "4144135",
            "problem": "考虑二维 FitzHugh–Nagumo 模型，这是复杂自适应系统中可兴奋动力学的一个典范简化，由以下自治常微分方程（ODE）系统给出\n$$\n\\dot v = v - \\frac{v^3}{3} - w + I,\\quad \\dot w = \\epsilon\\,(v + a - b\\,w),\n$$\n其中，$v$ 和 $w$ 分别表示快慢状态变量，而 $\\epsilon$、$a$、$b$、$I$ 是实数参数。在用于复杂自适应系统建模的状态空间分析的背景下，状态空间是所有可能状态 $(v,w)$ 的集合，吸引子是状态空间中轨迹渐近演化所趋向的集合（例如，一个稳定不动点或一个稳定极限环），而吸引盆是渐近趋近某一特定吸引子的初始条件的集合。吸引盆之间的边界（吸引盆边界）将状态空间划分为收敛到不同吸引子的区域。\n\n从状态空间、吸引子和吸引盆的核心定义出发，并仅使用连续时间动力系统的基本性质，设计一个数值方案来近似一个稳定不动点和一个稳定极限环之间的吸引盆边界。你的方案必须基于第一性原理，不预设任何目标公式，并应使用逻辑上合理的方法来区分长时间收敛到不动点与长时间收敛到极限环。\n\n你必须实现一个完整的、可运行的程序，为测试套件中的每个参数集执行以下操作：\n\n1. 通过求解平衡方程并利用雅可比矩阵分析局部稳定性，来确定系统是否至少存在一个稳定不动点。具体来说，一个平衡点 $(v^\\ast, w^\\ast)$ 满足\n$$\nv^\\ast - \\frac{(v^\\ast)^3}{3} - w^\\ast + I = 0,\\quad w^\\ast = \\frac{v^\\ast + a}{b},\n$$\n其局部稳定性由雅可比矩阵\n$$\nJ(v^\\ast,w^\\ast) = \\begin{pmatrix} 1 - (v^\\ast)^2  -1 \\\\ \\epsilon  -\\epsilon\\,b \\end{pmatrix}\n$$\n的特征值具有严格负实部来确定。\n\n2. 如果存在稳定不动点，则沿着一条从 $(v^\\ast, w^\\ast)$ 出发、角度为 $\\theta$（以弧度为单位测量）的射线上近似吸引盆边界。将该射线上的初始条件参数化为\n$$\n(v_0, w_0) = (v^\\ast, w^\\ast) + r\\,(\\cos\\theta, \\sin\\theta),\n$$\n其中 $r \\ge 0$ 是径向距离。在 $r \\in [r_{\\min}, r_{\\max}]$ 上使用区间套分与二分法程序，搜索从稳定不动点到稳定极限环（或反之）的长时间吸引子分类的变化。分类必须通过在足够长的时间跨度上积分 ODE，并应用能够区分不动点和极限环的原则性标准来进行。\n\n3. 对于每个测试用例，输出一个实数，等于沿射线上吸引子分类发生变化的近似临界半径 $r_c$，其精度在指定的容差范围内。如果你的程序无法在给定的区间 $[r_{\\min}, r_{\\max}]$ 和时间跨度内为这样的变化找到区间并定位，则输出浮点数 $-1.0$。\n\n你的实现必须在科学上是合理的，在数值上是自洽的。角度必须以弧度处理。不涉及物理单位，因此不需要单位换算。程序必须生成单行输出，其中包含所有测试用例的结果，形式为逗号分隔的列表，并用方括号括起来，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是如上定义的浮点数。\n\n测试套件：\n为以下四个参数集提供结果，每个参数集指定为元组 $(\\epsilon, a, b, I, \\theta, r_{\\min}, r_{\\max}, \\text{tol}, T)$，其中 $T$ 是积分时间跨度：\n\n- 案例 1（目标为稳定不动点和稳定极限环共存）：$(\\epsilon = 0.01, a = 1.05, b = 0.5, I = 0.5, \\theta = \\pi/4, r_{\\min} = 10^{-3}, r_{\\max} = 4.0, \\text{tol} = 10^{-3}, T = 800)$。\n- 案例 2（接近具有快慢分离的转变点）：$(\\epsilon = 0.01, a = 1.05, b = 0.5, I = 0.35, \\theta = \\pi/3, r_{\\min} = 10^{-3}, r_{\\max} = 4.0, \\text{tol} = 10^{-3}, T = 800)$。\n- 案例 3（典型的极限环区域，无共存的稳定不动点）：$(\\epsilon = 0.08, a = 0.7, b = 0.8, I = 0.8, \\theta = \\pi/6, r_{\\min} = 10^{-3}, r_{\\max} = 3.0, \\text{tol} = 10^{-3}, T = 600)$。\n- 案例 4（典型的稳定不动点区域）：$(\\epsilon = 0.08, a = 0.7, b = 0.8, I = 0.2, \\theta = \\pi/2, r_{\\min} = 10^{-3}, r_{\\max} = 3.0, \\text{tol} = 10^{-3}, T = 600)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$）。",
            "solution": "该问题要求设计并实现一个数值方案，以近似 FitzHugh-Nagumo 系统中稳定不动点和稳定极限环之间的吸引盆边界。该解决方案基于连续时间动力系统的基本原理。该方法分为三个主要部分：识别稳定平衡态，对长期轨迹行为进行分类，以及系统地搜索该行为发生变化的边界。\n\n首先，我们解决不动点的识别和稳定性分析问题。系统的不动点或平衡点是一个状态 $(v^\\ast, w^\\ast)$，在该状态下动力学停止，即时间导数为零：$\\dot{v} = 0$ 且 $\\dot{w} = 0$。对于给定的 FitzHugh-Nagumo 模型，\n$$\n\\dot v = v - \\frac{v^3}{3} - w + I,\n$$\n$$\n\\dot w = \\epsilon\\,(v + a - b\\,w),\n$$\n平衡条件为：\n$$\nv^\\ast - \\frac{(v^\\ast)^3}{3} - w^\\ast + I = 0,\n$$\n$$\n\\epsilon\\,(v^\\ast + a - b\\,w^\\ast) = 0.\n$$\n由于在我们感兴趣的情况下 $\\epsilon \\neq 0$，第二个方程简化为 $v^\\ast + a - b\\,w^\\ast = 0$，从而得到线性关系 $w^\\ast = (v^\\ast + a)/b$。将此代入第一个方程可消去 $w^\\ast$，得到一个关于 $v^\\ast$ 的三次方程：\n$$\nv^\\ast - \\frac{(v^\\ast)^3}{3} - \\frac{v^\\ast + a}{b} + I = 0.\n$$\n将其整理为标准多项式形式，得到：\n$$\n\\frac{1}{3}(v^\\ast)^3 - \\left(1 - \\frac{1}{b}\\right)v^\\ast + \\left(\\frac{a}{b} - I\\right) = 0.\n$$\n这个三次方程的实根对应于系统不动点的 $v$ 坐标。对于每个实根 $v^\\ast$，相应的 $w^\\ast$ 也被确定。\n\n每个不动点 $(v^\\ast, w^\\ast)$ 的局部稳定性是通过在其周围对系统进行线性化来确定的。这通过分析在该不动点处计算的雅可比矩阵 $J$ 的特征值来实现：\n$$\nJ(v^\\ast,w^\\ast) = \\begin{pmatrix} \\frac{\\partial \\dot{v}}{\\partial v}  \\frac{\\partial \\dot{v}}{\\partial w} \\\\ \\frac{\\partial \\dot{w}}{\\partial v}  \\frac{\\partial \\dot{w}}{\\partial w} \\end{pmatrix}_{(v^\\ast,w^\\ast)} = \\begin{pmatrix} 1 - (v^\\ast)^2  -1 \\\\ \\epsilon  -\\epsilon\\,b \\end{pmatrix}.\n$$\n一个不动点是局部稳定的，当且仅当其雅可比矩阵的所有特征值都具有严格为负的实部。对于一个 $2 \\times 2$ 矩阵，Routh-Hurwitz 稳定性判据提供了一个方便的测试方法，无需显式计算特征值：如果雅可比矩阵的迹为负（$\\text{Tr}(J)  0$）且其行列式为正（$\\det(J) > 0$），则稳定性得到保证。\n$$\n\\text{Tr}(J) = (1 - (v^\\ast)^2) - \\epsilon b  0,\n$$\n$$\n\\det(J) = (1 - (v^\\ast)^2)(-\\epsilon b) - (-1)(\\epsilon) = \\epsilon(1 - b + b(v^\\ast)^2) > 0.\n$$\n实现的程序将首先寻找满足这两个不等式的不动点。如果不存在这样的稳定不动点，则后续搜索的前提不成立，该案例的程序将终止。\n\n其次，需要一种有原则的方法来对给定轨迹的长期吸引子进行分类。收敛到不动点和收敛到极限环之间的根本区别在于，在前一种情况下，状态变量接近常数值，而在后一种情况下，它们继续振荡。这可以通过从给定的初始条件 $(v_0, w_0)$ 在足够长的时间跨度 $T$ 上对 ODE 进行数值积分来量化，以使系统稳定到其吸引子上。然后我们分析积分区间的后半部分（例如，时间 $t \\in [T/2, T]$）轨迹的统计特性。其中一个状态变量（例如 $v(t)$）的标准差可以作为一个稳健的度量：\n$$\n\\sigma_v = \\sqrt{\\frac{1}{N-1}\\sum_{i=1}^{N} (v(t_i) - \\bar{v})^2}.\n$$\n如果轨迹收敛到一个稳定不动点，$\\sigma_v$ 将趋近于零（或一个由数值精度决定的小值）。如果它收敛到一个极限环，$\\sigma_v$ 将显著非零。我们建立一个阈值 $\\sigma_{crit}$，如果 $\\sigma_v  \\sigma_{crit}$，则吸引子被分类为不动点；否则，它被分类为极限环。\n\n第三，使用二分搜索算法来定位吸引盆边界。搜索是沿着一条从已发现的稳定不动点 $(v^\\ast, w^\\ast)$ 出发、角度为 $\\theta$ 的射线上进行的。这条射线上的初始条件由它们的径向距离 $r$ 参数化：\n$$\n(v_0(r), w_0(r)) = (v^\\ast, w^\\ast) + r(\\cos\\theta, \\sin\\theta).\n$$\n搜索在区间 $r \\in [r_{\\min}, r_{\\max}]$ 上执行。我们首先验证区间端点处的吸引子类型不同，即一个是固定点，另一个是极限环。这是区间套分条件。假设 $r_{\\min}$ 处的吸引子是不动点（因为 $r_{\\min}$ 很小，靠近射线的起点），我们要求 $r_{\\max}$ 处的吸引子是极限环。如果不满足此条件，则在给定范围内没有找到边界的区间。如果满足条件，我们迭代地将搜索区间 $[r_{low}, r_{high}]$ 减半。在每一步中，我们计算中点 $r_{mid} = (r_{low} + r_{high})/2$ 并对其吸引子进行分类。如果 $r_{mid}$ 处的吸引子与 $r_{low}$ 处的类型相同，我们更新 $r_{low} = r_{mid}$；否则，我们更新 $r_{high} = r_{mid}$。这个过程一直持续到区间宽度 $(r_{high} - r_{low})$ 小于指定的容差 $\\text{tol}$。临界半径 $r_c$ 的最终估计值是最终区间的中点。如果找不到稳定不动点或不满足区间套分条件，则该过程返回一个值 $-1.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Define constants for attractor classification and numerical analysis\nATTRACTOR_FP = 0  # Represents convergence to a fixed point\nATTRACTOR_LC = 1  # Represents convergence to a limit cycle\nCONVERGENCE_STD_THRESHOLD = 1e-4  # Threshold for standard deviation to classify an attractor\n\ndef fhn_ode(t, y, epsilon, a, b, I):\n    \"\"\"\n    Defines the FitzHugh-Nagumo system of ordinary differential equations.\n    \"\"\"\n    v, w = y\n    dv_dt = v - v**3 / 3.0 - w + I\n    dw_dt = epsilon * (v + a - b * w)\n    return [dv_dt, dw_dt]\n\ndef find_stable_fixed_point(epsilon, a, b, I):\n    \"\"\"\n    Finds a stable fixed point of the FitzHugh-Nagumo system for given parameters.\n    Returns the coordinates (v*, w*) of a stable fixed point, or None if none is found.\n    \"\"\"\n    # Define the coefficients of the cubic equation for v*:\n    # (1/3)v^3 - (1 - 1/b)v + (a/b - I) = 0\n    # or v^3 - 3(1 - 1/b)v + 3(a/b - I) = 0\n    coeffs = [1.0/3.0, 0.0, -(1.0 - 1.0/b), (a/b - I)]\n    roots = np.roots(coeffs)\n    \n    # Filter for real roots, as v* must be real.\n    real_roots = roots[np.isreal(roots)].real\n    \n    for v_star in real_roots:\n        # Check stability using Routh-Hurwitz criteria (Tr  0, Det > 0)\n        trace = 1.0 - v_star**2 - epsilon * b\n        determinant = epsilon * (1.0 - b + b * v_star**2)\n        \n        if trace  0 and determinant > 0:\n            w_star = (v_star + a) / b\n            return (v_star, w_star) # Return first stable fixed point found\n            \n    return None # No stable fixed point found\n\ndef classify_attractor(initial_conditions, epsilon, a, b, I, T):\n    \"\"\"\n    Classifies the long-term attractor by integrating the ODE and analyzing the trajectory.\n    Returns ATTRACTOR_FP or ATTRACTOR_LC.\n    \"\"\"\n    # Use a dense output to evaluate the solution efficiently at specific times\n    sol = solve_ivp(\n        fhn_ode,\n        t_span=[0, T],\n        y0=initial_conditions,\n        args=(epsilon, a, b, I),\n        method='RK45',\n        dense_output=True,\n        rtol=1e-6, \n        atol=1e-9\n    )\n    \n    # Analyze the last half of the trajectory to ensure transients have died out\n    eval_times = np.linspace(T / 2.0, T, num=200)\n    trajectory_tail = sol.sol(eval_times)\n    \n    # Use the standard deviation of the v-component as the classification metric\n    v_tail = trajectory_tail[0, :]\n    std_v = np.std(v_tail)\n    \n    if std_v  CONVERGENCE_STD_THRESHOLD:\n        return ATTRACTOR_FP\n    else:\n        return ATTRACTOR_LC\n\ndef solve():\n    \"\"\"\n    Main function to execute the full analysis for each test case.\n    \"\"\"\n    # Test suite parameters:\n    # (epsilon, a, b, I, theta, r_min, r_max, tol, T)\n    test_cases = [\n        (0.01, 1.05, 0.5, 0.5, np.pi/4, 1e-3, 4.0, 1e-3, 800),\n        (0.01, 1.05, 0.5, 0.35, np.pi/3, 1e-3, 4.0, 1e-3, 800),\n        (0.08, 0.7, 0.8, 0.8, np.pi/6, 1e-3, 3.0, 1e-3, 600),\n        (0.08, 0.7, 0.8, 0.2, np.pi/2, 1e-3, 3.0, 1e-3, 600)\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        epsilon, a, b, I, theta, r_min, r_max, tol, T = case\n        \n        # Step 1: Find a stable fixed point to originate the search ray.\n        fp = find_stable_fixed_point(epsilon, a, b, I)\n        \n        if fp is None:\n            # If no stable fixed point, the search cannot be performed as specified.\n            results.append(-1.0)\n            continue\n            \n        v_star, w_star = fp\n        \n        # Define a helper function to classify attractor for a given radius r\n        def get_attractor_type_at_r(r):\n            ic_v = v_star + r * np.cos(theta)\n            ic_w = w_star + r * np.sin(theta)\n            return classify_attractor([ic_v, ic_w], epsilon, a, b, I, T)\n\n        # Step 2: Bracket the boundary.\n        # The search ray originates from the fixed point, so for small r (r_min),\n        # the attractor should be that same fixed point.\n        type_at_rmin = get_attractor_type_at_r(r_min)\n        type_at_rmax = get_attractor_type_at_r(r_max)\n        \n        # If types are the same, no boundary is bracketed in the interval.\n        # Also ensures that the inner point is indeed the fixed point's basin.\n        if type_at_rmin != ATTRACTOR_FP or type_at_rmin == type_at_rmax:\n            results.append(-1.0)\n            continue\n        \n        # Step 3: Perform bisection search.\n        r_low, r_high = r_min, r_max\n        \n        while (r_high - r_low) > tol:\n            r_mid = (r_low + r_high) / 2.0\n            if r_mid == r_low or r_mid == r_high: # Break if precision limit is reached\n                break\n            \n            type_at_rmid = get_attractor_type_at_r(r_mid)\n            \n            if type_at_rmid == ATTRACTOR_FP:\n                # Midpoint is still in the fixed point basin, move the lower bound up.\n                r_low = r_mid\n            else:\n                # Midpoint is in the other basin, move the upper bound down.\n                r_high = r_mid\n                \n        critical_radius = (r_low + r_high) / 2.0\n        results.append(critical_radius)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}