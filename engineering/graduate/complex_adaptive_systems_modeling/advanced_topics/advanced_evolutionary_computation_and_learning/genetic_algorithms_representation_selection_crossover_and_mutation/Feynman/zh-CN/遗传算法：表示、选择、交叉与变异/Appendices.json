{
    "hands_on_practices": [
        {
            "introduction": "在设计遗传算法时，选择合适的表征方法是定义搜索空间的关键第一步。本练习探讨了两种不同的编码方式——实值编码与二进制编码——如何与变异算子相互作用，让您能够通过分析比较它们的“局部性”，并理解搜索空间的结构是如何被探索的。",
            "id": "4124812",
            "problem": "一个研究小组正在通过比较同一凸二次目标上的两种表示法，来对遗传算法（GA）在复杂自适应系统模型中的变异局部性进行基准测试。该目标由 $f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$ 给出，其中 $\\mathbf{x} \\in \\mathbb{R}^d$，$\\boldsymbol{\\mu} \\in \\mathbb{R}^d$，并且 $\\mathbf{A} \\in \\mathbb{R}^{d \\times d}$ 是对称正定矩阵。表示法和变异算子如下：\n\n表示法 R（实值）：每个基因组直接编码 $\\mathbf{x}$。变异是加性高斯变异，$\\mathbf{x}^\\prime = \\mathbf{x} + \\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_d)$，$\\sigma > 0$，$\\mathbf{I}_d$ 是 $d \\times d$ 的单位矩阵。\n\n表示法 B（二进制定点数）：每个坐标用 $m$ 位以分辨率 $\\Delta > 0$ 进行编码，因此最低有效位（Least Significant Bit, LSB）的单位变化对应于该坐标中大小为 $\\Delta$ 的变化。一个小的变异定义为：从 $\\{1, \\dots, d\\}$ 中均匀随机选择一个坐标索引 $i$，然后翻转其 LSB，这会使表现型改变 $\\delta \\mathbf{e}_i$，其中 $\\delta \\in \\{+\\Delta, -\\Delta\\}$ 的概率相等，$\\mathbf{e}_i$ 是第 $i$ 个标准基向量。假设当前的 $\\mathbf{x}$ 严格位于可表示域的内部，因此不会发生边界裁剪。\n\n仅使用期望和凸二次型的一般定义和性质，确定在每种表示法下，给定 $\\mathbf{x}$ 时适应度变化 $f(\\mathbf{x}^\\prime) - f(\\mathbf{x})$ 的精确条件期望，并确定两种编码之间变异局部性的正确比较。在这里，变异局部性被理解为在小的随机扰动下 $f$ 的期望增加量，较小的期望增加量表示在 $\\mathbf{x}$ 附近有更好的局部性。\n\n哪个选项是正确的？\n\nA. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，如果 $\\Delta^2 / d = \\sigma^2$，则两种编码在凸二次型上具有相同的期望适应度变化，因此具有相同的期望变异局部性。\n\nB. 在表示法 R 下，根据高斯分布的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。在表示法 B 下，根据 LSB 翻转的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。因此，对于任何 $\\sigma$ 和 $\\Delta$，两种编码都表现出完全中性。\n\nC. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\sigma^2 \\lambda_{\\max}(\\mathbf{A})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\lambda_{\\min}(\\mathbf{A})$。因此，只要 $\\sigma^2 > \\Delta^2 / (2 d)$，实值编码的局部性就较差。\n\nD. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\Delta^2 \\operatorname{tr}(\\mathbf{A})$。因此，对于任何固定的 $\\sigma$ 和 $\\Delta$，二进制编码的局部性要差一个因子 $d$。\n\nE. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) + \\tfrac{1}{2} \\sigma^2 (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，即使对于固定的 $\\sigma$，随着 $\\mathbf{x}$ 远离 $\\boldsymbol{\\mu}$，实值编码的局部性也会变差。",
            "solution": "在进行求解之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 目标函数：$f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$\n- 变量和参数：$\\mathbf{x}, \\boldsymbol{\\mu} \\in \\mathbb{R}^d$，$\\mathbf{A} \\in \\mathbb{R}^{d \\times d}$ 是一个对称正定矩阵。\n- 表示法 R（实值）：\n  - 编码：直接编码 $\\mathbf{x}$。\n  - 变异：$\\mathbf{x}^\\prime = \\mathbf{x} + \\boldsymbol{\\varepsilon}$，其中扰动 $\\boldsymbol{\\varepsilon}$ 是从多元正态分布 $\\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_d)$ 中抽取的随机变量，$\\sigma > 0$，$\\mathbf{I}_d$ 是 $d \\times d$ 的单位矩阵。\n- 表示法 B（二进制定点数）：\n  - 编码：$\\mathbf{x}$ 的每个坐标都用 $m$ 位以分辨率 $\\Delta > 0$ 进行编码。\n  - 变异：从 $\\{1, \\dots, d\\}$ 中均匀随机选择一个坐标索引 $i$。其最低有效位（LSB）被翻转。在表现型向量 $\\mathbf{x}$ 中产生的变化是 $\\delta \\mathbf{e}_i$，其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量，$\\delta$ 是一个随机变量，满足 $P(\\delta=+\\Delta) = P(\\delta=-\\Delta) = 1/2$。新的表现型是 $\\mathbf{x}^\\prime = \\mathbf{x} + \\delta \\mathbf{e}_i$。\n  - 假设：不发生边界裁剪。\n- 待确定量：对于每种表示法，适应度变化的条件期望 $\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}]$。\n- 变异局部性的定义：$f$ 的期望增加量越小，表示局部性越好。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是适定的、客观的。它利用了线性代数、概率论和演化计算中的标准数学概念。目标函数是一个凸二次型，这是一个标准的基准。变异算子定义明确。表示法 B 的变异定义将 LSB 翻转的效果建模为 $\\pm\\Delta$ 的对称概率变化，这是一个有效的建模选择，确保了问题是自足的，并且无需指定确切的二进制编码方案（例如，二进制补码）即可无歧义地解决。所有必要信息均已提供。\n\n### 步骤 3：结论和行动\n问题陈述是**有效的**。将推导解答。\n\n### 适应度变化期望的推导\n\n让表现型的变化为向量 $\\boldsymbol{\\delta}_{\\text{mut}}$，因此 $\\mathbf{x}^\\prime = \\mathbf{x} + \\boldsymbol{\\delta}_{\\text{mut}}$。适应度的变化是：\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{x} + \\boldsymbol{\\delta}_{\\text{mut}} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} + \\boldsymbol{\\delta}_{\\text{mut}} - \\boldsymbol{\\mu}) - \\tfrac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu}) $$\n令 $\\mathbf{y} = \\mathbf{x} - \\boldsymbol{\\mu}$。表达式变为：\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{y} + \\boldsymbol{\\delta}_{\\text{mut}})^\\top \\mathbf{A} (\\mathbf{y} + \\boldsymbol{\\delta}_{\\text{mut}}) - \\tfrac{1}{2} \\mathbf{y}^\\top \\mathbf{A} \\mathbf{y} $$\n展开第一项：\n$$ \\tfrac{1}{2} (\\mathbf{y}^\\top\\mathbf{A}\\mathbf{y} + \\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} + \\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\mathbf{y} + \\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}) $$\n由于 $\\mathbf{A}$ 是对称的，$\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\mathbf{y} = (\\mathbf{y}^\\top\\mathbf{A}^\\top\\boldsymbol{\\delta}_{\\text{mut}})^\\top = (\\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}})^\\top$。因为这是一个标量，它等于其转置。因此，两个交叉项相等。\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\tfrac{1}{2}(\\mathbf{y}^\\top\\mathbf{A}\\mathbf{y} + 2\\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} + \\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}) - \\tfrac{1}{2}\\mathbf{y}^\\top\\mathbf{A}\\mathbf{y} $$\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} + \\tfrac{1}{2}\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} $$\n取关于 $\\mathbf{x}$（因此也关于 $\\mathbf{y}$）的条件期望：\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\mathbb{E}[\\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}] + \\mathbb{E}[\\tfrac{1}{2}\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}] $$\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\mathbf{y}^\\top\\mathbf{A}\\mathbb{E}[\\boldsymbol{\\delta}_{\\text{mut}}] + \\tfrac{1}{2}\\mathbb{E}[\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}] $$\n\n#### 表示法 R（实值）\n对于此表示法，扰动为 $\\boldsymbol{\\delta}_{\\text{mut}} = \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_d)$。\n扰动的期望为 $\\mathbb{E}[\\boldsymbol{\\varepsilon}] = \\mathbf{0}$。第一项消失：$\\mathbf{y}^\\top\\mathbf{A}\\mathbb{E}[\\boldsymbol{\\varepsilon}] = \\mathbf{0}$。\n对于第二项，我们计算二次型 $\\boldsymbol{\\varepsilon}^\\top\\mathbf{A}\\boldsymbol{\\varepsilon}$ 的期望。使用性质 $\\mathbb{E}[\\mathbf{z}^\\top \\mathbf{M} \\mathbf{z}] = \\operatorname{tr}(\\mathbf{M} \\boldsymbol{\\Sigma}_\\mathbf{z}) + \\boldsymbol{\\mu}_\\mathbf{z}^\\top \\mathbf{M} \\boldsymbol{\\mu}_\\mathbf{z}$，其中 $\\mathbf{z}=\\boldsymbol{\\varepsilon}$，$\\mathbf{M}=\\mathbf{A}$，$\\boldsymbol{\\mu}_\\mathbf{z}=\\mathbf{0}$，以及 $\\boldsymbol{\\Sigma}_\\mathbf{z} = \\sigma^2 \\mathbf{I}_d$。\n$$ \\mathbb{E}[\\boldsymbol{\\varepsilon}^\\top\\mathbf{A}\\boldsymbol{\\varepsilon}] = \\operatorname{tr}(\\mathbf{A} (\\sigma^2 \\mathbf{I}_d)) + \\mathbf{0}^\\top\\mathbf{A}\\mathbf{0} = \\operatorname{tr}(\\sigma^2\\mathbf{A}) = \\sigma^2 \\operatorname{tr}(\\mathbf{A}) $$\n因此，表示法 R 的期望适应度变化为：\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0 + \\tfrac{1}{2}(\\sigma^2 \\operatorname{tr}(\\mathbf{A})) = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) $$\n\n#### 表示法 B（二进制定点数）\n对于此表示法，扰动为 $\\boldsymbol{\\delta}_{\\text{mut}} = \\boldsymbol{\\eta} = \\delta \\mathbf{e}_i$。随机性在于索引 $i \\in \\{1, \\dots, d\\}$（均匀分布）和符号变量 $\\delta \\in \\{+\\Delta, -\\Delta\\}$（均匀分布）。\n首先，我们计算扰动 $\\boldsymbol{\\eta}$ 的期望：\n$$ \\mathbb{E}[\\boldsymbol{\\eta}] = \\mathbb{E}_i[\\mathbb{E}_\\delta[\\delta \\mathbf{e}_i \\mid i]] = \\mathbb{E}_i[\\mathbf{e}_i \\mathbb{E}_\\delta[\\delta]] $$\n$\\delta$ 的期望是 $\\mathbb{E}[\\delta] = (+\\Delta)(1/2) + (-\\Delta)(1/2) = 0$。\n因此，$\\mathbb{E}[\\boldsymbol{\\eta}] = \\mathbf{0}$，第一项 $\\mathbf{y}^\\top\\mathbf{A}\\mathbb{E}[\\boldsymbol{\\eta}]$ 为零。\n对于第二项，我们计算 $\\mathbb{E}[\\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta}]$。\n$$ \\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta} = (\\delta \\mathbf{e}_i)^\\top\\mathbf{A}(\\delta \\mathbf{e}_i) = \\delta^2 (\\mathbf{e}_i^\\top\\mathbf{A}\\mathbf{e}_i) = \\delta^2 A_{ii} $$\n其中 $A_{ii}$ 是 $\\mathbf{A}$ 的第 $i$ 个对角元素。现在我们对 $i$ 和 $\\delta$ 取期望。由于它们是独立的：\n$$ \\mathbb{E}[\\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta}] = \\mathbb{E}[\\delta^2 A_{ii}] = \\mathbb{E}[\\delta^2] \\mathbb{E}[A_{ii}] $$\n$\\delta^2$ 的期望是 $\\mathbb{E}[\\delta^2] = (+\\Delta)^2(1/2) + (-\\Delta)^2(1/2) = \\Delta^2$。\n在 $i$ 的均匀选择下，$A_{ii}$ 的期望是：\n$$ \\mathbb{E}[A_{ii}] = \\sum_{k=1}^d A_{kk} P(i=k) = \\sum_{k=1}^d A_{kk} \\frac{1}{d} = \\frac{1}{d} \\operatorname{tr}(\\mathbf{A}) $$\n结合这些，$\\mathbb{E}[\\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta}] = \\Delta^2 \\frac{1}{d}\\operatorname{tr}(\\mathbf{A})$。\n因此，表示法 B 的期望适应度变化为：\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0 + \\tfrac{1}{2}\\left(\\frac{\\Delta^2}{d}\\operatorname{tr}(\\mathbf{A})\\right) = \\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A}) $$\n\n### 逐项分析\n\nA. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，如果 $\\Delta^2 / d = \\sigma^2$，则两种编码在凸二次型上具有相同的期望适应度变化，因此具有相同的期望变异局部性。\n- 推导出的表示法 R 的表达式为 $\\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$，相符。\n- 推导出的表示法 B 的表达式为 $\\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$，相符。\n- 比较如下：令两个表达式相等，$\\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) = \\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A})$。由于 $\\mathbf{A}$ 是正定的，其迹 $\\operatorname{tr}(\\mathbf{A}) > 0$，所以我们可以除以它和 $\\tfrac{1}{2}$，得到 $\\sigma^2 = \\Delta^2/d$。此条件正确地使两个期望适应度变化相等。关于在该条件下局部性相同的结论是正确的。\n- 结论：**正确**。\n\nB. 在表示法 R 下，根据高斯分布的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。在表示法 B 下，根据 LSB 翻转的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。因此，对于任何 $\\sigma$ 和 $\\Delta$，两种编码都表现出完全中性。\n- 表示法 R 的期望适应度变化是 $\\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$，这是严格为正的，而不是 $0$。变异分布的对称性使得泰勒展开中的一阶项平均为零，但二阶项不为零。\n- 同样，表示法 B 的期望适应度变化是 $\\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A})$，这也是严格为正的，而不是 $0$。\n- 前提是错误的。\n- 结论：**不正确**。\n\nC. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\sigma^2 \\lambda_{\\max}(\\mathbf{A})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\lambda_{\\min}(\\mathbf{A})$。因此，只要 $\\sigma^2 > \\Delta^2 / (2 d)$，实值编码的局部性就较差。\n- 推导出的表达式涉及 $\\operatorname{tr}(\\mathbf{A})$，即特征值之和，而不是最大特征值 $\\lambda_{\\max}(\\mathbf{A})$ 或最小特征值 $\\lambda_{\\min}(\\mathbf{A})$。两个公式都不正确。\n- 结论：**不正确**。\n\nD. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\Delta^2 \\operatorname{tr}(\\mathbf{A})$。因此，对于任何固定的 $\\sigma$ 和 $\\Delta$，二进制编码的局部性要差一个因子 $d$。\n- 表示法 R 的表达式是正确的。\n- 表示法 B 的表达式不正确；它缺少了因子 $1/d$。正确的表达式是 $\\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A})$。\n- 结论是基于错误的前提。\n- 结论：**不正确**。\n\nE. 在表示法 R 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) + \\tfrac{1}{2} \\sigma^2 (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$。在表示法 B 下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，即使对于固定的 $\\sigma$，随着 $\\mathbf{x}$ 远离 $\\boldsymbol{\\mu}$，实值编码的局部性也会变差。\n- 表示法 R 的表达式不正确。我们的推导表明期望适应度变化与 $\\mathbf{x}$ 无关。公式中依赖于 $\\mathbf{x}$ 的项是虚假的。\n- 表示法 B 的表达式是正确的。\n- 结论是基于关于表示法 R 的错误前提。\n- 结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在对个体进行评估后，选择算子决定了哪些个体能够繁殖，从而引导种群向适应度更高的区域移动。本练习要求您从数学上推导并比较两种经典方法的选择压力：线性排序选择和适应度比例选择。 通过分析它们概率分布的方差，您将更深入地理解遗传算法如何在探索与利用之间取得平衡。",
            "id": "4124789",
            "problem": "在复杂自适应系统建模中，遗传算法 (GA) 通过迭代选择、交叉和变异来探索候选解的演化分布。考虑一个由 $N$ 个个体组成的种群，按等级 $i \\in \\{1,2,\\dots,N\\}$ 进行标记，其中 $i=1$ 是最低（最差）适应度，$i=N$ 是最高（最优）适应度，并假设所有适应度值都不同。使用两种选择算子：\n\n1. 由 Baker 定义的线性等级选择，选择压力参数为 $s \\in [1,2]$，其中分配给最高等级的后代期望数量为 $s$，分配给最低等级的为 $2-s$。当归一化为概率时，这意味着 $p_{N} = s/N$ 且 $p_{1} = (2-s)/N$。该分配被约束为等级 $i$ 的线性函数。\n\n2. 在仿射适应度景观 $f_{i} = i$（其中 $i=1,\\dots,N$）上操作的比例选择，因此比例选择概率为 $q_{i} = f_{i} / \\sum_{j=1}^{N} f_{j}$。\n\n仅从这些定义和约束出发，推导线性等级选择的线性分配 $p_{i}$。然后，对于 $p = (p_{1},\\dots,p_{N})$ 和 $q = (q_{1},\\dots,q_{N})$，计算跨索引的种群方差，\n$$\n\\operatorname{Var}(x) = \\frac{1}{N} \\sum_{i=1}^{N} \\left(x_{i} - \\frac{1}{N}\\right)^{2},\n$$\n并通过报告方差比的闭式解析表达式来比较这两种选择算子\n$$\nR(N,s) = \\frac{\\operatorname{Var}(p)}{\\operatorname{Var}(q)}.\n$$\n将您的最终答案表示为关于 $N$ 和 $s$ 的单个简化解析表达式。无需四舍五入。",
            "solution": "该问题要求推导和比较两种遗传算法选择方案：线性等级选择和比例选择的一个特定情况。比较将通过计算它们各自概率分布的方差之比来进行。\n\n首先，我们推导线性等级选择的概率分配 $p_i$。问题指出 $p_i$ 是等级 $i \\in \\{1, 2, \\dots, N\\}$ 的线性函数。我们可以将此关系表示为 $p_i = a \\cdot i + b$，其中 $a$ 和 $b$ 是常数。我们已知最低等级 ($i=1$) 和最高等级 ($i=N$) 的概率：\n$p_1 = (2-s)/N$\n$p_N = s/N$\n\n我们可以通过将这些代入线性方程来求解 $a$ 和 $b$：\n对于 $i=1$：$a(1) + b = \\frac{2-s}{N}$\n对于 $i=N$：$a(N) + b = \\frac{s}{N}$\n\n用第二个方程减去第一个方程得到：\n$a(N-1) = \\frac{s}{N} - \\frac{2-s}{N} = \\frac{2s-2}{N}$\n$a = \\frac{2(s-1)}{N(N-1)}$\n\n或者，更直接地，我们可以使用线的点斜式来表示 $p_i$，在点 $(1, p_1)$ 和 $(N, p_N)$ 之间进行插值。斜率，即我们的常数 $a$，是：\n$$m = \\frac{p_N - p_1}{N-1} = \\frac{s/N - (2-s)/N}{N-1} = \\frac{(2s-2)/N}{N-1} = \\frac{2(s-1)}{N(N-1)}$$\n那么任意等级 $i$ 的概率 $p_i$ 由下式给出：\n$$p_i = p_1 + m(i-1) = \\frac{2-s}{N} + \\frac{2(s-1)}{N(N-1)}(i-1)$$\n我们可以验证 $\\sum_{i=1}^{N} p_i = 1$：\n$$\\sum_{i=1}^{N} p_i = \\sum_{i=1}^{N} \\left(\\frac{2-s}{N}\\right) + \\frac{2(s-1)}{N(N-1)} \\sum_{i=1}^{N} (i-1)$$\n$$= N\\left(\\frac{2-s}{N}\\right) + \\frac{2(s-1)}{N(N-1)} \\sum_{j=0}^{N-1} j$$\n$$= (2-s) + \\frac{2(s-1)}{N(N-1)} \\frac{(N-1)N}{2} = 2-s + s-1 = 1$$\n因此， $p_i$ 的推导是正确的。\n\n接下来，我们推导比例选择的概率分配 $q_i$。适应度给定为 $f_i = i$。概率 $q_i$ 定义为 $q_i = f_i / \\sum_{j=1}^{N} f_j$。\n分母是前 $N$ 个整数的和：\n$$\\sum_{j=1}^{N} f_j = \\sum_{j=1}^{N} j = \\frac{N(N+1)}{2}$$\n因此，概率 $q_i$ 是：\n$$q_i = \\frac{i}{N(N+1)/2} = \\frac{2i}{N(N+1)}$$\n\n现在，我们必须计算每个分布的种群方差，定义为 $\\operatorname{Var}(x) = \\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\frac{1}{N})^2$。两个分布的均值都是 $\\mu = \\frac{1}{N}\\sum x_i = \\frac{1}{N}(1) = \\frac{1}{N}$，因此该公式与概率值的标准种群方差一致。\n\n让我们计算两个分布与均值的偏差，$x_i - 1/N$。\n对于 $p_i$：\n$$p_i - \\frac{1}{N} = \\left(\\frac{2-s}{N} + \\frac{2(s-1)}{N(N-1)}(i-1)\\right) - \\frac{1}{N}$$\n$$= \\frac{1-s}{N} + \\frac{2(s-1)}{N(N-1)}(i-1) = \\frac{s-1}{N} \\left( \\frac{2(i-1)}{N-1} - 1 \\right)$$\n$$= \\frac{s-1}{N} \\left( \\frac{2i - 2 - (N-1)}{N-1} \\right) = \\frac{s-1}{N} \\frac{2i - N - 1}{N-1}$$\n对于 $q_i$：\n$$q_i - \\frac{1}{N} = \\frac{2i}{N(N+1)} - \\frac{1}{N} = \\frac{1}{N} \\left( \\frac{2i}{N+1} - 1 \\right) = \\frac{1}{N} \\frac{2i - (N+1)}{N+1}$$\n\n方差为：\n$$\\operatorname{Var}(p) = \\frac{1}{N} \\sum_{i=1}^{N} \\left( \\frac{s-1}{N} \\frac{2i - N - 1}{N-1} \\right)^2 = \\frac{(s-1)^2}{N^3(N-1)^2} \\sum_{i=1}^{N} (2i - (N+1))^2$$\n$$\\operatorname{Var}(q) = \\frac{1}{N} \\sum_{i=1}^{N} \\left( \\frac{1}{N} \\frac{2i - N - 1}{N+1} \\right)^2 = \\frac{1}{N^3(N+1)^2} \\sum_{i=1}^{N} (2i - (N+1))^2$$\n两个方差表达式都依赖于相同的求和项 $\\sum_{i=1}^{N} (2i - (N+1))^2$。我们来计算这个和。\n$$\\sum_{i=1}^{N} (2i - (N+1))^2 = \\sum_{i=1}^{N} (4i^2 - 4i(N+1) + (N+1)^2)$$\n$$= 4\\sum_{i=1}^{N}i^2 - 4(N+1)\\sum_{i=1}^{N}i + N(N+1)^2$$\n使用标准的幂和公式，$\\sum_{i=1}^N i = \\frac{N(N+1)}{2}$ 和 $\\sum_{i=1}^N i^2 = \\frac{N(N+1)(2N+1)}{6}$：\n$$= 4\\frac{N(N+1)(2N+1)}{6} - 4(N+1)\\frac{N(N+1)}{2} + N(N+1)^2$$\n$$= \\frac{2N(N+1)(2N+1)}{3} - 2N(N+1)^2 + N(N+1)^2$$\n$$= \\frac{2N(N+1)(2N+1)}{3} - N(N+1)^2$$\n$$= N(N+1) \\left( \\frac{2(2N+1)}{3} - (N+1) \\right)$$\n$$= N(N+1) \\left( \\frac{4N+2 - 3N-3}{3} \\right) = N(N+1) \\frac{N-1}{3} = \\frac{N(N^2-1)}{3}$$\n现在我们将此结果代回方差表达式中。\n$$\\operatorname{Var}(p) = \\frac{(s-1)^2}{N^3(N-1)^2} \\left(\\frac{N(N-1)(N+1)}{3}\\right) = \\frac{(s-1)^2(N+1)}{3N^2(N-1)}$$\n$$\\operatorname{Var}(q) = \\frac{1}{N^3(N+1)^2} \\left(\\frac{N(N-1)(N+1)}{3}\\right) = \\frac{N-1}{3N^2(N+1)}$$\n\n最后，我们计算比率 $R(N,s) = \\frac{\\operatorname{Var}(p)}{\\operatorname{Var}(q)}$：\n$$R(N,s) = \\frac{\\frac{(s-1)^2(N+1)}{3N^2(N-1)}}{\\frac{N-1}{3N^2(N+1)}} = \\frac{(s-1)^2(N+1)}{3N^2(N-1)} \\cdot \\frac{3N^2(N+1)}{N-1}$$\n$$R(N,s) = \\frac{(s-1)^2 (N+1)^2}{(N-1)^2}$$\n这可以更紧凑地写成：\n$$R(N,s) = \\left( \\frac{(s-1)(N+1)}{N-1} \\right)^2$$\n这就是方差比的最终简化解析表达式。",
            "answer": "$$\\boxed{\\left(\\frac{(s-1)(N+1)}{N-1}\\right)^{2}}$$"
        },
        {
            "introduction": "遗传算子的设计必须与其所选的表征方法相匹配，以确保生成合法的后代。对于旅行商问题等解是排列组合的优化问题，标准的交叉算子会失效。这个动手编程练习将指导您实现部分匹配交叉（PMX），这是一种为保持基于排列的染色体的完整性而专门设计的经典算子。",
            "id": "4124850",
            "problem": "考虑一个在组合优化问题中使用排列表示法的遗传算法（GA, Genetic Algorithm），其中每条染色体都是一个固定等位基因集的排列。该问题的基础是将排列定义为从一个索引集到等位基因集的双射，以及遗传算法中交叉操作必须保持排列结构的约束。长度为 $n$ 的排列是一个序列 $(x_0,x_1,\\dots,x_{n-1})$，其中来自固定集合 $A$ 的每个等位基因都恰好出现一次。部分映射交叉（PMX, Partially Mapped Crossover）是一种为排列编码的遗传算法设计的交叉算子，它必须保持排列所固有的双射约束。PMX 算子使用两个交叉点来定义两个父代排列子序列之间的映射，并通过重复应用此映射来解决冲突。\n\n您的任务是根据以下原则性约束，为两个父代排列和两个指定的交叉点实现 PMX：\n\n- 表示：每个父代都是大小为 $n$ 的相同等位基因集 $A$ 上的一个排列，意味着两个父代都由相同的 $n$ 个不同等位基因组成，顺序可能不同。\n- 交叉：给定两个交叉点 $c_1$ 和 $c_2$（满足 $0 \\le c_1  c_2 \\le n-1$），PMX 按以下步骤进行：\n  1. 将第一个父代中从索引 $c_1$ 到索引 $c_2$（含两端）的片段复制到第一个子代中，同样地，将第二个父代中相同的片段复制到第二个子代中。\n  2. 在复制的片段中的等位基因之间构建一个映射：对于每个索引 $i \\in \\{c_1,\\dots,c_2\\}$，为第一个子代记录配对 $(p^{(1)}_i \\mapsto p^{(2)}_i)$，为第二个子代记录逆映射 $(p^{(2)}_i \\mapsto p^{(1)}_i)$，其中 $p^{(1)}_i$ 和 $p^{(2)}_i$ 分别表示第一个和第二个父代在索引 $i$ 处的等位基因。\n  3. 对于片段之外的位置，尝试用 $p^{(2)}_j$ 填充第一个子代中位置 $j \\notin [c_1,c_2]$。如果该候选等位基因已存在于第一个子代的复制片段中，则重复应用步骤2中定义的映射，用映射值 $f(x)$ 替换候选等位基因 $x$，直到它不在复制片段中为止，然后将其放入。对第二个子代执行对称操作，使用逆映射和 $p^{(1)}_j$ 作为初始候选基因。\n- 验证：验证每个生成的子代都是等位基因集 $A$ 的一个有效排列，即每个子代长度为 $n$，包含 $A$ 中的每个等位基因恰好一次，从而构成一个双射。\n\n从这些核心定义和约束出发，在一个完整的、可运行的程序中实现 PMX，并为以下测试套件计算子代。对于每个测试用例，输出一个列表，其中包含第一个子代、第一个子代的布尔验证值、第二个子代以及第二个子代的布尔验证值。最终的程序输出必须是包含所有测试用例结果的单行 JSON 数组，且不含空格。\n\n位置使用从零开始的索引，并将所有序列视为其各自等位基因集上的排列。\n\n测试套件：\n- 案例 $1$（具有非平凡映射的一般情况）：\n  - $n = 10$\n  - $P_1 = [9,1,8,4,3,7,6,5,2,10]$\n  - $P_2 = [1,10,3,6,2,8,5,4,9,7]$\n  - $c_1 = 3$, $c_2 = 7$\n- 案例 $2$（交叉片段跨越整个染色体的边界情况）：\n  - $n = 10$\n  - $P_1 = [4,3,2,1,5,6,7,8,9,10]$\n  - $P_2 = [10,9,8,7,6,5,4,3,2,1]$\n  - $c_1 = 0$, $c_2 = 9$\n- 案例 $3$（映射链需要多个解决步骤）：\n  - $n = 8$\n  - $P_1 = [8,3,1,4,5,6,2,7]$\n  - $P_2 = [3,8,5,1,2,7,6,4]$\n  - $c_1 = 2$, $c_2 = 5$\n- 案例 $4$（最小非平凡长度）：\n  - $n = 2$\n  - $P_1 = [2,1]$\n  - $P_2 = [1,2]$\n  - $c_1 = 0$, $c_2 = 1$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个无空格的 JSON 数组形式的结果，每个元素对应一个测试用例的结果，格式为 $[\\text{offspring}_1,\\ \\text{validity}_1,\\ \\text{offspring}_2,\\ \\text{validity}_2]$。每个子代是一个整数列表，每个有效性是一个布尔值。例如，包含两个测试用例的输出应如下所示：$[[[1,2,3],true,[3,2,1],true],[[4,5],true,[5,4],true]]$。",
            "solution": "该问题提出了一个为基于排列的遗传算法实现部分映射交叉（PMX）算子的任务。解决方案必须遵循 PMX 的特定程序性定义并验证生成的子代。该问题具有科学依据、提法明确且客观，提供了清晰的算法规范和可验证的测试套件。因此，该问题是有效的，可以构建一个严谨的、分步的解决方案。\n\n该问题的基础在于组合优化，其中遗传算法被用来在巨大的搜索空间中寻找解决方案。当一个问题的解可以编码为一组项目的排列时（例如，旅行商问题），遗传算法中的染色体就是排列。一个关键的约束是，遗传算子（如交叉和变异）必须保持排列属性；也就是说，由两个有效的排列父代产生的子代也必须是一个有效的排列。标准的交叉算子，如单点或双点交叉，会产生包含重复等位基因的无效子代。PMX 是一种专门设计的算子，旨在克服这一问题，并维持定义排列的从索引集到等位基因集的双射关系。\n\n设两个父代排列为 $p^{(1)}$ 和 $p^{(2)}$，两者长度均为 $n$，均基于等位基因集 $A$。设两个交叉点为 $c_1$ 和 $c_2$，满足约束 $0 \\le c_1  c_2 \\le n-1$。PMX 算法按以下步骤生成两个子代 $o^{(1)}$ 和 $o^{(2)}$。\n\n**步骤1：片段复制**\n\nPMX 的核心在于交换两个父代之间的一个片段。为每个子代创建一个初始为空的子代模板。将 $p^{(1)}$ 中索引 $c_1$ 和 $c_2$ 之间（含两端）的染色体片段直接复制到第一个子代 $o^{(1)}$ 的相应位置。对称地，将 $p^{(2)}$ 中相同索引之间的片段复制到第二个子代 $o^{(2)}$ 中。\n\n对于 $i \\in \\{c_1, \\dots, c_2\\}$:\n$$o^{(1)}_i = p^{(1)}_i$$\n$$o^{(2)}_i = p^{(2)}_i$$\n\n**步骤2：映射构建**\n\n复制的片段定义了它们所含等位基因之间的映射。对于交叉片段内的每个索引 $i$，我们在来自 $p^{(1)}$ 的等位基因和来自 $p^{(2)}$ 的等位基因之间建立双向对应关系。这个映射是解决填充染色体其余部分时出现冲突的关键。\n\n为生成子代 $o^{(1)}$，创建一个映射 $M_{1 \\to 2}$：\n$$M_{1 \\to 2} = \\{ (p^{(1)}_i, p^{(2)}_i) \\mid i \\in \\{c_1, \\dots, c_2\\} \\}$$\n这可以读作“$p^{(1)}_i$ 映射到 $p^{(2)}_i$”。\n\n为生成子代 $o^{(2)}$，创建逆映射 $M_{2 \\to 1}$：\n$$M_{2 \\to 1} = \\{ (p^{(2)}_i, p^{(1)}_i) \\mid i \\in \\{c_1, \\dots, c_2\\} \\}$$\n\n**步骤3：带冲突解决的等位基因填充**\n\n填充每个子代中的剩余位置（即在范围 $[c_1, c_2]$ 之外的位置）。基本思想是从*另一个*父代获取等位基因。然而，如果该等位基因已经是步骤1中复制的片段的一部分，这可能会引入重复。步骤2中的映射用于解决此类冲突。\n\n要填充 $o^{(1)}$ 中索引 $j \\notin [c_1, c_2]$ 的位置：\n1.  初始候选等位基因取自第二个父代，$x = p^{(2)}_j$。\n2.  执行检查，看该候选基因 $x$ 是否已存在于从 $p^{(1)}$ 复制到 $o^{(1)}$ 的片段中。这等同于检查 $x$ 是否是映射 $M_{1 \\to 2}$ 中的一个键。\n3.  如果 $x$ 不在复制的片段中，则它是该位置的有效等位基因。我们设置 $o^{(1)}_j = x$。\n4.  如果 $x$ 存在，则存在冲突。等位基因 $x$ 已经在 $o^{(1)}$ 的某个位置 $k \\in [c_1, c_2]$ 处。为解决此问题，我们使用映射 $M_{1 \\to 2}$ 来寻找新的候选基因。我们设置 $x' = M_{1 \\to 2}(x)$ 并用这个新的候选基因 $x'$ 重复步骤2的检查。这个过程持续进行，形成一个“映射链”，直到找到一个不会产生冲突的候选基因。这个最终的非冲突等位基因被放置在位置 $j$，即 $o^{(1)}_j = x_{\\text{final}}$。\n\n填充 $o^{(2)}$ 的过程是对称的。对于索引 $j \\notin [c_1, c_2]$：\n1.  初始候选等位基因为 $y = p^{(1)}_j$。\n2.  检查 $y$ 是否存在于从 $p^{(2)}$ 复制到 $o^{(2)}$ 的片段中，这等同于检查 $y$ 是否是映射 $M_{2 \\to 1}$ 中的一个键。\n3.  如果没有冲突，设置 $o^{(2)}_j = y$。\n4.  如果存在冲突，找到新的候选基因 $y' = M_{2 \\to 1}(y)$ 并重复检查，直到找到一个非冲突的等位基因并放置它。\n\n这种冲突解决机制保证了没有等位基因被复制，从而保持了排列属性。\n\n**步骤4：验证**\n\n最后要求的步骤是验证每个生成的子代 $o^{(1)}$ 和 $o^{(2)}$ 都是原始等位基因集 $A$ 的有效排列。一个有效的排列必须满足两个条件：\n1.  其长度必须为 $n$，与父代相同。\n2.  其组成等位基因的集合必须与原始等位基因集 $A$ 相同。即 $\\text{set}(o) = A$。这一项检查即可确认所有原始等位基因都存在且没有重复项。\n\n通过严格遵循这些步骤，可以正确实现 PMX 算子，从有效的排列父代生成有效的排列子代。",
            "answer": "```python\nimport numpy as np\n\ndef is_valid_permutation(perm, original_set):\n    \"\"\"\n    Validates if a list is a valid permutation of a given set of alleles.\n    A valid permutation must have the same number of elements and the exact same\n    set of unique elements as the original.\n    \"\"\"\n    return len(perm) == len(original_set) and set(perm) == original_set\n\ndef pmx_crossover(p1, p2, c1, c2):\n    \"\"\"\n    Performs Partially Mapped Crossover (PMX) on two parent permutations.\n\n    Args:\n        p1 (list): The first parent permutation.\n        p2 (list): The second parent permutation.\n        c1 (int): The first crossover point (inclusive).\n        c2 (int): The second crossover point (inclusive).\n\n    Returns:\n        tuple: A tuple containing the two offspring permutations.\n    \"\"\"\n    n = len(p1)\n    # Initialize offspring with None placeholders\n    o1 = [None] * n\n    o2 = [None] * n\n\n    # Step 1: Copy the crossover segments directly\n    o1[c1:c2 + 1] = p1[c1:c2 + 1]\n    o2[c1:c2 + 1] = p2[c1:c2 + 1]\n\n    # Step 2: Create the mappings based on the segments\n    map1_to_2 = {p1[i]: p2[i] for i in range(c1, c2 + 1)}\n    map2_to_1 = {p2[i]: p1[i] for i in range(c1, c2 + 1)}\n\n    # Step 3: Fill the remaining positions for Offspring 1\n    for i in list(range(c1)) + list(range(c2 + 1, n)):\n        candidate = p2[i]\n        # Resolve conflicts by following the mapping chain\n        while candidate in map1_to_2:\n            candidate = map1_to_2[candidate]\n        o1[i] = candidate\n\n    # Step 3 (symmetric): Fill the remaining positions for Offspring 2\n    for i in list(range(c1)) + list(range(c2 + 1, n)):\n        candidate = p1[i]\n        # Resolve conflicts by following the mapping chain\n        while candidate in map2_to_1:\n            candidate = map2_to_1[candidate]\n        o2[i] = candidate\n        \n    return o1, o2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general)\n        ([9, 1, 8, 4, 3, 7, 6, 5, 2, 10], [1, 10, 3, 6, 2, 8, 5, 4, 9, 7], 3, 7),\n        # Case 2 (boundary)\n        ([4, 3, 2, 1, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 0, 9),\n        # Case 3 (mapping chain)\n        ([8, 3, 1, 4, 5, 6, 2, 7], [3, 8, 5, 1, 2, 7, 6, 4], 2, 5),\n        # Case 4 (minimal nontrivial)\n        ([2, 1], [1, 2], 0, 1),\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        p1, p2, c1, c2 = case\n        original_allele_set = set(p1)\n\n        o1, o2 = pmx_crossover(p1, p2, c1, c2)\n\n        valid1 = is_valid_permutation(o1, original_allele_set)\n        valid2 = is_valid_permutation(o2, original_allele_set)\n\n        # Manually construct JSON-like string to avoid spaces and format booleans correctly\n        o1_str = f\"[{','.join(map(str, o1))}]\"\n        v1_str = str(valid1).lower()\n        o2_str = f\"[{','.join(map(str, o2))}]\"\n        v2_str = str(valid2).lower()\n        \n        result_str = f\"[{o1_str},{v1_str},{o2_str},{v2_str}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format (no spaces)\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}