{
    "hands_on_practices": [
        {
            "introduction": "遗传算法的一个核心挑战是为特定的问题表示设计有效的遗传算子。在处理旅行商问题等组合优化问题时，解通常被编码为排列。本练习将指导您动手实现部分匹配交叉（PMX）算子，这是一个确保子代染色体保持有效排列结构的关键技术，对于将遗传算法应用于广泛的组合优化问题至关重要。",
            "id": "4124850",
            "problem": "考虑一个在组合优化中使用排列表示的遗传算法 (GA, Genetic Algorithm)，其中每个染色体是一个固定等位基因集的排列。此问题的基本原理是将排列定义为从索引集到等位基因集的双射，以及遗传算法中交叉操作必须保持排列结构的约束。一个长度为 $n$ 的排列是一个序列 $(x_0,x_1,\\dots,x_{n-1})$，其中来自固定集合 $A$ 的每个等位基因恰好出现一次。部分映射交叉 (PMX, Partially Mapped Crossover) 是一种为排列编码的遗传算法设计的交叉算子，它必须保持排列固有的双射约束。PMX 算子使用两个交叉点来定义两个父代排列子序列之间的映射，并通过重复应用此映射来解决冲突。\n\n你的任务是根据以下原则性约束，为两个父代排列和两个指定的交叉点实现 PMX：\n\n- 表示：每个父代都是大小为 $n$ 的相同等位基因集 $A$ 上的一个排列，意味着两个父代都由相同的 $n$ 个不同等位基因组成，顺序可能不同。\n- 交叉：给定两个交叉点 $c_1$ 和 $c_2$，满足 $0 \\le c_1  c_2 \\le n-1$，PMX 按以下步骤进行：\n  1. 将第一个父代中从索引 $c_1$ 到索引 $c_2$（含两端）的片段复制到第一个子代中，同样地，将第二个父代中的相同片段复制到第二个子代中。\n  2. 在复制的片段中的等位基因之间构建一个映射：对于每个索引 $i \\in \\{c_1,\\dots,c_2\\}$，为第一个子代记录配对 $(p^{(1)}_i \\mapsto p^{(2)}_i)$，为第二个子代记录逆映射 $(p^{(2)}_i \\mapsto p^{(1)}_i)$，其中 $p^{(1)}_i$ 和 $p^{(2)}_i$ 分别表示第一个和第二个父代在索引 $i$ 处的等位基因。\n  3. 对于片段之外的位置，尝试用 $p^{(2)}_j$ 填充第一个子代的位置 $j \\notin [c_1,c_2]$。如果这个候选等位基因已经存在于第一个子代的复制片段中，则重复应用步骤 2 中定义的映射，用映射值 $f(x)$ 替换候选等位基因 $x$，直到它不在复制片段中，然后将其放入。对第二个子代执行对称操作，使用逆映射和 $p^{(1)}_j$ 作为初始候选基因。\n- 验证：验证每个生成的子代都是等位基因集 $A$ 的一个有效排列，即每个子代长度为 $n$，包含 $A$ 中的每个等位基因恰好一次，从而构成一个双射。\n\n从这些核心定义和约束出发，在一个完整的、可运行的程序中实现 PMX，并为以下测试套件计算子代。对于每个测试用例，输出一个列表，其中包含第一个子代、第一个子代的布尔值验证结果、第二个子代以及第二个子代的布尔值验证结果。最终的程序输出必须是单行，内容是一个包含所有测试用例结果的 JSON 数组，不含空格。\n\n位置使用从零开始的索引，并将所有序列视为其各自等位基因集上的排列。\n\n测试套件：\n- 案例 1（具有非平凡映射的一般情况）：\n  - $n = 10$\n  - $P_1 = [9,1,8,4,3,7,6,5,2,10]$\n  - $P_2 = [1,10,3,6,2,8,5,4,9,7]$\n  - $c_1 = 3$, $c_2 = 7$\n- 案例 2（交叉片段跨越整个染色体的边界情况）：\n  - $n = 10$\n  - $P_1 = [4,3,2,1,5,6,7,8,9,10]$\n  - $P_2 = [10,9,8,7,6,5,4,3,2,1]$\n  - $c_1 = 0$, $c_2 = 9$\n- 案例 3（映射链需要多个解决步骤）：\n  - $n = 8$\n  - $P_1 = [8,3,1,4,5,6,2,7]$\n  - $P_2 = [3,8,5,1,2,7,6,4]$\n  - $c_1 = 2$, $c_2 = 5$\n- 案例 4（最小非平凡长度）：\n  - $n = 2$\n  - $P_1 = [2,1]$\n  - $P_2 = [1,2]$\n  - $c_1 = 0$, $c_2 = 1$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个无空格的 JSON 数组形式的结果，每个元素对应一个测试用例的结果，格式为 $[\\text{子代}_1,\\ \\text{有效性}_1,\\ \\text{子代}_2,\\ \\text{有效性}_2]$。每个子代是一个整数列表，每个有效性是一个布尔值。例如，一个包含两个测试用例的输出应如下所示：$[[[1,2,3],true,[3,2,1],true],[[4,5],true,[5,4],true]]$。",
            "solution": "该问题提出了为基于排列的遗传算法实现部分映射交叉 (PMX) 算子的任务。解决方案必须遵循 PMX 的特定过程定义，并验证生成的子代。该问题具有科学依据、适定且客观，提供了清晰的算法规范和可验证的测试套件。因此，该问题是有效的，可以构建一个严谨的、分步的解决方案。\n\n此问题的基础在于组合优化，其中遗传算法被用于在巨大的搜索空间中寻找解决方案。当一个问题的解决方案可以编码为一组项目的排列时（例如，旅行商问题），遗传算法中的染色体就是排列。一个关键的约束是，遗传算子（如交叉和变异）必须保持排列属性；也就是说，由两个有效的排列父代产生的子代也必须是有效的排列。标准的交叉算子，如单点或双点交叉，会产生包含重复等位基因的无效子代。PMX 是一种专门设计的算子，旨在克服这个问题，并维持定义排列的从索引集到等位基因集的双射关系。\n\n设两个父代排列为 $p^{(1)}$ 和 $p^{(2)}$，两者都是在等位基因集 $A$ 上的长度为 $n$ 的排列。设两个交叉点为 $c_1$ 和 $c_2$，约束条件为 $0 \\le c_1  c_2 \\le n-1$。PMX 算法按以下步骤生成两个子代 $o^{(1)}$ 和 $o^{(2)}$。\n\n**步骤 1：片段复制**\n\nPMX 的核心在于交换两个父代之间的一个片段。为每个子代创建一个初始为空的子代模板。将 $p^{(1)}$ 中索引 $c_1$ 和 $c_2$ 之间（含两端）的染色体片段直接复制到第一个子代 $o^{(1)}$ 的相应位置。对称地，将 $p^{(2)}$ 中相同索引之间的片段复制到第二个子代 $o^{(2)}$ 中。\n\n对于 $i \\in \\{c_1, \\dots, c_2\\}$：\n$$o^{(1)}_i = p^{(1)}_i$$\n$$o^{(2)}_i = p^{(2)}_i$$\n\n**步骤 2：映射构建**\n\n复制的片段定义了它们所包含的等位基因之间的映射。对于交叉片段内的每个索引 $i$，我们在来自 $p^{(1)}$ 的等位基因和来自 $p^{(2)}$ 的等位基因之间建立一种双向对应关系。这个映射是解决填充染色体其余部分时出现冲突的关键。\n\n为生成子代 $o^{(1)}$，创建一个映射 $M_{1 \\to 2}$：\n$$M_{1 \\to 2} = \\{ (p^{(1)}_i, p^{(2)}_i) \\mid i \\in \\{c_1, \\dots, c_2\\} \\}$$\n这可以读作“$p^{(1)}_i$ 映射到 $p^{(2)}_i$”。\n\n为生成子代 $o^{(2)}$，创建逆映射 $M_{2 \\to 1}$：\n$$M_{2 \\to 1} = \\{ (p^{(2)}_i, p^{(1)}_i) \\mid i \\in \\{c_1, \\dots, c_2\\} \\}$$\n\n**步骤 3：带冲突解决的等位基因填充**\n\n每个子代中的剩余位置（即在范围 $[c_1, c_2]$ 之外的位置）将被填充。基本思想是从*另一个*父代获取等位基因。然而，如果该等位基因已经是步骤 1 中复制的片段的一部分，这可能会引入重复。步骤 2 中的映射用于解决此类冲突。\n\n要填充 $o^{(1)}$ 中索引 $j \\notin [c_1, c_2]$ 的位置：\n1.  初始候选等位基因取自第二个父代，$x = p^{(2)}_j$。\n2.  检查该候选基因 $x$ 是否已存在于从 $p^{(1)}$ 复制到 $o^{(1)}$ 的片段中。这等同于检查 $x$ 是否是映射 $M_{1 \\to 2}$ 中的一个键。\n3.  如果 $x$ 不在复制的片段中，则它是该位置的有效等位基因。我们设置 $o^{(1)}_j = x$。\n4.  如果 $x$ 存在，则存在冲突。等位基因 $x$ 已在 $o^{(1)}$ 的某个位置 $k \\in [c_1, c_2]$。为解决此问题，我们使用映射 $M_{1 \\to 2}$ 来寻找新的候选基因。我们设置 $x' = M_{1 \\to 2}(x)$，并用这个新候选基因 $x'$ 重复步骤 2 的检查。此过程持续进行，形成一个“映射链”，直到找到一个不产生冲突的候选基因。这个最终的无冲突等位基因被放置在位置 $j$，即 $o^{(1)}_j = x_{\\text{final}}$。\n\n填充 $o^{(2)}$ 的过程是对称的。对于索引 $j \\notin [c_1, c_2]$：\n1.  初始候选等位基因是 $y = p^{(1)}_j$。\n2.  检查 $y$ 是否存在于从 $p^{(2)}$ 复制到 $o^{(2)}$ 的片段中，这等同于检查 $y$ 是否是映射 $M_{2 \\to 1}$ 中的一个键。\n3.  如果没有冲突，设置 $o^{(2)}_j = y$。\n4.  如果有冲突，找到新的候选基因 $y' = M_{2 \\to 1}(y)$，并重复检查，直到找到一个无冲突的等位基因并将其放置。\n\n这种冲突解决机制保证了没有等位基因被复制，从而保持了排列属性。\n\n**步骤 4：验证**\n\n最后必需的步骤是验证每个生成的子代 $o^{(1)}$ 和 $o^{(2)}$ 是否是原始等位基因集 $A$ 的有效排列。一个有效的排列必须满足两个条件：\n1.  其长度必须为 $n$，与父代相同。\n2.  其构成等位基因的集合必须与原始等位基因集 $A$ 相同。即 $\\text{set}(o) = A$。这一个检查即可确认所有原始等位基因都存在且没有重复。\n\n通过严格遵循这些步骤，可以实现 PMX 算子的正确实现，从而从有效的排列父代生成有效的排列子代。",
            "answer": "```python\nimport numpy as np\n\ndef is_valid_permutation(perm, original_set):\n    \"\"\"\n    Validates if a list is a valid permutation of a given set of alleles.\n    A valid permutation must have the same number of elements and the exact same\n    set of unique elements as the original.\n    \"\"\"\n    return len(perm) == len(original_set) and set(perm) == original_set\n\ndef pmx_crossover(p1, p2, c1, c2):\n    \"\"\"\n    Performs Partially Mapped Crossover (PMX) on two parent permutations.\n\n    Args:\n        p1 (list): The first parent permutation.\n        p2 (list): The second parent permutation.\n        c1 (int): The first crossover point (inclusive).\n        c2 (int): The second crossover point (inclusive).\n\n    Returns:\n        tuple: A tuple containing the two offspring permutations.\n    \"\"\"\n    n = len(p1)\n    # Initialize offspring with None placeholders\n    o1 = [None] * n\n    o2 = [None] * n\n\n    # Step 1: Copy the crossover segments directly\n    o1[c1:c2 + 1] = p1[c1:c2 + 1]\n    o2[c1:c2 + 1] = p2[c1:c2 + 1]\n\n    # Step 2: Create the mappings based on the segments\n    map1_to_2 = {p1[i]: p2[i] for i in range(c1, c2 + 1)}\n    map2_to_1 = {p2[i]: p1[i] for i in range(c1, c2 + 1)}\n\n    # Step 3: Fill the remaining positions for Offspring 1\n    for i in list(range(c1)) + list(range(c2 + 1, n)):\n        candidate = p2[i]\n        # Resolve conflicts by following the mapping chain\n        while candidate in map1_to_2:\n            candidate = map1_to_2[candidate]\n        o1[i] = candidate\n\n    # Step 3 (symmetric): Fill the remaining positions for Offspring 2\n    for i in list(range(c1)) + list(range(c2 + 1, n)):\n        candidate = p1[i]\n        # Resolve conflicts by following the mapping chain\n        while candidate in map2_to_1:\n            candidate = map2_to_1[candidate]\n        o2[i] = candidate\n        \n    return o1, o2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general)\n        ([9, 1, 8, 4, 3, 7, 6, 5, 2, 10], [1, 10, 3, 6, 2, 8, 5, 4, 9, 7], 3, 7),\n        # Case 2 (boundary)\n        ([4, 3, 2, 1, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 0, 9),\n        # Case 3 (mapping chain)\n        ([8, 3, 1, 4, 5, 6, 2, 7], [3, 8, 5, 1, 2, 7, 6, 4], 2, 5),\n        # Case 4 (minimal nontrivial)\n        ([2, 1], [1, 2], 0, 1),\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        p1, p2, c1, c2 = case\n        original_allele_set = set(p1)\n\n        o1, o2 = pmx_crossover(p1, p2, c1, c2)\n\n        valid1 = is_valid_permutation(o1, original_allele_set)\n        valid2 = is_valid_permutation(o2, original_allele_set)\n\n        # Manually construct JSON-like string to avoid spaces and format booleans correctly\n        o1_str = f\"[{','.join(map(str, o1))}]\"\n        v1_str = str(valid1).lower()\n        o2_str = f\"[{','.join(map(str, o2))}]\"\n        v2_str = str(valid2).lower()\n        \n        result_str = f\"[{o1_str},{v1_str},{o2_str},{v2_str}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format (no spaces)\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "表示方案（例如二进制编码与实值编码）和变异算子的选择深刻影响遗传算法的搜索行为。一个关键属性是“局部性”，即基因型中的微小变化如何转化为适应度景观中的相应变化。本练习将通过在一个标准二次型适应度函数上，分析比较二进制编码和实值编码，来帮助您深入理解变异局部性的概念，并定量地揭示不同表示方案如何影响进化搜索的平滑度和效率。",
            "id": "4124812",
            "problem": "一个研究小组正在为复杂自适应系统模型中的遗传算法（GA）的变异局部性进行基准测试，方法是在同一个凸二次目标函数上比较两种表示方法。目标函数由 $f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$ 给出，其中 $\\mathbf{x} \\in \\mathbb{R}^d$，$\\boldsymbol{\\mu} \\in \\mathbb{R}^d$，并且 $\\mathbf{A} \\in \\mathbb{R}^{d \\times d}$ 是一个对称正定矩阵。表示方法和变异算子如下：\n\n表示 R（实数值）：每个基因组直接编码 $\\mathbf{x}$。变异是加性高斯变异，$\\mathbf{x}^\\prime = \\mathbf{x} + \\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_d)$，$\\sigma  0$ 且 $\\mathbf{I}_d$ 是 $d \\times d$ 单位矩阵。\n\n表示 B（二进制定点）：每个坐标用 $m$ 个比特以分辨率 $\\Delta  0$ 进行编码，因此最低有效位（Least Significant Bit, LSB）的单位变化对应于该坐标上大小为 $\\Delta$ 的变化。一次小变异定义为：从 $\\{1, \\dots, d\\}$ 中均匀随机选择一个坐标索引 $i$，然后翻转其 LSB，这将使表现型改变 $\\delta \\mathbf{e}_i$，其中 $\\delta \\in \\{+\\Delta, -\\Delta\\}$ 的概率相等，$\\mathbf{e}_i$ 是第 $i$ 个标准基向量。假设当前的 $\\mathbf{x}$ 严格位于可表示域的内部，因此不会发生边界截断。\n\n仅使用期望和凸二次型的一般定义和性质，确定在每种表示下适应度变化 $f(\\mathbf{x}^\\prime) - f(\\mathbf{x})$ 的精确条件期望（给定 $\\mathbf{x}$），并确定两种编码之间变异局部性的正确比较。在此，变异局部性被理解为在小的随机扰动下 $f$ 的期望增量，较小的期望增量表示在 $\\mathbf{x}$ 附近有更好的局部性。\n\n哪个选项是正确的？\n\nA. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，如果 $\\Delta^2 / d = \\sigma^2$，两种编码具有相同的期望适应度变化，因而在该凸二次型上具有相同的期望变异局部性。\n\nB. 在表示 R下，由于高斯分布的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。在表示 B下，由于 LSB 翻转的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。因此，对于任何 $\\sigma$ 和 $\\Delta$，两种编码都表现出完美的中心性。\n\nC. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\sigma^2 \\lambda_{\\max}(\\mathbf{A})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\lambda_{\\min}(\\mathbf{A})$。因此，只要 $\\sigma^2  \\Delta^2 / (2 d)$，实数值编码的局部性就较差。\n\nD. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\Delta^2 \\operatorname{tr}(\\mathbf{A})$。因此，对于任何固定的 $\\sigma$ 和 $\\Delta$，二进制编码的局部性要差 $d$ 倍。\n\nE. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) + \\tfrac{1}{2} \\sigma^2 (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，即使对于固定的 $\\sigma$，当 $\\mathbf{x}$ 远离 $\\boldsymbol{\\mu}$ 时，实数值编码的局部性也会变差。",
            "solution": "在进行求解之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 目标函数：$f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$\n- 变量和参数：$\\mathbf{x}, \\boldsymbol{\\mu} \\in \\mathbb{R}^d$，$\\mathbf{A} \\in \\mathbb{R}^{d \\times d}$ 是一个对称正定矩阵。\n- 表示 R（实数值）：\n  - 编码：直接编码 $\\mathbf{x}$。\n  - 变异：$\\mathbf{x}^\\prime = \\mathbf{x} + \\boldsymbol{\\varepsilon}$，其中扰动 $\\boldsymbol{\\varepsilon}$ 是一个从多元正态分布 $\\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_d)$ 中抽取的随机变量，$\\sigma  0$ 且 $\\mathbf{I}_d$ 是 $d \\times d$ 单位矩阵。\n- 表示 B（二进制定点）：\n  - 编码：$\\mathbf{x}$ 的每个坐标都用 $m$ 个比特以分辨率 $\\Delta  0$ 进行编码。\n  - 变异：从 $\\{1, \\dots, d\\}$ 中均匀随机选择一个坐标索引 $i$。其最低有效位（LSB）被翻转。由此产生的表现型向量 $\\mathbf{x}$ 的变化是 $\\delta \\mathbf{e}_i$，其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量，$\\delta$ 是一个随机变量，满足 $P(\\delta=+\\Delta) = P(\\delta=-\\Delta) = 1/2$。新的表现型是 $\\mathbf{x}^\\prime = \\mathbf{x} + \\delta \\mathbf{e}_i$。\n  - 假设：不发生边界截断。\n- 待定数量：对于每种表示方法，适应度变化的条件期望 $\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}]$。\n- 变异局部性的定义：$f$ 的较小期望增量表示更好的局部性。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述具有科学依据，是适定且客观的。它利用了线性代数、概率论和演化计算中的标准数学概念。目标函数是一个凸二次型，这是一个标准的基准。变异算子有明确的定义。表示 B 的变异定义将 LSB 翻转的效果建模为 $\\pm\\Delta$ 的对称概率变化，这是一个有效的建模选择，确保了问题是自洽的，并且无需指定确切的二进制编码方案（例如，二进制补码）即可明确求解。所有必要信息都已提供。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导解答。\n\n### 期望适应度变化的推导\n\n设表现型的变化为向量 $\\boldsymbol{\\delta}_{\\text{mut}}$，因此 $\\mathbf{x}^\\prime = \\mathbf{x} + \\boldsymbol{\\delta}_{\\text{mut}}$。适应度的变化为：\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{x} + \\boldsymbol{\\delta}_{\\text{mut}} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} + \\boldsymbol{\\delta}_{\\text{mut}} - \\boldsymbol{\\mu}) - \\tfrac{1}{2} (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu}) $$\n令 $\\mathbf{y} = \\mathbf{x} - \\boldsymbol{\\mu}$。表达式变为：\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\tfrac{1}{2} (\\mathbf{y} + \\boldsymbol{\\delta}_{\\text{mut}})^\\top \\mathbf{A} (\\mathbf{y} + \\boldsymbol{\\delta}_{\\text{mut}}) - \\tfrac{1}{2} \\mathbf{y}^\\top \\mathbf{A} \\mathbf{y} $$\n展开第一项：\n$$ \\tfrac{1}{2} (\\mathbf{y}^\\top\\mathbf{A}\\mathbf{y} + \\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} + \\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\mathbf{y} + \\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}) $$\n因为 $\\mathbf{A}$ 是对称的，所以 $\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\mathbf{y} = (\\mathbf{y}^\\top\\mathbf{A}^\\top\\boldsymbol{\\delta}_{\\text{mut}})^\\top = (\\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}})^\\top$。由于这是一个标量，它等于其转置。因此，两个交叉项相等。\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\tfrac{1}{2}(\\mathbf{y}^\\top\\mathbf{A}\\mathbf{y} + 2\\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} + \\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}) - \\tfrac{1}{2}\\mathbf{y}^\\top\\mathbf{A}\\mathbf{y} $$\n$$ f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) = \\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} + \\tfrac{1}{2}\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}} $$\n在给定 $\\mathbf{x}$（因此也给定 $\\mathbf{y}$）的条件下取期望：\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\mathbb{E}[\\mathbf{y}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}] + \\mathbb{E}[\\tfrac{1}{2}\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}] $$\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\mathbf{y}^\\top\\mathbf{A}\\mathbb{E}[\\boldsymbol{\\delta}_{\\text{mut}}] + \\tfrac{1}{2}\\mathbb{E}[\\boldsymbol{\\delta}_{\\text{mut}}^\\top\\mathbf{A}\\boldsymbol{\\delta}_{\\text{mut}}] $$\n\n#### 表示 R（实数值）\n对于这种表示，扰动是 $\\boldsymbol{\\delta}_{\\text{mut}} = \\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_d)$。\n扰动的期望是 $\\mathbb{E}[\\boldsymbol{\\varepsilon}] = \\mathbf{0}$。第一项消失：$\\mathbf{y}^\\top\\mathbf{A}\\mathbb{E}[\\boldsymbol{\\varepsilon}] = \\mathbf{0}$。\n对于第二项，我们计算二次型 $\\boldsymbol{\\varepsilon}^\\top\\mathbf{A}\\boldsymbol{\\varepsilon}$ 的期望。使用性质 $\\mathbb{E}[\\mathbf{z}^\\top \\mathbf{M} \\mathbf{z}] = \\operatorname{tr}(\\mathbf{M} \\boldsymbol{\\Sigma}_\\mathbf{z}) + \\boldsymbol{\\mu}_\\mathbf{z}^\\top \\mathbf{M} \\boldsymbol{\\mu}_\\mathbf{z}$，其中 $\\mathbf{z}=\\boldsymbol{\\varepsilon}$，$\\mathbf{M}=\\mathbf{A}$，$\\boldsymbol{\\mu}_\\mathbf{z}=\\mathbf{0}$，以及 $\\boldsymbol{\\Sigma}_\\mathbf{z} = \\sigma^2 \\mathbf{I}_d$。\n$$ \\mathbb{E}[\\boldsymbol{\\varepsilon}^\\top\\mathbf{A}\\boldsymbol{\\varepsilon}] = \\operatorname{tr}(\\mathbf{A} (\\sigma^2 \\mathbf{I}_d)) + \\mathbf{0}^\\top\\mathbf{A}\\mathbf{0} = \\operatorname{tr}(\\sigma^2\\mathbf{A}) = \\sigma^2 \\operatorname{tr}(\\mathbf{A}) $$\n因此，表示 R 的期望适应度变化是：\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0 + \\tfrac{1}{2}(\\sigma^2 \\operatorname{tr}(\\mathbf{A})) = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) $$\n\n#### 表示 B（二进制定点）\n对于这种表示，扰动是 $\\boldsymbol{\\delta}_{\\text{mut}} = \\boldsymbol{\\eta} = \\delta \\mathbf{e}_i$。随机性来自索引 $i \\in \\{1, \\dots, d\\}$（均匀分布）和符号变量 $\\delta \\in \\{+\\Delta, -\\Delta\\}$（均匀分布）。\n首先，我们计算扰动 $\\boldsymbol{\\eta}$ 的期望：\n$$ \\mathbb{E}[\\boldsymbol{\\eta}] = \\mathbb{E}_i[\\mathbb{E}_\\delta[\\delta \\mathbf{e}_i \\mid i]] = \\mathbb{E}_i[\\mathbf{e}_i \\mathbb{E}_\\delta[\\delta]] $$\n$\\delta$ 的期望是 $\\mathbb{E}[\\delta] = (+\\Delta)(1/2) + (-\\Delta)(1/2) = 0$。\n因此，$\\mathbb{E}[\\boldsymbol{\\eta}] = \\mathbf{0}$，并且第一项 $\\mathbf{y}^\\top\\mathbf{A}\\mathbb{E}[\\boldsymbol{\\eta}]$ 为零。\n对于第二项，我们计算 $\\mathbb{E}[\\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta}]$。\n$$ \\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta} = (\\delta \\mathbf{e}_i)^\\top\\mathbf{A}(\\delta \\mathbf{e}_i) = \\delta^2 (\\mathbf{e}_i^\\top\\mathbf{A}\\mathbf{e}_i) = \\delta^2 A_{ii} $$\n其中 $A_{ii}$ 是 $\\mathbf{A}$ 的第 $i$ 个对角元素。现在我们对 $i$ 和 $\\delta$ 取期望。由于它们是独立的：\n$$ \\mathbb{E}[\\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta}] = \\mathbb{E}[\\delta^2 A_{ii}] = \\mathbb{E}[\\delta^2] \\mathbb{E}[A_{ii}] $$\n$\\delta^2$ 的期望是 $\\mathbb{E}[\\delta^2] = (+\\Delta)^2(1/2) + (-\\Delta)^2(1/2) = \\Delta^2$。\n在 $i$ 的均匀选择下，$A_{ii}$ 的期望是：\n$$ \\mathbb{E}[A_{ii}] = \\sum_{k=1}^d A_{kk} P(i=k) = \\sum_{k=1}^d A_{kk} \\frac{1}{d} = \\frac{1}{d} \\operatorname{tr}(\\mathbf{A}) $$\n将这些结合起来，$\\mathbb{E}[\\boldsymbol{\\eta}^\\top\\mathbf{A}\\boldsymbol{\\eta}] = \\Delta^2 \\frac{1}{d}\\operatorname{tr}(\\mathbf{A})$。\n因此，表示 B 的期望适应度变化是：\n$$ \\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0 + \\tfrac{1}{2}\\left(\\frac{\\Delta^2}{d}\\operatorname{tr}(\\mathbf{A})\\right) = \\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A}) $$\n\n### 逐项分析\n\nA. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，如果 $\\Delta^2 / d = \\sigma^2$，两种编码具有相同的期望适应度变化，因而在该凸二次型上具有相同的期望变异局部性。\n- 推导出的表示 R 的表达式是 $\\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$，这与选项匹配。\n- 推导出的表示 B 的表达式是 $\\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$，这与选项匹配。\n- 比较如下：令两个表达式相等，$\\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) = \\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A})$。由于 $\\mathbf{A}$ 是正定的，其迹 $\\operatorname{tr}(\\mathbf{A})  0$，所以我们可以除以它和 $\\tfrac{1}{2}$，得到 $\\sigma^2 = \\Delta^2/d$。这个条件正确地使两个期望适应度变化相等。关于在该条件下具有相同局部性的结论是正确的。\n- 结论：**正确**。\n\nB. 在表示 R下，由于高斯分布的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。在表示 B下，由于 LSB 翻转的对称性，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = 0$。因此，对于任何 $\\sigma$ 和 $\\Delta$，两种编码都表现出完美的中心性。\n- 表示 R 的期望适应度变化是 $\\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$，这是一个严格正值，而不是 $0$。变异分布的对称性使得泰勒展开中的一阶项的平均值为零，但二阶项不为零。\n- 类似地，表示 B 的期望适应度变化是 $\\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A})$，这也是一个严格正值，而不是 $0$。\n- 前提是错误的。\n- 结论：**不正确**。\n\nC. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\sigma^2 \\lambda_{\\max}(\\mathbf{A})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\lambda_{\\min}(\\mathbf{A})$。因此，只要 $\\sigma^2  \\Delta^2 / (2 d)$，实数值编码的局部性就较差。\n- 推导出的表达式涉及 $\\operatorname{tr}(\\mathbf{A})$，即特征值之和，而不是最大特征值 $\\lambda_{\\max}(\\mathbf{A})$ 或最小特征值 $\\lambda_{\\min}(\\mathbf{A})$。两个公式都不正确。\n- 结论：**不正确**。\n\nD. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\Delta^2 \\operatorname{tr}(\\mathbf{A})$。因此，对于任何固定的 $\\sigma$ 和 $\\Delta$，二进制编码的局部性要差 $d$ 倍。\n- 表示 R 的表达式是正确的。\n- 表示 B 的表达式不正确；它缺少了因子 $1/d$。正确的表达式是 $\\tfrac{\\Delta^2}{2d}\\operatorname{tr}(\\mathbf{A})$。\n- 结论基于错误的前提。\n- 结论：**不正确**。\n\nE. 在表示 R下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{1}{2} \\sigma^2 \\operatorname{tr}(\\mathbf{A}) + \\tfrac{1}{2} \\sigma^2 (\\mathbf{x} - \\boldsymbol{\\mu})^\\top \\mathbf{A} (\\mathbf{x} - \\boldsymbol{\\mu})$。在表示 B下，$\\mathbb{E}[f(\\mathbf{x}^\\prime) - f(\\mathbf{x}) \\mid \\mathbf{x}] = \\tfrac{\\Delta^2}{2 d} \\operatorname{tr}(\\mathbf{A})$。因此，即使对于固定的 $\\sigma$，当 $\\mathbf{x}$ 远离 $\\boldsymbol{\\mu}$ 时，实数值编码的局部性也会变差。\n- 表示 R 的表达式不正确。我们的推导表明，期望适应度变化与 $\\mathbf{x}$ 无关。公式中依赖于 $\\mathbf{x}$ 的项是虚假的。\n- 表示 B 的表达式是正确的。\n- 结论基于关于表示 R 的错误前提。\n- 结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "虽然遗传算法功能强大，但有时也会被“欺骗性”适应度景观所误导，导致种群向次优解收敛。理解这种失效模式对于高级遗传算法的设计至关重要。本练习将引导您从单个算子转向对整个种群动态的分析，您将通过建模一个无限种群在欺骗性函数上的演化过程，并数值计算欺骗性最优解与全局最优解的吸引盆大小。这将为您提供一个关于欺骗现象以及为何遗传算法并非简单爬山算法的清晰、可视化的理解。",
            "id": "4124845",
            "problem": "您正在一个更广泛的复杂自适应系统（CAS）框架内对遗传算法（GA）进行建模。考虑二进制串表示法，适应度基于块内1的个数（unitation），并采用无限种群和比例选择动力学。假设完全混合重组（连锁平衡），因此基因型分布可分解为每个基因座独立的伯努利试验，且具有共同的等位基因1频率。您的任务是在单个块上构建一个欺骗性适应度函数，并在比例选择下，通过分析等位基因频率复制子映射来计算欺骗性局部最优与全局最优的吸引盆体积。\n\n基本原理。使用以下基础事实：\n- 比例选择（复制子方程）根据 $p'(x) = \\dfrac{p(x) f(x)}{\\mathbb{E}[f(X)]}$ 更新基因型 $x$ 的概率质量函数 $p(x)$，其中 $f(x)$ 是适应度，$\\mathbb{E}[f(X)]$ 是在 $p(x)$ 下的期望适应度。\n- 在完全混合重组和二进制基因座下，如果一个块长为 $k$ 位，并且每个基因座都是一个独立的伯努利试验，其等位基因1的频率为 $p \\in [0,1]$，那么1的个数（unitation）$u \\in \\{0,1,\\dots,k\\}$ 的分布是二项分布，其概率质量为 $\\Pr(U=u) = \\binom{k}{u} p^u (1-p)^{k-u}$。\n- 在对块适应度进行比例选择下，等位基因1的频率更新公式为 $p' = \\dfrac{\\mathbb{E}\\left[\\dfrac{U}{k} f(U)\\right]}{\\mathbb{E}[f(U)]}$，其中期望是根据 $U$ 的二项分布定律计算的。\n\n欺骗性块适应度。为块长度为 $k$ 的情况，定义一个关于1的个数（unitation）$u$ 的单块欺骗性陷阱函数如下。设全局最优在 $u=k$ 处，适应度为 $H$。对于所有 $u \\in \\{0,1,\\dots,k-1\\}$，定义一个关于 $u$ 的严格递减仿射适应度：\n$$\nf(u) =\n\\begin{cases}\nH,  \\text{if } u = k, \\\\\nb - a \\dfrac{u}{k},  \\text{if } u \\in \\{0,1,\\dots,k-1\\},\n\\end{cases}\n$$\n参数为 $H  0$，$b  0$，$a  0$，且 $b  H$，使得在 $u=0$ 处的局部欺骗性最优的适应度 $f(0) = b$ 低于全局最优 $H$，但高于所有其他 $u \\in \\{1,\\dots,k-1\\}$ 的 $f(u)$。这种构造确保了作用于朝向全局最优的部分进展（$u$ 增加但 $u  k$）的选择压力是负的。\n\n您的任务是计算一维离散动力系统 $p' = \\Phi(p; k, H, b, a)$ 的不动点 $p=0$（欺骗性最优解）和 $p=1$（全局最优解）的吸引盆体积。吸引盆体积是所有初始频率 $p_0 \\in (0,1)$ 中，最终分别收敛到这两个不动点的点所占的比例。通过在区间 $(0,1)$ 上均匀间隔的 $N=2001$ 个点组成的网格上模拟该映射来数值计算这些体积。对于每个网格点，迭代映射 $p_{t+1} = \\Phi(p_t)$，最多 $T_{\\max}=1000$ 次，或直到连续迭代之间的变化小于 $\\epsilon = 10^{-12}$。如果最终 $p  10^{-6}$，则认为轨迹收敛到 $p=0$。如果最终 $p  1 - 10^{-6}$，则认为轨迹收敛到 $p=1$。在模糊的情况下，最后一步迭代的方向决定了分类。\n\n对于以下每个测试用例，计算吸引盆体积的数值，并将结果作为一个列表对 $[V_{\\text{deceptive}}, V_{\\text{global}}]$ 输出，四舍五入到六位小数。\n- 1: $(k, H, b, a) = (4, 1.0, 0.90, 0.90)$\n- 2: $(k, H, b, a) = (5, 1.0, 0.85, 0.70)$\n- 3: $(k, H, b, a) = (6, 1.0, 0.99, 0.79)$\n- 4: $(k, H, b, a) = (5, 1.0, 0.10, 0.00)$\n- 5: $(k, H, b, a) = (1, 1.0, 0.90, 0.90)$",
            "solution": "用户提供了一个遗传算法和复杂自适应系统领域的问题，这需要分析一个一维离散动力系统。验证过程如下。\n\n### 第一步：提取已知条件\n- **模型**：具有比例选择和完全混合的无限种群遗传算法。\n- **基因组**：一个由 $k$ 个二进制基因座组成的块。状态由等位基因1的频率 $p \\in [0,1]$ 描述。\n- **1的个数分布**：一个块中1的数量 $U$ 服从二项分布，$U \\sim \\text{Binomial}(k, p)$。\n- **适应度函数**：一个定义在1的个数 $u \\in \\{0, 1, \\dots, k\\}$ 上的欺骗性陷阱函数：\n$$\nf(u) =\n\\begin{cases}\nH,  \\text{if } u = k, \\\\\nb - a \\dfrac{u}{k},  \\text{if } u \\in \\{0,1,\\dots,k-1\\},\n\\end{cases}\n$$\n参数为 $H  0$，$b  0$，$a  0$，且 $b  H$。\n- **复制子映射**：等位基因1的频率 $p$ 根据离散映射 $p' = \\Phi(p; k, H, b, a)$ 更新，其表达式为：\n$$\np' = \\frac{\\mathbb{E}\\left[\\frac{U}{k} f(U)\\right]}{\\mathbb{E}[f(U)]} = \\frac{\\sum_{u=0}^{k} \\left(\\frac{u}{k}\\right) \\binom{k}{u} p^u (1-p)^{k-u} f(u)}{\\sum_{u=0}^{k} \\binom{k}{u} p^u (1-p)^{k-u} f(u)}.\n$$\n- **任务**：计算不动点 $p=0$（欺骗性最优）和 $p=1$（全局最优）的吸引盆体积。\n- **数值方法**：\n    - 使用一个含 $N=2001$ 个点的均匀网格离散化区间 $(0,1)$。\n    - 对每个网格点，迭代映射 $p_{t+1}=\\Phi(p_t)$ 最多 $T_{\\max}=1000$ 次，或直到 $|p_{t+1}-p_t|  \\epsilon = 10^{-12}$。\n    - 收敛分类：如果最终 $p  10^{-6}$，则收敛到 $p=0$；如果最终 $p > 1-10^{-6}$，则收敛到 $p=1$。模糊情况由最后一次迭代步骤的符号决定。\n- **测试用例**：\n    - 1: $(k, H, b, a) = (4, 1.0, 0.90, 0.90)$\n    - 2: $(k, H, b, a) = (5, 1.0, 0.85, 0.70)$\n    - 3: $(k, H, b, a) = (6, 1.0, 0.99, 0.79)$\n    - 4: $(k, H, b, a) = (5, 1.0, 0.10, 0.00)$\n    - 5: $(k, H, b, a) = (1, 1.0, 0.90, 0.90)$\n- **输出**：每个测试用例的一个列表对 $[V_{\\text{deceptive}}, V_{\\text{global}}]$，数值四舍五入到六位小数。\n\n### 第二步：使用提取的已知条件进行验证\n该问题在种群遗传学和演化计算的既定理论中具有科学依据。等位基因频率在比例选择下的复制子方程是一个标准模型。欺骗性适应度函数是用于研究GA中简单爬山动力学局限性的经典构造。问题定义明确，提供了清晰的目标和完整、数值上合理的实现步骤。所有参数和常数都已定义，且没有矛盾。计算任务是可行的。语言客观而精确。因此，该问题被认为是有效的。\n\n### 第三步：结论与行动\n问题是有效的。将开发一个解决方案。\n\n### 求解过程\n\n问题的核心是分析一维复制子映射 $p' = \\Phi(p)$ 的动力学。在每次迭代中直接数值计算 $\\Phi(p)$ 定义中的求和项效率会很低。一种更优雅且计算上更优越的方法是推导出一个 $\\Phi(p)$ 的闭式解析表达式。\n\n令 $P(u) = \\binom{k}{u} p^u (1-p)^{k-u}$ 为二项概率质量函数。$\\Phi(p)$ 的分母是期望适应度 $\\mathbb{E}[f(U)]$。我们可以将全局最优 $u=k$ 的项分离开来：\n$$\n\\mathbb{E}[f(U)] = \\sum_{u=0}^{k-1} P(u) \\left(b - a\\frac{u}{k}\\right) + P(k)H\n$$\n利用期望的线性和以及二项分布的性质（其中 $\\mathbb{E}[U] = kp$），我们可以简化这个和：\n$$\n\\sum_{u=0}^{k-1} P(u) \\left(b - a\\frac{u}{k}\\right) = b \\sum_{u=0}^{k-1} P(u) - \\frac{a}{k} \\sum_{u=0}^{k-1} u P(u)\n$$\n这里的求和是针对部分范围的。我们使用 $\\sum_{u=0}^k P(u)=1$ 和 $\\sum_{u=0}^k uP(u) = \\mathbb{E}[U] = kp$。\n$$\n\\sum_{u=0}^{k-1} P(u) = 1 - P(k) = 1 - p^k\n$$\n$$\n\\sum_{u=0}^{k-1} u P(u) = \\mathbb{E}[U] - k P(k) = kp - k p^k\n$$\n将这些代回，得到分母：\n$$\n\\mathbb{E}[f(U)] = b(1-p^k) - \\frac{a}{k}(kp - kp^k) + p^k H = b - ap + (H - b + a)p^k\n$$\n类似地，$\\Phi(p)$ 的分子是 $\\mathbb{E}[\\frac{U}{k}f(U)]$。遵循类似的过程并使用二阶矩 $\\mathbb{E}[U^2] = \\text{Var}(U) + (\\mathbb{E}[U])^2 = kp(1-p) + (kp)^2$：\n$$\n\\mathbb{E}\\left[\\frac{U}{k}f(U)\\right] = \\sum_{u=0}^{k-1} \\frac{u}{k} P(u) \\left(b - a\\frac{u}{k}\\right) + \\frac{k}{k} P(k)H\n$$\n$$\n= \\frac{b}{k}\\sum_{u=0}^{k-1} u P(u) - \\frac{a}{k^2}\\sum_{u=0}^{k-1} u^2 P(u) + p^k H\n$$\n$$\n= \\frac{b}{k}(kp - kp^k) - \\frac{a}{k^2}(\\mathbb{E}[U^2] - k^2 P(k)) + p^k H\n$$\n$$\n= b(p - p^k) - \\frac{a}{k^2}(kp(1-p) + (kp)^2 - k^2 p^k) + p^k H\n$$\n化简后，分子变为：\n$$\n\\mathbb{E}\\left[\\frac{U}{k}f(U)\\right] = p\\left(b - \\frac{a}{k}\\right) + p^2\\left(\\frac{a}{k} - a\\right) + p^k(H - b + a)\n$$\n因此，映射 $\\Phi(p)$ 是 $p$ 和 $p^k$ 的一个有理函数：\n$$\n\\Phi(p) = \\frac{p(b - a/k) + p^2(a/k - a) + p^k(H - b + a)}{b - ap + (H - b + a)p^k}\n$$\n这种解析形式数值稳定且计算效率高。\n\n总体算法如下：\n1.  对于每个由参数 $(k, H, b, a)$ 定义的测试用例，将欺骗性盆和全局盆的计数器初始化为零。\n2.  在区间 $(0,1)$ 中生成一个包含 $N=2001$ 个初始点 $p_0$ 的均匀网格。\n3.  对于每个初始点 $p_0$：\n    a. 从 $p_0$ 开始，迭代映射 $p_{t+1} = \\Phi(p_t)$。\n    b. 如果变化量 $|p_{t+1} - p_t|$ 小于容差 $\\epsilon=10^{-12}$（收敛）或达到最大迭代次数 $T_{\\max}=1000$，则迭代停止。\n    c. 对轨迹的最终值 $p_{\\text{final}}$ 进行分类。如果 $p_{\\text{final}}  10^{-6}$，轨迹被计入欺骗性盆。如果 $p_{\\text{final}} > 1 - 10^{-6}$，则计入全局盆。\n    d. 如果最终点位于这些阈值之间的模糊区域，则其所属的盆由最后一次迭代步骤的方向决定：负步骤意味着收敛到 $p=0$，非负步骤意味着收敛到 $p=1$。\n4. 在所有网格点都被分类后，每个吸引盆的体积通过收敛到相应吸引子的点的比例来近似。具体来说，$V_{\\text{deceptive}} = \\text{count}_{\\text{deceptive}}/N$ 和 $V_{\\text{global}} = \\text{count}_{\\text{global}}/N$。\n5. 每个测试用例的结果按要求格式化并收集以用于最终输出。下面的 Python 程序实现了此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the basin of attraction volumes for a genetic algorithm's \n    replicator dynamics on a deceptive fitness function.\n    \"\"\"\n\n    # Define parameters from the problem statement\n    test_cases = [\n        # k, H, b, a\n        (4, 1.0, 0.90, 0.90),\n        (5, 1.0, 0.85, 0.70),\n        (6, 1.0, 0.99, 0.79),\n        (5, 1.0, 0.10, 0.00),  # non-deceptive baseline\n        (1, 1.0, 0.90, 0.90),  # boundary block size k=1\n    ]\n    N = 2001\n    T_max = 1000\n    epsilon = 1e-12\n    conv_thresh_low = 1e-6\n    conv_thresh_high = 1.0 - conv_thresh_low\n\n    # List to store formatted results for each case\n    all_results = []\n    \n    def phi_map(p, k, H, b, a):\n        \"\"\"\n        Computes the next allele frequency p' = Phi(p) using the derived \n        analytical expression for the replicator map.\n        \"\"\"\n        if p == 0.0:\n            return 0.0\n        if p == 1.0:\n            return 1.0\n        \n        # Use high-precision floating point numbers for intermediate calculations\n        p, k, H, b, a = map(np.float64, [p, k, H, b, a])\n        \n        pk = np.power(p, k)\n        \n        # Denominator: E[f(U)] = b - a*p + (H - b + a)*p^k\n        # Numerator: E[(U/k)*f(U)] = p*(b-a/k) + p^2*(a/k - a) + p^k*(H-b+a)\n        \n        C3 = H - b + a\n        \n        denominator = b - a * p + C3 * pk\n        \n        # Guard against k=0 which is not in test cases but good practice\n        if k > 0:\n            C1 = b - a / k\n            C2 = a / k - a\n            numerator = p * C1 + np.power(p, 2) * C2 + pk * C3\n        else:\n             numerator = 0.0\n\n        # This condition should not be met with the problem's constraints (H>0, b>0)\n        # but is included as a safeguard.\n        if denominator == 0:\n            return p \n\n        return numerator / denominator\n\n    # Iterate over each test case\n    for k, H, b, a in test_cases:\n        deceptive_count = 0\n        global_count = 0\n        \n        # Create a uniform grid of N points over the open interval (0, 1)\n        grid_points = np.linspace(0.0, 1.0, N + 2, dtype=np.float64)[1:-1]\n\n        # For each initial point, iterate the map to find its attractor\n        for p_initial in grid_points:\n            p_current = p_initial\n            last_step_delta = 0.0\n\n            for _ in range(T_max):\n                p_next = phi_map(p_current, k, H, b, a)\n                \n                # Clamp values to [0,1] to handle potential minor floating point inaccuracies\n                if p_next  0.0: p_next = 0.0\n                if p_next > 1.0: p_next = 1.0\n\n                last_step_delta = p_next - p_current\n                \n                if np.abs(last_step_delta)  epsilon:\n                    p_current = p_next\n                    break\n                \n                p_current = p_next\n            \n            p_final = p_current\n            \n            # Classify trajectory based on the final position\n            if p_final  conv_thresh_low:\n                deceptive_count += 1\n            elif p_final > conv_thresh_high:\n                global_count += 1\n            else:\n                # Classify ambiguous cases by the sign of the last update step\n                if last_step_delta  0:\n                    deceptive_count += 1\n                else:  # Includes last_step_delta >= 0\n                    global_count += 1\n                    \n        # Calculate basin volumes as fractions of the grid\n        v_d = deceptive_count / N\n        v_g = global_count / N\n        \n        result_str = f\"[{v_d:.6f},{v_g:.6f}]\"\n        all_results.append(result_str)\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}