{
    "hands_on_practices": [
        {
            "introduction": "理解上位性相互作用（$K0$）是掌握NK模型的核心。要直观地理解这个概念，最好的方法就是通过一个小型例子进行演算。本练习将引导您为一个简单的 $N=2, K=1$ 系统计算适应度值，并利用这些结果来识别和量化上位性，正是这种相互作用导致了适应度景观的崎岖性。",
            "id": "4148370",
            "problem": "考虑复杂适应系统中的适应度景观的N-K模型（NK），其中基因型由长度为$N$的二进制串表示，每个位点的适应度贡献取决于其自身的状态以及$K$个相互作用位点的状态。对于$N=2$和$K=1$，假设每个位点都与另一个位点相互作用。设总适应度是各位点特定贡献的算术平均值。形式上，对于基因型$\\mathbf{x}=(x_{1},x_{2})\\in\\{0,1\\}^{2}$，适应度定义为\n$$\nW(\\mathbf{x})=\\frac{1}{2}\\left[w_{1}(x_{1},x_{2})+w_{2}(x_{2},x_{1})\\right],\n$$\n其中$w_{1}$是位点1的贡献，$w_{2}$是位点2的贡献。\n\n通过为所有等位基因组合指定贡献表$w_{1}$和$w_{2}$，构建两个明确的NK实例。对于实例A，使用\n$$\nw_{1}(0,0)=2.0,\\quad w_{1}(1,0)=3.2,\\quad w_{1}(0,1)=3.5,\\quad w_{1}(1,1)=2.6,\n$$\n$$\nw_{2}(0,0)=2.0,\\quad w_{2}(0,1)=3.5,\\quad w_{2}(1,0)=2.8,\\quad w_{2}(1,1)=3.4.\n$$\n对于实例B，使用\n$$\nw_{1}(0,0)=3.8,\\quad w_{1}(1,0)=2.7,\\quad w_{1}(0,1)=2.9,\\quad w_{1}(1,1)=4.7,\n$$\n$$\nw_{2}(0,0)=4.2,\\quad w_{2}(0,1)=2.1,\\quad w_{2}(1,0)=2.3,\\quad w_{2}(1,1)=4.3.\n$$\n\n任务：\n1. 仅使用上述模型定义，计算每个实例的适应度$W(0,0)$、$W(1,0)$、$W(0,1)$和$W(1,1)$。\n2. 从“当单一位点突变的适应度效应的符号取决于另一位点的状态时，发生符号上位性”以及“当两个位点相对于彼此都表现出这种符号变化时，发生交互符号上位性”的定义出发，确定每个实例表现出哪种类型的上位性。\n3. 通过标准上位性偏差来量化非加性\n$$\n\\varepsilon \\equiv W(0,0)+W(1,1)-W(0,1)-W(1,0).\n$$\n计算每个实例的$\\varepsilon$。\n\n将有序对$\\left(\\varepsilon_{\\text{A}},\\varepsilon_{\\text{B}}\\right)$以单行矩阵的精确形式报告。无需四舍五入，不涉及单位。",
            "solution": "首先将对问题进行验证，以确保其科学性、良定性和客观性。\n\n### 步骤1：提取已知条件\n- **模型**：N-K模型（NK）\n- **基因型**：长度为$N=2$的二进制串，$\\mathbf{x}=(x_{1},x_{2})\\in\\{0,1\\}^{2}$\n- **相互作用**：$K=1$，每个位点与另一个位点相互作用。\n- **适应度函数**：$W(\\mathbf{x})=\\frac{1}{2}\\left[w_{1}(x_{1},x_{2})+w_{2}(x_{2},x_{1})\\right]$\n- **实例A贡献值**：\n  $w_{1}(0,0)=2.0$, $w_{1}(1,0)=3.2$, $w_{1}(0,1)=3.5$, $w_{1}(1,1)=2.6$\n  $w_{2}(0,0)=2.0$, $w_{2}(0,1)=3.5$, $w_{2}(1,0)=2.8$, $w_{2}(1,1)=3.4$\n- **实例B贡献值**：\n  $w_{1}(0,0)=3.8$, $w_{1}(1,0)=2.7$, $w_{1}(0,1)=2.9$, $w_{1}(1,1)=4.7$\n  $w_{2}(0,0)=4.2$, $w_{2}(0,1)=2.1$, $w_{2}(1,0)=2.3$, $w_{2}(1,1)=4.3$\n- **任务1**：计算每个实例的$W(0,0)$、$W(1,0)$、$W(0,1)$、$W(1,1)$。\n- **任务2**：确定上位性的类型（符号上位性、交互符号上位性）。\n- **任务3**：计算每个实例的上位性偏差$\\varepsilon \\equiv W(0,0)+W(1,1)-W(0,1)-W(1,0)$。\n- **最终输出**：以单行矩阵形式报告有序对$\\left(\\varepsilon_{\\text{A}},\\varepsilon_{\\text{B}}\\right)$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它基于Stuart Kauffman开发的标准NK模型，这是复杂适应系统理论的基石。适应度、上位性的定义以及数学框架在理论生物学和演化计算领域都是标准且成熟的。问题是良定的，提供了执行所需计算的所有必要数值数据和明确公式。语言客观、精确。问题是自洽且一致的，没有矛盾或缺失信息。没有违反科学原理或逻辑之处。\n\n### 步骤3：结论与操作\n问题被判定为有效。将提供解答。\n\n### 解答推导\n\n解答过程将执行问题陈述中指定的三个任务。\n\n#### 任务1：适应度计算\n\n基因型$\\mathbf{x}=(x_1, x_2)$的总适应度由$W(\\mathbf{x})=\\frac{1}{2}\\left[w_{1}(x_{1},x_{2})+w_{2}(x_{2},x_{1})\\right]$给出。我们将此公式应用于实例A和实例B的所有四种可能基因型。\n\n**实例A：**\n四种基因型的适应度值为：\n$W_A(0,0) = \\frac{1}{2}\\left[w_{1}(0,0) + w_{2}(0,0)\\right] = \\frac{1}{2}(2.0 + 2.0) = \\frac{1}{2}(4.0) = 2.0$\n$W_A(1,0) = \\frac{1}{2}\\left[w_{1}(1,0) + w_{2}(0,1)\\right] = \\frac{1}{2}(3.2 + 3.5) = \\frac{1}{2}(6.7) = 3.35$\n$W_A(0,1) = \\frac{1}{2}\\left[w_{1}(0,1) + w_{2}(1,0)\\right] = \\frac{1}{2}(3.5 + 2.8) = \\frac{1}{2}(6.3) = 3.15$\n$W_A(1,1) = \\frac{1}{2}\\left[w_{1}(1,1) + w_{2}(1,1)\\right] = \\frac{1}{2}(2.6 + 3.4) = \\frac{1}{2}(6.0) = 3.0$\n\n**实例B：**\n四种基因型的适应度值为：\n$W_B(0,0) = \\frac{1}{2}\\left[w_{1}(0,0) + w_{2}(0,0)\\right] = \\frac{1}{2}(3.8 + 4.2) = \\frac{1}{2}(8.0) = 4.0$\n$W_B(1,0) = \\frac{1}{2}\\left[w_{1}(1,0) + w_{2}(0,1)\\right] = \\frac{1}{2}(2.7 + 2.1) = \\frac{1}{2}(4.8) = 2.4$\n$W_B(0,1) = \\frac{1}{2}\\left[w_{1}(0,1) + w_{2}(1,0)\\right] = \\frac{1}{2}(2.9 + 2.3) = \\frac{1}{2}(5.2) = 2.6$\n$W_B(1,1) = \\frac{1}{2}\\left[w_{1}(1,1) + w_{2}(1,1)\\right] = \\frac{1}{2}(4.7 + 4.3) = \\frac{1}{2}(9.0) = 4.5$\n\n#### 任务2：上位性分析\n\n如果一个位点上突变的适应度效应的符号因另一个位点上的等位基因而改变，则存在符号上位性。如果两个位点的突变都如此，则发生交互符号上位性。\n\n**实例A：**\n位点1上突变（$0 \\to 1$）的影响：\n- 在背景$x_2=0$下：$\\Delta W_{1|0} = W_A(1,0) - W_A(0,0) = 3.35 - 2.0 = 1.35$（正）\n- 在背景$x_2=1$下：$\\Delta W_{1|1} = W_A(1,1) - W_A(0,1) = 3.0 - 3.15 = -0.15$（负）\n由于符号不同，位点1存在符号上位性。\n\n位点2上突变（$0 \\to 1$）的影响：\n- 在背景$x_1=0$下：$\\Delta W_{2|0} = W_A(0,1) - W_A(0,0) = 3.15 - 2.0 = 1.15$（正）\n- 在背景$x_1=1$下：$\\Delta W_{2|1} = W_A(1,1) - W_A(1,0) = 3.0 - 3.35 = -0.35$（负）\n由于符号不同，位点2存在符号上位性。\n由于两个位点都表现出符号上位性，**实例A表现出交互符号上位性**。\n\n**实例B：**\n位点1上突变（$0 \\to 1$）的影响：\n- 在背景$x_2=0$下：$\\Delta W_{1|0} = W_B(1,0) - W_B(0,0) = 2.4 - 4.0 = -1.6$（负）\n- 在背景$x_2=1$下：$\\Delta W_{1|1} = W_B(1,1) - W_B(0,1) = 4.5 - 2.6 = 1.9$（正）\n由于符号不同，位点1存在符号上位性。\n\n位点2上突变（$0 \\to 1$）的影响：\n- 在背景$x_1=0$下：$\\Delta W_{2|0} = W_B(0,1) - W_B(0,0) = 2.6 - 4.0 = -1.4$（负）\n- 在背景$x_1=1$下：$\\Delta W_{2|1} = W_B(1,1) - W_B(1,0) = 4.5 - 2.4 = 2.1$（正）\n由于符号不同，位点2存在符号上位性。\n由于两个位点都表现出符号上位性，**实例B也表现出交互符号上位性**。\n\n#### 任务3：上位性偏差计算\n\n上位性偏差$\\varepsilon$使用公式$\\varepsilon = W(0,0) + W(1,1) - W(0,1) - W(1,0)$计算。\n\n**实例A：**\n使用任务1中计算的适应度值：\n$\\varepsilon_A = W_A(0,0) + W_A(1,1) - W_A(0,1) - W_A(1,0)$\n$\\varepsilon_A = 2.0 + 3.0 - 3.15 - 3.35 = 5.0 - 6.5 = -1.5$\n\n**实例B：**\n使用任务1中计算的适应度值：\n$\\varepsilon_B = W_B(0,0) + W_B(1,1) - W_B(0,1) - W_B(1,0)$\n$\\varepsilon_B = 4.0 + 4.5 - 2.6 - 2.4 = 8.5 - 5.0 = 3.5$\n\n问题要求报告有序对$(\\varepsilon_A, \\varepsilon_B)$。即$(-1.5, 3.5)$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -1.5  3.5 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在处理复杂的崎岖景观之前，理解其基准情形至关重要，即可加性景观（$K=0$）。本练习要求您“动手”推导在所有可能的基因型和随机景观上适应度的均值和方差。这个过程将揭示景观的整体统计特性是如何根植于其各个组成部分的基本属性的，这是一个基础性的结论。",
            "id": "4148453",
            "problem": "考虑N-K适应度景观模型（NK），具体来说是加性情况，即没有上位效应相互作用，意味着 $K=0$。存在 $N$ 个位点，每个位点具有 $\\{0,1\\}$ 中的二元等位基因。对于每个位点 $i \\in \\{1,\\dots,N\\}$，定义一个查找函数 $f_i:\\{0,1\\}\\to \\mathbb{R}$。假设以下生成性假设成立：\n- 对每个 $i$，两个表项 $f_i(0)$ 和 $f_i(1)$ 是从一个均值为 $\\mu$、方差为 $\\sigma^{2}$ 的共同分布中进行的独立同分布抽样。\n- 在不同位点 $i$ 之间，所有表项都是相互独立的。\n- 一个基因型 $X=(X_1,\\dots,X_N)\\in\\{0,1\\}^N$ 是从所有查找表项中独立地进行均匀随机抽样的。\n\n在加性情况下，基因型 $x\\in\\{0,1\\}^N$ 的适应度定义为\n$$\nF(x) \\equiv \\frac{1}{N}\\sum_{i=1}^{N} f_i(x_i).\n$$\n令 $F \\equiv F(X)$ 表示在如上所述的随机生成的加性景观下，均匀随机基因型 $X$ 的适应度。仅使用期望、方差、期望的线性性、独立随机变量和的方差、以及全期望定律和全方差定律的核心概率定义，推导在基因型和景观的联合随机性下的均值 $\\mathbb{E}[F]$ 和方差 $\\mathrm{Var}(F)$ 的闭式表达式。\n\n以单行矩阵 $\\begin{pmatrix}\\mathbb{E}[F]  \\mathrm{Var}(F)\\end{pmatrix}$ 的形式给出你的最终答案。不要近似或四舍五入；你的答案必须是关于 $\\mu$、$\\sigma^{2}$ 和 $N$ 的精确符号表达式。",
            "solution": "问题陈述已经过验证，被认为是科学合理的、适定的、客观的且内部一致的。它提出了一个关于适应度景观统计分析的标准理论练习。我们开始进行求解。\n\n我们关心的随机变量是适应度 $F = F(X)$，定义为\n$$\nF \\equiv \\frac{1}{N}\\sum_{i=1}^{N} f_i(X_i)\n$$\n$F$ 中的随机性来自两个独立的来源：\n$1.$ 景观的随机生成，它由所有查找表项的集合 $\\{f_i(a) \\mid i \\in \\{1,\\dots,N\\}, a \\in \\{0,1\\}\\}$ 组成。我们用下标 $\\mathcal{L}$ 表示对此随机性的期望和方差。每个 $f_i(a)$ 是一个独立同分布的随机变量，其均值为 $\\mathbb{E}_{\\mathcal{L}}[f_i(a)] = \\mu$，方差为 $\\mathrm{Var}_{\\mathcal{L}}(f_i(a)) = \\sigma^2$。\n$2.$ 从空间 $\\{0,1\\}^N$ 中对基因型 $X=(X_1,\\dots,X_N)$ 进行均匀随机抽样。我们用下标 $X$ 表示对此随机性的期望和方差。均匀抽样意味着对于每个位点 $i$，$\\mathbb{P}(X_i = 0) = \\mathbb{P}(X_i = 1) = \\frac{1}{2}$，并且变量 $X_1, \\dots, X_N$ 是相互独立的。\n\n我们寻求在景观和基因型的联合概率空间上的总期望 $\\mathbb{E}[F]$ 和总方差 $\\mathrm{Var}(F)$。\n\n**均值 $\\mathbb{E}[F]$ 的计算**\n\n我们将使用全期望定律，也称为迭代期望定律：$\\mathbb{E}[Y] = \\mathbb{E}_A[\\mathbb{E}_B[Y|A]]$。我们可以选择先对景观或基因型进行条件化。对基因型 $X$ 进行条件化更为直接。\n$$\n\\mathbb{E}[F] = \\mathbb{E}_{X}[\\mathbb{E}_{\\mathcal{L}}[F | X]]\n$$\n首先，我们计算内层期望，即固定基因型 $x \\in \\{0,1\\}^N$ 在景观的随机系综上的期望适应度。\n$$\n\\mathbb{E}_{\\mathcal{L}}[F | X=x] = \\mathbb{E}_{\\mathcal{L}}\\left[\\frac{1}{N}\\sum_{i=1}^{N} f_i(x_i)\\right]\n$$\n根据期望的线性性，我们可以将期望算子移到求和号内部：\n$$\n\\mathbb{E}_{\\mathcal{L}}[F | X=x] = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbb{E}_{\\mathcal{L}}[f_i(x_i)]\n$$\n根据问题陈述，对于任何位点 $i$ 和任何等位基因选择 $x_i \\in \\{0,1\\}$，项 $f_i(x_i)$ 是从一个均值为 $\\mu$ 的分布中抽取的随机变量。因此，$\\mathbb{E}_{\\mathcal{L}}[f_i(x_i)] = \\mu$。\n将此代入求和中，得到：\n$$\n\\mathbb{E}_{\\mathcal{L}}[F | X=x] = \\frac{1}{N}\\sum_{i=1}^{N} \\mu = \\frac{1}{N}(N\\mu) = \\mu\n$$\n给定特定基因型 $x$ 时，$F$ 的条件期望就是 $\\mu$，这是一个不依赖于基因型本身的常数值。\n\n现在，我们计算关于基因型 $X$ 的随机选择的外层期望：\n$$\n\\mathbb{E}[F] = \\mathbb{E}_{X}[\\mu] = \\mu\n$$\n常数的期望就是常数本身。因此，平均适应度为 $\\mu$。\n\n**方差 $\\mathrm{Var}(F)$ 的计算**\n\n我们使用全方差定律，该定律表明：\n$$\n\\mathrm{Var}(F) = \\mathbb{E}_{X}[\\mathrm{Var}_{\\mathcal{L}}(F | X)] + \\mathrm{Var}_{X}(\\mathbb{E}_{\\mathcal{L}}[F | X])\n$$\n我们来分析右侧的两项。\n\n第二项 $\\mathrm{Var}_{X}(\\mathbb{E}_{\\mathcal{L}}[F | X])$ 是我们之前计算的条件期望的方差。因为我们发现 $\\mathbb{E}_{\\mathcal{L}}[F | X] = \\mu$ 是一个常数，所以它关于 $X$ 的方差为零：\n$$\n\\mathrm{Var}_{X}(\\mathbb{E}_{\\mathcal{L}}[F | X]) = \\mathrm{Var}_{X}(\\mu) = 0\n$$\n这使得全方差定律简化为：\n$$\n\\mathrm{Var}(F) = \\mathbb{E}_{X}[\\mathrm{Var}_{\\mathcal{L}}(F | X)]\n$$\n现在我们必须计算内层项 $\\mathrm{Var}_{\\mathcal{L}}(F | X=x)$，即固定基因型 $x$ 的适应度在景观系综上的方差。\n$$\n\\mathrm{Var}_{\\mathcal{L}}(F | X=x) = \\mathrm{Var}_{\\mathcal{L}}\\left(\\frac{1}{N}\\sum_{i=1}^{N} f_i(x_i)\\right)\n$$\n使用方差性质 $\\mathrm{Var}(cY) = c^2\\mathrm{Var}(Y)$，其中 $c = \\frac{1}{N}$：\n$$\n\\mathrm{Var}_{\\mathcal{L}}(F | X=x) = \\frac{1}{N^2}\\mathrm{Var}_{\\mathcal{L}}\\left(\\sum_{i=1}^{N} f_i(x_i)\\right)\n$$\n求和中的各项 $f_1(x_1), f_2(x_2), \\dots, f_N(x_N)$ 是对应于不同位点适应度贡献的随机变量。根据问题的生成性假设，所有表项都是相互独立的。由于每个 $f_i(x_i)$ 是不同位点 $i$ 的一个表项，因此这些变量是相互独立的。对于独立随机变量的和，和的方差等于方差的和：\n$$\n\\mathrm{Var}_{\\mathcal{L}}\\left(\\sum_{i=1}^{N} f_i(x_i)\\right) = \\sum_{i=1}^{N} \\mathrm{Var}_{\\mathcal{L}}(f_i(x_i))\n$$\n对于任何位点 $i$ 和任何等位基因选择 $x_i \\in \\{0,1\\}$，项 $f_i(x_i)$ 是从一个方差为 $\\sigma^2$ 的分布中抽取的随机变量。因此，$\\mathrm{Var}_{\\mathcal{L}}(f_i(x_i)) = \\sigma^2$。将此代入求和中：\n$$\n\\sum_{i=1}^{N} \\mathrm{Var}_{\\mathcal{L}}(f_i(x_i)) = \\sum_{i=1}^{N} \\sigma^2 = N\\sigma^2\n$$\n将所有部分组合起来得到条件方差：\n$$\n\\mathrm{Var}_{\\mathcal{L}}(F | X=x) = \\frac{1}{N^2}(N\\sigma^2) = \\frac{\\sigma^2}{N}\n$$\n这个结果也是一个常数，不依赖于特定的基因型 $x$。\n\n最后，我们计算关于随机基因型 $X$ 的外层期望：\n$$\n\\mathrm{Var}(F) = \\mathbb{E}_{X}\\left[\\frac{\\sigma^2}{N}\\right] = \\frac{\\sigma^2}{N}\n$$\n常数的期望就是常数本身。因此，适应度的总方差为 $\\frac{\\sigma^2}{N}$。\n\n总之，适应度分布的均值为 $\\mu$，方差为 $\\frac{\\sigma^2}{N}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\mu  \\frac{\\sigma^{2}}{N}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "复杂系统中的理论模型常常通过计算实验来进行检验和探索。本练习要求您编写程序来枚举适应度景观，并计算NK模型两种极端情况下的局部最大值数量：完全平滑的可加性景观（$K=0$）和最大程度崎岖的“纸牌屋”（House-of-Cards）景观（$K=N-1$）。这个练习将抽象的理论与具体的数值结果联系起来，弥合了两者之间的鸿沟。",
            "id": "4148406",
            "problem": "考虑 $N$-$K$ 适应度景观模型（NK），其中基因型是长度为 $N$ 的二进制字符串，基因型 $\\mathbf{x} \\in \\{0,1\\}^N$ 的适应度 $F(\\mathbf{x})$ 是 $N$ 个局部贡献函数的平均值，每个函数依赖于 $K+1$ 个比特位。对于每个基因座 $i \\in \\{0,\\dots,N-1\\}$，令 $\\mathcal{N}_i$ 为其大小为 $K+1$ 的邻域（我们将使用环上的相邻邻域：$\\mathcal{N}_i = \\{i,i+1,\\dots,i+K\\}$，索引对 $N$ 取模）。每个贡献函数 $f_i:\\{0,1\\}^{K+1}\\to \\mathbb{R}$ 都是从一个连续分布中独立抽取的。基因型 $\\mathbf{x}$ 的适应度定义为\n$$\nF(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i\\left(\\mathbf{x}_{\\mathcal{N}_i}\\right),\n$$\n其中 $\\mathbf{x}_{\\mathcal{N}_i}$ 表示 $\\mathbf{x}$ 中限于 $\\mathcal{N}_i$ 内索引并按固定顺序排列的子串。\n\n如果一个基因型 $\\mathbf{x}$ 的适应度 $F(\\mathbf{x})  F(\\mathbf{y})$ 对于所有与 $\\mathbf{x}$ 汉明距离为 $1$ 的 $\\mathbf{y}$（即所有单位点邻居）都成立，那么它就是一个局部最大值。\n\n您的任务是编写一个程序，对于较小的 $N$ 和 $K$，枚举特定实例的所有基因型和局部最大值，并从第一性原理出发，数值验证导出的理论预测。您必须实现以下测试套件，每个案例都需产生一个量化的结果。\n\n定义和约束：\n- 基因型枚举必须包括所有 $2^N$ 个二进制字符串。\n- 邻域必须如 $N$-$K$ 模型中所述，在环上是相邻的。\n- 随机值必须从 $[0,1]$ 上的连续均匀分布中抽取，每个测试使用固定的种子以确保可复现性。\n- 在 $K=N-1$ 的特殊 House-of-Cards 极限情况下，将每个基因型 $\\mathbf{x}$ 的适应度值 $F(\\mathbf{x})$ 视为独立同分布的连续随机变量。\n\n测试套件：\n1. 加性景观案例（$K=0$）：\n   - 参数：$N=5$, $K=0$, 随机种子 $s=12345$。\n   - 构建方法：对每个基因座 $i$，独立抽取 $f_i(0)$ 和 $f_i(1)$，并设置 $F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i(x_i)$。\n   - 输出规格：返回一个列表，其中包含单个实例中找到的局部最大值的整数计数、加性案例的整数理论预测值以及一个指示两者是否相等的布尔值。\n\n2. House-of-Cards 极限：\n   - 参数：$N=8$, $K=7$, 独立实例数 $R=3000$, 随机种子 $s=67890$。\n   - 构建方法：对每个实例，为所有 $2^N$ 个基因型从 $[0,1]$ 上的独立均匀随机抽样中分配 $F(\\mathbf{x})$，然后通过完全枚举和邻居比较来计算局部最大值。\n   - 输出规格：返回一个列表，其中包含 $R$ 个实例中局部最大值的浮点平均分数、浮点理论分数以及经验平均值与理论值之间的浮点绝对差。\n\n3. House-of-Cards 极限（小边界案例）：\n   - 参数：$N=2$, $K=1$, 独立实例数 $R=50000$, 随机种子 $s=13579$。\n   - 构建方法：与 House-of-Cards 案例一样，为每个基因型和实例独立分配 $F(\\mathbf{x})$，计算局部最大值，并对所有实例的分数进行平均。\n   - 输出规格：返回一个列表，其中包含 $R$ 个实例中局部最大值的浮点平均分数、浮点理论分数以及绝对差。\n\n4. 加性景观案例（平凡边界）：\n   - 参数：$N=1$, $K=0$, 随机种子 $s=24680$。\n   - 构建方法：与加性案例一样，抽取 $f_0(0)$ 和 $f_0(1)$ 并设置 $F(\\mathbf{x}) = f_0(x_0)$。\n   - 输出规格：返回一个列表，其中包含局部最大值的整数计数、加性案例的整数理论预测值以及一个指示两者是否相等的布尔值。\n\n待数值验证的理论预测：\n- 对于加性景观（$K=0$），预测局部最大值的确切数量。\n- 对于 House-of-Cards 极限（$K=N-1$），预测局部最大值的预期分数和预期数量（作为 $N$ 的函数）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例的输出本身就是上述指定格式的列表。例如：“[[result_case1],[result_case2],[result_case3],[result_case4]]”。\n- 所有返回值必须是以下类型之一：布尔值、整数、浮点数或这些类型的列表。不允许其他任何输出。",
            "solution": "用户提供的问题已经过验证，并被确定为复杂自适应系统领域中一个适定且有科学依据的问题。它要求对 NK 适应度景观模型的理论性质进行数值验证。问题陈述提供了进行唯一且有意义的求解所需的所有必要定义、参数和约束。\n\n解决方案分为两部分：首先，推导在指定模型极限下局部最大值数量的理论预测；其次，描述用于生成数值结果以进行比较的计算算法。\n\n**理论预测**\n\nNK 模型将基因型 $\\mathbf{x} \\in \\{0,1\\}^N$ 的适应度定义为 $N$ 个局部贡献函数的平均值，$F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i\\left(\\mathbf{x}_{\\mathcal{N}_i}\\right)$。如果一个基因型 $\\mathbf{x}$ 的适应度严格大于其所有 $N$ 个单位点翻转邻居的适应度，则该基因型为局部最大值。我们分析所要求的两种特殊情况。\n\n1.  **加性景观 ($K=0$)**\n\n    当上位性参数 $K=0$ 时，每个基因座 $i$ 的邻域就是其自身，$\\mathcal{N}_i = \\{i\\}$。适应度函数简化为加性形式：\n    $$F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_i(x_i)$$\n    其中 $f_i(x_i)$ 是基因座 $i$ 上等位基因 $x_i$ 的适应度贡献。\n\n    设 $\\mathbf{y}^{(j)}$ 是通过翻转 $\\mathbf{x}$ 的第 $j$ 位得到的基因型。适应度差异为：\n    $$F(\\mathbf{x}) - F(\\mathbf{y}^{(j)}) = \\frac{1}{N}\\left(f_j(x_j) - f_j(1-x_j)\\right)$$\n    要使 $\\mathbf{x}$ 成为局部最大值，必须对所有 $j \\in \\{0, \\dots, N-1\\}$ 满足 $F(\\mathbf{x})  F(\\mathbf{y}^{(j)})$。这意味着对于每个基因座 $j$，条件 $f_j(x_j)  f_j(1-x_j)$ 必须成立。\n\n    对于每个基因座 $j$，值 $f_j(0)$ 和 $f_j(1)$ 是从连续分布中抽取的。因此，其中一个值大于另一个的概率为 $1$。\n    - 如果 $f_j(0)  f_j(1)$，则只有当 $x_j=0$ 时条件才满足。\n    - 如果 $f_j(1)  f_j(0)$，则只有当 $x_j=1$ 时条件才满足。\n\n    无论哪种情况，对于每个基因座 $j$，都存在一个唯一的等位基因值，可以最大化局部适应度贡献 $f_j$。由于该条件必须对所有 $N$ 个基因座独立成立，因此只有一个基因型能同时满足所有 $N$ 个条件。该基因型是通过在每个基因座上选择最优的等位基因来构建的。\n\n    因此，对于加性案例（$K=0$）且适应度贡献从连续分布中抽取的情况，恰好存在 $1$ 个局部最大值。\n\n2.  **House-of-Cards 极限 ($K=N-1$)**\n\n    在 $K=N-1$ 极限下，即所谓的 House-of-Cards (HoC) 模型，所有 $2^N$ 个基因型的适应度值 $F(\\mathbf{x})$ 被假定为独立同分布 (i.i.d.) 的随机变量。问题指定从 $[0,1]$ 上的连续均匀分布中抽取这些值。\n\n    对于给定的基因型 $\\mathbf{x}$，要成为局部最大值，其适应度 $F(\\mathbf{x})$ 必须大于其所有 $N$ 个邻居的适应度值。设邻居为 $\\mathbf{y}_1, \\dots, \\mathbf{y}_N$。条件是对于所有 $k \\in \\{1, \\dots, N\\}$，$F(\\mathbf{x})  F(\\mathbf{y}_k)$。\n\n    适应度值集合 $\\{F(\\mathbf{x}), F(\\mathbf{y}_1), \\dots, F(\\mathbf{y}_N)\\}$ 由从连续分布中抽取的 $N+1$ 个独立同分布样本组成。由于独立同分布的性质，这些值的任何排序都是等可能的。因此，任何特定值（在此例中为 $F(\\mathbf{x})$）是该集合中最大值的概率为 $\\frac{1}{N+1}$。\n\n    这表示任何单个基因型是局部最大值的概率。根据期望的线性性质，整个 $2^N$ 基因型景观上的预期局部最大值数量是基因型总数乘以这个概率：\n    $$E[\\text{Number of Local Maxima}] = 2^N \\times \\frac{1}{N+1} = \\frac{2^N}{N+1}$$\n    作为局部最大值的基因型的预期*分数*就是这个概率：\n    $$E[\\text{Fraction of Local Maxima}] = \\frac{1}{N+1}$$\n    我们在案例2和3中的数值模拟将验证这个理论分数。对于 $N=8$，理论分数为 $\\frac{1}{9}$。对于 $N=2$，理论分数为 $\\frac{1}{3}$。\n\n**算法设计与实现**\n\n验证是通过实现与两种模型变体相对应的两个不同模拟程序来执行的。\n\n**加性景观 ($K=0$) 模拟（案例1和4）**\n\n1.  **初始化**：对于给定的 $N$ 和随机种子 $s$，初始化一个随机数生成器。\n2.  **适应度景观构建**：创建一个大小为 $N \\times 2$ 的适应度贡献表。每个条目 $f_{i,b}$（对于基因座 $i$ 和等位基因 $b \\in \\{0, 1\\}$）都是从 $U[0,1]$ 中独立抽取的。\n3.  **适应度评估**：枚举 $2^N$ 个基因型的整个景观。对于每个基因型 $\\mathbf{x}=(x_0, \\dots, x_{N-1})$，其适应度计算为 $F(\\mathbf{x}) = \\frac{1}{N}\\sum_{i=0}^{N-1} f_{i, x_i}$。所有基因型的适应度值都被存储起来。\n4.  **局部最大值识别**：测试每个基因型 $\\mathbf{x}$ 的局部最优性。将其适应度 $F(\\mathbf{x})$ 与其 $N$ 个邻居的预计算适应度值进行比较。如果 $F(\\mathbf{x})$ 严格大于所有邻居的适应度，则局部最大值计数器加一。\n5.  **输出**：该过程返回一个列表，其中包含局部最大值的最终整数计数、理论预测值 $1$ 以及一个指示经验计数是否与理论相符的布尔值。\n\n**House-of-Cards ($K=N-1$) 模拟（案例2和3）**\n\n1.  **初始化**：对于给定的 $N$、重复次数 $R$ 和种子 $s$，初始化一个随机数生成器。准备一个空列表来存储每个实例中的最大值分数。\n2.  **蒙特卡洛循环**：模拟迭代 $R$ 次。在每次迭代中：\n    a.  **适应度景观构建**：通过从 $U[0,1]$ 中抽取独立同分布样本，生成一个包含 $2^N$ 个适应度值的数组。每个基因型（由其从 $0$ 到 $2^N-1$ 的整数索引表示）被分配这些随机适应度值中的一个。\n    b.  **局部最大值识别**：算法遍历每个基因型索引 $i \\in \\{0, \\dots, 2^N-1\\}$。将适应度 $F_i$ 与其 $N$ 个邻居的适应度进行比较。基因型 $i$ 的邻居由索引 $i \\oplus 2^j$（按位异或）标识，其中 $j \\in \\{0, \\dots, N-1\\}$。如果 $F_i$ 是该集合中的严格最大值，则当前实例的计数器加一。\n    c.  **分数计算**：将实例的局部最大值分数计算为（计数 / $2^N$）并存储。\n3.  **结果汇总**：在所有 $R$ 个实例完成后，计算存储分数的平均值。\n4.  **输出**：该过程返回一个列表，其中包含局部最大值的平均分数、理论分数 $\\frac{1}{N+1}$ 以及这两个值之间的绝对差。\n\n提供的 Python 代码实现了这些算法，以生成四个测试案例的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve_additive_case(N, seed):\n    \"\"\"\n    Solves for the K=0 additive landscape case.\n    - Constructs the landscape based on per-locus contributions.\n    - Enumerates all genotypes and finds local maxima.\n    - Returns the empirical count, theoretical count, and a boolean for equality.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # f_table[i, b] is the fitness contribution f_i(b) for locus i and bit b.\n    f_table = rng.uniform(size=(N, 2))\n    \n    num_genotypes = 1  N\n    genotypes = []\n    # Generate all 2^N genotypes as tuples of (0,1)\n    for i in range(num_genotypes):\n        genotype = tuple((i >> (N - 1 - j))  1 for j in range(N))\n        genotypes.append(genotype)\n\n    # Calculate and store fitness for all genotypes\n    fitness_map = {}\n    for g in genotypes:\n        fitness = np.sum(f_table[i, g[i]] for i in range(N)) / N\n        fitness_map[g] = fitness\n\n    # Count local maxima\n    local_maxima_count = 0\n    for g in genotypes:\n        current_fitness = fitness_map[g]\n        is_local_max = True\n        for i in range(N):\n            neighbor_list = list(g)\n            neighbor_list[i] = 1 - neighbor_list[i]\n            neighbor = tuple(neighbor_list)\n            if current_fitness = fitness_map[neighbor]:\n                is_local_max = False\n                break\n        if is_local_max:\n            local_maxima_count += 1\n            \n    theoretical_count = 1\n    return [local_maxima_count, theoretical_count, local_maxima_count == theoretical_count]\n\ndef solve_hoc_case(N, R, seed):\n    \"\"\"\n    Solves for the K=N-1 House-of-Cards limit case.\n    - Runs R independent simulations.\n    - In each simulation, fitness values are i.i.d. draws.\n    - Returns the average fraction of maxima, theoretical fraction, and absolute difference.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    num_genotypes = 1  N\n    \n    fractions = []\n    for _ in range(R):\n        # For each instance, generate a new random landscape\n        fitness_values = rng.uniform(size=num_genotypes)\n        \n        instance_maxima_count = 0\n        for i in range(num_genotypes):\n            current_fitness = fitness_values[i]\n            is_local_max = True\n            for j in range(N):\n                # Neighbor's index is found by flipping the j-th bit\n                neighbor_idx = i ^ (1  j)\n                if current_fitness = fitness_values[neighbor_idx]:\n                    is_local_max = False\n                    break\n            if is_local_max:\n                instance_maxima_count += 1\n        \n        fractions.append(instance_maxima_count / num_genotypes)\n\n    avg_fraction = np.mean(fractions)\n    theoretical_fraction = 1.0 / (N + 1)\n    abs_diff = np.abs(avg_fraction - theoretical_fraction)\n    \n    return [avg_fraction, theoretical_fraction, abs_diff]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_suite = [\n        # 1. Additive landscape case ($K=0$)\n        {'func': solve_additive_case, 'params': {'N': 5, 'seed': 12345}},\n        # 2. House-of-Cards limit\n        {'func': solve_hoc_case, 'params': {'N': 8, 'R': 3000, 'seed': 67890}},\n        # 3. House-of-Cards limit (small boundary case)\n        {'func': solve_hoc_case, 'params': {'N': 2, 'R': 50000, 'seed': 13579}},\n        # 4. Additive landscape case (trivial boundary)\n        {'func': solve_additive_case, 'params': {'N': 1, 'seed': 24680}},\n    ]\n\n    results = []\n    for test in test_suite:\n        result = test['func'](**test['params'])\n        results.append(result)\n\n    # The spec requires a specific print format. The Python default for a list\n    # includes spaces, which we will use as per the provided template code.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}