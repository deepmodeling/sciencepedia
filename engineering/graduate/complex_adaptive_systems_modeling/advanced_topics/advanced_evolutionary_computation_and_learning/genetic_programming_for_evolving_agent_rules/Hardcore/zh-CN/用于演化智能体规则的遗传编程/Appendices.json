{
    "hands_on_practices": [
        {
            "introduction": "遗传编程在一个广阔的程序空间中进行搜索。为了确保生成的程序在结构上始终有效，尤其是在处理多种数据类型的领域中，强类型遗传编程（STGP）至关重要。本练习旨在深入探究强类型遗传编程的核心机制，通过计算一个随机点突变保持类型正确的概率，来具体理解类型约束是如何影响遗传算子的。这项实践将帮助你量化地认识到函数和终端集的设计如何塑造演化搜索的“景观”，并影响其效率 ()。",
            "id": "4125248",
            "problem": "考虑一个强类型遗传编程（GP）系统，该系统在一个具有类型集 $\\{\\mathsf{R}, \\mathsf{B}, \\mathsf{U}\\}$ 的多类型域中演化智能体决策规则，其中 $\\mathsf{R}$ 表示实值量，$\\mathsf{B}$ 表示布尔值，$\\mathsf{U}$ 表示动作。函数和终结符库由元数和类型签名定义如下。\n\n- 元数为 $0$ 的终结符（每个终结符只有一个输出类型）：有 $5$ 个类型为 $\\mathsf{R}$ 的终结符，$2$ 个类型为 $\\mathsf{B}$ 的终结符，以及 $3$ 个类型为 $\\mathsf{U}$ 的终结符。\n- 元数为 $1$ 的函数（每个函数有一个输入和一个输出类型）：有 $4$ 个签名为 $\\mathsf{R} \\to \\mathsf{R}$ 的函数，$2$ 个签名为 $\\mathsf{B} \\to \\mathsf{B}$ 的函数，$1$ 个签名为 $\\mathsf{U} \\to \\mathsf{R}$ 的函数，$1$ 个签名为 $\\mathsf{U} \\to \\mathsf{B}$ 的函数，以及 $1$ 个签名为 $\\mathsf{R} \\to \\mathsf{B}$ 的函数。\n- 元数为 $2$ 的函数（每个函数有两个有序输入和一个输出类型）：有 $3$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$ 的函数，$2$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}$ 的函数，$3$ 个签名为 $(\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$ 的函数，$1$ 个签名为 $(\\mathsf{U},\\mathsf{R}) \\to \\mathsf{U}$ 的函数，以及 $1$ 个签名为 $(\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$ 的函数。\n- 元数为 $3$ 的函数（每个函数有三个有序输入和一个输出类型）：有 $1$ 个签名为 $(\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$ 的函数，$1$ 个签名为 $(\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$ 的函数，以及 $1$ 个签名为 $(\\mathsf{B},\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$ 的函数。\n\n一个特定的良类型程序树（智能体规则）有 $12$ 个节点，每个节点具有以下上下文，其中每个节点的上下文包括其元数 $k$、其子节点输出类型的有序元组以及其自身的输出类型（该类型与父节点在该位置期望的输入类型相匹配，如果该节点是原始良类型树中的根节点，则与程序的输出类型相匹配）：\n\n- 节点 $1$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{U},\\mathsf{U})$，输出 $\\mathsf{U}$。\n- 节点 $2$：$k=1$，子节点 $(\\mathsf{U})$，输出 $\\mathsf{B}$。\n- 节点 $3$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{B}$。\n- 节点 $4$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n- 节点 $5$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{R}$。\n- 节点 $6$：$k=0$，输出 $\\mathsf{U}$。\n- 节点 $7$：$k=0$，输出 $\\mathsf{R}$。\n- 节点 $8$：$k=0$，输出 $\\mathsf{B}$。\n- 节点 $9$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n- 节点 $10$：$k=2$，子节点 $(\\mathsf{B},\\mathsf{B})$，输出 $\\mathsf{B}$。\n- 节点 $11$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{B}$。\n- 节点 $12$：$k=0$，输出 $\\mathsf{R}$。\n\n点突变的定义如下：从 $12$ 个节点中均匀随机选择一个节点，其符号被替换为从全局符号库中与该节点具有相同元数 $k$ 的所有符号中均匀随机抽取的一个符号。树的形状以及该节点子节点的子树保持不变。该突变算子不考虑类型；通常情况下，替换后的符号可能与子节点以及父节点期望的类型兼容，也可能不兼容。\n\n利用树的强类型基本属性，即全局类型正确性能得以保持，当且仅当在突变节点处，替换符号的输入类型与子节点的输出类型按顺序完全匹配，并且其输出类型与父节点在该位置期望的类型相匹配（如果该节点是根节点，则与程序的输出类型相匹配），计算单次均匀随机点突变（如定义）产生一个良类型树的精确概率。\n\n将你的最终答案表示为一个简化的精确分数。不要四舍五入。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n\n- **类型集**：$\\{\\mathsf{R}, \\mathsf{B}, \\mathsf{U}\\}$，表示实数、布尔和动作类型。\n- **函数和终结符库**：\n    - **元数 0（终结符）**：\n        - $5$ 个类型为 $\\mathsf{R}$。\n        - $2$ 个类型为 $\\mathsf{B}$。\n        - $3$ 个类型为 $\\mathsf{U}$。\n    - **元数 1（函数）**：\n        - $4$ 个签名为 $\\mathsf{R} \\to \\mathsf{R}$。\n        - $2$ 个签名为 $\\mathsf{B} \\to \\mathsf{B}$。\n        - $1$ 个签名为 $\\mathsf{U} \\to \\mathsf{R}$。\n        - $1$ 个签名为 $\\mathsf{U} \\to \\mathsf{B}$。\n        - $1$ 个签名为 $\\mathsf{R} \\to \\mathsf{B}$。\n    - **元数 2（函数）**：\n        - $3$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n        - $2$ 个签名为 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}$。\n        - $3$ 个签名为 $(\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$。\n        - $1$ 个签名为 $(\\mathsf{U},\\mathsf{R}) \\to \\mathsf{U}$。\n        - $1$ 个签名为 $(\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$。\n    - **元数 3（函数）**：\n        - $1$ 个签名为 $(\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$。\n        - $1$ 个签名为 $(\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n        - $1$ 个签名为 $(\\mathsf{B},\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$。\n- **程序树结构**：一个包含 $12$ 个节点的树，具有以下上下文（元数 $k$、子节点输出类型、自身输出类型）：\n    - 节点 $1$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{U},\\mathsf{U})$，输出 $\\mathsf{U}$。\n    - 节点 $2$：$k=1$，子节点 $(\\mathsf{U})$，输出 $\\mathsf{B}$。\n    - 节点 $3$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{B}$。\n    - 节点 $4$：$k=2$，子节点 $(\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n    - 节点 $5$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{R}$。\n    - 节点 $6$：$k=0$，输出 $\\mathsf{U}$。\n    - 节点 $7$：$k=0$，输出 $\\mathsf{R}$。\n    - 节点 $8$：$k=0$，输出 $\\mathsf{B}$。\n    - 节点 $9$：$k=3$，子节点 $(\\mathsf{B},\\mathsf{R},\\mathsf{R})$，输出 $\\mathsf{R}$。\n    - 节点 $10$：$k=2$，子节点 $(\\mathsf{B},\\mathsf{B})$，输出 $\\mathsf{B}$。\n    - 节点 $11$：$k=1$，子节点 $(\\mathsf{R})$，输出 $\\mathsf{B}$。\n    - 节点 $12$：$k=0$，输出 $\\mathsf{R}$。\n- **突变算子**：\n    - 从 $12$ 个节点中均匀随机选择一个节点。\n    - 其符号被替换为从全局库中具有相同元数 $k$ 的所有符号子集中均匀随机抽取的另一个符号。\n- **有效性条件**：当且仅当替换符号的输入类型与子节点的输出类型相匹配，并且其输出类型与父节点期望的类型相匹配时，突变后的树才是良类型的。\n- **目标**：计算单次此类突变产生一个良类型树的精确概率。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题设置在遗传编程（GP）的背景下，这是演化计算和人工智能的一个子领域。强类型 GP 和点突变是该领域的标准概念。该问题是基于这些概念的一个定义明确的组合概率练习。它不含伪科学和推测。\n- **问题定义良好**：问题提供了所有必要的信息：完整的类型集、可用的遗传算子（终结符和函数）及其类型签名的完整清单、程序树的结构，以及对突变操作和成功（类型正确）结果的精确定义。这使得计算一个唯一的、精确的概率成为可能。\n- **客观性**：问题以计算机科学和数学中常见的精确、形式化的语言陈述。它没有任何主观看法或含糊之处。\n\n该问题是一个标准的、自洽的、一致的练习，它将概率论应用于计算机科学中的一个特定算法。它满足所有有效性标准。\n\n### 步骤 3：结论和行动\n\n问题有效。将提供解答。\n\n## 解答\n\n问题要求计算在一个特定的 $12$ 节点程序树上进行单次点突变后，得到一个良类型树的概率。突变过程涉及两个均匀随机选择：首先，从 $N=12$ 个节点中选择一个进行突变；其次，从与所选节点具有相同元数的所有符号集合中选择一个替换符号。\n\n设 $E$ 为突变产生良类型树的事件，设 $C_i$ 为选择节点 $i$ 进行突变的事件，其中 $i \\in \\{1, 2, \\dots, 12\\}$。由于节点是均匀随机选择的，选择任何特定节点 $i$ 的概率为 $P(C_i) = \\frac{1}{12}$。\n\n有效突变的总概率是每个节点上发生有效突变的概率之和，并按选择该节点的概率加权。根据全概率公式：\n$$P(E) = \\sum_{i=1}^{12} P(E | C_i) P(C_i)$$\n由于对所有 $i$ 都有 $P(C_i) = \\frac{1}{12}$，这可以简化为：\n$$P(E) = \\frac{1}{12} \\sum_{i=1}^{12} P(E | C_i)$$\n这里，$P(E | C_i)$ 是在节点 $i$ 上的突变是类型正确的概率。如果随机选择的替换符号的类型签名与节点 $i$ 的上下文相匹配，则该事件发生。替换符号是从库中与节点 $i$ 具有相同元数的所有符号中均匀选择的。\n\n我们首先为每个元数 $k$ 统计可用符号的总数。设 $N_k$ 为元数为 $k$ 的符号总数。\n- 元数 $k=0$：$N_0 = 5 (\\text{类型 }\\mathsf{R}) + 2 (\\text{类型 }\\mathsf{B}) + 3 (\\text{类型 }\\mathsf{U}) = 10$。\n- 元数 $k=1$：$N_1 = 4 (\\mathsf{R} \\to \\mathsf{R}) + 2 (\\mathsf{B} \\to \\mathsf{B}) + 1 (\\mathsf{U} \\to \\mathsf{R}) + 1 (\\mathsf{U} \\to \\mathsf{B}) + 1 (\\mathsf{R} \\to \\mathsf{B}) = 9$。\n- 元数 $k=2$：$N_2 = 3 ((\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}) + 2 ((\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}) + 3 ((\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}) + 1 ((\\mathsf{U},\\mathsf{R}) \\to \\mathsf{U}) + 1 ((\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}) = 10$。\n- 元数 $k=3$：$N_3 = 1 ((\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}) + 1 ((\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}) + 1 ((\\mathsf{B},\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}) = 3$。\n\n现在我们为每个节点 $i=1, \\dots, 12$ 计算 $P_i = P(E|C_i)$。$P_i$ 是具有所需类型签名的符号数量与相同元数的符号总数之比。\n\n- **节点 1**：$k=3$，签名 $(\\mathsf{B},\\mathsf{U},\\mathsf{U}) \\to \\mathsf{U}$。\n库中有 $1$ 个具有此签名的函数。元数为 $3$ 的函数总数为 $N_3=3$。\n$P_1 = \\frac{1}{3}$。\n\n- **节点 2**：$k=1$，签名 $\\mathsf{U} \\to \\mathsf{B}$。\n库中有 $1$ 个具有此签名的函数。元数为 $1$ 的函数总数为 $N_1=9$。\n$P_2 = \\frac{1}{9}$。\n\n- **节点 3**：$k=2$，签名 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{B}$。\n库中有 $2$ 个具有此签名的函数。元数为 $2$ 的函数总数为 $N_2=10$。\n$P_3 = \\frac{2}{10} = \\frac{1}{5}$。\n\n- **节点 4**：$k=2$，签名 $(\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n库中有 $3$ 个具有此签名的函数。元数为 $2$ 的函数总数为 $N_2=10$。\n$P_4 = \\frac{3}{10}$。\n\n- **节点 5**：$k=1$，签名 $\\mathsf{R} \\to \\mathsf{R}$。\n库中有 $4$ 个具有此签名的函数。元数为 $1$ 的函数总数为 $N_1=9$。\n$P_5 = \\frac{4}{9}$。\n\n- **节点 6**：$k=0$，输出类型 $\\mathsf{U}$。\n库中有 $3$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_6 = \\frac{3}{10}$。\n\n- **节点 7**：$k=0$，输出类型 $\\mathsf{R}$。\n库中有 $5$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_7 = \\frac{5}{10} = \\frac{1}{2}$。\n\n- **节点 8**：$k=0$，输出类型 $\\mathsf{B}$。\n库中有 $2$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_8 = \\frac{2}{10} = \\frac{1}{5}$。\n\n- **节点 9**：$k=3$，签名 $(\\mathsf{B},\\mathsf{R},\\mathsf{R}) \\to \\mathsf{R}$。\n库中有 $1$ 个具有此签名的函数。元数为 $3$ 的函数总数为 $N_3=3$。\n$P_9 = \\frac{1}{3}$。\n\n- **节点 10**：$k=2$，签名 $(\\mathsf{B},\\mathsf{B}) \\to \\mathsf{B}$。\n库中有 $3$ 个具有此签名的函数。元数为 $2$ 的函数总数为 $N_2=10$。\n$P_{10} = \\frac{3}{10}$。\n\n- **节点 11**：$k=1$，签名 $\\mathsf{R} \\to \\mathsf{B}$。\n库中有 $1$ 个具有此签名的函数。元数为 $1$ 的函数总数为 $N_1=9$。\n$P_{11} = \\frac{1}{9}$。\n\n- **节点 12**：$k=0$，输出类型 $\\mathsf{R}$。\n库中有 $5$ 个此类型的终结符。元数为 $0$ 的终结符总数为 $N_0=10$。\n$P_{12} = \\frac{5}{10} = \\frac{1}{2}$。\n\n现在，我们将这些概率相加：\n$$ \\sum_{i=1}^{12} P_i = P_1 + P_2 + P_3 + P_4 + P_5 + P_6 + P_7 + P_8 + P_9 + P_{10} + P_{11} + P_{12} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{1}{3} + \\frac{1}{9} + \\frac{1}{5} + \\frac{3}{10} + \\frac{4}{9} + \\frac{3}{10} + \\frac{1}{2} + \\frac{1}{5} + \\frac{1}{3} + \\frac{3}{10} + \\frac{1}{9} + \\frac{1}{2} $$\n将具有相同分母的项分组：\n$$ \\sum_{i=1}^{12} P_i = \\left(\\frac{1}{3}+\\frac{1}{3}\\right) + \\left(\\frac{1}{9}+\\frac{4}{9}+\\frac{1}{9}\\right) + \\left(\\frac{1}{5}+\\frac{1}{5}\\right) + \\left(\\frac{3}{10}+\\frac{3}{10}+\\frac{3}{10}\\right) + \\left(\\frac{1}{2}+\\frac{1}{2}\\right) $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{2}{3} + \\frac{6}{9} + \\frac{2}{5} + \\frac{9}{10} + \\frac{2}{2} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{2}{3} + \\frac{2}{3} + \\frac{2}{5} + \\frac{9}{10} + 1 $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{4}{3} + \\frac{2}{5} + \\frac{9}{10} + 1 $$\n为了对这些分数求和，我们找到一个公分母，即 $\\text{lcm}(3, 5, 10) = 30$。\n$$ \\sum_{i=1}^{12} P_i = \\frac{4 \\times 10}{3 \\times 10} + \\frac{2 \\times 6}{5 \\times 6} + \\frac{9 \\times 3}{10 \\times 3} + \\frac{30}{30} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{40}{30} + \\frac{12}{30} + \\frac{27}{30} + \\frac{30}{30} $$\n$$ \\sum_{i=1}^{12} P_i = \\frac{40 + 12 + 27 + 30}{30} = \\frac{109}{30} $$\n最后，我们计算总概率 $P(E)$：\n$$ P(E) = \\frac{1}{12} \\sum_{i=1}^{12} P_i = \\frac{1}{12} \\times \\frac{109}{30} $$\n$$ P(E) = \\frac{109}{12 \\times 30} = \\frac{109}{360} $$\n数字 $109$ 是一个素数，所以这个分数是最简形式。",
            "answer": "$$\\boxed{\\frac{109}{360}}$$"
        },
        {
            "introduction": "由遗传编程演化出的智能体规则可以有多种表现形式。行为树（Behavior Trees, BTs）是一种流行且直观的表示方法，但理解其形式化属性以及与其他模型（如有限状态机 FSMs）的等价性，对于规则的分析和部署至关重要。本练习通过将行为树映射到等价的有限状态机，让你亲身实践计算等价性的概念，并理解在特定假设下（如无记忆执行），反应式行为树可以如何被精确地转换为有限状态机。这项技能对于模型验证、简化以及在不同计算环境中部署演化出的智能体逻辑非常有价值 ()。",
            "id": "4125224",
            "problem": "在复杂自适应系统 (CAS) 和用于演化智能体规则的遗传编程 (GP) 的背景下，您将获得一个用于简单导航任务的行为树 (BT) 和有限状态机 (FSM) 的形式化定义。在单叶执行语义下，智能体在每个tick感知一个二进制输入向量，并每个tick输出一个确切的动作。您的任务是构建一个从指定片段中的任何 BT 到等效 FSM 的映射，陈述等效性成立的假设，并在提供的测试套件上通过仿真验证等效性。\n\n定义和假设：\n- 行为树 (BT) 是一种有根有序树，其内部节点是选择器或序列，叶节点是条件或动作。我们考虑一个具有瞬时节点和每个tick单叶执行的片段。条件读取当前传感器值。动作是瞬时的且总是成功。没有记忆、没有黑板、没有运行状态，除了可能的否定条件值外，没有装饰器。\n- 有限状态机 (FSM) 是一种确定性机器，具有有限的状态集和将当前状态及输入映射到下一状态的转移函数。FSM 通过将每个状态解释为当前选择的动作，在每个tick产生一个动作输出。我们使用 Mealy 风格的转移函数和 Moore 风格的输出解释，其中下一个状态编码了下一个动作。\n- 智能体拥有固定顺序的传感器，在tick $t$ 的每个输入是一个二进制向量 $x_t \\in \\{0,1\\}^4$，其四个分量分别是 $O_t$ (前方有障碍物)、$G_t$ (目标可见)、$L_t$ (左侧无障碍)和 $R_t$ (右侧无障碍)。每个分量 $O_t$、$G_t$、$L_t$、$R_t$ 均在 $\\{0,1\\}$ 中。\n- 动作集为 $A = \\{\\text{forward}, \\text{turn\\_left}, \\text{turn\\_right}, \\text{stop}\\}$。\n\n行为树节点语义：\n- 条件叶节点被指定为一个三元组 $\\text{cond}(s, v)$，其中 $s \\in \\{O,G,L,R\\}$ 且 $v \\in \\{0,1\\}$。当且仅当当前输入满足 $x_t[s] = v$ 时，它返回成功，否则返回失败。\n- 动作叶节点被指定为 $\\text{act}(a)$，其中 $a \\in A$。它总是返回成功，并为当前tick产生动作 $a$。\n- 序列节点 $\\text{seq}([n_1,\\dots,n_k])$ 从左到右评估其子节点，当且仅当所有子节点都返回成功时，它才返回成功；在单叶执行假设下，遍历在为当前tick执行遇到的第一个动作叶节点后停止。\n- 选择器节点 $\\text{sel}([n_1,\\dots,n_k])$ 从左到右评估其子节点，当且仅当第一个返回成功的子节点这样做时，它才返回成功；在单叶执行假设下，当第一个可行的子节点产生一个动作时，遍历停止。\n\n映射目标：\n- 构建一个映射 $\\Phi$，它接受一个 BT 并生成一个 FSM，该 FSM 的状态是 $A$ 的元素，其转移函数 $\\delta$ 对所有 $s \\in A$ 和所有输入 $x_t$ 满足 $\\delta(s,x_t) = a(x_t)$，其中 $a(x_t)$ 是 BT 在输入 $x_t$ 下根据上述 BT 语义选择的动作。等效性意味着对于任何有限输入序列 $(x_1,\\dots,x_T)$，BT 产生的动作序列等于 FSM 产生的状态序列，对所有 $T \\in \\mathbb{N}$ 成立。\n\n等效性必须成立的假设：\n- 确定性评估：对于任何输入 $x_t$，BT 选择一个唯一的动作 $a(x_t) \\in A$，并且对于所有 $s \\in A$，FSM 的转移 $\\delta(s,x_t)$ 是唯一确定的。\n- 单叶tick语义：每个tick只执行一个动作叶节点。\n- 瞬时、无记忆的条件和动作：节点状态仅取决于 $x_t$；除了最后执行的动作之外，没有持久性记忆，并且动作执行在tick内完成。\n- 没有运行状态或黑板变量；没有时间相关的装饰器或随机节点。\n\n要实现的表示法：\n- 节点表示为嵌套元组：\n  - 选择器: $\\text{sel}([c_1,\\dots,c_k])$。\n  - 序列: $\\text{seq}([c_1,\\dots,c_k])$。\n  - 条件: $\\text{cond}(s, v)$，其中 $s \\in \\{\\text{\"O\"}, \\text{\"G\"}, \\text{\"L\"}, \\text{\"R\"}\\}$ 且 $v \\in \\{0,1\\}$。\n  - 动作: $\\text{act}(a)$，其中 $a \\in \\{\\text{\"forward\"}, \\text{\"turn\\_left\"}, \\text{\"turn\\_right\"}, \\text{\"stop\"}\\}$。\n- 在tick $t$ 的输入向量是一个有序四元组 $x_t = (O_t,G_t,L_t,R_t)$，每个分量都在 $\\{0,1\\}$ 中。\n- BT 评估函数必须根据语义为每个输入 $x_t$ 选择一个动作。\n- 映射 $\\Phi$ 必须构建一个 FSM，其状态等于 BT 中存在的动作集合，并且其转移函数 $\\delta$ 将任何当前状态和输入映射到等于该输入下 BT 所选动作的下一个动作状态。\n\n测试套件：\n- 有 $4$ 个测试用例。对于每个测试用例，在给定的输入序列上模拟 BT 和映射的 FSM；测试结果是一个布尔值，指示动作序列是否逐个tick相同。\n- 测试用例 1 (正常路径，带目标检查的避障)：\n  - BT: $\\text{sel}([\\ \\text{seq}([\\ \\text{cond}(\\text{\"G\"},1),\\ \\text{act}(\\text{\"stop\"})\\ ]),\\ \\text{seq}([\\ \\text{cond}(\\text{\"O\"},1),\\ \\text{sel}([\\ \\text{seq}([\\ \\text{cond}(\\text{\"L\"},1),\\ \\text{act}(\\text{\"turn\\_left\"})\\ ]),\\ \\text{seq}([\\ \\text{cond}(\\text{\"R\"},1),\\ \\text{act}(\\text{\"turn\\_right\"})\\ ]),\\ \\text{act}(\\text{\"stop\"})\\ ])\\ ]),\\ \\text{act}(\\text{\"forward\"})\\ ])$.\n  - 长度为 8 的输入序列： $[(0,0,1,1),\\ (1,0,1,0),\\ (1,0,0,1),\\ (1,0,0,0),\\ (0,1,0,0),\\ (0,0,0,0),\\ (1,1,1,1),\\ (1,0,1,1)]$.\n- 测试用例 2 (边界情况，单个动作叶节点)：\n  - BT: $\\text{act}(\\text{\"forward\"})$.\n  - 长度为 3 的输入序列： $[(1,1,0,0),\\ (0,0,1,0),\\ (1,0,1,1)]$.\n- 测试用例 3 (边缘情况，带否定的嵌套合取)：\n  - BT: $\\text{sel}([\\ \\text{seq}([\\ \\text{cond}(\\text{\"G\"},1),\\ \\text{cond}(\\text{\"O\"},0),\\ \\text{act}(\\text{\"stop\"})\\ ]),\\ \\text{seq}([\\ \\text{cond}(\\text{\"O\"},1),\\ \\text{act}(\\text{\"turn\\_right\"})\\ ]),\\ \\text{act}(\\text{\"forward\"})\\ ])$.\n  - 长度为 6 的输入序列： $[(0,1,0,0),\\ (1,1,0,0),\\ (1,0,0,0),\\ (0,0,0,0),\\ (0,1,0,0),\\ (1,0,0,0)]$.\n- 测试用例 4 (边缘情况，重叠的守卫条件和优先级)：\n  - BT: $\\text{sel}([\\ \\text{seq}([\\ \\text{cond}(\\text{\"L\"},1),\\ \\text{act}(\\text{\"turn\\_left\"})\\ ]),\\ \\text{seq}([\\ \\text{cond}(\\text{\"R\"},1),\\ \\text{act}(\\text{\"turn\\_right\"})\\ ]),\\ \\text{seq}([\\ \\text{cond}(\\text{\"G\"},1),\\ \\text{act}(\\text{\"stop\"})\\ ]),\\ \\text{act}(\\text{\"forward\"})\\ ])$.\n  - 长度为 5 的输入序列： $[(0,1,1,1),\\ (0,1,0,1),\\ (0,1,0,0),\\ (0,0,0,0),\\ (0,1,1,0)]$.\n\n要求输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$），其中每个 $\\text{result}_i$ 是一个布尔值，指示测试用例 $i$ 的等效性。\n\n需要实现的内容：\n- 在所述语义下实现 BT 评估。\n- 按照描述实现从 BT 到 FSM 的映射 $\\Phi$。\n- 对于每个测试用例，比较 BT 和 FSM 在输入序列上的动作序列，并以指定格式输出等效性布尔值。\n\n科学真实性与适用性：\n- 此映射使遗传编程 (GP) 的从业者能够将在所述假设下演化出的 BT 策略转换为 FSM 以进行分析或部署，同时保留其行为，这与复杂自适应系统 (CAS) 中的建模需求相符。",
            "solution": "问题要求构建一个从行为树 (BTs) 的特定片段到等效有限状态机 (FSMs) 的映射，陈述此等效性成立的假设，并通过在给定的测试套件上进行仿真来验证该映射。\n\n**1. 系统等效性分析**\n\n指定的行为树与目标有限状态机之间等效性的基础在于它们共有的无记忆特性。\n\n根据问题定义，行为树是一个反应式系统，其在任意tick $t$ 的输出仅取决于同一tick的感官输入 $x_t$。这些约束——无记忆、无黑板、无 `running` 状态以及瞬时动作——确保了BT的状态不会跨tick持续存在。因此，BT可以被建模为一个纯函数 $\\mathcal{B}$，它将一个输入向量 $x_t \\in \\{0,1\\}^4$ 映射到一个动作 $a_t \\in A$，其中 $A = \\{\\text{forward}, \\text{turn\\_left}, \\text{turn\\_right}, \\text{stop}\\}$。我们可以将其写作 $a_t = \\mathcal{B}(x_t)$。\n\n目标FSM由一个状态集（即动作集 $A$）和一个转移函数 $\\delta: A \\times \\{0,1\\}^4 \\to A$ 定义。问题规定此转移函数必须满足 $\\delta(s, x_t) = a(x_t)$，其中 $a(x_t)$ 是由BT选择的动作。这意味着转移函数被定义为 $\\delta(s, x_t) = \\mathcal{B}(x_t)$。该定义的一个关键推论是 FSM 的下一个状态与其当前状态 $s$ 无关。FSM 的状态更新规则实际上是 $s_t = \\mathcal{B}(x_t)$，其中 $s_{t-1}$ 没有影响。这样的系统是一个无状态转换器，其在时间 $t$ 的输出仅是其在时间 $t$ 的输入的函数。\n\n等效性要求对于任何输入序列 $(x_1, x_2, \\ldots, x_T)$，BT产生的动作序列与FSM产生的动作序列相同。\n- BT的动作序列是 $(a_1, a_2, \\ldots, a_T)$，其中 $a_t = \\mathcal{B}(x_t)$。\n- FSM的输出是Moore风格的，其中tick $t$ 的动作是它在tick $t$ 的状态 $s_t$。状态序列是 $(s_1, s_2, \\ldots, s_T)$。\n- 状态转移是 $s_t = \\delta(s_{t-1}, x_t)$。根据 $\\delta$ 的定义，这变为 $s_t = \\mathcal{B}(x_t)$。\n- 因此，FSM的动作序列是 $(\\mathcal{B}(x_1), \\mathcal{B}(x_2), \\ldots, \\mathcal{B}(x_T))$。\n\n根据定义，这与BT的动作序列是相同的。因此，验证任务是正确实现函数 $\\mathcal{B}(x_t)$，并证明两个仿真模型在使用此函数时，会产生相同的输出。\n\n**2. 映射 $\\Phi$: BT到FSM**\n\n映射 $\\Phi$ 接受一个 BT 并生成一个 FSM。\n- **状态**：FSM 的状态集是 BT 叶节点中存在的所有唯一动作的集合，是 $A$ 的一个子集。\n- **转移函数**：FSM 的转移函数 $\\delta(s, x)$ 对于任何状态 $s$ 和任何输入 $x$ 都由 BT 自身的评估逻辑定义：$\\delta(s, x) = \\mathcal{B}(x)$。此映射的实现包括实现 BT 评估函数 $\\mathcal{B}$。\n\n**3. BT评估的算法设计**\n\n主要挑战是根据指定的语义实现BT评估函数 $\\mathcal{B}(x_t)$，特别是“单叶执行”规则。该规则规定，对于给定的tick，树的评估在第一个动作叶节点执行后立即停止。这种非局部控制转移最好使用异常来建模。\n\n我们设计了一个递归函数 `evaluate_bt_node(node, input)`。它遍历树并返回一个布尔值，指示成功或失败。当一个动作叶节点被成功评估时，它不返回；而是抛出一个包含所选动作的自定义 `ActionFound` 异常。此异常会沿调用栈向上传播，直到被顶层包装函数 `get_bt_action(bt, input)` 捕获，然后该函数返回捕获的动作。这正确地模拟了tick评估的终止。\n\n`evaluate_bt_node` 中每种节点类型的逻辑如下：\n- **`act(a)` (动作叶节点)**：此节点总是成功。它抛出 `ActionFound(a)` 以表示已选择动作 $a$ 且评估应停止。\n- **`cond(s, v)` (条件叶节点)**：此节点检查 $s$ 的传感器输入是否等于值 $v$。如果 $x_t[s] = v$ 则返回 `True`，否则返回 `False`。它不抛出异常。\n- **`seq([n_1, ..., n_k])` (序列节点)**：此节点按顺序评估其子节点 $n_1, \\ldots, n_k$。它仅在子节点 $n_i$ 返回 `True` 时才继续评估子节点 $n_{i+1}$。如果任何子节点返回 `False`，序列节点立即失败并返回 `False`。如果所有子节点都被评估并返回 `True`（这只在它们都是条件节点时才可能发生），则序列节点成功并返回 `True`。如果一个子节点触发了 `ActionFound` 异常，该异常会向上传播，从而正确地停止序列的执行。\n- **`sel([n_1, ..., n_k])` (选择器节点)**：此节点按顺序评估其子节点 $n_1, \\ldots, n_k$。如果任何子节点返回 `True`，选择器节点立即成功并返回 `True`。如果一个子节点返回 `False`，它会继续处理下一个子节点。如果所有子节点都返回 `False`，选择器节点失败并返回 `False`。与序列节点一样，来自子节点的 `ActionFound` 异常会向上传播，从而停止选择器的执行。\n\n**4. 仿真与验证**\n\n为了验证等效性，实现了两个仿真函数：\n1.  `simulate_bt(bt, input_sequence)`：此函数遍历输入序列。对于每个输入向量 $x_t$，它调用 `get_bt_action(bt, x_t)` 并将结果动作附加到列表中。\n2.  `simulate_fsm(bt, input_sequence)`：此函数也遍历输入序列。对于每个输入 $x_t$，它计算 FSM 的下一个状态 $s_t$，该状态也是该tick的动作。下一个状态由转移函数决定，$s_t = \\delta(s_{t-1}, x_t)$。由于 $\\delta(s, x) = \\mathcal{B}(x) = \\text{get\\_bt\\_action(bt, x)}$，FSM 仿真在每一步也调用 `get_bt\\_action(bt, x_t)` 来确定下一个状态/动作。\n\n每个测试用例的验证涉及比较两个生成的动作序列。正确的实现保证它们将是相同的。\n\n**5. 等效性假设**\n\n等效性在以下假设下成立，这些假设在问题中明确说明并在设计中得到遵守：\n- **确定性和完整性评估**：对于任何输入 $x_t$，BT 的结构应能选择一个且仅一个唯一的动作 $a(x_t)$。这通常通过将一个默认动作作为根选择器的最后一个子节点来确保。\n- **无记忆执行**：在tick $t$ 对任何节点的评估仅取决于输入 $x_t$。没有从先前tick延续下来的持久状态（例如，`running` 状态）或共享内存（例如，黑板）。\n- **瞬时节点**：所有节点（条件和动作）都在单个仿真tick内执行和完成。\n\n这些假设将BT的动态特性简化为一个纯组合函数，从而能够直接映射到指定的无状态FSM结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the BT-to-FSM mapping and verification task.\n    \"\"\"\n\n    # Custom exception for non-local control flow in BT evaluation,\n    # implementing the \"single-leaf execution\" semantic.\n    class ActionFound(Exception):\n        \"\"\"Raised when a BT action leaf is executed.\"\"\"\n        def __init__(self, action):\n            super().__init__(f\"Action selected: {action}\")\n            self.action = action\n\n    # A mapping from sensor names to their index in the input vector.\n    SENSOR_MAP = {\"O\": 0, \"G\": 1, \"L\": 2, \"R\": 3}\n\n    def evaluate_bt_node(node, input_vec):\n        \"\"\"\n        Recursively evaluates a BT node. Returns True for success, False for failure.\n        Raises ActionFound when an action is executed.\n        \"\"\"\n        node_type = node[0]\n\n        if node_type == \"act\":\n            action = node[1]\n            raise ActionFound(action)\n        \n        elif node_type == \"cond\":\n            sensor, value = node[1]\n            sensor_idx = SENSOR_MAP[sensor]\n            return input_vec[sensor_idx] == value\n        \n        elif node_type == \"seq\":\n            children = node[1]\n            for child in children:\n                if not evaluate_bt_node(child, input_vec):\n                    return False  # Sequence fails on first child failure\n            return True  # All children succeeded\n        \n        elif node_type == \"sel\":\n            children = node[1]\n            for child in children:\n                if evaluate_bt_node(child, input_vec):\n                    return True  # Selector succeeds on first child success\n            return False  # All children failed\n        \n        else:\n            raise TypeError(f\"Unknown node type: {node_type}\")\n\n    def get_bt_action(bt_root, input_vec):\n        \"\"\"\n        Top-level wrapper for BT evaluation for a single tick.\n        Catches the ActionFound exception and returns the selected action.\n        \"\"\"\n        try:\n            evaluate_bt_node(bt_root, input_vec)\n            # This line should be unreachable under the problem's assumption that\n            # an action is always selected.\n            raise ValueError(\"BT evaluation completed without selecting an action.\")\n        except ActionFound as e:\n            return e.action\n\n    def simulate_bt(bt_root, input_sequence):\n        \"\"\"\n        Simulates the BT over a sequence of inputs, producing a sequence of actions.\n        \"\"\"\n        return [get_bt_action(bt_root, input_vec) for input_vec in input_sequence]\n\n    def simulate_fsm(bt_root, input_sequence):\n        \"\"\"\n        Simulates the equivalent FSM. The FSM's transition function is defined\n        by the BT's evaluation logic, making its simulation identical in this case.\n        The next state (which is the output action) depends only on the current input.\n        \"\"\"\n        # FSM action at tick t is state s_t.\n        # s_t = delta(s_{t-1}, x_t) = get_bt_action(bt_root, x_t).\n        return [get_bt_action(bt_root, input_vec) for input_vec in input_sequence]\n\n    # Test cases defined using nested tuples.\n    test_cases = [\n        (\n            # Test Case 1 BT\n            (\"sel\", [\n                (\"seq\", [(\"cond\", (\"G\", 1)), (\"act\", \"stop\")]),\n                (\"seq\", [\n                    (\"cond\", (\"O\", 1)),\n                    (\"sel\", [\n                        (\"seq\", [(\"cond\", (\"L\", 1)), (\"act\", \"turn_left\")]),\n                        (\"seq\", [(\"cond\", (\"R\", 1)), (\"act\", \"turn_right\")]),\n                        (\"act\", \"stop\"),\n                    ]),\n                ]),\n                (\"act\", \"forward\"),\n            ]),\n            # Test Case 1 Input Sequence\n            [(0,0,1,1), (1,0,1,0), (1,0,0,1), (1,0,0,0), (0,1,0,0), (0,0,0,0), (1,1,1,1), (1,0,1,1)],\n        ),\n        (\n            # Test Case 2 BT\n            (\"act\", \"forward\"),\n            # Test Case 2 Input Sequence\n            [(1,1,0,0), (0,0,1,0), (1,0,1,1)],\n        ),\n        (\n            # Test Case 3 BT\n            (\"sel\", [\n                (\"seq\", [(\"cond\", (\"G\", 1)), (\"cond\", (\"O\", 0)), (\"act\", \"stop\")]),\n                (\"seq\", [(\"cond\", (\"O\", 1)), (\"act\", \"turn_right\")]),\n                (\"act\", \"forward\"),\n            ]),\n            # Test Case 3 Input Sequence\n            [(0,1,0,0), (1,1,0,0), (1,0,0,0), (0,0,0,0), (0,1,0,0), (1,0,0,0)],\n        ),\n        (\n            # Test Case 4 BT\n            (\"sel\", [\n                (\"seq\", [(\"cond\", (\"L\", 1)), (\"act\", \"turn_left\")]),\n                (\"seq\", [(\"cond\", (\"R\", 1)), (\"act\", \"turn_right\")]),\n                (\"seq\", [(\"cond\", (\"G\", 1)), (\"act\", \"stop\")]),\n                (\"act\", \"forward\"),\n            ]),\n            # Test Case 4 Input Sequence\n            [(0,1,1,1), (0,1,0,1), (0,1,0,0), (0,0,0,0), (0,1,1,0)],\n        ),\n    ]\n\n    results = []\n    for bt_root, input_seq in test_cases:\n        bt_actions = simulate_bt(bt_root, input_seq)\n        fsm_actions = simulate_fsm(bt_root, input_seq)\n        is_equivalent = bt_actions == fsm_actions\n        results.append(is_equivalent)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在随机环境中评估智能体规则时，环境内在的随机性常常会掩盖不同规则之间的真实性能差异。为了进行统计上稳健的比较，我们需要高效的实验设计方法。本练习介绍了共同随机数（Common Random Numbers, CRN）这一重要的方差缩减技术，它通过让不同的智能体规则面对完全相同的随机事件序列，来最大程度地减少环境“运气”带来的噪声，从而凸显规则性能差异的“信号”。通过理论推导和实际计算，你将掌握CRN有效性背后的数学原理，并学会量化其优势，这对于任何从事随机模拟研究的学者来说，都是一项以更少计算成本获得更精确结论的核心技能 ()。",
            "id": "4125258",
            "problem": "考虑一个复杂自适应系统中的两个智能体规则。在每次运行中，环境会生成外生随机输入，建模为随机向量 $\\boldsymbol{\\xi}$。每个智能体规则将 $\\boldsymbol{\\xi}$ 转换为一个标量性能结果：规则 $A$ 产生 $Y_A(\\boldsymbol{\\xi})$，规则 $B$ 产生 $Y_B(\\boldsymbol{\\xi})$。假设 $Y_A(\\boldsymbol{\\xi})$ 和 $Y_B(\\boldsymbol{\\xi})$ 是具有有限方差的平方可积随机变量。目标是估计平均性能差异 $\\Delta = \\mathbb{E}[Y_A(\\boldsymbol{\\xi})] - \\mathbb{E}[Y_B(\\boldsymbol{\\xi})]$。\n\n您将比较两种实验设计：\n- 独立运行：为 $A$ 和 $B$ 使用不同的伪随机数流，从而产生 $Y_A$ 和 $Y_B$ 的独立样本。\n- 公共随机数（CRN）：使用共享的伪随机数流，以便在每次配对运行中，$A$ 和 $B$ 都看到相同的 $\\boldsymbol{\\xi}$。\n\n仅从期望、方差、协方差、独立性的基本定义以及均值的蒙特卡洛估计器出发，推导独立设计和 CRN 设计下均值差估计器的方差。然后，用 CRN 设计下的边际方差和相关系数，将 CRN 相对于独立运行的方差减少量表示为一个分数。您的推导必须从 $\\mathbb{E}[\\cdot]$、$\\operatorname{Var}[\\cdot]$ 和 $\\operatorname{Cov}[\\cdot]$ 的定义开始，并且必须假设在 CRN 设计下有 $n$ 次独立同分布的配对运行（或在独立设计下每个规则有 $n$ 次独立运行）。\n\n为了可复现性和科学真实性，请为这些智能体规则提出一种 CRN 设计，该设计能对齐伪随机数生成器的调用，以便在每次配对运行中，环境中的微观层面随机事件在 $A$ 和 $B$ 之间是同步的。您的提议必须确保当规则对 $\\boldsymbol{\\xi}$ 的反应相似时，$Y_A(\\boldsymbol{\\xi})$ 和 $Y_B(\\boldsymbol{\\xi})$ 能实现一个明确定义的非负相关。\n\n您的程序必须计算并报告每个测试用例中 CRN 相对于独立运行的理论方差减少分数，定义为 $R = 1 - \\frac{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}]}{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}]}$，以小数形式表示（无百分号）。使用参数化 $(\\sigma_A^2, \\sigma_B^2, \\rho, n)$，其中 $\\sigma_A^2 = \\operatorname{Var}[Y_A(\\boldsymbol{\\xi})]$, $\\sigma_B^2 = \\operatorname{Var}[Y_B(\\boldsymbol{\\xi})]$, $\\rho$ 是 CRN 设计下的相关系数 $\\rho = \\frac{\\operatorname{Cov}[Y_A(\\boldsymbol{\\xi}), Y_B(\\boldsymbol{\\xi})]}{\\sigma_A \\sigma_B}$，$n$ 是配对运行的次数。您的程序应计算每个案例的 $R$ 值，并输出一行包含在方括号内的逗号分隔列表。将每个结果四舍五入到 $6$ 位小数。\n\n使用以下参数值测试套件以覆盖典型和边界行为：\n- 案例 1（正相关，等方差，典型情况）：$(\\sigma_A^2 = 4.0, \\sigma_B^2 = 4.0, \\rho = 0.8, n = 100)$。\n- 案例 2（完全正相关，等方差，边界情况）：$(\\sigma_A^2 = 9.0, \\sigma_B^2 = 9.0, \\rho = 1.0, n = 50)$。\n- 案例 3（负相关，非对称方差，边缘情况）：$(\\sigma_A^2 = 1.0, \\sigma_B^2 = 4.0, \\rho = -0.5, n = 200)$。\n- 案例 4（零相关，非对称方差，基线情况）：$(\\sigma_A^2 = 2.25, \\sigma_B^2 = 1.0, \\rho = 0.0, n = 1000)$。\n- 案例 5（高正相关，高度非对称方差）：$(\\sigma_A^2 = 16.0, \\sigma_B^2 = 1.0, \\rho = 0.9, n = 300)$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是为案例 $i$ 计算并四舍五入的方差减少分数。",
            "solution": "该问题要求对两种实验设计——独立运行和公共随机数（CRN）——的均值差估计器的方差进行形式化推导，然后给出 CRN 的方差减少表达式。它还要求为智能体基础的仿真情境提出一个 CRN 实现方案，并最终为几个测试用例计算方差减少量。\n\n让我们从建立基本定义和感兴趣数量的估计器开始。\n智能体规则 $A$ 和 $B$ 的性能结果分别是随机变量 $Y_A(\\boldsymbol{\\xi})$ 和 $Y_B(\\boldsymbol{\\xi})$。为简单起见，我们将其表示为 $Y_A$ 和 $Y_B$。目标是估计它们期望性能的差异，$\\Delta = \\mathbb{E}[Y_A] - \\mathbb{E}[Y_B]$。设 $\\mu_A = \\mathbb{E}[Y_A]$ 且 $\\mu_B = \\mathbb{E}[Y_B]$。方差给定为 $\\operatorname{Var}[Y_A] = \\sigma_A^2$ 和 $\\operatorname{Var}[Y_B] = \\sigma_B^2$。\n\n使用蒙特卡洛方法进行估计。基于 $n$ 次仿真运行，我们为每个规则获得样本。设规则 $A$ 的结果为 $\\{Y_{A,1}, Y_{A,2}, \\dots, Y_{A,n}\\}$，规则 $B$ 的结果为 $\\{Y_{B,1}, Y_{B,2}, \\dots, Y_{B,n}\\}$。单个均值的估计器为：\n$$ \\hat{\\mu}_A = \\frac{1}{n} \\sum_{i=1}^{n} Y_{A,i} \\quad \\text{和} \\quad \\hat{\\mu}_B = \\frac{1}{n} \\sum_{i=1}^{n} Y_{B,i} $$\n差异 $\\Delta$ 的估计器自然是 $\\hat{\\Delta} = \\hat{\\mu}_A - \\hat{\\mu}_B$。我们可以将其写为：\n$$ \\hat{\\Delta} = \\frac{1}{n} \\sum_{i=1}^{n} (Y_{A,i} - Y_{B,i}) $$\n我们的目标是求出该估计器在两种不同实验设计下的方差 $\\operatorname{Var}[\\hat{\\Delta}]$。\n\n**独立运行下估计器的方差**\n\n在独立运行设计中，用于生成 $\\{Y_{A,i}\\}$ 的随机数集与用于生成 $\\{Y_{B,i}\\}$ 的随机数集在统计上是独立的。这意味着对于所有 $i,j \\in \\{1, \\dots, n\\}$，$Y_{A,i}$ 都独立于 $Y_{B,j}$。因此，估计器 $\\hat{\\mu}_A$ 和 $\\hat{\\mu}_B$ 是独立的随机变量。\n\n两个独立随机变量之和的方差是它们方差的和。因此，估计器 $\\hat{\\Delta}_{\\mathrm{ind}}$ 的方差是：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}] = \\operatorname{Var}[\\hat{\\mu}_A - \\hat{\\mu}_B] = \\operatorname{Var}[\\hat{\\mu}_A] + \\operatorname{Var}[-\\hat{\\mu}_B] = \\operatorname{Var}[\\hat{\\mu}_A] + (-1)^2 \\operatorname{Var}[\\hat{\\mu}_B] = \\operatorname{Var}[\\hat{\\mu}_A] + \\operatorname{Var}[\\hat{\\mu}_B] $$\n现在，我们推导 $\\hat{\\mu}_A$ 的方差。样本 $Y_{A,1}, \\dots, Y_{A,n}$ 是独立同分布（i.i.d.）的，方差为 $\\sigma_A^2$。\n$$ \\operatorname{Var}[\\hat{\\mu}_A] = \\operatorname{Var}\\left[\\frac{1}{n} \\sum_{i=1}^{n} Y_{A,i}\\right] $$\n使用属性 $\\operatorname{Var}[cX] = c^2\\operatorname{Var}[X]$：\n$$ \\operatorname{Var}[\\hat{\\mu}_A] = \\frac{1}{n^2} \\operatorname{Var}\\left[\\sum_{i=1}^{n} Y_{A,i}\\right] $$\n由于 $Y_{A,i}$ 是独立的，它们的和的方差是它们方差的和：\n$$ \\operatorname{Var}[\\hat{\\mu}_A] = \\frac{1}{n^2} \\sum_{i=1}^{n} \\operatorname{Var}[Y_{A,i}] = \\frac{1}{n^2} \\sum_{i=1}^{n} \\sigma_A^2 = \\frac{1}{n^2} (n \\sigma_A^2) = \\frac{\\sigma_A^2}{n} $$\n通过相同的推理，$\\operatorname{Var}[\\hat{\\mu}_B] = \\frac{\\sigma_B^2}{n}$。\n将这些代入 $\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}]$ 的表达式中得到：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}] = \\frac{\\sigma_A^2}{n} + \\frac{\\sigma_B^2}{n} = \\frac{\\sigma_A^2 + \\sigma_B^2}{n} $$\n\n**公共随机数（CRN）下估计器的方差**\n\n在 CRN 设计中，对于每次配对运行 $i \\in \\{1, \\dots, n\\}$，两个规则都使用相同的随机数序列进行仿真，即相同的外生输入 $\\boldsymbol{\\xi}_i$。这在 $Y_{A,i}$ 和 $Y_{B,i}$ 之间引入了相关性。配对 $(Y_{A,i}, Y_{B,i})$ 在 $i=1, \\dots, n$ 之间是独立同分布的。\n令 $Z_i = Y_{A,i} - Y_{B,i}$。那么估计器是 $\\hat{\\Delta}_{\\mathrm{CRN}} = \\frac{1}{n} \\sum_{i=1}^{n} Z_i$。由于配对 $(Y_{A,i}, Y_{B,i})$ 是独立同分布的，差值 $Z_i$ 也是独立同分布的。\n估计器的方差为：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}] = \\operatorname{Var}\\left[\\frac{1}{n} \\sum_{i=1}^{n} Z_i\\right] = \\frac{1}{n^2} \\sum_{i=1}^{n} \\operatorname{Var}[Z_i] = \\frac{n \\operatorname{Var}[Z_1]}{n^2} = \\frac{\\operatorname{Var}[Z_1]}{n} $$\n我们现在需要求 $\\operatorname{Var}[Z_1] = \\operatorname{Var}[Y_{A,1} - Y_{B,1}]$。两个相关随机变量之差的方差由以下恒等式给出：\n$$ \\operatorname{Var}[X - Y] = \\operatorname{Var}[X] + \\operatorname{Var}[Y] - 2\\operatorname{Cov}[X, Y] $$\n应用这个恒等式，我们得到：\n$$ \\operatorname{Var}[Z_1] = \\operatorname{Var}[Y_{A,1}] + \\operatorname{Var}[Y_{B,1}] - 2\\operatorname{Cov}[Y_{A,1}, Y_{B,1}] $$\n边际方差 $\\operatorname{Var}[Y_{A,1}]$ 和 $\\operatorname{Var}[Y_{B,1}]$ 仍然是 $\\sigma_A^2$ 和 $\\sigma_B^2$。协方差项 $\\operatorname{Cov}[Y_{A,1}, Y_{B,1}]$（我们记为 $\\operatorname{Cov}[Y_A, Y_B]$）在 CRN 下通常不为零。\n因此，CRN 下估计器的方差是：\n$$ \\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}] = \\frac{\\sigma_A^2 + \\sigma_B^2 - 2\\operatorname{Cov}[Y_A, Y_B]}{n} $$\n\n**方差减少分数**\n\n方差减少分数 $R$ 定义为 $R = 1 - \\frac{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{CRN}}]}{\\operatorname{Var}[\\hat{\\Delta}_{\\mathrm{ind}}]}$。代入推导出的表达式：\n$$ R = 1 - \\frac{(\\sigma_A^2 + \\sigma_B^2 - 2\\operatorname{Cov}[Y_A, Y_B])/n}{(\\sigma_A^2 + \\sigma_B^2)/n} $$\n样本量 $n$ 被消去，表明相对方差减少量与运行次数无关：\n$$ R = 1 - \\frac{\\sigma_A^2 + \\sigma_B^2 - 2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} $$\n$$ R = 1 - \\left( \\frac{\\sigma_A^2 + \\sigma_B^2}{\\sigma_A^2 + \\sigma_B^2} - \\frac{2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} \\right) = 1 - \\left( 1 - \\frac{2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} \\right) $$\n$$ R = \\frac{2\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A^2 + \\sigma_B^2} $$\n最后，我们用相关系数 $\\rho = \\frac{\\operatorname{Cov}[Y_A, Y_B]}{\\sigma_A \\sigma_B}$ 来表示它，其中 $\\sigma_A = \\sqrt{\\sigma_A^2}$ 和 $\\sigma_B = \\sqrt{\\sigma_B^2}$ 是标准差。根据这个定义，$\\operatorname{Cov}[Y_A, Y_B] = \\rho \\sigma_A \\sigma_B$。\n将此代入 $R$ 的表达式中：\n$$ R = \\frac{2 \\rho \\sigma_A \\sigma_B}{\\sigma_A^2 + \\sigma_B^2} $$\n这是理论方差减少分数的最终表达式。正相关（$\\rho  0$）会导致正的方差减少（$R  0$），而负相关（$\\rho  0$）会导致方差增加（$R  0$）。如果 $\\rho=0$，与独立设计相比，方差没有变化。\n\n**CRN 设计方案**\n\n为了在基于智能体的模型中有效实施 CRN，目标是同步规则 $A$ 和规则 $B$ 下的智能体在每次配对运行中所经历的随机事件。这确保了观察到的任何性能差异更有可能是由于规则本身，而不是随机运气上的差异。\n\n一个科学上稳健的 CRN 设计可以按以下方式构建：\n1.  **复现种子设定**：仿真进行 $n$ 次配对复现。应生成一个包含 $n$ 个不同种子的主序列 $\\{S_1, S_2, \\dots, S_n\\}$。对于每次复现 $i$，规则 $A$ 仿真的伪随机数生成器（PRNG）和规则 $B$ 仿真的 PRNG 都用相同的种子 $S_i$ 初始化。\n2.  **随机数流的同步**：CRN 的核心在于确保规则 $A$ 仿真中请求的第 $k$ 个随机数与其在规则 $B$ 仿真中用于相同逻辑目的的第 $k$ 个随机数相同。\n    - 例如，如果第一个随机事件是确定资源的初始位置，则两个仿真都应使用来自其同步流的第一个随机数 $U_1$ 来完成此目的。如果第二个事件是确定智能体的通信尝试是否成功，两者都应使用 $U_2$。\n    - 当规则 $A$ 和规则 $B$ 的逻辑决定了不同数量的随机数抽取时，会出现一个关键挑战。例如，如果规则 $A$ 导致一个需要 $3$ 个随机数的操作，而规则 $B$ 导致一个只需要 $1$ 个随机数的操作，那么流将在所有后续事件中变得不同步。\n3.  **通过多流实现的稳健同步**：一种减轻不同步问题的更优方法是使用多个独立的 PRNG 流，每个流专用于模型中特定的随机性来源。例如：\n    - 流 1：用于初始智能体布局。\n    - 流 2：用于随机环境变化（例如，资源补充）。\n    - 流 3：用于智能体行动成功概率（例如，觅食成功）。\n    每个流都是公共随机数包的一部分；对于复现 $i$，规则 $A$ 仿真中的流 $j$ 与规则 $B$ 仿真中的流 $j$ 同步。这样，如果规则 $A$ 需要为其特有逻辑进行额外的抽取，它可以从一个规则 $B$ 不使用的专用流中抽取，从而保持公共流的同步。\n4.  **实现非负相关**：通过同步底层的随机事件，我们确保两个规则在给定的运行中面临相同的“有利”或“不利”条件。如果智能体规则 $A$ 和 $B$ 在结构上相似（例如，是某个基本启发式算法的变体），它们很可能会以类似的方式对这些条件做出反应。一组有利的随机事件（例如，资源丰富，风险低）可能会为两者都带来高性能（$Y_A$ 和 $Y_B$ 都高），而不利的事件会导致两者表现都差（$Y_A$ 和 $Y_B$ 都低）。$Y_A$ 和 $Y_B$ 趋于同向变化的这种趋势导致了正的协方差，$\\operatorname{Cov}[Y_A, Y_B]  0$，从而产生正相关 $\\rho  0$。这种正相关是方差减少的来源。\n\n这种结构化设计确保了 CRN 技术的正确应用，从而能够对智能体规则进行统计上高效的比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the theoretical variance reduction fraction of Common Random Numbers (CRN)\n    relative to independent runs for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_A^2, sigma_B^2, rho, n)\n    # sigma_A^2: Variance of outcome for rule A\n    # sigma_B^2: Variance of outcome for rule B\n    # rho: Correlation coefficient between Y_A and Y_B under CRN\n    # n: Number of paired runs (note: n is not used in the final formula for R)\n    test_cases = [\n        (4.0, 4.0, 0.8, 100),\n        (9.0, 9.0, 1.0, 50),\n        (1.0, 4.0, -0.5, 200),\n        (2.25, 1.0, 0.0, 1000),\n        (16.0, 1.0, 0.9, 300)\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma_A_sq, sigma_B_sq, rho, _ = case\n        \n        # The theoretical variance reduction fraction is given by the formula:\n        # R = (2 * rho * sigma_A * sigma_B) / (sigma_A^2 + sigma_B^2)\n        \n        # Calculate the standard deviations\n        sigma_A = np.sqrt(sigma_A_sq)\n        sigma_B = np.sqrt(sigma_B_sq)\n        \n        # Numerator of the fraction R\n        numerator = 2 * rho * sigma_A * sigma_B\n        \n        # Denominator of the fraction R\n        denominator = sigma_A_sq + sigma_B_sq\n        \n        # The problem statement gives positive variances, so no division by zero is expected.\n        result = numerator / denominator\n        \n        # Round the result to 6 decimal places as required.\n        results.append(round(result, 6))\n\n    # Format the final output as a comma-separated list in square brackets.\n    # The map(str, ...) is necessary to handle potential negative signs and floating point representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver function.\nsolve()\n```"
        }
    ]
}