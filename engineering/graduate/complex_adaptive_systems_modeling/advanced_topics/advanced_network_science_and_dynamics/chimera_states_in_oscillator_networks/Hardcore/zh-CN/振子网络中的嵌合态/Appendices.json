{
    "hands_on_practices": [
        {
            "introduction": "在分析振子网络时，全局Kuramoto序参数是衡量整体同步水平的经典工具。然而，当系统呈现出如嵌合态这般复杂的时空模式时，单一的全局平均值能否准确捕捉其本质？本练习 () 将通过一个精心设计的思想实验，引导你亲手计算并揭示全局序参数在识别有序与无序共存状态时的内在局限性。",
            "id": "4117505",
            "problem": "考虑一个由 $N=1200$ 个相同的非局部耦合相位振子组成的环形网络，该网络在复杂自适应系统建模的框架下进行研究。其相位的快照展现了相干与非相干的共存现象：一个连续的相干域和一个互补的非相干域。具体来说，相位由以下划分给出：\n- 对于 $1 \\leq j \\leq 360$，振子的相位被锁定在 $\\theta_{j}=0$（单位为弧度）。\n- 对于 $361 \\leq j \\leq 1200$，振子在单位圆上均匀分布：$\\theta_{j}=\\frac{2\\pi}{840}\\big(j-361\\big)$（单位为弧度），这枚举了圆上所有 $840$ 个等距点的完整集合。\n\n从全局 Kuramoto 序参数的核心定义出发，计算复数平均值\n$$R\\,\\exp(i\\Psi)=\\frac{1}{N}\\sum_{j=1}^{N}\\exp\\big(i\\theta_{j}\\big),$$\n并以精确有理数的形式返回其模 $R$。然后，利用关于单位圆上平均化的第一性原理，并且不借助标准定义之外的任何现成诊断公式，解释为什么单个全局 $R$ 值可能无法分辨通常在嵌合态（chimera states）中观察到的相干与非相干的共存现象。\n\n将最终的模 $R$ 精确地表示为一个有理数。角度以弧度为单位。最终答案不需要单位。",
            "solution": "这个问题提法清晰且科学上合理，为进行完整分析提供了所有必要信息。我们需要计算给定相位分布下的全局 Kuramoto 序参数的模，并解释这一全局度量的局限性。\n\n全局 Kuramoto 序参数定义为一个复数 $Z = R\\,\\exp(i\\Psi)$，其中 $R$ 是模，$\\Psi$ 是平均相位。它的计算方法是网络中所有振子相量（phasor）的复数平均值：\n$$Z = R\\,\\exp(i\\Psi)=\\frac{1}{N}\\sum_{j=1}^{N}\\exp\\big(i\\theta_{j}\\big)$$\n振子总数为 $N=1200$。该网络被划分为两个不同的子群体。\n\n首先，我们通过将求和分解到两个区域来计算总和 $\\sum_{j=1}^{N}\\exp(i\\theta_{j})$：相干域和非相干域。\n$$\\sum_{j=1}^{1200}\\exp\\big(i\\theta_{j}\\big) = \\sum_{j=1}^{360}\\exp\\big(i\\theta_{j}\\big) + \\sum_{j=361}^{1200}\\exp\\big(i\\theta_{j}\\big)$$\n\n让我们评估相干域的求和。该子群体由 $N_c = 360$ 个振子组成，索引从 $j=1$ 到 $j=360$。它们的相位都锁定在 $\\theta_{j}=0$ 弧度。\n$$\\sum_{j=1}^{360}\\exp\\big(i\\theta_{j}\\big) = \\sum_{j=1}^{360}\\exp(i \\cdot 0) = \\sum_{j=1}^{360} 1 = 360$$\n这一组的相量都沿着正实轴对齐，它们的和是一个实数，等于该组中的振子数量。\n\n接下来，我们评估非相干域的求和。该子群体由 $N_i = 1200 - 360 = 840$ 个振子组成，索引从 $j=361$ 到 $j=1200$。它们的相位由 $\\theta_{j}=\\frac{2\\pi}{840}\\big(j-361\\big)$ 给出。\n为了简化求和，我们引入一个新的索引 $k = j-361$。当 $j=361$ 时，$k=0$。当 $j=1200$ 时，$k=1200-361=839$。求和变为：\n$$\\sum_{j=361}^{1200}\\exp\\left(i\\frac{2\\pi}{840}(j-361)\\right) = \\sum_{k=0}^{839}\\exp\\left(i\\frac{2\\pi k}{840}\\right)$$\n这个求和中的各项 $\\exp\\left(i\\frac{2\\pi k}{840}\\right)$（其中 $k=0, 1, \\dots, 839$）代表了 $840$ 次单位根的完整集合。从几何上看，这些是 840 个单位长度的向量，在单位圆上均匀分布。由于对称性，这些向量的和为零。\n这可以通过将该和视为一个有限几何级数 $\\sum_{k=0}^{n-1} ar^k = a\\frac{1-r^n}{1-r}$ 来正式证明，其中 $a=1$，$n=840$，公比为 $r = \\exp\\left(i\\frac{2\\pi}{840}\\right)$。由于 $n=840$，所以 $r \\neq 1$。\n$$\\sum_{k=0}^{839} r^k = \\frac{1-r^{840}}{1-r} = \\frac{1-\\left(\\exp\\left(i\\frac{2\\pi}{840}\\right)\\right)^{840}}{1-\\exp\\left(i\\frac{2\\pi}{840}\\right)} = \\frac{1-\\exp(i2\\pi)}{1-\\exp\\left(i\\frac{2\\pi}{840}\\right)} = \\frac{1-1}{1-\\exp\\left(i\\frac{2\\pi}{840}\\right)} = 0$$\n因此，非相干域上的和为 $0$。\n\n现在，我们可以结合两个域的结果来找到总和：\n$$\\sum_{j=1}^{1200}\\exp\\big(i\\theta_{j}\\big) = 360 + 0 = 360$$\n将此代入全局序参数的定义中：\n$$Z = \\frac{1}{1200} (360) = \\frac{360}{1200} = \\frac{36}{120} = \\frac{3}{10}$$\n复数平均值是一个实数，$Z = \\frac{3}{10}$。模 $R$ 是 $Z$ 的绝对值。\n$$R = \\left|\\frac{3}{10}\\right| = \\frac{3}{10}$$\n\n对于问题的第二部分，我们解释为什么全局序参数 $R$ 对于嵌合态来说是一个不充分的诊断工具。\n全局序参数 $R$ 本质上是一个通过对整个振子群体进行平均而获得的宏观度量。根据其作为平均值的定义，它将所有 $N$ 个振子的详细相位配置简化为单个复数。\n在给定的问题中，系统表现出一种截然不同的异构结构：一个完全相干的子群体与一个完全非相干的子群体共存。我们可以通过考虑每个子群体的序参数来分析这一点。\n设 $Z_c$ 为相干组（$N_c = 360$ 个振子）的序参数，$Z_i$ 为非相干组（$N_i = 840$ 个振子）的序参数。\n$$Z_c = \\frac{1}{N_c}\\sum_{j=1}^{360}\\exp\\big(i\\theta_j\\big) = \\frac{1}{360} \\sum_{j=1}^{360}\\exp(i \\cdot 0) = \\frac{360}{360} = 1$$\n$$Z_i = \\frac{1}{N_i}\\sum_{j=361}^{1200}\\exp\\big(i\\theta_j\\big) = \\frac{1}{840} \\sum_{k=0}^{839}\\exp\\left(i\\frac{2\\pi k}{840}\\right) = \\frac{0}{840} = 0$$\n相干组的局部序参数的模为 $R_c = |Z_c| = 1$，表示完全的相同步。对于非相干组，其模为 $R_i = |Z_i| = 0$，表示完全的异步。\n全局序参数 $Z$ 可以表示为子群体序参数的加权平均：\n$$Z = \\frac{1}{N}\\left(N_c Z_c + N_i Z_i\\right) = \\frac{N_c}{N}Z_c + \\frac{N_i}{N}Z_i$$\n$$Z = \\frac{360}{1200}(1) + \\frac{840}{1200}(0) = \\frac{3}{10}$$\n结果 $R = |Z| = \\frac{3}{10}$ 是一个介于 $0$ 和 $1$ 之间的中间值。全局度量 $R$ 的一个关键缺陷是它无法将这种特定的嵌合态与一个完全不同的、空间均匀的状态区分开来。例如，一个由 1200 个振子组成的网络可能处于部分同步状态，其中每个振子具有大致相同的相位相关水平，从而导致全局序参数为 $R = \\frac{3}{10}$。这样的状态在动力学和结构上都与嵌合态不同，但它会产生相同的全局诊断值。\n因此，单个标量值 $R$ 内在地平均掉并掩盖了关于不同动力学行为（网络不同区域的相干与非相干）共存的空间信息，而这正是嵌合态的定义性特征。解析这类状态需要能够捕捉这种异质性的局部或空间分辨的度量。",
            "answer": "$$\\boxed{\\frac{3}{10}}$$"
        },
        {
            "introduction": "认识到全局度量的局限后，下一步是掌握能够刻画空间异质性的局部诊断工具。本练习 () 将指导你实现一套用于识别嵌合态的核心算法，包括计算局部序参数和嵌合指数。通过分析给定的相位快照，你将学会如何从原始数据中定量地识别并分类这些复杂的共存模式。",
            "id": "4117507",
            "problem": "给定一维环形网络上振荡器相位的快照，要求您计算局部相干性、空间非相干性分数和奇美拉指数，然后根据指定的阈值判断每个快照是否符合奇美拉的条件。该环形网络在单一时刻有 $N$ 个振荡器，其相位 $\\theta_i$ 以弧度为单位，索引为 $i \\in \\{0,1,\\dots,N-1\\}$，并具有周期性边界条件。\n\n使用的定义：\n\n1. 局部Kuramoto序参量。对于每个索引 $i$，以及给定的整数邻域半宽 $L \\ge 0$，定义\n$$\nr_i = \\left| \\frac{1}{2L+1} \\sum_{j=-L}^{L} e^{\\mathrm{i}\\,\\theta_{(i+j) \\bmod N}} \\right| .\n$$\n这衡量了节点 $i$ 周围相位的局部相干性。\n\n2. 空间非相干性。给定一个相干性阈值 $r_{\\mathrm{thr}} \\in [0,1]$，根据以下规则在每个节点上定义一个二元分类：\n$$\n\\text{节点 } i \\text{ 是非相干的，如果 } r_i   r_{\\mathrm{thr}}, \\quad \\text{否则是相干的}。\n$$\n如果节点 $i$ 是非相干的，则令 $b_i$ 为 $1$，否则为 $0$。空间非相干性则为\n$$\nSI = \\frac{1}{N} \\sum_{i=0}^{N-1} b_i .\n$$\n\n3. 环上的奇美拉指数。定义奇美拉指数 $X$ 为环上连续的非相干簇的数量。形式上，使用周期性索引，\n$$\nX = \n\\begin{cases}\n0,  \\text{如果 } SI = 0, \\\\\n1,  \\text{如果 } SI = 1, \\\\\n\\sum_{i=0}^{N-1} \\left[ b_i = 1 \\wedge b_{(i-1) \\bmod N} = 0 \\right],  \\text{其他情况},\n\\end{cases}\n$$\n其中 $\\left[\\cdot\\right]$ 表示其内部逻辑条件为真时的指示函数。\n\n4. 奇美拉判定。给定阈值 $SI_{\\min}$、$SI_{\\max}$（满足 $0 \\le SI_{\\min}  SI_{\\max} \\le 1$）和一个最小域数量 $X_{\\min} \\in \\mathbb{N}$，当且仅当\n$$\nSI_{\\min}  SI  SI_{\\max} \\quad \\text{且} \\quad X \\ge X_{\\min}.\n$$\n时，将快照判定为奇美拉。\n\n角度单位是弧度。没有需要报告的物理单位。对于数值报告，将每个 $r_i$ 和 $SI$ 四舍五入到小数点后4位。每个测试用例的最终输出必须是以下形式的列表：\n$$\n[\\,[r_0,\\dots,r_{N-1}],\\, SI,\\, X,\\, \\text{chimera\\_bool}\\,],\n$$\n其中 $[r_0,\\dots,r_{N-1}]$ 是四舍五入后的局部序参量列表，$SI$ 是四舍五入后的空间非相干性，$X$ 是整数奇美拉指数，$\\text{chimera\\_bool}$ 是一个布尔值。您的程序应生成单行输出，包含所有测试用例的结果，结果为逗号分隔的列表并用方括号括起来（例如：$[\\text{result1},\\text{result2},\\text{result3}]$）。\n\n测试套件。使用以下5个测试用例：\n\n- 用例 A (均匀相干):\n  - $N = 12$, $L = 2$, $r_{\\mathrm{thr}} = 0.95$, $SI_{\\min} = 0.05$, $SI_{\\max} = 0.95$, $X_{\\min} = 1$.\n  - 相位: $\\theta_i = 0$ 对所有 $i$。\n\n- 用例 B (展开态，高非相干性阈值):\n  - $N = 12$, $L = 2$, $r_{\\mathrm{thr}} = 0.8$, $SI_{\\min} = 0.05$, $SI_{\\max} = 0.95$, $X_{\\min} = 1$.\n  - 相位: $\\theta_i = \\frac{2\\pi i}{N}$ 对 $i=0,\\dots,N-1$。\n\n- 用例 C (单个连续非相干域):\n  - $N = 20$, $L = 2$, $r_{\\mathrm{thr}} = 0.85$, $SI_{\\min} = 0.2$, $SI_{\\max} = 0.8$, $X_{\\min} = 1$.\n  - 相位: $\\theta_i = 0$ 对 $i = 0,\\dots,9$，以及 $\\theta_i = \\frac{2\\pi (i-10)}{10}$ 对 $i=10,\\dots,19$。\n\n- 用例 D (由相干岛屿分隔的两个非相干域):\n  - $N = 24$, $L = 2$, $r_{\\mathrm{thr}} = 0.85$, $SI_{\\min} = 0.3$, $SI_{\\max} = 0.9$, $X_{\\min} = 2$.\n  - 相位: $\\theta_i = 0$ 对 $i \\in \\{0,1,2,3,4,5,12,13,14,15,16,17\\}$; $\\theta_i = \\frac{2\\pi (i-6)}{6}$ 对 $i \\in \\{6,7,8,9,10,11\\}$; $\\theta_i = \\frac{2\\pi (i-18)}{6}$ 对 $i \\in \\{18,19,20,21,22,23\\}$。\n\n- 用例 E (产生多个边界的交替块):\n  - $N = 16$, $L = 1$, $r_{\\mathrm{thr}} = 0.7$, $SI_{\\min} = 0.1$, $SI_{\\max} = 0.9$, $X_{\\min} = 2$.\n  - 相位: 四个大小为$4$的块交替出现，分别为 $0$ 和局部斜坡,\n    $\\theta_i = 0$ 对 $i \\in \\{0,1,2,3\\}$，$\\theta_i = \\frac{2\\pi (i-4)}{4}$ 对 $i \\in \\{4,5,6,7\\}$，$\\theta_i = 0$ 对 $i \\in \\{8,9,10,11\\}$，$\\theta_i = \\frac{2\\pi (i-12)}{4}$ 对 $i \\in \\{12,13,14,15\\}$。\n\n您的程序必须实现上述定义的计算，并生成仅包含一行输出，该行包含五个结果的列表，每个结果本身都是一个列表 $[\\,[r_0,\\dots,r_{N-1}],\\, SI,\\, X,\\, \\text{chimera\\_bool}\\,]$，并按规定进行四舍五入。",
            "solution": "该问题要求分析一维环形网络上振荡器相位的几个快照，以确定它们是否代表奇美拉态。此分析涉及计算一套标准指标：局部Kuramoto序参量、空间非相干性以及奇美拉指数。基于这些指标和一组给定的阈值，做出最终分类。该过程是确定性的，并遵循所提供的数学定义。\n\n分析的基础建立在局部同步的概念之上。Kuramoto序参量是相位同步的标准度量。其局部版本 $r_i$ 用于评估振荡器 $i$ 特定邻域内的同步程度。$r_i=1$ 的值表示完美的局部相干性（所有相邻相位都相同），而 $r_i=0$ 表示最大的局部非相干性。\n\n该问题是有效的，因为它在科学上植根于复杂系统和非线性动力学的既定理论，在数学上是适定的，具有明确的定义，并提出了一个客观、可验证的计算任务。所有数据和参数都已提供，确保每个测试用例都有唯一的解决方案。\n\n解决每个测试用例问题的算法流程如下：\n\n**步骤1：计算局部Kuramoto序参量 $r_i$**\n\n对于每个振荡器 $i \\in \\{0, 1, \\dots, N-1\\}$，局部序参量 $r_i$ 是根据其邻居的相位计算的。邻域由半宽 $L$ 定义，包括以 $i$ 为中心的 $2L+1$ 个振荡器。由于是环形拓扑，索引采用模 $N$ 运算。公式为：\n$$\nr_i = \\left| \\frac{1}{2L+1} \\sum_{j=-L}^{L} e^{\\mathrm{i}\\,\\theta_{(i+j) \\bmod N}} \\right|\n$$\n每一项 $e^{\\mathrm{i}\\,\\theta_k}$ 是复平面中的一个相量（单位幅度的复数），代表振荡器 $k$ 的状态。模内的表达式是节点 $i$ 邻域内相量的复数均值。这个均值向量的幅度 $r_i$ 量化了这些相量的对齐程度。如果它们完全对齐（所有相位相等），均值向量的长度为 $1$。如果它们均匀分布，均值向量的长度接近 $0$。对所有 $N$ 个振荡器执行此计算，得到局部相干性值的列表 $[r_0, r_1, \\dots, r_{N-1}]$。根据问题规范，每个 $r_i$ 在报告时需四舍五入到小数点后4位。\n\n**步骤2：节点分类与空间非相干性 $SI$ 的计算**\n\n使用计算出的 $r_i$ 值，将每个振荡器分类为相干或非相干。阈值 $r_{\\mathrm{thr}}$ 用于此二元分类。如果振荡器 $i$ 的局部相干性 $r_i$ 小于 $r_{\\mathrm{thr}}$，则它被认为是非相干的。我们定义一个二元指示变量 $b_i$：\n$$\nb_i = \\begin{cases} 1  \\text{如果 } r_i  r_{\\mathrm{thr}} \\\\ 0  \\text{如果 } r_i \\ge r_{\\mathrm{thr}} \\end{cases}\n$$\n空间非相干性 $SI$ 是被分类为非相干的振荡器占总数的比例。它是二元指示符的均值：\n$$\nSI = \\frac{1}{N} \\sum_{i=0}^{N-1} b_i\n$$\n$SI$ 的值范围从 $0$（所有振荡器都相干）到 $1$（所有振荡器都非相干）。此值在输出时也需四舍五入到小数点后4位。\n\n**步骤3：计算奇美拉指数 $X$**\n\n奇美拉指数 $X$ 通过计算不同、连续的非相干簇的数量来量化相干域和非相干域的空间组织。在环上，这等同于计算相干区域和非相干区域之间的界面数量。定义如下：\n$$\nX = \n\\begin{cases}\n0,  \\text{如果 } SI = 0 \\text{ (无非相干节点)} \\\\\n1,  \\text{如果 } SI = 1 \\text{ (所有节点都非相干)} \\\\\n\\sum_{i=0}^{N-1} \\left[ b_i = 1 \\wedge b_{(i-1) \\bmod N} = 0 \\right],  \\text{其他情况}\n\\end{cases}\n$$\n一般情况计算的是当在环形上观察时，二元序列 $b$ 中“上升沿”的数量，这恰好对应于非相干簇的数量。$SI=0$ 和 $SI=1$ 的特殊情况分别处理完全相干和完全非相干的均匀状态。一个完全非相干的状态被认为拥有单个簇。\n\n**步骤4：奇美拉态判定**\n\n一个状态是否被分类为奇美拉，取决于一个由两部分组成的逻辑条件。该条件确保状态表现出非平凡的相干与非相干混合（$SI_{\\min}  SI  SI_{\\max}$），并且这些域被组织成足够数量的簇（$X \\ge X_{\\min}$）。布尔变量 `chimera_bool` 由以下公式确定：\n$$\n\\text{chimera\\_bool} = (SI_{\\min}  SI  SI_{\\max}) \\wedge (X \\ge X_{\\min})\n$$\n为了避免四舍五入带来的误差，此比较使用未经四舍五入的 $SI$ 值。\n\n将此四步流程应用于提供的五个测试用例中的每一个。最终输出是每个用例结果的集合，并按指定格式进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef stringify(v):\n    \"\"\"\n    Custom function to convert a Python object to a string representation\n    without spaces, as suggested by the problem's output format examples.\n    \"\"\"\n    if isinstance(v, list):\n        return '[' + ','.join(stringify(x) for x in v) + ']'\n    if isinstance(v, bool):\n        return 'True' if v else 'False'\n    if isinstance(v, np.bool_):\n        return 'True' if v else 'False'\n    return str(v)\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": {\"N\": 12, \"L\": 2, \"r_thr\": 0.95, \"SI_min\": 0.05, \"SI_max\": 0.95, \"X_min\": 1},\n            \"phases_func\": lambda N: np.zeros(N)\n        },\n        {\n            \"params\": {\"N\": 12, \"L\": 2, \"r_thr\": 0.8, \"SI_min\": 0.05, \"SI_max\": 0.95, \"X_min\": 1},\n            \"phases_func\": lambda N: 2 * np.pi * np.arange(N) / N\n        },\n        {\n            \"params\": {\"N\": 20, \"L\": 2, \"r_thr\": 0.85, \"SI_min\": 0.2, \"SI_max\": 0.8, \"X_min\": 1},\n            \"phases_func\": lambda N: np.concatenate([\n                np.zeros(10),\n                2 * np.pi * np.arange(10) / 10\n            ])\n        },\n        {\n            \"params\": {\"N\": 24, \"L\": 2, \"r_thr\": 0.85, \"SI_min\": 0.3, \"SI_max\": 0.9, \"X_min\": 2},\n            \"phases_func\": lambda N: (\n                lambda p: (\n                    p.__setitem__(slice(6, 12), 2 * np.pi * np.arange(6) / 6),\n                    p.__setitem__(slice(18, 24), 2 * np.pi * np.arange(6) / 6),\n                    p\n                )[-1]\n            )(np.zeros(N))\n        },\n        {\n            \"params\": {\"N\": 16, \"L\": 1, \"r_thr\": 0.7, \"SI_min\": 0.1, \"SI_max\": 0.9, \"X_min\": 2},\n            \"phases_func\": lambda N: (\n                lambda p: (\n                    p.__setitem__(slice(4, 8), 2 * np.pi * np.arange(4) / 4),\n                    p.__setitem__(slice(12, 16), 2 * np.pi * np.arange(4) / 4),\n                    p\n                )[-1]\n            )(np.zeros(N))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        N, L = params[\"N\"], params[\"L\"]\n        r_thr, SI_min, SI_max, X_min = params[\"r_thr\"], params[\"SI_min\"], params[\"SI_max\"], params[\"X_min\"]\n        \n        phases = case[\"phases_func\"](N)\n        \n        # Step 1: Compute local order parameters r_i\n        r_vals_unrounded = []\n        neighborhood_size = 2 * L + 1\n        for i in range(N):\n            indices = (i + np.arange(-L, L + 1)) % N\n            neighborhood_phases = phases[indices]\n            \n            # Sum of phasors e^(i*theta)\n            phasor_sum = np.sum(np.exp(1j * neighborhood_phases))\n            \n            # Magnitude of the mean phasor\n            r_i = np.abs(phasor_sum / neighborhood_size)\n            r_vals_unrounded.append(r_i)\n        \n        r_vals_rounded = [round(r, 4) for r in r_vals_unrounded]\n\n        # Step 2: Compute spatial incoherence SI\n        b = np.array([1 if r  r_thr else 0 for r in r_vals_unrounded])\n        si_unrounded = np.mean(b)\n        si_rounded = round(si_unrounded, 4)\n\n        # Step 3: Compute chimera index X\n        if si_unrounded == 0:\n            X = 0\n        elif si_unrounded == 1:\n            X = 1\n        else:\n            # Count rising edges (0 -> 1) on the ring\n            b_shifted = np.roll(b, 1)\n            X = np.sum((b == 1)  (b_shifted == 0))\n\n        # Step 4: Chimera qualification\n        chimera_bool = (SI_min  si_unrounded  SI_max) and (X >= X_min)\n\n        # Assemble result for the case\n        result = [r_vals_rounded, si_rounded, int(X), chimera_bool]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The custom stringify function ensures a compact representation.\n    print(stringify(results))\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何诊断嵌合态之后，最终的实践环节是亲手生成它。本练习 () 提供了一个完整的数值模拟指南，你将从零开始构建一个双种群振子网络模型。通过编写代码并调整耦合参数，你将能够亲眼见证并验证，简单的动力学方程是如何在特定条件下自发涌现出有序与无序共存的迷人嵌合态的。",
            "id": "4117497",
            "problem": "您的任务是构建并分析一个双种群相位振子网络，以确定出现嵌合态的条件。从 Kuramoto–Sakaguchi 模型入手，在该模型中，每个振子都由其相位表征，并通过带有相位延迟的正弦耦合与自身种群和另一个种群中的所有其他振子相互作用。考虑由 $\\sigma \\in \\{1,2\\}$ 索引的两个种群，每个种群包含 $N$ 个振子，其相位为 $\\theta_{\\sigma,i}(t)$，其中 $i \\in \\{1,\\dots,N\\}$。动力学方程为\n$$\n\\frac{d\\theta_{1,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{11}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{1,i} - \\alpha\\big) \\;+\\; \\frac{K_{12}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{1,i} - \\alpha\\big),\n$$\n$$\n\\frac{d\\theta_{2,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{22}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{2,i} - \\alpha\\big) \\;+\\; \\frac{K_{21}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{2,i} - \\alpha\\big),\n$$\n其中 $\\omega$ 是共同的自然频率，$K_{11}$ 和 $K_{22}$ 是种群内耦合强度，$K_{12}$ 和 $K_{21}$ 是种群间耦合强度，$\\alpha$ 是相位延迟。每个种群的复序参数定义为\n$$\nZ_{\\sigma}(t) \\;=\\; \\frac{1}{N}\\sum_{j=1}^{N} e^{\\,i\\theta_{\\sigma,j}(t)} \\;=\\; r_{\\sigma}(t)e^{\\,i\\psi_{\\sigma}(t)},\n$$\n其中 $r_{\\sigma}(t) \\in [0,1]$ 是振幅，$\\psi_{\\sigma}(t)$ 是种群 $\\sigma$ 的平均相位。在时间 $t$，种群 $\\sigma$ 中振子 $i$ 的瞬时频率定义为\n$$\n\\Omega_{\\sigma,i}(t) \\;=\\; \\frac{d\\theta_{\\sigma,i}}{dt}(t).\n$$\n\n您的程序必须：\n- 以弧度为角度单位实现动力学，并从一组明确指定的初始条件演化系统。\n- 每个种群使用固定数量的振子 $N = 64$，统一的自然频率 $\\omega = 0$，固定的总模拟时间 $T = 80$（无量纲时间单位），以及固定的时间步长 $\\Delta t = 0.02$。\n- 按如下方式初始化相位：对于种群 1，从均值为 0、标准差为 0.1 的正态分布中独立设置 $\\theta_{1,i}(0)$；对于种群 2，从 $[-\\pi,\\pi]$ 上的均匀分布中独立设置 $\\theta_{2,i}(0)$。为了可复现性，使用固定的伪随机数生成器种子 $12345$。\n- 使用不依赖捷径的数值稳定的显式格式对动力学进行积分；例如，使用经典的四阶 Runge–Kutta 方法，并在每一步之后将角度包裹到 $[-\\pi,\\pi]$ 区间内。\n- 积分到时间 $T$ 后，计算 $r_{1}(T)$、$r_{2}(T)$、$\\{\\Omega_{1,i}(T)\\}_{i=1}^{N}$ 和 $\\{\\Omega_{2,i}(T)\\}_{i=1}^{N}$ 各自的标准差 $\\sigma_{\\Omega_1}$ 和 $\\sigma_{\\Omega_2}$，并根据下述共存准则判断是否存在嵌合态。\n\n嵌合态的共存准则：当且仅当，对于某种群标记方式，一个种群是相干的而另一个种群是不相干的，则声明存在嵌合态。其中，“相干”和“不相干”由以下阈值确定：\n- 相干种群：$r_{\\sigma}(T) \\ge \\rho_{\\text{high}}$ 且 $\\sigma_{\\Omega_\\sigma} \\le \\sigma_{\\text{low}}$，\n- 不相干种群：$r_{\\sigma}(T) \\le \\rho_{\\text{low}}$ 且 $\\sigma_{\\Omega_\\sigma} \\ge \\sigma_{\\text{high}}$，\n固定阈值为 $\\rho_{\\text{high}} = 0.95$，$\\rho_{\\text{low}} = 0.70$，$\\sigma_{\\text{low}} = 0.05$，$\\sigma_{\\text{high}} = 0.15$。请严格按照所述阈值使用。\n\n您的程序必须评估以下参数值测试集 $(K_{11},K_{22},K_{12},K_{21},\\alpha)$：\n- 测试 1：$(1.0, 1.0, 0.2, 0.2, 1.5)$，\n- 测试 2：$(1.0, 1.0, 0.8, 0.8, 1.5)$，\n- 测试 3：$(0.2, 0.2, 0.2, 0.2, 1.5)$，\n- 测试 4：$(1.0, 1.0, 0.5, 0.5, 1.5)$。\n\n对于每个测试用例，计算并返回列表 $[r_1(T), r_2(T), \\sigma_{\\Omega_1}, \\sigma_{\\Omega_2}, \\mathrm{chimera}]$，其中 $r_1(T)$ 和 $r_2(T)$ 是以弧度为单位的浮点数（无量纲），$\\sigma_{\\Omega_1}$ 和 $\\sigma_{\\Omega_2}$ 是浮点数（无量纲），$\\mathrm{chimera}$ 是一个布尔值，指示是否满足共存准则。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例表示为其自己的嵌套列表，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。角度必须以弧度为单位。除了已说明的无量纲时间单位外，不需要其他物理单位。",
            "solution": "问题陈述经评估在科学上是合理的、适定的和完整的。唯一且可验证的解决方案所需的所有要素均已提供。因此，我们可以着手解决。\n\n该问题要求对双种群 Kuramoto-Sakaguchi 相位振子网络进行数值模拟，以确定支持嵌合态的参数区域。嵌合态是相同振子网络中的一种时空模式，其中一部分振子同步，而其余振子则保持在不相干的、去同步的状态。\n\n该系统由以下关于种群 $\\sigma \\in \\{1,2\\}$ 中振子 $i$ 的相位 $\\theta_{\\sigma,i}(t)$ 的耦合常微分方程组 (ODE) 描述：\n$$\n\\frac{d\\theta_{1,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{11}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{1,i} - \\alpha\\big) \\;+\\; \\frac{K_{12}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{1,i} - \\alpha\\big)\n$$\n$$\n\\frac{d\\theta_{2,i}}{dt} \\;=\\; \\omega \\;+\\; \\frac{K_{22}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{2,j} - \\theta_{2,i} - \\alpha\\big) \\;+\\; \\frac{K_{21}}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{1,j} - \\theta_{2,i} - \\alpha\\big)\n$$\n\n对这些方程进行直接数值积分，在积分算法的每个子步骤中，都需要为 $2N$ 个振子中的每一个对所有 $N$ 个振子进行求和，这将导致每步的计算复杂度为 $O(N^2)$。为了创建更高效的模拟，我们可以使用各种群 $\\sigma$ 的复序参数来重构方程：\n$$\nZ_{\\sigma}(t) \\;=\\; r_{\\sigma}(t)e^{i\\psi_{\\sigma}(t)} \\;=\\; \\frac{1}{N}\\sum_{j=1}^{N} e^{i\\theta_{\\sigma,j}(t)}\n$$\n使用恒等式 $\\sin(x) = \\text{Im}[e^{ix}]$，可以重写 ODE 中的求和项。例如，对于第一个方程中的第一项：\n$$\n\\frac{1}{N}\\sum_{j=1}^{N}\\sin(\\theta_{1,j} - \\theta_{1,i} - \\alpha) = \\frac{1}{N}\\sum_{j=1}^{N}\\text{Im}[e^{i(\\theta_{1,j} - \\theta_{1,i} - \\alpha)}] = \\text{Im}[e^{-i(\\theta_{1,i} + \\alpha)} \\frac{1}{N}\\sum_{j=1}^{N}e^{i\\theta_{1,j}}]\n$$\n$$\n= \\text{Im}[e^{-i(\\theta_{1,i} + \\alpha)} r_1(t)e^{i\\psi_1(t)}] = r_1(t)\\sin(\\psi_1(t) - \\theta_{1,i} - \\alpha)\n$$\n将此简化应用于所有求和项，ODE 系统变为：\n$$\n\\frac{d\\theta_{1,i}}{dt} = \\omega + K_{11} r_1 \\sin(\\psi_1 - \\theta_{1,i} - \\alpha) + K_{12} r_2 \\sin(\\psi_2 - \\theta_{1,i} - \\alpha)\n$$\n$$\n\\frac{d\\theta_{2,i}}{dt} = \\omega + K_{22} r_2 \\sin(\\psi_2 - \\theta_{2,i} - \\alpha) + K_{21} r_1 \\sin(\\psi_1 - \\theta_{2,i} - \\alpha)\n$$\n这种形式将每个时间步的计算复杂度降低到 $O(N)$，因为它只需要在为所有 $2N$ 个振子求导数之前计算两个序参数 ($Z_1, Z_2$)。\n\n该系统使用经典的四阶 Runge-Kutta (RK4) 方法，以固定的时间步长 $\\Delta t=0.02$ 从 $t=0$ 到 $t=T=80$ 进行数值积分。系统的状态是一个包含 $2N$ 个相位的向量 $[\\theta_{1,1},\\dots,\\theta_{1,N},\\theta_{2,1},\\dots,\\theta_{2,N}]$。在每个完整的 RK4 步骤之后，相位被包裹到区间 $[-\\pi, \\pi]$ 内，以防止数值溢出并保持一致性。系统参数设置为每个种群 $N=64$ 个振子，共同自然频率 $\\omega=0$。\n\n为了可复现性，初始条件是使用固定种子为 $12345$ 的伪随机数生成器生成的。种群 1 的初始相位从均值为 0、标准差为 0.1 的正态分布中抽取，即 $\\theta_{1,i}(0) \\sim \\mathcal{N}(0, 0.1^2)$。这使第一个种群处于高度相干的状态。种群 2 的初始相位从 $[-\\pi, \\pi]$ 上的均匀分布中抽取，即 $\\theta_{2,i}(0) \\sim \\mathcal{U}[-\\pi, \\pi]$，这对应于完全不相干的状态。\n\n模拟达到最终时间 $T=80$ 后，计算一组度量指标以对最终状态进行分类。这些度量指标是序参数的振幅 $r_1(T)$ 和 $r_2(T)$，以及瞬时频率的标准差 $\\sigma_{\\Omega_1}$ 和 $\\sigma_{\\Omega_2}$。瞬时频率 $\\Omega_{\\sigma,i}(T)$ 是通过在最终时间 $T$ 评估 ODE 的右侧来计算的。\n\n嵌合态是根据严格的共存准则来识别的。如果一个种群 $\\sigma$ 的序参数高且其频率离散度低（$r_{\\sigma}(T) \\ge \\rho_{\\text{high}}=0.95$ 且 $\\sigma_{\\Omega_\\sigma} \\le \\sigma_{\\text{low}}=0.05$），则该种群是“相干的”。如果一个种群的序参数低且其频率离散度高（$r_{\\sigma}(T) \\le \\rho_{\\text{low}}=0.70$ 且 $\\sigma_{\\Omega_\\sigma} \\ge \\sigma_{\\text{high}}=0.15$），则该种群是“不相干的”。当且仅当根据这些确切的阈值，一个种群是相干的而另一个是不相干的，才声明存在嵌合态。\n\n该算法通过迭代测试集中提供的每个参数集来执行。对于每组参数，它都执行所述的初始化、数值积分和最终分析。得到的五个值——$[r_1(T), r_2(T), \\sigma_{\\Omega_1}, \\sigma_{\\Omega_2}, \\text{嵌合态状态}]$——被存储起来。最后，将所有测试用例的收集结果格式化为表示列表的列表的单个字符串并打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-population Kuramoto-Sakaguchi model to find chimera states.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 64          # Number of oscillators per population\n    omega = 0.0     # Natural frequency\n    T = 80.0        # Total simulation time\n    dt = 0.02       # Time step\n\n    # Chimera detection thresholds\n    rho_high = 0.95\n    rho_low = 0.70\n    sigma_low = 0.05\n    sigma_high = 0.15\n\n    # Test cases: (K11, K22, K12, K21, alpha)\n    test_cases = [\n        (1.0, 1.0, 0.2, 0.2, 1.5),\n        (1.0, 1.0, 0.8, 0.8, 1.5),\n        (0.2, 0.2, 0.2, 0.2, 1.5),\n        (1.0, 1.0, 0.5, 0.5, 1.5),\n    ]\n\n    # --- Helper Functions ---\n\n    def wrap_angles(angles):\n        \"\"\"Wrap angles to the interval [-pi, pi].\"\"\"\n        return (angles + np.pi) % (2 * np.pi) - np.pi\n\n    def derivatives(thetas, N, K11, K22, K12, K21, alpha, omega):\n        \"\"\"\n        Calculates the time derivatives of the phases (d(theta)/dt).\n        \n        This function uses the efficient formulation based on order parameters.\n        \"\"\"\n        thetas1 = thetas[:N]\n        thetas2 = thetas[N:]\n\n        # Calculate complex order parameters\n        Z1 = np.mean(np.exp(1j * thetas1))\n        Z2 = np.mean(np.exp(1j * thetas2))\n\n        # Extract magnitudes (r) and mean phases (psi)\n        r1, psi1 = np.abs(Z1), np.angle(Z1)\n        r2, psi2 = np.abs(Z2), np.angle(Z2)\n\n        # Calculate derivatives for each population\n        d_thetas1 = omega + K11 * r1 * np.sin(psi1 - thetas1 - alpha) \\\n                          + K12 * r2 * np.sin(psi2 - thetas1 - alpha)\n        \n        d_thetas2 = omega + K22 * r2 * np.sin(psi2 - thetas2 - alpha) \\\n                          + K21 * r1 * np.sin(psi1 - thetas2 - alpha)\n        \n        return np.concatenate((d_thetas1, d_thetas2))\n\n    # --- Main Simulation Loop ---\n\n    results = []\n    \n    for case in test_cases:\n        K11, K22, K12, K21, alpha = case\n\n        # Initialize phases with a fixed seed for reproducibility\n        rng = np.random.default_rng(12345)\n        thetas1_0 = rng.normal(loc=0.0, scale=0.1, size=N)\n        thetas2_0 = rng.uniform(low=-np.pi, high=np.pi, size=N)\n        thetas = wrap_angles(np.concatenate((thetas1_0, thetas2_0)))\n\n        # RK4 Integration\n        num_steps = int(T / dt)\n        \n        # Define a closure for the derivative function with fixed parameters for the current case\n        f = lambda th: derivatives(th, N, K11, K22, K12, K21, alpha, omega)\n\n        for _ in range(num_steps):\n            # RK4 substeps\n            k1 = dt * f(thetas)\n            k2 = dt * f(wrap_angles(thetas + 0.5 * k1))\n            k3 = dt * f(wrap_angles(thetas + 0.5 * k2))\n            k4 = dt * f(wrap_angles(thetas + k3))\n            \n            # Update step\n            thetas = wrap_angles(thetas + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0)\n\n        # --- Final Analysis ---\n\n        # Separate final phases\n        thetas1_T = thetas[:N]\n        thetas2_T = thetas[N:]\n\n        # Calculate final order parameter magnitudes\n        r1_T = np.abs(np.mean(np.exp(1j * thetas1_T)))\n        r2_T = np.abs(np.mean(np.exp(1j * thetas2_T)))\n\n        # Calculate final instantaneous frequencies and their standard deviations\n        final_omegas = f(thetas) # This is d(theta)/dt at T\n        omegas1_T = final_omegas[:N]\n        omegas2_T = final_omegas[N:]\n        \n        s_om1 = np.std(omegas1_T)\n        s_om2 = np.std(omegas2_T)\n        \n        # Apply chimera criterion\n        pop1_coherent = (r1_T >= rho_high) and (s_om1 = sigma_low)\n        pop1_incoherent = (r1_T = rho_low) and (s_om1 >= sigma_high)\n\n        pop2_coherent = (r2_T >= rho_high) and (s_om2 = sigma_low)\n        pop2_incoherent = (r2_T = rho_low) and (s_om2 >= sigma_high)\n\n        is_chimera = (pop1_coherent and pop2_incoherent) or \\\n                     (pop1_incoherent and pop2_coherent)\n        \n        results.append([r1_T, r2_T, s_om1, s_om2, is_chimera])\n\n    # Final print statement in the exact required format.\n    # The template format print(f\"[{','.join(map(str, results))}]\") is used.\n    # This stringifies each inner list and joins them with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}