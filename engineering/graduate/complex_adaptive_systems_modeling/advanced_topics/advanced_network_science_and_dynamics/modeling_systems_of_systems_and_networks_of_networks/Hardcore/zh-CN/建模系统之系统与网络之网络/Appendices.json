{
    "hands_on_practices": [
        {
            "introduction": "在对复杂系统进行建模时，简化通常是必要的一步。然而，我们必须理解简化所带来的权衡。本练习  提供了一个具体的案例，要求您精确量化一个常见的简化方法——使用加权平均聚合模型来近似多层网络上的扩散过程——所引入的偏差。通过推导其与更精确的“超拉普拉斯”（supra-Laplacian）模型之间的差异，您将深入理解层间耦合强度和各层网络结构如何共同影响模型的准确性。这项实践不仅能磨练您在谱图论方面的分析能力，更重要的是，它将培养您审慎评估模型假设并量化其影响的批判性思维。",
            "id": "4130135",
            "problem": "考虑一个多层网络系统，它由两个建立在同一组 $n$ 个节点上的无向连通网络层组成，其对称组合拉普拉斯算子分别为 $L_1 \\in \\mathbb{R}^{n \\times n}$ 和 $L_2 \\in \\mathbb{R}^{n \\times n}$。一个标量状态在该网络之网络上的扩散是线性的，并由网络热方程控制：对于一个状态向量 $x(t)$，其动力学满足 $\\frac{d x}{d t} = -L x$，其中 $L$ 是所考虑网络架构的相应拉普拉斯算子。假设各层以复用方式耦合，层间耦合强度为 $\\omega > 0$，将每个节点与其在另一层中的副本以权重 $\\omega$ 连接。由此产生的超拉普拉斯算子是分块矩阵\n$$\nL_{\\mathrm{sup}}(\\omega) \\;=\\; \\begin{pmatrix}\nL_1 + \\omega I & -\\omega I \\\\\n-\\omega I & L_2 + \\omega I\n\\end{pmatrix} \\in \\mathbb{R}^{2n \\times 2n}.\n$$\n一种常见的模型降维方法是通过加权求和来聚合各层，形成 $L_{\\mathrm{agg}}(\\alpha) = \\alpha L_1 + (1-\\alpha) L_2$（对于一个固定的权重 $\\alpha \\in [0,1]$），然后使用 $\\lambda_2\\!\\left(L_{\\mathrm{agg}}(\\alpha)\\right)$ 作为扩散速度的代理，其中 $\\lambda_2(\\cdot)$ 表示第二小特征值（代数连通度）。相比之下，具有 $L_{\\mathrm{sup}}(\\omega)$ 的多层网络动力学的真实渐近扩散速率由 $\\lambda_2\\!\\left(L_{\\mathrm{sup}}(\\omega)\\right)$ 给出。\n\n假设以下结构性条件成立：\n- $L_1$ 和 $L_2$ 对易，并可由一个共同的标准正交特征基 $\\{u_k\\}_{k=1}^n$ 同时对角化，其中 $L_1 u_k = a_k u_k$ 且 $L_2 u_k = b_k u_k$，此处 $a_1 = b_1 = 0$，且对于所有 $k \\ge 2$，有 $a_k \\ge a_2$ 和 $b_k \\ge b_2$。\n- 在这些排序假设下，基于聚合的扩散速度代理和真实的多层网络扩散速度都由相同的模态指数 $k=2$ 达到。\n\n仅从对称矩阵 $L$ 的线性扩散定律 $\\frac{d x}{d t} = -L x$ 以及对称矩阵的谱特性出发，推导偏差\n$$\nB(\\omega,\\alpha) \\;=\\; \\lambda_2\\!\\left(L_{\\mathrm{agg}}(\\alpha)\\right) \\;-\\; \\lambda_2\\!\\left(L_{\\mathrm{sup}}(\\omega)\\right)\n$$\n的精确闭式表达式，该表达式是关于 $\\omega$、$\\alpha$、$a_2$ 和 $b_2$ 的函数。您的推导必须阐明，在这种情况下，何时通过加权求和进行的聚合会产生有偏的扩散速度估计，并明确指出层间耦合强度和层的谱是如何进入表达式的。请将您的最终结果表示为 $B(\\omega,\\alpha)$ 的单个闭式解析表达式。无需进行数值计算。",
            "solution": "所提出的问题陈述在形式上是明确定义的，在科学上基于网络科学和线性代数的原理，并且内部一致。它提供了所有必要的定义、约束和假设，以进行严格且唯一的数学推导。这些假设虽然很强（例如，拉普拉斯算子的对易性），但陈述清晰，旨在使问题在解析上易于处理。因此，该问题被认为是有效的，我将着手推导所要求的偏差 $B(\\omega,\\alpha)$ 的表达式。\n\n目标是推导偏差 $B(\\omega,\\alpha) = \\lambda_2(L_{\\mathrm{agg}}(\\alpha)) - \\lambda_2(L_{\\mathrm{sup}}(\\omega))$ 的闭式表达式。这需要确定聚合拉普拉斯算子 $L_{\\mathrm{agg}}(\\alpha)$ 和超拉普拉斯算子 $L_{\\mathrm{sup}}(\\omega)$ 的代数连通度，用 $\\lambda_2(\\cdot)$ 表示。\n\n首先，我们分析聚合拉普拉斯算子 $L_{\\mathrm{agg}}(\\alpha)$。它被定义为各层拉普拉斯算子的加权和：\n$$\nL_{\\mathrm{agg}}(\\alpha) = \\alpha L_1 + (1-\\alpha) L_2\n$$\n其中 $\\alpha \\in [0,1]$。一个关键的给定条件是，$L_1$ 和 $L_2$ 对易，并可由一个共同的标准正交特征基 $\\{u_k\\}_{k=1}^n$ 同时对角化。这意味着对于每个特征向量 $u_k$，我们有 $L_1 u_k = a_k u_k$ 和 $L_2 u_k = b_k u_k$。我们可以将 $L_{\\mathrm{agg}}(\\alpha)$ 应用于该共同基中的任意一个特征向量 $u_k$：\n$$\nL_{\\mathrm{agg}}(\\alpha) u_k = (\\alpha L_1 + (1-\\alpha) L_2) u_k = \\alpha (L_1 u_k) + (1-\\alpha) (L_2 u_k) = \\alpha (a_k u_k) + (1-\\alpha) (b_k u_k)\n$$\n将 $u_k$ 因子提出来，我们发现：\n$$\nL_{\\mathrm{agg}}(\\alpha) u_k = (\\alpha a_k + (1-\\alpha) b_k) u_k\n$$\n这表明 $u_k$ 也是 $L_{\\mathrm{agg}}(\\alpha)$ 的一个特征向量，其对应的特征值为 $\\lambda_k(L_{\\mathrm{agg}}(\\alpha)) = \\alpha a_k + (1-\\alpha) b_k$。问题指明，扩散速度的代理是 $\\lambda_2(L_{\\mathrm{agg}}(\\alpha))$，并且这是在模态指数 $k=2$ 时达到的。因此，我们可以直接写出偏差的第一项：\n$$\n\\lambda_2(L_{\\mathrm{agg}}(\\alpha)) = \\alpha a_2 + (1-\\alpha) b_2\n$$\n\n接下来，我们分析超拉普拉斯算子 $L_{\\mathrm{sup}}(\\omega)$，它是一个 $2n \\times 2n$ 的分块矩阵：\n$$\nL_{\\mathrm{sup}}(\\omega) = \\begin{pmatrix}\nL_1 + \\omega I & -\\omega I \\\\\n-\\omega I & L_2 + \\omega I\n\\end{pmatrix}\n$$\n$L_1$ 和 $L_2$ 的对易性允许我们寻找形如 $v_k = \\begin{pmatrix} c_1 u_k \\\\ c_2 u_k \\end{pmatrix}$ 的 $L_{\\mathrm{sup}}(\\omega)$ 的特征向量，其中 $u_k$ 来自共同的特征基，$c_1, c_2$ 是标量系数。特征值方程为 $L_{\\mathrm{sup}}(\\omega) v_k = \\lambda v_k$。将超拉普拉斯算子应用于此向量形式，得到：\n$$\nL_{\\mathrm{sup}}(\\omega) \\begin{pmatrix} c_1 u_k \\\\ c_2 u_k \\end{pmatrix} = \\begin{pmatrix} (L_1 + \\omega I)c_1 u_k - \\omega I c_2 u_k \\\\ -\\omega I c_1 u_k + (L_2 + \\omega I)c_2 u_k \\end{pmatrix} = \\begin{pmatrix} c_1(L_1 u_k) + c_1 \\omega u_k - c_2 \\omega u_k \\\\ -c_1 \\omega u_k + c_2(L_2 u_k) + c_2 \\omega u_k \\end{pmatrix}\n$$\n代入 $L_1 u_k = a_k u_k$ 和 $L_2 u_k = b_k u_k$：\n$$\nL_{\\mathrm{sup}}(\\omega) v_k = \\begin{pmatrix} (c_1 a_k + c_1 \\omega - c_2 \\omega) u_k \\\\ (-c_1 \\omega + c_2 b_k + c_2 \\omega) u_k \\end{pmatrix} = \\begin{pmatrix} (a_k + \\omega)c_1 - \\omega c_2 \\\\ -\\omega c_1 + (b_k + \\omega)c_2 \\end{pmatrix} \\otimes u_k\n$$\n其中 $\\otimes$ 表示克罗内克积。为了使 $v_k$ 成为特征值为 $\\lambda$ 的特征向量，我们必须有 $L_{\\mathrm{sup}}(\\omega) v_k = \\lambda v_k = \\lambda \\begin{pmatrix} c_1 u_k \\\\ c_2 u_k \\end{pmatrix}$。这将 $2n \\times 2n$ 的特征值问题简化为 $n$ 个独立的 $2 \\times 2$ 特征值问题，每个模态 $k$ 对应一个：\n$$\n\\begin{pmatrix}\na_k + \\omega & -\\omega \\\\\n-\\omega & b_k + \\omega\n\\end{pmatrix}\n\\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = \\lambda \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix}\n$$\n每个模态 $k$ 的特征值 $\\lambda$ 通过求解该 $2 \\times 2$ 矩阵的特征方程得到：\n$$\n\\det \\begin{pmatrix}\na_k + \\omega - \\lambda & -\\omega \\\\\n-\\omega & b_k + \\omega - \\lambda\n\\end{pmatrix} = 0\n$$\n$$\n(a_k + \\omega - \\lambda)(b_k + \\omega - \\lambda) - \\omega^2 = 0\n$$\n$$\n\\lambda^2 - (a_k + b_k + 2\\omega)\\lambda + (a_k+\\omega)(b_k+\\omega) - \\omega^2 = 0\n$$\n$$\n\\lambda^2 - (a_k + b_k + 2\\omega)\\lambda + (a_k b_k + a_k \\omega + b_k \\omega) = 0\n$$\n这是一个关于 $\\lambda$ 的二次方程。使用二次公式，与模态 $k$ 相关联的两个特征值（表示为 $\\lambda_{k, \\pm}$）是：\n$$\n\\lambda_{k, \\pm} = \\frac{(a_k + b_k + 2\\omega) \\pm \\sqrt{(a_k + b_k + 2\\omega)^2 - 4(a_k b_k + a_k \\omega + b_k \\omega)}}{2}\n$$\n化简判别式：\n$$\n\\Delta = (a_k^2 + b_k^2 + 4\\omega^2 + 2a_k b_k + 4a_k \\omega + 4b_k \\omega) - 4a_k b_k - 4a_k \\omega - 4b_k \\omega = a_k^2 - 2a_k b_k + b_k^2 + 4\\omega^2 = (a_k - b_k)^2 + 4\\omega^2\n$$\n所以每个模态 $k$ 的一对特征值是：\n$$\n\\lambda_{k, \\pm} = \\frac{a_k + b_k + 2\\omega \\pm \\sqrt{(a_k - b_k)^2 + 4\\omega^2}}{2}\n$$\n对于 $k=1$，我们有 $a_1=b_1=0$，这得到 $\\lambda_{1,\\pm} = \\frac{2\\omega \\pm \\sqrt{4\\omega^2}}{2} = \\omega \\pm \\omega$。这给出了 $\\lambda_{1,-}=0$（任何拉普拉斯算子的平凡特征值）和 $\\lambda_{1,+}=2\\omega$。\n多层网络的真实扩散速率是其代数连通度 $\\lambda_2(L_{\\mathrm{sup}}(\\omega))$。问题陈述该值“由模态指数 $k=2$ 达到”。这是一个关键的简化假设，它意味着整个超拉普拉斯算子的第二小特征值是 $\\{\\lambda_{2,+}, \\lambda_{2,-}\\}$ 对中的一个。由于 $\\sqrt{(a_2-b_2)^2+4\\omega^2} > 0$（因为 $\\omega>0$），很明显 $\\lambda_{2,-} < \\lambda_{2,+}$。该假设意味着 $\\lambda_2(L_{\\mathrm{sup}}(\\omega)) = \\lambda_{2,-}$。因此我们有：\n$$\n\\lambda_2(L_{\\mathrm{sup}}(\\omega)) = \\frac{a_2 + b_2 + 2\\omega - \\sqrt{(a_2-b_2)^2 + 4\\omega^2}}{2}\n$$\n\n最后，我们通过减去两个推导出的量来构建偏差 $B(\\omega,\\alpha)$：\n$$\nB(\\omega,\\alpha) = \\lambda_2(L_{\\mathrm{agg}}(\\alpha)) - \\lambda_2(L_{\\mathrm{sup}}(\\omega)) = \\left(\\alpha a_2 + (1-\\alpha) b_2\\right) - \\left(\\frac{a_2 + b_2 + 2\\omega - \\sqrt{(a_2-b_2)^2 + 4\\omega^2}}{2}\\right)\n$$\n为了得到一个单一的闭式表达式，我们将各项合并到一个公分母 $2$ 上：\n$$\nB(\\omega,\\alpha) = \\frac{2\\alpha a_2 + 2(1-\\alpha) b_2 - (a_2 + b_2 + 2\\omega - \\sqrt{(a_2-b_2)^2 + 4\\omega^2})}{2}\n$$\n$$\nB(\\omega,\\alpha) = \\frac{2\\alpha a_2 + 2b_2 - 2\\alpha b_2 - a_2 - b_2 - 2\\omega + \\sqrt{(a_2-b_2)^2 + 4\\omega^2}}{2}\n$$\n$$\nB(\\omega,\\alpha) = \\frac{(2\\alpha - 1)a_2 + (1 - 2\\alpha)b_2 - 2\\omega + \\sqrt{(a_2-b_2)^2 + 4\\omega^2}}{2}\n$$\n提出因子 $(2\\alpha - 1)$：\n$$\nB(\\omega,\\alpha) = \\frac{(2\\alpha - 1)(a_2 - b_2) - 2\\omega + \\sqrt{(a_2-b_2)^2 + 4\\omega^2}}{2}\n$$\n该表达式揭示了聚合通常会产生对真实扩散速度的有偏估计。偏差取决于层谱的不匹配程度（$a_2 - b_2$）、层间耦合强度 $\\omega$ 以及聚合权重 $\\alpha$。仅在特定条件下，聚合才是无偏的（$B(\\omega,\\alpha)=0$）。例如，如果各层具有相同的代数连通度（$a_2=b_2$），则表达式简化为 $B(\\omega,\\alpha) = \\frac{-2\\omega + \\sqrt{4\\omega^2}}{2} = \\frac{-2\\omega + 2\\omega}{2} = 0$，这意味着在这种特殊情况下，无论 $\\alpha$ 或 $\\omega$ 取何值，聚合都是一个无偏的代理。通常情况下，偏差不为零。",
            "answer": "$$ \\boxed{ \\frac{(2\\alpha - 1)(a_2 - b_2) - 2\\omega + \\sqrt{(a_2-b_2)^2 + 4\\omega^2}}{2} } $$"
        },
        {
            "introduction": "从静态分析转向动态仿真，我们将探索相依系统（systems-of-systems）的一个标志性特征：级联失效。从电网到金融市场，相依网络中的一个小故障可能引发灾难性的系统性崩溃。本练习  要求您从零开始构建一个仿真程序，以模拟这种动态过程。您将通过编程实现一个迭代失效模型，并亲手验证初始冲击如何导致系统发生突变式崩溃，以及如何通过“加固”少量关键节点来有效提升整个系统的韧性。这项实践是计算建模的核心训练，它让您对“突变”和“临界点”等涌现现象获得直观的体感，并学会如何评估干预策略的有效性。",
            "id": "4130113",
            "problem": "考虑一个由$2$个相互依赖的网络层组成的系统，表示为层$\\mathcal{A}$和层$\\mathcal{B}$，每层都有$N$个节点。层$\\mathcal{A}$中的每个节点都依赖于其在层$\\mathcal{B}$中的对应节点，反之亦然，形成一一对应的相互依赖关系。每层中比例为$\\rho$的节点被指定为增强（自主）节点，它们不需要其相互依赖的对应节点正常工作；所有其余节点都是非增强的，并且需要其相互依赖的对应节点具备结构功能性。最初，每层中的每个节点以概率$1-p$被独立移除，其中$p \\in [0,1]$是保留比例。\n\n层中的结构功能性按以下规则定义：在当前活动节点中，一个节点是结构功能性的，当且仅当它属于最大连通分量（LCC），或属于任何包含至少一个活动的增强节点的连通分量。相互依赖功能性定义如下：层$\\mathcal{A}$中的一个节点是功能性活动的，当且仅当它在层$\\mathcal{A}$中是结构功能性的，并且它要么在层$\\mathcal{A}$中是增强的，要么其在层$\\mathcal{B}$中的对应节点是结构功能性的。相同的规则对称地适用于层$\\mathcal{B}$。级联过程迭代进行：给定两层中的活动节点集，重新计算结构功能性集合，并应用相互依赖规则，直到达到一个不动点。令$S(p)$表示最终的序参量，定义为$S(p) = \\min\\{ f_{\\mathcal{A}}(p), f_{\\mathcal{B}}(p) \\}$，其中$f_{\\mathcal{A}}(p)$和$f_{\\mathcal{B}}(p)$是级联收敛后层$\\mathcal{A}$和层$\\mathcal{B}$中功能性活动节点的最终比例。\n\n如果在网格中的连续$p$值之间存在一个下降$\\Delta S = S(p_{i}) - S(p_{i+1})$超过阈值$\\tau$，则该崩溃被视为突变。消除突变崩溃所需的最小增强节点比例是最小的$\\rho$，使得对于整个$p$网格，没有这样的下降超过$\\tau$。\n\n从以下基本依据出发：\n- 通过配置模型进行随机图建模：对于目标度分布$P(k)$和度序列$\\{k_i\\}_{i=1}^N$，通过匹配“末端”（stubs）来形成边，尽可能避免自环和多重边，从而得到一个近似$P(k)$的无向简单图。\n- 渗流和连通分量：对于一个活动节点集，根据上述定义，结构功能性由其是否属于最大连通分量（LCC）或包含至少一个增强节点的连通分量来决定。\n- 迭代的相互依赖级联：通过重复应用结构功能性和依赖约束，直到不再发生变化，从而达到相互依赖更新规则的不动点。\n\n你的任务是实现一个程序，该程序为每个测试用例估算最小增强比例$\\rho^{\\star}$，使得系统在指定的$p$值网格上根据阈值$\\tau$不表现出突变崩溃。关于度异质性的敏感性分析通过改变每层的度分布来进行。为保证可复现性，请使用固定的随机种子。\n\n所需的建模细节和数值规范：\n- 每层节点数为$N = 2000$。\n- 相互依赖映射在两层相应的节点索引之间是一一对应的。\n- 对于每个测试用例，增强节点在每层中均匀随机选择，两层中的比例$\\rho$相同。\n- 初始随机移除以保留概率$p$独立地应用于两层。\n- $p$网格从$p=1.0$到$p=0.0$（含两端）均匀分布有$31$个点。\n- 突变崩溃阈值为$\\tau = 0.12$。\n- 最小增强比例$\\rho^{\\star}$必须通过在均匀网格$\\{0.00, 0.05, 0.10, \\dots, 0.50\\}$上扫描$\\rho$来确定，并选择在整个$p$网格上消除了任何突变下降的最小$\\rho$。如果此网格中没有$\\rho$能消除突变性，则报告扫描的最大值。\n\n度异质性测试套件：\n- 测试用例1（理想情况）：两层均为泊松度分布，平均度为$\\langle k \\rangle = 3.0$。\n- 测试用例2（高异质性）：两层均为截断离散幂律度分布，指数$\\gamma = 2.3$，最小度$k_{\\min} = 1$，最大度$k_{\\max} = 50$。\n- 测试用例3（接近连通性阈值的边界条件）：两层均为泊松度分布，平均度为$\\langle k \\rangle = 2.0$。\n\n对于所有测试用例，使用相同的目标度分布独立生成两个网络层，但实现是独立的。使用固定的随机种子以确保确定性输出。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其中每个元素是相应测试用例的估计最小增强比例$\\rho^{\\star}$，按测试用例1、测试用例2和测试用例3的顺序排列，每个都格式化为小数点后三位的小数（例如，$[0.150,0.100,0.250]$）。此问题不涉及物理单位；也不涉及角度和百分比。最终输出必须严格遵循此格式并且为单行。",
            "solution": "用户提供的问题经评估有效。这是一个在复杂自适应系统建模领域中关于相互依赖网络渗流问题的、适定的、有科学依据的问题。问题陈述是自洽的，为计算解决方案提供了所有必要的参数、定义和约束。它没有模糊性、主观论断或科学谬误。\n\n该解决方案涉及对两个相互依赖网络系统上所描述的级联失效过程进行直接模拟。目标是确定为防止不同网络拓扑下的系统突变崩溃所需的最小增强节点比例$\\rho^{\\star}$。突变崩溃被定义为，在初始节点保留概率$p$的网格上的连续点之间，系统序参量$S(p)$的下降值大于阈值$\\tau = 0.12$。\n\n该方法的核心分为三个主要部分：网络生成、级联模拟和$\\rho^{\\star}$的参数搜索。\n\n### 1. 网络生成\n\n问题指定了两个相互依赖的网络层$\\mathcal{A}$和$\\mathcal{B}$，每层有$N=2000$个节点。每层的拓扑结构是使用基于目标度分布$P(k)$的配置模型独立生成的。\n\n**度序列生成：**\n对于每个测试用例，从指定的分布中为每层抽取一个度序列$\\{k_i\\}_{i=1}^N$。\n- **泊松分布：** 对于平均度$\\langle k \\rangle$，一个节点度为$k$的概率由概率质量函数给出：\n$$ P(k) = \\frac{e^{-\\langle k \\rangle} \\langle k \\rangle^k}{k!} $$\n- **截断幂律分布：** 对于指数$\\gamma$和度范围$[k_{\\min}, k_{\\max}]$，离散概率质量函数为：\n$$ P(k) = C k^{-\\gamma}, \\quad k \\in \\{k_{\\min}, k_{\\min}+1, \\dots, k_{\\max}\\} $$\n其中 $C = \\left(\\sum_{j=k_{\\min}}^{k_{\\max}} j^{-\\gamma}\\right)^{-1}$ 是归一化常数。\n\n为使配置模型适用，度数之和$\\sum_{i=1}^N k_i$必须为偶数。如果生成了奇数和，则应用一个微小修正（例如，将随机选择的一个节点的度增加1）以满足此约束。\n\n**配置模型：**\n从度序列$\\{k_i\\}$构造一个无向简单图的方法如下：\n1. 创建一个“末端”（stubs）列表，其中每个节点$i$出现$k_i$次。\n2. 随机排列这个末端列表。\n3. 将排列后的列表中的相邻末端（例如，末端$2j$与$2j+1$）配对以形成边。\n4. 为满足“尽可能避免自环和多重边”的要求，需对生成的边集进行验证。如果形成了自环（连接节点自身的边）或多重边（重复的边），则重复排列和配对过程，直到获得一个有效的简单图。对于大型网络，此过程预计会很快成功。两个网络层$\\mathcal{A}$和$\\mathcal{B}$是根据相同的度分布参数独立生成的实现。\n\n### 2. 级联模拟\n\n对于给定的网络对、固定的增强节点比例$\\rho$和初始保留概率$p$，级联失效模拟如下。\n\n**步骤 0：初始化**\n- 在每层中均匀随机选择比例为$\\rho$的节点作为“增强”节点。令这些集合为$\\mathcal{V}_{\\text{reinf},\\mathcal{A}}$和$\\mathcal{V}_{\\text{reinf},\\mathcal{B}}$。\n- 模拟初始随机失效。每层中的每个节点以$1-p$的概率被移除。这定义了初始的活动节点集$\\mathcal{V}^{(0)}_{\\mathcal{A}}$和$\\mathcal{V}^{(0)}_{\\mathcal{B}}$。\n\n**步骤 1：迭代级联**\n系统状态在离散时间步$t=0, 1, 2, \\dots$中演化，直到达到不动点。在每一步，活动节点集根据两个规则更新：结构功能性和相互依赖性。\n\n**A. 结构功能性：**\n给定活动节点集$\\mathcal{V}^{(t)}_{\\mathcal{A}}$，分析由这些节点诱导的子图。如果一个节点$i \\in \\mathcal{V}^{(t)}_{\\mathcal{A}}$满足以下至少一个条件，则被视为结构功能性的：\n1. 节点$i$属于子图的最大连通分量（LCC）。\n2. 节点$i$属于一个包含至少一个活动增强节点的连通分量。即，如果$C_j$是包含$i$的分量，则$C_j \\cap \\mathcal{V}_{\\text{reinf},\\mathcal{A}} \\cap \\mathcal{V}^{(t)}_{\\mathcal{A}} \\neq \\emptyset$。\n\n该规则为每层定义了结构功能性节点集$\\mathcal{F}^{(t)}_{\\mathcal{A}}$和$\\mathcal{F}^{(t)}_{\\mathcal{B}}$。这通过首先使用广度优先搜索（BFS）或深度优先搜索（DFS）算法找到活动子图的所有连通分量来实现。\n\n**B. 相互依赖功能性：**\n下一次迭代的活动节点集$\\mathcal{V}^{(t+1)}$通过应用相互依赖规则来确定。层$\\mathcal{A}$中的节点$i$保持活动，当且仅当它在其自身层中是结构功能性的，并且其支持条件得到满足。支持条件是节点本身是增强的，或者其在层$\\mathcal{B}$中的对应节点是结构功能性的。形式上：\n$$ \\mathcal{V}^{(t+1)}_{\\mathcal{A}} = \\left\\{ i \\in \\mathcal{F}^{(t)}_{\\mathcal{A}} \\mid (i \\in \\mathcal{V}_{\\text{reinf},\\mathcal{A}}) \\lor (i \\in \\mathcal{F}^{(t)}_{\\mathcal{B}}) \\right\\} $$\n一个对称的规则适用于确定$\\mathcal{V}^{(t+1)}_{\\mathcal{B}}$：\n$$ \\mathcal{V}^{(t+1)}_{\\mathcal{B}} = \\left\\{ i \\in \\mathcal{F}^{(t)}_{\\mathcal{B}} \\mid (i \\in \\mathcal{V}_{\\text{reinf},\\mathcal{B}}) \\lor (i \\in \\mathcal{F}^{(t)}_{\\mathcal{A}}) \\right\\} $$\n\n**C. 收敛：**\n迭代持续进行，直到活动节点集不再变化，即$\\mathcal{V}^{(t+1)}_{\\mathcal{A}} = \\mathcal{V}^{(t)}_{\\mathcal{A}}$且$\\mathcal{V}^{(t+1)}_{\\mathcal{B}} = \\mathcal{V}^{(t)}_{\\mathcal{B}}$。由于在级联过程中节点只会被移除，这个单调过程保证会收敛到一个唯一的不动点。\n\n**步骤 2：序参量计算**\n收敛后，每层中功能性活动节点的最终比例为$f_{\\mathcal{A}}(p) = |\\mathcal{V}_{\\text{final},\\mathcal{A}}| / N$和$f_{\\mathcal{B}}(p) = |\\mathcal{V}_{\\text{final},\\mathcal{B}}| / N$。系统的序参量定义为$S(p) = \\min\\{f_{\\mathcal{A}}(p), f_{\\mathcal{B}}(p)\\}$。\n\n### 3. 最小增强的参数搜索\n\n主要目标是找到减缓突变崩溃的最小增强比例$\\rho^{\\star}$。这通过系统性搜索来实现。\n\n对于三个测试用例中的每一个：\n1. 网络层对$(\\mathcal{A}, \\mathcal{B})$生成一次，并在整个搜索过程中保持固定。\n2. 算法遍历指定的增强比例网格$\\rho \\in \\{0.00, 0.05, \\dots, 0.50\\}$。对于每个$\\rho$：\n    a. 选择并固定增强节点集。\n    b. 对于其网格中从$p=1.0$到$p=0.0$的每个$p$值，计算序参量$S(p)$。\n    c. 分析得到的$S(p)$对$p$的曲线是否存在突变下降。对于网格上每对连续的点$(p_i, S(p_i))$和$(p_{i+1}, S(p_{i+1}))$，计算下降量$\\Delta S = S(p_i) - S(p_{i+1})$。\n    d. 如果任何下降量$\\Delta S$超过阈值$\\tau = 0.12$，则认为当前的$\\rho$不足以防止突变崩溃，算法继续处理下一个更高的$\\rho$值。\n    e. 如果遍历整个$p$网格且没有下降量超过$\\tau$，则该$\\rho$值即为该测试用例的最小增强比例$\\rho^{\\star}$。由于$\\rho$是按递增顺序扫描的，第一个满足条件的值即为最小值。\n3. 如果对所有$\\rho$值（最高到0.50）的搜索完成，但没有一个能防止突变崩溃，则报告$\\rho^{\\star}$为扫描的最大值0.50。\n\n在整个过程开始时使用固定的随机种子，以确保依赖于图生成和增强节点选择的结果是确定性和可复现的。",
            "answer": "```python\nimport numpy as np\n\ndef generate_degree_sequence(dist_type, params, n_nodes, rng):\n    \"\"\"Generates a degree sequence for a given distribution.\"\"\"\n    if dist_type == 'poisson':\n        # Ensure k_i >= 1 to avoid disconnected nodes from the start\n        degrees = rng.poisson(lam=params['lam'] - 1, size=n_nodes) + 1\n    elif dist_type == 'powerlaw':\n        k_min, k_max, gamma = params['k_min'], params['k_max'], params['gamma']\n        k_range = np.arange(k_min, k_max + 1)\n        probs = k_range**(-gamma)\n        probs /= np.sum(probs)\n        degrees = rng.choice(k_range, size=n_nodes, p=probs)\n    else:\n        raise ValueError(\"Unknown distribution type\")\n\n    # Sum of degrees must be even for the Configuration Model\n    if np.sum(degrees) % 2 != 0:\n        degrees[rng.integers(0, n_nodes)] += 1\n        \n    return degrees\n\ndef generate_config_model_graph(degree_sequence, n_nodes, rng):\n    \"\"\"Generates a graph using the Configuration Model, avoiding self-loops and multi-edges.\"\"\"\n    while True:\n        stubs = np.repeat(np.arange(n_nodes), degree_sequence)\n        rng.shuffle(stubs)\n        \n        edges = set()\n        adj = [[] for _ in range(n_nodes)]\n        is_valid = True\n        \n        for i in range(0, len(stubs), 2):\n            u, v = stubs[i], stubs[i+1]\n            if u == v:\n                is_valid = False\n                break\n            \n            # Ensure order for checking multi-edges\n            edge = tuple(sorted((u, v)))\n            if edge in edges:\n                is_valid = False\n                break\n            edges.add(edge)\n\n        if is_valid:\n            for u, v in edges:\n                adj[u].append(v)\n                adj[v].append(u)\n            return adj\n\ndef find_components(adj, active_nodes, n_nodes):\n    \"\"\"Finds connected components in the subgraph of active nodes using BFS.\"\"\"\n    visited = np.zeros(n_nodes, dtype=bool)\n    components = []\n    for i in range(n_nodes):\n        if active_nodes[i] and not visited[i]:\n            component = set()\n            q = [i]\n            visited[i] = True\n            head = 0\n            while head < len(q):\n                u = q[head]\n                head += 1\n                component.add(u)\n                for v in adj[u]:\n                    if active_nodes[v] and not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(component)\n    return components\n\ndef run_cascade(p_retain, rho, adj_A, adj_B, reinforced_A_nodes, reinforced_B_nodes, n_nodes, rng):\n    \"\"\"Simulates the cascading failure for a given p and returns the final order parameter S(p).\"\"\"\n    \n    # Step 0: Initial random removal\n    active_A = rng.random(size=n_nodes) < p_retain\n    active_B = rng.random(size=n_nodes) < p_retain\n\n    while True:\n        # Store current state to check for convergence\n        prev_active_A = active_A.copy()\n        prev_active_B = active_B.copy()\n        \n        # Step 1A: Find structurally functional nodes in Layer A\n        components_A = find_components(adj_A, active_A, n_nodes)\n        structurally_functional_A = np.zeros(n_nodes, dtype=bool)\n        if components_A:\n            lcc_A = max(components_A, key=len)\n            for node in lcc_A:\n                structurally_functional_A[node] = True\n            for comp in components_A:\n                if comp != lcc_A:\n                    for node in comp:\n                        if reinforced_A_nodes[node] and active_A[node]:\n                            for member in comp:\n                                structurally_functional_A[member] = True\n                            break\n\n        # Step 1B: Find structurally functional nodes in Layer B\n        components_B = find_components(adj_B, active_B, n_nodes)\n        structurally_functional_B = np.zeros(n_nodes, dtype=bool)\n        if components_B:\n            lcc_B = max(components_B, key=len)\n            for node in lcc_B:\n                structurally_functional_B[node] = True\n            for comp in components_B:\n                if comp != lcc_B:\n                    for node in comp:\n                        if reinforced_B_nodes[node] and active_B[node]:\n                            for member in comp:\n                                structurally_functional_B[member] = True\n                            break\n\n        # Step 2: Apply interdependency rules\n        next_active_A = structurally_functional_A & (reinforced_A_nodes | structurally_functional_B)\n        next_active_B = structurally_functional_B & (reinforced_B_nodes | structurally_functional_A)\n        \n        active_A = next_active_A\n        active_B = next_active_B\n\n        # Step 3: Check for convergence\n        if np.array_equal(active_A, prev_active_A) and np.array_equal(active_B, prev_active_B):\n            break\n\n    f_A = np.sum(active_A) / n_nodes\n    f_B = np.sum(active_B) / n_nodes\n    s_p = min(f_A, f_B)\n    \n    return s_p\n\n\ndef solve():\n    \"\"\"Main solver function.\"\"\"\n    N = 2000\n    P_GRID = np.linspace(1.0, 0.0, 31)\n    RHO_GRID = np.arange(0.00, 0.51, 0.05)\n    TAU = 0.12\n    SEED = 42\n\n    rng = np.random.default_rng(SEED)\n\n    test_cases = [\n        {'name': 'Poisson k=3', 'dist_type': 'poisson', 'params': {'lam': 3.0}},\n        {'name': 'PowerLaw', 'dist_type': 'powerlaw', 'params': {'gamma': 2.3, 'k_min': 1, 'k_max': 50}},\n        {'name': 'Poisson k=2', 'dist_type': 'poisson', 'params': {'lam': 2.0}},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Generate graphs for this test case\n        deg_A = generate_degree_sequence(case['dist_type'], case['params'], N, rng)\n        deg_B = generate_degree_sequence(case['dist_type'], case['params'], N, rng)\n        adj_A = generate_config_model_graph(deg_A, N, rng)\n        adj_B = generate_config_model_graph(deg_B, N, rng)\n        \n        rho_star = RHO_GRID[-1] # Default to max if no solution found\n        found_rho_star = False\n        \n        for rho in RHO_GRID:\n            if found_rho_star:\n                break\n\n            # Select reinforced nodes\n            n_reinforced = int(rho * N)\n            reinforced_A_indices = rng.choice(N, size=n_reinforced, replace=False)\n            reinforced_B_indices = rng.choice(N, size=n_reinforced, replace=False)\n            \n            reinforced_A_nodes = np.zeros(N, dtype=bool)\n            reinforced_B_nodes = np.zeros(N, dtype=bool)\n            reinforced_A_nodes[reinforced_A_indices] = True\n            reinforced_B_nodes[reinforced_B_indices] = True\n            \n            s_values = []\n            for p in P_GRID:\n                # Use a new RNG state for each cascade to ensure initial removals are independent\n                cascade_rng = np.random.default_rng(rng.integers(2**32))\n                s_p = run_cascade(p, rho, adj_A, adj_B, reinforced_A_nodes, reinforced_B_nodes, N, cascade_rng)\n                s_values.append(s_p)\n            \n            is_abrupt = False\n            for i in range(len(s_values) - 1):\n                # P_GRID is from 1.0 down to 0.0, so S(p_i) - S(p_{i+1}) is correct\n                delta_s = s_values[i] - s_values[i+1]\n                if delta_s > TAU:\n                    is_abrupt = True\n                    break\n            \n            if not is_abrupt:\n                rho_star = rho\n                found_rho_star = True\n        \n        results.append(f\"{rho_star:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在整合来自多层网络或多个数据源的信息来构建一个统一模型时，一个核心挑战是如何保证数据和约束的内在一致性。本练习  将引导您使用一种来自代数拓扑学的强大工具——上同调（cohomology）——来解决这一问题。您将编写一个程序，把网络间网络系统抽象为一个单纯复形，并利用上同调理论来检测数据中的矛盾。这个方法不仅能发现局部的数据冲突，更能揭示那些无法通过局部调整解决的、更深层次的全局性“障碍”（obstruction）。这项实践将抽象的数学概念（如上链、上边缘算子）转化为具体的线性代数计算，让您掌握一种用于验证复杂分层模型一致性的形式化方法，极大地扩展您解决复杂系统建模问题的工具箱。",
            "id": "4130131",
            "problem": "给定一个形式化设定，它将一个“网络之网络”中跨层的数据集成建模为一个配备了线性限制约束的有限单纯复形。目标是构建一个一致性检查算法，该算法通过计算第一上同调群来检测跨层的数据冲突，并将一个非平凡上同调类解释为全局一致性的一个阻碍。\n\n基本基础和定义：\n- 一个有限单纯复形由一组 0-单纯形（节点）、1-单纯形（有向边）和 2-单纯形（有向三角形）指定，每个三角形都由具有选定方向的恰好三个有向边作为边界。\n- 对于像实数域 $\\mathbb{R}$ 这样的域，上链空间为 $C^{0} \\cong \\mathbb{R}^{n_{0}}$，$C^{1} \\cong \\mathbb{R}^{n_{1}}$ 和 $C^{2} \\cong \\mathbb{R}^{n_{2}}$，其中 $n_{0}$ 是节点数，$n_{1}$ 是边数，$n_{2}$ 是三角形数。\n- 上边缘（上链微分）映射 $\\delta^{0}: C^{0} \\to C^{1}$ 和 $\\delta^{1}: C^{1} \\to C^{2}$ 是满足上链复形性质 $\\delta^{1} \\circ \\delta^{0} = 0$ 的线性映射。具体来说，如果一条边 $e=(i \\to j)$ 的方向是从节点 $i$ 指向节点 $j$，那么对于一个 0-上链 $x \\in \\mathbb{R}^{n_{0}}$，其值 $(\\delta^{0} x)(e)$ 为 $x_{j} - x_{i}$。对于一个由三条边组成的有向边界的三角形 $t$，将 $\\delta^{1}$ 应用于一个 1-上链，会计算该三角形有向边界上带符号的边值之和。\n- 第一上同调群为 $H^{1} := Z^{1} / B^{1}$，其中 $Z^{1} = \\ker(\\delta^{1})$ 是 1-上循环空间，$B^{1} = \\operatorname{im}(\\delta^{0})$ 是 1-上边缘空间。对于 $\\mathbb{R}$ 上的有限复形，其维数由 $\\dim H^{1} = \\dim \\ker(\\delta^{1}) - \\operatorname{rank}(\\delta^{0})$ 给出。\n- 边上的数据分配由一个 1-上链 $d \\in \\mathbb{R}^{n_{1}}$ 表示。当且仅当 $\\delta^{1} d = 0$ 时，该分配在每个 2-单纯形上是局部一致的。当且仅当存在一个 0-上链 $x \\in \\mathbb{R}^{n_{0}}$ 使得 $d = \\delta^{0} x$ 时，该分配在整个“网络之网络”中是全局一致的。一个非平凡上同调类 $[d] \\in H^{1}$ 表示存在一个全局一致性的阻碍，这个阻碍无法通过任何 $x$ 的选择来解决，即使 $d$ 是局部一致的（即 $d \\in Z^{1}$ 但 $d \\notin B^{1}$）。\n\n任务：\n- 实现一个程序，在给定一个有限单纯复形的规范和一个边数据上链 $d$ 的情况下，计算：\n  1. 通过 $\\dim \\ker(\\delta^{1}) - \\operatorname{rank}(\\delta^{0})$ 计算整数维数 $\\dim H^{1}$。\n  2. 一个布尔值，指示 $d$ 是否为上循环，即 $\\delta^{1} d = 0$ 是否成立。\n  3. 一个布尔值，指示 $d$ 是否为平凡上同调类（即 $d \\in \\operatorname{im}(\\delta^{0})$ 是否成立），这对应于边数据在层间和层内完全的全局一致性。\n\n表示细节：\n- 节点索引为 $0,1,\\ldots,n_{0}-1$。\n- 有向边是序对 $(i,j)$，表示 $i \\to j$，索引为 $0,1,\\ldots,n_{1}-1$。\n- 有向三角形是带有相关符号的边索引三元组 $(e_{a}, s_{a}), (e_{b}, s_{b}), (e_{c}, s_{c})$，其中 $s_{k} \\in \\{+1,-1\\}$ 编码了所列边的方向是与三角形方向一致（$+1$）还是相反（$-1$）。\n- 1-上链 $d$ 是 $\\mathbb{R}^{n_{1}}$ 中的一个向量，为每条有向边赋予一个实数值，可解释为跨该边的所需差异约束。例如，一个层间边 $i \\to j$ 与 $d_{e}$ 建模了一个约束 $x_{j} - x_{i} = d_{e}$，该约束必须与其他约束相协调。\n\n数值约定：\n- 在检查与零的相等性以进行一致性和秩计算时，使用 $10^{-9}$ 的数值容差。\n- 所有输出都是无单位的实数和布尔值；不适用任何物理单位。\n\n测试套件：\n提供四个覆盖不同方面的测试用例：\n- 用例 A（理想路径，三角形，一致）：$n_{0} = 3$，边 $e_{0}=(0 \\to 1), e_{1}=(1 \\to 2), e_{2}=(2 \\to 0)$，三角形 $t_{0}=[(e_{0},+1),(e_{1},+1),(e_{2},+1)]$，$d = [1,2,-3]$。\n- 用例 B（局部冲突，三角形，不一致）：与用例 A 相同的复形，但 $d = [1,2,-2]$。\n- 用例 C（全局阻碍，循环图，无三角形）：$n_{0} = 4$，边 $e_{0}=(0 \\to 1), e_{1}=(1 \\to 2), e_{2}=(2 \\to 3), e_{3}=(3 \\to 0)$，无三角形，$d = [1,1,1,1]$。\n- 用例 D（分层的网络之网络，跨层三角形带有一个局部不一致）：$n_{0} = 4$，其中两个层被解释为层 A 中的节点 0,1 和层 B 中的节点 2,3，边 $e_{0}=(0 \\to 1)$ 在层 A 内，$e_{1}=(2 \\to 3)$ 在层 B 内，层间边 $e_{2}=(0 \\to 2), e_{3}=(1 \\to 3)$，以及跨层边 $e_{4}=(3 \\to 0)$。三角形 $t_{0}=[(e_{0},+1),(e_{3},+1),(e_{4},+1)]$ 代表有向环 $0 \\to 1 \\to 3 \\to 0$，以及 $t_{1}=[(e_{2},+1),(e_{1},+1),(e_{4},+1)]$ 代表 $0 \\to 2 \\to 3 \\to 0$。设 $d = [1,1,0,2,-3]$，使得 $t_{0}$ 局部一致而 $t_{1}$ 不一致。\n\n每个用例的所需输出：\n- 一个整数 $\\dim H^{1}$。\n- 一个表示 $d$ 的上循环状态的布尔值。\n- 一个表示 $d$ 的平凡类状态的布尔值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个用例生成一个形如 $[\\dim H^{1}, \\text{is\\_cocycle}, \\text{is\\_trivial}]$ 的列表。输出字符串中不得有任何空格。对于以上四个用例，要求的格式为：\n$[[r_{A,1},r_{A,2},r_{A,3}],[r_{B,1},r_{B,2},r_{B,3}],[r_{C,1},r_{C,2},r_{C,3}],[r_{D,1},r_{D,2},r_{D,3}]]$,\n其中每个 $r_{*,*}$ 是由您的程序计算出的整数或布尔值。",
            "solution": "该问题要求实现一个算法，用于检查“网络之网络”模型中的数据一致性。该模型表示为一个有限单纯复形，并使用代数拓扑的工具（特别是第一上同调群 $H^1$）来分析一致性。解决方案涉及将上链空间和上边缘映射的抽象定义转化为对矩阵和向量的具体线性代数运算。\n\n该方法的核心是将上边缘算子 $\\delta^0: C^0 \\to C^1$ 和 $\\delta^1: C^1 \\to C^2$ 表示为矩阵。$k$-上链空间 $C^k$ 是 $\\mathbb{R}$ 上的有限维向量空间，同构于 $\\mathbb{R}^{n_k}$，其中 $n_k$ 是 $k$-单纯形的数量。\n\n设 $n_0$ 为节点（0-单纯形）的数量，$n_1$ 为有向边（1-单纯形）的数量，$n_2$ 为有向三角形（2-单纯形）的数量。\n\n第一个上边缘算子 $\\delta^0: \\mathbb{R}^{n_0} \\to \\mathbb{R}^{n_1}$ 由一个 $n_1 \\times n_0$ 矩阵表示，我们记为 $D_0$。对于一条方向从节点 $i$ 到节点 $j$ 的边 $e_k$（我们索引中的第 $k$ 条边），矩阵 $D_0$ 的第 $k$ 行被构造用于计算节点值的差异。该行将在第 $i$ 列有一个 $-1$ 和在第 $j$ 列有一个 $+1$，所有其他项均为 $0$。如果 $x \\in \\mathbb{R}^{n_0}$ 是一个 0-上链（为每个节点赋一个值），矩阵-向量积 $D_0 x$ 会得到一个 1-上链，其第 $k$ 个分量为 $(\\delta^0 x)(e_k) = x_j - x_i$。\n\n第二个上边缘算子 $\\delta^1: \\mathbb{R}^{n_1} \\to \\mathbb{R}^{n_2}$ 由一个 $n_2 \\times n_1$ 矩阵表示，记为 $D_1$。对于一个三角形 $t_k$（第 $k$ 个三角形），其有向边界由边 $\\{e_{i_1}, e_{i_2}, e_{i_3}\\}$ 和对应的符号 $\\{s_1, s_2, s_3\\}$（其中 $s_j \\in \\{-1, +1\\}$）组成，$D_1$ 的第 $k$ 行编码了这种关系。该行将在第 $i_j$ 列具有值 $s_j$（对于 $j \\in \\{1,2,3\\}$），其他位置为 $0$。如果 $d \\in \\mathbb{R}^{n_1}$ 是一个 1-上链（给定的边数据），矩阵-向量积 $D_1 d$ 计算每个三角形周围带符号的数据总和，即 $(\\delta^1 d)(t_k)$。\n\n有了这些矩阵表示，可以如下计算三个所需的量：\n\n1.  **第一上同调群的维数 $\\dim H^1$**：\n    第一上同调群定义为 $H^1 = Z^1 / B^1$，其中 $Z^1 = \\ker(\\delta^1)$ 是 1-上循环空间，$B^1 = \\operatorname{im}(\\delta^0)$ 是 1-上边缘空间。对于 $\\mathbb{R}$ 上的向量空间，其维数由 $\\dim H^1 = \\dim(Z^1) - \\dim(B^1)$ 给出。用我们的矩阵来表示，$\\dim(Z^1) = \\dim(\\ker(D_1))$，也就是 $D_1$ 的零度。根据秩-零度定理，$\\operatorname{nullity}(D_1) = n_1 - \\operatorname{rank}(D_1)$。上边缘空间的维数是 $\\dim(B^1) = \\dim(\\operatorname{im}(D_0))$，也就是 $D_0$ 的秩。因此，要实现的公式是 $\\dim H^1 = (n_1 - \\operatorname{rank}(D_1)) - \\operatorname{rank}(D_0)$。矩阵的秩通过计算大于指定数值容差（此处为 $10^{-9}$）的奇异值的数量来稳健地计算。这是通过奇异值分解（SVD）实现的。\n\n2.  **边数据 $d$ 的上循环状态**：\n    如果边数据上链 $d \\in \\mathbb{R}^{n_1}$ 位于 $\\delta^1$ 的核中，即 $\\delta^1 d = 0$，则它是一个上循环。这对应于局部一致性，即数据值在每个三角形周围的总和为零。在矩阵形式下，这个条件是 $D_1 d = 0$。我们计算向量 $v = D_1 d$ 并检查其所有分量是否在数值上接近于零，即对所有 $i$ 都有 $|v_i| < 10^{-9}$。\n\n3.  **边数据 $d$ 的平凡类状态**：\n    如果一个上链 $d$ 是一个上边缘，即它位于 $\\delta^0$ 的像中（$d \\in \\operatorname{im}(\\delta^0)$），则它代表一个平凡上同调类。这对应于全局一致性，因为它意味着存在一个 0-上链 $x \\in \\mathbb{R}^{n_0}$（节点上的一个全局势函数），使得 $d = \\delta^0 x$。上链复形的一个基本性质是 $\\delta^1 \\circ \\delta^0 = 0$，这意味着 $\\operatorname{im}(\\delta^0) \\subseteq \\ker(\\delta^1)$（$B^1 \\subseteq Z^1$）。因此，$d$ 成为一个上边缘的必要条件是它必须首先是一个上循环。如果 $d$ 不是一个上循环，它就不可能是一个上边缘，因此不能代表一个平凡类。如果 $d$ 是一个上循环，我们接着检查线性系统 $D_0 x = d$ 是否对 $x$ 有解。根据线性代数，该系统有解当且仅当增广矩阵 $[D_0 | d]$ 的秩等于矩阵 $D_0$ 的秩。我们再次使用基于 SVD 的秩计算来执行此检查。\n\n该算法的流程是：首先根据单纯复形的输入规范构造矩阵 $D_0$ 和 $D_1$。然后，计算这些矩阵的秩以求得 $\\dim H^1$。最后，执行上述的矩阵-向量乘法和秩检验，以确定给定数据上链 $d$ 的上循环状态和平凡类状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    \n    # Numerical tolerance for equality checks.\n    TOL = 1e-9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"n0\": 3,\n            \"edges\": [(0, 1), (1, 2), (2, 0)],\n            \"triangles\": [[(0, 1), (1, 1), (2, 1)]],\n            \"d\": [1, 2, -3],\n        },\n        {\n            \"name\": \"B\",\n            \"n0\": 3,\n            \"edges\": [(0, 1), (1, 2), (2, 0)],\n            \"triangles\": [[(0, 1), (1, 1), (2, 1)]],\n            \"d\": [1, 2, -2],\n        },\n        {\n            \"name\": \"C\",\n            \"n0\": 4,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 0)],\n            \"triangles\": [],\n            \"d\": [1, 1, 1, 1],\n        },\n        {\n            \"name\": \"D\",\n            \"n0\": 4,\n            \"edges\": [(0, 1), (2, 3), (0, 2), (1, 3), (3, 0)],\n            \"triangles\": [[(0, 1), (3, 1), (4, 1)], [(2, 1), (1, 1), (4, 1)]],\n            \"d\": [1, 1, 0, 2, -3],\n        },\n    ]\n\n    def get_rank(matrix, tol):\n        \"\"\"Computes matrix rank using SVD by counting singular values above tolerance.\"\"\"\n        if matrix.size == 0:\n            return 0\n        s = np.linalg.svd(matrix, compute_uv=False)\n        return np.sum(s > tol)\n\n    def compute_cohomology_properties(n0, edges, triangles, d, tol):\n        \"\"\"\n        Computes the required cohomology properties for a given simplicial complex and data cochain.\n        \n        Returns:\n            A list [dim_H1, is_cocycle, is_trivial]\n        \"\"\"\n        n1 = len(edges)\n        n2 = len(triangles)\n        d_vec = np.array(d, dtype=float)\n\n        # 1. Construct the coboundary matrices D0 and D1.\n        D0 = np.zeros((n1, n0))\n        for k, edge in enumerate(edges):\n            i, j = edge\n            D0[k, i] = -1\n            D0[k, j] = 1\n\n        D1 = np.zeros((n2, n1))\n        for k, triangle in enumerate(triangles):\n            for edge_idx, sign in triangle:\n                D1[k, edge_idx] = sign\n\n        # 2. Compute dim H^1 = (n1 - rank(D1)) - rank(D0).\n        rank_D0 = get_rank(D0, tol)\n        rank_D1 = get_rank(D1, tol)\n        nullity_D1 = n1 - rank_D1\n        dim_H1 = nullity_D1 - rank_D0\n\n        # 3. Check if d is a cocycle (d in ker(D1), i.e., D1*d = 0).\n        if n2 == 0:\n            is_cocycle = True\n        else:\n            cocycle_check_vector = D1 @ d_vec\n            is_cocycle = np.all(np.abs(cocycle_check_vector) < tol)\n\n        # 4. Check if d is a trivial class (d in im(D0)).\n        is_trivial = False\n        # A necessary condition for d to be a coboundary is that it must be a cocycle.\n        if is_cocycle:\n            # Check if D0 @ x = d has a solution by comparing ranks.\n            # A solution exists iff rank([D0 | d]) == rank(D0).\n            d_col = d_vec.reshape(-1, 1)\n            augmented_D0 = np.hstack([D0, d_col])\n            rank_augmented = get_rank(augmented_D0, tol)\n            if rank_D0 == rank_augmented:\n                is_trivial = True\n\n        return [int(dim_H1), is_cocycle, is_trivial]\n\n    results = []\n    for case in test_cases:\n        result = compute_cohomology_properties(\n            case[\"n0\"], case[\"edges\"], case[\"triangles\"], case[\"d\"], TOL\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[0,True,True],[0,False,False],...]\n    result_strings = []\n    for r in results:\n        # Booleans need to be capitalized as `True`/`False` as per Python's str()\n        result_strings.append(f\"[{r[0]},{str(r[1])},{str(r[2])}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}