{
    "hands_on_practices": [
        {
            "introduction": "贝特格子（Bethe lattice）作为一种无限无环树状结构，是统计物理中一个至关重要的理论模型，它常被看作是平均场环境的具象化。由于其独特的无环拓扑结构，我们能够将渗流过程精确地映射到一个高尔顿-沃森（Galton-Watson）分支过程上，从而求得解析解。本练习将引导你通过这一经典映射，推导出贝特格子上的键渗流阈值，这是一个展示强大解析技巧的绝佳范例 。",
            "id": "4136648",
            "problem": "考虑一个无环的无限树，称为贝特格子（Bethe lattice），其中每个顶点的度（配位数）均为 $z \\geq 3$。在键渗流中，每条边以概率 $p \\in [0,1]$ 独立地宣告为开放，否则为关闭。包含指定根顶点的开放边连通分量称为其开放簇。在没有环的情况下，开放簇从根部向外的生长可以建模为一个分支过程，其中每个新到达的顶点只能尝试连接到其先前未到达的邻居。\n\n从适用于复杂自适应系统建模的第一性原理出发，使用以下基本依据：\n\n- 贝特格子作为无限、无环、$z$-正则图的定义。\n- 将树上的渗流簇映射到高尔顿-沃森（Galton–Watson）分支过程，其中一个顶点的后代数量等于连接到先前未到达邻居的开放边数量。\n- 通过后代生成函数对高尔顿-沃森过程中灭绝和存活的标准刻画，以及在临界状态下出现非零存活概率的判据。\n\n推导贝特格子上的键渗流阈值 $p_c$ 作为 $z$ 的闭式函数。你的推导必须从上述依据开始，明确指出由贝特格子上的键渗流所诱导的后代分布，使用生成函数构建灭绝概率方程，并推断出非平凡存活概率出现的条件。将最终阈值表示为关于 $z$ 的单一精确解析表达式。无需四舍五入，也无需单位。最终答案必须是单个表达式。",
            "solution": "问题陈述经验证具有科学依据、提法恰当且客观。它描述了复杂系统统计物理学中的一个典型问题，特别是贝特格子上的键渗流，并要求基于第一性原理进行推导。所提供的框架——映射到高尔顿-沃森过程——是解决此问题的标准且严谨的方法。所有定义和条件都是自洽且数学上一致的。\n\n键渗流阈值 $p_c$ 的推导是遵循指定的基本依据进行的。\n\n1.  **将渗流映射到分支过程**\n    贝特格子是一个无限、无环的图，其中每个顶点都有配位数 $z$。我们将一个顶点视为潜在开放簇的根，并将其指定为第 $G_0$ 代。一条边以概率 $p$ 开放，以概率 $1-p$ 关闭。\n    开放簇从根部的生长可以建模为高尔顿-沃森分支过程。在此模型中，簇的顶点是“个体”，连接到新顶点的开放边是“后代”。\n    让我们考虑一个属于开放簇且属于第 $n \\geq 1$ 代的顶点。它是通过一条来自第 $n-1$ 代的唯一“父”顶点的开放边到达的。由于该晶格是一棵树，所以没有环。因此，连接到该顶点的 $z$ 条边中，一条通向其父顶点，另外 $z-1$ 条通向先前未访问过的“前进”邻居。\n    第 $n \\geq 1$ 代中一个顶点的后代数量是连接到其 $z-1$ 个前进邻居的开放边数量。为了使该过程可以建模为一个所有个体都具有相同后代分布的标准高尔顿-沃森过程，我们考虑从第 $G_1$ 代（根的子代）开始的种群动态。任何在第 $n \\geq 1$ 代的个体都有 $z-1$ 个潜在后代。\n\n2.  **后代分布与生成函数**\n    任何给定个体（第 $n \\geq 1$ 代中的顶点）的后代数量 $k$ 服从二项分布。有 $z-1$ 次独立试验（连接到前进邻居的边），每次试验的成功概率为 $p$（边是开放的）。拥有 $k$ 个后代的概率质量函数 $P(k)$ 为：\n    $$P(k) = \\binom{z-1}{k} p^k (1-p)^{z-1-k}, \\quad \\text{for } k \\in \\{0, 1, \\dots, z-1\\}$$\n    后代生成函数 $G(x)$ 由幂级数 $G(x) = \\sum_{k=0}^{\\infty} P(k) x^k$ 定义。代入我们的二项分布：\n    $$G(x) = \\sum_{k=0}^{z-1} \\binom{z-1}{k} p^k (1-p)^{z-1-k} x^k$$\n    这是二项式表达式的展开。根据二项式定理 $(a+b)^n = \\sum_{k=0}^n \\binom{n}{k} a^{n-k} b^k$，我们可以确定 $n = z-1$，$a = 1-p$，$b = px$。生成函数简化为：\n    $$G(x) = ((1-p)+px)^{z-1} = (1-p+px)^{z-1}$$\n\n3.  **无限簇形成（非灭绝）的条件**\n    在分支过程理论中，最终灭绝的概率 $q$ 是生成函数的最小非负不动点，即 $q = G(q)$ 的最小解。\n    只有在存活概率非零的情况下，才能形成无限簇，这意味着灭绝概率 $q$ 必须严格小于 $1$。\n    方程 $x = G(x)$ 在 $x=1$ 处总有一个解，因为 $G(1) = \\sum P(k) = 1$。是否存在另一个解 $q \\in [0, 1)$ 取决于 $G(x)$ 在 $x=1$ 附近的行为。由于 $G(x)$ 在 $[0,1]$ 上是一个凸函数（因为所有 $P(k) \\geq 0$），当且仅当其在 $x=1$ 处的斜率大于 $1$ 时，它才会与直线 $y=x$ 在一个小于 $x=1$ 的点相交。\n    因此，出现非平凡存活概率的条件是 $G'(1) > 1$。量 $G'(1)$ 是单个个体的期望后代数量。\n    渗流阈值 $p_c$ 是 $p$ 的临界值，在该值处系统从所有簇都是有限的区域（亚临界，$G'(1) \\leq 1$）过渡到可能存在无限簇的区域（超临界，$G'(1) > 1$）。在临界状态下，平均后代数量恰好为1：\n    $$G'(1) = 1$$\n\n4.  **渗流阈值 $p_c$ 的推导**\n    我们计算 $G(x)$ 关于 $x$ 的导数：\n    $$G'(x) = \\frac{d}{dx} \\left[ (1-p+px)^{z-1} \\right]$$\n    使用链式法则：\n    $$G'(x) = (z-1) (1-p+px)^{z-2} \\cdot \\frac{d}{dx}(1-p+px) = p(z-1)(1-p+px)^{z-2}$$\n    现在，我们在 $x=1$ 处计算该导数的值：\n    $$G'(1) = p(z-1)(1-p+p(1))^{z-2} = p(z-1)(1)^{z-2} = p(z-1)$$\n    平均后代数量为 $\\mu = p(z-1)$。我们在临界概率 $p=p_c$ 处将其设为 $1$：\n    $$p_c(z-1) = 1$$\n    求解 $p_c$，我们得到贝特格子上的键渗流阈值：\n    $$p_c = \\frac{1}{z-1}$$\n    该表达式给出了作为配位数 $z$ 函数的精确渗流阈值，符合要求。条件 $z \\geq 3$ 确保 $p_c \\in (0, 1/2]$，这具有物理意义。",
            "answer": "$$\\boxed{\\frac{1}{z-1}}$$"
        },
        {
            "introduction": "对于像三维立方晶格这样的多数真实晶格系统，我们往往无法找到精确的解析解。在这种情况下，推导严格的界限就成为次优的最佳选择。本练习将结合两种不同的方法：一方面，你将使用形式化的自回避行走路径计数来确定渗流阈值的严格下界；另一方面，你将运用物理直觉，通过近似簇的生长过程来估算一个启发式的上界。这种结合严谨数学与物理洞察的策略，是统计物理研究中的常用手段 。",
            "id": "4136670",
            "problem": "考虑在三维立方晶格 $\\mathbb{Z}^3$ 上的独立键渗流，其中每条无向边（键）以概率 $p \\in [0,1]$ 开启，否则关闭，各边之间相互独立。设 $p_c$ 表示这样一个 $p$ 值的下确界：对于这些 $p$ 值，存在一个包含原点的无限大开启边连通分量（簇）的概率为正。仅使用基本定义和成熟的概率工具，通过计算从原点出发的自回避行走（SAWs）的数量并应用独立性原理，推导 $p_c$ 的一个严格下界 $p_L$。然后，使用在 $\\mathbb{Z}^3$ 上的等周式向外扩展论证，以及通过高尔顿-沃森（GW）分支过程的启发式近似，推导 $p_c$ 的一个启发式上界 $p_U$，该上界基于可用于簇增长的 $L^1$-向外边。你的界限应从第一性原理出发进行充分论证，清楚地说明哪些步骤是严格的，哪些是启发式的。将你的最终界限表示为无单位的精确分数，并按顺序以数对 $(p_L, p_U)$ 的形式报告。无需四舍五入。",
            "solution": "所述问题具有科学依据、良定、客观且内部一致。这是统计物理和概率论中的一个标准问题，特别是在渗流理论这一主题内。验证清单中指出的缺陷均不存在。因此，有必要提供解答。\n\n该问题要求为三维立方晶格 $\\mathbb{Z}^3$ 上键渗流的临界概率 $p_c$ 推导一个严格下界 $p_L$ 和一个启发式上界 $p_U$。\n\n### 严格下界 $p_L$ 的推导\n\n临界概率 $p_c$ 是一个阈值，低于此值时，连接到原点的开启簇 $C(O)$ 几乎必然是有限的。求 $p_c$ 下界的一个标准方法是，找到一个 $p$ 的范围，在此范围内该簇的期望大小 $E_p[|C(O)|]$ 是有限的。如果 $E_p[|C(O)|]  \\infty$，那么根据波莱尔-坎泰利引理或直接论证，簇的大小必须以概率 1 是有限的，即 $P_p(|C(O)|  \\infty) = 1$。这意味着任何这样的 $p$ 都必须处于亚临界相，因此 $p \\le p_c$。这类 $p$ 值的上确界提供了 $p_c$ 的一个下界。\n\n包含原点的簇的期望大小是每个顶点 $x$ 与原点 $O$ 相连的概率之和：\n$$\nE_p[|C(O)|] = \\sum_{x \\in \\mathbb{Z}^3} P_p(O \\leftrightarrow x)\n$$\n其中 $O \\leftrightarrow x$ 表示 $O$ 和 $x$ 之间至少存在一条开启的边路径的事件。\n\n为了界定这个概率，我们对所有可能的路径使用并集界。问题指定使用自回避行走（SAWs）。设 $\\mathcal{W}(O,x)$ 为从 $O$ 到 $x$ 的所有自回避行走的集合。一个长度为 $n$（由 $n$ 条边组成）的特定自回避行走 $\\gamma \\in \\mathcal{W}(O,x)$ 是开启的，当且仅当其所有 $n$ 条边都是开启的。由于边状态的独立性，这发生的概率为 $p^n$。\n事件 $\\{O \\leftrightarrow x\\}$ 是所有从 $O$ 到 $x$ 的自回避行走 $\\gamma$ 的事件 $\\{\\gamma \\text{ is open}\\}$ 的并集。根据并集界：\n$$\nP_p(O \\leftrightarrow x) \\le \\sum_{\\gamma \\in \\mathcal{W}(O,x)} P_p(\\gamma \\text{ is open})\n$$\n设 $c_n(x)$ 为从原点到顶点 $x$ 的长度为 $n$ 的自回避行走的数量。上述和可以写成：\n$$\nP_p(O \\leftrightarrow x) \\le \\sum_{n=1}^\\infty c_n(x) p^n\n$$\n将此代入期望簇大小的表达式中：\n$$\nE_p[|C(O)|] = \\sum_{x \\in \\mathbb{Z}^3} P_p(O \\leftrightarrow x) \\le \\sum_{x \\in \\mathbb{Z}^3} \\sum_{n=1}^\\infty c_n(x) p^n\n$$\n我们可以交换求和顺序（因为所有项都是非负的）：\n$$\nE_p[|C(O)|] \\le \\sum_{n=1}^\\infty p^n \\sum_{x \\in \\mathbb{Z}^3} c_n(x)\n$$\n内层和 $\\sum_{x \\in \\mathbb{Z}^3} c_n(x)$ 是从原点开始的长度为 $n$ 的自回避行走的总数，我们将其记为 $c_n$。因此，\n$$\nE_p[|C(O)|] \\le \\sum_{n=1}^\\infty c_n p^n\n$$\n为了使这个界有用，我们需要一个 $c_n$ 的上界。对于任何晶格，$c_n$ 的上界是长度为 $n$ 的非回溯行走的数量。三维立方晶格 $\\mathbb{Z}^3$ 的配位数是 $z=6$。从原点开始的长度为 $n$ 的行走，第一步有 $z=6$ 种选择。对于非回溯行走中的每一步后续步骤，行走不能立即反向，因此最多剩下 $z-1=5$ 种选择。由于自回避行走根据定义是非回溯的，其数量受此数量的限制：\n$$\nc_n \\le z(z-1)^{n-1} = 6 \\cdot 5^{n-1}\n$$\n将此代入我们关于期望簇大小的不等式中：\n$$\nE_p[|C(O)|] \\le \\sum_{n=1}^\\infty (6 \\cdot 5^{n-1}) p^n = \\frac{6}{5} \\sum_{n=1}^\\infty (5p)^n\n$$\n右边是一个几何级数，其收敛当且仅当其公比小于 $1$。收敛条件是 $|5p|  1$。由于 $p \\ge 0$，这简化为 $5p  1$，即 $p  \\frac{1}{5}$。\n\n对于任何 $p  \\frac{1}{5}$，级数收敛，因此 $E_p[|C(O)|]$ 是有限的。这意味着 $P_p(|C(O)|=\\infty) = 0$。因此，范围 $[0, 1/5)$ 内的任何 $p$ 都属于亚临界相。由于 $p_c$ 是发生渗流的 $p$ 值的下确界，我们必须有 $p_c \\ge \\frac{1}{5}$。\n这建立了一个严格的下界：\n$$\np_L = \\frac{1}{5}\n$$\n\n### 启发式上界 $p_U$ 的推导\n\n为了找到 $p_c$ 的一个上界，我们需要找到一个 $p$ 值，使得我们可以论证渗流*确实*会发生。所要求的论证是启发式的，并且基于将簇的增长建模为分支过程（高尔顿-沃森过程）。\n\n该启发式方法依赖于考虑“定向渗流”。我们定义一条从原点出发的路径为“向外定向”的，如果从原点出发的 $L^1$-距离（对于顶点 $v=(v_x, v_y, v_z)$ 定义为 $|v|_1 = |v_x|+|v_y|+|v_z|$）沿着路径的每一步都严格增加。如果存在无限长的向外定向开启路径，则存在无限大的簇。无限长定向开启路径的存在是无限大开启簇存在的充分但非必要条件。因此，定向渗流的临界概率 $p_c^{\\text{oriented}}$ 是真实临界概率 $p_c$ 的一个上界：$p_c \\le p_c^{\\text{oriented}}$。\n\n我们可以通过将定向渗流建模为高尔顿-沃森分支过程来近似其发生条件。在这个模型中，每个新到达的顶点是一个“个体”，它产生对应于可通过开启的向外边到达的邻居的“后代”。如果每个个体的期望后代数大于 $1$，则该过程以正概率无限增长（存活）。\n\n让我们确定从一个顶点 $v \\in \\mathbb{Z}^3$ 出发的向外定向边的数量。如果 $|u|_1 = |v|_1 + 1$，则边 $(v, u)$ 是向外的。这类边的数量取决于 $v$ 的位置：\n- 如果 $v$ 是原点 $(0,0,0)$，所有 $z=6$ 个邻居的 $L^1$-距离都是 1。因此，有 6 条向外边。\n- 如果 $v=(x,y,z)$ 且 $x,y,z \\neq 0$，它有 3 个邻居增加 $L^1$ 距离（例如 $(x+\\text{sgn}(x), y, z)$），还有 3 个邻居减少 $L^1$ 距离（例如 $(x-\\text{sgn}(x), y, z)$）。因此，有 3 条向外边。\n- 如果 $v$ 位于某个坐标平面上但不在坐标轴上（例如 $x,y \\neq 0, z=0$），它有 4 条向外边。\n- 如果 $v$ 位于某个坐标轴上但不是原点（例如 $x \\neq 0, y=z=0$），它有 5 条向外边。\n\n对于任何顶点 $v \\neq O$，可用于增长的向外边数量至少为 3。为了找到渗流的充分条件，我们可以保守地考虑增长的“最坏情况”，这种情况发生在远离原点的地方，那里的一个普通位点只有 3 条可用的向外边。\n\n我们启发式地将此过程建模为分支过程，其中每个个体拥有的后代数量服从二项分布 $\\text{Bin}(k, p)$，$k$ 是可用的子代位置数。如果期望后代数 $kp$ 大于 1，则该过程存活。使用我们保守的 $k=3$ 值：\n$$\nE[\\text{后代}] = 3p > 1 \\implies p > \\frac{1}{3}\n$$\n如果 $p > 1/3$，表示定向路径增长的分支过程是超临界的，并以正概率存活。由于无限长定向路径的存在意味着原始渗流问题中存在无限大簇，我们可以启发式地得出结论，对于 $p > 1/3$ 会发生渗流。\n这意味着临界概率 $p_c$ 必须不大于 $1/3$。这给出了启发式上界：\n$$\np_U = \\frac{1}{3}\n$$\n这是一个启发式方法，因为我们忽略了晶格复杂的空间相关性，以及向外边的数量不是恒定的事实，从而将增长过程简化为一个无记忆的分支过程。\n\n推导出的界限是严格下界 $p_L = 1/5$ 和启发式上界 $p_U = 1/3$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{5}  \\frac{1}{3} \\end{pmatrix}}$$"
        },
        {
            "introduction": "当精确解遥不可及，而解析界限又不够精确时，计算方法便成为不可或缺的工具。本练习要求你实现一个精密的算法，以模拟在具有周期性边界条件的有限晶格上的点渗流过程。通过分析一种被称为“环绕概率”（wrapping probability）的量，你将能够获得对临界阈值的高精度估计，同时学习如何处理任何计算机模拟中都固有的有限尺寸效应 。",
            "id": "4136646",
            "problem": "考虑一个线性尺寸为 $L$ 的二维方格晶格上的位点逾渗，该晶格具有周期性边界条件，在拓扑上形成一个离散的环面。每个晶格位点以概率 $p \\in [0,1]$ 被独立占据。团簇由环面上的最近邻连接性定义。逾渗阈值 $p_c$ 是出现宏观团簇时的临界占据概率。在有限系统中，边界效应会使 $p_c$ 的估计量产生偏差；周期性边界条件通过消除边缘和角落来减轻这些效应，并允许使用环绕概率进行估计。\n\n定义环绕概率 $R_L(p)$ 为存在至少一个团簇在环面的水平或垂直方向上具有非零环绕数的概率。如果一个团簇中存在一条闭合路径，在考虑跨越周期性边界的跳跃后，其在水平方向的净位移非零，则称该团簇表现出水平环绕；垂直环绕的定义与此类似。对于给定的实现和固定的晶格尺寸 $L$，首次环绕指数 $m^\\star$ 是指团簇在至少一个方向上获得非零环绕数时所需占据的最小位点数 $m$。\n\n从逾渗团簇、最近邻连接性和周期性边界条件的核心定义出发，实现一个算法来检测环绕。该算法使用一个增强了位移跟踪功能的不相交集联合（并查集）数据结构，以便在环面任一方向上形成具有非零净位移的环时，能够在其发生的确切时刻检测到。使用该算法，通过计算在多次独立实现中 $m^\\star/n$ 的中位数来估计 $p_c$，其中 $n=L^2$ 是晶格位点数。该估计量对应于微正则环绕概率穿过 $1/2$ 的点，在周期性边界条件下，该交叉点给出了一个边界效应减弱的 $p_c$ 估计值。\n\n您的程序必须：\n- 构建一个大小为 $L \\times L$ 的环面晶格。\n- 以随机顺序逐个添加位点，并使用最近邻连接性（考虑周期性边界条件）将其与已占据的邻居进行合并。\n- 对每次合并操作跟踪位移约束，以便当一条边闭合一个环时，可以计算出环的净位移；如果沿水平或垂直方向的净位移非零，则标记该团簇在该方向上环绕。\n- 记录每次实现的首次环绕指数 $m^\\star$（即首次发生环绕的步骤），并计算所有实现中 $m^\\star/n$ 的中位数以估计 $p_c$。\n- 为提供的测试套件生成结果。\n\n使用的基本原理：\n- 方格晶格上的最近邻连接性。\n- 通过已占据位点将团簇定义为连通分量。\n- 通过模 $L$ 的索引算术实现环面拓扑的周期性边界条件。\n- 环绕概率随占据分数增加的单调性。\n- 中位数作为交叉点的解释：多次实现中 $m^\\star/n$ 的中位数等于有限尺寸微正则环绕概率穿过 $1/2$ 时的占据分数。\n\n您的实现必须是纯粹算法性的，并模拟所定义的过程；不得使用外部数据。所有输出都是无量纲的概率，并且必须以小数值表示。\n\n测试套件：\n- 案例 $1$：$L=16$，实现次数 $T=600$，随机种子 $314159$。\n- 案例 $2$：$L=32$，实现次数 $T=400$，随机种子 $271828$。\n- 案例 $3$：$L=64$，实现次数 $T=300$，随机种子 $161803$。\n- 案例 $4$：$L=10$，实现次数 $T=800$，随机种子 $101$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为逗号分隔的列表并用方括号括起，例如“[$r_1,r_2,r_3,r_4$]”。每个 $r_i$ 必须是一个小数值，代表对应案例的估计 $p_c$。",
            "solution": "该算法使用不相交集联合（DSU）或并查集数据结构。这对于跟踪晶格上的连通分量（团簇）非常理想。问题要求的关键创新是增强 DSU 以检测环绕。\n\n标准的 DSU 跟踪父指针和秩/大小以实现高效的合并操作。为了跟踪环绕，我们需要为每个节点存储额外信息。\n\n核心思想是将 $L \\times L$ 环面晶格想象成 $\\mathbb{Z}^2$ 中无限周期晶格的一个基本域。环面上的每个位点 $(x, y)$ 对应于无限晶格上的一组无限位点 $(x+iL, y+jL)$，其中 $i, j$ 为所有整数。如果一个团簇包含两个位点 $(x_1, y_1)$ 和 $(x_2, y_2)$，它们在团簇内部是连通的，并且它们在无限晶格上的像（例如 $(x'_1, y'_1)$ 和 $(x'_2, y'_2)$）满足 $x'_1 - x'_2 = kL$（其中 $k$ 为某个非零整数），那么该团簇就是水平环绕的。\n\n换言之，如果环面上的一个环在遍历时，其在对应无限晶格上的路径不形成闭环，那么这个环就具有非零环绕数。净位移向量 $(dx, dy)$ 将形如 $(k_x L, k_y L)$，其中 $k_x, k_y$ 是不全为零的整数。我们只需要检测是否有 $k_x \\neq 0$ 或 $k_y \\neq 0$。\n\n为了用 DSU 实现这一点：\n- 对于每个位点 `i`，我们存储一个位移向量 `disp[i]`，它表示在无限晶格坐标系中从 `parent[i]` 到 `i` 的位置向量。\n- `find` 操作必须修改。在执行路径压缩时，如果我们将 `parent[i]` 从 `p` 更改为 `root`，我们必须更新 `disp[i]`。新的位移是 `new_disp[i] = disp[i] + disp[p]`。这是因为 `pos(i) - pos(root) = (pos(i) - pos(p)) + (pos(p) - pos(root))`。通过递归应用此规则，我们可以找到从任何节点到其根的总位移。\n- `union(i, j)` 操作是检测环的地方。假设 `i` 和 `j` 是我们要合并的两个位点。首先，我们找到它们的根 `root_i` 和 `root_j`，以及从 `i` 和 `j` 到各自根的位移 `d_i` 和 `d_j`。\n- 如果 `root_i != root_j`，我们合并这两棵树。例如，如果我们将 `root_i` 合并到 `root_j`（设置 `parent[root_i] = root_j`），我们必须定义 `disp[root_i]`。这是向量 `pos(root_i) - pos(root_j)`。我们知道 `pos(i) \\approx pos(j)`（它们是邻居）。设 `delta = pos(j) - pos(i)` 为邻居之间的位移向量（例如 `(1,0)` 或 `(-1,0)`），并考虑周期性边界。那么 `pos(root_i) = pos(i) - d_i` 且 `pos(root_j) = pos(j) - d_j`。所以，`disp[root_i] = pos(root_i) - pos(root_j) = (pos(i) - d_i) - (pos(j) - d_j) = (pos(i) - pos(j)) - d_i + d_j = -delta - d_i + d_j`。\n- 如果 `root_i == root_j`，则形成了一个环。位点 `i` 和 `j` 已经处于同一个连通分量中。树中从 `i` 到 `j` 的路径对应位移 `d_j - d_i`。从 `i` 到 `j` 的直接边对应位移 `delta`。环向量是它们的差：`W = (d_j - d_i) - delta`。这个向量 `W` 给出了新形成的环在无限晶格上的净位移。如果 `W_x` 或 `W_y` 非零，它必定是 `L` 的倍数。这表示发生了环绕。我们可以为每个连通分量存储一个布尔标志 `wrapped[root]`。\n- 此外，在合并两棵树时，如果其中一棵已经环绕，则新合并的树也环绕。因此，在合并之前 `wrapped[new_root] = wrapped[root_i] or wrapped[root_j]`。\n\n主模拟循环：\n- 对于每次实现：\n    - 初始化一个空的 $L \\times L$ 晶格和增强的 DSU 结构。\n    - 创建一个包含 $n=L^2$ 个位点索引的随机排列。\n    - 遍历该排列，一次添加一个位点（从 `m=1` 到 `n`）。\n    - 对于每个新位点，将其标记为已占据。然后，检查其四个邻居。如果邻居已被占据，则执行 `union` 操作。\n    - 每次 `union` 后，检查该连通分量是否已环绕。DSU 将在内部处理此问题。我们只需检查该连通分量根的 `wrapped` 标志。\n    - 如果首次检测到环绕，记录当前已占据的位点数 `m` 为 `m_star`，并中断本次实现的内部循环。\n- 在所有 `T` 次实现之后，我们得到一个 `m_star` 值的列表。\n- 计算每次实现的比例 `m_star / n`。\n- 找到这些比例的中位数。这就是对 `p_c` 的估计值。\n\n代码看起来是正确的。我将继续编写最终输出。\n对问题陈述细节的最终检查：\n- “环绕概率 $R_L(p)$ 为存在至少一个团簇在水平或垂直方向上具有非零环绕数的概率”。我的算法在检测到x-环绕或y-环绕时会正确停止。\n- “团簇获得非零环绕数时所需占据的最小位点数 $m$”。我的算法通过在首次检测时停止来找到这个 `m_star`。\n- “通过计算 $m^\\star/n$ 的中位数来估计 $p_c$”。我的算法计算了这个值。\n- 测试案例和随机种子都已给出。我会使用它们。\n- 这个问题提得非常好，几乎就像是为了精确测试这个算法而设计的。\n- 输出格式 `[r1,r2,r3,r4]` 将使用 f-string 对结果列表生成。\n- 似乎没有遗漏任何细节。计划很可靠，我现在可以编写解决方案了。",
            "answer": "```python\nimport numpy as np\n# No other libraries are permitted by the problem statement.\n\nclass UF_Winding:\n    \"\"\"\n    A Disjoint-Set Union (DSU) data structure augmented to detect winding numbers\n    on a 2D toroidal lattice of size L x L.\n    \"\"\"\n    def __init__(self, L):\n        self.L = L\n        n = L * L\n        self.parent = np.arange(n, dtype=np.intc)\n        self.rank = np.zeros(n, dtype=np.intc)\n        # disp[i] stores the vector displacement pos(i) - pos(parent[i])\n        # in the unrolled infinite lattice.\n        self.disp = np.zeros((n, 2), dtype=np.intc)\n        # wrapped[i] stores [wrapped_x, wrapped_y] for root i.\n        self.wrapped = np.zeros((n, 2), dtype=bool)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing element i, with path compression\n        and displacement vector updates.\n        Returns: (root, displacement_from_i_to_root)\n        \"\"\"\n        if self.parent[i] == i:\n            return i, np.array([0, 0], dtype=np.intc)\n        \n        root, d_parent_root = self.find(self.parent[i])\n        \n        # Path compression: point i directly to root\n        self.parent[i] = root\n        # Update displacement: d(i-root) = d(i-parent) + d(parent-root)\n        self.disp[i] += d_parent_root\n        \n        return root, self.disp[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Unites the sets containing elements i and j. Detects cycle closure\n        and updates wrapping status.\n        i and j must be indices of nearest-neighbor sites.\n        \"\"\"\n        # Calculate the minimal displacement vector from i to j on the torus\n        xi, yi = i // self.L, i % self.L\n        xj, yj = j // self.L, j % self.L\n        \n        dx = xj - xi\n        if dx  1: dx -= self.L\n        if dx  -1: dx += self.L\n        \n        dy = yj - yi\n        if dy  1: dy -= self.L\n        if dy  -1: dy += self.L\n        \n        delta = np.array([dx, dy], dtype=np.intc)\n\n        root_i, d_i = self.find(i)\n        root_j, d_j = self.find(j)\n\n        if root_i != root_j:\n            # Union by rank\n            if self.rank[root_i]  self.rank[root_j]:\n                # Merge set i into set j\n                self.parent[root_i] = root_j\n                # disp[root_i] = pos(root_i) - pos(root_j)\n                # pos(root_i) = pos(i) - d_i\n                # pos(root_j) = pos(j) - d_j\n                # pos(i) = pos(j) - delta\n                # disp[root_i] = (pos(j) - delta - d_i) - (pos(j) - d_j) = d_j - d_i - delta\n                self.disp[root_i] = d_j - d_i - delta\n                # Propagate wrapping status\n                self.wrapped[root_j] = np.logical_or(self.wrapped[root_j], self.wrapped[root_i])\n            else:\n                # Merge set j into set i\n                self.parent[root_j] = root_i\n                # disp[root_j] = pos(root_j) - pos(root_i)\n                # pos(root_j) = pos(j) - d_j\n                # pos(root_i) = pos(i) - d_i\n                # pos(j) = pos(i) + delta\n                # disp[root_j] = (pos(i) + delta - d_j) - (pos(i) - d_i) = d_i - d_j + delta\n                self.disp[root_j] = d_i - d_j + delta\n                # Propagate wrapping status\n                self.wrapped[root_i] = np.logical_or(self.wrapped[root_i], self.wrapped[root_j])\n                if self.rank[root_i] == self.rank[root_j]:\n                    self.rank[root_i] += 1\n        else:\n            # Cycle closed: i and j are already in the same cluster\n            # W is the cycle vector in the unrolled lattice.\n            # W = (path displacement i-j) - (direct displacement i-j)\n            # Path disp i-j = pos(j) - pos(i) = (pos(root)+d_j) - (pos(root)+d_i) = d_j - d_i\n            # Direct disp i-j = delta\n            W = d_j - d_i - delta\n            \n            if W[0] != 0:\n                self.wrapped[root_i][0] = True\n            if W[1] != 0:\n                self.wrapped[root_i][1] = True\n\ndef estimate_pc(L, T, seed):\n    \"\"\"\n    Estimates the percolation threshold p_c for a given lattice size L,\n    number of realizations T, and a random seed.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    m_stars = []\n    n = L * L\n\n    for _ in range(T):\n        uf = UF_Winding(L)\n        occupied = np.zeros(n, dtype=bool)\n        site_order = rng.permutation(n)\n        \n        m_star_found = False\n        for m, site_idx in enumerate(site_order, 1):\n            occupied[site_idx] = True\n            \n            x, y = site_idx // L, site_idx % L\n            \n            # Neighbors are (x, y-1), (x, y+1), (x-1, y), (x+1, y)\n            neighbor_coords = [\n                (x, (y - 1 + L) % L),\n                (x, (y + 1) % L),\n                ((x - 1 + L) % L, y),\n                ((x + 1) % L, y)\n            ]\n            \n            for nx, ny in neighbor_coords:\n                neighbor_idx = nx * L + ny\n                if occupied[neighbor_idx]:\n                    uf.union(site_idx, neighbor_idx)\n            \n            root, _ = uf.find(site_idx)\n            if uf.wrapped[root, 0] or uf.wrapped[root, 1]:\n                m_stars.append(m)\n                m_star_found = True\n                break\n        \n        # If the loop finishes, wrapping must have occurred. A fully occupied\n        # grid guarantees wrapping. The break is guaranteed to be hit.\n        if not m_star_found:\n            # This case is physically impossible for L  1.\n            # Add n as a fallback, but it should not be reached.\n            m_stars.append(n)\n\n    m_star_fractions = np.array(m_stars, dtype=np.float64) / n\n    pc_estimate = np.median(m_star_fractions)\n    return pc_estimate\n\ndef solve():\n    test_cases = [\n        {'L': 16, 'T': 600, 'seed': 314159},\n        {'L': 32, 'T': 400, 'seed': 271828},\n        {'L': 64, 'T': 300, 'seed': 161803},\n        {'L': 10, 'T': 800, 'seed': 101},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = estimate_pc(L=case['L'], T=case['T'], seed=case['seed'])\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}