{
    "hands_on_practices": [
        {
            "introduction": "贝特晶格（Bethe lattice），或称无限树，是统计物理学中的一个基本模型，因为它没有环路，极大地简化了分析。本练习将引导您通过严谨的推导，将逾渗问题映射到分支过程（branching process）上，从而得到逾渗阈值。这是在复杂系统研究中一项关键的分析技术。",
            "id": "4136648",
            "problem": "考虑一个无限无环树，称为贝特晶格（Bethe lattice），其中每个顶点的度（配位数）均为 $z \\geq 3$。在键逾渗（bond percolation）中，每条边以概率 $p \\in [0,1]$ 独立地被宣告为开放，否则为关闭。包含一个指定根顶点的开放边连通分量称为其开放簇。由于没有环，开放簇从根部向外的生长过程可以被建模为一个分支过程，其中每个新到达的顶点只能尝试连接到其先前未到达的邻居。\n\n从适用于复杂自适应系统建模的第一性原理出发，使用以下基本依据：\n\n- 贝特晶格作为无限、无环、$z$-正则图的定义。\n- 将树上的逾渗簇映射到高尔顿-沃森（Galton–Watson）分支过程，其中一个顶点的后代数量等于连接到先前未到达邻居的开放边数量。\n- 通过后代生成函数对高尔顿-沃森过程中的灭绝和存活进行的标准刻画，以及在临界点出现非零存活概率的判据。\n\n推导贝特晶格上的键逾渗阈值 $p_c$，使其成为 $z$ 的一个闭式函数。你的推导必须从上述基本依据开始，明确识别由贝特晶格上的键逾渗所诱导的后代分布，使用生成函数构建灭绝概率方程，并推断出非平凡存活概率出现的条件。将最终阈值表示为关于 $z$ 的单个精确解析表达式。无需四舍五入，也无需单位。最终答案必须是单个表达式。",
            "solution": "问题陈述经验证是科学上合理的、提法恰当的且客观的。它描述了复杂系统统计物理学中的一个典型问题，特别是贝特晶格上的键逾渗，并要求基于第一性原理进行推导。所提供的框架——映射到高尔顿-沃森过程——是解决此问题的标准且严谨的方法。所有定义和条件都是自洽的，且在数学上是一致的。\n\n键逾渗阈值 $p_c$ 的推导是遵循指定的基本依据进行的。\n\n1.  **将逾渗映射到分支过程**\n    贝特晶格是一个无限无环图，其中每个顶点的配位数均为 $z$。我们将一个顶点视为潜在开放簇的根，并将其指定为第 $G_0$ 代。一条边以概率 $p$ 开放，以概率 $1-p$ 关闭。\n    从根部开始的开放簇的生长过程可以被建模为高尔顿-沃森分支过程。在此模型中，簇的顶点是“个体”，连接到新顶点的开放边是“后代”。\n    让我们考虑一个属于开放簇且属于第 $n \\geq 1$ 代的顶点。它是通过一条来自第 $n-1$ 代中唯一“父”顶点的开放边到达的。由于晶格是树状结构，因此没有环。因此，连接到该顶点的 $z$ 条边中，一条指回其父顶点，另外 $z-1$ 条指向先前未访问过的“前向”邻居。\n    第 $n \\geq 1$ 代中一个顶点的后代数量，是连接它与其 $z-1$ 个前向邻居的开放边的数量。为了使该过程能被一个所有个体都具有相同后代分布的标准高尔顿-沃森过程建模，我们考虑从第 $G_1$ 代（根的子代）开始的种群动态。第 $n \\geq 1$ 代中的任何个体都有 $z-1$ 个潜在后代。\n\n2.  **后代分布与生成函数**\n    对于任何给定的个体（第 $n \\geq 1$ 代中的一个顶点），其后代数量 $k$ 服从二项分布。存在 $z-1$ 次独立试验（连接到前向邻居的边），每次试验的成功概率为 $p$（边是开放的）。拥有 $k$ 个后代的概率质量函数 $P(k)$ 为：\n    $$P(k) = \\binom{z-1}{k} p^k (1-p)^{z-1-k}, \\quad \\text{for } k \\in \\{0, 1, \\dots, z-1\\}$$\n    后代生成函数 $G(x)$ 由幂级数 $G(x) = \\sum_{k=0}^{\\infty} P(k) x^k$ 定义。代入我们的二项分布：\n    $$G(x) = \\sum_{k=0}^{z-1} \\binom{z-1}{k} p^k (1-p)^{z-1-k} x^k$$\n    这是一个二项式表达式的展开。根据二项式定理 $(a+b)^n = \\sum_{k=0}^n \\binom{n}{k} a^{n-k} b^k$，我们可以确定 $n = z-1$，$a = 1-p$ 和 $b = px$。生成函数简化为：\n    $$G(x) = ((1-p)+px)^{z-1} = (1-p+px)^{z-1}$$\n\n3.  **无限簇形成的条件（非灭绝）**\n    在分支过程理论中，最终灭绝的概率 $q$ 是生成函数的最小非负不动点，即方程 $q = G(q)$ 的最小解。\n    只有在存活概率非零的情况下，才能形成无限簇，这意味着灭绝概率 $q$ 必须严格小于 $1$。\n    方程 $x = G(x)$ 在 $x=1$ 处总有一个解，因为 $G(1) = \\sum P(k) = 1$。是否存在另一个解 $q \\in [0, 1)$ 取决于 $G(x)$ 在 $x=1$ 附近的行为。由于 $G(x)$ 在 $[0,1]$ 上是一个凸函数（因为所有 $P(k) \\geq 0$），它与直线 $y=x$ 在小于 $x=1$ 的点相交的充要条件是它在 $x=1$ 处的斜率大于 $1$。\n    因此，出现非平凡存活概率的条件是 $G'(1) > 1$。量 $G'(1)$ 是单个个体的期望后代数。\n    逾渗阈值 $p_c$ 是 $p$ 的临界值，在该值上，系统从所有簇都有限的区域（亚临界，$G'(1) \\leq 1$）过渡到可能存在无限簇的区域（超临界，$G'(1) > 1$）。在临界点，平均后代数恰好为1：\n    $$G'(1) = 1$$\n\n4.  **逾渗阈值 $p_c$ 的推导**\n    我们计算 $G(x)$ 对 $x$ 的导数：\n    $$G'(x) = \\frac{d}{dx} \\left[ (1-p+px)^{z-1} \\right]$$\n    使用链式法则：\n    $$G'(x) = (z-1) (1-p+px)^{z-2} \\cdot \\frac{d}{dx}(1-p+px) = p(z-1)(1-p+px)^{z-2}$$\n    现在，我们计算该导数在 $x=1$ 处的值：\n    $$G'(1) = p(z-1)(1-p+p(1))^{z-2} = p(z-1)(1)^{z-2} = p(z-1)$$\n    平均后代数是 $\\mu = p(z-1)$。我们在临界概率 $p=p_c$ 处将其设为 $1$：\n    $$p_c(z-1) = 1$$\n    求解 $p_c$，我们得到贝特晶格上的键逾渗阈值：\n    $$p_c = \\frac{1}{z-1}$$\n    该表达式给出了作为配位数 $z$ 函数的精确逾渗阈值，符合要求。条件 $z \\geq 3$ 确保了 $p_c \\in (0, 1/2]$，这在物理上是有意义的。",
            "answer": "$$\\boxed{\\frac{1}{z-1}}$$"
        },
        {
            "introduction": "对于大多数晶格，例如三维立方晶格 $\\mathbb{Z}^3$，逾渗阈值的精确解仍然未知。本练习旨在教授应对这类棘手问题的核心技能：推导严格的数学界限和构建富有洞察力的启发式论证。您将使用路径计数的方法建立一个严格的下界，并利用简化的生长模型来找到一个合理的上界。",
            "id": "4136670",
            "problem": "考虑立方晶格 $\\mathbb{Z}^3$ 上的独立键渗流，其中每条无向边（键）以概率 $p \\in [0,1]$ 开启，否则关闭，且各边的状态相互独立。令 $p_c$ 表示这样一个 $p$ 值的下确界：在该 $p$ 值下，存在一个包含原点的由开启的边构成的无限连通分支（簇）的概率为正。仅使用基本定义和成熟的概率论工具，通过对从原点出发的自回避行走（SAW）进行计数并应用独立性，为 $p_c$ 推导一个严格的下界 $p_L$。然后，在 $\\mathbb{Z}^3$ 上使用等周式的向外扩展论证，并通过 Galton–Watson (GW) 分支过程进行启发式近似，根据可用于簇增长的 $L^1$向外边，为 $p_c$ 推导一个启发式的上界 $p_U$。您的界应当从第一性原理出发进行充分论证，并清楚地说明哪些步骤是严格的，哪些是启发式的。请将您的最终界表示为无单位的精确分数，并按顺序以数对 $(p_L, p_U)$ 的形式报告。无需四舍五入。",
            "solution": "所述问题具有科学依据、提法恰当、客观且内部一致。这是统计物理和概率论中的一个标准问题，特别是在渗流理论这一主题下。验证清单中指出的缺陷均不存在。因此，有必要提供解答。\n\n该问题要求为立方晶格 $\\mathbb{Z}^3$ 上键渗流的临界概率 $p_c$ 推导一个严格下界 $p_L$ 和一个启发式上界 $p_U$。\n\n### 严格下界 $p_L$ 的推导\n\n临界概率 $p_c$ 是一个阈值，当概率低于此值时，与原点相连的开放簇 $C(O)$ 几乎必然是有限的。寻找 $p_c$ 下界的一个标准方法是确定一个 $p$ 的范围，在该范围内，此簇的期望大小 $E_p[|C(O)|]$ 是有限的。如果 $E_p[|C(O)|]  \\infty$，那么根据 Borel-Cantelli 引理或直接论证可知，簇的大小必然以概率 $1$ 为有限，即 $P_p(|C(O)|  \\infty) = 1$。这意味着任何这样的 $p$ 都必须处于亚临界相，因此 $p \\le p_c$。这类 $p$ 值的上确界即为 $p_c$ 的一个下界。\n\n包含原点的簇的期望大小是每个顶点 $x$ 与原点 $O$ 相连的概率之和：\n$$\nE_p[|C(O)|] = \\sum_{x \\in \\mathbb{Z}^3} P_p(O \\leftrightarrow x)\n$$\n其中 $O \\leftrightarrow x$ 表示在 $O$ 和 $x$ 之间至少存在一条由开启的边构成的路径的事件。\n\n为了界定这个概率，我们对所有可能的路径使用并集界。问题指定使用自回避行走（SAW）。令 $\\mathcal{W}(O,x)$ 为从 $O$ 到 $x$ 的所有 SAW 的集合。一条长度为 $n$（由 $n$ 条边组成）的特定 SAW $\\gamma \\in \\mathcal{W}(O,x)$ 是开启的，当且仅当其所有 $n$ 条边都是开启的。由于边状态的独立性，这种情况发生的概率为 $p^n$。\n事件 $\\{O \\leftrightarrow x\\}$ 是所有从 $O$ 到 $x$ 的 SAW $\\gamma$ 的 $\\{\\gamma \\text{ is open}\\}$ 事件的并集。根据并集界：\n$$\nP_p(O \\leftrightarrow x) \\le \\sum_{\\gamma \\in \\mathcal{W}(O,x)} P_p(\\gamma \\text{ is open})\n$$\n令 $c_n(x)$ 为从原点到顶点 $x$ 的长度为 $n$ 的 SAW 的数量。上述和式可以写作：\n$$\nP_p(O \\leftrightarrow x) \\le \\sum_{n=1}^\\infty c_n(x) p^n\n$$\n将此代入簇期望大小的表达式中：\n$$\nE_p[|C(O)|] = \\sum_{x \\in \\mathbb{Z}^3} P_p(O \\leftrightarrow x) \\le \\sum_{x \\in \\mathbb{Z}^3} \\sum_{n=1}^\\infty c_n(x) p^n\n$$\n我们可以交换求和顺序（因为所有项都是非负的）：\n$$\nE_p[|C(O)|] \\le \\sum_{n=1}^\\infty p^n \\sum_{x \\in \\mathbb{Z}^3} c_n(x)\n$$\n内层和 $\\sum_{x \\in \\mathbb{Z}^3} c_n(x)$ 是从原点出发的长度为 $n$ 的 SAW 的总数，我们将其记为 $c_n$。因此，\n$$\nE_p[|C(O)|] \\le \\sum_{n=1}^\\infty c_n p^n\n$$\n为了使这个界有用，我们需要一个 $c_n$ 的上界。对于任何晶格，$c_n$ 的上界是长度为 $n$ 的非回溯行走的数量。立方晶格 $\\mathbb{Z}^3$ 的配位数是 $z=6$。从原点出发的长度为 $n$ 的行走，第一步有 $z=6$ 种选择。对于非回溯行走中的每一步后续步骤，行走不能立即反向，因此最多剩下 $z-1=5$ 种选择。由于自回避行走根据定义就是非回溯的，其数量受此量所界定：\n$$\nc_n \\le z(z-1)^{n-1} = 6 \\cdot 5^{n-1}\n$$\n将此代入我们关于簇期望大小的不等式中：\n$$\nE_p[|C(O)|] \\le \\sum_{n=1}^\\infty (6 \\cdot 5^{n-1}) p^n = \\frac{6}{5} \\sum_{n=1}^\\infty (5p)^n\n$$\n右侧是一个几何级数，它收敛当且仅当其公比小于 $1$。收敛的条件是 $|5p|  1$。由于 $p \\ge 0$，这可以简化为 $5p  1$，即 $p  \\frac{1}{5}$。\n\n对于任何 $p  \\frac{1}{5}$，该级数收敛，因此 $E_p[|C(O)|]$ 是有限的。这意味着 $P_p(|C(O)|=\\infty) = 0$。因此，范围 $[0, 1/5)$ 内的任何 $p$ 都属于亚临界相。由于 $p_c$ 是发生渗流的 $p$ 值的下确界，我们必有 $p_c \\ge \\frac{1}{5}$。\n这就确立了一个严格的下界：\n$$\np_L = \\frac{1}{5}\n$$\n\n### 启发式上界 $p_U$ 的推导\n\n为了找到 $p_c$ 的一个上界，我们需要找到一个 $p$ 值，使得我们可以论证渗流 *确实* 发生。所要求的论证是启发式的，并且基于将簇的增长建模为一个分支过程（一个 Galton-Watson 过程）。\n\n该启发式方法依赖于考虑“有向渗流”。如果从原点出发的路径上每一步都使 $L^1$距离（对于顶点 $v=(v_x, v_y, v_z)$ 定义为 $|v|_1 = |v_x|+|v_y|+|v_z|$）严格增加，我们就称该路径是“向外”的。如果存在一条无限长的向外开放路径，那么就存在一个无限簇。无限有向开放路径的存在是无限开放簇存在的充分但非必要条件。因此，有向渗流的临界概率 $p_c^{\\text{oriented}}$ 是真实临界概率 $p_c$ 的一个上界：$p_c \\le p_c^{\\text{oriented}}$。\n\n我们可以通过将有向渗流的条件建模为一个 Galton-Watson 分支过程来近似它。在这个模型中，每个新到达的顶点是一个“个体”，它产生的“后代”对应于那些可以通过一条开启的向外边到达的邻居。如果每个个体的期望后代数大于 $1$，那么该过程将以正概率无限增长（存活）。\n\n让我们确定从一个顶点 $v \\in \\mathbb{Z}^3$ 出发的向外边的数量。如果 $|u|_1 = |v|_1 + 1$，则边 $(v, u)$ 是向外的。这类边的数量取决于 $v$ 的位置：\n- 如果 $v$ 是原点 $(0,0,0)$，所有 $z=6$ 个邻居的 $L^1$距离都为 $1$。所以，有 $6$ 条向外边。\n- 如果 $v=(x,y,z)$ 且 $x,y,z \\neq 0$，它有 $3$ 个邻居增加 $L^1$距离（例如 $(x+\\text{sgn}(x), y, z)$），还有 $3$ 个邻居减少 $L^1$距离（例如 $(x-\\text{sgn}(x), y, z)$）。所以，有 $3$ 条向外边。\n- 如果 $v$ 位于某个坐标平面上但不在坐标轴上（例如 $x,y \\neq 0, z=0$），它有 $4$ 条向外边。\n- 如果 $v$ 位于某个坐标轴上但不是原点（例如 $x \\neq 0, y=z=0$），它有 $5$ 条向外边。\n\n对于任何顶点 $v \\neq O$，可用于增长的向外边数量至少为 $3$。为了找到渗流的充分条件，我们可以保守地考虑增长的“最坏情况”，这种情况发生在远离原点的地方，那里的一个一般位置只有 $3$ 条可用的向外边。\n\n我们启发式地将此过程建模为一个分支过程，其中每个个体的后代数量服从二项分布 $\\text{Bin}(k, p)$，这里 $k$ 是可用的子代位置数。如果期望后代数 $kp$ 大于 $1$，则该过程存活。使用我们的保守值 $k=3$：\n$$\nE[\\text{offspring}] = 3p > 1 \\implies p > \\frac{1}{3}\n$$\n如果 $p > 1/3$，代表有向路径增长的分支过程是超临界的，并以正概率存活。由于无限有向路径的存在意味着原始渗流问题中存在无限簇，我们可以启发式地得出结论：当 $p > 1/3$ 时会发生渗流。\n这意味着临界概率 $p_c$ 必定不大于 $1/3$。这给出了启发式上界：\n$$\np_U = \\frac{1}{3}\n$$\n这是启发式的，因为我们忽略了晶格复杂的空间相关性，以及向外边的数量不是恒定的事实，从而将增长过程简化为了一个无记忆的分支过程。\n\n推导出的界是严格下界 $p_L = 1/5$ 和启发式上界 $p_U = 1/3$。",
            "answer": "$$\\boxed{(\\frac{1}{5}, \\frac{1}{3})}$$"
        },
        {
            "introduction": "当解析方法不足以解决问题时，计算模拟便成为不可或缺的工具。本练习涉及实现一个复杂的算法，以高精度地估计二维晶格上的逾渗阈值。它将介绍如何通过使用周期性边界条件和探测“环绕”团簇等技术来最小化有限尺寸效应，从而提供一个在相变计算科学领域的真实动手经验。",
            "id": "4136646",
            "problem": "考虑一个线性尺寸为 $L$ 的二维方格上的位点逾渗，该方格具有周期性边界条件，在拓扑上形成一个离散环面。每个格点以概率 $p \\in [0,1]$ 被独立占据。团簇由环面上的最近邻连接定义。逾渗阈值 $p_c$ 是指出现一个宏观团簇时的临界占据概率。在有限系统中，边界效应会使 $p_c$ 的估计量产生偏差；周期性边界条件通过消除边缘和角落来减轻这些效应，从而允许使用环绕概率进行估计。\n\n我们将环绕概率 $R_L(p)$ 定义为：存在至少一个团簇，其沿环面的水平或垂直方向具有非零卷绕数的概率。如果一个团簇中存在一条闭合路径，在考虑跨越周期性边界的跳跃后，其在水平方向上的净位移不为零，则称该团簇表现出水平环绕；垂直环绕的定义与此类似。对于给定的实现和固定的晶格尺寸 $L$，首次环绕指数 $m^\\star$ 是指使某个团簇在至少一个方向上获得非零卷绕数所需的最少占据位点数 $m$。\n\n基于逾渗团簇、最近邻连接和周期性边界条件的核心定义，请实现一个算法，使用一个增加了位移追踪功能的不相交集并（并查集）数据结构来检测卷绕。该算法应能在沿任一环面方向具有非零净位移的环路形成时，精确地检测到这一事件。利用该算法，通过计算在多次独立实现中 $m^\\star/n$ 的中位数来估计 $p_c$，其中 $n=L^2$ 是晶格位点的总数。该估计量对应于微正则环繞概率等于 $1/2$ 的点，在周期性边界条件下，该点给出了一个边界效应减弱的 $p_c$ 估计值。\n\n您的程序必须：\n- 构建一个尺寸为 $L \\times L$ 的环面晶格。\n- 按随机顺序逐个添加位点，并使用带周期性边界条件的最近邻连接规则，将其与已占据的邻居进行合并。\n- 对每次合并操作追踪位移约束，以便在某条边闭合形成环路时，能够计算出该环路的净位移；如果沿水平或垂直方向的净位移不为零，则标记该团簇在该方向上发生了环绕。\n- 记录每次实现的首次环绕指数 $m^\\star$（即首次发生环绕时的步骤），并计算所有实现中 $m^\\star/n$ 的中位数，以估计 $p_c$。\n- 针对提供的测试套件生成结果。\n\n使用的基本原理：\n- 方格上的最近邻连接。\n- 通过被占据的位点将团簇定义为连通分量。\n- 通过模 $L$ 的索引算术实现环面拓扑的周期性边界条件。\n- 环绕概率随占据分数增加的单调性。\n- 中位数作为交叉点的解释：在多次实现中 $m^\\star/n$ 的中位数等于有限尺寸微正则环绕概率等于 $1/2$ 时的占据分数。\n\n您的实现必须是纯算法性的，并模拟所定义的过程；不得使用任何外部数据。所有输出均为无量纲概率，且必须以小数十进制数表示。\n\n测试套件：\n- 情况1：$L=16$，实现次数 $T=600$，随机种子 $314159$。\n- 情况2：$L=32$，实现次数 $T=400$，随机种子 $271828$。\n- 情况3：$L=64$，实现次数 $T=300$, 随机种子 $161803$。\n- 情况4：$L=10$，实现次数 $T=800$，随机种子 $101$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试套件的顺序列出结果，例如：“[$r_1,r_2,r_3,r_4$]”。每个 $r_i$ 必须是一个小数十进制数，代表对应情况的 $p_c$ 估计值。",
            "solution": "该问题要求实现一个算法来估计二维方格上的位点逾渗阈值 $p_c$。该算法基于在随机填充格点的过程中检测“环绕”簇（wrapping cluster）的出现。下面是算法的详细解释，这与所提供的Python代码实现相对应。\n\n1.  **模型设置**\n    该模型是一个 $L \\times L$ 的二维方格，具有周期性边界条件，使其在拓扑上等效于一个环面。格点（位点）以随机顺序被逐个“占据”。\n\n2.  **核心数据结构：带位移追踪的并查集 (Union-Find with Displacement Tracking)**\n    为了有效地跟踪连通分量（簇）并检测环绕，我们使用一个增强的并查集（DSU）数据结构。\n    *   **标准并查集**：每个格点是一个元素。`parent`数组跟踪每个集合的父节点，`rank`数组用于实现按秩合并优化。`find`操作（带路径压缩）用于确定一个元素所属集合的根。\n    *   **位移追踪**：这是算法的关键。我们为每个元素 `i` 维护一个二维位移向量 `disp[i]`。该向量存储了在无限展开的（非周期性）晶格上，从位置 `i` 到其父节点 `parent[i]` 的位移。当执行路径压缩时，这些位移会累加起来，因此 `find(i)` 的最终结果不仅返回根节点 `root`，还返回从 `i` 到 `root` 的总位移。\n    *   **环绕状态**：我们为每个集合的根节点维护一个布尔数组 `wrapped[root]`，用于标记该簇是否已经在水平方向（x）或垂直方向（y）上环绕了环面。\n\n3.  **合并操作与环绕检测 (`union`)**\n    当一个新位点被占据时，我们会检查其所有已占据的邻居，并调用 `union` 操作将它们合并到同一个簇中。\n    *   **不同集合的合并**：如果要合并的两个位点 `i` 和 `j` 属于不同的集合（即有不同的根 `root_i` 和 `root_j`），我们将一个集合连接到另一个上。关键在于更新位移向量。例如，如果我们将 `root_i` 连接到 `root_j`，`disp[root_i]` 需要被设置为在无限晶格上从 `root_i` 到 `root_j` 的位移。这个位移可以通过 `disp[i]`、`disp[j]` 和 `i`与`j`之间的直接位移（考虑到周期性边界）计算出来。新根的环绕状态是两个旧根环绕状态的逻辑或。\n    *   **同一集合的合并（闭环）**：如果 `i` 和 `j` 已经在同一个集合中，这次合并操作实际上关闭了一个环路。我们可以计算出这个环路在无限展开晶格上的净位移向量 `W`。该向量 `W` 可以通过 `i` 和 `j` 到它们共同根的位移，以及 `i` 和 `j` 之间的直接位移来确定。计算公式为 `W = (d_j - d_i) - delta`，其中 `d_i` 和 `d_j` 是从 `i` 和 `j` 到根的位移，`delta` 是从 `i` 到 `j` 的直接位移。\n    *   **环绕判定**：如果闭环向量 `W` 的任何一个分量（x或y）不为零，就意味着这个环路在那个方向上环绕了环面。例如，如果 `W_x` 非零，则该簇现在具有水平环绕。我们随即更新该簇根节点的 `wrapped` 状态。\n\n4.  **$p_c$ 的估计**\n    对于每一次独立的模拟（实现）：\n    *   我们按随机顺序逐个添加位点。\n    *   在每一步，我们执行 `union` 操作并检查是否有环绕事件发生。\n    *   我们记录下第一次检测到任何方向的环绕时所占据的位点数，记为“首次环绕指数” $m^\\star$。\n    *   该次模拟的逾渗概率估计值为 $p_{est} = m^\\star / n$，其中 $n=L^2$ 是总位点数。\n    对所有 `T` 次模拟，我们得到一系列的 $p_{est}$ 值。根据逾渗理论中的有限尺寸标度，这些值的**中位数**是 $p_c(L)$ 的一个非常好的估计量。它对应于“微正则”系综中环绕概率为 $1/2$ 的点。\n\n该算法通过追踪拓扑不变量（卷绕数）而非几何上的贯穿，为在周期性边界条件下估计 $p_c$ 提供了一种精确且计算上高效的方法。",
            "answer": "```python\nimport numpy as np\n# No other libraries are permitted by the problem statement.\n\nclass UF_Winding:\n    \"\"\"\n    A Disjoint-Set Union (DSU) data structure augmented to detect winding numbers\n    on a 2D toroidal lattice of size L x L.\n    \"\"\"\n    def __init__(self, L):\n        self.L = L\n        n = L * L\n        self.parent = np.arange(n, dtype=np.intc)\n        self.rank = np.zeros(n, dtype=np.intc)\n        # disp[i] stores the vector displacement pos(i) - pos(parent[i])\n        # in the unrolled infinite lattice.\n        self.disp = np.zeros((n, 2), dtype=np.intc)\n        # wrapped[i] stores [wrapped_x, wrapped_y] for root i.\n        self.wrapped = np.zeros((n, 2), dtype=bool)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing element i, with path compression\n        and displacement vector updates.\n        Returns: (root, displacement_from_i_to_root)\n        \"\"\"\n        if self.parent[i] == i:\n            return i, np.array([0, 0], dtype=np.intc)\n        \n        root, d_parent_root = self.find(self.parent[i])\n        \n        # Path compression: point i directly to root\n        self.parent[i] = root\n        # Update displacement: d(i-root) = d(i-parent) + d(parent-root)\n        self.disp[i] += d_parent_root\n        \n        return root, self.disp[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Unites the sets containing elements i and j. Detects cycle closure\n        and updates wrapping status.\n        i and j must be indices of nearest-neighbor sites.\n        \"\"\"\n        # Calculate the minimal displacement vector from i to j on the torus\n        xi, yi = i // self.L, i % self.L\n        xj, yj = j // self.L, j % self.L\n        \n        dx = xj - xi\n        if dx  1: dx -= self.L\n        if dx  -1: dx += self.L\n        \n        dy = yj - yi\n        if dy  1: dy -= self.L\n        if dy  -1: dy += self.L\n        \n        delta = np.array([dx, dy], dtype=np.intc)\n\n        root_i, d_i = self.find(i)\n        root_j, d_j = self.find(j)\n\n        if root_i != root_j:\n            # Union by rank\n            if self.rank[root_i]  self.rank[root_j]:\n                # Merge set i into set j\n                self.parent[root_i] = root_j\n                # disp[root_i] = pos(root_i) - pos(root_j)\n                # pos(root_i) = pos(i) - d_i\n                # pos(root_j) = pos(j) - d_j\n                # pos(i) = pos(j) - delta\n                # disp[root_i] = (pos(j) - delta - d_i) - (pos(j) - d_j) = d_j - d_i - delta\n                self.disp[root_i] = d_j - d_i - delta\n                # Propagate wrapping status\n                self.wrapped[root_j] = np.logical_or(self.wrapped[root_j], self.wrapped[root_i])\n            else:\n                # Merge set j into set i\n                self.parent[root_j] = root_i\n                # disp[root_j] = pos(root_j) - pos(root_i)\n                # pos(root_j) = pos(j) - d_j\n                # pos(root_i) = pos(i) - d_i\n                # pos(j) = pos(i) + delta\n                # disp[root_j] = (pos(i) + delta - d_j) - (pos(i) - d_i) = d_i - d_j + delta\n                self.disp[root_j] = d_i - d_j + delta\n                # Propagate wrapping status\n                self.wrapped[root_i] = np.logical_or(self.wrapped[root_i], self.wrapped[root_j])\n                if self.rank[root_i] == self.rank[root_j]:\n                    self.rank[root_i] += 1\n        else:\n            # Cycle closed: i and j are already in the same cluster\n            # W is the cycle vector in the unrolled lattice.\n            # W = (path displacement i-j) - (direct displacement i-j)\n            # Path disp i-j = pos(j) - pos(i) = (pos(root)+d_j) - (pos(root)+d_i) = d_j - d_i\n            # Direct disp i-j = delta\n            W = d_j - d_i - delta\n            \n            if W[0] != 0:\n                self.wrapped[root_i][0] = True\n            if W[1] != 0:\n                self.wrapped[root_i][1] = True\n\ndef estimate_pc(L, T, seed):\n    \"\"\"\n    Estimates the percolation threshold p_c for a given lattice size L,\n    number of realizations T, and a random seed.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    m_stars = []\n    n = L * L\n\n    for _ in range(T):\n        uf = UF_Winding(L)\n        occupied = np.zeros(n, dtype=bool)\n        site_order = rng.permutation(n)\n        \n        m_star_found = False\n        for m, site_idx in enumerate(site_order, 1):\n            occupied[site_idx] = True\n            \n            x, y = site_idx // L, site_idx % self.L\n            \n            # Neighbors are (x, y-1), (x, y+1), (x-1, y), (x+1, y)\n            neighbor_coords = [\n                (x, (y - 1 + L) % L),\n                (x, (y + 1) % L),\n                ((x - 1 + L) % L, y),\n                ((x + 1) % L, y)\n            ]\n            \n            for nx, ny in neighbor_coords:\n                neighbor_idx = nx * L + ny\n                if occupied[neighbor_idx]:\n                    uf.union(site_idx, neighbor_idx)\n            \n            root, _ = uf.find(site_idx)\n            if uf.wrapped[root, 0] or uf.wrapped[root, 1]:\n                m_stars.append(m)\n                m_star_found = True\n                break\n        \n        # If the loop finishes, wrapping must have occurred. A fully occupied\n        # grid guarantees wrapping. The break is guaranteed to be hit.\n        if not m_star_found:\n            # This case is physically impossible for L  1.\n            # Add n as a fallback, but it should not be reached.\n            m_stars.append(n)\n\n    m_star_fractions = np.array(m_stars, dtype=np.float64) / n\n    pc_estimate = np.median(m_star_fractions)\n    return pc_estimate\n\ndef solve():\n    test_cases = [\n        {'L': 16, 'T': 600, 'seed': 314159},\n        {'L': 32, 'T': 400, 'seed': 271828},\n        {'L': 64, 'T': 300, 'seed': 161803},\n        {'L': 10, 'T': 800, 'seed': 101},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = estimate_pc(L=case['L'], T=case['T'], seed=case['seed'])\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}