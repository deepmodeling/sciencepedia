{
    "hands_on_practices": [
        {
            "introduction": "我们从巩固超图的基本构件开始。这项练习将强化节点度与超边大小的定义，并通过一个简单的计数论证来展示它们之间的基本关系 。掌握这些基础知识是理解更复杂高阶结构的第一步。",
            "id": "4126420",
            "problem": "考虑一个有限超图模型，用于编码复杂自适应系统（CAS）中的高阶相互作用。超图由一个节点集合 $V$ 和一个超边集合 $E$ 定义，其中每条超边是 $V$ 的一个子集。节点 $v \\in V$ 的度 $d(v)$ 是 $E$ 中包含 $v$ 的超边数量，而超边 $e \\in E$ 的大小 $|e|$ 是它所包含的节点数量。关联矩阵记录了节点与超边的隶属关系，其非零项的总数可以通过对所有节点的度求和，或通过对所有超边的大小求和来计算。从这些定义和关联矩阵的观点出发，证明在任何有限超图中这两个总数相等，然后对给定特例 $V=\\{1,2,3,4\\}$ 和 $E=\\{\\{1,2,3\\},\\{2,3\\},\\{1,4\\}\\}$ 计算这个共同的总数。计算每个 $v \\in V$ 的 $d(v)$，计算每个 $e \\in E$ 的 $|e|$，并以精确整数形式给出最终的共同总数。",
            "solution": "该问题被认为是有效的，因为它在科学上基于超图理论这一数学领域，问题阐述清晰，目标明确，语言客观，并包含了得出完整解所需的所有必要信息。\n\n该问题要求分两部分回答：首先，对“任何有限超图中，节点度数之和等于超边大小之和”这一结论进行普适性证明；其次，对一个具体示例计算这些和以及共同的总数。\n\n设超图表示为 $\\mathcal{H} = (V, E)$，其中 $V$ 是一个有限的节点集合，$E$ 是一个有限的超边集合，每条超边 $e \\in E$ 是 $V$ 的一个非空子集。\n\n为证明该等式，我们采用问题中建议的关联矩阵概念。设 $|V|=n$ 和 $|E|=m$。关联矩阵 $H$ 是一个 $n \\times m$ 矩阵，其行由节点 $v \\in V$ 索引，列由超边 $e \\in E$ 索引。矩阵的元素 $H_{ve}$ 定义如下：\n$$\nH_{ve} = \\begin{cases} 1  \\text{if } v \\in e \\\\ 0  \\text{if } v \\notin e \\end{cases}\n$$\n$H$ 中非零项的总数即为其所有元素之和，因为元素值仅为 $1$ 或 $0$。我们用 $S$ 表示这个总和。我们可以通过两种不同的顺序对矩阵元素求和来计算 $S$。\n\n首先，我们对每一行按列求和，然后将所有行的结果相加。这对应于以节点为中心的视角。对于一个固定的节点 $v_i \\in V$，其对应行的元素之和为：\n$$\n\\sum_{e_j \\in E} H_{v_i e_j}\n$$\n根据关联矩阵的定义，$H_{v_i e_j}$ 为 $1$ 当且仅当节点 $v_i$ 包含在超边 $e_j$ 中。因此，这个和计算了包含节点 $v_i$ 的超边数量。这正是节点 $v_i$ 的度（记作 $d(v_i)$）的定义。\n$$\nd(v_i) = \\sum_{e_j \\in E} H_{v_i e_j}\n$$\n为了求得总和 $S$，我们将这些行和对所有节点 $v_i \\in V$ 求和：\n$$\nS = \\sum_{v_i \\in V} \\left( \\sum_{e_j \\in E} H_{v_i e_j} \\right) = \\sum_{v_i \\in V} d(v_i)\n$$\n其次，我们对每一列按行求和，然后将所有列的结果相加。这对应于以超边为中心的视角。对于一条固定的超边 $e_j \\in E$，其对应列的元素之和为：\n$$\n\\sum_{v_i \\in V} H_{v_i e_j}\n$$\n根据定义，$H_{v_i e_j}$ 为 $1$ 当且仅当节点 $v_i$ 是超边 $e_j$ 的一个成员。因此，这个和计算了超边 $e_j$ 中包含的节点数量。这正是超边 $e_j$ 的大小（或基数）（记作 $|e_j|$）的定义。\n$$\n|e_j| = \\sum_{v_i \\in V} H_{v_i e_j}\n$$\n为了求得总和 $S$，我们将这些列和对所有超边 $e_j \\in E$ 求和：\n$$\nS = \\sum_{e_j \\in E} \\left( \\sum_{v_i \\in V} H_{v_i e_j} \\right) = \\sum_{e_j \\in E} |e_j|\n$$\n由于两种计算方法都得出了相同的总和 $S$，因此这两个表达式必然相等。这种证明方法被称为双重计数法。\n$$\n\\sum_{v \\in V} d(v) = \\sum_{e \\in E} |e|\n$$\n这就证明了对于任何有限超图，该普遍原理都成立。\n\n现在，我们对给定的具体案例进行计算：$V=\\{1,2,3,4\\}$ 且 $E=\\{e_1, e_2, e_3\\}$，其中 $e_1=\\{1,2,3\\}$，$e_2=\\{2,3\\}$，$e_3=\\{1,4\\}$。\n\n我们首先计算每个节点 $v \\in V$ 的度 $d(v)$：\n- 对于节点 $v=1$：它被包含在 $e_1=\\{1,2,3\\}$ 和 $e_3=\\{1,4\\}$ 中。因此，$d(1) = 2$。\n- 对于节点 $v=2$：它被包含在 $e_1=\\{1,2,3\\}$ 和 $e_2=\\{2,3\\}$ 中。因此，$d(2) = 2$。\n- 对于节点 $v=3$：它被包含在 $e_1=\\{1,2,3\\}$ 和 $e_2=\\{2,3\\}$ 中。因此，$d(3) = 2$。\n- 对于节点 $v=4$：它被包含在 $e_3=\\{1,4\\}$ 中。因此，$d(4) = 1$。\n\n度的总和是：\n$$\n\\sum_{v \\in V} d(v) = d(1) + d(2) + d(3) + d(4) = 2 + 2 + 2 + 1 = 7\n$$\n接下来，我们计算每条超边 $e \\in E$ 的大小 $|e|$：\n- 对于超边 $e_1=\\{1,2,3\\}$：其大小是它包含的节点数，所以 $|e_1| = 3$。\n- 对于超边 $e_2=\\{2,3\\}$：其大小是 $|e_2| = 2$。\n- 对于超边 $e_3=\\{1,4\\}$：其大小是 $|e_3| = 2$。\n\n超边大小的总和是：\n$$\n\\sum_{e \\in E} |e| = |e_1| + |e_2| + |e_3| = 3 + 2 + 2 = 7\n$$\n两个和都得到了相同的值 $7$，正如该定理所预测的。这个共同的总数代表了（节点，超边）关联对的总数，也就是对应的 $4 \\times 3$ 关联矩阵中非零项的数量。\n最终的共同总数是 $7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "在掌握了集合描述之后，我们转向更为强大的代数框架——张量。本练习将提供构建邻接张量的实践经验，这是分析高阶连通性和动力学的关键工具 。理解这种表示方法对于将谱方法和其他高级技术应用于超图至关重要。",
            "id": "4126393",
            "problem": "考虑一个在 $n=4$ 个标记顶点上的 $3$-一致超图，其超边为 $\\{1,2,3\\}$ 和 $\\{2,3,4\\}$。令邻接张量 $\\mathcal{A}$ 是一个对称的 3 阶 4 维张量，由 $k$-一致超图的广泛使用的归一化定义：对于任意两两不同的索引 $i,j,k$，如果 $\\{i,j,k\\}$ 是一条超边，则 $\\mathcal{A}_{ijk}=\\frac{1}{(k-1)!}$，否则 $\\mathcal{A}_{ijk}=0$，并且在索引置换下完全对称。使用此定义：\n1. 通过列出所有非零元素来明确写出 $\\mathcal{A}$。\n2. 对于一个分量为 $x_1,x_2,x_3,x_4$ 的向量 $x\\in\\mathbb{R}^{4}$，计算标量缩并 $x^{\\top}\\mathcal{A}x^{2}$，其定义为\n$$\nx^{\\top}\\mathcal{A}x^{2}\\;=\\;\\sum_{i=1}^{4}\\sum_{j=1}^{4}\\sum_{k=1}^{4}\\mathcal{A}_{ijk}\\,x_i x_j x_k.\n$$\n将您的最终答案表示为关于 $x_1,x_2,x_3,x_4$ 的简化解析表达式。不需要四舍五入，也不涉及单位。",
            "solution": "用户希望我解决这个问题。我将首先仔细验证问题陈述。\n\n### 步骤 1：提取已知条件\n- 超图类型：$3$-一致。\n- 顶点数：$n=4$，标记为 $\\{1, 2, 3, 4\\}$。\n- 超边集合：$E = \\{\\{1,2,3\\}, \\{2,3,4\\}\\}$。\n- 邻接张量：$\\mathcal{A}$，一个 3 阶 4 维对称张量。\n- $\\mathcal{A}$ 的定义：对于两两不同的索引 $i, j, k$，如果 $\\{i,j,k\\}$ 是一条超边，则 $\\mathcal{A}_{ijk} = \\frac{1}{(k-1)!}$，否则 $\\mathcal{A}_{ijk}=0$。该张量在索引置换下完全对称。\n- 任务 1：列出 $\\mathcal{A}$ 的所有非零元素。\n- 任务 2：对于向量 $x \\in \\mathbb{R}^{4}$，计算标量缩并 $x^{\\top}\\mathcal{A}x^{2} = \\sum_{i=1}^{4}\\sum_{j=1}^{4}\\sum_{k=1}^{4}\\mathcal{A}_{ijk}\\,x_i x_j x_k$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于超图理论和张量代数的既定原理。邻接张量的定义是谱超图理论中使用的标准约定。该问题在数学上是合理的。\n- **适定性：** 超图和邻接张量的定义明确。任务是基于这些定义的具体计算。存在唯一、稳定且有意义的解。\n- **客观性：** 问题以精确、客观的数学语言陈述。\n- **缺陷分析：**\n  1.  **科学或事实不准确：** 无。定义和概念在数学中是标准的。\n  2.  **无法形式化或不相关：** 无。问题是形式化的，并与高阶网络直接相关。\n  3.  **不完整或矛盾的设置：** 无。所有必要信息均已提供。该定义意味着具有重复索引的张量元素为 $0$，这是简单超图的标准约定，并非矛盾。\n  4.  **不切实际或不可行：** 不适用，因为这是一个纯数学问题。\n  5.  **不适定或结构不良：** 无。问题结构良好。\n  6.  **伪深刻、琐碎或同义反复：** 无。该问题是需要代数操作的定义的直接应用。\n  7.  **超出科学可验证性：** 无。结果在数学上是可验证的。\n\n### 步骤 3：结论和行动\n问题有效。我将继续提供完整的解决方案。\n\n***\n\n该问题要求我们首先确定邻接张量 $\\mathcal{A}$ 的非零元素，然后用它来计算一个多项式形式。\n\n该超图是 $n=4$ 个顶点上的 $k=3$-一致超图。超边给定为 $E = \\{\\{1,2,3\\}, \\{2,3,4\\}\\}$。\n邻接张量 $\\mathcal{A}$ 是 3 阶 4 维的。其元素 $\\mathcal{A}_{ijk}$ 定义如下：对于两两不同的索引 $i, j, k \\in \\{1, 2, 3, 4\\}$，如果 $\\{i,j,k\\}$ 是一条超边，则 $\\mathcal{A}_{ijk} = \\frac{1}{(k-1)!}$，否则 $\\mathcal{A}_{ijk} = 0$。该张量是完全对称的，意味着 $\\mathcal{A}_{ijk}$ 在其索引的任何置换下都保持不变。“否则”这一条件意味着如果索引不是两两不同的（例如 $i=j$），则 $\\mathcal{A}_{ijk}=0$。\n\n对于一个 $3$-一致超图，$k=3$。归一化因子为 $\\frac{1}{(k-1)!} = \\frac{1}{(3-1)!} = \\frac{1}{2!} = \\frac{1}{2}$。\n\n1.  **$\\mathcal{A}$ 的非零元素**\n\n我们根据两条超边来确定非零元素。\n对于超边 $\\{1,2,3\\}$：\n这些索引是不同的，因此对于 $(1,2,3)$ 的任何置换 $(\\sigma_1, \\sigma_2, \\sigma_3)$，元素 $\\mathcal{A}_{\\sigma_1 \\sigma_2 \\sigma_3}$ 都是非零的。共有 $3! = 6$ 个这样的置换。\n对应于这条超边的非零元素是：\n$\\mathcal{A}_{123} = \\mathcal{A}_{132} = \\mathcal{A}_{213} = \\mathcal{A}_{231} = \\mathcal{A}_{312} = \\mathcal{A}_{321} = \\frac{1}{2}$。\n\n对于超边 $\\{2,3,4\\}$：\n同样，这些索引是不同的。对于 $(2,3,4)$ 的任何置换 $(\\sigma_1, \\sigma_2, \\sigma_3)$，元素 $\\mathcal{A}_{\\sigma_1 \\sigma_2 \\sigma_3}$ 都是非零的。共有 $3! = 6$ 个这样的置换。\n对应于这条超边的非零元素是：\n$\\mathcal{A}_{234} = \\mathcal{A}_{243} = \\mathcal{A}_{324} = \\mathcal{A}_{342} = \\mathcal{A}_{423} = \\mathcal{A}_{432} = \\frac{1}{2}$。\n\n张量 $\\mathcal{A}$ 的所有其他元素均为 $0$。这完成了任务的第一部分。\n\n2.  **标量缩并**\n\n我们需要计算表达式 $S = x^{\\top}\\mathcal{A}x^{2} = \\sum_{i=1}^{4}\\sum_{j=1}^{4}\\sum_{k=1}^{4}\\mathcal{A}_{ijk}\\,x_i x_j x_k$。\n该和包含 $4^3 = 64$ 个项。然而，我们只需要对上面确定的 $\\mathcal{A}_{ijk}$ 非零的项求和。这个和可以分解为来自每条超边的贡献。\n\n来自超边 $\\{1,2,3\\}$ 的贡献：\n这部分贡献是索引 $(1,2,3)$ 所有置换的和。\n$$\n\\sum_{\\sigma \\in S_3} \\mathcal{A}_{\\sigma(1)\\sigma(2)\\sigma(3)} x_{\\sigma(1)}x_{\\sigma(2)}x_{\\sigma(3)}\n$$\n这个和中的项是：\n$\\mathcal{A}_{123}x_1x_2x_3 + \\mathcal{A}_{132}x_1x_3x_2 + \\mathcal{A}_{213}x_2x_1x_3 + \\mathcal{A}_{231}x_2x_3x_1 + \\mathcal{A}_{312}x_3x_1x_2 + \\mathcal{A}_{321}x_3x_2x_1$。\n由于所有这些 $\\mathcal{A}$ 元素都等于 $\\frac{1}{2}$，并且在每种情况下变量的乘积都简化为 $x_1x_2x_3$，所以和是：\n$6 \\times \\left(\\frac{1}{2} x_1x_2x_3\\right) = 3x_1x_2x_3$。\n\n来自超边 $\\{2,3,4\\}$ 的贡献：\n这部分贡献是索引 $(2,3,4)$ 所有置换的和。\n$$\n\\sum_{\\sigma \\in S_3} \\mathcal{A}_{\\sigma(2)\\sigma(3)\\sigma(4)} x_{\\sigma(2)}x_{\\sigma(3)}x_{\\sigma(4)}\n$$\n这个和中的项是：\n$\\mathcal{A}_{234}x_2x_3x_4 + \\mathcal{A}_{243}x_2x_4x_3 + \\mathcal{A}_{324}x_3x_2x_4 + \\mathcal{A}_{342}x_3x_4x_2 + \\mathcal{A}_{423}x_4x_2x_3 + \\mathcal{A}_{432}x_4x_3x_2$。\n同样，所有这些 $\\mathcal{A}$ 元素都等于 $\\frac{1}{2}$，并且变量的乘积简化为 $x_2x_3x_4$。所以和是：\n$6 \\times \\left(\\frac{1}{2} x_2x_3x_4\\right) = 3x_2x_3x_4$。\n\n总和 $S$ 是所有超边贡献的和：\n$S = 3x_1x_2x_3 + 3x_2x_3x_4$。\n\n为了以简化形式提供答案，我们可以提取公因式 $3x_2x_3$：\n$S = 3x_2x_3(x_1 + x_4)$。\n\n这表示标量缩并的最终简化解析表达式。",
            "answer": "$$\\boxed{3x_2x_3(x_1 + x_4)}$$"
        },
        {
            "introduction": "最后的这项练习旨在阐明研究超图的核心动机：它们能够捕捉到成对模型所忽略的协同效应。通过构建一个反例，其中简单的图模型未能预测出超图模型所捕捉到的级联现象，您将直接证明网络简化的局限性 。这个练习突显了为何显式地为群体互动建模对于理解复杂系统至关重要。",
            "id": "4126352",
            "problem": "考虑在高阶网络和超图的背景下的以下构造问题。令 $\\mathcal{H} = (V, E)$ 是一个 $3$-一致超图，其节点集为 $V$，超边集为 $E$。它的成对投影是一个简单图 $G = (V, \\mathcal{E})$，通过将每个超边 $e \\in E$ 替换为其成员节点之间的所有成对边来获得，也就是说，如果 $e = \\{u,v,w\\}$，那么 $\\{u,v\\}, \\{v,w\\}, \\{u,w\\} \\in \\mathcal{E}$。考虑从一个初始种子集 $S_0 \\subseteq V$ 开始的两种同步、离散时间的采纳动态过程：\n- 图 $G$ 上的线性阈值模型 (LTM)，其中一个未激活节点 $x$ 在时间 $t+1$ 变为激活状态，当且仅当它在图 $G$ 中的邻居中至少有 $m$ 个在时间 $t$ 是激活的，其中 $m \\in \\mathbb{N}$ 是一个整数阈值。\n- 超图 $\\mathcal{H}$ 上具有三元协同效应的高阶级联模型 (HCM)，其中一个未激活节点 $x$ 在时间 $t+1$ 变为激活状态，当且仅当存在某个包含 $x$ 的超边 $e \\in E$，使得 $e$ 中至少有 $s$ 个其他成员在时间 $t$ 是激活的，其中 $s \\in \\{1,2\\}$ 是三元协同效应阈值（因为对于任何节点，每个 3-一致超边都恰好有 2 个共同成员）。\n\n你需要构造并分析一个反例族，其中成对投影 $G$ 在 LTM 下预测没有级联，但超图 $\\mathcal{H}$ 上的高阶 HCM 在三元协同效应的驱动下表现出全局级联。为此，使用如下定义的共享边的三角形链式超图。对于任意整数长度 $L \\ge 0$，定义大小为 $|V| = L+2$ 的节点集 $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$，并定义超边集 $E = \\{e_i : i = 0,1,\\dots,L-1\\}$，其中 $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$。因此，连续的超边共享边 $\\{v_{i+1}, v_{i+2}\\}$。初始种子集为 $S_0 = \\{v_0, v_1\\}$。\n\n从上面给出的超图投影、线性阈值模型 (LTM) 和高阶三元协同效应 HCM 的核心定义出发（不使用任何其他快捷公式），完成以下任务：\n\n1. 通过根据给定的定义进行推理，证明对于任何 $L \\ge 1$，在成对投影 $G$ 上，阈值为 $m = 3$ 且种子集为 $S_0 = \\{v_0, v_1\\}$ 的 LTM 不会激活除 $S_0$ 之外的任何额外节点。请精确解释为什么在这种构造下，没有未激活节点满足 LTM 的激活条件。\n\n2. 通过根据给定的定义进行推理，证明对于任何 $L \\ge 1$，在超图 $\\mathcal{H}$ 上，三元协同效应阈值为 $s = 2$ 且种子集为 $S_0 = \\{v_0, v_1\\}$ 的 HCM 会激活所有节点，即表现出全局级联。请沿着共享边的三角形链提供一个清晰的归纳论证，说明每个后续的非种子节点是如何变为激活状态的。\n\n3. 将定量级联差距 $g(L,m,s)$ 定义为 HCM 和 LTM 在相同构造下的最终激活集大小之差：\n$$\ng(L,m,s) \\triangleq |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|,\n$$\n其中 $\\mathcal{A}_{\\mathrm{HCM}}(L,s)$ 和 $\\mathcal{A}_{\\mathrm{LTM}}(L,m)$ 分别表示从 $S_0$ 开始的各自最终（不动点）激活集。通过仅应用模型定义和你在步骤 1 和 2 中的推理，为下面提供的测试套件案例推导 $g(L,m,s)$。\n\n4. 实现一个程序，该程序为任意 $L$ 构造超图及其成对投影，使用上述定义从 $S_0$ 开始模拟两种动态过程直到达到不动点，并为下面列出的每个测试案例输出级联差距 $g(L,m,s)$。你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3]$）。每个 $r_i$ 必须是整数。不涉及物理单位或角度，也不期望百分比。\n\n测试套件（每个案例为 $(L,m,s)$）：\n- 案例 1：$(L,m,s) = (5,3,2)$。\n- 案例 2：$(L,m,s) = (5,2,2)$。\n- 案例 3：$(L,m,s) = (1,3,2)$。\n- 案例 4：$(L,m,s) = (0,3,2)$。\n- 案例 5：$(L,m,s) = (7,3,1)$。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，并按上述案例的顺序排列（例如，$[r_1,r_2,r_3,r_4,r_5]$）。",
            "solution": "该问题提出了一个在复杂系统建模领域的有效研究问题，比较了超图上的传染动态过程与其成对投影上的动态过程。所有定义在数学上都是精确的，并且所提出的构造是良定义的，这使得该问题具有科学依据、良态且客观。因此，我们可以进行形式化解法。\n\n解法按要求分为三部分：首先，分析成对投影上的线性阈值模型 (LTM)；其次，分析超图上的高阶级联模型 (HCM)；第三，为指定的测试案例推导级联差距 $g(L,m,s)$。\n\n让我们首先确定超图 $\\mathcal{H} = (V, E)$ 及其投影图 $G = (V, \\mathcal{E})$ 的结构。\n节点集为 $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$，大小为 $|V| = L+2$。\n超边集为 $E = \\{e_i : i = 0, \\dots, L-1\\}$，其中 $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$。\n投影图 $G$ 的边集 $\\mathcal{E}$ 是通过取每个超边中所有成对边的并集形成的。对于每个 $e_i \\in E$，我们将边 $\\{v_i, v_{i+1}\\}$、$\\{v_i, v_{i+2}\\}$ 和 $\\{v_{i+1}, v_{i+2}\\}$ 添加到 $\\mathcal{E}$ 中。两种动态过程的初始激活节点集均为 $S_0 = \\{v_0, v_1\\}$。\n\n**1. 线性阈值模型 (LTM) 分析**\n\n我们需要证明对于任何 $L \\ge 1$ 和阈值 $m=3$，从 $S_0$ 开始的 LTM 级联不会激活任何额外的节点。\n\nLTM 激活一个未激活节点 $x$ 的条件是，其在图 $G$ 中的激活邻居数量，表示为 $|N_G(x) \\cap S_t|$，至少为 $m$。在时间 $t=0$ 时，激活集为 $S_0 = \\{v_0, v_1\\}$。我们必须检查是否有任何未激活节点 $v_k \\in V \\setminus S_0$ (其中 $k \\ge 2$) 能够被激活。\n\n- **节点 $v_2$ 的情况**：节点 $v_2$ 存在于超边 $e_0 = \\{v_0, v_1, v_2\\}$ 中。该超边的投影创建了一个三角形，使得 $v_0$ 和 $v_1$ 成为 $v_2$ 在图 $G$ 中的邻居。对于 $L \\ge 1$，这是唯一同时包含 $v_2$ 和来自 $S_0$ 的任何节点的超边。具体来说，$e_1 = \\{v_1, v_2, v_3\\}$ (如果 $L \\ge 2$) 也会使 $v_1$ 成为 $v_2$ 的邻居，但这并非新的邻居。没有其他超边可以连接 $v_2$ 到 $v_0$ 或 $v_1$。因此，在 $S_0$ 中 $v_2$ 的邻居恰好是 $\\{v_0, v_1\\}$。在 $t=0$ 时，$v_2$ 的激活邻居数量为 $|N_G(v_2) \\cap S_0| = |\\{v_0, v_1\\}| = 2$。当阈值为 $m=3$ 时，激活条件未被满足 ($2  3$)。因此，$v_2$ 不会变为激活状态。\n\n- **节点 $v_k$ (其中 $k \\ge 3$) 的情况**：仅当存在一个超边 $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$ 同时包含 $v_j$ 和 $v_k$ 时，图 $G$ 中才存在边 $\\{v_j, v_k\\}$。对于 $v_k$ (其中 $k \\ge 3$)，要使其有一个来自 $S_0=\\{v_0, v_1\\}$ 的邻居，必须存在某个超边 $e_i$ 包含 $\\{v_k, v_0\\}$ 或 $\\{v_k, v_1\\}$。任何超边 $e_i$ 中节点的索引为 $i, i+1, i+2$。要使 $e_i$ 包含 $v_0$ 或 $v_1$，其组成索引必须包含 $0$ 或 $1$。这仅对 $e_0 = \\{v_0, v_1, v_2\\}$ 成立。然而，$e_0$ 不包含任何索引 $k \\ge 3$ 的节点 $v_k$。因此，对于任何 $k \\ge 3$，其邻域 $N_G(v_k)$ 不包含 $v_0$ 或 $v_1$。由此可知 $|N_G(v_k) \\cap S_0| = 0$。在阈值 $m=3$ 的情况下，这些节点无法激活。\n\n由于在 $t=0$ 时没有未激活节点满足激活阈值，所以在 $t=1$ 时的激活集保持不变，即 $S_1 = S_0$。系统已达到一个不动点。最终激活集为 $\\mathcal{A}_{\\mathrm{LTM}}(L,3) = S_0 = \\{v_0, v_1\\}$，其大小为 $|\\mathcal{A}_{\\mathrm{LTM}}(L,3)| = 2$ (对于任何 $L \\ge 1$)。\n\n**2. 高阶级联模型 (HCM) 分析**\n\n我们需要证明对于任何 $L \\ge 1$ 和三元协同效应阈值 $s=2$，从 $S_0$ 开始的 HCM 级联会激活 $V$ 中的所有节点。\n\nHCM 激活一个未激活节点 $x$ 的条件是，存在一个包含 $x$ 的超边 $e \\in E$，使得 $e$ 中至少有 $s$ 个其他成员是激活的。对于一个 3-一致超边 $e=\\{x,y,z\\}$ 和 $s=2$，如果 $y$ 和 $z$ 都被激活，节点 $x$ 就会被激活。我们通过对节点索引进行归纳来证明全局级联。\n\n- **基础情况**：在 $t=0$ 时，$S_0 = \\{v_0, v_1\\}$。我们检查下一个时间步 $t=1$ 时未激活节点 $v_2$ 的状态。节点 $v_2$ 是超边 $e_0 = \\{v_0, v_1, v_2\\}$ 的成员。$e_0$ 的其他成员是 $\\{v_0, v_1\\}$。这两个节点都在 $S_0$ 中，因此是激活的。激活的共同成员数量为 2。由于这满足阈值 $s=2$，节点 $v_2$ 在 $t=1$ 时变为激活状态。激活集增长为 $S_1 = S_0 \\cup \\{v_2\\} = \\{v_0, v_1, v_2\\}$。\n\n- **归纳步骤**：假设在时间步 $t=k-1$ 时，所有直到 $v_{k+1}$ 的节点都是激活的，即对于 $k \\ge 1$，$S_{k-1} = \\{v_0, v_1, \\dots, v_{k+1}\\}$。我们将证明节点 $v_{k+2}$ 在时间步 $t=k$ 时变为激活状态。考虑未激活节点 $v_{k+2}$。它是超边 $e_k = \\{v_k, v_{k+1}, v_{k+2}\\}$ 的成员。该超边的其他成员是 $\\{v_k, v_{k+1}\\}$。根据归纳假设，$v_k$ 和 $v_{k+1}$ 都在激活集 $S_{k-1}$ 中。因此，$v_{k+2}$ 在 $e_k$ 中有 2 个激活的共同成员。由于 $s=2$，激活条件得到满足，$v_{k+2}$ 在时间 $t=k$ 时变为激活状态。同时，任何索引 $j > k+2$ 的节点 $v_j$ 都无法激活，因为根据假设，任何包含 $v_j$ 的超边的成员索引都接近 $j$，这些节点尚未激活。\n\n通过归纳法，激活沿着链顺序传播：$v_2$ 在 $t=1$ 时激活，$v_3$ 在 $t=2$ 时激活，依此类推，直到最后一个节点 $v_{L+1}$ 在 $t=L$ 时激活。当 $V$ 中的所有节点都激活时，该过程终止。最终激活集为 $\\mathcal{A}_{\\mathrm{HCM}}(L,2) = V$，其大小为 $|\\mathcal{A}_{\\mathrm{HCM}}(L,2)| = L+2$ (对于任何 $L \\ge 1$)。\n\n**3. 级联差距 $g(L,m,s)$ 的推导**\n\n级联差距定义为 $g(L,m,s) = |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|$。我们现在为每个测试案例计算这个值。\n\n- **案例 1: $(L,m,s) = (5,3,2)$**\n    根据第 1 部分，当 $m=3$ 时，LTM 级联停止。$|\\mathcal{A}_{\\mathrm{LTM}}(5,3)| = 2$。\n    根据第 2 部分，当 $s=2$ 时，HCM 级联是全局的。$|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = L+2 = 5+2 = 7$。\n    $g(5,3,2) = 7 - 2 = 5$。\n\n- **案例 2: $(L,m,s) = (5,2,2)$**\n    对于 LTM，$m=2$：在 $t=0$ 时，$S_0=\\{v_0,v_1\\}$。节点 $v_2$ 有 2 个激活邻居 ($v_0, v_1$)，满足阈值 $m=2$。$v_2$ 激活，所以 $S_1=\\{v_0,v_1,v_2\\}$。在 $t=1$ 时，节点 $v_3$ (邻居为 $\\{v_1,v_2,v_4\\}$) 有 2 个激活邻居 ($v_1,v_2$) 。$v_3$ 激活。这个过程继续下去，每个 $v_k$ 都被其前驱节点 $v_{k-2}$ 和 $v_{k-1}$ 激活，导致全局级联。$|\\mathcal{A}_{\\mathrm{LTM}}(5,2)| = L+2 = 7$。\n    对于 HCM，$s=2$，级联是全局的。$|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = 7$。\n    $g(5,2,2) = 7 - 7 = 0$。\n\n- **案例 3: $(L,m,s) = (1,3,2)$**\n    对于 $L=1$，$V=\\{v_0,v_1,v_2\\}$ 且 $E=\\{e_0\\}=\\{v_0,v_1,v_2\\}$。\n    对于 LTM，$m=3$：图 $G$ 是一个 3-团。节点 $v_2$ 有 2 个来自 $S_0$ 的激活邻居。由于 $2  3$，它不激活。$|\\mathcal{A}_{\\mathrm{LTM}}(1,3)| = 2$。\n    对于 HCM，$s=2$：在 $e_0$ 中的节点 $v_2$ 有 2 个来自 $S_0$ 的激活共同成员。它被激活。$|\\mathcal{A}_{\\mathrm{HCM}}(1,2)| = 3$。\n    $g(1,3,2) = 3 - 2 = 1$。\n\n- **案例 4: $(L,m,s) = (0,3,2)$**\n    对于 $L=0$，$V=\\{v_0,v_1\\}$ 且 $E=\\emptyset$。初始集 $S_0=V$ 包含所有节点。两种动态过程都以所有节点激活的状态开始和结束。\n    $|\\mathcal{A}_{\\mathrm{LTM}}(0,3)| = 2$ 且 $|\\mathcal{A}_{\\mathrm{HCM}}(0,2)| = 2$。\n    $g(0,3,2) = 2 - 2 = 0$。\n\n- **案例 5: $(L,m,s) = (7,3,1)$**\n    对于 LTM，$m=3$：级联停止。$|\\mathcal{A}_{\\mathrm{LTM}}(7,3)| = 2$。\n    对于 HCM，$s=1$：一个未激活节点只需要一个超边中有一个激活的共同成员即可激活。\n    在 $t=0$ 时，$S_0=\\{v_0,v_1\\}$：\n    节点 $v_2$ (在 $e_0=\\{v_0,v_1,v_2\\}$ 中) 看到 2 个激活的共同成员 ($\\{v_0,v_1\\}$)。$2 \\ge 1$，所以 $v_2$ 激活。\n    节点 $v_3$ (在 $e_1=\\{v_1,v_2,v_3\\}$ 中) 看到 1 个激活的共同成员 ($v_1$) 。$1 \\ge 1$，所以 $v_3$ 激活。\n    在下一步，$S_1=\\{v_0,v_1,v_2,v_3\\}$，这接着会允许 $v_4$ 和 $v_5$ 激活，等等。级联是全局的。$|\\mathcal{A}_{\\mathrm{HCM}}(7,1)| = L+2 = 7+2 = 9$。\n    $g(7,3,1) = 9 - 2 = 7$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cascade gap problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # (L, m, s)\n        (5, 3, 2),\n        (5, 2, 2),\n        (1, 3, 2),\n        (0, 3, 2),\n        (7, 3, 1),\n    ]\n\n    def calculate_gap(L, m, s):\n        \"\"\"\n        Calculates the cascade gap for a given (L, m, s) configuration.\n        \"\"\"\n        num_nodes = L + 2\n        nodes = set(range(num_nodes))\n        \n        # Handle L=0 case: no hyperedges, S0 is the whole set\n        if L == 0: # Technically problem states L>=0, but as a guard\n            return 0\n        \n        hyperedges = []\n        if L >= 1:\n            for i in range(L):\n                hyperedges.append(frozenset({i, i + 1, i + 2}))\n\n        # --- LTM Simulation ---\n        active_ltm = {0, 1}\n        \n        # Build pairwise projection graph G if there are hyperedges\n        adj = {i: set() for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                u, v, w = he\n                adj[u].add(v)\n                adj[v].add(u)\n                adj[u].add(w)\n                adj[w].add(u)\n                adj[v].add(w)\n                adj[w].add(v)\n        \n        while True:\n            newly_activated_ltm = set()\n            inactive_nodes = nodes - active_ltm\n            if not inactive_nodes:\n                break\n                \n            for node in inactive_nodes:\n                active_neighbors_count = len(adj[node].intersection(active_ltm))\n                if active_neighbors_count >= m:\n                    newly_activated_ltm.add(node)\n            \n            if not newly_activated_ltm:\n                break\n            \n            active_ltm.update(newly_activated_ltm)\n        \n        final_size_ltm = len(active_ltm)\n\n        # --- HCM Simulation ---\n        active_hcm = {0, 1}\n        \n        # Pre-build a map from node to its containing hyperedges for efficiency\n        node_to_hyperedges = {i: [] for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                for node in he:\n                    node_to_hyperedges[node].append(he)\n            \n        while True:\n            newly_activated_hcm = set()\n            inactive_nodes = nodes - active_hcm\n            if not inactive_nodes:\n                break\n\n            for node in inactive_nodes:\n                is_activated = False\n                for he in node_to_hyperedges[node]:\n                    co_members = he - {node}\n                    active_co_members_count = len(co_members.intersection(active_hcm))\n                    if active_co_members_count >= s:\n                        is_activated = True\n                        break # Found an activating hyperedge\n                \n                if is_activated:\n                    newly_activated_hcm.add(node)\n\n            if not newly_activated_hcm:\n                break\n            \n            active_hcm.update(newly_activated_hcm)\n            \n        final_size_hcm = len(active_hcm)\n\n        return final_size_hcm - final_size_ltm\n\n    results = []\n    for L, m, s in test_cases:\n        gap = calculate_gap(L, m, s)\n        results.append(gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}