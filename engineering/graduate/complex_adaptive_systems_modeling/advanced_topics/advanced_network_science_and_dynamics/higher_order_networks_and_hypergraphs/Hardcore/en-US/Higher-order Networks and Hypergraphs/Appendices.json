{
    "hands_on_practices": [
        {
            "introduction": "A primary motivation for using higher-order networks is their ability to model synergistic group interactions that are fundamentally irreducible to pairwise connections. This practice provides a direct and compelling demonstration of the limitations of traditional graph models. By constructing a scenario where a linear threshold model on a pairwise projection predicts no contagion, while a higher-order model reveals a global cascade, you will quantify the 'cascade gap' that arises from ignoring triadic synergy .",
            "id": "4126352",
            "problem": "Consider the following construction problem in the setting of higher-order networks and hypergraphs. Let $\\mathcal{H} = (V, E)$ be a $3$-uniform hypergraph with node set $V$ and hyperedge set $E$. Its pairwise projection is the simple graph $G = (V, \\mathcal{E})$ obtained by replacing each hyperedge $e \\in E$ with all pairwise edges among its member nodes, that is, if $e = \\{u,v,w\\}$, then $\\{u,v\\}, \\{v,w\\}, \\{u,w\\} \\in \\mathcal{E}$. Consider two synchronous, discrete-time adoption dynamics starting from an initial seed set $S_0 \\subseteq V$: \n- The Linear Threshold Model (LTM) on $G$, where an inactive node $x$ becomes active at time $t+1$ if and only if at least $m$ of its neighbors in $G$ are active at time $t$, with $m \\in \\mathbb{N}$ an integer threshold.\n- A Higher-Order Cascade Model (HCM) on $\\mathcal{H}$ with triadic synergy, where an inactive node $x$ becomes active at time $t+1$ if and only if there exists some hyperedge $e \\in E$ containing $x$ for which at least $s$ of the other members of $e$ are active at time $t$, with $s \\in \\{1,2\\}$ the triadic synergy threshold (since each $3$-uniform hyperedge has exactly $2$ co-members for any node).\n\nYou are to construct and analyze a counterexample family where the pairwise projection $G$ predicts no cascade under LTM, but the higher-order HCM on $\\mathcal{H}$ exhibits a global cascade driven by triadic synergy. To do so, use the edge-sharing triangle chain hypergraph defined as follows. For any integer length $L \\ge 0$, define $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$ of size $|V| = L+2$, and define the hyperedge set $E = \\{e_i : i = 0,1,\\dots,L-1\\}$ where $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$. Thus, consecutive hyperedges share the edge $\\{v_{i+1}, v_{i+2}\\}$. The initial seed set is $S_0 = \\{v_0, v_1\\}$.\n\nStarting from the core definitions of hypergraph projection, the Linear Threshold Model (LTM), and higher-order triadic synergy HCM given above (and no other shortcut formulas), do the following:\n\n1. Prove, by reasoning from the given definitions, that for any $L \\ge 1$, the LTM on the pairwise projection $G$ with threshold $m = 3$ and seed set $S_0 = \\{v_0, v_1\\}$ does not activate any additional nodes beyond $S_0$. Explain precisely why no inactive node meets the activation condition under LTM in this construction.\n\n2. Prove, by reasoning from the given definitions, that for any $L \\ge 1$, the HCM on the hypergraph $\\mathcal{H}$ with triadic synergy threshold $s = 2$ and seed set $S_0 = \\{v_0, v_1\\}$ activates all nodes, that is, exhibits a global cascade. Provide a clear inductive argument along the chain of edge-sharing triangles showing that each successive non-seed node becomes active.\n\n3. Define the quantitative cascade gap $g(L,m,s)$ as the difference in final active set sizes between the HCM and the LTM on the same construction: \n$$\ng(L,m,s) \\triangleq |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|,\n$$\nwhere $\\mathcal{A}_{\\mathrm{HCM}}(L,s)$ and $\\mathcal{A}_{\\mathrm{LTM}}(L,m)$ denote the respective final (fixed-point) active sets starting from $S_0$. Derive $g(L,m,s)$ for the provided test suite cases below, by applying only the model definitions and your reasoning from steps $1$ and $2$.\n\n4. Implement a program that constructs the hypergraph and its pairwise projection for arbitrary $L$, simulates both dynamics from $S_0$ until the fixed point using the definitions above, and outputs the cascade gap $g(L,m,s)$ for each test case listed below. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$). Each $r_i$ must be an integer. No physical units or angles are involved, and no percentages are expected.\n\nTest suite (each case is $(L,m,s)$):\n- Case $1$: $(L,m,s) = (5,3,2)$.\n- Case $2$: $(L,m,s) = (5,2,2)$.\n- Case $3$: $(L,m,s) = (1,3,2)$.\n- Case $4$: $(L,m,s) = (0,3,2)$.\n- Case $5$: $(L,m,s) = (7,3,1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the cases above (for example, $[r_1,r_2,r_3,r_4,r_5]$).",
            "solution": "The problem presents a valid research question in the modeling of complex systems, comparing contagion dynamics on a hypergraph with dynamics on its pairwise projection. All definitions are mathematically precise, and the proposed construction is well-defined, making the problem scientifically grounded, well-posed, and objective. We can therefore proceed with a formal solution.\n\nThe solution is structured into three parts as requested: first, an analysis of the Linear Threshold Model (LTM) on the pairwise projection; second, an analysis of the Higher-Order Cascade Model (HCM) on the hypergraph; and third, the derivation of the cascade gap $g(L,m,s)$ for the specified test cases.\n\nLet us first establish the structure of the hypergraph $\\mathcal{H} = (V, E)$ and its projection $G = (V, \\mathcal{E})$.\nThe node set is $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$, with $|V| = L+2$.\nThe hyperedge set is $E = \\{e_i : i = 0, \\dots, L-1\\}$, where $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$.\nThe edge set $\\mathcal{E}$ of the projection graph $G$ is formed by taking the union of all pairwise edges from each hyperedge. For each $e_i \\in E$, we add the edges $\\{v_i, v_{i+1}\\}$, $\\{v_i, v_{i+2}\\}$, and $\\{v_{i+1}, v_{i+2}\\}$ to $\\mathcal{E}$. The initial set of active nodes for both dynamics is $S_0 = \\{v_0, v_1\\}$.\n\n**1. Analysis of the Linear Threshold Model (LTM)**\n\nWe are asked to prove that for any $L \\ge 1$ and threshold $m=3$, the LTM cascade starting from $S_0$ does not activate any additional nodes.\n\nThe LTM activates an inactive node $x$ if the number of its active neighbors in $G$, denoted $|N_G(x) \\cap S_t|$, is at least $m$. At time $t=0$, the active set is $S_0 = \\{v_0, v_1\\}$. We must check if any inactive node $v_k \\in V \\setminus S_0$ (where $k \\ge 2$) can be activated.\n\n- **Case for node $v_2$**: The node $v_2$ is present in the hyperedge $e_0 = \\{v_0, v_1, v_2\\}$. The projection of this hyperedge creates a triangle, making $v_0$ and $v_1$ neighbors of $v_2$ in $G$. For $L \\ge 1$, this is the only hyperedge that contains both $v_2$ and any node from $S_0$. Specifically, $e_1 = \\{v_1, v_2, v_3\\}$ (if $L \\ge 2$) also gives $v_1$ as a neighbor of $v_2$, but this is not a new neighbor. No other hyperedge can connect $v_2$ to $v_0$ or $v_1$. Thus, the neighbors of $v_2$ that are in $S_0$ are precisely $\\{v_0, v_1\\}$. The number of active neighbors for $v_2$ at $t=0$ is $|N_G(v_2) \\cap S_0| = |\\{v_0, v_1\\}| = 2$. With a threshold of $m=3$, the condition for activation is not met ($2 < 3$). Therefore, $v_2$ does not become active.\n\n- **Case for nodes $v_k$ where $k \\ge 3$**: An edge $\\{v_j, v_k\\}$ exists in $G$ only if there is a hyperedge $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$ that contains both $v_j$ and $v_k$. For $v_k$ (with $k \\ge 3$) to have a neighbor from $S_0=\\{v_0, v_1\\}$, there must be some hyperedge $e_i$ containing $\\{v_k, v_0\\}$ or $\\{v_k, v_1\\}$. The indices of nodes in any hyperedge $e_i$ are $i, i+1, i+2$. For $e_i$ to contain $v_0$ or $v_1$, its constituent indices must include $0$ or $1$. This occurs only for $e_0 = \\{v_0, v_1, v_2\\}$. However, $e_0$ does not contain any node $v_k$ with $k \\ge 3$. Therefore, for any $k \\ge 3$, the neighborhood $N_G(v_k)$ does not contain $v_0$ or $v_1$. It follows that $|N_G(v_k) \\cap S_0| = 0$. With a threshold $m=3$, these nodes cannot activate.\n\nSince no inactive node meets the activation threshold at $t=0$, the set of active nodes at $t=1$ is unchanged, i.e., $S_1 = S_0$. The system has reached a fixed point. The final active set is $\\mathcal{A}_{\\mathrm{LTM}}(L,3) = S_0 = \\{v_0, v_1\\}$, and its size is $|\\mathcal{A}_{\\mathrm{LTM}}(L,3)| = 2$ for any $L \\ge 1$.\n\n**2. Analysis of the Higher-Order Cascade Model (HCM)**\n\nWe are asked to prove that for any $L \\ge 1$ and triadic synergy threshold $s=2$, the HCM cascade starting from $S_0$ activates all nodes in $V$.\n\nThe HCM activates an inactive node $x$ if there exists a hyperedge $e \\in E$ containing $x$ such that at least $s$ of the other members of $e$ are active. For a $3$-uniform hyperedge $e=\\{x,y,z\\}$ and $s=2$, node $x$ activates if both $y$ and $z$ are active. We prove the global cascade by induction on the node index.\n\n- **Base Case**: At $t=0$, $S_0 = \\{v_0, v_1\\}$. We check the status of inactive node $v_2$ at the next time step, $t=1$. Node $v_2$ is a member of hyperedge $e_0 = \\{v_0, v_1, v_2\\}$. The other members of $e_0$ are $\\{v_0, v_1\\}$. Both of these nodes are in $S_0$ and are therefore active. The count of active co-members is $2$. Since this meets the threshold $s=2$, node $v_2$ becomes active at $t=1$. The active set grows to $S_1 = S_0 \\cup \\{v_2\\} = \\{v_0, v_1, v_2\\}$.\n\n- **Inductive Step**: Assume that at time step $t=k-1$, all nodes up to $v_{k+1}$ are active, i.e., $S_{k-1} = \\{v_0, v_1, \\dots, v_{k+1}\\}$ for $k \\ge 1$. We will show that node $v_{k+2}$ becomes active at time step $t=k$.\nConsider the inactive node $v_{k+2}$. It is a member of the hyperedge $e_k = \\{v_k, v_{k+1}, v_{k+2}\\}$. The other members of this hyperedge are $\\{v_k, v_{k+1}\\}$. By the inductive hypothesis, both $v_k$ and $v_{k+1}$ are in the active set $S_{k-1}$. Thus, $v_{k+2}$ has $2$ active co-members in $e_k$. Since $s=2$, the condition for activation is met, and $v_{k+2}$ becomes active at time $t=k$.\nSimultaneously, no node $v_j$ with $j > k+2$ can activate, as any hyperedge containing $v_j$ has members with indices close to $j$, which are not yet active by the hypothesis.\n\nBy induction, the activation propagates sequentially along the chain: $v_2$ activates at $t=1$, $v_3$ activates at $t=2$, and so on, until the final node $v_{L+1}$ activates at $t=L$. The process terminates when all nodes in $V$ are active. The final active set is $\\mathcal{A}_{\\mathrm{HCM}}(L,2) = V$, and its size is $|\\mathcal{A}_{\\mathrm{HCM}}(L,2)| = L+2$ for any $L \\ge 1$.\n\n**3. Derivation of the Cascade Gap $g(L,m,s)$**\n\nThe cascade gap is defined as $g(L,m,s) = |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|$. We now calculate this for each test case.\n\n- **Case 1: $(L,m,s) = (5,3,2)$**\n    From Part 1, with $m=3$, the LTM cascade stalls. $|\\mathcal{A}_{\\mathrm{LTM}}(5,3)| = 2$.\n    From Part 2, with $s=2$, the HCM cascade is global. $|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = L+2 = 5+2 = 7$.\n    $g(5,3,2) = 7 - 2 = 5$.\n\n- **Case 2: $(L,m,s) = (5,2,2)$**\n    For LTM with $m=2$: At $t=0$, $S_0=\\{v_0,v_1\\}$. Node $v_2$ has $2$ active neighbors ($v_0, v_1$), which meets the threshold $m=2$. $v_2$ activates, so $S_1=\\{v_0,v_1,v_2\\}$. At $t=1$, node $v_3$ (neighbors $\\{v_1,v_2,v_4\\}$) has $2$ active neighbors ($v_1,v_2$). $v_3$ activates. This continues, with each $v_k$ being activated by its predecessors $v_{k-2}$ and $v_{k-1}$, causing a global cascade. $|\\mathcal{A}_{\\mathrm{LTM}}(5,2)| = L+2 = 7$.\n    For HCM with $s=2$, the cascade is global. $|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = 7$.\n    $g(5,2,2) = 7 - 7 = 0$.\n\n- **Case 3: $(L,m,s) = (1,3,2)$**\n    For $L=1$, $V=\\{v_0,v_1,v_2\\}$ and $E=\\{e_0\\}=\\{v_0,v_1,v_2\\}$.\n    LTM with $m=3$: The graph $G$ is a $3$-clique. Node $v_2$ has $2$ active neighbors from $S_0$. Since $2 < 3$, it does not activate. $|\\mathcal{A}_{\\mathrm{LTM}}(1,3)| = 2$.\n    HCM with $s=2$: Node $v_2$ in $e_0$ has $2$ active co-members from $S_0$. It activates. $|\\mathcal{A}_{\\mathrm{HCM}}(1,2)| = 3$.\n    $g(1,3,2) = 3 - 2 = 1$.\n\n- **Case 4: $(L,m,s) = (0,3,2)$**\n    For $L=0$, $V=\\{v_0,v_1\\}$ and $E=\\emptyset$. The initial set $S_0=V$ contains all nodes. Both dynamics start and end at the same state with all nodes active.\n    $|\\mathcal{A}_{\\mathrm{LTM}}(0,3)| = 2$ and $|\\mathcal{A}_{\\mathrm{HCM}}(0,2)| = 2$.\n    $g(0,3,2) = 2 - 2 = 0$.\n\n- **Case 5: $(L,m,s) = (7,3,1)$**\n    LTM with $m=3$: Cascade stalls. $|\\mathcal{A}_{\\mathrm{LTM}}(7,3)| = 2$.\n    HCM with $s=1$: An inactive node needs only one active co-member in a hyperedge to activate.\n    At $t=0$ with $S_0=\\{v_0,v_1\\}$:\n    Node $v_2$ (in $e_0=\\{v_0,v_1,v_2\\}$) sees $2$ active co-members ($\\{v_0,v_1\\}$). $2 \\ge 1$, so $v_2$ activates.\n    Node $v_3$ (in $e_1=\\{v_1,v_2,v_3\\}$) sees $1$ active co-member ($v_1$). $1 \\ge 1$, so $v_3$ activates.\n    At the next step, $S_1=\\{v_0,v_1,v_2,v_3\\}$, which then allows $v_4$ and $v_5$ to activate, and so on. The cascade is global. $|\\mathcal{A}_{\\mathrm{HCM}}(7,1)| = L+2 = 7+2 = 9$.\n    $g(7,3,1) = 9 - 2 = 7$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cascade gap problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # (L, m, s)\n        (5, 3, 2),\n        (5, 2, 2),\n        (1, 3, 2),\n        (0, 3, 2),\n        (7, 3, 1),\n    ]\n\n    def calculate_gap(L, m, s):\n        \"\"\"\n        Calculates the cascade gap for a given (L, m, s) configuration.\n        \"\"\"\n        num_nodes = L + 2\n        nodes = set(range(num_nodes))\n        \n        # Handle L=0 case: no hyperedges, S0 is the whole set\n        if L < 0: # Technically problem states L>=0, but as a guard\n            return 0\n        \n        hyperedges = []\n        if L >= 1:\n            for i in range(L):\n                hyperedges.append(frozenset({i, i + 1, i + 2}))\n\n        # --- LTM Simulation ---\n        active_ltm = {0, 1}\n        \n        # Build pairwise projection graph G if there are hyperedges\n        adj = {i: set() for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                u, v, w = he\n                adj[u].add(v)\n                adj[v].add(u)\n                adj[u].add(w)\n                adj[w].add(u)\n                adj[v].add(w)\n                adj[w].add(v)\n        \n        while True:\n            newly_activated_ltm = set()\n            inactive_nodes = nodes - active_ltm\n            if not inactive_nodes:\n                break\n                \n            for node in inactive_nodes:\n                active_neighbors_count = len(adj[node].intersection(active_ltm))\n                if active_neighbors_count >= m:\n                    newly_activated_ltm.add(node)\n            \n            if not newly_activated_ltm:\n                break\n            \n            active_ltm.update(newly_activated_ltm)\n        \n        final_size_ltm = len(active_ltm)\n\n        # --- HCM Simulation ---\n        active_hcm = {0, 1}\n        \n        # Pre-build a map from node to its containing hyperedges for efficiency\n        node_to_hyperedges = {i: [] for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                for node in he:\n                    node_to_hyperedges[node].append(he)\n            \n        while True:\n            newly_activated_hcm = set()\n            inactive_nodes = nodes - active_hcm\n            if not inactive_nodes:\n                break\n\n            for node in inactive_nodes:\n                is_activated = False\n                for he in node_to_hyperedges[node]:\n                    co_members = he - {node}\n                    active_co_members_count = len(co_members.intersection(active_hcm))\n                    if active_co_members_count >= s:\n                        is_activated = True\n                        break # Found an activating hyperedge\n                \n                if is_activated:\n                    newly_activated_hcm.add(node)\n\n            if not newly_activated_hcm:\n                break\n            \n            active_hcm.update(newly_activated_hcm)\n            \n        final_size_hcm = len(active_hcm)\n\n        return final_size_hcm - final_size_ltm\n\n    results = []\n    for L, m, s in test_cases:\n        gap = calculate_gap(L, m, s)\n        results.append(gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Not all higher-order models are structurally equivalent. This exercise delves into the crucial distinction between a raw hypergraph and a simplicial complex, which is a hypergraph closed under the inclusion of subsets. You will simulate a contagion process on both structures to demonstrate how the presence or absence of lower-dimensional faces can create or block pathways for spreading, fundamentally altering the system's final state .",
            "id": "4126350",
            "problem": "You are asked to design and implement a contagion simulator for higher-order interactions on a finite set of vertices with simplex-level thresholds. The simulator must be able to compare the contagion outcomes on a given family of maximal simplices when treated as a raw hypergraph versus when enforced to be a simplicial complex via closure (that is, by adding all faces of every present simplex). The goal is to provide a clear example where adding missing faces to enforce closure changes the outcome of a contagion process with simplex-level thresholds, and to quantify the difference.\n\nFundamental base:\n- A hypergraph is defined by a set of vertices $V$ and a family of hyperedges (simplices) $E \\subseteq \\mathcal{P}(V)$, where each hyperedge is a subset of $V$ with cardinality at least $2$. A simplex of size $s$ has dimension $d=s-1$.\n- A simplicial complex is a family of simplices that is closed under taking faces, meaning if a simplex $\\sigma \\in E$ is present, then every non-empty face $\\tau \\subset \\sigma$ with $|\\tau| \\ge 2$ is also present.\n- A contagion process is defined on discrete time steps $t = 0, 1, 2, \\dots$, with a monotone activation rule: once a node is active it remains active.\n- Simplex-level thresholds: for each dimension $d \\in \\{1,2,3,\\dots\\}$, a threshold $t_d \\in \\mathbb{N}$ specifies the minimum number of active neighbors required within a single incident $d$-simplex to activate a node. A node $v$ becomes active at time $t+1$ if there exists at least one incident simplex $\\sigma$ of dimension $d$ containing $v$ such that the number of active nodes in $\\sigma \\setminus \\{v\\}$ at time $t$ is at least $t_d$. If a threshold $t_d$ is not specified for a dimension $d$ that occurs, treat it as $+\\infty$ so that contagion through dimension $d$ cannot occur.\n- A synchronous update rule is used: at each time step, all nodes that meet a threshold become active simultaneously.\n\nYour implementation must:\n- Accept a finite vertex set $V$ and a list of maximal simplices (each simplex given by its vertex set).\n- Simulate the contagion dynamics until a fixed point (no further activations) under two structural conditions:\n  1. Without closure: only the provided maximal simplices are available for contagion.\n  2. With closure: all faces of the provided maximal simplices are added, so contagion can occur through any face of any maximal simplex.\n- Use synchronous updates and monotone activation, starting from a specified initial active set $S_0 \\subseteq V$.\n\nTest suite and parameters:\n- For each test case, specify $V$, the list of maximal simplices, the initial active set $S_0$, and the thresholds $t_1, t_2, t_3$ where applicable. The thresholds are integers. Angles are not used, and there are no physical units involved.\n\nProvide the following test suite:\n- Test case $A$ (closure changes the outcome via triangle faces inside a tetrahedron):\n  - $V = \\{0, 1, 2, 3\\}$\n  - Maximal simplices: $\\{\\{0, 1, 2, 3\\}\\}$\n  - Initial active set: $S_0 = \\{0, 1\\}$\n  - Thresholds: $t_1 = 1$, $t_2 = 2$, $t_3 = 3$\n- Test case $B$ (closure changes the outcome by enabling edge-level contagion within triangles):\n  - $V = \\{0, 1, 2, 3, 4\\}$\n  - Maximal simplices: $\\{\\{0, 1, 2\\}, \\{2, 3, 4\\}\\}$\n  - Initial active set: $S_0 = \\{0\\}$\n  - Thresholds: $t_1 = 1$, $t_2 = 2$\n- Test case $C$ (boundary case where closure does not change the outcome):\n  - $V = \\{0, 1, 2, 3\\}$\n  - Maximal simplices: $\\{\\{0, 1, 2, 3\\}\\}$\n  - Initial active set: $S_0 = \\{0, 1, 2\\}$\n  - Thresholds: $t_1 = 3$, $t_2 = 3$, $t_3 = 2$\n\nOutput specification:\n- For each test case, compute three integers:\n  1. The final number of active nodes without closure.\n  2. The final number of active nodes with closure.\n  3. The difference (with closure minus without closure).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of three integers for a test case. For example, the output format must be exactly of the form $[[n_{A}^{\\text{no}}, n_{A}^{\\text{cl}}, \\Delta_{A}], [n_{B}^{\\text{no}}, n_{B}^{\\text{cl}}, \\Delta_{B}], [n_{C}^{\\text{no}}, n_{C}^{\\text{cl}}, \\Delta_{C}]]$, which is a nested list containing the triple for test case $A$, then test case $B$, then test case $C$.",
            "solution": "The problem requires the design and implementation of a contagion simulator on higher-order networks, specifically to compare the dynamics on a raw hypergraph versus its corresponding simplicial complex. The validation confirms that the problem is scientifically sound, well-posed, and provides all necessary information to proceed with a solution.\n\n### 1. Conceptual Framework\n\nThe simulation is built upon the concepts of hypergraphs, simplicial complexes, and a threshold-based contagion model.\n\nA **hypergraph** is a generalization of a graph where an edge, called a hyperedge, can connect any number of vertices. In this context, hyperedges are referred to as **simplices**. A hypergraph is defined by a pair $(V, E)$, where $V$ is a set of vertices and $E$ is a family of subsets of $V$, representing the simplices. A simplex $\\sigma$ of size $s = |\\sigma|$ is said to have dimension $d = s - 1$.\n\nA **simplicial complex** is a specific type of hypergraph that is closed under the operation of taking faces. A set $\\tau$ is a face of a simplex $\\sigma$ if $\\tau \\subset \\sigma$. For the purposes of this problem, the closure property is defined as: if a simplex $\\sigma$ is in the complex, then every non-empty face $\\tau$ of $\\sigma$ with cardinality $|\\tau| \\ge 2$ must also be in the complex. This means that if a triangle $\\{v_1, v_2, v_3\\}$ exists, its constituent edges $\\{v_1, v_2\\}$, $\\{v_1, v_3\\}$, and $\\{v_2, v_3\\}$ must also exist.\n\nThe **contagion process** unfolds in discrete time steps $t = 0, 1, 2, \\dots$ starting from an initial set of active nodes $S_0$. The activation rule is monotone, meaning a node, once active, remains active for all subsequent time steps. Activation is governed by **simplex-level thresholds**. For each dimension $d \\in \\{1, 2, 3, \\dots\\}$, a threshold $t_d \\in \\mathbb{N}$ is defined. A currently inactive node $v$ becomes active at time $t+1$ if there exists at least one simplex $\\sigma$ of dimension $d$ containing $v$ such that the number of active nodes in $\\sigma \\setminus \\{v\\}$ at time $t$ is at least $t_d$. Updates are **synchronous**: all nodes that meet the activation criteria at time $t$ become active simultaneously at $t+1$.\n\n### 2. Simulation Strategy\n\nThe core task is to run the simulation under two distinct structural conditions and compare the final number of active nodes.\n\n**Condition 1: Without Closure (Raw Hypergraph)**\nIn this scenario, the contagion can only spread through the specific list of maximal simplices provided in the problem statement. The underlying structure is treated as a simple hypergraph, which may not be a valid simplicial complex.\n\n**Condition 2: With Closure (Simplicial Complex)**\nIn this scenario, the structure is first transformed into a valid simplicial complex by a **closure** operation. This involves taking every maximal simplex provided and generating all of its faces $\\tau$ of size $|\\tau| \\ge 2$. The contagion can then spread through any simplex in this expanded set—the maximal ones and all their lower-dimensional faces. This expansion of available contagion pathways is hypothesized to alter the simulation's outcome.\n\nThe simulation in both cases proceeds until a fixed point is reached, i.e., when a time step passes with no new nodes becoming active. Since the vertex set $V$ is finite and the activation is monotone, a fixed point is guaranteed to be reached in a finite number of steps.\n\n### 3. Algorithmic Design\n\nThe implementation is divided into three main parts: data structure setup, the closure generation, and the simulation loop.\n\n**Data Structures:**\n- The vertex set $V$ is implicitly defined by its size, e.g., $V = \\{0, 1, \\dots, N-1\\}$.\n- Simplices are represented as `frozenset` objects in Python, which are hashable and can be stored in a set to ensure uniqueness.\n- The set of active nodes, $S_t$, is a `set` for efficient addition and membership testing.\n- The dimension-wise thresholds $\\{t_d\\}$ are stored in a dictionary mapping an integer dimension $d$ to its integer threshold $t_d$. If a threshold for a given dimension is not specified, it is treated as effectively infinite.\n\n**Closure Generation:**\nTo generate the simplicial complex from a list of maximal simplices, we iterate through each maximal simplex $\\sigma_{max}$. For each $\\sigma_{max}$ of size $s$, we generate all its subsets (faces) of sizes $k$ from $2$ to $s$. The `itertools.combinations` function from Python's standard library is ideally suited for this. All generated faces, along with the original maximal simplices, are collected into a single set to form the complete set of simplices for the \"with closure\" simulation.\n\n**Simulation Loop:**\nThe simulation is implemented as a function that takes the number of vertices, the set of simplices (either raw or with closure), the initial active set $S_0$, and the thresholds as input.\n1.  Initialize the active set with $S_0$.\n2.  Pre-process the simplex list into an adjacency structure, mapping each vertex $v$ to the list of simplices that contain it. This optimizes the activation check.\n3.  Enter a loop that continues until a fixed point is detected.\n4.  Inside the loop, create an empty set `newly_activated` to store nodes that will become active in the current step, enforcing the synchronous update rule.\n5.  Iterate through each inactive node $v \\in V \\setminus S_t$.\n6.  For each inactive node $v$, iterate through its incident simplices $\\sigma$.\n7.  For each simplex $\\sigma$, determine its dimension $d=|\\sigma|-1$ and retrieve the corresponding threshold $t_d$.\n8.  Count the number of active nodes in $\\sigma \\setminus \\{v\\}$, which is equivalent to $|S_t \\cap \\sigma|$ since $v$ is inactive.\n9.  If this count is greater than or equal to $t_d$, the condition is met. Mark $v$ for activation, add it to `newly_activated`, and break the inner loop over simplices for this node (as one simplex is sufficient).\n10. After checking all inactive nodes, if `newly_activated` is empty, break the main loop (fixed point reached).\n11. Otherwise, update the active set $S_{t+1} = S_t \\cup \\text{newly\\_activated}$ and proceed to the next time step.\n12. Once the loop terminates, return the final number of active nodes, $|S_{final}|$.\n\n### 4. Walkthrough of Test Case A\n\nLet's analyze Test Case A to illustrate the difference between the two conditions.\n-   $V = \\{0, 1, 2, 3\\}$\n-   Maximal simplices: $E_{max} = \\{\\{0, 1, 2, 3\\}\\}$ (one tetrahedron)\n-   Initial active set: $S_0 = \\{0, 1\\}$\n-   Thresholds: $t_1 = 1$, $t_2 = 2$, $t_3 = 3$\n\n**Without Closure:**\nThe only available simplex for contagion is the $3$-simplex $\\sigma = \\{0, 1, 2, 3\\}$, for which the threshold is $t_3 = 3$. At $t=0$, the active set is $S_0 = \\{0, 1\\}$. The inactive nodes are $\\{2, 3\\}$.\n-   For node $v=2$, the number of active neighbors in $\\sigma \\setminus \\{2\\}$ is $|\\{0, 1\\}| = 2$. Since $2 < t_3$, node $2$ is not activated.\n-   For node $v=3$, the number of active neighbors in $\\sigma \\setminus \\{3\\}$ is also $|\\{0, 1\\}| = 2$. Since $2 < t_3$, node $3$ is not activated.\nNo new nodes are activated. The process terminates with the final active set $\\{0, 1\\}$. The final count is $2$.\n\n**With Closure:**\nThe closure of the tetrahedron $\\{0, 1, 2, 3\\}$ includes all its faces of size $\\ge 2$:\n-   Four $2$-simplices (triangles): $\\{0, 1, 2\\}, \\{0, 1, 3\\}, \\{0, 2, 3\\}, \\{1, 2, 3\\}$.\n-   Six $1$-simplices (edges): $\\{0, 1\\}, \\{0, 2\\}, \\{0, 3\\}, \\{1, 2\\}, \\{1, 3\\}, \\{2, 3\\}$.\nAt $t=0$, $S_0 = \\{0, 1\\}$ and inactive nodes are $\\{2, 3\\}$.\n-   Consider node $v=2$. It participates in the $2$-simplex $\\sigma' = \\{0, 1, 2\\}$, for which the threshold is $t_2 = 2$. The number of active neighbors in $\\sigma' \\setminus \\{2\\}$ is $|\\{0, 1\\}| = 2$. Since $2 \\ge t_2$, node $2$ is activated.\n-   Similarly, for node $v=3$, the $2$-simplex $\\sigma'' = \\{0, 1, 3\\}$ provides a pathway. The number of active neighbors in $\\sigma'' \\setminus \\{3\\}$ is $|\\{0, 1\\}| = 2$. Since $2 \\ge t_2$, node $3$ is activated.\nIn the synchronous update, both $2$ and $3$ become active. The active set at $t=1$ becomes $S_1 = \\{0, 1, 2, 3\\}$. All nodes are active, and the process stops. The final count is $4$.\n\nThe final results for this case are: without closure $n^{\\text{no}}=2$, with closure $n^{\\text{cl}}=4$, and the difference $\\Delta=2$. This demonstrates a clear instance where enforcing closure fundamentally alters the contagion outcome by enabling pathways through lower-dimensional faces.",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef _generate_closure(maximal_simplices):\n    \"\"\"\n    Generates a full simplicial complex by adding all faces of size >= 2\n    for a given set of maximal simplices.\n\n    Args:\n        maximal_simplices (iterable of frozensets): The maximal simplices of the complex.\n\n    Returns:\n        set of frozensets: The full set of simplices, closed under face operation.\n    \"\"\"\n    all_simplices = set()\n    for max_s in maximal_simplices:\n        s_size = len(max_s)\n        # A face must have at least 2 vertices as per problem spec.\n        for k in range(2, s_size + 1):\n            for face_tuple in combinations(max_s, k):\n                all_simplices.add(frozenset(face_tuple))\n    return all_simplices\n\ndef _run_simulation(num_vertices, simplices, initial_active, thresholds):\n    \"\"\"\n    Runs the contagion simulation on a given hypergraph until a fixed point is reached.\n\n    Args:\n        num_vertices (int): The total number of vertices in the set V.\n        simplices (set of frozensets): The set of simplices available for contagion.\n        initial_active (set): The set of initially active nodes.\n        thresholds (dict): A mapping from dimension d to threshold t_d.\n\n    Returns:\n        int: The final number of active nodes.\n    \"\"\"\n    all_vertices = set(range(num_vertices))\n    active_nodes = set(initial_active)\n\n    # Pre-process for efficiency: map each vertex to its incident simplices\n    incident_simplices = {v: [] for v in all_vertices}\n    for s in simplices:\n        for v_in_s in s:\n            if v_in_s in incident_simplices:\n                incident_simplices[v_in_s].append(s)\n\n    while True:\n        if len(active_nodes) == num_vertices:\n            break  # Optimization: all nodes are active\n\n        newly_activated = set()\n        inactive_nodes = all_vertices - active_nodes\n\n        for v in inactive_nodes:\n            is_activated = False\n            for s in incident_simplices.get(v, []):\n                dimension = len(s) - 1\n                # The contagion rule applies to simplices of dimension >= 1 (size >= 2)\n                if dimension < 1:\n                    continue\n                \n                threshold = thresholds.get(dimension, float('inf'))\n\n                # As v is inactive, `s.intersection(active_nodes)` is equivalent to\n                # `(s - {v}).intersection(active_nodes)`.\n                num_active_neighbors = len(s.intersection(active_nodes))\n\n                if num_active_neighbors >= threshold:\n                    is_activated = True\n                    break  # \"at least one incident simplex\" condition is met\n\n            if is_activated:\n                newly_activated.add(v)\n        \n        if not newly_activated:\n            break  # Fixed point reached\n        \n        active_nodes.update(newly_activated)\n\n    return len(active_nodes)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case A (closure changes the outcome via triangle faces inside a tetrahedron)\n        {\n            \"V_size\": 4,\n            \"maximal_simplices\": [{0, 1, 2, 3}],\n            \"S0\": {0, 1},\n            \"thresholds\": {1: 1, 2: 2, 3: 3}\n        },\n        # Test case B (closure changes outcome by enabling edge-level contagion)\n        {\n            \"V_size\": 5,\n            \"maximal_simplices\": [{0, 1, 2}, {2, 3, 4}],\n            \"S0\": {0},\n            \"thresholds\": {1: 1, 2: 2}\n        },\n        # Test case C (boundary case where closure does not change the outcome)\n        {\n            \"V_size\": 4,\n            \"maximal_simplices\": [{0, 1, 2, 3}],\n            \"S0\": {0, 1, 2},\n            \"thresholds\": {1: 3, 2: 3, 3: 2}\n        }\n    ]\n\n    all_results_formatted = []\n    \n    for case in test_cases:\n        V_size = case[\"V_size\"]\n        # Use frozensets for hashability\n        max_simplices = [frozenset(s) for s in case[\"maximal_simplices\"]]\n        S0 = case[\"S0\"]\n        thresholds = case[\"thresholds\"]\n        \n        # 1. Simulate without closure (on the raw hypergraph of maximal simplices)\n        simplices_no_closure = set(max_simplices)\n        n_no = _run_simulation(V_size, simplices_no_closure, S0, thresholds)\n        \n        # 2. Simulate with closure (on the full simplicial complex)\n        simplices_with_closure = _generate_closure(max_simplices)\n        n_cl = _run_simulation(V_size, simplices_with_closure, S0, thresholds)\n        \n        # 3. Calculate difference\n        delta = n_cl - n_no\n        \n        # Format the result for this case to `[n_no,n_cl,delta]`\n        formatted_result = f\"[{n_no},{n_cl},{delta}]\"\n        all_results_formatted.append(formatted_result)\n\n    # Join the formatted strings for each case to produce the final output string\n    final_output = f\"[{','.join(all_results_formatted)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond simulating dynamics, a key task in network science is to identify the most influential nodes. This practice extends the concept of centrality from simple graphs to hypergraphs, contrasting a local measure (degree) with a global one based on the adjacency tensor. You will implement the power iteration method to compute tensor eigenvector centrality, providing a powerful tool for ranking node importance in systems with multi-way interactions .",
            "id": "4126430",
            "problem": "Consider a $3$-uniform hypergraph with node set $\\{0,1,\\dots,n-1\\}$ and hyperedge set $\\mathcal{E}$, where each hyperedge is a $3$-element subset of the node set. The goal is to compute node influence via two complementary centralities and to produce a deterministic ranking. The computations must be based on foundational definitions and well-tested principles appropriate for higher-order networks and hypergraphs in complex adaptive systems modeling.\n\nDefinitions and foundations:\n- A $3$-uniform hypergraph is a pair $(V,\\mathcal{E})$ with $V=\\{0,1,\\dots,n-1\\}$ and $\\mathcal{E}\\subseteq \\{e\\subseteq V: |e|=3\\}$.\n- The degree centrality of node $i$ is $d_i$, the count of hyperedges in $\\mathcal{E}$ that contain $i$.\n- The adjacency tensor of a $3$-uniform hypergraph is the order-$3$ symmetric tensor $\\mathcal{A}\\in\\mathbb{R}^{n\\times n\\times n}$ with entries\n$$\n\\mathcal{A}_{ijk}=\\begin{cases}\n\\frac{1}{2} & \\text{if } \\{i,j,k\\}\\in\\mathcal{E} \\text{ and } i,j,k \\text{ are pairwise distinct},\\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\n- The tensor eigenvector centrality uses the $Z$-eigenpair $(\\lambda,x)$ satisfying\n$$\n\\mathcal{A}x^2=\\lambda x,\n$$\nwhere $(\\mathcal{A}x^2)_i=\\sum_{j,k=0}^{n-1}\\mathcal{A}_{ijk}x_j x_k$, $x\\in\\mathbb{R}_{\\ge 0}^n$ and a normalization such as $\\|x\\|_2=1$ is imposed to fix scale. Existence of a nonnegative principal eigenvector for nonnegative, weakly irreducible tensors follows from the Perron–Frobenius theorem (PF) generalized to tensors.\n- A computationally consistent contraction for $3$-uniform hypergraphs that avoids explicit tensor construction is\n$$\n(\\mathcal{A}x^2)_i=\\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x_j x_k,\n$$\nwhich matches the above $\\mathcal{A}$ by symmetry and the factor $\\frac{1}{2}$ summed over permutations.\n\nYour program must, for each supplied test hypergraph:\n1. Compute the degree centrality vector $d\\in\\mathbb{N}^n$ with entries $d_i$.\n2. Compute a nonnegative tensor $Z$-eigenvector centrality $x\\in\\mathbb{R}_{\\ge 0}^n$ by fixed-point iteration derived from $\\mathcal{A}x^2=\\lambda x$:\n   - Initialize $x^{(0)}$ with strictly positive entries and normalize with the Euclidean norm $\\|\\cdot\\|_2$.\n   - Iterate $x^{(t+1)}=\\frac{\\mathcal{A}(x^{(t)})^2}{\\|\\mathcal{A}(x^{(t)})^2\\|_2}$ until convergence in the Euclidean norm, i.e., stop when $\\|x^{(t+1)}-x^{(t)}\\|_2$ is below a tolerance. If $\\|\\mathcal{A}(x^{(t)})^2\\|_2=0$, then the centrality vector is the zero vector.\n   - Report the converged $x$ normalized by $\\|x\\|_2=1$ and provide entries rounded to $6$ decimal places.\n3. Rank nodes by influence using the following total order:\n   - Primary key: descending tensor eigenvector centrality $x_i$,\n   - Secondary key: descending degree centrality $d_i$,\n   - Tertiary key: ascending node index $i$.\n   The ranking must be reported as a list of node indices from most to least influential.\n\nTest suite:\n- Test case $1$ (general case): $n=5$, $\\mathcal{E}=\\{\\{0,1,2\\},\\{0,2,3\\},\\{0,3,4\\},\\{1,2,3\\}\\}$.\n- Test case $2$ (boundary with isolated node): $n=4$, $\\mathcal{E}=\\{\\{0,1,2\\}\\}$; node $3$ is isolated.\n- Test case $3$ (symmetric regular case): $n=6$, $\\mathcal{E}=\\{\\{0,1,2\\},\\{0,3,4\\},\\{1,3,5\\},\\{2,4,5\\}\\}$.\n\nAnswer specification:\n- For each test case, output a triple of lists $[d,x,r]$ where $d$ is the list of integers $d_i$, $x$ is the list of floats $x_i$ each rounded to $6$ decimal places, and $r$ is the list of integers representing the node ranking.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one element per test case, in the exact format\n$$\n[[d^{(1)},x^{(1)},r^{(1)}],[d^{(2)},x^{(2)},r^{(2)}],[d^{(3)},x^{(3)},r^{(3)}]].\n$$\nNo additional text should be printed.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the fields of complex network theory and numerical linear algebra, specifically concerning hypergraphs and tensor eigenvectors. The problem is well-posed, with all definitions, constraints, and objectives clearly and formally stated, leading to a unique, computable solution. All terms are objective and mathematically precise.\n\nThe task is to compute two centrality measures for nodes in a $3$-uniform hypergraph and then to produce a deterministic ranking based on these measures. The specified measures are degree centrality and tensor eigenvector centrality.\n\n### 1. Degree Centrality\n\nDegree centrality is a fundamental measure of a node's importance based on its direct involvement in the network's structure. For a hypergraph, it is the most direct generalization of the concept from simple graphs.\n\n**Definition**: The degree centrality $d_i$ of a node $i$ is defined as the number of hyperedges that contain node $i$. Mathematically, for a hypergraph $(V, \\mathcal{E})$ with node set $V$ and hyperedge set $\\mathcal{E}$,\n$$\nd_i = |\\{e \\in \\mathcal{E} : i \\in e\\}|\n$$\n\n**Computation**: To compute the degree centrality vector $d \\in \\mathbb{N}^n$ for a hypergraph with $n$ nodes, one can initialize a zero vector of size $n$. Then, for each hyperedge $e = \\{v_1, v_2, v_3\\}$ in the set $\\mathcal{E}$, the degree counts for nodes $v_1$, $v_2$, and $v_3$ are incremented by one. This process is repeated for all hyperedges.\n\n### 2. Tensor Eigenvector Centrality\n\nWhile degree centrality captures local influence, eigenvector-based centralities measure a node's influence transitively. A node is important if it is connected to other important nodes. For hypergraphs, this relationship is captured by an adjacency tensor, a higher-order generalization of an adjacency matrix.\n\n**Adjacency Tensor and Eigenvalue Problem**: For a $k$-uniform hypergraph, the interactions are represented by an order-$k$ adjacency tensor. For the given $3$-uniform hypergraph, this is an order-$3$ tensor $\\mathcal{A} \\in \\mathbb{R}^{n \\times n \\times n}$. The problem defines it as\n$$\n\\mathcal{A}_{ijk}=\\begin{cases}\n\\frac{1}{2} & \\text{if } \\{i,j,k\\}\\in\\mathcal{E} \\text{ and } i,j,k \\text{ are pairwise distinct},\\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nThe factor of $1/2$ is a convention related to the number of non-zero entries for a symmetric tensor, which is $3! = 6$. The problem states the total contribution per hyperedge $\\{i,j,k\\}$ is $\\mathcal{A}_{ijk}+\\mathcal{A}_{ikj}+\\mathcal{A}_{jik}+\\mathcal{A}_{jki}+\\mathcal{A}_{kij}+\\mathcal{A}_{kji} = 6 \\times \\frac{1}{2} = 3$. This is a detail of tensor definition; the core computation relies on a more direct contraction.\n\nThe eigenvector centrality vector $x \\in \\mathbb{R}_{\\ge 0}^n$ is derived from the $Z$-eigenvalue equation:\n$$\n\\mathcal{A}x^2 = \\lambda x\n$$\nwhere $(\\mathcal{A}x^2)_i = \\sum_{j,k=0}^{n-1}\\mathcal{A}_{ijk}x_j x_k$. This equation signifies that a node $i$'s centrality, $x_i$, is proportional to the summed influence from pairs of nodes $(j,k)$ with which it forms hyperedges.\n\n**Computational Method via Power Iteration**: Constructing and storing the $n \\times n \\times n$ tensor $\\mathcal{A}$ is computationally expensive. The problem provides a more efficient, equivalent contraction for computing the tensor-vector product $\\mathcal{A}x^2$:\n$$\n(\\mathcal{A}x^2)_i = \\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x_j x_k\n$$\nThis form avoids materializing the tensor by directly iterating over the list of hyperedges.\n\nThe principal eigenvector (the one associated with the largest eigenvalue $\\lambda$) can be found using the fixed-point power iteration method. The existence and uniqueness of a non-negative principal eigenvector are guaranteed for non-negative, irreducible tensors by the Perron-Frobenius theorem for tensors. For reducible tensors, as seen in hypergraphs with isolated components, the method still converges to an eigenvector corresponding to the dominant component.\n\nThe iterative scheme is as follows:\n1.  Initialize a vector $x^{(0)}$ with strictly positive entries (e.g., a vector of ones) and normalize it to have a Euclidean norm of $1$: $\\|x^{(0)}\\|_2 = 1$.\n2.  For $t = 0, 1, 2, \\dots$, compute the next iterate $x^{(t+1)}$:\n    a.  Compute the unnormalized vector $y^{(t+1)}$ where $y^{(t+1)}_i = (\\mathcal{A}(x^{(t)})^2)_i = \\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x^{(t)}_j x^{(t)}_k$.\n    b.  If $\\|y^{(t+1)}\\|_2 = 0$, the centrality vector is the zero vector. This occurs if the hypergraph is empty or the initial vector lies in a nullspace, which is avoided by positive initialization.\n    c.  Normalize to get the next iterate: $x^{(t+1)} = \\frac{y^{(t+1)}}{\\|y^{(t+1)}\\|_2}$.\n3.  The iteration stops when the change between successive vectors is negligible, i.e., $\\|x^{(t+1)} - x^{(t)}\\|_2 < \\epsilon$ for a small tolerance $\\epsilon$. The final $x^{(t+1)}$ is the desired centrality vector.\n\n### 3. Deterministic Node Ranking\n\nTo provide a single, unambiguous influence ranking, a total order on the set of nodes is required. The problem specifies a lexicographical comparison using three keys, which resolves any ties that may arise from using a single metric.\n\n**Ranking Keys**:\n1.  **Primary Key**: The tensor eigenvector centrality score $x_i$, in descending order. Nodes with higher eigenvector centrality are considered more influential.\n2.  **Secondary Key**: The degree centrality $d_i$, in descending order. This is used to break ties among nodes with identical eigenvector centrality.\n3.  **Tertiary Key**: The node index $i$, in ascending order. This is the final tie-breaker, ensuring a unique ranking when both primary and secondary keys are equal.\n\n**Procedure**: The ranking algorithm involves creating a list of tuples for each node $i$, of the form $(x_i, d_i, i)$. This list is then sorted using the specified compound key. The final ranked list of nodes is extracted from the sorted tuples.\n\nBy integrating these three principles, we can construct a robust algorithm to analyze the provided hypergraphs and generate the required output triplets $[d, x, r]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hypergraph centrality and ranking problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case)\n        {'n': 5, 'edges': [[0, 1, 2], [0, 2, 3], [0, 3, 4], [1, 2, 3]]},\n        # Test case 2 (boundary with isolated node)\n        {'n': 4, 'edges': [[0, 1, 2]]},\n        # Test case 3 (symmetric regular case)\n        {'n': 6, 'edges': [[0, 1, 2], [0, 3, 4], [1, 3, 5], [2, 4, 5]]}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n\n        # 1. Compute degree centrality\n        d = compute_degree_centrality(n, edges)\n\n        # 2. Compute tensor eigenvector centrality\n        x = compute_eigenvector_centrality(n, edges)\n\n        # 3. Rank nodes\n        r = rank_nodes(d, x)\n\n        # Format results for output\n        d_list = d.tolist()\n        x_list_rounded = [round(val, 6) for val in x]\n        r_list = r\n\n        all_results.append([d_list, x_list_rounded, r_list])\n\n    # Final print statement in the exact required format.\n    # Custom formatter to avoid spaces in the output string.\n    def format_list(lst, is_float=False):\n        if is_float:\n            return '[' + ','.join(f'{val:.6f}' for val in lst) + ']'\n        return '[' + ','.join(map(str, lst)) + ']'\n\n    results_str = []\n    for d, x, r in all_results:\n        case_str = f\"[{format_list(d)},{format_list(x, is_float=True)},{format_list(r)}]\"\n        results_str.append(case_str)\n    \n    print(f\"[{','.join(results_str)}]\")\n\ndef compute_degree_centrality(n, edges):\n    \"\"\"\n    Computes degree centrality for each node.\n    d_i is the number of hyperedges containing node i.\n    \"\"\"\n    degrees = np.zeros(n, dtype=int)\n    for edge in edges:\n        for node in edge:\n            degrees[node] += 1\n    return degrees\n\ndef compute_eigenvector_centrality(n, edges, tol=1e-9, max_iter=1000):\n    \"\"\"\n    Computes tensor eigenvector centrality using fixed-point power iteration.\n    \"\"\"\n    # 1. Initialize x_t0 with strictly positive entries and normalize\n    x = np.ones(n)\n    x = x / np.linalg.norm(x)\n\n    for _ in range(max_iter):\n        # 2a. Compute the unnormalized next vector y = A(x^2)\n        y = np.zeros(n)\n        for i, j, k in edges:\n            y[i] += x[j] * x[k]\n            y[j] += x[i] * x[k]\n            y[k] += x[i] * x[j]\n        \n        # 2b. Check for zero vector case\n        norm_y = np.linalg.norm(y)\n        if norm_y == 0:\n            return np.zeros(n)\n        \n        # 2c. Normalize to get the next iterate x_t1\n        x_next = y / norm_y\n        \n        # 3. Check for convergence\n        if np.linalg.norm(x_next - x) < tol:\n            return x_next\n        \n        x = x_next\n        \n    return x\n\ndef rank_nodes(d, x):\n    \"\"\"\n    Ranks nodes based on a three-key system:\n    1. Descending eigenvector centrality (x_i)\n    2. Descending degree centrality (d_i)\n    3. Ascending node index (i)\n    \"\"\"\n    n = len(d)\n    # Create a list of tuples (x_i, d_i, i) for sorting\n    nodes_with_metrics = [(x[i], d[i], i) for i in range(n)]\n\n    # Sort using a lambda function that implements the ranking logic\n    # Python's sort is stable. We use negative values for descending order.\n    nodes_with_metrics.sort(key=lambda item: (-item[0], -item[1], item[2]))\n\n    # Extract the ranked node indices\n    ranked_indices = [item[2] for item in nodes_with_metrics]\n    \n    return ranked_indices\n\nsolve()\n\n```"
        }
    ]
}