{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究高阶网络的复杂动态和代数表示之前，首先必须确保我们对它的基本构成要素有扎实的理解。这个练习旨在通过计算一个简单超图的基本属性——节点度与超边大小，来巩固这些核心概念。通过验证节点度之和等于超边大小之和这一基本恒等式 ，您将亲手实践一个在图论和组合学中被称为“双重计数”的经典证明思想。",
            "id": "4126420",
            "problem": "考虑一个用于编码复杂自适应系统 (CAS) 中高阶相互作用的有限超图模型。一个超图由一个节点集合 $V$ 和一个超边集合 $E$ 定义，其中每条超边是 $V$ 的一个子集。节点 $v \\in V$ 的度 $d(v)$ 是 $E$ 中包含 $v$ 的超边数量，而超边 $e \\in E$ 的大小 $|e|$ 是它所包含的节点数量。关联矩阵记录了节点-超边的隶属关系，其非零元的总数可以通过对所有节点的度求和或对所有超边的大小求和来计算。从这些定义和关联矩阵的视角出发，证明在任何有限超图中这两个总和都相等，然后为给定的特定情况 $V=\\{1,2,3,4\\}$ 和 $E=\\{\\{1,2,3\\},\\{2,3\\},\\{1,4\\}\\}$ 计算这个共同的总和。计算每个 $v \\in V$ 的 $d(v)$，计算每个 $e \\in E$ 的 $|e|$，并以精确整数形式给出最终的共同总和。",
            "solution": "该问题被认为是有效的，因为它在超图理论这一数学领域有科学依据，问题阐述清晰，目标明确，语言客观，并包含了完整解答所需的所有信息。\n\n该问题要求分两部分解答：首先，普遍性地证明对于任何有限超图，所有节点的度之和等于所有超边的大小之和；其次，对一个具体例子计算这些和以及共同的总和。\n\n设该超图表示为 $\\mathcal{H} = (V, E)$，其中 $V$ 是一个有限的节点集合，$E$ 是一个有限的超边集合，每个超边 $e \\in E$ 是 $V$ 的一个非空子集。\n\n为了证明该等式，我们使用问题中建议的关联矩阵概念。设 $|V|=n$ 且 $|E|=m$。关联矩阵 $H$ 是一个 $n \\times m$ 矩阵，其行由节点 $v \\in V$ 索引，列由超边 $e \\in E$ 索引。矩阵的元素 $H_{ve}$ 定义如下：\n$$\nH_{ve} = \\begin{cases} 1  \\text{如果 } v \\in e \\\\ 0  \\text{如果 } v \\notin e \\end{cases}\n$$\n由于矩阵元素为 $1$ 或 $0$，因此 $H$ 中非零元的总数就是其所有元素的和。我们用 $S$ 表示这个总和。我们可以通过两种不同的顺序对矩阵元素求和来计算 $S$。\n\n首先，我们对每一行按列求和，然后将所有行的结果相加。这对应于以节点为中心的视角。对于一个固定的节点 $v_i \\in V$，其对应行中元素的和为：\n$$\n\\sum_{e_j \\in E} H_{v_i e_j}\n$$\n根据关联矩阵的定义，$H_{v_i e_j}$ 为 $1$ 当且仅当节点 $v_i$ 包含在超边 $e_j$ 中。因此，这个和计算了包含节点 $v_i$ 的超边数量。这正是节点 $v_i$ 的度的定义，记为 $d(v_i)$。\n$$\nd(v_i) = \\sum_{e_j \\in E} H_{v_i e_j}\n$$\n为了求得总和 $S$，我们将这些行和对所有节点 $v_i \\in V$ 求和：\n$$\nS = \\sum_{v_i \\in V} \\left( \\sum_{e_j \\in E} H_{v_i e_j} \\right) = \\sum_{v_i \\in V} d(v_i)\n$$\n其次，我们对每一列按行求和，然后将所有列的结果相加。这对应于以超边为中心的视角。对于一个固定的超边 $e_j \\in E$，其对应列中元素的和为：\n$$\n\\sum_{v_i \\in V} H_{v_i e_j}\n$$\n根据定义，$H_{v_i e_j}$ 为 $1$ 当且仅当节点 $v_i$ 是超边 $e_j$ 的一个成员。因此，这个和计算了超边 $e_j$ 中包含的节点数量。这正是超边 $e_j$ 的大小（或基数）的定义，记为 $|e_j|$。\n$$\n|e_j| = \\sum_{v_i \\in V} H_{v_i e_j}\n$$\n为了求得总和 $S$，我们将这些列和对所有超边 $e_j \\in E$ 求和：\n$$\nS = \\sum_{e_j \\in E} \\left( \\sum_{v_i \\in V} H_{v_i e_j} \\right) = \\sum_{e_j \\in E} |e_j|\n$$\n由于两种计算方法都计算了相同的总和 $S$，所以这两个表达式必然相等。这种证明方法被称为双重计数法。\n$$\n\\sum_{v \\in V} d(v) = \\sum_{e \\in E} |e|\n$$\n这就证明了对于任何有限超图该普遍原理都成立。\n\n现在，我们为给定的具体情况进行计算：$V=\\{1,2,3,4\\}$ 且 $E=\\{e_1, e_2, e_3\\}$，其中 $e_1=\\{1,2,3\\}$，$e_2=\\{2,3\\}$，$e_3=\\{1,4\\}$。\n\n我们首先计算每个节点 $v \\in V$ 的度 $d(v)$：\n- 对于节点 $v=1$：它包含在 $e_1=\\{1,2,3\\}$ 和 $e_3=\\{1,4\\}$ 中。因此，$d(1) = 2$。\n- 对于节点 $v=2$：它包含在 $e_1=\\{1,2,3\\}$ 和 $e_2=\\{2,3\\}$ 中。因此，$d(2) = 2$。\n- 对于节点 $v=3$：它包含在 $e_1=\\{1,2,3\\}$ 和 $e_2=\\{2,3\\}$ 中。因此，$d(3) = 2$。\n- 对于节点 $v=4$：它包含在 $e_3=\\{1,4\\}$ 中。因此，$d(4) = 1$。\n\n度的总和是：\n$$\n\\sum_{v \\in V} d(v) = d(1) + d(2) + d(3) + d(4) = 2 + 2 + 2 + 1 = 7\n$$\n接下来，我们计算每条超边 $e \\in E$ 的大小 $|e|$：\n- 对于超边 $e_1=\\{1,2,3\\}$：其大小是它包含的节点数，所以 $|e_1| = 3$。\n- 对于超边 $e_2=\\{2,3\\}$：其大小为 $|e_2| = 2$。\n- 对于超边 $e_3=\\{1,4\\}$：其大小为 $|e_3| = 2$。\n\n超边大小的总和是：\n$$\n\\sum_{e \\in E} |e| = |e_1| + |e_2| + |e_3| = 3 + 2 + 2 = 7\n$$\n正如定理所预测的，两个总和都得出相同的值 $7$。这个共同的总和表示（节点，超边）关联对的总数，也就是对应的 $4 \\times 3$ 关联矩阵中非零元的数量。\n最终的共同总和是 $7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "高阶网络研究的一个核心动机是，许多系统中的交互本质上是群体的，无法被简化为成对连接的集合。本练习通过一个级联动力学的案例，鲜明地展示了高阶结构的重要性 。您将证明，在一个特定的超图上，其成对投影（一个普通图）无法支持级联传播，而能够捕捉三元协同效应的原始超图模型却能引发全局性的传播，从而深刻理解为何需要超越传统的成对网络模型。",
            "id": "4126352",
            "problem": "考虑在高阶网络和超图背景下的以下构造问题。设 $\\mathcal{H} = (V, E)$ 是一个 3-一致超图，其节点集为 $V$，超边集为 $E$。它的成对投影是一个简单图 $G = (V, \\mathcal{E})$，该图通过将每条超边 $e \\in E$ 替换为其成员节点之间的所有成对边来获得，即如果 $e = \\{u,v,w\\}$，则 $\\{u,v\\}, \\{v,w\\}, \\{u,w\\} \\in \\mathcal{E}$。考虑从一个初始种子集 $S_0 \\subseteq V$ 开始的两种同步、离散时间采纳动态：\n- 在 $G$ 上的线性阈值模型 (LTM)，其中一个非活跃节点 $x$ 在时间 $t+1$ 变为活跃，当且仅当它在 $G$ 中的邻居中至少有 $m$ 个在时间 $t$ 是活跃的，其中 $m \\in \\mathbb{N}$ 是一个整数阈值。\n- 在 $\\mathcal{H}$ 上的具有三元协同作用的高阶级联模型 (HCM)，其中一个非活跃节点 $x$ 在时间 $t+1$ 变为活跃，当且仅当存在某条包含 $x$ 的超边 $e \\in E$，使得 $e$ 的其他成员中至少有 $s$ 个在时间 $t$ 是活跃的，其中 $s \\in \\{1,2\\}$ 是三元协同作用阈值（因为对于任何节点，每条 3-一致超边都恰好有 2 个共同成员）。\n\n你需要构造并分析一个反例族，在该反例中，成对投影 $G$ 在 LTM 下预测不会发生级联，但 $\\mathcal{H}$ 上的高阶 HCM 在三元协同作用的驱动下表现出全局级联。为此，请使用如下定义的边共享三角形链超图。对于任意整数长度 $L \\ge 0$，定义节点集 $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$，其大小为 $|V| = L+2$，并定义超边集 $E = \\{e_i : i = 0,1,\\dots,L-1\\}$，其中 $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$。因此，连续的超边共享边 $\\{v_{i+1}, v_{i+2}\\}$。初始种子集为 $S_0 = \\{v_0, v_1\\}$。\n\n从上面给出的超图投影、线性阈值模型 (LTM) 和高阶三元协同作用 HCM 的核心定义出发（不使用任何其他简化公式），完成以下任务：\n\n1. 根据给定定义进行推理，证明对于任何 $L \\ge 1$，在成对投影 $G$ 上，当阈值为 $m=3$ 且种子集为 $S_0 = \\{v_0, v_1\\}$ 时，LTM 不会激活 $S_0$ 之外的任何其他节点。精确解释为什么在此构造中没有非活跃节点满足 LTM 下的激活条件。\n\n2. 根据给定定义进行推理，证明对于任何 $L \\ge 1$，在超图 $\\mathcal{H}$ 上，当三元协同作用阈值为 $s = 2$ 且种子集为 $S_0 = \\{v_0, v_1\\}$ 时，HCM 会激活所有节点，即表现出全局级联。沿着边共享三角形链提供一个清晰的归纳论证，说明每个后续的非种子节点如何变为活跃状态。\n\n3. 将定量级联差距 $g(L,m,s)$ 定义为在相同构造下，HCM 和 LTM 的最终活跃集大小之差：\n$$\ng(L,m,s) \\triangleq |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|,\n$$\n其中 $\\mathcal{A}_{\\mathrm{HCM}}(L,s)$ 和 $\\mathcal{A}_{\\mathrm{LTM}}(L,m)$ 分别表示从 $S_0$ 开始的各自最终（不动点）活跃集。通过仅应用模型定义和你在步骤 1 和 2 中的推理，为下面提供的测试套件案例推导出 $g(L,m,s)$。\n\n4. 实现一个程序，该程序为任意 $L$ 构造超图及其成对投影，使用上述定义从 $S_0$ 开始模拟两种动态直至达到不动点，并为下面列出的每个测试案例输出级联差距 $g(L,m,s)$。你的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3]$）。每个 $r_i$ 都必须是整数。不涉及物理单位或角度，也不期望输出百分比。\n\n测试套件（每个案例为 $(L,m,s)$）：\n- 案例 1：$(L,m,s) = (5,3,2)$。\n- 案例 2：$(L,m,s) = (5,2,2)$。\n- 案例 3：$(L,m,s) = (1,3,2)$。\n- 案例 4：$(L,m,s) = (0,3,2)$。\n- 案例 5：$(L,m,s) = (7,3,1)$。\n\n你的程序应按上述案例的顺序，生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$）。",
            "solution": "该问题提出了复杂系统建模领域一个有效的研究问题，即比较超图上的传染动态与其成对投影上的动态。所有定义在数学上都是精确的，所提出的构造是良定义的，这使得该问题具有科学依据、良定性和客观性。因此，我们可以进行形式化的求解。\n\n根据要求，解答分为三个部分：首先，分析成对投影上的线性阈值模型 (LTM)；其次，分析超图上的高阶级联模型 (HCM)；第三，为指定的测试案例推导级联差距 $g(L,m,s)$。\n\n我们首先确定超图 $\\mathcal{H} = (V, E)$ 及其投影图 $G = (V, \\mathcal{E})$ 的结构。\n节点集为 $V = \\{v_0, v_1, \\dots, v_{L+1}\\}$，其大小为 $|V| = L+2$。\n超边集为 $E = \\{e_i : i = 0, \\dots, L-1\\}$，其中 $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$。\n投影图 $G$ 的边集 $\\mathcal{E}$ 是由每个超图的所有成对边的并集构成的。对于每个 $e_i \\in E$，我们将边 $\\{v_i, v_{i+1}\\}$、$\\{v_i, v_{i+2}\\}$ 和 $\\{v_{i+1}, v_{i+2}\\}$ 添加到 $\\mathcal{E}$ 中。两种动态的初始活跃节点集均为 $S_0 = \\{v_0, v_1\\}$。\n\n**1. 线性阈值模型 (LTM) 分析**\n\n题目要求我们证明，对于任何 $L \\ge 1$ 和阈值 $m=3$，从 $S_0$ 开始的 LTM 级联不会激活任何其他节点。\n\nLTM 激活一个非活跃节点 $x$ 的条件是，其在 $G$ 中的活跃邻居数量（表示为 $|N_G(x) \\cap S_t|$）至少为 $m$。在时间 $t=0$ 时，活跃集为 $S_0 = \\{v_0, v_1\\}$。我们必须检查是否有任何非活跃节点 $v_k \\in V \\setminus S_0$（其中 $k \\ge 2$）可以被激活。\n\n- **节点 $v_2$ 的情况**：节点 $v_2$ 存在于超边 $e_0 = \\{v_0, v_1, v_2\\}$ 中。该超边的投影创建了一个三角形，使得 $v_0$ 和 $v_1$ 成为 $v_2$ 在 $G$ 中的邻居。对于 $L \\ge 1$，这是唯一一条同时包含 $v_2$ 和来自 $S_0$ 的任何节点的超边。具体来说，$e_1 = \\{v_1, v_2, v_3\\}$（如果 $L \\ge 2$）也使 $v_1$ 成为 $v_2$ 的邻居，但这不是一个新的邻居。没有其他超边可以将 $v_2$ 连接到 $v_0$ 或 $v_1$。因此，在 $S_0$ 中的 $v_2$ 的邻居恰好是 $\\{v_0, v_1\\}$。在 $t=0$ 时，$v_2$ 的活跃邻居数量为 $|N_G(v_2) \\cap S_0| = |\\{v_0, v_1\\}| = 2$。由于阈值为 $m=3$，激活条件未被满足（$2  3$）。因此，$v_2$ 不会变为活跃状态。\n\n- **节点 $v_k$（其中 $k \\ge 3$）的情况**：仅当存在一条超边 $e_i = \\{v_i, v_{i+1}, v_{i+2}\\}$ 同时包含 $v_j$ 和 $v_k$ 时，边 $\\{v_j, v_k\\}$ 才存在于 $G$ 中。对于 $v_k$（其中 $k \\ge 3$），要使其有一个来自 $S_0=\\{v_0, v_1\\}$ 的邻居，必须存在某条超边 $e_i$ 包含 $\\{v_k, v_0\\}$ 或 $\\{v_k, v_1\\}$。任何超边 $e_i$ 中的节点索引为 $i, i+1, i+2$。要使 $e_i$ 包含 $v_0$ 或 $v_1$，其构成的索引必须包括 $0$ 或 $1$。这仅在 $e_0 = \\{v_0, v_1, v_2\\}$ 时发生。然而，$e_0$ 不包含任何索引 $k \\ge 3$ 的节点 $v_k$。因此，对于任何 $k \\ge 3$，$N_G(v_k)$ 的邻域不包含 $v_0$ 或 $v_1$。由此可知 $|N_G(v_k) \\cap S_0| = 0$。在阈值 $m=3$ 的情况下，这些节点无法激活。\n\n由于在 $t=0$ 时没有非活跃节点满足激活阈值，因此在 $t=1$ 时的活跃节点集保持不变，即 $S_1 = S_0$。系统已达到不动点。最终的活跃集为 $\\mathcal{A}_{\\mathrm{LTM}}(L,3) = S_0 = \\{v_0, v_1\\}$，其大小为 $|\\mathcal{A}_{\\mathrm{LTM}}(L,3)| = 2$（对于任何 $L \\ge 1$）。\n\n**2. 高阶级联模型 (HCM) 分析**\n\n题目要求我们证明，对于任何 $L \\ge 1$ 和三元协同作用阈值 $s=2$，从 $S_0$ 开始的 HCM 级联会激活 $V$ 中的所有节点。\n\nHCM 激活一个非活跃节点 $x$ 的条件是，存在一条包含 $x$ 的超边 $e \\in E$，使得 $e$ 的其他成员中至少有 $s$ 个是活跃的。对于一个 3-一致超边 $e=\\{x,y,z\\}$ 和 $s=2$，如果 $y$ 和 $z$ 都活跃，则节点 $x$ 激活。我们通过对节点索引进行归纳来证明全局级联。\n\n- **基础情况**：在 $t=0$ 时，$S_0 = \\{v_0, v_1\\}$。我们检查非活跃节点 $v_2$ 在下一个时间步 $t=1$ 的状态。节点 $v_2$ 是超边 $e_0 = \\{v_0, v_1, v_2\\}$ 的成员。$e_0$ 的其他成员是 $\\{v_0, v_1\\}$。这两个节点都在 $S_0$ 中，因此都是活跃的。活跃的共同成员数量为 $2$。由于这满足阈值 $s=2$，节点 $v_2$ 在 $t=1$ 时变为活跃。活跃集增长为 $S_1 = S_0 \\cup \\{v_2\\} = \\{v_0, v_1, v_2\\}$。\n\n- **归纳步骤**：假设在时间步 $t=k-1$ 时，所有直到 $v_{k+1}$ 的节点都是活跃的，即 $S_{k-1} = \\{v_0, v_1, \\dots, v_{k+1}\\}$，其中 $k \\ge 1$。我们将证明节点 $v_{k+2}$ 在时间步 $t=k$ 时变为活跃。\n考虑非活跃节点 $v_{k+2}$。它是超边 $e_k = \\{v_k, v_{k+1}, v_{k+2}\\}$ 的成员。该超边的其他成员是 $\\{v_k, v_{k+1}\\}$。根据归纳假设，$v_k$ 和 $v_{k+1}$ 都在活跃集 $S_{k-1}$ 中。因此，$v_{k+2}$ 在 $e_k$ 中有 $2$ 个活跃的共同成员。由于 $s=2$，激活条件得到满足，$v_{k+2}$ 在时间 $t=k$ 时变为活跃。\n同时，任何索引 $j > k+2$ 的节点 $v_j$ 都不能被激活，因为包含 $v_j$ 的任何超边的成员索引都接近 $j$，根据假设，这些成员尚未活跃。\n\n通过归纳法，激活沿着链顺序传播：$v_2$ 在 $t=1$ 时激活，$v_3$ 在 $t=2$ 时激活，依此类推，直到最终节点 $v_{L+1}$ 在 $t=L$ 时激活。当 $V$ 中的所有节点都变为活跃时，过程终止。最终的活跃集为 $\\mathcal{A}_{\\mathrm{HCM}}(L,2) = V$，其大小为 $|\\mathcal{A}_{\\mathrm{HCM}}(L,2)| = L+2$（对于任何 $L \\ge 1$）。\n\n**3. 级联差距 $g(L,m,s)$ 的推导**\n\n级联差距定义为 $g(L,m,s) = |\\mathcal{A}_{\\mathrm{HCM}}(L,s)| - |\\mathcal{A}_{\\mathrm{LTM}}(L,m)|$。我们现在为每个测试案例计算这个值。\n\n- **案例 1: $(L,m,s) = (5,3,2)$**\n    根据第 1 部分，当 $m=3$ 时，LTM 级联停止。$|\\mathcal{A}_{\\mathrm{LTM}}(5,3)| = 2$。\n    根据第 2 部分，当 $s=2$ 时，HCM 级联是全局的。$|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = L+2 = 5+2 = 7$。\n    $g(5,3,2) = 7 - 2 = 5$。\n\n- **案例 2: $(L,m,s) = (5,2,2)$**\n    对于 LTM，当 $m=2$ 时：在 $t=0$ 时，$S_0=\\{v_0,v_1\\}$。节点 $v_2$ 有 $2$ 个活跃邻居（$v_0, v_1$），满足阈值 $m=2$。$v_2$ 激活，所以 $S_1=\\{v_0,v_1,v_2\\}$。在 $t=1$ 时，节点 $v_3$（邻居为 $\\{v_1,v_2,v_4\\}$）有 $2$ 个活跃邻居（$v_1,v_2$）。$v_3$ 激活。这个过程继续下去，每个 $v_k$ 都被其前驱节点 $v_{k-2}$ 和 $v_{k-1}$ 激活，导致全局级联。$|\\mathcal{A}_{\\mathrm{LTM}}(5,2)| = L+2 = 7$。\n    对于 HCM，当 $s=2$ 时，级联是全局的。$|\\mathcal{A}_{\\mathrm{HCM}}(5,2)| = 7$。\n    $g(5,2,2) = 7 - 7 = 0$。\n\n- **案例 3: $(L,m,s) = (1,3,2)$**\n    对于 $L=1$，$V=\\{v_0,v_1,v_2\\}$ 且 $E=\\{e_0\\}=\\{v_0,v_1,v_2\\}$。\n    LTM，当 $m=3$ 时：图 $G$ 是一个 3-团。节点 $v_2$ 有 $2$ 个来自 $S_0$ 的活跃邻居。由于 $2  3$，它不激活。$|\\mathcal{A}_{\\mathrm{LTM}}(1,3)| = 2$。\n    HCM，当 $s=2$ 时：$e_0$ 中的节点 $v_2$ 有 $2$ 个来自 $S_0$ 的活跃共同成员。它被激活。$|\\mathcal{A}_{\\mathrm{HCM}}(1,2)| = 3$。\n    $g(1,3,2) = 3 - 2 = 1$。\n\n- **案例 4: $(L,m,s) = (0,3,2)$**\n    对于 $L=0$，$V=\\{v_0,v_1\\}$ 且 $E=\\emptyset$。初始集 $S_0=V$ 包含所有节点。两种动态开始和结束时都处于所有节点均活跃的状态。\n    $|\\mathcal{A}_{\\mathrm{LTM}}(0,3)| = 2$ 且 $|\\mathcal{A}_{\\mathrm{HCM}}(0,2)| = 2$。\n    $g(0,3,2) = 2 - 2 = 0$。\n\n- **案例 5: $(L,m,s) = (7,3,1)$**\n    LTM，当 $m=3$ 时：级联停止。$|\\mathcal{A}_{\\mathrm{LTM}}(7,3)| = 2$。\n    HCM，当 $s=1$ 时：一个非活跃节点在一条超边中仅需一个活跃的共同成员即可激活。\n    在 $t=0$ 时，有 $S_0=\\{v_0,v_1\\}$：\n    节点 $v_2$（在 $e_0=\\{v_0,v_1,v_2\\}$ 中）看到 $2$ 个活跃的共同成员（$\\{v_0,v_1\\}$）。$2 \\ge 1$，所以 $v_2$ 激活。\n    节点 $v_3$（在 $e_1=\\{v_1,v_2,v_3\\}$ 中）看到 $1$ 个活跃的共同成员（$v_1$）。$1 \\ge 1$，所以 $v_3$ 激活。\n    在下一个步骤中，$S_1=\\{v_0,v_1,v_2,v_3\\}$，这接着会激活 $v_4$ 和 $v_5$，以此类推。级联是全局的。$|\\mathcal{A}_{\\mathrm{HCM}}(7,1)| = L+2 = 7+2 = 9$。\n    $g(7,3,1) = 9 - 2 = 7$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cascade gap problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # (L, m, s)\n        (5, 3, 2),\n        (5, 2, 2),\n        (1, 3, 2),\n        (0, 3, 2),\n        (7, 3, 1),\n    ]\n\n    def calculate_gap(L, m, s):\n        \"\"\"\n        Calculates the cascade gap for a given (L, m, s) configuration.\n        \"\"\"\n        num_nodes = L + 2\n        nodes = set(range(num_nodes))\n        \n        # Handle L=0 case: no hyperedges, S0 is the whole set\n        if L  0: # Technically problem states L>=0, but as a guard\n            return 0\n        \n        hyperedges = []\n        if L >= 1:\n            for i in range(L):\n                hyperedges.append(frozenset({i, i + 1, i + 2}))\n\n        # --- LTM Simulation ---\n        active_ltm = {0, 1}\n        \n        # Build pairwise projection graph G if there are hyperedges\n        adj = {i: set() for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                u, v, w = he\n                adj[u].add(v)\n                adj[v].add(u)\n                adj[u].add(w)\n                adj[w].add(u)\n                adj[v].add(w)\n                adj[w].add(v)\n        \n        while True:\n            newly_activated_ltm = set()\n            inactive_nodes = nodes - active_ltm\n            if not inactive_nodes:\n                break\n                \n            for node in inactive_nodes:\n                active_neighbors_count = len(adj[node].intersection(active_ltm))\n                if active_neighbors_count >= m:\n                    newly_activated_ltm.add(node)\n            \n            if not newly_activated_ltm:\n                break\n            \n            active_ltm.update(newly_activated_ltm)\n        \n        final_size_ltm = len(active_ltm)\n\n        # --- HCM Simulation ---\n        active_hcm = {0, 1}\n        \n        # Pre-build a map from node to its containing hyperedges for efficiency\n        node_to_hyperedges = {i: [] for i in range(num_nodes)}\n        if hyperedges:\n            for he in hyperedges:\n                for node in he:\n                    node_to_hyperedges[node].append(he)\n            \n        while True:\n            newly_activated_hcm = set()\n            inactive_nodes = nodes - active_hcm\n            if not inactive_nodes:\n                break\n\n            for node in inactive_nodes:\n                is_activated = False\n                for he in node_to_hyperedges[node]:\n                    co_members = he - {node}\n                    active_co_members_count = len(co_members.intersection(active_hcm))\n                    if active_co_members_count >= s:\n                        is_activated = True\n                        break # Found an activating hyperedge\n                \n                if is_activated:\n                    newly_activated_hcm.add(node)\n\n            if not newly_activated_hcm:\n                break\n            \n            active_hcm.update(newly_activated_hcm)\n            \n        final_size_hcm = len(active_hcm)\n\n        return final_size_hcm - final_size_ltm\n\n    results = []\n    for L, m, s in test_cases:\n        gap = calculate_gap(L, m, s)\n        results.append(gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在识别了高阶交互的重要性之后，下一步是开发能够量化节点在这些结构中影响力的分析工具。本练习将引导您计算两种互补的中心性度量：简单的节点度和更复杂的张量特征向量中心性 。通过实现一个数值迭代算法来求解张量特征值问题，您将获得处理高阶网络代数表示的实践经验，并学会如何结合多种度量来对节点的影响力进行确定性的排序。",
            "id": "4126430",
            "problem": "考虑一个$3$-一致超图，其节点集为$\\{0,1,\\dots,n-1\\}$，超边集为$\\mathcal{E}$，其中每条超边是节点集的一个$3$-元素子集。目标是通过两种互补的中心性来计算节点影响力，并得出一个确定性的排名。计算必须基于适用于复杂自适应系统建模中高阶网络和超图的基本定义和经过充分检验的原则。\n\n定义与基础：\n- 一个$3$-一致超图是一个序对 $(V,\\mathcal{E})$，其中 $V=\\{0,1,\\dots,n-1\\}$ 且 $\\mathcal{E}\\subseteq \\{e\\subseteq V: |e|=3\\}$。\n- 节点 $i$ 的度中心性是 $d_i$，即 $\\mathcal{E}$ 中包含 $i$ 的超边的数量。\n- $3$-一致超图的邻接张量是一个3阶对称张量 $\\mathcal{A}\\in\\mathbb{R}^{n\\times n\\times n}$，其条目为\n$$\n\\mathcal{A}_{ijk}=\\begin{cases}\n\\frac{1}{2}  \\text{如果 } \\{i,j,k\\}\\in\\mathcal{E} \\text{ 且 } i,j,k \\text{ 两两不同},\\\\\n0  \\text{其他情况}。\n\\end{cases}\n$$\n- 张量特征向量中心性使用满足以下条件的 $Z$-特征对 $(\\lambda,x)$：\n$\\mathcal{A}x^2=\\lambda x$,\n其中 $(\\mathcal{A}x^2)_i=\\sum_{j,k=0}^{n-1}\\mathcal{A}_{ijk}x_j x_k$，$x\\in\\mathbb{R}_{\\ge 0}^n$，并且施加了如 $\\|x\\|_2=1$ 的归一化来固定尺度。对于非负、弱不可约张量，非负主特征向量的存在性可由推广到张量的 Perron–Frobenius (PF) 定理得出。\n- 一种用于$3$-一致超图的、避免了显式张量构造的计算上一致的缩并是：\n$(\\mathcal{A}x^2)_i=\\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x_j x_k$,\n这通过对称性和对所有排列求和的因子 $\\frac{1}{2}$ 与上述 $\\mathcal{A}$ 相匹配。\n\n您的程序必须为每个提供的测试超图执行以下操作：\n1. 计算度中心性向量 $d\\in\\mathbb{N}^n$，其条目为 $d_i$。\n2. 通过从 $\\mathcal{A}x^2=\\lambda x$ 导出的不动点迭代法计算非负张量 $Z$-特征向量中心性 $x\\in\\mathbb{R}_{\\ge 0}^n$：\n   - 用严格正的条目初始化 $x^{(0)}$，并用欧几里得范数 $\\|\\cdot\\|_2$ 对其进行归一化。\n   - 迭代 $x^{(t+1)}=\\frac{\\mathcal{A}(x^{(t)})^2}{\\|\\mathcal{A}(x^{(t)})^2\\|_2}$ 直到在欧几里得范数下收敛，即当 $\\|x^{(t+1)}-x^{(t)}\\|_2$ 低于一个容差时停止。如果 $\\|\\mathcal{A}(x^{(t)})^2\\|_2=0$，则中心性向量为零向量。\n   - 报告经 $\\|x\\|_2=1$ 归一化且其条目四舍五入到$6$位小数的收敛后的 $x$。\n3. 使用以下全序关系根据影响力对节点进行排名：\n   - 主键：张量特征向量中心性 $x_i$，降序排列，\n   - 次键：度中心性 $d_i$，降序排列，\n   - 第三键：节点索引 $i$，升序排列。\n   排名必须以节点索引列表的形式报告，从最有影响力到最没有影响力排列。\n\n测试套件：\n- 测试用例 $1$ (一般情况)：$n=5$，$\\mathcal{E}=\\{\\{0,1,2\\},\\{0,2,3\\},\\{0,3,4\\},\\{1,2,3\\}\\}$。\n- 测试用例 $2$ (带有孤立节点的边界情况)：$n=4$，$\\mathcal{E}=\\{\\{0,1,2\\}\\}$；节点 $3$ 是孤立的。\n- 测试用例 $3$ (对称正则情况)：$n=6$，$\\mathcal{E}=\\{\\{0,1,2\\},\\{0,3,4\\},\\{1,3,5\\},\\{2,4,5\\}\\}$。\n\n答案规范：\n- 对于每个测试用例，输出一个三元列表组 $[d,x,r]$，其中 $d$ 是整数 $d_i$ 的列表，$x$ 是浮点数 $x_i$ 的列表（每个都四舍五入到6位小数），$r$ 是表示节点排名的整数列表。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个测试用例一个元素，格式完全如下\n$$\n[[d^{(1)},x^{(1)},r^{(1)}],[d^{(2)},x^{(2)},r^{(2)}],[d^{(3)},x^{(3)},r^{(3)}]].\n$$\n不应打印任何额外文本。",
            "solution": "用户提供的问题是有效的。它在复杂网络理论和数值线性代数领域有科学依据，特别是关于超图和张量特征向量。该问题是适定的，所有定义、约束和目标都清晰而正式地陈述，从而导向一个唯一的可计算解。所有术语都是客观且数学上精确的。\n\n任务是计算一个$3$-一致超图中节点的两种中心性度量，然后基于这些度量得出一个确定性的排名。指定的度量是度中心性和张量特征向量中心性。\n\n### 1. 度中心性\n\n度中心性是一种基于节点在网络结构中的直接参与度来衡量其重要性的基本度量。对于超图而言，它是简单图中相应概念最直接的泛化。\n\n**定义**：节点 $i$ 的度中心性 $d_i$ 定义为包含节点 $i$ 的超边的数量。数学上，对于一个具有节点集 $V$ 和超边集 $\\mathcal{E}$ 的超图 $(V, \\mathcal{E})$，\n$$\nd_i = |\\{e \\in \\mathcal{E} : i \\in e\\}|\n$$\n\n**计算**：要计算一个有 $n$ 个节点的超图的度中心性向量 $d \\in \\mathbb{N}^n$，可以初始化一个大小为 $n$ 的零向量。然后，对于集合 $\\mathcal{E}$ 中的每条超边 $e = \\{v_1, v_2, v_3\\}$，节点 $v_1$、$v_2$ 和 $v_3$ 的度数计数各增加一。对所有超边重复此过程。\n\n### 2. 张量特征向量中心性\n\n度中心性捕捉的是局部影响力，而基于特征向量的中心性则传递地衡量节点的影响力。一个节点如果连接到其他重要节点，那么它就是重要的。对于超图，这种关系由邻接张量捕捉，它是邻接矩阵的一种高阶泛化。\n\n**邻接张量与特征值问题**：对于一个 $k$-一致超图，其相互作用由一个 $k$-阶邻接张量表示。对于给定的 $3$-一致超图，这是一个 $3$-阶张量 $\\mathcal{A} \\in \\mathbb{R}^{n \\times n \\times n}$。问题将其定义为\n$$\n\\mathcal{A}_{ijk}=\\begin{cases}\n\\frac{1}{2}   \\text{如果 } \\{i,j,k\\}\\in\\mathcal{E} \\text{ 且 } i,j,k \\text{ 两两不同},\\\\\n0  \\text{其他情况}。\n\\end{cases}\n$$\n因子 $1/2$ 是一个与对称张量的非零条目数量（即 $3! = 6$）相关的约定。问题陈述了每条超边 $\\{i,j,k\\}$ 的总贡献是 $\\mathcal{A}_{ijk}+\\mathcal{A}_{ikj}+\\mathcal{A}_{jik}+\\mathcal{A}_{jki}+\\mathcal{A}_{kij}+\\mathcal{A}_{kji} = 6 \\times \\frac{1}{2} = 3$。这是张量定义的一个细节；核心计算依赖于一种更直接的缩并。\n\n特征向量中心性向量 $x \\in \\mathbb{R}_{\\ge 0}^n$ 源自 $Z$-特征值方程：\n$$\n\\mathcal{A}x^2 = \\lambda x\n$$\n其中 $(\\mathcal{A}x^2)_i = \\sum_{j,k=0}^{n-1}\\mathcal{A}_{ijk}x_j x_k$。该方程表示节点 $i$ 的中心性 $x_i$ 与其共同构成超边的节点对 $(j,k)$ 的影响力总和成正比。\n\n**通过幂迭代法的计算方法**：构造和存储 $n \\times n \\times n$ 的张量 $\\mathcal{A}$ 计算成本高昂。问题提供了一种更高效、等价的缩并方式来计算张量-向量积 $\\mathcal{A}x^2$：\n$$\n(\\mathcal{A}x^2)_i = \\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x_j x_k\n$$\n这种形式通过直接遍历超边列表来避免实例化张量。\n\n主特征向量（与最大特征值 $\\lambda$ 相关联的那个）可以使用不动点幂迭代法找到。对于非负、不可约张量，非负主特征向量的存在性和唯一性由推广到张量的 Perron-Frobenius 定理保证。对于可约张量，如在具有孤立分量的超图中看到的那样，该方法仍然收敛到对应于主导分量的特征向量。\n\n迭代方案如下：\n1.  用严格正的条目（例如，全一向量）初始化一个向量 $x^{(0)}$，并将其归一化，使其欧几里得范数为 $1$：$\\|x^{(0)}\\|_2 = 1$。\n2.  对于 $t = 0, 1, 2, \\dots$，计算下一个迭代向量 $x^{(t+1)}$：\n    a.  计算未归一化的向量 $y^{(t+1)}$，其中 $y^{(t+1)}_i = (\\mathcal{A}(x^{(t)})^2)_i = \\sum_{\\{i,j,k\\}\\in\\mathcal{E}} x^{(t)}_j x^{(t)}_k$。\n    b.  如果 $\\|y^{(t+1)}\\|_2 = 0$，则中心性向量为零向量。这种情况发生在超图为空或初始向量位于零空间中时，通过正值初始化可以避免。\n    c.  归一化以获得下一个迭代向量：$x^{(t+1)} = \\frac{y^{(t+1)}}{\\|y^{(t+1)}\\|_2}$。\n3.  当连续向量之间的变化可忽略不计时，迭代停止，即对于一个小的容差 $\\epsilon$，有 $\\|x^{(t+1)} - x^{(t)}\\|_2  \\epsilon$。最终的 $x^{(t+1)}$ 就是所求的中心性向量。\n\n### 3. 确定性节点排名\n\n为了提供一个单一、明确的影响力排名，需要在节点集上建立一个全序关系。问题指定了使用三个键的字典序比较，这解决了使用单一度量可能出现的任何平局情况。\n\n**排名键**：\n1.  **主键**：张量特征向量中心性得分 $x_i$，按降序排列。具有较高特征向量中心性的节点被认为更具影响力。\n2.  **次键**：度中心性 $d_i$，按降序排列。这用于打破特征向量中心性相同的节点之间的平局。\n3.  **第三键**：节点索引 $i$，按升序排列。这是最终的平局决胜规则，确保在主键和次键都相等时能有唯一的排名。\n\n**步骤**：排名算法包括为每个节点 $i$ 创建一个形式为 $(x_i, d_i, i)$ 的元组列表。然后使用指定的复合键对该列表进行排序。最终的节点排名列表从排序后的元组中提取。\n\n通过整合这三个原则，我们可以构建一个鲁棒的算法来分析所提供的超图，并生成所需的三元组输出 $[d, x, r]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hypergraph centrality and ranking problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case)\n        {'n': 5, 'edges': [[0, 1, 2], [0, 2, 3], [0, 3, 4], [1, 2, 3]]},\n        # Test case 2 (boundary with isolated node)\n        {'n': 4, 'edges': [[0, 1, 2]]},\n        # Test case 3 (symmetric regular case)\n        {'n': 6, 'edges': [[0, 1, 2], [0, 3, 4], [1, 3, 5], [2, 4, 5]]}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n\n        # 1. Compute degree centrality\n        d = compute_degree_centrality(n, edges)\n\n        # 2. Compute tensor eigenvector centrality\n        x = compute_eigenvector_centrality(n, edges)\n\n        # 3. Rank nodes\n        r = rank_nodes(d, x)\n\n        # Format results for output\n        d_list = d.tolist()\n        x_list_rounded = [round(val, 6) for val in x]\n        r_list = r\n\n        all_results.append([d_list, x_list_rounded, r_list])\n\n    # Final print statement in the exact required format.\n    # Custom formatter to avoid spaces in the output string.\n    def format_list(lst, is_float=False):\n        if is_float:\n            return '[' + ','.join(f'{val:.6f}' for val in lst) + ']'\n        return '[' + ','.join(map(str, lst)) + ']'\n\n    results_str = []\n    for d, x, r in all_results:\n        case_str = f\"[{format_list(d)},{format_list(x, is_float=True)},{format_list(r)}]\"\n        results_str.append(case_str)\n    \n    print(f\"[{','.join(results_str)}]\")\n\ndef compute_degree_centrality(n, edges):\n    \"\"\"\n    Computes degree centrality for each node.\n    d_i is the number of hyperedges containing node i.\n    \"\"\"\n    degrees = np.zeros(n, dtype=int)\n    for edge in edges:\n        for node in edge:\n            degrees[node] += 1\n    return degrees\n\ndef compute_eigenvector_centrality(n, edges, tol=1e-9, max_iter=1000):\n    \"\"\"\n    Computes tensor eigenvector centrality using fixed-point power iteration.\n    \"\"\"\n    # 1. Initialize x_t0 with strictly positive entries and normalize\n    x = np.ones(n)\n    x = x / np.linalg.norm(x)\n\n    for _ in range(max_iter):\n        # 2a. Compute the unnormalized next vector y = A(x^2)\n        y = np.zeros(n)\n        for i, j, k in edges:\n            y[i] += x[j] * x[k]\n            y[j] += x[i] * x[k]\n            y[k] += x[i] * x[j]\n        \n        # 2b. Check for zero vector case\n        norm_y = np.linalg.norm(y)\n        if norm_y == 0:\n            return np.zeros(n)\n        \n        # 2c. Normalize to get the next iterate x_t1\n        x_next = y / norm_y\n        \n        # 3. Check for convergence\n        if np.linalg.norm(x_next - x)  tol:\n            return x_next\n        \n        x = x_next\n        \n    return x\n\ndef rank_nodes(d, x):\n    \"\"\"\n    Ranks nodes based on a three-key system:\n    1. Descending eigenvector centrality (x_i)\n    2. Descending degree centrality (d_i)\n    3. Ascending node index (i)\n    \"\"\"\n    n = len(d)\n    # Create a list of tuples (x_i, d_i, i) for sorting\n    nodes_with_metrics = [(x[i], d[i], i) for i in range(n)]\n\n    # Sort using a lambda function that implements the ranking logic\n    # Python's sort is stable. We use negative values for descending order.\n    nodes_with_metrics.sort(key=lambda item: (-item[0], -item[1], item[2]))\n\n    # Extract the ranked node indices\n    ranked_indices = [item[2] for item in nodes_with_metrics]\n    \n    return ranked_indices\n\nsolve()\n\n```"
        }
    ]
}