{
    "hands_on_practices": [
        {
            "introduction": "在快速热处理（RTP）系统中，加热效果取决于灯管的发射光谱与晶圆吸收光谱的匹配程度。此练习将深入探讨由普朗克定律描述的黑体辐射的基本物理原理。通过数值计算特定波长带内的能量分数，您将掌握精确建模热处理模拟中辐射源的核心技能。",
            "id": "4158476",
            "problem": "用于快速热处理 (RTP) 的钨卤灯阵列可被理想化为一组类黑体发射器，其灯丝温度约为 $T \\approx 3000\\,\\mathrm{K}$。对于晶圆-灯源耦合的辐射传热建模，一个关键的量是在波长区间 $[\\lambda_1,\\lambda_2]$ 内发射的总黑体发射功率的带限分数。从适用于半导体制造过程建模的基本辐射定律出发，实现一个程序来计算无量纲分数\n$F(\\lambda_1,\\lambda_2;T) = \\dfrac{\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda}{\\sigma T^4}$，\n其中 $E_\\lambda^{b}(T)$ 是光谱黑体发射功率，$\\sigma$ 是斯特藩-玻尔兹曼常数。您的推导必须从普朗克定律和总黑体发射功率的定义（斯特藩-玻尔兹曼定律）开始，并为适用于灯阵列建模的近红外区域的波段积分开发一种数值稳健的策略。不要假定任何预先制表的黑体分数函数；相反，应推导出一个数值稳定的积分表示，并指定一个具体的数值求积策略来对给定参数进行求值。\n\n您使用的所有物理常数必须是标准值并明确说明，所有计算必须在国际单位制 (SI) 中进行。最终报告的量 $F(\\lambda_1,\\lambda_2;T)$ 是无量纲的，并且必须以十进制数返回。\n\n您的程序必须为以下参数集测试套件评估 $F(\\lambda_1,\\lambda_2;T)$，每个参数集指定为 $(\\lambda_1,\\lambda_2,T)$：\n\n- 案例 A（类钨丝温度下的近红外波段）：$(0.8\\,\\mu\\mathrm{m},\\,2.5\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n- 案例 B（合理性检查，全光谱）：$(0\\,\\mu\\mathrm{m},\\,+\\infty\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n- 案例 C（类钨丝温度下的可见光波段）：$(0.4\\,\\mu\\mathrm{m},\\,0.7\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n- 案例 D（温度稍低的灯的近红外波段）：$(0.8\\,\\mu\\mathrm{m},\\,2.5\\,\\mu\\mathrm{m},\\,2800\\,\\mathrm{K})$。\n- 案例 E（简并波段）：$(1.0\\,\\mu\\mathrm{m},\\,1.0\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$。\n\n将 $+\\infty$ 解释为数学上的无穷大。不涉及角度。所有波长在使用前必须内部从微米转换为米。每个案例的输出必须是介于 $0$ 和 $1$ 之间的单个浮点数。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，“[resultA,resultB,resultC,resultD,resultE]”）。每个浮点结果必须四舍五入到 $8$ 位有效数字。不应打印其他任何文本。",
            "solution": "该问题要求计算总黑体发射功率的带限分数，这是辐射传热分析中的一个基本量，与快速热处理 (RTP) 系统的建模尤其相关。求解过程始于对问题陈述的验证，该陈述被认为是科学上合理、适定且客观的。该问题基于热物理学的既定原理，并直接适用于指定的工程背景。所有提供的参数都是现实的，并且要求是自洽的。\n\n问题的核心是评估无量纲分数 $F(\\lambda_1, \\lambda_2; T)$，其定义为：\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda}{\\int_{0}^{\\infty} E_\\lambda^{b}(T)\\, d\\lambda}\n$$\n分母表示总黑体发射功率，根据斯特藩-玻尔兹曼定律，它等于 $\\sigma T^4$。$E_\\lambda^{b}(T)$ 项是光谱黑体发射功率，由普朗克定律描述：\n$$\nE_\\lambda^{b}(T) = \\frac{2\\pi h c^2}{\\lambda^5 \\left(\\exp\\left(\\frac{hc}{\\lambda k_B T}\\right) - 1\\right)}\n$$\n其中 $h$ 是普朗克常数，$c$ 是真空中的光速，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\lambda$ 是波长。\n\n由于在小波长处存在 $\\lambda^5$ 项以及指数项中可能出现的浮点数上溢或下溢，直接对该表达式进行数值积分容易产生数值不稳定性。一个稳健的数值策略需要重新构建积分。这通过变量替换来实现，以使积分无量纲化。让我们定义一个无量纲变量 $x$ 为：\n$$\nx = \\frac{hc}{\\lambda k_B T}\n$$\n由此，我们可以用 $x$ 表示 $\\lambda$ 及其微分 $d\\lambda$：\n$$\n\\lambda = \\frac{hc}{x k_B T} \\quad \\implies \\quad d\\lambda = -\\frac{hc}{x^2 k_B T} dx\n$$\n积分限也随之改变。当 $\\lambda$ 从 $\\lambda_1$ 变为 $\\lambda_2$ 时，$x$ 从 $x_2 = \\frac{hc}{\\lambda_1 k_B T}$ 变为 $x_1 = \\frac{hc}{\\lambda_2 k_B T}$。\n\n将这些代入 $F(\\lambda_1, \\lambda_2; T)$ 的分子积分中：\n$$\n\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda = \\int_{x_2}^{x_1} \\frac{2\\pi h c^2}{\\left(\\frac{hc}{x k_B T}\\right)^5 \\left(e^x - 1\\right)} \\left(-\\frac{hc}{x^2 k_B T}\\right) dx\n$$\n通过反转积分限以抵消负号并简化代数项，我们得到：\n$$\n\\int_{x_1}^{x_2} \\frac{2\\pi h c^2 (k_B T)^5 x^5}{(hc)^5 (e^x - 1)} \\frac{h c}{x^2 k_B T} dx = \\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx\n$$\n分母，即总发射功率，是通过令 $\\lambda_1 \\to 0$ 和 $\\lambda_2 \\to \\infty$ 得到的，这对应于 $x_2 \\to \\infty$ 和 $x_1 \\to 0$：\n$$\n\\sigma T^4 = \\int_{0}^{\\infty} E_\\lambda^{b}(T)\\, d\\lambda = \\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx\n$$\n定积分 $\\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx$ 是与玻色-爱因斯坦积分相关的标准形式，其值为 $\\frac{\\pi^4}{15}$。这使得我们可以根据基本常数推导出斯特藩-玻尔兹曼常数 $\\sigma$：\n$$\n\\sigma = \\frac{2\\pi k_B^4}{h^3 c^2} \\frac{\\pi^4}{15} = \\frac{2\\pi^5 k_B^4}{15 h^3 c^2}\n$$\n\n现在，分数 $F(\\lambda_1, \\lambda_2; T)$ 可以表示为两个变换后积分的比值：\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{\\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx}{\\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx} = \\frac{\\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx}{\\frac{\\pi^4}{15}}\n$$\n这给出了最终要实现的数值稳定的表达式：\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{15}{\\pi^4} \\int_{\\frac{hc}{\\lambda_2 k_B T}}^{\\frac{hc}{\\lambda_1 k_B T}} \\frac{x^3}{e^x - 1} dx\n$$\n被积函数 $f(x) = \\frac{x^3}{e^x - 1}$ 是良态的，并且对于有限、非零的 $\\lambda_1, \\lambda_2$，积分是在一个有限区间上进行的。\n\n对于数值实现，使用以下国际单位制 (SI) 中的物理常数（2018 CODATA 值）：\n- 普朗克常数, $h = 6.62607015 \\times 10^{-34}$ J·s\n- 光速, $c = 299792458$ m/s\n- 玻尔兹曼常数, $k_B = 1.380649 \\times 10^{-23}$ J/K\n\n指定的数值求积策略是使用 `scipy.integrate` 库中的 `quad` 函数。该函数采用基于 QUADPACK FORTRAN 库的自适应求积方案，该方案对各种被积函数（包括在端点具有可积奇点的函数）都非常稳健。它还可以处理无穷积分限，这对于案例 B 是必需的。\n\n测试案例处理如下：\n- **案例 A, C, D**：使用有限、非零的积分限进行标准评估。波长从 $\\mu$m 转换为 m。\n- **案例 B $(\\lambda_1=0, \\lambda_2=\\infty)$**：$x$ 的积分限变为 $(\\infty, 0)$，因此积分是 $\\int_0^\\infty$。数值积分器将计算这个值，结果应为 $1.0$，作为归一化的验证。\n- **案例 E $(\\lambda_1=\\lambda_2)$**：积分限相同 ($x_1=x_2$)，因此积分为零。这通过一个条件检查直接返回 $0.0$ 来处理。\n\n为了保证数值精度，项 $e^x - 1$ 使用 `numpy.expm1(x)` 计算，这在 $x$ 值很小时能保持精度。还包括一个安全措施来处理被积函数中 $x$ 值非常大时可能出现的上溢，此时函数值会迅速趋于零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the blackbody radiation fraction problem for a suite of test cases.\n    The implementation follows the derivation of a numerically stable integral\n    representation of the band-limited emission fraction.\n    \"\"\"\n\n    # Physical Constants (2018 CODATA values, SI units)\n    H = 6.62607015e-34      # Planck constant (J.s)\n    C = 299792458.0         # Speed of light in vacuum (m/s)\n    K_B = 1.380649e-23      # Boltzmann constant (J/K)\n\n    # Second radiation constant, C2 = h*c/k_B (m.K)\n    C2 = H * C / K_B\n\n    def integrand(x):\n        \"\"\"\n        The non-dimensionalized integrand for the blackbody radiation function.\n        f(x) = x^3 / (exp(x) - 1).\n        \"\"\"\n        # Handle the limit at x=0, which is 0.\n        if x == 0:\n            return 0.0\n        # Prevent overflow for large x, where the integrand approaches zero.\n        # np.exp(709.78) is near floating point limit.\n        if x > 709.0:\n            return 0.0\n        # np.expm1(x) provides better precision for exp(x)-1 when x is small.\n        return x**3 / np.expm1(x)\n\n    def calculate_F(lambda1_micron, lambda2_micron, T_kelvin):\n        \"\"\"\n        Calculates the fraction of blackbody radiation F in the band [lambda1, lambda2]\n        at temperature T.\n\n        Args:\n            lambda1_micron (float): Start wavelength in micrometers.\n            lambda2_micron (float): End wavelength in micrometers.\n            T_kelvin (float): Temperature in Kelvin.\n\n        Returns:\n            float: The dimensionless fraction F.\n        \"\"\"\n        # Case E: Degenerate band of zero width\n        if lambda1_micron == lambda2_micron:\n            return 0.0\n        \n        # Convert wavelengths from micrometers to meters\n        lambda1_m = lambda1_micron * 1e-6\n        lambda2_m = lambda2_micron * 1e-6\n\n        # Calculate the dimensionless integration limits x = hc / (lambda * k_B * T)\n        # Note the inverse relationship between lambda and x.\n        \n        # Upper limit x2 corresponds to lower wavelength lambda1\n        if lambda1_m == 0.0:\n            x2 = np.inf\n        else:\n            x2 = C2 / (lambda1_m * T_kelvin)\n\n        # Lower limit x1 corresponds to upper wavelength lambda2\n        if np.isinf(lambda2_m):\n            x1 = 0.0\n        else:\n            x1 = C2 / (lambda2_m * T_kelvin)\n        \n        # The integral is over [x1, x2]\n        integral_val, _ = integrate.quad(integrand, x1, x2)\n        \n        # The total integral from 0 to infinity is pi^4 / 15\n        normalization_constant = 15.0 / (np.pi**4)\n        \n        return normalization_constant * integral_val\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda1_micron, lambda2_micron, T_kelvin)\n    test_cases = [\n        (0.8, 2.5, 3000.0),      # Case A\n        (0.0, np.inf, 3000.0),   # Case B\n        (0.4, 0.7, 3000.0),      # Case C\n        (0.8, 2.5, 2800.0),      # Case D\n        (1.0, 1.0, 3000.0),      # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda1, lambda2, T = case\n        fraction = calculate_F(lambda1, lambda2, T)\n        # Format the result to 8 significant figures\n        results.append(f\"{fraction:.8g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "辐射一经发射，其到达晶圆的路径便由系统几何结构决定，这一几何关系可通过角系数来量化。本练习侧重于角系数的定义以及模型验证这一关键实践。通过实现角系数的数值计算并将其与已知的解析解进行比较，您将练习构建可靠、精确的仿真工具所必需的基本验证步骤。",
            "id": "4158599",
            "problem": "您正在为半导体晶圆的快速热处理过程建立辐射交换模型，其中钨卤素灯组件在局部被理想化为一个与差分晶圆片元共轴的圆形发射盘。为了验证用于灯阵建模的辐射角系数的数值实现，请复现一个具有已知闭式解的典范构型，并报告其相对误差。\n\n从第一性原理出发，使用从表面 $A_1$ 到表面 $A_2$ 的漫灰辐射角系数的定义：\n$$\nF_{1 \\to 2} \\;=\\; \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, V \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1,\n$$\n其中 $r$ 是差分面积元之间的中心距，$\\theta_1$ 和 $\\theta_2$ 分别是发射点和接收点处视线与局部表面法线之间的夹角，而 $V$ 是二元可见性函数，如果两点相互可见则为 $1$，否则为 $0$。在此验证问题中，没有遮挡物，因此对于所有相互可见的点对，$V = 1$。\n\n考虑以下与快速热处理灯阵建模直接相关的几何构型：一个差分晶圆片元（建模为无穷小平坦区域）位于平面 $z=0$ 的原点，其法线沿 $+\\hat{z}$ 方向；一个与晶圆片元共轴的圆形灯代表盘，半径为 $R$，位于平面 $z=h$ 中，其法线沿 $-\\hat{z}$ 方向。该圆盘以 $z$ 轴为中心，并且从晶圆片元看，整个圆盘都是可见的。在此几何构型中，辐射角系数是无量纲的（答案中无需物理单位）。\n\n您的任务是：\n- 基于上述积分定义，直接为该几何构型实现一个从差分晶圆片元到圆形圆盘的角系数的数值估计量，无需调用任何预制表格公式。该数值估计量应对各种 $(R,h)$ 值（其中 $R \\ge 0$ 且 $h > 0$）都具有稳健性。\n- 独立地，为此几何构型从第一性原理推导出相应的解析闭式角系数，作为基准真相。\n- 对于每个测试案例，计算相对误差，其定义为\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert F_{\\text{num}} - F_{\\text{ana}} \\rvert}{\\max\\left( \\lvert F_{\\text{ana}} \\rvert, \\delta \\right)},\n$$\n其中 $F_{\\text{num}}$ 是数值估计的角系数，$F_{\\text{ana}}$ 是解析推导的角系数，$\\delta$ 是一个小的正常数，仅用于在 $F_{\\text{ana}} = 0$ 时避免除以零。使用 $\\delta = 10^{-12}$。\n\n测试套件：\n- 案例 1：$R = 0.05$，$h = 0.05$。\n- 案例 2：$R = 0.05$，$h = 0.10$。\n- 案例 3：$R = 0.10$，$h = 1.00$。\n- 案例 4：$R = 0.00$，$h = 0.05$。\n- 案例 5：$R = 0.10$，$h = 0.01$。\n\n所有半径和距离的单位均为米，但输出是无量纲的。您的程序应生成单行输出，其中包含五个测试案例的相对误差，按顺序以逗号分隔的列表形式，并用方括号括起来，每个值都四舍五入到八位有效数字并以科学记数法表示。例如，输出格式必须是\n“[x1,x2,x3,x4,x5]”\n每个 $x_i$ 都以科学记数法打印（例如，$1.23456789\\text{e-}06$）。不应打印任何其他文本。",
            "solution": "该问题是有效的。它在科学上基于辐射传热的原理，问题陈述清晰，为唯一解提供了足够的信息，并以客观、正式的语言表述。我们将着手解决。\n\n解决方案分四步进行：\n1.  将通用角系数积分针对给定几何构型进行特化。\n2.  推导角系数的解析（闭式）解 $F_{\\text{ana}}$。\n3.  基于该积分构建数值估计量 $F_{\\text{num}}$。\n4.  为每个测试案例计算相对误差 $\\varepsilon$。\n\n### 1. 角系数积分的特化\n\n从表面 $A_1$到表面 $A_2$ 的通用角系数定义如下：\n$$\nF_{1 \\to 2} \\;=\\; \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, V \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1\n$$\n在此问题中，表面 $A_1$ 是一个差分晶圆片元，我们可以表示为 $\\mathrm{d}A_1$。当 $A_1 \\to \\mathrm{d}A_1$ 时，对外层 $A_1$ 的积分被移除，而 $1/A_1$ 项变为 $1/\\mathrm{d}A_1$。因此，从差分面积到有限面积 $A_2$ 的角系数为：\n$$\nF_{\\mathrm{d}A_1 \\to A_2} \\;=\\; \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, \\mathrm{d}A_2\n$$\n这里，假定可见性 $V=1$。\n\n我们建立一个坐标系。差分片元 $\\mathrm{d}A_1$ 位于 $z=0$ 平面的原点 $(0, 0, 0)$，其表面法向量为 $\\mathbf{n}_1 = \\hat{\\mathbf{k}}$。表面 $A_2$ 是一个半径为 $R$ 的圆形圆盘，位于 $z=h$ 平面，以 $z$ 轴为中心。其指向片元的法向量为 $\\mathbf{n}_2 = -\\hat{\\mathbf{k}}$。\n\n我们在圆盘 $A_2$ 上考虑一个差分元 $\\mathrm{d}A_2$。在 $z=h$ 平面中使用极坐标 $(\\rho, \\phi)$，$\\mathrm{d}A_2$ 的位置向量为 $\\mathbf{p}_2 = \\rho \\cos\\phi \\, \\hat{\\mathbf{i}} + \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} + h \\, \\hat{\\mathbf{k}}$，其中 $0 \\le \\rho \\le R$ 且 $0 \\le \\phi  2\\pi$。差分面积为 $\\mathrm{d}A_2 = \\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\phi$。\n\n从 $\\mathrm{d}A_1$ 中心（原点）到 $\\mathrm{d}A_2$ 中心的向量是 $\\mathbf{r} = \\mathbf{p}_2$。距离 $r$ 是其模：\n$$\nr = |\\mathbf{r}| = \\sqrt{(\\rho \\cos\\phi)^2 + (\\rho \\sin\\phi)^2 + h^2} = \\sqrt{\\rho^2 + h^2}\n$$\n角 $\\theta_1$ 是法线 $\\mathbf{n}_1$ 与视线向量 $\\mathbf{r}$ 之间的夹角。\n$$\n\\cos \\theta_1 = \\frac{\\mathbf{r} \\cdot \\mathbf{n}_1}{|\\mathbf{r}| |\\mathbf{n}_1|} = \\frac{(\\rho \\cos\\phi \\, \\hat{\\mathbf{i}} + \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} + h \\, \\hat{\\mathbf{k}}) \\cdot (\\hat{\\mathbf{k}})}{\\sqrt{\\rho^2+h^2} \\cdot 1} = \\frac{h}{\\sqrt{\\rho^2+h^2}}\n$$\n角 $\\theta_2$ 是法线 $\\mathbf{n}_2$ 与从 $\\mathrm{d}A_2$ 指向 $\\mathrm{d}A_1$ 的视线向量（即 $-\\mathbf{r}$）之间的夹角。\n$$\n\\cos \\theta_2 = \\frac{(-\\mathbf{r}) \\cdot \\mathbf{n}_2}{|-\\mathbf{r}| |\\mathbf{n}_2|} = \\frac{(-\\rho \\cos\\phi \\, \\hat{\\mathbf{i}} - \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} - h \\, \\hat{\\mathbf{k}}) \\cdot (-\\hat{\\mathbf{k}})}{\\sqrt{\\rho^2+h^2} \\cdot 1} = \\frac{h}{\\sqrt{\\rho^2+h^2}}\n$$\n将这些表达式代入角系数积分中：\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\int_{0}^{2\\pi} \\int_{0}^{R} \\frac{1}{\\pi} \\left( \\frac{h}{\\sqrt{\\rho^2+h^2}} \\right) \\left( \\frac{h}{\\sqrt{\\rho^2+h^2}} \\right) \\frac{1}{(\\sqrt{\\rho^2+h^2})^2} (\\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\phi)\n$$\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\frac{1}{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{R} \\frac{h^2}{(\\rho^2+h^2)^2} \\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\phi\n$$\n被积函数与方位角 $\\phi$ 无关。对 $\\phi$ 的积分产生一个因子 $2\\pi$：\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\frac{2\\pi}{\\pi} \\int_{0}^{R} \\frac{h^2 \\rho}{(\\rho^2+h^2)^2} \\, \\mathrm{d}\\rho = 2h^2 \\int_{0}^{R} \\frac{\\rho}{(\\rho^2+h^2)^2} \\, \\mathrm{d}\\rho\n$$\n这个最终的一维积分为解析解和数值解奠定了基础。\n\n### 2. 解析解 ($F_{\\text{ana}}$)\n\n为了找到解析解，我们求解上面推导出的积分。我们使用换元法，令 $u = \\rho^2 + h^2$，这意味着 $\\mathrm{d}u = 2\\rho \\, \\mathrm{d}\\rho$，或者 $\\rho \\, \\mathrm{d}\\rho = \\frac{1}{2}\\mathrm{d}u$。积分限从 $\\rho=0 \\to \\rho=R$ 变为 $u=h^2 \\to u=R^2+h^2$。\n$$\nF_{\\text{ana}} = 2h^2 \\int_{h^2}^{R^2+h^2} \\frac{1}{u^2} \\left( \\frac{1}{2}\\mathrm{d}u \\right) = h^2 \\int_{h^2}^{R^2+h^2} u^{-2} \\, \\mathrm{d}u\n$$\n$$\nF_{\\text{ana}} = h^2 \\left[ -u^{-1} \\right]_{h^2}^{R^2+h^2} = h^2 \\left( -\\frac{1}{R^2+h^2} - \\left(-\\frac{1}{h^2}\\right) \\right)\n$$\n$$\nF_{\\text{ana}} = h^2 \\left( \\frac{1}{h^2} - \\frac{1}{R^2+h^2} \\right) = 1 - \\frac{h^2}{R^2+h^2}\n$$\n$$\nF_{\\text{ana}} = \\frac{(R^2+h^2) - h^2}{R^2+h^2} = \\frac{R^2}{R^2+h^2}\n$$\n这就是角系数的闭式解析表达式。\n\n### 3. 数值估计量 ($F_{\\text{num}}$)\n\n数值估计量 $F_{\\text{num}}$ 是通过使用高精度数值积分方法直接计算一维积分来实现的。我们将使用 `scipy.integrate.quad` 函数，这是一个用于此目的的稳健工具。要对 $\\rho$ 在区间 $[0, R]$ 上积分的函数是：\n$$\nf(\\rho; h) = \\frac{2h^2 \\rho}{(\\rho^2+h^2)^2}\n$$\n因此，对于每对参数 $(R, h)$，数值角系数计算如下：\n$$\nF_{\\text{num}}(R, h) = \\int_{0}^{R} f(\\rho; h) \\, \\mathrm{d}\\rho \\approx \\text{quad}(f, 0, R, \\text{args}=(h))\n$$\n这种方法遵循了问题要求，即“基于积分定义”并“为该几何构型适当特化”。\n\n### 4. 相对误差计算\n\n对于每个测试案例，我们计算 $F_{\\text{ana}}$ 和 $F_{\\text{num}}$。然后根据提供的公式计算相对误差 $\\varepsilon$：\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert F_{\\text{num}} - F_{\\text{ana}} \\rvert}{\\max\\left( \\lvert F_{\\text{ana}} \\rvert, \\delta \\right)}\n$$\n其中 $\\delta = 10^{-12}$。分母的设计是为了在 $F_{\\text{ana}}$ 为零时避免除以零，这在 $R=0$ 的测试案例中会发生。得到的五个误差值将被格式化并打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Calculates the relative error between numerical and analytical view factors\n    for five test cases and prints the results in the required format.\n    \"\"\"\n    \n    # Define test cases as a list of (R, h) tuples.\n    test_cases = [\n        (0.05, 0.05),  # Case 1\n        (0.05, 0.10),  # Case 2\n        (0.10, 1.00),  # Case 3\n        (0.00, 0.05),  # Case 4\n        (0.10, 0.01),  # Case 5\n    ]\n    \n    # Small constant for relative error calculation to avoid division by zero.\n    delta = 1.0e-12\n\n    results = []\n    \n    for R, h in test_cases:\n        # 1. Analytical Solution (F_ana)\n        # The closed-form solution is F_ana = R^2 / (R^2 + h^2).\n        # This is derived by analytically solving the view factor integral.\n        # Check for h  0 as per problem constraints.\n        if h = 0:\n            raise ValueError(\"Height h must be positive.\")\n        \n        # The formula is robust and handles R=0 correctly.\n        F_ana = R**2 / (R**2 + h**2)\n        \n        # 2. Numerical Solution (F_num)\n        # The numerical solution is obtained by integrating the simplified\n        # 1D view factor kernel using scipy.integrate.quad.\n        # The integrand is f(rho) = 2*h^2*rho / (rho^2 + h^2)^2.\n        \n        # Handle the R=0 case directly, as the integration interval is [0, 0].\n        if R == 0:\n            F_num = 0.0\n        else:\n            integrand = lambda rho, h_val: (2 * h_val**2 * rho) / (rho**2 + h_val**2)**2\n            # quad returns a tuple (result, error_estimate). We need the result.\n            F_num, _ = quad(integrand, 0, R, args=(h,))\n\n        # 3. Relative Error Calculation\n        # epsilon = |F_num - F_ana| / max(|F_ana|, delta)\n        abs_error = abs(F_num - F_ana)\n        denominator = max(abs(F_ana), delta)\n        relative_error = abs_error / denominator\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.7e}\" provides 8 significant figures.\n    formatted_results = [f\"{res:.7e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "RTP 建模的最终目标通常是控制工艺过程，例如，在整个晶圆上实现完全均匀的温度，这需要解决一个“逆问题”。本练习将辐射传热、对流传热和数值优化整合到一个综合的系统级模型中。通过确定达到目标温度所需的灯管功率，您将应对一个真实的工程设计挑战，从分析走向综合，并深入了解复杂热系统的控制。",
            "id": "4158567",
            "problem": "考虑一个快速热处理场景，其中一个圆形半导体晶圆由三个同心灯环加热。晶圆半径为 $R$，并被离散为 $N$ 个同心环形控制体积（节点）。每个灯环 $i \\in \\{1,2,3\\}$ 的半径为 $R_i$，位于晶圆平面上方高度 $H_i$ 处，并将其电功率 $P_i$ 的一部分 $\\eta_i$ 作为热辐射发射出去。晶圆被建模为发射率为 $\\varepsilon_w$ 的灰体漫射表面。假设腔室中充满了温度为 $T_{\\mathrm{gas}}$ 的静态气体，并具有均匀的对流传热系数 $h_c$。环境（腔室壁）温度为 $T_{\\mathrm{env}}$。角度必须以弧度处理。\n\n从第一性原理出发，起点如下：\n- Stefan–Boltzmann 定律：温度为 $T$ 的表面节点与温度为 $T_{\\mathrm{env}}$ 的环境之间的净辐射热交换为每单位面积 $q_{\\mathrm{rad}} = \\varepsilon_w \\sigma \\left(T^4 - T_{\\mathrm{env}}^4\\right)$，其中 $\\sigma$ 是 Stefan–Boltzmann 常数。\n- 各向同性点源的辐照度定义：接收器处的辐照度与距离的平方成反比，并包含一个等于入射角余弦的投影因子。\n- 每个环形节点在稳态下的能量守恒：吸收的辐射功率等于向环境的辐射发射和向气体的对流损失之和。\n\n将第 $i$ 个灯环建模为在晶圆上方高度 $H_i$、半径为 $R_i$ 的圆上均匀分布的一组各向同性点源。设一个平均半径为 $r_j$ 的节点 $j$ 位于晶圆平面上。对于方位角为 $\\alpha \\in [0,2\\pi)$ 的环形元素，该元素与节点之间的距离为 $d(\\alpha) = \\sqrt{H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha}$，入射余弦为 $H_i/d(\\alpha)$。环形元素的无穷小功率为 $\\mathrm{d}P_i = \\eta_i P_i \\mathrm{d}\\alpha / (2\\pi)$。\n\n综上所述，可得节点 $j$ 上由灯 $i$ 引起的辐照度，通过对环积分得到，并与下式成正比\n$$\nE_{ij} \\propto \\eta_i P_i H_i \\int_{0}^{2\\pi} \\frac{1}{d(\\alpha)^3}\\,\\mathrm{d}\\alpha.\n$$\n假设晶圆吸收入射辐射的一小部分 $\\varepsilon_w$（根据灰体表面的 Kirchhoff 定律），并将每个面积为 $A_j$ 的环形区域 $j$ 作为一个整体，则节点 $j$ 从灯 $i$ 吸收的功率与 $P_i$ 成线性关系。因此，存在一个耦合系数 $k_{ij}$，使得节点 $j$ 从所有灯吸收的总功率为 $\\sum_{i=1}^{3} k_{ij} P_i$。\n\n在稳态下，对每个节点强制执行能量平衡：\n$$\n\\sum_{i=1}^{3} k_{ij} P_i = \\varepsilon_w \\sigma A_j \\left(T_j^4 - T_{\\mathrm{env}}^4\\right) + h_c A_j \\left(T_j - T_{\\mathrm{gas}}\\right),\n$$\n其中 $T_j$ 是节点温度。对于在指定目标温度 $T_{\\mathrm{t}}$ 下的逆向设计，要求所有 $j$ 的 $T_j \\approx T_{\\mathrm{t}}$，误差在 $\\pm 5\\ \\mathrm{K}$ 以内。\n\n您的任务是实现一个完整的程序，该程序：\n1. 通过使用均匀的方位角离散化，对辐照度的环积分进行数值计算，从而从第一性原理构建几何耦合系数 $k_{ij}$。对 $\\alpha$ 使用弧度。\n2. 在目标温度 $T_{\\mathrm{t}}$ 下为每个节点建立稳态能量平衡，从而得到一个关于未知灯功率 $P_i$ 的线性系统。使用非负最小二乘法求解关于 $P = [P_1,P_2,P_3]$ 的非负逆问题，以便在最小二乘意义上匹配所有节点的目标。\n3. 通过使用计算出的灯功率求解每个节点的非线性能量平衡来验证所得的节点温度 $T_j$，并计算最大偏差 $\\max_j |T_j - T_{\\mathrm{t}}|$（单位为 K）。\n4. 对每个测试用例，输出三个灯功率（单位 W）和与 $T_{\\mathrm{t}}$ 的最大偏差（单位 K），后跟一个布尔值，指示是否满足偏差要求 $\\leq 5\\ \\mathrm{K}$。功率必须以瓦特 (W) 表示，温度以开尔文 (K) 表示。\n\n全过程使用 Stefan–Boltzmann 常数 $\\sigma = 5.670374419\\times 10^{-8}\\ \\mathrm{W\\,m^{-2}\\,K^{-4}}$ 和国际单位制 (SI)。所有角度必须以弧度为单位。\n\n测试套件：\n- 案例1（正常路径）：$R = 0.10\\ \\mathrm{m}$, $N = 11$, $R_1 = 0.03\\ \\mathrm{m}$, $R_2 = 0.06\\ \\mathrm{m}$, $R_3 = 0.09\\ \\mathrm{m}$, $H_1 = H_2 = H_3 = 0.08\\ \\mathrm{m}$, $\\eta_1=\\eta_2=\\eta_3=0.75$, $\\varepsilon_w = 0.70$, $h_c = 10\\ \\mathrm{W\\,m^{-2}\\,K^{-1}}$, $T_{\\mathrm{env}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{gas}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{t}}=1000\\ \\mathrm{K}$。\n- 案例2（边界发射率）：与案例1相同，但 $\\varepsilon_w = 0.30$。\n- 案例3（几何边缘情况）：$R = 0.10\\ \\mathrm{m}$, $N = 11$, $R_1 = 0.02\\ \\mathrm{m}$, $R_2 = 0.04\\ \\mathrm{m}$, $R_3 = 0.08\\ \\mathrm{m}$, $H_1 = H_2 = H_3 = 0.05\\ \\mathrm{m}$, $\\eta_1=0.70$, $\\eta_2=0.75$, $\\eta_3=0.80$, $\\varepsilon_w = 0.60$, $h_c = 8\\ \\mathrm{W\\,m^{-2}\\,K^{-1}}$, $T_{\\mathrm{env}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{gas}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{t}}=1000\\ \\mathrm{K}$。\n\n数值要求：\n- 对每个灯-节点耦合，使用至少 $M=720$ 个方位角点来近似积分。\n- 将晶圆节点分布在半径 $r_j = \\left(j - \\tfrac{1}{2}\\right)\\Delta r$ 处，其中 $j=1,\\dots,N$，$\\Delta r = R/N$，并使用精确的环形面积 $A_j = \\pi\\left((r_j+\\tfrac{\\Delta r}{2})^2 - (r_j-\\tfrac{\\Delta r}{2})^2\\right)$。\n- 在计算 $P_i$ 后验证温度 $T_j$ 时，在 $T \\in [300\\ \\mathrm{K}, 1400\\ \\mathrm{K}]$ 的范围内为每个节点稳健地求解非线性平衡。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形式为 $[P_1,P_2,P_3,\\Delta_{\\max},\\mathrm{compliant}]$ 的列表，其中 $P_i$ 的单位是 W，$\\Delta_{\\max}$ 的单位是 K。例如，输出应如下所示：\n$[[P1\\_case1,P2\\_case1,P3\\_case1,\\Delta\\_max\\_case1,\\mathrm{True}],[P1\\_case2,\\dots],[P1\\_case3,\\dots]]$。\n- 所有数值输出必须是浮点数（功率和偏差四舍五入到三位小数）或布尔值。整个输出必须打印为单行。",
            "solution": "用户提供的问题是一个定义明确、具有科学依据的计算传热学任务，专门针对半导体制造过程建模。它要求在快速热处理（RTP）系统中确定最佳灯功率，以实现均匀的晶圆温度。该问题是自洽的，提供了所有必要的物理参数、常数和控制方程。验证是成功的。\n\n该解决方案是通过遵循一系列源自热科学第一性原理和数值方法的步骤来实现的。\n\n**1. 系统离散化与几何参数**\n\n该模型首先对物理系统进行离散化。半径为 $R$ 的圆形晶圆被划分为 $N$ 个同心环形控制体积，或称节点。第 $j$ 个节点（$j=1, \\dots, N$）由其平均半径 $r_j$ 和面积 $A_j$ 表征。\n- 每个环的径向宽度为 $\\Delta r = R/N$。\n- 第 $j$ 个节点的平均半径定义在环的中心：$r_j = (j - 1/2) \\Delta r$。\n- 第 $j$ 个环的面积，其内半径为 $(j-1)\\Delta r$，外半径为 $j\\Delta r$，精确值为 $A_j = \\pi((j\\Delta r)^2 - ((j-1)\\Delta r)^2)$。这可简化为 $A_j = 2\\pi r_j \\Delta r$。\n\n**2. 辐射耦合矩阵 ($\\mathbf{K}$) 的构建**\n\n核心任务是在每个灯环的电功率 $P_i$ 与每个晶圆节点 $j$ 吸收的热功率之间建立线性关系。这种关系由一组耦合系数 $k_{ij}$ 捕获。\n\n每个灯环 $i$ 被建模为位于半径 $R_i$ 和高度 $H_i$ 处的一个由各向同性点源组成的连续圆环。位于方位角 $\\alpha$ 的环的一个无穷小段发射总环功率的一部分。来自该段的辐射功率为 $\\mathrm{d}P_i^{\\mathrm{rad}} = \\eta_i P_i \\frac{\\mathrm{d}\\alpha}{2\\pi}$。对于各向同性源，辐射强度（单位立体角的功率）为 $I = \\mathrm{d}P_i^{\\mathrm{rad}} / (4\\pi)$。\n\n来自此源元素的晶圆上一点（半径为 $r_j$）的无穷小辐照度 $\\mathrm{d}E_{ij}$ 由平方反比定律给出，其中包括一个投影因子 ($\\cos\\theta$)：\n$$ \\mathrm{d}E_{ij}(\\alpha) = I \\frac{\\cos\\theta}{d(\\alpha)^2} $$\n其中 $d(\\alpha)$ 是从源元素到晶圆点的距离，$\\theta$ 是入射角。几何关系决定了：\n- 距离：$d(\\alpha) = \\sqrt{H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha}$\n- 入射余弦：$\\cos\\theta = H_i / d(\\alpha)$\n\n将这些代入辐照度方程，并对整个环（$\\alpha$ 从 $0$ 到 $2\\pi$）进行积分，得到来自灯环 $i$ 在半径 $r_j$ 处的总辐照度 $E_{ij}$：\n$$ E_{ij} = \\int_{0}^{2\\pi} \\frac{\\eta_i P_i \\mathrm{d}\\alpha / (2\\pi)}{4\\pi} \\frac{H_i/d(\\alpha)}{d(\\alpha)^2} = \\frac{\\eta_i H_i P_i}{8\\pi^2} \\int_{0}^{2\\pi} \\frac{1}{\\left(H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha\\right)^{3/2}} \\, \\mathrm{d}\\alpha $$\n晶圆节点 $j$ 从灯 $i$ 吸收的功率为 $Q_{\\mathrm{abs}, ij} = \\varepsilon_w A_j E_{ij}$，其中 $\\varepsilon_w$ 是晶圆发射率（根据灰体表面的 Kirchhoff 定律，也是吸收率）。该吸收功率与 $P_i$ 成线性关系，因此我们可以写成 $Q_{\\mathrm{abs}, ij} = k_{ij} P_i$。耦合系数 $k_{ij}$ 因此为：\n$$ k_{ij} = \\frac{\\varepsilon_w A_j \\eta_i H_i}{8\\pi^2} \\int_{0}^{2\\pi} \\frac{1}{\\left(H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha\\right)^{3/2}} \\, \\mathrm{d}\\alpha $$\n这个定积分通过数值方法计算。我们将角度 $\\alpha$ 离散为 $M$ 个点，$\\alpha_k = k \\cdot (2\\pi/M)$，$k=0, \\dots, M-1$，步长为 $\\Delta\\alpha = 2\\pi/M$。积分通过 Riemann 和近似：\n$$ \\int_{0}^{2\\pi} f(\\alpha) \\, \\mathrm{d}\\alpha \\approx \\sum_{k=0}^{M-1} f(\\alpha_k) \\Delta\\alpha $$\n对每个灯-节点对 $(i,j)$ 执行此计算，得出 $N \\times 3$ 的耦合矩阵 $\\mathbf{K}$。\n\n**3. 逆问题：灯功率计算**\n\n为在整个晶圆上实现均匀的目标温度 $T_t$，每个节点吸收的功率必须与在该温度下损失的热量相平衡。在温度 $T_t$ 下，节点 $j$ 的总热损失是辐射和对流损失之和：\n$$ Q_j^{\\mathrm{target}} = \\varepsilon_w \\sigma A_j (T_t^4 - T_{\\mathrm{env}}^4) + h_c A_j (T_t - T_{\\mathrm{gas}}) $$\n其中 $\\sigma$ 是 Stefan–Boltzmann 常数。\n\n节点 $j$ 的总吸收功率是所有灯贡献的总和：$\\sum_{i=1}^{3} k_{ij} P_i$。将此值与每个节点的目标损失相等，得到一个线性方程组：\n$$ \\sum_{i=1}^{3} k_{ij} P_i = Q_j^{\\mathrm{target}} \\quad \\text{for } j=1, \\dots, N $$\n用矩阵表示法，即为 $\\mathbf{K} \\mathbf{P} = \\mathbf{Q}^{\\mathrm{target}}$，其中 $\\mathbf{P} = [P_1, P_2, P_3]^T$ 是未知灯功率的向量，$\\mathbf{Q}^{\\mathrm{target}}$ 是目标热损失的 $N \\times 1$ 向量。由于 $N=11$ 且灯的数量为 $3$，这是一个超定系统。为了找到一个物理上有意义的解，其中功率为非负值 ($P_i \\ge 0$)，我们求解非负最小二乘（NNLS）问题：\n$$ \\min_{\\mathbf{P} \\ge 0} || \\mathbf{K} \\mathbf{P} - \\mathbf{Q}^{\\mathrm{target}} ||_2^2 $$\n该解提供了最优的非负功率 $P_1, P_2, P_3$，这些功率能最好地在所有节点上实现目标热负荷。\n\n**4. 正问题：温度验证**\n\n利用计算出的灯功率 $\\mathbf{P}^*$，我们必须验证实际的温度分布。每个节点 $j$ 实际吸收的功率为 $Q_j^{\\mathrm{actual}} = \\sum_{i=1}^{3} k_{ij} P_i^*$。然后，通过求解非线性能量平衡方程来找到每个节点的实际稳态温度 $T_j$：\n$$ Q_j^{\\mathrm{actual}} = \\varepsilon_w \\sigma A_j (T_j^4 - T_{\\mathrm{env}}^4) + h_c A_j (T_j - T_{\\mathrm{gas}}) $$\n这等效于找到函数 $f(T_j) = 0$ 的根，其中：\n$$ f(T_j) = \\varepsilon_w \\sigma A_j T_j^4 + h_c A_j T_j - \\left( Q_j^{\\mathrm{actual}} + \\varepsilon_w \\sigma A_j T_{\\mathrm{env}}^4 + h_c A_j T_{\\mathrm{gas}} \\right) $$\n对于 $T_j  0$，此函数是单调的，保证了唯一的正解。我们使用数值求根算法，例如 Brent's method，在指定的范围 $[300\\ \\mathrm{K}, 1400\\ \\mathrm{K}]$ 内找到每个 $T_j$。\n\n最后，通过与目标的最大偏差来评估温度均匀性：\n$$ \\Delta_{\\max} = \\max_{j=1, \\dots, N} |T_j - T_t| $$\n如果此偏差不大于 $5\\ \\mathrm{K}$，则该过程是合规的。每个测试用例的最终输出包括计算出的功率 $[P_1, P_2, P_3]$、最大偏差 $\\Delta_{\\max}$ 和合规状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls, brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the RTP lamp power design problem for all test cases.\n    \"\"\"\n    # Define physical constant\n    SIGMA = 5.670374419e-8  # Stefan-Boltzmann constant, W m^-2 K^-4\n\n    # Define numerical parameters\n    M = 720  # Number of azimuthal points for integration\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.03, 0.06, 0.09]),\n            \"H_lamps\": np.array([0.08, 0.08, 0.08]),\n            \"eta_lamps\": np.array([0.75, 0.75, 0.75]),\n            \"epsilon_w\": 0.70, \"h_c\": 10.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        },\n        # Case 2 (boundary emissivity)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.03, 0.06, 0.09]),\n            \"H_lamps\": np.array([0.08, 0.08, 0.08]),\n            \"eta_lamps\": np.array([0.75, 0.75, 0.75]),\n            \"epsilon_w\": 0.30, \"h_c\": 10.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        },\n        # Case 3 (geometric edge case)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.02, 0.04, 0.08]),\n            \"H_lamps\": np.array([0.05, 0.05, 0.05]),\n            \"eta_lamps\": np.array([0.70, 0.75, 0.80]),\n            \"epsilon_w\": 0.60, \"h_c\": 8.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters\n        R = case[\"R\"]\n        N = case[\"N\"]\n        R_lamps = case[\"R_lamps\"]\n        H_lamps = case[\"H_lamps\"]\n        eta_lamps = case[\"eta_lamps\"]\n        epsilon_w = case[\"epsilon_w\"]\n        h_c = case[\"h_c\"]\n        T_env = case[\"T_env\"]\n        T_gas = case[\"T_gas\"]\n        T_t = case[\"T_t\"]\n        \n        num_lamps = len(R_lamps)\n\n        # Step 1: Wafer discretization\n        dr = R / N\n        r_nodes = (np.arange(1, N + 1) - 0.5) * dr\n        # Exact area of each annulus is 2*pi*r_j*dr\n        A_nodes = 2 * np.pi * r_nodes * dr\n\n        # Step 2: Construct the coupling matrix K\n        K_matrix = np.zeros((N, num_lamps))\n        \n        alpha_k = np.linspace(0, 2 * np.pi, M, endpoint=False)\n        d_alpha = 2 * np.pi / M\n\n        for i in range(num_lamps):  # For each lamp ring\n            for j in range(N):  # For each wafer node\n                R_i, H_i, r_j = R_lamps[i], H_lamps[i], r_nodes[j]\n                \n                # Distance squared from source element to wafer point\n                dist_sq = H_i**2 + R_i**2 + r_j**2 - 2 * R_i * r_j * np.cos(alpha_k)\n                \n                # Integrand is 1 / d(alpha)^3\n                integrand = dist_sq**(-1.5)\n                \n                # Numerical integration using Riemann sum\n                integral_val = np.sum(integrand) * d_alpha\n                \n                # Calculate the coupling coefficient k_ij\n                k_ij = (epsilon_w * A_nodes[j] * eta_lamps[i] * H_i) / (8 * np.pi**2) * integral_val\n                K_matrix[j, i] = k_ij\n\n        # Step 3: Solve inverse problem for lamp powers P\n        # Calculate target heat loss vector Q_target for T_t\n        rad_loss = epsilon_w * SIGMA * A_nodes * (T_t**4 - T_env**4)\n        conv_loss = h_c * A_nodes * (T_t - T_gas)\n        Q_target = rad_loss + conv_loss\n\n        # Solve the Nonnegative Least Squares problem: min ||K*P - Q_target||_2^2 s.t. P = 0\n        P_lamps, _ = nnls(K_matrix, Q_target)\n\n        # Step 4: Verify temperatures and compute deviation\n        # Calculate actual absorbed power Q_actual = K * P\n        Q_actual = K_matrix @ P_lamps\n        \n        T_nodes = np.zeros(N)\n        for j in range(N):\n            A_j = A_nodes[j]\n            Q_abs_j = Q_actual[j]\n\n            # Define the energy balance equation f(T) = 0 for the root finder\n            def energy_balance(T):\n                power_out = epsilon_w * SIGMA * A_j * (T**4 - T_env**4) + h_c * A_j * (T - T_gas)\n                return power_out - Q_abs_j\n\n            # Solve for T_j using Brent's method in the specified range\n            T_nodes[j] = brentq(energy_balance, 300.0, 1400.0)\n\n        # Compute maximum deviation from target temp and check compliance\n        delta_max = np.max(np.abs(T_nodes - T_t))\n        is_compliant = delta_max = 5.0\n\n        # Store results for this case in the required format\n        result_list = [round(p, 3) for p in P_lamps]\n        result_list.append(round(delta_max, 3))\n        result_list.append(is_compliant)\n        results.append(result_list)\n\n    # Construct the final output string to match the exact format requested\n    # (no spaces within or between list elements)\n    inner_strs = []\n    for res_list in results:\n        # String representation for one case: [P1,P2,P3,delta,compliant]\n        s = f\"[{res_list[0]},{res_list[1]},{res_list[2]},{res_list[3]},{str(res_list[4])}]\"\n        inner_strs.append(s)\n    \n    final_output_str = f\"[{','.join(inner_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}