{
    "hands_on_practices": [
        {
            "introduction": "Accurate modeling of a Rapid Thermal Processing system begins with a precise characterization of the energy source. While tungsten-halogen lamps are often approximated as blackbody emitters, the silicon wafer's absorption of radiation is highly dependent on wavelength. This practice  challenges you to compute the fraction of energy a lamp emits within specific spectral bands by deriving a numerically stable integral from Planck's law, a foundational skill for developing spectrally-resolved thermal models.",
            "id": "4158476",
            "problem": "A tungsten-halogen lamp array used in Rapid Thermal Processing (RTP) can be idealized as a collection of blackbody-like emitters with a filament temperature around $T \\approx 3000\\,\\mathrm{K}$. For radiative heat transfer modeling of the wafer-lamp coupling, an essential quantity is the band-limited fraction of the total blackbody emissive power emitted within a wavelength interval $[\\lambda_1,\\lambda_2]$. Starting from fundamental radiation laws appropriate for semiconductor manufacturing process modeling, implement a program that computes the dimensionless fraction\n$F(\\lambda_1,\\lambda_2;T) = \\dfrac{\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda}{\\sigma T^4}$,\nwhere $E_\\lambda^{b}(T)$ is the spectral blackbody emissive power and $\\sigma$ is the Stefan–Boltzmann constant. Your derivation must begin with Planck’s law and the definition of total blackbody emissive power (the Stefan–Boltzmann law), and develop a numerically robust strategy appropriate for band integration in the near-infrared regime relevant to lamp array modeling. Do not assume any pre-tabulated blackbody fraction functions; instead, derive a numerically stable integral representation and specify a concrete numerical quadrature strategy to evaluate it for given parameters.\n\nAll physical constants you use must be standard and explicitly stated, and all calculations must be performed in the International System of Units (SI). The final reported quantity $F(\\lambda_1,\\lambda_2;T)$ is dimensionless and must be returned as a decimal number.\n\nYour program must evaluate $F(\\lambda_1,\\lambda_2;T)$ for the following test suite of parameter sets, each specified as $(\\lambda_1,\\lambda_2,T)$:\n\n- Case A (near-infrared band at tungsten-like temperature): $(0.8\\,\\mu\\mathrm{m},\\,2.5\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$.\n- Case B (sanity check, full spectrum): $(0\\,\\mu\\mathrm{m},\\,+\\infty\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$.\n- Case C (visible band at tungsten-like temperature): $(0.4\\,\\mu\\mathrm{m},\\,0.7\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$.\n- Case D (near-infrared band at slightly cooler lamp): $(0.8\\,\\mu\\mathrm{m},\\,2.5\\,\\mu\\mathrm{m},\\,2800\\,\\mathrm{K})$.\n- Case E (degenerate band): $(1.0\\,\\mu\\mathrm{m},\\,1.0\\,\\mu\\mathrm{m},\\,3000\\,\\mathrm{K})$.\n\nInterpret $+\\infty$ as mathematical infinity. Angles are not involved. All wavelengths must be internally converted from micrometers to meters before use. The output for each case must be a single floating-point number between $0$ and $1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD,resultE]\"). Each floating-point result must be rounded to $8$ significant figures. No other text should be printed.",
            "solution": "The problem requires the computation of the band-limited fraction of total blackbody emissive power, a fundamental quantity in radiative heat transfer analysis, particularly relevant to modeling Rapid Thermal Processing (RTP) systems. The solution procedure begins with a validation of the problem statement, which is found to be scientifically sound, well-posed, and objective. The problem is based on established principles of thermal physics and is directly applicable to the specified engineering context. All provided parameters are realistic, and the requirements are self-consistent.\n\nThe core of the problem is to evaluate the dimensionless fraction $F(\\lambda_1, \\lambda_2; T)$ defined as:\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda}{\\int_{0}^{\\infty} E_\\lambda^{b}(T)\\, d\\lambda}\n$$\nThe denominator represents the total blackbody emissive power, which, according to the Stefan–Boltzmann law, is equal to $\\sigma T^4$. The term $E_\\lambda^{b}(T)$ is the spectral blackbody emissive power, described by Planck’s law:\n$$\nE_\\lambda^{b}(T) = \\frac{2\\pi h c^2}{\\lambda^5 \\left(\\exp\\left(\\frac{hc}{\\lambda k_B T}\\right) - 1\\right)}\n$$\nwhere $h$ is the Planck constant, $c$ is the speed of light in vacuum, $k_B$ is the Boltzmann constant, $T$ is the absolute temperature, and $\\lambda$ is the wavelength.\n\nDirect numerical integration of this expression is prone to numerical instability due to the $\\lambda^5$ term at small wavelengths and potential floating-point overflow or underflow in the exponential term. A robust numerical strategy requires reformulating the integral. This is achieved through a change of variables to non-dimensionalize the integral. Let us define a dimensionless variable $x$ as:\n$$\nx = \\frac{hc}{\\lambda k_B T}\n$$\nFrom this, we can express $\\lambda$ and its differential $d\\lambda$ in terms of $x$:\n$$\n\\lambda = \\frac{hc}{x k_B T} \\quad \\implies \\quad d\\lambda = -\\frac{hc}{x^2 k_B T} dx\n$$\nThe integration limits also change. As $\\lambda$ goes from $\\lambda_1$ to $\\lambda_2$, $x$ goes from $x_2 = \\frac{hc}{\\lambda_1 k_B T}$ to $x_1 = \\frac{hc}{\\lambda_2 k_B T}$.\n\nSubstituting these into the integral in the numerator of $F(\\lambda_1, \\lambda_2; T)$:\n$$\n\\int_{\\lambda_1}^{\\lambda_2} E_\\lambda^{b}(T)\\, d\\lambda = \\int_{x_2}^{x_1} \\frac{2\\pi h c^2}{\\left(\\frac{hc}{x k_B T}\\right)^5 \\left(e^x - 1\\right)} \\left(-\\frac{hc}{x^2 k_B T}\\right) dx\n$$\nBy reversing the integration limits to cancel the negative sign and simplifying the algebraic terms, we get:\n$$\n\\int_{x_1}^{x_2} \\frac{2\\pi h c^2 (k_B T)^5 x^5}{(hc)^5 (e^x - 1)} \\frac{h c}{x^2 k_B T} dx = \\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx\n$$\nThe denominator, the total emissive power, is found by letting $\\lambda_1 \\to 0$ and $\\lambda_2 \\to \\infty$, which corresponds to $x_2 \\to \\infty$ and $x_1 \\to 0$:\n$$\n\\sigma T^4 = \\int_{0}^{\\infty} E_\\lambda^{b}(T)\\, d\\lambda = \\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx\n$$\nThe definite integral $\\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx$ is a standard form related to the Bose-Einstein integral and evaluates to $\\frac{\\pi^4}{15}$. This allows for a derivation of the Stefan-Boltzmann constant $\\sigma$ in terms of fundamental constants:\n$$\n\\sigma = \\frac{2\\pi k_B^4}{h^3 c^2} \\frac{\\pi^4}{15} = \\frac{2\\pi^5 k_B^4}{15 h^3 c^2}\n$$\n\nNow, the fraction $F(\\lambda_1, \\lambda_2; T)$ can be expressed as the ratio of the two transformed integrals:\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{\\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx}{\\left(\\frac{2\\pi k_B^4}{h^3 c^2}\\right) T^4 \\int_{0}^{\\infty} \\frac{x^3}{e^x - 1} dx} = \\frac{\\int_{x_1}^{x_2} \\frac{x^3}{e^x - 1} dx}{\\frac{\\pi^4}{15}}\n$$\nThis gives the final, numerically stable expression to be implemented:\n$$\nF(\\lambda_1,\\lambda_2;T) = \\frac{15}{\\pi^4} \\int_{\\frac{hc}{\\lambda_2 k_B T}}^{\\frac{hc}{\\lambda_1 k_B T}} \\frac{x^3}{e^x - 1} dx\n$$\nThe integrand, $f(x) = \\frac{x^3}{e^x - 1}$, is well-behaved and the integration is over a finite interval for finite, non-zero $\\lambda_1, \\lambda_2$.\n\nFor the numerical implementation, the following physical constants (2018 CODATA values) are used in SI units:\n- Planck constant, $h = 6.62607015 \\times 10^{-34}$ J·s\n- Speed of light, $c = 299792458$ m/s\n- Boltzmann constant, $k_B = 1.380649 \\times 10^{-23}$ J/K\n\nThe specified numerical quadrature strategy is to use the `quad` function from the `scipy.integrate` library. This function employs an adaptive quadrature scheme based on the QUADPACK FORTRAN library, which is robust for a wide variety of integrands, including those with integrable singularities at the endpoints. It can also handle infinite integration limits, which is necessary for Case B.\n\nThe test cases are handled as follows:\n- **Cases A, C, D**: Standard evaluation with finite, non-zero limits. Wavelengths are converted from $\\mu$m to m.\n- **Case B $(\\lambda_1=0, \\lambda_2=\\infty)$**: The integration limits for $x$ become $(\\infty, 0)$, so the integral is $\\int_0^\\infty$. The numerical integrator will compute this, and the result should be $1.0$, serving as a validation of the normalization.\n- **Case E $(\\lambda_1=\\lambda_2)$**: The integration limits are identical ($x_1=x_2$), so the integral is zero. This is handled with a conditional check to return $0.0$ directly.\n\nFor numerical precision, the term $e^x - 1$ is computed using `numpy.expm1(x)`, which maintains accuracy for small values of $x$. A safeguard is also included to handle potential overflow for very large $x$ in the integrand, where the function value tends to zero rapidly.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the blackbody radiation fraction problem for a suite of test cases.\n    The implementation follows the derivation of a numerically stable integral\n    representation of the band-limited emission fraction.\n    \"\"\"\n\n    # Physical Constants (2018 CODATA values, SI units)\n    H = 6.62607015e-34      # Planck constant (J.s)\n    C = 299792458.0         # Speed of light in vacuum (m/s)\n    K_B = 1.380649e-23      # Boltzmann constant (J/K)\n\n    # Second radiation constant, C2 = h*c/k_B (m.K)\n    C2 = H * C / K_B\n\n    def integrand(x):\n        \"\"\"\n        The non-dimensionalized integrand for the blackbody radiation function.\n        f(x) = x^3 / (exp(x) - 1).\n        \"\"\"\n        # Handle the limit at x=0, which is 0.\n        if x == 0:\n            return 0.0\n        # Prevent overflow for large x, where the integrand approaches zero.\n        # np.exp(709.78) is near floating point limit.\n        if x > 709.0:\n            return 0.0\n        # np.expm1(x) provides better precision for exp(x)-1 when x is small.\n        return x**3 / np.expm1(x)\n\n    def calculate_F(lambda1_micron, lambda2_micron, T_kelvin):\n        \"\"\"\n        Calculates the fraction of blackbody radiation F in the band [lambda1, lambda2]\n        at temperature T.\n\n        Args:\n            lambda1_micron (float): Start wavelength in micrometers.\n            lambda2_micron (float): End wavelength in micrometers.\n            T_kelvin (float): Temperature in Kelvin.\n\n        Returns:\n            float: The dimensionless fraction F.\n        \"\"\"\n        # Case E: Degenerate band of zero width\n        if lambda1_micron == lambda2_micron:\n            return 0.0\n        \n        # Convert wavelengths from micrometers to meters\n        lambda1_m = lambda1_micron * 1e-6\n        lambda2_m = lambda2_micron * 1e-6\n\n        # Calculate the dimensionless integration limits x = hc / (lambda * k_B * T)\n        # Note the inverse relationship between lambda and x.\n        \n        # Upper limit x2 corresponds to lower wavelength lambda1\n        if lambda1_m == 0.0:\n            x2 = np.inf\n        else:\n            x2 = C2 / (lambda1_m * T_kelvin)\n\n        # Lower limit x1 corresponds to upper wavelength lambda2\n        if np.isinf(lambda2_m):\n            x1 = 0.0\n        else:\n            x1 = C2 / (lambda2_m * T_kelvin)\n        \n        # The integral is over [x1, x2]\n        integral_val, _ = integrate.quad(integrand, x1, x2)\n        \n        # The total integral from 0 to infinity is pi^4 / 15\n        normalization_constant = 15.0 / (np.pi**4)\n        \n        return normalization_constant * integral_val\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda1_micron, lambda2_micron, T_kelvin)\n    test_cases = [\n        (0.8, 2.5, 3000.0),      # Case A\n        (0.0, np.inf, 3000.0),   # Case B\n        (0.4, 0.7, 3000.0),      # Case C\n        (0.8, 2.5, 2800.0),      # Case D\n        (1.0, 1.0, 3000.0),      # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda1, lambda2, T = case\n        fraction = calculate_F(lambda1, lambda2, T)\n        # Format the result to 8 significant figures\n        results.append(f\"{fraction:.8g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once radiation is emitted, its journey to the wafer is governed entirely by the geometry of the chamber. The view factor is the essential, dimensionless quantity that captures this geometric relationship between two surfaces. In this exercise , you will derive and implement a numerical estimator for a classic view factor configuration and validate it against its exact analytical solution, a critical step in building robust and trustworthy simulation tools.",
            "id": "4158599",
            "problem": "You are modeling radiative exchange in rapid thermal processing for semiconductor wafers, where a tungsten-halogen lamp assembly is idealized locally as a circular emitting disk coaxial with a differential wafer patch. To validate a numerical implementation of radiative view factors used in lamp array modeling, reproduce a canonical configuration with a known closed-form solution and report the relative error.\n\nStarting from first principles, use the definition of the diffuse-gray radiative view factor from a surface $A_1$ to a surface $A_2$:\n$$\nF_{1 \\to 2} \\;=\\; \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, V \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1,\n$$\nwhere $r$ is the center-to-center distance between differential area elements, $\\theta_1$ and $\\theta_2$ are the angles between the line-of-sight and the local surface normals at the emitting and receiving points respectively, and $V$ is the binary visibility function which is $1$ if the two points are mutually visible and $0$ otherwise. In this validation problem, there are no obstructions, so $V = 1$ for all mutually visible point pairs.\n\nConsider the following geometry that is directly relevant to rapid thermal processing lamp array modeling: a differential wafer patch (modeled as an infinitesimal planar area) located at the origin in the plane $z=0$ with its normal along $+\\hat{z}$, and a coaxial circular lamp-representative disk of radius $R$ lying in the plane $z=h$ with its normal along $-\\hat{z}$. The disk is centered on the $z$-axis, and the entire disk is mutually visible from the wafer patch. The radiative view factor in this geometry is dimensionless (no physical unit is required in the answer).\n\nYour tasks are:\n- Implement a numerical estimator of the view factor from the differential wafer patch to the circular disk based directly on the integral definition above, specialized appropriately to this geometry without invoking any pre-tabulated formulas. The numerical estimator should be robust for a variety of $(R,h)$ values with $R \\ge 0$ and $h > 0$.\n- Independently, compute the corresponding analytical closed-form view factor for this geometry, derived from first principles, to serve as the ground truth.\n- For each test case, compute the relative error, defined as\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert F_{\\text{num}} - F_{\\text{ana}} \\rvert}{\\max\\left( \\lvert F_{\\text{ana}} \\rvert, \\delta \\right)},\n$$\nwhere $F_{\\text{num}}$ is the numerically estimated view factor, $F_{\\text{ana}}$ is the analytically derived view factor, and $\\delta$ is a small positive constant used only to avoid division by zero when $F_{\\text{ana}} = 0$. Use $\\delta = 10^{-12}$.\n\nTest suite:\n- Case $1$: $R = 0.05$, $h = 0.05$.\n- Case $2$: $R = 0.05$, $h = 0.10$.\n- Case $3$: $R = 0.10$, $h = 1.00$.\n- Case $4$: $R = 0.00$, $h = 0.05$.\n- Case $5$: $R = 0.10$, $h = 0.01$.\n\nAll radii and distances are in meters, but the output is dimensionless. Your program should produce a single line of output containing the results as a comma-separated list of the relative errors for the five test cases, in order, enclosed in square brackets and with each value rounded to eight significant figures in scientific notation. For example, the output format must be\n\"[x1,x2,x3,x4,x5]\"\nwith each $x_i$ printed in scientific notation (e.g., $1.23456789\\text{e-}06$). No additional text should be printed.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of radiative heat transfer, is well-posed with sufficient information for a unique solution, and is stated in objective, formal language. We will proceed with a solution.\n\nThe solution is developed in four steps:\n1.  Specialization of the general view factor integral to the given geometry.\n2.  Derivation of the analytical (closed-form) solution for the view factor, $F_{\\text{ana}}$.\n3.  Formulation of the numerical estimator, $F_{\\text{num}}$, based on the integral.\n4.  Calculation of the relative error, $\\varepsilon$, for each test case.\n\n### 1. Specialization of the View Factor Integral\n\nThe general definition of the view factor from a surface $A_1$ to a surface $A_2$ is given as:\n$$\nF_{1 \\to 2} \\;=\\; \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, V \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1\n$$\nIn this problem, surface $A_1$ is a differential wafer patch, which we can denote as $\\mathrm{d}A_1$. As $A_1 \\to \\mathrm{d}A_1$, the outer integral over $A_1$ is removed, and the $1/A_1$ term becomes $1/\\mathrm{d}A_1$. The view factor from the differential area to the finite area $A_2$ is thus:\n$$\nF_{\\mathrm{d}A_1 \\to A_2} \\;=\\; \\int_{A_2} \\frac{\\cos \\theta_1 \\, \\cos \\theta_2}{\\pi \\, r^2} \\, \\mathrm{d}A_2\n$$\nHere, visibility $V=1$ is assumed.\n\nLet's establish a coordinate system. The differential patch $\\mathrm{d}A_1$ is at the origin $(0, 0, 0)$ in the $z=0$ plane, with its surface normal vector being $\\mathbf{n}_1 = \\hat{\\mathbf{k}}$. The surface $A_2$ is a circular disk of radius $R$ in the $z=h$ plane, centered on the $z$-axis. Its normal vector, pointing towards the patch, is $\\mathbf{n}_2 = -\\hat{\\mathbf{k}}$.\n\nWe consider a differential element $\\mathrm{d}A_2$ on the disk $A_2$. Using polar coordinates $(\\rho, \\phi)$ in the $z=h$ plane, the position vector of $\\mathrm{d}A_2$ is $\\mathbf{p}_2 = \\rho \\cos\\phi \\, \\hat{\\mathbf{i}} + \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} + h \\, \\hat{\\mathbf{k}}$, where $0 \\le \\rho \\le R$ and $0 \\le \\phi < 2\\pi$. The differential area is $\\mathrm{d}A_2 = \\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\phi$.\n\nThe vector from the center of $\\mathrm{d}A_1$ (origin) to the center of $\\mathrm{d}A_2$ is $\\mathbf{r} = \\mathbf{p}_2$. The distance $r$ is its magnitude:\n$$\nr = |\\mathbf{r}| = \\sqrt{(\\rho \\cos\\phi)^2 + (\\rho \\sin\\phi)^2 + h^2} = \\sqrt{\\rho^2 + h^2}\n$$\nThe angle $\\theta_1$ is the angle between the normal $\\mathbf{n}_1$ and the line-of-sight vector $\\mathbf{r}$.\n$$\n\\cos \\theta_1 = \\frac{\\mathbf{r} \\cdot \\mathbf{n}_1}{|\\mathbf{r}| |\\mathbf{n}_1|} = \\frac{(\\rho \\cos\\phi \\, \\hat{\\mathbf{i}} + \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} + h \\, \\hat{\\mathbf{k}}) \\cdot (\\hat{\\mathbf{k}})}{\\sqrt{\\rho^2+h^2} \\cdot 1} = \\frac{h}{\\sqrt{\\rho^2+h^2}}\n$$\nThe angle $\\theta_2$ is the angle between the normal $\\mathbf{n}_2$ and the line-of-sight vector pointing from $\\mathrm{d}A_2$ to $\\mathrm{d}A_1$, which is $-\\mathbf{r}$.\n$$\n\\cos \\theta_2 = \\frac{(-\\mathbf{r}) \\cdot \\mathbf{n}_2}{|-\\mathbf{r}| |\\mathbf{n}_2|} = \\frac{(-\\rho \\cos\\phi \\, \\hat{\\mathbf{i}} - \\rho \\sin\\phi \\, \\hat{\\mathbf{j}} - h \\, \\hat{\\mathbf{k}}) \\cdot (-\\hat{\\mathbf{k}})}{\\sqrt{\\rho^2+h^2} \\cdot 1} = \\frac{h}{\\sqrt{\\rho^2+h^2}}\n$$\nSubstituting these expressions into the view factor integral:\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\int_{0}^{2\\pi} \\int_{0}^{R} \\frac{1}{\\pi} \\left( \\frac{h}{\\sqrt{\\rho^2+h^2}} \\right) \\left( \\frac{h}{\\sqrt{\\rho^2+h^2}} \\right) \\frac{1}{(\\sqrt{\\rho^2+h^2})^2} (\\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\phi)\n$$\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\frac{1}{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{R} \\frac{h^2}{(\\rho^2+h^2)^2} \\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\phi\n$$\nThe integrand is independent of the azimuthal angle $\\phi$. The integration over $\\phi$ yields a factor of $2\\pi$:\n$$\nF_{\\mathrm{d}A_1 \\to A_2} = \\frac{2\\pi}{\\pi} \\int_{0}^{R} \\frac{h^2 \\rho}{(\\rho^2+h^2)^2} \\, \\mathrm{d}\\rho = 2h^2 \\int_{0}^{R} \\frac{\\rho}{(\\rho^2+h^2)^2} \\, \\mathrm{d}\\rho\n$$\nThis final one-dimensional integral forms the basis for both the analytical and numerical solutions.\n\n### 2. Analytical Solution ($F_{\\text{ana}}$)\n\nTo find the analytical solution, we solve the integral derived above. We use the substitution $u = \\rho^2 + h^2$, which implies $\\mathrm{d}u = 2\\rho \\, \\mathrm{d}\\rho$, or $\\rho \\, \\mathrm{d}\\rho = \\frac{1}{2}\\mathrm{d}u$. The limits of integration change from $\\rho=0 \\to \\rho=R$ to $u=h^2 \\to u=R^2+h^2$.\n$$\nF_{\\text{ana}} = 2h^2 \\int_{h^2}^{R^2+h^2} \\frac{1}{u^2} \\left( \\frac{1}{2}\\mathrm{d}u \\right) = h^2 \\int_{h^2}^{R^2+h^2} u^{-2} \\, \\mathrm{d}u\n$$\n$$\nF_{\\text{ana}} = h^2 \\left[ -u^{-1} \\right]_{h^2}^{R^2+h^2} = h^2 \\left( -\\frac{1}{R^2+h^2} - \\left(-\\frac{1}{h^2}\\right) \\right)\n$$\n$$\nF_{\\text{ana}} = h^2 \\left( \\frac{1}{h^2} - \\frac{1}{R^2+h^2} \\right) = 1 - \\frac{h^2}{R^2+h^2}\n$$\n$$\nF_{\\text{ana}} = \\frac{(R^2+h^2) - h^2}{R^2+h^2} = \\frac{R^2}{R^2+h^2}\n$$\nThis is the closed-form analytical expression for the view factor.\n\n### 3. Numerical Estimator ($F_{\\text{num}}$)\n\nThe numerical estimator $F_{\\text{num}}$ is implemented by directly evaluating the one-dimensional integral using a high-precision numerical quadrature method. We will use the `scipy.integrate.quad` function, which is a robust tool for this purpose. The function to be integrated with respect to $\\rho$ over the interval $[0, R]$ is:\n$$\nf(\\rho; h) = \\frac{2h^2 \\rho}{(\\rho^2+h^2)^2}\n$$\nSo, for each pair of parameters $(R, h)$, the numerical view factor is calculated as:\n$$\nF_{\\text{num}}(R, h) = \\int_{0}^{R} f(\\rho; h) \\, \\mathrm{d}\\rho \\approx \\text{quad}(f, 0, R, \\text{args}=(h))\n$$\nThis approach adheres to the problem requirement of being \"based directly on the integral definition\" and \"specialized appropriately to this geometry\".\n\n### 4. Relative Error Calculation\n\nFor each test case, we compute both $F_{\\text{ana}}$ and $F_{\\text{num}}$. The relative error $\\varepsilon$ is then calculated according to the provided formula:\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert F_{\\text{num}} - F_{\\text{ana}} \\rvert}{\\max\\left( \\lvert F_{\\text{ana}} \\rvert, \\delta \\right)}\n$$\nwhere $\\delta = 10^{-12}$. The denominator is designed to avoid division by zero when $F_{\\text{ana}}$ is zero, which occurs in the test case where $R=0$. The resulting five error values will be formatted and printed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Calculates the relative error between numerical and analytical view factors\n    for five test cases and prints the results in the required format.\n    \"\"\"\n    \n    # Define test cases as a list of (R, h) tuples.\n    test_cases = [\n        (0.05, 0.05),  # Case 1\n        (0.05, 0.10),  # Case 2\n        (0.10, 1.00),  # Case 3\n        (0.00, 0.05),  # Case 4\n        (0.10, 0.01),  # Case 5\n    ]\n    \n    # Small constant for relative error calculation to avoid division by zero.\n    delta = 1.0e-12\n\n    results = []\n    \n    for R, h in test_cases:\n        # 1. Analytical Solution (F_ana)\n        # The closed-form solution is F_ana = R^2 / (R^2 + h^2).\n        # This is derived by analytically solving the view factor integral.\n        # Check for h > 0 as per problem constraints.\n        if h = 0:\n            raise ValueError(\"Height h must be positive.\")\n        \n        # The formula is robust and handles R=0 correctly.\n        F_ana = R**2 / (R**2 + h**2)\n        \n        # 2. Numerical Solution (F_num)\n        # The numerical solution is obtained by integrating the simplified\n        # 1D view factor kernel using scipy.integrate.quad.\n        # The integrand is f(rho) = 2*h^2*rho / (rho^2 + h^2)^2.\n        \n        # Handle the R=0 case directly, as the integration interval is [0, 0].\n        if R == 0:\n            F_num = 0.0\n        else:\n            integrand = lambda rho, h_val: (2 * h_val**2 * rho) / (rho**2 + h_val**2)**2\n            # quad returns a tuple (result, error_estimate). We need the result.\n            F_num, _ = quad(integrand, 0, R, args=(h,))\n\n        # 3. Relative Error Calculation\n        # epsilon = |F_num - F_ana| / max(|F_ana|, delta)\n        abs_error = abs(F_num - F_ana)\n        denominator = max(abs(F_ana), delta)\n        relative_error = abs_error / denominator\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.7e}\" provides 8 significant figures.\n    formatted_results = [f\"{res:.7e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The ultimate purpose of developing physical models for RTP is to enable precise process control, particularly for achieving wafer temperature uniformity. This capstone practice  integrates the concepts of source emission and geometric coupling into a complete system-level energy balance. You will tackle an inverse design problem to determine the optimal lamp powers required to maintain a uniform target temperature, bridging the gap from fundamental physics to practical engineering design.",
            "id": "4158567",
            "problem": "Consider a rapid thermal processing scenario for a circular semiconductor wafer heated by three concentric lamp rings. The wafer has radius $R$ and is discretized into $N$ concentric annular control volumes (nodes). Each lamp ring $i \\in \\{1,2,3\\}$ has radius $R_i$, height $H_i$ above the wafer plane, and emits a fraction $\\eta_i$ of its electrical power $P_i$ as thermal radiation. The wafer is modeled as a gray, diffuse surface with emissivity $\\varepsilon_w$. The chamber is assumed to be filled with a quiescent gas at temperature $T_{\\mathrm{gas}}$, with a uniform convective heat transfer coefficient $h_c$. The environment (chamber walls) is at temperature $T_{\\mathrm{env}}$. Angles must be treated in radians.\n\nFrom first principles, the starting points are as follows:\n- The Stefan–Boltzmann law: the net radiative heat exchange from a surface node at temperature $T$ to surroundings at $T_{\\mathrm{env}}$ is $q_{\\mathrm{rad}} = \\varepsilon_w \\sigma \\left(T^4 - T_{\\mathrm{env}}^4\\right)$ per unit area, where $\\sigma$ is the Stefan–Boltzmann constant.\n- The definition of irradiance from a point source emitting isotropically: the irradiance at a receiver is inversely proportional to the square of distance and includes a projection factor equal to the cosine of the incidence angle.\n- Energy conservation at steady state for each annular node: absorbed radiative power equals the sum of radiative emission to the environment and convective loss to the gas.\n\nModel the $i$th lamp ring as a uniformly distributed set of isotropic point sources along a circle of radius $R_i$ at height $H_i$ above the wafer. Let a node $j$ at mean radius $r_j$ lie on the wafer plane. For a ring element at azimuth $\\alpha \\in [0,2\\pi)$, the distance between the element and the node is $d(\\alpha) = \\sqrt{H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha}$ and the incidence cosine is $H_i/d(\\alpha)$. The infinitesimal power of the ring element is $\\mathrm{d}P_i = \\eta_i P_i \\mathrm{d}\\alpha / (2\\pi)$.\n\nUsing the above, it follows that the irradiance at node $j$ due to lamp $i$ is obtained by integrating over the ring and is proportional to\n$$\nE_{ij} \\propto \\eta_i P_i H_i \\int_{0}^{2\\pi} \\frac{1}{d(\\alpha)^3}\\,\\mathrm{d}\\alpha.\n$$\nAssuming the wafer absorbs a fraction $\\varepsilon_w$ of the incident radiation (by Kirchhoff's law for gray surfaces) and treating each annulus $j$ with area $A_j$, the absorbed power at node $j$ from lamp $i$ is linear in $P_i$. Therefore, there exists a coupling coefficient $k_{ij}$ such that the absorbed power at node $j$ from all lamps is $\\sum_{i=1}^{3} k_{ij} P_i$.\n\nAt steady state, enforce the node-wise energy balance:\n$$\n\\sum_{i=1}^{3} k_{ij} P_i = \\varepsilon_w \\sigma A_j \\left(T_j^4 - T_{\\mathrm{env}}^4\\right) + h_c A_j \\left(T_j - T_{\\mathrm{gas}}\\right),\n$$\nwhere $T_j$ is the node temperature. For inverse design at a specified target temperature $T_{\\mathrm{t}}$, require $T_j \\approx T_{\\mathrm{t}}$ for all $j$ to within $\\pm 5\\ \\mathrm{K}$.\n\nYour task is to implement a complete program that:\n1. Constructs the geometric coupling coefficients $k_{ij}$ from first principles by numerically evaluating the ring integral for irradiance using a uniform azimuthal discretization. Use radians for $\\alpha$.\n2. Sets up the steady-state energy balance for each node at the target temperature $T_{\\mathrm{t}}$, yielding a linear system in the unknown lamp powers $P_i$. Solve the nonnegative inverse problem for $P = [P_1,P_2,P_3]$ using nonnegative least squares so that the target is matched across nodes in the least-squares sense.\n3. Verifies the resulting node temperatures $T_j$ by solving the nonlinear energy balance for each node with the computed lamp powers, and computes the maximum deviation $\\max_j |T_j - T_{\\mathrm{t}}|$ in $\\mathrm{K}$.\n4. Outputs, for each test case, the three lamp powers in $\\mathrm{W}$ and the maximum deviation from $T_{\\mathrm{t}}$ in $\\mathrm{K}$, followed by a boolean indicating whether the deviation requirement $\\leq 5\\ \\mathrm{K}$ is satisfied. Powers must be expressed in watts (W), and temperatures in kelvin (K).\n\nUse the Stefan–Boltzmann constant $\\sigma = 5.670374419\\times 10^{-8}\\ \\mathrm{W\\,m^{-2}\\,K^{-4}}$ and International System of Units (SI) throughout. All angles must be in radians.\n\nTest suite:\n- Case 1 (happy path): $R = 0.10\\ \\mathrm{m}$, $N = 11$, $R_1 = 0.03\\ \\mathrm{m}$, $R_2 = 0.06\\ \\mathrm{m}$, $R_3 = 0.09\\ \\mathrm{m}$, $H_1 = H_2 = H_3 = 0.08\\ \\mathrm{m}$, $\\eta_1=\\eta_2=\\eta_3=0.75$, $\\varepsilon_w = 0.70$, $h_c = 10\\ \\mathrm{W\\,m^{-2}\\,K^{-1}}$, $T_{\\mathrm{env}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{gas}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{t}}=1000\\ \\mathrm{K}$.\n- Case 2 (boundary emissivity): same as Case 1 but with $\\varepsilon_w = 0.30$.\n- Case 3 (geometric edge case): $R = 0.10\\ \\mathrm{m}$, $N = 11$, $R_1 = 0.02\\ \\mathrm{m}$, $R_2 = 0.04\\ \\mathrm{m}$, $R_3 = 0.08\\ \\mathrm{m}$, $H_1 = H_2 = H_3 = 0.05\\ \\mathrm{m}$, $\\eta_1=0.70$, $\\eta_2=0.75$, $\\eta_3=0.80$, $\\varepsilon_w = 0.60$, $h_c = 8\\ \\mathrm{W\\,m^{-2}\\,K^{-1}}$, $T_{\\mathrm{env}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{gas}} = 500\\ \\mathrm{K}$, $T_{\\mathrm{t}}=1000\\ \\mathrm{K}$.\n\nNumerical requirements:\n- Use at least $M=720$ azimuthal points to approximate the integral for each lamp-node coupling.\n- Distribute the wafer nodes at radii $r_j = \\left(j - \\tfrac{1}{2}\\right)\\Delta r$ for $j=1,\\dots,N$, where $\\Delta r = R/N$, and use exact annulus area $A_j = \\pi\\left((r_j+\\tfrac{\\Delta r}{2})^2 - (r_j-\\tfrac{\\Delta r}{2})^2\\right)$.\n- When verifying temperatures $T_j$ after computing $P_i$, solve the nonlinear balance per node robustly over $T \\in [300\\ \\mathrm{K}, 1400\\ \\mathrm{K}]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list in the form $[P_1,P_2,P_3,\\Delta_{\\max},\\mathrm{compliant}]$ with $P_i$ in $\\mathrm{W}$ and $\\Delta_{\\max}$ in $\\mathrm{K}$. For example, the output should look like:\n$[[P1\\_case1,P2\\_case1,P3\\_case1,\\Delta\\_max\\_case1,\\mathrm{True}],[P1\\_case2,\\dots],[P1\\_case3,\\dots]]$.\nAll numerical outputs must be floats (rounded to three decimal places for powers and deviation) or booleans. The entire output must be printed as a single line.",
            "solution": "The user-provided problem is a well-posed, scientifically grounded task in computational heat transfer, specific to semiconductor manufacturing process modeling. It requires the determination of optimal lamp powers in a rapid thermal processing (RTP) system to achieve a uniform wafer temperature. The problem is self-contained, with all necessary physical parameters, constants, and governing equations provided. The validation is successful.\n\nThe solution is implemented by following a sequence of steps derived from first principles of thermal science and numerical methods.\n\n**1. System Discretization and Geometric Parameters**\n\nThe model begins by discretizing the physical system. The circular wafer, with radius $R$, is divided into $N$ concentric annular control volumes, or nodes. The $j$-th node (for $j=1, \\dots, N$) is characterized by its mean radius $r_j$ and area $A_j$.\n- The radial width of each annulus is $\\Delta r = R/N$.\n- The mean radius of the $j$-th node is defined at the center of the annulus: $r_j = (j - 1/2) \\Delta r$.\n- The area of the $j$-th annulus, which has inner radius $(j-1)\\Delta r$ and outer radius $j\\Delta r$, is exactly $A_j = \\pi((j\\Delta r)^2 - ((j-1)\\Delta r)^2)$. This simplifies to $A_j = 2\\pi r_j \\Delta r$.\n\n**2. Radiative Coupling Matrix ($\\mathbf{K}$) Construction**\n\nThe central task is to establish a linear relationship between the electrical power $P_i$ supplied to each lamp ring and the thermal power absorbed by each wafer node $j$. This relationship is captured by a set of coupling coefficients, $k_{ij}$.\n\nEach lamp ring $i$ is modeled as a continuous circle of isotropic point sources at radius $R_i$ and height $H_i$. An infinitesimal segment of the ring at azimuth $\\alpha$ emits a fraction of the total ring power. The radiated power from this segment is $\\mathrm{d}P_i^{\\mathrm{rad}} = \\eta_i P_i \\frac{\\mathrm{d}\\alpha}{2\\pi}$. For an isotropic source, the radiant intensity (power per unit solid angle) is $I = \\mathrm{d}P_i^{\\mathrm{rad}} / (4\\pi)$.\n\nThe infinitesimal irradiance $\\mathrm{d}E_{ij}$ at a point on the wafer (at radius $r_j$) from this source element is given by the inverse square law, including a projection factor ($\\cos\\theta$):\n$$ \\mathrm{d}E_{ij}(\\alpha) = I \\frac{\\cos\\theta}{d(\\alpha)^2} $$\nwhere $d(\\alpha)$ is the distance from the source element to the wafer point and $\\theta$ is the angle of incidence. The geometry dictates:\n- Distance: $d(\\alpha) = \\sqrt{H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha}$\n- Incidence cosine: $\\cos\\theta = H_i / d(\\alpha)$\n\nSubstituting these into the irradiance equation and integrating over the full ring ($\\alpha$ from $0$ to $2\\pi$) gives the total irradiance $E_{ij}$ at radius $r_j$ from lamp ring $i$:\n$$ E_{ij} = \\int_{0}^{2\\pi} \\frac{\\eta_i P_i \\mathrm{d}\\alpha / (2\\pi)}{4\\pi} \\frac{H_i/d(\\alpha)}{d(\\alpha)^2} = \\frac{\\eta_i H_i P_i}{8\\pi^2} \\int_{0}^{2\\pi} \\frac{1}{\\left(H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha\\right)^{3/2}} \\, \\mathrm{d}\\alpha $$\nThe power absorbed by wafer node $j$ from lamp $i$ is $Q_{\\mathrm{abs}, ij} = \\varepsilon_w A_j E_{ij}$, where $\\varepsilon_w$ is the wafer emissivity (and absorptivity, per Kirchhoff's law for a gray surface). This absorbed power is linear in $P_i$, so we can write $Q_{\\mathrm{abs}, ij} = k_{ij} P_i$. The coupling coefficient $k_{ij}$ is therefore:\n$$ k_{ij} = \\frac{\\varepsilon_w A_j \\eta_i H_i}{8\\pi^2} \\int_{0}^{2\\pi} \\frac{1}{\\left(H_i^2 + R_i^2 + r_j^2 - 2 R_i r_j \\cos\\alpha\\right)^{3/2}} \\, \\mathrm{d}\\alpha $$\nThis definite integral is computed numerically. We discretize the angle $\\alpha$ into $M$ points, $\\alpha_k = k \\cdot (2\\pi/M)$ for $k=0, \\dots, M-1$, with step $\\Delta\\alpha = 2\\pi/M$. The integral is approximated by a Riemann sum:\n$$ \\int_{0}^{2\\pi} f(\\alpha) \\, \\mathrm{d}\\alpha \\approx \\sum_{k=0}^{M-1} f(\\alpha_k) \\Delta\\alpha $$\nThis calculation is performed for each lamp-node pair $(i,j)$, yielding the $N \\times 3$ coupling matrix $\\mathbf{K}$.\n\n**3. Inverse Problem: Lamp Power Calculation**\n\nTo achieve a uniform target temperature $T_t$ across the wafer, the power absorbed by each node must balance the heat lost at that temperature. The total heat loss from node $j$ at temperature $T_t$ is the sum of radiative and convective losses:\n$$ Q_j^{\\mathrm{target}} = \\varepsilon_w \\sigma A_j (T_t^4 - T_{\\mathrm{env}}^4) + h_c A_j (T_t - T_{\\mathrm{gas}}) $$\nwhere $\\sigma$ is the Stefan–Boltzmann constant.\n\nThe total absorbed power at node $j$ is the sum of contributions from all lamps: $\\sum_{i=1}^{3} k_{ij} P_i$. Equating this to the target loss for each node results in a system of linear equations:\n$$ \\sum_{i=1}^{3} k_{ij} P_i = Q_j^{\\mathrm{target}} \\quad \\text{for } j=1, \\dots, N $$\nIn matrix notation, this is $\\mathbf{K} \\mathbf{P} = \\mathbf{Q}^{\\mathrm{target}}$, where $\\mathbf{P} = [P_1, P_2, P_3]^T$ is the vector of unknown lamp powers and $\\mathbf{Q}^{\\mathrm{target}}$ is the $N \\times 1$ vector of target heat losses. Since $N=11$ and the number of lamps is $3$, this is an overdetermined system. To find a physically meaningful solution where powers are non-negative ($P_i \\ge 0$), we solve the nonnegative least-squares (NNLS) problem:\n$$ \\min_{\\mathbf{P} \\ge 0} || \\mathbf{K} \\mathbf{P} - \\mathbf{Q}^{\\mathrm{target}} ||_2^2 $$\nThe solution provides the optimal, non-negative powers $P_1, P_2, P_3$ that best achieve the target thermal load across all nodes.\n\n**4. Forward Problem: Temperature Verification**\n\nWith the computed lamp powers $\\mathbf{P}^*$, we must verify the actual temperature distribution. The actual power absorbed by each node $j$ is $Q_j^{\\mathrm{actual}} = \\sum_{i=1}^{3} k_{ij} P_i^*$. The actual steady-state temperature $T_j$ for each node is then found by solving the nonlinear energy balance equation:\n$$ Q_j^{\\mathrm{actual}} = \\varepsilon_w \\sigma A_j (T_j^4 - T_{\\mathrm{env}}^4) + h_c A_j (T_j - T_{\\mathrm{gas}}) $$\nThis is equivalent to finding the root of the function $f(T_j) = 0$, where:\n$$ f(T_j) = \\varepsilon_w \\sigma A_j T_j^4 + h_c A_j T_j - \\left( Q_j^{\\mathrm{actual}} + \\varepsilon_w \\sigma A_j T_{\\mathrm{env}}^4 + h_c A_j T_{\\mathrm{gas}} \\right) $$\nThis function is monotonic for $T_j  0$, guaranteeing a unique positive solution. We use a numerical root-finding algorithm, such as Brent's method, over the specified range $[300\\ \\mathrm{K}, 1400\\ \\mathrm{K}]$ to find each $T_j$.\n\nFinally, the temperature uniformity is assessed by the maximum deviation from the target:\n$$ \\Delta_{\\max} = \\max_{j=1, \\dots, N} |T_j - T_t| $$\nThe process is compliant if this deviation is no more than $5\\ \\mathrm{K}$. The final output for each test case consists of the computed powers $[P_1, P_2, P_3]$, the maximum deviation $\\Delta_{\\max}$, and the compliance status.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls, brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the RTP lamp power design problem for all test cases.\n    \"\"\"\n    # Define physical constant\n    SIGMA = 5.670374419e-8  # Stefan-Boltzmann constant, W m^-2 K^-4\n\n    # Define numerical parameters\n    M = 720  # Number of azimuthal points for integration\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.03, 0.06, 0.09]),\n            \"H_lamps\": np.array([0.08, 0.08, 0.08]),\n            \"eta_lamps\": np.array([0.75, 0.75, 0.75]),\n            \"epsilon_w\": 0.70, \"h_c\": 10.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        },\n        # Case 2 (boundary emissivity)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.03, 0.06, 0.09]),\n            \"H_lamps\": np.array([0.08, 0.08, 0.08]),\n            \"eta_lamps\": np.array([0.75, 0.75, 0.75]),\n            \"epsilon_w\": 0.30, \"h_c\": 10.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        },\n        # Case 3 (geometric edge case)\n        {\n            \"R\": 0.10, \"N\": 11,\n            \"R_lamps\": np.array([0.02, 0.04, 0.08]),\n            \"H_lamps\": np.array([0.05, 0.05, 0.05]),\n            \"eta_lamps\": np.array([0.70, 0.75, 0.80]),\n            \"epsilon_w\": 0.60, \"h_c\": 8.0,\n            \"T_env\": 500.0, \"T_gas\": 500.0, \"T_t\": 1000.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters\n        R = case[\"R\"]\n        N = case[\"N\"]\n        R_lamps = case[\"R_lamps\"]\n        H_lamps = case[\"H_lamps\"]\n        eta_lamps = case[\"eta_lamps\"]\n        epsilon_w = case[\"epsilon_w\"]\n        h_c = case[\"h_c\"]\n        T_env = case[\"T_env\"]\n        T_gas = case[\"T_gas\"]\n        T_t = case[\"T_t\"]\n        \n        num_lamps = len(R_lamps)\n\n        # Step 1: Wafer discretization\n        dr = R / N\n        r_nodes = (np.arange(1, N + 1) - 0.5) * dr\n        # Exact area of each annulus is 2*pi*r_j*dr\n        A_nodes = 2 * np.pi * r_nodes * dr\n\n        # Step 2: Construct the coupling matrix K\n        K_matrix = np.zeros((N, num_lamps))\n        \n        alpha_k = np.linspace(0, 2 * np.pi, M, endpoint=False)\n        d_alpha = 2 * np.pi / M\n\n        for i in range(num_lamps):  # For each lamp ring\n            for j in range(N):  # For each wafer node\n                R_i, H_i, r_j = R_lamps[i], H_lamps[i], r_nodes[j]\n                \n                # Distance squared from source element to wafer point\n                dist_sq = H_i**2 + R_i**2 + r_j**2 - 2 * R_i * r_j * np.cos(alpha_k)\n                \n                # Integrand is 1 / d(alpha)^3\n                integrand = dist_sq**(-1.5)\n                \n                # Numerical integration using Riemann sum\n                integral_val = np.sum(integrand) * d_alpha\n                \n                # Calculate the coupling coefficient k_ij\n                k_ij = (epsilon_w * A_nodes[j] * eta_lamps[i] * H_i) / (8 * np.pi**2) * integral_val\n                K_matrix[j, i] = k_ij\n\n        # Step 3: Solve inverse problem for lamp powers P\n        # Calculate target heat loss vector Q_target for T_t\n        rad_loss = epsilon_w * SIGMA * A_nodes * (T_t**4 - T_env**4)\n        conv_loss = h_c * A_nodes * (T_t - T_gas)\n        Q_target = rad_loss + conv_loss\n\n        # Solve the Nonnegative Least Squares problem: min ||K*P - Q_target||_2^2 s.t. P >= 0\n        P_lamps, _ = nnls(K_matrix, Q_target)\n\n        # Step 4: Verify temperatures and compute deviation\n        # Calculate actual absorbed power Q_actual = K * P\n        Q_actual = K_matrix @ P_lamps\n        \n        T_nodes = np.zeros(N)\n        for j in range(N):\n            A_j = A_nodes[j]\n            Q_abs_j = Q_actual[j]\n\n            # Define the energy balance equation f(T) = 0 for the root finder\n            def energy_balance(T):\n                power_out = epsilon_w * SIGMA * A_j * (T**4 - T_env**4) + h_c * A_j * (T - T_gas)\n                return power_out - Q_abs_j\n\n            # Solve for T_j using Brent's method in the specified range\n            T_nodes[j] = brentq(energy_balance, 300.0, 1400.0)\n\n        # Compute maximum deviation from target temp and check compliance\n        delta_max = np.max(np.abs(T_nodes - T_t))\n        is_compliant = delta_max = 5.0\n\n        # Store results for this case in the required format\n        result_list = [round(p, 3) for p in P_lamps]\n        result_list.append(round(delta_max, 3))\n        result_list.append(is_compliant)\n        results.append(result_list)\n\n    # Construct the final output string to match the exact format requested\n    # (no spaces within or between list elements)\n    inner_strs = []\n    for res_list in results:\n        # String representation for one case: [P1,P2,P3,delta,compliant]\n        s = f\"[{res_list[0]},{res_list[1]},{res_list[2]},{res_list[3]},{str(res_list[4]).lower()}]\" # Python boolean to js/json boolean\n        inner_strs.append(s)\n    \n    final_output_str = f\"[{','.join(inner_strs)}]\"\n    # A small correction for Python boolean \"True\" to JSON \"true\" as per the example format.\n    final_output_str = final_output_str.replace(\"True\", \"true\").replace(\"False\", \"false\")\n\n\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}