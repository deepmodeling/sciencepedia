{
    "hands_on_practices": [
        {
            "introduction": "在分析复杂信号之前，我们必须首先理解其物理来源。光学发射光谱（OES）测量的反应性物种浓度，是由等离子体中的生成速率与在晶圆和腔室壁上的消耗速率之间的动态平衡决定的。这个练习将指导您从物种平衡方程这一基本原理出发，推导出一个关键的无量纲参数——丹姆科勒数（Damköhler number, $Da$），并用它来判断终点信号是由表面反应动力学主导（反应限制）还是由物种输运主导（输运限制），这是过程诊断与控制中的一个核心概念 。",
            "id": "4124304",
            "problem": "一个单晶圆电感耦合等离子体反应器用于反应离子刻蚀，其终点检测采用光学发射光谱法（OES）。OES监测一种活性自由基物质，记为 $R$，已知其谱线强度与其空间平均的气相浓度成正比。反应器内含有均匀的等离子体，在刻蚀的最后阶段，$R$ 的体积生成速率近似恒定。表面（晶圆和腔室壁）通过一级非均相吸收过程充当 $R$ 的汇。\n\n从第一性原理出发，为反应器中 $R$ 的总摩尔数 $N_{R}(t)$ 建立一个空间平均的动态平衡方程，并定义一个无量纲数组，该数组量化了特征表面反应能力与特征摩尔通量之比。具体而言，假设：\n\n- 反应器体积为 $V$，总可用反应表面积为 $A_{s}$。\n- $R$ 的体积生成速率为常数 $\\dot{n}$，单位为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-3}$。\n- $R$ 到表面的非均相吸收通量相对于空间平均浓度是一级的，并且可以用一个有效摩尔速率系数 $k_{s}$ 表示，单位为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-2}$（该系数包含了动力学系数和刻蚀最后阶段的主要基线浓度，因此净消耗速率为 $k_{s}A_{s}$）。\n- 气体流动和泵送设定了有限的停留时间，但为了在确定OES终点信号形成时，分离生成和表面反应之间的竞争，请在平衡方程中忽略 $R$ 的显式流出，并通过体积生成项来模拟通量。\n\n根据物种平衡和特征时间论证，推导出一个 Damköhler 数 $\\mathrm{Da}$，该数比较了最大表面反应能力与供应到反应器的摩尔通量。然后，使用以下参数计算该反应器的 $\\mathrm{Da}$ 值：\n- $V = 2.50 \\times 10^{-2}\\,\\mathrm{m}^{3}$，\n- $A_{s} = 1.50\\,\\mathrm{m}^{2}$，\n- $\\dot{n} = 2.00 \\times 10^{-1}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-3}$，\n- $k_{s} = 5.00 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-2}$。\n\n将计算出的 Damköhler 数四舍五入至三位有效数字，并以无量纲量的形式报告。最后，使用推导出的无量纲数组，讨论在给定反应器和参数下，哪种机制（反应限制或传输限制）预计将主导终点OES信号的形成，并从第一性原理出发证明该结论，而不使用经验性简化公式。你的最终数值答案应仅为 Damköhler 数的值，无量纲，并四舍五入至指定的有效数字。",
            "solution": "问题陈述已经过验证，被认为是科学合理的、定义明确的、客观的。它提供了一套独立、一致的定义、假设和数据，用于模拟等离子体刻蚀过程控制中一个简化但物理上相关的场景。该问题按所述方式是可解的。\n\n分析过程分为三个部分：首先，推导物种摩尔平衡方程；其次，定义并计算所要求的无量纲数组；第三，对该数组进行物理解释，以确定速率限制机制。\n\n**第1部分：空间平均物种平衡**\n\n在一个控制体积 $V$ 内，物种 $R$ 的总摩尔数 $N_{R}(t)$ 的动态平衡由通用守恒方程给出：\n$$\n\\frac{dN_{R}(t)}{dt} = (\\text{摩尔流入速率}) - (\\text{摩尔流出速率}) + (\\text{总生成速率}) - (\\text{总消耗速率})\n$$\n问题为此平衡方程指定了以下各项：\n-   **累积速率**：反应器中 $R$ 的总摩尔数的变化速率，即 $\\frac{dN_{R}(t)}{dt}$。\n-   **流速**：问题明确指示“忽略 $R$ 的显式流出”。没有提及 $R$ 的流入。因此，流动项为零。\n-   **生成速率**：$R$ 的体积生成速率是一个常数 $\\dot{n}$，单位为 $\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-3}$。对于体积为 $V$ 的反应器中的均匀等离子体，总摩尔生成速率为 $R_{gen} = \\dot{n}V$。\n-   **消耗速率**：物种 $R$ 在总面积为 $A_s$ 的表面（晶圆和壁）上被消耗。问题陈述“净消耗速率为 $k_{s}A_{s}$”，其中 $k_s$ 是一个有效摩尔速率系数。因此，总摩尔消耗速率为 $R_{surf} = k_{s}A_{s}$。\n\n将这些项代入通用平衡方程，得到总摩尔数 $N_{R}(t)$ 的空间平均动态平衡方程：\n$$\n\\frac{dN_{R}(t)}{dt} = \\dot{n}V - k_{s}A_{s}\n$$\n该常微分方程描述了在给定假设下，反应器体积内自由基物种 $R$ 的总摩尔数随时间的演变。OES信号强度与空间平均浓度 $C_R(t) = \\frac{N_R(t)}{V}$ 成正比，因此 $N_R(t)$ 的行为直接决定了OES信号。\n\n**第2部分：Damköhler 数 ($\\mathrm{Da}$)**\n\n问题要求定义并评估一个无量纲数组，即 Damköhler 数 $\\mathrm{Da}$，它“量化了特征表面反应能力与特征摩尔通量之比”。\n\n根据我们对物种平衡的分析：\n-   **特征表面反应能力**是表面可以消耗物种 $R$ 的总速率。根据问题中的定义，这是 $R_{surf} = k_{s}A_{s}$。\n-   **特征摩尔通量**由体积生成项建模。这是物种 $R$ 供应到反应器体积的总速率，即 $R_{gen} = \\dot{n}V$。\n\nDamköhler 数是这两个特征速率的比值：\n$$\n\\mathrm{Da} = \\frac{\\text{特征表面反应能力}}{\\text{特征摩尔通量}} = \\frac{k_{s}A_{s}}{\\dot{n}V}\n$$\n这个无量纲数比较了表面反应去除物种的最大速率与等离子体中物种生成的速率。\n\n我们现在使用提供的参数来计算这个数值：\n-   $V = 2.50 \\times 10^{-2}\\,\\mathrm{m}^{3}$\n-   $A_{s} = 1.50\\,\\mathrm{m}^{2}$\n-   $\\dot{n} = 2.00 \\times 10^{-1}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-3}$\n-   $k_{s} = 5.00 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-2}$\n\n首先，计算分子（表面反应能力）：\n$$\nk_{s}A_{s} = (5.00 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-2}) \\times (1.50\\,\\mathrm{m}^{2}) = 7.50 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\n$$\n接下来，计算分母（摩尔通量/生成）：\n$$\n\\dot{n}V = (2.00 \\times 10^{-1}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-3}) \\times (2.50 \\times 10^{-2}\\,\\mathrm{m}^{3}) = 5.00 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}\n$$\n最后，计算比值以求得 $\\mathrm{Da}$：\n$$\n\\mathrm{Da} = \\frac{7.50 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}}{5.00 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}} = 1.50\n$$\n问题要求四舍五入到三位有效数字，而结果已经符合此格式。计算出的 Damköhler 数为 $1.50$。\n\n**第3部分：主导机制的解释**\n\nDamköhler 数为我们提供了关于系统速率限制过程的深刻见解。我们可以用 $\\mathrm{Da}$ 来重写物种平衡方程：\n$$\n\\frac{dN_R(t)}{dt} = \\dot{n}V \\left(1 - \\frac{k_s A_s}{\\dot{n}V}\\right) = \\dot{n}V(1 - \\mathrm{Da})\n$$\n$\\mathrm{Da}$ 的值决定了自由基浓度变化速率的符号和大小，这反过来又决定了OES信号的行为。\n\n-   如果 $\\mathrm{Da} \\ll 1$：这意味着 $k_s A_s \\ll \\dot{n}V$。生成速率远超表面消耗能力。累积项 $\\frac{dN_R}{dt}$ 将为大的正值，导致 $R$ 的浓度增加。整个过程的瓶颈是缓慢的表面反应。这是一个**反应限制**机制。\n-   如果 $\\mathrm{Da} \\gg 1$：这意味着 $k_s A_s \\gg \\dot{n}V$。表面消耗能力远超生成速率。累积项 $\\frac{dN_R}{dt}$ 将为大的负值，导致 $R$ 的浓度迅速下降。物种几乎一生成就被表面消耗掉。总消耗速率不受表面反应活性的限制，而是受物种生成并传输到表面的速率限制。这是一个**传输限制**（或供应限制）机制。\n\n在本问题中，计算值为 $\\mathrm{Da} = 1.50$。由于 $\\mathrm{Da} > 1$，特征表面反应能力（$7.50 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$）大于由生成产生的特征摩尔通量（$5.00 \\times 10^{-3}\\,\\mathrm{mol}\\,\\mathrm{s}^{-1}$）。\n\n从第一性原理出发，总过程速率由其最慢的步骤决定。在这里，表面消耗自由基的能力比等离子体产生自由基的速度要快。因此，自由基最终被消耗的速率受限于它们的生成和向表面传输的速率。表面处于反应物“匮乏”状态。因此，依赖于自由基浓度变化的OES终点信号的形成，由**传输限制**机制主导（更准确地说，是供应限制机制，其中供应包括生成和传输）。$\\frac{dN_R}{dt} = \\dot{n}V(1-1.50) = -0.50 \\dot{n}V$ 的负号表示 $R$ 的浓度正在下降，这是当一个反应性更强的底层暴露时典型的OES终点特征。这种下降的动态过程受限于该物种的供应。",
            "answer": "$$\\boxed{1.50}$$"
        },
        {
            "introduction": "理想的物理模型只是第一步，现实世界的测量系统总有其局限性。在光学发射光谱法中，一个常见的问题是探测器饱和，即强烈的发射信号超出了探测器的动态范围。这种信号削波会引入非线性失真，从而系统性地影响依赖于信号阈值的终点检测算法的计时准确性。通过这个练习，您将定量分析由饱和效应引起的终点计时偏差，并设计一种实用的动态范围管理策略，从而将理论信号模型与硬件实现的实际挑战联系起来 。",
            "id": "4124331",
            "problem": "使用光发射光谱法（OES）检测等离子体刻蚀终点，其中光电探测器测量与挥发性刻蚀产物相关的发射强度。其潜在的过程动力学模型如下：发射强度在终点前基本保持在一个恒定水平，然后在真实终点时刻过渡到终点后的指数衰减。具体来说，假设真实发射强度为 $$I_{\\text{true}}(t) = \\begin{cases} I_{0}, & t  t_{e}, \\\\ I_{0} \\exp\\!\\big(-\\frac{t - t_{e}}{\\tau}\\big),  t \\ge t_{e}, \\end{cases}$$ 其中 $I_{0}$ 是终点前的发射强度，$t_{e}$ 是真实终点时间，$\\tau$ 是由质量输运和复合动力学产生的衰减时间常数。\n\n探测器前端由一个增益为 $$G$$ 的跨阻放大器和一个满量程电压为 $$V_{\\text{FS}}$$ 的模数转换器（ADC）组成，跨阻放大器将光发射强度转换为电压 $$V(t) = G I_{\\text{true}}(t)$$。测量信号在 ADC 极限处被硬性削波：$$V_{\\text{meas}}(t) = \\min\\!\\big(V(t), V_{\\text{FS}}\\big).$$ 当测量信号下降到其终点前测量平台值 $$V_{\\text{pre}}$$ 的一个固定分数 $$\\alpha$$ 时，终点检测算法触发，即在第一个满足 $$V_{\\text{meas}}(t) = \\alpha V_{\\text{pre}}$$ 的时间 $$t$$ 触发。\n\n给定参数值 $$I_{0} = 1.5 \\times 10^{-8} \\ \\text{A}, \\quad G = 5.0 \\times 10^{7} \\ \\text{V/A}, \\quad V_{\\text{FS}} = 0.50 \\ \\text{V}, \\quad \\tau = 0.15 \\ \\text{s}, \\quad \\alpha = 0.40,$$ 量化由探测器饱和引起的终点时间偏差，该偏差定义为 $$\\Delta t = t_{\\text{sat}} - t_{\\text{ideal}},$$ 其中 $$t_{\\text{sat}}$$ 是当终点前测量平台被削波至 $$V_{\\text{FS}}$$ 时算法的触发时间，而 $$t_{\\text{ideal}}$$ 是在假设的非饱和情况 $$V_{\\text{pre}} = G I_{0} \\le V_{\\text{FS}}$$ 下算法的触发时间。\n\n然后，提出并量化一种动态范围管理策略，通过在跨阻放大器前引入一个输入衰减因子 $$a$$（无量纲）来防止削波，使得终点前的测量平台等于 ADC 满量程的一个选定分数 $$\\gamma = 0.80$$，即 $$a G I_{0} = \\gamma V_{\\text{FS}}.$$ 计算所需的衰减因子 $$a$$。\n\n将您的最终答案表示为一个二元行矩阵 $$\\begin{pmatrix} \\Delta t  a \\end{pmatrix}$$。将 $$\\Delta t$$ 以秒为单位表示，$$a$$ 为无量纲。将两个量都四舍五入到四位有效数字。",
            "solution": "首先验证问题，以确保其具有科学依据、问题提出得当且客观。\n\n**步骤1：提取已知条件**\n- 真实发射强度模型：$$I_{\\text{true}}(t) = \\begin{cases} I_{0},  t  t_{e}, \\\\ I_{0} \\exp\\!\\big(-\\frac{t - t_{e}}{\\tau}\\big),  t \\ge t_{e}, \\end{cases}$$\n- 终点前发射强度：$$I_{0} = 1.5 \\times 10^{-8} \\ \\text{A}$$\n- 跨阻放大器增益：$$G = 5.0 \\times 10^{7} \\ \\text{V/A}$$\n- ADC 满量程电压：$$V_{\\text{FS}} = 0.50 \\ \\text{V}$$\n- 衰减时间常数：$$\\tau = 0.15 \\ \\text{s}$$\n- 终点检测触发分数：$$\\alpha = 0.40$$\n- 带削波的测量信号：$$V_{\\text{meas}}(t) = \\min\\!\\big(G I_{\\text{true}}(t), V_{\\text{FS}}\\big)$$\n- 终点检测触发条件：$$V_{\\text{meas}}(t) = \\alpha V_{\\text{pre}}$$，其中 $$V_{\\text{pre}}$$ 是终点前的测量平台值。\n- 终点时间偏差定义：$$\\Delta t = t_{\\text{sat}} - t_{\\text{ideal}}$$\n- $$t_{\\text{sat}}$$: 信号削波时的触发时间。\n- $$t_{\\text{ideal}}$$: 信号未削波时的触发时间。\n- 动态范围管理衰减因子：$$a$$\n- 衰减条件：$$a G I_{0} = \\gamma V_{\\text{FS}}$$\n- 选定的 ADC 满量程分数：$$\\gamma = 0.80$$\n- 要求输出：一个二元行矩阵 $$\\begin{pmatrix} \\Delta t  a \\end{pmatrix}$$，值四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了在等离子体刻蚀中使用光发射光谱法进行终点检测的标准模型，这是半导体制造中的一个关键过程。模型组件，包括信号形状（恒定后接指数衰减）和探测器电子设备（带 ADC 削波的跨阻放大器），在物理上是现实且成熟的。问题提出得当，提供了所有必要的常量值和待计算量的清晰定义。语言客观且精确。参数是一致的，并导向了所关注的物理情况，即探测器饱和，因为潜在的终点前电压 $$G I_{0} = (5.0 \\times 10^{7}) \\times (1.5 \\times 10^{-8}) = 0.75 \\ \\text{V}$$ 超过了 ADC 满量程电压 $$V_{\\text{FS}} = 0.50 \\ \\text{V}$$。该问题可形式化，并与指定主题直接相关。\n\n**步骤3：结论与行动**\n问题被认为是有效的。将提供完整解答。\n\n解答分为两部分：首先，计算终点时间偏差 $$\\Delta t$$，其次，计算所需的衰减因子 $$a$$。\n\n**第1部分：计算终点时间偏差 $$\\Delta t$$**\n\n时间偏差定义为 $$\\Delta t = t_{\\text{sat}} - t_{\\text{ideal}}$$。我们必须找到理想触发时间 $$t_{\\text{ideal}}$$ 和饱和触发时间 $$t_{\\text{sat}}$$ 的表达式。\n\n**理想情况（非饱和）：**\n在这种假设情况下，探测器不饱和，意味着 $$G I_{0} \\le V_{\\text{FS}}$$。对于 $$t  t_e$$，终点前电压 $$V(t)$$ 恒定为 $$V(t) = G I_0$$。因此，终点前的测量平台值为 $$V_{\\text{pre, ideal}} = G I_0$$。\n当信号下降到 $$\\alpha V_{\\text{pre, ideal}}$$ 时，终点检测算法在时间 $$t_{\\text{ideal}}$$ 触发。对于 $$t \\ge t_e$$，信号的衰减部分为 $$V(t) = G I_{0} \\exp\\!\\big(-\\frac{t - t_{e}}{\\tau}\\big)$$。\n触发条件为：\n$$G I_{0} \\exp\\!\\big(-\\frac{t_{\\text{ideal}} - t_{e}}{\\tau}\\big) = \\alpha V_{\\text{pre, ideal}} = \\alpha (G I_{0})$$\n两边同除以 $$G I_0$$ 得：\n$$\\exp\\!\\big(-\\frac{t_{\\text{ideal}} - t_{e}}{\\tau}\\big) = \\alpha$$\n两边取自然对数：\n$$-\\frac{t_{\\text{ideal}} - t_{e}}{\\tau} = \\ln(\\alpha)$$\n求解 $$t_{\\text{ideal}}$$，我们得到相对于真实终点 $$t_e$$ 的时间延迟：\n$$t_{\\text{ideal}} - t_e = -\\tau \\ln(\\alpha) = \\tau \\ln\\left(\\frac{1}{\\alpha}\\right)$$\n$$t_{\\text{ideal}} = t_{e} + \\tau \\ln\\left(\\frac{1}{\\alpha}\\right)$$\n\n**饱和情况（削波）：**\n在这种情况下，潜在的终点前电压 $$G I_0$$ 大于 ADC 满量程电压 $$V_{\\text{FS}}$$。因此，对于 $$t  t_e$$，测量信号被削波：$$V_{\\text{meas}}(t) = V_{\\text{FS}}$$。因此，终点前的测量平台值为 $$V_{\\text{pre, sat}} = V_{\\text{FS}}$$。\n当测量信号下降到 $$\\alpha V_{\\text{pre, sat}} = \\alpha V_{\\text{FS}}$$ 时，算法在时间 $$t_{\\text{sat}}$$ 触发。\n在触发点，信号正在衰减，其值低于 $$V_{\\text{FS}}$$，因此 $$V_{\\text{meas}}(t_{\\text{sat}})$$ 就是该时刻电压的未削波值。触发条件为：\n$$G I_{0} \\exp\\!\\big(-\\frac{t_{\\text{sat}} - t_{e}}{\\tau}\\big) = \\alpha V_{\\text{FS}}$$\n为了求解 $$t_{\\text{sat}}$$，我们首先分离出指数项：\n$$\\exp\\!\\big(-\\frac{t_{\\text{sat}} - t_{e}}{\\tau}\\big) = \\frac{\\alpha V_{\\text{FS}}}{G I_{0}}$$\n两边取自然对数：\n$$-\\frac{t_{\\text{sat}} - t_{e}}{\\tau} = \\ln\\left(\\frac{\\alpha V_{\\text{FS}}}{G I_{0}}\\right)$$\n求解 $$t_{\\text{sat}}$$：\n$$t_{\\text{sat}} - t_e = -\\tau \\ln\\left(\\frac{\\alpha V_{\\text{FS}}}{G I_{0}}\\right) = \\tau \\ln\\left(\\frac{G I_{0}}{\\alpha V_{\\text{FS}}}\\right)$$\n$$t_{\\text{sat}} = t_{e} + \\tau \\ln\\left(\\frac{G I_{0}}{\\alpha V_{\\text{FS}}}\\right)$$\n\n**计算偏差 $$\\Delta t$$：**\n时间偏差是饱和触发时间与理想触发时间之差：\n$$\\Delta t = t_{\\text{sat}} - t_{\\text{ideal}}$$\n$$\\Delta t = \\left(t_{e} + \\tau \\ln\\left(\\frac{G I_{0}}{\\alpha V_{\\text{FS}}}\\right)\\right) - \\left(t_{e} + \\tau \\ln\\left(\\frac{1}{\\alpha}\\right)\\right)$$\n$$t_e$$ 项相互抵消。我们可以提出公因子 $$\\tau$$：\n$$\\Delta t = \\tau \\left[ \\ln\\left(\\frac{G I_{0}}{\\alpha V_{\\text{FS}}}\\right) - \\ln\\left(\\frac{1}{\\alpha}\\right) \\right]$$\n使用对数性质 $$\\ln(x) - \\ln(y) = \\ln(x/y)$$:\n$$\\Delta t = \\tau \\ln\\left(\\frac{G I_{0}/(\\alpha V_{\\text{FS}})}{1/\\alpha}\\right) = \\tau \\ln\\left(\\frac{G I_{0}}{\\alpha V_{\\text{FS}}} \\cdot \\alpha\\right)$$\n$$\\Delta t = \\tau \\ln\\left(\\frac{G I_{0}}{V_{\\text{FS}}}\\right)$$\n这个非常简洁的结果表明，偏差仅取决于时间常数和饱和程度。\n现在，我们代入数值：\n$$I_{0} = 1.5 \\times 10^{-8} \\ \\text{A}$$\n$$G = 5.0 \\times 10^{7} \\ \\text{V/A}$$\n$$V_{\\text{FS}} = 0.50 \\ \\text{V}$$\n$$\\tau = 0.15 \\ \\text{s}$$\n首先，计算非饱和的终点前电压 $$G I_{0}$$：\n$$G I_{0} = (5.0 \\times 10^{7} \\ \\text{V/A}) \\times (1.5 \\times 10^{-8} \\ \\text{A}) = 0.75 \\ \\text{V}$$\n现在，计算 $$\\Delta t$$：\n$$\\Delta t = (0.15 \\ \\text{s}) \\times \\ln\\left(\\frac{0.75 \\ \\text{V}}{0.50 \\ \\text{V}}\\right) = 0.15 \\times \\ln(1.5)$$\n$$\\Delta t \\approx 0.15 \\times 0.405465 = 0.06081975... \\ \\text{s}$$\n四舍五入到四位有效数字，$$\\Delta t = 0.06082 \\ \\text{s}$$。\n\n**第2部分：计算衰减因子 $$a$$**\n\n目标是调整增益，使得终点前的信号水平处于 ADC 满量程的一个分数 $$\\gamma$$，从而防止饱和。在放大器前引入一个衰减因子 $$a$$，因此有效输入强度为 $$a I_{0}$$。由此产生的终点前电压为 $$V'_{\\text{pre}} = G (a I_0)$$。\n条件是：\n$$V'_{\\text{pre}} = \\gamma V_{\\text{FS}}$$\n因此，我们必须解以下方程求 $$a$$：\n$$a G I_{0} = \\gamma V_{\\text{FS}}$$\n$$a = \\frac{\\gamma V_{\\text{FS}}}{G I_{0}}$$\n代入给定的数值：\n$$\\gamma = 0.80$$\n我们已经计算出 $$G I_{0} = 0.75 \\ \\text{V}$$，且给定 $$V_{\\text{FS}} = 0.50 \\ \\text{V}$$.\n$$a = \\frac{0.80 \\times 0.50 \\ \\text{V}}{0.75 \\ \\text{V}} = \\frac{0.40}{0.75}$$\n$$a = \\frac{40}{75} = \\frac{8}{15} \\approx 0.533333...$$\n四舍五入到四位有效数字，$$a = 0.5333$$。这是一个无量纲的量。\n\n我们被要求以一个二元行矩阵 $$\\begin{pmatrix} \\Delta t  a \\end{pmatrix}$$ 的形式提供最终答案。\n根据我们计算和四舍五入的值，结果是 $$\\begin{pmatrix} 0.06082  0.5333 \\end{pmatrix}$$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.06082  0.5333\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一旦采集到（可能不完美的）信号，最终的挑战便是做出可靠的决策：终点是否已经到达？这是一个通常采用统计方法解决的分类问题。接收者操作特征（ROC）分析是评估和优化二元分类器性能的强大工具。通过扫描决策阈值，我们可以直观地看到正确识别终点（真阳性率）与错误提前触发（假阳性率）之间的权衡。这项基于编程的实践将引导您完成一个完整的数据分析流程：合成含噪声的真实OES数据，应用去噪滤波器，并利用ROC分析和尤登指数（Youden's J statistic）来确定最佳检测阈值，让您亲身体验现代终点检测系统核心的统计信号处理技术 。",
            "id": "4124311",
            "problem": "您将要执行一项针对半导体制造中光学发射光谱（OES）终点检测的建模任务。终点对应于等离子体信号中某一活性物质因工艺完成而发生转变的时刻，通常表现为 OES 强度的下降。您需要从一个基于原理的形成模型中合成带标签的、物理上合理的 OES 信号，应用去噪滤波器，为一系列通过对去噪信号进行阈值处理而定义的二元分类器构建受试者工作特征（ROC）曲线，并选择使 Youden J 统计量最大化的阈值。您的程序必须确定性地实现整个流程，并以指定格式输出最终结果。\n\n基本原理：\n- 光学发射光谱（OES）强度可以建模为从终点前状态到终点后状态的平滑时间过渡，并受到测量噪声和工艺振荡的干扰。\n- 可以通过对去噪后的 OES 强度进行阈值处理来构建用于终点状态的二元分类器。真实标签根据已知的终点时间定义。\n- 受试者工作特征（ROC）曲线关联了在所有阈值下的真阳性率与假阳性率。\n- Youden J 统计量由灵敏度（真阳性率）和假阳性率定义，用于选择最佳阈值。\n\n信号形成模型：\n对于每次运行 $r$（其终点时间为 $t_{\\mathrm{EP}}^{(r)}$），定义时间 $t \\in [0,T]$ 和采样率 $f_s$。离散时间点为 $t_i = i \\Delta t$，其中 $i = 0,1,\\dots,N-1$，$\\Delta t = 1/f_s$ 且 $N = \\lfloor T f_s \\rfloor$。OES 强度为\n$$\nx^{(r)}(t_i) = I_0 + a\\, t_i - \\Delta I \\cdot s\\big(t_i - t_{\\mathrm{EP}}^{(r)}\\big) + A \\sin\\big(2\\pi f\\, t_i\\big) + \\epsilon^{(r)}(t_i),\n$$\n其中 $I_0$ 是终点前基线强度，$a$ 是线性漂移系数，$\\Delta I$ 是下降幅度，$s(u) = \\frac{1}{1 + e^{-u/\\tau}}$ 是一个时间常数为 $\\tau$ 的逻辑斯谛阶跃，$A$ 和 $f$ 分别是等离子体闪烁振荡的振幅和频率，而 $\\epsilon^{(r)}(t_i)$ 是标准差为 $\\sigma$ 的零均值高斯噪声。每个测试用例使用一个固定的伪随机种子来确定性地生成 $\\epsilon^{(r)}(t_i)$。\n\n真实标签定义：\n对于每次运行 $r$，通过以下方式定义二元标签 $y^{(r)}(t_i)$\n$$\ny^{(r)}(t_i) = \\begin{cases}\n0,  t_i  t_{\\mathrm{EP}}^{(r)},\\\\\n1,  t_i \\ge t_{\\mathrm{EP}}^{(r)}.\n\\end{cases}\n$$\n\n去噪：\n令 $\\tilde{x}^{(r)}(t_i)$ 为对 $x^{(r)}(t_i)$ 应用零相位局部多项式平滑器后得到的去噪信号。在实现中，使用一个多项式阶数 $p = 3$ 的 Savitzky–Golay 滤波器，并选择一个奇数窗口长度，使其覆盖大约 $0.15$ 秒，调整后长度至少为 5 个样本且严格小于 $N$。\n\n阈值分类器与 ROC：\n对于一个阈值 $\\theta$，在时间 $t_i$ 的分类器定义为\n$$\n\\hat{y}^{(r)}_\\theta(t_i) = \\begin{cases}\n1,  \\tilde{x}^{(r)}(t_i) \\le \\theta,\\\\\n0,  \\tilde{x}^{(r)}(t_i) > \\theta.\n\\end{cases}\n$$\n将所有运行中的所有样本聚合到一个集合中。对于任何 $\\theta$，计算：\n- 真阳性 $TP(\\theta)$：$\\hat{y}^{(r)}_\\theta(t_i) = 1$ 且 $y^{(r)}(t_i) = 1$ 的样本数量。\n- 假阳性 $FP(\\theta)$：$\\hat{y}^{(r)}_\\theta(t_i) = 1$ 且 $y^{(r)}(t_i) = 0$ 的样本数量。\n- 真阴性 $TN(\\theta)$ 和假阴性 $FN(\\theta)$ 的定义与此类似。\n将阳性样本总数 $P = TP(\\theta) + FN(\\theta)$ 和阴性样本总数 $N = TN(\\theta) + FP(\\theta)$ 定义为一旦标签固定后就与 $\\theta$ 无关的常数。那么，真阳性率（灵敏度）和假阳性率分别为\n$$\n\\mathrm{TPR}(\\theta) = \\frac{TP(\\theta)}{P}, \\quad \\mathrm{FPR}(\\theta) = \\frac{FP(\\theta)}{N}.\n$$\nYouden J 统计量为\n$$\nJ(\\theta) = \\mathrm{TPR}(\\theta) - \\mathrm{FPR}(\\theta).\n$$\n\n选择：\n在一个包含 $M$ 个阈值的网格上扫描 $\\theta$，该网格均匀地覆盖所有运行中去噪信号强度的全局范围，即在 $\\min_{r,i} \\tilde{x}^{(r)}(t_i)$ 和 $\\max_{r,i} \\tilde{x}^{(r)}(t_i)$ 之间。使用 $M = 301$ 个阈值。选择使 $J(\\theta)$ 最大化的 $\\theta^\\star$。如果 $J(\\theta)$ 出现平局，选择具有最大 $\\mathrm{TPR}(\\theta)$ 的 $\\theta$。如果仍然存在平局，则选择其中最小的 $\\theta$。\n\n单位：\n- 时间必须以秒（$\\mathrm{s}$）表示。\n- 采样率以赫兹（$\\mathrm{Hz}$）表示。\n- OES 强度以任意单位（$\\mathrm{a.u.}$）表示。\n- 漂移以 $\\mathrm{a.u.}/\\mathrm{s}$ 表示。\n- 噪声标准差以 $\\mathrm{a.u.}$ 表示。\n- 频率以赫兹（$\\mathrm{Hz}$）表示。\n\n测试套件：\n为以下参数集实现该流程。在计算 ROC 和选择 $\\theta^\\star$ 时，每个测试用例都会聚合该用例中的所有运行。\n\n- 测试用例 1（下降明显，中等噪声）：\n    - 运行次数 $R = 4$。\n    - 持续时间 $T = 5\\,\\mathrm{s}$。\n    - 采样率 $f_s = 200\\,\\mathrm{Hz}$。\n    - 终点时间 $\\big[t_{\\mathrm{EP}}^{(r)}\\big] = [2.0,\\,2.5,\\,3.0,\\,2.7]\\,\\mathrm{s}$。\n    - 基线 $I_0 = 1.0\\,\\mathrm{a.u.}$。\n    - 下降幅度 $\\Delta I = 0.4\\,\\mathrm{a.u.}$。\n    - 时间常数 $\\tau = 0.05\\,\\mathrm{s}$。\n    - 漂移 $a = 0.0\\,\\mathrm{a.u.}/\\mathrm{s}$。\n    - 闪烁振幅 $A = 0.02\\,\\mathrm{a.u.}$，频率 $f = 6\\,\\mathrm{Hz}$。\n    - 噪声标准差 $\\sigma = 0.03\\,\\mathrm{a.u.}$。\n    - 伪随机种子 $0$。\n\n- 测试用例 2（下降微小，噪声相似）：\n    - 运行次数 $R = 4$。\n    - 持续时间 $T = 5\\,\\mathrm{s}$。\n    - 采样率 $f_s = 200\\,\\mathrm{Hz}$。\n    - 终点时间 $\\big[t_{\\mathrm{EP}}^{(r)}\\big] = [2.5,\\,2.5,\\,2.5,\\,2.5]\\,\\mathrm{s}$。\n    - 基线 $I_0 = 1.0\\,\\mathrm{a.u.}$。\n    - 下降幅度 $\\Delta I = 0.05\\,\\mathrm{a.u.}$。\n    - 时间常数 $\\tau = 0.05\\,\\mathrm{s}$。\n    - 漂移 $a = 0.0\\,\\mathrm{a.u.}/\\mathrm{s}$。\n    - 闪烁振幅 $A = 0.01\\,\\mathrm{a.u.}$，频率 $f = 8\\,\\mathrm{Hz}$。\n    - 噪声标准差 $\\sigma = 0.05\\,\\mathrm{a.u.}$。\n    - 伪随机种子 $0$。\n\n- 测试用例 3（噪声大，有漂移，终点靠近边界）：\n    - 运行次数 $R = 3$。\n    - 持续时间 $T = 5\\,\\mathrm{s}$。\n    - 采样率 $f_s = 200\\,\\mathrm{Hz}$。\n    - 终点时间 $\\big[t_{\\mathrm{EP}}^{(r)}\\big] = [0.3,\\,4.7,\\,2.0]\\,\\mathrm{s}$。\n    - 基线 $I_0 = 1.0\\,\\mathrm{a.u.}$。\n    - 下降幅度 $\\Delta I = 0.3\\,\\mathrm{a.u.}$。\n    - 时间常数 $\\tau = 0.07\\,\\mathrm{s}$。\n    - 漂移 $a = 0.02\\,\\mathrm{a.u.}/\\mathrm{s}$。\n    - 闪烁振幅 $A = 0.03\\,\\mathrm{a.u.}$，频率 $f = 5\\,\\mathrm{Hz}$。\n    - 噪声标准差 $\\sigma = 0.10\\,\\mathrm{a.u.}$。\n    - 伪随机种子 $123$。\n\n所需最终输出：\n您的程序应生成一行输出，其中包含一个列表的列表形式的结果，每个测试用例对应一个内层列表。每个内层列表包含选定的阈值和对应的 Youden J 统计量，阈值为以 $\\mathrm{a.u.}$ 为单位的实数，$J$ 为无单位实数。格式必须是包含在方括号内的逗号分隔列表，例如：\n$$\n\\text{[ [}\\theta^\\star_1\\text{, }J^\\star_1\\text{], [}\\theta^\\star_2\\text{, }J^\\star_2\\text{], [}\\theta^\\star_3\\text{, }J^\\star_3\\text{] ]}\n$$\n您的实现必须是自包含的，不需要任何输入，并遵循执行环境的约束。",
            "solution": "该问题要求为光学发射光谱（OES）终点检测实现一个完整的计算流程。这包括基于所提供的模型合成物理上合理的 OES 信号，应用去噪滤波器，然后通过构建受试者工作特征（ROC）曲线并最大化 Youden J 统计量来确定最佳分类阈值。该过程将针对三个不同的测试用例执行。\n\n该方法是确定性的，并遵循一系列定义明确的步骤：\n\n1.  **信号形成**：对于每个测试用例中的每次运行 $r$，生成一个时间序列信号 $x^{(r)}(t_i)$。该信号是代表等离子体刻蚀过程中物理现象的多个分量的复合体。\n2.  **去噪**：使用 Savitzky-Golay 滤波器处理包含噪声的合成信号 $x^{(r)}(t_i)$，以生成平滑信号 $\\tilde{x}^{(r)}(t_i)$。\n3.  **分类与评估**：聚合给定测试用例的所有运行中生成的所有数据点。将一个基于可变阈值 $\\theta$ 的二元分类器应用于去噪信号。通过改变 $\\theta$，计算真阳性率（$\\mathrm{TPR}$）和假阳性率（$\\mathrm{FPR}$），从而形成 ROC 曲线。\n4.  **最佳阈值选择**：为每个阈值计算 Youden J 统计量 $J(\\theta) = \\mathrm{TPR}(\\theta) - \\mathrm{FPR}(\\theta)$。选择使 $J(\\theta)$ 最大化的阈值为最佳阈值 $\\theta^\\star$，并有特定的平局打破规则。\n\n以下是该实现的详细分步描述。\n\n**步骤 1：信号生成**\n对于每个测试用例以及从 $1$ 到 $R$ 的每次运行 $r$，我们首先建立时域。给定总持续时间 $T$ 和采样率 $f_s$，时间步长为 $\\Delta t = 1/f_s$。离散时间点为 $t_i = i \\Delta t$，其中 $i = 0, 1, \\dots, N-1$，样本总数为 $N = \\lfloor T f_s \\rfloor$。 OES 强度信号 $x^{(r)}(t_i)$ 根据以下模型合成：\n$$\nx^{(r)}(t_i) = I_0 + a\\, t_i - \\Delta I \\cdot s\\big(t_i - t_{\\mathrm{EP}}^{(r)}\\big) + A \\sin\\big(2\\pi f\\, t_i\\big) + \\epsilon^{(r)}(t_i)\n$$\n每个项的计算如下：\n-   **基线与漂移**：项 $I_0 + a\\, t_i$ 建模了初始强度 $I_0$ 以及系数为 $a$ 的线性漂移。\n-   **终点过渡**：项 $-\\Delta I \\cdot s(t_i - t_{\\mathrm{EP}}^{(r)})$ 建模了终点处的强度下降。下降幅度为 $\\Delta I$。过渡的形状由逻辑斯谛函数 $s(u) = \\frac{1}{1 + e^{-u/\\tau}}$ 控制，该函数创建了一个以终点时间 $t_{\\mathrm{EP}}^{(r)}$ 为中心、特征持续时间由时间常数 $\\tau$ 控制的平滑阶跃。\n-   **振荡**：项 $A \\sin(2\\pi f t_i)$ 建模了振幅为 $A$ 频率为 $f$ 的周期性等离子体闪烁。\n-   **噪声**：项 $\\epsilon^{(r)}(t_i)$ 代表测量噪声，建模为来自标准差为 $\\sigma$ 的零均值高斯分布的一系列独立同分布的随机变量。为保证确定性复现，使用为每个测试用例提供的特定值对伪随机数生成器进行播种。\n\n**步骤 2：真实标签定义**\n与信号生成同时，为每个时间点创建真实标签 $y^{(r)}(t_i)$。这些标签定义了过程的真实状态，即“终点前”或“终点后”。根据问题描述，状态在终点时间 $t_{\\mathrm{EP}}^{(r)}$ 发生转变：\n$$\ny^{(r)}(t_i) = \\begin{cases}\n0,  t_i  t_{\\mathrm{EP}}^{(r)} \\quad \\text{(终点前)}\\\\\n1,  t_i \\ge t_{\\mathrm{EP}}^{(r)} \\quad \\text{(终点后)}\n\\end{cases}\n$$\n\n**步骤 3：信号去噪**\n对原始的含噪信号 $x^{(r)}(t_i)$ 进行平滑处理，以更好地揭示其潜在的过渡。为此采用了零相位的 Savitzky-Golay 滤波器。该滤波器在移动窗口中对数据进行局部多项式拟合。问题指定了多项式阶数为 $p=3$。窗口长度选择为跨越大约 $0.15\\,\\mathrm{s}$。对于给定的采样率 $f_s = 200\\,\\mathrm{Hz}$，这对应于 $0.15\\,\\mathrm{s} \\times 200\\,\\mathrm{Hz} = 30$ 个样本。由于窗口长度必须是奇数，因此使用下一个奇数 $31$。该值满足至少为 $5$ 且严格小于总样本数 $N=1000$ 的约束。将此滤波器应用于 $x^{(r)}(t_i)$ 可得到去噪信号 $\\tilde{x}^{(r)}(t_i)$。\n\n**步骤 4：数据聚合与分类器定义**\n对于每个测试用例，将所有 $R$ 次运行的去噪信号 $\\tilde{x}^{(r)}(t_i)$ 和真实标签 $y^{(r)}(t_i)$ 连接成单个、大型的一维数组。我们称之为 $\\tilde{x}_{\\mathrm{agg}}$ 和 $y_{\\mathrm{agg}}$。\n\n基于阈值 $\\theta$ 定义了一个简单的二元分类器。由于终点的特征是强度下降，如果一个样本的强度低于阈值，则将其分类为“终点后”（标签 1）：\n$$\n\\hat{y}_{\\theta}(t_i) = \\begin{cases}\n1,  \\tilde{x}_{\\mathrm{agg}}(t_i) \\le \\theta\\\\\n0,  \\tilde{x}_{\\mathrm{agg}}(t_i) > \\theta\n\\end{cases}\n$$\n\n**步骤 5：ROC 分析与最佳阈值选择**\n为了找到最佳阈值 $\\theta^\\star$，我们在一个可能的阈值范围内评估分类器的性能。创建一个包含 $M=301$ 个阈值的网格，该网格均匀地覆盖了从聚合去噪信号 $\\tilde{x}_{\\mathrm{agg}}$ 的最小值到最大值的范围。\n\n对于网格中的每个阈值 $\\theta$，我们通过将预测标签 $\\hat{y}_{\\theta}$ 与真实标签 $y_{\\mathrm{agg}}$ 进行比较，来计算真阳性（$TP$）、假阳性（$FP$）、真阴性（$TN$）和假阴性（$FN$）的数量。\n\n实际阳性实例的总数是 $P = TP + FN = \\sum y_{\\mathrm{agg}}$，实际阴性实例的总数是 $N = TN + FP = \\mathrm{length}(y_{\\mathrm{agg}}) - P$。对于给定的测试用例，这些是常数。\n\n然后计算真阳性率（$\\mathrm{TPR}$，或灵敏度）和假阳性率（$\\mathrm{FPR}$）：\n$$\n\\mathrm{TPR}(\\theta) = \\frac{TP(\\theta)}{P}, \\quad \\mathrm{FPR}(\\theta) = \\frac{FP(\\theta)}{N}\n$$\nYouden J 统计量计算为 $J(\\theta) = \\mathrm{TPR}(\\theta) - \\mathrm{FPR}(\\theta)$。\n\n最佳阈值 $\\theta^\\star$ 是使 $J(\\theta)$ 最大化的那个值。问题指定了一个平局打破程序：\n1.  如果多个阈值得出相同的最大 $J$ 值，则选择 $\\mathrm{TPR}$ 最高的那个。\n2.  如果仍然存在平局，则选择候选者中最小的 $\\theta$。\n通过按升序迭代阈值，并仅在根据有序标准找到一组严格更优的度量时才更新找到的最佳结果（$\\theta^\\star, J(\\theta^\\star), \\mathrm{TPR}(\\theta^\\star)$），来实现此搜索。\n\n对三个测试用例中的每一个都执行这整个流程，每个用例的最终结果是数对 $[\\theta^\\star, J(\\theta^\\star)]$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import savgol_filter\nfrom scipy.special import expit\n\ndef solve():\n    \"\"\"\n    Implements the full OES endpoint detection pipeline for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: clear drop, moderate noise\n        {\n            \"R\": 4, \"T\": 5, \"f_s\": 200, \"t_EP\": [2.0, 2.5, 3.0, 2.7],\n            \"I0\": 1.0, \"DeltaI\": 0.4, \"tau\": 0.05, \"a\": 0.0,\n            \"A\": 0.02, \"f\": 6, \"sigma\": 0.03, \"seed\": 0\n        },\n        # Test Case 2: small drop, similar noise\n        {\n            \"R\": 4, \"T\": 5, \"f_s\": 200, \"t_EP\": [2.5, 2.5, 2.5, 2.5],\n            \"I0\": 1.0, \"DeltaI\": 0.05, \"tau\": 0.05, \"a\": 0.0,\n            \"A\": 0.01, \"f\": 8, \"sigma\": 0.05, \"seed\": 0\n        },\n        # Test Case 3: heavy noise, drift, endpoints near boundaries\n        {\n            \"R\": 3, \"T\": 5, \"f_s\": 200, \"t_EP\": [0.3, 4.7, 2.0],\n            \"I0\": 1.0, \"DeltaI\": 0.3, \"tau\": 0.07, \"a\": 0.02,\n            \"A\": 0.03, \"f\": 5, \"sigma\": 0.10, \"seed\": 123\n        }\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        # Step 1  2: Generate signals and ground truth labels for all runs\n        N = int(params[\"T\"] * params[\"f_s\"])\n        t = np.linspace(0, params[\"T\"], N, endpoint=False)\n        \n        all_x_raw = []\n        all_y_true = []\n        \n        rng = np.random.default_rng(params[\"seed\"])\n\n        for r in range(params[\"R\"]):\n            t_ep_r = params[\"t_EP\"][r]\n            \n            # Signal components\n            drift = params[\"a\"] * t\n            # logistic_step = 1 / (1 + np.exp(-(t - t_ep_r) / params[\"tau\"]))\n            logistic_step = expit((t - t_ep_r) / params[\"tau\"])\n            intensity_drop = -params[\"DeltaI\"] * logistic_step\n            flicker = params[\"A\"] * np.sin(2 * np.pi * params[\"f\"] * t)\n            noise = rng.normal(0, params[\"sigma\"], size=N)\n            \n            x_raw = params[\"I0\"] + drift + intensity_drop + flicker + noise\n            all_x_raw.append(x_raw)\n            \n            # Ground truth labels\n            y_true = (t >= t_ep_r).astype(int)\n            all_y_true.append(y_true)\n\n        # Step 3: Denoise signals\n        # Calculate Savitzky-Golay window length\n        window_len = int(0.15 * params[\"f_s\"])\n        if window_len % 2 == 0:\n            window_len += 1\n        window_len = max(5, window_len)\n        \n        all_x_denoised = []\n        for x_raw in all_x_raw:\n            x_denoised = savgol_filter(x_raw, window_length=window_len, polyorder=3)\n            all_x_denoised.append(x_denoised)\n\n        # Step 4: Aggregate data\n        x_agg = np.concatenate(all_x_denoised)\n        y_agg = np.concatenate(all_y_true)\n\n        # Step 5: ROC analysis and optimal threshold selection\n        M = 301\n        thresholds = np.linspace(np.min(x_agg), np.max(x_agg), M)\n        \n        P = np.sum(y_agg == 1)\n        N_total = len(y_agg) - P\n\n        best_j = -2.0  # J is in [-1, 1]\n        best_tpr = -1.0\n        best_theta = thresholds[0]\n\n        if P == 0 or N_total == 0:\n            # Handle edge cases where one class is not present, though unlikely\n            # with the problem setup.\n            all_results.append([best_theta, best_j])\n            continue\n            \n        for theta in thresholds:\n            y_pred = (x_agg = theta).astype(int)\n            \n            tp = np.sum((y_pred == 1)  (y_agg == 1))\n            fp = np.sum((y_pred == 1)  (y_agg == 0))\n            \n            tpr = tp / P\n            fpr = fp / N_total\n            \n            j_stat = tpr - fpr\n            \n            # Apply selection criteria with tie-breaking\n            # Criterion 1: Maximize J\n            if j_stat > best_j:\n                best_j = j_stat\n                best_tpr = tpr\n                best_theta = theta\n            # Criterion 2: For same J, maximize TPR\n            elif j_stat == best_j:\n                if tpr > best_tpr:\n                    best_tpr = tpr\n                    best_theta = theta\n            # Criterion 3 (smallest theta) is handled implicitly by iterating\n            # thresholds in increasing order. The first time we find the best\n            # (J, TPR) pair, we lock in the theta.\n        \n        all_results.append([best_theta, best_j])\n\n    # Final output formatting\n    # The default str() for a list gives '[item1, item2]', which has a space. This\n    # matches the problem's example format: \"[ [t1, J1], [t2, J2], ... ]\".\n    # Using 'repr' is a robust way to get the standard string representation.\n    print(repr(all_results).replace(\" \", \"\"))\n\n# The above repr().replace(\" \", \"\") produces output like [[theta,J],[theta,J],...]\n# for example [[0.81,0.96],[0.97,0.76],[0.83,0.91]]. The prompt example `[ [a, b], [c, d] ]`\n# suggests spaces. The `solve()` skeleton print statement `f\"[{','.join(map(str, results))}]\"`\n# for `results=[[a,b],[c,d]]` would produce `'[[a, b],[c, d]]'`.\n# Let's write a manual formatter to be very precise to the ambiguity.\n# The `repr` output with spaces `[[a, b], [c, d]]` seems the most faithful interpretation of the\n# example formatting `[ [theta_1, J_1], ... ]`. The default python `print` of a list of lists.\n#\n# Let's re-examine `print(f\"[{','.join(map(str, results))}]\")`\n# a = [[1, 2], [3, 4]]; print(f\"[{','.join(map(str, a))}]\")\n# -> '[[1, 2],[3, 4]]'. This has no spaces between inner lists.\n# The prompt example `[ [t1, J1], [t2, J2] ]` has spaces.\n# I will use a simple `str(list)` which gives spaces and is standard.\n\ndef precise_solve():\n    \"\"\"\n    Implements the full OES endpoint detection pipeline for all test cases.\n    This version refines the final print statement to exactly match the\n    most likely intended format.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\"R\": 4, \"T\": 5, \"f_s\": 200, \"t_EP\": [2.0, 2.5, 3.0, 2.7], \"I0\": 1.0, \"DeltaI\": 0.4, \"tau\": 0.05, \"a\": 0.0, \"A\": 0.02, \"f\": 6, \"sigma\": 0.03, \"seed\": 0},\n        # Test Case 2\n        {\"R\": 4, \"T\": 5, \"f_s\": 200, \"t_EP\": [2.5, 2.5, 2.5, 2.5], \"I0\": 1.0, \"DeltaI\": 0.05, \"tau\": 0.05, \"a\": 0.0, \"A\": 0.01, \"f\": 8, \"sigma\": 0.05, \"seed\": 0},\n        # Test Case 3\n        {\"R\": 3, \"T\": 5, \"f_s\": 200, \"t_EP\": [0.3, 4.7, 2.0], \"I0\": 1.0, \"DeltaI\": 0.3, \"tau\": 0.07, \"a\": 0.02, \"A\": 0.03, \"f\": 5, \"sigma\": 0.10, \"seed\": 123},\n    ]\n\n    final_results = []\n    \n    for params in test_cases:\n        N = int(params[\"T\"] * params[\"f_s\"])\n        t = np.linspace(0, params[\"T\"], N, endpoint=False)\n        rng = np.random.default_rng(params[\"seed\"])\n        \n        all_x_raw, all_y_true = [], []\n        for t_ep_r in params[\"t_EP\"]:\n            logistic_step = expit((t - t_ep_r) / params[\"tau\"])\n            x_raw = (params[\"I0\"] + params[\"a\"] * t - params[\"DeltaI\"] * logistic_step\n                     + params[\"A\"] * np.sin(2 * np.pi * params[\"f\"] * t)\n                     + rng.normal(0, params[\"sigma\"], size=N))\n            all_x_raw.append(x_raw)\n            all_y_true.append((t >= t_ep_r).astype(int))\n            \n        window_len = int(0.15 * params[\"f_s\"])\n        if window_len % 2 == 0: window_len += 1\n        window_len = max(5, window_len)\n        \n        all_x_denoised = [savgol_filter(x, window_length=window_len, polyorder=3) for x in all_x_raw]\n        \n        x_agg = np.concatenate(all_x_denoised)\n        y_agg = np.concatenate(all_y_true)\n        \n        M = 301\n        thresholds = np.linspace(np.min(x_agg), np.max(x_agg), M)\n        \n        P = np.sum(y_agg)\n        N_total = len(y_agg) - P\n        \n        best_j, best_tpr, best_theta = -2.0, -1.0, thresholds[0]\n        \n        if P > 0 and N_total > 0:\n            for theta in thresholds:\n                y_pred = (x_agg = theta).astype(int)\n                tp = np.sum((y_pred == 1)  (y_agg == 1))\n                fp = np.sum((y_pred == 1)  (y_agg == 0))\n                \n                tpr, fpr = tp / P, fp / N_total\n                j_stat = tpr - fpr\n                \n                # Tie-breaking logic\n                # Using a small epsilon for float comparison safety\n                epsilon = 1e-9\n                if j_stat > best_j + epsilon:\n                    best_j, best_tpr, best_theta = j_stat, tpr, theta\n                elif abs(j_stat - best_j)  epsilon and tpr > best_tpr + epsilon:\n                    best_tpr, best_theta = tpr, theta\n        \n        final_results.append([best_theta, best_j])\n        \n    # Format the final output to match `[ [val, val], [val, val] ]`\n    inner_strs = [f\"[{t},{j}]\" for t, j in final_results]\n    print(f\"[{','.join(inner_strs)}]\")\n\nprecise_solve()\n```"
        }
    ]
}