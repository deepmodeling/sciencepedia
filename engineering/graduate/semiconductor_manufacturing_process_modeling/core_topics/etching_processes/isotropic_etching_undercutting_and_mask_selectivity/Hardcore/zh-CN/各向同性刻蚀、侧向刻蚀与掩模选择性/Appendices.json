{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的工艺模型之前，理解各向同性刻蚀的基本定义至关重要。理想的各向同性刻蚀意味着刻蚀前沿在所有方向上都以相同的速率推进，不受局部几何形状的影响。这项练习通过推导一个可测试的几何结论来巩固这一概念，揭示了一个简单的尺寸变化比率如何成为工艺表征的有力诊断工具。",
            "id": "4136847",
            "problem": "各向异性刻蚀会以不相等的速率加宽不同的掩模开口，而理想的各向同性刻蚀则以相同的法向速度在暴露表面的每一点上推进材料去除前沿，且该速度与方向无关。考虑一个平面薄膜，其上覆盖着一层具有有效无限选择比的刚性、不可刻蚀的掩模。该掩模定义了两个开口：(i) 一个初始直径为 $D_0$ 的圆形孔，以及 (ii) 一个初始宽度为 $W_0$ 的长槽，其长度远大于 $W_0$，因此末端效应可以忽略。该薄膜经过一次实验上旨在实现各向同性的刻蚀，其法向刻蚀前沿速度 $v_n$ 是一个常数，不依赖于位置、方向、曲率或时间。在持续时间为 $t$ 的刻蚀之后，掩模下方的侧向掏蚀导致两个开口在掩模平面上测量时都发生了横向扩展。将圆形孔的扩展量 $\\Delta D$ 定义为在掩模平面上测得的孔直径的增加量，将槽的增宽量 $\\Delta W$ 定义为在掩模平面上测得的槽宽度的增加量。在上述假设下，且两种特征的刻蚀时间 $t$ 相同，请从第一性原理出发，推导出理想各向同性刻蚀下的预期比率\n$$\n\\mathcal{R}_{\\text{iso}} \\equiv \\frac{\\Delta D}{\\Delta W}\n$$\n。请以一个无量纲数的形式给出你的答案；无需四舍五入。",
            "solution": "问题陈述已经过验证，被确定为是合理的、适定的且具有科学依据的。它提出了一个理想化的各向同性刻蚀情景，这是微加工工艺理论中的一个标准模型。所提供的假设是一致且充分的，足以从第一性原理推导出一个唯一的解。\n\n如问题所述，理想各向同性刻蚀的核心原理是，材料去除前沿以恒定的法向速度 $v_n$ 从暴露表面的每一点向前推进。经过持续时间为 $t$ 的刻蚀后，新的刻蚀表面是以掩模所暴露的薄膜初始表面上的每一点为中心、半径为 $R = v_n t$ 的球体的包络面。对槽和圆形孔的增宽分析，取决于对这种传播几何的理解，特别是对非刻蚀掩模下方的侧向掏蚀的理解。\n\n我们首先分析长槽的增宽量 $\\Delta W$。问题陈述指出，槽的长度远大于其宽度 $W_0$，这使我们可以忽略末端效应。这将分析简化为垂直于槽长度的二维横截面。在这个横截面中，掩模有一个宽度为 $W_0$ 的开口。我们建立一个坐标系，其中掩模平面位于 $z=0$，开口从 $x = -W_0/2$ 延伸到 $x = W_0/2$。待刻蚀的材料位于半空间 $z \\le 0$ 中。\n\n初始暴露表面是 $xz$ 平面内从 $(-W_0/2, 0)$ 到 $(W_0/2, 0)$ 的线段。刻蚀前沿从该线段上的每一点开始传播。决定侧向掏蚀的最关键点是掩模开口的边缘，位于 $x = -W_0/2$ 和 $x = W_0/2$ 处。由于刻蚀的各向同性，前沿从这些边缘点以半球形（或者在我们的二维横截面中，以半圆形）的方式向薄膜内部传播。\n\n经过时间 $t$ 后，右侧（$x > W_0/2$）掩模下方的刻蚀轮廓是一个以 $(W_0/2, 0)$ 为中心、半径为 $R = v_n t$ 的四分之一圆。其方程为 $(x - W_0/2)^2 + z^2 = (v_n t)^2$，其中 $x \\ge W_0/2$ 且 $z \\le 0$。类似地，左侧（$x  -W_0/2$）掩模下方的轮廓是一个以 $(-W_0/2, 0)$ 为中心、半径为 $R = v_n t$ 的四分之一圆。\n\n槽的增宽量 $\\Delta W$ 定义为在掩模平面（$z=0$）上测得的槽宽度的增加量。在 $z=0$ 处，通过在四分之一圆方程中设置 $z=0$ 可以找到开口新的右边缘：$(x - W_0/2)^2 = (v_n t)^2$。这得出 $x - W_0/2 = v_n t$，即 $x = W_0/2 + v_n t$。类似地，可以找到新的左边缘在 $x = -W_0/2 - v_n t$ 处。在掩模平面上，开口新的总宽度 $W_f$ 是这两个新边缘之间的距离：\n$$\nW_f = \\left(\\frac{W_0}{2} + v_n t\\right) - \\left(-\\frac{W_0}{2} - v_n t\\right) = W_0 + 2 v_n t\n$$\n槽的增宽量 $\\Delta W$ 是最终宽度与初始宽度之差：\n$$\n\\Delta W = W_f - W_0 = (W_0 + 2 v_n t) - W_0 = 2 v_n t\n$$\n量 $v_n t$ 表示从一侧测量的掩模下方的侧向掏蚀距离。\n\n接下来，我们分析圆形孔的扩展量 $\\Delta D$。初始开口是一个直径为 $D_0$ 的圆。这是一个具有轴对称性的三维问题。我们可以通过取穿过孔中心的二维横截面来分析它。这个横截面在几何上与我们刚才分析的槽问题完全相同，只是初始开口的宽度为 $D_0$。\n\n刻蚀前沿从掩模开口的圆形边缘开始传播。由于各向同性，侧向掏蚀将沿径向均匀进行。在掩模平面上，从孔的初始边缘向外径向测量的掏蚀距离，同样由边缘处的传播决定。这个径向掏蚀距离是 $v_n t$。\n\n孔的初始半径为 $r_0 = D_0/2$。经过刻蚀时间 $t$ 后，在掩模平面上，开口的新半径 $r_f$ 是初始半径加上径向掏蚀距离：\n$$\nr_f = r_0 + v_n t = \\frac{D_0}{2} + v_n t\n$$\n新直径 $D_f$ 是新半径的两倍：\n$$\nD_f = 2 r_f = 2 \\left(\\frac{D_0}{2} + v_n t\\right) = D_0 + 2 v_n t\n$$\n圆形孔的扩展量 $\\Delta D$ 是最终直径与初始直径之差：\n$$\n\\Delta D = D_f - D_0 = (D_0 + 2 v_n t) - D_0 = 2 v_n t\n$$\n我们观察到，圆形孔直径的增加量与长槽宽度的增加量是相同的。这是理想各向同性刻蚀模型的一个基本推论，即侧向掏蚀速率与掩模边缘的曲率无关。\n\n最后，我们计算所要求的比率 $\\mathcal{R}_{\\text{iso}}$：\n$$\n\\mathcal{R}_{\\text{iso}} \\equiv \\frac{\\Delta D}{\\Delta W}\n$$\n代入我们推导出的 $\\Delta D$ 和 $\\Delta W$ 的表达式：\n$$\n\\mathcal{R}_{\\text{iso}} = \\frac{2 v_n t}{2 v_n t} = 1\n$$\n该比率是一个值为 $1$ 的无量纲常数。只要模型条件得到满足，这个结果就成立，而与初始尺寸 $D_0$ 和 $W_0$、刻蚀速度 $v_n$ 或刻蚀时间 $t$ 无关。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "理想模型假设刻蚀速率是恒定的，但在现实中，该速率可能受限于刻蚀剂分子到达反应表面的速度。本练习探讨了菲克扩散（输运）与表面反应动力学之间的耦合作用，并演示了从反应限制到扩散限制状态的转变。通过推导并求解控制方程，您将量化扩散如何在诸如底切通道等受限空间中减缓刻蚀速率，这是微加工实践中一个至关重要的效应。",
            "id": "4136868",
            "problem": "您的任务是为一个平面掩膜下的湿法各向同性腐蚀工艺实现一个耦合输运-反应求解器，并用它来量化扩散限制如何导致偏离简单的解析底切关系 $u = R t$。底切距离 $u$ 定义为腐蚀前沿在掩膜下方的横向推进距离。假设液体为等温、稀溶液，并且沿底切路径的扩散为稳态。\n\n从以下基本定义和核心概念开始：\n\n- 菲克第一定律对于一维稳态扩散：蚀刻剂的摩尔通量 $J$ 由 $J = -D \\,\\frac{dC}{dx}$ 给出，其中 $D$ 是扩散系数， $C$ 是浓度。\n- 腐蚀前沿处的一级表面反应边界条件：表面的消耗通量满足 $J = k_s \\, C_{\\text{front}}$，其中 $k_s$ 是表面动力学系数， $C_{\\text{front}}$ 是腐蚀前沿的浓度。\n- 消耗通量与界面速度之间的化学计量联系：界面速度 $v$（等于局部腐蚀速率）与摩尔通量通过 $v = \\frac{J}{n}$ 相关联，其中 $n$ 是移除单位体积固体所需的摩尔量。\n- 各向同性：在某一点上，所有方向的腐蚀速率都相同，并由该点的局部蚀刻剂浓度控制。\n\n在掩膜下方横向方向上采用长而窄的底切通道近似，将系统视为输运过程中的准稳态，通道入口处具有恒定的体相浓度 $C_b$，反应前沿处具有单一的底切长度 $u(t)$。通过将扩散通量与反应通量相等来在前沿施加守恒。通过结合特征长度上的菲克输运和一级反应边界，建立 $J$、$u$、$D$、$k_s$、$C_b$ 和 $n$ 之间的控制关系，并通过将 $v = \\frac{J}{n}$ 与各向同性推进耦合，推导出 $u(t)$ 的时间演化。\n\n掩膜选择性的建模如下。设开放液体中的掩膜腐蚀速率为基底腐蚀速率除以选择性 $S$，其中基底腐蚀速率使用无扩散限制的反应限制速率。若初始掩膜厚度为 $T_0$，则掩膜幸存时间为 $t_{\\text{mask}} = \\frac{T_0 \\, S}{R_{\\text{sub}}}$，其中 $R_{\\text{sub}}$ 是反应限制的基底腐蚀速率。工艺的实际持续时间为 $t_{\\text{actual}} = \\min(t_{\\text{end}}, t_{\\text{mask}})$。\n\n您的程序必须：\n- 仅使用上述基本原理，实现耦合输运-反应求解器来计算 $u_{\\text{num}}(t_{\\text{actual}})$，而不借助任何额外的经验性简化。\n- 计算解析的反应限制底切 $u_{\\text{analytical}}(t_{\\text{actual}}) = R \\, t_{\\text{actual}}$，其中 $R$ 等于从基本关系中获得的反应限制基底腐蚀速率。\n- 将由扩散限制引起的差异量化为绝对差异 $u_{\\text{num}} - u_{\\text{analytical}}$（以微米表示）和相对差异 $(u_{\\text{num}} - u_{\\text{analytical}})/u_{\\text{analytical}}$（以小数表示，不使用百分号）。\n\n所有距离以微米表示，时间以秒表示。如果在计算中出现任何角度，均以弧度处理；但此问题不需要明确的角度输入。\n\n测试套件：\n为以下参数集提供结果。每个测试用例是一个元组 $\\left(C_b, D, k_s, n, t_{\\text{end}}, T_0, S\\right)$，单位为 $\\left(\\text{mol}/\\text{m}^3, \\text{m}^2/\\text{s}, \\text{m}/\\text{s}, \\text{mol}/\\text{m}^3, \\text{s}, \\mu\\text{m}, \\text{无量纲}\\right)$。\n\n1. $(500, 1.0\\times 10^{-9}, 1.0\\times 10^{-5}, 1.0\\times 10^{5}, 1000, 1000, 100)$，一个扩散和反应速率适中的平衡情况。\n2. $(500, 1.0\\times 10^{-9}, 1.0\\times 10^{-6}, 1.0\\times 10^{5}, 1000, 1000, 100)$，一个反应限制的情况。\n3. $(500, 1.0\\times 10^{-11}, 1.0\\times 10^{-5}, 1.0\\times 10^{5}, 1000, 1000, 100)$，一个扩散限制的情况。\n4. $(500, 1.0\\times 10^{-9}, 1.0\\times 10^{-5}, 1.0\\times 10^{5}, 1000, 1, 2)$，一个掩膜限制的情况，其中掩膜在标称结束时间前被消耗完。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表，每个测试用例一个列表，每个内部列表的形式为 $[u_{\\text{num}}, u_{\\text{analytical}}, \\Delta, \\delta]$，其中 $u_{\\text{num}}$ 和 $u_{\\text{analytical}}$ 以微米为单位，$\\Delta$ 是以微米为单位的绝对差异，$\\delta$ 是以小数表示的相对差异。例如：“[[u_num1,u_anal1,delta_um1,frac1],[u_num2,u_anal2,delta_um2,frac2],...]”。",
            "solution": "用户提供的问题陈述经过严格验证，被认为是科学上合理、适定且完整的。唯一解所需的所有参数和边界条件均已提供。该问题基于化学反应工程和传质现象的基本原理，特别是菲克扩散和一级反应动力学，这些是模拟半导体制造中湿法腐蚀工艺的标准方法。\n\n解决方案首先推导底切长度 $u(t)$ 作为时间函数的控制常微分方程（ODE）。然后我们求解这个ODE，找到 $u(t)$ 的精确解析表达式，它代表了耦合输运-反应求解器的核心。将此结果与简化的反应限制情况进行对比。\n\n**1. 模型建立与推导**\n\n该问题将底切建模为掩膜下一个长度为 $u(t)$ 的一维通道。蚀刻剂从通道入口（浓度为体相值 $C_b$）扩散到通道末端的腐蚀前沿。\n\n在扩散的准稳态近似下，对于从 $x=0$（入口）到 $x=u$（腐蚀前沿）的一维通道，菲克第一定律 $J = -D \\frac{dC}{dx}$ 意味着浓度分布是线性的。给定边界条件 $C(x=0) = C_b$ 和 $C(x=u) = C_{\\text{front}}$，浓度梯度是恒定的，由 $\\frac{dC}{dx} = \\frac{C_{\\text{front}} - C_b}{u}$ 给出。\n\n因此，蚀刻剂到前沿的扩散通量 $J_{\\text{diff}}$ 是：\n$$\nJ_{\\text{diff}} = -D \\left( \\frac{C_{\\text{front}} - C_b}{u} \\right) = D \\frac{C_b - C_{\\text{front}}}{u}\n$$\n\n在腐蚀前沿，该通量被一级表面反应所消耗。根据问题陈述，反应通量 $J_{\\text{react}}$ 为：\n$$\nJ_{\\text{react}} = k_s C_{\\text{front}}\n$$\n其中 $k_s$ 是表面动力学系数。\n\n根据腐蚀前沿的质量守恒，扩散通量必须等于反应通量，$J = J_{\\text{diff}} = J_{\\text{react}}$。\n$$\nD \\frac{C_b - C_{\\text{front}}}{u} = k_s C_{\\text{front}}\n$$\n\n我们求解这个方程以得到前沿浓度 $C_{\\text{front}}$，它依赖于动态底切长度 $u(t)$：\n$$\nD C_b - D C_{\\text{front}} = u k_s C_{\\text{front}} \\\\\nD C_b = (D + u k_s) C_{\\text{front}} \\\\\nC_{\\text{front}}(u) = \\frac{D C_b}{D + u k_s}\n$$\n\n腐蚀前沿以速度 $v = \\frac{du}{dt}$ 推进。该速度与摩尔通量通过化学计量关系 $v = \\frac{J}{n}$ 相关，其中 $n$ 是每单位体积移除的固体所需的摩尔量。代入通量表达式 $J = k_s C_{\\text{front}}$：\n$$\n\\frac{du}{dt} = \\frac{k_s C_{\\text{front}}}{n} = \\frac{k_s}{n} \\left( \\frac{D C_b}{D + u k_s} \\right)\n$$\n这是底切长度 $u(t)$ 的控制性一阶可分离常微分方程。\n\n**2. 求解底切长度 $u_{\\text{num}}(t)$ 的常微分方程**\n\n为了找到 $u(t)$，我们对该ODE进行积分，初始条件为 $u(0)=0$。\n$$\n(D + u k_s) du = \\left( \\frac{k_s D C_b}{n} \\right) dt\n$$\n从 $t=0$ 到 $t=t_{\\text{actual}}$ 积分，对应的底切从 $u=0$ 到 $u=u_{\\text{num}}$：\n$$\n\\int_{0}^{u_{\\text{num}}} (D + u k_s) \\,du = \\int_{0}^{t_{\\text{actual}}} \\frac{k_s D C_b}{n} \\,dt\n$$\n积分结果为：\n$$\n\\left[ Du + \\frac{1}{2} k_s u^2 \\right]_0^{u_{\\text{num}}} = \\left[ \\frac{k_s D C_b}{n} t \\right]_0^{t_{\\text{actual}}} \\\\\nD u_{\\text{num}} + \\frac{1}{2} k_s u_{\\text{num}}^2 = \\frac{k_s D C_b}{n} t_{\\text{actual}}\n$$\n这是一个关于 $u_{\\text{num}}$ 的二次方程：\n$$\n\\frac{1}{2} k_s u_{\\text{num}}^2 + D u_{\\text{num}} - \\left( \\frac{k_s D C_b}{n} t_{\\text{actual}} \\right) = 0\n$$\n使用二次公式求解 $u_{\\text{num}}$，并取有物理意义的正根（因为 $u_{\\text{num}} \\ge 0$）：\n$$\nu_{\\text{num}} = \\frac{-D + \\sqrt{D^2 - 4 \\left(\\frac{1}{2}k_s\\right) \\left(-\\frac{k_s D C_b}{n}t_{\\text{actual}}\\right)}}{2 \\left(\\frac{1}{2}k_s\\right)} = \\frac{-D + \\sqrt{D^2 + \\frac{2k_s^2 D C_b t_{\\text{actual}}}{n}}}{k_s}\n$$\n该方程为耦合扩散-反应模型在时间 $t_{\\text{actual}}$ 的底切长度 $u_{\\text{num}}$ 提供了精确解。\n\n**3. 解析的反应限制底切 $u_{\\text{analytical}}(t)$**\n\n纯粹的反应限制情况假设扩散无限快 ($D \\to \\infty$)，因此没有浓度耗尽。腐蚀前沿的浓度始终是体相浓度，$C_{\\text{front}} = C_b$。\n反应限制的基底腐蚀速率 $R_{\\text{sub}}$ 是在这些条件下的速度 $v$：\n$$\nR_{\\text{sub}} = v_{\\text{rxn-ltd}} = \\frac{J_{\\text{rxn-ltd}}}{n} = \\frac{k_s C_b}{n}\n$$\n问题将此速率定义为 $R$。解析底切是此恒定速率下的线性进展：\n$$\nu_{\\text{analytical}}(t_{\\text{actual}}) = R_{\\text{sub}} \\cdot t_{\\text{actual}} = \\left( \\frac{k_s C_b}{n} \\right) t_{\\text{actual}}\n$$\n\n**4. 工艺持续时间与掩膜选择性**\n\n掩膜在工艺过程中会被腐蚀。掩膜幸存时间 $t_{\\text{mask}}$ 是根据其初始厚度 $T_0$、选择性 $S$ 和基底腐蚀速率计算的。问题指定使用反应限制的基底速率 $R_{\\text{sub}}$ 进行此计算。\n$$\nt_{\\text{mask}} = \\frac{T_0 S}{R_{\\text{sub}}} = \\frac{T_0 S n}{k_s C_b}\n$$\n腐蚀工艺的实际持续时间 $t_{\\text{actual}}$ 是预定工艺时间 $t_{\\text{end}}$ 和掩膜完全腐蚀所需时间中的较小者：\n$$\nt_{\\text{actual}} = \\min(t_{\\text{end}}, t_{\\text{mask}})\n$$\n\n**5. 算法实现**\n\n每个测试用例的算法如下：\n1.  读取输入参数 $(C_b, D, k_s, n, t_{\\text{end}}, T_{0, \\mu m}, S)$。将所有单位转换为国际单位制基本单位（米，秒等）。具体来说，$T_0$ [m] $= T_{0, \\mu m} \\times 10^{-6}$。\n2.  计算反应限制的基底腐蚀速率：$R_{\\text{sub}} = (k_s C_b) / n$。\n3.  计算掩膜幸存时间：$t_{\\text{mask}} = (T_0 S) / R_{\\text{sub}}$。\n4.  确定实际工艺持续时间：$t_{\\text{actual}} = \\min(t_{\\text{end}}, t_{\\text{mask}})$。\n5.  计算解析底切：$u_{\\text{analytical}} = R_{\\text{sub}} \\cdot t_{\\text{actual}}$。\n6.  使用推导出的ODE解析解计算耦合模型的底切 $u_{\\text{num}}$。\n7.  将 $u_{\\text{num}}$ 和 $u_{\\text{analytical}}$ 从米转换为微米以供报告。\n8.  计算绝对差异 $\\Delta = u_{\\text{num}} - u_{\\text{analytical}}$（以微米为单位）。\n9.  计算相对差异 $\\delta = \\Delta / u_{\\text{analytical}}$。处理 $u_{\\text{analytical}}$ 可能为零的情况以避免除零错误，尽管在给定的测试用例中预计不会发生。\n10. 格式化并存储四个结果：$[u_{\\text{num}}, u_{\\text{analytical}}, \\Delta, \\delta]$。\n\n此过程在Python程序中为每个提供的测试用例实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the undercut in an isotropic etch process, comparing a coupled\n    diffusion-reaction model with a simplified reaction-limited model.\n    \"\"\"\n\n    # Test cases: (C_b, D, k_s, n, t_end, T0_um, S)\n    # Units: (mol/m^3, m^2/s, m/s, mol/m^3, s, µm, dimensionless)\n    test_cases = [\n        (500, 1.0e-9, 1.0e-5, 1.0e5, 1000, 1000, 100),\n        (500, 1.0e-9, 1.0e-6, 1.0e5, 1000, 1000, 100),\n        (500, 1.0e-11, 1.0e-5, 1.0e5, 1000, 1000, 100),\n        (500, 1.0e-9, 1.0e-5, 1.0e5, 1000, 1, 2),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Cb, D, ks, n, t_end, T0_um, S = case\n\n        # Convert all units to base SI (meters, seconds, mol) for internal calculations\n        T0 = T0_um * 1.0e-6  # Convert mask thickness from micrometers to meters\n\n        # --- Step 1: Calculate process duration ---\n\n        # Calculate the reaction-limited substrate etch rate (R_sub)\n        # This occurs when diffusion is not a limiting factor (C_front = Cb)\n        # R_sub = v = J/n = (ks * Cb) / n\n        # Handle potential division by zero if n or ks or Cb is zero, though not in test data.\n        if n == 0 or ks == 0 or Cb == 0:\n            R_sub = 0.0\n        else:\n            R_sub = (ks * Cb) / n  # Units: m/s\n\n        # Calculate the mask survival time\n        if R_sub == 0:\n             # If etch rate is zero, mask lasts indefinitely.\n            t_mask = float('inf')\n        else:\n            t_mask = (T0 * S) / R_sub # Units: s\n        \n        # Determine the actual process time, t_actual\n        t_actual = np.min([t_end, t_mask])\n\n        # --- Step 2: Calculate analytical (reaction-limited) undercut ---\n        \n        # u_analytical = R_sub * t_actual\n        u_analytical_m = R_sub * t_actual  # Result in meters\n\n        # --- Step 3: Calculate numerical (coupled transport-reaction) undercut ---\n\n        # The model leads to a quadratic equation for u_num:\n        # 0.5*ks*u_num^2 + D*u_num - (ks*D*Cb/n)*t_actual = 0\n        # We solve this using the quadratic formula for u_num.\n        \n        # Note: (ks*D*Cb/n) = D * (ks*Cb/n) = D * R_sub\n        c_term = D * R_sub * t_actual\n\n        if ks == 0:\n            # If ks is 0, the etch rate is 0, so undercut is 0.\n            # Equation becomes D*u_num = 0 - u_num = 0\n            u_num_m = 0.0\n        else:\n            # Standard quadratic formula: (-b +/- sqrt(b^2 - 4ac)) / 2a\n            # a = 0.5 * ks, b = D, c = -c_term\n            discriminant = D**2 + 4 * (0.5 * ks) * c_term\n            \n            # Since u_num must be positive, we take the '+' root.\n            u_num_m = (-D + np.sqrt(discriminant)) / ks\n\n        # --- Step 4: Convert to output units and compute discrepancies ---\n        \n        # Conversion factor from meters to micrometers\n        m_to_um = 1.0e6\n        \n        u_num_um = u_num_m * m_to_um\n        u_analytical_um = u_analytical_m * m_to_um\n        \n        # Absolute difference in micrometers\n        delta_um = u_num_um - u_analytical_um\n        \n        # Fractional discrepancy\n        if u_analytical_um == 0:\n             # If analytical undercut is 0, fractional difference is undefined or 0 if num is also 0.\n             # In our cases, if analytical is 0, num is also 0.\n            delta_frac = 0.0\n        else:\n            delta_frac = delta_um / u_analytical_um\n            \n        results.append([u_num_um, u_analytical_um, delta_um, delta_frac])\n\n    # Format the final output string as specified\n    # The default string representation of a list includes spaces, which is fine.\n    # Ex: '[[val1, val2,...], [val1, val2,...]]'\n    formatted_results = [\n        f\"[{res[0]:.6f}, {res[1]:.6f}, {res[2]:.6f}, {res[3]:.6f}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论模型只有当其参数能够通过实际测量数据确定时才具有实用价值。这项练习要求您建立一个简化的、但在物理上一致的沟槽增宽模型，并使用非线性最小二乘法（NLLS）将模型的参数（刻蚀速率、掩模侵蚀速率）与合成的实验数据进行拟合。这个综合性练习模拟了工艺工程师的完整工作流程：推导模型、生成或收集数据，并使用数值方法校准模型，同时还引入了通过置信区间来量化拟合参数不确定性的关键概念。",
            "id": "4136876",
            "problem": "一位制造工程师正在对由刚性不透明硬掩模保护的平面衬底的各向同性湿法刻蚀进行建模。工程师在刻蚀过程中收集了底部关键尺寸（CD）的时间序列测量数据，此处CD定义为掩模底面下方衬底表面的沟槽宽度。其目的是在物理一致的假设下，根据这些数据校准衬底的各向同性刻蚀速率和掩模的侵蚀速率。\n\n使用的基本原理：\n\n- 各向同性刻蚀以恒定的法向速度推进材料界面。设衬底刻蚀速率为 $R$ (单位 $\\mathrm{m/s}$)，意味着经过时间 $t$ 后，刻蚀前沿是距其初始位置偏移距离为 $R t$ 的边界。\n- 由于暴露和溅射/化学侵蚀，掩模厚度以恒定的垂直速率 $R_\\mathrm{mask}$ (单位 $\\mathrm{m/s}$) 随时间均匀减小。设初始掩模厚度为 $h_0$ (单位 $\\mathrm{m}$)，因此瞬时厚度为 $h(t) = h_0 - R_\\mathrm{mask} t$ (当 $h(t) \\ge 0$ 时)，此后 $h(t) = 0$。\n- 衬底表面的初始掩模开口宽度为 $W_0$ (单位 $\\mathrm{m}$)。\n- 掩模下方的侧向底切源于从暴露边缘开始的各向同性刻蚀前沿的推进。在二维横截面中，从掩模边缘开始刻蚀的点在时间 $t$ 后的轨迹由一个以该边缘为中心、半径为 $R t$ 的圆描述。掩模底面上与边缘垂直分离距离为 $h(t)$ 的一个点，如果其到边缘的欧几里得距离小于或等于 $R t$，则该点被刻蚀。\n\n任务：\n\n1. 仅使用上述基本原理，推导出一个物理上一致的解析表达式，用于表示掩模底面的侧向底切距离 $U(t)$ 作为 $R$、$R_\\mathrm{mask}$、$h_0$ 和 $t$ 的函数，然后根据 $W_0$ 和 $U(t)$ 推导出衬底表面的底部CD $W(t)$。您必须明确考虑有限的掩模厚度以及掩模厚度不能为负的事实。使用LaTeX表示法表达所有数学关系。\n\n2. 提出并实施一个校准程序，该程序在给定时间序列观测值 $\\{(t_i, W_\\mathrm{obs}(t_i))\\}_{i=1}^N$ 的情况下，通过最小化推导出的模型 $W(t; R, R_\\mathrm{mask})$ 与观测值 $W_\\mathrm{obs}(t_i)$ 之间的残差平方和来拟合 $R$ 和 $R_\\mathrm{mask}$。您的算法必须使用非线性最小二乘法，并强制执行非负性约束 $R \\ge 0$ 和 $R_\\mathrm{mask} \\ge 0$。\n\n3. 使用非线性最小二乘解的一阶线性化，推导拟合参数 $R$ 和 $R_\\mathrm{mask}$ 的近似 $95\\%$ 置信区间。具体来说，根据在最优点评估的残差雅可比矩阵和残差方差估计推导出参数协方差矩阵，然后计算双边区间。将区间以 $\\mathrm{m/s}$ 为单位表示为小数（不带百分号）。\n\n4. 将您的程序实现为一个完整的、可运行的程序，使用由推导模型和附加的零均值高斯测量噪声生成的合成数据来执行以下测试套件。使用固定的随机种子 $42$ 来生成噪声。所有长度单位必须是米 ($\\mathrm{m}$)，时间单位是秒 ($\\mathrm{s}$)，速率单位是米/秒 ($\\mathrm{m/s}$)。\n\n测试套件：\n\n- 测试用例A（一般情况）：\n  - $W_0 = 200 \\times 10^{-9}\\ \\mathrm{m}$，$h_0 = 150 \\times 10^{-9}\\ \\mathrm{m}$，\n  - 真实速率：$R^\\star = 2.0 \\times 10^{-9}\\ \\mathrm{m/s}$，$R_\\mathrm{mask}^\\star = 5.0 \\times 10^{-10}\\ \\mathrm{m/s}$，\n  - 采样时间：$t = [0, 25, 50, 100, 150, 200, 300]\\ \\mathrm{s}$，\n  - 测量噪声标准差：$\\sigma = 3.0 \\times 10^{-9}\\ \\mathrm{m}$。\n\n- 测试用例B（具有延迟底切开始的边界情况，即对于某些样本，初始 $R t \\le h_0 - R_\\mathrm{mask} t$）：\n  - $W_0 = 150 \\times 10^{-9}\\ \\mathrm{m}$，$h_0 = 300 \\times 10^{-9}\\ \\mathrm{m}$，\n  - 真实速率：$R^\\star = 1.5 \\times 10^{-9}\\ \\mathrm{m/s}$，$R_\\mathrm{mask}^\\star = 2.5 \\times 10^{-9}\\ \\mathrm{m/s}$，\n  - 采样时间：$t = [0, 30, 60, 90, 120]\\ \\mathrm{s}$，\n  - 测量噪声标准差：$\\sigma = 2.0 \\times 10^{-9}\\ \\mathrm{m}$。\n\n- 测试用例C（实验过程中掩模被完全消耗的边缘情况）：\n  - $W_0 = 100 \\times 10^{-9}\\ \\mathrm{m}$，$h_0 = 50 \\times 10^{-9}\\ \\mathrm{m}$，\n  - 真实速率：$R^\\star = 3.0 \\times 10^{-9}\\ \\mathrm{m/s}$，$R_\\mathrm{mask}^\\star = 1.0 \\times 10^{-9}\\ \\mathrm{m/s}$，\n  - 采样时间：$t = [0, 20, 40, 60, 80, 100]\\ \\mathrm{s}$，\n  - 测量噪声标准差：$\\sigma = 4.0 \\times 10^{-9}\\ \\mathrm{m}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，报告一个包含六个浮点数的列表，顺序如下：\n  - $R$ 估计值，单位 $\\mathrm{m/s}$，\n  - $R_\\mathrm{mask}$ 估计值，单位 $\\mathrm{m/s}$，\n  - $R$ 的 $95\\%$ 置信区间下界，单位 $\\mathrm{m/s}$，\n  - $R$ 的 $95\\%$ 置信区间上界，单位 $\\mathrm{m/s}$，\n  - $R_\\mathrm{mask}$ 的 $95\\%$ 置信区间下界，单位 $\\mathrm{m/s}$，\n  - $R_\\mathrm{mask}$ 的 $95\\%$ 置信区间上界，单位 $\\mathrm{m/s}$。\n\n因此，程序必须打印出类似这样的一行\n$[ [r_1, r_2, r_3, r_4, r_5, r_6], [\\dots], [\\dots] ]$\n其中每个方括号组对应三个测试用例中的一个。",
            "solution": "根据沟槽宽度的时间序列测量来校准各向同性刻蚀和掩模侵蚀速率的问题，在半导体工艺建模中是一个有效且适定的问题。所提供的物理基础，虽然是对复杂的现实世界现象的简化，但其本身是自洽的，并且足以推导出一个形式化的解析模型。这些任务涉及模型推导、用于参数拟合的数值优化以及用于不确定性量化的 statistical analysis，所有这些都是科学和工程实践中的标准程序。\n\n### 第1部分：宽度 $W(t)$ 的刻蚀模型推导\n\n问题陈述描述了一个由掩模开口角落处开始的各向同性刻蚀引起的侧向底切的物理模型。我们建立一个二维坐标系，其中衬底表面为x轴（$y=0$），掩模位于其上方（$y0$）。初始宽度为 $W_0$ 的掩模开口的一个边缘位于 $x=W_0/2$。各向同性刻蚀从角落 $(W_0/2, 0)$ 开始并向外径向传播。在时间 $t$，刻蚀前沿是一个以 $(W_0/2, 0)$ 为中心、半径为 $R t$ 的圆，其中 $R$ 是衬底刻蚀速率。\n\n模型的核心在于确定侧向底切距离 $U(t)$。问题陈述中说：“掩模底面上与边缘垂直分离距离为 $h(t)$ 的一个点，如果其到边缘的欧几里得距离小于或等于 $R t$，则该点被刻蚀。”这被解释为一种几何关系。衬底层面的侧向底切 $U(t)$、瞬时掩模厚度 $h(t)$ 以及刻蚀距离 $R t$ 形成一个直角三角形。斜边是刻蚀前沿传播的总距离 $R t$。两条直角边是刻蚀剂必须克服的垂直距离 $h(t)$ 和在衬底表面产生的侧向底切 $U(t)$。\n\n这种几何关系可以通过勾股定理表示：\n$$U(t)^2 + h(t)^2 = (Rt)^2$$\n\n瞬时掩模厚度 $h(t)$ 从其初始值 $h_0$ 以恒定速率 $R_\\mathrm{mask}$ 减小。它不能为负，所以我们定义为：\n$$h(t) = \\max(0, h_0 - R_\\mathrm{mask} t)$$\n设 $t_\\mathrm{clear} = h_0 / R_\\mathrm{mask}$ 为掩模被完全消耗的时间（对于 $R_\\mathrm{mask}  0$）。\n\n求解侧向底切 $U(t)$ 得：\n$$U(t) = \\sqrt{(Rt)^2 - h(t)^2}$$\n为了让底切成为一个真实的物理距离，平方根下的项必须为非负。这意味着在 $(Rt)^2 \\ge h(t)^2$ 之前不会发生底切。在此时间之前，$U(t)=0$。我们可以将这些条件组合成一个单一的表达式：\n$$U(t) = \\sqrt{\\max\\left(0, (Rt)^2 - \\left[\\max(0, h_0 - R_\\mathrm{mask}t)\\right]^2\\right)}$$\n\n总的底部关键尺寸（CD）$W(t)$ 是初始宽度 $W_0$ 加上沟槽两侧的底切，假设对称。\n$$W(t) = W_0 + 2U(t)$$\n代入 $U(t)$ 的表达式：\n$$W(t; R, R_\\mathrm{mask}) = W_0 + 2 \\sqrt{\\max\\left(0, (Rt)^2 - \\left[\\max(0, h_0 - R_\\mathrm{mask}t)\\right]^2\\right)}$$\n这个方程为沟槽宽度作为时间以及未知参数 $R$ 和 $R_\\mathrm{mask}$ 的函数，提供了一个完整的、物理上一致的解析模型。\n\n### 第2部分：通过非线性最小二乘法进行参数校准\n\n给定一组 $N$ 个观测值 $\\{(t_i, W_\\mathrm{obs}(t_i))\\}_{i=1}^N$，目标是找到参数 $\\mathbf{p} = [R, R_\\mathrm{mask}]^T$ 的最优值，使模型与数据最佳拟合。这通过最小化残差平方和（SSR）来实现，定义为：\n$$S(\\mathbf{p}) = \\sum_{i=1}^N \\left( W_\\mathrm{obs}(t_i) - W(t_i; \\mathbf{p}) \\right)^2$$\n由于模型 $W(t; \\mathbf{p})$ 是参数 $R$ 和 $R_\\mathrm{mask}$ 的非线性函数，这种最小化构成了一个非线性最小二乘（NLLS）问题。\n\n解是通过迭代优化算法找到的，例如Levenberg-Marquardt算法，该算法在 `scipy.optimize.least_squares` 中实现。该函数通过寻找残差向量 $\\mathbf{r}(\\mathbf{p})$ 的零点来最小化SSR，其中每个元素为 $r_i(\\mathbf{p}) = W_\\mathrm{obs}(t_i) - W(t_i; \\mathbf{p})$。\n\n此外，问题要求对参数强制执行物理非负性约束：$R \\ge 0$ 和 $R_\\mathrm{mask} \\ge 0$。这些约束作为参数搜索空间的界限被纳入优化中。\n\n### 第3部分：置信区间的推导\n\n为了评估估计参数 $\\hat{\\mathbf{p}} = [\\hat{R}, \\hat{R}_\\mathrm{mask}]^T$ 的不确定性，我们计算它们的近似 $95\\%$ 置信区间。这基于模型在最优解 $\\hat{\\mathbf{p}}$ 附近的一阶泰勒展开（线性化）。在此框架下，参数协方差矩阵 $\\mathrm{Cov}(\\hat{\\mathbf{p}})$ 可近似为：\n$$\\mathrm{Cov}(\\hat{\\mathbf{p}}) \\approx \\hat{\\sigma}^2 (J^T J)^{-1}$$\n其中：\n- $J$ 是残差关于参数的雅可比矩阵，在解 $\\hat{\\mathbf{p}}$ 处进行评估。其元素为 $J_{ij} = \\frac{\\partial r_i}{\\partial p_j}|_{\\hat{\\mathbf{p}}} = -\\frac{\\partial W(t_i; \\mathbf{p})}{\\partial p_j}|_{\\hat{\\mathbf{p}}}$。\n- $\\hat{\\sigma}^2$ 是测量误差的估计方差，由最小值处的残差平方和计算得出：\n$$\\hat{\\sigma}^2 = \\frac{S(\\hat{\\mathbf{p}})}{N-k}$$\n其中 $N$ 是数据点的数量，$k$ 是拟合参数的数量（此处 $k=2$）。$N-k$ 项代表自由度。\n\n协方差矩阵的对角元素 $\\mathrm{Cov}_{jj}$ 提供了参数估计的方差 $\\mathrm{var}(\\hat{p}_j)$。每个参数的标准误差是其方差的平方根：$se(\\hat{p}_j) = \\sqrt{\\mathrm{var}(\\hat{p}_j)}$。\n\n参数 $\\hat{p}_j$ 的近似双边 $(1-\\alpha) \\times 100\\%$ 置信区间随后构造为：\n$$\\hat{p}_j \\pm t_{1-\\alpha/2, N-k} \\cdot se(\\hat{p}_j)$$\n对于 $95\\%$ 置信区间，$\\alpha = 0.05$。值 $t_{1-\\alpha/2, N-k}$ 是来自具有 $N-k$ 个自由度的学生t分布的临界值。这种分布适用于小样本量，正如在测试用例中遇到的情况。\n\n### 第4部分：实施策略\n\n该实施将推导出的模型和统计程序封装到一个Python程序中。\n1.  **模型函数**：定义一个函数 `W_model`，使用 `numpy` 进行向量化计算，为给定的 `t` 值和参数集计算 $W(t)$。注意正确处理 `max` 操作以确保计算的稳健性。\n2.  **数据生成**：对于每个测试用例，通过使用真实参数（$R^\\star, R_\\mathrm{mask}^\\star$）评估 `W_model` 并添加具有指定标准差 $\\sigma$ 的高斯噪声来生成合成的 `W_obs` 数据，使用固定的随机种子以保证可复现性。\n3.  **优化**：使用 `scipy.optimize.least_squares` 函数。\n    - 定义一个残差函数，它接受一个参数向量并返回观测宽度与模型宽度之间的差异。\n    - 使用 `bounds` 参数强制执行非负性。\n    - 雅可比矩阵 $J$ 由 `scipy` 进行数值计算，这能稳健地处理模型中的不可微点。\n4.  **置信区间计算**：\n    - 优化后，使用返回的雅可比矩阵 `J` 和最优参数。\n    - 计算残差方差 $\\hat{\\sigma}^2$。\n    - 计算协方差矩阵为 $\\hat{\\sigma}^2 (J^T J)^{-1}$。\n    - 从协方差矩阵的对角线中提取标准误差。\n    - 使用 `scipy.stats.t.ppf` 为适当的自由度获取t临界值。\n    - 最后，计算并存储 $R$ 和 $R_\\mathrm{mask}$ 的 $95\\%$ 置信区间的下界和上界。\n\n最终输出将所有测试用例的结果汇总到指定的列表的列表格式中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Solves the etch rate calibration problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Test Case A\",\n            \"W0\": 200e-9, \"h0\": 150e-9,\n            \"R_star\": 2.0e-9, \"R_mask_star\": 0.5e-9,\n            \"times\": np.array([0, 25, 50, 100, 150, 200, 300]),\n            \"sigma\": 3.0e-9\n        },\n        {\n            \"name\": \"Test Case B\",\n            \"W0\": 150e-9, \"h0\": 300e-9,\n            \"R_star\": 1.5e-9, \"R_mask_star\": 2.5e-9,\n            \"times\": np.array([0, 30, 60, 90, 120]),\n            \"sigma\": 2.0e-9\n        },\n        {\n            \"name\": \"Test Case C\",\n            \"W0\": 100e-9, \"h0\": 50e-9,\n            \"R_star\": 3.0e-9, \"R_mask_star\": 1.0e-9,\n            \"times\": np.array([0, 20, 40, 60, 80, 100]),\n            \"sigma\": 4.0e-9\n        }\n    ]\n\n    all_results = []\n    \n    # Use a fixed random seed for reproducibility of synthetic data\n    np.random.seed(42)\n\n    def W_model(t, R, R_mask, W0, h0):\n        \"\"\"\n        Computes the trench width W(t) based on the derived analytical model.\n\n        Args:\n            t (np.ndarray): Array of time points.\n            R (float): Substrate isotropic etch rate.\n            R_mask (float): Mask erosion rate.\n            W0 (float): Initial mask opening width.\n            h0 (float): Initial mask thickness.\n\n        Returns:\n            np.ndarray: The computed trench width at each time point.\n        \"\"\"\n        # Ensure rates are non-negative for physical consistency\n        R = max(0, R)\n        R_mask = max(0, R_mask)\n        \n        # Instantaneous mask thickness h(t)\n        h_t = np.maximum(0, h0 - R_mask * t)\n        \n        # Squared etch distance (Rt)^2\n        Rt_sq = (R * t)**2\n        \n        # Undercut calculation U(t)\n        # U(t)^2 = (Rt)^2 - h(t)^2\n        # Use np.maximum to ensure the argument of sqrt is non-negative\n        U_sq_term = Rt_sq - h_t**2\n        U_t = np.sqrt(np.maximum(0, U_sq_term))\n        \n        # Total bottom CD W(t) = W0 + 2*U(t)\n        W_t = W0 + 2 * U_t\n        return W_t\n\n    for case in test_cases:\n        # Unpack case parameters\n        W0, h0 = case[\"W0\"], case[\"h0\"]\n        R_star, R_mask_star = case[\"R_star\"], case[\"R_mask_star\"]\n        times, sigma = case[\"times\"], case[\"sigma\"]\n\n        # 1. Generate synthetic data\n        W_true = W_model(times, R_star, R_mask_star, W0, h0)\n        noise = np.random.normal(0, sigma, len(times))\n        W_obs = W_true + noise\n\n        # 2. Perform nonlinear least squares fitting\n        def residuals(p, t, W_obs, W0, h0):\n            \"\"\"Residuals function for least_squares.\"\"\"\n            R, R_mask = p\n            return W_obs - W_model(t, R, R_mask, W0, h0)\n\n        # Initial guess for the parameters\n        p0 = [1e-9, 1e-10]\n        \n        # Non-negativity constraints\n        bounds = ([0, 0], [np.inf, np.inf])\n\n        # Perform the optimization\n        result = least_squares(\n            residuals,\n            p0,\n            jac='2-point', # Use numerical jacobian\n            bounds=bounds,\n            args=(times, W_obs, W0, h0)\n        )\n\n        # Estimated parameters\n        R_fit, R_mask_fit = result.x\n\n        # 3. Calculate 95% confidence intervals\n        p_opt = result.x\n        res_opt = result.fun # residuals at optimum\n        J = result.jac # Jacobian at optimum\n        \n        N = len(times) # Number of data points\n        k = len(p_opt) # Number of parameters\n        dof = N - k    # Degrees of freedom\n\n        # Estimate of the error variance\n        s_sq = np.sum(res_opt**2) / dof\n        \n        # Parameter covariance matrix, handling potential singularity\n        try:\n            cov_matrix = s_sq * np.linalg.inv(J.T @ J)\n            # Standard errors\n            se = np.sqrt(np.diag(cov_matrix))\n            se_R, se_R_mask = se\n            \n            # t-critical value for 95% confidence\n            alpha = 0.05\n            t_crit = t.ppf(1 - alpha / 2, df=dof)\n\n            # Confidence intervals\n            R_ci_lower = R_fit - t_crit * se_R\n            R_ci_upper = R_fit + t_crit * se_R\n            R_mask_ci_lower = R_mask_fit - t_crit * se_R_mask\n            R_mask_ci_upper = R_mask_fit + t_crit * se_R_mask\n            \n        except np.linalg.LinAlgError:\n            # If matrix is singular, cannot compute CIs\n            R_ci_lower, R_ci_upper = np.nan, np.nan\n            R_mask_ci_lower, R_mask_ci_upper = np.nan, np.nan\n\n        # Collect results for this case\n        case_results = [\n            R_fit, R_mask_fit,\n            R_ci_lower, R_ci_upper,\n            R_mask_ci_lower, R_mask_ci_upper\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format requested is a string representation of a list of lists.\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        formatted_res = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        output_str += formatted_res\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}