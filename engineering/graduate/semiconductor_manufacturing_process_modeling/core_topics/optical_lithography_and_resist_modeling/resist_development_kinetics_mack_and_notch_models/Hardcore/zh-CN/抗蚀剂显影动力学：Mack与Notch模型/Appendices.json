{
    "hands_on_practices": [
        {
            "introduction": "光刻胶最终形貌的形成是一系列复杂步骤的结果，其中曝光后烘烤（PEB）是决定性的环节。本练习  将指导你从基本的质量作用动力学定律出发，推导在催化性去保护反应和淬灭剂中和反应共同作用下，光刻胶保护基团比例的演变过程。掌握这一推导过程，将为你深刻理解 PEB 条件如何转化为决定显影过程的潜像（latent image）打下坚实的理论基础。",
            "id": "4161137",
            "problem": "一种化学增幅型光刻胶在厚度坐标为 $z$（$0 \\le z \\le L$）的薄膜中进行曝光后烘烤（PEB）。设 $[H^{+}](z,t)$ 表示局部质子（酸）浓度，$P(z,t)$ 表示局部受保护聚合物的比例。假设在PEB期间酸扩散可忽略不计，因此 $[H^{+}](z,t)$ 在每个位置 $z$ 处独立演化。在PEB期间，淬灭剂浓度 $Q$ 是均匀的且不随时间变化。酸根据一级质量作用速率定律 $d[H^{+}]/dt = -k_{q} Q [H^{+}]$ 被淬灭剂中和，其中 $k_{q}$ 是中和速率常数。去保护反应遵循 Mack 模型，其中受保护比例遵循 $dP/dt = -k_{D} [H^{+}] P$，$k_{D}$ 是去保护速率常数，并且酸起催化作用（去保护反应中的酸消耗被忽略）。在PEB开始时（$t = 0$）的初始条件为 $[H^{+}](z,0) = H_{0}(z)$ 和 $P(z,0) = P_{0}(z)$，其中 $0 \\le P_{0}(z) \\le 1$。\n\n从这些质量作用速率定律和给定的假设出发，推导经过烘烤时间 $t_{f}$ 后受保护比例 $P(z,t_{f})$ 的闭式解析表达式。最终答案需用 $H_{0}(z)$、$P_{0}(z)$、$k_{q}$、$Q$、$k_{D}$ 和 $t_{f}$ 来表示。答案应为一个单一的解析表达式。无需进行数值计算或四舍五入。受保护比例 $P$ 是无量纲的，因此最终表达式中不需要单位。你可以假设 $k_{q} > 0$，$k_{D} > 0$，$Q > 0$ 且 $t_{f} \\ge 0$。清晰地陈述获得最终表达式所使用的任何中间步骤，但除了给定的质量作用动力学和可忽略扩散的假设外，不要引用任何经验性简化公式。",
            "solution": "问题要求在酸扩散可忽略、淬灭剂浓度 $Q$ 均匀以及酸中和与去保护反应（Mack 模型）均遵循质量作用动力学的条件下，求出烘烤时间 $t_{f}$ 后的受保护比例 $P(z,t_{f})$。基本依据包括以下经过充分验证的动力学定律：\n\n- 淬灭剂对酸的中和作用：\n$$\\frac{d[H^{+}](z,t)}{dt} = -k_{q} Q [H^{+}](z,t),$$\n其中 $k_{q} > 0$ 且 $Q > 0$。\n- Mack 去保护动力学：\n$$\\frac{dP(z,t)}{dt} = -k_{D} [H^{+}](z,t) P(z,t),$$\n其中 $k_{D} > 0$。\n\n此外，我们在 $t = 0$ 时有初始条件：\n$$[H^{+}](z,0) = H_{0}(z), \\quad P(z,0) = P_{0}(z)。$$\n\n由于酸扩散可忽略不计，每个位置 $z$ 处的演化是独立的，我们可以将 $z$ 视为一个参数。我们首先使用一阶线性常微分方程求解酸浓度 $[H^{+}](z,t)$：\n$$\\frac{d[H^{+}](z,t)}{dt} = -k_{q} Q [H^{+}](z,t)。$$\n该方程有标准的指数衰减解。分离变量并积分，\n$$\\frac{d[H^{+}](z,t)}{[H^{+}](z,t)} = -k_{q} Q \\, dt,$$\n将 $t$ 从 $0$ 积分到 $t$，并将 $[H^{+}]$ 从 $[H^{+}](z,0) = H_{0}(z)$ 积分到 $[H^{+}](z,t)$：\n$$\\int_{H_{0}(z)}^{[H^{+}](z,t)} \\frac{d\\xi}{\\xi} = -k_{q} Q \\int_{0}^{t} dt',$$\n得到\n$$\\ln\\!\\left(\\frac{[H^{+}](z,t)}{H_{0}(z)}\\right) = -k_{q} Q t。$$\n对两边取指数可得\n$$[H^{+}](z,t) = H_{0}(z) \\exp(-k_{q} Q t)。$$\n\n接下来，我们将这个随时间变化的酸浓度代入 Mack 去保护速率定律中：\n$$\\frac{dP(z,t)}{dt} = -k_{D} [H^{+}](z,t) P(z,t) = -k_{D} H_{0}(z) \\exp(-k_{q} Q t) \\, P(z,t)。$$\n这是一个关于 $P(z,t)$ 的可分离一阶微分方程。分离变量：\n$$\\frac{dP(z,t)}{P(z,t)} = -k_{D} H_{0}(z) \\exp(-k_{q} Q t) \\, dt。$$\n将 $t$ 从 $0$ 积分到 $t = t_{f}$，并将 $P$ 从 $P(z,0) = P_{0}(z)$ 积分到 $P(z,t_{f})$：\n$$\\int_{P_{0}(z)}^{P(z,t_{f})} \\frac{d\\eta}{\\eta} = -k_{D} H_{0}(z) \\int_{0}^{t_{f}} \\exp(-k_{q} Q t) \\, dt。$$\n左边积分得到\n$$\\ln\\!\\left(\\frac{P(z,t_{f})}{P_{0}(z)}\\right)。$$\n对于右边，计算该积分：\n$$\\int_{0}^{t_{f}} \\exp(-k_{q} Q t) \\, dt = \\left[ -\\frac{1}{k_{q} Q} \\exp(-k_{q} Q t) \\right]_{0}^{t_{f}} = \\frac{1}{k_{q} Q} \\left(1 - \\exp(-k_{q} Q t_{f})\\right)。$$\n因此，\n$$\\ln\\!\\left(\\frac{P(z,t_{f})}{P_{0}(z)}\\right) = -k_{D} H_{0}(z) \\cdot \\frac{1}{k_{q} Q} \\left(1 - \\exp(-k_{q} Q t_{f})\\right)。$$\n对两边取指数，得到闭式表达式：\n$$P(z,t_{f}) = P_{0}(z) \\exp\\!\\left( - \\frac{k_{D} H_{0}(z)}{k_{q} Q} \\left(1 - \\exp(-k_{q} Q t_{f})\\right) \\right)。$$\n\n按要求，该表达式是无量纲的，因为 $P$ 是一个比例。它仅取决于给定的初始分布和参数，并且是直接从所述的质量作用动力学和可忽略扩散的假设推导出来的。没有使用任何经验性简化方法；该推导过程使用了变量分离法和对控制速率定律的直接积分。",
            "answer": "$$\\boxed{P_{0}(z)\\,\\exp\\!\\left(-\\frac{k_{D}\\,H_{0}(z)}{k_{q}\\,Q}\\left(1-\\exp(-k_{q}\\,Q\\,t_{f})\\right)\\right)}$$"
        },
        {
            "introduction": "在曝光后烘烤步骤之后，显影过程通过物理去除光刻胶来形成最终的图形。本练习  聚焦于一个关键的非理想效应——表面抑制，这是“Notch”模型中的核心概念。通过计算穿透此抑制层所需的时间，你将对表面效应如何显著改变显影初始阶段并影响整个工艺动态获得定量的理解。",
            "id": "4161160",
            "problem": "一层厚度为 $H$ 的化学增幅光刻胶薄膜在碱性水溶液中进行显影。在 Mack 溶解框架下，局部溶解速率 $R(P)$ 取决于此处考虑的显影初始阶段中空间均匀且不随时间变化的保护分数 $P$。在存在与凹口模型（notch model）一致的表面抑制时，假设厚度为 $\\delta$ 的顶层以一个降低的速率 $R_{\\mathrm{top}} = (1-\\beta) R(P)$ 溶解，其中 $0  \\beta  1$ 量化了抑制强度。假设一维平面溶解、显影液活性恒定，并且顶层下方的输运限制可忽略不计，因此移动边界速度等于局部溶解速率。\n\n从移动边界的运动学描述出发，其中界面后退速度等于局部溶解速率，推导表面突破时间 $t_{\\mathrm{break}}$，该时间定义为完全移除厚度为 $\\delta$ 的受抑制顶层所需的时间。然后考虑体清除时间 $t_{\\mathrm{bulk}}$，该时间定义为在没有表面抑制的情况下，厚度为 $H$ 的薄膜以速率 $R(P)$ 清除所需的时间。将您的比较结果以比率 $\\rho = t_{\\mathrm{break}}/t_{\\mathrm{bulk}}$ 的形式报告。\n\n请以 $H$、$\\delta$ 和 $\\beta$ 的单个闭合形式解析表达式提供最终答案。无需进行数值计算。最终答案中不应包含单位。",
            "solution": "该问题要求推导比率 $\\rho = t_{\\mathrm{break}}/t_{\\mathrm{bulk}}$，其中 $t_{\\mathrm{break}}$ 是移除表面受抑制层的时间，而 $t_{\\mathrm{bulk}}$ 是在没有抑制的情况下清除整个薄膜的假设时间。该解法基于移动边界的运动学模型，其中界面速度等于局部材料去除速率。\n\n设 $z$ 为表示光刻胶薄膜深度的坐标，其中 $z=0$ 对应于薄膜的初始顶表面。溶解界面在时间 $t$ 的位置用 $z(t)$ 表示。问题陈述移动边界速度 $\\frac{dz}{dt}$ 等于局部溶解速率。\n\n溶解过程由两种不同的速率描述：\n1.  对于厚度为 $\\delta$ 的顶层，对应于深度区间 $0 \\leq z \\leq \\delta$，由于表面抑制，溶解速率降低。该速率为 $R_{\\mathrm{top}} = (1-\\beta) R(P)$，其中 $R(P)$ 是体溶解速率，$\\beta$ 是抑制强度参数，且 $0  \\beta  1$。\n2.  对于薄膜的主体部分，在深度 $z  \\delta$ 处，溶解以未受抑制的体速率 $R(P)$ 进行。\n\n首先，我们计算表面突破时间 $t_{\\mathrm{break}}$。这被定义为完全移除受抑制顶层所需的时间。换句话说，它是溶解界面从 $z=0$ 移动到 $z=\\delta$ 所需的时间。\n\n在此阶段，界面位于顶层内，因此其速度是恒定的，等于 $R_{\\mathrm{top}}$：\n$$\n\\frac{dz}{dt} = R_{\\mathrm{top}} = (1-\\beta) R(P) \\quad \\text{for } 0 \\le z(t) \\le \\delta\n$$\n为了求出时间 $t_{\\mathrm{break}}$，我们可以分离变量并积分。我们将位置从 $z=0$ 积分到 $z=\\delta$，时间从 $t=0$ 积分到 $t=t_{\\mathrm{break}}$：\n$$\n\\int_{0}^{\\delta} dz = \\int_{0}^{t_{\\mathrm{break}}} R_{\\mathrm{top}} \\, dt\n$$\n由于 $R(P)$ 和 $\\beta$ 给定为常数，所以 $R_{\\mathrm{top}}$ 相对于时间也是常数。积分得到：\n$$\n\\delta = R_{\\mathrm{top}} \\cdot t_{\\mathrm{break}}\n$$\n解出 $t_{\\mathrm{break}}$，我们得到：\n$$\nt_{\\mathrm{break}} = \\frac{\\delta}{R_{\\mathrm{top}}} = \\frac{\\delta}{(1-\\beta)R(P)}\n$$\n\n接下来，我们计算体清除时间 $t_{\\mathrm{bulk}}$。这被定义为，如果溶解在整个厚度上都以体速率 $R(P)$ 均匀发生，即在没有任何表面抑制的情况下，清除整个厚度为 $H$ 的薄膜所需的时间。\n在这种假设情景下，界面在整个过程中的速度将是恒定的，等于 $R(P)$：\n$$\n\\frac{dz}{dt} = R(P)\n$$\n为了求出清除厚度 $H$ 的时间，我们建立一个类似的积分：\n$$\n\\int_{0}^{H} dz = \\int_{0}^{t_{\\mathrm{bulk}}} R(P) \\, dt\n$$\n由于 $R(P)$ 是常数，这给出：\n$$\nH = R(P) \\cdot t_{\\mathrm{bulk}}\n$$\n解出 $t_{\\mathrm{bulk}}$：\n$$\nt_{\\mathrm{bulk}} = \\frac{H}{R(P)}\n$$\n\n最后，我们被要求求出比率 $\\rho = t_{\\mathrm{break}} / t_{\\mathrm{bulk}}$。我们代入为 $t_{\\mathrm{break}}$ 和 $t_{\\mathrm{bulk}}$ 推导出的表达式：\n$$\n\\rho = \\frac{t_{\\mathrm{break}}}{t_{\\mathrm{bulk}}} = \\frac{\\frac{\\delta}{(1-\\beta)R(P)}}{\\frac{H}{R(P)}}\n$$\n体溶解速率 $R(P)$ 是分子和分母的公因子，因此可以消去：\n$$\n\\rho = \\frac{\\delta}{H(1-\\beta)}\n$$\n该表达式以薄膜厚度 $H$、受抑制层厚度 $\\delta$ 和抑制强度参数 $\\beta$ 的形式提供了所求的比率。正如预期的那样，它是一个无量纲的量，因为它是两个时间段的比率。",
            "answer": "$$\\boxed{\\frac{\\delta}{H(1-\\beta)}}$$"
        },
        {
            "introduction": "建立精确的预测模型不仅需要理解其正向物理过程，还需要具备从实验数据中确定模型参数的能力，即所谓的“反演问题”。这项综合性练习  要求你整合体溶解（类Mack模型）和表面抑制（类Notch模型）效应，构建一个完整的计算模型。通过生成合成数据并实施数值反演来恢复原始参数，本练习提供了模型验证和参数提取全流程的实践经验，这是任何工艺建模工程师的核心技能。",
            "id": "4161113",
            "problem": "您的任务是使用一个根据半导体制造过程建模中使用的 Mack 和 notch 公式代表性的耦合基础速率和表面抑制模型生成的合成数据集，来验证一种用于光刻胶显影动力学的反演算法。请从以下基础理论出发，您必须用它来推导一个可计算的模型：\n\n1. 垂直显影速度等于局部溶解速率，因此光刻胶表面的演化由 $dz/dt = R_{\\mathrm{eff}}$ 控制，其中 $z$ 是深度，$t$ 是时间。\n2. 体溶解速率随树脂位点的局部去保护分数 $p \\in [0,1]$ 单调变化，在最小速率 $R_{\\min}$ 和最大速率 $R_{\\max}$ 之间过渡，并表现出由一个正实数指数 $n$ 控制的选择性。\n3. 表面抑制以乘法方式将有效溶解速率相对于体速率降低一个因子，该因子随离表面深度 $z$ 的增加而衰减。这种抑制由一个正强度参数 $\\beta$、一个正衰减长度 $\\lambda$ 和一个正阶数 $m$ 来表征。\n\n您的程序必须执行以下任务：\n\nA. 推导体速率作为一个关于去保护分数 $p$ 和参数 $R_{\\min}$、$R_{\\max}$ 及 $n$ 的函数的最小、平滑且物理上一致的参数形式，该形式在 $R_{\\min}$ 和 $R_{\\max}$ 之间有界，并且对于任何固定的可接受参数，在 $p \\in (0,1)$ 区间内对 $p$ 严格递增。然后，推导一个与影响随深度从表面衰减相一致的乘性表面抑制衰减因子，该因子由参数 $m$、$\\beta$ 和 $\\lambda$ 表征。将这两者结合起来，得到一个显式模型 $R_{\\mathrm{model}}(p,z; \\theta)$，其中 $\\theta$ 表示六个参数 $\\{R_{\\min}, R_{\\max}, n, m, \\beta, \\lambda\\}$。\n\nB. 通过在指定的网格上采样点对 $(p,z)$ 来构建合成数据集，并计算带噪声的观测值\n$$\nR_{\\mathrm{obs}}(p,z) = R_{\\mathrm{model}}(p,z; \\theta_{\\mathrm{true}}) + \\varepsilon,\n$$\n其中 $\\varepsilon$ 是均值为零、标准差 $\\sigma$ 已知的独立高斯噪声。去保护分数 $p$ 是无量纲的。深度 $z$ 必须以纳米为单位指定，溶解速率必须以纳米/秒为单位。内部计算中所有报告的速率和深度都必须以这些单位处理。\n\nC. 使用非线性最小二乘法反演模型，从合成数据中恢复参数估计值 $\\hat{\\theta}$，并使用基于雅可比矩阵的协方差近似，在残差模型的常规线性化下，计算 $\\theta$ 每个分量的近似双边 $95\\%$ 置信区间。通过用残差方差估计值缩放协方差，明确地考虑自由度。对于点对 $(R_{\\min}, R_{\\max})$，引入一种参数化方法，以保证在优化过程中 $R_{\\max} \\ge R_{\\min}$，而无需施加非线性不等式约束。\n\nD. 通过检查每个真实参数值是否位于其对应的双边 $95\\%$ 置信区间内来验证反演结果。对于每个测试用例，输出一个布尔值，当且仅当所有六个真实参数同时位于各自的置信区间内时，该值为真。\n\n测试套件和数据生成规范：\n\n精确实现以下三个合成测试用例，每个用例都有自己的随机种子以确保可复现性。在所有情况下，您的程序必须在 $(p,z)$ 上构建一个全因子网格，添加具有指定标准差 $\\sigma$ 的独立同分布高斯噪声，然后如上所述进行反演和验证。深度使用纳米（nanometers）单位，速率使用纳米/秒（nanometers per second）单位。\n\n- 测试用例 1（理想路径，中等信噪比）：\n  - 真实参数：$R_{\\min} = 1.0$, $R_{\\max} = 100.0$, $n = 3.0$, $m = 2.0$, $\\beta = 3.0$, $\\lambda = 20.0$。\n  - 网格：$p$ 在 $[0,1]$ 上取 $11$ 个等距点；$z$ 在 $[0,200]$ 纳米上取 $11$ 个等距点。\n  - 噪声：高斯分布，标准差 $\\sigma = 1.0$ 纳米/秒。\n  - 随机种子：$123$。\n\n- 测试用例 2（样本较少，噪声较高）：\n  - 真实参数：$R_{\\min} = 0.5$, $R_{\\max} = 50.0$, $n = 1.5$, $m = 1.0$, $\\beta = 1.0$, $\\lambda = 50.0$。\n  - 网格：$p$ 在 $[0,1]$ 上取 $7$ 个等距点；$z$ 在 $[0,200]$ 纳米上取 $7$ 个等距点。\n  - 噪声：高斯分布，标准差 $\\sigma = 2.5$ 纳米/秒。\n  - 随机种子：$456$。\n\n- 测试用例 3（靠近顶层表面的强表面抑制）：\n  - 真实参数：$R_{\\min} = 2.0$, $R_{\\max} = 80.0$, $n = 4.0$, $m = 3.0$, $\\beta = 5.0$, $\\lambda = 5.0$。\n  - 网格：$p$ 在 $[0,1]$ 上取 $11$ 个等距点；$z$ 在 $[0,50]$ 纳米上取 $21$ 个等距点。\n  - 噪声：高斯分布，标准差 $\\sigma = 1.5$ 纳米/秒。\n  - 随机种子：$789$。\n\n算法和数值要求：\n\n- 使用带边界约束的非线性最小二乘求解器。对 $(R_{\\min}, R_{\\max})$ 引入重参数化，通过对 $R_{\\min}$ 和一个非负差值参数 $\\Delta$ 进行优化来强制 $R_{\\max} \\ge R_{\\min}$，使得 $R_{\\max} = R_{\\min} + \\Delta$。\n- 基于雅可比矩阵的协方差计算如下\n$$\n\\mathrm{Cov}(\\hat{\\phi}) \\approx s^2 \\left(J^\\top J\\right)^{-1},\n$$\n其中 $\\hat{\\phi}$ 是内部使用的优化参数向量，$J$ 是解处的残差雅可比矩阵，以及\n$$\ns^2 = \\frac{1}{N - K} \\sum_{i=1}^N r_i^2\n$$\n其中 $N$ 是标量残差的数量，$K$ 是自由参数的数量，$r_i$ 是加权残差。如果您使用由已知 $\\sigma$ 加权的残差，请确保在构成 $J$ 和 $s^2$ 时加权方式是一致的。\n- 使用线性误差传播，将不确定性从内部参数化 $(R_{\\min}, \\Delta, n, m, \\beta, \\lambda)$ 传播到 $(R_{\\min}, R_{\\max}, n, m, \\beta, \\lambda)$。特别地，对于 $R_{\\max} = R_{\\min} + \\Delta$，使用\n$$\n\\mathrm{Var}(\\widehat{R}_{\\max}) = \\mathrm{Var}(\\widehat{R}_{\\min}) + \\mathrm{Var}(\\widehat{\\Delta}) + 2\\,\\mathrm{Cov}(\\widehat{R}_{\\min}, \\widehat{\\Delta}).\n$$\n\n最终输出格式：\n\n您的程序应生成一行输出，其中仅包含一个包含三个布尔值的列表，每个布尔值对应上面列出的一个测试用例，表示所有六个真实参数是否同时包含在它们的双边 $95\\%$ 置信区间内。该列表必须格式化为一个逗号分隔的 Python 风格列表，不含空格，例如，“[True,False,True]”。不得打印任何其他文本。\n\n所有内部速率必须以纳米/秒为单位处理，深度以纳米为单位。不使用角度。不打印任何百分比；任何分数如果需要，必须表示为小数。最终打印的输出是按规定格式的无单位布尔值。",
            "solution": "该问题被认为是有效的，因为它科学地基于光刻胶显影动力学的既定原则，问题定义良好，目标明确，数据充分，并且没有矛盾或含糊之处。它提出了一个在计算科学与工程中常见的，标准但并非无足轻重的模型推导、数值优化和统计验证的练习。\n\n### A. 模型推导\n\n该问题要求推导有效溶解速率 $R_{\\mathrm{eff}}$ 的参数模型，该模型是树脂位点的去保护分数 $p$ 和离表面的深度 $z$ 的函数。该模型是体溶解速率项 $R_{\\mathrm{bulk}}(p)$ 与表面抑制因子 $S(z)$ 的乘积。\n\n**1. 体溶解速率 ($R_{\\mathrm{bulk}}$)**\n\n体速率 $R_{\\mathrm{bulk}}$ 必须满足以下条件：\n- 它取决于去保护分数 $p \\in [0, 1]$。\n- 它在最小速率 $R_{\\min}$ 和最大速率 $R_{\\max}$ 之间过渡。具体来说，$R_{\\mathrm{bulk}}(p=0) = R_{\\min}$ 且 $R_{\\mathrm{bulk}}(p=1) = R_{\\max}$。\n- 对于 $p \\in (0,1)$，它是严格递增的。\n- 其选择性由一个正指数 $n$ 控制。\n- 它必须是一个最小、平滑且物理上一致的函数形式。\n\n一个满足这些要求的简单而常见的模型是在两个极限速率之间进行幂律插值：\n$$\nR_{\\mathrm{bulk}}(p; R_{\\min}, R_{\\max}, n) = R_{\\min} + (R_{\\max} - R_{\\min}) p^n\n$$\n让我们根据标准验证此形式：\n- 在 $p=0$ 时，$R_{\\mathrm{bulk}}(0) = R_{\\min} + (R_{\\max} - R_{\\min}) \\cdot 0^n = R_{\\min}$。\n- 在 $p=1$ 时，$R_{\\mathrm{bulk}}(1) = R_{\\min} + (R_{\\max} - R_{\\min}) \\cdot 1^n = R_{\\max}$。\n- 对于 $p \\in (0,1)$，假设 $R_{\\max}  R_{\\min}  0$ 和 $n0$，速率界于 $R_{\\min}$ 和 $R_{\\max}$ 之间。\n- 关于 $p$ 的导数是 $\\frac{\\partial R_{\\mathrm{bulk}}}{\\partial p} = (R_{\\max} - R_{\\min}) n p^{n-1}$。给定 $R_{\\max}  R_{\\min}$ 和 $n0$，此导数对于 $p \\in (0,1)$ 是正的，因此函数是严格递增的。\n这种形式是平滑的，并代表了从慢速蚀刻的保护态到快速蚀刻的去保护态的物理上合理的过渡。\n\n**2. 表面抑制因子 ($S(z)$)**\n\n表面抑制因子 $S(z)$ 必须是一个降低体速率的乘性因子。其特性是：\n- 抑制效应在表面（$z=0$）处最强，并随深度 $z$ 的增加而衰减。\n- 该因子由一个正强度 $\\beta$、一个正衰减长度 $\\lambda$ 和一个正阶数 $m$ 表征。\n\n这意味着因子 $S(z)$ 在表面附近应小于 $1$，并在 $z \\to \\infty$ 时趋近于 $1$。一个捕捉此行为并包含指定参数的函数形式是：\n$$\nS(z; m, \\beta, \\lambda) = \\frac{1}{1 + \\beta \\exp\\left(-\\left(\\frac{z}{\\lambda}\\right)^m\\right)}\n$$\n让我们验证此形式：\n- 在表面 $z=0$ 处，指数项为 $1$，且 $S(0) = \\frac{1}{1+\\beta}$。由于 $\\beta0$，该因子小于 $1$，表示最大抑制。\n- 对于大深度 $z \\to \\infty$，项 $(z/\\lambda)^m \\to \\infty$，所以指数项趋于 $0$。因此，$S(z) \\to 1$，意味着抑制效应消失。\n- 参数 $\\beta$ 控制表面抑制的强度。\n- 参数 $\\lambda$ 是抑制衰减的特征长度尺度。\n- 参数 $m$ 控制衰减曲线的形状。\n\n**3. 组合模型 ($R_{\\mathrm{model}}$)**\n\n有效溶解速率的完整模型是体速率和表面抑制因子的乘积：\n$$\nR_{\\mathrm{model}}(p,z; \\theta) = R_{\\mathrm{bulk}}(p) \\cdot S(z)\n$$\n其中 $\\theta = \\{R_{\\min}, R_{\\max}, n, m, \\beta, \\lambda\\}$。代入推导出的形式：\n$$\nR_{\\mathrm{model}}(p,z; \\theta) = \\left[R_{\\min} + (R_{\\max} - R_{\\min}) p^n\\right] \\left[\\frac{1}{1 + \\beta \\exp\\left(-\\left(\\frac{z}{\\lambda}\\right)^m\\right)}\\right]\n$$\n这是用于数据生成和反演的显式模型。\n\n### B. 合成数据生成\n\n对于每个测试用例，按以下方式生成合成数据集：\n1.  使用指定的范围和点数构建 $(p, z)$ 点的因子网格。\n2.  对于网格上的每个点 $(p_i, z_i)$，使用提供的真实参数 $\\theta_{\\mathrm{true}}$ 计算真实速率 $R_{\\mathrm{model}}(p_i, z_i; \\theta_{\\mathrm{true}})$。\n3.  向每个真实速率添加独立同分布的高斯噪声 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$，以获得“观测”速率：\n    $$\n    R_{\\mathrm{obs}, i} = R_{\\mathrm{model}}(p_i, z_i; \\theta_{\\mathrm{true}}) + \\varepsilon_i\n    $$\n为可复现性设置随机数生成器种子。\n\n### C. 模型反演和置信区间\n\n目标是从带噪声的数据 $R_{\\mathrm{obs}}$ 中恢复参数 $\\theta$。\n\n**1. 重参数化**\n\n为了在不使用非线性不等式约束的情况下强制执行约束 $R_{\\max} \\ge R_{\\min} \\ge 0$，我们定义了一组新的优化参数 $\\phi$：\n$$\n\\phi = (R_{\\min}, \\Delta, n, m, \\beta, \\lambda)\n$$\n其中 $\\Delta = R_{\\max} - R_{\\min}$。原始参数通过 $R_{\\max} = R_{\\min} + \\Delta$ 恢复。对 $\\phi$ 进行优化，并带有简单的非负边界：$R_{\\min} \\ge 0$, $\\Delta \\ge 0$, $n0$, $m0$, $\\beta \\ge 0$, $\\lambda0$。\n\n**2. 非线性最小二乘法**\n\n我们使用非线性最小二乘法来找到最小化加权残差平方和的参数向量 $\\hat{\\phi}$：\n$$\n\\chi^2(\\phi) = \\sum_{i=1}^{N} \\left( \\frac{R_{\\mathrm{obs}, i} - R_{\\mathrm{model}}(p_i, z_i; \\phi)}{\\sigma} \\right)^2\n$$\n其中 $N$ 是数据点的总数。待最小化的函数使用 `scipy.optimize.least_squares` 实现。\n\n**3. 协方差和置信区间**\n\n估计参数 $\\hat{\\phi}$ 的近似协方差矩阵是基于解处加权残差的雅可比矩阵计算的。令 $r'_i(\\phi) = (R_{\\mathrm{obs}, i} - R_{\\mathrm{model}}(p_i, z_i; \\phi))/\\sigma$ 为加权残差，并令 $J'$ 为在 $\\hat{\\phi}$ 处求值的雅可比矩阵，其元素为 $J'_{ij} = \\partial r'_i / \\partial \\phi_j$。\n协方差通过约化卡方值进行缩放，以考虑拟合优度：\n$$\ns^2 = \\frac{1}{N - K} \\sum_{i=1}^{N} (r'_i(\\hat{\\phi}))^2 = \\frac{\\chi^2(\\hat{\\phi})}{N-K}\n$$\n其中 $K=6$ 是自由参数的数量。$\\hat{\\phi}$ 的协方差矩阵则为：\n$$\n\\mathrm{Cov}(\\hat{\\phi}) \\approx s^2 (J'^\\top J')^{-1}\n$$\n$\\hat{\\phi}$ 各分量的方差是该矩阵的对角元素。每个参数 $\\hat{\\phi}_j$ 的标准误是 $\\mathrm{SE}(\\hat{\\phi}_j) = \\sqrt{\\mathrm{Cov}(\\hat{\\phi})_{jj}}$。\n\n为了找到 $\\widehat{R}_{\\max} = \\widehat{R}_{\\min} + \\widehat{\\Delta}$ 的标准误，我们使用线性误差传播：\n$$\n\\mathrm{Var}(\\widehat{R}_{\\max}) = \\mathrm{Var}(\\widehat{R}_{\\min}) + \\mathrm{Var}(\\widehat{\\Delta}) + 2\\,\\mathrm{Cov}(\\widehat{R}_{\\min}, \\widehat{\\Delta})\n$$\n标准误为 $\\mathrm{SE}(\\widehat{R}_{\\max}) = \\sqrt{\\mathrm{Var}(\\widehat{R}_{\\max})}$。\n\n最后，每个参数 $\\theta_j \\in \\{R_{\\min}, R_{\\max}, n, m, \\beta, \\lambda\\}$ 的双边 $95\\%$ 置信区间计算如下：\n$$\n\\mathrm{CI}_j = [\\hat{\\theta}_j - z_{0.025} \\cdot \\mathrm{SE}(\\hat{\\theta}_j), \\hat{\\theta}_j + z_{0.025} \\cdot \\mathrm{SE}(\\hat{\\theta}_j)]\n$$\n其中 $z_{0.025} \\approx 1.95996$ 是对应于累积概率 $0.975$ 的标准正态分布的临界值。\n\n### D. 验证\n\n对于每个测试用例，通过检查六个参数中每个参数的真实值 $\\theta_{\\mathrm{true}, j}$ 是否位于其对应的计算出的 $95\\%$ 置信区间内来进行验证：\n$$\n\\mathrm{CI}_{j, \\text{lower}} \\le \\theta_{\\mathrm{true}, j} \\le \\mathrm{CI}_{j, \\text{upper}}\n$$\n一个测试用例当且仅当所有六个真实参数同时包含在它们各自的置信区间内时，才通过验证。最终输出是一个布尔值列表，代表每个测试用例的验证结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the photoresist kinetics inversion problem for the three specified test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: Happy path\n        {\n            \"true_params\": {\"R_min\": 1.0, \"R_max\": 100.0, \"n\": 3.0, \"m\": 2.0, \"beta\": 3.0, \"lambda\": 20.0},\n            \"p_grid\": np.linspace(0, 1, 11),\n            \"z_grid\": np.linspace(0, 200, 11),\n            \"sigma\": 1.0,\n            \"seed\": 123\n        },\n        # Case 2: Fewer samples, higher noise\n        {\n            \"true_params\": {\"R_min\": 0.5, \"R_max\": 50.0, \"n\": 1.5, \"m\": 1.0, \"beta\": 1.0, \"lambda\": 50.0},\n            \"p_grid\": np.linspace(0, 1, 7),\n            \"z_grid\": np.linspace(0, 200, 7),\n            \"sigma\": 2.5,\n            \"seed\": 456\n        },\n        # Case 3: Strong surface inhibition\n        {\n            \"true_params\": {\"R_min\": 2.0, \"R_max\": 80.0, \"n\": 4.0, \"m\": 3.0, \"beta\": 5.0, \"lambda\": 5.0},\n            \"p_grid\": np.linspace(0, 1, 11),\n            \"z_grid\": np.linspace(0, 50, 21),\n            \"sigma\": 1.5,\n            \"seed\": 789\n        }\n    ]\n\n    results = []\n\n    # Model definition using the internal optimization parametrization (phi)\n    # phi = (R_min, Delta, n, m, beta, lambda)\n    def R_model(phi, p, z):\n        R_min, Delta, n, m, beta, lam = phi\n        \n        # Ensure parameters are valid to prevent math errors during optimization\n        if n = 0 or R_min  0 or Delta  0 or lam = 0 or m = 0:\n            return np.full_like(p, np.inf)\n\n        R_max = R_min + Delta\n        \n        R_bulk = R_min + (R_max - R_min) * (p**n)\n        \n        S_z = 1.0 / (1.0 + beta * np.exp(-((z / lam)**m)))\n        \n        return R_bulk * S_z\n\n    # Residuals function for least_squares\n    def residuals(phi, p, z, R_obs, sigma):\n        return (R_obs - R_model(phi, p, z)) / sigma\n\n    # Main loop over test cases\n    for case in test_cases:\n        # Extract true parameters and re-parametrize\n        theta_true_map = case[\"true_params\"]\n        theta_true_vec = np.array([\n            theta_true_map[\"R_min\"], theta_true_map[\"R_max\"], theta_true_map[\"n\"],\n            theta_true_map[\"m\"], theta_true_map[\"beta\"], theta_true_map[\"lambda\"]\n        ])\n        \n        phi_true_vec = np.array([\n            theta_true_map[\"R_min\"],\n            theta_true_map[\"R_max\"] - theta_true_map[\"R_min\"],\n            theta_true_map[\"n\"],\n            theta_true_map[\"m\"],\n            theta_true_map[\"beta\"],\n            theta_true_map[\"lambda\"]\n        ])\n\n        # Generate synthetic data\n        p_grid, z_grid = np.meshgrid(case[\"p_grid\"], case[\"z_grid\"])\n        p_flat, z_flat = p_grid.flatten(), z_grid.flatten()\n        \n        rng = np.random.default_rng(case[\"seed\"])\n        \n        R_true = R_model(phi_true_vec, p_flat, z_flat)\n        noise = rng.normal(0, case[\"sigma\"], size=R_true.shape)\n        R_obs = R_true + noise\n\n        # Set up optimization\n        # Use true parameters as initial guess for robust convergence test\n        phi0 = phi_true_vec.copy() \n        \n        # Bounds: [R_min, Delta, n, m, beta, lambda]\n        # Use a small positive epsilon for strictly positive parameters.\n        eps = 1e-9\n        bounds = ([0, 0, eps, eps, 0, eps], \n                  [np.inf, np.inf, np.inf, np.inf, np.inf, np.inf])\n\n        # Perform nonlinear least-squares fit\n        lsq_result = least_squares(\n            residuals,\n            phi0,\n            args=(p_flat, z_flat, R_obs, case[\"sigma\"]),\n            bounds=bounds,\n            method='trf'\n        )\n        \n        phi_hat = lsq_result.x\n        \n        # Post-process to get CIs\n        # Jacobian and residuals\n        J_prime = lsq_result.jac\n        res_weighted = lsq_result.fun\n        \n        # Degrees of freedom\n        N = len(R_obs)\n        K = len(phi_hat)\n        dof = N - K\n\n        # Covariance matrix for phi\n        if dof > 0:\n            s2 = np.sum(res_weighted**2) / dof\n            try:\n                cov_phi = s2 * np.linalg.inv(J_prime.T @ J_prime)\n                # Standard errors for phi\n                se_phi = np.sqrt(np.diag(cov_phi))\n            except np.linalg.LinAlgError:\n                # If inversion fails, CIs are undefined; validation fails\n                results.append(False)\n                continue\n        else:\n            # Not enough data points to estimate variance\n            results.append(False)\n            continue\n\n        # Map back to theta parameters\n        theta_hat = np.array([\n            phi_hat[0],                    # R_min\n            phi_hat[0] + phi_hat[1],       # R_max\n            phi_hat[2],                    # n\n            phi_hat[3],                    # m\n            phi_hat[4],                    # beta\n            phi_hat[5]                     # lambda\n        ])\n        \n        # Calculate standard error for R_max using error propagation\n        var_R_min = cov_phi[0, 0]\n        var_Delta = cov_phi[1, 1]\n        cov_R_min_Delta = cov_phi[0, 1]\n        var_R_max = var_R_min + var_Delta + 2 * cov_R_min_Delta\n\n        se_theta = np.array([\n            se_phi[0],                    # SE(R_min)\n            np.sqrt(var_R_max),           # SE(R_max)\n            se_phi[2],                    # SE(n)\n            se_phi[3],                    # SE(m)\n            se_phi[4],                    # SE(beta)\n            se_phi[5]                     # SE(lambda)\n        ])\n        \n        # Calculate 95% CIs\n        z_score = norm.ppf(0.975)\n        ci_lower = theta_hat - z_score * se_theta\n        ci_upper = theta_hat + z_score * se_theta\n        \n        # Validate if true parameters are within CIs\n        is_valid = np.all((theta_true_vec >= ci_lower)  (theta_true_vec = ci_upper))\n        results.append(is_valid)\n\n    # Print final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}