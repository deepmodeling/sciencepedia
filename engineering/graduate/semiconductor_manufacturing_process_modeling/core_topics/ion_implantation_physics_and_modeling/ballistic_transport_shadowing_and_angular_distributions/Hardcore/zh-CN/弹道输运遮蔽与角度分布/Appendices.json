{
    "hands_on_practices": [
        {
            "introduction": "在弹道输运模型中，粒子的初始角分布是决定薄膜沉积轮廓和均匀性的关键因素。物理气相沉积（PVD）等工艺中的粒子通量通常不完全垂直于基底，而是遵循特定的角度分布，例如余弦幂次定律。通过本练习 ，您将从第一性原理出发，推导并计算在不同角分布下（例如朗伯分布 $n=1$ 和更具方向性的分布 $n=2$），到达特定立体角内的粒子通量份额，从而深入理解源的准直性如何影响沉积结果。",
            "id": "4110130",
            "problem": "考虑一个平面靶，在高真空中进行物理气相沉积（PVD）溅射，原子被发射到上半球，并以弹道方式输运到一个平行的平面基底上。忽略气相散射和几何遮蔽，从而使得在基底上的到达分布与发射分布相同。假设溅射的角发射遵循余弦幂律，单位立体角内的微分通量由 $J(\\theta)\\propto \\cos^{n}(\\theta)$ 给出，其中极角 $\\theta\\in[0,\\pi/2]$ 是从靶材法线方向测量的，并且围绕法线具有方位角对称性。\n\n使用通量和立体角的基本定义，从第一性原理出发，推导位于围绕法线的半角为 $\\theta_{0}$ 的锥体内的总发射通量的归一化分数，即在 $\\theta < \\theta_{0}$ 范围内收集到的分数。然后，对于 $n=2$ 和 $n=1$ 两种情况，计算当 $\\theta_{0}=30^{\\circ}$ 时的该分数值。在最终答案中，将这两个分数值以行矩阵 $\\begin{pmatrix}F_{n=2} & F_{n=1}\\end{pmatrix}$ 的形式给出。将每个条目四舍五入到四位有效数字。角度单位为度。分数为无量纲量；最终答案中不包含单位。",
            "solution": "问题要求计算从平面溅射靶发射的总通量中，在围绕法线的半角为 $\\theta_{0}$ 的锥体内收集到的归一化分数。溅射通量的角分布由余弦幂律给出。\n\n首先，我们将问题陈述形式化。单位立体角内的微分通量 $J(\\theta)$ 与 $\\cos^n(\\theta)$ 成正比。我们可以将其写为：\n$$\nJ(\\theta) = k \\cos^n(\\theta)\n$$\n其中 $k$ 是一个比例常数，$\\theta$ 是从靶材法线测量的极角。问题说明 $\\theta \\in [0, \\pi/2]$。发射具有方位角对称性。\n\n发射到微分立体角 $d\\Omega$ 内的总微分通量 $d\\Phi$ 由下式给出：\n$$\nd\\Phi = J(\\theta) d\\Omega\n$$\n在球坐标系中，微分立体角 $d\\Omega$ 由下式给出：\n$$\nd\\Omega = \\sin(\\theta) d\\theta d\\phi\n$$\n其中 $\\phi$ 是方位角。\n\n为了求出在半角为 $\\theta_0$ 的锥体内收集到的通量 $\\Phi(\\theta_0)$，我们必须在适当的角度范围内对微分通量 $d\\Phi$ 进行积分。由于方位角对称性，我们将 $\\phi$ 从 $0$ 积分到 $2\\pi$。极角 $\\theta$ 从 $0$ 积分到 $\\theta_0$。\n$$\n\\Phi(\\theta_0) = \\int_{\\phi=0}^{2\\pi} \\int_{\\theta=0}^{\\theta_0} J(\\theta) \\sin(\\theta) d\\theta d\\phi\n$$\n代入 $J(\\theta)$ 的表达式：\n$$\n\\Phi(\\theta_0) = \\int_{0}^{2\\pi} \\int_{0}^{\\theta_0} k \\cos^n(\\theta) \\sin(\\theta) d\\theta d\\phi\n$$\n由于被积函数不依赖于 $\\phi$，对 $\\phi$ 的积分产生一个因子 $2\\pi$：\n$$\n\\Phi(\\theta_0) = 2\\pi k \\int_{0}^{\\theta_0} \\cos^n(\\theta) \\sin(\\theta) d\\theta\n$$\n接下来，我们计算发射到整个上半球的总通量 $\\Phi_{total}$。这通过将 $\\theta$ 从 $0$ 积分到 $\\pi/2$ 来得到：\n$$\n\\Phi_{total} = \\int_{0}^{2\\pi} \\int_{0}^{\\pi/2} k \\cos^n(\\theta) \\sin(\\theta) d\\theta d\\phi\n$$\n$$\n\\Phi_{total} = 2\\pi k \\int_{0}^{\\pi/2} \\cos^n(\\theta) \\sin(\\theta) d\\theta\n$$\n在锥体内收集到的通量的归一化分数 $F(\\theta_0)$ 是 $\\Phi(\\theta_0)$ 与 $\\Phi_{total}$ 的比值：\n$$\nF(\\theta_0) = \\frac{\\Phi(\\theta_0)}{\\Phi_{total}} = \\frac{2\\pi k \\int_{0}^{\\theta_0} \\cos^n(\\theta) \\sin(\\theta) d\\theta}{2\\pi k \\int_{0}^{\\pi/2} \\cos^n(\\theta) \\sin(\\theta) d\\theta}\n$$\n常数项 $2\\pi k$ 被消去：\n$$\nF(\\theta_0) = \\frac{\\int_{0}^{\\theta_0} \\cos^n(\\theta) \\sin(\\theta) d\\theta}{\\int_{0}^{\\pi/2} \\cos^n(\\theta) \\sin(\\theta) d\\theta}\n$$\n为了计算该积分，我们使用换元法，令 $u = \\cos(\\theta)$。这得到 $du = -\\sin(\\theta) d\\theta$。\n\n我们先计算不定积分：\n$$\n\\int \\cos^n(\\theta) \\sin(\\theta) d\\theta = \\int u^n (-du) = - \\int u^n du = -\\frac{u^{n+1}}{n+1} = -\\frac{\\cos^{n+1}(\\theta)}{n+1}\n$$\n现在，我们应用积分限。\n对于分子：\n$$\n\\int_{0}^{\\theta_0} \\cos^n(\\theta) \\sin(\\theta) d\\theta = \\left[ -\\frac{\\cos^{n+1}(\\theta)}{n+1} \\right]_{0}^{\\theta_0} = -\\frac{\\cos^{n+1}(\\theta_0)}{n+1} - \\left(-\\frac{\\cos^{n+1}(0)}{n+1}\\right) = \\frac{1 - \\cos^{n+1}(\\theta_0)}{n+1}\n$$\n对于分母：\n$$\n\\int_{0}^{\\pi/2} \\cos^n(\\theta) \\sin(\\theta) d\\theta = \\left[ -\\frac{\\cos^{n+1}(\\theta)}{n+1} \\right]_{0}^{\\pi/2} = -\\frac{\\cos^{n+1}(\\pi/2)}{n+1} - \\left(-\\frac{\\cos^{n+1}(0)}{n+1}\\right) = \\frac{0 - (-1)}{n+1} = \\frac{1}{n+1}\n$$\n将这些结果代回分数 $F(\\theta_0)$ 的表达式中：\n$$\nF(\\theta_0) = \\frac{\\frac{1 - \\cos^{n+1}(\\theta_0)}{n+1}}{\\frac{1}{n+1}} = 1 - \\cos^{n+1}(\\theta_0)\n$$\n这是半角为 $\\theta_0$ 的锥体内通量分数的一般公式。\n\n问题要求我们对 $\\theta_0 = 30^{\\circ}$ 以及 $n=2$ 和 $n=1$ 两种情况计算此分数值。我们注意到 $30^{\\circ}$ 等于 $\\pi/6$ 弧度，并且 $\\cos(30^{\\circ}) = \\frac{\\sqrt{3}}{2}$。\n\n情况 1：$n=2$\n该分数表示为 $F_{n=2}$。\n$$\nF_{n=2} = 1 - \\cos^{2+1}(30^{\\circ}) = 1 - \\cos^3(30^{\\circ})\n$$\n代入 $\\cos(30^{\\circ})$ 的值：\n$$\nF_{n=2} = 1 - \\left(\\frac{\\sqrt{3}}{2}\\right)^3 = 1 - \\frac{3\\sqrt{3}}{8}\n$$\n进行数值计算：\n$$\nF_{n=2} \\approx 1 - \\frac{3 \\times 1.7320508}{8} = 1 - \\frac{5.1961524}{8} \\approx 1 - 0.64951905 = 0.35048095\n$$\n四舍五入到四位有效数字，我们得到 $F_{n=2} \\approx 0.3505$。\n\n情况 2：$n=1$（朗伯分布）\n该分数表示为 $F_{n=1}$。\n$$\nF_{n=1} = 1 - \\cos^{1+1}(30^{\\circ}) = 1 - \\cos^2(30^{\\circ})\n$$\n使用恒等式 $1 - \\cos^2(\\theta) = \\sin^2(\\theta)$，这也等于 $F_{n=1} = \\sin^2(30^{\\circ})$。\n代入 $\\cos(30^{\\circ})$ 的值：\n$$\nF_{n=1} = 1 - \\left(\\frac{\\sqrt{3}}{2}\\right)^2 = 1 - \\frac{3}{4} = \\frac{1}{4} = 0.25\n$$\n保留四位有效数字，结果为 $0.2500$。\n\n最终答案需以行矩阵 $\\begin{pmatrix} F_{n=2} & F_{n=1} \\end{pmatrix}$ 的形式给出。\n值为 $F_{n=2} = 0.3505$ 和 $F_{n=1} = 0.2500$。\n因此矩阵为 $\\begin{pmatrix} 0.3505 & 0.2500 \\end{pmatrix}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.3505 & 0.2500\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "当粒子进入高深宽比的微结构（如通孔或沟槽）时，并非所有粒子都能到达底部。粒子与侧壁的碰撞以及在侧壁上的吸附（由非零的“吸附系数”$s$ 描述）会导致沿着特征深度的粒子通量逐渐衰减。本练习  采用一个简化的指数衰减模型来描述这一过程，帮助您建立一个直观的解析框架，以理解几何形状（深宽比 $L/r$）和表面化学（吸附系数 $s$）如何共同决定到达底部的粒子份额，这对于预测原子层沉积（ALD）等工艺的共形性至关重要。",
            "id": "4110168",
            "problem": "一个半径为 $r$、深度为 $L$ 的高深宽比圆柱形通孔正在通过原子层沉积（ALD）技术被中性前驱体涂覆。前驱体以余弦角分布（朗伯入射）从顶部进入通孔，并在自由分子（弹道）区域中传播。每次与侧壁的碰撞都有概率 $s$（粘附系数）发生粘附，未粘附时则发生漫反射。在一个简化的指数生存模型中，将角度重分布和遮蔽效应合并为一个恒定的单位轴向距离危险率，单位深度损失率被认为与表面-体积几何形状和粘附系数成比例，使得轴向粒子数通量 $J(z)$ 的衰减满足以下形式的常微分方程\n$$\n\\frac{dJ}{dz}=-k\\,J,\n$$\n其中 $k$ 与 $s/r$ 成正比。在这个简单模型中，取比例常数为1，即 $k=s/r$。从质量守恒和单位深度危险率恒定的假设出发，推导未发生粘附而到达通孔底部的粒子透射分数 $K \\equiv J(L)/J(0)$，用 $s$、$L$ 和 $r$ 表示。然后，在 $L/r=10$ 和 $s=0.1$ 的条件下计算 $K$ 的值。将 $K$ 报告为一个四舍五入到4位有效数字的纯数。将最终答案表示为不带单位的小数。在你的推导中，明确说明建模假设，并指出所选危险率模型如何反映余弦角分布和遮蔽效应，并定性解释计算出的 $K$ 值相对于无粘附情况对透射通量的影响。",
            "solution": "问题假定轴向粒子数通量 $J(z)$ 随深度 $z$ 进入通孔的衰减由以下一阶常微分方程描述：\n$$\n\\frac{dJ}{dz} = -k J(z)\n$$\n其中 $k$ 是单位深度的恒定衰减率。根据题目设定，$k = s/r$，其中 $s$ 是粘附系数，$r$ 是通孔半径。通孔入口在 $z=0$，底部在 $z=L$。\n\n这是一个变量可分离的常微分方程。我们将其整理为：\n$$\n\\frac{dJ}{J} = -k \\, dz\n$$\n为了求出任意深度 $z$ 处的通量 $J(z)$，我们对两边进行积分。我们将通量从入口（$z=0$）处的初始值 $J(0)$ 积分到深度 $z$ 处的值 $J(z)$：\n$$\n\\int_{J(0)}^{J(z)} \\frac{1}{J'} \\, dJ' = \\int_{0}^{z} -k \\, dz'\n$$\n积分得到：\n$$\n[\\ln|J'|]_{J(0)}^{J(z)} = [-k z']_{0}^{z}\n$$\n由于通量 $J$ 是表示粒子数的非负量，我们可以省略绝对值符号。\n$$\n\\ln(J(z)) - \\ln(J(0)) = -kz\n$$\n利用对数的性质，我们得到：\n$$\n\\ln\\left(\\frac{J(z)}{J(0)}\\right) = -kz\n$$\n对两边取指数以求解比率 $J(z)/J(0)$：\n$$\n\\frac{J(z)}{J(0)} = \\exp(-kz)\n$$\n此方程描述了通量随深度的指数衰减。题目要求的透射分数 $K$ 是到达通孔底部的通量 $J(L)$ 与进入通孔的通量 $J(0)$ 之比。我们可以通过计算上述表达式在 $z=L$ 处的值来得到 $K$：\n$$\nK = \\frac{J(L)}{J(0)} = \\exp(-kL)\n$$\n代入给定的速率常数表达式 $k = s/r$：\n$$\nK = \\exp\\left(-\\frac{sL}{r}\\right)\n$$\n这是透射分数 $K$ 的最终表达式。\n\n接下来，我们针对深宽比 $L/r = 10$ 和粘附系数 $s = 0.1$ 的具体情况计算 $K$ 的值。\n指数项为 $-\\frac{sL}{r} = -s\\left(\\frac{L}{r}\\right)$。\n代入给定值：\n$$\n-s\\left(\\frac{L}{r}\\right) = -(0.1)(10) = -1\n$$\n因此，透射分数 $K$ 为：\n$$\nK = \\exp(-1) \\approx 0.36787944...\n$$\n按要求四舍五入到4位有效数字：\n$$\nK \\approx 0.3679\n$$\n\n### 建模假设与解释\n该推导依赖于所提供模型 $\\frac{dJ}{dz}=-kJ$ 中固有的一组关键简化假设：\n1.  **恒定危险率**：主要假设是粒子沿通孔向下行进单位距离时在侧壁损失的概率 $k$ 不随深度 $z$ 变化。实际上，粒子的角分布会随着它们行进得更深而改变。初始的朗伯分布具有很广的角度范围，导致入口附近有很高的损失率。随着粒子行进得更深，那些与轴线夹角大的轨迹被过滤掉，剩余的通量变得更加沿通孔轴线准直。这种准直会降低有效危险率随深度的变化。因此，该模型将这种复杂行为平均为一个单一常数 $k$。\n2.  **离散过程的连续模型**：该模型将粒子通量 $J$ 视为一个连续变量，这在粒子数量很大时是一个有效的近似。\n3.  **简化的几何依赖性**：危险率 $k=s/r$ 正确地捕捉了与半径的逆相关性（与表面积-体积比相关）和与粘附概率的直接相关性。然而，它将再发射和遮蔽等复杂几何效应合并到一个单一的比例常数中，并设为1。\n\n**余弦角分布**和**遮蔽**的物理现象通过恒定的危险率 $k$ 在模型中被粗略地反映出来。入口的余弦分布确保了许多粒子开始时具有高度倾斜于轴线的轨迹，从而保证了在顶部附近的高壁面碰撞率。该模型将这种初始的高损失行为在整个长度上进行了平均。**遮蔽**是一种几何效应，即壁的某些部分从其他点是不可见的，它控制着一个再发射粒子在下一次碰撞前行进一定距离的概率。详细的蒙特卡洛模拟会明确地追踪这些效应。在这个简化的常微分方程模型中，这些复杂的、与位置相关的概率被聚合成单一的、恒定的参数 $k$。\n\n### 结果的定性解释\n计算出的 $K \\approx 0.3679$ 值表明，对于一个深宽比为10的通孔和一个粘附系数为0.1的前驱体，只有大约36.8%的进入通孔顶部的粒子通量成功到达底部。另外63.2%由于在侧壁上粘附而损失了。在 $s=0$ 的非反应性前驱体的极限情况下，危险率 $k$ 将为0，透射分数将为 $K=\\exp(0)=1$。这意味着所有通量都将到达底部（在这个模型中，忽略了从通孔入口反向散射出去的情况）。因此，即使是一个相对较小的粘附系数 $s=0.1$，也会导致到达特征深处区域的通量发生显著衰减。这对ALD工艺有直接影响，因为它会导致非共形薄膜生长，使得通孔底部的薄膜比顶部的薄膜薄得多。",
            "answer": "$$\n\\boxed{0.3679}\n$$"
        },
        {
            "introduction": "虽然解析模型为了求解性而引入了简化假设，但要精确模拟复杂三维几何结构中的弹道输运，必须依赖于强大的数值方法。蒙特卡洛（Monte Carlo）模拟通过追踪大量单个粒子的随机路径，成为解决此类问题的黄金标准。本练习  将指导您亲手实现一个蒙特卡洛算法，用于计算复杂几何内部各表面之间的“角系数”（view factor），这是描述粒子交换的关键参数。通过数值验证互易性和能量守恒这两个基本物理定律，您不仅能掌握一种核心的仿真技术，还能深刻体会到如何确保计算模型的物理正确性。",
            "id": "4110188",
            "problem": "在半导体制造工艺的弹道输运（包含遮蔽效应和角分布）建模中，角系数这一概念用于量化在指定的角发射定律下，遵循视线输运的粒子从一个表面发射后到达另一个表面的比例。考虑一个由凸多边形横截面沿垂直轴拉伸而成的棱柱形腔体。其内表面包括水平底面和垂直侧壁；顶部开口是一个孔径，粒子可从中逃逸。假设为漫反射（朗伯）发射，即射线从每个表面微元发射时，其分布相对于局部表面法线呈余弦加权。假设表面为理想吸收表面，首次碰撞后无再发射，且气相中无粒子间碰撞。\n\n您的任务是实现一个蒙特卡洛算法，用于估算此种棱柱形腔体内部各面之间的角系数矩阵，并数值验证两个基本性质：互易性和能量平衡。所有长度单位使用米，所有角度单位使用弧度。\n\n基本原理：\n- 通过一个具有 $\\{(x_k,y_k)\\}_{k=0}^{n-1}$ 逆时针顺序顶点的凸多边形定义棱柱形腔体，该多边形从 $z=0$ 拉伸至 $z=H$，其中高度 $H>0$，$n \\geq 3$ 为顶点数。\n- 内表面为：面 $0$（位于 $z=0$ 处，覆盖多边形底面的水平底面），其面积为 $A_0$；以及面 $1$ 至 $n$（每个垂直侧壁对应多边形的一条边 $k$），其面积 $\\{A_k\\}_{k=1}^n$ 等于边长乘以 $H$。\n- 对每个内表面 $i$，定义其到其他内表面 $j$ 的角系数 $F_{ij}$ 和到顶部开口的逃逸系数 $F_{i,\\mathrm{esc}}$。根据守恒定律，$\\sum_{j} F_{ij} + F_{i,\\mathrm{esc}} = 1$。\n- 对于漫反射、视线输运，互易性要求对所有内表面 $i,j$ 均满足 $A_i F_{ij} = A_j F_{ji}$。\n\n算法说明：\n- 对每个内表面 $i$，从其面积上均匀分布的点发射 $N_i$ 条射线，其方向从围绕该表面内向法线的余弦加权半球中独立抽取。射线的首次相交点决定了其击中的表面 $j$ 或逃逸事件。\n- 通过从 $i$ 发射的采样射线中首次击中 $j$ 的射线所占的比例来估算 $F_{ij}$，并通过穿过顶部孔径逃逸的射线所占的比例来估算 $F_{i,\\mathrm{esc}}$。\n\n您必须：\n- 计算估算的内表面间角系数矩阵 $\\{F_{ij}\\}$ 和逃逸系数 $\\{F_{i,\\mathrm{esc}}\\}$。\n- 计算最大互易性偏差 $\\max_{i<j} |A_i F_{ij} - A_j F_{ji}|$ 和最大能量平衡偏差 $\\max_i |\\sum_j F_{ij} + F_{i,\\mathrm{esc}} - 1|$。\n- 将这些偏差与预设的容差进行比较，以确定您的蒙特卡洛模拟是否通过了对这些基本物理原理的验证。\n- 针对下表中定义的三个测试用例运行您的模拟。将每个用例的结果（一个包含两个布尔值和两个浮点数的数组）收集到一个列表中。",
            "solution": "该问题的解决方案是实现一个蒙特卡洛射线追踪算法来估算角系数。算法的核心步骤如下：\n\n1.  **几何定义与预计算**：\n    *   首先，定义棱柱腔体的几何形状，包括底面多边形的顶点和腔体的高度。\n    *   计算每个内表面（底面和各个侧壁）的面积 $A_i$。底面面积可通过鞋带公式计算，侧壁面积为边长乘以高度。\n    *   计算每个面的内向法线向量 $\\mathbf{n}_i$。\n\n2.  **蒙特卡洛射线发射**：\n    *   对于每个源表面 $i$，发射大量的蒙特卡洛粒子（射线），总数为 $N_i$。\n    *   **发射点**：在表面 $i$ 上随机均匀地选择每个粒子的起始位置。对于多边形底面，可以通过将其三角化并在随机选择的三角形内使用重心坐标来采样。对于矩形侧壁，可以在两个维度上使用均匀随机数。\n    *   **发射方向**：根据朗伯余弦定律随机生成每个粒子的发射方向。这可以通过在局部坐标系中生成方向向量 $(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)$，其中 $\\phi$ 在 $[0, 2\\pi]$ 上均匀分布，而 $\\theta$ 的分布满足 $P(\\theta) \\propto \\sin\\theta\\cos\\theta$，然后将该向量转换到全局坐标系。\n\n3.  **射线追踪与相交测试**：\n    *   对于每条发射的射线，计算其与腔体所有其他内表面以及顶部开口平面的交点。\n    *   射线与每个平面（由法线和一点定义）的交点可以通过求解线性方程得到。\n    *   在所有可能的交点中，选择具有最小正飞行距离（时间）的那个，即首次相交点。\n    *   判断该交点是否落在对应表面或开口的边界之内。对于侧壁，是检查z坐标是否在 $[0, H]$ 范围内；对于底面和开口，是执行一个点在多边形内的测试。\n\n4.  **统计与计算**：\n    *   记录从每个源表面 $i$ 发射并首次击中目标表面 $j$ 的射线数量 $N_{ij}$。同时记录逃逸到开口的射线数量 $N_{i,\\mathrm{esc}}$。\n    *   角系数 $F_{ij}$ 通过比率 $N_{ij} / N_i$ 估算。\n    *   逃逸系数 $F_{i,\\mathrm{esc}}$ 通过比率 $N_{i,\\mathrm{esc}} / N_i$ 估算。\n\n5.  **验证**：\n    *   **互易性验证**：计算最大互易性偏差 $\\max_{i<j} |A_i F_{ij} - A_j F_{ji}|$。\n    *   **能量平衡验证**：对于每个源表面 $i$，计算其角系数与逃逸系数之和，然后计算与1的最大偏差 $\\max_i |\\sum_j F_{ij} + F_{i,\\mathrm{esc}} - 1|$。\n    *   将这些计算出的偏差与给定的容差进行比较，以确定模拟是否通过了验证。\n\n通过执行这些步骤，我们可以数值化地求解复杂几何中的粒子输运问题，并验证其是否符合基本的物理守恒定律。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Monte Carlo view factor calculation.\n    \"\"\"\n    \n    # Set a seed for reproducibility of random numbers.\n    np.random.seed(42)\n\n    def solve_case(vertices, H, N, recip_tol, balance_tol):\n        \"\"\"\n        Solves a single test case for view factor estimation and verification.\n\n        Args:\n            vertices (list): A list of (x, y) tuples defining the convex polygon base in CCW order.\n            H (float): The height of the prismatic cavity.\n            N (int): The number of Monte Carlo samples (rays) to emit from each facet.\n            recip_tol (float): The tolerance for the reciprocity check.\n            balance_tol (float): The tolerance for the energy balance check.\n\n        Returns:\n            list: A list containing [reciprocity_pass, energy_balance_pass, max_reciprocity_dev, max_energy_balance_dev].\n        \"\"\"\n        n_verts = len(vertices)\n        num_facets = n_verts + 1\n\n        # --- 1. Geometry Pre-computation ---\n        verts_3d = [np.array([v[0], v[1], 0.0]) for v in vertices]\n        verts_xy = [np.array(v) for v in vertices]\n\n        areas = np.zeros(num_facets)\n        # Area of bottom (Facet 0) via shoelace formula\n        shoelace_sum = sum(verts_xy[i][0] * verts_xy[(i + 1) % n_verts][1] - \n                           verts_xy[(i + 1) % n_verts][0] * verts_xy[i][1] for i in range(n_verts))\n        areas[0] = 0.5 * abs(shoelace_sum)\n\n        # Areas of side walls (Facets 1 to n)\n        for i in range(n_verts):\n            edge_len = np.linalg.norm(verts_3d[(i + 1) % n_verts] - verts_3d[i])\n            areas[i + 1] = edge_len * H\n\n        normals = np.zeros((num_facets, 3))\n        normals[0] = np.array([0., 0., 1.])\n        side_facet_origins = []\n        for i in range(n_verts):\n            p1 = verts_xy[i]\n            p2 = verts_xy[(i + 1) % n_verts]\n            edge_vec = p2 - p1\n            norm_2d = np.array([-edge_vec[1], edge_vec[0]])\n            normals[i + 1] = np.array([norm_2d[0], norm_2d[1], 0.])\n            normals[i + 1] /= np.linalg.norm(normals[i + 1])\n            side_facet_origins.append(verts_3d[i])\n\n        # Pre-calculate triangulation of the base polygon for sampling.\n        # Triangulation from centroid is robust for convex polygons.\n        centroid = sum(verts_xy) / n_verts\n        triangles = []\n        tri_areas = []\n        for i in range(n_verts):\n            p0, p1, p2 = centroid, verts_xy[i], verts_xy[(i + 1) % n_verts]\n            triangles.append((p0, p1, p2))\n            tri_areas.append(0.5 * abs(p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]) + p0[0]*(p1[1]-p2[1])))\n        tri_probs = np.array(tri_areas) / sum(tri_areas)\n\n        # --- 2. Monte Carlo Simulation ---\n        counts = np.zeros((num_facets, num_facets), dtype=int)\n        escapes = np.zeros(num_facets, dtype=int)\n        epsilon = 1e-12\n\n        for i in range(num_facets):  # Loop over source facets\n            n_i = normals[i]\n            \n            # Create transformation matrix for Lambertian direction generation\n            if abs(n_i[2]) > 1.0 - epsilon: # Normal is (0,0,+-1)\n                t_i = np.array([1., 0., 0.])\n            else:\n                u_vec = np.array([0., 0., 1.])\n                t_i = np.cross(u_vec, n_i)\n                t_i /= np.linalg.norm(t_i)\n            b_i = np.cross(n_i, t_i)\n            transform_matrix = np.array([t_i, b_i, n_i]).T\n\n            # Generate N rays at once for efficiency\n            rand_nums = np.random.rand(N, 4) # For point and direction\n            \n            # Generate origins (p)\n            if i == 0:  # Source is bottom facet\n                tri_indices = np.random.choice(len(triangles), size=N, p=tri_probs)\n                p0_s, p1_s, p2_s = np.array([triangles[idx] for idx in tri_indices]).transpose((1,0,2))\n                sqrt_r1 = np.sqrt(rand_nums[:,0])\n                p_xy = (1 - sqrt_r1)[:, np.newaxis] * p0_s + \\\n                       (sqrt_r1 * (1 - rand_nums[:,1]))[:, np.newaxis] * p1_s + \\\n                       (sqrt_r1 * rand_nums[:,1])[:, np.newaxis] * p2_s\n                origins = np.hstack([p_xy, np.zeros((N,1))])\n            else:  # Source is a side facet\n                facet_idx = i - 1\n                p1_base = verts_3d[facet_idx]\n                p2_base = verts_3d[(facet_idx + 1) % n_verts]\n                origins = p1_base + rand_nums[:,0,np.newaxis] * (p2_base - p1_base)\n                origins[:, 2] = rand_nums[:,1] * H\n            \n            # Generate Lambertian directions (d)\n            phi = 2 * np.pi * rand_nums[:,2]\n            r2 = rand_nums[:,3]\n            cos_theta, sin_theta = np.sqrt(1 - r2), np.sqrt(r2)\n            d_local_x = sin_theta * np.cos(phi)\n            d_local_y = sin_theta * np.sin(phi)\n            d_local_z = cos_theta\n            \n            d_local = np.vstack([d_local_x, d_local_y, d_local_z])\n            directions = (transform_matrix @ d_local).T\n\n            for k in range(N): # Trace each ray\n                p, d = origins[k], directions[k]\n                \n                min_t = np.inf\n                hit_facet_idx = -1  # -1 for escape\n\n                # Check for escape\n                if d[2] > epsilon:\n                    t = (H - p[2]) / d[2]\n                    if t > epsilon:\n                        pt = p + t * d\n                        # Point-in-polygon test\n                        if all(np.cross(verts_xy[(j + 1) % n_verts] - verts_xy[j], pt[:2] - verts_xy[j]) >= -epsilon for j in range(n_verts)):\n                            min_t, hit_facet_idx = t, -1\n\n                # Check hits on internal facets\n                for j in range(num_facets):\n                    n_j = normals[j]\n                    denom = np.dot(d, n_j)\n                    \n                    if abs(denom) > epsilon:\n                        if j == 0: # Bottom facet\n                           t = -p[2] / d[2]\n                        else: # Side facet\n                           t = np.dot(side_facet_origins[j-1] - p, n_j) / denom\n\n                        if epsilon < t < min_t:\n                            pt = p + t * d\n                            \n                            is_in_bounds = False\n                            if j == 0: # Bottom facet\n                                if all(np.cross(verts_xy[(m + 1) % n_verts] - verts_xy[m], pt[:2] - verts_xy[m]) >= -epsilon for m in range(n_verts)):\n                                    is_in_bounds = True\n                            else: # Side facet\n                                if 0.0 - epsilon <= pt[2] <= H + epsilon:\n                                    is_in_bounds = True\n                            \n                            if is_in_bounds:\n                                min_t, hit_facet_idx = t, j\n                \n                if hit_facet_idx == -1: escapes[i] += 1\n                elif hit_facet_idx != i: counts[i, hit_facet_idx] += 1\n                else: # Self-hit, should not happen for flat surfaces, re-assign\n                    escapes[i] += N - (np.sum(counts[i]) + escapes[i])\n                    break\n            \n            # Ensure all rays are counted\n            total_counted = np.sum(counts[i]) + escapes[i]\n            if total_counted != N:\n                escapes[i] += N - total_counted\n\n\n        # --- 3. Compute View Factors and Deviations ---\n        F = counts / N\n        F_esc = escapes / N\n\n        max_recip_dev = 0.0\n        for r in range(num_facets):\n            for c in range(r + 1, num_facets):\n                dev = abs(areas[r] * F[r, c] - areas[c] * F[c, r])\n                if dev > max_recip_dev:\n                    max_recip_dev = dev\n        \n        max_balance_dev = 0.0\n        for r in range(num_facets):\n            dev = abs(np.sum(F[r, :]) + F_esc[r] - 1.0)\n            if dev > max_balance_dev:\n                max_balance_dev = dev\n        \n        recip_pass = max_recip_dev <= recip_tol\n        balance_pass = max_balance_dev <= balance_tol\n\n        return [recip_pass, balance_pass, float(max_recip_dev), float(max_balance_dev)]\n\n    # --- Test Suite Definition ---\n    L_1 = 1.0e-6\n    test_case_1 = {\n        \"vertices\": [(0, 0), (L_1, 0), (L_1, L_1), (0, L_1)],\n        \"H\": 1.0e-6,\n        \"N\": 6000\n    }\n\n    W_2, L_2 = 2.0e-7, 1.0e-6\n    test_case_2 = {\n        \"vertices\": [(0, 0), (W_2, 0), (W_2, L_2), (0, L_2)],\n        \"H\": 1.5e-6,\n        \"N\": 8000\n    }\n    \n    S_3 = 1.0e-6\n    test_case_3 = {\n        \"vertices\": [(0, 0), (S_3, 0), (S_3/2, (math.sqrt(3)/2)*S_3)],\n        \"H\": 0.7e-6,\n        \"N\": 6000\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3]\n    tolerances = {\"recip_tol\": 4.0e-2, \"balance_tol\": 2.0e-2}\n\n    results = []\n    for case in test_cases:\n        res = solve_case(case[\"vertices\"], case[\"H\"], case[\"N\"], **tolerances)\n        results.append(res)\n\n    # --- Final Output Formatting ---\n    result_strings = []\n    for res in results:\n        # Convert bool to lowercase 'true'/'false' as common in data formats\n        b1_str = str(res[0]).lower()\n        b2_str = str(res[1]).lower()\n        result_strings.append(f\"[{b1_str},{b2_str},{res[2]},{res[3]}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}