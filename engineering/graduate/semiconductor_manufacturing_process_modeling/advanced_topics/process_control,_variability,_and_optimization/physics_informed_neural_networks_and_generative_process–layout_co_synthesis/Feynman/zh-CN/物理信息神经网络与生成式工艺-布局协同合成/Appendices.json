{
    "hands_on_practices": [
        {
            "introduction": "在构建任何复杂的神经网络模型之前，首要且关键的一步是深入理解并恰当地表述其背后的物理学。本练习  将指导您对化学机械平坦化（CMP）过程进行量纲分析，这是一个从第一性原理出发的经典实践。通过从Navier-Stokes方程中推导出关键的无量纲数，您将掌握一项核心技能：如何将一个复杂的物理问题进行规范化，从而为构建稳健且高效的物理信息神经网络（PINN）代理模型奠定基础。",
            "id": "4152003",
            "problem": "一个半导体制造团队正在使用化学机械平坦化（CMP）技术在铜大马士革工艺中实现平坦表面。研磨浆可以很好地近似为牛顿不可压缩流体，其密度为 $\\rho$，动力粘度为 $\\mu$，并被限制在抛光垫和晶圆之间厚度为 $h$ 的均匀间隙中。一个生成式工艺-版图协同综合引擎提出了一种晶圆上的重复性特征图案，其特征横向长度尺度为 $\\ell$，填充因子为 $\\phi$。工具的运动学在单个特征上，于抛光垫-晶圆界面处产生特征切向滑移速度 $U$。该团队计划将一个物理信息神经网络（PINN）嵌入协同综合循环中，以根据给定的 $(\\rho,\\mu,h,\\ell,U,k_{p},\\phi)$ 预测压力 $p$、界面剪切应力 $\\tau$ 和材料去除率 $R$，其中 $k_{p}$ 是CMP去除关系中的Preston系数。\n\n从牛顿流体的不可压缩Navier–Stokes方程和连续性方程出发，并采用以下基本假设：纵横比 $\\epsilon=h/\\ell$ 很小（润滑状态），界面速度尺度为 $U$，且材料去除遵循Preston关系 $R=k_{p}\\,p\\,U$。请进行一次量纲分析，以适用于PINN兼容的无量纲化。您的目标是：\n- 使用第一性原理标度分析，用 $(\\rho,\\mu,h,\\ell,U,k_{p})$ 来确定 $p$、$\\tau$ 和 $R$ 的特征量级。\n- 构建一个最小集合，包含3个无量纲群，用于控制润滑流条件下的压力、剪切应力和去除率的量级。\n- 在轴向动量平衡中，确定用于量化惯性效应与粘性效应之比的主导阶小参数，并用 $(\\rho,\\mu,h,\\ell,U)$ 将其表示为无量纲表达式。\n- 除润滑排序外，不要假设存在对称性，并且除了Preston关系外，不要引用其他经验性流体动力学公式。解释纵横比 $\\epsilon$ 如何进入惯性-粘性比较。\n\n您的最终答案必须是一个单行矩阵，按顺序包含您为压力、剪切应力和去除率定义的3个无量纲群，以及证明在润滑排序下可忽略惯性项的单个无量纲参数。请将最终答案表示为闭式解析表达式。您答案中的量必须是无量纲的，最终答案无需单位。",
            "solution": "我们从牛顿流体的不可压缩Navier–Stokes方程和连续性方程开始。用 $x$ 表示沿晶圆表面的横向坐标，用 $z$ 表示垂直于晶圆的法向坐标。方程为\n$$\n\\rho \\left( \\frac{\\partial \\mathbf{v}}{\\partial t} + \\mathbf{v}\\cdot\\nabla \\mathbf{v} \\right) = -\\nabla p + \\mu \\nabla^{2} \\mathbf{v}, \\quad \\nabla \\cdot \\mathbf{v} = 0,\n$$\n其中 $\\mathbf{v}=(u,w)$ 分别是横向和法向速度分量。\n\n我们假设系统处于稳态操作，因此在平均时间尺度上 $\\partial \\mathbf{v}/\\partial t$ 可以忽略不计。我们采用润滑状态，其纵横比 $\\epsilon=h/\\ell \\ll 1$，其中 $h$ 是间隙厚度，$\\ell$ 是由生成式版图综合设定的横向长度尺度。设 $U$ 为界面处的特征横向滑移速度。根据细长间隙中的连续性，法向速度尺度被纵横比抑制，得到\n$$\nu \\sim U, \\quad w \\sim U \\frac{h}{\\ell} = U \\epsilon.\n$$\n\n现在我们根据 $x \\sim \\ell$ 和 $z \\sim h$ 对导数进行标度分析，因此 $\\partial/\\partial x \\sim 1/\\ell$ 且 $\\partial/\\partial z \\sim 1/h$。考虑轴向（$x$）动量方程的主导阶。主导粘性项来自于关于 $z$ 的二阶导数，而在润滑流中，$x$ 方向的压力梯度与该粘性应力相平衡：\n$$\n\\text{粘性项: } \\mu \\frac{\\partial^{2} u}{\\partial z^{2}} \\sim \\mu \\frac{U}{h^{2}}, \\quad \\text{压力梯度: } \\frac{\\partial p}{\\partial x} \\sim \\frac{p}{\\ell}.\n$$\n平衡这两项，得到特征压力尺度\n$$\n\\frac{p}{\\ell} \\sim \\mu \\frac{U}{h^{2}} \\quad \\Rightarrow \\quad p \\sim \\mu U \\frac{\\ell}{h^{2}}.\n$$\n界面剪切应力由壁面处的粘性梯度决定，\n$$\n\\tau \\sim \\mu \\frac{\\partial u}{\\partial z} \\sim \\mu \\frac{U}{h}.\n$$\n对于材料去除率，我们采用Preston关系，这是CMP在工艺尺度上一个经过充分检验的经验定律，\n$$\nR = k_{p} \\, p \\, U,\n$$\n因此，特征去除率尺度为\n$$\nR \\sim k_{p} \\left( \\mu U \\frac{\\ell}{h^{2}} \\right) U = k_{p} \\mu U^{2} \\frac{\\ell}{h^{2}}.\n$$\n\n为了生成适用于PINN的无量纲变量，我们用各自的特征尺度对每个场进行归一化：\n- 通过 $p = \\left( \\mu U \\ell / h^{2} \\right) p^{\\ast}$ 定义无量纲压力 $p^{\\ast}$。等效地，控制压力的无量纲群是\n$$\n\\Pi_{p} \\equiv \\frac{p h^{2}}{\\mu U \\ell}.\n$$\n- 通过 $\\tau = \\left( \\mu U / h \\right) \\tau^{\\ast}$ 定义无量纲剪切应力 $\\tau^{\\ast}$。等效地，控制剪切应力的无量纲群是\n$$\n\\Pi_{\\tau} \\equiv \\frac{\\tau h}{\\mu U}.\n$$\n- 通过 $R = \\left( k_{p} \\mu U^{2} \\ell / h^{2} \\right) R^{\\ast}$ 定义无量纲去除率 $R^{\\ast}$。等效地，控制去除率的无量纲群是\n$$\n\\Pi_{R} \\equiv \\frac{R h^{2}}{k_{p} \\mu U^{2} \\ell}.\n$$\n\n接下来，我们通过比较轴向动量平衡中的惯性项和粘性项来证明忽略惯性项的合理性。对流惯性项的尺度为\n$$\n\\rho \\, u \\frac{\\partial u}{\\partial x} \\sim \\rho \\, U \\frac{U}{\\ell} = \\rho \\frac{U^{2}}{\\ell},\n$$\n而主导粘性项的尺度为\n$$\n\\mu \\frac{\\partial^{2} u}{\\partial z^{2}} \\sim \\mu \\frac{U}{h^{2}}.\n$$\n因此，轴向动量方程中惯性效应与粘性效应之比为\n$$\n\\frac{\\text{惯性}}{\\text{粘性}} \\sim \\frac{\\rho \\, U^{2} / \\ell}{\\mu \\, U / h^{2}} = \\frac{\\rho U h^{2}}{\\mu \\ell}.\n$$\n定义相应的无量纲小参数\n$$\n\\Pi_{I} \\equiv \\frac{\\rho U h^{2}}{\\mu \\ell}.\n$$\n该参数可以写成 $\\Pi_{I} = \\left( \\rho U h / \\mu \\right) \\left( h / \\ell \\right)$，它是基于间隙 $h$ 的雷诺数与纵横比 $\\epsilon$ 的乘积。因为 $\\epsilon \\ll 1$，即使 $\\rho U h / \\mu$ 取中等值，也会导致 $\\Pi_{I} \\ll 1$，这证明了在润滑排序中忽略惯性项是合理的。在物理信息神经网络的背景下，使用与 $\\Pi_{p}$、$\\Pi_{\\tau}$ 和 $\\Pi_{R}$ 相关的无量纲变量可以确保残差量级的平衡，而 $\\Pi_{I}$ 则量化了PINN应强制执行斯托克斯-润滑动力学的适用范围。\n\n汇总结果，控制压力、剪切应力和去除率的3个最小无量纲群集合，以及用于惯性项的单个无量纲参数为\n$$\n\\Pi_{p} = \\frac{p h^{2}}{\\mu U \\ell}, \\quad \\Pi_{\\tau} = \\frac{\\tau h}{\\mu U}, \\quad \\Pi_{R} = \\frac{R h^{2}}{k_{p} \\mu U^{2} \\ell}, \\quad \\Pi_{I} = \\frac{\\rho U h^{2}}{\\mu \\ell}.\n$$\n这些无量纲群直接源于经过充分检验的不可压缩Navier–Stokes方程的润滑标度分析和Preston关系，它们通过由版图和工具运动学决定的 $\\ell$ 和 $U$ 的出现，提供了一种有原则的PINN无量纲化方法和一个生成式工艺-版图协同综合的联系。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{p h^{2}}{\\mu U \\ell} & \\frac{\\tau h}{\\mu U} & \\frac{R h^{2}}{k_{p} \\mu U^{2} \\ell} & \\frac{\\rho U h^{2}}{\\mu \\ell}\\end{pmatrix}}$$"
        },
        {
            "introduction": "物理定律的数学形式有时会给基于梯度的优化算法带来数值计算上的挑战。本练习  聚焦于一个在PINN训练中普遍存在的问题：当控制方程中包含绝对值或范数等非光滑算子时，会导致梯度未定义或不稳定。通过一个各向异性刻蚀模型的具体案例，您将学习如何识别这些问题，并构造和应用光滑的代理函数（smooth surrogate functions）来解决它们，这对于确保PINN优化的稳定性和收敛性至关重要。",
            "id": "4152045",
            "problem": "在半导体制造中，一个物理信息神经网络（PINN）被用于生成式工艺-布局协同合成，以联合优化掩模版图和刻蚀工艺条件，从而产生目标沟槽轮廓。演化中的沟槽界面由一个水平集函数 $\\phi(x,y,t)$ 表示，其中界面是零水平集 $\\{\\phi=0\\}$。各向异性等离子体刻蚀的法向速度定律被设为 $V(\\mathbf{n}) = V_0 \\left(1 + a\\,|\\cos\\theta|\\right)$，其中 $\\mathbf{n} = \\nabla \\phi / \\|\\nabla \\phi\\|$ 是单位法向量，$\\theta$ 是 $\\mathbf{n}$ 与垂直方向 $\\mathbf{e}_y$ 之间的夹角，$V_0 > 0$ 是一个特征刻蚀速率，$a \\in [0,1]$ 表征了各向异性强度。以法向速度 $V$ 移动的水平集的运动学演化定律导出了以下控制方程\n$$\n\\partial_t \\phi + V(\\mathbf{n})\\,\\|\\nabla \\phi\\| = 0,\n$$\n并附有从掩模版和晶圆堆叠几何形状导出的相应初始和边界条件。一个生成器网络 $\\mathcal{G}_\\theta(z)$ 产生初始的有符号距离掩模版图 $\\phi(x,y,0)$ 和工艺参数（例如 $a$），而一个PINN $\\phi_\\theta(x,y,t)$ 则近似该问题的解。用于物理信息损失的残差为\n$$\n\\mathcal{R}(x,y,t) = \\partial_t \\phi_\\theta(x,y,t) + V_0\\left(1 + a\\,\\left|\\frac{\\nabla\\phi_\\theta(x,y,t)}{\\|\\nabla\\phi_\\theta(x,y,t)\\|}\\cdot \\mathbf{e}_y\\right|\\right)\\,\\|\\nabla \\phi_\\theta(x,y,t)\\|.\n$$\n自动微分 (AD) 计算残差相对于网络参数的梯度。然而，该残差包含非光滑操作：模 $\\|\\nabla \\phi_\\theta\\|$ 和应用于 $\\cos\\theta = \\mathbf{n}\\cdot\\mathbf{e}_y$ 的绝对值 $|\\cdot|$。当 $\\|\\nabla\\phi_\\theta\\|\\to 0$ 或在掠射角处 $\\cos\\theta \\to 0$ 时，这些操作会使AD不稳定，因为其导数涉及除以一个很小的量或未定义的次梯度。\n\n从水平集运动学定律和单位法向量的定义出发，分析残差中的非光滑性如何产生病态的AD梯度。然后，选择一个选项，该选项提供一个科学上合理、物理上一致且可微的代理函数，该代理函数能在恢复光滑性的同时控制近似误差，并解释其为何能稳定训练。该代理函数必须保持关于符号的对称性（因此反转法向不会改变速率大小），在平滑参数趋于 $0$ 时保留正确的极限行为，并为AD产生有界导数。\n\n哪个选项是正确的？\n\nA. 将残差中所有出现的 $|x|$ 替换为光滑代理 $\\sqrt{x^2 + \\varepsilon^2}$（其中 $\\varepsilon>0$），并将 $\\|\\nabla\\phi_\\theta\\|$ 替换为 $\\sqrt{\\|\\nabla\\phi_\\theta\\|^2 + \\varepsilon^2}$。然后 $\\cos\\theta$ 被计算为 $\\left(\\nabla\\phi_\\theta\\cdot\\mathbf{e}_y\\right)/\\sqrt{\\|\\nabla\\phi_\\theta\\|^2 + \\varepsilon^2}$，其绝对值被一个小的 $\\delta>0$ 近似为 $\\sqrt{\\left(\\left(\\nabla\\phi_\\theta\\cdot\\mathbf{e}_y\\right)/\\sqrt{\\|\\nabla\\phi_\\theta\\|^2 + \\varepsilon^2}\\right)^2 + \\delta^2}$。这产生的AD导数 $x/\\sqrt{x^2+\\varepsilon^2}$ 和 $\\nabla\\phi_\\theta/\\sqrt{\\|\\nabla\\phi_\\theta\\|^2+\\varepsilon^2}$ 的模以 $1$ 为界，消除了在 $\\|\\nabla\\phi_\\theta\\|\\approx 0$ 附近除以 $\\|\\nabla\\phi_\\theta\\|$ 的操作，保持了对称性，并以在 $x$ 上一致的 $O(\\varepsilon)$ 误差近似原始残差。一个针对 $\\varepsilon$ 和 $\\delta$ 的退火方案（从一个初始值减小到 $0$）可以在早期限制偏差，并在后期恢复尖锐模型。\n\nB. 将残差中的 $|x|$ 替换为 $x^2$，并保持 $\\|\\nabla\\phi_\\theta\\|$ 不变。这使得残差光滑并移除了不可微性，同时由于 $x^2$ 和 $|x|$ 都是非负的，因此保留了原始物理。当 $\\|\\nabla\\phi_\\theta\\|\\to 0$ 时，AD无需进一步修改即可保持稳定。\n\nC. 保持残差不变，但通过 $|x|$ 为AD定义 $\\operatorname{sign}(0)=0$，并将梯度 $\\nabla\\phi_\\theta$ 裁剪至使其模至少为一个小的常数 $\\eta>0$。这使得残差在实现上可微，并避免了在单位法向量中除以 $0$ 的情况，且不引入近似偏差。\n\nD. 将 $|x|$ 替换为修正线性单元 $\\max(0,x)$，并将 $\\|\\nabla\\phi_\\theta\\|$ 替换为 $\\max\\left(0,\\|\\nabla\\phi_\\theta\\|\\right)$。这移除了不可微性并确保了非负的速度。因为 $\\max(\\cdot,\\cdot)$ 是分段线性的，所以AD导数在各区域内是常数，训练变得更稳定，且不影响物理对称性。",
            "solution": "用户希望我验证并解决一个关于在半导体工艺建模中使用的物理信息神经网络（PINN）的自动微分（AD）稳定性的问题。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n- **系统：** 一个PINN，$\\phi_\\theta(x,y,t)$，用于模拟半导体制造中沟槽轮廓的演化。\n- **物理模型：** 沟槽界面是函数 $\\phi(x,y,t)$ 的零水平集，该函数根据水平集方程演化。\n- **控制方程：** $\\partial_t \\phi + V(\\mathbf{n})\\,\\|\\nabla \\phi\\| = 0$。\n- **法向速度定律：** $V(\\mathbf{n}) = V_0 \\left(1 + a\\,|\\cos\\theta|\\right)$。\n- **定义：**\n    - $\\mathbf{n} = \\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|}$ 是水平集的单位法向量。\n    - $\\theta$ 是 $\\mathbf{n}$ 与垂直方向 $\\mathbf{e}_y$ 之间的夹角，所以 $\\cos\\theta = \\mathbf{n} \\cdot \\mathbf{e}_y$。\n    - $V_0 > 0$ 是一个特征刻蚀速率。\n    - $a \\in [0,1]$ 是各向异性强度。\n- **PINN残差：** PINN损失函数的残差由下式给出：\n$$\n\\mathcal{R}(x,y,t) = \\partial_t \\phi_\\theta(x,y,t) + V_0\\left(1 + a\\,\\left|\\frac{\\nabla\\phi_\\theta(x,y,t)}{\\|\\nabla\\phi_\\theta(x,y,t)\\|}\\cdot \\mathbf{e}_y\\right|\\right)\\,\\|\\nabla \\phi_\\theta(x,y,t)\\|.\n$$\n- **已识别问题：** 残差 $\\mathcal{R}$ 包含非光滑操作：欧几里得范数 $\\|\\nabla\\phi_\\theta\\|$ 和绝对值 $|\\cdot|$。当它们的自变量趋近于零时，这些操作会导致AD不稳定。具体来说，$\\sqrt{u}$ 相对于 $u$ 的梯度是 $\\frac{1}{2\\sqrt{u}}$，当 $u \\to 0$ 时发散。$|x|$ 的导数在 $x=0$ 处不连续。\n- **任务：** 选择一个为非光滑残差提出科学上合理、物理上一致且可微的代理函数的选项。该代理函数必须：\n    1.  为稳定的AD恢复光滑性。\n    2.  控制近似误差。\n    3.  保持对称性（当 $\\mathbf{n} \\to -\\mathbf{n}$ 时，速率大小不变）。\n    4.  在平滑参数趋于 $0$ 时，保留正确的极限行为。\n    5.  产生有界导数。\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学基础：** 该问题在计算物理学和机器学习方面有坚实的基础。水平集方法是追踪移动界面的标准技术。PINN是求解微分方程的一种现代方法。其在半导体刻蚀模拟中的应用是一个成熟的研究领域。速度定律是用于各向异性等离子体刻蚀的一个物理上合理的模型。该问题在科学上是合理的。\n- **适定性：** 该问题要求在一组清晰的约束条件下，找到一个合适的数学修改（一个代理函数）来解决一个明确定义的计算问题（AD中的不可微性）。这是一个适定问题。\n- **客观性：** 该问题使用精确、客观的数学和计算术语进行陈述。没有主观因素。\n\n**第三步：结论与行动**\n\n问题陈述是有效的。它在科学上合理、适定且客观。我将继续进行解法推导和选项分析。\n\n### 推导与分析\n\n首先，我们来分析残差 $\\mathcal{R}$ 的结构。对于 $\\|\\nabla\\phi_\\theta\\| \\neq 0$ 的情况，我们可以简化该表达式：\n$$\n\\begin{aligned}\n\\mathcal{R}(x,y,t) = \\partial_t \\phi_\\theta + V_0\\left(1 + a\\,\\frac{|\\nabla\\phi_\\theta\\cdot \\mathbf{e}_y|}{\\|\\nabla\\phi_\\theta\\|}\\right)\\,\\|\\nabla \\phi_\\theta\\| \\\\\n= \\partial_t \\phi_\\theta + V_0\\left(\\|\\nabla \\phi_\\theta\\| + a\\,|\\nabla\\phi_\\theta\\cdot \\mathbf{e}_y|\\right) \\\\\n= \\partial_t \\phi_\\theta + V_0\\left(\\sqrt{(\\partial_x\\phi_\\theta)^2 + (\\partial_y\\phi_\\theta)^2} + a\\,|\\partial_y\\phi_\\theta|\\right)\n\\end{aligned}\n$$\n这个简化形式清楚地显示了不可微性的两个来源：\n1.  欧几里得范数 $\\|\\nabla\\phi_\\theta\\| = \\sqrt{(\\partial_x\\phi_\\theta)^2 + (\\partial_y\\phi_\\theta)^2}$，当 $\\nabla\\phi_\\theta = \\mathbf{0}$ 时不可微。\n2.  绝对值 $|\\partial_y\\phi_\\theta|$，当 $\\partial_y\\phi_\\theta = 0$ 时不可微。\n\n目标是用满足给定约束的光滑代理函数替换这些非光滑函数。对于 $|x|$ 和 $\\sqrt{u}$（当 $u \\ge 0$），一个广泛使用且有效的代理是基于函数 $f(z) = \\sqrt{z + \\varepsilon^2}$，其中 $\\varepsilon$ 是一个小的正平滑参数。\n\n- 对于绝对值 $|x| = \\sqrt{x^2}$，代理函数是 $\\sqrt{x^2 + \\varepsilon^2}$。\n- 对于范数 $\\|\\mathbf{v}\\| = \\sqrt{\\|\\mathbf{v}\\|^2}$，代理函数是 $\\sqrt{\\|\\mathbf{v}\\|^2 + \\varepsilon^2}$。\n\n我们来检查这种类型的代理函数是否满足要求：\n1.  **可微性：** 函数 $s(x) = \\sqrt{x^2 + \\varepsilon^2}$ 对于任何 $\\varepsilon > 0$ 都是无限可微的。其导数是 $s'(x) = \\frac{x}{\\sqrt{x^2 + \\varepsilon^2}}$。\n2.  **有界导数：** 该导数的模 $|s'(x)| = \\frac{|x|}{\\sqrt{x^2 + \\varepsilon^2}} < 1$。这对稳定AD至关重要，因为它能防止梯度爆炸。类似地，$\\sqrt{\\|\\mathbf{v}\\|^2 + \\varepsilon^2}$ 相对于 $\\mathbf{v}$ 的梯度是 $\\frac{\\mathbf{v}}{\\sqrt{\\|\\mathbf{v}\\|^2 + \\varepsilon^2}}$，其模小于 $1$。\n3.  **对称性：** 绝对值的代理函数 $\\sqrt{x^2 + \\varepsilon^2}$ 是一个偶函数，即 $\\sqrt{(-x)^2 + \\varepsilon^2} = \\sqrt{x^2 + \\varepsilon^2}$。这保持了物理对称性，即刻蚀速率取决于 $|\\cos\\theta|$ 而非 $\\cos\\theta$ 的符号。\n4.  **极限行为：** 当 $\\varepsilon \\to 0$ 时，$\\sqrt{x^2 + \\varepsilon^2} \\to \\sqrt{x^2} = |x|$。代理函数正确地收敛于原始函数。\n5.  **近似误差：** 误差为 $|\\sqrt{x^2 + \\varepsilon^2} - |x||$。根据反三角不等式， $|\\sqrt{x^2+\\varepsilon^2} - \\sqrt{x^2}| \\le \\sqrt{(x-x)^2 + (\\varepsilon-0)^2} = \\varepsilon$。误差被 $\\varepsilon$ 一致地界定。\n\n这证实了使用形式为 $\\sqrt{\\cdot^2 + \\varepsilon^2}$ 的代理函数是一种有原则且有效的方法。我们现在将基于这一理解来评估每个选项。\n\n### 逐项分析\n\n**A. 将残差中所有出现的 $|x|$ 替换为光滑代理 $\\sqrt{x^2 + \\varepsilon^2}$（其中 $\\varepsilon>0$），并将 $\\|\\nabla\\phi_\\theta\\|$ 替换为 $\\sqrt{\\|\\nabla\\phi_\\theta\\|^2 + \\varepsilon^2}$。然后 $\\cos\\theta$ 被计算为 $\\left(\\nabla\\phi_\\theta\\cdot\\mathbf{e}_y\\right)/\\sqrt{\\|\\nabla\\phi_\\theta\\|^2 + \\varepsilon^2}$，其绝对值被一个小的 $\\delta>0$ 近似为 $\\sqrt{\\left(\\left(\\nabla\\phi_\\theta\\cdot\\mathbf{e}_y\\right)/\\sqrt{\\|\\nabla\\phi_\\theta\\|^2 + \\varepsilon^2}\\right)^2 + \\delta^2}$。这产生的AD导数 $x/\\sqrt{x^2+\\varepsilon^2}$ 和 $\\nabla\\phi_\\theta/\\sqrt{\\|\\nabla\\phi_\\theta\\|^2+\\varepsilon^2}$ 的模以 $1$ 为界，消除了在 $\\|\\nabla\\phi_\\theta\\|\\approx 0$ 附近除以 $\\|\\nabla\\phi_\\theta\\|$ 的操作，保持了对称性，并以在 $x$ 上一致的 $O(\\varepsilon)$ 误差近似原始残差。一个针对 $\\varepsilon$ 和 $\\delta$ 的退火方案（从一个初始值减小到 $0$）可以在早期限制偏差，并在后期恢复尖锐模型。**\n\n此选项恰好提出了上述推导的有原则的方法。它系统地正则化了原始、未简化的残差中每个有问题的部分：\n1.  单位法向量 $\\mathbf{n}$ 中的分母被正则化：$\\|\\nabla\\phi_\\theta\\| \\to \\sqrt{\\|\\nabla\\phi_\\theta\\|^2 + \\varepsilon^2}$。这避免了除以零。\n2.  相乘的范数也得到了一致的正则化。\n3.  然后，平滑后的 $\\cos\\theta$ 项的绝对值本身也被正则化：$|\\cdot| \\to \\sqrt{\\cdot^2 + \\delta^2}$。\n最终的表达式是完全可微的，并且如推导所示，代理函数具有有界导数。选项文本中对属性的分析是正确的：它保持了对称性，具有正确的极限，界定了AD梯度，并且误差界也被正确陈述。建议对 $\\varepsilon$ 和 $\\delta$ 使用退火方案是在实践中一种标准且有效的技术，用于在优化过程中平衡稳定性和准确性。\n\n**结论：正确。**\n\n**B. 将残差中的 $|x|$ 替换为 $x^2$，并保持 $\\|\\nabla\\phi_\\theta\\|$ 不变。这使得残差光滑并移除了不可微性，同时由于 $x^2$ 和 $|x|$ 都是非负的，因此保留了原始物理。当 $\\|\\nabla\\phi_\\theta\\|\\to 0$ 时，AD无需进一步修改即可保持稳定。**\n\n此选项有几个缺陷：\n1.  **不完全平滑：** 它建议保持 $\\|\\nabla\\phi_\\theta\\|$ 不变。该项在 $\\nabla\\phi_\\theta=\\mathbf{0}$ 处不可微，因此该提议未能修复问题中指出的两个不稳定来源之一。\n2.  **错误的物理：** 将 $|x|$ 替换为 $x^2$ 并没有“保留原始物理”。它从根本上将模型从 $V \\propto |\\cos\\theta|$ 改变为 $V \\propto (\\cos\\theta)^2$。这是两个不同的物理模型。例如，对于小参数 $|\\cos\\theta| \\ll 1$，原始模型具有线性依赖性，而提议的模型具有二次依赖性。这改变了物理，而不是以可控的方式近似它。\n3.  **无界导数：** $x^2$ 的导数是 $2x$，是无界的。这无助于稳定梯度。\n\n**结论：错误。**\n\n**C. 保持残差不变，但通过 $|x|$ 为AD定义 $\\operatorname{sign}(0)=0$，并将梯度 $\\nabla\\phi_\\theta$ 裁剪至使其模至少为一个小的常数 $\\eta>0$。这使得残差在实现上可微，并避免了在单位法向量中除以 $0$ 的情况，且不引入近似偏差。**\n\n此选项描述了一些有问题的临时数值启发式方法：\n1.  **关于无偏差的错误声明：** 裁剪梯度的模会在所有 $\\|\\nabla\\phi_\\theta\\| < \\eta$ 的点上引入系统误差或偏差。声称这样做“不会引入近似偏差”在事实上是错误的。\n2.  **不完全平滑：** 定义 $\\operatorname{sign}(0)=0$ 仅处理了一个不可微点。损失函数的梯度仍然会有一个阶跃不连续性，从 -1 跳到 +1，这会阻碍基于梯度的优化。此外，裁剪本身在裁剪区域的边界（即 $\\|\\nabla\\phi_\\theta\\| = \\eta$ 处）引入了新的不可微点，这可能导致不稳定。这并不能创建一个光滑的优化景观。\n\n**结论：错误。**\n\n**D. 将 $|x|$ 替换为修正线性单元 $\\max(0,x)$，并将 $\\|\\nabla\\phi_\\theta\\|$ 替换为 $\\max\\left(0,\\|\\nabla\\phi_\\theta\\|\\right)$。这移除了不可微性并确保了非负的速度。因为 $\\max(\\cdot,\\cdot)$ 是分段线性的，所以AD导数在各区域内是常数，训练变得更稳定，且不影响物理对称性。**\n\n此选项有根本性缺陷：\n1.  **破坏物理对称性：** 问题明确要求代理函数保持对称性。函数 $\\max(0,x)$ (ReLU) 不是偶函数。用 $\\max(0, \\cos\\theta)$ 替换 $|\\cos\\theta|$ 意味着对于向上指向的法向量（$\\cos\\theta>0$）刻蚀速率为正，而对于向下指向的法向量（$\\cos\\theta<0$）刻蚀速率为零，这与物理模型相矛盾，在物理模型中，速率取决于角度的大小而非其符号。\n2.  **范数未平滑：** 范数 $\\|\\nabla\\phi_\\theta\\|$ 总是非负的。因此，$\\max(0, \\|\\nabla\\phi_\\theta\\|) \\equiv \\|\\nabla\\phi_\\theta\\|$。这个替换完全没有任何作用，未能解决范数在 $\\nabla\\phi_\\theta=\\mathbf{0}$ 处的不可微性。\n3.  **持续的不可微性：** ReLU 本身在原点处是不可微的。虽然它比符号函数的阶跃不连续性有所改善，但它并不能使残差真正光滑。\n\n**结论：错误。**\n\n基于全面的分析，选项A是唯一一个对所述问题提出了数学上严谨、物理上一致且计算上稳定的解决方案。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "将PINN应用于工业级问题的一个主要障碍是如何处理非局域物理效应，例如光学光刻模型中的卷积运算，其计算成本非常高昂。本动手编程练习  介绍了一种受扩展PINN（XPINN）框架启发的强大解决方案：区域分解法。通过实现一种分块快速傅里叶变换（block-FFT）方法，您将亲身体验如何在计算效率和模型精度之间进行权衡，从而获得将PINN扩展应用于大规模、复杂制造过程的宝贵实践经验。",
            "id": "4152028",
            "problem": "考虑在空间不变非相herent成像近似下，于一维空间中建模的标量光学投影光刻。在此近似中，光程像 $I(x)$ 是掩模版图 $M(x)$ 与强度点扩展函数（光学核）$K(x)$ 的线性卷积，即 $I(x) = (K * M)(x)$。假设归一化空间坐标 $x \\in [0,1)$，在一个包含 $N$ 个点、间距为 $\\Delta x = 1/N$ 的均匀网格上进行离散化。长程光学核由一个物理上合理的、结合了指数和代数衰减的尾部建模，$$K(x) \\propto \\frac{\\exp(-|x|/\\ell)}{1 + (|x|/a)^2},$$ 并被归一化，以使样本的离散和等于$1$。基准光程像 $I_{\\mathrm{true}}$ 定义为通过频域方法在全域上计算的精确线性卷积。为了高效处理 $K(x)$ 的长程特性，您需要实现一种受扩展物理信息神经网络（XPINN）启发的块FFT方法：将域划分为 $S$ 个相等的子域，并对每个子域，使用基于快速傅里叶变换（FFT）的卷积，在一个两侧扩展了 $o$ 个样本重叠的局部窗口上计算卷积。将核截断至半径 $R = \\min\\{o, H\\}$，其中 $H$ 是由核振幅阈值 $\\tau$ 确定的完整核支撑区的半长（以样本数为单位）。通过仅保留每个子域计算的中心（非重叠）部分来组装全域近似。\n\n请从以下基本依据和核心定义出发，不使用任何超出这些范围的快捷公式：\n- 非相干成像近似 $I(x) = (K * M)(x)$ 及其在均匀网格上作为线性卷积的离散形式。\n- 快速傅里叶变换（FFT）卷积的定义，即一种通过离散傅里叶变换（DFT）来评估线性卷积的方法，其中使用足够的零填充以实现线性（非循环）卷积。\n- XPINN（扩展物理信息神经网络）的区域分解思想，以减小每个子问题的有效感受野，并通过在每个子域窗口上局部施加卷积残差来强制物理约束。\n\n您必须设计一个程序，该程序：\n- 在 $N$ 个网格点上构造一个确定性二值掩模版图 $M(x)$，其定义为：如果 $\\sin(2\\pi f_0 x_n) + 0.3 \\sin(2\\pi \\cdot 3 f_0 \\, x_n) > 0$，则 $M[n] = 1$，否则 $M[n] = 0$，其中 $x_n = n/N$，频率 $f_0$ 的单位是周期/单位长度。\n- 通过在 $x=0$ 附近的离散网格上对 $K(x) \\propto \\exp(-|x|/\\ell)/(1 + (|x|/a)^2)$ 进行采样来构建核 $K$，并将其截断到最小的对称支撑区，该支撑区的半长为 $H$（以样本数为单位），使得未归一化的核振幅在 $H\\Delta x$ 处低于阈值 $\\tau$。归一化 $K$，使其离散和等于 $1$。\n- 通过在全域上进行基于FFT的线性卷积（模式“same”）来计算基准图像 $I_{\\mathrm{true}}$。\n- 通过以下步骤实现受XPINN启发的块FFT近似 $I_{\\mathrm{XPINN}}$：\n  - 将 $M$ 分割成 $S$ 个相等的子域（假设 $S$ 能整除 $N$），每个子域的长度为 $N/S$。\n  - 对于每个子域 $i$，提取一个以该子域为中心、长度为 $N/S + 2o$ 的窗口（根据需要，在$[0,N-1]$范围外进行零填充），将窗口化的掩模与半径为 $R = \\min\\{o,H\\}$ 的截断核进行基于FFT的线性卷积，并仅保留中心的 $N/S$ 个样本（丢弃重叠的边缘）。\n  - 将保留的中心部分拼接起来，形成长度为 $N$ 的 $I_{\\mathrm{XPINN}}$。\n- 通过相对离散$\\ell_2$误差 $$\\varepsilon = \\frac{\\|I_{\\mathrm{XPINN}} - I_{\\mathrm{true}}\\|_2}{\\|I_{\\mathrm{true}}\\|_2}$$ 来量化精度。\n- 通过以下代理模型（单位为字节）来估算全域FFT卷积和XPINN块FFT卷积之间的峰值内存权衡。设 $L_{\\mathrm{sig}}$ 表示给定FFT卷积中使用的信号长度，$L_{\\mathrm{ker}}$ 表示核长度，且 $$P = 2^{\\lceil \\log_2(L_{\\mathrm{sig}} + L_{\\mathrm{ker}} - 1) \\rceil}$$ 为FFT长度。将峰值内存近似为\n  $$B(L_{\\mathrm{sig}}, L_{\\mathrm{ker}}) = 8\\,(L_{\\mathrm{sig}} + L_{\\mathrm{ker}}) + 16 \\times 3 P,$$\n  这对应于存储实数信号和核（使用$64$位浮点数）以及三个长度为 $P$ 的复数数组（使用$128$位复数），用于正向变换和谱乘积。对全域卷积和分块域卷积均使用此模型，后者的计算基于最大窗口尺寸 $L_{\\mathrm{sig}} = N/S + 2o$ 和截断核长度 $L_{\\mathrm{ker}} = 2\\min\\{o,H\\} + 1$。报告无量纲内存比\n  $$\\rho = \\frac{B\\big(N,\\; L_{\\mathrm{ker,full}}\\big)}{B\\big(N/S + 2o,\\; 2\\min\\{o,H\\} + 1\\big)},$$\n  其中 $L_{\\mathrm{ker,full}} = 2H + 1$ 是完整核的长度。请注意，较大的 $\\rho$ 表示全域方法比分块方法使用更多的峰值内存；$\\rho < 1$ 表示在此模型下分块方法使用更多的峰值内存。\n\n在所有测试中，请使用以下固定参数：\n- 网格大小 $N = 4096$。\n- 基频 $f_0 = 20$。\n- 核参数 $\\ell = 0.06$，$a = 0.01$，以及截断阈值 $\\tau = 10^{-6}$。\n- 本问题不使用角度；不需要角度单位。\n- 输出不要求物理单位；所有报告的量均为无量纲。\n\n您的程序必须按此确切顺序运行以下 $(S,o)$ 值的测试套件：\n- 测试 $1$：$S = 4$，$o = 64$。\n- 测试 $2$：$S = 4$，$o = 1400$。\n- 测试 $3$：$S = 16$，$o = 256$。\n- 测试 $4$：$S = 8$，$o = 0$。\n\n对于每个测试 $i$，计算一对 $(\\varepsilon_i, \\rho_i)$，其中 $\\varepsilon_i$ 是相对$\\ell_2$误差，$\\rho_i$ 是上面定义的内存比。最终程序输出必须是单行，包含一个用方括号括起来的、由逗号分隔的$8$个浮点数列表，对应于展平后的列表 $[\\varepsilon_1, \\rho_1, \\varepsilon_2, \\rho_2, \\varepsilon_3, \\rho_3, \\varepsilon_4, \\rho_4]$，每个值四舍五入到恰好$6$位小数。",
            "solution": "用户提供的问题已经过分析，被认为是有效的。该问题在科学上基于傅里叶光学和计算物理学的原理，问题陈述清晰完整、适定，没有任何歧义或矛盾。我们将着手提供完整的解决方案。\n\n该问题要求实现并比较两种计算光学投影光刻中光程像的方法，该过程被建模为线性卷积。第一种方法是使用快速傅里叶变换（FFT）的直接全域卷积。第二种是受扩展物理信息神经网络（XPINN）启发的区域分解方法，它在更小的重叠块中计算卷积。目标是评估基于块的方法在不同参数下，其精度与计算内存之间的权衡。\n\n我们的步骤如下：\n1.  定义离散仿真网格，并根据提供的周期函数构建二值掩模版图 $M(x)$。\n2.  构建离散光学核 $K(x)$。这包括基于振幅阈值 $\\tau$ 确定其有效支撑区半宽 $H$，在一个对称的 $2H+1$ 点网格上采样该函数，并对结果进行归一化。\n3.  通过使用基于FFT的方法对完整掩模 $M$ 和完整核 $K$ 进行线性卷积，计算基准光程像 $I_{\\mathrm{true}}$。\n4.  实现受XPINN启发的块FFT方法，以计算近似光程像 $I_{\\mathrm{XPINN}}$。这包括区域划分、处理重叠、使用截断核以及组装最终结果。\n5.  对于每个测试用例，计算相对 $\\ell_2$ 误差 $\\varepsilon$ 以量化精度，并计算内存消耗比 $\\rho$ 以量化计算权衡。\n\n让我们从定义和初始设置开始。空间域为 $x \\in [0,1)$，在一个包含 $N=4096$ 个点的网格上离散化，间距为 $\\Delta x = 1/N$。坐标为 $x_n = n \\Delta x$，其中 $n = 0, 1, \\ldots, N-1$。\n\n掩模版图 $M[n]$ 是一个确定性二值图案，由下式给出：\n$$M[n] = \\begin{cases} 1 & \\text{若 } \\sin(2\\pi f_0 x_n) + 0.3 \\sin(2\\pi \\cdot 3 f_0 x_n) > 0 \\\\ 0 & \\text{否则} \\end{cases}$$\n其中基频为 $f_0 = 20$。\n\n光学核由以下函数建模：\n$$K(x) \\propto \\frac{\\exp(-|x|/\\ell)}{1 + (|x|/a)^2}$$\n参数为 $\\ell = 0.06$ 和 $a = 0.01$。为了创建一个离散的、有限支撑的核，我们首先找到最小的整数半长 $H$，使得在 $x = H \\Delta x$ 处的未归一化核振幅低于阈值 $\\tau = 10^{-6}$。然后，通过在从 $x = -H \\Delta x$ 到 $x = H \\Delta x$ 的一个对称的 $2H+1$ 点网格上对该函数进行采样，来创建离散核 $K_{\\mathrm{full}}$。最后，对采样值进行归一化，使其总和等于1：\n$$K_{\\mathrm{full}}[k] = \\frac{K_{\\mathrm{un}}((k-H)\\Delta x)}{\\sum_{j=0}^{2H} K_{\\mathrm{un}}((j-H)\\Delta x)}, \\quad k = 0, \\ldots, 2H$$\n其中 $K_{\\mathrm{un}}(x)$ 是未归一化的核函数。完整核的长度为 $L_{\\mathrm{ker,full}} = 2H+1$。\n\n基准光程像是线性卷积 $I_{\\mathrm{true}} = (K_{\\mathrm{full}} * M)[n]$。我们使用卷积定理来计算它，该定理指出空间域中的卷积等效于频域中的乘法。我们采用一种基于FFT的线性卷积算法，确保足够的零填充以避免循环卷积失真。输出被裁剪为长度 $N$ 以匹配掩模域的大小（模式'same'）。\n\n受XPINN启发的块FFT近似 $I_{\\mathrm{XPINN}}$ 的计算方式如下。将掩模 $M$ 分为 $S$ 个相等的、不重叠的子域，每个子域的长度为 $N/S$。对于每个子域 $i \\in \\{0, \\ldots, S-1\\}$：\n1.  提取掩模的一个扩展窗口。该窗口以子域为中心，长度为 $N/S + 2o$，其中 $o$ 是重叠大小（以样本数为单位）。原始域 $[0, N-1]$ 之外的区域用零填充。\n2.  将完整核 $K_{\\mathrm{full}}$ 截断至半径 $R = \\min(o, H)$。这产生一个特定于块的核 $K_{\\mathrm{block}}$，其长度为 $2R+1$。这种截断是近似误差的一个关键来源，因为它忽略了超出重叠区域的长程光学相互作用。\n3.  使用基于FFT的方法，将扩展的掩模窗口与截断的核 $K_{\\mathrm{block}}$ 进行卷积。\n4.  从得到的卷积窗口中，只保留长度为 $N/S$ 的中心部分，该部分对应于原始子域。重叠的边缘被丢弃。\n5.  通过拼接所有 $S$ 个子域中保留的中心部分，构建最终的图像 $I_{\\mathrm{XPINN}}$。\n\n此近似的精度通过相对离散 $\\ell_2$ 误差来衡量：\n$$\\varepsilon = \\frac{\\|I_{\\mathrm{XPINN}} - I_{\\mathrm{true}}\\|_2}{\\|I_{\\mathrm{true}}\\|_2} = \\sqrt{\\frac{\\sum_{n=0}^{N-1} (I_{\\mathrm{XPINN}}[n] - I_{\\mathrm{true}}[n])^2}{\\sum_{n=0}^{N-1} (I_{\\mathrm{true}}[n])^2}}$$\n\n计算内存的权衡使用提供的代理模型来估算基于FFT的卷积过程中的峰值内存使用量：\n$$B(L_{\\mathrm{sig}}, L_{\\mathrm{ker}}) = 8\\,(L_{\\mathrm{sig}} + L_{\\mathrm{ker}}) + 16 \\times 3 P$$\n其中 $L_{\\mathrm{sig}}$ 是信号长度，$L_{\\mathrm{ker}}$ 是核长度，$P = 2^{\\lceil\\log_2(L_{\\mathrm{sig}} + L_{\\mathrm{ker}} - 1)\\rceil}$ 是为FFT填充后的长度。然后计算内存比：\n$$\\rho = \\frac{B\\big(N, L_{\\mathrm{ker,full}}\\big)}{B\\big(N/S + 2o, 2\\min\\{o,H\\} + 1\\big)}$$\n比率 $\\rho > 1$ 表示全域方法比基于块的方法更耗费内存。\n\n我们现在将对指定的 $(S, o)$ 值测试套件执行此过程，并报告所得的 $(\\varepsilon, \\rho)$ 对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal as sp_signal\n\ndef solve():\n    \"\"\"\n    Solves the optical lithography modeling problem by comparing full-domain\n    convolution with a block-FFT domain decomposition method.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    N = 4096\n    f0 = 20.0\n    ell = 0.06\n    a = 0.01\n    tau = 1e-6\n\n    # Test suite of (S, o) values\n    test_cases = [\n        (4, 64),\n        (4, 1400),\n        (16, 256),\n        (8, 0),\n    ]\n\n    # --- Step 1: Pre-computation of Mask and Kernel ---\n\n    # Define the spatial grid\n    x_grid = np.arange(N) / N\n    dx = 1.0 / N\n\n    # Construct the binary mask layout M\n    mask_signal = np.sin(2 * np.pi * f0 * x_grid) + 0.3 * np.sin(2 * np.pi * 3 * f0 * x_grid)\n    M = (mask_signal > 0).astype(float)\n\n    # Define the unnormalized kernel function\n    def K_unnormalized_func(x_val):\n        return np.exp(-np.abs(x_val) / ell) / (1.0 + (np.abs(x_val) / a)**2)\n\n    # Find the kernel half-length H based on the threshold tau\n    H = 0\n    for h_candidate in range(N):\n        if K_unnormalized_func(h_candidate * dx)  tau:\n            H = h_candidate\n            break\n    else:  # If the loop completes without breaking\n        H = N - 1\n\n    # Construct and normalize the discrete kernel K_full\n    L_ker_full = 2 * H + 1\n    k_indices = np.arange(-H, H + 1)\n    k_x_coords = k_indices * dx\n    K_full = K_unnormalized_func(k_x_coords)\n    K_full /= np.sum(K_full)\n\n    # --- Step 2: Compute Ground-Truth Aerial Image I_true ---\n\n    # Use 'scipy.signal.fftconvolve' for efficient and correct FFT-based convolution\n    I_true = sp_signal.fftconvolve(M, K_full, mode='same')\n\n    # Helper function for the memory proxy model\n    def get_peak_memory(L_sig, L_ker):\n        if L_sig = 0 or L_ker = 0:\n            return 0\n        fft_len = L_sig + L_ker - 1\n        if fft_len = 1:\n          P = 1\n        else:\n          P = 1  (fft_len - 1).bit_length() # Efficient way to find next power of 2\n        \n        # The formula from the problem statement:\n        # B(L_sig, L_ker) = 8*(L_sig + L_ker) + 16 * 3 * P\n        # 8 bytes for float64, 16 bytes for complex128\n        return 8 * (L_sig + L_ker) + 48 * P\n\n    results = []\n    # --- Step 3: Loop over test cases to compute I_XPINN and metrics ---\n    for S, o in test_cases:\n        # --- Step 3a: Compute I_XPINN using the block-FFT method ---\n        subdomain_len = N // S\n        I_XPINN_parts = []\n\n        for i in range(S):\n            sub_start_idx = i * subdomain_len\n            sub_end_idx = sub_start_idx + subdomain_len\n\n            # Define the extended window for the mask\n            win_start_idx = sub_start_idx - o\n            win_end_idx = sub_end_idx + o\n            win_len = subdomain_len + 2 * o\n            \n            M_window = np.zeros(win_len)\n            \n            # Extract the slice of M for the window, handling domain boundaries\n            src_start_in_M = max(0, win_start_idx)\n            src_end_in_M = min(N, win_end_idx)\n            M_slice = M[src_start_in_M:src_end_in_M]\n\n            # Place the slice into the window, handling padding\n            dst_start_in_win = src_start_in_M - win_start_idx\n            dst_end_in_win = dst_start_in_win + len(M_slice)\n            M_window[dst_start_in_win:dst_end_in_win] = M_slice\n            \n            # Truncate the kernel for the block-based convolution\n            R = min(o, H)\n            K_block = K_full[H - R : H + R + 1]\n            \n            # Convolve the windowed mask with the truncated kernel\n            I_window_convolved = sp_signal.fftconvolve(M_window, K_block, mode='same')\n            \n            # Retain only the central portion corresponding to the non-overlapped subdomain\n            I_subdomain = I_window_convolved[o : o + subdomain_len]\n            I_XPINN_parts.append(I_subdomain)\n\n        I_XPINN = np.concatenate(I_XPINN_parts)\n\n        # --- Step 3b: Calculate accuracy and memory metrics ---\n        \n        # Relative L2 error\n        error_norm = np.linalg.norm(I_XPINN - I_true)\n        true_norm = np.linalg.norm(I_true)\n        epsilon = error_norm / true_norm\n\n        # Memory ratio\n        mem_full = get_peak_memory(N, L_ker_full)\n        \n        L_sig_block = subdomain_len + 2 * o\n        L_ker_block = 2 * min(o, H) + 1\n        mem_block = get_peak_memory(L_sig_block, L_ker_block)\n        \n        rho = mem_full / mem_block if mem_block > 0 else float('inf')\n        \n        results.extend([epsilon, rho])\n    \n    # --- Step 4: Format and print the final output ---\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}