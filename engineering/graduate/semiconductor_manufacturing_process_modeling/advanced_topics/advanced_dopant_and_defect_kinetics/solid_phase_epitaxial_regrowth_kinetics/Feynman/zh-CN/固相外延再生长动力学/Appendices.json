{
    "hands_on_practices": [
        {
            "introduction": "在任何定量分析中，选择正确的动力学模型是至关重要的第一步。该练习旨在挑战您批判性地评估广为人知的Johnson-Mehl-Avrami-Kolmogorov (JMAK)模型，并理解为何对于单界面固相外延再生长(SPER)，一个更简单的、确定性的等速界面传播模型才是物理上正确的选择。通过辨析这些模型，您将巩固对SPER核心物理机制的理解。",
            "id": "4165774",
            "problem": "考虑在均匀温度 $T$ 下，厚度为 $d$ 的非晶硅层在晶体硅上进行固相外延（SPE）。再生长从遍及整个晶圆区域的单一、平面的非晶/晶体界面开始，界面前方没有发生体成核。该过程可以理想化为在恒定 $T$ 下的界面控制过程，没有长程扩散限制，并且应力或杂质效应可忽略不计。结晶分数定义为结晶体积与总层体积之比。\n\n选择最准确地指明了结晶分数的 Johnson-Mehl-Avrami-Kolmogorov (JMAK) 描述，解释了为什么它在指定条件下不适用于 SPE，并为厚度和分数随时间的演化提出了一个物理上一致的动力学模型的选项。\n\nA. JMAK 分数为 $X(t)=1-\\exp(-K t)$，对于一维推进，其指数 $n=1$，因此它直接适用于单个 SPE 界面。因此，相变分数随时间呈指数关系，再生长的厚度遵循 $x(t)=d\\,X(t)=d\\left[1-\\exp(-K t)\\right]$。\n\nB. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，该模型假设随机的体成核和生长。它不适用于单界面 SPE，因为没有成核过程，且相变是通过确定性的界面传播进行的。在恒定 $T$ 下的界面控制动力学中，界面速度是 Arrhenius 型的，$v(T)=v_0\\exp\\!\\left(-E_a/(k_B T)\\right)$，因此再生长的厚度为 $x(t)=v(T)\\,t$，分数为 $X(t)=x(t)/d=v(T)\\,t/d$，直到在 $t_f=d/v(T)$ 时完成。\n\nC. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，它对 SPE 不适用，因为 SPE 是扩散受限的，所以再生长的厚度必须遵循抛物线定律 $x(t)=\\sqrt{D t}$，分数为 $X(t)=x(t)/d=\\sqrt{t/t_f}$，其中 $D$ 是有效扩散系数，$t_f=d^2/D$。\n\nD. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，但单界面 SPE 用 logistic 定律 $X(t)=1/\\left[1+\\exp\\!\\left(-\\alpha(t-t_0)\\right)\\right]$ 能更好地描述，该定律模拟了饱和过程；因此 $x(t)=d\\,X(t)$ 提供了一致的厚度演化。\n\nE. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，但设置 $n=0$ 可以移除成核以匹配单界面 SPE。然后厚度由于驱动力而加速，$x(t)=\\tfrac{1}{2}a t^2$，得到 $X(t)=x(t)/d$，其中恒定加速度 $a$ 由界面自由能差决定。",
            "solution": "问题陈述描述了在晶体硅衬底上非晶硅层的固相外延（SPE）再生长过程。必须首先评估该陈述的有效性。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 过程：在晶体硅上的非晶硅层的固相外延（SPE）。\n- 初始非晶层厚度：`$d$`。\n- 温度：均匀且恒定，`$T$`。\n- 生长几何：从单一、平面的非晶/晶体界面开始。\n- 成核约束：界面前方无体成核。\n- 动力学控制：理想化为在恒定 `$T$` 下的界面控制。\n- 输运约束：无长程扩散限制。\n- 其他约束：可忽略的应力或杂质效应。\n- 定义：结晶分数 `$X$` 是结晶体积与总层体积之比。对于平面界面，这等同于再生长厚度 `$x$` 与初始厚度 `$d$` 之比，因此 `$X = x/d$`。\n- 问题：选择正确指明 Johnson-Mehl-Avrami-Kolmogorov (JMAK) 描述，解释其对指定 SPE 过程的不适用性，并为厚度 `$x(t)$` 和分数 `$X(t)$` 的演化提出物理上一致的动力学模型的选项。\n\n**步骤2：使用已知条件进行验证**\n- **科学依据：** 该问题描述了一个公认的材料科学过程。SPE、界面控制动力学、Arrhenius 行为和 JMAK 理论等概念都是研究固相相变的基础。该设定是过程建模中使用的标准、物理上现实的理想化模型。\n- **适定性：** 问题表述清晰。它提供了一个具体的物理情景，并要求通过从一组选项中选择来给出正确的理论描述。所提供的约束足以在选项中唯一确定正确的物理模型。\n- **客观性：** 语言是先验中立、精确且不含主观内容的。诸如“平面界面”、“界面控制”和“无体成核”等术语在此上下文中具有特定、明确的含义。\n- **不完整或矛盾的设定：** 问题陈述是自洽的，并提供了所有必要信息。“界面控制”和“无长程扩散限制”的条件是一致且互补的。“单一、平面界面”和“无体成核”的条件定义了一种特定的生长模式（层状生长或 Frank-van der Merwe 型生长，尽管简化为一维推进）。没有矛盾之处。\n- **不现实或不可行：** 这些条件描述了高纯度硅 SPE 的一个有效（尽管是理想化的）物理状态。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它在科学上是合理的，问题是适定的，并且内部一致。可以继续进行求解过程。\n\n**推导与选项分析**\n\n核心的先验分析如下：\n1.  **JMAK模型：** Johnson-Mehl-Avrami-Kolmogorov (JMAK) 理论描述了通过成核和生长过程进行的相变的整体动力学。相变体积分数 `$X(t)$` 作为时间 `$t$` 的函数的通用表达式为：\n    $$X(t) = 1 - \\exp(-K t^n)$$\n    此处，`$K$` 是一个与温度相关的速率常数，`$n$` 是 Avrami 指数，它取决于生长的维度和成核速率的时间依赖性。JMAK 模型的关键物理基础是新相区域的随机空间成核及其随后的生长，直到与相邻区域发生撞击。指数形式的出现是由于对这种撞击进行了统计处理。\n\n2.  **对SPE的适用性：** 问题指明再生长从*单一、平面界面*开始，并且*无体成核*。这种物理情况与 JMAK 模型的假设有根本不同。没有随机成核事件；相变前沿是一个单一、预先存在且确定性推进的平面。因此，作为 JMAK 理论核心的对撞击的统计处理在此不相关。JMAK 模型不是对这一特定过程的正确物理描述。\n\n3.  **物理上一致的SPE模型：** 问题指出该过程是在*恒定温度* `$T$` 下*界面控制*的。这意味着速率限制步骤是发生在非晶/晶体界面本身的原子重排过程。对于在恒定温度和恒定驱动力（非晶相和晶相之间的自由能差）下的热激活过程，其速率是恒定的。这里的相关速率是界面的速度 `$v$`。该速度由 Arrhenius 方程描述：\n    $$v(T) = v_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)$$\n    其中 `$v_0$` 是指前因子，`$E_a$` 是再生长的活化能，`$k_B$` 是玻尔兹曼常数。由于速度 `$v(T)$` 相对于时间是恒定的，再生长的晶体层厚度 `$x(t)$` 从 `$x(0)=0$` 开始随时间 `$t$` 线性增加：\n    $$x(t) = v(T) \\cdot t$$\n    这种线性生长一直持续到整个非晶层被消耗完，即直到 `$x(t) = d$`。结晶分数 `$X(t)$` 是再生长厚度与总初始厚度 `$d$` 之比：\n    $$X(t) = \\frac{x(t)}{d} = \\frac{v(T)}{d} t$$\n    `$X(t)$` 的这种线性关系在 `$0 \\le t \\le t_f$` 范围内有效，其中完成时间为 `$t_f = d/v(T)$`。对于 `$t \\ge t_f$`，`$x(t)=d$` 且 `$X(t)=1$`。\n\n现在，我们基于这一理解来评估每个选项。\n\n**选项A：** 此选项声称具有 `$n=1$` 的 JMAK 模型 `$X(t)=1-\\exp(-K t)$` 直接适用。这是不正确的。虽然 JMAK 中的 `$n=1$` 可以对应于从预先存在的核开始的一维生长，但函数形式 `$X(t)=1-\\exp(-K t)$` 意味着再生长速度 `$v(t) = dx/dt = d \\cdot dX/dt = dK\\exp(-Kt)$` 会随时间*指数级下降*。这与在恒定温度下界面控制过程所预期的恒定速度相矛盾。\n**结论：不正确。**\n\n**选项B：** 此选项正确地指出了 JMAK 的一般形式 `$X(t)=1-\\exp(-K t^n)$` 及其在“随机体成核和生长”中的物理基础。它正确地解释了 JMAK 不适用于单界面 SPE，因为“没有成核”，且生长是“确定性的界面传播”。然后，它正确地提出，对于恒定 `$T$` 下的界面控制动力学，速度 `$v(T)$` 是恒定的（由 Arrhenius 定律给出），导致厚度线性增加 `$x(t)=v(T)t$`，分数也线性增加 `$X(t)=x(t)/d = v(T)t/d$`。这一分析与第一性原理推导完全一致。\n**结论：正确。**\n\n**选项C：** 此选项声称 SPE 是扩散受限的，这与问题陈述中的“无长程扩散限制”和“界面控制”直接矛盾。所提出的抛物线生长定律 `$x(t)=\\sqrt{D t}$` 是扩散受限过程的特征，而这已被明确排除。\n**结论：不正确。**\n\n**选项D：** 此选项为分数提出了一个 logistic 定律，`$X(t)=1/\\left[1+\\exp\\!\\left(-\\alpha(t-t_0)\\right)\\right]$`。该函数描述了 S 型（sigmoidal）生长，其中速率 `$dX/dt$` 最初很慢，然后加速，最后减速。虽然在一些复杂的相变中可以观察到这种动力学，但它与问题约束（恒定 `$T$` 下的界面控制）所预期的简单、恒速生长不符。恒速过程具有恒定的速率 `$dX/dt$`，导致分数的线性增长，而非 S 型增长。\n**结论：不正确。**\n\n**选项E：** 此选项建议在 JMAK 方程中设置 Avrami 指数 `$n=0$` 来模拟 SPE。设置 `$n=0$` 得到 `$X(t) = 1-\\exp(-K)$`，这是一个常数值，而不是描述随时间演化的动力学定律。这是无稽之谈。然后它提出了一个恒定加速度的模型，`$x(t)=\\tfrac{1}{2}a t^2$`，这意味着速度 `$v(t) = at$` 随时间线性增加。问题陈述中没有为在恒定温度和驱动力下出现这种加速度提供任何物理基础。界面控制的热激活过程模型是恒定速度。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "一旦确定了动力学模型的基本形式（即阿伦尼乌斯定律），关键的下一步就是从实验数据中提取其关键参数。本练习将引导您完成这项基本任务，从模型的线性化变换，到应用加权线性回归以精确处理实验不确定性。这构成了从理论模型到真实世界实验科学之间的桥梁。",
            "id": "4165824",
            "problem": "您正在对退火过程中非晶硅的固相外延（SPE）再生长动力学进行建模。假设再生长前沿速度遵循与过渡态理论一致的阿伦尼乌斯定律：存在一个活化能和一个动力学指前因子，使得再生长速度的温度依赖性呈阿伦尼乌斯形式。您将根据受采样噪声影响的有限样本实验测量值来估计活化能和指前因子。您的任务是设计并实现一种数值方法，该方法在给定一组温度、带有样本标准差和重复次数的含噪声样本均值速度测量值的情况下，能够产生统计上有效的估计值以及反映有限采样效应的单标准差不确定度。\n\n基本原理：\n- 阿伦尼乌斯模型被广泛接受用于描述热激活过程的动力学。如果SPE再生长速度表示为$v$，温度为$T$，活化能为$E_{a}$，动力学指前因子为$v_{0}$，则速率模型为 $v = v_{0} \\exp\\!\\left(-E_{a}/(k_{\\mathrm{B}} T)\\right)$，其中$k_{\\mathrm{B}}$是玻尔兹曼常数。\n- 对于在固定温度$T_{i}$下的独立重复测量，假设第$j$次重复测量的速度$v_{ij}$是具有有限方差的独立抽取。报告的$v_{i}$是$n_{i}$次重复测量的样本均值，$s_{v,i}$是这些重复测量中的样本标准差。均值的标准误为$s_{v,i}/\\sqrt{n_{i}}$。\n- 对于较小的相对噪声，样本均值的对数的不确定度可以通过一阶泰勒展开进行传播：如果$y_{i} = \\ln v_{i}$，那么$y_{i}$的标准差约等于$\\sigma_{y,i} \\approx \\left(s_{v,i}/\\sqrt{n_{i}}\\right)/v_{i}$。\n\n设计一种方法，通过利用阿伦尼乌斯方程取自然对数后的线性关系，并对转换后的数据使用加权线性回归，来估计$E_{a}$和$v_{0}$及其单标准差不确定度。\n\n使用以下常数和约定：\n- 使用$k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}$，单位为$\\mathrm{eV/K}$。\n- 温度$T$的单位为$\\mathrm{K}$。\n- 速度$v$和指前因子$v_{0}$的单位为$\\mathrm{nm/s}$。\n- 活化能$E_{a}$以$\\mathrm{eV}$为单位报告。\n- 单标准差不确定度必须以与这些单位一致的方式报告。\n- 不涉及角度。\n\n测试套件：\n对于每种情况，您会得到温度、样本均值速度、样本标准差和重复次数的数组。将报告的样本标准差视为根据重复测量计算得出，并假设样本均值存在独立的高斯采样噪声。使用均值标准误和一阶不确定度传播来定义转换后空间中加权线性回归的权重。\n\n- 情况A（理想情况，多个温度，中等噪声）：\n  - 温度 $T_{\\mathrm{A}} = [900, 950, 1000, 1050, 1100, 1150, 1200]$\n  - 样本均值速度 $v_{\\mathrm{A}} = [0.052, 0.095, 0.17, 0.31, 0.55, 0.96, 1.60]$\n  - 样本标准差 $s_{v,\\mathrm{A}} = [0.005, 0.006, 0.012, 0.02, 0.028, 0.05, 0.08]$\n  - 重复次数 $n_{\\mathrm{A}} = [8, 8, 8, 8, 8, 8, 8]$\n\n- 情况B（边界条件，仅两个温度，已知的异方差噪声）：\n  - 温度 $T_{\\mathrm{B}} = [1000, 1200]$\n  - 样本均值速度 $v_{\\mathrm{B}} = [0.20, 1.70]$\n  - 样本标准差 $s_{v,\\mathrm{B}} = [0.02, 0.10]$\n  - 重复次数 $n_{\\mathrm{B}} = [5, 5]$\n\n- 情况C（异方差噪声，重复次数少且变化）：\n  - 温度 $T_{\\mathrm{C}} = [950, 975, 1000, 1025, 1050]$\n  - 样本均值速度 $v_{\\mathrm{C}} = [0.090, 0.120, 0.180, 0.230, 0.310]$\n  - 样本标准差 $s_{v,\\mathrm{C}} = [0.020, 0.015, 0.020, 0.030, 0.050]$\n  - 重复次数 $n_{\\mathrm{C}} = [3, 3, 2, 4, 3]$\n\n您的程序必须对每种情况执行以下操作：\n- 根据阿伦尼乌斯模型将数据转换为线性化形式。\n- 使用加权线性回归，以转换后观测值方差的倒数定义权重，计算斜率和截距的统计有效估计值。\n- 将斜率和截距的估计值分别转换为$E_{a}$和$v_{0}$。\n- 传播不确定度以获得$E_{a}$和$v_{0}$的单标准差不确定度。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，内含三个内部列表，每个内部列表为$[E_{a}, u_{E_{a}}, v_{0}, u_{v_{0}}]$，依次对应情况A、B和C，其中$u_{E_{a}}$和$u_{v_{0}}$表示单标准差不确定度。单位为：$E_{a}$为$\\mathrm{eV}$，$v_{0}$为$\\mathrm{nm/s}$。例如，一个有效的输出结构形式为$[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]$。",
            "solution": "该问题要求估算固相外延（SPE）再生长的活化能$E_a$和动力学指前因子$v_0$，该过程由阿伦尼乌斯方程建模。我们获得了实验数据，包括温度$T_i$、对应的样本均值再生长速度$v_i$、样本标准差$s_{v,i}$以及每个测量点的重复次数$n_i$。我们还必须计算估计参数的单标准差不确定度$u_{E_a}$和$u_{v_0}$。\n\n指定的方法是对阿伦尼乌斯模型进行线性化，并对转换后的数据执行加权线性回归。回归的权重由测量不确定度确定。\n\n**1. 阿伦尼乌斯模型的线性化**\n\n再生长速度$v$作为温度$T$的函数的阿伦尼乌斯模型由下式给出：\n$$\nv = v_0 \\exp\\left(-\\frac{E_a}{k_{\\mathrm{B}} T}\\right)\n$$\n其中$k_{\\mathrm{B}}$是玻尔兹曼常数。对方程两边取自然对数可将其线性化：\n$$\n\\ln(v) = \\ln(v_0) - \\frac{E_a}{k_{\\mathrm{B}}} \\frac{1}{T}\n$$\n该方程为直线形式 $y = c + mx$，其中：\n- 因变量为 $y_i = \\ln(v_i)$。\n- 自变量为 $x_i = 1/T_i$。\n- 截距为 $c = \\ln(v_0)$。\n- 斜率为 $m = -E_a/k_{\\mathrm{B}}$。\n\n我们的目标是根据给定的数据$(T_i, v_i, s_{v,i}, n_i)$来估计参数$m$和$c$。\n\n**2. 加权线性回归**\n\n$v_i$的测量值是带噪声的。这种噪声会传播到转换后的变量$y_i = \\ln(v_i)$。我们使用加权线性回归（WLR）来考虑更精确的测量值应该对拟合有更大影响的事实。权重$w_i$选择为因变量方差的倒数，$w_i = 1/\\sigma_{y_i}^2$。\n\n首先，我们确定$y_i$的不确定度。报告的数据包括样本均值速度$v_i$及其来自$n_i$次重复测量的样本标准差$s_{v,i}$。均值速度的标准误是 $\\sigma_{v_i, \\text{mean}} = s_{v,i} / \\sqrt{n_i}$。使用一阶泰勒展开进行函数$y_i = \\ln(v_i)$的不确定度传播，方差$\\sigma_{y_i}^2$近似为：\n$$\n\\sigma_{y_i}^2 \\approx \\left(\\frac{d(\\ln v_i)}{dv_i}\\right)^2 \\sigma_{v_i, \\text{mean}}^2 = \\left(\\frac{1}{v_i}\\right)^2 \\left(\\frac{s_{v,i}}{\\sqrt{n_i}}\\right)^2 = \\frac{s_{v,i}^2}{v_i^2 n_i}\n$$\n因此，WLR的权重为：\n$$\nw_i = \\frac{1}{\\sigma_{y_i}^2} = \\frac{v_i^2 n_i}{s_{v,i}^2}\n$$\n\nWLR问题是找到参数$\\hat{m}$和$\\hat{c}$，使得加权残差平方和$\\chi^2$最小化：\n$$\n\\chi^2 = \\sum_{i=1}^{N} w_i (y_i - (c + m x_i))^2\n$$\n这是一个标准问题，可以使用矩阵代数高效解决。设$\\mathbf{y}$是观测值$y_i$的列向量，$\\mathbf{W}$是权重$w_i$的对角矩阵，$\\mathbf{X}$是设计矩阵：\n$$\n\\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{pmatrix}, \\quad\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix}\n$$\n估计参数的向量$\\hat{\\boldsymbol{\\beta}} = [\\hat{c}, \\hat{m}]^T$由WLR的正规方程给出：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n估计参数的协方差矩阵$\\mathbf{C}_{\\boldsymbol{\\beta}}$包含$\\hat{c}$和$\\hat{m}$的方差和协方差，其表达式为：\n$$\n\\mathbf{C}_{\\boldsymbol{\\beta}} = \\begin{pmatrix} \\sigma_c^2  \\sigma_{cm} \\\\ \\sigma_{cm}  \\sigma_m^2 \\end{pmatrix} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}\n$$\n截距和斜率的单标准差不确定度是该矩阵对角元素的平方根：$u_c = \\sigma_c = \\sqrt{(\\mathbf{C}_{\\boldsymbol{\\beta}})_{11}}$ 和 $u_m = \\sigma_m = \\sqrt{(\\mathbf{C}_{\\boldsymbol{\\beta}})_{22}}$。\n\n**3. 物理参数及其不确定度的计算**\n\n一旦我们有了估计值$\\hat{c}$、$\\hat{m}$及其不确定度$u_c$、$u_m$，我们就可以计算物理参数$E_a$和$v_0$并传播不确定度。\n\n- **活化能 ($E_a$)**:\n  估计值由斜率$m = -E_a/k_{\\mathrm{B}}$导出：\n  $$\n  \\hat{E}_a = -\\hat{m} k_{\\mathrm{B}}\n  $$\n  不确定度$u_{E_a}$通过传播斜率的不确定度$u_m$得到：\n  $$\n  u_{E_a} = | -k_{\\mathrm{B}} | u_m = k_{\\mathrm{B}} u_m\n  $$\n\n- **指前因子 ($v_0$)**:\n  估计值由截距$c = \\ln(v_0)$导出：\n  $$\n  \\hat{v}_0 = \\exp(\\hat{c})\n  $$\n  不确定度$u_{v_0}$通过传播截距的不确定度$u_c$得到：\n  $$\n  u_{v_0}^2 \\approx \\left(\\frac{d(\\exp c)}{dc}\\Big|_{c=\\hat{c}}\\right)^2 u_c^2 = (\\exp(\\hat{c}))^2 u_c^2 = \\hat{v}_0^2 u_c^2\n  $$\n  取平方根得到单标准差不确定度：\n  $$\n  u_{v_0} \\approx \\hat{v}_0 u_c\n  $$\n\n此程序将应用于问题陈述中提供的三个测试案例中的每一个。玻尔兹曼常数使用其指定值$k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV/K}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for Arrhenius parameters and their uncertainties from experimental data\n    using weighted linear regression.\n    \"\"\"\n    \n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, multiple temperatures, moderate noise)\n        {\n            \"T\": np.array([900, 950, 1000, 1050, 1100, 1150, 1200]),\n            \"v\": np.array([0.052, 0.095, 0.17, 0.31, 0.55, 0.96, 1.60]),\n            \"s_v\": np.array([0.005, 0.006, 0.012, 0.02, 0.028, 0.05, 0.08]),\n            \"n\": np.array([8, 8, 8, 8, 8, 8, 8]),\n        },\n        # Case B (boundary condition, only two temperatures, known heteroscedastic noise)\n        {\n            \"T\": np.array([1000, 1200]),\n            \"v\": np.array([0.20, 1.70]),\n            \"s_v\": np.array([0.02, 0.10]),\n            \"n\": np.array([5, 5]),\n        },\n        # Case C (heteroscedastic noise, small and varying replicate counts)\n        {\n            \"T\": np.array([950, 975, 1000, 1025, 1050]),\n            \"v\": np.array([0.090, 0.120, 0.180, 0.230, 0.310]),\n            \"s_v\": np.array([0.020, 0.015, 0.020, 0.030, 0.050]),\n            \"n\": np.array([3, 3, 2, 4, 3]),\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, v, s_v, n = case[\"T\"], case[\"v\"], case[\"s_v\"], case[\"n\"]\n\n        # 1. Transform data for linearization\n        # y = ln(v), x = 1/T\n        x = 1.0 / T\n        y = np.log(v)\n\n        # 2. Calculate weights for Weighted Linear Regression (WLR)\n        # Weight w_i = 1 / sigma_y_i^2\n        # sigma_y_i is approx (sigma_v_mean_i) / v_i\n        # sigma_v_mean_i = s_v_i / sqrt(n_i)\n        # So, sigma_y_i^2 = s_v_i^2 / (v_i^2 * n_i)\n        # And w_i = (v_i^2 * n_i) / s_v_i^2\n        weights = (v**2 * n) / s_v**2\n        W = np.diag(weights)\n\n        # 3. Perform Weighted Linear Regression\n        # Setup the design matrix X for y = c + mx\n        X = np.vstack([np.ones_like(x), x]).T\n        \n        # Calculate (X^T * W * X)\n        XT_W_X = X.T @ W @ X\n        \n        # The covariance matrix of the parameters [c, m] is inv(X^T * W * X)\n        try:\n            cov_beta = np.linalg.inv(XT_W_X)\n        except np.linalg.LinAlgError:\n            # This would happen if X is singular (e.g., all T are the same),\n            # but the test cases are well-behaved.\n            results.append([np.nan] * 4)\n            continue\n            \n        # The parameter vector beta = [c, m] is inv(X^T * W * X) * X^T * W * y\n        beta_hat = cov_beta @ X.T @ W @ y\n        \n        c_hat = beta_hat[0]  # Intercept = ln(v0)\n        m_hat = beta_hat[1]  # Slope = -Ea / k_B\n        \n        # Extract uncertainties (std deviations) from the covariance matrix\n        u_c = np.sqrt(cov_beta[0, 0])\n        u_m = np.sqrt(cov_beta[1, 1])\n        \n        # 4. Convert regression parameters to physical parameters and propagate uncertainty\n        # Activation Energy (E_a)\n        Ea = -m_hat * k_B\n        u_Ea = u_m * k_B\n        \n        # Prefactor (v0)\n        v0 = np.exp(c_hat)\n        # Uncertainty propagation: u_v0 = v0 * u_c\n        u_v0 = v0 * u_c\n        \n        results.append([Ea, u_Ea, v0, u_v0])\n        \n    # Final print statement in the exact required format.\n    # Convert numpy arrays/scalars to native Python floats for clean string representation.\n    final_results = [[float(val) for val in res] for res in results]\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "拥有一个经过校准的动力学模型后，我们便能够预测系统在复杂的非等温条件下的行为，这在半导体制造中屡见不鲜。该练习展示了如何将阿伦尼乌斯模型应用于一个实际场景——线性温度斜坡升温，这需要通过数值积分和求根算法来解决。它体现了一个精确物理模型在工艺工程与设计中所具有的强大预测能力。",
            "id": "4165823",
            "problem": "考虑在非晶化半导体薄膜中，在线性温度爬升条件下的固相外延再生长。再生长前沿以随温度变化的速度前进，该速度由阿伦尼乌斯关系描述，其中再生长速度 $v(T)$ 满足 $v(T) = v_0 \\exp\\!\\left(-\\dfrac{E_a}{k_\\mathrm{B} T}\\right)$，其中 $v_0$ 是指前因子，$E_a$ 是活化能，$k_\\mathrm{B}$ 是玻尔兹曼常数。晶圆通过线性温度爬升进行退火，温度变化关系为 $T(t) = T_0 + \\beta t$，其中 $T_0$ 是初始温度，$\\beta$ 是恒定的爬升率。到时间 $t$ 为止累积的再生长厚度为 $L(t) = \\int_{0}^{t} v\\!\\left(T(\\tau)\\right)\\,\\mathrm{d}\\tau$。对于给定的参数 $T_0$、$\\beta$、$v_0$ 和 $E_a$，您必须反推厚度关系，以确定再生长到目标厚度 $L$ 所需的爬升时间 $t_f$。该反推过程会得到一个关于 $t_f$ 的超越方程，该方程无法简化为初等函数，必须进行数值求解。\n\n仅从上述基本定义和经过充分验证的事实出发，推导在线性爬升条件下再生长厚度随时间变化的数学形式，确定保证对于任何非负 $L$ 都存在且唯一的 $t_f$ 的性质，并设计一个鲁棒的数值算法来计算任意物理上合理的输入的 $t_f$。最终时间 $t_f$ 以秒为单位表示。如果某个案例中 $L = 0$，则返回 $t_f = 0$。\n\n您的程序必须实现该算法，并对以下每个测试案例求解 $t_f$。请统一使用以下单位：$T$ 的单位为开尔文，$\\beta$ 的单位为开尔文/秒，$v_0$ 的单位为米/秒，$E_a$ 的单位为电子伏特，$L$ 的单位为纳米。玻尔兹曼常数 $k_\\mathrm{B}$ 使用电子伏特/开尔文为单位。对于数值结果，将每个 $t_f$ 打印为以秒为单位的浮点数，并精确到小数点后六位。\n\n测试套件：\n- 案例 1：$T_0 = 600 \\ \\mathrm{K}$，$\\beta = 2 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 2.7 \\ \\mathrm{eV}$，$L = 100 \\ \\mathrm{nm}$。\n- 案例 2（边界条件）：$T_0 = 500 \\ \\mathrm{K}$，$\\beta = 5 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 2.7 \\ \\mathrm{eV}$，$L = 0 \\ \\mathrm{nm}$。\n- 案例 3（慢速爬升）：$T_0 = 450 \\ \\mathrm{K}$，$\\beta = 0.2 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 2.7 \\ \\mathrm{eV}$，$L = 50 \\ \\mathrm{nm}$。\n- 案例 4（更高活化能）：$T_0 = 600 \\ \\mathrm{K}$，$\\beta = 2 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 3.2 \\ \\mathrm{eV}$，$L = 100 \\ \\mathrm{nm}$。\n\n您的程序应生成单行输出，其中包含四个案例的结果，格式为一个由方括号括起来的逗号分隔列表（例如，$[t_1,t_2,t_3,t_4]$），其中每个 $t_i$ 是计算出的 $t_f$（以秒为单位），并精确到小数点后六位。",
            "solution": "所述问题在科学上是合理的、适定的且内部一致的。所有必要的物理定律、数学定义和数值参数均已提供，足以构建和求解所需的时间 $t_f$。该物理模型基于固相外延再生长的标准阿伦尼乌斯动力学，而退火过程是常见的线性温度爬升。因此，该问题被认为是有效的。\n\n问题的核心是确定达到目标再生长厚度 $L$ 所需的时间 $t_f$。这是通过求解方程 $L(t_f) = L$ 来实现的，其中 $L(t)$ 是作为时间函数的累积厚度。\n\n再生长前沿的速度 $v$ 是温度 $T$ 的函数，由阿伦尼乌斯关系给出：\n$$v(T) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} T}\\right)$$\n其中 $v_0$ 是指前因子，$E_a$ 是活化能，$k_\\mathrm{B}$ 是玻尔兹曼常数。\n\n温度 $T$ 随时间 $t$ 根据线性爬升变化：\n$$T(t) = T_0 + \\beta t$$\n其中 $T_0$ 是初始温度，$\\beta$ 是恒定的爬升率。为使该关系在 $t \\ge 0$ 时具有物理意义，我们必须有 $T_0  0$ 和 $\\beta \\ge 0$。所提供的测试案例满足这些条件。\n\n截至时间 $t$ 累积的总再生长厚度 $L(t)$ 是速度的时间积分。通过将温度爬升的表达式 $T(\\tau)$ 代入速度方程 $v(T)$，我们得到速度作为时间 $\\tau$ 的显式函数：\n$$v(T(\\tau)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right)$$\n在最终时间 $t_f$ 时的累积厚度则由定积分给出：\n$$L(t_f) = \\int_{0}^{t_f} v(T(\\tau)) \\, \\mathrm{d}\\tau = \\int_{0}^{t_f} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau$$\n\n为了找到生长特定厚度 $L$ 所需的时间 $t_f$，我们必须求解以下关于 $t_f$ 的方程：\n$$L = \\int_{0}^{t_f} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau$$\n\n该积分没有以初等函数表示的闭式解。它可以用指数积分特殊函数 $E_n(x)$ 来表示，但对于数值计算，直接以数值方式处理该积分通常更为直接和鲁棒。\n\n在设计算法之前，我们必须确定对于任何给定的非负目标厚度 $L$，解 $t_f$ 的存在性和唯一性。让我们分析函数 $L(t_f)$。\n被积函数 $v(T(\\tau)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right)$，对于所有物理参数（$v_0  0, E_a  0, k_\\mathrm{B}  0, T_0  0, \\beta \\ge 0$）和所有 $\\tau \\ge 0$ 都是一个严格的正函数。\n根据微积分基本定理，$L(t)$ 对时间 $t$ 的导数为：\n$$\\frac{\\mathrm{d}L}{\\mathrm{d}t} = v(T(t)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta t)}\\right)$$\n由于对于所有 $t \\ge 0$ 都有 $v(T(t))  0$，函数 $L(t)$ 在 $t \\ge 0$ 上是严格单调递增的。\n此外，在初始时间 $t=0$ 时，累积厚度为零：$L(0) = \\int_{0}^{0} \\dots \\, \\mathrm{d}\\tau = 0$。\n\n这些性质保证了解的存在性和唯一性：\n1.  **存在性**：由于 $L(0) = 0$ 且 $L(t)$ 是连续的并且随着 $t \\to \\infty$ 无界增长，根据介值定理，对于任何目标厚度 $L \\ge 0$，保证存在至少一个时间 $t_f \\ge 0$ 使得 $L(t_f) = L$。\n2.  **唯一性**：因为 $L(t)$ 是严格单调递增的，所以它不能多次取相同的值。因此，对于任何给定的 $L$，时间 $t_f$ 是唯一的。\n\n因此，问题简化为求解超越方程 $f(t_f) = 0$ 的根，其中：\n$$f(t) = \\left( \\int_{0}^{t} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau \\right) - L$$\n\n完成此任务的一个鲁棒数值算法是求根方法，例如 Brent 方法。该方法非常适合单变量函数，并且如果能找到一个使 $f(a)$ 和 $f(b)$ 异号的括号区间 $[a, b]$，就能保证收敛。\n\n算法设计如下：\n1.  处理平凡情况：如果目标厚度 $L=0$，所需时间为 $t_f=0$。立即返回此值。\n2.  对于 $L0$，如上所述定义函数 $f(t)$。$f(t)$ 中的积分将使用高精度求积方法进行数值计算，例如 `scipy.integrate.quad` 提供的方法。\n3.  为根 $t_f$ 建立一个搜索区间 $[a, b]$。\n    a.  设置下界 $a=0$。此时，$f(0) = L(0) - L = -L  0$。\n    b.  找到一个上界 $b  0$ 使得 $f(b)  0$。由于 $f(t)$ 保证会变为正值，我们可以从一个小的猜测值（例如 1 秒）开始，通过反复加倍直到 $f(b)$ 的符号变为正，来找到 $b$。这确保总能找到一个有效的括号区间。\n4.  使用数值求根求解器（例如，`scipy.optimize.root_scalar` 并设置 `method='brentq'`）在区间 $[a, b]$ 内对函数 $f(t)$ 求解，以找到唯一的根 $t_f$。\n5.  在实现过程中，确保所有参数都转换为一组一致的单位。问题指定了混合单位（$L$ 以纳米计，$v_0$ 以米/秒计）。我们将在内部计算中使用国际单位制（SI）基本单位（米、秒、开尔文）。因此，以纳米为单位的目标厚度 $L$ 必须通过乘以 $10^{-9}$ 转换为米。需要使用单位为 eV/K 的玻尔兹曼常数 $k_\\mathrm{B}$，其值约为 $8.617333 \\times 10^{-5} \\ \\mathrm{eV/K}$。\n\n最终结果 $t_f$ 将以秒为单位，与一致的单位系统相符。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Calculates the time required for solid phase epitaxial regrowth\n    to a target thickness under a linear temperature ramp.\n    \"\"\"\n\n    # Define the Boltzmann constant in eV/K.\n    # The value is taken from CODATA 2018.\n    KB_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T0, beta, v0, Ea, L_nm)\n    # Units: T0 [K], beta [K/s], v0 [m/s], Ea [eV], L_nm [nm]\n    test_cases = [\n        (600.0, 2.0, 1.0e8, 2.7, 100.0),\n        (500.0, 5.0, 1.0e8, 2.7, 0.0),\n        (450.0, 0.2, 1.0e8, 2.7, 50.0),\n        (600.0, 2.0, 1.0e8, 3.2, 100.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        T0, beta, v0, Ea, L_nm = case\n\n        # Trivial case: zero thickness requires zero time.\n        if L_nm == 0.0:\n            results.append(0.0)\n            continue\n\n        # Convert target thickness from nanometers to meters for consistency.\n        L_m = L_nm * 1e-9\n\n        # Define the integrand: regrowth velocity as a function of time tau.\n        # v(T(tau)) = v0 * exp(-Ea / (kB * (T0 + beta * tau)))\n        integrand = lambda tau: v0 * np.exp(-Ea / (KB_EV_PER_K * (T0 + beta * tau)))\n\n        # Define the function whose root we need to find.\n        # f(t) = integral_from_0_to_t(v(tau) dtau) - L_target\n        def objective_function(t):\n            # quad returns a tuple (integral_value, error_estimate)\n            integral_val, _ = quad(integrand, 0, t)\n            return integral_val - L_m\n\n        # Find a suitable bracket [a, b] for the root-finding algorithm.\n        # We know f(0) = -L_m  0, so the lower bound is 0.\n        t_lower = 0.0\n        \n        # Find an upper bound t_upper such that f(t_upper)  0.\n        # Start with a guess and double it until the sign changes.\n        t_upper = 1.0\n        # To prevent potential infinite loops with unusual parameters,\n        # add a reasonable limit to the number of doublings.\n        max_iter = 30 # Corresponds to t_upper up to 2^29 seconds ~ 17 years.\n        iterations = 0\n        while objective_function(t_upper)  0 and iterations  max_iter:\n            t_upper *= 2.0\n            iterations += 1\n        \n        if objective_function(t_upper)  0:\n            # This should not happen for physically reasonable inputs,\n            # as L(t) is guaranteed to grow. Indicates a potential issue.\n            # Handle as an error or by appending a failure code. For this problem,\n            # we assume valid inputs where a bracket can be found.\n            # For robustness, we could raise an exception.\n            raise RuntimeError(\"Could not find a valid bracket for the root.\")\n\n        # Use a robust root-finding algorithm (Brent's method) to solve for t.\n        solution = root_scalar(\n            objective_function, \n            bracket=[t_lower, t_upper], \n            method='brentq'\n        )\n        \n        t_f = solution.root\n        results.append(t_f)\n\n    # Format the results to exactly six decimal places and print.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}