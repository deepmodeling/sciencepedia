{
    "hands_on_practices": [
        {
            "introduction": "The Arrhenius equation provides a powerful macroscopic description of thermally activated processes, but its parameters have deep physical meaning at the atomic scale. This exercise bridges the gap between microscopic theory and macroscopic observation by using an activation barrier, often obtained from atomistic simulations, to calculate the fundamental attempt frequency. By working through this problem , you will gain a concrete understanding of how the collective effect of individual atomic jumps gives rise to the continuous interface velocity measured in experiments.",
            "id": "4165768",
            "problem": "A crystalline silicon wafer with a buried amorphous silicon layer undergoes Solid Phase Epitaxial Regrowth (SPER). Molecular Dynamics (MD) simulations of the rate-limiting bond-switching event yield an atomistic activation barrier of $\\Delta E = 2.5\\ \\text{eV}$. In a kinetic picture consistent with Transition State Theory (TST), each successful barrier-crossing event advances the amorphous/crystalline interface by a characteristic atomic length $\\lambda = 0.27\\ \\text{nm}$, and the macroscopic interface velocity is controlled by these thermally activated events.\n\nAn isothermal experiment at temperature $T = 1000\\ \\text{K}$ measures a steady-state interface velocity of $v = 0.68\\ \\text{nm}\\cdot \\text{s}^{-1}$ for undoped silicon. Starting from first principles of Arrhenius kinetics for a thermally activated process and a coarse-grained relation between discrete atomic advances and a continuous interface velocity, derive an expression for the attempt frequency $\\nu$ in terms of $v$, $\\lambda$, $\\Delta E$, and the Boltzmann constant $k_{B}$, and then compute its value. Use $k_{B} = 8.617333262 \\times 10^{-5}\\ \\text{eV}\\cdot \\text{K}^{-1}$. \n\nRound your final numerical answer to three significant figures. Express the final attempt frequency in $\\text{s}^{-1}$.",
            "solution": "The problem requires the derivation of an expression for the attempt frequency, $\\nu$, and the computation of its numerical value for the process of Solid Phase Epitaxial Regrowth (SPER). The solution is founded upon the principles of Transition State Theory (TST) and Arrhenius kinetics.\n\nThe rate of a thermally activated process, $R$, which in this context is the frequency of successful bond-switching events at the amorphous/crystalline interface, is described by the Arrhenius equation:\n$$R = \\nu \\exp\\left(-\\frac{\\Delta E}{k_{B}T}\\right)$$\nIn this equation, $\\nu$ is the attempt frequency, $\\Delta E$ is the activation energy barrier for the event, $T$ is the absolute temperature, and $k_B$ is the Boltzmann constant. The term $\\exp\\left(-\\frac{\\Delta E}{k_{B}T}\\right)$ is the Boltzmann factor, representing the probability that a system at thermal equilibrium has sufficient energy to overcome the barrier $\\Delta E$.\n\nThe macroscopic interface velocity, $v$, is related to the rate of these discrete microscopic events. The problem states that each successful event advances the interface by a characteristic atomic length, $\\lambda$. Therefore, the continuous velocity $v$ can be expressed as the product of the rate of events, $R$, and the distance advanced per event, $\\lambda$:\n$$v = R \\cdot \\lambda$$\nThis provides a coarse-grained link between the atomistic kinetics and the observable macroscopic regrowth rate.\n\nTo find an expression for the attempt frequency $\\nu$, we combine these two equations. Substituting the expression for $R$ from the Arrhenius equation into the equation for $v$:\n$$v = \\left( \\nu \\exp\\left(-\\frac{\\Delta E}{k_{B}T}\\right) \\right) \\lambda$$\nWe can now algebraically rearrange this expression to solve for $\\nu$:\n$$\\nu = \\frac{v}{\\lambda \\exp\\left(-\\frac{\\Delta E}{k_{B}T}\\right)}$$\nThis expression can be written more elegantly as:\n$$\\nu = \\frac{v}{\\lambda} \\exp\\left(\\frac{\\Delta E}{k_{B}T}\\right)$$\nThis is the required analytical expression for the attempt frequency $\\nu$ in terms of the given parameters $v$, $\\lambda$, $\\Delta E$, $T$, and $k_B$.\n\nNext, we compute the numerical value of $\\nu$ using the provided data:\n- Interface velocity, $v = 0.68\\ \\text{nm}\\cdot \\text{s}^{-1}$\n- Characteristic length, $\\lambda = 0.27\\ \\text{nm}$\n- Activation barrier, $\\Delta E = 2.5\\ \\text{eV}$\n- Temperature, $T = 1000\\ \\text{K}$\n- Boltzmann constant, $k_{B} = 8.617333262 \\times 10^{-5}\\ \\text{eV}\\cdot \\text{K}^{-1}$\n\nFirst, we calculate the thermal energy, $k_{B}T$:\n$$k_{B}T = (8.617333262 \\times 10^{-5}\\ \\text{eV}\\cdot \\text{K}^{-1}) \\times (1000\\ \\text{K}) = 0.08617333262\\ \\text{eV}$$\nThen, we compute the ratio of the activation energy to the thermal energy, which is a dimensionless quantity:\n$$\\frac{\\Delta E}{k_{B}T} = \\frac{2.5\\ \\text{eV}}{0.08617333262\\ \\text{eV}} \\approx 29.01168$$\nWe also calculate the pre-exponential factor from the macroscopic parameters:\n$$\\frac{v}{\\lambda} = \\frac{0.68\\ \\text{nm}\\cdot \\text{s}^{-1}}{0.27\\ \\text{nm}} \\approx 2.5185185\\ \\text{s}^{-1}$$\nThe units of nanometers ($\\text{nm}$) cancel, yielding units of inverse seconds ($\\text{s}^{-1}$), as expected for a frequency.\n\nFinally, we substitute these values into the derived expression for $\\nu$:\n$$\\nu = \\left(\\frac{v}{\\lambda}\\right) \\exp\\left(\\frac{\\Delta E}{k_{B}T}\\right) \\approx (2.5185185\\ \\text{s}^{-1}) \\times \\exp(29.01168)$$\n$$\\nu \\approx (2.5185185\\ \\text{s}^{-1}) \\times (3.987005 \\times 10^{12})$$\n$$\\nu \\approx 1.004137 \\times 10^{13}\\ \\text{s}^{-1}$$\nThe problem requires the final answer to be rounded to three significant figures.\n$$\\nu \\approx 1.00 \\times 10^{13}\\ \\text{s}^{-1}$$\nThis value is physically reasonable, as it is on the order of magnitude of typical phonon frequencies in crystalline solids, which represents the natural frequency scale for atomic vibrations.",
            "answer": "$$\\boxed{1.00 \\times 10^{13}}$$"
        },
        {
            "introduction": "Once we have a kinetic model like the Arrhenius law, we need a robust method to determine its parameters from experimental data. This practice guides you through the essential process of extracting the activation energy ($E_a$) and pre-exponential factor ($v_0$) from a set of velocity-temperature measurements. You will implement a weighted linear regression on a linearized 'Arrhenius plot', a cornerstone technique in chemical kinetics and materials science that accounts for varying measurement uncertainties .",
            "id": "4165824",
            "problem": "You are modeling Solid Phase Epitaxy (SPE) regrowth kinetics of amorphous silicon during annealing. The regrowth front velocity is assumed to obey an Arrhenius law consistent with transition-state theory: there exists an activation energy and a kinetic prefactor such that the temperature dependence of the regrowth velocity is Arrhenius-like. You will estimate the activation energy and prefactor from finite-sample experimental measurements subject to sampling noise. Your task is to design and implement a numerical method that, given a set of temperatures and noisy sample-mean velocity measurements with sample standard deviations and replicate counts, produces statistically efficient estimates together with one-standard-deviation uncertainties that reflect the finite sampling.\n\nFundamental base:\n- The Arrhenius model is widely accepted for thermally activated kinetics. If the SPE regrowth velocity is denoted by $v$, temperature by $T$, activation energy by $E_{a}$, and the kinetic prefactor by $v_{0}$, then the rate model is $v = v_{0} \\exp\\!\\left(-E_{a}/(k_{\\mathrm{B}} T)\\right)$, where $k_{\\mathrm{B}}$ is the Boltzmann constant.\n- For independent replicate measurements at a fixed temperature $T_{i}$, assume the $j$th replicate velocity $v_{ij}$ is an independent draw with finite variance. The reported $v_{i}$ is the sample mean over $n_{i}$ replicates, and $s_{v,i}$ is the sample standard deviation across those replicates. The standard error of the mean is $s_{v,i}/\\sqrt{n_{i}}$.\n- For small relative noise, the uncertainty of the logarithm of the sample mean can be propagated by a first-order Taylor expansion: if $y_{i} = \\ln v_{i}$, then the standard deviation of $y_{i}$ is approximately $\\sigma_{y,i} \\approx \\left(s_{v,i}/\\sqrt{n_{i}}\\right)/v_{i}$.\n\nDesign a method to estimate $E_{a}$ and $v_{0}$ and their one-standard-deviation uncertainties by exploiting the linear relationship that follows from taking the natural logarithm of the Arrhenius equation and using weighted linear regression on the transformed data.\n\nUse the following constants and conventions:\n- Use $k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}$ in units of $\\mathrm{eV/K}$.\n- Temperatures $T$ are in $\\mathrm{K}$.\n- Velocities $v$ and the prefactor $v_{0}$ are in $\\mathrm{nm/s}$.\n- Activation energy $E_{a}$ is to be reported in $\\mathrm{eV}$.\n- One-standard-deviation uncertainties must be reported consistently with these units.\n- Angles are not involved.\n\nTest suite:\nFor each case, you are given arrays of temperatures, sample mean velocities, sample standard deviations, and replicate counts. Treat the reported sample standard deviations as computed from the replicates, and assume independent Gaussian sampling noise for the sample mean. Use the standard error of the mean and first-order uncertainty propagation to define weights for a weighted linear regression in the transformed space.\n\n- Case A (happy path, multiple temperatures, moderate noise):\n  - Temperatures $T_{\\mathrm{A}} = [900, 950, 1000, 1050, 1100, 1150, 1200]$\n  - Sample mean velocities $v_{\\mathrm{A}} = [0.052, 0.095, 0.17, 0.31, 0.55, 0.96, 1.60]$\n  - Sample standard deviations $s_{v,\\mathrm{A}} = [0.005, 0.006, 0.012, 0.02, 0.028, 0.05, 0.08]$\n  - Replicates $n_{\\mathrm{A}} = [8, 8, 8, 8, 8, 8, 8]$\n\n- Case B (boundary condition, only two temperatures, known heteroscedastic noise):\n  - Temperatures $T_{\\mathrm{B}} = [1000, 1200]$\n  - Sample mean velocities $v_{\\mathrm{B}} = [0.20, 1.70]$\n  - Sample standard deviations $s_{v,\\mathrm{B}} = [0.02, 0.10]$\n  - Replicates $n_{\\mathrm{B}} = [5, 5]$\n\n- Case C (heteroscedastic noise, small and varying replicate counts):\n  - Temperatures $T_{\\mathrm{C}} = [950, 975, 1000, 1025, 1050]$\n  - Sample mean velocities $v_{\\mathrm{C}} = [0.090, 0.120, 0.180, 0.230, 0.310]$\n  - Sample standard deviations $s_{v,\\mathrm{C}} = [0.020, 0.015, 0.020, 0.030, 0.050]$\n  - Replicates $n_{\\mathrm{C}} = [3, 3, 2, 4, 3]$\n\nYour program must do the following for each case:\n- Transform the data to the linearized form based on the Arrhenius model.\n- Compute statistically efficient estimates of the slope and intercept using weighted linear regression with weights defined by the inverse variance of the transformed observations.\n- Convert the slope and intercept estimates to $E_{a}$ and $v_{0}$, respectively.\n- Propagate uncertainties to obtain one-standard-deviation uncertainties for $E_{a}$ and $v_{0}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of three inner lists, each inner list being $[E_{a}, u_{E_{a}}, v_{0}, u_{v_{0}}]$ corresponding to Cases A, B, and C in order, where $u_{E_{a}}$ and $u_{v_{0}}$ denote one-standard-deviation uncertainties. The units are $E_{a}$ in $\\mathrm{eV}$ and $v_{0}$ in $\\mathrm{nm/s}$. For example, a valid output structure is of the form $[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]$.",
            "solution": "The problem requires the estimation of the activation energy $E_a$ and the kinetic prefactor $v_0$ for Solid Phase Epitaxial (SPE) regrowth, which is modeled by the Arrhenius equation. We are provided with experimental data consisting of temperatures $T_i$, corresponding sample-mean regrowth velocities $v_i$, the sample standard deviations $s_{v,i}$, and the number of replicates $n_i$ for each measurement point. We must also compute the one-standard-deviation uncertainties for the estimated parameters, $u_{E_a}$ and $u_{v_0}$.\n\nThe specified method is to linearize the Arrhenius model and perform a weighted linear regression on the transformed data. The weights for the regression are to be determined from the measurement uncertainties.\n\n**1. Linearization of the Arrhenius Model**\n\nThe Arrhenius model for the regrowth velocity $v$ as a function of temperature $T$ is given by:\n$$\nv = v_0 \\exp\\left(-\\frac{E_a}{k_{\\mathrm{B}} T}\\right)\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant. Taking the natural logarithm of both sides linearizes the equation:\n$$\n\\ln(v) = \\ln(v_0) - \\frac{E_a}{k_{\\mathrm{B}}} \\frac{1}{T}\n$$\nThis equation is in the form of a straight line, $y = c + mx$, where:\n- The dependent variable is $y_i = \\ln(v_i)$.\n- The independent variable is $x_i = 1/T_i$.\n- The intercept is $c = \\ln(v_0)$.\n- The slope is $m = -E_a/k_{\\mathrm{B}}$.\n\nOur goal is to estimate the parameters $m$ and $c$ from the given data $(T_i, v_i, s_{v,i}, n_i)$.\n\n**2. Weighted Linear Regression**\n\nThe measurements of $v_i$ are noisy. This noise propagates to the transformed variable $y_i = \\ln(v_i)$. We use weighted linear regression (WLR) to account for the fact that a more precise measurement should have a greater influence on the fit. The weights $w_i$ are chosen as the inverse of the variance of the dependent variable, $w_i = 1/\\sigma_{y_i}^2$.\n\nFirst, we determine the uncertainty in $y_i$. The reported data includes the sample mean velocity $v_i$ and its sample standard deviation $s_{v,i}$ from $n_i$ replicates. The standard error of the mean velocity is $\\sigma_{v_i, \\text{mean}} = s_{v,i} / \\sqrt{n_i}$. Using a first-order Taylor expansion for uncertainty propagation for the function $y_i = \\ln(v_i)$, the variance $\\sigma_{y_i}^2$ is approximately:\n$$\n\\sigma_{y_i}^2 \\approx \\left(\\frac{d(\\ln v_i)}{dv_i}\\right)^2 \\sigma_{v_i, \\text{mean}}^2 = \\left(\\frac{1}{v_i}\\right)^2 \\left(\\frac{s_{v,i}}{\\sqrt{n_i}}\\right)^2 = \\frac{s_{v,i}^2}{v_i^2 n_i}\n$$\nTherefore, the weights for the WLR are:\n$$\nw_i = \\frac{1}{\\sigma_{y_i}^2} = \\frac{v_i^2 n_i}{s_{v,i}^2}\n$$\n\nThe WLR problem is to find the parameters $\\hat{m}$ and $\\hat{c}$ that minimize the weighted sum of squared residuals, $\\chi^2$:\n$$\n\\chi^2 = \\sum_{i=1}^{N} w_i (y_i - (c + m x_i))^2\n$$\nThis is a standard problem that can be solved efficiently using matrix algebra. Let $\\mathbf{y}$ be the column vector of observed $y_i$, $\\mathbf{W}$ be the diagonal matrix of weights $w_i$, and $\\mathbf{X}$ be the design matrix:\n$$\n\\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{pmatrix}, \\quad\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix}\n$$\nThe vector of estimated parameters $\\hat{\\boldsymbol{\\beta}} = [\\hat{c}, \\hat{m}]^T$ is given by the normal equations for WLR:\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\nThe covariance matrix of the estimated parameters, $\\mathbf{C}_{\\boldsymbol{\\beta}}$, which contains the variances and covariances of $\\hat{c}$ and $\\hat{m}$, is:\n$$\n\\mathbf{C}_{\\boldsymbol{\\beta}} = \\begin{pmatrix} \\sigma_c^2  \\sigma_{cm} \\\\ \\sigma_{cm}  \\sigma_m^2 \\end{pmatrix} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}\n$$\nThe one-standard-deviation uncertainties for the intercept and slope are the square roots of the diagonal elements of this matrix: $u_c = \\sigma_c = \\sqrt{(\\mathbf{C}_{\\boldsymbol{\\beta}})_{11}}$ and $u_m = \\sigma_m = \\sqrt{(\\mathbf{C}_{\\boldsymbol{\\beta}})_{22}}$.\n\n**3. Calculation of Physical Parameters and Uncertainties**\n\nOnce we have the estimates $\\hat{c}$, $\\hat{m}$ and their uncertainties $u_c$, $u_m$, we can calculate the physical parameters $E_a$ and $v_0$ and propagate the uncertainties.\n\n- **Activation Energy ($E_a$)**:\n  The estimate is derived from the slope $m = -E_a/k_{\\mathrm{B}}$:\n  $$\n  \\hat{E}_a = -\\hat{m} k_{\\mathrm{B}}\n  $$\n  The uncertainty $u_{E_a}$ is found by propagating the uncertainty of the slope, $u_m$:\n  $$\n  u_{E_a} = | -k_{\\mathrm{B}} | u_m = k_{\\mathrm{B}} u_m\n  $$\n\n- **Prefactor ($v_0$)**:\n  The estimate is derived from the intercept $c = \\ln(v_0)$:\n  $$\n  \\hat{v}_0 = \\exp(\\hat{c})\n  $$\n  The uncertainty $u_{v_0}$ is found by propagating the uncertainty of the intercept, $u_c$:\n  $$\n  u_{v_0}^2 \\approx \\left(\\frac{d(\\exp c)}{dc}\\Big|_{c=\\hat{c}}\\right)^2 u_c^2 = (\\exp(\\hat{c}))^2 u_c^2 = \\hat{v}_0^2 u_c^2\n  $$\n  Taking the square root gives the one-standard-deviation uncertainty:\n  $$\n  u_{v_0} \\approx \\hat{v}_0 u_c\n  $$\n\nThis procedure is applied to each of the three test cases provided in the problem statement. The Boltzmann constant is used with its specified value $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV/K}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for Arrhenius parameters and their uncertainties from experimental data\n    using weighted linear regression.\n    \"\"\"\n    \n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, multiple temperatures, moderate noise)\n        {\n            \"T\": np.array([900, 950, 1000, 1050, 1100, 1150, 1200]),\n            \"v\": np.array([0.052, 0.095, 0.17, 0.31, 0.55, 0.96, 1.60]),\n            \"s_v\": np.array([0.005, 0.006, 0.012, 0.02, 0.028, 0.05, 0.08]),\n            \"n\": np.array([8, 8, 8, 8, 8, 8, 8]),\n        },\n        # Case B (boundary condition, only two temperatures, known heteroscedastic noise)\n        {\n            \"T\": np.array([1000, 1200]),\n            \"v\": np.array([0.20, 1.70]),\n            \"s_v\": np.array([0.02, 0.10]),\n            \"n\": np.array([5, 5]),\n        },\n        # Case C (heteroscedastic noise, small and varying replicate counts)\n        {\n            \"T\": np.array([950, 975, 1000, 1025, 1050]),\n            \"v\": np.array([0.090, 0.120, 0.180, 0.230, 0.310]),\n            \"s_v\": np.array([0.020, 0.015, 0.020, 0.030, 0.050]),\n            \"n\": np.array([3, 3, 2, 4, 3]),\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, v, s_v, n = case[\"T\"], case[\"v\"], case[\"s_v\"], case[\"n\"]\n\n        # 1. Transform data for linearization\n        # y = ln(v), x = 1/T\n        x = 1.0 / T\n        y = np.log(v)\n\n        # 2. Calculate weights for Weighted Linear Regression (WLR)\n        # Weight w_i = 1 / sigma_y_i^2\n        # sigma_y_i is approx (sigma_v_mean_i) / v_i\n        # sigma_v_mean_i = s_v_i / sqrt(n_i)\n        # So, sigma_y_i^2 = s_v_i^2 / (v_i^2 * n_i)\n        # And w_i = (v_i^2 * n_i) / s_v_i^2\n        weights = (v**2 * n) / s_v**2\n        W = np.diag(weights)\n\n        # 3. Perform Weighted Linear Regression\n        # Setup the design matrix X for y = c + mx\n        X = np.vstack([np.ones_like(x), x]).T\n        \n        # Calculate (X^T * W * X)\n        XT_W_X = X.T @ W @ X\n        \n        # The covariance matrix of the parameters [c, m] is inv(X^T * W * X)\n        try:\n            cov_beta = np.linalg.inv(XT_W_X)\n        except np.linalg.LinAlgError:\n            # This would happen if X is singular (e.g., all T are the same),\n            # but the test cases are well-behaved.\n            results.append([np.nan] * 4)\n            continue\n            \n        # The parameter vector beta = [c, m] is inv(X^T * W * X) * X^T * W * y\n        beta_hat = cov_beta @ X.T @ W @ y\n        \n        c_hat = beta_hat[0]  # Intercept = ln(v0)\n        m_hat = beta_hat[1]  # Slope = -Ea / k_B\n        \n        # Extract uncertainties (std deviations) from the covariance matrix\n        u_c = np.sqrt(cov_beta[0, 0])\n        u_m = np.sqrt(cov_beta[1, 1])\n        \n        # 4. Convert regression parameters to physical parameters and propagate uncertainty\n        # Activation Energy (E_a)\n        Ea = -m_hat * k_B\n        u_Ea = u_m * k_B\n        \n        # Prefactor (v0)\n        v0 = np.exp(c_hat)\n        # Uncertainty propagation: u_v0 = v0 * u_c\n        u_v0 = v0 * u_c\n        \n        results.append([Ea, u_Ea, v0, u_v0])\n        \n    # Final print statement in the exact required format.\n    # Convert numpy arrays/scalars to native Python floats for clean string representation.\n    final_results = [[float(val) for val in res] for res in results]\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "A complete kinetic model is not just descriptive; it is predictive, allowing us to design and control manufacturing processes. This exercise applies the Arrhenius model to a realistic, non-isothermal scenario: solid phase epitaxy during a linear temperature ramp, a common step in thermal annealing. You will learn how to integrate the rate equation over a time-varying temperature profile and use numerical methods to solve for the total process time needed to achieve a target thickness , a critical task in process simulation.",
            "id": "4165823",
            "problem": "Consider the solid phase epitaxial regrowth in an amorphized semiconductor film under a linear temperature ramp. The regrowth front advances with temperature-dependent velocity described by the Arrhenius relation, where the regrowth velocity $v(T)$ satisfies $v(T) = v_0 \\exp\\!\\left(-\\dfrac{E_a}{k_\\mathrm{B} T}\\right)$, with $v_0$ the pre-exponential factor, $E_a$ the activation energy, and $k_\\mathrm{B}$ the Boltzmann constant. The wafer is annealed with a linear temperature ramp $T(t) = T_0 + \\beta t$, where $T_0$ is the initial temperature and $\\beta$ is the constant ramp rate. The regrown thickness accumulated by time $t$ is $L(t) = \\int_{0}^{t} v\\!\\left(T(\\tau)\\right)\\,\\mathrm{d}\\tau$. You must invert the thickness relation to determine the ramp time $t_f$ required to regrow a target thickness $L$ for given parameters $T_0$, $\\beta$, $v_0$, and $E_a$. The inversion leads to a transcendental equation in $t_f$ that does not reduce to elementary functions and must be solved numerically.\n\nStarting only from the fundamental definitions and well-tested facts stated above, derive the mathematical form of the regrown thickness as a function of time under a linear ramp, identify properties that guarantee existence and uniqueness of $t_f$ for any nonnegative $L$, and design a robust numerical algorithm to compute $t_f$ for arbitrary physically reasonable inputs. Express the final time $t_f$ in seconds. If a case has $L = 0$, return $t_f = 0$.\n\nYour program must implement the algorithm and solve for $t_f$ for each of the following test cases. Use the following units consistently: $T$ in Kelvin, $\\beta$ in Kelvin per second, $v_0$ in meters per second, $E_a$ in electronvolts, and $L$ in nanometers. Use the Boltzmann constant $k_\\mathrm{B}$ in electronvolts per Kelvin. For numerical results, print each $t_f$ as a floating-point number in seconds rounded to exactly six digits after the decimal point.\n\nTest suite:\n- Case $1$: $T_0 = 600 \\ \\mathrm{K}$, $\\beta = 2 \\ \\mathrm{K/s}$, $v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$, $E_a = 2.7 \\ \\mathrm{eV}$, $L = 100 \\ \\mathrm{nm}$.\n- Case $2$ (boundary condition): $T_0 = 500 \\ \\mathrm{K}$, $\\beta = 5 \\ \\mathrm{K/s}$, $v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$, $E_a = 2.7 \\ \\mathrm{eV}$, $L = 0 \\ \\mathrm{nm}$.\n- Case $3$ (slow ramp): $T_0 = 450 \\ \\mathrm{K}$, $\\beta = 0.2 \\ \\mathrm{K/s}$, $v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$, $E_a = 2.7 \\ \\mathrm{eV}$, $L = 50 \\ \\mathrm{nm}$.\n- Case $4$ (higher activation energy): $T_0 = 600 \\ \\mathrm{K}$, $\\beta = 2 \\ \\mathrm{K/s}$, $v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$, $E_a = 3.2 \\ \\mathrm{eV}$, $L = 100 \\ \\mathrm{nm}$.\n\nYour program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets (e.g., $[t_1,t_2,t_3,t_4]$), where each $t_i$ is the computed $t_f$ in seconds rounded to exactly six digits after the decimal point.",
            "solution": "The problem as stated is scientifically sound, well-posed, and internally consistent. All necessary physical laws, mathematical definitions, and numerical parameters are provided to formulate and solve for the required time $t_f$. The physical model is based on the standard Arrhenius kinetics for solid phase epitaxial regrowth, and the annealing process is a common linear temperature ramp. The problem is therefore deemed valid.\n\nThe core of the problem is to determine the time $t_f$ required to achieve a target regrown thickness $L$. This is achieved by solving the equation $L(t_f) = L$, where $L(t)$ is the accumulated thickness as a function of time.\n\nThe velocity of the regrowth front, $v$, is a function of temperature $T$ and is given by the Arrhenius relation:\n$$v(T) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} T}\\right)$$\nwhere $v_0$ is the pre-exponential factor, $E_a$ is the activation energy, and $k_\\mathrm{B}$ is the Boltzmann constant.\n\nThe temperature $T$ changes over time $t$ according to a linear ramp:\n$$T(t) = T_0 + \\beta t$$\nwhere $T_0$ is the initial temperature and $\\beta$ is the constant ramp rate. For this relation to be physically meaningful for $t \\ge 0$, we must have $T_0  0$ and $\\beta \\ge 0$. The provided test cases satisfy these conditions.\n\nThe total regrown thickness $L(t)$ accumulated up to time $t$ is the time integral of the velocity. By substituting the expression for the temperature ramp $T(\\tau)$ into the velocity equation $v(T)$, we obtain the velocity as an explicit function of time $\\tau$:\n$$v(T(\\tau)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right)$$\nThe accumulated thickness at a final time $t_f$ is then given by the definite integral:\n$$L(t_f) = \\int_{0}^{t_f} v(T(\\tau)) \\, \\mathrm{d}\\tau = \\int_{0}^{t_f} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau$$\n\nTo find the time $t_f$ required to grow a specific thickness $L$, we must solve the following equation for $t_f$:\n$$L = \\int_{0}^{t_f} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau$$\n\nThis integral does not have a closed-form solution in terms of elementary functions. It can be expressed using the exponential integral special function $E_n(x)$, but for numerical computation, it is often more direct and robust to handle the integral numerically.\n\nBefore designing an algorithm, we must establish the existence and uniqueness of the solution $t_f$ for any given non-negative target thickness $L$. Let us analyze the function $L(t_f)$.\nThe integrand, $v(T(\\tau)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right)$, is a strictly positive function for all physical parameters ($v_0  0, E_a  0, k_\\mathrm{B}  0, T_0  0, \\beta \\ge 0$) and for all $\\tau \\ge 0$.\nThe derivative of $L(t)$ with respect to time $t$ is, by the Fundamental Theorem of Calculus:\n$$\\frac{\\mathrm{d}L}{\\mathrm{d}t} = v(T(t)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta t)}\\right)$$\nSince $v(T(t))  0$ for all $t \\ge 0$, the function $L(t)$ is strictly monotonically increasing for $t \\ge 0$.\nFurthermore, at the initial time $t=0$, the accumulated thickness is zero: $L(0) = \\int_{0}^{0} \\dots \\, \\mathrm{d}\\tau = 0$.\n\nThese properties guarantee the existence and uniqueness of the solution:\n1.  **Existence**: Since $L(0) = 0$ and $L(t)$ is continuous and increases without bound as $t \\to \\infty$, the Intermediate Value Theorem guarantees that for any target thickness $L \\ge 0$, there exists at least one time $t_f \\ge 0$ such that $L(t_f) = L$.\n2.  **Uniqueness**: Because $L(t)$ is strictly monotonically increasing, it cannot take the same value more than once. Therefore, the time $t_f$ for any given $L$ is unique.\n\nThe problem thus reduces to finding the root of the transcendental equation $f(t_f) = 0$, where:\n$$f(t) = \\left( \\int_{0}^{t} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau \\right) - L$$\n\nA robust numerical algorithm for this task is a root-finding method, such as Brent's method, which is well-suited for single-variable functions and guarantees convergence if a bracketing interval $[a, b]$ (where $f(a)$ and $f(b)$ have opposite signs) is found.\n\nThe algorithm design is as follows:\n1.  Handle the trivial case: If the target thickness $L=0$, the required time is $t_f=0$. Return this value immediately.\n2.  For $L0$, define the function $f(t)$ as specified above. The integral within $f(t)$ will be computed numerically using a high-precision quadrature method, such as the one provided by `scipy.integrate.quad`.\n3.  Establish a search bracket $[a, b]$ for the root $t_f$.\n    a.  Set the lower bound $a=0$. At this point, $f(0) = L(0) - L = -L  0$.\n    b.  Find an upper bound $b  0$ such that $f(b)  0$. Since $f(t)$ is guaranteed to become positive, we can find $b$ by starting with a small guess (e.g., $1$ second) and repeatedly doubling it until the sign of $f(b)$ becomes positive. This ensures a valid bracket is always found.\n4.  Use a numerical root-finding solver (e.g., `scipy.optimize.root_scalar` with `method='brentq'`) on the function $f(t)$ within the bracket $[a, b]$ to find the unique root $t_f$.\n5.  During implementation, ensure all parameters are converted to a consistent set of units. The problem specifies a mix of units ($L$ in nm, $v_0$ in m/s). We will use base SI units internally for calculations (meters, seconds, Kelvin). Therefore, the target thickness $L$ given in nanometers must be converted to meters by multiplying by $10^{-9}$. The Boltzmann constant $k_\\mathrm{B}$ in units of eV/K is required, which is approximately $8.617333 \\times 10^{-5} \\ \\mathrm{eV/K}$.\n\nThe final result $t_f$ will be in seconds, as per the consistent unit system.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Calculates the time required for solid phase epitaxial regrowth\n    to a target thickness under a linear temperature ramp.\n    \"\"\"\n\n    # Define the Boltzmann constant in eV/K.\n    # The value is taken from CODATA 2018.\n    KB_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T0, beta, v0, Ea, L_nm)\n    # Units: T0 [K], beta [K/s], v0 [m/s], Ea [eV], L_nm [nm]\n    test_cases = [\n        (600.0, 2.0, 1.0e8, 2.7, 100.0),\n        (500.0, 5.0, 1.0e8, 2.7, 0.0),\n        (450.0, 0.2, 1.0e8, 2.7, 50.0),\n        (600.0, 2.0, 1.0e8, 3.2, 100.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        T0, beta, v0, Ea, L_nm = case\n\n        # Trivial case: zero thickness requires zero time.\n        if L_nm == 0.0:\n            results.append(0.0)\n            continue\n\n        # Convert target thickness from nanometers to meters for consistency.\n        L_m = L_nm * 1e-9\n\n        # Define the integrand: regrowth velocity as a function of time tau.\n        # v(T(tau)) = v0 * exp(-Ea / (kB * (T0 + beta * tau)))\n        integrand = lambda tau: v0 * np.exp(-Ea / (KB_EV_PER_K * (T0 + beta * tau)))\n\n        # Define the function whose root we need to find.\n        # f(t) = integral_from_0_to_t(v(tau) dtau) - L_target\n        def objective_function(t):\n            # quad returns a tuple (integral_value, error_estimate)\n            integral_val, _ = quad(integrand, 0, t)\n            return integral_val - L_m\n\n        # Find a suitable bracket [a, b] for the root-finding algorithm.\n        # We know f(0) = -L_m  0, so the lower bound is 0.\n        t_lower = 0.0\n        \n        # Find an upper bound t_upper such that f(t_upper)  0.\n        # Start with a guess and double it until the sign changes.\n        t_upper = 1.0\n        # To prevent potential infinite loops with unusual parameters,\n        # add a reasonable limit to the number of doublings.\n        max_iter = 30 # Corresponds to t_upper up to 2^29 seconds ~ 17 years.\n        iterations = 0\n        while objective_function(t_upper)  0 and iterations  max_iter:\n            t_upper *= 2.0\n            iterations += 1\n        \n        if objective_function(t_upper)  0:\n            # This should not happen for physically reasonable inputs,\n            # as L(t) is guaranteed to grow. Indicates a potential issue.\n            # Handle as an error or by appending a failure code. For this problem,\n            # we assume valid inputs where a bracket can be found.\n            # For robustness, we could raise an exception.\n            raise RuntimeError(\"Could not find a valid bracket for the root.\")\n\n        # Use a robust root-finding algorithm (Brent's method) to solve for t.\n        solution = root_scalar(\n            objective_function, \n            bracket=[t_lower, t_upper], \n            method='brentq'\n        )\n        \n        t_f = solution.root\n        results.append(t_f)\n\n    # Format the results to exactly six decimal places and print.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}