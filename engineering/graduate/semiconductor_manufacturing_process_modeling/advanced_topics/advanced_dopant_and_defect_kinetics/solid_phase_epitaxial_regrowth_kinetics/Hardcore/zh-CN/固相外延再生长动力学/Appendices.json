{
    "hands_on_practices": [
        {
            "introduction": "在对固相外延再生长进行建模时，首要任务是选择一个能准确反映其物理过程的动力学模型。许多相变过程遵循复杂的成核与生长机制，可以用约翰逊-梅尔-阿弗拉米-科尔莫戈罗夫(JMAK)方程等模型来描述，但固相外延再生长具有其独特性。本练习  旨在通过对比分析，帮助您理解为何对于由单一平面界面推进的理想固相外延再生长过程，一个简单的线性界面速度模型是恰当的，而基于随机成核的JMAK模型则不适用，从而掌握模型选择的基本原则。",
            "id": "4165774",
            "problem": "考虑在均匀温度 $T$ 下，厚度为 $d$ 的非晶硅层在晶态硅上进行固相外延（SPE）。再结晶从单一、平面的非晶/晶态界面开始，在整个晶圆区域上进行，界面前方没有发生体形核。该过程可以理想化为在恒定温度 $T$ 下由界面控制，没有长程扩散限制，且应力或杂质效应可忽略不计。结晶分数定义为结晶体积与总层体积之比。\n\n选择最准确地指明了结晶分数的 Johnson-Mehl-Avrami-Kolmogorov (JMAK) 描述，解释了为何它不适用于指定条件下的 SPE，并为厚度和分数随时间的演化提出了一个物理上一致的动力学模型的选项。\n\nA. JMAK 分数为 $X(t)=1-\\exp(-K t)$，其中指数 $n=1$ 对应一维推进，因此它直接适用于单个 SPE 界面。所以，转变分数随时间呈指数关系，再生长厚度遵循 $x(t)=d\\,X(t)=d\\left[1-\\exp(-K t)\\right]$。\n\nB. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，它假设随机的体形核和生长。它不适用于单界面 SPE，因为没有形核，且相变通过确定性的界面传播进行。在恒定温度 $T$ 下的界面控制动力学中，界面速度符合 Arrhenius 关系，$v(T)=v_0\\exp\\!\\left(-E_a/(k_B T)\\right)$，因此再生长厚度为 $x(t)=v(T)\\,t$，分数为 $X(t)=x(t)/d=v(T)\\,t/d$，直到在 $t_f=d/v(T)$ 时完成。\n\nC. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，但它对 SPE 不适用，因为 SPE 是扩散受限的，所以再生长厚度必须遵循抛物线定律 $x(t)=\\sqrt{D t}$，分数为 $X(t)=x(t)/d=\\sqrt{t/t_f}$，其中 $D$ 是有效扩散系数，$t_f=d^2/D$。\n\nD. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，但单界面 SPE 更适合用逻辑斯谛定律 $X(t)=1/\\left[1+\\exp\\!\\left(-\\alpha(t-t_0)\\right)\\right]$ 来描述，该定律模拟了饱和过程；因此 $x(t)=d\\,X(t)$ 提供了一致的厚度演化。\n\nE. JMAK 分数为 $X(t)=1-\\exp(-K t^n)$，但设置 $n=0$ 可以消除形核以匹配单界面 SPE。然后，厚度由于驱动力而加速，$x(t)=\\tfrac{1}{2}a t^2$，得到 $X(t)=x(t)/d$，其中恒定加速度 $a$ 由界面自由能差决定。",
            "solution": "问题陈述描述了非晶硅层在晶态硅衬底上的固相外延（SPE）再生长。必须首先评估该陈述的有效性。\n\n**问题验证**\n\n**步骤 1：提取给定条件**\n- 过程：非晶硅层在晶态硅上的固相外延（SPE）。\n- 初始非晶层厚度：`$d$`。\n- 温度：均匀且恒定，`$T$`。\n- 生长几何形状：从单一、平面的非晶/晶态界面开始。\n- 形核约束：界面前方无体形核。\n- 动力学控制：理想化为在恒定 `$T$` 下由界面控制。\n- 输运约束：无长程扩散限制。\n- 其他约束：应力或杂质效应可忽略不计。\n- 定义：结晶分数 `$X$` 是结晶体积与总层体积之比。对于平面界面，这等同于再生长厚度 `$x$` 与初始厚度 `$d$` 之比，因此 `$X = x/d$`。\n- 问题：选择一个选项，该选项正确指明了 Johnson-Mehl-Avrami-Kolmogorov (JMAK) 描述，解释了其为何不适用于指定的 SPE 过程，并为厚度 `$x(t)$` 和分数 `$X(t)$` 的演化提出了一个物理上一致的动力学模型。\n\n**步骤 2：使用提取的给定条件进行验证**\n- **科学依据：** 该问题描述了一个公认的材料科学过程。SPE、界面控制动力学、Arrhenius 行为和 JMAK 理论等概念都是研究固相相变的基础。该设置是过程建模中使用的标准、物理上现实的理想化模型。\n- **适定性：** 问题表述清晰。它提供了一个特定的物理场景，并要求从一组选项中选择正确的理论描述。所提供的约束条件足以在选项中唯一确定正确的物理模型。\n- **客观性：** 语言是先验中立、精确的，并且没有主观内容。诸如“平面界面”、“界面控制”和“无体形核”等术语在此背景下具有特定、明确的含义。\n- **不完整或矛盾的设置：** 问题陈述是自洽的，并提供了所有必要的信息。“界面控制”和“无长程扩散限制”的条件是一致且互补的。“单一、平面界面”和“无体形核”的条件定义了一种特定的生长模式（层状生长或 Frank-van der Merwe 型生长，尽管简化为一维推进）。没有矛盾之处。\n- **不切实际或不可行：** 这些条件描述了一个有效但理想化的高纯度硅 SPE 的物理体系。\n\n**步骤 3：结论与行动**\n问题陈述有效。它在科学上是合理的、适定的且内部一致的。可以继续进行求解过程。\n\n**推导与选项分析**\n\n核心的先验分析如下：\n1.  **JMAK 模型：** Johnson-Mehl-Avrami-Kolmogorov (JMAK) 理论描述了通过形核和生长过程进行的相变的整体动力学。转变体积分数 `$X(t)$` 作为时间 `$t$` 的函数的通用表达式为：\n    $$X(t) = 1 - \\exp(-K t^n)$$\n    这里，`$K$` 是一个依赖于温度的速率常数，`$n$` 是 Avrami 指数，它取决于生长的维度和形核速率的时间依赖性。JMAK 模型的关键物理基础是新相区域的随机空间形核及其随后的生长，直到与相邻区域发生碰撞。指数形式的出现是由于对这种碰撞进行了统计学处理。\n\n2.  **对 SPE 的适用性：** 问题指定再生长从*单一、平面界面*开始，并且*没有体形核*。这种情况与 JMAK 模型的假设有着根本的不同。没有随机的形核事件；相变前沿是一个单一、预先存在且确定性推进的平面。因此，作为 JMAK 理论核心的对碰撞的统计处理在此不适用。JMAK 模型不是对此特定过程的正确物理描述。\n\n3.  **SPE 的物理一致模型：** 问题指出该过程是在*恒定温度* `$T$` 下*由界面控制*。这意味着限速步骤是发生在非晶/晶态界面本身的原子重排过程。对于在恒定温度和恒定驱动力（非晶相和晶相之间的自由能差）下的热激活过程，过程的速率是恒定的。这里的相关速率是界面速度 `$v$`。该速度由 Arrhenius 方程描述：\n    $$v(T) = v_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)$$\n    其中 `$v_0$` 是指前因子，`$E_a$` 是再生长的活化能，`$k_B$` 是玻尔兹曼常数。由于速度 `$v(T)$` 相对于时间是恒定的，再生长晶体层的厚度 `$x(t)$` 随时间 `$t$` 线性增加，从 `$x(0)=0$` 开始：\n    $$x(t) = v(T) \\cdot t$$\n    这种线性生长一直持续到整个非晶层被消耗完，即直到 `$x(t) = d$`。结晶分数 `$X(t)$` 是再生长厚度与总初始厚度 `$d$` 的比值：\n    $$X(t) = \\frac{x(t)}{d} = \\frac{v(T)}{d} t$$\n    `$X(t)$` 的这种线性关系在 `$0 \\le t \\le t_f$` 范围内有效，其中完成时间为 `$t_f = d/v(T)$`。当 `$t \\ge t_f$` 时，`$x(t)=d$` 且 `$X(t)=1$`。\n\n现在，我们基于这一理解来评估每个选项。\n\n**选项 A：** 该选项声称具有 `$n=1$` 的 JMAK 模型 `$X(t)=1-\\exp(-K t)$` 直接适用。这是不正确的。虽然 JMAK 中的 `$n=1$` 可以对应于从预先存在的核进行的一维生长，但函数形式 `$X(t)=1-\\exp(-K t)$` 意味着再生长速度 `$v(t) = dx/dt = d \\cdot dX/dt = dK\\exp(-Kt)$` 随时间*指数级下降*。这与在恒定温度下由界面控制的过程所预期的恒定速度相矛盾。\n**结论：不正确。**\n\n**选项 B：** 该选项正确地指出了通用的 JMAK 形式 `$X(t)=1-\\exp(-K t^n)$` 及其在“随机体形核和生长”中的物理基础。它正确地解释了 JMAK 不适用于单界面 SPE，因为“没有形核”且生长是“确定性的界面传播”。然后，它正确地提出，对于恒定 `$T$` 下的界面控制动力学，速度 `$v(T)$` 是恒定的（由 Arrhenius 定律给出），导致厚度线性增加 `$x(t)=v(T)t$`，分数也线性增加 `$X(t)=x(t)/d = v(T)t/d$`。这个分析与第一性原理推导完全一致。\n**结论：正确。**\n\n**选项 C：** 该选项声称 SPE 是扩散受限的，这直接与问题陈述“无长程扩散限制”和“界面控制”相矛盾。所提出的抛物线生长定律 `$x(t)=\\sqrt{D t}$` 是扩散受限过程的特征，而这一点已被明确排除。\n**结论：不正确。**\n\n**选项 D：** 该选项为分数提出了一个逻辑斯谛定律，`$X(t)=1/\\left[1+\\exp\\!\\left(-\\alpha(t-t_0)\\right)\\right]$`。这个函数描述了 S 形（sigmoidal）生长，其中速率 `$dX/dt$` 最初很慢，然后加速，最后减速。虽然在某些复杂的相变中可以观察到这种动力学，但它与问题约束条件下（恒定 `$T$` 下的界面控制）预期的简单、恒定速度的生长不符。恒速过程具有恒定的速率 `$dX/dt$`，导致分数的线性增长，而非 S 形增长。\n**结论：不正确。**\n\n**选项 E：** 该选项建议在 JMAK 方程中设置 Avrami 指数 `$n=0$` 来模拟 SPE。设置 `$n=0$` 会得到 `$X(t) = 1-\\exp(-K)$`，这是一个常数值，而不是描述随时间演化的动力学定律。这是无稽之谈。它接着提出了一个恒定加速度的模型，`$x(t)=\\tfrac{1}{2}a t^2$`，这意味着速度 `$v(t) = at$` 随时间线性增加。问题陈述没有为在恒定温度和驱动力下出现这种加速度提供任何物理基础。对于界面控制的热激活过程，模型是恒定速度。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "固相外延再生长的速率由阿伦尼乌斯关系 $v = v_{0} \\exp(-E_{a}/(k_{\\mathrm{B}} T))$ 描述，其核心是活化能 $E_a$ 和指前因子 $v_0$ 这两个关键参数，而这些参数必须通过实验测量来确定。本练习  将指导您完成从含噪声的实验数据中提取这些动力学参数的全过程，这是一个标准的阿伦尼乌斯分析。您将学习如何通过对数变换将模型线性化，并使用加权线性回归来精确地处理测量不确定性，这是实验科学家和工程师必备的核心数据处理技能。",
            "id": "4165824",
            "problem": "您正在对退火过程中非晶硅的固相外延（SPE）再生长动力学进行建模。假设再生长前沿速度遵循与过渡态理论一致的阿伦尼乌斯定律：存在一个活化能和一个动力学指前因子，使得再生长速度的温度依赖性呈阿伦尼乌斯形式。您将根据受采样噪声影响的有限样本实验测量值来估计活化能和指前因子。您的任务是设计并实现一种数值方法，该方法在给定一组温度、带有样本标准差和重复次数的含噪声样本平均速度测量值的情况下，能够生成统计上有效的估计值以及反映有限采样的单标准差不确定度。\n\n基本原理：\n- 阿伦尼乌斯模型被广泛用于描述热激活过程的动力学。如果SPE再生长速度表示为$v$，温度为$T$，活化能为$E_{a}$，动力学指前因子为$v_{0}$，则速率模型为 $v = v_{0} \\exp\\!\\left(-E_{a}/(k_{\\mathrm{B}} T)\\right)$，其中$k_{\\mathrm{B}}$是玻尔兹曼常数。\n- 对于在固定温度$T_{i}$下进行的独立重复测量，假设第$j$次重复测量的速度$v_{ij}$是一个具有有限方差的独立抽取样本。报告的$v_{i}$是$n_{i}$次重复测量的样本均值，$s_{v,i}$是这些重复测量的样本标准差。均值的标准误为$s_{v,i}/\\sqrt{n_{i}}$。\n- 对于较小的相对噪声，样本均值对数的不确定度可以通过一阶泰勒展开进行传播：如果$y_{i} = \\ln v_{i}$，那么$y_{i}$的标准差约为 $\\sigma_{y,i} \\approx \\left(s_{v,i}/\\sqrt{n_{i}}\\right)/v_{i}$。\n\n设计一种方法，通过利用阿伦尼乌斯方程取自然对数后得到的线性关系，并对变换后的数据使用加权线性回归，来估计$E_{a}$和$v_{0}$及其单标准差不确定度。\n\n使用以下常量和约定：\n- 使用$k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}$，单位为$\\mathrm{eV/K}$。\n- 温度$T$的单位是$\\mathrm{K}$。\n- 速度$v$和指前因子$v_{0}$的单位是$\\mathrm{nm/s}$。\n- 活化能$E_{a}$需以$\\mathrm{eV}$为单位报告。\n- 单标准差不确定度必须以与这些单位一致的方式报告。\n- 不涉及角度。\n\n测试套件：\n对于每种情况，您都会得到温度、样本平均速度、样本标准差和重复次数的数组。将报告的样本标准差视为从重复测量中计算得出，并假设样本均值具有独立的高斯采样噪声。使用均值标准误和一阶不确定度传播来定义变换空间中加权线性回归的权重。\n\n- 情况 A（正常路径，多个温度，中等噪声）：\n  - 温度 $T_{\\mathrm{A}} = [900, 950, 1000, 1050, 1100, 1150, 1200]$\n  - 样本平均速度 $v_{\\mathrm{A}} = [0.052, 0.095, 0.17, 0.31, 0.55, 0.96, 1.60]$\n  - 样本标准差 $s_{v,\\mathrm{A}} = [0.005, 0.006, 0.012, 0.02, 0.028, 0.05, 0.08]$\n  - 重复次数 $n_{\\mathrm{A}} = [8, 8, 8, 8, 8, 8, 8]$\n\n- 情况 B（边界条件，仅两个温度，已知异方差噪声）：\n  - 温度 $T_{\\mathrm{B}} = [1000, 1200]$\n  - 样本平均速度 $v_{\\mathrm{B}} = [0.20, 1.70]$\n  - 样本标准差 $s_{v,\\mathrm{B}} = [0.02, 0.10]$\n  - 重复次数 $n_{\\mathrm{B}} = [5, 5]$\n\n- 情况 C（异方差噪声，重复次数少且多变）：\n  - 温度 $T_{\\mathrm{C}} = [950, 975, 1000, 1025, 1050]$\n  - 样本平均速度 $v_{\\mathrm{C}} = [0.090, 0.120, 0.180, 0.230, 0.310]$\n  - 样本标准差 $s_{v,\\mathrm{C}} = [0.020, 0.015, 0.020, 0.030, 0.050]$\n  - 重复次数 $n_{\\mathrm{C}} = [3, 3, 2, 4, 3]$\n\n您的程序必须为每种情况执行以下操作：\n- 根据阿伦尼乌斯模型将数据转换为线性化形式。\n- 使用由变换后观测值方差的倒数定义的权重，通过加权线性回归计算斜率和截距的统计有效估计值。\n- 将斜率和截距的估计值分别转换为$E_{a}$和$v_{0}$。\n- 传播不确定度，以获得$E_{a}$和$v_{0}$的单标准差不确定度。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由三个内部列表组成的逗号分隔列表，每个内部列表的格式为$[E_{a}, u_{E_{a}}, v_{0}, u_{v_{0}}]$，按顺序对应情况 A、B 和 C，其中$u_{E_{a}}$和$u_{v_{0}}$表示单标准差不确定度。$E_{a}$的单位是$\\mathrm{eV}$，$v_{0}$的单位是$\\mathrm{nm/s}$。例如，一个有效的输出结构形式为$[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]$。",
            "solution": "该问题要求估算固相外延（SPE）再生长的活化能$E_a$和动力学指前因子$v_0$，其过程由阿伦尼乌斯方程建模。我们获得了实验数据，包括每个测量点的温度$T_i$、对应的样本平均再生长速度$v_i$、样本标准差$s_{v,i}$以及重复测量次数$n_i$。我们还必须计算估计参数的单标准差不确定度$u_{E_a}$和$u_{v_0}$。\n\n指定的方法是线性化阿伦尼乌斯模型，并对变换后的数据执行加权线性回归。回归的权重将根据测量不确定度来确定。\n\n**1. 阿伦尼乌斯模型的线性化**\n\n再生长速度$v$作为温度$T$的函数的阿伦尼乌斯模型由下式给出：\n$$\nv = v_0 \\exp\\left(-\\frac{E_a}{k_{\\mathrm{B}} T}\\right)\n$$\n其中$k_{\\mathrm{B}}$是玻尔兹曼常数。对两边取自然对数可将方程线性化：\n$$\n\\ln(v) = \\ln(v_0) - \\frac{E_a}{k_{\\mathrm{B}}} \\frac{1}{T}\n$$\n该方程是直线形式$y = c + mx$，其中：\n- 因变量为$y_i = \\ln(v_i)$。\n- 自变量为$x_i = 1/T_i$。\n- 截距为$c = \\ln(v_0)$。\n- 斜率为$m = -E_a/k_{\\mathrm{B}}$。\n\n我们的目标是根据给定数据$(T_i, v_i, s_{v,i}, n_i)$估计参数$m$和$c$。\n\n**2. 加权线性回归**\n\n$v_i$的测量值含有噪声。这种噪声会传播到变换后的变量$y_i = \\ln(v_i)$中。我们使用加权线性回归（WLR）来考虑更精确的测量应对拟合产生更大影响这一事实。权重$w_i$选择为因变量方差的倒数，即$w_i = 1/\\sigma_{y_i}^2$。\n\n首先，我们确定$y_i$中的不确定度。报告的数据包括来自$n_i$次重复测量的样本平均速度$v_i$及其样本标准差$s_{v,i}$。平均速度的标准误为$\\sigma_{v_i, \\text{mean}} = s_{v,i} / \\sqrt{n_i}$。对于函数$y_i = \\ln(v_i)$，使用一阶泰勒展开进行不确定度传播，方差$\\sigma_{y_i}^2$近似为：\n$$\n\\sigma_{y_i}^2 \\approx \\left(\\frac{d(\\ln v_i)}{dv_i}\\right)^2 \\sigma_{v_i, \\text{mean}}^2 = \\left(\\frac{1}{v_i}\\right)^2 \\left(\\frac{s_{v,i}}{\\sqrt{n_i}}\\right)^2 = \\frac{s_{v,i}^2}{v_i^2 n_i}\n$$\n因此，WLR的权重为：\n$$\nw_i = \\frac{1}{\\sigma_{y_i}^2} = \\frac{v_i^2 n_i}{s_{v,i}^2}\n$$\n\nWLR问题旨在找到使加权残差平方和$\\chi^2$最小化的参数$\\hat{m}$和$\\hat{c}$：\n$$\n\\chi^2 = \\sum_{i=1}^{N} w_i (y_i - (c + m x_i))^2\n$$\n这是一个标准问题，可以使用矩阵代数高效求解。设$\\mathbf{y}$为观测值$y_i$的列向量，$\\mathbf{W}$为权重$w_i$的对角矩阵，$\\mathbf{X}$为设计矩阵：\n$$\n\\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{pmatrix}, \\quad\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix}\n$$\n估计参数的向量$\\hat{\\boldsymbol{\\beta}} = [\\hat{c}, \\hat{m}]^T$由WLR的法方程给出：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n估计参数的协方差矩阵$\\mathbf{C}_{\\boldsymbol{\\beta}}$包含$\\hat{c}$和$\\hat{m}$的方差和协方差，其形式为：\n$$\n\\mathbf{C}_{\\boldsymbol{\\beta}} = \\begin{pmatrix} \\sigma_c^2  \\sigma_{cm} \\\\ \\sigma_{cm}  \\sigma_m^2 \\end{pmatrix} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}\n$$\n截距和斜率的单标准差不确定度是该矩阵对角线元素的平方根：$u_c = \\sigma_c = \\sqrt{(\\mathbf{C}_{\\boldsymbol{\\beta}})_{11}}$和$u_m = \\sigma_m = \\sqrt{(\\mathbf{C}_{\\boldsymbol{\\beta}})_{22}}$。\n\n**3. 物理参数及其不确定度的计算**\n\n一旦我们得到了估计值$\\hat{c}$、$\\hat{m}$及其不确定度$u_c$、$u_m$，我们就可以计算物理参数$E_a$和$v_0$并传播不确定度。\n\n- **活化能 ($E_a$)**：\n  估计值由斜率$m = -E_a/k_{\\mathrm{B}}$导出：\n  $$\n  \\hat{E}_a = -\\hat{m} k_{\\mathrm{B}}\n  $$\n  不确定度$u_{E_a}$通过传播斜率的不确定度$u_m$得到：\n  $$\n  u_{E_a} = | -k_{\\mathrm{B}} | u_m = k_{\\mathrm{B}} u_m\n  $$\n\n- **指前因子 ($v_0$)**：\n  估计值由截距$c = \\ln(v_0)$导出：\n  $$\n  \\hat{v}_0 = \\exp(\\hat{c})\n  $$\n  不确定度$u_{v_0}$通过传播截距的不确定度$u_c$得到：\n  $$\n  u_{v_0}^2 \\approx \\left(\\frac{d(\\exp c)}{dc}\\Big|_{c=\\hat{c}}\\right)^2 u_c^2 = (\\exp(\\hat{c}))^2 u_c^2 = \\hat{v}_0^2 u_c^2\n  $$\n  取平方根得到单标准差不确定度：\n  $$\n  u_{v_0} \\approx \\hat{v}_0 u_c\n  $$\n\n将此过程应用于问题陈述中提供的三个测试用例。玻尔兹曼常数使用其指定值$k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV/K}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for Arrhenius parameters and their uncertainties from experimental data\n    using weighted linear regression.\n    \"\"\"\n    \n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, multiple temperatures, moderate noise)\n        {\n            \"T\": np.array([900, 950, 1000, 1050, 1100, 1150, 1200]),\n            \"v\": np.array([0.052, 0.095, 0.17, 0.31, 0.55, 0.96, 1.60]),\n            \"s_v\": np.array([0.005, 0.006, 0.012, 0.02, 0.028, 0.05, 0.08]),\n            \"n\": np.array([8, 8, 8, 8, 8, 8, 8]),\n        },\n        # Case B (boundary condition, only two temperatures, known heteroscedastic noise)\n        {\n            \"T\": np.array([1000, 1200]),\n            \"v\": np.array([0.20, 1.70]),\n            \"s_v\": np.array([0.02, 0.10]),\n            \"n\": np.array([5, 5]),\n        },\n        # Case C (heteroscedastic noise, small and varying replicate counts)\n        {\n            \"T\": np.array([950, 975, 1000, 1025, 1050]),\n            \"v\": np.array([0.090, 0.120, 0.180, 0.230, 0.310]),\n            \"s_v\": np.array([0.020, 0.015, 0.020, 0.030, 0.050]),\n            \"n\": np.array([3, 3, 2, 4, 3]),\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, v, s_v, n = case[\"T\"], case[\"v\"], case[\"s_v\"], case[\"n\"]\n\n        # 1. Transform data for linearization\n        # y = ln(v), x = 1/T\n        x = 1.0 / T\n        y = np.log(v)\n\n        # 2. Calculate weights for Weighted Linear Regression (WLR)\n        # Weight w_i = 1 / sigma_y_i^2\n        # sigma_y_i is approx (sigma_v_mean_i) / v_i\n        # sigma_v_mean_i = s_v_i / sqrt(n_i)\n        # So, sigma_y_i^2 = s_v_i^2 / (v_i^2 * n_i)\n        # And w_i = (v_i^2 * n_i) / s_v_i^2\n        weights = (v**2 * n) / s_v**2\n        W = np.diag(weights)\n\n        # 3. Perform Weighted Linear Regression\n        # Setup the design matrix X for y = c + mx\n        X = np.vstack([np.ones_like(x), x]).T\n        \n        # Calculate (X^T * W * X)\n        XT_W_X = X.T @ W @ X\n        \n        # The covariance matrix of the parameters [c, m] is inv(X^T * W * X)\n        try:\n            cov_beta = np.linalg.inv(XT_W_X)\n        except np.linalg.LinAlgError:\n            # This would happen if X is singular (e.g., all T are the same),\n            # but the test cases are well-behaved.\n            results.append([np.nan] * 4)\n            continue\n            \n        # The parameter vector beta = [c, m] is inv(X^T * W * X) * X^T * W * y\n        beta_hat = cov_beta @ X.T @ W @ y\n        \n        c_hat = beta_hat[0]  # Intercept = ln(v0)\n        m_hat = beta_hat[1]  # Slope = -Ea / k_B\n        \n        # Extract uncertainties (std deviations) from the covariance matrix\n        u_c = np.sqrt(cov_beta[0, 0])\n        u_m = np.sqrt(cov_beta[1, 1])\n        \n        # 4. Convert regression parameters to physical parameters and propagate uncertainty\n        # Activation Energy (E_a)\n        Ea = -m_hat * k_B\n        u_Ea = u_m * k_B\n        \n        # Prefactor (v0)\n        v0 = np.exp(c_hat)\n        # Uncertainty propagation: u_v0 = v0 * u_c\n        u_v0 = v0 * u_c\n        \n        results.append([Ea, u_Ea, v0, u_v0])\n        \n    # Final print statement in the exact required format.\n    # Convert numpy arrays/scalars to native Python floats for clean string representation.\n    final_results = [[float(val) for val in res] for res in results]\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "建立和校准动力学模型的最终目的是为了预测和控制真实的制造过程。在半导体制造中，退火工艺常常采用非等温条件，例如线性升温。本练习  展示了动力学模型的预测能力，要求您将已校准的阿伦尼乌斯模型应用于一个动态的工艺场景。您需要通过对速率方程在变化的温度下进行积分，来计算在给定的升温速率下生长特定厚度非晶层所需的时间，这个过程将让您实践在现代工艺仿真中至关重要的数值求解方法。",
            "id": "4165823",
            "problem": "考虑在非晶半导体薄膜中，在线性升温条件下进行的固相外延再生长。再生长前沿以依赖于温度的速度推进，该速度由阿伦尼乌斯关系描述，其中再生长速度 $v(T)$ 满足 $v(T) = v_0 \\exp\\!\\left(-\\dfrac{E_a}{k_\\mathrm{B} T}\\right)$，其中 $v_0$ 是指前因子，$E_a$ 是活化能，$k_\\mathrm{B}$ 是玻尔兹曼常数。晶圆通过线性升温斜坡进行退火，其温度变化为 $T(t) = T_0 + \\beta t$，其中 $T_0$ 是初始温度，$\\beta$ 是恒定的升温速率。到时间 $t$ 为止累积的再生长厚度为 $L(t) = \\int_{0}^{t} v\\!\\left(T(\\tau)\\right)\\,\\mathrm{d}\\tau$。您必须反转厚度关系，以确定在给定参数 $T_0$、$\\beta$、$v_0$ 和 $E_a$ 的情况下，再生长到目标厚度 $L$ 所需的升温时间 $t_f$。该反演过程会得到一个关于 $t_f$ 的超越方程，该方程不能简化为初等函数，必须进行数值求解。\n\n仅从上述基本定义和经过检验的事实出发，推导在线性升温条件下再生长厚度随时间变化的数学形式，识别保证对于任何非负 $L$ 都存在唯一解 $t_f$ 的性质，并设计一个鲁棒的数值算法来计算任意物理上合理的输入的 $t_f$。最终时间 $t_f$ 以秒为单位表示。如果某个情况中 $L = 0$，则返回 $t_f = 0$。\n\n您的程序必须实现该算法，并对以下每个测试用例求解 $t_f$。请一致使用以下单位：$T$ 以开尔文为单位，$\\beta$ 以开尔文/秒为单位，$v_0$ 以米/秒为单位，$E_a$ 以电子伏特为单位，$L$ 以纳米为单位。玻尔兹曼常数 $k_\\mathrm{B}$ 使用电子伏特/开尔文为单位。对于数值结果，将每个 $t_f$ 打印为以秒为单位的浮点数，并精确到小数点后六位。\n\n测试套件：\n- 案例 $1$：$T_0 = 600 \\ \\mathrm{K}$，$\\beta = 2 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 2.7 \\ \\mathrm{eV}$，$L = 100 \\ \\mathrm{nm}$。\n- 案例 $2$（边界条件）：$T_0 = 500 \\ \\mathrm{K}$，$\\beta = 5 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 2.7 \\ \\mathrm{eV}$，$L = 0 \\ \\mathrm{nm}$。\n- 案例 $3$（慢速升温）：$T_0 = 450 \\ \\mathrm{K}$，$\\beta = 0.2 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 2.7 \\ \\mathrm{eV}$，$L = 50 \\ \\mathrm{nm}$。\n- 案例 $4$（更高活化能）：$T_0 = 600 \\ \\mathrm{K}$，$\\beta = 2 \\ \\mathrm{K/s}$，$v_0 = 1.0\\times 10^{8} \\ \\mathrm{m/s}$，$E_a = 3.2 \\ \\mathrm{eV}$，$L = 100 \\ \\mathrm{nm}$。\n\n您的程序应生成单行输出，其中包含四个案例的结果，格式为方括号内的逗号分隔列表（例如，$[t_1,t_2,t_3,t_4]$），其中每个 $t_i$ 是计算出的以秒为单位的 $t_f$，并精确到小数点后六位。",
            "solution": "所述问题在科学上是合理的、适定的且内部一致的。所有必要的物理定律、数学定义和数值参数都已提供，足以构建公式并求解所需时间 $t_f$。该物理模型基于固相外延再生长的标准阿伦尼乌斯动力学，退火过程是常见的线性升温斜坡。因此，该问题被认为是有效的。\n\n问题的核心是确定达到目标再生长厚度 $L$ 所需的时间 $t_f$。这可以通过求解方程 $L(t_f) = L$ 来实现，其中 $L(t)$ 是累积厚度作为时间的函数。\n\n再生长前沿的速度 $v$ 是温度 $T$ 的函数，由阿伦尼乌斯关系给出：\n$$v(T) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} T}\\right)$$\n其中 $v_0$ 是指前因子，$E_a$ 是活化能，$k_\\mathrm{B}$ 是玻尔兹曼常数。\n\n温度 $T$ 随时间 $t$ 按照线性斜坡变化：\n$$T(t) = T_0 + \\beta t$$\n其中 $T_0$ 是初始温度，$\\beta$ 是恒定的升温速率。为了使该关系在 $t \\ge 0$ 时具有物理意义，我们必须有 $T_0  0$ 和 $\\beta \\ge 0$。所提供的测试用例满足这些条件。\n\n截至时间 $t$ 累积的总再生长厚度 $L(t)$ 是速度的时间积分。通过将温度斜坡 $T(\\tau)$ 的表达式代入速度方程 $v(T)$，我们得到速度作为时间 $\\tau$ 的显式函数：\n$$v(T(\\tau)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right)$$\n则在最终时间 $t_f$ 的累积厚度由以下定积分给出：\n$$L(t_f) = \\int_{0}^{t_f} v(T(\\tau)) \\, \\mathrm{d}\\tau = \\int_{0}^{t_f} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau$$\n\n为了找到生长特定厚度 $L$ 所需的时间 $t_f$，我们必须求解以下关于 $t_f$ 的方程：\n$$L = \\int_{0}^{t_f} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau$$\n\n该积分没有以初等函数表示的闭式解。它可以使用指数积分特殊函数 $E_n(x)$ 来表示，但对于数值计算，直接且稳健地处理该积分通常更可取。\n\n在设计算法之前，我们必须确定对于任何给定的非负目标厚度 $L$，解 $t_f$ 的存在性和唯一性。让我们分析函数 $L(t_f)$。\n被积函数 $v(T(\\tau)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right)$ 对于所有物理参数（$v_0  0, E_a  0, k_\\mathrm{B}  0, T_0  0, \\beta \\ge 0$）和所有 $\\tau \\ge 0$ 都是严格正函数。\n根据微积分基本定理，$L(t)$ 对时间 $t$ 的导数为：\n$$\\frac{\\mathrm{d}L}{\\mathrm{d}t} = v(T(t)) = v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta t)}\\right)$$\n由于对于所有 $t \\ge 0$ 都有 $v(T(t))  0$，因此函数 $L(t)$ 在 $t \\ge 0$ 上是严格单调递增的。\n此外，在初始时间 $t=0$ 时，累积厚度为零：$L(0) = \\int_{0}^{0} \\dots \\, \\mathrm{d}\\tau = 0$。\n\n这些性质保证了解的存在性和唯一性：\n1.  **存在性**：由于 $L(0) = 0$ 且 $L(t)$ 是连续的，并且当 $t \\to \\infty$ 时无界增加，根据介值定理，对于任何目标厚度 $L \\ge 0$，保证存在至少一个时间 $t_f \\ge 0$ 使得 $L(t_f) = L$。\n2.  **唯一性**：因为 $L(t)$ 是严格单调递增的，所以它不能多次取相同的值。因此，对于任何给定的 $L$，时间 $t_f$ 是唯一的。\n\n因此，问题简化为求解超越方程 $f(t_f) = 0$ 的根，其中：\n$$f(t) = \\left( \\int_{0}^{t} v_0 \\exp\\left(-\\frac{E_a}{k_\\mathrm{B} (T_0 + \\beta \\tau)}\\right) \\, \\mathrm{d}\\tau \\right) - L$$\n\n完成此任务的鲁棒数值算法是一种求根方法，例如 Brent 方法。该方法非常适合单变量函数，并且如果能找到一个使 $f(a)$ 和 $f(b)$ 符号相反的区间 $[a, b]$，则能保证收敛。\n\n算法设计如下：\n1.  处理平凡情况：如果目标厚度 $L=0$，则所需时间为 $t_f=0$。立即返回此值。\n2.  对于 $L0$，如上定义函数 $f(t)$。$f(t)$ 中的积分将使用高精度求积方法（例如 `scipy.integrate.quad` 提供的）进行数值计算。\n3.  为根 $t_f$ 建立一个搜索区间 $[a, b]$。\n    a.  设置下界 $a=0$。此时，$f(0) = L(0) - L = -L  0$。\n    b.  找到一个上界 $b  0$ 使得 $f(b)  0$。由于 $f(t)$ 保证会变为正值，我们可以从一个小的猜测值（例如 1 秒）开始，并反复将其加倍，直到 $f(b)$ 的符号变为正。这确保总能找到一个有效的区间。\n4.  在区间 $[a, b]$ 内对函数 $f(t)$ 使用数值求根求解器（例如，`scipy.optimize.root_scalar` 并设置 `method='brentq'`）来找到唯一的根 $t_f$。\n5.  在实现过程中，确保所有参数都转换为一致的单位制。问题指定了混合单位（$L$ 为 nm，$v_0$ 为 m/s）。我们将在内部计算中使用国际单位制基本单位（米、秒、开尔文）。因此，以纳米为单位给出的目标厚度 $L$ 必须通过乘以 $10^{-9}$ 转换为米。需要使用单位为 eV/K 的玻尔兹曼常数 $k_\\mathrm{B}$，其值约为 $8.617333 \\times 10^{-5} \\ \\mathrm{eV/K}$。\n\n根据一致的单位系统，最终结果 $t_f$ 将以秒为单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Calculates the time required for solid phase epitaxial regrowth\n    to a target thickness under a linear temperature ramp.\n    \"\"\"\n\n    # Define the Boltzmann constant in eV/K.\n    # The value is taken from CODATA 2018.\n    KB_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T0, beta, v0, Ea, L_nm)\n    # Units: T0 [K], beta [K/s], v0 [m/s], Ea [eV], L_nm [nm]\n    test_cases = [\n        (600.0, 2.0, 1.0e8, 2.7, 100.0),\n        (500.0, 5.0, 1.0e8, 2.7, 0.0),\n        (450.0, 0.2, 1.0e8, 2.7, 50.0),\n        (600.0, 2.0, 1.0e8, 3.2, 100.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        T0, beta, v0, Ea, L_nm = case\n\n        # Trivial case: zero thickness requires zero time.\n        if L_nm == 0.0:\n            results.append(0.0)\n            continue\n\n        # Convert target thickness from nanometers to meters for consistency.\n        L_m = L_nm * 1e-9\n\n        # Define the integrand: regrowth velocity as a function of time tau.\n        # v(T(tau)) = v0 * exp(-Ea / (kB * (T0 + beta * tau)))\n        integrand = lambda tau: v0 * np.exp(-Ea / (KB_EV_PER_K * (T0 + beta * tau)))\n\n        # Define the function whose root we need to find.\n        # f(t) = integral_from_0_to_t(v(tau) dtau) - L_target\n        def objective_function(t):\n            # quad returns a tuple (integral_value, error_estimate)\n            integral_val, _ = quad(integrand, 0, t)\n            return integral_val - L_m\n\n        # Find a suitable bracket [a, b] for the root-finding algorithm.\n        # We know f(0) = -L_m  0, so the lower bound is 0.\n        t_lower = 0.0\n        \n        # Find an upper bound t_upper such that f(t_upper) > 0.\n        # Start with a guess and double it until the sign changes.\n        t_upper = 1.0\n        # To prevent potential infinite loops with unusual parameters,\n        # add a reasonable limit to the number of doublings.\n        max_iter = 30 # Corresponds to t_upper up to 2^29 seconds ~ 17 years.\n        iterations = 0\n        while objective_function(t_upper)  0 and iterations  max_iter:\n            t_upper *= 2.0\n            iterations += 1\n        \n        if objective_function(t_upper)  0:\n            # This should not happen for physically reasonable inputs,\n            # as L(t) is guaranteed to grow. Indicates a potential issue.\n            # Handle as an error or by appending a failure code. For this problem,\n            # we assume valid inputs where a bracket can be found.\n            # For robustness, we could raise an exception.\n            raise RuntimeError(\"Could not find a valid bracket for the root.\")\n\n        # Use a robust root-finding algorithm (Brent's method) to solve for t.\n        solution = root_scalar(\n            objective_function, \n            bracket=[t_lower, t_upper], \n            method='brentq'\n        )\n        \n        t_f = solution.root\n        results.append(t_f)\n\n    # Format the results to exactly six decimal places and print.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}