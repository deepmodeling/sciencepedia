{
    "hands_on_practices": [
        {
            "introduction": "在许多半导体工艺中，例如蚀刻和退火，表面的演化速度直接取决于其局部几何形状，尤其是曲率。由于在串模型（Stringer Method）和单元模型（Cell-based Method）中，表面都是通过离散点来表示的，因此从这些离散数据中准确计算曲率是一项基本而关键的挑战。这项练习将指导您使用二次多项式拟合的方法来估算一个点上的曲率，并探讨这种数值微分方法在精度和对噪声的敏感性之间固有的权衡关系 。",
            "id": "4170884",
            "problem": "在半导体蚀刻过程中一个演化表面的二维横截面中，一种基于 Stringer 的离散化方法通过有序点（“串点”）来表示界面，这些点根据局部几何速度移动。在一种配套的基于单元（Cell-Based）的方法中，场量存储在欧拉网格上，并通过采样来恢复串的局部几何描述符。在特定时刻，考虑位于 $x=0$ 的一个串点周围的局部邻域，在该邻域的一个小窗口内，界面可以表示为函数图像 $y(x)$。通过基于单元的方法收集的三个相邻样本点提供了以下数据（单位为纳米 nm）：$(-10, 5.2)$、$(0, 5.0)$、$(10, 5.4)$。\n\n利用对这三个相邻点的局部二次拟合 $y(x) = a x^{2} + b x + c$，从平面曲线曲率的几何定义出发，计算串点 $x=0$ 处的曲率 $\\kappa$。假设当界面局部向上凸时，曲率为正。最终曲率以 $\\mathrm{nm}^{-1}$ 为单位表示，并将答案四舍五入至四位有效数字。\n\n然后，在均匀间距 $h$ 和足够光滑的 $y(x)$ 条件下，讨论该二次拟合曲率估计器的精度阶数，并分析在串（Stringer）框架下其对点间距和测量噪声的敏感性。你的讨论必须从基本的几何定义和泰勒展开出发，并且必须明确地将估计器随 $h$ 的标度变化、局部拟合的条件数与曲率驱动表面演化模型（例如在串（Stringer）和单元（Cell-Based）耦合中使用模型）中的预期误差行为联系起来。",
            "solution": "该问题具有科学依据，提法明确，客观，并包含获得唯一解所需的所有信息。这是一个应用于计算物理的数值分析标准问题，因此是有效的。\n\n第一步是利用提供的三个数据点 $P_1(-10, 5.2)$、$P_2(0, 5.0)$ 和 $P_3(10, 5.4)$ 来确定局部二次拟合 $y(x) = a x^{2} + b x + c$ 的系数。坐标以纳米为单位，所以 $x$ 和 $y(x)$ 的单位是 $\\mathrm{nm}$。系数 $a$、$b$ 和 $c$ 的单位将分别为 $\\mathrm{nm}^{-1}$、无量纲和 $\\mathrm{nm}$。\n\n我们将每个点代入二次方程：\n1. 对于 $P_1(-10, 5.2)$：$y(-10) = a(-10)^{2} + b(-10) + c = 5.2$，化简为 $100a - 10b + c = 5.2$。\n2. 对于 $P_2(0, 5.0)$：$y(0) = a(0)^{2} + b(0) + c = 5.0$，得到 $c = 5.0$。\n3. 对于 $P_3(10, 5.4)$：$y(10) = a(10)^{2} + b(10) + c = 5.4$，化简为 $100a + 10b + c = 5.4$。\n\n将 $c = 5.0$ 代入 $P_1$ 和 $P_3$ 的方程：\n1. $100a - 10b + 5.0 = 5.2 \\implies 100a - 10b = 0.2$\n2. $100a + 10b + 5.0 = 5.4 \\implies 100a + 10b = 0.4$\n\n这是一个关于 $a$ 和 $b$ 的二元一次方程组。将两个方程相加得到：\n$(100a - 10b) + (100a + 10b) = 0.2 + 0.4$\n$200a = 0.6$\n$a = \\frac{0.6}{200} = 0.003$\n\n用第二个方程减去第一个方程得到：\n$(100a + 10b) - (100a - 10b) = 0.4 - 0.2$\n$20b = 0.2$\n$b = \\frac{0.2}{20} = 0.01$\n\n因此，界面的局部二次近似为：\n$y(x) = 0.003x^{2} + 0.01x + 5.0$\n\n对于以函数图像 $y(x)$ 给出的平面曲线，其曲率 $\\kappa$ 的几何定义为：\n$$\\kappa(x) = \\frac{y''(x)}{\\left(1 + [y'(x)]^2\\right)^{3/2}}$$\n问题规定，正曲率对应于向上凸的表面，这与该公式中 $y''(x)$ 为正时的符号约定相符。\n\n我们计算 $y(x)$ 的一阶和二阶导数：\n$y'(x) = \\frac{d}{dx}(0.003x^{2} + 0.01x + 5.0) = 0.006x + 0.01$\n$y''(x) = \\frac{d}{dx}(0.006x + 0.01) = 0.006$\n\n我们需要计算串点 $x=0$ 处的曲率。首先，我们计算在 $x=0$ 处的导数值：\n$y'(0) = 0.006(0) + 0.01 = 0.01$\n$y''(0) = 0.006$\n\n现在，我们将这些值代入曲率公式：\n$\\kappa(0) = \\frac{y''(0)}{\\left(1 + [y'(0)]^2\\right)^{3/2}} = \\frac{0.006}{\\left(1 + (0.01)^2\\right)^{3/2}}$\n$\\kappa(0) = \\frac{0.006}{(1 + 0.0001)^{3/2}} = \\frac{0.006}{(1.0001)^{3/2}}$\n\n计算数值结果：\n$\\kappa(0) \\approx \\frac{0.006}{1.00015000375} \\approx 0.005999100049...$\n$x$ 和 $y$ 的单位是 $\\mathrm{nm}$，所以 $y'$ 是无量纲的，$y''$ 的单位是 $\\mathrm{nm}^{-1}$。因此，$\\kappa$ 的单位是 $\\mathrm{nm}^{-1}$。\n将结果四舍五入至四位有效数字，得到 $0.005999 \\, \\mathrm{nm}^{-1}$。\n\n接下来，我们讨论该方法的精度和敏感性。\n让我们考虑一个一般情况，从一个足够光滑的函数 $y(x)$ 上在 $x_0-h$、$x_0$ 和 $x_0+h$ 处采集三个点。不失一般性，我们设 $x_0=0$。这些点是 $(-h, y_{-1})$、$(0, y_0)$ 和 $(h, y_1)$。通过这些点的二次拟合 $y_{fit}(x) = ax^2+bx+c$ 得到的系数为：\n$c = y_0$\n$b = \\frac{y_1 - y_{-1}}{2h}$\n$a = \\frac{y_1 - 2y_0 + y_{-1}}{2h^2}$\n\n在 $x=0$ 处的导数估计为：\n$y'_{est}(0) = b = \\frac{y_1 - y_{-1}}{2h}$\n$y''_{est}(0) = 2a = \\frac{y_1 - 2y_0 + y_{-1}}{h^2}$\n这些是一阶和二阶导数的标准二阶中心差分公式。\n\n为了分析精度阶数，我们使用 $y(x)$ 在 $x=0$ 附近的泰勒展开：\n$y(h) = y_1 = y(0) + y'(0)h + \\frac{1}{2}y''(0)h^2 + \\frac{1}{6}y'''(0)h^3 + \\frac{1}{24}y''''(0)h^4 + O(h^5)$\n$y(-h) = y_{-1} = y(0) - y'(0)h + \\frac{1}{2}y''(0)h^2 - \\frac{1}{6}y'''(0)h^3 + \\frac{1}{24}y''''(0)h^4 - O(h^5)$\n\n对于一阶导数估计器：\n$y'_{est}(0) = \\frac{1}{2h} [ (y(0) + y'(0)h + \\dots) - (y(0) - y'(0)h + \\dots) ] = \\frac{1}{2h} [2y'(0)h + \\frac{1}{3}y'''(0)h^3 + O(h^5)] = y'(0) + \\frac{1}{6}y'''(0)h^2 + O(h^4)$\n截断误差为 $y'_{est}(0) - y'(0) = O(h^2)$，所以该估计器是二阶精度的。\n\n对于二阶导数估计器：\n$y''_{est}(0) = \\frac{1}{h^2} [ (y(0) + \\dots) - 2y(0) + (y(0) - \\dots) ] = \\frac{1}{h^2} [ y''(0)h^2 + \\frac{1}{12}y''''(0)h^4 + O(h^6) ] = y''(0) + \\frac{1}{12}y''''(0)h^2 + O(h^4)$\n截断误差为 $y''_{est}(0) - y''(0) = O(h^2)$，所以该估计器也是二阶精度的。\n\n由于两个导数估计器都是二阶精度的，得到的曲率估计器 $\\kappa_{est}$ 也将是二阶精度的，即 $\\kappa_{est} = \\kappa + O(h^2)$，前提是 $y(x)$ 足够光滑（至少是 $C^4$ 连续）。\n\n现在，我们分析对测量噪声的敏感性。\n设测量的 y 值为 $\\tilde{y}_i = y_i + \\epsilon_i$，其中 $\\epsilon_i$ 是均值为 $0$、方差为 $\\sigma^2$ 的独立随机误差。由该噪声引起的二阶导数估计误差为：\n$E_{y''} = \\frac{(\\tilde{y}_1 - 2\\tilde{y}_0 + \\tilde{y}_{-1})}{h^2} - y''_{est,true} = \\frac{\\epsilon_1 - 2\\epsilon_0 + \\epsilon_{-1}}{h^2}$\n该误差的方差为：\n$\\mathrm{Var}(E_{y''}) = \\frac{1}{h^4} \\mathrm{Var}(\\epsilon_1 - 2\\epsilon_0 + \\epsilon_{-1}) = \\frac{1}{h^4} (\\mathrm{Var}(\\epsilon_1) + 4\\mathrm{Var}(\\epsilon_0) + \\mathrm{Var}(\\epsilon_{-1})) = \\frac{\\sigma^2 + 4\\sigma^2 + \\sigma^2}{h^4} = \\frac{6\\sigma^2}{h^4}$\n因此，$y''$ 误差的标准差与 $\\sigma/h^2$ 成比例。类似地，$y'$ 误差的标准差与 $\\sigma/h$ 成比例。\n\n该分析揭示了在选择串点间距 $h$ 时的一个关键权衡。\n1.  **截断误差**：为了最小化 $O(h^2)$ 阶的截断误差，必须选择一个小的 $h$。这对于精确解析表面的精细几何特征是必要的。\n2.  **噪声放大**：为了最小化测量噪声（例如，来自基于单元网格的采样）的影响，必须选择一个大的 $h$。曲率的计算依赖于二阶导数，因此对噪声极其敏感，其误差放大与 $1/h^2$ 成正比。\n\n这种权衡是数值微分中的一个基本问题。对于小的 $h$，局部二次拟合的条件数很差，因为这些点变得几乎共线，这使得二次项（`a`）的确定对 y 值的微小扰动高度敏感。这正是 $1/h^2$ 标度关系所反映的。\n\n在曲率驱动的表面演化模型的背景下，例如在耦合的串（Stringer）/单元（Cell-Based）方法中使用的模型，这种敏感性具有深远的影响。串点的法向速度通常与局部曲率成正比，$v_n \\propto \\kappa$。如果 $h$ 很小，串点位置的任何微小噪声都将被极大地放大，导致计算出的曲率出现大的、振荡的误差。这些带噪声的曲率值继而导致大的、带噪声的速度，从而引起串点不规则和不稳定的运动。这会破坏模拟界面的光滑性，并可能导致模拟失败。这是一种数值不稳定性。为了缓解这个问题，从业者通常采用正则化技术，例如使用更宽的模板（例如，5点拟合），对串点坐标或计算出的曲率值应用数字滤波器，或者使用更复杂的、从变分法推导出的、对噪声更鲁棒的曲率估计器。",
            "answer": "$$\\boxed{0.005999}$$"
        },
        {
            "introduction": "真实的半导体制造过程很少在无约束的空间中进行；相反，表面演化通常受到坚硬的掩模（mask）结构的限制。因此，准确模拟表面点在与掩模接触时的行为至关重要。本练习将探讨两种最常见的物理约束：固定（sticking）和滑移（slipping），并要求您从运动学基本定律出发，推导并实现处理这些边界条件的算法 。掌握这些技术对于建立能够反映真实器件几何形状的可靠工艺模型是必不可少的。",
            "id": "4170931",
            "problem": "考虑一个工艺模型中半导体特征的二维横截面，其中演化的材料表面由一系列连接成线段的离散点表示（一种“串”表示法），而其底层物理过程也可以在基于单元（有限体积）的框架中进行解释。在没有约束的情况下，每个表面点根据运动学定律 $$\\dot{\\mathbf{x}} = V_n \\,\\mathbf{n}_s$$ 演化，其中 $\\mathbf{x}$ 是位置，$V_n$ 是局部法向速度（例如，由刻蚀或沉积引起），$\\mathbf{n}_s$ 是该点处表面的单位法向量。对于附着在刚性掩模边缘上的点，其运动必须满足边界约束。两种具有物理意义的情况是：\n\n- 无运动（完美粘附）：点保持固定，满足 $$\\dot{\\mathbf{x}} = \\mathbf{0}.$$\n- 沿刚性掩模边缘的滑移约束：点只允许沿着掩模边缘切线 $\\mathbf{t}_m$（单位向量）移动，不允许穿过掩模，此条件由掩模边缘法线 $\\mathbf{m}_n$（单位向量）来表征，强制执行 $$\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}} = 0.$$ 滑移速度可以是将未约束速度投影到掩模切线上得到的速度，也可以是沿着 $\\mathbf{t}_m$ 的指定滑移速率 $u_t$。\n\n在掩模角点处，两个刚性掩模边缘相交，其法线分别为 $\\mathbf{m}_{n,1}$ 和 $\\mathbf{m}_{n,2}$，切线分别为 $\\mathbf{t}_{m,1}$ 和 $\\mathbf{t}_{m,2}$。此时，容许运动子空间是两个切线方向的交集。在二维空间中，这个交集通常是平凡的（即零向量），因此得到 $$\\dot{\\mathbf{x}} = \\mathbf{0}.$$\n\n从基本运动学定律 $$\\dot{\\mathbf{x}} = V_n \\,\\mathbf{n}_s$$ 和刚性边界的完整约束公式 $$\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}} = 0$$ 出发，根据约束运动的第一性原理，推导在以下情况下计算边界串点的受约束速度 $\\dot{\\mathbf{x}}$ 的公式：\n1. 完美粘附于刚性掩模。\n2. 沿掩模边缘的滑移约束，其速度由未约束速度在 $\\mathbf{t}_m$ 上的投影给出。\n3. 沿掩模边缘的滑移约束，其滑移速率为沿 $\\mathbf{t}_m$ 的指定速率 $u_t$。\n4. 两个刚性边缘相交的掩模角点。\n\n然后，在一个程序中实现这些约束，该程序针对每个测试用例，使用给定的时间步长 $\\Delta t$ 计算更新后的位置 $$\\mathbf{x}_{\\text{new}} = \\mathbf{x} + \\dot{\\mathbf{x}}\\,\\Delta t$$，并验证约束是否在数值容差范围内得到满足。将所有向量视为二维向量，并假设所有输入均使用国际单位制（SI单位）。您必须：\n- 位置以米为单位，速度以米/秒为单位，时间以秒为单位表示。\n- 仅通过给定的向量隐式使用角度；不要显式计算或要求角度。\n- 对任何意在作为单位向量的输入向量进行归一化。\n- 使用 $10^{-12}$ 的数值容差进行约束验证。\n\n您的程序必须解决以下测试用例集：\n- 用例 A (粘附): $\\mathbf{x} = [5.0\\times 10^{-7},\\,2.0\\times 10^{-7}]$, $V_n = 4.0\\times 10^{-8}$, $\\mathbf{n}_s = [0,\\,1]$, $\\mathbf{t}_m = [1,\\,0]$, $\\mathbf{m}_n = [0,\\,1]$, type = \"stick\", $\\Delta t = 0.1$.\n- 用例 B (通过投影滑移): $\\mathbf{x} = [0.0,\\,0.0]$, $V_n = 1.0\\times 10^{-7}$, $\\mathbf{n}_s = [1/\\sqrt{2},\\,1/\\sqrt{2}]$, $\\mathbf{t}_m = [\\sqrt{3}/2,\\,1/2]$, $\\mathbf{m}_n = [-1/2,\\,\\sqrt{3}/2]$, type = \"slip_projected\", $\\Delta t = 0.2$.\n- 用例 C (指定滑移): $\\mathbf{x} = [1.0\\times 10^{-6},\\,0.0]$, $V_n = 2.0\\times 10^{-8}$, $\\mathbf{n}_s = [1,\\,0]$, $\\mathbf{t}_m = [0,\\,1]$, $\\mathbf{m}_n = [1,\\,0]$, type = \"slip_specified\", $u_t = 1.2\\times 10^{-7}$, $\\Delta t = 0.05$.\n- 用例 D (角点，无运动): $\\mathbf{x} = [1.0\\times 10^{-7},\\,1.0\\times 10^{-7}]$, $V_n = 2.0\\times 10^{-7}$, $\\mathbf{n}_s = [1/\\sqrt{2},\\,-1/\\sqrt{2}]$, $\\mathbf{t}_{m,1} = [1,\\,0]$, $\\mathbf{m}_{n,1} = [0,\\,1]$, $\\mathbf{t}_{m,2} = [0,\\,1]$, $\\mathbf{m}_{n,2} = [1,\\,0]$, type = \"corner\", $\\Delta t = 0.05$.\n- 用例 E (使用非单位切线投影，需要归一化): $\\mathbf{x} = [-2.0\\times 10^{-6},\\,3.0\\times 10^{-6}]$, $V_n = 2.0\\times 10^{-7}$, $\\mathbf{n}_s = [1,\\,0]$, $\\mathbf{t}_m = [2,\\,0]$ (注意: 非单位长度), $\\mathbf{m}_n = [0,\\,1]$, type = \"slip_projected\", $\\Delta t = 0.05$.\n\n对于每个用例，计算：\n- 更新后的位置 $\\mathbf{x}_{\\text{new}}$（以米为单位），形式为列表 $[x_{\\text{new}}, y_{\\text{new}}]$。\n- 一个布尔值，指示所施加的约束是否在 $10^{-12}$ 的容差内得到满足。\n\n您的程序应生成单行输出，其中包含所有五个用例的结果。结果是一个用方括号括起来的逗号分隔列表，其中每个元素是形如 $[x_{\\text{new}}, y_{\\text{new}}, \\text{constraint\\_ok}]$ 的列表。例如：“[[x1,y1,True],[x2,y2,False],...]”。",
            "solution": "该问题要求推导在刚性掩模边界上表面点的受约束速度的公式，然后进行数值实现。所有情况的出发点都是表面点的未约束速度，由运动学定律给出：\n$$\n\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s\n$$\n其中 $\\dot{\\mathbf{x}}_u$ 是未约束速度向量，$V_n$ 是局部法向速度，$\\mathbf{n}_s$ 是点 $\\mathbf{x}$ 处表面的单位法向量。所有向量都视为二维向量，即 $\\mathbf{v} = [v_x, v_y]$。当一个点位于刚性掩模边界上时，其运动受到约束。该约束表示为对速度的完整约束：\n$$\n\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0\n$$\n其中 $\\dot{\\mathbf{x}}_c$ 是受约束速度，$\\mathbf{m}_n$ 是掩模的单位法向量，指向远离容许运动区域的方向。此条件确保该点不会“穿过”掩模。从几何上看，这意味着受约束速度 $\\dot{\\mathbf{x}}_c$ 必须平行于掩模边缘，其方向由单位切向量 $\\mathbf{t}_m$ 给出。在二维空间中，$\\mathbf{t}_m$ 和 $\\mathbf{m}_n$ 是正交的，因此 $\\mathbf{t}_m \\cdot \\mathbf{m}_n = 0$。\n\n我们现在将为四个指定情况中的每一种推导受约束速度 $\\dot{\\mathbf{x}}_c$ 的表达式。\n\n**情况1：完美粘附于刚性掩模**\n\n这是最简单的情况。问题陈述将此条件定义为“无运动”。这对应于速度的狄利克雷（Dirichlet）边界条件。因此，受约束速度为零向量：\n$$\n\\dot{\\mathbf{x}}_c = \\mathbf{0}\n$$\n由于 $\\mathbf{m}_n \\cdot \\mathbf{0} = 0$，约束 $\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0$ 自然得到满足。其物理解释是，该点完美地粘附在掩模上，无论未约束的表面演化速度 $V_n$ 为何，都不能移动。经过时间步长 $\\Delta t$ 后的新位置就是原始位置：$\\mathbf{x}_{\\text{new}} = \\mathbf{x} + \\mathbf{0} \\cdot \\Delta t = \\mathbf{x}$。\n\n**情况2：沿掩模边缘的滑移约束（投影速度）**\n\n在这种情况下，点可以沿着掩模边缘自由滑动。速度被约束为平行于掩模切线 $\\mathbf{t}_m$。问题指定速度的大小和方向由未约束速度 $\\dot{\\mathbf{x}}_u$ 在切线方向 $\\mathbf{t}_m$ 上的投影决定。\n\n将向量 $\\mathbf{v}$ 投影到单位向量 $\\mathbf{u}$ 上的公式为 $(\\mathbf{v} \\cdot \\mathbf{u})\\mathbf{u}$。将此应用于我们的问题，受约束速度 $\\dot{\\mathbf{x}}_c$ 是 $\\dot{\\mathbf{x}}_u$ 在 $\\mathbf{t}_m$ 上的投影：\n$$\n\\dot{\\mathbf{x}}_c = (\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\n代入 $\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s$，我们得到：\n$$\n\\dot{\\mathbf{x}}_c = ( (V_n \\mathbf{n}_s) \\cdot \\mathbf{t}_m ) \\mathbf{t}_m = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\n根据其构造，该速度向量是 $\\mathbf{t}_m$ 的标量倍。不穿过掩模的约束得到满足，因为 $\\mathbf{t}_m$ 与 $\\mathbf{m}_n$ 正交：\n$$\n\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = \\mathbf{m}_n \\cdot (V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) \\mathbf{t}_m) = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) (\\mathbf{m}_n \\cdot \\mathbf{t}_m) = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) (0) = 0\n$$\n\n**情况3：沿掩模边缘的滑移约束（指定滑移速率）**\n\n与前一种情况类似，运动被约束在掩模切线 $\\mathbf{t}_m$ 的方向上。但是，其大小不是由投影确定，而是由指定的滑移速率 $u_t$ 给出。沿切线方向的滑移方向（+$\\mathbf{t}_m$ 或 -$\\mathbf{t}_m$）由未约束速度沿切线的分量决定。如果未约束速度沿 $\\mathbf{t}_m$ 有正分量，则点沿 $\\mathbf{t}_m$ 方向滑移；如果分量为负，则沿与 $\\mathbf{t}_m$ 相反的方向滑移。\n\n$\\dot{\\mathbf{x}}_u$ 沿 $\\mathbf{t}_m$ 的有符号分量由点积 $\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m$ 给出。因此，滑移方向为 $\\text{sign}(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m$，其中 $\\text{sign}$ 函数返回 $+1$、$-1$ 或 $0$。速度是速率 $u_t$ 乘以该方向向量：\n$$\n\\dot{\\mathbf{x}}_c = u_t \\cdot \\text{sign}(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\n代入 $\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s$：\n$$\n\\dot{\\mathbf{x}}_c = u_t \\cdot \\text{sign}((V_n \\mathbf{n}_s) \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\n如果未约束速度的切向分量为零，即 $(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) = 0$，则 $\\text{sign}(0)=0$，滑移速度为零。约束 $\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0$ 依据与情况2相同的逻辑得到满足，因为 $\\dot{\\mathbf{x}}_c$ 平行于 $\\mathbf{t}_m$。\n\n**情况4：掩模角点**\n\n在角点处，点同时位于两个不同的掩模边缘上。这些边缘具有不同的单位法向量 $\\mathbf{m}_{n,1}$ 和 $\\mathbf{m}_{n,2}$，以及不同的单位切向量 $\\mathbf{t}_{m,1}$ 和 $\\mathbf{t}_{m,2}$。为使该点保持在两个边缘上，其速度 $\\dot{\\mathbf{x}}_c$ 必须同时满足两个约束：\n$$\n\\mathbf{m}_{n,1} \\cdot \\dot{\\mathbf{x}}_c = 0 \\quad \\text{and} \\quad \\mathbf{m}_{n,2} \\cdot \\dot{\\mathbf{x}}_c = 0\n$$\n第一个条件意味着 $\\dot{\\mathbf{x}}_c$ 必须平行于 $\\mathbf{t}_{m,1}$（因为在这种情况下，$\\mathbf{t}_{m,1}$ 是 $\\mathbf{m}_{n,1}$ 的零空间）。第二个条件意味着 $\\dot{\\mathbf{x}}_c$ 也必须平行于 $\\mathbf{t}_{m,2}$。\n因此，必须存在标量 $k_1$ 和 $k_2$，使得：\n$$\n\\dot{\\mathbf{x}}_c = k_1 \\mathbf{t}_{m,1} \\quad \\text{and} \\quad \\dot{\\mathbf{x}}_c = k_2 \\mathbf{t}_{m,2}\n$$\n这要求 $k_1 \\mathbf{t}_{m,1} = k_2 \\mathbf{t}_{m,2}$。在二维空间中，如果向量 $\\mathbf{t}_{m,1}$ 和 $\\mathbf{t}_{m,2}$ 是线性无关的（即不平行，这对于任何真正的角点都是成立的），则此方程的唯一解是平凡解：$k_1 = 0$ 和 $k_2 = 0$。\n因此，唯一可能的受约束速度是零向量：\n$$\n\\dot{\\mathbf{x}}_c = \\mathbf{0}\n$$\n这实际上是由角点的几何形状施加的“粘附”条件。两个边界约束都自然得到满足。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves for the updated position and constraint satisfaction for several test cases\n    of a surface point evolution under different boundary conditions.\n    \"\"\"\n\n    # Numerical tolerance for constraint verification\n    TOL = 1e-12\n\n    # Test suite definition\n    test_cases = [\n        {\n            'name': 'Case A (sticking)',\n            'type': 'stick',\n            'x': np.array([5.0e-7, 2.0e-7]),\n            'Vn': 4.0e-8,\n            'ns': np.array([0.0, 1.0]),\n            'tm': np.array([1.0, 0.0]),\n            'mn': np.array([0.0, 1.0]),\n            'dt': 0.1\n        },\n        {\n            'name': 'Case B (slip via projection)',\n            'type': 'slip_projected',\n            'x': np.array([0.0, 0.0]),\n            'Vn': 1.0e-7,\n            'ns': np.array([1/math.sqrt(2), 1/math.sqrt(2)]),\n            'tm': np.array([math.sqrt(3)/2, 1/2]),\n            'mn': np.array([-1/2, math.sqrt(3)/2]),\n            'dt': 0.2\n        },\n        {\n            'name': 'Case C (specified slip)',\n            'type': 'slip_specified',\n            'x': np.array([1.0e-6, 0.0]),\n            'Vn': 2.0e-8,\n            'ns': np.array([1.0, 0.0]),\n            'tm': np.array([0.0, 1.0]),\n            'mn': np.array([1.0, 0.0]),\n            'ut': 1.2e-7,\n            'dt': 0.05\n        },\n        {\n            'name': 'Case D (corner, no motion)',\n            'type': 'corner',\n            'x': np.array([1.0e-7, 1.0e-7]),\n            'Vn': 2.0e-7,\n            'ns': np.array([1/math.sqrt(2), -1/math.sqrt(2)]),\n            't_m1': np.array([1.0, 0.0]),\n            'm_n1': np.array([0.0, 1.0]),\n            't_m2': np.array([0.0, 1.0]),\n            'm_n2': np.array([1.0, 0.0]),\n            'dt': 0.05\n        },\n        {\n            'name': 'Case E (projection with non-unit tangent)',\n            'type': 'slip_projected',\n            'x': np.array([-2.0e-6, 3.0e-6]),\n            'Vn': 2.0e-7,\n            'ns': np.array([1.0, 0.0]),\n            'tm': np.array([2.0, 0.0]), # Not unit length\n            'mn': np.array([0.0, 1.0]),\n            'dt': 0.05\n        }\n    ]\n\n    results = []\n\n    def normalize(v):\n        \"\"\"Normalizes a 2D numpy vector, handling the zero vector case.\"\"\"\n        norm = np.linalg.norm(v)\n        if norm == 0:\n            return v\n        return v / norm\n\n    for case in test_cases:\n        v_c = np.array([0.0, 0.0])\n        constraint_ok = False\n\n        # --- Calculate Constrained Velocity ---\n\n        if case['type'] == 'stick':\n            # Velocity is zero for a sticking point.\n            v_c = np.array([0.0, 0.0])\n            # Constraint verification based on velocity magnitude.\n            constraint_ok = np.linalg.norm(v_c)  TOL\n        \n        elif case['type'] == 'corner':\n            # Velocity is zero for a corner point.\n            v_c = np.array([0.0, 0.0])\n            m_n1 = normalize(case['m_n1'])\n            m_n2 = normalize(case['m_n2'])\n            # Verify both holonomic constraints.\n            check1 = abs(np.dot(m_n1, v_c))  TOL\n            check2 = abs(np.dot(m_n2, v_c))  TOL\n            constraint_ok = check1 and check2\n\n        elif case['type'] == 'slip_projected':\n            ns = normalize(case['ns'])\n            tm = normalize(case['tm'])\n            mn = normalize(case['mn'])\n            Vn = case['Vn']\n            \n            v_u = Vn * ns\n            v_c = np.dot(v_u, tm) * tm\n            \n            # Verify the holonomic constraint.\n            constraint_ok = abs(np.dot(mn, v_c))  TOL\n\n        elif case['type'] == 'slip_specified':\n            ns = normalize(case['ns'])\n            tm = normalize(case['tm'])\n            mn = normalize(case['mn'])\n            Vn = case['Vn']\n            ut = case['ut']\n            \n            v_u = Vn * ns\n            tangential_comp = np.dot(v_u, tm)\n            \n            v_c = ut * np.sign(tangential_comp) * tm\n            \n            # Verify the holonomic constraint.\n            constraint_ok = abs(np.dot(mn, v_c))  TOL\n\n        # --- Update Position and Store Result ---\n        \n        x = case['x']\n        dt = case['dt']\n        x_new = x + v_c * dt\n        \n        results.append([x_new[0], x_new[1], constraint_ok])\n\n    # Format the output string to match the required format precisely,\n    # without spaces inside the inner lists.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在表面演化模拟中，最复杂的挑战之一是处理拓扑变化，例如当一个结构在蚀刻过程中被“夹断”成两个独立的结构时。对于显式追踪表面的串模型而言，这尤其困难，因为它需要算法能够检测到即将发生的拓扑变化并相应地更新其连接数据结构。本练习通过一个简化的窄颈（neck）蚀刻模型，引导您设计一个算法来判断何时发生分裂，并确保串模型和底层单元模型的连通性保持一致 。",
            "id": "4170909",
            "problem": "考虑一种基于串的二维横截面表示法，用于描述在各向同性蚀刻下演化的半导体特征。其表面由一条折线（“串”）离散化，材料区域由基于单元的网格表示。一个初始连通的特征包含一个狭窄的颈部。随着蚀刻的进行，颈部可能会缩断，从而引起拓扑变化。这种变化必须同时在串表示和基于单元的图中被捕捉，以保持连通性数据结构的一致性。\n\n基本原理。假设各向同性蚀刻具有恒定的法向速度。设局部法向速度为 $v_n$，单位为纳米/秒 ($nm/s$)。设时间 $t$ 时的颈部宽度为 $w(t)$，沿着两个相对表面段之间最窄间距的方向测量。定义一个沿 $w$ 方向的单位向量 $\\hat{e}_w$，以及在颈部上下相对表面上的向外单位法向量 $\\mathbf{n}_u$ 和 $\\mathbf{n}_\\ell$。在相对表面局部平坦的假设下，颈部宽度的变化率由法向运动在 $\\hat{e}_w$ 上的投影之和给出：\n$$\n\\frac{dw}{dt} = - v_n \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) - v_n \\left( -\\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right) = - v_n \\left[ \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) + \\left( \\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right) \\right].\n$$\n定义对齐因子 $c \\in [0,2]$ 为\n$$\nc := \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) + \\left( \\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right),\n$$\n因此在时间步长 $\\Delta t$ 内的离散时间更新为\n$$\nw_{k+1} = \\max\\left( w_k - c \\, v_n \\, \\Delta t, \\, 0 \\right).\n$$\n该模型对所有长度使用纳米 ($nm$)，对时间使用秒 ($s$)。\n\n基于单元的分裂准则。设单元尺寸为 $h$ 纳米。在基于单元的占据表示法中，需要至少一个完整单元宽度的桥梁横跨颈部以保持连通性。定义通道单元计数 $m = \\left\\lfloor \\frac{w}{h} \\right\\rfloor$。当 $m = 0$ 时，即等效于当 $w  h$ 时，发生基于单元的断开事件。为了保持一致性，这需要在颈部对串的连通性进行必要的分裂。\n\n连通性数据结构。“串”是一个图，其节点是沿折线的有序点，边连接连续的节点。基于单元的区域是一个图，其节点是单元，边编码了4-连通性。一致性要求在评估颈部的同一时间索引下，串图中的连通分量数量与单元图中的连通分量数量相匹配。\n\n任务。从上述基本原理出发，推导分裂串的准则并设计一个算法，该算法能够：\n- 使用离散更新 $w_{k+1} = \\max\\left( w_k - c \\, v_n \\, \\Delta t, \\, 0 \\right)$ 来推进颈部宽度的演化。\n- 在任何时间步 $k$（包括 $k=0$）开始时，若 $w  h$，或一旦更新产生 $w  h$，则触发分裂。\n- 通过移除跨越颈部区域的单一边来更新串图（假设颈部位于有序串节点的中点）。\n- 构建一个简化的单元图表示，该表示由两个体区域通过一个由 $m = \\left\\lfloor \\frac{w}{h} \\right\\rfloor$ 个单元组成的通道连接；在单元之间以及通道端点与体区域之间使用4-连通性。\n- 通过比较更新后的串图的连通分量数量与同一时间索引下单元图的连通分量数量来检查一致性。\n\n你的程序必须实现此算法并评估以下测试套件，其中所有长度单位为 $nm$，时间单位为 $s$：\n\n- 测试用例1（演化后分裂的正常路径）：$w_0 = 40$, $v_n = 10$, $c = 2$, $\\Delta t = 1$, 步数 $= 3$, $h = 10$。\n- 测试用例2（初始处于边界相等状态，一步后发生分裂）：$w_0 = 10$, $v_n = 5$, $c = 1$, $\\Delta t = 1$, 步数 $= 1$, $h = 10$。\n- 测试用例3（不分裂）：$w_0 = 50$, $v_n = 2$, $c = 1.5$, $\\Delta t = 1$, 步数 $= 10$, $h = 15$。\n- 测试用例4（在 $k=0$ 时立即分裂）：$w_0 = 8$, $v_n = 4$, $c = 2$, $\\Delta t = 0.5$, 步数 $= 1$, $h = 10$。\n\n对于每个测试用例，输出一个对 $[s, q]$，其中 $s$ 是一个布尔值，指示在最后一步或之前是否发生分裂；$q$ 是一个布尔值，指示在评估时间（如果发生分裂，则为分裂时间，否则为最终时间），串和单元连通性图是否一致。你的程序应生成单行输出，其中包含一个以逗号分隔的列表，用方括号括起来，列表中的每个元素是对应一个测试用例的对，例如 $[[\\text{True},\\text{False}],[\\text{False},\\text{True}],\\dots]$。",
            "solution": "该问题要求设计并实现一个算法，以模拟在各向同性蚀刻过程中半导体特征的拓扑变化——即颈部缩断。该模型使用一种混合表示法：用连续的串（折线）表示表面，用离散的基于单元的网格表示材料区域。核心任务是模拟狭窄颈部的变薄过程，检测何时发生分裂，并在评估时验证串和基于单元的数据结构之间连通性的一致性。\n\n物理模型基于恒定的各向同性蚀刻速率，其中表面沿其法线方向以恒定速度 $v_n$向内移动。颈部宽度 $w$ 的演化通过考虑两个局部平坦的相对表面段而得以简化。宽度的变化率由下式给出：\n$$\n\\frac{dw}{dt} = - v_n \\left[ \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) + \\left( \\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right) \\right]\n$$\n其中 $\\mathbf{n}_u$ 和 $\\mathbf{n}_\\ell$ 是颈部上下表面的向外单位法向量，而 $\\hat{e}_w$ 是沿宽度测量方向的单位向量。括号中的项被定义为对齐因子 $c$，其范围从 $c=0$（法向量垂直于宽度方向，无变薄）到 $c=2$（法向量反平行且与宽度方向对齐，最大变薄速率）。\n\n该算法通过以时间步长 $\\Delta t$ 对此演化过程进行时间离散化来推进。步骤 $k+1$ 处的颈部宽度使用显式欧拉公式从其在步骤 $k$ 的值更新而来，并带有非负约束：\n$$\nw_{k+1} = \\max\\left( w_k - c \\, v_n \\, \\Delta t, \\, 0 \\right)\n$$\n这个方程构成了任务中模拟方面的基础。\n\n问题的核心在于将 $w$ 的连续演化与离散的基于单元的表示法耦合起来。一个关键参数是单元尺寸 $h$。问题将基于单元的断开事件定义为颈部宽度 $w$ 变得小于一个单元尺寸 $h$ 的时刻。这是一个有物理和数值动机的准则：在基于单元的域中，比网格分辨率更窄的特征不能被视为连接桥。该准则被正式表述为，在任何时间步 $k \\ge 0$ 当 $w_k  h$ 时触发分裂。\n\n因此，为每个测试用例设计的算法必须执行以下步骤：\n1.  **初始化**：将初始宽度设置为 $w_0$。\n2.  **时间演化**：从初始时间步 $k=0$ 迭代到指定的最大步数。在每次迭代中，使用离散更新公式计算下一个时间步的宽度。宽度值的历史记录 $w_k$ 被存储或跟踪。\n3.  **分裂检测**：在每个时间步 $k$（包括初始状态 $k=0$），检查是否满足条件 $w_k  h$。第一个满足此条件的时刻是“分裂时间”。如果满足条件，则注册一个分裂事件，并且该测试用例的模拟实际上在此步骤结束，并进行评估。如果在给定的步数内从未满足该条件，则不发生分裂，并在最后一步进行评估。\n4.  **一致性验证**：在确定的评估时间（分裂时间或最终模拟时间），必须检查两个图表示的连通性是否一致。\n    -   **串图连通性**：串被建模为初始连通的，有1个连通分量。如果触发了分裂事件，则移除一条边，导致2个连通分量。因此，如果发生分裂，串分量的数量为2，否则为1。\n    -   **单元图连通性**：基于单元表示的连通性由形成跨颈部通道的单元数量 $m = \\left\\lfloor \\frac{w}{h} \\right\\rfloor$ 决定，其中 $w$ 是评估时的颈部宽度。如果 $m \\ge 1$，则存在单元路径，图是连通的（1个分量）。如果 $m=0$，则不存在这样的路径，图是不连通的（2个分量）。\n    -   **检查**：该算法比较两个图模型的连通分量数量。如果数量匹配，则确认一致性。\n\n问题的定义内在地将两种表示联系在一起。当且仅当 $w  h$ 时，$\\lfloor w/h \\rfloor = 0$（对于非负 $w$）。因此，串分裂的标准与单元图断开的标准是相同的。这意味着，只要算法正确实现，一致性检查（q）应始终返回 True。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (w0, vn, c, dt, steps, h)\n    #\n    # Test case 1 (happy path with split after evolution): \n    #   w0=40, vn=10, c=2, dt=1, steps=3, h=10.\n    # Test case 2 (boundary equality initially, split occurs after one step): \n    #   w0=10, vn=5, c=1, dt=1, steps=1, h=10.\n    # Test case 3 (no split): \n    #   w0=50, vn=2, c=1.5, dt=1, steps=10, h=15.\n    # Test case 4 (immediate split at k=0): \n    #   w0=8, vn=4, c=2, dt=0.5, steps=1, h=10.\n    \n    test_cases = [\n        (40, 10, 2, 1, 3, 10),\n        (10, 5, 1, 1, 1, 10),\n        (50, 2, 1.5, 1, 10, 15),\n        (8, 4, 2, 0.5, 1, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        w0, vn, c, dt, steps, h = case\n        \n        # Calculate the evolution of the neck width over time\n        w_history = [w0]\n        w_current = w0\n        for _ in range(steps):\n            # w_{k+1} = max(w_k - c * v_n * dt, 0)\n            w_next = max(w_current - c * vn * dt, 0.0)\n            w_history.append(w_next)\n            w_current = w_next\n\n        # Determine if and when a split occurred\n        split_occurred = False\n        evaluation_k = steps  # Evaluate at the final step if no split\n        for k, w_k in enumerate(w_history):\n            if w_k  h:\n                split_occurred = True\n                evaluation_k = k\n                break\n        \n        # Get the width at the evaluation time\n        final_w = w_history[evaluation_k]\n\n        # Perform the consistency check at the evaluation time\n        \n        # 1. Determine the number of connected components in the string graph\n        #    The string graph is split (2 components) if a split event occurred.\n        #    Otherwise, it remains connected (1 component).\n        string_components = 2 if split_occurred else 1\n        \n        # 2. Determine the number of connected components in the cell graph\n        #    Corridor cell count m = floor(w/h).\n        #    If m=0, the graph is disconnected (2 components).\n        #    If m>=1, the graph is connected (1 component).\n        m = np.floor(final_w / h)\n        cell_components = 2 if m == 0 else 1\n        \n        # 3. Check for consistency\n        #    The number of components in both graphs must match.\n        consistency = (string_components == cell_components)\n        \n        # Format the result pair as a string '[s,q]' without spaces\n        result_pair_str = f\"[{str(split_occurred)},{str(consistency)}]\"\n        results.append(result_pair_str)\n\n    # Final print statement in the exact required format '[[s1,q1],[s2,q2],...]'\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}