{
    "hands_on_practices": [
        {
            "introduction": "The accurate estimation of local surface geometry is a cornerstone of physically-based process modeling. Since many etch and deposition phenomena are dependent on local curvature, the ability to reliably compute this value from a discrete representation of the surface is paramount. This exercise provides direct practice in calculating curvature from a set of discrete points—a common task in both stringer and coupled cell-based methods—and explores the fundamental numerical trade-off between resolving fine features and amplifying noise. ",
            "id": "4170884",
            "problem": "In a two-dimensional cross-section of an evolving surface during a semiconductor etch, a Stringer-based discretization represents the interface by ordered points (\"string points\") that move according to a local geometric velocity. In a companion Cell-Based method, field quantities are stored on an Eulerian grid and sampled to recover local geometric descriptors for the string. At a particular time, consider a local neighborhood around a string point at $x=0$ where the interface can be expressed as a graph $y(x)$ in a small window. Three neighboring samples collected by the Cell-Based method provide the following data, in nanometers (nm): $(-10, 5.2)$, $(0, 5.0)$, $(10, 5.4)$.\n\nUsing a local quadratic fit $y(x) = a x^{2} + b x + c$ to these three neighboring points, compute the curvature $\\kappa$ at the string point $x=0$ by starting from the geometric definition of curvature for a planar curve. Assume the curvature is positive when the interface is locally convex upward. Express the final curvature in $\\mathrm{nm}^{-1}$ and round your answer to four significant figures.\n\nThen, discuss the accuracy order of this quadratic-fit curvature estimator under uniform spacing $h$ and sufficiently smooth $y(x)$, and analyze its sensitivity to point spacing and measurement noise in the Stringer framework. Your discussion must begin from foundational geometric definitions and Taylor expansions, and must explicitly connect the estimator’s scaling with $h$ and the conditioning of the local fit to the expected error behavior in curvature-driven surface evolution models such as those used in Cell-Based and Stringer coupling.",
            "solution": "The problem is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a standard problem in numerical analysis applied to computational physics and is therefore valid.\n\nThe first step is to determine the coefficients of the local quadratic fit $y(x) = a x^{2} + b x + c$ using the three provided data points: $P_1(-10, 5.2)$, $P_2(0, 5.0)$, and $P_3(10, 5.4)$. The coordinates are given in nanometers, so $x$ and $y(x)$ have units of $\\mathrm{nm}$. The coefficients $a$, $b$, and $c$ will have units of $\\mathrm{nm}^{-1}$, dimensionless, and $\\mathrm{nm}$ respectively.\n\nWe substitute each point into the quadratic equation:\n1. For $P_1(-10, 5.2)$: $y(-10) = a(-10)^{2} + b(-10) + c = 5.2$, which simplifies to $100a - 10b + c = 5.2$.\n2. For $P_2(0, 5.0)$: $y(0) = a(0)^{2} + b(0) + c = 5.0$, which gives $c = 5.0$.\n3. For $P_3(10, 5.4)$: $y(10) = a(10)^{2} + b(10) + c = 5.4$, which simplifies to $100a + 10b + c = 5.4$.\n\nSubstituting $c = 5.0$ into the equations for $P_1$ and $P_3$:\n1. $100a - 10b + 5.0 = 5.2 \\implies 100a - 10b = 0.2$\n2. $100a + 10b + 5.0 = 5.4 \\implies 100a + 10b = 0.4$\n\nThis is a system of two linear equations in $a$ and $b$. Adding the two equations yields:\n$(100a - 10b) + (100a + 10b) = 0.2 + 0.4$\n$200a = 0.6$\n$a = \\frac{0.6}{200} = 0.003$\n\nSubtracting the first equation from the second yields:\n$(100a + 10b) - (100a - 10b) = 0.4 - 0.2$\n$20b = 0.2$\n$b = \\frac{0.2}{20} = 0.01$\n\nThe local quadratic approximation of the interface is therefore:\n$y(x) = 0.003x^{2} + 0.01x + 5.0$\n\nThe geometric definition of curvature $\\kappa$ for a planar curve given as a graph $y(x)$ is:\n$$\\kappa(x) = \\frac{y''(x)}{\\left(1 + [y'(x)]^2\\right)^{3/2}}$$\nThe problem specifies that positive curvature corresponds to a surface that is convex upward, which matches the sign convention of this formula for a positive $y''(x)$.\n\nWe compute the first and second derivatives of $y(x)$:\n$y'(x) = \\frac{d}{dx}(0.003x^{2} + 0.01x + 5.0) = 0.006x + 0.01$\n$y''(x) = \\frac{d}{dx}(0.006x + 0.01) = 0.006$\n\nWe need to evaluate the curvature at the string point $x=0$. First, we evaluate the derivatives at $x=0$:\n$y'(0) = 0.006(0) + 0.01 = 0.01$\n$y''(0) = 0.006$\n\nNow, we substitute these values into the curvature formula:\n$\\kappa(0) = \\frac{y''(0)}{\\left(1 + [y'(0)]^2\\right)^{3/2}} = \\frac{0.006}{\\left(1 + (0.01)^2\\right)^{3/2}}$\n$\\kappa(0) = \\frac{0.006}{(1 + 0.0001)^{3/2}} = \\frac{0.006}{(1.0001)^{3/2}}$\n\nCalculating the numerical value:\n$\\kappa(0) \\approx \\frac{0.006}{1.00015000375} \\approx 0.005999100049...$\nThe units of $x$ and $y$ are $\\mathrm{nm}$, so $y'$ is dimensionless and $y''$ has units of $\\mathrm{nm}^{-1}$. Thus, $\\kappa$ has units of $\\mathrm{nm}^{-1}$.\nRounding the result to four significant figures gives $0.005999 \\, \\mathrm{nm}^{-1}$.\n\nNext, we address the discussion on the accuracy and sensitivity of this method.\nLet us consider a general case with three points sampled from a sufficiently smooth function $y(x)$ at $x_0-h$, $x_0$, and $x_0+h$. Without loss of generality, we set $x_0=0$. The points are $(-h, y_{-1})$, $(0, y_0)$, and $(h, y_1)$. The quadratic fit $y_{fit}(x) = ax^2+bx+c$ through these points gives coefficients:\n$c = y_0$\n$b = \\frac{y_1 - y_{-1}}{2h}$\n$a = \\frac{y_1 - 2y_0 + y_{-1}}{2h^2}$\n\nThe derivatives at $x=0$ are estimated as:\n$y'_{est}(0) = b = \\frac{y_1 - y_{-1}}{2h}$\n$y''_{est}(0) = 2a = \\frac{y_1 - 2y_0 + y_{-1}}{h^2}$\nThese are the standard second-order central difference formulas for the first and second derivatives.\n\nTo analyze the accuracy order, we use Taylor expansions of $y(x)$ around $x=0$:\n$y(h) = y_1 = y(0) + y'(0)h + \\frac{1}{2}y''(0)h^2 + \\frac{1}{6}y'''(0)h^3 + \\frac{1}{24}y''''(0)h^4 + O(h^5)$\n$y(-h) = y_{-1} = y(0) - y'(0)h + \\frac{1}{2}y''(0)h^2 - \\frac{1}{6}y'''(0)h^3 + \\frac{1}{24}y''''(0)h^4 - O(h^5)$\n\nFor the first derivative estimator:\n$y'_{est}(0) = \\frac{1}{2h} [ (y(0) + y'(0)h + \\dots) - (y(0) - y'(0)h + \\dots) ] = \\frac{1}{2h} [2y'(0)h + \\frac{1}{3}y'''(0)h^3 + O(h^5)] = y'(0) + \\frac{1}{6}y'''(0)h^2 + O(h^4)$\nThe truncation error is $y'_{est}(0) - y'(0) = O(h^2)$, so the estimator is second-order accurate.\n\nFor the second derivative estimator:\n$y''_{est}(0) = \\frac{1}{h^2} [ (y(0) + \\dots) - 2y(0) + (y(0) - \\dots) ] = \\frac{1}{h^2} [ y''(0)h^2 + \\frac{1}{12}y''''(0)h^4 + O(h^6) ] = y''(0) + \\frac{1}{12}y''''(0)h^2 + O(h^4)$\nThe truncation error is $y''_{est}(0) - y''(0) = O(h^2)$, so this estimator is also second-order accurate.\n\nSince both derivative estimators are second-order accurate, the resulting curvature estimator $\\kappa_{est}$ will also be second-order accurate, i.e., $\\kappa_{est} = \\kappa + O(h^2)$, provided $y(x)$ is sufficiently smooth (at least $C^4$).\n\nNow, we analyze the sensitivity to measurement noise. Let the measured y-values be $\\tilde{y}_i = y_i + \\epsilon_i$, where $\\epsilon_i$ are independent random errors with mean $0$ and variance $\\sigma^2$. The error in the estimated second derivative due to this noise is:\n$E_{y''} = \\frac{(\\tilde{y}_1 - 2\\tilde{y}_0 + \\tilde{y}_{-1})}{h^2} - y''_{est,true} = \\frac{\\epsilon_1 - 2\\epsilon_0 + \\epsilon_{-1}}{h^2}$\nThe variance of this error is:\n$\\mathrm{Var}(E_{y''}) = \\frac{1}{h^4} \\mathrm{Var}(\\epsilon_1 - 2\\epsilon_0 + \\epsilon_{-1}) = \\frac{1}{h^4} (\\mathrm{Var}(\\epsilon_1) + 4\\mathrm{Var}(\\epsilon_0) + \\mathrm{Var}(\\epsilon_{-1})) = \\frac{\\sigma^2 + 4\\sigma^2 + \\sigma^2}{h^4} = \\frac{6\\sigma^2}{h^4}$\nThe standard deviation of the error in $y''$ thus scales as $\\sigma/h^2$. Similarly, the standard deviation of the error in $y'$ scales as $\\sigma/h$.\n\nThis analysis reveals a critical trade-off in the choice of string point spacing $h$.\n1.  **Truncation Error**: To minimize the truncation error, which is $O(h^2)$, one must choose a small $h$. This is necessary to accurately resolve fine geometric features of the surface.\n2.  **Noise Amplification**: To minimize the effect of measurement noise (e.g., from sampling on the Cell-Based grid), one must choose a large $h$. The calculation of curvature, being dependent on the second derivative, is extremely sensitive to noise, with error amplification proportional to $1/h^2$.\n\nThis trade-off is fundamental to numerical differentiation. The conditioning of the local quadratic fit is poor for small $h$, as the points become nearly collinear, making the determination of the quadratic term (`a`) highly sensitive to small perturbations in the y-values. This is precisely what the $1/h^2$ scaling reflects.\n\nIn the context of curvature-driven surface evolution models, such as those used in coupled Stringer/Cell-Based methods, this sensitivity has profound implications. The normal velocity of the string points is often proportional to the local curvature, $v_n \\propto \\kappa$. If $h$ is small, any small noise in the string point positions will be hugely amplified into large, oscillating errors in the calculated curvature. These noisy curvature values then lead to large, noisy velocities, which cause erratic and unstable movement of the string points. This can destroy the smoothness of the simulated interface and cause the simulation to fail. This is a form of numerical instability. To mitigate this, practitioners often employ regularization techniques, such as using wider stencils (e.g., a 5-point fit), applying digital filters to the string point coordinates or the calculated curvature values, or using more sophisticated, variationally-derived curvature estimators that are more robust to noise.",
            "answer": "$$\\boxed{0.005999}$$"
        },
        {
            "introduction": "In practical semiconductor process simulations, evolving surfaces do not exist in isolation; they interact with rigid, pre-existing structures such as hard masks. This requires the implementation of robust boundary conditions to govern the motion of surface points that meet these fixed features. This practice delves into the mathematical formulation and implementation of such constraints, covering essential cases like sticking and slipping conditions that are critical for achieving physically realistic simulation outcomes in complex geometries. ",
            "id": "4170931",
            "problem": "Consider a two-dimensional cross-section of a semiconductor feature in a process model where the evolving material surface is represented by a discrete set of points connected as segments (a \"string\" representation), while the underlying physics can also be interpreted in a cell-based (finite-volume) framework. In the absence of constraints, each surface point evolves according to the kinematic law $$\\dot{\\mathbf{x}} = V_n \\,\\mathbf{n}_s,$$ where $\\mathbf{x}$ is the position, $V_n$ is the local normal speed (e.g., due to etch or deposition), and $\\mathbf{n}_s$ is the unit normal to the surface at that point. For points attached to a rigid mask edge, motion must satisfy boundary constraints. Two physically meaningful cases are:\n\n- No motion (perfect sticking): the point remains fixed with $$\\dot{\\mathbf{x}} = \\mathbf{0}.$$\n- Slip constrained to the rigid mask edge: the point is allowed to move only along the mask edge tangent $\\mathbf{t}_m$ (unit vector), with no motion through the mask characterized by the mask edge normal $\\mathbf{m}_n$ (unit vector), enforcing $$\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}} = 0.$$ The slip velocity may be either the projection of the unconstrained velocity onto the mask tangent or a specified slip speed $u_t$ along $\\mathbf{t}_m$.\n\nAt mask corners, where two rigid mask edges intersect with normals $\\mathbf{m}_{n,1}$ and $\\mathbf{m}_{n,2}$ and tangents $\\mathbf{t}_{m,1}$ and $\\mathbf{t}_{m,2}$, the admissible motion subspace is the intersection of the two tangent directions. In two dimensions, this intersection is generically trivial (the zero vector), resulting in $$\\dot{\\mathbf{x}} = \\mathbf{0}.$$\n\nStarting from the fundamental kinematic law $$\\dot{\\mathbf{x}} = V_n \\,\\mathbf{n}_s,$$ and the holonomic constraint formulation for rigid boundaries $$\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}} = 0,$$ derive, from first principles of constrained motion, the formulae to compute the constrained velocity $\\dot{\\mathbf{x}}$ of a boundary string point in the following cases:\n1. Perfect sticking to the rigid mask.\n2. Slip constrained to the mask edge with velocity given by a projection of the unconstrained velocity onto $\\mathbf{t}_m$.\n3. Slip constrained to the mask edge with a specified slip speed $u_t$ along $\\mathbf{t}_m$.\n4. Mask corner where two rigid edges meet.\n\nThen implement these constraints in a program that, for each test case, computes the updated position $$\\mathbf{x}_{\\text{new}} = \\mathbf{x} + \\dot{\\mathbf{x}}\\,\\Delta t$$ using a given time step $\\Delta t$, and verifies that the constraint is satisfied to numerical tolerance. Treat all vectors as two-dimensional, and assume all inputs use International System of Units (SI units). You must:\n- Express positions in meters, speeds in meters per second, and time in seconds.\n- Use angles only implicitly through provided vectors; do not compute or require angles explicitly.\n- Normalize any input vectors intended as unit vectors.\n- Use a numerical tolerance of $10^{-12}$ for constraint verification.\n\nYour program must solve the following test suite of cases:\n- Case A (sticking): $\\mathbf{x} = [5.0\\times 10^{-7},\\,2.0\\times 10^{-7}]$, $V_n = 4.0\\times 10^{-8}$, $\\mathbf{n}_s = [0,\\,1]$, $\\mathbf{t}_m = [1,\\,0]$, $\\mathbf{m}_n = [0,\\,1]$, type = \"stick\", $\\Delta t = 0.1$.\n- Case B (slip via projection): $\\mathbf{x} = [0.0,\\,0.0]$, $V_n = 1.0\\times 10^{-7}$, $\\mathbf{n}_s = [1/\\sqrt{2},\\,1/\\sqrt{2}]$, $\\mathbf{t}_m = [\\sqrt{3}/2,\\,1/2]$, $\\mathbf{m}_n = [-1/2,\\,\\sqrt{3}/2]$, type = \"slip_projected\", $\\Delta t = 0.2$.\n- Case C (specified slip): $\\mathbf{x} = [1.0\\times 10^{-6},\\,0.0]$, $V_n = 2.0\\times 10^{-8}$, $\\mathbf{n}_s = [1,\\,0]$, $\\mathbf{t}_m = [0,\\,1]$, $\\mathbf{m}_n = [1,\\,0]$, type = \"slip_specified\", $u_t = 1.2\\times 10^{-7}$, $\\Delta t = 0.05$.\n- Case D (corner, no motion): $\\mathbf{x} = [1.0\\times 10^{-7},\\,1.0\\times 10^{-7}]$, $V_n = 2.0\\times 10^{-7}$, $\\mathbf{n}_s = [1/\\sqrt{2},\\,-1/\\sqrt{2}]$, $\\mathbf{t}_{m,1} = [1,\\,0]$, $\\mathbf{m}_{n,1} = [0,\\,1]$, $\\mathbf{t}_{m,2} = [0,\\,1]$, $\\mathbf{m}_{n,2} = [1,\\,0]$, type = \"corner\", $\\Delta t = 0.05$.\n- Case E (projection with non-unit tangent, normalization required): $\\mathbf{x} = [-2.0\\times 10^{-6},\\,3.0\\times 10^{-6}]$, $V_n = 2.0\\times 10^{-7}$, $\\mathbf{n}_s = [1,\\,0]$, $\\mathbf{t}_m = [2,\\,0]$ (note: not unit length), $\\mathbf{m}_n = [0,\\,1]$, type = \"slip_projected\", $\\Delta t = 0.05$.\n\nFor each case, compute:\n- The updated position $\\mathbf{x}_{\\text{new}}$ in meters, as a list $[x_{\\text{new}}, y_{\\text{new}}]$.\n- A boolean indicating whether the enforced constraint is satisfied within $10^{-12}$.\n\nYour program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets, where each element is a list of the form $[x_{\\text{new}}, y_{\\text{new}}, \\text{constraint\\_ok}]$. For example: \"[[x1,y1,True],[x2,y2,False],...]\".",
            "solution": "The problem requires the derivation of formulae for the constrained velocity of a surface point at a rigid mask boundary, followed by a numerical implementation. The starting point for all cases is the unconstrained velocity of a surface point, given by the kinematic law:\n$$\n\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s\n$$\nwhere $\\dot{\\mathbf{x}}_u$ is the unconstrained velocity vector, $V_n$ is the local normal speed, and $\\mathbf{n}_s$ is the unit normal vector to the surface at the point $\\mathbf{x}$. All vectors are considered two-dimensional, i.e., $\\mathbf{v} = [v_x, v_y]$. When a point is on a rigid mask boundary, its motion is constrained. The constraint is expressed as a holonomic constraint on the velocity:\n$$\n\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0\n$$\nwhere $\\dot{\\mathbf{x}}_c$ is the constrained velocity and $\\mathbf{m}_n$ is the unit normal vector to the mask, pointing away from the permissible region of motion. This condition ensures the point does not move \"through\" the mask. Geometrically, this means the constrained velocity $\\dot{\\mathbf{x}}_c$ must be parallel to the mask edge, whose direction is given by the unit tangent vector $\\mathbf{t}_m$. In two dimensions, $\\mathbf{t}_m$ and $\\mathbf{m}_n$ are orthogonal, so $\\mathbf{t}_m \\cdot \\mathbf{m}_n = 0$.\n\nWe will now derive the expression for the constrained velocity $\\dot{\\mathbf{x}}_c$ for each of the four specified cases.\n\n**Case 1: Perfect sticking to the rigid mask**\n\nThis is the simplest case. The problem statement defines this condition as \"no motion\". This corresponds to a Dirichlet boundary condition on the velocity. Therefore, the constrained velocity is the zero vector:\n$$\n\\dot{\\mathbf{x}}_c = \\mathbf{0}\n$$\nThe constraint $\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0$ is trivially satisfied since $\\mathbf{m}_n \\cdot \\mathbf{0} = 0$. The physical interpretation is that the point is perfectly adhered to the mask and cannot move, regardless of the unconstrained surface evolution speed $V_n$. The new position after a time step $\\Delta t$ is simply the original position: $\\mathbf{x}_{\\text{new}} = \\mathbf{x} + \\mathbf{0} \\cdot \\Delta t = \\mathbf{x}$.\n\n**Case 2: Slip constrained to the mask edge (projected velocity)**\n\nIn this scenario, the point is free to slide along the mask edge. The velocity is constrained to be parallel to the mask tangent $\\mathbf{t}_m$. The problem specifies that the velocity's magnitude and direction are determined by the projection of the unconstrained velocity, $\\dot{\\mathbf{x}}_u$, onto the tangent direction $\\mathbf{t}_m$.\n\nThe projection of a vector $\\mathbf{v}$ onto a unit vector $\\mathbf{u}$ is given by the formula $(\\mathbf{v} \\cdot \\mathbf{u})\\mathbf{u}$. Applying this to our problem, the constrained velocity $\\dot{\\mathbf{x}}_c$ is the projection of $\\dot{\\mathbf{x}}_u$ onto $\\mathbf{t}_m$:\n$$\n\\dot{\\mathbf{x}}_c = (\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nSubstituting $\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s$, we obtain:\n$$\n\\dot{\\mathbf{x}}_c = ( (V_n \\mathbf{n}_s) \\cdot \\mathbf{t}_m ) \\mathbf{t}_m = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nThis velocity vector is, by construction, a scalar multiple of $\\mathbf{t}_m$. The constraint of no motion through the mask is satisfied because $\\mathbf{t}_m$ is orthogonal to $\\mathbf{m}_n$:\n$$\n\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = \\mathbf{m}_n \\cdot (V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) \\mathbf{t}_m) = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) (\\mathbf{m}_n \\cdot \\mathbf{t}_m) = V_n (\\mathbf{n}_s \\cdot \\mathbf{t}_m) (0) = 0\n$$\n\n**Case 3: Slip constrained to the mask edge (specified slip speed)**\n\nSimilar to the previous case, the motion is constrained to the direction of the mask tangent $\\mathbf{t}_m$. However, instead of the magnitude being determined by projection, it is given by a specified slip speed, $u_t$. The direction of slip along the tangent (+$\\mathbf{t}_m$ or -$\\mathbf{t}_m$) is determined by the component of the unconstrained velocity along the tangent. If the unconstrained velocity has a positive component along $\\mathbf{t}_m$, the point slips in the direction of $\\mathbf{t}_m$; if the component is negative, it slips opposite to $\\mathbf{t}_m$.\n\nThe signed component of $\\dot{\\mathbf{x}}_u$ along $\\mathbf{t}_m$ is given by the dot product $\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m$. The direction of slip is therefore $\\text{sign}(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m$, where the $\\text{sign}$ function returns $+1$, $-1$, or $0$. The velocity is the speed $u_t$ multiplied by this direction vector:\n$$\n\\dot{\\mathbf{x}}_c = u_t \\cdot \\text{sign}(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nSubstituting $\\dot{\\mathbf{x}}_u = V_n \\mathbf{n}_s$:\n$$\n\\dot{\\mathbf{x}}_c = u_t \\cdot \\text{sign}((V_n \\mathbf{n}_s) \\cdot \\mathbf{t}_m) \\mathbf{t}_m\n$$\nIf the tangential component of the unconstrained velocity is zero, i.e., $(\\dot{\\mathbf{x}}_u \\cdot \\mathbf{t}_m) = 0$, then $\\text{sign}(0)=0$ and the slip velocity is zero. The constraint $\\mathbf{m}_n \\cdot \\dot{\\mathbf{x}}_c = 0$ is satisfied by the same logic as in Case 2, since $\\dot{\\mathbf{x}}_c$ is parallel to $\\mathbf{t}_m$.\n\n**Case 4: Mask corner**\n\nAt a corner, the point is simultaneously on two different mask edges. These edges have distinct unit normal vectors, $\\mathbf{m}_{n,1}$ and $\\mathbf{m}_{n,2}$, and distinct unit tangent vectors, $\\mathbf{t}_{m,1}$ and $\\mathbf{t}_{m,2}$. For the point to remain on both edges, its velocity $\\dot{\\mathbf{x}}_c$ must satisfy both constraints simultaneously:\n$$\n\\mathbf{m}_{n,1} \\cdot \\dot{\\mathbf{x}}_c = 0 \\quad \\text{and} \\quad \\mathbf{m}_{n,2} \\cdot \\dot{\\mathbf{x}}_c = 0\n$$\nThe first condition implies that $\\dot{\\mathbf{x}}_c$ must be parallel to $\\mathbf{t}_{m,1}$ (since $\\mathbf{t}_{m,1}$ is the null space of $\\mathbf{m}_{n,1}$ in this context). The second condition implies that $\\dot{\\mathbf{x}}_c$ must also be parallel to $\\mathbf{t}_{m,2}$.\nSo, there must exist scalars $k_1$ and $k_2$ such that:\n$$\n\\dot{\\mathbf{x}}_c = k_1 \\mathbf{t}_{m,1} \\quad \\text{and} \\quad \\dot{\\mathbf{x}}_c = k_2 \\mathbf{t}_{m,2}\n$$\nThis requires $k_1 \\mathbf{t}_{m,1} = k_2 \\mathbf{t}_{m,2}$. In a two-dimensional space, if the vectors $\\mathbf{t}_{m,1}$ and $\\mathbf{t}_{m,2}$ are linearly independent (i.e., not parallel, which is true for any genuine corner), the only solution to this equation is the trivial one: $k_1 = 0$ and $k_2 = 0$.\nTherefore, the only possible constrained velocity is the zero vector:\n$$\n\\dot{\\mathbf{x}}_c = \\mathbf{0}\n$$\nThis is effectively a \"sticking\" condition imposed by the geometry of the corner. Both boundary constraints are trivially satisfied.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves for the updated position and constraint satisfaction for several test cases\n    of a surface point evolution under different boundary conditions.\n    \"\"\"\n\n    # Numerical tolerance for constraint verification\n    TOL = 1e-12\n\n    # Test suite definition\n    test_cases = [\n        {\n            'name': 'Case A (sticking)',\n            'type': 'stick',\n            'x': np.array([5.0e-7, 2.0e-7]),\n            'Vn': 4.0e-8,\n            'ns': np.array([0.0, 1.0]),\n            'tm': np.array([1.0, 0.0]),\n            'mn': np.array([0.0, 1.0]),\n            'dt': 0.1\n        },\n        {\n            'name': 'Case B (slip via projection)',\n            'type': 'slip_projected',\n            'x': np.array([0.0, 0.0]),\n            'Vn': 1.0e-7,\n            'ns': np.array([1/math.sqrt(2), 1/math.sqrt(2)]),\n            'tm': np.array([math.sqrt(3)/2, 1/2]),\n            'mn': np.array([-1/2, math.sqrt(3)/2]),\n            'dt': 0.2\n        },\n        {\n            'name': 'Case C (specified slip)',\n            'type': 'slip_specified',\n            'x': np.array([1.0e-6, 0.0]),\n            'Vn': 2.0e-8,\n            'ns': np.array([1.0, 0.0]),\n            'tm': np.array([0.0, 1.0]),\n            'mn': np.array([1.0, 0.0]),\n            'ut': 1.2e-7,\n            'dt': 0.05\n        },\n        {\n            'name': 'Case D (corner, no motion)',\n            'type': 'corner',\n            'x': np.array([1.0e-7, 1.0e-7]),\n            'Vn': 2.0e-7,\n            'ns': np.array([1/math.sqrt(2), -1/math.sqrt(2)]),\n            't_m1': np.array([1.0, 0.0]),\n            'm_n1': np.array([0.0, 1.0]),\n            't_m2': np.array([0.0, 1.0]),\n            'm_n2': np.array([1.0, 0.0]),\n            'dt': 0.05\n        },\n        {\n            'name': 'Case E (projection with non-unit tangent)',\n            'type': 'slip_projected',\n            'x': np.array([-2.0e-6, 3.0e-6]),\n            'Vn': 2.0e-7,\n            'ns': np.array([1.0, 0.0]),\n            'tm': np.array([2.0, 0.0]), # Not unit length\n            'mn': np.array([0.0, 1.0]),\n            'dt': 0.05\n        }\n    ]\n\n    results = []\n\n    def normalize(v):\n        \"\"\"Normalizes a 2D numpy vector, handling the zero vector case.\"\"\"\n        norm = np.linalg.norm(v)\n        if norm == 0:\n            return v\n        return v / norm\n\n    for case in test_cases:\n        v_c = np.array([0.0, 0.0])\n        constraint_ok = False\n\n        # --- Calculate Constrained Velocity ---\n\n        if case['type'] == 'stick':\n            # Velocity is zero for a sticking point.\n            v_c = np.array([0.0, 0.0])\n            # Constraint verification based on velocity magnitude.\n            constraint_ok = np.linalg.norm(v_c)  TOL\n        \n        elif case['type'] == 'corner':\n            # Velocity is zero for a corner point.\n            v_c = np.array([0.0, 0.0])\n            m_n1 = normalize(case['m_n1'])\n            m_n2 = normalize(case['m_n2'])\n            # Verify both holonomic constraints.\n            check1 = abs(np.dot(m_n1, v_c))  TOL\n            check2 = abs(np.dot(m_n2, v_c))  TOL\n            constraint_ok = check1 and check2\n\n        elif case['type'] == 'slip_projected':\n            ns = normalize(case['ns'])\n            tm = normalize(case['tm'])\n            mn = normalize(case['mn'])\n            Vn = case['Vn']\n            \n            v_u = Vn * ns\n            v_c = np.dot(v_u, tm) * tm\n            \n            # Verify the holonomic constraint.\n            constraint_ok = abs(np.dot(mn, v_c))  TOL\n\n        elif case['type'] == 'slip_specified':\n            ns = normalize(case['ns'])\n            tm = normalize(case['tm'])\n            mn = normalize(case['mn'])\n            Vn = case['Vn']\n            ut = case['ut']\n            \n            v_u = Vn * ns\n            tangential_comp = np.dot(v_u, tm)\n            \n            v_c = ut * np.sign(tangential_comp) * tm\n            \n            # Verify the holonomic constraint.\n            constraint_ok = abs(np.dot(mn, v_c))  TOL\n\n        # --- Update Position and Store Result ---\n        \n        x = case['x']\n        dt = case['dt']\n        x_new = x + v_c * dt\n        \n        results.append([x_new[0], x_new[1], constraint_ok])\n\n    # Format the output string to match the required format precisely,\n    # without spaces inside the inner lists.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "One of the most significant challenges in surface evolution modeling is handling topological changes, where a single continuous surface may split into multiple disconnected parts, or vice-versa. This exercise addresses the classic problem of a narrow neck \"pinching off\" during an etch process. You will develop an algorithm based on a clear physical criterion to detect this topological event and ensure that the connectivity data structures for both the string representation and the underlying cell-based grid remain consistent, a crucial capability for robust, long-time simulations. ",
            "id": "4170909",
            "problem": "Consider a two-dimensional cross-sectional string-based representation of a semiconductor feature evolving under isotropic etching. The surface is discretized by a polyline (the \"string\") and the material domain is represented by a cell-based grid. An initially connected feature contains a narrow neck. As etching proceeds, the neck can pinch off, causing a topological change, which must be captured both in the string representation and in the cell-based graph to maintain consistent connectivity data structures.\n\nFundamental base. Assume isotropic etch with constant normal velocity. Let the local normal velocity be denoted by $v_n$ with units of nanometers per second ($nm/s$). Let the neck width at time $t$ be $w(t)$, measured along the direction of the narrowest separation between two opposing surface segments. Define a unit vector $\\hat{e}_w$ along the direction of $w$ and outward unit normals $\\mathbf{n}_u$ and $\\mathbf{n}_\\ell$ on the upper and lower opposing surfaces at the neck. Under the assumption of locally planar opposing surfaces, the rate of change of the neck width is given by the sum of projections of the normal motion on $\\hat{e}_w$:\n$$\n\\frac{dw}{dt} = - v_n \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) - v_n \\left( -\\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right) = - v_n \\left[ \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) + \\left( \\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right) \\right].\n$$\nDefine the alignment factor $c \\in [0,2]$ by\n$$\nc := \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) + \\left( \\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right),\n$$\nso that the discrete-time update over a time step $\\Delta t$ is\n$$\nw_{k+1} = \\max\\left( w_k - c \\, v_n \\, \\Delta t, \\, 0 \\right).\n$$\nThis model uses nanometers ($nm$) for all lengths and seconds ($s$) for time.\n\nCell-based splitting criterion. Let the cell size be $h$ in nanometers. In a cell-based occupancy representation, a bridge of at least one full cell across the neck is required to maintain connectivity. Define the corridor cell count $m = \\left\\lfloor \\frac{w}{h} \\right\\rfloor$. A cell-based disconnection event occurs when $m = 0$, equivalently when $w  h$. This induces a required split of the string connectivity at the neck to maintain consistency.\n\nConnectivity data structures. The string is a graph whose nodes are ordered points along the polyline, with edges between consecutive nodes. The cell-based domain is a graph whose nodes are cells and edges encode $4$-connectivity. Consistency requires that the number of connected components in the string graph match the number of connected components in the cell graph at the same time index where the neck is evaluated.\n\nTask. Starting from the above fundamentals, derive the criterion to split the string and design an algorithm that:\n- Advances the neck width using the discrete update $w_{k+1} = \\max\\left( w_k - c \\, v_n \\, \\Delta t, \\, 0 \\right)$.\n- Triggers a split when $w  h$ at the beginning of any time step $k$ (including $k=0$), or as soon as the update produces $w  h$.\n- Updates the string graph by removing the single edge that spans the neck region (assume the neck is localized at the midpoint of the ordered string nodes).\n- Builds a simplified cell graph representation consisting of two bulk regions connected by a corridor of $m = \\left\\lfloor \\frac{w}{h} \\right\\rfloor$ cells; use $4$-connectivity between cells and between the corridor endpoints and the bulk regions.\n- Checks consistency by comparing the number of connected components of the updated string graph to the number of connected components of the cell graph at the same time index.\n\nYour program must implement this algorithm and evaluate the following test suite, expressed with all lengths in $nm$ and times in $s$:\n\n- Test case $1$ (happy path with split after evolution): $w_0 = 40$, $v_n = 10$, $c = 2$, $\\Delta t = 1$, steps $= 3$, $h = 10$.\n- Test case $2$ (boundary equality initially, split occurs after one step): $w_0 = 10$, $v_n = 5$, $c = 1$, $\\Delta t = 1$, steps $= 1$, $h = 10$.\n- Test case $3$ (no split): $w_0 = 50$, $v_n = 2$, $c = 1.5$, $\\Delta t = 1$, steps $= 10$, $h = 15$.\n- Test case $4$ (immediate split at $k=0$): $w_0 = 8$, $v_n = 4$, $c = 2$, $\\Delta t = 0.5$, steps $= 1$, $h = 10$.\n\nFor each test case, output a pair $[s, q]$ where $s$ is a boolean indicating whether a split occurred at or before the final step and $q$ is a boolean indicating whether the string and cell connectivity graphs are consistent at the evaluation time (the split time if a split occurs, otherwise the final time). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the pair for one test case, for example $[[\\text{True},\\text{False}],[\\text{False},\\text{True}],\\dots]$.",
            "solution": "The problem requires the design and implementation of an algorithm to model a topological change—a neck pinch-off—in a semiconductor feature during an isotropic etch process. The model uses a hybrid representation: a continuous string (polyline) for the surface and a discrete cell-based grid for the material domain. The core task is to simulate the thinning of a narrow neck, detect when a split occurs, and verify the consistency between the connectivity of the string and cell-based data structures at the time of evaluation.\n\nThe physical model is based on a constant isotropic etch rate, where the surface moves inward along its normal direction with a constant velocity $v_n$. The evolution of the neck width, $w$, is simplified by considering two locally planar, opposing surface segments. The rate of change of the width is given by:\n$$\n\\frac{dw}{dt} = - v_n \\left[ \\left( \\mathbf{n}_u \\cdot \\hat{e}_w \\right) + \\left( \\mathbf{n}_\\ell \\cdot \\hat{e}_w \\right) \\right]\n$$\nwhere $\\mathbf{n}_u$ and $\\mathbf{n}_\\ell$ are the outward unit normals of the upper and lower surfaces at the neck, and $\\hat{e}_w$ is the unit vector along the direction of the width measurement. The term in the brackets is defined as the alignment factor $c$, which ranges from $c=0$ (normals are perpendicular to the width direction, no thinning) to $c=2$ (normals are anti-parallel and aligned with the width direction, maximum thinning rate).\n\nThe algorithm proceeds by discretizing this evolution in time with a time step $\\Delta t$. The neck width at step $k+1$ is updated from its value at step $k$ using the explicit Euler formula, with a non-negativity constraint:\n$$\nw_{k+1} = \\max\\left( w_k - c \\, v_n \\, \\Delta t, \\, 0 \\right)\n$$\nThis equation forms the basis of the simulation aspect of the task.\n\nThe central part of the problem lies in coupling this continuous evolution of $w$ with the discrete cell-based representation. A key parameter is the cell size, $h$. The problem defines a cell-based disconnection event as the point where the neck width $w$ becomes smaller than one cell size $h$. This is a physically and numerically motivated criterion: a feature narrower than the grid resolution cannot be considered a connecting bridge in the cell-based domain. This criterion is formally stated as triggering a split when $w_k  h$ for any time step $k \\ge 0$.\n\nThe algorithm to be designed must therefore perform the following steps for each test case:\n1.  **Initialization**: Set the initial width to $w_0$.\n2.  **Time Evolution**: Iterate from an initial time step $k=0$ up to the maximum number of steps specified. In each iteration, calculate the width for the next time step using the discrete update formula. The history of width values, $w_k$, is stored or tracked.\n3.  **Split Detection**: At each time step $k$, including the initial state $k=0$, check if the condition $w_k  h$ is met. The first time step at which this condition holds is the \"split time\". If the condition is met, a split event is registered, and the simulation for this test case is effectively concluded, with the evaluation performed at this step. If the condition is never met within the given number of steps, no split occurs, and the evaluation is performed at the final step.\n4.  **Consistency Verification**: At the determined evaluation time (either the split time or the final simulation time), the connectivity of the two graph representations must be checked for consistency.\n    -   **String Graph Connectivity**: The string is modeled as being initially connected, having $1$ connected component. If a split event is triggered, an edge is removed, resulting in $2$ connected components. Thus, the number of string components is $2$ if a split occurred and $1$ otherwise.\n    -   **Cell Graph Connectivity**: The connectivity of the cell-based representation is determined by the number of cells forming a corridor across the neck, $m = \\left\\lfloor \\frac{w}{h} \\right\\rfloor$, where $w$ is the neck width at the evaluation time. If $m \\ge 1$, a path of cells exists, and the graph is connected ($1$ component). If $m=0$, no such path exists, and the graph is disconnected ($2$ components).\n    -   **The Check**: The algorithm compares the number of components from both graph models. Consistency is confirmed if the numbers match.\n\nThe problem's definitions intrinsically link the two representations. A split is triggered if and only if $wh$.\n-   If a split occurs, the string graph has $2$ components. The condition $wh$ also implies $0 \\le w/h  1$, which means $m = \\lfloor w/h \\rfloor = 0$. This, by definition, means the cell graph has $2$ components. Consistency holds.\n-   If no split occurs, the string graph has $1$ component. This means that at the evaluation time, $w \\ge h$. This implies $w/h \\ge 1$, which means $m = \\lfloor w/h \\rfloor \\ge 1$. This, by definition, means the cell graph has $1$ component. Consistency holds.\nTherefore, the model is architected to be consistent. The task is to implement the algorithm that formally verifies this for each specific test case. The program will calculate the evolution of $w$, determine if and when a split occurs, and then perform the component-counting for both graphs at the correct evaluation time to produce the required boolean outputs for `split_occurred` and `consistency`.\n\nThe implementation will process a list of test cases, with each case defined by the parameters $(w_0, v_n, c, \\Delta t, \\text{steps}, h)$. For each case, it will compute the history of $w_k$ values, find the evaluation step, and then determine the split status and consistency, formatting the results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (w0, vn, c, dt, steps, h)\n    #\n    # Test case 1 (happy path with split after evolution): \n    #   w0=40, vn=10, c=2, dt=1, steps=3, h=10.\n    # Test case 2 (boundary equality initially, split occurs after one step): \n    #   w0=10, vn=5, c=1, dt=1, steps=1, h=10.\n    # Test case 3 (no split): \n    #   w0=50, vn=2, c=1.5, dt=1, steps=10, h=15.\n    # Test case 4 (immediate split at k=0): \n    #   w0=8, vn=4, c=2, dt=0.5, steps=1, h=10.\n    \n    test_cases = [\n        (40, 10, 2, 1, 3, 10),\n        (10, 5, 1, 1, 1, 10),\n        (50, 2, 1.5, 1, 10, 15),\n        (8, 4, 2, 0.5, 1, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        w0, vn, c, dt, steps, h = case\n        \n        # Calculate the evolution of the neck width over time\n        w_history = [w0]\n        w_current = w0\n        for _ in range(steps):\n            # w_{k+1} = max(w_k - c * v_n * dt, 0)\n            w_next = max(w_current - c * vn * dt, 0.0)\n            w_history.append(w_next)\n            w_current = w_next\n\n        # Determine if and when a split occurred\n        split_occurred = False\n        evaluation_k = steps  # Evaluate at the final step if no split\n        for k, w_k in enumerate(w_history):\n            if w_k  h:\n                split_occurred = True\n                evaluation_k = k\n                break\n        \n        # Get the width at the evaluation time\n        final_w = w_history[evaluation_k]\n\n        # Perform the consistency check at the evaluation time\n        \n        # 1. Determine the number of connected components in the string graph\n        #    The string graph is split (2 components) if a split event occurred.\n        #    Otherwise, it remains connected (1 component).\n        string_components = 2 if split_occurred else 1\n        \n        # 2. Determine the number of connected components in the cell graph\n        #    Corridor cell count m = floor(w/h).\n        #    If m=0, the graph is disconnected (2 components).\n        #    If m=1, the graph is connected (1 component).\n        m = np.floor(final_w / h)\n        cell_components = 2 if m == 0 else 1\n        \n        # 3. Check for consistency\n        #    The number of components in both graphs must match.\n        consistency = (string_components == cell_components)\n        \n        # Format the result pair as a string '[s,q]' without spaces\n        result_pair_str = f\"[{str(split_occurred)},{str(consistency)}]\"\n        results.append(result_pair_str)\n\n    # Final print statement in the exact required format '[[s1,q1],[s2,q2],...]'\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}