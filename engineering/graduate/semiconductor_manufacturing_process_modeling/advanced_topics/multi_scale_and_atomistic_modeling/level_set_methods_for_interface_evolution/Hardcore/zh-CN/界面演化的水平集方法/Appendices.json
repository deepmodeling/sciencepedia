{
    "hands_on_practices": [
        {
            "introduction": "本练习将带您深入了解水平集方法的核心驱动——数值更新步骤。您将亲手计算一个时间步内的界面演化，这有助于您理解戈杜诺夫（Godunov）格式等迎风格式如何精确捕捉信息传播方向，这对于求解哈密顿-雅可比方程至关重要。通过这个实践 ，您将巩固对数值哈密顿量在实际计算中应用的理解。",
            "id": "4138484",
            "problem": "考虑一个在半导体等离子体刻蚀中，界面在外部给定速度场下演化的二维水平集公式。水平集函数 $\\phi(x,y,t)$ 表示到演化界面的有符号距离，其演化由哈密顿-雅可比方程控制\n$$\n\\phi_{t} + F(x,y)\\,|\\nabla \\phi| = 0,\n$$\n其中 $F(x,y)$ 是法向速度。给定一个均匀笛卡尔网格，其空间步长为 $\\Delta x = \\Delta y = 0.02\\,\\mu\\mathrm{m}$，以及单个显式时间步长 $\\Delta t = 0.05\\,\\mathrm{s}$。数值更新必须使用一个单调的Godunov数值哈密顿量，该哈密顿量与相对于局部速度符号的正确迎风选择相一致。必须满足库朗-弗里德里希斯-列维（CFL）条件。通过在区域边界处使用鬼点反射来施加齐次诺伊曼边界条件（$\\partial \\phi/\\partial n = 0$）。\n\n在以网格索引 $(i,j)=(2,2)$ 为中心的 $3 \\times 3$ 模板上，时间 $t^{n}$ 时的当前水平集函数值为\n$$\n\\phi_{1,1} = 0.012\\,\\mu\\mathrm{m},\\quad \\phi_{2,1} = 0.006\\,\\mu\\mathrm{m},\\quad \\phi_{3,1} = 0.001\\,\\mu\\mathrm{m},\n$$\n$$\n\\phi_{1,2} = 0.010\\,\\mu\\mathrm{m},\\quad \\phi_{2,2} = 0.002\\,\\mu\\mathrm{m},\\quad \\phi_{3,2} = -0.002\\,\\mu\\mathrm{m},\n$$\n$$\n\\phi_{1,3} = 0.008\\,\\mu\\mathrm{m},\\quad \\phi_{2,3} = -0.004\\,\\mu\\mathrm{m},\\quad \\phi_{3,3} = -0.006\\,\\mu\\mathrm{m}.\n$$\n中心的局部速度场为\n$$\nF_{2,2} = -0.18\\,\\mu\\mathrm{m}/\\mathrm{s}.\n$$\n\n从哈密顿-雅可比方程和均匀网格上单边有限差分的定义出发，构造与粘性解以及适用于 $F_{2,2}$ 符号的迎风格式相一致的Godunov数值哈密顿量，并计算显式更新\n$$\n\\phi^{n+1}_{2,2} = \\phi^{n}_{2,2} - \\Delta t \\, H_{G},\n$$\n其中 $H_{G}$ 是在 $(i,j)=(2,2)$ 处求值的Godunov数值哈密顿量。在组合单边差分时，仅使用给定的模板值。验证对于给定的 $\\Delta t$，CFL条件是满足的。\n\n给出 $\\phi^{n+1}_{2,2}$ 的数值，四舍五入到四位有效数字。最终答案以 $\\mu\\mathrm{m}$ 为单位表示。",
            "solution": "用户要求解答一个涉及水平集方法的数值问题。\n\n### 步骤1：提取给定条件\n-   控制方程是关于水平集函数 $\\phi(x,y,t)$ 的哈密顿-雅可比方程：$\\phi_{t} + F(x,y)\\,|\\nabla \\phi| = 0$。\n-   网格是均匀笛卡尔网格，空间步长为 $\\Delta x = \\Delta y = 0.02\\,\\mu\\mathrm{m}$。\n-   时间步长为 $\\Delta t = 0.05\\,\\mathrm{s}$。\n-   数值更新格式是显式的：$\\phi^{n+1}_{i,j} = \\phi^{n}_{i,j} - \\Delta t \\, H_{G}$，其中 $H_G$ 是Godunov数值哈密顿量。\n-   模板中心的局部速度为 $F_{2,2} = -0.18\\,\\mu\\mathrm{m}/\\mathrm{s}$。\n-   在以 $(i,j)=(2,2)$ 为中心的 $3 \\times 3$ 模板上，时间 $t^n$ 时的水平集值为：\n    $$\n    \\begin{pmatrix} \\phi_{1,3}  \\phi_{2,3}  \\phi_{3,3} \\\\ \\phi_{1,2}  \\phi_{2,2}  \\phi_{3,2} \\\\ \\phi_{1,1}  \\phi_{2,1}  \\phi_{3,1} \\end{pmatrix}\n    =\n    \\begin{pmatrix} 0.008  -0.004  -0.006 \\\\ 0.010  0.002  -0.002 \\\\ 0.012  0.006  0.001 \\end{pmatrix}\n    \\,\\mu\\mathrm{m}\n    $$\n    注意：题目文本将点 $(i,j-1)$ 列为第一行，但标准矩阵表示法将 $j=1$ 映射到底部行。这些值为：\n    $\\phi_{1,1} = 0.012, \\phi_{2,1} = 0.006, \\phi_{3,1} = 0.001$\n    $\\phi_{1,2} = 0.010, \\phi_{2,2} = 0.002, \\phi_{3,2} = -0.002$\n    $\\phi_{1,3} = 0.008, \\phi_{2,3} = -0.004, \\phi_{3,3} = -0.006$\n    （单位均为 $\\mu\\mathrm{m}$）。\n-   $\\phi^{n+1}_{2,2}$ 的最终数值应四舍五入到四位有效数字，并以 $\\mu\\mathrm{m}$ 为单位表示。\n-   必须验证库朗-弗里德里希斯-列维（CFL）条件。\n\n### 步骤2：使用提取的给定条件进行验证\n-   **科学依据**：该问题描述了应用水平集方法，使用标准的一阶显式Godunov类型格式来求解哈密顿-雅可比方程。这是一种在包括半导体工艺建模在内的多个领域中使用的成熟且正确的数值技术。该提法在科学上是合理的。\n-   **适定性**：该问题提供了所有必要的数据（模板上的初始值、网格参数、时间步长、速度场值），并指定了一个明确定义的数值算法。可以计算出唯一的数值结果。\n-   **客观性**：该问题使用精确的数学术语和客观数据进行陈述。没有主观或含糊的陈述。\n-   **完整性与一致性**：所有必需的数据都已给出。问题要求验证CFL条件，这是一个作为解答一部分需要执行的一致性检查，而不是题目陈述中的缺陷。所提供的数据是一致的。\n-   **其他标准**：该问题并非无关紧要、比喻性或科学上不可验证的。\n\n### 步骤3：结论与行动\n该问题是有效的。将提供解答。\n\n### 解答\n\n水平集函数 $\\phi$ 的演化由哈密顿-雅可比方程控制：\n$$\n\\phi_t + F |\\nabla \\phi| = 0\n$$\n我们被要求使用单个显式前向欧拉时间步来计算更新后的值 $\\phi^{n+1}_{2,2}$：\n$$\n\\phi^{n+1}_{i,j} = \\phi^{n}_{i,j} - \\Delta t H_{G}\n$$\n其中 $H_G$ 是一个近似于 $F |\\nabla \\phi|$ 的Godunov数值哈密顿量。对于这类问题，一个与粘性解一致的标准选择是Engquist-Osher格式。该格式的形式取决于速度 $F$ 的符号。\n\n均匀网格上的单边有限差分算子定义如下：\n$$ D_x^- \\phi_{i,j} = \\frac{\\phi_{i,j} - \\phi_{i-1,j}}{\\Delta x}, \\quad D_x^+ \\phi_{i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x} $$\n$$ D_y^- \\phi_{i,j} = \\frac{\\phi_{i,j} - \\phi_{i,j-1}}{\\Delta y}, \\quad D_y^+ \\phi_{i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y} $$\n$|\\nabla \\phi|^2$ 的近似由 $(\\hat{|\\nabla\\phi|})^2 = (\\nabla_x \\phi)^2 + (\\nabla_y \\phi)^2$ 给出。对于哈密顿量 $H=F\\sqrt{\\phi_x^2 + \\phi_y^2}$，Engquist-Osher迎风格式为：\n如果 $F \\ge 0$：$(\\nabla_x \\phi)^2 = (\\max(D_x^-\\phi, 0))^2 + (\\min(D_x^+\\phi, 0))^2$。\n如果 $F  0$：$(\\nabla_x \\phi)^2 = (\\max(D_x^+\\phi, 0))^2 + (\\min(D_x^-\\phi, 0))^2$。\n同样的规则适用于 $y$ 方向的导数分量。\n\n在本问题中，$F_{2,2} = -0.18\\,\\mu\\mathrm{m}/\\mathrm{s}$，是负数。我们必须使用第二种情况（$F  0$）。\n\n首先，我们使用给定的模板数据和 $\\Delta x = \\Delta y = 0.02\\,\\mu\\mathrm{m}$，计算网格点 $(i,j)=(2,2)$ 处所需的单边差分。\n$$\nD_x^+ \\phi_{2,2} = \\frac{\\phi_{3,2} - \\phi_{2,2}}{\\Delta x} = \\frac{-0.002 - 0.002}{0.02} = \\frac{-0.004}{0.02} = -0.2\n$$\n$$\nD_x^- \\phi_{2,2} = \\frac{\\phi_{2,2} - \\phi_{1,2}}{\\Delta x} = \\frac{0.002 - 0.010}{0.02} = \\frac{-0.008}{0.02} = -0.4\n$$\n$$\nD_y^+ \\phi_{2,2} = \\frac{\\phi_{2,3} - \\phi_{2,2}}{\\Delta y} = \\frac{-0.004 - 0.002}{0.02} = \\frac{-0.006}{0.02} = -0.3\n$$\n$$\nD_y^- \\phi_{2,2} = \\frac{\\phi_{2,2} - \\phi_{2,1}}{\\Delta y} = \\frac{0.002 - 0.006}{0.02} = \\frac{-0.004}{0.02} = -0.2\n$$\n接下来，我们使用适用于 $F  0$ 的格式计算数值梯度模平方的分量：\n$$\n(\\nabla_x \\phi)^2 = (\\max(D_x^+ \\phi_{2,2}, 0))^2 + (\\min(D_x^- \\phi_{2,2}, 0))^2 = (\\max(-0.2, 0))^2 + (\\min(-0.4, 0))^2 = 0^2 + (-0.4)^2 = 0.16\n$$\n$$\n(\\nabla_y \\phi)^2 = (\\max(D_y^+ \\phi_{2,2}, 0))^2 + (\\min(D_y^- \\phi_{2,2}, 0))^2 = (\\max(-0.3, 0))^2 + (\\min(-0.2, 0))^2 = 0^2 + (-0.2)^2 = 0.04\n$$\n数值梯度的模平方为：\n$$\n(\\hat{|\\nabla\\phi|})^2 = (\\nabla_x \\phi)^2 + (\\nabla_y \\phi)^2 = 0.16 + 0.04 = 0.20\n$$\n因此，数值梯度的模为：\n$$\n\\hat{|\\nabla\\phi|} = \\sqrt{0.20}\n$$\n在 $(2,2)$ 处的Godunov数值哈密顿量 $H_G$ 为：\n$$\nH_G = F_{2,2} \\cdot \\hat{|\\nabla\\phi|} = -0.18 \\times \\sqrt{0.20}\n$$\n现在我们计算更新后的水平集函数值 $\\phi^{n+1}_{2,2}$。给定 $\\phi^n_{2,2} = 0.002\\,\\mu\\mathrm{m}$ 和 $\\Delta t = 0.05\\,\\mathrm{s}$。\n$$\n\\phi^{n+1}_{2,2} = \\phi^{n}_{2,2} - \\Delta t H_{G} = 0.002 - (0.05) \\left( -0.18 \\sqrt{0.20} \\right)\n$$\n$$\n\\phi^{n+1}_{2,2} = 0.002 + (0.05 \\times 0.18) \\sqrt{0.20} = 0.002 + 0.009 \\sqrt{0.20}\n$$\n对此表达式进行数值计算：\n$$\n\\phi^{n+1}_{2,2} \\approx 0.002 + 0.009 \\times 0.4472135955...\n$$\n$$\n\\phi^{n+1}_{2,2} \\approx 0.002 + 0.0040249223...\n$$\n$$\n\\phi^{n+1}_{2,2} \\approx 0.0060249223...\n$$\n四舍五入到四位有效数字，我们得到 $0.006025\\,\\mu\\mathrm{m}$。\n\n最后，我们必须验证显式格式的CFL条件。对于在 $\\Delta x = \\Delta y$ 的网格上的方程 $\\phi_t + F|\\nabla \\phi| = 0$，其条件为：\n$$\n\\Delta t \\left( \\frac{|F|}{\\Delta x} + \\frac{|F|}{\\Delta y} \\right) \\le 1\n$$\n代入给定值：\n$|F| = |-0.18| = 0.18\\,\\mu\\mathrm{m}/\\mathrm{s}$，$\\Delta t = 0.05\\,\\mathrm{s}$，以及 $\\Delta x = \\Delta y = 0.02\\,\\mu\\mathrm{m}$。\n$$\n0.05 \\left( \\frac{0.18}{0.02} + \\frac{0.18}{0.02} \\right) = 0.05 (9 + 9) = 0.05 \\times 18 = 0.9\n$$\n由于 $0.9 \\le 1$，CFL条件得到满足，显式时间步是稳定的。\n\n中心节点的水平集函数的更新值为 $\\phi^{n+1}_{2,2} \\approx 0.006025\\,\\mu\\mathrm{m}$。",
            "answer": "$$\\boxed{0.006025}$$"
        },
        {
            "introduction": "虽然界面演化是水平集方法的核心，但为了保证数值的稳定性和精度，维持水平集函数作为符号距离函数的性质也同样关键。本练习旨在解决“重新初始化”这一挑战，要求您实现高效的快速扫描法（fast sweeping method）来求解程函方程（Eikonal equation） $|\\nabla \\phi| = 1$。这项实践  将引导您从单个时间步的计算，过渡到实现一个完整的、对于维持水平集方法鲁棒性至关重要的算法。",
            "id": "4138511",
            "problem": "考虑用于符号距离函数的一维程函方程，在一维空间中可写作 $|\\partial \\phi / \\partial x| = 1$。在用于刻蚀和沉积前沿追踪的半导体制造过程建模中，水平集方法将演化的界面表示为函数 $\\phi(x)$ 的零水平集，而重新初始化为符号距离函数是稳定平流、曲率计算和窄带操作的常用步骤。在一维空间中，到给定界面 $\\Gamma$ 的符号距离函数 $d(x)$ 满足 $d(x) = \\inf_{y \\in \\Gamma} |x - y|$ 并且在 $d$ 不可微的点（例如，与多个界面点等距的 $x$ 处）之外几乎处处满足 $|\\partial d / \\partial x| = 1$。\n\n你的任务是实现一个完整的一维快速扫描方法，用于求解程函方程，以在均匀网格上获得符号距离函数 $\\phi(x)$。该方法从一个连续分段线性初始函数 $\\phi_0(x)$ 开始，此函数将初始界面定义为满足 $\\phi_0(x) = 0$ 的点集。你必须：\n\n- 在有限区间 $[0, L]$ 上使用均匀网格 $x_i$，网格间距为 $\\Delta x = L / (N - 1)$，其中 $L$（以微米 $\\mu\\mathrm{m}$ 为单位）和 $N$ 将被提供。\n- 通过识别网格上 $\\phi_0(x)$ 的过零点来确定界面位置。如果过零点严格位于两个网格点之间，则通过对这两点间的 $\\phi_0$ 进行线性插值来定位该点。如果任何网格点满足 $\\phi_0(x_i) = 0$，则将其视为界面点。\n- 使用已识别的界面位置，通过适当的子单元边界条件来初始化无符号距离 $T(x)$。然后使用一种快速扫描算法，该算法包含交替的从左到右和从右到左的扫描过程，通过与 $|\\partial T / \\partial x| = 1$ 和一维特征线单调性一致的因果上风传播来更新 $T$。\n- 在所有网格点上，通过将 $\\phi_0(x)$ 的符号赋给 $T(x)$ 来恢复符号距离 $\\phi(x)$，并在 $\\phi_0(x) = 0$ 的网格点处令 $\\phi(x) = 0$。\n- 通过计算内部点的离散梯度大小，并排除离散的扭结（即单边离散导数在某个网格点两侧变号的位置），在指定的容差范围内验证网格上的性质 $|\\nabla \\phi| = 1$（将 $\\nabla$ 解释为一维空间导数）。报告在所有被检查的点上与 1 的最大绝对偏差是否小于或等于给定的容差。\n\n你必须使用的基本原理和定义：\n- 符号距离的定义 $d(x) = \\inf_{y \\in \\Gamma} |x - y|$ 以及程函方程在不可微点之外的性质 $|\\partial d / \\partial x| = 1$。\n- 一维 Hamilton-Jacobi 方程特征线的因果性和单调性，这为快速扫描方法的定向扫描提供了理论依据。\n\n通过指定一组 $x_k$ 单调递增的锚点 $(x_k, \\phi_k)$，并在连续的锚点之间使用线性插值，来将 $\\phi_0(x)$ 构建为一个连续分段线性函数。这些锚点对定义域进行划分，并确保 $\\phi_0(x)$ 的连续性。\n\n你的程序必须以数值稳定且与上述基本原理在科学上一致的方式实现该算法。然后，它必须在离散导数不变号的内部网格点上评估验证标准 $||\\nabla \\phi| - 1| \\leq \\text{tolerance}$。对于索引为 $1 \\leq i \\leq N - 2$ 的点 $i$，定义离散单边导数 $a_i = (\\phi_i - \\phi_{i-1}) / \\Delta x$ 和 $b_i = (\\phi_{i+1} - \\phi_i) / \\Delta x$。排除满足 $a_i b_i \\leq 0$ 的点，并在剩余的内部点上使用中心差分计算被检查的梯度大小。\n\n测试套件：\n提供以下测试用例集，每个用例由 $(L, N, \\text{anchors}, \\text{tolerance})$ 指定，其中 $L$ 的单位是微米， $N$ 是一个整数，anchors 是 $(x_k, \\phi_k)$ 对的列表（$x_k$ 的单位是微米，$\\phi_k$ 无量纲），tolerance 是一个无量纲的浮点数：\n\n- 案例 A（具有多个界面的正常路径）：$L = 2.0\\,\\mu\\mathrm{m}$, $N = 401$, 锚点 $[(0.0, 0.8), (0.8, 0.0), (1.0, -0.1), (1.3, 0.05), (2.0, 0.4)]$, 容差 $0.05$。\n- 案例 B（靠近边界的界面，粗糙网格）：$L = 2.0\\,\\mu\\mathrm{m}$, $N = 21$, 锚点 $[(0.0, 0.2), (0.2, 0.0), (2.0, 0.9)]$, 容差 $0.2$。\n- 案例 C（界面恰好在网格节点上）：$L = 1.0\\,\\mu\\mathrm{m}$, $N = 101$, 锚点 $[(0.0, 0.5), (0.5, 0.0), (1.0, 0.5)]$, 容差 $0.05$。\n- 案例 D（两个相近的界面）：$L = 1.0\\,\\mu\\mathrm{m}$, $N = 201$, 锚点 $[(0.0, 0.5), (0.5, 0.0), (0.55, 0.0), (1.0, 0.2)]$, 容差 $0.1$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_A, r_B, r_C, r_D]$），其中每个 $r_\\cdot$ 是一个布尔值，指示相应测试用例是否通过了 $||\\nabla \\phi| - 1| \\leq \\text{tolerance}$ 的检查。",
            "solution": "我们从一维空间中到集合 $\\Gamma$ 的符号距离的定义开始：对于一个点 $x$，无符号距离是 $T(x) = \\inf_{y \\in \\Gamma} |x - y|$，符号距离是 $\\phi(x) = \\sigma(x) T(x)$，其中 $\\sigma(x)$ 是初始函数 $\\phi_0(x)$ 的符号，该函数的零水平集定义了 $\\Gamma$。在一维空间中，在 $T$ 不可微的点之外，程函方程 $|\\partial T / \\partial x| = 1$ 成立。这是一个 Hamilton-Jacobi 方程，其哈密顿量为 $H(p) = |p| - 1$，其特征线是直线，这些直线的单调性为快速扫描方法提供了理论依据：信息沿网格以单位速度传播，使用上风值的定向更新在有限次扫描中收敛。\n\n我们必须计算在均匀网格上到给定连续分段线性函数 $\\phi_0(x)$ 的零点集的符号距离 $\\phi(x)$。该函数通过 $x_k$ 严格递增的锚点 $(x_k, \\phi_k)$ 来表达，且 $\\phi_0$ 由锚点间的线性插值定义。$\\phi_0(x)$ 的零点提供了界面 $\\Gamma$。在数值上，我们通过检查 $\\phi_0$ 在网格节点 $x_i$ 上的值来检测过零点。如果 $\\phi_0(x_i) = 0$，则该网格节点位于界面上。如果 $\\phi_0(x_i)$ 和 $\\phi_0(x_{i+1})$ 符号相反，则在单元 $(x_i, x_{i+1})$ 中存在一个唯一的零点；由于 $\\phi_0$ 在该单元内是线性的，零点位置可以通过插值获得：令 $\\phi_i = \\phi_0(x_i)$ 和 $\\phi_{i+1} = \\phi_0(x_{i+1})$，则零点位于\n$$\nx^\\star = x_i + \\frac{\\phi_i}{\\phi_i - \\phi_{i+1}} (x_{i+1} - x_i).\n$$\n为了将子单元信息并入程函方程的数值边界数据中，我们在与零点相邻的网格节点上初始化无符号距离 $T$：如果 $x^\\star$ 位于 $x_i$ 和 $x_{i+1}$ 之间，我们设置\n$$\nT(x_i) \\gets \\min\\left( T(x_i), |x_i - x^\\star| \\right), \\quad T(x_{i+1}) \\gets \\min\\left( T(x_{i+1}), |x_{i+1} - x^\\star| \\right).\n$$\n如果 $x^\\star = x_i$ 恰好是一个网格节点，我们设置 $T(x_i) = 0$。所有其他节点都初始化为一个很大的值，以表示未知的距离。这种子单元初始化是一种标准的稳定化方法，可确保离散边界信息能以子网格分辨率表示界面几何形状。\n\n一维快速扫描方法随后通过定向扫描来更新 $T$，这些扫描强制执行 $|\\partial T / \\partial x| = 1$ 的因果上风性质。在一维中，遵循单调性的离散更新是：\n- 从左到右扫描：对于 $i = 1, 2, \\dots, N - 1$，更新 $T_i \\gets \\min(T_i, T_{i-1} + \\Delta x)$。\n- 从右到左扫描：对于 $i = N - 2, N - 3, \\dots, 0$，更新 $T_i \\gets \\min(T_i, T_{i+1} + \\Delta x)$。\n\n因为一维中的特征线是单调的，所以交替进行这两次扫描会在有限次迭代内收敛到具有给定边界数据的程函方程的粘性解。该算法是稳定的、一致的，并且相对于网格间距 $\\Delta x$ 具有一阶精度。\n\n一旦计算出无符号距离 $T$，我们通过赋予 $\\phi_0$ 的符号来恢复符号距离 $\\phi$：\n$$\n\\phi_i = \\begin{cases}\nT_i  \\text{if } \\phi_0(x_i) > 0, \\\\\n- T_i  \\text{if } \\phi_0(x_i)  0, \\\\\n0  \\text{if } \\phi_0(x_i) = 0.\n\\end{cases}\n$$\n这保留了由 $\\phi_0$ 定义的拓扑结构，同时使梯度的大小与程函方程保持一致。\n\n为了在容差范围内验证网格上的 $|\\nabla \\phi| = 1$，我们在避开扭结的内部点计算离散梯度的大小。对于每个满足 $1 \\leq i \\leq N - 2$ 的内部索引 $i$，定义单边离散导数：\n$$\na_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}, \\qquad b_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}.\n$$\n如果 $a_i b_i \\leq 0$，离散导数在 $x_i$ 两侧变号，表明存在一个扭结或不可微点（例如与多个界面点等距的位置），因此我们从检查中排除索引 $i$。否则，我们计算中心差分的大小\n$$\ng_i = \\left| \\frac{\\phi_{i+1} - \\phi_{i-1}}{2 \\Delta x} \\right|,\n$$\n并评估偏差 $|g_i - 1|$。我们报告在所有被检查索引上的最大偏差，并评估其是否小于或等于指定的容差。\n\n对于提供的测试套件：\n- 案例 A 使用 $L = 2.0\\,\\mu\\mathrm{m}$, $N = 401$, 和锚点 $[(0.0, 0.8), (0.8, 0.0), (1.0, -0.1), (1.3, 0.05), (2.0, 0.4)]$，容差为 $0.05$。这有多个界面，具有连续性和混合斜率，验证了该方法处理多个过零点的能力。\n- 案例 B 使用 $L = 2.0\\,\\mu\\mathrm{m}$, $N = 21$, 和锚点 $[(0.0, 0.2), (0.2, 0.0), (2.0, 0.9)]$，容差为 $0.2$，重点测试了粗糙分辨率和邻近边界的界面处理。\n- 案例 C 使用 $L = 1.0\\,\\mu\\mathrm{m}$, $N = 101$, 和锚点 $[(0.0, 0.5), (0.5, 0.0), (1.0, 0.5)]$，容差为 $0.05$，测试了界面与网格节点精确对齐的情况。\n- 案例 D 使用 $L = 1.0\\,\\mu\\mathrm{m}$, $N = 201$, 和锚点 $[(0.0, 0.5), (0.5, 0.0), (0.55, 0.0), (1.0, 0.2)]$，容差为 $0.1$，测试了两个间距很近的界面，它们会形成一个可能具有强离散曲率效应的狭窄区域。\n\n该算法为每个案例计算符号距离，在所有非扭结的内部点上评估梯度大小与 1 的最大偏差，并为每个案例生成一个布尔结果，指示偏差是否在容差范围内。最终输出是按顺序列出这些布尔值的单行文本，并用方括号括起来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_phi0_from_anchors(x, anchors):\n    \"\"\"\n    Build a continuous piecewise-linear function phi0(x) by linear interpolation\n    between anchor points (x_k, phi_k), with anchors covering [x_min, x_max].\n    \"\"\"\n    x_anchors = np.array([a[0] for a in anchors], dtype=float)\n    phi_anchors = np.array([a[1] for a in anchors], dtype=float)\n    # Ensure strictly increasing anchors for interpolation\n    assert np.all(np.diff(x_anchors)  0), \"Anchors must have strictly increasing x.\"\n    # Interpolate\n    phi0 = np.interp(x, x_anchors, phi_anchors)\n    return phi0\n\ndef locate_zero_crossings(x, phi0):\n    \"\"\"\n    Identify zero crossings: grid nodes where phi0 == 0 and sub-cell zeros in cells where\n    phi0 changes sign between adjacent nodes. Return:\n      - zero_nodes: indices i where phi0[i] == 0\n      - subcell_zeros: list of tuples (i, i+1, x_zero) for crossings between i and i+1\n    \"\"\"\n    zero_nodes = np.where(phi0 == 0.0)[0].tolist()\n\n    sgn = np.sign(phi0)\n    # Identify strict sign changes between adjacent nodes (exclude cases where either is zero)\n    sign_change_idx = np.where((sgn[:-1] * sgn[1:]  0))[0]\n\n    subcell_zeros = []\n    for i in sign_change_idx:\n        # Linear interpolation to find exact zero location in the cell (i, i+1)\n        phi_i = phi0[i]\n        phi_ip1 = phi0[i+1]\n        # t in [0,1] position from x[i] to x[i+1]\n        t = phi_i / (phi_i - phi_ip1)\n        x_zero = x[i] + t * (x[i+1] - x[i])\n        subcell_zeros.append((i, i+1, x_zero))\n    return zero_nodes, subcell_zeros\n\ndef fast_sweeping_1d_unsigned_distance(x, zero_nodes, subcell_zeros):\n    \"\"\"\n    Compute unsigned distance T on grid x using 1D fast sweeping with sub-cell initialization.\n    Returns T array.\n    \"\"\"\n    N = x.size\n    dx = x[1] - x[0]\n    T = np.full(N, np.inf, dtype=float)\n\n    # Initialize boundary data:\n    # - Exact zeros at grid nodes\n    for i in zero_nodes:\n        T[i] = 0.0\n    # - Sub-cell zeros: set distances at adjacent nodes to distance from the zero\n    for (i, j, x_zero) in subcell_zeros:\n        di = abs(x[i] - x_zero)\n        dj = abs(x[j] - x_zero)\n        if di  T[i]:\n            T[i] = di\n        if dj  T[j]:\n            T[j] = dj\n\n    # Fast sweeping: alternate left-to-right and right-to-left passes until convergence\n    # In 1D, convergence is achieved quickly; still, use a loop with a cap to be safe.\n    max_iter = 10  # 1D with two directions should converge in = 2 passes, but allow more\n    for _ in range(max_iter):\n        changed = False\n        # Left-to-right sweep\n        for i in range(1, N):\n            cand = T[i-1] + dx\n            if cand  T[i]:\n                T[i] = cand\n                changed = True\n        # Right-to-left sweep\n        for i in range(N-2, -1, -1):\n            cand = T[i+1] + dx\n            if cand  T[i]:\n                T[i] = cand\n                changed = True\n        if not changed:\n            break\n    return T\n\ndef signed_distance_from_T(T, phi0):\n    \"\"\"\n    Assign sign of phi0 to unsigned distance T to obtain signed distance phi.\n    \"\"\"\n    phi = np.zeros_like(T)\n    pos = phi0  0.0\n    neg = phi0  0.0\n    phi[pos] = T[pos]\n    phi[neg] = -T[neg]\n    # where phi0 == 0, keep phi == 0\n    return phi\n\ndef max_gradient_deviation(phi, dx, exclude_zero=True):\n    \"\"\"\n    Compute the maximum deviation of discrete gradient magnitude from 1\n    at interior points, excluding kinks (where sign of one-sided derivatives changes).\n    If exclude_zero is True, also exclude points where phi == 0.\n    \"\"\"\n    N = phi.size\n    if N  3:\n        return 0.0  # Not enough points to form interior derivatives\n    # One-sided derivatives\n    a = (phi[1:N-1] - phi[0:N-2]) / dx\n    b = (phi[2:N] - phi[1:N-1]) / dx\n    # Kink mask: exclude where a*b = 0 (derivative changes sign)\n    mask = (a * b)  0.0\n    # Exclude points where phi == 0, if requested\n    if exclude_zero:\n        mask = (phi[1:N-1] != 0.0)\n    # Centered gradient magnitude\n    g = np.abs((phi[2:N] - phi[0:N-2]) / (2.0 * dx))\n    if not np.any(mask):\n        # If no points to check (e.g., all kinks), define deviation as 0.0\n        return 0.0\n    deviations = np.abs(g[mask] - 1.0)\n    return float(np.max(deviations))\n\ndef run_case(L, N, anchors, tolerance):\n    \"\"\"\n    Run a single test case:\n    - Build grid\n    - Build phi0 from anchors\n    - Locate zero crossings\n    - Fast sweeping to compute unsigned distance\n    - Construct signed distance\n    - Verify |grad phi| ~ 1 within tolerance at interior non-kink points\n    Return boolean pass/fail.\n    \"\"\"\n    # Grid\n    x = np.linspace(0.0, L, N, dtype=float)\n    dx = x[1] - x[0]\n\n    # phi0 piecewise-linear\n    phi0 = build_phi0_from_anchors(x, anchors)\n\n    # Find zeros\n    zero_nodes, subcell_zeros = locate_zero_crossings(x, phi0)\n\n    # Solve unsigned distance by fast sweeping\n    T = fast_sweeping_1d_unsigned_distance(x, zero_nodes, subcell_zeros)\n\n    # Signed distance\n    phi = signed_distance_from_T(T, phi0)\n\n    # Gradient deviation\n    max_dev = max_gradient_deviation(phi, dx, exclude_zero=True)\n\n    # Check against tolerance\n    return max_dev = tolerance\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: L, N, anchors, tolerance\n        (2.0, 401, [(0.0, 0.8), (0.8, 0.0), (1.0, -0.1), (1.3, 0.05), (2.0, 0.4)], 0.05),\n        # Case B: boundary-near interface, coarse grid\n        (2.0, 21, [(0.0, 0.2), (0.2, 0.0), (2.0, 0.9)], 0.2),\n        # Case C: interface exactly on a grid node\n        (1.0, 101, [(0.0, 0.5), (0.5, 0.0), (1.0, 0.5)], 0.05),\n        # Case D: two close interfaces\n        (1.0, 201, [(0.0, 0.5), (0.5, 0.0), (0.55, 0.0), (1.0, 0.2)], 0.1),\n    ]\n\n    results = []\n    for L, N, anchors, tol in test_cases:\n        result = run_case(L, N, anchors, tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "掌握了基本实现后，我们需要思考更复杂的情况：当数值方案遭遇特定几何构型时会发生什么？本练习将引导您从“如何做”转向“怎么办”，探讨当界面与计算网格对齐时，标准数值格式可能产生的伪影。这项挑战  要求您诊断一个典型问题——界面钉扎（interface pinning），并评估一种先进的解决方案——子网格分辨率法（subcell resolution），从而培养您对该方法局限性及高级应用的批判性思维。",
            "id": "4138524",
            "problem": "在半导体制造的特征尺度形貌模拟中，演化中的材料-真空界面由一个标量场 $\\phi(\\mathbf{x},t)$ 的零水平集表示，该标量场满足哈密顿-雅可比平流方程\n$$\n\\frac{\\partial \\phi}{\\partial t} + V_n(\\mathbf{x},t)\\,\\lvert \\nabla \\phi \\rvert = 0,\n$$\n其中 $V_n(\\mathbf{x},t)$ 是给定的法向速度。考虑一个二维笛卡尔网格，其间距为 $\\Delta x = \\Delta y$，以及一个静止的、完全刚性的光刻胶掩模，其直边与直线 $x=0$ 重合。该模型对 $\\lvert \\nabla \\phi \\rvert$ 的哈密顿量使用一阶 Godunov 离散化，并采用标准的窄带重新初始化来维持符号距离性质。假设初始界面与掩模边缘重合，并且工艺在开放区域 $x0$ 上施加均匀的沉积速度 $V_n(\\mathbf{x},t) = v_0$，而在 $x \\le 0$（掩模内部或下方）区域 $V_n(\\mathbf{x},t) = 0$。在实践中，速度场通过沿法线求解一个扩展方程来延伸到界面之外，但掩模对于材料界面来说是一个不可穿透的边界。\n\n分析零水平集在网格线 $x=0$ 附近节点处的离散演化。重点关注当对 $\\lvert \\nabla \\phi \\rvert$ 使用一阶 Godunov 近似时，掩模边缘与笛卡尔网格之间的网格对齐效应。当零水平集与网格对齐的掩模边缘对齐时，哪个选项能最好地指出产生的主要数值伪影，并提供一种数学上合理的子单元分辨率策略，该策略能在不改变物理模型或远离界面的体模板的情况下消除该伪影？\n\n选择一个选项。\n\nA. 主要伪影是由于零点横跨网格面时迎风 Godunov 通量的退化，导致前沿在掩模边缘发生网格诱导的钉扎，表现为沿 $x=0$ 的伪各向异性和阶梯效应。一种一致的子单元分辨率修正方法是通过线性插值重构切割单元内的界面位置，并在方向导数中用子单元到界面的距离替换完整的网格间距。具体来说，如果 $\\phi_{i,j}\\,\\phi_{i+1,j}0$，定义面交叉分数\n$$\n\\theta_{i+\\frac{1}{2},j} = \\frac{\\lvert \\phi_{i,j} \\rvert}{\\lvert \\phi_{i,j} \\rvert + \\lvert \\phi_{i+1,j} \\rvert},\n$$\n因此从 $(i,j)$ 沿 $+x$ 方向到界面的距离是 $d_{x}^{+} = (1-\\theta_{i+\\frac{1}{2},j})\\,\\Delta x$。然后使用修正后的单边导数\n$$\n\\left(D_x^{+}\\phi\\right)_{\\text{subcell}} = \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{d_{x}^{+}}\n$$\n（当符号发生变化时，对 $D_x^{-}\\phi$, $D_y^{\\pm}\\phi$ 进行类似处理），并使用 Godunov 选择来构造 $\\lvert \\nabla \\phi \\rvert$，但仅在被界面切割的单元中使用这些子单元导数。这恢复了各向同性并防止了钉扎，因为修正后的导数在包含零水平集的单元中恢复了符号距离梯度 $\\lvert \\nabla \\phi \\rvert \\approx 1$。\n\nB. 主要伪影是由高阶多项式插值引起的掩模边缘附近的吉布斯振荡，这导致 $\\phi$ 在 $x=0$ 处出现上冲和下冲。一个合适的修正是对水平集场应用全变差递减 (TVD) 限制器，并在边缘附近将空间离散化降至一阶，从而在不修改梯度计算的情况下抑制振荡。\n\nC. 主要问题是在直掩模边缘处的曲率爆破，因为 $\\kappa = \\nabla \\cdot \\left(\\nabla \\phi / \\lvert \\nabla \\phi \\rvert \\right)$ 在与网格对齐的直线上是奇异的，导致无限大的法向速度 $V_n = \\gamma \\kappa$。一种稳定的修正是将 $\\kappa$ 替换为拉普拉斯算子 $\\Delta \\phi$，并在演化方程中添加一个扩散项 $\\nu \\Delta \\phi$，从而对曲率进行正则化并消除奇异性。\n\nD. 伪影是由于窄带重新初始化裁剪符号距离场而导致的全局质量损失，每当界面接近掩模边缘时，这种损失就会累积。修正是加宽窄带并减小重新初始化的伪时间步，确保符号距离性质在离界面更远的地方得以保持，并最小化质量守恒误差，而不改变切割单元处的梯度计算或通量。",
            "solution": "用户请求对问题陈述进行严格验证，然后提供详细的解决方案并评估所给选项。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n*   **控制方程：** 水平集函数 $\\phi(\\mathbf{x},t)$ 根据哈密顿-雅可比平流方程演化：$\\frac{\\partial \\phi}{\\partial t} + V_n(\\mathbf{x},t)\\,\\lvert \\nabla \\phi \\rvert = 0$。\n*   **物理设置：** 一个模拟掩模旁材料沉积的二维问题。\n*   **域和速度：** 当 $x0$ 时，速度为 $V_n(\\mathbf{x},t) = v_0$；当 $x \\le 0$ 时，速度为 $V_n(\\mathbf{x},t) = 0$。掩模边缘是直线 $x=0$。\n*   **初始条件：** 初始界面（$\\phi$ 的零水平集）与掩模边缘 $x=0$ 重合。一个一致的 $\\phi$ 初始条件是 $\\phi(\\mathbf{x},0) = x$，使其成为一个符号距离函数。\n*   **数值方法：** 模拟使用间距为 $\\Delta x = \\Delta y$ 的二维笛卡尔网格。$\\lvert \\nabla \\phi \\rvert$ 项使用一阶 Godunov 格式进行离散化。使用窄带重新初始化来保持 $\\phi$ 的符号距离性质。\n*   **约束条件：** $x=0$ 处的掩模对于材料界面是一个不可穿透的边界。\n*   **问题：** 识别由于界面和掩模的网格对齐而产生的主要数值伪影，并确定一种数学上合理的子单元分辨率策略来修正它。\n\n**第2步：使用提取的已知条件进行验证**\n\n*   **科学基础扎实：** 该问题牢固地建立在公认的原理之上。由哈密顿-雅可比方程控制的水平集方法是跟踪计算物理和工程中移动界面的标准而强大的技术，尤其是在半导体工艺模拟（如蚀刻和沉积）中。使用 Godunov 格式是数值求解此类双曲方程的标准选择。所描述的设置是测试界面跟踪算法准确性的经典基准。该问题在科学和数学上都是合理的。\n*   **适定性：** 在静止壁旁边进行均匀沉积的潜在物理问题是适定的。问题要求识别应用于此问题的特定离散化格式的一个已知数值伪影，这是数值分析中的一个标准课题。\n*   **客观性：** 问题以精确、客观的技术语言陈述。没有主观或模糊的术语。\n*   **缺陷清单：**\n    1.  **科学/事实不合理：** 无。模型和方法都是标准的。\n    2.  **非形式化/不相关：** 无。问题是具体的，并与主题直接相关。\n    3.  **不完整/矛盾的设置：** 无。设置是自洽的，足以分析数值行为。\n    4.  **不切实际/不可行：** 无。网格对齐的特征是模拟中常见的现象，也是一个关键的测试案例。\n    5.  **不适定/结构不良：** 无。问题清晰且有针对性。\n    6.  **伪深刻/琐碎：** 无。一阶格式中的网格诱导各向异性问题是计算方法中一个非琐碎且重要的问题。\n    7.  **超出科学可验证性：** 无。所描述的行为可以通过一个简单的数值实现轻松复现。\n\n**第3步：结论和行动**\n\n问题陈述有效。我将继续推导解决方案并评估选项。\n\n### 解题推导\n\n问题描述了由 $\\phi_t + V_n |\\nabla\\phi| = 0$ 控制的界面演化。速度 $V_n$ 是一个阶跃函数：当 $x0$ 时 $V_n = v_0$，当 $x \\le 0$ 时 $V_n=0$。初始界面是直线 $x=0$。在离散设置中，网格节点 $(i,j)$ 位于位置 $(i\\Delta x, j\\Delta y)$。$V_n$ 的条件应用于这些节点。因此，对于索引 $i \\le 0$ 的任何节点，速度为 $V_n=0$。\n\n节点 $(i,j)$ 处 $\\phi$ 的更新方程为 $\\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t (V_n)_{i,j} |\\nabla\\phi|_{i,j}$。\n最初，界面位于 $x=0$，因此 $\\phi(x,y,0)=x$。在网格上，这意味着 $\\phi_{i,j}^0 = i\\Delta x$。\n考虑掩模边缘上的一个节点 $(0,j)$。这里，$i=0$，因此 $(V_n)_{0,j} = 0$。更新方程变为：\n$$ \\phi_{0,j}^{n+1} = \\phi_{0,j}^n - \\Delta t \\cdot 0 \\cdot |\\nabla\\phi|_{0,j} = \\phi_{0,j}^n $$\n由于 $\\phi_{0,j}^0 = 0 \\cdot \\Delta x = 0$，值 $\\phi_{0,j}$ 将永远保持为 $0$。这迫使零水平集永久通过位于直线 $x=0$ 上的网格节点。这种现象被称为**界面钉扎**或**锁定**。\n\n物理上，各向同性沉积应该导致前沿演化成以掩模任何“角点”为中心的四分之一圆。然而，由于界面被钉扎在 $x=0$ 的网格节点上，它只能在节点之间的区域向前移动。以其数值扩散闻名的一阶格式倾向于模糊特征。综合效应是前沿主要沿 $x$ 方向推进，保持一个尖锐的、与网格对齐的角，而不是一个圆角。这种沿网格轴的优先移动是一个经典的数值伪影，称为**伪各向异性**或**阶梯效应**。\n\n根本原因是，一阶离散格式无法解析边界处的子网格单元行为。速度被分配给节点，而掩模边缘节点上的硬性零速度冻结了那里的界面。一个有效的修正必须将子单元信息引入计算中，以允许界面从网格线上“解钉”并更各向同性地演化。\n\n### 逐项分析选项\n\n**A. 主要伪影是由于零点横跨网格面时迎风 Godunov 通量的退化，导致前沿在掩模边缘发生网格诱导的钉扎，表现为沿 $x=0$ 的伪各向异性和阶梯效应。一种一致的子单元分辨率修正方法是通过线性插值重构切割单元内的界面位置，并在方向导数中用子单元到界面的距离替换完整的网格间距。具体来说，如果 $\\phi_{i,j}\\,\\phi_{i+1,j}0$，定义面交叉分数\n$$\n\\theta_{i+\\frac{1}{2},j} = \\frac{\\lvert \\phi_{i,j} \\rvert}{\\lvert \\phi_{i,j} \\rvert + \\lvert \\phi_{i+1,j} \\rvert},\n$$\n因此从 $(i,j)$ 沿 $+x$ 方向到界面的距离是 $d_{x}^{+} = (1-\\theta_{i+\\frac{1}{2},j})\\,\\Delta x$。然后使用修正后的单边导数\n$$\n\\left(D_x^{+}\\phi\\right)_{\\text{subcell}} = \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{d_{x}^{+}}\n$$\n（当符号发生变化时，对 $D_x^{-}\\phi$, $D_y^{\\pm}\\phi$ 进行类似处理），并使用 Godunov 选择来构造 $\\lvert \\nabla \\phi \\rvert$，但仅在被界面切割的单元中使用这些子单元导数。这恢复了各向同性并防止了钉扎，因为修正后的导数在包含零水平集的单元中恢复了符号距离梯度 $\\lvert \\nabla \\phi \\rvert \\approx 1$。**\n\n此选项正确地将主要伪影识别为导致“伪各向异性”和“阶梯效应”的“网格诱导钉扎”。这与我们的分析完全一致。它还正确地识别了解决方案的类别：一种涉及在“切割单元”（包含界面的单元）内重构界面位置的“子单元分辨率修正”。使用子单元距离来校正导数的通用策略是解决此问题的标准方法。\n\n让我们仔细检查所提供的公式。$\\theta_{i+\\frac{1}{2},j}$ 的定义是标准线性插值下从节点 $(i,j)$ 到连接 $(i,j)$ 和 $(i+1,j)$ 的线段上的界面的分数距离。从 $(i,j)$ 到界面的距离是 $\\theta \\Delta x$，从界面到 $(i+1,j)$ 的距离是 $(1-\\theta)\\Delta x$。该选项将 $d_{x}^{+}$ 定义为 $(1-\\theta)\\Delta x$，但含糊地称其为“从 $(i,j)$ 沿 $+x$ 方向到界面的距离”。这不精确；$d_x^+$ 是从界面到点 $(i+1,j)$ 的距离。所提出的导数 $\\left(D_x^{+}\\phi\\right)_{\\text{subcell}} = (\\phi_{i+1,j} - \\phi_{i,j}) / d_{x}^{+}$ 也有问题。人们期望子单元导数会涉及界面处的值（为0），例如将 $\\phi_x$ 近似为 $\\phi_{i+1,j} / d_{x}^{+}$。所写的公式不能稳健地恢复 $|\\nabla\\phi|=1$。\n\n尽管具体公式中存在这些明显的不精确之处，但对伪影的描述是完美的，对解决方法（对切割单元进行子单元解析以校正导数）的描述在概念上是正确的，并且是标准方法。与其他根本上错误的选项相比，此选项提供了对问题和正确解决方案类别的最佳描述。缺陷似乎在于示例性实现细节，而非核心概念。\n\n结论：**正确**\n\n**B. 主要伪影是由高阶多项式插值引起的掩模边缘附近的吉布斯振荡，这导致 $\\phi$ 在 $x=0$ 处出现上冲和下冲。一个合适的修正是对水平集场应用全变差递减 (TVD) 限制器，并在边缘附近将空间离散化降至一阶，从而在不修改梯度计算的情况下抑制振荡。**\n\n此选项不正确。问题明确指出使用的是*一阶*Godunov离散化。一阶格式是单调的，不会产生吉布斯振荡。吉布斯振荡是高阶*线性*格式应用于不连续性或陡峭梯度时的标志。这里的问题是由一阶格式固有的*过度数值扩散*引起的，这导致了模糊和几何误差（各向异性），而不是振荡。提议降至一阶作为修正没有意义，因为该格式已经是第一阶的。\n\n结论：**不正确**\n\n**C. 主要问题是在直掩模边缘处的曲率爆破，因为 $\\kappa = \\nabla \\cdot \\left(\\nabla \\phi / \\lvert \\nabla \\phi \\rvert \\right)$ 在与网格对齐的直线上是奇异的，导致无限大的法向速度 $V_n = \\gamma \\kappa$。一种稳定的修正是将 $\\kappa$ 替换为拉普拉斯算子 $\\Delta \\phi$，并在演化方程中添加一个扩散项 $\\nu \\Delta \\phi$，从而对曲率进行正则化并消除奇异性。**\n\n此选项根本上不正确，因为它错误地识别了物理模型。问题指出速度是一个给定的函数，$V_n(\\mathbf{x},t) = v_0$（对于 $x0$），这对应于一个恒速平流问题。它不是一个曲率驱动流问题，其中 $V_n$ 会与曲率 $\\kappa$ 成正比。初始界面是一条直线，其 $\\kappa=0$，因此没有初始奇异性。所提议的修正，即添加一个扩散项，改变了控制偏微分方程，这是提示明确禁止的（“不改变物理模型”）。\n\n结论：**不正确**\n\n**D. 伪影是由于窄带重新初始化裁剪符号距离场而导致的全局质量损失，每当界面接近掩模边缘时，这种损失就会累积。修正是加宽窄带并减小重新初始化的伪时间步，确保符号距离性质在离界面更远的地方得以保持，并最小化质量守恒误差，而不改变切割单元处的梯度计算或通量。**\n\n此选项不正确，因为它错误地识别了*主要*伪影。虽然重新初始化确实会引入误差，这些误差可能表现为零水平集的缓慢漂移（通常导致随时间变化的“质量”或体积变化），但这在所有水平集模拟中是一个普遍且通常很小的误差源。在具有一阶格式的网格对齐特征的特定场景中，主要的、最明显的伪影是几何误差——钉扎和伪各向异性——这是由空间离散化格式在边界处的失败引起的。重新初始化误差是次要效应，在这种情况下比几何误差小几个数量级。所提议的修正解决了重新初始化问题，但完全忽略了空间离散化的主要问题。\n\n结论：**不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}