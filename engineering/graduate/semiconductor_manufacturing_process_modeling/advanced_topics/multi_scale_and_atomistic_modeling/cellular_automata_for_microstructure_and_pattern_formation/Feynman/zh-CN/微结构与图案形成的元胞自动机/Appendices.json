{
    "hands_on_practices": [
        {
            "introduction": "任何基于网格的模拟都必须面对一个基本问题：离散化本身是否会引入影响结果的人工效应。本练习通过解析推导，深入分析在计算曲率时，不同数值模板（如冯·诺依曼邻域与摩尔邻域）的选择如何导致非物理的各向异性，从而影响模拟微观结构的形态。这项练习  对于培养对元胞自动机及其他有限差分模型内在局限性和偏差的批判性理解至关重要，是构建可靠计算模型的第一步。",
            "id": "4113119",
            "problem": "在用于半导体制造过程建模的曲率驱动微结构演化中，一个二维界面的法向速度与其平均曲率成正比。考虑一个间距为 $a$ 的方形晶格上的元胞自动机 (CA) 离散化，其中界面由表示半径为 $R$ 的圆形夹杂物的符号距离函数 $\\phi(x,y) = \\sqrt{x^{2}+y^{2}} - R$ 隐式表示。连续法向速度定律为 $V_{n} = M \\gamma \\kappa$，其中 $M$ 是迁移率，$\\gamma$ 是各向同性的单位长度界面自由能。界面处的曲率 $\\kappa$ 可以通过二维符号距离场的拉普拉斯算子得到。\n\n通过将离散拉普拉斯算子应用于在最靠近界面的晶格点上求值的 $\\phi$ 来模拟离散曲率。定义两种邻域模板：\n- von Neumann 邻域（四邻域，五点模板）离散拉普拉斯算子，\n$$\\Delta_{\\mathrm{VN}} \\phi(i,j) \\equiv \\frac{1}{a^{2}}\\Big(\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4\\phi_{i,j}\\Big).$$\n- Moore 邻域（八邻域，九点模板）离散拉普拉斯算子，选择该算子以改善主导阶的角向各向同性，\n$$\\Delta_{\\mathrm{M}} \\phi(i,j) \\equiv \\frac{1}{6 a^{2}}\\Big(4\\big[\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1}\\big] + \\big[\\phi_{i+1,j+1} + \\phi_{i+1,j-1} + \\phi_{i-1,j+1} + \\phi_{i-1,j-1}\\big] - 20\\phi_{i,j}\\Big).$$\n\n假设 $a/R \\ll 1$，并使用界面点 $(x,y) = (R \\cos\\theta, R \\sin\\theta)$ 的局部角参数化，其中 $\\theta$ 是从 $x$ 轴测量的极角。从二维曲率的基本定义和离散拉普拉斯算子的一致泰勒展开出发，推导由晶格各向异性引入的界面法向速度偏差的主导阶角相关性。将模板 $S \\in \\{\\mathrm{VN}, \\mathrm{M}\\}$ 在角度 $\\theta$ 处的曲率相关界面速度偏差定义为\n$$B_{S}(\\theta) \\equiv V_{n,S}(\\theta) - \\langle V_{n,S} \\rangle_{\\theta},$$\n其中 $V_{n,S}(\\theta) = M \\gamma\\, \\kappa_{S}(\\theta)$ 且 $\\langle \\cdot \\rangle_{\\theta}$ 表示在 $\\theta \\in [0,2\\pi)$ 上的方位角平均。\n\n提供一个关于 $M$、$\\gamma$、$a$、$R$ 和 $\\theta$ 的单一闭式解析表达式，表示 von Neumann 和 Moore 模板之间主导阶曲率相关界面速度偏差的差异，$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta)$。不需要进行数值计算或四舍五入。将最终答案表示为符号表达式。",
            "solution": "用户想要找出 von Neumann 和 Moore 模板之间主导阶曲率相关界面速度偏差的差异，记作 $B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta)$。\n\n首先，我们确定所提供的定义。模板 $S$ 的界面速度由 $V_{n,S}(\\theta) = M \\gamma \\kappa_{S}(\\theta)$ 给出，其中 $M$ 是迁移率，$\\gamma$ 是界面自由能，$\\kappa_{S}(\\theta)$ 是在极角 $\\theta$ 处的离散曲率。离散曲率由符号距离函数的离散拉普拉斯算子近似，即 $\\kappa_{S}(\\theta) \\approx \\Delta_{S} \\phi$。\n\n模板 $S$ 的速度偏差定义为其与方位角平均值的偏差：\n$$B_{S}(\\theta) \\equiv V_{n,S}(\\theta) - \\langle V_{n,S}(\\theta) \\rangle_{\\theta}$$\n其中 $\\langle \\cdot \\rangle_{\\theta}$ 表示在 $\\theta \\in [0, 2\\pi)$ 上的平均值。\n代入 $V_{n,S}(\\theta)$ 的表达式，我们得到：\n$$B_{S}(\\theta) = M \\gamma \\left( \\kappa_{S}(\\theta) - \\langle \\kappa_{S}(\\theta) \\rangle_{\\theta} \\right)$$\n我们需要计算的量是：\n$$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta) = M \\gamma \\left[ \\left( \\kappa_{\\mathrm{VN}}(\\theta) - \\langle \\kappa_{\\mathrm{VN}}(\\theta) \\rangle_{\\theta} \\right) - \\left( \\kappa_{\\mathrm{M}}(\\theta) - \\langle \\kappa_{\\mathrm{M}}(\\theta) \\rangle_{\\theta} \\right) \\right]$$\n$$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta) = M \\gamma \\left[ (\\kappa_{\\mathrm{VN}}(\\theta) - \\kappa_{\\mathrm{M}}(\\theta)) - \\langle \\kappa_{\\mathrm{VN}}(\\theta) - \\kappa_{\\mathrm{M}}(\\theta) \\rangle_{\\theta} \\right]$$\n\n为了找到离散曲率 $\\kappa_{\\mathrm{VN}}(\\theta)$ 和 $\\kappa_{\\mathrm{M}}(\\theta)$，我们对离散拉普拉斯算子 $\\Delta_{\\mathrm{VN}}$ 和 $\\Delta_{\\mathrm{M}}$ 在界面上的一个点 $(x,y)$ 周围进行泰勒级数展开。函数 $f(x+h, y+k)$ 的泰勒展开式为\n$$f(x+h, y+k) = \\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left( h \\frac{\\partial}{\\partial x} + k \\frac{\\partial}{\\partial y} \\right)^n f(x,y)$$\n将此应用于间距为 $a$ 的晶格上的 von Neumann 模板项：\n$$\\phi(x\\pm a, y) = \\phi \\pm a \\phi_x + \\frac{a^2}{2} \\phi_{xx} \\pm \\frac{a^3}{6} \\phi_{xxx} + \\frac{a^4}{24} \\phi_{xxxx} + O(a^5)$$\n$$\\phi(x, y\\pm a) = \\phi \\pm a \\phi_y + \\frac{a^2}{2} \\phi_{yy} \\pm \\frac{a^3}{6} \\phi_{yyy} + \\frac{a^4}{24} \\phi_{yyyy} + O(a^5)$$\n对 von Neumann 模板的邻点项求和：\n$$\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} = 4\\phi + a^2(\\phi_{xx} + \\phi_{yy}) + \\frac{a^4}{12}(\\phi_{xxxx} + \\phi_{yyyy}) + O(a^6)$$\n因此，von Neumann 模板的离散拉普拉斯算子为：\n$$\\kappa_{\\mathrm{VN}} \\equiv \\Delta_{\\mathrm{VN}}\\phi = \\frac{1}{a^2} \\left[ 4\\phi + a^2 \\Delta\\phi + \\frac{a^4}{12}(\\phi_{xxxx} + \\phi_{yyyy}) - 4\\phi \\right] + O(a^4) = \\Delta\\phi + \\frac{a^2}{12}(\\phi_{xxxx} + \\phi_{yyyy}) + O(a^4)$$\n其中 $\\Delta\\phi = \\phi_{xx} + \\phi_{yy}$ 是连续拉普拉斯算子。\n\n对于 Moore 模板，我们还需要对角项，例如 $\\phi(x+a, y+a)$。对所有四个对角邻点求和，奇数阶导数项会抵消，我们发现：\n$$\\sum_{\\text{diag}} \\phi_k = 4\\phi + 2a^2 \\Delta\\phi + \\frac{a^4}{6} (\\phi_{xxxx} + 6\\phi_{xxyy} + \\phi_{yyyy}) + O(a^6)$$\nMoore 离散拉普拉斯算子是：\n$$\\kappa_{\\mathrm{M}} \\equiv \\Delta_{\\mathrm{M}}\\phi = \\frac{1}{6a^2} \\left[ 4 \\left( \\sum_{\\text{v-n}} \\phi_k \\right) + \\left( \\sum_{\\text{diag}} \\phi_k \\right) - 20\\phi \\right]$$\n其中求和是针对非中心邻点。\n$$\\kappa_{\\mathrm{M}} = \\frac{1}{6a^2} \\left[ 4\\left(4\\phi + a^2 \\Delta\\phi + \\frac{a^4}{12}(\\phi_{xxxx} + \\phi_{yyyy})\\right) + \\left(4\\phi + 2a^2 \\Delta\\phi + \\frac{a^4}{6}(\\phi_{xxxx} + 6\\phi_{xxyy} + \\phi_{yyyy})\\right) - 20\\phi \\right] + O(a^4)$$\n$$\\kappa_{\\mathrm{M}} = \\frac{1}{6a^2} \\left[ 6a^2 \\Delta\\phi + \\frac{a^4}{2}(\\phi_{xxxx} + \\phi_{yyyy}) + a^4 \\phi_{xxyy} \\right] + O(a^4)$$\n$$\\kappa_{\\mathrm{M}} = \\Delta\\phi + \\frac{a^2}{12}(\\phi_{xxxx} + 2\\phi_{xxyy} + \\phi_{yyyy}) + O(a^4) = \\Delta\\phi + \\frac{a^2}{12}\\Delta^2\\phi + O(a^4)$$\n\n离散曲率在 $a$ 的主导阶上的差异是：\n$$\\kappa_{\\mathrm{VN}} - \\kappa_{\\mathrm{M}} = \\left( \\Delta\\phi + \\frac{a^2}{12}(\\phi_{xxxx} + \\phi_{yyyy}) \\right) - \\left( \\Delta\\phi + \\frac{a^2}{12}(\\phi_{xxxx} + 2\\phi_{xxyy} + \\phi_{yyyy}) \\right) + O(a^4)$$\n$$\\kappa_{\\mathrm{VN}} - \\kappa_{\\mathrm{M}} = -\\frac{a^2}{6}\\phi_{xxyy} + O(a^4)$$\n现在，我们必须在界面上（其中 $x=R\\cos\\theta$ 且 $y=R\\sin\\theta$）为符号距离函数 $\\phi(x,y) = \\sqrt{x^2+y^2} - R$ 计算 $\\phi_{xxyy}$。令 $r = \\sqrt{x^2+y^2}$。\n所需的偏导数是：\n$\\phi_x = \\frac{x}{r}$\n$\\phi_{xx} = \\frac{y^2}{r^3}$\n$\\phi_{xxy} = \\frac{\\partial}{\\partial y} \\left( y^2 r^{-3} \\right) = 2yr^{-3} - 3y^3 r^{-5} = \\frac{2yr^2 - 3y^3}{r^5} = \\frac{2yx^2 - y^3}{r^5}$\n$\\phi_{xxyy} = \\frac{\\partial}{\\partial y} \\left( (2yx^2 - y^3)r^{-5} \\right) = (2x^2 - 3y^2)r^{-5} - 5y(2yx^2 - y^3)r^{-7}$\n$= \\frac{(2x^2-3y^2)r^2 - 10y^2x^2 + 5y^4}{r^7} = \\frac{(2x^2-3y^2)(x^2+y^2) - 10y^2x^2 + 5y^4}{r^7} = \\frac{2x^4 - 11x^2y^2 + 2y^4}{r^7}$\n在界面上，$r=R$，$x=R\\cos\\theta$，且 $y=R\\sin\\theta$：\n$$\\phi_{xxyy} = \\frac{R^4(2\\cos^4\\theta - 11\\cos^2\\theta\\sin^2\\theta + 2\\sin^4\\theta)}{R^7} = \\frac{1}{R^3}(2\\cos^4\\theta - 11\\cos^2\\theta\\sin^2\\theta + 2\\sin^4\\theta)$$\n我们使用倍角和降幂恒等式来简化该三角函数表达式：\n$$2\\cos^4\\theta - 11\\cos^2\\theta\\sin^2\\theta + 2\\sin^4\\theta = 2(\\cos^4\\theta + \\sin^4\\theta) - 11\\cos^2\\theta\\sin^2\\theta$$\n$$= 2( (1 - 2\\cos^2\\theta\\sin^2\\theta) ) - 11\\cos^2\\theta\\sin^2\\theta = 2 - 15\\cos^2\\theta\\sin^2\\theta$$\n$$= 2 - 15 \\left( \\frac{\\sin(2\\theta)}{2} \\right)^2 = 2 - \\frac{15}{4}\\sin^2(2\\theta) = 2 - \\frac{15}{4} \\left( \\frac{1-\\cos(4\\theta)}{2} \\right)$$\n$$= 2 - \\frac{15}{8} + \\frac{15}{8}\\cos(4\\theta) = \\frac{1}{8} + \\frac{15}{8}\\cos(4\\theta) = \\frac{1}{8}(1 + 15\\cos(4\\theta))$$\n因此，界面上的四阶导数是：\n$$\\phi_{xxyy}(\\theta) = \\frac{1}{8R^3}(1 + 15\\cos(4\\theta))$$\n将此代入曲率差异的表达式中：\n$$\\kappa_{\\mathrm{VN}}(\\theta) - \\kappa_{\\mathrm{M}}(\\theta) = -\\frac{a^2}{6} \\left[ \\frac{1}{8R^3}(1 + 15\\cos(4\\theta)) \\right] = -\\frac{a^2}{48R^3}(1 + 15\\cos(4\\theta))$$\n接下来，我们计算此差异的方位角平均值。$\\cos(4\\theta)$ 在 $[0, 2\\pi)$ 上的积分为 $0$。\n$$\\langle \\kappa_{\\mathrm{VN}} - \\kappa_{\\mathrm{M}} \\rangle_{\\theta} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} -\\frac{a^2}{48R^3}(1 + 15\\cos(4\\theta)) \\,d\\theta = -\\frac{a^2}{48R^3}$$\n最后，我们将这些结果代回到偏差差异的表达式中：\n$$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta) = M \\gamma \\left[ (\\kappa_{\\mathrm{VN}}(\\theta) - \\kappa_{\\mathrm{M}}(\\theta)) - \\langle \\kappa_{\\mathrm{VN}}(\\theta) - \\kappa_{\\mathrm{M}}(\\theta) \\rangle_{\\theta} \\right]$$\n$$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta) = M \\gamma \\left[ \\left(-\\frac{a^2}{48R^3}(1 + 15\\cos(4\\theta))\\right) - \\left(-\\frac{a^2}{48R^3}\\right) \\right]$$\n$$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta) = M \\gamma \\left[ -\\frac{a^2}{48R^3} - \\frac{15a^2}{48R^3}\\cos(4\\theta) + \\frac{a^2}{48R^3} \\right]$$\n$$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta) = -M \\gamma \\frac{15a^2}{48R^3}\\cos(4\\theta)$$\n化简分数 $\\frac{15}{48} = \\frac{5}{16}$，我们得到最终表达式。\n$$B_{\\mathrm{VN}}(\\theta) - B_{\\mathrm{M}}(\\theta) = -M \\gamma \\frac{5a^2}{16R^3}\\cos(4\\theta)$$\n此结果表明，在主导阶 $O(a^2)$ 上，Moore 模板不引入角偏差（$B_{\\mathrm{M}}(\\theta)=0$），整个差异是由于 von Neumann 模板的四重对称偏差造成的。",
            "answer": "$$\\boxed{- \\frac{5 M \\gamma a^{2}}{16 R^{3}} \\cos(4\\theta)}$$"
        },
        {
            "introduction": "在理解了网格离散化的基础之上，我们转向探索系统在这些网格上的动态演化行为。本实践采用一个确定性的类伊辛模型，来研究元胞自动机状态空间中的稳定性和吸引域等核心概念 。通过编程识别系统的固定点构型，并量化其在微小扰动下的稳定性与吸引盆大小，你将亲身体验局部相互作用规则如何涌现出宏观且持久的微观结构。",
            "id": "4113048",
            "problem": "您将实现一个确定性的二维二元细胞自动机，以在与半导体制造过程建模相关的简化设置中模拟微结构演化。该自动机定义在一个周期性方格晶格上，并使用一个源于最小化局部相互作用能的更新规则，该能量函数倾向于与最近邻和均匀偏置场对齐。您将分析指定固定微结构构型在局部规则扰动下的稳定性，并根据汉明距离邻域来表征吸引盆。\n\n基本原理和定义：\n- 设晶格为 $\\Omega = \\{0,1,\\dots,N-1\\} \\times \\{0,1,\\dots,N-1\\}$，具有周期性边界条件。每个格点 $(i,j) \\in \\Omega$ 都有一个自旋 $s_{i,j} \\in \\{-1,+1\\}$，代表两种微结构相。\n- 邻域是八邻域集合 $\\mathcal{N}_{8}(i,j)$，由偏移量 $(\\Delta i,\\Delta j) \\in \\{(-1,0),(+1,0),(0,-1),(0,+1),(-1,-1),(-1,+1),(+1,-1),(+1,+1)\\}$ 处的格点组成，并采用周期性环绕方式解释。\n- 在格点 $(i,j)$ 处的局部场为\n$$\nF_{i,j} = J \\sum_{(p,q)\\in\\mathcal{N}_{8}(i,j)} s_{p,q} + h,\n$$\n其中 $J \\in \\mathbb{R}$ 是最近邻耦合强度，$h \\in \\mathbb{R}$ 是一个均匀偏置场，代表外部驱动偏好。\n- 时间 $t \\mapsto t+1$ 的确定性同步更新规则为\n$$\ns_{i,j}^{t+1} =\n\\begin{cases}\ns_{i,j}^{t},  &\\text{若 } F_{i,j}^{t} = 0,\\\\\n\\mathrm{sign}\\!\\left(F_{i,j}^{t}\\right),  &\\text{若 } F_{i,j}^{t} \\neq 0,\n\\end{cases}\n$$\n其中，如果 $x>0$，$\\mathrm{sign}(x)=+1$；如果 $x<0$，$\\mathrm{sign}(x)=-1$。当出现平局 ($F_{i,j}^{t}=0$) 时，保持当前自旋不变。\n- 一个构型 $s^\\star = \\{s_{i,j}^\\star\\}$ 在参数 $(J,h)$ 下是一个固定构型，当且仅当应用同步更新不产生任何变化，即对所有 $(i,j)$ 都有 $s_{i,j}^{t+1}=s_{i,j}^{t}=s_{i,j}^\\star$。\n- 扰动下的稳定性：给定一个有限的参数扰动集合 $\\{(\\Delta J_k,\\Delta h_k)\\}_{k=1}^{K}$，如果构型 $s^\\star$ 对于每个扰动后的参数对 $(J+\\Delta J_k,h+\\Delta h_k)$ 仍然是一个固定构型，则称其在这些扰动下是稳定的。\n- 汉明半径内的吸引盆：对于一个目标固定构型 $s^\\star$，定义构型 $x$ 和 $s^\\star$ 之间的汉明距离 $d_H(x,s^\\star)$ 为它们在格点上不一致的数量。对于半径 $R \\in \\mathbb{N}$ 和最大迭代预算 $M \\in \\mathbb{N}$，半径为 $R$ 的吸引盆 $\\mathcal{B}_R$ 是所有满足 $d_H(x,s^\\star) \\le R$ 的构型 $x$ 的集合，这些构型在基线参数 $(J,h)$ 下通过同步更新的迭代应用，在至多 $M$ 步内达到 $s^\\star$。如果一条轨迹进入一个不包含 $s^\\star$ 的循环，或者在 $M$ 步内未达到 $s^\\star$，则它不属于 $\\mathcal{B}_R$。\n\n需要实现的任务：\n1. 对于下面的每个测试用例，计算布尔值 `b_0`，指示 $s^\\star$ 在基线参数 $(J,h)$ 下是否为固定构型。\n2. 对于每个测试用例，计算布尔值 `b_1`，指示 $s^\\star$ 在所提供的列表中的所有扰动 $(J+\\Delta J_k,h+\\Delta h_k)$ 下是否为固定构型。\n3. 对于每个测试用例，计算整数 `B`，即在基线参数下汉明半径 $R$ 内吸引盆的大小。\n4. 对于每个测试用例，计算浮点数 `T_bar`，即 $\\mathcal{B}_R$ 中的构型达到 $s^\\star$ 所需的平均更新步数，四舍五入到三位小数。如果 $|\\mathcal{B}_R|=0$，则返回 `T_bar=0.0`。\n\n科学基础：\n- 从类伊辛模型的局部相互作用能 $E = -J \\sum_{\\langle (i,j),(p,q)\\rangle} s_{i,j} s_{p,q} - h \\sum_{(i,j)} s_{i,j}$ 出发，其中 $\\langle \\cdot,\\cdot \\rangle$ 表示最近邻。在零温确定性极限下，局部更新使自旋与局部场 $F_{i,j}$ 的符号对齐，从而得出上述规则。平局对应于局部中性的能量差异，保持不变，这与能量非增动力学一致。\n\n边界条件和计算细节：\n- 在 $N \\times N$ 晶格上使用周期性边界条件。\n- 邻域和是按规定对八个最近邻进行求和。\n- 在浮点数运算中，平局条件中的等于零应稳健处理，考虑一个小的容差，但由于这里所有的和都是 $J$ 的整数倍加上 $h$，如果实现得当，精确比较是可以接受的。\n- 汉明邻域枚举必须包括所有与 $s^\\star$ 相差恰好 $k$ 个自旋的构型，其中 $k \\in \\{0,1,\\dots,R\\}$。\n\n测试套件：\n- 所有用例均使用晶格大小 $N=4$，半径 $R=3$ 和最大迭代预算 $M=50$。对于每个用例，按如下方式定义 $s^\\star$、$(J,h)$ 和扰动 $\\{(\\Delta J_k,\\Delta h_k)\\}$。\n  - 用例 1 (均匀正相)：\n    - $s^\\star$ 是均匀构型，对所有 $(i,j)$ 都有 $s_{i,j}^\\star=+1$。\n    - 基线参数 $(J,h)=(1.0,0.0)$。\n    - 扰动： $\\{(-0.1,0.0),(0.0,0.2),(0.05,-0.3)\\}$。\n  - 用例 2 (棋盘构型)：\n    - $s^\\star$ 是棋盘构型 $s_{i,j}^\\star = (-1)^{i+j}$ 映射到 $\\{-1,+1\\}$，即如果 $i+j$ 是偶数，则 $s_{i,j}^\\star=+1$；如果 $i+j$ 是奇数，则 $s_{i,j}^\\star=-1$。\n    - 基线参数 $(J,h)=(1.0,0.0)$。\n    - 扰动： $\\{(0.0,0.1),(0.0,-0.1),(-0.1,0.05)\\}$。\n  - 用例 3 (均匀负相)：\n    - $s^\\star$ 是均匀构型，对所有 $(i,j)$ 都有 $s_{i,j}^\\star=-1$。\n    - 基线参数 $(J,h)=(1.0,0.0)$。\n    - 扰动： $\\{(0.0,-0.2),(-0.5,3.9),(-0.95,0.5)\\}$。\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是按顺序排列的方括号列表 `[b_0,b_1,B,T_bar]`，其中 `b_0` 和 `b_1` 是布尔值，`B` 是整数，`T_bar` 是四舍五入到三位小数的浮点数。例如，三个测试用例的有效输出应如下所示：`[[True,False,12,3.000],[True,True,8,1.250],[False,False,0,0.000]]`。",
            "solution": "用户的要求是实现并分析一个确定性的二维二元细胞自动机。该问题在科学上基于统计力学原理，特别是零温伊辛模型，并且问题定义适定，提供了所有必要的参数和定义。任务具有计算可行性，并且陈述客观清晰。因此，该问题被认为是有效的。\n\n解决方案首先将模型形式化，然后详细说明为解决指定任务而设计的算法。\n\n### 模型形式化\n\n该系统定义在一个大小为 $N \\times N$ 的二维方格晶格 $\\Omega$ 上，具有周期性边界条件。晶格上的每个格点 $(i,j)$ 处于两种状态之一，由一个自旋变量 $s_{i,j} \\in \\{-1, +1\\}$ 表示。系统的演化由一个同步更新规则控制，该规则确定性地最小化一个局部能量泛函。此规则依赖于每个格点的局部场 $F_{i,j}$，定义为：\n$$\nF_{i,j} = J \\sum_{(p,q)\\in\\mathcal{N}_{8}(i,j)} s_{p,q} + h\n$$\n这里，$J$ 是耦合常数，决定了一个自旋与其邻居相互作用的强度；$h$ 是一个外部偏置场，倾向于某一种自旋状态；$\\mathcal{N}_{8}(i,j)$ 是格点 $(i,j)$ 的 8 个最近邻的集合。这种形式化类似于伊辛模型在零温下的动力学，其中自旋排列以降低局部能量。\n\n所有格点 $(i,j)$ 从时间 $t$ 到 $t+1$ 的同步更新规则由下式给出：\n$$\ns_{i,j}^{t+1} =\n\\begin{cases}\ns_{i,j}^{t},  &\\text{若 } F_{i,j}^{t} = 0,\\\\\n\\mathrm{sign}\\!\\left(F_{i,j}^{t}\\right),  &\\text{若 } F_{i,j}^{t} \\neq 0,\n\\end{cases}\n$$\n其中符号函数定义为：当 $x > 0$ 时 $\\mathrm{sign}(x) = +1$，当 $x < 0$ 时 $\\mathrm{sign}(x) = -1$。如果局部场 $F_{i,j}^{t}$ 恰好为零，该格点的自旋保持不变，代表一种中性稳定状态。\n\n### 算法实现\n\n高效的实现需要仔细的设计，特别是在邻域和的计算以及吸引盆分析方面。\n\n**1. 不动点和稳定性分析 (任务 1 和 2)**\n\n一个构型 $s^\\star = \\{s_{i,j}^\\star\\}$ 是一个不动点，如果对于每个格点 $(i,j)$，更新规则不产生任何变化：$s_{i,j}^{t+1} = s_{i,j}^\\star$。这等价于对于每个格点，局部场 $F_{i,j}$ 要么为零，要么其符号与该格点的自旋匹配，即 $s_{i,j}^\\star \\cdot F_{i,j} > 0$。\n\n为了实现对 `b_0`（即 $s^\\star$ 在基线参数 $(J,h)$ 下是否为不动点）的检查，我们对 $s^\\star$ 执行一次完整的同步更新，并验证所得构型是否与 $s^\\star$ 相同。\n\n`b_1` 的稳定性分析扩展了此过程。如果构型 $s^\\star$ 对于所有扰动参数 $(J_k', h_k') = (J+\\Delta J_k, h+\\Delta h_k)$ 仍然是一个不动点，则它在一组扰动 $\\{(\\Delta J_k, \\Delta h_k)\\}$ 下是稳定的。该算法遍历每个扰动，应用不动点检查，并且只有当条件对所有扰动都成立时才返回 `True`。\n\n同时计算所有格点的邻居和 $\\sum s_{p,q}$ 的关键步骤，可以通过二维卷积高效完成。晶格构型与一个中心为零、其余为一的 $3 \\times 3$ 卷积核进行卷积。使用周期性边界条件（`scipy.signal.convolve2d` 中的 `wrap` 模式）正确处理了晶格拓扑。\n\n**2. 吸引盆分析 (任务 3 和 4)**\n\n仅当目标构型 $s^\\star$ 在基线参数 $(J,h)$ 下是有效的不动点时，才进行此分析。目标是找到吸引盆的大小 $B = |\\mathcal{B}_R|$ 和平均收敛时间 $\\bar{T}$。\n\n该算法按以下步骤进行：\n- **枚举汉明邻域**：我们必须测试每个与 $s^\\star$ 的汉明距离小于或等于半径 $R$ 的构型 $s$。这是通过为每个 $k \\in \\{0, 1, \\dots, R\\}$ 生成所有翻转 $k$ 个不同格点自旋的组合来完成的。`itertools.combinations` 函数用于这种组合生成。\n- **模拟轨迹**：对于每个生成的初始构型：\n    1. 运行最多 $M$ 步的模拟。\n    2. 在每一步，使用同步规则更新构型。\n    3. 检查轨迹是否收敛，如果构型变得与 $s^\\star$ 相同，则发生收敛。如果它在第 $\\tau$ 步收敛，则将此构型添加到吸引盆 $\\mathcal{B}_R$ 中，并记录步数 $\\tau$。\n    4. 为了检测非收敛循环，会维护当前轨迹中所有访问过的构型的历史记录。如果在到达 $s^\\star$ 之前重复了某个构型，则找到了一个循环，该轨迹被标记为非收敛。\n    5. 如果一条轨迹在 $M$ 步的预算内没有收敛到 $s^\\star$，它也被认为是非收敛的。\n- **计算统计数据**：在测试了汉明球内的所有初始构型后，盆地大小 $B$ 是收敛轨迹的总数。将所有收敛轨迹的步数相加，平均收敛时间 $\\bar{T}$ 计算为该总和除以 $B$。如果 $B=0$，$\\bar{T}$ 定义为 $0.0$。初始状态 $s^\\star$ 本身对吸引盆有贡献，其收敛时间为 0 步。\n\n这种全面的方法确保了根据问题陈述，自动机在指定不动点附近的动力学特性被正确地表征。使用 `numpy` 进行数组操作，`scipy` 进行卷积，以及标准库工具进行组合学计算，提供了一个高效且稳健的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    \n    # Define a helper function to create the s_star configurations.\n    def create_s_star(n_size, config_type):\n        if config_type == 'uniform_pos':\n            # All spins are +1\n            return np.ones((n_size, n_size), dtype=np.int8)\n        elif config_type == 'uniform_neg':\n            # All spins are -1\n            return -np.ones((n_size, n_size), dtype=np.int8)\n        elif config_type == 'checkerboard':\n            # s_ij = (-1)^(i+j)\n            # Create a grid where value is (i+j)\n            idx_grid = np.fromfunction(lambda i, j: i + j, (n_size, n_size), dtype=np.int8)\n            # Map even to +1, odd to -1\n            return 1 - 2 * (idx_grid % 2)\n        return None\n\n    # Define test cases as specified in the problem statement.\n    N_val = 4\n    test_cases = [\n        {\n            \"s_star\": create_s_star(N_val, 'uniform_pos'),\n            \"J\": 1.0, \"h\": 0.0,\n            \"perturbations\": [(-0.1, 0.0), (0.0, 0.2), (0.05, -0.3)],\n            \"N\": N_val, \"R\": 3, \"M\": 50\n        },\n        {\n            \"s_star\": create_s_star(N_val, 'checkerboard'),\n            \"J\": 1.0, \"h\": 0.0,\n            \"perturbations\": [(0.0, 0.1), (0.0, -0.1), (-0.1, 0.05)],\n            \"N\": N_val, \"R\": 3, \"M\": 50\n        },\n        {\n            \"s_star\": create_s_star(N_val, 'uniform_neg'),\n            \"J\": 1.0, \"h\": 0.0,\n            \"perturbations\": [(0.0, -0.2), (-0.5, 3.9), (-0.95, 0.5)],\n            \"N\": N_val, \"R\": 3, \"M\": 50\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(\n            case[\"s_star\"], case[\"J\"], case[\"h\"], case[\"perturbations\"],\n            case[\"N\"], case[\"R\"], case[\"M\"]\n        )\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    str_results = []\n    for res in results:\n        b0_str = str(res[0])\n        b1_str = str(res[1])\n        b_str = str(res[2])\n        t_bar_str = f\"{res[3]:.3f}\"\n        str_results.append(f\"[{b0_str},{b1_str},{b_str},{t_bar_str}]\")\n        \n    print(f\"[{','.join(str_results)}]\")\n\ndef update_step(config, J, h):\n    \"\"\"\n    Performs a single synchronous update of the entire lattice.\n    \"\"\"\n    # Kernel for summing the 8-neighbor Moore neighborhood.\n    kernel = np.array([[1, 1, 1], [1, 0, 1], [1, 1, 1]], dtype=np.int8)\n    # Use 2D convolution with periodic boundary conditions.\n    neighbor_sum = convolve2d(config, kernel, mode='same', boundary='wrap')\n    \n    # Calculate the local field F for all sites.\n    F = J * neighbor_sum + h\n    \n    # Apply the update rule.\n    next_config = config.copy()\n    next_config[F > 0] = 1\n    next_config[F  0] = -1\n    # Where F=0, the spin remains unchanged from the copied config.\n    \n    return next_config\n\ndef is_fixed_point(config, J, h):\n    \"\"\"\n    Checks if a given configuration is a fixed point for the given parameters.\n    \"\"\"\n    next_config = update_step(config, J, h)\n    return np.array_equal(config, next_config)\n\ndef analyze_basin(s_star, J, h, N, R, M):\n    \"\"\"\n    Analyzes the basin of attraction within Hamming radius R.\n    Returns the size of the basin (B) and the mean convergence time (T_bar).\n    \"\"\"\n    basin_size = 0\n    total_steps = 0\n    \n    num_sites = N * N\n    site_indices = np.arange(num_sites)\n\n    # Iterate through all Hamming distances from 0 to R.\n    for k in range(R + 1):\n        # Generate all combinations of k sites to flip.\n        for flip_indices_1d in combinations(site_indices, k):\n            # Create the initial configuration by flipping spins in s_star.\n            initial_config = s_star.copy()\n            if k > 0:\n                # Convert 1D indices to 2D for array indexing.\n                flip_indices_2d = np.unravel_index(list(flip_indices_1d), (N, N))\n                initial_config[flip_indices_2d] *= -1\n\n            # Simulate the trajectory for this initial configuration.\n            current_config = initial_config\n            # Use a set of byte-representations for efficient history tracking (cycle detection).\n            history = {current_config.tobytes()}\n            \n            # Check for convergence within M steps.\n            for step in range(M + 1):\n                if np.array_equal(current_config, s_star):\n                    basin_size += 1\n                    total_steps += step\n                    break\n                \n                # If we've reached the step limit M without converging, stop.\n                if step == M:\n                    break\n\n                current_config = update_step(current_config, J, h)\n                config_bytes = current_config.tobytes()\n                if config_bytes in history:\n                    # Cycle detected, trajectory does not converge to s_star.\n                    break\n                history.add(config_bytes)\n    \n    if basin_size == 0:\n        return 0, 0.0\n    \n    mean_steps = total_steps / basin_size\n    return basin_size, mean_steps\n\ndef process_case(s_star, J, h, perturbations, N, R, M):\n    \"\"\"\n    Processes a single test case to compute b0, b1, B, and T_bar.\n    \"\"\"\n    # Task 1: Check if s_star is a fixed configuration under baseline parameters.\n    b0 = is_fixed_point(s_star, J, h)\n    \n    # Task 2: Check if s_star is stable under all perturbations.\n    if not b0:\n        b1 = False\n    else:\n        b1 = True\n        for dJ, dh in perturbations:\n            if not is_fixed_point(s_star, J + dJ, h + dh):\n                b1 = False\n                break\n    \n    # Tasks 3  4: Analyze basin of attraction.\n    # If s_star is not a fixed point, its basin of attraction is considered empty.\n    if not b0:\n        B = 0\n        T_bar = 0.0\n    else:\n        B, T_bar = analyze_basin(s_star, J, h, N, R, M)\n        \n    return [b0, b1, B, T_bar]\n\n# Run the solver.\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将前面所学的网格建模和动态演化知识相结合，用于模拟一个重要的真实物理现象：定向凝固过程中的图形形成。你将实现一个元胞自动机，它能捕捉到稳定平直凝固前沿与元胞状微观结构形成之间的竞争，这一过程在物理上由穆林斯-塞克卡不稳定性所主导 。这项练习将你的数值模拟结果与线性稳定性理论的解析预测进行直接对比，是连接计算建模与理论物理的绝佳实践，充分展示了元胞自动机在探索材料科学复杂问题中的强大能力。",
            "id": "4113123",
            "problem": "设计并实现一个二维元胞自动机（CA）模型，用于模拟与半导体制造过程相关的定向凝固。该模型需能捕捉平面凝固前沿与胞状结构形成之间的竞争。模型必须基于以下基本原理和假设，并且所有量均为无量纲：\n\n1. 基本物理定律：使用 Fick 第二扩散定律描述一个被解释为过冷或过饱和场的标量场，其偏微分方程表示为 $$\\frac{\\partial u}{\\partial t} = D \\nabla^2 u,$$ 其中 $u$ 是标量场，$t$ 是时间，$D$ 是一个正常数扩散系数，$\\nabla^2$ 是拉普拉斯算子。在间距为 $\\Delta x = 1$ 的均匀方形晶格上，使用显式时间步进 $\\Delta t = 1$ 和标准的五点差分格式来实现拉普拉斯算子的离散版本。\n\n2. 界面动力学：通过结合局部驱动和曲率惩罚的线性动力学定律来近似法向界面速度，$$v_n \\propto \\alpha u_{\\mathrm{int}} - \\beta \\kappa,$$ 其中 $\\alpha  0$ 是界面迁移率系数，$\\beta \\ge 0$ 是有效毛细系数，$u_{\\mathrm{int}}$ 是界面前方紧邻处的局部标量场，$\\kappa$ 是局部界面曲率。界面被建模为固体区域的上边界；曲率可以通过界面高度的离散二阶差分来近似。\n\n3. 边界条件：在顶部和底部边界上施加固定的标量场，以驱动一个大小与控制参数 $G$ 成正比的线性背景梯度。在水平方向上使用周期性边界条件。\n\n4. 初始化：用振幅为 $A_0$、波数为 $k = \\frac{2\\pi m}{N_x}$（其中 $m$ 为整数模式指数，$N_x$ 为水平网格大小）的微小正弦高度扰动来初始化一个平面界面。固体占据界面以下的区域。将标量场初始化为与边界条件一致的线性剖面。\n\n5. 经验稳定性评估：通过以下公式数值估计正弦振幅的时间增长率：$$\\sigma_{\\mathrm{emp}}(k) = \\frac{1}{T_{\\mathrm{eff}}} \\ln\\left(\\frac{A(T_{\\mathrm{eff}})}{A(0)}\\right),$$ 其中 $A(t)$ 是在时间 $t$ 时界面高度选定傅里叶模式的振幅，通过对高度场进行离散傅里叶变换提取，而 $T_{\\mathrm{eff}}$ 是实际模拟的时间步数（以考虑当界面到达域边界时提前终止的情况）。经验临界梯度 $G_{\\mathrm{c,CA}}(k)$ 是使 $\\sigma_{\\mathrm{emp}}(k)$ 符号改变的 $G$ 值，通过扫描一定范围内的 $G$ 并选择使增长率最接近零的值来估计。\n\n6. 解析比较：从 Fick 第二定律和界面的线性动力学定律出发，在离散设置下进行线性稳定性分析，以获得形式为 $$\\sigma(k;G) = \\alpha G - \\mathcal{D}(k) - \\beta k^2,$$ 的色散关系，其中 $\\mathcal{D}(k)$ 是离散扩散贡献。对于间距为 $\\Delta x = 1$ 的方形晶格上的五点差分格式，平面波响应得出 $$\\mathcal{D}(k) = 2D\\left(1 - \\cos(k)\\right),$$ 适用于水平方向周期性扰动。解析临界梯度则为 $$G_{\\mathrm{c,an}}(k) = \\frac{\\mathcal{D}(k) + \\beta k^2}{\\alpha}.$$\n\n7. 输出量：对于每个测试案例，计算差值 $$\\Delta G(k) = G_{\\mathrm{c,CA}}(k) - G_{\\mathrm{c,an}}(k).$$\n\n每个时间步的 CA 更新必须遵循以下步骤：\n- 使用扩散系数为 $D$ 的离散拉普拉斯算子对标量场 $u$ 进行扩散，并在顶部 $(y=0)$ 和底部 $(y=N_y-1)$ 强制执行与由 $G$ 控制的垂直梯度一致的 Dirichlet 边界条件。在 $x$ 方向使用周期性边界条件。\n- 使用界面高度的二阶差分计算离散界面曲率 $\\kappa$。\n- 在界面驱动为正的列中，根据规则将界面向上推进一个晶格位置：如果 $\\alpha u_{\\mathrm{int}} - \\beta \\kappa  0$，则界面正上方的液体单元凝固。在新凝固的位置，将 $u$ 局部减少一个小的消耗量，以模拟潜热或溶质吸收。固体区域相应更新。\n- 使用界面高度与其平均值偏差的相应离散傅里叶系数的模，测量指定模式 $m$ 的界面振幅 $A(t)$。\n\n测试套件和规格：\n- 使用均匀网格，其中 $N_x = 64$ 和 $N_y = 64$，间距 $\\Delta x = 1$，时间步长 $\\Delta t = 1$。\n- 使用以下三个测试案例，每个由 $(m, D, \\alpha, \\beta, A_0, T)$ 指定：\n    1. $(m=2, D=0.2, \\alpha=0.7, \\beta=0.05, A_0=2.0, T=180)$\n    2. $(m=2, D=0.01, \\alpha=0.5, \\beta=0.0, A_0=2.0, T=180)$\n    3. $(m=4, D=0.15, \\alpha=0.9, \\beta=0.25, A_0=2.0, T=180)$\n- 对于每个测试案例，通过在以 $G_{\\mathrm{c,an}}(k)$ 为中心的合适范围内扫描 $G$，并选择使 $\\sigma_{\\mathrm{emp}}(k)$ 最接近零的 $G$ 值，来确定 $G_{\\mathrm{c,CA}}(k)$。\n- 最终的程序输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中包含按给定顺序排列的三个测试案例的 `[`ΔG_1`, `ΔG_2`, `ΔG_3`]` 值。数值必须是无量纲单位的小数。\n\n程序必须是自包含的，且不应要求任何用户输入。它必须实现 CA，执行经验稳定性分析，计算解析预测，并以指定格式打印最终的单行输出。不允许有其他输出。",
            "solution": "科学知识库证实了该问题的有效性。它提出了一个适定的计算物理任务，该任务基于定向凝固过程中图样形成的既定原理，特别是 Mullins-Sekerka 不稳定性。该问题要求在使用元胞自动机（CA）的直接数值模拟与线性化解析稳定性分析之间进行比较。目标是量化这两种方法预测的失稳临界热梯度之间的差异。\n\n对每个测试案例，解决方案分两个主要阶段进行：首先，计算解析临界梯度 $G_{\\mathrm{c,an}}(k)$；其次，通过直接模拟数值确定经验临界梯度 $G_{\\mathrm{c,CA}}(k)$。最终结果是差值 $\\Delta G(k) = G_{\\mathrm{c,CA}}(k) - G_{\\mathrm{c,an}}(k)$。\n\n### 解析临界梯度，$G_{\\mathrm{c,an}}(k)$\n\n问题提供了在施加梯度 $G$ 的情况下，波数为 $k$ 的正弦扰动增长率 $\\sigma$ 的解析色散关系：\n$$\n\\sigma(k;G) = \\alpha G - \\mathcal{D}(k) - \\beta k^2\n$$\n此处，$\\alpha G$ 是由成分过冷/过饱和梯度引起的失稳项。$\\mathcal{D}(k)$ 是由扩散引起的稳定项，而 $\\beta k^2$ 是由毛细作用（界面能）引起的稳定项。稳定性的临界条件是增长率为零，即 $\\sigma(k;G) = 0$。求解在此阈值下的梯度 $G$ 即可得到解析临界梯度 $G_{\\mathrm{c,an}}(k)$。\n\n给定在间距为 $\\Delta x = 1$ 的晶格上使用五点差分格式的离散扩散项：\n$$\n\\mathcal{D}(k) = 2D(1 - \\cos(k))\n$$\n通过设置 $\\sigma(k;G) = 0$ 来找到解析临界梯度：\n$$\n\\alpha G_{\\mathrm{c,an}}(k) - 2D(1 - \\cos(k)) - \\beta k^2 = 0\n$$\n$$\nG_{\\mathrm{c,an}}(k) = \\frac{2D(1 - \\cos(k)) + \\beta k^2}{\\alpha}\n$$\n对于每个测试案例，波数 $k$ 由模式指数 $m$ 和水平网格大小 $N_x = 64$ 决定：\n$$\nk = \\frac{2\\pi m}{N_x}\n$$\n该公式用于计算每组参数 $(m, D, \\alpha, \\beta)$ 的参考临界梯度。\n\n### 数值临界梯度，$G_{\\mathrm{c,CA}}(k)$\n\n经验临界梯度 $G_{\\mathrm{c,CA}}(k)$ 是通过在一系列候选梯度 $G$ 上执行一系列 CA 模拟，并确定使扰动增长率最接近零的 $G$ 值来确定的。\n\n**1. 模拟设置**\n\n对于每次模拟，都会初始化一个大小为 $N_x = 64 \\times N_y = 64$ 的二维网格。坐标系定义为顶部 $y=0$，底部 $y=N_y-1$。\n\n- **标量场 $u$**：代表过饱和度的标量场 $u$ 被初始化为与施加梯度 $G$ 一致的线性剖面。顶部和底部的边界条件是固定的（Dirichlet）：$u(x, y=0) = G(N_y-1)$ 和 $u(x, y=N_y-1) = 0$。因此，初始场为 $u(x, y) = G \\cdot (N_y - 1 - y)$。\n- **界面**：界面由一个整数高度数组 $h(x)$ 表示，其中 $h(x)$ 是第 $x$ 列中固液边界的 y 坐标。固相存在于 $y \\ge h(x)$ 的区域。界面在域的底部附近（平均高度为 $N_y - 20$）被初始化，并带有一个振幅为 $A_0$、波数为 $k$ 的正弦扰动：\n  $$\n  h(x, t=0) = \\text{round}\\left( (N_y - 20) - A_0 \\cos(kx) \\right)\n  $$\n- **相场**：使用相场 $\\phi(x,y)$ 来区分液相（$\\phi=0$）和固相（$\\phi=1$）单元。\n\n**2. CA 时间演化**\n\n系统在最多 $T$ 个时间步内演化，$\\Delta t=1$。每个步骤包括以下顺序更新：\n\n- **$u$ 的扩散**：标量场 $u$ 根据 Fick 第二定律的显式有限差分形式演化，$\\frac{\\partial u}{\\partial t} = D \\nabla^2 u$。拉普拉斯算子 $\\nabla^2 u$ 使用五点差分格式和 $x$ 方向的周期性边界条件计算。\n  $$\n  u(x,y,t+\\Delta t) = u(x,y,t) + D \\Delta t \\left[ u(x+1,y,t) + u(x-1,y,t) + u(x,y+1,t) + u(x,y-1,t) - 4u(x,y,t) \\right]\n  $$\n  扩散更新后，重新施加 $y=0$ 和 $y=N_y-1$ 处的固定边界条件。此外，将固相区域内的过饱和度设置为零，$u(x,y) = 0$ 对所有 $\\phi(x,y)=1$ 的单元成立。\n\n- **界面推进**：界面运动由基于局部驱动力的离散规则控制。\n    - 界面处的局部过饱和度为 $u_{\\mathrm{int}}(x) = u(x, h(x)-1, t+\\Delta t)$。\n    - 局部界面曲率 $\\kappa(x)$ 通过高度剖面的中心二阶差分近似：$\\kappa(x) = h(x+1) + h(x-1) - 2h(x)$。\n    - 驱动力为 $F_{\\text{drive}}(x) = \\alpha u_{\\mathrm{int}}(x) - \\beta \\kappa(x)$。\n    - 对于每个驱动力 $F_{\\text{drive}}(x) > 0$ 的列 $x$，界面向上推进一个晶格位点：$h(x) \\to h(x) - 1$。这种基于阈值的离散推进是与解析模型中假设的连续速度定律的一个关键区别。\n\n- **推进后更新**：界面推进后，任何新凝固的单元通过在其位置设置 $u=0$ 来消耗其局部过饱和度。\n\n**3. 增长率测量**\n\n在每个时间步测量扰动振幅 $A(t)$。从界面剖面中减去平均高度，$h'(x,t) = h(x,t) - \\langle h \\rangle_x$，并对 $h'(x,t)$ 进行离散傅里叶变换（DFT）。使用实信号的标准定义提取模式 $m$ 的振幅：\n$$\nA(t) = \\frac{2}{N_x} |\\hat{h}'(m,t)|\n$$\n其中 $\\hat{h}'(m,t)$ 是来自 DFT 的第 $m$ 个复系数。从离散化的初始界面测量初始振幅 $A(0)$，并在模拟结束时测量最终振幅 $A(T_{\\mathrm{eff}})$。有效模拟时间 $T_{\\mathrm{eff}}$ 是模拟终止前完成的步数，如果界面到达域边界，该值可能小于最大时间 $T$。\n\n然后经验增长率计算如下：\n$$\n\\sigma_{\\mathrm{emp}}(k) = \\frac{1}{T_{\\mathrm{eff}}} \\ln\\left(\\frac{A(T_{\\mathrm{eff}})}{A(0)}\\right)\n$$\n\n**4. 寻找 $G_{\\mathrm{c,CA}}(k)$**\n\n对于每个测试案例，在以解析预测 $G_{\\mathrm{c,an}}(k)$ 为中心的一系列候选 $G$ 值上进行一维搜索。对于每个 $G_{\\text{test}}$，运行一次完整的 CA 模拟以计算 $\\sigma_{\\mathrm{emp}}(k)$。产生最接近零的增长率的 $G_{\\text{test}}$ 值被选为数值临界梯度 $G_{\\mathrm{c,CA}}(k)$。\n\n这个过程系统地确定了数值稳定性阈值，从而可以直接与解析预测进行比较并计算 $\\Delta G(k)$。差异 $\\Delta G(k)$ 的主要来源包括：CA 的离散、带阈值的界面推进规则与解析模型的连续速度定律之间的差异，以及解析公式中使用了连续曲率近似 $\\beta k^2$ 而非离散表示。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the complete analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        # (m, D, alpha, beta, A0, T)\n        (2, 0.2, 0.7, 0.05, 2.0, 180),\n        (2, 0.01, 0.5, 0.0, 2.0, 180),\n        (4, 0.15, 0.9, 0.25, 2.0, 180),\n    ]\n\n    delta_g_results = []\n\n    for m, D, alpha, beta, A0, T in test_cases:\n        params = {\n            'm': m, 'D': D, 'alpha': alpha, 'beta': beta,\n            'A0': A0, 'T': T,\n            'Nx': 64, 'Ny': 64\n        }\n        \n        # 1. Calculate analytical critical gradient\n        k = 2 * np.pi * m / params['Nx']\n        D_k = 2 * D * (1 - np.cos(k))\n        g_c_analytical = (D_k + beta * k**2) / alpha\n        \n        # 2. Find numerical critical gradient by scanning G\n        g_c_numerical = find_g_crit_ca(params, g_c_analytical)\n        \n        # 3. Compute and store the difference\n        delta_g = g_c_numerical - g_c_analytical\n        delta_g_results.append(delta_g)\n\n    print(f\"[{','.join(f'{g:.6f}' for g in delta_g_results)}]\")\n\ndef find_g_crit_ca(params, g_an_estimate):\n    \"\"\"\n    Scans a range of G values around an estimate to find the numerical critical gradient.\n    \"\"\"\n    if g_an_estimate == 0:\n        # Handle cases where analytical G is zero or very small\n        g_range = np.linspace(-0.01, 0.01, 21)\n    else:\n        # Scan a range from 50% to 150% of the analytical value\n        g_range = np.linspace(g_an_estimate * 0.5, g_an_estimate * 1.5, 21)\n    \n    sigmas = []\n    for g_test in g_range:\n        current_params = params.copy()\n        current_params['G'] = g_test\n        sigma = run_ca_simulation(current_params)\n        sigmas.append(sigma)\n    \n    sigmas = np.array(sigmas)\n    # Find the G that results in sigma closest to 0\n    closest_idx = np.argmin(np.abs(sigmas))\n    \n    return g_range[closest_idx]\n\ndef run_ca_simulation(params):\n    \"\"\"\n    Runs a single Cellular Automaton simulation for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    m, D, alpha, beta, A0, T = params['m'], params['D'], params['alpha'], params['beta'], params['A0'], params['T']\n    Nx, Ny, G = params['Nx'], params['Ny'], params['G']\n\n    k = 2 * np.pi * m / Nx\n    x_coords = np.arange(Nx)\n    \n    # Initialization\n    # Scalar field u\n    y_coords = np.arange(Ny).reshape(-1, 1)\n    u = G * (Ny - 1 - y_coords)\n    u = np.broadcast_to(u, (Ny, Nx)).copy()\n    \n    # Interface height h\n    h_mean = Ny - 20\n    h_initial = np.round(h_mean - A0 * np.cos(k * x_coords)).astype(int)\n    h = h_initial.copy()\n    \n    # Phase field (1 for solid, 0 for liquid)\n    y_grid, _ = np.mgrid[0:Ny, 0:Nx]\n    phase_mask = y_grid >= h\n    u[phase_mask] = 0.0\n\n    # Measure initial amplitude\n    h_dev_initial = h_initial - np.mean(h_initial)\n    fft_initial = np.fft.fft(h_dev_initial)\n    A_initial = (2 / Nx) * np.abs(fft_initial[m])\n\n    if A_initial == 0:\n        return np.inf  # Undefined growth\n\n    T_eff = T\n    for t in range(1, T + 1):\n        # Diffusion Step\n        lap_u = (np.roll(u, 1, axis=1) + np.roll(u, -1, axis=1) +\n                 np.roll(u, 1, axis=0) + np.roll(u, -1, axis=0) - 4.0 * u)\n        u += D * lap_u\n\n        # Set u=0 in the solid region\n        solid_mask = y_grid >= h\n        u[solid_mask] = 0.0\n\n        # Enforce Dirichlet BCs\n        u[0, :] = G * (Ny - 1)\n        u[Ny-1, :] = 0.0\n        \n        # Interface Advancement Step\n        # Check for boundary collision\n        if np.any(h = 1) or np.any(h >= Ny - 2):\n            T_eff = t - 1\n            break\n\n        # Get u just above the interface\n        u_interface = u[h - 1, x_coords]\n        \n        # Calculate curvature\n        kappa = np.roll(h, 1) + np.roll(h, -1) - 2 * h\n        \n        # Calculate drive and advance interface\n        drive = alpha * u_interface - beta * kappa\n        to_advance = drive > 0\n        \n        h_old = h.copy()\n        h[to_advance] -= 1\n        \n        # Consume supersaturation at newly solidified cells\n        newly_solidified_mask_x = h  h_old\n        if np.any(newly_solidified_mask_x):\n            new_solid_y_coords = h[newly_solidified_mask_x]\n            new_solid_x_coords = x_coords[newly_solidified_mask_x]\n            u[new_solid_y_coords, new_solid_x_coords] = 0.0\n    \n    if T_eff = 0:\n        return np.inf # Simulation ended immediately\n\n    # Measure final amplitude\n    h_dev_final = h - np.mean(h)\n    fft_final = np.fft.fft(h_dev_final)\n    A_final = (2 / Nx) * np.abs(fft_final[m])\n\n    if A_final == 0:\n        return -np.inf # Perturbation died out completely\n\n    # Calculate empirical growth rate\n    sigma_emp = (1 / T_eff) * np.log(A_final / A_initial)\n    \n    return sigma_emp\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}