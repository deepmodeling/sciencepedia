{
    "hands_on_practices": [
        {
            "introduction": "本节的实践练习将我们的讨论置于实验现实的基础之上。它展示了如何利用一个宏观测量量——晶圆的弯曲——来量化薄膜内部的微观应力 ()，这是工艺控制和仿真输入的一个关键参数。这项练习通过推导和应用著名的 Stoney 方程，巩固了板力学理论与实际表征技术之间的联系。",
            "id": "4132811",
            "problem": "微电子工艺流程模拟需要等双轴薄膜应力来参数化后续热处理步骤中的应力相关扩散和图形变形。在一个沉积步骤之后，测量得到一个圆形硅片具有均匀的曲率。将该硅片视为一个各向同性、均匀的板，并将沉积的薄膜视为一个远薄于基底的、承受均匀等双轴应力的层。仅从线性弹性理论和经典各向同性板弯曲理论出发，推导薄膜应力与测得的晶圆曲率之间的关系。\n\n假设晶体硅基底和氮化硅薄膜具有以下测量值和材料参数：\n- 测得的曲率（定义为 $k = 1/R$，其中 $R$ 为曲率半径）：$k = 1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}$，标准不确定度 $u_k = 5.00 \\times 10^{-6} \\,\\mathrm{m}^{-1}$。\n- 基底厚度：$t_s = 775 \\,\\mu\\mathrm{m}$，标准不确定度 $u_{t_s} = 1.00 \\,\\mu\\mathrm{m}$。\n- 薄膜厚度：$t_f = 100 \\,\\mathrm{nm}$，标准不确定度 $u_{t_f} = 0.50 \\,\\mathrm{nm}$。\n- 基底杨氏模量：$E_s = 130 \\,\\mathrm{GPa}$，标准不确定度 $u_{E_s} = 1.00 \\,\\mathrm{GPa}$。\n- 基底泊松比：$\\nu_s = 0.28$，标准不确定度 $u_{\\nu_s} = 0.010$。\n\n使用与《测量不确定度表示指南》(GUM)一致的不确定度传播定律，假设所有输入量都是独立且不相关的，传播不确定度以获得计算出的薄膜应力的标准不确定度。清晰地陈述所使用的任何理想化假设。\n\n计算薄膜应力的数值及其标准不确定度。将应力及其不确定度都以兆帕（MPa）为单位表示。将应力值四舍五入到四位有效数字，将标准不确定度四舍五入到两位有效数字。最终答案必须以一对数字的形式给出，分别对应应力及其标准不确定度。",
            "solution": "该问题具有科学依据，提法得当且客观。它提出了一个薄膜力学中的标准问题，具有物理上合理的参数，并要求基于线性弹性理论和板理论的基本原理进行推导和计算，然后进行标准不确定度分析。所有必要信息均已提供，没有矛盾或模糊之处。因此，该问题被认为是有效的，并将提供完整的解答。\n\n主要任务是推导薄膜中的内应力 $\\sigma_f$ 与其在厚得多的基底中引起的曲率 $k$ 之间的关系。这个关系就是著名的 Stoney 方程。推导从经典板理论和线性弹性理论的原理出发，基于以下几个关键的理想化假设：\n1.  薄膜比基底薄得多，即 $t_f \\ll t_s$。这使我们可以忽略薄膜本身的抗弯刚度，并假设复合结构的弯曲中性面位于基底的中面。\n2.  基底被视为一个均匀、各向同性的线性弹性板。\n3.  变形很小，符合线性弹性理论的假设。\n4.  薄膜具有均匀的等双轴应力 $\\sigma_f$。\n5.  引起的曲率 $k$ 在整个晶圆上是均匀的。\n\n设基底的厚度为 $t_s$，杨氏模量为 $E_s$，泊松比为 $\\nu_s$。设薄膜的厚度为 $t_f$。薄膜中的等双轴应力 $\\sigma_f$ 在界面处对基底施加一个单位长度上的力 $F'$，其大小为 $F' = \\sigma_f t_f$。\n\n这个力作用在界面上，但基底是围绕其中性轴弯曲的。由于 $t_f \\ll t_s$ 的近似，中性轴位于基底的中心，距离界面 $t_s/2$。因此，这个力在基底中产生一个单位长度上的弯矩 $M'$：\n$$\nM' = F' \\cdot \\frac{t_s}{2} = (\\sigma_f t_f) \\frac{t_s}{2}\n$$\n根据经典板理论，对于在等双轴弯曲（$k_x = k_y = k$）下的各向同性材料，施加的单位长度上的弯矩 $M'$ 与产生的曲率 $k$ 之间的关系是：\n$$\nM' = D k (1 + \\nu_s)\n$$\n其中 $D$ 是板的抗弯刚度，定义为：\n$$\nD = \\frac{E_s t_s^3}{12(1-\\nu_s^2)}\n$$\n将 $D$ 的表达式代入弯矩-曲率关系中：\n$$\nM' = \\frac{E_s t_s^3}{12(1-\\nu_s^2)} k (1 + \\nu_s) = \\frac{E_s t_s^3 k (1 + \\nu_s)}{12(1-\\nu_s)(1+\\nu_s)} = \\frac{E_s t_s^3 k}{12(1-\\nu_s)}\n$$\n现在，我们令弯矩 $M'$ 的两个表达式相等：\n$$\n(\\sigma_f t_f) \\frac{t_s}{2} = \\frac{E_s t_s^3 k}{12(1-\\nu_s)}\n$$\n求解薄膜应力 $\\sigma_f$，我们得到 Stoney 方程：\n$$\n\\sigma_f = \\frac{E_s t_s^2 k}{6(1-\\nu_s)t_f}\n$$\n这就是所要求的关系。$\\sigma_f$ 的正值对应于薄膜中的拉应力，这会导致晶圆弯曲成凹形（正曲率）。\n\n接下来，我们使用所提供的数据计算薄膜应力的数值。所有数值都转换为国际单位制基本单位（米、帕斯卡）。\n- $k = 1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}$\n- $t_s = 775 \\,\\mu\\mathrm{m} = 775 \\times 10^{-6} \\,\\mathrm{m}$\n- $t_f = 100 \\,\\mathrm{nm} = 100 \\times 10^{-9} \\,\\mathrm{m}$\n- $E_s = 130 \\,\\mathrm{GPa} = 130 \\times 10^9 \\,\\mathrm{Pa}$\n- $\\nu_s = 0.28$\n\n将这些值代入 Stoney 方程：\n$$\n\\sigma_f = \\frac{(130 \\times 10^9 \\,\\mathrm{Pa}) (775 \\times 10^{-6} \\,\\mathrm{m})^2 (1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1})}{6(1 - 0.28)(100 \\times 10^{-9} \\,\\mathrm{m})}\n$$\n$$\n\\sigma_f = \\frac{(1.30 \\times 10^{11}) \\cdot (6.00625 \\times 10^{-7}) \\cdot (1.000 \\times 10^{-3})}{6(0.72)(1.00 \\times 10^{-7})} \\,\\mathrm{Pa}\n$$\n$$\n\\sigma_f = \\frac{7.808125 \\times 10^1}{0.432} \\,\\mathrm{Pa} \\approx 1.807436 \\times 10^8 \\,\\mathrm{Pa} = 180.7436 \\,\\mathrm{MPa}\n$$\n按要求四舍五入到四位有效数字，薄膜应力为 $\\sigma_f \\approx 180.7 \\,\\mathrm{MPa}$。\n\n最后，我们传播不确定度。函数为 $\\sigma_f = \\sigma_f(E_s, t_s, k, t_f, \\nu_s)$。对于独立的输入量，根据不确定度传播定律，合成标准不确定度的平方 $u^2(\\sigma_f)$ 由下式给出：\n$$\nu^2(\\sigma_f) = \\sum_i \\left( \\frac{\\partial \\sigma_f}{\\partial x_i} u_{x_i} \\right)^2\n$$\n使用相对不确定度进行计算会很方便。两边同除以 $\\sigma_f^2$：\n$$\n\\left(\\frac{u(\\sigma_f)}{\\sigma_f}\\right)^2 = \\left(\\frac{u_{E_s}}{E_s}\\right)^2 + \\left(2\\frac{u_{t_s}}{t_s}\\right)^2 + \\left(\\frac{u_k}{k}\\right)^2 + \\left(\\frac{u_{t_f}}{t_f}\\right)^2 + \\left(\\frac{u_{\\nu_s}}{1-\\nu_s}\\right)^2\n$$\n我们计算每一项的相对不确定度平方：\n- $u_{E_s}/E_s = (1.00 \\,\\mathrm{GPa}) / (130 \\,\\mathrm{GPa}) = 1/130$。项：$(1/130)^2 \\approx 5.917 \\times 10^{-5}$。\n- $u_{t_s}/t_s = (1.00 \\,\\mu\\mathrm{m}) / (775 \\,\\mu\\mathrm{m}) = 1/775$。项：$(2 \\cdot 1/775)^2 \\approx 6.660 \\times 10^{-6}$。\n- $u_k/k = (5.00 \\times 10^{-6} \\,\\mathrm{m}^{-1}) / (1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}) = 0.005$。项：$(0.005)^2 = 2.500 \\times 10^{-5}$。\n- $u_{t_f}/t_f = (0.50 \\,\\mathrm{nm}) / (100 \\,\\mathrm{nm}) = 0.005$。项：$(0.005)^2 = 2.500 \\times 10^{-5}$。\n- $u_{\\nu_s}/(1-\\nu_s) = 0.010 / (1 - 0.28) = 0.010/0.72$。项：$(0.010/0.72)^2 \\approx 1.929 \\times 10^{-4}$。\n\n将各项相加：\n$$\n\\left(\\frac{u(\\sigma_f)}{\\sigma_f}\\right)^2 \\approx (5.917 \\times 10^{-5}) + (6.660 \\times 10^{-6}) + (2.500 \\times 10^{-5}) + (2.500 \\times 10^{-5}) + (1.929 \\times 10^{-4}) \\approx 3.0873 \\times 10^{-4}\n$$\n因此，相对不确定度为：\n$$\n\\frac{u(\\sigma_f)}{\\sigma_f} = \\sqrt{3.0873 \\times 10^{-4}} \\approx 0.01757\n$$\n应力的绝对标准不确定度 $u(\\sigma_f)$ 为：\n$$\nu(\\sigma_f) = \\sigma_f \\cdot \\frac{u(\\sigma_f)}{\\sigma_f} \\approx (180.7436 \\,\\mathrm{MPa}) \\cdot (0.01757) \\approx 3.176 \\,\\mathrm{MPa}\n$$\n按要求将标准不确定度四舍五入到两位有效数字，得到 $u(\\sigma_f) \\approx 3.2 \\,\\mathrm{MPa}$。\n\n计算出的薄膜应力为 $180.7 \\,\\mathrm{MPa}$，其标准不确定度为 $3.2 \\,\\mathrm{MPa}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 180.7  3.2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在应力概念的基础上，我们现在来解决硅晶体复杂且具各向异性的特性。该练习演示了当晶圆在加工过程中被重新定向时，如何以数学方式表示和转换材料的刚度张量 ()，从而确保我们的仿真能准确反映方向相关的力学响应。这对于现代半导体制造中的预测性建模至关重要。",
            "id": "4132792",
            "problem": "一块单晶硅片表现出立方各向异性弹性，其特性由与晶轴 $[100]$、$[010]$ 和 $[001]$ 对齐的晶体参考系中的四阶刚度张量 $C_{ijkl}$ 描述。该晶片经过一个制造工艺流程，在流程中的步骤之间，由于晶片旋转和切割等操作，它会进行机械重新定向。工艺流程模拟必须通过根据晶片在每一步的方向变换刚度张量，来包含这些重新定向对弹性响应的影响。\n\n您需要实现一个程序，对于应用于晶片的指定刚性旋转序列，计算实验室坐标系中变换后的刚度张量 $C'_{pqrs}$，并报告选定的分量，以供下游工艺模型使用。\n\n从以下基本原理开始：\n- 线性弹性力学中的柯西应力-应变关系为 $\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$，其中 $\\sigma_{ij}$ 是二阶柯西应力张量，$\\varepsilon_{kl}$ 是二阶无穷小应变张量，$C_{ijkl}$ 是四阶刚度张量。\n- 根据线性代数和刚体运动学的法则，二阶张量和向量的分量在正常正交基变换下进行变换。使用这些原理推导当晶片通过一次正常正交旋转进行旋转时四阶刚度张量的变换法则。\n\n假设和数据：\n- 室温下立方硅的晶体坐标系刚度由三个独立的常数指定：$C_{11} = 165.7$ 吉帕斯卡 (GPa)，$C_{12} = 63.9$ GPa，以及 $C_{44} = 79.6$ GPa。使用这些值在晶体坐标系中构建 $C_{ijkl}$。克罗内克δ为 $\\delta_{ij}$，晶轴是标准基向量 $\\mathbf{e}_1 = (1,0,0)$、$\\mathbf{e}_2 = (0,1,0)$、$\\mathbf{e}_3 = (0,0,1)$。\n- 所有旋转都是行列式为 $+1$ 的正常正交旋转，围绕实验室坐标轴 $\\hat{x}$、$\\hat{y}$ 和 $\\hat{z}$ 进行，并按给定顺序应用。使用右手定则确定旋转方向。\n- 角度值以度为单位提供；您必须使用度，并在需要时在内部转换为弧度。\n- 所有刚度分量均以吉帕斯卡 (GPa) 为单位报告。\n\n任务：\n1. 从所述基本原理出发，推导刚性旋转下四阶刚度张量的正确变换，确保与二阶张量的变换规则一致。\n2. 实现一个函数，使用 $\\delta_{ij}$ 和晶轴的标准张量构造方法，从 $C_{11}$、$C_{12}$ 和 $C_{44}$ 构建立方晶体的晶体坐标系四阶刚度张量 $C_{ijkl}$。\n3. 实现绕 $\\hat{x}$、$\\hat{y}$ 和 $\\hat{z}$ 轴按给定角度（以度为单位）旋转的旋转矩阵，并按给定顺序复合多次旋转，以形成每个工艺步骤序列中从晶体坐标系到实验室坐标系的总旋转。\n4. 应用推导出的变换以获得实验室坐标系刚度 $C'_{pqrs}$，并提取分量 $C'_{1111}$、$C'_{1122}$ 和 $C'_{1212}$，以吉帕斯卡 (GPa) 表示。将每个报告值四舍五入到六位小数。\n\n测试套件：\n使用以下四个测试用例，每个用例由按顺序应用于晶片的一系列旋转定义：\n- 用例 A（基准，无旋转）：一个空序列。\n- 用例 B（四重对称性检查）：绕 $\\hat{z}$ 轴单次旋转 $90$ 度。\n- 用例 C（一般平面内旋转）：绕 $\\hat{z}$ 轴单次旋转 $45$ 度。\n- 用例 D（复合工艺重定向）：绕 $\\hat{z}$ 轴旋转 $30$ 度，然后绕 $\\hat{x}$ 轴旋转 $180$ 度。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个方括号括起来的逗号分隔列表形式的结果，其中每个用例由一个包含三个浮点数的列表 $[C'_{1111}, C'_{1122}, C'_{1212}]$（单位 GPa）表示，四舍五入到六位小数。因此，总输出是一个列表的列表，按 A、B、C、D 的顺序排列。例如，输出应如下所示：\n[[a11,a12,a66],[b11,b12,b66],[c11,c12,c66],[d11,d12,d66]]\n其中每个符号代表一个 GPa 单位的浮点数，保留六位小数。",
            "solution": "问题陈述已经过严格审查，并被确定为**有效**。它在科学上基于连续介质力学的原理，问题设定良好，数据完整一致，并以客观、正式的语言表述。这些任务在计算上是可行的，并且与半导体工艺模拟领域相关。\n\n### 1. 四阶刚度张量变换定律的推导\n\n在线性弹性材料中，柯西应力张量 $\\sigma$ 和无穷小应变张量 $\\varepsilon$ 之间的关系由广义胡克定律给出：\n$$ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $$\n其中 $C_{ijkl}$ 是四阶刚度张量。这个方程是一个张量关系，其形式在坐标系变换下必须保持不变。\n\n让我们考虑两个笛卡尔坐标系：实验室坐标系，其基向量为 $\\{\\mathbf{e}_p\\}$；以及晶体坐标系，其基向量为 $\\{\\mathbf{e'}_i\\}$。晶体坐标系是通过对实验室坐标系进行刚性旋转得到的。设该旋转由一个正常正交矩阵 $R$ 描述，其分量为 $R_{ip} = \\mathbf{e'}_i \\cdot \\mathbf{e}_p$。向量 $\\mathbf{v}$ 在两个坐标系中的分量关系为 $v'_i = R_{ij} v_j$。\n\n二阶张量（如应力 $\\sigma$ 和应变 $\\varepsilon$）的分量按以下规则变换：\n$$ \\sigma'_{pq} = R_{pi} R_{qj} \\sigma_{ij} $$\n$$ \\varepsilon'_{rs} = R_{rk} R_{sl} \\varepsilon_{kl} $$\n在这里，带撇号的分量在晶体坐标系中，不带撇号的分量在实验室坐标系中。\n\n本构关系在晶体坐标系中定义，其中刚度张量 $C^{crys}$ 具有其最简单的形式，由常数 $C_{11}、C_{12}、C_{44}$ 指定。\n$$ \\sigma'_{pq} = C^{crys}_{pqrs} \\varepsilon'_{rs} $$\n为了找到实验室坐标系中的本构关系 $\\sigma_{ij} = C^{lab}_{ijkl} \\varepsilon_{kl}$，我们将变换规则代入晶体坐标系的方程中：\n$$ R_{pi} R_{qj} \\sigma_{ij} = C^{crys}_{pqrs} (R_{rk} R_{sl} \\varepsilon_{kl}) $$\n为了分离出 $\\sigma_{ab}$，我们用旋转矩阵的逆（转置）矩阵进行左乘，利用正交性 $R_{ap} R_{pi} = \\delta_{ai}$：\n$$ (R_{ap} R_{bq}) (R_{pi} R_{qj} \\sigma_{ij}) = (R_{ap} R_{bq}) C^{crys}_{pqrs} R_{rk} R_{sl} \\varepsilon_{kl} $$\n$$ \\delta_{ai} \\delta_{bj} \\sigma_{ij} = (R_{ap} R_{bq} R_{rk} R_{sl}) C^{crys}_{pqrs} \\varepsilon_{kl} $$\n$$ \\sigma_{ab} = (R_{ap} R_{bq} R_{rk} R_{sl} C^{crys}_{pqrs}) \\varepsilon_{kl} $$\n通过与 $\\sigma_{ab} = C^{lab}_{abkl} \\varepsilon_{kl}$ 进行比较，我们确定实验室坐标系刚度张量的分量为：\n$$ C^{lab}_{abkl} = R_{ap} R_{bq} R_{rk} R_{sl} C^{crys}_{pqrs} $$\n这是四阶刚度张量的变换法则。正确识别矩阵 $R$ 至关重要。问题描述了施加于晶片的一系列旋转。这对应于晶体的主动旋转。如果晶轴通过矩阵 $M$ 进行旋转，那么从实验室坐标系到新晶体坐标系的向量分量变换矩阵是 $R=M^{-1}=M^T$。然而，将张量分量从晶体坐标系转换到实验室坐标系更为直接。设 $M$ 是将向量分量从晶体的局部坐标系转换到实验室坐标系的旋转矩阵。那么刚度张量分量的变换如下：\n$$ C^{lab}_{pqrs} = M_{pi} M_{qj} M_{rk} M_{sl} C^{crys}_{ijkl} $$\n这就是将要实现的方程。\n\n### 2. 立方刚度张量的构建\n\n对于具有立方对称性的晶体，其刚度张量 $C_{ijkl}$ 只有三个独立的非零分量：$C_{1111}$、$C_{1122}$ 和 $C_{1212}$。根据给定的常数 $C_{11}$、$C_{12}$ 和 $C_{44}$，可以构建完整的张量。立方刚度张量的一个通用且稳健的表示方法如下：\n$$ C_{ijkl} = C_{12} \\delta_{ij} \\delta_{kl} + C_{44} (\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + (C_{11} - C_{12} - 2C_{44}) \\sum_{m=1}^{3} \\delta_{im} \\delta_{jm} \\delta_{km} \\delta_{lm} $$\n其中 $\\delta_{ij}$ 是克罗内克δ。求和项仅对角向分量如 $C_{mmmm} = C_{1111}, C_{2222}, C_{3333}$ 非零。该公式正确地生成了张量的所有分量，例如：\n- $C_{1111} = C_{12} + 2C_{44} + (C_{11} - C_{12} - 2C_{44}) = C_{11}$\n- $C_{1122} = C_{12} + 0 + 0 = C_{12}$\n- $C_{1212} = 0 + C_{44}(\\delta_{11}\\delta_{22} + \\delta_{12}\\delta_{21}) + 0 = C_{44}$\n这个构造将通过遍历 $3 \\times 3 \\times 3 \\times 3$ 张量的所有 $3^4 = 81$ 个分量，并根据索引 $i, j, k, l$ 赋值来实现。\n\n### 3. 旋转矩阵的复合\n\n问题指定了围绕固定的实验室坐标轴 $\\hat{x}, \\hat{y}, \\hat{z}$ 的旋转序列。对于按顺序施加的旋转序列 $M_1, M_2, \\dots, M_n$，最终的方向由复合旋转矩阵 $M_{total}$ 描述：\n$$ M_{total} = M_n \\dots M_2 M_1 $$\n围绕标准轴旋转角度 $\\theta$ 的旋转矩阵为：\n$$ R_x(\\theta) = \\begin{pmatrix} 1  0  0 \\\\ 0  \\cos\\theta  -\\sin\\theta \\\\ 0  \\sin\\theta  \\cos\\theta \\end{pmatrix} $$\n$$ R_y(\\theta) = \\begin{pmatrix} \\cos\\theta  0  \\sin\\theta \\\\ 0  1  0 \\\\ -\\sin\\theta  0  \\cos\\theta \\end{pmatrix} $$\n$$ R_z(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{pmatrix} $$\n以度为单位提供的角度将被转换为弧度以用于三角函数：$\\theta_{rad} = \\theta_{deg} \\times \\frac{\\pi}{180}$。复合矩阵 $M_{total}$ 将作为张量变换方程中的变换矩阵 $M$。\n\n### 4. 计算策略\n\n该解决方案将使用 Python 的 NumPy 库实现。\n1.  **刚度张量构建：** 一个 `build_stiffness_tensor` 函数将使用提供的 $C_{11}, C_{12}, C_{44}$ 值和第2节中的公式创建 $3 \\times 3 \\times 3 \\times 3$ 的 NumPy 数组 $C^{crys}_{ijkl}$。\n2.  **旋转矩阵计算：** 一个 `get_rotation_matrix` 函数将为给定的轴和角度（以度为单位）生成相应的 $3 \\times 3$ 旋转矩阵。\n3.  **变换循环：** 对每个测试用例：\n    a. 初始化总旋转矩阵 $M$ 为 $3 \\times 3$ 的单位矩阵。\n    b. 对于指定序列中的每次旋转，计算基本旋转矩阵并通过左乘更新总旋转矩阵：$M \\leftarrow M_{step} \\cdot M$。\n    c. 使用 `numpy.einsum` 将最终的变换矩阵 $M$ 应用于 $C^{crys}$ 以计算 $C^{lab}$，该函数对于此类张量缩并非常高效：\n    `C_lab = np.einsum('pi,qj,rk,sl,ijkl-pqrs', M, M, M, M, C_crys)`\n4.  **结果提取：** 计算出 $C^{lab}$ 后，使用基于0的索引提取所需分量：$C'_{1111} \\equiv C^{lab}[0,0,0,0]$，$C'_{1122} \\equiv C^{lab}[0,0,1,1]$，以及 $C'_{1212} \\equiv C^{lab}[0,1,0,1]$。\n5.  **输出格式化：** 提取的值将被四舍五入到六位小数，并格式化为指定的列表的列表字符串表示。基准用例（无旋转）可作为一个验证性检查，因为它应返回原始的弹性常数。绕 $\\hat{z}$ 轴旋转 $90^\\circ$ 的用例测试了实现对立方对称性的处理，因为张量必须保持不变。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_stiffness_tensor(c11, c12, c44):\n    \"\"\"\n    Builds the 4th-order stiffness tensor for a cubic crystal.\n    \n    Args:\n        c11 (float): C11 elastic constant in GPa.\n        c12 (float): C12 elastic constant in GPa.\n        c44 (float): C44 elastic constant in GPa.\n\n    Returns:\n        np.ndarray: A 3x3x3x3 numpy array representing the stiffness tensor C_ijkl.\n    \"\"\"\n    C = np.zeros((3, 3, 3, 3))\n    \n    # Anisotropy factor\n    anisotropy_factor = c11 - c12 - 2 * c44\n    \n    # Use delta function for a more direct construction\n    delta = np.identity(3)\n    \n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                for l in range(3):\n                    C[i, j, k, l] = c12 * delta[i, j] * delta[k, l] + \\\n                                    c44 * (delta[i, k] * delta[j, l] + delta[i, l] * delta[j, k])\n                    if i == j == k == l:\n                         C[i, j, k, l] += anisotropy_factor\n    return C\n\n\ndef get_rotation_matrix(axis, angle_deg):\n    \"\"\"\n    Generates a 3x3 rotation matrix for a given axis and angle.\n    \n    Args:\n        axis (str): The axis of rotation ('x', 'y', or 'z').\n        angle_deg (float): The angle of rotation in degrees.\n    \n    Returns:\n        np.ndarray: The 3x3 rotation matrix.\n    \"\"\"\n    angle_rad = np.deg2rad(angle_deg)\n    c = np.cos(angle_rad)\n    s = np.sin(angle_rad)\n    \n    if axis == 'x':\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n    elif axis == 'y':\n        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n    elif axis == 'z':\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    else:\n        raise ValueError(\"Invalid rotation axis. Must be 'x', 'y', or 'z'.\")\n\ndef transform_stiffness_tensor(C_crys, M):\n    \"\"\"\n    Transforms the stiffness tensor from the crystal to the lab frame.\n    \n    Args:\n        C_crys (np.ndarray): The 3x3x3x3 stiffness tensor in the crystal frame.\n        M (np.ndarray): The 3x3 rotation matrix from crystal to lab frame.\n    \n    Returns:\n        np.ndarray: The 3x3x3x3 stiffness tensor in the lab frame.\n    \"\"\"\n    # C'_pqrs = M_pi * M_qj * M_rk * M_sl * C_ijkl\n    C_lab = np.einsum('pi,qj,rk,sl,ijkl-pqrs', M, M, M, M, C_crys, optimize=True)\n    return C_lab\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Silicon stiffness constants in GPa\n    C11 = 165.7\n    C12 = 63.9\n    C44 = 79.6\n\n    # Build the stiffness tensor in the crystal frame\n    C_crystal = build_stiffness_tensor(C11, C12, C44)\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'A': [],\n        'B': [('z', 90.0)],\n        'C': [('z', 45.0)],\n        'D': [('z', 30.0), ('x', 180.0)]\n    }\n\n    results = []\n\n    # Process each test case in order A, B, C, D\n    for case_id in sorted(test_cases.keys()):\n        rotations = test_cases[case_id]\n        \n        # Start with identity matrix for the total rotation\n        M_total = np.identity(3)\n        \n        # Compose rotations\n        for axis, angle in rotations:\n            M_step = get_rotation_matrix(axis, angle)\n            # The new rotation is applied to the already rotated object,\n            # so we left-multiply. M_total = M_n * ... * M_1\n            M_total = np.dot(M_step, M_total)\n\n        # Transform the stiffness tensor\n        C_lab = transform_stiffness_tensor(C_crystal, M_total)\n\n        # Extract required components (using 0-based indexing)\n        c_1111 = C_lab[0, 0, 0, 0]\n        c_1122 = C_lab[0, 0, 1, 1]\n        c_1212 = C_lab[0, 1, 0, 1]\n\n        # Round to 6 decimal places and store\n        case_results = [\n            round(c_1111, 6),\n            round(c_1122, 6),\n            round(c_1212, 6)\n        ]\n        results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # str() includes spaces, so we remove them to match the required format.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "这项最后的练习将前面的概念整合到一个动态的工艺流程仿真中。它要求您开发一种算法，追踪应力在不同热处理步骤中的演变，并计算其对关键电学性能——电子迁移率——的最终影响 ()。这项练习概括了本主题的核心目标：集成应力建模以预测器件性能。",
            "id": "4132784",
            "problem": "您的任务是实现一个有理论依据的方法，在工艺流程模拟中跨离散工艺步骤传递与应力相关的电子迁移率状态变量，并使用施加受控应力的测试结构来验证该方法。该问题必须通过从半导体工艺建模和连续介质力学的第一性原理及公认模型出发进行推导，然后设计一种算法来跨步骤传播状态。\n\n从以下基本原理和事实开始：\n\n1. 连续介质热激活弛豫：在温度为 $T$、持续时间为 $\\Delta t$ 的等温步骤下，内部单轴残余应力状态 $\\sigma_{x}(t)$ 会根据符合麦克斯韦型弛豫的一阶线性常微分方程，向外部施加的受控单轴应力 $\\sigma_{\\mathrm{app}}$ 演化，\n$$\n\\frac{d \\sigma_{x}}{dt} = - \\frac{\\sigma_{x} - \\sigma_{\\mathrm{app}}}{\\tau(T)},\n$$\n其中弛豫时间遵循阿伦尼乌斯动力学，\n$$\n\\tau(T) = \\tau_{0} \\exp\\!\\left(\\frac{E_{a}}{k_{B} T}\\right),\n$$\n$E_{a}$ 是活化能，$k_{B}$ 是玻尔兹曼常数，$\\tau_{0}$ 是指前因子。\n\n2. 各向同性张量不变量和小应力迁移率扰动：对于小的弹性应力，标量电子迁移率 $\\mu_{n}$ 是应力的各向同性函数，因此可以在柯西应力张量 $\\boldsymbol{\\sigma}$ 的不变量上展开到一阶。对于与沟道方向（$x$ 轴）对齐的单轴应力状态 $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$，对标量输运系数有一阶影响的两个独立不变量是静水应力 $\\sigma_{h} = \\mathrm{tr}(\\boldsymbol{\\sigma})/3$ 和偏应力张量第二不变量的平方根 $\\sqrt{J_{2}}$，其中 $J_{2} = \\tfrac{1}{2}\\,\\mathbf{s}:\\mathbf{s}$ 且 $\\mathbf{s} = \\boldsymbol{\\sigma} - \\sigma_{h}\\mathbf{I}$。对于单轴情况，$\\sqrt{J_{2}} = |\\sigma_{x}|/\\sqrt{3}$。假设电子迁移率关于零应力的一阶线性化使用这些不变量，并带有待定的常系数。\n\n3. 单位：所有量必须采用国际单位制 (SI)。具体而言，应力单位为帕斯卡 (Pa)，温度单位为开尔文 (K)，时间单位为秒 (s)，迁移率单位为平方米/伏特·秒 (m$^{2}$/V·s)。如果 $E_{a}$ 以电子伏特 (eV) 为单位，则玻尔兹曼常数 $k_{B}$ 必须使用电子伏特/开尔文 (eV/K) 作为单位。\n\n任务要求：\n\na) 针对一个工艺步骤，推导出一个解析的、逐步骤的 $\\sigma_{x}$ 更新法则，该法则能够在给定恒定 $T$、$\\Delta t$ 和 $\\sigma_{\\mathrm{app}}$ 的情况下，将状态从步骤开始传播到结束。该法则的形式应适用于稳定的数值实现和多步骤的组合。\n\nb) 基于不变量展开的前提，使用对应于静水压力分量和畸变分量的两个系数，推导电子迁移率 $\\mu_{n}$ 作为单轴应力 $\\sigma_{x}$ 函数的一阶小应力关系。\n\nc) 设计一种算法，该算法为每个测试结构在流程开始时初始化内部应力状态 $\\sigma_{x}$，然后在工艺步骤序列中应用逐步骤更新法则以获得最终应力，最后根据推导出的基于不变量的表达式计算最终电子迁移率 $\\mu_{n}$。除了通过物理弛豫动力学外，严格地将状态从一个步骤传递到下一个步骤，不丢失历史信息。\n\nd) 使用受控应力测试结构进行验证：使用提供的测试套件，其中每个测试结构在指定的温度和持续时间下经受已知的单轴外加应力序列 $\\sigma_{\\mathrm{app}}$。受控的应力值作为验证激励；您的程序必须计算每种情况下的最终电子迁移率。\n\n使用的数值数据和常数：\n\n- 零应力下的参考电子迁移率：$\\mu_{n,0} = 0.045$ m$^{2}$/V·s。\n- 线性化不变量模型中电子的静水压力和畸变系数：$a_{h}^{(n)} = 1.0\\times 10^{-11}$ Pa$^{-1}$ 和 $a_{d}^{(n)} = 2.0\\times 10^{-11}$ Pa$^{-1}$。\n- 阿伦尼乌斯参数：$\\tau_{0} = 1.0\\times 10^{-7}$ s, $E_{a} = 1.5$ eV, $k_{B} = 8.617333262145\\times 10^{-5}$ eV/K。\n- 对于单轴应力 $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$，在评估迁移率扰动时必须使用 $\\sigma_{h} = \\sigma_{x}/3$ 和 $\\sqrt{J_{2}} = |\\sigma_{x}|/\\sqrt{3}$。\n\n测试套件：\n\n每个测试案例由初始内部单轴应力 $\\sigma_{x}(0)$（单位 Pa）和一系列工艺步骤定义，每个步骤以三元组 $(T, \\Delta t, \\sigma_{\\mathrm{app}})$ 的形式给出，其中 $T$ 单位为 K，$\\Delta t$ 单位为 s，$\\sigma_{\\mathrm{app}}$ 单位为 Pa。\n\n- 案例 1 (理想路径，中等弛豫下的拉伸偏置):\n  - 初始 $\\sigma_{x}(0) = 0$ Pa。\n  - 步骤：\n    1) $(800,\\ 1200,\\ +2.0\\times 10^{8})$,\n    2) $(300,\\ 600,\\ +2.0\\times 10^{8})$。\n\n- 案例 2 (边界情况，全程施加零应力):\n  - 初始 $\\sigma_{x}(0) = 0$ Pa。\n  - 步骤：\n    1) $(900,\\ 3600,\\ 0)$,\n    2) $(300,\\ 100,\\ 0)$。\n\n- 案例 3 (从压缩初始状态向拉伸状态的快速高温弛豫):\n  - 初始 $\\sigma_{x}(0) = -1.0\\times 10^{8}$ Pa。\n  - 步骤：\n    1) $(1100,\\ 100,\\ +3.0\\times 10^{8})$,\n    2) $(1100,\\ 1000,\\ +3.0\\times 10^{8})$。\n\n- 案例 4 (恒温下部分追踪的交替拉伸/压缩步骤):\n  - 初始 $\\sigma_{x}(0) = 0$ Pa。\n  - 步骤：\n    1) $(800,\\ 200,\\ +2.0\\times 10^{8})$,\n    2) $(800,\\ 200,\\ -2.0\\times 10^{8})$,\n    3) $(800,\\ 200,\\ +2.0\\times 10^{8})$。\n\n所需输出及单位：\n\n- 对于每个测试案例，计算最后一个步骤结束时的最终电子迁移率 $\\mu_{n}$，单位为 m$^{2}$/V·s，四舍五入到八位小数。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[0.04500000,0.04512345,0.04498765,0.04567890]\"）。\n\n角度单位不适用。所有结果均以十进制数表示，不带任何百分号。\n\n您的最终程序必须是自包含的，并且可以按原样运行，不得读取任何输入。它必须实现上述基于物理的推导和算法，以生成指定测试套件所需的输出。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于连续介质力学和半导体物理的既定原理，在数学上是适定的，并提供了一套自包含且明确的数据和要求。因此，我们可以着手解决。\n\n解决方案按要求分为四个部分：a) 应力更新法则的推导，b) 迁移率模型的推导，c) 计算算法的构建，以及 d) 对指定测试案例的应用。\n\na) 应力更新法则的推导\n\n内部单轴应力 $\\sigma_{x}$ 的演化由以下一阶线性常微分方程控制：\n$$\n\\frac{d \\sigma_{x}}{dt} = - \\frac{\\sigma_{x} - \\sigma_{\\mathrm{app}}}{\\tau(T)}\n$$\n对于单个工艺步骤，温度 $T$ 和外部施加的应力 $\\sigma_{\\mathrm{app}}$ 是恒定的。因此，弛豫时间 $\\tau(T)$ 在该步骤的持续时间 $\\Delta t$ 内也是恒定的。我们可以将方程重写为：\n$$\n\\frac{d \\sigma_{x}}{dt} + \\frac{1}{\\tau} \\sigma_{x} = \\frac{\\sigma_{\\mathrm{app}}}{\\tau}\n$$\n这是一个标准的非齐次线性一阶微分方程。其解可以通过积分因子 $I(t) = \\exp(\\int \\frac{dt}{\\tau}) = \\exp(t/\\tau)$ 求得。方程两边乘以 $I(t)$ 得：\n$$\n\\exp(t/\\tau) \\frac{d \\sigma_{x}}{dt} + \\frac{1}{\\tau} \\exp(t/\\tau) \\sigma_{x} = \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau)\n$$\n左侧是乘积的导数，即 $\\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right)$。因此：\n$$\n\\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right) = \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau)\n$$\n我们在时间区间从 $t=0$ 到 $t=\\Delta t$ 上积分，这对应于工艺步骤的开始和结束。设步骤开始时的应力为 $\\sigma_{x, \\text{start}}$。\n$$\n\\int_{0}^{\\Delta t} \\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right) dt = \\int_{0}^{\\Delta t} \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau) dt\n$$\n$$\n\\left[ \\sigma_{x}(t) \\exp(t/\\tau) \\right]_{0}^{\\Delta t} = \\left[ \\sigma_{\\mathrm{app}} \\exp(t/\\tau) \\right]_{0}^{\\Delta t}\n$$\n$$\n\\sigma_{x}(\\Delta t) \\exp(\\Delta t/\\tau) - \\sigma_{x}(0) \\exp(0) = \\sigma_{\\mathrm{app}} \\exp(\\Delta t/\\tau) - \\sigma_{\\mathrm{app}} \\exp(0)\n$$\n令 $\\sigma_{x, \\text{end}} = \\sigma_{x}(\\Delta t)$ 和 $\\sigma_{x, \\text{start}} = \\sigma_{x}(0)$，我们有：\n$$\n\\sigma_{x, \\text{end}} \\exp(\\Delta t/\\tau) - \\sigma_{x, \\text{start}} = \\sigma_{\\mathrm{app}} (\\exp(\\Delta t/\\tau) - 1)\n$$\n两边乘以 $\\exp(-\\Delta t/\\tau)$ 来求解 $\\sigma_{x, \\text{end}}$：\n$$\n\\sigma_{x, \\text{end}} = \\sigma_{x, \\text{start}} \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right) + \\sigma_{\\mathrm{app}} \\left(1 - \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right)\\right)\n$$\n这个方程可以重排成一种数值稳定且物理直观的形式。它将最终应力描述为初始应力和施加应力的凸组合，由指数衰减因子加权。一个更常见的形式是：\n$$\n\\sigma_{x, \\text{end}} = \\sigma_{\\mathrm{app}} + (\\sigma_{x, \\text{start}} - \\sigma_{\\mathrm{app}}) \\exp\\left(-\\frac{\\Delta t}{\\tau(T)}\\right)\n$$\n在这里，弛豫时间 $\\tau(T)$ 遵循阿伦尼乌斯定律：\n$$\n\\tau(T) = \\tau_{0} \\exp\\left(\\frac{E_{a}}{k_{B} T}\\right)\n$$\n其中常数 $\\tau_0 = 1.0\\times 10^{-7}$ s, $E_a = 1.5$ eV, and $k_B = 8.617333262145\\times 10^{-5}$ eV/K。这个更新法则用于在单个离散工艺步骤中传播应力状态。\n\nb) 迁移率模型的推导\n\n问题假定，对于小应力，标量电子迁移率 $\\mu_{n}$ 可以表示为柯西应力张量 $\\boldsymbol{\\sigma}$ 不变量的一阶展开。所选的不变量是静水应力 $\\sigma_{h}$ 和偏应力张量第二不变量的平方根 $\\sqrt{J_2}$。迁移率相对变化的一阶通用模型为：\n$$\n\\frac{\\mu_{n} - \\mu_{n,0}}{\\mu_{n,0}} = a_{h}^{(n)} \\sigma_{h} + a_{d}^{(n)} \\sqrt{J_{2}}\n$$\n其中 $\\mu_{n,0}$ 是零应力下的参考迁移率，$a_{h}^{(n)}$ 和 $a_{d}^{(n)}$ 是静水压力和畸变压阻迁移率系数，给定为 $a_{h}^{(n)} = 1.0\\times 10^{-11}$ Pa$^{-1}$ 和 $a_{d}^{(n)} = 2.0\\times 10^{-11}$ Pa$^{-1}$。\n\n这给出了迁移率表达式：\n$$\n\\mu_{n}(\\boldsymbol{\\sigma}) = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\sigma_{h} + a_{d}^{(n)} \\sqrt{J_{2}} \\right)\n$$\n我们现在必须为指定的单轴应力状态 $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$ 计算不变量。\n\n静水应力是应力张量迹的三分之一：\n$$\n\\sigma_{h} = \\frac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3} (\\sigma_{x} + 0 + 0) = \\frac{\\sigma_{x}}{3}\n$$\n偏应力张量 $\\mathbf{s}$ 定义为 $\\mathbf{s} = \\boldsymbol{\\sigma} - \\sigma_{h}\\mathbf{I}$：\n$$\n\\mathbf{s} = \\begin{pmatrix} \\sigma_{x}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} - \\frac{\\sigma_{x}}{3} \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2\\sigma_{x}/3  0  0 \\\\ 0  -\\sigma_{x}/3  0 \\\\ 0  0  -\\sigma_{x}/3 \\end{pmatrix}\n$$\n第二不变量 $J_2$ 由 $J_2 = \\frac{1}{2} \\mathbf{s}:\\mathbf{s} = \\frac{1}{2}\\sum_{i,j} s_{ij}s_{ji}$ 给出。对于对角张量，这简化为 $J_2 = \\frac{1}{2}\\sum_{i} s_{ii}^2$：\n$$\nJ_2 = \\frac{1}{2} \\left[ \\left(\\frac{2\\sigma_{x}}{3}\\right)^2 + \\left(-\\frac{\\sigma_{x}}{3}\\right)^2 + \\left(-\\frac{\\sigma_{x}}{3}\\right)^2 \\right] = \\frac{1}{2} \\left( \\frac{4\\sigma_{x}^2}{9} + \\frac{\\sigma_{x}^2}{9} + \\frac{\\sigma_{x}^2}{9} \\right) = \\frac{1}{2} \\left( \\frac{6\\sigma_{x}^2}{9} \\right) = \\frac{\\sigma_{x}^2}{3}\n$$\n因此，该不变量的平方根是：\n$$\n\\sqrt{J_2} = \\sqrt{\\frac{\\sigma_{x}^2}{3}} = \\frac{|\\sigma_{x}|}{\\sqrt{3}}\n$$\n这两个不变量与问题陈述中提供的值一致。将这些表达式代入迁移率方程，得到电子迁移率作为单轴应力 $\\sigma_x$ 函数的最终模型：\n$$\n\\mu_{n}(\\sigma_{x}) = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\frac{\\sigma_{x}}{3} + a_{d}^{(n)} \\frac{|\\sigma_{x}|}{\\sqrt{3}} \\right)\n$$\n该表达式将用于从最终应力状态计算最终迁移率。\n\nc) 算法设计\n\n为给定测试案例计算最终电子迁移率的算法如下：\n1.  用提供的初始应力 $\\sigma_{x}(0)$ 初始化内部应力状态变量 $\\sigma_{x,\\text{current}}$。\n2.  遍历工艺步骤序列，其中每个步骤 $i$ 由一个元组 $(T_i, \\Delta t_i, \\sigma_{\\mathrm{app}, i})$ 定义。\n3.  对于每个步骤 $i$：\n    a. 获取步骤参数 $T_i$、$\\Delta t_i$ 和 $\\sigma_{\\mathrm{app}, i}$。\n    b. 使用阿伦尼乌斯方程计算弛豫时间 $\\tau(T_i)$：$\\tau(T_i) = \\tau_{0} \\exp(E_{a} / (k_{B} T_i))$。\n    c. 应用推导出的更新法则来找到步骤结束时的应力 $\\sigma_{x, \\text{end}}$。此步骤的初始应力是上一步的最终应力，即 $\\sigma_{x, \\text{current}}$。\n       $$ \\sigma_{x, \\text{end}} = \\sigma_{\\mathrm{app}, i} + (\\sigma_{x, \\text{current}} - \\sigma_{\\mathrm{app}, i}) \\exp\\left(-\\frac{\\Delta t_i}{\\tau(T_i)}\\right) $$\n    d. 更新状态变量以进行下一次迭代：$\\sigma_{x,\\text{current}} \\leftarrow \\sigma_{x, \\text{end}}$。\n4.  处理完所有步骤后，最终的内部应力为 $\\sigma_{x,\\text{final}} = \\sigma_{x,\\text{current}}$。\n5.  使用最终应力 $\\sigma_{x,\\text{final}}$，通过推导出的迁移率模型计算最终电子迁移率 $\\mu_{n,\\text{final}}$：\n    $$ \\mu_{n,\\text{final}} = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\frac{\\sigma_{x,\\text{final}}}{3} + a_{d}^{(n)} \\frac{|\\sigma_{x,\\text{final}}|}{\\sqrt{3}} \\right) $$\n6.  然后将结果 $\\mu_{n,\\text{final}}$ 格式化为所需的精度。\n\nd) 实现与验证\n\n上述算法在 Python 程序中实现。该程序按顺序处理四个指定的测试案例。对于每个案例，它初始化应力，迭代应用逐步骤更新法则以在整个工艺流程中传播应力状态，并最终从最终应力计算电子迁移率。问题陈述中提供的数值常数（$\\mu_{n,0} = 0.045$ m$^2$/V·s, $a_{h}^{(n)}$, $a_{d}^{(n)}$, $\\tau_{0}$, $E_{a}$, $k_{B}$）直接用于计算。输出是每个测试案例的最终迁移率值的列表，四舍五入到八位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of propagating stress state and calculating final electron mobility.\n    \"\"\"\n    \n    # Numerical data and constants in SI units\n    MU_N0 = 0.045  # Reference electron mobility [m^2/V·s]\n    A_H_N = 1.0e-11  # Hydrostatic piezomobility coefficient [Pa^-1]\n    A_D_N = 2.0e-11  # Distortional piezomobility coefficient [Pa^-1]\n    TAU0 = 1.0e-7    # Arrhenius pre-exponential factor [s]\n    EA = 1.5         # Activation energy [eV]\n    KB = 8.617333262145e-5  # Boltzmann constant [eV/K]\n\n    # Test suite from the problem statement\n    # Each case: (initial_sigma_x_0, list of steps)\n    # Each step: (Temperature T [K], duration delta_t [s], applied_stress sigma_app [Pa])\n    test_cases = [\n        # Case 1\n        (0.0, [\n            (800.0, 1200.0, 2.0e8),\n            (300.0, 600.0, 2.0e8),\n        ]),\n        # Case 2\n        (0.0, [\n            (900.0, 3600.0, 0.0),\n            (300.0, 100.0, 0.0),\n        ]),\n        # Case 3\n        (-1.0e8, [\n            (1100.0, 100.0, 3.0e8),\n            (1100.0, 1000.0, 3.0e8),\n        ]),\n        # Case 4\n        (0.0, [\n            (800.0, 200.0, 2.0e8),\n            (800.0, 200.0, -2.0e8),\n            (800.0, 200.0, 2.0e8),\n        ]),\n    ]\n\n    results = []\n    \n    for initial_sigma, steps in test_cases:\n        current_sigma_x = initial_sigma\n        \n        # Propagate stress through the process steps\n        for T, delta_t, sigma_app in steps:\n            # Calculate relaxation time using Arrhenius law\n            # Note: T must be  0\n            if T == 0:\n                # In a physically realistic scenario, T  0.\n                # If T - 0, tau - infinity, stress is frozen.\n                # exp(-delta_t / tau) - 1.\n                decay_factor = 1.0\n            else:\n                tau = TAU0 * np.exp(EA / (KB * T))\n                # Protect against underflow/overflow if delta_t/tau is very large\n                # For large x, exp(-x) - 0. Let's use numpy's robust exp.\n                decay_factor = np.exp(-delta_t / tau)\n\n            # Update stress using the derived analytical solution\n            # sigma_end = sigma_app + (sigma_start - sigma_app) * exp(-delta_t / tau)\n            current_sigma_x = sigma_app + (current_sigma_x - sigma_app) * decay_factor\n\n        final_sigma_x = current_sigma_x\n\n        # Calculate final electron mobility using the derived invariant-based model\n        # mu_n = mu_n0 * (1 + a_h * sigma_x / 3 + a_d * |sigma_x| / sqrt(3))\n        mobility_change = A_H_N * final_sigma_x / 3.0 + A_D_N * np.abs(final_sigma_x) / np.sqrt(3.0)\n        final_mobility = MU_N0 * (1.0 + mobility_change)\n        \n        results.append(f\"{final_mobility:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}