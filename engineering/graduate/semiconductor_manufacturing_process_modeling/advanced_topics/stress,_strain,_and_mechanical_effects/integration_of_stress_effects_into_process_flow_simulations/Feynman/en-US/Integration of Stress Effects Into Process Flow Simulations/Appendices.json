{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in any stress simulation is to have reliable input data, often derived from experimental measurements. This practice guides you through translating a common metrology output—wafer curvature—into the intrinsic stress of a deposited thin film using the celebrated Stoney equation, a cornerstone of thin-film mechanics . You will not only derive this fundamental relationship but also rigorously quantify the uncertainty in your calculated stress, a critical skill for any modeling effort.",
            "id": "4132811",
            "problem": "A microelectronic process flow simulation requires the equi-biaxial thin-film stress to parameterize stress-dependent diffusion and pattern deformation in subsequent thermal steps. After a deposition step, a circular silicon wafer was measured to have a uniform curvature. Treat the wafer as an isotropic, homogeneous plate and the deposited film as a uniform, equi-biaxial stressed layer much thinner than the substrate. Starting only from linear elasticity and classical isotropic plate bending, derive the relation between the film stress and the measured wafer curvature.\n\nAssume the following measurements and material parameters for a crystalline silicon substrate and a silicon nitride film:\n- Measured curvature (defined as $k = 1/R$ with $R$ the radius of curvature): $k = 1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}$ with standard uncertainty $u_k = 5.00 \\times 10^{-6} \\,\\mathrm{m}^{-1}$.\n- Substrate thickness: $t_s = 775 \\,\\mu\\mathrm{m}$ with standard uncertainty $u_{t_s} = 1.00 \\,\\mu\\mathrm{m}$.\n- Film thickness: $t_f = 100 \\,\\mathrm{nm}$ with standard uncertainty $u_{t_f} = 0.50 \\,\\mathrm{nm}$.\n- Substrate Young’s modulus: $E_s = 130 \\,\\mathrm{GPa}$ with standard uncertainty $u_{E_s} = 1.00 \\,\\mathrm{GPa}$.\n- Substrate Poisson’s ratio: $\\nu_s = 0.28$ with standard uncertainty $u_{\\nu_s} = 0.010$.\n\nUsing the law of propagation of uncertainty consistent with the Guide to the Expression of Uncertainty in Measurement (GUM), assume all input quantities are independent and uncorrelated, and propagate uncertainties to obtain the standard uncertainty in the computed film stress. State clearly any idealizations used.\n\nCompute the numerical value of the film stress and its standard uncertainty. Express both the stress and its uncertainty in megapascals. Round the stress to four significant figures and the standard uncertainty to two significant figures. The final answer must be presented as a pair of numbers corresponding to the stress and its standard uncertainty.",
            "solution": "The problem is scientifically grounded, well-posed, and objective. It presents a standard problem in thin-film mechanics with physically plausible parameters and asks for a derivation and calculation based on fundamental principles of linear elasticity and plate theory, followed by a standard uncertainty analysis. All necessary information is provided, and there are no contradictions or ambiguities. Therefore, the problem is deemed valid and a full solution will be provided.\n\nThe primary task is to derive the relationship between the intrinsic stress in a thin film, $\\sigma_f$, and the curvature, $k$, it induces in a much thicker substrate. This relationship is famously known as the Stoney equation. The derivation begins from the principles of classical plate theory and linear elasticity, under several key idealizations:\n1.  The film is significantly thinner than the substrate, i.e., $t_f \\ll t_s$. This allows us to neglect the flexural rigidity of the film itself and to assume the neutral bending plane of the composite structure lies at the mid-plane of the substrate.\n2.  The substrate is treated as a homogeneous, isotropic, linear elastic plate.\n3.  Deformations are small, consistent with the assumptions of linear elasticity.\n4.  The film possesses a uniform, equi-biaxial stress $\\sigma_f$.\n5.  The induced curvature $k$ is uniform across the wafer.\n\nLet the substrate have thickness $t_s$, Young's modulus $E_s$, and Poisson's ratio $\\nu_s$. Let the film have thickness $t_f$. The equi-biaxial stress $\\sigma_f$ in the film exerts a force per unit length, $F'$, on the substrate at the interface, given by $F' = \\sigma_f t_f$.\n\nThis force acts at the interface, but the substrate bends about its neutral axis, which, due to the $t_f \\ll t_s$ approximation, is located at the center of the substrate, a distance of $t_s/2$ from the interface. This force thus creates a bending moment per unit length, $M'$, in the substrate:\n$$\nM' = F' \\cdot \\frac{t_s}{2} = (\\sigma_f t_f) \\frac{t_s}{2}\n$$\nAccording to classical plate theory for an isotropic material under equi-biaxial bending ($k_x = k_y = k$), the relationship between the applied moment per unit length, $M'$, and the resulting curvature, $k$, is:\n$$\nM' = D k (1 + \\nu_s)\n$$\nwhere $D$ is the flexural rigidity of the plate, defined as:\n$$\nD = \\frac{E_s t_s^3}{12(1-\\nu_s^2)}\n$$\nSubstituting the expression for $D$ into the moment-curvature relation:\n$$\nM' = \\frac{E_s t_s^3}{12(1-\\nu_s^2)} k (1 + \\nu_s) = \\frac{E_s t_s^3 k (1 + \\nu_s)}{12(1-\\nu_s)(1+\\nu_s)} = \\frac{E_s t_s^3 k}{12(1-\\nu_s)}\n$$\nNow, we equate the two expressions for the bending moment $M'$:\n$$\n(\\sigma_f t_f) \\frac{t_s}{2} = \\frac{E_s t_s^3 k}{12(1-\\nu_s)}\n$$\nSolving for the film stress $\\sigma_f$, we obtain the Stoney equation:\n$$\n\\sigma_f = \\frac{E_s t_s^2 k}{6(1-\\nu_s)t_f}\n$$\nThis is the required relationship. A positive value of $\\sigma_f$ corresponds to tensile stress in the film, which causes the wafer to bend into a concave shape (positive curvature).\n\nNext, we compute the numerical value of the film stress using the provided data. All values are converted to base SI units (meters, Pascals).\n- $k = 1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}$\n- $t_s = 775 \\,\\mu\\mathrm{m} = 775 \\times 10^{-6} \\,\\mathrm{m}$\n- $t_f = 100 \\,\\mathrm{nm} = 100 \\times 10^{-9} \\,\\mathrm{m}$\n- $E_s = 130 \\,\\mathrm{GPa} = 130 \\times 10^9 \\,\\mathrm{Pa}$\n- $\\nu_s = 0.28$\n\nSubstituting these into the Stoney equation:\n$$\n\\sigma_f = \\frac{(130 \\times 10^9 \\,\\mathrm{Pa}) (775 \\times 10^{-6} \\,\\mathrm{m})^2 (1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1})}{6(1 - 0.28)(100 \\times 10^{-9} \\,\\mathrm{m})}\n$$\n$$\n\\sigma_f = \\frac{(1.30 \\times 10^{11}) \\cdot (6.00625 \\times 10^{-7}) \\cdot (1.000 \\times 10^{-3})}{6(0.72)(1.00 \\times 10^{-7})} \\,\\mathrm{Pa}\n$$\n$$\n\\sigma_f = \\frac{7.808125 \\times 10^1}{0.432} \\,\\mathrm{Pa} \\approx 1.807436 \\times 10^8 \\,\\mathrm{Pa} = 180.7436 \\,\\mathrm{MPa}\n$$\nRounding to four significant figures as requested, the film stress is $\\sigma_f \\approx 180.7 \\,\\mathrm{MPa}$.\n\nFinally, we propagate the uncertainties. The function is $\\sigma_f = \\sigma_f(E_s, t_s, k, t_f, \\nu_s)$. For independent input quantities, the square of the combined standard uncertainty, $u^2(\\sigma_f)$, is given by the law of propagation of uncertainty:\n$$\nu^2(\\sigma_f) = \\sum_i \\left( \\frac{\\partial \\sigma_f}{\\partial x_i} u_{x_i} \\right)^2\n$$\nIt is convenient to work with relative uncertainties. Dividing by $\\sigma_f^2$:\n$$\n\\left(\\frac{u(\\sigma_f)}{\\sigma_f}\\right)^2 = \\left(\\frac{u_{E_s}}{E_s}\\right)^2 + \\left(2\\frac{u_{t_s}}{t_s}\\right)^2 + \\left(\\frac{u_k}{k}\\right)^2 + \\left(\\frac{u_{t_f}}{t_f}\\right)^2 + \\left(\\frac{u_{\\nu_s}}{1-\\nu_s}\\right)^2\n$$\nWe calculate the squared relative uncertainties for each term:\n- $u_{E_s}/E_s = (1.00 \\,\\mathrm{GPa}) / (130 \\,\\mathrm{GPa}) = 1/130$. Term: $(1/130)^2 \\approx 5.917 \\times 10^{-5}$.\n- $u_{t_s}/t_s = (1.00 \\,\\mu\\mathrm{m}) / (775 \\,\\mu\\mathrm{m}) = 1/775$. Term: $(2 \\cdot 1/775)^2 \\approx 6.660 \\times 10^{-6}$.\n- $u_k/k = (5.00 \\times 10^{-6} \\,\\mathrm{m}^{-1}) / (1.000 \\times 10^{-3} \\,\\mathrm{m}^{-1}) = 0.005$. Term: $(0.005)^2 = 2.500 \\times 10^{-5}$.\n- $u_{t_f}/t_f = (0.50 \\,\\mathrm{nm}) / (100 \\,\\mathrm{nm}) = 0.005$. Term: $(0.005)^2 = 2.500 \\times 10^{-5}$.\n- $u_{\\nu_s}/(1-\\nu_s) = 0.010 / (1 - 0.28) = 0.010/0.72$. Term: $(0.010/0.72)^2 \\approx 1.929 \\times 10^{-4}$.\n\nSumming the terms:\n$$\n\\left(\\frac{u(\\sigma_f)}{\\sigma_f}\\right)^2 \\approx (5.917 + 0.666 + 2.500 + 2.500 + 19.29) \\times 10^{-5} = 3.0873 \\times 10^{-4}\n$$\nThe relative uncertainty is therefore:\n$$\n\\frac{u(\\sigma_f)}{\\sigma_f} = \\sqrt{3.0873 \\times 10^{-4}} \\approx 0.01757\n$$\nThe absolute standard uncertainty in the stress, $u(\\sigma_f)$, is:\n$$\nu(\\sigma_f) = \\sigma_f \\cdot \\frac{u(\\sigma_f)}{\\sigma_f} \\approx (180.7436 \\,\\mathrm{MPa}) \\cdot (0.01757) \\approx 3.176 \\,\\mathrm{MPa}\n$$\nRounding the standard uncertainty to two significant figures as requested gives $u(\\sigma_f) \\approx 3.2 \\,\\mathrm{MPa}$.\n\nThe computed film stress is $180.7 \\,\\mathrm{MPa}$ and its standard uncertainty is $3.2 \\,\\mathrm{MPa}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 180.7  3.2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "While isotropic models are useful, the single-crystal silicon at the heart of semiconductor devices is anisotropic, meaning its mechanical properties depend on direction. This exercise tackles the essential task of representing this anisotropy correctly by transforming the fourth-order stiffness tensor, $C_{ijkl}$, as the wafer is reoriented during the manufacturing flow . Mastering this tensor transformation is fundamental to building high-fidelity process models that respect the underlying crystal structure of the material.",
            "id": "4132792",
            "problem": "A single-crystal silicon wafer exhibits cubic anisotropic elasticity characterized by the fourth-order stiffness tensor $C_{ijkl}$ in the crystal reference frame aligned with the crystallographic axes $[100]$, $[010]$, and $[001]$. The wafer undergoes a manufacturing process flow in which it is mechanically reoriented between steps due to operations such as wafer rotation and dicing. A process flow simulation must incorporate the effects of these reorientations on the elastic response by transforming the stiffness tensor according to the wafer’s orientation at each step.\n\nYou are to implement a program that, for a specified sequence of rigid rotations applied to the wafer, computes the transformed stiffness tensor $C'_{pqrs}$ in the laboratory frame and reports selected components to be used by downstream process models.\n\nStart from the following fundamental base:\n- The Cauchy stress-strain relation in linear elasticity is $\\sigma_{ij} = C_{ijkl}\\,\\varepsilon_{kl}$, where $\\sigma_{ij}$ is the second-order Cauchy stress tensor, $\\varepsilon_{kl}$ is the second-order infinitesimal strain tensor, and $C_{ijkl}$ is the fourth-order stiffness tensor.\n- The components of a second-order tensor and a vector transform under a proper orthogonal change of basis by the rules that follow from linear algebra and rigid body kinematics. Use these principles to derive the transformation law for the fourth-order stiffness tensor when the wafer is rotated by a proper orthogonal rotation.\n\nAssumptions and data:\n- The crystal-frame stiffness for cubic silicon at room temperature is specified by the three independent constants: $C_{11} = 165.7$ Gigapascal (GPa), $C_{12} = 63.9$ GPa, and $C_{44} = 79.6$ GPa. Use these to construct $C_{ijkl}$ in the crystal coordinate system. The Kronecker delta is $\\delta_{ij}$, and the crystal axes are the canonical basis vectors $\\mathbf{e}_1 = (1,0,0)$, $\\mathbf{e}_2 = (0,1,0)$, $\\mathbf{e}_3 = (0,0,1)$.\n- All rotations are proper orthogonal with determinant $+1$, about the laboratory axes $\\hat{x}$, $\\hat{y}$, and $\\hat{z}$, and are applied in the given order. Use the right-hand rule for the sense of rotation.\n- Angle values are provided in degrees; you must use degrees and convert to radians internally if needed.\n- Report all stiffness components in gigapascals (GPa).\n\nTasks:\n1. Derive from the stated base the correct transformation of the fourth-order stiffness tensor under a rigid rotation, ensuring consistency with the transformation rules for second-order tensors.\n2. Implement a function to build the crystal-frame fourth-order stiffness tensor $C_{ijkl}$ for a cubic crystal from $C_{11}$, $C_{12}$, and $C_{44}$ using standard tensorial constructions with $\\delta_{ij}$ and the crystal axes.\n3. Implement rotation matrices for rotations about $\\hat{x}$, $\\hat{y}$, and $\\hat{z}$ by a given angle in degrees, and compose multiple rotations in the order given to form the total rotation from crystal to laboratory frame for each process step sequence.\n4. Apply the derived transformation to obtain the laboratory-frame stiffness $C'_{pqrs}$ and extract the components $C'_{1111}$, $C'_{1122}$, and $C'_{1212}$, expressed in Gigapascal (GPa). Round each reported value to six decimal places.\n\nTest suite:\nUse the following four test cases, each defined by a sequence of rotations applied in order to the wafer:\n- Case A (baseline, no rotation): an empty sequence.\n- Case B (four-fold symmetry check): a single rotation of $90$ degrees about $\\hat{z}$.\n- Case C (general in-plane rotation): a single rotation of $45$ degrees about $\\hat{z}$.\n- Case D (composite process reorientation): a rotation of $30$ degrees about $\\hat{z}$ followed by a rotation of $180$ degrees about $\\hat{x}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case is represented by a list of three floats $[C'_{1111}, C'_{1122}, C'_{1212}]$ in GPa, rounded to six decimal places. The overall output is thus a list of lists, in the order A, B, C, D. For example, the output should look like:\n[[a11,a12,a66],[b11,b12,b66],[c11,c12,c66],[d11,d12,d66]]\nwhere each symbol represents a float in GPa with six decimal places.",
            "solution": "The problem statement has been critically examined and is determined to be **valid**. It is scientifically grounded in the principles of continuum mechanics, is well-posed with a complete and consistent set of data, and is expressed in objective, formal language. The tasks are computationally tractable and relevant to the field of semiconductor process simulation.\n\n### 1. Derivation of the Fourth-Order Stiffness Tensor Transformation Law\n\nThe relationship between the Cauchy stress tensor $\\sigma$ and the infinitesimal strain tensor $\\varepsilon$ in a linear elastic material is given by the generalized Hooke's Law:\n$$ \\sigma_{ij} = C_{ijkl} \\varepsilon_{kl} $$\nwhere $C_{ijkl}$ is the fourth-order stiffness tensor. This equation is a tensorial relation, and its form must be invariant under a change of the coordinate system.\n\nLet us consider two Cartesian coordinate systems: the laboratory frame, with basis vectors $\\{\\mathbf{e}_p\\}$, and the crystal frame, with basis vectors $\\{\\mathbf{e'}_i\\}$. The crystal frame is obtained by a rigid rotation of the laboratory frame. Let the rotation be described by a proper orthogonal matrix $R$, whose components are $R_{ip} = \\mathbf{e'}_i \\cdot \\mathbf{e}_p$. The components of a vector $\\mathbf{v}$ in the two frames are related by $v'_i = R_{ij} v_j$.\n\nThe components of a second-order tensor, such as stress $\\sigma$ and strain $\\varepsilon$, transform according to the rule:\n$$ \\sigma'_{pq} = R_{pi} R_{qj} \\sigma_{ij} $$\n$$ \\varepsilon'_{rs} = R_{rk} R_{sl} \\varepsilon_{kl} $$\nHere, the primed components are in the crystal frame, and the unprimed components are in the laboratory frame.\n\nThe constitutive law is defined in the crystal frame, where the stiffness tensor $C^{crys}$ has its simplest form, specified by the constants $C_{11}, C_{12}, C_{44}$.\n$$ \\sigma'_{pq} = C^{crys}_{pqrs} \\varepsilon'_{rs} $$\nTo find the constitutive law in the laboratory frame, $\\sigma_{ij} = C^{lab}_{ijkl} \\varepsilon_{kl}$, we substitute the transformation rules into the crystal-frame equation:\n$$ R_{pi} R_{qj} \\sigma_{ij} = C^{crys}_{pqrs} (R_{rk} R_{sl} \\varepsilon_{kl}) $$\nTo isolate $\\sigma_{ab}$, we pre-multiply by the inverse (transpose) of the rotation matrix, using the orthogonality property $R_{ap} R_{pi} = \\delta_{ai}$:\n$$ (R_{ap} R_{bq}) (R_{pi} R_{qj} \\sigma_{ij}) = (R_{ap} R_{bq}) C^{crys}_{pqrs} R_{rk} R_{sl} \\varepsilon_{kl} $$\n$$ \\delta_{ai} \\delta_{bj} \\sigma_{ij} = (R_{ap} R_{bq} R_{rk} R_{sl}) C^{crys}_{pqrs} \\varepsilon_{kl} $$\n$$ \\sigma_{ab} = (R_{ap} R_{bq} R_{rk} R_{sl} C^{crys}_{pqrs}) \\varepsilon_{kl} $$\nBy comparing this with $\\sigma_{ab} = C^{lab}_{abkl} \\varepsilon_{kl}$, we identify the laboratory-frame stiffness tensor components as:\n$$ C^{lab}_{abkl} = R_{ap} R_{bq} R_{rk} R_{sl} C^{crys}_{pqrs} $$\nThis is the transformation law for the fourth-order stiffness tensor. It is crucial to correctly identify the matrix $R$. The problem describes a sequence of rotations applied to the wafer. This corresponds to an active rotation of the crystal. If the crystal axes are rotated by a matrix $M$, then the transformation matrix for vector components from the lab frame to the new crystal frame is $R=M^{-1}=M^T$. However, it is more direct to transform the tensor components from the crystal frame to the lab frame. Let $M$ be the rotation matrix that transforms a vector's components from the crystal's local frame to the lab frame. Then the stiffness tensor components transform as:\n$$ C^{lab}_{pqrs} = M_{pi} M_{qj} M_{rk} M_{sl} C^{crys}_{ijkl} $$\nThis is the equation that will be implemented.\n\n### 2. Construction of the Cubic Stiffness Tensor\n\nFor a crystal with cubic symmetry, the stiffness tensor $C_{ijkl}$ has only three independent non-zero components: $C_{1111}$, $C_{1122}$, and $C_{1212}$. In terms of the given constants $C_{11}$, $C_{12}$, and $C_{44}$, the full tensor can be constructed. A general and robust representation of the cubic stiffness tensor is given by:\n$$ C_{ijkl} = C_{12} \\delta_{ij} \\delta_{kl} + C_{44} (\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + (C_{11} - C_{12} - 2C_{44}) \\sum_{m=1}^{3} \\delta_{im} \\delta_{jm} \\delta_{km} \\delta_{lm} $$\nwhere $\\delta_{ij}$ is the Kronecker delta. The summation term is non-zero only for the diagonal components of the form $C_{mmmm} = C_{1111}, C_{2222}, C_{3333}$. This formula correctly generates all components of the tensor, for example:\n- $C_{1111} = C_{12} + 2C_{44} + (C_{11} - C_{12} - 2C_{44}) = C_{11}$\n- $C_{1122} = C_{12} + 0 + 0 = C_{12}$\n- $C_{1212} = 0 + C_{44}(\\delta_{11}\\delta_{22} + \\delta_{12}\\delta_{21}) + 0 = C_{44}$\nThis construction will be implemented by iterating through all $3^4 = 81$ components of the $3 \\times 3 \\times 3 \\times 3$ tensor and assigning values based on the indices $i, j, k, l$.\n\n### 3. Rotation Matrix Composition\n\nThe problem specifies sequences of rotations about the fixed laboratory axes $\\hat{x}, \\hat{y}, \\hat{z}$. For a sequence of rotations $M_1, M_2, \\dots, M_n$ applied in that order, the final orientation is described by the composite rotation matrix $M_{total}$:\n$$ M_{total} = M_n \\dots M_2 M_1 $$\nThe rotation matrices for rotations by an angle $\\theta$ about the canonical axes are:\n$$ R_x(\\theta) = \\begin{pmatrix} 1  0  0 \\\\ 0  \\cos\\theta  -\\sin\\theta \\\\ 0  \\sin\\theta  \\cos\\theta \\end{pmatrix} $$\n$$ R_y(\\theta) = \\begin{pmatrix} \\cos\\theta  0  \\sin\\theta \\\\ 0  1  0 \\\\ -\\sin\\theta  0  \\cos\\theta \\end{pmatrix} $$\n$$ R_z(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{pmatrix} $$\nAngles provided in degrees will be converted to radians for use in trigonometric functions: $\\theta_{rad} = \\theta_{deg} \\times \\frac{\\pi}{180}$. The composite matrix $M_{total}$ will serve as the transformation matrix $M$ in the tensor transformation equation.\n\n### 4. Computational Strategy\n\nThe solution will be implemented in Python using the NumPy library.\n1.  **Stiffness Tensor Construction:** A function `build_stiffness_tensor` will create the $3 \\times 3 \\times 3 \\times 3$ NumPy array for $C^{crys}_{ijkl}$ using the provided $C_{11}, C_{12}, C_{44}$ values and the formula from Section 2.\n2.  **Rotation Matrix Calculation:** A function `get_rotation_matrix` will generate the appropriate $3 \\times 3$ rotation matrix for a given axis and angle in degrees.\n3.  **Transformation Loop:** For each test case:\n    a. Initialize the total rotation matrix $M$ as the $3 \\times 3$ identity matrix.\n    b. For each rotation in the specified sequence, compute the elementary rotation matrix and update the total rotation via left-multiplication: $M \\leftarrow M_{step} \\cdot M$.\n    c. Apply the final transformation matrix $M$ to $C^{crys}$ to compute $C^{lab}$ using `numpy.einsum`, which is highly efficient for this type of tensor contraction:\n    `C_lab = np.einsum('pi,qj,rk,sl,ijkl-pqrs', M, M, M, M, C_crys)`\n4.  **Result Extraction:** After computing $C^{lab}$, extract the required components using 0-based indexing: $C'_{1111} \\equiv C^{lab}[0,0,0,0]$, $C'_{1122} \\equiv C^{lab}[0,0,1,1]$, and $C'_{1212} \\equiv C^{lab}[0,1,0,1]$.\n5.  **Output Formatting:** The extracted values will be rounded to six decimal places and formatted into the specified list-of-lists string representation. The baseline case (no rotation) serves as a validation check, as it should return the original elastic constants. The $90^\\circ$ rotation about $\\hat{z}$ case tests the implementation's handling of cubic symmetry, as the tensor must remain unchanged.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_stiffness_tensor(c11, c12, c44):\n    \"\"\"\n    Builds the 4th-order stiffness tensor for a cubic crystal.\n    \n    Args:\n        c11 (float): C11 elastic constant in GPa.\n        c12 (float): C12 elastic constant in GPa.\n        c44 (float): C44 elastic constant in GPa.\n\n    Returns:\n        np.ndarray: A 3x3x3x3 numpy array representing the stiffness tensor C_ijkl.\n    \"\"\"\n    C = np.zeros((3, 3, 3, 3))\n    \n    # Anisotropy factor\n    anisotropy_factor = c11 - c12 - 2 * c44\n    \n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                for l in range(3):\n                    # C12 part\n                    if i == j and k == l:\n                        C[i, j, k, l] += c12\n                    \n                    # C44 part\n                    if i == k and j == l:\n                        C[i, j, k, l] += c44\n                    if i == l and j == k:\n                        C[i, j, k, l] += c44\n\n                    # Anisotropy part (only for C_iiii)\n                    if i == j == k == l:\n                        C[i, j, k, l] += anisotropy_factor\n    return C\n\n\ndef get_rotation_matrix(axis, angle_deg):\n    \"\"\"\n    Generates a 3x3 rotation matrix for a given axis and angle.\n    \n    Args:\n        axis (str): The axis of rotation ('x', 'y', or 'z').\n        angle_deg (float): The angle of rotation in degrees.\n    \n    Returns:\n        np.ndarray: The 3x3 rotation matrix.\n    \"\"\"\n    angle_rad = np.deg2rad(angle_deg)\n    c = np.cos(angle_rad)\n    s = np.sin(angle_rad)\n    \n    if axis == 'x':\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n    elif axis == 'y':\n        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n    elif axis == 'z':\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    else:\n        raise ValueError(\"Invalid rotation axis. Must be 'x', 'y', or 'z'.\")\n\ndef transform_stiffness_tensor(C_crys, M):\n    \"\"\"\n    Transforms the stiffness tensor from the crystal to the lab frame.\n    \n    Args:\n        C_crys (np.ndarray): The 3x3x3x3 stiffness tensor in the crystal frame.\n        M (np.ndarray): The 3x3 rotation matrix from crystal to lab frame.\n    \n    Returns:\n        np.ndarray: The 3x3x3x3 stiffness tensor in the lab frame.\n    \"\"\"\n    # C'_pqrs = M_pi * M_qj * M_rk * M_sl * C_ijkl\n    C_lab = np.einsum('pi,qj,rk,sl,ijkl-pqrs', M, M, M, M, C_crys, optimize=True)\n    return C_lab\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Silicon stiffness constants in GPa\n    C11 = 165.7\n    C12 = 63.9\n    C44 = 79.6\n\n    # Build the stiffness tensor in the crystal frame\n    C_crystal = build_stiffness_tensor(C11, C12, C44)\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'A': [],\n        'B': [('z', 90.0)],\n        'C': [('z', 45.0)],\n        'D': [('z', 30.0), ('x', 180.0)]\n    }\n\n    results = []\n\n    # Process each test case in order A, B, C, D\n    for case_id in sorted(test_cases.keys()):\n        rotations = test_cases[case_id]\n        \n        # Start with identity matrix for the total rotation\n        M_total = np.identity(3)\n        \n        # Compose rotations\n        for axis, angle in rotations:\n            M_step = get_rotation_matrix(axis, angle)\n            # The new rotation is applied to the already rotated object,\n            # so we left-multiply. M_total = M_n * ... * M_1\n            M_total = np.dot(M_step, M_total)\n\n        # Transform the stiffness tensor\n        C_lab = transform_stiffness_tensor(C_crystal, M_total)\n\n        # Extract required components (using 0-based indexing)\n        c_1111 = C_lab[0, 0, 0, 0]\n        c_1122 = C_lab[0, 0, 1, 1]\n        c_1212 = C_lab[0, 1, 0, 1]\n\n        # Round to 6 decimal places and store\n        case_results = [\n            round(c_1111, 6),\n            round(c_1122, 6),\n            round(c_1212, 6)\n        ]\n        results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # str() includes spaces, so we remove them to match the required format.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of process simulation is to predict how a sequence of manufacturing steps collectively impacts final device characteristics. This capstone practice simulates a miniature process flow, challenging you to propagate a stress state variable through multiple thermal steps by solving a time-dependent relaxation model . You will then connect this final stress state to a critical performance metric—electron mobility—demonstrating the end-to-end integration of stress effects.",
            "id": "4132784",
            "problem": "You are asked to implement a principled method to carry forward stress-dependent electron mobility state variables across discrete process steps in a process flow simulation and to validate the method using test structures with controlled applied stress. The problem must be solved by deriving from first principles and widely accepted models in semiconductor process modeling and continuum mechanics, and then designing an algorithm to propagate the state across steps.\n\nStart from the following base principles and facts:\n\n1. Continuum thermally activated relaxation: Under an isothermal step at temperature $T$ and duration $\\Delta t$, an internal uniaxial residual stress state $\\sigma_{x}(t)$ evolves toward an externally controlled applied uniaxial stress $\\sigma_{\\mathrm{app}}$ according to a first-order linear ordinary differential equation consistent with a Maxwell-type relaxation,\n$$\n\\frac{d \\sigma_{x}}{dt} = - \\frac{\\sigma_{x} - \\sigma_{\\mathrm{app}}}{\\tau(T)},\n$$\nwhere the relaxation time obeys Arrhenius kinetics,\n$$\n\\tau(T) = \\tau_{0} \\exp\\!\\left(\\frac{E_{a}}{k_{B} T}\\right),\n$$\nwith $E_{a}$ the activation energy, $k_{B}$ the Boltzmann constant, and $\\tau_{0}$ a pre-exponential factor.\n\n2. Isotropic tensor invariants and small-stress mobility perturbation: For small elastic stresses, the scalar electron mobility $\\mu_{n}$ is an isotropic function of stress and thus can be expanded to first order in the invariants of the Cauchy stress tensor $\\boldsymbol{\\sigma}$. For a uniaxial stress state aligned with the channel direction (the $x$-axis), $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$, the two independent invariants that impact scalar transport coefficients to first order are the hydrostatic stress $\\sigma_{h} = \\mathrm{tr}(\\boldsymbol{\\sigma})/3$ and the square root of the second invariant of the deviatoric stress $J_{2}$, where $J_{2} = \\tfrac{1}{2}\\,\\mathbf{s}:\\mathbf{s}$ and $\\mathbf{s} = \\boldsymbol{\\sigma} - \\sigma_{h}\\mathbf{I}$. For the uniaxial case, $\\sqrt{J_{2}} = |\\sigma_{x}|/\\sqrt{3}$. Assume the first-order linearization of electron mobility about zero-stress uses these invariants, with constant coefficients to be identified.\n\n3. Units: All quantities must be treated in the International System of Units (SI). Specifically, stress in pascals (Pa), temperature in kelvin (K), time in seconds (s), and mobility in square meters per volt-second (m$^{2}$/V·s). The Boltzmann constant $k_{B}$ must be used in electron-volts per kelvin (eV/K) if $E_{a}$ is provided in electron-volts (eV).\n\nTask requirements:\n\na) Derive an analytic, per-step update rule for $\\sigma_{x}$ that propagates the state from the start to the end of a process step, given constant $T$, $\\Delta t$, and $\\sigma_{\\mathrm{app}}$ over that step, in a form suitable for stable numerical implementation and composition over multiple steps.\n\nb) Based on the invariant expansion premise, derive a first-order small-stress relation for electron mobility $\\mu_{n}$ as a function of the uniaxial stress $\\sigma_{x}$, using two coefficients corresponding to hydrostatic and distortional components.\n\nc) Design an algorithm that, for each test structure, initializes the internal stress state $\\sigma_{x}$ at the beginning of the flow, then applies the per-step update across the sequence of process steps to obtain the final stress, and finally computes the final electron mobility $\\mu_{n}$ from the derived invariant-based expression. Carry the state strictly from one step to the next without loss of history except through the physical relaxation dynamics.\n\nd) Validation using controlled-stress test structures: Use the provided test suite where each test structure is subjected to known applied uniaxial stress sequences $\\sigma_{\\mathrm{app}}$ at specified temperatures and durations. The controlled stress values serve as validation stimuli; your program must compute the final electron mobility for each case.\n\nNumerical data and constants to use:\n\n- Reference electron mobility at zero stress: $\\mu_{n,0} = 0.045$ m$^{2}$/V·s.\n- Hydrostatic and distortional coefficients for electrons in the linearized invariant model: $a_{h}^{(n)} = 1.0\\times 10^{-11}$ Pa$^{-1}$ and $a_{d}^{(n)} = 2.0\\times 10^{-11}$ Pa$^{-1}$.\n- Arrhenius parameters: $\\tau_{0} = 1.0\\times 10^{-7}$ s, $E_{a} = 1.5$ eV, $k_{B} = 8.617333262145\\times 10^{-5}$ eV/K.\n- For uniaxial stress $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$, you must use $\\sigma_{h} = \\sigma_{x}/3$ and $\\sqrt{J_{2}} = |\\sigma_{x}|/\\sqrt{3}$ when evaluating the mobility perturbation.\n\nTest suite:\n\nEach test case is defined by an initial internal uniaxial stress $\\sigma_{x}(0)$ in Pa and a list of process steps, each step given as a triple $(T, \\Delta t, \\sigma_{\\mathrm{app}})$ with $T$ in K, $\\Delta t$ in s, and $\\sigma_{\\mathrm{app}}$ in Pa.\n\n- Case 1 (happy path, tensile bias with moderate relaxation):\n  - Initial $\\sigma_{x}(0) = 0$ Pa.\n  - Steps:\n    1) $(800,\\ 1200,\\ +2.0\\times 10^{8})$,\n    2) $(300,\\ 600,\\ +2.0\\times 10^{8})$.\n\n- Case 2 (boundary, zero applied stress throughout):\n  - Initial $\\sigma_{x}(0) = 0$ Pa.\n  - Steps:\n    1) $(900,\\ 3600,\\ 0)$,\n    2) $(300,\\ 100,\\ 0)$.\n\n- Case 3 (fast high-temperature relaxation toward tensile state from compressive initial):\n  - Initial $\\sigma_{x}(0) = -1.0\\times 10^{8}$ Pa.\n  - Steps:\n    1) $(1100,\\ 100,\\ +3.0\\times 10^{8})$,\n    2) $(1100,\\ 1000,\\ +3.0\\times 10^{8})$.\n\n- Case 4 (alternating tensile/compressive steps at constant temperature with partial tracking):\n  - Initial $\\sigma_{x}(0) = 0$ Pa.\n  - Steps:\n    1) $(800,\\ 200,\\ +2.0\\times 10^{8})$,\n    2) $(800,\\ 200,\\ -2.0\\times 10^{8})$,\n    3) $(800,\\ 200,\\ +2.0\\times 10^{8})$.\n\nRequired outputs and units:\n\n- For each test case, compute the final electron mobility $\\mu_{n}$ in m$^{2}$/V·s at the end of the last step, rounded to eight decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[0.04500000,0.04512345,0.04498765,0.04567890]\").\n\nExpress all results as decimal numbers without any percentage sign.\n\nYour final program must be self-contained and runnable as provided, and must not read any input. It must implement the physics-based derivation and algorithm described above to generate the required outputs for the specified test suite.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded in established principles of continuum mechanics and semiconductor physics, is mathematically well-posed, and provides a self-contained and unambiguous set of data and requirements. We may therefore proceed with the solution.\n\nThe solution is developed in four parts as required: a) derivation of the stress update rule, b) derivation of the mobility model, c) formulation of the computational algorithm, and d) application to the specified test cases.\n\na) Derivation of the Stress Update Rule\n\nThe evolution of the internal uniaxial stress, $\\sigma_{x}$, is governed by the first-order linear ordinary differential equation:\n$$\n\\frac{d \\sigma_{x}}{dt} = - \\frac{\\sigma_{x} - \\sigma_{\\mathrm{app}}}{\\tau(T)}\n$$\nFor a single process step, the temperature $T$ and the externally applied stress $\\sigma_{\\mathrm{app}}$ are constant. Consequently, the relaxation time $\\tau(T)$ is also constant over the duration of the step, $\\Delta t$. We can rewrite the equation as:\n$$\n\\frac{d \\sigma_{x}}{dt} + \\frac{1}{\\tau} \\sigma_{x} = \\frac{\\sigma_{\\mathrm{app}}}{\\tau}\n$$\nThis is a standard non-homogeneous linear first-order differential equation. Its solution can be found using an integrating factor, $I(t) = \\exp(\\int \\frac{dt}{\\tau}) = \\exp(t/\\tau)$. Multiplying the equation by $I(t)$ yields:\n$$\n\\exp(t/\\tau) \\frac{d \\sigma_{x}}{dt} + \\frac{1}{\\tau} \\exp(t/\\tau) \\sigma_{x} = \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau)\n$$\nThe left-hand side is the derivative of a product, $\\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right)$. Thus:\n$$\n\\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right) = \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau)\n$$\nWe integrate over a time interval from $t=0$ to $t=\\Delta t$, corresponding to the start and end of the process step. Let the stress at the start of the step be $\\sigma_{x, \\text{start}}$.\n$$\n\\int_{0}^{\\Delta t} \\frac{d}{dt} \\left( \\sigma_{x}(t) \\exp(t/\\tau) \\right) dt = \\int_{0}^{\\Delta t} \\frac{\\sigma_{\\mathrm{app}}}{\\tau} \\exp(t/\\tau) dt\n$$\n$$\n\\left[ \\sigma_{x}(t) \\exp(t/\\tau) \\right]_{0}^{\\Delta t} = \\left[ \\sigma_{\\mathrm{app}} \\exp(t/\\tau) \\right]_{0}^{\\Delta t}\n$$\n$$\n\\sigma_{x}(\\Delta t) \\exp(\\Delta t/\\tau) - \\sigma_{x}(0) \\exp(0) = \\sigma_{\\mathrm{app}} \\exp(\\Delta t/\\tau) - \\sigma_{\\mathrm{app}} \\exp(0)\n$$\nLetting $\\sigma_{x, \\text{end}} = \\sigma_{x}(\\Delta t)$ and $\\sigma_{x, \\text{start}} = \\sigma_{x}(0)$, we have:\n$$\n\\sigma_{x, \\text{end}} \\exp(\\Delta t/\\tau) - \\sigma_{x, \\text{start}} = \\sigma_{\\mathrm{app}} (\\exp(\\Delta t/\\tau) - 1)\n$$\nSolving for $\\sigma_{x, \\text{end}}$ by multiplying through by $\\exp(-\\Delta t/\\tau)$:\n$$\n\\sigma_{x, \\text{end}} = \\sigma_{x, \\text{start}} \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right) + \\sigma_{\\mathrm{app}} \\left(1 - \\exp\\left(-\\frac{\\Delta t}{\\tau}\\right)\\right)\n$$\nThis equation can be rearranged into a numerically stable and physically intuitive form. It describes the final stress as a convex combination of the initial and applied stresses, weighted by the exponential decay factor. A more common form is:\n$$\n\\sigma_{x, \\text{end}} = \\sigma_{\\mathrm{app}} + (\\sigma_{x, \\text{start}} - \\sigma_{\\mathrm{app}}) \\exp\\left(-\\frac{\\Delta t}{\\tau(T)}\\right)\n$$\nHere, the relaxation time $\\tau(T)$ follows the Arrhenius law:\n$$\n\\tau(T) = \\tau_{0} \\exp\\left(\\frac{E_{a}}{k_{B} T}\\right)\n$$\nwith constants $\\tau_0 = 1.0\\times 10^{-7}$ s, $E_a = 1.5$ eV, and $k_B = 8.617333262145\\times 10^{-5}$ eV/K. This update rule propagates the stress state across one discrete process step.\n\nb) Derivation of the Mobility Model\n\nThe problem posits that for small stresses, the scalar electron mobility $\\mu_{n}$ can be expressed as a first-order expansion in the invariants of the Cauchy stress tensor $\\boldsymbol{\\sigma}$. The chosen invariants are the hydrostatic stress, $\\sigma_{h}$, and the square root of the second invariant of the deviatoric stress, $\\sqrt{J_2}$. The general first-order model for the relative change in mobility is:\n$$\n\\frac{\\mu_{n} - \\mu_{n,0}}{\\mu_{n,0}} = a_{h}^{(n)} \\sigma_{h} + a_{d}^{(n)} \\sqrt{J_{2}}\n$$\nwhere $\\mu_{n,0}$ is the reference mobility at zero stress, and $a_{h}^{(n)}$ and $a_{d}^{(n)}$ are the hydrostatic and distortional piezomobility coefficients, given as $a_{h}^{(n)} = 1.0\\times 10^{-11}$ Pa$^{-1}$ and $a_{d}^{(n)} = 2.0\\times 10^{-11}$ Pa$^{-1}$.\n\nThis gives the mobility as:\n$$\n\\mu_{n}(\\boldsymbol{\\sigma}) = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\sigma_{h} + a_{d}^{(n)} \\sqrt{J_{2}} \\right)\n$$\nWe must now evaluate the invariants for the specified uniaxial stress state, $\\boldsymbol{\\sigma} = \\mathrm{diag}(\\sigma_{x}, 0, 0)$.\n\nThe hydrostatic stress is a third of the trace of the stress tensor:\n$$\n\\sigma_{h} = \\frac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3} (\\sigma_{x} + 0 + 0) = \\frac{\\sigma_{x}}{3}\n$$\nThe deviatoric stress tensor $\\mathbf{s}$ is defined as $\\mathbf{s} = \\boldsymbol{\\sigma} - \\sigma_{h}\\mathbf{I}$:\n$$\n\\mathbf{s} = \\begin{pmatrix} \\sigma_{x}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} - \\frac{\\sigma_{x}}{3} \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2\\sigma_{x}/3  0  0 \\\\ 0  -\\sigma_{x}/3  0 \\\\ 0  0  -\\sigma_{x}/3 \\end{pmatrix}\n$$\nThe second invariant $J_2$ is given by $J_2 = \\frac{1}{2} \\mathbf{s}:\\mathbf{s} = \\frac{1}{2}\\sum_{i,j} s_{ij}s_{ji}$. For a diagonal tensor, this simplifies to $J_2 = \\frac{1}{2}\\sum_{i} s_{ii}^2$:\n$$\nJ_2 = \\frac{1}{2} \\left[ \\left(\\frac{2\\sigma_{x}}{3}\\right)^2 + \\left(-\\frac{\\sigma_{x}}{3}\\right)^2 + \\left(-\\frac{\\sigma_{x}}{3}\\right)^2 \\right] = \\frac{1}{2} \\left( \\frac{4\\sigma_{x}^2}{9} + \\frac{\\sigma_{x}^2}{9} + \\frac{\\sigma_{x}^2}{9} \\right) = \\frac{1}{2} \\left( \\frac{6\\sigma_{x}^2}{9} \\right) = \\frac{\\sigma_{x}^2}{3}\n$$\nTherefore, the square root of this invariant is:\n$$\n\\sqrt{J_2} = \\sqrt{\\frac{\\sigma_{x}^2}{3}} = \\frac{|\\sigma_{x}|}{\\sqrt{3}}\n$$\nBoth invariants are consistent with the values provided in the problem statement. Substituting these expressions into the mobility equation yields the final model for electron mobility as a function of the uniaxial stress $\\sigma_x$:\n$$\n\\mu_{n}(\\sigma_{x}) = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\frac{\\sigma_{x}}{3} + a_{d}^{(n)} \\frac{|\\sigma_{x}|}{\\sqrt{3}} \\right)\n$$\nThis expression will be used to compute the final mobility from the final stress state.\n\nc) Algorithmic Design\n\nThe algorithm to compute the final electron mobility for a given test case proceeds as follows:\n1.  Initialize the state variable for internal stress, $\\sigma_{x,\\text{current}}$, with the provided initial stress, $\\sigma_{x}(0)$.\n2.  Iterate through the sequence of process steps, where each step $i$ is defined by a tuple $(T_i, \\Delta t_i, \\sigma_{\\mathrm{app}, i})$.\n3.  For each step $i$:\n    a. Retrieve the step parameters $T_i$, $\\Delta t_i$, and $\\sigma_{\\mathrm{app}, i}$.\n    b. Calculate the relaxation time $\\tau(T_i)$ using the Arrhenius equation: $\\tau(T_i) = \\tau_{0} \\exp(E_{a} / (k_{B} T_i))$.\n    c. Apply the derived update rule to find the stress at the end of the step, $\\sigma_{x, \\text{end}}$. The initial stress for this step is the final stress from the previous step, $\\sigma_{x, \\text{current}}$.\n       $$ \\sigma_{x, \\text{end}} = \\sigma_{\\mathrm{app}, i} + (\\sigma_{x, \\text{current}} - \\sigma_{\\mathrm{app}, i}) \\exp\\left(-\\frac{\\Delta t_i}{\\tau(T_i)}\\right) $$\n    d. Update the state variable for the next iteration: $\\sigma_{x,\\text{current}} \\leftarrow \\sigma_{x, \\text{end}}$.\n4.  After processing all steps, the final internal stress is $\\sigma_{x,\\text{final}} = \\sigma_{x,\\text{current}}$.\n5.  Use the final stress $\\sigma_{x,\\text{final}}$ to compute the final electron mobility $\\mu_{n,\\text{final}}$ using the derived mobility model:\n    $$ \\mu_{n,\\text{final}} = \\mu_{n,0} \\left( 1 + a_{h}^{(n)} \\frac{\\sigma_{x,\\text{final}}}{3} + a_{d}^{(n)} \\frac{|\\sigma_{x,\\text{final}}|}{\\sqrt{3}} \\right) $$\n6.  The result, $\\mu_{n,\\text{final}}$, is then formatted to the required precision.\n\nd) Implementation and Validation\n\nThe above algorithm is implemented in a Python program. This program sequentially processes each of the four specified test cases. For each case, it initializes the stress, iteratively applies the per-step update rule to propagate the stress state through the process flow, and finally computes the electron mobility from the final stress. The numerical constants provided in the problem statement ($\\mu_{n,0} = 0.045$ m$^2$/V·s, $a_{h}^{(n)}$, $a_{d}^{(n)}$, $\\tau_{0}$, $E_{a}$, $k_{B}$) are used directly in the calculations. The output is a list of the final mobility values, rounded to eight decimal places, for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of propagating stress state and calculating final electron mobility.\n    \"\"\"\n    \n    # Numerical data and constants in SI units\n    MU_N0 = 0.045  # Reference electron mobility [m^2/V·s]\n    A_H_N = 1.0e-11  # Hydrostatic piezomobility coefficient [Pa^-1]\n    A_D_N = 2.0e-11  # Distortional piezomobility coefficient [Pa^-1]\n    TAU0 = 1.0e-7    # Arrhenius pre-exponential factor [s]\n    EA = 1.5         # Activation energy [eV]\n    KB = 8.617333262145e-5  # Boltzmann constant [eV/K]\n\n    # Test suite from the problem statement\n    # Each case: (initial_sigma_x_0, list of steps)\n    # Each step: (Temperature T [K], duration delta_t [s], applied_stress sigma_app [Pa])\n    test_cases = [\n        # Case 1\n        (0.0, [\n            (800.0, 1200.0, 2.0e8),\n            (300.0, 600.0, 2.0e8),\n        ]),\n        # Case 2\n        (0.0, [\n            (900.0, 3600.0, 0.0),\n            (300.0, 100.0, 0.0),\n        ]),\n        # Case 3\n        (-1.0e8, [\n            (1100.0, 100.0, 3.0e8),\n            (1100.0, 1000.0, 3.0e8),\n        ]),\n        # Case 4\n        (0.0, [\n            (800.0, 200.0, 2.0e8),\n            (800.0, 200.0, -2.0e8),\n            (800.0, 200.0, 2.0e8),\n        ]),\n    ]\n\n    results = []\n    \n    for initial_sigma, steps in test_cases:\n        current_sigma_x = initial_sigma\n        \n        # Propagate stress through the process steps\n        for T, delta_t, sigma_app in steps:\n            # Calculate relaxation time using Arrhenius law\n            # Note: T must be  0\n            if T = 0:\n                # In a physically realistic scenario, T  0.\n                # If T - 0, tau - infinity, stress is frozen.\n                # exp(-delta_t / tau) - 1.\n                decay_factor = 1.0\n            else:\n                tau = TAU0 * np.exp(EA / (KB * T))\n                # Protect against underflow/overflow if delta_t/tau is very large\n                # For large x, exp(-x) - 0. Let's use numpy's robust exp.\n                decay_factor = np.exp(-delta_t / tau)\n\n            # Update stress using the derived analytical solution\n            # sigma_end = sigma_app + (sigma_start - sigma_app) * exp(-delta_t / tau)\n            current_sigma_x = sigma_app + (current_sigma_x - sigma_app) * decay_factor\n\n        final_sigma_x = current_sigma_x\n\n        # Calculate final electron mobility using the derived invariant-based model\n        # mu_n = mu_n0 * (1 + a_h * sigma_x / 3 + a_d * |sigma_x| / sqrt(3))\n        mobility_change = A_H_N * final_sigma_x / 3.0 + A_D_N * np.abs(final_sigma_x) / np.sqrt(3.0)\n        final_mobility = MU_N0 * (1.0 + mobility_change)\n        \n        results.append(f\"{final_mobility:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}