{
    "hands_on_practices": [
        {
            "introduction": "光刻建模的核心是精确预测晶圆上的光强分布，即“航拍像”。这项实践是掌握该技能的基石。我们将运用傅里叶光学的基本原理——阿贝成像理论，从零开始计算一个简单周期性光栅的航拍像。通过这个练习，你将深入理解衍射级次、数值孔径（$NA$）以及光源形状（例如偶极子光源）如何共同决定图像衬度，这是衡量成像质量的关键指标 。",
            "id": "4125078",
            "problem": "考虑一个一维二元线空间光栅，晶圆侧的间距为 $p$，占空比为 $f$，在极紫外光 (EUV) 波长 $\\lambda$ 下由部分相干偶极子光源照明。成像系统被建模为一个薄透镜、标量、在焦的 Abbe 成像系统，其数值孔径 (NA) 为 $\\mathrm{NA}$。假设光栅沿 $y$ 轴不变，沿 $x$ 轴周期性分布。通过相干因子 $\\sigma$ 来定义部分相干光源，使得两个偶极子点沿某一选定方向位于空间频率偏移 $\\pm \\sigma \\,\\mathrm{NA}/\\lambda$ 处。\n\n您的任务是采用基于傅里叶光学和标量衍射理论的第一性原理方法，计算晶圆上光栅的空气像对比度。空气像定义为由每个偶极子光源点形成的相干图像进行非相干叠加而在像平面中产生的强度分布。基本原理必须包括：\n- 标量衍射理论和傅里叶光学的定义，特别是周期性结构可以用傅里叶级数谐波表示，其空间频率为 $m/p$，其中 $m$ 为整数。\n- 针对部分相干照明的 Abbe 成像原理，其中每个光源点对应一个倾斜的平面波，该平面波会使掩模频谱在光瞳中发生位移，只有那些位移后的空间频率位于光瞳内的谐波才能通过。\n- 对于一个空间频率 $k_x$，其通带条件由光瞳截止频率 $k_c = \\mathrm{NA}/\\lambda$ 给出。\n\n科学真实性约束：\n- 对 EUV 照明使用 $\\lambda = 13.5\\ \\mathrm{nm}$。\n- 将掩模视为一个薄振幅物体，其线条区域的透射率为1，空间区域为0。\n- 仅考虑零阶、一阶和二阶衍射级次，即整数谐波 $m \\in \\{-2,-1,0,1,2\\}$。\n- 偶极子光源可以沿 $x$ 轴取向（在 $k_x$ 上产生位移）或沿 $y$ 轴取向（对于一维 $x$ 向变化的光栅，在 $k_x$ 上无位移）。\n\n推导所需的定义：\n- 光瞳截止频率为 $k_c = \\mathrm{NA}/\\lambda$，单位为 $\\mathrm{nm}^{-1}$。\n- 对于沿 $x$ 轴取向的光源，两个光源点位于 $k_x$ 中的 $k_{s} = \\pm \\sigma\\, k_c$。对于沿 $y$ 轴的取向，在 $k_x$ 中没有位移（即，对于此一维模型，$k_s = 0$）。\n- 占空比为 $f$ 的二元线空间光栅的傅里叶级数系数 $c_m$ 定义为 $c_0 = f$ 和 $c_m = \\dfrac{\\sin(\\pi m f)}{\\pi m}$（当 $m \\neq 0$ 时）。\n- 对于给定的光源点，当且仅当 $|k_s + \\frac{m}{p}| \\le k_c$ 时，阶数为 $m$ 的谐波才能通过。\n\n计算过程要求：\n- 对每个光源点，计算其相干场，即在单个空间周期 $x \\in [0,p]$ 内对所有通过的谐波 $m \\in \\{-2,-1,0,1,2\\}$ 求和。\n- 总空气像强度是来自两个光源点强度的非相干叠加。\n- 空气像对比度定义为 $C = \\dfrac{I_{\\max} - I_{\\min}}{I_{\\max} + I_{\\min}}$，其中 $I_{\\max}$ 和 $I_{\\min}$ 是在 $x \\in [0,p]$ 上的最大和最小强度。\n\n单位和数值规范：\n- 所有长度必须以 $\\mathrm{nm}$ 为单位处理，空间频率以 $\\mathrm{nm}^{-1}$ 为单位。\n- 将最终对比度值表示为小数（不带百分号），四舍五入到六位小数。\n\n测试集：\n提供以下五个参数集的结果，每个参数集以 $(p,\\ \\mathrm{NA},\\ \\sigma,\\ \\text{orientation},\\ f)$ 的形式给出，其中方向为 $x$ 或 $y$：\n1. 在截止受限间距下的基线 x 轴偶极子：$(40\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n2. 相同间距但偶极子沿 y 轴（无 $k_x$ 偏移）：$(40\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ y,\\ 0.5)$。\n3. 允许通过偶极子传输二阶衍射的较大间距：$(60\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n4. 对于每个偶极子叶，一阶衍射在光瞳中居中的边界情况：$(81.8181818182\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n5. 即使使用偶极子，一阶或二阶衍射也无法传输的小间距：$(25\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[$c_1$,$c_2$,$c_3$,$c_4$,$c_5$]”），其中 $c_i$ 是按上述顺序列出的测试用例的对比度值，四舍五入到六位小数。",
            "solution": "该问题陈述已经过严格验证，并被确定为半导体光刻建模领域中一个定义明确、具有科学依据的问题。它提供了计算唯一且有意义的解所需的所有必要参数、定义和约束。该问题没有矛盾、歧义和事实错误。\n\n该解决方案计算了一维线空间光栅在部分相干 EUV 照明下的空气像对比度。该方法基于傅里叶光学和标量衍射理论的原理，并应用于 Abbe 图像形成模型。\n\n基本原理是，像光栅这样的周期性物体可以通过其傅里叶级数来表示。光线刚通过掩模（物场）后的复电场可以写成：\n$$\nE_{\\text{obj}}(x) = \\sum_{m=-\\infty}^{\\infty} c_m e^{i 2\\pi (m/p) x}\n$$\n其中 $p$ 是光栅的间距，而 $c_m$ 是傅里叶级数系数。对于占空比为 $f$（周期中透明部分的比例）的二元光栅，其系数由以下公式给出：\n$$\nc_0 = f\n$$\n$$\nc_m = \\frac{\\sin(\\pi m f)}{\\pi m} \\quad \\text{对于 } m \\neq 0\n$$\n问题规定我们只需要考虑衍射级次 $m \\in \\{-2, -1, 0, 1, 2\\}$。\n\n成像系统的物镜充当空间频率滤波器。在标量、薄透镜近似中，此滤波器由一个光瞳函数表示，该函数仅在空间频率 $k_x$ 的大小小于或等于截止频率 $k_c$ 时才非零。该截止频率由透镜的数值孔径 $\\mathrm{NA}$ 和光的波长 $\\lambda$ 决定：\n$$\nk_c = \\frac{\\mathrm{NA}}{\\lambda}\n$$\n只有在光瞳平面中 $|k| \\le k_c$ 圆内的空间频率才能被透镜传输。\n\n部分相干照明通过将光源视作一组相互非相干的点光源集合来建模。对于偶极子光源，存在两个这样的点。每个光源点都用倾斜的平面波照射掩模。光源平面中位于空间频率位置 $k_s$ 的光源点，实际上会将物的衍射图样（其傅里叶光谱）在光瞳平面中移动 $-k_s$。因此，对于位于位置 $k_{s,j}$ 的给定光源点 $j$，空间频率为 $k_m = m/p$ 的衍射级次 $m$ 能否通过透镜，取决于其移动后的频率是否落在光瞳的通带内：\n$$\n|k_{s,j} + k_m| \\le k_c\n$$\n对于每个光源点 $j$，像平面中的电场 $E_j(x)$ 是通过对所有通过的谐波求和形成的。为简单起见，假设放大倍率为1，则电场为：\n$$\nE_j(x) = \\sum_{m \\in \\{-2,...,2\\}} c_m \\cdot T_j(m) \\cdot e^{i 2\\pi (m/p) x}\n$$\n其中 $T_j(m)$ 是第 $j$ 个光源点和第 $m$ 阶的二元透射因子：\n$$\nT_j(m) = \\begin{cases} 1  \\text{如果 } |k_{s,j} + m/p| \\le k_c \\\\ 0  \\text{否则} \\end{cases}\n$$\n问题指定了一个偶极子光源。对于沿 $x$ 轴取向的偶极子，两个光源点位于 $k_x = \\pm \\sigma k_c$。因此，光源位移为 $k_{s,1} = +\\sigma k_c$ 和 $k_{s,2} = -\\sigma k_c$。对于沿 $y$ 轴取向的偶极子，问题指出这在此一维模型的 $k_x$ 维度上不产生位移，因此我们对两个光源点都取 $k_s = 0$。\n\n由于光源点是相互非相干的，总空气像强度 $I(x)$ 是由每个光源点单独产生的强度之和：\n$$\nI(x) = \\sum_{j=1}^{2} |E_j(x)|^2 = |E_1(x)|^2 + |E_2(x)|^2\n$$\n最后，空气像对比度 $C$ 是根据光栅一个周期内 ($x \\in [0, p]$) 的总强度的最大值 ($I_{\\max}$) 和最小值 ($I_{\\min}$) 计算得出的：\n$$\nC = \\frac{I_{\\max} - I_{\\min}}{I_{\\max} + I_{\\min}}\n$$\n$C=1$ 的值表示完美的对比度，而 $C=0$ 表示没有调制（一个平坦的场），意味着图案没有被解析。\n\n计算过程如下：\n1.  对于每个具有参数 $(p, \\mathrm{NA}, \\sigma, \\text{orientation}, f)$ 的测试用例，设置 EUV 波长 $\\lambda = 13.5 \\ \\mathrm{nm}$。\n2.  计算光瞳截止频率 $k_c = \\mathrm{NA}/\\lambda$。\n3.  确定光源点位置 $\\{k_{s,j}\\}$。对于 'x' 取向，$k_{s,j} = \\{\\sigma k_c, -\\sigma k_c\\}$。对于 'y' 取向，$k_{s,j} = \\{0, 0\\}$。\n4.  在 $x \\in [0, p]$ 的空间网格上，将总强度数组 $I(x)$ 初始化为零。\n5.  对于每个光源点 $k_{s,j}$：\n    a. 初始化一个复电场数组 $E_j(x)$ 为零。\n    b. 对于每个衍射级次 $m \\in \\{-2, -1, 0, 1, 2\\}$：\n        i. 使用条件 $|k_{s,j} + m/p| \\le k_c$ 检查该级次是否通过。\n        ii. 如果通过，则计算傅里叶系数 $c_m$ 并将项 $c_m e^{i 2\\pi (m/p) x}$ 加到 $E_j(x)$ 中。\n    c. 计算该光源的强度 $|E_j(x)|^2$，并将其加到总强度 $I(x)$ 中。\n6.  找到最终 $I(x)$ 数组的最大值和最小值。\n7.  使用其定义计算对比度 $C$。如果 $I_{\\max} + I_{\\min}$ 为零，则对比度定义为 0。\n\n对每个提供的测试用例实施此过程，以找到所需的对比度值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aerial image contrast for several EUV lithography scenarios.\n    \n    The solution is based on Fourier optics and the Abbe theory of image formation.\n    It models a 1D binary grating illuminated by a partially coherent dipole\n    source and imaged by a scalar, in-focus system.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (p, NA, sigma, orientation, f)\n    # where p is pitch (nm), NA is numerical aperture, sigma is coherence parameter,\n    # orientation is 'x' or 'y', f is duty cycle.\n    test_cases = [\n        (40.0, 0.33, 0.5, 'x', 0.5),\n        (40.0, 0.33, 0.5, 'y', 0.5),\n        (60.0, 0.33, 0.5, 'x', 0.5),\n        (900.0 / 11.0, 0.33, 0.5, 'x', 0.5),  # p = 81.8181... nm\n        (25.0, 0.33, 0.5, 'x', 0.5)\n    ]\n    \n    LAMBDA = 13.5  # EUV wavelength in nm\n    ORDERS = [-2, -1, 0, 1, 2] # Diffraction orders to consider\n    NUM_SAMPLES = 1000  # Number of points for spatial grid over one period\n\n    results = []\n    \n    for case in test_cases:\n        p, NA, sigma, orientation, f = case\n\n        # Step 1: Calculate derived parameters\n        kc = NA / LAMBDA  # Pupil cutoff frequency in nm^-1\n\n        # Step 2: Determine source point locations in k_x space\n        if orientation == 'x':\n            ks_vals = [sigma * kc, -sigma * kc]\n        elif orientation == 'y':\n            # For a 1D grating, a y-oriented dipole produces no k_x shift.\n            # We model this as two on-axis source points.\n            ks_vals = [0.0, 0.0]\n        else:\n            raise ValueError(\"Orientation must be 'x' or 'y'\")\n            \n        # Step 3: Define spatial grid and initialize total intensity\n        x_grid = np.linspace(0, p, NUM_SAMPLES, endpoint=False)\n        total_intensity = np.zeros_like(x_grid)\n\n        # Step 4: Loop over incoherent source points\n        for ks in ks_vals:\n            coherent_field = np.zeros_like(x_grid, dtype=np.complex128)\n\n            # Step 5: For each source, sum transmitted diffraction orders\n            for m in ORDERS:\n                km = m / p  # Spatial frequency of the m-th order\n                \n                # Pupil passband condition\n                if np.abs(ks + km) = kc:\n                    # Calculate Fourier coefficient c_m\n                    if m == 0:\n                        cm = f\n                    else:\n                        # Handle potential division by zero for m=0, though separated\n                        cm = np.sin(np.pi * m * f) / (np.pi * m)\n                    \n                    # Add harmonic's contribution to the coherent field\n                    coherent_field += cm * np.exp(1j * 2 * np.pi * km * x_grid)\n            \n            # Step 6: Accumulate intensities (incoherent sum)\n            total_intensity += np.abs(coherent_field)**2\n            \n        # Step 7: Calculate contrast from the total aerial image intensity\n        if total_intensity.size > 0:\n            I_max = np.max(total_intensity)\n            I_min = np.min(total_intensity)\n        else:\n            I_max, I_min = 0, 0\n\n        denominator = I_max + I_min\n        if denominator > 1e-12: # Check for non-zero denominator to avoid division by zero\n            contrast = (I_max - I_min) / denominator\n        else:\n            contrast = 0.0\n            \n        results.append(f\"{contrast:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了一维基础理论后，我们将挑战一个更贴近工业实践的二维工程问题：计算掩模误差增强因子（MEEF）。这项实践将傅里叶光学模型扩展至二维空间，用于模拟接触孔阵列的成像，并引入了离焦和简化抗蚀剂模型等实际工艺因素。MEEF是评估工艺窗口和控制掩模制造规格的关键参数，完成此练习将使你获得模拟掩模误差如何在晶圆上被放大，以及如何对多重曝光等先进技术进行建模的宝贵经验 。",
            "id": "4125029",
            "problem": "要求您实现一个计算模型，用于估算极紫外 (EUV) 光刻接触孔阵列的掩模误差增强因子 (MEEF)。MEEF量化了掩模关键尺寸 (CD) 的误差如何转化为晶圆CD的误差，并定义为晶圆CD对掩模CD的灵敏度。具体来说，您将通过在指定的焦距和剂量矩阵下，使用基于抗蚀剂阈值显影模型的模拟衍射图像，对晶圆CD相对于掩模CD进行数值微分来计算MEEF。\n\n使用以下科学基础和建模假设：\n\n- 极紫外 (EUV) 光刻的工作波长为 $\\lambda = 13.5 \\,\\text{nm}$。数值孔径 (NA) 是空间频率空间中的光瞳半径。\n- 衍射图像采用Abbe成像下的标量傅里叶光学进行建模，其中部分相干照明通过离散光源点产生的相干图像的非相干叠加来近似。\n- 光瞳函数 $P(\\mathbf{f})$ 是空间频率坐标 $\\mathbf{f} = (f_x,f_y)$ 中的一个圆形孔径，其通带半径为 $f_c = \\mathrm{NA}/\\lambda$。对于像平面上距离为 $z$ 的离焦，相干传递函数包含二次相位 $\\exp\\!\\left(-i \\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2\\right)$。\n- 部分相干性由频率空间中半径为 $s = \\sigma f_c$ 的圆上的一组光源点表示，其中 $\\sigma$ 是部分相干因子。衍射光强是所有光源点的贡献之和，每个贡献是对移动光瞳与物谱的乘积进行傅里叶逆变换后所得结果的平方模。\n- 接触孔阵列的物体是一个二元振幅透射函数 $A(x,y)$，它由排列在节距为 $p$ 的方形网格上的圆形开口组成，每个开口的半径为 $r = \\frac{1}{2}\\, \\mathrm{CD}_\\text{mask} / M$，其中 $M$ 是投影缩小倍率（使用 $M=4$）。这里的 $\\mathrm{CD}_\\text{mask}$ 是在掩模尺度上指定的；衍射图像是在晶圆尺度上计算的。\n- 抗蚀剂阈值模型是二元的：通过将计算出的光强除以给定情景下模拟域内的最大值来定义归一化衍射光强 $I_\\mathrm{norm}(x,y)$。对于给定的剂量因子 $D$ 和阈值 $T_\\mathrm{th}$（无量纲），当 $D \\, I_\\mathrm{norm}(x,y) \\ge T_\\mathrm{th}$ 时，抗蚀剂被清除（在晶圆上产生一个孔）。\n- 中心接触孔的晶圆CD被测量为清除后的二值图像中包含设计孔中心的连通区域的等效直径。如果在中心没有区域被清除，则CD为零。等效直径 $d_\\mathrm{wafer}$ 定义为 $d_\\mathrm{wafer} = 2 \\sqrt{A_\\mathrm{region}/\\pi}$，其中 $A_\\mathrm{region}$ 是对应于中心孔的连通清除区域的面积，单位为 $\\text{m}^2$。\n\n使用中心有限差分计算掩模误差增强因子 (MEEF)：\n$$\n\\mathrm{MEEF} \\approx \\frac{d_\\mathrm{wafer}\\!\\left(\\mathrm{CD}_\\text{mask}+\\Delta\\right) - d_\\mathrm{wafer}\\!\\left(\\mathrm{CD}_\\text{mask}-\\Delta\\right)}{(\\mathrm{CD}_\\text{mask}+\\Delta) - (\\mathrm{CD}_\\text{mask}-\\Delta)} = \\frac{d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-}{2\\Delta},\n$$\n其中 $\\Delta$ 是应用于掩模尺度上掩模CD的一个微小变化。\n\n如果使用多重图案（两次曝光），则假设采用光刻-蚀刻-光刻-蚀刻 (LELE) 风格将接触孔拆分为两个交错的子集。总剂量在曝光之间累加；即，组合光强是两次曝光的衍射光强之和。对于多重图案，仅计算相对于第一个掩模CD的导数，并保持第二个掩模恒定。\n\n在数学上实现以下步骤：\n\n1. 定义一个边长为 $L$、分辨率为 $N \\times N$ 的二维计算网格；空间采样率为 $\\Delta x = L/N$。使用与快速傅里叶变换 (FFT) 一致的频率网格 $f_x, f_y$。\n2. 在给定节距 $p$ 和像中心为中心位置的情况下，构建晶圆尺度上的接触孔阵列振幅 $A(x,y)$。对于多重图案，使用阵列索引的奇偶性将阵列拆分为两个子集 $A_1(x,y)$ 和 $A_2(x,y)$，并可选地对第二次曝光应用一个套刻偏移 $(\\delta_x, \\delta_y)$。\n3. 对于给定的离焦 $z$、部分相干因子 $\\sigma$ 以及半径为 $s=\\sigma f_c$ 的圆上的一组光源偏移 $\\{\\mathbf{s}_k\\}$，计算衍射光强\n$$\nI(x,y) = \\sum_k \\left| \\mathcal{F}^{-1}\\left[ P(\\mathbf{f}-\\mathbf{s}_k)\\, e^{-i\\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2} \\, \\mathcal{F}\\{A(x,y)\\} \\right] \\right|^2,\n$$\n其中 $\\mathcal{F}$ 表示傅里叶变换，$\\mathcal{F}^{-1}$ 表示其逆变换。\n4. 归一化光强得到 $I_\\mathrm{norm}(x,y) = I(x,y) / \\max_{x,y} I(x,y)$，应用剂量 $D$ 和阈值 $T_\\mathrm{th}$ 来计算清除后的二值图像。\n5. 通过计算包含中心像素的连通清除区域的面积，并将其转换为等效直径，来测量中心孔的 $d_\\mathrm{wafer}$。\n6. 使用上述有限差分公式计算 $\\mathrm{MEEF}$，其中 $\\Delta$ 是掩模尺度上的微小变化，对应于晶圆尺度上半径 $\\Delta/M$ 的变化。\n\n测试套件和参数：\n\n使用一个计算网格，其 $L = 512\\,\\text{nm}$ 且 $N=256$（因此所有空间维度必须在代码中以米为单位提供并进行适当转换）。使用圆形光瞳，其中 $\\mathrm{NA} = 0.33$，EUV波长 $\\lambda = 13.5\\,\\text{nm}$。使用 $M=4$。定义 $p = 64\\,\\text{nm}$。在光源圆上均匀分布使用 $8$ 个光源点。在掩模尺度上，对有限差分使用 $\\Delta = 2\\,\\text{nm}$。\n\n提供以下三个测试用例：\n\n- 案例1（单次曝光，标称值）：$\\mathrm{CD}_\\text{mask} = 140\\,\\text{nm}$, $z=0\\,\\text{nm}$, $\\sigma = 0.20$, $D=1.0$ (无量纲), $T_\\mathrm{th}=0.35$ (无量纲)。\n- 案例2（单次曝光，离焦和低剂量）：$\\mathrm{CD}_\\text{mask} = 140\\,\\text{nm}$, $z=100\\,\\text{nm}$, $\\sigma = 0.20$, $D=0.85$, $T_\\mathrm{th}=0.35$。\n- 案例3（带套刻的双曝光多重图案）：第一次曝光掩模 $\\mathrm{CD}_\\text{mask,1} = 140\\,\\text{nm}$ 按 $\\pm \\Delta$ 变化，第二次曝光掩模固定为 $\\mathrm{CD}_\\text{mask,2} = 140\\,\\text{nm}$，套刻偏移 $(\\delta_x,\\delta_y) = (3\\,\\text{nm}, 0\\,\\text{nm})$ 应用于第二次曝光。使用 $z=0\\,\\text{nm}$, $\\sigma=0.20$, $D=1.0$, $T_\\mathrm{th}=0.35$。根据阵列索引 $i+j$ 的奇偶性将接触孔拆分为两个交错子集。\n\n对于所有案例，MEEF必须报告为无量纲浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3]”）。\n\n代码中所有物理量必须使用国际单位制（SI）表示。不需要角度。不允许使用百分比；阈值和剂量是纯小数。确保对于给定的参数，模拟在科学上是一致的并且在数值上是稳定的。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。其科学基础植根于傅里叶光学和光刻建模原理，问题提法明确，信息充分，可以推导出唯一解，并且使用客观、正式的语言表述。关于掩模误差增强因子 (MEEF) 的定义存在一个微小的歧义。所提供的公式 $\\mathrm{MEEF} \\approx (d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-)/(2\\Delta)$ 产生的结果单位是缩小倍率的倒数 ($1/M$)，而问题要求的是无量纲浮点数。这可以通过采用标准的行业定义来解决，即 $\\mathrm{MEEF} = M \\cdot \\partial (\\mathrm{CD}_\\text{wafer}) / \\partial (\\mathrm{CD}_\\text{mask})$，该定义是无量纲的。解决方案将基于此标准定义进行。\n\n解决方案通过遵循问题陈述中概述的计算步骤序列来实现。所有物理量均以国际单位制（SI）表示。\n\n**1. 网格和坐标系定义**\n建立一个二维计算网格来表示像平面。该网格的边长为 $L = 512 \\times 10^{-9}\\,\\text{m}$，分辨率为 $N \\times N$ 像素，其中 $N=256$。这导致空间采样间隔（像素大小）为 $\\Delta x = L/N = 2 \\times 10^{-9}\\,\\text{m}$。一个笛卡尔坐标系 $(x,y)$ 以网格为中心，其坐标在每个维度上从 $-L/2$ 延伸到 $L/2 - \\Delta x$。\n\n相应的频域网格 $(\\mathbf{f} = (f_x, f_y))$ 被定义用于快速傅里叶变换 (FFT)。频率坐标由空间采样确定，与 `numpy.fft.fftfreq` 一致，并为计算而居中，范围可达奈奎斯特频率 $f_{Ny} = 1/(2\\Delta x)$。\n\n**2. 掩模对象生成**\n掩模是在晶圆尺度上的一个二元振幅对象 $A(x,y)$。它代表一个方形接触孔阵列。选择一个 $7 \\times 7$ 的阵列来模拟对中心接触孔的局部邻近效应，同时避免FFT隐式周期性导致的边界伪影。该阵列以原点为中心，接触孔中心位于 $(i \\cdot p, j \\cdot p)$，其中节距为 $p=64 \\times 10^{-9}\\,\\text{m}$，索引 $i, j$ 的范围从 $-3$ 到 $3$。\n\n每个圆形孔在晶圆尺度上的半径为 $r$，由掩模尺度的关键尺寸 ($\\mathrm{CD}_\\text{mask}$) 和系统缩小倍率 $M=4$ 决定：\n$$\nr = \\frac{1}{2} \\frac{\\mathrm{CD}_\\text{mask}}{M}\n$$\n对于多重图案案例（案例3），这个 $7 \\times 7$ 的接触孔阵列根据其网格索引之和 $(i+j)$ 的奇偶性被拆分为两个掩模 $A_1(x,y)$ 和 $A_2(x,y)$。$i+j$ 为偶数的接触孔构成掩模 $A_1$，奇数的构成掩模 $A_2$。一个指定的套刻误差 $(\\delta_x, \\delta_y) = (3 \\times 10^{-9}\\,\\text{m}, 0\\,\\text{m})$ 通过平移掩模 $A_2$ 上所有特征的坐标来应用。\n\n**3. 衍射图像模拟**\n衍射光强 $I(x,y)$ 使用用于部分相干成像的Abbe公式进行计算。照明光源被建模为在频域中一个圆上均匀分布的 $k=8$ 个离散点光源的非相干集合。这个圆的半径为 $s = \\sigma f_c$，其中 $\\sigma$ 是部分相干因子，$f_c = \\mathrm{NA}/\\lambda$ 是投影光学系统的截止频率。给定的参数为波长 $\\lambda = 13.5 \\times 10^{-9}\\,\\text{m}$ 和数值孔径 $\\mathrm{NA}=0.33$。\n\n对于每个光源点 $\\mathbf{s}_k$，计算一个相干图像。总光强是来自所有光源点的光强之和。单个光源点的计算包括：\n1.  计算掩模对象的傅里叶变换，$\\mathcal{F}\\{A(x,y)\\}$。\n2.  将光瞳函数 $P(\\mathbf{f})$ 定义为半径为 $f_c$ 的圆形孔径。\n3.  应用离焦像差作为一个二次相位项，$W(\\mathbf{f}) = \\exp(-i \\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2)$，其中 $z$ 是离焦距离。\n4.  将物谱与平移后的光瞳和离焦项相乘：$E(\\mathbf{f}) = P(\\mathbf{f}-\\mathbf{s}_k) \\cdot W(\\mathbf{f}) \\cdot \\mathcal{F}\\{A(x,y)\\}$。\n5.  进行傅里葉逆变换以获得像平面中的复电场，$E(x,y) = \\mathcal{F}^{-1}\\{E(\\mathbf{f})\\}$。\n6.  该光源点的光强为 $|E(x,y)|^2$。\n\n总衍射光强是所有 $k$ 个光源点的总和：\n$$\nI(x,y) = \\sum_{k=1}^{8} \\left| \\mathcal{F}^{-1}\\left[ P(\\mathbf{f}-\\mathbf{s}_k) \\cdot e^{-i\\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2} \\cdot \\mathcal{F}\\{A(x,y)\\} \\right] \\right|^2\n$$\n对于多重图案案例，分别为掩模 $A_1$ 和 $A_2$ 计算两个独立的衍射图像 $I_1(x,y)$ 和 $I_2(x,y)$。最终光强是它们的和，$I_\\text{total}(x,y) = I_1(x,y) + I_2(x,y)$，模拟一个剂量累加的光刻-蚀刻-光刻-蚀刻 (LELE) 工艺。\n\n**4. 抗蚀剂阈值模型和晶圆CD测量**\n将一个简单的二元阈值模型应用于衍射图像以模拟抗蚀剂显影。首先，光强通过其最大值进行归一化：$I_\\text{norm}(x,y) = I(x,y) / \\max(I)$。如果加剂量后的归一化光强超过给定的阈值 $T_\\mathrm{th}$，则认为该区域被“清除”：\n$$\n\\text{Cleared}(x,y) = 1 \\quad \\text{if} \\quad D \\cdot I_\\text{norm}(x,y) \\ge T_\\mathrm{th}, \\quad \\text{else} \\quad 0\n$$\n其中 $D$ 是剂量因子。\n\n中心接触孔的晶圆CD $d_\\mathrm{wafer}$ 是通过识别包含网格原点 $(x,y)=(0,0)$ 的清除区域来确定的。这是通过在二元清除图像上使用连通分量标记算法来实现的。如果原点不属于任何清除区域，则 $d_\\mathrm{wafer} = 0$。否则，计算中心连通分量的面积 $A_\\mathrm{region}$，方法是计算其像素数并乘以像素面积 $\\Delta x^2$。然后，晶圆CD是具有该面积的圆的直径：\n$$\nd_\\mathrm{wafer} = 2 \\sqrt{\\frac{A_\\mathrm{region}}{\\pi}}\n$$\n\n**5. MEEF计算**\nMEEF使用中心有限差分近似进行计算。这需要为两个扰动后的掩模CD模拟晶圆CD：$\\mathrm{CD}_\\text{mask}^+ = \\mathrm{CD}_\\text{mask} + \\Delta$ 和 $\\mathrm{CD}_\\text{mask}^- = \\mathrm{CD}_\\text{mask} - \\Delta$，其中 $\\Delta = 2 \\times 10^{-9}\\,\\text{m}$ 是掩模尺度上的扰动。这将产生两个晶圆CD，$d_\\mathrm{wafer}^+$ 和 $d_\\mathrm{wafer}^-$。\n\n如验证时所确立的，标准的无量纲MEEF是通过用缩小倍率 $M=4$ 来归一化掩模CD的变化来计算的：\n$$\n\\mathrm{MEEF} = \\frac{d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-}{(\\mathrm{CD}_\\text{mask}^+ - \\mathrm{CD}_\\text{mask}^-)/M} = M \\frac{d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-}{2\\Delta}\n$$\n对于多重图案案例，此过程应用于第一个掩模的CD ($\\mathrm{CD}_{\\text{mask},1}$)，而第二个掩模的CD ($\\mathrm{CD}_{\\text{mask},2}$)保持不变。晶圆CD $d_\\mathrm{wafer}^+$ 和 $d_\\mathrm{wafer}^-$ 是从组合的光强图像中测量的。\n\n整个算法在一个Python脚本中实现，该脚本处理三个测试案例中的每一个，计算相应的MEEF，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Main function to solve the MEEF calculation problem for the given test cases.\n    \"\"\"\n\n    # --- Physical and Simulation Constants (SI Units) ---\n    LAMBDA = 13.5e-9  # Wavelength (m)\n    NA = 0.33  # Numerical Aperture\n    M = 4.0  # Demagnification\n    PITCH = 64e-9  # Contact pitch (m)\n    DELTA_MASK = 2e-9  # CD perturbation on mask scale (m)\n    N_SOURCE_POINTS = 8\n\n    # --- Computational Grid ---\n    L_GRID = 512e-9  # Grid side length (m)\n    N_PIXELS = 256  # Grid resolution\n    DX = L_GRID / N_PIXELS  # Spatial sampling / pixel size (m)\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1: Single exposure, nominal\n        {'cd_mask': 140e-9, 'z': 0.0, 'sigma': 0.20, 'dose': 1.0, 't_th': 0.35, 'multi_pattern': False},\n        # Case 2: Single exposure, defocus and low dose\n        {'cd_mask': 140e-9, 'z': 100e-9, 'sigma': 0.20, 'dose': 0.85, 't_th': 0.35, 'multi_pattern': False},\n        # Case 3: Two-exposure multi-patterning\n        {'cd_mask1': 140e-9, 'cd_mask2': 140e-9, 'overlay': (3e-9, 0.0), 'z': 0.0, 'sigma': 0.20, 'dose': 1.0, 't_th': 0.35, 'multi_pattern': True},\n    ]\n    \n    # Pre-calculate frequency grids and coordinates\n    x_coords = np.linspace(-L_GRID / 2, L_GRID / 2 - DX, N_PIXELS)\n    X, Y = np.meshgrid(x_coords, x_coords)\n    \n    freq_coords = np.fft.fftfreq(N_PIXELS, d=DX)\n    Fx, Fy = np.meshgrid(freq_coords, freq_coords)\n    F_sq = Fx**2 + Fy**2\n    \n    F_mag = np.sqrt(F_sq)\n    \n    # --- Helper Functions ---\n    \n    def create_mask(cd_mask, pitch, M, N, L, X, Y, pattern_type='all', overlay=(0,0)):\n        \"\"\"Creates a binary mask for a contact hole array.\"\"\"\n        mask = np.zeros((N, N))\n        cd_wafer = cd_mask / M\n        radius_sq = (cd_wafer / 2)**2\n        array_size = 7 # Use a 7x7 array\n        indices = range(-array_size // 2, array_size // 2 + 1)\n        \n        for i in indices:\n            for j in indices:\n                is_even = (i + j) % 2 == 0\n                if (pattern_type == 'all') or \\\n                   (pattern_type == 'even' and is_even) or \\\n                   (pattern_type == 'odd' and not is_even):\n                    \n                    cx = i * pitch + overlay[0]\n                    cy = j * pitch + overlay[1]\n                    hole = (X - cx)**2 + (Y - cy)**2 = radius_sq\n                    mask[hole] = 1.0\n        return mask\n\n    def calculate_aerial_image(mask, z, sigma, Fx, Fy, F_sq):\n        \"\"\"Calculates the aerial image using Abbe's method.\"\"\"\n        fc = NA / LAMBDA\n        \n        source_radius = sigma * fc\n        \n        object_spectrum = np.fft.fftshift(np.fft.fft2(mask))\n        defocus_term = np.exp(-1j * np.pi * LAMBDA * z * F_sq)\n\n        total_intensity = np.zeros_like(mask, dtype=float)\n        \n        for k in range(N_SOURCE_POINTS):\n            theta = 2 * np.pi * k / N_SOURCE_POINTS\n            sk_x = source_radius * np.cos(theta)\n            sk_y = source_radius * np.sin(theta)\n            \n            Fx_shifted = Fx - sk_x\n            Fy_shifted = Fy - sk_y\n            \n            pupil_shifted = (Fx_shifted**2 + Fy_shifted**2 = fc**2).astype(float)\n            \n            E_field_spectrum = pupil_shifted * defocus_term * object_spectrum\n            E_field = np.fft.ifft2(np.fft.ifftshift(E_field_spectrum))\n            total_intensity += np.abs(E_field)**2\n            \n        return total_intensity\n\n    def measure_wafer_cd(intensity, dose, t_th, dx):\n        \"\"\"Measures the wafer CD from the aerial image using a threshold model.\"\"\"\n        if intensity.max() == 0:\n            return 0.0\n        \n        norm_intensity = intensity / intensity.max()\n        binary_image = (dose * norm_intensity >= t_th).astype(int)\n        \n        labeled_array, num_features = label(binary_image)\n        \n        center_pixel_idx = N_PIXELS // 2\n        center_label = labeled_array[center_pixel_idx, center_pixel_idx]\n        \n        if center_label == 0:\n            return 0.0\n        \n        area_pixels = np.sum(labeled_array == center_label)\n        area_region = area_pixels * (dx**2)\n        d_wafer = 2 * np.sqrt(area_region / np.pi)\n        \n        return d_wafer\n\n    def compute_single_exposure_meef(params):\n        \"\"\"Computes MEEF for a single exposure case.\"\"\"\n        \n        def get_dwafer(cd_mask):\n            mask = create_mask(cd_mask, PITCH, M, N_PIXELS, L_GRID, X, Y)\n            intensity = calculate_aerial_image(mask, params['z'], params['sigma'], Fx, Fy, F_sq)\n            return measure_wafer_cd(intensity, params['dose'], params['t_th'], DX)\n\n        d_wafer_plus = get_dwafer(params['cd_mask'] + DELTA_MASK)\n        d_wafer_minus = get_dwafer(params['cd_mask'] - DELTA_MASK)\n\n        meef = M * (d_wafer_plus - d_wafer_minus) / (2 * DELTA_MASK)\n        return meef\n\n    def compute_multi_pattern_meef(params):\n        \"\"\"Computes MEEF for a multi-patterning case.\"\"\"\n        # Calculate aerial image for fixed mask 2\n        mask2 = create_mask(params['cd_mask2'], PITCH, M, N_PIXELS, L_GRID, X, Y,\n                            pattern_type='odd', overlay=params['overlay'])\n        intensity2 = calculate_aerial_image(mask2, params['z'], params['sigma'], Fx, Fy, F_sq)\n\n        def get_dwafer(cd_mask1):\n            mask1 = create_mask(cd_mask1, PITCH, M, N_PIXELS, L_GRID, X, Y, pattern_type='even')\n            intensity1 = calculate_aerial_image(mask1, params['z'], params['sigma'], Fx, Fy, F_sq)\n            total_intensity = intensity1 + intensity2\n            return measure_wafer_cd(total_intensity, params['dose'], params['t_th'], DX)\n\n        d_wafer_plus = get_dwafer(params['cd_mask1'] + DELTA_MASK)\n        d_wafer_minus = get_dwafer(params['cd_mask1'] - DELTA_MASK)\n\n        meef = M * (d_wafer_plus - d_wafer_minus) / (2 * DELTA_MASK)\n        return meef\n\n    # --- Main Calculation Loop ---\n    results = []\n    for case in test_cases:\n        if not case['multi_pattern']:\n            meef = compute_single_exposure_meef(case)\n        else:\n            meef = compute_multi_pattern_meef(case)\n        results.append(meef)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "EUV光刻技术的独特之处在于其反射式光学系统，尤其是核心元件——布拉格反射镜掩模。这项高级实践将我们的焦点从通用成像系统转向EUV掩模的物理层面。你需要实现特征矩阵法来严格计算多层膜的反射率，并将其作为成像仿真的输入。这项练习将掩模的材料科学属性和制造参数（如多层膜周期、界面粗糙度）与最终的光刻性能指标（如最佳焦面和最大衬度）直接联系起来，深刻揭示了EUV技术中材料、物理与图形化工艺之间紧密的耦合关系 。",
            "id": "4125089",
            "problem": "您的任务是建立一个严谨的、自洽的计算模型，用以量化反射式极紫外（EUV）掩模版的空间像对多层膜周期和界面粗糙度微小扰动的响应。使用一维标量傅里叶光学模型进行相干成像，并使用特征矩阵法计算正入射下的多层膜反射率。目标是进行参数扫描，评估像衬度随离焦的变化，并报告最佳焦点衬度和最佳焦点设置相对于一个已定义基准的变化量。\n\n请从以下基本依据出发：\n\n- 麦克斯韦方程组可以推导出分层介质的菲涅尔边界条件，而由此得到的薄膜特征矩阵法可确定多层膜在正入射时的振幅反射率。\n- 标量傅里叶光学将相干成像建模为一个带限线性系统，其中光瞳传递函数以一个依赖于离焦的相位来过滤空间频率。\n- 空间像衬度定义为 $C = (I_{\\max} - I_{\\min})/(I_{\\max} + I_{\\min})$，其中 $I_{\\max}$ 和 $I_{\\min}$ 是像在一个周期内的最大和最小光强。\n\n需要实现的模型组件：\n\n1. 多层膜反射率：\n   - EUV反射式掩模版由 $N$ 个双层膜构成，这两种材料的复折射率分别为 $n_1$ 和 $n_2$，双层膜周期为 $d$。设两层厚度分别为 $t_1 = \\Gamma d$ 和 $t_2 = (1 - \\Gamma) d$，其中 $\\Gamma \\in (0,1)$ 是厚度比。假设从折射率为 $n_0 = 1$ 的真空入射，基底折射率为 $n_s$。\n   - 在正入射条件下，定义波数 $k_0 = 2\\pi / \\lambda$。对于折射率为 $n_j$、厚度为 $t_j$ 的第 $j$ 层，定义其相位 $\\delta_j = k_0 n_j t_j$ 和光学导纳 $y_j = n_j$。第 $j$ 层的特征矩阵为\n     $$M_j = \\begin{pmatrix}\n     \\cos \\delta_j   \\frac{i}{y_j} \\sin \\delta_j \\\\\n     i y_j \\sin \\delta_j   \\cos \\delta_j\n     \\end{pmatrix}.$$\n     总膜堆矩阵 $M$ 是从顶部（靠近 $n_0$）到基底所有层矩阵的有序乘积。对于 $M = \\begin{pmatrix} A   B \\\\ C   D \\end{pmatrix}$ 和基底导纳 $y_s = n_s$，输入导纳为\n     $$y_{\\text{in}} = \\frac{C + D y_s}{A + B y_s},$$\n     顶部界面的振幅反射系数为\n     $$r_{\\text{ML}} = \\frac{y_0 - y_{\\text{in}}}{y_0 + y_{\\text{in}}}, \\quad y_0 = n_0.$$\n   - 使用 Nevot–Croce 型乘性衰减因子来考虑界面粗糙度对振幅反射率的影响：\n     $$F_{\\text{rough}}(\\sigma) = \\exp\\left( - \\left( \\frac{4 \\pi \\sigma}{\\lambda} \\right)^2 \\right),$$\n     并将透明（非吸收）区域的振幅反射率设为 $r_{\\text{clear}} = F_{\\text{rough}}(\\sigma) \\, r_{\\text{ML}}$。\n   - 将吸收区域的振幅反射率建模为 $r_{\\text{abs}} = \\alpha \\, r_{\\text{clear}}$，其中固定的振幅缩放因子 $0  \\alpha  1$ 代表吸收衰减。\n\n2. 掩模版图形及其傅里叶频谱：\n   - 考虑一个周期为 $P$、占空比为 $D$ 的一维线空间反射式掩模版。在一个周期内，振幅反射率定义为\n     $$m(x) = \\begin{cases}\n     r_{\\text{clear}},   0 \\le x  D P, \\\\\n     r_{\\text{abs}},   D P \\le x  P,\n     \\end{cases}$$\n     且被周期性延拓。通过在一个周期内对 $m(x)$ 进行均匀采样并应用离散傅里叶变换，来计算其离散傅里叶级数系数。\n\n3. 成像与离焦：\n   - 使用相干成像，其光瞳为圆形，数值孔径为 $\\mathrm{NA}$。相干截止空间频率为\n     $$f_c = \\frac{\\mathrm{NA}}{\\lambda} \\quad \\text{（单位：周期/纳米）}.$$\n   - 对于每个空间频率 $f$，当 $|f| \\le f_c$ 时，相干传递函数的振幅为1，并施加一个与离焦相关的相位。使用光瞳边缘处的主离焦系数 $W_{20}$（单位：波长）来参数化离焦。传递函数的相位为\n     $$\\phi(f; W_{20}) = \\pi W_{20} \\left( \\frac{f}{f_c} \\right)^2.$$\n     超出截止频率的频率将被阻断。对于每个 $W_{20}$，用此传递函数对掩模版频谱进行滤波，并通过逆变换计算像场；空间像光强是该复数场的模的平方。\n\n4. 衬度与最佳焦点：\n   - 对于给定的 $(d, \\sigma)$，在一系列 $W_{20}$ 扫描值下，计算一个周期内的空间像光强，并确定：\n     - 最佳焦点衬度 $C^{\\star}(d,\\sigma)$，定义为离焦扫描范围内的最大衬度。\n     - 达到最大衬度时的最佳焦点设置 $W_{20}^{\\star}(d,\\sigma)$（单位：波长）。\n   - 在 $(d_0, \\sigma_0)$ 处定义一个基准，计算 $C^{\\star}_0$ 和 $W_{20,0}^{\\star}$，并对其他每个测试用例 $(d, \\sigma)$ 计算其变化量\n     $$\\Delta C^{\\star} = C^{\\star}(d,\\sigma) - C^{\\star}_0, \\quad \\Delta W_{20}^{\\star} = W_{20}^{\\star}(d,\\sigma) - W_{20,0}^{\\star}.$$\n\n使用以下固定的物理和模型参数：\n- 波长 $\\lambda = 13.5$ nm。\n- 数值孔径 $\\mathrm{NA} = 0.55$。\n- 双层膜数量 $N = 40$。\n- 厚度比 $\\Gamma = 0.40$。\n- 在波长 $\\lambda$ 下的复折射率：$n_1$ (钼) $= 0.920 - i \\, 0.006$, $n_2$ (硅) $= 0.999 - i \\, 0.003$, 基底 $n_s = 0.999 - i \\, 0.003$, 真空 $n_0 = 1$。\n- 吸收层振幅缩放因子 $\\alpha = 0.20$。\n- 掩模版周期 $P = 80$ nm，占空比 $D = 0.50$。\n- 离焦扫描 $W_{20} \\in [-1.0, 1.0]$ 波长，步长为 $0.01$ 波长，进行均匀采样（即 $201$ 个采样点）。\n\n测试组：\n- 基准用例: $(d_0, \\sigma_0) = (6.90 \\text{ nm}, 0.20 \\text{ nm})$。\n- 用例 1: $(d, \\sigma) = (6.95 \\text{ nm}, 0.20 \\text{ nm})$。\n- 用例 2: $(d, \\sigma) = (6.85 \\text{ nm}, 0.20 \\text{ nm})$。\n- 用例 3: $(d, \\sigma) = (6.90 \\text{ nm}, 0.30 \\text{ nm})$。\n- 用例 4: $(d, \\sigma) = (6.90 \\text{ nm}, 0.10 \\text{ nm})$。\n- 用例 5: $(d, \\sigma) = (7.00 \\text{ nm}, 0.35 \\text{ nm})$。\n- 用例 6: $(d, \\sigma) = (6.80 \\text{ nm}, 0.50 \\text{ nm})$。\n\n计算要求和输出规范：\n- 所有长度必须以纳米为单位处理。焦点参数 $W_{20}$ 必须以波长（无量纲）为单位进行处理和报告。\n- 对于上述6个非基准用例（用例1至用例6），计算相对于基准的 $\\Delta C^{\\star}$ 和 $\\Delta W_{20}^{\\star}$。\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的数对列表形式的结果，每个数对对应一个非基准用例，并用方括号括起来。每个数对本身是一个包含两个浮点数 $[\\Delta C^{\\star}, \\Delta W_{20}^{\\star}]$ 的列表。例如：\n\"[ [x1,y1],[x2,y2],... ]\"\n其中 $x_k$ 和 $y_k$ 是浮点数，分别代表用例 $k$ 的最佳焦点衬度变化量和最佳焦点设置变化量（单位：波长）。\n\n科学真实性：严格按照规定使用模型和参数；请勿引入上述描述之外的任何捷径、简化或替代公式。确保所有用例的数值稳定性和一致性。必须在一个周期内对空间像光强进行评估，并采用足够的采样率以捕获直至相干截止频率的各次谐波。\n\n您的实现必须是一个完整、可运行的程序，且不得需要任何外部输入。最终输出必须严格符合上述单行格式要求。",
            "solution": "该问题是有效的，因为它具有科学依据、提法恰当且目标明确。它提供了一套完整且一致的参数、物理模型和计算要求，用于模拟掩模版扰动对EUV空间像的影响。所指定的模型——用于多层膜反射率的特征矩阵法和用于相干成像的标量傅里叶光学——是完成此任务的标准且合适的方法。\n\n在此，我们遵循指定的方法论构建一个数值解。该过程分解为几个计算步骤：对多层膜反射率建模，定义掩模版轮廓及其频谱，模拟包含离焦的相干成像过程，最后进行参数扫描以找到最佳焦点和衬度。\n\n### 1. 多层膜反射镜反射率\nEUV掩模版的核心是一个布拉格反射器，它由$N$个交替材料组成的双层膜构成。此膜堆的反射率使用特征矩阵法计算。\n\n物理参数为：波长 $\\lambda = 13.5$ nm，双层膜数量 $N = 40$，厚度比 $\\Gamma = 0.40$，以及钼（$n_1 = 0.920 - i \\, 0.006$）、硅（$n_2 = 0.999 - i \\, 0.003$）、基底（$n_s = 0.999 - i \\, 0.003$）和真空（$n_0 = 1$）的复折射率。为保证化学稳定性，标准的EUV多层膜堆以硅为顶层，这意味着从真空到基底的膜层序列为$(\\text{Si}, \\text{Mo}) \\times N$。因此，第一层的折射率为 $n_2$，厚度为 $t_2 = (1-\\Gamma)d$；第二层的折射率为 $n_1$，厚度为 $t_1 = \\Gamma d$，其中 $d$ 是双层膜周期。\n\n对于膜堆中的每一层 $j$，其特征矩阵 $M_j$ 关联了穿过该层的切向电场和磁场。在正入射下，该矩阵由下式给出：\n$$\nM_j = \\begin{pmatrix}\n\\cos \\delta_j   \\frac{i}{y_j} \\sin \\delta_j \\\\\ni y_j \\sin \\delta_j   \\cos \\delta_j\n\\end{pmatrix}\n$$\n其中 $y_j = n_j$ 是光学导纳，平面波穿过该层的相位累积为 $\\delta_j = k_0 n_j t_j$，而 $k_0 = 2\\pi/\\lambda$ 是真空波数。\n\n$2N$ 层的膜堆的总特征矩阵是单个矩阵从上到下依次相乘的积：\n$$\nM = M_1 M_2 \\cdots M_{2N} = \\begin{pmatrix} A   B \\\\ C   D \\end{pmatrix}\n$$\n在膜堆顶部，朝向导纳为 $y_s = n_s$ 的基底方向看的输入导纳为：\n$$\ny_{\\text{in}} = \\frac{C + D y_s}{A + B y_s}\n$$\n那么，在真空（导纳 $y_0 = n_0 = 1$）和多层膜堆之间的界面处的振幅反射系数 $r_{\\text{ML}}$ 为：\n$$\nr_{\\text{ML}} = \\frac{y_0 - y_{\\text{in}}}{y_0 + y_{\\text{in}}}\n$$\n层间界面粗糙度会降低反射率。这通过一个 Nevot–Croce 因子建模，该因子与理想振幅反射率相乘：\n$$\nr_{\\text{clear}} = F_{\\text{rough}}(\\sigma) \\, r_{\\text{ML}} = \\exp\\left( - \\left( \\frac{4 \\pi \\sigma}{\\lambda} \\right)^2 \\right) r_{\\text{ML}}\n$$\n其中 $\\sigma$ 是均方根界面粗糙度。此处的 $r_{\\text{clear}}$ 是掩模版上“透明”或高反射区域的反射率。\n\n### 2. 掩模版图形和傅里叶频谱\n掩模版是一个周期为 $P=80$ nm、占空比为 $D=0.5$ 的一维周期性线空间图形。吸收区域的反射率按因子 $\\alpha = 0.20$ 进行缩放。掩模版在一个周期内的复振幅反射率函数为：\n$$\nm(x) = \\begin{cases}\nr_{\\text{clear}},   0 \\le x  D P \\\\\nr_{\\text{abs}},   D P \\le x  P\n\\end{cases}\n\\quad \\text{其中 } r_{\\text{abs}} = \\alpha \\, r_{\\text{clear}}\n$$\n为了在频域中进行分析，我们计算其离散傅里叶级数系数。这通过在一个周期内对 $m(x)$ 进行采样并应用快速傅里叶变换（FFT）来数值完成。采样点数必须足以解析出光学系统所能通过的所有空间频率。\n\n### 3. 相干成像与离焦\n成像系统被建模为一个数值孔径 $\\mathrm{NA} = 0.55$ 的相干低通线性系统。相干传递函数（CTF）$H(f)$ 仅在空间频率 $|f|$ 直到截止频率 $f_c = \\mathrm{NA} / \\lambda$ 的范围内非零。\n$$\nf_c = \\frac{0.55}{13.5 \\text{ nm}} \\approx 0.04074 \\text{ nm}^{-1}\n$$\n掩模版的基频空间频率为 $1/P = 1/80 \\text{ nm} = 0.0125 \\text{ nm}^{-1}$。该系统将通过直流分量（0级）以及 $\\pm 1$、$\\pm 2$ 和 $\\pm 3$ 级衍射级次，因为 $|3/P| = 0.0375 \\text{ nm}^{-1}  f_c$。\n\n离焦作为光瞳中的一个二次相位误差被引入。由离焦系数 $W_{20}$（单位：波长）参数化的CTF为：\n$$\nH(f; W_{20}) = \\begin{cases}\n\\exp\\left(i \\pi W_{20} \\left( \\frac{f}{f_c} \\right)^2\\right),   |f| \\le f_c \\\\\n0,   |f|  f_c\n\\end{cases}\n$$\n空间像场 $E_{\\text{image}}(f)$ 的傅里叶频谱是掩模版频谱 $M(f)$ 和CTF的乘积：\n$$\nE_{\\text{image}}(f) = M(f) H(f; W_{20})\n$$\n一次逆FFT产生复数像场 $E_{\\text{image}}(x)$，而空间像光强是其模的平方，$I(x) = |E_{\\text{image}}(x)|^2$。\n\n### 4. 衬度与最佳焦点确定\n空间像的质量由其衬度量化，定义为：\n$$\nC = \\frac{I_{\\max} - I_{\\min}}{I_{\\max} + I_{\\min}}\n$$\n其中 $I_{\\max}$ 和 $I_{\\min}$ 是周期性像中的最大和最小光强。\n\n对于每一组掩模版参数 $(d, \\sigma)$，我们在离焦值范围 $W_{20} \\in [-1.0, 1.0]$ 内计算衬度 $C$。最佳焦点衬度 $C^{\\star}(d, \\sigma)$ 是在此扫描中找到的最大衬度，而最佳焦点设置 $W_{20}^{\\star}(d, \\sigma)$ 是出现此最大值时的 $W_{20}$ 值。\n\n### 5. 参数化分析\n在 $(d_0, \\sigma_0) = (6.90 \\text{ nm}, 0.20 \\text{ nm})$ 定义一个基准用例，得到基准值 $C^{\\star}_0$ 和 $W_{20,0}^{\\star}$。对于其他几个测试用例 $(d, \\sigma)$，我们计算它们各自的 $C^{\\star}$ 和 $W_{20}^{\\star}$，并报告相对于基准的变化量：\n$$\n\\Delta C^{\\star} = C^{\\star}(d,\\sigma) - C^{\\star}_0, \\quad \\Delta W_{20}^{\\star} = W_{20}^{\\star}(d,\\sigma) - W_{20,0}^{\\star}\n$$\n该分析量化了图像质量和最佳焦点对多层膜周期和界面粗糙度微小变化的灵敏度，这些都是EUV掩模版制造中的关键参数。最终输出汇总了所有指定测试用例的这些差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the EUV lithography modeling problem.\n    This function is self-contained and houses all constants, helper functions,\n    and the main execution logic.\n    \"\"\"\n\n    # ------------------ Physical and Model Parameters ------------------\n    LAMBDA = 13.5  # Wavelength in nm\n    NA = 0.55      # Numerical aperture\n    N_BILAYER = 40 # Number of bilayers\n    GAMMA = 0.40   # Thickness ratio t_Mo / (t_Mo + t_Si)\n    # Complex refractive indices\n    N1 = 0.920 - 0.006j  # Mo\n    N2 = 0.999 - 0.003j  # Si\n    N_S = 0.999 - 0.003j # Substrate (assumed Si)\n    N0 = 1.0 + 0.0j      # Vacuum\n    ALPHA = 0.20   # Absorber amplitude scaling\n    PITCH = 80.0   # Mask pitch in nm\n    DUTY_CYCLE = 0.50 # Mask duty cycle\n    W20_SWEEP = np.linspace(-1.0, 1.0, 201) # Defocus sweep in waves\n\n    # ------------------ Derived Constants and Settings -----------------\n    K0 = 2 * np.pi / LAMBDA          # Vacuum wavenumber\n    F_C = NA / LAMBDA                # Coherent cutoff frequency\n    N_SAMPLES_MASK = 256             # Spatial sampling for FFT\n\n    # ------------------ Helper Functions ------------------\n\n    def calculate_r_clear(d, sigma):\n        \"\"\"\n        Calculates the clear field amplitude reflectivity r_clear using the\n        characteristic matrix method for a given bilayer period d and roughness sigma.\n        \"\"\"\n        t_mo = GAMMA * d\n        t_si = (1.0 - GAMMA) * d\n        \n        # Stack assumes Si-termination: Air | (Si/Mo) * N | Substrate\n        layers = [(N2, t_si), (N1, t_mo)] * N_BILAYER\n\n        y0 = N0\n        ys = N_S\n        \n        M_total = np.identity(2, dtype=np.complex128)\n        \n        for n_j, t_j in layers:\n            y_j = n_j\n            delta_j = K0 * n_j * t_j\n            \n            cos_delta = np.cos(delta_j)\n            sin_delta = np.sin(delta_j)\n            \n            M_j = np.array([\n                [cos_delta, (1j / y_j) * sin_delta],\n                [1j * y_j * sin_delta, cos_delta]\n            ], dtype=np.complex128)\n            \n            M_total = M_total @ M_j\n            \n        A, B = M_total[0, 0], M_total[0, 1]\n        C, D = M_total[1, 0], M_total[1, 1]\n        \n        y_in = (C + D * ys) / (A + B * ys)\n        \n        r_ml = (y0 - y_in) / (y0 + y_in)\n        \n        f_rough = np.exp(-((4 * np.pi * sigma / LAMBDA)**2))\n        \n        r_clear = f_rough * r_ml\n        \n        return r_clear\n\n    def calculate_mask_spectrum(r_clear):\n        \"\"\"\n        Calculates the Fourier spectrum of the 1D periodic mask.\n        \"\"\"\n        r_abs = ALPHA * r_clear\n        \n        m_x = np.zeros(N_SAMPLES_MASK, dtype=np.complex128)\n        \n        num_clear_samples = int(round(N_SAMPLES_MASK * DUTY_CYCLE))\n        m_x[:num_clear_samples] = r_clear\n        m_x[num_clear_samples:] = r_abs\n        \n        m_f = np.fft.fft(m_x)\n        freqs = np.fft.fftfreq(N_SAMPLES_MASK, d=PITCH / N_SAMPLES_MASK)\n        \n        return m_f, freqs\n\n    def calculate_contrast(m_f, freqs, w20):\n        \"\"\"\n        Calculates the aerial image contrast for a given mask spectrum and defocus.\n        \"\"\"\n        ctf = np.zeros_like(m_f, dtype=np.complex128)\n        \n        norm_freq_sq = (freqs / F_C)**2\n        valid_freq_mask = np.abs(freqs) = F_C\n        \n        phase = np.pi * w20 * norm_freq_sq[valid_freq_mask]\n        ctf[valid_freq_mask] = np.exp(1j * phase)\n            \n        image_f = m_f * ctf\n        image_x_field = np.fft.ifft(image_f)\n        image_intensity = np.abs(image_x_field)**2\n        \n        i_max = np.max(image_intensity)\n        i_min = np.min(image_intensity)\n        \n        if i_max + i_min  1e-12:  # Avoid division by zero\n            return 0.0\n        \n        contrast = (i_max - i_min) / (i_max + i_min)\n        return contrast\n\n    def find_best_focus(d, sigma):\n        \"\"\"\n        Performs a defocus sweep to find the best-focus contrast C* and\n        the corresponding best-focus setting W20*.\n        \"\"\"\n        r_clear = calculate_r_clear(d, sigma)\n        m_f, freqs = calculate_mask_spectrum(r_clear)\n        \n        contrasts = np.array([calculate_contrast(m_f, freqs, w20) for w20 in W20_SWEEP])\n        \n        max_contrast_idx = np.argmax(contrasts)\n        c_star = contrasts[max_contrast_idx]\n        w20_star = W20_SWEEP[max_contrast_idx]\n        \n        return c_star, w20_star\n\n    # ------------------ Main Execution Logic ------------------\n    \n    # Define the test cases from the problem statement.\n    baseline_case = (6.90, 0.20)\n    test_cases = [\n        (6.95, 0.20),  # Case 1\n        (6.85, 0.20),  # Case 2\n        (6.90, 0.30),  # Case 3\n        (6.90, 0.10),  # Case 4\n        (7.00, 0.35),  # Case 5\n        (6.80, 0.50),  # Case 6\n    ]\n\n    # Calculate results for the baseline case\n    c_star_0, w20_star_0 = find_best_focus(*baseline_case)\n\n    results = []\n    for d_case, sigma_case in test_cases:\n        c_star, w20_star = find_best_focus(d_case, sigma_case)\n        delta_c = c_star - c_star_0\n        delta_w20 = w20_star - w20_star_0\n        results.append([delta_c, delta_w20])\n\n    # Final print statement in the exact required format.\n    # Convert numpy floats to standard Python floats for clean string representation\n    formatted_results = [[float(f'{dc:.6f}'), float(f'{dw:.6f}')] for dc, dw in results]\n    print(f\"[{','.join(map(str, formatted_results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}