{
    "hands_on_practices": [
        {
            "introduction": "光刻仿真的基石在于理解光学系统如何形成图像。本练习将引导你运用傅里叶光学和阿贝成像理论，从第一性原理出发，计算一个基本的一维光栅在部分相干光照明下所产生的航拍图像。通过亲手实现这个模型，你将深入理解光源形状、波长和数值孔径等关键参数如何共同决定最终图像的对比度和分辨率。",
            "id": "4125078",
            "problem": "考虑一个一维二元线空间光栅，其晶圆侧的周期为 $p$，占空比为 $f$，由波长为 $\\lambda$ 的部分相干偶极光源在极紫外（EUV）下进行照明。成像系统被建模为一个薄的、标量的、焦内 Abbe 成像系统，其数值孔径（NA）为 $\\mathrm{NA}$。假设光栅沿 $y$ 轴不变，沿 $x$ 轴周期性分布。通过相干性参数 $\\sigma$ 定义部分相干光源，使得两个偶极点沿某一选定方向位于空间频率偏移 $\\pm \\sigma \\,\\mathrm{NA}/\\lambda$ 处。\n\n您的任务是使用基于傅里叶光学和标量衍射理论的第一性原理方法，计算光栅在晶圆上的衍射图像衬比度。衍射图像定义为像平面上的光强分布，它是由每个偶极光源点形成的相干图像的非相干叠加产生的。基本依据必须包括：\n- 标量衍射理论和傅里叶光学的定义，特别是周期性结构可以由傅里叶级数谐波表示，其空间频率为 $m/p$（$m$ 为整数）。\n- 用于部分相干照明的 Abbe 成像原理，其中每个光源点对应一个倾斜的平面波，该平面波会使掩模频谱在光瞳中发生位移，只有位移后的空间频率位于光瞳内的谐波才能通过。\n- 对于给定的空间频率 $k_x$，其通过带条件由光瞳截止频率 $k_c = \\mathrm{NA}/\\lambda$ 决定。\n\n科学真实性约束：\n- EUV 照明使用 $\\lambda = 13.5\\ \\mathrm{nm}$。\n- 将掩模视为一个薄的振幅物体，其在透光部分（线）的透射率为1，在不透光部分（空间）的透射率为0。\n- 仅考虑零级、一级和二级衍射级次，即整数谐波 $m \\in \\{-2,-1,0,1,2\\}$。\n- 偶极光源可以沿 $x$ 轴方向（在 $k_x$ 上有位移）或沿 $y$ 轴方向（对于一维 $x$ 方向变化的光栅，在 $k_x$ 上无位移）。\n\n推导所需的定义：\n- 光瞳截止频率为 $k_c = \\mathrm{NA}/\\lambda$，单位为 $\\mathrm{nm}^{-1}$。\n- 对于沿 $x$ 轴方向的光源，两个光源点位于 $k_x$ 中的 $k_{s} = \\pm \\sigma\\, k_c$ 处。对于沿 $y$ 轴方向，在 $k_x$ 上没有位移（即，对于此一维模型，$k_s = 0$）。\n- 占空比为 $f$ 的二元线空间光栅的傅里叶级数系数 $c_m$ 定义为 $c_0 = f$ 和 $c_m = \\dfrac{\\sin(\\pi m f)}{\\pi m}$（对于 $m \\neq 0$）。\n- 对于给定的光源点，一个 $m$ 级谐波能够通过当且仅当 $\\left|k_s + \\dfrac{m}{p}\\right| \\le k_c$。\n\n计算过程要求：\n- 对每个光源点，计算其相干场，即在一个空间周期 $x \\in [0,p]$ 内对所有通过的谐波 $m \\in \\{-2,-1,0,1,2\\}$ 进行求和。\n- 总衍射图像光强是两个光源点产生的光强的非相干叠加。\n- 衍射图像衬比度定义为 $C = \\dfrac{I_{\\max} - I_{\\min}}{I_{\\max} + I_{\\min}}$，其中 $I_{\\max}$ 和 $I_{\\min}$ 是在一个周期 $x \\in [0,p]$ 内的最大和最小光强。\n\n单位和数值规范：\n- 所有长度单位必须为 $\\mathrm{nm}$，空间频率单位为 $\\mathrm{nm}^{-1}$。\n- 将最终的衬比度值表示为小数（无百分号），并四舍五入到六位小数。\n\n测试集：\n提供以下五组参数集的结果，每组参数格式为 $(p,\\ \\mathrm{NA},\\ \\sigma,\\ \\text{orientation},\\ f)$，其中方向为 $x$ 或 $y$：\n1. 基准情况，偶极子沿 $x$ 轴，处于截止限制周期：$(40\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n2. 相同周期，但偶极子沿 $y$ 轴（无 $k_x$ 位移）：$(40\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ y,\\ 0.5)$。\n3. 更大周期，允许二级衍射通过偶极子传输：$(60\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n4. 边界情况，对于每个偶极子叶，一级衍射中心位于光瞳中心：$(81.8181818182\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n5. 小周期，即使使用偶极子，一级或二级衍射也无法传输：$(25\\ \\mathrm{nm},\\ 0.33,\\ 0.5,\\ x,\\ 0.5)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[$c_1$,$c_2$,$c_3$,$c_4$,$c_5$]”），其中 $c_i$ 是按上述顺序列出的测试案例的衬比度值，四舍五入到六位小数。",
            "solution": "该问题陈述已经过严格验证，被确定为半导体光刻建模领域中一个定义明确、具有科学依据的问题。它提供了计算唯一且有意义的解所需的所有必要参数、定义和约束。该问题没有矛盾、歧义和事实错误。\n\n该解决方案计算了部分相干 EUV 照明下的一维线空间光栅的衍射图像衬比度。该方法基于傅里叶光学和标量衍射理论的原理，并应用于 Abbe 图像形成模型。\n\n基本原理是，周期性物体（如光栅）可以用其傅里叶级数表示。刚好通过掩模后的光的复电场（物场）可以写为：\n$$\nE_{\\text{obj}}(x) = \\sum_{m=-\\infty}^{\\infty} c_m e^{i 2\\pi (m/p) x}\n$$\n其中 $p$ 是光栅的周期，$c_m$ 是傅里叶级数系数。对于占空比为 $f$（周期中透明部分的比例）的二元光栅，其系数由下式给出：\n$$\nc_0 = f\n$$\n$$\nc_m = \\frac{\\sin(\\pi m f)}{\\pi m} \\quad \\text{for } m \\neq 0\n$$\n问题指定我们只需要考虑衍射级次 $m \\in \\{-2, -1, 0, 1, 2\\}$。\n\n成像系统的物镜充当空间频率滤波器。在标量薄透镜近似中，此滤波器由一个光瞳函数表示，该函数仅在空间频率 $k_x$ 的大小小于或等于截止频率 $k_c$ 时非零。该截止频率由透镜的数值孔径 $\\mathrm{NA}$ 和光的波长 $\\lambda$ 决定：\n$$\nk_c = \\frac{\\mathrm{NA}}{\\lambda}\n$$\n只有光瞳平面中圆 $|k| \\le k_c$ 内的空间频率才能通过透镜传输。\n\n部分相干照明通过将光源视为一组相互非相干的点光源来建模。对于偶极光源，存在两个这样的点。每个光源点都以一个倾斜的平面波照射掩模。源平面中空间频率位置为 $k_s$ 的光源点，会有效地将物体的衍射图样（其傅里叶频谱）在光瞳平面中移动 $-k_s$。因此，对于位于 $k_{s,j}$ 处的给定光源点 $j$，具有空间频率 $k_m = m/p$ 的衍射级次 $m$ 将在其位移后的频率落入光瞳通带内时通过透镜：\n$$\n|k_{s,j} + k_m| \\le k_c\n$$\n对于每个光源点 $j$，像平面中的电场 $E_j(x)$ 是通过仅对传输的谐波求和而形成的。为简单起见，假设单位放大倍率，该场为：\n$$\nE_j(x) = \\sum_{m \\in \\{-2,...,2\\}} c_m \\cdot T_j(m) \\cdot e^{i 2\\pi (m/p) x}\n$$\n其中 $T_j(m)$ 是第 $j$ 个光源点和第 $m$ 级衍射的二元传输因子：\n$$\nT_j(m) = \\begin{cases} 1  \\text{if } |k_{s,j} + m/p| \\le k_c \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n问题指定了偶极光源。对于沿 $x$ 轴方向的偶极子，两个光源点位于 $k_x = \\pm \\sigma k_c$。因此，光源位移为 $k_{s,1} = +\\sigma k_c$ 和 $k_{s,2} = -\\sigma k_c$。对于沿 $y$ 轴方向的偶极子，问题指出这在这个一维模型的 $k_x$ 维度上不产生位移，因此我们对两个光源点都取 $k_s = 0$。\n\n由于光源点是相互非相干的，总衍射图像光强 $I(x)$ 是每个光源点单独产生的光强的总和：\n$$\nI(x) = \\sum_{j=1}^{2} |E_j(x)|^2 = |E_1(x)|^2 + |E_2(x)|^2\n$$\n最后，衍射图像衬比度 $C$ 是根据光栅一个周期（$x \\in [0, p]$）内的总光强的最大值（$I_{\\max}$）和最小值（$I_{\\min}$）计算得出的：\n$$\nC = \\frac{I_{\\max} - I_{\\min}}{I_{\\max} + I_{\\min}}\n$$\n$C=1$ 的值表示完美的衬比度，而 $C=0$ 表示没有调制（平场），意味着图案没有被分辨出来。\n\n计算过程如下：\n1.  对于每个具有参数 $(p, \\mathrm{NA}, \\sigma, \\text{orientation}, f)$ 的测试案例，设置 EUV 波长 $\\lambda = 13.5 \\ \\mathrm{nm}$。\n2.  计算光瞳截止频率 $k_c = \\mathrm{NA}/\\lambda$。\n3.  确定光源点位置 $\\{k_{s,j}\\}$。对于 'x' 方向，$k_{s,j} = \\{\\sigma k_c, -\\sigma k_c\\}$。对于 'y' 方向，$k_{s,j} = \\{0, 0\\}$。\n4.  在 $x \\in [0, p]$ 的空间网格上，将总光强数组 $I(x)$ 初始化为零。\n5.  对于每个光源点 $k_{s,j}$：\n    a. 将复电场数组 $E_j(x)$ 初始化为零。\n    b. 对于每个衍射级次 $m \\in \\{-2, -1, 0, 1, 2\\}$：\n        i. 使用条件 $|k_{s,j} + m/p| \\le k_c$ 检查该级次是否被传输。\n        ii. 如果它被传输，计算傅里叶系数 $c_m$ 并将项 $c_m e^{i 2\\pi (m/p) x}$ 添加到 $E_j(x)$ 中。\n    c. 计算该光源的光强 $|E_j(x)|^2$，并将其加到总光强 $I(x)$ 中。\n6.  找到最终 $I(x)$ 数组的最大值和最小值。\n7.  使用其定义计算衬比度 $C$。如果 $I_{\\max} + I_{\\min}$ 为零，则衬比度定义为 $0$。\n\n对每个提供的测试案例实施此过程，以找到所需的衬比度值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aerial image contrast for several EUV lithography scenarios.\n    \n    The solution is based on Fourier optics and the Abbe theory of image formation.\n    It models a 1D binary grating illuminated by a partially coherent dipole\n    source and imaged by a scalar, in-focus system.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (p, NA, sigma, orientation, f)\n    # where p is pitch (nm), NA is numerical aperture, sigma is coherence parameter,\n    # orientation is 'x' or 'y', f is duty cycle.\n    test_cases = [\n        (40.0, 0.33, 0.5, 'x', 0.5),\n        (40.0, 0.33, 0.5, 'y', 0.5),\n        (60.0, 0.33, 0.5, 'x', 0.5),\n        (900.0 / 11.0, 0.33, 0.5, 'x', 0.5),  # p = 81.8181... nm\n        (25.0, 0.33, 0.5, 'x', 0.5)\n    ]\n    \n    LAMBDA = 13.5  # EUV wavelength in nm\n    ORDERS = [-2, -1, 0, 1, 2] # Diffraction orders to consider\n    NUM_SAMPLES = 1000  # Number of points for spatial grid over one period\n\n    results = []\n    \n    for case in test_cases:\n        p, NA, sigma, orientation, f = case\n\n        # Step 1: Calculate derived parameters\n        kc = NA / LAMBDA  # Pupil cutoff frequency in nm^-1\n\n        # Step 2: Determine source point locations in k_x space\n        if orientation == 'x':\n            ks_vals = [sigma * kc, -sigma * kc]\n        elif orientation == 'y':\n            # For a 1D grating, a y-oriented dipole produces no k_x shift.\n            # We model this as two on-axis source points.\n            ks_vals = [0.0, 0.0]\n        else:\n            raise ValueError(\"Orientation must be 'x' or 'y'\")\n            \n        # Step 3: Define spatial grid and initialize total intensity\n        x_grid = np.linspace(0, p, NUM_SAMPLES, endpoint=False)\n        total_intensity = np.zeros_like(x_grid)\n\n        # Step 4: Loop over incoherent source points\n        for ks in ks_vals:\n            coherent_field = np.zeros_like(x_grid, dtype=np.complex128)\n\n            # Step 5: For each source, sum transmitted diffraction orders\n            for m in ORDERS:\n                km = m / p  # Spatial frequency of the m-th order\n                \n                # Pupil passband condition\n                if np.abs(ks + km) <= kc:\n                    # Calculate Fourier coefficient c_m\n                    if m == 0:\n                        cm = f\n                    else:\n                        # Handle potential division by zero for m=0, though separated\n                        cm = np.sin(np.pi * m * f) / (np.pi * m)\n                    \n                    # Add harmonic's contribution to the coherent field\n                    coherent_field += cm * np.exp(1j * 2 * np.pi * km * x_grid)\n            \n            # Step 6: Accumulate intensities (incoherent sum)\n            total_intensity += np.abs(coherent_field)**2\n            \n        # Step 7: Calculate contrast from the total aerial image intensity\n        if total_intensity.size > 0:\n            I_max = np.max(total_intensity)\n            I_min = np.min(total_intensity)\n        else:\n            I_max, I_min = 0, 0\n\n        denominator = I_max + I_min\n        if denominator > 1e-12: # Check for non-zero denominator to avoid division by zero\n            contrast = (I_max - I_min) / denominator\n        else:\n            contrast = 0.0\n            \n        results.append(f\"{contrast:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了一维模型的基础上，我们将挑战更贴近实际生产的二维图形，并引入关键的工艺控制指标。本练习将模拟一个接触孔阵列的航拍图像，并计算其掩模误差增强因子（MEEF），这是一个衡量光刻工艺稳健性的核心参数。通过这个实践，你将学会如何量化掩模制造误差在晶圆上的放大效应，并初步探索多重曝光技术对工艺控制的影响。",
            "id": "4125029",
            "problem": "要求您实现一个计算模型，以估算极紫外（EUV）光刻接触孔阵列的掩模误差增强因子（MEEF）。MEEF量化了掩模关键尺寸（CD）的误差如何转化为晶圆CD的误差，并定义为晶圆CD对掩模CD的灵敏度。具体来说，您将通过对指定聚焦和剂量矩阵下的光刻胶阈值显影模型中的模拟光场像，对晶圆CD关于掩模CD进行数值微分来计算MEEF。\n\n使用以下科学基础和建模假设：\n\n- 极紫外（EUV）光刻的工作波长为 $\\lambda = 13.5 \\,\\text{nm}$。数值孔径（NA）是空间频率空间中的光瞳半径。\n- 光场像使用标量傅里叶光学，在部分相干照明的Abbe成像条件下进行建模，通过离散光源点的相干图像的非相干叠加来近似。\n- 光瞳函数 $P(\\mathbf{f})$ 是空间频率坐标 $\\mathbf{f} = (f_x,f_y)$ 中的一个圆形孔径，其通带半径为 $f_c = \\mathrm{NA}/\\lambda$。对于像平面的离焦距离 $z$，相干传递函数包含二次相位项 $\\exp\\!\\left(-i \\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2\\right)$。\n- 部分相干性由频率空间中半径为 $s = \\sigma f_c$ 的圆上的一组光源点表示，其中 $\\sigma$ 是部分相干因子。光场强度是所有光源点产生的像的强度之和，每个像的强度是移动后的光瞳与物频谱乘积的傅里葉逆变换的模平方。\n- 接触孔阵列的物是一个二元振幅透射函数 $A(x,y)$，由排列在间距为 $p$ 的方形网格上的圆形开口组成，每个开口的半径为 $r = \\frac{1}{2}\\, \\mathrm{CD}_\\text{mask} / M$，其中 $M$ 是投影缩小倍率（使用 $M=4$）。此处的 $\\mathrm{CD}_\\text{mask}$ 是在掩模尺度上指定的；光场像是在晶圆尺度上计算的。\n- 光刻胶阈值模型是二元的：通过将计算出的强度除以给定情景下仿真域内的最大值，来定义归一化光场强度 $I_\\mathrm{norm}(x,y)$。对于给定的剂量因子 $D$ 和阈值 $T_\\mathrm{th}$（无量纲），当 $D \\, I_\\mathrm{norm}(x,y) \\ge T_\\mathrm{th}$ 时，光刻胶被清除（在晶圆上形成一个孔）。\n- 中心接触孔的晶圆CD被测量为清除后的二元图像中包含设计孔中心的连通区域的等效直径。如果中心没有区域被清除，则CD为零。等效直径 $d_\\mathrm{wafer}$ 定义为 $d_\\mathrm{wafer} = 2 \\sqrt{A_\\mathrm{region}/\\pi}$，其中 $A_\\mathrm{region}$ 是对应于中心孔的连通清除区域的面积，单位为 $\\text{m}^2$。\n\n使用中心有限差分法计算掩模误差增强因子（MEEF）：\n$$\n\\mathrm{MEEF} \\approx \\frac{d_\\mathrm{wafer}\\!\\left(\\mathrm{CD}_\\text{mask}+\\Delta\\right) - d_\\mathrm{wafer}\\!\\left(\\mathrm{CD}_\\text{mask}-\\Delta\\right)}{(\\mathrm{CD}_\\text{mask}+\\Delta) - (\\mathrm{CD}_\\text{mask}-\\Delta)} = \\frac{d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-}{2\\Delta},\n$$\n其中 $\\Delta$ 是在掩模尺度上应用于掩模CD的一个小变化。\n\n如果使用多重曝光（两次曝光），假设采用光刻-刻蚀-光刻-刻蚀（LELE）的方式将接触孔分成两个交错的子集。总剂量在多次曝光中累加；即，组合强度是两次曝光的光场强度之和。对于多重曝光，仅计算相对于第一个掩模CD的导数，同时保持第二个掩模不变。\n\n在数学上实现以下步骤：\n\n1. 定义一个边长为 $L$、分辨率为 $N \\times N$ 的二维计算网格；空间采样率为 $\\Delta x = L/N$。使用与快速傅里叶变换（FFT）一致的频率网格 $f_x, f_y$。\n2. 根据给定的间距 $p$ 和在像中心的中心位置，构建晶圆尺度上的接触孔阵列振幅 $A(x,y)$。对于多重曝光，使用阵列索引的奇偶性将阵列分成两个子集 $A_1(x,y)$ 和 $A_2(x,y)$，并可选择性地对第二次曝光应用一个套刻偏移 $(\\delta_x, \\delta_y)$。\n3. 对于给定的离焦 $z$、部分相干因子 $\\sigma$ 以及半径为 $s=\\sigma f_c$ 的圆上的一组光源偏移量 $\\{\\mathbf{s}_k\\}$，计算光场强度\n$$\nI(x,y) = \\sum_k \\left| \\mathcal{F}^{-1}\\left[ P(\\mathbf{f}-\\mathbf{s}_k)\\, e^{-i\\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2} \\, \\mathcal{F}\\{A(x,y)\\} \\right] \\right|^2,\n$$\n其中 $\\mathcal{F}$ 表示傅里叶变换，$\\mathcal{F}^{-1}$ 表示其逆变换。\n4. 归一化强度以获得 $I_\\mathrm{norm}(x,y) = I(x,y) / \\max_{x,y} I(x,y)$，应用剂量 $D$ 和阈值 $T_\\mathrm{th}$ 来计算清除后的二元图像。\n5. 通过计算包含中心像素的连通清除区域的面积，并将其转换为等效直径，来测量中心孔的 $d_\\mathrm{wafer}$。\n6. 使用上述有限差分公式计算 $\\mathrm{MEEF}$，其中 $\\Delta$ 是在掩模尺度上的变化，这会转化为晶圆尺度上半径 $\\Delta/M$ 的变化。\n\n测试套件和参数：\n\n使用一个计算网格，其 $L = 512\\,\\text{nm}$，$N=256$（因此代码中所有空间维度必须以米为单位提供并进行适当转换）。使用圆形光瞳，$\\mathrm{NA} = 0.33$，EUV波长 $\\lambda = 13.5\\,\\text{nm}$。使用 $M=4$。定义 $p = 64\\,\\text{nm}$。在光源圆上使用8个均匀分布的光源点。在掩模尺度上使用 $\\Delta = 2\\,\\text{nm}$ 进行有限差分。\n\n提供以下三个测试用例：\n\n- 情况1（单次曝光，标称条件）：$\\mathrm{CD}_\\text{mask} = 140\\,\\text{nm}$，$z=0\\,\\text{nm}$，$\\sigma = 0.20$，$D=1.0$（无量纲），$T_\\mathrm{th}=0.35$（无量纲）。\n- 情况2（单次曝光，离焦和低剂量）：$\\mathrm{CD}_\\text{mask} = 140\\,\\text{nm}$，$z=100\\,\\text{nm}$，$\\sigma = 0.20$，$D=0.85$，$T_\\mathrm{th}=0.35$。\n- 情况3（带套刻的多重曝光（两次曝光））：第一次曝光掩模 $\\mathrm{CD}_\\text{mask,1} = 140\\,\\text{nm}$ 以 $\\pm \\Delta$ 变化，第二次曝光掩模固定为 $\\mathrm{CD}_\\text{mask,2} = 140\\,\\text{nm}$，对第二次曝光应用套刻偏移 $(\\delta_x,\\delta_y) = (3\\,\\text{nm}, 0\\,\\text{nm})$。使用 $z=0\\,\\text{nm}$，$\\sigma=0.20$，$D=1.0$，$T_\\mathrm{th}=0.35$。通过阵列索引 $i+j$ 的奇偶性将接触孔分成两个交错的子集。\n\n对于所有情况，MEEF必须报告为无量纲浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。\n\n代码中的所有物理量必须用国际单位制（SI）表示。不需要角度。不允许使用百分比；阈值和剂量是纯小数。确保仿真在给定参数下是科学一致且数值稳定的。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于傅里叶光学和光刻建模的原理，问题定义良好，有足够的信息来推导出唯一解，并以客观、正式的语言表述。关于掩模误差增强因子（MEEF）的定义存在一个小的歧义。所提供的公式 $\\mathrm{MEEF} \\approx (d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-)/(2\\Delta)$ 产生的结果单位为逆放大率（$1/M$），而问题要求的是无量纲浮点数。这通过采用标准的行业定义来解决，即 $\\mathrm{MEEF} = M \\cdot \\partial (\\mathrm{CD}_\\text{wafer}) / \\partial (\\mathrm{CD}_\\text{mask})$，该定义是无量纲的。解决方案将基于此标准定义进行。\n\n该解决方案通过遵循问题陈述中概述的计算步骤顺序来实现。所有物理量均以国际单位制（SI）表示。\n\n**1. 网格和坐标系定义**\n建立一个二维计算网格来表示像平面。网格边长为 $L = 512 \\times 10^{-9}\\,\\text{m}$，分辨率为 $N \\times N$ 像素，其中 $N=256$。这导致空间采样间隔（像素大小）为 $\\Delta x = L/N = 2 \\times 10^{-9}\\,\\text{m}$。在网格上中心化一个笛卡尔坐标系 $(x,y)$，坐标在每个维度上从 $-L/2$ 延伸到 $L/2 - \\Delta x$。\n\n相应的频域网格 $(\\mathbf{f} = (f_x, f_y))$ 被定义用于快速傅里叶变换（FFT）。频率坐标由空间采样决定，与 `numpy.fft.fftfreq` 一致，并为计算而居中，范围可达奈奎斯特频率 $f_{Ny} = 1/(2\\Delta x)$。\n\n**2. 掩模对象生成**\n掩模是在晶圆尺度上的一个二元振幅对象 $A(x,y)$。它代表一个方形的圆形接触孔阵列。选择一个 $7 \\times 7$ 的阵列来模拟中心接触孔的局部邻近效应，同时避免FFT隐式周期性带来的边界伪影。阵列以原点为中心，接触孔中心位于 $(i \\cdot p, j \\cdot p)$，其中间距为 $p=64 \\times 10^{-9}\\,\\text{m}$，索引 $i, j$ 的范围从 $-3$ 到 $3$。\n\n每个圆形孔在晶圆尺度上的半径 $r$ 由掩模尺度的关键尺寸（$\\mathrm{CD}_\\text{mask}$）和系统缩小倍率 $M=4$ 决定：\n$$\nr = \\frac{1}{2} \\frac{\\mathrm{CD}_\\text{mask}}{M}\n$$\n对于多重曝光情况（情况3），$7 \\times 7$ 的接触孔阵列根据其网格索引 $(i+j)$ 的和的奇偶性被分成两个掩模 $A_1(x,y)$ 和 $A_2(x,y)$。$i+j$ 为偶数的接触孔构成掩模 $A_1$，$i+j$ 为奇数的接触孔构成掩模 $A_2$。通过平移掩模 $A_2$ 上的所有特征，施加一个指定的套刻误差 $(\\delta_x, \\delta_y) = (3 \\times 10^{-9}\\,\\text{m}, 0\\,\\text{m})$。\n\n**3. 光场像模拟**\n光场像强度 $I(x,y)$ 使用部分相干成像的Abbe公式计算。照明光源被建模为在频域中一个圆上均匀分布的 $k=8$ 个离散点光源的非相干集合。这个圆的半径是 $s = \\sigma f_c$，其中 $\\sigma$ 是部分相干因子，$f_c = \\mathrm{NA}/\\lambda$ 是投影光学的截止频率。给定的参数是波长 $\\lambda = 13.5 \\times 10^{-9}\\,\\text{m}$ 和数值孔径 $\\mathrm{NA}=0.33$。\n\n对于每个光源点 $\\mathbf{s}_k$，计算一个相干图像。总强度是来自所有光源点的强度之和。单个光源点的计算包括：\n1.  计算掩模对象的傅里叶变换，$\\mathcal{F}\\{A(x,y)\\}$。\n2.  将光瞳函数 $P(\\mathbf{f})$ 定义为半径为 $f_c$ 的圆形孔径。\n3.  应用离焦像差作为二次相位项，$W(\\mathbf{f}) = \\exp(-i \\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2)$，其中 $z$ 是离焦距离。\n4.  将物频谱与移位的的光瞳和离焦项相乘：$E(\\mathbf{f}) = P(\\mathbf{f}-\\mathbf{s}_k) \\cdot W(\\mathbf{f}) \\cdot \\mathcal{F}\\{A(x,y)\\}$。\n5.  执行傅里葉逆变换以获得像平面中的复电场，$E(x,y) = \\mathcal{F}^{-1}\\{E(\\mathbf{f})\\}$。\n6.  该光源点的强度为 $|E(x,y)|^2$。\n\n总光场强度是所有 $k$ 个光源点的总和：\n$$\nI(x,y) = \\sum_{k=1}^{8} \\left| \\mathcal{F}^{-1}\\left[ P(\\mathbf{f}-\\mathbf{s}_k) \\cdot e^{-i\\pi \\lambda z \\lVert \\mathbf{f} \\rVert^2} \\cdot \\mathcal{F}\\{A(x,y)\\} \\right] \\right|^2\n$$\n对于多重曝光情况，分别为掩模 $A_1$ 和 $A_2$ 计算两个独立的光场像 $I_1(x,y)$ 和 $I_2(x,y)$。最终强度是它们的和，$I_\\text{total}(x,y) = I_1(x,y) + I_2(x,y)$，模拟具有累加剂量的光刻-刻蚀-光刻-刻蚀（LELE）过程。\n\n**4. 光刻胶阈值模型与晶圆CD测量**\n将一个简单的二元阈值模型应用于光场像，以模拟光刻胶显影。首先，强度通过其最大值进行归一化：$I_\\text{norm}(x,y) = I(x,y) / \\max(I)$。如果加剂量后的归一化强度超过给定的阈值 $T_\\mathrm{th}$，则一个区域被认为是“已清除”的：\n$$\n\\text{Cleared}(x,y) = 1 \\quad \\text{if} \\quad D \\cdot I_\\text{norm}(x,y) \\ge T_\\mathrm{th}, \\quad \\text{else} \\quad 0\n$$\n其中 $D$ 是剂量因子。\n\n中心接触孔的晶圆CD $d_\\mathrm{wafer}$ 是通过识别包含网格原点 $(x,y)=(0,0)$ 的清除区域来确定的。这是通过在二元清除图像上使用连通分量标记算法实现的。如果原点不属于任何清除区域，则 $d_\\mathrm{wafer} = 0$。否则，计算中心连通分量的面积 $A_\\mathrm{region}$，方法是计算其像素数并乘以像素面积 $\\Delta x^2$。然后，晶圆CD是具有此面积的圆的直径：\n$$\nd_\\mathrm{wafer} = 2 \\sqrt{\\frac{A_\\mathrm{region}}{\\pi}}\n$$\n\n**5. MEEF计算**\nMEEF是使用中心有限差分近似法计算的。这需要为两个扰动后的掩模CD模拟晶圆CD：$\\mathrm{CD}_\\text{mask}^+ = \\mathrm{CD}_\\text{mask} + \\Delta$ 和 $\\mathrm{CD}_\\text{mask}^- = \\mathrm{CD}_\\text{mask} - \\Delta$，其中 $\\Delta = 2 \\times 10^{-9}\\,\\text{m}$ 是掩模尺度上的扰动。这将产生两个晶圆CD，$d_\\mathrm{wafer}^+$ 和 $d_\\mathrm{wafer}^-$。\n\n正如在验证期间所确立的，标准的无量纲MEEF通过用放大倍数 $M=4$ 对掩模CD的变化进行归一化来计算：\n$$\n\\mathrm{MEEF} = \\frac{d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-}{(\\mathrm{CD}_\\text{mask}^+ - \\mathrm{CD}_\\text{mask}^-)/M} = M \\frac{d_\\mathrm{wafer}^+ - d_\\mathrm{wafer}^-}{2\\Delta}\n$$\n对于多重曝光情况，此过程应用于第一个掩模的CD（$\\mathrm{CD}_{\\text{mask},1}$），而第二个掩模的CD（$\\mathrm{CD}_{\\text{mask},2}$）保持不变。晶圆CD $d_\\mathrm{wafer}^+$ 和 $d_\\mathrm{wafer}^-$ 是从组合强度图像中测量的。\n\n整个算法在一个Python脚本中实现，该脚本处理三个测试用例中的每一个，计算相应的MEEF，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Main function to solve the MEEF calculation problem for the given test cases.\n    \"\"\"\n\n    # --- Physical and Simulation Constants (SI Units) ---\n    LAMBDA = 13.5e-9  # Wavelength (m)\n    NA = 0.33  # Numerical Aperture\n    M = 4.0  # Demagnification\n    PITCH = 64e-9  # Contact pitch (m)\n    DELTA_MASK = 2e-9  # CD perturbation on mask scale (m)\n    N_SOURCE_POINTS = 8\n\n    # --- Computational Grid ---\n    L_GRID = 512e-9  # Grid side length (m)\n    N_PIXELS = 256  # Grid resolution\n    DX = L_GRID / N_PIXELS  # Spatial sampling / pixel size (m)\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1: Single exposure, nominal\n        {'cd_mask': 140e-9, 'z': 0.0, 'sigma': 0.20, 'dose': 1.0, 't_th': 0.35, 'multi_pattern': False},\n        # Case 2: Single exposure, defocus and low dose\n        {'cd_mask': 140e-9, 'z': 100e-9, 'sigma': 0.20, 'dose': 0.85, 't_th': 0.35, 'multi_pattern': False},\n        # Case 3: Two-exposure multi-patterning\n        {'cd_mask1': 140e-9, 'cd_mask2': 140e-9, 'overlay': (3e-9, 0.0), 'z': 0.0, 'sigma': 0.20, 'dose': 1.0, 't_th': 0.35, 'multi_pattern': True},\n    ]\n    \n    # Pre-calculate frequency grids and coordinates\n    x_coords = np.linspace(-L_GRID / 2, L_GRID / 2 - DX, N_PIXELS)\n    X, Y = np.meshgrid(x_coords, x_coords)\n    \n    freq_coords = np.fft.fftfreq(N_PIXELS, d=DX)\n    Fx, Fy = np.meshgrid(freq_coords, freq_coords)\n    F_sq = Fx**2 + Fy**2\n    \n    F_mag = np.sqrt(F_sq)\n    \n    # --- Helper Functions ---\n    \n    def create_mask(cd_mask, pitch, M, N, L, X, Y, pattern_type='all', overlay=(0,0)):\n        \"\"\"Creates a binary mask for a contact hole array.\"\"\"\n        mask = np.zeros((N, N))\n        cd_wafer = cd_mask / M\n        radius_sq = (cd_wafer / 2)**2\n        array_size = 7 # Use a 7x7 array\n        indices = range(-array_size // 2, array_size // 2 + 1)\n        \n        for i in indices:\n            for j in indices:\n                is_even = (i + j) % 2 == 0\n                if (pattern_type == 'all') or \\\n                   (pattern_type == 'even' and is_even) or \\\n                   (pattern_type == 'odd' and not is_even):\n                    \n                    cx = i * pitch + overlay[0]\n                    cy = j * pitch + overlay[1]\n                    hole = (X - cx)**2 + (Y - cy)**2 <= radius_sq\n                    mask[hole] = 1.0\n        return mask\n\n    def calculate_aerial_image(mask, z, sigma, Fx, Fy, F_sq):\n        \"\"\"Calculates the aerial image using Abbe's method.\"\"\"\n        fc = NA / LAMBDA\n        pupil = (F_sq <= fc**2).astype(float)\n        \n        source_radius = sigma * fc\n        \n        object_spectrum = np.fft.fftshift(np.fft.fft2(mask))\n        defocus_term = np.exp(-1j * np.pi * LAMBDA * z * F_sq)\n\n        total_intensity = np.zeros_like(mask, dtype=float)\n        \n        for k in range(N_SOURCE_POINTS):\n            theta = 2 * np.pi * k / N_SOURCE_POINTS\n            sk_x = source_radius * np.cos(theta)\n            sk_y = source_radius * np.sin(theta)\n            \n            Fx_shifted = Fx - sk_x\n            Fy_shifted = Fy - sk_y\n            \n            pupil_shifted = (Fx_shifted**2 + Fy_shifted**2 <= fc**2).astype(float)\n            \n            E_field_spectrum = pupil_shifted * defocus_term * object_spectrum\n            E_field = np.fft.ifft2(np.fft.ifftshift(E_field_spectrum))\n            total_intensity += np.abs(E_field)**2\n            \n        return total_intensity\n\n    def measure_wafer_cd(intensity, dose, t_th, dx):\n        \"\"\"Measures the wafer CD from the aerial image using a threshold model.\"\"\"\n        if intensity.max() == 0:\n            return 0.0\n        \n        norm_intensity = intensity / intensity.max()\n        binary_image = (dose * norm_intensity >= t_th).astype(int)\n        \n        labeled_array, num_features = label(binary_image)\n        \n        center_pixel_idx = N_PIXELS // 2\n        center_label = labeled_array[center_pixel_idx, center_pixel_idx]\n        \n        if center_label == 0:\n            return 0.0\n        \n        area_pixels = np.sum(labeled_array == center_label)\n        area_region = area_pixels * (dx**2)\n        d_wafer = 2 * np.sqrt(area_region / np.pi)\n        \n        return d_wafer\n\n    def compute_single_exposure_meef(params):\n        \"\"\"Computes MEEF for a single exposure case.\"\"\"\n        \n        def get_dwafer(cd_mask):\n            mask = create_mask(cd_mask, PITCH, M, N_PIXELS, L_GRID, X, Y)\n            intensity = calculate_aerial_image(mask, params['z'], params['sigma'], Fx, Fy, F_sq)\n            return measure_wafer_cd(intensity, params['dose'], params['t_th'], DX)\n\n        d_wafer_plus = get_dwafer(params['cd_mask'] + DELTA_MASK)\n        d_wafer_minus = get_dwafer(params['cd_mask'] - DELTA_MASK)\n\n        meef = M * (d_wafer_plus - d_wafer_minus) / (2 * DELTA_MASK)\n        return meef\n\n    def compute_multi_pattern_meef(params):\n        \"\"\"Computes MEEF for a multi-patterning case.\"\"\"\n        # Calculate aerial image for fixed mask 2\n        mask2 = create_mask(params['cd_mask2'], PITCH, M, N_PIXELS, L_GRID, X, Y,\n                            pattern_type='odd', overlay=params['overlay'])\n        intensity2 = calculate_aerial_image(mask2, params['z'], params['sigma'], Fx, Fy, F_sq)\n\n        def get_dwafer(cd_mask1):\n            mask1 = create_mask(cd_mask1, PITCH, M, N_PIXELS, L_GRID, X, Y, pattern_type='even')\n            intensity1 = calculate_aerial_image(mask1, params['z'], params['sigma'], Fx, Fy, F_sq)\n            total_intensity = intensity1 + intensity2\n            return measure_wafer_cd(total_intensity, params['dose'], params['t_th'], DX)\n\n        d_wafer_plus = get_dwafer(params['cd_mask1'] + DELTA_MASK)\n        d_wafer_minus = get_dwafer(params['cd_mask1'] - DELTA_MASK)\n\n        meef = M * (d_wafer_plus - d_wafer_minus) / (2 * DELTA_MASK)\n        return meef\n\n    # --- Main Calculation Loop ---\n    results = []\n    for case in test_cases:\n        if not case['multi_pattern']:\n            meef = compute_single_exposure_meef(case)\n        else:\n            meef = compute_multi_pattern_meef(case)\n        results.append(meef)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然精确的数值模拟功能强大，但简化的解析模型往往能更清晰地揭示物理本质。本练习将采用一种解析方法，通过将理想的“切割”掩模与高斯模糊函数进行卷积，来研究线端回缩（Line-End Shortening）这一关键现象。你将从中推导出线端回缩与系统总模糊以及归一化图像对数斜率（NILS）之间的直接关系，从而体验一种与纯数值计算不同但同样富有洞察力的建模方法。",
            "id": "4125054",
            "problem": "您需要为一个由多重曝光光刻工艺中的切割特征所产生的线端，建立其一维极紫外（EUV）成像场景的模型。在考虑了光学模糊和光刻胶模糊之后，通过对衍射图像进行光刻胶阈值化来获得最终的印刷轮廓。您必须从第一性原理推导线端的衍射图像，然后使用阈值模型量化线端缩短。您的程序必须实现推导出的表达式，并为指定的测试套件生成数值结果。\n\n假设以下基于物理的建模基础：\n- 光学系统是线性和移位不变的，因此衍射图像是掩模透射率与光学点扩散函数的卷积。\n- 光学点扩散函数由高斯函数近似，当仅保留标量效应时，这是EUV中部分相干成像模糊的一个广泛使用的替代模型。\n- 光刻胶模糊被建模为作用在衍射图像上的高斯卷积，并由一个标准差参数化。\n- 最终印刷轮廓由模糊后的衍射图像的恒定阈值穿越点定义。\n\n定义一维坐标 $y$ 沿线轴方向，使得掩模上预期的线端位置在 $y=-L_c$ 处，其中 $L_c \\ge 0$ 是切割长度。对于被切割块截断的连续线条，其复合掩模透射率被建模为区间 $(-\\infty, -L_c)$ 的指示函数；也就是说，当 $y < -L_c$ 时掩模是透光的，而当 $y \\ge -L_c$ 时是不透光的。\n\n设光学高斯点扩散函数的标准差为 $\\sigma_{\\mathrm{opt}}$，它通过数值孔径（NA）和波长 $\\lambda$ 依赖于光源形状和投影光学系统。使用以下参数化来进行光源形状到模糊的映射：\n- 对于圆形（均匀）光源，使用 $k_s = 0.21$ 和 $\\sigma_{\\mathrm{opt}} = k_s \\cdot \\lambda / \\mathrm{NA}$。\n- 对于环形比为 $\\rho \\in [0,1]$（内光瞳半径与外光瞳半径之比）的环形光源，使用 $k_s = 0.21 \\cdot (1 - 0.3 \\rho)$ 和 $\\sigma_{\\mathrm{opt}} = k_s \\cdot \\lambda / \\mathrm{NA}$。\n\n将光刻胶模糊建模为标准差为 $\\sigma_R$ 的高斯函数。因为高斯函数的卷积仍是高斯函数，所以有效模糊标准差为 $\\sigma_{\\mathrm{eff}} = \\sqrt{\\sigma_{\\mathrm{opt}}^2 + \\sigma_R^2}$。\n\n定义在阈值位置 $y=y_{\\mathrm{print}}$ 处的归一化图像对数斜率（NILS）为 $s = \\left(1/I_{\\mathrm{th}}\\right) \\left| \\frac{d I(y)}{d y} \\right|_{y=y_{\\mathrm{print}}}$，其中 $I(y)$ 是最终的模糊衍射图像，$I_{\\mathrm{th}} \\in (0,1)$ 是恒定阈值。在高斯模糊阶跃边缘模型中，此NILS可用于独立于光源参数来校准 $\\sigma_{\\mathrm{eff}}$，从而实现对线端缩短的第二次、由NILS驱动的估计。\n\n定义以纳米（nm）为单位的线端缩短为 $LES = y_{\\mathrm{print}} - (-L_c) = y_{\\mathrm{print}} + L_c$，即印刷端相对于预期端的正向内移。您必须为每个测试用例计算两个值：\n- 使用从光源形状映射和光刻胶模糊获得的 $\\sigma_{\\mathrm{eff}}$ 计算的光源模型缩短 $LES_{\\mathrm{src}}$。\n- 使用通过在阈值处匹配给定NILS而推断出的 $\\sigma_{\\mathrm{eff}}$ 计算的NILS校准缩短 $LES_{\\mathrm{nils}}$。\n\n您的程序必须实现以下步骤：\n1. 仅使用提供的建模基础，为上述阶跃掩模推导模糊衍射图像 $I(y)$。然后从阈值方程 $I(y_{\\mathrm{print}}) = I_{\\mathrm{th}}$ 求解 $y_{\\mathrm{print}}$。\n2. 根据 $\\sigma_{\\mathrm{eff}} = \\sqrt{\\sigma_{\\mathrm{opt}}^2 + \\sigma_R^2}$ 计算 $LES_{\\mathrm{src}}$，其中 $\\sigma_{\\mathrm{opt}}$ 由光源形状映射和给定的 $\\lambda$ 与 $\\mathrm{NA}$ 决定。\n3. 首先用 $\\sigma_{\\mathrm{eff}}$ 和 $I_{\\mathrm{th}}$ 表示阈值处的NILS $s$，然后反演以从提供的 $s$ 获得 $\\sigma_{\\mathrm{eff}}$，最后使用该 $\\sigma_{\\mathrm{eff}}$ 计算缩短量，从而计算 $LES_{\\mathrm{nils}}$。\n\n所有物理量在适用时必须以纳米为单位处理。具体来说：\n- $\\lambda$ 以 nm 为单位给出。\n- $\\sigma_R$ 和 $L_c$ 以 nm 为单位给出。\n- 输出 $LES_{\\mathrm{src}}$ 和 $LES_{\\mathrm{nils}}$ 必须以 nm 表示，并四舍五入到三位小数。\n\n在此一维公式中不出现角度。所有强度都是无单位的，NILS $s$ 的单位是逆纳米（nm$^{-1}$）。\n\n测试套件：\n为以下四个测试用例提供结果，每个用例指定为一个元组：\n- 用例1（理想路径）：圆形光源，$\\mathrm{NA} = 0.33$，$\\lambda = 13.5$ nm，$I_{\\mathrm{th}} = 0.3$，$\\sigma_R = 5$ nm，$L_c=0$ nm，$s = 2.0$ nm$^{-1}$。\n- 用例2（环形，高离轴）：环形光源，$\\rho = 0.8$，$\\mathrm{NA} = 0.33$，$\\lambda = 13.5$ nm，$I_{\\mathrm{th}} = 0.25$，$\\sigma_R = 2$ nm，$L_c = 4$ nm，$s = 3.0$ nm$^{-1}$。\n- 用例3（边界阈值）：圆形光源，$\\mathrm{NA} = 0.28$，$\\lambda = 13.5$ nm，$I_{\\mathrm{th}} = 0.5$，$\\sigma_R = 3$ nm，$L_c = 10$ nm，$s = 1.0$ nm$^{-1}$。\n- 用例4（强模糊）：环形光源，$\\rho = 0.0$，$\\mathrm{NA} = 0.33$，$\\lambda = 13.5$ nm，$I_{\\mathrm{th}} = 0.1$，$\\sigma_R = 10$ nm，$L_c = 20$ nm，$s = 0.8$ nm$^{-1}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，每个内部列表包含以nm为单位的 $[LES_{\\mathrm{src}}, LES_{\\mathrm{nils}}]$，四舍五入到三位小数，并用方括号括起来。例如：\"[[les_src_case1,les_nils_case1],[les_src_case2,les_nils_case2],[les_src_case3,les_nils_case4]]\"。",
            "solution": "该问题被评估为有效，因为它具有科学依据、内容自洽且定义明确。它提出了一个标准的、尽管简化的光刻成像模型，可以通过已建立的数学物理原理求解。所有必需的参数均已提供，目标也已明确定义。\n\n求解过程首先推导所关注量的解析表达式，然后对指定的测试用例进行数值评估。\n\n### 步骤1：推导模糊衍射图像\n\n问题描述了一个一维成像场景。掩模由其透射率函数 $M(y)$ 定义，指定为当坐标 $y < -L_c$ 时透光，当 $y \\ge -L_c$ 时不透光。这对应一个阶跃函数。使用亥维赛阶跃函数 $H(x)$（定义为当 $x>0$ 时 $H(x)=1$，当 $x<0$ 时 $H(x)=0$），我们可以将掩模透射率写为：\n$$\nM(y) = H(-L_c - y)\n$$\n包括光学和光刻胶效应在内的成像过程被建模为一个线性、移位不变的系统。总模糊由单个有效点扩散函数（PSF）描述，该函数是光学PSF和光刻胶模糊函数的卷积。由于两者都建模为高斯函数，它们的卷积也是一个高斯函数。因此，有效PSF $g(y)$ 是一个具有有效标准差 $\\sigma_{\\mathrm{eff}}$ 的高斯函数：\n$$\ng(y) = \\frac{1}{\\sqrt{2\\pi} \\sigma_{\\mathrm{eff}}} e^{-\\frac{y^2}{2\\sigma_{\\mathrm{eff}}^2}}\n$$\n最终的模糊衍射图像 $I(y)$ 是掩模透射率 $M(y)$ 与有效PSF $g(y)$ 的卷积：\n$$\nI(y) = (M * g)(y) = \\int_{-\\infty}^{\\infty} M(y') g(y - y') dy'\n$$\n代入 $M(y')$ 和 $g(y-y')$ 的表达式：\n$$\nI(y) = \\int_{-\\infty}^{-L_c} \\frac{1}{\\sqrt{2\\pi} \\sigma_{\\mathrm{eff}}} e^{-\\frac{(y - y')^2}{2\\sigma_{\\mathrm{eff}}^2}} dy'\n$$\n为了求解此积分，我们进行变量替换。令 $u = \\frac{y' - y}{\\sigma_{\\mathrm{eff}}}$。则 $du = \\frac{dy'}{\\sigma_{\\mathrm{eff}}}$。积分限变为 $y' \\to -\\infty \\implies u \\to -\\infty$ 和 $y' \\to -L_c \\implies u \\to \\frac{-L_c - y}{\\sigma_{\\mathrm{eff}}}$。\n$$\nI(y) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\frac{-L_c - y}{\\sigma_{\\mathrm{eff}}}} e^{-\\frac{u^2}{2}} du\n$$\n此积分是标准正态分布的累积分布函数（CDF）的定义，记为 $\\Phi(x)$。\n$$\n\\Phi(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} e^{-\\frac{t^2}{2}} dt\n$$\n因此，衍射图像为：\n$$\nI(y) = \\Phi\\left(\\frac{-L_c - y}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n该表达式也可以用误差函数 $\\mathrm{erf}(x)$ 来表示，使用关系式 $\\Phi(x) = \\frac{1}{2}\\left[1 + \\mathrm{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right]$。\n\n### 步骤2：推导线端缩短（LES）\n\n印刷线端轮廓 $y_{\\mathrm{print}}$ 由阈值条件 $I(y_{\\mathrm{print}}) = I_{\\mathrm{th}}$ 确定，其中 $I_{\\mathrm{th}} \\in (0,1)$ 是光刻胶阈值。\n$$\nI_{\\mathrm{th}} = \\Phi\\left(\\frac{-L_c - y_{\\mathrm{print}}}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n为了求解 $y_{\\mathrm{print}}$，我们将逆CDF函数 $\\Phi^{-1}$（也称为标准正态分布的概率单位函数或分位数函数）应用于方程两侧：\n$$\n\\Phi^{-1}(I_{\\mathrm{th}}) = \\frac{-L_c - y_{\\mathrm{print}}}{\\sigma_{\\mathrm{eff}}}\n$$\n对 $y_{\\mathrm{print}}$ 进行整理可得：\n$$\ny_{\\mathrm{print}} = -L_c - \\sigma_{\\mathrm{eff}} \\Phi^{-1}(I_{\\mathrm{th}})\n$$\n线端缩短（$LES$）定义为印刷边缘相对于预期边缘的位移，$LES = y_{\\mathrm{print}} - (-L_c) = y_{\\mathrm{print}} + L_c$。\n$$\nLES = \\left(-L_c - \\sigma_{\\mathrm{eff}} \\Phi^{-1}(I_{\\mathrm{th}})\\right) + L_c\n$$\n$$\nLES = -\\sigma_{\\mathrm{eff}} \\Phi^{-1}(I_{\\mathrm{th}})\n$$\n这是计算LES的核心方程。请注意，对于典型的光刻胶阈值 $I_{\\mathrm{th}} < 0.5$，$\\Phi^{-1}(I_{\\mathrm{th}})$ 的值为负，导致 $LES$ 为正，这对应于线端的“缩短”或回缩。由于模型的移位不变特性，$L_c$ 参数被抵消；缩短量仅取决于模糊和阈值，而不取决于特征的绝对位置。\n\n### 步骤3：计算 $LES_{\\mathrm{src}}$（基于光源模型）\n\n要计算 $LES_{\\mathrm{src}}$，我们必须首先根据给定的光源和光刻胶参数确定 $\\sigma_{\\mathrm{eff}}$。\n1.  **计算 $k_s$**：该因子取决于光源形状。对于圆形光源，在环形光源公式中使用 $\\rho=0$。\n    $$ k_s = 0.21 \\cdot (1 - 0.3 \\rho) $$\n2.  **计算 $\\sigma_{\\mathrm{opt}}$**：光学模糊标准差由下式给出：\n    $$ \\sigma_{\\mathrm{opt}} = k_s \\cdot \\frac{\\lambda}{\\mathrm{NA}} $$\n3.  **计算 $\\sigma_{\\mathrm{eff, src}}$**：有效模糊是光学模糊和光刻胶模糊的平方和的平方根。\n    $$ \\sigma_{\\mathrm{eff, src}} = \\sqrt{\\sigma_{\\mathrm{opt}}^2 + \\sigma_R^2} $$\n4.  **计算 $LES_{\\mathrm{src}}$**：将 $\\sigma_{\\mathrm{eff, src}}$ 代入LES公式。\n    $$ LES_{\\mathrm{src}} = -\\sigma_{\\mathrm{eff, src}} \\cdot \\Phi^{-1}(I_{\\mathrm{th}}) $$\n\n### 步骤4：计算 $LES_{\\mathrm{nils}}$（NILS校准）\n\n要计算 $LES_{\\mathrm{nils}}$，我们必须首先找到一个与给定归一化图像对数斜率（$s$）一致的 $\\sigma_{\\mathrm{eff}}$ 替代值。\nNILS定义为 $s = \\frac{1}{I_{\\mathrm{th}}} \\left| \\frac{d I(y)}{d y} \\right|_{y=y_{\\mathrm{print}}}$。首先，我们求 $I(y)$ 的导数：\n$$\n\\frac{dI}{dy} = \\frac{d}{dy} \\Phi\\left(\\frac{-L_c - y}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n使用链式法则以及 $\\frac{d}{dx}\\Phi(x) = \\phi(x)$（标准正态概率密度函数，PDF）这一事实，我们得到：\n$$\n\\frac{dI}{dy} = \\phi\\left(\\frac{-L_c - y}{\\sigma_{\\mathrm{eff}}}\\right) \\cdot \\frac{d}{dy}\\left(\\frac{-L_c - y}{\\sigma_{\\mathrm{eff}}}\\right) = -\\frac{1}{\\sigma_{\\mathrm{eff}}} \\phi\\left(\\frac{-L_c - y}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n其中 $\\phi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$。我们在 $y=y_{\\mathrm{print}}$ 处计算该导数的值。在此位置，我们从步骤2中知道 $\\frac{-L_c - y_{\\mathrm{print}}}{\\sigma_{\\mathrm{eff}}} = \\Phi^{-1}(I_{\\mathrm{th}})$。\n$$\n\\left. \\frac{dI}{dy} \\right|_{y=y_{\\mathrm{print}}} = -\\frac{1}{\\sigma_{\\mathrm{eff}}} \\phi(\\Phi^{-1}(I_{\\mathrm{th}}))\n$$\n将此代入NILS定义中：\n$$\ns = \\frac{1}{I_{\\mathrm{th}}} \\left| -\\frac{1}{\\sigma_{\\mathrm{eff}}} \\phi(\\Phi^{-1}(I_{\\mathrm{th}})) \\right| = \\frac{\\phi(\\Phi^{-1}(I_{\\mathrm{th}}))}{I_{\\mathrm{th}} \\sigma_{\\mathrm{eff}}}\n$$\n我们现在可以反演此表达式，以求解NILS校准的有效模糊 $\\sigma_{\\mathrm{eff, nils}}$：\n$$\n\\sigma_{\\mathrm{eff, nils}} = \\frac{\\phi(\\Phi^{-1}(I_{\\mathrm{th}}))}{s \\cdot I_{\\mathrm{th}}}\n$$\n最后，我们使用此 $\\sigma_{\\mathrm{eff, nils}}$ 计算 $LES_{\\mathrm{nils}}$：\n$$\nLES_{\\mathrm{nils}} = -\\sigma_{\\mathrm{eff, nils}} \\cdot \\Phi^{-1}(I_{\\mathrm{th}}) = -\\left(\\frac{\\phi(\\Phi^{-1}(I_{\\mathrm{th}}))}{s \\cdot I_{\\mathrm{th}}}\\right) \\Phi^{-1}(I_{\\mathrm{th}})\n$$\n至此完成了所需的推导。现在可以实现一个程序来为给定的测试套件评估这些表达式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the EUV lithography modeling problem.\n    It processes a suite of test cases, calculates line-end shortening (LES)\n    using two different models, and prints the results in the specified format.\n    \"\"\"\n\n    # Test suite from the problem statement.\n    # Each tuple contains:\n    # (source_type, rho, NA, lambda, I_th, sigma_R, L_c, s)\n    # where rho=0.0 is used for circular sources. L_c is not used in the\n    # final LES calculation due to cancellation but is retained for problem fidelity.\n    test_cases = [\n        # Case 1: Circular source, happy path.\n        ({'rho': 0.0}, 0.33, 13.5, 0.3, 5.0, 0.0, 2.0),\n        # Case 2: Annular source, high off-axis.\n        ({'rho': 0.8}, 0.33, 13.5, 0.25, 2.0, 4.0, 3.0),\n        # Case 3: Circular source, boundary threshold.\n        ({'rho': 0.0}, 0.28, 13.5, 0.5, 3.0, 10.0, 1.0),\n        # Case 4: Annular source with rho=0 (equivalent to circular), strong blur.\n        ({'rho': 0.0}, 0.33, 13.5, 0.1, 10.0, 20.0, 0.8),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        params, NA, lam, I_th, sigma_R, L_c, s = case\n        rho = params['rho']\n        \n        # --- Common Calculation ---\n        # Calculate the inverse CDF of the threshold intensity.\n        # This is a core component for both LES calculations.\n        # For I_th = 0.5, inv_cdf is 0, leading to LES = 0.\n        if I_th == 0.5:\n            inv_cdf_I_th = 0.0\n        else:\n            inv_cdf_I_th = norm.ppf(I_th)\n\n        # --- 1. Source-Model LES (LES_src) ---\n        \n        # Calculate k_s based on source shape (rho=0 for circular)\n        k_s = 0.21 * (1 - 0.3 * rho)\n        \n        # Calculate optical blur standard deviation\n        sigma_opt = k_s * lam / NA\n        \n        # Calculate effective blur standard deviation\n        sigma_eff_src = np.sqrt(sigma_opt**2 + sigma_R**2)\n        \n        # Calculate source-model LES\n        les_src = -sigma_eff_src * inv_cdf_I_th\n        \n        # --- 2. NILS-Calibrated LES (LES_nils) ---\n        \n        # The LES calculation for the NILS case can result in a division by zero\n        # if I_th or s is zero. Also, if I_th=0.5, inv_cdf_I_th is 0, making LES_nils 0.\n        if I_th == 0.0 or s == 0.0 or I_th == 0.5:\n            les_nils = 0.0\n        else:\n            # Calculate the standard normal PDF at the inverse CDF of the threshold\n            pdf_at_inv_cdf = norm.pdf(inv_cdf_I_th)\n            \n            # Calculate NILS-calibrated effective blur\n            # sigma_eff_nils = pdf_at_inv_cdf / (s * I_th)\n            \n            # Calculate NILS-calibrated LES directly\n            # LES_nils = -sigma_eff_nils * inv_cdf_I_th\n            les_nils = -(pdf_at_inv_cdf / (s * I_th)) * inv_cdf_I_th\n\n        # Append rounded results for the current case\n        results.append([round(les_src, 3), round(les_nils, 3)])\n\n    # Format the final output string as per requirements\n    inner_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    output_string = f\"[{','.join(inner_strings)}]\"\n    \n    print(output_string)\n\nsolve()\n```"
        }
    ]
}