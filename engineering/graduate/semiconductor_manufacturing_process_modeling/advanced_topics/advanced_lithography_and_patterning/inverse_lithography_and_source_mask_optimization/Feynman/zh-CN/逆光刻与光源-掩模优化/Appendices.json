{
    "hands_on_practices": [
        {
            "introduction": "本练习将巩固您对傅里叶光学基本原理的理解。通过从第一性原理推导一个简单周期性图形的航拍图像，您将清晰地看到光学系统如何充当空间频率滤波器，以及少数几个衍射级之间的干涉如何形成图像。这项基于第一性原理的计算是所有光刻仿真和优化工具的基石。",
            "id": "4134399",
            "problem": "考虑一个周期性二元线条空间掩模的一维标量相干成像，其振幅透射函数为 $M(x)=\\mathrm{sgn}\\!\\big(\\cos(2\\pi x/p)\\big)$，其中 $p$ 是周期。成像系统的光瞳函数为 $P(f)=\\mathrm{circ}\\!\\big(f f_c^{-1}\\big)$，截止空间频率为 $f_c=\\mathrm{NA}/\\lambda$，其中 $\\mathrm{NA}$ 是数值孔径，$\\lambda$ 是波长。函数 $\\mathrm{circ}(u)$ 在 $|u|\\leq 1$ 时为 $1$，否则为 $0$。假设为相干照明，像平面复场 $E(x)$ 由光瞳函数与掩模频谱的乘积的傅里叶逆变换给出，空中像强度为 $I(x)=|E(x)|^2$。\n\n在科学上符合实际的操作条件下，即截止空间频率通过基频但滤除所有更高阶的掩模谐波，具体而言，$f_c$ 满足 $1/p  f_c  3/p$，求空中像强度 $I(x)$ 的傅里叶展开中第一个非直流谐波（即 $\\cos(4\\pi x/p)$ 项）的振幅 $A_1$。",
            "solution": "该问题要求推导空中像强度 $I(x)$，并随后确定其傅里叶展开中第一个非直流谐波的振幅 $A_1$。成像过程是相干的，并且对系统的截止频率有特定约束。\n\n该过程包括以下步骤：\n1.  确定周期性掩模函数 $M(x)$ 的傅里叶级数。\n2.  求出掩模的空间频谱 $\\tilde{M}(f)$，即 $M(x)$ 的傅里叶变换。\n3.  将光瞳滤波器 $P(f)$ 应用于掩模频谱，以求出像平面场的频谱 $\\tilde{E}(f) = P(f)\\tilde{M}(f)$。\n4.  通过对 $\\tilde{E}(f)$ 进行傅里叶逆变换，计算像平面电场 $E(x)$。\n5.  计算空中像强度 $I(x) = |E(x)|^2$。\n6.  将 $I(x)$ 展开为其傅里叶级数，并确定所需的系数 $A_1$。\n\n第一步：掩模函数 $M(x)$ 的傅里叶级数\n掩模函数由 $M(x) = \\mathrm{sgn}(\\cos(2\\pi x/p))$ 给出。此函数描述了一个周期为 $p$ 的周期性方波。当 $\\cos(2\\pi x/p) > 0$ 时，其值为 $+1$，当 $\\cos(2\\pi x/p)  0$ 时，其值为 $-1$。对于以 $x=0$ 为中心的一个周期，具体为 $x \\in [-p/2, p/2]$，函数为：\n$$\nM(x) = \n\\begin{cases} \n+1  \\text{for } x \\in (-p/4, p/4) \\\\\n-1  \\text{for } x \\in [-p/2, -p/4) \\cup (p/4, p/2]\n\\end{cases}\n$$\n$M(x)$ 是一个周期函数，可以由复傅里叶级数表示：\n$$\nM(x) = \\sum_{n=-\\infty}^{\\infty} c_n e^{i 2 \\pi n x/p}\n$$\n复傅里叶系数 $c_n$ 通过以下方式计算：\n$$\nc_n = \\frac{1}{p} \\int_{-p/2}^{p/2} M(x) e^{-i 2 \\pi n x/p} dx\n$$\n首先，对于直流分量（$n=0$）：\n$$\nc_0 = \\frac{1}{p} \\int_{-p/2}^{p/2} M(x) dx = \\frac{1}{p} \\left( \\int_{-p/2}^{-p/4} (-1) dx + \\int_{-p/4}^{p/4} (1) dx + \\int_{p/4}^{p/2} (-1) dx \\right) = \\frac{1}{p} \\left( -\\frac{p}{4} + \\frac{p}{2} - \\frac{p}{4} \\right) = 0\n$$\n直流分量为零。对于 $n \\neq 0$：\n$$\nc_n = \\frac{1}{p} \\left( \\int_{-p/4}^{p/4} e^{-i 2 \\pi n x/p} dx - \\int_{-p/2}^{-p/4} e^{-i 2 \\pi n x/p} dx - \\int_{p/4}^{p/2} e^{-i 2 \\pi n x/p} dx \\right)\n$$\n由于 $M(x)$ 是实偶函数，我们可以简化计算：$c_n = \\frac{2}{p} \\int_0^{p/2} M(x) \\cos(2\\pi n x/p) dx$。\n$$\nc_n = \\frac{2}{p} \\left( \\int_0^{p/4} \\cos\\left(\\frac{2\\pi n x}{p}\\right) dx - \\int_{p/4}^{p/2} \\cos\\left(\\frac{2\\pi n x}{p}\\right) dx \\right)\n$$\n$$\nc_n = \\frac{2}{p} \\left[ \\frac{p}{2\\pi n} \\sin\\left(\\frac{2\\pi n x}{p}\\right) \\right]_0^{p/4} - \\frac{2}{p} \\left[ \\frac{p}{2\\pi n} \\sin\\left(\\frac{2\\pi n x}{p}\\right) \\right]_{p/4}^{p/2}\n$$\n$$\nc_n = \\frac{1}{\\pi n} \\left( \\sin\\left(\\frac{n\\pi}{2}\\right) - 0 \\right) - \\frac{1}{\\pi n} \\left( \\sin(n\\pi) - \\sin\\left(\\frac{n\\pi}{2}\\right) \\right)\n$$\n由于对于任何整数 $n$，$\\sin(n\\pi) = 0$，上式简化为：\n$$\nc_n = \\frac{1}{\\pi n}\\sin\\left(\\frac{n\\pi}{2}\\right) + \\frac{1}{\\pi n}\\sin\\left(\\frac{n\\pi}{2}\\right) = \\frac{2}{\\pi n}\\sin\\left(\\frac{n\\pi}{2}\\right)\n$$\n此公式对 $n \\neq 0$ 有效。系数仅在 $n$ 为奇数时非零。对于偶数 $n \\neq 0$，$\\sin(n\\pi/2)=0$。\n对于 $n = \\pm 1$，$c_{\\pm 1} = \\frac{2}{\\pm \\pi}\\sin(\\pm\\pi/2) = \\frac{2}{\\pi}$。\n对于 $n = \\pm 3$，$c_{\\pm 3} = \\frac{2}{\\pm 3\\pi}\\sin(\\pm 3\\pi/2) = -\\frac{2}{3\\pi}$。\n通常，对于奇数 $n$，$c_n = \\frac{2(-1)^{(n-1)/2}}{\\pi n}$。\n\n第二步：掩模频谱 $\\tilde{M}(f)$\n周期函数的傅里叶变换是一串位于基频 $1/p$ 整数倍处的狄拉克δ函数。\n$$\n\\tilde{M}(f) = \\mathcal{F}\\{M(x)\\} = \\sum_{n=-\\infty}^{\\infty} c_n \\delta\\left(f - \\frac{n}{p}\\right)\n$$\n代入系数 $c_n$：\n$$\n\\tilde{M}(f) = \\sum_{n \\text{ odd}} \\frac{2}{\\pi n}\\sin\\left(\\frac{n\\pi}{2}\\right) \\delta\\left(f - \\frac{n}{p}\\right)\n$$\n\n第三步：应用光瞳滤波器 $P(f)$\n像平面场的频谱为 $\\tilde{E}(f) = P(f)\\tilde{M}(f)$。光瞳函数 $P(f)=\\mathrm{circ}(f/f_c)$ 充当一个低通滤波器，在 $|f| \\le f_c$ 时为 $1$，否则为 $0$。问题陈述 $1/p  f_c  3/p$。\n此条件决定了哪些衍射级（δ函数）被光瞳透射：\n- 对于 $n=\\pm 1$，空间频率为 $f=\\pm 1/p$。由于 $|f|=1/p  f_c$，这些衍射级通过光瞳，因此 $P(\\pm 1/p) = 1$。\n- 对于 $n=\\pm 3$，空间频率为 $f=\\pm 3/p$。由于 $|f|=3/p > f_c$，这些衍射级被光瞳阻挡，因此 $P(\\pm 3/p) = 0$。\n- 所有更高阶（$|n| \\geq 3$）的衍射级也都被阻挡。\n直流分量（$n=0$）由于 $c_0=0$ 已经不存在。\n因此，只有 $n=\\pm 1$ 级对像场频谱有贡献：\n$$\n\\tilde{E}(f) = c_1 \\delta\\left(f - \\frac{1}{p}\\right) + c_{-1} \\delta\\left(f + \\frac{1}{p}\\right)\n$$\n使用 $c_1 = c_{-1} = 2/\\pi$：\n$$\n\\tilde{E}(f) = \\frac{2}{\\pi} \\delta\\left(f - \\frac{1}{p}\\right) + \\frac{2}{\\pi} \\delta\\left(f + \\frac{1}{p}\\right)\n$$\n\n第四步：像平面电场 $E(x)$\n像平面电场是 $\\tilde{E}(f)$ 的傅里叶逆变换：\n$$\nE(x) = \\mathcal{F}^{-1}\\{\\tilde{E}(f)\\} = \\int_{-\\infty}^{\\infty} \\tilde{E}(f) e^{i 2\\pi f x} df\n$$\n$$\nE(x) = \\int_{-\\infty}^{\\infty} \\left[ \\frac{2}{\\pi} \\delta\\left(f - \\frac{1}{p}\\right) + \\frac{2}{\\pi} \\delta\\left(f + \\frac{1}{p}\\right) \\right] e^{i 2\\pi f x} df\n$$\n使用δ函数的筛选特性，$\\int g(t) \\delta(t-t_0) dt = g(t_0)$：\n$$\nE(x) = \\frac{2}{\\pi} e^{i 2\\pi (1/p) x} + \\frac{2}{\\pi} e^{i 2\\pi (-1/p) x} = \\frac{2}{\\pi} (e^{i 2\\pi x/p} + e^{-i 2\\pi x/p})\n$$\n使用欧拉公式，$e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$：\n$$\nE(x) = \\frac{2}{\\pi} \\left( 2\\cos\\left(\\frac{2\\pi x}{p}\\right) \\right) = \\frac{4}{\\pi} \\cos\\left(\\frac{2\\pi x}{p}\\right)\n$$\n\n第五步：空中像强度 $I(x)$\n空中像强度是复电场的模平方：\n$$\nI(x) = |E(x)|^2 = \\left| \\frac{4}{\\pi} \\cos\\left(\\frac{2\\pi x}{p}\\right) \\right|^2\n$$\n由于 $E(x)$ 的表达式是纯实数：\n$$\nI(x) = \\left( \\frac{4}{\\pi} \\right)^2 \\cos^2\\left(\\frac{2\\pi x}{p}\\right) = \\frac{16}{\\pi^2} \\cos^2\\left(\\frac{2\\pi x}{p}\\right)\n$$\n这是推导出的空中像强度。\n\n第六步：$I(x)$ 的傅里叶展开及系数 $A_1$\n为了找到项 $\\cos(4\\pi x/p)$ 的系数 $A_1$，我们使用三角幂减恒等式 $\\cos^2(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$ 来展开 $I(x)$：\n$$\nI(x) = \\frac{16}{\\pi^2} \\left( \\frac{1 + \\cos\\left(2 \\cdot \\frac{2\\pi x}{p}\\right)}{2} \\right)\n$$\n$$\nI(x) = \\frac{8}{\\pi^2} \\left( 1 + \\cos\\left(\\frac{4\\pi x}{p}\\right) \\right)\n$$\n$$\nI(x) = \\frac{8}{\\pi^2} + \\frac{8}{\\pi^2} \\cos\\left(\\frac{4\\pi x}{p}\\right)\n$$\n这是强度 $I(x)$ 的傅里叶展开。它包含一个直流分量 $8/\\pi^2$ 和一个单一谐波项。该谐波项是第一个非直流项。问题将 $A_1$ 定义为 $\\cos(4\\pi x/p)$ 项的振幅。通过观察，该振幅为：\n$$\nA_1 = \\frac{8}{\\pi^2}\n$$",
            "answer": "$$\\boxed{\\frac{8}{\\pi^2}}$$"
        },
        {
            "introduction": "在图像形成原理的基础上，本练习将带您进入一个真实的工程挑战：光学邻近效应修正（OPC）。您将编写一个程序，以确定亚分辨率辅助图形（SRAF）的最佳放置位置，从而在一定的焦距和剂量工艺窗口内提高主图形的印刷质量。这个练习展示了反向光刻的核心任务——主动设计掩模图形以在晶圆上实现预期的结果。",
            "id": "4134402",
            "problem": "考虑一个用于半导体制造过程建模的一维相干成像模型，该模型具有单点光源照明和薄透镜系统。您将使用光刻胶阈值模型，计算亚分辨率辅助图形（SRAF）相对于二元掩模上主清晰线边缘的最佳放置距离，并验证在指定的离焦和剂量变化窗口内SRAF不会被打印出来。在此，逆向光刻技术和光源掩模协同优化被定义为选择SRAF的放置位置，以优化主图形的成像质量，同时对辅助图形强制执行不打印约束。\n\n假设为标量、近轴、放大倍数为1的相干成像，具有二元实值振幅透射率的掩模，以及一个带限光瞳。令一维空间坐标为 $x$，单位为纳米。令波长为 $\\lambda$（单位为纳米），数值孔径（NA）为一个无单位的正值。像平面中的相干成像振幅由掩模频谱与带有离焦相位的瞳函数的乘积的傅里叶逆变换给出。具体来说，定义空间频率变量为 $k$（单位为周期/纳米），光瞳截止频率为 $k_c = \\mathrm{NA} / \\lambda$，以及光瞳边缘的离焦参数（以波长数计）为 $N_\\mathrm{waves}$（无单位）。光瞳函数是一个带有二次相位的低通滤波器：\n$$\nP(k;N_\\mathrm{waves}) = \\begin{cases}\n\\exp\\!\\left(i\\,2\\pi\\,N_\\mathrm{waves}\\left(\\frac{k}{k_c}\\right)^2\\right),  |k| \\le k_c, \\\\\n0,  |k|  k_c.\n\\end{cases}\n$$\n令掩模振幅透射率为 $m(x) \\in \\{0,1\\}$，在清晰开口内部等于1，其他地方等于0。相干像平面复数场为\n$$\nE(x;N_\\mathrm{waves}) = \\mathcal{F}^{-1}\\left\\{\\mathcal{F}\\{m(x)\\}\\cdot P(k;N_\\mathrm{waves})\\right\\},\n$$\n且空间像强度为 $I(x;N_\\mathrm{waves}) = |E(x;N_\\mathrm{waves})|^2$。对强度进行归一化，使得均匀无限大的清晰掩模产生 $I(x)=1$。为了在数值上实现此归一化，定义 $I_\\mathrm{uniform}(x;N_\\mathrm{waves})$ 为在相同 $P(k;N_\\mathrm{waves})$ 条件下 $m(x) \\equiv 1$ 时的强度，并使用\n$$\n\\tilde{I}(x;N_\\mathrm{waves}) = \\frac{I(x;N_\\mathrm{waves})}{\\langle I_\\mathrm{uniform}(x;N_\\mathrm{waves})\\rangle},\n$$\n其中 $\\langle \\cdot \\rangle$ 表示空间平均值，确保对于均匀清晰掩模，$\\tilde{I}(x)=1$。\n\n使用一个带有剂量缩放的简单光刻胶阈值模型：对于给定的剂量 $D$（无单位，相对于标称值），如果 $D\\,\\tilde{I}(x;N_\\mathrm{waves}) \\ge I_\\mathrm{th}$，则位置 $x$ 会被打印，其中 $I_\\mathrm{th}$ 是光刻胶阈值（无单位）。否则，它不会被打印。\n\n掩模几何规格：\n- 一条宽度为 $W_\\mathrm{main}$ 的主清晰线，中心在 $x=0$ 处，即对于 $|x|\\le W_\\mathrm{main}/2$，$m(x)=1$。\n- 一个宽度为 $W_\\mathrm{a}$ 的矩形SRAF放置在主线的右侧。其近边缘距离主线右边缘为 $s$，因此它占据的区域为 $x \\in [W_\\mathrm{main}/2 + s,\\, W_\\mathrm{main}/2 + s + W_\\mathrm{a}]$。\n\n优化目标和约束条件：\n- 定义标称剂量 $D_\\mathrm{nom} = (D_\\mathrm{min} + D_\\mathrm{max})/2$。\n- 定义标称阈值穿越水平 $I_\\mathrm{cross} = I_\\mathrm{th}/D_\\mathrm{nom}$。\n- 在标称焦平面（$N_\\mathrm{waves}=0$）上，定义右边缘阈值穿越位置 $x^\\star$ 为右边缘附近满足 $\\tilde{I}(x^\\star;0) = I_\\mathrm{cross}$ 的位置（取从主线向外移动的第一个穿越点）。定义穿越点处的边缘斜率大小为 $S = \\left|\\frac{d\\tilde{I}}{dx}\\big|_{x^\\star}\\right|$。\n- 选择 $s$ 以最大化 $S$，同时满足在指定工艺窗口内的以下不打印和打印约束：\n    1. SRAF不打印：对于离焦集合中的所有 $N_\\mathrm{waves}$ 和 $D \\in [D_\\mathrm{min}, D_\\mathrm{max}]$，在SRAF中心 $x_\\mathrm{a,center} = W_\\mathrm{main}/2 + s + W_\\mathrm{a}/2$ 处，要求 $D\\,\\tilde{I}(x_\\mathrm{a,center};N_\\mathrm{waves})  I_\\mathrm{th}$。\n    2. 主图形打印：对于离焦集合中的所有 $N_\\mathrm{waves}$，在剂量 $D=D_\\mathrm{min}$ 时，在主图形中心 $x=0$ 处，要求 $D_\\mathrm{min}\\,\\tilde{I}(0;N_\\mathrm{waves}) > I_\\mathrm{th}$。\n\n离焦集合规格：\n- 使用光瞳边缘处离焦值（以波长数计）的离散集合：$\\{-N_\\mathrm{max}, -N_\\mathrm{max}/2, 0, N_\\mathrm{max}/2, N_\\mathrm{max}\\}$。\n\n数值实现要求：\n- 在足够大的一维计算窗口上使用离散傅里叶变换执行相干成像，以避免环绕伪影。使用的空间采样需确保奈奎斯特（Nyquist）频率远超过 $k_c$。\n- 为所需的掩模配置和离焦值计算 $\\tilde{I}(x;N_\\mathrm{waves})$。\n- 在指定的离散范围内搜索 $s$，以找到能最大化 $S$ 的可行 $s$。如果不存在可行的 $s$，则该测试用例返回 $-1$。\n\n单位和输出：\n- 所有距离（$W_\\mathrm{main}$、$W_\\mathrm{a}$、$s$）必须以纳米为单位处理，返回的最优 $s$ 必须以纳米为单位表示，并四舍五入到一位小数的浮点数。如果不可行，则返回整数 $-1$。\n- 不涉及角度，因此不需要角度单位。\n\n测试套件：\n为以下每组参数计算最优SRAF放置距离 $s$。对于每个测试用例，按给定的范围搜索 $s$。最终输出必须为单行，包含由方括号括起来的四个结果，结果之间用逗号分隔。\n\n- 情况1 (典型干法光刻):\n    - $\\lambda = 193$ nm, $\\mathrm{NA} = 0.85$, $W_\\mathrm{main} = 40$ nm, $W_\\mathrm{a} = 15$ nm\n    - $I_\\mathrm{th} = 0.30$, $D_\\mathrm{min} = 0.90$, $D_\\mathrm{max} = 1.10$\n    - $N_\\mathrm{max} = 0.20$ waves\n    - $s \\in [20, 200]$ nm，步长为 $2$ nm\n\n- 情况2 (较低数值孔径):\n    - $\\lambda = 193$ nm, $\\mathrm{NA} = 0.50$, $W_\\mathrm{main} = 40$ nm, $W_\\mathrm{a} = 15$ nm\n    - $I_\\mathrm{th} = 0.30$, $D_\\mathrm{min} = 0.90$, $D_\\mathrm{max} = 1.10$\n    - $N_\\mathrm{max} = 0.20$ waves\n    - $s \\in [20, 200]$ nm，步长为 $2$ nm\n\n- 情况3 (高数值孔径，更严格的剂量和更大的离焦窗口):\n    - $\\lambda = 193$ nm, $\\mathrm{NA} = 1.35$, $W_\\mathrm{main} = 30$ nm, $W_\\mathrm{a} = 12$ nm\n    - $I_\\mathrm{th} = 0.25$, $D_\\mathrm{min} = 0.95$, $D_\\mathrm{max} = 1.05$\n    - $N_\\mathrm{max} = 0.30$ waves\n    - $s \\in [20, 200]$ nm，步长为 $2$ nm\n\n- 情况4 (窄主线):\n    - $\\lambda = 193$ nm, $\\mathrm{NA} = 0.93$, $W_\\mathrm{main} = 20$ nm, $W_\\mathrm{a} = 10$ nm\n    - $I_\\mathrm{th} = 0.28$, $D_\\mathrm{min} = 0.90$, $D_\\mathrm{max} = 1.10$\n    - $N_\\mathrm{max} = 0.25$ waves\n    - $s \\in [20, 200]$ nm，步长为 $2$ nm\n\n最终输出格式：\n您的程序应产生单行输出，其中包含用方括号括起来并以逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是纳米单位的最优SRAF放置距离 $s$，四舍五入到一位小数，或者如果在约束和搜索范围内未找到可行解，则为整数-1。",
            "solution": "用户在计算光刻领域提供了一个适定问题，该领域是半导体制造过程建模的一个分支。任务是确定亚分辨率辅助图形（SRAF）的最佳放置位置，以增强光掩模上主图形的成像质量。\n\n该问题将遵循以下基于结构化原则的方法来解决：\n\n1.  **问题建模**：问题的核心在于使用傅里叶光学对一维相干光学成像系统进行建模。该系统将二元掩模的振幅透射率 $m(x)$ 映射到像平面上的空间像强度 $\\tilde{I}(x)$。目标是优化SRAF的位置 $s$，以最大化主图形边缘的图像斜率 $S$，同时满足工艺窗口（离焦和曝光剂量的变化）的约束条件。\n\n2.  **成像模型实现**：根据规定，空间像是通过傅里叶变换路径计算的：$E(x) = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{m(x)\\} \\cdot P(k)\\}$，其中 $P(k)$ 是光瞳函数。这等效于掩模 $m(x)$ 与相干点扩散函数 $h(x) = \\mathcal{F}^{-1}\\{P(k)\\}$ 的卷积。对于数值计算，我们将使用由`numpy.fft`实现的离散傅里叶变换（DFT）。\n    -   为空间坐标 $x$ 建立一个足够大的计算网格，以防止基于DFT的卷积固有的循环卷积伪影。\n    -   选择空间采样间隔 $\\Delta x$，以确保奈奎斯特频率 $k_{\\mathrm{Nyquist}} = 1/(2\\Delta x)$ 远高于光瞳的截止频率 $k_c = \\mathrm{NA} / \\lambda$。\n    -   对于每个候选的SRAF位置 $s$，将掩模透射率函数 $m(x)$ 在此网格上离散化。\n    -   光瞳函数 $P(k; N_{\\mathrm{waves}})$ 也在相应的频域网格 $k$ 上离散化。它作为一个带有依赖于离焦的二次相位项的低通滤波器。\n    -   对于每个离焦值，计算掩模频谱与光瞳函数的乘积，然后进行傅里叶逆变换以获得像平面中的复电场 $E(x)$。\n    -   强度则为 $I(x) = |E(x)|^2$。\n    -   问题指定了一个归一化过程。对于均匀清晰掩模 ($m(x) \\equiv 1$)，光学系统在 $P(k=0)=1$ 的条件下，产生均匀场 $E(x)=1$ 和强度 $I(x)=1$。因此，指定的归一化因子 $\\langle I_{\\mathrm{uniform}} \\rangle$ 的计算结果为1。归一化强度 $\\tilde{I}(x)$ 因此与计算出的 $I(x)$ 相同。尽管该因子为1，但为了完全遵从要求，将按所述实现此过程。\n\n3.  **优化与约束检查**：解决方案涉及在规定的SRAF放置距离 $s$ 的离散范围内进行搜索。对于每个 $s$ 值：\n    a.  **可行性分析**：根据指定的工艺窗口测试放置的可行性。这涉及为所有五个离散离焦值（$\\{-N_{\\mathrm{max}}, -N_{\\mathrm{max}}/2, 0, N_{\\mathrm{max}}/2, N_{\\mathrm{max}}\\}$）计算空间像 $\\tilde{I}(x; N_{\\mathrm{waves}})$。\n        i.  **主图形打印约束**：为使主图形可靠打印，其中心强度即使在最低剂量 $D_{\\mathrm{min}}$下也必须保持在光刻胶阈值之上。这转化为条件 $\\tilde{I}(0;N_{\\mathrm{waves}}) > I_{\\mathrm{th}} / D_{\\mathrm{min}}$，对所有离焦值均成立。\n        ii. **SRAF不打印约束**：SRAF不得打印。这在最高剂量 $D_{\\mathrm{max}}$ 时最为关键。条件是在SRAF中心 $x_{\\mathrm{a,center}}$ 处的强度必须保持在光刻胶阈值以下：$\\tilde{I}(x_{\\mathrm{a,center}};N_{\\mathrm{waves}})  I_{\\mathrm{th}} / D_{\\mathrm{max}}$，对所有离焦值均成立。\n        如果所有离焦条件下的两个约束都得到满足，则SRAF放置位置 $s$ 被视为可行。\n\n    b.  **目标函数评估**：如果 $s$ 可行，则计算目标函数，即图形边缘的图像对数斜率（ILS）或简称为图像斜率大小 $S$。这是在标称焦平面（$N_{\\mathrm{waves}}=0$）上执行的。\n        i.  边缘位置的目标强度水平为 $I_{\\mathrm{cross}} = I_{\\mathrm{th}}/D_{\\mathrm{nom}}$，其中 $D_{\\mathrm{nom}} = (D_{\\mathrm{min}} + D_{\\mathrm{max}})/2$。\n        ii. 边缘位置 $x^{\\star}$ 是通过在主图形右边缘附近（$x \\approx W_{\\mathrm{main}}/2$）定位坐标找到的，在该坐标处 $\\tilde{I}(x^{\\star}; 0) = I_{\\mathrm{cross}}$。这是通过找到强度穿过阈值的网格段并使用线性插值来完成的。\n        iii. 强度的导数 $d\\tilde{I}/dx$ 使用有限差分法（`numpy.gradient`）进行数值计算。\n        iv. 斜率大小 $S = |\\frac{d\\tilde{I}}{dx}|$ 是通过在位置 $x^{\\star}$ 处对计算出的梯度进行插值得到的。\n\n4.  **最优解选择**：算法遍历所有候选的 $s$ 值，记录迄今为止产生最高斜率 $S$ 的可行 $s$。如果在搜索范围内未找到可行的 $s$ 值，则根据问题规范，该测试用例的结果为 $-1$。否则，报告最优的 $s$，并四舍五入到一位小数。对所提供的四个测试用例中的每一个都重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the SRAF placement problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: typical dry lithography\n        {\n            \"lambda_nm\": 193.0, \"NA\": 0.85, \"W_main\": 40.0, \"W_a\": 15.0,\n            \"I_th\": 0.30, \"D_min\": 0.90, \"D_max\": 1.10,\n            \"N_max\": 0.20, \"s_range\": (20, 200, 2)\n        },\n        # Case 2: lower numerical aperture\n        {\n            \"lambda_nm\": 193.0, \"NA\": 0.50, \"W_main\": 40.0, \"W_a\": 15.0,\n            \"I_th\": 0.30, \"D_min\": 0.90, \"D_max\": 1.10,\n            \"N_max\": 0.20, \"s_range\": (20, 200, 2)\n        },\n        # Case 3: high numerical aperture, tighter dose and larger defocus window\n        {\n            \"lambda_nm\": 193.0, \"NA\": 1.35, \"W_main\": 30.0, \"W_a\": 12.0,\n            \"I_th\": 0.25, \"D_min\": 0.95, \"D_max\": 1.05,\n            \"N_max\": 0.30, \"s_range\": (20, 200, 2)\n        },\n        # Case 4: narrow main line\n        {\n            \"lambda_nm\": 193.0, \"NA\": 0.93, \"W_main\": 20.0, \"W_a\": 10.0,\n            \"I_th\": 0.28, \"D_min\": 0.90, \"D_max\": 1.10,\n            \"N_max\": 0.25, \"s_range\": (20, 200, 2)\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_sraf_placement(**case)\n        if result == -1:\n            results.append(-1)\n        else:\n            results.append(round(result, 1))\n    \n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\n\ndef find_optimal_sraf_placement(lambda_nm, NA, W_main, W_a, I_th, D_min, D_max, N_max, s_range):\n    \"\"\"\n    Computes the optimal SRAF placement for a single set of parameters.\n    \"\"\"\n    # 1. Numerical Grid Setup\n    N_points = 4096\n    dx = 1.0  # nm\n    L = N_points * dx\n    x = np.linspace(-L / 2, L / 2, N_points, endpoint=False)\n    k = np.fft.fftshift(np.fft.fftfreq(N_points, d=dx))\n\n    # 2. Parameter Calculation\n    k_c = NA / lambda_nm\n    defocus_set = [-N_max, -N_max / 2, 0, N_max / 2, N_max]\n    \n    D_nom = (D_min + D_max) / 2.0\n    I_cross = I_th / D_nom\n    \n    # Process window thresholds for normalized intensity\n    I_main_print_min = I_th / D_min\n    I_sraf_nonprint_max = I_th / D_max\n\n    # 3. Pre-compute Pupil Functions and Normalization\n    pupil_functions = {}\n    norm_factors = {}\n    \n    # Pupil for normalization\n    m_uniform = np.ones(N_points)\n    M_uniform_k = np.fft.fftshift(np.fft.fft(m_uniform))\n\n    for n_waves in defocus_set:\n        pupil = np.exp(1j * 2 * np.pi * n_waves * (k / k_c)**2)\n        pupil[np.abs(k) > k_c] = 0.0\n        pupil_functions[n_waves] = pupil\n\n        # Calculate normalization factor\n        E_uniform_field_k = M_uniform_k * pupil\n        e_uniform_x = np.fft.ifft(np.fft.ifftshift(E_uniform_field_k))\n        I_uniform_x = np.abs(e_uniform_x)**2\n        norm_factors[n_waves] = np.mean(I_uniform_x)\n        \n    # 4. Search for Optimal s\n    s_min, s_max, s_step = s_range\n    s_values = np.arange(s_min, s_max + s_step, s_step)\n    \n    best_s = -1\n    max_S = -1.0\n\n    for s in s_values:\n        # Create mask\n        m_x = np.zeros(N_points)\n        # Main feature\n        m_x[np.abs(x) = W_main / 2] = 1.0\n        # SRAF\n        sraf_start = W_main / 2 + s\n        sraf_end = sraf_start + W_a\n        m_x[(x >= sraf_start)  (x = sraf_end)] = 1.0\n        \n        M_k = np.fft.fftshift(np.fft.fft(m_x))\n\n        is_s_feasible = True\n        I_nominal = None\n        \n        for n_waves in defocus_set:\n            P_k = pupil_functions[n_waves]\n            norm = norm_factors[n_waves]\n\n            E_field_k = M_k * P_k\n            E_x = np.fft.ifft(np.fft.ifftshift(E_field_k))\n            I_x = np.abs(E_x)**2\n            I_tilde = I_x / norm\n\n            if n_waves == 0:\n                I_nominal = I_tilde\n\n            # Check main feature printing constraint\n            I_center = np.interp(0.0, x, I_tilde)\n            if I_center = I_main_print_min:\n                is_s_feasible = False\n                break\n            \n            # Check SRAF non-printing constraint\n            x_a_center = W_main / 2 + s + W_a / 2\n            I_sraf_center = np.interp(x_a_center, x, I_tilde)\n            if I_sraf_center >= I_sraf_nonprint_max:\n                is_s_feasible = False\n                break\n        \n        if is_s_feasible:\n            # Calculate slope S at nominal focus\n            x_search_start_idx = np.searchsorted(x, W_main / 2)\n            \n            I_minus_cross = I_nominal[x_search_start_idx:] - I_cross\n            \n            # Find first crossing index\n            cross_indices = np.where((I_minus_cross[:-1] > 0)  (I_minus_cross[1:] = 0))[0]\n            \n            if len(cross_indices) > 0:\n                idx = cross_indices[0] + x_search_start_idx\n                \n                # Linear interpolation to find x_star\n                x1, y1 = x[idx], I_nominal[idx]\n                x2, y2 = x[idx + 1], I_nominal[idx + 1]\n                x_star = x1 + (I_cross - y1) * (x2 - x1) / (y2 - y1)\n\n                # Calculate slope\n                grad_I = np.gradient(I_nominal, dx)\n                S = np.abs(np.interp(x_star, x, grad_I))\n\n                if S > max_S:\n                    max_S = S\n                    best_s = s\n    \n    return best_s\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "最后一个练习将视角从直接物理仿真提升到稳健性优化的数学结构层面。您将使用一个边缘位置误差（EPE）的代理模型，构建并求解一个凸优化问题，该问题明确地对工艺变化的敏感度进行惩罚。这项练习让您深入了解在光源-掩模协同优化（SMO）中用于创建能够抵御制造波动的稳健性设计的高级策略。",
            "id": "4134355",
            "problem": "要求您为一维线空间图案设计一个基于灵敏度的稳健逆光刻代理模型，该模型使用边缘放置误差 (EPE) 的离散代理模型，EPE 是低维掩模参数矢量和工艺参数的函数。目标是通过惩罚 EPE 相对于焦距和剂量的灵敏度的平方范数来计算稳健的掩模设计，然后量化在施加此惩罚时工艺窗口面积如何变化。为确保精确性，本问题中的每个数学实体都使用 LaTeX 书写。\n\n请从以下基本依据出发，您必须使用这些依据来推导您的算法：\n- Hopkins 成像模型和阈值光刻胶模型在局部可以通过光刻胶边缘位置误差的一阶泰勒展开很好地近似，因此边缘放置误差（用 $E$ 表示）可以建模为掩模控制量和工艺参数的仿射函数。在存在工艺变化（焦距和剂量）的情况下，对工艺参数的一阶灵敏度是提高工艺窗口稳健性的可靠设计目标。\n- 对于一个离散的焦距-剂量样本集，EPE 相对于焦距和剂量的梯度的平方范数可以用作降低灵敏度的惩罚项。\n\n代理模型。考虑由 $j \\in \\{1,2\\}$ 索引的两个关键边缘和一个掩模参数矢量 $\\mathbf{m} \\in \\mathbb{R}^2$，其中 $\\mathbf{m} = [m_0, m_1]^\\top$ 代表掩模偏置 ($m_0$) 和亚分辨率辅助特征振幅 ($m_1$)，两者均为无量纲。设工艺参数为归一化的无量纲离焦 $f$ 和归一化的剂量变化 $d$。在 $(f,d)$ 处，边缘 $j$ 的边缘放置误差建模为\n$$\nE_j(\\mathbf{m}, f, d) \\;=\\; \\mathbf{a}_j^\\top \\mathbf{m} \\;+\\; b_j f \\;+\\; c_j d \\;+\\; \\mathbf{d}_j^\\top \\mathbf{m}\\, f \\;+\\; \\mathbf{e}_j^\\top \\mathbf{m}\\, d \\;+\\; g_j f d,\n$$\n其中所有系数均为下面给出的常数。EPE $E_j$ 以纳米为单位，而 $f$ 和 $d$ 是无量纲的。\n\n灵敏度惩罚。$E_j$ 相对于焦距和剂量的灵敏度为\n$$\n\\nabla_{(f,d)} E_j(\\mathbf{m}, f, d) \\;=\\; \n\\begin{bmatrix}\n\\frac{\\partial E_j}{\\partial f} \\\\\n\\frac{\\partial E_j}{\\partial d}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\nb_j + \\mathbf{d}_j^\\top \\mathbf{m} + g_j d \\\\\nc_j + \\mathbf{e}_j^\\top \\mathbf{m} + g_j f\n\\end{bmatrix}.\n$$\n\n稳健设计目标。将稳健目标定义为 $\\mathbf{m}$ 的凸二次函数：\n$$\nJ(\\mathbf{m}) \\;=\\; \\sum_{j=1}^{2} \\left(\\mathbf{a}_j^\\top \\mathbf{m}\\right)^2 \\;+\\; \\lambda \\sum_{(f_k,d_k)\\in\\mathcal{S}} \\alpha_{k} \\sum_{j=1}^{2} \\left\\| \\nabla_{(f,d)} E_j(\\mathbf{m}, f_k, d_k) \\right\\|_2^2 \\;+\\; \\mu \\, \\|\\mathbf{m}\\|_2^2,\n$$\n其中 $\\lambda \\ge 0$ 是灵敏度惩罚权重，$\\mu  0$ 是一个小的 Tikhonov 正则化权重，$\\mathcal{S}$ 是焦距-剂量样本的有限集，$\\alpha_k \\ge 0$ 是非负权重。标称保真度项 $\\sum_{j=1}^{2} (\\mathbf{a}_j^\\top \\mathbf{m})^2$ 强制在标称工艺 $(f=d=0)$ 下的目标位置。\n\n系数。使用以下固定系数（与以纳米计量的 $E_j$ 和无量纲的 $f,d$ 量纲一致）：\n- $\\mathbf{a}_1 = \\begin{bmatrix} 1.0 \\\\ 0.2 \\end{bmatrix}$, $\\mathbf{a}_2 = \\begin{bmatrix} -0.9 \\\\ 0.25 \\end{bmatrix}$.\n- $b_1 = 1.0$, $b_2 = -0.8$.\n- $c_1 = 0.7$, $c_2 = -0.6$.\n- $\\mathbf{d}_1 = \\begin{bmatrix} -1.2 \\\\ -0.1 \\end{bmatrix}$, $\\mathbf{d}_2 = \\begin{bmatrix} 0.9 \\\\ -0.2 \\end{bmatrix}$.\n- $\\mathbf{e}_1 = \\begin{bmatrix} -0.8 \\\\ 0.05 \\end{bmatrix}$, $\\mathbf{e}_2 = \\begin{bmatrix} 0.7 \\\\ 0.1 \\end{bmatrix}$.\n- $g_1 = 0.1$, $g_2 = -0.05$.\n- $\\mu = 0.01$.\n\n惩罚采样集。设 $\\mathcal{S}$ 为一个 $3 \\times 3$ 的网格，其中 $f \\in \\{-0.2, 0.0, 0.2\\}$ 且 $d \\in \\{-0.2, 0.0, 0.2\\}$。\n\n工艺窗口。对于给定的 $\\mathbf{m}$，将工艺窗口区域 $\\mathcal{W}(\\mathbf{m}) \\subset \\mathbb{R}^2$ 定义为满足两个边缘均符合标量 EPE 容差的 $(f,d)$ 集合：\n$$\n\\mathcal{W}(\\mathbf{m}) \\;=\\; \\left\\{ (f,d) \\,:\\, \\max\\left(|E_1(\\mathbf{m}, f, d)|,\\, |E_2(\\mathbf{m}, f, d)|\\right) \\le \\tau \\right\\}.\n$$\n使用容差 $\\tau = 0.5$（单位：纳米）。在一个覆盖 $[-0.25, 0.25] \\times [-0.25, 0.25]$ 的均匀网格上估计 $\\mathcal{W}(\\mathbf{m})$ 的面积，其中 $f$ 和 $d$ 的步长均为 $0.01$，并将面积计算为 $\\mathcal{W}(\\mathbf{m})$ 内的网格点数乘以 $(0.01)^2$。由于 $f$ 和 $d$ 是无量纲的，所以工艺窗口面积也是无量纲的。\n\n计算任务。推导最小化 $J(\\mathbf{m})$ 的最优解 $\\mathbf{m}^\\star$ 的闭式表达式，并实现一个程序，为以下每个测试用例计算 $\\mathbf{m}^\\star$ 和相应的工艺窗口面积。在所有情况下，系数和 $\\mu$ 均如上所述，惩罚采样集 $\\mathcal{S}$ 是上面描述的 $3 \\times 3$ 网格，工艺窗口面积按所述方法计算。\n\n测试套件（每个用例定义 $(\\lambda, \\{\\alpha_k\\})$）：\n- 用例 A：$\\lambda = 0.0$ 且对于所有 $(f_k,d_k) \\in \\mathcal{S}$，$\\alpha_k = 1.0$。\n- 用例 B：$\\lambda = 0.5$ 和非均匀的 $\\alpha_k$（强调角点）：对于 $(f,d) \\in \\{-0.2, 0.0, 0.2\\}^2$，令\n  $$\n  \\boldsymbol{\\alpha} \\;=\\;\n  \\begin{bmatrix}\n  2.0  1.0  2.0 \\\\\n  1.0  1.0  1.0 \\\\\n  2.0  1.0  2.0\n  \\end{bmatrix},\n  $$\n  其中行对应 $f = -0.2, 0.0, 0.2$，列对应 $d = -0.2, 0.0, 0.2$。\n- 用例 C：$\\lambda = 2.0$，使用与用例 B 相同的非均匀 $\\boldsymbol{\\alpha}$。\n- 用例 D：$\\lambda = 2.0$ 且对于所有 $(f_k,d_k) \\in \\mathcal{S}$，$\\alpha_k = 0.0$。\n\n要求输出。按 A、B、C、D 的顺序，为每个用例使用指定的网格和容差计算 $\\mathcal{W}(\\mathbf{m}^\\star)$ 的工艺窗口面积。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[areaA,areaB,areaC,areaD]\"），其中每个面积是保留六位小数的十进制数。这些面积是无量纲的。\n\n约束和说明：\n- 您必须将 $f$ 和 $d$ 视为无量纲的归一化量，将 $E_j$ 视为以纳米为单位。最终输出的面积必须是保留六位小数的无量纲十进制浮点数。\n- 不使用角度，因此不需要角度单位。\n- 不使用百分比；任何分数值都必须表示为小数。\n- 您必须通过推导和构建关于 $\\mathbf{m}$ 的二次目标函数，精确求解（在数值精度范围内）所得的线性系统，并按规定评估工艺窗口面积来实现您的求解器。",
            "solution": "用户在计算光刻领域提供了一个适定问题，该领域是半导体制造过程建模的一个分支。任务是通过最小化一个指定的目标函数来找到一个稳健的掩模设计，然后评估该优化对工艺窗口的影响。该问题有科学依据、内容自洽且可通过算法求解。\n\n问题的核心是找到最小化凸二次目标函数 $J(\\mathbf{m})$ 的掩模参数矢量 $\\mathbf{m} \\in \\mathbb{R}^2$：\n$$\nJ(\\mathbf{m}) \\;=\\; \\underbrace{\\sum_{j=1}^{2} \\left(\\mathbf{a}_j^\\top \\mathbf{m}\\right)^2}_{\\text{标称保真度}} \\;+\\; \\underbrace{\\lambda \\sum_{(f_k,d_k)\\in\\mathcal{S}} \\alpha_{k} \\sum_{j=1}^{2} \\left\\| \\nabla_{(f,d)} E_j(\\mathbf{m}, f_k, d_k) \\right\\|_2^2}_{\\text{灵敏度惩罚}} \\;+\\; \\underbrace{\\mu \\, \\|\\mathbf{m}\\|_2^2}_{\\text{正则化}}.\n$$\n由于 $J(\\mathbf{m})$ 是关于 $\\mathbf{m}$ 的凸二次函数，其唯一的最小化子 $\\mathbf{m}^\\star$ 可以通过将其关于 $\\mathbf{m}$ 的梯度设为零来找到：\n$$\n\\nabla_\\mathbf{m} J(\\mathbf{m}) = \\mathbf{0}.\n$$\n这将产生一个形式为 $\\mathbf{A}\\mathbf{m} = \\mathbf{b}$ 的线性方程组，其中 $\\mathbf{A}$ 是一个 $2 \\times 2$ 矩阵，$\\mathbf{b}$ 是一个 $2 \\times 1$ 矢量。我们将通过对 $J(\\mathbf{m})$ 的每一项进行微分来推导 $\\mathbf{A}$ 和 $\\mathbf{b}$ 的表达式。\n\n标称保真度项的梯度是：\n$$\n\\nabla_\\mathbf{m} \\left( \\sum_{j=1}^{2} \\left(\\mathbf{a}_j^\\top \\mathbf{m}\\right)^2 \\right) = \\nabla_\\mathbf{m} \\left( \\sum_{j=1}^{2} \\mathbf{m}^\\top \\mathbf{a}_j \\mathbf{a}_j^\\top \\mathbf{m} \\right) = 2 \\left( \\sum_{j=1}^{2} \\mathbf{a}_j \\mathbf{a}_j^\\top \\right) \\mathbf{m}.\n$$\n\n正则化项的梯度是：\n$$\n\\nabla_\\mathbf{m} \\left( \\mu \\|\\mathbf{m}\\|_2^2 \\right) = \\nabla_\\mathbf{m} \\left( \\mu \\mathbf{m}^\\top \\mathbf{m} \\right) = 2 \\mu \\mathbf{I} \\mathbf{m},\n$$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。\n\n灵敏度惩罚项的梯度更为复杂。首先，我们用 $\\mathbf{m}$ 来表示 EPE 梯度 $\\nabla_{(f,d)} E_j$：\n$$\n\\nabla_{(f,d)} E_j(\\mathbf{m}, f_k, d_k) =\n\\begin{bmatrix}\nb_j + \\mathbf{d}_j^\\top \\mathbf{m} + g_j d_k \\\\\nc_j + \\mathbf{e}_j^\\top \\mathbf{m} + g_j f_k\n\\end{bmatrix}.\n$$\n平方范数是：\n$$\n\\left\\| \\nabla_{(f,d)} E_j \\right\\|_2^2 = (b_j + g_j d_k + \\mathbf{d}_j^\\top \\mathbf{m})^2 + (c_j + g_j f_k + \\mathbf{e}_j^\\top \\mathbf{m})^2.\n$$\n此项关于 $\\mathbf{m}$ 的梯度是：\n$$\n\\nabla_\\mathbf{m} \\left\\| \\nabla_{(f,d)} E_j \\right\\|_2^2 = 2 (b_j + g_j d_k + \\mathbf{d}_j^\\top \\mathbf{m}) \\mathbf{d}_j + 2 (c_j + g_j f_k + \\mathbf{e}_j^\\top \\mathbf{m}) \\mathbf{e}_j.\n$$\n重新整理各项，我们得到：\n$$\n\\nabla_\\mathbf{m} \\left\\| \\nabla_{(f,d)} E_j \\right\\|_2^2 = 2(\\mathbf{d}_j \\mathbf{d}_j^\\top + \\mathbf{e}_j \\mathbf{e}_j^\\top)\\mathbf{m} + 2 \\left( (b_j + g_j d_k)\\mathbf{d}_j + (c_j + g_j f_k)\\mathbf{e}_j \\right).\n$$\n现在，我们通过对 $j$ 和 $k$ 求和来计算完整灵敏度惩罚项的梯度：\n$$\n\\nabla_\\mathbf{m} \\left( \\lambda \\sum_{k} \\alpha_k \\sum_{j} \\left\\| \\nabla E_j \\right\\|_2^2 \\right) = 2\\lambda \\sum_k \\alpha_k \\sum_j \\left[ (\\mathbf{d}_j \\mathbf{d}_j^\\top + \\mathbf{e}_j \\mathbf{e}_j^\\top)\\mathbf{m} + (b_j + g_j d_k)\\mathbf{d}_j + (c_j + g_j f_k)\\mathbf{e}_j \\right].\n$$\n这可以分离为一个与 $\\mathbf{m}$ 成正比的项和一个常数项：\n$$\n= 2\\lambda \\left( \\sum_k \\alpha_k \\right) \\left( \\sum_j (\\mathbf{d}_j \\mathbf{d}_j^\\top + \\mathbf{e}_j \\mathbf{e}_j^\\top) \\right) \\mathbf{m} + 2\\lambda \\sum_k \\alpha_k \\sum_j \\left( (b_j + g_j d_k)\\mathbf{d}_j + (c_j + g_j f_k)\\mathbf{e}_j \\right).\n$$\n\n合并所有梯度并将总和设为零，$\\nabla_\\mathbf{m} J(\\mathbf{m}) = \\mathbf{0}$，得出：\n$$\n\\left( 2 \\sum_j \\mathbf{a}_j \\mathbf{a}_j^\\top + 2\\lambda (\\sum_k \\alpha_k) \\sum_j (\\mathbf{d}_j \\mathbf{d}_j^\\top + \\mathbf{e}_j \\mathbf{e}_j^\\top) + 2\\mu \\mathbf{I} \\right) \\mathbf{m} = -2\\lambda \\sum_k \\alpha_k \\sum_j \\left( (b_j + g_j d_k)\\mathbf{d}_j + (c_j + g_j f_k)\\mathbf{e}_j \\right).\n$$\n两边除以 $2$ 得到线性系统 $\\mathbf{A} \\mathbf{m} = \\mathbf{b}$，其中：\n$$\n\\mathbf{A} = \\sum_{j=1}^2 \\mathbf{a}_j \\mathbf{a}_j^\\top + \\mu \\mathbf{I} + \\lambda \\left(\\sum_k \\alpha_k\\right) \\left(\\sum_{j=1}^2 (\\mathbf{d}_j \\mathbf{d}_j^\\top + \\mathbf{e}_j \\mathbf{e}_j^\\top)\\right),\n$$\n$$\n\\mathbf{b} = -\\lambda \\sum_k \\alpha_k \\sum_j \\left[ (b_j + g_j d_k)\\mathbf{d}_j + (c_j + g_j f_k)\\mathbf{e}_j \\right].\n$$\n通过重新排列求和顺序，可以简化矢量 $\\mathbf{b}$：\n$$\n\\mathbf{b} = -\\lambda \\sum_j \\left[ \\left(b_j(\\sum_k \\alpha_k) + g_j(\\sum_k \\alpha_k d_k)\\right)\\mathbf{d}_j + \\left(c_j(\\sum_k \\alpha_k) + g_j(\\sum_k \\alpha_k f_k)\\right)\\mathbf{e}_j \\right].\n$$\n对于每个测试用例，我们使用给定的 $\\lambda$ 和 $\\alpha_k$ 值计算矩阵 $\\mathbf{A}$ 和矢量 $\\mathbf{b}$，然后求解系统 $\\mathbf{A} \\mathbf{m}^\\star = \\mathbf{b}$ 以获得最优掩模参数 $\\mathbf{m}^\\star$。\n\n找到 $\\mathbf{m}^\\star$ 后，我们评估工艺窗口面积。边缘 $j$ 的边缘放置误差由下式给出：\n$$\nE_j(\\mathbf{m}^\\star, f, d) = C_{0,j} + C_{f,j} f + C_{d,j} d + g_j f d,\n$$\n其中给定 $\\mathbf{m}^\\star$ 的系数为：\n$$\nC_{0,j} = \\mathbf{a}_j^\\top \\mathbf{m}^\\star, \\quad C_{f,j} = b_j + \\mathbf{d}_j^\\top \\mathbf{m}^\\star, \\quad C_{d,j} = c_j + \\mathbf{e}_j^\\top \\mathbf{m}^\\star.\n$$\n工艺窗口 $\\mathcal{W}(\\mathbf{m}^\\star)$ 是满足 $|E_j(\\mathbf{m}^\\star, f, d)| \\le \\tau$（对于 $j=1,2$）的点 $(f, d)$ 的集合，其中 $\\tau=0.5$。我们通过以 $0.01$ 的步长离散化域 $[-0.25, 0.25] \\times [-0.25, 0.25]$ 来估计其面积。面积是满足条件的网格点数乘以一个网格单元的面积，即 $(0.01)^2$。\n\n算法如下：\n1. 预计算常数矩阵：$\\sum_j \\mathbf{a}_j \\mathbf{a}_j^\\top$ 和 $\\sum_j (\\mathbf{d}_j \\mathbf{d}_j^\\top + \\mathbf{e}_j \\mathbf{e}_j^\\top)$。\n2. 对于每个测试用例 $(\\lambda, \\{\\alpha_k\\})$：\n   a. 计算总和 $\\sum_k \\alpha_k$、$\\sum_k \\alpha_k f_k$ 和 $\\sum_k \\alpha_k d_k$。\n   b. 使用推导出的公式构建矩阵 $\\mathbf{A}$ 和矢量 $\\mathbf{b}$。\n   c. 求解线性系统 $\\mathbf{A} \\mathbf{m}^\\star = \\mathbf{b}$ 以获得 $\\mathbf{m}^\\star$。一个特殊情况是当 $\\mathbf{b} = \\mathbf{0}$ 时，这在 $\\lambda=0$ 或所有 $\\alpha_k=0$ 时发生，由于 $\\mathbf{A}$ 是正定的，导致 $\\mathbf{m}^\\star = \\mathbf{0}$。\n   d. 计算工艺窗口面积：\n      i. 使用 $\\mathbf{m}^\\star$ 计算系数 $C_{0,j}、C_{f,j}、C_{d,j}$。\n      ii. 生成 $(f,d)$ 网格。\n      iii. 在网格上评估 $E_1$ 和 $E_2$。\n      iv. 统计满足 $|E_1| \\le \\tau$ 和 $|E_2| \\le \\tau$ 的网格点数。\n      v. 将计数乘以 $(0.01)^2$ 以获得面积。\n3. 收集所有测试用例的面积并格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust inverse lithography problem for four test cases.\n    \"\"\"\n    # Define coefficients and constants as numpy arrays\n    a1 = np.array([1.0, 0.2])\n    a2 = np.array([-0.9, 0.25])\n    b1, b2 = 1.0, -0.8\n    c1, c2 = 0.7, -0.6\n    d1 = np.array([-1.2, -0.1])\n    d2 = np.array([0.9, -0.2])\n    e1 = np.array([-0.8, 0.05])\n    e2 = np.array([0.7, 0.1])\n    g1, g2 = 0.1, -0.05\n    mu = 0.01\n    tau = 0.5\n    \n    # Pack coefficients for easier iteration\n    a = [a1, a2]\n    b = [b1, b2]\n    c = [c1, c2]\n    d = [d1, d2]\n    e = [e1, e2]\n    g = [g1, g2]\n\n    # Pre-compute constant matrix parts\n    A_fidelity = np.outer(a1, a1) + np.outer(a2, a2)\n    A_reg = mu * np.identity(2)\n    A_sens_sum = (np.outer(d1, d1) + np.outer(d2, d2) +\n                  np.outer(e1, e1) + np.outer(e2, e2))\n\n    # Define the penalty sampling set S\n    f_samples = np.array([-0.2, 0.0, 0.2])\n    d_samples = np.array([-0.2, 0.0, 0.2])\n    \n    # Define test cases\n    alpha_B_C = np.array([[2.0, 1.0, 2.0], [1.0, 1.0, 1.0], [2.0, 1.0, 2.0]])\n    test_cases = [\n        {'lambda': 0.0, 'alpha': np.ones((3, 3))},\n        {'lambda': 0.5, 'alpha': alpha_B_C},\n        {'lambda': 2.0, 'alpha': alpha_B_C},\n        {'lambda': 2.0, 'alpha': np.zeros((3, 3))},\n    ]\n\n    results = []\n    \n    # --- Process Window Area Calculation Function ---\n    def calculate_pw_area(m_star):\n        # PW grid setup\n        grid_step = 0.01\n        f_grid_pts = np.arange(-0.25, 0.25 + grid_step / 2, grid_step)\n        d_grid_pts = np.arange(-0.25, 0.25 + grid_step / 2, grid_step)\n        f_pw_grid, d_pw_grid = np.meshgrid(f_grid_pts, d_grid_pts)\n\n        # Calculate EPE on the grid for both edges\n        C0 = [aj.T @ m_star for aj in a]\n        Cf = [bj + dj.T @ m_star for bj, dj in zip(b, d)]\n        Cd = [cj + ej.T @ m_star for cj, ej in zip(c, e)]\n\n        E1 = C0[0] + Cf[0] * f_pw_grid + Cd[0] * d_pw_grid + g[0] * f_pw_grid * d_pw_grid\n        E2 = C0[1] + Cf[1] * f_pw_grid + Cd[1] * d_pw_grid + g[1] * f_pw_grid * d_pw_grid\n\n        # Check tolerance condition\n        valid_points = (np.abs(E1) = tau)  (np.abs(E2) = tau)\n        \n        # Calculate area\n        area = np.sum(valid_points) * (grid_step ** 2)\n        return area\n\n    # --- Main Loop for Test Cases ---\n    for case in test_cases:\n        lambda_val = case['lambda']\n        alpha_k = case['alpha']\n\n        sum_alpha = np.sum(alpha_k)\n\n        if lambda_val == 0.0 or sum_alpha == 0.0:\n            m_star = np.array([0.0, 0.0])\n        else:\n            # Calculate sums over the sampling grid S\n            # f_samples[:, np.newaxis] ensures broadcasting matches alpha_k shape (3,3)\n            sum_alpha_f = np.sum(alpha_k * f_samples[:, np.newaxis])\n            sum_alpha_d = np.sum(alpha_k * d_samples[np.newaxis, :])\n            \n            # Assemble the matrix A\n            A = A_fidelity + A_reg + lambda_val * sum_alpha * A_sens_sum\n\n            # Assemble the vector b\n            b_vec = np.zeros(2)\n            for j in range(2):\n                term_d = (b[j] * sum_alpha + g[j] * sum_alpha_d) * d[j]\n                term_e = (c[j] * sum_alpha + g[j] * sum_alpha_f) * e[j]\n                b_vec += term_d + term_e\n            b_vec *= -lambda_val\n            \n            # Solve for m_star\n            m_star = np.linalg.solve(A, b_vec)\n        \n        # Calculate process window area for the optimal m_star\n        area = calculate_pw_area(m_star)\n        results.append(f\"{area:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}