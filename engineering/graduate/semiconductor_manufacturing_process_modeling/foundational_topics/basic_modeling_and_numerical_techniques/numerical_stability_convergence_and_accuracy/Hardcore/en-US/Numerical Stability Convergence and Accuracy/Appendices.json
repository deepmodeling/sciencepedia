{
    "hands_on_practices": [
        {
            "introduction": "Many phenomena in semiconductor process modeling, such as reaction kinetics, involve processes with widely varying time scales, leading to numerically \"stiff\" systems of equations. This practice illuminates the fundamental challenge of stiffness by contrasting an explicit Runge-Kutta method with an implicit Backward Differentiation Formula. By determining the required number of steps for each to meet stability and accuracy goals, you will gain a quantitative feel for why implicit methods are often indispensable for efficiently simulating these multiscale physical models. ",
            "id": "4145395",
            "problem": "Consider the fraction of electrically active dopants $a(t)$ during an isothermal anneal in semiconductor manufacturing. A widely used first-order kinetic model posits that activation and deactivation proceed via thermally activated reactions, yielding the linear ordinary differential equation\n$$\n\\frac{da}{dt} = k_{\\mathrm{on}}(T)\\,\\big(a_{\\mathrm{eq}} - a(t)\\big) - k_{\\mathrm{off}}(T)\\,a(t),\n$$\nwhere $a(t)$ is dimensionless, $t$ is in seconds, $T$ is in Kelvin, $a_{\\mathrm{eq}}$ is the equilibrium active fraction (dimensionless), and the rate coefficients obey Arrhenius laws\n$$\nk_{\\mathrm{on}}(T) = \\nu_{\\mathrm{on}}\\exp\\!\\left(-\\frac{E_{\\mathrm{on}}}{k_{\\mathrm{B}}T}\\right),\\quad\nk_{\\mathrm{off}}(T) = \\nu_{\\mathrm{off}}\\exp\\!\\left(-\\frac{E_{\\mathrm{off}}}{k_{\\mathrm{B}}T}\\right),\n$$\nwith $\\nu_{\\mathrm{on}}$ and $\\nu_{\\mathrm{off}}$ in $\\mathrm{s}^{-1}$, activation energies $E_{\\mathrm{on}}$ and $E_{\\mathrm{off}}$ in electronvolts, and $k_{\\mathrm{B}}$ the Boltzmann constant in $\\mathrm{eV/K}$. This model is linear with constant coefficients at fixed temperature and has the form\n$$\n\\frac{da}{dt} = c + \\lambda\\, a(t),\n$$\nwhere $\\lambda = -\\big(k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)\\big)$ and $c = k_{\\mathrm{on}}(T)\\,a_{\\mathrm{eq}}$.\n\nYou are to determine, for several parameter sets, the minimal number of uniform time steps needed to reach a final physical time $t_f$ while simultaneously satisfying numerical stability (when applicable) and accuracy constraints for two methods:\n- The classical explicit fourth-order Runge–Kutta method (RK4).\n- The implicit second-order Backward Differentiation Formula (BDF2), started with a single implicit trapezoidal step to maintain second-order accuracy.\n\nUse the following principles:\n- Absolute stability is defined with respect to the linear test equation $y'=\\lambda y$ and step size $h$ by requiring that the method’s amplification factor $R(h\\lambda)$ satisfy $\\lvert R(h\\lambda)\\rvert \\le 1$. Enforce this condition for the explicit method on the linearized model with constant $\\lambda$ as defined above. The implicit BDF2 method with the stated startup is to be treated according to its absolute stability properties for $\\operatorname{Re}(\\lambda)0$.\n- Accuracy is enforced by requiring the absolute global error at $t_f$ to be at most a user-specified tolerance $\\varepsilon$, i.e.,\n$$\n\\lvert a_{\\mathrm{num}}(t_f;h) - a_{\\mathrm{exact}}(t_f)\\rvert \\le \\varepsilon.\n$$\nHere $a_{\\mathrm{num}}(t_f;h)$ is the numerical solution at $t_f$ computed with uniform step size $h=t_f/N$ using the stated method, and $a_{\\mathrm{exact}}(t)$ is the exact solution of the linear model. The method’s startup for BDF2 must be the single-step implicit trapezoidal rule with the same step size $h$ to ensure second-order consistency.\n\nFundamental base and data:\n- Use the Arrhenius law and the linearity of the model as given above. The Boltzmann constant is $k_{\\mathrm{B}}=8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$.\n- The exact solution for the linear inhomogeneous equation with constant coefficients is\n$$\na_{\\mathrm{exact}}(t) = a_{\\infty} + \\big(a_0 - a_{\\infty}\\big)\\,e^{\\lambda t},\\quad a_{\\infty} = -\\frac{c}{\\lambda} = \\frac{k_{\\mathrm{on}}(T)}{k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)}\\,a_{\\mathrm{eq}},\n$$\nwith initial value $a(0)=a_0$.\n\nTask:\n- For each test case below, compute the smallest integer $N_{\\mathrm{RK4}}$ and $N_{\\mathrm{BDF2}}$ such that with $h=t_f/N$:\n  - For explicit RK4: both absolute stability on the linearized model and the accuracy constraint at $t_f$ hold.\n  - For implicit BDF2 (with a single implicit trapezoidal startup step): the accuracy constraint at $t_f$ holds. Treat stability according to the absolute stability of the method for $\\operatorname{Re}(\\lambda)0$.\n- Your algorithm must determine the minimal $N$ without using any closed-form \"shortcut\" global error constants; you may evaluate numerical solutions and compare against the exact solution. You must rigorously apply the absolute stability definition for the explicit method on the given linear model.\n\nPhysical units:\n- Time $t$ and $t_f$ in seconds, temperature $T$ in Kelvin, activation energies in electronvolts, rates in $\\mathrm{s}^{-1}$.\n- Report $N$ as integers.\n\nTest suite:\n- Case $1$: $T=1000\\,\\mathrm{K}$, $t_f=1.0\\,\\mathrm{s}$, $a_0=0.1$, $a_{\\mathrm{eq}}=0.9$, $\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{on}}=2.1\\,\\mathrm{eV}$, $\\nu_{\\mathrm{off}}=5.0\\times 10^{12}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{off}}=2.4\\,\\mathrm{eV}$, $\\varepsilon=1.0\\times 10^{-6}$.\n- Case $2$: $T=1150\\,\\mathrm{K}$, $t_f=0.1\\,\\mathrm{s}$, $a_0=0.05$, $a_{\\mathrm{eq}}=0.95$, $\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{on}}=2.0\\,\\mathrm{eV}$, $\\nu_{\\mathrm{off}}=8.0\\times 10^{12}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{off}}=2.2\\,\\mathrm{eV}$, $\\varepsilon=1.0\\times 10^{-8}$.\n- Case $3$: $T=850\\,\\mathrm{K}$, $t_f=10.0\\,\\mathrm{s}$, $a_0=0.2$, $a_{\\mathrm{eq}}=0.85$, $\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{on}}=2.4\\,\\mathrm{eV}$, $\\nu_{\\mathrm{off}}=5.0\\times 10^{12}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{off}}=2.8\\,\\mathrm{eV}$, $\\varepsilon=1.0\\times 10^{-6}$.\n\nNumerical requirements:\n- Use radians where any angles may appear.\n- All comparisons to the tolerance must be in absolute value (dimensionless).\n- For RK4, enforce absolute stability on the linearized model as defined above at each candidate step size $h$ via its stability function.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets of the form\n$$\n\\big[N_{\\mathrm{RK4}}^{(1)},N_{\\mathrm{BDF2}}^{(1)},N_{\\mathrm{RK4}}^{(2)},N_{\\mathrm{BDF2}}^{(2)},N_{\\mathrm{RK4}}^{(3)},N_{\\mathrm{BDF2}}^{(3)}\\big],\n$$\nwhere the superscript indicates the test case index. The elements must be integers. No additional text or formatting is allowed in the program’s output line.",
            "solution": "The user has provided a problem from the field of numerical analysis, applied to a physical model of dopant activation in semiconductor manufacturing. The task is to determine the minimum number of uniform time steps, $N$, required to solve a linear ordinary differential equation (ODE) up to a final time $t_f$ using two different numerical methods: the explicit fourth-order Runge-Kutta (RK4) method and the implicit second-order Backward Differentiation Formula (BDF2). The determination of $N$ must satisfy method-specific stability constraints and a common accuracy constraint.\n\nThe problem is validated as follows:\n- **Scientific Grounding**: The model is based on standard first-order reaction kinetics and the Arrhenius law, which are fundamental principles in physical chemistry and materials science. The problem is scientifically sound.\n- **Well-Posedness**: The ODE is a linear, first-order initial value problem with constant coefficients. A unique, stable solution is guaranteed. The constraints for numerical stability and accuracy are quantitatively defined. The task of finding the minimal integer $N$ is well-defined.\n- **Objectivity and Completeness**: The problem is stated using precise mathematical language and provides all necessary physical constants, parameters, initial conditions, and numerical tolerances for each test case. There are no ambiguities or subjective statements.\n\nThe problem is deemed valid and a step-by-step solution is constructed.\n\n### Step 1: Model Parameter Calculation\nFor each test case, we first compute the coefficients of the linear ODE, $\\frac{da}{dt} = c + \\lambda a(t)$.\nThe temperature $T$, activation energies $E_{\\mathrm{on}}, E_{\\mathrm{off}}$, and pre-exponential factors $\\nu_{\\mathrm{on}}, \\nu_{\\mathrm{off}}$ are used to calculate the rate coefficients using the Arrhenius equation:\n$$\nk_{\\mathrm{on}}(T) = \\nu_{\\mathrm{on}}\\exp\\!\\left(-\\frac{E_{\\mathrm{on}}}{k_{\\mathrm{B}}T}\\right)\n$$\n$$\nk_{\\mathrm{off}}(T) = \\nu_{\\mathrm{off}}\\exp\\!\\left(-\\frac{E_{\\mathrm{off}}}{k_{\\mathrm{B}}T}\\right)\n$$\nwhere $k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$.\nThe ODE parameters $\\lambda$ and $c$ are then:\n$$\n\\lambda = -\\big(k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)\\big)\n$$\n$$\nc = k_{\\mathrm{on}}(T)\\,a_{\\mathrm{eq}}\n$$\nSince $k_{\\mathrm{on}}$ and $k_{\\mathrm{off}}$ are always positive, $\\lambda$ is always real and negative.\n\n### Step 2: Exact Solution\nThe exact solution to the linear ODE is necessary to evaluate the accuracy of the numerical methods. Given the initial condition $a(0)=a_0$, the solution is:\n$$\na_{\\mathrm{exact}}(t) = a_{\\infty} + (a_0 - a_{\\infty})e^{\\lambda t}\n$$\nwhere $a_{\\infty}$ is the steady-state solution:\n$$\na_{\\infty} = -\\frac{c}{\\lambda} = \\frac{k_{\\mathrm{on}}(T) a_{\\mathrm{eq}}}{k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)}\n$$\nWe compute the exact value at the final time, $a_{\\mathrm{exact}}(t_f)$, to serve as the reference for the accuracy check: $|\\,a_{\\mathrm{num}}(t_f) - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$.\n\n### Step 3: Minimal Step Count for RK4 ($N_{\\mathrm{RK4}}$)\nThe determination of $N_{\\mathrm{RK4}}$ requires satisfying both a stability and an accuracy constraint. The final number of steps must be the maximum of the number required by each constraint.\n\n**Stability Constraint:**\nThe absolute stability of the RK4 method is governed by its amplification factor $R(z) = \\sum_{k=0}^{4} z^k/k!$ for the test equation $y' = \\lambda y$, where $z = h\\lambda$. For a real negative $\\lambda$, the stability condition $|R(h\\lambda)| \\le 1$ holds for $h\\lambda \\in [-2.78528..., 0]$. This imposes an upper limit on the step size $h = t_f/N$:\n$$\nh \\le \\frac{-2.785281594}{\\lambda}\n$$\nThis translates to a minimum number of steps, $N_{\\mathrm{stab}}$, required for stability:\n$$\nN_{\\mathrm{stab}} = \\left\\lceil \\frac{t_f}{h_{\\mathrm{max}}} \\right\\rceil = \\left\\lceil \\frac{-t_f \\lambda}{2.785281594} \\right\\rceil\n$$\n\n**Accuracy Constraint:**\nTo find the minimum number of steps for accuracy, $N_{\\mathrm{acc}}$, we perform a numerical search. Since we cannot use closed-form error estimates, we must directly simulate the system. We implement a search algorithm that first finds an upper bound for $N$ by doubling it until the accuracy tolerance $\\varepsilon$ is met, and then performs a binary search within the identified range to find the minimal integer $N$ satisfying the condition. For each candidate $N$, a full RK4 simulation is run:\n- Set $h=t_f/N$ and $a_0$.\n- Iterate $N$ times:\n  $$\n  k_1 = f(a_n) \\\\\n  k_2 = f(a_n + \\frac{h}{2}k_1) \\\\\n  k_3 = f(a_n + \\frac{h}{2}k_2) \\\\\n  k_4 = f(a_n + hk_3) \\\\\n  a_{n+1} = a_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n  $$\n- Check if $|\\,a_N - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$.\n\nThe final minimal step count for RK4 is $N_{\\mathrm{RK4}} = \\max(N_{\\mathrm{stab}}, N_{\\mathrm{acc}})$.\n\n### Step 4: Minimal Step Count for BDF2 ($N_{\\mathrm{BDF2}}$)\n\n**Stability Constraint:**\nThe BDF2 method is A-stable, meaning its region of absolute stability contains the entire left half of the complex plane, $\\operatorname{Re}(z) \\le 0$. Since our $\\lambda$ is always real and negative, the method is unconditionally stable for any step size $h0$. Therefore, stability imposes no restriction on $N$, and $N_{\\mathrm{BDF2}}$ is determined solely by the accuracy requirement.\n\n**Accuracy Constraint:**\nThe BDF2 method is a two-step method, requiring a startup procedure. As specified, we use a single step of the second-order implicit trapezoidal rule to compute $a_1$ from $a_0$.\n- **Startup (Trapezoidal rule):** For the linear ODE, we can solve for $a_1$ explicitly:\n$$\na_1 = a_0 + \\frac{h}{2}\\left( (c+\\lambda a_0) + (c+\\lambda a_1) \\right) \\implies a_1 = \\frac{a_0(1+\\frac{h\\lambda}{2}) + hc}{1-\\frac{h\\lambda}{2}}\n$$\n- **Main loop (BDF2):** For $n \\ge 1$, we compute $a_{n+1}$ using $a_n$ and $a_{n-1}$. For our linear ODE, we can again solve for $a_{n+1}$ explicitly:\n$$\na_{n+1} = \\frac{4}{3}a_n - \\frac{1}{3}a_{n-1} + \\frac{2h}{3}(c+\\lambda a_{n+1}) \\implies a_{n+1} = \\frac{\\frac{4}{3}a_n - \\frac{1}{3}a_{n-1} + \\frac{2hc}{3}}{1-\\frac{2h\\lambda}{3}}\n$$\nThe same search algorithm (exponential increase followed by binary search) is used to find the minimal $N_{\\mathrm{BDF2}}$ that satisfies $|\\,a_N - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$.\n\nBy implementing these steps for each test case, we can determine the required integer pairs $(N_{\\mathrm{RK4}}, N_{\\mathrm{BDF2}})$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function to find the minimal number of steps for RK4 and BDF2\n    methods to satisfy stability and accuracy constraints for a given ODE modelling\n    dopant activation in semiconductors.\n    \"\"\"\n    # Boltzmann constant in eV/K\n    KB = 8.617333262145e-5\n    # Stability limit for RK4 on the negative real axis for z = h*lambda\n    RK4_STABILITY_LIMIT = 2.785281594\n\n    def find_min_N(is_accurate_func):\n        \"\"\"\n        Finds the minimum integer N that satisfies the accuracy condition.\n        Uses an exponential increase to find an upper bound, then performs a\n        binary search to find the minimal N.\n        \"\"\"\n        if is_accurate_func(1):\n            return 1\n        \n        # Exponential search for an upper bound\n        n_upper = 2\n        while not is_accurate_func(n_upper):\n            # Safety break to prevent very long searches\n            if n_upper > 2**28: \n                raise RuntimeError(\n                    \"Search for N failed to converge within a reasonable limit.\"\n                )\n            n_upper *= 2\n        \n        # Binary search for the precise minimum N\n        low = n_upper // 2\n        high = n_upper\n        ans = high\n        \n        while low = high:\n            mid = low + (high - low) // 2\n            if mid == 0:\n                low = 1\n                continue\n            \n            if is_accurate_func(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n\n    test_cases = [\n        # Case 1: T=1000K, tf=1.0s, eps=1e-6\n        (1000.0, 1.0, 0.1, 0.9, 1.0e13, 2.1, 5.0e12, 2.4, 1.0e-6),\n        # Case 2: T=1150K, tf=0.1s, eps=1e-8\n        (1150.0, 0.1, 0.05, 0.95, 1.0e13, 2.0, 8.0e12, 2.2, 1.0e-8),\n        # Case 3: T=850K, tf=10.0s, eps=1e-6\n        (850.0, 10.0, 0.2, 0.85, 1.0e13, 2.4, 5.0e12, 2.8, 1.0e-6),\n    ]\n\n    all_results = []\n\n    for T, tf, a0, a_eq, nu_on, E_on, nu_off, E_off, eps in test_cases:\n        # Step 1: Calculate model parameters\n        k_on = nu_on * np.exp(-E_on / (KB * T))\n        k_off = nu_off * np.exp(-E_off / (KB * T))\n        \n        lam = -(k_on + k_off)\n        c = k_on * a_eq\n        \n        # The ODE right-hand side: da/dt = c + lam * a\n        def f_ode(a):\n            return c + lam * a\n\n        # Step 2: Calculate exact solution\n        if lam == 0:\n            a_exact_tf = a0 + c * tf\n        else:\n            a_inf = -c / lam\n            a_exact_tf = a_inf + (a0 - a_inf) * np.exp(lam * tf)\n\n        # --- Step 3: Find N_RK4 ---\n        \n        # Stability constraint\n        N_stab = math.ceil(-tf * lam / RK4_STABILITY_LIMIT)\n\n        # Accuracy constraint\n        def run_rk4(N):\n            h = tf / N\n            a_num = a0\n            for _ in range(N):\n                k1 = f_ode(a_num)\n                k2 = f_ode(a_num + 0.5 * h * k1)\n                k3 = f_ode(a_num + 0.5 * h * k2)\n                k4 = f_ode(a_num + h * k3)\n                a_num += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            return a_num\n\n        def is_accurate_rk4(N):\n            if N == 0: return False\n            a_num_tf = run_rk4(N)\n            return np.abs(a_num_tf - a_exact_tf) = eps\n        \n        N_acc_rk4 = find_min_N(is_accurate_rk4)\n        N_rk4 = max(N_stab, N_acc_rk4)\n        all_results.append(N_rk4)\n\n        # --- Step 4: Find N_BDF2 ---\n        \n        # Stability is unconditional (A-stable method)\n        # Accuracy constraint\n        def run_bdf2(N):\n            h = tf / N\n            \n            # First step: Implicit Trapezoidal startup\n            # a1 * (1 - h*lam/2) = a0*(1+h*lam/2) + h*c\n            a_n_minus_1 = a0\n            if N == 1:\n                return (a_n_minus_1 * (1.0 + 0.5 * h * lam) + h * c) / (1.0 - 0.5 * h * lam)\n            \n            a_n = (a_n_minus_1 * (1.0 + 0.5 * h * lam) + h * c) / (1.0 - 0.5 * h * lam)\n\n            # BDF2 steps for n > 1\n            # a_{n+1} * (1 - 2/3 h lam) = 4/3 a_n - 1/3 a_{n-1} + 2/3 h c\n            den = 1.0 - (2.0/3.0) * h * lam\n            for _ in range(1, N): # Loop N-1 times to get to the Nth step\n                num = (4.0/3.0) * a_n - (1.0/3.0) * a_n_minus_1 + (2.0/3.0) * h * c\n                a_n_plus_1 = num / den\n                \n                a_n_minus_1 = a_n\n                a_n = a_n_plus_1\n            return a_n\n\n        def is_accurate_bdf2(N):\n            if N == 0: return False\n            a_num_tf = run_bdf2(N)\n            return np.abs(a_num_tf - a_exact_tf) = eps\n            \n        N_bdf2 = find_min_N(is_accurate_bdf2)\n        all_results.append(N_bdf2)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Simulating carrier transport across steep p-n junctions is a classic challenge where naive discretizations often fail, producing non-physical negative concentrations. The Scharfetter-Gummel scheme provides an elegant solution by incorporating the physics of drift and diffusion directly into the discrete flux expression, guaranteeing stability and positivity. In this exercise, you will implement this industry-standard method and verify its ability to produce physically meaningful results that satisfy the discrete maximum principle, a cornerstone of robust device simulation. ",
            "id": "4145374",
            "problem": "Consider a one-dimensional, steady-state carrier transport across a steep semiconductor $p$-$n$ junction. Use the Drift-Diffusion (DD) model with the Einstein relation and assume dimensionless variables, where the electrostatic potential $\\,\\psi(x)\\,$ is already given in units of thermal voltage, and carrier densities are normalized by the intrinsic carrier density. The domain is $[0,1]$ with a nonuniform mesh refined around the junction at $x = 0.5$. You must discretize the continuity equation using the Scharfetter–Gummel (SG) flux on a nonuniform mesh and verify numerical stability, convergence, and accuracy manifested as positivity and absence of nonphysical undershoots or overshoots.\n\nFundamental base and modeling assumptions:\n- The steady-state continuity equation for electrons and holes is $\\,\\partial_x J_n = 0\\,$ and $\\,\\partial_x J_p = 0\\,$, respectively.\n- The Drift-Diffusion (DD) fluxes are $\\,J_n = -D_n \\left(\\partial_x n - n \\,\\partial_x \\psi\\right)\\,$ and $\\,J_p = -D_p \\left(\\partial_x p + p \\,\\partial_x \\psi\\right)\\,$.\n- The Einstein relation implies $\\,D_n = \\mu_n V_T\\,$ and $\\,D_p = \\mu_p V_T\\,$; in the chosen dimensionless units set $\\,D_n = D_p = 1\\,$.\n- The Scharfetter–Gummel (SG) numerical flux on an edge $[x_i,x_{i+1}]$ of length $\\,h_{i+\\frac{1}{2}} = x_{i+1}-x_i\\,$ with potential drop $\\,\\Delta\\psi_{i+\\frac{1}{2}} = \\psi_{i+1} - \\psi_i\\,$ uses the Bernoulli function $\\,B(\\xi) = \\xi/(e^\\xi - 1)\\,$ with the convention $\\,B(0)=1\\,$.\n- The discrete SG fluxes are\n$$\nJ_{n,i+\\frac{1}{2}} = -\\frac{1}{h_{i+\\frac{1}{2}}}\\left[n_{i+1} B(\\Delta\\psi_{i+\\frac{1}{2}}) - n_i B(-\\Delta\\psi_{i+\\frac{1}{2}})\\right],\n\\quad\nJ_{p,i+\\frac{1}{2}} = -\\frac{1}{h_{i+\\frac{1}{2}}}\\left[p_{i+1} B(-\\Delta\\psi_{i+\\frac{1}{2}}) - p_i B(\\Delta\\psi_{i+\\frac{1}{2}})\\right].\n$$\n- Steady-state implies $\\,J_{n,i+\\frac{1}{2}} = J_{n,i-\\frac{1}{2}}\\,$ and $\\,J_{p,i+\\frac{1}{2}} = J_{p,i-\\frac{1}{2}}\\,$, which yields a linear system for $\\,\\{n_i\\}\\,$ and $\\,\\{p_i\\}\\,$ when Dirichlet boundary conditions are imposed at the contacts.\n\nYou are given a dimensionless electrostatic potential profile intended to mimic a steep $p$-$n$ junction:\n$$\n\\psi(x) = \\frac{\\Delta\\psi}{2}\\,\\tanh\\left(\\frac{x - x_j}{w}\\right),\n$$\nwhere $\\,\\Delta\\psi\\,$ controls the total potential drop, $\\,x_j = 0.5\\,$ is the junction center, and $\\,w\\,$ controls the transition width.\n\nBoundary conditions (Dirichlet) for carriers at $\\,x=0\\,$ and $\\,x=1\\,$ are specified as $\\,n(0)=n_L\\,$, $\\,n(1)=n_R\\,$, $\\,p(0)=p_L\\,$, $\\,p(1)=p_R\\,$, chosen to be physically consistent (e.g., $\\,n_L p_L = 1\\,$ and $\\,n_R p_R = 1\\,$ in normalized units).\n\nYour tasks:\n1. Construct nonuniform meshes refined around $\\,x=0.5\\,$. Use a smooth, symmetric mapping from a uniform computational coordinate $\\,\\xi \\in [0,1]\\,$ to the physical coordinate $\\,x\\,$ defined by\n$$\nx(\\xi) = \\frac{1}{2} + \\frac{1}{2}\\,\\frac{\\sinh\\!\\big(\\beta(\\xi-\\frac{1}{2})\\big)}{\\sinh\\!\\big(\\frac{\\beta}{2}\\big)},\n$$\nwhere $\\,\\beta \\ge 0\\,$ controls clustering near $\\,x=0.5\\,$. For $\\,\\beta=0\\,$, default to a uniform grid.\n\n2. Implement the Scharfetter–Gummel discretization on the constructed nonuniform meshes for both electrons and holes. Assemble and solve the resulting tridiagonal linear systems with the given Dirichlet boundary conditions to obtain $\\,\\{n_i\\}\\,$ and $\\,\\{p_i\\}\\,$ on the mesh nodes.\n\n3. Verify positivity and absence of nonphysical undershoots or overshoots using a discrete maximum principle: for each carrier, check that all nodal values are strictly positive and lie within the closed interval determined by the boundary values. That is, for carrier $\\,c \\in \\{n,p\\}\\,$ with boundary values $\\,c_L\\,$ and $\\,c_R\\,$, verify\n$$\n\\min_i c_i \\ge \\min(c_L, c_R), \\quad \\max_i c_i \\le \\max(c_L, c_R), \\quad \\text{and} \\quad \\min_i c_i  0.\n$$\n\n4. Verify convergence for electrons under mesh refinement at moderate $\\,\\Delta\\psi\\,$ by computing the $\\,\\ell_\\infty\\,$ error of coarser-grid solutions relative to a very fine-grid reference, using linear interpolation to compare solutions on different grids. Confirm that the error decreases as the mesh is refined.\n\nNumerical stability requirements:\n- Evaluate the Bernoulli function $\\,B(\\xi)\\,$ in a numerically stable manner for small $\\,|\\xi|\\,$ using a suitable series expansion and for large $\\,|\\xi|\\,$ using stable exponentiation (e.g., $\\,\\mathrm{expm1}\\,$ to avoid catastrophic cancellation).\n\nTest suite:\nProvide and solve the following four test cases, aggregating the results into a single output line as specified below.\n\n- Case A (happy path, steep but manageable): $\\,\\Delta\\psi = 40\\,$, $\\,w = 0.02\\,$, $\\,\\beta = 6\\,$, $\\,N = 201\\,$ nodes. Boundary values: $\\,n_L = 10^4\\,$, $\\,n_R = 10^{-4}\\,$, $\\,p_L = 10^{-4}\\,$, $\\,p_R = 10^4\\,$. Output a single boolean that is true if both electrons and holes satisfy positivity and the discrete maximum-principle bounds.\n\n- Case B (edge case, extremely steep): $\\,\\Delta\\psi = 80\\,$, $\\,w = 0.01\\,$, $\\,\\beta = 6\\,$, $\\,N = 101\\,$ nodes. Boundary values: $\\,n_L = 10^6\\,$, $\\,n_R = 10^{-6}\\,$, $\\,p_L = 10^{-6}\\,$, $\\,p_R = 10^6\\,$. Output a single boolean that is true if both electrons and holes satisfy positivity and the discrete maximum-principle bounds.\n\n- Case C (boundary condition check, flat field): $\\,\\Delta\\psi = 0\\,$, $\\,w = 0.05\\,$, $\\,\\beta = 0\\,$, $\\,N = 51\\,$ nodes. Boundary values: $\\,n_L = 10^3\\,$, $\\,n_R = 10^{-2}\\,$, $\\,p_L = 10^{-2}\\,$, $\\,p_R = 10^3\\,$. Output a single boolean that is true if both electrons and holes satisfy positivity and the discrete maximum-principle bounds.\n\n- Case D (convergence under refinement, moderate field): $\\,\\Delta\\psi = 20\\,$, $\\,w = 0.05\\,$, $\\,\\beta = 4\\,$. Consider three meshes with $\\,N_1=51\\,$, $\\,N_2=101\\,$, and $\\,N_3=401\\,$ nodes. Boundary values: $\\,n_L = 10^3\\,$, $\\,n_R = 10^{-1}\\,$. Compute electron solutions on all three grids and use the finest grid $\\,N_3\\,$ as reference. Interpolate the coarse and medium solutions to the fine grid and compute the $\\,\\ell_\\infty\\,$ errors $\\,E_{1\\to 3}\\,$ and $\\,E_{2\\to 3}\\,$. Output a single boolean that is true if $\\,E_{1\\to 3}  E_{2\\to 3}\\,$, indicating monotone error reduction upon refinement.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[A,B,C,D]$, where each element is the boolean result of the corresponding case as specified above. For example: \"[True,True,True,True]\". No additional text should be printed.",
            "solution": "The user has provided a scientifically sound and well-posed problem from the field of computational semiconductor device modeling. The problem asks for the implementation and verification of the Scharfetter-Gummel (SG) discretization scheme for the steady-state Drift-Diffusion equations on a one-dimensional, nonuniform grid.\n\nThe validation steps confirm that all necessary components are provided, including the governing equations, boundary conditions, discretization formulas, a mesh generation function, a potential profile, and specific test cases to verify numerical stability and convergence. The problem is grounded in established physical and numerical principles, and the tasks are objective and verifiable. Therefore, I will proceed with a full solution.\n\nThe solution methodology involves the following steps:\n1.  **Bernoulli Function**: A numerically stable implementation of the Bernoulli function, $B(\\xi) = \\xi / (e^\\xi - 1)$, is crucial. For small $|\\xi|$, a Taylor series expansion is used to prevent catastrophic cancellation. For larger values, standard floating-point arithmetic, aided by `numpy.expm1` for precision, is sufficient. The identity $B(-\\xi) = B(\\xi) + \\xi$ is also fundamental to the SG scheme.\n2.  **Mesh Generation**: A function is created to generate the nonuniform physical grid $x$ from a uniform computational grid $\\xi$ using the specified mapping $x(\\xi) = \\frac{1}{2} + \\frac{1}{2} \\sinh(\\beta(\\xi-1/2)) / \\sinh(\\beta/2)$. The special case of $\\beta=0$ resulting in a uniform grid is handled.\n3.  **System Assembly**: The core of the solution is to discretize the continuity equation $\\partial_x J_c = 0$ for each carrier type $c \\in \\{n, p\\}$. Applying the SG flux conservation condition, $J_{c, i-1/2} = J_{c, i+1/2}$, at each interior grid node $x_i$ (for $i=1, \\dots, N-2$) yields a linear equation relating the carrier concentrations $c_{i-1}$, $c_i$, and $c_{i+1}$. This results in a tridiagonal system of linear equations for the unknown concentrations at the interior nodes.\n    For electrons ($n$), the equation at node $i$ is:\n    $$ \\frac{B(-\\Delta\\psi_{i-1/2})}{h_{i-1/2}} n_{i-1} - \\left(\\frac{B(\\Delta\\psi_{i-1/2})}{h_{i-1/2}} + \\frac{B(-\\Delta\\psi_{i+1/2})}{h_{i+1/2}}\\right) n_i + \\frac{B(\\Delta\\psi_{i+1/2})}{h_{i+1/2}} n_{i+1} = 0 $$\n    For holes ($p$), the equation is similar, with $B(\\Delta\\psi)$ and $B(-\\Delta\\psi)$ interchanged.\n4.  **System Solution**: The resulting $(N-2) \\times (N-2)$ tridiagonal system is of the form $A\\mathbf{c} = \\mathbf{b}$, where the vector $\\mathbf{b}$ incorporates the Dirichlet boundary conditions. This system is solved efficiently using `scipy.linalg.solve_banded`, which is well-suited for such matrices.\n5.  **Verification**:\n    - **Maximum Principle**: For cases A, B, and C, the numerical solution for both electrons and holes, $\\{c_i\\}$, is checked against the discrete maximum principle. A key property of the SG scheme for source-free problems is that the solution should be bounded by its boundary values. We verify that $\\min(c_L, c_R) \\le c_i \\le \\max(c_L, c_R)$ for all $i$, and that all concentrations are positive, $c_i  0$.\n    - **Convergence**: For case D, the electron concentration is computed on three progressively refined meshes. The solutions from the coarser grids are interpolated onto the finest grid. The $\\ell_\\infty$ norm of the error, $\\|\\mathbf{n}_{\\text{coarse}} - \\mathbf{n}_{\\text{ref}}\\|_\\infty$, is calculated relative to the fine-grid reference solution. Convergence is verified by checking that the error decreases as the mesh resolution increases.\n\nThe implementation will be structured into a main `solve()` function that orchestrates the execution of these steps for each of the four specified test cases and formats the final boolean results as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef bernoulli(x):\n    \"\"\"\n    Numerically stable implementation of the Bernoulli function B(x) = x / (exp(x) - 1).\n    \"\"\"\n    x = np.asarray(x)\n    res = np.zeros_like(x, dtype=float)\n    \n    # Use Taylor series for small |x| to avoid catastrophic cancellation.\n    # B(x) approx 1 - x/2 + x^2/12 - x^4/720\n    small_mask = np.abs(x)  1e-4\n    x_small = x[small_mask]\n    res[small_mask] = 1.0 - x_small/2.0 + x_small**2/12.0 - x_small**4/720.0\n    \n    # Use standard formula for non-small x, with np.expm1 for precision.\n    large_mask = ~small_mask\n    x_large = x[large_mask]\n    res[large_mask] = x_large / np.expm1(x_large)\n    \n    return res\n\ndef generate_mesh(N, beta):\n    \"\"\"\n    Generates a 1D physical mesh x on [0, 1] with N points.\n    beta controls the clustering of points around x=0.5.\n    beta=0 gives a uniform mesh.\n    \"\"\"\n    xi = np.linspace(0.0, 1.0, N)\n    if beta == 0:\n        return xi\n    else:\n        # Prevent potential overflow with very large beta, though sinh ratio is stable.\n        numerator = np.sinh(beta * (xi - 0.5))\n        denominator = np.sinh(beta / 2.0)\n        x = 0.5 + 0.5 * numerator / denominator\n        return x\n\ndef get_potential_profile(x, d_psi, w):\n    \"\"\"\n    Calculates the electrostatic potential profile psi(x).\n    \"\"\"\n    x_j = 0.5\n    return (d_psi / 2.0) * np.tanh((x - x_j) / w)\n\ndef solve_carrier(carrier_type, x, psi, c_L, c_R):\n    \"\"\"\n    Solves the 1D steady-state drift-diffusion equation using\n    Scharfetter-Gummel discretization for a given carrier type ('n' or 'p').\n    \"\"\"\n    N = len(x)\n    M = N - 2  # Number of interior points (unknowns)\n\n    if M = 0:\n        return np.array([c_L, c_R])\n\n    h = np.diff(x)      # h_{i+1/2}\n    d_psi = np.diff(psi) # psi_{i+1} - psi_i\n\n    # Pre-compute flux coefficients\n    g_p = bernoulli(d_psi) / h\n    g_m = bernoulli(-d_psi) / h\n\n    # Assemble the banded matrix A for the system A*c = b\n    # ab is a (3, M) array for scipy.linalg.solve_banded\n    ab = np.zeros((3, M))\n    rhs = np.zeros(M)\n    \n    if carrier_type == 'n':\n        # For electrons\n        ab[0, 1:] = g_p[1:M]                # Upper diagonal\n        ab[1, :] = -(g_p[:M] + g_m[1:M+1])  # Main diagonal\n        ab[2, :-1] = g_m[1:M]               # Lower diagonal\n        rhs[0] = -g_m[0] * c_L\n        rhs[-1] = -g_p[M] * c_R\n    elif carrier_type == 'p':\n        # For holes\n        ab[0, 1:] = g_m[1:M]                # Upper diagonal\n        ab[1, :] = -(g_m[:M] + g_p[1:M+1])  # Main diagonal\n        ab[2, :-1] = g_p[1:M]               # Lower diagonal\n        rhs[0] = -g_p[0] * c_L\n        rhs[-1] = -g_m[M] * c_R\n    else:\n        raise ValueError(\"carrier_type must be 'n' or 'p'\")\n\n    # Solve the tridiagonal system for interior nodes\n    c_internal = solve_banded((1, 1), ab, rhs)\n\n    # Combine with boundary values to form the full solution\n    c_sol = np.concatenate(([c_L], c_internal, [c_R]))\n    \n    return c_sol\n\ndef check_max_principle(c_sol, c_L, c_R):\n    \"\"\"\n    Verifies positivity and the discrete maximum principle bounds.\n    \"\"\"\n    c_min_bound = min(c_L, c_R)\n    c_max_bound = max(c_L, c_R)\n    \n    # All values must be strictly positive\n    positivity_ok = np.all(c_sol > 0)\n    \n    # All values must lie within the bounds set by the BCs\n    min_val = np.min(c_sol)\n    max_val = np.max(c_sol)\n    \n    # Use a small tolerance for floating point comparisons\n    tol = 1e-9\n    bounds_ok = (min_val >= c_min_bound - tol) and (max_val = c_max_bound + tol)\n    \n    return positivity_ok and bounds_ok\n\ndef run_case_A():\n    params = {'d_psi': 40.0, 'w': 0.02, 'beta': 6.0, 'N': 201}\n    bcs = {'n_L': 1e4, 'n_R': 1e-4, 'p_L': 1e-4, 'p_R': 1e4}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n\ndef run_case_B():\n    params = {'d_psi': 80.0, 'w': 0.01, 'beta': 6.0, 'N': 101}\n    bcs = {'n_L': 1e6, 'n_R': 1e-6, 'p_L': 1e-6, 'p_R': 1e6}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n\ndef run_case_C():\n    params = {'d_psi': 0.0, 'w': 0.05, 'beta': 0.0, 'N': 51}\n    bcs = {'n_L': 1e3, 'n_R': 1e-2, 'p_L': 1e-2, 'p_R': 1e3}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n    \ndef run_case_D():\n    params = {'d_psi': 20.0, 'w': 0.05, 'beta': 4.0}\n    bcs = {'n_L': 1e3, 'n_R': 1e-1}\n    Ns = [51, 101, 401]\n    \n    # Solve on three grids\n    solutions = []\n    for N in Ns:\n        x = generate_mesh(N, params['beta'])\n        psi = get_potential_profile(x, params['d_psi'], params['w'])\n        n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n        solutions.append((x, n_sol))\n    \n    (x1, n1), (x2, n2), (x3, n3) = solutions\n    \n    # Interpolate coarse solutions onto the fine grid\n    n1_interp = np.interp(x3, x1, n1)\n    n2_interp = np.interp(x3, x2, n2)\n    \n    # Compute L-infinity errors\n    E_1_to_3 = np.max(np.abs(n1_interp - n3))\n    E_2_to_3 = np.max(np.abs(n2_interp - n3))\n    \n    # Check for error reduction\n    return E_1_to_3 > E_2_to_3\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    results = [\n        run_case_A(),\n        run_case_B(),\n        run_case_C(),\n        run_case_D()\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The use of implicit discretizations or the search for steady-state solutions inevitably leads to large systems of nonlinear algebraic equations. While Newton's method is powerful, its convergence is only guaranteed for good initial guesses, a luxury we rarely have. This exercise guides you through implementing a globally convergent damped Newton method, complete with a backtracking line search and feasibility-preserving steps, to solve a physically-motivated dopant clustering model, demonstrating how to make solvers robust enough for real-world simulation tasks. ",
            "id": "4145409",
            "problem": "Consider a simplified but physically grounded model for post-implant activation in a semiconductor, where donors can be either electrically active or trapped in neutral clusters. At fixed temperature, assume that clustering is governed by the law of mass action for the reaction $m \\, \\mathrm{A} \\rightleftharpoons \\mathrm{C}$, where $\\mathrm{A}$ denotes an active donor and $\\mathrm{C}$ denotes a neutral cluster composed of $m$ donors. Let the equilibrium constant be $K \\gt 0$, the stoichiometric coefficient be an integer $m \\ge 2$, and the total donor concentration at a spatial node be $D \\gt 0$. The unknown active concentration $a$ at that node must satisfy conservation and equilibrium:\n- Conservation: $D = a + m c$, where $c$ is the cluster concentration.\n- Mass action: $c = K a^m$.\n\nCombine these to obtain the residual equation $F(a) = 0$ for the unknown $a$ at a node, and generalize to a vector of nodes by applying the same relation componentwise. All quantities may be treated as dimensionless for this problem. The physically admissible domain is the box constraint $0 \\le a_i \\le D_i$ for each node $i$.\n\nYour task is to implement a globally convergent damped Newton method to solve $F(a) = 0$ for $a$, starting from rough initial guesses. The method must incorporate:\n1. A feasibility-preserving damping that enforces the box constraints $0 \\le a_i \\le D_i$ at every iteration using a maximum admissible step length computed from the current iterate and the proposed Newton step.\n2. A backtracking line search with a sufficient decrease condition based on the squared residual norm merit function $\\phi(a) = \\tfrac{1}{2} \\lVert F(a) \\rVert_2^2$ (an Armijo-type condition), with a strictly positive parameter $c_1$ and a contraction factor $\\tau$ in the interval $(0,1)$.\n\nYou must derive the Newton step from first principles (i.e., by differentiating $F$ with respect to $a$), implement the line search and damping strategy, and apply the method to the following test suite. Each test case specifies the donor profile $D$ (either a scalar or a list for multiple nodes), the stoichiometric coefficient $m$, the equilibrium constant $K$, and an initial guess $a^{(0)}$:\n- Test 1 (happy path, single node): $D = 1.0$, $m = 2$, $K = 0.5$, initial guess $a^{(0)} = 0.0$.\n- Test 2 (rough start near an active upper bound, single node): $D = 10.0$, $m = 3$, $K = 0.02$, initial guess $a^{(0)} = D$.\n- Test 3 (multi-node profile, mixed scales): $D = [0.1, 1.0, 5.0, 10.0, 20.0]$, $m = 3$, $K = 0.05$, initial guess $a^{(0)} = [0, 0, 0, 0, 0]$.\n- Test 4 (stiff clustering, single node, rough start at upper bound): $D = 1.0$, $m = 4$, $K = 1.0$, initial guess $a^{(0)} = D$.\n\nImplement a termination criterion that declares convergence when the infinity norm of the residual satisfies $\\lVert F(a) \\rVert_{\\infty} \\le \\varepsilon$ for a small tolerance $\\varepsilon \\gt 0$, or a maximum number of iterations is reached. Use a fixed $\\varepsilon$ across all tests. If the method fails to converge within the maximum number of iterations, it must still return a best-effort result.\n\nRequired outputs for each test case:\n- If $D$ is a scalar, output the final activation fraction $a/D$ as a float.\n- If $D$ is a list, output the average activation fraction $\\left(\\frac{1}{N} \\sum_{i=1}^N \\frac{a_i}{D_i}\\right)$ as a float, where $N$ is the number of nodes.\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"). Each float must be rounded to ten decimal places in the output. No other text should be printed.\n\nDesign notes and constraints that must be followed:\n- Start from the foundational definitions above (conservation and mass action). Do not use pre-derived specialized formulas for activation fraction; derive the Newton step directly from differentiating your $F(a)$.\n- The line search must be based on the merit function $\\phi(a) = \\tfrac{1}{2} \\lVert F(a) \\rVert_2^2$ and must use a sufficient decrease test with a user-specified $c_1 \\in (0,1)$ and backtracking factor $\\tau \\in (0,1)$, together with feasibility-preserving damping that respects $0 \\le a_i \\le D_i$ for all $i$.\n- Use the same algorithm for both scalar and vector cases without branching on dimension other than shape handling.\n- Choose reasonable numerical parameters for tolerance, $c_1$, $\\tau$, and maximum iterations that would ensure global convergence from the given rough initial guesses.\n- All answers are dimensionless in this problem. Angles are not used, and no unit conversion is necessary.",
            "solution": "The user's request is to validate and solve a problem concerning a simplified model of post-implant activation in a semiconductor. The solution requires the implementation of a globally convergent damped Newton method.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following information:\n- **Reaction:** $m \\, \\mathrm{A} \\rightleftharpoons \\mathrm{C}$, where $\\mathrm{A}$ is an active donor, $\\mathrm{C}$ is a neutral cluster, and $m$ is an integer stoichiometric coefficient with $m \\ge 2$.\n- **Concentrations:** $a$ is the active donor concentration, $c$ is the cluster concentration, and $D$ is the total donor concentration at a spatial node, with $D  0$.\n- **Equilibrium Constant:** $K  0$.\n- **Governing Equations:**\n  - Conservation of mass: $D = a + m c$.\n  - Law of mass action: $c = K a^m$.\n- **Residual Equation:** $F(a) = 0$, derived from the governing equations.\n- **Physical Constraints:** For each node $i$, the active concentration must satisfy the box constraint $0 \\le a_i \\le D_i$.\n- **Numerical Method:** A globally convergent damped Newton method.\n  - **Damping:** A feasibility-preserving damping strategy to enforce the box constraints.\n  - **Line Search:** A backtracking line search based on the merit function $\\phi(a) = \\tfrac{1}{2} \\lVert F(a) \\rVert_2^2$, using an Armijo-type sufficient decrease condition with parameters $c_1 \\in (0,1)$ and $\\tau \\in (0,1)$.\n- **Termination Criterion:** $\\lVert F(a) \\rVert_{\\infty} \\le \\varepsilon$ for a tolerance $\\varepsilon  0$, or a maximum number of iterations.\n- **Test Cases:**\n  1. $D = 1.0$, $m = 2$, $K = 0.5$, $a^{(0)} = 0.0$.\n  2. $D = 10.0$, $m = 3$, $K = 0.02$, $a^{(0)} = D$.\n  3. $D = [0.1, 1.0, 5.0, 10.0, 20.0]$, $m = 3$, $K = 0.05$, $a^{(0)} = [0, 0, 0, 0, 0]$.\n  4. $D = 1.0$, $m = 4$, $K = 1.0$, $a^{(0)} = D$.\n- **Output Format:** For each test case, the activation fraction $a/D$ (for scalar $D$) or the average activation fraction $\\left(\\frac{1}{N} \\sum_{i=1}^N \\frac{a_i}{D_i}\\right)$ (for vector $D$), rounded to ten decimal places.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded:** The model is based on the law of mass action, a fundamental principle of chemical kinetics and thermodynamics used extensively in physics and materials science, including the modeling of defect reactions and dopant activation in semiconductors. The model is a standard, simplified representation of such phenomena. The problem is scientifically sound.\n- **Well-Posed:** To determine if the problem is well-posed, we must establish the existence and uniqueness of a solution.\n  1.  Substituting the mass action law $c = K a^m$ into the conservation equation $D = a + m c$ yields a single equation for the unknown $a$: $D = a + m K a^m$.\n  2.  We define the residual function $F(a) = a + m K a^m - D$. The problem is to find the root of $F(a) = 0$.\n  3.  We analyze $F(a)$ on the physically admissible domain $a \\in [0, D]$.\n      - At the lower bound, $F(0) = 0 + m K (0)^m - D = -D$. Since $D  0$, $F(0)  0$.\n      - At the upper bound, $F(D) = D + m K D^m - D = m K D^m$. Since $m \\ge 2$, $K  0$, and $D  0$, we have $F(D)  0$.\n      - The function $F(a)$ is a sum of polynomials and is therefore continuous. By the Intermediate Value Theorem, since $F(0)  0$ and $F(D)  0$, there exists at least one root $a^* \\in (0, D)$.\n      - To check for uniqueness, we examine the derivative: $F'(a) = \\frac{d}{da}(a + m K a^m - D) = 1 + m^2 K a^{m-1}$.\n      - Given $m \\ge 2$, $K  0$, and $a \\ge 0$, the derivative $F'(a)$ is always greater than or equal to $1$. This means $F(a)$ is strictly monotonically increasing on its domain.\n      - A strictly monotonic function can cross zero at most once. Therefore, there exists a unique solution $a^*$ in the interval $(0, D)$.\n  The problem is well-posed.\n- **Objective:** The problem is formulated with precise mathematical equations, constraints, and numerical parameters. The task is specific and the required output format is unambiguous. The problem is objective.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is scientifically grounded, well-posed, objective, and self-contained. It is deemed **valid**. A solution will be provided.\n\n### Principle-Based Solution Design\n\nThe core of the problem is to solve the system of nonlinear equations $F(a) = 0$ for the vector of active concentrations $a$, where $F(a)$ is applied component-wise.\n$$ F_i(a_i) = a_i + m K a_i^m - D_i = 0 \\quad \\text{for each node } i $$\nWe will implement a damped Newton method, which is an iterative procedure. Starting from an initial guess $a^{(0)}$, each subsequent iterate is found by $a^{(k+1)} = a^{(k)} + \\alpha^{(k)} p^{(k)}$, where $p^{(k)}$ is the Newton step and $\\alpha^{(k)} \\in (0, 1]$ is a step length determined by a line search.\n\n**1. Newton Step Derivation**\nThe Newton step $p^{(k)}$ at iterate $a^{(k)}$ is the solution to the linear system $J(a^{(k)}) p^{(k)} = -F(a^{(k)})$, where $J(a)$ is the Jacobian matrix of $F(a)$.\n\nSince the relationship $F_i(a_i)$ only depends on the $i$-th component $a_i$, the system is decoupled. The Jacobian matrix is therefore diagonal:\n$$ J(a) = \\mathrm{diag}\\left(\\frac{dF_1}{da_1}, \\frac{dF_2}{da_2}, \\dots, \\frac{dF_N}{da_N}\\right) $$\nThe derivative of the $i$-th component of the residual function is:\n$$ \\frac{dF_i}{da_i} = \\frac{d}{da_i}(a_i + m K a_i^m - D_i) = 1 + m^2 K a_i^{m-1} $$\nThe Newton step $p^{(k)}$ can be computed component-wise by inverting the diagonal Jacobian:\n$$ p_i^{(k)} = -\\frac{F_i(a_i^{(k)})}{J_{ii}(a_i^{(k)})} = -\\frac{a_i^{(k)} + m K (a_i^{(k)})^m - D_i}{1 + m^2 K (a_i^{(k)})^{m-1}} $$\nAs shown in the validation, the denominator $J_{ii}(a_i^{(k)}) = 1 + m^2 K (a_i^{(k)})^{m-1} \\ge 1$ for all valid $a_i^{(k)} \\ge 0$, so the step is always well-defined.\n\n**2. Global Convergence: Damping and Line Search**\nTo ensure convergence from initial guesses that may be far from the solution, we introduce a step length $\\alpha^{(k)}$ and a line search procedure.\n\n**2.1. Feasibility-Preserving Damping**\nThe iterate must remain within the physical box constraints $[0, D]$ at every step. That is, for each component $i$, we require $0 \\le a_i^{(k+1)} \\le D_i$.\n$$ 0 \\le a_i^{(k)} + \\alpha p_i^{(k)} \\le D_i $$\nThis imposes an upper limit on the step length $\\alpha$.\n- If $p_i^{(k)}  0$, we must satisfy $a_i^{(k)} + \\alpha p_i^{(k)} \\le D_i \\implies \\alpha \\le \\frac{D_i - a_i^{(k)}}{p_i^{(k)}}$.\n- If $p_i^{(k)}  0$, we must satisfy $a_i^{(k)} + \\alpha p_i^{(k)} \\ge 0 \\implies \\alpha \\le \\frac{-a_i^{(k)}}{p_i^{(k)}}$.\nTo satisfy these for all components simultaneously, we compute the maximum admissible step length, $\\alpha_{\\text{feas}}$, by taking the minimum of these ratios over all components $i$. The initial trial step length for the line search, $\\alpha_0$, is then set to $\\min(1, \\alpha_{\\text{feas}})$, ensuring that even the full Newton step (if chosen) respects the bounds.\n\n**2.2. Backtracking Line Search with Armijo Condition**\nThe line search ensures that each step provides a sufficient decrease in a merit function, here chosen as $\\phi(a) = \\frac{1}{2} \\lVert F(a) \\rVert_2^2$. The Newton direction $p^{(k)}$ is a descent direction for this function.\nThe Armijo condition requires that the step length $\\alpha$ satisfies:\n$$ \\phi(a^{(k)} + \\alpha p^{(k)}) \\le \\phi(a^{(k)}) + c_1 \\alpha \\nabla \\phi(a^{(k)})^T p^{(k)} $$\nwhere $c_1 \\in (0,1)$ is a small constant (e.g., $10^{-4}$). The directional derivative is $\\nabla \\phi(a)^T p = F(a)^T J(a) p$. Since $J(a)p = -F(a)$, this simplifies to:\n$$ \\nabla \\phi(a^{(k)})^T p^{(k)} = -F(a^{(k)})^T F(a^{(k)}) = -\\lVert F(a^{(k)}) \\rVert_2^2 $$\nThe Armijo condition becomes:\n$$ \\phi(a^{(k)} + \\alpha p^{(k)}) \\le \\phi(a^{(k)}) - c_1 \\alpha \\lVert F(a^{(k)}) \\rVert_2^2 $$\nThe backtracking algorithm starts with the feasibility-preserving step length $\\alpha = \\alpha_0$. If the Armijo condition is not met, $\\alpha$ is repeatedly reduced by a contraction factor $\\tau \\in (0,1)$ (e.g., $0.5$) until the condition is satisfied.\n\n**3. Algorithm Summary**\nFor $k = 0, 1, 2, \\dots$ until convergence or maximum iterations:\n1.  Given the current iterate $a^{(k)}$, compute the residual vector $F(a^{(k)})$.\n2.  Check for convergence: If $\\lVert F(a^{(k)}) \\rVert_{\\infty} \\le \\varepsilon$, terminate and return $a^{(k)}$.\n3.  Compute the diagonal Jacobian $J(a^{(k)})$ and the Newton step $p^{(k)} = -J(a^{(k)})^{-1}F(a^{(k)})$.\n4.  Compute the maximum step length $\\alpha_0$ that preserves feasibility, $\\alpha_0 = \\min(1, \\alpha_{\\text{feas}})$.\n5.  Perform a backtracking line search starting with $\\alpha = \\alpha_0$:\n    While $\\phi(a^{(k)} + \\alpha p^{(k)})  \\phi(a^{(k)}) - c_1 \\alpha \\lVert F(a^{(k)}) \\rVert_2^2$:\n        $\\alpha \\leftarrow \\tau \\alpha$.\n6.  Update the solution: $a^{(k+1)} = a^{(k)} + \\alpha p^{(k)}$.\nIf the loop finishes due to reaching the maximum number of iterations, the last computed $a^{(k)}$ is returned as the best-effort result.\nThe computed final concentration $a$ is then used to calculate the activation fraction(s) for the output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef damped_newton(D, m, K, a0, tol=1e-12, max_iter=100, c1=1e-4, tau=0.5):\n    \"\"\"\n    Solves the system F(a) = a + m*K*a^m - D = 0 using a globally convergent\n    damped Newton method with a backtracking line search and feasibility-preserving damping.\n    \"\"\"\n    D_arr = np.atleast_1d(D)\n    a = np.atleast_1d(a0).astype(float)\n\n    # Project the initial guess onto the feasible domain [0, D] for robustness.\n    a = np.clip(a, 0, D_arr)\n\n    for _ in range(max_iter):\n        # 1. Evaluate residual F(a) and check for convergence\n        # The term a**m is safe because m >= 2.\n        a_pow_m = a**m\n        F_val = a + m * K * a_pow_m - D_arr\n\n        if np.max(np.abs(F_val)) = tol:\n            return a\n\n        # 2. Compute Jacobian and Newton step p\n        # The term a**(m-1) is safe because m >= 2, so m-1 >= 1.\n        a_pow_m_minus_1 = a**(m - 1)\n        J_diag = 1.0 + m**2 * K * a_pow_m_minus_1\n\n        # The Jacobian is a diagonal matrix with entries >= 1, so inversion is safe.\n        p = -F_val / J_diag\n\n        # 3. Feasibility-preserving damping: compute max allowed step length\n        alpha_max = 1.0\n        \n        # Components where step p_i is positive are limited by the upper bound D_i\n        idx_pos = p > 1e-15\n        if np.any(idx_pos):\n            # (D_arr - a) is guaranteed to be non-negative. If a_i = D_i, p_i must be  0.\n            alpha_pos = (D_arr[idx_pos] - a[idx_pos]) / p[idx_pos]\n            alpha_max = min(alpha_max, np.min(alpha_pos))\n\n        # Components where step p_i is negative are limited by the lower bound 0\n        idx_neg = p  -1e-15\n        if np.any(idx_neg):\n            # a is guaranteed to be non-negative. If a_i = 0, p_i must be > 0.\n            alpha_neg = -a[idx_neg] / p[idx_neg]\n            alpha_max = min(alpha_max, np.min(alpha_neg))\n        \n        # 4. Backtracking line search with Armijo condition\n        alpha = alpha_max\n        phi_a = 0.5 * np.sum(F_val**2)\n        # The directional derivative of phi in direction p is -||F||^2 = -2*phi\n        descent_term = -2.0 * phi_a\n        \n        while True:\n            a_new = a + alpha * p\n            \n            F_new = a_new + m * K * (a_new**m) - D_arr\n            phi_a_new = 0.5 * np.sum(F_new**2)\n            \n            armijo_rhs = phi_a + c1 * alpha * descent_term\n            if phi_a_new = armijo_rhs:\n                break # Step accepted\n            \n            alpha *= tau\n            if alpha  1e-16: # Fallback to prevent stall\n                break\n\n        # 5. Update the solution\n        a += alpha * p\n\n    return a\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'D': 1.0, 'm': 2, 'K': 0.5, 'a0': 0.0},\n        {'D': 10.0, 'm': 3, 'K': 0.02, 'a0': 10.0},\n        {'D': [0.1, 1.0, 5.0, 10.0, 20.0], 'm': 3, 'K': 0.05, 'a0': [0.0, 0.0, 0.0, 0.0, 0.0]},\n        {'D': 1.0, 'm': 4, 'K': 1.0, 'a0': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        D_val = case['D']\n        m_val = case['m']\n        K_val = case['K']\n        a0_val = case['a0']\n        \n        a_final = damped_newton(\n            D=D_val,\n            m=m_val,\n            K=K_val,\n            a0=a0_val,\n        )\n        \n        D_arr = np.atleast_1d(D_val)\n        \n        # For D_i > 0 which is a problem constraint, this is safe.\n        activation_fractions = a_final / D_arr\n        \n        if activation_fractions.size == 1:\n            result = activation_fractions[0]\n        else:\n            result = np.mean(activation_fractions)\n        \n        results.append(f\"{result:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}