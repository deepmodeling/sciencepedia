{
    "hands_on_practices": [
        {
            "introduction": "平流方程是许多物理系统中输运建模的基石，包括半导体中的电荷输运。虽然其形式简单，但其数值求解过程却揭示了深刻的挑战。本练习  提供了一个基础性实践，您将通过解析的方式证明一种直观的离散化方法——中心差分格式——为何会反常地产生非物理振荡，从而突显数值单调性这一关键概念。",
            "id": "4145386",
            "problem": "考虑在等离子体掺杂步骤中，半导体特征结构内移动电荷密度的一维纯漂移输运。忽略扩散和复合，在恒定电场和迁移率的条件下，电荷连续性方程简化为关于电荷密度 $n(x,t)$ 的纯平流标量偏微分方程 (PDE)。假设存在一个指向 $+x$ 方向的均匀、不随时间变化的电场 $\\mathbf{E}$，其大小为 $E>0$，且载流子迁移率 $\\mu>0$ 为常数。令漂移速度为 $v=\\mu E>0$。空间域在均匀网格 $x_i=i\\,\\Delta x$（$i$ 为整数）上进行离散化，时间步长为 $t^m=m\\,\\Delta t$（$m$ 为整数）。空间导数使用二阶中心差分近似，时间导数使用前向欧拉时间步进近似。初始离散电荷密度对应一个陡峭的掩模边缘（跨越光刻边界的阶跃），由 $n_i^{0}=n(x_i,0)$ 给出，定义为：当 $i\\leq 0$ 时，$n_i^{0}=1$；当 $i\\geq 1$ 时，$n_i^{0}=0$。\n\n从基本的电荷连续性方程和漂移电流的本构关系出发，使用平流项的中心差分，推导一个前向欧拉时间步长在通用网格点上的离散更新方程。然后，通过在上述阶跃初始条件下，计算一个时间步长 $t^{1}=\\Delta t$ 后网格索引 $i=0$ 处的更新值，构建一个单调性的反例。在此背景下，单调性意味着每个网格点上更新后的解应位于其前一时间步长相邻数据值的闭凸包内。通过解析证明，对于 $v>0$，中心差分格式在掩模边缘产生了超过初始最大值的过冲，从而违反了单调性。\n\n作为最终答案，请提供一个时间步长后在 $i=0$ 处的过冲幅度的单一闭式表达式，该幅度定义为 $n_0^{1}-\\max_i n_i^{0}$，并用 $v$、$\\Delta t$ 和 $\\Delta x$ 表示。无需取整，过冲幅度是无量纲的；仅给出解析表达式作为答案。",
            "solution": "该问题要求分析一种用于半导体中电荷输运的数值格式，并具体证明其非单调行为。分析始于所提供的基本物理原理。\n\n移动电荷的输运由一维电荷连续性方程决定：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial J}{\\partial x} = 0\n$$\n其中 $\\rho$ 是体电荷密度，$J$ 是电流密度。移动电荷密度由 $n(x,t)$ 给出，因此体电荷密度可以写成 $\\rho = qn$，其中 $q$ 是载流子的基本电荷。问题陈述忽略扩散和复合，因此电流纯粹由漂移引起。漂移电流密度由本构关系 $J = \\rho v$ 给出，其中 $v$ 是漂移速度。将这些关系代入连续性方程，得到：\n$$\n\\frac{\\partial (qn)}{\\partial t} + \\frac{\\partial (qnv)}{\\partial x} = 0\n$$\n问题指明电场 $E$ 和迁移率 $\\mu$ 是常数，这意味着漂移速度 $v = \\mu E$ 也是一个正常数。基本电荷 $q$ 是一个基本常数。因此，我们可以将这些常数从导数中提取出来：\n$$\nq \\frac{\\partial n}{\\partial t} + qv \\frac{\\partial n}{\\partial x} = 0\n$$\n两边除以 $q$，表达式简化为关于电荷密度 $n(x,t)$ 的线性平流方程：\n$$\n\\frac{\\partial n}{\\partial t} + v \\frac{\\partial n}{\\partial x} = 0\n$$\n接下来，我们在均匀网格上离散化这个偏微分方程，空间步长为 $\\Delta x$，时间步长为 $\\Delta t$，使得 $x_i = i\\,\\Delta x$ 且 $t^m = m\\,\\Delta t$。离散电荷密度表示为 $n_i^m \\approx n(x_i, t^m)$。问题指定了数值格式：时间导数由前向欧拉差分近似，空间导数由二阶中心差分近似。\n\n在 $(x_i, t^m)$ 处，时间导数的前向欧拉近似为：\n$$\n\\frac{\\partial n}{\\partial t} \\bigg|_{i,m} \\approx \\frac{n_i^{m+1} - n_i^m}{\\Delta t}\n$$\n空间导数的二阶中心差分为：\n$$\n\\frac{\\partial n}{\\partial x} \\bigg|_{i,m} \\approx \\frac{n_{i+1}^m - n_{i-1}^m}{2 \\Delta x}\n$$\n将这些离散近似代入平流方程，得到有限差分方程：\n$$\n\\frac{n_i^{m+1} - n_i^m}{\\Delta t} + v \\left( \\frac{n_{i+1}^m - n_{i-1}^m}{2 \\Delta x} \\right) = 0\n$$\n为推导更新规则，我们求解下一个时间步的电荷密度 $n_i^{m+1}$：\n$$\nn_i^{m+1} = n_i^m - v \\frac{\\Delta t}{2 \\Delta x} (n_{i+1}^m - n_{i-1}^m)\n$$\n这是在任意网格点 $i$ 和时间步长 $m$ 上的离散更新的通用表达式。该格式被称为前向时间中心空间（FTCS）方法。\n\n问题要求通过计算从 $t^0=0$ 演化到 $t^1=\\Delta t$ 的第一个时间步长后，在网格索引 $i=0$ 处的更新值，来证明其违反了单调性。在更新方程中令 $i=0$ 和 $m=0$，我们得到：\n$$\nn_0^1 = n_0^0 - v \\frac{\\Delta t}{2 \\Delta x} (n_{1}^0 - n_{-1}^0)\n$$\n初始条件以阶跃函数形式给出：\n- 当 $i \\leq 0$ 时，$n_i^0 = 1$\n- 当 $i \\geq 1$ 时，$n_i^0 = 0$\n\n根据这个初始条件，我们可以确定计算 $n_0^1$ 所需的特定网格点上的值：\n- 对于 $i=0$，$n_0^0 = 1$\n- 对于 $i=1$，$n_1^0 = 0$\n- 对于 $i=-1$，$n_{-1}^0 = 1$\n\n将这些初始值代入 $n_0^1$ 的方程中：\n$$\nn_0^1 = 1 - v \\frac{\\Delta t}{2 \\Delta x} (0 - 1)\n$$\n$$\nn_0^1 = 1 + \\frac{v \\Delta t}{2 \\Delta x}\n$$\n问题将单调性定义为一个性质，即在任意网格点上更新后的解都应位于其前一时间步长邻近值的范围内。此性质的一个推论是，该数值格式不应产生新的极大值或极小值。初始数据中的最大值为 $\\max_i n_i^0 = 1$。一个时间步长后在 $i=0$ 处的计算值为 $n_0^1 = 1 + \\frac{v \\Delta t}{2 \\Delta x}$。\n\n鉴于漂移速度 $v>0$，且离散化步长 $\\Delta t>0$ 和 $\\Delta x>0$，项 $\\frac{v \\Delta t}{2 \\Delta x}$ 严格为正。因此，\n$$\nn_0^1 > 1\n$$\n此结果表明，一个时间步长后在网格点 $i=0$ 处的电荷密度值大于初始时刻在整个域中存在的最大值。这种产生新的、非物理的极大值的现象被称为过冲，它明显违反了单调性原理。\n\n最后的任务是提供在 $i=0$ 处的过冲幅度的表达式，定义为 $n_0^1 - \\max_i n_i^0$。使用推导出的结果：\n$$\n\\text{过冲幅度} = n_0^1 - \\max_i n_i^0 = \\left(1 + \\frac{v \\Delta t}{2 \\Delta x}\\right) - 1\n$$\n简化后得到：\n$$\n\\text{过冲幅度} = \\frac{v \\Delta t}{2 \\Delta x}\n$$\n此表达式表示在给定的格式和初始条件下，经过一个时间步长后，对单调性违反的幅度。",
            "answer": "$$\n\\boxed{\\frac{v \\Delta t}{2 \\Delta x}}\n$$"
        },
        {
            "introduction": "半导体制造中的许多物理过程，例如掺杂剂激活，是由刚性常微分方程组描述的，其中不同过程发生在迥异的时间尺度上。本练习  将让您沉浸于刚性问题带来的实际影响中，通过比较一种受稳定性限制的显式龙格-库塔方法和一种由精度决定的隐式后向差分公式。您将量化两种方法在计算成本上的巨大差异，这是选择数值求解器时的核心考量因素。",
            "id": "4145395",
            "problem": "考虑在半导体制造过程中的等温退火期间，电活性掺杂剂的比例 $a(t)$。一个广泛使用的一阶动力学模型假设，激活和去激活通过热激活反应进行，得到以下线性常微分方程\n$$\n\\frac{da}{dt} = k_{\\mathrm{on}}(T)\\,\\big(a_{\\mathrm{eq}} - a(t)\\big) - k_{\\mathrm{off}}(T)\\,a(t),\n$$\n其中 $a(t)$ 是无量纲的，$t$ 的单位是秒，$T$ 的单位是开尔文，$a_{\\mathrm{eq}}$ 是平衡时的活性比例（无量纲），速率系数遵循阿伦尼乌斯定律\n$$\nk_{\\mathrm{on}}(T) = \\nu_{\\mathrm{on}}\\exp\\!\\left(-\\frac{E_{\\mathrm{on}}}{k_{\\mathrm{B}}T}\\right),\\quad\nk_{\\mathrm{off}}(T) = \\nu_{\\mathrm{off}}\\exp\\!\\left(-\\frac{E_{\\mathrm{off}}}{k_{\\mathrm{B}}T}\\right),\n$$\n其中 $\\nu_{\\mathrm{on}}$ 和 $\\nu_{\\mathrm{off}}$ 的单位是 $\\mathrm{s}^{-1}$，活化能 $E_{\\mathrm{on}}$ 和 $E_{\\mathrm{off}}$ 的单位是电子伏特，而 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，单位是 $\\mathrm{eV/K}$。该模型在固定温度下是常系数线性的，其形式为\n$$\n\\frac{da}{dt} = c + \\lambda\\, a(t),\n$$\n其中 $\\lambda = -\\big(k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)\\big)$ 且 $c = k_{\\mathrm{on}}(T)\\,a_{\\mathrm{eq}}$。\n\n你需要对几组参数集，确定达到最终物理时间 $t_f$ 所需的最小均匀时间步数，同时满足两种方法的数值稳定性（若适用）和精度约束：\n- 经典的显式四阶龙格－库塔方法 (RK4)。\n- 隐式二阶后向差分公式 (BDF2)，以单个隐式梯形步启动以保持二阶精度。\n\n使用以下原则：\n- 绝对稳定性是相对于线性测试方程 $y'=\\lambda y$ 和步长 $h$ 定义的，要求方法的放大因子 $R(h\\lambda)$ 满足 $|R(h\\lambda)| \\le 1$。对于显式方法，在具有如上定义的常数 $\\lambda$ 的线性化模型上强制执行此条件。对于具有所述启动方式的隐式 BDF2 方法，应根据其对 $\\operatorname{Re}(\\lambda) < 0$ 的绝对稳定性属性来处理。\n- 通过要求在 $t_f$ 处的绝对全局误差最多为用户指定的容差 $\\varepsilon$ 来强制执行精度，即：\n$$\n|a_{\\mathrm{num}}(t_f;h) - a_{\\mathrm{exact}}(t_f)| \\le \\varepsilon.\n$$\n此处 $a_{\\mathrm{num}}(t_f;h)$ 是使用所述方法以均匀步长 $h=t_f/N$ 计算得到的在 $t_f$ 处的数值解，$a_{\\mathrm{exact}}(t)$ 是线性模型的精确解。为确保二阶一致性，BDF2 方法的启动必须是使用相同步长 $h$ 的单步隐式梯形法则。\n\n基本依据和数据：\n- 使用如上给出的阿伦尼乌斯定律和模型的线性特性。玻尔兹曼常数为 $k_{\\mathrm{B}}=8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$。\n- 该常系数线性非齐次方程的精确解为\n$$\na_{\\mathrm{exact}}(t) = a_{\\infty} + \\big(a_0 - a_{\\infty}\\big)\\,e^{\\lambda t},\\quad a_{\\infty} = -\\frac{c}{\\lambda} = \\frac{k_{\\mathrm{on}}(T)}{k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)}\\,a_{\\mathrm{eq}},\n$$\n初始值为 $a(0)=a_0$。\n\n任务：\n- 对于下面的每个测试用例，计算最小整数 $N_{\\mathrm{RK4}}$ 和 $N_{\\mathrm{BDF2}}$，使得当 $h=t_f/N$ 时：\n  - 对于显式 RK4：在线性化模型上的绝对稳定性和在 $t_f$ 处的精度约束都成立。\n  - 对于隐式 BDF2（带单步隐式梯形启动）：在 $t_f$ 处的精度约束成立。根据该方法对 $\\operatorname{Re}(\\lambda) < 0$ 的绝对稳定性来处理稳定性问题。\n- 你的算法必须确定最小的 $N$，而不能使用任何闭式“捷径”全局误差常数；你可以计算数值解并与精确解进行比较。你必须对给定的线性模型严格应用显式方法的绝对稳定性定义。\n\n物理单位：\n- 时间 $t$ 和 $t_f$ 的单位是秒，温度 $T$ 的单位是开尔文，活化能的单位是电子伏特，速率的单位是 $\\mathrm{s}^{-1}$。\n- 将 $N$ 报告为整数。\n\n测试套件：\n- 用例 1：$T=1000\\,\\mathrm{K}$，$t_f=1.0\\,\\mathrm{s}$，$a_0=0.1$，$a_{\\mathrm{eq}}=0.9$，$\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{on}}=2.1\\,\\mathrm{eV}$，$\\nu_{\\mathrm{off}}=5.0\\times 10^{12}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{off}}=2.4\\,\\mathrm{eV}$，$\\varepsilon=1.0\\times 10^{-6}$。\n- 用例 2：$T=1150\\,\\mathrm{K}$，$t_f=0.1\\,\\mathrm{s}$，$a_0=0.05$，$a_{\\mathrm{eq}}=0.95$，$\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{on}}=2.0\\,\\mathrm{eV}$，$\\nu_{\\mathrm{off}}=8.0\\times 10^{12}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{off}}=2.2\\,\\mathrm{eV}$，$\\varepsilon=1.0\\times 10^{-8}$。\n- 用例 3：$T=850\\,\\mathrm{K}$，$t_f=10.0\\,\\mathrm{s}$，$a_0=0.2$，$a_{\\mathrm{eq}}=0.85$，$\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{on}}=2.4\\,\\mathrm{eV}$，$\\nu_{\\mathrm{off}}=5.0\\times 10^{12}\\,\\mathrm{s}^{-1}$，$E_{\\mathrm{off}}=2.8\\,\\mathrm{eV}$，$\\varepsilon=1.0\\times 10^{-6}$。\n\n数值要求：\n- 在任何可能出现角度的地方使用弧度。\n- 与容差的所有比较都必须是绝对值（无量纲）。\n- 对于 RK4，通过其稳定性函数，在每个候选步长 $h$ 下，对如上定义的线性化模型强制执行绝对稳定性。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，格式如下\n$$\n\\big[N_{\\mathrm{RK4}}^{(1)},N_{\\mathrm{BDF2}}^{(1)},N_{\\mathrm{RK4}}^{(2)},N_{\\mathrm{BDF2}}^{(2)},N_{\\mathrm{RK4}}^{(3)},N_{\\mathrm{BDF2}}^{(3)}\\big],\n$$\n其中上标表示测试用例的索引。元素必须是整数。程序的输出行中不允许有额外的文本或格式。",
            "solution": "用户提供了一个来自数值分析领域的问题，应用于半导体制造中掺杂剂激活的物理模型。任务是确定使用两种不同的数值方法——显式四阶龙格-库塔 (RK4) 方法和隐式二阶后向差分公式 (BDF2)——求解一个线性常微分方程 (ODE) 直至最终时间 $t_f$ 所需的最小均匀时间步数 $N$。$N$ 的确定必须满足特定方法的稳定性约束和共同的精度约束。\n\n该问题的有效性验证如下：\n- **科学依据**：该模型基于标准的一阶反应动力学和阿伦尼乌斯定律，这些是物理化学和材料科学中的基本原理。该问题在科学上是合理的。\n- **适定性**：该 ODE 是一个常系数线性一阶初值问题。保证了唯一、稳定的解的存在。数值稳定性和精度的约束是定量定义的。寻找最小整数 $N$ 的任务是明确定义的。\n- **客观性和完整性**：该问题使用精确的数学语言陈述，并为每个测试用例提供了所有必要的物理常数、参数、初始条件和数值容差。没有歧义或主观陈述。\n\n该问题被认为是有效的，并构建了分步解决方案。\n\n### 步骤 1：模型参数计算\n对于每个测试用例，我们首先计算线性 ODE $\\frac{da}{dt} = c + \\lambda a(t)$ 的系数。\n使用温度 $T$、活化能 $E_{\\mathrm{on}}, E_{\\mathrm{off}}$ 和指前因子 $\\nu_{\\mathrm{on}}, \\nu_{\\mathrm{off}}$，通过阿伦尼乌斯方程计算速率系数：\n$$\nk_{\\mathrm{on}}(T) = \\nu_{\\mathrm{on}}\\exp\\!\\left(-\\frac{E_{\\mathrm{on}}}{k_{\\mathrm{B}}T}\\right)\n$$\n$$\nk_{\\mathrm{off}}(T) = \\nu_{\\mathrm{off}}\\exp\\!\\left(-\\frac{E_{\\mathrm{off}}}{k_{\\mathrm{B}}T}\\right)\n$$\n其中 $k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$。\n然后，ODE 参数 $\\lambda$ 和 $c$ 为：\n$$\n\\lambda = -\\big(k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)\\big)\n$$\n$$\nc = k_{\\mathrm{on}}(T)\\,a_{\\mathrm{eq}}\n$$\n由于 $k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 总是正的，所以 $\\lambda$ 总是实数且为负。\n\n### 步骤 2：精确解\n线性 ODE 的精确解对于评估数值方法的精度是必需的。给定初始条件 $a(0)=a_0$，解为：\n$$\na_{\\mathrm{exact}}(t) = a_{\\infty} + (a_0 - a_{\\infty})e^{\\lambda t}\n$$\n其中 $a_{\\infty}$ 是稳态解：\n$$\na_{\\infty} = -\\frac{c}{\\lambda} = \\frac{k_{\\mathrm{on}}(T) a_{\\mathrm{eq}}}{k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)}\n$$\n我们计算最终时间 $t_f$ 处的精确值 $a_{\\mathrm{exact}}(t_f)$，作为精度检查的参考：$|\\,a_{\\mathrm{num}}(t_f) - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$。\n\n### 步骤 3：RK4 的最小步数 ($N_{\\mathrm{RK4}}$)\n$N_{\\mathrm{RK4}}$ 的确定需要同时满足稳定性和精度约束。最终的步数必须是每个约束所要求的步数的最大值。\n\n**稳定性约束：**\nRK4 方法的绝对稳定性由其对测试方程 $y' = \\lambda y$ 的放大因子 $R(z) = \\sum_{k=0}^{4} z^k/k!$ 决定，其中 $z = h\\lambda$。对于实数负 $\\lambda$，稳定性条件 $|R(h\\lambda)| \\le 1$ 在 $h\\lambda \\in [-2.78528..., 0]$ 时成立。这对步长 $h = t_f/N$ 施加了一个上限：\n$$\nh \\le \\frac{-2.785281594}{\\lambda}\n$$\n这转化为稳定性所需的最小步数 $N_{\\mathrm{stab}}$：\n$$\nN_{\\mathrm{stab}} = \\left\\lceil \\frac{t_f}{h_{\\mathrm{max}}} \\right\\rceil = \\left\\lceil \\frac{-t_f \\lambda}{2.785281594} \\right\\rceil\n$$\n\n**精度约束：**\n为了找到满足精度的最小步数 $N_{\\mathrm{acc}}$，我们进行数值搜索。由于我们不能使用闭式误差估计，我们必须直接模拟系统。我们实现一个搜索算法，该算法首先通过将 $N$ 加倍直到满足精度容差 $\\varepsilon$ 来找到其上界，然后在新确定的范围内进行二分搜索，以找到满足条件的最小整数 $N$。对于每个候选 $N$，运行一个完整的 RK4 模拟：\n- 设置 $h=t_f/N$ 和 $a_0$。\n- 迭代 $N$ 次：\n  $$\n  k_1 = f(a_n) \\\\\n  k_2 = f(a_n + \\frac{h}{2}k_1) \\\\\n  k_3 = f(a_n + \\frac{h}{2}k_2) \\\\\n  k_4 = f(a_n + hk_3) \\\\\n  a_{n+1} = a_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n  $$\n- 检查是否 $|\\,a_N - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$。\n\nRK4 的最终最小步数为 $N_{\\mathrm{RK4}} = \\max(N_{\\mathrm{stab}}, N_{\\mathrm{acc}})$。\n\n### 步骤 4：BDF2 的最小步数 ($N_{\\mathrm{BDF2}}$)\n\n**稳定性约束：**\nBDF2 方法是 A-稳定的，这意味着其绝对稳定区域包含整个左半复平面，即 $\\operatorname{Re}(z) \\le 0$。由于我们的 $\\lambda$ 总是实数且为负，该方法对于任何步长 $h>0$ 都是无条件稳定的。因此，稳定性对 $N$ 没有限制，$N_{\\mathrm{BDF2}}$ 完全由精度要求决定。\n\n**精度约束：**\nBDF2 方法是一个两步法，需要一个启动程序。按照规定，我们使用单步二阶隐式梯形法则从 $a_0$ 计算 $a_1$。\n- **启动（梯形法则）：** 对于线性 ODE，我们可以显式地解出 $a_1$：\n$$\na_1 = a_0 + \\frac{h}{2}\\left( (c+\\lambda a_0) + (c+\\lambda a_1) \\right) \\implies a_1 = \\frac{a_0(1+\\frac{h\\lambda}{2}) + hc}{1-\\frac{h\\lambda}{2}}\n$$\n- **主循环 (BDF2)：** 对于 $n \\ge 1$，我们使用 $a_n$ 和 $a_{n-1}$ 计算 $a_{n+1}$。对于我们的线性 ODE，我们同样可以显式地解出 $a_{n+1}$：\n$$\na_{n+1} = \\frac{4}{3}a_n - \\frac{1}{3}a_{n-1} + \\frac{2h}{3}(c+\\lambda a_{n+1}) \\implies a_{n+1} = \\frac{\\frac{4}{3}a_n - \\frac{1}{3}a_{n-1} + \\frac{2hc}{3}}{1-\\frac{2h\\lambda}{3}}\n$$\n使用相同的搜索算法（指数增长后接二分搜索）来找到满足 $|\\,a_N - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$ 的最小 $N_{\\mathrm{BDF2}}$。\n\n通过为每个测试用例实施这些步骤，我们可以确定所需的整数对 $(N_{\\mathrm{RK4}}, N_{\\mathrm{BDF2}})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function to find the minimal number of steps for RK4 and BDF2\n    methods to satisfy stability and accuracy constraints for a given ODE modelling\n    dopant activation in semiconductors.\n    \"\"\"\n    # Boltzmann constant in eV/K\n    KB = 8.617333262145e-5\n    # Stability limit for RK4 on the negative real axis for z = h*lambda\n    RK4_STABILITY_LIMIT = 2.785281594\n\n    def find_min_N(is_accurate_func):\n        \"\"\"\n        Finds the minimum integer N that satisfies the accuracy condition.\n        Uses an exponential increase to find an upper bound, then performs a\n        binary search to find the minimal N.\n        \"\"\"\n        if is_accurate_func(1):\n            return 1\n        \n        # Exponential search for an upper bound\n        n_upper = 2\n        while not is_accurate_func(n_upper):\n            # Safety break to prevent very long searches\n            if n_upper > 2**28: \n                raise RuntimeError(\n                    \"Search for N failed to converge within a reasonable limit.\"\n                )\n            n_upper *= 2\n        \n        # Binary search for the precise minimum N\n        low = n_upper // 2\n        high = n_upper\n        ans = high\n        \n        while low = high:\n            mid = low + (high - low) // 2\n            if mid == 0:\n                low = 1\n                continue\n            \n            if is_accurate_func(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n\n    test_cases = [\n        # Case 1: T=1000K, tf=1.0s, eps=1e-6\n        (1000.0, 1.0, 0.1, 0.9, 1.0e13, 2.1, 5.0e12, 2.4, 1.0e-6),\n        # Case 2: T=1150K, tf=0.1s, eps=1e-8\n        (1150.0, 0.1, 0.05, 0.95, 1.0e13, 2.0, 8.0e12, 2.2, 1.0e-8),\n        # Case 3: T=850K, tf=10.0s, eps=1e-6\n        (850.0, 10.0, 0.2, 0.85, 1.0e13, 2.4, 5.0e12, 2.8, 1.0e-6),\n    ]\n\n    all_results = []\n\n    for T, tf, a0, a_eq, nu_on, E_on, nu_off, E_off, eps in test_cases:\n        # Step 1: Calculate model parameters\n        k_on = nu_on * np.exp(-E_on / (KB * T))\n        k_off = nu_off * np.exp(-E_off / (KB * T))\n        \n        lam = -(k_on + k_off)\n        c = k_on * a_eq\n        \n        # The ODE right-hand side: da/dt = c + lam * a\n        def f_ode(a):\n            return c + lam * a\n\n        # Step 2: Calculate exact solution\n        if lam == 0:\n            a_exact_tf = a0 + c * tf\n        else:\n            a_inf = -c / lam\n            a_exact_tf = a_inf + (a0 - a_inf) * np.exp(lam * tf)\n\n        # --- Step 3: Find N_RK4 ---\n        \n        # Stability constraint\n        N_stab = math.ceil(-tf * lam / RK4_STABILITY_LIMIT)\n\n        # Accuracy constraint\n        def run_rk4(N):\n            h = tf / N\n            a_num = a0\n            for _ in range(N):\n                k1 = f_ode(a_num)\n                k2 = f_ode(a_num + 0.5 * h * k1)\n                k3 = f_ode(a_num + 0.5 * h * k2)\n                k4 = f_ode(a_num + h * k3)\n                a_num += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            return a_num\n\n        def is_accurate_rk4(N):\n            if N = 0: return False\n            a_num_tf = run_rk4(N)\n            return np.abs(a_num_tf - a_exact_tf) = eps\n        \n        N_acc_rk4 = find_min_N(is_accurate_rk4)\n        N_rk4 = max(N_stab, N_acc_rk4)\n        all_results.append(N_rk4)\n\n        # --- Step 4: Find N_BDF2 ---\n        \n        # Stability is unconditional (A-stable method)\n        # Accuracy constraint\n        def run_bdf2(N):\n            h = tf / N\n            \n            # First step: Implicit Trapezoidal startup\n            # a1 * (1 - h*lam/2) = a0*(1+h*lam/2) + h*c\n            a_n_minus_1 = a0\n            if N == 1:\n                return (a_n_minus_1 * (1.0 + 0.5 * h * lam) + h * c) / (1.0 - 0.5 * h * lam)\n            \n            a_n = (a_n_minus_1 * (1.0 + 0.5 * h * lam) + h * c) / (1.0 - 0.5 * h * lam)\n\n            # BDF2 steps for n > 1\n            # a_{n+1} * (1 - 2/3 h lam) = 4/3 a_n - 1/3 a_{n-1} + 2/3 h c\n            den = 1.0 - (2.0/3.0) * h * lam\n            for _ in range(1, N): # Loop N-1 times to get to the Nth step\n                num = (4.0/3.0) * a_n - (1.0/3.0) * a_n_minus_1 + (2.0/3.0) * h * c\n                a_n_plus_1 = num / den\n                \n                a_n_minus_1 = a_n\n                a_n = a_n_plus_1\n            return a_n\n\n        def is_accurate_bdf2(N):\n            if N = 0: return False\n            a_num_tf = run_bdf2(N)\n            return np.abs(a_num_tf - a_exact_tf) = eps\n            \n        N_bdf2 = find_min_N(is_accurate_bdf2)\n        all_results.append(N_bdf2)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了朴素格式如何失效后，我们现在转向为具有挑战性的漂移-扩散方程构建一个鲁棒的求解器，该方程控制着器件中的载流子输运。Scharfetter-Gummel离散化是一种工业标准技术，以其在存在导致强平流的陡峭电势梯度时仍能保持稳定性而著称。在这个高级实践  中，您将实现这一强大的方案，并验证其保持载流子浓度正性和满足离散极值原理的能力，从而避免简单方法产生的非物理伪影。",
            "id": "4145374",
            "problem": "考虑一维稳态载流子在陡峭半导体$p$-$n$结中的输运过程。使用包含爱因斯坦关系式的漂移-扩散（DD）模型，并假设使用无量纲变量，其中静电势$\\,\\psi(x)\\,$已用热电压单位给出，载流子密度已通过本征载流子密度归一化。求解域为$[0,1]$，使用在$x = 0.5$的结区附近加密的非均匀网格。您必须在非均匀网格上使用 Scharfetter–Gummel (SG) 通量对连续性方程进行离散化，并验证其数值稳定性、收敛性和准确性，具体表现为解的正性和无非物理下冲或过冲现象。\n\n基本和建模假设：\n- 电子和空穴的稳态连续性方程分别为 $\\,\\partial_x J_n = 0\\,$ 和 $\\,\\partial_x J_p = 0\\,$。\n- 漂移-扩散（DD）通量为 $\\,J_n = -D_n \\left(\\partial_x n - n \\,\\partial_x \\psi\\right)\\,$ 和 $\\,J_p = -D_p \\left(\\partial_x p + p \\,\\partial_x \\psi\\right)\\,$。\n- 爱因斯坦关系式意味着 $\\,D_n = \\mu_n V_T\\,$ 和 $\\,D_p = \\mu_p V_T\\,$；在选定的无量纲单位制中，设 $\\,D_n = D_p = 1\\,$。\n- 在长度为 $\\,h_{i+\\frac{1}{2}} = x_{i+1}-x_i\\,$、电势降为 $\\,\\Delta\\psi_{i+\\frac{1}{2}} = \\psi_{i+1} - \\psi_i\\,$ 的边 $[x_i,x_{i+1}]$ 上，Scharfetter–Gummel (SG) 数值通量使用伯努利函数 $\\,B(\\xi) = \\xi/(e^\\xi - 1)\\,$，并约定 $\\,B(0)=1\\,$。\n- 离散 SG 通量为\n$$\nJ_{n,i+\\frac{1}{2}} = -\\frac{1}{h_{i+\\frac{1}{2}}}\\left[n_{i+1} B(\\Delta\\psi_{i+\\frac{1}{2}}) - n_i B(-\\Delta\\psi_{i+\\frac{1}{2}})\\right],\n\\quad\nJ_{p,i+\\frac{1}{2}} = -\\frac{1}{h_{i+\\frac{1}{2}}}\\left[p_{i+1} B(-\\Delta\\psi_{i+\\frac{1}{2}}) - p_i B(\\Delta\\psi_{i+\\frac{1}{2}})\\right].\n$$\n- 稳态意味着 $\\,J_{n,i+\\frac{1}{2}} = J_{n,i-\\frac{1}{2}}\\,$ 和 $\\,J_{p,i+\\frac{1}{2}} = J_{p,i-\\frac{1}{2}}\\,$，当在接触点施加狄利克雷边界条件时，这将为 $\\,\\{n_i\\}\\,$ 和 $\\,\\{p_i\\}\\,$ 导出一个线性系统。\n\n给定一个用于模拟陡峭 $p$-$n$ 结的无量纲静电势分布：\n$$\n\\psi(x) = \\frac{\\Delta\\psi}{2}\\,\\tanh\\left(\\frac{x - x_j}{w}\\right),\n$$\n其中 $\\,\\Delta\\psi\\,$ 控制总电势降，$\\,x_j = 0.5\\,$ 是结中心，$\\,w\\,$ 控制过渡宽度。\n\n在 $\\,x=0\\,$ 和 $\\,x=1\\,$ 处载流子的边界条件（狄利克雷）指定为 $\\,n(0)=n_L\\,$, $\\,n(1)=n_R\\,$, $\\,p(0)=p_L\\,$, $\\,p(1)=p_R\\,$，其选择应与物理相符（例如，在归一化单位中 $\\,n_L p_L = 1\\,$ 和 $\\,n_R p_R = 1\\,$）。\n\n您的任务：\n1. 构建在 $\\,x=0.5\\,$ 附近加密的非均匀网格。使用一个从均匀计算坐标 $\\,\\xi \\in [0,1]\\,$ 到物理坐标 $\\,x\\,$ 的平滑、对称映射，定义如下\n$$\nx(\\xi) = \\frac{1}{2} + \\frac{1}{2}\\,\\frac{\\sinh\\!\\big(\\beta(\\xi-\\frac{1}{2})\\big)}{\\sinh\\!\\big(\\frac{\\beta}{2}\\big)},\n$$\n其中 $\\,\\beta \\ge 0\\,$ 控制在 $\\,x=0.5\\,$ 附近的聚集程度。对于 $\\,\\beta=0\\,$，默认为均匀网格。\n\n2. 在构建的非均匀网格上为电子和空穴实现 Scharfetter–Gummel 离散化。组装并求解生成的三对角线性系统，使用给定的狄利克雷边界条件，以获得网格节点上的 $\\,\\{n_i\\}\\,$ 和 $\\,\\{p_i\\}\\,$。\n\n3. 使用离散极值原理验证解的正性以及无非物理下冲或过冲现象：对于每种载流子，检查所有节点值是否严格为正，并且位于由边界值确定的闭区间内。即，对于载流子 $\\,c \\in \\{n,p\\}\\,$，其边界值为 $\\,c_L\\,$ 和 $\\,c_R\\,$，验证\n$$\n\\min_i c_i \\ge \\min(c_L, c_R), \\quad \\max_i c_i \\le \\max(c_L, c_R), \\quad \\text{and} \\quad \\min_i c_i > 0.\n$$\n\n4. 在中等 $\\,\\Delta\\psi\\,$ 值下，通过网格加密验证电子的收敛性。计算较粗网格解相对于一个极细网格参考解的 $\\,\\ell_\\infty\\,$ 误差，使用线性插值来比较不同网格上的解。确认随着网格加密，误差会减小。\n\n数值稳定性要求：\n- 对伯努利函数 $\\,B(\\xi)\\,$ 进行求值时，当 $\\,|\\xi|\\,$ 很小时，使用合适的级数展开以保证数值稳定性；当 $\\,|\\xi|\\,$ 很大时，使用稳定的指数计算（例如，使用 $\\,\\mathrm{expm1}\\,$ 来避免灾难性抵消）。\n\n测试套件：\n提供并求解以下四个测试案例，并按下方指定格式将结果汇总到单行输出中。\n\n- 案例 A (理想情况，陡峭但可控): $\\,\\Delta\\psi = 40\\,$, $\\,w = 0.02\\,$, $\\,\\beta = 6\\,$, $\\,N = 201\\,$ 个节点。边界值: $\\,n_L = 10^4\\,$, $\\,n_R = 10^{-4}\\,$, $\\,p_L = 10^{-4}\\,$, $\\,p_R = 10^4\\,$。输出一个布尔值，如果电子和空穴的解都满足正性和离散极值原理界限，则为 true。\n\n- 案例 B (边界情况，极度陡峭): $\\,\\Delta\\psi = 80\\,$, $\\,w = 0.01\\,$, $\\,\\beta = 6\\,$, $\\,N = 101\\,$ 个节点。边界值: $\\,n_L = 10^6\\,$, $\\,n_R = 10^{-6}\\,$, $\\,p_L = 10^{-6}\\,$, $\\,p_R = 10^6\\,$。输出一个布尔值，如果电子和空穴的解都满足正性和离散极值原理界限，则为 true。\n\n- 案例 C (边界条件检查，平坦场): $\\,\\Delta\\psi = 0\\,$, $\\,w = 0.05\\,$, $\\,\\beta = 0\\,$, $\\,N = 51\\,$ 个节点。边界值: $\\,n_L = 10^3\\,$, $\\,n_R = 10^{-2}\\,$, $\\,p_L = 10^{-2}\\,$, $\\,p_R = 10^3\\,$。输出一个布尔值，如果电子和空穴的解都满足正性和离散极值原理界限，则为 true。\n\n- 案例 D (加密下的收敛性，中等场强): $\\,\\Delta\\psi = 20\\,$, $\\,w = 0.05\\,$, $\\,\\beta = 4\\,$。考虑三个网格，分别有 $\\,N_1=51\\,$, $\\,N_2=101\\,$ 和 $\\,N_3=401\\,$ 个节点。边界值: $\\,n_L = 10^3\\,$, $\\,n_R = 10^{-1}\\,$。在所有三个网格上计算电子解，并使用最细的网格 $\\,N_3\\,$ 作为参考。将粗网格和中等网格的解插值到细网格上，并计算 $\\,\\ell_\\infty\\,$ 误差 $\\,E_{1\\to 3}\\,$ 和 $\\,E_{2\\to 3}\\,$。输出一个布尔值，如果 $\\,E_{1\\to 3}  E_{2\\to 3}\\,$，则为 true，表示误差随网格加密单调减小。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含按 $[A,B,C,D]$ 顺序排列的结果，形式为方括号括起来的逗号分隔列表。列表中的每个元素是对应案例的布尔结果，如上所述。例如：\"[True,True,True,True]\"。不应打印任何额外文本。",
            "solution": "用户提供了一个来自计算半导体器件建模领域的科学上合理且适定的问题。该问题要求在一维非均匀网格上，实现并验证用于稳态漂移-扩散方程的 Scharfetter-Gummel (SG) 离散化格式。\n\n验证步骤确认所有必要的组成部分均已提供，包括控制方程、边界条件、离散化公式、网格生成函数、电势分布以及用于验证数值稳定性和收敛性的特定测试案例。该问题基于既有的物理和数值原理，任务客观且可验证。因此，我将继续提供完整解答。\n\n求解方法包括以下步骤：\n1.  **伯努利函数**：伯努利函数 $B(\\xi) = \\xi / (e^\\xi - 1)$ 的数值稳定实现至关重要。对于小的 $|\\xi|$，使用泰勒级数展开来防止灾难性抵消。对于较大的值，标准的浮点运算，辅以 `numpy.expm1` 以提高精度，已经足够。恒等式 $B(-\\xi) = B(\\xi) + \\xi$ 对 SG 格式也至关重要。\n2.  **网格生成**：创建一个函数，使用指定的映射 $x(\\xi) = \\frac{1}{2} + \\frac{1}{2} \\sinh(\\beta(\\xi-1/2)) / \\sinh(\\beta/2)$ 从均匀计算网格 $\\xi$ 生成非均匀物理网格 $x$。处理了 $\\beta=0$ 导致均匀网格的特殊情况。\n3.  **系统组装**：解法的核心是为每种载流子类型 $c \\in \\{n, p\\}$ 离散化连续性方程 $\\partial_x J_c = 0$。在每个内部网格节点 $x_i$（对于 $i=1, \\dots, N-2$）应用 SG 通量守恒条件 $J_{c, i-1/2} = J_{c, i+1/2}$，会得到一个关联载流子浓度 $c_{i-1}$、$c_i$ 和 $c_{i+1}$ 的线性方程。这为内部节点上的未知浓度导出了一个三对角线性方程组。\n    对于电子 ($n$)，节点 $i$ 处的方程是：\n    $$ \\frac{B(-\\Delta\\psi_{i-1/2})}{h_{i-1/2}} n_{i-1} - \\left(\\frac{B(\\Delta\\psi_{i-1/2})}{h_{i-1/2}} + \\frac{B(-\\Delta\\psi_{i+1/2})}{h_{i+1/2}}\\right) n_i + \\frac{B(\\Delta\\psi_{i+1/2})}{h_{i+1/2}} n_{i+1} = 0 $$\n    对于空穴 ($p$)，方程类似，只是将 $B(\\Delta\\psi)$ 和 $B(-\\Delta\\psi)$ 互换。\n4.  **系统求解**：得到的 $(N-2) \\times (N-2)$ 三对角系统形式为 $A\\mathbf{c} = \\mathbf{b}$，其中向量 $\\mathbf{b}$ 包含了狄利克雷边界条件。该系统使用 `scipy.linalg.solve_banded` 高效求解，该函数非常适合处理此类矩阵。\n5.  **验证**：\n    - **极值原理**：对于案例 A、B 和 C，电子和空穴的数值解 $\\{c_i\\}$ 均需对照离散极值原理进行检查。对于无源问题，SG 格式的一个关键性质是其解应受其边界值的界定。我们验证对于所有的 $i$，都有 $\\min(c_L, c_R) \\le c_i \\le \\max(c_L, c_R)$，并且所有浓度都为正，$c_i  0$。\n    - **收敛性**：对于案例 D，在三个逐步加密的网格上计算电子浓度。将较粗网格上的解插值到最细的网格上。计算相对于细网格参考解的误差的 $\\ell_\\infty$ 范数，即 $\\|\\mathbf{n}_{\\text{coarse}} - \\mathbf{n}_{\\text{ref}}\\|_\\infty$。通过检查误差是否随着网格分辨率的提高而减小来验证收敛性。\n\n该实现将被组织到一个主函数 `solve()` 中，该函数将为四个指定的测试案例协调执行这些步骤，并按要求格式化最终的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef bernoulli(x):\n    \"\"\"\n    Numerically stable implementation of the Bernoulli function B(x) = x / (exp(x) - 1).\n    \"\"\"\n    x = np.asarray(x)\n    res = np.zeros_like(x, dtype=float)\n    \n    # Use Taylor series for small |x| to avoid catastrophic cancellation.\n    # B(x) approx 1 - x/2 + x^2/12 - x^4/720\n    small_mask = np.abs(x)  1e-4\n    x_small = x[small_mask]\n    res[small_mask] = 1.0 - x_small/2.0 + x_small**2/12.0 - x_small**4/720.0\n    \n    # Use standard formula for non-small x, with np.expm1 for precision.\n    large_mask = ~small_mask\n    x_large = x[large_mask]\n    res[large_mask] = x_large / np.expm1(x_large)\n    \n    return res\n\ndef generate_mesh(N, beta):\n    \"\"\"\n    Generates a 1D physical mesh x on [0, 1] with N points.\n    beta controls the clustering of points around x=0.5.\n    beta=0 gives a uniform mesh.\n    \"\"\"\n    xi = np.linspace(0.0, 1.0, N)\n    if beta == 0:\n        return xi\n    else:\n        # Prevent potential overflow with very large beta, though sinh ratio is stable.\n        numerator = np.sinh(beta * (xi - 0.5))\n        denominator = np.sinh(beta / 2.0)\n        x = 0.5 + 0.5 * numerator / denominator\n        return x\n\ndef get_potential_profile(x, d_psi, w):\n    \"\"\"\n    Calculates the electrostatic potential profile psi(x).\n    \"\"\"\n    x_j = 0.5\n    return (d_psi / 2.0) * np.tanh((x - x_j) / w)\n\ndef solve_carrier(carrier_type, x, psi, c_L, c_R):\n    \"\"\"\n    Solves the 1D steady-state drift-diffusion equation using\n    Scharfetter-Gummel discretization for a given carrier type ('n' or 'p').\n    \"\"\"\n    N = len(x)\n    M = N - 2  # Number of interior points (unknowns)\n\n    if M = 0:\n      if N == 0: return np.array([])\n      if N == 1: return np.array([c_L]) # Or some average, but problem constraints imply N>=2\n      return np.array([c_L, c_R])\n\n\n    h = np.diff(x)      # h_{i+1/2}\n    d_psi = np.diff(psi) # psi_{i+1} - psi_i\n\n    # Pre-compute flux coefficients\n    g_p = bernoulli(d_psi) / h\n    g_m = bernoulli(-d_psi) / h\n\n    # Assemble the banded matrix A for the system A*c = b\n    # ab is a (3, M) array for scipy.linalg.solve_banded\n    ab = np.zeros((3, M))\n    rhs = np.zeros(M)\n    \n    if carrier_type == 'n':\n        # For electrons\n        ab[0, 1:] = g_p[1:M]                # Upper diagonal\n        ab[1, :] = -(g_p[:M] + g_m[1:M+1])  # Main diagonal\n        ab[2, :-1] = g_m[1:M]               # Lower diagonal\n        rhs[0] = -g_m[0] * c_L\n        rhs[-1] = -g_p[M] * c_R\n    elif carrier_type == 'p':\n        # For holes\n        ab[0, 1:] = g_m[1:M]                # Upper diagonal\n        ab[1, :] = -(g_m[:M] + g_p[1:M+1])  # Main diagonal\n        ab[2, :-1] = g_p[1:M]               # Lower diagonal\n        rhs[0] = -g_p[0] * c_L\n        rhs[-1] = -g_m[M] * c_R\n    else:\n        raise ValueError(\"carrier_type must be 'n' or 'p'\")\n\n    # Solve the tridiagonal system for interior nodes\n    c_internal = solve_banded((1, 1), ab, rhs)\n\n    # Combine with boundary values to form the full solution\n    c_sol = np.concatenate(([c_L], c_internal, [c_R]))\n    \n    return c_sol\n\ndef check_max_principle(c_sol, c_L, c_R):\n    \"\"\"\n    Verifies positivity and the discrete maximum principle bounds.\n    \"\"\"\n    if len(c_sol) == 0:\n        return True # Vacuously true\n    c_min_bound = min(c_L, c_R)\n    c_max_bound = max(c_L, c_R)\n    \n    # All values must be strictly positive\n    positivity_ok = np.all(c_sol > 0)\n    \n    # All values must lie within the bounds set by the BCs\n    min_val = np.min(c_sol)\n    max_val = np.max(c_sol)\n    \n    # Use a small tolerance for floating point comparisons\n    tol = 1e-9\n    bounds_ok = (min_val >= c_min_bound - tol) and (max_val = c_max_bound + tol)\n    \n    return positivity_ok and bounds_ok\n\ndef run_case_A():\n    params = {'d_psi': 40.0, 'w': 0.02, 'beta': 6.0, 'N': 201}\n    bcs = {'n_L': 1e4, 'n_R': 1e-4, 'p_L': 1e-4, 'p_R': 1e4}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n\ndef run_case_B():\n    params = {'d_psi': 80.0, 'w': 0.01, 'beta': 6.0, 'N': 101}\n    bcs = {'n_L': 1e6, 'n_R': 1e-6, 'p_L': 1e-6, 'p_R': 1e6}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n\ndef run_case_C():\n    params = {'d_psi': 0.0, 'w': 0.05, 'beta': 0.0, 'N': 51}\n    bcs = {'n_L': 1e3, 'n_R': 1e-2, 'p_L': 1e-2, 'p_R': 1e3}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n    \ndef run_case_D():\n    params = {'d_psi': 20.0, 'w': 0.05, 'beta': 4.0}\n    bcs = {'n_L': 1e3, 'n_R': 1e-1}\n    Ns = [51, 101, 401]\n    \n    # Solve on three grids\n    solutions = []\n    for N in Ns:\n        x = generate_mesh(N, params['beta'])\n        psi = get_potential_profile(x, params['d_psi'], params['w'])\n        n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n        solutions.append((x, n_sol))\n    \n    (x1, n1), (x2, n2), (x3, n3) = solutions\n    \n    # Interpolate coarse solutions onto the fine grid\n    n1_interp = np.interp(x3, x1, n1)\n    n2_interp = np.interp(x3, x2, n2)\n    \n    # Compute L-infinity errors\n    E_1_to_3 = np.max(np.abs(n1_interp - n3))\n    E_2_to_3 = np.max(np.abs(n2_interp - n3))\n    \n    # Check for error reduction\n    return E_1_to_3 > E_2_to_3\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    results = [\n        run_case_A(),\n        run_case_B(),\n        run_case_C(),\n        run_case_D()\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}