{
    "hands_on_practices": [
        {
            "introduction": "一个看似合理的数值格式有时会产生不符合物理规律的结果，尤其是在处理急剧变化的变量时。本练习将以经典的纯平流方程为例，使用前向时间中心空间（FTCS）差分格式，引导你通过解析推导来揭示该格式为何会违背单调性原则，从而在浓度阶跃附近产生非物理的振荡。理解这种数值不稳定性的根源，是认识到为何需要更先进的数值方法（如迎风格式）的关键第一步。",
            "id": "4145386",
            "problem": "考虑在等离子体掺杂步骤中，半导体器件内移动电荷密度的一维纯漂移输运。忽略扩散和复合，在恒定电场和迁移率条件下，电荷连续性方程简化为关于电荷密度 $n(x,t)$ 的纯平流标量偏微分方程（PDE）。假设存在一个指向 $+x$ 方向的均匀、不随时间变化的电场 $\\mathbf{E}$，其大小为 $E>0$，以及一个恒定的载流子迁移率 $\\mu>0$。令漂移速度为 $v=\\mu E>0$。空间域在均匀网格 $x_i=i\\,\\Delta x$（$i$ 为整数）上进行离散化，时间步长为 $t^m=m\\,\\Delta t$（$m$ 为整数）。空间导数使用二阶中心差分进行近似，时间导数使用前向欧拉时间步进进行近似。初始离散电荷密度对应于一个陡峭的掩模边缘（跨越光刻边界的阶跃），由 $n_i^{0}=n(x_i,0)$ 给出，定义为当 $i\\leq 0$ 时 $n_i^{0}=1$，当 $i\\geq 1$ 时 $n_i^{0}=0$。\n\n从基本的电荷连续性方程和漂移电流的本构关系出发，推导在一个通用网格点上，使用平流项的中心差分进行一次前向欧拉时间步进的离散更新公式。然后，通过在上述阶跃初始条件下，计算一个时间步 $t^{1}=\\Delta t$ 后网格索引 $i=0$ 处的更新值，构造一个违反单调性的反例。在此背景下，单调性意味着每个网格点上的更新解应位于其前一时间步相邻数据值的闭合凸包内。分析证明，对于 $v>0$，中心差分格式通过在掩模边缘产生一个超过初始最大值的过冲，从而违反了单调性。\n\n作为最终答案，请提供一个在 $i=0$ 处经过一个时间步长后过冲幅度的单一闭式表达式，该过冲幅度定义为 $n_0^{1}-\\max_i n_i^{0}$，并用 $v$、$\\Delta t$ 和 $\\Delta x$ 表示。无需四舍五入，过冲幅度是无量纲的；请仅以解析表达式的形式给出您的答案。",
            "solution": "该问题要求分析一种用于半导体中电荷输运的数值格式，特别是要证明其非单调行为。分析从所提供的基本物理原理开始。\n\n移动电荷的输运由一维电荷连续性方程决定：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial J}{\\partial x} = 0\n$$\n其中 $\\rho$ 是体电荷密度，$J$ 是电流密度。移动电荷密度由 $n(x,t)$ 给出，因此体电荷密度可以写成 $\\rho = qn$，其中 $q$ 是载流子的基本电荷。问题指出忽略扩散和复合，因此电流完全由漂移产生。漂移电流密度由本构关系 $J = \\rho v$ 给出，其中 $v$ 是漂移速度。将这些关系代入连续性方程，得到：\n$$\n\\frac{\\partial (qn)}{\\partial t} + \\frac{\\partial (qnv)}{\\partial x} = 0\n$$\n问题指明电场 $E$ 和迁移率 $\\mu$ 是恒定的，这意味着漂移速度 $v = \\mu E$ 也是一个正常数。基本电荷 $q$ 是一个基本常数。因此，我们可以将这些常数从导数中提取出来：\n$$\nq \\frac{\\partial n}{\\partial t} + qv \\frac{\\partial n}{\\partial x} = 0\n$$\n两边除以 $q$，表达式简化为关于电荷密度 $n(x,t)$ 的线性平流方程：\n$$\n\\frac{\\partial n}{\\partial t} + v \\frac{\\partial n}{\\partial x} = 0\n$$\n接下来，我们在一个均匀网格上对这个偏微分方程进行离散化，空间步长为 $\\Delta x$，时间步长为 $\\Delta t$，使得 $x_i = i\\,\\Delta x$ 且 $t^m = m\\,\\Delta t$。离散电荷密度记为 $n_i^m \\approx n(x_i, t^m)$。问题指定了数值格式：时间导数由前向欧拉差分近似，空间导数由二阶中心差分近似。\n\n在点 $(x_i, t^m)$ 处，时间导数的前向欧拉近似为：\n$$\n\\frac{\\partial n}{\\partial t} \\bigg|_{i,m} \\approx \\frac{n_i^{m+1} - n_i^m}{\\Delta t}\n$$\n空间导数的二阶中心差分为：\n$$\n\\frac{\\partial n}{\\partial x} \\bigg|_{i,m} \\approx \\frac{n_{i+1}^m - n_{i-1}^m}{2 \\Delta x}\n$$\n将这些离散近似代入平流方程，得到有限差分方程：\n$$\n\\frac{n_i^{m+1} - n_i^m}{\\Delta t} + v \\left( \\frac{n_{i+1}^m - n_{i-1}^m}{2 \\Delta x} \\right) = 0\n$$\n为了推导更新规则，我们求解下一个时间步的电荷密度 $n_i^{m+1}$：\n$$\nn_i^{m+1} = n_i^m - v \\frac{\\Delta t}{2 \\Delta x} (n_{i+1}^m - n_{i-1}^m)\n$$\n这是在任意网格点 $i$ 和时间步 $m$ 上的离散更新的通用表达式。该格式被称为时间前向空间中心（FTCS）方法。\n\n问题要求通过计算从 $t^0=0$ 演化到 $t^1=\\Delta t$ 的第一个时间步之后，在网格索引 $i=0$ 处的更新值来证明对单调性的违反。在更新方程中设 $i=0$ 和 $m=0$，我们得到：\n$$\nn_0^1 = n_0^0 - v \\frac{\\Delta t}{2 \\Delta x} (n_{1}^0 - n_{-1}^0)\n$$\n初始条件以阶跃函数的形式给出：\n- 当 $i \\leq 0$ 时，$n_i^0 = 1$\n- 当 $i \\geq 1$ 时，$n_i^0 = 0$\n\n根据这个初始条件，我们可以确定计算 $n_0^1$ 所需的特定网格点上的值：\n- 对于 $i=0$：$n_0^0 = 1$\n- 对于 $i=1$：$n_1^0 = 0$\n- 对于 $i=-1$：$n_{-1}^0 = 1$\n\n将这些初始值代入 $n_0^1$ 的方程中：\n$$\nn_0^1 = 1 - v \\frac{\\Delta t}{2 \\Delta x} (0 - 1)\n$$\n$$\nn_0^1 = 1 + \\frac{v \\Delta t}{2 \\Delta x}\n$$\n问题将单调性定义为：在一个网格点上的更新解位于其前一时间步相邻点的值域内的性质。该性质的一个推论是，格式不应产生新的极大值或极小值。初始数据中的最大值为 $\\max_i n_i^0 = 1$。经过一个时间步后，在 $i=0$ 处的计算值为 $n_0^1 = 1 + \\frac{v \\Delta t}{2 \\Delta x}$。\n\n鉴于漂移速度 $v>0$ 以及离散化步长 $\\Delta t>0$ 和 $\\Delta x>0$，项 $\\frac{v \\Delta t}{2 \\Delta x}$ 是严格为正的。因此，有\n$$\nn_0^1 > 1\n$$\n这个结果表明，经过一个时间步后，在网格点 $i=0$ 处的电荷密度值大于初始时刻域中任何地方存在的最大值。这种新的、非物理性的最大值的产生被称为过冲（overshoot），它明显违反了单调性原理。\n\n最后的任务是提供一个在 $i=0$ 处的过冲幅度的表达式，其定义为 $n_0^1 - \\max_i n_i^0$。使用推导出的结果：\n$$\n\\text{过冲幅度} = n_0^1 - \\max_i n_i^0 = \\left(1 + \\frac{v \\Delta t}{2 \\Delta x}\\right) - 1\n$$\n这可以简化为：\n$$\n\\text{过冲幅度} = \\frac{v \\Delta t}{2 \\Delta x}\n$$\n这个表达式表示了在给定的格式和初始条件下，经过单个时间步后对单调性违背的程度。",
            "answer": "$$\n\\boxed{\\frac{v \\Delta t}{2 \\Delta x}}\n$$"
        },
        {
            "introduction": "认识到显式格式可能存在不稳定性之后，我们自然会问：如何控制这种不稳定性以获得可靠的解？本练习将指导你根据著名的 Courant-Friedrichs-Lewy (CFL) 条件和扩散稳定性条件，为半导体中的漂移-扩散模型构建一个依赖于网格和局部场强的自适应时间步长选择策略。掌握这项技能对于任何使用显式时间积分方法求解输运方程的工程师和科学家来说都至关重要。",
            "id": "4145368",
            "problem": "您正在使用漂移扩散方程的显式有限体积离散化方法，对半导体器件中的一维瞬态电子输运进行建模。显式时间步进的稳定性由双曲（漂移）部分的 Courant–Friedrichs–Lewy (CFL) 条件和抛物（扩散）部分的 Fourier 型条件共同决定。在欧姆接触附近，电场可能很大，导致高漂移速度，如果时间步长不够小，可能会违反局部稳定性约束。\n\n从电荷守恒和本构关系出发，考虑一维空间中的电子连续性方程：\n$$\n\\frac{\\partial n}{\\partial t} + \\frac{\\partial J_n}{\\partial x} = S,\n$$\n其中 $n$ 是电子密度，$J_n$ 是电子电流密度，$S$ 代表由产生-复合引起的源项。电子的漂移扩散模型写作：\n$$\nJ_n = q n \\mu E + q D \\frac{\\partial n}{\\partial x},\n$$\n其中 $q$ 是元电荷，$\\mu$ 是电子迁移率，$E$ 是电场，$D$ 是电子扩散系数。Einstein 关系式通过温度 $T$ 将 $D$ 和 $\\mu$ 联系起来：\n$$\nD = \\mu \\frac{k_B T}{q},\n$$\n其中 $k_B$ 是 Boltzmann 常数。\n\n对于节点位置为 $\\{x_i\\}$ 的网格上的显式有限体积格式，通过对相邻节点值进行平均，定义边中心的间距 $\\Delta x_i = x_{i+1} - x_i$ 和边中心的电场 $E_i$。通过一个物理上合理的饱和模型定义边 $i$ 上的漂移速度 $v_i$：\n$$\nv_i = \\min\\left(\\mu_0 |E_i|, v_{\\text{sat}}\\right),\n$$\n其中 $\\mu_0$ 是低场迁移率，$v_{\\text{sat}}$ 是饱和速度。边 $i$ 上的局部 Courant 数为：\n$$\nC_i = \\frac{|v_i| \\Delta t}{\\Delta x_i},\n$$\n以及局部 Fourier 数为：\n$$\nF_i = \\frac{D \\Delta t}{\\Delta x_i^2}.\n$$\n为确保显式格式的数值稳定性和准确性，要求在接触区域内的边子集上，$C_i$ 严格小于 $1$，$F_i$ 严格小于 $1/2$。接触区域定义为其中点到任一器件边界的距离在 $w$ 以内的边的集合。\n\n构建一个与网格相关的时间步长选择策略，对于给定的网格 $\\{x_i\\}$、电场分布 $\\{E(x_i)\\}$ 和物理参数 $(\\mu_0, v_{\\text{sat}}, T)$，该策略返回一个以秒为单位的时间步长 $\\Delta t$，此步长在接触区域内强制满足 $C_i < 1$ 并且满足 $F_i < 1/2$。您的策略应基于第一性原理，并且必须仅使用接触区域内的局部网格间距和局部边中心电场。为确保在实现过程中的严格不等式，请使用满足 $0 < C_{\\text{target}} < 1$ 和 $0 < F_{\\text{target}} < 1/2$ 的目标阈值 $C_{\\text{target}}$ 和 $F_{\\text{target}}$。\n\n您的程序必须实现此策略，并为以下每个测试用例计算 $\\Delta t$。在所有情况下，将最终的时间步长以秒为单位表示为浮点数。\n\n使用以下常量：\n- $k_B = 1.380649 \\times 10^{-23}$ (J/K),\n- $q = 1.602176634 \\times 10^{-19}$ (C),\n- $T = 300$ (K),\n- $\\mu_0 = 0.135$ (m$^2$/(V·s)),\n- $v_{\\text{sat}} = 1.0 \\times 10^{5}$ (m/s),\n- $C_{\\text{target}} = 0.95$,\n- $F_{\\text{target}} = 0.45$.\n\n节点上的电场由以下公式定义：\n$$\nE(x) = E_0\\left(\\exp\\left(-\\frac{x}{s}\\right) - \\exp\\left(-\\frac{L-x}{s}\\right)\\right),\n$$\n其中 $L$ 是器件长度，$E_0$ 是特征场幅值，$s$ 是衰减长度。\n\n测试套件：\n1. 正常路径下的均匀网格，接触区附近为中等场强：\n   - $L = 1.0 \\times 10^{-6}$ (m), $N = 101$, $x_i$ 在 $[0, L]$ 上均匀分布,\n   - $E_0 = 1.0 \\times 10^{5}$ (V/m), $s = 1.0 \\times 10^{-7}$ (m),\n   - 接触区宽度 $w = 1.0 \\times 10^{-7}$ (m)。\n2. 接触区附近的高场饱和：\n   - $L = 1.0 \\times 10^{-6}$ (m), $N = 101$, $x_i$ 均匀分布,\n   - $E_0 = 1.0 \\times 10^{7}$ (V/m), $s = 5.0 \\times 10^{-8}$ (m),\n   - $w = 1.0 \\times 10^{-7}$ (m)。\n3. 零场扩散限制情况：\n   - $L = 5.0 \\times 10^{-7}$ (m), $N = 101$, $x_i$ 均匀分布,\n   - $E_0 = 0$ (V/m), $s = 1.0 \\times 10^{-7}$ (m) (当 $E_0=0$ 时未使用),\n   - $w = 5.0 \\times 10^{-8}$ (m)。\n4. 在接触区附近加密的非均匀网格：\n   - $L = 1.0 \\times 10^{-6}$ (m), $N = 101$, $x_i = L \\cdot \\frac{1}{2}\\left(1 - \\cos(\\pi \\xi_i)\\right)$，其中 $\\xi_i$ 在 $[0,1]$ 内均匀分布,\n   - $E_0 = 2.0 \\times 10^{5}$ (V/m), $s = 1.0 \\times 10^{-7}$ (m),\n   - $w = 1.5 \\times 10^{-7}$ (m)。\n5. 具有小接触区宽度的粗网格：\n   - $L = 2.0 \\times 10^{-6}$ (m), $N = 21$, $x_i$ 均匀分布,\n   - $E_0 = 5.0 \\times 10^{4}$ (V/m), $s = 2.0 \\times 10^{-7}$ (m),\n   - $w = 5.0 \\times 10^{-8}$ (m)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），列表中的每个条目是相应测试用例所选的 $\\Delta t$ 值（以秒为单位的浮点数）。",
            "solution": "用户提供的问题被评估为有效。它在科学上基于半导体器件物理和偏微分方程数值分析的原理。该问题是适定的、客观的、自包含的，并且所有参数和条件都已明确定义。\n\n核心任务是确定应用于电子漂移扩散方程的显式时间积分格式的最大允许时间步长 $\\Delta t$。这个时间步长必须在一维半导体器件的指定接触区域内，同时满足两个不同的稳定性判据——一个与载流子漂移（平流）相关，另一个与载流子扩散相关。\n\n电子浓度 $n$ 的控制方程是连续性方程：\n$$\n\\frac{\\partial n}{\\partial t} + \\frac{\\partial J_n}{\\partial x} = S\n$$\n电子电流密度 $J_n$ 由漂移扩散模型给出：\n$$\nJ_n = q n \\mu E + q D \\frac{\\partial n}{\\partial x}\n$$\n此处，$q$ 是元电荷，$\\mu$ 是电子迁移率，$E$ 是电场，$D$ 是电子扩散系数。扩散系数通过 Einstein 关系式在给定温度 $T$ 下与迁移率相关：\n$$\nD = \\mu \\frac{k_B T}{q}\n$$\n为了计算稳定性约束，我们在 Einstein 关系式中使用低场迁移率 $\\mu_0$。扩散系数 $D$ 的恒定值可以使用提供的常量预先计算：\n$k_B = 1.380649 \\times 10^{-23}$ J/K\n$q = 1.602176634 \\times 10^{-19}$ C\n$T = 300$ K\n$\\mu_0 = 0.135$ m$^2$/(V·s)\n\n该数值格式是在一个包含 $N$ 个节点 $\\{x_i\\}_{i=0}^{N-1}$ 和 $N-1$ 条边的网格上使用的有限体积法。对时间步长 $\\Delta t$ 的约束源于漂移项和扩散项的显式离散化，并且必须在位于接触区域内的所有边上得到满足。连接节点 $i$ 和 $i+1$ 的边 $i$，如果其中点 $x_{mid, i} = (x_i + x_{i+1})/2$ 到任一器件边界的距离在 $w$ 以内（即 $x_{mid, i} \\le w$ 或 $x_{mid, i} \\ge L - w$），则定义该边位于接触区域内。\n\n对于接触区域内的每一条边 $i$，必须满足两个局部稳定性判据。\n\n1.  **针对漂移的 Courant–Friedrichs–Lewy (CFL) 条件：** Courant 数 $C_i$ 将漂移速度与时间步长和网格间距关联起来。条件是 $C_i < 1$。为确保鲁棒性，使用了一个更严格的目标值 $C_{\\text{target}} = 0.95$。\n    $$\n    C_i = \\frac{|v_i| \\Delta t}{\\Delta x_i} \\le C_{\\text{target}}\n    $$\n    这里，$\\Delta x_i = x_{i+1} - x_i$ 是边 $i$ 的间距。边中心漂移速度 $v_i$ 由边中心电场 $E_i$ 和给定的饱和模型确定：$v_i = \\min(\\mu_0 |E_i|, v_{\\text{sat}})$。电场 $E_i$ 是节点电场的平均值：$E_i = (E(x_i) + E(x_{i+1})) / 2$。\n    这个不等式为每条边 $i$ 上的 $\\Delta t$ 施加了一个上界：\n    $$\n    \\Delta t \\le \\frac{C_{\\text{target}} \\Delta x_i}{|v_i|}\n    $$\n    该条件必须对接触区域中的所有边都成立。因此，由漂移限制的时间步长 $\\Delta t_{\\text{drift}}$ 是所有相关边上这些上界的最小值：\n    $$\n    \\Delta t_{\\text{drift}} = \\min_{i \\in \\text{contacts}} \\left( \\frac{C_{\\text{target}} \\Delta x_i}{|v_i|} \\right)\n    $$\n    如果电场为零，则 $v_i = 0$，此约束失效（允许无限大的 $\\Delta t$）。\n\n2.  **针对扩散的 Fourier 型条件：** Fourier 数 $F_i$ 将跨越一个网格单元的扩散时间尺度与时间步长关联起来。条件是 $F_i < 1/2$，为此使用了一个更严格的目标值 $F_{\\text{target}} = 0.45$。\n    $$\n    F_i = \\frac{D \\Delta t}{\\Delta x_i^2} \\le F_{\\text{target}}\n    $$\n    这个不等式为 $\\Delta t$ 施加了另一个上界：\n    $$\n    \\Delta t \\le \\frac{F_{\\text{target}} \\Delta x_i^2}{D}\n    $$\n    与漂移情况类似，该条件必须对接触区域中的所有边都成立，从而得到一个由扩散限制的时间步长 $\\Delta t_{\\text{diff}}$：\n    $$\n    \\Delta t_{\\text{diff}} = \\min_{i \\in \\text{contacts}} \\left( \\frac{F_{\\text{target}} \\Delta x_i^2}{D} \\right)\n    $$\n\n**总体时间步长策略：**\n为确保稳定性，所选的时间步长 $\\Delta t$ 必须在所有相关边上同时满足漂移和扩散约束。这意味着 $\\Delta t$ 必须小于或等于 $\\Delta t_{\\text{drift}}$ 和 $\\Delta t_{\\text{diff}}$。为了获得最大可能的稳定时间步长，我们选择这两个上界中的最小值：\n$$\n\\Delta t = \\min(\\Delta t_{\\text{drift}}, \\Delta t_{\\text{diff}})\n$$\n\n**算法：**\n对于每个测试用例：\n1.  定义物理参数（$L, N, E_0, s, w$）并根据指定规则（均匀或非均匀）生成节点网格 $\\{x_i\\}_{i=0}^{N-1}$。\n2.  将由漂移引起的最小时间步长 $\\Delta t_{\\text{drift}}$ 和由扩散引起的最小时间步长 $\\Delta t_{\\text{diff}}$ 初始化为正无穷大。\n3.  遍历从 $0$ 到 $N-2$ 的所有边 $i$。\n4.  对每条边，计算其中点 $x_{mid, i} = (x_i + x_{i+1})/2$。\n5.  检查该边是否位于接触区域内：$x_{mid, i} \\le w$ 或 $x_{mid, i} \\ge L - w$。\n6.  如果该边在接触区域内：\n    a. 计算局部网格间距 $\\Delta x_i = x_{i+1} - x_i$。\n    b. 使用提供的 $E(x)$ 公式计算节点电场 $E(x_i)$ 和 $E(x_{i+1})$。\n    c. 计算边中心电场 $E_i = (E(x_i) + E(x_{i+1})) / 2$。\n    d. 确定边中心漂移速度 $v_i = \\min(\\mu_0 |E_i|, v_{\\text{sat}})$。\n    e. 如果 $v_i > 0$，计算局部漂移时间步长限制 $\\Delta t_{\\text{local, drift}} = (C_{\\text{target}} \\Delta x_i) / v_i$ 并更新 $\\Delta t_{\\text{drift}} = \\min(\\Delta t_{\\text{drift}}, \\Delta t_{\\text{local, drift}})$。\n    f. 计算局部扩散时间步长限制 $\\Delta t_{\\text{local, diff}} = (F_{\\text{target}} \\Delta x_i^2) / D$ 并更新 $\\Delta t_{\\text{diff}} = \\min(\\Delta t_{\\text{diff}}, \\Delta t_{\\text{local, diff}})$。\n7.  检查完所有边后，该测试用例的最终时间步长为 $\\Delta t = \\min(\\Delta t_{\\text{drift}}, \\Delta t_{\\text{diff}})$。\n对测试套件中的所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define physical and numerical constants\n    KB = 1.380649e-23  # Boltzmann's constant in J/K\n    Q = 1.602176634e-19 # Elementary charge in C\n    T = 300.0           # Temperature in K\n    MU0 = 0.135         # Low-field mobility in m^2/(V.s)\n    V_SAT = 1.0e5       # Saturation velocity in m/s\n    C_TARGET = 0.95\n    F_TARGET = 0.45\n\n    # Calculate electron diffusivity D from the Einstein relation\n    # D = mu * (kB * T / q)\n    D = MU0 * (KB * T / Q)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy-path uniform mesh with moderate fields\n        {'L': 1.0e-6, 'N': 101, 'mesh_type': 'uniform', 'E0': 1.0e5, 's': 1.0e-7, 'w': 1.0e-7},\n        # 2. High-field saturation near contacts\n        {'L': 1.0e-6, 'N': 101, 'mesh_type': 'uniform', 'E0': 1.0e7, 's': 5.0e-8, 'w': 1.0e-7},\n        # 3. Zero-field diffusion-limited case\n        {'L': 5.0e-7, 'N': 101, 'mesh_type': 'uniform', 'E0': 0.0, 's': 1.0e-7, 'w': 5.0e-8},\n        # 4. Non-uniform mesh clustered near contacts\n        {'L': 1.0e-6, 'N': 101, 'mesh_type': 'cosine', 'E0': 2.0e5, 's': 1.0e-7, 'w': 1.5e-7},\n        # 5. Coarse mesh with small contact width\n        {'L': 2.0e-6, 'N': 21, 'mesh_type': 'uniform', 'E0': 5.0e4, 's': 2.0e-7, 'w': 5.0e-8},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        mesh_type = case['mesh_type']\n        E0 = case['E0']\n        s = case['s']\n        w = case['w']\n\n        # Generate the mesh nodes {x_i}\n        if mesh_type == 'uniform':\n            x_nodes = np.linspace(0.0, L, N)\n        elif mesh_type == 'cosine':\n            xi = np.linspace(0.0, 1.0, N)\n            x_nodes = L * 0.5 * (1.0 - np.cos(np.pi * xi))\n        else:\n            raise ValueError(f\"Unknown mesh type: {mesh_type}\")\n\n        # Electric field function E(x)\n        def E_field(x):\n            if E0 == 0:\n                return 0.0\n            return E0 * (np.exp(-x / s) - np.exp(-(L - x) / s))\n\n        # Initialize overall time step limits for drift and diffusion\n        dt_drift_min = float('inf')\n        dt_diff_min = float('inf')\n\n        # Iterate through all edges i from 0 to N-2\n        for i in range(N - 1):\n            x_i = x_nodes[i]\n            x_i_plus_1 = x_nodes[i+1]\n            \n            # Calculate edge midpoint\n            x_mid = (x_i + x_i_plus_1) / 2.0\n            \n            # Check if the edge is in a contact region\n            is_in_contact = (x_mid = w) or (x_mid >= L - w)\n\n            if is_in_contact:\n                # Calculate edge spacing\n                dx_i = x_i_plus_1 - x_i\n                \n                # Calculate local diffusion time step limit\n                # dt = F_target * dx^2 / D\n                local_dt_diff = F_TARGET * (dx_i**2) / D\n                dt_diff_min = min(dt_diff_min, local_dt_diff)\n                \n                # Calculate local drift time step limit\n                # Calculate edge-centered electric field\n                E_i = (E_field(x_i) + E_field(x_i_plus_1)) / 2.0\n                \n                # Calculate drift velocity with saturation\n                v_i = min(MU0 * abs(E_i), V_SAT)\n                \n                if v_i > 1e-12: # Avoid division by zero in zero-field case\n                    # dt = C_target * dx / v\n                    local_dt_drift = C_TARGET * dx_i / v_i\n                    dt_drift_min = min(dt_drift_min, local_dt_drift)\n\n        # The final time step is the minimum of the two constraints\n        final_dt = min(dt_drift_min, dt_diff_min)\n        results.append(final_dt)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在半导体器件建模中，我们常会遇到所谓的“刚性”问题，例如p-n结附近载流子浓度在极小空间尺度内发生数个数量级的剧变。在这种情况下，简单地控制时间步长已不足够，我们需要设计在空间上就具有内在稳定性的离散格式。本练习将介绍解决这一挑战的基石——Scharfetter-Gummel (SG) 离散格式，并要求你亲手实现它，以验证其在保证解的物理正确性（如载流子浓度为正且满足离散极值原理）方面的卓越能力。",
            "id": "4145374",
            "problem": "考虑一维稳态载流子在陡峭半导体 $p$-$n$ 结上的输运。使用包含爱因斯坦关系的漂移扩散（Drift-Diffusion, DD）模型，并假定无量纲变量，其中静电势 $\\,\\psi(x)\\,$ 已以热电压为单位给出，载流子密度已通过本征载流子密度进行归一化。求解域为 $[0,1]$，使用在结区 $x = 0.5$ 附近加密的非均匀网格。您必须在非均匀网格上使用 Scharfetter–Gummel (SG) 通量对连续性方程进行离散化，并验证数值稳定性、收敛性和准确性，具体表现为解的正性以及无非物理下冲或过冲现象。\n\n基本和建模假设：\n- 电子和空穴的稳态连续性方程分别为 $\\,\\partial_x J_n = 0\\,$ 和 $\\,\\partial_x J_p = 0\\,$。\n- 漂移扩散（DD）通量为 $\\,J_n = -D_n \\left(\\partial_x n - n \\,\\partial_x \\psi\\right)\\,$ 和 $\\,J_p = -D_p \\left(\\partial_x p + p \\,\\partial_x \\psi\\right)\\,$。\n- 爱因斯坦关系意味着 $\\,D_n = \\mu_n V_T\\,$ 和 $\\,D_p = \\mu_p V_T\\,$；在所选的无量纲单位中，设 $\\,D_n = D_p = 1\\,$。\n- 在长度为 $\\,h_{i+\\frac{1}{2}} = x_{i+1}-x_i\\,$、电势降为 $\\,\\Delta\\psi_{i+\\frac{1}{2}} = \\psi_{i+1} - \\psi_i\\,$ 的边 $[x_i,x_{i+1}]$ 上的 Scharfetter–Gummel (SG) 数值通量使用伯努利函数 $\\,B(\\xi) = \\xi/(e^\\xi - 1)\\,$，并约定 $\\,B(0)=1\\,$。\n- 离散的 SG 通量为\n$$\nJ_{n,i+\\frac{1}{2}} = -\\frac{1}{h_{i+\\frac{1}{2}}}\\left[n_{i+1} B(\\Delta\\psi_{i+\\frac{1}{2}}) - n_i B(-\\Delta\\psi_{i+\\frac{1}{2}})\\right],\n\\quad\nJ_{p,i+\\frac{1}{2}} = -\\frac{1}{h_{i+\\frac{1}{2}}}\\left[p_{i+1} B(-\\Delta\\psi_{i+\\frac{1}{2}}) - p_i B(\\Delta\\psi_{i+\\frac{1}{2}})\\right].\n$$\n- 稳态意味着 $\\,J_{n,i+\\frac{1}{2}} = J_{n,i-\\frac{1}{2}}\\,$ 和 $\\,J_{p,i+\\frac{1}{2}} = J_{p,i-\\frac{1}{2}}\\,$，当在接触点施加狄利克雷（Dirichlet）边界条件时，这将为 $\\,\\{n_i\\}\\,$ 和 $\\,\\{p_i\\}\\,$ 产生一个线性系统。\n\n给定一个旨在模拟陡峭 $p$-$n$ 结的无量纲静电势分布：\n$$\n\\psi(x) = \\frac{\\Delta\\psi}{2}\\,\\tanh\\left(\\frac{x - x_j}{w}\\right),\n$$\n其中 $\\,\\Delta\\psi\\,$ 控制总电势降，$\\,x_j = 0.5\\,$ 是结中心，$\\,w\\,$ 控制过渡区宽度。\n\n在 $\\,x=0\\,$ 和 $\\,x=1\\,$ 处载流子的边界条件（狄利克雷）指定为 $\\,n(0)=n_L\\,$, $\\,n(1)=n_R\\,$, $\\,p(0)=p_L\\,$, $\\,p(1)=p_R\\,$，其选择应符合物理实际（例如，在归一化单位下，$\\,n_L p_L = 1\\,$ 和 $\\,n_R p_R = 1\\,$）。\n\n您的任务：\n1. 构建在 $\\,x=0.5\\,$ 附近加密的非均匀网格。使用从均匀计算坐标 $\\,\\xi \\in [0,1]\\,$ 到物理坐标 $\\,x\\,$ 的平滑对称映射，定义如下：\n$$\nx(\\xi) = \\frac{1}{2} + \\frac{1}{2}\\,\\frac{\\sinh\\!\\big(\\beta(\\xi-\\frac{1}{2})\\big)}{\\sinh\\!\\big(\\frac{\\beta}{2}\\big)},\n$$\n其中 $\\,\\beta \\ge 0\\,$ 控制在 $\\,x=0.5\\,$ 附近的聚集程度。对于 $\\,\\beta=0\\,$，默认为均匀网格。\n\n2. 在所构建的非均匀网格上，为电子和空穴实现 Scharfetter–Gummel 离散化。根据给定的狄利克雷边界条件，组装并求解所得到的三对角线性系统，以获得网格节点上的 $\\,\\{n_i\\}\\,$ 和 $\\,\\{p_i\\}\\,$。\n\n3. 使用离散极值原理验证解的正性以及无非物理下冲或过冲现象：对于每种载流子，检查所有节点值是否严格为正，并且位于由边界值确定的闭区间内。也就是说，对于载流子 $\\,c \\in \\{n,p\\}\\,$，其边界值为 $\\,c_L\\,$ 和 $\\,c_R\\,$，验证：\n$$\n\\min_i c_i \\ge \\min(c_L, c_R), \\quad \\max_i c_i \\le \\max(c_L, c_R), \\quad \\text{and} \\quad \\min_i c_i  0.\n$$\n\n4. 在中等 $\\,\\Delta\\psi\\,$ 条件下，通过网格加密来验证电子解的收敛性。通过计算较粗网格解相对于一个非常精细的参考网格解的 $\\,\\ell_\\infty\\,$ 误差来实现，使用线性插值来比较不同网格上的解。确认随着网格的加密，误差会减小。\n\n数值稳定性要求：\n- 以数值稳定的方式计算伯努利函数 $\\,B(\\xi)\\,$：对于小的 $\\,|\\xi|\\,$，使用合适的级数展开；对于大的 $\\,|\\xi|\\,$，使用稳定的指数函数计算（例如，使用 $\\,\\mathrm{expm1}\\,$ 以避免灾难性抵消）。\n\n测试套件：\n提供并解决以下四个测试案例，并将结果按如下规定汇总到单行输出中。\n\n- 案例 A（常规路径，陡峭但可控）：$\\,\\Delta\\psi = 40\\,$, $\\,w = 0.02\\,$, $\\,\\beta = 6\\,$, $\\,N = 201\\,$ 个节点。边界值：$\\,n_L = 10^4\\,$, $\\,n_R = 10^{-4}\\,$, $\\,p_L = 10^{-4}\\,$, $\\,p_R = 10^4\\,$。输出一个布尔值，如果电子和空穴的解都满足正性和离散极值原理界限，则为真。\n\n- 案例 B（边缘案例，极度陡峭）：$\\,\\Delta\\psi = 80\\,$, $\\,w = 0.01\\,$, $\\,\\beta = 6\\,$, $\\,N = 101\\,$ 个节点。边界值：$\\,n_L = 10^6\\,$, $\\,n_R = 10^{-6}\\,$, $\\,p_L = 10^{-6}\\,$, $\\,p_R = 10^6\\,$。输出一个布尔值，如果电子和空穴的解都满足正性和离散极值原理界限，则为真。\n\n- 案例 C（边界条件检查，平场）：$\\,\\Delta\\psi = 0\\,$, $\\,w = 0.05\\,$, $\\,\\beta = 0\\,$, $\\,N = 51\\,$ 个节点。边界值：$\\,n_L = 10^3\\,$, $\\,n_R = 10^{-2}\\,$, $\\,p_L = 10^{-2}\\,$, $\\,p_R = 10^3\\,$。输出一个布尔值，如果电子和空穴的解都满足正性和离散极值原理界限，则为真。\n\n- 案例 D（网格加密下的收敛性，中等场强）：$\\,\\Delta\\psi = 20\\,$, $\\,w = 0.05\\,$, $\\,\\beta = 4\\,$。考虑三个网格，分别有 $\\,N_1=51\\,$, $\\,N_2=101\\,$ 和 $\\,N_3=401\\,$ 个节点。边界值：$\\,n_L = 10^3\\,$, $\\,n_R = 10^{-1}\\,$。在所有三个网格上计算电子解，并使用最精细的网格 $\\,N_3\\,$ 作为参考。将粗网格和中等网格的解插值到精细网格上，并计算 $\\,\\ell_\\infty\\,$ 误差 $\\,E_{1\\to 3}\\,$ 和 $\\,E_{2\\to 3}\\,$。输出一个布尔值，如果 $\\,E_{1\\to 3}  E_{2\\to 3}\\,$，则为真，表示误差随着网格加密单调减小。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按 $[A,B,C,D]$ 顺序排列的结果，形式为方括号内的逗号分隔列表。每个元素是对应案例的布尔结果，如上所述。例如：“[True,True,True,True]”。不应打印任何额外文本。",
            "solution": "用户提供了一个来自计算半导体器件建模领域的科学上合理且适定的问题。该问题要求在一维非均匀网格上实现并验证用于稳态漂移扩散方程的 Scharfetter-Gummel (SG) 离散化方案。\n\n验证步骤确认所有必要组件均已提供，包括控制方程、边界条件、离散化公式、网格生成函数、电势分布以及用于验证数值稳定性和收敛性的特定测试案例。该问题基于成熟的物理和数值原理，其任务是客观且可验证的。因此，我将继续提供完整解决方案。\n\n解决方案的方法论包括以下步骤：\n1.  **伯努利函数**：伯努利函数 $B(\\xi) = \\xi / (e^\\xi - 1)$ 的数值稳定实现至关重要。对于小的 $|\\xi|$，使用泰勒级数展开以防止灾难性抵消。对于较大的值，标准的浮点数运算，辅以 `numpy.expm1` 以提高精度，已经足够。恒等式 $B(-\\xi) = B(\\xi) + \\xi$ 也是 SG 方案的基础。\n2.  **网格生成**：创建一个函数，使用指定的映射 $x(\\xi) = \\frac{1}{2} + \\frac{1}{2} \\sinh(\\beta(\\xi-1/2)) / \\sinh(\\beta/2)$ 从均匀计算网格 $\\xi$ 生成非均匀物理网格 $x$。处理了 $\\beta=0$ 产生均匀网格的特殊情况。\n3.  **系统组装**：解决方案的核心是为每种载流子类型 $c \\in \\{n, p\\}$ 离散化连续性方程 $\\partial_x J_c = 0$。在每个内部网格节点 $x_i$（对于 $i=1, \\dots, N-2$）应用 SG 通量守恒条件 $J_{c, i-1/2} = J_{c, i+1/2}$，会得到一个关联载流子浓度 $c_{i-1}$、$c_i$ 和 $c_{i+1}$ 的线性方程。这为内部节点上的未知浓度产生一个三对角线性方程组。\n    对于电子 ($n$)，节点 $i$ 处的方程是：\n    $$ \\frac{B(-\\Delta\\psi_{i-1/2})}{h_{i-1/2}} n_{i-1} - \\left(\\frac{B(\\Delta\\psi_{i-1/2})}{h_{i-1/2}} + \\frac{B(-\\Delta\\psi_{i+1/2})}{h_{i+1/2}}\\right) n_i + \\frac{B(\\Delta\\psi_{i+1/2})}{h_{i+1/2}} n_{i+1} = 0 $$\n    对于空穴 ($p$)，方程是类似的，只是 $B(\\Delta\\psi)$ 和 $B(-\\Delta\\psi)$ 相互交换。\n4.  **系统求解**：所得到的 $(N-2) \\times (N-2)$ 三对角系统形式为 $A\\mathbf{c} = \\mathbf{b}$，其中向量 $\\mathbf{b}$ 包含了狄利克雷边界条件。该系统使用 `scipy.linalg.solve_banded` 高效求解，该函数非常适合此类矩阵。\n5.  **验证**：\n    - **极值原理**：对于案例 A、B 和 C，电子和空穴的数值解 $\\{c_i\\}$ 均会根据离散极值原理进行检查。对于无源问题，SG 方案的一个关键特性是其解应受其边界值的限制。我们验证对于所有 $i$，$\\min(c_L, c_R) \\le c_i \\le \\max(c_L, c_R)$，并且所有浓度均为正值，$c_i  0$。\n    - **收敛性**：对于案例 D，电子浓度在三个逐渐加密的网格上计算。来自较粗网格的解被插值到最精细的网格上。相对于精细网格的参考解，计算误差的 $\\ell_\\infty$ 范数 $\\|\\mathbf{n}_{\\text{coarse}} - \\mathbf{n}_{\\text{ref}}\\|_\\infty$。通过检查误差是否随着网格分辨率的提高而减小来验证收敛性。\n\n该实现将组织成一个主 `solve()` 函数，该函数为四个指定的测试案例分别执行这些步骤，并按要求格式化最终的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef bernoulli(x):\n    \"\"\"\n    Numerically stable implementation of the Bernoulli function B(x) = x / (exp(x) - 1).\n    \"\"\"\n    x = np.asarray(x)\n    res = np.zeros_like(x, dtype=float)\n    \n    # Use Taylor series for small |x| to avoid catastrophic cancellation.\n    # B(x) approx 1 - x/2 + x^2/12 - x^4/720\n    small_mask = np.abs(x)  1e-4\n    x_small = x[small_mask]\n    res[small_mask] = 1.0 - x_small/2.0 + x_small**2/12.0 - x_small**4/720.0\n    \n    # Use standard formula for non-small x, with np.expm1 for precision.\n    large_mask = ~small_mask\n    x_large = x[large_mask]\n    res[large_mask] = x_large / np.expm1(x_large)\n    \n    return res\n\ndef generate_mesh(N, beta):\n    \"\"\"\n    Generates a 1D physical mesh x on [0, 1] with N points.\n    beta controls the clustering of points around x=0.5.\n    beta=0 gives a uniform mesh.\n    \"\"\"\n    xi = np.linspace(0.0, 1.0, N)\n    if beta == 0:\n        return xi\n    else:\n        # Prevent potential overflow with very large beta, though sinh ratio is stable.\n        numerator = np.sinh(beta * (xi - 0.5))\n        denominator = np.sinh(beta / 2.0)\n        x = 0.5 + 0.5 * numerator / denominator\n        return x\n\ndef get_potential_profile(x, d_psi, w):\n    \"\"\"\n    Calculates the electrostatic potential profile psi(x).\n    \"\"\"\n    x_j = 0.5\n    return (d_psi / 2.0) * np.tanh((x - x_j) / w)\n\ndef solve_carrier(carrier_type, x, psi, c_L, c_R):\n    \"\"\"\n    Solves the 1D steady-state drift-diffusion equation using\n    Scharfetter-Gummel discretization for a given carrier type ('n' or 'p').\n    \"\"\"\n    N = len(x)\n    M = N - 2  # Number of interior points (unknowns)\n\n    if M = 0:\n        # Handle cases with N=1 or N=2. The solution is just the boundary conditions.\n        if N == 1:\n            return np.array([c_L]) # Or some average, but let's stick to BCs if applicable\n        return np.array([c_L, c_R])\n\n    h = np.diff(x)      # h_{i+1/2}\n    d_psi = np.diff(psi) # psi_{i+1} - psi_i\n\n    # Pre-compute flux coefficients\n    g_p = bernoulli(d_psi) / h\n    g_m = bernoulli(-d_psi) / h\n\n    # Assemble the banded matrix A for the system A*c = b\n    # ab is a (3, M) array for scipy.linalg.solve_banded\n    ab = np.zeros((3, M))\n    rhs = np.zeros(M)\n    \n    if carrier_type == 'n':\n        # For electrons\n        ab[0, 1:] = g_p[1:M]                # Upper diagonal\n        ab[1, :] = -(g_p[:M] + g_m[1:M+1])  # Main diagonal\n        ab[2, :-1] = g_m[1:M]               # Lower diagonal\n        rhs[0] = -g_m[0] * c_L\n        rhs[-1] = -g_p[M] * c_R\n    elif carrier_type == 'p':\n        # For holes\n        ab[0, 1:] = g_m[1:M]                # Upper diagonal\n        ab[1, :] = -(g_m[:M] + g_p[1:M+1])  # Main diagonal\n        ab[2, :-1] = g_p[1:M]               # Lower diagonal\n        rhs[0] = -g_p[0] * c_L\n        rhs[-1] = -g_m[M] * c_R\n    else:\n        raise ValueError(\"carrier_type must be 'n' or 'p'\")\n\n    # Solve the tridiagonal system for interior nodes\n    c_internal = solve_banded((1, 1), ab, rhs)\n\n    # Combine with boundary values to form the full solution\n    c_sol = np.concatenate(([c_L], c_internal, [c_R]))\n    \n    return c_sol\n\ndef check_max_principle(c_sol, c_L, c_R):\n    \"\"\"\n    Verifies positivity and the discrete maximum principle bounds.\n    \"\"\"\n    c_min_bound = min(c_L, c_R)\n    c_max_bound = max(c_L, c_R)\n    \n    # All values must be strictly positive\n    positivity_ok = np.all(c_sol > 0)\n    \n    # All values must lie within the bounds set by the BCs\n    min_val = np.min(c_sol)\n    max_val = np.max(c_sol)\n    \n    # Use a small tolerance for floating point comparisons\n    tol = 1e-9\n    bounds_ok = (min_val >= c_min_bound - tol) and (max_val = c_max_bound + tol)\n    \n    return positivity_ok and bounds_ok\n\ndef run_case_A():\n    params = {'d_psi': 40.0, 'w': 0.02, 'beta': 6.0, 'N': 201}\n    bcs = {'n_L': 1e4, 'n_R': 1e-4, 'p_L': 1e-4, 'p_R': 1e4}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n\ndef run_case_B():\n    params = {'d_psi': 80.0, 'w': 0.01, 'beta': 6.0, 'N': 101}\n    bcs = {'n_L': 1e6, 'n_R': 1e-6, 'p_L': 1e-6, 'p_R': 1e6}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n\ndef run_case_C():\n    params = {'d_psi': 0.0, 'w': 0.05, 'beta': 0.0, 'N': 51}\n    bcs = {'n_L': 1e3, 'n_R': 1e-2, 'p_L': 1e-2, 'p_R': 1e3}\n    \n    x = generate_mesh(params['N'], params['beta'])\n    psi = get_potential_profile(x, params['d_psi'], params['w'])\n    \n    n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n    p_sol = solve_carrier('p', x, psi, bcs['p_L'], bcs['p_R'])\n    \n    n_ok = check_max_principle(n_sol, bcs['n_L'], bcs['n_R'])\n    p_ok = check_max_principle(p_sol, bcs['p_L'], bcs['p_R'])\n    \n    return n_ok and p_ok\n    \ndef run_case_D():\n    params = {'d_psi': 20.0, 'w': 0.05, 'beta': 4.0}\n    bcs = {'n_L': 1e3, 'n_R': 1e-1}\n    Ns = [51, 101, 401]\n    \n    # Solve on three grids\n    solutions = []\n    for N in Ns:\n        x = generate_mesh(N, params['beta'])\n        psi = get_potential_profile(x, params['d_psi'], params['w'])\n        n_sol = solve_carrier('n', x, psi, bcs['n_L'], bcs['n_R'])\n        solutions.append((x, n_sol))\n    \n    (x1, n1), (x2, n2), (x3, n3) = solutions\n    \n    # Interpolate coarse solutions onto the fine grid\n    n1_interp = np.interp(x3, x1, n1)\n    n2_interp = np.interp(x3, x2, n2)\n    \n    # Compute L-infinity errors\n    E_1_to_3 = np.max(np.abs(n1_interp - n3))\n    E_2_to_3 = np.max(np.abs(n2_interp - n3))\n    \n    # Check for error reduction\n    return E_1_to_3 > E_2_to_3\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    results = [\n        run_case_A(),\n        run_case_B(),\n        run_case_C(),\n        run_case_D()\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}