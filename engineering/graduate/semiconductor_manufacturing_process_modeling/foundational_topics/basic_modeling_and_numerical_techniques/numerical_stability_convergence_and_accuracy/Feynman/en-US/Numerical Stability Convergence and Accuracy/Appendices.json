{
    "hands_on_practices": [
        {
            "introduction": "Many phenomena in semiconductor process modeling, from chemical reactions to defect kinetics, are described by systems of ordinary differential equations (ODEs) that are mathematically \"stiff.\" This exercise provides a concrete, quantitative comparison between an explicit method (RK4) and an implicit method (BDF2) for solving such a system. By calculating the number of time steps each method requires to meet both stability and accuracy goals, you will gain first-hand insight into why implicit methods are often essential for efficiently simulating stiff problems, where the stability constraint of an explicit method can be far more demanding than its accuracy requirement .",
            "id": "4145395",
            "problem": "Consider the fraction of electrically active dopants $a(t)$ during an isothermal anneal in semiconductor manufacturing. A widely used first-order kinetic model posits that activation and deactivation proceed via thermally activated reactions, yielding the linear ordinary differential equation\n$$\n\\frac{da}{dt} = k_{\\mathrm{on}}(T)\\,\\big(a_{\\mathrm{eq}} - a(t)\\big) - k_{\\mathrm{off}}(T)\\,a(t),\n$$\nwhere $a(t)$ is dimensionless, $t$ is in seconds, $T$ is in Kelvin, $a_{\\mathrm{eq}}$ is the equilibrium active fraction (dimensionless), and the rate coefficients obey Arrhenius laws\n$$\nk_{\\mathrm{on}}(T) = \\nu_{\\mathrm{on}}\\exp\\!\\left(-\\frac{E_{\\mathrm{on}}}{k_{\\mathrm{B}}T}\\right),\\quad\nk_{\\mathrm{off}}(T) = \\nu_{\\mathrm{off}}\\exp\\!\\left(-\\frac{E_{\\mathrm{off}}}{k_{\\mathrm{B}}T}\\right),\n$$\nwith $\\nu_{\\mathrm{on}}$ and $\\nu_{\\mathrm{off}}$ in $\\mathrm{s}^{-1}$, activation energies $E_{\\mathrm{on}}$ and $E_{\\mathrm{off}}$ in electronvolts, and $k_{\\mathrm{B}}$ the Boltzmann constant in $\\mathrm{eV/K}$. This model is linear with constant coefficients at fixed temperature and has the form\n$$\n\\frac{da}{dt} = c + \\lambda\\, a(t),\n$$\nwhere $\\lambda = -\\big(k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)\\big)$ and $c = k_{\\mathrm{on}}(T)\\,a_{\\mathrm{eq}}$.\n\nYou are to determine, for several parameter sets, the minimal number of uniform time steps needed to reach a final physical time $t_f$ while simultaneously satisfying numerical stability (when applicable) and accuracy constraints for two methods:\n- The classical explicit fourth-order Runge–Kutta method (RK4).\n- The implicit second-order Backward Differentiation Formula (BDF2), started with a single implicit trapezoidal step to maintain second-order accuracy.\n\nUse the following principles:\n- Absolute stability is defined with respect to the linear test equation $y'=\\lambda y$ and step size $h$ by requiring that the method’s amplification factor $R(h\\lambda)$ satisfy $\\lvert R(h\\lambda)\\rvert \\le 1$. Enforce this condition for the explicit method on the linearized model with constant $\\lambda$ as defined above. The implicit BDF2 method with the stated startup is to be treated according to its absolute stability properties for $\\operatorname{Re}(\\lambda)<0$.\n- Accuracy is enforced by requiring the absolute global error at $t_f$ to be at most a user-specified tolerance $\\varepsilon$, i.e.,\n$$\n\\lvert a_{\\mathrm{num}}(t_f;h) - a_{\\mathrm{exact}}(t_f)\\rvert \\le \\varepsilon.\n$$\nHere $a_{\\mathrm{num}}(t_f;h)$ is the numerical solution at $t_f$ computed with uniform step size $h=t_f/N$ using the stated method, and $a_{\\mathrm{exact}}(t)$ is the exact solution of the linear model. The method’s startup for BDF2 must be the single-step implicit trapezoidal rule with the same step size $h$ to ensure second-order consistency.\n\nFundamental base and data:\n- Use the Arrhenius law and the linearity of the model as given above. The Boltzmann constant is $k_{\\mathrm{B}}=8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$.\n- The exact solution for the linear inhomogeneous equation with constant coefficients is\n$$\na_{\\mathrm{exact}}(t) = a_{\\infty} + \\big(a_0 - a_{\\infty}\\big)\\,e^{\\lambda t},\\quad a_{\\infty} = -\\frac{c}{\\lambda} = \\frac{k_{\\mathrm{on}}(T)}{k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)}\\,a_{\\mathrm{eq}},\n$$\nwith initial value $a(0)=a_0$.\n\nTask:\n- For each test case below, compute the smallest integer $N_{\\mathrm{RK4}}$ and $N_{\\mathrm{BDF2}}$ such that with $h=t_f/N$:\n  - For explicit RK4: both absolute stability on the linearized model and the accuracy constraint at $t_f$ hold.\n  - For implicit BDF2 (with a single implicit trapezoidal startup step): the accuracy constraint at $t_f$ holds. Treat stability according to the absolute stability of the method for $\\operatorname{Re}(\\lambda)<0$.\n- Your algorithm must determine the minimal $N$ without using any closed-form \"shortcut\" global error constants; you may evaluate numerical solutions and compare against the exact solution. You must rigorously apply the absolute stability definition for the explicit method on the given linear model.\n\nPhysical units:\n- Time $t$ and $t_f$ in seconds, temperature $T$ in Kelvin, activation energies in electronvolts, rates in $\\mathrm{s}^{-1}$.\n- Report $N$ as integers.\n\nTest suite:\n- Case $1$: $T=1000\\,\\mathrm{K}$, $t_f=1.0\\,\\mathrm{s}$, $a_0=0.1$, $a_{\\mathrm{eq}}=0.9$, $\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{on}}=2.1\\,\\mathrm{eV}$, $\\nu_{\\mathrm{off}}=5.0\\times 10^{12}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{off}}=2.4\\,\\mathrm{eV}$, $\\varepsilon=1.0\\times 10^{-6}$.\n- Case $2$: $T=1150\\,\\mathrm{K}$, $t_f=0.1\\,\\mathrm{s}$, $a_0=0.05$, $a_{\\mathrm{eq}}=0.95$, $\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{on}}=2.0\\,\\mathrm{eV}$, $\\nu_{\\mathrm{off}}=8.0\\times 10^{12}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{off}}=2.2\\,\\mathrm{eV}$, $\\varepsilon=1.0\\times 10^{-8}$.\n- Case $3$: $T=850\\,\\mathrm{K}$, $t_f=10.0\\,\\mathrm{s}$, $a_0=0.2$, $a_{\\mathrm{eq}}=0.85$, $\\nu_{\\mathrm{on}}=1.0\\times 10^{13}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{on}}=2.4\\,\\mathrm{eV}$, $\\nu_{\\mathrm{off}}=5.0\\times 10^{12}\\,\\mathrm{s}^{-1}$, $E_{\\mathrm{off}}=2.8\\,\\mathrm{eV}$, $\\varepsilon=1.0\\times 10^{-6}$.\n\nNumerical requirements:\n- Use radians where any angles may appear.\n- All comparisons to the tolerance must be in absolute value (dimensionless).\n- For RK4, enforce absolute stability on the linearized model as defined above at each candidate step size $h$ via its stability function.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets of the form\n$$\n\\big[N_{\\mathrm{RK4}}^{(1)},N_{\\mathrm{BDF2}}^{(1)},N_{\\mathrm{RK4}}^{(2)},N_{\\mathrm{BDF2}}^{(2)},N_{\\mathrm{RK4}}^{(3)},N_{\\mathrm{BDF2}}^{(3)}\\big],\n$$\nwhere the superscript indicates the test case index. The elements must be integers. No additional text or formatting is allowed in the program’s output line.",
            "solution": "The user has provided a problem from the field of numerical analysis, applied to a physical model of dopant activation in semiconductor manufacturing. The task is to determine the minimum number of uniform time steps, $N$, required to solve a linear ordinary differential equation (ODE) up to a final time $t_f$ using two different numerical methods: the explicit fourth-order Runge-Kutta (RK4) method and the implicit second-order Backward Differentiation Formula (BDF2). The determination of $N$ must satisfy method-specific stability constraints and a common accuracy constraint.\n\nThe problem is validated as follows:\n- **Scientific Grounding**: The model is based on standard first-order reaction kinetics and the Arrhenius law, which are fundamental principles in physical chemistry and materials science. The problem is scientifically sound.\n- **Well-Posedness**: The ODE is a linear, first-order initial value problem with constant coefficients. A unique, stable solution is guaranteed. The constraints for numerical stability and accuracy are quantitatively defined. The task of finding the minimal integer $N$ is well-defined.\n- **Objectivity and Completeness**: The problem is stated using precise mathematical language and provides all necessary physical constants, parameters, initial conditions, and numerical tolerances for each test case. There are no ambiguities or subjective statements.\n\nThe problem is deemed valid and a step-by-step solution is constructed.\n\n### Step 1: Model Parameter Calculation\nFor each test case, we first compute the coefficients of the linear ODE, $\\frac{da}{dt} = c + \\lambda a(t)$.\nThe temperature $T$, activation energies $E_{\\mathrm{on}}, E_{\\mathrm{off}}$, and pre-exponential factors $\\nu_{\\mathrm{on}}, \\nu_{\\mathrm{off}}$ are used to calculate the rate coefficients using the Arrhenius equation:\n$$\nk_{\\mathrm{on}}(T) = \\nu_{\\mathrm{on}}\\exp\\!\\left(-\\frac{E_{\\mathrm{on}}}{k_{\\mathrm{B}}T}\\right)\n$$\n$$\nk_{\\mathrm{off}}(T) = \\nu_{\\mathrm{off}}\\exp\\!\\left(-\\frac{E_{\\mathrm{off}}}{k_{\\mathrm{B}}T}\\right)\n$$\nwhere $k_{\\mathrm{B}} = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$.\nThe ODE parameters $\\lambda$ and $c$ are then:\n$$\n\\lambda = -\\big(k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)\\big)\n$$\n$$\nc = k_{\\mathrm{on}}(T)\\,a_{\\mathrm{eq}}\n$$\nSince $k_{\\mathrm{on}}$ and $k_{\\mathrm{off}}$ are always positive, $\\lambda$ is always real and negative.\n\n### Step 2: Exact Solution\nThe exact solution to the linear ODE is necessary to evaluate the accuracy of the numerical methods. Given the initial condition $a(0)=a_0$, the solution is:\n$$\na_{\\mathrm{exact}}(t) = a_{\\infty} + (a_0 - a_{\\infty})e^{\\lambda t}\n$$\nwhere $a_{\\infty}$ is the steady-state solution:\n$$\na_{\\infty} = -\\frac{c}{\\lambda} = \\frac{k_{\\mathrm{on}}(T) a_{\\mathrm{eq}}}{k_{\\mathrm{on}}(T)+k_{\\mathrm{off}}(T)}\n$$\nWe compute the exact value at the final time, $a_{\\mathrm{exact}}(t_f)$, to serve as the reference for the accuracy check: $|\\,a_{\\mathrm{num}}(t_f) - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$.\n\n### Step 3: Minimal Step Count for RK4 ($N_{\\mathrm{RK4}}$)\nThe determination of $N_{\\mathrm{RK4}}$ requires satisfying both a stability and an accuracy constraint. The final number of steps must be the maximum of the number required by each constraint.\n\n**Stability Constraint:**\nThe absolute stability of the RK4 method is governed by its amplification factor $R(z) = \\sum_{k=0}^{4} z^k/k!$ for the test equation $y' = \\lambda y$, where $z = h\\lambda$. For a real negative $\\lambda$, the stability condition $|R(h\\lambda)| \\le 1$ holds for $h\\lambda \\in [-2.78528..., 0]$. This imposes an upper limit on the step size $h = t_f/N$:\n$$\nh \\le \\frac{-2.785281594}{\\lambda}\n$$\nThis translates to a minimum number of steps, $N_{\\mathrm{stab}}$, required for stability:\n$$\nN_{\\mathrm{stab}} = \\left\\lceil \\frac{t_f}{h_{\\mathrm{max}}} \\right\\rceil = \\left\\lceil \\frac{-t_f \\lambda}{2.785281594} \\right\\rceil\n$$\n\n**Accuracy Constraint:**\nTo find the minimum number of steps for accuracy, $N_{\\mathrm{acc}}$, we perform a numerical search. Since we cannot use closed-form error estimates, we must directly simulate the system. We implement a search algorithm that first finds an upper bound for $N$ by doubling it until the accuracy tolerance $\\varepsilon$ is met, and then performs a binary search within the identified range to find the minimal integer $N$ satisfying the condition. For each candidate $N$, a full RK4 simulation is run:\n- Set $h=t_f/N$ and $a_0$.\n- Iterate $N$ times:\n  $$\n  k_1 = f(a_n) \\\\\n  k_2 = f(a_n + \\frac{h}{2}k_1) \\\\\n  k_3 = f(a_n + \\frac{h}{2}k_2) \\\\\n  k_4 = f(a_n + hk_3) \\\\\n  a_{n+1} = a_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n  $$\n- Check if $|\\,a_N - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$.\n\nThe final minimal step count for RK4 is $N_{\\mathrm{RK4}} = \\max(N_{\\mathrm{stab}}, N_{\\mathrm{acc}})$.\n\n### Step 4: Minimal Step Count for BDF2 ($N_{\\mathrm{BDF2}}$)\n\n**Stability Constraint:**\nThe BDF2 method is A-stable, meaning its region of absolute stability contains the entire left half of the complex plane, $\\operatorname{Re}(z) \\le 0$. Since our $\\lambda$ is always real and negative, the method is unconditionally stable for any step size $h>0$. Therefore, stability imposes no restriction on $N$, and $N_{\\mathrm{BDF2}}$ is determined solely by the accuracy requirement.\n\n**Accuracy Constraint:**\nThe BDF2 method is a two-step method, requiring a startup procedure. As specified, we use a single step of the second-order implicit trapezoidal rule to compute $a_1$ from $a_0$.\n- **Startup (Trapezoidal rule):** For the linear ODE, we can solve for $a_1$ explicitly:\n$$\na_1 = a_0 + \\frac{h}{2}\\left( (c+\\lambda a_0) + (c+\\lambda a_1) \\right) \\implies a_1 = \\frac{a_0(1+\\frac{h\\lambda}{2}) + hc}{1-\\frac{h\\lambda}{2}}\n$$\n- **Main loop (BDF2):** For $n \\ge 1$, we compute $a_{n+1}$ using $a_n$ and $a_{n-1}$. For our linear ODE, we can again solve for $a_{n+1}$ explicitly:\n$$\na_{n+1} = \\frac{4}{3}a_n - \\frac{1}{3}a_{n-1} + \\frac{2h}{3}(c+\\lambda a_{n+1}) \\implies a_{n+1} = \\frac{\\frac{4}{3}a_n - \\frac{1}{3}a_{n-1} + \\frac{2hc}{3}}{1-\\frac{2h\\lambda}{3}}\n$$\nThe same search algorithm (exponential increase followed by binary search) is used to find the minimal $N_{\\mathrm{BDF2}}$ that satisfies $|\\,a_N - a_{\\mathrm{exact}}(t_f)\\,| \\le \\varepsilon$.\n\nBy implementing these steps for each test case, we can determine the required integer pairs $(N_{\\mathrm{RK4}}, N_{\\mathrm{BDF2}})$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function to find the minimal number of steps for RK4 and BDF2\n    methods to satisfy stability and accuracy constraints for a given ODE modelling\n    dopant activation in semiconductors.\n    \"\"\"\n    # Boltzmann constant in eV/K\n    KB = 8.617333262145e-5\n    # Stability limit for RK4 on the negative real axis for z = h*lambda\n    RK4_STABILITY_LIMIT = 2.785281594\n\n    def find_min_N(is_accurate_func):\n        \"\"\"\n        Finds the minimum integer N that satisfies the accuracy condition.\n        Uses an exponential increase to find an upper bound, then performs a\n        binary search to find the minimal N.\n        \"\"\"\n        if is_accurate_func(1):\n            return 1\n        \n        # Exponential search for an upper bound\n        n_upper = 2\n        while not is_accurate_func(n_upper):\n            # Safety break to prevent very long searches\n            if n_upper > 2**28: \n                raise RuntimeError(\n                    \"Search for N failed to converge within a reasonable limit.\"\n                )\n            n_upper *= 2\n        \n        # Binary search for the precise minimum N\n        low = n_upper // 2\n        high = n_upper\n        ans = high\n        \n        while low <= high:\n            mid = low + (high - low) // 2\n            if mid == 0:\n                low = 1\n                continue\n            \n            if is_accurate_func(mid):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n\n    test_cases = [\n        # Case 1: T=1000K, tf=1.0s, eps=1e-6\n        (1000.0, 1.0, 0.1, 0.9, 1.0e13, 2.1, 5.0e12, 2.4, 1.0e-6),\n        # Case 2: T=1150K, tf=0.1s, eps=1e-8\n        (1150.0, 0.1, 0.05, 0.95, 1.0e13, 2.0, 8.0e12, 2.2, 1.0e-8),\n        # Case 3: T=850K, tf=10.0s, eps=1e-6\n        (850.0, 10.0, 0.2, 0.85, 1.0e13, 2.4, 5.0e12, 2.8, 1.0e-6),\n    ]\n\n    all_results = []\n\n    for T, tf, a0, a_eq, nu_on, E_on, nu_off, E_off, eps in test_cases:\n        # Step 1: Calculate model parameters\n        k_on = nu_on * np.exp(-E_on / (KB * T))\n        k_off = nu_off * np.exp(-E_off / (KB * T))\n        \n        lam = -(k_on + k_off)\n        c = k_on * a_eq\n        \n        # The ODE right-hand side: da/dt = c + lam * a\n        def f_ode(a):\n            return c + lam * a\n\n        # Step 2: Calculate exact solution\n        if lam == 0:\n            a_exact_tf = a0 + c * tf\n        else:\n            a_inf = -c / lam\n            a_exact_tf = a_inf + (a0 - a_inf) * np.exp(lam * tf)\n\n        # --- Step 3: Find N_RK4 ---\n        \n        # Stability constraint\n        N_stab = math.ceil(-tf * lam / RK4_STABILITY_LIMIT)\n\n        # Accuracy constraint\n        def run_rk4(N):\n            h = tf / N\n            a_num = a0\n            for _ in range(N):\n                k1 = f_ode(a_num)\n                k2 = f_ode(a_num + 0.5 * h * k1)\n                k3 = f_ode(a_num + 0.5 * h * k2)\n                k4 = f_ode(a_num + h * k3)\n                a_num += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            return a_num\n\n        def is_accurate_rk4(N):\n            if N == 0: return False\n            a_num_tf = run_rk4(N)\n            return np.abs(a_num_tf - a_exact_tf) <= eps\n        \n        N_acc_rk4 = find_min_N(is_accurate_rk4)\n        N_rk4 = max(N_stab, N_acc_rk4)\n        all_results.append(N_rk4)\n\n        # --- Step 4: Find N_BDF2 ---\n        \n        # Stability is unconditional (A-stable method)\n        # Accuracy constraint\n        def run_bdf2(N):\n            h = tf / N\n            \n            # First step: Implicit Trapezoidal startup\n            # a1 * (1 - h*lam/2) = a0*(1+h*lam/2) + h*c\n            a_n_minus_1 = a0\n            if N == 1:\n                return (a_n_minus_1 * (1.0 + 0.5 * h * lam) + h * c) / (1.0 - 0.5 * h * lam)\n            \n            a_n = (a_n_minus_1 * (1.0 + 0.5 * h * lam) + h * c) / (1.0 - 0.5 * h * lam)\n\n            # BDF2 steps for n > 1\n            # a_{n+1} * (1 - 2/3 h lam) = 4/3 a_n - 1/3 a_{n-1} + 2/3 h c\n            den = 1.0 - (2.0/3.0) * h * lam\n            for _ in range(1, N): # Loop N-1 times to get to the Nth step\n                num = (4.0/3.0) * a_n - (1.0/3.0) * a_n_minus_1 + (2.0/3.0) * h * c\n                a_n_plus_1 = num / den\n                \n                a_n_minus_1 = a_n\n                a_n = a_n_plus_1\n            return a_n\n\n        def is_accurate_bdf2(N):\n            if N == 0: return False\n            a_num_tf = run_bdf2(N)\n            return np.abs(a_num_tf - a_exact_tf) <= eps\n            \n        N_bdf2 = find_min_N(is_accurate_bdf2)\n        all_results.append(N_bdf2)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from ODEs to the partial differential equations (PDEs) that govern charge transport, this practice addresses the practical challenge of ensuring stability in an explicit finite-volume scheme. The stability of such schemes is not governed by a single number but by local conditions, like the Courant–Friedrichs–Lewy (CFL) and Fourier numbers, which can vary dramatically across the device. This exercise guides you through constructing a time-step selection strategy that respects the most restrictive local constraint, a crucial skill for developing robust simulators for transient phenomena where electric fields and mesh spacings may vary significantly .",
            "id": "4145368",
            "problem": "You are modeling a one-dimensional transient electron transport in a semiconductor device using an explicit finite-volume discretization of the drift–diffusion equations. The stability of the explicit time stepping is governed by the Courant–Friedrichs–Lewy (CFL) condition for the hyperbolic (drift) part and by a Fourier-type condition for the parabolic (diffusion) part. Near ohmic contacts, the electric field can be large, causing high drift velocity and potentially violating local stability constraints if the time step is not sufficiently small.\n\nStarting from the conservation of charge and constitutive relations, consider the electron continuity equation in one spatial dimension:\n$$\n\\frac{\\partial n}{\\partial t} + \\frac{\\partial J_n}{\\partial x} = S,\n$$\nwhere $n$ is the electron density, $J_n$ is the electron current density, and $S$ represents sources due to generation–recombination. The drift–diffusion model for electrons writes\n$$\nJ_n = q n \\mu E + q D \\frac{\\partial n}{\\partial x},\n$$\nwhere $q$ is the elementary charge, $\\mu$ is the electron mobility, $E$ is the electric field, and $D$ is the electron diffusivity. The Einstein relation connects $D$ and $\\mu$ via temperature $T$:\n$$\nD = \\mu \\frac{k_B T}{q},\n$$\nwhere $k_B$ is Boltzmann’s constant.\n\nFor an explicit finite-volume scheme on a mesh with node positions $\\{x_i\\}$, define edge-centered spacings $\\Delta x_i = x_{i+1} - x_i$ and edge-centered electric fields $E_i$ by averaging neighboring nodal values. Define a drift velocity $v_i$ at edge $i$ by a physically plausible saturation model:\n$$\nv_i = \\min\\left(\\mu_0 |E_i|, v_{\\text{sat}}\\right),\n$$\nwhere $\\mu_0$ is the low-field mobility and $v_{\\text{sat}}$ is the saturation velocity. The local Courant number at edge $i$ is\n$$\nC_i = \\frac{|v_i| \\Delta t}{\\Delta x_i},\n$$\nand the local Fourier number is\n$$\nF_i = \\frac{D \\Delta t}{\\Delta x_i^2}.\n$$\nTo ensure numerical stability and accuracy for an explicit scheme, require $C_i$ to be strictly less than $1$ and $F_i$ to be strictly less than $1/2$ on the subset of edges that lie within the contact regions. Let the contact regions be defined as the set of edges whose midpoints fall within a distance $w$ from either device boundary.\n\nConstruct a mesh-dependent time-step selection strategy that, for a given mesh $\\{x_i\\}$, electric field profile $\\{E(x_i)\\}$, and physical parameters $(\\mu_0, v_{\\text{sat}}, T)$, returns a time step $\\Delta t$ in seconds that enforces $C_i < 1$ in the contact regions and also enforces $F_i < 1/2$. Your strategy should be based on first principles and must use only local mesh spacings and local edge-centered fields in the contact regions. To ensure strict inequalities during implementation, use target thresholds $C_{\\text{target}}$ and $F_{\\text{target}}$ satisfying $0 < C_{\\text{target}} < 1$ and $0 < F_{\\text{target}} < 1/2$.\n\nYour program must implement this strategy and compute $\\Delta t$ for each of the following test cases. In all cases, express the final time step in seconds as a floating-point number.\n\nUse the following constants:\n- $k_B = 1.380649 \\times 10^{-23}$ (J/K),\n- $q = 1.602176634 \\times 10^{-19}$ (C),\n- $T = 300$ (K),\n- $\\mu_0 = 0.135$ (m$^2$/(V·s)),\n- $v_{\\text{sat}} = 1.0 \\times 10^{5}$ (m/s),\n- $C_{\\text{target}} = 0.95$,\n- $F_{\\text{target}} = 0.45$.\n\nDefine electric fields at nodes by\n$$\nE(x) = E_0\\left(\\exp\\left(-\\frac{x}{s}\\right) - \\exp\\left(-\\frac{L-x}{s}\\right)\\right),\n$$\nwhere $L$ is the device length, $E_0$ is a characteristic field amplitude, and $s$ is a decay length.\n\nTest Suite:\n1. Happy-path uniform mesh with moderate fields near contacts:\n   - $L = 1.0 \\times 10^{-6}$ (m), $N = 101$, $x_i$ uniformly spaced over $[0, L]$,\n   - $E_0 = 1.0 \\times 10^{5}$ (V/m), $s = 1.0 \\times 10^{-7}$ (m),\n   - contact width $w = 1.0 \\times 10^{-7}$ (m).\n2. High-field saturation near contacts:\n   - $L = 1.0 \\times 10^{-6}$ (m), $N = 101$, $x_i$ uniformly spaced,\n   - $E_0 = 1.0 \\times 10^{7}$ (V/m), $s = 5.0 \\times 10^{-8}$ (m),\n   - $w = 1.0 \\times 10^{-7}$ (m).\n3. Zero-field diffusion-limited case:\n   - $L = 5.0 \\times 10^{-7}$ (m), $N = 101$, $x_i$ uniformly spaced,\n   - $E_0 = 0$ (V/m), $s = 1.0 \\times 10^{-7}$ (m) (unused when $E_0=0$),\n   - $w = 5.0 \\times 10^{-8}$ (m).\n4. Non-uniform mesh clustered near contacts:\n   - $L = 1.0 \\times 10^{-6}$ (m), $N = 101$, $x_i = L \\cdot \\frac{1}{2}\\left(1 - \\cos(\\pi \\xi_i)\\right)$ with $\\xi_i$ uniformly spaced in $[0,1]$,\n   - $E_0 = 2.0 \\times 10^{5}$ (V/m), $s = 1.0 \\times 10^{-7}$ (m),\n   - $w = 1.5 \\times 10^{-7}$ (m).\n5. Coarse mesh with small contact width:\n   - $L = 2.0 \\times 10^{-6}$ (m), $N = 21$, $x_i$ uniformly spaced,\n   - $E_0 = 5.0 \\times 10^{4}$ (V/m), $s = 2.0 \\times 10^{-7}$ (m),\n   - $w = 5.0 \\times 10^{-8}$ (m).\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each entry is the selected $\\Delta t$ for the corresponding test case, in seconds, as floating-point values.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of semiconductor device physics and the numerical analysis of partial differential equations. The problem is well-posed, objective, self-contained, and all parameters and conditions are clearly defined.\n\nThe core task is to determine the maximum permissible time step, $\\Delta t$, for an explicit time-integration scheme applied to the electron drift–diffusion equation. This time step must satisfy two distinct stability criteria simultaneously—one related to carrier drift (advection) and another to carrier diffusion—within specified contact regions of a one-dimensional semiconductor device.\n\nThe governing equation for electron concentration $n$ is the continuity equation:\n$$\n\\frac{\\partial n}{\\partial t} + \\frac{\\partial J_n}{\\partial x} = S\n$$\nThe electron current density, $J_n$, is given by the drift–diffusion model:\n$$\nJ_n = q n \\mu E + q D \\frac{\\partial n}{\\partial x}\n$$\nHere, $q$ is the elementary charge, $\\mu$ is the electron mobility, $E$ is the electric field, and $D$ is the electron diffusivity. The diffusivity is related to mobility via the Einstein relation at a given temperature $T$:\n$$\nD = \\mu \\frac{k_B T}{q}\n$$\nFor the purpose of calculating the stability constraints, we use the low-field mobility, $\\mu_0$, in the Einstein relation. The constant value of diffusivity $D$ can be pre-calculated using the provided constants:\n$k_B = 1.380649 \\times 10^{-23}$ J/K\n$q = 1.602176634 \\times 10^{-19}$ C\n$T = 300$ K\n$\\mu_0 = 0.135$ m$^2$/(V·s)\n\nThe numerical scheme is a finite-volume method on a mesh of $N$ nodes $\\{x_i\\}_{i=0}^{N-1}$ and $N-1$ edges. The constraints on the time step $\\Delta t$ arise from the explicit discretization of the drift and diffusion terms and must be satisfied on all edges located within the contact regions. An edge $i$, connecting nodes $i$ and $i+1$, is defined to be in a contact region if its midpoint, $x_{mid, i} = (x_i + x_{i+1})/2$, falls within a distance $w$ from either device boundary, i.e., if $x_{mid, i} \\le w$ or $x_{mid, i} \\ge L - w$.\n\nFor each such edge $i$ within a contact region, two local stability criteria must be met.\n\n1.  **Courant–Friedrichs–Lewy (CFL) Condition for Drift:** The Courant number, $C_i$, relates the drift velocity to the time step and mesh spacing. The condition is $C_i < 1$. To ensure robustness, a stricter target, $C_{\\text{target}} = 0.95$, is used.\n    $$\n    C_i = \\frac{|v_i| \\Delta t}{\\Delta x_i} < C_{\\text{target}}\n    $$\n    Here, $\\Delta x_i = x_{i+1} - x_i$ is the spacing of edge $i$. The edge-centered drift velocity, $v_i$, is determined by the edge-centered electric field, $E_i$, using the provided saturation model: $v_i = \\min(\\mu_0 |E_i|, v_{\\text{sat}})$. The field $E_i$ is the average of the nodal fields: $E_i = (E(x_i) + E(x_{i+1})) / 2$.\n    This inequality imposes an upper bound on $\\Delta t$ for each edge $i$:\n    $$\n    \\Delta t < \\frac{C_{\\text{target}} \\Delta x_i}{|v_i|}\n    $$\n    This must hold for all edges in the contact regions. Therefore, the drift-limited time step, $\\Delta t_{\\text{drift}}$, is the minimum of these bounds over all relevant edges:\n    $$\n    \\Delta t_{\\text{drift}} = \\min_{i \\in \\text{contacts}} \\left( \\frac{C_{\\text{target}} \\Delta x_i}{|v_i|} \\right)\n    $$\n    If the electric field is zero, then $v_i = 0$, and this constraint becomes non-binding (allowing an infinite $\\Delta t$).\n\n2.  **Fourier-type Condition for Diffusion:** The Fourier number, $F_i$, relates the timescale of diffusion across a mesh cell to the time step. The condition is $F_i < 1/2$, for which a stricter target, $F_{\\text{target}} = 0.45$, is used.\n    $$\n    F_i = \\frac{D \\Delta t}{\\Delta x_i^2} < F_{\\text{target}}\n    $$\n    This inequality imposes another upper bound on $\\Delta t$:\n    $$\n    \\Delta t < \\frac{F_{\\text{target}} \\Delta x_i^2}{D}\n    $$\n    Similar to the drift case, this must hold for all edges in the contact regions, leading to a diffusion-limited time step, $\\Delta t_{\\text{diff}}$:\n    $$\n    \\Delta t_{\\text{diff}} = \\min_{i \\in \\text{contacts}} \\left( \\frac{F_{\\text{target}} \\Delta x_i^2}{D} \\right)\n    $$\n\n**Overall Time Step Strategy:**\nTo ensure stability, the chosen time step $\\Delta t$ must satisfy both the drift and diffusion constraints simultaneously across all relevant edges. This means $\\Delta t$ must be less than or equal to both $\\Delta t_{\\text{drift}}$ and $\\Delta t_{\\text{diff}}$. To obtain the largest possible stable time step, we select the minimum of these two bounds:\n$$\n\\Delta t = \\min(\\Delta t_{\\text{drift}}, \\Delta t_{\\text{diff}})\n$$\n\n**Algorithm:**\nFor each test case:\n1.  Define the physical parameters ($L, N, E_0, s, w$) and generate the nodal mesh $\\{x_i\\}_{i=0}^{N-1}$ according to the specified rule (uniform or non-uniform).\n2.  Initialize the minimum time step due to drift, $\\Delta t_{\\text{drift}}$, and diffusion, $\\Delta t_{\\text{diff}}$, to positive infinity.\n3.  Iterate through all edges $i$ from $0$ to $N-2$.\n4.  For each edge, calculate its midpoint $x_{mid, i} = (x_i + x_{i+1})/2$.\n5.  Check if the edge lies in a contact region: $x_{mid, i} \\le w$ or $x_{mid, i} \\ge L - w$.\n6.  If the edge is in a contact region:\n    a. Calculate the local mesh spacing $\\Delta x_i = x_{i+1} - x_i$.\n    b. Calculate the nodal electric fields $E(x_i)$ and $E(x_{i+1})$ using the provided formula for $E(x)$.\n    c. Compute the edge-centered electric field $E_i = (E(x_i) + E(x_{i+1})) / 2$.\n    d. Determine the edge-centered drift velocity $v_i = \\min(\\mu_0 |E_i|, v_{\\text{sat}})$.\n    e. If $v_i > 0$, calculate the local drift time step limit $\\Delta t_{\\text{local, drift}} = (C_{\\text{target}} \\Delta x_i) / v_i$ and update $\\Delta t_{\\text{drift}} = \\min(\\Delta t_{\\text{drift}}, \\Delta t_{\\text{local, drift}})$.\n    f. Calculate the local diffusion time step limit $\\Delta t_{\\text{local, diff}} = (F_{\\text{target}} \\Delta x_i^2) / D$ and update $\\Delta t_{\\text{diff}} = \\min(\\Delta t_{\\text{diff}}, \\Delta t_{\\text{local, diff}})$.\n7.  After checking all edges, the final time step for the test case is $\\Delta t = \\min(\\Delta t_{\\text{drift}}, \\Delta t_{\\text{diff}})$.\nThis procedure is repeated for all test cases in the suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define physical and numerical constants\n    KB = 1.380649e-23  # Boltzmann's constant in J/K\n    Q = 1.602176634e-19 # Elementary charge in C\n    T = 300.0           # Temperature in K\n    MU0 = 0.135         # Low-field mobility in m^2/(V.s)\n    V_SAT = 1.0e5       # Saturation velocity in m/s\n    C_TARGET = 0.95\n    F_TARGET = 0.45\n\n    # Calculate electron diffusivity D from the Einstein relation\n    # D = mu * (kB * T / q)\n    D = MU0 * (KB * T / Q)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy-path uniform mesh with moderate fields\n        {'L': 1.0e-6, 'N': 101, 'mesh_type': 'uniform', 'E0': 1.0e5, 's': 1.0e-7, 'w': 1.0e-7},\n        # 2. High-field saturation near contacts\n        {'L': 1.0e-6, 'N': 101, 'mesh_type': 'uniform', 'E0': 1.0e7, 's': 5.0e-8, 'w': 1.0e-7},\n        # 3. Zero-field diffusion-limited case\n        {'L': 5.0e-7, 'N': 101, 'mesh_type': 'uniform', 'E0': 0.0, 's': 1.0e-7, 'w': 5.0e-8},\n        # 4. Non-uniform mesh clustered near contacts\n        {'L': 1.0e-6, 'N': 101, 'mesh_type': 'cosine', 'E0': 2.0e5, 's': 1.0e-7, 'w': 1.5e-7},\n        # 5. Coarse mesh with small contact width\n        {'L': 2.0e-6, 'N': 21, 'mesh_type': 'uniform', 'E0': 5.0e4, 's': 2.0e-7, 'w': 5.0e-8},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        mesh_type = case['mesh_type']\n        E0 = case['E0']\n        s = case['s']\n        w = case['w']\n\n        # Generate the mesh nodes {x_i}\n        if mesh_type == 'uniform':\n            x_nodes = np.linspace(0.0, L, N)\n        elif mesh_type == 'cosine':\n            xi = np.linspace(0.0, 1.0, N)\n            x_nodes = L * 0.5 * (1.0 - np.cos(np.pi * xi))\n        else:\n            raise ValueError(f\"Unknown mesh type: {mesh_type}\")\n\n        # Electric field function E(x)\n        def E_field(x):\n            if E0 == 0:\n                return 0.0\n            return E0 * (np.exp(-x / s) - np.exp(-(L - x) / s))\n\n        # Initialize overall time step limits for drift and diffusion\n        dt_drift_min = float('inf')\n        dt_diff_min = float('inf')\n\n        # Iterate through all edges i from 0 to N-2\n        for i in range(N - 1):\n            x_i = x_nodes[i]\n            x_i_plus_1 = x_nodes[i+1]\n            \n            # Calculate edge midpoint\n            x_mid = (x_i + x_i_plus_1) / 2.0\n            \n            # Check if the edge is in a contact region\n            is_in_contact = (x_mid <= w) or (x_mid >= L - w)\n\n            if is_in_contact:\n                # Calculate edge spacing\n                dx_i = x_i_plus_1 - x_i\n                \n                # Calculate local diffusion time step limit\n                # dt < F_target * dx^2 / D\n                local_dt_diff = F_TARGET * (dx_i**2) / D\n                dt_diff_min = min(dt_diff_min, local_dt_diff)\n                \n                # Calculate local drift time step limit\n                # Calculate edge-centered electric field\n                E_i = (E_field(x_i) + E_field(x_i_plus_1)) / 2.0\n                \n                # Calculate drift velocity with saturation\n                v_i = min(MU0 * abs(E_i), V_SAT)\n                \n                if v_i > 1e-12: # Avoid division by zero in zero-field case\n                    # dt < C_target * dx / v\n                    local_dt_drift = C_TARGET * dx_i / v_i\n                    dt_drift_min = min(dt_drift_min, local_dt_drift)\n\n        # The final time step is the minimum of the two constraints\n        final_dt = min(dt_drift_min, dt_diff_min)\n        results.append(final_dt)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Ultimately, most advanced semiconductor models—whether they describe steady-state transport or arise from implicit time-stepping—lead to systems of nonlinear algebraic equations. Solving these systems robustly is a paramount challenge, and naive application of Newton's method often fails if the initial guess is not close to the solution. This practice tackles the \"convergence\" pillar of our topic by having you implement a damped Newton method, a powerful globalization strategy that combines backtracking line searches and feasibility checks to guarantee convergence to a physical solution even from a poor starting point, a technique vital for any practical simulation software .",
            "id": "4145409",
            "problem": "Consider a simplified but physically grounded model for post-implant activation in a semiconductor, where donors can be either electrically active or trapped in neutral clusters. At fixed temperature, assume that clustering is governed by the law of mass action for the reaction $m \\, \\mathrm{A} \\rightleftharpoons \\mathrm{C}$, where $\\mathrm{A}$ denotes an active donor and $\\mathrm{C}$ denotes a neutral cluster composed of $m$ donors. Let the equilibrium constant be $K > 0$, the stoichiometric coefficient be an integer $m \\ge 2$, and the total donor concentration at a spatial node be $D > 0$. The unknown active concentration $a$ at that node must satisfy conservation and equilibrium:\n- Conservation: $D = a + m c$, where $c$ is the cluster concentration.\n- Mass action: $c = K a^m$.\n\nCombine these to obtain the residual equation $F(a) = 0$ for the unknown $a$ at a node, and generalize to a vector of nodes by applying the same relation componentwise. All quantities may be treated as dimensionless for this problem. The physically admissible domain is the box constraint $0 \\le a_i \\le D_i$ for each node $i$.\n\nYour task is to implement a globally convergent damped Newton method to solve $F(a) = 0$ for $a$, starting from rough initial guesses. The method must incorporate:\n1. A feasibility-preserving damping that enforces the box constraints $0 \\le a_i \\le D_i$ at every iteration using a maximum admissible step length computed from the current iterate and the proposed Newton step.\n2. A backtracking line search with a sufficient decrease condition based on the squared residual norm merit function $\\phi(a) = \\tfrac{1}{2} \\lVert F(a) \\rVert_2^2$ (an Armijo-type condition), with a strictly positive parameter $c_1$ and a contraction factor $\\tau$ in the interval $(0,1)$.\n\nYou must derive the Newton step from first principles (i.e., by differentiating $F$ with respect to $a$), implement the line search and damping strategy, and apply the method to the following test suite. Each test case specifies the donor profile $D$ (either a scalar or a list for multiple nodes), the stoichiometric coefficient $m$, the equilibrium constant $K$, and an initial guess $a^{(0)}$:\n- Test 1 (happy path, single node): $D = 1.0$, $m = 2$, $K = 0.5$, initial guess $a^{(0)} = 0.0$.\n- Test 2 (rough start near an active upper bound, single node): $D = 10.0$, $m = 3$, $K = 0.02$, initial guess $a^{(0)} = D$.\n- Test 3 (multi-node profile, mixed scales): $D = [0.1, 1.0, 5.0, 10.0, 20.0]$, $m = 3$, $K = 0.05$, initial guess $a^{(0)} = [0, 0, 0, 0, 0]$.\n- Test 4 (stiff clustering, single node, rough start at upper bound): $D = 1.0$, $m = 4$, $K = 1.0$, initial guess $a^{(0)} = D$.\n\nImplement a termination criterion that declares convergence when the infinity norm of the residual satisfies $\\lVert F(a) \\rVert_{\\infty} \\le \\varepsilon$ for a small tolerance $\\varepsilon > 0$, or a maximum number of iterations is reached. Use a fixed $\\varepsilon$ across all tests. If the method fails to converge within the maximum number of iterations, it must still return a best-effort result.\n\nRequired outputs for each test case:\n- If $D$ is a scalar, output the final activation fraction $a/D$ as a float.\n- If $D$ is a list, output the average activation fraction $\\left(\\frac{1}{N} \\sum_{i=1}^N \\frac{a_i}{D_i}\\right)$ as a float, where $N$ is the number of nodes.\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"). Each float must be rounded to ten decimal places in the output. No other text should be printed.\n\nDesign notes and constraints that must be followed:\n- Start from the foundational definitions above (conservation and mass action). Do not use pre-derived specialized formulas for activation fraction; derive the Newton step directly from differentiating your $F(a)$.\n- The line search must be based on the merit function $\\phi(a) = \\tfrac{1}{2} \\lVert F(a) \\rVert_2^2$ and must use a sufficient decrease test with a user-specified $c_1 \\in (0,1)$ and backtracking factor $\\tau \\in (0,1)$, together with feasibility-preserving damping that respects $0 \\le a_i \\le D_i$ for all $i$.\n- Use the same algorithm for both scalar and vector cases without branching on dimension other than shape handling.\n- Choose reasonable numerical parameters for tolerance, $c_1$, $\\tau$, and maximum iterations that would ensure global convergence from the given rough initial guesses.\n- All answers are dimensionless in this problem. Angles are not used, and no unit conversion is necessary.",
            "solution": "The user's request is to validate and solve a problem concerning a simplified model of post-implant activation in a semiconductor. The solution requires the implementation of a globally convergent damped Newton method.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following information:\n- **Reaction:** $m \\, \\mathrm{A} \\rightleftharpoons \\mathrm{C}$, where $\\mathrm{A}$ is an active donor, $\\mathrm{C}$ is a neutral cluster, and $m$ is an integer stoichiometric coefficient with $m \\ge 2$.\n- **Concentrations:** $a$ is the active donor concentration, $c$ is the cluster concentration, and $D$ is the total donor concentration at a spatial node, with $D > 0$.\n- **Equilibrium Constant:** $K > 0$.\n- **Governing Equations:**\n  - Conservation of mass: $D = a + m c$.\n  - Law of mass action: $c = K a^m$.\n- **Residual Equation:** $F(a) = 0$, derived from the governing equations.\n- **Physical Constraints:** For each node $i$, the active concentration must satisfy the box constraint $0 \\le a_i \\le D_i$.\n- **Numerical Method:** A globally convergent damped Newton method.\n  - **Damping:** A feasibility-preserving damping strategy to enforce the box constraints.\n  - **Line Search:** A backtracking line search based on the merit function $\\phi(a) = \\tfrac{1}{2} \\lVert F(a) \\rVert_2^2$, using an Armijo-type sufficient decrease condition with parameters $c_1 \\in (0,1)$ and $\\tau \\in (0,1)$.\n- **Termination Criterion:** $\\lVert F(a) \\rVert_{\\infty} \\le \\varepsilon$ for a tolerance $\\varepsilon > 0$, or a maximum number of iterations.\n- **Test Cases:**\n  1. $D = 1.0$, $m = 2$, $K = 0.5$, $a^{(0)} = 0.0$.\n  2. $D = 10.0$, $m = 3$, $K = 0.02$, $a^{(0)} = D$.\n  3. $D = [0.1, 1.0, 5.0, 10.0, 20.0]$, $m = 3$, $K = 0.05$, $a^{(0)} = [0, 0, 0, 0, 0]$.\n  4. $D = 1.0$, $m = 4$, $K = 1.0$, $a^{(0)} = D$.\n- **Output Format:** For each test case, the activation fraction $a/D$ (for scalar $D$) or the average activation fraction $\\left(\\frac{1}{N} \\sum_{i=1}^N \\frac{a_i}{D_i}\\right)$ (for vector $D$), rounded to ten decimal places.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded:** The model is based on the law of mass action, a fundamental principle of chemical kinetics and thermodynamics used extensively in physics and materials science, including the modeling of defect reactions and dopant activation in semiconductors. The model is a standard, simplified representation of such phenomena. The problem is scientifically sound.\n- **Well-Posed:** To determine if the problem is well-posed, we must establish the existence and uniqueness of a solution.\n  1.  Substituting the mass action law $c = K a^m$ into the conservation equation $D = a + m c$ yields a single equation for the unknown $a$: $D = a + m K a^m$.\n  2.  We define the residual function $F(a) = a + m K a^m - D$. The problem is to find the root of $F(a) = 0$.\n  3.  We analyze $F(a)$ on the physically admissible domain $a \\in [0, D]$.\n      - At the lower bound, $F(0) = 0 + m K (0)^m - D = -D$. Since $D > 0$, $F(0) < 0$.\n      - At the upper bound, $F(D) = D + m K D^m - D = m K D^m$. Since $m \\ge 2$, $K > 0$, and $D > 0$, we have $F(D) > 0$.\n      - The function $F(a)$ is a sum of polynomials and is therefore continuous. By the Intermediate Value Theorem, since $F(0) < 0$ and $F(D) > 0$, there exists at least one root $a^* \\in (0, D)$.\n      - To check for uniqueness, we examine the derivative: $F'(a) = \\frac{d}{da}(a + m K a^m - D) = 1 + m^2 K a^{m-1}$.\n      - Given $m \\ge 2$, $K > 0$, and $a \\ge 0$, the derivative $F'(a)$ is always greater than or equal to $1$. This means $F(a)$ is strictly monotonically increasing on its domain.\n      - A strictly monotonic function can cross zero at most once. Therefore, there exists a unique solution $a^*$ in the interval $(0, D)$.\n  The problem is well-posed.\n- **Objective:** The problem is formulated with precise mathematical equations, constraints, and numerical parameters. The task is specific and the required output format is unambiguous. The problem is objective.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is scientifically grounded, well-posed, objective, and self-contained. It is deemed **valid**. A solution will be provided.\n\n### Principle-Based Solution Design\n\nThe core of the problem is to solve the system of nonlinear equations $F(a) = 0$ for the vector of active concentrations $a$, where $F(a)$ is applied component-wise.\n$$ F_i(a_i) = a_i + m K a_i^m - D_i = 0 \\quad \\text{for each node } i $$\nWe will implement a damped Newton method, which is an iterative procedure. Starting from an initial guess $a^{(0)}$, each subsequent iterate is found by $a^{(k+1)} = a^{(k)} + \\alpha^{(k)} p^{(k)}$, where $p^{(k)}$ is the Newton step and $\\alpha^{(k)} \\in (0, 1]$ is a step length determined by a line search.\n\n**1. Newton Step Derivation**\nThe Newton step $p^{(k)}$ at iterate $a^{(k)}$ is the solution to the linear system $J(a^{(k)}) p^{(k)} = -F(a^{(k)})$, where $J(a)$ is the Jacobian matrix of $F(a)$.\n\nSince the relationship $F_i(a_i)$ only depends on the $i$-th component $a_i$, the system is decoupled. The Jacobian matrix is therefore diagonal:\n$$ J(a) = \\mathrm{diag}\\left(\\frac{dF_1}{da_1}, \\frac{dF_2}{da_2}, \\dots, \\frac{dF_N}{da_N}\\right) $$\nThe derivative of the $i$-th component of the residual function is:\n$$ \\frac{dF_i}{da_i} = \\frac{d}{da_i}(a_i + m K a_i^m - D_i) = 1 + m^2 K a_i^{m-1} $$\nThe Newton step $p^{(k)}$ can be computed component-wise by inverting the diagonal Jacobian:\n$$ p_i^{(k)} = -\\frac{F_i(a_i^{(k)})}{J_{ii}(a_i^{(k)})} = -\\frac{a_i^{(k)} + m K (a_i^{(k)})^m - D_i}{1 + m^2 K (a_i^{(k)})^{m-1}} $$\nAs shown in the validation, the denominator $J_{ii}(a_i^{(k)}) = 1 + m^2 K (a_i^{(k)})^{m-1} \\ge 1$ for all valid $a_i^{(k)} \\ge 0$, so the step is always well-defined.\n\n**2. Global Convergence: Damping and Line Search**\nTo ensure convergence from initial guesses that may be far from the solution, we introduce a step length $\\alpha^{(k)}$ and a line search procedure.\n\n**2.1. Feasibility-Preserving Damping**\nThe iterate must remain within the physical box constraints $[0, D]$ at every step. That is, for each component $i$, we require $0 \\le a_i^{(k+1)} \\le D_i$.\n$$ 0 \\le a_i^{(k)} + \\alpha p_i^{(k)} \\le D_i $$\nThis imposes an upper limit on the step length $\\alpha$.\n- If $p_i^{(k)} > 0$, we must satisfy $a_i^{(k)} + \\alpha p_i^{(k)} \\le D_i \\implies \\alpha \\le \\frac{D_i - a_i^{(k)}}{p_i^{(k)}}$.\n- If $p_i^{(k)} < 0$, we must satisfy $a_i^{(k)} + \\alpha p_i^{(k)} \\ge 0 \\implies \\alpha \\le \\frac{-a_i^{(k)}}{p_i^{(k)}}$.\nTo satisfy these for all components simultaneously, we compute the maximum admissible step length, $\\alpha_{\\text{feas}}$, by taking the minimum of these ratios over all components $i$. The initial trial step length for the line search, $\\alpha_0$, is then set to $\\min(1, \\alpha_{\\text{feas}})$, ensuring that even the full Newton step (if chosen) respects the bounds.\n\n**2.2. Backtracking Line Search with Armijo Condition**\nThe line search ensures that each step provides a sufficient decrease in a merit function, here chosen as $\\phi(a) = \\frac{1}{2} \\lVert F(a) \\rVert_2^2$. The Newton direction $p^{(k)}$ is a descent direction for this function.\nThe Armijo condition requires that the step length $\\alpha$ satisfies:\n$$ \\phi(a^{(k)} + \\alpha p^{(k)}) \\le \\phi(a^{(k)}) + c_1 \\alpha \\nabla \\phi(a^{(k)})^T p^{(k)} $$\nwhere $c_1 \\in (0,1)$ is a small constant (e.g., $10^{-4}$). The directional derivative is $\\nabla \\phi(a)^T p = F(a)^T J(a) p$. Since $J(a)p = -F(a)$, this simplifies to:\n$$ \\nabla \\phi(a^{(k)})^T p^{(k)} = -F(a^{(k)})^T F(a^{(k)}) = -\\lVert F(a^{(k)}) \\rVert_2^2 $$\nThe Armijo condition becomes:\n$$ \\phi(a^{(k)} + \\alpha p^{(k)}) \\le \\phi(a^{(k)}) - c_1 \\alpha \\lVert F(a^{(k)}) \\rVert_2^2 $$\nThe backtracking algorithm starts with the feasibility-preserving step length $\\alpha = \\alpha_0$. If the Armijo condition is not met, $\\alpha$ is repeatedly reduced by a contraction factor $\\tau \\in (0,1)$ (e.g., $0.5$) until the condition is satisfied.\n\n**3. Algorithm Summary**\nFor $k = 0, 1, 2, \\dots$ until convergence or maximum iterations:\n1.  Given the current iterate $a^{(k)}$, compute the residual vector $F(a^{(k)})$.\n2.  Check for convergence: If $\\lVert F(a^{(k)}) \\rVert_{\\infty} \\le \\varepsilon$, terminate and return $a^{(k)}$.\n3.  Compute the diagonal Jacobian $J(a^{(k)})$ and the Newton step $p^{(k)} = -J(a^{(k)})^{-1}F(a^{(k)})$.\n4.  Compute the maximum step length $\\alpha_0$ that preserves feasibility, $\\alpha_0 = \\min(1, \\alpha_{\\text{feas}})$.\n5.  Perform a backtracking line search starting with $\\alpha = \\alpha_0$:\n    While $\\phi(a^{(k)} + \\alpha p^{(k)}) > \\phi(a^{(k)}) - c_1 \\alpha \\lVert F(a^{(k)}) \\rVert_2^2$:\n        $\\alpha \\leftarrow \\tau \\alpha$.\n6.  Update the solution: $a^{(k+1)} = a^{(k)} + \\alpha p^{(k)}$.\nIf the loop finishes due to reaching the maximum number of iterations, the last computed $a^{(k)}$ is returned as the best-effort result.\nThe computed final concentration $a$ is then used to calculate the activation fraction(s) for the output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef damped_newton(D, m, K, a0, tol=1e-12, max_iter=100, c1=1e-4, tau=0.5):\n    \"\"\"\n    Solves the system F(a) = a + m*K*a^m - D = 0 using a globally convergent\n    damped Newton method with a backtracking line search and feasibility-preserving damping.\n    \"\"\"\n    D_arr = np.atleast_1d(D)\n    a = np.atleast_1d(a0).astype(float)\n\n    # Project the initial guess onto the feasible domain [0, D] for robustness.\n    a = np.clip(a, 0, D_arr)\n\n    for _ in range(max_iter):\n        # 1. Evaluate residual F(a) and check for convergence\n        # The term a**m is safe because m >= 2.\n        a_pow_m = a**m\n        F_val = a + m * K * a_pow_m - D_arr\n\n        if np.max(np.abs(F_val)) <= tol:\n            return a\n\n        # 2. Compute Jacobian and Newton step p\n        # The term a**(m-1) is safe because m >= 2, so m-1 >= 1.\n        a_pow_m_minus_1 = a**(m - 1)\n        J_diag = 1.0 + m**2 * K * a_pow_m_minus_1\n\n        # The Jacobian is a diagonal matrix with entries >= 1, so inversion is safe.\n        p = -F_val / J_diag\n\n        # 3. Feasibility-preserving damping: compute max allowed step length\n        alpha_max = 1.0\n        \n        # Components where step p_i is positive are limited by the upper bound D_i\n        idx_pos = p > 1e-15\n        if np.any(idx_pos):\n            # (D_arr - a) is guaranteed to be non-negative. If a_i = D_i, p_i must be < 0.\n            alpha_pos = (D_arr[idx_pos] - a[idx_pos]) / p[idx_pos]\n            alpha_max = min(alpha_max, np.min(alpha_pos))\n\n        # Components where step p_i is negative are limited by the lower bound 0\n        idx_neg = p < -1e-15\n        if np.any(idx_neg):\n            # a is guaranteed to be non-negative. If a_i = 0, p_i must be > 0.\n            alpha_neg = -a[idx_neg] / p[idx_neg]\n            alpha_max = min(alpha_max, np.min(alpha_neg))\n        \n        # 4. Backtracking line search with Armijo condition\n        alpha = alpha_max\n        phi_a = 0.5 * np.sum(F_val**2)\n        # The directional derivative of phi in direction p is -||F||^2 = -2*phi\n        descent_term = -2.0 * phi_a\n        \n        while True:\n            a_new = a + alpha * p\n            \n            F_new = a_new + m * K * (a_new**m) - D_arr\n            phi_a_new = 0.5 * np.sum(F_new**2)\n            \n            armijo_rhs = phi_a + c1 * alpha * descent_term\n            if phi_a_new <= armijo_rhs:\n                break # Step accepted\n            \n            alpha *= tau\n            if alpha < 1e-16: # Fallback to prevent stall\n                break\n\n        # 5. Update the solution\n        a += alpha * p\n\n    return a\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'D': 1.0, 'm': 2, 'K': 0.5, 'a0': 0.0},\n        {'D': 10.0, 'm': 3, 'K': 0.02, 'a0': 10.0},\n        {'D': [0.1, 1.0, 5.0, 10.0, 20.0], 'm': 3, 'K': 0.05, 'a0': [0.0, 0.0, 0.0, 0.0, 0.0]},\n        {'D': 1.0, 'm': 4, 'K': 1.0, 'a0': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        D_val = case['D']\n        m_val = case['m']\n        K_val = case['K']\n        a0_val = case['a0']\n        \n        a_final = damped_newton(\n            D=D_val,\n            m=m_val,\n            K=K_val,\n            a0=a0_val,\n        )\n        \n        D_arr = np.atleast_1d(D_val)\n        \n        # For D_i > 0 which is a problem constraint, this is safe.\n        activation_fractions = a_final / D_arr\n        \n        if activation_fractions.size == 1:\n            result = activation_fractions[0]\n        else:\n            result = np.mean(activation_fractions)\n        \n        results.append(f\"{result:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}