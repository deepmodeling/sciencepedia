{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最终目的是解决实际问题。本节的第一个实践练习将引导您将Prandtl-Reuss方程应用于一个经典的单轴拉伸-卸载试验中。通过从第一性原理出发推导残余应变的表达式，您将巩固对流动法则、硬化规律以及一致性条件等核心概念的理解，并将其与可测量的物理量直接联系起来。",
            "id": "2673839",
            "problem": "考虑一个遵循线性各向同性硬化的第二偏应力不变量（$J_2$）流动理论的关联Prandtl-Reuss方程的小应变、各向同性弹塑性固体。总小应变张量可加法分解为 $\\boldsymbol{\\varepsilon}=\\boldsymbol{\\varepsilon}^{e}+\\boldsymbol{\\varepsilon}^{p}$，且弹性响应是线性的，杨氏模量为 $E$。屈服函数为带有各向同性硬化的von Mises型函数，$f(\\boldsymbol{\\sigma},\\bar{\\varepsilon}^{p})=\\sigma_{\\mathrm{eq}}-\\sigma_{y}(\\bar{\\varepsilon}^{p})\\le 0$，其中 $\\sigma_{\\mathrm{eq}}=\\sqrt{\\tfrac{3}{2}\\,\\mathbf{s}:\\mathbf{s}}$ 是由偏应力 $\\mathbf{s}$ 构建的等效应力，而 $\\sigma_{y}(\\bar{\\varepsilon}^{p})=\\sigma_{y0}+H\\,\\bar{\\varepsilon}^{p}$，其中初始屈服强度 $\\sigma_{y0}$ 和硬化模量 $H$ 为常数。塑性流动是相关的（Prandtl-Reuss），等效塑性应变定义为 $d\\bar{\\varepsilon}^{p}=\\sqrt{\\tfrac{2}{3}\\,d\\boldsymbol{\\varepsilon}^{p}:d\\boldsymbol{\\varepsilon}^{p}}$。\n\n沿 $x_1$ 方向进行单轴拉伸试验：试样被单调应变至总轴向应变为 $\\varepsilon_{\\max}$，该值严格大于弹性屈服应变，然后在无反向塑性流动的情况下卸载至零应力。假设为小应变，且加载过程中的应力状态为单轴拉伸，其中 $\\sigma_{11}=\\sigma>0$，$\\sigma_{22}=\\sigma_{33}=0$，所有剪应力均为零。\n\n从上述模型的基本原理出发，推导完全卸载后的残余轴向应变 $\\varepsilon_{\\mathrm{res}}$ 关于 $E$、$H$、$\\sigma_{y0}$ 和 $\\varepsilon_{\\max}$ 的表达式，然后对 $E=200\\,\\mathrm{GPa}$、$\\sigma_{y0}=300\\,\\mathrm{MPa}$、$H=1.2\\,\\mathrm{GPa}$ 和 $\\varepsilon_{\\max}=0.015$ 进行求值。您可以假设 $\\varepsilon_{\\max}>\\sigma_{y0}/E$，以便在卸载前发生塑性变形。将最终数值答案四舍五入至四位有效数字，并以无量纲小数表示（无单位）。",
            "solution": "我们从小应变加法分解 $\\boldsymbol{\\varepsilon}=\\boldsymbol{\\varepsilon}^{e}+\\boldsymbol{\\varepsilon}^{p}$ 和线弹性理论出发。在单轴应力 $\\sigma_{11}=\\sigma>0$ 下，我们有轴向弹性关系\n$$\n\\sigma=E\\,\\varepsilon^{e}_{11}=E\\left(\\varepsilon_{11}-\\varepsilon^{p}_{11}\\right).\n$$\n带有线性各向同性硬化的von Mises屈服函数为\n$$\nf(\\boldsymbol{\\sigma},\\bar{\\varepsilon}^{p})=\\sigma_{\\mathrm{eq}}-\\sigma_{y}(\\bar{\\varepsilon}^{p})=\\sigma_{\\mathrm{eq}}-\\big(\\sigma_{y0}+H\\bar{\\varepsilon}^{p}\\big)\\le 0.\n$$\n对于单轴应力 $\\sigma_{22}=\\sigma_{33}=0$，偏应力分量为 $s_{11}=\\tfrac{2}{3}\\sigma$，$s_{22}=s_{33}=-\\tfrac{1}{3}\\sigma$，对于 $\\sigma>0$ 给出 $\\sigma_{\\mathrm{eq}}=\\sqrt{\\tfrac{3}{2}\\,\\mathbf{s}:\\mathbf{s}}=|\\sigma|=\\sigma$。\n\n相关的 Prandtl–Reuss 流动法则是\n$$\nd\\boldsymbol{\\varepsilon}^{p}=d\\lambda\\,\\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}=d\\lambda\\,\\frac{3}{2}\\,\\frac{\\mathbf{s}}{\\sigma_{\\mathrm{eq}}}.\n$$\n使用等效塑性应变的定义，\n$$\nd\\bar{\\varepsilon}^{p}=\\sqrt{\\tfrac{2}{3}\\,d\\boldsymbol{\\varepsilon}^{p}:d\\boldsymbol{\\varepsilon}^{p}}=\\sqrt{\\tfrac{2}{3}\\left(d\\lambda\\,\\tfrac{3}{2}\\,\\tfrac{\\mathbf{s}}{\\sigma_{\\mathrm{eq}}}\\right):\\left(d\\lambda\\,\\tfrac{3}{2}\\,\\tfrac{\\mathbf{s}}{\\sigma_{\\mathrm{eq}}}\\right)}=d\\lambda,\n$$\n因此 $d\\bar{\\varepsilon}^{p}=d\\lambda$。在单轴拉伸（$\\sigma>0$）中，轴向塑性应变增量遵循流动方向：\n$$\nd\\varepsilon^{p}_{11}=d\\lambda\\,\\frac{3}{2}\\frac{s_{11}}{\\sigma_{\\mathrm{eq}}}=d\\lambda\\,\\frac{3}{2}\\frac{(2/3)\\sigma}{\\sigma}=d\\lambda=d\\bar{\\varepsilon}^{p}.\n$$\n因此，在单调单轴拉伸期间，轴向塑性应变等于等效塑性应变，$\\varepsilon^{p}_{11}=\\bar{\\varepsilon}^{p}$（直至累积值）。\n\n在塑性加载（$f=0$ 且加载继续）期间，一致性条件 $df=0$ 给出\n$$\nd\\sigma_{\\mathrm{eq}}-H\\,d\\bar{\\varepsilon}^{p}=0.\n$$\n对于 $\\sigma>0$，有 $\\sigma_{\\mathrm{eq}}=\\sigma$，我们得到 $d\\sigma=H\\,d\\bar{\\varepsilon}^{p}$。从弹性理论可知，\n$$\nd\\sigma=E\\big(d\\varepsilon_{11}-d\\varepsilon^{p}_{11}\\big)=E\\big(d\\varepsilon_{11}-d\\bar{\\varepsilon}^{p}\\big).\n$$\n将两者相等，\n$$\nE\\big(d\\varepsilon_{11}-d\\bar{\\varepsilon}^{p}\\big)=H\\,d\\bar{\\varepsilon}^{p}\\quad\\Longrightarrow\\quad d\\bar{\\varepsilon}^{p}=\\frac{E}{E+H}\\,d\\varepsilon_{11}.\n$$\n当 $\\sigma=\\sigma_{y0}$ 时开始出现塑性，这对应于弹性屈服应变\n$$\n\\varepsilon_{y}=\\frac{\\sigma_{y0}}{E}.\n$$\n从首次屈服（$\\varepsilon_{11}=\\varepsilon_{y}$，$\\bar{\\varepsilon}^{p}=0$）积分到加载结束时达到的最大总应变 $\\varepsilon_{11}=\\varepsilon_{\\max}$，\n$$\n\\bar{\\varepsilon}^{p}\\big|_{\\mathrm{end}}=\\int_{\\varepsilon_{y}}^{\\varepsilon_{\\max}}\\frac{E}{E+H}\\,d\\varepsilon_{11}=\\frac{E}{E+H}\\,\\big(\\varepsilon_{\\max}-\\varepsilon_{y}\\big).\n$$\n此时，应力等于当前屈服应力，对于无反向卸载下的率无关各向同性硬化，卸载至零应力是弹性的（无进一步塑性应变）。因此，当卸载时 $\\sigma\\to 0$，弹性应变消失（$\\varepsilon^{e}_{11}\\to 0$），残余应变完全是塑性的：\n$$\n\\varepsilon_{\\mathrm{res}}=\\varepsilon^{p}_{11}\\big|_{\\mathrm{end}}=\\bar{\\varepsilon}^{p}\\big|_{\\mathrm{end}}=\\frac{E}{E+H}\\left(\\varepsilon_{\\max}-\\frac{\\sigma_{y0}}{E}\\right).\n$$\n\n现在进行数值计算。将模量转换为一致的单位（例如 $\\mathrm{MPa}$）：$E=200\\,\\mathrm{GPa}=200{,}000\\,\\mathrm{MPa}$，$H=1.2\\,\\mathrm{GPa}=1{,}200\\,\\mathrm{MPa}$，以及 $\\sigma_{y0}=300\\,\\mathrm{MPa}$。弹性屈服应变为\n$$\n\\varepsilon_{y}=\\frac{\\sigma_{y0}}{E}=\\frac{300}{200{,}000}=0.0015.\n$$\n比例因子为\n$$\n\\frac{E}{E+H}=\\frac{200{,}000}{200{,}000+1{,}200}=\\frac{200{,}000}{201{,}200}=\\frac{500}{503}\\approx 0.9940357853.\n$$\n因此，\n$$\n\\varepsilon_{\\mathrm{res}}=\\frac{E}{E+H}\\left(\\varepsilon_{\\max}-\\varepsilon_{y}\\right)=\\left(\\frac{500}{503}\\right)\\left(0.015-0.0015\\right)=\\left(\\frac{500}{503}\\right)(0.0135)\\approx 0.0134194831.\n$$\n四舍五入到四位有效数字并表示为无量纲小数，残余应变为 $0.01342$。",
            "answer": "$$\\boxed{0.01342}$$"
        },
        {
            "introduction": "在掌握了单轴情况下的解析推导之后 ()，下一个关键步骤是将其转化为计算机能够执行的算法。本练习要求您亲自编写一个基于“返回映射”算法的本构更新程序，这是计算塑性力学中的核心。通过设计一系列加载-卸载-再加载的数值试验，您将能验证算法的正确性，并深入理解材料在弹塑性变形过程中的响应，例如弹性卸载和包辛格效应的体现。",
            "id": "2673864",
            "problem": "设计并实现一个用于关联性 von Mises（第二偏应力不变量，J2）弹塑性模型的小应变单轴本构更新，该模型由 Prandtl-Reuss 方程和线性各向同性硬化控制。目标是通过加载-卸载-再加载的数值实验，验证所实现的模型表现出弹性卸载，并在再加载时正确恢复屈服面。该解决方案必须基于原理，并且不得依赖于下文规定的基本基础之外的预先组合公式。所有应力必须以兆帕（MPa）为单位表示，所有应变必须是无量纲的。本问题不涉及角度。所有最终输出必须是布尔值。\n\n使用的基本基础：\n- 运动学：小应变加法分解 $\\,\\varepsilon = \\varepsilon^{e} + \\varepsilon^{p}\\,$，其中 $\\,\\varepsilon\\,$ 是总应变，$\\,\\varepsilon^{e}\\,$ 是弹性应变，$\\,\\varepsilon^{p}\\,$ 是塑性应变。\n- 线性弹性：$\\,\\sigma = E\\,\\varepsilon^{e} = E(\\varepsilon - \\varepsilon^{p})\\,$，其中 $\\,\\sigma\\,$ 是 Cauchy 应力，$\\,E\\,$ 是杨氏模量。\n- Von Mises 屈服条件 (J2)：一般形式为 $\\,f(\\sigma,\\alpha) = \\sigma_{\\mathrm{eq}} - \\sigma_{y}(\\alpha) \\le 0\\,$，其中 $\\,\\sigma_{\\mathrm{eq}} = \\sqrt{\\tfrac{3}{2}}\\,\\|s\\|\\,$ 是等效应力，$\\,s\\,$ 是偏应力，$\\,\\sigma_{y}(\\alpha)\\,$ 是取决于硬化变量 $\\,\\alpha\\,$ 的当前屈服应力。\n- 关联流动 (Prandtl-Reuss)：$\\,\\dot{\\varepsilon}^{p} = \\dot{\\lambda}\\,\\dfrac{\\partial f}{\\partial \\sigma}\\,$，满足 $\\,\\dot{\\lambda} \\ge 0\\,$、$\\,f \\le 0\\,$ 和 $\\,\\dot{\\lambda}\\,f = 0\\,$（Kuhn–Tucker 条件），以及塑性加载期间的一致性条件 $\\,\\dot{\\lambda}\\,\\dot{f} = 0\\,$。\n- 线性各向同性硬化：$\\,\\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\,\\alpha\\,$，其中 $\\,\\sigma_{y0}\\,$ 是初始屈服应力，$\\,H\\,$ 是硬化模量。硬化变量 $\\,\\alpha\\,$ 是累积等效塑性应变，对于 J2 关联塑性，有 $\\,\\dot{\\alpha} = \\dot{\\lambda}\\,$。\n\n在单轴应力状态下，您可以利用 von Mises 等效应力等于轴向应力的绝对值（即 $\\,\\sigma_{\\mathrm{eq}} = |\\sigma|\\,$）以及关联流动意味着塑性应变沿轴向发生且其符号由轴向应力决定的事实，将通用的 J2 关系一致地简化为一维。程序必须实现一个增量返回映射更新，在每个给定的总应变下，强制执行屈服条件和带硬化的流动法则，在适用时遵守弹性域，并在需要时执行塑性修正。\n\n您的程序必须：\n- 实现一个单轴更新，其输入为总应变序列 $\\,\\{\\varepsilon_{n}\\}\\,$ 和材料参数 $\\,E\\,$, $\\,\\sigma_{y0}\\,$, $\\,H\\,$，从 $\\,\\varepsilon^{p}_{0} = 0\\,$ 和 $\\,\\alpha_{0} = 0\\,$ 开始。\n- 在每一步 $\\,n\\,$，通过强制执行基本基础（弹性预测，并在需要时，与关联 J2 塑性和线性各向同性硬化一致的塑性修正），计算应力 $\\,\\sigma_{n}\\,$、塑性应变 $\\,\\varepsilon^{p}_{n}\\,$ 和硬化变量 $\\,\\alpha_{n}\\,$。\n- 使用鲁棒的容差进行屈服评估，并为下文要求的检查报告布尔值。\n\n测试套件：\n实现以下四个独立的测试用例，每个用例由材料参数和给定的应变路径定义。所有应力必须以 MPa 为单位，应变为无量纲。\n\n- 测试 A（塑性加载后的弹性卸载验证）：\n  - 材料：$\\,E = 210000\\,$, $\\,\\sigma_{y0} = 300\\,$, $\\,H = 1200\\,$。\n  - 应变路径：$\\,\\left[\\,0.0,\\, 0.0050,\\, 0.0025,\\, 0.0\\,\\right]\\,$。\n  - 要求的布尔结果：当且仅当在从 $\\,0.0050\\,$ 卸载到 $\\,0.0\\,$ 期间，以下两条均成立时为 true：\n    - 塑性应变 $\\,\\varepsilon^{p}\\,$ 在 $\\,10^{-10}\\,$ 的相对容差内保持不变。\n    - 每个卸载段上的割线斜率 $\\,\\dfrac{\\Delta \\sigma}{\\Delta \\varepsilon}\\,$ 在 $\\,10^{-8}\\,$ 的相对容差内等于 $\\,E\\,$。\n\n- 测试 B（纯弹性加载-卸载）：\n  - 材料：$\\,E = 70000\\,$, $\\,\\sigma_{y0} = 300\\,$, $\\,H = 500\\,$。\n  - 应变路径：$\\,\\left[\\,0.0,\\, 0.0020,\\, 0.0\\,\\right]\\,$。\n  - 要求的布尔结果：当且仅当以下条件成立时为 true：\n    - 在所有步骤中，$\\,\\varepsilon^{p} = 0\\,$（绝对容差为 $\\,10^{-14}\\,$）。\n    - 加载和卸载时的割线斜率 $\\,\\dfrac{\\Delta \\sigma}{\\Delta \\varepsilon}\\,$ 在 $\\,10^{-12}\\,$ 的相对容差内均等于 $\\,E\\,$。\n\n- 测试 C（接近屈服开始时的屈服边界处理）：\n  - 材料：$\\,E = 200000\\,$, $\\,\\sigma_{y0} = 250\\,$, $\\,H = 1000\\,$。\n  - 应变路径：$\\,\\left[\\,0.0,\\, 0.0012505\\,\\right]\\,$。\n  - 要求的布尔结果：当且仅当以下条件成立时为 true：\n    - 在最后一步，屈服函数残差 $\\,r = |\\sigma| - (\\sigma_{y0} + H\\,\\alpha)\\,$ 满足 $\\,|r| \\le 10^{-9}\\,$。\n    - 硬化变量从零增加，即 $\\,\\alpha > 0\\,$。\n\n- 测试 D（从塑性状态弹性卸载后再加载时的再屈服应力恢复）：\n  - 材料：$\\,E = 200000\\,$, $\\,\\sigma_{y0} = 250\\,$, $\\,H = 1000\\,$。\n  - 应变路径阶段：\n    - 加载到塑性状态并卸载到零：$\\,\\left[\\,0.0,\\, 0.0050,\\, 0.0\\,\\right]\\,$。\n    - 然后定义预测的再屈服应变 $\\,\\varepsilon_{\\mathrm{pred}} = \\varepsilon^{p}_{\\star} + \\dfrac{\\sigma_{y0} + H\\,\\alpha_{\\star}}{E}\\,$，其中 $\\,\\varepsilon^{p}_{\\star}\\,$ 和 $\\,\\alpha_{\\star}\\,$ 是在第一次加载结束时（卸载前）记录的塑性应变和硬化变量。\n    - 使用两个步骤框住预测的再屈服点进行再加载：$\\,\\varepsilon_{\\mathrm{pred}} - 10^{-6}\\,$ 和 $\\,\\varepsilon_{\\mathrm{pred}} + 10^{-6}\\,$。\n  - 要求的布尔结果：当且仅当以下所有条件均成立时为 true：\n    - 在 $\\,\\varepsilon_{\\mathrm{pred}} - 10^{-6}\\,$ 时，该步是弹性的：$\\,\\alpha\\,$ 在 $\\,10^{-12}\\,$ 的绝对容差内等于 $\\,\\alpha_{\\star}\\,$。\n    - 在 $\\,\\varepsilon_{\\mathrm{pred}} + 10^{-6}\\,$ 时，屈服函数残差 $\\,r = |\\sigma| - (\\sigma_{y0} + H\\,\\alpha)\\,$ 满足 $\\,|r| \\le 10^{-9}\\,$ 并且 $\\,\\alpha > \\alpha_{\\star}\\,$。\n\n您的程序必须生成单行输出，其中包含测试 A–D 的四个布尔结果，格式为用方括号括起来的逗号分隔列表（例如，“[True,False,True,True]”）。",
            "solution": "该问题要求为具有线性各向同性硬化的单轴、小应变、关联 $J_2$ 弹塑性模型设计并实现一个本构更新算法。该实现的有效性将通过一系列四个数值实验进行验证。\n\n该问题陈述具有科学依据、适定且完整。它描述了连续介质塑性力学中的一个标准模型，提供了所有必要的方程、材料参数、初始条件和加载历史。验证标准是客观且可通过数值验证的。因此，该问题是有效的，将从提供的基本原理推导出解决方案。\n\n解决方案的核心是一个基于后向欧拉积分方案的增量更新过程，通常称为返回映射算法。该算法包括一个弹性预测步，如果违反了屈服条件，则随后进行塑性修正步。我们将为指定的一维情况推导该算法。\n\n设一个时间增量开始时（步骤 $n$）的状态为已知：$(\\sigma_{n}, \\varepsilon^{p}_{n}, \\alpha_{n})$。我们已知增量结束时的总应变 $\\varepsilon_{n+1}$。我们的目标是计算状态 $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$。\n\n在从 $n$ 到 $n+1$ 的增量上离散化的基本关系是：\n1. 应变加法分解：$\\varepsilon_{n+1} = \\varepsilon^{e}_{n+1} + \\varepsilon^{p}_{n+1}$\n2. 线性弹性应力-应变关系：$\\sigma_{n+1} = E \\cdot \\varepsilon^{e}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})$\n3. 离散流动法则：$\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\varepsilon^{p} = \\varepsilon^{p}_{n} + \\Delta\\lambda \\cdot \\text{sign}(\\sigma_{n+1})$\n4. 离散硬化定律：$\\alpha_{n+1} = \\alpha_{n} + \\Delta\\alpha = \\alpha_{n} + \\Delta\\lambda$\n5. 屈服条件：$f_{n+1} = |\\sigma_{n+1}| - (\\sigma_{y0} + H \\alpha_{n+1}) \\le 0$\n6. Kuhn-Tucker 加载/卸载条件：$\\Delta\\lambda \\ge 0$, $f_{n+1} \\le 0$, $\\Delta\\lambda \\cdot f_{n+1} = 0$\n\n这里，$\\Delta\\lambda$ 是塑性乘子的增量，它量化了该步骤内的塑性流动量。项 $\\text{sign}(\\sigma_{n+1})$ 来自于对单轴情况下的 $\\partial f/\\partial \\sigma = \\partial |\\sigma|/\\partial \\sigma$ 的评估。\n\n该算法对每个增量都分两个主要阶段进行。\n\n**第 1 步：弹性预测**\n首先，我们假设整个应变增量是纯弹性的。这等同于将塑性乘子增量设为零，$\\Delta\\lambda = 0$。由此计算出“试探”状态：\n- 试探塑性应变：$\\varepsilon^{p, \\text{tr}}_{n+1} = \\varepsilon^{p}_{n}$\n- 试探硬化变量：$\\alpha^{\\text{tr}}_{n+1} = \\alpha_{n}$\n- 试探应力：$\\sigma^{\\text{tr}}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p, \\text{tr}}_{n+1}) = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$\n\n**第 2 步：屈服检查与塑性修正**\n接下来，我们检查这个试探应力是否违反了由增量开始时状态定义的屈服条件。我们在试探状态下评估屈服函数：\n$$f^{\\text{tr}} = |\\sigma^{\\text{tr}}_{n+1}| - \\sigma_{y}(\\alpha_{n}) = |\\sigma^{\\text{tr}}_{n+1}| - (\\sigma_{y0} + H \\alpha_{n})$$\n\n有两种可能的结果：\n\n**情况 I：弹性步 ($f^{\\text{tr}} \\le 0$)**\n如果试探屈服函数不为正，则试探应力在屈服面内或其上。弹性步的假设是正确的。增量结束时的状态即为试探状态：\n- $\\sigma_{n+1} = \\sigma^{\\text{tr}}_{n+1}$\n- $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}$\n- $\\alpha_{n+1} = \\alpha_{n}$\n在这种情况下，$\\Delta\\lambda = 0$，满足 Kuhn-Tucker 条件。\n\n**情况 II：塑性步 ($f^{\\text{tr}} > 0$)**\n如果试探屈服函数为正，则试探应力位于屈服面之外，这在物理上是不允许的。必须发生塑性变形，以使应力状态返回到屈服面上。必须更新状态，以满足一致性条件 $f_{n+1} = 0$。这就是塑性修正或“返回映射”步。\n\n我们必须找到满足控制方程的非负值 $\\Delta\\lambda$。将流动法则 (3) 代入弹性定律 (2)：\n$$\\sigma_{n+1} = E (\\varepsilon_{n+1} - (\\varepsilon^{p}_{n} + \\Delta\\lambda \\cdot \\text{sign}(\\sigma_{n+1})))$$\n认识到 $\\sigma^{\\text{tr}}_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$，并且对于这个简单模型，在修正过程中应力方向不改变符号，所以 $\\text{sign}(\\sigma_{n+1}) = \\text{sign}(\\sigma^{\\text{tr}}_{n+1})$，我们有：\n$$\\sigma_{n+1} = \\sigma^{\\text{tr}}_{n+1} - E \\cdot \\Delta\\lambda \\cdot \\text{sign}(\\sigma^{\\text{tr}}_{n+1})$$\n两边取绝对值得：\n$$|\\sigma_{n+1}| = |\\sigma^{\\text{tr}}_{n+1}| - E \\cdot \\Delta\\lambda$$\n\n最终应力必须位于更新后的屈服面上，因此根据屈服条件 (5) 和硬化定律 (4)：\n$$|\\sigma_{n+1}| = \\sigma_{y0} + H \\alpha_{n+1} = \\sigma_{y0} + H (\\alpha_{n} + \\Delta\\lambda)$$\n\n令两个 $|\\sigma_{n+1}|$ 的表达式相等：\n$$|\\sigma^{\\text{tr}}_{n+1}| - E \\cdot \\Delta\\lambda = \\sigma_{y0} + H \\alpha_{n} + H \\cdot \\Delta\\lambda$$\n我们现在可以解出未知的一致性参数 $\\Delta\\lambda$：\n$$|\\sigma^{\\text{tr}}_{n+1}| - (\\sigma_{y0} + H \\alpha_{n}) = (E + H) \\Delta\\lambda$$\n左侧恰好是试探屈服函数 $f^{\\text{tr}}$。因此：\n$$\\Delta\\lambda = \\frac{f^{\\text{tr}}}{E + H} = \\frac{|\\sigma^{\\text{tr}}_{n+1}| - (\\sigma_{y0} + H \\alpha_{n})}{E + H}$$\n由于我们处于塑性情况（$f^{\\text{tr}} > 0$），并且 $E$ 和 $H$ 都是非负材料常数（$E>0$），因此 $\\Delta\\lambda > 0$，这与 Kuhn-Tucker 条件一致。\n\n确定 $\\Delta\\lambda$ 后，更新状态变量：\n1. 硬化变量：$\\alpha_{n+1} = \\alpha_{n} + \\Delta\\lambda$\n2. 塑性应变：$\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\lambda \\cdot \\text{sign}(\\sigma^{\\text{tr}}_{n+1})$\n3. 应力：$\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})$\n\n至此，更新算法的推导结束。该算法是鲁棒的，将用于执行所需的数值实验。对于每个测试用例，指定的应变路径将被离散化，并使用此逻辑增量更新状态。然后，使用每一步的最终状态来验证问题陈述中列出的条件。",
            "answer": "```python\nimport numpy as np\n\ndef _uniaxial_update_step(current_state, next_total_strain, E, sigy0, H):\n    \"\"\"\n    Performs a single incremental update step for the uniaxial J2 model.\n\n    Args:\n        current_state (tuple): (sigma_n, ep_n, alpha_n).\n        next_total_strain (float): Total strain at step n+1.\n        E (float): Young's modulus.\n        sigy0 (float): Initial yield stress.\n        H (float): Hardening modulus.\n\n    Returns:\n        tuple: (sigma_n+1, ep_n+1, alpha_n+1).\n    \"\"\"\n    _, ep_n, alpha_n = current_state\n\n    # Elastic predictor\n    sig_tr = E * (next_total_strain - ep_n)\n\n    # Yield function check\n    f_tr = np.abs(sig_tr) - (sigy0 + H * alpha_n)\n\n    if f_tr = 1e-12:  # Using a small tolerance for floating point comparisons\n        # Elastic step\n        sig_n1 = sig_tr\n        ep_n1 = ep_n\n        alpha_n1 = alpha_n\n    else:\n        # Plastic corrector\n        delta_lambda = f_tr / (E + H)\n        alpha_n1 = alpha_n + delta_lambda\n        # np.sign(0) is 0, which is correct for sig_tr = 0\n        ep_n1 = ep_n + delta_lambda * np.sign(sig_tr)\n        sig_n1 = E * (next_total_strain - ep_n1)\n\n    return sig_n1, ep_n1, alpha_n1\n\ndef run_simulation(material_params, strain_path, initial_state=(0.0, 0.0, 0.0)):\n    \"\"\"\n    Runs a full simulation over a given strain path.\n\n    Args:\n        material_params (tuple): (E, sigy0, H).\n        strain_path (list): Sequence of total strains.\n        initial_state (tuple): Initial state (sigma, ep, alpha).\n\n    Returns:\n        tuple: (strains, sigmas, eps, alphas) history lists.\n    \"\"\"\n    E, sigy0, H = material_params\n    \n    strains = list(strain_path)\n    sigmas = [initial_state[0]]\n    eps = [initial_state[1]]  # Plastic strains\n    alphas = [initial_state[2]]\n\n    current_state = initial_state\n    for i in range(len(strains) - 1):\n        next_strain = strains[i+1]\n        next_state = _uniaxial_update_step(current_state, next_strain, E, sigy0, H)\n        \n        sigmas.append(next_state[0])\n        eps.append(next_state[1])\n        alphas.append(next_state[2])\n        current_state = next_state\n        \n    return strains, np.array(sigmas), np.array(eps), np.array(alphas)\n\n\ndef test_A():\n    \"\"\"Elastic unloading verification after plastic loading.\"\"\"\n    E, sigy0, H = 210000.0, 300.0, 1200.0\n    strain_path = [0.0, 0.0050, 0.0025, 0.0]\n    strains, sigmas, eps, _ = run_simulation((E, sigy0, H), strain_path)\n\n    # Unloading occurs from state 1 to 2, and 2 to 3.\n    # Check 1: Plastic strain remains constant during unloading.\n    # ep_1 is the plastic strain after first load, it should not be zero.\n    ep_check1 = np.isclose(eps[2], eps[1], rtol=1e-10, atol=0)\n    ep_check2 = np.isclose(eps[3], eps[2], rtol=1e-10, atol=0)\n    ep_const_check = ep_check1 and ep_check2\n\n    # Check 2: Secant slope on unloading segments equals E.\n    # Avoid division by zero, although strain diffs are non-zero here.\n    slope12 = (sigmas[2] - sigmas[1]) / (strains[2] - strains[1])\n    slope_check1 = np.isclose(slope12, E, rtol=1e-8, atol=0)\n    \n    slope23 = (sigmas[3] - sigmas[2]) / (strains[3] - strains[2])\n    slope_check2 = np.isclose(slope23, E, rtol=1e-8, atol=0)\n    \n    slope_E_check = slope_check1 and slope_check2\n    \n    return ep_const_check and slope_E_check\n\ndef test_B():\n    \"\"\"Purely elastic loading-unloading.\"\"\"\n    E, sigy0, H = 70000.0, 300.0, 500.0\n    strain_path = [0.0, 0.0020, 0.0]\n    strains, sigmas, eps, _ = run_simulation((E, sigy0, H), strain_path)\n\n    # Check 1: Plastic strain is zero throughout.\n    ep_zero_check = np.all(np.abs(eps) = 1e-14)\n    \n    # Check 2: Secant slopes on loading and unloading equal E.\n    slope01 = (sigmas[1] - sigmas[0]) / (strains[1] - strains[0])\n    slope12 = (sigmas[2] - sigmas[1]) / (strains[2] - strains[1])\n    \n    slope_load_check = np.isclose(slope01, E, rtol=1e-12, atol=0)\n    slope_unload_check = np.isclose(slope12, E, rtol=1e-12, atol=0)\n    slope_E_check = slope_load_check and slope_unload_check\n\n    return ep_zero_check and slope_E_check\n\ndef test_C():\n    \"\"\"Yield boundary handling at near-onset loading.\"\"\"\n    E, sigy0, H = 200000.0, 250.0, 1000.0\n    strain_path = [0.0, 0.0012505]\n    _, sigmas, _, alphas = run_simulation((E, sigy0, H), strain_path)\n\n    final_sigma = sigmas[-1]\n    final_alpha = alphas[-1]\n\n    # Check 1: Yield function residual is near zero.\n    residual = np.abs(final_sigma) - (sigy0 + H * final_alpha)\n    residual_check = abs(residual) = 1e-9\n\n    # Check 2: Hardening variable has increased.\n    hardening_check = final_alpha > 0\n\n    return residual_check and hardening_check\n\ndef test_D():\n    \"\"\"Re-yield stress recovery upon reloading.\"\"\"\n    E, sigy0, H = 200000.0, 250.0, 1000.0\n    material_params = (E, sigy0, H)\n    \n    # Stage 1: Load to a plastic state and unload to zero.\n    load_unload_path = [0.0, 0.0050, 0.0]\n    _, sig_hist1, ep_hist1, alpha_hist1 = run_simulation(material_params, load_unload_path)\n    \n    ep_star = ep_hist1[1]  # at peak strain\n    alpha_star = alpha_hist1[1] # at peak strain\n\n    # State at the end of unloading\n    initial_state_reload = (sig_hist1[2], ep_hist1[2], alpha_hist1[2])\n\n    # Stage 2: Define reloading path\n    # Predicted re-yield strain\n    eps_pred = ep_star + (sigy0 + H * alpha_star) / E\n    eps_A = eps_pred - 1e-6\n    eps_B = eps_pred + 1e-6\n    \n    reload_path = [0.0, eps_A, eps_B]\n    \n    # Stage 3: Run reloading simulation\n    _, sig_hist2, ep_hist2, alpha_hist2 = run_simulation(material_params, reload_path, initial_state=initial_state_reload)\n\n    # Check 1: Step to eps_A is elastic\n    # alpha at eps_A (index 1 in reload history) should equal alpha_star\n    alpha_A = alpha_hist2[1]\n    check_elastic = np.isclose(alpha_A, alpha_star, atol=1e-12, rtol=0)\n\n    # Check 2: Step to eps_B is plastic\n    sig_B = sig_hist2[2]\n    alpha_B = alpha_hist2[2]\n    \n    # Yield function residual check\n    residual_B = np.abs(sig_B) - (sigy0 + H * alpha_B)\n    check_residual = abs(residual_B) = 1e-9\n    \n    # Hardening increase check\n    check_hardening = alpha_B > alpha_star\n    \n    check_plastic = check_residual and check_hardening\n    \n    return check_elastic and check_plastic\n\n\ndef solve():\n    \"\"\"\n    Executes all test cases and prints the results in the required format.\n    \"\"\"\n    results = [test_A(), test_B(), test_C(), test_D()]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了获得更深刻和普适的理解，我们将返回映射算法置于一个更广阔的数学框架下。本练习揭示了$J_2$塑性中的应力更新过程在本质上是一个约束优化问题：在所有满足屈服条件的应力状态中，寻找一个与弹性试探应力“最近”的点。您需要通过编写一个迭代数值求解器，并将其结果与解析的“径向返回”公式进行比较，从而亲手验证这一优雅的变分原理，并将对塑性理论的理解从物理直观提升到数学构造的层面。",
            "id": "2673804",
            "problem": "考虑无穷小（小）应变、率无关、关联 von Mises 塑性（也称为偏应力第二不变量 (J2) 塑性），采用 Prandtl–Reuss 流动法则和理想塑性（无硬化）。设 Cauchy 应力为一个对称张量 $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$，其偏量部分为 $\\mathbf{s} = \\operatorname{dev}(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\tfrac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})\\mathbf{I}$，静水压力为 $p = \\tfrac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})$。von Mises 屈服函数为\n$$\nf(\\boldsymbol{\\sigma}) = \\sqrt{\\tfrac{3}{2}}\\,\\|\\mathbf{s}\\|_F - \\sigma_y \\le 0,\n$$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数，$\\sigma_y > 0$ 是屈服应力。关联塑性的 Prandtl–Reuss 流动法则指定塑性应变增量的方向为应力空间中屈服面的外法线方向。\n\n对于一个固定的时间步和一个给定的弹性预测（试探应力）$\\boldsymbol{\\sigma}^{\\text{tr}}$，该理想塑性模型在偏应力空间中的增量变分原理可简化为以下凸最小化问题：\n- 在满足 $\\operatorname{tr}(\\mathbf{s})=0$ 的偏应力 $\\mathbf{s} \\in \\mathbb{R}^{3 \\times 3}$ 上最小化目标函数\n$$\n\\Phi(\\mathbf{s}) = \\tfrac{1}{2}\\,\\|\\mathbf{s} - \\mathbf{s}^{\\text{tr}}\\|_F^2\n$$\n并服从 von Mises 容许性约束\n$$\n\\sqrt{\\tfrac{3}{2}}\\,\\|\\mathbf{s}\\|_F \\le \\sigma_y.\n$$\n请注意，对于此模型和时间步，静水压力部分 $p = \\tfrac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma}^{\\text{tr}})$ 不受塑性流动影响，因此更新后的全应力为 $\\boldsymbol{\\sigma} = \\mathbf{s} + p\\,\\mathbf{I}$。\n\n您的任务是实现：\n1) 一个针对上述偏应力空间中最小化问题的数值求解器，使用迭代投影梯度法（或同等稳健的一阶方法），该方法对于任何试探偏应力 $\\mathbf{s}^{\\text{tr}}$ 都能收敛到唯一的极小值点。\n2) 一个通过在该时间步结束时强制执行 Prandtl–Reuss 流动方向和一致性条件而获得的解析闭式映射（在偏应力空间中通常称为“径向返回”）。\n3) 一个验证程序，对于每个给定的试探应力，计算：\n   - 数值最小化得到的偏应力 $\\mathbf{s}^{\\star}_{\\text{num}}$ 和相应的更新后全应力 $\\boldsymbol{\\sigma}_{\\text{num}} = \\mathbf{s}^{\\star}_{\\text{num}} + p\\,\\mathbf{I}$，\n   - 解析法得到的偏应力 $\\mathbf{s}^{\\star}_{\\text{rad}}$ 和更新后全应力 $\\boldsymbol{\\sigma}_{\\text{rad}} = \\mathbf{s}^{\\star}_{\\text{rad}} + p\\,\\mathbf{I}$，\n   - 两种方法的塑性乘子增量 $\\Delta\\gamma$，其定义由具有剪切模量 $\\mu$ 的理想塑性中 Prandtl–Reuss 方程的一致性所隐含（详见下文）。\n最后，对每个测试用例，报告一个布尔值，表示两种方法得到的更新后全应力和塑性乘子增量是否在规定的数值容差内一致。\n\n您可以使用的基础知识：\n- 小应变下的线性弹性：$\\boldsymbol{\\sigma} = \\mathbb{C}:(\\boldsymbol{\\varepsilon}-\\boldsymbol{\\varepsilon}^p)$，其中 Lamé 剪切模量 $\\mu = \\tfrac{E}{2(1+\\nu)}$ 由杨氏模量 $E$ 和泊松比 $\\nu$ 导出。\n- 偏量/静水压力分解 $\\boldsymbol{\\sigma} = \\mathbf{s} + p\\,\\mathbf{I}$、Frobenius 范数 $\\|\\cdot\\|_F$ 以及基本的凸优化原理（严格凸目标和凸可行集的存在性和唯一性）。\n- J2 塑性的关联流动法则 (Prandtl–Reuss)：塑性应变增量的方向垂直于屈服面，当步长为塑性时，步末的一致性条件决定了塑性乘子增量 $\\Delta\\gamma$。\n\n材料常数和单位：\n- 使用 $E = 210 \\times 10^9$ 帕斯卡，$\\nu = 0.3$，因此 $\\mu = \\tfrac{E}{2(1+\\nu)}$ 帕斯卡。\n- 使用屈服应力 $\\sigma_y = 400 \\times 10^6$ 帕斯卡。\n- 下面提供的所有应力单位均为帕斯卡。输出的布尔值为无量纲。\n\n测试套件（试探应力）：\n令 $\\mathbf{I}$ 表示 $3 \\times 3$ 单位矩阵。定义以下 $3 \\times 3$ 对称试探应力 $\\boldsymbol{\\sigma}^{\\text{tr}}_k$：\n- 情况 1 (内部)：$\\mathbf{s}_1^{\\text{tr}} = \\operatorname{diag}(100\\!\\times\\!10^6,\\,-50\\!\\times\\!10^6,\\,-50\\!\\times\\!10^6)$，$p_1 = 50\\!\\times\\!10^6$，$\\boldsymbol{\\sigma}^{\\text{tr}}_1 = \\mathbf{s}_1^{\\text{tr}} + p_1 \\mathbf{I}$。\n- 情况 2 (屈服面上)：$\\mathbf{s}_2^{\\text{tr}} = \\sigma_y \\,\\operatorname{diag}\\!\\big(\\tfrac{2}{3},\\,-\\tfrac{1}{3},\\,-\\tfrac{1}{3}\\big)$，$p_2 = -20\\!\\times\\!10^6$，$\\boldsymbol{\\sigma}^{\\text{tr}}_2 = \\mathbf{s}_2^{\\text{tr}} + p_2 \\mathbf{I}$。\n- 情况 3 (略微超出)：$\\mathbf{s}_3^{\\text{tr}} = 1.05\\,\\mathbf{s}_2^{\\text{tr}}$，$p_3 = 30\\!\\times\\!10^6$，$\\boldsymbol{\\sigma}^{\\text{tr}}_3 = \\mathbf{s}_3^{\\text{tr}} + p_3 \\mathbf{I}$。\n- 情况 4 (远超出)：令 $r_y = \\sqrt{\\tfrac{2}{3}}\\,\\sigma_y$ 且 $a = \\tfrac{\\sqrt{3}}{\\sqrt{2}}\\,r_y$。设 $\\mathbf{s}_4^{\\text{tr}} = \\operatorname{diag}(a,\\,-a,\\,0)$，$p_4 = -100\\!\\times\\!10^6$，$\\boldsymbol{\\sigma}^{\\text{tr}}_4 = \\mathbf{s}_4^{\\text{tr}} + p_4 \\mathbf{I}$。\n- 情况 5 (零)：$\\boldsymbol{\\sigma}^{\\text{tr}}_5 = \\mathbf{0}$。\n- 情况 6 (纯静水压力)：$\\boldsymbol{\\sigma}^{\\text{tr}}_6 = 120\\!\\times\\!10^6\\,\\mathbf{I}$。\n- 情况 7 (超出且含非对角元素)：\n$$\n\\mathbf{s}_7^{\\text{tr}} = 10^8\\begin{bmatrix}\n2  -1  0.5\\\\\n-1  -3  0.2\\\\\n0.5  0.2  1\n\\end{bmatrix},\\quad\np_7 = 15\\!\\times\\!10^6,\\quad \\boldsymbol{\\sigma}^{\\text{tr}}_7 = \\mathbf{s}_7^{\\text{tr}} + p_7 \\mathbf{I}.\n$$\n\n验证和输出规范：\n- 对于每个情况 $k \\in \\{1,\\dots,7\\}$，通过数值求解关于 $\\mathbf{s}$ 的最小化问题来计算 $\\boldsymbol{\\sigma}_{\\text{num}}$，然后通过加上不变的静水压力部分 $p\\,\\mathbf{I}$ 来重构全应力。同时，根据数值极小值点所隐含的 Prandtl–Reuss 一致性条件计算 $\\Delta\\gamma_{\\text{num}}$。\n- 与此同时，根据从理想塑性的 Prandtl–Reuss 方程推导出的闭式径向映射计算解析返回应力 $\\boldsymbol{\\sigma}_{\\text{rad}}$ 和相应的塑性乘子增量 $\\Delta\\gamma_{\\text{rad}}$。\n- 对每个情况，评估一个布尔值，当且仅当以下两个条件都满足时，该值为真：\n  1) $\\boldsymbol{\\sigma}_{\\text{num}}$ 和 $\\boldsymbol{\\sigma}_{\\text{rad}}$ 之间的相对 Frobenius 范数差异不大于 $10^{-10}$，以及\n  2) $\\Delta\\gamma_{\\text{num}}$ 和 $\\Delta\\gamma_{\\text{rad}}$ 之间的相对差异不大于 $10^{-12}$（对于弹性步，允许精确值为零）。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[True,False,True,...]”）。\n\n角度单位不适用。不涉及百分比。最终的布尔值为无量纲。",
            "solution": "所呈现的问题是计算固体力学中的一个标准且适定的问题，具体涉及率无关 $J_2$ 理想塑性返回映射算法的实现。核心任务是找到一个试探偏应力状态在 von Mises 屈服面上的最近点投影，该屈服面在主应力空间中是一个椭球，在配备了 Frobenius 范数的偏应力张量空间中是一个球面。题目要求我们使用两种方法——解析闭式解和迭代数值方法——来解决这个问题，并验证它们的一致性。\n\n首先，我们建立数学框架。Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 被加法分解为其偏量部分 $\\mathbf{s}$ 和静水压力部分 $p\\mathbf{I}$，其中 $\\mathbf{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})\\mathbf{I}$ 且 $p = \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})$。对于 $J_2$ 流动理论，静水压力响应是纯弹性的，因此塑性流动不影响压力，即 $p = p^{\\text{tr}}$。因此，问题被简化到偏应力空间中。\n\nvon Mises 屈服准则为 $f(\\boldsymbol{\\sigma}) = \\sqrt{\\frac{3}{2}}\\|\\mathbf{s}\\|_F - \\sigma_y \\le 0$。容许的偏应力集合是在 5 维对称偏应力张量空间中以原点为中心的闭球，由约束 $\\|\\mathbf{s}\\|_F \\le \\sqrt{\\frac{2}{3}}\\sigma_y$ 定义。我们将这个球的半径定义为 $r_y = \\sqrt{\\frac{2}{3}}\\sigma_y$。\n\n问题是在约束 $\\|\\mathbf{s}\\|_F \\le r_y$ 下最小化目标函数 $\\Phi(\\mathbf{s}) = \\frac{1}{2}\\|\\mathbf{s} - \\mathbf{s}^{\\text{tr}}\\|_F^2$。这是一个将点 $\\mathbf{s}^{\\text{tr}}$ 投影到一个闭凸集（半径为 $r_y$ 的球）上的经典欧几里得投影问题。\n\n**解析解（径向返回映射）**\n\n目标函数的严格凸性和可行集的闭凸性保证了解 $\\mathbf{s}^\\star$ 的存在性和唯一性。该解可以通过考察 Karush-Kuhn-Tucker (KKT) 条件找到，但对于投影到一个球体上的问题，其解在几何上是直观的。\n\n设试探屈服函数值为 $f^{\\text{tr}} = \\sqrt{\\frac{3}{2}}\\|\\mathbf{s}^{\\text{tr}}\\|_F - \\sigma_y$。出现两种情况：\n\n1.  **弹性步**：如果 $f^{\\text{tr}} \\le 0$，这等价于 $\\|\\mathbf{s}^{\\text{tr}}\\|_F \\le r_y$，则试探应力 $\\mathbf{s}^{\\text{tr}}$ 已经位于容许区域内。由于 $\\mathbf{s}^{\\text{tr}}$ 是 $\\Phi(\\mathbf{s})$ 的无约束极小值点，它也是有约束的极小值点。因此，更新后的偏应力为 $\\mathbf{s}^\\star_{\\text{rad}} = \\mathbf{s}^{\\text{tr}}$。在这种情况下，没有塑性变形，所以塑性乘子增量为 $\\Delta\\gamma_{\\text{rad}} = 0$。\n\n2.  **塑性步**：如果 $f^{\\text{tr}} > 0$，即 $\\|\\mathbf{s}^{\\text{tr}}\\|_F > r_y$，则试探应力在屈服面之外。球内距离 $\\mathbf{s}^{\\text{tr}}$ 最近的点位于边界（屈服面）上，并且从原点出发的方向与 $\\mathbf{s}^{\\text{tr}}$ 相同。这就是“径向返回”的概念。解通过将 $\\mathbf{s}^{\\text{tr}}$ 按比例缩回到球面上得到：\n    $$\n    \\mathbf{s}^\\star_{\\text{rad}} = r_y \\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F} = \\sqrt{\\frac{2}{3}}\\sigma_y \\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F}.\n    $$\n    相应的塑性乘子增量 $\\Delta\\gamma_{\\text{rad}}$ 由离散本构方程确定。弹性预测-塑性修正格式给出更新后的应力为 $\\mathbf{s} = \\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\boldsymbol{\\varepsilon}^p$，其中 $\\mu$ 是剪切模量。$J_2$ 塑性的关联流动法则表明 $\\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\gamma \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\Delta\\gamma \\sqrt{\\frac{3}{2}}\\frac{\\mathbf{s}}{\\|\\mathbf{s}\\|_F}$。将此代入应力更新公式，并利用对于塑性步 $\\mathbf{s}$ 和 $\\mathbf{s}^{\\text{tr}}$ 是共线的事实（即，对于 $\\mathbf{s}^{\\text{tr}} \\neq \\mathbf{0}$，有 $\\frac{\\mathbf{s}}{\\|\\mathbf{s}\\|_F} = \\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F}$）：\n    $$\n    \\mathbf{s} = \\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\gamma \\sqrt{\\frac{3}{2}}\\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F}.\n    $$\n    对两边取 Frobenius 范数可得 $\\|\\mathbf{s}\\|_F = \\|\\mathbf{s}^{\\text{tr}}\\|_F - 2\\mu\\Delta\\gamma\\sqrt{\\frac{3}{2}}$。由于最终状态在屈服面上，$\\|\\mathbf{s}\\|_F = r_y = \\sqrt{\\frac{2}{3}}\\sigma_y$。解出 $\\Delta\\gamma$ 可得：\n    $$\n    \\Delta\\gamma_{\\text{rad}} = \\frac{\\|\\mathbf{s}^{\\text{tr}}\\|_F - r_y}{2\\mu\\sqrt{3/2}} = \\frac{\\|\\mathbf{s}^{\\text{tr}}\\|_F - \\sqrt{2/3}\\sigma_y}{2\\mu\\sqrt{3/2}} = \\frac{\\sqrt{3/2}\\|\\mathbf{s}^{\\text{tr}}\\|_F - \\sigma_y}{3\\mu} = \\frac{f^{\\text{tr}}}{3\\mu}.\n    $$\n\n在两种情况下，更新后的全应力都重构为 $\\boldsymbol{\\sigma}_{\\text{rad}} = \\mathbf{s}^\\star_{\\text{rad}} + p^{\\text{tr}}\\mathbf{I}$。\n\n**数值解（投影梯度法）**\n\n该问题使用投影梯度法进行数值求解，这是一种适用于约束凸优化的一阶迭代算法。迭代公式为：\n$$\n\\mathbf{s}_{k+1} = P_C(\\mathbf{s}_k - \\alpha \\nabla\\Phi(\\mathbf{s}_k)),\n$$\n其中 $P_C$ 是到可行集 $C = \\{\\mathbf{s} \\in \\mathbb{R}^{3 \\times 3} \\mid \\operatorname{tr}(\\mathbf{s})=0, \\|\\mathbf{s}\\|_F \\le r_y\\}$ 的投影算子，$\\alpha$ 是步长。目标函数的梯度为 $\\nabla\\Phi(\\mathbf{s}) = \\mathbf{s} - \\mathbf{s}^{\\text{tr}}$。迭代变为：\n$$\n\\mathbf{s}_{k+1} = P_C((1-\\alpha)\\mathbf{s}_k + \\alpha \\mathbf{s}^{\\text{tr}}).\n$$\n一个偏张量 $\\mathbf{T}$ 的投影 $P_C(\\mathbf{T})$ 就是将其径向返回到半径为 $r_y$ 的球上：$P_C(\\mathbf{T}) = \\min\\left(1, \\frac{r_y}{\\|\\mathbf{T}\\|_F}\\right)\\mathbf{T}$。为保证收敛，步长 $\\alpha$ 必须在 $(0, 2/L)$ 范围内，其中 $L$ 是梯度的 Lipschitz 常数。对于我们的问题，$L=1$，所以任何 $\\alpha \\in (0, 2)$ 都能保证收敛。我们选择 $\\alpha=0.5$ 以保证稳健性，并以 $\\mathbf{s}_0 = \\mathbf{0}$ 进行初始化。迭代持续进行，直到变化量 $\\|\\mathbf{s}_{k+1} - \\mathbf{s}_k\\|_F$ 小于指定的容差。\n\n设收敛后的数值解为 $\\mathbf{s}^\\star_{\\text{num}}$。为了找到相应的塑性乘子 $\\Delta\\gamma_{\\text{num}}$，我们重排应力更新方程 $\\mathbf{s}^\\star_{\\text{num}} = \\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\boldsymbol{\\varepsilon}^p$。与 $\\mathbf{s}^\\star_{\\text{num}}$ 作内积（Frobenius 点积）得到：\n$$\n\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F^2 = \\mathbf{s}^\\star_{\\text{num}}:\\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\gamma_{\\text{num}}\\sqrt{\\frac{3}{2}}\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F.\n$$\n解出 $\\Delta\\gamma_{\\text{num}}$（对于 $\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F > 0$）：\n$$\n\\Delta\\gamma_{\\text{num}} = \\frac{\\mathbf{s}^\\star_{\\text{num}}:\\mathbf{s}^{\\text{tr}} - \\|\\mathbf{s}^\\star_{\\text{num}}\\|_F^2}{2\\mu\\sqrt{3/2}\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F}.\n$$\n这个公式是通用的。如果步是弹性的，数值解会收敛到 $\\mathbf{s}^\\star_{\\text{num}} = \\mathbf{s}^{\\text{tr}}$，导致分子为零，因此 $\\Delta\\gamma_{\\text{num}} = 0$。如果步是塑性的，它提供与数值解一致的值。对于 $\\mathbf{s}^{\\text{tr}}=\\mathbf{0}$，解为 $\\mathbf{s}^\\star_{\\text{num}}=\\mathbf{0}$ 且 $\\Delta\\gamma_{\\text{num}}=0$。全应力为 $\\boldsymbol{\\sigma}_{\\text{num}} = \\mathbf{s}^\\star_{\\text{num}} + p^{\\text{tr}}\\mathbf{I}$。\n\n**验证**\n\n对每个测试用例，我们计算两种方法的结果，并根据两个标准验证其一致性：\n1. 全应力张量 Frobenius 范数的相对差异：$\\frac{\\|\\boldsymbol{\\sigma}_{\\text{num}} - \\boldsymbol{\\sigma}_{\\text{rad}}\\|_F}{\\|\\boldsymbol{\\sigma}_{\\text{rad}}\\|_F} \\le 10^{-10}$。如果 $\\|\\boldsymbol{\\sigma}_{\\text{rad}}\\|_F=0$，则检查绝对差异 $\\|\\boldsymbol{\\sigma}_{\\text{num}}\\|_F$ 是否小于容差。\n2. 塑性乘子之间的相对差异：$\\frac{|\\Delta\\gamma_{\\text{num}} - \\Delta\\gamma_{\\text{rad}}|}{|\\Delta\\gamma_{\\text{rad}}|} \\le 10^{-12}$。如果 $\\Delta\\gamma_{\\text{rad}}=0$，则检查绝对值 $|\\Delta\\gamma_{\\text{num}}|$ 是否小于一个小的容差。\n\n当且仅当两个条件都满足时，报告布尔值 `True`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the J2 plasticity problem using analytical and numerical methods,\n    and verifies their agreement for a suite of test cases.\n    \"\"\"\n\n    # Material constants\n    E = 210e9  # Young's modulus in Pa\n    NU = 0.3   # Poisson's ratio\n    SIGMA_Y = 400e6  # Yield stress in Pa\n    MU = E / (2.0 * (1.0 + NU))  # Shear modulus in Pa\n    # Radius of the yield surface in deviatoric stress space\n    R_Y = np.sqrt(2.0/3.0) * SIGMA_Y\n\n    def get_deviatoric(sigma):\n        \"\"\"Computes the deviatoric part of a 3x3 stress tensor.\"\"\"\n        return sigma - (1.0/3.0) * np.trace(sigma) * np.eye(3)\n\n    def get_pressure(sigma):\n        \"\"\"Computes the hydrostatic pressure from a 3x3 stress tensor.\"\"\"\n        return (1.0/3.0) * np.trace(sigma)\n\n    def frobenius_norm(tensor):\n        \"\"\"Computes the Frobenius norm of a tensor.\"\"\"\n        return np.linalg.norm(tensor, 'fro')\n\n    def solve_analytical(sigma_tr):\n        \"\"\"\n        Computes the updated stress and plastic multiplier using the\n        analytical radial return method.\n        \"\"\"\n        s_tr = get_deviatoric(sigma_tr)\n        p = get_pressure(sigma_tr)\n        \n        norm_s_tr = frobenius_norm(s_tr)\n        \n        # Check if trial stress is inside or on the yield surface\n        yield_func_val = np.sqrt(3.0/2.0) * norm_s_tr - SIGMA_Y\n        \n        if yield_func_val = 1e-12:  # Elastic or on-surface step\n            s_star = s_tr\n            delta_gamma = 0.0\n        else:  # Plastic step\n            s_star = R_Y * s_tr / norm_s_tr\n            delta_gamma = (np.sqrt(3.0/2.0) * norm_s_tr - SIGMA_Y) / (3.0 * MU)\n\n        sigma_star = s_star + p * np.eye(3)\n        return sigma_star, delta_gamma\n\n    def solve_numerical(sigma_tr, alpha=0.5, tol=1e-15, max_iter=1000):\n        \"\"\"\n        Computes the updated stress and plastic multiplier using a\n        projected gradient method.\n        \"\"\"\n        s_tr = get_deviatoric(sigma_tr)\n        p = get_pressure(sigma_tr)\n\n        s_num = np.zeros((3, 3))  # Initial guess s_0 = 0\n\n        for _ in range(max_iter):\n            s_old = s_num\n            # Gradient descent step\n            s_arg = (1.0 - alpha) * s_old + alpha * s_tr\n            \n            # Projection onto the feasible set\n            norm_s_arg = frobenius_norm(s_arg)\n            if norm_s_arg > R_Y:\n                s_num = R_Y * s_arg / norm_s_arg\n            else:\n                s_num = s_arg\n            \n            # Convergence check\n            norm_s_old = frobenius_norm(s_old)\n            if frobenius_norm(s_num - s_old)  tol * (1.0 + norm_s_old):\n                break\n        \n        # Compute the corresponding plastic multiplier\n        norm_s_num = frobenius_norm(s_num)\n        if norm_s_num  1e-15:\n            delta_gamma_num = 0.0\n        else:\n            dot_product = np.sum(s_num * s_tr)  # s_num : s_tr\n            numerator = dot_product - norm_s_num**2\n            denominator = 2.0 * MU * np.sqrt(3.0/2.0) * norm_s_num\n            delta_gamma_num = numerator / denominator\n\n        sigma_num = s_num + p * np.eye(3)\n        return sigma_num, delta_gamma_num\n\n    # Define test cases\n    I = np.eye(3)\n    s1_tr = np.diag([100e6, -50e6, -50e6])\n    p1 = 50e6\n    s2_tr = SIGMA_Y * np.diag([2.0/3.0, -1.0/3.0, -1.0/3.0])\n    p2 = -20e6\n    s3_tr = 1.05 * s2_tr\n    p3 = 30e6\n    a = np.sqrt(3.0/2.0) * R_Y # Corrected 'a' based on problem description\n    s4_tr = np.diag([a, -a, 0.0])\n    p4 = -100e6\n    s7_tr = 1e8 * np.array([[2.0, -1.0,  0.5],\n                             [-1.0, -3.0, 0.2],\n                             [0.5,  0.2, 1.0]])\n    p7 = 15e6\n\n    test_cases_tr = [\n        s1_tr + p1 * I,\n        s2_tr + p2 * I,\n        s3_tr + p3 * I,\n        s4_tr + p4 * I,\n        np.zeros((3, 3)),\n        120e6 * I,\n        s7_tr + p7 * I\n    ]\n\n    results = []\n    \n    TOL_STRESS = 1e-10\n    TOL_GAMMA_REL = 1e-12\n    TOL_GAMMA_ABS = 1e-15\n\n    for sigma_tr in test_cases_tr:\n        # Analytical solution\n        sigma_rad, delta_gamma_rad = solve_analytical(sigma_tr)\n        \n        # Numerical solution\n        sigma_num, delta_gamma_num = solve_numerical(sigma_tr)\n        \n        # Verification\n        # 1. Stress comparison\n        norm_sigma_rad = frobenius_norm(sigma_rad)\n        norm_diff_sigma = frobenius_norm(sigma_num - sigma_rad)\n        \n        if norm_sigma_rad  1e-15:\n            sigma_ok = norm_diff_sigma  TOL_STRESS\n        else:\n            sigma_ok = (norm_diff_sigma / norm_sigma_rad) = TOL_STRESS\n            \n        # 2. Plastic multiplier comparison\n        if abs(delta_gamma_rad)  TOL_GAMMA_ABS:\n            gamma_ok = abs(delta_gamma_num)  TOL_GAMMA_ABS\n        else:\n            gamma_ok = abs(delta_gamma_num - delta_gamma_rad) / abs(delta_gamma_rad) = TOL_GAMMA_REL\n\n        results.append(sigma_ok and gamma_ok)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}