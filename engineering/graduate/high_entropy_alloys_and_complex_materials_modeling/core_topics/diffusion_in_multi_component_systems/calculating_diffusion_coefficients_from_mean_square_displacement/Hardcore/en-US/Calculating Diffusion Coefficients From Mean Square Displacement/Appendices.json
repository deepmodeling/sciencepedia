{
    "hands_on_practices": [
        {
            "introduction": "Molecular dynamics simulations often use Periodic Boundary Conditions (PBC) to approximate a bulk system, but this creates an analytical challenge where particle trajectories are \"wrapped\" back into the primary simulation box. Calculating Mean Squared Displacement (MSD) directly from this wrapped data leads to significant, unphysical errors. This exercise  guides you through the fundamental process of \"unwrapping\" a trajectory using the Minimum Image Convention to reconstruct the true continuous particle motion, an essential prerequisite for any accurate displacement-based analysis.",
            "id": "3465051",
            "problem": "Consider a molecular dynamics style trajectory of a single point particle inside a cubic simulation box of side length $L$ with Periodic Boundary Conditions (PBC). The recorded positions at discrete times are wrapped into the primary simulation cell, and instantaneous displacements are measured under the Minimum Image Convention (MIC). You must explain how these recording rules alter the stored data and design an unwrapping algorithm that reconstructs the continuous trajectory from the wrapped positions such that Mean Squared Displacement (MSD) and the diffusion coefficient are computed accurately.\n\nStart from the following foundational bases:\n- The definition of position as a function of time $x(t)$ and displacement $\\Delta x = x(t+\\Delta t) - x(t)$.\n- The concept of PBC as identifying positions modulo the box length $L$ along each Cartesian coordinate, so that the simulation domain is topologically a three-dimensional torus.\n- The definition of the MSD for a time lag $\\tau$ in $d$ dimensions as the time-origin average of the squared norm of net displacements over $\\tau$, and the relationship between isotropic diffusion and the linear growth in MSD at long times.\n\nYou must not rely on any shortcut formulas beyond these bases. Your implementation must explicitly reconstruct the continuous trajectory by cumulatively adding per-frame displacement increments chosen to be the nearest periodic images under MIC. Then compute a time-averaged MSD curve over available time lags and estimate the diffusion coefficient in the long-time diffusive regime using a statistically sound linear regression approach.\n\nUnits and numerical requirements:\n- All lengths must be in nanometers (nm).\n- All times must be in picoseconds (ps).\n- The diffusion coefficient must be expressed in $\\text{nm}^2/\\text{ps}$.\n- The final reported diffusion coefficients for test cases must be rounded to six decimal places.\n\nYour program must implement the following components:\n- A function that takes an array of wrapped positions in $d$ dimensions and a box length $L$, and returns the unwrapped, continuous positions by cumulatively summing MIC-consistent increments.\n- A function that computes the time-averaged MSD for all integer time lags $k$ from $1$ to a chosen maximum, where the lag time is $\\tau_k = k \\Delta t$ and $\\Delta t$ is the uniform time step between frames.\n- An estimator that, for an isotropic diffusive process in $d$ dimensions, obtains the diffusion coefficient from the slope of the MSD versus $\\tau$ in the long-time regime via linear regression over a specified lag-time interval.\n\nTest suite and parameter specifications:\nImplement and run the following three test cases. In all cases, use a fixed pseudorandom number generator seed $12345$ to ensure reproducibility.\n\n- Test Case $1$ (deterministic drift in one dimension):\n    - Dimension $d = 1$.\n    - Box length $L = 10$ nm.\n    - Time step $\\Delta t = 1$ ps.\n    - Number of frames $N = 12$.\n    - Initial position $x(0) = 0$ nm.\n    - Deterministic velocity $v = 2$ nm/ps, so the true continuous positions are $x(n \\Delta t) = v \\, n \\, \\Delta t$ for integer $n$.\n    - The recorded positions are the wrapped positions into the primary cell under PBC.\n    - Your output for this case is a boolean indicating whether your unwrapping algorithm exactly reconstructs the original continuous positions to within absolute tolerance $10^{-12}$ nm at every frame.\n\n- Test Case $2$ (three-dimensional isotropic Brownian motion with nonzero diffusion):\n    - Dimension $d = 3$.\n    - Box length $L = 8$ nm.\n    - Time step $\\Delta t = 0.5$ ps.\n    - Number of frames $N = 4000$.\n    - True diffusion coefficient $D_{\\text{true}} = 0.05$ $\\text{nm}^2/\\text{ps}$.\n    - Continuous trajectory is generated by independent Gaussian increments per coordinate with zero mean and variance per step consistent with isotropic diffusion in $d$ dimensions over time step $\\Delta t$, starting from the origin.\n    - Positions are recorded as wrapped under PBC.\n    - Unwrap the positions, compute the time-averaged MSD, perform a linear regression of MSD versus lag time $\\tau$ over the interval $\\tau \\in [10, 800]$ ps, and report the estimated diffusion coefficient as a float in $\\text{nm}^2/\\text{ps}$ rounded to six decimal places.\n\n- Test Case $3$ (three-dimensional stationary particle):\n    - Dimension $d = 3$.\n    - Box length $L = 6$ nm.\n    - Time step $\\Delta t = 0.5$ ps.\n    - Number of frames $N = 200$.\n    - True diffusion coefficient $D_{\\text{true}} = 0$ $\\text{nm}^2/\\text{ps}$.\n    - The particle remains at the origin for all times.\n    - Positions are recorded as wrapped under PBC (which leaves all positions unchanged).\n    - Unwrap the positions, compute the time-averaged MSD, perform a linear regression of MSD versus lag time $\\tau$ over the interval $\\tau \\in [1, 50]$ ps, and report the estimated diffusion coefficient as a float in $\\text{nm}^2/\\text{ps}$ rounded to six decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the three test cases: the boolean for Test Case $1$, followed by the diffusion coefficient estimates for Test Case $2$ and Test Case $3$. For example, your output must look like $\\texttt{[True,0.049872,0.000000]}$ with the actual numeric values determined by your implementation and computations.",
            "solution": "The problem requires the development and implementation of a methodology to compute the Mean Squared Displacement (MSD) and estimate the diffusion coefficient from a particle trajectory recorded in a simulation box with Periodic Boundary Conditions (PBC). The core challenge lies in correcting for the artificial coordinate wrapping introduced by PBC before performing the physical analysis.\n\n### Principle-Based Design\n\n#### 1. Periodic Boundary Conditions and Wrapped Coordinates\nIn molecular simulations, PBC are employed to approximate an infinite, bulk system by simulating a finite primary cell that is replicated infinitely in all directions. A particle exiting the primary cell through one face re-enters through the opposite face. This creates a space with the topology of a $d$-dimensional torus.\n\nIf the primary simulation box is a cube of side length $L$, the position of a particle is typically \"wrapped\" into this box. A particle with a continuous, unwrapped position vector $\\mathbf{r}_{\\text{cont}}$ is recorded at its wrapped position $\\mathbf{r}_{\\text{wrap}}$. For each Cartesian coordinate $i \\in \\{x, y, z\\}$, the wrapping is defined by:\n$$\nr_{i, \\text{wrap}} = r_{i, \\text{cont}} \\pmod L\n$$\nMore precisely, this can be written as:\n$$\nr_{i, \\text{wrap}} = r_{i, \\text{cont}} - L \\cdot \\lfloor \\frac{r_{i, \\text{cont}}}{L} \\rfloor\n$$\nThis operation maps any real-valued coordinate into the half-open interval $[0, L)$.\n\n#### 2. The Minimum Image Convention (MIC)\nWhen calculating the displacement between two positions, $\\mathbf{r}_1$ and $\\mathbf{r}_2$, in a periodic system, one must consider not just the displacement vector in the primary cell but the displacement to the closest periodic image. This is the Minimum Image Convention (MIC).\n\nFor a raw displacement component $\\Delta r_i = r_{i,2} - r_{i,1}$, the MIC ensures that the resulting displacement component has a magnitude no larger than $L/2$. The MIC displacement, $\\Delta r_{i, \\text{mic}}$, is calculated as:\n$$\n\\Delta r_{i, \\text{mic}} = \\Delta r_i - L \\cdot \\text{round} \\left( \\frac{\\Delta r_i}{L} \\right)\n$$\nwhere the `round` function rounds its argument to the nearest integer. This formula finds the shortest vector connecting any periodic image of $\\mathbf{r}_2$ to $\\mathbf{r}_1$.\n\n#### 3. Trajectory Unwrapping Algorithm\nIf only wrapped positions $\\mathbf{r}_{\\text{wrap}}(t)$ are stored, naive calculation of displacements, $\\mathbf{r}_{\\text{wrap}}(t_{n+1}) - \\mathbf{r}_{\\text{wrap}}(t_n)$, would produce large, spurious jumps whenever the particle crosses a periodic boundary. This would lead to a grossly overestimated MSD.\n\nTo compute the correct MSD, we must first reconstruct the continuous, unwrapped trajectory $\\mathbf{r}_{\\text{cont}}(t)$. This is achieved by iteratively accumulating displacement increments that are consistent with the MIC. The algorithm proceeds as follows:\n1. Initialize the unwrapped trajectory. The first position is unchanged: $\\mathbf{r}_{\\text{cont}}(t_0) = \\mathbf{r}_{\\text{wrap}}(t_0)$.\n2. For each subsequent time step $n = 1, 2, \\dots, N-1$:\n    a. Calculate the raw displacement between consecutive wrapped positions: $\\Delta \\mathbf{r}_{\\text{raw}} = \\mathbf{r}_{\\text{wrap}}(t_n) - \\mathbf{r}_{\\text{wrap}}(t_{n-1})$.\n    b. Apply the MIC to this raw displacement to find the physically correct displacement increment for that time step: $\\Delta \\mathbf{r}_{\\text{step}} = \\Delta \\mathbf{r}_{\\text{raw}} - L \\cdot \\text{round}(\\Delta \\mathbf{r}_{\\text{raw}} / L)$. This assumes the particle does not move more than $L/2$ in any dimension during a single time step $\\Delta t$, a standard assumption in molecular dynamics.\n    c. Update the continuous position by adding this increment to the previous continuous position: $\\mathbf{r}_{\\text{cont}}(t_n) = \\mathbf{r}_{\\text{cont}}(t_{n-1}) + \\Delta \\mathbf{r}_{\\text{step}}$.\n\nThis procedure reconstructs the true path of the particle in space, without the artificial jumps from PBC.\n\n#### 4. Mean Squared Displacement (MSD) Calculation\nThe MSD measures the average distance a particle travels over a given time interval, or lag time, $\\tau$. For a discrete trajectory of $N$ frames with a uniform time step $\\Delta t$, the lag time is $\\tau_k = k \\Delta t$, where $k$ is the number of frames in the lag. The MSD is computed by averaging the squared displacement over all possible starting times in the trajectory. Using the unwrapped positions, the MSD for a lag time $\\tau_k$ is:\n$$\n\\text{MSD}(\\tau_k) = \\left\\langle \\| \\mathbf{r}_{\\text{cont}}(t + \\tau_k) - \\mathbf{r}_{\\text{cont}}(t) \\|^2 \\right\\rangle_t = \\frac{1}{N-k} \\sum_{n=0}^{N-1-k} \\| \\mathbf{r}_{\\text{cont}}(t_{n+k}) - \\mathbf{r}_{\\text{cont}}(t_n) \\|^2\n$$\nThis calculation is performed for a range of lag indices $k$.\n\n#### 5. Isotropic Diffusion and the Einstein Relation\nFor a particle undergoing isotropic Brownian motion (diffusion) in $d$ dimensions, the MSD is expected to grow linearly with time for sufficiently long lag times. This relationship is given by the Einstein relation:\n$$\n\\lim_{\\tau \\to \\infty} \\text{MSD}(\\tau) = 2dD\\tau\n$$\nwhere $D$ is the diffusion coefficient. In practice, we analyze the \"diffusive regime\" where the MSD curve is approximately linear. By performing a linear regression of the form $\\text{MSD}(\\tau) = m\\tau + c$ on the MSD data over a suitable range of lag times $\\tau$, we can estimate the slope $m$. The diffusion coefficient is then obtained from the slope:\n$$\nD = \\frac{m}{2d}\n$$\nThis procedure forms the basis for estimating the diffusion coefficient from simulation data.\n\nThe implementation will consist of three functions corresponding to these principles: a function to unwrap the trajectory, a function to compute the MSD curve from the unwrapped trajectory, and a function to perform linear regression on the MSD curve to estimate the diffusion coefficient.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results according to the problem specification.\n    \"\"\"\n\n    def generate_wrapped_trajectory_case1(L, dt, N, v):\n        \"\"\"Generates the wrapped trajectory for Test Case 1 (deterministic drift).\"\"\"\n        time = np.arange(N) * dt\n        true_positions = v * time\n        wrapped_positions = true_positions - L * np.floor(true_positions / L)\n        return true_positions.reshape(-1, 1), wrapped_positions.reshape(-1, 1)\n\n    def generate_wrapped_trajectory_case2(L, dt, N, d, D_true, seed):\n        \"\"\"Generates the wrapped trajectory for Test Case 2 (3D Brownian motion).\"\"\"\n        rng = np.random.default_rng(seed)\n        # Variance of displacement per step is 2*D*dt per dimension\n        scale = np.sqrt(2 * D_true * dt)\n        increments = rng.normal(loc=0.0, scale=scale, size=(N - 1, d))\n        # Initial position at origin\n        initial_pos = np.zeros((1, d))\n        true_positions = np.cumsum(np.vstack([initial_pos, increments]), axis=0)\n        wrapped_positions = true_positions - L * np.floor(true_positions / L)\n        return wrapped_positions\n\n    def generate_wrapped_trajectory_case3(N, d):\n        \"\"\"Generates the wrapped trajectory for Test Case 3 (stationary particle).\"\"\"\n        return np.zeros((N, d))\n\n    def unwrap_positions(wrapped_positions, L):\n        \"\"\"\n        Reconstructs the continuous trajectory from wrapped positions.\n\n        Args:\n            wrapped_positions (np.ndarray): Array of shape (N, d) of wrapped positions.\n            L (float): Box length.\n\n        Returns:\n            np.ndarray: Array of shape (N, d) of unwrapped, continuous positions.\n        \"\"\"\n        N, d = wrapped_positions.shape\n        unwrapped_pos = np.zeros_like(wrapped_positions)\n        unwrapped_pos[0] = wrapped_positions[0]\n\n        for i in range(1, N):\n            raw_disp = wrapped_positions[i] - wrapped_positions[i-1]\n            # Apply Minimum Image Convention to find the true displacement increment\n            mic_disp = raw_disp - L * np.round(raw_disp / L)\n            unwrapped_pos[i] = unwrapped_pos[i-1] + mic_disp\n            \n        return unwrapped_pos\n\n    def compute_msd(unwrapped_positions, dt):\n        \"\"\"\n        Computes the time-averaged Mean Squared Displacement (MSD).\n\n        Args:\n            unwrapped_positions (np.ndarray): Array of shape (N, d) of unwrapped positions.\n            dt (float): Time step between frames.\n\n        Returns:\n            tuple: A tuple containing:\n                - msd_values (np.ndarray): 1D array of MSD values for each lag.\n                - lag_times (np.ndarray): 1D array of corresponding lag times (tau).\n        \"\"\"\n        N = unwrapped_positions.shape[0]\n        max_lag_k = N - 1\n        msd_values = np.zeros(max_lag_k)\n\n        for k in range(1, max_lag_k + 1):\n            displacements = unwrapped_positions[k:] - unwrapped_positions[:-k]\n            sq_displacements = np.sum(displacements**2, axis=1)\n            msd_values[k-1] = np.mean(sq_displacements)\n        \n        lag_times = (np.arange(max_lag_k) + 1) * dt\n        return msd_values, lag_times\n\n    def estimate_diffusion(msd_values, lag_times, d, lag_interval):\n        \"\"\"\n        Estimates the diffusion coefficient from an MSD curve via linear regression.\n\n        Args:\n            msd_values (np.ndarray): 1D array of MSD values.\n            lag_times (np.ndarray): 1D array of lag times.\n            d (int): a dimension of the system.\n            lag_interval (tuple): (tau_min, tau_max) for the linear regression.\n\n        Returns:\n            float: The estimated diffusion coefficient.\n        \"\"\"\n        tau_min, tau_max = lag_interval\n        \n        # Find indices corresponding to the lag time interval for regression\n        indices = np.where((lag_times >= tau_min)  (lag_times = tau_max))\n        \n        if len(indices[0])  2:\n            # Not enough points to perform linear regression\n            return 0.0\n\n        taus_fit = lag_times[indices]\n        msds_fit = msd_values[indices]\n\n        # Perform linear regression: MSD = slope * tau + intercept\n        res = linregress(x=taus_fit, y=msds_fit)\n        \n        slope = res.slope\n        \n        # D = slope / (2*d)\n        D_est = slope / (2 * d)\n        \n        return D_est\n\n    # --- Test Cases ---\n    results = []\n    \n    # Test Case 1: Deterministic drift\n    L1, dt1, N1, v1 = 10.0, 1.0, 12, 2.0\n    true_pos1, wrapped_pos1 = generate_wrapped_trajectory_case1(L1, dt1, N1, v1)\n    unwrapped_pos1 = unwrap_positions(wrapped_pos1, L1)\n    is_correct = np.allclose(true_pos1, unwrapped_pos1, atol=1e-12)\n    results.append(is_correct)\n    \n    # Test Case 2: 3D Brownian motion\n    d2, L2, dt2, N2, D_true2, seed = 3, 8.0, 0.5, 4000, 0.05, 12345\n    lag_interval2 = (10.0, 800.0)\n    wrapped_pos2 = generate_wrapped_trajectory_case2(L2, dt2, N2, d2, D_true2, seed)\n    unwrapped_pos2 = unwrap_positions(wrapped_pos2, L2)\n    msd2, lags2 = compute_msd(unwrapped_pos2, dt2)\n    D_est2 = estimate_diffusion(msd2, lags2, d2, lag_interval2)\n    results.append(D_est2)\n    \n    # Test Case 3: 3D stationary particle\n    d3, L3, dt3, N3 = 3, 6.0, 0.5, 200\n    lag_interval3 = (1.0, 50.0)\n    wrapped_pos3 = generate_wrapped_trajectory_case3(N3, d3)\n    unwrapped_pos3 = unwrap_positions(wrapped_pos3, L3)\n    msd3, lags3 = compute_msd(unwrapped_pos3, dt3)\n    D_est3 = estimate_diffusion(msd3, lags3, d3, lag_interval3)\n    results.append(D_est3)\n    \n    # Format and print the final output\n    formatted_results = [\n        str(results[0]),\n        f\"{results[1]:.6f}\",\n        f\"{results[2]:.6f}\"\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a continuous trajectory, the next critical step is to identify the time interval that represents true diffusion, as particle motion in complex materials often involves multiple physical regimes. This practice  moves beyond simple visual inspection by introducing a powerful, data-driven method for analyzing the local scaling exponent, $\\alpha(t) = \\frac{d \\log(\\text{MSD})}{d \\log(t)}$, to automatically detect the ballistic ($\\alpha \\approx 2$), caging ($\\alpha  1$), and diffusive ($\\alpha \\approx 1$) regimes. Mastering this technique allows for a robust and objective estimation of the diffusion coefficient, which is especially crucial in complex systems like amorphous alloys where these regimes may not be cleanly separated.",
            "id": "3731737",
            "problem": "You are given time series of mean square displacement as a function of time, denoted by $MSD(t)$, for structurally disordered, amorphous high-entropy alloys. The goal is to estimate the long-time self-diffusion coefficient $D$ while rigorously excluding contributions from the early-time ballistic regime and the intermediate-time caging regime. Your program must implement a principled, data-adaptive approach that identifies the asymptotically linear regime of $MSD(t)$ without using any fixed, hard-coded time cutoffs.\n\nStarting point and physical bases that you may rely on:\n- For very short times $t$, particle motion retains inertia, with displacements dominated by velocity persistence, and $MSD(t)$ grows approximately as a quadratic function of time.\n- Structural disorder in amorphous systems generates transient “cages” that impede motion, often leading to a near-plateau or sublinear growth of $MSD(t)$ over an intermediate time window.\n- At sufficiently long times, the central limit theorem and loss of memory of initial conditions imply that $MSD(t)$ grows linearly with $t$ in the diffusive regime for an isotropic, homogeneous material in three spatial dimensions.\n\nYour method must:\n1. Detect and exclude both the early-time ballistic and the intermediate-time caging regimes in a data-driven manner by analyzing the local scaling behavior of $MSD(t)$ with respect to $t$. The method must not assume any prior knowledge of the exact cutoff times separating regimes.\n2. Identify a stable time window in which $MSD(t)$ is asymptotically linear with $t$. Within this window, perform a robust line fit of $MSD$ versus $t$ in ordinary (not logarithmic) coordinates.\n3. From the fitted long-time linear behavior in three dimensions, infer the self-diffusion coefficient $D$ and report it in the required units.\n\nMathematical and algorithmic requirements:\n- Use a sliding-window analysis of the local scaling exponent defined by $ \\alpha = \\dfrac{d \\log(MSD)}{d \\log(t)} $ to detect the diffusive regime, where $ \\alpha $ is close to $ 1 $. You must design a quantitative criterion of “sufficiently close” and “sufficiently stable” and justify it algorithmically.\n- Use a robust linear regression for $MSD$ versus $t$ in the candidate diffusive window to mitigate the effect of noise and outliers.\n- Implement a decision rule to choose the final fitting window when multiple candidate windows satisfy your criteria. The rule must prefer windows that are longer and more linear by an appropriate quantitative score.\n- Avoid any fixed, hand-tuned cutoff times expressed directly in time units; all exclusions must be discovered from the data through your criteria.\n\nUnits and output:\n- The input time $t$ is given in picoseconds ($ps$), and the input mean square displacement $MSD$ is given in square nanometers ($nm^2$).\n- You must report the final $D$ in meters squared per second ($m^2/s$).\n- Express the final results as scientific-notation decimal numbers with three significant figures (for example, $1.23 \\times 10^{-8}$ should be printed as $1.23e-08$). The printed format must be a single line containing a comma-separated list enclosed in square brackets, such as $[d_1,d_2,d_3,d_4]$, with no spaces, where each $d_i$ is the estimated diffusion coefficient for the corresponding test case in $m^2/s$.\n\nSynthetic test suite:\nYou must generate four synthetic $MSD(t)$ datasets, each of which is a noisy, smooth composition of three physically motivated components: an early ballistic contribution that decays, a caging plateau that emerges and then decays, and a long-time diffusive growth that turns on gradually. For each dataset, generate a time grid $t_i$ and then construct\n$$\nMSD(t) \\;=\\; v_2\\, t^2 \\, e^{-\\left(\\frac{t}{t_b}\\right)^2}\n\\;+\\; a \\left(1 - e^{-\\left(\\frac{t}{t_c}\\right)^2}\\right) e^{-\\left(\\frac{t}{t_d}\\right)^2}\n\\;+\\; 6 D \\, t \\left(1 - e^{-\\left(\\frac{t}{t_d}\\right)^2}\\right)\n\\;+\\; \\eta,\n$$\nwhere:\n- $t$ is in $ps$,\n- $MSD$ is in $nm^2$,\n- $v_2$ has units $nm^2/ps^2$,\n- $a$ has units $nm^2$,\n- $t_b, t_c, t_d$ have units $ps$,\n- $D$ has units $nm^2/ps$,\n- $\\eta$ is additive zero-mean Gaussian noise with standard deviation $\\sigma$ in $nm^2$; if $MSD(t)$ becomes non-positive at any point due to noise, clip it to a small positive floor $10^{-12}\\,nm^2$ to keep logarithms well-defined.\n\nFor each test case use a uniformly spaced time grid $t_i$ with $N$ points from $t_{\\min}$ to $t_{\\max}$ inclusive, with $t_{\\min} = 10^{-3}\\,ps$. Use the following parameter sets and random seeds to generate the datasets:\n\n- Case $1$ (happy path, clear long diffusive tail):\n  - $N = 1200$, $t_{\\max} = 100$, $v_2 = 0.50$, $a = 0.20$, $t_b = 0.20$, $t_c = 1.00$, $t_d = 5.00$, $D = 0.020$, $\\sigma = 5.0 \\times 10^{-3}$, seed $= 12345$.\n- Case $2$ (extended caging, late-onset diffusion, slower $D$):\n  - $N = 1600$, $t_{\\max} = 200$, $v_2 = 0.70$, $a = 0.50$, $t_b = 0.50$, $t_c = 5.00$, $t_d = 30.0$, $D = 0.0050$, $\\sigma = 3.0 \\times 10^{-3}$, seed $= 24680$.\n- Case $3$ (short trajectory, minimal diffusive window, faster $D$):\n  - $N = 900$, $t_{\\max} = 20.0$, $v_2 = 0.60$, $a = 0.30$, $t_b = 0.80$, $t_c = 3.00$, $t_d = 8.00$, $D = 0.0300$, $\\sigma = 1.0 \\times 10^{-2}$, seed $= 13579$.\n- Case $4$ (noisier data, moderate $D$):\n  - $N = 1400$, $t_{\\max} = 120.0$, $v_2 = 0.40$, $a = 0.25$, $t_b = 0.30$, $t_c = 2.50$, $t_d = 10.0$, $D = 0.0150$, $\\sigma = 2.0 \\times 10^{-2}$, seed $= 11223$.\n\nAll numerical values above are in $ps$ and $nm^2$-based units as indicated. You must convert the final estimated diffusion coefficients to $m^2/s$ using the exact conversion factor $1\\,nm^2/ps = 10^{-6}\\,m^2/s$.\n\nProgram requirements:\n- Implement the data generation and the estimation method exactly as specified.\n- Your program should produce a single line of output containing the results as a comma-separated list of the four estimated diffusion coefficients in $m^2/s$, enclosed in square brackets, with each value printed in scientific notation with three significant figures (e.g., $[2.00e-08,5.00e-09,3.00e-08,1.50e-08]$). No additional text may be printed.",
            "solution": "The ensuing discourse provides a complete solution to the problem of estimating the self-diffusion coefficient from mean square displacement data. The process begins with a mandatory critical validation of the problem statement.\n\n### Step 1: Extract Givens\n\n- **Objective**: Estimate the long-time self-diffusion coefficient $D$ from time series data of mean square displacement, $MSD(t)$.\n- **Physical System**: Structurally disordered, amorphous high-entropy alloys.\n- **Physical Model**: Particle motion exhibits three regimes:\n    1. Early-time ballistic: $MSD(t) \\propto t^2$.\n    2. Intermediate-time caging: Sublinear growth of $MSD(t)$.\n    3. Long-time diffusive: $MSD(t)$ is linear with $t$. For three dimensions, $MSD(t) = 6Dt$.\n- **Core Methodological Constraint**: The method must be data-adaptive, identifying the linear diffusive regime without using fixed, hard-coded time cutoffs.\n- **Algorithmic Requirements**:\n    1. Use a sliding-window analysis of the local scaling exponent $\\alpha = \\frac{d \\log(MSD)}{d \\log(t)}$ to find where $\\alpha \\approx 1$.\n    2. Implement quantitative criteria for \"sufficiently close\" and \"sufficiently stable\" for $\\alpha$.\n    3. Use a robust linear regression for $MSD$ versus $t$ in the identified diffusive window.\n    4. Implement a decision rule to select the best window if multiple candidates exist, favoring longer and more linear windows.\n- **Units and Conversions**:\n    - Input time $t$ is in picoseconds ($ps$).\n    - Input $MSD$ is in square nanometers ($nm^2$).\n    - The final reported $D$ must be in meters squared per second ($m^2/s$).\n    - The conversion factor is $1\\,nm^2/ps = 10^{-6}\\,m^2/s$.\n- **Synthetic Data Generation**:\n    - Formula: $MSD(t) = v_2 t^2 e^{-(t/t_b)^2} + a (1 - e^{-(t/t_c)^2}) e^{-(t/t_d)^2} + 6 D t (1 - e^{-(t/t_d)^2}) + \\eta$.\n    - $\\eta$ is zero-mean Gaussian noise with standard deviation $\\sigma$.\n    - Non-positive $MSD(t)$ values are clipped to a floor of $10^{-12}\\,nm^2$.\n    - Time grid: $N$ points, uniformly spaced from $t_{\\min} = 10^{-3}\\,ps$ to $t_{\\max}$.\n- **Test Cases**: Four specific parameter sets (Case 1, Case 2, Case 3, Case 4) are provided, each with values for $N, t_{\\max}, v_2, a, t_b, t_c, t_d, D, \\sigma$, and a random seed.\n- **Output Format**: A single line containing a comma-separated list of the four diffusion coefficients in $m^2/s$, enclosed in square brackets (e.g., `[d1,d2,d3,d4]`), with each value in scientific notation with three significant figures.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is subjected to rigorous validation.\n\n1.  **Scientific or Factual Unsoundness**: The problem is scientifically sound. It is based on the canonical model of diffusion in disordered systems, which correctly describes ballistic, caged, and diffusive regimes. The use of the Einstein relation, $MSD(t) = 2dDt$ (where the dimensionality $d=3$), and the analysis of the local logarithmic derivative $\\alpha(t)$ are standard, well-established methods in condensed matter physics and statistical mechanics. The synthetic data model is a physically plausible representation of these combined effects.\n2.  **Non-Formalizable or Irrelevant**: The problem is highly formalizable as a numerical analysis task grounded in physics. It is directly and unambiguously related to the specified topic of calculating diffusion coefficients from mean square displacement.\n3.  **Incomplete or Contradictory Setup**: The problem is complete. It provides all necessary parameters, equations, and explicit random seeds to generate the test data deterministically. The requirements for the analysis method and output format are specified in detail, leaving no room for ambiguity. There are no contradictions in the givens.\n4.  **Unrealistic or Infeasible**: The physical parameters and time scales are representative of those found in molecular dynamics simulations of amorphous materials and complex liquids. The task is challenging but entirely feasible with standard numerical libraries.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed. It requests the estimation of a specific parameter ($D$) using a constrained but sensible methodology. The provision of synthetic data with a known ground-truth $D$ allows for a clear success criterion. The core challenge—designing the data-adaptive windowing logic—is a well-defined algorithmic design task, not an ill-posed problem.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is non-trivial. A simple linear fit across the entire dataset would yield an incorrect result due to the contributions of the ballistic and caging regimes. The problem requires a thoughtful implementation of a filtering and selection algorithm that bypasses these non-diffusive portions of the data, which is a common and substantive challenge in real-world data analysis.\n7.  **Outside Scientific Verifiability**: The problem is perfectly verifiable. Given the fixed seeds and deterministic data generation formula, any correct implementation of the algorithm will produce the same set of input data and should yield highly comparable final results.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is scientifically sound, well-posed, and presents a clear, non-trivial challenge that is representative of real-world scientific data analysis. The solution process may proceed.\n\n### Principled Solution Design\n\nThe core objective is to estimate the diffusion coefficient $D$ from the long-time linear regime of the mean square displacement, $MSD(t)$. The relation in three dimensions is given by the Einstein equation:\n$$MSD(t) = 6Dt + C$$\nwhere $C$ is an intercept term. Our task is to isolate the time window where this linear relationship holds and robustly estimate the slope, which is equal to $6D$. The approach must be data-adaptive, avoiding arbitrary time cutoffs.\n\n**Step 1: Local Scaling Exponent Calculation**\n\nTo distinguish the different dynamical regimes, we analyze the local scaling exponent, $\\alpha(t)$, defined as the logarithmic derivative of $MSD(t)$ with respect to $t$:\n$$\\alpha(t) = \\frac{d \\log(MSD(t))}{d \\log(t)}$$\nThis exponent quantifies the power-law relationship $MSD(t) \\sim t^{\\alpha(t)}$ in the vicinity of time $t$. The expected values are $\\alpha \\approx 2$ for the ballistic regime, $\\alpha  1$ (often near $0$) for the caging regime, and $\\alpha \\approx 1$ for the diffusive regime.\n\nDirect numerical differentiation of noisy data is unstable as it amplifies noise. A more robust method is to compute $\\alpha(t_i)$ at each point $t_i$ by performing a linear regression on $\\log(MSD)$ versus $\\log(t)$ within a sliding window of points centered at $t_i$. The slope of this local fit provides a smoothed estimate of $\\alpha_i$. We choose a fixed window size of $51$ points for this calculation, which is large enough to average out noise but small enough to resolve changes in dynamical regimes for the given data density.\n\n**Step 2: Identification of Candidate Diffusive Windows**\n\nThe diffusive regime is characterized by $\\alpha(t) \\approx 1$. We define a quantitative criterion for this condition: we identify all time points $t_i$ where the calculated exponent $\\alpha_i$ falls within a tolerance band around $1$. We set this as:\n$$| \\alpha_i - 1.0 |  \\delta_{\\alpha}$$\nA tolerance of $\\delta_{\\alpha} = 0.1$ is chosen, identifying points where the local scaling is between $t^{0.9}$ and $t^{1.1}$.\n\nTo ensure stability and statistical significance, we are not interested in isolated points that satisfy this criterion but rather in contiguous segments of sufficient length. We find all contiguous blocks of indices where the condition holds and discard any block that is shorter than a minimum length. This minimum length is set to $10\\%$ of the total number of data points, $N$, ensuring any subsequent linear fit is performed on a substantial portion of the trajectory.\n\n**Step 3: Robust Regression and Final Window Selection**\n\nFor each candidate window identified, a linear fit of $MSD$ versus $t$ is performed. As the data contains noise, a robust regression method is superior to standard ordinary least squares. We employ the Theil-Sen estimator, a non-parametric method that is highly robust to outliers. It calculates the slope as the median of the slopes of lines connecting all pairs of points in the dataset. This provides a reliable estimate of the slope $m = 6D$.\n\nThe problem requires a rule to select the best window if multiple candidates are found. The chosen rule is: select the **longest** contiguous window that satisfies the $\\alpha$-criterion. This prioritizes the most stable and extended exhibition of diffusive behavior. In the rare event of a tie in length, the window that occurs latest in time is selected, as this best represents the true asymptotic, long-time behavior of the system.\n\n**Step 4: Diffusion Coefficient Calculation and Unit Conversion**\n\nOnce the optimal window is selected and the robust slope $m$ is estimated using `scipy.stats.theilslopes`:\n1.  The diffusion coefficient in simulation units is calculated as:\n    $$D_{\\text{sim}} = \\frac{m}{6}$$\n    The units of $D_{\\text{sim}}$ are $nm^2/ps$.\n2.  This value is converted to the required SI units of $m^2/s$ using the provided conversion factor:\n    $$D_{\\text{SI}} [m^2/s] = D_{\\text{sim}} [nm^2/ps] \\times 10^{-6}$$\n3.  The final result is formatted to scientific notation with three significant figures.\n\nThis self-contained, data-driven procedure robustly extracts the diffusion coefficient by systematically identifying the physically correct time regime for analysis, fully satisfying the problem's constraints.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import theilslopes\n\ndef solve():\n    \"\"\"\n    Main function to generate data, run the analysis for all test cases,\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, clear long diffusive tail)\n        {'N': 1200, 't_max': 100.0, 'v_2': 0.50, 'a': 0.20, 't_b': 0.20,\n         't_c': 1.00, 't_d': 5.00, 'D': 0.020, 'sigma': 5.0e-3, 'seed': 12345},\n\n        # Case 2 (extended caging, late-onset diffusion, slower D)\n        {'N': 1600, 't_max': 200.0, 'v_2': 0.70, 'a': 0.50, 't_b': 0.50,\n         't_c': 5.00, 't_d': 30.0, 'D': 0.0050, 'sigma': 3.0e-3, 'seed': 24680},\n\n        # Case 3 (short trajectory, minimal diffusive window, faster D)\n        {'N': 900, 't_max': 20.0, 'v_2': 0.60, 'a': 0.30, 't_b': 0.80,\n         't_c': 3.00, 't_d': 8.00, 'D': 0.0300, 'sigma': 1.0e-2, 'seed': 13579},\n\n        # Case 4 (noisier data, moderate D)\n        {'N': 1400, 't_max': 120.0, 'v_2': 0.40, 'a': 0.25, 't_b': 0.30,\n         't_c': 2.50, 't_d': 10.0, 'D': 0.0150, 'sigma': 2.0e-2, 'seed': 11223},\n    ]\n\n    results = []\n    for params in test_cases:\n        t, msd = generate_msd_data(**params)\n        D_si = estimate_diffusion_coefficient(t, msd)\n        results.append(D_si)\n\n    # Format and print the final output exactly as required.\n    print(f\"[{','.join(f'{d:.2e}' for d in results)}]\")\n\ndef generate_msd_data(N, t_max, v_2, a, t_b, t_c, t_d, D, sigma, seed, t_min=1e-3):\n    \"\"\"\n    Generates synthetic MSD data based on the provided formula and parameters.\n    \"\"\"\n    np.random.seed(seed)\n    \n    t = np.linspace(t_min, t_max, N)\n    \n    # Ballistic term\n    msd_ballistic = v_2 * t**2 * np.exp(-(t / t_b)**2)\n    \n    # Caging term\n    msd_caging = a * (1 - np.exp(-(t / t_c)**2)) * np.exp(-(t / t_d)**2)\n    \n    # Diffusive term\n    msd_diffusive = 6 * D * t * (1 - np.exp(-(t / t_d)**2))\n    \n    msd_clean = msd_ballistic + msd_caging + msd_diffusive\n    \n    # Add Gaussian noise\n    noise = np.random.normal(0, sigma, N)\n    msd_noisy = msd_clean + noise\n    \n    # Clip non-positive values to prevent log(0) or log(0) issues\n    msd = np.maximum(msd_noisy, 1e-12)\n    \n    return t, msd\n\ndef estimate_diffusion_coefficient(t, msd):\n    \"\"\"\n    Estimates the diffusion coefficient using a data-adaptive windowing method.\n    \"\"\"\n    N = len(t)\n    \n    # --- Step 1: Calculate local scaling exponent alpha(t) ---\n    # Use a sliding window to perform log-log fits for noise robustness.\n    # The chosen window size must be an odd integer.\n    alpha_window_size = 51 \n    half_window = alpha_window_size // 2\n    \n    alphas = np.full(N, np.nan)\n    \n    log_t = np.log(t)\n    log_msd = np.log(msd)\n    \n    for i in range(half_window, N - half_window):\n        # Define the window for the local fit\n        start, end = i - half_window, i + half_window + 1\n        \n        # polyfit(x, y, 1) returns [slope, intercept]\n        slope, _ = np.polyfit(log_t[start:end], log_msd[start:end], 1)\n        alphas[i] = slope\n\n    # --- Step 2: Identify candidate diffusive windows ---\n    alpha_tolerance = 0.1\n    min_window_frac = 0.1\n    min_len = int(min_window_frac * N)\n\n    # Find indices where alpha is close to 1\n    diffusive_indices = np.where(np.abs(alphas - 1.0)  alpha_tolerance)[0]\n\n    if len(diffusive_indices) == 0:\n        # Fallback if no window is found - this shouldn't happen with the test data\n        return np.nan\n\n    # Group consecutive indices into windows\n    candidate_windows = []\n    if len(diffusive_indices) > 0:\n        # Split a list of indices into sub-lists of consecutive numbers\n        splits = np.where(np.diff(diffusive_indices) != 1)[0] + 1\n        contiguous_blocks = np.split(diffusive_indices, splits)\n        \n        for block in contiguous_blocks:\n            if len(block) >= min_len:\n                candidate_windows.append(block)\n\n    if not candidate_windows:\n        # If no window meets the minimum length, try relaxing criteria (not done here as it's not needed for the given problem)\n        return np.nan # Or handle error appropriately\n\n    # --- Step 3: Select the best window ---\n    # Rule: Choose the longest window. If tied, choose the one latest in time.\n    best_window = max(candidate_windows, key=lambda w: (len(w), w[-1]))\n    \n    t_window = t[best_window]\n    msd_window = msd[best_window]\n\n    # --- Step 4: Perform robust linear regression ---\n    # Use Theil-Sen estimator on the selected window (MSD vs t)\n    # theilslopes returns (slope, intercept, low_slope, high_slope)\n    slope, _, _, _ = theilslopes(y=msd_window, x=t_window)\n    \n    # --- Step 5: Calculate D and convert units ---\n    # D_sim = slope / (2 * dimensions), here dimensions=3\n    D_sim = slope / 6.0  # units: nm^2 / ps\n    \n    # Conversion factor from nm^2/ps to m^2/s\n    # 1 nm^2/ps = (10^-9 m)^2 / (10^-12 s) = 10^-18 m^2 / 10^-12 s = 10^-6 m^2/s\n    conversion_factor = 1e-6\n    D_si = D_sim * conversion_factor # units: m^2 / s\n    \n    return D_si\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "The diffusion coefficient calculated directly from simulation data is often expressed in abstract, reduced units, such as Lennard-Jones (LJ) units, which are convenient for computation but not for direct physical interpretation. This final exercise  bridges the gap between simulation and reality by tasking you with performing the dimensional analysis required to convert a diffusion coefficient from LJ units to standard SI units ($\\mathrm{m^2/s}$). This skill is indispensable for comparing computational predictions with experimental measurements and for reporting physically meaningful results.",
            "id": "3731785",
            "problem": "A molecular dynamics study of a five-component equiatomic high-entropy alloy is conducted using reduced Lennard–Jones (LJ) units based on a single effective reference triplet of scales: the reference length $\\sigma_{\\mathrm{ref}}$, the reference energy $\\epsilon_{\\mathrm{ref}}$, and the reference mass $m_{\\mathrm{ref}}$. The simulation yields, in the long-time diffusive regime, a linear increase of the ensemble-averaged Mean Square Displacement (MSD) with dimensionless time. The slope of the MSD versus time in reduced units is measured to be $s^{*} = 0.12$, where the MSD is $\\langle \\Delta r^{*2} \\rangle$ and time is $t^{*}$. The system is isotropic and three-dimensional, and finite-size effects are negligible. The LJ reduced units are anchored to the following physically motivated effective scales that are consistent with the alloy’s composition and thermodynamic state: $\\sigma_{\\mathrm{ref}} = 2.50\\,\\mathrm{\\AA}$, $\\epsilon_{\\mathrm{ref}}/k_{\\mathrm{B}} = 2000\\,\\mathrm{K}$, and $m_{\\mathrm{ref}} = 59.0\\,\\mathrm{amu}$. Here, $k_{\\mathrm{B}}$ is the Boltzmann constant and $\\mathrm{amu}$ denotes the atomic mass unit.\n\nStarting from first principles, use dimensional analysis of Newton’s second law together with the definition of Mean Square Displacement to establish the conversion required to map the reduced MSD slope $s^{*}$ into the physical slope $s$ in International System of Units (SI), and then to the diffusion coefficient $D$ in SI units. Take $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$ and $1\\,\\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$. Express your final result for the diffusion coefficient $D$ in $\\mathrm{m^{2}/s}$ and round your answer to four significant figures. The final answer must be a single number.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- Simulation type: Molecular dynamics of a five-component equiatomic high-entropy alloy.\n- System of units: Reduced Lennard-Jones (LJ) units based on a reference triplet of scales: $\\sigma_{\\mathrm{ref}}$, $\\epsilon_{\\mathrm{ref}}$, $m_{\\mathrm{ref}}$.\n- Reduced slope of Mean Square Displacement (MSD) versus time: $s^{*} = \\frac{d \\langle \\Delta r^{*2} \\rangle}{dt^{*}} = 0.12$.\n- System dimensionality: Three-dimensional ($d=3$).\n- System property: Isotropic.\n- Assumption: Finite-size effects are negligible.\n- Reference length scale: $\\sigma_{\\mathrm{ref}} = 2.50\\,\\mathrm{\\AA}$.\n- Reference energy scale (effective): $\\epsilon_{\\mathrm{ref}}/k_{\\mathrm{B}} = 2000\\,\\mathrm{K}$.\n- Reference mass scale: $m_{\\mathrm{ref}} = 59.0\\,\\mathrm{amu}$.\n- Boltzmann constant: $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$.\n- Atomic mass unit: $1\\,\\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$.\n- Required output: Diffusion coefficient $D$ in SI units ($\\mathrm{m^2/s}$), rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, describing a standard practice in computational materials science for calculating transport coefficients. The relationship between the Mean Square Displacement and the diffusion coefficient is a fundamental result from statistical mechanics (the Einstein relation). The use of reduced Lennard-Jones units is a ubiquitous technique in molecular dynamics simulations to ensure generality and computational stability. The provided values for the reference scales ($\\sigma_{\\mathrm{ref}}$, $\\epsilon_{\\mathrm{ref}}$, $m_{\\mathrm{ref}}$) are physically realistic for metallic alloys. The problem is well-posed, providing all necessary information to establish a unique and meaningful numerical solution. The problem statement is objective, precise, and free of contradictions or ambiguities.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid. A solution will be provided.\n\nThe solution requires establishing the relationship between the dimensionless quantities from the simulation and their physical counterparts in SI units.\n\nFirst, we establish the fundamental reduced units. Any physical quantity $Q$ is related to its dimensionless (reduced) counterpart $Q^{*}$ by a characteristic reference scale $Q_{\\mathrm{ref}}$, such that $Q = Q_{\\mathrm{ref}} Q^{*}$.\nThe primary reference scales are given for length ($L$), mass ($M$), and energy ($E$):\n- Length: $r = \\sigma_{\\mathrm{ref}} r^{*}$\n- Mass: $m = m_{\\mathrm{ref}} m^{*}$\n- Energy: $\\mathcal{E} = \\epsilon_{\\mathrm{ref}} \\mathcal{E}^{*}$\n\nThe reference time scale, $\\tau_{\\mathrm{ref}}$, is not given directly but can be derived from the three primary scales using dimensional analysis of Newton's second law, $F = ma$. The characteristic force, $F_{\\mathrm{ref}}$, can be derived from the energy and length scales, as force is the negative gradient of potential energy:\n$$ [F_{\\mathrm{ref}}] = \\frac{[\\mathcal{E}_{\\mathrm{ref}}]}{[L_{\\mathrm{ref}}]} = \\frac{\\epsilon_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}}} $$\nFrom Newton's second law, the characteristic force is also given by:\n$$ [F_{\\mathrm{ref}}] = [M_{\\mathrm{ref}}][a_{\\mathrm{ref}}] = m_{\\mathrm{ref}} \\frac{L_{\\mathrm{ref}}}{T_{\\mathrm{ref}}^2} = m_{\\mathrm{ref}} \\frac{\\sigma_{\\mathrm{ref}}}{\\tau_{\\mathrm{ref}}^2} $$\nEquating these two expressions for $F_{\\mathrm{ref}}$:\n$$ \\frac{\\epsilon_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}}} = m_{\\mathrm{ref}} \\frac{\\sigma_{\\mathrm{ref}}}{\\tau_{\\mathrm{ref}}^2} $$\nSolving for the reference time scale $\\tau_{\\mathrm{ref}}$ yields:\n$$ \\tau_{\\mathrm{ref}}^2 = \\frac{m_{\\mathrm{ref}} \\sigma_{\\mathrm{ref}}^2}{\\epsilon_{\\mathrm{ref}}} \\implies \\tau_{\\mathrm{ref}} = \\sigma_{\\mathrm{ref}} \\sqrt{\\frac{m_{\\mathrm{ref}}}{\\epsilon_{\\mathrm{ref}}}} $$\nTherefore, physical time $t$ is related to reduced time $t^{*}$ by $t = \\tau_{\\mathrm{ref}} t^{*}$.\n\nNext, we consider the Einstein relation for diffusion in a three-dimensional isotropic system. In the long-time limit, the Mean Square Displacement, $\\langle \\Delta r^2(t) \\rangle$, is linearly proportional to time $t$:\n$$ \\langle \\Delta r^2(t) \\rangle = 6Dt $$\nwhere $D$ is the diffusion coefficient. The slope of the physical MSD versus time plot is $s$:\n$$ s = \\frac{d\\langle \\Delta r^2(t) \\rangle}{dt} = 6D $$\nThus, the diffusion coefficient can be found via $D = s/6$.\n\nThe problem provides the slope in reduced units, $s^{*} = 0.12$. We must convert this to the physical slope $s$.\n$$ s^{*} = \\frac{d\\langle \\Delta r^{*2} \\rangle}{dt^{*}} $$\nThe physical MSD is related to the reduced MSD by $\\langle \\Delta r^2 \\rangle = \\sigma_{\\mathrm{ref}}^2 \\langle \\Delta r^{*2} \\rangle$. The physical time is related to the reduced time by $t = \\tau_{\\mathrm{ref}} t^{*}$.\nWe can now express the physical slope $s$ in terms of reduced quantities:\n$$ s = \\frac{d\\langle \\Delta r^2 \\rangle}{dt} = \\frac{d(\\sigma_{\\mathrm{ref}}^2 \\langle \\Delta r^{*2} \\rangle)}{d(\\tau_{\\mathrm{ref}} t^{*})} $$\nSince $\\sigma_{\\mathrm{ref}}$ and $\\tau_{\\mathrm{ref}}$ are constants, they can be factored out of the differentiation:\n$$ s = \\frac{\\sigma_{\\mathrm{ref}}^2}{\\tau_{\\mathrm{ref}}} \\frac{d\\langle \\Delta r^{*2} \\rangle}{dt^{*}} = \\frac{\\sigma_{\\mathrm{ref}}^2}{\\tau_{\\mathrm{ref}}} s^{*} $$\nSubstituting the expression for $\\tau_{\\mathrm{ref}}$:\n$$ s = s^{*} \\frac{\\sigma_{\\mathrm{ref}}^2}{\\sigma_{\\mathrm{ref}} \\sqrt{m_{\\mathrm{ref}}/\\epsilon_{\\mathrm{ref}}}} = s^{*} \\sigma_{\\mathrm{ref}} \\sqrt{\\frac{\\epsilon_{\\mathrm{ref}}}{m_{\\mathrm{ref}}}} $$\nThe diffusion coefficient $D$ is then:\n$$ D = \\frac{s}{6} = \\frac{s^{*}}{6} \\sigma_{\\mathrm{ref}} \\sqrt{\\frac{\\epsilon_{\\mathrm{ref}}}{m_{\\mathrm{ref}}}} $$\nThis is the final symbolic expression for the diffusion coefficient.\n\nNow, we substitute the numerical values in SI units.\nFirst, convert the reference scales to SI units:\n- $\\sigma_{\\mathrm{ref}} = 2.50\\,\\mathrm{\\AA} = 2.50 \\times 10^{-10}\\,\\mathrm{m}$.\n- $\\epsilon_{\\mathrm{ref}} = 2000\\,\\mathrm{K} \\times k_{\\mathrm{B}} = 2000\\,\\mathrm{K} \\times (1.380649 \\times 10^{-23}\\,\\mathrm{J/K}) = 2.761298 \\times 10^{-20}\\,\\mathrm{J}$.\n- $m_{\\mathrm{ref}} = 59.0\\,\\mathrm{amu} = 59.0 \\times (1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}) = 9.797180493 \\times 10^{-26}\\,\\mathrm{kg}$.\n\nNow, substitute these values into the expression for $D$:\n$$ D = \\frac{0.12}{6} \\left( 2.50 \\times 10^{-10}\\,\\mathrm{m} \\right) \\sqrt{\\frac{2.761298 \\times 10^{-20}\\,\\mathrm{J}}{9.797180493 \\times 10^{-26}\\,\\mathrm{kg}}} $$\n$$ D = 0.02 \\times (2.50 \\times 10^{-10}\\,\\mathrm{m}) \\times \\sqrt{281845.03\\,\\mathrm{m^2/s^2}} $$\n$$ D = 0.02 \\times (2.50 \\times 10^{-10}\\,\\mathrm{m}) \\times (530.89079\\,\\mathrm{m/s}) $$\n$$ D = (5.0 \\times 10^{-12}\\,\\mathrm{m}) \\times (530.89079\\,\\mathrm{m/s}) $$\n$$ D = 2.65445395 \\times 10^{-9}\\,\\mathrm{m^2/s} $$\nThe problem requires the answer to be rounded to four significant figures.\n$$ D \\approx 2.654 \\times 10^{-9}\\,\\mathrm{m^2/s} $$",
            "answer": "$$\\boxed{2.654 \\times 10^{-9}}$$"
        }
    ]
}