{
    "hands_on_practices": [
        {
            "introduction": "在分子动力学模拟中，为了模拟体相材料，通常会使用周期性边界条件（PBC）。然而，这导致原始轨迹数据中的原子坐标被人为地“折叠”回主模拟盒子中，直接使用这些坐标计算均方位移（MSD）会产生严重错误。本实践将指导您完成一个关键的数据预处理步骤：通过实现一个轨迹“解缠绕”算法，来重建原子的真实连续运动路径，为精确计算MSD奠定基础。",
            "id": "3465051",
            "problem": "考虑一个点粒子在边长为 $L$ 的立方模拟盒子中进行分子动力学式运动的轨迹，该系统采用周期性边界条件（PBC）。记录的离散时间点上的位置被包裹在主模拟单元内，瞬时位移则根据最小镜像约定（MIC）进行测量。您必须解释这些记录规则如何改变存储的数据，并设计一个解包裹算法，从包裹后的位置重建连续轨迹，以便精确计算均方​​位移（MSD）和扩散系数。\n\n从以下基本概念出发：\n- 位置是时间的函数 $x(t)$ 以及位移 $\\Delta x = x(t+\\Delta t) - x(t)$ 的定义。\n- PBC 的概念，即沿着每个笛卡尔坐标，位置对盒子长度 $L$ 取模，因此模拟区域在拓扑上是一个三维环面。\n- 在 $d$ 维空间中，对于时间延迟 $\\tau$，MSD 的定义为在 $\\tau$ 时间段内净位移平方范数的时间原点平均值，以及各向同性扩散与 MSD 在长时间尺度上线性增长之间的关系。\n\n您不得依赖于这些基础之外的任何快捷公式。您的实现必须通过累加根据 MIC 选择的最近周期性镜像的逐帧位移增量，来明确地重建连续轨迹。然后，计算可用时间延迟下的时间平均 MSD 曲线，并使用统计上稳健的线性回归方法，在长时间扩散区间内估计扩散系数。\n\n单位和数值要求：\n- 所有长度单位必须是纳米（nm）。\n- 所有时间单位必须是皮秒（ps）。\n- 扩散系数必须以 $\\text{nm}^2/\\text{ps}$ 表示。\n- 测试用例的最终报告扩散系数必须四舍五入到六位小数。\n\n您的程序必须实现以下组件：\n- 一个函数，它接受一个 $d$ 维包裹位置数组和盒子长度 $L$ 作为输入，通过累加符合 MIC 的增量，返回解包裹后的连续位置。\n- 一个函数，它为从 $1$ 到选定最大值的所有整数时间延迟 $k$ 计算时间平均 MSD，其中延迟时间为 $\\tau_k = k \\Delta t$，$\\Delta t$ 是帧之间的均匀时间步长。\n- 一个估计器，对于 $d$ 维各向同性扩散过程，通过在指定的时间延迟间隔上对 MSD 与 $\\tau$ 的关系进行线性回归，从长时间范围内的斜率中获取扩散系数。\n\n测试套件和参数规格：\n实现并运行以下三个测试用例。在所有用例中，使用固定的伪随机数生成器种子 $12345$ 以确保可复现性。\n\n- 测试用例 $1$（一维确定性漂移）：\n    - 维度 $d = 1$。\n    - 盒子长度 $L = 10$ nm。\n    - 时间步长 $\\Delta t = 1$ ps。\n    - 帧数 $N = 12$。\n    - 初始位置 $x(0) = 0$ nm。\n    - 确定性速度 $v = 2$ nm/ps，因此对于整数 $n$，真实的连续位置为 $x(n \\Delta t) = v \\, n \\, \\Delta t$。\n    - 记录的位置是在 PBC 下包裹到主单元中的位置。\n    - 您在此用例的输出是一个布尔值，表示您的解包裹算法是否在每一帧都以 $10^{-12}$ nm 的绝对公差内精确重建了原始连续位置。\n\n- 测试用例 $2$（具有非零扩散的三维各向同性布朗运动）：\n    - 维度 $d = 3$。\n    - 盒子长度 $L = 8$ nm。\n    - 时间步长 $\\Delta t = 0.5$ ps。\n    - 帧数 $N = 4000$。\n    - 真实扩散系数 $D_{\\text{true}} = 0.05$ $\\text{nm}^2/\\text{ps}$。\n    - 连续轨迹是通过每个坐标上的独立高斯增量生成的，从原点开始，每步的均值为零，方差与 $d$ 维各向同性扩散在时间步长 $\\Delta t$ 内的表现一致。\n    - 位置在 PBC 下被包裹记录。\n    - 解包裹位置，计算时间平均 MSD，在时间间隔 $\\tau \\in [10, 800]$ ps 内对 MSD 与延迟时间 $\\tau$ 进行线性回归，并报告估计的扩散系数，以 $\\text{nm}^2/\\text{ps}$ 为单位的浮点数形式，四舍五入到六位小数。\n\n- 测试用例 $3$（三维静止粒子）：\n    - 维度 $d = 3$。\n    - 盒子长度 $L = 6$ nm。\n    - 时间步长 $\\Delta t = 0.5$ ps。\n    - 帧数 $N = 200$。\n    - 真实扩散系数 $D_{\\text{true}} = 0$ $\\text{nm}^2/\\text{ps}$。\n    - 粒子在所有时间点都保持在原点。\n    - 位置在 PBC 下被包裹记录（这使得所有位置保持不变）。\n    - 解包裹位置，计算时间平均 MSD，在时间间隔 $\\tau \\in [1, 50]$ ps 内对 MSD 与延迟时间 $\\tau$ 进行线性回归，并报告估计的扩散系数，以 $\\text{nm}^2/\\text{ps}$ 为单位的浮点数形式，四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按三个测试用例的顺序排列结果：测试用例 1 的布尔值，后跟测试用例 2 和测试用例 3 的扩散系数估计值。例如，您的输出必须类似于 $\\texttt{[True,0.049872,0.000000]}$，其中的实际数值由您的实现和计算确定。",
            "solution": "该问题要求开发并实现一种方法，用于从在具有周期性边界条件（PBC）的模拟盒子中记录的粒子轨迹计算均方​​位移（MSD）并估计扩散系数。核心挑战在于，在进行物理分析之前，校正由 PBC 引入的人为坐标包裹。\n\n### 基于原理的设计\n\n#### 1. 周期性边界条件与包裹坐标\n在分子模拟中，采用 PBC 通过模拟一个在所有方向上无限复制的有限主单元来近似一个无限的体相系统。粒子从主单元的一个面穿出后，会从相对的面重新进入。这创建了一个具有 $d$ 维环面拓扑结构的空间。\n\n如果主模拟盒子是边长为 $L$ 的立方体，粒子的位置通常会被“包裹”到这个盒子中。具有连续、未包裹位置向量 $\\mathbf{r}_{\\text{cont}}$ 的粒子，其记录位置为其包裹后位置 $\\mathbf{r}_{\\text{wrap}}$。对于每个笛卡尔坐标 $i \\in \\{x, y, z\\}$，包裹操作定义如下：\n$$\nr_{i, \\text{wrap}} = r_{i, \\text{cont}} \\pmod L\n$$\n更精确地，可以写成：\n$$\nr_{i, \\text{wrap}} = r_{i, \\text{cont}} - L \\cdot \\lfloor \\frac{r_{i, \\text{cont}}}{L} \\rfloor\n$$\n此操作将任何实数值坐标映射到半开区间 $[0, L)$ 中。\n\n#### 2. 最小镜像约定（MIC）\n在周期性系统中计算两个位置 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 之间的位移时，必须不仅考虑主单元内的位移向量，还要考虑到位移到最近周期性镜像的向量。这就是最小镜像约定（MIC）。\n\n对于原始位移分量 $\\Delta r_i = r_{i,2} - r_{i,1}$，MIC 确保最终的位移分量大小不超过 $L/2$。MIC 位移 $\\Delta r_{i, \\text{mic}}$ 计算如下：\n$$\n\\Delta r_{i, \\text{mic}} = \\Delta r_i - L \\cdot \\text{round} \\left( \\frac{\\Delta r_i}{L} \\right)\n$$\n其中 `round` 函数将其参数四舍五入到最近的整数。此公式用于找到连接 $\\mathbf{r}_2$ 的任意周期性镜像到 $\\mathbf{r}_1$ 的最短向量。\n\n#### 3. 轨迹解包裹算法\n如果只存储了包裹后的位置 $\\mathbf{r}_{\\text{wrap}}(t)$，那么对位移的天真计算，即 $\\mathbf{r}_{\\text{wrap}}(t_{n+1}) - \\mathbf{r}_{\\text{wrap}}(t_n)$，会在粒子每次穿过周期性边界时产生巨大的伪跳跃。这将导致 MSD 被严重高估。\n\n为了计算正确的 MSD，我们必须首先重建连续、未包裹的轨迹 $\\mathbf{r}_{\\text{cont}}(t)$。这可以通过迭代累加符合 MIC 的位移增量来实现。算法流程如下：\n1. 初始化解包裹后的轨迹。第一个位置保持不变：$\\mathbf{r}_{\\text{cont}}(t_0) = \\mathbf{r}_{\\text{wrap}}(t_0)$。\n2. 对于每个后续的时间步 $n = 1, 2, \\dots, N-1$：\n    a. 计算连续包裹位置之间的原始位移：$\\Delta \\mathbf{r}_{\\text{raw}} = \\mathbf{r}_{\\text{wrap}}(t_n) - \\mathbf{r}_{\\text{wrap}}(t_{n-1})$。\n    b. 对此原始位移应用 MIC，以找到该时间步内物理上正确的位移增量：$\\Delta \\mathbf{r}_{\\text{step}} = \\Delta \\mathbf{r}_{\\text{raw}} - L \\cdot \\text{round}(\\Delta \\mathbf{r}_{\\text{raw}} / L)$。这假设粒子在单个时间步长 $\\Delta t$ 内在任何维度上的移动距离都不超过 $L/2$，这是分子动力学中的一个标准假设。\n    c. 通过将此增量加到前一个连续位置上，来更新当前连续位置：$\\mathbf{r}_{\\text{cont}}(t_n) = \\mathbf{r}_{\\text{cont}}(t_{n-1}) + \\Delta \\mathbf{r}_{\\text{step}}$。\n\n这个过程重建了粒子在空间中的真实路径，消除了由 PBC 引起的人为跳跃。\n\n#### 4. 均方​​位移（MSD）计算\nMSD 衡量粒子在给定时间间隔（或称延迟时间）$\\tau$ 内移动的平均距离。对于一个有 $N$ 帧、均匀时间步长为 $\\Delta t$ 的离散轨迹，延迟时间为 $\\tau_k = k \\Delta t$，其中 $k$ 是延迟中的帧数。MSD 是通过对轨迹中所有可能的起始时间的平方位移进行平均来计算的。使用解包裹后的位置，对于延迟时间 $\\tau_k$ 的 MSD 为：\n$$\n\\text{MSD}(\\tau_k) = \\left\\langle \\| \\mathbf{r}_{\\text{cont}}(t + \\tau_k) - \\mathbf{r}_{\\text{cont}}(t) \\|^2 \\right\\rangle_t = \\frac{1}{N-k} \\sum_{n=0}^{N-1-k} \\| \\mathbf{r}_{\\text{cont}}(t_{n+k}) - \\mathbf{r}_{\\text{cont}}(t_n) \\|^2\n$$\n此计算针对一系列延迟指数 $k$ 进行。\n\n#### 5. 各向同性扩散与爱因斯坦关系式\n对于在 $d$ 维空间中进行各向同性布朗运动（扩散）的粒子，当延迟时间足够长时，MSD 预期会随时间线性增长。此关系由爱因斯坦关系式给出：\n$$\n\\lim_{\\tau \\to \\infty} \\text{MSD}(\\tau) = 2dD\\tau\n$$\n其中 $D$ 是扩散系数。在实践中，我们分析 MSD 曲线近似线性的“扩散区域”。通过在合适的时间延迟 $\\tau$ 范围内，对 MSD 数据进行 $\\text{MSD}(\\tau) = m\\tau + c$ 形式的线性回归，我们可以估计斜率 $m$。然后从斜率中获得扩散系数：\n$$\nD = \\frac{m}{2d}\n$$\n该过程构成了从模拟数据中估计扩散系数的基础。\n\n实现将包括与这些原理相对应的三个函数：一个用于解包裹轨迹的函数，一个用于从解包裹后的轨迹计算 MSD 曲线的函数，以及一个用于对 MSD 曲线执行线性回归以估计扩散系数的函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results according to the problem specification.\n    \"\"\"\n\n    def generate_wrapped_trajectory_case1(L, dt, N, v):\n        \"\"\"Generates the wrapped trajectory for Test Case 1 (deterministic drift).\"\"\"\n        time = np.arange(N) * dt\n        true_positions = v * time\n        wrapped_positions = true_positions - L * np.floor(true_positions / L)\n        return true_positions.reshape(-1, 1), wrapped_positions.reshape(-1, 1)\n\n    def generate_wrapped_trajectory_case2(L, dt, N, d, D_true, seed):\n        \"\"\"Generates the wrapped trajectory for Test Case 2 (3D Brownian motion).\"\"\"\n        rng = np.random.default_rng(seed)\n        # Variance of displacement per step is 2*D*dt per dimension\n        scale = np.sqrt(2 * D_true * dt)\n        increments = rng.normal(loc=0.0, scale=scale, size=(N - 1, d))\n        # Initial position at origin\n        initial_pos = np.zeros((1, d))\n        true_positions = np.cumsum(np.vstack([initial_pos, increments]), axis=0)\n        wrapped_positions = true_positions - L * np.floor(true_positions / L)\n        return wrapped_positions\n\n    def generate_wrapped_trajectory_case3(N, d):\n        \"\"\"Generates the wrapped trajectory for Test Case 3 (stationary particle).\"\"\"\n        return np.zeros((N, d))\n\n    def unwrap_positions(wrapped_positions, L):\n        \"\"\"\n        Reconstructs the continuous trajectory from wrapped positions.\n\n        Args:\n            wrapped_positions (np.ndarray): Array of shape (N, d) of wrapped positions.\n            L (float): Box length.\n\n        Returns:\n            np.ndarray: Array of shape (N, d) of unwrapped, continuous positions.\n        \"\"\"\n        N, d = wrapped_positions.shape\n        unwrapped_pos = np.zeros_like(wrapped_positions)\n        unwrapped_pos[0] = wrapped_positions[0]\n\n        for i in range(1, N):\n            raw_disp = wrapped_positions[i] - wrapped_positions[i-1]\n            # Apply Minimum Image Convention to find the true displacement increment\n            mic_disp = raw_disp - L * np.round(raw_disp / L)\n            unwrapped_pos[i] = unwrapped_pos[i-1] + mic_disp\n            \n        return unwrapped_pos\n\n    def compute_msd(unwrapped_positions, dt):\n        \"\"\"\n        Computes the time-averaged Mean Squared Displacement (MSD).\n\n        Args:\n            unwrapped_positions (np.ndarray): Array of shape (N, d) of unwrapped positions.\n            dt (float): Time step between frames.\n\n        Returns:\n            tuple: A tuple containing:\n                - msd_values (np.ndarray): 1D array of MSD values for each lag.\n                - lag_times (np.ndarray): 1D array of corresponding lag times (tau).\n        \"\"\"\n        N = unwrapped_positions.shape[0]\n        max_lag_k = N - 1\n        msd_values = np.zeros(max_lag_k)\n\n        for k in range(1, max_lag_k + 1):\n            displacements = unwrapped_positions[k:] - unwrapped_positions[:-k]\n            sq_displacements = np.sum(displacements**2, axis=1)\n            msd_values[k-1] = np.mean(sq_displacements)\n        \n        lag_times = (np.arange(max_lag_k) + 1) * dt\n        return msd_values, lag_times\n\n    def estimate_diffusion(msd_values, lag_times, d, lag_interval):\n        \"\"\"\n        Estimates the diffusion coefficient from an MSD curve via linear regression.\n\n        Args:\n            msd_values (np.ndarray): 1D array of MSD values.\n            lag_times (np.ndarray): 1D array of lag times.\n            d (int): a dimension of the system.\n            lag_interval (tuple): (tau_min, tau_max) for the linear regression.\n\n        Returns:\n            float: The estimated diffusion coefficient.\n        \"\"\"\n        tau_min, tau_max = lag_interval\n        \n        # Find indices corresponding to the lag time interval for regression\n        indices = np.where((lag_times >= tau_min) & (lag_times <= tau_max))\n        \n        if len(indices[0]) < 2:\n            # Not enough points to perform linear regression\n            return 0.0\n\n        taus_fit = lag_times[indices]\n        msds_fit = msd_values[indices]\n\n        # Perform linear regression: MSD = slope * tau + intercept\n        res = linregress(x=taus_fit, y=msds_fit)\n        \n        slope = res.slope\n        \n        # D = slope / (2*d)\n        D_est = slope / (2 * d)\n        \n        return D_est\n\n    # --- Test Cases ---\n    results = []\n    \n    # Test Case 1: Deterministic drift\n    L1, dt1, N1, v1 = 10.0, 1.0, 12, 2.0\n    true_pos1, wrapped_pos1 = generate_wrapped_trajectory_case1(L1, dt1, N1, v1)\n    unwrapped_pos1 = unwrap_positions(wrapped_pos1, L1)\n    is_correct = np.allclose(true_pos1, unwrapped_pos1, atol=1e-12)\n    results.append(is_correct)\n    \n    # Test Case 2: 3D Brownian motion\n    d2, L2, dt2, N2, D_true2, seed = 3, 8.0, 0.5, 4000, 0.05, 12345\n    lag_interval2 = (10.0, 800.0)\n    wrapped_pos2 = generate_wrapped_trajectory_case2(L2, dt2, N2, d2, D_true2, seed)\n    unwrapped_pos2 = unwrap_positions(wrapped_pos2, L2)\n    msd2, lags2 = compute_msd(unwrapped_pos2, dt2)\n    D_est2 = estimate_diffusion(msd2, lags2, d2, lag_interval2)\n    results.append(D_est2)\n    \n    # Test Case 3: 3D stationary particle\n    d3, L3, dt3, N3 = 3, 6.0, 0.5, 200\n    lag_interval3 = (1.0, 50.0)\n    wrapped_pos3 = generate_wrapped_trajectory_case3(N3, d3)\n    unwrapped_pos3 = unwrap_positions(wrapped_pos3, L3)\n    msd3, lags3 = compute_msd(unwrapped_pos3, dt3)\n    D_est3 = estimate_diffusion(msd3, lags3, d3, lag_interval3)\n    results.append(D_est3)\n    \n    # Format and print the final output\n    formatted_results = [\n        str(results[0]),\n        f\"{results[1]:.6f}\",\n        f\"{results[2]:.6f}\"\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "获得了连续的原子轨迹后，下一步是计算MSD曲线。然而，尤其是在晶体材料中，原子围绕其晶格位置的振动会在MSD曲线上叠加高频振荡，这可能掩盖长时程下的扩散行为。本实践将向您展示如何通过“时间原点平均”这一强大的统计方法来有效滤除这些振动噪声，从而获得一条更平滑、更能反映真实扩散趋势的MSD曲线。",
            "id": "3731791",
            "problem": "您被要求构建一个完整、可运行的程序，该程序模拟包含叠加的振动和扩散分量的晶体合金动力学，计算均方位移（MSD）和扩散系数，并演示在达到扩散区之前，如何通过对时间起点进行平均来减轻振荡。其背景是高熵合金和复杂材料建模，目标是量化振动贡献如何影响 $MSD(t)$，以及对时间起点进行平均如何减少振荡，从而能够稳健地估算扩散系数。\n\n从以下基础开始：\n\n- 根据其统计意义定义原子系综的均方位移（MSD）：对于索引为 $i$ 的原子，其位置为 $\\mathbf{r}_i(t)$，时间延迟为 $\\tau$，MSD 是在时间延迟内位移平方的系综平均值。\n- 认识到在有限温度下的晶体材料中，振动模式会贡献振荡运动，这在短时间内可能主导 $MSD(t)$。当存在此类振动时，单个时间起点可以将依赖于相位的振荡印刻到 $MSD(t)$ 中，而对多个时间起点进行平均则通过使振动贡献去相干来减少这些振荡。\n- 在各向同性三维系统的长时间扩散区中，MSD 与时间成线性关系，扩散系数可以从渐近线性行为中提取，并使用适用于 $d=3$ 的适当比例常数。\n\n您的程序必须：\n\n1.  为晶体合金中的一组原子生成三维合成轨迹 $\\mathbf{r}_i(t)$。每条轨迹必须由以下部分组成：\n    -   一个表示为离散时间各向同性随机行走的扩散分量。\n    -   一个建模为谐波振荡的振动分量，具有原子特定的随机相位和随机振动方向。\n    -   对于每个原子 $i$，振动位移应具有 $\\mathbf{a}_i \\sin(2\\pi f t + \\phi_i)$ 的形式，其中 $\\mathbf{a}_i$ 是一个大小为 $A$ 且方向随机的恒定向量，$f$ 是振动频率，$\\phi_i$ 是在 $[0,2\\pi)$ 上均匀分布的相位，且各原子间独立。\n2.  使用以下方法计算三个版本的 $MSD(\\tau)$：\n    -   在 $t_0=0$ 处的单个时间起点（朴素MSD）。\n    -   在轨迹持续时间内均匀分布的多个时间起点，以使 $t_0+\\tau$ 保持在轨迹内（时间起点平均MSD）。使用至少 $5$ 个时间起点，最多 $50$ 个时间起点；选择一个与轨迹长度相适应的数字。\n    -   对时间起点平均MSD应用中心移动平均得到的平滑版本，其窗口宽度为奇数，至少为 $5$，且大约为计算的延迟点数量的 $2\\%$。\n3.  通过使用普通最小二乘法（OLS）拟合长时间的线性区域，从每个MSD曲线中估算扩散系数。为保证稳健性：\n    -   仅使用可用延迟的最后一部分来拟合斜率；取尾部 $0.4$ 的部分。\n    -   使用与延迟相对应的时间值作为拟合的自变量。\n    -   对各MSD曲线在其长时间区域内执行所有斜率拟合。\n4.  将扩散系数转换为国际单位制（SI单位）$\\mathrm{m}^2/\\mathrm{s}$；轨迹和参数在长度上以纳米（nm）定义，时间上以皮秒（ps）定义，因此 $1\\,\\mathrm{nm}^2/\\mathrm{ps} = 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$。\n\n物理和数值单位：\n- 位置必须以 $\\mathrm{nm}$ 生成，时间以 $\\mathrm{ps}$ 生成，扩散系数必须以 $\\mathrm{m}^2/\\mathrm{s}$ 报告。\n- 角度（相位）以弧度为单位。\n- 将所有数值输出表示为浮点数。\n\n使用以下测试套件。对于每种情况，为 $N$ 个原子和 $M$ 个时间步长生成轨迹，时间增量为 $\\Delta t$，振动幅度为 $A$，振动频率为 $f$，真实扩散系数为 $D_{\\mathrm{true}}$（单位为 $\\mathrm{nm}^2/\\mathrm{ps}$）。振动频率 $f$ 的单位是太赫兹（THz），在线性频率单位中 $1\\,\\mathrm{THz} = 1/\\mathrm{ps}$。整个过程中维度为 $d=3$。\n\n- 情况1（正常路径）：\n  - $N = 200$，$M = 5000$，$\\Delta t = 0.001\\,\\mathrm{ps}$，$A = 0.03\\,\\mathrm{nm}$，$f = 2.0\\,\\mathrm{THz}$，$D_{\\mathrm{true}} = 0.01\\,\\mathrm{nm}^2/\\mathrm{ps}$。\n- 情况2（强振动）：\n  - $N = 200$，$M = 5000$，$\\Delta t = 0.001\\,\\mathrm{ps}$，$A = 0.10\\,\\mathrm{nm}$，$f = 5.0\\,\\mathrm{THz}$，$D_{\\mathrm{true}} = 0.005\\,\\mathrm{nm}^2/\\mathrm{ps}$。\n- 情况3（纯振动，无扩散）：\n  - $N = 200$，$M = 5000$，$\\Delta t = 0.001\\,\\mathrm{ps}$，$A = 0.05\\,\\mathrm{nm}$，$f = 3.0\\,\\mathrm{THz}$，$D_{\\mathrm{true}} = 0.0\\,\\mathrm{nm}^2/\\mathrm{ps}$。\n- 情况4（短轨迹边界）：\n  - $N = 200$，$M = 1200$，$\\Delta t = 0.001\\,\\mathrm{ps}$，$A = 0.05\\,\\mathrm{nm}$，$f = 1.0\\,\\mathrm{THz}$，$D_{\\mathrm{true}} = 0.02\\,\\mathrm{nm}^2/\\mathrm{ps}$。\n\n算法要求：\n\n- 对于扩散分量，为每个坐标使用独立的、方差与时间步长成正比的高斯增量，这与三维各向同性随机行走一致。\n- 对于多个时间起点，选择均匀间隔的 $t_0$，以使对于任何使用的延迟 $\\tau$，$t_0 + \\tau$ 不超过轨迹长度；将最大延迟限制在轨迹的合理分数内，以确保有足够数量的时间起点贡献。\n- 对于移动平均，确保窗口宽度为奇数且至少为 $5$；使用大约 $2\\%$ 的延迟点数来选择窗口大小。\n\n最终输出格式：\n\n- 对于每种情况，计算三个扩散系数估计值：\n  - $D_{\\mathrm{naive}}$ 来自单一起点MSD。\n  - $D_{\\mathrm{toa}}$ 来自时间起点平均MSD。\n  - $D_{\\mathrm{filt}}$ 来自过滤后的时间起点平均MSD。\n- 您的程序应生成单行输出，包含按 $[D_{\\mathrm{naive}}^{(1)},D_{\\mathrm{toa}}^{(1)},D_{\\mathrm{filt}}^{(1)},D_{\\mathrm{naive}}^{(2)},D_{\\mathrm{toa}}^{(2)},D_{\\mathrm{filt}}^{(2)},D_{\\mathrm{naive}}^{(3)},D_{\\mathrm{toa}}^{(3)},D_{\\mathrm{filt}}^{(3)},D_{\\mathrm{naive}}^{(4)},D_{\\mathrm{toa}}^{(4)},D_{\\mathrm{filt}}^{(4)}]$ 顺序排列的 $12$ 个数值结果，单位为 $\\mathrm{m}^2/\\mathrm{s}$，其中上标表示案例编号。输出必须精确地打印为一行，其中包含方括号括起来的、以逗号分隔的浮点数。",
            "solution": "该问题要求构建一个计算模型来模拟晶体合金中的原子运动，该运动同时具有随机扩散跳跃和相干晶格振动的特征。根据这些模拟轨迹，我们需要使用几种技术来计算均方位移（MSD），并随后估算材料的扩散系数 $D$。问题的核心在于演示如何利用先进的平均和滤波方法，从短时动力学由振荡伪影主导的轨迹中提取可靠的扩散系数。\n\n分析过程主要分为四个阶段：（1）生成合成原子轨迹，（2）计算MSD，（3）通过线性拟合估算扩散系数，以及（4）转换为标准单位。\n\n**1. 轨迹生成**\n\n每个原子 $i$ 在时间 $t$ 的位置，表示为 $\\mathbf{r}_i(t)$，被建模为扩散分量和振动分量的叠加，相对于初始位置 $\\mathbf{r}_i(0)$（不失一般性地，我们可以将其设置为 $\\mathbf{0}$）。\n$$\n\\mathbf{r}_i(t) = \\mathbf{r}_{i, \\text{diff}}(t) + \\mathbf{r}_{i, \\text{vib}}(t)\n$$\n\n轨迹被离散化为 $M$ 个持续时间为 $\\Delta t$ 的时间步。\n\n**扩散分量：** 项 $\\mathbf{r}_{i, \\text{diff}}(t)$ 表示一个各向同性的 $3$ 维随机行走，这是布朗运动的离散时间模拟。第 $k+1$ 步的位置是通过在第 $k$ 步的位置上加上一个随机位移向量 $\\delta\\mathbf{r}_i(k)$ 来更新的：\n$$\n\\mathbf{r}_{i, \\text{diff}}((k+1)\\Delta t) = \\mathbf{r}_{i, \\text{diff}}(k\\Delta t) + \\delta\\mathbf{r}_i(k)\n$$\n$\\delta\\mathbf{r}_i(k)$ 的分量从均值为 $0$、方差为 $\\sigma^2$ 的高斯分布中抽取。方差与真实扩散系数 $D_{\\mathrm{true}}$ 和时间步长 $\\Delta t$直接相关。对于一个 $d$ 维各向同性系统，经过时间 $t$ 后的均方位移由爱因斯坦关系式给出，即 $\\langle |\\Delta\\mathbf{r}|^2 \\rangle = 2d D t$。对于在 $d=3$ 维中单个时间步 $\\Delta t$，我们有 $\\langle |\\delta\\mathbf{r}|^2 \\rangle = 6 D_{\\mathrm{true}} \\Delta t$。由于步长分量是独立的，$\\langle |\\delta\\mathbf{r}|^2 \\rangle = \\langle (\\delta x)^2 + (\\delta y)^2 + (\\delta z)^2 \\rangle = 3\\sigma^2$。将两者相等，得到每个分量增量所需的方差：\n$$\n\\sigma^2 = 2 D_{\\mathrm{true}} \\Delta t\n$$\n因此，高斯增量的标准差为 $\\sigma = \\sqrt{2 D_{\\mathrm{true}} \\Delta t}$。\n\n**振动分量：** 项 $\\mathbf{r}_{i, \\text{vib}}(t)$ 模拟了原子 $i$ 围绕其随机行走路径的振荡。这由一个谐波函数描述：\n$$\n\\mathbf{r}_{i, \\text{vib}}(t) = \\mathbf{a}_i \\sin(2\\pi f t + \\phi_i)\n$$\n其中 $f$ 是振动频率。对于每个原子 $i$，振幅向量 $\\mathbf{a}_i$ 具有恒定的大小 $A$ 和在 $3$D 空间中的随机取向，而相位 $\\phi_i$ 从 $[0, 2\\pi)$ 的均匀分布中抽取。这模拟了一个具有随机方向和相位的独立振荡器系统，这是复杂晶体中热振动的特征。\n\n**2. 均方位移（MSD）计算**\n\nMSD 测量原子在时间间隔（或延迟）$\\tau$ 内移动的平均平方距离。它被定义为对所有原子 $i$ 和所有可能的时间起点 $t_0$ 的平均值：\n$$\n\\text{MSD}(\\tau) = \\left\\langle \\frac{1}{N} \\sum_{i=1}^N |\\mathbf{r}_i(t_0 + \\tau) - \\mathbf{r}_i(t_0)|^2 \\right\\rangle_{t_0}\n$$\n我们用三种不同的方式计算MSD，以说明振动噪声的减轻效果：\n\n- **朴素MSD（$D_{\\text{naive}}$）：** 这仅使用单个时间起点 $t_0=0$ 来计算。由此产生的 $\\text{MSD}(\\tau)$ 曲线对振动分量的特定相位高度敏感，通常表现出强烈的振荡，掩盖了潜在的线性扩散趋势。\n\n- **时间起点平均MSD（$D_{\\text{toa}}$）：** 为了抑制这些振荡，MSD 在多个均匀间隔的时间起点 $t_0$ 上进行平均。时间起点的总数选择为 $20$，这在指定的 [$5$, $50$] 范围内。通过对轨迹中不同起始点进行平均，具有随机相位的正弦振动项的贡献趋于抵消。这种去相干效应显著平滑了MSD曲线，使得线性扩散区更加明显。\n\n- **滤波后MSD（$D_{\\text{filt}}$）：** 作为最后的改进，通过应用中心移动平均滤波器进一步平滑TOA MSD曲线。这是使用 `scipy.ndimage.uniform_filter1d` 实现的。滤波器的窗口宽度选择为大于或等于 $5$ 的奇数整数，并且约为计算出的总延迟点数的 $2\\%$。此滤波步骤可去除残余的高频噪声，而不会扭曲长时间的线性斜率。最大延迟设置为总轨迹持续时间的 $50\\%$，以确保统计的稳健性。\n\n**3. 扩散系数估算**\n\n在长时间极限（$\\tau \\to \\infty$）下，系统进入纯粹的扩散区。此时，MSD 与时间成线性关系，遵循 $3$ 维的爱因斯坦关系式：\n$$\n\\lim_{\\tau \\to \\infty} \\text{MSD}(\\tau) = 6 D \\tau\n$$\n因此，扩散系数 $D$ 可以从 $\\text{MSD}(\\tau)$ 对 $\\tau$ 的曲线的线性部分的斜率 $m$ 中提取，其中 $D = m/6$。\n\n为了估算这个斜率，我们对三个计算出的MSD曲线的尾部进行普通最小二乘法（OLS）线性回归。拟合仅限于可用延迟时间的最后 $40\\%$，因为这个区域最有可能代表真实的扩散行为，不受短时弹道或振动效应的影响。使用 `numpy.polyfit` 函数来获得每种情况下的斜率。\n\n**4. 单位转换**\n\n模拟参数以纳米（$\\mathrm{nm}$）、皮秒（$\\mathrm{ps}$）和太赫兹（$\\mathrm{THz}$）给出，其中 $1\\,\\mathrm{THz} = 1/\\mathrm{ps}$。因此，从OLS拟合中估算的扩散系数 $D$ 的单位是 $\\mathrm{nm}^2/\\mathrm{ps}$。最终结果必须以国际单位制（SI）的 $\\mathrm{m}^2/\\mathrm{s}$ 报告。转换关系如下：\n$$\n1 \\, \\frac{\\mathrm{nm}^2}{\\mathrm{ps}} = \\frac{(10^{-9} \\, \\mathrm{m})^2}{10^{-12} \\, \\mathrm{s}} = \\frac{10^{-18} \\, \\mathrm{m}^2}{10^{-12} \\, \\mathrm{s}} = 10^{-6} \\, \\frac{\\mathrm{m}^2}{\\mathrm{s}}\n$$\n在最终输出中报告之前，每个计算出的扩散系数都乘以这个因子 $10^{-6}$。对每个提供的测试用例重复整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import uniform_filter1d\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n    # Set a fixed seed for reproducibility of the random components.\n    np.random.seed(0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        (200, 5000, 0.001, 0.03, 2.0, 0.01),\n        # Case 2 (strong vibrations)\n        (200, 5000, 0.001, 0.10, 5.0, 0.005),\n        # Case 3 (purely vibrational, no diffusion)\n        (200, 5000, 0.001, 0.05, 3.0, 0.0),\n        # Case 4 (short trajectory boundary)\n        (200, 1200, 0.001, 0.05, 1.0, 0.02),\n    ]\n\n    # Constants for the analysis\n    MAX_LAG_FRAC = 0.5  # Use lags up to 50% of trajectory length\n    NUM_ORIGINS = 20    # Number of time origins for averaging, in [5, 50]\n    SMOOTH_WINDOW_FRAC = 0.02 # Window for moving average is ~2% of lags\n    FIT_FRAC = 0.4      # Use last 40% of data for linear fit\n    CONV_FACTOR = 1e-6  # Conversion from nm^2/ps to m^2/s\n\n    results = []\n\n    for case in test_cases:\n        N, M, dt, A, f, D_true = case\n        \n        trajs, t_array = generate_trajectories(N, M, dt, D_true, A, f)\n\n        # --- Naive MSD ---\n        lag_times, msd_naive = calculate_msd(trajs, dt, MAX_LAG_FRAC, num_origins=1)\n        D_naive = estimate_diffusion_coefficient(lag_times, msd_naive, FIT_FRAC)\n        \n        # --- Time-Origin Averaged (TOA) MSD ---\n        # lag_times are the same as for the naive case\n        _, msd_toa = calculate_msd(trajs, dt, MAX_LAG_FRAC, num_origins=NUM_ORIGINS)\n        D_toa = estimate_diffusion_coefficient(lag_times, msd_toa, FIT_FRAC)\n        \n        # --- Filtered MSD ---\n        msd_filt = smooth_msd(msd_toa, SMOOTH_WINDOW_FRAC)\n        D_filt = estimate_diffusion_coefficient(lag_times, msd_filt, FIT_FRAC)\n        \n        # Append results with unit conversion\n        results.extend([\n            D_naive * CONV_FACTOR,\n            D_toa * CONV_FACTOR,\n            D_filt * CONV_FACTOR\n        ])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_trajectories(N, M, dt, D_true, A, f):\n    \"\"\"\n    Generates synthetic atomic trajectories with diffusive and vibrational components.\n    \n    Args:\n        N (int): Number of atoms.\n        M (int): Number of time steps.\n        dt (float): Time step duration (ps).\n        D_true (float): True diffusion coefficient (nm^2/ps).\n        A (float): Vibration amplitude (nm).\n        f (float): Vibration frequency (THz).\n        \n    Returns:\n        tuple: (trajectories, time_array)\n            - trajectories (np.ndarray): (N, M, 3) array of positions (nm).\n            - time_array (np.ndarray): (M,) array of time points (ps).\n    \"\"\"\n    # Time array\n    t = np.arange(M) * dt\n\n    # 1. Diffusive component (isotropic random walk)\n    # Variance of increments is 2*D*dt per dimension.\n    sigma_diff = np.sqrt(2 * D_true * dt)\n    # Generate random increments for all atoms and all steps\n    increments = np.random.normal(0, sigma_diff, size=(N, M, 3))\n    # The walk starts from the origin, so increments at t=0 are zero.\n    increments[:, 0, :] = 0.0\n    # The diffusive trajectory is the cumulative sum of increments.\n    r_diff = np.cumsum(increments, axis=1)\n\n    # 2. Vibrational component (harmonic oscillation)\n    # Random phases for each atom\n    phi = np.random.uniform(0, 2 * np.pi, size=(N, 1))\n    # Random unit vectors for vibration directions\n    u_vec = np.random.normal(size=(N, 3))\n    u_vec /= np.linalg.norm(u_vec, axis=1, keepdims=True)\n    a_vec = A * u_vec  # Amplitude vectors\n    \n    # Calculate the time-dependent part of the vibration\n    omega = 2 * np.pi * f\n    # Time and phase part, shape (N, M)\n    time_phase_part = omega * t[np.newaxis, :] + phi\n    sin_component = np.sin(time_phase_part) # shape (N, M)\n    \n    # Combine with amplitude vectors using broadcasting\n    # (N, 1, 3) * (N, M, 1) -> (N, M, 3)\n    r_vib = a_vec[:, np.newaxis, :] * sin_component[:, :, np.newaxis]\n\n    # 3. Total trajectory\n    r_total = r_diff + r_vib\n    \n    return r_total, t\n\ndef calculate_msd(trajectories, dt, max_lag_frac, num_origins):\n    \"\"\"\n    Computes the Mean Square Displacement (MSD) for a set of trajectories.\n    \n    Args:\n        trajectories (np.ndarray): (N, M, 3) array of positions.\n        dt (float): Time step duration.\n        max_lag_frac (float): Maximum lag as a fraction of trajectory length.\n        num_origins (int): Number of time origins to average over.\n        \n    Returns:\n        tuple: (lag_times, msd)\n            - lag_times (np.ndarray): Array of lag times.\n            - msd (np.ndarray): Computed MSD values.\n    \"\"\"\n    N, M, _ = trajectories.shape\n    max_lag_steps = int(M * max_lag_frac)\n    lags = np.arange(1, max_lag_steps)\n    \n    # Create an array of uniformly spaced time origins\n    # Ensure t0 + max_lag does not exceed trajectory length\n    origin_steps = np.linspace(0, M - max_lag_steps, num_origins, dtype=int, endpoint=False)\n    \n    msd_accumulator = np.zeros(len(lags))\n    \n    for t0_step in origin_steps:\n        # Calculate displacements for all atoms and all lags from this origin\n        # trajectories[:, t0_step + lags, :] has shape (N, num_lags, 3)\n        # trajectories[:, t0_step, np.newaxis, :] has shape (N, 1, 3)\n        displacements = trajectories[:, t0_step + lags, :] - trajectories[:, t0_step, np.newaxis, :]\n        \n        # Square and sum over dimensions, then average over atoms\n        sq_displacements = np.sum(displacements**2, axis=2) # Shape (N, num_lags)\n        msd_at_t0 = np.mean(sq_displacements, axis=0) # Shape (num_lags,)\n        \n        msd_accumulator += msd_at_t0\n        \n    msd = msd_accumulator / num_origins\n    lag_times = lags * dt\n    \n    return lag_times, msd\n\ndef smooth_msd(msd, window_frac):\n    \"\"\"\n    Applies a centered moving average to an MSD curve.\n    \n    Args:\n        msd (np.ndarray): The MSD curve to smooth.\n        window_frac (float): Fraction of data points to use for window size.\n        \n    Returns:\n        np.ndarray: The smoothed MSD curve.\n    \"\"\"\n    num_lags = len(msd)\n    # Calculate window width, ensure it's odd and at least 5\n    window_width = int(num_lags * window_frac)\n    window_width = max(5, window_width // 2 * 2 + 1)\n    \n    # Use uniform_filter1d for simple moving average with boundary handling\n    return uniform_filter1d(msd, size=window_width, mode='nearest')\n\ndef estimate_diffusion_coefficient(lag_times, msd, fit_frac):\n    \"\"\"\n    Estimates the diffusion coefficient D by fitting the tail of the MSD curve.\n    \n    Args:\n        lag_times (np.ndarray): The array of lag times.\n        msd (np.ndarray): The corresponding MSD values.\n        fit_frac (float): The fraction of the tail of the data to use for fitting.\n        \n    Returns:\n        float: The estimated diffusion coefficient D in nm^2/ps.\n    \"\"\"\n    num_points = len(lag_times)\n    fit_start_index = int((1 - fit_frac) * num_points)\n    \n    t_fit = lag_times[fit_start_index:]\n    msd_fit = msd[fit_start_index:]\n    \n    # Perform OLS linear regression: y = mx + c\n    # np.polyfit returns [slope, intercept] for deg=1\n    slope, _ = np.polyfit(t_fit, msd_fit, 1)\n    \n    # From Einstein relation in 3D: MSD = 6*D*t, so D = slope / 6\n    D = slope / 6.0\n    \n    return D\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "得到一条清晰的MSD曲线后，最后的挑战是如何可靠地提取扩散系数 $D$。非晶态材料（如高熵合金）的原子动力学通常更为复杂，其MSD曲线会依次展现弹道输运、笼蔽效应和扩散这三个不同区域。本实践将引导您设计一个数据驱动的自动化分析流程，通过分析MSD曲线的局部标度指数 $\\alpha = \\frac{d \\log(\\text{MSD})}{d \\log(t)}$，精确地识别并拟合长时程的线性扩散区，从而避免使用任意或固定的时间窗口所带来的偏差。",
            "id": "3731737",
            "problem": "给定结构无序的非晶高熵合金的均方位移随时间变化的时间序列，记为 $MSD(t)$。目标是估算长时自扩散系数 $D$，同时严格排除早期弹道输运区和中间时段笼蔽效应区的贡献。您的程序必须实现一种有原则的、数据自适应的方法，该方法能在不使用任何固定的、硬编码的时间截断值的情况下，识别出 $MSD(t)$ 的渐近线性区。\n\n您可以依赖的出发点和物理基础：\n- 在极短时间 $t$ 内，粒子运动保留惯性，其位移主要由速度持续性主导，$MSD(t)$ 随时间近似呈二次方增长。\n- 非晶体系中的结构无序会产生瞬态的“笼子”来阻碍运动，这通常导致 $MSD(t)$ 在一个中间时间窗口内出现近平台区或亚线性增长。\n- 在足够长的时间后，根据中心极限定理和初始条件记忆的丧失，对于三维空间中的各向同性均匀材料，在扩散区内 $MSD(t)$ 随 $t$ 线性增长。\n\n您的方法必须：\n1. 通过分析 $MSD(t)$ 相对于 $t$ 的局域标度行为，以数据驱动的方式检测并排除早期弹道输运区和中间时段笼蔽效应区。该方法不得假设任何关于分隔不同区域的精确截断时间的先验知识。\n2. 识别一个稳定的时间窗口，在此窗口内 $MSD(t)$ 与 $t$ 呈渐近线性关系。在该窗口内，对普通（非对数）坐标系下的 $MSD$ 与 $t$ 的关系进行稳健的线性拟合。\n3. 从拟合出的三维长时线性行为中，推断出自扩散系数 $D$，并以要求的单位报告结果。\n\n数学和算法要求：\n- 使用滑动窗口分析局域标度指数 $ \\alpha = \\dfrac{d \\log(MSD)}{d \\log(t)} $ 来检测扩散区，其中 $ \\alpha $ 接近 $ 1 $。您必须设计“足够接近”和“足够稳定”的定量标准，并从算法上证明其合理性。\n- 在候选扩散窗口内，对 $MSD$ 与 $t$ 的关系使用稳健的线性回归，以减轻噪声和异常值的影响。\n- 当多个候选窗口满足您的标准时，实现一个决策规则来选择最终的拟合窗口。该规则必须通过一个合适的量化分数来偏好更长且线性度更高的窗口。\n- 避免使用任何以时间单位直接表示的、固定的、手动调整的截断时间；所有排除操作都必须通过您设定的标准从数据中发现。\n\n单位和输出：\n- 输入时间 $t$ 的单位为皮秒 ($ps$)，输入均方位移 $MSD$ 的单位为平方纳米 ($nm^2$)。\n- 您必须以平方米每秒 ($m^2/s$) 为单位报告最终的 $D$。\n- 将最终结果表示为包含三位有效数字的科学记数法小数（例如，$1.23 \\times 10^{-8}$ 应打印为 $1.23e-08$）。打印格式必须是单行，包含一个用方括号括起来的逗号分隔列表，如 $[d_1,d_2,d_3,d_4]$，不含空格，其中每个 $d_i$ 是对应测试用例估算出的扩散系数，单位为 $m^2/s$。\n\n综合测试套件：\n您必须生成四个综合 $MSD(t)$ 数据集，每个数据集都是三个有物理动机的组分的含噪声平滑组合：一个衰减的早期弹道贡献，一个出现后又衰减的笼蔽平台，以及一个逐渐启动的长时扩散增长。对于每个数据集，生成一个时间网格 $t_i$，然后构建\n$$\nMSD(t) \\;=\\; v_2\\, t^2 \\, e^{-\\left(\\frac{t}{t_b}\\right)^2}\n\\;+\\; a \\left(1 - e^{-\\left(\\frac{t}{t_c}\\right)^2}\\right) e^{-\\left(\\frac{t}{t_d}\\right)^2}\n\\;+\\; 6 D \\, t \\left(1 - e^{-\\left(\\frac{t}{t_d}\\right)^2}\\right)\n\\;+\\; \\eta,\n$$\n其中：\n- $t$ 的单位是 $ps$，\n- $MSD$ 的单位是 $nm^2$，\n- $v_2$ 的单位是 $nm^2/ps^2$，\n- $a$ 的单位是 $nm^2$，\n- $t_b, t_c, t_d$ 的单位是 $ps$，\n- $D$ 的单位是 $nm^2/ps$，\n- $\\eta$ 是附加的零均值高斯噪声，其标准差为 $\\sigma$，单位为 $nm^2$；如果 $MSD(t)$ 因噪声在任何点变为非正值，请将其限制在一个小的正数下限 $10^{-12}\\,nm^2$，以确保对数函数有定义。\n\n对于每个测试用例，使用一个包含 $N$ 个点的均匀间隔时间网格 $t_i$，范围从 $t_{\\min}$ 到 $t_{\\max}$（包括端点），其中 $t_{\\min} = 10^{-3}\\,ps$。使用以下参数集和随机种子生成数据集：\n\n- 用例 1（理想情况，清晰的长扩散尾部）：\n  - $N = 1200$，$t_{\\max} = 100$，$v_2 = 0.50$，$a = 0.20$，$t_b = 0.20$，$t_c = 1.00$，$t_d = 5.00$，$D = 0.020$，$\\sigma = 5.0 \\times 10^{-3}$，seed $= 12345$。\n- 用例 2（扩展的笼蔽效应，扩散出现较晚，较慢的 $D$）：\n  - $N = 1600$，$t_{\\max} = 200$，$v_2 = 0.70$，$a = 0.50$，$t_b = 0.50$，$t_c = 5.00$，$t_d = 30.0$，$D = 0.0050$，$\\sigma = 3.0 \\times 10^{-3}$，seed $= 24680$。\n- 用例 3（轨迹较短，扩散窗口极小，较快的 $D$）：\n  - $N = 900$，$t_{\\max} = 20.0$，$v_2 = 0.60$，$a = 0.30$，$t_b = 0.80$，$t_c = 3.00$，$t_d = 8.00$，$D = 0.0300$，$\\sigma = 1.0 \\times 10^{-2}$，seed $= 13579$。\n- 用例 4（噪声较多的数据，中等的 $D$）：\n  - $N = 1400$，$t_{\\max} = 120.0$，$v_2 = 0.40$，$a = 0.25$，$t_b = 0.30$，$t_c = 2.50$，$t_d = 10.0$，$D = 0.0150$，$\\sigma = 2.0 \\times 10^{-2}$，seed $= 11223$。\n\n以上所有数值均如前述，使用基于 $ps$ 和 $nm^2$ 的单位。您必须使用精确的转换因子 $1\\,nm^2/ps = 10^{-6}\\,m^2/s$ 将最终估算的扩散系数转换为 $m^2/s$。\n\n程序要求：\n- 完全按照规定实现数据生成和估算方法。\n- 您的程序应生成单行输出，其中包含四个估算的扩散系数（单位为 $m^2/s$）的结果，形式为逗号分隔的列表，并用方括号括起来，每个值都以三位有效数字的科学记数法打印（例如 $[2.00e-08,5.00e-09,3.00e-08,1.50e-08]$）。不得打印任何额外文本。",
            "solution": "接下来的论述提供了从均方位移数据估算自扩散系数问题的完整解决方案。该过程始于对问题陈述的强制性批判性验证。\n\n### 步骤 1：提取已知信息\n\n- **目标**：从均方位移 $MSD(t)$ 的时间序列数据中估算长时自扩散系数 $D$。\n- **物理系统**：结构无序的非晶高熵合金。\n- **物理模型**：粒子运动表现出三个区域：\n    1. 早期弹道输运区：$MSD(t) \\propto t^2$。\n    2. 中间时段笼蔽效应区：$MSD(t)$ 呈亚线性增长。\n    3. 长时扩散区：$MSD(t)$ 与 $t$ 呈线性关系。对于三维空间，$MSD(t) = 6Dt$。\n- **核心方法论约束**：方法必须是数据自适应的，在不使用固定的、硬编码的时间截断值的情况下识别线性扩散区。\n- **算法要求**：\n    1. 使用滑动窗口分析局域标度指数 $\\alpha = \\frac{d \\log(MSD)}{d \\log(t)}$ 来寻找 $\\alpha \\approx 1$ 的区域。\n    2. 为 $\\alpha$ 实现“足够接近”和“足够稳定”的定量标准。\n    3. 在识别出的扩散窗口内，对 $MSD$ 与 $t$ 的关系使用稳健的线性回归。\n    4. 如果存在多个候选窗口，实现一个决策规则以选择最佳窗口，偏好更长且线性度更高的窗口。\n- **单位与转换**：\n    - 输入时间 $t$ 的单位为皮秒 ($ps$)。\n    - 输入 $MSD$ 的单位为平方纳米 ($nm^2$)。\n    - 最终报告的 $D$ 必须以平方米每秒 ($m^2/s$) 为单位。\n    - 转换因子为 $1\\,nm^2/ps = 10^{-6}\\,m^2/s$。\n- **综合数据生成**：\n    - 公式：$MSD(t) = v_2 t^2 e^{-(t/t_b)^2} + a (1 - e^{-(t/t_c)^2}) e^{-(t/t_d)^2} + 6 D t (1 - e^{-(t/t_d)^2}) + \\eta$。\n    - $\\eta$ 是标准差为 $\\sigma$ 的零均值高斯噪声。\n    - 非正的 $MSD(t)$ 值被限制在一个下限 $10^{-12}\\,nm^2$。\n    - 时间网格：$N$ 个点，从 $t_{\\min} = 10^{-3}\\,ps$ 到 $t_{\\max}$ 均匀间隔。\n- **测试用例**：提供了四个具体的参数集（用例1、用例2、用例3、用例4），每个都包含 $N, t_{\\max}, v_2, a, t_b, t_c, t_d, D, \\sigma$ 和一个随机种子的值。\n- **输出格式**：单行，包含四个扩散系数（单位为 $m^2/s$）的逗号分隔列表，用方括号括起来（例如 `[d1,d2,d3,d4]`），每个值都采用三位有效数字的科学记数法。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n对问题陈述进行严格验证。\n\n1.  **科学或事实上的不健全性**：问题在科学上是健全的。它基于无序系统中扩散的经典模型，该模型正确描述了弹道、笼蔽和扩散区域。爱因斯坦关系 $MSD(t) = 2dDt$（其中维度 $d=3$）的使用以及局域对数导数 $\\alpha(t)$ 的分析，是凝聚态物理和统计力学中标准且成熟的方法。综合数据模型是这些组合效应在物理上合理的表示。\n2.  **非形式化或不相关**：问题是高度可形式化的，可作为一个基于物理的数值分析任务。它直接且明确地关系到从均方位移计算扩散系数的指定主题。\n3.  **不完整或矛盾的设置**：问题是完整的。它提供了所有必要的参数、方程和明确的随机种子，以确定性地生成测试数据。对分析方法和输出格式的要求都作了详细规定，没有留下歧义的空间。已知信息中没有矛盾。\n4.  **不切实际或不可行**：物理参数和时间尺度代表了非晶材料和复杂液体的分子动力学模拟中常见的值。该任务具有挑战性，但使用标准数值库完全可行。\n5.  **不适定或结构不良**：问题是适定的。它要求使用一种受约束但合理的方法论来估算特定参数 ($D$)。提供具有已知基准真相 $D$ 的综合数据，使得成功标准清晰明确。核心挑战——设计数据自适应的窗口逻辑——是一个定义明确的算法设计任务，而非不适定问题。\n6.  **伪深刻、琐碎或同义反复**：问题是非琐碎的。由于弹道和笼蔽区域的贡献，对整个数据集进行简单的线性拟合会产生错误结果。问题需要审慎地实现一个过滤和选择算法，以绕过数据的这些非扩散部分，这是现实世界数据分析中常见且实质性的挑战。\n7.  **超出科学可验证性范围**：问题是完全可验证的。给定固定的种子和确定性的数据生成公式，任何正确的算法实现都将产生相同的输入数据集，并应得出高度可比的最终结果。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。它在科学上是健全的、适定的，并提出了一个清晰、非琐碎的挑战，代表了真实的科学数据分析。可以继续进行求解过程。\n\n### 原则性解决方案设计\n\n核心目标是从均方位移 $MSD(t)$ 的长时线性区域估算扩散系数 $D$。在三维空间中，该关系由爱因斯坦方程给出：\n$$MSD(t) = 6Dt + C$$\n其中 $C$ 是一个截距项。我们的任务是分离出这种线性关系成立的时间窗口，并稳健地估计其斜率（等于 $6D$）。该方法必须是数据自适应的，避免任意的时间截断。\n\n**步骤 1：局域标度指数计算**\n\n为了区分不同的动力学区域，我们分析局域标度指数 $\\alpha(t)$，定义为 $MSD(t)$ 相对于 $t$ 的对数导数：\n$$\\alpha(t) = \\frac{d \\log(MSD(t))}{d \\log(t)}$$\n该指数在时间 $t$ 附近量化了幂律关系 $MSD(t) \\sim t^{\\alpha(t)}$。预期的值是：弹道区 $\\alpha \\approx 2$，笼蔽区 $\\alpha  1$（通常接近 $0$），扩散区 $\\alpha \\approx 1$。\n\n对含噪声数据进行直接数值微分是不稳定的，因为它会放大噪声。一种更稳健的方法是在每个点 $t_i$ 处，通过对以 $t_i$ 为中心的滑动窗口内的 $\\log(MSD)$ 与 $\\log(t)$ 进行线性回归来计算 $\\alpha(t_i)$。这种局域拟合的斜率提供了 $\\alpha_i$ 的平滑估计。我们为此计算选择一个固定的窗口大小，51个点，这足够大以平均掉噪声，但又足够小以解析给定数据密度下动力学区域的变化。\n\n**步骤 2：识别候选扩散窗口**\n\n扩散区的特征是 $\\alpha(t) \\approx 1$。我们为此条件定义一个定量标准：我们识别出所有计算出的指数 $\\alpha_i$ 落在 $1$ 的容差带内的所有时间点 $t_i$。我们设定为：\n$$| \\alpha_i - 1.0 |  \\delta_{\\alpha}$$\n选择容差 $\\delta_{\\alpha} = 0.1$，识别出局域标度介于 $t^{0.9}$ 和 $t^{1.1}$ 之间的点。\n\n为确保稳定性和统计显著性，我们感兴趣的不是满足此标准的孤立点，而是足够长的连续片段。我们找到所有满足该条件的连续索引块，并丢弃任何长度小于最小长度的块。此最小长度设置为总数据点数 $N$ 的 $10\\%$，以确保任何后续的线性拟合都是在轨迹的相当大一部分上执行的。\n\n**步骤 3：稳健回归和最终窗口选择**\n\n对于每个识别出的候选窗口，都对 $MSD$ 与 $t$ 进行线性拟合。由于数据含有噪声，稳健回归方法优于标准的普通最小二乘法。我们采用 Theil-Sen 估计器，这是一种对异常值高度稳健的非参数方法。它将斜率计算为连接数据集中所有点对的直线的斜率的中位数。这为斜率 $m = 6D$ 提供了一个可靠的估计。\n\n问题要求一个规则，在找到多个候选窗口时选择最佳的一个。选择的规则是：选择满足 $\\alpha$ 标准的**最长**连续窗口。这优先考虑了最稳定和最持久的扩散行为表现。在罕见的长度并列情况下，选择时间上最晚出现的窗口，因为它最能代表系统的真实渐近长时行为。\n\n**步骤 4：扩散系数计算和单位转换**\n\n一旦选定最佳窗口并使用 `scipy.stats.theilslopes` 估算出稳健斜率 $m$：\n1.  计算模拟单位下的扩散系数：\n    $$D_{\\text{sim}} = \\frac{m}{6}$$\n    $D_{\\text{sim}}$ 的单位是 $nm^2/ps$。\n2.  使用提供的转换因子将此值转换为所需的国际单位制（SI）单位 $m^2/s$：\n    $$D_{\\text{SI}} [m^2/s] = D_{\\text{sim}} [nm^2/ps] \\times 10^{-6}$$\n3.  将最终结果格式化为三位有效数字的科学记数法。\n\n这个自洽的、数据驱动的流程通过系统地识别用于分析的物理上正确的时间区域，稳健地提取扩散系数，完全满足了问题的约束条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import theilslopes\n\ndef solve():\n    \"\"\"\n    Main function to generate data, run the analysis for all test cases,\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, clear long diffusive tail)\n        {'N': 1200, 't_max': 100.0, 'v_2': 0.50, 'a': 0.20, 't_b': 0.20,\n         't_c': 1.00, 't_d': 5.00, 'D': 0.020, 'sigma': 5.0e-3, 'seed': 12345},\n\n        # Case 2 (extended caging, late-onset diffusion, slower D)\n        {'N': 1600, 't_max': 200.0, 'v_2': 0.70, 'a': 0.50, 't_b': 0.50,\n         't_c': 5.00, 't_d': 30.0, 'D': 0.0050, 'sigma': 3.0e-3, 'seed': 24680},\n\n        # Case 3 (short trajectory, minimal diffusive window, faster D)\n        {'N': 900, 't_max': 20.0, 'v_2': 0.60, 'a': 0.30, 't_b': 0.80,\n         't_c': 3.00, 't_d': 8.00, 'D': 0.0300, 'sigma': 1.0e-2, 'seed': 13579},\n\n        # Case 4 (noisier data, moderate D)\n        {'N': 1400, 't_max': 120.0, 'v_2': 0.40, 'a': 0.25, 't_b': 0.30,\n         't_c': 2.50, 't_d': 10.0, 'D': 0.0150, 'sigma': 2.0e-2, 'seed': 11223},\n    ]\n\n    results = []\n    for params in test_cases:\n        t, msd = generate_msd_data(**params)\n        D_si = estimate_diffusion_coefficient(t, msd)\n        results.append(D_si)\n\n    # Format and print the final output exactly as required.\n    print(f\"[{','.join(f'{d:.2e}' for d in results)}]\")\n\ndef generate_msd_data(N, t_max, v_2, a, t_b, t_c, t_d, D, sigma, seed, t_min=1e-3):\n    \"\"\"\n    Generates synthetic MSD data based on the provided formula and parameters.\n    \"\"\"\n    np.random.seed(seed)\n    \n    t = np.linspace(t_min, t_max, N)\n    \n    # Ballistic term\n    msd_ballistic = v_2 * t**2 * np.exp(-(t / t_b)**2)\n    \n    # Caging term\n    msd_caging = a * (1 - np.exp(-(t / t_c)**2)) * np.exp(-(t / t_d)**2)\n    \n    # Diffusive term\n    msd_diffusive = 6 * D * t * (1 - np.exp(-(t / t_d)**2))\n    \n    msd_clean = msd_ballistic + msd_caging + msd_diffusive\n    \n    # Add Gaussian noise\n    noise = np.random.normal(0, sigma, N)\n    msd_noisy = msd_clean + noise\n    \n    # Clip non-positive values to prevent log(0) or log(0) issues\n    msd = np.maximum(msd_noisy, 1e-12)\n    \n    return t, msd\n\ndef estimate_diffusion_coefficient(t, msd):\n    \"\"\"\n    Estimates the diffusion coefficient using a data-adaptive windowing method.\n    \"\"\"\n    N = len(t)\n    \n    # --- Step 1: Calculate local scaling exponent alpha(t) ---\n    # Use a sliding window to perform log-log fits for noise robustness.\n    # The chosen window size must be an odd integer.\n    alpha_window_size = 51 \n    half_window = alpha_window_size // 2\n    \n    alphas = np.full(N, np.nan)\n    \n    log_t = np.log(t)\n    log_msd = np.log(msd)\n    \n    for i in range(half_window, N - half_window):\n        # Define the window for the local fit\n        start, end = i - half_window, i + half_window + 1\n        \n        # polyfit(x, y, 1) returns [slope, intercept]\n        slope, _ = np.polyfit(log_t[start:end], log_msd[start:end], 1)\n        alphas[i] = slope\n\n    # --- Step 2: Identify candidate diffusive windows ---\n    alpha_tolerance = 0.1\n    min_window_frac = 0.1\n    min_len = int(min_window_frac * N)\n\n    # Find indices where alpha is close to 1\n    diffusive_indices = np.where(np.abs(alphas - 1.0) < alpha_tolerance)[0]\n\n    if len(diffusive_indices) == 0:\n        # Fallback if no window is found - this shouldn't happen with the test data\n        return np.nan\n\n    # Group consecutive indices into windows\n    candidate_windows = []\n    if len(diffusive_indices) > 0:\n        # Split a list of indices into sub-lists of consecutive numbers\n        splits = np.where(np.diff(diffusive_indices) != 1)[0] + 1\n        contiguous_blocks = np.split(diffusive_indices, splits)\n        \n        for block in contiguous_blocks:\n            if len(block) >= min_len:\n                candidate_windows.append(block)\n\n    if not candidate_windows:\n        # If no window meets the minimum length, try relaxing criteria (not done here as it's not needed for the given problem)\n        return np.nan # Or handle error appropriately\n\n    # --- Step 3: Select the best window ---\n    # Rule: Choose the longest window. If tied, choose the one latest in time.\n    best_window = max(candidate_windows, key=lambda w: (len(w), w[-1]))\n    \n    t_window = t[best_window]\n    msd_window = msd[best_window]\n\n    # --- Step 4: Perform robust linear regression ---\n    # Use Theil-Sen estimator on the selected window (MSD vs t)\n    # theilslopes returns (slope, intercept, low_slope, high_slope)\n    slope, _, _, _ = theilslopes(y=msd_window, x=t_window)\n    \n    # --- Step 5: Calculate D and convert units ---\n    # D_sim = slope / (2 * dimensions), here dimensions=3\n    D_sim = slope / 6.0  # units: nm^2 / ps\n    \n    # Conversion factor from nm^2/ps to m^2/s\n    # 1 nm^2/ps = (10^-9 m)^2 / (10^-12 s) = 10^-18 m^2 / 10^-12 s = 10^-6 m^2/s\n    conversion_factor = 1e-6\n    D_si = D_sim * conversion_factor # units: m^2 / s\n    \n    return D_si\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}