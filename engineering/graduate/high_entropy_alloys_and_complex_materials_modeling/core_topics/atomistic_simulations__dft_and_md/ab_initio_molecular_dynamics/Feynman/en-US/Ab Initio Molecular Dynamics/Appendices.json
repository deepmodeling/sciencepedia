{
    "hands_on_practices": [
        {
            "introduction": "In molecular dynamics, temperature is a macroscopic property that emerges from the microscopic motion of atoms. This exercise connects the concept of temperature $T$ to the average kinetic energy per atom, $\\langle E_{kin} \\rangle = \\frac{3}{2} k_B T$, using the equipartition theorem from classical statistical mechanics. Mastering this principle is fundamental to understanding how thermostats function to control temperature in AIMD simulations and to correctly interpreting the thermal properties of a simulated system. ",
            "id": "4236153",
            "problem": "You are given a scientifically realistic scenario in computational electrochemistry involving Ab Initio Molecular Dynamics (AIMD). In Born–Oppenheimer Ab Initio Molecular Dynamics (AIMD), the electrons are assumed to remain in the instantaneous ground state for the current nuclear positions, and the nuclei evolve according to classical Newtonian dynamics with forces obtained from the electronic ground-state energy surface. Consider a small aqueous sodium chloride system near a platinum $(111)$ slab. The task is to use first principles to determine the mean kinetic energy per atom during a canonical ensemble trajectory at a specified temperature and to reason about how the trajectory would be set up.\n\nStarting from fundamental laws and definitions only, derive the mean kinetic energy per atom in a classical canonical ensemble for nuclei evolving under the Born–Oppenheimer approximation at temperature $T$ with no holonomic constraints. The derivation must begin from the definitions of kinetic energy and the canonical ensemble and should connect to how velocities are distributed for classical nuclei at equilibrium. Then, implement a program that computes the mean kinetic energy per atom from a given set of temperatures, assuming a three-dimensional system in which each atom has three translational degrees of freedom and there are no constraints.\n\nFor context, a typical $10\\ \\mathrm{ps}$ Born–Oppenheimer trajectory at $T=300\\ \\mathrm{K}$ would use a time step of order $0.5$ to $1.0\\ \\mathrm{fs}$, yielding $10000$ to $20000$ steps, with forces obtained at each step from electronic structure calculations at fixed nuclear positions, and a thermostat to maintain the canonical ensemble. However, in this problem your program must only compute the mean kinetic energy per atom as a function of temperature, consistent with the canonical ensemble for classical nuclei.\n\nPhysical units requirement: Express the mean kinetic energy per atom in electronvolts. The program must output values in $\\mathrm{eV}$, rounded to six decimal places.\n\nAngle unit requirement: Not applicable, as no angles are involved.\n\nPercentages requirement: Not applicable.\n\nTest Suite:\n- Case 1 (happy path): $T=300\\ \\mathrm{K}$\n- Case 2 (boundary condition at absolute zero): $T=0\\ \\mathrm{K}$\n- Case 3 (high temperature edge case): $T=1000\\ \\mathrm{K}$\n- Case 4 (near-ambient temperature with higher precision): $T=298.15\\ \\mathrm{K}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$), where each $result$ is the mean kinetic energy per atom in $\\mathrm{eV}$, rounded to six decimal places, corresponding respectively to the four test temperatures above.",
            "solution": "The problem asks for a first-principles derivation of the mean kinetic energy per atom for a system of classical nuclei in a canonical ensemble at temperature $T$, followed by a programmatic calculation for specific temperatures.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Theoretical Framework**: Born-Oppenheimer Ab Initio Molecular Dynamics (AIMD).\n- **Physical Model**: Nuclei evolve according to classical Newtonian dynamics. Electrons are in the ground state for fixed nuclear positions.\n- **Ensemble**: Canonical ensemble (NVT).\n- **System Properties**: Each atom has three translational degrees of freedom. There are no holonomic constraints.\n- **Task 1 (Derivation)**: Derive the mean kinetic energy per atom starting from the definitions of kinetic energy and the canonical ensemble.\n- **Task 2 (Calculation)**: Implement a program to compute the mean kinetic energy per atom for a given set of temperatures.\n- **Units**: The final result must be in electronvolts ($\\mathrm{eV}$).\n- **Rounding**: Numerical outputs must be rounded to six decimal places.\n- **Test Cases**:\n    - Case 1: $T = 300\\ \\mathrm{K}$\n    - Case 2: $T = 0\\ \\mathrm{K}$\n    - Case 3: $T = 1000\\ \\mathrm{K}$\n    - Case 4: $T = 298.15\\ \\mathrm{K}$\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective.\n1.  **Scientific Soundness**: The problem is built upon fundamental principles of classical statistical mechanics (canonical ensemble, equipartition theorem) and their application in computational chemistry (Born-Oppenheimer approximation). These are standard and correct assumptions for this type of problem.\n2.  **Well-Posedness**: The objective is clearly defined: derive a known physical quantity and then compute its value under specified conditions. The assumptions (classical nuclei, 3 degrees of freedom, no constraints) are sufficient to yield a unique, stable, and meaningful solution.\n3.  **Objectivity**: The problem is stated in precise, quantitative terms, free from ambiguity or subjective content. The context of AIMD is used to frame a question about fundamental statistical mechanics, which is a valid pedagogical approach.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be provided.\n\n### Derivation and Solution\n\nThe derivation proceeds from the fundamental definitions of classical statistical mechanics for a system of $N$ atoms in a canonical ensemble at temperature $T$.\n\n1.  **Hamiltonian and Kinetic Energy**: In the Born-Oppenheimer approximation, the potential energy of the nuclei, $U(\\mathbf{r}_1, ..., \\mathbf{r}_N)$, depends only on their positions $\\mathbf{r}_i$. The total classical Hamiltonian $H$ for the nuclear subsystem is the sum of the kinetic energy $K$ and the potential energy $U$:\n    $$H(\\mathbf{r}^N, \\mathbf{p}^N) = K(\\mathbf{p}^N) + U(\\mathbf{r}^N)$$\n    where $\\mathbf{r}^N = (\\mathbf{r}_1, ..., \\mathbf{r}_N)$ and $\\mathbf{p}^N = (\\mathbf{p}_1, ..., \\mathbf{p}_N)$ represent the set of all position and momentum vectors. The total kinetic energy $K$ is the sum of the kinetic energies of each of the $N$ atoms:\n    $$K = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_i^2}{2m_i} = \\sum_{i=1}^{N} \\left( \\frac{p_{ix}^2}{2m_i} + \\frac{p_{iy}^2}{2m_i} + \\frac{p_{iz}^2}{2m_i} \\right)$$\n    Here, $m_i$ is the mass of the $i$-th atom, and $\\mathbf{p}_i = (p_{ix}, p_{iy}, p_{iz})$ is its momentum vector.\n\n2.  **Canonical Ensemble and Expectation Values**: In the canonical ensemble, the probability density of finding the system in a microstate with coordinates $(\\mathbf{r}^N, \\mathbf{p}^N)$ is given by:\n    $$\\rho(\\mathbf{r}^N, \\mathbf{p}^N) = \\frac{e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}}{Z}$$\n    where $\\beta = 1/(k_B T)$, $k_B$ is the Boltzmann constant, and $Z$ is the partition function, which normalizes the probability distribution:\n    $$Z = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, e^{-\\beta H(\\mathbf{r}^N, \\mathbf{p}^N)}$$\n    The average or expectation value of any observable quantity $A$ is given by:\n    $$\\langle A \\rangle = \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, A(\\mathbf{r}^N, \\mathbf{p}^N) \\rho(\\mathbf{r}^N, \\mathbf{p}^N)$$\n\n3.  **Mean Kinetic Energy**: We seek the mean total kinetic energy, $\\langle K \\rangle$.\n    $$\\langle K \\rangle = \\frac{1}{Z} \\int d\\mathbf{r}^N d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta (K(\\mathbf{p}^N) + U(\\mathbf{r}^N))}$$\n    Since the Hamiltonian is separable into a momentum-dependent part $K(\\mathbf{p}^N)$ and a position-dependent part $U(\\mathbf{r}^N)$, the partition function $Z$ can be factored:\n    $$Z = \\left( \\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right) = Z_p Z_r$$\n    Similarly, the integral for $\\langle K \\rangle$ separates:\n    $$\\langle K \\rangle = \\frac{1}{Z_p Z_r} \\left( \\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)} \\right) \\left( \\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)} \\right)$$\n    The positional integral $\\int d\\mathbf{r}^N \\, e^{-\\beta U(\\mathbf{r}^N)}$ is equal to $Z_r$, which cancels, leaving:\n    $$\\langle K \\rangle = \\frac{\\int d\\mathbf{p}^N \\, K(\\mathbf{p}^N) e^{-\\beta K(\\mathbf{p}^N)}}{\\int d\\mathbf{p}^N \\, e^{-\\beta K(\\mathbf{p}^N)}}$$\n    This shows that the mean kinetic energy is independent of the potential energy function $U(\\mathbf{r}^N)$.\n\n4.  **Equipartition Theorem**: The total kinetic energy is a sum of $3N$ independent quadratic terms (one for each momentum component $p_{ix}, p_{iy}, p_{iz}$ for each of the $N$ atoms). We can evaluate the average energy contribution from a single such term, for instance, $\\frac{p_{ix}^2}{2m_i}$.\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\int_{-\\infty}^{\\infty} dp_{ix} \\, \\frac{p_{ix}^2}{2m_i} e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}{\\int_{-\\infty}^{\\infty} dp_{ix} \\, e^{-\\beta \\frac{p_{ix}^2}{2m_i}}}$$\n    All other integrals over other momentum components cancel out between the numerator and the denominator. We use the standard Gaussian integrals:\n    $$\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\frac{\\pi}{a}}$$\n    $$\\int_{-\\infty}^{\\infty} x^2 e^{-ax^2} dx = -\\frac{d}{da} \\int_{-\\infty}^{\\infty} e^{-ax^2} dx = -\\frac{d}{da} \\sqrt{\\frac{\\pi}{a}} = \\frac{1}{2a}\\sqrt{\\frac{\\pi}{a}}$$\n    Letting $x = p_{ix}$ and $a = \\frac{\\beta}{2m_i}$:\n    - Denominator: $\\int_{-\\infty}^{\\infty} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    - Numerator: $\\int_{-\\infty}^{\\infty} \\frac{p_{ix}^2}{2m_i} e^{-\\frac{\\beta}{2m_i} p_{ix}^2} dp_{ix} = \\frac{1}{2m_i} \\left( \\frac{1}{2 \\frac{\\beta}{2m_i}}\\sqrt{\\frac{2 \\pi m_i}{\\beta}} \\right) = \\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}$\n    Taking the ratio gives:\n    $$\\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle = \\frac{\\frac{1}{2\\beta} \\sqrt{\\frac{2 \\pi m_i}{\\beta}}}{\\sqrt{\\frac{2 \\pi m_i}{\\beta}}} = \\frac{1}{2\\beta} = \\frac{1}{2} k_B T$$\n    This is the equipartition theorem: each quadratic degree of freedom in the Hamiltonian contributes an average energy of $\\frac{1}{2}k_B T$ to the system.\n\n5.  **Mean Kinetic Energy Per Atom**: The problem specifies that each atom has three translational degrees of freedom, and there are no constraints. The kinetic energy part of the Hamiltonian contains $3N$ such quadratic terms. Therefore, the total mean kinetic energy for the system of $N$ atoms is:\n    $$\\langle K_{total} \\rangle = \\sum_{i=1}^{N} \\left( \\left\\langle \\frac{p_{ix}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iy}^2}{2m_i} \\right\\rangle + \\left\\langle \\frac{p_{iz}^2}{2m_i} \\right\\rangle \\right) = 3N \\times \\left(\\frac{1}{2} k_B T\\right) = \\frac{3}{2} N k_B T$$\n    To find the mean kinetic energy per atom, $\\langle E_{kin, atom} \\rangle$, we divide the total mean kinetic energy by the number of atoms, $N$:\n    $$\\langle E_{kin, atom} \\rangle = \\frac{\\langle K_{total} \\rangle}{N} = \\frac{\\frac{3}{2} N k_B T}{N} = \\frac{3}{2} k_B T$$\n    This is the final derived expression. It is a universal result for any classical system in thermal equilibrium where the kinetic energy is quadratic in momenta and there are three unconstrained degrees of freedom per particle.\n\n6.  **Numerical Calculation**: To implement the calculation, we use the value of the Boltzmann constant in the required units of electronvolts per Kelvin ($\\mathrm{eV}/\\mathrm{K}$).\n    - $k_B \\approx 8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}$\n    - The formula is: $\\langle E_{kin, atom} \\rangle [\\mathrm{eV}] = \\frac{3}{2} \\times (8.617333262 \\times 10^{-5}\\ \\mathrm{eV}/\\mathrm{K}) \\times T[\\mathrm{K}]$\n\nThis formula is now implemented for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean kinetic energy per atom for a classical system\n    in a canonical ensemble at various temperatures.\n    \"\"\"\n    \n    # The Boltzmann constant in electronvolts per Kelvin (eV/K).\n    # Source: CODATA 2018 value.\n    K_B_EV_PER_K = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    # Temperatures are in Kelvin (K).\n    test_cases = [\n        300.0,      # Case 1 (happy path)\n        0.0,        # Case 2 (boundary condition at absolute zero)\n        1000.0,     # Case 3 (high temperature edge case)\n        298.15      # Case 4 (near-ambient temperature with higher precision)\n    ]\n\n    results = []\n    for T in test_cases:\n        # According to the equipartition theorem for a classical system with\n        # 3 translational degrees of freedom per atom and no constraints,\n        # the mean kinetic energy per atom is (3/2) * k_B * T.\n        #\n        # Degrees of freedom (dof) = 3 (for x, y, z translation)\n        # Mean energy per dof = (1/2) * k_B * T\n        # Mean kinetic energy per atom = dof * (1/2) * k_B * T = (3/2) * k_B * T\n        \n        mean_kinetic_energy_per_atom = 1.5 * K_B_EV_PER_K * T\n        \n        # Round the result to six decimal places as required.\n        # We use a format string for robust formatting to ensure trailing zeros.\n        rounded_result = \"{:.6f}\".format(mean_kinetic_energy_per_atom)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format: [result1,result2,result3,result4]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A critical test of any molecular dynamics simulation's stability is its ability to conserve total energy in the microcanonical ($NVE$) ensemble. This practice provides a quantitative approach to diagnosing and controlling numerical errors that cause energy drift in Born-Oppenheimer MD. By modeling the sources of drift from the integration time step $\\Delta t$ and electronic convergence tolerance $\\tau$, you will learn to select parameters that ensure a robust and physically meaningful simulation. ",
            "id": "3728716",
            "problem": "Consider a Born-Oppenheimer Molecular Dynamics (BOMD) simulation in the microcanonical ensemble (constant number of particles, volume, and energy; NVE) for a high-entropy alloy composed of $128$ atoms. The total energy of the system should be conserved in an ideal continuous-time evolution under exact Self-Consistent Field (SCF) convergence and exact forces. In practice, two sources of systematic numerical error contribute to energy drift: the finite time step $\\Delta t$ of the integrator and the finite SCF convergence tolerance $\\tau$ of the electronic structure solver. For sufficiently small $\\Delta t$ and tight SCF tolerance, the energy drift rate per atom can be approximated by a model that is linear in the dominant small-error contributions. Assuming a velocity-Verlet integrator (which has a local truncation error of order $\\mathcal{O}((\\Delta t)^3)$ and a global energy error scaling as $\\mathcal{O}((\\Delta t)^2)$ for well-behaved forces) and a residual force error that scales approximately linearly with the SCF energy tolerance, adopt the following linearized drift-rate model:\n$$\nr(\\Delta t,\\tau) = \\alpha\\,(\\Delta t)^2 + \\beta\\,\\tau + \\gamma,\n$$\nwhere $r$ is the energy drift rate in meV/atom/ns, $\\Delta t$ is the time step in fs (femtoseconds), $\\tau$ is the SCF energy tolerance in eV (electronvolts), and $\\alpha$, $\\beta$, $\\gamma$ are parameters to be determined.\n\nYou are provided with calibration measurements of the energy drift rate $r$ for a set of $(\\Delta t,\\tau)$ pairs obtained from short NVE BOMD runs on the $128$-atom high-entropy alloy. All listed $r$ values are per atom in meV/atom/ns. Use these calibration data to fit the linear model parameters $\\alpha$, $\\beta$, and $\\gamma$ via least squares:\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.1625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.6125$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.6125$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.5500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.8000$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.8000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.1000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.3000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=1.5500$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=3.5500$\n\nAfter fitting $\\alpha$, $\\beta$, and $\\gamma$, quantify the energy drift for specified test $(\\Delta t,\\tau)$ pairs by evaluating $r(\\Delta t,\\tau)$. Furthermore, derive a recommendation for the maximum allowable time step $\\Delta t_{\\max}$ as a function of SCF tolerance $\\tau$ such that the drift rate remains below a target threshold $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$. Using the fitted model, this recommendation must satisfy:\n$$\n\\Delta t_{\\max}(\\tau) = \n\\begin{cases}\n\\sqrt{\\dfrac{r_{\\text{thr}} - \\beta\\,\\tau - \\gamma}{\\alpha}}, & \\text{if } r_{\\text{thr}} - \\beta\\,\\tau - \\gamma > 0 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nwith $\\Delta t_{\\max}$ expressed in fs.\n\nYour program must perform the following steps:\n1. Fit the parameters $\\alpha$, $\\beta$, and $\\gamma$ using the calibration dataset above.\n2. Compute the predicted drift rates $r(\\Delta t,\\tau)$ for the following test pairs:\n   - $\\Delta t=1.0\\,\\text{fs}$, $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\Delta t=2.0\\,\\text{fs}$, $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\Delta t=1.5\\,\\text{fs}$, $\\tau=1\\times 10^{-4}\\,\\text{eV}$.\n   Report each $r$ in meV/atom/ns.\n3. Compute the recommended $\\Delta t_{\\max}$ for the following SCF tolerances to keep the drift below $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$:\n   - $\\tau=1\\times 10^{-5}\\,\\text{eV}$,\n   - $\\tau=5\\times 10^{-5}\\,\\text{eV}$,\n   - $\\tau=1\\times 10^{-4}\\,\\text{eV}$,\n   - $\\tau=5\\times 10^{-4}\\,\\text{eV}$.\n   Report each $\\Delta t_{\\max}$ in fs.\n\nAll numerical answers must be floats rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order: the three predicted drift rates followed by the four recommended maximum time steps, i.e., $[r_{1},r_{2},r_{3},\\Delta t_{\\max,1},\\Delta t_{\\max,2},\\Delta t_{\\max,3},\\Delta t_{\\max,4}]$.",
            "solution": "The problem requires us to determine the parameters of a linear model for energy drift in a Born-Oppenheimer Molecular Dynamics (BOMD) simulation and then use this model for prediction and to establish operational constraints. The analysis proceeds in two main stages: first, fitting the model parameters using the method of linear least squares, and second, applying the fitted model to answer the specific questions posed.\n\nThe proposed model for the energy drift rate per atom, $r$, is given by:\n$$\nr(\\Delta t, \\tau) = \\alpha (\\Delta t)^2 + \\beta \\tau + \\gamma\n$$\nwhere $\\Delta t$ is the integration time step in femtoseconds (fs), $\\tau$ is the Self-Consistent Field (SCF) energy convergence tolerance in electronvolts (eV), and $r$ is the drift rate in meV/atom/ns. The parameters to be determined are $\\alpha$, $\\beta$, and $\\gamma$. This model is linear with respect to the parameters. The term $(\\Delta t)^2$ is physically motivated by the global energy error scaling of the velocity-Verlet integrator, and the linear dependence on $\\tau$ is a reasonable first-order approximation for the influence of incomplete SCF convergence on atomic forces.\n\nWe are given $12$ calibration data points of the form $((\\Delta t)_i, \\tau_i, r_i)$, for $i=1, \\dots, 12$. To find the best-fit parameters $\\alpha$, $\\beta$, and $\\gamma$, we employ the method of linear least squares. This method minimizes the sum of the squared differences between the observed drift rates $r_i$ and the rates predicted by the model.\n\nLet us define a parameter vector $\\mathbf{p}$ and a feature vector $\\mathbf{x}_i$ for each data point:\n$$\n\\mathbf{p} = \\begin{pmatrix} \\alpha \\\\ \\beta \\\\ \\gamma \\end{pmatrix}, \\quad \\mathbf{x}_i = \\begin{pmatrix} (\\Delta t_i)^2 \\\\ \\tau_i \\\\ 1 \\end{pmatrix}\n$$\nThe model can then be expressed as $r_i \\approx \\mathbf{x}_i^T \\mathbf{p}$. We can assemble all $12$ equations into a single matrix equation:\n$$\n\\mathbf{A} \\mathbf{p} = \\mathbf{b}\n$$\nwhere $\\mathbf{A}$ is the $12 \\times 3$ design matrix whose rows are the feature vectors $\\mathbf{x}_i^T$, and $\\mathbf{b}$ is the $12 \\times 1$ vector of observed drift rates $r_i$.\n\n$$\n\\mathbf{A} = \\begin{pmatrix}\n(\\Delta t_1)^2 & \\tau_1 & 1 \\\\\n(\\Delta t_2)^2 & \\tau_2 & 1 \\\\\n\\vdots & \\vdots & \\vdots \\\\\n(\\Delta t_{12})^2 & \\tau_{12} & 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n(0.5)^2 & 1 \\times 10^{-5} & 1 \\\\\n(0.5)^2 & 5 \\times 10^{-5} & 1 \\\\\n(0.5)^2 & 1 \\times 10^{-4} & 1 \\\\\n(0.5)^2 & 5 \\times 10^{-4} & 1 \\\\\n(1.0)^2 & 1 \\times 10^{-5} & 1 \\\\\n(1.0)^2 & 5 \\times 10^{-5} & 1 \\\\\n(1.0)^2 & 1 \\times 10^{-4} & 1 \\\\\n(1.0)^2 & 5 \\times 10^{-4} & 1 \\\\\n(2.0)^2 & 1 \\times 10^{-5} & 1 \\\\\n(2.0)^2 & 5 \\times 10^{-5} & 1 \\\\\n(2.0)^2 & 1 \\times 10^{-4} & 1 \\\\\n(2.0)^2 & 5 \\times 10^{-4} & 1\n\\end{pmatrix},\n\\quad\n\\mathbf{b} = \\begin{pmatrix}\n0.1625 \\\\ 0.3625 \\\\ 0.6125 \\\\ 2.6125 \\\\\n0.3500 \\\\ 0.5500 \\\\ 0.8000 \\\\ 2.8000 \\\\\n1.1000 \\\\ 1.3000 \\\\ 1.5500 \\\\ 3.5500\n\\end{pmatrix}\n$$\n\nThe least squares solution $\\mathbf{p}$ minimizes the Euclidean norm of the residual vector, $||\\mathbf{A} \\mathbf{p} - \\mathbf{b}||_2$. The solution is found by solving the normal equations:\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{p} = \\mathbf{A}^T \\mathbf{b}\n$$\nSolving this system of linear equations for $\\mathbf{p}$ yields the values for $\\alpha$, $\\beta$, and $\\gamma$. Performing this calculation with the given data results in:\n$$\n\\alpha = 0.25 \\, \\frac{\\text{meV/atom/ns}}{\\text{fs}^2}\n$$\n$$\n\\beta = 5000 \\, \\frac{\\text{meV/atom/ns}}{\\text{eV}}\n$$\n$$\n\\gamma = 0.05 \\, \\text{meV/atom/ns}\n$$\nThe data provided are perfectly described by these parameters, indicating no random noise in the calibration set. The fitted model is thus:\n$$\nr(\\Delta t, \\tau) = 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n\nWith the model parameterized, we can proceed to the required calculations.\n\n**1. Predicted Drift Rates**\n\nWe compute the drift rate $r$ for three test pairs $(\\Delta t, \\tau)$:\n- For $(\\Delta t=1.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$:\n$$\nr_1 = 0.25 (1.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25 + 0.05 + 0.05 = 0.35 \\, \\text{meV/atom/ns}\n$$\n- For $(\\Delta t=2.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$:\n$$\nr_2 = 0.25 (2.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25(4) + 0.05 + 0.05 = 1.0 + 0.05 + 0.05 = 1.10 \\, \\text{meV/atom/ns}\n$$\n- For $(\\Delta t=1.5\\,\\text{fs}, \\tau=1 \\times 10^{-4}\\,\\text{eV})$:\n$$\nr_3 = 0.25 (1.5)^2 + 5000 (1 \\times 10^{-4}) + 0.05 = 0.25(2.25) + 0.5 + 0.05 = 0.5625 + 0.5 + 0.05 = 1.1125 \\, \\text{meV/atom/ns}\n$$\n\n**2. Recommended Maximum Time Step**\n\nWe need to find the maximum time step $\\Delta t_{\\max}$ for a given tolerance $\\tau$ such that the drift rate does not exceed a threshold $r_{\\text{thr}} = 1.0\\,\\text{meV/atom/ns}$. We start from the model and solve for $\\Delta t$:\n$$\nr_{\\text{thr}} \\ge 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n$$\n(\\Delta t)^2 \\le \\frac{r_{\\text{thr}} - 5000 \\tau - 0.05}{0.25}\n$$\nFor $\\Delta t$ to be real, the numerator must be non-negative. This gives the expression for $\\Delta t_{\\max}$:\n$$\n\\Delta t_{\\max}(\\tau) = \\begin{cases}\n\\sqrt{\\dfrac{1.0 - 5000 \\tau - 0.05}{0.25}} = \\sqrt{4 (0.95 - 5000 \\tau)} = 2\\sqrt{0.95 - 5000 \\tau}, & \\text{if } 0.95 - 5000 \\tau > 0 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThe condition $0.95 - 5000 \\tau > 0$ implies $\\tau < \\frac{0.95}{5000} = 1.9 \\times 10^{-4}$ eV.\n\nWe now compute $\\Delta t_{\\max}$ for the four given values of $\\tau$:\n\n- For $\\tau = 1 \\times 10^{-5}\\,\\text{eV}$: The condition is met.\n$$\n\\Delta t_{\\max,1} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.05} = 2\\sqrt{0.90} \\approx 1.897367 \\, \\text{fs}\n$$\n- For $\\tau = 5 \\times 10^{-5}\\,\\text{eV}$: The condition is met.\n$$\n\\Delta t_{\\max,2} = 2\\sqrt{0.95 - 5000(5 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.25} = 2\\sqrt{0.70} \\approx 1.673320 \\, \\text{fs}\n$$\n- For $\\tau = 1 \\times 10^{-4}\\,\\text{eV}$: The condition is met.\n$$\n\\Delta t_{\\max,3} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-4})} = 2\\sqrt{0.95 - 0.50} = 2\\sqrt{0.45} \\approx 1.341641 \\, \\text{fs}\n$$\n- For $\\tau = 5 \\times 10^{-4}\\,\\text{eV}$: $5000 \\tau = 2.5$, which is greater than $0.95$. The numerator is negative.\n$$\n\\Delta t_{\\max,4} = 0 \\, \\text{fs}\n$$\n\nThe final collection of results, rounded to six decimal places, is: $r_1=0.350000$, $r_2=1.100000$, $r_3=1.112500$, $\\Delta t_{\\max,1}=1.897367$, $\\Delta t_{\\max,2}=1.673320$, $\\Delta t_{\\max,3}=1.341641$, and $\\Delta t_{\\max,4}=0.000000$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of fitting an energy drift model for BOMD simulations\n    and using it for prediction and constraint derivation.\n    \"\"\"\n    \n    # --- Step 1: Fit the model parameters using least squares ---\n    \n    # Calibration data: (delta_t, tau, r)\n    # delta_t is in fs, tau in eV, r in meV/atom/ns.\n    calibration_data = [\n        (0.5, 1e-5, 0.1625),\n        (0.5, 5e-5, 0.3625),\n        (0.5, 1e-4, 0.6125),\n        (0.5, 5e-4, 2.6125),\n        (1.0, 1e-5, 0.3500),\n        (1.0, 5e-5, 0.5500),\n        (1.0, 1e-4, 0.8000),\n        (1.0, 5e-4, 2.8000),\n        (2.0, 1e-5, 1.1000),\n        (2.0, 5e-5, 1.3000),\n        (2.0, 1e-4, 1.5500),\n        (2.0, 5e-4, 3.5500),\n    ]\n\n    # The model is r = alpha * (delta_t)^2 + beta * tau + gamma\n    # This is a linear model in the parameters (alpha, beta, gamma).\n    # We set up the linear system A * p = b, where p = [alpha, beta, gamma].\n    \n    num_points = len(calibration_data)\n    A = np.zeros((num_points, 3))\n    b = np.zeros(num_points)\n    \n    for i, (dt, tau, r) in enumerate(calibration_data):\n        A[i, 0] = dt**2\n        A[i, 1] = tau\n        A[i, 2] = 1\n        b[i] = r\n        \n    # Solve the least squares problem A*p = b for p\n    params, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    alpha, beta, gamma = params\n\n    # --- Step 2: Compute predicted drift rates for test cases ---\n    \n    test_rates_inputs = [\n        (1.0, 1e-5),  # (delta_t, tau)\n        (2.0, 1e-5),\n        (1.5, 1e-4),\n    ]\n    \n    predicted_rates = []\n    for dt, tau in test_rates_inputs:\n        rate = alpha * dt**2 + beta * tau + gamma\n        predicted_rates.append(rate)\n\n    # --- Step 3: Compute recommended max time step ---\n\n    r_thr = 1.0  # meV/atom/ns\n    \n    test_dtmax_inputs = [\n        1e-5,  # tau in eV\n        5e-5,\n        1e-4,\n        5e-4,\n    ]\n    \n    recommended_dtmax = []\n    for tau in test_dtmax_inputs:\n        # dt_max = sqrt((r_thr - beta*tau - gamma) / alpha)\n        numerator = r_thr - beta * tau - gamma\n        if numerator > 0:\n            dt_max = np.sqrt(numerator / alpha)\n        else:\n            dt_max = 0.0\n        recommended_dtmax.append(dt_max)\n        \n    # Combine all results\n    all_results = predicted_rates + recommended_dtmax\n    \n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The practical application of AIMD involves a crucial trade-off between computational accuracy and cost. This exercise guides you through the process of designing a convergence study, a standard procedure for determining the optimal simulation parameters. By systematically analyzing how the plane-wave cutoff energy $E_{\\text{cut}}$ and the k-point mesh affect calculated forces and stresses, you will learn to configure simulations that are both reliable and computationally efficient. ",
            "id": "3728689",
            "problem": "You are asked to formalize and solve a convergence study design for Ab Initio Molecular Dynamics (AIMD) applied to a liquid High-Entropy Alloy (HEA). The objective is to determine the minimal plane-wave kinetic energy cutoff and the minimal uniform $k$-point grid per direction that bound the force and stress errors across a set of representative atomic snapshots within specified tolerances. Begin from the definitions of discretization error and computational cost, and formulate a selection rule that minimizes cost subject to error constraints. Then implement this selection rule.\n\nDefinitions and assumptions:\n- Ab Initio Molecular Dynamics (AIMD) computes interatomic forces and stress using electronic structure calculations that employ a plane-wave basis with kinetic energy cutoff and $k$-point sampling in reciprocal space. Discretization of the basis and sampling introduces errors in forces and stress.\n- Let there be $N$ representative snapshots indexed by $s \\in \\{1,\\dots,N\\}$. For a given plane-wave kinetic energy cutoff $E_{\\text{cut}}$ (in eV) and a uniform Monkhorst-Pack $k$-point grid size per direction $K$ (dimensionless integer), the force error at snapshot $s$ is modeled as\n$$\n\\mathcal{E}_f^{(s)}(E_{\\text{cut}},K) = A_s \\, E_{\\text{cut}}^{-p} + B_s \\, K^{-q}\n$$\nand the stress error at snapshot $s$ is modeled as\n$$\n\\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K) = C_s \\, E_{\\text{cut}}^{-p_\\sigma} + D_s \\, K^{-q_\\sigma}.\n$$\nHere $A_s$, $B_s$, $C_s$, and $D_s$ are nonnegative coefficients that encode snapshot-dependent sensitivity, and $p$, $q$, $p_\\sigma$, $q_\\sigma$ are positive exponents describing error decay with increasing $E_{\\text{cut}}$ and $K$.\n- The maximal errors across snapshots are\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_f^{(s)}(E_{\\text{cut}},K), \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K).\n$$\n- The target tolerances are a force error bound $T_f$ and a stress error bound $T_\\sigma$. The convergence feasibility constraints are\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f, \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma.\n$$\n- The computational cost model is\n$$\n\\mathcal{C}(E_{\\text{cut}},K) = \\alpha \\, E_{\\text{cut}}^{3/2} + \\beta \\, K^3,\n$$\nwhere $\\alpha$ and $\\beta$ are positive weights reflecting the scaling of the number of plane waves with $E_{\\text{cut}}$ and the number of sampled points with $K$ per direction.\n- Among candidate values $E_{\\text{cut}} \\in \\mathcal{E}$ and $K \\in \\mathcal{K}$, select the pair $(E_{\\text{cut}}^\\star,K^\\star)$ that satisfies the feasibility constraints and minimizes $\\mathcal{C}(E_{\\text{cut}},K)$. If multiple pairs have identical minimal cost, choose the one with smaller $E_{\\text{cut}}$, and if still tied, choose the one with smaller $K$. If no feasible pair exists, return a sentinel output indicating infeasibility.\n\nScientific units and output specification:\n- Express $E_{\\text{cut}}$ in eV and $K$ as an integer per direction. The force error bound $T_f$ is in meV/Å and the stress error bound $T_\\sigma$ is in GPa. There are no angle quantities in this problem.\n- Your program must compute the selection for each test case below and produce a single line of output containing a comma-separated list of per-test-case results, each result formatted as a two-element list $[E_{\\text{cut}},K]$ with $E_{\\text{cut}}$ represented as a decimal (float) and $K$ as an integer, all enclosed in square brackets. For example, the output line must look like $[[400.0,2],[300.0,1],[0.0,0]]$.\n\nTest suite:\n- Test case $1$ (happy path):\n  - $N = 3$ snapshots, coefficients:\n    - Force: $A = [1600,1400,1500]$ (units meV/Å$\\cdot$eV$^p$), $B = [4.0,6.0,5.0]$ (units meV/Å), exponents $p = 1.0$, $q = 2.0$.\n    - Stress: $C = [20.0,16.0,18.0]$ (units GPa$\\cdot$eV$^{p_\\sigma}$), $D = [0.05,0.07,0.06]$ (units GPa), exponents $p_\\sigma = 0.8$, $q_\\sigma = 1.5$.\n  - Tolerances: $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa.\n  - Candidates: $\\mathcal{E} = [300,350,400,450,500,600]$ eV, $\\mathcal{K} = [1,2,3,4,5,6]$.\n  - Cost weights: $\\alpha = 1.0$, $\\beta = 0.08$.\n- Test case $2$ (boundary and tie-possibility):\n  - $N = 2$ snapshots, coefficients:\n    - Force: $A = [1200,1200]$, $B = [0.5,0.5]$, exponents $p = 1.0$, $q = 1.0$.\n    - Stress: $C = [10.0,8.0]$, $D = [0.02,0.02]$, exponents $p_\\sigma = 1.0$, $q_\\sigma = 1.0$.\n  - Tolerances: $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa.\n  - Candidates: $\\mathcal{E} = [300,350,400,450,500,600]$ eV, $\\mathcal{K} = [1,2,3,4,5,6]$.\n  - Cost weights: $\\alpha = 1.0$, $\\beta = 0.08$.\n- Test case $3$ (edge case infeasible):\n  - $N = 2$ snapshots, coefficients:\n    - Force: $A = [8000,9000]$, $B = [10.0,10.0]$, exponents $p = 1.0$, $q = 2.0$.\n    - Stress: $C = [100.0,120.0]$, $D = [0.10,0.10]$, exponents $p_\\sigma = 1.0$, $q_\\sigma = 1.0$.\n  - Tolerances: $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa.\n  - Candidates: $\\mathcal{E} = [300,350,400,450,500,600]$ eV, $\\mathcal{K} = [1,2,3,4,5,6]$.\n  - Cost weights: $\\alpha = 1.0$, $\\beta = 0.08$.\n- Sentinel output rule: If no feasible pair exists, output $[0.0,0]$ for that test case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each per-test-case result itself being a two-element list $[E_{\\text{cut}},K]$ as specified, for example $[[400.0,2],[300.0,1],[0.0,0]]$.",
            "solution": "The goal is to design and implement a principled selection of the plane-wave kinetic energy cutoff and $k$-point grid per direction that jointly satisfy error tolerances for forces and stress across representative snapshots, while minimizing a model of computational cost. The scientific basis is the behavior of discretization errors in plane-wave electronic structure calculations and Brillouin zone sampling. In a plane-wave basis, the number of basis functions scales with the volume of reciprocal space inside the kinetic energy sphere, which is proportional to $E_{\\text{cut}}^{3/2}$, and in uniform $k$-point sampling, the number of sampled points grows like $K^3$ for a cubic grid of size $K \\times K \\times K$. These scalings motivate the cost model $\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$. The discretization errors typically decrease monotonically with $E_{\\text{cut}}$ and $K$, and the provided parametric error model captures this decay: $\\mathcal{E}_f^{(s)} = A_s E_{\\text{cut}}^{-p} + B_s K^{-q}$ and $\\mathcal{E}_\\sigma^{(s)} = C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma}$ with positive exponents.\n\nPrinciple-based algorithm design:\n- Start from the definitions of maximum errors across snapshots,\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( A_s E_{\\text{cut}}^{-p} + B_s K^{-q} \\right), \\quad\n\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma} \\right).\n$$\n- The feasibility region in $(E_{\\text{cut}},K)$ is the set where $\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$ and $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$ simultaneously.\n- Among discrete candidates $E_{\\text{cut}} \\in \\mathcal{E}$ and $K \\in \\mathcal{K}$, select the feasible pair that minimizes $\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$. If ties occur, prefer smaller $E_{\\text{cut}}$, then smaller $K$.\n\nAlgorithm steps:\n- For each $E_{\\text{cut}} \\in \\mathcal{E}$ and each $K \\in \\mathcal{K}$:\n  - Compute $\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K)$ and $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K)$ from the snapshot coefficients and exponents.\n  - Check feasibility: $\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$ and $\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$.\n  - If feasible, evaluate $\\mathcal{C}(E_{\\text{cut}},K)$ and track the minimal cost solution with the specified tie-breaks.\n- If no feasible pair exists, return the sentinel $[0.0,0]$.\n\nValidation on the test suite:\n- Test case $1$:\n  - Parameters: $A = [1600,1400,1500]$, $B = [4.0,6.0,5.0]$, $p = 1.0$, $q = 2.0$; $C = [20.0,16.0,18.0]$, $D = [0.05,0.07,0.06]$, $p_\\sigma = 0.8$, $q_\\sigma = 1.5$; $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa; $\\mathcal{E} = [300,350,400,450,500,600]$ eV; $\\mathcal{K} = [1,2,3,4,5,6]$; $\\alpha = 1.0$, $\\beta = 0.08$.\n  - Consider $E_{\\text{cut}} = 400$ eV, $K = 2$. Force errors per snapshot:\n    - Snapshot $1$: $\\mathcal{E}_f^{(1)} = 1600 \\cdot 400^{-1.0} + 4.0 \\cdot 2^{-2.0} = 4.0 + 1.0 = 5.0$ meV/Å.\n    - Snapshot $2$: $\\mathcal{E}_f^{(2)} = 1400 \\cdot 400^{-1.0} + 6.0 \\cdot 2^{-2.0} = 3.5 + 1.5 = 5.0$ meV/Å.\n    - Snapshot $3$: $\\mathcal{E}_f^{(3)} = 1500 \\cdot 400^{-1.0} + 5.0 \\cdot 2^{-2.0} = 3.75 + 1.25 = 5.0$ meV/Å.\n    - Hence $\\mathcal{E}_f^{\\max}(400,2) = 5.0$ meV/Å satisfies $T_f = 5.0$ meV/Å.\n  - Stress errors per snapshot:\n    - Compute $400^{-0.8}$. Using $400^{-0.8} \\approx \\exp(-0.8 \\ln 400) \\approx \\exp(-0.8 \\cdot 5.991) \\approx \\exp(-4.793) \\approx 0.0083$.\n    - $2^{-1.5} = 1 / 2^{1.5} = 1 / (2 \\sqrt{2}) \\approx 1 / 2.828 \\approx 0.3536$.\n    - Snapshot $1$: $\\mathcal{E}_\\sigma^{(1)} = 20.0 \\cdot 0.0083 + 0.05 \\cdot 0.3536 \\approx 0.166 + 0.0177 \\approx 0.1837$ GPa.\n    - Snapshot $2$: $\\mathcal{E}_\\sigma^{(2)} = 16.0 \\cdot 0.0083 + 0.07 \\cdot 0.3536 \\approx 0.133 + 0.0248 \\approx 0.1578$ GPa.\n    - Snapshot $3$: $\\mathcal{E}_\\sigma^{(3)} = 18.0 \\cdot 0.0083 + 0.06 \\cdot 0.3536 \\approx 0.149 + 0.0212 \\approx 0.1702$ GPa.\n    - Hence $\\mathcal{E}_\\sigma^{\\max}(400,2) \\approx 0.1837$ GPa satisfies $T_\\sigma = 0.2$ GPa.\n  - Check whether any lower-cost pair could satisfy both bounds. For $E_{\\text{cut}} = 350$ eV, $A \\cdot 350^{-1.0}$ forces are at least $4.571$ meV/Å for snapshot $1$, and with $K \\ge 2$, the added $B_s K^{-2}$ term increases the error, so the maximum force exceeds $5.0$ meV/Å. For $K = 1$, the $B_s K^{-2}$ term is larger and infeasible. Thus $(400,2)$ is the minimal feasible pair by $E_{\\text{cut}}$ and $K$ among the candidate sets. Its cost is $\\mathcal{C}(400,2) = 1.0 \\cdot 400^{3/2} + 0.08 \\cdot 2^3 = 8000.0 + 0.64 = 8000.64$, and no lower $E_{\\text{cut}}$ or $K$ choice is feasible, making $(400,2)$ the selected pair.\n- Test case $2$:\n  - Parameters: $A = [1200,1200]$, $B = [0.5,0.5]$, $p = 1.0$, $q = 1.0$; $C = [10.0,8.0]$, $D = [0.02,0.02]$, $p_\\sigma = 1.0$, $q_\\sigma = 1.0$; $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa; same candidates and cost weights as test case $1$.\n  - Evaluate $(E_{\\text{cut}},K) = (300,1)$:\n    - Force: $\\mathcal{E}_f^{(s)} = 1200 \\cdot 300^{-1.0} + 0.5 \\cdot 1^{-1.0} = 4.0 + 0.5 = 4.5$ meV/Å for both snapshots, hence $\\mathcal{E}_f^{\\max}(300,1) = 4.5 \\le 5.0$ meV/Å.\n    - Stress: snapshot $1$, $\\mathcal{E}_\\sigma^{(1)} = 10.0 \\cdot 300^{-1.0} + 0.02 \\cdot 1^{-1.0} = 0.033\\overline{3} + 0.02 \\approx 0.053\\overline{3}$ GPa; snapshot $2$, $\\mathcal{E}_\\sigma^{(2)} = 8.0 \\cdot 300^{-1.0} + 0.02 = 0.026\\overline{6} + 0.02 \\approx 0.046\\overline{6}$ GPa; thus $\\mathcal{E}_\\sigma^{\\max}(300,1) \\approx 0.053\\overline{3} \\le 0.2$ GPa.\n  - This pair is feasible and has cost $\\mathcal{C}(300,1) = 1.0 \\cdot 300^{3/2} + 0.08 \\cdot 1 = 300 \\cdot \\sqrt{300} + 0.08 \\approx 300 \\cdot 17.3205 + 0.08 \\approx 5196.15 + 0.08 \\approx 5196.23$, which is minimal among feasible pairs because it uses the smallest $E_{\\text{cut}}$ and $K$ that already satisfy the tolerances, and cost increases monotonically with either parameter. Hence $(300,1)$ is selected.\n- Test case $3$:\n  - Parameters: $A = [8000,9000]$, $B = [10.0,10.0]$, $p = 1.0$, $q = 2.0$; $C = [100.0,120.0]$, $D = [0.10,0.10]$, $p_\\sigma = 1.0$, $q_\\sigma = 1.0$; $T_f = 5.0$ meV/Å, $T_\\sigma = 0.2$ GPa; same candidates and cost weights.\n  - Evaluate the most favorable candidate $(E_{\\text{cut}},K) = (600,6)$ for forces:\n    - Snapshot $2$: $\\mathcal{E}_f^{(2)} = 9000 \\cdot 600^{-1.0} + 10.0 \\cdot 6^{-2.0} = 15.0 + 10.0/36 \\approx 15.0 + 0.277\\overline{7} \\approx 15.277\\overline{7}$ meV/Å, which far exceeds $T_f = 5.0$ meV/Å. Thus no candidate can satisfy the force bound, and feasibility fails.\n  - By the sentinel rule, the output for this test case is $[0.0,0]$.\n\nThe algorithm therefore returns the per-test-case selections $[400.0,2]$, $[300.0,1]$, and $[0.0,0]$. The implementation directly evaluates the defined functions over the candidate sets, applies the feasibility constraints, minimizes the cost under tie-break rules, and formats the output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef select_minimal_cutoff_and_kgrid(A, B, C, D, p, q, p_sigma, q_sigma,\n                                    T_f, T_sigma, E_candidates, K_candidates,\n                                    alpha, beta):\n    \"\"\"\n    Given error model parameters and candidate sets, select the minimal-cost\n    (E_cut, K) satisfying the force and stress tolerances across snapshots.\n    Tie-break by smaller E_cut, then smaller K. If none feasible, return [0.0, 0].\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    A = np.array(A, dtype=float)\n    B = np.array(B, dtype=float)\n    C = np.array(C, dtype=float)\n    D = np.array(D, dtype=float)\n    E_candidates = np.array(E_candidates, dtype=float)\n    K_candidates = np.array(K_candidates, dtype=int)\n\n    best_pair = None\n    best_cost = np.inf\n\n    for E in E_candidates:\n        # Precompute E-dependent factors\n        E_pow_f = E ** (-p)\n        E_pow_sigma = E ** (-p_sigma)\n        for K in K_candidates:\n            # Compute K-dependent factors\n            K_pow_f = K ** (-q)\n            K_pow_sigma = K ** (-q_sigma)\n\n            # Force and stress errors per snapshot\n            force_errors = A * E_pow_f + B * K_pow_f\n            stress_errors = C * E_pow_sigma + D * K_pow_sigma\n\n            max_force_error = np.max(force_errors)\n            max_stress_error = np.max(stress_errors)\n\n            # Check tolerances\n            if (max_force_error = T_f) and (max_stress_error = T_sigma):\n                # Compute cost\n                cost = alpha * (E ** 1.5) + beta * (K ** 3)\n                # Update best with tie-breaks: lower cost, then lower E, then lower K\n                if (cost  best_cost) or (\n                    np.isclose(cost, best_cost) and (\n                        (best_pair is None) or (E  best_pair[0]) or (\n                            (np.isclose(E, best_pair[0])) and (K  best_pair[1])\n                        )\n                    )\n                ):\n                    best_cost = cost\n                    best_pair = (float(E), int(K))\n\n    if best_pair is None:\n        return [0.0, 0]\n    else:\n        # Ensure E is printed as float\n        return [float(best_pair[0]), int(best_pair[1])]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": [1600, 1400, 1500],\n            \"B\": [4.0, 6.0, 5.0],\n            \"C\": [20.0, 16.0, 18.0],\n            \"D\": [0.05, 0.07, 0.06],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 0.8,\n            \"q_sigma\": 1.5,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [1200, 1200],\n            \"B\": [0.5, 0.5],\n            \"C\": [10.0, 8.0],\n            \"D\": [0.02, 0.02],\n            \"p\": 1.0,\n            \"q\": 1.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [8000, 9000],\n            \"B\": [10.0, 10.0],\n            \"C\": [100.0, 120.0],\n            \"D\": [0.10, 0.10],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = select_minimal_cutoff_and_kgrid(\n            A=case[\"A\"], B=case[\"B\"], C=case[\"C\"], D=case[\"D\"],\n            p=case[\"p\"], q=case[\"q\"], p_sigma=case[\"p_sigma\"], q_sigma=case[\"q_sigma\"],\n            T_f=case[\"T_f\"], T_sigma=case[\"T_sigma\"],\n            E_candidates=case[\"E_candidates\"], K_candidates=case[\"K_candidates\"],\n            alpha=case[\"alpha\"], beta=case[\"beta\"]\n        )\n        results.append(result)\n\n    # Format results as specified: single line, comma-separated, list of [E_cut,K] with no spaces.\n    formatted = \"[\" + \",\".join(f\"[{res[0]:.1f},{res[1]}]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        }
    ]
}