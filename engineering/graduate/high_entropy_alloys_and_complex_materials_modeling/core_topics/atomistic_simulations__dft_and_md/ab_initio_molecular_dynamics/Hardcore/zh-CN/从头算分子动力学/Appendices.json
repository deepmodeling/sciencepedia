{
    "hands_on_practices": [
        {
            "introduction": "第一性原理分子动力学主要有两种方法：Born-Oppenheimer分子动力学 (BOMD) 和 Car-Parrinello分子动力学 (CPMD)。本练习通过一个简化的水二聚体模型，让您亲手实现并对比这两种方法中的能量守恒性。通过模拟原子核与虚构电子坐标的耦合运动，您将深入理解维持绝热条件对于CPMD稳定性的重要性，并体会虚构电子质量和积分时间步长等参数选择的实践意义。",
            "id": "2448304",
            "problem": "你需要对应用于沿单一分子间坐标的简化水二聚体的两种第一性原理分子动力学范式中的能量守恒进行建模和比较。考虑一个一维核坐标 $R$，代表氧-氧间距，以玻尔半径 ($a_0$) 为单位测量。核运动由一个 Born–Oppenheimer 势能面控制，该势能面由 Morse 势近似：\n$$\nE_{\\mathrm{BO}}(R) \\;=\\; D \\left[\\left(1 - e^{-a(R - R_e)}\\right)^2 - 1\\right],\n$$\n其参数 $D$、$a$ 和 $R_e$ 在下面指定。与此同时，考虑一个辅助电子集体坐标 $q$（无量纲），其瞬时基态流形由 $q^\\star(R) = c\\,R$ 给出。定义一个扩展能量\n$$\nE_{\\mathrm{CP}}(R,q) \\;=\\; E_{\\mathrm{BO}}(R) \\;+\\; \\tfrac{1}{2} k_e \\left(q - c\\,R\\right)^2,\n$$\n其中耦合刚度为 $k_e$，无量纲比例常数为 $c$。你必须在持续时间为 $T = 1\\,\\mathrm{ps}$ 的轨迹上执行两种类型的动力学：\n- Born–Oppenheimer 分子动力学 (BOMD)：核坐标 $R$ 在 $E_{\\mathrm{BO}}(R)$ 上演化，没有显式的电子动力学。\n- Car–Parrinello 分子动力学 (CPMD)：核坐标 $R$ 和辅助坐标 $q$ 根据扩展能量 $E_{\\mathrm{CP}}(R,q)$ 演化，并使用一个虚拟电子质量 $M_q$。\n\n使用以下运动方程，其中点表示时间导数：\n- 对于 BOMD：\n$$\nM_R \\,\\ddot{R} \\;=\\; -\\frac{dE_{\\mathrm{BO}}}{dR}.\n$$\n- 对于 CPMD：\n$$\nM_R \\,\\ddot{R} \\;=\\; -\\frac{dE_{\\mathrm{BO}}}{dR} \\;+\\; k_e\\,c\\left(q - c\\,R\\right),\n\\qquad\nM_q \\,\\ddot{q} \\;=\\; -k_e \\left(q - c\\,R\\right).\n$$\n取核质量 $M_R$ 为两个氧原子沿 $R$ 坐标的约化质量：\n$$\nM_R \\;=\\; \\frac{1}{2} m_{\\mathrm{O}},\n\\qquad\nm_{\\mathrm{O}} \\;=\\; 15.999 \\,u,\n\\qquad\n1\\,u \\;=\\; 1822.888486209 \\,m_e,\n$$\n以原子单位表示，其中电子质量 $m_e = 1$。Morse 参数和耦合参数为：\n$$\nD \\;=\\; \\frac{0.22\\,\\mathrm{eV}}{27.211386245988\\,\\mathrm{eV/Ha}} \\;\\mathrm{Ha},\n\\quad\na \\;=\\; 3.0 \\;a_0^{-1},\n\\quad\nR_e \\;=\\; 5.5 \\;a_0,\n$$\n$$\nk_e \\;=\\; 0.5 \\;\\mathrm{Ha},\n\\qquad\nc \\;=\\; 0.05.\n$$\n使用时间 $t=0$ 时的初始条件：\n$$\nR(0) \\;=\\; R_e + 0.1 \\;a_0,\n\\qquad\n\\dot{R}(0) \\;=\\; 0,\n\\qquad\nq(0) \\;=\\; c\\,R(0),\n\\qquad\n\\dot{q}(0) \\;=\\; 0.\n$$\n对 BOMD 和 CPMD 进行模拟，总持续时间为 $T = 1\\,\\mathrm{ps}$。方程应在原子时间单位下进行积分，转换关系为 $1\\,\\mathrm{a.u.\\ of\\ time} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s}$ 和 $1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$。需要监控的总能量为：\n- 对于 BOMD：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{BO}}(t) \\;=\\; \\tfrac{1}{2} M_R \\dot{R}^2 \\;+\\; E_{\\mathrm{BO}}(R).\n$$\n- 对于 CPMD：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{CP}}(t) \\;=\\; \\tfrac{1}{2} M_R \\dot{R}^2 \\;+\\; \\tfrac{1}{2} M_q \\dot{q}^2 \\;+\\; E_{\\mathrm{CP}}(R,q).\n$$\n对于每次模拟，计算轨迹上的绝对总能量漂移，\n$$\n\\Delta E \\;=\\; \\left| E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0) \\right|,\n$$\n并以电子伏特 (eV) 为单位报告 $\\Delta E$，精确到 $6$ 位小数。\n\n测试套件。对于以下每一组参数 $(\\Delta t, M_q)$，运行 BOMD 和 CPMD，持续时间为 $T = 1\\,\\mathrm{ps}$，其中 $\\Delta t$ 是用于积分的数值时间步长：\n- 情况 A：$\\Delta t = 0.25\\,\\mathrm{fs}$，$M_q = 400$。\n- 情况 B：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 400$。\n- 情况 C：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 1600$。\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含一个包含六个浮点数的列表，分别代表情况 A、B 和 C 中 BOMD 和 CPMD 的能量漂移（单位 eV），每个数值都精确到 $6$ 位小数，顺序如下：\n$$\n[\\Delta E_{\\mathrm{BO}}^{A}, \\Delta E_{\\mathrm{CP}}^{A}, \\Delta E_{\\mathrm{BO}}^{B}, \\Delta E_{\\mathrm{CP}}^{B}, \\Delta E_{\\mathrm{BO}}^{C}, \\Delta E_{\\mathrm{CP}}^{C}].\n$$\n输出必须是单行，并且必须与指定的格式精确匹配（例如，$[0.000001,0.000002,0.000003,0.000004,0.000005,0.000006]$）。",
            "solution": "所述问题需要进行验证。\n\n### 第一步：提取已知条件\n- **核坐标**：$R$ (玻尔, $a_0$)\n- **Born–Oppenheimer 势**：$E_{\\mathrm{BO}}(R) = D[(1 - e^{-a(R - R_e)})^2 - 1]$\n- **辅助电子坐标**：$q$ (无量纲)\n- **电子基态流形**：$q^\\star(R) = c R$\n- **扩展 Car–Parrinello 能量**：$E_{\\mathrm{CP}}(R,q) = E_{\\mathrm{BO}}(R) + \\tfrac{1}{2} k_e (q - cR)^2$\n- **模拟持续时间**：$T = 1\\,\\mathrm{ps}$\n- **运动方程 (BOMD)**：$M_R \\ddot{R} = -\\frac{dE_{\\mathrm{BO}}}{dR}$\n- **运动方程 (CPMD)**：\n  $M_R \\ddot{R} = -\\frac{dE_{\\mathrm{BO}}}{dR} + k_e c(q - cR)$\n  $M_q \\ddot{q} = -k_e (q - cR)$\n- **质量**：$M_R = \\frac{1}{2} m_{\\mathrm{O}}$，$m_{\\mathrm{O}} = 15.999 \\,u$，$1\\,u = 1822.888486209 \\,m_e$，$m_e = 1$\n- **势参数**：$D = \\frac{0.22\\,\\mathrm{eV}}{27.211386245988\\,\\mathrm{eV/Ha}} \\;\\mathrm{Ha}$，$a = 3.0 \\;a_0^{-1}$，$R_e = 5.5 \\;a_0$\n- **耦合参数**：$k_e = 0.5 \\;\\mathrm{Ha}$，$c = 0.05$\n- **初始条件 ($t=0$)**：$R(0) = R_e + 0.1 \\;a_0$，$\\dot{R}(0) = 0$，$q(0) = c R(0)$，$\\dot{q}(0) = 0$\n- **时间转换**：$1\\,\\mathrm{a.u.\\ of\\ time} = 2.4188843265857 \\times 10^{-17}\\,\\mathrm{s}$，$1\\,\\mathrm{fs} = 10^{-15}\\,\\mathrm{s}$\n- **总能量 (BOMD)**：$E_{\\mathrm{tot}}^{\\mathrm{BO}}(t) = \\tfrac{1}{2} M_R \\dot{R}^2 + E_{\\mathrm{BO}}(R)$\n- **总能量 (CPMD)**：$E_{\\mathrm{tot}}^{\\mathrm{CP}}(t) = \\tfrac{1}{2} M_R \\dot{R}^2 + \\tfrac{1}{2} M_q \\dot{q}^2 + E_{\\mathrm{CP}}(R,q)$\n- **度量**：绝对能量漂移 $\\Delta E = | E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0) |$，单位为 eV，保留 $6$ 位小数。\n- **测试用例**：\n    - 情况 A：$\\Delta t = 0.25\\,\\mathrm{fs}$，$M_q = 400$\n    - 情况 B：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 400$\n    - 情况 C：$\\Delta t = 0.50\\,\\mathrm{fs}$，$M_q = 1600$\n- **输出格式**：$[\\Delta E_{\\mathrm{BO}}^{A}, \\Delta E_{\\mathrm{CP}}^{A}, \\Delta E_{\\mathrm{BO}}^{B}, \\Delta E_{\\mathrm{CP}}^{B}, \\Delta E_{\\mathrm{BO}}^{C}, \\Delta E_{\\mathrm{CP}}^{C}]$\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，它使用一个简化但物理上具有代表性的模型系统，对 Born-Oppenheimer 和 Car-Parrinello 分子动力学进行了标准比较。运动方程是根据所提供的能量泛函正确推导出来的。参数、单位和常数都给出了明确的规定，并且与计算化学中的标准值相符。该问题是适定的，提供了所有必要的初始条件和参数以确保存在唯一解。该问题是客观且自洽的，没有明显的矛盾或遗漏。\n\n### 第三步：结论与行动\n该问题被认定为有效。将构建一个解决方案。\n\n### 解决方案\n\n任务是在两种不同的理论框架下，即 Born-Oppenheimer 分子动力学 (BOMD) 和 Car-Parrinello 分子动力学 (CPMD)，模拟一维核坐标 $R$ 的经典动力学。主要目标是比较每种范式中总能量的数值守恒性。分析将在原子单位 (a.u.) 下进行，其中电子质量 $m_e$、基本电荷 $e$、约化普朗克常数 $\\hbar$ 和玻尔半径 $a_0$ 均设为 1。能量单位是哈特里 (Hartree, Ha)。\n\n首先，我们确定原子单位下的常数和参数。\n哈特里到电子伏特的转换关系为 $1\\,\\mathrm{Ha} \\approx 27.211386245988\\,\\mathrm{eV}$。\nMorse 势的解离能为 $D = \\frac{0.22}{27.211386245988}\\,\\mathrm{Ha} \\approx 0.0080850\\,\\mathrm{Ha}$。\n其他 Morse 参数为 $a = 3.0\\,a_0^{-1}$ 和 $R_e = 5.5\\,a_0$。\n氧二聚体约化运动的核质量 $M_R$ 为：\n$$\nM_R = \\frac{1}{2} m_{\\mathrm{O}} = \\frac{1}{2} (15.999\\,u) = \\frac{1}{2} \\times 15.999 \\times 1822.888486209 \\,m_e \\approx 14581.285 \\,m_e\n$$\nCPMD 耦合参数为 $k_e = 0.5\\,\\mathrm{Ha}$ 和 $c = 0.05$。\n模拟时间 $T = 1\\,\\mathrm{ps} = 1000\\,\\mathrm{fs}$。从飞秒到原子时间单位的转换为：\n$$\n1\\,\\mathrm{fs} = \\frac{10^{-15}\\,\\mathrm{s}}{2.4188843265857 \\times 10^{-17}\\,\\mathrm{s/a.u.}} \\approx 41.3413745758\\,\\mathrm{a.u.}\n$$\n因此，$T \\approx 41341.37\\,\\mathrm{a.u.}$ 时间步长为 $\\Delta t_A = 0.25\\,\\mathrm{fs} \\approx 10.335\\,\\mathrm{a.u.}$ 和 $\\Delta t_B = \\Delta t_C = 0.50\\,\\mathrm{fs} \\approx 20.671\\,\\mathrm{a.u.}$\n\n运动方程使用速度 Verlet 算法进行积分。这是一种时间可逆的辛积分器，以其在微正则系综模拟中出色的长期能量守恒特性而闻名。对于一个质量为 $M$、受力为 $F(x)$ 的坐标 $x$，该算法的步骤如下：\n1. $v(t + \\frac{\\Delta t}{2}) = v(t) + \\frac{1}{2} \\frac{F(x(t))}{M} \\Delta t$\n2. $x(t + \\Delta t) = x(t) + v(t + \\frac{\\Delta t}{2}) \\Delta t$\n3. $v(t + \\Delta t) = v(t + \\frac{\\Delta t}{2}) + \\frac{1}{2} \\frac{F(x(t+\\Delta t))}{M} \\Delta t$\n\n积分所需的力由各自的势能导出。\n对于 BOMD，作用在核坐标 $R$ 上的力为：\n$$\nF_R^{\\mathrm{BO}} = -\\frac{dE_{\\mathrm{BO}}}{dR} = -2aD \\left(1 - e^{-a(R - R_e)}\\right) e^{-a(R - R_e)}\n$$\n对于 CPMD，作用在耦合坐标 $(R, q)$ 上的力为：\n$$\nF_R^{\\mathrm{CP}} = -\\frac{\\partial E_{\\mathrm{CP}}}{\\partial R} = -\\frac{dE_{\\mathrm{BO}}}{dR} + k_e c(q - cR) = F_R^{\\mathrm{BO}} + k_e c(q - cR)\n$$\n$$\nF_q^{\\mathrm{CP}} = -\\frac{\\partial E_{\\mathrm{CP}}}{\\partial q} = -k_e(q - cR)\n$$\n这定义了一个二维系统 $(R, q)$，由力 $(F_R^{\\mathrm{CP}}, F_q^{\\mathrm{CP}})$ 驱动，并具有相应的质量 $(M_R, M_q)$。\n\n初始条件为：$R(0) = 5.5 + 0.1 = 5.6\\,a_0$，$\\dot{R}(0) = 0$，$q(0) = c R(0) = 0.05 \\times 5.6 = 0.28$，以及 $\\dot{q}(0) = 0$。\n系统从一个偏离的核几何结构静止开始初始化，其中虚拟电子坐标满足基态条件 $q=cR$。\n\n每次模拟的守恒总能量在轨迹的开始 ($t=0$) 和结束 ($t=T$) 时计算。\n对于 BOMD，总能量为：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{BO}}(t) = \\frac{1}{2} M_R \\dot{R}(t)^2 + D \\left[\\left(1 - e^{-a(R(t) - R_e)}\\right)^2 - 1\\right]\n$$\n对于 CPMD，守恒的扩展或虚拟能量为：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{CP}}(t) = \\frac{1}{2} M_R \\dot{R}(t)^2 + \\frac{1}{2} M_q \\dot{q}(t)^2 + E_{\\mathrm{BO}}(R(t)) + \\frac{1}{2} k_e (q(t) - cR(t))^2\n$$\n绝对能量漂移 $\\Delta E = |E_{\\mathrm{tot}}(T) - E_{\\mathrm{tot}}(0)|$ 将为六次模拟（BOMD/CPMD 分别对应情况 A, B, C）中的每一次进行计算。最终结果从哈特里转换为 eV，并按指定精度报告。\n\n实现将包含两个主要函数，每种动力学类型各一个。每个函数将接受积分时间步长和其他相关参数，执行速度 Verlet 积分循环直至指定的总持续时间，并返回能量漂移。主程序将为每个测试用例调用这些函数，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    # --- Constants and Unit Conversions ---\n    EV_PER_HA = 27.211386245988\n    AMU_PER_ME = 1822.888486209\n    AU_TIME_PER_S = 2.4188843265857e-17\n    FS_PER_S = 1e-15\n    FS_TO_AU_TIME = FS_PER_S / AU_TIME_PER_S\n\n    # --- System Parameters in Atomic Units ---\n    D_ev = 0.22\n    D_ha = D_ev / EV_PER_HA\n    A_au = 3.0\n    RE_au = 5.5\n    \n    M_O_u = 15.999\n    M_R_me = 0.5 * M_O_u * AMU_PER_ME\n    \n    K_E_ha = 0.5\n    C_dimless = 0.05\n\n    # --- Simulation Time ---\n    T_ps = 1.0\n    T_fs = T_ps * 1000.0\n    T_au = T_fs * FS_TO_AU_TIME\n\n    # --- Initial Conditions in Atomic Units ---\n    R0 = RE_au + 0.1\n    R_DOT0 = 0.0\n    Q0 = C_dimless * R0\n    Q_DOT0 = 0.0\n\n    # --- Energy and Force Functions ---\n    def e_bo(r):\n        term = 1.0 - np.exp(-A_au * (r - RE_au))\n        return D_ha * (term**2 - 1.0)\n\n    def f_bo(r):\n        exp_term = np.exp(-A_au * (r - RE_au))\n        return -2.0 * A_au * D_ha * (1.0 - exp_term) * exp_term\n\n    def e_cp(r, q):\n        return e_bo(r) + 0.5 * K_E_ha * (q - C_dimless * r)**2\n    \n    def f_cp_r(r, q):\n        return f_bo(r) + K_E_ha * C_dimless * (q - C_dimless * r)\n        \n    def f_cp_q(r, q):\n        return -K_E_ha * (q - C_dimless * r)\n\n    # --- Simulation Functions ---\n    def run_bomd(dt_fs):\n        dt_au = dt_fs * FS_TO_AU_TIME\n        num_steps = int(round(T_au / dt_au))\n\n        r = R0\n        r_dot = R_DOT0\n\n        e_initial = 0.5 * M_R_me * r_dot**2 + e_bo(r)\n        \n        accel = f_bo(r) / M_R_me\n        for _ in range(num_steps):\n            r_dot += 0.5 * accel * dt_au\n            r += r_dot * dt_au\n            accel = f_bo(r) / M_R_me\n            r_dot += 0.5 * accel * dt_au\n        \n        e_final = 0.5 * M_R_me * r_dot**2 + e_bo(r)\n        \n        delta_e_ha = np.abs(e_final - e_initial)\n        return delta_e_ha * EV_PER_HA\n\n    def run_cpmd(dt_fs, M_q_me):\n        dt_au = dt_fs * FS_TO_AU_TIME\n        num_steps = int(round(T_au / dt_au))\n\n        r, r_dot = R0, R_DOT0\n        q, q_dot = Q0, Q_DOT0\n\n        e_initial = 0.5 * M_R_me * r_dot**2 + 0.5 * M_q_me * q_dot**2 + e_cp(r, q)\n\n        accel_r = f_cp_r(r, q) / M_R_me\n        accel_q = f_cp_q(r, q) / M_q_me\n        for _ in range(num_steps):\n            # Update velocities (half step)\n            r_dot += 0.5 * accel_r * dt_au\n            q_dot += 0.5 * accel_q * dt_au\n            \n            # Update positions\n            r += r_dot * dt_au\n            q += q_dot * dt_au\n            \n            # Update accelerations\n            accel_r = f_cp_r(r, q) / M_R_me\n            accel_q = f_cp_q(r, q) / M_q_me\n            \n            # Update velocities (full step)\n            r_dot += 0.5 * accel_r * dt_au\n            q_dot += 0.5 * accel_q * dt_au\n\n        e_final = 0.5 * M_R_me * r_dot**2 + 0.5 * M_q_me * q_dot**2 + e_cp(r, q)\n        \n        delta_e_ha = np.abs(e_final - e_initial)\n        return delta_e_ha * EV_PER_HA\n\n    # --- Test Cases ---\n    test_cases = [\n        # (dt_fs, M_q_me)\n        (0.25, 400.0),  # Case A\n        (0.50, 400.0),  # Case B\n        (0.50, 1600.0), # Case C\n    ]\n\n    results = []\n    \n    # Case A\n    dt_A, Mq_A = test_cases[0]\n    results.append(run_bomd(dt_A))\n    results.append(run_cpmd(dt_A, Mq_A))\n\n    # Case B\n    dt_B, Mq_B = test_cases[1]\n    # BOMD results for dt=0.50fs are identical for Cases B  C\n    bomd_b_drift = run_bomd(dt_B)\n    results.append(bomd_b_drift)\n    results.append(run_cpmd(dt_B, Mq_B))\n    \n    # Case C\n    dt_C, Mq_C = test_cases[2]\n    # Re-use BOMD result\n    results.append(bomd_b_drift) # dt is the same as in B\n    results.append(run_cpmd(dt_C, Mq_C))\n\n    # --- Format and Print Output ---\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何可靠的从头算模拟都始于细致的收敛性测试，以确保计算结果的准确性。本练习将这一关键实践过程形式化为一个量化的优化问题，旨在教会您如何在计算成本和模拟精度之间做出原则性的权衡。您将学习如何根据给定的误差模型，系统地选择平面波截断能 ($E_{\\text{cut}}$) 和 $k$ 点网格，以满足力与应力张量的收敛标准。",
            "id": "3728689",
            "problem": "需要您形式化并解决一个应用于液态高熵合金（HEA）的第一性原理分子动力学（AIMD）的收敛性研究设计。目标是确定最小的平面波动能截断和每个方向上最小的均匀$k$点网格，以将一组代表性原子快照中的力和应力误差限制在指定公差内。从离散化误差和计算成本的定义开始，制定一个在误差约束下最小化成本的选择规则，然后实现该选择规则。\n\n定义与假设：\n- 第一性原理分子动力学（AIMD）使用电子结构计算来计算原子间力和应力，这些计算采用具有动能截断的平面波基组和倒易空间中的$k$点采样。基组和采样的离散化会引入力和应力误差。\n- 假设有$N$个代表性快照，索引为$s \\in \\{1,\\dots,N\\}$。对于给定的平面波动能截断$E_{\\text{cut}}$（单位为eV）和每个方向上均匀的Monkhorst-Pack $k$点网格大小$K$（无量纲整数），快照$s$处的力误差模型为\n$$\n\\mathcal{E}_f^{(s)}(E_{\\text{cut}},K) = A_s \\, E_{\\text{cut}}^{-p} + B_s \\, K^{-q}\n$$\n快照$s$处的应力误差模型为\n$$\n\\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K) = C_s \\, E_{\\text{cut}}^{-p_\\sigma} + D_s \\, K^{-q_\\sigma}.\n$$\n此处，$A_s$、$B_s$、$C_s$和$D_s$是编码快照相关敏感性的非负系数，$p$、$q$、$p_\\sigma$、$q_\\sigma$是描述误差随$E_{\\text{cut}}$和$K$增加而衰减的正指数。\n- 跨快照的最大误差为\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_f^{(s)}(E_{\\text{cut}},K), \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\mathcal{E}_\\sigma^{(s)}(E_{\\text{cut}},K).\n$$\n- 目标公差是力误差界限$T_f$和应力误差界限$T_\\sigma$。收敛性可行性约束为\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f, \\quad \\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma.\n$$\n- 计算成本模型为\n$$\n\\mathcal{C}(E_{\\text{cut}},K) = \\alpha \\, E_{\\text{cut}}^{3/2} + \\beta \\, K^3,\n$$\n其中$\\alpha$和$\\beta$是正权重，分别反映了平面波数量随$E_{\\text{cut}}$的变化以及每个方向上采样点数量随$K$的变化。\n- 在候选值$E_{\\text{cut}} \\in \\mathcal{E}$和$K \\in \\mathcal{K}$中，选择满足可行性约束且最小化$\\mathcal{C}(E_{\\text{cut}},K)$的对$(E_{\\text{cut}}^\\star,K^\\star)$。如果多个对具有相同的最小成本，则选择$E_{\\text{cut}}$较小的那个；如果仍然相同，则选择$K$较小的那个。如果不存在可行的对，则返回一个表示不可行的哨兵输出。\n\n科学单位和输出规范：\n- $E_{\\text{cut}}$以eV表示，$K$为每个方向上的整数。力误差界限$T_f$的单位是meV/Å，应力误差界限$T_\\sigma$的单位是GPa。此问题中不涉及角度量。\n- 您的程序必须计算以下每个测试用例的选择，并生成一行输出，其中包含一个逗号分隔的各测试用例结果列表，每个结果格式化为一个双元素列表$[E_{\\text{cut}},K]$，$E_{\\text{cut}}$表示为十进制（浮点数），$K$表示为整数，所有内容都用方括号括起来。例如，输出行必须类似于$[[400.0,2],[300.0,1],[0.0,0]]$。\n\n测试套件：\n- 测试用例1（正常路径）：\n  - $N = 3$个快照，系数：\n    - 力：$A = [1600,1400,1500]$（单位 meV/Å$\\cdot$eV$^p$），$B = [4.0,6.0,5.0]$（单位 meV/Å），指数 $p = 1.0$，$q = 2.0$。\n    - 应力：$C = [20.0,16.0,18.0]$（单位 GPa$\\cdot$eV$^{p_\\sigma}$），$D = [0.05,0.07,0.06]$（单位 GPa），指数 $p_\\sigma = 0.8$，$q_\\sigma = 1.5$。\n  - 公差：$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV，$\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$，$\\beta = 0.08$。\n- 测试用例2（边界和可能平局情况）：\n  - $N = 2$个快照，系数：\n    - 力：$A = [1200,1200]$，$B = [0.5,0.5]$，指数 $p = 1.0$，$q = 1.0$。\n    - 应力：$C = [10.0,8.0]$，$D = [0.02,0.02]$，指数 $p_\\sigma = 1.0$，$q_\\sigma = 1.0$。\n  - 公差：$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV，$\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$，$\\beta = 0.08$。\n- 测试用例3（边缘情况不可行）：\n  - $N = 2$个快照，系数：\n    - 力：$A = [8000,9000]$，$B = [10.0,10.0]$，指数 $p = 1.0$，$q = 2.0$。\n    - 应力：$C = [100.0,120.0]$，$D = [0.10,0.10]$，指数 $p_\\sigma = 1.0$，$q_\\sigma = 1.0$。\n  - 公差：$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa。\n  - 候选值：$\\mathcal{E} = [300,350,400,450,500,600]$ eV，$\\mathcal{K} = [1,2,3,4,5,6]$。\n  - 成本权重：$\\alpha = 1.0$，$\\beta = 0.08$。\n- 哨兵输出规则：如果不存在可行的对，则该测试用例输出$[0.0,0]$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身是一个双元素列表$[E_{\\text{cut}},K]$，如示例$[[400.0,2],[300.0,1],[0.0,0]]$所示。",
            "solution": "目标是设计并实现一种基于原则的选择方法，用于确定平面波动能截断和每个方向的$k$点网格，使其共同满足代表性快照中力和应力的误差公差，同时最小化计算成本模型。其科学基础是平面波电子结构计算和布里渊区采样中离散化误差的行为。在平面波基组中，基函数的数量与动能球面内倒易空间的体积成正比，即与$E_{\\text{cut}}^{3/2}$成正比；在均匀$k$点采样中，对于大小为$K \\times K \\times K$的立方网格，采样点的数量随$K^3$增长。这些标度关系构成了成本模型$\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$的基础。离散化误差通常随$E_{\\text{cut}}$和$K$单调递减，所提供的参数化误差模型捕捉了这种衰减趋势：$\\mathcal{E}_f^{(s)} = A_s E_{\\text{cut}}^{-p} + B_s K^{-q}$和$\\mathcal{E}_\\sigma^{(s)} = C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma}$，其中指数为正。\n\n基于原则的算法设计：\n- 从跨快照的最大误差定义开始，\n$$\n\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( A_s E_{\\text{cut}}^{-p} + B_s K^{-q} \\right), \\quad\n\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) = \\max_{s} \\left( C_s E_{\\text{cut}}^{-p_\\sigma} + D_s K^{-q_\\sigma} \\right).\n$$\n- $(E_{\\text{cut}},K)$的可行域是同时满足$\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$和$\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$的集合。\n- 在离散候选值$E_{\\text{cut}} \\in \\mathcal{E}$和$K \\in \\mathcal{K}$中，选择最小化$\\mathcal{C}(E_{\\text{cut}},K) = \\alpha E_{\\text{cut}}^{3/2} + \\beta K^3$的可行对。如果出现平局，则优先选择较小的$E_{\\text{cut}}$，然后是较小的$K$。\n\n算法步骤：\n- 对于每个$E_{\\text{cut}} \\in \\mathcal{E}$和每个$K \\in \\mathcal{K}$：\n  - 根据快照系数和指数计算$\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K)$和$\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K)$。\n  - 检查可行性：$\\mathcal{E}_f^{\\max}(E_{\\text{cut}},K) \\le T_f$和$\\mathcal{E}_\\sigma^{\\max}(E_{\\text{cut}},K) \\le T_\\sigma$。\n  - 如果可行，则评估$\\mathcal{C}(E_{\\text{cut}},K)$并根据指定的平局决胜规则追踪最小成本的解决方案。\n- 如果不存在可行的对，则返回哨兵值$[0.0,0]$。\n\n在测试套件上进行验证：\n- 测试用例1：\n  - 参数：$A = [1600,1400,1500]$，$B = [4.0,6.0,5.0]$，$p = 1.0$，$q = 2.0$；$C = [20.0,16.0,18.0]$，$D = [0.05,0.07,0.06]$，$p_\\sigma = 0.8$，$q_\\sigma = 1.5$；$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa；$\\mathcal{E} = [300,350,400,450,500,600]$ eV；$\\mathcal{K} = [1,2,3,4,5,6]$；$\\alpha = 1.0$，$\\beta = 0.08$。\n  - 考虑$E_{\\text{cut}} = 400$ eV，$K = 2$。每个快照的力误差：\n    - 快照1：$\\mathcal{E}_f^{(1)} = 1600 \\cdot 400^{-1.0} + 4.0 \\cdot 2^{-2.0} = 4.0 + 1.0 = 5.0$ meV/Å。\n    - 快照2：$\\mathcal{E}_f^{(2)} = 1400 \\cdot 400^{-1.0} + 6.0 \\cdot 2^{-2.0} = 3.5 + 1.5 = 5.0$ meV/Å。\n    - 快照3：$\\mathcal{E}_f^{(3)} = 1500 \\cdot 400^{-1.0} + 5.0 \\cdot 2^{-2.0} = 3.75 + 1.25 = 5.0$ meV/Å。\n    - 因此$\\mathcal{E}_f^{\\max}(400,2) = 5.0$ meV/Å，满足$T_f = 5.0$ meV/Å。\n  - 每个快照的应力误差：\n    - 计算$400^{-0.8}$。使用$400^{-0.8} \\approx \\exp(-0.8 \\ln 400) \\approx \\exp(-0.8 \\cdot 5.991) \\approx \\exp(-4.793) \\approx 0.0083$。\n    - $2^{-1.5} = 1 / 2^{1.5} = 1 / (2 \\sqrt{2}) \\approx 1 / 2.828 \\approx 0.3536$。\n    - 快照1：$\\mathcal{E}_\\sigma^{(1)} = 20.0 \\cdot 0.0083 + 0.05 \\cdot 0.3536 \\approx 0.166 + 0.0177 \\approx 0.1837$ GPa。\n    - 快照2：$\\mathcal{E}_\\sigma^{(2)} = 16.0 \\cdot 0.0083 + 0.07 \\cdot 0.3536 \\approx 0.133 + 0.0248 \\approx 0.1578$ GPa。\n    - 快照3：$\\mathcal{E}_\\sigma^{(3)} = 18.0 \\cdot 0.0083 + 0.06 \\cdot 0.3536 \\approx 0.149 + 0.0212 \\approx 0.1702$ GPa。\n    - 因此$\\mathcal{E}_\\sigma^{\\max}(400,2) \\approx 0.1837$ GPa，满足$T_\\sigma = 0.2$ GPa。\n  - 检查是否有任何成本更低的对可以同时满足两个界限。对于$E_{\\text{cut}} = 350$ eV，快照1的力$A \\cdot 350^{-1.0}$至少为$4.571$ meV/Å，并且当$K \\ge 2$时，增加的$B_s K^{-2}$项会增大误差，因此最大力超过$5.0$ meV/Å。对于$K = 1$，$B_s K^{-2}$项更大，同样不可行。因此，在候选集合中，根据$E_{\\text{cut}}$和$K$来看，$(400,2)$是最小的可行对。其成本为$\\mathcal{C}(400,2) = 1.0 \\cdot 400^{3/2} + 0.08 \\cdot 2^3 = 8000.0 + 0.64 = 8000.64$，且没有更低的$E_{\\text{cut}}$或$K$选择是可行的，这使得$(400,2)$成为选定的对。\n- 测试用例2：\n  - 参数：$A = [1200,1200]$，$B = [0.5,0.5]$，$p = 1.0$，$q = 1.0$；$C = [10.0,8.0]$，$D = [0.02,0.02]$，$p_\\sigma = 1.0$，$q_\\sigma = 1.0$；$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa；与测试用例1相同的候选值和成本权重。\n  - 评估$(E_{\\text{cut}},K) = (300,1)$：\n    - 力：对于两个快照，$\\mathcal{E}_f^{(s)} = 1200 \\cdot 300^{-1.0} + 0.5 \\cdot 1^{-1.0} = 4.0 + 0.5 = 4.5$ meV/Å，因此$\\mathcal{E}_f^{\\max}(300,1) = 4.5 \\le 5.0$ meV/Å。\n    - 应力：快照1，$\\mathcal{E}_\\sigma^{(1)} = 10.0 \\cdot 300^{-1.0} + 0.02 \\cdot 1^{-1.0} = 0.033\\overline{3} + 0.02 \\approx 0.053\\overline{3}$ GPa；快照2，$\\mathcal{E}_\\sigma^{(2)} = 8.0 \\cdot 300^{-1.0} + 0.02 = 0.026\\overline{6} + 0.02 \\approx 0.046\\overline{6}$ GPa；因此$\\mathcal{E}_\\sigma^{\\max}(300,1) \\approx 0.053\\overline{3} \\le 0.2$ GPa。\n  - 这对组合是可行的，其成本为$\\mathcal{C}(300,1) = 1.0 \\cdot 300^{3/2} + 0.08 \\cdot 1^3 = 300 \\cdot \\sqrt{300} + 0.08 \\approx 300 \\cdot 17.3205 + 0.08 \\approx 5196.15 + 0.08 \\approx 5196.23$。由于它使用了已经满足公差的最小$E_{\\text{cut}}$和$K$，并且成本随任一参数单调增加，因此该成本在可行对中是最小的。因此，选择$(300,1)$。\n- 测试用例3：\n  - 参数：$A = [8000,9000]$，$B = [10.0,10.0]$，$p = 1.0$，$q = 2.0$；$C = [100.0,120.0]$，$D = [0.10,0.10]$，$p_\\sigma = 1.0$，$q_\\sigma = 1.0$；$T_f = 5.0$ meV/Å，$T_\\sigma = 0.2$ GPa；相同的候选值和成本权重。\n  - 评估对力最有利的候选对$(E_{\\text{cut}},K) = (600,6)$：\n    - 快照2：$\\mathcal{E}_f^{(2)} = 9000 \\cdot 600^{-1.0} + 10.0 \\cdot 6^{-2.0} = 15.0 + 10.0/36 \\approx 15.0 + 0.277\\overline{7} \\approx 15.277\\overline{7}$ meV/Å，这远超$T_f = 5.0$ meV/Å。因此，没有候选对能够满足力界限，可行性失败。\n  - 根据哨兵规则，此测试用例的输出为$[0.0,0]$。\n\n因此，算法返回每个测试用例的选择$[400.0,2]$、$[300.0,1]$和$[0.0,0]$。该实现直接在候选集上评估定义的函数，应用可行性约束，在平局决胜规则下最小化成本，并按规定格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef select_minimal_cutoff_and_kgrid(A, B, C, D, p, q, p_sigma, q_sigma,\n                                    T_f, T_sigma, E_candidates, K_candidates,\n                                    alpha, beta):\n    \"\"\"\n    Given error model parameters and candidate sets, select the minimal-cost\n    (E_cut, K) satisfying the force and stress tolerances across snapshots.\n    Tie-break by smaller E_cut, then smaller K. If none feasible, return [0.0, 0].\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    A = np.array(A, dtype=float)\n    B = np.array(B, dtype=float)\n    C = np.array(C, dtype=float)\n    D = np.array(D, dtype=float)\n    E_candidates = np.array(E_candidates, dtype=float)\n    K_candidates = np.array(K_candidates, dtype=int)\n\n    best_pair = None\n    best_cost = np.inf\n\n    for E in E_candidates:\n        # Precompute E-dependent factors\n        E_pow_f = E ** (-p)\n        E_pow_sigma = E ** (-p_sigma)\n        for K in K_candidates:\n            # Compute K-dependent factors\n            K_pow_f = K ** (-q)\n            K_pow_sigma = K ** (-q_sigma)\n\n            # Force and stress errors per snapshot\n            force_errors = A * E_pow_f + B * K_pow_f\n            stress_errors = C * E_pow_sigma + D * K_pow_sigma\n\n            max_force_error = np.max(force_errors)\n            max_stress_error = np.max(stress_errors)\n\n            # Check tolerances\n            if (max_force_error = T_f) and (max_stress_error = T_sigma):\n                # Compute cost\n                cost = alpha * (E ** 1.5) + beta * (K ** 3)\n                # Update best with tie-breaks: lower cost, then lower E, then lower K\n                if (cost  best_cost) or (\n                    np.isclose(cost, best_cost) and (\n                        (best_pair is None) or (E  best_pair[0]) or (\n                            (np.isclose(E, best_pair[0])) and (K  best_pair[1])\n                        )\n                    )\n                ):\n                    best_cost = cost\n                    best_pair = (float(E), int(K))\n\n    if best_pair is None:\n        return [0.0, 0]\n    else:\n        # Ensure E is printed as float\n        return [float(best_pair[0]), int(best_pair[1])]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": [1600, 1400, 1500],\n            \"B\": [4.0, 6.0, 5.0],\n            \"C\": [20.0, 16.0, 18.0],\n            \"D\": [0.05, 0.07, 0.06],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 0.8,\n            \"q_sigma\": 1.5,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [1200, 1200],\n            \"B\": [0.5, 0.5],\n            \"C\": [10.0, 8.0],\n            \"D\": [0.02, 0.02],\n            \"p\": 1.0,\n            \"q\": 1.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        },\n        {\n            \"A\": [8000, 9000],\n            \"B\": [10.0, 10.0],\n            \"C\": [100.0, 120.0],\n            \"D\": [0.10, 0.10],\n            \"p\": 1.0,\n            \"q\": 2.0,\n            \"p_sigma\": 1.0,\n            \"q_sigma\": 1.0,\n            \"T_f\": 5.0,       # meV/Å\n            \"T_sigma\": 0.2,   # GPa\n            \"E_candidates\": [300, 350, 400, 450, 500, 600],  # eV\n            \"K_candidates\": [1, 2, 3, 4, 5, 6],              # per-direction\n            \"alpha\": 1.0,\n            \"beta\": 0.08\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = select_minimal_cutoff_and_kgrid(\n            A=case[\"A\"], B=case[\"B\"], C=case[\"C\"], D=case[\"D\"],\n            p=case[\"p\"], q=case[\"q\"], p_sigma=case[\"p_sigma\"], q_sigma=case[\"q_sigma\"],\n            T_f=case[\"T_f\"], T_sigma=case[\"T_sigma\"],\n            E_candidates=case[\"E_candidates\"], K_candidates=case[\"K_candidates\"],\n            alpha=case[\"alpha\"], beta=case[\"beta\"]\n        )\n        results.append(result)\n\n    # Format results as specified: single line, comma-separated, list of [E_cut,K] with no spaces.\n    formatted = \"[\" + \",\".join(f\"[{res[0]:.1f},{res[1]}]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "在微正则系综 (NVE) 模拟中，总能量的守恒性是衡量模拟稳定性和准确性的黄金标准。然而，时间积分算法的离散化误差和自洽场计算的不完全收敛都会导致能量漂移。本练习将指导您如何量化这些误差来源，建立一个预测能量漂移率的实用模型 ($r(\\Delta t, \\tau) = \\alpha(\\Delta t)^2 + \\beta\\tau + \\gamma$)，并利用该模型制定出能够将能量漂移控制在可接受范围内的稳健模拟方案。",
            "id": "3728716",
            "problem": "考虑一个由$128$个原子组成的高熵合金，在微正则系综（粒子数、体积和能量恒定；NVE）中进行的Born-Oppenheimer分子动力学（BOMD）模拟。在理想的连续时间演化中，当自洽场（SCF）精确收敛且力精确时，系统的总能量应守恒。在实践中，两个系统性数值误差源导致了能量漂移：积分器的有限时间步长 $\\Delta t$ 和电子结构求解器的有限SCF收敛容差 $\\tau$。对于足够小的 $\\Delta t$ 和严格的SCF容差，每个原子的能量漂移率可以由一个对主要小误差贡献呈线性的模型来近似。假设使用速度Verlet积分器（对于行为良好的力，其局域截断误差为$\\mathcal{O}((\\Delta t)^3)$阶，全局能量误差标度为$\\mathcal{O}((\\Delta t)^2)$），并且残余力误差与SCF能量容差近似呈线性关系，我们采用以下线性化漂移率模型：\n$$\nr(\\Delta t,\\tau) = \\alpha\\,(\\Delta t)^2 + \\beta\\,\\tau + \\gamma,\n$$\n其中，$r$ 是以 meV/原子/ns 为单位的能量漂移率，$\\Delta t$ 是以 fs（飞秒）为单位的时间步长，$\\tau$ 是以 eV（电子伏特）为单位的SCF能量容差，而 $\\alpha$、$\\beta$、$\\gamma$ 是待定参数。\n\n我们为您提供了从对包含$128$个原子的高熵合金进行的简短NVE BOMD模拟中获得的一组$(\\Delta t,\\tau)$对的能量漂移率 $r$ 的校准测量值。所有列出的 $r$ 值都是以 meV/原子/ns 为单位的每个原子的值。请使用这些校准数据，通过最小二乘法拟合线性模型参数 $\\alpha$、$\\beta$ 和 $\\gamma$：\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.1625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3625$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.6125$\n- $(\\Delta t=0.5\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.6125$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.3500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=0.5500$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=0.8000$\n- $(\\Delta t=1.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=2.8000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.1000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-5}\\,\\text{eV}) \\rightarrow r=1.3000$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=1\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=1.5500$\n- $(\\Delta t=2.0\\,\\text{fs}, \\tau=5\\times 10^{-4}\\,\\text{eV}) \\rightarrow r=3.5500$\n\n在拟合 $\\alpha$、$\\beta$ 和 $\\gamma$ 之后，通过计算 $r(\\Delta t,\\tau)$ 来量化指定测试 $(\\Delta t,\\tau)$ 对的能量漂移。此外，推导出一个关于最大允许时间步长 $\\Delta t_{\\max}$ 作为SCF容差 $\\tau$ 的函数的建议，以确保漂移率保持在目标阈值 $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$ 以下。使用拟合后的模型，该建议必须满足：\n$$\n\\Delta t_{\\max}(\\tau) = \n\\begin{cases}\n\\sqrt{\\dfrac{r_{\\text{thr}} - \\beta\\,\\tau - \\gamma}{\\alpha}},  \\text{如果 } r_{\\text{thr}} - \\beta\\,\\tau - \\gamma > 0,\\\\[8pt]\n0,  \\text{否则,}\n\\end{cases}\n$$\n其中 $\\Delta t_{\\max}$ 以 fs 表示。\n\n您的程序必须执行以下步骤：\n1. 使用上面的校准数据集拟合参数 $\\alpha$、$\\beta$ 和 $\\gamma$。\n2. 计算以下测试对的预测漂移率 $r(\\Delta t,\\tau)$：\n   - $\\Delta t=1.0\\,\\text{fs}$，$\\tau=1\\times 10^{-5}\\,\\text{eV}$，\n   - $\\Delta t=2.0\\,\\text{fs}$，$\\tau=1\\times 10^{-5}\\,\\text{eV}$，\n   - $\\Delta t=1.5\\,\\text{fs}$，$\\tau=1\\times 10^{-4}\\,\\text{eV}$。\n   以 meV/原子/ns 为单位报告每个 $r$。\n3. 计算以下SCF容差下，为使漂移低于 $r_{\\text{thr}}=1\\,\\text{meV/atom/ns}$ 的推荐最大时间步长 $\\Delta t_{\\max}$：\n   - $\\tau=1\\times 10^{-5}\\,\\text{eV}$，\n   - $\\tau=5\\times 10^{-5}\\,\\text{eV}$，\n   - $\\tau=1\\times 10^{-4}\\,\\text{eV}$，\n   - $\\tau=5\\times 10^{-4}\\,\\text{eV}$。\n   以 fs 为单位报告每个 $\\Delta t_{\\max}$。\n\n所有数值答案必须是浮点数，并四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按以下顺序排列：三个预测的漂移率，后跟四个推荐的最大时间步长，即 $[r_{1},r_{2},r_{3},\\Delta t_{\\max,1},\\Delta t_{\\max,2},\\Delta t_{\\max,3},\\Delta t_{\\max,4}]$。",
            "solution": "该问题要求我们确定Born-Oppenheimer分子动力学（BOMD）模拟中能量漂移线性模型的参数，然后使用该模型进行预测并建立操作约束。分析过程分为两个主要阶段：首先，使用线性最小二乘法拟合模型参数；其次，应用拟合后的模型来回答提出的具体问题。\n\n提出的每个原子的能量漂移率 $r$ 的模型由下式给出：\n$$\nr(\\Delta t, \\tau) = \\alpha (\\Delta t)^2 + \\beta \\tau + \\gamma\n$$\n其中，$\\Delta t$ 是以飞秒（fs）为单位的积分时间步长，$\\tau$ 是以电子伏特（eV）为单位的自洽场（SCF）能量收敛容差，$r$ 是以 meV/原子/ns 为单位的漂移率。待定参数为 $\\alpha$、$\\beta$ 和 $\\gamma$。该模型相对于这些参数是线性的。$(\\Delta t)^2$ 项的物理动机是速度Verlet积分器的全局能量误差标度，而对 $\\tau$ 的线性依赖是对不完全SCF收敛对原子力的影响的一个合理的一阶近似。\n\n我们得到了12个形式为 $((\\Delta t)_i, \\tau_i, r_i)$（$i=1, \\dots, 12$）的校准数据点。为了找到最佳拟合参数 $\\alpha$、$\\beta$ 和 $\\gamma$，我们采用线性最小二乘法。该方法旨在最小化观测漂移率 $r_i$ 与模型预测速率之间的平方差之和。\n\n让我们为每个数据点定义一个参数向量 $\\mathbf{p}$ 和一个特征向量 $\\mathbf{x}_i$：\n$$\n\\mathbf{p} = \\begin{pmatrix} \\alpha \\\\ \\beta \\\\ \\gamma \\end{pmatrix}, \\quad \\mathbf{x}_i = \\begin{pmatrix} (\\Delta t_i)^2 \\\\ \\tau_i \\\\ 1 \\end{pmatrix}\n$$\n然后，模型可以表示为 $r_i \\approx \\mathbf{x}_i^T \\mathbf{p}$。我们可以将所有12个方程组合成一个单一的矩阵方程：\n$$\n\\mathbf{A} \\mathbf{p} = \\mathbf{b}\n$$\n其中 $\\mathbf{A}$ 是一个 $12 \\times 3$ 的设计矩阵，其行是特征向量 $\\mathbf{x}_i^T$，$\\mathbf{b}$ 是一个 $12 \\times 1$ 的观测漂移率 $r_i$ 向量。\n\n$$\n\\mathbf{A} = \\begin{pmatrix}\n(\\Delta t_1)^2  \\tau_1  1 \\\\\n(\\Delta t_2)^2  \\tau_2  1 \\\\\n\\vdots  \\vdots  \\vdots \\\\\n(\\Delta t_{12})^2  \\tau_{12}  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n(0.5)^2  1 \\times 10^{-5}  1 \\\\\n(0.5)^2  5 \\times 10^{-5}  1 \\\\\n(0.5)^2  1 \\times 10^{-4}  1 \\\\\n(0.5)^2  5 \\times 10^{-4}  1 \\\\\n(1.0)^2  1 \\times 10^{-5}  1 \\\\\n(1.0)^2  5 \\times 10^{-5}  1 \\\\\n(1.0)^2  1 \\times 10^{-4}  1 \\\\\n(1.0)^2  5 \\times 10^{-4}  1 \\\\\n(2.0)^2  1 \\times 10^{-5}  1 \\\\\n(2.0)^2  5 \\times 10^{-5}  1 \\\\\n(2.0)^2  1 \\times 10^{-4}  1 \\\\\n(2.0)^2  5 \\times 10^{-4}  1\n\\end{pmatrix},\n\\quad\n\\mathbf{b} = \\begin{pmatrix}\n0.1625 \\\\ 0.3625 \\\\ 0.6125 \\\\ 2.6125 \\\\\n0.3500 \\\\ 0.5500 \\\\ 0.8000 \\\\ 2.8000 \\\\\n1.1000 \\\\ 1.3000 \\\\ 1.5500 \\\\ 3.5500\n\\end{pmatrix}\n$$\n\n最小二乘解 $\\mathbf{p}$ 最小化了残差向量的欧几里得范数 $||\\mathbf{A} \\mathbf{p} - \\mathbf{b}||_2$。该解通过求解正规方程得到：\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{p} = \\mathbf{A}^T \\mathbf{b}\n$$\n求解这个关于 $\\mathbf{p}$ 的线性方程组，可以得到 $\\alpha$、$\\beta$ 和 $\\gamma$ 的值。使用给定数据进行此计算，结果如下：\n$$\n\\alpha = 0.25 \\, \\frac{\\text{meV/原子/ns}}{\\text{fs}^2}\n$$\n$$\n\\beta = 5000 \\, \\frac{\\text{meV/原子/ns}}{\\text{eV}}\n$$\n$$\n\\gamma = 0.05 \\, \\text{meV/原子/ns}\n$$\n所提供的数据可以被这些参数完美描述，表明校准集中没有随机噪声。因此，拟合后的模型为：\n$$\nr(\\Delta t, \\tau) = 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n\n在模型参数化之后，我们可以进行所需的计算。\n\n**1. 预测漂移率**\n\n我们为三个测试对 $(\\Delta t, \\tau)$ 计算漂移率 $r$：\n- 对于 $(\\Delta t=1.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$：\n$$\nr_1 = 0.25 (1.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25 + 0.05 + 0.05 = 0.35 \\, \\text{meV/原子/ns}\n$$\n- 对于 $(\\Delta t=2.0\\,\\text{fs}, \\tau=1 \\times 10^{-5}\\,\\text{eV})$：\n$$\nr_2 = 0.25 (2.0)^2 + 5000 (1 \\times 10^{-5}) + 0.05 = 0.25(4) + 0.05 + 0.05 = 1.0 + 0.05 + 0.05 = 1.10 \\, \\text{meV/原子/ns}\n$$\n- 对于 $(\\Delta t=1.5\\,\\text{fs}, \\tau=1 \\times 10^{-4}\\,\\text{eV})$：\n$$\nr_3 = 0.25 (1.5)^2 + 5000 (1 \\times 10^{-4}) + 0.05 = 0.25(2.25) + 0.5 + 0.05 = 0.5625 + 0.5 + 0.05 = 1.1125 \\, \\text{meV/原子/ns}\n$$\n\n**2. 推荐的最大时间步长**\n\n我们需要找到在给定容差 $\\tau$ 下的最大时间步长 $\\Delta t_{\\max}$，使得漂移率不超过阈值 $r_{\\text{thr}} = 1.0\\,\\text{meV/atom/ns}$。我们从模型出发，求解 $\\Delta t$：\n$$\nr_{\\text{thr}} \\ge 0.25 (\\Delta t)^2 + 5000 \\tau + 0.05\n$$\n$$\n(\\Delta t)^2 \\le \\frac{r_{\\text{thr}} - 5000 \\tau - 0.05}{0.25}\n$$\n为使 $\\Delta t$ 为实数，分子必须为非负数。这给出了 $\\Delta t_{\\max}$ 的表达式：\n$$\n\\Delta t_{\\max}(\\tau) = \\begin{cases}\n\\sqrt{\\dfrac{1.0 - 5000 \\tau - 0.05}{0.25}} = \\sqrt{4 (0.95 - 5000 \\tau)} = 2\\sqrt{0.95 - 5000 \\tau},  \\text{如果 } 0.95 - 5000 \\tau > 0 \\\\\n0,  \\text{否则}\n\\end{cases}\n$$\n条件 $0.95 - 5000 \\tau > 0$ 意味着 $\\tau  \\frac{0.95}{5000} = 1.9 \\times 10^{-4}$ eV。\n\n我们现在为四个给定的 $\\tau$ 值计算 $\\Delta t_{\\max}$：\n\n- 对于 $\\tau = 1 \\times 10^{-5}\\,\\text{eV}$：条件满足。\n$$\n\\Delta t_{\\max,1} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.05} = 2\\sqrt{0.90} \\approx 1.897367 \\, \\text{fs}\n$$\n- 对于 $\\tau = 5 \\times 10^{-5}\\,\\text{eV}$：条件满足。\n$$\n\\Delta t_{\\max,2} = 2\\sqrt{0.95 - 5000(5 \\times 10^{-5})} = 2\\sqrt{0.95 - 0.25} = 2\\sqrt{0.70} \\approx 1.673320 \\, \\text{fs}\n$$\n- 对于 $\\tau = 1 \\times 10^{-4}\\,\\text{eV}$：条件满足。\n$$\n\\Delta t_{\\max,3} = 2\\sqrt{0.95 - 5000(1 \\times 10^{-4})} = 2\\sqrt{0.95 - 0.50} = 2\\sqrt{0.45} \\approx 1.341641 \\, \\text{fs}\n$$\n- 对于 $\\tau = 5 \\times 10^{-4}\\,\\text{eV}$：$5000 \\tau = 2.5$，大于 $0.95$。分子为负。\n$$\n\\Delta t_{\\max,4} = 0 \\, \\text{fs}\n$$\n\n最终的结果集合，四舍五入到六位小数，是：$r_1=0.350000$, $r_2=1.100000$, $r_3=1.112500$, $\\Delta t_{\\max,1}=1.897367$, $\\Delta t_{\\max,2}=1.673320$, $\\Delta t_{\\max,3}=1.341641$ 和 $\\Delta t_{\\max,4}=0.000000$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of fitting an energy drift model for BOMD simulations\n    and using it for prediction and constraint derivation.\n    \"\"\"\n    \n    # --- Step 1: Fit the model parameters using least squares ---\n    \n    # Calibration data: (delta_t, tau, r)\n    # delta_t is in fs, tau in eV, r in meV/atom/ns.\n    calibration_data = [\n        (0.5, 1e-5, 0.1625),\n        (0.5, 5e-5, 0.3625),\n        (0.5, 1e-4, 0.6125),\n        (0.5, 5e-4, 2.6125),\n        (1.0, 1e-5, 0.3500),\n        (1.0, 5e-5, 0.5500),\n        (1.0, 1e-4, 0.8000),\n        (1.0, 5e-4, 2.8000),\n        (2.0, 1e-5, 1.1000),\n        (2.0, 5e-5, 1.3000),\n        (2.0, 1e-4, 1.5500),\n        (2.0, 5e-4, 3.5500),\n    ]\n\n    # The model is r = alpha * (delta_t)^2 + beta * tau + gamma\n    # This is a linear model in the parameters (alpha, beta, gamma).\n    # We set up the linear system A * p = b, where p = [alpha, beta, gamma].\n    \n    num_points = len(calibration_data)\n    A = np.zeros((num_points, 3))\n    b = np.zeros(num_points)\n    \n    for i, (dt, tau, r) in enumerate(calibration_data):\n        A[i, 0] = dt**2\n        A[i, 1] = tau\n        A[i, 2] = 1\n        b[i] = r\n        \n    # Solve the least squares problem A*p = b for p\n    params, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    alpha, beta, gamma = params\n\n    # --- Step 2: Compute predicted drift rates for test cases ---\n    \n    test_rates_inputs = [\n        (1.0, 1e-5),  # (delta_t, tau)\n        (2.0, 1e-5),\n        (1.5, 1e-4),\n    ]\n    \n    predicted_rates = []\n    for dt, tau in test_rates_inputs:\n        rate = alpha * dt**2 + beta * tau + gamma\n        predicted_rates.append(rate)\n\n    # --- Step 3: Compute recommended max time step ---\n\n    r_thr = 1.0  # meV/atom/ns\n    \n    test_dtmax_inputs = [\n        1e-5,  # tau in eV\n        5e-5,\n        1e-4,\n        5e-4,\n    ]\n    \n    recommended_dtmax = []\n    for tau in test_dtmax_inputs:\n        # dt_max = sqrt((r_thr - beta*tau - gamma) / alpha)\n        numerator = r_thr - beta * tau - gamma\n        if numerator > 0:\n            dt_max = np.sqrt(numerator / alpha)\n        else:\n            dt_max = 0.0\n        recommended_dtmax.append(dt_max)\n        \n    # Combine all results\n    all_results = predicted_rates + recommended_dtmax\n    \n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}