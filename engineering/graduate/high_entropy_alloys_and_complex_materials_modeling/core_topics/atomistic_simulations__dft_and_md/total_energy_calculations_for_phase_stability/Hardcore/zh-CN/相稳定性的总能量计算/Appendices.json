{
    "hands_on_practices": [
        {
            "introduction": "在评估相稳定性时，首要任务是为给定的晶体结构找到其能量最低的平衡态。本练习将指导您通过最小化总能量来确定平衡晶格常数，这是计算材料科学中的一项基本技能。此练习还引入了数值收敛性这一关键概念，并探讨了它如何影响预测的物理性质()。",
            "id": "3763351",
            "problem": "您正在零温下对一种面心立方高熵合金进行建模，使用总能计算通过平衡晶格参数来确定相稳定性。从热力学第一性原理出发，平衡态对应于在压力和体积模量的定义下，将每个原子的总能量作为单原子体积的函数进行最小化。您必须实现一个物理上一致的状态方程来表示静态晶格能与单原子体积的函数关系，然后量化计算出的平衡晶格参数对通过积分和基组近似进入总能量的数值收敛参数的敏感性。\n\n基本原理：\n- 平衡条件由总能量相对于体积的驻定性定义，即在固定成分和温度下，$dE/dV=0$。\n- 压力由 $P(V)=-dE/dV$ 定义。\n- 等温体积模量由 $B(V)=-V\\,dP/dV$ 定义，其中 $B_0=B(V_0)$ 是平衡体积 $V_0$ 处的模量。\n- 对于每个传统立方晶胞包含 $4$ 个原子的面心立方晶格，单原子体积为 $V=a^3/4$，其中 $a$ 是传统立方晶格参数。\n\n采用一个广泛使用的零温状态方程，该方程在热力学上与 $P(V)=-dE/dV$ 和 $B(V)=-V\\,dP/dV$ 一致。对于此任务，请使用三阶 Birch-Murnaghan 模型（不要假定问题陈述中任何预先指定的公式；您必须遵循上述基本原理自行推导和实现它）。\n\n建模要求：\n- 将每个原子的总能量处理为 $E_{\\text{tot}}(V; N, E_{\\mathrm{cut}}) = E_{\\mathrm{EOS}}(V) + \\Delta E(V; N, E_{\\mathrm{cut}})$，其中 $E_{\\mathrm{EOS}}(V)$ 是所选的状态方程能量（每个原子），而 $\\Delta E$ 是一个收敛误差代理，该代理依赖于 k 点线性密度参数 $N$（因此网格有 $N^3$ 个点）和平面波截断能 $E_{\\mathrm{cut}}$。\n- 假设以下具有物理动机的参数用于状态方程：$E_0=-6.0$（单位 $\\mathrm{eV}$/原子），$V_0=12.0$（单位 $\\mathrm{\\AA}^3$/原子），$B_0=180.0$（单位 $\\mathrm{GPa}$），以及 $B_0'=4.2$（无量纲）。使用 $1\\,\\mathrm{eV}/\\mathrm{\\AA}^3=160.21766208\\,\\mathrm{GPa}$ 将 $B_0$ 转换为 $\\mathrm{eV}/\\mathrm{\\AA}^3$。\n- 使用以下形式的误差代理：$$\\Delta E(V; N, E_{\\mathrm{cut}})=\\left(\\frac{A_k}{N^2}+\\frac{A_c}{E_{\\mathrm{cut}}^{3/2}}\\right)\\left(\\frac{V}{V_0}-1\\right)+\\frac{B_k}{N^3}\\left(\\frac{V}{V_0}-1\\right)^2,$$ 其中常数 $A_k=1.0$（单位 $\\mathrm{eV}$），$A_c=15.0$（单位 $\\mathrm{eV}$），以及 $B_k=0.2$（单位 $\\mathrm{eV}$）。此代理捕捉了随 k 点密度和平面波截断能增加而衰减的主导阶系统偏差，并通过一个依赖于体积的微扰确保了平衡体积的非平凡偏移。\n\n计算任务：\n- 使用从基本原理推导出的三阶 Birch-Murnaghan 模型实现 $E_{\\mathrm{EOS}}(V)$，并通过对 $a$ 最小化 $E_{\\text{tot}}(V(N,E_{\\mathrm{cut}}))$ 来计算平衡晶格参数 $a_{\\mathrm{eq}}(N,E_{\\mathrm{cut}})$，其中对面心立方晶格使用映射 $V=a^3/4$。\n- 将参考收敛晶格参数 $a_{\\mathrm{ref}}$ 定义为在理想收敛极限下（即状态方程的最小值处）的值，即 $a_{\\mathrm{ref}}=(4V_0)^{1/3}$，单位为 $\\mathrm{\\AA}$。\n- 对于每个测试用例，报告两个量：平衡晶格参数 $a_{\\mathrm{eq}}$（单位 $\\mathrm{\\AA}$）和分数偏差 $(a_{\\mathrm{eq}}-a_{\\mathrm{ref}})/a_{\\mathrm{ref}}$（以小数形式表示）。\n\n单位和数值要求：\n- 所有晶格参数以 $\\mathrm{\\AA}$ 表示。\n- 分数偏差以小数表示（无百分号）。\n- 不使用角度。\n- 使用双精度浮点运算。\n\n测试套件：\n在一系列 $(N,E_{\\mathrm{cut}})$ 对上评估程序，其中 $N$ 是无量纲的，$E_{\\mathrm{cut}}$ 的单位是 $\\mathrm{eV}$：\n1. $(4,250)$：极粗糙的 k 点和低截断能（边界情况）。\n2. $(8,300)$：粗糙的 k 点和低截断能（正常路径的粗略情况）。\n3. $(12,400)$：中等的 k 点和截断能。\n4. $(20,700)$：精细的 k 点和高截断能（接近收敛）。\n5. $(24,800)$：非常精细的 k 点和高截断能（边界接近收敛）。\n6. $(24,300)$：良好的 k 点，较差的截断能（不平衡收敛）。\n7. $(8,800)$：较差的 k 点，良好的截断能（不平衡收敛）。\n\n算法和输出规范：\n- 您的程序应通过在以 $a_{\\mathrm{ref}}$ 为中心的有界区间上最小化 $E_{\\text{tot}}(a)$ 来计算 $a_{\\mathrm{eq}}(N,E_{\\mathrm{cut}})$，然后计算相对于 $a_{\\mathrm{ref}}$ 的分数偏差。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号内由逗号分隔的数对列表，每个数对的形式为 $[a_{\\mathrm{eq}},\\ \\mathrm{分数偏差}]$。例如：$[[a_1,\\delta_1],[a_2,\\delta_2],\\dots]$。\n\n您的最终答案必须是一个完整、可运行的程序。",
            "solution": "问题陈述已经过严格评估，并被确定为有效。它具有科学依据、问题明确、客观，并包含所有必要信息，以构建和解决一个在计算材料科学领域独特而有意义的问题。\n\n任务是通过最小化总能量泛函，计算面心立方（fcc）高熵合金在不同数值收敛参数下的平衡晶格参数 $a_{\\mathrm{eq}}$。这需要推导和实现一个三阶 Birch-Murnaghan 状态方程（EOS），然后用一个收敛误差代理项对其进行增强。\n\n**1. 三阶 Birch-Murnaghan 状态方程的推导**\n\n问题要求从基本热力学原理推导 EOS，而不是假定一个标准的预定义公式。Birch-Murnaghan EOS 是通过将每个原子的总能量 $E$ 在欧拉有限应变 $f_E$ 中展开为泰勒级数来构建的。欧拉应变定义为：\n$$f_E(V) = \\frac{1}{2} \\left[ \\left(\\frac{V_0}{V}\\right)^{2/3} - 1 \\right]$$\n其中 $V$ 是单原子体积，$V_0$ 是平衡单原子体积。\n\n能量 $E(f_E)$ 在平衡态（$f_E=0$）附近的泰勒展开为：\n$$E(f_E) = E(0) + \\left.\\frac{dE}{df_E}\\right|_{f_E=0} f_E + \\frac{1}{2} \\left.\\frac{d^2E}{df_E^2}\\right|_{f_E=0} f_E^2 + \\frac{1}{6} \\left.\\frac{d^3E}{df_E^3}\\right|_{f_E=0} f_E^3 + \\mathcal{O}(f_E^4)$$\n在平衡状态（$V=V_0$），我们有 $f_E=0$，$E=E_0$，且压力 $P = -dE/dV = 0$。使用链式法则，$dE/dV = (dE/df_E) \\cdot (df_E/dV)$。由于 $df_E/dV|_{V=V_0} = -1/(3V_0) \\neq 0$，平衡条件 $dE/dV|_{V=V_0}=0$ 意味着展开式中的一阶导数项必须为零：\n$$\\left.\\frac{dE}{df_E}\\right|_{f_E=0} = 0$$\n因此，展开式从二阶项开始。截断至三阶可得：\n$$E(V) = E_0 + a_2 f_E^2 + a_3 f_E^3$$\n其中我们定义了系数 $a_2 = \\frac{1}{2} d^2E/df_E^2|_{f_E=0}$ 和 $a_3 = \\frac{1}{6} d^3E/df_E^3|_{f_E=0}$。这些系数可以与平衡体积模量 $B_0$ 及其一阶压力导数 $B_0' = (dB/dP)|_{V=V_0}$ 相关联。\n\n体积模量定义为 $B(V) = V (d^2E/dV^2)$。在平衡状态， $B_0 = V_0 (d^2E/dV^2)|_{V=V_0}$。通过两次应用链式法则并在 $V=V_0$（此时 $f_E=0$）处求值，我们得到：\n$$\\left.\\frac{d^2E}{dV^2}\\right|_{V=V_0} = \\frac{2 a_2}{9 V_0^2}$$\n将此代入 $B_0$ 的定义中可得：\n$$B_0 = V_0 \\left( \\frac{2 a_2}{9 V_0^2} \\right) = \\frac{2 a_2}{9 V_0} \\implies a_2 = \\frac{9}{2} V_0 B_0$$\n类似地，$B_0'$ 与能量的三阶导数有关。关系式为 $B_0' = -1 - V_0^2/B_0 \\cdot (d^3E/dV^3)|_{V=V_0}$。将链式法则应用于三阶导数，可将 $d^3E/dV^3|_{V=V_0}$ 与 $a_2$ 和 $a_3$ 关联起来，得到：\n$$a_3 = \\frac{9}{2} V_0 B_0 (B_0' - 4)$$\n将这些系数代入能量展开式，得到基于能量直接应变展开的三阶 Birch-Murnaghan EOS 的显式形式：\n$$E_{\\mathrm{EOS}}(V) = E_0 + \\frac{9}{2} V_0 B_0 f_E^2 + \\frac{9}{2} V_0 B_0 (B_0' - 4) f_E^3$$\n这可以因式分解为：\n$$E_{\\mathrm{EOS}}(V) = E_0 + \\frac{9}{2} V_0 B_0 f_E^2 \\left[ 1 + (B_0' - 4) f_E \\right]$$\n这个推导出的方程是热力学一致的，并满足了所要求的材料在平衡状态下的性质。\n\n**2. 总能量泛函**\n\n每个原子的总能量 $E_{\\text{tot}}$ 包括 EOS 能量和一个收敛误差代理 $\\Delta E$，它依赖于 k 点网格密度参数 $N$ 和平面波截断能 $E_{\\mathrm{cut}}$：\n$$E_{\\text{tot}}(V; N, E_{\\mathrm{cut}}) = E_{\\mathrm{EOS}}(V) + \\Delta E(V; N, E_{\\mathrm{cut}})$$\n提供的误差代理形式为：\n$$\\Delta E(V; N, E_{\\mathrm{cut}}) = \\left(\\frac{A_k}{N^2}+\\frac{A_c}{E_{\\mathrm{cut}}^{3/2}}\\right)\\left(\\frac{V}{V_0}-1\\right) + \\frac{B_k}{N^3}\\left(\\frac{V}{V_0}-1\\right)^2$$\n\n对于 fcc 晶格，单原子体积 $V$ 通过 $V = a^3/4$ 与传统立方晶格参数 $a$ 相关。我们将其代入总能量表达式中，以获得一个关于 $a$ 的函数：\n$$E_{\\text{tot}}(a; N, E_{\\mathrm{cut}}) = E_{\\text{tot}}(V=a^3/4; N, E_{\\mathrm{cut}})$$\n\n**3. 最小化与偏差计算**\n\n对于给定的收敛参数集，$a_{\\mathrm{eq}}(N, E_{\\mathrm{cut}})$，其平衡晶格参数是通过对 $a$ 最小化 $E_{\\text{tot}}(a)$ 来找到的。这是一个一维最小化问题，可以用数值方法求解。我们为此使用 `scipy.optimize.minimize_scalar`，在参考晶格参数 $a_{\\mathrm{ref}}$ 附近的一个有界区间内进行搜索。\n\n参考晶格参数 $a_{\\mathrm{ref}}$ 对应于没有收敛误差（即 $\\Delta E = 0$）时的平衡状态。这发生在体积为 $V_0$ 时。因此：\n$$a_{\\mathrm{ref}} = (4 V_0)^{1/3}$$\n\n对于每个测试用例 $(N, E_{\\mathrm{cut}})$，我们计算 $a_{\\mathrm{eq}}$ 和相对于参考值的分数偏差：\n$$\\text{分数偏差} = \\frac{a_{\\mathrm{eq}} - a_{\\mathrm{ref}}}{a_{\\mathrm{ref}}}$$\n\n**4. 实现参数**\n\n- **EOS 参数**：$E_0 = -6.0$ eV/原子， $V_0 = 12.0$ Å$^3$/原子， $B_0 = 180.0$ GPa， $B_0' = 4.2$。\n- **误差代理常数**：$A_k = 1.0$ eV， $A_c = 15.0$ eV， $B_k = 0.2$ eV。\n- **单位转换**：为了能量单位的一致性，体积模量 $B_0$ 的单位必须是 eV/Å$^3$。转换关系为 $1$ GPa $= 1/160.21766208$ eV/Å$^3$。\n$$B_0 [\\text{eV}/\\text{\\AA}^3] = 180.0 / 160.21766208 \\approx 1.1234736 \\text{ eV}/\\text{\\AA}^3$$\n- **参考晶格参数**：\n$$a_{\\mathrm{ref}} = (4 \\times 12.0)^{1/3} = (48)^{1/3} \\approx 3.6342411857 \\text{ \\AA}$$\n\n下面的 Python 代码实现了此过程，以计算所有指定测试用例所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium lattice parameter and its fractional deviation \n    for a high-entropy alloy model under various convergence conditions.\n    \"\"\"\n    \n    # Define physical and model constants from the problem statement.\n    E0 = -6.0  # eV/atom\n    V0 = 12.0  # Angstrom^3/atom\n    B0_GPa = 180.0  # GPa\n    B0_prime = 4.2  # dimensionless\n    \n    Ak = 1.0  # eV\n    Ac = 15.0 # eV\n    Bk = 0.2  # eV\n    \n    # Unit conversion for the bulk modulus.\n    GPa_to_eV_per_A3 = 1.0 / 160.21766208\n    B0_eV_A3 = B0_GPa * GPa_to_eV_per_A3\n    \n    # Calculate the reference lattice parameter (converged limit).\n    a_ref = (4.0 * V0)**(1.0/3.0)\n    \n    # Define the test suite of (N, E_cut) pairs.\n    test_cases = [\n        (4, 250),\n        (8, 300),\n        (12, 400),\n        (20, 700),\n        (24, 800),\n        (24, 300),\n        (8, 800)\n    ]\n    \n    results = []\n\n    def make_total_energy_func(N, E_cut):\n        \"\"\"\n        Factory function to create the total energy function for a specific\n        (N, E_cut) pair.\n        \"\"\"\n        def total_energy(a):\n            \"\"\"\n            Calculates the total energy per atom as a function of the lattice parameter 'a'.\n            \"\"\"\n            # Volume per atom for an fcc lattice.\n            V = a**3.0 / 4.0\n            \n            # Part 1: Third-order Birch-Murnaghan Equation of State energy.\n            # This is based on the rigorously derived form E(V) = E0 + a2*fE^2 + a3*fE^3.\n            if V == 0:\n                return 1e9 # Return a large number to avoid math errors for V=0.\n                \n            f_E = 0.5 * ((V0 / V)**(2.0/3.0) - 1.0)\n            \n            # Using the derived coefficients: a2 = 9/2*V0*B0, a3 = 9/2*V0*B0*(B0'-4)\n            term_fE2 = 4.5 * V0 * B0_eV_A3 * f_E**2\n            term_fE3_coeff = 4.5 * V0 * B0_eV_A3 * (B0_prime - 4.0)\n            \n            energy_eos = E0 + term_fE2 + term_fE3_coeff * f_E**3\n            \n            # Part 2: Convergence error surrogate energy.\n            v_ratio_minus_1 = (V / V0) - 1.0\n            \n            C1 = (Ak / N**2.0) + (Ac / E_cut**1.5)\n            C2 = Bk / N**3.0\n            \n            delta_e = C1 * v_ratio_minus_1 + C2 * v_ratio_minus_1**2\n            \n            return energy_eos + delta_e\n            \n        return total_energy\n\n    # Process each test case.\n    for N, E_cut in test_cases:\n        # Create the specific total energy function for this case.\n        energy_func_to_minimize = make_total_energy_func(N, E_cut)\n        \n        # Numerically minimize the energy function to find the equilibrium lattice parameter.\n        # The search is bounded in a physically reasonable interval around a_ref.\n        res = minimize_scalar(\n            energy_func_to_minimize, \n            bounds=(a_ref * 0.95, a_ref * 1.05), \n            method='bounded'\n        )\n        \n        a_eq = res.x\n        \n        # Calculate the fractional deviation.\n        deviation = (a_eq - a_ref) / a_ref\n        \n        # Store the formatted result pair.\n        results.append(f\"[{a_eq:.8f},{deviation:.8f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "确定了单个相的平衡态后，下一步是比较不同候选结构之间的相对稳定性，以预测材料的基态。本练习提供了一系列假设的能量-体积数据点，您需要通过拟合这些数据来找出面心立方（FCC）和体心立方（BCC）结构各自的最低能量()。通过比较这些能量最小值，您可以判断哪种相在热力学上更受青睐。",
            "id": "3763371",
            "problem": "给定某单等原子比高熵合金的面心立方（FCC）和体心立方（BCC）两种晶体结构的离散总能量-体积数据。假设 Born–Oppenheimer 近似成立，且固定原子位置上的总电子能量在平衡点附近定义了一个性质良好的物态方程。在最小值附近，将总能量近似为体积的三次多项式，并利用微积分原理确定能量最低时的体积。\n\n从以下基本依据出发：\n- Born–Oppenheimer 近似断言，在原子核位置固定时，总电子能量为原子定义了一个势能面。\n- 在稳定的平衡体积附近，作为体积函数的总能量可以通过低阶泰勒级数来近似。为了在有限的体积窗口内进行实际拟合，我们使用体积的三次多项式来建模能量，即通过线性最小二乘法拟合 $$E(V) = a_3 V^3 + a_2 V^2 + a_1 V + a_0$$，其中 $$E$$ 是能量，$$V$$ 是体积。\n- 平衡体积由平稳点条件 $$\\frac{dE}{dV} = 0$$ 给出，并需满足最小值的正曲率条件 $$\\frac{d^2E}{dV^2} > 0$$。如果计算出的平稳点位于采样区间之外，或在采样区间内不满足曲率条件，则选择区间端点中能量最低者。\n\n实现一个程序，对下述每个测试用例执行以下操作：\n1. 通过最小化残差平方和，分别为 FCC 和 BCC 数据集独立拟合一个三次多项式 $$E(V)$$。\n2. 通过求解 $$\\frac{dE}{dV} = 0$$ 并检验 $$\\frac{d^2E}{dV^2} > 0$$，在采样区间内找到使能量最小化的体积 $$V^\\star$$，否则使用能量最低的端点。\n3. 计算 FCC 的最小能量 $$E^\\text{FCC}_\\text{min}$$ 和 BCC 的最小能量 $$E^\\text{BCC}_\\text{min}$$。\n4. 输出能量差 $$\\Delta E = E^\\text{FCC}_\\text{min} - E^\\text{BCC}_\\text{min}$$，以电子伏特/原子 (eV/atom) 为单位，表示为浮点数。\n\n物理和数值单位：\n- 体积以每个原子为单位，单位为立方埃/原子 ($\\text{\\AA}^3/\\text{atom}$)。\n- 能量以每个原子为单位，单位为电子伏特/原子 ($\\text{eV}/\\text{atom}$)。\n- 最终的能量差 $$\\Delta E$$ 以电子伏特/原子 ($\\text{eV}/\\text{atom}$) 为单位，表示为浮点数。\n\n测试套件和数据：\n为 FCC 和 BCC 提供以下五个测试用例，形式为体积和能量对的列表。对于每个用例，程序必须计算 $$\\Delta E$$。\n\n用例 A（理想情况；不同的最小值）：\n- FCC 体积 $$[14.5, 15.0, 15.5, 16.0, 16.5, 17.0]$$，能量 $$[-5.1505, -5.1770, -5.19375, -5.2000, -5.1935, -5.1730]$$。\n- BCC 体积 $$[14.5, 15.0, 15.5, 16.0, 16.5, 17.0]$$，能量 $$[-4.979375, -5.0500, -5.103625, -5.1410, -5.162875, -5.1700]$$。\n\n用例 B（BCC 稳定；FCC 能量更高）：\n- FCC 体积 $$[15.0, 15.5, 16.0, 16.5, 17.0, 17.5]$$，能量 $$[-5.078528, -5.105643, -5.118808, -5.117273, -5.100288, -5.067103]$$。\n- BCC 体积 $$[15.0, 15.5, 16.0, 16.5, 17.0, 17.5]$$，能量 $$[-5.123744, -5.137624, -5.138904, -5.126084, -5.097664, -5.052144]$$。\n\n用例 C（近简并；差异极小）：\n- FCC 体积 $$[15.0, 15.3, 15.6, 15.9, 16.2]$$，能量 $$[-5.992908, -5.9982135, -6.0000, -5.9981865, -5.992692]$$。\n- BCC 体積 $$[15.0, 15.3, 15.6, 15.9, 16.2]$$，能量 $$[-5.9817713, -5.9913752, -5.9971019, -5.9990, -5.9971181]$$。\n\n用例 D（边界条件；最小值在区间外）：\n- FCC 体积 $$[13.0, 13.5, 14.0, 14.5]$$，能量 $$[-4.3800, -4.4325, -4.4700, -4.4925]$$。\n- BCC 体积 $$[13.0, 13.5, 14.0, 14.5]$$，能量 $$[-4.46125, -4.4350, -4.39125, -4.3300]$$。\n\n用例 E（平坦曲率；轻微噪声）：\n- FCC 体积 $$[10.0, 10.5, 11.0, 11.5, 12.0]$$，能量 $$[-2.9953, -2.99855, -3.0000, -2.99885, -2.99485]$$。\n- BCC 体积 $$[10.0, 10.5, 11.0, 11.5, 12.0]$$，能量 $$[-2.98656, -2.99196, -2.99476, -2.99456, -2.9910]$$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $$[x_1,x_2,x_3,x_4,x_5]$$，其中每个 $$x_i$$ 是为相应测试用例（按 A、B、C、D、E 的顺序）计算出的浮点数 $$\\Delta E$$，单位为电子伏特/原子 ($\\text{eV}/\\text{atom}$)。",
            "solution": "提出的问题要求确定一种高熵合金的面心立方（FCC）和体心立方（BCC）晶体结构之间的相对相稳定性。这通过计算它们的最小总能量之差 $$\\Delta E = E^\\text{FCC}_\\text{min} - E^\\text{BCC}_\\text{min}$$ 来完成。此分析的基础是 Born-Oppenheimer 近似，该近似允许将总能量表示为原子体积的函数 $$E(V)$$。必须将为每个相提供的离散能量-体积数据拟合到连续模型中，以准确定位能量最小值。\n\n对每种晶体结构的处理过程包括两个主要阶段：将离散数据拟合到三次多项式，然后根据指定约束条件找到该多项式函数的最小值。\n\n步骤 1：通过线性最小二乘法进行三次多项式拟合\n给定一组代表体积和能量的 $$N$$ 个离散数据点 $$(V_i, E_i)$$（其中 $$i = 1, \\dots, N$$），我们的任务是使用以下形式的三次多项式对能量-体积关系进行建模：\n$$\nE(V) = a_3 V^3 + a_2 V^2 + a_1 V + a_0\n$$\n系数 $$\\mathbf{c} = [a_3, a_2, a_1, a_0]^T$$ 通过最小化残差平方和 $$S$$ 来确定，$$S$$ 是观测能量 $$E_i$$ 与多项式预测能量 $$E(V_i)$$ 之间的差值：\n$$\nS = \\sum_{i=1}^{N} [E_i - (a_3 V_i^3 + a_2 V_i^2 + a_1 V_i + a_0)]^2\n$$\n这种最小化是一个标准的线性最小二乘问题。它可以用矩阵代数表示为最小化残差向量的欧几里得范数 $$\\| \\mathbf{A}\\mathbf{c} - \\mathbf{E} \\|_2^2$$。此处，$$\\mathbf{E}$$ 是给定能量值的向量，$$\\mathbf{A}$$ 是由体积数据构造的范德蒙矩阵：\n$$\n\\mathbf{A} = \\begin{pmatrix}\nV_1^3  V_1^2  V_1  1 \\\\\nV_2^3  V_2^2  V_2  1 \\\\\n\\vdots  \\vdots  \\vdots  \\vdots \\\\\nV_N^3  V_N^2  V_N  1\n\\end{pmatrix}, \\quad\n\\mathbf{E} = \\begin{pmatrix}\nE_1 \\\\\nE_2 \\\\\n\\vdots \\\\\nE_N\n\\end{pmatrix}\n$$\n该系统可以使用标准的数值线性代数例程（例如 Python 中 `numpy` 库提供的例程）来稳健地求解，从而计算出系数向量 $$\\mathbf{c}$$。\n\n步骤 2：定位最小能量\n在建立连续函数 $$E(V)$$ 后，下一步是找到使能量最小化的体积 $$V^\\star$$。根据微分学原理，最小值必须出现在平稳点，即函数对体积的一阶导数为零的点。该点的稳定性（即，是最小值、最大值还是拐点）由二阶导数的符号确定。\n\n能量多项式的一阶导数为：\n$$\n\\frac{dE}{dV} = 3a_3 V^2 + 2a_2 V + a_1\n$$\n将其设为零，即 $$\\frac{dE}{dV} = 0$$，得到一个关于体积 $$V$$ 的二次方程。该方程的根代表平稳点，可使用二次公式求得：\n$$\nV_\\text{stationary} = \\frac{-2a_2 \\pm \\sqrt{(2a_2)^2 - 4(3a_3)(a_1)}}{2(3a_3)} = \\frac{-a_2 \\pm \\sqrt{a_2^2 - 3a_1 a_3}}{3a_3}\n$$\n一个物理上有效的最小值必须满足几个条件：\n1.  根 $$V_\\text{stationary}$$ 必须是实数，这要求判别式 $$a_2^2 - 3a_1 a_3 \\ge 0$$。\n2.  平稳点必须对应于一个局部最小值，这通过一个正的二阶导数来确认：\n    $$\n    \\frac{d^2E}{dV^2} = 6a_3 V + 2a_2 > 0\n    $$\n3.  使能量最小化的体积 $$V^\\star$$ 必须位于由最小和最大采样体积定义的闭区间内，即 $$V^\\star \\in [V_\\text{min\\_data}, V_\\text{max\\_data}]$$。\n\n我们的算法将找到 $$\\frac{dE}{dV} = 0$$ 的所有实根。对于落在数据区间内的每个根，我们检验其二阶导数条件。如果找到一个或多个这样的最小值点，我们选择对应于绝对最低能量值的体积。\n\n根据问题陈述，如果在采样区间内不存在满足这些条件的平稳点，则该区间上的最小能量必定出现在其边界之一。在这种情况下，我们在端点 $$V_\\text{min\\_data}$$ 和 $$V_\\text{max\\_data}$$ 处评估拟合的多项式 $$E(V)$$，并将这两个值中较小的一个作为最小能量：\n$$\nE_\\text{min} = \\min(E(V_\\text{min\\_data}), E(V_\\text{max\\_data}))\n$$\n此过程正确地识别了拟合多项式在指定闭区间上的全局最小值。\n\n最终计算\n对每个测试用例，此完整过程都针对 FCC 和 BCC 数据集独立执行，从而得出它们各自的最小能量 $$E^\\text{FCC}_\\text{min}$$ 和 $$E^\\text{BCC}_\\text{min}$$。最终要报告的值是它们的差值：\n$$\n\\Delta E = E^\\text{FCC}_\\text{min} - E^\\text{BCC}_\\text{min}\n$$\n$$\\Delta E$$ 的符号表示相对稳定性：如果 $$\\Delta E < 0$$，则 FCC 相更稳定；如果 $$\\Delta E > 0$$，则 BCC 相更稳定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_minimum_energy(volumes, energies):\n    \"\"\"\n    Fits a cubic polynomial to the energy-volume data and finds the minimum energy.\n\n    The function fits E(V) = a*V^3 + b*V^2 + c*V + d, finds the stationary\n    points by solving dE/dV = 0, and checks for a minimum within the given\n    volume range. If no such minimum exists, it checks the boundaries of the\n    volume interval.\n\n    Args:\n        volumes (list[float]): A list of volumes per atom in cubic angstroms.\n        energies (list[float]): A list of corresponding energies per atom in eV.\n\n    Returns:\n        float: The minimum energy found for the fitted curve within the interval.\n    \"\"\"\n    # Fit a cubic polynomial E(V) = a3*V^3 + a2*V^2 + a1*V + a0\n    # The result of polyfit is an array of coefficients [a3, a2, a1, a0].\n    coeffs = np.polyfit(volumes, energies, 3)\n    p = np.poly1d(coeffs)\n\n    # Define the closed interval from the sampled volumes.\n    v_min_data = min(volumes)\n    v_max_data = max(volumes)\n\n    # Find stationary points by finding the roots of the first derivative.\n    # The derivative polynomial is given by p.deriv().\n    roots = np.roots(p.deriv())\n\n    # The second derivative polynomial is used to test for a minimum.\n    p_d2 = p.deriv(2)\n\n    valid_minima_volumes = []\n    for r in roots:\n        # We are only interested in real-valued stationary points.\n        if np.isreal(r):\n            v_stat = np.real(r)\n            # Check if the stationary point is within the sampled interval.\n            if v_min_data = v_stat = v_max_data:\n                # Check the second derivative condition for a local minimum (d^2E/dV^2  0).\n                if p_d2(v_stat) > 0:\n                    valid_minima_volumes.append(v_stat)\n\n    if valid_minima_volumes:\n        # If one or more valid minima are found within the interval,\n        # calculate their energies and select the lowest one.\n        min_energies_at_roots = [p(v) for v in valid_minima_volumes]\n        min_energy = min(min_energies_at_roots)\n    else:\n        # If no valid minimum is found in the interval (e.g., the minimum\n        # is outside the interval or the stationary points are maxima),\n        # the minimum over the closed interval must be at one of the endpoints.\n        energy_at_min_endpoint = p(v_min_data)\n        energy_at_max_endpoint = p(v_max_data)\n        min_energy = min(energy_at_min_endpoint, energy_at_max_endpoint)\n\n    return min_energy\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path; distinct minima)\n        {\n            \"fcc_v\": [14.5, 15.0, 15.5, 16.0, 16.5, 17.0],\n            \"fcc_e\": [-5.1505, -5.1770, -5.19375, -5.2000, -5.1935, -5.1730],\n            \"bcc_v\": [14.5, 15.0, 15.5, 16.0, 16.5, 17.0],\n            \"bcc_e\": [-4.979375, -5.0500, -5.103625, -5.1410, -5.162875, -5.1700]\n        },\n        # Case B (BCC stable; FCC higher)\n        {\n            \"fcc_v\": [15.0, 15.5, 16.0, 16.5, 17.0, 17.5],\n            \"fcc_e\": [-5.078528, -5.105643, -5.118808, -5.117273, -5.100288, -5.067103],\n            \"bcc_v\": [15.0, 15.5, 16.0, 16.5, 17.0, 17.5],\n            \"bcc_e\": [-5.123744, -5.137624, -5.138904, -5.126084, -5.097664, -5.052144]\n        },\n        # Case C (near-degenerate; very small difference)\n        {\n            \"fcc_v\": [15.0, 15.3, 15.6, 15.9, 16.2],\n            \"fcc_e\": [-5.992908, -5.9982135, -6.0000, -5.9981865, -5.992692],\n            \"bcc_v\": [15.0, 15.3, 15.6, 15.9, 16.2],\n            \"bcc_e\": [-5.9817713, -5.9913752, -5.9971019, -5.9990, -5.9971181]\n        },\n        # Case D (boundary condition; minimum outside interval)\n        {\n            \"fcc_v\": [13.0, 13.5, 14.0, 14.5],\n            \"fcc_e\": [-4.3800, -4.4325, -4.4700, -4.4925],\n            \"bcc_v\": [13.0, 13.5, 14.0, 14.5],\n            \"bcc_e\": [-4.46125, -4.4350, -4.39125, -4.3300]\n        },\n        # Case E (flat curvature; slight noise)\n        {\n            \"fcc_v\": [10.0, 10.5, 11.0, 11.5, 12.0],\n            \"fcc_e\": [-2.9953, -2.99855, -3.0000, -2.99885, -2.99485],\n            \"bcc_v\": [10.0, 10.5, 11.0, 11.5, 12.0],\n            \"bcc_e\": [-2.98656, -2.99196, -2.99476, -2.99456, -2.9910]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        e_fcc_min = find_minimum_energy(case[\"fcc_v\"], case[\"fcc_e\"])\n        e_bcc_min = find_minimum_energy(case[\"bcc_v\"], case[\"bcc_e\"])\n\n        delta_e = e_fcc_min - e_bcc_min\n        results.append(delta_e)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个在能量上有利的相未必是真正稳定的，它还必须在动力学上稳定，即能抵抗微小的原子振动。本练习通过计算声子色散关系，引入了动力学稳定性的概念()。您将学习如何构建和对角化动力学矩阵，并通过寻找虚频（即“软模”）来识别预示着相变或结构坍塌的晶格不稳定性。",
            "id": "3763319",
            "problem": "要求您为一个简单的一维双原子亚晶格高熵合金（HEA）模型，实现一个基于总能量谐波近似的第一性原理晶格动力学计算。其目标是计算沿第一布里渊区（FBZ）的声子色散关系，并识别出虚频率预示着结构不稳定性或相变的软模。该算法必须从总能量的谐波近似和动力学矩阵的定义出发。您不能依赖预先推导的色散公式；相反，您必须通过对实空间谐波力常数进行傅里叶变换来构建动力学矩阵，然后对其进行对角化，以从第一性原理获得声子频率。\n\n基础理论：\n- 在谐波近似下，围绕参考结构的小位移的总能量 $E$ 展开为\n$$\nE \\approx E_0 + \\frac{1}{2} \\sum_{i\\alpha,j\\beta} \\Phi_{i\\alpha,j\\beta} \\, u_{i\\alpha} \\, u_{j\\beta},\n$$\n其中 $u_{i\\alpha}$ 是原子 $i$ 在笛卡尔方向 $\\alpha$ 上的位移，而 $\\Phi_{i\\alpha,j\\beta}$ 是力常数（总能量的二阶导数）。\n- 波矢为 $\\mathbf{q}$ 处的动力学矩阵 $D(\\mathbf{q})$ 由质量加权的力常数的晶格傅里叶变换定义，\n$$\nD_{i\\alpha,j\\beta}(\\mathbf{q}) = \\frac{1}{\\sqrt{m_i m_j}} \\sum_{\\mathbf{R}} \\Phi_{i\\alpha,j\\beta}(\\mathbf{R}) \\, e^{i \\mathbf{q}\\cdot \\mathbf{R}},\n$$\n其中 $m_i$ 是原子 $i$ 的质量，$\\Phi_{i\\alpha,j\\beta}(\\mathbf{R})$ 将参考原胞与由晶格矢量 $\\mathbf{R}$ 平移的原胞耦合起来。声子频率 $\\omega(\\mathbf{q})$ 满足\n$$\nD(\\mathbf{q}) \\, e(\\mathbf{q},s) = \\omega^2(\\mathbf{q},s) \\, e(\\mathbf{q},s),\n$$\n其中 $s$ 为声子支的索引，$e(\\mathbf{q},s)$ 为本征矢量。虚频率对应于负的 $\\omega^2(\\mathbf{q},s)$（即 $D(\\mathbf{q})$ 的负本征值），并指示软模和结构不稳定性。\n\n模型说明：\n- 考虑一个一维双原子链作为 HEA 的最小二元亚晶格模型，每个晶胞有两个原子，标记为 $s=0$ 和 $s=1$，质量分别为 $m_0$ 和 $m_1$，晶格常数为 $a$。位移限制在沿链方向，因此不需要笛卡尔索引。\n- 只考虑最近邻谐波相互作用，通过两个弹簧常数实现：$k_0$ 用于同一晶胞内 $s=0$ 和 $s=1$ 之间的键，以及 $k_1$ 用于晶胞 $n$ 中的 $s=1$ 和晶胞 $n+1$ 中的 $s=0$ 之间的键。连接原子 $i$ 和 $j$ 的弹簧的对相互作用能为\n$$\nE_{ij} = \\frac{1}{2} k_{ij} \\, (u_j - u_i)^2,\n$$\n这对力常数产生如下的局域贡献\n$$\n\\Phi_{ii} \\leftarrow \\Phi_{ii} + k_{ij}, \\quad\n\\Phi_{jj} \\leftarrow \\Phi_{jj} + k_{ij}, \\quad\n\\Phi_{ij} \\leftarrow \\Phi_{ij} - k_{ij}, \\quad\n\\Phi_{ji} \\leftarrow \\Phi_{ji} - k_{ij}.\n$$\n- 列举出与双原子链的周期性和平移不变性一致的非零实空间力常数：\n$$\n\\Phi_{00}(0) = k_0 + k_1, \\quad \\Phi_{11}(0) = k_0 + k_1,\n$$\n$$\n\\Phi_{01}(0) = -k_0, \\quad \\Phi_{01}(-1) = -k_1,\n$$\n$$\n\\Phi_{10}(0) = -k_0, \\quad \\Phi_{10}(+1) = -k_1,\n$$\n所有其他的 $\\Phi_{ss'}(n)$ 均为零，其中 $n \\in \\mathbb{Z}$ 标记晶胞偏移，位置为 $R_n = n a$。\n- 一维动力学矩阵的分量由晶格傅里叶变换得出：\n$$\nD_{00}(q) = \\frac{k_0 + k_1}{m_0}, \\quad\nD_{11}(q) = \\frac{k_0 + k_1}{m_1},\n$$\n$$\nD_{01}(q) = \\frac{-k_0 - k_1 e^{-i q a}}{\\sqrt{m_0 m_1}}, \\quad\nD_{10}(q) = \\frac{-k_0 - k_1 e^{+i q a}}{\\sqrt{m_0 m_1}},\n$$\n并且对 $2\\times 2$ 的厄米矩阵 $D(q)$进行对角化以获得 $\\omega^2(q,s)$。\n\n计算任务：\n- 实现一个程序，给定 $(m_0,m_1,a,k_0,k_1)$，在一个包含 $N_q$ 个点的均匀波矢网格 $q \\in [0,\\pi/a]$ 上构建 $D(q)$，对每个 $q$ 对角化 $D(q)$，并通过检查负本征值 $\\omega^2(q,s)  -\\epsilon$ 来检测软模，其中 $\\epsilon$ 是一个小的正阈值，以避免由数值舍入误差引起的假阳性。虚频率等效于负的 $\\omega^2(q,s)$，因此预示着软模的存在。\n- 在组装 $D(q)$ 之前，必须使用 $1\\,\\text{u} = 1.66053906660 \\times 10^{-27}\\,\\text{kg}$ 将质量从原子质量单位转换为千克。弹簧常数的单位是 $\\text{N}/\\text{m}$，$a$ 的单位是 $\\text{m}$。尽管程序内部计算 $\\omega^2$ 时使用的单位是 $\\text{s}^{-2}$，但要求的输出是表示软模存在与否的无单位布尔值。由于 $q a$ 是无量纲的，所以不会出现角度单位的模糊性。\n\n测试套件：\n使用以下三个具有不同行为的科学上一致的参数集。对于每种情况，设置 $N_q = 201$ 和 $\\epsilon = 10^{-12}$。\n1. 情况 1（稳定，典型的二元质量和弹簧）： $(m_0,m_1) = (\\,50\\,\\text{u},\\,55\\,\\text{u}\\,)$, $a = 2.5 \\times 10^{-10}\\,\\text{m}$, $k_0 = 12\\,\\text{N}/\\text{m}$, $k_1 = 10\\,\\text{N}/\\text{m}$。\n2. 情况 2（不稳定，软化的晶胞间键导致 $q=0$ 处光学支出现负曲率）： $(m_0,m_1) = (\\,50\\,\\text{u},\\,55\\,\\text{u}\\,)$, $a = 2.5 \\times 10^{-10}\\,\\text{m}$, $k_0 = 12\\,\\text{N}/\\text{m}$, $k_1 = -20\\,\\text{N}/\\text{m}$。\n3. 情况 3（边缘情况，极端的质量比和极弱的晶胞间键，数值计算上具有挑战性但稳定）： $(m_0,m_1) = (\\,50\\,\\text{u},\\,200\\,\\text{u}\\,)$, $a = 2.5 \\times 10^{-10}\\,\\text{m}$, $k_0 = 1.0\\,\\text{N}/\\text{m}$, $k_1 = 1.0 \\times 10^{-6}\\,\\text{N}/\\text{m}$。\n\n输出规格：\n- 对于每个测试用例，返回一个布尔值，指示在 $q$-网格上是否存在至少一个软模，其定义为存在任何负本征值 $\\omega^2(q,s)  -\\epsilon$。将这三个布尔值聚合到单行输出中，形式为逗号分隔的 Python 风格列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 为 $\\text{True}$ 或 $\\text{False}$（无单位）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,x_3]$）。",
            "solution": "确定晶格稳定性的问题是凝聚态物理学和材料科学中的一个基本问题。一个给定的原子排列只有在对应于总势能的局域最小值时才是结构稳定的。原子从其平衡位置的微小位移必须导致能量增加。在谐波近似中，势能面在平衡构型周围展开到二阶，提供了一个二次能量景观。其稳定性由该景观的曲率符号决定。\n\n总能量 $E$ 对于小原子位移 $u_{i\\alpha}$（原子 $i$ 在方向 $\\alpha$ 上的位移）由下式给出：\n$$\nE \\approx E_0 + \\frac{1}{2} \\sum_{i\\alpha,j\\beta} \\Phi_{i\\alpha,j\\beta} u_{i\\alpha} u_{j\\beta}\n$$\n这里，$E_0$ 是静态参考晶格的能量，$\\Phi_{i\\alpha,j\\beta} = \\frac{\\partial^2 E}{\\partial u_{i\\alpha} \\partial u_{j\\beta}}$ 是 Hessian 矩阵，或称为谐波力常数矩阵。对于一个稳定结构，这个二次型必须是正定的，意味着其所有本征值都为正。\n\n周期性晶格中原子的集体振动由声子描述。从谐波势推导出的原子运动方程最好通过变换到倒易空间来求解。该过程按波矢 $\\mathbf{q}$ 将问题块对角化。对于每个 $\\mathbf{q}$，我们求解一个称为动力学矩阵 $D(\\mathbf{q})$ 的小矩阵的本征值问题。其矩阵元是实空间力常数的质量加权傅里叶变换：\n$$\nD_{s\\alpha,s'\\beta}(\\mathbf{q}) = \\frac{1}{\\sqrt{m_s m_{s'}}} \\sum_{\\mathbf{R}} \\Phi_{s\\alpha,s'\\beta}(\\mathbf{R}) e^{i \\mathbf{q}\\cdot \\mathbf{R}}\n$$\n其中 $s$ 和 $s'$ 索引晶胞内的原子，$m_s$ 是原子 $s$ 的质量，求和遍历所有晶格矢量 $\\mathbf{R}$。$D(\\mathbf{q})$ 的本征值是声子频率的平方，$\\omega^2(\\mathbf{q})$。\n$$\nD(\\mathbf{q}) \\mathbf{e}(\\mathbf{q}) = \\omega^2(\\mathbf{q}) \\mathbf{e}(\\mathbf{q})\n$$\n本征值的物理意义决定了稳定性：\n- 如果 $\\omega^2(\\mathbf{q})  0$，频率 $\\omega(\\mathbf{q})$ 为实数，对应于一个稳定的、传播的振动模式（声子）。\n- 如果 $\\omega^2(\\mathbf{q})  0$，频率 $\\omega(\\mathbf{q})$ 为虚数。这表明一个小的位移将随时间指数增长，而不是振荡。这是一种被称为“软模”的动力学不稳定性，它标志着初始原子结构是不稳定的，并将自发发生畸变。\n\n该问题要求我们将此形式体系应用于一个一维双原子链，其每个晶胞中含有质量为 $m_0$ 和 $m_1$ 的原子。晶格常数为 $a$。我们只考虑最近邻相互作用，其中晶胞内弹簧常数为 $k_0$，晶胞间弹簧常数为 $k_1$。根据从对势构建力常数的规则，提供了非零力常数 $\\Phi_{ss'}(n)$（将参考晶胞 0 中的原子 $s$ 与晶胞 $n$ 中的原子 $s'$ 耦合）。\n\n这个一维模型的动力学矩阵是一个 $2 \\times 2$ 的厄米矩阵，其分量如下：\n$$\nD_{00}(q) = \\frac{k_0 + k_1}{m_0}\n$$\n$$\nD_{11}(q) = \\frac{k_0 + k_1}{m_1}\n$$\n$$\nD_{01}(q) = \\frac{-k_0 - k_1 e^{-i q a}}{\\sqrt{m_0 m_1}}\n$$\n$$\nD_{10}(q) = \\frac{-k_0 - k_1 e^{+i q a}}{\\sqrt{m_0 m_1}}\n$$\n注意 $D_{10}(q) = D_{01}^*(q)$，这证实了其厄米性质。\n\n计算步骤是为给定的测试用例实现计算。对于每个用例，我们将：\n1. 定义物理常数和模型参数 $(m_0, m_1, a, k_0, k_1)$。质量以原子质量单位（$\\text{u}$）给出，必须使用提供的转换因子转换为千克（$\\text{kg}$）。\n2. 在区间 $[0, \\pi/a]$ 内生成一个包含 $N_q$ 个波矢 $q$ 的均匀网格，该网格覆盖了第一布里渊区的不可约部分。\n3. 遍历网格中的每个 $q$ 值。\n4. 在每个 $q$ 点，使用上述公式构建复数值的 $2 \\times 2$ 动力学矩阵 $D(q)$。\n5. 计算 $D(q)$ 的两个本征值。由于 $D(q)$ 是厄米矩阵，其本征值 ($\\omega^2$) 保证为实数。\n6. 检查是否有任一本征值为负，具体来说是小于一个小的负阈值 $-\\epsilon$（其中 $\\epsilon = 10^{-12}$），以便在避免零点附近的浮点不精确性导致的假阳性的同时，稳健地检测不稳定性。\n7. 如果在任何 $q$ 值下发现负本征值，我们断定对于给定的参数集存在软模。然后我们可以停止检查该情况下的其他 $q$ 值，并将结果记录为 `True`。\n8. 如果循环完成而没有发现任何负本征值，则系统是稳定的，结果为 `False`。\n9. 最终输出汇集所有测试用例的布尔结果。\n\n这个过程直接模拟了晶格动力学的物理原理来评估结构稳定性，符合要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Computes the presence of soft modes in a 1D diatomic lattice model.\n    \"\"\"\n\n    # Physical constant for atomic mass unit to kilogram conversion.\n    U_TO_KG = 1.66053906660e-27\n\n    # Computational parameters from the problem statement.\n    N_q = 201\n    epsilon = 1.0e-12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m0_u, m1_u, a_m, k0_Npm, k1_Npm)\n    test_cases = [\n        (50.0, 55.0, 2.5e-10, 12.0, 10.0),   # Case 1: Stable\n        (50.0, 55.0, 2.5e-10, 12.0, -20.0),  # Case 2: Unstable\n        (50.0, 200.0, 2.5e-10, 1.0, 1.0e-6),  # Case 3: Stable, extreme params\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m0_u, m1_u, a, k0, k1 = case\n\n        # Convert masses from atomic mass units (u) to kilograms (kg).\n        m0 = m0_u * U_TO_KG\n        m1 = m1_u * U_TO_KG\n\n        # Create a uniform grid of wave vectors q in the first Brillouin Zone [0, pi/a].\n        q_grid = np.linspace(0, np.pi / a, N_q)\n\n        soft_mode_found = False\n        \n        # Iterate through each wave vector to check for instabilities.\n        for q in q_grid:\n            # Construct the 2x2 dynamical matrix D(q).\n            # D is a complex-valued Hermitian matrix.\n            D = np.zeros((2, 2), dtype=np.complex128)\n\n            # Diagonal elements (real).\n            D[0, 0] = (k0 + k1) / m0\n            D[1, 1] = (k0 + k1) / m1\n\n            # Off-diagonal elements (complex conjugates).\n            common_term = -k0 - k1 * np.exp(-1j * q * a)\n            D[0, 1] = common_term / np.sqrt(m0 * m1)\n            D[1, 0] = np.conj(D[0, 1])\n\n            # Calculate the eigenvalues of the Hermitian matrix D(q).\n            # The eigenvalues omega^2 are guaranteed to be real.\n            # np.linalg.eigvalsh is optimized for Hermitian matrices.\n            eigenvalues_w2 = np.linalg.eigvalsh(D)\n\n            # Check if any eigenvalue is negative beyond the numerical tolerance epsilon.\n            # This indicates a soft mode and thus a structural instability.\n            if np.any(eigenvalues_w2  -epsilon):\n                soft_mode_found = True\n                # An instability was found, no need to check other q values for this case.\n                break\n        \n        results.append(soft_mode_found)\n\n    # Format the final output as a Python-style list of booleans.\n    # The map(str, ...) is used to get 'True'/'False' with capital letters.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}