{
    "hands_on_practices": [
        {
            "introduction": "加速分子动力学的一个核心概念是时间重加权。在偏置动力学模拟中，系统演化所经历的时间并不等同于真实的物理时间。本练习将指导您实现从偏置势轨迹中恢复物理时间的积分公式，这是理解和应用如超动力学（Hyperdynamics）等方法的基石。",
            "id": "3729122",
            "problem": "考虑在用于稀有事件的加速分子动力学（MD）方案（超动力学）中，一个原子构型在偏置势作用下演化的轨迹。设无偏势表示为 $U(\\mathbf{r})$，偏置是在亚稳态盆地中添加的非负含时函数 $\\Delta V(t)$，因此偏置势为 $U_{b}(\\mathbf{r}, t) = U(\\mathbf{r}) + \\Delta V(t)$。目标是通过在模拟路径上累积一个加速因子，来恢复与过渡态理论（TST）一致的、由模拟所推进的物理上正确的时钟时间。此映射的基本依据是，在过渡态理论中，对于温度为 $T$ 的热力学系统，逃逸速率与 $\\exp(-\\beta U)$ 成比例，其中 $\\beta = 1/(k_{B} T)$ 且 $k_{B}$ 是 Boltzmann 常数。在添加了偏置 $\\Delta V$ 后，微观时间尺度被扭曲。为了获得有效的物理时间，偏置模拟中的无穷小时间增量 $dt$ 必须通过因子 $\\exp(\\beta \\Delta V(t))$ 进行重新加权，总有效时间是路径积分\n$$\nt_{\\mathrm{eff}} = \\int_{0}^{t_{\\mathrm{sim}}} \\exp\\!\\big(\\beta \\Delta V(t)\\big)\\, dt,\n$$\n其中 $t_{\\mathrm{sim}}$ 是偏置模拟的时钟时间。量 $t_{\\mathrm{eff}}$ 必须以秒为单位表示。\n\n实现一个完整的程序，该程序：\n- 使用 $k_{B} = 8.617333262145 \\times 10^{-5}$ 电子伏特每开尔文 (eV/K) 计算 $\\beta = \\frac{1}{k_{B} T}$，其中 $T$ 的单位是开尔文，$\\Delta V$ 的单位是电子伏特 (eV)。\n- 给定一个离散轨迹，其时间点 $\\{t_i\\}$ 以秒为单位，相应的偏置值 $\\{\\Delta V(t_i)\\}$ 以电子伏特为单位，在给定的网格上以对非均匀时间步长精确的方式数值计算\n$$\nt_{\\mathrm{eff}} \\approx \\int \\exp\\!\\big(\\beta \\Delta V(t)\\big)\\, dt\n$$\n- 为所有测试用例生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$，其中每个结果都是一个以秒为单位的浮点数。\n\n使用以下测试套件来验证正确性和覆盖率（所有输出必须以秒为单位）：\n\n- 测试用例 $1$（恒定偏置，均匀网格，基准加速时间）：$T = 300$ 开尔文，$t_{\\mathrm{sim}} = 1.0 \\times 10^{-9}$ 秒，$N = 1001$ 个从 $t = 0$ 到 $t = t_{\\mathrm{sim}}$ 的等间距点，并且对于所有 $t$，$\\Delta V(t) = 0.1$ 电子伏特。这测试了 $\\exp(\\beta \\Delta V)$ 在时间上为常数的情况。\n\n- 测试用例 $2$（含时非负偏置，均匀网格，正弦变化）：$T = 600$ 开尔文，$t_{\\mathrm{sim}} = 2.0 \\times 10^{-8}$ 秒，$N = 20001$ 个等间距点，频率 $f = 5.0 \\times 10^{9}$ 赫兹，振幅 $A = 0.05$ 电子伏特，并且对于所有 $t$，$\\Delta V(t) = A \\big(1 + \\sin(2\\pi f t)\\big)$。这测试了具有非负偏置的非平凡时间依赖性。\n\n- 测试用例 $3$（分段偏置，非均匀网格）：$T = 450$ 开尔文，非均匀时间点 $t = [0, 2.0\\times 10^{-12}, 5.0\\times 10^{-12}, 1.1\\times 10^{-11}, 1.5\\times 10^{-11}]$ 秒，以及相应的 $\\Delta V$ 值 $[0.2, 0.2, 0.1, 0.0, 0.0]$ 电子伏特。这测试了非均匀时间采样和一个在出口附近趋于零的偏置。\n\n- 测试用例 $4$（零偏置基准）：$T = 300$ 开尔文，$t_{\\mathrm{sim}} = 1.0 \\times 10^{-9}$ 秒，$N = 1001$ 个等间距点，并且对于所有 $t$，$\\Delta V(t) = 0.0$ 电子伏特。这验证了当没有偏置时，$t_{\\mathrm{eff}}$ 简化为 $t_{\\mathrm{sim}}$。\n\n您的程序必须生成单行输出，其中包含四个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，例如 [x_1,x_2,x_3,x_4]，其中 x_i 是表示 $t_{\\mathrm{eff}}$（以秒为单位）的浮点数。",
            "solution": "该问题是有效的。其科学基础是加速分子动力学的原理，特别是超动力学方法。其物理参数和数学公式是一致且适定的，可以得到唯一的数值解。\n\n该问题背后的基本原理是，在偏置分子动力学轨迹中对模拟时间进行重新加权，以恢复系统的真实物理时间演化。在统计力学中，诸如原子扩散或化学反应等热激活稀有事件的速率由 Arrhenius 定律决定，该定律指出速率 $k$ 与 $\\exp(-\\beta E_a)$ 成正比，其中 $E_a$ 是活化能垒，$\\beta = 1/(k_B T)$ 是逆热能。这里，$k_B$ 是 Boltzmann 常数，$T$ 是绝对温度。\n\n在超动力学方法中，一个非负偏置势 $\\Delta V(\\mathbf{r}) \\ge 0$ 被添加到一个亚稳态内的真实势能面 $U(\\mathbf{r})$ 上。然后，动力学在偏置势能面 $U_b(\\mathbf{r}) = U(\\mathbf{r}) + \\Delta V(\\mathbf{r})$ 上进行演化。这个偏置势有效地降低了活化能垒，从而加速了从势阱中的逃逸。该偏置有效性的关键要求是，它在分隔盆地的过渡态表面上必须为零，这样才不会改变不同逃逸路径的相对概率。\n\n动力学的加速是以扭曲时间尺度为代价的。为了恢复真实的物理时间，偏置模拟的每个无穷小步长 $dt$ 都必须通过一个“加速因子”进行重新加权。该因子由偏置系综和无偏置系综中的概率（或驻留时间）之比推导得出。在一个由坐标 $\\mathbf{r}$ 表征的状态中，概率密度与 $\\exp(-\\beta U(\\mathbf{r}))$ 成正比。加上偏置后，它变为 $\\exp(-\\beta U_b(\\mathbf{r})) = \\exp(-\\beta U(\\mathbf{r})) \\exp(-\\beta \\Delta V(\\mathbf{r}))$。模拟所花费的时间被一个局部因子 $\\exp(\\beta \\Delta V(\\mathbf{r},t))$ 增强。为了获得正确的总流逝物理时间 $t_{\\mathrm{eff}}$，我们必须沿着持续时间为 $t_{\\mathrm{sim}}$ 的偏置模拟轨迹对这个加速因子进行积分：\n$$\nt_{\\mathrm{eff}} = \\int_{0}^{t_{\\mathrm{sim}}} \\exp\\!\\big(\\beta \\Delta V(t)\\big)\\, dt\n$$\n这里，$\\Delta V(t)$ 表示在模拟时间 $t$ 系统位置 $\\mathbf{r}(t)$ 处的偏置势的值。问题直接提供了偏置势的时间序列。\n\n任务是针对离散时间序列数据 $\\{t_i\\}$ 和相应的偏置势值 $\\{\\Delta V(t_i)\\}$ 数值计算该积分。根据问题陈述的要求，一种对均匀和非均匀网格都精确的稳健数值积分方法是梯形法则。对于在点 $(t_i, f_i)$ 采样的函数 $f(t)$，其积分可通过对连续点之间形成的梯形面积求和来近似：\n$$\n\\int_{t_0}^{t_{N-1}} f(t) \\, dt \\approx \\sum_{i=0}^{N-2} \\frac{f(t_i) + f(t_{i+1})}{2} (t_{i+1} - t_i)\n$$\n在我们的情况下，被积函数是 $f(t_i) = \\exp(\\beta \\Delta V(t_i))$。\n\n对于每个测试用例，计算实现将按以下步骤进行：\n1.  计算逆热能 $\\beta = \\frac{1}{k_B T}$，确保单位一致。当 $k_B$ 的单位是 $\\mathrm{eV}/\\mathrm{K}$，$T$ 的单位是 $\\mathrm{K}$，$\\Delta V$ 的单位是 $\\mathrm{eV}$ 时，乘积 $\\beta \\Delta V$ 正确地成为无量纲量。\n2.  生成时间点 $\\{t_i\\}$ 的离散网格和相应的偏置势值 $\\{\\Delta V_i = \\Delta V(t_i)\\}$。对于均匀网格，这涉及使用 `np.linspace`。对于非均匀网格，直接使用所提供的点。对于函数形式的 $\\Delta V(t)$，在时间网格上对该函数求值。\n3.  计算每个点 $i$ 的被积函数值 $y_i = \\exp(\\beta \\Delta V_i)$。\n4.  利用一个实现梯形法则的数值积分例程，例如 `numpy.trapz`，来计算该定积分。该函数接受被积函数值数组 $\\{y_i\\}$ 和时间点数组 $\\{t_i\\}$ 作为输入，能正确处理点 $t_i$ 之间的均匀和非均匀间距。\n\n- **测试用例 1** (恒定偏置)：被积函数 $\\exp(\\beta \\Delta V)$ 是常数。积分简化为 $t_{\\mathrm{eff}} = \\exp(\\beta \\Delta V) \\times t_{\\mathrm{sim}}$。数值方法应能精确地重现此解析结果。\n- **测试用例 2** (正弦偏置)：必须在精细、均匀网格的每个点上计算完整的含时被积函数，然后进行数值积分。\n- **测试用例 3** (分段偏置，非均匀网格)：此用例专门测试积分方法在非均匀采样网格上的稳健性。梯形法则是专门为处理这种情况而设计的。\n- **测试用例 4** (零偏置)：当 $\\Delta V = 0$ 时，加速因子为 $\\exp(0) = 1$。积分必须返回 $t_{\\mathrm{eff}} = \\int_0^{t_{\\mathrm{sim}}} 1 \\, dt = t_{\\mathrm{sim}}$，这是对实现方案基线正确性的一个关键验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the accelerated molecular dynamics time-recovery problem for four test cases.\n    \"\"\"\n\n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    def compute_teff(T, t_points, delta_V_points):\n        \"\"\"\n        Computes the effective physical time from a biased MD trajectory.\n\n        Args:\n            T (float): Temperature in Kelvin.\n            t_points (np.ndarray): Array of time points in seconds.\n            delta_V_points (np.ndarray): Array of bias potential values in eV.\n\n        Returns:\n            float: The effective time t_eff in seconds.\n        \"\"\"\n        if T == 0:\n            raise ValueError(\"Temperature must be positive.\")\n        \n        # Calculate inverse temperature in 1/eV\n        beta = 1.0 / (k_B * T)\n        \n        # Calculate the integrand, exp(beta * DeltaV(t))\n        integrand = np.exp(beta * delta_V_points)\n        \n        # Numerically integrate using the trapezoidal rule, which is suitable\n        # for both uniform and non-uniform grids.\n        t_eff = np.trapz(integrand, t_points)\n        \n        return t_eff\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: Constant bias, uniform grid\n        {\n            \"T\": 300.0,\n            \"t_sim\": 1.0e-9,\n            \"N\": 1001,\n            \"delta_V_func\": lambda t: 0.1\n        },\n        # Test Case 2: Time-dependent bias, uniform grid\n        {\n            \"T\": 600.0,\n            \"t_sim\": 2.0e-8,\n            \"N\": 20001,\n            \"delta_V_func\": lambda t: 0.05 * (1 + np.sin(2 * np.pi * 5.0e9 * t))\n        },\n        # Test Case 3: Piecewise bias, nonuniform grid\n        {\n            \"T\": 450.0,\n            \"t_points\": np.array([0.0, 2.0e-12, 5.0e-12, 1.1e-11, 1.5e-11]),\n            \"delta_V_points\": np.array([0.2, 0.2, 0.1, 0.0, 0.0])\n        },\n        # Test Case 4: Zero bias baseline\n        {\n            \"T\": 300.0,\n            \"t_sim\": 1.0e-9,\n            \"N\": 1001,\n            \"delta_V_func\": lambda t: 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T = case[\"T\"]\n        \n        if \"t_points\" in case:\n            # Case with explicitly defined non-uniform grid\n            t_points = case[\"t_points\"]\n            delta_V_points = case[\"delta_V_points\"]\n        else:\n            # Cases with uniform grid and functional form of delta_V\n            t_sim = case[\"t_sim\"]\n            N = case[\"N\"]\n            delta_V_func = case[\"delta_V_func\"]\n            \n            t_points = np.linspace(0, t_sim, N)\n            \n            # For constant functions, we can create a full array\n            if np.isscalar(delta_V_func(0)):\n                delta_V_points = np.full(N, delta_V_func(0))\n            else: # For time-dependent functions\n                delta_V_points = delta_V_func(t_points)\n\n        result = compute_teff(T, t_points, delta_V_points)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从加速模拟中获得一系列重加权后的“无偏”事件时间后，下一步是估计其对应的物理速率。本练习将介绍如何应用最大似然估计（MLE）这一强大的统计方法，从有限的事件数据中计算出最可能的反应速率。此外，我们还将学习如何量化估计的不确定性，即计算其置信区间，这是严谨科学分析中不可或缺的一步。",
            "id": "3729149",
            "problem": "在应用于难熔高熵合金的加速分子动力学中，考虑在超动力学中构建的偏置势作用下，一个与单空位迁移事件相关的亚稳微观盆地的逃逸过程。假设盆地中的无偏置停留时间被建模为速率为 $k$ 的独立同分布指数随机变量，这意味着单个无偏置停留时间 $t$ 的概率密度为 $f(t \\mid k) = k \\exp(-k t)$ (当 $t \\ge 0$)。在模拟中，每个停留阶段内都保持一个恒定的提升因子，因此第 $i$ 阶段的无偏置停留时间 $t_i$ 通过 $t_i = s_i \\, \\tau_i^{b}$ 与观测到的偏置停留时间 $\\tau_i^{b}$ 相关联，其中 $s_i$ 是已知的每阶段加速（提升）因子。\n\n你的任务是：\n- 从 $t_i$ 的独立性和指数模型出发，根据无偏置停留时间 $\\{t_i\\}_{i=1}^{n}$ 推导逃逸速率 $k$ 的最大似然估计量。\n- 对于大小为 $n$ 的有限样本，使用基于费雪信息的大样本正态近似，构建 $k$ 的双边置信区间。用估计量、样本大小和对应于双边 $95\\%$ 水平的标准正态分位数来表示该区间。\n- 使用以下 $n=4$ 次逃逸事件的观测数据：\n  - 阶段 1：$\\tau_1^{b} = 0.50 \\ \\mathrm{ps}$，$s_1 = 20$，\n  - 阶段 2：$\\tau_2^{b} = 0.40 \\ \\mathrm{ps}$，$s_2 = 25$，\n  - 阶段 3：$\\tau_3^{b} = 1.00 \\ \\mathrm{ps}$，$s_3 = 10$，\n  - 阶段 4：$\\tau_4^{b} = 0.25 \\ \\mathrm{ps}$，$s_4 = 40$，\n  计算重加权的无偏置停留时间 $\\{t_i\\}$，并数值计算你的估计量和 $95\\%$ 置信区间。\n\n答案规格：\n- 以 $\\mathrm{ps}^{-1}$ 为单位表示最终速率和两个置信区间界限。\n- 将最终结果报告为按 $\\big(k_{\\text{MLE}}, k_{\\text{lower}}, k_{\\text{upper}}\\big)$ 顺序排列的三个数字。\n- 将报告的每个数字四舍五入到四位有效数字。",
            "solution": "该问题是有效的。它在科学上基于统计力学和计算材料科学的原理，特别是加速分子动力学。问题陈述清晰，提供了所有必要信息和明确的目标。语言客观，设定内部一致。\n\n首先，我们推导逃逸速率 $k$ 的最大似然估计量 (MLE)。问题陈述，无偏置停留时间 $\\{t_i\\}_{i=1}^{n}$ 是来自概率密度函数为 $f(t_i | k) = k \\exp(-k t_i)$ 的指数分布的独立同分布随机变量。对于大小为 $n$ 的样本，其似然函数 $L(k)$ 是各个概率密度的乘积：\n$$L(k; \\{t_i\\}_{i=1}^{n}) = \\prod_{i=1}^{n} f(t_i | k) = \\prod_{i=1}^{n} k \\exp(-k t_i) = k^n \\exp\\left(-k \\sum_{i=1}^{n} t_i\\right)$$\n为了找到 $L(k)$ 的最大值，我们首先取自然对数得到对数似然函数 $\\ell(k)$：\n$$\\ell(k) = \\ln(L(k)) = \\ln\\left(k^n \\exp\\left(-k \\sum_{i=1}^{n} t_i\\right)\\right) = n \\ln(k) - k \\sum_{i=1}^{n} t_i$$\n然后，我们将 $\\ell(k)$ 对 $k$ 求导，并令结果为零，以找到使对数似然最大化的 $k$ 值：\n$$\\frac{d\\ell(k)}{dk} = \\frac{n}{k} - \\sum_{i=1}^{n} t_i = 0$$\n解出 $k$ 得到最大似然估计量，记为 $\\hat{k}$：\n$$\\hat{k} = \\frac{n}{\\sum_{i=1}^{n} t_i}$$\n这表明速率 $k$ 的最大似然估计量是无偏置停留时间的样本均值的倒数。\n\n接下来，我们使用大样本正态近似为 $k$ 构建一个双边 $95\\%$ 置信区间。最大似然估计量的渐近方差由费雪信息的倒数给出。单个观测的费雪信息 $I(k)$ 定义为 $I(k) = -E\\left[\\frac{d^2 \\ln f(t|k)}{dk^2}\\right]$。\n对数概率密度函数的一阶导数是 $\\frac{d \\ln f(t|k)}{dk} = \\frac{1}{k} - t$。二阶导数是：\n$$\\frac{d^2 \\ln f(t|k)}{dk^2} = -\\frac{1}{k^2}$$\n由于二阶导数相对于 $t$ 是一个常数，其期望就是该常数本身。因此，单个观测的费雪信息是：\n$$I(k) = -E\\left[-\\frac{1}{k^2}\\right] = \\frac{1}{k^2}$$\n对于 $n$ 个独立观测的样本，总费雪信息为 $I_n(k) = n I(k) = \\frac{n}{k^2}$。最大似然估计量 $\\hat{k}$ 的渐近方差是 $I_n(k)$ 的倒数：\n$$\\text{Var}(\\hat{k}) \\approx [I_n(k)]^{-1} = \\frac{k^2}{n}$$\n$\\hat{k}$ 的标准误差通过用 $\\hat{k}$ 代替 $k$ 来估计：\n$$SE(\\hat{k}) = \\sqrt{\\frac{\\hat{k}^2}{n}} = \\frac{\\hat{k}}{\\sqrt{n}}$$\n对于大样本 $n$，$\\hat{k}$ 的分布近似为正态分布，$\\hat{k} \\sim N\\left(k, \\frac{k^2}{n}\\right)$。$k$ 的一个双边 $100(1-\\alpha)\\%$ 置信区间由 $\\hat{k} \\pm z_{1-\\alpha/2} SE(\\hat{k})$ 给出，其中 $z_{1-\\alpha/2}$ 是标准正态分布的上 $(1-\\alpha/2)$ 分位数。对于 $95\\%$ 的置信水平，$\\alpha=0.05$，所以我们使用 $z_{1-0.05/2} = z_{0.975} \\approx 1.96$。置信区间为：\n$$ \\left( \\hat{k} - z_{0.975} \\frac{\\hat{k}}{\\sqrt{n}}, \\hat{k} + z_{0.975} \\frac{\\hat{k}}{\\sqrt{n}} \\right) = \\hat{k} \\left( 1 \\pm \\frac{z_{0.975}}{\\sqrt{n}} \\right) $$\n\n最后，我们使用所提供的数据计算数值。首先，我们计算无偏置停留时间 $t_i = s_i \\tau_i^b$：\n- $t_1 = 20 \\times 0.50 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n- $t_2 = 25 \\times 0.40 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n- $t_3 = 10 \\times 1.00 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n- $t_4 = 40 \\times 0.25 \\ \\mathrm{ps} = 10.0 \\ \\mathrm{ps}$\n\n无偏置停留时间的总和是 $\\sum_{i=1}^{4} t_i = 10.0+10.0+10.0+10.0 = 40.0 \\ \\mathrm{ps}$。\n样本大小为 $n=4$。$k$ 的最大似然估计量是：\n$$\\hat{k}_{\\text{MLE}} = \\frac{4}{40.0 \\ \\mathrm{ps}} = 0.1 \\ \\mathrm{ps}^{-1}$$\n对于置信区间，我们有 $n=4$，所以 $\\sqrt{n}=2$，以及 $z_{0.975} \\approx 1.96$。\n置信区间的下界 $k_{\\text{lower}}$ 是：\n$$k_{\\text{lower}} = 0.1 \\left( 1 - \\frac{1.96}{2} \\right) = 0.1 (1 - 0.98) = 0.1(0.02) = 0.002 \\ \\mathrm{ps}^{-1}$$\n置信区间的上界 $k_{\\text{upper}}$ 是：\n$$k_{\\text{upper}} = 0.1 \\left( 1 + \\frac{1.96}{2} \\right) = 0.1 (1 + 0.98) = 0.1(1.98) = 0.198 \\ \\mathrm{ps}^{-1}$$\n问题要求将结果四舍五入到四位有效数字。\n- $\\hat{k}_{\\text{MLE}} = 0.1 \\ \\mathrm{ps}^{-1}$ 变为 $0.1000 \\ \\mathrm{ps}^{-1}$。\n- $k_{\\text{lower}} = 0.002 \\ \\mathrm{ps}^{-1}$ 变为 $0.002000 \\ \\mathrm{ps}^{-1}$。\n- $k_{\\text{upper}} = 0.198 \\ \\mathrm{ps}^{-1}$ 变为 $0.1980 \\ \\mathrm{ps}^{-1}$。\n最终结果是序三元组 $(k_{\\text{MLE}}, k_{\\text{lower}}, k_{\\text{upper}})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1000  0.002000  0.1980\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "所有加速动力学方法及其后续的统计分析都建立在一个关键假设之上：稀有事件的发生是无记忆的（马尔可夫过程），这导致其逃逸时间服从指数分布。如果这个假设不成立，计算出的时间和速率将是有偏的。本练习将引导您设计并实现一个似然比检验（LRT），以从统计上验证您的模拟数据是否符合这一基本假设，从而确保结果的有效性。",
            "id": "3729086",
            "problem": "您正在使用加速分子动力学（AMD）模拟高熵合金（HEA）中的稀有事件动力学。在马尔可夫假设下，且当亚稳态盆地内存在准稳态分布（QSD）时，从该盆地逃逸的时间是无记忆的，具有恒定的风险率。从第一性原理出发，这意味着逃逸时间分布是具有单一率参数的指数分布。偏离指数分布表明存在非马尔可夫效应、盆地内存在异质微观态，或违反了AMD的假设（例如，不正确的提升因子或不充分的去相关），这些情况会使时间加速映射失效，并导致有偏的动力学结果。\n\n从生存函数、风险函数和独立逃逸时间下的最大似然估计（MLE）的定义出发，推导并实现一个统计检验，用于检测逃逸时间是否偏离指数分布。将此检验构建为一个似然比检验（LRT），比较指数模型（恒定风险）与更通用的威布尔模型（时变风险）。您的程序必须：\n\n- 从第一性原理推导指数模型和威布尔模型的对数似然，并计算LRT统计量。\n- 使用原假设下LRT统计量的渐近分布来计算$p$值。\n- 对每个数据集返回一个布尔决策，指明在显著性水平 $\\alpha = 0.05$ 下，指数逃逸时间的原假设是否被拒绝。\n\n使用的定义：\n- 生存函数为 $S(t) = \\mathbb{P}(T  t)$，风险函数为 $h(t) = \\frac{f(t)}{S(t)}$，其中 $f(t)$ 是逃逸时间 $T$ 的概率密度函数。\n- 在恒定风险的原假设下，$T$ 服从尺度参数为 $\\lambda  0$ 的指数分布，因此对于 $t \\ge 0$，其概率密度函数为 $f(t) = \\frac{1}{\\lambda} \\exp\\!\\left(-\\frac{t}{\\lambda}\\right)$。\n- 在备择假设下，$T$ 服从形状参数为 $k  0$ 且尺度参数为 $\\lambda  0$ 的威布尔分布，因此对于 $t \\ge 0$，其概率密度函数为 $f(t) = \\frac{k}{\\lambda}\\left(\\frac{t}{\\lambda}\\right)^{k-1} \\exp\\!\\left(-\\left(\\frac{t}{\\lambda}\\right)^{k}\\right)$。\n\n物理单位与数据生成：\n- 逃逸时间必须以秒为单位处理，并作为以秒为单位的独立样本生成。\n- 为保证可复现性，请使用一个固定种子 $s = 314159$ 的伪随机数生成器。\n- 构建以下数据集测试套件，每个数据集都是一个以秒为单位的独立逃逸时间列表：\n    1. 尺度参数 $\\lambda = 2.0$ 秒的指数分布逃逸时间，样本量 $n = 200$。\n    2. 形状参数 $k = 0.7$、尺度参数 $\\lambda = 2.0$ 秒的威布尔分布逃逸时间，样本量 $n = 200$。\n    3. 指数混合分布：以 $0.5$ 的概率从 $\\text{Exponential}(\\lambda_1 = 1.0)$ 秒的分布中抽样，以 $0.5$ 的概率从 $\\text{Exponential}(\\lambda_2 = 3.3333333333)$ 秒的分布中抽样，样本量 $n = 200$。\n    4. 尺度参数 $\\lambda = 2.0$ 秒的指数分布逃逸时间，样本量 $n = 20$（边界情况：统计功效低）。\n    5. 形状参数 $k = 1.5$、尺度参数 $\\lambda = 2.0$ 秒的威布尔分布逃逸时间，样本量 $n = 200$。\n\n算法要求：\n- 在原假设下，根据给定数据通过MLE估计指数分布的尺度参数 $\\lambda$。\n- 在备择假设下，根据给定数据通过MLE估计威布尔分布的形状参数 $k$ 和尺度参数 $\\lambda$。\n- 使用最大化对数似然的差值计算LRT统计量，并从自由度为1的卡方分布中获取$p$值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，其顺序与上述数据集的顺序相同（例如，“[True,False,True,False,True]”）。\n- 每个布尔值必须指明对于该数据集，在 $\\alpha = 0.05$ 的显著性水平下，指数逃逸时间的原假设是否被拒绝。",
            "solution": "该问题要求推导并实现一个似然比检验（LRT），以验证加速分子动力学（AMD）模拟中指数逃逸时间的假设。这个假设是基础性的，因为它源于模拟设置将稀有事件近似为一个无记忆的马尔可夫过程。偏离具有恒定风险率的指数分布，表明潜在的动力学过程更为复杂（例如，非马尔可夫性或涉及异质状态），并且从AMD中获得的时间加速可能存在偏差。我们将比较指数分布的原假设与一个更通用的备择假设——威布尔分布，后者允许时变风险率。\n\n### 1. 似然比检验的理论构建\n\n设观测到的逃逸时间为一组 $n$ 个独立同分布（i.i.d.）的正随机变量 $\\mathbf{T} = \\{T_1, T_2, \\ldots, T_n\\}$，其观测值为 $\\mathbf{t} = \\{t_1, t_2, \\ldots, t_n\\}$。似然函数由 $L(\\theta | \\mathbf{t}) = \\prod_{i=1}^n f(t_i | \\theta)$ 给出，其中 $f(t|\\theta)$ 是由 $\\theta$ 参数化的概率密度函数（PDF）。我们将使用对数似然函数，$\\ell(\\theta | \\mathbf{t}) = \\ln L(\\theta | \\mathbf{t}) = \\sum_{i=1}^n \\ln f(t_i | \\theta)$。\n\n#### 原假设（$H_0$）：指数逃逸时间\n\n在原假设下，逃逸时间服从指数分布，其特征是恒定的风险率。其概率密度函数为：\n$$\nf(t|\\lambda) = \\frac{1}{\\lambda} \\exp\\left(-\\frac{t}{\\lambda}\\right), \\quad t \\ge 0, \\lambda  0\n$$\n其中 $\\lambda$ 是尺度参数，代表平均逃逸时间。对于样本 $\\mathbf{t}$，其对数似然函数为：\n$$\n\\ell_0(\\lambda | \\mathbf{t}) = \\sum_{i=1}^n \\ln\\left(\\frac{1}{\\lambda} \\exp\\left(-\\frac{t_i}{\\lambda}\\right)\\right) = \\sum_{i=1}^n \\left(-\\ln\\lambda - \\frac{t_i}{\\lambda}\\right) = -n\\ln\\lambda - \\frac{1}{\\lambda}\\sum_{i=1}^n t_i\n$$\n为了找到 $\\lambda$ 的最大似然估计（MLE），我们将 $\\ell_0$ 对 $\\lambda$ 求导，并令其结果为零：\n$$\n\\frac{\\partial \\ell_0}{\\partial \\lambda} = -\\frac{n}{\\lambda} + \\frac{1}{\\lambda^2}\\sum_{i=1}^n t_i = 0\n$$\n求解 $\\lambda$ 可得到其MLE，记为 $\\hat{\\lambda}_0$：\n$$\n\\hat{\\lambda}_0 = \\frac{1}{n}\\sum_{i=1}^n t_i = \\bar{t}\n$$\n指数分布尺度参数的MLE是样本均值。在 $H_0$ 下的最大化对数似然（记为 $\\hat{\\ell}_0$）可通过将 $\\hat{\\lambda}_0$ 代入 $\\ell_0(\\lambda | \\mathbf{t})$ 得到：\n$$\n\\hat{\\ell}_0 = \\ell_0(\\hat{\\lambda}_0 | \\mathbf{t}) = -n\\ln(\\bar{t}) - \\frac{1}{\\bar{t}}\\sum_{i=1}^n t_i = -n\\ln(\\bar{t}) - \\frac{n\\bar{t}}{\\bar{t}} = -n(\\ln(\\bar{t}) + 1)\n$$\n\n#### 备择假设（$H_1$）：威布尔逃逸时间\n\n在备择假设下，我们使用双参数威布尔分布，该分布能容纳时变风险函数 $h(t) \\propto t^{k-1}$。其概率密度函数为：\n$$\nf(t|k, \\lambda) = \\frac{k}{\\lambda}\\left(\\frac{t}{\\lambda}\\right)^{k-1} \\exp\\left(-\\left(\\frac{t}{\\lambda}\\right)^k\\right), \\quad t \\ge 0, k  0, \\lambda  0\n$$\n这里，$k$ 是形状参数，$\\lambda$ 是尺度参数。指数分布是威布尔分布在 $k=1$ 时的特例。对于样本 $\\mathbf{t}$，其对数似然函数为：\n$$\n\\ell_1(k, \\lambda | \\mathbf{t}) = \\sum_{i=1}^n \\ln\\left[\\frac{k}{\\lambda}\\left(\\frac{t_i}{\\lambda}\\right)^{k-1} \\exp\\left(-\\left(\\frac{t_i}{\\lambda}\\right)^k\\right)\\right] = n\\ln k - nk\\ln\\lambda + (k-1)\\sum_{i=1}^n \\ln t_i - \\sum_{i=1}^n\\left(\\frac{t_i}{\\lambda}\\right)^k\n$$\n$k$ 和 $\\lambda$ 的MLE（记为 $(\\hat{k}_1, \\hat{\\lambda}_1)$）没有闭式解。它们必须通过数值最大化 $\\ell_1(k, \\lambda | \\mathbf{t})$ 来求得。在 $H_1$ 下的最大化对数似然（记为 $\\hat{\\ell}_1$）为 $\\ell_1(\\hat{k}_1, \\hat{\\lambda}_1 | \\mathbf{t})$。\n\n#### 似然比检验统计量\n\nLRT用于比较两个嵌套模型。由于指数模型是威布尔模型（$k=1$）的特例，因此它们是嵌套的。LRT统计量 $\\Lambda$ 定义为最大化对数似然差值的两倍：\n$$\n\\Lambda = 2(\\hat{\\ell}_1 - \\hat{\\ell}_0)\n$$\n根据威尔克斯定理（Wilks' theorem），在原假设 $H_0$ 下，检验统计量 $\\Lambda$ 渐近服从卡方（$\\chi^2$）分布。自由度（$df$）的数量是备择模型和原假设模型之间自由参数数量的差值。在我们的案例中，威布尔模型有两个参数（$k, \\lambda$），指数模型有一个参数（$\\lambda$），所以 $df = 2 - 1 = 1$。\n$$\n\\Lambda \\sim \\chi^2_1 \\quad (\\text{under } H_0)\n$$\n\n### 2. 算法流程与决策规则\n\n对于每个逃逸时间数据集，统计检验按以下步骤实现：\n\n1.  **生成数据集：** 为保证可复现性，使用一个固定种子 $s = 314159$ 的伪随机数生成器来构建五个指定的逃逸时间测试案例。\n\n2.  **在 $H_0$ 下进行估计：** 计算指数参数的MLE，$\\hat{\\lambda}_0 = \\bar{t}$。然后计算最大化对数似然，$\\hat{\\ell}_0 = -n(\\ln(\\hat{\\lambda}_0) + 1)$。\n\n3.  **在 $H_1$ 下进行估计：** 数值求解最大化威布尔对数似然函数 $\\ell_1(k, \\lambda | \\mathbf{t})$ 的参数 $(\\hat{k}_1, \\hat{\\lambda}_1)$。这通过使用数值优化算法（如可以处理边界约束 $k0, \\lambda0$ 的L-BFGS-B算法）最小化负对数似然函数 $-\\ell_1(k, \\lambda | \\mathbf{t})$ 来实现。最终得到的最大化对数似然为 $\\hat{\\ell}_1$。\n\n4.  **计算检验统计量和 $p$ 值：** 计算LRT统计量 $\\Lambda = 2(\\hat{\\ell}_1 - \\hat{\\ell}_0)$。$\\Lambda$ 的值必须为非负数。任何因浮点不精确性导致的小负值都应视为零。然后，$p$ 值被计算为从 $\\chi^2_1$ 分布中观测到大于或等于所计算的 $\\Lambda$ 值的概率：\n    $$\n    p = \\mathbb{P}(\\chi^2_1 \\ge \\Lambda) = 1 - F_{\\chi^2_1}(\\Lambda)\n    $$\n    其中 $F_{\\chi^2_1}$ 是 $\\chi^2_1$ 分布的累积分布函数。这等价于生存函数。\n\n5.  **决策：** 将 $p$ 值与预定义的显著性水平 $\\alpha = 0.05$ 进行比较。如果 $p  \\alpha$，我们拒绝原假设 $H_0$。这表明逃逸时间不服从指数分布，且更简单的恒定风险模型是不充分的。反之，如果 $p \\ge \\alpha$，我们则不拒绝 $H_0$。\n\n这一严谨的流程为评估复杂材料的AMD模拟中关键假设的有效性提供了一个量化的诊断工具。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Derives and implements a Likelihood Ratio Test to detect deviations from\n    exponential exit times in simulated molecular dynamics data.\n    \"\"\"\n\n    def generate_datasets(seed):\n        \"\"\"Generates the five test datasets as specified in the problem.\"\"\"\n        rng = np.random.default_rng(seed)\n        datasets = []\n\n        # Dataset 1: Exponential(lambda=2.0), n=200\n        datasets.append(rng.exponential(scale=2.0, size=200))\n\n        # Dataset 2: Weibull(k=0.7, lambda=2.0), n=200\n        # numpy.random.weibull(a) has scale=1, so we multiply by the desired scale.\n        datasets.append(2.0 * rng.weibull(a=0.7, size=200))\n\n        # Dataset 3: Mixture of exponentials, n=200\n        n3 = 200\n        lam1, lam2 = 1.0, 10.0 / 3.0  # Use fraction for precision\n        mixture_draws = rng.uniform(size=n3)\n        data3 = np.array([\n            rng.exponential(scale=lam1) if u  0.5 \n            else rng.exponential(scale=lam2) \n            for u in mixture_draws\n        ])\n        datasets.append(data3)\n\n        # Dataset 4: Exponential(lambda=2.0), n=20 (low power)\n        datasets.append(rng.exponential(scale=2.0, size=20))\n\n        # Dataset 5: Weibull(k=1.5, lambda=2.0), n=200\n        datasets.append(2.0 * rng.weibull(a=1.5, size=200))\n        \n        return datasets\n\n    def perform_lrt(data, alpha):\n        \"\"\"\n        Performs the Likelihood Ratio Test on a single dataset.\n        \n        Args:\n            data (np.ndarray): Array of exit times.\n            alpha (float): Significance level.\n\n        Returns:\n            bool: True if the null hypothesis is rejected, False otherwise.\n        \"\"\"\n        n = len(data)\n        \n        # H0: Exponential distribution\n        # MLE for lambda is the sample mean.\n        lambda_exp_mle = np.mean(data)\n        # Maximized log-likelihood for the exponential model.\n        log_L0 = -n * (np.log(lambda_exp_mle) + 1.0)\n        \n        # H1: Weibull distribution\n        def neg_log_likelihood_weibull(params, t_data):\n            k, lam = params\n            if k = 0 or lam = 0:\n                return np.inf\n            \n            # To avoid log(0) if any data point is zero.\n            if np.any(t_data = 0):\n                return np.inf\n\n            # Log-likelihood expression for Weibull\n            log_t = np.log(t_data)\n            term1 = n * np.log(k)\n            term2 = -n * k * np.log(lam)\n            term3 = (k - 1) * np.sum(log_t)\n            term4 = -np.sum((t_data / lam)**k)\n            \n            log_L = term1 + term2 + term3 + term4\n            return -log_L\n\n        # Initial guess for optimization: k=1 (exponential) and lambda=sample_mean\n        initial_guess = [1.0, lambda_exp_mle]\n        bounds = [(1e-9, None), (1e-9, None)]  # k > 0, lambda > 0\n        \n        opt_result = minimize(\n            neg_log_likelihood_weibull,\n            x0=initial_guess,\n            args=(data,),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        \n        # Maximized log-likelihood for the Weibull model\n        log_L1 = -opt_result.fun\n        \n        # Compute the LRT statistic\n        # Should be non-negative, but can be slightly negative due to precision.\n        lrt_statistic = 2 * (log_L1 - log_L0)\n        if lrt_statistic  0:\n            lrt_statistic = 0.0\n\n        # Compute p-value from chi-squared distribution with 1 degree of freedom\n        p_value = chi2.sf(lrt_statistic, df=1)\n\n        return p_value  alpha\n\n    # --- Main execution logic ---\n    \n    # Define parameters\n    seed = 314159\n    alpha = 0.05\n    \n    # Generate the test suite of datasets\n    test_cases = generate_datasets(seed)\n    \n    results = []\n    for data in test_cases:\n        # Perform the LRT for each dataset and store the boolean result\n        reject_h0 = perform_lrt(data, alpha)\n        results.append(reject_h0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}