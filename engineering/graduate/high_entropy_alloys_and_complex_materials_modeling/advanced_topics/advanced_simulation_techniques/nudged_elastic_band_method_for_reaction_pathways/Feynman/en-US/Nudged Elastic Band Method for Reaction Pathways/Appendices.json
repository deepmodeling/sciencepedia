{
    "hands_on_practices": [
        {
            "introduction": "The first step in any Nudged Elastic Band (NEB) calculation is to create an initial guess for the reaction path. The most straightforward approach is a linear interpolation between the known initial and final states. This exercise  invites you to implement this simple path and evaluate the potential energy profile on a rugged, multi-featured surface designed to mimic the complexity of a high-entropy alloy. By calculating the barrier from this naive guess, you will gain a direct, quantitative understanding of its primary limitation—the tendency to overestimate the true activation energy—and thereby appreciate the critical need for the path relaxation techniques at the core of the NEB method.",
            "id": "3752897",
            "problem": "Consider a binary diffusion event of a single migrating atom in a quinary high-entropy alloy (HEA) supercell. The goal is to evaluate, by first principles and algorithmic construction, a discretized estimate of the potential energy profile along a guessed path and to quantify an activation barrier using linear interpolation between the endpoints. You will construct a program to compute the energies of a set of discrete images along a linearly interpolated path and return the estimated barrier for several parameter sets. Use the Nudged Elastic Band (NEB) method’s conceptual foundation, but restrict the computation to sampling a guessed path by linear interpolation without any spring forces or tangent projections. The problem must be framed from the following base definitions and facts:\n\n- The potential energy surface (PES) assigns a potential energy $V(\\mathbf{R})$ to a configuration of atomic coordinates $\\mathbf{R}$. For a single migrating atom whose position is represented in two spatial dimensions, use $\\mathbf{r}\\in\\mathbb{R}^2$.\n- A continuous path between two endpoint configurations $\\mathbf{r}_0$ and $\\mathbf{r}_1$ can be parameterized as $\\mathbf{r}(t)=\\mathbf{r}_0+t(\\mathbf{r}_1-\\mathbf{r}_0)$, where $t\\in[0,1]$. A discretized set of $N$ images is defined by $t_i=\\frac{i}{N-1}$, yielding $\\mathbf{r}_i=\\mathbf{r}(t_i)$ for $i=0,1,\\dots,N-1$.\n- The activation barrier estimate relative to the initial state is defined as $E^\\ddagger=\\max_{i}V(\\mathbf{r}_i)-V(\\mathbf{r}_0)$.\n\nYou must implement the following physically motivated, rugged HEA-inspired PES for the migrating atom:\n\n$$\nV(\\mathbf{r})=\\sum_{j=1}^{5}A_j\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{c}_j\\|^2}{2\\sigma_j^2}\\right)\n+B\\cos\\!\\left(2\\pi\\,\\mathbf{q}\\cdot\\mathbf{r}\\right)\n+C\\sum_{m=1}^{2}\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{s}_m\\|^2}{2\\lambda^2}\\right),\n$$\n\nwhere the five Gaussian wells model local species-dependent attractions in the quinary alloy, the cosine term models a mesoscale strain field, and the final sum models two repulsive obstacles along the path. Use fixed parameters and endpoints as follows:\n\n- Gaussian well centers (species sites, in nanometers): $\\mathbf{c}_1=(0.0,\\,0.0)$, $\\mathbf{c}_2=(1.0,\\,0.0)$, $\\mathbf{c}_3=(0.5,\\,0.8)$, $\\mathbf{c}_4=(-0.6,\\,0.4)$, $\\mathbf{c}_5=(1.2,\\,-0.7)$.\n- Well depths (in electronvolts): $A_1=-0.20$, $A_2=-0.18$, $A_3=-0.16$, $A_4=-0.14$, $A_5=-0.12$.\n- Gaussian widths (in nanometers): $\\sigma_j=\\sigma=0.15$ for $j=1,\\dots,5$.\n- Repulsive obstacle centers (in nanometers): $\\mathbf{s}_1=(0.5,\\,0.0)$, $\\mathbf{s}_2=(0.6,\\,0.2)$.\n- Repulsive obstacle width (in nanometers): $\\lambda=0.10$.\n- Strain field wavevector (in inverse nanometers): $\\mathbf{q}=(1.5,\\,0.7)$.\n- Endpoints (in nanometers): $\\mathbf{r}_0=\\mathbf{c}_1$, $\\mathbf{r}_1=\\mathbf{c}_2$.\n\nThe amplitudes $B$ (strain field) and $C$ (repulsive obstacles) will vary per test case. The program must:\n\n- For each test case, construct $N$ linearly interpolated images $\\mathbf{r}_i$ between $\\mathbf{r}_0$ and $\\mathbf{r}_1$ using $\\mathbf{r}_i=\\mathbf{r}_0+\\frac{i}{N-1}(\\mathbf{r}_1-\\mathbf{r}_0)$.\n- Evaluate $V(\\mathbf{r}_i)$ for all $i$.\n- Compute the barrier $E^\\ddagger=\\max_i V(\\mathbf{r}_i)-V(\\mathbf{r}_0)$.\n\nExpress all energies in electronvolts (eV). Angles in the cosine are in radians. No other physical units need to be reported by the program. The final numerical results must be floats.\n\nDiscuss in your solution the limitations of linear interpolation on rugged PES, specifically for HEA systems with strong compositional disorder. Your discussion must be grounded in fundamental definitions and should not depend on any shortcut formulas.\n\nTest Suite:\nProvide outputs for the following parameter sets $(N,B,C)$:\n\n- Case $1$: $(11,\\,0.05,\\,0.25)$.\n- Case $2$: $(2,\\,0.05,\\,0.25)$.\n- Case $3$: $(51,\\,0.10,\\,0.35)$.\n- Case $4$: $(21,\\,0.00,\\,0.00)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$). Each $\\text{result}_k$ is the activation barrier $E^\\ddagger$ in eV for the corresponding test case, represented as a float. The program must be entirely self-contained and require no external inputs or files.",
            "solution": "The problem requires the computation of an estimated activation energy barrier for a single atom diffusing in a model two-dimensional potential energy surface (PES) that mimics a quinary high-entropy alloy (HEA). The procedure involves discretizing a linearly interpolated path between an initial and final configuration, evaluating the potential energy at each discrete point (image), and determining the maximum energy relative to the starting point.\n\nFirst, we define the mathematical and physical framework. The position of the migrating atom is a two-dimensional vector $\\mathbf{r} = (x, y)$. The potential energy surface, $V(\\mathbf{r})$, is given by the function:\n$$\nV(\\mathbf{r})=\\sum_{j=1}^{5}A_j\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{c}_j\\|^2}{2\\sigma_j^2}\\right)\n+B\\cos\\!\\left(2\\pi\\,\\mathbf{q}\\cdot\\mathbf{r}\\right)\n+C\\sum_{m=1}^{2}\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{s}_m\\|^2}{2\\lambda^2}\\right)\n$$\nThis function is a superposition of three terms:\n$1$. A sum of five Gaussian functions representing attractive potential wells centered at positions $\\mathbf{c}_j$ with varying depths $A_j$. These model chemically distinct atomic sites in the HEA.\n$2$. A sinusoidal term representing a mesoscale strain field, with amplitude $B$ and wavevector $\\mathbf{q}$.\n$3$. A sum of two Gaussian functions representing repulsive potential barriers, with amplitude $C$ and centered at positions $\\mathbf{s}_m$. These model obstacles or energetically unfavorable sites.\n\nThe diffusion path is approximated by a straight line between the initial configuration $\\mathbf{r}_0$ and the final configuration $\\mathbf{r}_1$. This continuous path, parameterized by $t \\in [0, 1]$, is $\\mathbf{r}(t) = \\mathbf{r}_0 + t(\\mathbf{r}_1 - \\mathbf{r}_0)$. We discretize this path into a set of $N$ images, $\\mathbf{r}_i$, for $i = 0, 1, \\dots, N-1$. The position of the $i$-th image is given by:\n$$\n\\mathbf{r}_i = \\mathbf{r}_0 + \\frac{i}{N-1}(\\mathbf{r}_1 - \\mathbf{r}_0) \\quad \\text{for } N \\ge 2\n$$\nThe problem specifies the endpoints as $\\mathbf{r}_0 = \\mathbf{c}_1 = (0.0, 0.0)$ and $\\mathbf{r}_1 = \\mathbf{c}_2 = (1.0, 0.0)$. This simplifies the image positions to $\\mathbf{r}_i = (\\frac{i}{N-1}, 0)$.\n\nThe estimated activation barrier, $E^\\ddagger$, is defined as the difference between the maximum potential energy found along the discretized path and the potential energy of the initial state:\n$$\nE^\\ddagger = \\max_{i=0, \\dots, N-1} V(\\mathbf{r}_i) - V(\\mathbf{r}_0)\n$$\n\nThe computational procedure for each test case $(N, B, C)$ is as follows:\n$1$. The fixed parameters are defined: attractive well centers $\\mathbf{c}_j$, depths $A_j$, and width $\\sigma$; repulsive obstacle centers $\\mathbf{s}_m$ and width $\\lambda$; and strain field wavevector $\\mathbf{q}$. The endpoints are $\\mathbf{r}_0 = (0.0, 0.0)$ and $\\mathbf{r}_1 = (1.0, 0.0)$.\n$2$. A set of $N$ image coordinates, $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$, is generated along the straight line connecting $\\mathbf{r}_0$ and $\\mathbf{r}_1$.\n$3$. The potential energy $V(\\mathbf{r}_i)$ is calculated for each image $\\mathbf{r}_i$ using the given values of $B$ and $C$.\n$4$. The energy of the initial state, $V_0 = V(\\mathbf{r}_0)$, is identified from the computed energies (it is the energy of the first image, $V(\\mathbf{r}_i)$ where $i=0$).\n$5$. The maximum energy in the set of computed energies, $V_{\\text{max}} = \\max_{i} V(\\mathbf{r}_i)$, is found.\n$6$. The activation barrier is calculated as $E^\\ddagger = V_{\\text{max}} - V_0$.\n\nA crucial aspect of this problem is to understand the limitations of using a simple linear interpolation for the reaction path, particularly in complex systems like HEAs. The true diffusion path for a thermally activated process follows the Minimum Energy Path (MEP) on the potential energy surface. The MEP is a path connecting two local minima (like $\\mathbf{r}_0$ and $\\mathbf{r}_1$) such that the energy is a maximum in the direction along the path at the saddle point, and a minimum in all directions perpendicular to the path. The highest point on the MEP defines the true saddle point energy, and its difference from the initial state energy gives the true activation barrier.\n\nThe linearly interpolated path is merely a guess and is highly unlikely to be the true MEP. On a \"rugged\" PES, which is characteristic of HEAs due to severe lattice distortion and chemical complexity, a straight-line path will likely pass through regions of much higher energy than the true MEP, which would naturally curve to avoid such obstacles. Consequently, the activation barrier calculated from a linear path, $E^\\ddagger$, is almost always an overestimation of the true physical activation barrier. Methods like the Nudged Elastic Band (NEB) are designed to overcome this issue. NEB starts with an initial path (often a linear interpolation) and iteratively relaxes the images, moving them \"downhill\" on the PES in directions perpendicular to the path, until the set of images converges onto the MEP. The procedure in this problem is equivalent to the very first step of a NEB calculation (evaluating the initial guess) without any subsequent relaxation. The density of images, $N$, affects the resolution of the energy profile along the fixed linear path. A very low $N$ (e.g., $N=2$) might miss the peak energy along this path, leading to an underestimation of the barrier *for that specific path*. A higher $N$ gives a more accurate value for the barrier along the linear path, but it does not correct the fundamental deficiency of the path itself.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the estimated activation barrier for a single migrating atom\n    in a model quinary high-entropy alloy (HEA) supercell for several\n    parameter sets.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    # Gaussian well centers (species sites, in nanometers)\n    C_CENTERS = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.5, 0.8], [-0.6, 0.4], [1.2, -0.7]\n    ])\n    # Well depths (in electronvolts)\n    A_DEPTHS = np.array([-0.20, -0.18, -0.16, -0.14, -0.12])\n    # Gaussian width (in nanometers)\n    SIGMA = 0.15\n    \n    # Repulsive obstacle centers (in nanometers)\n    S_CENTERS = np.array([[0.5, 0.0], [0.6, 0.2]])\n    # Repulsive obstacle width (in nanometers)\n    LAMBDA = 0.10\n    \n    # Strain field wavevector (in inverse nanometers)\n    Q_VEC = np.array([1.5, 0.7])\n    \n    # Endpoints (in nanometers)\n    R0 = C_CENTERS[0]\n    R1 = C_CENTERS[1]\n\n    def potential_energy(r, B, C):\n        \"\"\"\n        Calculates the potential energy V(r) for a given position r and\n        parameters B and C.\n        \n        Args:\n            r (np.ndarray): 2D position vector [x, y].\n            B (float): Amplitude of the strain field term.\n            C (float): Amplitude of the repulsive obstacle term.\n            \n        Returns:\n            float: The potential energy in eV.\n        \"\"\"\n        # 1. Sum of attractive Gaussian wells\n        term1 = 0.0\n        for j in range(len(C_CENTERS)):\n            norm_sq = np.linalg.norm(r - C_CENTERS[j])**2\n            term1 += A_DEPTHS[j] * np.exp(-norm_sq / (2 * SIGMA**2))\n            \n        # 2. Strain field term\n        term2 = B * np.cos(2 * np.pi * np.dot(Q_VEC, r))\n        \n        # 3. Sum of repulsive Gaussian obstacles\n        term3 = 0.0\n        for m in range(len(S_CENTERS)):\n            norm_sq = np.linalg.norm(r - S_CENTERS[m])**2\n            term3 += C * np.exp(-norm_sq / (2 * LAMBDA**2))\n            \n        return term1 + term2 + term3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, B, C)\n        (11, 0.05, 0.25),\n        (2, 0.05, 0.25),\n        (51, 0.10, 0.35),\n        (21, 0.00, 0.00),\n    ]\n\n    results = []\n    for N, B, C in test_cases:\n        # Generate the N linearly interpolated image positions\n        # The path is from (0,0) to (1,0), so it's along the x-axis.\n        if N  2:\n            # For N=1, the path is just the starting point. Barrier is 0.\n            # This case is not in the test suite but handled for robustness.\n            results.append(0.0)\n            continue\n            \n        x_coords = np.linspace(R0[0], R1[0], N)\n        y_coords = np.linspace(R0[1], R1[1], N)\n        path_images = np.stack((x_coords, y_coords), axis=-1)\n        \n        # Evaluate V(r_i) for all images i\n        energies = np.array([potential_energy(r, B, C) for r in path_images])\n        \n        # Initial energy V(r_0)\n        v0 = energies[0]\n        \n        # Maximum energy along the path\n        v_max = np.max(energies)\n        \n        # Compute the barrier E_dagger = max(V(r_i)) - V(r_0)\n        barrier = v_max - v0\n        results.append(barrier)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established that a simple linear path is often a poor approximation of the true reaction coordinate, we now focus on the mechanism NEB uses to refine this path. The genius of the method lies in its unique force decomposition, which separates the force relaxing the path towards the Minimum Energy Path (MEP) from the artificial spring forces that maintain image spacing. In this practice , you will dissect this mechanism by calculating the tangent vector $\\hat{\\boldsymbol{\\tau}}_i$, the perpendicular component of the true force $\\mathbf{F}_i^{\\perp}$, and the parallel spring force $\\mathbf{F}_i^{\\parallel, \\text{spring}}$, which collectively guide the images toward their final, optimized positions.",
            "id": "3752868",
            "problem": "You are given a set of discrete images representing atomic configurations along a candidate reaction pathway in a simplified high-entropy alloy environment. The goal is to compute the tangent unit vector, the force decomposition, and the Nudged Elastic Band (NEB) force for each interior image, and to verify the orthogonality of the perpendicular true-force component to the tangent at each interior image. Use the following fundamental bases and definitions.\n\nLet the path be a sequence of images with positions $\\mathbf{R}_i \\in \\mathbb{R}^3$ and energies $E_i = V(\\mathbf{R}_i)$ for $i = 0, 1, \\dots, N-1$. The potential energy function $V(\\mathbf{R})$ is defined as a sum of Gaussian terms, a periodic cosine term, and a quartic term:\n$$\nV(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right) + A\\left(\\cos(\\beta_x x) + \\cos(\\beta_y y) + \\cos(\\beta_z z)\\right) + B \\left(\\|\\mathbf{R}\\|^2\\right)^2,\n$$\nwhere $\\mathbf{R} = (x,y,z)$, $w_m$ are Gaussian weights, $\\sigma_m$ are Gaussian widths, and $\\mathbf{C}_m$ are Gaussian centers. The gradient $\\nabla V(\\mathbf{R})$ is obtained by differentiating each term:\n$$\n\\nabla V(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right)\\left(-\\frac{2}{\\sigma_m^2}\\right)(\\mathbf{R} - \\mathbf{C}_m) \n- A \\begin{bmatrix} \\beta_x \\sin(\\beta_x x) \\\\ \\beta_y \\sin(\\beta_y y) \\\\ \\beta_z \\sin(\\beta_z z)\\end{bmatrix}\n+ 4 B (\\|\\mathbf{R}\\|^2)\\mathbf{R}.\n$$\n\nFor each interior image $i$ with $1 \\leq i \\leq N-2$, define forward and backward displacements $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ and $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$. Let the tangent vector $\\hat{\\tau}_i$ be chosen using an energy-based selection rule to avoid kinks. Use the following improved but simple selection:\n- If $E_{i+1}  E_i  E_{i-1}$, set $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$.\n- Else if $E_{i+1}  E_i  E_{i-1}$, set $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$.\n- Else if $E_{i+1}  E_{i-1}$, set $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$.\n- Else if $E_{i+1}  E_{i-1}$, set $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$.\n- Else, set $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^-$.\n\nThen normalize to obtain the unit tangent $\\hat{\\tau}_i = \\mathbf{\\tau}_i / \\|\\mathbf{\\tau}_i\\|$.\n\nLet the true force be $\\mathbf{F}_i^{\\text{true}} = -\\nabla V(\\mathbf{R}_i)$. Compute its perpendicular component to the path tangent,\n$$\n\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\text{true}} - \\left(\\mathbf{F}_i^{\\text{true}} \\cdot \\hat{\\tau}_i\\right)\\hat{\\tau}_i,\n$$\nand the elastic spring force projected along the tangent,\n$$\n\\mathbf{F}_i^{\\parallel, \\text{spring}} = k\\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right)\\hat{\\tau}_i,\n$$\nwhere $k$ is a given dimensionless spring constant. The Nudged Elastic Band (NEB) force for interior images is\n$$\n\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\parallel, \\text{spring}}.\n$$\n\nVerification of orthogonality requires checking that the perpendicular component is orthogonal to the tangent, i.e., $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i = 0$ within a given numerical tolerance. Compute the maximum absolute value of $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i$ across interior images for each test case, and report whether all interior images satisfy $|\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i| \\leq \\varepsilon$ for a specified tolerance $\\varepsilon$.\n\nAll quantities are dimensionless. Report floating-point outputs to full precision; no rounding is required. Angles are in radians implicitly through the trigonometric functions. No physical units are involved.\n\nImplement the above for the following test suite of three cases. For each case, the energies $E_i$ must be computed from the provided potential $V(\\mathbf{R}_i)$ and used in the tangent selection rule.\n\nTest Case $1$:\n- Images ($N = 7$):\n  - $\\mathbf{R}_0 = (-1.0, 0.2, 0.0)$,\n  - $\\mathbf{R}_1 = (-0.6666666667, 0.1333333333, 0.0)$,\n  - $\\mathbf{R}_2 = (-0.3333333333, 0.0666666667, 0.0)$,\n  - $\\mathbf{R}_3 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (0.3333333333, -0.0666666667, 0.0)$,\n  - $\\mathbf{R}_5 = (0.6666666667, -0.1333333333, 0.0)$,\n  - $\\mathbf{R}_6 = (1.0, -0.2, 0.0)$.\n- Potential parameters:\n  - Gaussian terms ($M = 3$):\n    - $w_1 = 1.20$, $\\sigma_1 = 0.40$, $\\mathbf{C}_1 = (0.30, 0.00, 0.00)$,\n    - $w_2 = 0.80$, $\\sigma_2 = 0.35$, $\\mathbf{C}_2 = (-0.50, 0.20, 0.00)$,\n    - $w_3 = -0.60$, $\\sigma_3 = 0.45$, $\\mathbf{C}_3 = (0.00, -0.30, 0.00)$.\n  - Periodic term: $A = 0.15$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - Quartic term: $B = 0.02$.\n- Spring constant: $k = 0.50$.\n- Orthogonality tolerance: $\\varepsilon = 1\\times 10^{-10}$.\n\nTest Case $2$:\n- Images ($N = 6$):\n  - $\\mathbf{R}_0 = (-0.8, -0.2, 0.1)$,\n  - $\\mathbf{R}_1 = (-0.5, 0.05, 0.1)$,\n  - $\\mathbf{R}_2 = (-0.2, 0.3, 0.1)$,\n  - $\\mathbf{R}_3 = (0.1, 0.15, 0.1)$,\n  - $\\mathbf{R}_4 = (0.4, -0.05, 0.1)$,\n  - $\\mathbf{R}_5 = (0.7, -0.25, 0.1)$.\n- Potential parameters (same as Case $1$):\n  - Gaussian terms ($M = 3$):\n    - $w_1 = 1.20$, $\\sigma_1 = 0.40$, $\\mathbf{C}_1 = (0.30, 0.00, 0.00)$,\n    - $w_2 = 0.80$, $\\sigma_2 = 0.35$, $\\mathbf{C}_2 = (-0.50, 0.20, 0.00)$,\n    - $w_3 = -0.60$, $\\sigma_3 = 0.45$, $\\mathbf{C}_3 = (0.00, -0.30, 0.00)$.\n  - Periodic term: $A = 0.15$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - Quartic term: $B = 0.02$.\n- Spring constant: $k = 0.80$.\n- Orthogonality tolerance: $\\varepsilon = 1\\times 10^{-10}$.\n\nTest Case $3$:\n- Images ($N = 5$):\n  - $\\mathbf{R}_0 = (-0.5, 0.0, 0.0)$,\n  - $\\mathbf{R}_1 = (-0.25, 0.0, 0.0)$,\n  - $\\mathbf{R}_2 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_3 = (0.25, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (0.5, 0.0, 0.0)$.\n- Potential parameters (flattened landscape to probe degeneracy):\n  - Gaussian terms ($M = 3$):\n    - $w_1 = 0.40$, $\\sigma_1 = 0.90$, $\\mathbf{C}_1 = (0.00, 0.00, 0.00)$,\n    - $w_2 = 0.30$, $\\sigma_2 = 0.90$, $\\mathbf{C}_2 = (0.30, 0.00, 0.00)$,\n    - $w_3 = 0.20$, $\\sigma_3 = 1.00$, $\\mathbf{C}_3 = (-0.30, 0.00, 0.00)$.\n  - Periodic term: $A = 0.00$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - Quartic term: $B = 0.01$.\n- Spring constant: $k = 0.30$.\n- Orthogonality tolerance: $\\varepsilon = 1\\times 10^{-12}$.\n\nYour program should compute, for each test case, the following three quantities across all interior images:\n- The maximum absolute dot product $m = \\max_{i} \\left| \\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i \\right|$.\n- The orthogonality flag $b$, defined as $b = 1$ if $\\left| \\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i \\right| \\leq \\varepsilon$ holds for all interior images $i$, and $b = 0$ otherwise.\n- The maximum Euclidean norm $n = \\max_{i} \\left\\| \\mathbf{F}_i^{\\text{NEB}} \\right\\|$.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list of lists, one sublist per test case in the order defined above. Each sublist must be of the form $[m,b,n]$, where $m$ and $n$ are floating-point values and $b$ is an integer. For example, an output might look like $[[0.0,1,0.5],[0.0,1,0.8],[0.0,1,0.3]]$ but with the actual computed values for the given data.",
            "solution": "The problem requires the computation of key vectors and forces used in the Nudged Elastic Band (NEB) method for a given set of atomic configurations (images) on a predefined potential energy surface (PES). The solution involves a step-by-step calculation for each interior image of the path.\n\n**Step 1: Potential Energy and True Force Calculation**\nFirst, for each image $\\mathbf{R}_i$ in the given path, we must calculate its potential energy $E_i = V(\\mathbf{R}_i)$ using the provided formula for the PES. This is necessary for the energy-based tangent selection rule. For each interior image (i.e., not the endpoints), we also calculate the \"true\" force, which is the negative gradient of the potential, $\\mathbf{F}_i^{\\text{true}} = -\\nabla V(\\mathbf{R}_i)$. The analytical expression for $\\nabla V(\\mathbf{R})$ is provided.\n\n**Step 2: Path Tangent Determination**\nThe tangent vector $\\hat{\\tau}_i$ defines the local orientation of the path at image $i$. A robust tangent is crucial for the stability of the NEB method. The problem specifies an energy-weighted scheme:\n- The forward and backward displacement vectors are calculated: $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ and $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$.\n- Based on the relative energies of the current image and its neighbors ($E_{i-1}$, $E_i$, $E_{i+1}$), an unnormalized tangent $\\mathbf{\\tau}_i$ is selected from $\\Delta \\mathbf{R}_i^+$, $\\Delta \\mathbf{R}_i^-$, or their sum. This ensures the tangent points \"uphill\" and avoids kinks.\n- The final unit tangent $\\hat{\\tau}_i$ is obtained by normalizing $\\mathbf{\\tau}_i$.\n\n**Step 3: Force Decomposition and NEB Force Assembly**\nThis step is the core of the NEB method. The total NEB force is a sum of two specially projected components:\n1.  **Perpendicular True Force ($\\mathbf{F}_i^{\\perp}$):** This component drives the image toward the Minimum Energy Path (MEP). It is calculated by taking the true force $\\mathbf{F}_i^{\\text{true}}$ and removing its projection along the path tangent:\n    $$\n    \\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\text{true}} - (\\mathbf{F}_i^{\\text{true}} \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i\n    $$\n    By construction, this vector is orthogonal to $\\hat{\\tau}_i$.\n2.  **Parallel Spring Force ($\\mathbf{F}_i^{\\parallel, \\text{spring}}$):** This is an artificial force that ensures images remain evenly distributed along the path. It is defined as:\n    $$\n    \\mathbf{F}_i^{\\parallel, \\text{spring}} = k\\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right)\\hat{\\tau}_i\n    $$\n    This force acts only along the tangent and is proportional to the difference in length of the adjacent path segments.\n\nThe total NEB force on the image is the sum of these two components: $\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\parallel, \\text{spring}}$.\n\n**Step 4: Verification and Aggregation of Results**\nThe algorithm is executed for each interior image $i \\in \\{1, \\dots, N-2\\}$. The results are then aggregated for each test case:\n-   **Orthogonality Check ($m$ and $b$):** We compute the dot product $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i$. The maximum absolute value of this dot product across all interior images is reported as $m$. This value should be near machine precision. The boolean flag $b$ is set to 1 if this dot product is less than or equal to the tolerance $\\varepsilon$ for all images, and 0 otherwise.\n-   **Maximum NEB Force ($n$):** We compute the Euclidean norm of the total NEB force, $\\|\\mathbf{F}_i^{\\text{NEB}}\\|$, for each interior image. The maximum of these norms is reported as $n$. This value is a common convergence criterion in a real NEB calculation.\n\nThe implementation will apply these steps to each of the three test cases, collecting the three aggregate metrics ($m, b, n$) for the final output.",
            "answer": "```python\nimport numpy as np\n\ndef get_potential_and_gradient(potential_params):\n    \"\"\"\n    Factory function to create potential energy and gradient functions\n    based on the given parameters.\n    \"\"\"\n    gaussians = potential_params['gaussians']\n    A = potential_params['A']\n    betas = np.array(potential_params['betas'])\n    B = potential_params['B']\n\n    def V(R):\n        \"\"\"Computes the potential energy V at a given position R.\"\"\"\n        R = np.array(R)\n        # Gaussian terms\n        gauss_sum = 0.0\n        for w, sigma, C in gaussians:\n            C = np.array(C)\n            norm_sq = np.sum((R - C)**2)\n            gauss_sum += w * np.exp(-norm_sq / (sigma**2))\n        \n        # Periodic term\n        periodic_sum = A * np.sum(np.cos(betas * R))\n        \n        # Quartic term\n        quartic_term = B * (np.sum(R**2))**2\n        \n        return gauss_sum + periodic_sum + quartic_term\n\n    def grad_V(R):\n        \"\"\"Computes the gradient of the potential V at a given position R.\"\"\"\n        R = np.array(R)\n        grad = np.zeros(3, dtype=float)\n        \n        # Gaussian terms\n        for w, sigma, C in gaussians:\n            C = np.array(C)\n            norm_sq = np.sum((R - C)**2)\n            grad += w * np.exp(-norm_sq / (sigma**2)) * (-2.0 / (sigma**2)) * (R - C)\n        \n        # Periodic term\n        grad -= A * betas * np.sin(betas * R)\n        \n        # Quartic term\n        grad += 4.0 * B * np.sum(R**2) * R\n        \n        return grad\n        \n    return V, grad_V\n\ndef solve():\n    \"\"\"\n    Main function to run the NEB calculations for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"images\": [\n                (-1.0, 0.2, 0.0), (-0.6666666667, 0.1333333333, 0.0),\n                (-0.3333333333, 0.0666666667, 0.0), (0.0, 0.0, 0.0),\n                (0.3333333333, -0.0666666667, 0.0), (0.6666666667, -0.1333333333, 0.0),\n                (1.0, -0.2, 0.0)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (1.20, 0.40, (0.30, 0.00, 0.00)),\n                    (0.80, 0.35, (-0.50, 0.20, 0.00)),\n                    (-0.60, 0.45, (0.00, -0.30, 0.00))\n                ],\n                \"A\": 0.15, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.02\n            },\n            \"k\": 0.50,\n            \"epsilon\": 1e-10\n        },\n        # Test Case 2\n        {\n            \"images\": [\n                (-0.8, -0.2, 0.1), (-0.5, 0.05, 0.1), (-0.2, 0.3, 0.1),\n                (0.1, 0.15, 0.1), (0.4, -0.05, 0.1), (0.7, -0.25, 0.1)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (1.20, 0.40, (0.30, 0.00, 0.00)),\n                    (0.80, 0.35, (-0.50, 0.20, 0.00)),\n                    (-0.60, 0.45, (0.00, -0.30, 0.00))\n                ],\n                \"A\": 0.15, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.02\n            },\n            \"k\": 0.80,\n            \"epsilon\": 1e-10\n        },\n        # Test Case 3\n        {\n            \"images\": [\n                (-0.5, 0.0, 0.0), (-0.25, 0.0, 0.0), (0.0, 0.0, 0.0),\n                (0.25, 0.0, 0.0), (0.5, 0.0, 0.0)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (0.40, 0.90, (0.00, 0.00, 0.00)),\n                    (0.30, 0.90, (0.30, 0.00, 0.00)),\n                    (0.20, 1.00, (-0.30, 0.00, 0.00))\n                ],\n                \"A\": 0.00, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.01\n            },\n            \"k\": 0.30,\n            \"epsilon\": 1e-12\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        images_R = [np.array(r) for r in case[\"images\"]]\n        N = len(images_R)\n        V, grad_V = get_potential_and_gradient(case[\"potential_params\"])\n        k = case[\"k\"]\n        epsilon = case[\"epsilon\"]\n        \n        energies_E = [V(R) for R in images_R]\n        \n        max_abs_dot_product = 0.0\n        max_neb_force_norm = 0.0\n        \n        dot_products_below_eps = True\n        \n        for i in range(1, N - 1):\n            R_i = images_R[i]\n            R_i_minus_1 = images_R[i-1]\n            R_i_plus_1 = images_R[i+1]\n            \n            E_i = energies_E[i]\n            E_i_minus_1 = energies_E[i-1]\n            E_i_plus_1 = energies_E[i+1]\n            \n            delta_R_plus = R_i_plus_1 - R_i\n            delta_R_minus = R_i - R_i_minus_1\n            \n            # Tangent selection\n            tau_i = None\n            if E_i_plus_1 > E_i and E_i > E_i_minus_1:\n                tau_i = delta_R_plus\n            elif E_i_plus_1  E_i and E_i  E_i_minus_1:\n                tau_i = delta_R_minus\n            else:\n                if E_i_plus_1 > E_i_minus_1:\n                    tau_i = delta_R_plus\n                elif E_i_plus_1  E_i_minus_1:\n                    tau_i = delta_R_minus\n                else: # E_i_plus_1 == E_i_minus_1\n                    tau_i = delta_R_plus + delta_R_minus\n            \n            # Normalize tangent\n            tau_i_norm = np.linalg.norm(tau_i)\n            tau_hat_i = tau_i / tau_i_norm if tau_i_norm > 1e-15 else np.zeros(3)\n\n            # True force\n            F_i_true = -grad_V(R_i)\n            \n            # Perpendicular component of true force\n            F_i_perp = F_i_true - np.dot(F_i_true, tau_hat_i) * tau_hat_i\n            \n            # Parallel spring force\n            norm_delta_R_plus = np.linalg.norm(delta_R_plus)\n            norm_delta_R_minus = np.linalg.norm(delta_R_minus)\n            F_i_spring_parallel = k * (norm_delta_R_plus - norm_delta_R_minus) * tau_hat_i\n            \n            # NEB force\n            F_i_NEB = F_i_perp + F_i_spring_parallel\n            \n            # Metric 1: Orthogonality check\n            dot_product = np.dot(F_i_perp, tau_hat_i)\n            max_abs_dot_product = max(max_abs_dot_product, abs(dot_product))\n            \n            if abs(dot_product) > epsilon:\n                dot_products_below_eps = False\n                \n            # Metric 3: Max NEB force norm\n            neb_force_norm = np.linalg.norm(F_i_NEB)\n            max_neb_force_norm = max(max_neb_force_norm, neb_force_norm)\n                \n        b = 1 if dot_products_below_eps else 0\n        m = max_abs_dot_product\n        n = max_neb_force_norm\n        \n        all_results.append([m, b, n])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "While the standard NEB method is effective at finding the overall MEP, the presence of spring forces can prevent any single image from settling exactly at the saddle point, which is the highest point on the path. The Climbing Image NEB (CI-NEB) is an essential refinement that solves this problem by modifying the force on the highest-energy image. This exercise  guides you through implementing the force for the \"climbing image,\" which is inverted along the path tangent to drive it uphill to the true transition state, while still relaxing downhill perpendicular to the path, thus ensuring a precise and reliable calculation of the activation barrier.",
            "id": "3752891",
            "problem": "Consider a two-dimensional potential energy surface intended to emulate a disordered landscape common in high-entropy alloys (HEA) diffusion, where reaction pathways are identified by the Nudged Elastic Band (NEB) method and refined by the Climbing Image (CI) modification. Let the potential energy be defined by a smooth scalar field $V(\\mathbf{r})$, with $\\mathbf{r} = (x,y)$, and let the force field be given by the negative gradient $-\\nabla V(\\mathbf{r})$. A discrete path is represented by a sequence of images $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$, where endpoints $i=0$ and $i=N-1$ are fixed. Assume all quantities are dimensionless (unitless).\n\nFundamental base and definitions:\n- The energy at image $i$ is $E_i = V(\\mathbf{r}_i)$ and the gradient is $\\nabla V(\\mathbf{r}_i)$.\n- The NEB path tangent at an interior image $i$ is the unit vector $\\hat{\\boldsymbol{\\tau}}_i$ aligned with the path direction at $i$, constructed from neighboring images. You must choose a mathematically consistent tangent definition using only neighboring images and robustly handle near-degenerate neighbor differences without division by zero.\n- The climbing image modification aims for the image with the largest energy among interior images to move uphill along the path tangent direction and downhill in the subspace perpendicular to the path, with no spring forces applied to that image.\n\nTask:\n1. For each test case below, identify the interior image with maximal energy and compute the updated force for that image by applying the climbing image modification consistent with the description above: it should strictly drive the image uphill along the path tangent and downhill perpendicular to the path, while removing any spring contributions at that image.\n2. Verify, using vector projections and inner products, that the computed force satisfies both:\n   - Its tangential component moves uphill (along the direction of increasing $V$ along the path).\n   - Its perpendicular component moves downhill (opposing the perpendicular component of the energy gradient).\n3. For verification, use the following quantitative checks at the maximal-energy image $i^\\star$:\n   - Let $\\hat{\\boldsymbol{\\tau}} = \\hat{\\boldsymbol{\\tau}}_{i^\\star}$, $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$, and define projections $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ and $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$. Let $\\mathbf{F}$ denote your computed climbing image force. Verify all of the following within an absolute tolerance of $\\epsilon = 10^{-8}$:\n     - The tangential component of $\\mathbf{F}$ matches uphill motion: $\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}}$ equals $+\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}$.\n     - The perpendicular component of $\\mathbf{F}$ is downhill relative to the gradient: $\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ equals $-\\mathbf{g}_{\\perp}$.\n     - The downhill condition is energetically consistent: $\\left(\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}\\right)\\cdot \\mathbf{g}_{\\perp} \\le 0$.\n   Aggregate these three checks into a single boolean by logical conjunction (true only if all three hold within tolerance).\n4. Important algorithmic requirements:\n   - For the tangent $\\hat{\\boldsymbol{\\tau}}_i$ at interior image $i$, use a finite-difference direction derived from $\\mathbf{r}_{i+1}-\\mathbf{r}_{i-1}$ and normalize it. If the norm is below a small threshold, you must robustly choose an alternate nonzero direction (for example, by preferring $\\mathbf{r}_{i}-\\mathbf{r}_{i-1}$ or $\\mathbf{r}_{i+1}-\\mathbf{r}_{i}$ with the larger norm, or as a last resort a direction related to $\\nabla V(\\mathbf{r}_i)$) and normalize it. Endpoints are not considered for climbing.\n   - All computations are unitless.\n   - Use the potential energy function and its analytic gradient defined below.\n\nPotential energy definition:\n- Let\n$$\nV(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y),\n$$\nwith constants $a = 0.15$, $b = 0.10$, $c = 0.05$, and $d = 0.03$.\n- Its gradient is\n$$\n\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big).\n$$\n\nTest suite:\nFor each case, you are given a list of image coordinates $\\{(x_i,y_i)\\}_{i=0}^{N-1}$.\n- Case $1$ (straight path across a barrier):\n  $\\{(-1.4,\\,0.0),\\; (-1.0,\\,0.0),\\; (-0.6,\\,0.0),\\; (-0.2,\\,0.0),\\; (0.2,\\,0.0),\\; (0.6,\\,0.0),\\; (1.0,\\,0.0)\\}$.\n- Case $2$ (bent path sampling anistropic gradients):\n  $\\{(-1.2,\\,-0.3),\\; (-0.8,\\,-0.15),\\; (-0.4,\\,-0.02),\\; (0.0,\\,0.06),\\; (0.4,\\,0.12),\\; (0.8,\\,0.22),\\; (1.0,\\,0.4)\\}$.\n- Case $3$ (near-degenerate neighbor differences around the maximum):\n  $\\{(-0.9,\\,0.0),\\; (-0.001,\\,0.02),\\; (0.0,\\,0.02),\\; (0.0000005,\\,0.0200001),\\; (0.9,\\,0.0)\\}$.\n\nProgram requirements:\n- Implement the analytic $V(x,y)$ and $\\nabla V(x,y)$ exactly as given.\n- For each case, identify the interior image with the largest $V$ and compute the climbing image force $\\mathbf{F}$ for that image in a manner that enforces uphill motion along $\\hat{\\boldsymbol{\\tau}}$ and downhill motion perpendicular to $\\hat{\\boldsymbol{\\tau}}$, with no spring forces on that image.\n- Perform the three verification checks described above with absolute tolerance $\\epsilon = 10^{-8}$ and produce a single boolean per case by logical conjunction.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is a boolean for the corresponding test case.",
            "solution": "The problem requires the calculation and verification of the climbing image force for a Nudged Elastic Band (NEB) simulation on a given two-dimensional potential energy surface $V(x,y)$. The climbing image (CI) modification is a standard technique used to converge an NEB path to a minimal energy path (MEP) where the image with the highest energy converges to a first-order saddle point (a transition state).\n\nThe core of the problem lies in correctly interpreting the definition of the climbing image force from the provided description and verification criteria. A regular NEB image is subject to two forces: a spring force parallel to the path tangent, $\\mathbf{F}_{s, \\parallel}$, which ensures even spacing of images, and the perpendicular component of the true potential force, $\\mathbf{F}_{\\text{pot}, \\perp}$, which minimizes energy perpendicular to the path. The potential force is the negative gradient of the potential energy, $\\mathbf{F}_{\\text{pot}} = -\\nabla V$.\n\nThe climbing image, designated as $\\mathbf{r}_{i^\\star}$ (the interior image with the highest energy), is treated differently. The problem states that spring forces are removed. It is driven \"uphill\" along the path tangent and \"downhill\" perpendicular to it. Let $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$ be the gradient of the potential at the climbing image, and let $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ be the unit tangent vector to the path at that image. The terms \"uphill\" and \"downhill\" refer to the direction of increasing and decreasing potential energy, respectively. The direction of steepest ascent is given by $\\mathbf{g}$.\n\nThe force on the climbing image, $\\mathbf{F}_{\\text{CI}}$, is defined by its components parallel and perpendicular to the tangent $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$:\n$\\mathbf{F}_{\\text{CI}} = \\mathbf{F}_{\\parallel} + \\mathbf{F}_{\\perp}$.\n\nThe problem's verification criteria specify these components:\n1.  The tangential component of force moves the image \"uphill\". The check is specified as $\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}$. This implies that the parallel component of the force is equal to the parallel component of the gradient: $\\mathbf{F}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}_{\\parallel}$. This force component pushes the image along the tangent in the direction of increasing potential along that tangent, hence \"climbing\" the energy barrier.\n\n2.  The perpendicular component of force moves the image \"downhill\". The check is $\\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = -\\mathbf{g}_{\\perp}$. This means the perpendicular component of the force is the negative of the perpendicular component of the gradient: $\\mathbf{F}_{\\perp} = -\\mathbf{g}_{\\perp}$. This force component acts to minimize the potential energy in the hyperplane perpendicular to the path, relaxing the image onto the MEP.\n\nCombining these components, the climbing image force is:\n$$\n\\mathbf{F}_{\\text{CI}} = \\mathbf{g}_{\\parallel} - \\mathbf{g}_{\\perp}\n$$\nwhere $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ and $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$. This formulation is equivalent to the standard definition of the inverted-gradient CI force, $\\mathbf{F}_{\\text{CI}} = -\\mathbf{g} + 2\\mathbf{g}_{\\parallel}$.\n\nThe algorithm to solve the problem for each test case is as follows:\n1.  Given a path $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$, identify the interior images, which are $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$.\n2.  Calculate the potential energy $E_i = V(\\mathbf{r}_i)$ for each interior image. Find the index $i^\\star$ corresponding to the image with the maximum energy.\n3.  Determine the tangent vector $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ at the climbing image $\\mathbf{r}_{i^\\star}$. The primary definition is the normalized vector between its neighbors: $\\mathbf{t} = \\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star-1}$. A robustness check is required for cases where $\\|\\mathbf{t}\\|$ is close to zero. The specified fallback is to use the normalized vector of either $\\mathbf{r}_{i^\\star} - \\mathbf{r}_{i^\\star-1}$ or $\\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star}$, whichever has a larger magnitude.\n4.  Calculate the gradient vector $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$.\n5.  Compute the climbing image force $\\mathbf{F}_{\\text{CI}} = (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} - (\\mathbf{g} - (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star})$.\n6.  Perform the three verification checks with a tolerance $\\epsilon=10^{-8}$:\n    a. Check 1: $|\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} - \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}|  \\epsilon$.\n    b. Check 2: $\\|\\mathbf{F}_{\\perp} - (-\\mathbf{g}_{\\perp})\\|  \\epsilon$, where $\\mathbf{F}_{\\perp} = \\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ and $\\mathbf{g}_{\\perp} = \\mathbf{g} - (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$.\n    c. Check 3: $\\mathbf{F}_{\\perp} \\cdot \\mathbf{g}_{\\perp} \\le 0$. This should hold true if the previous check passes, as it becomes $-(\\mathbf{g}_{\\perp}\\cdot\\mathbf{g}_{\\perp}) = -\\|\\mathbf{g}_{\\perp}\\|^2 \\le 0$.\n7.  The final result for the test case is `True` if and only if all three checks pass.\n\nThe implementation will use the provided analytical expressions for the potential $V(x,y)$ and its gradient $\\nabla V(x,y)$:\n$V(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y)$\n$\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big)$\nwith $a = 0.15$, $b = 0.10$, $c = 0.05$, and $d = 0.03$. Numerical vector operations from the `numpy` library are used for calculations.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the climbing image force verification problem for three test cases.\n    \"\"\"\n\n    # Constants for the potential energy function\n    a = 0.15\n    b = 0.10\n    c = 0.05\n    d = 0.03\n\n    def potential(r):\n        \"\"\"Calculates the potential energy V(x,y) at a given point r = [x, y].\"\"\"\n        x, y = r\n        term1 = (x**2 - 1)**2\n        term2 = a * y**2\n        term3 = b * np.sin(3 * x) * np.cos(2 * y)\n        term4 = c * x\n        term5 = d * np.sin(5 * y)\n        return term1 + term2 + term3 + term4 + term5\n\n    def gradient(r):\n        \"\"\"Calculates the gradient of the potential energy grad V(x,y) at a point r = [x, y].\"\"\"\n        x, y = r\n        grad_x = 4 * x * (x**2 - 1) + 3 * b * np.cos(3 * x) * np.cos(2 * y) + c\n        grad_y = 2 * a * y - 2 * b * np.sin(3 * x) * np.sin(2 * y) + 5 * d * np.cos(5 * y)\n        return np.array([grad_x, grad_y])\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        # Case 1: straight path across a barrier\n        [(-1.4, 0.0), (-1.0, 0.0), (-0.6, 0.0), (-0.2, 0.0), (0.2, 0.0), (0.6, 0.0), (1.0, 0.0)],\n        # Case 2: bent path sampling anistropic gradients\n        [(-1.2, -0.3), (-0.8, -0.15), (-0.4, -0.02), (0.0, 0.06), (0.4, 0.12), (0.8, 0.22), (1.0, 0.4)],\n        # Case 3: near-degenerate neighbor differences around the maximum\n        [(-0.9, 0.0), (-0.001, 0.02), (0.0, 0.02), (0.0000005, 0.0200001), (0.9, 0.0)],\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        path = np.array(case)\n        num_images = len(path)\n        \n        # Interior images are from index 1 to N-2\n        interior_indices = range(1, num_images - 1)\n        interior_images = path[1:num_images - 1]\n        \n        # 1. Find the interior image with the maximal energy\n        energies = [potential(r) for r in interior_images]\n        # Get the global index of the max energy image\n        i_star = np.argmax(energies) + 1 \n        r_istar = path[i_star]\n\n        # 2. Compute the tangent vector at the climbing image\n        r_prev = path[i_star - 1]\n        r_next = path[i_star + 1]\n        \n        # Primary tangent definition\n        t = r_next - r_prev\n        norm_t = np.linalg.norm(t)\n        \n        tangent_threshold = 1e-9\n        if norm_t  tangent_threshold:\n            # Fallback tangent definition\n            t1 = r_istar - r_prev\n            t2 = r_next - r_istar\n            if np.linalg.norm(t1) > np.linalg.norm(t2):\n                t_alt = t1\n            else:\n                t_alt = t2\n            \n            norm_t_alt = np.linalg.norm(t_alt)\n            # The problem provides no case where second fallback is needed.\n            if norm_t_alt  tangent_threshold:\n                 # This path shouldn't be taken with the given test cases.\n                 # Fallback to gradient if all else fails, normalized.\n                 g_temp = gradient(r_istar)\n                 tau_hat = g_temp / np.linalg.norm(g_temp)\n            else:\n                 tau_hat = t_alt / norm_t_alt\n        else:\n            tau_hat = t / norm_t\n\n        # 3. Compute climbing image force from its components\n        g = gradient(r_istar)\n        g_dot_tau = np.dot(g, tau_hat)\n        \n        g_parallel = g_dot_tau * tau_hat\n        g_perp = g - g_parallel\n        \n        # Force is defined as F_CI = g_parallel - g_perp\n        F = g_parallel - g_perp\n        \n        # 4. Perform verification checks\n        epsilon = 1e-8\n\n        # Check 1: F_parallel component matches g_parallel component\n        F_dot_tau = np.dot(F, tau_hat)\n        check1 = abs(F_dot_tau - g_dot_tau)  epsilon\n        \n        # Check 2: F_perp component equals -g_perp\n        F_perp = F - F_dot_tau * tau_hat\n        check2 = np.linalg.norm(F_perp - (-g_perp))  epsilon\n\n        # Check 3: F_perp is energetically downhill with respect to g_perp\n        # This will be = 0 if check2 is met, due to F_perp ≈ -g_perp\n        dot_product_perp = np.dot(F_perp, g_perp)\n        check3 = dot_product_perp = 0.0 # Strict check as per definition\n\n        # Aggregate results\n        final_check = check1 and check2 and check3\n        results.append(final_check)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```"
        }
    ]
}