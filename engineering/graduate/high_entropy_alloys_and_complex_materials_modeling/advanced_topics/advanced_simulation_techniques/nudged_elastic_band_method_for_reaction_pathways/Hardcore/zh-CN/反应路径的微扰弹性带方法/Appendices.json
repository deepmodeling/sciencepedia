{
    "hands_on_practices": [
        {
            "introduction": "在深入研究完整的“微动弹性带”算法之前，理解为什么简单方法通常不够用是至关重要的。第一个练习  要求你沿着一条简单的线性插值路径（这是反应路径的常见初始猜测）来评估能垒。通过实现这一过程，你将直接观察到这样一条路径在复杂的“崎岖”势能面上会如何严重高估真实的能垒，从而凸显了路径优化的必要性。",
            "id": "3752897",
            "problem": "考虑一个五元高熵合金（HEA）超晶胞中单个迁移原子的二元扩散事件。目标是通过第一性原理和算法构建，评估沿猜测路径的势能剖面的离散化估计，并使用端点之间的线性插值来量化激活能垒。你将构建一个程序，用于计算沿线性插值路径的一组离散“图像”（image）的能量，并返回几组不同参数下的估计能垒。使用微动弹性带（Nudged Elastic Band, NEB）方法的基本概念，但将计算限制为通过线性插值对猜测路径进行采样，不涉及任何弹簧力或切向投影。问题必须基于以下基本定义和事实进行构建：\n\n- 势能面（PES）为原子坐标构型 $\\mathbf{R}$ 指定一个势能 $V(\\mathbf{R})$。对于一个在二维空间中表示其位置的迁移原子，使用 $\\mathbf{r}\\in\\mathbb{R}^2$。\n- 两个端点构型 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 之间的一条连续路径可以参数化为 $\\mathbf{r}(t)=\\mathbf{r}_0+t(\\mathbf{r}_1-\\mathbf{r}_0)$，其中 $t\\in[0,1]$。一组由 $N$ 个图像组成的离散集合由 $t_i=\\frac{i}{N-1}$ 定义，从而得到 $\\mathbf{r}_i=\\mathbf{r}(t_i)$，其中 $i=0,1,\\dots,N-1$。\n- 相对于初始状态的激活能垒估计值定义为 $E^\\ddagger=\\max_{i}V(\\mathbf{r}_i)-V(\\mathbf{r}_0)$。\n\n你必须为迁移原子实现以下受物理启发、崎岖不平且源于高熵合金（HEA）的势能面（PES）：\n\n$$\nV(\\mathbf{r})=\\sum_{j=1}^{5}A_j\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{c}_j\\|^2}{2\\sigma_j^2}\\right)\n+B\\cos\\!\\left(2\\pi\\,\\mathbf{q}\\cdot\\mathbf{r}\\right)\n+C\\sum_{m=1}^{2}\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{s}_m\\|^2}{2\\lambda^2}\\right),\n$$\n\n其中，五个高斯势阱模拟了五元合金中与局域原子种类相关的吸引作用，余弦项模拟了介观尺度的应变场，最后的求和项模拟了路径上的两个排斥性障碍物。使用固定的参数和端点如下：\n\n- 高斯势阱中心（原子种类位置，单位：纳米）：$\\mathbf{c}_1=(0.0,\\,0.0)$，$\\mathbf{c}_2=(1.0,\\,0.0)$，$\\mathbf{c}_3=(0.5,\\,0.8)$，$\\mathbf{c}_4=(-0.6,\\,0.4)$，$\\mathbf{c}_5=(1.2,\\,-0.7)$。\n- 势阱深度（单位：电子伏特）：$A_1=-0.20$, $A_2=-0.18$, $A_3=-0.16$, $A_4=-0.14$, $A_5=-0.12$。\n- 高斯宽度（单位：纳米）：$\\sigma_j=\\sigma=0.15$ for $j=1,\\dots,5$。\n- 排斥性障碍物中心（单位：纳米）：$\\mathbf{s}_1=(0.5,\\,0.0)$，$\\mathbf{s}_2=(0.6,\\,0.2)$。\n- 排斥性障碍物宽度（单位：纳米）：$\\lambda=0.10$。\n- 应变场波矢（单位：反纳米）：$\\mathbf{q}=(1.5,\\,0.7)$。\n- 端点（单位：纳米）：$\\mathbf{r}_0=\\mathbf{c}_1$，$\\mathbf{r}_1=\\mathbf{c}_2$。\n\n振幅 $B$（应变场）和 $C$（排斥性障碍物）将随测试用例而变化。程序必须：\n\n- 对于每个测试用例，使用 $\\mathbf{r}_i=\\mathbf{r}_0+\\frac{i}{N-1}(\\mathbf{r}_1-\\mathbf{r}_0)$ 在 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 之间构建 $N$ 个线性插值的图像 $\\mathbf{r}_i$。\n- 对所有的 $i$ 计算 $V(\\mathbf{r}_i)$。\n- 计算能垒 $E^\\ddagger=\\max_i V(\\mathbf{r}_i)-V(\\mathbf{r}_0)$。\n\n所有能量均以电子伏特（eV）表示。余弦函数中的角度以弧度为单位。程序无需报告任何其他物理单位。最终的数值结果必须是浮点数。\n\n在你的解决方案中，讨论在崎岖的势能面上使用线性插值的局限性，特别是对于具有强成分无序的高熵合金系统。你的讨论必须基于基本定义，并且不应依赖任何快捷公式。\n\n测试套件：\n为以下参数集 $(N,B,C)$ 提供输出：\n\n- 情况 1：$(11,\\,0.05,\\,0.25)$。\n- 情况 2：$(2,\\,0.05,\\,0.25)$。\n- 情况 3：$(51,\\,0.10,\\,0.35)$。\n- 情况 4：$(21,\\,0.00,\\,0.00)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$）。每个 $\\text{result}_k$ 是相应测试用例的激活能垒 $E^\\ddagger$（单位：eV），表示为浮点数。程序必须完全自包含，不需要任何外部输入或文件。",
            "solution": "该问题要求计算一个在模拟五元高熵合金（HEA）的模型二维势能面（PES）上扩散的单个原子的估计活化能垒。该过程包括：将初始构型和最终构型之间的线性插值路径离散化，评估每个离散点（图像）的势能，并确定相对于起点的最大能量。\n\n首先，我们定义数学和物理框架。迁移原子的位置是一个二维向量 $\\mathbf{r} = (x, y)$。势能面 $V(\\mathbf{r})$ 由以下函数给出：\n$$\nV(\\mathbf{r})=\\sum_{j=1}^{5}A_j\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{c}_j\\|^2}{2\\sigma_j^2}\\right)\n+B\\cos\\!\\left(2\\pi\\,\\mathbf{q}\\cdot\\mathbf{r}\\right)\n+C\\sum_{m=1}^{2}\\exp\\left(-\\frac{\\|\\mathbf{r}-\\mathbf{s}_m\\|^2}{2\\lambda^2}\\right)\n$$\n该函数是三项的叠加：\n1. 五个高斯函数的和，代表以位置 $\\mathbf{c}_j$ 为中心、深度 $A_j$ 不同的吸引势阱。这些势阱模拟了高熵合金中化学性质不同的原子位点。\n2. 一个正弦项，代表振幅为 $B$、波矢为 $\\mathbf{q}$ 的介观尺度应变场。\n3. 两个高斯函数的和，代表振幅为 $C$、以位置 $\\mathbf{s}_m$ 为中心的排斥势垒。这些势垒模拟了障碍物或能量上不利的位点。\n\n扩散路径近似为初始构型 $\\mathbf{r}_0$ 和最终构型 $\\mathbf{r}_1$ 之间的一条直线。这条由 $t \\in [0, 1]$ 参数化的连续路径为 $\\mathbf{r}(t) = \\mathbf{r}_0 + t(\\mathbf{r}_1 - \\mathbf{r}_0)$。我们将此路径离散化为一组 $N$ 个图像 $\\mathbf{r}_i$，其中 $i = 0, 1, \\dots, N-1$。第 $i$ 个图像的位置由下式给出：\n$$\n\\mathbf{r}_i = \\mathbf{r}_0 + \\frac{i}{N-1}(\\mathbf{r}_1 - \\mathbf{r}_0) \\quad \\text{for } N \\ge 2\n$$\n问题指定端点为 $\\mathbf{r}_0 = \\mathbf{c}_1 = (0.0, 0.0)$ 和 $\\mathbf{r}_1 = \\mathbf{c}_2 = (1.0, 0.0)$。这将图像位置简化为 $\\mathbf{r}_i = (\\frac{i}{N-1}, 0)$。\n\n估计的激活能垒 $E^\\ddagger$ 定义为沿离散路径找到的最大势能与初始状态势能之差：\n$$\nE^\\ddagger = \\max_{i=0, \\dots, N-1} V(\\mathbf{r}_i) - V(\\mathbf{r}_0)\n$$\n\n每个测试用例 $(N, B, C)$ 的计算过程如下：\n1. 定义固定参数：吸引势阱中心 $\\mathbf{c}_j$、深度 $A_j$ 和宽度 $\\sigma$；排斥性障碍物中心 $\\mathbf{s}_m$ 和宽度 $\\lambda$；以及应变场波矢 $\\mathbf{q}$。端点为 $\\mathbf{r}_0 = (0.0, 0.0)$ 和 $\\mathbf{r}_1 = (1.0, 0.0)$。\n2. 沿着连接 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 的直线生成一组 $N$ 个图像坐标 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$。\n3. 使用给定的 $B$ 和 $C$ 值，为每个图像 $\\mathbf{r}_i$ 计算势能 $V(\\mathbf{r}_i)$。\n4. 从计算出的能量中确定初始状态的能量 $V_0 = V(\\mathbf{r}_0)$（它就是第一个图像的能量，即 $i=0$ 时的 $V(\\mathbf{r}_i)$）。\n5. 找到计算出的能量集合中的最大能量 $V_{\\text{max}} = \\max_{i} V(\\mathbf{r}_i)$。\n6. 计算激活能垒 $E^\\ddagger = V_{\\text{max}} - V_0$。\n\n该问题的一个关键方面是理解使用简单线性插值作为反应路径的局限性，特别是在像高熵合金这样的复杂系统中。热激活过程的真实扩散路径遵循势能面上的最小能量路径（Minimum Energy Path, MEP）。MEP 是一条连接两个局部极小值点（如 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$）的路径，在该路径的鞍点处，能量在沿路径方向上是最大的，而在所有垂直于路径的方向上都是最小的。MEP 上的最高点定义了真实的鞍点能量，其与初始状态能量的差值即为真实的激活能垒。\n\n线性插值路径仅仅是一个猜测，极不可能是真实的 MEP。在一个“崎岖”的 PES 上——这是高熵合金因其严重的晶格畸变和化学复杂性而具有的特征——直线路径很可能会穿过比真实 MEP 能量高得多的区域，而真实的 MEP 会自然弯曲以避开这些障碍物。因此，从线性路径计算出的激活能垒 $E^\\ddagger$ 几乎总是对真实物理激活能垒的高估。像微动弹性带（NEB）这样的方法就是为了克服这个问题而设计的。NEB 从一个初始路径（通常是线性插值）开始，并迭代地弛豫这些图像，使它们在垂直于路径的方向上沿着 PES“下山”，直到这组图像收敛到 MEP 上。本问题中的过程等同于 NEB 计算的第一步（评估初始猜测），而没有任何后续的弛豫。图像的密度 $N$ 会影响沿固定线性路径的能量剖面的分辨率。一个非常低的 $N$（例如 $N=2$）可能会错过该路径上的能量峰值，导致对*该特定路径*的能垒的低估。一个更高的 $N$ 会给出沿线性路径的更准确的能垒值，但它并不能纠正路径本身的根本缺陷。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the estimated activation barrier for a single migrating atom\n    in a model quinary high-entropy alloy (HEA) supercell for several\n    parameter sets.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    # Gaussian well centers (species sites, in nanometers)\n    C_CENTERS = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.5, 0.8], [-0.6, 0.4], [1.2, -0.7]\n    ])\n    # Well depths (in electronvolts)\n    A_DEPTHS = np.array([-0.20, -0.18, -0.16, -0.14, -0.12])\n    # Gaussian width (in nanometers)\n    SIGMA = 0.15\n    \n    # Repulsive obstacle centers (in nanometers)\n    S_CENTERS = np.array([[0.5, 0.0], [0.6, 0.2]])\n    # Repulsive obstacle width (in nanometers)\n    LAMBDA = 0.10\n    \n    # Strain field wavevector (in inverse nanometers)\n    Q_VEC = np.array([1.5, 0.7])\n    \n    # Endpoints (in nanometers)\n    R0 = C_CENTERS[0]\n    R1 = C_CENTERS[1]\n\n    def potential_energy(r, B, C):\n        \"\"\"\n        Calculates the potential energy V(r) for a given position r and\n        parameters B and C.\n        \n        Args:\n            r (np.ndarray): 2D position vector [x, y].\n            B (float): Amplitude of the strain field term.\n            C (float): Amplitude of the repulsive obstacle term.\n            \n        Returns:\n            float: The potential energy in eV.\n        \"\"\"\n        # 1. Sum of attractive Gaussian wells\n        term1 = 0.0\n        for j in range(len(C_CENTERS)):\n            norm_sq = np.linalg.norm(r - C_CENTERS[j])**2\n            term1 += A_DEPTHS[j] * np.exp(-norm_sq / (2 * SIGMA**2))\n            \n        # 2. Strain field term\n        term2 = B * np.cos(2 * np.pi * np.dot(Q_VEC, r))\n        \n        # 3. Sum of repulsive Gaussian obstacles\n        term3 = 0.0\n        for m in range(len(S_CENTERS)):\n            norm_sq = np.linalg.norm(r - S_CENTERS[m])**2\n            term3 += C * np.exp(-norm_sq / (2 * LAMBDA**2))\n            \n        return term1 + term2 + term3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, B, C)\n        (11, 0.05, 0.25),\n        (2, 0.05, 0.25),\n        (51, 0.10, 0.35),\n        (21, 0.00, 0.00),\n    ]\n\n    results = []\n    for N, B, C in test_cases:\n        # Generate the N linearly interpolated image positions\n        # The path is from (0,0) to (1,0), so it's along the x-axis.\n        if N  2:\n            # For N2, the path is ill-defined. Barrier is 0.\n            # This case is not in the test suite but handled for robustness.\n            results.append(0.0)\n            continue\n            \n        x_coords = np.linspace(R0[0], R1[0], N)\n        y_coords = np.linspace(R0[1], R1[1], N)\n        path_images = np.stack((x_coords, y_coords), axis=-1)\n        \n        # Evaluate V(r_i) for all images i\n        energies = np.array([potential_energy(r, B, C) for r in path_images])\n        \n        # Initial energy V(r_0)\n        v0 = energies[0]\n        \n        # Maximum energy along the path\n        v_max = np.max(energies)\n        \n        # Compute the barrier E_dagger = max(V(r_i)) - V(r_0)\n        barrier = v_max - v0\n        results.append(barrier)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "NEB方法的核心在于其独特的力定义，它允许路径点（images）向最小能量路径（MEP）弛豫，而不会滑向路径两端的能量最低点。本练习  将指导你完成NEB力的基本计算。你将把真实的势能力分解为平行于路径和垂直于路径的分量，并将垂直分量与一个平行的弹簧力相结合，从而亲身体验“微动”是如何实现的。",
            "id": "3752868",
            "problem": "给定一组离散图像，这些图像代表了简化高熵合金环境中候选反应路径上的原子构型。目标是为每个内部图像计算切向单位向量、力分解以及微动弹性带（Nudged Elastic Band, NEB）力，并验证垂直真实力分量与每个内部图像处切线的正交性。请使用以下基本依据和定义。\n\n设路径为一系列图像，其位置为 $\\mathbf{R}_i \\in \\mathbb{R}^3$，能量为 $E_i = V(\\mathbf{R}_i)$，其中 $i = 0, 1, \\dots, N-1$。势能函数 $V(\\mathbf{R})$ 定义为高斯项、周期余弦项和四次项之和：\n$$\nV(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right) + A\\left(\\cos(\\beta_x x) + \\cos(\\beta_y y) + \\cos(\\beta_z z)\\right) + B \\left(\\|\\mathbf{R}\\|^2\\right)^2,\n$$\n其中 $\\mathbf{R} = (x,y,z)$，$w_m$ 是高斯权重，$\\sigma_m$ 是高斯宽度，$\\mathbf{C}_m$ 是高斯中心。梯度 $\\nabla V(\\mathbf{R})$ 通过对每一项求导获得：\n$$\n\\nabla V(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right)\\left(-\\frac{2}{\\sigma_m^2}\\right)(\\mathbf{R} - \\mathbf{C}_m) \n- A \\begin{bmatrix} \\beta_x \\sin(\\beta_x x) \\\\ \\beta_y \\sin(\\beta_y y) \\\\ \\beta_z \\sin(\\beta_z z)\\end{bmatrix}\n+ 4 B (\\|\\mathbf{R}\\|^2)\\mathbf{R}.\n$$\n\n对于每个内部图像 $i$（$1 \\leq i \\leq N-2$），定义前向和后向位移 $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ 和 $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$。切向量 $\\hat{\\tau}_i$ 使用基于能量的选择规则来选取，以避免路径扭结。使用以下经过改进但简单的选择规则：\n- 如果 $E_{i+1} > E_i > E_{i-1}$，则设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n- 否则，如果 $E_{i+1}  E_i  E_{i-1}$，则设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n- 否则，如果 $E_{i+1} > E_{i-1}$，则设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n- 否则，如果 $E_{i+1}  E_{i-1}$，则设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n- 否则，设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^-$。\n\n然后进行归一化，得到单位切向量 $\\hat{\\tau}_i = \\mathbf{\\tau}_i / \\|\\mathbf{\\tau}_i\\|$。\n\n令真实力为 $\\mathbf{F}_i^{\\text{true}} = -\\nabla V(\\mathbf{R}_i)$。计算其垂直于路径切线的分量，\n$$\n\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\text{true}} - \\left(\\mathbf{F}_i^{\\text{true}} \\cdot \\hat{\\tau}_i\\right)\\hat{\\tau}_i,\n$$\n以及沿切线投影的弹性弹簧力，\n$$\n\\mathbf{F}_i^{\\parallel, \\text{spring}} = k\\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right)\\hat{\\tau}_i,\n$$\n其中 $k$ 是给定的无量纲弹簧常数。内部图像的微动弹性带（NEB）力为\n$$\n\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\parallel, \\text{spring}}.\n$$\n\n正交性验证需要检查垂直分量是否与切线正交，即在给定的数值公差范围内 $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i = 0$。为每个测试用例计算所有内部图像上 $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i$ 的最大绝对值，并报告是否所有内部图像都满足 $|\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i| \\leq \\varepsilon$（其中 $\\varepsilon$ 是指定的公差）。\n\n所有量均为无量纲。以完整精度报告浮点输出；无需四舍五入。角度通过三角函数隐式地以弧度为单位。不涉及物理单位。\n\n为以下三个测试用例组成的测试套件实现上述计算。对于每个用例，必须根据提供的势能 $V(\\mathbf{R}_i)$ 计算能量 $E_i$，并将其用于切线选择规则。\n\n测试用例 $1$：\n- 图像 ($N = 7$):\n  - $\\mathbf{R}_0 = (-1.0, 0.2, 0.0)$,\n  - $\\mathbf{R}_1 = (-0.6666666667, 0.1333333333, 0.0)$,\n  - $\\mathbf{R}_2 = (-0.3333333333, 0.0666666667, 0.0)$,\n  - $\\mathbf{R}_3 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (0.3333333333, -0.0666666667, 0.0)$,\n  - $\\mathbf{R}_5 = (0.6666666667, -0.1333333333, 0.0)$,\n  - $\\mathbf{R}_6 = (1.0, -0.2, 0.0)$.\n- 势能参数:\n  - 高斯项 ($M = 3$):\n    - $w_1 = 1.20$, $\\sigma_1 = 0.40$, $\\mathbf{C}_1 = (0.30, 0.00, 0.00)$,\n    - $w_2 = 0.80$, $\\sigma_2 = 0.35$, $\\mathbf{C}_2 = (-0.50, 0.20, 0.00)$,\n    - $w_3 = -0.60$, $\\sigma_3 = 0.45$, $\\mathbf{C}_3 = (0.00, -0.30, 0.00)$.\n  - 周期项: $A = 0.15$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - 四次项: $B = 0.02$.\n- 弹簧常数: $k = 0.50$.\n- 正交性公差: $\\varepsilon = 1\\times 10^{-10}$.\n\n测试用例 $2$：\n- 图像 ($N = 6$):\n  - $\\mathbf{R}_0 = (-0.8, -0.2, 0.1)$,\n  - $\\mathbf{R}_1 = (-0.5, 0.05, 0.1)$,\n  - $\\mathbf{R}_2 = (-0.2, 0.3, 0.1)$,\n  - $\\mathbf{R}_3 = (0.1, 0.15, 0.1)$,\n  - $\\mathbf{R}_4 = (0.4, -0.05, 0.1)$,\n  - $\\mathbf{R}_5 = (0.7, -0.25, 0.1)$.\n- 势能参数 (同用例 $1$):\n  - 高斯项 ($M = 3$):\n    - $w_1 = 1.20$, $\\sigma_1 = 0.40$, $\\mathbf{C}_1 = (0.30, 0.00, 0.00)$,\n    - $w_2 = 0.80$, $\\sigma_2 = 0.35$, $\\mathbf{C}_2 = (-0.50, 0.20, 0.00)$,\n    - $w_3 = -0.60$, $\\sigma_3 = 0.45$, $\\mathbf{C}_3 = (0.00, -0.30, 0.00)$.\n  - 周期项: $A = 0.15$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - 四次项: $B = 0.02$.\n- 弹簧常数: $k = 0.80$.\n- 正交性公差: $\\varepsilon = 1\\times 10^{-10}$.\n\n测试用例 $3$：\n- 图像 ($N = 5$):\n  - $\\mathbf{R}_0 = (-0.5, 0.0, 0.0)$,\n  - $\\mathbf{R}_1 = (-0.25, 0.0, 0.0)$,\n  - $\\mathbf{R}_2 = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{R}_3 = (0.25, 0.0, 0.0)$,\n  - $\\mathbf{R}_4 = (0.5, 0.0, 0.0)$.\n- 势能参数 (为探测简并性而平坦化的势能面):\n  - 高斯项 ($M = 3$):\n    - $w_1 = 0.40$, $\\sigma_1 = 0.90$, $\\mathbf{C}_1 = (0.00, 0.00, 0.00)$,\n    - $w_2 = 0.30$, $\\sigma_2 = 0.90$, $\\mathbf{C}_2 = (0.30, 0.00, 0.00)$,\n    - $w_3 = 0.20$, $\\sigma_3 = 1.00$, $\\mathbf{C}_3 = (-0.30, 0.00, 0.00)$.\n  - 周期项: $A = 0.00$, $(\\beta_x, \\beta_y, \\beta_z) = (2.0, 2.5, 1.5)$.\n  - 四次项: $B = 0.01$.\n- 弹簧常数: $k = 0.30$.\n- 正交性公差: $\\varepsilon = 1\\times 10^{-12}$.\n\n你的程序应该为每个测试用例计算所有内部图像的以下三个量：\n- 最大绝对点积 $m = \\max_{i} \\left| \\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i \\right|$。\n- 正交性标志 $b$，定义为：如果对所有内部图像 $i$ 都有 $\\left| \\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i \\right| \\leq \\varepsilon$ 成立，则 $b=1$，否则 $b=0$。\n- 最大欧几里得范数 $n = \\max_{i} \\left\\| \\mathbf{F}_i^{\\text{NEB}} \\right\\|$。\n\n最终输出格式：你的程序应该生成一行输出，其中包含一个逗号分隔的列表的列表，每个子列表对应一个测试用例，顺序如上文所定义。每个子列表必须为 $[m,b,n]$ 的形式，其中 $m$ 和 $n$ 是浮点值，$b$ 是整数。例如，一个输出可能看起来像 $[[0.0,1,0.5],[0.0,1,0.8],[0.0,1,0.3]]$，但需使用给定数据计算出的实际值。",
            "solution": "该问题已经过严格验证，并被确定为是合理的。它在科学上基于计算材料科学的原理，特别是用于寻找反应路径的微动弹性带（Nudged Elastic Band, NEB）方法。该问题定义明确，为三个不同的测试用例提供了一套完整且一致的定义、方程和数据。所有术语都得到了正式定义，任务包含一个直接、明确的计算过程。验证 $\\mathbf{F}_i^{\\perp}$ 和 $\\hat{\\tau}_i$ 正交性的要求是一项标准的数值健全性检查，因为根据定义，这两个向量是正交的；任何非零结果都应在机器精度级别，由浮点运算限制引起。\n\n解决方案通过对所提供反应路径的每个内部图像执行一系列计算步骤来实现。路径由位于位置 $\\mathbf{R}_0, \\mathbf{R}_1, \\dots, \\mathbf{R}_{N-1}$ 的 $N$ 个图像（原子构型）序列定义。计算针对每个内部图像 $\\mathbf{R}_i$ 执行，其中索引 $i$ 的范围从 $1$ 到 $N-2$。\n\n**第1步：势能面与真实力**\n\n首先，我们定义势能面（Potential Energy Surface, PES）$V(\\mathbf{R})$ 及其对应的力场。位于位置 $\\mathbf{R} = (x,y,z)$ 的构型的势能由下式给出：\n$$\nV(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right) + A\\left(\\cos(\\beta_x x) + \\cos(\\beta_y y) + \\cos(\\beta_z z)\\right) + B \\left(\\|\\mathbf{R}\\|^2\\right)^2\n$$\n系统受到的力，称为“真实力”，是该势能的负梯度：$\\mathbf{F}^{\\text{true}} = -\\nabla V(\\mathbf{R})$。梯度由下式给出：\n$$\n\\nabla V(\\mathbf{R}) = \\sum_{m=1}^{M} w_m \\exp\\left(-\\frac{\\|\\mathbf{R} - \\mathbf{C}_m\\|^2}{\\sigma_m^2}\\right)\\left(-\\frac{2}{\\sigma_m^2}\\right)(\\mathbf{R} - \\mathbf{C}_m) \n- A \\begin{bmatrix} \\beta_x \\sin(\\beta_x x) \\\\ \\beta_y \\sin(\\beta_y y) \\\\ \\beta_z \\sin(\\beta_z z)\\end{bmatrix}\n+ 4 B (\\|\\mathbf{R}\\|^2)\\mathbf{R}\n$$\n对于每个图像 $\\mathbf{R}_i$，我们计算其能量 $E_i = V(\\mathbf{R}_i)$。对于每个内部图像 $\\mathbf{R}_i$ ($1 \\le i \\le N-2$)，我们计算真实力 $\\mathbf{F}_i^{\\text{true}} = -\\nabla V(\\mathbf{R}_i)$。\n\n**第2步：路径切线计算**\n\n内部图像 $\\mathbf{R}_i$ 处反应路径的局部方向由切向量 $\\hat{\\tau}_i$ 定义。为构建此切线，我们首先定义前向和后向位移向量：$\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ 和 $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$。\n\n使用基于能量的切换方案来选择未归一化的切向量 $\\mathbf{\\tau}_i$，以确保它从能量较低的邻居指向“上坡”方向，并避免路径扭结。指定的选择规则是：\n1. 如果 $E_{i+1} > E_i > E_{i-1}$ (路径是上升的)，设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n2. 否则如果 $E_{i+1}  E_i  E_{i-1}$ (路径是下降的)，设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n3. 否则 (图像 $\\mathbf{R}_i$ 靠近极值点或在斜坡上):\n   a. 如果 $E_{i+1} > E_{i-1}$, 设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+$。\n   b. 否则如果 $E_{i+1}  E_{i-1}$, 设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^-$。\n   c. 否则 ($E_{i+1} = E_{i-1}$), 设置 $\\mathbf{\\tau}_i = \\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^- = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}$。\n\n最终的单位切向量通过归一化 $\\mathbf{\\tau}_i$ 得到：\n$$\n\\hat{\\tau}_i = \\frac{\\mathbf{\\tau}_i}{\\|\\mathbf{\\tau}_i\\|}\n$$\n\n**第3步：NEB 力计算**\n\nNEB方法的核心思想是将作用在图像上的力分解为平行于和垂直于反应路径的分量。总NEB力 $\\mathbf{F}_i^{\\text{NEB}}$ 是两个分量的和：真实力的垂直分量和虚构弹簧力的平行分量。\n\n真实力的垂直分量 $\\mathbf{F}_i^{\\perp}$ 将图像推向最小能量路径。它的计算方法是将 $\\mathbf{F}_i^{\\text{true}}$ 投影到切线 $\\hat{\\tau}_i$ 上，然后从原始力向量中减去这个投影：\n$$\n\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\text{true}} - (\\mathbf{F}_i^{\\text{true}} \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i\n$$\n通过这种构造方式，$\\mathbf{F}_i^{\\perp}$ 在数学上与 $\\hat{\\tau}_i$ 正交，即 $\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i = 0$。\n\n弹簧力分量 $\\mathbf{F}_i^{\\parallel, \\text{spring}}$ 仅沿路径切线方向作用。其目的是确保图像沿路径均匀分布。它被定义为：\n$$\n\\mathbf{F}_i^{\\parallel, \\text{spring}} = k(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|)\\hat{\\tau}_i\n$$\n这里，$k$ 是弹簧常数。这个力与图像 $\\mathbf{R}_i$ 前后路径段的长度差成正比。\n\n总微动弹性带力是这两个分量的和：\n$$\n\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\parallel, \\text{spring}}\n$$\n这种构造确保了真实势能仅使图像垂直于路径移动，而弹簧力仅使它们平行于路径移动，从而防止图像滑落到能量最低点并保持其分布。\n\n**第4步：验证与指标聚合**\n\n对于每个测试用例，我们遍历所有内部图像 $i \\in \\{1, \\dots, N-2\\}$ 并计算所需的量。每个用例的最终结果被聚合成三个指标：\n\n1.  最大绝对点积，$m = \\max_{i} |\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i|$。该指标用于数值验证正交性。由于浮点精度问题，该值预期会非常接近于零，但不会精确为零。\n2.  正交性标志，$b$。如果所有内部图像都满足条件 $|\\mathbf{F}_i^{\\perp} \\cdot \\hat{\\tau}_i| \\le \\varepsilon$（其中 $\\varepsilon$ 是给定的公差），则该整数设置为 $1$，否则为 $0$。\n3.  NEB力的最大欧几里得范数，$n = \\max_{i} \\|\\mathbf{F}_i^{\\text{NEB}}\\|$。这表示作用在带中任何图像上的最大力，在完整的NEB优化中是一个有用的收敛标准。\n\n该实现将对提供的三个测试用例分别应用这些步骤。",
            "answer": "```python\nimport numpy as np\n\ndef get_potential_and_gradient(potential_params):\n    \"\"\"\n    Factory function to create potential energy and gradient functions\n    based on the given parameters.\n    \"\"\"\n    gaussians = potential_params['gaussians']\n    A = potential_params['A']\n    betas = np.array(potential_params['betas'])\n    B = potential_params['B']\n\n    def V(R):\n        \"\"\"Computes the potential energy V at a given position R.\"\"\"\n        R = np.array(R)\n        # Gaussian terms\n        gauss_sum = 0.0\n        for w, sigma, C in gaussians:\n            C = np.array(C)\n            norm_sq = np.sum((R - C)**2)\n            gauss_sum += w * np.exp(-norm_sq / (sigma**2))\n        \n        # Periodic term\n        periodic_sum = A * np.sum(np.cos(betas * R))\n        \n        # Quartic term\n        quartic_term = B * (np.sum(R**2))**2\n        \n        return gauss_sum + periodic_sum + quartic_term\n\n    def grad_V(R):\n        \"\"\"Computes the gradient of the potential V at a given position R.\"\"\"\n        R = np.array(R)\n        grad = np.zeros(3, dtype=float)\n        \n        # Gaussian terms\n        for w, sigma, C in gaussians:\n            C = np.array(C)\n            norm_sq = np.sum((R - C)**2)\n            grad += w * np.exp(-norm_sq / (sigma**2)) * (-2.0 / (sigma**2)) * (R - C)\n        \n        # Periodic term\n        grad -= A * betas * np.sin(betas * R)\n        \n        # Quartic term\n        grad += 4.0 * B * np.sum(R**2) * R\n        \n        return grad\n        \n    return V, grad_V\n\ndef solve():\n    \"\"\"\n    Main function to run the NEB calculations for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"images\": [\n                (-1.0, 0.2, 0.0), (-0.6666666667, 0.1333333333, 0.0),\n                (-0.3333333333, 0.0666666667, 0.0), (0.0, 0.0, 0.0),\n                (0.3333333333, -0.0666666667, 0.0), (0.6666666667, -0.1333333333, 0.0),\n                (1.0, -0.2, 0.0)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (1.20, 0.40, (0.30, 0.00, 0.00)),\n                    (0.80, 0.35, (-0.50, 0.20, 0.00)),\n                    (-0.60, 0.45, (0.00, -0.30, 0.00))\n                ],\n                \"A\": 0.15, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.02\n            },\n            \"k\": 0.50,\n            \"epsilon\": 1e-10\n        },\n        # Test Case 2\n        {\n            \"images\": [\n                (-0.8, -0.2, 0.1), (-0.5, 0.05, 0.1), (-0.2, 0.3, 0.1),\n                (0.1, 0.15, 0.1), (0.4, -0.05, 0.1), (0.7, -0.25, 0.1)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (1.20, 0.40, (0.30, 0.00, 0.00)),\n                    (0.80, 0.35, (-0.50, 0.20, 0.00)),\n                    (-0.60, 0.45, (0.00, -0.30, 0.00))\n                ],\n                \"A\": 0.15, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.02\n            },\n            \"k\": 0.80,\n            \"epsilon\": 1e-10\n        },\n        # Test Case 3\n        {\n            \"images\": [\n                (-0.5, 0.0, 0.0), (-0.25, 0.0, 0.0), (0.0, 0.0, 0.0),\n                (0.25, 0.0, 0.0), (0.5, 0.0, 0.0)\n            ],\n            \"potential_params\": {\n                \"gaussians\": [\n                    (0.40, 0.90, (0.00, 0.00, 0.00)),\n                    (0.30, 0.90, (0.30, 0.00, 0.00)),\n                    (0.20, 1.00, (-0.30, 0.00, 0.00))\n                ],\n                \"A\": 0.00, \"betas\": (2.0, 2.5, 1.5), \"B\": 0.01\n            },\n            \"k\": 0.30,\n            \"epsilon\": 1e-12\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        images_R = [np.array(r) for r in case[\"images\"]]\n        N = len(images_R)\n        V, grad_V = get_potential_and_gradient(case[\"potential_params\"])\n        k = case[\"k\"]\n        epsilon = case[\"epsilon\"]\n        \n        energies_E = [V(R) for R in images_R]\n        \n        max_abs_dot_product = 0.0\n        max_neb_force_norm = 0.0\n        \n        dot_products_below_eps = True\n        \n        for i in range(1, N - 1):\n            R_i = images_R[i]\n            R_i_minus_1 = images_R[i-1]\n            R_i_plus_1 = images_R[i+1]\n            \n            E_i = energies_E[i]\n            E_i_minus_1 = energies_E[i-1]\n            E_i_plus_1 = energies_E[i+1]\n            \n            delta_R_plus = R_i_plus_1 - R_i\n            delta_R_minus = R_i - R_i_minus_1\n            \n            # Tangent selection\n            tau_i = None\n            if E_i_plus_1 > E_i and E_i > E_i_minus_1:\n                tau_i = delta_R_plus\n            elif E_i_plus_1  E_i and E_i  E_i_minus_1:\n                tau_i = delta_R_minus\n            else:\n                if E_i_plus_1 > E_i_minus_1:\n                    tau_i = delta_R_plus\n                elif E_i_plus_1  E_i_minus_1:\n                    tau_i = delta_R_minus\n                else: # E_i_plus_1 == E_i_minus_1\n                    tau_i = delta_R_plus + delta_R_minus\n            \n            # Normalize tangent\n            tau_i_norm = np.linalg.norm(tau_i)\n            tau_hat_i = tau_i / tau_i_norm if tau_i_norm > 1e-15 else np.zeros(3)\n\n            # True force\n            F_i_true = -grad_V(R_i)\n            \n            # Perpendicular component of true force\n            F_i_perp = F_i_true - np.dot(F_i_true, tau_hat_i) * tau_hat_i\n            \n            # Parallel spring force\n            norm_delta_R_plus = np.linalg.norm(delta_R_plus)\n            norm_delta_R_minus = np.linalg.norm(delta_R_minus)\n            F_i_spring_parallel = k * (norm_delta_R_plus - norm_delta_R_minus) * tau_hat_i\n            \n            # NEB force\n            F_i_NEB = F_i_perp + F_i_spring_parallel\n            \n            # Metric 1: Orthogonality check\n            dot_product = np.dot(F_i_perp, tau_hat_i)\n            max_abs_dot_product = max(max_abs_dot_product, abs(dot_product))\n            \n            if abs(dot_product) > epsilon:\n                dot_products_below_eps = False\n                \n            # Metric 3: Max NEB force norm\n            neb_force_norm = np.linalg.norm(F_i_NEB)\n            max_neb_force_norm = max(max_neb_force_norm, neb_force_norm)\n                \n        b = 1 if dot_products_below_eps else 0\n        m = max_abs_dot_product\n        n = max_neb_force_norm\n        \n        all_results.append([m, b, n])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "虽然标准的NEB方法能有效地找到最小能量路径，但要精确地定位鞍点（即过渡态），通常需要进行一些修改。“爬山”弹性带（CI-NEB）方法通过改变最高能量路径点上的力，使其“爬”向鞍点来解决这个问题。在最后一个练习  中，你将为爬山路径点实现特定的力计算，并验证其性质，从而巩固你对如何实现精确鞍点收敛的理解。",
            "id": "3752891",
            "problem": "考虑一个二维势能面，旨在模拟高熵合金（HEA）扩散中常见的无序景观。在此类景观中，反应路径通过微动弹性带（NEB）方法确定，并通过爬山镜像（CI）修正进行优化。设势能由一个光滑标量场 $V(\\mathbf{r})$ 定义，其中 $\\mathbf{r} = (x,y)$，力场由负梯度 $-\\nabla V(\\mathbf{r})$ 给出。一条离散路径由一系列镜像 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 表示，其中端点 $i=0$ 和 $i=N-1$ 是固定的。假设所有量均为无量纲（无单位）。\n\n基本原理和定义：\n- 镜像 $i$ 处的能量为 $E_i = V(\\mathbf{r}_i)$，梯度为 $\\nabla V(\\mathbf{r}_i)$。\n- 在内部镜像 $i$ 处的NEB路径切线是单位向量 $\\hat{\\boldsymbol{\\tau}}_i$，它与镜像 $i$ 处的路径方向对齐，并由相邻镜像构造。您必须仅使用相邻镜像来选择一个数学上一致的切线定义，并稳健地处理近简并的相邻镜像差异，避免除以零。\n- 爬山镜像修正旨在使内部镜像中能量最高的镜像沿路径切线方向“上坡”移动，并在垂直于路径的子空间中“下坡”移动，且该镜像不受任何弹簧力作用。\n\n任务：\n1. 对于下方的每个测试用例，找出具有最大能量的内部镜像，并通过应用与上述描述一致的爬山镜像修正来计算该镜像的更新力：该力应严格驱动镜像沿路径切线上坡移动，并垂直于路径下坡移动，同时移除该镜像上的任何弹簧力贡献。\n2. 使用向量投影和内积，验证计算出的力同时满足以下两点：\n   - 其切向分量使其上坡移动（沿路径上 $V$ 增加的方向）。\n   - 其垂直分量使其下坡移动（与能量梯度的垂直分量方向相反）。\n3. 为了验证，在最大能量镜像 $i^\\star$ 处使用以下量化检查：\n   - 令 $\\hat{\\boldsymbol{\\tau}} = \\hat{\\boldsymbol{\\tau}}_{i^\\star}$，$\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$，并定义投影 $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ 和 $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$。令 $\\mathbf{F}$ 表示您计算出的爬山镜像力。在 $\\epsilon = 10^{-8}$ 的绝对容差内验证以下所有条件：\n     - $\\mathbf{F}$ 的切向分量与上坡运动匹配：$\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}}$ 等于 $+\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}$。\n     - $\\mathbf{F}$ 的垂直分量相对于梯度是下坡的：$\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ 等于 $-\\mathbf{g}_{\\perp}$。\n     - 下坡条件在能量上是一致的：$\\left(\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}\\right)\\cdot \\mathbf{g}_{\\perp} \\le 0$。\n   通过逻辑与（仅当所有三个检查都在容差范围内成立时为真）将这三个检查聚合为单个布尔值。\n4. 重要的算法要求：\n   - 对于内部镜像 $i$ 处的切线 $\\hat{\\boldsymbol{\\tau}}_i$，使用从 $\\mathbf{r}_{i+1}-\\mathbf{r}_{i-1}$ 派生的有限差分方向并将其归一化。如果其范数低于一个小阈值，您必须稳健地选择一个备用的非零方向（例如，优先选择范数较大的 $\\mathbf{r}_{i}-\\mathbf{r}_{i-1}$ 或 $\\mathbf{r}_{i+1}-\\mathbf{r}_{i}$，或者作为最后手段，选择一个与 $\\nabla V(\\mathbf{r}_i)$ 相关的方向）并将其归一化。端点不参与爬山计算。\n   - 所有计算都是无量纲的。\n   - 使用下面定义的势能函数及其解析梯度。\n\n势能定义：\n- 令\n$$\nV(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y),\n$$\n其中常数 $a = 0.15$, $b = 0.10$, $c = 0.05$, $d = 0.03$。\n- 其梯度为\n$$\n\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big).\n$$\n\n测试套件：\n对于每个用例，您将获得一个镜像坐标列表 $\\{(x_i,y_i)\\}_{i=0}^{N-1}$。\n- 用例 1（跨越势垒的直线路径）：\n  $\\{(-1.4,\\,0.0),\\; (-1.0,\\,0.0),\\; (-0.6,\\,0.0),\\; (-0.2,\\,0.0),\\; (0.2,\\,0.0),\\; (0.6,\\,0.0),\\; (1.0,\\,0.0)\\}$.\n- 用例 2（对各向异性梯度进行采样的弯曲路径）：\n  $\\{(-1.2,\\,-0.3),\\; (-0.8,\\,-0.15),\\; (-0.4,\\,-0.02),\\; (0.0,\\,0.06),\\; (0.4,\\,0.12),\\; (0.8,\\,0.22),\\; (1.0,\\,0.4)\\}$.\n- 用例 3（最大值点附近的近简并相邻点差异）：\n  $\\{(-0.9,\\,0.0),\\; (-0.001,\\,0.02),\\; (0.0,\\,0.02),\\; (0.0000005,\\,0.0200001),\\; (0.9,\\,0.0)\\}$.\n\n程序要求：\n- 精确实现所给定的解析 $V(x,y)$ 和 $\\nabla V(x,y)$。\n- 对每个用例，找出具有最大 $V$ 的内部镜像，并计算该镜像的爬山镜像力 $\\mathbf{F}$，其计算方式应确保沿 $\\hat{\\boldsymbol{\\tau}}$ 的上坡运动和垂直于 $\\hat{\\boldsymbol{\\tau}}$ 的下坡运动，且该镜像上没有弹簧力。\n- 使用绝对容差 $\\epsilon = 10^{-8}$ 执行上述三个验证检查，并通过逻辑与为每个用例生成一个布尔值。\n\n最终输出格式：\n- 您的程序应产生一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”），其中每个结果是对应测试用例的布尔值。",
            "solution": "该问题要求在给定的二维势能面 $V(x,y)$ 上，为微动弹性带（NEB）模拟计算并验证爬山镜像力。爬山镜像（CI）修正是将NEB路径收敛到最小能量路径（MEP）的一种标准技术，其中能量最高的镜像会收敛到一个一阶鞍点（即过渡态）。\n\n问题的核心在于根据所提供的描述和验证标准，正确地解释爬山镜像力的定义。一个常规的NEB镜像受到两种力的作用：平行于路径切线的弹簧力 $\\mathbf{F}_{s, \\parallel}$，用于确保镜像均匀分布；以及真实势能力的垂直分量 $\\mathbf{F}_{\\text{pot}, \\perp}$，用于最小化垂直于路径的能量。势能力是势能的负梯度，即 $\\mathbf{F}_{\\text{pot}} = -\\nabla V$。\n\n爬山镜像，记为 $\\mathbf{r}_{i^\\star}$（能量最高的内部镜像），其处理方式有所不同。问题指出，其上的弹簧力被移除。它被驱动沿路径切线“上坡”，并垂直于路径“下坡”。令 $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$ 为爬山镜像处的势能梯度，并令 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 为该镜像处的路径单位切向量。术语“上坡”和“下坡”分别指势能增加和减少的方向。最陡峭的上升方向由 $\\mathbf{g}$ 给出。\n\n作用在爬山镜像上的力 $\\mathbf{F}_{\\text{CI}}$ 由其平行于和垂直于切线 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 的分量定义：\n$\\mathbf{F}_{\\text{CI}} = \\mathbf{F}_{\\parallel} + \\mathbf{F}_{\\perp}$。\n\n问题的验证标准明确了这些分量：\n1.  力的切向分量使镜像“上坡”移动。验证条件指定为 $\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。这意味着力的平行分量等于梯度的平行分量：$\\mathbf{F}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}_{\\parallel}$。该力分量沿切线方向推动镜像，使其朝该切线方向上势能增加的方向移动，从而“爬越”能垒。\n\n2.  力的垂直分量使镜像“下坡”移动。验证条件为 $\\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = -\\mathbf{g}_{\\perp}$。这意味着力的垂直分量是梯度的垂直分量的负值：$\\mathbf{F}_{\\perp} = -\\mathbf{g}_{\\perp}$。该力分量作用于最小化垂直于路径的超平面中的势能，从而将镜像松弛到最小能量路径（MEP）上。\n\n结合这些分量，爬山镜像力为：\n$$\n\\mathbf{F}_{\\text{CI}} = \\mathbf{g}_{\\parallel} - \\mathbf{g}_{\\perp}\n$$\n其中 $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 且 $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$。此公式等价于反转梯度CI力的标准定义，即 $\\mathbf{F}_{\\text{CI}} = -\\mathbf{g} + 2\\mathbf{g}_{\\parallel}$。\n\n解决每个测试用例的算法如下：\n1.  给定路径 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$，确定内部镜像，即 $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$。\n2.  计算每个内部镜像的势能 $E_i = V(\\mathbf{r}_i)$。找到能量最大镜像对应的索引 $i^\\star$。\n3.  确定爬山镜像 $\\mathbf{r}_{i^\\star}$ 处的切向量 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。主要定义是其相邻点之间的归一化向量：$\\mathbf{t} = \\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star-1}$。对于 $\\|\\mathbf{t}\\|$ 接近于零的情况，需要进行稳健性检查。指定的备用方法是使用 $\\mathbf{r}_{i^\\star} - \\mathbf{r}_{i^\\star-1}$ 或 $\\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star}$ 中模长较大的那个向量的归一化向量。\n4.  计算梯度向量 $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$。\n5.  计算爬山镜像力 $\\mathbf{F}_{\\text{CI}} = (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} - (\\mathbf{g} - (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star})$。\n6.  使用容差 $\\epsilon=10^{-8}$ 执行三个验证检查：\n    a. 检查 1: $|\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} - \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}|  \\epsilon$。\n    b. 检查 2: $\\|\\mathbf{F}_{\\perp} - (-\\mathbf{g}_{\\perp})\\|  \\epsilon$，其中 $\\mathbf{F}_{\\perp} = \\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 且 $\\mathbf{g}_{\\perp} = \\mathbf{g} - (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。\n    c. 检查 3: $\\mathbf{F}_{\\perp} \\cdot \\mathbf{g}_{\\perp} \\le 0$。如果前一个检查通过，此条件应成立，因为它变为 $-(\\mathbf{g}_{\\perp}\\cdot\\mathbf{g}_{\\perp}) = -\\|\\mathbf{g}_{\\perp}\\|^2 \\le 0$。\n7.  当且仅当所有三个检查都通过时，该测试用例的最终结果为 `True`。\n\n实现将使用所提供的势能 $V(x,y)$ 及其梯度 $\\nabla V(x,y)$ 的解析表达式：\n$V(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y)$\n$\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big)$\n其中 $a = 0.15$, $b = 0.10$, $c = 0.05$, $d = 0.03$。计算中使用了 `numpy` 库的数值向量操作。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the climbing image force verification problem for three test cases.\n    \"\"\"\n\n    # Constants for the potential energy function\n    a = 0.15\n    b = 0.10\n    c = 0.05\n    d = 0.03\n\n    def potential(r):\n        \"\"\"Calculates the potential energy V(x,y) at a given point r = [x, y].\"\"\"\n        x, y = r\n        term1 = (x**2 - 1)**2\n        term2 = a * y**2\n        term3 = b * np.sin(3 * x) * np.cos(2 * y)\n        term4 = c * x\n        term5 = d * np.sin(5 * y)\n        return term1 + term2 + term3 + term4 + term5\n\n    def gradient(r):\n        \"\"\"Calculates the gradient of the potential energy grad V(x,y) at a point r = [x, y].\"\"\"\n        x, y = r\n        grad_x = 4 * x * (x**2 - 1) + 3 * b * np.cos(3 * x) * np.cos(2 * y) + c\n        grad_y = 2 * a * y - 2 * b * np.sin(3 * x) * np.sin(2 * y) + 5 * d * np.cos(5 * y)\n        return np.array([grad_x, grad_y])\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        # Case 1: straight path across a barrier\n        [(-1.4, 0.0), (-1.0, 0.0), (-0.6, 0.0), (-0.2, 0.0), (0.2, 0.0), (0.6, 0.0), (1.0, 0.0)],\n        # Case 2: bent path sampling anistropic gradients\n        [(-1.2, -0.3), (-0.8, -0.15), (-0.4, -0.02), (0.0, 0.06), (0.4, 0.12), (0.8, 0.22), (1.0, 0.4)],\n        # Case 3: near-degenerate neighbor differences around the maximum\n        [(-0.9, 0.0), (-0.001, 0.02), (0.0, 0.02), (0.0000005, 0.0200001), (0.9, 0.0)],\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        path = np.array(case)\n        num_images = len(path)\n        \n        # Interior images are from index 1 to N-2\n        interior_indices = range(1, num_images - 1)\n        interior_images = path[1:num_images - 1]\n        \n        # 1. Find the interior image with the maximal energy\n        energies = [potential(r) for r in interior_images]\n        # Get the global index of the max energy image\n        i_star = np.argmax(energies) + 1 \n        r_istar = path[i_star]\n\n        # 2. Compute the tangent vector at the climbing image\n        r_prev = path[i_star - 1]\n        r_next = path[i_star + 1]\n        \n        # Primary tangent definition\n        t = r_next - r_prev\n        norm_t = np.linalg.norm(t)\n        \n        tangent_threshold = 1e-9\n        if norm_t  tangent_threshold:\n            # Fallback tangent definition\n            t1 = r_istar - r_prev\n            t2 = r_next - r_istar\n            if np.linalg.norm(t1) > np.linalg.norm(t2):\n                t_alt = t1\n            else:\n                t_alt = t2\n            \n            norm_t_alt = np.linalg.norm(t_alt)\n            # The problem provides no case where second fallback is needed.\n            if norm_t_alt  tangent_threshold:\n                 # This path shouldn't be taken with the given test cases.\n                 # Fallback to gradient if all else fails, normalized.\n                 g_temp = gradient(r_istar)\n                 tau_hat = g_temp / np.linalg.norm(g_temp)\n            else:\n                 tau_hat = t_alt / norm_t_alt\n        else:\n            tau_hat = t / norm_t\n\n        # 3. Compute climbing image force from its components\n        g = gradient(r_istar)\n        g_dot_tau = np.dot(g, tau_hat)\n        \n        g_parallel = g_dot_tau * tau_hat\n        g_perp = g - g_parallel\n        \n        # Force is defined as F_CI = g_parallel - g_perp\n        F = g_parallel - g_perp\n        \n        # 4. Perform verification checks\n        epsilon = 1e-8\n\n        # Check 1: F_parallel component matches g_parallel component\n        F_dot_tau = np.dot(F, tau_hat)\n        check1 = abs(F_dot_tau - g_dot_tau)  epsilon\n        \n        # Check 2: F_perp component equals -g_perp\n        F_perp = F - F_dot_tau * tau_hat\n        check2 = np.linalg.norm(F_perp - (-g_perp))  epsilon\n\n        # Check 3: F_perp is energetically downhill with respect to g_perp\n        # This will be = 0 if check2 is met, due to F_perp ≈ -g_perp\n        dot_product_perp = np.dot(F_perp, g_perp)\n        check3 = dot_product_perp = 0.0 # Strict check as per definition\n\n        # Aggregate results\n        final_check = check1 and check2 and check3\n        results.append(final_check)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(str(res).lower() for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}