{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究高熵合金（HEAs）复杂的力学行为之前，首先必须理解它们为何能形成稳定的单相固溶体。本练习聚焦于热力学驱动力，特别是赋予这些合金名称的高构型熵（high configurational entropy）。通过计算混合吉布斯自由能（$ \\Delta G_{\\mathrm{mix}} $），你将直接应用支撑高熵合金稳定性的核心热力学原理，建立成分与相稳定性之间的关键联系 。",
            "id": "3752559",
            "problem": "在一个针对五元高熵合金（HEA）的分层多尺度工作流中，原子模拟提供了一个有效的每摩尔等压混合焓，该值在加工状态的一个小邻域内近似与成分无关。考虑一个由元素A、B、C、D和E组成的单相置换型随机固溶体，在温度 $T=1200\\,\\mathrm{K}$ 时，其摩尔分数为 $x_{\\mathrm{A}}=0.25$，$x_{\\mathrm{B}}=0.25$，$x_{\\mathrm{C}}=0.20$，$x_{\\mathrm{D}}=0.15$ 和 $x_{\\mathrm{E}}=0.15$。由小尺度计算提供的每摩尔混合焓为 $\\Delta H_{\\mathrm{mix}}=-5.0\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。假设压力效应可以忽略不计，并且与该状态下的理想构型熵贡献相比，非构型熵贡献（振动、电子、磁）很小。普适气体常数为 $R=8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$，且对数为自然对数。\n\n仅使用吉布斯自由能和置换固溶体理想混合构型熵的基本热力学定义，确定此状态下的摩尔混合吉布斯自由能。将最终能量以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位表示，并将答案四舍五入至四位有效数字。\n\n在您的计算过程中，简要论证结果的符号如何预示在一个并行原子-连续介质耦合中化学有序化与无序化的趋势，但最终答案仅报告所要求的数值。",
            "solution": "该问题经核实具有科学依据、提法恰当、客观且完整。这是一个应用于材料科学（特别是高熵合金）的标准热力学计算，所有必要的数据和条件都已提供且无矛盾。\n\n主要任务是计算给定状态下五元高熵合金的摩尔混合吉布斯自由能 $\\Delta G_{\\mathrm{mix}}$。定义该量的基本热力学关系是：\n$$\n\\Delta G_{\\mathrm{mix}} = \\Delta H_{\\mathrm{mix}} - T \\Delta S_{\\mathrm{mix}}\n$$\n其中 $\\Delta H_{\\mathrm{mix}}$ 是摩尔混合焓，$T$ 是绝对温度，$\\Delta S_{\\mathrm{mix}}$ 是摩尔混合熵。\n\n问题提供了以下数值：\n摩尔混合焓 $\\Delta H_{\\mathrm{mix}} = -5.0\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n温度 $T = 1200\\,\\mathrm{K}$。\n\n必须计算摩尔混合熵 $\\Delta S_{\\mathrm{mix}}$。问题指出，非构型熵贡献（振动、电子等）可以忽略不计。因此，总混合熵可以近似为理想混合构型熵 $\\Delta S_{\\mathrm{mix}}^{\\mathrm{config}}$。对于一个有 $N$ 个组分的多组分置换型随机固溶体，该值由以下统计力学公式给出：\n$$\n\\Delta S_{\\mathrm{mix}} \\approx \\Delta S_{\\mathrm{mix}}^{\\mathrm{config}} = -R \\sum_{i=1}^{N} x_i \\ln(x_i)\n$$\n其中 $R$ 是普适气体常数，$x_i$ 是组分 $i$ 的摩尔分数。\n\n该系统是一个五元合金（A、B、C、D、E），其摩尔分数如下：\n$x_{\\mathrm{A}} = 0.25$\n$x_{\\mathrm{B}} = 0.25$\n$x_{\\mathrm{C}} = 0.20$\n$x_{\\mathrm{D}} = 0.15$\n$x_{\\mathrm{E}} = 0.15$\n总和为 $\\sum x_i = 0.25+0.25+0.20+0.15+0.15 = 1.00$，符合要求。\n\n普适气体常数给定为 $R = 8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n\n首先，我们计算求和项 $\\sum x_i \\ln(x_i)$:\n$$\n\\sum_{i} x_i \\ln(x_i) = x_{\\mathrm{A}}\\ln(x_{\\mathrm{A}}) + x_{\\mathrm{B}}\\ln(x_{\\mathrm{B}}) + x_{\\mathrm{C}}\\ln(x_{\\mathrm{C}}) + x_{\\mathrm{D}}\\ln(x_{\\mathrm{D}}) + x_{\\mathrm{E}}\\ln(x_{\\mathrm{E}})\n$$\n$$\n\\sum_{i} x_i \\ln(x_i) = 2 \\times 0.25\\ln(0.25) + 0.20\\ln(0.20) + 2 \\times 0.15\\ln(0.15)\n$$\n使用自然对数值：\n$\\ln(0.25) \\approx -1.386294$\n$\\ln(0.20) \\approx -1.609438$\n$\\ln(0.15) \\approx -1.897120$\n该和变为：\n$$\n\\sum_{i} x_i \\ln(x_i) \\approx 2 \\times 0.25(-1.386294) + 0.20(-1.609438) + 2 \\times 0.15(-1.897120)\n$$\n$$\n\\sum_{i} x_i \\ln(x_i) \\approx -0.693147 - 0.321888 - 0.569136 = -1.584171\n$$\n现在，我们计算摩尔混合熵：\n$$\n\\Delta S_{\\mathrm{mix}} \\approx - (8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}) \\times (-1.584171)\n$$\n$$\n\\Delta S_{\\mathrm{mix}} \\approx 13.1706\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\n$$\n接下来，我们计算对吉布斯自由能的熵贡献 $T \\Delta S_{\\mathrm{mix}}$:\n$$\nT \\Delta S_{\\mathrm{mix}} \\approx (1200\\,\\mathrm{K}) \\times (13.1706\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1})\n$$\n$$\nT \\Delta S_{\\mathrm{mix}} \\approx 15804.7\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\n$$\n为了将其与混合焓合并，我们必须用相同的单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 来表示它:\n$$\nT \\Delta S_{\\mathrm{mix}} \\approx 15.8047\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\n$$\n最后，我们将已知的 $\\Delta H_{\\mathrm{mix}}$ 值和计算出的 $T \\Delta S_{\\mathrm{mix}}$ 值代入吉布斯自由能方程:\n$$\n\\Delta G_{\\mathrm{mix}} = \\Delta H_{\\mathrm{mix}} - T \\Delta S_{\\mathrm{mix}}\n$$\n$$\n\\Delta G_{\\mathrm{mix}} \\approx -5.0\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} - 15.8047\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\n$$\n$$\n\\Delta G_{\\mathrm{mix}} \\approx -20.8047\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\n$$\n问题要求将答案四舍五入至四位有效数字。\n$$\n\\Delta G_{\\mathrm{mix}} \\approx -20.80\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\n$$\n按照论证要求，$\\Delta G_{\\mathrm{mix}}$ 的符号预示了该相的稳定性。如本文计算所得，$\\Delta G_{\\mathrm{mix}}$ 的负值表明，从其纯组元形成随机固溶体是一个热力学自发过程。负值的巨大绝对值（$|\\Delta G_{\\mathrm{mix}}| \\gg 0$）表明混合驱动力很大，因此，在该温度下，无序单相固溶体具有高稳定性。这种稳定性源于能量上有利的（负）混合焓和大的正混合构型熵，这是高熵合金的特征。在一个并行原子-连续介质模型中，这个来自连续介质层面热力学的结果意味着，该系统有强烈的趋势保持为无序固溶体。它会抵抗诸如化学有序化（金属间化合物的形成）或相分离成多相等现象，这些现象将对应于较小的负值，甚至是正值的吉布斯自由能变化。与此连续介质模型耦合的原子模拟预计将显示出与随机分布一致的原子构型，从而验证高熵态的假设。",
            "answer": "$$\n\\boxed{-20.80}\n$$"
        },
        {
            "introduction": "在确认了材料的热力学稳定性后，下一步便是预测其力学性能。本练习将引导你应用柯西-玻恩法则（Cauchy-Born rule），这是一种经典的分层方法，旨在连接原子尺度（原子间势）和连续介质尺度（弹性常数）。通过这个实践，你将能够从微观描述中直接推导出宏观属性，从而掌握分层框架中一个强大（尽管是简化的）的信息传递方案 。",
            "id": "3752520",
            "problem": "考虑一种具有面心立方 (FCC) 晶格的等原子高熵合金 (HEA)。为了在分层多尺度框架中连接原子尺度和连续介质尺度，请使用柯西-玻恩定则，从一个通过有效介质近似来表示化学无序的有效中心对势中，推导出晶体的有效弹性常数。假设以下科学上真实的设定：\n\n- 在 $0\\,\\text{K}$ 时，晶格常数为 $a_0 = 3.60\\,\\text{\\AA}$。\n- 只考虑第一近邻相互作用，有 $z_1 = 12$ 个最近邻，距离为 $r_1 = a_0 / \\sqrt{2}$，键方向对应于 FCC 晶格的面心对角线。\n- 原子间相互作用由一个有效莫尔斯势 $\nV(r) = D_e\\left[\\exp\\!\\left(-2 a (r - r_0)\\right) - 2\\exp\\!\\left(-a (r - r_0)\\right)\\right],\n$ 建模，其参数为 $D_e = 0.30\\,\\text{eV}$，$a = 2.00\\,\\text{\\AA}^{-1}$，平衡距离为 $r_0 = r_1$。\n- 晶体数密度为 $\\rho = 4/a_0^3$。\n\n使用柯西-玻恩定则，并假设在 $r = r_0$ 处达到力学平衡，从而一阶导数项消失，从键方向贡献的晶格求和中计算立方弹性常数 $C_{11}$ 和 $C_{12}$，使用 $1\\,\\text{eV}/\\text{\\AA}^3 = 160.21766208\\,\\text{GPa}$ 将它们转换为吉帕斯卡 (GPa)，然后将它们与在并行原子-连续介质耦合框架中获得的基于分子动力学 (MD) 的估计值 $C_{11}^{\\mathrm{MD}} = 195\\,\\text{GPa}$ 和 $C_{12}^{\\mathrm{MD}} = 115\\,\\text{GPa}$ 进行比较。\n\n定义偏差度量 $\nD = \\sqrt{\\left(\\frac{C_{11}^{\\mathrm{CB}} - C_{11}^{\\mathrm{MD}}}{C_{11}^{\\mathrm{MD}}}\\right)^2 + \\left(\\frac{C_{12}^{\\mathrm{CB}} - C_{12}^{\\mathrm{MD}}}{C_{12}^{\\mathrm{MD}}}\\right)^2},\n$ 其中 $C_{ij}^{\\mathrm{CB}}$ 是柯西-玻恩结果，$C_{ij}^{\\mathrm{MD}}$ 是基于 MD 的估计值。\n\n计算 $D$ 并将您的答案四舍五入到四位有效数字。最终答案以不带单位的小数形式表示。",
            "solution": "该问题要求计算一个偏差度量 $D$，它量化了使用柯西-玻恩定则计算的弹性常数 ($C_{ij}^{\\mathrm{CB}}$) 与通过分子动力学模拟获得的弹性常数 ($C_{ij}^{\\mathrm{MD}}$) 之间的差异。该系统是一种等原子面心立方 (FCC) 高熵合金，其原子间相互作用由一个有效莫尔斯势建模。\n\n首先，我们建立理论框架。柯西-玻恩定则提供了原子尺度（原子间势）和连续介质尺度（弹性常数）之间的联系。对于一个由中心对势 $V(r)$ 描述且没有初始应力（即晶格处于力学平衡状态）的中心对称晶格，例如 FCC，可以推导出立方弹性常数的表达式。在仅考虑第一近邻相互作用的情况下，通过对所有键的贡献进行晶格求和，得到的标准表达式为：\n$$C_{11} = \\frac{1}{2a_0} \\frac{d^2V}{dr^2}\\bigg|_{r=r_1}$$\n$$C_{12} = \\frac{1}{4a_0} \\frac{d^2V}{dr^2}\\bigg|_{r=r_1}$$\n这些关系满足中心势在平衡状态下的柯西关系，即 $C_{12} = C_{44}$，并且对于这个特定的第一近邻模型，也意味着 $C_{11} = 2C_{12}$。\n\n问题给出了有效莫尔斯势：\n$$V(r) = D_e\\left[\\exp(-2 a (r - r_0)) - 2\\exp(-a (r - r_0))\\right]$$\n我们需要计算其二阶导数 $V''(r)$。一阶导数为：\n$$V'(r) = \\frac{dV}{dr} = D_e\\left[-2a\\exp(-2a(r-r_0)) + 2a\\exp(-a(r-r_0))\\right]$$\n二阶导数为：\n$$V''(r) = \\frac{d^2V}{dr^2} = D_e\\left[4a^2\\exp(-2a(r-r_0)) - 2a^2\\exp(-a(r-r_0))\\right]$$\n\n问题指明晶格处于平衡状态，势的平衡距离 $r_0$ 等于第一近邻距离 $r_1 = a_0 / \\sqrt{2}$。这确保了势的一阶导数在原子间距离处为零，$V'(r_1) = V'(r_0) = 0$，与无初始应力的假设一致。我们在 $r = r_1 = r_0$ 处计算二阶导数：\n$$V''(r_1) = V''(r_0) = D_e\\left[4a^2\\exp(0) - 2a^2\\exp(0)\\right] = D_e(4a^2 - 2a^2) = 2a^2 D_e$$\n\n现在，我们代入势参数的给定值：$D_e = 0.30\\,\\text{eV}$ 和 $a = 2.00\\,\\text{\\AA}^{-1}$。\n$$V''(r_1) = 2 \\times (2.00\\,\\text{\\AA}^{-1})^2 \\times (0.30\\,\\text{eV}) = 2 \\times 4.00\\,\\text{\\AA}^{-2} \\times 0.30\\,\\text{eV} = 2.40\\,\\text{eV}/\\text{\\AA}^2$$\n\n根据这个结果和给定的晶格常数 $a_0 = 3.60\\,\\text{\\AA}$，我们可以计算以 $\\text{eV}/\\text{\\AA}^3$ 为单位的弹性常数：\n$$C_{11}^{\\mathrm{CB}} = \\frac{1}{2a_0}V''(r_1) = \\frac{1}{2 \\times 3.60\\,\\text{\\AA}} \\times (2.40\\,\\text{eV}/\\text{\\AA}^2) = \\frac{2.40}{7.20}\\,\\text{eV}/\\text{\\AA}^3 = \\frac{1}{3}\\,\\text{eV}/\\text{\\AA}^3$$\n$$C_{12}^{\\mathrm{CB}} = \\frac{1}{4a_0}V''(r_1) = \\frac{1}{4 \\times 3.60\\,\\text{\\AA}} \\times (2.40\\,\\text{eV}/\\text{\\AA}^2) = \\frac{2.40}{14.4}\\,\\text{eV}/\\text{\\AA}^3 = \\frac{1}{6}\\,\\text{eV}/\\text{\\AA}^3$$\n\n接下来，我们使用提供的转换因子 $1\\,\\text{eV}/\\text{\\AA}^3 = 160.21766208\\,\\text{GPa}$，将这些值转换为吉帕斯卡 (GPa)。\n$$C_{11}^{\\mathrm{CB}} = \\frac{1}{3} \\times 160.21766208\\,\\text{GPa} \\approx 53.4059\\,\\text{GPa}$$\n$$C_{12}^{\\mathrm{CB}} = \\frac{1}{6} \\times 160.21766208\\,\\text{GPa} \\approx 26.7029\\,\\text{GPa}$$\n\n最后，我们使用计算出的柯西-玻恩值和给定的基于 MD 的估计值 $C_{11}^{\\mathrm{MD}} = 195\\,\\text{GPa}$ 和 $C_{12}^{\\mathrm{MD}} = 115\\,\\text{GPa}$ 来计算偏差度量 $D$。\n$$D = \\sqrt{\\left(\\frac{C_{11}^{\\mathrm{CB}} - C_{11}^{\\mathrm{MD}}}{C_{11}^{\\mathrm{MD}}}\\right)^2 + \\left(\\frac{C_{12}^{\\mathrm{CB}} - C_{12}^{\\mathrm{MD}}}{C_{12}^{\\mathrm{MD}}}\\right)^2}$$\n我们计算相对差异：\n$$\\frac{C_{11}^{\\mathrm{CB}} - C_{11}^{\\mathrm{MD}}}{C_{11}^{\\mathrm{MD}}} = \\frac{53.4059 - 195}{195} = \\frac{-141.5941}{195} \\approx -0.72612$$\n$$\\frac{C_{12}^{\\mathrm{CB}} - C_{12}^{\\mathrm{MD}}}{C_{12}^{\\mathrm{MD}}} = \\frac{26.7029 - 115}{115} = \\frac{-88.2971}{115} \\approx -0.76780$$\n\n现在，我们将这些值代入 $D$ 的表达式中：\n$$D = \\sqrt{(-0.72612)^2 + (-0.76780)^2}$$\n$$D = \\sqrt{0.52727 + 0.58952} = \\sqrt{1.11679} \\approx 1.05678$$\n\n将结果四舍五入到四位有效数字，我们得到：\n$$D \\approx 1.057$$",
            "answer": "$$\n\\boxed{1.057}\n$$"
        },
        {
            "introduction": "虽然分层模型功能强大，但有些问题，如裂纹扩展的动态过程，则需要对原子和连续介质区域进行并发耦合（concurrent coupling）。最后的这个练习旨在解决此类并发方案中的一个关键挑战：如何最大限度地减少两种模型界面处的人为效应。通过优化重叠区域的大小以减少伪波反射，你将接触到在创建无缝且具有物理意义的并发模拟时所涉及的实际困难和权衡 。",
            "id": "3752618",
            "problem": "考虑沿代表高熵合金（HEA）的杆传播的一维纵向弹性波。左侧域通过分子动力学（MD）在原子尺度上建模，右侧域通过有限元（FE）方法在连续介质尺度上建模。通过长度为 $L_{\\mathrm{o}}$ 的重叠区域实现并发耦合，在该区域中材料属性平滑混合。假设横截面积 $A$ 均匀，并设 MD 和 FE 区域的特征分别为密度和杨氏模量对 $\\left(\\rho_{\\mathrm{MD}},E_{\\mathrm{MD}}\\right)$ 和 $\\left(\\rho_{\\mathrm{FE}},E_{\\mathrm{FE}}\\right)$。重叠区域的属性从 $x=0$ 处的 MD 值线性混合到 $x=L_{\\mathrm{o}}$ 处的 FE 值。角频率为 $\\omega$ 的时谐纵波从 MD 侧入射。\n\n基本原理：\n- 牛顿第二定律和线性弹性理论导出了一维波动方程，在时谐拟设 $u(x,t)=\\Re\\left\\{U(x)\\mathrm{e}^{\\mathrm{i}\\omega t}\\right\\}$下，该方程简化为亥姆霍兹型方程 $U''(x)+k(x)^{2}U(x)=0$，其中 $k(x)=\\omega/c(x)$ 且 $c(x)=\\sqrt{E(x)/\\rho(x)}$。\n- 在每个材料界面处，必须满足位移 $u(x)$ 和牵引力 $\\sigma(x)=E(x)\\,\\partial u/\\partial x$ 的连续性。\n\n在频域中，均匀段中的场可以表示为 $U(x)=A\\,\\mathrm{e}^{\\mathrm{i}k x}+B\\,\\mathrm{e}^{-\\mathrm{i}k x}$，其中 $A$ 和 $B$ 分别是右行波和左行波的振幅。穿过从段 $j$ 到段 $j+1$ 的界面时，连续性条件意味着 $\\left(A_{j},B_{j}\\right)$ 和 $\\left(A_{j+1},B_{j+1}\\right)$ 之间存在线性关系；穿过长度为 $d$ 的均匀段会在 $A$ 和 $B$ 上引起 $\\mathrm{e}^{\\pm \\mathrm{i}k d}$ 的相移。通过将这些从 MD 侧穿过重叠区域到 FE 侧的线性映射进行组合，可以获得一个全局传递算子，该算子在 FE 侧施加仅出射波条件时，确定 MD 入口处的反射振幅 $R$。\n\n定义一个目标函数 $J(L_{\\mathrm{o}})=\\left|R(L_{\\mathrm{o}})\\right|+\\alpha\\,L_{\\mathrm{o}}$，其中第一项惩罚虚假反射，第二项惩罚与重叠区域大小成正比的计算成本。您的任务是为每个测试案例计算能使 $J(L_{\\mathrm{o}})$ 最小化的重叠长度 $L_{\\mathrm{o}}$（从提供的离散候选集合中选择）。\n\n离散化与建模要求：\n- 将重叠区域离散为 $N$ 个宽度均匀的均匀单元，其中 $N=\\left\\lfloor L_{\\mathrm{o}}/\\Delta x \\right\\rfloor$ 且 $N\\geq 1$。\n- 在重叠区域内，使用归一化坐标 $s_{j}=j/N$ 定义单元 $j\\in\\{0,\\dots,N-1\\}$ 处的线性混合属性为 $E_{j}=E_{\\mathrm{MD}}+(E_{\\mathrm{FE}}-E_{\\mathrm{MD}})\\,s_{j}$ 和 $\\rho_{j}=\\rho_{\\mathrm{MD}}+(\\rho_{\\mathrm{FE}}-\\rho_{\\mathrm{MD}})\\,s_{j}$，以及 $k_{j}=\\omega/\\sqrt{E_{j}/\\rho_{j}}$。\n- 对于每个均匀单元 $j$，相位映射由对角算子表示，其元素为作用于 $(A_{j},B_{j})$ 的 $\\mathrm{e}^{\\mathrm{i}k_{j}\\Delta x}$ 和 $\\mathrm{e}^{-\\mathrm{i}k_{j}\\Delta x}$。\n- 在连续单元之间的每个界面处，以及在 MD-到-第一单元 和 最后一单元-到-FE 的界面处，强制位移和牵引力的连续性，以构建一个 $2\\times 2$ 的界面算子。对界面的每一侧使用牵引力系数 $r=\\!E\\,k$。\n- 组合这些算子以获得从 MD 入口到 FE 出口的总传递算子，并在 FE 侧使用仅出射波条件，以纯数学方式提取 MD 入口处的反射振幅 $R$。\n- 对每个候选 $L_{\\mathrm{o}}$，计算 $J(L_{\\mathrm{o}})$ 并选择最小值点。\n\n单位与报告：\n- 使用单位：$\\rho$ 为 $\\mathrm{kg}/\\mathrm{m}^{3}$，$E$ 为 $\\mathrm{Pa}$，$\\omega$ 为 $\\mathrm{rad}/\\mathrm{s}$，$A$ 为 $\\mathrm{m}^{2}$（请注意，在此一维纵向公式中 $A$ 会被消去），$L_{\\mathrm{o}}$ 和 $\\Delta x$ 为 $\\mathrm{m}$，$\\alpha$ 为 $\\mathrm{m}^{-1}$。\n- 以 $\\mathrm{m}$ 为单位表示最优重叠长度 $L_{\\mathrm{o}}^{\\star}$，四舍五入至六位小数。\n- 角度必须以弧度为单位。\n\n测试套件：\n- 案例 1（中等失配，中等频率）：$\\rho_{\\mathrm{MD}}=7800\\,\\mathrm{kg}/\\mathrm{m}^{3}$，$E_{\\mathrm{MD}}=1.60\\times 10^{11}\\,\\mathrm{Pa}$，$\\rho_{\\mathrm{FE}}=8000\\,\\mathrm{kg}/\\mathrm{m}^{3}$，$E_{\\mathrm{FE}}=1.90\\times 10^{11}\\,\\mathrm{Pa}$，$\\omega=2\\pi\\times 8.0\\times 10^{6}\\,\\mathrm{rad}/\\mathrm{s}$，$A=1.0\\times 10^{-6}\\,\\mathrm{m}^{2}$，$\\Delta x=2.5\\times 10^{-4}\\,\\mathrm{m}$，候选 $L_{\\mathrm{o}}\\in\\{5.0\\times 10^{-4},1.0\\times 10^{-3},2.0\\times 10^{-3},3.0\\times 10^{-3}\\}\\,\\mathrm{m}$，$\\alpha=20\\,\\mathrm{m}^{-1}$。\n- 案例 2（接近匹配，较低频率）：$\\rho_{\\mathrm{MD}}=7900\\,\\mathrm{kg}/\\mathrm{m}^{3}$，$E_{\\mathrm{MD}}=1.80\\times 10^{11}\\,\\mathrm{Pa}$，$\\rho_{\\mathrm{FE}}=7950\\,\\mathrm{kg}/\\mathrm{m}^{3}$，$E_{\\mathrm{FE}}=1.82\\times 10^{11}\\,\\mathrm{Pa}$，$\\omega=2\\pi\\times 5.0\\times 10^{6}\\,\\mathrm{rad}/\\mathrm{s}$，$A=1.0\\times 10^{-6}\\,\\mathrm{m}^{2}$，$\\Delta x=2.5\\times 10^{-4}\\,\\mathrm{m}$，候选 $L_{\\mathrm{o}}\\in\\{5.0\\times 10^{-4},1.0\\times 10^{-3},2.0\\times 10^{-3},3.0\\times 10^{-3}\\}\\,\\mathrm{m}$，$\\alpha=50\\,\\mathrm{m}^{-1}$。\n- 案例 3（强失配，较高频率）：$\\rho_{\\mathrm{MD}}=7500\\,\\mathrm{kg}/\\mathrm{m}^{3}$，$E_{\\mathrm{MD}}=1.30\\times 10^{11}\\,\\mathrm{Pa}$，$\\rho_{\\mathrm{FE}}=8200\\,\\mathrm{kg}/\\mathrm{m}^{3}$，$E_{\\mathrm{FE}}=2.10\\times 10^{11}\\,\\mathrm{Pa}$，$\\omega=2\\pi\\times 1.50\\times 10^{7}\\,\\mathrm{rad}/\\mathrm{s}$，$A=1.0\\times 10^{-6}\\,\\mathrm{m}^{2}$，$\\Delta x=2.5\\times 10^{-4}\\,\\mathrm{m}$，候选 $L_{\\mathrm{o}}\\in\\{5.0\\times 10^{-4},1.0\\times 10^{-3},2.0\\times 10^{-3},3.0\\times 10^{-3}\\}\\,\\mathrm{m}$，$\\alpha=10\\,\\mathrm{m}^{-1}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是按上述顺序列出的各案例的最优 $L_{\\mathrm{o}}^{\\star}$（单位为米，四舍五入至六位小数）（例如，[0.001000,0.000500,0.002000]）。",
            "solution": "该问题是有效的，因为它在一维波动力学方面有科学依据，问题设定良好，目标明确，并为其求解提供了一套完整且一致的参数和指令。我们将按照规定，通过实现传递矩阵法来解决该问题。\n\n该物理系统是一个具有空间变化材料属性的一维杆，这导致了时谐纵波空间部分 $U(x)$ 的亥姆霍兹型方程：\n$$\n\\frac{d^2U(x)}{dx^2} + k(x)^2 U(x) = 0\n$$\n其中 $k(x) = \\omega / c(x)$ 是空间变化的波数，$\\omega$ 是角频率，而 $c(x) = \\sqrt{E(x)/\\rho(x)}$ 是由杨氏模量 $E(x)$ 和密度 $\\rho(x)$ 推导出的局部波速。\n\n解决方案的核心是传递矩阵法，该方法关联了在材料不同截面上传播的前向波和后向波的振幅。在任何波数为 $k$ 的均匀区域中，解是平面波的叠加：\n$$\nU(x) = A e^{\\mathrm{i}k x} + B e^{-\\mathrm{i}k x}\n$$\n其中 $A$ 和 $B$ 分别是右行波和左行波的复振幅。我们可以用向量 $\\mathbf{v} = \\begin{pmatrix} A \\\\ B \\end{pmatrix}$ 来表示波场的状态。\n\n指定的模型将系统分为三部分：一个半无限的 MD 区域（$x<0$）、一个长度为 $L_o$ 的有限重叠区域（$0 \\le x \\le L_o$），以及一个半无限的 FE 区域（$x>L_o$）。重叠区域被进一步离散为 $N = \\lfloor L_{\\mathrm{o}}/\\Delta x \\rfloor$ 个宽度为 $\\Delta x$ 的均匀单元。\n\n该解决方案涉及两种类型的算子：\n1.  **界面传递矩阵 $\\mathbf{T}$**：该矩阵关联了两种不同介质界面两侧的波振幅。\n2.  **传播矩阵 $\\mathbf{P}$**：该矩阵描述了波振幅在穿过一个均匀单元时相位的演化。\n\n通过按正确顺序组合这些矩阵，我们构建了一个总传递矩阵 $\\mathbf{M}$，它将 MD 区域的波振幅 $\\mathbf{v}_{\\mathrm{MD}}$ 与 FE 区域的波振幅 $\\mathbf{v}_{\\mathrm{FE}}$ 联系起来：\n$$\n\\mathbf{v}_{\\mathrm{FE}} = \\mathbf{M} \\mathbf{v}_{\\mathrm{MD}}\n$$\n\n**步骤 1：界面传递矩阵的推导**\n在“左”介质（L）和“右”介质（R）之间的界面处，我们强制位移 $U(x)$ 和牵引力的连续性。问题将牵引力定义为 $\\sigma(x) = E(x)\\frac{dU}{dx}$。设界面位于 $x_i$。\n位移连续性：$U_L(x_i) = U_R(x_i)$\n$$\nA_L + B_L = A_R + B_R\n$$\n牵引力连续性：$E_L U_L'(x_i) = E_R U_R'(x_i)$\n$$\nE_L (\\mathrm{i}k_L A_L - \\mathrm{i}k_L B_L) = E_R (\\mathrm{i}k_R A_R - \\mathrm{i}k_R B_R)\n$$\n使用“牵引力系数” $r = E k = E (\\omega/c) = \\omega\\sqrt{E\\rho}$，这可以简化为：\n$$\nr_L (A_L - B_L) = r_R (A_R - B_R)\n$$\n求解这两个关于 $A_R$ 和 $B_R$ 的线性方程组（用 $A_L$ 和 $B_L$ 表示），得到界面传递矩阵 $\\mathbf{T}_{L\\to R}$：\n$$\n\\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1 + r_L/r_R & 1 - r_L/r_R \\\\ 1 - r_L/r_R & 1 + r_L/r_R \\end{pmatrix} \\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix}\n$$\n因此，$\\mathbf{T}_{L\\to R} = \\frac{1}{2r_R} \\begin{pmatrix} r_R+r_L & r_R-r_L \\\\ r_R-r_L & r_R+r_L \\end{pmatrix}$。\n\n**步骤 2：传播矩阵的推导**\n在宽度为 $\\Delta x$、波数为 $k_j$ 的均匀单元 $j$ 内，波从其入口 $x_{in}$ 传播到出口 $x_{out} = x_{in} + \\Delta x$。出口处的振幅（$A_{out}, B_{out}$）通过一个简单的相移与入口处的振幅（$A_{in}, B_{in}$）相关联：\n$$\nA_{out} = A_{in} e^{\\mathrm{i}k_j \\Delta x} \\quad , \\quad B_{out} = B_{in} e^{-\\mathrm{i}k_j \\Delta x}\n$$\n这定义了传播矩阵 $\\mathbf{P}_j$：\n$$\n\\mathbf{P}_j = \\begin{pmatrix} e^{\\mathrm{i}k_j \\Delta x} & 0 \\\\ 0 & e^{-\\mathrm{i}k_j \\Delta x} \\end{pmatrix}\n$$\n\n**步骤 3：总传递矩阵的构建**\n重叠区域由 $N$ 个单元组成，索引为 $j=0, \\dots, N-1$。单元 $j$ 的材料属性使用归一化坐标 $s_j = j/N$ 的线性混合规则计算：\n$E_j = E_{\\mathrm{MD}} + (E_{\\mathrm{FE}} - E_{\\mathrm{MD}})s_j$\n$\\rho_j = \\rho_{\\mathrm{MD}} + (\\rho_{\\mathrm{FE}} - \\rho_{\\mathrm{MD}})s_j$\n根据这些，我们计算 $k_j = \\omega/\\sqrt{E_j/\\rho_j}$ 和 $r_j = \\omega\\sqrt{E_j\\rho_j}$。\n\n请注意，对于单元 $j=0$，$s_0=0$，这意味着 $E_0=E_{\\mathrm{MD}}$ 和 $\\rho_0=\\rho_{\\mathrm{MD}}$。因此，MD 区域和单元 0 之间的界面是无反射的，其传递矩阵 $\\mathbf{T}_{\\mathrm{MD}\\to 0}$ 是单位矩阵。\n\n总传递矩阵 $\\mathbf{M}$ 是从重叠区域开始到 FE 区域的所有传播矩阵和界面矩阵的有序乘积：\n$$\n\\mathbf{M} = \\mathbf{T}_{N-1 \\to \\mathrm{FE}} \\cdot \\mathbf{P}_{N-1} \\cdot \\mathbf{T}_{N-2 \\to N-1} \\cdots \\mathbf{T}_{0 \\to 1} \\cdot \\mathbf{P}_0\n$$\n其中第一个界面的矩阵 $\\mathbf{T}_{\\mathrm{MD}\\to 0}$ 被省略，因为它是单位矩阵。\n\n**步骤 4：反射系数的计算**\n入射波来自 MD 侧，因此我们可以将其振幅归一化为 $A_{\\mathrm{MD}}=1$。反射振幅为 $B_{\\mathrm{MD}} = R$，其中 $R$ 是反射系数。因此，$\\mathbf{v}_{\\mathrm{MD}} = \\begin{pmatrix} 1 \\\\ R \\end{pmatrix}$。\nFE 侧的仅出射波条件意味着没有来自 $x=+\\infty$ 的波，所以 $B_{\\mathrm{FE}} = 0$。因此，$\\mathbf{v}_{\\mathrm{FE}} = \\begin{pmatrix} A_{\\mathrm{FE}} \\\\ 0 \\end{pmatrix}$。\n\n将这些代入全局关系 $\\mathbf{v}_{\\mathrm{FE}} = \\mathbf{M} \\mathbf{v}_{\\mathrm{MD}}$：\n$$\n\\begin{pmatrix} A_{\\mathrm{FE}} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} M_{11} & M_{12} \\\\ M_{21} & M_{22} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ R \\end{pmatrix}\n$$\n第二行给出了方程 $0 = M_{21} \\cdot 1 + M_{22} \\cdot R$，由此我们解出 $R$：\n$$\nR = - \\frac{M_{21}}{M_{22}}\n$$\n\n**步骤 5：优化**\n对于每个候选重叠长度 $L_{\\mathrm{o}}$，我们执行上述计算以找到反射系数 $R(L_{\\mathrm{o}})$。然后，我们评估目标函数：\n$$\nJ(L_{\\mathrm{o}}) = |R(L_{\\mathrm{o}})| + \\alpha L_{\\mathrm{o}}\n$$\n我们为提供的候选集中的每个 $L_{\\mathrm{o}}$ 计算 $J(L_{\\mathrm{o}})$，并选择产生最小 $J$ 值的那个。这个 $L_{\\mathrm{o}}$ 就是最优重叠长度 $L_{\\mathrm{o}}^{\\star}$。对每个测试案例重复整个过程。\n\n待实现的算法如下：\n对于每个测试案例：\n1. 初始化一个列表来存储结果 $(J, L_{\\mathrm{o}})$。\n2. 对于每个候选 $L_{\\mathrm{o}}$：\n    a. 计算 $N = \\lfloor L_{\\mathrm{o}}/\\Delta x \\rfloor$。\n    b. 计算所有 $N$ 个单元以及 FE 区域的材料属性（$r_j$, $k_j$）和（$r_{\\mathrm{FE}}$）。\n    c. 从 $\\mathbf{P}_0$ 开始，一直到 $\\mathbf{T}_{N-1 \\to \\mathrm{FE}}$，通过按传播的相反顺序前乘构成的矩阵，顺序构建总传递矩阵 $\\mathbf{M}$。\n    d. 计算 $R = -M_{21}/M_{22}$。\n    e. 计算 $J(L_{\\mathrm{o}}) = |R| + \\alpha L_{\\mathrm{o}}$。\n    f. 存储序对 $(J(L_{\\mathrm{o}}), L_{\\mathrm{o}})$。\n3. 找到具有最小 $J$ 值的序对。对应的 $L_{\\mathrm{o}}$ 是此测试案例的最优长度 $L_{\\mathrm{o}}^{\\star}$。\n4. 处理完所有测试案例后，格式化并打印最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the final result.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            \"rho_md\": 7800.0, \"e_md\": 1.60e11,\n            \"rho_fe\": 8000.0, \"e_fe\": 1.90e11,\n            \"omega\": 2 * np.pi * 8.0e6,\n            \"dx\": 2.5e-4,\n            \"lo_candidates\": [5.0e-4, 1.0e-3, 2.0e-3, 3.0e-3],\n            \"alpha\": 20.0\n        },\n        # Case 2\n        {\n            \"rho_md\": 7900.0, \"e_md\": 1.80e11,\n            \"rho_fe\": 7950.0, \"e_fe\": 1.82e11,\n            \"omega\": 2 * np.pi * 5.0e6,\n            \"dx\": 2.5e-4,\n            \"lo_candidates\": [5.0e-4, 1.0e-3, 2.0e-3, 3.0e-3],\n            \"alpha\": 50.0\n        },\n        # Case 3\n        {\n            \"rho_md\": 7500.0, \"e_md\": 1.30e11,\n            \"rho_fe\": 8200.0, \"e_fe\": 2.10e11,\n            \"omega\": 2 * np.pi * 1.50e7,\n            \"dx\": 2.5e-4,\n            \"lo_candidates\": [5.0e-4, 1.0e-3, 2.0e-3, 3.0e-3],\n            \"alpha\": 10.0\n        }\n    ]\n\n    optimal_los = []\n\n    for case in test_cases:\n        optimal_los.append(find_optimal_lo(case))\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join([f'{lo:.6f}' for lo in optimal_los])}]\")\n\n\ndef find_optimal_lo(params):\n    \"\"\"\n    Finds the optimal overlap length Lo for a single test case.\n    \"\"\"\n    rho_md, e_md = params[\"rho_md\"], params[\"e_md\"]\n    rho_fe, e_fe = params[\"rho_fe\"], params[\"e_fe\"]\n    omega = params[\"omega\"]\n    dx = params[\"dx\"]\n    lo_candidates = params[\"lo_candidates\"]\n    alpha = params[\"alpha\"]\n\n    min_j = float('inf')\n    optimal_lo = -1.0\n\n    r_fe = omega * np.sqrt(e_fe * rho_fe)\n    \n    for lo in lo_candidates:\n        n_cells = int(np.floor(lo / dx))\n        if n_cells  1:\n            # Per problem spec, N must be >= 1.\n            # This case won't be hit with the given test data.\n            continue\n        \n        # --- Pre-calculate properties for all cells ---\n        s_vals = np.arange(n_cells) / n_cells\n        e_cells = e_md + (e_fe - e_md) * s_vals\n        rho_cells = rho_md + (rho_fe - rho_md) * s_vals\n        \n        r_cells = omega * np.sqrt(e_cells * rho_cells)\n        k_cells = omega / np.sqrt(e_cells / rho_cells)\n\n        # --- Construct total transfer matrix M ---\n        # The first interface T_{MD -> 0} is identity because cell 0 has MD properties.\n        # So, the chain starts with P_0.\n        \n        # P_0\n        phase = 1j * k_cells[0] * dx\n        M = np.array([[np.exp(phase), 0], [0, np.exp(-phase)]], dtype=np.cdouble)\n\n        # Chain multiplication for the rest of the cells\n        for j in range(1, n_cells):\n            # Interface T_{j-1 -> j}\n            r_left = r_cells[j-1]\n            r_right = r_cells[j]\n            p = r_left / r_right\n            t11 = 0.5 * (1 + p)\n            t12 = 0.5 * (1 - p)\n            T_interface = np.array([[t11, t12], [t12, t11]], dtype=np.cdouble)\n            M = T_interface @ M\n            \n            # Propagation P_j\n            phase = 1j * k_cells[j] * dx\n            P_prop = np.array([[np.exp(phase), 0], [0, np.exp(-phase)]], dtype=np.cdouble)\n            M = P_prop @ M\n            \n        # Final interface T_{N-1 -> FE}\n        r_left = r_cells[n_cells - 1]\n        r_right = r_fe\n        p = r_left / r_right\n        t11 = 0.5 * (1 + p)\n        t12 = 0.5 * (1 - p)\n        T_final = np.array([[t11, t12], [t12, t11]], dtype=np.cdouble)\n        M = T_final @ M\n\n        # --- Calculate reflection and objective function J ---\n        m21, m22 = M[1, 0], M[1, 1]\n        \n        if np.abs(m22)  1e-12:\n            # Avoid division by zero, though unlikely with physical properties.\n            # A very large reflection would be implied.\n            R = complex(1e12, 0)\n        else:\n            R = -m21 / m22\n            \n        J = np.abs(R) + alpha * lo\n        \n        if J  min_j:\n            min_j = J\n            optimal_lo = lo\n            \n    return optimal_lo\n\n\nsolve()\n```"
        }
    ]
}