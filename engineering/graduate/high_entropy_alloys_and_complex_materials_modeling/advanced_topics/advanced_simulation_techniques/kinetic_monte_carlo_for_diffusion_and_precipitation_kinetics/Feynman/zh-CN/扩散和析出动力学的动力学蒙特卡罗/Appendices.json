{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在建立微观尺度上的能量参数与宏观尺度上可观测的扩散现象之间的桥梁。通过一个具体的设例，您将应用玻尔兹曼分布和过渡态理论，从基本的空位形成能（$E_f$）和迁移能（$E_m$）出发，推导并计算出材料的扩散系数（$D(T)$）。这项实践有助于您深入理解空位介导扩散机制的物理基础，并将理论知识应用于实际的定量分析中 。",
            "id": "3747898",
            "problem": "考虑一个在动态蒙特卡罗 (kMC) 框架中建模的面心立方高熵合金，用于研究空位介导的扩散和析出动力学。假设存在一个由热激活过程控制的有效单物种空位机制。平衡空位浓度遵循缺陷形成的玻尔兹曼分布，基本交换事件速率遵循过渡态理论。忽略振动形成熵（或假设其被吸收到有效形成能中），并假设空位浓度是稀疏的。使用以下物理上一致的参数：\n- 温度：$T = 1300\\,\\mathrm{K}$，\n- 空位形成能：$E_f = 1.60\\,\\mathrm{eV}$，\n- 空位迁移能：$E_m = 0.90\\,\\mathrm{eV}$，\n- 空位-原子交换的尝试频率（指前因子）：$\\nu_0 = 1.00 \\times 10^{13}\\,\\mathrm{s}^{-1}$，\n- 晶格常数：$a = 0.360\\,\\mathrm{nm}$，\n- 最近邻配位数（面心立方）：$z = 12$，\n- 最近邻跳跃距离（面心立方）：$\\lambda = a/\\sqrt{2}$，\n- 面心立方自扩散的空位相关因子：$f = 0.781$，\n- 玻尔兹曼常数：$k_B = 8.617333262 \\times 10^{-5}\\,\\mathrm{eV\\,K^{-1}}$。\n\n从以下基本原理出发：\n1. 在温度 $T$ 下，能量为 $E$ 的缺陷的平衡概率与 $\\exp(-E/(k_B T))$ 成正比。\n2. 根据过渡态理论，热激活过程的事件速率为 $r = \\nu_0 \\exp\\!\\left(-E_m/(k_B T)\\right)$。\n3. 对于 $d=3$ 维的无关随机行走，扩散系数为 $D = \\frac{1}{2d}\\lambda^2 \\Gamma$，其中 $\\Gamma$ 是总平均跳跃频率。对于空位介导的自扩散，引入相关因子 $f$ 以考虑反向关联效应。\n\n结合上述基本原理和面心立方晶格的几何结构，推导代表性物种的温度依赖性扩散系数 $D(T)$ 的表达式，用 $E_f$、$E_m$、$k_B$、$T$、$\\nu_0$、$a$ 和 $f$ 表示。然后，数值计算：\n- 平衡空位浓度 $c_v$，\n- 以及由此产生的扩散系数 $D(T)$。\n\n最终的扩散系数以 $\\mathrm{m^2\\,s^{-1}}$ 为单位表示，并将平衡空位浓度视为无量纲。将 $c_v$ 和 $D(T)$ 四舍五入到四位有效数字。以数对 $\\big(c_v, D(T)\\big)$ 的形式提供您的最终数值答案。",
            "solution": "该问题要求推导面心立方（FCC）晶格中空位介导的自扩散系数 $D(T)$ 的表达式，然后在指定温度下数值计算平衡空位浓度 $c_v$ 和扩散系数 $D(T)$。\n\n首先，我们根据提供的基本原理推导必要的表达式。\n\n**1. 平衡空位浓度 ($c_v$)**\n根据提供的第一个基本原理，能量为 $E$ 的状态的平衡概率与 $\\exp(-E/(k_B T))$ 成正比。在晶格中形成一个空位需要能量 $E_f$。在一个有 $N$ 个原子格点的晶体中，产生 $n_v$ 个空位的方式有 $\\binom{N}{n_v}$ 种。形成 $n_v$ 个空位时吉布斯自由能的变化为 $\\Delta G = n_v E_f - T \\Delta S_{conf}$，其中 $\\Delta S_{conf}$ 是构型熵。对熵项使用斯特林近似，并对 $\\Delta G$ 关于 $n_v$ 求最小化，可得到平衡空位格点分数（浓度）。对于稀疏体系（$n_v \\ll N$）并按要求忽略振动形成熵，这简化为形成能的玻尔兹曼因子：\n$$c_v = \\frac{n_v}{N} = \\exp\\left(-\\frac{E_f}{k_B T}\\right)$$\n这给出了在给定温度 $T$ 下空格点的分数。\n\n**2. 自扩散系数 $D(T)$ 的推导**\n原子的扩散是通过其与相邻空位的交换来介导的。我们可以通过将原子扩散系数 $D(T)$ 与空位的性质联系起来进行推导。\n\n根据第二个基本原理，特定原子与相邻空位之间的交换速率 $\\omega$ 由过渡态理论给出：\n$$\\omega = \\nu_0 \\exp\\left(-\\frac{E_m}{k_B T}\\right)$$\n这里，$\\nu_0$ 是尝试频率，$E_m$ 是交换的能垒，即空位迁移能。\n\n空位本身的扩散系数 $D_v$ 可以使用第三个基本原理中的随机行走理论来确定。一个空位可以跳到其 $z$ 个相邻原子位点中的任何一个。单个空位的总跳跃频率 $\\Gamma_v$ 是可用跳跃方向数 $z$ 与每个方向的交换速率 $\\omega$ 的乘积：\n$$\\Gamma_v = z \\omega = z \\nu_0 \\exp\\left(-\\frac{E_m}{k_B T}\\right)$$\n假设空位的行走是无关的，其在三维晶格中的扩散系数为：\n$$D_v = \\frac{1}{6} \\lambda^2 \\Gamma_v = \\frac{1}{6} z \\lambda^2 \\omega$$\n其中 $\\lambda$ 是跳跃距离。\n\n示踪原子的自扩散系数 $D(T)$ 与空位扩散系数 $D_v$ 通过以下表达式相关联：\n$$D(T) = c_v f D_v$$\n这种关系源于原子只有在相邻位点存在空位时才能跳跃（概率为 $c_v$），并且原子的后续跳跃是相关的，这由相关因子 $f$ 来解释。代入 $c_v$ 和 $D_v$ 的表达式：\n$$D(T) = \\exp\\left(-\\frac{E_f}{k_B T}\\right) \\cdot f \\cdot \\left( \\frac{1}{6} z \\lambda^2 \\omega \\right)$$\n代入 $\\omega$ 的表达式：\n$$D(T) = f \\frac{z \\lambda^2}{6} \\exp\\left(-\\frac{E_f}{k_B T}\\right) \\nu_0 \\exp\\left(-\\frac{E_m}{k_B T}\\right)$$\n合并指数项得到一个阿伦尼乌斯型扩散方程：\n$$D(T) = f \\frac{z \\lambda^2 \\nu_0}{6} \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\n这可以写成 $D(T) = D_0 \\exp(-Q/(k_B T))$，其中 $Q = E_f + E_m$ 是扩散的总活化能，$D_0$ 是指前因子。\n\n对于指定的面心立方（FCC）晶格，几何参数为配位数 $z=12$ 和最近邻跳跃距离 $\\lambda = a/\\sqrt{2}$，其中 $a$ 是晶格常数。将这些代入 $D(T)$ 的表达式中：\n$$D(T) = f \\frac{12 \\cdot (a/\\sqrt{2})^2 \\nu_0}{6} \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\n$$D(T) = f \\frac{12 \\cdot (a^2/2) \\nu_0}{6} \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\n$$D(T) = f \\frac{6 a^2 \\nu_0}{6} \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\n最终推导出的扩散系数表达式为：\n$$D(T) = f a^2 \\nu_0 \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\n\n**3. 数值计算**\n给定以下参数：\n- $T = 1300\\,\\mathrm{K}$\n- $E_f = 1.60\\,\\mathrm{eV}$\n- $E_m = 0.90\\,\\mathrm{eV}$\n- $\\nu_0 = 1.00 \\times 10^{13}\\,\\mathrm{s}^{-1}$\n- $a = 0.360\\,\\mathrm{nm} = 0.360 \\times 10^{-9}\\,\\mathrm{m}$\n- $f = 0.781$\n- $k_B = 8.617333262 \\times 10^{-5}\\,\\mathrm{eV\\,K^{-1}}$\n\n首先，我们计算热能乘积 $k_B T$：\n$$k_B T = (8.617333262 \\times 10^{-5}\\,\\mathrm{eV\\,K^{-1}}) \\times (1300\\,\\mathrm{K}) \\approx 0.112025\\,\\mathrm{eV}$$\n\n**平衡空位浓度 ($c_v$) 的计算**：\n使用上面推导的公式：\n$$c_v = \\exp\\left(-\\frac{E_f}{k_B T}\\right) = \\exp\\left(-\\frac{1.60\\,\\mathrm{eV}}{0.112025\\,\\mathrm{eV}}\\right) = \\exp(-14.2825)$$\n$$c_v \\approx 6.27038 \\times 10^{-7}$$\n四舍五入到四位有效数字，空位浓度为：\n$$c_v \\approx 6.270 \\times 10^{-7}$$\n\n**扩散系数 ($D(T)$) 的计算**：\n扩散的总活化能为 $Q = E_f + E_m$：\n$$Q = 1.60\\,\\mathrm{eV} + 0.90\\,\\mathrm{eV} = 2.50\\,\\mathrm{eV}$$\n扩散方程中指数的参数为：\n$$-\\frac{Q}{k_B T} = -\\frac{2.50\\,\\mathrm{eV}}{0.112025\\,\\mathrm{eV}} \\approx -22.3163$$\n指数项为 $\\exp(-22.3163) \\approx 1.9392 \\times 10^{-10}$。\n\n指前因子 $D_0 = f a^2 \\nu_0$ 为：\n$$a^2 = (0.360 \\times 10^{-9}\\,\\mathrm{m})^2 = 1.296 \\times 10^{-19}\\,\\mathrm{m}^2$$\n$$D_0 = (0.781) \\times (1.296 \\times 10^{-19}\\,\\mathrm{m}^2) \\times (1.00 \\times 10^{13}\\,\\mathrm{s}^{-1})$$\n$$D_0 = 1.012176 \\times 10^{-6}\\,\\mathrm{m^2\\,s^{-1}}$$\n\n最后，我们计算 $D(T) = D_0 \\exp(-Q/(k_B T))$：\n$$D(T) = (1.012176 \\times 10^{-6}\\,\\mathrm{m^2\\,s^{-1}}) \\times (1.9392 \\times 10^{-10})$$\n$$D(T) \\approx 1.96294 \\times 10^{-16}\\,\\mathrm{m^2\\,s^{-1}}$$\n四舍五入到四位有效数字，扩散系数为：\n$$D(T) \\approx 1.963 \\times 10^{-16}\\,\\mathrm{m^2\\,s^{-1}}$$\n\n计算出的数值为 $c_v \\approx 6.270 \\times 10^{-7}$ (无量纲) 和 $D(T) \\approx 1.963 \\times 10^{-16}\\,\\mathrm{m^2\\,s^{-1}}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.270 \\times 10^{-7},  1.963 \\times 10^{-16}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "动力学蒙特卡罗模拟的核心产出是体系中粒子的运动轨迹，然而，原始数据本身并非终点。本练习的核心任务是从这些轨迹数据中提取出具有物理意义的宏观性质。您将首先从理论上推导均方位移（MSD）与时间之间的线性关系，然后通过分析模拟生成的轨迹数据，运用统计回归方法来估算扩散系数，并为其构建置信区间 。",
            "id": "3747912",
            "problem": "考虑在多组分高熵合金（HEA）中，每种化学物质的各向同性、空位介导的扩散过程，该过程通过动力学蒙特卡洛（kMC）方法建模。kMC的输出是每种物质的粒子位置的时间序列。您的任务分为两部分：首先，从基本原理出发，推导各向同性扩散过程中系综均方位移与时间之间的线性关系，并根据空间维度和扩散系数确定其斜率；其次，设计并实现一种算法，该算法能够根据给定的多种物质的合成kMC位置轨迹，基于统计上合理的方法估算扩散系数，并给出双侧置信区间。\n\n您必须从以下基础出发，不得假定任何捷径公式：\n- 在$d$维空间中，各向同性扩散过程的位移$\\mathbf{r}$的概率密度函数$p(\\mathbf{r},t)$满足Fick第二定律 $\\partial_t p(\\mathbf{r},t) = D \\nabla^2 p(\\mathbf{r},t)$，初始条件为$p(\\mathbf{r},0)=\\delta(\\mathbf{r})$，其中$D$是扩散系数，$\\delta$是狄拉克δ函数。\n- 系综均方位移定义为 $\\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 p(\\mathbf{r},t) \\,\\mathrm{d}^d \\mathbf{r}$。\n- 对于每种物质，在马尔可夫假设下，kMC轨迹在足够粗的时间间隔内可以被视为具有零均值和有限方差的独立、各向同性增量的序列。\n\n程序要求：\n- 为以下测试套件构建合成的kMC输出。在每种情况下，通过对每个时间间隔$\\Delta t_k$内在每个坐标上累加独立的、服从正态分布的增量来模拟粒子位置，对于扩散系数为$D$的物质，其方差为$2 D \\Delta t_k$。位置单位必须是$\\mathrm{m}$，时间单位是$\\mathrm{s}$，扩散系数单位是$\\mathrm{m^2/s}$。请精确使用指定的随机种子以确保可复现性。\n- 对于每种物质，计算系综均方位移时间序列$M(t_k)$，定义为$M(t_k) = \\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i(t_k) - \\mathbf{r}_i(0)\\|^2$，其中$N$是该物质的粒子数，$\\mathbf{r}_i(t_k)$是粒子$i$在时间$t_k$的位置。\n- 对于每种物质，通过对$M(t_k)$与$t_k$进行带截距的普通最小二乘线性回归来估计扩散系数$D$，然后将斜率映射到$D$。使用斜率的标准误差和Student分布为$D$构建一个双侧$95\\%$置信区间。所有估算的扩散系数和置信区间界限都以$\\mathrm{m^2/s}$表示。\n- 如果某个物质的所有$k$的$M(t_k)$都恒等于零，则该物质的点估计和置信区间都返回$0$。\n\n测试套件规范：\n- 案例1（通用多组分，$d=3$）：三种物质，扩散系数$D = [1.0 \\times 10^{-20},\\, 4.0 \\times 10^{-20},\\, 0.0]\\,\\mathrm{m^2/s}$，粒子数$N = [200,\\, 200,\\, 200]$，维度$d=3$，时间$t_k = k \\Delta t$（对于$k=0,1,\\dots,100$），其中$\\Delta t = 5.0 \\times 10^{-6}\\,\\mathrm{s}$，随机种子$123$。\n- 案例2（平面扩散，$d=2$）：两种物质，扩散系数$D = [1.0 \\times 10^{-18},\\, 3.0 \\times 10^{-19}]\\,\\mathrm{m^2/s}$，粒子数$N = [50,\\, 50]$，维度$d=2$，时间$t_k = k \\Delta t$（对于$k=0,1,\\dots,150$），其中$\\Delta t = 1.0 \\times 10^{-6}\\,\\mathrm{s}$，随机种子$456$。\n- 案例3（边界情况，少粒子，$d=3$）：两种物质，扩散系数$D = [5.0 \\times 10^{-23},\\, 1.0 \\times 10^{-20}]\\,\\mathrm{m^2/s}$，粒子数$N = [5,\\, 5]$，维度$d=3$，时间$t_k = k \\Delta t$（对于$k=0,1,\\dots,40$），其中$\\Delta t = 2.0 \\times 10^{-5}\\,\\mathrm{s}$，随机种子$789$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试案例贡献一个物质结果列表，每个物质结果必须是一个包含三个浮点数的列表，顺序为$[\\hat{D},\\, \\mathrm{CI}_{\\mathrm{low}},\\, \\mathrm{CI}_{\\mathrm{high}}]$，单位均为$\\mathrm{m^2/s}$。例如，总体输出必须具有以下形式：$[[[d_{11},l_{11},u_{11}],\\dots],[[d_{21},l_{21},u_{21}],\\dots],[[d_{31},l_{31},u_{31}],\\dots]]$，其中$d_{js}$、$l_{js}$和$u_{js}$表示案例$j$中物质$s$的估计值、置信下界和置信上界。",
            "solution": "该问题提出了一个双重任务：首先，理论推导均方位移与扩散系数之间的关系；其次，实现一个计算流程，用于从模拟的粒子轨迹中估算该系数。该问题提法明确，具有科学依据，并为完整且可验证的解决方案提供了足够的细节。\n\n### 第一部分：均方位移关系的理论推导\n\n目标是为经历各向同性扩散的物质建立系综均方位移（MSD）$\\langle \\|\\mathbf{r}(t)\\|^2 \\rangle$与时间$t$之间的线性关系。推导从Fick第二定律开始，该定律控制着粒子在时间$t$的位移$\\mathbf{r}$的概率密度函数$p(\\mathbf{r}, t)$的演化。\n\n**1. 基础方程**\n\n我们已知：\n-   $d$维空间中的Fick第二定律：\n    $$ \\frac{\\partial p(\\mathbf{r},t)}{\\partial t} = D \\nabla^2 p(\\mathbf{r},t) $$\n    其中$D$是扩散系数，$\\nabla^2$是拉普拉斯算子。\n-   初始条件，表示粒子从原点开始：\n    $$ p(\\mathbf{r}, 0) = \\delta(\\mathbf{r}) $$\n    其中$\\delta(\\mathbf{r})$是$d$维狄拉克δ函数。\n-   系综均方位移的定义：\n    $$ \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} $$\n    其中$\\|\\mathbf{r}\\|^2 = \\sum_{i=1}^{d} r_i^2$是位移向量$\\mathbf{r} = (r_1, r_2, \\dots, r_d)$的欧几里得范数的平方。\n\n**2. MSD的时间导数**\n\n我们通过对其定义对时间$t$求导来分析MSD的变化率：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} $$\n假设有足够的光滑性，我们可以交换求导和积分算子（Leibniz积分法则）：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\frac{\\partial p(\\mathbf{r}, t)}{\\partial t} \\,\\mathrm{d}^d \\mathbf{r} $$\n现在，我们将Fick第二定律代入此表达式：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\left( D \\nabla^2 p(\\mathbf{r}, t) \\right) \\,\\mathrm{d}^d \\mathbf{r} = D \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\nabla^2 p \\,\\mathrm{d}^d \\mathbf{r} $$\n\n**3. 应用Green第二恒等式**\n\n为了计算该积分，我们使用Green第二恒等式，它是多维空间中的一种分部积分。该恒等式表述为：\n$$ \\int_V (f \\nabla^2 g - g \\nabla^2 f) \\,\\mathrm{d}V = \\int_S (f \\nabla g - g \\nabla f) \\cdot \\mathrm{d}\\mathbf{S} $$\n令$f = \\|\\mathbf{r}\\|^2$，$g = p(\\mathbf{r}, t)$，体积$V$为整个空间$\\mathbb{R}^d$。面积分是在无穷远处的边界上进行的。对于扩散过程，概率密度$p(\\mathbf{r}, t)$及其梯度$\\nabla p$在$\\|\\mathbf{r}\\| \\to \\infty$时必须足够快地消失。因此，面积分项为零。这使得我们得到：\n$$ \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\nabla^2 p \\,\\mathrm{d}^d \\mathbf{r} = \\int_{\\mathbb{R}^d} p \\left(\\nabla^2 \\|\\mathbf{r}\\|^2\\right) \\,\\mathrm{d}^d \\mathbf{r} $$\n我们现在计算$f(\\mathbf{r}) = \\|\\mathbf{r}\\|^2$的拉普拉斯算子：\n$$ \\nabla^2 \\|\\mathbf{r}\\|^2 = \\nabla^2 \\left(\\sum_{i=1}^{d} r_i^2\\right) = \\sum_{i=1}^{d} \\frac{\\partial^2}{\\partial r_i^2} \\left(\\sum_{j=1}^{d} r_j^2\\right) $$\n由于$\\frac{\\partial^2 r_j^2}{\\partial r_i^2} = 2 \\delta_{ij}$（其中$\\delta_{ij}$是Kronecker delta），该和变为：\n$$ \\nabla^2 \\|\\mathbf{r}\\|^2 = \\sum_{i=1}^{d} 2 = 2d $$\n位移平方的拉普拉斯算子就是空间维数的两倍。\n\n**4. 最终积分**\n\n将此结果代回到MSD时间导数的表达式中：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = D \\int_{\\mathbb{R}^d} p(\\mathbf{r}, t) (2d) \\,\\mathrm{d}^d \\mathbf{r} = 2dD \\int_{\\mathbb{R}^d} p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} $$\n由于$p(\\mathbf{r}, t)$是一个概率密度函数，根据定义，其在整个空间上的积分为1：\n$$ \\int_{\\mathbb{R}^d} p(\\mathbf{r}, t) \\,\\mathrm{d}^d \\mathbf{r} = 1 $$\n这将MSD的变化率简化为一个常数：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = 2dD $$\n将此常微分方程对时间从$0$到$t$进行积分：\n$$ \\int_0^t \\frac{\\mathrm{d}}{\\mathrm{d}\\tau} \\langle \\|\\mathbf{r}(\\tau)\\|^2 \\rangle \\,\\mathrm{d}\\tau = \\int_0^t 2dD \\,\\mathrm{d}\\tau $$\n$$ \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle - \\langle \\|\\mathbf{r}(0)\\|^2 \\rangle = 2dDt $$\n根据初始条件$p(\\mathbf{r}, 0) = \\delta(\\mathbf{r})$，所有粒子在$t=0$时都位于原点，因此初始位移及其均方值为零：\n$$ \\langle \\|\\mathbf{r}(0)\\|^2 \\rangle = \\int_{\\mathbb{R}^d} \\|\\mathbf{r}\\|^2 \\delta(\\mathbf{r}) \\,\\mathrm{d}^d \\mathbf{r} = 0 $$\n因此，我们得到了著名的Einstein扩散关系式：\n$$ \\langle \\|\\mathbf{r}(t)\\|^2 \\rangle = 2dDt $$\n这个结果表明，均方位移是时间$t$的线性函数。这个线性关系的斜率$m$由$m = 2dD$给出。因此，扩散系数$D$可以从MSD对时间作图的斜率中确定：\n$$ D = \\frac{\\text{斜率}}{2d} $$\n\n### 第二部分：扩散系数估算的算法流程\n\n该算法分三个阶段进行：合成数据生成、MSD计算以及带有置信区间的扩散系数的统计估算。\n\n**1. 合成轨迹生成**\n每个粒子的轨迹被模拟为离散时间随机游走。粒子$i$在时间步$k+1$的位置由$\\mathbf{r}_i(t_{k+1}) = \\mathbf{r}_i(t_k) + \\Delta\\mathbf{r}_{i,k}$给出，其中$\\Delta\\mathbf{r}_{i,k}$是一个随机位移向量。对于时间间隔$\\Delta t = t_{k+1}-t_k$内的各向同性扩散过程，每个$d$维中的位移分量是独立同分布的。布朗运动理论的一个基石是，这些增量可以很好地用均值为$0$、方差为$2D\\Delta t$的正态分布来近似。\n因此，对于每个粒子$i$和时间步$k$，我们生成一个位移向量$\\Delta\\mathbf{r}_{i,k}$，其分量$(\\Delta r_1, \\dots, \\Delta r_d)$从$\\mathcal{N}(0, 2D\\Delta t)$中抽取。模拟开始时，所有粒子都在原点，$\\mathbf{r}_i(0) = \\mathbf{0}$。\n\n**2. 均方位移计算**\n对于给定的具有$N$个粒子的物质，我们首先生成$N$个独立的轨迹$\\{\\mathbf{r}_i(t_k)\\}_{k=0}^{K}$，其中$K$是总时间步数。每个时间$t_k$的系综均方位移通过对所有粒子的位移大小的平方进行平均来计算：\n$$ M(t_k) = \\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i(t_k) - \\mathbf{r}_i(0)\\|^2 $$\n由于$\\mathbf{r}_i(0) = \\mathbf{0}$，这可以简化为：\n$$ M(t_k) = \\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i(t_k)\\|^2 $$\n这将产生一个MSD值的时间序列$\\{M(t_k)\\}_{k=0}^{K}$。\n\n**3. 参数估计和置信区间**\n基于理论推导，我们预期存在一个线性关系$M(t_k) \\approx b \\cdot t_k + a$，其中理论斜率为$b = 2dD$，理论截距为$a=0$。我们使用普通最小二乘（OLS）回归从计算出的数据$(t_k, M(t_k))$中估计斜率。\n\n*   **OLS回归**：给定$n=K+1$个数据点$(x_k, y_k) = (t_k, M(t_k))$，斜率估计值$\\hat{b}$由下式给出：\n    $$ \\hat{b} = \\frac{\\sum_{k=0}^{K} (x_k - \\bar{x})(y_k - \\bar{y})}{\\sum_{k=0}^{K} (x_k - \\bar{x})^2} $$\n    其中$\\bar{x}$和$\\bar{y}$是样本均值。扩散系数的估计值$\\hat{D}$则为：\n    $$ \\hat{D} = \\frac{\\hat{b}}{2d} $$\n\n*   **置信区间**：为了量化我们估计中的不确定性，我们为$D$构建一个双侧$95\\%$置信区间。这是从斜率$\\hat{b}$的置信区间推导出来的。\n    1.  计算拟合的残差：$e_k = y_k - (\\hat{a} + \\hat{b}x_k)$，其中$\\hat{a} = \\bar{y} - \\hat{b}\\bar{x}$。\n    2.  估计残差的方差：$s_e^2 = \\frac{1}{n-2} \\sum_{k=0}^{K} e_k^2$。分母$n-2$代表带截距的简单线性回归的自由度。\n    3.  计算斜率估计的标准误差：\n        $$ SE(\\hat{b}) = \\sqrt{\\frac{s_e^2}{\\sum_{k=0}^{K} (x_k - \\bar{x})^2}} $$\n    4.  真实斜率$b$的置信区间由$\\hat{b} \\pm t_{\\alpha/2, n-2} \\cdot SE(\\hat{b})$给出。对于$95\\%$的置信水平，$\\alpha=0.05$。值$t_{0.025, n-2}$是从具有$n-2$个自由度的Student t-分布中得到的临界值。\n    5.  斜率的下界和上界是：\n        $$ \\hat{b}_{\\text{low}} = \\hat{b} - t_{0.025, n-2} \\cdot SE(\\hat{b}) $$\n        $$ \\hat{b}_{\\text{high}} = \\hat{b} + t_{0.025, n-2} \\cdot SE(\\hat{b}) $$\n    6.  最后，这些界限被映射到扩散系数$D$的置信区间：\n        $$ \\mathrm{CI}_{\\mathrm{low}} = \\frac{\\hat{b}_{\\text{low}}}{2d} \\quad \\text{和} \\quad \\mathrm{CI}_{\\mathrm{high}} = \\frac{\\hat{b}_{\\text{high}}}{2d} $$\n    如果一个物质的$D=0$，其轨迹将全为零，导致对所有$k$，$M(t_k)=0$。在这种特殊情况下，估计结果为$\\hat{D}=0$，置信区间为$[0, 0]$。这在实现中作为特定条件处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef estimate_diffusion(trajectories: np.ndarray, d: int, times: np.ndarray):\n    \"\"\"\n    Estimates the diffusion coefficient and its 95% CI from particle trajectories.\n\n    Args:\n        trajectories (np.ndarray): Array of particle positions with shape\n                                   (num_timesteps, num_particles, num_dims).\n        d (int): Number of spatial dimensions.\n        times (np.ndarray): Array of time points.\n\n    Returns:\n        list: A list containing [D_est, D_low, D_high].\n    \"\"\"\n    # MSD Calculation: M(t_k) = 1/N * sum_i ||r_i(t_k) - r_i(0)||^2\n    # Since r_i(0) = 0 for all i, this is ||r_i(t_k)||^2\n    squared_displacements = np.sum(trajectories**2, axis=2)\n    msd = np.mean(squared_displacements, axis=1)\n\n    # Handle the case of a non-diffusing species (D=0)\n    if np.all(msd == 0):\n        return [0.0, 0.0, 0.0]\n\n    # Ordinary Least Squares (OLS) regression of msd vs times\n    # Model: msd = intercept + slope * times\n    n = len(times)\n    x = times\n    y = msd\n    \n    # Using OLS formulas for y = a + bx\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    \n    # Calculate slope (b) and intercept (a)\n    ss_xy = np.sum((x - x_mean) * (y - y_mean))\n    ss_xx = np.sum((x - x_mean)**2)\n    \n    if ss_xx == 0: # Should not happen with the given problem constraints\n        return [0.0, 0.0, 0.0]\n\n    slope = ss_xy / ss_xx\n    \n    # Estimate D from the slope: slope = 2*d*D\n    d_est = slope / (2 * d)\n    \n    # Confidence Interval calculation\n    # Degrees of freedom for simple linear regression is n - 2\n    df = n - 2\n    if df = 0: # Not enough data points to compute CI\n        return [d_est, d_est, d_est]\n\n    intercept = y_mean - slope * x\n    y_pred = intercept + slope * x\n    residuals = y - y_pred\n    ssr = np.sum(residuals**2)\n    \n    # Standard error of the slope\n    se_slope = np.sqrt((ssr / df) / ss_xx)\n\n    # Critical t-value for 95% CI\n    alpha = 0.05\n    t_crit = t.ppf(1 - alpha / 2, df)\n\n    # Margin of error for the slope\n    margin_of_error_slope = t_crit * se_slope\n\n    # Confidence interval for the slope\n    slope_low = slope - margin_of_error_slope\n    slope_high = slope + margin_of_error_slope\n    \n    # Map slope CI to D CI\n    d_low = slope_low / (2 * d)\n    d_high = slope_high / (2 * d)\n\n    return [d_est, d_low, d_high]\n\ndef generate_trajectories(D, N, d, times, dt, seed):\n    \"\"\"\n    Generates synthetic particle trajectories for a given species.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    num_timesteps = len(times)\n    \n    if D == 0.0:\n        return np.zeros((num_timesteps, N, d))\n\n    positions = np.zeros((num_timesteps, N, d))\n    std_dev = np.sqrt(2 * D * dt)\n\n    current_pos = np.zeros((N, d))\n    for k in range(1, num_timesteps):\n        increments = rng.normal(loc=0.0, scale=std_dev, size=(N, d))\n        current_pos += increments\n        positions[k, :, :] = current_pos\n        \n    return positions\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"d_coeffs\": [1.0e-20, 4.0e-20, 0.0],\n            \"n_particles\": [200, 200, 200],\n            \"dim\": 3,\n            \"t_steps\": 101,\n            \"dt\": 5.0e-6,\n            \"seed\": 123\n        },\n        {\n            \"d_coeffs\": [1.0e-18, 3.0e-19],\n            \"n_particles\": [50, 50],\n            \"dim\": 2,\n            \"t_steps\": 151,\n            \"dt\": 1.0e-6,\n            \"seed\": 456\n        },\n        {\n            \"d_coeffs\": [5.0e-23, 1.0e-20],\n            \"n_particles\": [5, 5],\n            \"dim\": 3,\n            \"t_steps\": 41,\n            \"dt\": 2.0e-5,\n            \"seed\": 789\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        d_coeffs = case[\"d_coeffs\"]\n        n_particles = case[\"n_particles\"]\n        d = case[\"dim\"]\n        t_steps = case[\"t_steps\"]\n        dt = case[\"dt\"]\n        seed = case[\"seed\"]\n        \n        times = np.arange(t_steps) * dt\n        \n        case_results = []\n        \n        # We need a reproducible source of seeds for each species.\n        # Use the master seed to generate sub-seeds.\n        master_rng = np.random.default_rng(seed)\n        species_seeds = master_rng.integers(low=0, high=2**32, size=len(d_coeffs))\n\n        for i, D in enumerate(d_coeffs):\n            N = n_particles[i]\n            species_seed = species_seeds[i]\n            \n            trajectories = generate_trajectories(D, N, d, times, dt, species_seed)\n            species_result = estimate_diffusion(trajectories, d, times)\n            case_results.append(species_result)\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required.\n    # The str() function in Python adds spaces, which are not desired.\n    # We will build the string manually or use replacement.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "任何模拟方法的可靠性都取决于其是否忠实地遵循了底层的物理原理。对于处于热力学平衡态的 kMC 模拟而言，其有效性的基石是细致平衡原理。本练习将指导您设计并实施一个数值验证方案，通过在模拟过程中测量正向和反向跃迁的统计数据，来检验您的 kMC 模拟器是否满足细致平衡条件，从而确保模拟结果的物理正确性 。",
            "id": "3747955",
            "problem": "你需要实现一个数值协议，用于为一小组代表高熵合金 (HEAs) 中空位介导扩散和沉淀动力学的动力学过程验证细致平衡。你的验证必须基于使用连续时间动力学蒙特卡洛 (kMC) 模拟来测量选定状态对的前向和后向跃迁概率。实现必须是自包含的，无需外部输入，并为提供的测试套件生成所要求的结果。\n\n使用的基本原理：\n- 动力学蒙特卡洛 (kMC) 在微观态 $i \\in \\{0,1,\\dots\\}$上定义了一个连续时间马尔可夫过程，这些微观态具有状态能量 $E_i$ 和到相邻状态 $j$ 的跃迁速率 $r_{i \\to j}$。\n- 在温度为 $T$ (单位为开尔文) 的正则系综平衡下，微观态 $i$ 的稳态概率与玻尔兹曼因子成正比，即 $\\pi_i \\propto \\exp(-\\beta E_i)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是以电子伏特每开尔文为单位的玻尔兹曼常数。\n- 过渡态理论 (TST) 给出活化跃迁的阿伦尼乌斯形式速率：$r_{i \\to j} = \\nu_{i \\to j} \\exp(-\\beta (E_{ij}^{\\ddagger} - E_i))$，其中 $\\nu_{i \\to j}$ 是尝试频率 (单位为 $\\mathrm{s}^{-1}$)，$E_{ij}^{\\ddagger}$ 是连接 $i$ 和 $j$ 的反应坐标的过渡态能量 (单位为 $\\mathrm{eV}$)。\n\n需进行数值验证的细致平衡定义：\n- 一个马尔可夫过程相对于正则分布满足细致平衡，当且仅当对于每一对连接的微观态 $(i,j)$，都有 $\\pi_i r_{i \\to j} = \\pi_j r_{j \\to i}$。\n\n需实现的协议：\n- 将每个测试用例构建为一个微观态的小型网络，具有指定的能量 $E_i$ (单位为 $\\mathrm{eV}$) 和赋有过渡态能量 $E_{ij}^{\\ddagger}$ (单位为 $\\mathrm{eV}$) 的无向边 $(i,j)$。对于每条边，定义尝试频率 $\\nu_{i \\to j}$ (单位为 $\\mathrm{s}^{-1}$)。对称的物理模型使用 $\\nu_{i \\to j} = \\nu_{j \\to i}$；一个有意破坏的模型使用 $\\nu_{i \\to j} \\neq \\nu_{j \\to i}$。\n- 使用 Gillespie 算法模拟 kMC：\n  - 在当前状态 $i$，使用上述阿伦尼乌斯形式计算所有到邻居 $j$ 的出射速率 $r_{i \\to j}$。\n  - 总速率为 $R_i = \\sum_j r_{i \\to j}$。从均值为 $1/R_i$ 的指数分布中抽取一个等待时间 $\\Delta t$，并将其加到状态 $i$ 的驻留时间中。\n  - 以概率 $r_{i \\to j}/R_i$ 选择下一个状态 $j$，前进到 $j$，并记录一次跃迁 $i \\to j$。\n- 使用指定数量的事件进行预运行，让过程接近稳态；然后收集统计数据：\n  - 对于每个选定的对 $(i,j)$，统计预运行后的前向跃迁次数 $N_{i \\to j}$ 和后向跃迁次数 $N_{j \\to i}$。\n  - 累积预运行后的驻留时间 $\\tau_i$ 和 $\\tau_j$。\n- 对每对 $(i,j)$ 定义两个细致平衡的数值检查：\n  1. 通量对称性检查：前向/后向通量相等意味着在稳态下 $N_{i \\to j} \\approx N_{j \\to i}$。量化相对差异 $\\delta_{\\mathrm{flux}} = |N_{i \\to j} - N_{j \\to i}|/(N_{i \\to j}+N_{j \\to i})$。\n  2. 速率比一致性检查：当微观可逆性成立时，阿伦尼乌斯和玻尔兹曼形式意味着 $r_{i \\to j}/r_{j \\to i} = \\exp(-\\beta (E_j - E_i))$。将速率经验性地估计为 $\\hat{r}_{i \\to j} = N_{i \\to j}/\\tau_i$ 和 $\\hat{r}_{j \\to i} = N_{j \\to i}/\\tau_j$，并通过计算相对偏差 $\\delta_{\\mathrm{rate}} = \\left|\\frac{(\\hat{r}_{i \\to j}/\\hat{r}_{j \\to i})}{\\exp(-\\beta (E_j - E_i))} - 1\\right|$ 来比较 $\\hat{r}_{i \\to j}/\\hat{r}_{j \\to i}$ 和 $\\exp(-\\beta (E_j - E_i))$。\n- 如果 $\\delta_{\\mathrm{flux}}$ 和 $\\delta_{\\mathrm{rate}}$ 都在选定的容差范围内，则一对 $(i,j)$ 通过检查。\n\n单位：\n- 能量 $E_i$ 和 $E_{ij}^{\\ddagger}$ 必须以电子伏特 ($\\mathrm{eV}$) 为单位。\n- 温度 $T$ 必须以开尔文 ($\\mathrm{K}$) 为单位。\n- 尝试频率 $\\nu_{i \\to j}$ 必须以反秒 ($\\mathrm{s}^{-1}$) 为单位。\n- 最终程序输出报告为布尔值，无单位。\n\n需实现和模拟的测试套件：\n- 用例 $1$ (理想情况，对称双态)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.0$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.4$ $\\mathrm{eV}$，$\\nu_{0 \\to 1} = \\nu_{1 \\to 0} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1000$ $\\mathrm{K}$，选定对 $(0,1)$，模拟 $200000$ 次预运行后事件。\n- 用例 $2$ (理想情况，不对称能量双态)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.2$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.5$ $\\mathrm{eV}$，$\\nu_{0 \\to 1} = \\nu_{1 \\to 0} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1000$ $\\mathrm{K}$，选定对 $(0,1)$，模拟 $250000$ 次预运行后事件。\n- 用例 $3$ (边缘案例，破坏的微观可逆性)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.2$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.5$ $\\mathrm{eV}$，$\\nu_{0 \\to 1} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$\\nu_{1 \\to 0} = 2.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1000$ $\\mathrm{K}$，选定对 $(0,1)$，模拟 $250000$ 次预运行后事件。\n- 用例 $4$ (多态覆盖)：$E_0 = 0.0$ $\\mathrm{eV}$，$E_1 = 0.1$ $\\mathrm{eV}$，$E_2 = 0.3$ $\\mathrm{eV}$，边 $(0,1)$ 的 $E_{01}^{\\ddagger} = 0.4$ $\\mathrm{eV}$ 和边 $(1,2)$ 的 $E_{12}^{\\ddagger} = 0.6$ $\\mathrm{eV}$，两者均有 $\\nu_{i \\to j} = \\nu_{j \\to i} = 1.0 \\times 10^{12}$ $\\mathrm{s}^{-1}$，$T = 1200$ $\\mathrm{K}$，选定对 $(0,1)$ 和 $(1,2)$，模拟 $400000$ 次预运行后事件。\n\n通过/失败的容差：\n- 通量容差 $\\delta_{\\mathrm{flux}}^{\\max} = 0.03$。\n- 速率比容差 $\\delta_{\\mathrm{rate}}^{\\max} = 0.05$。\n\n最终输出规范：\n- 对每个用例，计算一个布尔值，指示所有选定对是否都通过了两项检查。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3}]$，其中每个 ${\\text{result}_k}$ 为 $True$ 或 $False$。最终输出必须严格匹配此格式，并按用例 $1$ 到 $4$ 的顺序包含四个条目。",
            "solution": "用户提供了一个问题，要求实现动力学蒙特卡洛 (kMC) 模拟，以数值方式验证几个小状态系统的细致平衡原理。该问题具有科学依据，定义严谨，并且在计算上是可行的。\n\n### **问题验证**\n\n**第 1 步：提取给定信息**\n\n*   **物理模型**：微观态 $i$ 上的连续时间马尔可夫过程，能量为 $E_i$。稳态概率 $\\pi_i \\propto \\exp(-\\beta E_i)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。\n*   **跃迁动力学**：过渡态理论 (TST) 与阿伦尼乌斯速率 $r_{i \\to j} = \\nu_{i \\to j} \\exp(-\\beta (E_{ij}^{\\ddagger} - E_i))$，其中 $E_{ij}^{\\ddagger}$ 是过渡态能量，$\\nu_{i \\to j}$ 是尝试频率。\n*   **基本原理**：细致平衡由 $\\pi_i r_{i \\to j} = \\pi_j r_{j \\to i}$ 定义，适用于所有连接的状态对 $(i,j)$。\n*   **模拟算法**：Gillespie kMC 算法 (驻留时间从指数分布中抽取，下一个状态通过速率加权概率选择)。\n*   **数值验证协议**：\n    1.  **通量对称性检查**：使用模拟中的跃迁计数 $N_{i \\to j}$ 计算 $\\delta_{\\mathrm{flux}} = |N_{i \\to j} - N_{j \\to i}|/(N_{i \\to j}+N_{j \\to i})$。\n    2.  **速率比一致性检查**：使用从计数和驻留时间 $\\tau_i$ 导出的经验速率 $\\hat{r}_{i \\to j} = N_{i \\to j}/\\tau_i$ 计算 $\\delta_{\\mathrm{rate}} = \\left|\\frac{(\\hat{r}_{i \\to j}/\\hat{r}_{j \\to i})}{\\exp(-\\beta (E_j - E_i))} - 1\\right|$。\n*   **容差**：$\\delta_{\\mathrm{flux}}^{\\max} = 0.03$，$\\delta_{\\mathrm{rate}}^{\\max} = 0.05$。\n*   **测试套件**：为四个特定用例定义了所有必要参数：状态能量 $E_i$、过渡态能量 $E_{ij}^{\\ddagger}$、尝试频率 $\\nu_{i \\to j}$、温度 $T$、要检查的对以及预运行后的模拟事件数。\n*   **常数与单位**：能量单位为 $\\mathrm{eV}$，温度单位为 $\\mathrm{K}$，频率单位为 $\\mathrm{s}^{-1}$，玻尔兹曼常数 $k_{\\mathrm{B}}$ 使用 $\\mathrm{eV/K}$ 单位。\n\n**第 2 步：使用提取的给定信息进行验证**\n\n根据验证标准对问题进行审查：\n\n*   **具有科学依据**：该问题基于统计力学和化学动力学的基本原理。kMC 方法是模拟随机过程的标准、严谨的计算技术。前提和检查方法在科学上是合理的。\n*   **定义明确**：每个测试用例的所有参数 ($E_i, E_{ij}^{\\ddagger}, \\nu_{i \\to j}, T$)、模拟长度和验证标准 (容差) 都已明确定义。这确保了可以为每个用例确定一个唯一且有意义的布尔结果。\n*   **客观**：问题以精确、定量的术语陈述，没有任何主观或模棱两可的语言。\n*   **完整性和一致性**：问题是自包含的。提供的数据足以执行模拟和验证。一个次要细节，即预运行事件的数量，未指定。然而，由于系统很小且混合迅速，任何合理的选择 (例如，$10^4$ 事件) 都足以达到稳态，并不构成缺陷。问题在内部是一致的。\n*   **可行性**：所有指定参数都在物理上现实的范围内。所需的模拟事件数在标准计算机上是计算可行的。\n*   **概念深度**：问题并非微不足道。它要求正确实现 Gillespie 算法，并对细致平衡有深入的理解，特别是稳态 (通过通量平衡检查) 和热力学一致性 (通过速率比测试检查) 之间的区别，这一点在用例 3 中得到了突出体现。\n\n**第 3 步：结论与行动**\n\n问题陈述是**有效的**。这是一个定义明确且科学合理的数值问题。我现在将着手构建完整的解决方案。\n\n### **解决方案实现**\n\n解决方案的核心是一个函数，该函数为给定系统执行 kMC 模拟，然后应用两个验证检查。\n\n**1. 系统表示**\n每个测试用例由其系统拓扑和能量学定义。一种合适的表示方法是一组字典和数组：状态能量 $E_i$、表示连接的邻接表，以及用于过渡态能量 $E_{ij}^{\\ddagger}$ 和尝试频率 $\\nu_{i \\to j}$ 的字典。\n\n**2. kMC 模拟 (Gillespie 算法)**\n模拟以离散事件的形式进行。在每一步，从当前状态 $i$：\n*   使用阿伦尼乌斯公式计算所有可能的到邻居状态 $j$ 的出射跃迁速率：$r_{i \\to j} = \\nu_{i \\to j} \\exp\\left(-\\frac{E_{ij}^{\\ddagger} - E_i}{k_{\\mathrm{B}}T}\\right)$。\n*   从状态 $i$ 的总出射速率是所有单个速率的总和，$R_i = \\sum_j r_{i \\to j}$。如果 $R_i = 0$，系统处于一个汇点状态，模拟终止。\n*   从均值为 $1/R_i$ 的指数分布中抽取一个时间步长 $\\Delta t$。这通过计算 $\\Delta t = -\\ln(u_1) / R_i$ 来实现，其中 $u_1$ 是在 $(0, 1]$ 内均匀分布的随机数。\n*   下一个状态 $j$ 以与其速率成正比的概率 $p(j) = r_{i \\to j}/R_i$ 被选择。这通过基于第二个均匀随机数 $u_2 \\in (0, 1]$ 的“轮盘赌”选择来实现。\n*   系统时间前进 $\\Delta t$，当前状态变为 $j$。\n*   为了进行统计分析，我们记录前一个状态 $i$ 的驻留时间 $\\Delta t$，并对跃迁 $i \\to j$ 进行计数。\n\n使用 $10,000$ 个事件的预运行期，以确保系统在收集统计数据之前达到其稳态分布。\n\n**3. 验证检查**\n模拟完成后，收集到的统计数据——跃迁计数 $N_{i \\to j}$ 和总驻留时间 $\\tau_i$——用于对每个指定的状态对 $(i, j)$ 进行检查。\n\n*   **通量对称性检查**：计算前向和后向跃迁计数的相对差异 $\\delta_{\\mathrm{flux}} = |N_{i \\to j} - N_{j \\to i}|/(N_{i \\to j}+N_{j \\to i})$。增加了鲁棒性以处理 (不太可能发生的) 分母为零的情况。结果与容差 $\\delta_{\\mathrm{flux}}^{\\max} = 0.03$进行比较。\n\n*   **速率比一致性检查**：\n    *   理论速率比基于玻尔兹曼分布计算：$K_{\\text{theory}} = \\exp(-\\beta(E_j - E_i))$。\n    *   经验速率从模拟中估计：$\\hat{r}_{i \\to j} = N_{i \\to j}/\\tau_i$ 和 $\\hat{r}_{j \\to i} = N_{j \\to i}/\\tau_j$。\n    *   经验速率比为 $K_{\\text{empirical}} = \\hat{r}_{i \\to j}/\\hat{r}_{j \\to i}$。\n    *   计算相对偏差：$\\delta_{\\mathrm{rate}} = |K_{\\text{empirical}}/K_{\\text{theory}} - 1|$。\n    *   此检查需要仔细处理潜在的除零情况 (例如，如果 $\\tau_j=0$ 或 $\\hat{r}_{j \\to i}=0$)，这可能表示未能满足细致平衡条件或采样不足。结果与容差 $\\delta_{\\mathrm{rate}}^{\\max} = 0.05$ 进行比较。\n\n一个测试用例仅当其**所有**指定对都通过**两项**检查时才被视为通过。\n\n**用例分析预测：**\n*   **用例 1 (对称)**：预期通过。$E_0=E_1$ 且 $\\nu_{0 \\to 1}=\\nu_{1 \\to 0}$。系统是完全对称的。\n*   **用例 2 (不对称能量)**：预期通过。能量差异造成了状态布居数的不对称，但由于微观可逆性成立 ($\\nu_{0 \\to 1}=\\nu_{1 \\to 0}$)，细致平衡得到满足。\n*   **用例 3 (破坏的微观可逆性)**：预期失败。条件 $\\nu_{0 \\to 1} \\neq \\nu_{1 \\to 0}$ 明确破坏了相对于正则玻尔兹曼分布的细致平衡的基本假设。速率比检查应该能检测到这种差异。通量检查可能仍然会通过，因为系统达到了一个具有平衡通量的非平衡稳态。\n*   **用例 4 (多态)**：预期通过。细致平衡是一个局部属性，对于每个连接的状态对都成立，无论网络中其他状态如何，只要每个链接都保持微观可逆性。\n\n最终的实现将把此逻辑封装到一个脚本中，处理所有四个用例并生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the KMC simulation and verification for all test cases.\n    \"\"\"\n    \n    # Define physical constants and simulation parameters\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n    BURN_IN_EVENTS = 10000\n    FLUX_TOLERANCE = 0.03\n    RATE_RATIO_TOLERANCE = 0.05\n\n    test_cases = [\n        {\n            \"name\": \"Case 1: Symmetric two-state\",\n            \"state_energies\": np.array([0.0, 0.0]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.4, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12}\n            },\n            \"temperature\": 1000.0,\n            \"num_events\": 200000,\n            \"selected_pairs\": [(0, 1)],\n        },\n        {\n            \"name\": \"Case 2: Asymmetric energies two-state\",\n            \"state_energies\": np.array([0.0, 0.2]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.5, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12}\n            },\n            \"temperature\": 1000.0,\n            \"num_events\": 250000,\n            \"selected_pairs\": [(0, 1)],\n        },\n        {\n            \"name\": \"Case 3: Broken microreversibility\",\n            \"state_energies\": np.array([0.0, 0.2]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.5, \"nu_fwd\": 1.0e12, \"nu_bwd\": 2.0e12}\n            },\n            \"temperature\": 1000.0,\n            \"num_events\": 250000,\n            \"selected_pairs\": [(0, 1)],\n        },\n        {\n            \"name\": \"Case 4: Multi-state coverage\",\n            \"state_energies\": np.array([0.0, 0.1, 0.3]),\n            \"edges\": {\n                (0, 1): {\"saddle_energy\": 0.4, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12},\n                (1, 2): {\"saddle_energy\": 0.6, \"nu_fwd\": 1.0e12, \"nu_bwd\": 1.0e12},\n            },\n            \"temperature\": 1200.0,\n            \"num_events\": 400000,\n            \"selected_pairs\": [(0, 1), (1, 2)],\n        },\n    ]\n\n    def run_kmc_case(params):\n        \"\"\"\n        Runs a single KMC simulation and detailed balance check for a given case.\n        \"\"\"\n        state_energies = params[\"state_energies\"]\n        n_states = len(state_energies)\n        T = params[\"temperature\"]\n        beta = 1.0 / (KB_EV_K * T)\n\n        # Build adjacency list and rate info\n        adjacency = [[] for _ in range(n_states)]\n        saddle_energies = {}\n        attempt_freqs = {}\n        for (i, j), edge_data in params[\"edges\"].items():\n            adjacency[i].append(j)\n            adjacency[j].append(i)\n            saddle_energies[(i, j)] = saddle_energies[(j, i)] = edge_data[\"saddle_energy\"]\n            attempt_freqs[(i, j)] = edge_data[\"nu_fwd\"]\n            attempt_freqs[(j, i)] = edge_data[\"nu_bwd\"]\n\n        # KMC simulation state\n        current_state = 0\n        rng = np.random.default_rng(seed=42) # Seed for reproducibility\n\n        # Gillespie step function\n        def gillespie_step(state_idx):\n            neighbors = adjacency[state_idx]\n            if not neighbors:\n                return state_idx, np.inf # Sink state\n\n            rates = []\n            for neighbor_idx in neighbors:\n                E_i = state_energies[state_idx]\n                E_ij_saddle = saddle_energies[(state_idx, neighbor_idx)]\n                barrier = E_ij_saddle - E_i\n                nu = attempt_freqs[(state_idx, neighbor_idx)]\n                rate = nu * np.exp(-beta * barrier)\n                rates.append(rate)\n            \n            total_rate = sum(rates)\n            if total_rate == 0:\n                return state_idx, np.inf\n\n            dt = -np.log(rng.random()) / total_rate\n            \n            # Select next state\n            rand_choice = rng.random() * total_rate\n            cum_rate = 0.0\n            next_state = -1\n            for i, rate in enumerate(rates):\n                cum_rate += rate\n                if rand_choice  cum_rate:\n                    next_state = neighbors[i]\n                    break\n            \n            return next_state, dt\n\n        # --- Simulation Loop ---\n        num_total_events = BURN_IN_EVENTS + params[\"num_events\"]\n        residence_times = np.zeros(n_states)\n        transition_counts = np.zeros((n_states, n_states), dtype=int)\n\n        for event_num in range(num_total_events):\n            next_state, dt = gillespie_step(current_state)\n            \n            # Collect statistics only after burn-in\n            if event_num >= BURN_IN_EVENTS:\n                residence_times[current_state] += dt\n                if next_state != current_state:\n                    transition_counts[current_state, next_state] += 1\n            \n            current_state = next_state\n\n        # --- Verification ---\n        all_pairs_passed = True\n        for i, j in params[\"selected_pairs\"]:\n            # 1. Flux symmetry check\n            N_ij = transition_counts[i, j]\n            N_ji = transition_counts[j, i]\n            \n            flux_check_passed = False\n            total_flux_events = N_ij + N_ji\n            if total_flux_events == 0:\n                # If no transitions occurred, this check is inconclusive but not a failure.\n                flux_check_passed = True\n            else:\n                delta_flux = np.abs(N_ij - N_ji) / total_flux_events\n                if delta_flux = FLUX_TOLERANCE:\n                    flux_check_passed = True\n\n            # 2. Rate-ratio consistency check\n            tau_i = residence_times[i]\n            tau_j = residence_times[j]\n            \n            rate_check_passed = False\n            if tau_i > 0 and tau_j > 0 and N_ji > 0:\n                r_hat_ij = N_ij / tau_i\n                r_hat_ji = N_ji / tau_j\n                \n                if r_hat_ji > 0:\n                    empirical_ratio = r_hat_ij / r_hat_ji\n                    \n                    E_i, E_j = state_energies[i], state_energies[j]\n                    theoretical_ratio = np.exp(-beta * (E_j - E_i))\n                    \n                    if theoretical_ratio > 0:\n                        delta_rate = np.abs(empirical_ratio / theoretical_ratio - 1)\n                        if delta_rate = RATE_RATIO_TOLERANCE:\n                            rate_check_passed = True\n\n            if not (flux_check_passed and rate_check_passed):\n                all_pairs_passed = False\n                break # A single failure is enough for the case\n\n        return all_pairs_passed\n\n    # Run all test cases and collect results\n    results = [run_kmc_case(case) for case in test_cases]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}