{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering any computational technique is to ensure the implementation is correct, a process known as verification and validation. This practice guides you through this crucial step by testing thermodynamic integration against a simple harmonic oscillator, a model system for which the free energy difference can be solved analytically. By comparing your numerical results to this exact \"ground truth,\" you will learn to decompose the total error into its primary sources: the numerical error from discretizing the integration path (quadrature error) and the statistical error from finite sampling (sampling error) . This diagnostic skill is indispensable for building robust and reliable computational models.",
            "id": "3762543",
            "problem": "You are to implement and validate a thermodynamic integration procedure for computing a free energy difference in a simplified, analytically solvable model relevant to High-Entropy Alloys (HEA). The goal is to demonstrate a rigorous validation cycle against a known analytical baseline and to diagnose whether discrepancies arise from sampling errors or from numerical quadrature errors. The context is free energy calculations via Thermodynamic Integration (TI) for a single configurational degree of freedom representative of a local harmonic mode in a complex material.\n\nStart from the following foundational principles:\n- The canonical ensemble with inverse temperature $\\beta = 1/(k_{\\mathrm{B}} T)$, where $k_{\\mathrm{B}}$ is the Boltzmann constant and $T$ is the absolute temperature.\n- The Helmholtz free energy defined by $F = - k_{\\mathrm{B}} T \\ln Z$, where $Z$ is the partition function.\n- Thermodynamic Integration (TI): define a coupling parameter $\\lambda \\in [0,1]$ with a mixed potential $U_{\\lambda}$ between two states. The free energy difference $\\Delta F$ between the endpoints is obtained by integrating the canonical ensemble average of the generalized force over $\\lambda$.\n\nModel and path specification:\n- Consider a one-dimensional harmonic oscillator with potential $U(x) = \\frac{1}{2} k x^2$, where $k$ is a stiffness parameter with units $\\mathrm{N/m}$ and $x$ is the displacement with units $\\mathrm{m}$.\n- Define endpoint stiffnesses $k_0$ and $k_1$ and a linear mixing path $U_{\\lambda}(x) = (1-\\lambda) U_0(x) + \\lambda U_1(x)$, with $\\lambda \\in [0,1]$, where $U_0(x) = \\frac{1}{2} k_0 x^2$ and $U_1(x) = \\frac{1}{2} k_1 x^2$.\n- By construction, $U_{\\lambda}(x)$ is harmonic with an effective stiffness $k_{\\lambda} = (1-\\lambda) k_0 + \\lambda k_1$.\n\nAnalytical baseline requirement:\n- Using the canonical ensemble and the above model, derive the analytical free energy difference $\\Delta F_{\\mathrm{exact}}$ between the two harmonic states at temperature $T$. This requires evaluating $Z$ for each endpoint and forming the free energy difference based on $F = -k_{\\mathrm{B}} T \\ln Z$. You must express the analytical $\\Delta F_{\\mathrm{exact}}$ in $\\mathrm{J}$.\n\nNumerical TI implementation requirements:\n- Implement a numerical TI integrand based on the definition of $U_{\\lambda}$ and the canonical ensemble average of the generalized force. Use two routes:\n  1. An analytical integrand as a function of $\\lambda$ derived from the harmonic model and canonical averages for $U_{\\lambda}(x)$.\n  2. A Monte Carlo estimator at each $\\lambda$ that samples $x$ from the canonical distribution associated with $U_{\\lambda}(x)$ and approximates the ensemble average by a finite sample mean.\n- Perform numerical integration over $\\lambda$ using a composite trapezoidal rule and a composite Simpson’s rule. Use a uniform $\\lambda$ mesh consisting of $N_{\\lambda}$ points. For composite Simpson’s rule, use an odd number of points (even number of intervals).\n- Quantify three discrepancies (all in $\\mathrm{J}$):\n  1. The total error $E_{\\mathrm{tot}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{exact}}$, where $\\Delta F_{\\mathrm{MC}}$ is the TI estimate using the Monte Carlo integrand and the chosen quadrature.\n  2. The quadrature error $E_{\\mathrm{quad}} = \\Delta F_{\\mathrm{analytic\\_discrete}} - \\Delta F_{\\mathrm{exact}}$, where $\\Delta F_{\\mathrm{analytic\\_discrete}}$ is the TI estimate obtained by integrating the analytical integrand on the discrete $\\lambda$ grid using the chosen quadrature.\n  3. The sampling error $E_{\\mathrm{samp}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{analytic\\_discrete}}$, i.e., the discrepancy between the Monte Carlo and analytical integrands under the same quadrature and grid.\n- Provide a boolean diagnostic per test case indicating whether sampling error dominates: return $\\mathrm{True}$ if $|E_{\\mathrm{samp}}| > |E_{\\mathrm{quad}}|$, otherwise $\\mathrm{False}$.\n\nUnits and numerical details:\n- Use $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$. Express all free energies and errors in $\\mathrm{J}$.\n- Use angles, if any, in radians; none are needed here.\n- Monte Carlo sampling must be performed from the canonical Gaussian distribution implied by $U_{\\lambda}(x)$ at temperature $T$; ensure reproducibility via a fixed pseudo-random number generator seed.\n- The numerical quadrature must be implemented in a general manner that works for any uniform grid with $N_{\\lambda} \\ge 2$; composite Simpson’s rule requires $N_{\\lambda}$ to be odd.\n\nTest suite:\nFor each test case, the parameters are $(k_0,\\ k_1,\\ T,\\ N_{\\lambda},\\ N_{\\mathrm{s}},\\ \\text{quadrature})$, where $N_{\\mathrm{s}}$ is the number of Monte Carlo samples per $\\lambda$ point.\n\n- Case $1$ (general case): $(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 4.0\\ \\mathrm{N/m},\\ T = 300\\ \\mathrm{K},\\ N_{\\lambda} = 21,\\ N_{\\mathrm{s}} = 2000,\\ \\text{quadrature} = \\text{Simpson})$.\n- Case $2$ (sampling-limited): $(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 4.0\\ \\mathrm{N/m},\\ T = 300\\ \\mathrm{K},\\ N_{\\lambda} = 101,\\ N_{\\mathrm{s}} = 50,\\ \\text{quadrature} = \\text{Simpson})$.\n- Case $3$ (quadrature-limited): $(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 4.0\\ \\mathrm{N/m},\\ T = 300\\ \\mathrm{K},\\ N_{\\lambda} = 3,\\ N_{\\mathrm{s}} = 20000,\\ \\text{quadrature} = \\text{Trapezoid})$.\n- Case $4$ (small stiffness contrast at low temperature): $(k_0 = 1.0\\ \\mathrm{N/m},\\ k_1 = 1.2\\ \\mathrm{N/m},\\ T = 50\\ \\mathrm{K},\\ N_{\\lambda} = 5,\\ N_{\\mathrm{s}} = 5000,\\ \\text{quadrature} = \\text{Trapezoid})$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a list with four entries: $[E_{\\mathrm{tot}},\\ |E_{\\mathrm{samp}}|,\\ |E_{\\mathrm{quad}}|,\\ \\text{sampling\\_dominant}]$. For example, an output with two cases would look like $[[e_1,\\ s_1,\\ q_1,\\ b_1],[e_2,\\ s_2,\\ q_2,\\ b_2]]$. All energy quantities must be in $\\mathrm{J}$, and the boolean must be either $\\mathrm{True}$ or $\\mathrm{False}$.",
            "solution": "The problem statement has been critically examined and is found to be valid. It is scientifically grounded in the principles of statistical mechanics, well-posed, objective, and internally consistent. It presents a standard, albeit simplified, scenario for demonstrating and validating a thermodynamic integration (TI) calculation, a common task in computational materials science. We may therefore proceed with the derivation and solution.\n\nThe solution is developed in three stages: first, the derivation of the analytical expressions for the free energy difference and the TI integrand; second, the design of the numerical procedure for TI and error analysis; and third, the implementation of this procedure in code to address the specific test cases.\n\n### 1. Analytical Derivations\n\nThis section establishes the theoretical foundation for the problem by deriving the exact quantities against which the numerical estimates will be compared.\n\n**1.1. Analytical Free Energy Difference**\n\nThe model is a one-dimensional classical harmonic oscillator with potential energy $U(x) = \\frac{1}{2}kx^2$, where $x$ is the displacement and $k$ is the spring constant. The system is in thermal equilibrium with a heat bath at temperature $T$. The canonical partition function, $Z$, is given by:\n$$ Z = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U(x)) \\, dx $$\nwhere $\\beta = 1/(k_B T)$ is the inverse temperature and $k_B$ is the Boltzmann constant. Substituting the potential energy, we get:\n$$ Z(k, T) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k x^2}{2}\\right) \\, dx $$\nThis is a standard Gaussian integral of the form $\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\pi/a}$. Here, $a = \\beta k / 2$, so the partition function is:\n$$ Z(k, T) = \\sqrt{\\frac{2\\pi}{\\beta k}} $$\nThe Helmholtz free energy, $F$, is defined as $F = -k_B T \\ln Z = -1/\\beta \\ln Z$.\n$$ F(k, T) = -\\frac{1}{\\beta} \\ln\\left(\\sqrt{\\frac{2\\pi}{\\beta k}}\\right) = -\\frac{1}{2\\beta} \\ln\\left(\\frac{2\\pi}{\\beta k}\\right) = \\frac{1}{2\\beta} \\ln\\left(\\frac{\\beta k}{2\\pi}\\right) $$\nSubstituting $\\beta = 1/(k_B T)$:\n$$ F(k, T) = \\frac{k_B T}{2} \\ln\\left(\\frac{k}{2\\pi k_B T}\\right) $$\nThe problem asks for the free energy difference, $\\Delta F = F_1 - F_0$, between two states with spring constants $k_1$ and $k_0$, respectively, at the same temperature $T$.\n$$ \\Delta F_{\\mathrm{exact}} = F(k_1, T) - F(k_0, T) = \\frac{k_B T}{2} \\ln\\left(\\frac{k_1}{2\\pi k_B T}\\right) - \\frac{k_B T}{2} \\ln\\left(\\frac{k_0}{2\\pi k_B T}\\right) $$\nUsing the property of logarithms, $\\ln(a) - \\ln(b) = \\ln(a/b)$, we obtain the exact analytical free energy difference:\n$$ \\Delta F_{\\mathrm{exact}} = \\frac{k_B T}{2} \\ln\\left(\\frac{k_1}{k_0}\\right) $$\nThis expression serves as our exact baseline for validation.\n\n**1.2. Analytical Thermodynamic Integration Integrand**\n\nThermodynamic integration computes the free energy difference by integrating the ensemble average of the generalized force along a path defined by a coupling parameter $\\lambda$. The path-dependent potential is given as $U_{\\lambda}(x) = (1-\\lambda)U_0(x) + \\lambda U_1(x)$, where $U_i(x) = \\frac{1}{2}k_i x^2$.\n$$ U_{\\lambda}(x) = \\frac{1}{2} \\left( (1-\\lambda)k_0 + \\lambda k_1 \\right) x^2 = \\frac{1}{2} k_{\\lambda} x^2 $$\nHere, $k_{\\lambda} = (1-\\lambda)k_0 + \\lambda k_1$ is the $\\lambda$-dependent effective spring constant. The free energy difference is:\n$$ \\Delta F = \\int_0^1 \\left\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\right\\rangle_{\\lambda} d\\lambda $$\nThe term inside the integral is the integrand. First, we compute the partial derivative of $U_{\\lambda}(x)$ with respect to $\\lambda$:\n$$ \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda} \\left[ \\frac{1}{2} ((1-\\lambda)k_0 + \\lambda k_1) x^2 \\right] = \\frac{1}{2} (-k_0 + k_1) x^2 = \\frac{1}{2} (k_1 - k_0) x^2 $$\nNext, we must find the canonical ensemble average of $x^2$ for a system governed by the potential $U_{\\lambda}(x)$, denoted as $\\langle x^2 \\rangle_{\\lambda}$. From the equipartition theorem, the average potential energy for a one-dimensional quadratic degree of freedom is $\\frac{1}{2}k_B T$.\n$$ \\langle U_{\\lambda}(x) \\rangle_{\\lambda} = \\left\\langle \\frac{1}{2} k_{\\lambda} x^2 \\right\\rangle_{\\lambda} = \\frac{1}{2} k_{\\lambda} \\langle x^2 \\rangle_{\\lambda} = \\frac{1}{2} k_B T $$\nSolving for $\\langle x^2 \\rangle_{\\lambda}$ yields:\n$$ \\langle x^2 \\rangle_{\\lambda} = \\frac{k_B T}{k_{\\lambda}} = \\frac{k_B T}{(1-\\lambda)k_0 + \\lambda k_1} $$\nThis result can also be obtained by direct integration of $\\langle x^2 \\rangle_{\\lambda} = (\\int x^2 e^{-\\beta U_{\\lambda}(x)} dx) / Z_{\\lambda}$.\nNow, we can write the analytical expression for the TI integrand, which we denote as $I(\\lambda)$:\n$$ I(\\lambda) = \\left\\langle \\frac{\\partial U_{\\lambda}(x)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\frac{1}{2} (k_1 - k_0) \\langle x^2 \\rangle_{\\lambda} = \\frac{k_B T (k_1 - k_0)}{2((1-\\lambda)k_0 + \\lambda k_1)} $$\nIntegrating this analytical integrand from $\\lambda=0$ to $\\lambda=1$ correctly recovers the $\\Delta F_{\\mathrm{exact}}$ derived previously, confirming the consistency of our framework.\n\n### 2. Numerical Procedure and Error Analysis\n\n**2.1. Numerical Quadrature**\n\nThe integral $\\Delta F = \\int_0^1 I(\\lambda) d\\lambda$ is to be computed numerically using two methods on a uniform grid of $N_{\\lambda}$ points, $\\lambda_i = i/(N_{\\lambda}-1)$ for $i = 0, \\ldots, N_{\\lambda}-1$.\n- **Composite Trapezoidal Rule:** Approximates the integral as the sum of areas of trapezoids under the curve.\n- **Composite Simpson's Rule:** A higher-order method that fits quadratic polynomials to segments of the curve, requiring an odd number of points ($N_{\\lambda}$).\n\n**2.2. Monte Carlo Estimator**\nFor a given $\\lambda_i$, the ensemble average $\\langle \\frac{\\partial U_{\\lambda}}{\\partial \\lambda} \\rangle_{\\lambda_i}$ is estimated using a Monte Carlo (MC) procedure. The probability distribution of $x$ is a Gaussian, $p_{\\lambda_i}(x) \\propto \\exp(-\\beta U_{\\lambda_i}(x))$, with mean $0$ and variance $\\sigma_{\\lambda_i}^2 = \\langle x^2 \\rangle_{\\lambda_i} = k_B T / k_{\\lambda_i}$.\nWe generate $N_s$ samples, $\\{x_j\\}$, from this distribution, $x_j \\sim \\mathcal{N}(0, \\sigma_{\\lambda_i}^2)$. The MC estimator for the integrand is:\n$$ \\left\\langle \\frac{\\partial U_{\\lambda_i}}{\\partial \\lambda_i} \\right\\rangle^{\\mathrm{MC}}_{\\lambda_i} = \\frac{1}{N_s} \\sum_{j=1}^{N_s} \\frac{1}{2} (k_1 - k_0) x_j^2 = \\frac{1}{2} (k_1 - k_0) \\left( \\frac{1}{N_s} \\sum_{j=1}^{N_s} x_j^2 \\right) $$\n\n**2.3. Error Decomposition**\n\nWe quantify discrepancies between the various estimates and the exact result:\n- $\\Delta F_{\\mathrm{exact}}$: The true analytical value, $\\frac{k_B T}{2} \\ln(k_1/k_0)$.\n- $\\Delta F_{\\mathrm{analytic\\_discrete}}$: The result from numerically integrating the analytical integrand $I(\\lambda)$ over the discrete $\\lambda$ grid.\n- $\\Delta F_{\\mathrm{MC}}$: The result from numerically integrating the MC-estimated integrand over the same discrete $\\lambda$ grid.\n\nThe errors are defined as:\n1.  **Total Error ($E_{\\mathrm{tot}}$):** The overall deviation of the full numerical simulation from the true value.\n    $$ E_{\\mathrm{tot}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{exact}} $$\n2.  **Quadrature Error ($E_{\\mathrm{quad}}$):** The error arising solely from the discretization of the $\\lambda$ integral. It is the difference between the exact value and the result of applying the quadrature rule to the exact integrand.\n    $$ E_{\\mathrm{quad}} = \\Delta F_{\\mathrm{analytic\\_discrete}} - \\Delta F_{\\mathrm{exact}} $$\n3.  **Sampling Error ($E_{\\mathrm{samp}}$):** The error arising from the use of finite Monte Carlo sampling to estimate the ensemble average at each $\\lambda$ point.\n    $$ E_{\\mathrm{samp}} = \\Delta F_{\\mathrm{MC}} - \\Delta F_{\\mathrm{analytic\\_discrete}} $$\n\nBy construction, these errors are additive: $E_{\\mathrm{tot}} = E_{\\mathrm{quad}} + E_{\\mathrm{samp}}$. The diagnostic for whether sampling error dominates is the boolean result of the comparison $|E_{\\mathrm{samp}}| > |E_{\\mathrm{quad}}|$.\n\n### 3. Implementation\n\nThe following Python code implements the described procedure. It defines a function to perform the calculations for a single test case, including the analytical baseline, the analytical and MC-based TI integrands, numerical quadrature, and error analysis. The main `solve` function iterates through the provided test suite, calls the calculation function, and formats the results as specified. A fixed seed is used for the pseudo-random number generator to ensure reproducibility of the Monte Carlo sampling.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import trapezoid, simpson\n\ndef calculate_ti_errors(k0, k1, T, N_lambda, N_s, quadrature_rule, rng):\n    \"\"\"\n    Performs Thermodynamic Integration for a 1D harmonic oscillator model and analyzes errors.\n\n    Args:\n        k0 (float): Stiffness of the initial state (N/m).\n        k1 (float): Stiffness of the final state (N/m).\n        T (float): Absolute temperature (K).\n        N_lambda (int): Number of points in the lambda grid.\n        N_s (int): Number of Monte Carlo samples per lambda point.\n        quadrature_rule (str): Either 'Trapezoid' or 'Simpson'.\n        rng (np.random.Generator): A seeded random number generator.\n\n    Returns:\n        list: A list containing [E_tot, abs(E_samp), abs(E_quad), sampling_dominant].\n    \"\"\"\n    # Universal constant\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    # 1. Analytical Baseline Calculation\n    # The exact free energy difference is Delta_F = 0.5 * k_B * T * ln(k1 / k0).\n    # Handle the case k0=0, k1=0, k1/k0 <= 0 for robustness, although not in tests.\n    if k0 <= 0 or k1 <= 0:\n        raise ValueError(\"Stiffness constants must be positive.\")\n    delta_F_exact = 0.5 * K_B * T * np.log(k1 / k0)\n\n    # 2. Setup for Thermodynamic Integration\n    # Create a uniform grid of lambda points from 0 to 1.\n    lambda_grid = np.linspace(0.0, 1.0, N_lambda)\n    \n    # Initialize arrays to store the integrand values.\n    integrand_analytic = np.zeros(N_lambda)\n    integrand_mc = np.zeros(N_lambda)\n    \n    k_delta = k1 - k0\n\n    # 3. Calculate Integrand at Each Lambda Point\n    for i, lam in enumerate(lambda_grid):\n        # Effective stiffness k(lambda) = (1-lambda)*k0 + lambda*k1\n        k_lambda = (1 - lam) * k0 + lam * k1\n        \n        # 3.1. Analytical Integrand\n        # I(lambda) = <dU/d_lambda> = 0.5 * (k1-k0) * <x^2>_lambda\n        # where <x^2>_lambda = k_B*T / k_lambda from equipartition theorem.\n        integrand_analytic[i] = 0.5 * k_delta * (K_B * T / k_lambda)\n        \n        # 3.2. Monte Carlo Integrand\n        # The position x is drawn from a Gaussian distribution N(0, sigma^2)\n        # where variance sigma^2 = <x^2>_lambda = k_B*T / k_lambda.\n        sigma = np.sqrt(K_B * T / k_lambda)\n        \n        # Generate N_s random samples for x.\n        x_samples = rng.normal(loc=0.0, scale=sigma, size=N_s)\n        \n        # Estimate <x^2> from the finite sample.\n        mean_x_squared_mc = np.mean(x_samples**2)\n        \n        # MC estimator for the integrand.\n        integrand_mc[i] = 0.5 * k_delta * mean_x_squared_mc\n\n    # 4. Perform Numerical Integration over Lambda\n    if quadrature_rule.lower() == 'trapezoid':\n        delta_F_analytic_discrete = trapezoid(integrand_analytic, x=lambda_grid)\n        delta_F_mc = trapezoid(integrand_mc, x=lambda_grid)\n    elif quadrature_rule.lower() == 'simpson':\n        if N_lambda % 2 == 0:\n            raise ValueError(\"Simpson's rule requires an odd number of grid points.\")\n        delta_F_analytic_discrete = simpson(integrand_analytic, x=lambda_grid)\n        delta_F_mc = simpson(integrand_mc, x=lambda_grid)\n    else:\n        raise ValueError(f\"Unknown quadrature rule: {quadrature_rule}\")\n\n    # 5. Decompose and Calculate Errors\n    # Total error: Deviation of full MC simulation from the exact value.\n    E_tot = delta_F_mc - delta_F_exact\n    \n    # Quadrature error: Error from discretizing the lambda integral.\n    E_quad = delta_F_analytic_discrete - delta_F_exact\n    \n    # Sampling error: Error from finite MC sampling at each lambda.\n    E_samp = delta_F_mc - delta_F_analytic_discrete\n    \n    # Sanity check: E_tot = E_quad + E_samp\n    # assert np.isclose(E_tot, E_quad + E_samp)\n\n    # 6. Final Diagnostic\n    # Determine if sampling error's magnitude exceeds quadrature error's magnitude.\n    sampling_dominant = np.abs(E_samp) > np.abs(E_quad)\n    \n    return [E_tot, np.abs(E_samp), np.abs(E_quad), sampling_dominant]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    # Format: (k0, k1, T, N_lambda, N_s, quadrature_rule)\n    test_cases = [\n        (1.0, 4.0, 300.0, 21, 2000, 'Simpson'),\n        (1.0, 4.0, 300.0, 101, 50, 'Simpson'),\n        (1.0, 4.0, 300.0, 3, 20000, 'Trapezoid'),\n        (1.0, 1.2, 50.0, 5, 5000, 'Trapezoid'),\n    ]\n\n    # Use a fixed seed for the random number generator for reproducibility.\n    rng = np.random.default_rng(seed=42)\n\n    results = []\n    for case in test_cases:\n        k0, k1, T, N_lambda, N_s, quad_rule = case\n        result = calculate_ti_errors(k0, k1, T, N_lambda, N_s, quad_rule, rng)\n        results.append(result)\n\n    # Format the final output according to the problem specification.\n    # The output is a string representation of a list of lists.\n    # Example: [[val1, val2, val3, bool1], [val4, val5, val6, bool2]]\n    # Each sublist must be converted to a string.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "With a validated method, we can now tackle a genuine materials science question: determining the phase stability of an alloy. This practice involves calculating the mixing Gibbs free energy, $G_{\\text{mix}}$, for a binary alloy on a lattice described by a simplified Embedded Atom Method (EAM) potential, a quantity that governs whether elements will mix or separate. You will construct a complete thermodynamic cycle, integrating from a non-interacting lattice gas reference state to the fully interacting alloy model . This exercise demonstrates the full workflow of a practical TI calculation, from defining the integration path to correctly assembling the final thermodynamic quantity from multiple simulations and analytical corrections.",
            "id": "3762471",
            "problem": "You are modeling a binary alloy on a one-dimensional periodic lattice using a simplified Embedded Atom Method (EAM). Let the lattice have $N$ sites with periodic boundary conditions and fixed spacing $a$. Each site $i \\in \\{0,1,\\dots,N-1\\}$ is occupied by species $\\alpha_i \\in \\{A,B\\}$, with composition fixed by $N_A$ and $N_B$, and $N = N_A + N_B$. The system is at fixed temperature $T$ and volume, and thus the relevant thermodynamic potential is the Helmholtz free energy $F$. For solids at constant volume, the Gibbs free energy $G$ differs from $F$ by the product $pV$; in a fixed-lattice model at constant volume, you may neglect this correction and use $F$ in place of $G$.\n\nFundamental definitions you must base your reasoning on:\n- The partition function is $Z = \\sum_{\\mathcal{C}} \\exp\\left(-\\beta H(\\mathcal{C})\\right)$, where the sum runs over all microstates $\\mathcal{C}$ consistent with the fixed composition, $H(\\mathcal{C})$ is the Hamiltonian, and $\\beta = 1/(k_B T)$ with $k_B$ the Boltzmann constant.\n- The Helmholtz free energy is $F = -k_B T \\ln Z$.\n- For a Hamiltonian $H_\\lambda$ that depends on a coupling parameter $\\lambda \\in [0,1]$, the derivative of the free energy with respect to $\\lambda$ is $\\frac{\\partial F}{\\partial \\lambda} = \\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda$, where $\\langle \\cdot \\rangle_\\lambda$ denotes the ensemble average with respect to $Z_\\lambda = \\sum_{\\mathcal{C}} \\exp\\left(-\\beta H_\\lambda(\\mathcal{C})\\right)$.\n\nIn this problem, you must design and implement a Thermodynamic Integration (TI) cycle between a non-interacting lattice gas reference and an interacting alloy described by EAM, and use it to compute the mixing Gibbs free energy per atom of the alloy, $G_{\\text{mix}}/N$, expressed in units of $k_B T$.\n\nDefinitions of the two end-point Hamiltonians:\n- Non-interacting lattice gas reference: $H_{\\text{lg}}(\\mathcal{C}) = 0$ for all configurations $\\mathcal{C}$ consistent with the fixed composition. The corresponding reference Helmholtz free energy for fixed composition is $F_{\\text{lg}} = -k_B T \\ln W$, where $W$ is the degeneracy count of distinct configurations for the fixed composition. For a binary alloy on $N$ lattice sites, $W = \\frac{N!}{N_A! N_B!}$.\n- Interacting EAM alloy: $H_{\\text{eam}}(\\mathcal{C}) = E_{\\text{pair}}(\\mathcal{C}) + E_{\\text{embed}}(\\mathcal{C})$, where\n  $$E_{\\text{pair}}(\\mathcal{C}) = \\sum_{0 \\le i < j \\le N-1} \\phi_{\\alpha_i \\alpha_j}(r_{ij}), \\quad \\phi_{\\alpha \\beta}(r) = \\varepsilon_{\\alpha \\beta} \\exp\\left(-\\frac{r}{r_0}\\right),$$\n  $$E_{\\text{embed}}(\\mathcal{C}) = \\sum_{i=0}^{N-1} F_{\\alpha_i}\\left(\\rho_i\\right), \\quad F_{\\alpha}(\\rho) = -\\eta_\\alpha \\sqrt{\\rho}, \\quad \\rho_i = \\sum_{\\substack{j=0 \\\\ j \\ne i}}^{N-1} f_{\\alpha_i \\alpha_j}(r_{ij}), \\quad f_{\\alpha \\beta}(r) = c_{\\alpha \\beta} \\exp\\left(-\\frac{r}{r_f}\\right),$$\nwith periodic distances $r_{ij} = a \\times \\min\\left(|i-j|, N - |i-j|\\right)$. Here $\\varepsilon_{\\alpha\\beta}$ are pair interaction parameters, $c_{\\alpha\\beta}$ are electron-density contribution parameters, $\\eta_\\alpha$ are embedding strength parameters, and $r_0$, $r_f$ are decay lengths.\n\nYou must perform TI using the linear coupling path\n$$H_\\lambda(\\mathcal{C}) = (1 - \\lambda) H_{\\text{lg}}(\\mathcal{C}) + \\lambda H_{\\text{eam}}(\\mathcal{C}), \\quad \\lambda \\in [0,1],$$\nand evaluate\n$$\\Delta F_{\\text{mix}}^{\\text{TI}} = \\int_0^1 \\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda \\, d\\lambda,$$\nover the ensemble restricted to mixture configurations at fixed $(N_A, N_B)$, and similarly for the pure system references with $(N_A,N_B) = (N,0)$ and $(0,N)$.\n\nReference state corrections:\n- Combinatorial entropy: Because the lattice gas reference has $H_{\\text{lg}} = 0$, its Helmholtz free energy at fixed composition is purely entropic, $F_{\\text{lg}} = -k_B T \\ln W$. This term must be included for both the mixture and the pure references.\n- Pure-element baselines: The TI must also be performed for the pure-$A$ and pure-$B$ systems to correctly establish the free energies of the pure references under the same EAM model and lattice constraints. These are used to compute the mixing free energy relative to pure components.\n- Pressure-volume correction: In this fixed-volume lattice model, set the $pV$ contributions to zero; thus $G \\approx F$.\n\nThe final target quantity is the mixing Gibbs free energy per atom, in units of $k_B T$:\n$$\\frac{G_{\\text{mix}}}{N k_B T} = \\frac{F_{\\text{lg}}^{\\text{mix}} + \\Delta F_{\\text{mix}}^{\\text{TI}}}{N k_B T} - x_A \\frac{F_{\\text{lg}}^{A} + \\Delta F_{A}^{\\text{TI}}}{N k_B T} - x_B \\frac{F_{\\text{lg}}^{B} + \\Delta F_{B}^{\\text{TI}}}{N k_B T},$$\nwhere $x_A = \\frac{N_A}{N}$, $x_B = \\frac{N_B}{N}$, $F_{\\text{lg}}^{\\text{mix}} = -k_B T \\ln \\frac{N!}{N_A! N_B!}$, $F_{\\text{lg}}^{A} = -k_B T \\ln 1 = 0$, and $F_{\\text{lg}}^{B} = -k_B T \\ln 1 = 0$. The TI integrals are evaluated by exact enumeration of microstates at fixed composition and numerical quadrature over $\\lambda \\in [0,1]$. All results should be expressed as floats representing $\\frac{G_{\\text{mix}}}{N k_B T}$, rounded to six decimal places.\n\nAlgorithmic requirements:\n- Enumerate all distinct microstates $\\mathcal{C}$ for the given $(N,N_A)$ using combinations of site indices for species $A$; the remaining sites are species $B$.\n- Compute $H_{\\text{eam}}(\\mathcal{C})$ exactly using the provided EAM definitions.\n- For each $\\lambda$ node in a chosen quadrature rule, compute the ensemble average $\\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda$ over the restricted composition ensemble using Boltzmann weights $\\exp(-\\beta H_\\lambda(\\mathcal{C}))$.\n- Integrate the ensemble average over $\\lambda \\in [0,1]$ using a sufficiently accurate quadrature (e.g., Gauss–Legendre) to obtain $\\Delta F^{\\text{TI}}$ for the mixture and for both pure references.\n- Assemble $\\frac{G_{\\text{mix}}}{N k_B T}$ using the formula above.\n\nUnit specification:\n- Report the final results in units of $k_B T$ per atom (dimensionless), rounded to six decimal places. No physical unit symbols are to be included.\n\nTest suite:\nImplement your program to compute the final quantity for the following test cases. Use the given parameter sets exactly as specified.\n1. Happy path alloy at moderate temperature:\n   - $N = 4$, $N_A = 2$, $N_B = 2$, $a = 1.0$,\n   - $r_0 = 1.0$, $r_f = 1.0$,\n   - Pair parameters: $\\varepsilon_{AA} = -1.0$, $\\varepsilon_{BB} = -0.8$, $\\varepsilon_{AB} = -0.9$,\n   - Density parameters: $c_{AA} = 1.0$, $c_{BB} = 0.9$, $c_{AB} = 0.95$,\n   - Embedding strengths: $\\eta_A = 1.2$, $\\eta_B = 1.0$,\n   - $\\beta = 1.5$.\n2. High-temperature limit to test entropic dominance:\n   - Same parameters as case 1, but $\\beta = 0.01$.\n3. Pure component boundary:\n   - $N = 4$, $N_A = 4$, $N_B = 0$, $a = 1.0$,\n   - $r_0 = 1.0$, $r_f = 1.0$,\n   - Pair parameters: $\\varepsilon_{AA} = -1.0$, $\\varepsilon_{BB} = -0.8$, $\\varepsilon_{AB} = -0.9$,\n   - Density parameters: $c_{AA} = 1.0$, $c_{BB} = 0.9$, $c_{AB} = 0.95$,\n   - Embedding strengths: $\\eta_A = 1.2$, $\\eta_B = 1.0$,\n   - $\\beta = 0.5$.\n\nFinal output format:\nYour program should produce a single line of output containing the three computed results, each rounded to six decimal places, as a comma-separated list enclosed in square brackets, for example, \"[x1,x2,x3]\".",
            "solution": "The objective is to compute the mixing Gibbs free energy per atom, $\\frac{G_{\\text{mix}}}{N}$, of a binary alloy on a one-dimensional periodic lattice. The result is to be expressed in units of $k_B T$, making the target quantity the dimensionless value $\\frac{G_{\\text{mix}}}{N k_B T}$. The calculation is based on a simplified Embedded Atom Method (EAM) potential and utilizes thermodynamic integration (TI) to find the free energy difference between the interacting alloy and a non-interacting lattice gas reference.\n\nThe mixing Gibbs free energy is defined as the difference between the Gibbs free energy of the alloy and the weighted average of the Gibbs free energies of its pure constituents. For a fixed-volume lattice model, the pressure-volume term is negligible, allowing the use of Helmholtz free energy $F$ in place of Gibbs free energy $G$. The formula to be implemented is:\n$$\n\\frac{G_{\\text{mix}}}{N k_B T} = \\frac{F^{\\text{mix}}}{N k_B T} - x_A \\frac{F^{A}}{N k_B T} - x_B \\frac{F^{B}}{N k_B T}\n$$\nwhere $F^{\\text{mix}}$, $F^{A}$, and $F^{B}$ are the Helmholtz free energies of the mixture, pure component $A$, and pure component $B$, respectively. The mole fractions are $x_A = \\frac{N_A}{N}$ and $x_B = \\frac{N_B}{N}$.\n\nEach free energy term $F$ is composed of a reference part from the non-interacting lattice gas, $F_{\\text{lg}}$, and a contribution from turning on the interactions, $\\Delta F^{\\text{TI}}$, obtained via thermodynamic integration. Thus, $F = F_{\\text{lg}} + \\Delta F^{\\text{TI}}$. Substituting this into the mixing formula yields:\n$$\n\\frac{G_{\\text{mix}}}{N k_B T} = \\frac{F_{\\text{lg}}^{\\text{mix}} + \\Delta F_{\\text{mix}}^{\\text{TI}}}{N k_B T} - x_A \\frac{F_{\\text{lg}}^{A} + \\Delta F_{A}^{\\text{TI}}}{N k_B T} - x_B \\frac{F_{\\text{lg}}^{B} + \\Delta F_{B}^{\\text{TI}}}{N k_B T}\n$$\n\nThe calculation proceeds by evaluating each term in this expression.\n\nFirst, the ideal (non-interacting) free energy contributions, $F_{\\text{lg}}$, arise from the configurational entropy. For a system with $N$ total sites, $N_A$ of species $A$ and $N_B$ of species $B$, the number of distinct configurations is $W = \\frac{N!}{N_A! N_B!}$. The corresponding free energy is $F_{\\text{lg}} = -k_B T \\ln W$.\n- For the mixture, this gives $F_{\\text{lg}}^{\\text{mix}} = -k_B T \\ln \\frac{N!}{N_A! N_B!}$.\n- For the pure components, there is only one configuration ($W=1$), so $F_{\\text{lg}}^{A} = F_{\\text{lg}}^{B} = -k_B T \\ln 1 = 0$.\n\nThe formula for the mixing free energy per atom in units of $k_B T$ thus simplifies to:\n$$\n\\frac{G_{\\text{mix}}}{N k_B T} = -\\frac{1}{N} \\ln\\left(\\frac{N!}{N_A! N_B!}\\right) + \\frac{\\beta}{N} \\left( \\Delta F_{\\text{mix}}^{\\text{TI}} - x_A \\Delta F_{A}^{\\text{TI}} - x_B \\Delta F_{B}^{\\text{TI}} \\right)\n$$\nwhere $\\beta = \\frac{1}{k_B T}$.\n\nSecond, the terms $\\Delta F^{\\text{TI}}$ are calculated using thermodynamic integration. The Hamiltonian is coupled linearly between the non-interacting lattice gas ($H_{\\text{lg}}=0$) and the interacting EAM model ($H_{\\text{eam}}$) via a parameter $\\lambda \\in [0,1]$:\n$$\nH_\\lambda(\\mathcal{C}) = (1 - \\lambda) H_{\\text{lg}}(\\mathcal{C}) + \\lambda H_{\\text{eam}}(\\mathcal{C}) = \\lambda H_{\\text{eam}}(\\mathcal{C})\n$$\nThe change in free energy is given by the integral of the ensemble average of the derivative of the Hamiltonian with respect to $\\lambda$:\n$$\n\\Delta F^{\\text{TI}} = \\int_0^1 \\left\\langle \\frac{\\partial H_\\lambda}{\\partial \\lambda} \\right\\rangle_\\lambda \\, d\\lambda\n$$\nThe derivative is $\\frac{\\partial H_\\lambda}{\\partial \\lambda} = H_{\\text{eam}}(\\mathcal{C})$, which is independent of $\\lambda$. The integral becomes:\n$$\n\\Delta F^{\\text{TI}} = \\int_0^1 \\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda \\, d\\lambda\n$$\nwhere $\\langle \\cdot \\rangle_\\lambda$ denotes the canonical ensemble average using the Hamiltonian $H_\\lambda$.\n\nThe numerical evaluation of this integral involves two main steps:\n1.  **Computing the Ensemble Average**: For a given value of $\\lambda$, the integrand $\\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda$ is calculated by exact enumeration of all possible microstates $\\mathcal{C}$ consistent with the fixed composition. The average is a Boltzmann-weighted sum:\n    $$\n    \\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda = \\frac{\\sum_{\\mathcal{C}} H_{\\text{eam}}(\\mathcal{C}) \\exp(-\\beta H_\\lambda(\\mathcal{C}))}{\\sum_{\\mathcal{C}} \\exp(-\\beta H_\\lambda(\\mathcal{C}))} = \\frac{\\sum_{\\mathcal{C}} H_{\\text{eam}}(\\mathcal{C}) \\exp(-\\beta \\lambda H_{\\text{eam}}(\\mathcal{C}))}{\\sum_{\\mathcal{C}} \\exp(-\\beta \\lambda H_{\\text{eam}}(\\mathcal{C}))}\n    $$\n    The set of microstates $\\{\\mathcal{C}\\}$ for a composition $(N, N_A)$ is generated by considering all combinations of $N_A$ sites out of $N$ to be occupied by species $A$.\n\n2.  **Numerical Quadrature**: The integral over $\\lambda$ from $0$ to $1$ is approximated using Gauss-Legendre quadrature. This involves evaluating the integrand $\\left\\langle H_{\\text{eam}} \\right\\rangle_\\lambda$ at a set of discrete quadrature nodes $\\lambda_k$ and summing the results with corresponding weights $w_k$:\n    $$\n    \\Delta F^{\\text{TI}} \\approx \\sum_k w_k' \\left\\langle H_{\\text{eam}} \\right\\rangle_{\\lambda_k'}\n    $$\n    where $(\\lambda_k', w_k')$ are the nodes and weights transformed from the standard interval $[-1, 1]$ to $[0, 1]$.\n\nFor each configuration $\\mathcal{C}$, the energy $H_{\\text{eam}}(\\mathcal{C})$ is calculated according to the problem's EAM definition:\n$$\nH_{\\text{eam}}(\\mathcal{C}) = \\sum_{0 \\le i < j \\le N-1} \\phi_{\\alpha_i \\alpha_j}(r_{ij}) + \\sum_{i=0}^{N-1} F_{\\alpha_i}\\left(\\rho_i\\right)\n$$\nwith pair potentials $\\phi_{\\alpha \\beta}(r) = \\varepsilon_{\\alpha \\beta} \\exp(-\\frac{r}{r_0})$, embedding functions $F_{\\alpha}(\\rho) = -\\eta_\\alpha \\sqrt{\\rho}$, and electron densities $\\rho_i = \\sum_{j \\ne i} f_{\\alpha_i \\alpha_j}(r_{ij})$ where $f_{\\alpha \\beta}(r) = c_{\\alpha \\beta} \\exp(-\\frac{r}{r_f})$. The distances $r_{ij}$ account for the one-dimensional periodic boundary conditions: $r_{ij} = a \\times \\min(|i-j|, N - |i-j|)$.\n\nThe overall algorithm consists of:\n1.  For a given test case $(N, N_A, \\text{parameters}, \\beta)$, identify the composition of the mixture $(N, N_A, N_B=N-N_A)$.\n2.  Calculate the ideal mixing free energy contribution, $-\\frac{1}{N} \\ln\\left(\\frac{N!}{N_A! N_B!}\\right)$.\n3.  Perform the TI calculation to find $\\frac{\\beta}{N} \\Delta F^{\\text{TI}}$ for three systems:\n    a. The mixture itself: $(N, N_A)$.\n    b. Pure component A: $(N, N_A=N)$.\n    c. Pure component B: $(N, N_A=0)$.\n4.  Combine these terms using the final expression for $\\frac{G_{\\text{mix}}}{N k_B T}$ to obtain the result. For pure component test cases (e.g., $N_A=N$), the mixing free energy is by definition zero.\n\nThis procedure is applied to each test case provided in the problem statement.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln, roots_legendre\nfrom itertools import combinations\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the results.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": 4, \"N_A\": 2, \"a\": 1.0, \"r0\": 1.0, \"rf\": 1.0,\n            \"eps_AA\": -1.0, \"eps_BB\": -0.8, \"eps_AB\": -0.9,\n            \"c_AA\": 1.0, \"c_BB\": 0.9, \"c_AB\": 0.95,\n            \"eta_A\": 1.2, \"eta_B\": 1.0,\n            \"beta\": 1.5,\n        },\n        {\n            \"N\": 4, \"N_A\": 2, \"a\": 1.0, \"r0\": 1.0, \"rf\": 1.0,\n            \"eps_AA\": -1.0, \"eps_BB\": -0.8, \"eps_AB\": -0.9,\n            \"c_AA\": 1.0, \"c_BB\": 0.9, \"c_AB\": 0.95,\n            \"eta_A\": 1.2, \"eta_B\": 1.0,\n            \"beta\": 0.01,\n        },\n        {\n            \"N\": 4, \"N_A\": 4, \"a\": 1.0, \"r0\": 1.0, \"rf\": 1.0,\n            \"eps_AA\": -1.0, \"eps_BB\": -0.8, \"eps_AB\": -0.9,\n            \"c_AA\": 1.0, \"c_BB\": 0.9, \"c_AB\": 0.95,\n            \"eta_A\": 1.2, \"eta_B\": 1.0,\n            \"beta\": 0.5,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _calculate_g_mix(params)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef _parse_params(params):\n    \"\"\"\n    Organizes raw parameters into a structured dictionary for easy access.\n    Maps species 'A' and 'B' to indices 0 and 1.\n    \"\"\"\n    p = {\n        'N': params['N'], 'a': params['a'], 'r0': params['r0'], 'rf': params['rf'],\n        'species_map': {'A': 0, 'B': 1},\n        'eps': np.zeros((2, 2)),\n        'c': np.zeros((2, 2)),\n        'eta': np.zeros(2)\n    }\n    # Pair potentials: phi_alphabeta is symmetric\n    p['eps'][0, 0] = params['eps_AA']\n    p['eps'][1, 1] = params['eps_BB']\n    p['eps'][0, 1] = p['eps'][1, 0] = params['eps_AB']\n    # Density contributions: c_alphabeta is not necessarily symmetric\n    p['c'][0, 0] = params['c_AA']\n    p['c'][0, 1] = params['c_AB']\n    p['c'][1, 0] = params['c_AB'] # Assuming c_BA = c_AB from problem context\n    p['c'][1, 1] = params['c_BB']\n    # Embedding strengths\n    p['eta'][0] = params['eta_A']\n    p['eta'][1] = params['eta_B']\n    return p\n\ndef _calculate_eam_energy(config, params):\n    \"\"\"\n    Calculates the EAM Hamiltonian for a single configuration.\n    config: array of 0s ('A') and 1s ('B').\n    params: structured parameter dictionary.\n    \"\"\"\n    N = params['N']\n    a = params['a']\n    \n    # Pre-calculate distances\n    dists = np.zeros((N, N))\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = a * min(j - i, N - (j - i))\n            dists[i, j] = dists[j, i] = dist\n\n    # Pair energy\n    e_pair = 0.0\n    for i in range(N):\n        for j in range(i + 1, N):\n            s_i, s_j = config[i], config[j]\n            phi = params['eps'][s_i, s_j] * np.exp(-dists[i, j] / params['r0'])\n            e_pair += phi\n            \n    # Embedding energy\n    rhos = np.zeros(N)\n    for i in range(N):\n        s_i = config[i]\n        for j in range(N):\n            if i == j:\n                continue\n            s_j = config[j]\n            # f_alphai_alphaj where i is the central atom\n            f = params['c'][s_i, s_j] * np.exp(-dists[i, j] / params['rf'])\n            rhos[i] += f\n            \n    e_embed = 0.0\n    for i in range(N):\n        s_i = config[i]\n        rho_i = rhos[i]\n        if rho_i > 0:\n            e_embed -= params['eta'][s_i] * np.sqrt(rho_i)\n            \n    return e_pair + e_embed\n\ndef _perform_ti(N, N_A, p, beta, n_quad=32):\n    \"\"\"\n    Performs thermodynamic integration and returns beta * Delta_F_TI.\n    \"\"\"\n    N_B = N - N_A\n    \n    # 1. Enumerate all microstates\n    site_indices = range(N)\n    if 0 < N_A < N:\n        a_sites_options = combinations(site_indices, N_A)\n        configurations = []\n        for a_sites in a_sites_options:\n            config = np.ones(N, dtype=int) # All B (1)\n            config[list(a_sites)] = 0 # Set A (0)\n            configurations.append(config)\n    elif N_A == N: # Pure A\n        configurations = [np.zeros(N, dtype=int)]\n    else: # Pure B\n        configurations = [np.ones(N, dtype=int)]\n\n    # 2. Calculate EAM energy for each configuration\n    eam_energies = np.array([_calculate_eam_energy(c, p) for c in configurations])\n\n    # If all energies are identical (e.g., pure component), avg is constant\n    if np.all(eam_energies == eam_energies[0]):\n        delta_f_ti = eam_energies[0]\n        return beta * delta_f_ti\n\n    # 3. Setup Gauss-Legendre quadrature for integral over lambda in [0, 1]\n    nodes, weights = roots_legendre(n_quad)\n    lambda_nodes = 0.5 * (nodes + 1.0)\n    lambda_weights = 0.5 * weights\n    \n    # 4. Integrate\n    integral_val = 0.0\n    for i in range(n_quad):\n        lam = lambda_nodes[i]\n        w = lambda_weights[i]\n        \n        # Calculate ensemble average <H_eam>_lambda\n        energies_lambda = lam * eam_energies\n        # Numerically stable Boltzmann average\n        min_e = np.min(energies_lambda)\n        boltzmann_factors = np.exp(-beta * (energies_lambda - min_e))\n        partition_func = np.sum(boltzmann_factors)\n        \n        # The numerator needs H_eam, not H_lambda\n        numerator = np.sum(eam_energies * boltzmann_factors)\n        \n        avg_h_eam_lambda = numerator / partition_func\n        integral_val += w * avg_h_eam_lambda\n        \n    delta_f_ti = integral_val\n    return beta * delta_f_ti\n\ndef _calculate_g_mix(params):\n    \"\"\"\n    Calculates the mixing Gibbs free energy per atom in units of kT.\n    \"\"\"\n    N = params['N']\n    N_A = params['N_A']\n    N_B = N - N_A\n    beta = params['beta']\n    \n    # If pure component, G_mix is 0 by definition\n    if N_A == 0 or N_B == 0:\n        return 0.0\n\n    p_struct = _parse_params(params)\n    \n    # Ideal mixing free energy term\n    # F_lg_mix / (N*kT) = - (1/N) * ln(N!/(NA!*NB!))\n    # Using log-gamma for numerical stability\n    log_W = gammaln(N + 1) - gammaln(N_A + 1) - gammaln(N_B + 1)\n    g_ideal_mix = -log_W / N\n    \n    # TI for the mixture\n    beta_delta_F_mix = _perform_ti(N, N_A, p_struct, beta)\n\n    # TI for pure A reference\n    beta_delta_F_pure_A = _perform_ti(N, N, p_struct, beta)\n\n    # TI for pure B reference\n    beta_delta_F_pure_B = _perform_ti(N, 0, p_struct, beta)\n\n    # Assemble final result: G_mix / (N*kT)\n    x_A = N_A / N\n    x_B = N_B / N\n    \n    g_ex_mix_norm = beta_delta_F_mix / N\n    g_ex_A_norm = beta_delta_F_pure_A / N\n    g_ex_B_norm = beta_delta_F_pure_B / N\n\n    g_mix_total_norm = g_ideal_mix + g_ex_mix_norm - x_A * g_ex_A_norm - x_B * g_ex_B_norm\n    \n    return g_mix_total_norm\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A significant challenge in thermodynamic integration arises when the integration path crosses a first-order phase transition, violating the core assumption of reversibility and leading to incorrect results. This practice addresses this advanced pitfall, which manifests in simulations as hysteresis—the system's state depends on the direction of the change in $\\lambda$. Using a clear conceptual model, you will first see how hysteresis invalidates the direct integration and then design a corrective thermodynamic cycle to circumvent this problem . This powerful strategy of using an auxiliary biasing field to create a smooth, reversible path is essential for obtaining reliable free energies in complex systems where multiple phases may exist.",
            "id": "3762510",
            "problem": "You are modeling free-energy differences in a high-entropy alloy using alchemical interpolation. Let the Helmholtz free energy be $F(\\lambda)$ for an alchemical coupling parameter $\\lambda \\in [0,1]$, and the partition function be $Z(\\lambda)$. Use only the following foundational base: $F(\\lambda) = -k_{\\mathrm{B}} T \\ln Z(\\lambda)$, and the fact that the derivative $\\mathrm{d}F/\\mathrm{d}\\lambda$ along a smooth path is equal to the ensemble average of $\\partial H/\\partial \\lambda$ at fixed $\\lambda$, where $H$ is the Hamiltonian. You must reason from these facts and standard properties of first-order phase transitions (finite-size hysteresis and non-analyticity at coexistence) without relying on any pre-derived shortcut formulas beyond the explicitly supplied model definitions below.\n\nConsider an effective one-dimensional model for the alchemical path that captures the breakdown of thermodynamic integration when crossing a first-order transition along $\\lambda$. The model prescribes the integrand of the thermodynamic integration (the ensemble average $\\langle \\partial H/\\partial \\lambda \\rangle$) along three branches:\n- A smooth, single-phase stabilized branch $g_{\\mu}(\\lambda) \\equiv g_{\\mathrm{smooth}}(\\lambda)$ that is analytic on $[0,1]$.\n- A hysteretic increasing-$\\lambda$ branch $g_{\\uparrow}(\\lambda)$ that exhibits a discontinuity at $\\lambda_{\\uparrow}$.\n- A hysteretic decreasing-$\\lambda$ branch $g_{\\downarrow}(\\lambda)$ that exhibits a discontinuity at $\\lambda_{\\downarrow}$.\n\nDefine the smooth branch by $g_{\\mathrm{smooth}}(\\lambda) = c_0 + c_1 \\lambda + c_2 \\lambda^2$. Let the hysteretic branches be modeled by a step discontinuity of magnitude $J > 0$ using the Heaviside step function $\\Theta(x)$, where $\\Theta(x) = 0$ for $x < 0$ and $\\Theta(x) = 1$ for $x \\ge 0$:\n- $g_{\\uparrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\uparrow})$,\n- $g_{\\downarrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\downarrow})$.\n\nYou must:\n1. Starting from $F(\\lambda) = -k_{\\mathrm{B}} T \\ln Z(\\lambda)$ and the smoothness requirement for thermodynamic integration, explain why crossing a first-order transition along $\\lambda$ invalidates the method and how hysteresis between $g_{\\uparrow}$ and $g_{\\downarrow}$ quantifies this invalidation.\n2. Design a thermodynamic cycle that circumvents the phase transition by introducing an auxiliary field $\\mu$ that stabilizes a single phase for all $\\lambda \\in [0,1]$. The cycle is:\n   - Add the field at state $A$ (at $\\lambda = 0$) to reach $\\mu = \\mu_*$,\n   - Integrate $\\lambda$ from $0$ to $1$ at fixed $\\mu = \\mu_*$ along the smooth branch $g_{\\mu}(\\lambda)$,\n   - Remove the field at state $B$ (at $\\lambda = 1$).\n   Assume linear field work contributions at the endpoints with constants $s_A$ and $s_B$: $w_A = s_A \\mu_*$ at $A$ and $w_B = s_B \\mu_*$ at $B$. The net cycle free-energy change is then $F_{\\mathrm{cycle}} = \\int_0^1 g_{\\mu}(\\lambda)\\,\\mathrm{d}\\lambda + w_A - w_B$. In the special case $s_A = s_B$, the net field work cancels.\n3. Implement a program that, for each test case, computes:\n   - The direct thermodynamic integration from $\\lambda = 0$ to $\\lambda = 1$ along $g_{\\uparrow}$, as a numerical integral $\\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda$,\n   - The direct thermodynamic integration from $\\lambda = 0$ to $\\lambda = 1$ along $g_{\\downarrow}$, as a numerical integral $\\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda$,\n   - The cycle free energy $F_{\\mathrm{cycle}}$ using $g_{\\mu}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda)$ and $w_A - w_B = s_A \\mu_* - s_B \\mu_*$.\n   Use a uniform grid with $N = 10001$ points on $[0,1]$ and the trapezoidal rule for all numerical integrals. Determine a boolean invalidation flag as $\\mathrm{invalid} = \\left|\\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda - \\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda\\right| > \\varepsilon$, with tolerance $\\varepsilon = 10^{-6}$.\n4. Express all free energies in units of $k_{\\mathrm{B}} T$ (dimensionless numbers). Report floating point values without any unit symbol. Do not round; use default floating-point string formatting.\n5. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[F_{\\uparrow}, F_{\\downarrow}, F_{\\mathrm{cycle}}, \\mathrm{invalid}]$.\n\nUse the following test suite of parameter values, covering a general case, boundary conditions, and edge cases. Each tuple corresponds to $(c_0, c_1, c_2, J, \\lambda_{\\uparrow}, \\lambda_{\\downarrow}, \\mu_*, s_A, s_B)$:\n- Case $1$: $(0.5, -0.2, 0.1, 1.0, 0.65, 0.35, 0.8, 0.3, 0.3)$.\n- Case $2$: $(0.2, 0.0, 0.3, 0.5, 0.05, 0.95, 0.6, 0.1, 0.1)$.\n- Case $3$: $(-0.1, 0.4, -0.2, 0.05, 0.5, 0.5, 0.7, 0.2, 0.2)$.\n- Case $4$: $(1.0, -0.5, 0.25, 2.0, 0.8, 0.2, 1.0, 0.4, 0.4)$.\n\nYour program must compute, for each case, the triple of free energies and the invalidation flag described above and print a single line as $[[F_{\\uparrow}^{(1)}, F_{\\downarrow}^{(1)}, F_{\\mathrm{cycle}}^{(1)}, \\mathrm{invalid}^{(1)}],\\ldots,[F_{\\uparrow}^{(4)}, F_{\\downarrow}^{(4)}, F_{\\mathrm{cycle}}^{(4)}, \\mathrm{invalid}^{(4)}]]$.",
            "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the principles of statistical mechanics and computational chemistry, well-posed with all necessary parameters and methods defined, and objective in its formulation. The problem provides a conceptually sound, albeit simplified, model to explore the challenges of thermodynamic integration across first-order phase transitions and the standard technique used to circumvent them.\n\nThe solution is structured into three parts as requested: a theoretical explanation of the method's invalidation, a description of the corrective thermodynamic cycle, and the design of the numerical implementation.\n\n### 1. Invalidation of Thermodynamic Integration at a First-Order Transition\n\nThe Helmholtz free energy difference, $\\Delta F$, between two states characterized by an alchemical coupling parameter $\\lambda = 0$ and $\\lambda = 1$ is given by the fundamental thermodynamic integration formula. This formula is derived from the definition of Helmholtz free energy, $F(\\lambda) = -k_{\\mathrm{B}} T \\ln Z(\\lambda)$, where $k_{\\mathrm{B}}$ is the Boltzmann constant, $T$ is the temperature, and $Z(\\lambda)$ is the partition function. The derivative of $F(\\lambda)$ with respect to $\\lambda$ is:\n$$\n\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda} = \\frac{\\mathrm{d}}{\\mathrm{d}\\lambda} (-k_{\\mathrm{B}} T \\ln Z(\\lambda)) = -k_{\\mathrm{B}} T \\frac{1}{Z(\\lambda)} \\frac{\\mathrm{d}Z}{\\mathrm{d}\\lambda}\n$$\nThe partition function is $Z(\\lambda) = \\int e^{-H(\\mathbf{x};\\lambda)/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}$, where $H(\\mathbf{x};\\lambda)$ is the Hamiltonian of the system. Its derivative is $\\frac{\\mathrm{d}Z}{\\mathrm{d}\\lambda} = \\int \\left(-\\frac{1}{k_{\\mathrm{B}}T} \\frac{\\partial H}{\\partial \\lambda}\\right) e^{-H(\\mathbf{x};\\lambda)/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}$. Substituting this into the expression for $\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda}$ yields:\n$$\n\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda} = -k_{\\mathrm{B}} T \\frac{1}{Z(\\lambda)} \\int \\left(-\\frac{1}{k_{\\mathrm{B}}T} \\frac{\\partial H}{\\partial \\lambda}\\right) e^{-H/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x} = \\frac{\\int \\frac{\\partial H}{\\partial \\lambda} e^{-H/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}}{\\int e^{-H/(k_{\\mathrm{B}} T)} \\mathrm{d}\\mathbf{x}} = \\left\\langle \\frac{\\partial H}{\\partial \\lambda} \\right\\rangle_{\\lambda}\n$$\nThis shows that the derivative of the free energy is the ensemble average of the derivative of the Hamiltonian. By the fundamental theorem of calculus, the total free energy difference is the integral of its derivative:\n$$\n\\Delta F = F(\\lambda=1) - F(\\lambda=0) = \\int_0^1 \\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda} \\mathrm{d}\\lambda = \\int_0^1 \\left\\langle \\frac{\\partial H}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\mathrm{d}\\lambda\n$$\nThis integration is valid if and only if the path between $\\lambda=0$ and $\\lambda=1$ is thermodynamically reversible. A first-order phase transition at some $\\lambda_c \\in (0,1)$ is characterized by a discontinuity in the first derivative of the free energy, $\\frac{\\mathrm{d}F}{\\mathrm{d}\\lambda}$. This means the integrand $\\left\\langle \\frac{\\partial H}{\\partial \\lambda} \\right\\rangle$ is discontinuous. Any finite-speed traversal across such a discontinuity is inherently irreversible.\n\nIn a finite-size system simulation, this non-analyticity manifests as hysteresis. When increasing $\\lambda$ (the forward path), the system remains in a metastable state past the transition point $\\lambda_c$ before abruptly switching to the new phase at $\\lambda_{\\uparrow} > \\lambda_c$. When decreasing $\\lambda$ (the backward path), it again remains in a metastable state before switching back at $\\lambda_{\\downarrow} < \\lambda_c$. This leads to two different measured functions for the integrand, $g_{\\uparrow}(\\lambda)$ and $g_{\\downarrow}(\\lambda)$, depending on the direction of the simulation.\n\nConsequently, computing the integral yields two different results:\n$$\n\\Delta F_{\\uparrow} = \\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda \\neq \\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda = \\Delta F_{\\downarrow}\n$$\nSince free energy is a state function, its change, $\\Delta F$, must be independent of the path taken. The fact that $\\Delta F_{\\uparrow} \\neq \\Delta F_{\\downarrow}$ proves that both calculations are incorrect and that the direct thermodynamic integration procedure has failed. The hysteresis, quantified by the area between the two curves, $\\left| \\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda - \\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda \\right|$, represents the work dissipated during the irreversible cycle and is a direct measure of the method's invalidation.\n\n### 2. The Corrective Thermodynamic Cycle\n\nTo obtain the correct free energy difference, one must construct an alternative, reversible path between the initial state ($\\lambda=0$) and the final state ($\\lambda=1$). The problem describes such a path using an auxiliary field $\\mu$. This constructs a thermodynamic cycle:\n1.  **Leg 1 ($A \\to A'$):** At constant $\\lambda=0$, the auxiliary field is applied, changing from $\\mu=0$ to $\\mu=\\mu_*$. The free energy change is the work done on the system, which is given as a linear contribution: $\\Delta F_{A \\to A'} = w_A = s_A \\mu_*$.\n2.  **Leg 2 ($A' \\to B'$):** At constant field $\\mu=\\mu_*$, the alchemical parameter is changed from $\\lambda=0$ to $\\lambda=1$. The field $\\mu_*$ is chosen to be strong enough to suppress the phase transition, ensuring the system remains in a single, stable phase for all $\\lambda \\in [0,1]$. This makes the path reversible. The integrand becomes the smooth, analytic function $g_{\\mu}(\\lambda) \\equiv g_{\\mathrm{smooth}}(\\lambda)$. The free energy change for this leg is $\\Delta F_{A' \\to B'} = \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda$.\n3.  **Leg 3 ($B' \\to B$):** At constant $\\lambda=1$, the auxiliary field is removed, changing from $\\mu=\\mu_*$ to $\\mu=0$. The free energy change is the negative of the work required to apply the field in this state: $\\Delta F_{B' \\to B} = -w_B = -s_B \\mu_*$.\n\nSince free energy is a state function, the total change along the path $A \\to B$ is the sum of the changes along the alternative path $A \\to A' \\to B' \\to B$:\n$$\n\\Delta F_{\\mathrm{cycle}} = F(B) - F(A) = \\Delta F_{A \\to A'} + \\Delta F_{A' \\to B'} + \\Delta F_{B' \\to B}\n$$\nSubstituting the expressions for each leg gives the correct, path-independent free energy difference:\n$$\n\\Delta F_{\\mathrm{cycle}} = w_A + \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda - w_B = \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda + (s_A - s_B) \\mu_*\n$$\nThis value, $F_{\\mathrm{cycle}}$, represents the true free energy difference in units of $k_{\\mathrm{B}} T$. In the special case where the work of adding and removing the field is identical ($s_A = s_B$), the work terms cancel, and the free energy is given solely by the integral along the smooth path.\n\n### 3. Numerical Implementation\n\nThe required quantities are computed numerically. The free energies are expressed in units of $k_{\\mathrm{B}} T$, making them dimensionless.\n- The independent variable is $\\lambda$, on the interval $[0,1]$. A uniform grid with $N=10001$ points is used, defined by $\\lambda_i = i/(N-1)$ for $i=0, 1, \\ldots, N-1$.\n- The three integrands are defined as per the problem statement:\n    - $g_{\\mathrm{smooth}}(\\lambda) = c_0 + c_1 \\lambda + c_2 \\lambda^2$\n    - $g_{\\uparrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\uparrow})$\n    - $g_{\\downarrow}(\\lambda) = g_{\\mathrm{smooth}}(\\lambda) + J \\,\\Theta(\\lambda - \\lambda_{\\downarrow})$\n    where the Heaviside function $\\Theta(x)$ is implemented such that it returns $1$ for $x \\ge 0$ and $0$ otherwise.\n- The integrals $\\int_0^1 g_{\\uparrow}(\\lambda)\\,\\mathrm{d}\\lambda$ (giving $F_{\\uparrow}$) and $\\int_0^1 g_{\\downarrow}(\\lambda)\\,\\mathrm{d}\\lambda$ (giving $F_{\\downarrow}$) are computed using the trapezoidal rule on the discretized functions.\n- The cycle free energy is computed as $F_{\\mathrm{cycle}} = \\int_0^1 g_{\\mathrm{smooth}}(\\lambda)\\,\\mathrm{d}\\lambda + (s_A - s_B) \\mu_*$, where the integral is also evaluated using the trapezoidal rule.\n- The invalidation flag is a boolean determined by the condition: $\\mathrm{invalid} = |\\Delta F_{\\uparrow} - \\Delta F_{\\downarrow}| > \\varepsilon$, where the tolerance $\\varepsilon$ is $10^{-6}$.\n\nThe process is repeated for each set of parameters provided in the test suite. The final output is assembled into a list of lists, with each inner list containing the four computed values for a given test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes free energies for different thermodynamic paths based on a model\n    for thermodynamic integration across a first-order phase transition.\n    \"\"\"\n    # Test cases: tuples of (c0, c1, c2, J, lambda_up, lambda_down, mu_star, sA, sB)\n    test_cases = [\n        (0.5, -0.2, 0.1, 1.0, 0.65, 0.35, 0.8, 0.3, 0.3),\n        (0.2, 0.0, 0.3, 0.5, 0.05, 0.95, 0.6, 0.1, 0.1),\n        (-0.1, 0.4, -0.2, 0.05, 0.5, 0.5, 0.7, 0.2, 0.2),\n        (1.0, -0.5, 0.25, 2.0, 0.8, 0.2, 1.0, 0.4, 0.4),\n    ]\n\n    # Numerical integration parameters\n    N = 10001\n    lambdas = np.linspace(0, 1, N)\n    epsilon = 1e-6\n    \n    results = []\n\n    for case in test_cases:\n        c0, c1, c2, J, lambda_up, lambda_down, mu_star, sA, sB = case\n\n        # Define the integrand functions\n        # g_smooth is the polynomial base for the stabilized path\n        g_smooth = c0 + c1 * lambdas + c2 * lambdas**2\n\n        # g_up represents the forward (increasing lambda) hysteretic path\n        # The Heaviside step function is implemented using a boolean comparison\n        g_up = g_smooth + J * (lambdas >= lambda_up)\n\n        # g_down represents the backward (decreasing lambda) hysteretic path\n        g_down = g_smooth + J * (lambdas >= lambda_down)\n\n        # 1. Compute the direct integration along the increasing-lambda path\n        F_up = np.trapz(g_up, lambdas)\n\n        # 2. Compute the direct integration along the decreasing-lambda path\n        F_down = np.trapz(g_down, lambdas)\n\n        # 3. Compute the free energy from the corrective thermodynamic cycle\n        # First, integrate along the smooth, stabilized path\n        integral_smooth = np.trapz(g_smooth, lambdas)\n        # Add the net work done by the auxiliary field\n        F_cycle = integral_smooth + (sA - sB) * mu_star\n\n        # 4. Determine the invalidation flag based on hysteresis\n        is_invalid = abs(F_up - F_down) > epsilon\n        \n        # Collect results for this test case\n        results.append([F_up, F_down, F_cycle, is_invalid])\n\n    # Format the output string precisely as required: [[r1,r2,r3,r4],[...],...]\n    # This involves building the string manually to avoid spaces introduced by str(list).\n    inner_strings = []\n    for res_list in results:\n        # Format each element and join with commas, then wrap in brackets\n        res_str = f\"[{res_list[0]},{res_list[1]},{res_list[2]},{'True' if res_list[3] else 'False'}]\"\n        inner_strings.append(res_str)\n    \n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```"
        }
    ]
}