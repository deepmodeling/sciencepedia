{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个实践将为后续内容奠定基础。我们将从一个简单但功能强大的“避开交叉”模型入手，其旨在揭示对玻恩-奥本海默近似的主要修正——即对角玻恩-奥本海默修正（DBOC）。通过推导和计算该修正项，您将具体理解核质量如何影响玻恩-奥本海默近似的准确性，这是分子和材料建模中的一个基本概念。",
            "id": "3760549",
            "problem": "考虑一个高熵合金中的粗粒化局域环境，该环境通过一个双能级电子子空间进行建模，该子空间与一维核坐标线性耦合。设电子哈密顿量为\n$$\nH_{e}(Q) \\;=\\; \\begin{pmatrix}\n\\Delta + \\kappa Q  & V \\\\\nV & -\\big(\\Delta + \\kappa Q\\big)\n\\end{pmatrix},\n$$\n其中 $Q$ 是核坐标（单位为玻尔半径 $a_0$），$\\Delta$ 和 $V$ 是能量尺度（单位为哈特里 $\\mathrm{Ha}$），$\\kappa$ 是耦合常数（单位为 $\\mathrm{Ha}/a_0$）。核动能算符为 $-\\frac{1}{2M}\\frac{d^{2}}{dQ^{2}}$，其中 $M$ 是原子单位制下（即以电子质量为单位测量）的无量纲核质量。假设核势是平滑的，且对于避免交叉点附近的核运动，较低的绝热势能面是相关的势能面。使用玻恩-奥本海默 (BO) 近似及其从第一性原理出发的领头绝热修正定义，通过条件 $\\Delta + \\kappa Q_{c} = 0$ 确定避免交叉坐标 $Q_{c}$，推导领头的BO误差（此处定义为在 $Q_{c}$ 处计算的对较低绝热势能面的对角玻恩-奥本海默修正），然后对以下质量比计算该能量的数值估计：\n$$\nM \\in \\{10^{3},\\,10^{4},\\,10^{5}\\}.\n$$\n使用参数值 $\\Delta = 0.1\\,\\mathrm{Ha}$，$V = 0.05\\,\\mathrm{Ha}$，以及 $\\kappa = 0.2\\,\\mathrm{Ha}/a_0$。最终能量以 $\\mathrm{meV}$ 表示，并将您的答案四舍五入到三位有效数字。使用换算关系 $1\\,\\mathrm{Ha} = 27.211386\\,\\mathrm{eV}$ 和 $1\\,\\mathrm{eV} = 1000\\,\\mathrm{meV}$。",
            "solution": "首先对问题进行验证，以确保其科学上合理、适定且客观。\n\n**第1步：提取已知条件**\n- 电子哈密顿量：$H_{e}(Q) = \\begin{pmatrix} \\Delta + \\kappa Q  & V \\\\ V  & -\\big(\\Delta + \\kappa Q\\big) \\end{pmatrix}$\n- 核动能算符：$T_N = -\\frac{1}{2M}\\frac{d^{2}}{dQ^{2}}$\n- 变量：$Q$（核坐标，单位为 $a_0$），$\\Delta$（能量，单位为 $\\mathrm{Ha}$），$V$（能量，单位为 $\\mathrm{Ha}$），$\\kappa$（耦合常数，单位为 $\\mathrm{Ha}/a_0$），$M$（无量纲核质量）\n- 避免交叉条件：$\\Delta + \\kappa Q_{c} = 0$\n- 任务：推导领头的玻恩-奥本海默 (BO) 误差，定义为在 $Q_{c}$ 处计算的对较低绝热势能面的对角玻恩-奥本海默修正 (DBOC)，并计算其数值。\n- 参数值：$\\Delta = 0.1\\,\\mathrm{Ha}$，$V = 0.05\\,\\mathrm{Ha}$，$\\kappa = 0.2\\,\\mathrm{Ha}/a_0$\n- 质量比：$M \\in \\{10^{3},\\,10^{4},\\,10^{5}\\}$\n- 换算因子：$1\\,\\mathrm{Ha} = 27.211386\\,\\mathrm{eV}$，$1\\,\\mathrm{eV} = 1000\\,\\mathrm{meV}$\n\n**第2步：验证**\n该问题具有科学依据，描述了一个用于避免交叉的标准双能级模型，这是量子化学和物理学中的一个基本概念。玻恩-奥本海默近似及其修正对于分子与材料建模至关重要。该问题是适定的，因为已提供所有必要的参数、定义和条件以找到唯一解。语言客观而精确。参数在物理上是合理的。未发现与科学不合理性、不完整性或模糊性相关的缺陷。\n\n**第3步：结论**\n该问题是有效的。\n\n**求解推导**\n\n玻恩-奥本海默 (BO) 近似将电子运动与核运动分离。首先，我们求解固定核坐标 $Q$ 下的不含时电子薛定谔方程：\n$$\nH_e(Q) |\\Psi_n(Q)\\rangle = E_n(Q) |\\Psi_n(Q)\\rangle\n$$\n此处，$E_n(Q)$ 是绝热势能面 (PES)，$|\\Psi_n(Q)\\rangle$ 是相应的绝热电子本征态。对于给定的哈密顿量，令 $D(Q) = \\Delta + \\kappa Q$。该矩阵为：\n$$\nH_{e}(Q) = \\begin{pmatrix} D(Q) & V \\\\ V & -D(Q) \\end{pmatrix}\n$$\n通过求解特征方程 $\\det(H_e(Q) - \\lambda I) = 0$ 来找到本征值：\n$$\n(D(Q) - \\lambda)(-D(Q) - \\lambda) - V^2 = 0 \\implies \\lambda^2 - D(Q)^2 - V^2 = 0\n$$\n这给出了两个绝热势能面：\n$$\nE_{\\pm}(Q) = \\pm \\sqrt{D(Q)^2 + V^2} = \\pm \\sqrt{(\\Delta + \\kappa Q)^2 + V^2}\n$$\n该问题涉及较低的绝热势能面，$E_{-}(Q) = - \\sqrt{(\\Delta + \\kappa Q)^2 + V^2}$。\n\n为了找到相应的本征矢量 $|\\Psi_{-}(Q)\\rangle$，我们可以使用混合角 $\\theta(Q)$ 来参数化哈密顿量，使得 $\\tan(2\\theta(Q)) = V/D(Q)$。对应于较低势能面 $E_{-}(Q)$ 的归一化本征矢量为：\n$$\n|\\Psi_{-}(Q)\\rangle = \\begin{pmatrix} -\\sin(\\theta(Q)) \\\\ \\cos(\\theta(Q)) \\end{pmatrix}\n$$\n该问题将领头的BO误差定义为对角玻恩-奥本海默修正 (DBOC)，它为BO势增加了一个修正项。在原子单位制（$\\hbar=1$，$m_e=1$）的框架下，对于态 $|\\Psi_n(Q)\\rangle$ 的 DBOC 由下式给出：\n$$\n\\delta E_n^{\\mathrm{DBOC}}(Q) = \\left\\langle \\Psi_n(Q) \\left| T_N \\right| \\Psi_n(Q) \\right\\rangle_{\\mathrm{el}} = \\left\\langle \\Psi_n(Q) \\left| -\\frac{1}{2M}\\frac{d^2}{dQ^2} \\right| \\Psi_n(Q) \\right\\rangle_{\\mathrm{el}}\n$$\n其中下标 'el' 表示仅对电子坐标积分。\n对于实归一化电子波函数，该表达式可以简化。使用恒等式 $\\langle \\Psi_n | \\frac{d^2 \\Psi_n}{dQ^2} \\rangle = - \\langle \\frac{d\\Psi_n}{dQ} | \\frac{d\\Psi_n}{dQ} \\rangle$，DBOC 成为一个正定值：\n$$\n\\delta E_n^{\\mathrm{DBOC}}(Q) = \\frac{1}{2M} \\left\\langle \\frac{d\\Psi_n}{dQ} \\middle| \\frac{d\\Psi_n}{dQ} \\right\\rangle = \\frac{1}{2M} \\left\\| \\frac{d\\Psi_n(Q)}{dQ} \\right\\|^2\n$$\n我们需要为较低的势能面 $|\\Psi_{-}(Q)\\rangle$ 计算这个值。首先，我们求本征矢量关于 $Q$ 的导数：\n$$\n\\frac{d|\\Psi_{-}(Q)\\rangle}{dQ} = \\frac{d}{dQ} \\begin{pmatrix} -\\sin(\\theta(Q)) \\\\ \\cos(\\theta(Q)) \\end{pmatrix} = \\frac{d\\theta}{dQ} \\begin{pmatrix} -\\cos(\\theta(Q)) \\\\ -\\sin(\\theta(Q)) \\end{pmatrix}\n$$\n该矢量的范数的平方为：\n$$\n\\left\\| \\frac{d|\\Psi_{-}(Q)\\rangle}{dQ} \\right\\|^2 = \\left(\\frac{d\\theta}{dQ}\\right)^2 \\left( (-\\cos\\theta)^2 + (-\\sin\\theta)^2 \\right) = \\left(\\frac{d\\theta}{dQ}\\right)^2\n$$\n因此，DBOC 为 $\\delta E_{-}^{\\mathrm{DBOC}}(Q) = \\frac{1}{2M} \\left(\\frac{d\\theta}{dQ}\\right)^2$。\n接下来，我们从关系式 $\\tan(2\\theta) = V/(\\Delta + \\kappa Q)$ 确定 $\\frac{d\\theta}{dQ}$。对 $Q$ 求导：\n$$\n\\frac{d}{dQ} \\tan(2\\theta) = 2 \\sec^2(2\\theta) \\frac{d\\theta}{dQ}\n$$\n$$\n\\frac{d}{dQ} \\left( \\frac{V}{\\Delta + \\kappa Q} \\right) = -\\frac{V \\kappa}{(\\Delta + \\kappa Q)^2}\n$$\n将两者相等，并使用 $\\sec^2(2\\theta) = 1 + \\tan^2(2\\theta) = 1 + \\frac{V^2}{(\\Delta+\\kappa Q)^2} = \\frac{(\\Delta+\\kappa Q)^2 + V^2}{(\\Delta+\\kappa Q)^2}$：\n$$\n2 \\left(\\frac{(\\Delta+\\kappa Q)^2 + V^2}{(\\Delta+\\kappa Q)^2}\\right) \\frac{d\\theta}{dQ} = -\\frac{V \\kappa}{(\\Delta+\\kappa Q)^2}\n$$\n解出 $\\frac{d\\theta}{dQ}$：\n$$\n\\frac{d\\theta}{dQ} = -\\frac{V \\kappa}{2 \\left( (\\Delta + \\kappa Q)^2 + V^2 \\right)}\n$$\n题目要求在避免交叉坐标 $Q_c$ 处计算该值，该坐标由条件 $\\Delta + \\kappa Q_c = 0$ 定义。在此特定点，导数显著简化：\n$$\n\\left. \\frac{d\\theta}{dQ} \\right|_{Q=Q_c} = -\\frac{V \\kappa}{2 (0^2 + V^2)} = -\\frac{V \\kappa}{2 V^2} = -\\frac{\\kappa}{2V}\n$$\n现在我们可以计算在 $Q_c$ 处的 DBOC：\n$$\n\\delta E_{-}^{\\mathrm{DBOC}}(Q_c) = \\frac{1}{2M} \\left( \\left. \\frac{d\\theta}{dQ} \\right|_{Q=Q_c} \\right)^2 = \\frac{1}{2M} \\left( -\\frac{\\kappa}{2V} \\right)^2 = \\frac{\\kappa^2}{8 M V^2}\n$$\n这就是领头BO误差的最终解析表达式。此表达式的单位是哈特里，这在原子单位制下进行的计算中是常规做法。\n\n**数值计算**\n我们代入给定的参数值：$\\kappa = 0.2\\,\\mathrm{Ha}/a_0$ 和 $V = 0.05\\,\\mathrm{Ha}$。\n$$\n\\delta E_{-}^{\\mathrm{DBOC}}(Q_c) = \\frac{(0.2)^2}{8 M (0.05)^2} \\, \\mathrm{Ha} = \\frac{0.04}{8 M (0.0025)} \\, \\mathrm{Ha} = \\frac{0.04}{0.02 M} \\, \\mathrm{Ha} = \\frac{2}{M} \\, \\mathrm{Ha}\n$$\n现在，我们为三个给定的质量比计算这个能量，并使用 $1\\,\\mathrm{Ha} \\approx 27211.386\\,\\mathrm{meV}$ 将其转换为 $\\mathrm{meV}$。\n\n1.  对于 $M = 10^3$：\n    $$\n    E_1 = \\frac{2}{10^3} \\, \\mathrm{Ha} = 0.002 \\times 27211.386\\,\\mathrm{meV} \\approx 54.42277\\,\\mathrm{meV}\n    $$\n    四舍五入到三位有效数字，$E_1 \\approx 54.4\\,\\mathrm{meV}$。\n\n2.  对于 $M = 10^4$：\n    $$\n    E_2 = \\frac{2}{10^4} \\, \\mathrm{Ha} = 0.0002 \\times 27211.386\\,\\mathrm{meV} \\approx 5.442277\\,\\mathrm{meV}\n    $$\n    四舍五入到三位有效数字，$E_2 \\approx 5.44\\,\\mathrm{meV}$。\n\n3.  对于 $M = 10^5$：\n    $$\n    E_3 = \\frac{2}{10^5} \\, \\mathrm{Ha} = 0.00002 \\times 27211.386\\,\\mathrm{meV} \\approx 0.5442277\\,\\mathrm{meV}\n    $$\n    四舍五入到三位有效数字，$E_3 \\approx 0.544\\,\\mathrm{meV}$。\n\n结果表明，BO修正能量随着核质量的增加而减小，这符合预期的物理行为，因为更重的原子核更具经典性，BO近似也变得更加准确。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 54.4 & 5.44 & 0.544 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在我们理解了电子基态之后，本实践将重点转向玻恩-奥本海默分子动力学（BO MD）模拟的实际应用。我们将构建一个计算成本模型，该模型将模拟分解为其核心组成部分，例如电子结构计算和力评估。这项练习让您深入了解是什么使得大规模模拟的计算成本如此高昂，并帮助您预测性能瓶颈，这对任何计算科学家来说都是一项至关重要的技能。",
            "id": "3760505",
            "problem": "考虑一个用于化学无序高熵合金的 Born-Oppenheimer 分子动力学 (BO MD) 工作流程，该合金被建模为一个原子核和电子的系统，其中原子核的运动在基态电子势能面上进行。从固定原子核坐标下的不含时电子薛定谔方程以及在 Born-Oppenheimer 近似下电子与原子核自由度的分离开始。在每个分子动力学步骤中，通过自洽场 (SCF) 程序确定基态电子密度。对原子核应用恒温控制以对目标系综进行采样。原子核上的力评估通过电子基态获得，例如通过 Hellmann-Feynman 力。目标是推导、实现并评估一个算法成本模型，以预测大规模计算时的计算瓶颈。\n\n运用基本原理和经过充分检验的事实，从第一性原理出发推导出实现预测性运行时间和瓶颈分析所需的以下要素：\n\n- 在 Born-Oppenheimer 近似下，针对固定原子核的电子结构子问题，从电子哈密顿量 $H_{\\mathrm{e}}(\\{\\mathbf{R}_I\\})$ 和定态薛定谔方程 $H_{\\mathrm{e}}(\\{\\mathbf{R}_I\\}) \\lvert \\Psi_{\\mathrm{e}} \\rangle = E_{\\mathrm{e}} \\lvert \\Psi_{\\mathrm{e}} \\rangle$ 开始，其中 $\\{\\mathbf{R}_I\\}$ 是原子核坐标。阐述基态电子能量 $E_{\\mathrm{e}}(\\{\\mathbf{R}_I\\})$ 如何定义原子核的势能面。\n- 将自洽场 (SCF) 迭代视为使用线性混合方法求解电子密度或势的定点迭代，其残差更新为 $r_{n+1} = (1 - \\alpha)\\, r_n$，其中混合参数 $\\alpha$ 在区间 $(0,1)$ 内，初始残差为 $r_0$，收敛判据为 $r_n \\le \\varepsilon$。在给定 $r_0$、$\\varepsilon$、$\\alpha$ 和最大迭代次数上限 $I_{\\max}$ 的情况下，推导出达到收敛所需的 SCF 迭代次数 $n_{\\mathrm{SCF}}$。\n- 基于广泛使用的标度律的每次 SCF 迭代的计算成本模型：\n  - 对角化或子空间对角化成本，对于每个 $k$ 点的 $M$ 个基函数，其标度为 $\\mathcal{O}(M^3)$，共有 $K$ 个 $k$ 点，由一个与 $K\\, M^3$ 成正比的项建模。\n  - 哈密顿量/势构建成本，对于 $N$ 个原子核和 $M$ 个基函数，其标度为 $\\mathcal{O}(N\\,M)$。\n  - 混合/正交化成本，其标度为 $\\mathcal{O}(M^2)$。\n- 每个分子动力学步骤的力评估模型，其中成对邻居相互作用近似原子核之间的短程贡献，估计的对数为 $P \\approx N z / 2$，其中 $z$ 是在物理上有意义的截断半径内的平均邻居数。论证其相对于 $N$ 和 $z$ 的标度关系。\n- 每个分子动力学步骤的恒温控制更新（例如，Langevin 或 Nosé-Hoover），其与原子核数 $N$呈线性标度关系。\n\n假设计算成本的建模系数如下，单位为秒：\n- 对角化系数 $c_{\\mathrm{d}} = 10^{-9}$。\n- 哈密顿量/势构建系数 $c_{\\mathrm{h}} = 10^{-10}$。\n- 混合/正交化系数 $c_{\\mathrm{m}} = 5 \\times 10^{-9}$。\n- 力评估系数 $c_{\\mathrm{f}} = 10^{-6}$ 每对。\n- 恒温控制/积分系数 $c_{\\mathrm{t}} = 10^{-7}$ 每原子核。\n\n定义每次 SCF 迭代的成本为\n- 对角化贡献 $C_{\\mathrm{diag}} = K\\, c_{\\mathrm{d}}\\, M^3$，\n- 哈密顿量构建贡献 $C_{\\mathrm{ham}} = c_{\\mathrm{h}}\\, N\\, M$，\n- 混合贡献 $C_{\\mathrm{mix}} = c_{\\mathrm{m}}\\, M^2$。\n定义每步的力和恒温控制成本为\n- 力贡献 $C_{\\mathrm{force}} = c_{\\mathrm{f}}\\, P = c_{\\mathrm{f}}\\, \\frac{N z}{2}$，\n- 恒温控制贡献 $C_{\\mathrm{therm}} = c_{\\mathrm{t}}\\, N$。\n\n设分子动力学的总步数为 $T$。总挂钟时间应建模为\n$$\nC_{\\mathrm{total}} = T \\left( n_{\\mathrm{SCF}} \\left( C_{\\mathrm{diag}} + C_{\\mathrm{ham}} + C_{\\mathrm{mix}} \\right) + C_{\\mathrm{force}} + C_{\\mathrm{therm}} \\right).\n$$\n通过比较整个模拟过程中各个贡献的总和来确定主要瓶颈，以确定五个分量中哪一个占主导地位：\n- 对角化 $(0)$，\n- 哈密顿量构建 $(1)$，\n- 混合 $(2)$，\n- 力评估 $(3)$，\n- 恒温控制/积分 $(4)$。\n\n对于每个测试用例，您的程序必须计算总时间 $C_{\\mathrm{total}}$（单位为秒，四舍五入到三位小数）和瓶颈代码（从 $\\{0,1,2,3,4\\}$ 中选择的整数）。如果混合参数 $\\alpha$ 不在开区间 $(0,1)$ 内，则设置 $n_{\\mathrm{SCF}} = I_{\\max}$。如果 $r_0 \\le \\varepsilon$，则设置 $n_{\\mathrm{SCF}} = 0$。如果 $r_0 > \\varepsilon$ 且 $\\alpha \\in (0,1)$，则推导并使用线性混合模型所需的精确整数迭代次数，并以 $I_{\\max}$ 作为其上限。\n\n物理单位：总运行时间以秒表示。角度不是必需的。所有输出必须为数值。\n\n测试套件参数如下，所有数字和符号的解释如上所述：\n- 案例 A（通用高熵合金模拟）：$N = 128$，$M = 1024$，$K = 4$，$\\alpha = 0.4$，$r_0 = 10^{-1}$，$\\varepsilon = 10^{-6}$，$I_{\\max} = 100$，$z = 12$，$T = 50$。\n- 案例 B（边界情况，已收敛）：$N = 64$，$M = 256$，$K = 1$，$\\alpha = 0.3$，$r_0 = 10^{-8}$，$\\varepsilon = 10^{-6}$，$I_{\\max} = 50$，$z = 8$，$T = 10$。\n- 案例 C（因混合参数小而收敛缓慢）：$N = 200$，$M = 1500$，$K = 2$，$\\alpha = 0.05$，$r_0 = 10^{-1}$，$\\varepsilon = 10^{-8}$，$I_{\\max} = 200$，$z = 10$，$T = 2$。\n- 案例 D（极端规模）：$N = 4096$，$M = 8192$，$K = 8$，$\\alpha = 0.5$，$r_0 = 10^{-1}$，$\\varepsilon = 10^{-6}$，$I_{\\max} = 50$，$z = 12$，$T = 5$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按 A、B、C、D 的顺序交替显示每个测试用例的总运行时间和瓶颈代码。例如，格式必须是 $\\left[ C_{\\mathrm{total}}^{(A)}, b^{(A)}, C_{\\mathrm{total}}^{(B)}, b^{(B)}, C_{\\mathrm{total}}^{(C)}, b^{(C)}, C_{\\mathrm{total}}^{(D)}, b^{(D)} \\right]$，其中每个 $C_{\\mathrm{total}}^{(\\cdot)}$ 是一个四舍五入到三位小数的浮点数（单位为秒），每个 $b^{(\\cdot)}$ 是一个在 $\\{0,1,2,3,4\\}$ 中的整数瓶颈代码。",
            "solution": "该问题被验证为科学上合理、提法明确且完整。它提出了一个简化但具有代表性的 Born-Oppenheimer 分子动力学 (BO MD) 模拟模型，其基础是量子力学和计算科学的原理。我们继续进行推导和求解。\n\nBO MD 模拟的核心是 Born-Oppenheimer 近似，它利用了原子核和电子之间巨大的质量差异。这使得总系统波函数 $\\Psi(\\{\\mathbf{R}_I\\}, \\{\\mathbf{r}_i\\})$ 可以分离为一个原子核波函数 $\\Phi_N(\\{\\mathbf{R}_I\\})$ 和一个电子波函数 $\\Psi_e(\\{\\mathbf{r}_i\\}; \\{\\mathbf{R}_I\\})$ 的乘积，其中后者参数化地依赖于原子核坐标 $\\{\\mathbf{R}_I\\}$。这种分离导致了两个不同的问题：一个针对固定原子核的电子结构问题，以及一个核动力学问题。\n\n**1. 电子结构子问题与势能面**\n\n对于任何给定的原子核静态构型 $\\{\\mathbf{R}_I\\}$，电子的行为由不含时电子薛定谔方程决定：\n$$\nH_{\\mathrm{e}}(\\{\\mathbf{R}_I\\}) \\lvert \\Psi_{\\mathrm{e}} \\rangle = E_{\\mathrm{e}} \\lvert \\Psi_{\\mathrm{e}} \\rangle\n$$\n在这里，$H_{\\mathrm{e}}(\\{\\mathbf{R}_I\\})$ 是电子哈密顿量，它包括电子的动能、电子-电子相互作用势以及来自固定原子核的外部势。这是一个本征值方程，其解给出一组电子本征态 $\\lvert \\Psi_{\\mathrm{e},n} \\rangle$ 及其对应的能量 $E_{\\mathrm{e},n}(\\{\\mathbf{R}_I\\})$。\n\n在 BO MD 的背景下，通常假设原子核在由基态电子能量定义的势能面 (PES) 上进行经典演化。基态能量 $E_0(\\{\\mathbf{R}_I\\})$ 是给定原子核构型下的最低可能电子能量：\n$$\nE_0(\\{\\mathbf{R}_I\\}) = \\min_{n} E_{\\mathrm{e},n}(\\{\\mathbf{R}_I\\})\n$$\n这个函数 $E_0(\\{\\mathbf{R}_I\\})$ 就是势能面。在分子动力学模拟的每一步，原子核根据从此势能面导出的力 $\\mathbf{F}_I = -\\nabla_{\\mathbf{R}_I} E_0(\\{\\mathbf{R}_I\\})$ 运动。在每个新的原子核构型下计算 $E_0$ 及其梯度是 BO MD 模拟中计算量最大的部分。\n\n**2. 自洽场 (SCF) 迭代次数 $n_{\\mathrm{SCF}}$ 的推导**\n\n基态能量 $E_0$ 是通过自洽场 (SCF) 程序迭代求解的。问题提供了一个线性混合模型来描述残差量 $r$（例如，电子密度或势的误差）的收敛。第 $k+1$ 次迭代的残差，记为 $r_{k+1}$，与前一次的残差 $r_k$ 的关系为：\n$$\nr_{k+1} = (1 - \\alpha)\\, r_k\n$$\n其中 $\\alpha \\in (0,1)$ 是一个确保收敛的混合参数。从初始残差 $r_0$ 开始，$n$ 次迭代后的残差 $r_n$ 由以下几何级数给出：\n$$\nr_n = (1 - \\alpha)^n r_0\n$$\n当 $r_n$ 小于或等于阈值 $\\varepsilon$ 时，即 $r_n \\le \\varepsilon$，达到收敛。我们需要找到满足此条件的最小整数 $n$。对于 $r_0 > \\varepsilon$ 和 $\\alpha \\in (0,1)$：\n$$\n(1 - \\alpha)^n r_0 \\le \\varepsilon \\implies (1 - \\alpha)^n \\le \\frac{\\varepsilon}{r_0}\n$$\n我们对两边取自然对数。由于 $\\alpha \\in (0,1)$，所以 $1-\\alpha$ 也在 $(0,1)$ 内，其对数 $\\ln(1 - \\alpha)$ 是负数。\n$$\nn \\ln(1 - \\alpha) \\le \\ln\\left(\\frac{\\varepsilon}{r_0}\\right)\n$$\n除以负值 $\\ln(1 - \\alpha)$ 会反转不等号：\n$$\nn \\ge \\frac{\\ln(\\varepsilon / r_0)}{\\ln(1 - \\alpha)}\n$$\n由于 $n$ 必须是整数，所需的迭代次数（我们记为 $n_{\\mathrm{SCF}}$）是满足此条件的最小整数，通过对右侧表达式取上整得到。然后，这个计算出的值受最大允许迭代次数 $I_{\\max}$ 的限制。确定 $n_{\\mathrm{SCF}}$ 的完整逻辑是：\n$$\nn_{\\mathrm{SCF}} = \n\\begin{cases} \n0  &\\text{如果 } r_0 \\le \\varepsilon \\\\\nI_{\\max} &\\text{如果 } \\alpha \\notin (0,1) \\\\\n\\min\\left(I_{\\max}, \\left\\lceil \\frac{\\ln(\\varepsilon / r_0)}{\\ln(1 - \\alpha)} \\right\\rceil\\right) &\\text{如果 } r_0 > \\varepsilon \\text{ 且 } \\alpha \\in (0,1)\n\\end{cases}\n$$\n\n**3. 计算成本模型和标度关系论证**\n\n总计算成本是不同子任务成本的集合。所提供的模型基于标准电子结构算法的公认标度律。\n\n*   **每次 SCF 迭代的成本：**\n    *   $C_{\\mathrm{diag}} = K\\, c_{\\mathrm{d}}\\, M^3$：对一个 $M \\times M$ 矩阵进行对角化的计算复杂度为 $\\mathcal{O}(M^3)$。在固态计算中，问题通常针对倒易空间（$k$ 点）中的 $K$ 个特殊点独立求解，因此引入了因子 $K$。对于大系统，这一步是众所周知的瓶颈。\n    *   $C_{\\mathrm{ham}} = c_{\\mathrm{h}}\\, N\\, M$：构建哈密顿量的成本。所提供的 $\\mathcal{O}(NM)$ 标度关系是一个简化模型，可能出现在某些方法中，例如，对于 $N$ 个原子中的每一个，计算其对一个在大小为 $M$ 的网格或基组上表示的量的贡献。\n    *   $C_{\\mathrm{mix}} = c_{\\mathrm{m}}\\, M^2$：更新电子密度或势的成本。如果这些量由一个大小为 $M \\times M$ 的密度矩阵表示，简单的类向量操作的标度为 $\\mathcal{O}(M^2)$。\n\n*   **每个 MD 步骤的成本（SCF 之后）：**\n    *   $C_{\\mathrm{force}} = c_{\\mathrm{f}}\\, \\frac{N z}{2}$：力计算的成本。虽然 Hellmann-Feynman 力的计算可能很复杂，但此项模拟了来自成对相互作用的贡献。对于具有短程力的系统，通过使用邻居列表，将计算从 $\\mathcal{O}(N^2)$ 优化到接近 $\\mathcal{O}(N)$，其中 $N$ 个原子中的每一个仅与其 $z$ 个邻居相互作用。因此，总对数约为 $N z / 2$。\n    *   $C_{\\mathrm{therm}} = c_{\\mathrm{t}}\\, N$：应用恒温控制（例如，Langevin、Nosé-Hoover）和积分运动方程的成本。这些算法通常涉及更新所有 $N$ 个原子核的速度和位置，导致线性的 $\\mathcal{O}(N)$ 标度关系。\n\n**4. 总挂钟时间与瓶颈分析**\n\n总模拟时间 $C_{\\mathrm{total}}$ 是每个 MD 步骤的成本乘以总步数 $T$。每步的成本是 SCF 成本（每次迭代的成本乘以迭代次数）和 SCF 后成本的总和。\n$$\nC_{\\mathrm{total}} = T \\left( n_{\\mathrm{SCF}} \\left( C_{\\mathrm{diag}} + C_{\\mathrm{ham}} + C_{\\mathrm{mix}} \\right) + C_{\\mathrm{force}} + C_{\\mathrm{therm}} \\right)\n$$\n为了识别计算瓶颈，我们必须比较在整个模拟（$T$ 步）中花费在五个分量上的总时间：\n*   总对角化时间：$T_{\\mathrm{diag}} = T \\cdot n_{\\mathrm{SCF}} \\cdot C_{\\mathrm{diag}}$\n*   总哈密顿量构建时间：$T_{\\mathrm{ham}} = T \\cdot n_{\\mathrm{SCF}} \\cdot C_{\\mathrm{ham}}$\n*   总混合时间：$T_{\\mathrm{mix}} = T \\cdot n_{\\mathrm{SCF}} \\cdot C_{\\mathrm{mix}}$\n*   总力评估时间：$T_{\\mathrm{force}} = T \\cdot C_{\\mathrm{force}}$\n*   总恒温控制/积分时间：$T_{\\mathrm{therm}} = T \\cdot C_{\\mathrm{therm}}$\n\n瓶颈是对应于这五个值中最大值的那个分量，由整数代码标识：对角化 ($0$)、哈密顿量构建 ($1$)、混合 ($2$)、力评估 ($3$) 和恒温控制/积分 ($4$)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Derives and evaluates a computational cost model for a Born-Oppenheimer\n    Molecular Dynamics (BO MD) workflow.\n    \"\"\"\n\n    # Modeling coefficients from the problem statement.\n    c_d = 1e-9  # Diagonalization coefficient\n    c_h = 1e-10 # Hamiltonian/potential build coefficient\n    c_m = 5e-9  # Mixing/orthogonalization coefficient\n    c_f = 1e-6  # Force evaluation coefficient per pair\n    c_t = 1e-7  # Thermostat/integration coefficient per nucleus\n\n    # Test cases from the problem statement.\n    # Format: (N, M, K, alpha, r0, eps, Imax, z, T)\n    test_cases = [\n        # Case A: General high-entropy alloy simulation\n        (128, 1024, 4, 0.4, 1e-1, 1e-6, 100, 12, 50),\n        # Case B: Boundary, already converged\n        (64, 256, 1, 0.3, 1e-8, 1e-6, 50, 8, 10),\n        # Case C: Slow convergence due to small mixing\n        (200, 1500, 2, 0.05, 1e-1, 1e-8, 200, 10, 2),\n        # Case D: Extreme scale\n        (4096, 8192, 8, 0.5, 1e-1, 1e-6, 50, 12, 5),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N, M, K, alpha, r0, eps, Imax, z, T = case\n\n        # Step 1: Calculate the number of SCF iterations (n_scf)\n        n_scf = 0\n        if r0 = eps:\n            n_scf = 0\n        elif not (0  alpha  1):\n            n_scf = Imax\n        else:\n            # Derived formula: n_scf >= log(eps/r0) / log(1-alpha)\n            # We take the ceiling to get the smallest integer number of steps.\n            n_calc = math.ceil(math.log(eps / r0) / math.log(1 - alpha))\n            n_scf = min(Imax, int(n_calc))\n        \n        # Step 2: Calculate the cost for each component\n        \n        # Per-SCF-iteration costs\n        C_diag = K * c_d * (M**3)\n        C_ham = c_h * N * M\n        C_mix = c_m * (M**2)\n        \n        # Per-MD-step costs (outside SCF)\n        num_pairs = (N * z) / 2\n        C_force_per_step = c_f * num_pairs\n        C_therm_per_step = c_t * N\n\n        # Step 3: Calculate the total time spent on each component over the full simulation\n        T_diag = T * n_scf * C_diag\n        T_ham = T * n_scf * C_ham\n        T_mix = T * n_scf * C_mix\n        T_force = T * C_force_per_step\n        T_therm = T * C_therm_per_step\n        \n        # Step 4: Calculate the total wall-clock time\n        C_total = T_diag + T_ham + T_mix + T_force + T_therm\n\n        # Step 5: Identify the bottleneck\n        component_costs = [T_diag, T_ham, T_mix, T_force, T_therm]\n        bottleneck_code = int(np.argmax(component_costs))\n\n        # Append results for this case\n        results.append(round(C_total, 3))\n        results.append(bottleneck_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的实践将经典量子理论与现代机器学习联系起来。在这里，我们将探讨如何利用玻恩-奥本海默近似最不稳定的区域——其特征是高势能曲率和强非绝热耦合——来指导机器学习势函数的训练。这种主动学习方法展示了如何利用基本物理原理为复杂材料创建更准确、更高效的模型，代表了材料建模的前沿方向。",
            "id": "3760540",
            "problem": "考虑一个一维核坐标 $x$，它描述了一个典型高熵合金团簇中的局域畸变模式。假设电子由一个线性依赖于 $x$ 的两态非绝热哈密顿量描述，该哈密顿量由矩阵给出\n$$\n\\hat{H}(x)=\n\\begin{pmatrix}\n\\alpha x   \\Delta \\\\\n\\Delta  -\\alpha x\n\\end{pmatrix},\n$$\n其中 $\\alpha$ 和 $\\Delta$ 是正常实数参数。从不含时薛定谔方程和玻恩-奥本海默近似（该近似分离了快速的电子自由度和慢速的核自由度）出发，你必须求出绝热基态能量 $E_{-}(x)$、其一阶和二阶导数 $\\frac{d E_{-}}{dx}$ 和 $\\frac{d^2 E_{-}}{dx^2}$，以及基态和激发态之间的绝热导数耦合（作为 $x$ 的函数）。\n\n为主动学习定义一个敏感度引导的采集分数，该分数优先选择玻恩-奥本海默近似最敏感的核构型。令敏感度分数为\n$$\nS(x)=w_c\\, \\mathcal{N}\\!\\left(\\left|\\frac{d^2 E_{-}}{dx^2}\\right|\\right) + w_d\\, \\mathcal{N}\\!\\left(\\left|\\left\\langle \\psi_{-}(x)\\middle|\\frac{d}{dx}\\psi_{+}(x)\\right\\rangle\\right|\\right),\n$$\n其中 $w_c$ 和 $w_d$ 是满足 $w_c+w_d=1$ 的非负权重，$\\psi_{\\pm}(x)$ 是绝热电子本征态，$\\mathcal{N}(\\cdot)$ 表示在有限网格 $x\\in[-L,L]$ 上的最小-最大归一化：\n$$\n\\mathcal{N}(f(x))=\\frac{f(x)-\\min_{x\\in[-L,L]} f(x)}{\\max_{x\\in[-L,L]} f(x)-\\min_{x\\in[-L,L]} f(x)}.\n$$\n为机器学习势构建一个主动学习循环，该势能使用多项式回归在训练点集上对 $E_{-}(x)$ 进行建模。从一个初始训练集开始，该训练集包含在区间 $[-L,L]$ 上 $N_g$ 个网格点中均匀间隔选取的 $N_0$ 个点。通过最小二乘法对训练数据进行 $p$ 次多项式拟合，以近似 $E_{-}(x)$。将在网格点 $x$ 处的不确定性代理定义为该点到 $x$ 空间中最近训练点的距离，并将采集函数定义为\n$$\nA(x)=S(x)\\times U(x),\n$$\n其中 $U(x)$ 是不确定性代理。选择使 $A(x)$ 最大化的前 $M$ 个网格点（不包括已选择的训练点），扩充训练集，重新拟合多项式模型，并评估扩充前后在整个网格上的平均绝对误差。\n\n你的程序必须：\n- 使用对角化和源于玻恩-奥本海默近似的适当定义，从非绝热哈密顿量推导出 $E_{-}(x)$、其导数以及绝热导数耦合。\n- 实现敏感度分数 $S(x)$，其中 $w_c=w_d=\\frac{1}{2}$，并在网格上进行最小-最大归一化。\n- 使用采集函数 $A(x)$ 选择新的训练点并重新训练多项式模型。\n- 对每个测试用例，计算扩充前后在整个网格上的平均绝对误差 (MAE)。\n\n使用以下测试套件，其中指定了 $(\\alpha,\\Delta,L,N_0,N_g,M,p)$：\n- 测试用例 $1$：$(\\alpha,\\Delta,L,N_0,N_g,M,p)=(1.0,0.05,3.0,8,801,12,5)$。\n- 测试用例 $2$：$(\\alpha,\\Delta,L,N_0,N_g,M,p)=(1.0,1.0,3.0,8,801,12,5)$。\n- 测试用例 $3$：$(\\alpha,\\Delta,L,N_0,N_g,M,p)=(2.0,0.2,4.0,6,1001,20,5)$。\n\n不需要物理单位；将所有量视为无量纲。如果在内部引入角度，必须以弧度处理。对于每个测试用例，输出浮点数对 $[\\mathrm{MAE}_{\\text{before}},\\mathrm{MAE}_{\\text{after}}]$。\n\n最终输出格式：你的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，其中每个元素本身是代表一个测试用例的两个浮点数的列表，例如 $[[a,b],[c,d],[e,f]]$。",
            "solution": "该问题要求开发并实现一个主动学习程序，用于建模一维绝热势能面。该过程涉及几个相互关联的步骤：首先，从给定的两态非绝热哈密顿量解析推导基态性质；其次，构建一个基于物理的敏感度分数；第三，实现一个主动学习循环，利用该分数智能地扩充训练集并改进多项式机器学习模型。\n\n### 1. 绝热量的解析推导\n\n系统由一个线性依赖于核坐标 $x$ 的 $2 \\times 2$ 非绝热哈密顿矩阵描述：\n$$\n\\hat{H}(x) = \\begin{pmatrix} \\alpha x   \\Delta \\\\ \\Delta   -\\alpha x \\end{pmatrix}\n$$\n其中 $\\alpha$ 和 $\\Delta$ 是正常实数参数。绝热势能面 $E_{\\pm}(x)$ 是该矩阵的本征值。它们通过求解特征方程 $\\det(\\hat{H}(x) - E\\hat{I}) = 0$ 得到。\n$$\n(\\alpha x - E)(-\\alpha x - E) - \\Delta^2 = 0 \\\\\nE^2 - (\\alpha x)^2 - \\Delta^2 = 0 \\\\\nE^2 = (\\alpha x)^2 + \\Delta^2\n$$\n这给出了两个本征值，分别对应激发 $(+)$ 和基态 $(-)$ 绝热态：\n$$\nE_{\\pm}(x) = \\pm\\sqrt{(\\alpha x)^2 + \\Delta^2}\n$$\n问题集中于基态能量面：\n$$\nE_{-}(x) = -\\sqrt{(\\alpha x)^2 + \\Delta^2}\n$$\n敏感度分数需要 $E_{-}(x)$ 相对于核坐标 $x$ 的一阶和二阶导数。使用链式法则：\n$$\n\\frac{dE_{-}}{dx} = -\\frac{1}{2\\sqrt{(\\alpha x)^2 + \\Delta^2}} \\cdot (2\\alpha^2 x) = -\\frac{\\alpha^2 x}{\\sqrt{(\\alpha x)^2 + \\Delta^2}}\n$$\n使用商法则进行二次微分：\n$$\n\\frac{d^2E_{-}}{dx^2} = -\\alpha^2 \\frac{\\sqrt{(\\alpha x)^2 + \\Delta^2} - x \\left( \\frac{\\alpha^2 x}{\\sqrt{(\\alpha x)^2 + \\Delta^2}} \\right)}{(\\alpha x)^2 + \\Delta^2} \\\\\n= -\\alpha^2 \\frac{(\\alpha x)^2 + \\Delta^2 - \\alpha^2 x^2}{((\\alpha x)^2 + \\Delta^2)^{3/2}} \\\\\n= -\\frac{\\alpha^2 \\Delta^2}{((\\alpha x)^2 + \\Delta^2)^{3/2}}\n$$\n最后一个需要的量是绝热导数耦合 $d_{-,+}(x) = \\langle \\psi_{-}(x) | \\frac{d}{dx} \\psi_{+}(x) \\rangle$，其中 $\\psi_{\\pm}(x)$ 是相应的归一化本征矢量（绝热态）。该项量化了由核运动引起的绝热态之间的混合，是玻恩-奥本海默近似失效的关键指标。它可以使用非对角海尔曼-费曼定理计算：\n$$\nd_{-,+}(x) = \\frac{\\langle \\psi_{-}(x) | \\frac{d\\hat{H}}{dx} | \\psi_{+}(x) \\rangle}{E_{+}(x) - E_{-}(x)}\n$$\n首先，我们求哈密顿量的导数：\n$$\n\\frac{d\\hat{H}}{dx} = \\begin{pmatrix} \\alpha   0 \\\\ 0   -\\alpha \\end{pmatrix} = \\alpha\\sigma_z\n$$\n能量分母是 $E_{+} - E_{-} = 2\\sqrt{(\\alpha x)^2 + \\Delta^2}$。通过用混合角 $\\theta(x)$ (其中 $\\tan(2\\theta) = \\Delta/(\\alpha x)$) 表示本征矢量，可以最容易地找到分子中的矩阵元。本征矢量为 $\\psi_{+} = (\\cos\\theta, \\sin\\theta)^T$ 和 $\\psi_{-} = (-\\sin\\theta, \\cos\\theta)^T$。矩阵元变为：\n$$\n\\langle \\psi_{-}(x) | \\alpha\\sigma_z | \\psi_{+}(x) \\rangle = \\alpha \\begin{pmatrix} -\\sin\\theta   \\cos\\theta \\end{pmatrix} \\begin{pmatrix} 1   0 \\\\ 0   -1 \\end{pmatrix} \\begin{pmatrix} \\cos\\theta \\\\ \\sin\\theta \\end{pmatrix} = \\alpha(-\\sin\\theta\\cos\\theta - \\cos\\theta\\sin\\theta) = -\\alpha\\sin(2\\theta)\n$$\n由于 $\\tan(2\\theta) = \\Delta/(\\alpha x)$，我们有 $\\sin(2\\theta) = \\Delta / \\sqrt{(\\alpha x)^2 + \\Delta^2}$。因此，矩阵元为 $-\\alpha\\Delta / \\sqrt{(\\alpha x)^2 + \\Delta^2}$。\n代回到耦合的公式中：\n$$\nd_{-,+}(x) = \\frac{-\\alpha\\Delta / \\sqrt{(\\alpha x)^2 + \\Delta^2}}{2\\sqrt{(\\alpha x)^2 + \\Delta^2}} = -\\frac{\\alpha\\Delta}{2((\\alpha x)^2 + \\Delta^2)}\n$$\n\n### 2. 主动学习框架\n\n主动学习循环的目标是通过有针对性地添加训练点，高效地为 $E_{-}(x)$ 构建一个准确的多项式模型。采集函数 $A(x) = S(x) \\times U(x)$ 指导这一选择过程。\n\n**敏感度分数 $S(x)$**：此分数识别出物理上最难建模的区域。它是两个归一化项的加权和：\n$$\nS(x) = w_c\\, \\mathcal{N}\\!\\left(\\left|\\frac{d^2 E_{-}}{dx^2}\\right|\\right) + w_d\\, \\mathcal{N}\\!\\left(\\left|d_{-,+}(x)\\right|\\right)\n$$\n当 $w_c = w_d = 0.5$ 时，这变为：\n$$\nS(x) = \\frac{1}{2} \\mathcal{N}\\left(\\frac{\\alpha^2 \\Delta^2}{((\\alpha x)^2 + \\Delta^2)^{3/2}}\\right) + \\frac{1}{2} \\mathcal{N}\\left(\\frac{\\alpha\\Delta}{2((\\alpha x)^2 + \\Delta^2)}\\right)\n$$\n两项都在 $x=0$ 附近最大，在该处能隙 $E_{+} - E_{-}$ 最小（一个避免交叉），表明此处曲率高且非绝热效应强。归一化 $\\mathcal{N}(\\cdot)$ 将每个分量在网格 $[-L,L]$ 上的值缩放到 $[0, 1]$ 范围内，确保它们对分数的贡献相等。\n\n**不确定性代理 $U(x)$**：该项促进探索。它被定义为从一个网格点 $x$ 到当前训练集中最近点的距离。一个大的 $U(x)$ 表示构型空间中一个未被当前数据充分代表的区域，在该区域模型误差可能很高。\n\n**采集函数 $A(x)$**：通过将敏感度和不确定性相乘，$A(x)$ 偏好那些既具有物理重要性（高 $S(x)$）又采样不足（高 $U(x)$）的点。这种混合策略比随机采样或仅基于不确定性的采样更有效。\n\n### 3. 计算流程\n\n对于每个测试用例，算法按以下步骤进行：\n1.  **初始化**：在区间 $[-L, L]$ 中创建一个包含 $N_g$ 个点的均匀网格。通过以均匀间距选择其中的 $N_0$ 个点来形成初始训练集。\n2.  **基准真相 (Ground Truth)**：对网格上的所有点，计算 $E_{-}(x)$ 的精确解析表达式以及 $S(x)$ 的分量。\n3.  **初始模型评估**：使用最小二乘法将一个 $p$ 次多项式拟合到初始训练数据 $(x_i, E_{-}(x_i))$。在整个网格上计算该模型的平均绝对误差 (MAE)，即 $\\mathrm{MAE}_{\\text{before}}$。\n4.  **采集**：为所有网格点计算敏感度分数 $S(x)$ 和不确定性代理 $U(x)$。形成采集函数 $A(x)$。\n5.  **扩充**：识别出不在训练集中且具有最高采集分数的 $M$ 个网格点。将这些点添加到训练集中。\n6.  **重训练模型评估**：将一个新的 $p$ 次多项式拟合到扩充后的训练集。在整个网格上计算这个新模型的 MAE，即 $\\mathrm{MAE}_{\\text{after}}$。\n7.  **输出**：记录数据对 $[\\mathrm{MAE}_{\\text{before}}, \\mathrm{MAE}_{\\text{after}}]$。此过程展示了通过单步有针对性的数据采集所带来的模型准确性的提升。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the active learning problem for a series of test cases.\n\n    This function iterates through predefined test cases, each specifying parameters\n    for a 2-level quantum system and an active learning loop. For each case, it:\n    1.  Calculates the ground truth energy surface and sensitivity metrics.\n    2.  Builds an initial polynomial model on a sparse grid and calculates its error (MAE_before).\n    3.  Uses a physics-informed acquisition function to select new training points.\n    4.  Retrains the model with the augmented data and calculates the new error (MAE_after).\n    5.  Collects and prints the results in the specified format.\n    \"\"\"\n    # Test cases: (alpha, Delta, L, N_0, N_g, M, p)\n    test_cases = [\n        (1.0, 0.05, 3.0, 8, 801, 12, 5),\n        (1.0, 1.0, 3.0, 8, 801, 12, 5),\n        (2.0, 0.2, 4.0, 6, 1001, 20, 5),\n    ]\n\n    results = []\n\n    def min_max_normalize(arr: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Performs min-max normalization on a numpy array.\n        Scales the array values to the range [0, 1].\n        If all values are the same, returns an array of zeros.\n        \"\"\"\n        min_val = np.min(arr)\n        max_val = np.max(arr)\n        if max_val == min_val:\n            return np.zeros_like(arr)\n        return (arr - min_val) / (max_val - min_val)\n\n    for case in test_cases:\n        alpha, Delta, L, N_0, N_g, M, p = case\n\n        # 1. Grid and Ground Truth Calculation\n        x_grid = np.linspace(-L, L, N_g)\n        \n        # Ground state energy E_-(x)\n        common_term = (alpha * x_grid)**2 + Delta**2\n        E_true = -np.sqrt(common_term)\n\n        # 2. Sensitivity Score S(x)\n        # Component from |d^2E/dx^2|\n        f_c = (alpha**2 * Delta**2) / (common_term**1.5)\n        # Component from |derivative coupling|\n        f_d = (alpha * Delta) / (2 * common_term)\n        \n        # Normalize and combine with weights w_c = w_d = 0.5\n        S = 0.5 * min_max_normalize(f_c) + 0.5 * min_max_normalize(f_d)\n\n        # 3. Initial Training\n        initial_indices = np.round(np.linspace(0, N_g - 1, N_0)).astype(int)\n        train_indices = list(initial_indices)\n        \n        x_train = x_grid[train_indices]\n        y_train = E_true[train_indices]\n\n        # Fit initial model and calculate MAE_before\n        coeffs_before = np.polyfit(x_train, y_train, p)\n        model_before = np.poly1d(coeffs_before)\n        mae_before = np.mean(np.abs(model_before(x_grid) - E_true))\n        \n        # 4. Active Learning Acquisition\n        # Uncertainty proxy U(x): distance to nearest training point\n        grid_points_reshaped = x_grid.reshape(-1, 1)\n        train_points_reshaped = x_grid[train_indices].reshape(1, -1)\n        distances = np.abs(grid_points_reshaped - train_points_reshaped)\n        U = np.min(distances, axis=1)\n\n        # Acquisition function A(x) = S(x) * U(x)\n        A = S * U\n        \n        # Mask already trained points\n        A[train_indices] = -1.0 \n\n        # 5. Augment training set\n        new_indices = np.argsort(A)[-M:]\n        train_indices.extend(new_indices)\n        \n        x_train_after = x_grid[train_indices]\n        y_train_after = E_true[train_indices]\n\n        # 6. Retrain and calculate MAE_after\n        coeffs_after = np.polyfit(x_train_after, y_train_after, p)\n        model_after = np.poly1d(coeffs_after)\n        mae_after = np.mean(np.abs(model_after(x_grid) - E_true))\n\n        # 7. Store results\n        results.append([mae_before, mae_after])\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n```"
        }
    ]
}