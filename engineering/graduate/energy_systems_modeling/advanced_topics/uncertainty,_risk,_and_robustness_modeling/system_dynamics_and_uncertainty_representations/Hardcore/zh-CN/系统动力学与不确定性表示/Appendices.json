{
    "hands_on_practices": [
        {
            "introduction": "在实际的能量系统中，精确追踪如电池荷电状态（State of Charge, SOC）等关键变量至关重要，但系统模型往往存在非线性和过程噪声，使得状态的演化充满不确定性。本练习旨在解决非线性动态模型中的不确定性传播问题，引导您动手实践并对比两种核心方法：作为“黄金标准”的蒙特卡洛（Monte Carlo）模拟与计算效率更高的无迹变换（Unscented Transform, UT）。通过完成这项练习，您将掌握在非线性系统中进行状态估计的关键技能，这对于设计无迹卡尔曼滤波器（Unscented Kalman Filter）等高级估计算法具有直接的实践意义。",
            "id": "4128494",
            "problem": "考虑一个带有附加过程噪声的电池荷电状态 (SOC) 的单状态离散时间模型。设在步骤 $k$ 的 SOC 为 $x_k \\in \\mathbb{R}$，表示一个在 $[0,1]$ 范围内的无量纲分数（无单位）。在持续时间为 $\\Delta t$ 小时的单个时间步长内，施加恒定电流 $I$（放电为正，充电为负）时，从 $x_k$ 到 $x_{k+1}$ 的离散时间更新定义为\n$$\nx_{k+1} \\triangleq f(x_k; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) + w_k,\n$$\n其中\n$$\nf(x; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) = x - \\frac{\\Delta t}{C_{\\mathrm{eff}}} \\, I \\left( 1 + \\gamma \\left(1 - 2x\\right)^3 \\right),\n$$\n$C_{\\mathrm{eff}}$ 是有效容量，单位为安培小时 (Ah)，$w_k$ 是过程噪声，被建模为零均值高斯随机变量 $w_k \\sim \\mathcal{N}(0, q)$，其方差为 $q$。非线性水平由无量纲参数 $\\gamma \\ge 0$ 控制。初始 SOC $x_k$ 是不确定的，并被建模为高斯随机变量 $x_k \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$。\n\n您的任务是实现无迹变换 (UT)，以便在给定 $x_k$ 的高斯先验和非线性函数 $f(\\cdot)$ 的情况下，近似 $x_{k+1}$ 的均值和协方差，并将基于 UT 的估计值与通过对 $x_k$ 和 $w_k$ 采样并经过非线性更新传播而获得的经验蒙特卡洛估计值进行比较。使用无迹变换的缩放参数 $\\alpha_{\\mathrm{UT}}$、$\\beta_{\\mathrm{UT}}$ 和 $\\kappa_{\\mathrm{UT}}$，其指定值为：$\\alpha_{\\mathrm{UT}} = 0.5$，$\\beta_{\\mathrm{UT}} = 2$，$\\kappa_{\\mathrm{UT}} = 0$。\n\n您必须使用的基本假设：\n- 电荷守恒意味着在恒定电流下，$\\Delta t$ 时间内的确定性 SOC 变化与 $\\Delta t/C_{\\mathrm{eff}}$ 成正比，符号由电流方向决定。\n- 随机变量通过非线性函数的变换需要对输入分布进行积分；无迹变换提供了一种确定性采样方案，用于近似这些针对高斯先验的积分。\n- 方差为 $q$ 的附加高斯噪声会使输出协方差增加 $q$。\n\n实现一个程序，对于每个测试用例，返回两个标量结果：\n- UT 均值估计 $\\mu_{\\mathrm{UT}}$ 与蒙特卡洛均值 $\\mu_{\\mathrm{MC}}$ 之间的绝对差，以小数形式表示（无量纲）。\n- UT 方差估计 $\\sigma^2_{\\mathrm{UT}}$ 与蒙特卡洛方差 $\\sigma^2_{\\mathrm{MC}}$ 之间的绝对差，以小数形式表示（无量纲）。\n\n您必须将 SOC 视为无量纲分数。任何地方都不要使用百分号；始终将与 SOC 相关的量表示为小数。角度单位不适用于此问题。\n\n使用以下参数值测试套件，该套件涵盖了典型的操作条件、SOC 极端值附近的边界条件以及不同的非线性水平。每个测试用例以元组 $(\\mu_0, \\sigma_0, I, \\gamma, \\sigma_w, \\Delta t, C_{\\mathrm{eff}}, N_{\\mathrm{MC}})$ 的形式提供，其中 $q = \\sigma_w^2$：\n- 测试用例 1 (基线线性区域): $(0.5, 0.01, 5.0, 0.0, 0.001, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 2 (中等非线性，较大的先验不确定性): $(0.5, 0.05, 5.0, 2.0, 0.0015, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 3 (靠近上边界的高 SOC，强非线性，较高电流放电): $(0.95, 0.02, 10.0, 5.0, 0.002, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 4 (靠近下边界的低 SOC，中等非线性，充电电流): $(0.05, 0.02, -3.0, 3.0, 0.001, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 5 (极端非线性但先验方差非常小): $(0.5, 0.001, 5.0, 10.0, 0.001, \\frac{1}{60}, 5.0, 50000)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序连接每个测试用例的绝对误差对，即，其形式应为\n$$\n[\\varepsilon^{(1)}_{\\mu}, \\varepsilon^{(1)}_{\\sigma^2}, \\varepsilon^{(2)}_{\\mu}, \\varepsilon^{(2)}_{\\sigma^2}, \\ldots, \\varepsilon^{(5)}_{\\mu}, \\varepsilon^{(5)}_{\\sigma^2}],\n$$\n其中 $\\varepsilon^{(i)}_{\\mu} = \\left| \\mu_{\\mathrm{UT}}^{(i)} - \\mu_{\\mathrm{MC}}^{(i)} \\right|$ 和 $\\varepsilon^{(i)}_{\\sigma^2} = \\left| \\sigma_{\\mathrm{UT}}^{2\\,(i)} - \\sigma_{\\mathrm{MC}}^{2\\,(i)} \\right|$ 是小数。\n\n程序必须是完整的，并且无需任何用户输入即可运行。它必须根据上述规范实现一维情况下的无迹变换和蒙特卡洛估计，并且必须完全按照给定的方式使用提供的测试用例。最后一行必须完全按照所述格式打印。",
            "solution": "该问题要求实现并比较两种方法，用于在电池荷电状态 (SOC) 的非线性后验状态空间模型中传播不确定性。在离散时间步长 $k$ 上的状态为 $x_k \\in \\mathbb{R}$，它是不确定的，并被建模为高斯分布 $x_k \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$。状态根据以下方程演化：\n$$\nx_{k+1} = f(x_k; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) + w_k\n$$\n其中 $f(\\cdot)$ 是一个非线性函数，$w_k \\sim \\mathcal{N}(0, q)$ 是方差为 $q = \\sigma_w^2$ 的附加零均值高斯过程噪声。目标是估计后续状态 $x_{k+1}$ 的均值 $\\mu_{k+1}$ 和方差 $\\sigma_{k+1}^2$。我们将把无迹变换 (UT) 的估计值与作为高保真基准的蒙特卡洛 (MC) 模拟的估计值进行比较。\n\n非线性状态转移函数由下式给出：\n$$\nf(x; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) = x - \\frac{\\Delta t}{C_{\\mathrm{eff}}} \\, I \\left( 1 + \\gamma \\left(1 - 2x\\right)^3 \\right)\n$$\n其中 $I$ 是电流，$C_{\\mathrm{eff}}$ 是有效容量，$\\Delta t$ 是时间步长，$\\gamma$ 是一个控制非线性程度的参数。\n\n**蒙特卡洛 (MC) 模拟**\n\n蒙特卡洛方法为 $x_{k+1}$ 的真实后验分布提供了一个数值近似。根据大数定律，当样本数量趋于无穷大时，样本统计量会收敛到变换后分布的真实统计量。过程如下：\n1.  从初始高斯分布 $x_k \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$ 生成大量的随机样本 $\\{x_k^{(j)}\\}_{j=1}^{N_{\\mathrm{MC}}}$（数量为 $N_{\\mathrm{MC}}$）。\n2.  从过程噪声分布 $w_k \\sim \\mathcal{N}(0, q)$ 生成 $N_{\\mathrm{MC}}$ 个样本 $\\{w_k^{(j)}\\}_{j=1}^{N_{\\mathrm{MC}}}$。\n3.  对于每个样本 $j$，通过完整的状态更新方程进行传播，以获得下一个状态的样本：\n    $$\n    x_{k+1}^{(j)} = f(x_k^{(j)}; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) + w_k^{(j)}\n    $$\n4.  然后根据得到的样本集 $\\{x_{k+1}^{(j)}\\}$ 计算经验均值 $\\mu_{\\mathrm{MC}}$ 和方差 $\\sigma_{\\mathrm{MC}}^2$：\n    $$\n    \\mu_{\\mathrm{MC}} = \\frac{1}{N_{\\mathrm{MC}}} \\sum_{j=1}^{N_{\\mathrm{MC}}} x_{k+1}^{(j)}\n    $$\n    $$\n    \\sigma_{\\mathrm{MC}}^2 = \\frac{1}{N_{\\mathrm{MC}}-1} \\sum_{j=1}^{N_{\\mathrm{MC}}} (x_{k+1}^{(j)} - \\mu_{\\mathrm{MC}})^2\n    $$\n    此处使用无偏样本方差（分母为 $N_{\\mathrm{MC}}-1$）。\n\n**无迹变换 (UT)**\n\n无迹变换是一种确定性采样技术，它提供了一种更有效的方法来近似经过非线性变换的随机变量的统计特性。它使用一组最少的、确定性选择的采样点，称为 sigma 点，这些点能够捕捉先验高斯分布的前两个矩（均值和协方差）。\n\n对于一维状态 $x_k$，其过程如下：\n\n1.  **定义参数**：状态维度为 $n=1$。给定的 UT 缩放参数为 $\\alpha_{\\mathrm{UT}} = 0.5$，$\\beta_{\\mathrm{UT}} = 2$ 和 $\\kappa_{\\mathrm{UT}} = 0$。\n\n2.  **计算 Sigma 点和权重**：\n    - 计算一个复合缩放参数 $\\lambda$：\n      $$\n      \\lambda = \\alpha_{\\mathrm{UT}}^2(n + \\kappa_{\\mathrm{UT}}) - n = (0.5)^2(1+0) - 1 = 0.25 - 1 = -0.75\n      $$\n    - 从先验均值 $\\mu_0$ 和方差 $\\sigma_0^2$ 生成一组 $2n+1=3$ 个 sigma 点 $\\mathcal{X}_i$：\n      $$\n      \\begin{align*}\n      \\mathcal{X}_0 = \\mu_0 \\\\\n      \\mathcal{X}_1 = \\mu_0 + \\sqrt{(n+\\lambda)\\sigma_0^2} = \\mu_0 + \\sqrt{(1-0.75)}\\sigma_0 = \\mu_0 + 0.5\\sigma_0 \\\\\n      \\mathcal{X}_2 = \\mu_0 - \\sqrt{(n+\\lambda)\\sigma_0^2} = \\mu_0 - 0.5\\sigma_0\n      \\end{align*}\n      $$\n    - 计算均值（$W_i^{(m)}$）和协方差（$W_i^{(c)}$）的相应权重：\n      $$\n      \\begin{align*}\n      W_0^{(m)} = \\frac{\\lambda}{n+\\lambda} = \\frac{-0.75}{1-0.75} = -3 \\\\\n      W_1^{(m)} = W_2^{(m)} = \\frac{1}{2(n+\\lambda)} = \\frac{1}{2(1-0.75)} = 2 \\\\\n      W_0^{(c)} = \\frac{\\lambda}{n+\\lambda} + (1 - \\alpha_{\\mathrm{UT}}^2 + \\beta_{\\mathrm{UT}}) = -3 + (1 - (0.5)^2 + 2) = -0.25 \\\\\n      W_1^{(c)} = W_2^{(c)} = \\frac{1}{2(n+\\lambda)} = 2\n      \\end{align*}\n      $$\n\n3.  **传播 Sigma 点**：每个 sigma 点 $\\mathcal{X}_i$ 都通过非线性函数 $f(\\cdot)$ 进行变换，得到一组变换后的点 $\\mathcal{Y}_i$：\n    $$\n    \\mathcal{Y}_i = f(\\mathcal{X}_i; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) \\quad \\text{for } i \\in \\{0, 1, 2\\}\n    $$\n\n4.  **计算传播后的均值和协方差**：通过对传播后的点进行加权求和，计算变换后变量的预测均值 $\\mu_{\\mathrm{UT}}$ 和协方差 $P_y$（在添加过程噪声之前）：\n    $$\n    \\mu_{\\mathrm{UT}} = \\sum_{i=0}^{2} W_i^{(m)} \\mathcal{Y}_i\n    $$\n    $$\n    P_y = \\sum_{i=0}^{2} W_i^{(c)} (\\mathcal{Y}_i - \\mu_{\\mathrm{UT}})^2\n    $$\n\n5.  **融入过程噪声**：通过将过程噪声方差 $q$ 添加到传播后的协方差 $P_y$ 中，可以得到方差的最终估计值 $\\sigma_{\\mathrm{UT}}^2$。由于过程噪声的均值为零，因此均值不受影响。\n    $$\n    \\sigma_{\\mathrm{UT}}^2 = P_y + q\n    $$\n\n**实现与比较**\n\n程序将实现 UT 和 MC 两种方法。对于提供的五个测试用例中的每一个，它将计算 $(\\mu_{\\mathrm{UT}}, \\sigma_{\\mathrm{UT}}^2)$ 和 $(\\mu_{\\mathrm{MC}}, \\sigma_{\\mathrm{MC}}^2)$。每个测试用例的最终输出包括两个值：均值的绝对差 $\\varepsilon_{\\mu} = |\\mu_{\\mathrm{UT}} - \\mu_{\\mathrm{MC}}|$，以及方差的绝对差 $\\varepsilon_{\\sigma^2} = |\\sigma_{\\mathrm{UT}}^2 - \\sigma_{\\mathrm{MC}}^2|$。这些值量化了无迹变换近似相对于计算更为密集的蒙特卡洛模拟的准确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the battery SOC estimation problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # (mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_MC)\n        (0.5, 0.01, 5.0, 0.0, 0.001, 1.0/60.0, 5.0, 50000),\n        (0.5, 0.05, 5.0, 2.0, 0.0015, 1.0/60.0, 5.0, 50000),\n        (0.95, 0.02, 10.0, 5.0, 0.002, 1.0/60.0, 5.0, 50000),\n        (0.05, 0.02, -3.0, 3.0, 0.001, 1.0/60.0, 5.0, 50000),\n        (0.5, 0.001, 5.0, 10.0, 0.001, 1.0/60.0, 5.0, 50000),\n    ]\n\n    results = []\n    \n    # Use a fixed seed for reproducibility of Monte Carlo simulations\n    rng = np.random.default_rng(seed=42)\n\n    for case in test_cases:\n        mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_mc = case\n        \n        # Run Monte Carlo simulation\n        mu_mc, var_mc = monte_carlo(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_mc, rng)\n        \n        # Run Unscented Transform\n        mu_ut, var_ut = unscented_transform(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff)\n        \n        # Calculate absolute differences\n        err_mu = abs(mu_ut - mu_mc)\n        err_var = abs(var_ut - var_mc)\n        \n        results.extend([err_mu, err_var])\n\n    # Format the output as a comma-separated string in brackets\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\ndef state_transition_func(x, I, delta_t, C_eff, gamma):\n    \"\"\"\n    The nonlinear state transition function f(x).\n    \"\"\"\n    term_I = (delta_t / C_eff) * I\n    non_linearity = 1.0 + gamma * (1.0 - 2.0 * x)**3\n    return x - term_I * non_linearity\n\ndef unscented_transform(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff):\n    \"\"\"\n    Approximates the mean and variance of the next state using the Unscented Transform.\n    \"\"\"\n    # State dimension\n    n = 1\n    \n    # UT scaling parameters\n    alpha_ut = 0.5\n    beta_ut = 2.0\n    kappa_ut = 0.0\n    \n    # Composite scaling parameter\n    lambda_ = alpha_ut**2 * (n + kappa_ut) - n\n    \n    # --- Step 1: Generate Sigma Points ---\n    var_0 = sigma_0**2\n    sigma_points = np.zeros(2 * n + 1)\n    sigma_points[0] = mu_0\n    \n    sqrt_term = np.sqrt((n + lambda_) * var_0)\n    sigma_points[1] = mu_0 + sqrt_term\n    sigma_points[2] = mu_0 - sqrt_term\n    \n    # --- Step 2: Calculate Weights ---\n    weights_m = np.zeros(2 * n + 1)\n    weights_c = np.zeros(2 * n + 1)\n    \n    weights_m[0] = lambda_ / (n + lambda_)\n    weights_c[0] = lambda_ / (n + lambda_) + (1 - alpha_ut**2 + beta_ut)\n    \n    for i in range(1, 2 * n + 1):\n        weights_m[i] = 1.0 / (2.0 * (n + lambda_))\n        weights_c[i] = 1.0 / (2.0 * (n + lambda_))\n        \n    # --- Step 3: Propagate Sigma Points ---\n    propagated_points = state_transition_func(sigma_points, I, delta_t, C_eff, gamma)\n    \n    # --- Step 4: Calculate Propagated Mean and Covariance ---\n    mu_ut = np.sum(weights_m * propagated_points)\n    \n    # Covariance before adding process noise\n    var_y = np.sum(weights_c * (propagated_points - mu_ut)**2)\n    \n    # --- Step 5: Add Process Noise ---\n    q = sigma_w**2\n    var_ut = var_y + q\n    \n    return mu_ut, var_ut\n\ndef monte_carlo(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_mc, rng):\n    \"\"\"\n    Estimates the mean and variance of the next state using Monte Carlo simulation.\n    \"\"\"\n    # Generate initial state samples\n    x_k_samples = rng.normal(loc=mu_0, scale=sigma_0, size=N_mc)\n    \n    # Generate process noise samples\n    q = sigma_w**2\n    w_k_samples = rng.normal(loc=0.0, scale=np.sqrt(q), size=N_mc)\n    \n    # Propagate samples through the full state equation\n    x_k_plus_1_samples = state_transition_func(x_k_samples, I, delta_t, C_eff, gamma) + w_k_samples\n    \n    # Calculate empirical mean and variance\n    mu_mc = np.mean(x_k_plus_1_samples)\n    # Use ddof=1 for unbiased sample variance\n    var_mc = np.var(x_k_plus_1_samples, ddof=1)\n    \n    return mu_mc, var_mc\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "能源系统调度决策通常需要在面对未来需求不确定性的情况下做出。如何在模型中表达和应对这种不确定性，是决定系统经济性和可靠性的核心问题。本练习将带您深入探索两种主流决策范式——鲁棒优化与随机优化——之间的根本权衡。您将为一个简化的多周期能源系统，分别基于这两种方法制定发电机调度计划，并通过样本外测试（out-of-sample testing）来评估其真实性能。",
            "id": "4128563",
            "problem": "考虑一个小型多周期能源系统，该系统包含一个可控发电机和一个外部采购选项。时间被划分为 $T$ 个离散周期，索引为 $t \\in \\{1,2,3\\}$。周期 $t$ 的发电机调度 $g_t \\in \\{0,1,2\\}$ 以能量单位计量，受初始条件 $g_0 = 0$ 和爬坡约束 $|g_t - g_{t-1}| \\le R$（其中 $R=1$）的限制。假设每个周期的容量为 $2$ 个能量单位。在每个周期，随机需求为 $D_t \\ge 0$，已实现的需求向量为 $\\mathbf{D} = (D_1, D_2, D_3)$。需求实现后，运营商可以以单位成本从外部来源采购 $s_t \\ge 0$。周期能量平衡为 $g_t + s_t \\ge D_t$，而过量生产（$g_t > D_t$）将被无惩罚弃用。每个周期的发电成本为 $c \\cdot g_t$，单位外部采购成本为 $p$。对于一个调度 $\\mathbf{g} = (g_1,g_2,g_3)$ 和一个已实现的需求 $\\mathbf{D}$，总成本为\n$$\nC(\\mathbf{g}, \\mathbf{D}) = \\sum_{t=1}^{3} \\left( c \\cdot g_t + p \\cdot s_t \\right),\n$$\n其中 $s_t$ 的选择是为了以最低成本满足能量平衡，即\n$$\ns_t = \\max\\{0, D_t - g_t\\},\n$$\n因此\n$$\nC(\\mathbf{g}, \\mathbf{D}) = \\sum_{t=1}^{3} \\left( c \\cdot g_t + p \\cdot \\max\\{0, D_t - g_t\\} \\right).\n$$\n定义可行调度集\n$$\n\\mathcal{G} = \\left\\{ \\mathbf{g} \\in \\{0,1,2\\}^3 \\,:\\, |g_t - g_{t-1}| \\le 1 \\text{ for } t=1,2,3 \\text{ and } g_0 = 0 \\right\\}.\n$$\n训练阶段考虑两种不确定性表示：一个不确定性集 $\\mathcal{U}_0$ 和一个概率分布 $P_0$。鲁棒训练问题为\n$$\n\\min_{\\mathbf{g} \\in \\mathcal{G}} \\; \\max_{\\mathbf{D} \\in \\mathcal{U}_0} \\; C(\\mathbf{g}, \\mathbf{D}),\n$$\n而随机训练问题为\n$$\n\\min_{\\mathbf{g} \\in \\mathcal{G}} \\; \\mathbb{E}_{P_0}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right].\n$$\n对于评估，真实分布为 $P^*$，它可能与 $P_0$ 不同。令 $\\mathbf{g}_R$ 和 $\\mathbf{g}_S$ 分别表示从鲁棒训练和随机训练中获得的最优调度。鲁棒性代价 (Price of Robustness, PoR) 定义为\n$$\n\\text{PoR} = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_R, \\mathbf{D}) \\right] - \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_S, \\mathbf{D}) \\right].\n$$\n对于一个调度 $\\mathbf{g}$，在错误设定下的样本外遗憾定义为\n$$\n\\text{Reg}(\\mathbf{g}) = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right] - \\min_{\\mathbf{h} \\in \\mathcal{G}} \\mathbb{E}_{P^*}\\left[ C(\\mathbf{h}, \\mathbf{D}) \\right].\n$$\n您必须为下面的每个测试用例计算 $\\text{PoR}$、$\\text{Reg}(\\mathbf{g}_R)$ 和 $\\text{Reg}(\\mathbf{g}_S)$。所有成本必须以货币单位 (MU) 表示。\n\n假设 $\\mathcal{U}_0$ 是一个分量式箱体，其下界为 $\\mathbf{d}_{\\min} = (0,0,0)$，上界 $\\mathbf{d}_{\\max}$ 根据每个测试用例提供。因为对于固定的 $\\mathbf{g}$，$C(\\mathbf{g}, \\mathbf{D})$ 在每个 $D_t$ 上都是非递减的，所以鲁棒问题的内部最大化在其最大值 $\\mathbf{D} = \\mathbf{d}_{\\max}$ 处达到。\n\n测试套件（每个用例指定 $c$、$p$、$\\mathbf{d}_{\\max}$、$P_0$ 和 $P^*$）：\n- 用例 1：\n  - $c = 20$, $p = 100$, $\\mathbf{d}_{\\max} = (1,2,2)$。\n  - $P_0$：场景 $\\mathbf{D}^{(1)} = (0,1,1)$ 的概率为 $0.5$，场景 $\\mathbf{D}^{(2)} = (1,2,1)$ 的概率为 $0.3$，场景 $\\mathbf{D}^{(3)} = (0,0,2)$ 的概率为 $0.2$。\n  - $P^*$：场景 $\\mathbf{D}^{A} = (1,2,2)$ 的概率为 $0.4$，场景 $\\mathbf{D}^{B} = (0,1,2)$ 的概率为 $0.4$，场景 $\\mathbf{D}^{C} = (2,2,2)$ 的概率为 $0.2$。\n- 用例 2：\n  - $c = 40$, $p = 60$, $\\mathbf{d}_{\\max} = (1,1,1)$。\n  - $P_0$：场景 $\\mathbf{D}^{(1)} = (0,1,0)$ 的概率为 $0.6$，场景 $\\mathbf{D}^{(2)} = (1,1,1)$ 的概率为 $0.4$。\n  - $P^*$：场景 $\\mathbf{D}^{A} = (1,2,1)$ 的概率为 $0.5$，场景 $\\mathbf{D}^{B} = (0,0,1)$ 的概率为 $0.5$。\n- 用例 3：\n  - $c = 20$, $p = 100$, $\\mathbf{d}_{\\max} = (0,0,0)$。\n  - $P_0$：场景 $\\mathbf{D} = (0,0,0)$ 的概率为 $1.0$。\n  - $P^*$：场景 $\\mathbf{D} = (2,2,2)$ 的概率为 $1.0$。\n\n您的程序必须：\n- 枚举 $\\mathcal{G}$，遵循 $g_0 = 0$、$g_t \\in \\{0,1,2\\}$ 和 $|g_t - g_{t-1}| \\le 1$。\n- 求解鲁棒和随机训练问题以获得 $\\mathbf{g}_R$ 和 $\\mathbf{g}_S$。\n- 在 $P^*$ 下计算 $\\text{PoR}$、$\\text{Reg}(\\mathbf{g}_R)$ 和 $\\text{Reg}(\\mathbf{g}_S)$。\n- 生成单行输出，包含以逗号分隔的每个测试用例的三元组列表，每个三元组为 $[\\text{PoR}, \\text{Reg}_R, \\text{Reg}_S]$，四舍五入到两位小数，全部以货币单位 (MU) 表示，并用方括号括起来；即，\n$$\n\\left[ [\\text{PoR}_1,\\text{Reg}_R^{(1)},\\text{Reg}_S^{(1)}], [\\text{PoR}_2,\\text{Reg}_R^{(2)},\\text{Reg}_S^{(2)}], [\\text{PoR}_3,\\text{Reg}_R^{(3)},\\text{Reg}_S^{(3)}] \\right].\n$$\n角度单位不适用。不使用百分比。所有输出必须是货币单位 (MU) 的数值浮点数。",
            "solution": "用户提供了一个在能源系统建模领域内定义明确的优化问题，重点是比较鲁棒优化和随机优化技术在模型错误设定下的表现。该问题具有科学依据，数学上一致，并提供了所有必要的数据。由于决策空间的离散和小规模特性，计算求解是可行的。\n\n问题的核心是找到最优的发电机调度方案 $\\mathbf{g} = (g_1, g_2, g_3)$ 并评估其性能。解决方案按以下方法进行：\n\n首先，我们必须明确定义所有可行调度方案的集合 $\\mathcal{G}$。一个调度方案 $\\mathbf{g} = (g_1, g_2, g_3)$ 是可行的，如果它遵守给定的约束条件：\n1.  每个周期的发电量 $g_t$ 必须是来自 $\\{0, 1, 2\\}$ 的整数。\n2.  初始状态固定为 $g_0 = 0$。\n3.  对于 $t \\in \\{1, 2, 3\\}$，必须满足爬坡约束 $|g_t - g_{t-1}| \\le 1$。\n\n通过系统地枚举从 $g_0=0$ 开始并满足这些约束的所有路径，我们可以构建有限集 $\\mathcal{G}$。推导过程如下：\n- 对于 $t=1$，给定 $g_0=0$，爬坡约束允许 $g_1 \\in \\{0, 1\\}$。\n- 对于 $t=2$，如果 $g_1=0$，则 $g_2 \\in \\{0, 1\\}$。如果 $g_1=1$，则 $g_2 \\in \\{0, 1, 2\\}$。\n- 对于 $t=3$，$g_3$ 的可能值取决于 $g_2$。如果 $g_2=0$，$g_3 \\in \\{0, 1\\}$。如果 $g_2=1$，$g_3 \\in \\{0, 1, 2\\}$。如果 $g_2=2$，$g_3 \\in \\{1, 2\\}$。\n这种构造性枚举在 $\\mathcal{G}$ 中总共产生 12 个唯一的可行调度。由于这个集合很小，我们可以通过穷举搜索来解决优化问题。\n\n对于给定的调度 $\\mathbf{g}$ 和已实现的需求向量 $\\mathbf{D}=(D_1, D_2, D_3)$，总成本由以下函数给出：\n$$\nC(\\mathbf{g}, \\mathbf{D}) = \\sum_{t=1}^{3} \\left( c \\cdot g_t + p \\cdot \\max\\{0, D_t - g_t\\} \\right)\n$$\n其中 $c$ 是单位发电成本，$p$ 是单位外部采购成本。\n\n对于每个测试用例，我们按以下步骤进行：\n\n1.  **解决鲁棒训练问题**：我们找到鲁棒最优调度 $\\mathbf{g}_R$。该调度最小化了在不确定性集 $\\mathcal{U}_0$ 上的最坏情况成本。如前所述，成本函数 $C(\\mathbf{g}, \\mathbf{D})$ 在 $\\mathbf{D}$ 的每个分量上都是非递减的，因此最坏情况的需求是 $\\mathbf{d}_{\\max}$。问题因此变为：\n    $$\n    \\mathbf{g}_R \\in \\arg\\min_{\\mathbf{g} \\in \\mathcal{G}} C(\\mathbf{g}, \\mathbf{d}_{\\max})\n    $$\n    我们为每个 $\\mathbf{g} \\in \\mathcal{G}$ 计算 $C(\\mathbf{g}, \\mathbf{d}_{\\max})$，并确定达到最小成本的调度。\n\n2.  **解决随机训练问题**：我们找到随机最优调度 $\\mathbf{g}_S$。该调度最小化了在训练概率分布 $P_0$ 下的期望成本。对于具有场景 $\\mathbf{D}^{(i)}$ 和相关概率 $\\pi_i$ 的离散分布 $P_0$，问题是：\n    $$\n    \\mathbf{g}_S \\in \\arg\\min_{\\mathbf{g} \\in \\mathcal{G}} \\mathbb{E}_{P_0}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right] = \\arg\\min_{\\mathbf{g} \\in \\mathcal{G}} \\sum_{i} \\pi_i C(\\mathbf{g}, \\mathbf{D}^{(i)})\n    $$\n    我们为每个 $\\mathbf{g} \\in \\mathcal{G}$ 计算这个期望成本，并找到一个最小化它的调度。\n\n3.  **执行样本外评估**：所有调度（包括 $\\mathbf{g}_R$ 和 $\\mathbf{g}_S$）的性能都在真实概率分布 $P^*$ 下进行评估。我们计算每个调度 $\\mathbf{g} \\in \\mathcal{G}$ 在 $P^*$ 下的期望成本：\n    $$\n    \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right] = \\sum_{j} \\pi_j^* C(\\mathbf{g}, \\mathbf{D}^{(j)})\n    $$\n    其中 $\\mathbf{D}^{(j)}$ 是场景，$\\pi_j^*$ 是来自 $P^*$ 的概率。通过这些计算，我们确定真实的最小期望成本，即“全知”最优解：\n    $$\n    C^*_{P^*} = \\min_{\\mathbf{h} \\in \\mathcal{G}} \\mathbb{E}_{P^*}\\left[ C(\\mathbf{h}, \\mathbf{D}) \\right]\n    $$\n\n4.  **计算性能指标**：使用前面步骤的结果，我们为每个测试用例计算所需的指标：\n    -   **鲁棒性代价 (PoR)**：鲁棒解和随机解在样本外性能上的差异。\n        $$\n        \\text{PoR} = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_R, \\mathbf{D}) \\right] - \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_S, \\mathbf{D}) \\right]\n        $$\n    -   **$\\mathbf{g}_R$ 的样本外遗憾**：鲁棒解与真实最优解相比的性能损失。\n        $$\n        \\text{Reg}(\\mathbf{g}_R) = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_R, \\mathbf{D}) \\right] - C^*_{P^*}\n        $$\n    -   **$\\mathbf{g}_S$ 的样本外遗憾**：随机解与真实最优解相比的性能损失。\n        $$\n        \\text{Reg}(\\mathbf{g}_S) = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_S, \\mathbf{D}) \\right] - C^*_{P^*}\n        $$\n在多个调度为鲁棒或随机问题产生相同最小成本的情况下，使用确定性的平局打破规则（例如，选择枚举列表中遇到的第一个）以确保结果唯一。整个过程在一个程序中实现，该程序遍历提供的测试用例并按指定格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the energy system optimization problem for all test cases.\n    \"\"\"\n\n    def generate_schedules():\n        \"\"\"\n        Enumerates the set of all feasible generation schedules G.\n        A schedule g = (g1, g2, g3) is feasible if:\n        1. g_t is in {0, 1, 2}.\n        2. g_0 = 0.\n        3. |g_t - g_{t-1}| = 1.\n        \"\"\"\n        schedules = []\n        g0 = 0\n        # Time t=1\n        for g1 in range(max(0, g0 - 1), min(2, g0 + 1) + 1):\n            # Time t=2\n            for g2 in range(max(0, g1 - 1), min(2, g1 + 1) + 1):\n                # Time t=3\n                for g3 in range(max(0, g2 - 1), min(2, g2 + 1) + 1):\n                    schedules.append(np.array([g1, g2, g3], dtype=int))\n        return schedules\n\n    def calculate_cost(g, D, c, p):\n        \"\"\"\n        Calculates the total cost C(g, D) for a given schedule and demand.\n        C(g, D) = sum(c*g_t + p*max(0, D_t - g_t)) for t=1,2,3.\n        \"\"\"\n        generation_cost = c * np.sum(g)\n        procurement_cost = p * np.sum(np.maximum(0, D - g))\n        return generation_cost + procurement_cost\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"c\": 20, \"p\": 100, \"d_max\": np.array([1, 2, 2]),\n            \"P0\": {\"scenarios\": [np.array([0, 1, 1]), np.array([1, 2, 1]), np.array([0, 0, 2])], \"probs\": [0.5, 0.3, 0.2]},\n            \"P_star\": {\"scenarios\": [np.array([1, 2, 2]), np.array([0, 1, 2]), np.array([2, 2, 2])], \"probs\": [0.4, 0.4, 0.2]}\n        },\n        {\n            \"c\": 40, \"p\": 60, \"d_max\": np.array([1, 1, 1]),\n            \"P0\": {\"scenarios\": [np.array([0, 1, 0]), np.array([1, 1, 1])], \"probs\": [0.6, 0.4]},\n            \"P_star\": {\"scenarios\": [np.array([1, 2, 1]), np.array([0, 0, 1])], \"probs\": [0.5, 0.5]}\n        },\n        {\n            \"c\": 20, \"p\": 100, \"d_max\": np.array([0, 0, 0]),\n            \"P0\": {\"scenarios\": [np.array([0, 0, 0])], \"probs\": [1.0]},\n            \"P_star\": {\"scenarios\": [np.array([2, 2, 2])], \"probs\": [1.0]}\n        }\n    ]\n\n    schedules = generate_schedules()\n    final_results = []\n\n    for case in test_cases:\n        c, p, d_max = case[\"c\"], case[\"p\"], case[\"d_max\"]\n        P0 = case[\"P0\"]\n        P_star = case[\"P_star\"]\n\n        # 1. Find g_R (Robust solution) by minimizing worst-case cost\n        robust_costs = [calculate_cost(g, d_max, c, p) for g in schedules]\n        min_robust_cost = min(robust_costs)\n        # Deterministic tie-breaking by taking the first occurrence\n        idx_gR = robust_costs.index(min_robust_cost)\n        \n        # 2. Find g_S (Stochastic solution) by minimizing expected cost under P0\n        stochastic_costs_p0 = []\n        for g in schedules:\n            expected_cost = sum(prob * calculate_cost(g, D, c, p) for D, prob in zip(P0[\"scenarios\"], P0[\"probs\"]))\n            stochastic_costs_p0.append(expected_cost)\n        min_stochastic_cost_p0 = min(stochastic_costs_p0)\n        idx_gS = stochastic_costs_p0.index(min_stochastic_cost_p0)\n        \n        # 3. Evaluate all schedules under P_star to find true performance and true optimum\n        true_expected_costs = []\n        for g in schedules:\n            expected_cost = sum(prob * calculate_cost(g, D, c, p) for D, prob in zip(P_star[\"scenarios\"], P_star[\"probs\"]))\n            true_expected_costs.append(expected_cost)\n            \n        min_true_cost = min(true_expected_costs)\n        \n        # Performance of g_R and g_S under P_star\n        exp_cost_gR_pstar = true_expected_costs[idx_gR]\n        exp_cost_gS_pstar = true_expected_costs[idx_gS]\n\n        # 4. Calculate metrics\n        PoR = exp_cost_gR_pstar - exp_cost_gS_pstar\n        Reg_R = exp_cost_gR_pstar - min_true_cost\n        Reg_S = exp_cost_gS_pstar - min_true_cost\n        \n        # Format results for this case\n        case_result_str = f\"[{PoR:.2f},{Reg_R:.2f},{Reg_S:.2f}]\"\n        final_results.append(case_result_str)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们使用的系统模型参数，例如电池的等效电路参数，往往不是精确已知的。为了辨识这些参数，我们可以设计实验来主动收集信息，但这引出了一个更深层次的问题：什么样的实验才是“最优”的？这项高级练习将引导您进入最优实验设计的领域，利用费雪信息矩阵（Fisher Information Matrix）来寻找能够最大程度降低参数不确定性的输入信号。您将亲手为一个电池模型设计最优的输入电流序列，以最小化参数的后验协方差，从而深刻理解如何利用系统动态特性来主动获取信息并提升模型精度。",
            "id": "4128477",
            "problem": "您的任务是为单个电阻-电容电池等效电路模型设计一个输入电流序列，以在观察电压响应后最小化其参数的不确定性，同时满足幅度和能量约束。核心建模假设和推导必须从以下基本基础出发：小信号的线性系统动力学、高斯测量噪声以及使用线性化灵敏度的贝叶斯估计。\n\n考虑带有一个电阻和一个电容的戴维南模型。设输入为电流序列 $\\{i_k\\}_{k=0}^{N-1}$，采样周期为 $dt$，样本之间为零阶保持。内部状态 $v_{1,k}$ 根据从连续时间一阶线性系统 $dv_1/dt = -(1/(R_1 C_1)) v_1 + (1/C_1) i(t)$ 推导出的离散时间动力学演化：\n$$\nv_{1,k+1} = a(\\boldsymbol{\\theta})\\, v_{1,k} + b(\\boldsymbol{\\theta})\\, i_k,\n$$\n其中 $\\boldsymbol{\\theta} = [R_0, R_1, C_1]^\\top$， $a(\\boldsymbol{\\theta}) = \\exp\\!\\left(-\\dfrac{dt}{R_1 C_1}\\right)$，以及 $b(\\boldsymbol{\\theta}) = R_1 \\left(1 - a(\\boldsymbol{\\theta})\\right)$。测得的端电压（相对于开路电压）为\n$$\ny_k = - R_0\\, i_k - v_{1,k} + \\varepsilon_k,\n$$\n其中 $\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma^2)$ 是独立同分布的高斯测量噪声。\n\n对于不确定性下的实验设计，我们使用由 $\\boldsymbol{\\phi} = \\boldsymbol{\\theta} \\oslash \\boldsymbol{\\theta}_0$ 定义的归一化无量纲参数，其中 $\\boldsymbol{\\theta}_0$ 是一个标称参数向量，$\\oslash$ 表示逐元素除法。假设 $\\boldsymbol{\\phi}$ 服从高斯先验分布 $\\boldsymbol{\\phi} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\mathbf{C}_{\\text{prior}})$，其协方差矩阵为对角阵 $\\mathbf{C}_{\\text{prior}} = \\operatorname{diag}(\\sigma_{\\phi,0}^2, \\sigma_{\\phi,1}^2, \\sigma_{\\phi,2}^2)$。\n\n在围绕 $\\boldsymbol{\\theta}_0$ 的测量模型的一阶线性化下，对于输入 $\\{i_k\\}$ 的归一化参数的费雪信息矩阵为\n$$\n\\mathbf{F} = \\frac{1}{\\sigma^2}\\, \\mathbf{J}_\\phi^\\top \\mathbf{J}_\\phi,\n$$\n其中 $\\mathbf{J}_\\phi \\in \\mathbb{R}^{N \\times 3}$ 是无噪声输出序列 $\\mathbf{y}(\\boldsymbol{\\theta}, \\{i_k\\})$ 相对于 $\\boldsymbol{\\phi}$ 的雅可比矩阵，在 $\\boldsymbol{\\theta}_0$ 处求值。在线性高斯近似下的后验协方差为\n$$\n\\mathbf{C}_{\\text{post}} = \\left(\\mathbf{C}_{\\text{prior}}^{-1} + \\mathbf{F}\\right)^{-1}.\n$$\n您的设计目标是最小化标量泛函\n$$\nJ(\\{i_k\\}) = \\operatorname{tr}\\!\\left(\\mathbf{C}_{\\text{post}}\\right),\n$$\n该泛函是无量纲的，因为它是为归一化参数 $\\boldsymbol{\\phi}$ 定义的。\n\n输入电流序列必须满足以下约束：\n- 幅度限制：对所有 $k$，$|i_k| \\leq u_{\\max}$。\n- 能量限制：$\\sum_{k=0}^{N-1} i_k^2\\, dt \\leq E_{\\max}$。\n所有电流单位必须是安培 ($\\mathrm{A}$)，时间单位是秒 ($\\mathrm{s}$)，电阻单位是欧姆 ($\\Omega$)，电容单位是法拉 ($\\mathrm{F}$)，电压单位是伏特 ($\\mathrm{V}$)。输出目标 $J(\\{i_k\\})$ 是无量纲的。\n\n为了使问题可通过算法测试，您的程序必须评估一组固定的候选输入序列族（定义为单位幅度的模板，随后将进行缩放以满足两个约束），选择最小化 $J(\\{i_k\\})$ 的那一个，并报告结果。候选模板由 $c \\in \\{0,1,2,3,4,5,6,7,8\\}$ 索引：\n- $c=0$：零序列，$i_k = 0$。\n- $c=1$：在中间点符号反转的阶跃序列，$k  N/2$ 时 $i_k = 1$， $k \\ge N/2$ 时 $i_k = -1$。\n- $c=2$：在整个时间范围内有 $1$ 个周期的单个正弦波，$i_k = \\sin\\!\\left(2\\pi \\frac{1}{N} k\\right)$。\n- $c=3$：有 $3$ 个周期的正弦波，$i_k = \\sin\\!\\left(2\\pi \\frac{3}{N} k\\right)$。\n- $c=4$：有 $10$ 个周期的正弦波，$i_k = \\sin\\!\\left(2\\pi \\frac{10}{N} k\\right)$。\n- $c=5$：伪随机二进制序列（使用固定种子，确定性生成），$i_k \\in \\{-1, +1\\}$。\n- $c=6$：白噪声序列（使用固定种子，确定性生成），$i_k$ 从标准正态模板中独立同分布采样。\n- $c=7$：脉冲对，$i_{k^+} = +1$ 在 $k^+ = \\lfloor N/4 \\rfloor$， $i_{k^-} = -1$ 在 $k^- = \\lfloor 3N/4 \\rfloor$，其他情况下 $i_k = 0$。\n- $c=8$：双正弦组合，$i_k = \\sin\\!\\left(2\\pi \\frac{1}{N} k\\right) + \\sin\\!\\left(2\\pi \\frac{3}{N} k\\right)$。\n\n对于每个候选模板，通过一个缩放因子 $s$ 进行缩放，该因子被选择以满足两个约束：\n$$ s \\le u_{\\max}, \\quad s \\le \\sqrt{\\frac{E_{\\max}}{dt \\sum_{k=0}^{N-1} (i_k^{(\\text{template})})^2}} $$\n使用 $s = \\min\\left(u_{\\max}, \\sqrt{\\frac{E_{\\max}}{dt \\sum_{k=0}^{N-1} (i_k^{(\\text{template})})^2}}\\right)$，并将实现的输入序列定义为 $i_k^{(\\text{realized})} = s\\, i_k^{(\\text{template})}$。\n\n通过在 $\\boldsymbol{\\theta}_0$ 处对无噪声输出序列关于 $\\boldsymbol{\\theta}$ 的每个参数分量进行有限差分来计算 $\\mathbf{J}_\\phi$，然后通过将每列乘以相应的标称参数分量来转换为归一化参数。具体来说，对于第 $p$ 个分量的一个小微扰 $\\delta\\theta_p$，\n$$\n\\left[\\mathbf{J}_\\theta\\right]_{:,p} \\approx \\frac{\\mathbf{y}(\\boldsymbol{\\theta}_0 + \\delta\\theta_p\\, \\mathbf{e}_p, \\{i_k\\}) - \\mathbf{y}(\\boldsymbol{\\theta}_0, \\{i_k\\})}{\\delta\\theta_p},\n\\quad\n\\left[\\mathbf{J}_\\phi\\right]_{:,p} = \\theta_{0,p}\\, \\left[\\mathbf{J}_\\theta\\right]_{:,p}.\n$$\n\n测试套件。使用以下三种情况，每种情况以元组 $(N, dt, \\boldsymbol{\\theta}_0, \\boldsymbol{\\sigma}_\\phi, \\sigma, u_{\\max}, E_{\\max})$ 的形式提供：\n- 情况 A (理想情况): $N = 60$, $dt = 1$, $\\boldsymbol{\\theta}_0 = [0.02, 0.05, 2000]$, $\\boldsymbol{\\sigma}_\\phi = [0.5, 0.5, 0.5]$, $\\sigma = 0.01$, $u_{\\max} = 5$, $E_{\\max} = 600$。\n- 情况 B (低能量): $N = 60$, $dt = 1$, $\\boldsymbol{\\theta}_0 = [0.02, 0.05, 2000]$, $\\boldsymbol{\\sigma}_\\phi = [0.5, 0.5, 0.5]$, $\\sigma = 0.01$, $u_{\\max} = 5$, $E_{\\max} = 10$。\n- 情况 C (幅度限制): $N = 60$, $dt = 1$, $\\boldsymbol{\\theta}_0 = [0.02, 0.05, 2000]$, $\\boldsymbol{\\sigma}_\\phi = [0.5, 0.5, 0.5]$, $\\sigma = 0.01$, $u_{\\max} = 0.5$, $E_{\\max} = 600$。\n\n输出规范。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，输出三元组 $[c^\\star, J^\\star, E_{\\text{used}}]$，其中 $c^\\star$ 是最佳候选模板的整数索引，$J^\\star$ 是最小化的无量纲目标值，$E_{\\text{used}} = dt \\sum_k (i_k^{(\\text{realized})})^2$ 是实现的输入能量，单位为 $\\mathrm{A}^2\\cdot\\mathrm{s}$，表示为不带单位符号的十进制数。总体输出应为这三个三元组按测试套件案例顺序排列的列表，例如 $[[c_1,J_1,E_1],[c_2,J_2,E_2],[c_3,J_3,E_3]]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于电气电路理论和系统辨识的既定原则，在数学上是适定的，并且用客观、正式的语言定义。所有必要的数据和约束都已提供，以得出一个唯一的、可计算的解。\n\n该问题要求我们从一组给定的候选序列中，为单个电阻-电容（RC）电池模型找到最优的输入电流序列 $\\{i_k\\}_{k=0}^{N-1}$。最优性标准是最小化模型归一化参数的后验协方差矩阵的迹，这是衡量实验后参数不确定性的指标。这是一个经典的 A-最优实验设计问题。\n\n该模型是一个戴维南等效电路，参数为 $\\boldsymbol{\\theta} = [R_0, R_1, C_1]^\\top$。系统动力学以离散时间形式给出：\n$$\nv_{1,k+1} = a(\\boldsymbol{\\theta})\\, v_{1,k} + b(\\boldsymbol{\\theta})\\, i_k\n$$\n$$\ny_k = - R_0\\, i_k - v_{1,k}\n$$\n其中 $v_{1,k}$ 是RC对两端的电压，$y_k$ 是相对于开路电压的无噪声端电压测量值，系数是参数的函数：\n$$\na(\\boldsymbol{\\theta}) = \\exp\\left(-\\frac{dt}{R_1 C_1}\\right)\n$$\n$$\nb(\\boldsymbol{\\theta}) = R_1 \\left(1 - a(\\boldsymbol{\\theta})\\right)\n$$\n我们假设初始条件 $v_{1,0} = 0$，表示系统处于静止状态。\n\n目标是最小化 $J(\\{i_k\\}) = \\operatorname{tr}(\\mathbf{C}_{\\text{post}})$，其中归一化参数 $\\boldsymbol{\\phi} = \\boldsymbol{\\theta} \\oslash \\boldsymbol{\\theta}_0$ 的后验协方差矩阵由线性高斯近似下的贝叶斯更新公式给出：\n$$\n\\mathbf{C}_{\\text{post}} = \\left(\\mathbf{C}_{\\text{prior}}^{-1} + \\mathbf{F}\\right)^{-1}\n$$\n先验协方差 $\\mathbf{C}_{\\text{prior}}$ 是对角矩阵，其对角线元素为 $\\sigma_{\\phi,p}^2$。费雪信息矩阵（FIM）$\\mathbf{F}$ 为：\n$$\n\\mathbf{F} = \\frac{1}{\\sigma^2}\\, \\mathbf{J}_\\phi^\\top \\mathbf{J}_\\phi\n$$\n这里，$\\mathbf{J}_\\phi \\in \\mathbb{R}^{N \\times 3}$ 是输出序列 $\\mathbf{y} = [y_0, \\dots, y_{N-1}]^\\top$ 关于归一化参数 $\\boldsymbol{\\phi}$ 的灵敏度雅可比矩阵，在标称参数值 $\\boldsymbol{\\theta}_0$ 处求值。\n\n解决此问题的每个测试用例的算法流程如下：\n\n1.  **遍历候选序列**：对每个候选模板 $c \\in \\{0, 1, \\dots, 8\\}$，生成并评估一个输入电流序列 $\\{i_k\\}$。\n\n2.  **生成并缩放输入序列**：\n    a. 根据候选 $c$ 的定义，生成一个原始模板序列 $\\{i_k^{(\\text{raw})}\\}$。对于伪随机序列（$c=5, 6$），使用固定的随机种子以确保结果的确定性和可复现性。\n    b. 问题提到“单位幅度模板”。为确保此属性并保持所有候选序列的一致性，每个原始模板都通过其最大绝对值进行归一化。令 $M = \\max_k |i_k^{(\\text{raw})}|$。单位幅度模板为 $\\{i_k^{(\\text{template})}\\} = \\{i_k^{(\\text{raw})} / M\\}$（如果 $M > 0$），否则为 $\\{0\\}$。\n    c. 计算一个缩放因子 $s$，以确保最终序列同时满足幅度约束（$|i_k| \\le u_{\\max}$）和能量约束（$\\sum_{k=0}^{N-1} i_k^2\\, dt \\le E_{\\max}$）。对于单位幅度模板，$|i_k^{(\\text{template})}| \\le 1$，因此幅度约束变为 $s \\le u_{\\max}$。能量约束导致 $s \\le \\sqrt{E_{\\max} / (dt \\sum_k (i_k^{(\\text{template})})^2)}$。最大化利用允许输入范围的最优缩放因子是：\n        $$\n        s = \\min\\left(u_{\\max}, \\sqrt{\\frac{E_{\\max}}{dt \\sum_{k=0}^{N-1} (i_k^{(\\text{template})})^2}}\\right)\n        $$\n        对于全零模板（例如 $c=0$）的特殊情况需要处理，以避免除以零，此时 $s$ 实际上为 $0$。\n    d. 实现的输入序列则为 $\\{i_k^{(\\text{realized})}\\} = s \\cdot \\{i_k^{(\\text{template})}\\}$。\n\n3.  **计算雅可比矩阵 $\\mathbf{J}_\\phi$**：\n    a. 输出 $\\mathbf{y}$ 关于物理参数 $\\boldsymbol{\\theta}$ 的雅可比矩阵通过围绕标称值 $\\boldsymbol{\\theta}_0$ 的数值前向差分来计算。对于每个参数 $\\theta_p \\in \\{R_0, R_1, C_1\\}$，引入一个小的微扰 $\\delta\\theta_p$。一个稳健的微扰大小选择是 $\\delta\\theta_p = \\theta_{0,p} \\sqrt{\\epsilon_{\\text{machine}}}$，其中 $\\epsilon_{\\text{machine}}$ 是浮点数的机器ε。\n    b. 雅可比矩阵 $\\mathbf{J}_\\theta$ 的第 $p$ 列近似为：\n        $$\n        [\\mathbf{J}_\\theta]_{:,p} \\approx \\frac{\\mathbf{y}(\\boldsymbol{\\theta}_0 + \\delta\\theta_p \\mathbf{e}_p, \\{i_k^{(\\text{realized})}\\}) - \\mathbf{y}(\\boldsymbol{\\theta}_0, \\{i_k^{(\\text{realized})}\\})}{\\delta\\theta_p}\n        $$\n        其中 $\\mathbf{y}(\\cdot)$ 是模拟的无噪声输出序列。\n    c. 使用链式法则，通过缩放 $\\mathbf{J}_\\theta$ 的每一列来获得关于归一化参数 $\\boldsymbol{\\phi}$ 的雅可比矩阵：\n        $$\n        [\\mathbf{J}_\\phi]_{:,p} = \\theta_{0,p} [\\mathbf{J}_\\theta]_{:,p}\n        $$\n\n4.  **评估目标函数 $J$**：\n    a. 计算对角先验协方差矩阵的逆：$\\mathbf{C}_{\\text{prior}}^{-1} = \\operatorname{diag}(1/\\sigma_{\\phi,0}^2, 1/\\sigma_{\\phi,1}^2, 1/\\sigma_{\\phi,2}^2)$。\n    b. 计算FIM：$\\mathbf{F} = (1/\\sigma^2) \\mathbf{J}_\\phi^\\top \\mathbf{J}_\\phi$。\n    c. 通过矩阵求逆找到后验协方差：$\\mathbf{C}_{\\text{post}} = (\\mathbf{C}_{\\text{prior}}^{-1} + \\mathbf{F})^{-1}$。\n    d. 目标函数值是该矩阵的迹：$J = \\operatorname{tr}(\\mathbf{C}_{\\text{post}})$。对于零输入情况（$c=0$），$\\mathbf{J}_\\phi$ 是一个零矩阵，因此 $\\mathbf{F}=\\mathbf{0}$，$\\mathbf{C}_{\\text{post}} = \\mathbf{C}_{\\text{prior}}$，且 $J = \\operatorname{tr}(\\mathbf{C}_{\\text{prior}})$。\n\n5.  **选择最优解**：对所有候选模板重复此过程。选择产生最小目标值 $J^\\star$ 的候选索引 $c^\\star$ 作为最优选择。同时记录此最优序列所使用的能量 $E_{\\text{used}} = dt \\sum_k (i_{k,\\text{opt}}^{(\\text{realized})})^2$。\n\n此过程应用于提供的三个测试用例中的每一个。最终输出是一个列表，包含每个用例的三元组 $[c^\\star, J^\\star, E_{\\text{used}}]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the optimal experiment design problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case A: Happy path\n        (60, 1.0, np.array([0.02, 0.05, 2000.0]), np.array([0.5, 0.5, 0.5]), 0.01, 5.0, 600.0),\n        # Case B: Low energy\n        (60, 1.0, np.array([0.02, 0.05, 2000.0]), np.array([0.5, 0.5, 0.5]), 0.01, 5.0, 10.0),\n        # Case C: Amplitude-limited\n        (60, 1.0, np.array([0.02, 0.05, 2000.0]), np.array([0.5, 0.5, 0.5]), 0.01, 0.5, 600.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, dt, theta0, sigma_phi, sigma, u_max, E_max = case\n        \n        # Reset the seed for each test case to ensure independence\n        np.random.seed(0)\n\n        best_J = float('inf')\n        best_c = -1\n        best_E_used = -1\n\n        for c in range(9):\n            # 1. Generate Raw Template\n            i_raw = generate_template(c, N)\n\n            # 2. Normalize to a unit-amplitude template\n            max_abs_raw = np.max(np.abs(i_raw))\n            if max_abs_raw > 0:\n                i_template = i_raw / max_abs_raw\n            else:\n                i_template = i_raw  # Already all zeros\n\n            # 3. Calculate scaling factor s and realized input\n            template_energy_sum_sq = np.sum(i_template**2)\n            if template_energy_sum_sq == 0:\n                s = 0.0\n            else:\n                s_energy = np.sqrt(E_max / (dt * template_energy_sum_sq))\n                s = min(u_max, s_energy)\n            \n            i_realized = s * i_template\n\n            # 4. Calculate objective function J\n            current_J = calculate_objective(i_realized, N, dt, theta0, sigma_phi, sigma)\n\n            # 5. Update best result\n            if current_J  best_J:\n                best_J = current_J\n                best_c = c\n                best_E_used = dt * np.sum(i_realized**2)\n        \n        results.append([best_c, best_J, best_E_used])\n\n    # Format the output as a string representation of a list of lists.\n    # The problem asks for a very specific representation.\n    # We build it manually to ensure correctness.\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        c_star, J_star, E_used = res\n        output_str += f\"[{c_star},{J_star:.7f},{E_used:.7f}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\n\ndef generate_template(c, N):\n    \"\"\"Generates the raw input current template for a given candidate index c.\"\"\"\n    k = np.arange(N)\n    if c == 0:\n        return np.zeros(N)\n    elif c == 1:\n        i = np.ones(N)\n        i[N//2:] = -1.0\n        return i\n    elif c == 2:\n        return np.sin(2 * np.pi * 1 * k / N)\n    elif c == 3:\n        return np.sin(2 * np.pi * 3 * k / N)\n    elif c == 4:\n        return np.sin(2 * np.pi * 10 * k / N)\n    elif c == 5:\n        # PRBS needs a fixed seed, handled in the main loop\n        return 2 * np.random.randint(0, 2, size=N) - 1\n    elif c == 6:\n        # White noise needs a fixed seed, handled in the main loop\n        return np.random.randn(N)\n    elif c == 7:\n        i = np.zeros(N)\n        k_plus = int(np.floor(N / 4))\n        k_minus = int(np.floor(3 * N / 4))\n        i[k_plus] = 1.0\n        i[k_minus] = -1.0\n        return i\n    elif c == 8:\n        return np.sin(2 * np.pi * 1 * k / N) + np.sin(2 * np.pi * 3 * k / N)\n    else:\n        raise ValueError(\"Invalid candidate index\")\n\n\ndef simulate_model(i_seq, theta, N, dt):\n    \"\"\"Simulates the noiseless voltage output of the battery model.\"\"\"\n    R0, R1, C1 = theta\n    \n    if R1 == 0 or C1 == 0:\n        return np.full(N, np.nan)\n        \n    a = np.exp(-dt / (R1 * C1))\n    b = R1 * (1 - a)\n    \n    v1 = np.zeros(N)\n    # The loop runs up to N-2, calculating v1[1] to v1[N-1]\n    for k in range(N - 1):\n        v1[k + 1] = a * v1[k] + b * i_seq[k]\n        \n    y = -R0 * i_seq - v1\n    return y\n\n\ndef calculate_objective(i_seq, N, dt, theta0, sigma_phi, sigma):\n    \"\"\"Calculates the objective function J = tr(C_post).\"\"\"\n    \n    num_params = len(theta0)\n    \n    # Handle the zero-input case, which gives no information\n    if np.all(i_seq == 0):\n        C_prior = np.diag(sigma_phi**2)\n        return np.trace(C_prior)\n\n    # Calculate Jacobian J_phi\n    J_phi = np.zeros((N, num_params))\n    y_nominal = simulate_model(i_seq, theta0, N, dt)\n    \n    # Machine epsilon for finite difference perturbation\n    eps = np.finfo(float).eps\n\n    for p in range(num_params):\n        theta_p = theta0.copy()\n        delta = theta_p[p] * np.sqrt(eps)\n        if delta == 0: # Handle cases where theta0 component is 0\n            delta = np.sqrt(eps)\n        theta_p[p] += delta\n        \n        y_perturbed = simulate_model(i_seq, theta_p, N, dt)\n        \n        J_theta_col_p = (y_perturbed - y_nominal) / delta\n        J_phi[:, p] = J_theta_col_p * theta0[p]\n\n    # Calculate Fisher Information Matrix (FIM)\n    F = (1 / sigma**2) * (J_phi.T @ J_phi)\n    \n    # Calculate Posterior Covariance\n    C_prior_inv = np.diag(1.0 / sigma_phi**2)\n    C_post_inv = C_prior_inv + F\n    \n    try:\n        C_post = np.linalg.inv(C_post_inv)\n    except np.linalg.LinAlgError:\n        # If matrix is singular, posterior uncertainty is infinite\n        return float('inf')\n        \n    # Return the trace\n    return np.trace(C_post)\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}