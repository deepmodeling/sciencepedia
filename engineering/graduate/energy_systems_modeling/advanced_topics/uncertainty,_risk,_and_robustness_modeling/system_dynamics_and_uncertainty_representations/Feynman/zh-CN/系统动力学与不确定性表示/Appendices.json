{
    "hands_on_practices": [
        {
            "introduction": "在为如电池这样的非线性系统进行状态估计时，准确地传递不确定性至关重要。虽然线性化方法简单，但它可能在非线性较强时引入显著误差。本练习将引导您实践一种更先进的技术——无迹变换（Unscented Transform），通过确定性采样来逼近非线性函数下的概率分布，并将其结果与蒙特卡洛仿真的“黄金标准”进行比较，从而深入理解其在处理系统动态不确定性方面的优势。",
            "id": "4128494",
            "problem": "考虑一个具有加性过程噪声的电池荷电状态（SOC）的单状态离散时间模型。设在步骤 $k$ 的 SOC 为 $x_k \\in \\mathbb{R}$，表示一个在 $[0,1]$ 范围内的无量纲分数。在持续时间为 $\\Delta t$ 小时、施加恒定电流 $I$（放电为正，充电为负）的情况下，从 $x_k$到 $x_{k+1}$ 的离散时间更新定义为\n$$\nx_{k+1} \\triangleq f(x_k; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) + w_k,\n$$\n其中\n$$\nf(x; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) = x - \\frac{\\Delta t}{C_{\\mathrm{eff}}} \\, I \\left( 1 + \\gamma \\left(1 - 2x\\right)^3 \\right),\n$$\n$C_{\\mathrm{eff}}$ 是有效容量，单位为安时（Ah），$w_k$ 是过程噪声，建模为零均值高斯随机变量 $w_k \\sim \\mathcal{N}(0, q)$，其方差为 $q$。非线性程度由无量纲参数 $\\gamma \\ge 0$ 控制。初始 SOC $x_k$ 是不确定的，建模为高斯随机变量 $x_k \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$。\n\n您的任务是实现无迹变换（UT），以在给定 $x_k$ 的高斯先验和非线性函数 $f(\\cdot)$ 的情况下，近似计算 $x_{k+1}$ 的均值和协方差，并将基于 UT 的估计值与通过对 $x_k$ 和 $w_k$ 采样并经由非线性更新传播得到的经验蒙特卡洛估计值进行比较。使用无迹变换的缩放参数 $\\alpha_{\\mathrm{UT}}$、$\\beta_{\\mathrm{UT}}$ 和 $\\kappa_{\\mathrm{UT}}$，其指定值如下：$\\alpha_{\\mathrm{UT}} = 0.5$、$\\beta_{\\mathrm{UT}} = 2$ 和 $\\kappa_{\\mathrm{UT}} = 0$。\n\n您必须使用的基本假设：\n- 电荷守恒意味着在恒定电流下，经过 $\\Delta t$ 时间的确定性 SOC 变化与 $\\Delta t/C_{\\mathrm{eff}}$ 成正比，符号由电流方向决定。\n- 随机变量通过非线性函数的变换需要对输入分布进行积分；无迹变换提供了一种确定性采样方案，以近似计算这些针对高斯先验的积分。\n- 方差为 $q$ 的加性高斯噪声会使输出协方差增加 $q$。\n\n实现一个程序，对于每个测试用例，返回两个标量结果：\n- UT 均值估计 $\\mu_{\\mathrm{UT}}$ 与蒙特卡洛均值 $\\mu_{\\mathrm{MC}}$ 之间的绝对差，表示为小数（无量纲）。\n- UT 方差估计 $\\sigma^2_{\\mathrm{UT}}$ 与蒙特卡洛方差 $\\sigma^2_{\\mathrm{MC}}$ 之间的绝对差，表示为小数（无量纲）。\n\n您必须将 SOC 视为无量纲分数。任何地方都不要使用百分号；始终将与 SOC 相关的量表示为小数。角度单位不适用于此问题。\n\n使用以下参数值测试套件，该套件涵盖了典型的工作条件、接近 SOC 极值的边界条件以及变化的非线性水平。每个测试用例以元组 $(\\mu_0, \\sigma_0, I, \\gamma, \\sigma_w, \\Delta t, C_{\\mathrm{eff}}, N_{\\mathrm{MC}})$ 的形式给出，其中 $q = \\sigma_w^2$：\n- 测试用例 1（基准线性区域）：$(0.5, 0.01, 5.0, 0.0, 0.001, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 2（中等非线性，较大的先验不确定性）：$(0.5, 0.05, 5.0, 2.0, 0.0015, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 3（接近上边界的高 SOC，强非线性，较高的放电电流）：$(0.95, 0.02, 10.0, 5.0, 0.002, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 4（接近下边界的低 SOC，中等非线性，充电电流）：$(0.05, 0.02, -3.0, 3.0, 0.001, \\frac{1}{60}, 5.0, 50000)$\n- 测试用例 5（极端非线性但非常小的先验方差）：$(0.5, 0.001, 5.0, 10.0, 0.001, \\frac{1}{60}, 5.0, 50000)$\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序连接每个测试用例的绝对误差对，即，其形式应为\n$$\n[\\varepsilon^{(1)}_{\\mu}, \\varepsilon^{(1)}_{\\sigma^2}, \\varepsilon^{(2)}_{\\mu}, \\varepsilon^{(2)}_{\\sigma^2}, \\ldots, \\varepsilon^{(5)}_{\\mu}, \\varepsilon^{(5)}_{\\sigma^2}],\n$$\n其中 $\\varepsilon^{(i)}_{\\mu} = \\left| \\mu_{\\mathrm{UT}}^{(i)} - \\mu_{\\mathrm{MC}}^{(i)} \\right|$ 和 $\\varepsilon^{(i)}_{\\sigma^2} = \\left| \\sigma_{\\mathrm{UT}}^{2\\,(i)} - \\sigma_{\\mathrm{MC}}^{2\\,(i)} \\right|$ 是小数。\n\n程序必须是完整的，无需任何用户输入即可运行。它必须根据上述规范实现一维情况下的无迹变换和蒙特卡洛估计，并且必须完全按照给定的测试用例进行。最后一行必须严格按照所描述的格式打印。",
            "solution": "该问题要求实现并比较两种方法，用于通过一个非线性的电池荷电状态（SOC）后验状态空间模型来传播不确定性。离散时间步 $k$ 的状态是 $x_k \\in \\mathbb{R}$，它是不确定的，并由高斯分布 $x_k \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$ 建模。状态根据以下方程演化：\n$$\nx_{k+1} = f(x_k; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) + w_k\n$$\n其中 $f(\\cdot)$ 是一个非线性函数，而 $w_k \\sim \\mathcal{N}(0, q)$ 是加性零均值高斯过程噪声，其方差为 $q = \\sigma_w^2$。目标是估计后续状态 $x_{k+1}$ 的均值 $\\mu_{k+1}$ 和方差 $\\sigma_{k+1}^2$。我们将比较无迹变换（UT）的估计值与作为高保真度基准的蒙特卡洛（MC）模拟的估计值。\n\n非线性状态转移函数由下式给出：\n$$\nf(x; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) = x - \\frac{\\Delta t}{C_{\\mathrm{eff}}} \\, I \\left( 1 + \\gamma \\left(1 - 2x\\right)^3 \\right)\n$$\n其中 $I$ 是电流，$C_{\\mathrm{eff}}$ 是有效容量，$\\Delta t$ 是时间步长，$\\gamma$ 是控制非线性的参数。\n\n**蒙特卡洛（MC）模拟**\n\n蒙特卡洛方法提供了对 $x_{k+1}$ 真实后验分布的数值近似。根据大数定律，随着样本数量趋于无穷，样本统计量会收敛到变换后分布的真实统计量。其步骤如下：\n1.  从初始高斯分布 $x_k \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$ 生成大量（$N_{\\mathrm{MC}}$ 个）随机样本 $\\{x_k^{(j)}\\}_{j=1}^{N_{\\mathrm{MC}}}$。\n2.  从过程噪声分布 $w_k \\sim \\mathcal{N}(0, q)$ 生成 $N_{\\mathrm{MC}}$ 个样本 $\\{w_k^{(j)}\\}_{j=1}^{N_{\\mathrm{MC}}}$。\n3.  对于每个样本 $j$，通过完整的状态更新方程进行传播，以获得下一个状态的样本：\n    $$\n    x_{k+1}^{(j)} = f(x_k^{(j)}; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) + w_k^{(j)}\n    $$\n4.  然后，从得到的样本集 $\\{x_{k+1}^{(j)}\\}$ 中计算经验均值 $\\mu_{\\mathrm{MC}}$ 和方差 $\\sigma_{\\mathrm{MC}}^2$：\n    $$\n    \\mu_{\\mathrm{MC}} = \\frac{1}{N_{\\mathrm{MC}}} \\sum_{j=1}^{N_{\\mathrm{MC}}} x_{k+1}^{(j)}\n    $$\n    $$\n    \\sigma_{\\mathrm{MC}}^2 = \\frac{1}{N_{\\mathrm{MC}}-1} \\sum_{j=1}^{N_{\\mathrm{MC}}} (x_{k+1}^{(j)} - \\mu_{\\mathrm{MC}})^2\n    $$\n    这里使用无偏样本方差（分母为 $N_{\\mathrm{MC}}-1$）。\n\n**无迹变换（UT）**\n\n无迹变换是一种确定性采样技术，它为近似经历非线性变换的随机变量的统计特性提供了一种更有效的方法。它使用一组最少的确定性选择的采样点，称为 sigma 点，这些点捕捉了先验高斯分布的前两个矩（均值和协方差）。\n\n对于一维状态 $x_k$，其步骤如下：\n\n1.  **定义参数**：状态维度为 $n=1$。给定的 UT 缩放参数为 $\\alpha_{\\mathrm{UT}} = 0.5$，$\\beta_{\\mathrm{UT}} = 2$，和 $\\kappa_{\\mathrm{UT}} = 0$。\n\n2.  **计算 Sigma 点和权重**：\n    - 计算复合缩放参数 $\\lambda$：\n      $$\n      \\lambda = \\alpha_{\\mathrm{UT}}^2(n + \\kappa_{\\mathrm{UT}}) - n = (0.5)^2(1+0) - 1 = 0.25 - 1 = -0.75\n      $$\n    - 从先验均值 $\\mu_0$ 和方差 $\\sigma_0^2$ 生成一组 $2n+1=3$ 个 sigma 点 $\\mathcal{X}_i$：\n      \\begin{align*}\n      \\mathcal{X}_0 = \\mu_0 \\\\\n      \\mathcal{X}_1 = \\mu_0 + \\sqrt{(n+\\lambda)\\sigma_0^2} = \\mu_0 + \\sqrt{(1-0.75)}\\sigma_0 = \\mu_0 + 0.5\\sigma_0 \\\\\n      \\mathcal{X}_2 = \\mu_0 - \\sqrt{(n+\\lambda)\\sigma_0^2} = \\mu_0 - 0.5\\sigma_0\n      \\end{align*}\n    - 计算相应的均值（$W_i^{(m)}$）和协方差（$W_i^{(c)}$）权重：\n      \\begin{align*}\n      W_0^{(m)} = \\frac{\\lambda}{n+\\lambda} = \\frac{-0.75}{1-0.75} = -3 \\\\\n      W_1^{(m)} = W_2^{(m)} = \\frac{1}{2(n+\\lambda)} = \\frac{1}{2(1-0.75)} = 2 \\\\\n      W_0^{(c)} = \\frac{\\lambda}{n+\\lambda} + (1 - \\alpha_{\\mathrm{UT}}^2 + \\beta_{\\mathrm{UT}}) = -3 + (1 - (0.5)^2 + 2) = -0.25 \\\\\n      W_1^{(c)} = W_2^{(c)} = \\frac{1}{2(n+\\lambda)} = 2\n      \\end{align*}\n\n3.  **传播 Sigma 点**：每个 sigma 点 $\\mathcal{X}_i$ 通过非线性函数 $f(\\cdot)$ 进行变换，得到一组变换后的点 $\\mathcal{Y}_i$：\n    $$\n    \\mathcal{Y}_i = f(\\mathcal{X}_i; I, \\Delta t, C_{\\mathrm{eff}}, \\gamma) \\quad \\text{for } i \\in \\{0, 1, 2\\}\n    $$\n\n4.  **计算传播后的均值和协方差**：通过对传播后的点进行加权求和，计算变换后变量（在添加过程噪声之前）的预测均值 $\\mu_{\\mathrm{UT}}$ 和协方差 $P_y$：\n    $$\n    \\mu_{\\mathrm{UT}} = \\sum_{i=0}^{2} W_i^{(m)} \\mathcal{Y}_i\n    $$\n    $$\n    P_y = \\sum_{i=0}^{2} W_i^{(c)} (\\mathcal{Y}_i - \\mu_{\\mathrm{UT}})^2\n    $$\n\n5.  **合并过程噪声**：通过将过程噪声方差 $q$ 加到传播后的协方差 $P_y$ 上，得到方差的最终估计值 $\\sigma_{\\mathrm{UT}}^2$。由于过程噪声的均值为零，均值不受影响。\n    $$\n    \\sigma_{\\mathrm{UT}}^2 = P_y + q\n    $$\n\n**实现与比较**\n\n程序将实现 UT 和 MC 两种方法。对于所提供的五个测试用例中的每一个，它将计算 $(\\mu_{\\mathrm{UT}}, \\sigma_{\\mathrm{UT}}^2)$ 和 $(\\mu_{\\mathrm{MC}}, \\sigma_{\\mathrm{MC}}^2)$。每个测试用例的最终输出包括两个值：均值的绝对差 $\\varepsilon_{\\mu} = |\\mu_{\\mathrm{UT}} - \\mu_{\\mathrm{MC}}|$ 和方差的绝对差 $\\varepsilon_{\\sigma^2} = |\\sigma_{\\mathrm{UT}}^2 - \\sigma_{\\mathrm{MC}}^2|$。这些值量化了无迹变换近似相对于计算密集型蒙特卡洛模拟的准确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the battery SOC estimation problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # (mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_MC)\n        (0.5, 0.01, 5.0, 0.0, 0.001, 1.0/60.0, 5.0, 50000),\n        (0.5, 0.05, 5.0, 2.0, 0.0015, 1.0/60.0, 5.0, 50000),\n        (0.95, 0.02, 10.0, 5.0, 0.002, 1.0/60.0, 5.0, 50000),\n        (0.05, 0.02, -3.0, 3.0, 0.001, 1.0/60.0, 5.0, 50000),\n        (0.5, 0.001, 5.0, 10.0, 0.001, 1.0/60.0, 5.0, 50000),\n    ]\n\n    results = []\n    \n    # Use a fixed seed for reproducibility of Monte Carlo simulations\n    rng = np.random.default_rng(seed=42)\n\n    for case in test_cases:\n        mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_mc = case\n        \n        # Run Monte Carlo simulation\n        mu_mc, var_mc = monte_carlo(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_mc, rng)\n        \n        # Run Unscented Transform\n        mu_ut, var_ut = unscented_transform(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff)\n        \n        # Calculate absolute differences\n        err_mu = abs(mu_ut - mu_mc)\n        err_var = abs(var_ut - var_mc)\n        \n        results.extend([err_mu, err_var])\n\n    # Format the output as a comma-separated string in brackets\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\ndef state_transition_func(x, I, delta_t, C_eff, gamma):\n    \"\"\"\n    The nonlinear state transition function f(x).\n    \"\"\"\n    term_I = (delta_t / C_eff) * I\n    non_linearity = 1.0 + gamma * (1.0 - 2.0 * x)**3\n    return x - term_I * non_linearity\n\ndef unscented_transform(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff):\n    \"\"\"\n    Approximates the mean and variance of the next state using the Unscented Transform.\n    \"\"\"\n    # State dimension\n    n = 1\n    \n    # UT scaling parameters\n    alpha_ut = 0.5\n    beta_ut = 2.0\n    kappa_ut = 0.0\n    \n    # Composite scaling parameter\n    lambda_ = alpha_ut**2 * (n + kappa_ut) - n\n    \n    # --- Step 1: Generate Sigma Points ---\n    var_0 = sigma_0**2\n    sigma_points = np.zeros(2 * n + 1)\n    sigma_points[0] = mu_0\n    \n    sqrt_term = np.sqrt((n + lambda_) * var_0)\n    sigma_points[1] = mu_0 + sqrt_term\n    sigma_points[2] = mu_0 - sqrt_term\n    \n    # --- Step 2: Calculate Weights ---\n    weights_m = np.zeros(2 * n + 1)\n    weights_c = np.zeros(2 * n + 1)\n    \n    weights_m[0] = lambda_ / (n + lambda_)\n    weights_c[0] = lambda_ / (n + lambda_) + (1 - alpha_ut**2 + beta_ut)\n    \n    for i in range(1, 2 * n + 1):\n        weights_m[i] = 1.0 / (2.0 * (n + lambda_))\n        weights_c[i] = 1.0 / (2.0 * (n + lambda_))\n        \n    # --- Step 3: Propagate Sigma Points ---\n    propagated_points = state_transition_func(sigma_points, I, delta_t, C_eff, gamma)\n    \n    # --- Step 4: Calculate Propagated Mean and Covariance ---\n    mu_ut = np.sum(weights_m * propagated_points)\n    \n    # Covariance before adding process noise\n    var_y = np.sum(weights_c * (propagated_points - mu_ut)**2)\n    \n    # --- Step 5: Add Process Noise ---\n    q = sigma_w**2\n    var_ut = var_y + q\n    \n    return mu_ut, var_ut\n\ndef monte_carlo(mu_0, sigma_0, I, gamma, sigma_w, delta_t, C_eff, N_mc, rng):\n    \"\"\"\n    Estimates the mean and variance of the next state using Monte Carlo simulation.\n    \"\"\"\n    # Generate initial state samples\n    x_k_samples = rng.normal(loc=mu_0, scale=sigma_0, size=N_mc)\n    \n    # Generate process noise samples\n    q = sigma_w**2\n    w_k_samples = rng.normal(loc=0.0, scale=np.sqrt(q), size=N_mc)\n    \n    # Propagate samples through the full state equation\n    x_k_plus_1_samples = state_transition_func(x_k_samples, I, delta_t, C_eff, gamma) + w_k_samples\n    \n    # Calculate empirical mean and variance\n    mu_mc = np.mean(x_k_plus_1_samples)\n    # Use ddof=1 for unbiased sample variance\n    var_mc = np.var(x_k_plus_1_samples, ddof=1)\n    \n    return mu_mc, var_mc\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在能源系统中，我们不仅需要估计不确定性，更要在不确定性下做出最优决策。本练习将带您探索两种主流的决策框架：鲁棒优化，旨在抵御最坏情况；以及随机规划，旨在优化期望性能。您将通过解决一个发电机调度问题，亲手实现这两种方法，并使用“鲁棒性代价”（Price of Robustness）等关键指标来量化比较它们在不同未来场景下的表现，从而掌握在不确定性下进行权衡决策的核心技能。",
            "id": "4128563",
            "problem": "考虑一个小型多周期能源系统，该系统拥有一个可控发电机和一个外部采购选项。时间被划分为 $T$ 个离散时期，索引为 $t \\in \\{1,2,3\\}$。时期 $t$ 的发电机调度（出力）为 $g_t \\in \\{0,1,2\\}$，以能量单位计量，并受初始条件 $g_0 = 0$ 和爬坡约束 $|g_t - g_{t-1}| \\le R$（其中 $R = 1$）的限制。假设每个时期的容量为 $2$ 个能量单位。在每个时期，随机需求为 $D_t \\ge 0$，已实现的需求向量为 $\\mathbf{D} = (D_1, D_2, D_3)$。在需求实现后，运营商可以按单位成本从外部来源采购 $s_t \\ge 0$。周期能量平衡为 $g_t + s_t \\ge D_t$，而过度生产（$g_t > D_t$）的部分将被无惩罚地弃用。每时期的发电成本为 $c \\cdot g_t$，单位外部采购成本为 $p$。对于一个调度方案 $\\mathbf{g} = (g_1,g_2,g_3)$ 和一个已实现的需求 $\\mathbf{D}$，其总成本为\n$$\nC(\\mathbf{g}, \\mathbf{D}) = \\sum_{t=1}^{3} \\left( c \\cdot g_t + p \\cdot s_t \\right),\n$$\n其中 $s_t$ 的选择是为了以最小成本满足能量平衡，即：\n$$\ns_t = \\max\\{0, D_t - g_t\\},\n$$\n因此\n$$\nC(\\mathbf{g}, \\mathbf{D}) = \\sum_{t=1}^{3} \\left( c \\cdot g_t + p \\cdot \\max\\{0, D_t - g_t\\} \\right).\n$$\n定义可行调度集\n$$\n\\mathcal{G} = \\left\\{ \\mathbf{g} \\in \\{0,1,2\\}^3 \\,:\\, |g_t - g_{t-1}| \\le 1 \\text{ for } t=1,2,3 \\text{ and } g_0 = 0 \\right\\}.\n$$\n在训练阶段考虑两种不确定性表示：一个不确定性集 $\\mathcal{U}_0$ 和一个概率分布 $P_0$。鲁棒训练问题是\n$$\n\\min_{\\mathbf{g} \\in \\mathcal{G}} \\; \\max_{\\mathbf{D} \\in \\mathcal{U}_0} \\; C(\\mathbf{g}, \\mathbf{D}),\n$$\n而随机训练问题是\n$$\n\\min_{\\mathbf{g} \\in \\mathcal{G}} \\; \\mathbb{E}_{P_0}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right].\n$$\n为了进行评估，真实分布为 $P^*$，它可能与 $P_0$ 不同。令 $\\mathbf{g}_R$ 和 $\\mathbf{g}_S$ 分别表示从鲁棒训练和随机训练中获得的最优调度方案。鲁棒性代价 (Price of Robustness, PoR) 定义为\n$$\n\\text{PoR} = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_R, \\mathbf{D}) \\right] - \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_S, \\mathbf{D}) \\right].\n$$\n在模型错误设定的情况下，一个调度方案 $\\mathbf{g}$ 的样本外遗憾值 (out-of-sample regret) 定义为\n$$\n\\text{Reg}(\\mathbf{g}) = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right] - \\min_{\\mathbf{h} \\in \\mathcal{G}} \\mathbb{E}_{P^*}\\left[ C(\\mathbf{h}, \\mathbf{D}) \\right].\n$$\n您必须为下述每个测试用例计算 $\\text{PoR}$、$\\text{Reg}(\\mathbf{g}_R)$ 和 $\\text{Reg}(\\mathbf{g}_S)$。所有成本必须以货币单位 (MU) 表示。\n\n假设 $\\mathcal{U}_0$ 是一个分量式箱型集合，其下界为 $\\mathbf{d}_{\\min} = (0,0,0)$，上界 $\\mathbf{d}_{\\max}$ 则针对每个测试用例提供。因为对于固定的 $\\mathbf{g}$，$C(\\mathbf{g}, \\mathbf{D})$ 在每个 $D_t$ 上是非递减的，所以鲁棒问题的内部最大化在 $\\mathbf{D} = \\mathbf{d}_{\\max}$ 处达到其最大值。\n\n测试套件（每个用例指定 $c$、$p$、$\\mathbf{d}_{\\max}$、$P_0$ 和 $P^*$）：\n- 用例 1：\n  - $c = 20$, $p = 100$, $\\mathbf{d}_{\\max} = (1,2,2)$。\n  - $P_0$: 情景 $\\mathbf{D}^{(1)} = (0,1,1)$ 概率为 $0.5$, 情景 $\\mathbf{D}^{(2)} = (1,2,1)$ 概率为 $0.3$, 情景 $\\mathbf{D}^{(3)} = (0,0,2)$ 概率为 $0.2$。\n  - $P^*$: 情景 $\\mathbf{D}^{A} = (1,2,2)$ 概率为 $0.4$, 情景 $\\mathbf{D}^{B} = (0,1,2)$ 概率为 $0.4$, 情景 $\\mathbf{D}^{C} = (2,2,2)$ 概率为 $0.2$。\n- 用例 2：\n  - $c = 40$, $p = 60$, $\\mathbf{d}_{\\max} = (1,1,1)$。\n  - $P_0$: 情景 $\\mathbf{D}^{(1)} = (0,1,0)$ 概率为 $0.6$, 情景 $\\mathbf{D}^{(2)} = (1,1,1)$ 概率为 $0.4$。\n  - $P^*$: 情景 $\\mathbf{D}^{A} = (1,2,1)$ 概率为 $0.5$, 情景 $\\mathbf{D}^{B} = (0,0,1)$ 概率为 $0.5$。\n- 用例 3：\n  - $c = 20$, $p = 100$, $\\mathbf{d}_{\\max} = (0,0,0)$。\n  - $P_0$: 情景 $\\mathbf{D} = (0,0,0)$ 概率为 $1.0$。\n  - $P^*$: 情景 $\\mathbf{D} = (2,2,2)$ 概率为 $1.0$。\n\n您的程序必须：\n- 枚举 $\\mathcal{G}$，并遵守 $g_0 = 0$、$g_t \\in \\{0,1,2\\}$ 和 $|g_t - g_{t-1}| \\le 1$。\n- 求解鲁棒和随机训练问题以获得 $\\mathbf{g}_R$ 和 $\\mathbf{g}_S$。\n- 在 $P^*$ 下计算 $\\text{PoR}$、$\\text{Reg}(\\mathbf{g}_R)$ 和 $\\text{Reg}(\\mathbf{g}_S)$。\n- 生成单行输出，包含结果，格式为以逗号分隔的各测试用例三元组列表，每个三元组为 $[\\text{PoR}, \\text{Reg}_R, \\text{Reg}_S]$，四舍五入到两位小数，全部以货币单位 (MU) 表示，并用方括号括起来；即：\n$$\n\\left[ [\\text{PoR}_1,\\text{Reg}_R^{(1)},\\text{Reg}_S^{(1)}], [\\text{PoR}_2,\\text{Reg}_R^{(2)},\\text{Reg}_S^{(2)}], [\\text{PoR}_3,\\text{Reg}_R^{(3)},\\text{Reg}_S^{(3)}] \\right].\n$$\n角度单位不适用。不使用百分比。所有输出必须是货币单位 (MU) 的数值浮点数。",
            "solution": "用户在能源系统建模领域内提供了一个定义明确的优化问题，重点是在模型错误设定的情况下比较鲁棒优化和随机优化技术。该问题具有科学依据、数学上一致，并且所有必要的数据均已提供。由于决策空间的规模小且离散，计算求解是可行的。\n\n问题的核心是找到最优的发电机调度方案 $\\mathbf{g} = (g_1, g_2, g_3)$ 并评估其性能。求解过程按方法论步骤如下：\n\n首先，我们必须明确定义所有可行调度方案的集合 $\\mathcal{G}$。一个调度方案 $\\mathbf{g} = (g_1, g_2, g_3)$ 如果遵守给定的约束条件，则是可行的：\n1.  每周期发电量 $g_t$ 必须是来自 $\\{0, 1, 2\\}$ 的整数。\n2.  初始状态固定为 $g_0 = 0$。\n3.  对于 $t \\in \\{1, 2, 3\\}$，必须满足爬坡约束 $|g_t - g_{t-1}| \\le 1$。\n\n通过系统地枚举从 $g_0=0$ 出发并满足这些约束的所有路径，我们可以构建有限集 $\\mathcal{G}$。推导过程如下：\n- 对于 $t=1$，给定 $g_0=0$，爬坡约束允许 $g_1 \\in \\{0, 1\\}$。\n- 对于 $t=2$，如果 $g_1=0$，则 $g_2 \\in \\{0, 1\\}$。如果 $g_1=1$，则 $g_2 \\in \\{0, 1, 2\\}$。\n- 对于 $t=3$，$g_3$ 的可能值取决于 $g_2$。如果 $g_2=0$，$g_3 \\in \\{0, 1\\}$。如果 $g_2=1$，$g_3 \\in \\{0, 1, 2\\}$。如果 $g_2=2$，$g_3 \\in \\{1, 2\\}$。\n这种构造性枚举在 $\\mathcal{G}$ 中总共产生 12 个唯一的可行调度方案。由于这个集合很小，我们可以通过穷举搜索来解决优化问题。\n\n对于给定的调度方案 $\\mathbf{g}$ 和已实现的需求向量 $\\mathbf{D}=(D_1, D_2, D_3)$，总成本由以下函数给出：\n$$\nC(\\mathbf{g}, \\mathbf{D}) = \\sum_{t=1}^{3} \\left( c \\cdot g_t + p \\cdot \\max\\{0, D_t - g_t\\} \\right)\n$$\n其中 $c$ 是单位发电成本，$p$ 是单位外部采购成本。\n\n对于每个测试用例，我们按以下步骤进行：\n\n1.  **求解鲁棒训练问题**：我们找到鲁棒最优调度方案 $\\mathbf{g}_R$。该调度方案在不确定性集 $\\mathcal{U}_0$ 上最小化最坏情况下的成本。如前所述，成本函数 $C(\\mathbf{g}, \\mathbf{D})$ 在 $\\mathbf{D}$ 的每个分量上是非递减的，因此最坏情况下的需求是 $\\mathbf{d}_{\\max}$。因此，问题变为：\n    $$\n    \\mathbf{g}_R \\in \\arg\\min_{\\mathbf{g} \\in \\mathcal{G}} C(\\mathbf{g}, \\mathbf{d}_{\\max})\n    $$\n    我们为每个 $\\mathbf{g} \\in \\mathcal{G}$ 计算 $C(\\mathbf{g}, \\mathbf{d}_{\\max})$，并找出一个实现最小成本的调度方案。\n\n2.  **求解随机训练问题**：我们找到随机最优调度方案 $\\mathbf{g}_S$。该调度方案在训练概率分布 $P_0$ 下最小化期望成本。对于具有情景 $\\mathbf{D}^{(i)}$ 和相关概率 $\\pi_i$ 的离散分布 $P_0$，问题是：\n    $$\n    \\mathbf{g}_S \\in \\arg\\min_{\\mathbf{g} \\in \\mathcal{G}} \\mathbb{E}_{P_0}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right] = \\arg\\min_{\\mathbf{g} \\in \\mathcal{G}} \\sum_{i} \\pi_i C(\\mathbf{g}, \\mathbf{D}^{(i)})\n    $$\n    我们为每个 $\\mathbf{g} \\in \\mathcal{G}$ 计算此期望成本，并找到一个最小化该成本的调度方案。\n\n3.  **执行样本外评估**：所有调度方案（包括 $\\mathbf{g}_R$ 和 $\\mathbf{g}_S$）的性能都在真实概率分布 $P^*$ 下进行评估。我们在 $P^*$ 下为每个调度方案 $\\mathbf{g} \\in \\mathcal{G}$ 计算期望成本：\n    $$\n    \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}, \\mathbf{D}) \\right] = \\sum_{j} \\pi_j^* C(\\mathbf{g}, \\mathbf{D}^{(j)})\n    $$\n    其中 $\\mathbf{D}^{(j)}$ 是情景，$\\pi_j^*$ 是来自 $P^*$ 的概率。通过这些计算，我们确定了真实的最小期望成本，即‘先知’最优解：\n    $$\n    C^*_{P^*} = \\min_{\\mathbf{h} \\in \\mathcal{G}} \\mathbb{E}_{P^*}\\left[ C(\\mathbf{h}, \\mathbf{D}) \\right]\n    $$\n\n4.  **计算性能指标**：使用前面步骤的结果，我们为每个测试用例计算所需的指标：\n    -   **鲁棒性代价 (PoR)**：鲁棒解和随机解之间样本外性能的差异。\n        $$\n        \\text{PoR} = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_R, \\mathbf{D}) \\right] - \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_S, \\mathbf{D}) \\right]\n        $$\n    -   **$\\mathbf{g}_R$ 的样本外遗憾值**：鲁棒解与真实最优解相比的性能损失。\n        $$\n        \\text{Reg}(\\mathbf{g}_R) = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_R, \\mathbf{D}) \\right] - C^*_{P^*}\n        $$\n    -   **$\\mathbf{g}_S$ 的样本外遗憾值**：随机解与真实最优解相比的性能损失。\n        $$\n        \\text{Reg}(\\mathbf{g}_S) = \\mathbb{E}_{P^*}\\left[ C(\\mathbf{g}_S, \\mathbf{D}) \\right] - C^*_{P^*}\n        $$\n在多个调度方案为鲁棒或随机问题产生相同最小成本的情况下，使用确定性的平局打破规则（例如，选择在枚举列表中遇到的第一个）来确保结果的唯一性。整个过程在一个单独的程序中实现，该程序遍历所提供的测试用例并按规定格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the energy system optimization problem for all test cases.\n    \"\"\"\n\n    def generate_schedules():\n        \"\"\"\n        Enumerates the set of all feasible generation schedules G.\n        A schedule g = (g1, g2, g3) is feasible if:\n        1. g_t is in {0, 1, 2}.\n        2. g_0 = 0.\n        3. |g_t - g_{t-1}| = 1.\n        \"\"\"\n        schedules = []\n        g0 = 0\n        # Time t=1\n        for g1 in range(max(0, g0 - 1), min(2, g0 + 1) + 1):\n            # Time t=2\n            for g2 in range(max(0, g1 - 1), min(2, g1 + 1) + 1):\n                # Time t=3\n                for g3 in range(max(0, g2 - 1), min(2, g2 + 1) + 1):\n                    schedules.append(np.array([g1, g2, g3], dtype=int))\n        return schedules\n\n    def calculate_cost(g, D, c, p):\n        \"\"\"\n        Calculates the total cost C(g, D) for a given schedule and demand.\n        C(g, D) = sum(c*g_t + p*max(0, D_t - g_t)) for t=1,2,3.\n        \"\"\"\n        generation_cost = c * np.sum(g)\n        procurement_cost = p * np.sum(np.maximum(0, D - g))\n        return generation_cost + procurement_cost\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"c\": 20, \"p\": 100, \"d_max\": np.array([1, 2, 2]),\n            \"P0\": {\"scenarios\": [np.array([0, 1, 1]), np.array([1, 2, 1]), np.array([0, 0, 2])], \"probs\": [0.5, 0.3, 0.2]},\n            \"P_star\": {\"scenarios\": [np.array([1, 2, 2]), np.array([0, 1, 2]), np.array([2, 2, 2])], \"probs\": [0.4, 0.4, 0.2]}\n        },\n        {\n            \"c\": 40, \"p\": 60, \"d_max\": np.array([1, 1, 1]),\n            \"P0\": {\"scenarios\": [np.array([0, 1, 0]), np.array([1, 1, 1])], \"probs\": [0.6, 0.4]},\n            \"P_star\": {\"scenarios\": [np.array([1, 2, 1]), np.array([0, 0, 1])], \"probs\": [0.5, 0.5]}\n        },\n        {\n            \"c\": 20, \"p\": 100, \"d_max\": np.array([0, 0, 0]),\n            \"P0\": {\"scenarios\": [np.array([0, 0, 0])], \"probs\": [1.0]},\n            \"P_star\": {\"scenarios\": [np.array([2, 2, 2])], \"probs\": [1.0]}\n        }\n    ]\n\n    schedules = generate_schedules()\n    final_results = []\n\n    for case in test_cases:\n        c, p, d_max = case[\"c\"], case[\"p\"], case[\"d_max\"]\n        P0 = case[\"P0\"]\n        P_star = case[\"P_star\"]\n\n        # 1. Find g_R (Robust solution) by minimizing worst-case cost\n        robust_costs = [calculate_cost(g, d_max, c, p) for g in schedules]\n        min_robust_cost = min(robust_costs)\n        # Deterministic tie-breaking by taking the first occurrence\n        idx_gR = robust_costs.index(min_robust_cost)\n        \n        # 2. Find g_S (Stochastic solution) by minimizing expected cost under P0\n        stochastic_costs_p0 = []\n        for g in schedules:\n            expected_cost = sum(prob * calculate_cost(g, D, c, p) for D, prob in zip(P0[\"scenarios\"], P0[\"probs\"]))\n            stochastic_costs_p0.append(expected_cost)\n        min_stochastic_cost_p0 = min(stochastic_costs_p0)\n        idx_gS = stochastic_costs_p0.index(min_stochastic_cost_p0)\n        \n        # 3. Evaluate all schedules under P_star to find true performance and true optimum\n        true_expected_costs = []\n        for g in schedules:\n            expected_cost = sum(prob * calculate_cost(g, D, c, p) for D, prob in zip(P_star[\"scenarios\"], P_star[\"probs\"]))\n            true_expected_costs.append(expected_cost)\n            \n        min_true_cost = min(true_expected_costs)\n        \n        # Performance of g_R and g_S under P_star\n        exp_cost_gR_pstar = true_expected_costs[idx_gR]\n        exp_cost_gS_pstar = true_expected_costs[idx_gS]\n\n        # 4. Calculate metrics\n        PoR = exp_cost_gR_pstar - exp_cost_gS_pstar\n        Reg_R = exp_cost_gR_pstar - min_true_cost\n        Reg_S = exp_cost_gS_pstar - min_true_cost\n        \n        # Format results for this case\n        case_result_str = f\"[{PoR:.2f},{Reg_R:.2f},{Reg_S:.2f}]\"\n        final_results.append(case_result_str)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了应对外部不确定性，我们还能主动设计实验来减少模型本身的不确定性。本练习将您置于系统辨识的前沿，任务是设计一个最优的输入电流序列，以最大限度地降低电池模型的参数估计误差。您将学习如何使用费雪信息矩阵（Fisher Information Matrix）来量化输入信号的信息含量，并以此为依据选择能够最有效激发系统动态、从而最快揭示其内部参数的“最优实验”。",
            "id": "4128477",
            "problem": "你的任务是为单个电阻-电容电池等效电路模型设计一个输入电流序列，以在观察电压响应后最小化其参数的不确定性，同时满足幅度和能量约束。核心建模假设和推導必须从以下基本基础出发：小信号的线性系统动力学、高斯测量噪声以及使用线性化灵敏度的贝叶斯估计。\n\n考虑一个带有一个电阻和一个电容的戴维南模型。设输入为电流序列 $\\{i_k\\}_{k=0}^{N-1}$，采样周期为 $dt$，样本之间为零阶保持。内部状态 $v_{1,k}$ 根据从连续时间一阶线性系统 $dv_1/dt = -(1/(R_1 C_1)) v_1 + (1/C_1) i(t)$ 推导出的离散时间动力学演化：\n$$\nv_{1,k+1} = a(\\boldsymbol{\\theta})\\, v_{1,k} + b(\\boldsymbol{\\theta})\\, i_k,\n$$\n其中 $\\boldsymbol{\\theta} = [R_0, R_1, C_1]^\\top$， $a(\\boldsymbol{\\theta}) = \\exp\\!\\left(-\\dfrac{dt}{R_1 C_1}\\right)$，以及 $b(\\boldsymbol{\\theta}) = R_1 \\left(1 - a(\\boldsymbol{\\theta})\\right)$。测量到的端电压（相对于开路电压）为\n$$\ny_k = - R_0\\, i_k - v_{1,k} + \\varepsilon_k,\n$$\n其中测量噪声 $\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma^2)$ 是独立同分布的高斯噪声。\n\n对于不确定性下的实验设计，使用归一化的无量纲参数 $\\boldsymbol{\\phi} = \\boldsymbol{\\theta} \\oslash \\boldsymbol{\\theta}_0$ 进行计算，其中 $\\boldsymbol{\\theta}_0$ 是标称参数向量，$\\oslash$ 表示逐元素除法。假设 $\\boldsymbol{\\phi}$ 服从高斯先验分布 $\\boldsymbol{\\phi} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\mathbf{C}_{\\text{prior}})$，其协方差矩阵为对角阵 $\\mathbf{C}_{\\text{prior}} = \\operatorname{diag}(\\sigma_{\\phi,0}^2, \\sigma_{\\phi,1}^2, \\sigma_{\\phi,2}^2)$。\n\n在测量模型围绕 $\\boldsymbol{\\theta}_0$ 进行一阶线性化的情况下，对于归一化参数和输入 $\\{i_k\\}$ 的费雪信息矩阵为\n$$\n\\mathbf{F} = \\frac{1}{\\sigma^2}\\, \\mathbf{J}_\\phi^\\top \\mathbf{J}_\\phi,\n$$\n其中 $\\mathbf{J}_\\phi \\in \\mathbb{R}^{N \\times 3}$ 是无噪声输出序列 $\\mathbf{y}(\\boldsymbol{\\theta}, \\{i_k\\})$ 相对于 $\\boldsymbol{\\phi}$ 的雅可比矩阵，在 $\\boldsymbol{\\theta}_0$ 处求值。在线性高斯近似下的后验协方差为\n$$\n\\mathbf{C}_{\\text{post}} = \\left(\\mathbf{C}_{\\text{prior}}^{-1} + \\mathbf{F}\\right)^{-1}.\n$$\n你的设计目标是最小化标量泛函\n$$\nJ(\\{i_k\\}) = \\operatorname{tr}\\!\\left(\\mathbf{C}_{\\text{post}}\\right),\n$$\n该泛函是无量纲的，因为它针对归一化参数 $\\boldsymbol{\\phi}$ 定义。\n\n输入电流序列必须满足以下约束：\n- 幅度限制：对所有 $k$，$\\lvert i_k \\rvert \\leq u_{\\max}$。\n- 能量限制：$\\sum_{k=0}^{N-1} i_k^2\\, dt \\leq E_{\\max}$。\n所有电流单位为安培 ($\\mathrm{A}$)，时间为秒 ($\\mathrm{s}$)，电阻为欧姆 ($\\Omega$)，电容为法拉 ($\\mathrm{F}$)，电压为伏特 ($\\mathrm{V}$)。输出目标 $J(\\{i_k\\})$ 是无量纲的。\n\n为使问题可通过算法测试，你的程序必须评估一组固定的候选输入序列族（定义为单位幅度模板，后续将进行缩放以同时满足两个约束），选择最小化 $J(\\{i_k\\})$ 的那一个，并报告结果。候选模板由索引 $c \\in \\{0,1,2,3,4,5,6,7,8\\}$ 标识，具体如下：\n- $c=0$：零序列, $i_k = 0$。\n- $c=1$：中途符号反转的阶跃序列, $i_k = 1$ 当 $k  N/2$，以及 $i_k = -1$ 当 $k \\ge N/2$。\n- $c=2$：在整个时间范围内有 $1$ 个周期的单正弦波, $i_k = \\sin\\!\\left(2\\pi \\frac{1}{N} k\\right)$。\n- $c=3$：有 $3$ 个周期的正弦波, $i_k = \\sin\\!\\left(2\\pi \\frac{3}{N} k\\right)$。\n- $c=4$：有 $10$ 个周期的正弦波, $i_k = \\sin\\!\\left(2\\pi \\frac{10}{N} k\\right)$。\n- $c=5$：伪随机二进制序列（使用固定种子以确保确定性）, $i_k \\in \\{-1, +1\\}$。\n- $c=6$：白噪声序列（使用固定种子以确保确定性）, $i_k$ 从标准正态模板中独立同分布采样。\n- $c=7$：脉冲对, 在 $k^+ = \\lfloor N/4 \\rfloor$ 处 $i_{k^+} = +1$，在 $k^- = \\lfloor 3N/4 \\rfloor$ 处 $i_{k^-} = -1$，其他情况 $i_k = 0$。\n- $c=8$：双正弦波组合, $i_k = \\sin\\!\\left(2\\pi \\frac{1}{N} k\\right) + \\sin\\!\\left(2\\pi \\frac{3}{N} k\\right)$。\n\n对于每个候选模板，通过一个因子 $s$ 进行缩放，该因子需满足两个约束：\n$$\ns \\le u_{\\max}, \\quad s \\le \\sqrt{\\frac{E_{\\max}}{dt \\sum_{k=0}^{N-1} i_k^{(\\text{template})\\,2}}}.\n$$\n使用 $s = \\min\\left(u_{\\max}, \\sqrt{\\frac{E_{\\max}}{dt \\sum i_k^{(\\text{template})\\,2}}}\\right)$，并将实现的输入序列定义为 $i_k^{(\\text{realized})} = s\\, i_k^{(\\text{template})}$。\n\n通过无噪声输出序列相对于 $\\boldsymbol{\\theta}_0$ 处 $\\boldsymbol{\\theta}$ 的每个参数分量的有限差分来计算 $\\mathbf{J}_\\phi$，然后通过将每列乘以相应的标称参数分量来转换为归一化参数。具体来说，对于第 $p$ 个分量的一个小扰动 $\\delta\\theta_p$，\n$$\n\\left[\\mathbf{J}_\\theta\\right]_{:,p} \\approx \\frac{\\mathbf{y}(\\boldsymbol{\\theta}_0 + \\delta\\theta_p\\, \\mathbf{e}_p, \\{i_k\\}) - \\mathbf{y}(\\boldsymbol{\\theta}_0, \\{i_k\\})}{\\delta\\theta_p},\n\\quad\n\\left[\\mathbf{J}_\\phi\\right]_{:,p} = \\theta_{0,p}\\, \\left[\\mathbf{J}_\\theta\\right]_{:,p}.\n$$\n\n测试套件。使用以下三种情况，每种情况都以元组 $(N, dt, \\boldsymbol{\\theta}_0, \\boldsymbol{\\sigma}_\\phi, \\sigma, u_{\\max}, E_{\\max})$ 的形式提供：\n- 情况 A (正常路径): $N = 60$, $dt = 1$, $\\boldsymbol{\\theta}_0 = [0.02, 0.05, 2000]$, $\\boldsymbol{\\sigma}_\\phi = [0.5, 0.5, 0.5]$, $\\sigma = 0.01$, $u_{\\max} = 5$, $E_{\\max} = 600$。\n- 情况 B (低能量): $N = 60$, $dt = 1$, $\\boldsymbol{\\theta}_0 = [0.02, 0.05, 2000]$, $\\boldsymbol{\\sigma}_\\phi = [0.5, 0.5, 0.5]$, $\\sigma = 0.01$, $u_{\\max} = 5$, $E_{\\max} = 10$。\n- 情况 C (幅度受限): $N = 60$, $dt = 1$, $\\boldsymbol{\\theta}_0 = [0.02, 0.05, 2000]$, $\\boldsymbol{\\sigma}_\\phi = [0.5, 0.5, 0.5]$, $\\sigma = 0.01$, $u_{\\max} = 0.5$, $E_{\\max} = 600$。\n\n输出规范。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出三元组 $[c^\\star, J^\\star, E_{\\text{used}}]$，其中 $c^\\star$ 是最佳候选模板的整数索引，$J^\\star$ 是最小化的无量纲目标值，而 $E_{\\text{used}} = dt \\sum_k (i_k^{(\\text{realized})})^2$ 是以 $\\mathrm{A}^2\\cdot\\mathrm{s}$ 为单位的已实现输入能量，表示为一个不带单位符号的小数。整体输出应该是这三个三元组按测试套件案例顺序排列的列表，例如 $[[c_1,J_1,E_1],[c_2,J_2,E_2],[c_3,J_3,E_3]]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于电气电路理论和系统辨識的既定原则，在数学上是适定的，并使用客观、形式化的语言进行定义。所有必要的数据和约束都已提供，以得出一个唯一的、可计算的解。\n\n该问题要求我们从一组给定的候选序列中，为单个电阻-电容（RC）电池模型找到最优的输入电流序列 $\\{i_k\\}_{k=0}^{N-1}$。最优性准则是最小化模型归一化参数的后验协方差矩阵的迹，该迹是实验后参数不确定性的度量。这是一个经典的 A-最优实验设计问题。\n\n该模型是一个戴维南等效电路，参数为 $\\boldsymbol{\\theta} = [R_0, R_1, C_1]^\\top$。系统动力学以离散时间形式给出：\n$$\nv_{1,k+1} = a(\\boldsymbol{\\theta})\\, v_{1,k} + b(\\boldsymbol{\\theta})\\, i_k\n$$\n$$\ny_k = - R_0\\, i_k - v_{1,k}\n$$\n其中 $v_{1,k}$ 是 RC 对两端的电压，$y_k$ 是相对于开路电压的无噪声端电压测量值，系数是参数的函数：\n$$\na(\\boldsymbol{\\theta}) = \\exp\\left(-\\frac{dt}{R_1 C_1}\\right)\n$$\n$$\nb(\\boldsymbol{\\theta}) = R_1 \\left(1 - a(\\boldsymbol{\\theta})\\right)\n$$\n我们假设初始条件为 $v_{1,0} = 0$，表示系统处于静止状态。\n\n目标是最小化 $J(\\{i_k\\}) = \\operatorname{tr}(\\mathbf{C}_{\\text{post}})$，其中归一化参数 $\\boldsymbol{\\phi} = \\boldsymbol{\\theta} \\oslash \\boldsymbol{\\theta}_0$ 的后验协方差矩阵由线性高斯近似下的贝叶斯更新公式给出：\n$$\n\\mathbf{C}_{\\text{post}} = \\left(\\mathbf{C}_{\\text{prior}}^{-1} + \\mathbf{F}\\right)^{-1}\n$$\n先验协方差 $\\mathbf{C}_{\\text{prior}}$ 是对角矩阵，其对角线元素为 $\\sigma_{\\phi,p}^2$。费雪信息矩阵（FIM）$\\mathbf{F}$ 为：\n$$\n\\mathbf{F} = \\frac{1}{\\sigma^2}\\, \\mathbf{J}_\\phi^\\top \\mathbf{J}_\\phi\n$$\n此处，$\\mathbf{J}_\\phi \\in \\mathbb{R}^{N \\times 3}$ 是输出序列 $\\mathbf{y} = [y_0, \\dots, y_{N-1}]^\\top$ 相对于归一化参数 $\\boldsymbol{\\phi}$ 的灵敏度雅可比矩阵，在标称参数值 $\\boldsymbol{\\theta}_0$ 处求值。\n\n解决每个测试用例问题的算法流程如下：\n\n1.  **遍历候选序列**：对于每个候选模板 $c \\in \\{0, 1, \\dots, 8\\}$，生成并评估一个输入电流序列 $\\{i_k\\}$。\n\n2.  **生成并缩放输入序列**：\n    a.  根据候选 $c$ 的定义生成原始模板序列 $\\{i_k^{(\\text{raw})}\\}$。对于伪随机序列（$c=5, 6$），使用固定的随机种子以确保结果的确定性和可复现性。\n    b.  问题中提到“单位幅度模板”。为确保此属性并保持所有候选模板的一致性，每个原始模板都通过其最大绝对值进行归一化。设 $M = \\max_k |i_k^{(\\text{raw})}|$。单位幅度模板为 $\\{i_k^{(\\text{template})}\\} = \\{i_k^{(\\text{raw})} / M\\}$（如果 $M0$），否则为 $\\{0\\}$。\n    c.  计算缩放因子 $s$，以确保最终序列同时遵守幅度约束（$|i_k| \\le u_{\\max}$）和能量约束（$\\sum_{k=0}^{N-1} i_k^2\\, dt \\le E_{\\max}$）。对于单位幅度模板，有 $|i_k^{(\\text{template})}| \\le 1$，因此幅度约束变为 $s \\le u_{\\max}$。能量约束导致 $s \\le \\sqrt{E_{\\max} / (dt \\sum_k (i_k^{(\\text{template})})^2)}$。最大化利用允许输入范围的最优缩放因子是：\n        $$\n        s = \\min\\left(u_{\\max}, \\sqrt{\\frac{E_{\\max}}{dt \\sum_{k=0}^{N-1} (i_k^{(\\text{template})})^2}}\\right)\n        $$\n        对全零模板（例如 $c=0$）的特殊情况进行处理以避免除以零，此时 $s$ 实际上为 $0$。\n    d.  那么实现的输入序列为 $\\{i_k^{(\\text{realized})}\\} = s \\cdot \\{i_k^{(\\text{template})}\\}$。\n\n3.  **计算雅可比矩阵 $\\mathbf{J}_\\phi$**：\n    a.  输出 $\\mathbf{y}$ 相对于物理参数 $\\boldsymbol{\\theta}$ 的雅可比矩阵通过围绕标称值 $\\boldsymbol{\\theta}_0$ 的数值前向差分计算。对于每个参数 $\\theta_p \\in \\{R_0, R_1, C_1\\}$，引入一个小的扰动 $\\delta\\theta_p$。一个稳健的扰动大小选择是 $\\delta\\theta_p = \\theta_{0,p} \\sqrt{\\epsilon_{\\text{machine}}}$，其中 $\\epsilon_{\\text{machine}}$ 是浮点数的机器精度。\n    b.  雅可比矩阵 $\\mathbf{J}_\\theta$ 的第 $p$ 列近似为：\n        $$\n        [\\mathbf{J}_\\theta]_{:,p} \\approx \\frac{\\mathbf{y}(\\boldsymbol{\\theta}_0 + \\delta\\theta_p \\mathbf{e}_p, \\{i_k^{(\\text{realized})}\\}) - \\mathbf{y}(\\boldsymbol{\\theta}_0, \\{i_k^{(\\text{realized})}\\})}{\\delta\\theta_p}\n        $$\n        其中 $\\mathbf{y}(\\cdot)$ 是仿真的无噪声输出序列。\n    c.  使用链式法则，通过缩放 $\\mathbf{J}_\\theta$ 的每一列来获得相对于归一化参数 $\\boldsymbol{\\phi}$ 的雅可比矩阵：\n        $$\n        [\\mathbf{J}_\\phi]_{:,p} = \\theta_{0,p} [\\mathbf{J}_\\theta]_{:,p}\n        $$\n\n4.  **评估目标函数 $J$**：\n    a.  计算对角先验协方差矩阵的逆：$\\mathbf{C}_{\\text{prior}}^{-1} = \\operatorname{diag}(1/\\sigma_{\\phi,0}^2, 1/\\sigma_{\\phi,1}^2, 1/\\sigma_{\\phi,2}^2)$。\n    b.  计算 FIM: $\\mathbf{F} = (1/\\sigma^2) \\mathbf{J}_\\phi^\\top \\mathbf{J}_\\phi$。\n    c.  通过矩阵求逆找到后验协方差：$\\mathbf{C}_{\\text{post}} = (\\mathbf{C}_{\\text{prior}}^{-1} + \\mathbf{F})^{-1}$。\n    d.  目标函数的值是该矩阵的迹：$J = \\operatorname{tr}(\\mathbf{C}_{\\text{post}})$。对于零输入情况（$c=0$），$\\mathbf{J}_\\phi$ 是一个零矩阵，因此 $\\mathbf{F}=\\mathbf{0}$，$\\mathbf{C}_{\\text{post}} = \\mathbf{C}_{\\text{prior}}$，且 $J = \\operatorname{tr}(\\mathbf{C}_{\\text{prior}})$。\n\n5.  **选择最优值**：\n    对所有候选模板重复此过程。选择产生最小目标值 $J^\\star$ 的候选索引 $c^\\star$ 作为最优选择。同时记录此最优序列使用的能量 $E_{\\text{used}} = dt \\sum_k (i_{k,\\text{opt}}^{(\\text{realized})})^2$。\n\n将此过程应用于所提供的三个测试用例中的每一个。最终输出是一个列表，其中包含每个案例的三元组 $[c^\\star, J^\\star, E_{\\text{used}}]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the optimal experiment design problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case A: Happy path\n        (60, 1.0, np.array([0.02, 0.05, 2000.0]), np.array([0.5, 0.5, 0.5]), 0.01, 5.0, 600.0),\n        # Case B: Low energy\n        (60, 1.0, np.array([0.02, 0.05, 2000.0]), np.array([0.5, 0.5, 0.5]), 0.01, 5.0, 10.0),\n        # Case C: Amplitude-limited\n        (60, 1.0, np.array([0.02, 0.05, 2000.0]), np.array([0.5, 0.5, 0.5]), 0.01, 0.5, 600.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, dt, theta0, sigma_phi, sigma, u_max, E_max = case\n        \n        # Reset the seed for each test case to ensure independence\n        np.random.seed(0)\n\n        best_J = float('inf')\n        best_c = -1\n        best_E_used = -1\n\n        for c in range(9):\n            # 1. Generate Raw Template\n            i_raw = generate_template(c, N)\n\n            # 2. Normalize to a unit-amplitude template\n            max_abs_raw = np.max(np.abs(i_raw))\n            if max_abs_raw > 0:\n                i_template = i_raw / max_abs_raw\n            else:\n                i_template = i_raw  # Already all zeros\n\n            # 3. Calculate scaling factor s and realized input\n            template_energy_sum_sq = np.sum(i_template**2)\n            if template_energy_sum_sq == 0:\n                s = 0.0\n            else:\n                s_energy = np.sqrt(E_max / (dt * template_energy_sum_sq))\n                s = min(u_max, s_energy)\n            \n            i_realized = s * i_template\n\n            # 4. Calculate objective function J\n            current_J = calculate_objective(i_realized, N, dt, theta0, sigma_phi, sigma)\n\n            # 5. Update best result\n            if current_J  best_J:\n                best_J = current_J\n                best_c = c\n                best_E_used = dt * np.sum(i_realized**2)\n        \n        results.append([best_c, best_J, best_E_used])\n\n    # Format the output as a string representation of a list of lists.\n    # The problem asks for a very specific representation.\n    # We build it manually to ensure correctness.\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        c_star, J_star, E_used = res\n        output_str += f\"[{c_star},{J_star:.7f},{E_used:.7f}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\n\ndef generate_template(c, N):\n    \"\"\"Generates the raw input current template for a given candidate index c.\"\"\"\n    k = np.arange(N)\n    if c == 0:\n        return np.zeros(N)\n    elif c == 1:\n        i = np.ones(N)\n        i[N//2:] = -1.0\n        return i\n    elif c == 2:\n        return np.sin(2 * np.pi * 1 * k / N)\n    elif c == 3:\n        return np.sin(2 * np.pi * 3 * k / N)\n    elif c == 4:\n        return np.sin(2 * np.pi * 10 * k / N)\n    elif c == 5:\n        # PRBS needs a fixed seed, handled in the main loop\n        return 2 * np.random.randint(0, 2, size=N) - 1\n    elif c == 6:\n        # White noise needs a fixed seed, handled in the main loop\n        return np.random.randn(N)\n    elif c == 7:\n        i = np.zeros(N)\n        k_plus = int(np.floor(N / 4))\n        k_minus = int(np.floor(3 * N / 4))\n        i[k_plus] = 1.0\n        i[k_minus] = -1.0\n        return i\n    elif c == 8:\n        return np.sin(2 * np.pi * 1 * k / N) + np.sin(2 * np.pi * 3 * k / N)\n    else:\n        raise ValueError(\"Invalid candidate index\")\n\n\ndef simulate_model(i_seq, theta, N, dt):\n    \"\"\"Simulates the noiseless voltage output of the battery model.\"\"\"\n    R0, R1, C1 = theta\n    \n    if R1 == 0 or C1 == 0:\n        return np.full(N, np.nan)\n        \n    a = np.exp(-dt / (R1 * C1))\n    b = R1 * (1 - a)\n    \n    v1 = np.zeros(N)\n    # The loop runs up to N-2, calculating v1[1] to v1[N-1]\n    for k in range(N - 1):\n        v1[k + 1] = a * v1[k] + b * i_seq[k]\n        \n    y = -R0 * i_seq - v1\n    return y\n\n\ndef calculate_objective(i_seq, N, dt, theta0, sigma_phi, sigma):\n    \"\"\"Calculates the objective function J = tr(C_post).\"\"\"\n    \n    num_params = len(theta0)\n    \n    # Handle the zero-input case, which gives no information\n    if np.all(i_seq == 0):\n        C_prior = np.diag(sigma_phi**2)\n        return np.trace(C_prior)\n\n    # Calculate Jacobian J_phi\n    J_phi = np.zeros((N, num_params))\n    y_nominal = simulate_model(i_seq, theta0, N, dt)\n    \n    # Machine epsilon for finite difference perturbation\n    eps = np.finfo(float).eps\n\n    for p in range(num_params):\n        theta_p = theta0.copy()\n        delta = theta_p[p] * np.sqrt(eps)\n        if delta == 0: # Handle cases where theta0 component is 0\n            delta = np.sqrt(eps)\n        theta_p[p] += delta\n        \n        y_perturbed = simulate_model(i_seq, theta_p, N, dt)\n        \n        J_theta_col_p = (y_perturbed - y_nominal) / delta\n        J_phi[:, p] = J_theta_col_p * theta0[p]\n\n    # Calculate Fisher Information Matrix (FIM)\n    F = (1 / sigma**2) * (J_phi.T @ J_phi)\n    \n    # Calculate Posterior Covariance\n    C_prior_inv = np.diag(1.0 / sigma_phi**2)\n    C_post_inv = C_prior_inv + F\n    \n    try:\n        C_post = np.linalg.inv(C_post_inv)\n    except np.linalg.LinAlgError:\n        # If matrix is singular, posterior uncertainty is infinite\n        return float('inf')\n        \n    # Return the trace\n    return np.trace(C_post)\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}