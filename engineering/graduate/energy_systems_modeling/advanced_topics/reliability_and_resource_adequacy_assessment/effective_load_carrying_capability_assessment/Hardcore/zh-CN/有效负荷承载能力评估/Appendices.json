{
    "hands_on_practices": [
        {
            "introduction": "本次实践将从头开始构建可靠性评估的基础。通过从第一性原理出发构建容量中断概率表（COPT），您将掌握量化发电机组可用性的核心概率方法。这项练习对于理解系统性风险如何从单个发电机组的特性中衍生出来至关重要，它构成了诸如期望缺供概率（LOLP）等指标的基础 。",
            "id": "4087135",
            "problem": "给定一个由常规发电机组组成的小型电力系统，每个机组被建模为独立的两态设备。每个机组的出力要么是其全部额定容量，要么是零。转换到零容量状态的情况是发生强迫停运，并由一个概率来表征。目标是构建容量停运概率表 (COPT)——在本问题中理解为总可用容量的离散概率分布——然后通过将可用容量分布与每个时段的离散负荷分布相结合，来评估缺电风险。请从独立性的基本定义和离散随机变量的概率法则出发。不要使用任何快捷公式；相反，应从第一性原理推导计算方法。\n\n定义与假设：\n- 每个机组 $i$ 的额定容量为 $c_i$ 兆瓦 (MW)，并具有独立的强迫停运率 (FOR) $q_i$，这意味着该机组以 $1-q_i$ 的概率输出 $c_i$ 兆瓦，以 $q_i$ 的概率输出 $0$ 兆瓦。\n- 机组间的独立性意味着，某个给定子集可用而其余机组处于强迫停运状态的联合概率，等于它们各自概率的乘积。\n- 本问题中的容量停运概率表 (COPT) 应被视为总可用容量 $A$ 的离散概率质量函数 (PMF)，它是通过组合所有机组的二元可用性结果得到的。\n- 对于每个时段 $t$，负荷 $L_t$ 由一个关于有限个负荷水平（单位为 MW）的离散 PMF 表示。在时段 $t$ 的缺负荷概率 (LOLP)，记为 $LOLP_t$，是指当可用容量 $A$ 和负荷 $L_t$ 均被建模为离散随机变量时，可用容量 $A$ 严格小于负荷 $L_t$ 的概率。每个时段的输出必须是小数值。\n\n您的程序必须：\n1. 使用独立离散随机变量的法则，通过依次组合每个机组的两态可用性模型，构建总可用容量 $A$ 的离散 PMF。\n2. 基于可用容量的分布，通过将容量分布与负荷分布相结合，并使用离散随机变量的标准概率法则（不依赖任何预先给定的公式），计算每个时段 $t$ 的 $LOLP_t$。\n3. 所有容量均以兆瓦 (MW) 表示，所有概率均以小数表示。任何地方都不应使用百分号。\n4. 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例的 $LOLP_t$ 值列表。\n\n测试套件：\n- 测试用例 $1$ (一般情况)：\n  - 机组：$\\{(c_1,q_1)=(50,0.05),(c_2,q_2)=(30,0.10),(c_3,q_3)=(20,0.10),(c_4,q_4)=(10,0.20)\\}$，容量单位为 MW，FOR 为小数。\n  - 时段和负荷 PMF (MW, 小数概率)：\n    - $t=1$: $\\{(90,0.6),(100,0.3),(110,0.1)\\}$。\n    - $t=2$: $\\{(70,0.5),(80,0.4),(90,0.1)\\}$。\n    - $t=3$: $\\{(100,0.4),(115,0.4),(120,0.2)\\}$。\n- 测试用例 $2$ (边界情况，完全可靠)：\n  - 机组：$\\{(c_1,q_1)=(40,0.0),(c_2,q_2)=(40,0.0),(c_3,q_3)=(20,0.0)\\}$。\n  - 时段和负荷 PMF (MW, 小数概率)：\n    - $t=1$: $\\{(50,0.5),(60,0.3),(70,0.2)\\}$。\n    - $t=2$: $\\{(80,0.6),(90,0.4)\\}$。\n- 测试用例 $3$ (边缘情况，相同机组且停运率较高)：\n  - 机组：六个相同机组 $\\{(c_i,q_i)=(15,0.2)\\text{ for }i=1,2,3,4,5,6\\}$。\n  - 时段和负荷 PMF (MW, 小数概率)：\n    - $t=1$: $\\{(80,0.5),(85,0.3),(90,0.2)\\}$。\n    - $t=2$: $\\{(30,0.7),(60,0.2),(95,0.1)\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，本身也是一个包含该用例中各个时段 $[LOLP_1,LOLP_2,\\dots]$ 的小数值列表。例如，一个有效的整体输出格式是 $[[x_1,x_2,x_3],[y_1,y_2],[z_1,z_2]]$，其中每个 $x_k$、$y_k$ 和 $z_k$ 都是一个小数。",
            "solution": "该问题要求计算一个电力系统在不同时段 $t$ 的缺负荷概率 ($LOLP_t$)。该系统由几个独立的的发电机组组成，并且每个时段都有一个关于电力负荷的离散概率分布。解决方案必须从概率论的基本原理推导得出。这个过程在逻辑上分为两个主要步骤：首先，构建总可用发电容量的概率分布；其次，利用该分布和负荷分布来计算缺电概率。\n\n### 步骤 1：构建容量停运概率表 (COPT)\n\nCOPT 被定义为总可用容量（用随机变量 $A$ 表示）的离散概率质量函数 (PMF)。$N$ 个发电机组中的每一个都是一个独立的两态设备。机组 $i$ 以概率 $p_i = 1 - q_i$ 提供容量 $c_i$（机组可用），并以概率 $q_i$ 提供容量 $0$（机组处于强迫停运状态），其中 $q_i$ 是其强迫停运率 (FOR)。\n\n令 $G_i$ 为表示机组 $i$ 容量的随机变量。$G_i$ 的 PMF 由下式给出：\n$$ P(G_i=x) = \\begin{cases} p_i = 1-q_i  \\text{if } x=c_i \\\\ q_i  \\text{if } x=0 \\\\ 0  \\text{otherwise} \\end{cases} $$\n总可用容量 $A$ 是所有单个机组容量的总和：\n$$ A = \\sum_{i=1}^{N} G_i $$\n由于所有机组都是统计独立的，随机变量 $G_1, G_2, \\dots, G_N$ 也是独立的。概率论的一个基本定理指出，独立离散随机变量之和的 PMF 是它们各自 PMF 的离散卷积。\n\n我们可以迭代地构建 $A$ 的 PMF。令 $D_k$ 表示前 $k$ 个机组的累积容量 $A_k = \\sum_{i=1}^{k} G_i$ 的 PMF。$D_k$ 可以表示为一组（容量，概率）对，即 $\\{(a, P(A_k=a))\\}$。\n\n该算法从零个机组的基本情况开始。对于一个没有发电机的系统，其 PMF $D_0$ 是平凡的：总容量为 $0$ MW，概率为 $1$。\n$$ D_0 = \\{(0, 1.0)\\} $$\n现在，我们通过并入机组 $k$，从 $k-1$ 个机组的 PMF $D_{k-1}$ 推导出 $k$ 个机组的 PMF $D_k$。这等同于计算 $D_{k-1}$ 与 $G_k$ 的 PMF 的卷积。设 $(a', P(A_{k-1}=a'))$ 是 $D_{k-1}$ 中的一个任意状态。当我们加入机组 $k$ 时，由于独立性，存在两种可能性：\n1. 机组 $k$ 停运（容量为 $0$，概率为 $q_k$）。新的总容量为 $a' + 0 = a'$，此联合事件的概率为 $P(A_{k-1}=a') \\cdot q_k$。\n2. 机组 $k$ 可用（容量为 $c_k$，概率为 $p_k = 1 - q_k$）。新的总容量为 $a' + c_k$，此联合事件的概率为 $P(A_{k-1}=a') \\cdot p_k$。\n\n将此过程应用于 $D_{k-1}$ 中的所有状态以生成 $D_k$ 的状态。如果多条路径导致了相同的总容量值，则将它们的概率相加。对所有 $N$ 个机组执行此迭代卷积，最终得到最终的 PMF $D_N$，即整个系统的 COPT。\n\n### 步骤 2：计算缺负荷概率 (LOLP)\n\n给定时段 $t$ 的 $LOLP_t$ 定义为总可用容量 $A$ 严格小于负荷 $L_t$ 的概率。\n$$ LOLP_t = P(A  L_t) $$\n$A$ 和 $L_t$ 都是离散随机变量，并假设它们是独立的。$A$ 的 PMF 是我们推导出的 COPT，而 $L_t$ 的 PMF 对每个时段给定，由数对 $(l_j, P(L_t=l_j))$ 组成。\n\n为了计算 $P(A  L_t)$，我们应用全概率公式，以负荷 $L_t$ 的可能值为条件。\n$$ LOLP_t = P(A  L_t) = \\sum_{j} P(A  L_t \\mid L_t = l_j) \\cdot P(L_t = l_j) $$\n因为 $A$ 和 $L_t$ 是独立的，条件概率 $P(A  L_t \\mid L_t = l_j)$ 简化为无条件概率 $P(A  l_j)$。因此，表达式变为：\n$$ LOLP_t = \\sum_{j} P(A  l_j) \\cdot P(L_t = l_j) $$\n该公式提供了一个清晰的算法。对于每个可能的负荷水平 $l_j$ 及其概率 $P(L_t=l_j)$：\n1. 我们计算可用容量不足以满足此特定负荷的概率，即 $P(A  l_j)$。\n2. 这个概率通过对 COPT 中所有容量 $a$ 严格小于负荷水平 $l_j$ 的容量状态 $(a, P(A=a))$ 的概率求和得到。\n$$ P(A  l_j) = \\sum_{a  l_j} P(A=a) $$\n3. 然后，将值 $P(A  l_j)$ 与该负荷水平出现的概率 $P(L_t=l_j)$ 进行加权。\n4. 最终的 $LOLP_t$ 是对所有可能的负荷水平 $j$ 的这些加权概率的总和。\n\n这个基于第一性原理的两步过程能够正确计算所需的可靠性指标，而无需借助任何预先建立的、未经推导的公式。代码实现将直接遵循此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef build_copt(units):\n    \"\"\"\n    Constructs the Capacity Outage Probability Table (COPT) from first principles.\n\n    The COPT is the discrete probability mass function (PMF) of the total\n    available capacity. It is built by iteratively convolving the PMF of the\n    existing system with the PMF of each new unit.\n\n    Args:\n        units (list of tuples): A list where each tuple is (capacity, FOR),\n                                representing a generating unit.\n\n    Returns:\n        dict: A dictionary representing the COPT, where keys are capacity\n              levels (float) and values are their probabilities (float).\n    \"\"\"\n    # Base case: A system with 0 units has 0 capacity with probability 1.0.\n    # We use a defaultdict to simplify adding probabilities for new capacity states.\n    copt = defaultdict(float)\n    copt[0.0] = 1.0\n\n    # Iteratively add each unit to the system.\n    for capacity, forced_outage_rate in units:\n        new_copt = defaultdict(float)\n        prob_available = 1.0 - forced_outage_rate\n\n        # For each existing capacity state in the current COPT...\n        for existing_cap, existing_prob in copt.items():\n            # Case 1: The new unit is in a forced outage (capacity 0).\n            # The total capacity remains the same.\n            prob_outage = forced_outage_rate\n            new_copt[existing_cap] += existing_prob * prob_outage\n\n            # Case 2: The new unit is available (capacity c_i).\n            # The total capacity increases by c_i.\n            new_capacity = existing_cap + capacity\n            new_copt[new_capacity] += existing_prob * prob_available\n        \n        copt = new_copt\n\n    return dict(copt)\n\ndef calculate_lolp(copt, load_pmf):\n    \"\"\"\n    Calculates the Loss of Load Probability (LOLP) from first principles.\n\n    LOLP is the probability that available capacity is less than the load.\n    It is computed using the law of total probability, summing over all\n    possible load levels. LOLP_t = sum_j(P(A  l_j) * P(L_t = l_j)).\n\n    Args:\n        copt (dict): The COPT of the system (PMF of available capacity).\n        load_pmf (dict): The PMF of the load for a given time period.\n\n    Returns:\n        float: The calculated LOLP for the period.\n    \"\"\"\n    total_lolp = 0.0\n\n    # For each discrete load level and its probability...\n    for load_level, load_prob in load_pmf.items():\n        # Calculate P(Capacity  load_level).\n        prob_capacity_less_than_load = 0.0\n        for capacity, cap_prob in copt.items():\n            if capacity  load_level:\n                prob_capacity_less_than_load += cap_prob\n\n        # Add the contribution of this load level to the total LOLP.\n        total_lolp += prob_capacity_less_than_load * load_prob\n\n    return total_lolp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"units\": [(50, 0.05), (30, 0.10), (20, 0.10), (10, 0.20)],\n            \"loads\": [\n                {90: 0.6, 100: 0.3, 110: 0.1},\n                {70: 0.5, 80: 0.4, 90: 0.1},\n                {100: 0.4, 115: 0.4, 120: 0.2},\n            ]\n        },\n        {\n            \"units\": [(40, 0.0), (40, 0.0), (20, 0.0)],\n            \"loads\": [\n                {50: 0.5, 60: 0.3, 70: 0.2},\n                {80: 0.6, 90: 0.4},\n            ]\n        },\n        {\n            \"units\": [(15, 0.2)] * 6,\n            \"loads\": [\n                {80: 0.5, 85: 0.3, 90: 0.2},\n                {30: 0.7, 60: 0.2, 95: 0.1},\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Step 1: Construct the Capacity Outage Probability Table (COPT)\n        units = case[\"units\"]\n        copt = build_copt(units)\n        \n        case_lolps = []\n        # Step 2: For each time period, calculate the LOLP\n        for load_pmf in case[\"loads\"]:\n            lolp = calculate_lolp(copt, load_pmf)\n            case_lolps.append(lolp)\n        \n        all_results.append(case_lolps)\n\n    # Format the final output string precisely as required.\n    # e.g., [[x1,x2],[y1,y2]] without extra spaces.\n    case_results_str = [f\"[{','.join(map(str, lolp_list))}]\" for lolp_list in all_results]\n    final_output_str = f\"[{','.join(case_results_str)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在可靠性基本原理的基础上，本练习将引入有效荷载能力（ELCC）的概念。您将分析一个由可变可再生能源组成的组合，其容量价值如何随着更多机组的加入而变化。这个思想实验旨在揭示ELCC的两个核心原则：多元化的资源协同工作的“组合效应”，以及随着系统达到饱和状态而出现的“边际收益递减”规律 。",
            "id": "4087102",
            "problem": "考虑一个使用“期望失负荷”（Loss Of Load Expectation, LOLE）框架的电力系统简化充裕度模型。存在三个代表性小时，索引为 $t \\in \\{1,2,3\\}$，其中小时 $t=1$ 和 $t=2$ 是具有非零短缺概率的风险小时，而小时 $t=3$ 是无风险小时。基准小时短缺概率为 $p_1 = 0.5$，$p_2 = 0.4$ 和 $p_3 = 0$。在充裕度阈值附近，由大小为 $q_t$ 的小量净负荷转移引起的小时 $t$ 短缺概率的降低量可近似为 $f_t \\, q_t$（直至饱和），其中 $f_t$ 是阈值处的尾部概率密度。取 $f_1 = 0.5$，$f_2 = 0.1$ 和 $f_3 = 0$。假设每个小时的降低量在基准概率处饱和，即小时 $t$ 的降低量不能超过 $p_t$。\n\n添加了一个由 $N$ 个可变可再生能源单元组成的组合，其中单元 $i$ 在三个小时内产生确定的净负荷降低量 $\\{y_{i,1},y_{i,2},y_{i,3}\\}$。五个候选单元具有以下小时向量（所有分量均为非负实数，代表兆瓦的净负荷降低量）：单元1为 $\\{0.8,\\;0.5,\\;2.0\\}$，单元2为 $\\{0.3,\\;2.0,\\;1.5\\}$，单元3为 $\\{0.0,\\;1.5,\\;2.5\\}$，单元4为 $\\{0.0,\\;0.0,\\;3.0\\}$，单元5为 $\\{0.0,\\;0.0,\\;3.5\\}$。无风险小时 $t=3$ 的净负荷降低量不影响 LOLE。\n\n令“有效荷载能力”（Effective Load Carrying Capability, ELCC）通过“等效确定性容量”（Equivalent Firm Capacity, EFC）来定义：对于给定的 $N$，EFC $x(N)$ 是指完全可靠的确定性容量（单位为兆瓦），当其添加到基准系统中时，产生的 LOLE 总降低量与添加 $N$ 个可变单元所产生的相同。在线性化尾部近似下，增加确定性容量 $x$ 会使每个小时的阈值均等地移动 $x$；因此，确定性容量 $x$ 带来的 LOLE 降低量为 $\\sum_{t=1}^{3} \\min\\{f_t x,\\; p_t\\}$。\n\n任务：\n- 仅使用上述定义和 LOLE 降低模型的第一性原理推导，通过将 $N$ 个单元的 LOLE 降低量与确定性容量 $x$ 的 LOLE 降低量相等，计算 $N \\in \\{1,2,3,4,5\\}$ 时的 $x(N)$。将 $x(N)$ 以 $\\text{MW}$ 表示。\n- 定义单位平均 ELCC 为 $\\bar{x}(N) = x(N)/N$，并对 $N \\in \\{1,2,3,4,5\\}$ 进行求值。\n- 确定在 $\\{1,2,3,4,5\\}$ 中使 $\\bar{x}(N)$ 达到最大值的整数 $N^{\\star}$。将 $N^{\\star}$ 以整数形式给出，无需四舍五入。\n- 在您的解决方案中，解释转折点条件，需结合风险小时内 LOLE 的饱和以及风险区间外存在的多余净负荷降低量进行说明。\n\n您的最终答案必须是单个整数 $N^{\\star}$。",
            "solution": "问题要求确定可变可再生能源单元的最优数量 $N^{\\star}$，以使单位平均有效荷载能力（ELCC）最大化。这涉及到计算一系列组合的 ELCC，并找出单位平均值的最大值。ELCC，记为 $x(N)$，定义为等效确定性容量（EFC），它提供的期望失负荷（LOLE）总降低量与一个包含 $N$ 个单元的组合相同。\n\n首先，我们形式化 LOLE 降低量的表达式。问题设置在一个包含三个小时 $t \\in \\{1, 2, 3\\}$ 的简化模型中。基准短缺概率为 $p_1 = 0.5$，$p_2 = 0.4$ 和 $p_3 = 0$。短缺概率对净负荷降低量的敏感度由尾部密度 $f_1 = 0.5$，$f_2 = 0.1$ 和 $f_3 = 0$ 给出。\n\n一个包含 $N$ 个单元的组合所带来的总 LOLE 降低量是各小时短缺概率降低量之和，并受限于基准概率。令 $Y_t(N) = \\sum_{i=1}^{N} y_{i,t}$ 为前 $N$ 个单元在小时 $t$ 的总净负荷降低量。LOLE 降低量为：\n$$ \\Delta \\text{LOLE}_{\\text{portfolio}}(N) = \\sum_{t=1}^{3} \\min\\left(f_t Y_t(N), p_t\\right) $$\n由于 $f_3 = 0$ 且 $p_3 = 0$，第三项始终为零。因此，我们只考虑两个风险小时：\n$$ \\Delta \\text{LOLE}_{\\text{portfolio}}(N) = \\min\\left(f_1 Y_1(N), p_1\\right) + \\min\\left(f_2 Y_2(N), p_2\\right) $$\n\n由一定量的确定性容量 $x$ 带来的 LOLE 降低量也类似地定义：\n$$ \\Delta \\text{LOLE}_{\\text{firm}}(x) = \\sum_{t=1}^{3} \\min\\left(f_t x, p_t\\right) = \\min\\left(f_1 x, p_1\\right) + \\min\\left(f_2 x, p_2\\right) $$\n根据定义，EFC $x(N)$ 满足 $\\Delta \\text{LOLE}_{\\text{firm}}(x(N)) = \\Delta \\text{LOLE}_{\\text{portfolio}}(N)$。\n\n我们首先计算当 $t \\in \\{1, 2\\}$ 和 $N \\in \\{1, 2, 3, 4, 5\\}$ 时的累积净负荷降低量 $Y_t(N)$。风险小时的单元向量为：\n单元1：$\\{y_{1,1}, y_{1,2}\\} = \\{0.8, 0.5\\}$\n单元2：$\\{y_{2,1}, y_{2,2}\\} = \\{0.3, 2.0\\}$\n单元3：$\\{y_{3,1}, y_{3,2}\\} = \\{0.0, 1.5\\}$\n单元4：$\\{y_{4,1}, y_{4,2}\\} = \\{0.0, 0.0\\}$\n单元5：$\\{y_{5,1}, y_{5,2}\\} = \\{0.0, 0.0\\}$\n\n累积向量 $\\{Y_1(N), Y_2(N)\\}$ 为：\n对于 $N=1$：$\\{0.8, 0.5\\}$\n对于 $N=2$：$\\{0.8+0.3, 0.5+2.0\\} = \\{1.1, 2.5\\}$\n对于 $N=3$：$\\{1.1+0.0, 2.5+1.5\\} = \\{1.1, 4.0\\}$\n对于 $N=4$：$\\{1.1+0.0, 4.0+0.0\\} = \\{1.1, 4.0\\}$\n对于 $N=5$：$\\{1.1+0.0, 4.0+0.0\\} = \\{1.1, 4.0\\}$\n\n现在，我们使用 $f_1=0.5, p_1=0.5$ 和 $f_2=0.1, p_2=0.4$ 来计算每个 $N$ 的 $\\Delta \\text{LOLE}_{\\text{portfolio}}(N)$：\n对于 $N=1$：$\\min(0.5 \\times 0.8, 0.5) + \\min(0.1 \\times 0.5, 0.4) = \\min(0.4, 0.5) + \\min(0.05, 0.4) = 0.4 + 0.05 = 0.45$。\n对于 $N=2$：$\\min(0.5 \\times 1.1, 0.5) + \\min(0.1 \\times 2.5, 0.4) = \\min(0.55, 0.5) + \\min(0.25, 0.4) = 0.5 + 0.25 = 0.75$。\n在这一步，小时1的贡献饱和，即达到了其最大可能值 $p_1 = 0.5$。\n对于 $N=3$：$\\min(0.5 \\times 1.1, 0.5) + \\min(0.1 \\times 4.0, 0.4) = \\min(0.55, 0.5) + \\min(0.4, 0.4) = 0.5 + 0.4 = 0.9$。\n此时，小时2的贡献也在 $p_2 = 0.4$ 处饱和。总 LOLE 降低量达到了其理论最大值 $p_1+p_2 = 0.9$。\n对于 $N=4$：由于 $Y(4) = Y(3)$，$\\Delta \\text{LOLE}_{\\text{portfolio}}(4) = 0.9$。\n对于 $N=5$：由于 $Y(5) = Y(4)$，$\\Delta \\text{LOLE}_{\\text{portfolio}}(5) = 0.9$。\n\n接下来，我们通过求解 $\\Delta \\text{LOLE}_{\\text{firm}}(x(N)) = \\Delta \\text{LOLE}_{\\text{portfolio}}(N)$ 来找到 $x(N)$。我们分析函数 $\\Delta \\text{LOLE}_{\\text{firm}}(x) = \\min(0.5x, 0.5) + \\min(0.1x, 0.4)$。\n确定性容量 $x$ 的饱和点是：\n小时1：$0.5x = 0.5 \\implies x = 1$。\n小时2：$0.1x = 0.4 \\implies x = 4$。\n函数 $\\Delta \\text{LOLE}_{\\text{firm}}(x)$ 是分段线性的：\n- 如果 $0 \\le x \\le 1$：$\\Delta \\text{LOLE}_{\\text{firm}}(x) = 0.5x + 0.1x = 0.6x$。\n- 如果 $1  x \\le 4$：$\\Delta \\text{LOLE}_{\\text{firm}}(x) = 0.5 + 0.1x$。\n- 如果 $x > 4$：$\\Delta \\text{LOLE}_{\\text{firm}}(x) = 0.5 + 0.4 = 0.9$。\n\n现在我们通过反转该函数来找到每个 $x(N)$：\n- $x(1)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(1) = 0.45$。这属于第一个区间（$0.45 \\le 0.6$）。\n  $0.6 x(1) = 0.45 \\implies x(1) = \\frac{0.45}{0.6} = \\frac{45}{60} = \\frac{3}{4} = 0.75$ MW。\n- $x(2)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(2) = 0.75$。这属于第二个区间（$0.6  0.75 \\le 0.9$）。\n  $0.5 + 0.1 x(2) = 0.75 \\implies 0.1 x(2) = 0.25 \\implies x(2) = 2.5$ MW。\n- $x(3)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(3) = 0.9$。这是第二个区间的饱和点。\n  $0.5 + 0.1 x(3) = 0.9 \\implies 0.1 x(3) = 0.4 \\implies x(3) = 4.0$ MW。\n- $x(4)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(4) = 0.9$。由于 LOLE 降低量未改变，$x(4) = x(3) = 4.0$ MW。\n- $x(5)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(5) = 0.9$。同样地，$x(5) = 4.0$ MW。\n\n最后，我们计算单位平均 ELCC，$\\bar{x}(N) = x(N)/N$：\n- $\\bar{x}(1) = \\frac{0.75}{1} = 0.75$ MW/单元。\n- $\\bar{x}(2) = \\frac{2.5}{2} = 1.25$ MW/单元。\n- $\\bar{x}(3) = \\frac{4.0}{3} \\approx 1.333$ MW/单元。\n- $\\bar{x}(4) = \\frac{4.0}{4} = 1.0$ MW/单元。\n- $\\bar{x}(5) = \\frac{4.0}{5} = 0.8$ MW/单元。\n\n比较这些值，最大平均 ELCC 是 $\\bar{x}(3) = \\frac{4}{3}$。达到此最大值时的整数 $N$ 是 $N^{\\star}=3$。\n\n$\\bar{x}(N)$ 的行为展示了 ELCC 的关键特性。从 $N=1$ 到 $N=2$ 再到 $N=3$ 的增长反映了组合效应或协同效应：各单元的输出在时间上互补，有效地降低了不同风险小时的 LOLE。单元1在小时1有效，而单元2和3在小时2有效。转折点出现在 $N^{\\star}=3$。这恰好是组合对 LOLE 降低的贡献在所有可用风险小时内都达到饱和的点，意味着系统无法再吸收更多的风险降低效益。所有后续单元（4和5）仅在无风险小时 $t=3$（其中 $f_3=0$）提供“多余”的净负荷降低量。这些多余的容量对 LOLE 降低没有任何贡献。因此，对于 $N > 3$，总 ELCC $x(N)$ 保持在其最大值 $4.0$ 兆瓦不变，而分母 $N$ 在增加。这导致平均 ELCC $\\bar{x}(N)$ 下降，这是资源充裕度评估中新增容量边际收益递减的典型例证。因此，平均值的最大值在系统完全饱和的阈值处达到。\n\n使 $\\bar{x}(N)$ 最大化的整数 $N^{\\star}$ 是 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "这最后一个实践将ELCC理论与其在容量市场设计中的关键应用联系起来。您将比较两种不同的容量认证方案——一种基于简化的平均ELCC，另一种基于更精确的边际ELCC——以理解它们对投资决策的影响。通过量化由此产生的可靠性差距，本练习将阐明为何平均估值与边际估值之间的区别不仅仅是学术上的，而是对我们能源系统的效率和安全具有深远影响 。",
            "id": "4087056",
            "problem": "您的任务是构建一个完整的、可运行的程序，该程序模拟可变可再生能源资源的有效负载承载能力 (ELCC)，并在一个程式化的容量市场中比较平均 ELCC 认证与边际 ELCC 认证。其目的是从计算角度解释使用平均与边际 ELCC 进行资源认证所产生的影响，并以能源可靠性差距的形式，量化投资决策中的潜在低效性。\n\n请基于能源系统建模中的以下基本原理开始：\n- 可靠性通过未服务能源 (ENS) 来量化，其定义为离散时间序列上每小时缺额的总和。令 $T$ 表示小时数，令 $L_t$ 表示第 $t$ 小时的负荷，令 $C$ 表示固定容量（单位：兆瓦，MW），令 $R_t$ 表示第 $t$ 小时的资源出力（单位：MW）。未服务能源为 $$\\mathrm{ENS} = \\sum_{t=1}^{T} \\max(L_t - C - R_t, 0).$$ 这个定义反映了一个被广泛接受的可靠性指标，该指标汇总了随时间变化的未满足需求，当使用小时分辨率时，其单位为兆瓦时 (MWh)。\n- 新增资源组合的有效负载承载能力 (ELCC) 定义为一个以兆瓦为单位的恒定负荷增量，记为 $x$。该增量使得在计入该资源和额外负荷后的未服务能源，等于没有该资源时的基准未服务能源。形式上，如果 $\\mathrm{ENS}_0$ 是资源出力恒为零时的基准未服务能源，且 $\\mathrm{ENS}(x)$ 是当负荷增加 $x$ 并且存在资源出力时的未服务能源，那么 ELCC 就是满足 $$\\mathrm{ENS}(x) = \\mathrm{ENS}_0$$ 的值 $x$。\n- 平均 ELCC 指的是使用某一有限数量资源的 ELCC 与其铭牌容量的比值，并将该比值统一应用于所有增量的容量认证。边际 ELCC 指的是在当前渗透水平下，每兆瓦的增量 ELCC，并将其应用于每个增量兆瓦。\n\n您的程序必须严格基于以上基本原理实现以下功能，不得使用任何专门的简化公式：\n1. 使用数组对系统进行小时级建模，包括 $L_t$（单位 MW）、$C$（单位 MW）以及两种资源类型（太阳能和风能）的单位兆瓦出力曲线，分别用 $s_t$ 和 $w_t$ 表示。铭牌容量为 $N_{\\mathrm{s}}$ MW 的太阳能资源出力为 $N_{\\mathrm{s}} \\cdot s_t$，同理，风能出力为 $N_{\\mathrm{w}} \\cdot w_t$。\n2. 使用上述定义，在 $N_{\\mathrm{s}} = 0$ 和 $N_{\\mathrm{w}} = 0$ 的条件下，计算基准未服务能源 $\\mathrm{ENS}_0$。\n3. 定义一个函数，对于给定的 $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$，找到 ELCC 值 $x$（单位 MW），使得负荷为 $L_t + x$、资源出力为 $N_{\\mathrm{s}} \\cdot s_t + N_{\\mathrm{w}} \\cdot w_t$ 时的未服务能源等于 $\\mathrm{ENS}_0$。您必须通过在 $x \\ge 0$ 范围内使用稳健的搜索方法对该等式进行数值求解来确定 $x$。\n4. 使用类别参考渗透率（太阳能为 $N_{\\mathrm{s}}^{\\mathrm{ref}}$，风能为 $N_{\\mathrm{w}}^{\\mathrm{ref}}$）为每种资源类型计算一个平均 ELCC 认证比例。太阳能的比例定义为 $\\frac{\\text{ELCC}(N_{\\mathrm{s}}^{\\mathrm{ref}}, 0)}{N_{\\mathrm{s}}^{\\mathrm{ref}}}$，风能的比例定义为 $\\frac{\\text{ELCC}(0, N_{\\mathrm{w}}^{\\mathrm{ref}})}{N_{\\mathrm{w}}^{\\mathrm{ref}}}$。在平均 ELCC 方案下，这些比例将作为每兆瓦的固定认证率。\n5. 实现两个投资决策过程以满足目标认证容量需求 $K$（单位 MW），给定太阳能和风能的单位铭牌容量成本 $p_{\\mathrm{s}}$ 和 $p_{\\mathrm{w}}$：\n   - 在平均 ELCC 认证方案下，为每种资源类型分配第 4 步得出的固定认证率。选择单位认证兆瓦成本最低的资源类型，即 $\\frac{p_{\\mathrm{s}}}{\\text{avg\\_frac}_{\\mathrm{s}}}$ 和 $\\frac{p_{\\mathrm{w}}}{\\text{avg\\_frac}_{\\mathrm{w}}}$ 中的最小值，并以整数兆瓦为增量投资于该单一类型，直到认证容量总和（固定认证率乘以投资的铭牌容量）达到或超过 $K$。\n   - 在边际 ELCC 认证方案下，以整数兆瓦为增量进行。在每个增量步骤中，计算太阳能的单位兆瓦边际 ELCC 为 $\\text{ELCC}(N_{\\mathrm{s}}+1, N_{\\mathrm{w}}) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$，风能为 $\\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}}+1) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$。选择单位边际认证兆瓦成本最低的资源类型，即 $\\frac{p_{\\mathrm{s}}}{\\Delta \\text{ELCC}_{\\mathrm{s}}}$ 和 $\\frac{p_{\\mathrm{w}}}{\\Delta \\text{ELCC}_{\\mathrm{w}}}$ 中的最小值，并投资 1 兆瓦该类型资源。通过在每一步加上相应的边际 ELCC 来累积认证容量，直到达到或超过 $K$。\n6. 在每种方案下完成采购后，通过使用投资的资源出力和无负荷增加（即 $x=0$）来评估定义，计算已实现的未服务能源。将平均方案相对于边际方案的投资低效性定义为以 MWh 为单位的已实现未服务能源差距：$$\\Delta \\mathrm{ENS} = \\mathrm{ENS}_{\\mathrm{avg}} - \\mathrm{ENS}_{\\mathrm{marg}}.$$\n7. 对于每个测试用例，报告以兆瓦时 (MWh) 为单位的 $\\Delta \\mathrm{ENS}$，四舍五入到三位小数。\n\n使用以下测试套件。每个测试用例提供了数组和参数。所有数组都是小时级的， $T = 24$ 小时。所有容量单位均为 MW，成本以每兆瓦铭牌容量的任意成本单位计算，未服务能源在小时分辨率下以 MWh 为单位。\n\n所有测试用例的通用时间序列：\n- 负荷向量 $L_t$（$t = 1, \\dots, 24$）：\n  $\\{\\, $90$, $88$, $87$, $86$, $86$, $88$, $92$, $95$, $97$, $94$, $92$, $91$, $92$, $94$, $96$, $99$, $102$, $105$, $106$, $103$, $98$, $95$, $93$, $91$ \\,\\}$。\n- 固定容量 $C = $95。\n- 太阳能单位兆瓦出力曲线 $s_t$：\n  $\\{\\, $0$, $0$, $0$, $0$, $0$, $0$, $0.1$, $0.2$, $0.5$, $0.7$, $0.8$, $0.9$, $0.9$, $0.8$, $0.6$, $0.3$, $0.1$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ \\,\\}$。\n- 风能单位兆瓦出力曲线 $w_t$：\n  $\\{\\, $0.5$, $0.5$, $0.5$, $0.45$, $0.4$, $0.35$, $0.3$, $0.25$, $0.2$, $0.2$, $0.25$, $0.3$, $0.3$, $0.35$, $0.4$, $0.45$, $0.5$, $0.55$, $0.6$, $0.55$, $0.5$, $0.45$, $0.4$, $0.4$ \\,\\}$。\n- 用于平均 ELCC 认证的参考渗透率：$N_{\\mathrm{s}}^{\\mathrm{ref}} = $40$, $N_{\\mathrm{w}}^{\\mathrm{ref}} = $40$。\n- 单位铭牌容量成本：$p_{\\mathrm{s}} = $0.3$, $p_{\\mathrm{w}} = $0.8$。\n\n测试用例：\n- 用例 1：目标认证容量 $K = $20$ MW。\n- 用例 2：目标认证容量 $K = $2$ MW（边界用例，用于评估接近零渗透率时的行为）。\n- 用例 3：目标认证容量 $K = $60$ MW（边缘用例，用于评估饱和效应和急剧下降的边际 ELCC）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、按测试用例顺序排列的逗号分隔列表，每个条目是以 MWh 为单位且四舍五入到三位小数的 $\\Delta \\mathrm{ENS}$（例如，“[$1.234$,$0.000$,$5.678$]”）。",
            "solution": "用户要求编写一个程序，用于建模和比较一个系统在两种不同的可变可再生能源容量认证方案下的可靠性：一种是平均有效负载承载能力 (ELCC) 方案，另一种是边际 ELCC 方案。目标是通过已实现的未服务能源 ($\\mathrm{ENS}$) 的差距，来量化平均方案相对于边际方案的低效性。\n\n### 1. 问题验证\n\n首先，必须验证问题陈述的正确性和完整性。\n\n**步骤 1：提取已知条件**\n\n*   **系统时间范围**：$T = 24$ 小时，离散小时区间。\n*   **未服务能源 (ENS) 定义**：对于给定的负荷曲线 $L_t$、固定容量 $C$ 和可再生能源出力 $R_t$，$\\mathrm{ENS}$ 定义为：\n    $$ \\mathrm{ENS} = \\sum_{t=1}^{T} \\max(L_t - C - R_t, 0) $$\n*   **有效负载承载能力 (ELCC) 定义**：ELCC，记为 $x$，是与新增资源组合一同添加到系统中的恒定负荷量，使得系统的可靠性水平（以 $\\mathrm{ENS}$ 衡量）与没有该资源的基准系统保持相同。形式上，它是方程 $\\mathrm{ENS}(x) = \\mathrm{ENS}_0$ 的解，其中 $\\mathrm{ENS}_0$ 是基准 $\\mathrm{ENS}$（所有 $t$ 的 $R_t = 0$），而 $\\mathrm{ENS}(x)$ 是在使用调整后的负荷 $L_t' = L_t + x$ 和新增资源出力的情况下计算得出的。\n*   **资源出力**：$N_{\\mathrm{s}}$ MW 太阳能和 $N_{\\mathrm{w}}$ MW 风能的出力为 $R_t = N_{\\mathrm{s}} \\cdot s_t + N_{\\mathrm{w}} \\cdot w_t$。\n*   **通用数据**：\n    *   负荷曲线 $L_t$：$\\{90, 88, 87, 86, 86, 88, 92, 95, 97, 94, 92, 91, 92, 94, 96, 99, 102, 105, 106, 103, 98, 95, 93, 91\\}$ MW。\n    *   固定容量 $C$：$95$ MW。\n    *   单位兆瓦太阳能出力曲线 $s_t$：$\\{0, 0, 0, 0, 0, 0, 0.1, 0.2, 0.5, 0.7, 0.8, 0.9, 0.9, 0.8, 0.6, 0.3, 0.1, 0, 0, 0, 0, 0, 0, 0\\}$。\n    *   单位兆瓦风能出力曲线 $w_t$：$\\{0.5, 0.5, 0.5, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.2, 0.25, 0.3, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4\\}$。\n    *   参考渗透率：$N_{\\mathrm{s}}^{\\mathrm{ref}} = 40$ MW, $N_{\\mathrm{w}}^{\\mathrm{ref}} = 40$ MW。\n    *   单位铭牌容量成本：$p_{\\mathrm{s}} = 0.3$, $p_{\\mathrm{w}} = 0.8$。\n*   **测试用例**：目标认证容量 $K$ 的值为 $20$、$2$ 和 $60$ MW。\n*   **目标**：计算低效性 $\\Delta \\mathrm{ENS} = \\mathrm{ENS}_{\\mathrm{avg}} - \\mathrm{ENS}_{\\mathrm{marg}}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学依据**：$\\mathrm{ENS}$ 和 ELCC 的概念是电力系统可靠性分析的基础。所提供的定义是标准的，在数学上是合理的。随着渗透率的增加，边际 ELCC 递减的现象是能源系统中一个公认的原则。该问题具有科学依据。\n*   **良态性**：ELCC 是通过求解 $\\mathrm{ENS}(x) - \\mathrm{ENS}_0 = 0$ 来确定的。函数 $f(x) = \\mathrm{ENS}(x) - \\mathrm{ENS}_0$ 相对于 $x$ 是单调不减的，这确保了如果存在解，解是唯一的。像二分法这样的稳健数值求根方法是合适的。投资算法是确定性的，并为每个方案带来唯一的投资组合。该问题是良态的。\n*   **完整性和一致性**：所有必要的数据、函数和算法步骤都已明确定义。没有矛盾或缺失的参数。\n\n**步骤 3：结论与行动**\n\n问题被判定为**有效**。这是一个定义明确、科学合理且自成一体的计算建模任务。我将着手开发解决方案。\n\n### 2. 算法设计与原则\n\n解决方案是通过实现一系列与问题中概述的物理和经济原则相对应的函数来构建的。\n\n**A. 核心可靠性函数**\n\n1.  **未服务能源 ($\\mathrm{ENS}$)**：`calculate_ens` 函数直接实现了给定的公式。它接受负荷、容量和发电量的 numpy 数组，并计算每小时能源缺口的总和。这个函数量化了系统无法满足需求的能力。\n    $$ \\mathrm{ENS}(L, C, R) = \\sum_{t=1}^{T} \\max(L_t - C - R_t, 0) $$\n\n2.  **有效负载承载能力 (ELCC)**：`find_elcc` 函数计算给定投资组合 $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$ 的 ELCC。这是核心的数值任务。我们首先计算零可再生能源发电 ($R_t=0$) 系统的基准 $\\mathrm{ENS}_0$。然后，对于给定的 $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$，我们寻找能将 $\\mathrm{ENS}$ 恢复到这个基准水平的负荷增量 $x$。这是一个针对目标函数的求根问题：\n    $$ f(x) = \\mathrm{ENS}(L_t + x, C, N_{\\mathrm{s}}s_t + N_{\\mathrm{w}}w_t) - \\mathrm{ENS}_0 = 0 $$\n    鉴于 $f(x)$ 是单调的，我们采用二分搜索算法。我们在一个有界区间内搜索 $x$，例如 $[0, L_{\\max}]$，其中 $L_{\\max}$ 是峰值负荷。\n\n**B. 投资方案**\n\n程序接着模拟两种不同的投资策略来满足目标认证容量 $K$。\n\n1.  **平均 ELCC 方案**：该方案为每种资源类型使用一个简化的、固定的认证率，该认证率基于其在单一参考渗透水平下的表现。\n    *   首先，我们分别计算太阳能和风能在其参考容量下的 ELCC：$x_{\\mathrm{s}}^{\\mathrm{ref}} = \\text{ELCC}(N_{\\mathrm{s}}^{\\mathrm{ref}}, 0)$ 和 $x_{\\mathrm{w}}^{\\mathrm{ref}} = \\text{ELCC}(0, N_{\\mathrm{w}}^{\\mathrm{ref}})$。\n    *   然后，平均认证分数分别为 $\\alpha_{\\mathrm{s}} = x_{\\mathrm{s}}^{\\mathrm{ref}} / N_{\\mathrm{s}}^{\\mathrm{ref}}$ 和 $\\alpha_{\\mathrm{w}} = x_{\\mathrm{w}}^{\\mathrm{ref}} / N_{\\mathrm{w}}^{\\mathrm{ref}}$。\n    *   单位认证兆瓦的有效成本计算为太阳能的 $p_{\\mathrm{s}} / \\alpha_{\\mathrm{s}}$ 和风能的 $p_{\\mathrm{w}} / \\alpha_{\\mathrm{w}}$。\n    *   模型只投资于有效成本较低的资源。所需的铭牌容量 $N$ 被计算为刚好满足目标：$N = \\lceil K / \\alpha \\rceil$，其中 $\\alpha$ 是所选资源的分数。\n\n2.  **边际 ELCC 方案**：该方案反映了一个更复杂的市场，其中每增加一兆瓦的容量都根据其在当前系统状态下对可靠性的边际贡献来估值。这是一个迭代的、贪婪的优化过程。\n    *   从零容量（$N_{\\mathrm{s}}=0, N_{\\mathrm{w}}=0$）开始，总认证容量，即投资组合的 ELCC，也为零。\n    *   在每一步中，我们计算增加 1 兆瓦太阳能与 1 兆瓦风能的边际 ELCC。\n        *   $\\Delta \\text{ELCC}_{\\mathrm{s}} = \\text{ELCC}(N_{\\mathrm{s}}+1, N_{\\mathrm{w}}) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$\n        *   $\\Delta \\text{ELCC}_{\\mathrm{w}} = \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}}+1) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$\n    *   有效的边际成本为 $p_{\\mathrm{s}} / \\Delta \\text{ELCC}_{\\mathrm{s}}$ 和 $p_{\\mathrm{w}} / \\Delta \\text{ELCC}_{\\mathrm{w}}$。\n    *   模型增加 1 兆瓦边际成本较低的资源。\n    *   更新投资组合 $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$，总认证容量变为新投资组合的 ELCC。\n    *   这个过程重复进行，直到总认证容量 $\\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$ 达到或超过目标 $K$。这种迭代方法捕捉了每种资源类型的收益递减效应，并允许成本最优的投资组合多样化。\n\n**C. 低效性量化**\n\n最后，对于三个测试用例（$K \\in \\{20, 2, 60\\}$）中的每一个，我们执行以下操作：\n1.  从两种方案中确定最终的投资组合 $(N_{\\mathrm{s, avg}}, N_{\\mathrm{w, avg}})$ 和 $(N_{\\mathrm{s, marg}}, N_{\\mathrm{w, marg}})$。\n2.  使用原始负荷曲线（即 $x=0$）计算每个投资组合的已实现 $\\mathrm{ENS}$。\n    *   $\\mathrm{ENS}_{\\mathrm{avg}} = \\mathrm{ENS}(L, C, N_{\\mathrm{s, avg}}s_t + N_{\\mathrm{w, avg}}w_t)$\n    *   $\\mathrm{ENS}_{\\mathrm{marg}} = \\mathrm{ENS}(L, C, N_{\\mathrm{s, marg}}s_t + N_{\\mathrm{w, marg}}w_t)$\n3.  投资低效性是其差值：$\\Delta \\mathrm{ENS} = \\mathrm{ENS}_{\\mathrm{avg}} - \\mathrm{ENS}_{\\mathrm{marg}}$。正值表示对于给定的目标容量认证水平，平均方案导致了一个可靠性较低的系统，暴露了其简化估值方法的缺陷。\n收集每个用例的结果并按规定格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Models and compares average vs. marginal ELCC accreditation for renewable\n    energy resources and quantifies the resulting investment inefficiency.\n    \"\"\"\n\n    # --- Common Data and Parameters ---\n    # Time series data (T=24 hours)\n    L_t = np.array([\n        90, 88, 87, 86, 86, 88, 92, 95, 97, 94, 92, 91, 92, 94, 96, 99, 102,\n        105, 106, 103, 98, 95, 93, 91\n    ], dtype=float)\n    s_t = np.array([\n        0, 0, 0, 0, 0, 0, 0.1, 0.2, 0.5, 0.7, 0.8, 0.9, 0.9, 0.8, 0.6, 0.3,\n        0.1, 0, 0, 0, 0, 0, 0, 0\n    ], dtype=float)\n    w_t = np.array([\n        0.5, 0.5, 0.5, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.2, 0.25, 0.3,\n        0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4\n    ], dtype=float)\n\n    # System parameters\n    C = 95.0  # Firm capacity (MW)\n    N_s_ref = 40.0 # Solar reference penetration (MW)\n    N_w_ref = 40.0 # Wind reference penetration (MW)\n    p_s = 0.3      # Solar cost per MW\n    p_w = 0.8      # Wind cost per MW\n\n    # Test cases\n    test_cases = [\n        {\"K\": 20.0},  # Case 1\n        {\"K\": 2.0},   # Case 2\n        {\"K\": 60.0},  # Case 3\n    ]\n\n    # --- Core Functions ---\n\n    def calculate_ens(load, capacity, generation):\n        \"\"\"Calculates Energy Not Served (ENS) in MWh.\"\"\"\n        net_load = load - generation\n        deficit = np.maximum(net_load - capacity, 0)\n        return np.sum(deficit)\n\n    # Pre-calculate baseline ENS for efficiency\n    ENS_0 = calculate_ens(L_t, C, 0)\n\n    # Memoization cache for ELCC calculations to speed up repeated calls\n    elcc_cache = {}\n\n    def find_elcc(N_s, N_w):\n        \"\"\"Finds the ELCC for a given renewable portfolio (N_s, N_w).\"\"\"\n        \n        # Use a tuple of integers for the cache key\n        cache_key = (int(N_s), int(N_w))\n        if cache_key in elcc_cache:\n            return elcc_cache[cache_key]\n\n        if N_s == 0 and N_w == 0:\n            return 0.0\n\n        generation = N_s * s_t + N_w * w_t\n        \n        # Objective function for the root-finder: f(x) = ENS(x) - ENS_0\n        def objective_func(x):\n            return calculate_ens(L_t + x, C, generation) - ENS_0\n\n        # The ELCC must be non-negative. A safe upper bound for the search is the peak load.\n        # If adding the resource makes the system more reliable, objective_func(0) will be  0.\n        if objective_func(0) >= 0:\n            # This case means the resource adds no reliability value, or negative value\n            # which is not expected but must be handled. ELCC is 0.\n            elcc_val = 0.0\n        else:\n            try:\n                elcc_val = bisect(objective_func, 0, np.max(L_t))\n            except ValueError:\n                # Can occur if objective_func(0) and objective_func(L_max) have the same sign.\n                # This could happen if the resource is so effective that ENS remains 0\n                # even with max load increase. In this problem context, it implies very high ELCC.\n                # However, for the given data, this is not expected. Default to 0 for robustness.\n                elcc_val = 0.0\n\n        elcc_cache[cache_key] = elcc_val\n        return elcc_val\n\n    # --- Investment Scheme Implementations ---\n\n    def average_elcc_investment(K):\n        \"\"\"Determines the investment portfolio under the average ELCC scheme.\"\"\"\n        elcc_s_ref = find_elcc(N_s_ref, 0)\n        avg_frac_s = elcc_s_ref / N_s_ref if N_s_ref > 0 else 0\n        \n        elcc_w_ref = find_elcc(0, N_w_ref)\n        avg_frac_w = elcc_w_ref / N_w_ref if N_w_ref > 0 else 0\n\n        cost_per_accredited_s = p_s / avg_frac_s if avg_frac_s > 0 else float('inf')\n        cost_per_accredited_w = p_w / avg_frac_w if avg_frac_w > 0 else float('inf')\n\n        if cost_per_accredited_s = cost_per_accredited_w:\n            # Invest in solar\n            nameplate_needed = np.ceil(K / avg_frac_s) if avg_frac_s > 0 else float('inf')\n            return nameplate_needed, 0.0\n        else:\n            # Invest in wind\n            nameplate_needed = np.ceil(K / avg_frac_w) if avg_frac_w > 0 else float('inf')\n            return 0.0, nameplate_needed\n\n    def marginal_elcc_investment(K):\n        \"\"\"Determines the investment portfolio under the marginal ELCC scheme.\"\"\"\n        N_s, N_w = 0, 0\n        current_elcc = 0.0  # ELCC(0,0) is 0\n\n        while current_elcc  K:\n            # Calculate marginal ELCC for solar\n            elcc_s_plus_1 = find_elcc(N_s + 1, N_w)\n            delta_elcc_s = elcc_s_plus_1 - current_elcc\n            cost_s = p_s / delta_elcc_s if delta_elcc_s > 1e-9 else float('inf')\n\n            # Calculate marginal ELCC for wind\n            elcc_w_plus_1 = find_elcc(N_s, N_w + 1)\n            delta_elcc_w = elcc_w_plus_1 - current_elcc\n            cost_w = p_w / delta_elcc_w if delta_elcc_w > 1e-9 else float('inf')\n            \n            # Choose the cheaper resource\n            if cost_s = cost_w:\n                N_s += 1\n                current_elcc = elcc_s_plus_1\n            else:\n                N_w += 1\n                current_elcc = elcc_w_plus_1\n            \n            # Handle edge case where no technology can provide positive marginal ELCC\n            if cost_s == float('inf') and cost_w == float('inf'):\n                break\n\n        return float(N_s), float(N_w)\n\n    # --- Main Execution Loop ---\n    results = []\n    for case in test_cases:\n        K = case[\"K\"]\n        elcc_cache.clear() # Clear cache for each independent K trial\n\n        # 1. Solve for average scheme\n        N_s_avg, N_w_avg = average_elcc_investment(K)\n        gen_avg = N_s_avg * s_t + N_w_avg * w_t\n        ENS_avg = calculate_ens(L_t, C, gen_avg)\n\n        # 2. Solve for marginal scheme\n        N_s_marg, N_w_marg = marginal_elcc_investment(K)\n        gen_marg = N_s_marg * s_t + N_w_marg * w_t\n        ENS_marg = calculate_ens(L_t, C, gen_marg)\n\n        # 3. Calculate and store inefficiency\n        delta_ENS = ENS_avg - ENS_marg\n        results.append(delta_ENS)\n\n    # --- Format and Print Final Output ---\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}