{
    "hands_on_practices": [
        {
            "introduction": "To measure the effective capacity contribution of a new resource, one must first master the art of quantifying the reliability of the baseline system. This foundational exercise guides you through the process of building a Capacity Outage Probability Table (COPT) from first principles, a cornerstone of probabilistic adequacy studies. By implementing the convolution of individual generator outage probabilities (), you will gain a hands-on understanding of how component-level risks aggregate into a system-wide reliability profile, which is essential for any ELCC calculation.",
            "id": "4087135",
            "problem": "You are given a small power system composed of conventional generating units modeled as independent two-state devices. Each unit produces either its full nameplate capacity or zero, with the transition to the zero-capacity state occurring as a forced outage and characterized by a probability. The goal is to construct the Capacity Outage Probability Table (COPT), understood in this problem as the discrete probability distribution of total available capacity, and then assess the risk of demand shortfall by combining the available capacity distribution with a discrete load distribution for each time period. Proceed from fundamental definitions of independence and the laws of probability for discrete random variables. Do not use any shortcut formulas; instead, derive the computational method from first principles.\n\nDefinitions and assumptions:\n- Each unit $i$ has a nameplate capacity $c_i$ in megawatts (MW) and an independent Forced Outage Rate (FOR) $q_i$, meaning the unit produces either $c_i$ MW with probability $1-q_i$ or $0$ MW with probability $q_i$.\n- Independence across units implies the joint probability that a given subset is available and the rest are in forced outage equals the product of their individual probabilities.\n- The Capacity Outage Probability Table (COPT) for this problem should be treated as the discrete probability mass function (PMF) of the total available capacity $A$, obtained by combining the binary availability outcomes of all units.\n- For each time period $t$, the load $L_t$ is represented by a discrete PMF over finitely many load levels in MW. The Loss of Load Probability (LOLP) at time $t$, denoted $LOLP_t$, is the probability that the available capacity $A$ is strictly less than the load $L_t$ when both are modeled as discrete random variables. The output for each time period must be a decimal fraction.\n\nYour program must:\n1. Construct the discrete PMF for the total available capacity $A$ by sequentially combining each unit's two-state availability model using the rules for independent discrete random variables.\n2. From the distribution of available capacity, compute $LOLP_t$ for each time period $t$ by combining the capacity distribution with the load distribution using the standard rules of probability for discrete random variables (without relying on any pre-given formula).\n3. Express all capacities in megawatts (MW) and all probabilities as decimal fractions. No percentage signs should be used anywhere.\n4. Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list of $LOLP_t$ values for the corresponding test case.\n\nTest suite:\n- Test Case $1$ (general case):\n  - Units: $\\{(c_1,q_1)=(50,0.05),(c_2,q_2)=(30,0.10),(c_3,q_3)=(20,0.10),(c_4,q_4)=(10,0.20)\\}$ with capacities in MW and FORs as decimal fractions.\n  - Time periods and load PMFs (MW, decimal probability):\n    - $t=1$: $\\{(90,0.6),(100,0.3),(110,0.1)\\}$.\n    - $t=2$: $\\{(70,0.5),(80,0.4),(90,0.1)\\}$.\n    - $t=3$: $\\{(100,0.4),(115,0.4),(120,0.2)\\}$.\n- Test Case $2$ (boundary case with perfect reliability):\n  - Units: $\\{(c_1,q_1)=(40,0.0),(c_2,q_2)=(40,0.0),(c_3,q_3)=(20,0.0)\\}$.\n  - Time periods and load PMFs (MW, decimal probability):\n    - $t=1$: $\\{(50,0.5),(60,0.3),(70,0.2)\\}$.\n    - $t=2$: $\\{(80,0.6),(90,0.4)\\}$.\n- Test Case $3$ (edge case with identical units and substantial outages):\n  - Units: six identical units $\\{(c_i,q_i)=(15,0.2)\\text{ for }i=1,2,3,4,5,6\\}$.\n  - Time periods and load PMFs (MW, decimal probability):\n    - $t=1$: $\\{(80,0.5),(85,0.3),(90,0.2)\\}$.\n    - $t=2$: $\\{(30,0.7),(60,0.2),(95,0.1)\\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and is itself a list of decimal fractions $[LOLP_1,LOLP_2,\\dots]$ for the time periods in that case. For example, a valid overall output format is $[[x_1,x_2,x_3],[y_1,y_2],[z_1,z_2]]$, where each $x_k$, $y_k$, and $z_k$ is a decimal fraction.",
            "solution": "The problem requires the calculation of the Loss of Load Probability ($LOLP_t$) for a power system at different time periods $t$. The system consists of several independent generating units, and for each time period, there is a discrete probability distribution for the electrical load. The solution must be derived from fundamental principles of probability theory. The process is logically divided into two primary steps: first, constructing the probability distribution for the total available generating capacity, and second, using this distribution along with the load distribution to compute the probability of a shortfall.\n\n### Step 1: Construction of the Capacity Outage Probability Table (COPT)\n\nThe COPT is defined as the discrete probability mass function (PMF) of the total available capacity, denoted by the random variable $A$. Each of the $N$ generating units is an independent two-state device. Unit $i$ provides capacity $c_i$ with probability $p_i = 1 - q_i$ (the unit is available) and capacity $0$ with probability $q_i$ (the unit is in a forced outage), where $q_i$ is its Forced Outage Rate (FOR).\n\nLet $G_i$ be the random variable representing the capacity of unit $i$. The PMF of $G_i$ is given by:\n$$ P(G_i=x) = \\begin{cases} p_i = 1-q_i & \\text{ if } x=c_i \\\\ q_i & \\text{ if } x=0 \\\\ 0 & \\text{ otherwise} \\end{cases} $$\nThe total available capacity $A$ is the sum of the capacities of all individual units:\n$$ A = \\sum_{i=1}^{N} G_i $$\nSince all units are statistically independent, the random variables $G_1, G_2, \\dots, G_N$ are independent. A fundamental theorem of probability states that the PMF of a sum of independent discrete random variables is the discrete convolution of their individual PMFs.\n\nWe can construct the PMF for $A$ iteratively. Let $D_k$ denote the PMF of the cumulative capacity $A_k = \\sum_{i=1}^{k} G_i$ of the first $k$ units. $D_k$ can be represented as a set of (capacity, probability) pairs, $\\{(a, P(A_k=a))\\}$.\n\nThe algorithm begins with a base case of zero units. The PMF for a system with no generators, $D_0$, is trivial: there is a total capacity of $0$ MW with a probability of $1$.\n$$ D_0 = \\{(0, 1.0)\\} $$\nNow, we derive the PMF for $k$ units, $D_k$, from the PMF for $k-1$ units, $D_{k-1}$, by incorporating unit $k$. This is equivalent to computing the convolution of $D_{k-1}$ and the PMF of $G_k$. Let $(a', P(A_{k-1}=a'))$ be an arbitrary state in $D_{k-1}$. When we add unit $k$, there are two possibilities due to independence:\n$1$. Unit $k$ is on outage (capacity $0$, probability $q_k$). The new total capacity is $a' + 0 = a'$, and the probability of this joint event is $P(A_{k-1}=a') \\cdot q_k$.\n$2$. Unit $k$ is available (capacity $c_k$, probability $p_k = 1 - q_k$). The new total capacity is $a' + c_k$, and the probability of this joint event is $P(A_{k-1}=a') \\cdot p_k$.\n\nThis process is applied to all states in $D_{k-1}$ to generate the states of $D_k$. If multiple paths lead to the same total capacity value, their probabilities are summed. This iterative convolution is performed for all $N$ units, resulting in the final PMF, $D_N$, which is the COPT for the entire system.\n\n### Step 2: Calculation of the Loss of Load Probability (LOLP)\n\nThe $LOLP_t$ for a given time period $t$ is defined as the probability that the total available capacity $A$ is strictly less than the load $L_t$.\n$$ LOLP_t = P(A < L_t) $$\nBoth $A$ and $L_t$ are discrete random variables, and they are assumed to be independent. The PMF of $A$ is the COPT we derived, and the PMF for $L_t$ is given for each time period, consisting of pairs $(l_j, P(L_t=l_j))$.\n\nTo compute $P(A < L_t)$, we apply the law of total probability, conditioning on the possible values of the load $L_t$.\n$$ LOLP_t = P(A < L_t) = \\sum_{j} P(A < L_t \\mid L_t = l_j) \\cdot P(L_t = l_j) $$\nBecause $A$ and $L_t$ are independent, the conditional probability $P(A < L_t \\mid L_t = l_j)$ simplifies to the unconditional probability $P(A < l_j)$. Thus, the expression becomes:\n$$ LOLP_t = \\sum_{j} P(A < l_j) \\cdot P(L_t = l_j) $$\nThis formula provides a clear algorithm. For each possible load level $l_j$ with probability $P(L_t=l_j)$:\n$1$. We calculate the probability that the available capacity is insufficient to meet this specific load, $P(A < l_j)$.\n$2$. This probability is found by summing the probabilities of all capacity states $(a, P(A=a))$ in the COPT where the capacity $a$ is strictly less than the load level $l_j$.\n$$ P(A < l_j) = \\sum_{a < l_j} P(A=a) $$\n$3$. The value $P(A < l_j)$ is then weighted by the probability of that load level occurring, $P(L_t=l_j)$.\n$4$. The final $LOLP_t$ is the sum of these weighted probabilities over all possible load levels $j$.\n\nThis two-step, principle-based procedure correctly computes the required reliability index without recourse to pre-established, un-derived formulas. The implementation will directly follow this logic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef build_copt(units):\n    \"\"\"\n    Constructs the Capacity Outage Probability Table (COPT) from first principles.\n\n    The COPT is the discrete probability mass function (PMF) of the total\n    available capacity. It is built by iteratively convolving the PMF of the\n    existing system with the PMF of each new unit.\n\n    Args:\n        units (list of tuples): A list where each tuple is (capacity, FOR),\n                                representing a generating unit.\n\n    Returns:\n        dict: A dictionary representing the COPT, where keys are capacity\n              levels (float) and values are their probabilities (float).\n    \"\"\"\n    # Base case: A system with 0 units has 0 capacity with probability 1.0.\n    # We use a defaultdict to simplify adding probabilities for new capacity states.\n    copt = defaultdict(float)\n    copt[0.0] = 1.0\n\n    # Iteratively add each unit to the system.\n    for capacity, forced_outage_rate in units:\n        new_copt = defaultdict(float)\n        prob_available = 1.0 - forced_outage_rate\n\n        # For each existing capacity state in the current COPT...\n        for existing_cap, existing_prob in copt.items():\n            # Case 1: The new unit is in a forced outage (capacity 0).\n            # The total capacity remains the same.\n            prob_outage = forced_outage_rate\n            new_copt[existing_cap] += existing_prob * prob_outage\n\n            # Case 2: The new unit is available (capacity c_i).\n            # The total capacity increases by c_i.\n            new_capacity = existing_cap + capacity\n            new_copt[new_capacity] += existing_prob * prob_available\n        \n        copt = new_copt\n\n    return dict(copt)\n\ndef calculate_lolp(copt, load_pmf):\n    \"\"\"\n    Calculates the Loss of Load Probability (LOLP) from first principles.\n\n    LOLP is the probability that available capacity is less than the load.\n    It is computed using the law of total probability, summing over all\n    possible load levels. LOLP_t = sum_j(P(A  l_j) * P(L_t = l_j)).\n\n    Args:\n        copt (dict): The COPT of the system (PMF of available capacity).\n        load_pmf (dict): The PMF of the load for a given time period.\n\n    Returns:\n        float: The calculated LOLP for the period.\n    \"\"\"\n    total_lolp = 0.0\n\n    # For each discrete load level and its probability...\n    for load_level, load_prob in load_pmf.items():\n        # Calculate P(Capacity  load_level).\n        prob_capacity_less_than_load = 0.0\n        for capacity, cap_prob in copt.items():\n            if capacity  load_level:\n                prob_capacity_less_than_load += cap_prob\n\n        # Add the contribution of this load level to the total LOLP.\n        total_lolp += prob_capacity_less_than_load * load_prob\n\n    return total_lolp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"units\": [(50, 0.05), (30, 0.10), (20, 0.10), (10, 0.20)],\n            \"loads\": [\n                {90: 0.6, 100: 0.3, 110: 0.1},\n                {70: 0.5, 80: 0.4, 90: 0.1},\n                {100: 0.4, 115: 0.4, 120: 0.2},\n            ]\n        },\n        {\n            \"units\": [(40, 0.0), (40, 0.0), (20, 0.0)],\n            \"loads\": [\n                {50: 0.5, 60: 0.3, 70: 0.2},\n                {80: 0.6, 90: 0.4},\n            ]\n        },\n        {\n            \"units\": [(15, 0.2)] * 6,\n            \"loads\": [\n                {80: 0.5, 85: 0.3, 90: 0.2},\n                {30: 0.7, 60: 0.2, 95: 0.1},\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Step 1: Construct the Capacity Outage Probability Table (COPT)\n        units = case[\"units\"]\n        copt = build_copt(units)\n        \n        case_lolps = []\n        # Step 2: For each time period, calculate the LOLP\n        for load_pmf in case[\"loads\"]:\n            lolp = calculate_lolp(copt, load_pmf)\n            case_lolps.append(lolp)\n        \n        all_results.append(case_lolps)\n\n    # Format the final output string precisely as required.\n    # e.g., [[x1,x2],[y1,y2]] without extra spaces.\n    case_results_str = [f\"[{','.join(map(str, lolp_list))}]\" for lolp_list in all_results]\n    final_output_str = f\"[{','.join(case_results_str)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "With a firm grasp of baseline reliability, we can now explore the nuanced behavior of ELCC itself. This practice uses a stylized model to reveal how the average ELCC of a resource portfolio changes as its penetration grows, a critical concept in long-term planning. By analyzing the portfolio's evolving impact on risk hours (), you will uncover the dynamics of portfolio synergy and saturation, which together explain the fundamental principle of diminishing marginal returns for variable generation.",
            "id": "4087102",
            "problem": "Consider a stylized adequacy model for a power system using the Loss Of Load Expectation (LOLE) framework. There are three representative hours indexed by $t \\in \\{1,2,3\\}$, where hours $t=1$ and $t=2$ are risk hours with nonzero shortfall probabilities, and hour $t=3$ is a non-risk hour. Baseline hourly shortfall probabilities are $p_1 = 0.5$, $p_2 = 0.4$, and $p_3 = 0$. Near the adequacy threshold, the reduction in the hour-$t$ shortfall probability caused by a small net-load shift of magnitude $q_t$ is approximated by $f_t \\, q_t$ up to saturation, where $f_t$ is the tail probability density at the threshold. Take $f_1 = 0.5$, $f_2 = 0.1$, and $f_3 = 0$. Assume reductions saturate at the baseline probability in each hour, that is, the reduction in hour $t$ cannot exceed $p_t$.\n\nA portfolio of $N$ variable renewable resource units is added, with unit $i$ producing deterministic net-load reductions $\\{y_{i,1},y_{i,2},y_{i,3}\\}$ over the three hours. The five candidate units have the following hourly vectors (all components are nonnegative real-valued and represent megawatts of net-load reduction): unit $1$ has $\\{0.8,\\;0.5,\\;2.0\\}$, unit $2$ has $\\{0.3,\\;2.0,\\;1.5\\}$, unit $3$ has $\\{0.0,\\;1.5,\\;2.5\\}$, unit $4$ has $\\{0.0,\\;0.0,\\;3.0\\}$, and unit $5$ has $\\{0.0,\\;0.0,\\;3.5\\}$. The net-load reductions in the non-risk hour $t=3$ do not affect LOLE.\n\nLet the Effective Load Carrying Capability (ELCC) be defined via the Equivalent Firm Capacity (EFC): for a given $N$, the EFC $x(N)$ is the perfectly reliable firm capacity (in megawatts) that, when added to the baseline system, yields the same total reduction in LOLE as adding the $N$ variable units. Under the linearized tail approximation, adding firm capacity $x$ shifts the threshold in each hour equally by $x$; thus the LOLE reduction with firm capacity $x$ is $\\sum_{t=1}^{3} \\min\\{f_t x,\\; p_t\\}$.\n\nTasks:\n- Using only the definitions above and first-principles reasoning from the LOLE reduction model, compute $x(N)$ for $N \\in \\{1,2,3,4,5\\}$ by equating the LOLE reduction from the $N$ units to the LOLE reduction from firm capacity $x$. Express $x(N)$ in $\\text{MW}$.\n- Define the average ELCC per unit as $\\bar{x}(N) = x(N)/N$ and evaluate it for $N \\in \\{1,2,3,4,5\\}$.\n- Determine the integer $N^{\\star}$ in $\\{1,2,3,4,5\\}$ at which $\\bar{x}(N)$ attains its maximum. Give $N^{\\star}$ as an integer, with no rounding required.\n- In your solution, explain the turning point conditions in terms of the saturation of LOLE in the risk hours and the presence of surplus net-load reduction outside risk intervals.\n\nYour final answer must be the single integer $N^{\\star}$.",
            "solution": "The problem requires the determination of the optimal number of variable renewable resource units, $N^{\\star}$, that maximizes the average Effective Load Carrying Capability (ELCC) per unit. This involves calculating the ELCC for a sequence of portfolios and identifying the maximum of the per-unit average. The ELCC, denoted as $x(N)$, is defined as the Equivalent Firm Capacity (EFC) that provides the same total reduction in Loss Of Load Expectation (LOLE) as a portfolio of $N$ units.\n\nFirst, we formalize the LOLE reduction expressions. The problem is set in a stylized model with three hours, $t \\in \\{1, 2, 3\\}$. The baseline shortfall probabilities are $p_1 = 0.5$, $p_2 = 0.4$, and $p_3 = 0$. The sensitivity of shortfall probability to net-load reduction is given by the tail densities $f_1 = 0.5$, $f_2 = 0.1$, and $f_3 = 0$.\n\nThe total LOLE reduction from a portfolio of $N$ units is the sum of the hourly shortfall probability reductions, limited by the baseline probabilities. Let $Y_t(N) = \\sum_{i=1}^{N} y_{i,t}$ be the total net-load reduction in hour $t$ from the first $N$ units. The LOLE reduction is:\n$$ \\Delta \\text{LOLE}_{\\text{portfolio}}(N) = \\sum_{t=1}^{3} \\min\\left(f_t Y_t(N), p_t\\right) $$\nSince $f_3 = 0$ and $p_3 = 0$, the third term is always zero. Thus, we only consider the two risk hours:\n$$ \\Delta \\text{LOLE}_{\\text{portfolio}}(N) = \\min\\left(f_1 Y_1(N), p_1\\right) + \\min\\left(f_2 Y_2(N), p_2\\right) $$\n\nThe LOLE reduction from an amount of firm capacity $x$ is similarly defined:\n$$ \\Delta \\text{LOLE}_{\\text{firm}}(x) = \\sum_{t=1}^{3} \\min\\left(f_t x, p_t\\right) = \\min\\left(f_1 x, p_1\\right) + \\min\\left(f_2 x, p_2\\right) $$\nBy definition, the EFC $x(N)$ satisfies $\\Delta \\text{LOLE}_{\\text{firm}}(x(N)) = \\Delta \\text{LOLE}_{\\text{portfolio}}(N)$.\n\nLet us first calculate the cumulative net-load reductions $Y_t(N)$ for $t \\in \\{1, 2\\}$ and $N \\in \\{1, 2, 3, 4, 5\\}$. The unit vectors for the risk hours are:\nUnit $1$: $\\{y_{1,1}, y_{1,2}\\} = \\{0.8, 0.5\\}$\nUnit $2$: $\\{y_{2,1}, y_{2,2}\\} = \\{0.3, 2.0\\}$\nUnit $3$: $\\{y_{3,1}, y_{3,2}\\} = \\{0.0, 1.5\\}$\nUnit $4$: $\\{y_{4,1}, y_{4,2}\\} = \\{0.0, 0.0\\}$\nUnit $5$: $\\{y_{5,1}, y_{5,2}\\} = \\{0.0, 0.0\\}$\n\nThe cumulative vectors $\\{Y_1(N), Y_2(N)\\}$ are:\nFor $N=1$: $\\{0.8, 0.5\\}$\nFor $N=2$: $\\{0.8+0.3, 0.5+2.0\\} = \\{1.1, 2.5\\}$\nFor $N=3$: $\\{1.1+0.0, 2.5+1.5\\} = \\{1.1, 4.0\\}$\nFor $N=4$: $\\{1.1+0.0, 4.0+0.0\\} = \\{1.1, 4.0\\}$\nFor $N=5$: $\\{1.1+0.0, 4.0+0.0\\} = \\{1.1, 4.0\\}$\n\nNow, we compute $\\Delta \\text{LOLE}_{\\text{portfolio}}(N)$ for each $N$ using $f_1=0.5, p_1=0.5$ and $f_2=0.1, p_2=0.4$:\nFor $N=1$: $\\min(0.5 \\times 0.8, 0.5) + \\min(0.1 \\times 0.5, 0.4) = \\min(0.4, 0.5) + \\min(0.05, 0.4) = 0.4 + 0.05 = 0.45$.\nFor $N=2$: $\\min(0.5 \\times 1.1, 0.5) + \\min(0.1 \\times 2.5, 0.4) = \\min(0.55, 0.5) + \\min(0.25, 0.4) = 0.5 + 0.25 = 0.75$.\nIn this step, the contribution from hour $1$ saturates, i.e., it reaches its maximum possible value of $p_1 = 0.5$.\nFor $N=3$: $\\min(0.5 \\times 1.1, 0.5) + \\min(0.1 \\times 4.0, 0.4) = \\min(0.55, 0.5) + \\min(0.4, 0.4) = 0.5 + 0.4 = 0.9$.\nNow, the contribution from hour $2$ also saturates at $p_2 = 0.4$. The total LOLE reduction has reached its theoretical maximum of $p_1+p_2 = 0.9$.\nFor $N=4$: Since $Y(4) = Y(3)$, $\\Delta \\text{LOLE}_{\\text{portfolio}}(4) = 0.9$.\nFor $N=5$: Since $Y(5) = Y(4)$, $\\Delta \\text{LOLE}_{\\text{portfolio}}(5) = 0.9$.\n\nNext, we find $x(N)$ by solving $\\Delta \\text{LOLE}_{\\text{firm}}(x(N)) = \\Delta \\text{LOLE}_{\\text{portfolio}}(N)$. We analyze the function $\\Delta \\text{LOLE}_{\\text{firm}}(x) = \\min(0.5x, 0.5) + \\min(0.1x, 0.4)$.\nThe saturation points for firm capacity $x$ are:\nHour $1$: $0.5x = 0.5 \\implies x = 1$.\nHour $2$: $0.1x = 0.4 \\implies x = 4$.\nThe function $\\Delta \\text{LOLE}_{\\text{firm}}(x)$ is piecewise linear:\n- If $0 \\le x \\le 1$: $\\Delta \\text{LOLE}_{\\text{firm}}(x) = 0.5x + 0.1x = 0.6x$.\n- If $1  x \\le 4$: $\\Delta \\text{LOLE}_{\\text{firm}}(x) = 0.5 + 0.1x$.\n- If $x  4$: $\\Delta \\text{LOLE}_{\\text{firm}}(x) = 0.5 + 0.4 = 0.9$.\n\nNow we find each $x(N)$ by inverting this function:\n- $x(1)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(1) = 0.45$. This falls in the range of the first regime ($0.45 \\le 0.6$).\n  $0.6 x(1) = 0.45 \\implies x(1) = \\frac{0.45}{0.6} = \\frac{45}{60} = \\frac{3}{4} = 0.75$ MW.\n- $x(2)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(2) = 0.75$. This falls in the range of the second regime ($0.6  0.75 \\le 0.9$).\n  $0.5 + 0.1 x(2) = 0.75 \\implies 0.1 x(2) = 0.25 \\implies x(2) = 2.5$ MW.\n- $x(3)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(3) = 0.9$. This is the saturation point of the second regime.\n  $0.5 + 0.1 x(3) = 0.9 \\implies 0.1 x(3) = 0.4 \\implies x(3) = 4.0$ MW.\n- $x(4)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(4) = 0.9$. Since the LOLE reduction is unchanged, $x(4) = x(3) = 4.0$ MW.\n- $x(5)$: $\\Delta \\text{LOLE}_{\\text{portfolio}}(5) = 0.9$. Similarly, $x(5) = 4.0$ MW.\n\nFinally, we compute the average ELCC per unit, $\\bar{x}(N) = x(N)/N$:\n- $\\bar{x}(1) = \\frac{0.75}{1} = 0.75$ MW/unit.\n- $\\bar{x}(2) = \\frac{2.5}{2} = 1.25$ MW/unit.\n- $\\bar{x}(3) = \\frac{4.0}{3} \\approx 1.333$ MW/unit.\n- $\\bar{x}(4) = \\frac{4.0}{4} = 1.0$ MW/unit.\n- $\\bar{x}(5) = \\frac{4.0}{5} = 0.8$ MW/unit.\n\nComparing these values, the maximum average ELCC is $\\bar{x}(3) = \\frac{4}{3}$. The integer $N$ at which this maximum occurs is $N^{\\star}=3$.\n\nThe behavior of $\\bar{x}(N)$ demonstrates key properties of ELCC. The increase from $N=1$ to $N=2$ and then to $N=3$ reflects a portfolio or synergy effect: the units' outputs are complementary in time, efficiently reducing LOLE across different risk hours. Unit $1$ is effective in hour $1$, while units $2$ and $3$ are effective in hour $2$. The turning point occurs at $N^{\\star}=3$. This is precisely the point where the portfolio's contribution to LOLE reduction saturates in all available risk hours, meaning the system can absorb no more risk reduction benefit. All subsequent units ($4$ and $5$) provide \"surplus\" net-load reduction only in the non-risk hour $t=3$, where $f_3=0$. This surplus capacity contributes nothing to LOLE reduction. Consequently, for $N  3$, the total ELCC $x(N)$ remains constant at its maximum value of $4.0$ MW, while the denominator $N$ increases. This leads to a decline in the average ELCC $\\bar{x}(N)$, a classic illustration of diminishing marginal returns for capacity additions in resource adequacy assessments. The maximum average value is therefore achieved at the threshold of full system saturation.\n\nThe integer $N^{\\star}$ that maximizes $\\bar{x}(N)$ is $3$.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "This final practice bridges theory and application by demonstrating why the distinction between average and marginal ELCC is critically important for energy policy and economics. You will simulate two different capacity market accreditation schemes—one based on a simplified average ELCC and another on a more accurate marginal ELCC—to meet a specific reliability target. By quantifying the resulting inefficiency in investment outcomes (), this exercise reveals how seemingly small differences in resource valuation methods can lead to a less reliable or more costly power system.",
            "id": "4087056",
            "problem": "You are asked to build a complete, runnable program that models Effective Load Carrying Capability (ELCC) for variable renewable energy resources and compares average versus marginal ELCC accreditation in a stylized capacity market. The aim is to explain, in computational terms, the implications of using average versus marginal ELCC for resource accreditation and to quantify the potential inefficiencies in investment decisions, expressed as an energy reliability gap.\n\nBegin from the following fundamental base in energy systems modeling:\n- Reliability is quantified via Energy Not Served (ENS), defined on a discrete time series as the sum of hourly deficits. Let $T$ denote the number of hours, let $L_t$ denote the load in hour $t$, let $C$ denote the firm capacity in megawatts (MW), and let $R_t$ denote the resource output in MW in hour $t$. The Energy Not Served is $$\\mathrm{ENS} = \\sum_{t=1}^{T} \\max(L_t - C - R_t, 0).$$ This definition reflects a widely accepted reliability metric that aggregates unmet demand across time, measured in megawatt-hours (MWh) when hourly resolution is used.\n- The Effective Load Carrying Capability (ELCC) of an added resource portfolio is defined as the constant load increase in megawatts, denoted by $x$, such that the Energy Not Served with the resource and the additional load equals the baseline Energy Not Served without the resource. Formally, if $\\mathrm{ENS}_0$ is the baseline Energy Not Served with resource output identically zero, and $\\mathrm{ENS}(x)$ is the Energy Not Served when load is increased by $x$ and the resource output is present, then ELCC is the value $x$ satisfying $$\\mathrm{ENS}(x) = \\mathrm{ENS}_0.$$\n- Average ELCC refers to using the ratio of the ELCC of a finite amount of a resource to its nameplate capacity, applied uniformly to all increments for capacity accreditation. Marginal ELCC refers to the incremental ELCC per MW at the current penetration level, applied to each incremental MW.\n\nYour program must implement the following, strictly from these fundamentals, without using any specialized shortcut formulas:\n1. Model the system on an hourly basis using arrays for $L_t$ (in MW), $C$ (in MW), and per-MW output profiles for two resource types, solar and wind, denoted by $s_t$ and $w_t$, respectively. The output of the solar resource for $N_{\\mathrm{s}}$ MW nameplate is $N_{\\mathrm{s}} \\cdot s_t$, and similarly for wind with $N_{\\mathrm{w}} \\cdot w_t$.\n2. Compute baseline Energy Not Served, $\\mathrm{ENS}_0$, using the definition above with $N_{\\mathrm{s}} = 0$ and $N_{\\mathrm{w}} = 0$.\n3. Define a function that, for given $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$, finds the ELCC value $x$ (in MW) such that the Energy Not Served with $L_t + x$ and resource output $N_{\\mathrm{s}} \\cdot s_t + N_{\\mathrm{w}} \\cdot w_t$ equals $\\mathrm{ENS}_0$. You must determine $x$ by solving the equality numerically using a robust search method over $x \\ge 0$.\n4. Compute an average ELCC accreditation fraction for each resource type using a class reference penetration, $N_{\\mathrm{s}}^{\\mathrm{ref}}$ for solar and $N_{\\mathrm{w}}^{\\mathrm{ref}}$ for wind, defined as the ratio $\\frac{\\text{ELCC}(N_{\\mathrm{s}}^{\\mathrm{ref}}, 0)}{N_{\\mathrm{s}}^{\\mathrm{ref}}}$ for solar and $\\frac{\\text{ELCC}(0, N_{\\mathrm{w}}^{\\mathrm{ref}})}{N_{\\mathrm{w}}^{\\mathrm{ref}}}$ for wind. These fractions are used as fixed accreditation rates per MW under the average ELCC scheme.\n5. Implement two investment decision processes to meet a target accredited capacity requirement $K$ (in MW), given costs $p_{\\mathrm{s}}$ and $p_{\\mathrm{w}}$ per MW nameplate for solar and wind:\n   - Under the average ELCC accreditation scheme, assign fixed accreditation rates to each resource type from step $4$. Choose the resource type with the lowest cost per accredited MW, i.e., the minimum of $\\frac{p_{\\mathrm{s}}}{\\text{avg\\_frac}_{\\mathrm{s}}}$ and $\\frac{p_{\\mathrm{w}}}{\\text{avg\\_frac}_{\\mathrm{w}}}$, and invest in integer MW increments of that single type until the sum of accredited capacity (fixed rate times invested nameplate) reaches or exceeds $K$.\n   - Under the marginal ELCC accreditation scheme, proceed in integer MW increments. At each increment, compute the marginal ELCC per MW for solar as $\\text{ELCC}(N_{\\mathrm{s}}+1, N_{\\mathrm{w}}) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$ and for wind as $\\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}}+1) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$. Choose the resource type with the lowest cost per marginally accredited MW, i.e., the minimum of $\\frac{p_{\\mathrm{s}}}{\\Delta \\text{ELCC}_{\\mathrm{s}}}$ and $\\frac{p_{\\mathrm{w}}}{\\Delta \\text{ELCC}_{\\mathrm{w}}}$, and invest $1$ MW of that type. Accumulate the accredited capacity by adding the corresponding marginal ELCC at each step until reaching or exceeding $K$.\n6. After completing procurement under each scheme, compute the realized Energy Not Served by evaluating the definition with the invested resource outputs and no load increase (i.e., $x = 0$). Define the investment inefficiency for the average scheme relative to the marginal scheme as the realized Energy Not Served gap in MWh: $$\\Delta \\mathrm{ENS} = \\mathrm{ENS}_{\\mathrm{avg}} - \\mathrm{ENS}_{\\mathrm{marg}}.$$\n7. For each test case, report $\\Delta \\mathrm{ENS}$ in megawatt-hours (MWh), rounded to three decimal places.\n\nUse the following test suite. Each test case provides the arrays and parameters. All arrays are hourly with $T = 24$ hours. All capacities are in MW, costs are in arbitrary cost units per MW nameplate, and Energy Not Served is in MWh at hourly resolution.\n\nCommon time series for all test cases:\n- Load vector $L_t$ for $t = 1, \\dots, 24$:\n  $\\{\\, $90$, $88$, $87$, $86$, $86$, $88$, $92$, $95$, $97$, $94$, $92$, $91$, $92$, $94$, $96$, $99$, $102$, $105$, $106$, $103$, $98$, $95$, $93$, $91$ \\,\\}$.\n- Firm capacity $C = $95$.\n- Solar per-MW output profile $s_t$:\n  $\\{\\, $0$, $0$, $0$, $0$, $0$, $0$, $0.1$, $0.2$, $0.5$, $0.7$, $0.8$, $0.9$, $0.9$, $0.8$, $0.6$, $0.3$, $0.1$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ \\,\\}$.\n- Wind per-MW output profile $w_t$:\n  $\\{\\, $0.5$, $0.5$, $0.5$, $0.45$, $0.4$, $0.35$, $0.3$, $0.25$, $0.2$, $0.2$, $0.25$, $0.3$, $0.3$, $0.35$, $0.4$, $0.45$, $0.5$, $0.55$, $0.6$, $0.55$, $0.5$, $0.45$, $0.4$, $0.4$ \\,\\}$.\n- Reference penetrations for average ELCC accreditation: $N_{\\mathrm{s}}^{\\mathrm{ref}} = $40$, $N_{\\mathrm{w}}^{\\mathrm{ref}} = $40$.\n- Costs per MW nameplate: $p_{\\mathrm{s}} = $0.3$, $p_{\\mathrm{w}} = $0.8$.\n\nTest cases:\n- Case $1$: Target accredited capacity $K = $20$ MW.\n- Case $2$: Target accredited capacity $K = $2$ MW (boundary case to assess near-zero penetration behavior).\n- Case $3$: Target accredited capacity $K = $60$ MW (edge case to assess saturation effects and sharply declining marginal ELCC).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, with each entry being $\\Delta \\mathrm{ENS}$ in MWh rounded to three decimal places (e.g., \"[$1.234$,$0.000$,$5.678$]\").",
            "solution": "The problem requires a program to model and compare a system's reliability under two different capacity accreditation schemes for variable renewable energy: an average Effective Load Carrying Capability (ELCC) scheme and a marginal ELCC scheme. The goal is to quantify the inefficiency of the average scheme relative to the marginal one, measured by a gap in the realized Energy Not Served ($\\mathrm{ENS}$).\n\n### 1. Algorithmic Design and Principles\n\nThe solution is constructed by implementing a series of functions that correspond to the physical and economic principles outlined in the problem.\n\n**A. Core Reliability Functions**\n\n1.  **Energy Not Served ($\\mathrm{ENS}$)**: The function `calculate_ens` directly implements the given formula. It takes numpy arrays for load, capacity, and generation, and computes the sum of hourly energy deficits. This function quantifies the system's inability to meet demand.\n    $$ \\mathrm{ENS}(L, C, R) = \\sum_{t=1}^{T} \\max(L_t - C - R_t, 0) $$\n\n2.  **Effective Load Carrying Capability (ELCC)**: The function `find_elcc` computes the ELCC for a given portfolio $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$. This is the central numerical task. We first compute the baseline $\\mathrm{ENS}_0$ for the system with zero renewable generation ($R_t=0$). Then, for the given $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$, we seek the load increment $x$ that restores the $\\mathrm{ENS}$ to this baseline level. This is a root-finding problem for the objective function:\n    $$ f(x) = \\mathrm{ENS}(L_t + x, C, N_{\\mathrm{s}}s_t + N_{\\mathrm{w}}w_t) - \\mathrm{ENS}_0 = 0 $$\n    Given that $f(x)$ is monotonic, a bisection search algorithm is employed. We search for $x$ in a bounded interval, for example $[0, L_{\\max}]$, where $L_{\\max}$ is the peak load.\n\n**B. Investment Schemes**\n\nThe program then models two distinct investment strategies to meet a target accredited capacity, $K$.\n\n1.  **Average ELCC Scheme**: This scheme uses a simplified, fixed accreditation rate for each resource type, based on its performance at a single reference penetration level.\n    *   First, we calculate the ELCC for solar and wind individually at their reference capacities: $x_{\\mathrm{s}}^{\\mathrm{ref}} = \\text{ELCC}(N_{\\mathrm{s}}^{\\mathrm{ref}}, 0)$ and $x_{\\mathrm{w}}^{\\mathrm{ref}} = \\text{ELCC}(0, N_{\\mathrm{w}}^{\\mathrm{ref}})$.\n    *   The average accreditation fractions are then $\\alpha_{\\mathrm{s}} = x_{\\mathrm{s}}^{\\mathrm{ref}} / N_{\\mathrm{s}}^{\\mathrm{ref}}$ and $\\alpha_{\\mathrm{w}} = x_{\\mathrm{w}}^{\\mathrm{ref}} / N_{\\mathrm{w}}^{\\mathrm{ref}}$.\n    *   The effective cost per accredited MW is computed as $p_{\\mathrm{s}} / \\alpha_{\\mathrm{s}}$ for solar and $p_{\\mathrm{w}} / \\alpha_{\\mathrm{w}}$ for wind.\n    *   The model invests exclusively in the resource with the lower effective cost. The required nameplate capacity $N$ is calculated to just meet the target: $N = \\lceil K / \\alpha \\rceil$, where $\\alpha$ is the fraction for the chosen resource.\n\n2.  **Marginal ELCC Scheme**: This scheme reflects a more sophisticated market where each incremental megawatt of capacity is valued based on its marginal contribution to reliability at the current system state. This is an iterative, greedy optimization process.\n    *   Starting with zero capacity ($N_{\\mathrm{s}}=0, N_{\\mathrm{w}}=0$), the total accredited capacity, which is the portfolio's ELCC, is also zero.\n    *   In each step, we calculate the marginal ELCC of adding $1$ MW of solar versus $1$ MW of wind.\n        *   $\\Delta \\text{ELCC}_{\\mathrm{s}} = \\text{ELCC}(N_{\\mathrm{s}}+1, N_{\\mathrm{w}}) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$\n        *   $\\Delta \\text{ELCC}_{\\mathrm{w}} = \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}}+1) - \\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$\n    *   The effective marginal costs are $p_{\\mathrm{s}} / \\Delta \\text{ELCC}_{\\mathrm{s}}$ and $p_{\\mathrm{w}} / \\Delta \\text{ELCC}_{\\mathrm{w}}$.\n    *   The model adds $1$ MW of the resource with the lower marginal cost.\n    *   The portfolio $(N_{\\mathrm{s}}, N_{\\mathrm{w}})$ is updated, and the total accredited capacity becomes the ELCC of the new portfolio.\n    *   This process repeats until the total accredited capacity, $\\text{ELCC}(N_{\\mathrm{s}}, N_{\\mathrm{w}})$, meets or exceeds the target $K$. This iterative approach captures the diminishing returns of each resource type and allows for cost-optimal portfolio diversification.\n\n**C. Inefficiency Quantification**\n\nFinally, for each of the three test cases ($K \\in \\{20, 2, 60\\}$), we perform the following:\n1.  Determine the final portfolios $(N_{\\mathrm{s, avg}}, N_{\\mathrm{w, avg}})$ and $(N_{\\mathrm{s, marg}}, N_{\\mathrm{w, marg}})$ from the two schemes.\n2.  Calculate the realized $\\mathrm{ENS}$ for each portfolio using the original load profile (i.e., with $x=0$).\n    *   $\\mathrm{ENS}_{\\mathrm{avg}} = \\mathrm{ENS}(L, C, N_{\\mathrm{s, avg}}s_t + N_{\\mathrm{w, avg}}w_t)$\n    *   $\\mathrm{ENS}_{\\mathrm{marg}} = \\mathrm{ENS}(L, C, N_{\\mathrm{s, marg}}s_t + N_{\\mathrm{w, marg}}w_t)$\n3.  The investment inefficiency is the difference: $\\Delta \\mathrm{ENS} = \\mathrm{ENS}_{\\mathrm{avg}} - \\mathrm{ENS}_{\\mathrm{marg}}$. A positive value indicates the average scheme resulted in a less reliable system for a given target capacity accreditation level, exposing a flaw in its simplified valuation.\nThe results for each case are collected and formatted as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Models and compares average vs. marginal ELCC accreditation for renewable\n    energy resources and quantifies the resulting investment inefficiency.\n    \"\"\"\n\n    # --- Common Data and Parameters ---\n    # Time series data (T=24 hours)\n    L_t = np.array([\n        90, 88, 87, 86, 86, 88, 92, 95, 97, 94, 92, 91, 92, 94, 96, 99, 102,\n        105, 106, 103, 98, 95, 93, 91\n    ], dtype=float)\n    s_t = np.array([\n        0, 0, 0, 0, 0, 0, 0.1, 0.2, 0.5, 0.7, 0.8, 0.9, 0.9, 0.8, 0.6, 0.3,\n        0.1, 0, 0, 0, 0, 0, 0, 0\n    ], dtype=float)\n    w_t = np.array([\n        0.5, 0.5, 0.5, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.2, 0.25, 0.3,\n        0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.55, 0.5, 0.45, 0.4, 0.4\n    ], dtype=float)\n\n    # System parameters\n    C = 95.0  # Firm capacity (MW)\n    N_s_ref = 40.0 # Solar reference penetration (MW)\n    N_w_ref = 40.0 # Wind reference penetration (MW)\n    p_s = 0.3      # Solar cost per MW\n    p_w = 0.8      # Wind cost per MW\n\n    # Test cases\n    test_cases = [\n        {\"K\": 20.0},  # Case 1\n        {\"K\": 2.0},   # Case 2\n        {\"K\": 60.0},  # Case 3\n    ]\n\n    # --- Core Functions ---\n\n    def calculate_ens(load, capacity, generation):\n        \"\"\"Calculates Energy Not Served (ENS) in MWh.\"\"\"\n        net_load = load - generation\n        deficit = np.maximum(net_load - capacity, 0)\n        return np.sum( deficit )\n\n    # Pre-calculate baseline ENS for efficiency\n    ENS_0 = calculate_ens(L_t, C, 0)\n\n    # Memoization cache for ELCC calculations to speed up repeated calls\n    elcc_cache = {}\n\n    def find_elcc(N_s, N_w):\n        \"\"\"Finds the ELCC for a given renewable portfolio (N_s, N_w).\"\"\"\n        \n        # Use a tuple of integers for the cache key\n        cache_key = (int(N_s), int(N_w))\n        if cache_key in elcc_cache:\n            return elcc_cache[cache_key]\n\n        if N_s == 0 and N_w == 0:\n            return 0.0\n\n        generation = N_s * s_t + N_w * w_t\n        \n        # Objective function for the root-finder: f(x) = ENS(x) - ENS_0\n        def objective_func(x):\n            return calculate_ens(L_t + x, C, generation) - ENS_0\n\n        # The ELCC must be non-negative. A safe upper bound for the search is the peak load.\n        # If adding the resource makes the system more reliable, objective_func(0) will be = 0.\n        if objective_func(0) >= 0:\n            # This case means the resource adds no reliability value, or negative value\n            # which is not expected but must be handled. ELCC is 0.\n            elcc_val = 0.0\n        else:\n            try:\n                elcc_val = bisect(objective_func, 0, np.max(L_t))\n            except ValueError:\n                # Can occur if objective_func(0) and objective_func(L_max) have the same sign.\n                # This could happen if the resource is so effective that ENS remains 0\n                # even with max load increase. In this problem context, it implies very high ELCC.\n                # However, for the given data, this is not expected. Default to 0 for robustness.\n                elcc_val = 0.0\n\n        elcc_cache[cache_key] = elcc_val\n        return elcc_val\n\n    # --- Investment Scheme Implementations ---\n\n    def average_elcc_investment(K):\n        \"\"\"Determines the investment portfolio under the average ELCC scheme.\"\"\"\n        elcc_s_ref = find_elcc(N_s_ref, 0)\n        avg_frac_s = elcc_s_ref / N_s_ref if N_s_ref > 0 else 0\n        \n        elcc_w_ref = find_elcc(0, N_w_ref)\n        avg_frac_w = elcc_w_ref / N_w_ref if N_w_ref > 0 else 0\n\n        cost_per_accredited_s = p_s / avg_frac_s if avg_frac_s > 0 else float('inf')\n        cost_per_accredited_w = p_w / avg_frac_w if avg_frac_w > 0 else float('inf')\n\n        if cost_per_accredited_s = cost_per_accredited_w:\n            # Invest in solar\n            nameplate_needed = np.ceil(K / avg_frac_s) if avg_frac_s > 0 else float('inf')\n            return nameplate_needed, 0.0\n        else:\n            # Invest in wind\n            nameplate_needed = np.ceil(K / avg_frac_w) if avg_frac_w > 0 else float('inf')\n            return 0.0, nameplate_needed\n\n    def marginal_elcc_investment(K):\n        \"\"\"Determines the investment portfolio under the marginal ELCC scheme.\"\"\"\n        N_s, N_w = 0, 0\n        current_elcc = 0.0  # ELCC(0,0) is 0\n\n        while current_elcc  K:\n            # Calculate marginal ELCC for solar\n            elcc_s_plus_1 = find_elcc(N_s + 1, N_w)\n            delta_elcc_s = elcc_s_plus_1 - current_elcc\n            cost_s = p_s / delta_elcc_s if delta_elcc_s > 1e-9 else float('inf')\n\n            # Calculate marginal ELCC for wind\n            elcc_w_plus_1 = find_elcc(N_s, N_w + 1)\n            delta_elcc_w = elcc_w_plus_1 - current_elcc\n            cost_w = p_w / delta_elcc_w if delta_elcc_w > 1e-9 else float('inf')\n            \n            # Choose the cheaper resource\n            if cost_s = cost_w:\n                N_s += 1\n                current_elcc = elcc_s_plus_1\n            else:\n                N_w += 1\n                current_elcc = elcc_w_plus_1\n            \n            # Handle edge case where no technology can provide positive marginal ELCC\n            if cost_s == float('inf') and cost_w == float('inf'):\n                break\n\n        return float(N_s), float(N_w)\n\n    # --- Main Execution Loop ---\n    results = []\n    for case in test_cases:\n        K = case[\"K\"]\n        elcc_cache.clear() # Clear cache for each independent K trial\n\n        # 1. Solve for average scheme\n        N_s_avg, N_w_avg = average_elcc_investment(K)\n        gen_avg = N_s_avg * s_t + N_w_avg * w_t\n        ENS_avg = calculate_ens(L_t, C, gen_avg)\n\n        # 2. Solve for marginal scheme\n        N_s_marg, N_w_marg = marginal_elcc_investment(K)\n        gen_marg = N_s_marg * s_t + N_w_marg * w_t\n        ENS_marg = calculate_ens(L_t, C, gen_marg)\n\n        # 3. Calculate and store inefficiency\n        delta_ENS = ENS_avg - ENS_marg\n        results.append(delta_ENS)\n\n    # --- Format and Print Final Output ---\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}