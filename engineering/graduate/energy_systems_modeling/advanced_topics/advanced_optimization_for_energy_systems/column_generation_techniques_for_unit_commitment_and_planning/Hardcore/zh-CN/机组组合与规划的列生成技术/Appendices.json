{
    "hands_on_practices": [
        {
            "introduction": "列生成方法始于构建一个简化的主问题。本练习将指导您为简化的机组组合问题建立初始的“受限主问题”（Restricted Master Problem, RMP）。通过亲手生成一组初始列（即预设的运行方案）并评估其可行性和初始界限的质量 ，您将对Dantzig-Wolfe分解的整体框架获得基础而直观的理解。",
            "id": "4078892",
            "problem": "设计并实现一个程序，该程序使用 Dantzig–Wolfe 分解为一个分解后的机组组合公式构建一个初始受限主问题 (RMP)，并评估该初始列集的可行性和界质量。问题背景是一个多时段火力发电调度问题，具有线性可变成本，无爬坡限制，无最小启停时间，并采用一小时的时间步长，因此在每个时段内，以兆瓦为单位的功率在数值上等于以兆瓦时为单位的能量。所有成本必须以美元报告，所有功率必须解释为兆瓦，时段长度为一小时。\n\n从以下基本概念开始：\n- Dantzig–Wolfe 分解原理：一个大规模线性规划问题可以被重新表述，使得其可行决策可以表示为子问题多胞体的极点（列）的凸组合。\n- 线性规划松弛下界性质：在线性规划松弛的最小化问题中，其最优目标值小于或等于原始混合整数问题的最优值。\n- 可行供应覆盖：在每个时间段，总发电量加上任何明确建模的切负荷量必须不小于需求量。\n\n初始 RMP 的公式：\n- 设机组集合由 $u \\in \\{1,\\dots,|U|\\}$ 索引，时间段集合由 $t \\in \\{1,\\dots,|T|\\}$ 索引。对于每个机组 $u$，参数包括最小输出功率 $P^{\\min}_u$（兆瓦），最大输出功率 $P^{\\max}_u$（兆瓦），以及线性可变成本 $c_u$（美元/兆瓦时）。设需求曲线为 $D_t$（兆瓦），对应每个时段 $t$。\n- 机组 $u$ 的一个列由一个预定的输出曲线 $\\{p_{u,k,t}\\}_{t=1}^{|T|}$ 定义，其相关的列成本为 $\\text{cost}_{u,k} = \\sum_{t=1}^{|T|} c_u \\, p_{u,k,t}$（美元）。\n- 决策变量为 $\\lambda_{u,k} \\ge 0$（对于机组 $u$ 的每个列 $k$）和 $s_t \\ge 0$（表示在时间 $t$ 的切负荷，单位为兆瓦）。每个机组的凸性约束为 $\\sum_k \\lambda_{u,k} = 1$。需求覆盖约束为 $\\sum_{u} \\sum_{k} \\lambda_{u,k} \\, p_{u,k,t} + s_t \\ge D_t$，适用于所有 $t$。\n- RMP 的目标是最小化 $\\sum_{u} \\sum_{k} \\text{cost}_{u,k} \\, \\lambda_{u,k} + M \\sum_{t} s_t$，其中 $M$ 是一个对切负荷的高额惩罚（美元/兆瓦时）。在此问题中，使用 $M = 10000$。\n\n每个机组的初始列：\n- 始终关闭：对于所有 $t$，$p_{u,\\text{off},t} = 0$，且 $\\text{cost}_{u,\\text{off}} = 0$。\n- 始终以 $P^{\\min}$ 开启：对于所有 $t$，$p_{u,\\text{min},t} = P^{\\min}_u$，且 $\\text{cost}_{u,\\text{min}} = \\sum_{t=1}^{|T|} c_u \\, P^{\\min}_u$。\n- 经济顺序调度：对于每个时段 $t$，按 $c_u$ 升序对机组进行排序。从最便宜的机组开始，累积增加 $P^{\\min}$，直到达到或超过 $D_t$。如果机组 $u$ 在时段 $t$ 属于这个集合，则标记 $y_{u,t} = 1$，否则 $y_{u,t} = 0$。定义 $p_{u,\\text{merit},t} = y_{u,t} \\, P^{\\min}_u$，且 $\\text{cost}_{u,\\text{merit}} = \\sum_{t=1}^{|T|} c_u \\, y_{u,t} \\, P^{\\min}_u$。\n\n用于界质量的上界构造：\n- 独立于 RMP，构造一个分时段的可行机组组合和调度，该调度在机组开启时遵守 $P^{\\min}_u$，并以 $P^{\\max}_u$ 为上限。对于每个时间 $t$，按 $c_u$ 升序，开启机组并分配输出 $p_{u,t}$，其中 $p_{u,t} \\in \\{0\\} \\cup [P^{\\min}_u, P^{\\max}_u]$，直到累积输出满足或超过 $D_t$。在开启一个机组的时刻，分配 $p_{u,t} = \\min\\{P^{\\max}_u, \\max\\{P^{\\min}_u, \\text{residual}\\}\\}$，其中 residual 是剩余未满足的需求。时段成本为 $\\sum_u c_u \\, p_{u,t}$，总成本为 $\\sum_t \\sum_u c_u \\, p_{u,t}$。假设总可用容量满足 $\\sum_u P^{\\max}_u \\ge D_t$（对于所有 $t$），以确保可行性。\n- 将下界定义为最优 RMP 目标值，记为 $LB$。将上界定义为上述构造的启发式可行成本，记为 $UB$。\n- 定义一个标量界质量指标 $Q$ 如下：如果 $UB \\le 10^{-9}$，则当 $LB \\le 10^{-9}$ 时 $Q = 1$，否则 $Q = 0$；否则 $Q = \\min\\{1, \\max\\{0, LB/UB\\}\\}$。这个 $Q$ 是一个在 $[0,1]$ 区间内的小数。\n\n任务：\n- 对于下面的每个测试实例，生成初始列，求解 RMP，计算 $LB$，计算 $UB$，确定初始 RMP 在没有切负荷（所有 $s_t = 0$，容差为 $10^{-6}$）的情况下的可行性，计算总切负荷 $\\sum_t s_t$，并计算 $Q$。\n- 所有成本以美元表示，能量以兆瓦时表示（与一小时时段对齐）；然而，程序所需的输出是纯数值。在最终输出中，将 $LB$、$UB$、$Q$ 和总切负荷四舍五入到六位小数。\n\n测试套件：\n- 案例 A (理想情况): $|U| = 3$, $|T| = 3$, $P^{\\min} = [10, 15, 5]$ 兆瓦, $P^{\\max} = [50, 40, 30]$ 兆瓦, $c = [35, 20, 60]$ 美元/兆瓦时, $D = [25, 20, 30]$ 兆瓦。\n- 案例 B (边界条件): 与案例 A 相同的机组, $D = [30, 30, 30]$ 兆瓦。\n- 案例 C (无切负荷时初始列不可行): 与案例 A 相同的机组, $D = [45, 35, 50]$ 兆瓦。\n- 案例 D (零需求): 与案例 A 相同的机组, $D = [0, 0, 0]$ 兆瓦。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含一个结果列表，每个案例一个结果，其中每个案例结果本身是一个 $[\\text{feasible}, LB, UB, Q, \\text{shed}]$ 形式的列表，$\\text{feasible}$ 是一个布尔值，而 $LB$、$UB$、$Q$ 和 $\\text{shed}$ 是四舍五入到六位小数的浮点数。整个输出行必须是一个单独的列表，例如 $[[\\text{True}, 123.456000, 200.000000, 0.617280, 0.000000],[\\dots]]$。",
            "solution": "用户的要求是设计并实现一个程序，使用 Dantzig-Wolfe 分解框架来解决一个简化的火电机组组合问题。核心任务包括构建一个初始受限主问题 (RMP)，求解它以找到一个下界 ($LB$)，另外通过构建一个启发式可行解来找到一个上界 ($UB$)，并评估初始设置的质量。\n\n该问题陈述已经过验证，被认为是科学上合理的、问题定义清晰的、客观的且内部一致的。它提供了所有必要的数据和定义，以得到一个唯一且可验证的解。\n\n解决方案主要分三个阶段进行：\n1.  为每个发电机组构建初始列集。\n2.  建立并求解初始受限主问题 (RMP)，这是一个线性规划 (LP) 问题，以获得下界 ($LB$)。\n3.  通过分时段的贪心调度算法构建一个启发式上界 ($UB$)。\n\n设发电机组集合为 $U$，时间段集合为 $T$。对于每个机组 $u \\in U$，我们给定其最小功率输出 $P^{\\min}_u$、最大功率输出 $P^{\\max}_u$ 和可变发电成本 $c_u$。对于每个时间段 $t \\in T$，有一个功率需求 $D_t$。\n\n**1. 初始列生成**\n\n对于每个机组 $u \\in U$，我们生成一组初始运行计划，称为列。每个列 $k$ 是一个功率输出向量 $\\{p_{u,k,t}\\}_{t \\in T}$，并有其相关成本 $\\text{cost}_{u,k} = \\sum_{t \\in T} c_u p_{u,k,t}$。问题为每个机组指定了三个初始列：\n\n*   **始终关闭列 ($k=\\text{off}$):** 此列表示机组在整个计划周期内都处于关闭状态。\n    *   功率曲线：对于所有 $t \\in T$，$p_{u,\\text{off},t} = 0$。\n    *   成本：$\\text{cost}_{u,\\text{off}} = \\sum_{t \\in T} c_u \\cdot 0 = 0$。\n\n*   **始终以最小功率运行列 ($k=\\text{min}$):** 此列表示机组在整个周期内都以其最小稳定发电水平运行。\n    *   功率曲线：对于所有 $t \\in T$，$p_{u,\\text{min},t} = P^{\\min}_u$。\n    *   成本：$\\text{cost}_{u,\\text{min}} = \\sum_{t \\in T} c_u P^{\\min}_u = |T| \\cdot c_u P^{\\min}_u$。\n\n*   **经济顺序调度列 ($k=\\text{merit}$):** 此列代表一种简单的经济开机策略。对于每个时间段 $t$，机组按其可变成本 $c_u$ 递增的顺序进行概念上的开启，直到已开启机组的累积最小功率满足或超过需求 $D_t$。\n    *   设 $\\pi$ 为机组索引 $\\{1, \\dots, |U|\\}$ 的一个排列，它按成本升序对机组进行排序，因此 $c_{\\pi(1)} \\le c_{\\pi(2)} \\le \\dots \\le c_{\\pi(|U|)}$。\n    *   对于每个 $t \\in T$，找到最小的整数 $N_t$ 使得 $\\sum_{i=1}^{N_t} P^{\\min}_{\\pi(i)} \\ge D_t$。\n    *   定义一个二进制指标 $y_{u,t} = 1$（如果机组 $u$ 在时段 $t$ 属于前 $N_t$ 个最便宜的机组之一），否则 $y_{u,t} = 0$。\n    *   功率曲线：对于所有 $t \\in T$，$p_{u,\\text{merit},t} = y_{u,t} P^{\\min}_u$。\n    *   成本：$\\text{cost}_{u,\\text{merit}} = \\sum_{t \\in T} c_u p_{u,\\text{merit},t} = \\sum_{t \\in T} c_u y_{u,t} P^{\\min}_u$。\n\n**2. 受限主问题 (RMP) 的公式建立与求解**\n\nRMP 是一个线性规划问题，它寻求初始列的最佳凸组合，以在满足需求的同时最小化总成本。\n\n**决策变量：**\n*   $\\lambda_{u,k} \\ge 0$：分配给机组 $u$ 的列 $k$ 的权重。\n*   $s_t \\ge 0$：时段 $t$ 的切负荷量（未满足的需求），以高成本 $M = 10000$ \\$/MWh 进行惩罚。\n\n**目标函数：**\n目标是最小化发电成本和切负荷惩罚之和。\n$$ \\min Z_{RMP} = \\sum_{u \\in U} \\sum_{k} \\text{cost}_{u,k} \\lambda_{u,k} + M \\sum_{t \\in T} s_t $$\n最优值 $Z_{RMP}^*$ 提供了下界，$LB = Z_{RMP}^*$。\n\n**约束条件：**\n*   **凸性约束：** 对于每个机组 $u$，其列的权重之和必须为 1。这确保了每个机组的运行计划是其建议计划的有效凸组合。\n    $$ \\sum_{k} \\lambda_{u,k} = 1 \\quad \\forall u \\in U $$\n*   **需求约束：** 对于每个时间段 $t$，所有机组的总发电量加上任何切负荷必须满足或超过需求。机组 $u$ 在时间 $t$ 的发电量是其各列功率输出的加权平均值，即 $\\sum_{k} \\lambda_{u,k} p_{u,k,t}$。\n    $$ \\sum_{u \\in U} \\left( \\sum_{k} \\lambda_{u,k} p_{u,k,t} \\right) + s_t \\ge D_t \\quad \\forall t \\in T $$\n\n这个线性规划问题可以使用标准求解器（如 `scipy.optimize.linprog`）来求解。由于存在高成本的松弛变量 $s_t$，该问题保证是可行的。\n\n**3. 上界 (UB) 的启发式构造**\n\n原始问题最优成本的一个上界可以通过构造任何一个可行解来获得。问题指定了一个为每个时间段独立执行的贪心启发式算法。\n\n对于每个时段 $t \\in T$：\n1.  初始化未满足的需求，$d_{\\text{rem}} = D_t$。\n2.  将所有机组在时段 $t$ 的发电量初始化为零：对于所有 $u \\in U$，$p_{u,t} = 0$。\n3.  按其可变成本 $c_u$ 的升序处理机组。\n4.  对于此经济顺序中的每个机组 $u$：\n    a. 如果 $d_{\\text{rem}}  0$，则开启该机组。\n    b. 该机组要发的电量为 $p_{u,t} = \\min(P^{\\max}_u, \\max(P^{\\min}_u, d_{\\text{rem}}))$。注意，如果剩余需求 $d_{\\text{rem}}$ 在 $0$ 和 $P^{\\min}_u$ 之间，该机组将以 $P^{\\min}_u$ 进行调度。\n    c. 更新剩余需求：$d_{\\text{rem}} = d_{\\text{rem}} - p_{u,t}$。\n    d. 如果 $d_{\\text{rem}} \\le 0$，则停止为该时段开启更多机组。\n5. 该启发式解的总成本是所有时段成本的总和：\n$$ UB = \\sum_{t \\in T} \\sum_{u \\in U} c_u p_{u,t} $$\n问题保证对于所有 $t$，$\\sum_{u \\in U} P^{\\max}_u \\ge D_t$，确保该启发式算法总能满足需求而无需切负荷。\n\n**4. 最终输出指标**\n\n计算出 $LB$ 和 $UB$ 后，我们为每个测试案例导出最终的指标集：\n*   **可行性 (`feasible`):** 如果最优切负荷变量的总和接近于零，则认为初始 RMP 在没有切负荷的情况下是可行的。我们检查 $\\sum_{t \\in T} s_t^* \\le 10^{-6}$ 是否成立，其中 $s_t^*$ 是 LP 解的最优值。\n*   **下界 ($LB$):** 已求解的 RMP 的最优目标值 $Z_{RMP}^*$。\n*   **上界 ($UB$):** 来自贪心启发式算法的成本。\n*   **切负荷 (`shed`):** RMP 解的总切负荷量 $\\sum_{t \\in T} s_t^*$。\n*   **界质量 ($Q$):** 一个归一化的度量，表示 $LB$ 和 $UB$ 之间的差距。\n    $$ Q = \\begin{cases} 1  \\text{如果 } UB \\le 10^{-9} \\text{ 且 } LB \\le 10^{-9} \\\\ 0  \\text{如果 } UB \\le 10^{-9} \\text{ 且 } LB  10^{-9} \\\\ \\min\\{1, \\max\\{0, LB/UB\\}\\}  \\text{其他情况} \\end{cases} $$\n所有数值结果都四舍五入到六位小数。实现将为 `scipy.optimize.linprog` 构建 LP 矩阵和向量，并对每个提供的测试案例执行上述逻辑。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    It defines the test cases, iterates through them, computes the required metrics,\n    and prints the results in the specified format.\n    \"\"\"\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [25, 20, 30],\n        },\n        # Case B: Boundary condition\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [30, 30, 30],\n        },\n        # Case C: Infeasible initial columns without shedding\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [45, 35, 50],\n        },\n        # Case D: Zero demand\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [0, 0, 0],\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        result_tuple = run_case(case_data)\n        results.append(result_tuple)\n\n    # Format the final output string exactly as required.\n    formatted_results = []\n    for res in results:\n        feasible, lb, ub, q, shed = res\n        formatted_res = f\"[{str(feasible)}, {lb:.6f}, {ub:.6f}, {q:.6f}, {shed:.6f}]\"\n        formatted_results.append(formatted_res)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_case(case_data):\n    \"\"\"\n    Solves a single test case instance.\n    Generates initial columns, solves the RMP, computes the UB, and returns metrics.\n    \"\"\"\n    p_min = np.array(case_data[\"p_min\"], dtype=float)\n    p_max = np.array(case_data[\"p_max\"], dtype=float)\n    cost_var = np.array(case_data[\"cost_var\"], dtype=float)\n    demand = np.array(case_data[\"demand\"], dtype=float)\n    \n    num_units = len(p_min)\n    num_periods = len(demand)\n    shed_penalty = 10000.0\n    tol = 1e-6\n\n    # --- 1. Generate Initial Columns ---\n    columns = [[] for _ in range(num_units)]\n    \n    # Unit indices sorted by cost (merit order)\n    merit_order_indices = np.argsort(cost_var)\n\n    for u in range(num_units):\n        # Always-off column\n        p_off = np.zeros(num_periods)\n        cost_off = 0.0\n        columns[u].append({'profile': p_off, 'cost': cost_off})\n\n        # Always-on at P_min column\n        p_min_on = np.full(num_periods, p_min[u])\n        cost_min_on = num_periods * cost_var[u] * p_min[u]\n        columns[u].append({'profile': p_min_on, 'cost': cost_min_on})\n\n        # Merit-order column\n        p_merit = np.zeros(num_periods)\n        for t in range(num_periods):\n            cum_pmin = 0.0\n            for u_merit_idx in merit_order_indices:\n                cum_pmin += p_min[u_merit_idx]\n                if u_merit_idx == u:\n                    p_merit[t] = p_min[u]\n                    break\n                if cum_pmin >= demand[t]:\n                    break\n        cost_merit = np.sum(cost_var[u] * p_merit)\n        columns[u].append({'profile': p_merit, 'cost': cost_merit})\n\n    # --- 2. Formulate and Solve the RMP (LP) ---\n    num_lambda_vars = sum(len(c) for c in columns)\n    num_shed_vars = num_periods\n    num_total_vars = num_lambda_vars + num_shed_vars\n\n    # Objective function vector\n    c_lp = np.zeros(num_total_vars)\n    lambda_idx = 0\n    for u in range(num_units):\n        for col_data in columns[u]:\n            c_lp[lambda_idx] = col_data['cost']\n            lambda_idx += 1\n    c_lp[num_lambda_vars:] = shed_penalty\n\n    # Equality constraints (convexity): A_eq * x = b_eq\n    A_eq = np.zeros((num_units, num_total_vars))\n    b_eq = np.ones(num_units)\n    lambda_idx = 0\n    for u in range(num_units):\n        num_cols_u = len(columns[u])\n        A_eq[u, lambda_idx : lambda_idx + num_cols_u] = 1.0\n        lambda_idx += num_cols_u\n\n    # Inequality constraints (demand): A_ub * x = b_ub\n    # Original: sum(lambda*p) + s >= D  => -sum(lambda*p) - s = -D\n    A_ub = np.zeros((num_periods, num_total_vars))\n    b_ub = -demand\n    \n    lambda_idx = 0\n    for u in range(num_units):\n        for col_data in columns[u]:\n            A_ub[:, lambda_idx] = -col_data['profile']\n            lambda_idx += 1\n            \n    for t in range(num_periods):\n        A_ub[t, num_lambda_vars + t] = -1.0\n        \n    bounds = [(0, None) for _ in range(num_total_vars)]\n\n    res = linprog(c=c_lp, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    lb = res.fun if res.success else float('inf')\n    \n    total_shed = 0.0\n    if res.success:\n        shed_vars = res.x[num_lambda_vars:]\n        total_shed = np.sum(shed_vars)\n\n    is_feasible_no_shed = total_shed = tol\n\n    # --- 3. Compute Upper Bound (UB) ---\n    ub = 0.0\n    for t in range(num_periods):\n        demand_rem = demand[t]\n        cost_t = 0.0\n        \n        # Handle zero demand case explicitly\n        if demand_rem = tol:\n            continue\n            \n        for u in merit_order_indices:\n            if demand_rem > tol:\n                p_ut = min(p_max[u], max(p_min[u], demand_rem))\n                cost_t += cost_var[u] * p_ut\n                demand_rem -= p_ut\n        ub += cost_t\n\n    # --- 4. Compute Bound Quality (Q) ---\n    if ub = 1e-9:\n        q = 1.0 if lb = 1e-9 else 0.0\n    else:\n        q = min(1.0, max(0.0, lb / ub))\n\n    return is_feasible_no_shed, lb, ub, q, total_shed\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了主问题的结构后，下一步是学习如何生成更优的列来改进解。本练习  聚焦于列生成算法的核心——定价子问题，您将使用动态规划（Dynamic Programming）为单个发电机组求解其成本最低的运行计划。这个过程需要严格处理如最小开机时间（$MUT$）和最小停机时间（$MDT$）这类在实际中至关重要的时间耦合约束，是掌握列生成技术的关键一步。",
            "id": "4078854",
            "problem": "在机组组合 (UC) 列生成的背景下，考虑单个火力发电机组。应用于混合整数规划 (MIP) 的 Dantzig-Wolfe (DW) 分解产生一个主问题，其对偶变量被送入一个针对单个机组的子问题，该子问题旨在寻找一个使折算成本最小化的调度计划。根据线性规划 (LP) 对偶性，由 $j$ 索引的候选列的折算成本由 $r_j = c_j - y^\\top A_j$ 给出，其中 $c_j$ 是原始列成本，$y$ 是与主问题中耦合约束相关的对偶变量。对于单个机组，我们在一个由 $t \\in \\{1, \\dots, T\\}$ 索引的离散时间范围内对子问题进行建模，其状态空间通过状态对 $(s_t, \\ell_t)$ 来强制执行最小连续运行时间 (MUT) 和最小连续停机时间 (MDT)，其中 $s_t \\in \\{0,1\\}$ 表示开/关状态，$\\ell_t \\in \\mathbb{Z}_{\\ge 0}$ 记录在当前状态下持续的时间。该动态特性必须确保机组一旦启动，将至少连续运行 $MUT_i$ 个时段；一旦停机，将至少连续停机 $MDT_i$ 个时段。状态转移的形式为 $(s_t, \\ell_t) \\to (s_{t+1}, \\ell_{t+1})$，并遵循以下规则：保持相同状态时，$\\ell_t$ 增加一（为保持状态空间紧凑而设置上限）；只有当 $\\ell_t$ 满足各自的最小时间阈值时才允许切换状态（即 $\\ell_t \\ge MUT_i$ 才能停机，$\\ell_t \\ge MDT_i$ 才能启动）。\n\n假设每兆瓦时的线性可变生产成本为 $c_i$，在线时的单位时段固定成本为 $F_i$。令 $P^{\\min}_i$ 和 $P^{\\max}_i$ 分别表示在线时的最小和最大出力。启动和停机成本分别为 $SU_i$ 和 $SD_i$。主问题的需求平衡对偶价格序列为 $\\{\\lambda_t\\}_{t=1}^T$，单位为美元/兆瓦时。机组 $i$ 的凸性约束对偶变量为 $\\mu_i$，单位为美元/时间范围。对于机组在线的时段 $t$，其折算成本贡献是在出力 $g_t \\in [P^{\\min}_i, P^{\\max}_i]$ 范围内的最小值，即 $F_i + c_i g_t - \\lambda_t g_t$ 的最小值。当 $c_i - \\lambda_t \\le 0$ 时，在 $g_t = P^{\\max}_i$ 处取得该最小值；当 $c_i - \\lambda_t  0$ 时，在 $g_t = P^{\\min}_i$ 处取得该最小值。当机组离线时，单位时段贡献为零。从离线到在线的状态转换增加成本 $SU_i$，从在线到离线的状态转换增加成本 $SD_i$。一个调度计划的总折算成本是这些贡献在整个时间范围内的总和减去 $\\mu_i$。\n\n你的任务是实现一个程序，对于每个测试用例，构建状态空间 $(s_t, \\ell_t)$ 中的允许状态转移（其中 $\\ell_t$ 记录当前状态的持续时间），并使用动态规划方法，从指定的初始状态 $(s_1, \\ell_1)$ 开始，计算整个时间范围内的最小总折算成本。请使用以下基本原理：\n\n- 来自线性规划对偶性的折算成本公式：$r_j = c_j - y^\\top A_j$。\n- 在线时的单位时段折算成本贡献，计算公式为 $F_i + \\min_{g_t \\in [P^{\\min}_i, P^{\\max}_i]} (c_i - \\lambda_t) g_t$。\n- 通过关于 $(s_t, \\ell_t)$ 的状态转移规则强制执行最小连续运行时间 (MUT) 和最小连续停机时间 (MDT)。\n\n定义状态空间，使 $\\ell_t$ 对于当前状态的上限为 $\\max\\{MUT_i, MDT_i, 1\\}$，以保持状态空间有限，且不影响最小时间逻辑。初始的 $\\ell_1$ 可以为零；将 $\\ell_1 = 0$ 解释为如果相应的最小时间为零，则该机组可立即切换状态。如果在时段 $t$ 发生状态切换，则在该时段应用 $SU_i$ 或 $SD_i$ 成本，并加上新状态的单位时段贡献。\n\n必须遵守所有物理和货币单位，具体如下：功率单位为兆瓦 (MW)，能源价格和可变成本单位为美元/兆瓦时 ($/\\mathrm{MWh}$)，在线固定成本单位为美元/时段 ($)，启动和停机成本单位为美元 ($)。最终的折算成本以美元 ($) 为单位，表示为浮点数。不涉及角度。不涉及百分比。\n\n实现程序以评估以下参数集的测试套件：\n\n- 测试用例 1 (正常路径)：\n  - 时间范围 $T = 6$ 个时段 (小时)。\n  - 最小连续运行时间 $MUT_i = 2$ 小时，最小连续停机时间 $MDT_i = 2$ 小时。\n  - 初始状态 $(s_1, \\ell_1) = (0, 2)$。\n  - $P^{\\min}_i = 50$ MW, $P^{\\max}_i = 120$ MW。\n  - 可变成本 $c_i = 30$ $/ \\mathrm{MWh}$，在线固定成本 $F_i = 100$ $。\n  - 启动成本 $SU_i = 500$ $, 停机成本 $SD_i = 0$ $.\n  - 需求平衡对偶价格 $\\{\\lambda_t\\}_{t=1}^6 = \\{40, 45, 35, 20, 10, 50\\}$ $/ \\mathrm{MWh}$。\n  - 凸性约束对偶 $\\mu_i = 0$ $。\n\n- 测试用例 2 (最小时间为零且无发电激励的边界情况)：\n  - 时间范围 $T = 4$ 个时段 (小时)。\n  - 最小连续运行时间 $MUT_i = 0$ 小时，最小连续停机时间 $MDT_i = 0$ 小时。\n  - 初始状态 $(s_1, \\ell_1) = (0, 0)$。\n  - $P^{\\min}_i = 10$ MW, $P^{\\max}_i = 10$ MW。\n  - 可变成本 $c_i = 30$ $/ \\mathrm{MWh}$，在线固定成本 $F_i = 0$ $。\n  - 启动成本 $SU_i = 0$ $, 停机成本 $SD_i = 0$ $.\n  - 需求平衡对偶价格 $\\{\\lambda_t\\}_{t=1}^4 = \\{25, 25, 25, 25\\}$ $/ \\mathrm{MWh}$。\n  - 凸性约束对偶 $\\mu_i = 0$ $。\n\n- 测试用例 3 (强制初始在线时长的边缘情况)：\n  - 时间范围 $T = 5$ 个时段 (小时)。\n  - 最小连续运行时间 $MUT_i = 3$ 小时，最小连续停机时间 $MDT_i = 1$ 小时。\n  - 初始状态 $(s_1, \\ell_1) = (1, 1)$。\n  - $P^{\\min}_i = 20$ MW, $P^{\\max}_i = 60$ MW。\n  - 可变成本 $c_i = 20$ $/ \\mathrm{MWh}$，在线固定成本 $F_i = 50$ $。\n  - 启动成本 $SU_i = 200$ $, 停机成本 $SD_i = 0$ $.\n  - 需求平衡对偶价格 $\\{\\lambda_t\\}_{t=1}^5 = \\{15, 15, 15, 15, 15\\}$ $/ \\mathrm{MWh}$。\n  - 凸性约束对偶 $\\mu_i = 0$ $。\n\n- 测试用例 4 (高电价鼓励最大化生产)：\n  - 时间范围 $T = 3$ 个时段 (小时)。\n  - 最小连续运行时间 $MUT_i = 1$ 小时，最小连续停机时间 $MDT_i = 1$ 小时。\n  - 初始状态 $(s_1, \\ell_1) = (0, 1)$。\n  - $P^{\\min}_i = 10$ MW, $P^{\\max}_i = 50$ MW。\n  - 可变成本 $c_i = 20$ $/ \\mathrm{MWh}$，在线固定成本 $F_i = 10$ $。\n  - 启动成本 $SU_i = 100$ $, 停机成本 $SD_i = 0$ $.\n  - 需求平衡对偶价格 $\\{\\lambda_t\\}_{t=1}^3 = \\{100, 100, 100\\}$ $/ \\mathrm{MWh}$。\n  - 凸性约束对偶 $\\mu_i = 0$ $。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1, r_2, r_3, r_4]$），$r_k$ 是为测试用例 $k$ 计算出的最小总折算成本（单位为美元）。",
            "solution": "该问题是有效的。这是一个良定的优化问题，其基础是应用于电力系统运行（特别是列生成框架内的机组组合（UC）子问题）的数学规划和动态规划的既定原则。为获得唯一解所需的所有数据和定义均已提供，不存在科学或逻辑上的矛盾。\n\n任务是为单个火力发电机组在时间范围 $t \\in \\{1, \\dots, T\\}$ 内找到一个最小折算成本的调度计划。该问题可以使用动态规划（DP）解决。DP方法的核心是定义状态、每个状态的价值函数以及一个通过在每个时间步做出最优决策来计算价值函数的递推关系。\n\n设机组在时段 $t$ 开始时的状态由元组 $(s_t, \\ell_t)$ 描述，其中 $s_t \\in \\{0, 1\\}$ 是开/关状态（1代表在线，0代表离线），$\\ell_t \\in \\mathbb{Z}_{\\ge 0}$ 是机组处于该状态的连续小时数。为了保持状态空间有限，$\\ell_t$ 的上限设为 $L_{\\max} = \\max\\{MUT_i, MDT_i, 1\\}$，其中 $MUT_i$ 和 $MDT_i$ 分别是最小连续运行和停机时间。因此，时间 $t$ 的状态为 $(s, \\ell)$，其中 $s \\in \\{0, 1\\}$ 且 $\\ell \\in \\{0, 1, \\dots, L_{\\max}\\}$。\n\n设 $V(t, s, \\ell)$ 为从时段 $t$ 开始到时间范围 $T$ 结束，在时段 $t$ 开始时机组处于状态 $(s, \\ell)$ 的情况下，单位时段折算成本的最小可能总和。我们的目标是计算 $V(1, s_1, \\ell_1) - \\mu_i$，其中 $(s_1, \\ell_1)$ 是给定的初始状态，$\\mu_i$ 是凸性约束的对偶变量。\n\nDP过程按时间倒序进行，从 $t=T$ 到 $t=1$。基本情况是在时间范围结束时，即 $t=T+1$，此时未来成本为零：\n$$V(T+1, s, \\ell) = 0 \\quad \\forall s \\in \\{0, 1\\}, \\ell \\in \\{0, 1, \\dots, L_{\\max}\\}$$\n\n对于任意时间 $t \\in \\{1, \\dots, T\\}$，价值函数 $V(t, s, \\ell)$ 由贝尔曼方程确定，该方程考虑了在时间 $t$ 所有有效决策（行动）下的最小成本。单位时段的折算成本贡献（我们称之为 $C_t(s_t)$）取决于为时段 $t$选择的状态 $s_t$。\n如果机组离线 ($s_t=0$)，成本为 $C_t(0) = 0$。\n如果机组在线 ($s_t=1$)，成本为固定成本与优化后的发电成本之和：\n$$C_t(1) = F_i + \\min_{g_t \\in [P^{\\min}_i, P^{\\max}_i]} (c_i - \\lambda_t) g_t$$\n使该表达式最小化的最优发电量 $g_t^*$ 为：如果净价 $(c_i - \\lambda_t)$ 为非正数，则为 $P^{\\max}_i$；否则为 $P^{\\min}_i$。\n$$g_t^* = \\begin{cases} P^{\\max}_i  \\text{if } c_i - \\lambda_t \\le 0 \\\\ P^{\\min}_i  \\text{if } c_i - \\lambda_t  0 \\end{cases}$$\n因此，$C_t(1) = F_i + (c_i - \\lambda_t) g_t^*$。\n\n$V(t, s, \\ell)$的递推关系如下：\n\n情况1：在时段 $t$ 开始时机组在线，即状态为 $(1, \\ell)$。\n在时段 $t$ 有两种可能的行动：\n1.  **保持在线**：机组保持在线状态。此行动的成本为 $C_t(1)$ 加上从时间 $t+1$ 的状态 $(1, \\min(\\ell+1, L_{\\max}))$ 开始的最小未来成本。此行动总是允许的。\n2.  **停机**：机组关闭。此行动仅在满足最小运行时间约束（即 $\\ell \\ge MUT_i$）时才允许。成本为停机成本 $SD_i$，加上离线状态的单位时段成本 $C_t(0)=0$，再加上从时间 $t+1$ 的新状态 $(0, 1)$ 开始的最小未来成本。\n价值函数是这些有效行动成本的最小值：\n$$V(t, 1, \\ell) = \\min \\begin{cases} C_t(1) + V(t+1, 1, \\min(\\ell+1, L_{\\max})) \\\\ SD_i + C_t(0) + V(t+1, 0, 1)  \\text{if } \\ell \\ge MUT_i \\end{cases}$$\n\n情况2：在时段 $t$ 开始时机组离线，即状态为 $(0, \\ell)$。\n类似地，有两种可能的行动：\n1.  **保持离线**：机组保持离线状态。成本为 $C_t(0)$ 加上从时间 $t+1$ 的状态 $(0, \\min(\\ell+1, L_{\\max}))$ 开始的未来成本。此行动总是允许的。\n2.  **启动**：机组启动。此行动仅在满足最小停机时间约束（即 $\\ell \\ge MDT_i$）时才允许。成本为启动成本 $SU_i$，加上在线状态的单位时段成本 $C_t(1)$，再加上从时间 $t+1$ 的状态 $(1, 1)$ 开始的未来成本。条件 $\\ell \\ge MDT_i$ 正确处理了初始状态 $\\ell_1=0$ 的特殊情况，即仅当 $MDT_i=0$ 时才允许切换。\n价值函数为：\n$$V(t, 0, \\ell) = \\min \\begin{cases} C_t(0) + V(t+1, 0, \\min(\\ell+1, L_{\\max})) \\\\ SU_i + C_t(1) + V(t+1, 1, 1)  \\text{if } \\ell \\ge MDT_i \\end{cases}$$\n\n通过从 $t=T$ 到 $1$ 填充所有 $s \\in \\{0,1\\}$ 和 $\\ell \\in \\{0, \\dots, L_{\\max}\\}$ 的DP表 $V(t, s, \\ell)$，我们可以找到从任何状态开始的最小成本总和。每个测试用例的最终答案是 $V(1, s_1, \\ell_1) - \\mu_i$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving of all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'T': 6, 'MUT': 2, 'MDT': 2, 's1': 0, 'l1': 2,\n         'Pmin': 50, 'Pmax': 120, 'c': 30, 'F': 100, 'SU': 500, 'SD': 0,\n         'lambdas': [40, 45, 35, 20, 10, 50], 'mu': 0},\n        # Test case 2\n        {'T': 4, 'MUT': 0, 'MDT': 0, 's1': 0, 'l1': 0,\n         'Pmin': 10, 'Pmax': 10, 'c': 30, 'F': 0, 'SU': 0, 'SD': 0,\n         'lambdas': [25, 25, 25, 25], 'mu': 0},\n        # Test case 3\n        {'T': 5, 'MUT': 3, 'MDT': 1, 's1': 1, 'l1': 1,\n         'Pmin': 20, 'Pmax': 60, 'c': 20, 'F': 50, 'SU': 200, 'SD': 0,\n         'lambdas': [15, 15, 15, 15, 15], 'mu': 0},\n        # Test case 4\n        {'T': 3, 'MUT': 1, 'MDT': 1, 's1': 0, 'l1': 1,\n         'Pmin': 10, 'Pmax': 50, 'c': 20, 'F': 10, 'SU': 100, 'SD': 0,\n         'lambdas': [100, 100, 100], 'mu': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single unit commitment subproblem using dynamic programming.\n    \"\"\"\n    T = params['T']\n    MUT = params['MUT']\n    MDT = params['MDT']\n    s1, l1 = params['s1'], params['l1']\n    Pmin, Pmax = params['Pmin'], params['Pmax']\n    c, F = params['c'], params['F']\n    SU, SD = params['SU'], params['SD']\n    lambdas = params['lambdas']\n    mu = params['mu']\n\n    L_max = max(MUT, MDT, 1)\n\n    # Pre-calculate per-period costs for being online\n    on_costs = []\n    for t in range(T):\n        lambda_t = lambdas[t]\n        # Determine optimal generation level based on net price\n        gen_level = Pmax if c - lambda_t = 0 else Pmin\n        cost = F + (c - lambda_t) * gen_level\n        on_costs.append(cost)\n\n    # Initialize DP table V(t, s, l) with infinity\n    # Dimensions: (time+2) x (status) x (duration+1)\n    dp = np.full((T + 2, 2, L_max + 1), np.inf)\n\n    # Base case: cost from t=T+1 onwards is 0\n    dp[T + 1, :, :] = 0.0\n\n    # DP backward recursion from t=T down to t=1\n    for t in range(T, 0, -1):\n        t_idx = t - 1\n        current_on_cost = on_costs[t_idx]\n        current_off_cost = 0.0\n        \n        for l in range(L_max + 1):\n            # ===== State at start of period t is (s=1, l), i.e., ONLINE =====\n            \n            # Option 1: Stay ON\n            cost_stay_on = current_on_cost + dp[t + 1, 1, min(l + 1, L_max)]\n            \n            # Option 2: Switch OFF\n            cost_switch_off = np.inf\n            if l >= MUT:\n                cost_switch_off = SD + current_off_cost + dp[t + 1, 0, 1]\n            \n            dp[t, 1, l] = min(cost_stay_on, cost_switch_off)\n\n            # ===== State at start of period t is (s=0, l), i.e., OFFLINE =====\n            \n            # Option 1: Stay OFF\n            cost_stay_off = current_off_cost + dp[t + 1, 0, min(l + 1, L_max)]\n\n            # Option 2: Switch ON\n            cost_switch_on = np.inf\n            if l >= MDT:\n                cost_switch_on = SU + current_on_cost + dp[t + 1, 1, 1]\n\n            dp[t, 0, l] = min(cost_stay_off, cost_switch_on)\n            \n    # The minimum sum of costs is found at the initial state (s1, l1) for period t=1\n    min_sum_costs = dp[1, s1, l1]\n    \n    # Final reduced cost is the minimum sum of costs minus the convexity dual\n    total_reduced_cost = min_sum_costs - mu\n    return total_reduced_cost\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在解决了基本的定价子问题后，我们向模型中引入更真实的运行细节。本练习  在前一个动态规划模型的基础上，通过扩展状态变量来进一步考虑机组的“爬坡速率”（ramping rate）限制。此外，您还将分析发电出力水平“离散化”的粒度对解的质量与计算效率之间的影响，这是一个在能源系统建模实践中必须权衡的关键问题。",
            "id": "4078915",
            "problem": "考虑一个火电机组，它将在列生成（CG）框架内通过 Dantzig-Wolfe 分解进行定价，其中定价子问题是在满足爬坡约束的可行启停和出力轨迹上最小化检验数。我们假设生产成本是线性的，并且有一个外生价格轨迹，该轨迹来自主问题的能量平衡约束的对偶变量。目标是通过将前一时刻的出力 $p_{t-1}$ 增广到状态中来显式地纳入爬坡约束，并分析发电水平离散化对定价准确性的影响。\n\n从线性规划（LP）对偶性和 Dantzig-Wolfe 分解中的检验数这一基本基础出发。设 $\\lambda_t$ 是时刻 $t$ 的对偶价格（单位：美元/兆瓦时），发电机的参数如下：最小出力 $P_{\\min}$（单位：兆瓦），最大出力 $P_{\\max}$（单位：兆瓦），向上爬坡限制 $R^{\\uparrow}$（单位：兆瓦/小时），向下爬坡限制 $R^{\\downarrow}$（单位：兆瓦/小时），启动成本 $C^{\\text{su}}$（单位：美元），空载成本 $C^{\\text{nl}}$（单位：美元/小时），以及可变生产成本系数 $c$（单位：美元/兆瓦时）。设时间索引 $t$ 从 $t=1$ 到 $t=T$（以小时为单位），初始状态为 $p_{0}=0$ 且机组初始处于关闭状态。在价格 $\\lambda_t$ 下，一个列（一条可行轨迹）的检验数定义为总成本减去按对偶价格计算的收益：\n$$\n\\text{RC} \\;=\\; \\sum_{t=1}^{T} \\big( C^{\\text{nl}} \\, u_t + (c - \\lambda_t) \\, p_t \\big) \\;+\\; \\sum_{t=1}^{T} C^{\\text{su}} \\, \\mathbf{1}\\{u_{t-1}=0,\\,u_t=1\\},\n$$\n并服从机组运行约束\n$$\nu_t \\in \\{0,1\\}, \\quad p_t \\in [\\,P_{\\min} u_t,\\; P_{\\max} u_t\\,], \\quad p_t - p_{t-1} \\le R^{\\uparrow}, \\quad p_{t-1} - p_t \\le R^{\\downarrow}, \\quad p_0 = 0, \\quad u_0 = 0,\n$$\n其中 $u_t$ 是时刻 $t$ 的启停决策，$p_t$ 是时刻 $t$ 的出力。\n\n为了在动态规划（DP）递推中纳入爬坡约束，我们将状态增广以包括前一时刻的出力 $p_{t-1}$ 和启停状态 $u_{t-1}$。为了使定价问题在实践中计算上易于处理，许多实现方法都将可行的发电水平离散化。考虑将 $p_t$ 离散化为一个网格 $\\mathcal{G}_\\Delta = \\{0\\} \\cup \\{P_{\\min}, P_{\\min}+\\Delta, \\dots, P_{\\max}\\}$，其中步长为 $\\Delta$（单位：兆瓦）。这种离散化导致对真实检验数的近似。更精细的 $\\Delta$ 通常产生更接近的近似值，而更粗糙的 $\\Delta$ 则产生更少的状态和转移，但会增加近似误差。\n\n您的任务是实现一个动态规划求解器，该求解器使用增广状态和离散化发电水平来计算带爬坡约束的最小检验数。对于每个测试用例，使用粗糙离散化 $\\Delta_{\\text{coarse}}$ 和精细离散化 $\\Delta_{\\text{fine}}$ 计算最小检验数，然后报告定义如下的定价最优性间隙：\n$$\n\\text{Gap} \\;=\\; \\text{RC}_{\\Delta_{\\text{coarse}}}^{\\star} \\;-\\; \\text{RC}_{\\Delta_{\\text{fine}}}^{\\star},\n$$\n单位为美元。正的间隙表示在粗糙离散化下定价是次优的。\n\n必须遵守以下物理单位：功率水平 $p_t$、$P_{\\min}$、$P_{\\max}$、$R^{\\uparrow}$ 和 $R^{\\downarrow}$ 的单位为兆瓦；时间单位为小时；价格 $\\lambda_t$ 和可变成本 $c$ 的单位为美元/兆瓦时；空载成本 $C^{\\text{nl}}$ 的单位为美元/小时；启动成本 $C^{\\text{su}}$ 的单位为美元。最终报告的间隙值以美元表示，四舍五入到两位小数。\n\n实现程序以解决以下测试集的DP问题（每个测试用例指定 $T$、$\\{\\lambda_t\\}_{t=1}^{T}$、$P_{\\min}$、$P_{\\max}$、$R^{\\uparrow}$、$R^{\\downarrow}$、$c$、$C^{\\text{nl}}$、$C^{\\text{su}}$、$\\Delta_{\\text{coarse}}$、$\\Delta_{\\text{fine}}$）：\n\n- 测试用例 1 (具有中等爬坡率和变化价格的一般情况):\n  - $T = 6$,\n  - $\\lambda = [\\,30,\\,28,\\,35,\\,50,\\,45,\\,25\\,]$,\n  - $P_{\\min}=100$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=150$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=900$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- 测试用例 2 (更严格的爬坡限制，较低的 $P_{\\min}$ 以便在约束下启动):\n  - $T = 6$,\n  - $\\lambda = [\\,30,\\,28,\\,35,\\,50,\\,45,\\,25\\,]$,\n  - $P_{\\min}=60$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=70$, $R^{\\downarrow}=90$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=900$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- 测试用例 3 (低价格的单小时边界情况):\n  - $T = 1$,\n  - $\\lambda = [\\,20\\,]$,\n  - $P_{\\min}=80$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=150$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=900$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- 测试用例 4 (高启动成本抑制机组投入):\n  - $T = 6$,\n  - $\\lambda = [\\,30,\\,28,\\,35,\\,50,\\,45,\\,25\\,]$,\n  - $P_{\\min}=100$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=150$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=4000$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- 测试用例 5 (统一高价；研究受爬坡限制的升负荷过程):\n  - $T = 6$,\n  - $\\lambda = [\\,60,\\,60,\\,60,\\,60,\\,60,\\,60\\,]$,\n  - $P_{\\min}=100$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=120$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=800$,\n  - $\\Delta_{\\text{coarse}}=100$, $\\Delta_{\\text{fine}}=10$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列结果，每项是定价最优性间隙（单位：美元），四舍五入到两位小数（例如，$[\\,12.34,\\,0.00,\\,\\dots\\,]$）。",
            "solution": "此问题被评估为**有效**。这是一个在能源系统优化领域内定义明确、有科学依据的问题，具体涉及机组组合的列生成框架中的定价子问题。所有参数、约束和目标都得到了清晰且一致的定义。\n\n任务的核心是使用动态规划（DP）解决有向无环图上的最短路径问题。目标是找到单个火电机组在 $T$ 小时的时间范围内运行计划的最小检验数（$\\text{RC}$）。\n\n### 动态规划公式\n\n最优性原理适用，这使我们能够通过将问题分解为一系列更简单的决策来找到最优计划。\n\n**1. 阶段：** DP的阶段对应于时间段 $t \\in \\{1, 2, \\dots, T\\}$。我们按顺序一次一个时间段地解决问题。\n\n**2. 状态：** 为了在时刻 $t$ 做出决策，我们需要知道发电机在上一时段 $t-1$ 结束时的状态。爬坡约束 $p_t - p_{t-1} \\le R^{\\uparrow}$ 和 $p_{t-1} - p_t \\le R^{\\downarrow}$ 使得前一时刻的功率输出 $p_{t-1}$ 变得至关重要。启动成本 $C^{\\text{su}}$ 取决于机组之前是否处于关闭状态，这使得前一时刻的启停状态 $u_{t-1}$ 也至关重要。因此，在时段 $t$ 开始时的状态由元组 $(u_{t-1}, p_{t-1})$ 完全描述。状态空间是离散的。功率输出 $p_t$ 被限制在一个网格 $\\mathcal{G}_{\\Delta} = \\{0\\} \\cup \\{P_{\\min}, P_{\\min}+\\Delta, \\dots, P_{\\max}\\}$ 上。\n\n**3. 价值函数：** 令 $V_t(u_t, p_t)$ 为在时段 $t$ 结束时达到状态 $(u_t, p_t)$ 的最小累积检验数。我们的目标是找到 $\\min_{(u_T, p_T)} V_T(u_T, p_T)$。\n\n**4. 递推关系：** 我们使用前向递推。时刻 $t$ 的价值函数是基于时刻 $t-1$ 的值计算的。对于时刻 $t$ 的任何可达状态 $(u_t, p_t)$，其最小成本是所有可行的前驱状态 $(u_{t-1}, p_{t-1})$ 的前驱成本与转移成本之和的最小值。\n\n从 $(u_{t-1}, p_{t-1})$ 到 $(u_t, p_t)$ 在时段 $t$ 的转移成本是阶段成本，源于问题的检验数公式：\n$$\nC^{\\text{stage}}_t(u_{t-1}, p_{t-1}, u_t, p_t) = C^{\\text{nl}} u_t + (c - \\lambda_t) p_t + C^{\\text{su}} \\mathbf{1}\\{u_{t-1}=0, u_t=1\\}\n$$\n\nDP递推关系为：\n$$\nV_t(u_t, p_t) = \\min_{(u_{t-1}, p_{t-1})} \\left\\{ V_{t-1}(u_{t-1}, p_{t-1}) + C^{\\text{stage}}_t \\right\\}\n$$\n最小化是在所有可从中转移到 $(u_t, p_t)$ 的可行状态 $(u_{t-1}, p_{t-1})$ 上进行的。一个转移是可行的，如果它满足所有运行约束：\n- $u_t \\in \\{0, 1\\}$, $p_t \\in \\mathcal{G}_{\\Delta}$。\n- 如果 $u_t=1$，则 $p_t \\in [P_{\\min}, P_{\\max}]$。如果 $u_t=0$，则 $p_t=0$。\n- $p_t - p_{t-1} \\le R^{\\uparrow}$。\n- $p_{t-1} - p_t \\le R^{\\downarrow}$。这也约束了停机：一个处于功率 $p_{t-1}$ 的机组只有在 $p_{t-1} \\le R^{\\downarrow}$ 的情况下才能停机（至 $p_t=0$）。\n\n**5. 基准情形：** 问题定义了 $t=0$ 时的初始状态为关闭且出力为零。\n$$\nV_0(u_0=0, p_0=0) = 0\n$$\n在 $t=0$ 时的所有其他潜在状态都是不可达的，因此它们的成本为无穷大：对于 $(u,p) \\neq (0,0)$，$V_0(u, p) = \\infty$。\n\n### 算法实现\n\nDP通过从 $t=1$ 到 $T$ 迭代来实现。对于每个时间步 $t$，我们通过考虑从 $t-1$ 时刻的可行状态出发的所有可能转移，来计算每个可能状态 $(u_t, p_t)$ 的成本。\n\n1.  **离散化：** 对于给定的离散化步长 $\\Delta$，生成允许的功率水平集合 $\\mathcal{G}_{\\Delta}$。这是 $\\{0\\}$ 与从 $P_{\\min}$ 到 $P_{\\max}$ 以 $\\Delta$ 为增量的水平的并集。\n2.  **初始化：** 一个表（例如Python中的字典）存储成本 $V_t(u, p)$。用基准情形初始化 `dp_table[0]`：`{(0, 0): 0}`。\n3.  **迭代：**\n    对于 $t=1, \\dots, T$：\n    - 对于 `dp_table[t-1]` 中每个成本有限的源状态 $(u_{t-1}, p_{t-1})$：\n        - 评估到时刻 $t$ 的目标状态 $(u_t, p_t)$ 的可能转移。\n        - **转移到关闭状态：** 考虑 $(u_t, p_t) = (0,0)$。检查是否 $p_{t-1} \\le R^{\\downarrow}$。如果是，计算新的路径成本并更新 $V_t(0,0)$。\n        - **转移到开启状态：** 对于每个 $p_t \\in \\mathcal{G}_{\\Delta} \\setminus \\{0\\}$，考虑 $(u_t, p_t) = (1, p_t)$。检查是否满足爬坡约束。如果是，计算该阶段的启动和运行成本，加到之前的路径成本上，并更新 $V_t(1, p_t)$。\n4.  **最终结果：** 在遍历完所有 $T$ 个时段后，最小检验数是在 `dp_table[T]` 中所有可能的最终状态中找到的最小值。\n\n整个过程使用 $\\Delta = \\Delta_{\\text{coarse}}$ 执行一次以找到 $\\text{RC}_{\\Delta_{\\text{coarse}}}^{\\star}$，再使用 $\\Delta = \\Delta_{\\text fine}$ 执行一次以找到 $\\text{RC}_{\\Delta_{\\text{fine}}}^{\\star}$。最终的最优性间隙是它们的差值，$\\text{Gap} = \\text{RC}_{\\Delta_{\\text{coarse}}}^{\\star} - \\text{RC}_{\\Delta_{\\text{fine}}}^{\\star}$。正的间隙表示较粗的网格导致了次优的定价决策，未能找到通过较细网格可访问的真实最小检验数。",
            "answer": "```python\nimport numpy as np\n\ndef compute_min_rc(\n    T: int,\n    lambdas: list[float],\n    P_min: float,\n    P_max: float,\n    R_up: float,\n    R_down: float,\n    c: float,\n    C_nl: float,\n    C_su: float,\n    Delta: float,\n):\n    \"\"\"\n    Computes the minimum reduced cost using Dynamic Programming.\n\n    The state is defined by (u, p): commitment status u and power output p.\n    dp_table[t] stores a dictionary mapping state (u, p) to its minimum\n    cumulative reduced cost up to time t.\n    \"\"\"\n    \n    # Generate the discretized grid of power levels for the ON state.\n    # We add a small epsilon to P_max to ensure it's included if it's on the grid.\n    if Delta = 0 or P_min > P_max:\n        on_grid = np.array([], dtype=float)\n    else:\n        on_grid = np.arange(P_min, P_max + 1e-9, Delta)\n\n    # dp_table[t] is a dictionary: {(u, p): cost}\n    dp_table = {}\n    \n    # Base case at t=0: unit is off, power is 0, cost is 0.\n    dp_table[0] = {(0, 0.0): 0.0}\n\n    # Iterate through each time period\n    for t in range(1, T + 1):\n        dp_table[t] = {}\n        lambda_t = lambdas[t - 1]\n\n        # Iterate through all reachable states at the previous time step\n        for (u_prev, p_prev), cost_prev in dp_table[t - 1].items():\n            \n            # --- Possibility 1: Unit is OFF at time t ---\n            u_curr, p_curr = 0, 0.0\n            \n            # A unit can transition to OFF only if its previous power level\n            # does not exceed the ramp-down limit for a single step to zero.\n            if p_prev - p_curr = R_down:\n                # Stage cost is 0 when the unit is off.\n                stage_cost = 0.0\n                new_cost = cost_prev + stage_cost\n\n                # Update the DP table with the minimum cost found so far for this state\n                current_min = dp_table[t].get((u_curr, p_curr), float('inf'))\n                dp_table[t][(u_curr, p_curr)] = min(current_min, new_cost)\n\n            # --- Possibility 2: Unit is ON at time t ---\n            u_curr = 1\n            for p_curr in on_grid:\n                # Check ramp-up and ramp-down constraints for the transition\n                if p_curr - p_prev > R_up or p_prev - p_curr > R_down:\n                    continue  # This transition is infeasible\n\n                # Calculate the cost for this stage\n                startup_cost = C_su if u_prev == 0 else 0.0\n                operating_cost = C_nl + (c - lambda_t) * p_curr\n                stage_cost = startup_cost + operating_cost\n                \n                new_cost = cost_prev + stage_cost\n                \n                # Update the DP table with the minimum cost\n                current_min = dp_table[t].get((u_curr, p_curr), float('inf'))\n                dp_table[t][(u_curr, p_curr)] = min(current_min, new_cost)\n    \n    # The minimum reduced cost is the minimum cost over all possible final states at time T.\n    final_costs = dp_table[T].values()\n    \n    if not final_costs:\n        return float('inf')  # Should not be reached if staying off is always an option\n        \n    return min(final_costs)\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"T\": 6, \"lambda\": [30, 28, 35, 50, 45, 25], \"P_min\": 100, \"P_max\": 300,\n            \"R_up\": 120, \"R_down\": 150, \"c\": 28, \"C_nl\": 200, \"C_su\": 900,\n            \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 6, \"lambda\": [30, 28, 35, 50, 45, 25], \"P_min\": 60, \"P_max\": 300,\n            \"R_up\": 70, \"R_down\": 90, \"c\": 28, \"C_nl\": 200, \"C_su\": 900,\n            \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 1, \"lambda\": [20], \"P_min\": 80, \"P_max\": 300, \"R_up\": 120, \"R_down\": 150,\n            \"c\": 28, \"C_nl\": 200, \"C_su\": 900, \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 6, \"lambda\": [30, 28, 35, 50, 45, 25], \"P_min\": 100, \"P_max\": 300,\n            \"R_up\": 120, \"R_down\": 150, \"c\": 28, \"C_nl\": 200, \"C_su\": 4000,\n            \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 6, \"lambda\": [60, 60, 60, 60, 60, 60], \"P_min\": 100, \"P_max\": 300,\n            \"R_up\": 120, \"R_down\": 120, \"c\": 28, \"C_nl\": 200, \"C_su\": 800,\n            \"delta_coarse\": 100, \"delta_fine\": 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params_coarse = (\n            case[\"T\"], case[\"lambda\"], case[\"P_min\"], case[\"P_max\"],\n            case[\"R_up\"], case[\"R_down\"], case[\"c\"], case[\"C_nl\"], case[\"C_su\"],\n            case[\"delta_coarse\"]\n        )\n        rc_coarse = compute_min_rc(*params_coarse)\n\n        params_fine = (\n            case[\"T\"], case[\"lambda\"], case[\"P_min\"], case[\"P_max\"],\n            case[\"R_up\"], case[\"R_down\"], case[\"c\"], case[\"C_nl\"], case[\"C_su\"],\n            case[\"delta_fine\"]\n        )\n        rc_fine = compute_min_rc(*params_fine)\n\n        gap = rc_coarse - rc_fine\n        results.append(f\"{gap:.2f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}