{
    "hands_on_practices": [
        {
            "introduction": "Every column generation algorithm requires a starting point, and this practice focuses on creating the initial Restricted Master Problem (RMP). By generating a few simple, heuristic schedules for each generating unit, you will construct the initial RMP and evaluate its quality. This foundational exercise is crucial for understanding the structure of the master problem and the role of lower and upper bounds in tracking the algorithm's progress toward optimality .",
            "id": "4078892",
            "problem": "Design and implement a program that constructs an initial Restricted Master Problem (RMP) for a decomposed unit commitment formulation using Dantzig–Wolfe decomposition and evaluates the feasibility and bound quality of this initial column set. The setting is a multi-period thermal generation scheduling problem with linear variable costs, no ramping, no minimum up/down times, and a one-hour time step so that power in megawatts is numerically equal to energy in megawatt-hours over each period. All costs must be reported in dollars, and all powers must be interpreted in megawatts with a one-hour period length.\n\nStart from the following foundational base:\n- The Dantzig–Wolfe decomposition principle: a large-scale linear programming problem can be reformulated so that feasible decisions are expressed as convex combinations of extreme points (columns) of subproblem polytopes.\n- The linear programming relaxation lower bound property: the optimal objective value of a linear programming relaxation is less than or equal to the optimal value of the original mixed-integer problem in a minimization setting.\n- Feasible supply coverage: at each time period, total generation plus any explicitly modeled load shedding must be no less than the demand.\n\nFormulation for the initial RMP:\n- Let the set of units be indexed by $u \\in \\{1,\\dots,|U|\\}$ and the set of time periods by $t \\in \\{1,\\dots,|T|\\}$. For each unit $u$, parameters are minimum output $P^{\\min}_u$ in megawatts, maximum output $P^{\\max}_u$ in megawatts, and linear variable cost $c_u$ in dollars per megawatt-hour. Let the demand profile be $D_t$ in megawatts for each period $t$.\n- A column for unit $u$ is defined by a predetermined output profile $\\{p_{u,k,t}\\}_{t=1}^{|T|}$ with associated column cost $\\text{cost}_{u,k} = \\sum_{t=1}^{|T|} c_u \\, p_{u,k,t}$ in dollars.\n- Decision variables are $\\lambda_{u,k} \\ge 0$ for each column $k$ of unit $u$, and $s_t \\ge 0$ representing load shedding at time $t$ in megawatts. The convexity constraint per unit is $\\sum_k \\lambda_{u,k} = 1$. The demand coverage constraints are $\\sum_{u} \\sum_{k} \\lambda_{u,k} \\, p_{u,k,t} + s_t \\ge D_t$ for all $t$.\n- The RMP objective is to minimize $\\sum_{u} \\sum_{k} \\text{cost}_{u,k} \\, \\lambda_{u,k} + M \\sum_{t} s_t$, where $M$ is a large penalty in dollars per megawatt-hour for load shedding. In this problem, use $M = \\$\\,10000$.\n\nInitial columns per unit:\n- Always-off: $p_{u,\\text{off},t} = 0$ for all $t$ and $\\text{cost}_{u,\\text{off}} = 0$.\n- Always-on at $P^{\\min}$: $p_{u,\\text{min},t} = P^{\\min}_u$ for all $t$ and $\\text{cost}_{u,\\text{min}} = \\sum_{t=1}^{|T|} c_u \\, P^{\\min}_u$.\n- Merit-order schedule: For each period $t$, sort units by ascending $c_u$. Starting from the cheapest unit, cumulatively add $P^{\\min}$ until reaching or exceeding $D_t$. Mark $y_{u,t} = 1$ if unit $u$ is in this set at period $t$, otherwise $y_{u,t} = 0$. Define $p_{u,\\text{merit},t} = y_{u,t} \\, P^{\\min}_u$ and $\\text{cost}_{u,\\text{merit}} = \\sum_{t=1}^{|T|} c_u \\, y_{u,t} \\, P^{\\min}_u$.\n\nUpper bound construction for bound quality:\n- Independently of the RMP, construct a feasible per-period unit commitment and dispatch that respects $P^{\\min}_u$ when a unit is on and $P^{\\max}_u$ as an upper bound. For each time $t$, in ascending order of $c_u$, turn on units and assign outputs $p_{u,t}$ with $p_{u,t} \\in \\{0\\} \\cup [P^{\\min}_u, P^{\\max}_u]$ until cumulative output meets or exceeds $D_t$. Assign $p_{u,t} = \\min\\{P^{\\max}_u, \\max\\{P^{\\min}_u, \\text{residual}\\}\\}$ at the moment a unit is turned on, where the residual is the remaining unmet demand. The period cost is $\\sum_u c_u \\, p_{u,t}$ and the total cost is $\\sum_t \\sum_u c_u \\, p_{u,t}$. Assume total available capacity satisfies $\\sum_u P^{\\max}_u \\ge D_t$ for all $t$, ensuring feasibility.\n- Define the lower bound as the optimal RMP objective value, denoted $LB$. Define the upper bound as the heuristic feasible cost constructed above, denoted $UB$.\n- Define a scalar bound quality indicator $Q$ as follows: if $UB \\le 10^{-9}$ then $Q = 1$ if $LB \\le 10^{-9}$ and $Q = 0$ otherwise; else $Q = \\min\\{1, \\max\\{0, LB/UB\\}\\}$. This $Q$ is a decimal in $[0,1]$.\n\nTasks:\n- For each test instance below, generate the initial columns, solve the RMP, compute $LB$, compute $UB$, determine feasibility of the initial RMP without load shedding (all $s_t = 0$ within a tolerance of $10^{-6}$), compute the total load shed $\\sum_t s_t$, and compute $Q$.\n- Express all costs in dollars and energy quantities in megawatt-hours aligned with one-hour periods; however, the required program output is purely numerical. Round $LB$, $UB$, $Q$, and the total load shed to six decimal places in the final output.\n\nTest suite:\n- Case A (happy path): $|U| = 3$, $|T| = 3$, $P^{\\min} = [10, 15, 5]$ megawatts, $P^{\\max} = [50, 40, 30]$ megawatts, $c = [35, 20, 60]$ dollars per megawatt-hour, $D = [25, 20, 30]$ megawatts.\n- Case B (boundary condition): same units as Case A, $D = [30, 30, 30]$ megawatts.\n- Case C (infeasible initial columns without shedding): same units as Case A, $D = [45, 35, 50]$ megawatts.\n- Case D (zero demand): same units as Case A, $D = [0, 0, 0]$ megawatts.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of results, one per case, where each case result is itself a list of the form $[\\text{feasible}, LB, UB, Q, \\text{shed}]$ with $\\text{feasible}$ a boolean, and $LB$, $UB$, $Q$, and $\\text{shed}$ as decimal floats rounded to six places. The overall output line must be exactly a single list, for example, `[True, 123.456000, 200.000000, 0.617280, 0.000000],[\\dots]]`.",
            "solution": "The user's request is to design and implement a program to solve a simplified thermal unit commitment problem using a Dantzig-Wolfe decomposition framework. The core task involves constructing an initial Restricted Master Problem (RMP), solving it to find a lower bound ($LB$), separately constructing a heuristic feasible solution to find an upper bound ($UB$), and evaluating the quality of the initial setup.\n\nThe problem statement has been validated and found to be scientifically grounded, well-posed, objective, and internally consistent. It provides all necessary data and definitions to proceed with a unique and verifiable solution.\n\nThe solution proceeds in three main stages:\n1.  Construction of the initial set of columns for each generating unit.\n2.  Formulation and solution of the initial Restricted Master Problem (RMP), which is a Linear Program (LP), to obtain the lower bound ($LB$).\n3.  Construction of a heuristic upper bound ($UB$) via a per-period greedy dispatch algorithm.\n\nLet the set of generating units be $U$ and the set of time periods be $T$. For each unit $u \\in U$, we are given a minimum power output $P^{\\min}_u$, a maximum power output $P^{\\max}_u$, and a variable cost of generation $c_u$. For each time period $t \\in T$, there is a power demand $D_t$.\n\n**1. Initial Column Generation**\n\nFor each unit $u \\in U$, we generate a set of initial operating schedules, known as columns. Each column $k$ is a vector of power outputs $\\{p_{u,k,t}\\}_{t \\in T}$ and has an associated cost, $\\text{cost}_{u,k} = \\sum_{t \\in T} c_u p_{u,k,t}$. The problem specifies three initial columns for each unit:\n\n*   **Always-off column ($k=\\text{off}$):** This column represents the unit being shut down for the entire planning horizon.\n    *   Power profile: $p_{u,\\text{off},t} = 0$ for all $t \\in T$.\n    *   Cost: $\\text{cost}_{u,\\text{off}} = \\sum_{t \\in T} c_u \\cdot 0 = 0$.\n\n*   **Always-on at minimum power column ($k=\\text{min}$):** This column represents the unit operating at its minimum stable generation level for the entire horizon.\n    *   Power profile: $p_{u,\\text{min},t} = P^{\\min}_u$ for all $t \\in T$.\n    *   Cost: $\\text{cost}_{u,\\text{min}} = \\sum_{t \\in T} c_u P^{\\min}_u = |T| \\cdot c_u P^{\\min}_u$.\n\n*   **Merit-order column ($k=\\text{merit}$):** This column represents a simple economic commitment strategy. For each time period $t$, units are conceptually committed in order of increasing variable cost $c_u$ until the cumulative minimum power of the committed units meets or exceeds the demand $D_t$.\n    *   Let $\\pi$ be a permutation of the unit indices $\\{1, \\dots, |U|\\}$ that sorts the units by ascending cost, so $c_{\\pi(1)} \\le c_{\\pi(2)} \\le \\dots \\le c_{\\pi(|U|)}$.\n    *   For each $t \\in T$, find the smallest integer $N_t$ such that $\\sum_{i=1}^{N_t} P^{\\min}_{\\pi(i)} \\ge D_t$.\n    *   Define a binary indicator $y_{u,t} = 1$ if unit $u$ is among the first $N_t$ cheapest units for period $t$, and $y_{u,t} = 0$ otherwise.\n    *   Power profile: $p_{u,\\text{merit},t} = y_{u,t} P^{\\min}_u$ for all $t \\in T$.\n    *   Cost: $\\text{cost}_{u,\\text{merit}} = \\sum_{t \\in T} c_u p_{u,\\text{merit},t} = \\sum_{t \\in T} c_u y_{u,t} P^{\\min}_u$.\n\n**2. Restricted Master Problem (RMP) Formulation and Solution**\n\nThe RMP is an LP that seeks the optimal convex combination of the initial columns to minimize total cost while satisfying demand.\n\n**Decision Variables:**\n*   $\\lambda_{u,k} \\ge 0$: The weight assigned to column $k$ for unit $u$.\n*   $s_t \\ge 0$: The amount of load shedding (unmet demand) in period $t$, penalized at a high cost $M = 10000$ \\$/MWh.\n\n**Objective Function:**\nThe objective is to minimize the sum of generation costs and the penalty for load shedding.\n$$ \\min Z_{RMP} = \\sum_{u \\in U} \\sum_{k} \\text{cost}_{u,k} \\lambda_{u,k} + M \\sum_{t \\in T} s_t $$\nThe optimal value $Z_{RMP}^*$ provides the lower bound, $LB = Z_{RMP}^*$.\n\n**Constraints:**\n*   **Convexity Constraints:** For each unit $u$, the weights of its columns must sum to $1$. This ensures that the operating schedule for each unit is a valid convex combination of its proposed schedules.\n    $$ \\sum_{k} \\lambda_{u,k} = 1 \\quad \\forall u \\in U $$\n*   **Demand Constraints:** For each time period $t$, the total power generated by all units plus any load shedding must meet or exceed the demand. The generation from unit $u$ at time $t$ is the weighted average of the power outputs from its columns, $\\sum_{k} \\lambda_{u,k} p_{u,k,t}$.\n    $$ \\sum_{u \\in U} \\left( \\sum_{k} \\lambda_{u,k} p_{u,k,t} \\right) + s_t \\ge D_t \\quad \\forall t \\in T $$\n\nThis LP can be solved using standard solvers, such as `scipy.optimize.linprog`. The problem is guaranteed to be feasible due to the presence of the high-cost slack variables $s_t$.\n\n**3. Upper Bound (UB) Heuristic Construction**\n\nAn upper bound on the optimal cost of the original problem is obtained by constructing any feasible solution. The problem specifies a greedy heuristic performed independently for each time period.\n\nFor each period $t \\in T$:\n1.  Initialize unmet demand, $d_{\\text{rem}} = D_t$.\n2.  Initialize the generation of all units for period $t$ to zero: $p_{u,t} = 0$ for all $u \\in U$.\n3.  Process units in ascending order of their variable costs $c_u$.\n4.  For each unit $u$ in this merit order:\n    a. If $d_{\\text{rem}} > 0$, commit the unit.\n    b. The power to be generated by this unit is $p_{u,t} = \\min(P^{\\max}_u, \\max(P^{\\min}_u, d_{\\text{rem}}))$. Note that if the remaining demand $d_{\\text{rem}}$ is between $0$ and $P^{\\min}_u$, the unit is dispatched at $P^{\\min}_u$.\n    c. Update the remaining demand: $d_{\\text{rem}} = d_{\\text{rem}} - p_{u,t}$.\n    d. If $d_{\\text{rem}} \\le 0$, stop committing more units for this period.\n5. The total cost of this heuristic solution is the sum of costs over all periods:\n$$ UB = \\sum_{t \\in T} \\sum_{u \\in U} c_u p_{u,t} $$\nThe problem guarantees that $\\sum_{u \\in U} P^{\\max}_u \\ge D_t$ for all $t$, ensuring this heuristic can always meet demand without shedding.\n\n**4. Final Output Metrics**\n\nAfter computing $LB$ and $UB$, we derive the final set of metrics for each test case:\n*   **Feasibility (`feasible`):** The initial RMP is considered feasible without load shedding if the sum of optimal shedding variables is close to zero. We check if $\\sum_{t \\in T} s_t^* \\le 10^{-6}$, where $s_t^*$ are the optimal values from the LP solution.\n*   **Lower Bound ($LB$):** The optimal objective value of the solved RMP, $Z_{RMP}^*$.\n*   **Upper Bound ($UB$):** The cost from the greedy heuristic.\n*   **Load Shed (`shed`):** The total load shed from the RMP solution, $\\sum_{t \\in T} s_t^*$.\n*   **Bound Quality ($Q$):** A normalized measure of the gap between $LB$ and $UB$.\n    $$ Q = \\begin{cases} 1 & \\text{if } UB \\le 10^{-9} \\text{ and } LB \\le 10^{-9} \\\\ 0 & \\text{if } UB \\le 10^{-9} \\text{ and } LB > 10^{-9} \\\\ \\min\\{1, \\max\\{0, LB/UB\\}\\} & \\text{otherwise} \\end{cases} $$\nAll numerical results are rounded to six decimal places. The implementation will structure the LP matrices and vectors for `scipy.optimize.linprog` and execute the above logic for each provided test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    It defines the test cases, iterates through them, computes the required metrics,\n    and prints the results in the specified format.\n    \"\"\"\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [25, 20, 30],\n        },\n        # Case B: Boundary condition\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [30, 30, 30],\n        },\n        # Case C: Infeasible initial columns without shedding\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [45, 35, 50],\n        },\n        # Case D: Zero demand\n        {\n            \"p_min\": [10, 15, 5],\n            \"p_max\": [50, 40, 30],\n            \"cost_var\": [35, 20, 60],\n            \"demand\": [0, 0, 0],\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        result_tuple = run_case(case_data)\n        results.append(result_tuple)\n\n    # Format the final output string exactly as required.\n    formatted_results = []\n    for res in results:\n        feasible, lb, ub, q, shed = res\n        formatted_res = f\"[{str(feasible)}, {lb:.6f}, {ub:.6f}, {q:.6f}, {shed:.6f}]\"\n        formatted_results.append(formatted_res)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_case(case_data):\n    \"\"\"\n    Solves a single test case instance.\n    Generates initial columns, solves the RMP, computes the UB, and returns metrics.\n    \"\"\"\n    p_min = np.array(case_data[\"p_min\"], dtype=float)\n    p_max = np.array(case_data[\"p_max\"], dtype=float)\n    cost_var = np.array(case_data[\"cost_var\"], dtype=float)\n    demand = np.array(case_data[\"demand\"], dtype=float)\n    \n    num_units = len(p_min)\n    num_periods = len(demand)\n    shed_penalty = 10000.0\n    tol = 1e-6\n\n    # --- 1. Generate Initial Columns ---\n    columns = [[] for _ in range(num_units)]\n    \n    # Unit indices sorted by cost (merit order)\n    merit_order_indices = np.argsort(cost_var)\n\n    for u in range(num_units):\n        # Always-off column\n        p_off = np.zeros(num_periods)\n        cost_off = 0.0\n        columns[u].append({'profile': p_off, 'cost': cost_off})\n\n        # Always-on at P_min column\n        p_min_on = np.full(num_periods, p_min[u])\n        cost_min_on = num_periods * cost_var[u] * p_min[u]\n        columns[u].append({'profile': p_min_on, 'cost': cost_min_on})\n\n        # Merit-order column\n        p_merit = np.zeros(num_periods)\n        for t in range(num_periods):\n            cum_pmin = 0.0\n            for u_merit_idx in merit_order_indices:\n                cum_pmin += p_min[u_merit_idx]\n                if u_merit_idx == u:\n                    p_merit[t] = p_min[u]\n                    break\n                if cum_pmin >= demand[t]:\n                    break\n        cost_merit = np.sum(cost_var[u] * p_merit)\n        columns[u].append({'profile': p_merit, 'cost': cost_merit})\n\n    # --- 2. Formulate and Solve the RMP (LP) ---\n    num_lambda_vars = sum(len(c) for c in columns)\n    num_shed_vars = num_periods\n    num_total_vars = num_lambda_vars + num_shed_vars\n\n    # Objective function vector\n    c_lp = np.zeros(num_total_vars)\n    lambda_idx = 0\n    for u in range(num_units):\n        for col_data in columns[u]:\n            c_lp[lambda_idx] = col_data['cost']\n            lambda_idx += 1\n    c_lp[num_lambda_vars:] = shed_penalty\n\n    # Equality constraints (convexity): A_eq * x = b_eq\n    A_eq = np.zeros((num_units, num_total_vars))\n    b_eq = np.ones(num_units)\n    lambda_idx = 0\n    for u in range(num_units):\n        num_cols_u = len(columns[u])\n        A_eq[u, lambda_idx : lambda_idx + num_cols_u] = 1.0\n        lambda_idx += num_cols_u\n\n    # Inequality constraints (demand): A_ub * x <= b_ub\n    # Original: sum(lambda*p) + s >= D  => -sum(lambda*p) - s <= -D\n    A_ub = np.zeros((num_periods, num_total_vars))\n    b_ub = -demand\n    \n    lambda_idx = 0\n    for u in range(num_units):\n        for col_data in columns[u]:\n            A_ub[:, lambda_idx] = -col_data['profile']\n            lambda_idx += 1\n            \n    for t in range(num_periods):\n        A_ub[t, num_lambda_vars + t] = -1.0\n        \n    bounds = [(0, None) for _ in range(num_total_vars)]\n\n    res = linprog(c=c_lp, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    lb = res.fun if res.success else float('inf')\n    \n    total_shed = 0.0\n    if res.success:\n        shed_vars = res.x[num_lambda_vars:]\n        total_shed = np.sum(shed_vars)\n\n    is_feasible_no_shed = total_shed <= tol\n\n    # --- 3. Compute Upper Bound (UB) ---\n    ub = 0.0\n    for t in range(num_periods):\n        demand_rem = demand[t]\n        cost_t = 0.0\n        \n        # Handle zero demand case explicitly\n        if demand_rem <= tol:\n            continue\n            \n        for u in merit_order_indices:\n            if demand_rem > tol:\n                p_ut = min(p_max[u], max(p_min[u], demand_rem))\n                cost_t += cost_var[u] * p_ut\n                demand_rem -= p_ut\n        ub += cost_t\n\n    # --- 4. Compute Bound Quality (Q) ---\n    if ub <= 1e-9:\n        q = 1.0 if lb <= 1e-9 else 0.0\n    else:\n        q = min(1.0, max(0.0, lb / ub))\n\n    return is_feasible_no_shed, lb, ub, q, total_shed\n\nsolve()\n```"
        },
        {
            "introduction": "Once the master problem is initialized, the next step is to generate new, more cost-effective columns, which is the role of the pricing subproblem. This practice guides you through implementing a dynamic programming solver to find the optimal schedule for a single unit, incorporating fundamental operational limits like minimum up-time ($MUT$) and minimum down-time ($MDT$). Mastering this core subproblem is essential, as it forms the engine of the entire column generation procedure .",
            "id": "4078854",
            "problem": "Consider a single thermal generating unit in the context of Unit Commitment (UC) column generation. The Dantzig-Wolfe (DW) decomposition applied to Mixed Integer Programming (MIP) yields a master problem whose dual variables feed a per-unit subproblem that searches for a schedule minimizing the reduced cost. From Linear Programming (LP) duality, the reduced cost of a candidate column indexed by $j$ is given by $r_j = c_j - y^\\top A_j$, where $c_j$ is the original column cost and $y$ are the dual variables associated with the coupling constraints in the master problem. For a single unit, we model the subproblem over a discrete time horizon indexed by $t \\in \\{1, \\dots, T\\}$ with a state space that enforces Minimum Up Time (MUT) and Minimum Down Time (MDT) via the pair $(s_t, \\ell_t)$, where $s_t \\in \\{0,1\\}$ indicates on/off status and $\\ell_t \\in \\mathbb{Z}_{\\ge 0}$ counts time spent in the current status. The dynamics must enforce that once the unit switches on, it remains on for at least $MUT_i$ periods, and once it switches off, it remains off for at least $MDT_i$ periods. Transitions are of the form $(s_t, \\ell_t) \\to (s_{t+1}, \\ell_{t+1})$ with the rules: staying in the same status increments $\\ell_t$ by one (capped for state-space compactness), and switching is only allowed if $\\ell_t$ satisfies the respective minimum-time threshold ($\\ell_t \\ge MUT_i$ to turn off and $\\ell_t \\ge MDT_i$ to turn on).\n\nAssume linear variable production cost per megawatt-hour $c_i$ and a per-period fixed cost when online $F_i$. Let $P^{\\min}_i$ and $P^{\\max}_i$ denote minimum and maximum output when online. Startup and shutdown incur costs $SU_i$ and $SD_i$, respectively. The master problem’s demand balance dual price series is $\\{\\lambda_t\\}_{t=1}^T$ in dollars per megawatt-hour. The convexity constraint dual for unit $i$ is $\\mu_i$ in dollars per horizon. For a period $t$ when the unit is online, the reduced cost contribution is the minimum over output $g_t \\in [P^{\\min}_i, P^{\\max}_i]$ of $F_i + c_i g_t - \\lambda_t g_t$, which is achieved at $g_t = P^{\\max}_i$ if $c_i - \\lambda_t \\le 0$, and at $g_t = P^{\\min}_i$ if $c_i - \\lambda_t > 0$. When the unit is offline, the per-period contribution is zero. A transition from offline to online adds $SU_i$, and from online to offline adds $SD_i$. The total reduced cost of a schedule is the sum over time of these contributions minus $\\mu_i$.\n\nYour task is to implement a program that, for each test case, constructs the allowed transitions in the state space $(s_t, \\ell_t)$ with $\\ell_t$ counting time in the current status, and computes the minimum total reduced cost over the horizon by dynamic programming, starting from a specified initial state $(s_1, \\ell_1)$. Use the following fundamental base:\n\n- The reduced cost formula from Linear Programming duality: $r_j = c_j - y^\\top A_j$.\n- The per-period reduced cost contribution while online computed as $F_i + \\min_{g_t \\in [P^{\\min}_i, P^{\\max}_i]} (c_i - \\lambda_t) g_t$.\n- Enforcing Minimum Up Time (MUT) and Minimum Down Time (MDT) through the state transition rules on $(s_t, \\ell_t)$.\n\nDefine the state space so that $\\ell_t$ is capped at $\\max\\{MUT_i, MDT_i, 1\\}$ for the current status to keep the state space finite, without affecting the minimum-time logic. The initial $\\ell_1$ may be zero; interpret $\\ell_1 = 0$ as immediately eligible to switch if the corresponding minimum-time is zero. If switching occurs at period $t$, apply $SU_i$ or $SD_i$ at that period together with the per-period contribution of the resulting status.\n\nAll physical and monetary units must be respected as follows: power in megawatts (MW), energy prices and variable costs in dollars per megawatt-hour ($\\$\\!/\\mathrm{MWh}$), fixed online costs in dollars per period ($\\$$), startup and shutdown costs in dollars ($\\$$). Express the final reduced cost in dollars ($\\$$) as a float. Angles do not appear. Percentages do not appear.\n\nImplement the program to evaluate the following test suite of parameter sets:\n\n- Test case $1$ (happy path):\n  - Time horizon $T = 6$ periods (hours).\n  - Minimum up time $MUT_i = 2$ hours, minimum down time $MDT_i = 2$ hours.\n  - Initial state $(s_1, \\ell_1) = (0, 2)$.\n  - $P^{\\min}_i = 50$ MW, $P^{\\max}_i = 120$ MW.\n  - Variable cost $c_i = 30$ $\\$\\!/\\mathrm{MWh}$, fixed online cost $F_i = 100$ $\\$$.\n  - Startup cost $SU_i = 500$ $\\$$, shutdown cost $SD_i = 0$ $\\$$.\n  - Demand balance dual prices $\\{\\lambda_t\\}_{t=1}^6 = \\{40, 45, 35, 20, 10, 50\\}$ $\\$\\!/\\mathrm{MWh}$.\n  - Convexity dual $\\mu_i = 0$ $\\$$.\n\n- Test case $2$ (boundary with zero minimum times and no incentives to generate):\n  - Time horizon $T = 4$ periods (hours).\n  - Minimum up time $MUT_i = 0$ hours, minimum down time $MDT_i = 0$ hours.\n  - Initial state $(s_1, \\ell_1) = (0, 0)$.\n  - $P^{\\min}_i = 10$ MW, $P^{\\max}_i = 10$ MW.\n  - Variable cost $c_i = 30$ $\\$\\!/\\mathrm{MWh}$, fixed online cost $F_i = 0$ $\\$$.\n  - Startup cost $SU_i = 0$ $\\$$, shutdown cost $SD_i = 0$ $\\$$.\n  - Demand balance dual prices $\\{\\lambda_t\\}_{t=1}^4 = \\{25, 25, 25, 25\\}$ $\\$\\!/\\mathrm{MWh}$.\n  - Convexity dual $\\mu_i = 0$ $\\$$.\n\n- Test case $3$ (edge case with enforced initial on duration):\n  - Time horizon $T = 5$ periods (hours).\n  - Minimum up time $MUT_i = 3$ hours, minimum down time $MDT_i = 1$ hours.\n  - Initial state $(s_1, \\ell_1) = (1, 1)$.\n  - $P^{\\min}_i = 20$ MW, $P^{\\max}_i = 60$ MW.\n  - Variable cost $c_i = 20$ $\\$\\!/\\mathrm{MWh}$, fixed online cost $F_i = 50$ $\\$$.\n  - Startup cost $SU_i = 200$ $\\$$, shutdown cost $SD_i = 0$ $\\$$.\n  - Demand balance dual prices $\\{\\lambda_t\\}_{t=1}^5 = \\{15, 15, 15, 15, 15\\}$ $\\$\\!/\\mathrm{MWh}$.\n  - Convexity dual $\\mu_i = 0$ $\\$$.\n\n- Test case $4$ (high prices encouraging maximum production):\n  - Time horizon $T = 3$ periods (hours).\n  - Minimum up time $MUT_i = 1$ hours, minimum down time $MDT_i = 1$ hours.\n  - Initial state $(s_1, \\ell_1) = (0, 1)$.\n  - $P^{\\min}_i = 10$ MW, $P^{\\max}_i = 50$ MW.\n  - Variable cost $c_i = 20$ $\\$\\!/\\mathrm{MWh}$, fixed online cost $F_i = 10$ $\\$$.\n  - Startup cost $SU_i = 100$ $\\$$, shutdown cost $SD_i = 0$ $\\$$.\n  - Demand balance dual prices $\\{\\lambda_t\\}_{t=1}^3 = \\{100, 100, 100\\}$ $\\$\\!/\\mathrm{MWh}$.\n  - Convexity dual $\\mu_i = 0$ $\\$$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1, r_2, r_3, r_4]$), where $r_k$ is the minimum total reduced cost in dollars computed for test case $k$.",
            "solution": "The problem is valid. It is a well-posed optimization problem grounded in the established principles of mathematical programming and dynamic programming as applied to power systems operations, specifically the unit commitment (UC) subproblem within a column generation framework. All necessary data and definitions for a unique solution are provided, and there are no scientific or logical contradictions.\n\nThe task is to find the minimum reduced cost schedule for a single thermal generating unit over a time horizon $t \\in \\{1, \\dots, T\\}$. This problem can be solved using dynamic programming (DP). The core of the DP approach is to define a state, a value function for each state, and a recurrence relation that computes the value function by making optimal decisions at each time step.\n\nLet the state of the unit at the beginning of a time period $t$ be described by the tuple $(s_t, \\ell_t)$, where $s_t \\in \\{0, 1\\}$ is the on/off status ($1$ for on, $0$ for off) and $\\ell_t \\in \\mathbb{Z}_{\\ge 0}$ is the number of consecutive hours the unit has been in that status. To maintain a finite state space, $\\ell_t$ is capped at $L_{\\max} = \\max\\{MUT_i, MDT_i, 1\\}$, where $MUT_i$ and $MDT_i$ are the minimum up and down times, respectively. The state at time $t$ is thus $(s, \\ell)$ where $s \\in \\{0, 1\\}$ and $\\ell \\in \\{0, 1, \\dots, L_{\\max}\\}$.\n\nLet $V(t, s, \\ell)$ be the minimum possible sum of per-period reduced costs from the beginning of period $t$ to the end of the horizon $T$, given that the unit is in state $(s, \\ell)$ at the start of period $t$. Our goal is to compute $V(1, s_1, \\ell_1) - \\mu_i$, where $(s_1, \\ell_1)$ is the given initial state and $\\mu_i$ is the dual variable of the convexity constraint.\n\nThe DP proceeds backward in time, from $t=T$ down to $t=1$. The base case is at the end of the horizon, $t=T+1$, where the future cost is zero:\n$$V(T+1, s, \\ell) = 0 \\quad \\forall s \\in \\{0, 1\\}, \\ell \\in \\{0, 1, \\dots, L_{\\max}\\}$$\n\nFor any time $t \\in \\{1, \\dots, T\\}$, the value function $V(t, s, \\ell)$ is determined by the Bellman equation, which considers the minimum cost over all valid decisions (actions) at time $t$. The per-period reduced cost contribution, let's call it $C_t(s_t)$, depends on the chosen status $s_t$ for period $t$.\nIf the unit is offline ($s_t=0$), the cost is $C_t(0) = 0$.\nIf the unit is online ($s_t=1$), the cost is the sum of the fixed cost and the optimized generation cost:\n$$C_t(1) = F_i + \\min_{g_t \\in [P^{\\min}_i, P^{\\max}_i]} (c_i - \\lambda_t) g_t$$\nThe optimal generation $g_t^*$ that minimizes this expression is $P^{\\max}_i$ if the net price $(c_i - \\lambda_t)$ is non-positive, and $P^{\\min}_i$ otherwise.\n$$g_t^* = \\begin{cases} P^{\\max}_i & \\text{if } c_i - \\lambda_t \\le 0 \\\\ P^{\\min}_i & \\text{if } c_i - \\lambda_t > 0 \\end{cases}$$\nSo, $C_t(1) = F_i + (c_i - \\lambda_t) g_t^*$.\n\nThe recurrence relation for $V(t, s, \\ell)$ is as follows:\n\nCase 1: The unit is online at the start of period $t$, i.e., the state is $(1, \\ell)$.\nTwo actions are possible for period $t$:\n1.  **Stay On**: The unit remains online. The cost for this action is $C_t(1)$ plus the minimum future cost from state $(1, \\min(\\ell+1, L_{\\max}))$ at time $t+1$. This action is always permissible.\n2.  **Switch Off**: The unit shuts down. This action is permissible only if the minimum up time constraint is satisfied, i.e., $\\ell \\ge MUT_i$. The cost is the shutdown cost $SD_i$, plus the period cost for being off $C_t(0)=0$, plus the minimum future cost from the new state $(0, 1)$ at time $t+1$.\nThe value function is the minimum of the costs of these valid actions:\n$$V(t, 1, \\ell) = \\min \\begin{cases} C_t(1) + V(t+1, 1, \\min(\\ell+1, L_{\\max})) \\\\ SD_i + C_t(0) + V(t+1, 0, 1) & \\text{if } \\ell \\ge MUT_i \\end{cases}$$\n\nCase 2: The unit is offline at the start of period $t$, i.e., the state is $(0, \\ell)$.\nSimilarly, two actions are possible:\n1.  **Stay Off**: The unit remains offline. The cost is $C_t(0)$ plus the future cost from state $(0, \\min(\\ell+1, L_{\\max}))$ at $t+1$. This is always permissible.\n2.  **Switch On**: The unit starts up. This action is permissible only if the minimum down time constraint is met, i.e., $\\ell \\ge MDT_i$. The cost is the startup cost $SU_i$, plus the period cost for being on $C_t(1)$, plus the future cost from state $(1, 1)$ at $t+1$. The condition $\\ell \\ge MDT_i$ correctly handles the special case where an initial state has $\\ell_1=0$, allowing a switch only if $MDT_i=0$.\nThe value function is:\n$$V(t, 0, \\ell) = \\min \\begin{cases} C_t(0) + V(t+1, 0, \\min(\\ell+1, L_{\\max})) \\\\ SU_i + C_t(1) + V(t+1, 1, 1) & \\text{if } \\ell \\ge MDT_i \\end{cases}$$\n\nBy populating a DP table for $V(t, s, \\ell)$ for $t$ from $T$ down to $1$, for all $s \\in \\{0,1\\}$ and $\\ell \\in \\{0, \\dots, L_{\\max}\\}$, we can find the minimum sum of costs starting from any state. The final answer for each test case is $V(1, s_1, \\ell_1) - \\mu_i$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving of all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'T': 6, 'MUT': 2, 'MDT': 2, 's1': 0, 'l1': 2,\n         'Pmin': 50, 'Pmax': 120, 'c': 30, 'F': 100, 'SU': 500, 'SD': 0,\n         'lambdas': [40, 45, 35, 20, 10, 50], 'mu': 0},\n        # Test case 2\n        {'T': 4, 'MUT': 0, 'MDT': 0, 's1': 0, 'l1': 0,\n         'Pmin': 10, 'Pmax': 10, 'c': 30, 'F': 0, 'SU': 0, 'SD': 0,\n         'lambdas': [25, 25, 25, 25], 'mu': 0},\n        # Test case 3\n        {'T': 5, 'MUT': 3, 'MDT': 1, 's1': 1, 'l1': 1,\n         'Pmin': 20, 'Pmax': 60, 'c': 20, 'F': 50, 'SU': 200, 'SD': 0,\n         'lambdas': [15, 15, 15, 15, 15], 'mu': 0},\n        # Test case 4\n        {'T': 3, 'MUT': 1, 'MDT': 1, 's1': 0, 'l1': 1,\n         'Pmin': 10, 'Pmax': 50, 'c': 20, 'F': 10, 'SU': 100, 'SD': 0,\n         'lambdas': [100, 100, 100], 'mu': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single unit commitment subproblem using dynamic programming.\n    \"\"\"\n    T = params['T']\n    MUT = params['MUT']\n    MDT = params['MDT']\n    s1, l1 = params['s1'], params['l1']\n    Pmin, Pmax = params['Pmin'], params['Pmax']\n    c, F = params['c'], params['F']\n    SU, SD = params['SU'], params['SD']\n    lambdas = params['lambdas']\n    mu = params['mu']\n\n    L_max = max(MUT, MDT, 1)\n\n    # Pre-calculate per-period costs for being online\n    on_costs = []\n    for t in range(T):\n        lambda_t = lambdas[t]\n        # Determine optimal generation level based on net price\n        gen_level = Pmax if c - lambda_t <= 0 else Pmin\n        cost = F + (c - lambda_t) * gen_level\n        on_costs.append(cost)\n\n    # Initialize DP table V(t, s, l) with infinity\n    # Dimensions: (time+2) x (status) x (duration+1)\n    dp = np.full((T + 2, 2, L_max + 1), np.inf)\n\n    # Base case: cost from t=T+1 onwards is 0\n    dp[T + 1, :, :] = 0.0\n\n    # DP backward recursion from t=T down to t=1\n    for t in range(T, 0, -1):\n        t_idx = t - 1\n        current_on_cost = on_costs[t_idx]\n        current_off_cost = 0.0\n        \n        for l in range(L_max + 1):\n            # ===== State at start of period t is (s=1, l), i.e., ONLINE =====\n            \n            # Option 1: Stay ON\n            cost_stay_on = current_on_cost + dp[t + 1, 1, min(l + 1, L_max)]\n            \n            # Option 2: Switch OFF\n            cost_switch_off = np.inf\n            if l >= MUT:\n                cost_switch_off = SD + current_off_cost + dp[t + 1, 0, 1]\n            \n            dp[t, 1, l] = min(cost_stay_on, cost_switch_off)\n\n            # ===== State at start of period t is (s=0, l), i.e., OFFLINE =====\n            \n            # Option 1: Stay OFF\n            cost_stay_off = current_off_cost + dp[t + 1, 0, min(l + 1, L_max)]\n\n            # Option 2: Switch ON\n            cost_switch_on = np.inf\n            if l >= MDT:\n                cost_switch_on = SU + current_on_cost + dp[t + 1, 1, 1]\n\n            dp[t, 0, l] = min(cost_stay_off, cost_switch_on)\n            \n    # The minimum sum of costs is found at the initial state (s1, l1) for period t=1\n    min_sum_costs = dp[1, s1, l1]\n    \n    # Final reduced cost is the minimum sum of costs minus the convexity dual\n    total_reduced_cost = min_sum_costs - mu\n    return total_reduced_cost\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "To increase model realism, we must incorporate more detailed operational constraints into the pricing subproblem. This advanced practice explores how to include ramping limits by augmenting the state space of the dynamic programming model to include the generator's previous output level. You will also investigate the practical trade-off between model accuracy and computational effort by analyzing the impact of discretizing the unit's generation levels, a key consideration in large-scale energy systems modeling .",
            "id": "4078915",
            "problem": "Consider a single thermal generating unit to be priced via Dantzig–Wolfe decomposition within Column Generation (CG), where the pricing subproblem is the reduced-cost minimization over feasible on/off and output trajectories subject to ramping. We assume a linear production cost and an exogenous price trajectory coming from the dual of the master problem’s energy-balance constraints. The goal is to incorporate ramping explicitly by augmenting the state with the previous output $p_{t-1}$, and to analyze the effect of discretizing generation levels on the accuracy of pricing.\n\nStart from the fundamental base of Linear Programming (LP) duality and reduced costs in Dantzig–Wolfe decomposition. Let $\\lambda_t$ be the dual price (in dollars per megawatt-hour) at time $t$, and let the generator have the following parameters: minimum output $P_{\\min}$ (in megawatts), maximum output $P_{\\max}$ (in megawatts), ramp-up limit $R^{\\uparrow}$ (in megawatts per hour), ramp-down limit $R^{\\downarrow}$ (in megawatts per hour), startup cost $C^{\\text{su}}$ (in dollars), no-load cost $C^{\\text{nl}}$ (in dollars per hour), and variable production cost coefficient $c$ (in dollars per megawatt-hour). Let the time index $t$ run from $t=1$ to $t=T$ in hours, with initial state $p_{0}=0$ and the unit initially off. The reduced cost of a column (one feasible trajectory) under prices $\\lambda_t$ is defined as the total cost minus the revenue at the dual prices:\n$$\n\\text{RC} \\;=\\; \\sum_{t=1}^{T} \\big( C^{\\text{nl}} \\, u_t + (c - \\lambda_t) \\, p_t \\big) \\;+\\; \\sum_{t=1}^{T} C^{\\text{su}} \\, \\mathbf{1}\\{u_{t-1}=0,\\,u_t=1\\},\n$$\nsubject to the unit operating constraints\n$$\nu_t \\in \\{0,1\\}, \\quad p_t \\in [\\,P_{\\min} u_t,\\; P_{\\max} u_t\\,], \\quad p_t - p_{t-1} \\le R^{\\uparrow}, \\quad p_{t-1} - p_t \\le R^{\\downarrow}, \\quad p_0 = 0, \\quad u_0 = 0,\n$$\nwhere $u_t$ is the on/off decision at time $t$, and $p_t$ is the output at time $t$.\n\nTo incorporate ramping in a Dynamic Programming (DP) recursion, augment the state to include the previous output $p_{t-1}$ and on/off status $u_{t-1}$. To make the pricing problem computationally tractable in practice, many implementations discretize the feasible generation levels. Consider discretizing $p_t$ to a grid $\\mathcal{G}_\\Delta = \\{0\\} \\cup \\{P_{\\min}, P_{\\min}+\\Delta, \\dots, P_{\\max}\\}$ for a step size $\\Delta$ (in megawatts). This discretization induces an approximation to the true reduced cost. Finer $\\Delta$ generally yields a closer approximation, while coarser $\\Delta$ yields fewer states and transitions but increases approximation error.\n\nYour task is to implement a Dynamic Programming solver that computes the minimal reduced cost under ramping with the augmented state and discretized generation levels. For each test case, compute the minimal reduced cost with a coarse discretization $\\Delta_{\\text{coarse}}$ and with a fine discretization $\\Delta_{\\text{fine}}$, then report the pricing optimality gap defined as:\n$$\n\\text{Gap} \\;=\\; \\text{RC}_{\\Delta_{\\text{coarse}}}^{\\star} \\;-\\; \\text{RC}_{\\Delta_{\\text{fine}}}^{\\star},\n$$\nin dollars. A positive gap indicates suboptimal pricing under the coarse discretization.\n\nPhysical units must be respected as follows: power levels $p_t$, $P_{\\min}$, $P_{\\max}$, $R^{\\uparrow}$, and $R^{\\downarrow}$ in megawatts; time in hours; price $\\lambda_t$ and variable cost $c$ in dollars per megawatt-hour; no-load cost $C^{\\text{nl}}$ in dollars per hour; startup cost $C^{\\text{su}}$ in dollars. Express the final reported gap values in dollars, rounded to two decimal places.\n\nImplement the program to solve the DP for the following test suite (each test case specifies $T$, $\\{\\lambda_t\\}_{t=1}^{T}$, $P_{\\min}$, $P_{\\max}$, $R^{\\uparrow}$, $R^{\\downarrow}$, $c$, $C^{\\text{nl}}$, $C^{\\text{su}}$, $\\Delta_{\\text{coarse}}$, $\\Delta_{\\text{fine}}$):\n\n- Test case $1$ (general case with moderate ramping and varied prices):\n  - $T = 6$,\n  - $\\lambda = [\\,30,\\,28,\\,35,\\,50,\\,45,\\,25\\,]$,\n  - $P_{\\min}=100$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=150$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=900$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- Test case $2$ (tighter ramps, lower $P_{\\min}$ to allow startup under constraints):\n  - $T = 6$,\n  - $\\lambda = [\\,30,\\,28,\\,35,\\,50,\\,45,\\,25\\,]$,\n  - $P_{\\min}=60$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=70$, $R^{\\downarrow}=90$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=900$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- Test case $3$ (single-hour boundary case with low price):\n  - $T = 1$,\n  - $\\lambda = [\\,20\\,]$,\n  - $P_{\\min}=80$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=150$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=900$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- Test case $4$ (high startup cost discourages commitment):\n  - $T = 6$,\n  - $\\lambda = [\\,30,\\,28,\\,35,\\,50,\\,45,\\,25\\,]$,\n  - $P_{\\min}=100$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=150$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=4000$,\n  - $\\Delta_{\\text{coarse}}=50$, $\\Delta_{\\text{fine}}=10$.\n- Test case $5$ (uniformly high prices; examine ramp-limited ascent):\n  - $T = 6$,\n  - $\\lambda = [\\,60,\\,60,\\,60,\\,60,\\,60,\\,60\\,]$,\n  - $P_{\\min}=100$, $P_{\\max}=300$,\n  - $R^{\\uparrow}=120$, $R^{\\downarrow}=120$,\n  - $c=28$, $C^{\\text{nl}}=200$, $C^{\\text{su}}=800$,\n  - $\\Delta_{\\text{coarse}}=100$, $\\Delta_{\\text{fine}}=10$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, where each item is the pricing optimality gap in dollars, rounded to two decimal places (for example, $[\\,12.34,\\,0.00,\\,\\dots\\,]$).",
            "solution": "The problem is assessed to be **valid**. It is a well-posed, scientifically grounded problem in the domain of energy systems optimization, specifically addressing the pricing subproblem in a column generation framework for unit commitment. All parameters, constraints, and objectives are clearly and consistently defined.\n\nThe core of the task is to solve a shortest-path problem on a directed acyclic graph using Dynamic Programming (DP). The objective is to find the minimum reduced cost ($\\text{RC}$) for a single thermal generator's operating schedule over a time horizon of $T$ hours.\n\n### Dynamic Programming Formulation\n\nThe principle of optimality applies, allowing us to find the optimal schedule by breaking it down into a sequence of simpler decisions.\n\n**1. Stages:** The stages of the DP correspond to the time periods $t \\in \\{1, 2, \\dots, T\\}$. We solve the problem sequentially, one time period at a time.\n\n**2. States:** To make a decision at time $t$, we need to know the generator's status at the end of the previous period, $t-1$. The ramping constraints $p_t - p_{t-1} \\le R^{\\uparrow}$ and $p_{t-1} - p_t \\le R^{\\downarrow}$ make the previous power output $p_{t-1}$ essential. The startup cost $C^{\\text{su}}$ depends on whether the unit was previously off, making the previous commitment status $u_{t-1}$ essential. Therefore, the state at the beginning of period $t$ is fully described by the tuple $(u_{t-1}, p_{t-1})$. The state space is discretized. The power output $p_t$ is restricted to a grid $\\mathcal{G}_{\\Delta} = \\{0\\} \\cup \\{P_{\\min}, P_{\\min}+\\Delta, \\dots, P_{\\max}\\}$.\n\n**3. Value Function:** Let $V_t(u_t, p_t)$ be the minimum cumulative reduced cost to reach the state $(u_t, p_t)$ at the end of period $t$. Our goal is to find $\\min_{(u_T, p_T)} V_T(u_T, p_T)$.\n\n**4. Recursion Relation:** We use a forward recursion. The value function at time $t$ is computed based on the values at time $t-1$. For any reachable state $(u_t, p_t)$ at time $t$, its minimum cost is the minimum over all feasible predecessor states $(u_{t-1}, p_{t-1})$ of the sum of the predecessor's cost and the cost of transitioning.\n\nThe cost of a transition from $(u_{t-1}, p_{t-1})$ to $(u_t, p_t)$ during period $t$ is the stage cost, derived from the problem's reduced cost formula:\n$$\nC^{\\text{stage}}_t(u_{t-1}, p_{t-1}, u_t, p_t) = C^{\\text{nl}} u_t + (c - \\lambda_t) p_t + C^{\\text{su}} \\mathbf{1}\\{u_{t-1}=0, u_t=1\\}\n$$\n\nThe DP recursion is:\n$$\nV_t(u_t, p_t) = \\min_{(u_{t-1}, p_{t-1})} \\left\\{ V_{t-1}(u_{t-1}, p_{t-1}) + C^{\\text{stage}}_t \\right\\}\n$$\nThe minimization is taken over all states $(u_{t-1}, p_{t-1})$ from which the transition to $(u_t, p_t)$ is feasible. A transition is feasible if it satisfies all operating constraints:\n- $u_t \\in \\{0, 1\\}$, $p_t \\in \\mathcal{G}_{\\Delta}$.\n- If $u_t=1$, then $p_t \\in [P_{\\min}, P_{\\max}]$. If $u_t=0$, then $p_t=0$.\n- $p_t - p_{t-1} \\le R^{\\uparrow}$.\n- $p_{t-1} - p_t \\le R^{\\downarrow}$. This also constrains shutdowns: a unit at power $p_{t-1}$ can only shut down (to $p_t=0$) if $p_{t-1} \\le R^{\\downarrow}$.\n\n**5. Base Case:** The problem defines the initial state at $t=0$ as being off with zero output.\n$$\nV_0(u_0=0, p_0=0) = 0\n$$\nAll other potential states at $t=0$ are unreachable, so their cost is infinite: $V_0(u, p) = \\infty$ for $(u,p) \\neq (0,0)$.\n\n### Algorithmic Implementation\n\nThe DP is implemented by iterating from $t=1$ to $T$. For each time step $t$, we compute the cost for every possible state $(u_t, p_t)$ by considering all possible transitions from feasible states at $t-1$.\n\n1.  **Discretization:** For a given discretization step $\\Delta$, generate the set of allowed power levels $\\mathcal{G}_{\\Delta}$. This is $\\{0\\}$ combined with levels from $P_{\\min}$ to $P_{\\max}$ in increments of $\\Delta$.\n2.  **Initialization:** A table (e.g., a dictionary in Python) stores the costs $V_t(u, p)$. Initialize `dp_table[0]` with the base case: `{(0, 0): 0}`.\n3.  **Iteration:**\n    For $t=1, \\dots, T$:\n    - For each source state $(u_{t-1}, p_{t-1})$ with finite cost in `dp_table[t-1]`:\n        - Evaluate possible transitions to destination states $(u_t, p_t)$ at time $t$.\n        - **Transition to OFF state:** Consider $(u_t, p_t) = (0,0)$. Check if $p_{t-1} \\le R^{\\downarrow}$. If so, calculate the new path cost and update $V_t(0,0)$.\n        - **Transition to ON states:** For each $p_t \\in \\mathcal{G}_{\\Delta} \\setminus \\{0\\}$, consider $(u_t, p_t) = (1, p_t)$. Check if ramp constraints are met. If so, calculate the startup and operating costs for the stage, add to the previous path cost, and update $V_t(1, p_t)$.\n4.  **Final Result:** After iterating through all $T$ periods, the minimum reduced cost is the minimum value found in `dp_table[T]` across all possible final states.\n\nThis entire procedure is performed once with $\\Delta = \\Delta_{\\text{coarse}}$ to find $\\text{RC}_{\\Delta_{\\text{coarse}}}^{\\star}$ and once with $\\Delta = \\Delta_{\\text{fine}}$ to find $\\text{RC}_{\\Delta_{\\text{fine}}}^{\\star}$. The final optimality gap is their difference, $\\text{Gap} = \\text{RC}_{\\Delta_{\\text{coarse}}}^{\\star} - \\text{RC}_{\\Delta_{\\text{fine}}}^{\\star}$. A positive gap signifies that the coarser grid led to a suboptimal pricing decision, failing to find the true minimum reduced cost that was accessible with the finer grid.",
            "answer": "```python\nimport numpy as np\n\ndef compute_min_rc(\n    T: int,\n    lambdas: list[float],\n    P_min: float,\n    P_max: float,\n    R_up: float,\n    R_down: float,\n    c: float,\n    C_nl: float,\n    C_su: float,\n    Delta: float,\n):\n    \"\"\"\n    Computes the minimum reduced cost using Dynamic Programming.\n\n    The state is defined by (u, p): commitment status u and power output p.\n    dp_table[t] stores a dictionary mapping state (u, p) to its minimum\n    cumulative reduced cost up to time t.\n    \"\"\"\n    \n    # Generate the discretized grid of power levels for the ON state.\n    # We add a small epsilon to P_max to ensure it's included if it's on the grid.\n    if Delta <= 0 or P_min > P_max:\n        on_grid = np.array([], dtype=float)\n    else:\n        on_grid = np.arange(P_min, P_max + 1e-9, Delta)\n\n    # dp_table[t] is a dictionary: {(u, p): cost}\n    dp_table = {}\n    \n    # Base case at t=0: unit is off, power is 0, cost is 0.\n    dp_table[0] = {(0, 0.0): 0.0}\n\n    # Iterate through each time period\n    for t in range(1, T + 1):\n        dp_table[t] = {}\n        lambda_t = lambdas[t - 1]\n\n        # Iterate through all reachable states at the previous time step\n        for (u_prev, p_prev), cost_prev in dp_table[t - 1].items():\n            \n            # --- Possibility 1: Unit is OFF at time t ---\n            u_curr, p_curr = 0, 0.0\n            \n            # A unit can transition to OFF only if its previous power level\n            # does not exceed the ramp-down limit for a single step to zero.\n            if p_prev - p_curr <= R_down:\n                # Stage cost is 0 when the unit is off.\n                stage_cost = 0.0\n                new_cost = cost_prev + stage_cost\n\n                # Update the DP table with the minimum cost found so far for this state\n                current_min = dp_table[t].get((u_curr, p_curr), float('inf'))\n                dp_table[t][(u_curr, p_curr)] = min(current_min, new_cost)\n\n            # --- Possibility 2: Unit is ON at time t ---\n            u_curr = 1\n            for p_curr in on_grid:\n                # Check ramp-up and ramp-down constraints for the transition\n                if p_curr - p_prev > R_up or p_prev - p_curr > R_down:\n                    continue  # This transition is infeasible\n\n                # Calculate the cost for this stage\n                startup_cost = C_su if u_prev == 0 else 0.0\n                operating_cost = C_nl + (c - lambda_t) * p_curr\n                stage_cost = startup_cost + operating_cost\n                \n                new_cost = cost_prev + stage_cost\n                \n                # Update the DP table with the minimum cost\n                current_min = dp_table[t].get((u_curr, p_curr), float('inf'))\n                dp_table[t][(u_curr, p_curr)] = min(current_min, new_cost)\n    \n    # The minimum reduced cost is the minimum cost over all possible final states at time T.\n    final_costs = dp_table[T].values()\n    \n    if not final_costs:\n        return float('inf')  # Should not be reached if staying off is always an option\n        \n    return min(final_costs)\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"T\": 6, \"lambda\": [30, 28, 35, 50, 45, 25], \"P_min\": 100, \"P_max\": 300,\n            \"R_up\": 120, \"R_down\": 150, \"c\": 28, \"C_nl\": 200, \"C_su\": 900,\n            \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 6, \"lambda\": [30, 28, 35, 50, 45, 25], \"P_min\": 60, \"P_max\": 300,\n            \"R_up\": 70, \"R_down\": 90, \"c\": 28, \"C_nl\": 200, \"C_su\": 900,\n            \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 1, \"lambda\": [20], \"P_min\": 80, \"P_max\": 300, \"R_up\": 120, \"R_down\": 150,\n            \"c\": 28, \"C_nl\": 200, \"C_su\": 900, \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 6, \"lambda\": [30, 28, 35, 50, 45, 25], \"P_min\": 100, \"P_max\": 300,\n            \"R_up\": 120, \"R_down\": 150, \"c\": 28, \"C_nl\": 200, \"C_su\": 4000,\n            \"delta_coarse\": 50, \"delta_fine\": 10\n        },\n        {\n            \"T\": 6, \"lambda\": [60, 60, 60, 60, 60, 60], \"P_min\": 100, \"P_max\": 300,\n            \"R_up\": 120, \"R_down\": 120, \"c\": 28, \"C_nl\": 200, \"C_su\": 800,\n            \"delta_coarse\": 100, \"delta_fine\": 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params_coarse = (\n            case[\"T\"], case[\"lambda\"], case[\"P_min\"], case[\"P_max\"],\n            case[\"R_up\"], case[\"R_down\"], case[\"c\"], case[\"C_nl\"], case[\"C_su\"],\n            case[\"delta_coarse\"]\n        )\n        rc_coarse = compute_min_rc(*params_coarse)\n\n        params_fine = (\n            case[\"T\"], case[\"lambda\"], case[\"P_min\"], case[\"P_max\"],\n            case[\"R_up\"], case[\"R_down\"], case[\"c\"], case[\"C_nl\"], case[\"C_su\"],\n            case[\"delta_fine\"]\n        )\n        rc_fine = compute_min_rc(*params_fine)\n\n        gap = rc_coarse - rc_fine\n        results.append(f\"{gap:.2f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}