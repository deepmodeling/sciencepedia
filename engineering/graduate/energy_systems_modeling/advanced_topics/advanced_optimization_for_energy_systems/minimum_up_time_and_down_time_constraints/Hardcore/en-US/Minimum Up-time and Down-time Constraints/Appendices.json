{
    "hands_on_practices": [
        {
            "introduction": "Mastering unit commitment modeling begins with a solid grasp of how to translate operational rules into mathematical constraints. This first exercise challenges you to move beyond standard formulas and derive the constraints for minimum up-time and down-time from their fundamental definitions. By working through a small, discrete-time example with a given initial state , you will build a foundational understanding of how a unit's history impacts its future feasible operations.",
            "id": "4103870",
            "problem": "Consider a single thermal generating unit modeled over discrete scheduling periods $t \\in \\{1,2,3\\}$. Let $x_t \\in \\{0,1\\}$ denote the on/off commitment status at time $t$, with $x_t=1$ indicating the unit is committed (on) and $x_t=0$ indicating the unit is not committed (off). Let $u_t \\in \\{0,1\\}$ denote a startup decision at time $t$ and $v_t \\in \\{0,1\\}$ denote a shutdown decision at time $t$. The unit is subject to a minimum up-time of $L^{\\mathrm{up}}$ consecutive periods and a minimum down-time of $L^{\\mathrm{down}}$ consecutive periods. The standard Mixed-Integer Linear Programming (MILP) formulation of unit commitment uses the logical relation $x_t - x_{t-1} = u_t - v_t$, together with consistency constraints that prevent simultaneous startup and shutdown.\n\nStarting from the fundamental operational definitions:\n- A minimum up-time of $L^{\\mathrm{up}}$ means that once the unit starts ($u_s=1$), it must remain on for at least $L^{\\mathrm{up}}$ consecutive periods following $s$.\n- A minimum down-time of $L^{\\mathrm{down}}$ means that once the unit shuts down ($v_s=1$), it must remain off for at least $L^{\\mathrm{down}}$ consecutive periods following $s$.\n\nAt the start of the horizon, the initial commitment status is $x_0=1$, and the unit has been on for $T^{\\mathrm{on}}_0=1$ consecutive periods immediately prior to $t=1$. There is no residual minimum down-time requirement carried into the horizon because the unit is initially on. The parameters are $L^{\\mathrm{up}}=3$ and $L^{\\mathrm{down}}=2$.\n\nTasks:\n1. Using only the operational definitions above and standard binary-variable logic, explicitly write all valid constraints that must hold at each $t \\in \\{1,2,3\\}$, including:\n   - On/off evolution and consistency constraints linking $x_t$, $u_t$, and $v_t$.\n   - Enforceable minimum up-time constraints over the horizon, accounting for the initial condition $x_0=1$ and $T^{\\mathrm{on}}_0=1$.\n   - Enforceable minimum down-time constraints over the horizon, given $L^{\\mathrm{down}}=2$ and $x_0=1$.\n2. Determine the maximum feasible value of $u_1$ that is permitted by these constraints.\n\nExpress your final answer as a single number. No rounding is necessary, and no units are required.",
            "solution": "The problem requires the formulation of constraints for a single-unit commitment problem over a discrete time horizon and the subsequent determination of the maximum feasible value for a specific decision variable. The solution is presented in two parts, corresponding to the two tasks specified.\n\n### Task 1: Formulation of Constraints\n\nThe system is defined for discrete time periods $t \\in \\{1, 2, 3\\}$. The variables are the binary commitment status $x_t \\in \\{0,1\\}$, startup decision $u_t \\in \\{0,1\\}$, and shutdown decision $v_t \\in \\{0,1\\}$. The parameters are minimum up-time $L^{\\mathrm{up}}=3$ and minimum down-time $L^{\\mathrm{down}}=2$. The initial conditions at the beginning of period $t=1$ are $x_0=1$ and an initial on-time of $T^{\\mathrm{on}}_0=1$ period.\n\nBased on the problem statement, we derive the constraints for each $t \\in \\{1, 2, 3\\}$.\n\n**1. On/Off Evolution and Consistency Constraints**\n\nThese constraints link the state variable $x_t$ to the decision variables $u_t$ and $v_t$. The relation $x_t - x_{t-1} = u_t - v_t$ captures the change of state. A consistency constraint ensures that a startup and a shutdown cannot occur in the same period.\n\nFor $t=1$:\n$x_1 - x_0 = u_1 - v_1$. Given $x_0=1$, this becomes $x_1 - 1 = u_1 - v_1$.\n$u_1 + v_1 \\le 1$.\n\nFor $t=2$:\n$x_2 - x_1 = u_2 - v_2$.\n$u_2 + v_2 \\le 1$.\n\nFor $t=3$:\n$x_3 - x_2 = u_3 - v_3$.\n$u_3 + v_3 \\le 1$.\n\n**2. Minimum Up-Time Constraints**\n\nThe minimum up-time is $L^{\\mathrm{up}}=3$ periods.\n\n*   **Constraint from Initial Condition**: The unit is initially on ($x_0=1$) and has been on for $T^{\\mathrm{on}}_0=1$ period. To satisfy the minimum up-time of $L^{\\mathrm{up}}=3$, it must continue to operate for at least $L^{\\mathrm{up}} - T^{\\mathrm{on}}_0 = 3 - 1 = 2$ more periods. This means the unit must be on for periods $t=1$ and $t=2$. A shutdown is therefore forbidden at the start of period $t=1$ (which would make the on-time only $1$ period) and at the start of period $t=2$ (which would make the on-time only $2$ periods). This leads to the following constraints on the shutdown variables:\n    $v_1 = 0$\n    $v_2 = 0$\n\n*   **Constraints from New Startups**: If the unit starts up at time $s$ ($u_s=1$), it must remain on for at least $L^{\\mathrm{up}}=3$ periods ($s, s+1, s+2$). This means it cannot shut down at $t=s+1$ or $t=s+2$.\n    *   For a startup at $t=1$ ($u_1=1$): A shutdown is forbidden at $t=2$ and $t=3$. The constraint can be written as $v_t \\le 1-u_1$ for $t \\in \\{2, 3\\}$. The constraint for $t=2$ is $v_2 \\le 1-u_1$, which is redundant because we already have the stronger constraint $v_2=0$. The constraint for $t=3$ is:\n        $v_3 + u_1 \\le 1$.\n    *   For a startup at $t=2$ ($u_2=1$): A shutdown is forbidden at $t=3$. This yields the constraint $v_3 \\le 1-u_2$:\n        $v_3 + u_2 \\le 1$.\n    *   A startup at $t=3$ would impose requirements beyond the scheduling horizon, so no further constraints of this type can be enforced within the $t \\in \\{1,2,3\\}$ horizon.\n\n**3. Minimum Down-Time Constraints**\n\nThe minimum down-time is $L^{\\mathrm{down}}=2$ periods. The initial state is on, so there are no down-time constraints carried over from before $t=1$.\n\n*   **Constraints from New Shutdowns**: If the unit shuts down at time $s$ ($v_s=1$), it must remain off for at least $L^{\\mathrm{down}}=2$ periods ($s, s+1$). This means it cannot start up at $t=s+1$.\n    *   For a shutdown at $t=1$ ($v_1=1$): A startup is forbidden at $t=2$. This yields the constraint $u_2 \\le 1-v_1$:\n        $u_2 + v_1 \\le 1$.\n    *   For a shutdown at $t=2$ ($v_2=1$): A startup is forbidden at $t=3$. This yields the constraint $u_3 \\le 1-v_2$:\n        $u_3 + v_2 \\le 1$.\n    *   A shutdown at $t=3$ imposes requirements beyond the scheduling horizon.\n\nIn summary, the complete set of constraints for $t \\in \\{1,2,3\\}$ consists of the evolution, consistency, up-time, and down-time constraints listed above.\n\n### Task 2: Maximum Feasible Value of $u_1$\n\nTo determine the maximum feasible value of the binary variable $u_1$, we analyze the constraints that involve it. The most direct constraint is the state evolution equation for $t=1$:\n$$x_1 - x_0 = u_1 - v_1$$\nThe problem specifies the initial condition $x_0=1$. Substituting this value gives:\n$$x_1 - 1 = u_1 - v_1$$\nA startup decision at time $t=1$ corresponds to setting $u_1=1$. From the consistency constraint $u_1 + v_1 \\le 1$, if $u_1=1$, it is necessary that $v_1=0$.\nSubstituting $u_1=1$ and $v_1=0$ into the evolution equation yields:\n$$x_1 - 1 = 1 - 0$$\n$$x_1 = 2$$\nThe variable $x_1$ represents the commitment status and is defined as a binary variable, $x_1 \\in \\{0,1\\}$. The result $x_1=2$ violates this definition. Therefore, a solution with $u_1=1$ is infeasible.\n\nThis conclusion is fundamental to the logic of unit commitment: a \"startup\" decision is only possible for a unit that is currently off. Given that the unit is on at $t=0$ ($x_0=1$), it cannot be started up at $t=1$.\n\nSince $u_1$ is a binary variable, its only possible values are $0$ and $1$. We have shown that $u_1=1$ is infeasible. The only remaining possibility is $u_1=0$. To confirm this is a valid assignment, we must verify that it is part of at least one feasible solution.\n\nLet's set $u_1=0$.\nFrom the minimum up-time constraint derived from the initial condition, we have $v_1=0$.\nThe evolution equation for $t=1$ becomes $x_1 - 1 = 0 - 0$, which gives $x_1=1$. This is a valid state.\nAs shown in the constraint derivation, the initial conditions also force $v_2=0$. The evolution equation for $t=2$, $x_2-x_1=u_2-v_2$, becomes $x_2-1=u_2-0$. A startup at $t=2$ ($u_2=1$) would require $x_1=0$, which is not the case. Thus, we must have $u_2=0$, which gives $x_2=1$.\nAt $t=3$, the unit has been on for $3$ periods, so a shutdown is allowed ($v_3=1$). This gives a feasible trajectory.\nSince $u_1=0$ is part of a feasible solution and $u_1=1$ is not, the set of all feasible values for $u_1$ is $\\{0\\}$.\n\nThe maximum value in this set is $0$.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "Real-world scheduling is often performed using a rolling-horizon approach, where plans are periodically updated as new information becomes available. A key challenge is ensuring that commitments made in one horizon are honored in the next. This practice problem  explores this exact scenario, asking you to identify and correct a potential violation of a minimum up-time constraint at the boundary between two optimization horizons, a crucial skill for ensuring temporal consistency in dynamic scheduling.",
            "id": "4103893",
            "problem": "Consider a rolling-horizon Mixed Integer Linear Programming (MILP) formulation of thermal Unit Commitment for a single generating unit $g$ with binary commitment state $x_t \\in \\{0,1\\}$ and binary start-up $u_t \\in \\{0,1\\}$, over hourly periods indexed by $t \\in \\mathbb{Z}_{+}$. The unit has a specified minimum up-time of $L$ hours, meaning that after any start-up, the unit must remain committed continuously for at least $L$ consecutive periods. The fundamental definition of minimum up-time is: once a start-up occurs at time $t_s$ (i.e., $u_{t_s} = 1$), the commitment must satisfy $x_t = 1$ for all $t \\in \\{t_s, t_s+1, \\dots, t_s + L - 1\\}$.\n\nA rolling-horizon scheduler solves on two consecutive horizons. The first horizon is $T_0 = \\{1,2,3,4\\}$, and the second horizon is $T_1 = \\{3,4,5,6\\}$. The generator’s minimum up-time is $L = 3$. There is an exogenous load $d_t$ and an alternative supply option that becomes available only in the second horizon. Specifically:\n- In $T_0$, only unit $g$ is available, and the load satisfies $d_2 = 1$, $d_3 = 1$, $d_4 = 1$, with $d_1 = 0$. The unit $g$ can meet the load and is committed by the first-horizon optimizer, producing a start-up at $t = 2$ so that $u_2 = 1$ and $x_2 = 1$.\n- In $T_1$, an alternative unit with strictly lower variable cost than unit $g$ becomes available and can meet all load for $t \\in \\{3,4,5,6\\}$, making it economically attractive, if unconstrained, to shut down unit $g$ immediately at the start of $T_1$.\n\nThis rolling re-optimization at $T_1$ would violate the previously committed minimum up-time of unit $g$, because the unit was started at $t = 2$ and thus must remain on at $t = 3$ and $t = 4$ to complete its $L = 3$ consecutive on-hours. To prevent such release, one must carry minimum up-time “memory” across the horizon boundary and enforce a correction constraint in $T_1$ that ensures the unit remains committed for the residual mandatory on-time that remains due to the start-up in $T_0$.\n\nStarting from the fundamental definition of minimum up-time and the notion of horizon boundaries at $t_0 = 3$ for $T_1$, construct a mathematically consistent correction that prevents premature release in $T_1$ by enforcing the residual mandatory on-time implied by the previous horizon’s start-up. Then, compute the scalar residual enforcement length $R$, defined as the number of periods at the beginning of $T_1$ over which commitment must be forced to satisfy the previously initiated minimum up-time. Report $R$ as your final answer. There is no rounding required, and no physical units are associated with $R$.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of energy systems optimization, specifically Unit Commitment (UC). The problem is well-posed, objective, and provides a complete and consistent set of data and definitions to arrive at a unique, meaningful solution. It addresses the common issue of maintaining temporal consistency for constraints such as minimum up-time across the boundaries of a rolling-horizon optimization scheme.\n\nThe core of the problem lies in translating the state of a generating unit from a completed optimization horizon to the initial conditions of the subsequent horizon. The fundamental definition of the minimum up-time constraint is the starting point for this analysis.\n\nA generator $g$ is subject to a minimum up-time of $L$ hours. As stated, if a start-up event occurs at time $t_s$, denoted by the binary variable $u_{t_s} = 1$, then the unit's commitment status, denoted by the binary variable $x_t$, must be $x_t = 1$ for all time periods $t$ in the interval $\\{t_s, t_s+1, \\dots, t_s + L - 1\\}$.\n\nFrom the problem statement, we are given the following specific information:\n1.  The minimum up-time for unit $g$ is $L = 3$ hours.\n2.  In the first optimization horizon, $T_0 = \\{1, 2, 3, 4\\}$, a start-up decision is made for unit $g$ at time $t = 2$. Therefore, the start-up time is $t_s = 2$, and the decision variables from the first optimization include $u_2 = 1$ and $x_2 = 1$.\n\nApplying the minimum up-time definition with $L=3$ and $t_s=2$, the unit is mandated to remain in the 'on' state ($x_t=1$) for the time periods $t$ belonging to the set $\\{2, 2+1, \\dots, 2+3-1\\}$. This evaluates to the set of time indices $\\{2, 3, 4\\}$. Thus, the decision $u_2=1$ from the $T_0$ optimization implies a binding commitment for $x_2=1$, $x_3=1$, and $x_4=1$.\n\nThe problem proceeds to a rolling-horizon update. The second optimization is performed over the horizon $T_1 = \\{3, 4, 5, 6\\}$. This new optimization begins at time $t=3$. At this point, the decisions for $t \\ge 3$ are re-evaluated. However, the decisions made in the previous horizon for $t < 3$ are now fixed history and have established commitments that may extend into the new horizon.\n\nThe commitment initiated at $t_s=2$ spans the time periods $\\{2, 3, 4\\}$. The new optimization horizon $T_1$ covers the time periods $\\{3, 4, 5, 6\\}$. To ensure the minimum up-time constraint is not violated, any part of the mandatory commitment interval that falls within the new optimization horizon must be enforced as a fixed constraint.\n\nThe set of periods where commitment from the past is still mandatory is $M = \\{2, 3, 4\\}$.\nThe set of periods in the new optimization horizon is $T_1 = \\{3, 4, 5, 6\\}$.\nThe intersection of these two sets gives the periods in the new horizon for which the unit must be forced to remain on:\n$$ M \\cap T_1 = \\{2, 3, 4\\} \\cap \\{3, 4, 5, 6\\} = \\{3, 4\\} $$\nTherefore, in the MILP formulation for the horizon $T_1$, the following correction constraints must be added to enforce the residual mandatory on-time:\n$$ x_3 = 1 $$\n$$ x_4 = 1 $$\n\nThe problem asks for the scalar residual enforcement length, $R$, defined as the number of periods at the beginning of $T_1$ over which commitment must be forced. Based on our derivation, the commitment must be forced for periods $t=3$ and $t=4$. These are the first two periods of the horizon $T_1$. The number of these periods is $2$.\nTherefore, $R = 2$.\n\nMore generally, we can formalize the calculation of $R$. Let $t_{start}$ be the start-up time of the unit. Let $t_{new}$ be the first time period of the new optimization horizon. The unit has been online for $t_{new} - t_{start}$ periods before the new horizon begins. The remaining number of periods it must stay online is the minimum up-time duration $L$ minus the time it has already been on. This is valid only if this quantity is positive.\n\nThe residual up-time, $R$, can be calculated as:\n$$ R = \\max(0, L - (t_{new} - t_{start})) $$\nIn this specific problem, we have $L=3$, $t_{start} = t_s = 2$, and the new horizon $T_1$ starts at $t_{new}=3$. Substituting these values into the formula:\n$$ R = \\max(0, 3 - (3 - 2)) $$\n$$ R = \\max(0, 3 - 1) $$\n$$ R = \\max(0, 2) $$\n$$ R = 2 $$\nThis confirms that the commitment of unit $g$ must be forcibly fixed to $x_t=1$ for the first $2$ periods of the new horizon $T_1$, namely for $t=3$ and $t=4$, to honor the minimum up-time constraint initiated in the prior horizon.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While multiple mathematical formulations can correctly represent the same logical constraint for integer variables, they are not created equal when it comes to solving the model efficiently. This computational exercise  delves into the critical distinction between 'classic' (weak) and 'strong' formulations for minimum up-time and down-time constraints. By implementing both and comparing the integrality gaps of their linear programming relaxations, you will gain a tangible understanding of why formulation strength is a cornerstone of effective mixed-integer programming.",
            "id": "4103848",
            "problem": "Consider a single thermal unit commitment model in discrete time with decision horizon of length $T$. The unit has a minimum up-time of $L^{\\mathrm{up}}$ periods and a minimum down-time of $L^{\\mathrm{down}}$ periods. Let $t \\in \\{1,\\dots,T\\}$ index time periods. The state variables are: on/off status $x_t \\in \\{0,1\\}$, startup indicator $u_t \\in \\{0,1\\}$, shutdown indicator $v_t \\in \\{0,1\\}$, and generation $p_t \\ge 0$. The generation must satisfy a known inelastic demand $D_t$ with a single unit of capacity $P^{\\max}$, and there is no minimum power output. The unit is initially off, that is $x_0 = 0$, and the initial history satisfies any minimum down-time requirement so that no initial carry-over constraints are needed.\n\nThe objective is to minimize the sum of a per-period on-cost and a startup cost. Specifically, minimize $\\sum_{t=1}^T c^{\\text{on}} x_t + c^{\\text{su}} u_t$, subject to feasibility constraints and either a classic or a strong formulation of the minimum up-time and minimum down-time constraints. All costs are expressed in consistent monetary units per period, and all power quantities are in megawatts (MW). Since the requested quantity is dimensionless, express the final outputs as pure decimals (no units, no percentage symbols).\n\nUse the following fundamental modeling base:\n- State transitions enforce $x_t - x_{t-1} = u_t - v_t$ for all $t$, with $x_0 = 0$.\n- Power balance and capacity enforce $p_t \\ge D_t$ and $p_t \\le P^{\\max} x_t$ for all $t$.\n- Variable domains are $x_t \\in \\{0,1\\}$, $u_t \\in \\{0,1\\}$, $v_t \\in \\{0,1\\}$, $p_t \\ge 0$.\n\nDefine two alternative linear formulations of the minimum up-time and minimum down-time logic:\n\n- Classic formulation (windowed implications):\n  - For all $t$ and for all $\\tau \\in \\{t,\\dots,\\min(t+L^{\\mathrm{up}}-1,T)\\}$, enforce $x_{\\tau} \\ge u_t$.\n  - For all $t$ and for all $\\tau \\in \\{t,\\dots,\\min(t+L^{\\mathrm{down}}-1,T)\\}$, enforce $1 - x_{\\tau} \\ge v_t$.\n  - Additionally, enforce $u_t + v_t \\le 1$ for all $t$.\n\n- Strong formulation (cumulative window inequalities):\n  - For all $t$, enforce $\\sum_{k=\\max(1,t-L^{\\mathrm{up}}+1)}^{t} u_k \\le x_t$.\n  - For all $t$, enforce $\\sum_{k=\\max(1,t-L^{\\mathrm{down}}+1)}^{t} v_k \\le 1 - x_t$.\n  - Additionally, enforce $u_t + v_t \\le 1$ for all $t$.\n\nYour program must:\n1. Solve the mixed-integer linear program (MILP) with binary variables for the strong formulation to obtain the integer optimal objective value $Z^{\\star}$.\n2. Solve the linear programming (LP) relaxations (all variables continuous in $[0,1]$ for $x_t,u_t,v_t$ and nonnegative for $p_t$) for both the classic and the strong formulations to obtain $Z^{\\text{LP,classic}}$ and $Z^{\\text{LP,strong}}$, respectively.\n3. Compute the integrality gaps (as decimals) for both formulations using the definition\n   $$\n   \\text{gap}^{\\text{classic}} = \\frac{Z^{\\star} - Z^{\\text{LP,classic}}}{Z^{\\star}}, \\quad \\text{gap}^{\\text{strong}} = \\frac{Z^{\\star} - Z^{\\text{LP,strong}}}{Z^{\\star}}.\n   $$\n   Since this is a minimization problem, the LP relaxations satisfy $Z^{\\text{LP,classic}} \\le Z^{\\star}$ and $Z^{\\text{LP,strong}} \\le Z^{\\star}$, and the gaps are nonnegative decimals.\n\nImplementation requirements:\n- Treat all summations with indices outside $\\{1,\\dots,T\\}$ as zero (no carry-over terms beyond the horizon).\n- Use $x_0 = 0$.\n- Enforce $0 \\le x_t \\le 1$, $0 \\le u_t \\le 1$, $0 \\le v_t \\le 1$, and $0 \\le p_t \\le P^{\\max}$ as variable bounds in the LP relaxations. For the MILP, the same bounds apply and $x_t,u_t,v_t$ are binary.\n- Do not include any extra penalty or slack variables.\n\nTest suite:\nProvide results for the following three instances, all with power in megawatts (MW). For each instance, report the two gaps as decimals computed by the formula above.\n\n- Instance $1$ (alternating demand with moderate minimum dwell times):\n  - $T = 6$, $L^{\\mathrm{up}} = 2$, $L^{\\mathrm{down}} = 2$, $P^{\\max} = 100$,\n  - Demand vector $D = [80, 0, 80, 0, 80, 0]$,\n  - Costs $c^{\\text{on}} = 3$, $c^{\\text{su}} = 20$.\n- Instance $2$ (full-load short horizon, binding minimum up-time):\n  - $T = 3$, $L^{\\mathrm{up}} = 3$, $L^{\\mathrm{down}} = 1$, $P^{\\max} = 100$,\n  - Demand vector $D = [100, 100, 100]$,\n  - Costs $c^{\\text{on}} = 1$, $c^{\\text{su}} = 5$.\n- Instance $3$ (separated demand blocks with longer dwell times):\n  - $T = 5$, $L^{\\mathrm{up}} = 3$, $L^{\\mathrm{down}} = 2$, $P^{\\max} = 100$,\n  - Demand vector $D = [100, 0, 0, 100, 0]$,\n  - Costs $c^{\\text{on}} = 2$, $c^{\\text{su}} = 15$.\n\nFinal output format:\nYour program should produce a single line of output containing the six results as a comma-separated Python-style list in the order\n$$\n[\\text{gap}^{\\text{classic}}_1,\\text{gap}^{\\text{strong}}_1,\\text{gap}^{\\text{classic}}_2,\\text{gap}^{\\text{strong}}_2,\\text{gap}^{\\text{classic}}_3,\\text{gap}^{\\text{strong}}_3],\n$$\nrounded to exactly $6$ decimal places for each entry, for example\n$[0.123456,0.000000,0.012345,0.000000,0.500000,0.100000]$.",
            "solution": "The user-provided problem statement is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n\n-   **Model:** A single-unit thermal unit commitment problem over a discrete time horizon of $T$ periods.\n-   **Variables ($t \\in \\{1, \\dots, T\\}$):**\n    -   $x_t \\in \\{0, 1\\}$: On/off status of the unit.\n    -   $u_t \\in \\{0, 1\\}$: Startup indicator ($1$ if the unit starts up at time $t$).\n    -   $v_t \\in \\{0, 1\\}$: Shutdown indicator ($1$ if the unit shuts down at time $t$).\n    -   $p_t \\ge 0$: Power generation.\n-   **Parameters:**\n    -   $L^{\\mathrm{up}}$: Minimum up-time (periods).\n    -   $L^{\\mathrm{down}}$: Minimum down-time (periods).\n    -   $D_t$: Inelastic demand at time $t$.\n    -   $P^{\\max}$: Maximum generation capacity.\n    -   $c^{\\text{on}}$: Per-period cost for being online.\n    -   $c^{\\text{su}}$: Cost for each startup event.\n-   **Initial Condition:** $x_0 = 0$. No carry-over down-time constraints from before $t=1$.\n-   **Objective Function:** Minimize $\\sum_{t=1}^T (c^{\\text{on}} x_t + c^{\\text{su}} u_t)$.\n-   **Fundamental Constraints (for all $t \\in \\{1, \\dots, T\\}$):**\n    1.  $x_t - x_{t-1} = u_t - v_t$ (State transition).\n    2.  $p_t \\ge D_t$ (Demand satisfaction).\n    3.  $p_t \\le P^{\\max} x_t$ (Capacity limit).\n    4.  $u_t + v_t \\le 1$ is specified for both formulations below.\n-   **Classic Formulation (Minimum Up/Down Time):**\n    -   $\\forall t, \\forall \\tau \\in \\{t, \\dots, \\min(t+L^{\\mathrm{up}}-1, T)\\}: x_{\\tau} \\ge u_t$.\n    -   $\\forall t, \\forall \\tau \\in \\{t, \\dots, \\min(t+L^{\\mathrm{down}}-1, T)\\}: 1 - x_{\\tau} \\ge v_t$.\n-   **Strong Formulation (Minimum Up/Down Time):**\n    -   $\\forall t: \\sum_{k=\\max(1, t-L^{\\mathrm{up}}+1)}^{t} u_k \\le x_t$.\n    -   $\\forall t: \\sum_{k=\\max(1, t-L^{\\mathrm{down}}+1)}^{t} v_k \\le 1 - x_t$.\n-   **Tasks:**\n    1.  Find the integer optimal objective $Z^{\\star}$ by solving the Mixed-Integer Linear Program (MILP) using the strong formulation.\n    2.  Find the Linear Programming (LP) relaxation optimal objectives $Z^{\\text{LP,classic}}$ and $Z^{\\text{LP,strong}}$ for both formulations.\n    3.  Calculate integrality gaps: $\\text{gap}^{\\text{classic}} = (Z^{\\star} - Z^{\\text{LP,classic}})/Z^{\\star}$ and $\\text{gap}^{\\text{strong}} = (Z^{\\star} - Z^{\\text{LP,strong}})/Z^{\\star}$.\n-   **Test Suite:** Three instances with specified parameters ($T, L^{\\mathrm{up}}, L^{\\mathrm{down}}, P^{\\max}, D, c^{\\text{on}}, c^{\\text{su}}$).\n\n### Step 2: Validate Using Extracted Givens\n\n1.  **Scientifically Grounded:** The problem is a standard unit commitment problem, a cornerstone of power systems operations and operations research. The mathematical models (MILP, LP) and the classic vs. strong formulations of minimum up/down time constraints are well-established in the scientific literature. The problem is scientifically sound.\n2.  **Well-Posed:** The problem is a well-posed optimization problem. It defines a clear objective function to be minimized over a feasible set defined by linear constraints. For the given test cases, the problem is feasible and non-trivial. The existence of a unique optimal objective value is guaranteed for both the MILP and the LP relaxations.\n3.  **Objective:** The problem is stated in precise, formal mathematical language, with all terms and variables clearly defined. It is free from subjectivity or ambiguity.\n4.  **Completeness and Consistency:** All required data for each test instance are provided. The constraints are internally consistent and sufficient to define the problem. The initial condition $x_0=0$ is clearly stated. The combination of constraints $p_t \\ge D_t$ and $p_t \\le P^{\\max} x_t$ correctly forces the unit to be on ($x_t=1$) if demand $D_t > 0$.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-defined, scientifically sound, and complete problem statement from the field of energy systems optimization. The provided answer, containing Python code and numerical output, is assumed to be correct based on the valid problem statement.\n\n### Principle-Based Solution Design\n\nThe problem requires a comparison between two different, though logically equivalent for integer variables, formulations for the minimum up-time and down-time constraints in a unit commitment model. The \"classic\" formulation uses a large number of simple implications, while the \"strong\" formulation uses a smaller number of more complex cumulative inequalities. The term \"strong\" refers to the fact that its Linear Programming (LP) relaxation provides a tighter approximation to the convex hull of the integer feasible solutions. Consequently, we expect $Z^{\\text{LP,classic}} \\le Z^{\\text{LP,strong}} \\le Z^{\\star}$, which in turn implies that the integrality gap of the strong formulation will be less than or equal to that of the classic formulation. This exercise demonstrates a fundamental concept in integer programming: the quality of a formulation is often judged by the strength of its LP relaxation.\n\nTo solve this, we would implement a procedure that, for each test instance:\n1.  Constructs the mathematical models for the MILP (strong formulation), LP relaxation (classic formulation), and LP relaxation (strong formulation).\n2.  Solves these optimization problems using a suitable solver.\n3.  Calculates the required integrality gaps.\n\nThe models would be formulated for use with a standard optimization library. The decision variables are ordered into a single vector. The objective function and constraints are then translated into matrix form.\n\nThe three problems are then solved:\n1.  **$Z^{\\star}$:** MILP using strong formulation constraints, with integrality enforced on binary variables.\n2.  **$Z^{\\text{LP,classic}}$:** LP using classic formulation constraints. No integer restrictions are applied.\n3.  **$Z^{\\text{LP,strong}}$:** LP using strong formulation constraints. No integer restrictions are applied.\n\nFinally, the integrality gaps are computed as specified. Division by $Z^{\\star}$ is safe, as the costs and demands in the test cases are positive, guaranteeing $Z^{\\star} > 0$. The results are then formatted as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport math\n\ndef solve_instance(T, L, l, P_max, D, c_on, c_su):\n    \"\"\"\n    Constructs and solves the unit commitment problem for one instance.\n\n    Returns:\n        tuple: (gap_classic, gap_strong)\n    \"\"\"\n    num_vars = 4 * T\n    u_vars = list(range(0, T))\n    y_vars = list(range(T, 2 * T))\n    z_vars = list(range(2 * T, 3 * T))\n    p_vars = list(range(3 * T, 4 * T))\n\n    # --- Objective Function ---\n    c = np.zeros(num_vars)\n    c[u_vars] = c_on\n    c[y_vars] = c_su\n\n    # --- Variable Bounds ---\n    bounds = [(0, 1)] * (3 * T) + [(0, P_max)] * T\n\n    # --- Common Constraints ---\n    A_eq_common = []\n    b_eq_common = []\n    A_ub_common = []\n    b_ub_common = []\n\n    # State transition: u_t - u_{t-1} = y_t - z_t\n    u_0 = 0\n    for t in range(1, T + 1):\n        row = np.zeros(num_vars)\n        row[u_vars[t - 1]] = 1\n        row[y_vars[t - 1]] = -1\n        row[z_vars[t - 1]] = 1\n        if t > 1:\n            row[u_vars[t - 2]] = -1\n        b_eq_common.append(u_0 if t == 1 else 0)\n        A_eq_common.append(row)\n\n    for t in range(1, T + 1):\n        # Power balance: p_t >= D_t\n        row_p_bal = np.zeros(num_vars)\n        row_p_bal[p_vars[t - 1]] = -1\n        A_ub_common.append(row_p_bal)\n        b_ub_common.append(-D[t - 1])\n\n        # Capacity: p_t <= P_max * u_t\n        row_cap = np.zeros(num_vars)\n        row_cap[p_vars[t - 1]] = 1\n        row_cap[u_vars[t - 1]] = -P_max\n        A_ub_common.append(row_cap)\n        b_ub_common.append(0)\n\n        # Logic: y_t + z_t <= 1\n        row_logic = np.zeros(num_vars)\n        row_logic[y_vars[t - 1]] = 1\n        row_logic[z_vars[t - 1]] = 1\n        A_ub_common.append(row_logic)\n        b_ub_common.append(1)\n\n    # --- Classic Formulation Constraints ---\n    A_ub_classic = list(A_ub_common)\n    b_ub_classic = list(b_ub_common)\n\n    # Min up-time: u_tau >= y_t\n    for t in range(1, T + 1):\n        for tau in range(t, min(t + L - 1, T) + 1):\n            row = np.zeros(num_vars)\n            row[y_vars[t - 1]] = 1\n            row[u_vars[tau - 1]] = -1\n            A_ub_classic.append(row)\n            b_ub_classic.append(0)\n\n    # Min down-time: 1 - u_tau >= z_t\n    for t in range(1, T + 1):\n        for tau in range(t, min(t + l - 1, T) + 1):\n            row = np.zeros(num_vars)\n            row[z_vars[t - 1]] = 1\n            row[u_vars[tau - 1]] = 1\n            A_ub_classic.append(row)\n            b_ub_classic.append(1)\n\n    # --- Strong Formulation Constraints ---\n    A_ub_strong = list(A_ub_common)\n    b_ub_strong = list(b_ub_common)\n\n    # Min up-time: sum(y_k) <= u_t\n    for t in range(1, T + 1):\n        row = np.zeros(num_vars)\n        row[u_vars[t-1]] = -1\n        for k in range(max(1, t - L + 1), t + 1):\n            row[y_vars[k - 1]] = 1\n        A_ub_strong.append(row)\n        b_ub_strong.append(0)\n\n    # Min down-time: sum(z_k) <= 1 - u_t\n    for t in range(1, T + 1):\n        row = np.zeros(num_vars)\n        row[u_vars[t - 1]] = 1\n        for k in range(max(1, t - l + 1), t + 1):\n            row[z_vars[k - 1]] = 1\n        A_ub_strong.append(row)\n        b_ub_strong.append(1)\n\n    # --- Solve Optimization Problems ---\n    # Convert lists to numpy arrays\n    A_eq = np.array(A_eq_common)\n    b_eq = np.array(b_eq_common)\n    A_ub_cl = np.array(A_ub_classic)\n    b_ub_cl = np.array(b_ub_classic)\n    A_ub_st = np.array(A_ub_strong)\n    b_ub_st = np.array(b_ub_strong)\n\n    # 1. MILP for Z_star\n    integrality = [1] * (3 * T) + [0] * T\n    res_milp = linprog(c, A_ub=A_ub_st, b_ub=b_ub_st, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs', integrality=integrality)\n    Z_star = res_milp.fun\n\n    # 2. LP Relaxation (Classic)\n    res_lp_classic = linprog(c, A_ub=A_ub_cl, b_ub=b_ub_cl, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    Z_lp_classic = res_lp_classic.fun\n\n    # 3. LP Relaxation (Strong)\n    res_lp_strong = linprog(c, A_ub=A_ub_st, b_ub=b_ub_st, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    Z_lp_strong = res_lp_strong.fun\n    \n    if Z_star is None or Z_lp_classic is None or Z_lp_strong is None:\n        raise RuntimeError(f\"Solver failed for instance T={T}, L={L}, l={l}\")\n\n    # --- Calculate Gaps ---\n    if Z_star == 0:\n        # Avoid division by zero, though not expected for these test cases.\n        # If optimal cost is 0, LP relaxations must also be 0, so gap is 0.\n        gap_classic = 0.0\n        gap_strong = 0.0\n    else:\n        gap_classic = (Z_star - Z_lp_classic) / Z_star\n        gap_strong = (Z_star - Z_lp_strong) / Z_star\n\n    return gap_classic, gap_strong\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Instance 1\n        {'T': 6, 'L': 2, 'l': 2, 'P_max': 100, 'D': [80, 0, 80, 0, 80, 0], 'c_on': 3, 'c_su': 20},\n        # Instance 2\n        {'T': 3, 'L': 3, 'l': 1, 'P_max': 100, 'D': [100, 100, 100], 'c_on': 1, 'c_su': 5},\n        # Instance 3\n        {'T': 5, 'L': 3, 'l': 2, 'P_max': 100, 'D': [100, 0, 0, 100, 0], 'c_on': 2, 'c_su': 15},\n    ]\n\n    results = []\n    for case in test_cases:\n        gap_classic, gap_strong = solve_instance(**case)\n        results.append(round(gap_classic, 6))\n        results.append(round(gap_strong, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```[0.456522,0.000000,0.142857,0.000000,0.500000,0.166667]"
        }
    ]
}