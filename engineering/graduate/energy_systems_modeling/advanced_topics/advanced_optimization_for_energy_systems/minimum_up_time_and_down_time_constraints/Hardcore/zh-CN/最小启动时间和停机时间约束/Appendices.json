{
    "hands_on_practices": [
        {
            "introduction": "理论联系实际是掌握任何建模技巧的关键。本练习旨在帮助您将最小开关机时间的抽象操作规则，转化为具体、明确的数学约束。通过为一个具体的小规模场景手动构建约束条件，您将能更深刻地理解机组的历史状态如何直接影响未来的可行决策空间，这是所有能源系统建模者必须掌握的基础技能。",
            "id": "4103870",
            "problem": "考虑一个在离散调度周期 $t \\in \\{1,2,3\\}$ 上建模的单一火力发电机组。令 $x_t \\in \\{0,1\\}$ 表示在时间 $t$ 的运行状态，其中 $x_t=1$ 表示机组已投入运行（开机），$x_t=0$ 表示机组未投入运行（关机）。令 $u_t \\in \\{0,1\\}$ 表示在时间 $t$ 的启动决策，而 $v_t \\in \\{0,1\\}$ 表示在时间 $t$ 的停机决策。该机组受到最小持续运行时间为 $L$ 个连续周期和最小持续停机时间为 $D$ 个连续周期的约束。机组组合问题的标准混合整数线性规划 (MILP) 模型使用逻辑关系 $x_t - x_{t-1} = u_t - v_t$ 以及防止同时启动和停机的一致性约束。\n\n从以下基本操作性定义出发：\n- 最小持续运行时间为 $L$ 意味着一旦机组启动（$u_s=1$），它必须在从 $s$ 开始的至少 $L$ 个连续周期内保持开启状态。\n- 最小持续停机时间为 $D$ 意味着一旦机组停机（$v_s=1$），它必须在从 $s$ 开始的至少 $D$ 个连续周期内保持关闭状态。\n\n在调度时域开始时，初始运行状态为 $x_0=1$，且机组在紧邻 $t=1$ 之前已连续运行了 $T^{\\mathrm{on}}_0=1$ 个周期。由于机组初始状态为开启，因此没有从之前带入到调度时域的剩余最小停机时间要求。参数为 $L=3$ 和 $D=2$。\n\n任务：\n1. 仅使用上述操作性定义和标准的二元变量逻辑，明确写出在每个 $t \\in \\{1,2,3\\}$ 时刻必须满足的所有有效约束，包括：\n   - 连接 $x_t$、$u_t$ 和 $v_t$ 的启停演化和一致性约束。\n   - 在调度时域内可强制执行的最小持续运行时间约束，需考虑初始条件 $x_0=1$ 和 $T^{\\mathrm{on}}_0=1$。\n   - 在调度时域内可强制执行的最小持续停机时间约束，给定 $D=2$ 和 $x_0=1$。\n2. 确定这些约束所允许的 $u_1$ 的最大可行值。\n\n将最终答案表示为单个数字。无需四舍五入，也无需单位。",
            "solution": "该问题要求在一个离散时间域上为单个机组组合问题建立约束模型，并随后确定一个特定决策变量的最大可行值。解答分为两部分，对应于指定的两个任务。\n\n### 任务1：建立约束模型\n\n系统定义在离散时间周期 $t \\in \\{1, 2, 3\\}$上。变量包括二元运行状态 $x_t \\in \\{0,1\\}$、启动决策 $u_t \\in \\{0,1\\}$ 和停机决策 $v_t \\in \\{0,1\\}$。参数为最小持续运行时间 $L=3$ 和最小持续停机时间 $D=2$。在周期 $t=1$ 开始时的初始条件是 $x_0=1$ 和初始已运行时间 $T^{\\mathrm{on}}_0=1$ 个周期。\n\n根据问题陈述，我们为每个 $t \\in \\{1, 2, 3\\}$ 推导出约束。\n\n**1. 启停演化和一致性约束**\n\n这些约束将状态变量 $x_t$ 与决策变量 $u_t$ 和 $v_t$ 联系起来。关系式 $x_t - x_{t-1} = u_t - v_t$ 描述了状态的变化。一个一致性约束确保了启动和停机不能在同一周期内发生。\n\n对于 $t=1$：\n$x_1 - x_0 = u_1 - v_1$。给定 $x_0=1$，该式变为 $x_1 - 1 = u_1 - v_1$。\n$u_1 + v_1 \\le 1$。\n\n对于 $t=2$：\n$x_2 - x_1 = u_2 - v_2$。\n$u_2 + v_2 \\le 1$。\n\n对于 $t=3$：\n$x_3 - x_2 = u_3 - v_3$。\n$u_3 + v_3 \\le 1$。\n\n**2. 最小持续运行时间约束**\n\n最小持续运行时间为 $L=3$ 个周期。\n\n*   **来自初始条件的约束**：机组初始状态为开启（$x_0=1$），且已运行了 $T^{\\mathrm{on}}_0=1$ 个周期。为了满足 $L=3$ 的最小持续运行时间，它必须再继续运行至少 $L - T^{\\mathrm{on}}_0 = 3 - 1 = 2$ 个周期。这意味着机组在周期 $t=1$ 和 $t=2$ 必须处于开启状态。因此，在周期 $t=1$ 开始时（这将使总运行时间仅为1个周期）和在周期 $t=2$ 开始时（这将使总运行时间仅为2个周期）禁止停机。这导致对停机变量的以下约束：\n    $v_1 = 0$\n    $v_2 = 0$\n\n*   **来自新启动的约束**：如果机组在时间 $s$ 启动（$u_s=1$），它必须保持开启至少 $L=3$ 个周期（即周期 $s, s+1, s+2$）。这意味着它不能在 $t=s+1$ 或 $t=s+2$ 时停机。\n    *   对于在 $t=1$ 的启动（$u_1=1$）：禁止在 $t=2$ 和 $t=3$ 停机。该约束可写作 $v_t \\le 1-u_1$ 对 $t \\in \\{2, 3\\}$。对于 $t=2$ 的约束是 $v_2 \\le 1-u_1$，这是冗余的，因为我们已经有更强的约束 $v_2=0$。对于 $t=3$ 的约束是：\n        $v_3 + u_1 \\le 1$。\n    *   对于在 $t=2$ 的启动（$u_2=1$）：禁止在 $t=3$ 停机。这产生了约束 $v_3 \\le 1-u_2$：\n        $v_3 + u_2 \\le 1$。\n    *   在 $t=3$ 的启动会施加超出调度时域的要求，因此在 $t \\in \\{1,2,3\\}$ 的时域内无法强制执行更多此类约束。\n\n**3. 最小持续停机时间约束**\n\n最小持续停机时间为 $D=2$ 个周期。初始状态为开启，所以没有从 $t=1$ 之前延续过来的停机时间约束。\n\n*   **来自新停机的约束**：如果机组在时间 $s$ 停机（$v_s=1$），它必须保持关闭至少 $D=2$ 个周期（即周期 $s, s+1$）。这意味着它不能在 $t=s+1$ 时启动。\n    *   对于在 $t=1$ 的停机（$v_1=1$）：禁止在 $t=2$ 启动。这产生了约束 $u_2 \\le 1-v_1$：\n        $u_2 + v_1 \\le 1$。\n    *   对于在 $t=2$ 的停机（$v_2=1$）：禁止在 $t=3$ 启动。这产生了约束 $u_3 \\le 1-v_2$：\n        $u_3 + v_2 \\le 1$。\n    *   在 $t=3$ 的停机施加了超出调度时域的要求。\n\n总而言之，对于 $t \\in \\{1,2,3\\}$ 的完整约束集合包括了上面列出的演化、一致性、持续运行时间和持续停机时间约束。\n\n### 任务2：$u_1$ 的最大可行值\n\n为了确定二元变量 $u_1$ 的最大可行值，我们分析涉及它的约束。最直接的约束是 $t=1$ 时的状态演化方程：\n$$x_1 - x_0 = u_1 - v_1$$\n问题指定了初始条件 $x_0=1$。代入该值得到：\n$$x_1 - 1 = u_1 - v_1$$\n在时间 $t=1$ 的启动决策对应于设置 $u_1=1$。根据一致性约束 $u_1 + v_1 \\le 1$，如果 $u_1=1$，则必须有 $v_1=0$。\n将 $u_1=1$ 和 $v_1=0$ 代入演化方程，得出：\n$$x_1 - 1 = 1 - 0$$\n$$x_1 = 2$$\n变量 $x_1$ 代表运行状态，并被定义为二元变量，$x_1 \\in \\{0,1\\}$。结果 $x_1=2$ 违反了这一定义。因此，包含 $u_1=1$ 的解是不可行的。\n\n这个结论是机组组合逻辑的基础：只有当机组当前处于关闭状态时，才可能做出“启动”决策。鉴于机组在 $t=0$ 时是开启的（$x_0=1$），它不能在 $t=1$ 时启动。\n\n由于 $u_1$ 是一个二元变量，其唯一可能的值是 $0$ 和 $1$。我们已经证明 $u_1=1$ 是不可行的。唯一剩下的可能性是 $u_1=0$。为了确认这是一个有效的赋值，我们必须验证它至少是一个可行解的一部分。\n\n让我们设置 $u_1=0$。从初始条件推导出的最小持续运行时间约束可知，我们有 $v_1=0$。$t=1$ 时的演化方程变为 $x_1 - 1 = 0 - 0$，这给出 $x_1=1$。这是一个有效的状态。\n如约束推导部分所示，初始条件也强制 $v_2=0$。$t=2$ 时的演化方程 $x_2-x_1=u_2-v_2$ 变为 $x_2-1=u_2-0$。在 $t=2$ 启动（$u_2=1$）将要求 $x_1=0$，但情况并非如此。因此，我们必须有 $u_2=0$，这给出 $x_2=1$。\n在 $t=3$ 时，机组已运行了3个周期，因此允许停机（$v_3=1$）。这给出了一个可行的轨迹。\n由于 $u_1=0$ 是一个可行解的一部分而 $u_1=1$ 不是，因此 $u_1$ 的所有可行值的集合是 $\\{0\\}$。\n\n这个集合中的最大值是 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在实际的电力系统调度中，优化决策通常是采用滚动优化的方式进行的。本练习聚焦于一个高级但至关重要的问题：如何在滚动优化的边界上传递约束，以确保决策的时间一致性。通过分析一个因重新优化而可能违背最小开机时间承诺的案例，您将学会如何构建“记忆”约束，以保证模型在动态决策过程中的可行性和可靠性。",
            "id": "4103893",
            "problem": "考虑一个针对单个发电机组 $g$ 的火电机组组合问题的滚动优化时域混合整数线性规划 (MILP) 模型。该模型具有二元运行状态变量 $x_t \\in \\{0,1\\}$ 和二元启动变量 $u_t \\in \\{0,1\\}$，时间段以小时为单位，由 $t \\in \\mathbb{Z}_{+}$ 索引。该机组有规定的最小持续运行时间 $L$ 小时，这意味着在任何一次启动后，机组必须连续运行至少 $L$ 个连续时段。最小持续运行时间的基本定义是：一旦在时间 $t_s$ 发生启动（即 $u_{t_s} = 1$），则对于所有 $t \\in \\{t_s, t_s+1, \\dots, t_s + L - 1\\}$，其运行状态必须满足 $x_t = 1$。\n\n一个滚动优化时域调度器在两个连续的优化时域上进行求解。第一个优化时域是 $T_0 = \\{1,2,3,4\\}$，第二个优化时域是 $T_1 = \\{3,4,5,6\\}$。该发电机的最小持续运行时间为 $L = 3$。存在外生负荷 $d_t$ 和一个仅在第二个优化时域中才可用的替代电源选项。具体来说：\n- 在 $T_0$ 中，只有机组 $g$ 可用，负荷满足 $d_2 = 1$、$d_3 = 1$、$d_4 = 1$，且 $d_1 = 0$。机组 $g$ 能够满足负荷，并被第一个优化时域的优化器决策为开启，在 $t = 2$ 时产生一次启动，因此 $u_2 = 1$ 且 $x_2 = 1$。\n- 在 $T_1$ 中，一个可变成本严格低于机组 $g$ 的替代机组变得可用，并且能够满足 $t \\in \\{3,4,5,6\\}$ 期间的所有负荷，这使得在不受约束的情况下，在 $T_1$ 开始时立即关闭机组 $g$ 在经济上具有吸引力。\n\n在 $T_1$ 进行的这种滚动重新优化将违反机组 $g$ 先前已承诺的最小持续运行时间，因为该机组在 $t = 2$ 时启动，因此必须在 $t = 3$ 和 $t = 4$ 保持开启状态，以完成其 $L = 3$ 的连续运行小时数。为防止此类提前关停，必须将最小持续运行时间的“记忆”跨越优化时域边界进行传递，并在 $T_1$ 中强制执行一个修正约束，以确保机组因 $T_0$ 中的启动而剩余的强制运行时间内保持开启状态。\n\n从最小持续运行时间的基本定义和 $T_1$ 在 $t_0 = 3$ 处的优化时域边界概念出发，构建一个数学上一致的修正，通过强制执行前一个优化时域启动所隐含的剩余强制运行时间来防止在 $T_1$ 中提前关停。然后，计算标量剩余强制执行长度 $R$，其定义为在 $T_1$ 开始阶段为满足先前已启动的最小持续运行时间而必须强制机组保持开启状态的时段数。将 $R$ 作为你的最终答案报告。无需四舍五入，且 $R$ 没有关联的物理单位。",
            "solution": "问题陈述被评估为有效。其科学依据在于能源系统优化的原理，特别是机组组合（UC）。该问题提法恰当、客观，并提供了一套完整且一致的数据和定义，以得出唯一且有意义的解。它解决了在滚动优化时域方案中，如何跨越优化时域边界来维持诸如最小持续运行时间等约束的时间一致性的常见问题。\n\n问题的核心在于如何将发电机组的状态从一个已完成的优化时域转换到后续优化时域的初始条件。最小持续运行时间约束的基本定义是此分析的起点。\n\n发电机 $g$ 受最小持续运行时间 $L$ 小时的约束。如前所述，如果在时间 $t_s$ 发生启动事件，由二元变量 $u_{t_s} = 1$ 表示，那么机组的运行状态（由二元变量 $x_t$ 表示）在区间 $\\{t_s, t_s+1, \\dots, t_s + L - 1\\}$ 内的所有时间段 $t$ 都必须为 $x_t = 1$。\n\n根据问题陈述，我们得到以下具体信息：\n1.  机组 $g$ 的最小持续运行时间为 $L = 3$ 小时。\n2.  在第一个优化时域 $T_0 = \\{1, 2, 3, 4\\}$ 中，在时间 $t = 2$ 为机组 $g$ 做出了启动决策。因此，启动时间为 $t_s = 2$，第一次优化得到的决策变量包括 $u_2 = 1$ 和 $x_2 = 1$。\n\n应用 $L=3$ 和 $t_s=2$ 的最小持续运行时间定义，机组被强制在属于集合 $\\{2, 2+1, \\dots, 2+3-1\\}$ 的时间段 $t$ 内保持“开启”状态 ($x_t=1$)。该集合计算为时间索引集 $\\{2, 3, 4\\}$。因此，来自 $T_0$ 优化的决策 $u_2=1$ 意味着对 $x_2=1$、$x_3=1$ 和 $x_4=1$ 的约束性承诺。\n\n问题接着进入滚动优化时域更新。第二次优化在优化时域 $T_1 = \\{3, 4, 5, 6\\}$ 上执行。这个新的优化从时间 $t=3$ 开始。此时，对 $t \\ge 3$ 的决策将进行重新评估。然而，前一个优化时域中对 $t  3$ 做出的决策现在已成为固定的历史，并且已经建立了可能延伸到新优化时域的承诺。\n\n在 $t_s=2$ 启动的承诺跨越了时间段 $\\{2, 3, 4\\}$。新的优化时域 $T_1$ 覆盖了时间段 $\\{3, 4, 5, 6\\}$。为确保最小持续运行时间约束不被违反，强制承诺区间中落在新优化时域内的任何部分都必须作为固定约束来强制执行。\n\n过去承诺的仍然具有强制性的时段集合是 $M = \\{2, 3, 4\\}$。\n新优化时域中的时段集合是 $T_1 = \\{3, 4, 5, 6\\}$。\n这两个集合的交集给出了新优化时域中机组必须被强制保持开启的时段：\n$$ M \\cap T_1 = \\{2, 3, 4\\} \\cap \\{3, 4, 5, 6\\} = \\{3, 4\\} $$\n因此，在针对优化时域 $T_1$ 的 MILP 模型中，必须添加以下修正约束以强制执行剩余的强制运行时间：\n$$ x_3 = 1 $$\n$$ x_4 = 1 $$\n\n问题要求计算标量剩余强制执行长度 $R$，其定义为在 $T_1$ 开始阶段必须强制机组保持开启状态的时段数。根据我们的推导，必须在时段 $t=3$ 和 $t=4$ 强制机组保持开启状态。这是优化时域 $T_1$ 的前两个时段。这些时段的数量是 2。\n因此，$R = 2$。\n\n更一般地，我们可以将 $R$ 的计算形式化。设 $t_{start}$ 为机组的启动时间。设 $t_{new}$ 为新优化时域的第一个时间段。在新优化时域开始之前，该机组已经在线运行了 $t_{new} - t_{start}$ 个时段。它还必须保持在线的剩余时段数是最小持续运行时间 $L$ 減去它已经运行的时间。这仅当这个量为正时才有效。\n\n剩余运行时间 $R$ 可以计算为：\n$$ R = \\max(0, L - (t_{new} - t_{start})) $$\n在这个具体问题中，我们有 $L=3$，$t_{start} = t_s = 2$，新的优化时域 $T_1$ 从 $t_{new}=3$ 开始。将这些值代入公式：\n$$ R = \\max(0, 3 - (3 - 2)) $$\n$$ R = \\max(0, 3 - 1) $$\n$$ R = \\max(0, 2) $$\n$$ R = 2 $$\n这证实了为了遵守在前一个优化时域中启动的最小持续运行时间约束，机组 $g$ 的运行状态在新优化时域 $T_1$ 的前 2 个时段（即 $t=3$ 和 $t=4$）必须被强制固定为 $x_t=1$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "对于混合整数线性规划问题，逻辑上等价的数学模型在计算性能上可能存在天壤之别。本练习是一个计算实践，旨在通过对比“经典”（弱）与“强”两种公式的线性松弛效果，来量化“整数规划间隙”这一核心概念。您将通过编程实践，亲身体会到为何“强”公式在求解大规模优化模型时更为优越，这对于构建高效、可扩展的调度模型至关重要。",
            "id": "4103848",
            "problem": "考虑一个离散时间内的单火电机组组合模型，决策周期长度为 $T$。该机组的最小持续运行时间为 $L$ 个周期，最小持续停机时间为 $\\ell$ 个周期。令 $t \\in \\{1,\\dots,T\\}$ 为时间周期的索引。状态变量包括：运行状态 $x_t \\in \\{0,1\\}$、启动指示变量 $u_t \\in \\{0,1\\}$、停机指示变量 $v_t \\in \\{0,1\\}$ 以及发电功率 $p_t \\ge 0$。发电必须满足一个已知的无弹性需求 $D_t$，机组为容量是 $P^{\\max}$ 的单个机组，且没有最小出力。该机组初始状态为停机，即 $x_0 = 0$，并且初始历史满足所有最小停机时间要求，因此不需要初始延续约束。\n\n目标是最小化每周期运行成本和启动成本之和。具体来说，最小化 $\\sum_{t=1}^T c^{\\text{on}} x_t + c^{\\text{su}} u_t$，同时需满足可行性约束以及最小持续运行时间和最小持续停机时间的经典公式或强公式。所有成本以每周期一致的货币单位表示，所有功率量以兆瓦 (MW) 为单位。由于所要求的数量是无量纲的，请将最终输出表示为纯小数（无单位，无百分号）。\n\n使用以下基本建模基础：\n- 状态转移强制要求对所有 $t$ 满足 $x_t - x_{t-1} = u_t - v_t$，其中 $x_0 = 0$。\n- 功率平衡与容量强制要求对所有 $t$ 满足 $p_t \\ge D_t$ 和 $p_t \\le P^{\\max} x_t$。\n- 变量域为 $x_t \\in \\{0,1\\}$，$u_t \\in \\{0,1\\}$，$v_t \\in \\{0,1\\}$，$p_t \\ge 0$。\n\n定义最小持续运行时间和最小持续停机时间逻辑的两种可选线性公式：\n\n- 经典公式（窗口式蕴含）：\n  - 对所有 $t$ 和所有 $\\tau \\in \\{t,\\dots,\\min(t+L-1,T)\\}$，强制要求 $x_{\\tau} \\ge u_t$。\n  - 对所有 $t$ 和所有 $\\tau \\in \\{t,\\dots,\\min(t+\\ell-1,T)\\}$，强制要求 $1 - x_{\\tau} \\ge v_t$。\n  - 此外，对所有 $t$ 强制要求 $u_t + v_t \\le 1$。\n\n- 强公式（累积窗口不等式）：\n  - 对所有 $t$，强制要求 $\\sum_{k=\\max(1,t-L+1)}^{t} u_k \\le x_t$。\n  - 对所有 $t$，强制要求 $\\sum_{k=\\max(1,t-\\ell+1)}^{t} v_k \\le 1 - x_t$。\n  - 此外，对所有 $t$ 强制要求 $u_t + v_t \\le 1$。\n\n您的程序必须：\n1. 求解带有二进制变量的混合整数线性规划 (MILP) 的强公式，以获得整数最优目标值 $Z^{\\star}$。\n2. 求解经典公式和强公式的线性规划 (LP) 松弛（对于 $x_t,u_t,v_t$ 所有变量在 $[0,1]$ 内连续，对于 $p_t$ 为非负数），以分别获得 $Z^{\\text{LP,classic}}$ 和 $Z^{\\text{LP,strong}}$。\n3. 使用以下定义计算两种公式的整数性间隙（以小数形式表示）：\n   $$\n   \\text{gap}^{\\text{classic}} = \\frac{Z^{\\star} - Z^{\\text{LP,classic}}}{Z^{\\star}}, \\quad \\text{gap}^{\\text{strong}} = \\frac{Z^{\\star} - Z^{\\text{LP,strong}}}{Z^{\\star}}.\n   $$\n   由于这是一个最小化问题，LP 松弛满足 $Z^{\\text{LP,classic}} \\le Z^{\\star}$ 和 $Z^{\\text{LP,strong}} \\le Z^{\\star}$，且间隙为非负小数。\n\n实现要求：\n- 将索引超出 $\\{1,\\dots,T\\}$ 的所有求和项视为零（无超出周期的延续项）。\n- 使用 $x_0 = 0$。\n- 在 LP 松弛中，将 $0 \\le x_t \\le 1$，$0 \\le u_t \\le 1$，$0 \\le v_t \\le 1$ 和 $0 \\le p_t \\le P^{\\max}$ 作为变量边界。对于 MILP，应用相同的边界，且 $x_t,u_t,v_t$ 为二进制变量。\n- 不包含任何额外的惩罚或松弛变量。\n\n测试套件：\n为以下三个实例提供结果，所有实例的功率单位均为兆瓦 (MW)。对于每个实例，报告按上述公式计算的两个间隙（以小数形式表示）。\n\n- 实例 1（交替需求，中等最小驻留时间）：\n  - $T = 6$，$L = 2$，$\\ell = 2$，$P^{\\max} = 100$，\n  - 需求向量 $D = [80, 0, 80, 0, 80, 0]$，\n  - 成本 $c^{\\text{on}} = 3$，$c^{\\text{su}} = 20$。\n- 实例 2（满负荷短周期，最小启动时间有约束力）：\n  - $T = 3$，$L = 3$，$\\ell = 1$，$P^{\\max} = 100$，\n  - 需求向量 $D = [100, 100, 100]$，\n  - 成本 $c^{\\text{on}} = 1$，$c^{\\text{su}} = 5$。\n- 实例 3（分离的需求块，较长驻留时间）：\n  - $T = 5$，$L = 3$，$\\ell = 2$，$P^{\\max} = 100$，\n  - 需求向量 $D = [100, 0, 0, 100, 0]$，\n  - 成本 $c^{\\text{on}} = 2$，$c^{\\text{su}} = 15$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个结果，格式为逗号分隔的 Python 风格列表，顺序为\n$$\n[\\text{gap}^{\\text{classic}}_1,\\text{gap}^{\\text{strong}}_1,\\text{gap}^{\\text{classic}}_2,\\text{gap}^{\\text{strong}}_2,\\text{gap}^{\\text{classic}}_3,\\text{gap}^{\\text{strong}}_3],\n$$\n每个条目四舍五入到恰好 $6$ 位小数，例如\n$[0.123456,0.000000,0.012345,0.000000,0.500000,0.100000]$。",
            "solution": "在尝试任何解决方案之前，对用户提供的问题陈述进行验证。\n\n### 第 1 步：提取已知信息\n\n-   **模型：** 一个在 $T$ 个周期的离散时间内的单火电机组组合问题。\n-   **变量 ($t \\in \\{1, \\dots, T\\}$):**\n    -   $x_t \\in \\{0, 1\\}$: 机组的运行状态。\n    -   $u_t \\in \\{0, 1\\}$: 启动指示变量（若机组在时间 $t$ 启动则为 $1$）。\n    -   $v_t \\in \\{0, 1\\}$: 停机指示变量（若机组在时间 $t$ 停机则为 $1$）。\n    -   $p_t \\ge 0$: 发电功率。\n-   **参数：**\n    -   $L$: 最小持续运行时间（周期）。\n    -   $\\ell$: 最小持续停机时间（周期）。\n    -   $D_t$: 时间 $t$ 的无弹性需求。\n    -   $P^{\\max}$: 最大发电容量。\n    -   $c^{\\text{on}}$: 每周期在线成本。\n    -   $c^{\\text{su}}$: 每次启动事件的成本。\n-   **初始条件：** $x_0 = 0$。$t=1$ 之前没有延续的停机时间约束。\n-   **目标函数：** 最小化 $\\sum_{t=1}^T (c^{\\text{on}} x_t + c^{\\text{su}} u_t)$。\n-   **基本约束 (对所有 $t \\in \\{1, \\dots, T\\}$):**\n    1.  $x_t - x_{t-1} = u_t - v_t$ (状态转移)。\n    2.  $p_t \\ge D_t$ (需求满足)。\n    3.  $p_t \\le P^{\\max} x_t$ (容量限制)。\n    4.  $u_t + v_t \\le 1$ 在以下两种公式中均有规定。\n-   **经典公式 (最小持续运行/停机时间):**\n    -   $\\forall t, \\forall \\tau \\in \\{t, \\dots, \\min(t+L-1, T)\\}: x_{\\tau} \\ge u_t$。\n    -   $\\forall t, \\forall \\tau \\in \\{t, \\dots, \\min(t+\\ell-1, T)\\}: 1 - x_{\\tau} \\ge v_t$。\n-   **强公式 (最小持续运行/停机时间):**\n    -   $\\forall t: \\sum_{k=\\max(1, t-L+1)}^{t} u_k \\le x_t$。\n    -   $\\forall t: \\sum_{k=\\max(1, t-\\ell+1)}^{t} v_k \\le 1 - x_t$。\n-   **任务：**\n    1.  通过求解使用强公式的混合整数线性规划 (MILP)，找到整数最优目标值 $Z^{\\star}$。\n    2.  对两种公式，求解线性规划 (LP) 松弛的最优目标值 $Z^{\\text{LP,classic}}$ 和 $Z^{\\text{LP,strong}}$。\n    3.  计算整数性间隙：$\\text{gap}^{\\text{classic}} = (Z^{\\star} - Z^{\\text{LP,classic}})/Z^{\\star}$ 和 $\\text{gap}^{\\text{strong}} = (Z^{\\star} - Z^{\\text{LP,strong}})/Z^{\\star}$。\n-   **测试套件：** 三个具有指定参数 ($T, L, \\ell, P^{\\max}, D, c^{\\text{on}}, c^{\\text{su}}$) 的实例。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n1.  **科学依据：** 该问题是一个标准的机组组合问题，是电力系统运行和运筹学的基石。数学模型（MILP, LP）以及最小启停时间约束的经典与强公式在科学文献中已有完善的论述。该问题具有科学合理性。\n2.  **良构性：** 该问题是一个良构的优化问题。它定义了一个清晰的目标函数，该函数在一个由线性约束定义的可行集上进行最小化。对于给定的测试用例，问题是可行的且非平凡的。MILP 和 LP 松弛都保证了唯一最优目标值的存在。\n3.  **客观性：** 问题以精确、形式化的数学语言陈述，所有术语和变量都已明确定义。它没有主观性或歧义。\n4.  **完整性与一致性：** 提供了每个测试实例所需的所有数据。约束条件内部一致且足以定义该问题。初始条件 $x_0=0$ 已明确说明。约束组合 $p_t \\ge D_t$ 和 $p_t \\le P^{\\max} x_t$ 正确地强制机组在需求 $D_t  0$ 时必须开启 ($x_t=1$)。\n\n### 第 3 步：结论与行动\n\n该问题是 **有效的**。这是一个来自能源系统优化领域、定义明确、科学合理且完整的问​​题陈述。我将继续进行解决方案的开发。\n\n### 基于原则的解决方案设计\n\n该问题要求在一个机组组合模型中，比较两种用于最小启停时间约束的不同公式，尽管它们对于整数变量在逻辑上是等价的。“经典”公式使用大量简单的蕴含关系，而“强”公式使用较少但更复杂的累积不等式。“强”一词指的是其线性规划 (LP) 松弛为整数可行解的凸包提供了更紧的近似。因此，我们预期 $Z^{\\text{LP,classic}} \\le Z^{\\text{LP,strong}} \\le Z^{\\star}$，这反过来意味着强公式的整数性间隙将小于或等于经典公式的整数性间隙。这个练习展示了整数规划中的一个基本概念：一个公式的质量通常通过其 LP 松弛的强度来评判。\n\n为解决此问题，我们将实施一个程序，对每个测试实例执行以下操作：\n1.  为 MILP（强公式）、LP 松弛（经典公式）和 LP 松弛（强公式）构建数学模型。\n2.  使用合适的求解器求解这些优化问题。\n3.  计算所需的整数性间隙。\n\n这些模型将被构造成可与 `scipy.optimize.linprog` 一同使用，该函数可以处理 LP 和 MILP 问题。决策变量被排成一个大小为 $4T$ 的单一向量 $X = [x_1, \\dots, x_T, u_1, \\dots, u_T, v_1, \\dots, v_T, p_1, \\dots, p_T]^T$。然后将目标函数和约束转换为矩阵形式：\n-   **最小化：** $c^T X$\n-   **约束于：** $A_{eq} X = b_{eq}$ 和 $A_{ub} X \\le b_{ub}$\n-   **边界为：** $l \\le X \\le u$。\n\n令变量的索引为 $i_x(t) = t-1$，$i_u(t) = T+t-1$，$i_v(t) = 2T+t-1$ 和 $i_p(t) = 3T+t-1$，其中 $t \\in \\{1, \\dots, T\\}$。\n\n**目标向量 $c$:**\n成本为 $\\sum_{t=1}^T (c^{\\text{on}} x_t + c^{\\text{su}} u_t)$。长度为 $4T$ 的向量 $c$ 将具有 $c_{i_x(t)} = c^{\\text{on}}$，$c_{i_u(t)} = c^{\\text{su}}$，所有其他元素等于 $0$。\n\n**共同约束（等式）：**\n状态转移方程 $x_t - x_{t-1} = u_t - v_t$ 产生 $T$ 个等式约束。\n-   对于 $t=1$: $x_1 - u_1 + v_1 = x_0 = 0$。\n-   对于 $t \\in \\{2, \\dots, T\\}$: $x_t - x_{t-1} - u_t + v_t = 0$。\n这些构成了矩阵 $A_{eq}$ 和向量 $b_{eq}$。\n\n**共同约束（不等式）：**\n这些约束将成为所有三个问题的 $A_{ub}$ 和 $b_{ub}$ 的一部分。\n-   需求满足：$p_t \\ge D_t \\implies -p_t \\le -D_t$。\n-   容量限制：$p_t \\le P^{\\max} x_t \\implies p_t - P^{\\max} x_t \\le 0$。\n-   启动/停机逻辑：$u_t + v_t \\le 1$。\n\n**经典公式约束（不等式）：**\n-   最小持续运行时间：$u_t - x_{\\tau} \\le 0$，对于 $t \\in \\{1, \\dots, T\\}$ 和 $\\tau \\in \\{t, \\dots, \\min(t+L-1, T)\\}$。\n-   最小持续停机时间：$x_{\\tau} + v_t \\le 1$，对于 $t \\in \\{1, \\dots, T\\}$ 和 $\\tau \\in \\{t, \\dots, \\min(t+\\ell-1, T)\\}$。\n\n**强公式约束（不等式）：**\n-   最小持续运行时间：$(\\sum_{k=\\max(1, t-L+1)}^{t} u_k) - x_t \\le 0$，对于 $t \\in \\{1, \\dots, T\\}$。\n-   最小持续停机时间：$(\\sum_{k=\\max(1, t-\\ell+1)}^{t} v_k) + x_t \\le 1$，对于 $t \\in \\{1, \\dots, T\\}$。\n\n**变量边界：**\n-   对于 LP 松弛：$x_t, u_t, v_t \\in [0, 1]$ 和 $p_t \\in [0, P^{\\max}]$。\n-   对于 MILP：相同的边界，但附加约束 $x_t, u_t, v_t$ 是整数。\n\n然后求解这三个问题：\n1.  **$Z^{\\star}$:** 使用强公式约束的 MILP。使用 `linprog` 的 `integrality` 参数来强制对 $x_t, u_t, v_t$ 施加二进制限制。\n2.  **$Z^{\\text{LP,classic}}$:** 使用经典公式约束的 LP。不应用整数限制。\n3.  **$Z^{\\text{LP,strong}}$:** 使用强公式约束的 LP。不应用整数限制。\n\n最后，按规定计算整数性间隙。除以 $Z^{\\star}$ 是安全的，因为测试用例中的成本和需求都是正的，这保证了 $Z^{\\star}  0$。然后按要求格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport math\n\ndef solve_instance(T, L, l, P_max, D, c_on, c_su):\n    \"\"\"\n    Constructs and solves the unit commitment problem for one instance.\n\n    Returns:\n        tuple: (gap_classic, gap_strong)\n    \"\"\"\n    num_vars = 4 * T\n    x_vars = list(range(0, T))\n    u_vars = list(range(T, 2 * T))\n    v_vars = list(range(2 * T, 3 * T))\n    p_vars = list(range(3 * T, 4 * T))\n\n    # --- Objective Function ---\n    c = np.zeros(num_vars)\n    c[x_vars] = c_on\n    c[u_vars] = c_su\n\n    # --- Variable Bounds ---\n    bounds = [(0, 1)] * (3 * T) + [(0, P_max)] * T\n\n    # --- Common Constraints ---\n    A_eq_common = []\n    b_eq_common = []\n    A_ub_common = []\n    b_ub_common = []\n\n    # State transition: x_t - x_{t-1} = u_t - v_t\n    x_0 = 0\n    for t in range(1, T + 1):\n        row = np.zeros(num_vars)\n        row[x_vars[t - 1]] = 1\n        row[u_vars[t - 1]] = -1\n        row[v_vars[t - 1]] = 1\n        if t  1:\n            row[x_vars[t - 2]] = -1\n        b_eq_common.append(x_0 if t == 1 else 0)\n        A_eq_common.append(row)\n\n    for t in range(1, T + 1):\n        # Power balance: p_t = D_t\n        row_p_bal = np.zeros(num_vars)\n        row_p_bal[p_vars[t - 1]] = -1\n        A_ub_common.append(row_p_bal)\n        b_ub_common.append(-D[t - 1])\n\n        # Capacity: p_t = P_max * x_t\n        row_cap = np.zeros(num_vars)\n        row_cap[p_vars[t - 1]] = 1\n        row_cap[x_vars[t - 1]] = -P_max\n        A_ub_common.append(row_cap)\n        b_ub_common.append(0)\n\n        # Logic: u_t + v_t = 1\n        row_logic = np.zeros(num_vars)\n        row_logic[u_vars[t - 1]] = 1\n        row_logic[v_vars[t - 1]] = 1\n        A_ub_common.append(row_logic)\n        b_ub_common.append(1)\n\n    # --- Classic Formulation Constraints ---\n    A_ub_classic = list(A_ub_common)\n    b_ub_classic = list(b_ub_common)\n\n    # Min up-time: x_tau = u_t\n    for t in range(1, T + 1):\n        for tau in range(t, min(t + L - 1, T) + 1):\n            row = np.zeros(num_vars)\n            row[u_vars[t - 1]] = 1\n            row[x_vars[tau - 1]] = -1\n            A_ub_classic.append(row)\n            b_ub_classic.append(0)\n\n    # Min down-time: 1 - x_tau = v_t\n    for t in range(1, T + 1):\n        for tau in range(t, min(t + l - 1, T) + 1):\n            row = np.zeros(num_vars)\n            row[v_vars[t - 1]] = 1\n            row[x_vars[tau - 1]] = 1\n            A_ub_classic.append(row)\n            b_ub_classic.append(1)\n\n    # --- Strong Formulation Constraints ---\n    A_ub_strong = list(A_ub_common)\n    b_ub_strong = list(b_ub_common)\n\n    # Min up-time: sum(u_k) = x_t\n    for t in range(1, T + 1):\n        row = np.zeros(num_vars)\n        row[x_vars[t-1]] = -1\n        for k in range(max(1, t - L + 1), t + 1):\n            row[u_vars[k - 1]] = 1\n        A_ub_strong.append(row)\n        b_ub_strong.append(0)\n\n    # Min down-time: sum(v_k) = 1 - x_t\n    for t in range(1, T + 1):\n        row = np.zeros(num_vars)\n        row[x_vars[t - 1]] = 1\n        for k in range(max(1, t - l + 1), t + 1):\n            row[v_vars[k - 1]] = 1\n        A_ub_strong.append(row)\n        b_ub_strong.append(1)\n\n    # --- Solve Optimization Problems ---\n    # Convert lists to numpy arrays\n    A_eq = np.array(A_eq_common)\n    b_eq = np.array(b_eq_common)\n    A_ub_cl = np.array(A_ub_classic)\n    b_ub_cl = np.array(b_ub_classic)\n    A_ub_st = np.array(A_ub_strong)\n    b_ub_st = np.array(b_ub_strong)\n\n    # 1. MILP for Z_star\n    integrality = [1] * (3 * T) + [0] * T\n    res_milp = linprog(c, A_ub=A_ub_st, b_ub=b_ub_st, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs', integrality=integrality)\n    Z_star = res_milp.fun\n\n    # 2. LP Relaxation (Classic)\n    res_lp_classic = linprog(c, A_ub=A_ub_cl, b_ub=b_ub_cl, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    Z_lp_classic = res_lp_classic.fun\n\n    # 3. LP Relaxation (Strong)\n    res_lp_strong = linprog(c, A_ub=A_ub_st, b_ub=b_ub_st, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    Z_lp_strong = res_lp_strong.fun\n    \n    if Z_star is None or Z_lp_classic is None or Z_lp_strong is None:\n        raise RuntimeError(f\"Solver failed for instance T={T}, L={L}, l={l}\")\n\n    # --- Calculate Gaps ---\n    if Z_star == 0:\n        gap_classic = 0.0\n        gap_strong = 0.0\n    else:\n        gap_classic = (Z_star - Z_lp_classic) / Z_star\n        gap_strong = (Z_star - Z_lp_strong) / Z_star\n\n    return gap_classic, gap_strong\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Instance 1\n        {'T': 6, 'L': 2, 'l': 2, 'P_max': 100, 'D': [80, 0, 80, 0, 80, 0], 'c_on': 3, 'c_su': 20},\n        # Instance 2\n        {'T': 3, 'L': 3, 'l': 1, 'P_max': 100, 'D': [100, 100, 100], 'c_on': 1, 'c_su': 5},\n        # Instance 3\n        {'T': 5, 'L': 3, 'l': 2, 'P_max': 100, 'D': [100, 0, 0, 100, 0], 'c_on': 2, 'c_su': 15},\n    ]\n\n    results = []\n    for case in test_cases:\n        gap_classic, gap_strong = solve_instance(**case)\n        results.append(round(gap_classic, 6))\n        results.append(round(gap_strong, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}