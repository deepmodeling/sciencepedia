{
    "hands_on_practices": [
        {
            "introduction": "Before applying a Graph Neural Network, we must first translate the physical power system into the language of graphs. This fundamental step involves modeling buses and transmission lines as nodes and edges, and then encoding their physical properties into mathematical structures. This practice challenges you to derive the key matrices—the incidence matrix $A$, the bus admittance matrix $Y_{\\mathrm{bus}}$, and the graph Laplacian $L$—that form the bridge between the electrical characteristics of a power network and its abstract graph-theoretic representation . Mastering this translation is essential, as these matrices are the very foundation upon which GNN models for power systems are built.",
            "id": "4094186",
            "problem": "Consider a lossless transmission network represented as a simple chain of buses $1$–$2$–$3$ with two series branches $(1,2)$ and $(2,3)$ having per-unit series reactances $X_{12}=0.2$ and $X_{23}=0.25$, respectively. Assume the Direct Current (DC) power flow approximation in which bus voltage magnitudes are fixed at $1$ per-unit, angle differences are small, branch resistances and shunt elements are neglected, and lines are purely reactive. Adopt an orientation for the two directed edges $e_{1}: 1 \\to 2$ and $e_{2}: 2 \\to 3$. \n\nUsing Kirchhoff’s current law at each bus and Ohm’s law across each line under these DC assumptions, derive from first principles:\n\n(a) the node-to-edge incidence matrix $A$ corresponding to the chosen orientation,\n\n(b) the bus admittance matrix $Y_{\\mathrm{bus}}$ in per-unit,\n\n(c) the weighted graph Laplacian $L$ associated with the network’s susceptance weights.\n\nThen, using the definition of algebraic connectivity as the second-smallest eigenvalue of $L$, compute this eigenvalue exactly as a simplified analytic expression. Express your final answer as a single closed-form expression with no units. Do not round; provide the exact expression.",
            "solution": "The problem requires the derivation of key matrices representing a simple power network and the calculation of its algebraic connectivity. We will proceed step-by-step, deriving each quantity from first principles as requested. The network consists of three buses labeled $1$, $2$, and $3$, connected in a chain by two transmission lines $(1,2)$ and $(2,3)$. The analysis is performed under the standard Direct Current (DC) power flow assumptions.\n\nThe given per-unit series reactances are $X_{12}=0.2$ and $X_{23}=0.25$. In the DC power flow model, resistances are neglected, so the impedance of a branch is purely imaginary: $Z_{ik} = jX_{ik}$. The admittance is the reciprocal of the impedance, $y_{ik} = Z_{ik}^{-1} = (jX_{ik})^{-1} = -j/X_{ik}$. The term $B_{ik} = 1/X_{ik}$ is the branch susceptance.\n\nFor the given branches:\nThe branch susceptance for line $(1,2)$ is $B_{12} = \\frac{1}{X_{12}} = \\frac{1}{0.2} = 5$ per-unit.\nThe branch admittance is $y_{12} = -jB_{12} = -j5$ per-unit.\n\nThe branch susceptance for line $(2,3)$ is $B_{23} = \\frac{1}{X_{23}} = \\frac{1}{0.25} = 4$ per-unit.\nThe branch admittance is $y_{23} = -jB_{23} = -j4$ per-unit.\n\n(a) Derivation of the node-to-edge incidence matrix $A$\n\nThe node-to-edge incidence matrix, denoted by $A$, describes the topology of the directed graph. For a graph with $n$ nodes and $m$ edges, $A$ is an $n \\times m$ matrix. Its elements, $A_{ie}$, are defined based on the given edge orientation:\n- $A_{ie} = +1$ if node $i$ is the source (starting point) of edge $e$.\n- $A_{ie} = -1$ if node $i$ is the sink (ending point) of edge $e$.\n- $A_{ie} = 0$ if node $i$ is not incident to edge $e$.\n\nThe network has $n=3$ nodes (buses) and $m=2$ edges (lines). The specified edge orientations are $e_1: 1 \\to 2$ and $e_2: 2 \\to 3$.\n\nFor edge $e_1$ (column 1 of $A$): Node $1$ is the source ($+1$), node $2$ is the sink ($-1$), and node $3$ is not incident ($0$).\nFor edge $e_2$ (column 2 of $A$): Node $2$ is the source ($+1$), node $3$ is the sink ($-1$), and node $1$ is not incident ($0$).\n\nConstructing the $3 \\times 2$ incidence matrix $A$ with rows for nodes $\\{1, 2, 3\\}$ and columns for edges $\\{e_1, e_2\\}$:\n$$\nA = \\begin{pmatrix}\n1 & 0 \\\\\n-1 & 1 \\\\\n0 & -1\n\\end{pmatrix}\n$$\n\n(b) Derivation of the bus admittance matrix $Y_{\\mathrm{bus}}$\n\nThe bus admittance matrix $Y_{\\mathrm{bus}}$ relates the vector of bus current injections $I$ to the vector of bus voltages $V$ via the equation $I = Y_{\\mathrm{bus}}V$. It can be derived from first principles using Kirchhoff’s Current Law (KCL) at each bus.\n\nLet $V_1, V_2, V_3$ be the complex voltages at buses $1, 2, 3$ and $I_1, I_2, I_3$ be the current injections into these buses.\nKCL at bus 1: The current leaving bus $1$ towards bus $2$ is $(V_1-V_2)y_{12}$. Thus, the injected current is $I_1 = (V_1-V_2)y_{12} = y_{12}V_1 - y_{12}V_2$.\nKCL at bus 2: The current leaving bus $2$ towards bus $1$ is $(V_2-V_1)y_{12}$ and towards bus $3$ is $(V_2-V_3)y_{23}$. The injected current is $I_2 = (V_2-V_1)y_{12} + (V_2-V_3)y_{23} = -y_{12}V_1 + (y_{12}+y_{23})V_2 - y_{23}V_3$.\nKCL at bus 3: The current leaving bus $3$ towards bus $2$ is $(V_3-V_2)y_{23}$. The injected current is $I_3 = (V_3-V_2)y_{23} = -y_{23}V_2 + y_{23}V_3$.\n\nArranging these equations in matrix form $[I] = [Y_{\\mathrm{bus}}][V]$:\n$$\n\\begin{pmatrix} I_1 \\\\ I_2 \\\\ I_3 \\end{pmatrix} =\n\\begin{pmatrix}\ny_{12} & -y_{12} & 0 \\\\\n-y_{12} & y_{12}+y_{23} & -y_{23} \\\\\n0 & -y_{23} & y_{23}\n\\end{pmatrix}\n\\begin{pmatrix} V_1 \\\\ V_2 \\\\ V_3 \\end{pmatrix}\n$$\nSubstituting the calculated admittance values $y_{12} = -j5$ and $y_{23} = -j4$:\n$$\nY_{\\mathrm{bus}} =\n\\begin{pmatrix}\n-j5 & -(-j5) & 0 \\\\\n-(-j5) & (-j5)+(-j4) & -(-j4) \\\\\n0 & -(-j4) & -j4\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-j5 & j5 & 0 \\\\\nj5 & -j9 & j4 \\\\\n0 & j4 & -j4\n\\end{pmatrix}\n$$\n\n(c) Derivation of the weighted graph Laplacian $L$\n\nWithin the DC power flow approximation, the vector of active power injections $P$ is related to the vector of bus voltage angles $\\theta$ by the equation $P = B' \\theta$, where $B'$ is the DC bus admittance matrix. This matrix is defined as $B' = -\\mathrm{Im}(Y_{\\mathrm{bus}})$ and is identical to the weighted graph Laplacian $L$ of the network, where the edge weights are the susceptances $B_{ik}$.\n\nUsing the derived $Y_{\\mathrm{bus}}$:\n$$\n\\mathrm{Im}(Y_{\\mathrm{bus}}) =\n\\begin{pmatrix}\n-5 & 5 & 0 \\\\\n5 & -9 & 4 \\\\\n0 & 4 & -4\n\\end{pmatrix}\n$$\nThe weighted graph Laplacian $L$ is therefore:\n$$\nL = B' = -\\mathrm{Im}(Y_{\\mathrm{bus}}) = -\n\\begin{pmatrix}\n-5 & 5 & 0 \\\\\n5 & -9 & 4 \\\\\n0 & 4 & -4\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n5 & -5 & 0 \\\\\n-5 & 9 & -4 \\\\\n0 & -4 & 4\n\\end{pmatrix}\n$$\nThis matrix is symmetric and has zero row and column sums, which are properties of a Laplacian matrix.\n\nCalculation of the Algebraic Connectivity\n\nThe algebraic connectivity of a graph is the second-smallest eigenvalue of its Laplacian matrix, denoted $\\lambda_2$. For any connected graph, the smallest eigenvalue, $\\lambda_1$, is always $0$. We need to find the eigenvalues of $L$.\nThe characteristic equation is $\\det(L - \\lambda I) = 0$.\n$$\n\\det\\left(\n\\begin{pmatrix}\n5-\\lambda & -5 & 0 \\\\\n-5 & 9-\\lambda & -4 \\\\\n0 & -4 & 4-\\lambda\n\\end{pmatrix}\n\\right) = 0\n$$\nWe expand the determinant along the first row:\n$$\n(5-\\lambda) \\det\\left(\\begin{pmatrix} 9-\\lambda & -4 \\\\ -4 & 4-\\lambda \\end{pmatrix}\\right) - (-5) \\det\\left(\\begin{pmatrix} -5 & -4 \\\\ 0 & 4-\\lambda \\end{pmatrix}\\right) = 0\n$$\n$$\n(5-\\lambda)[(9-\\lambda)(4-\\lambda) - 16] + 5[-5(4-\\lambda) - 0] = 0\n$$\n$$\n(5-\\lambda)[\\lambda^2 - 13\\lambda + 36 - 16] + 5[-20 + 5\\lambda] = 0\n$$\n$$\n(5-\\lambda)(\\lambda^2 - 13\\lambda + 20) - 100 + 25\\lambda = 0\n$$\n$$\n5\\lambda^2 - 65\\lambda + 100 - \\lambda^3 + 13\\lambda^2 - 20\\lambda - 100 + 25\\lambda = 0\n$$\nCombining terms, we get:\n$$\n-\\lambda^3 + (5+13)\\lambda^2 + (-65-20+25)\\lambda + (100-100) = 0\n$$\n$$\n-\\lambda^3 + 18\\lambda^2 - 60\\lambda = 0\n$$\n$$\n\\lambda^3 - 18\\lambda^2 + 60\\lambda = 0\n$$\nFactor out $\\lambda$:\n$$\n\\lambda(\\lambda^2 - 18\\lambda + 60) = 0\n$$\nOne eigenvalue is $\\lambda_1 = 0$, as expected for a connected graph. The other two eigenvalues are the roots of the quadratic equation $\\lambda^2 - 18\\lambda + 60 = 0$.\nUsing the quadratic formula, $\\lambda = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$:\n$$\n\\lambda = \\frac{18 \\pm \\sqrt{(-18)^2 - 4(1)(60)}}{2(1)}\n$$\n$$\n\\lambda = \\frac{18 \\pm \\sqrt{324 - 240}}{2}\n$$\n$$\n\\lambda = \\frac{18 \\pm \\sqrt{84}}{2}\n$$\nTo simplify $\\sqrt{84}$, we note that $84 = 4 \\times 21$, so $\\sqrt{84} = 2\\sqrt{21}$.\n$$\n\\lambda = \\frac{18 \\pm 2\\sqrt{21}}{2} = 9 \\pm \\sqrt{21}\n$$\nThe three eigenvalues are $\\lambda_1=0$, $\\lambda_2=9 - \\sqrt{21}$, and $\\lambda_3=9 + \\sqrt{21}$. Since $\\sqrt{16} < \\sqrt{21} < \\sqrt{25}$, we have $4 < \\sqrt{21} < 5$, which confirms that $0 < 9 - \\sqrt{21} < 9 + \\sqrt{21}$.\nThe eigenvalues in increasing order are $\\lambda_{(1)}=0$, $\\lambda_{(2)}=9 - \\sqrt{21}$, and $\\lambda_{(3)}=9 + \\sqrt{21}$.\n\nThe algebraic connectivity is the second-smallest eigenvalue, $\\lambda_{(2)}$.",
            "answer": "$$\n\\boxed{9-\\sqrt{21}}\n$$"
        },
        {
            "introduction": "With the power grid represented as a graph, we can now explore the core mechanism of a GNN: message passing. In this process, nodes iteratively aggregate information from their local neighborhood to update their own features. This hands-on exercise simulates a single message passing step and prompts you to compare the effectiveness of `sum` versus `max` aggregation in capturing the distributed nature of power flow . By evaluating these different aggregation schemes against a physics-based ground truth, you will gain crucial intuition about how GNN architectural choices influence the model's ability to learn and approximate complex physical dependencies.",
            "id": "4094253",
            "problem": "Consider a connected power transmission network with $5$ buses represented as an undirected graph. Each line $(i,j)$ has a series reactance in per unit (p.u.), and the network is modeled using the linearized Direct Current (DC) power flow approximation. Let the vector of net active power injections be $\\mathbf{p} \\in \\mathbb{R}^{5}$ in p.u., with the convention that generation is positive and load is negative, and power balance $\\sum_{i=1}^{5} p_i = 0$ holds. Angles are measured in radians. Choose bus $1$ as the slack bus with angle $\\theta_1 = 0$. The DC power flow model states that\n$$\n\\mathbf{p} = \\mathbf{B} \\, \\boldsymbol{\\theta},\n$$\nwhere $\\boldsymbol{\\theta} \\in \\mathbb{R}^{5}$ is the vector of bus voltage angles, and $\\mathbf{B} \\in \\mathbb{R}^{5 \\times 5}$ is the bus susceptance matrix defined by\n$$\nB_{ij} = \\begin{cases}\n-\\frac{1}{x_{ij}} & \\text{if buses } i \\text{ and } j \\text{ are directly connected},\\\\\n0 & \\text{if buses } i \\text{ and } j \\text{ are not directly connected and } i \\neq j,\\\\\n-\\sum_{k \\neq i} B_{ik} & \\text{if } i = j,\n\\end{cases}\n$$\nwhere $x_{ij}$ is the series reactance (in p.u.) of the line $(i,j)$. For each connected pair $(i,j)$, the DC branch flow (in p.u.) is\n$$\nF_{ij} = \\frac{1}{x_{ij}} \\left(\\theta_i - \\theta_j\\right),\n$$\nand the total incident flow magnitude at bus $i$ is defined as\n$$\nd_i = \\sum_{j \\in \\mathcal{N}(i)} \\left| F_{ij} \\right|,\n$$\nwhere $\\mathcal{N}(i)$ denotes the set of neighbors of bus $i$.\n\nA Graph Neural Network (GNN) message passing step is defined on this graph as follows. Let the initial node feature be $h_i^{(0)} = p_i$ (in p.u.), and define an edge weight $s_{ij} = \\left| B_{ij} \\right|$ for each connected pair $(i,j)$. The message sent from node $j$ to node $i$ is\n$$\nm_{ij} = s_{ij} \\cdot \\left| h_j^{(0)} \\right| = \\left| B_{ij} \\right| \\cdot \\left| p_j \\right|.\n$$\nTwo aggregation operators at each node $i$ are considered:\n- Sum-aggregation: \n$$\na_i^{\\mathrm{sum}} = \\sum_{j \\in \\mathcal{N}(i)} m_{ij} = \\sum_{j \\in \\mathcal{N}(i)} \\left| B_{ij} \\right| \\cdot \\left| p_j \\right|.\n$$\n- Max-aggregation:\n$$\na_i^{\\mathrm{max}} = \\max_{j \\in \\mathcal{N}(i)} m_{ij} = \\max_{j \\in \\mathcal{N}(i)} \\left\\{ \\left| B_{ij} \\right| \\cdot \\left| p_j \\right| \\right\\}.\n$$\n\nThe goal is to compute a quantitative comparison of how well each aggregation captures the distributed power flow dependencies encoded by $\\{ d_i \\}_{i=1}^{5}$. Define the normalized mean absolute error (dimensionless) of an aggregation vector $\\mathbf{a} \\in \\mathbb{R}^{5}$ with respect to $\\mathbf{d} \\in \\mathbb{R}^{5}$ as\n$$\n\\operatorname{NMAE}(\\mathbf{a}, \\mathbf{d}) = \\frac{\\sum_{i=1}^{5} \\left| a_i - d_i \\right|}{\\sum_{i=1}^{5} d_i}.\n$$\nFor each test case, compute the improvement factor\n$$\n\\gamma = \\frac{\\operatorname{NMAE}\\left(\\mathbf{a}^{\\mathrm{max}}, \\mathbf{d}\\right)}{\\operatorname{NMAE}\\left(\\mathbf{a}^{\\mathrm{sum}}, \\mathbf{d}\\right)},\n$$\nwhich is greater than $1$ if the sum-aggregation is closer (lower error) to the distributed dependency $\\mathbf{d}$ than the max-aggregation.\n\nUse the following $5$-bus network and line reactances (in p.u.):\n- Line $(1,2)$: $x_{12} = 0.2$,\n- Line $(1,3)$: $x_{13} = 0.25$,\n- Line $(2,3)$: $x_{23} = 0.3$,\n- Line $(2,4)$: $x_{24} = 0.4$,\n- Line $(3,5)$: $x_{35} = 0.35$,\n- Line $(4,5)$: $x_{45} = 0.5$,\n- Line $(1,5)$: $x_{15} = 0.45$.\n\nConstruct $\\mathbf{B}$ accordingly. Solve for $\\boldsymbol{\\theta}$ using the DC power flow relation with slack bus angle $\\theta_1 = 0$. Compute $F_{ij}$ for each connected line and then $d_i$ for each bus.\n\nTest Suite (all injections in p.u., each vector $\\mathbf{p}$ satisfies $\\sum_i p_i = 0$):\n- Case $1$ (distributed injections): $\\mathbf{p}^{(1)} = [0.4,\\,-0.1,\\,0.0,\\,-0.15,\\,-0.15]$,\n- Case $2$ (single source and single sink): $\\mathbf{p}^{(2)} = [1.0,\\,-1.0,\\,0.0,\\,0.0,\\,0.0]$,\n- Case $3$ (neighboring buses opposite): $\\mathbf{p}^{(3)} = [0.0,\\,0.6,\\,-0.6,\\,0.0,\\,0.0]$,\n- Case $4$ (mildly spread): $\\mathbf{p}^{(4)} = [0.25,\\,-0.05,\\,-0.1,\\,-0.05,\\,-0.05]$.\n\nYour program should produce a single line of output containing the improvement factors $\\gamma$ for the four cases as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$). Angles must be treated in radians, reactances and injections in p.u., and the final improvement factors are dimensionless floats. Round nothing; report the raw computed floats.",
            "solution": "The user-provided problem is validated as scientifically grounded, well-posed, objective, and self-contained. It is a formal problem in power systems analysis and graph neural networks, free of any identified flaws. A complete solution is therefore warranted.\n\nThe solution methodology involves a systematic computation for each test case provided. The core steps are: 1) constructing the network's mathematical representation, 2) solving the DC power flow equations to find bus voltage angles, 3) calculating the ground-truth flow distribution metric $\\mathbf{d}$, 4) computing the GNN-based aggregation metrics $\\mathbf{a}^{\\mathrm{sum}}$ and $\\mathbf{a}^{\\mathrm{max}}$, and 5) evaluating the final improvement factor $\\gamma$.\n\n### Step 1: Network Representation and Susceptance Matrix Construction\n\nThe $5$-bus power network is represented as a graph where buses are nodes and transmission lines are edges. The key electrical property for the DC power flow model is the bus susceptance matrix $\\mathbf{B} \\in \\mathbb{R}^{5 \\times 5}$. Its elements are derived from the given line reactances $x_{ij}$.\n\nThe off-diagonal elements are given by $B_{ij} = -1/x_{ij}$ if an edge exists between bus $i$ and bus $j$, and $B_{ij} = 0$ otherwise. The diagonal elements are $B_{ii} = -\\sum_{k \\neq i} B_{ik}$. Let's denote the susceptance magnitude of a line as $b_{ij} = 1/x_{ij}$. The given reactances are:\n- $x_{12} = 0.2 \\implies b_{12} = 5.0$ p.u.\n- $x_{13} = 0.25 \\implies b_{13} = 4.0$ p.u.\n- $x_{23} = 0.3 \\implies b_{23} \\approx 3.333$ p.u.\n- $x_{24} = 0.4 \\implies b_{24} = 2.5$ p.u.\n- $x_{35} = 0.35 \\implies b_{35} \\approx 2.857$ p.u.\n- $x_{45} = 0.5 \\implies b_{45} = 2.0$ p.u.\n- $x_{15} = 0.45 \\implies b_{15} \\approx 2.222$ p.u.\n\nUsing these values, the bus susceptance matrix $\\mathbf{B}$ is constructed as:\n$$\n\\mathbf{B} = \\begin{pmatrix}\nb_{12}+b_{13}+b_{15} & -b_{12} & -b_{13} & 0 & -b_{15} \\\\\n-b_{12} & b_{12}+b_{23}+b_{24} & -b_{23} & -b_{24} & 0 \\\\\n-b_{13} & -b_{23} & b_{13}+b_{23}+b_{35} & 0 & -b_{35} \\\\\n0 & -b_{24} & 0 & b_{24}+b_{45} & -b_{45} \\\\\n-b_{15} & 0 & -b_{35} & -b_{45} & b_{15}+b_{35}+b_{45}\n\\end{pmatrix}\n$$\nNumerically, this is:\n$$\n\\mathbf{B} \\approx \\begin{pmatrix}\n11.222 & -5.0 & -4.0 & 0.0 & -2.222 \\\\\n-5.0 & 10.833 & -3.333 & -2.5 & 0.0 \\\\\n-4.0 & -3.333 & 10.190 & 0.0 & -2.857 \\\\\n0.0 & -2.5 & 0.0 & 4.5 & -2.0 \\\\\n-2.222 & 0.0 & -2.857 & -2.0 & 7.079\n\\end{pmatrix}\n$$\n\n### Step 2: Solving for Bus Voltage Angles\n\nThe DC power flow model is a linear system $\\mathbf{p} = \\mathbf{B} \\boldsymbol{\\theta}$, where $\\mathbf{p}$ is the net active power injection vector and $\\boldsymbol{\\theta}$ is the bus voltage angle vector. The matrix $\\mathbf{B}$ is singular because its row and column sums are zero. To obtain a unique solution, we must specify a reference angle. The problem designates bus $1$ as the slack bus with $\\theta_1 = 0$ radians.\n\nThis allows us to solve for the remaining unknown angles $(\\theta_2, \\theta_3, \\theta_4, \\theta_5)$. We form a reduced linear system by removing the first row and first column of the original system:\n$$\n\\mathbf{p}_{\\text{red}} = \\mathbf{B}_{\\text{red}} \\boldsymbol{\\theta}_{\\text{red}}\n$$\nwhere $\\mathbf{p}_{\\text{red}} = [p_2, p_3, p_4, p_5]^T$, $\\boldsymbol{\\theta}_{\\text{red}} = [\\theta_2, \\theta_3, \\theta_4, \\theta_5]^T$, and $\\mathbf{B}_{\\text{red}}$ is the $4 \\times 4$ submatrix of $\\mathbf{B}$ corresponding to buses $2$ through $5$. Since the network is connected, $\\mathbf{B}_{\\text{red}}$ is invertible. The unknown angles are found by solving this system:\n$$\n\\boldsymbol{\\theta}_{\\text{red}} = \\mathbf{B}_{\\text{red}}^{-1} \\mathbf{p}_{\\text{red}}\n$$\nThe full angle vector for the network is then $\\boldsymbol{\\theta} = [0, \\theta_2, \\theta_3, \\theta_4, \\theta_5]^T$.\n\n### Step 3: Calculation of Target Flow Dependencies ($\\mathbf{d}$)\n\nThe vector $\\mathbf{d}$ represents the ground-truth distribution of power flow stress at each bus. First, we compute the active power flow $F_{ij}$ on each line $(i,j)$:\n$$\nF_{ij} = \\frac{1}{x_{ij}} (\\theta_i - \\theta_j) = b_{ij}(\\theta_i - \\theta_j)\n$$\nThen, for each bus $i$, we sum the magnitudes of all flows on lines connected to it:\n$$\nd_i = \\sum_{j \\in \\mathcal{N}(i)} |F_{ij}|\n$$\nwhere $\\mathcal{N}(i)$ is the set of neighboring buses of bus $i$. This calculation is performed for all $i \\in \\{1, \\dots, 5\\}$ to form the vector $\\mathbf{d}$.\n\n### Step 4: Calculation of GNN Aggregations ($\\mathbf{a}^{\\mathrm{sum}}$ and $\\mathbf{a}^{\\mathrm{max}}$)\n\nThe problem defines a single GNN message passing step where initial node features are the power injections, $h_i^{(0)} = p_i$. The aggregations $\\mathbf{a}^{\\mathrm{sum}}$ and $\\mathbf{a}^{\\mathrm{max}}$ are local approximations of flow distribution, computed without solving the global power flow equations.\n\nFor each bus $i$, the message from a neighboring bus $j$ is $m_{ij} = |B_{ij}| \\cdot |p_j| = b_{ij} |p_j|$. The two aggregation operators are then:\n- Sum-aggregation: $a_i^{\\mathrm{sum}} = \\sum_{j \\in \\mathcal{N}(i)} m_{ij} = \\sum_{j \\in \\mathcal{N}(i)} b_{ij} |p_j|$\n- Max-aggregation: $a_i^{\\mathrm{max}} = \\max_{j \\in \\mathcal{N}(i)} m_{ij} = \\max_{j \\in \\mathcal{N}(i)} \\{ b_{ij} |p_j| \\}$\n\nThese calculations are performed for all $i \\in \\{1, \\dots, 5\\}$ to form the vectors $\\mathbf{a}^{\\mathrm{sum}}$ and $\\mathbf{a}^{\\mathrm{max}}$.\n\n### Step 5: Error and Improvement Factor Calculation\n\nThe normalized mean absolute error (NMAE) quantifies the discrepancy between an aggregated vector $\\mathbf{a}$ and the target vector $\\mathbf{d}$:\n$$\n\\operatorname{NMAE}(\\mathbf{a}, \\mathbf{d}) = \\frac{\\sum_{i=1}^{5} |a_i - d_i|}{\\sum_{i=1}^{5} d_i}\n$$\nThe final improvement factor $\\gamma$ compares the performance of sum-aggregation to max-aggregation:\n$$\n\\gamma = \\frac{\\operatorname{NMAE}(\\mathbf{a}^{\\mathrm{max}}, \\mathbf{d})}{\\operatorname{NMAE}(\\mathbf{a}^{\\mathrm{sum}}, \\mathbf{d})} = \\frac{\\sum_{i=1}^{5} |a_i^{\\mathrm{max}} - d_i| / \\sum_{i=1}^{5} d_i}{\\sum_{i=1}^{5} |a_i^{\\mathrm{sum}} - d_i| / \\sum_{i=1}^{5} d_i} = \\frac{\\sum_{i=1}^{5} |a_i^{\\mathrm{max}} - d_i|}{\\sum_{i=1}^{5} |a_i^{\\mathrm{sum}} - d_i|}\n$$\nA value $\\gamma > 1$ indicates that sum-aggregation provides a better approximation of the true flow distribution $\\mathbf{d}$ than max-aggregation. This entire procedure is repeated for each of the four specified test cases for the power injection vector $\\mathbf{p}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the power system GNN analysis problem for four test cases.\n    \"\"\"\n    \n    # Define network parameters using 1-based indexing for clarity.\n    reactances = {\n        (1, 2): 0.2, (1, 3): 0.25, (2, 3): 0.3, (2, 4): 0.4,\n        (3, 5): 0.35, (4, 5): 0.5, (1, 5): 0.45\n    }\n    num_buses = 5\n\n    # Convert to 0-based indexing for implementation.\n    connections = [(u - 1, v - 1, x) for (u, v), x in reactances.items()]\n\n    # Build susceptance-related structures.\n    # We use 0-based indexing for all arrays and lists from here on.\n    B = np.zeros((num_buses, num_buses))\n    neighbors = [[] for _ in range(num_buses)]\n    b_values = {} # To store |B_ij| = 1/x_ij\n\n    for u, v, x in connections:\n        susceptance = -1.0 / x\n        # Off-diagonal elements of B matrix\n        B[u, v] = susceptance\n        B[v, u] = susceptance\n        \n        # Store absolute value b_ij = 1/x_ij for future calculations\n        b_values[(u, v)] = 1.0 / x\n        b_values[(v, u)] = 1.0 / x\n\n        # Adjacency list for graph traversal\n        if v not in neighbors[u]:\n            neighbors[u].append(v)\n        if u not in neighbors[v]:\n            neighbors[v].append(u)\n    \n    # Sort neighbor lists for deterministic behavior (optional but good practice)\n    for i in range(num_buses):\n        neighbors[i].sort()\n\n    # Diagonal elements of B matrix\n    for i in range(num_buses):\n        B[i, i] = -np.sum(B[i, :]) + B[i,i] # sum B_ik for k!=i\n\n    # Reduced B matrix for solving with slack bus 1 (index 0)\n    B_red = B[1:, 1:]\n    \n    # Define the test cases for power injections p.\n    test_cases = [\n        np.array([0.4, -0.1, 0.0, -0.15, -0.15]),\n        np.array([1.0, -1.0, 0.0, 0.0, 0.0]),\n        np.array([0.0, 0.6, -0.6, 0.0, 0.0]),\n        np.array([0.25, -0.05, -0.1, -0.05, -0.05]),\n    ]\n\n    results = []\n\n    for p in test_cases:\n        # Step 1: Solve for angles theta using DC power flow\n        p_red = p[1:]\n        theta_red = np.linalg.solve(B_red, p_red)\n        theta = np.concatenate(([0.0], theta_red))\n\n        # Step 2: Calculate the target vector d (total incident flow magnitude)\n        d = np.zeros(num_buses)\n        for i in range(num_buses):\n            total_incident_flow = 0.0\n            for j in neighbors[i]:\n                # F_ij = (1/x_ij) * (theta_i - theta_j)\n                flow = b_values[(i, j)] * (theta[i] - theta[j])\n                total_incident_flow += abs(flow)\n            d[i] = total_incident_flow\n\n        # Step 3: Calculate GNN aggregation vectors a_sum and a_max\n        a_sum = np.zeros(num_buses)\n        a_max = np.zeros(num_buses)\n        p_abs = np.abs(p)\n\n        for i in range(num_buses):\n            messages = []\n            for j in neighbors[i]:\n                # m_ij = |B_ij| * |p_j| = (1/x_ij) * |p_j|\n                msg = b_values[(i, j)] * p_abs[j]\n                messages.append(msg)\n            \n            # Aggregate messages\n            if messages:\n                a_sum[i] = np.sum(messages)\n                a_max[i] = np.max(messages)\n        \n        # Step 4: Calculate NMAEs and the improvement factor gamma\n        mae_sum = np.sum(np.abs(a_sum - d))\n        mae_max = np.sum(np.abs(a_max - d))\n\n        # The factor gamma is the ratio of the Mean Absolute Errors (MAE), as the\n        # normalization factor sum(d_i) cancels out.\n        if mae_sum == 0:\n            # If sum-aggregation is perfect, its error is 0.\n            # If max-aggregation is also perfect, they are equally good (gamma=1).\n            # If max-aggregation is not perfect, sum is infinitely better (gamma=inf).\n            gamma = 1.0 if mae_max == 0 else float('inf')\n        else:\n            gamma = mae_max / mae_sum\n        \n        results.append(gamma)\n\n    # Print the final results in the specified format without rounding.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Graph Neural Networks are powerful tools, but they exhibit characteristic behaviors that must be understood to be used effectively. One of the most important is the \"smoothing\" effect, where repeated local aggregations can cause node features across the graph to become indistinguishable, potentially erasing vital information. This practice investigates this phenomenon by simulating two popular GNN architectures, GCN and GraphSAGE, over multiple layers to observe their impact on a physically meaningful signal . By quantifying how the voltage angle contrast across a transmission corridor degrades, you will develop a critical awareness of oversmoothing, a key challenge in designing deep GNNs for physical systems.",
            "id": "4094185",
            "problem": "Consider a path graph representing a transmission corridor with $4$ buses labeled $1, 2, 3, 4$. The buses are connected sequentially as $1–2, 2–3, 3–4$. Let the node feature at bus $i$ be the bus voltage angle $\\theta_i$ in radians. In linearized direct current (DC) power flow, the active power flow on a line is proportional to the angle difference across its terminals, and steep angle gradients indicate high stress and transfer across the corridor. We investigate how two iterations of graph-based averaging affect the end-to-end angle contrast between buses $1$ and $4$.\n\nYou must implement two message-passing layers for each of the following architectures:\n\n- Graph Convolutional Network (GCN): Graph Convolutional Network (GCN) uses symmetric normalization with self-loops. Construct the adjacency matrix $A$ for the path graph, then build $\\tilde{A} = A + I$ where $I$ is the identity matrix. Define the diagonal degree matrix $\\tilde{D}$ where $\\tilde{D}_{ii} = \\sum_j \\tilde{A}_{ij}$. The propagation operator is the symmetric normalization $\\hat{A} = \\tilde{D}^{-1/2} \\tilde{A} \\tilde{D}^{-1/2}$. Apply two layers with identity weights and no nonlinearity, so the two-layer propagated angles are $\\theta^{(2)}_{\\mathrm{GCN}} = \\hat{A} \\hat{A} \\theta^{(0)}$.\n\n- Graph Sample And Aggregate (GraphSAGE): Graph Sample And Aggregate (GraphSAGE) with mean aggregation and self-loops can be represented by row-normalizing the self-looped adjacency. Using the same $\\tilde{A}$, define $P = \\tilde{D}^{-1} \\tilde{A}$. Apply two layers with identity weights and no nonlinearity to obtain $\\theta^{(2)}_{\\mathrm{SAGE}} = P P \\theta^{(0)}$.\n\nYour task is to quantify the degradation in end-to-end angle contrast induced by these two-layer propagations. Define the initial contrast as $C_0 = \\left|\\theta^{(0)}_4 - \\theta^{(0)}_1\\right|$ and the post-propagation contrasts as $C_{\\mathrm{GCN}} = \\left|\\theta^{(2)}_{\\mathrm{GCN},4} - \\theta^{(2)}_{\\mathrm{GCN},1}\\right|$ and $C_{\\mathrm{SAGE}} = \\left|\\theta^{(2)}_{\\mathrm{SAGE},4} - \\theta^{(2)}_{\\mathrm{SAGE},1}\\right|$. Report the contrast degradation ratios $r_{\\mathrm{GCN}} = C_{\\mathrm{GCN}} / C_0$ and $r_{\\mathrm{SAGE}} = C_{\\mathrm{SAGE}} / C_0$. If $C_0 = 0$, define both ratios to be $0$. Angles must be handled in radians.\n\nUse the following test suite of initial angle configurations $\\theta^{(0)}$ (all entries in radians):\n\n- Test $1$: $\\theta^{(0)} = [0.0, 0.2, 0.6, 1.4]$ (a large gradient from bus $1$ to bus $4$).\n- Test $2$: $\\theta^{(0)} = [0.5, 0.5, 0.5, 0.5]$ (uniform angles).\n- Test $3$: $\\theta^{(0)} = [1.2, 0.0, 0.0, -1.2]$ (anti-phase endpoints).\n- Test $4$: $\\theta^{(0)} = [0.0, 0.0, 0.0, 1.0]$ (sharp step at the terminal bus).\n\nYour program must compute, for each test case, the two degradation ratios $r_{\\mathrm{GCN}}$ and $r_{\\mathrm{SAGE}}$ and produce a single line of output containing all results as a comma-separated list enclosed in square brackets, ordered as $[r_{\\mathrm{GCN},1}, r_{\\mathrm{SAGE},1}, r_{\\mathrm{GCN},2}, r_{\\mathrm{SAGE},2}, r_{\\mathrm{GCN},3}, r_{\\mathrm{SAGE},3}, r_{\\mathrm{GCN},4}, r_{\\mathrm{SAGE},4}]$. Each element must be a floating-point number in radians implied by the ratios, and no additional text should be printed.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique solution. The concepts of linearized DC power flow and graph neural network propagation are standard and correctly applied.\n\nThe solution proceeds by first constructing the GCN and GraphSAGE propagation operators for the specified graph, then applying them for two iterations to compute the final node features, and finally calculating the contrast degradation ratios for each test case.\n\n**1. Graph and Matrix Definitions**\n\nThe system is a path graph with $4$ buses, labeled $1, 2, 3, 4$. The connections are $1–2$, $2–3$, and $3–4$. Using zero-based indexing for matrices (node $1 \\to$ index $0$, node $4 \\to$ index $3$), the adjacency matrix $A$ is:\n$$\nA = \\begin{pmatrix} 0 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}\n$$\nThe adjacency matrix with self-loops, $\\tilde{A} = A + I$, is:\n$$\n\\tilde{A} = A + I_4 = \\begin{pmatrix}\n1 & 1 & 0 & 0 \\\\\n1 & 1 & 1 & 0 \\\\\n0 & 1 & 1 & 1 \\\\\n0 & 0 & 1 & 1\n\\end{pmatrix}\n$$\nThe diagonal degree matrix $\\tilde{D}$ is formed from the row sums of $\\tilde{A}$. The degrees of nodes with self-loops are $\\tilde{d}_1 = 2$, $\\tilde{d}_2 = 3$, $\\tilde{d}_3 = 3$, and $\\tilde{d}_4 = 2$.\n$$\n\\tilde{D} = \\begin{pmatrix}\n2 & 0 & 0 & 0 \\\\\n0 & 3 & 0 & 0 \\\\\n0 & 0 & 3 & 0 \\\\\n0 & 0 & 0 & 2\n\\end{pmatrix}\n$$\n\n**2. Graph Convolutional Network (GCN) Propagation**\n\nThe GCN propagation operator is $\\hat{A} = \\tilde{D}^{-1/2} \\tilde{A} \\tilde{D}^{-1/2}$. Its elements are $\\hat{A}_{ij} = \\tilde{A}_{ij} / \\sqrt{\\tilde{d}_i \\tilde{d}_j}$.\n$$\n\\hat{A} = \\begin{pmatrix}\n1/2 & 1/\\sqrt{6} & 0 & 0 \\\\\n1/\\sqrt{6} & 1/3 & 1/3 & 0 \\\\\n0 & 1/3 & 1/3 & 1/\\sqrt{6} \\\\\n0 & 0 & 1/\\sqrt{6} & 1/2\n\\end{pmatrix}\n$$\nTwo layers of propagation result in the operator $M_{\\mathrm{GCN}} = \\hat{A}^2$. The propagated angles are $\\theta^{(2)}_{\\mathrm{GCN}} = M_{\\mathrm{GCN}} \\theta^{(0)}$. The contrast $C_{\\mathrm{GCN}} = |\\theta^{(2)}_{\\mathrm{GCN},4} - \\theta^{(2)}_{\\mathrm{GCN},1}|$ depends on the first and fourth rows of $M_{\\mathrm{GCN}}$. Let $M_{\\mathrm{GCN},i}$ be the $i$-th row of $M_{\\mathrm{GCN}}$.\n$M_{\\mathrm{GCN},1} = [5/12, 5/(6\\sqrt{6}), 1/(3\\sqrt{6}), 0]$\n$M_{\\mathrm{GCN},4} = [0, 1/(3\\sqrt{6}), 5/(6\\sqrt{6}), 5/12]$\nThe difference vector $v = M_{\\mathrm{GCN},4} - M_{\\mathrm{GCN},1}$ is:\n$$\nv = [-5/12, -1/(2\\sqrt{6}), 1/(2\\sqrt{6}), 5/12]\n$$\nSo, the GCN contrast is $C_{\\mathrm{GCN}} = |v \\cdot \\theta^{(0)}| = |(5/12)(\\theta^{(0)}_4 - \\theta^{(0)}_1) + (1/(2\\sqrt{6}))(\\theta^{(0)}_3 - \\theta^{(0)}_2)|$.\n\n**3. GraphSAGE Propagation**\n\nThe GraphSAGE propagation operator (with mean aggregation) is $P = \\tilde{D}^{-1} \\tilde{A}$. Its elements are $P_{ij} = \\tilde{A}_{ij} / \\tilde{d}_i$.\n$$\nP = \\begin{pmatrix}\n1/2 & 1/2 & 0 & 0 \\\\\n1/3 & 1/3 & 1/3 & 0 \\\\\n0 & 1/3 & 1/3 & 1/3 \\\\\n0 & 0 & 1/2 & 1/2\n\\end{pmatrix}\n$$\nTwo layers of propagation result in $M_{\\mathrm{SAGE}} = P^2$. The propagated angles are $\\theta^{(2)}_{\\mathrm{SAGE}} = M_{\\mathrm{SAGE}} \\theta^{(0)}$. The contrast $C_{\\mathrm{SAGE}} = |\\theta^{(2)}_{\\mathrm{SAGE},4} - \\theta^{(2)}_{\\mathrm{SAGE},1}|$ depends on the first and fourth rows of $M_{\\mathrm{SAGE}}$. Let $M_{\\mathrm{SAGE},i}$ be the $i$-th row of $M_{\\mathrm{SAGE}}$.\n$M_{\\mathrm{SAGE},1} = [5/12, 5/12, 1/6, 0]$\n$M_{\\mathrm{SAGE},4} = [0, 1/6, 5/12, 5/12]$\nThe difference vector $w = M_{\\mathrm{SAGE},4} - M_{\\mathrm{SAGE},1}$ is:\n$$\nw = [-5/12, -1/4, 1/4, 5/12]\n$$\nSo, the GraphSAGE contrast is $C_{\\mathrm{SAGE}} = |w \\cdot \\theta^{(0)}| = |(5/12)(\\theta^{(0)}_4 - \\theta^{(0)}_1) + (1/4)(\\theta^{(0)}_3 - \\theta^{(0)}_2)|$.\n\n**4. Calculation of Degradation Ratios**\n\nFor each test case $\\theta^{(0)}$, we calculate $C_0 = |\\theta^{(0)}_4 - \\theta^{(0)}_1|$, $C_{\\mathrm{GCN}}$, and $C_{\\mathrm{SAGE}}$. The ratios are $r = C / C_0$ (or $0$ if $C_0=0$).\n\n- **Test 1:** $\\theta^{(0)} = [0.0, 0.2, 0.6, 1.4]$\n$C_0 = |1.4 - 0.0| = 1.4$.\n$\\theta^{(0)}_4 - \\theta^{(0)}_1 = 1.4$. $\\theta^{(0)}_3 - \\theta^{(0)}_2 = 0.4$.\n$C_{\\mathrm{GCN}} = |(5/12)(1.4) + (1/(2\\sqrt{6}))(0.4)| \\approx |0.58333 + 0.08165| \\approx 0.66498$.\n$r_{\\mathrm{GCN}} = 0.66498 / 1.4 \\approx 0.474988$.\n$C_{\\mathrm{SAGE}} = |(5/12)(1.4) + (1/4)(0.4)| = |7/12 + 1/10| = 41/60 \\approx 0.68333$.\n$r_{\\mathrm{SAGE}} = (41/60) / 1.4 = 41/84 \\approx 0.488095$.\n\n- **Test 2:** $\\theta^{(0)} = [0.5, 0.5, 0.5, 0.5]$\n$C_0 = |0.5 - 0.5| = 0$.\nPer the problem definition, $r_{\\mathrm{GCN}} = 0.0$ and $r_{\\mathrm{SAGE}} = 0.0$.\n\n- **Test 3:** $\\theta^{(0)} = [1.2, 0.0, 0.0, -1.2]$\n$C_0 = |-1.2 - 1.2| = 2.4$.\n$\\theta^{(0)}_4 - \\theta^{(0)}_1 = -2.4$. $\\theta^{(0)}_3 - \\theta^{(0)}_2 = 0.0$.\n$C_{\\mathrm{GCN}} = |(5/12)(-2.4) + 0| = |-1.0| = 1.0$.\n$r_{\\mathrm{GCN}} = 1.0 / 2.4 = 5/12 \\approx 0.416667$.\n$C_{\\mathrm{SAGE}} = |(5/12)(-2.4) + 0| = |-1.0| = 1.0$.\n$r_{\\mathrm{SAGE}} = 1.0 / 2.4 = 5/12 \\approx 0.416667$.\n\n- **Test 4:** $\\theta^{(0)} = [0.0, 0.0, 0.0, 1.0]$\n$C_0 = |1.0 - 0.0| = 1.0$.\n$\\theta^{(0)}_4 - \\theta^{(0)}_1 = 1.0$. $\\theta^{(0)}_3 - \\theta^{(0)}_2 = 0.0$.\n$C_{\\mathrm{GCN}} = |(5/12)(1.0) + 0| = 5/12$.\n$r_{\\mathrm{GCN}} = (5/12) / 1.0 = 5/12 \\approx 0.416667$.\n$C_{\\mathrm{SAGE}} = |(5/12)(1.0) + 0| = 5/12$.\n$r_{\\mathrm{SAGE}} = (5/12) / 1.0 = 5/12 \\approx 0.416667$.\n\nThese calculations demonstrate the smoothing effect of GNN layers, which reduces the end-to-end signal contrast. The magnitude of this effect depends on both the GNN architecture and the initial feature distribution.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes GCN and GraphSAGE contrast degradation ratios for a 4-bus path graph.\n    \"\"\"\n    \n    # 1. Define the graph structure and matrices\n    # Adjacency matrix for path graph 1-2-3-4\n    A = np.array([\n        [0, 1, 0, 0],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [0, 0, 1, 0]\n    ])\n    \n    # Adjacency matrix with self-loops\n    A_tilde = A + np.identity(4)\n    \n    # Degree vector and matrix for A_tilde\n    d_tilde_vec = A_tilde.sum(axis=1)\n    D_tilde_inv = np.diag(1.0 / d_tilde_vec)\n    \n    # 2. Construct GCN propagation operator\n    D_tilde_inv_sqrt = np.diag(1.0 / np.sqrt(d_tilde_vec))\n    # Symmetric normalization: A_hat = D_tilde^(-1/2) * A_tilde * D_tilde^(-1/2)\n    A_hat = D_tilde_inv_sqrt @ A_tilde @ D_tilde_inv_sqrt\n    # Two-layer propagation matrix for GCN\n    M_gcn = A_hat @ A_hat\n    \n    # 3. Construct GraphSAGE propagation operator\n    # Row normalization: P = D_tilde^(-1) * A_tilde\n    P = D_tilde_inv @ A_tilde\n    # Two-layer propagation matrix for GraphSAGE\n    M_sage = P @ P\n\n    # 4. Define test cases\n    test_cases = [\n        np.array([0.0, 0.2, 0.6, 1.4]),\n        np.array([0.5, 0.5, 0.5, 0.5]),\n        np.array([1.2, 0.0, 0.0, -1.2]),\n        np.array([0.0, 0.0, 0.0, 1.0])\n    ]\n    \n    results = []\n    \n    # 5. Process each test case\n    for theta_0 in test_cases:\n        # Calculate initial contrast C_0 between bus 4 and bus 1 (0-indexed: 3 and 0)\n        c0 = np.abs(theta_0[3] - theta_0[0])\n        \n        # Handle the case where initial contrast is zero\n        if np.isclose(c0, 0.0):\n            r_gcn = 0.0\n            r_sage = 0.0\n        else:\n            # Propagate features for two layers\n            theta_2_gcn = M_gcn @ theta_0\n            theta_2_sage = M_sage @ theta_0\n            \n            # Calculate post-propagation contrasts\n            c_gcn = np.abs(theta_2_gcn[3] - theta_2_gcn[0])\n            c_sage = np.abs(theta_2_sage[3] - theta_2_sage[0])\n            \n            # Calculate contrast degradation ratios\n            r_gcn = c_gcn / c0\n            r_sage = c_sage / c0\n            \n        results.extend([r_gcn, r_sage])\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}