{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any transactive energy market lies in its settlement rules, which dictate how money flows between participants. This first practice grounds our exploration in this fundamental mechanism by examining a common two-settlement system. By calculating the net cashflow for a prosumer based on their scheduled and actual energy delivery, you will gain a concrete understanding of how price signals and deviation penalties work in concert to ensure market efficiency and grid stability .",
            "id": "4111212",
            "problem": "Consider a peer-to-peer (P2P) transactive energy market operated over a single settlement interval of duration sufficiently short that energy is measured and settled in kilowatt-hours. A prosumer is a participant that can both consume and produce energy. Assume the following context and definitions forming the fundamental basis for the settlement design.\n\n- In a competitive market with many small participants, under standard welfare maximization with convex costs and feasibility constraints, the uniform clearing price equals the marginal social cost at the welfare optimum. Denote this uniform clearing price as $p$, applied to scheduled bilateral trades cleared by the market platform.\n- The platform employs a two-step settlement: ex-ante schedule clearing at the uniform price, followed by ex-post balancing. Ex-post balancing reflects system-level corrective actions to reconcile actual injections and withdrawals with cleared schedules and is charged via a deviation penalty. Denote the absolute energy deviation as $|E^{\\mathrm{act}} - E^{\\mathrm{sch}}|$, where $E^{\\mathrm{sch}}$ is the prosumer’s cleared net injection schedule and $E^{\\mathrm{act}}$ is the prosumer’s measured actual net injection in the interval. Deviations are charged at a linear rate $\\pi$ that represents the shadow price of balancing resources and is applied per unit of absolute deviation.\n- The sign convention is that net injection into the market is positive energy supplied and net withdrawal is negative energy consumed. The platform remunerates scheduled net injections at the uniform clearing price. Deviations are not remunerated at the uniform price and incur only the balancing penalty charge.\n\nA specific prosumer clears a scheduled net injection of $E^{\\mathrm{sch}} = 5\\,\\mathrm{kWh}$ and actually injects $E^{\\mathrm{act}} = 6\\,\\mathrm{kWh}$ during the interval. The uniform clearing price is $p = \\$0.20/\\mathrm{kWh}$, and the balancing penalty rate is $\\pi = \\$0.05/\\mathrm{kWh}$. Under the settlement design described above, determine the prosumer’s net settlement cashflow (revenues minus charges) for the interval.\n\nExpress your final answer in United States dollars and round to four significant figures.",
            "solution": "The user wants me to solve the problem by following the specified process.\n\n### Step 1: Extract Givens\n- Market: Peer-to-peer (P2P) transactive energy market.\n- Settlement Interval: Single, duration is short. Energy is measured in kilowatt-hours (kWh).\n- Uniform Clearing Price: $p$, equals marginal social cost.\n- Settlement Mechanism: Two-step: ex-ante schedule clearing at price $p$, followed by ex-post balancing.\n- Deviation Penalty: A linear rate $\\pi$ per unit of absolute energy deviation.\n- Absolute Energy Deviation: $|E^{\\mathrm{act}} - E^{\\mathrm{sch}}|$.\n- $E^{\\mathrm{sch}}$: Prosumer's cleared net injection schedule.\n- $E^{\\mathrm{act}}$: Prosumer's measured actual net injection.\n- Sign Convention: Net injection is positive, net withdrawal is negative.\n- Remuneration Rule: Scheduled net injections are remunerated at the uniform clearing price $p$.\n- Deviation Settlement Rule: Deviations are not remunerated at the uniform price and incur only the balancing penalty charge.\n- Prosumer's Scheduled Net Injection: $E^{\\mathrm{sch}} = 5\\,\\mathrm{kWh}$.\n- Prosumer's Actual Net Injection: $E^{\\mathrm{act}} = 6\\,\\mathrm{kWh}$.\n- Uniform Clearing Price Value: $p = \\$0.20/\\mathrm{kWh}$.\n- Balancing Penalty Rate Value: $\\pi = \\$0.05/\\mathrm{kWh}$.\n- Objective: Determine the prosumer's net settlement cashflow.\n- Final Answer Requirement: Express in United States dollars, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem describes a simplified but standard model for a two-settlement electricity market. Concepts such as a uniform clearing price, scheduled (ex-ante) markets, real-time (ex-post) balancing, and deviation penalties are fundamental components of modern electricity market design. The model is based on established microeconomic and energy system principles. The problem is scientifically sound.\n- **Well-Posed**: All necessary parameters ($E^{\\mathrm{sch}}$, $E^{\\mathrm{act}}$, $p$, $\\pi$) are defined and have been assigned specific numerical values. The rules for calculating revenues and charges are stated explicitly and unambiguously. A unique, meaningful solution for the net cashflow exists.\n- **Objective**: The problem is formulated in precise, technical language, free from subjectivity or opinion.\n- **Incomplete or Contradictory Setup**: The problem is self-contained. It provides all necessary data and consistently defines all settlement rules. For example, it is explicit that \"Deviations are not remunerated at the uniform price,\" which is a critical and non-contradictory rule.\n- **Unrealistic or Infeasible**: The provided numerical values for price ($p = \\$0.20/\\mathrm{kWh}$), penalty rate ($\\pi = \\$0.05/\\mathrm{kWh}$), and energy quantities ($5\\,\\mathrm{kWh}$, $6\\,\\mathrm{kWh}$) are plausible for a residential-scale prosumer in a retail or P2P market context over a single settlement interval (e.g., one hour).\n- **Ill-Posed or Poorly Structured**: The problem is clearly structured, defining terms and rules before asking for a calculation. There is no ambiguity.\n- **Pseudo-Profound, Trivial, or Tautological**: The problem requires a careful application of a multi-part settlement formula. While the arithmetic is not complex, the conceptual structure tests the understanding of market settlement rules, which is non-trivial.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, complete, and internally consistent. The solution process may proceed.\n\n### Solution\nThe prosumer's net settlement cashflow, denoted as $C_{\\text{net}}$, is the total revenue received from the market minus the total charges paid to the market. We must determine each of these components based on the rules provided.\n\n$1$. **Revenue Calculation**:\nThe problem states, \"The platform remunerates scheduled net injections at the uniform clearing price.\" This means the revenue is calculated based on the *scheduled* energy, $E^{\\mathrm{sch}}$, not the *actual* energy delivered. The revenue, $R$, is given by the product of the scheduled net injection and the uniform clearing price $p$.\n$$R = p \\cdot E^{\\mathrm{sch}}$$\nThe problem also explicitly clarifies that \"Deviations are not remunerated at the uniform price.\" This confirms that the additional energy injected beyond the schedule, $E^{\\mathrm{act}} - E^{\\mathrm{sch}}$, does not generate revenue at the price $p$.\n\n$2$. **Charges Calculation**:\nThe problem states, \"Deviations are charged at a linear rate $\\pi$ ... applied per unit of absolute deviation.\" The charge, which is a penalty for deviation, $C_{\\text{penalty}}$, is calculated as the product of the penalty rate $\\pi$ and the absolute value of the energy deviation.\nThe energy deviation is the difference between the actual and scheduled net injection, $E^{\\mathrm{act}} - E^{\\mathrm{sch}}$.\nThe absolute energy deviation is $|E^{\\mathrm{act}} - E^{\\mathrm{sch}}|$.\nTherefore, the penalty charge is:\n$$C_{\\text{penalty}} = \\pi \\cdot |E^{\\mathrm{act}} - E^{\\mathrm{sch}}|$$\n\n$3$. **Net Cashflow Calculation**:\nThe net settlement cashflow is the revenue minus the penalty charge.\n$$C_{\\text{net}} = R - C_{\\text{penalty}} = p \\cdot E^{\\mathrm{sch}} - \\pi \\cdot |E^{\\mathrm{act}} - E^{\\mathrm{sch}}|$$\nWe are given the following values:\n- Scheduled net injection: $E^{\\mathrm{sch}} = 5\\,\\mathrm{kWh}$\n- Actual net injection: $E^{\\mathrm{act}} = 6\\,\\mathrm{kWh}$\n- Uniform clearing price: $p = 0.20\\,\\$/\\mathrm{kWh}$\n- Balancing penalty rate: $\\pi = 0.05\\,\\$/\\mathrm{kWh}$\n\nFirst, we calculate the revenue component:\n$$R = (0.20\\,\\$/\\mathrm{kWh}) \\cdot (5\\,\\mathrm{kWh}) = \\$1.00$$\nNext, we calculate the absolute deviation:\n$$|E^{\\mathrm{act}} - E^{\\mathrm{sch}}| = |6\\,\\mathrm{kWh} - 5\\,\\mathrm{kWh}| = |1\\,\\mathrm{kWh}| = 1\\,\\mathrm{kWh}$$\nThen, we calculate the penalty charge component:\n$$C_{\\text{penalty}} = (0.05\\,\\$/\\mathrm{kWh}) \\cdot (1\\,\\mathrm{kWh}) = \\$0.05$$\nFinally, we compute the net cashflow:\n$$C_{\\text{net}} = R - C_{\\text{penalty}} = \\$1.00 - \\$0.05 = \\$0.95$$\nThe problem requires the final answer to be rounded to four significant figures. The calculated value is $0.95$. To express this with four significant figures, we add trailing zeros.\n$$C_{\\text{net}} = 0.9500$$\nThe final answer is in United States dollars.",
            "answer": "$$\n\\boxed{0.9500}\n$$"
        },
        {
            "introduction": "Having established the market rules, we now turn to modeling the behavior of a rational agent operating within this environment. This practice challenges you to solve a classic temporal arbitrage problem for a prosumer with battery storage, a core application in transactive energy systems. By formulating and solving this as a linear program, you will develop skills in optimal control and understand how agents can leverage price volatility to maximize profit while providing flexibility to the grid .",
            "id": "4111176",
            "problem": "Consider a single prosumer agent in a peer-to-peer (P2P) transactive energy market who operates an idealized battery to arbitrage temporal price differences. The agent participates in a sequence of $T$ settlement intervals indexed by $t \\in \\{1,\\dots,T\\}$. At each interval $t$, the market-clearing price is $p_t$ dollars per megawatt-hour ($/MWh$), the agent can buy energy from peers (charge the battery) at the price $p_t$, or sell energy to peers (discharge the battery) at the same price $p_t$. The battery has one-way charging efficiency $\\eta_c \\in (0,1]$ and one-way discharging efficiency $\\eta_d \\in (0,1]$, energy capacity $S_{\\max}$ in megawatt-hours (MWh), initial state of charge $s_0$ in MWh, and a target terminal state of charge $s_T^{\\text{target}}$ in MWh. Let $c_t \\ge 0$ be the market energy bought to charge the battery at time $t$ (in MWh) and $d_t \\ge 0$ be the market energy sold from discharging the battery at time $t$ (in MWh). The state of charge is $s_t$ in MWh at the end of interval $t$.\n\nFundamental basis:\n- Energy conservation and efficiency: Charging $c_t$ increases stored energy by $\\eta_c c_t$, and discharging $d_t$ decreases stored energy by $d_t/\\eta_d$.\n- Market settlement: Buying $c_t$ pays $p_t c_t$ and selling $d_t$ earns $p_t d_t$.\n\nDecision variables are the sequences $(c_t)_{t=1}^T$, $(d_t)_{t=1}^T$, and $(s_t)_{t=1}^T$ obeying the following constraints derived from these foundations:\n- State transition for all $t \\in \\{1,\\dots,T\\}$: $s_t = s_{t-1} + \\eta_c c_t - \\dfrac{d_t}{\\eta_d}$, with $s_0$ given.\n- Energy capacity bounds for all $t$: $0 \\le s_t \\le S_{\\max}$.\n- Non-negativity and per-interval physical feasibility bounds for all $t$: $0 \\le c_t \\le \\dfrac{S_{\\max}}{\\eta_c}$ and $0 \\le d_t \\le \\eta_d S_{\\max}$.\n- Terminal state target: $s_T = s_T^{\\text{target}}$.\n\nThe agent's objective is to maximize the cumulative arbitrage profit $\\sum_{t=1}^T p_t(d_t - c_t)$ subject to these constraints. This is a linear program in $(c_t,d_t,s_t)$ that can be solved exactly and efficiently.\n\nYour task is to implement a program that, for each test case, computes optimal sequences $(c_t)_{t=1}^T$ and $(d_t)_{t=1}^T$ that maximize the arbitrage profit under the constraints. Report all $c_t$ and $d_t$ values in MWh.\n\nTest suite:\n1. Baseline multi-peak case: $T=4$, prices $p=[20,40,10,30]$ $/MWh$, $\\eta_c=0.95$, $\\eta_d=0.90$, $S_{\\max}=1$ MWh, $s_0=0$ MWh, $s_T^{\\text{target}}=0$ MWh.\n2. Flat-price no-arbitrage case: $T=4$, prices $p=[25,25,25,25]$ $/MWh$, $\\eta_c=0.95$, $\\eta_d=0.90$, $S_{\\max}=1$ MWh, $s_0=0$ MWh, $s_T^{\\text{target}}=0$ MWh.\n3. Capacity-constrained case: $T=4$, prices $p=[20,40,10,30]$ $/MWh$, $\\eta_c=0.95$, $\\eta_d=0.90$, $S_{\\max}=0.5$ MWh, $s_0=0$ MWh, $s_T^{\\text{target}}=0$ MWh.\n4. Decreasing-price with terminal fullness: $T=4$, prices $p=[30,20,15,10]$ $/MWh$, $\\eta_c=0.95$, $\\eta_d=0.90$, $S_{\\max}=1$ MWh, $s_0=1$ MWh, $s_T^{\\text{target}}=1$ MWh.\n5. Perfect-efficiency benchmark: $T=3$, prices $p=[10,50,20]$ $/MWh$, $\\eta_c=1.0$, $\\eta_d=1.0$, $S_{\\max}=1$ MWh, $s_0=0$ MWh, $s_T^{\\text{target}}=0$ MWh.\n\nOutput format:\n- For each test case, return a pair of lists $[c_1,\\dots,c_T]$ and $[d_1,\\dots,d_T]$, both expressed in MWh as decimal floats.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to one test case and is itself a list structured as $[[c_1,\\dots,c_T],[d_1,\\dots,d_T]]$.\n- Round each reported float to six decimal places.",
            "solution": "The user's problem is a well-posed optimization task grounded in the principles of energy systems modeling, specifically battery arbitrage in a transactive energy market. The problem is to determine the optimal charging and discharging schedule for a battery to maximize profit, given a series of electricity prices and the battery's physical constraints. This can be formulated and solved as a Linear Program (LP).\n\nThe objective is to maximize the total profit, which is the sum of revenues from selling energy minus the costs of buying energy over the time horizon $T$. The profit function is:\n$$ \\text{Maximize} \\quad \\Pi = \\sum_{t=1}^{T} p_t (d_t - c_t) $$\nwhere $p_t$ is the price at time $t$, $d_t$ is the energy sold (discharged), and $c_t$ is the energy bought (charged).\n\nThis maximization is subject to several linear constraints:\n1.  State of Charge (SOC) transition: The energy stored at the end of interval $t$, $s_t$, is determined by the energy stored at the previous interval, $s_{t-1}$, and the energy charged or discharged, adjusted for efficiencies.\n    $$ s_t = s_{t-1} + \\eta_c c_t - \\frac{d_t}{\\eta_d} \\quad \\text{for } t \\in \\{1, \\dots, T\\} $$\n    with $s_0$ being the given initial state of charge.\n\n2.  Capacity limits: The state of charge must remain within the physical capacity of the battery.\n    $$ 0 \\le s_t \\le S_{\\max} \\quad \\text{for } t \\in \\{1, \\dots, T\\} $$\n\n3.  Non-negativity: Energy cannot be \"uncharged\" or \"undischarged\".\n    $$ c_t \\ge 0, \\quad d_t \\ge 0 \\quad \\text{for } t \\in \\{1, \\dots, T\\} $$\n\n4.  Terminal state: The state of charge at the end of the horizon must meet a specific target.\n    $$ s_T = s_T^{\\text{target}} $$\n\nThe problem is a linear program because both the objective function and all constraints are linear functions of the decision variables $(c_t)_{t=1}^T$, $(d_t)_{t=1}^T$, and $(s_t)_{t=1}^T$. We can solve this using a standard LP solver, such as `scipy.optimize.linprog`.\n\nTo use the solver, we first formulate the problem in its standard form:\n$$ \\min_{\\mathbf{x}} \\mathbf{c}_{\\text{LP}}^T \\mathbf{x} \\quad \\text{subject to} \\quad \\mathbf{A}_{\\text{eq}} \\mathbf{x} = \\mathbf{b}_{\\text{eq}} \\quad \\text{and} \\quad \\mathbf{l} \\le \\mathbf{x} \\le \\mathbf{u} $$\n\n1.  **Decision Vector $\\mathbf{x}$**: The decision variables are concatenated into a single vector $\\mathbf{x}$ of size $3T$:\n    $$ \\mathbf{x} = [c_1, \\dots, c_T, d_1, \\dots, d_T, s_1, \\dots, s_T]^T $$\n\n2.  **Objective Vector $\\mathbf{c}_{\\text{LP}}$**: Since `scipy.optimize.linprog` performs minimization, we minimize the negative of our profit function: $\\min \\sum_{t=1}^{T} p_t (c_t - d_t)$. The corresponding objective vector $\\mathbf{c}_{\\text{LP}}$ of size $3T$ is:\n    $$ \\mathbf{c}_{\\text{LP}} = [p_1, \\dots, p_T, -p_1, \\dots, -p_T, 0, \\dots, 0]^T $$\n    The final $T$ zeros correspond to the $s_t$ variables, which do not appear in the objective function.\n\n3.  **Equality Constraints $(\\mathbf{A}_{\\text{eq}}, \\mathbf{b}_{\\text{eq}})$**: The state transition equations form the set of equality constraints. We can rewrite them as:\n    $$ -\\eta_c c_t + \\frac{1}{\\eta_d} d_t + s_t - s_{t-1} = 0 \\quad \\text{for } t > 1 $$\n    $$ -\\eta_c c_1 + \\frac{1}{\\eta_d} d_1 + s_1 = s_0 \\quad \\text{for } t = 1 $$\n    These $T$ equations form a $T \\times 3T$ matrix $\\mathbf{A}_{\\text{eq}}$ and a vector $\\mathbf{b}_{\\text{eq}}$ of size $T$. For each row $i$ (from $0$ to $T-1$, corresponding to time $t=i+1$), the non-zero entries of $\\mathbf{A}_{\\text{eq}}$ capture the coefficients of $c_{i+1}$, $d_{i+1}$, $s_{i+1}$, and $s_i$. The vector $\\mathbf{b}_{\\text{eq}}$ is $[s_0, 0, \\dots, 0]^T$.\n\n4.  **Bounds $(\\mathbf{l}, \\mathbf{u})$**: The bounds for each variable in $\\mathbf{x}$ are derived from the problem constraints.\n    - For charge variables: $0 \\le c_t \\le S_{\\max} / \\eta_c$.\n    - For discharge variables: $0 \\le d_t \\le S_{\\max} \\cdot \\eta_d$.\n    - For state of charge variables: $0 \\le s_t \\le S_{\\max}$ for $t \\in \\{1, \\dots, T-1\\}$.\n    - For the terminal state of charge, the constraint $s_T = s_T^{\\text{target}}$ is enforced by setting its lower and upper bounds to be equal: $s_T^{\\text{target}} \\le s_T \\le s_T^{\\text{target}}$.\n\nBy constructing these matrices and vectors, the LP solver can find the optimal vector $\\mathbf{x}^*$, from which we extract the optimal charging sequence $(c_t^*)_{t=1}^T$ and discharging sequence $(d_t^*)_{t=1}^T$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the battery arbitrage problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # 1. Baseline multi-peak case\n        {\n            \"T\": 4,\n            \"p\": np.array([20, 40, 10, 30]),\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.90,\n            \"S_max\": 1.0,\n            \"s_0\": 0.0,\n            \"s_T_target\": 0.0,\n        },\n        # 2. Flat-price no-arbitrage case\n        {\n            \"T\": 4,\n            \"p\": np.array([25, 25, 25, 25]),\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.90,\n            \"S_max\": 1.0,\n            \"s_0\": 0.0,\n            \"s_T_target\": 0.0,\n        },\n        # 3. Capacity-constrained case\n        {\n            \"T\": 4,\n            \"p\": np.array([20, 40, 10, 30]),\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.90,\n            \"S_max\": 0.5,\n            \"s_0\": 0.0,\n            \"s_T_target\": 0.0,\n        },\n        # 4. Decreasing-price with terminal fullness\n        {\n            \"T\": 4,\n            \"p\": np.array([30, 20, 15, 10]),\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.90,\n            \"S_max\": 1.0,\n            \"s_0\": 1.0,\n            \"s_T_target\": 1.0,\n        },\n        # 5. Perfect-efficiency benchmark\n        {\n            \"T\": 3,\n            \"p\": np.array([10, 50, 20]),\n            \"eta_c\": 1.0,\n            \"eta_d\": 1.0,\n            \"S_max\": 1.0,\n            \"s_0\": 0.0,\n            \"s_T_target\": 0.0,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        c_opt, d_opt = calculate_arbitrage(**params)\n        c_opt_rounded = np.round(c_opt, 6).tolist()\n        d_opt_rounded = np.round(d_opt, 6).tolist()\n        results.append([c_opt_rounded, d_opt_rounded])\n    \n    # Format the output string manually to match the required format precisely.\n    # The str() representation of a list in Python matches the required format.\n    result_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(result_str)\n\ndef calculate_arbitrage(T, p, eta_c, eta_d, S_max, s_0, s_T_target):\n    \"\"\"\n    Solves the battery arbitrage linear programming problem for a single case.\n    \n    Decision vector x is structured as [c_1,...,c_T, d_1,...,d_T, s_1,...,s_T].\n    \"\"\"\n    # Total number of decision variables\n    num_vars = 3 * T\n\n    # 1. Objective function: min(p*c - p*d)\n    # The objective is to minimize the negative profit.\n    c_lp = np.concatenate([p, -p, np.zeros(T)])\n\n    # 2. Equality constraints: s_t = s_{t-1} + eta_c*c_t - d_t/eta_d\n    A_eq = np.zeros((T, num_vars))\n    b_eq = np.zeros(T)\n    b_eq[0] = s_0\n\n    for t in range(T):\n        # Coefficient for c_t\n        A_eq[t, t] = -eta_c\n        # Coefficient for d_t\n        A_eq[t, T + t] = 1.0 / eta_d\n        # Coefficient for s_t\n        A_eq[t, 2 * T + t] = 1.0\n        # Coefficient for s_{t-1}\n        if t > 0:\n            A_eq[t, 2 * T + t - 1] = -1.0\n\n    # 3. Bounds for decision variables\n    bounds = []\n    # Bounds for c_t: 0 <= c_t <= S_max / eta_c\n    bounds.extend([(0, S_max / eta_c) for _ in range(T)])\n    # Bounds for d_t: 0 <= d_t <= S_max * eta_d\n    bounds.extend([(0, S_max * eta_d) for _ in range(T)])\n    # Bounds for s_t: 0 <= s_t <= S_max\n    bounds.extend([(0, S_max) for _ in range(T - 1)])\n    # Bounds for s_T: s_T = s_T_target\n    bounds.append((s_T_target, s_T_target))\n\n    # 4. Solve the linear program\n    res = linprog(c=c_lp, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if not res.success:\n        # Handle cases where the solver fails, though not expected for these problems.\n        # Fallback to zeros if no solution is found.\n        return np.zeros(T), np.zeros(T)\n\n    # Extract optimal c and d\n    x_opt = res.x\n    c_opt = x_opt[0:T]\n    d_opt = x_opt[T:2*T]\n\n    # Clean up very small values that are effectively zero\n    c_opt[np.abs(c_opt) < 1e-9] = 0\n    d_opt[np.abs(d_opt) < 1e-9] = 0\n    \n    return c_opt, d_opt\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Our final practice moves beyond the single 'price-taker' agent to a more complex scenario involving strategic interaction between multiple participants. In many peer-to-peer markets, an individual's supply decision can influence the market price, leading to game-theoretic dynamics. This exercise applies the Cournot duopoly model to two competing prosumers, requiring you to derive best-response functions and numerically compute the Nash Equilibrium, offering insight into how market outcomes emerge from strategic behavior .",
            "id": "4111166",
            "problem": "Consider a single-interval Peer-to-Peer (P2P) transactive energy market with two prosumers. Each prosumer chooses a quantity to supply, denoted by $q_1$ and $q_2$, measured in megawatt-hours (MWh). The aggregate market quantity is $Q = q_1 + q_2$. The inverse demand is linear, given by $p(Q) = a - Q$, where $p$ is the market-clearing price in dollars per megawatt-hour ($/MWh$), and $a > 0$ is the demand intercept parameter. Prosumers incur convex quadratic costs $C_1(q_1) = c_1 q_1^2$ and $C_2(q_2) = c_2 q_2^2$, expressed in dollars ($). Each prosumer selects its quantity simultaneously to maximize its own profit, with profit function $\\pi_i(q_i, q_j) = p(Q)\\,q_i - C_i(q_i)$ for $i \\in \\{1,2\\}$ and $j \\neq i$. The Nash Equilibrium (NE) is a profile $(q_1^\\star, q_2^\\star)$ such that both prosumers' choices are mutual best responses.\n\nStarting from the fundamental definitions of profit maximization and the Nash Equilibrium (NE), derive the first-order optimality conditions that characterize each prosumer’s best-response quantity as a function of the other’s quantity. Then, implement a numerical fixed-point method to compute the NE by iterating best responses until convergence. Enforce nonnegativity constraints $q_1 \\ge 0$, $q_2 \\ge 0$ and $p \\ge 0$ to ensure physical realism.\n\nYour program must, for each test case below, compute:\n- the equilibrium quantities $q_1^\\star$ and $q_2^\\star$ in MWh,\n- the equilibrium price $p^\\star$ in $/MWh$,\n- the equilibrium profits $\\pi_1^\\star$ and $\\pi_2^\\star$ in dollars ($).\n\nExpress all outputs in the specified units and round each reported numerical value to three decimal places.\n\nTest suite (each case is $(a, c_1, c_2)$):\n1. $(10, 1, 2)$\n2. $(10, 1, 1)$\n3. $(12, 0.5, 3)$\n4. $(1, 4, 5)$\n\nFinal output format:\nYour program should produce a single line of output containing a comma-separated list of the results for all test cases, where each test case’s result is a list of five floats $[q_1^\\star,q_2^\\star,p^\\star,\\pi_1^\\star,\\pi_2^\\star]$ rounded to three decimals, and the overall line is enclosed in square brackets. For example, the output must look like:\n$[\\,[q_{1,1},q_{2,1},p_1,\\pi_{1,1},\\pi_{2,1}],\\,[q_{1,2},q_{2,2},p_2,\\pi_{1,2},\\pi_{2,2}],\\,\\ldots\\,]$",
            "solution": "The user-provided problem is a valid, well-posed problem in microeconomic theory, specifically a Cournot duopoly model applied to a transactive energy market. All parameters are clearly defined, and the objective is mathematically sound. We proceed to the solution.\n\nThe problem asks for the Nash Equilibrium (NE) of a single-interval energy market with two prosumers. The equilibrium is found by identifying a quantity profile $(q_1^\\star, q_2^\\star)$ where each prosumer's chosen quantity is a best response to the other's, meaning it maximizes their own profit given the other's choice.\n\nThe market is defined by the following components:\n- Prosumer quantities: $q_1, q_2$ in MWh.\n- Aggregate quantity: $Q = q_1 + q_2$.\n- Inverse demand function (price): $p(Q) = a - Q$, with $a > 0$.\n- Prosumer cost functions: $C_1(q_1) = c_1 q_1^2$ and $C_2(q_2) = c_2 q_2^2$.\n- Prosumer profit functions: $\\pi_i(q_i, q_j) = p(Q)q_i - C_i(q_i)$ for $i,j \\in \\{1,2\\}$ and $i \\neq j$.\n\nWe must also enforce the non-negativity constraints $q_1 \\ge 0$, $q_2 \\ge 0$, and ensure the resulting price is non-negative, $p \\ge 0$.\n\n### Derivation of Best-Response Functions\n\nTo find the Nash Equilibrium, we first derive each prosumer's best-response function. This function, denoted $BR_i(q_j)$, gives prosumer $i$'s profit-maximizing quantity for any given quantity $q_j$ produced by prosumer $j$.\n\nLet's first analyze prosumer $1$. Its profit function is:\n$$\n\\pi_1(q_1, q_2) = p(q_1 + q_2)q_1 - C_1(q_1)\n$$\nSubstituting the given functions for price and cost:\n$$\n\\pi_1(q_1, q_2) = (a - (q_1 + q_2))q_1 - c_1 q_1^2\n$$\n$$\n\\pi_1(q_1, q_2) = a q_1 - q_1^2 - q_2 q_1 - c_1 q_1^2\n$$\nTo find the quantity $q_1$ that maximizes this profit, we take the partial derivative of $\\pi_1$ with respect to $q_1$ (treating $q_2$ as a constant) and set it to zero. This is the first-order optimality condition (FOC):\n$$\n\\frac{\\partial \\pi_1}{\\partial q_1} = a - 2q_1 - q_2 - 2c_1 q_1 = 0\n$$\nThe second-order condition confirms this is a maximum, as $\\frac{\\partial^2 \\pi_1}{\\partial q_1^2} = -2 - 2c_1 = -2(1+c_1) < 0$ since cost coefficients are positive.\n\nSolving the FOC for $q_1$:\n$$\na - q_2 = 2q_1 + 2c_1 q_1 = (2 + 2c_1)q_1\n$$\n$$\nq_1 = \\frac{a - q_2}{2(1 + c_1)}\n$$\nThis expression defines the optimal quantity for prosumer $1$ given $q_2$. However, we must respect the physical constraint that quantity cannot be negative, $q_1 \\ge 0$. Therefore, the best-response function for prosumer $1$ is:\n$$\nBR_1(q_2) = \\max\\left(0, \\frac{a - q_2}{2(1 + c_1)}\\right)\n$$\nBy symmetry, the derivation for prosumer $2$ is analogous. The profit function is:\n$$\n\\pi_2(q_1, q_2) = (a - (q_1 + q_2))q_2 - c_2 q_2^2\n$$\nThe FOC with respect to $q_2$ is:\n$$\n\\frac{\\partial \\pi_2}{\\partial q_2} = a - q_1 - 2q_2 - 2c_2 q_2 = 0\n$$\nSolving for $q_2$ and incorporating the non-negativity constraint $q_2 \\ge 0$ yields the best-response function for prosumer $2$:\n$$\nBR_2(q_1) = \\max\\left(0, \\frac{a - q_1}{2(1 + c_2)}\\right)\n$$\n### Nash Equilibrium and Fixed-Point Iteration\n\nA Nash Equilibrium $(q_1^\\star, q_2^\\star)$ is a state where both prosumers are playing their best response simultaneously. Mathematically, it is a fixed point of the best-response functions:\n$$\nq_1^\\star = BR_1(q_2^\\star) \\quad \\text{and} \\quad q_2^\\star = BR_2(q_1^\\star)\n$$\nThe problem requires finding this equilibrium using a numerical fixed-point method. We will use an iterative approach known as best-response dynamics (or Cournot adjustment). The algorithm proceeds as follows:\n1.  Initialize the quantities for both prosumers, for instance, $(q_1^{(0)}, q_2^{(0)}) = (0, 0)$.\n2.  For each iteration $k = 0, 1, 2, \\ldots$, simultaneously update the quantities using the best-response functions:\n    $$\n    q_1^{(k+1)} = BR_1(q_2^{(k)})\n    $$\n    $$\n    q_2^{(k+1)} = BR_2(q_1^{(k)})\n    $$\n3.  Repeat step 2 until the quantities converge. Convergence is achieved when the change between successive iterations falls below a small tolerance, $\\epsilon$. That is, when $\\max(|q_1^{(k+1)} - q_1^{(k)}|, |q_2^{(k+1)} - q_2^{(k)}|) < \\epsilon$.\n\nThis iterative process is guaranteed to converge to the unique Nash Equilibrium for this model because the best-response functions form a contraction mapping under the given conditions.\n\n### Final Calculations\n\nOnce the iterative process converges to the equilibrium quantities $(q_1^\\star, q_2^\\star)$, we can compute the remaining market outcomes:\n-   Equilibrium aggregate quantity: $Q^\\star = q_1^\\star + q_2^\\star$.\n-   Equilibrium price: $p^\\star = a - Q^\\star$. The price will be non-negative as long as $c_1, c_2 \\ge 0$.\n-   Equilibrium profits:\n    $$\n    \\pi_1^\\star = p^\\star q_1^\\star - c_1(q_1^\\star)^2\n    $$\n    $$\n    \\pi_2^\\star = p^\\star q_2^\\star - c_2(q_2^\\star)^2\n    $$\nThe implementation will apply this complete procedure for each test case provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Cournot duopoly problem for the given test cases\n    and print the results in the specified format.\n    \"\"\"\n\n    # Test suite: each tuple is (a, c1, c2)\n    test_cases = [\n        (10, 1, 2),\n        (10, 1, 1),\n        (12, 0.5, 3),\n        (1, 4, 5),\n    ]\n\n    def compute_equilibrium(a, c1, c2, tol=1e-12, max_iter=1000):\n        \"\"\"\n        Computes the Nash Equilibrium using fixed-point iteration of best responses.\n\n        Args:\n            a (float): Demand intercept parameter.\n            c1 (float): Cost coefficient for prosumer 1.\n            c2 (float): Cost coefficient for prosumer 2.\n            tol (float): Convergence tolerance.\n            max_iter (int): Maximum number of iterations.\n\n        Returns:\n            list: A list containing [q1*, q2*, p*, pi1*, pi2*].\n        \"\"\"\n        \n        # Best response function for prosumer 1, given q2\n        def br1(q2_val):\n            numerator = a - q2_val\n            denominator = 2.0 * (1.0 + c1)\n            return max(0.0, numerator / denominator)\n\n        # Best response function for prosumer 2, given q1\n        def br2(q1_val):\n            numerator = a - q1_val\n            denominator = 2.0 * (1.0 + c2)\n            return max(0.0, numerator / denominator)\n\n        # Initial guess for quantities\n        q1, q2 = 0.0, 0.0\n\n        for _ in range(max_iter):\n            q1_old, q2_old = q1, q2\n            \n            # Simultaneous update (Jacobi-style iteration)\n            q1_new = br1(q2_old)\n            q2_new = br2(q1_old)\n\n            q1, q2 = q1_new, q2_new\n            \n            # Check for convergence\n            if max(abs(q1 - q1_old), abs(q2 - q2_old)) < tol:\n                break\n        \n        # At convergence, q1 and q2 are the equilibrium quantities q1_star, q2_star\n        q1_star = q1\n        q2_star = q2\n        \n        # Calculate equilibrium aggregate quantity and price\n        Q_star = q1_star + q2_star\n        p_star = a - Q_star\n        \n        # Calculate equilibrium costs and profits\n        C1_star = c1 * q1_star**2\n        C2_star = c2 * q2_star**2\n        pi1_star = p_star * q1_star - C1_star\n        pi2_star = p_star * q2_star - C2_star\n        \n        return [q1_star, q2_star, p_star, pi1_star, pi2_star]\n\n    all_results = []\n    for case in test_cases:\n        a_param, c1_param, c2_param = case\n        result = compute_equilibrium(a_param, c1_param, c2_param)\n        all_results.append(result)\n\n    # Format the results for the final output string.\n    # Each number is rounded to three decimal places.\n    result_strings = []\n    for res_list in all_results:\n        # Use f-string formatting to ensure rounding and fixed decimal places (e.g., 2.000)\n        formatted_nums = [f\"{val:.3f}\" for val in res_list]\n        result_strings.append(f\"[{','.join(formatted_nums)}]\")\n\n    # Join the string representations of each case's results with a comma.\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}