{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的随机单元组合模型之前，理解我们为什么需要它们至关重要。本练习将通过对比基于平均需求的确定性模型和完整的随机模型，来展示采用随机方法的具体经济价值。你将亲手计算“随机解的价值”（Value of the Stochastic Solution, VSS），这是一个关键指标，它量化了在不确定性下做出稳健决策所带来的好处 。",
            "id": "4104477",
            "problem": "一个两阶段随机机组组合决策问题，源于需要在不确定的净负荷实现之前决策发电机组的启停。其基本原理是在不确定性下的期望成本最小化和线性经济调度，这两者在能源系统建模中都得到了广泛接受。在第一阶段，运营商决策火电机组的启停；在第二阶段，当需求情景实现后，运营商调度已启机组以满足需求，并可能因未满足的负荷而产生惩罚。所有成本均以美元表示。通过假设每个时段的持续时间为1小时，功率和能量的单位保持一致，因此兆瓦（MW）在一个时段内等于兆瓦时（MWh）。\n\n考虑一个由2个火电机组（索引为 $i \\in \\{1,2\\}$）组成的玩具系统，以及一个持续时间为1小时的单一时段。每个机组 $i$ 的特征如下：\n- 最大容量 $P^{\\max}_i$，单位为兆瓦（MW），\n- 线性可变生产成本 $c_i$，单位为美元/兆瓦时，\n- 启动成本 $C^{\\mathrm{su}}_i$，单位为美元，\n- 空载成本 $C^{\\mathrm{nl}}_i$，单位为机组启机期间每时段的美元。\n\n第一阶段决策是在不确定性实现之前做出的，是每个机组的二元启停决策 $u_i \\in \\{0,1\\}$。第二阶段决策是针对每个情景 $s$ 的发电水平 $g_{i,s} \\ge 0$ 和未服务能源 $l_s \\ge 0$（切负荷），其中每兆瓦时的惩罚为 $M$ 美元。情景需求 $D_s$ 的单位为兆瓦时（MWh），情景概率 $p_s$ 满足 $\\sum_s p_s = 1$ 且 $p_s \\ge 0$。\n\n对于每个情景 $s$，调度必须满足\n$$\n\\sum_{i=1}^2 g_{i,s} + l_s = D_s, \\quad 0 \\le g_{i,s} \\le P^{\\max}_i u_i,\n$$\n且每个情景的第二阶段成本为\n$$\n\\sum_{i=1}^2 c_i g_{i,s} + M l_s.\n$$\n第一阶段成本为\n$$\n\\sum_{i=1}^2 \\left(C^{\\mathrm{su}}_i u_i + C^{\\mathrm{nl}}_i u_i\\right).\n$$\n\n随机机组组合（SUC）问题旨在最小化所有可行启停组合下的第一阶段成本与期望第二阶段成本之和。确定性期望值（EV）问题用期望需求\n$$\n\\bar{D} = \\sum_s p_s D_s,\n$$\n替代随机需求，并最小化在 $\\bar{D}$ 下的第一阶段成本与第二阶段可变成本之和，其约束条件是使用已启机组容量精确满足 $\\bar{D}$ 且不发生切负荷。\n\n一旦找到EV启停决策，就会计算在随机情景下评估此固定启停决策的期望成本（允许在补救措施中进行切负荷）；这被称为评估期望值（EEV）。需要计算的量是，对于每个测试用例，使用EV启停决策相对于最优SUC启停决策所增加的期望成本，以美元表示。程序必须：\n- 枚举第一阶段的启停组合。\n- 对于SUC，计算所有启停组合中的最优期望成本。\n- 对于EV，选择能够精确满足 $\\bar{D}$ 并最小化确定性成本的启停组合，然后计算其在随机情景下的期望成本。\n- 对于每个测试用例，输出EEV成本与SUC最优期望成本之间的差额，以美元表示。\n\n机组数据（所有测试用例通用）：\n- 机组1：$P^{\\max}_1 = 100$ MW, $c_1 = 20$ 美元/MWh, $C^{\\mathrm{su}}_1 = 1000$ 美元, $C^{\\mathrm{nl}}_1 = 500$ 美元。\n- 机组2：$P^{\\max}_2 = 50$ MW, $c_2 = 25$ 美元/MWh, $C^{\\mathrm{su}}_2 = 100$ 美元, $C^{\\mathrm{nl}}_2 = 0$ 美元。\n\n测试套件的情景集和惩罚值：\n- 用例1（一般情况）：\n  - 情景：$D_1 = 40$ MWh，概率 $p_1 = 0.6$；$D_2 = 120$ MWh，概率 $p_2 = 0.4$。\n  - 惩罚：$M = 200$ 美元/MWh。\n- 用例2（确定性期望值启停决策与随机最优解重合的边界情况）：\n  - 情景：$D_1 = 40$ MWh，概率 $p_1 = 0.95$；$D_2 = 120$ MWh，概率 $p_2 = 0.05$。\n  - 惩罚：$M = 200$ 美元/MWh。\n- 用例3（未服务能源惩罚较低的极端情况）：\n  - 情景：$D_1 = 40$ MWh，概率 $p_1 = 0.6$；$D_2 = 120$ MWh，概率 $p_2 = 0.4$。\n  - 惩罚：$M = 30$ 美元/MWh。\n\n假设：\n- 每个时段的持续时间为1小时，因此在该时段内1 MW等于1 MWh。\n- 所有机组的初始启停状态均为关闭，因此当机组启动时会产生启动成本。\n- 最小发电量为0 MWh，且无爬坡约束。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3]$，其中 $r_k$ 是为用例 $k$ 计算的评估期望值成本与最优随机机组组合成本之间的差额，以浮点数美元表示。",
            "solution": "### 问题验证\n\n**步骤1：提取已知信息**\n\n- **系统参数**：2个火电机组（$i \\in \\{1,2\\}$），1个持续时间为1小时的时段。\n- **机组1数据**：$P^{\\max}_1 = 100$ MW， $c_1 = 20$ 美元/MWh， $C^{\\mathrm{su}}_1 = 1000$ 美元， $C^{\\mathrm{nl}}_1 = 500$ 美元。\n- **机组2数据**：$P^{\\max}_2 = 50$ MW， $c_2 = 25$ 美元/MWh， $C^{\\mathrm{su}}_2 = 100$ 美元， $C^{\\mathrm{nl}}_2 = 0$ 美元。\n- **第一阶段决策**：每个机组 $i$ 的二元启停变量 $u_i \\in \\{0,1\\}$。\n- **第二阶段决策**：每个情景 $s$ 的发电水平 $g_{i,s} \\ge 0$ 和未服务能源 $l_s \\ge 0$。\n- **惩罚成本**：每兆瓦时未服务能源的惩罚为 $M$ 美元。\n- **情景数据**：情景由需求 $D_s$ (MWh) 和概率 $p_s$ 定义。\n- **模型方程**：\n    - 第一阶段成本：$\\sum_{i=1}^2 (C^{\\mathrm{su}}_i + C^{\\mathrm{nl}}_i) u_i$。\n    - 每个情景 $s$ 的第二阶段约束：$\\sum_{i=1}^2 g_{i,s} + l_s = D_s$ 和 $0 \\le g_{i,s} \\le P^{\\max}_i u_i$。\n    - 每个情景 $s$ 的第二阶段成本：$\\sum_{i=1}^2 c_i g_{i,s} + M l_s$。\n- **问题定义**：\n    - **随机机组组合 (SUC)**：在所有可行的启停组合中，最小化第一阶段成本与期望第二阶段成本之和。\n    - **确定性期望值 (EV)**：用期望需求 $\\bar{D} = \\sum_s p_s D_s$ 替代随机需求 $D_s$。在满足需求且不切负荷的前提下，最小化 $\\bar{D}$ 对应的总成本。\n    - **评估期望值 (EEV)**：使用通过求解 EV 问题得到的固定启停决策，在随机情景下产生的期望成本。\n- **目标**：计算 EEV 成本与最优 SUC 成本之间的差额（以美元计）。\n- **测试用例**：\n    - **用例1**：情景：$D_1 = 40$ MWh, $p_1 = 0.6$；$D_2 = 120$ MWh, $p_2 = 0.4$。惩罚：$M = 200$ 美元/MWh。\n    - **用例2**：情景：$D_1 = 40$ MWh, $p_1 = 0.95$；$D_2 = 120$ MWh, $p_2 = 0.05$。惩罚：$M = 200$ 美元/MWh。\n    - **用例3**：情景：$D_1 = 40$ MWh, $p_1 = 0.6$；$D_2 = 120$ MWh, $p_2 = 0.4$。惩罚：$M = 30$ 美元/MWh。\n- **假设**：时段持续时间为1小时（1 MW = 1 MWh），所有机组初始状态为关闭，最小发电量为0 MWh，无爬坡约束。\n\n**步骤2：使用提取的已知信息进行验证**\n\n根据验证标准对问题进行评估：\n- **科学性**：该问题是将两阶段随机整数规划应用于电力系统机组组合问题的经典案例，这是能源系统建模和运筹学中一个标准且成熟的课题。所有概念（经济调度、随机优化、期望值解）都具有科学依据。\n- **良构性**：该问题是良构的。第一阶段启停决策的决策空间是有限的（$2^2 = 4$ 种可能性）。对于每种启停组合，第二阶段子问题（经济调度）是一个具有唯一稳定解的线性规划问题。目标函数和约束条件定义清晰，确保了所需值有单一且有意义的解。\n- **客观性**：问题以精确、客观、形式化的数学语言陈述。所有术语均为该领域的标准术语。\n- **完整性与一致性**：为每个用例提供了机组、情景和成本的所有必要数据。假设澄清了任何潜在的模糊之处（如初始状态、最小发电量）。内部没有矛盾。\n- **现实性**：参数描述的是一个“玩具”系统，但在该背景下，它们在物理上是一致且合理的。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。它内容自洽，有科学依据，是良构的，并且其所有组成部分都定义清晰、一致。可以继续求解过程。\n\n### 基于原则的设计与求解\n\n核心任务是计算随机解的价值（VSS），它衡量了使用随机优化模型相对于更简单的确定性模型所带来的收益。此处，它被定义为在随机环境中使用确定性（EV）解所导致的成本增加，即 $VSS = C_{EEV} - C_{SUC}^*$。求解过程通过枚举该双机组系统的所有可能的第一阶段决策来进行。\n\n**1. 第一阶段决策空间**\n对于两个机组，存在四种可能的启停决策 $(u_1, u_2)$：$(0,0)$、$(0,1)$、$(1,0)$ 和 $(1,1)$。我们将评估与每种决策相关的成本。\n\n**2. 第二阶段经济调度**\n对于任何给定的启停组合 $(u_1, u_2)$ 和需求情景 $D_s$，第二阶段问题是一个经济调度问题。目标是以最小的可变成本满足需求。这通过优先顺序加载原则解决：首先调度具有最低可变成本的已启机组，直至其最大容量，然后是次便宜的机组，以此类推。如果总启机容量不足以满足需求，则通过“切负荷”（未服务能源 $l_s$）以高昂的惩罚成本 $M$ 来弥补缺口。\n机组数据显示 $c_1 = 20, c_2 = 25$。因此，机组1总是在机组2之前调度。\n\n**3. 随机机组组合 (SUC) 求解**\nSUC 问题旨在找到最小化总期望成本的启停组合 $(u_1, u_2)$。给定启停组合的总期望成本是其固定的第一阶段成本与期望的第二阶段调度成本之和。\n- 第一阶段成本：$C_1(u_1, u_2) = (C^{\\mathrm{su}}_1 + C^{\\mathrm{nl}}_1)u_1 + (C^{\\mathrm{su}}_2 + C^{\\mathrm{nl}}_2)u_2$。\n- 期望第二阶段成本：$E[C_2(u_1, u_2)] = \\sum_s p_s \\left( \\sum_{i=1}^2 c_i g_{i,s} + M l_s \\right)$，其中 $g_{i,s}$ 和 $l_s$ 是情景 $s$ 的经济调度子问题的最优解。\n- 总期望成本：$C_{total}(u_1, u_2) = C_1(u_1, u_2) + E[C_2(u_1, u_2)]$。\n\n通过计算所有四种启停选项的 $C_{total}$，我们可以找到最优 SUC 成本，$C_{SUC}^* = \\min_{(u_1, u_2)} C_{total}(u_1, u_2)$，以及相应的最优启停组合 $(u_1^*, u_2^*)_{SUC}$。\n\n**4. 期望值 (EV) 求解与评估期望值 (EEV)**\nEV 问题是一个确定性的简化问题，其中不确定的需求 $D_s$被其期望值 $\\bar{D} = \\sum_s p_s D_s$ 所取代。该问题是找到能够最小化服务 $\\bar{D}$ 的确定性成本的启停组合 $(u_1, u_2)$，并满足总启机容量必须充足的约束，即 $\\sum_i P_i^{\\max} u_i \\ge \\bar{D}$。\n- 确定性成本：$C_{EV}(u_1, u_2) = C_1(u_1, u_2) + (\\text{服务}\\bar{D}\\text{的调度成本})$。\n最优 EV 启停组合 $(u_1, u_2)_{EV}$ 是在所有可行启停组合中使 $C_{EV}$ 最小化的那一个。\n\n评估期望值 (EEV) 是在原始随机环境中使用此固定 EV 启停组合 $(u_1, u_2)_{EV}$ 的总期望成本。其计算方式为：\n$C_{EEV} = C_{total}((u_1, u_2)_{EV})$。\n\n**5. 最终计算**\n每个用例的最终结果是差值 $C_{EEV} - C_{SUC}^*$。\n\n**用例1的计算 ($D_1=40, p_1=0.6; D_2=120, p_2=0.4; M=200$):**\n- **SUC：** 通过枚举四种启停组合，我们发现最小总期望成本为 $C_{SUC}^* = \\$3080$，对应于启停组合 $(u_1, u_2) = (1,1)$。\n- **EV：** 期望需求 $\\bar{D} = 0.6(40) + 0.4(120) = 72$ MW。服务 $72$ MW 的最优 EV 启停组合是 $(1,0)$，其确定性成本为 $\\$2940$。\n- **EEV：** 在随机环境中，EV 启停组合 $(1,0)$ 的总期望成本为 $C_{EEV} = C_{total}(1,0) = \\$4380$。\n- **结果：** $C_{EEV} - C_{SUC}^* = 4380 - 3080 = \\$1300$。\n\n**用例2的计算 ($D_1=40, p_1=0.95; D_2=120, p_2=0.05; M=200$):**\n- **SUC：** 最小总期望成本为 $C_{SUC}^* = \\$1812.50$，对应于启停组合 $(u_1, u_2) = (0,1)$。\n- **EV：** 期望需求 $\\bar{D} = 0.95(40) + 0.05(120) = 44$ MW。服务 $44$ MW 的最优 EV 启停组合是 $(0,1)$。\n- **EEV：** 由于 EV 启停组合 $(0,1)$ 与 SUC 最优启停组合相同，因此 $C_{EEV} = C_{SUC}^* = \\$1812.50$。\n- **结果：** $C_{EEV} - C_{SUC}^* = 1812.50 - 1812.50 = \\$0$。\n\n**用例3的计算 ($D_1=40, p_1=0.6; D_2=120, p_2=0.4; M=30$):**\n- **SUC：** 在较低的惩罚下，最小总期望成本为 $C_{SUC}^* = \\$2040$，对应于启停组合 $(u_1, u_2) = (0,1)$。\n- **EV：** 期望需求与用例1相同，为 $\\bar{D} = 72$ MW。EV 问题与 $M$ 无关，因此最优 EV 启停组合仍为 $(1,0)$。\n- **EEV：** 在 $M=30$ 的情况下，EV 启停组合 $(1,0)$ 的总期望成本为 $C_{EEV} = C_{total}(1,0) = \\$3020$。\n- **结果：** $C_{EEV} - C_{SUC}^* = 3020 - 2040 = \\$980$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-stage stochastic unit commitment problem for three test cases.\n    \"\"\"\n\n    # Unit data (common to all test cases)\n    # Units are pre-sorted by variable cost c_i\n    units = [\n        {'id': 1, 'P_max': 100.0, 'c': 20.0, 'C_su': 1000.0, 'C_nl': 500.0},\n        {'id': 2, 'P_max': 50.0, 'c': 25.0, 'C_su': 100.0, 'C_nl': 0.0}\n    ]\n\n    # Test cases\n    test_cases = [\n        {\n            \"scenarios\": [(40.0, 0.6), (120.0, 0.4)],  # (Demand, Probability)\n            \"penalty\": 200.0\n        },\n        {\n            \"scenarios\": [(40.0, 0.95), (120.0, 0.05)],\n            \"penalty\": 200.0\n        },\n        {\n            \"scenarios\": [(40.0, 0.6), (120.0, 0.4)],\n            \"penalty\": 30.0\n        }\n    ]\n\n    # Possible first-stage commitment decisions (u1, u2)\n    commitments = [(0, 0), (0, 1), (1, 0), (1, 1)]\n\n    results = []\n\n    def economic_dispatch(demand, commitment, units_data, penalty_cost):\n        \"\"\"\n        Calculates the minimum dispatch cost for a given demand and commitment.\n        \"\"\"\n        dispatch_cost = 0.0\n        remaining_demand = float(demand)\n\n        # Dispatch units in merit order (pre-sorted by cost)\n        for i, unit_spec in enumerate(units_data):\n            if commitment[i] == 1:\n                dispatch = min(remaining_demand, unit_spec['P_max'])\n                dispatch_cost += dispatch * unit_spec['c']\n                remaining_demand -= dispatch\n\n        # Add penalty for non-served energy (load shedding)\n        if remaining_demand > 1e-6: # Use a small tolerance for float comparison\n            dispatch_cost += remaining_demand * penalty_cost\n        \n        return dispatch_cost\n\n    for case in test_cases:\n        scenarios = case[\"scenarios\"]\n        penalty = case[\"penalty\"]\n\n        # --- 1. SUC (Stochastic Unit Commitment) Solution ---\n        # Calculate the total expected cost for every possible commitment\n        stochastic_costs = {}\n        for u in commitments:\n            # First-stage cost (startup + no-load)\n            first_stage_cost = sum(\n                (unit['C_su'] + unit['C_nl']) * u[i]\n                for i, unit in enumerate(units)\n            )\n\n            # Expected second-stage cost\n            scenario_costs = np.array([\n                economic_dispatch(demand, u, units, penalty)\n                for demand, prob in scenarios\n            ])\n            probabilities = np.array([prob for demand, prob in scenarios])\n            expected_second_stage_cost = np.dot(probabilities, scenario_costs)\n            \n            total_expected_cost = first_stage_cost + expected_second_stage_cost\n            stochastic_costs[u] = total_expected_cost\n        \n        # The optimal SUC cost is the minimum over all commitments\n        suc_optimal_cost = min(stochastic_costs.values())\n        \n        # --- 2. EV (Expected Value) Solution ---\n        # Calculate expected demand\n        expected_demand = sum(prob * demand for demand, prob in scenarios)\n\n        # Find the optimal commitment for the deterministic EV problem\n        ev_candidates = []\n        for u in commitments:\n            total_capacity = sum(\n                unit['P_max'] * u[i] for i, unit in enumerate(units)\n            )\n            # Commitment must be feasible (capacity >= expected demand)\n            if total_capacity >= expected_demand:\n                first_stage_cost = sum(\n                    (unit['C_su'] + unit['C_nl']) * u[i]\n                    for i, unit in enumerate(units)\n                )\n                # Dispatch cost for expected demand (no shedding allowed, penalty is effectively infinite)\n                dispatch_cost_ev = economic_dispatch(expected_demand, u, units, float('inf'))\n                \n                deterministic_cost = first_stage_cost + dispatch_cost_ev\n                ev_candidates.append((deterministic_cost, u))\n        \n        # The EV commitment is the one with the minimum deterministic cost\n        if not ev_candidates: # Should not happen in these test cases\n             # Handle case where no commitment is feasible for expected demand\n             # This would imply a flawed problem setup, but we'll be robust.\n             # E.g., select the highest capacity commitment\n             max_cap = -1\n             u_ev = (0,0)\n             for u in commitments:\n                 cap = sum(unit['P_max'] * u[i] for i, unit in enumerate(units))\n                 if cap > max_cap:\n                     max_cap = cap\n                     u_ev = u\n        else:\n             _, u_ev = min(ev_candidates, key=lambda x: x[0])\n\n        \n        # --- 3. EEV (Evaluated Expected Value) Cost ---\n        # The EEV is the stochastic cost of the commitment chosen by the EV problem\n        eev_cost = stochastic_costs[u_ev]\n        \n        # --- 4. Final Calculation ---\n        # Value of the Stochastic Solution (VSS) / Cost difference\n        result = eev_cost - suc_optimal_cost\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, [round(r, 4) for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了随机模型的价值之后，本练习将转向多周期问题的基本结构。你将处理一个两周期的案例，这会促使你思考今天的决策（第一阶段）如何影响应对不同未来结果（第二阶段）的能力。这个练习旨在巩固“追索”行动（recourse actions）和序贯决策中“非预期性”（non-anticipativity）的概念 。",
            "id": "4104492",
            "problem": "考虑一个两阶段随机机组组合 (SUC) 问题，该问题包含两个火力发电机组和在第二阶段开始时揭晓的两个需求场景。随机机组组合 (SUC) 被建模为一个混合整数线性规划 (MILP) 问题，其中二进制启停变量表示发电机组的开/关状态，连续出力变量表示功率输出。推导的基本依据包括功率平衡定律（每个阶段的总发电量等于需求）、线性发电成本函数（燃料成本与产生的能量成正比）、从关闭到开启的启动成本，以及随机优化的期望值原理。所有时间间隔的长度均为 $1$ 小时，因此以兆瓦时为单位的能量等于以兆瓦为单位的功率。\n\n集合与数据：\n- 发电机组 $\\mathcal{G}=\\{1,2\\}$。\n- 时间阶段 $\\mathcal{T}=\\{1,2\\}$。\n- 场景 $\\mathcal{S}=\\{A,B\\}$，其概率为 $\\pi_A$ 和 $\\pi_B$，满足 $\\pi_A+\\pi_B=1$。\n- 对于每个发电机组 $g\\in\\mathcal{G}$：最小出力 $\\underline{P}_g$（单位 $\\mathrm{MW}$），最大出力 $\\overline{P}_g$（单位 $\\mathrm{MW}$），线性可变成本 $c_g$（单位 $\\$/\\mathrm{MWh}$），以及启动成本 $h_g$（单位 $\\$$）。初始状态为 $y_{g,0}=0$（关闭）。\n- 需求 $D_{1}$（单位 $\\mathrm{MW}$）为阶段 $1$ 的需求（在各场景中通用），$D_{2,s}$（单位 $\\mathrm{MW}$）为场景 $s\\in\\mathcal{S}$ 中阶段 $2$ 的需求。\n\n决策变量：\n- 第一阶段（场景揭晓前）：二进制启停变量 $y_{g,1}\\in\\{0,1\\}$ 和连续出力变量 $p_{g,1}\\ge 0$；二进制启动变量 $v_{g,1}\\in\\{0,1\\}$。\n- 第二阶段（场景揭晓后）：对于每个场景 $s\\in\\mathcal{S}$，二进制启停变量 $y_{g,2,s}\\in\\{0,1\\}$ 和连续出力变量 $p_{g,2,s}\\ge 0$；二进制启动变量 $v_{g,2,s}\\in\\{0,1\\}$。\n\n确定性等效 MILP 推导：\n期望总成本目标为\n$$\n\\min \\left\\{\\sum_{g\\in\\mathcal{G}} \\left(h_g v_{g,1} + c_g p_{g,1}\\right) + \\sum_{s\\in\\mathcal{S}} \\pi_s \\sum_{g\\in\\mathcal{G}} \\left(h_g v_{g,2,s} + c_g p_{g,2,s}\\right)\\right\\}.\n$$\n物理和逻辑约束：\n- 阶段 $1$ 的功率平衡：\n$$\n\\sum_{g\\in\\mathcal{G}} p_{g,1} = D_1.\n$$\n- 阶段 $2$，场景 $s$ 的功率平衡：\n$$\n\\sum_{g\\in\\mathcal{G}} p_{g,2,s} = D_{2,s},\\quad \\forall s\\in\\mathcal{S}.\n$$\n- 阶段 $1$ 中容量与启停状态的关联：\n$$\n\\underline{P}_g\\, y_{g,1} \\le p_{g,1} \\le \\overline{P}_g\\, y_{g,1},\\quad \\forall g\\in\\mathcal{G}.\n$$\n- 阶段 $2$ 中容量与启停状态的关联：\n$$\n\\underline{P}_g\\, y_{g,2,s} \\le p_{g,2,s} \\le \\overline{P}_g\\, y_{g,2,s},\\quad \\forall g\\in\\mathcal{G},\\ \\forall s\\in\\mathcal{S}.\n$$\n- 阶段 $1$ 的启动逻辑：\n$$\nv_{g,1} \\ge y_{g,1} - y_{g,0},\\quad v_{g,1}\\in\\{0,1\\},\\quad y_{g,1}\\in\\{0,1\\},\\quad \\forall g\\in\\mathcal{G}.\n$$\n- 阶段 $2$ 的启动逻辑：\n$$\nv_{g,2,s} \\ge y_{g,2,s} - y_{g,1},\\quad v_{g,2,s}\\in\\{0,1\\},\\quad y_{g,2,s}\\in\\{0,1\\},\\quad \\forall g\\in\\mathcal{G},\\ \\forall s\\in\\mathcal{S}.\n$$\n- 第一阶段变量的非预期性约束：\n由于第一阶段在场景揭晓之前，第一阶段的变量必须在所有场景中保持一致。在确定性等效形式中，这通过将 $y_{g,1}$ 和 $p_{g,1}$ 建模为不带场景索引的变量，或者在使用场景索引时通过显式等式来强制实现：\n$$\ny_{g,1,A} = y_{g,1,B},\\quad p_{g,1,A} = p_{g,1,B},\\quad \\forall g\\in\\mathcal{G},\n$$\n我们通过使用上述不依赖于场景的 $y_{g,1}$ 和 $p_{g,1}$ 来实现这一点。\n\n您必须为以下每个测试用例计算以 $\\$$ 为单位的最优期望总成本以及最优第一阶段启停决策 $y_{1,1}$ 和 $y_{2,1}$。最终成本以 $\\$$ 为单位，四舍五入到小数点后两位。启停决策必须以整数 $0$ 或 $1$ 报告。使用以下发电机组数据：\n- 机组 $1$：$\\underline{P}_1=10$ $\\mathrm{MW}$，$\\overline{P}_1=50$ $\\mathrm{MW}$，$c_1=20$ $\\$/\\mathrm{MWh}$，$h_1=100$ $\\$$。\n- 机组 $2$：$\\underline{P}_2=5$ $\\mathrm{MW}$，$\\overline{P}_2=30$ $\\mathrm{MW}$，$c_2=30$ $\\$/\\mathrm{MWh}$，$h_2=50$ $\\$$。\n- 初始状态：$y_{1,0}=0$，$y_{2,0}=0$。\n\n测试套件：\n- 案例 $1$（一般情况）：$D_1=40$ $\\mathrm{MW}$，$D_{2,A}=60$ $\\mathrm{MW}$，$D_{2,B}=35$ $\\mathrm{MW}$，$\\pi_A=0.4$，$\\pi_B=0.6$。\n- 案例 $2$（接近最小出力的边界可行性）：$D_1=15$ $\\mathrm{MW}$，$D_{2,A}=15$ $\\mathrm{MW}$，$D_{2,B}=15$ $\\mathrm{MW}$，$\\pi_A=0.5$，$\\pi_B=0.5$。\n- 案例 $3$（高需求后接低需求的边缘情况）：$D_1=55$ $\\mathrm{MW}$，$D_{2,A}=80$ $\\mathrm{MW}$，$D_{2,B}=10$ $\\mathrm{MW}$，$\\pi_A=0.8$，$\\pi_B=0.2$。\n\n输出规范：\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表的列表。每个内部列表的形式必须是 $[E^\\star, y_{1,1}^\\star, y_{2,1}^\\star]$，其中 $E^\\star$ 是以 $\\$$ 为单位的最优期望总成本，四舍五入到小数点后两位，$y_{1,1}^\\star$ 和 $y_{2,1}^\\star$ 是机组 $1$ 和 $2$ 的最优第一阶段启停决策。例如，输出可能看起来像 $[[1234.56,1,0],[\\dots]]$。",
            "solution": "用户提供了一个定义明确的两阶段随机机组组合 (SUC) 问题，该问题被建模为混合整数线性规划 (MILP)。该问题具有科学依据、内容完整，并提供了求解所需的所有必要数据。这是电力系统优化中的一个典型问题。因此，该问题被认为是有效的。\n\n目标是找到最小期望总成本以及相应的第一阶段最优启停决策 $(y_{1,1}^\\star, y_{2,1}^\\star)$。总成本包括第一阶段的启动和发电成本，加上在场景 $A$ 和 $B$ 下第二阶段启动和发电成本的期望值。\n\n鉴于问题的规模较小——两个发电机组和第一阶段的二进制启停决策——最直接和透明的解决方法是结构化地枚举所有可能的第一阶段启停策略。对于 $(y_{1,1}, y_{2,1})$ 存在 $2^2=4$ 种这样的策略：$(0,0)$、$(0,1)$、$(1,0)$ 和 $(1,1)$。对于这些策略中的每一种，我们都可以计算总期望成本。最优策略是产生最小总期望成本的策略。\n\n评估单个第一阶段启停策略 $(y_{1,1}, y_{2,1})$ 的过程如下：\n\n**1. 第一阶段分析**\n首先，我们评估第一个时间阶段 $t=1$ 的成本和可行性。\n- **可行性检查：** 所选的启停组合必须能够满足需求 $D_1$。也就是说，已启停机组的最小出力之和不能超过需求，而最大出力之和必须至少等于需求：\n$$\n\\sum_{g \\in \\mathcal{G}} \\underline{P}_g y_{g,1} \\le D_1 \\le \\sum_{g \\in \\mathcal{G}} \\overline{P}_g y_{g,1}\n$$\n如果不满足此条件，则该启停策略不可行，其成本被视为无穷大。\n- **经济调度：** 如果可行，通过经济调度确定功率输出 $p_{g,1}$，以最低的发电成本满足 $D_1$。由于可变成本 $c_g$ 是线性的，这涉及到在尊重最小和最大出力限制 $\\underline{P}_g$ 和 $\\overline{P}_g$ 的同时，先加载 $c_g$ 较低的机组（机组 1，其 $c_1=20$ $\\$/\\mathrm{MWh}$），再加载 $c_g$ 较高的机组（机组 2，其 $c_2=30$ $\\$/\\mathrm{MWh}$）。\n- **第一阶段成本 ($C_1$)：** 阶段 $1$ 的成本是启动成本和发电成本之和。由于两个机组都从关闭状态 ($y_{g,0}=0$) 开始，启动变量 $v_{g,1}$ 等于 $y_{g,1}$。成本为：\n$$\nC_1(y_{1,1}, y_{2,1}) = \\sum_{g \\in \\mathcal{G}} (h_g y_{g,1} + c_g p_{g,1})\n$$\n\n**2. 第二阶段分析（追索）**\n接下来，对于给定的第一阶段启停 $(y_{1,1}, y_{2,1})$，我们必须为每个场景 $s \\in \\{A, B\\}$ 确定最优的第二阶段决策，并计算期望成本。第二阶段的决策是在不确定性（需求 $D_{2,s}$）揭晓后采取的“追索”行动。\n\n对于每个场景 $s \\in \\{A, B\\}$：\n- **最优第二阶段启停：** 我们必须找到成本最低的启停决策 $(y_{1,2,s}, y_{2,2,s})$ 来满足特定场景的需求 $D_{2,s}$。这涉及到评估所有 $4$ 种可能的第二阶段启停。对于每种选择：\n    - 我们检查其相对于 $D_{2,s}$ 的可行性。\n    - 如果可行，我们计算启动成本。启动变量 $v_{g,2,s}$ 由从第一阶段状态 $y_{g,1}$ 的转变决定：$v_{g,2,s} = \\max(0, y_{g,2,s} - y_{g,1})$。该场景的启动成本为 $\\sum_{g \\in \\mathcal{G}} h_g v_{g,2,s}$。\n    - 我们执行经济调度以找到发电水平 $p_{g,2,s}$ 和相关的最小发电成本 $\\sum_{g \\in \\mathcal{G}} c_g p_{g,2,s}$。\n    - 该启停选择的第二阶段总成本是其启动成本和发电成本之和。\n- **最小场景成本 ($C_{2,s}^\\star$)：** 通过比较可行的第二阶段启停选项的总成本，我们找到场景 $s$ 的最小可能成本，记为 $C^\\star_{2,s}$。\n- **期望第二阶段成本 ($E[C_2]$)：** 第二阶段的期望成本是每个场景最小成本的概率加权平均值：\n$$\nE[C_2] = \\pi_A C^\\star_{2,A} + \\pi_B C^\\star_{2,B}\n$$\n\n**3. 总期望成本与优化**\n初始第一阶段策略 $(y_{1,1}, y_{2,1})$ 的总期望成本是第一阶段成本和期望第二阶段成本之和：\n$$\nE[C_{\\text{total}}] = C_1 + E[C_2]\n$$\n对所有四种初始第一阶段启停策略重复此计算。最优策略 $(y_{1,1}^\\star, y_{2,1}^\\star)$ 是产生最小 $E[C_{\\text{total}}]$ 的策略，而这个最小值就是最优期望总成本 $E^\\star$。\n\n使用的发电机组数据为：\n- 机组 1：$\\underline{P}_1=10$ $\\mathrm{MW}$，$\\overline{P}_1=50$ $\\mathrm{MW}$，$c_1=20$ $\\$/\\mathrm{MWh}$，$h_1=100$ $\\$$。\n- 机组 2：$\\underline{P}_2=5$ $\\mathrm{MW}$，$\\overline{P}_2=30$ $\\mathrm{MW}$，$c_2=30$ $\\$/\\mathrm{MWh}$，$h_2=50$ $\\$$。\n- 初始状态：$y_{1,0}=0$，$y_{2,0}=0$。\n\n通过对三个测试用例中的每一个应用这种系统性的枚举和成本计算，我们得出了最优的第一阶段决策和相应的最小期望成本。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-period stochastic unit commitment problem for the given test cases.\n    \"\"\"\n    \n    # Generator data\n    generators = [\n        {'id': 1, 'P_min': 10, 'P_max': 50, 'cost': 20, 'startup': 100, 'y0': 0},\n        {'id': 2, 'P_min': 5, 'P_max': 30, 'cost': 30, 'startup': 50, 'y0': 0}\n    ]\n    # Sort generators by cost for economic dispatch, cheaper first.\n    # We create a mapping to their original indices.\n    sorted_gen_indices = sorted(range(len(generators)), key=lambda k: generators[k]['cost'])\n\n    # Test suite\n    test_cases = [\n        {'D1': 40, 'D2A': 60, 'D2B': 35, 'pi_A': 0.4, 'pi_B': 0.6},\n        {'D1': 15, 'D2A': 15, 'D2B': 15, 'pi_A': 0.5, 'pi_B': 0.5},\n        {'D1': 55, 'D2A': 80, 'D2B': 10, 'pi_A': 0.8, 'pi_B': 0.2}\n    ]\n\n    def economic_dispatch(demand, commitment_status):\n        \"\"\"\n        Calculates the minimum generation cost and dispatch levels for a given demand and set of\n        committed units.\n        \n        Args:\n            demand (float): The load to be met.\n            commitment_status (tuple): A tuple of binary values (0 or 1) indicating which\n                                       generators are committed.\n\n        Returns:\n            tuple: (generation_cost, dispatch_levels) or (inf, None) if infeasible.\n        \"\"\"\n        p_min_total = sum(gen['P_min'] for i, gen in enumerate(generators) if commitment_status[i])\n        p_max_total = sum(gen['P_max'] for i, gen in enumerate(generators) if commitment_status[i])\n\n        if not (p_min_total <= demand <= p_max_total):\n            return float('inf'), None\n\n        dispatch = np.zeros(len(generators))\n        gen_cost = 0.0\n        \n        # Load all committed units to their minimum output\n        for i, gen in enumerate(generators):\n            if commitment_status[i]:\n                dispatch[i] = gen['P_min']\n                gen_cost += gen['cost'] * gen['P_min']\n\n        remaining_demand = demand - p_min_total\n\n        # Load incrementally based on cost\n        for i in sorted_gen_indices:\n            if commitment_status[i]:\n                gen = generators[i]\n                capacity_above_min = gen['P_max'] - gen['P_min']\n                load_increase = min(remaining_demand, capacity_above_min)\n                \n                dispatch[i] += load_increase\n                gen_cost += gen['cost'] * load_increase\n                remaining_demand -= load_increase\n        \n        return gen_cost, dispatch\n\n    results = []\n    \n    for case in test_cases:\n        min_total_exp_cost = float('inf')\n        optimal_y1 = None\n\n        # Enumerate all 4 possible first-stage commitments (y1_1, y2_1)\n        for y11 in [0, 1]:\n            for y21 in [0, 1]:\n                y1 = (y11, y21)\n                \n                # --- STAGE 1 ANALYSIS ---\n                # Calculate first-stage cost\n                stage1_gen_cost, _ = economic_dispatch(case['D1'], y1)\n                \n                if stage1_gen_cost == float('inf'):\n                    continue\n\n                stage1_startup_cost = sum(gen['startup'] * y1[i] for i, gen in enumerate(generators))\n                total_stage1_cost = stage1_startup_cost + stage1_gen_cost\n                \n                # --- STAGE 2 ANALYSIS ---\n                # Calculate expected second-stage cost\n                exp_stage2_cost = 0.0\n                scenarios = [('A', case['D2A'], case['pi_A']), ('B', case['D2B'], case['pi_B'])]\n                \n                for _, d2_s, pi_s in scenarios:\n                    min_cost_s = float('inf')\n                    \n                    # Find optimal recourse action for scenario s by enumerating y2_s\n                    for y12s in [0, 1]:\n                        for y22s in [0, 1]:\n                            y2_s = (y12s, y22s)\n                            \n                            gen_cost_s, _ = economic_dispatch(d2_s, y2_s)\n                            if gen_cost_s == float('inf'):\n                                continue\n                                \n                            startup_cost_s = sum(gen['startup'] * max(0, y2_s[i] - y1[i]) for i, gen in enumerate(generators))\n                            total_cost_s = startup_cost_s + gen_cost_s\n                            \n                            if total_cost_s < min_cost_s:\n                                min_cost_s = total_cost_s\n                    \n                    if min_cost_s == float('inf'):\n                        # If a scenario is infeasible for a given y1, that y1 is invalid.\n                        exp_stage2_cost = float('inf')\n                        break\n                    \n                    exp_stage2_cost += pi_s * min_cost_s\n\n                if exp_stage2_cost == float('inf'):\n                    continue\n                \n                # --- TOTAL COST & OPTIMIZATION ---\n                total_exp_cost = total_stage1_cost + exp_stage2_cost\n                \n                if total_exp_cost < min_total_exp_cost:\n                    min_total_exp_cost = total_exp_cost\n                    optimal_y1 = y1\n        \n        # Format and append result\n        results.append([float(f\"{min_total_exp_cost:.2f}\"), optimal_y1[0], optimal_y1[1]])\n\n    # Print results in the specified format\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了使模型更贴近现实，这最后一个练习引入了一个关键的运行细节：发电机爬坡约束。这些约束限制了发电机改变其出力的速度，从而在不同时间周期之间建立了依赖关系。通过解决一个包含爬坡限制的问题，你将学习如何处理调度子问题中的跨期约束，并了解这些物理限制如何收紧可行操作空间并影响最优启停策略 。",
            "id": "4125912",
            "problem": "考虑一个针对一个火电机组组合的随机机组组合（SUC）规划与运行问题，该问题的时间范围为离散的 $T = 3$ 个时段，包含 $G = 2$ 台机组。存在 $S = 3$ 个需求情景，以 $s \\in \\{1,2,3\\}$ 为索引，每个情景的概率为 $p_s$，且在每个时段 $t \\in \\{1,2,3\\}$ 具有时变的净负荷 $D_{t,s}$。决策变量包括：在所有情景中均相同的二进制启停决策 $x_{g,t} \\in \\{0,1\\}$（非预期性），以及与情景相关的调度量 $p_{g,t,s} \\ge 0$。目标是在满足机组容量、爬坡约束和节点平衡的条件下，最小化期望总成本。所有机组在 $t=0$ 时段初始状态为关停，出力为零。\n\n从以下基本原则出发：\n- 基于各情景概率 $p_s$ 的期望值算子。\n- 每单位能量的线性调度成本和每承诺时段的线性固定成本。\n- 每个情景时段内发电与需求之间的有功功率平衡。\n- 连续时段之间有功出力的物理爬坡约束。\n- 跨情景的二进制启停决策的非预期性。\n\n令 $c_g$ 表示机组 $g$ 的可变能量成本，单位为美元/兆瓦时（$\\$\\!/\\,\\mathrm{MWh}$）；$f_g$ 为空载成本，单位为美元/时段；$SU_g$ 为启动成本，单位为美元/次；$\\overline{P}_g$ 为最大功率，单位为兆瓦（$\\mathrm{MW}$）；$R^{\\uparrow}_g$ 为爬坡上限，单位为兆瓦/时段（$\\mathrm{MW}/\\mathrm{period}$）；$R^{\\downarrow}_g$ 为降坡下限，单位为兆瓦/时段（$\\mathrm{MW}/\\mathrm{period}$）。假设最小功率为零（$P^{\\min}_g = 0$）。二进制启动指示变量 $y_{g,t}$ 由 $x_{g,t}$ 隐含定义为 $y_{g,t} = \\max\\{0, x_{g,t} - x_{g,t-1}\\}$，其中 $x_{g,0} = 0$。\n\nSUC 数学模型如下：\n最小化\n$$\n\\sum_{g=1}^{G} \\left( SU_g \\sum_{t=1}^{T} y_{g,t} + f_g \\sum_{t=1}^{T} x_{g,t} \\right) + \\sum_{s=1}^{S} p_s \\sum_{t=1}^{T} \\sum_{g=1}^{G} c_g \\, p_{g,t,s}\n$$\n约束条件为，对于所有 $t \\in \\{1,2,3\\}$ 和 $s \\in \\{1,2,3\\}$：\n$$\n\\sum_{g=1}^{G} p_{g,t,s} = D_{t,s},\n$$\n$$\n0 \\le p_{g,t,s} \\le \\overline{P}_g \\, x_{g,t},\n$$\n$$\n- R^{\\downarrow}_g \\le p_{g,t,s} - p_{g,t-1,s} \\le R^{\\uparrow}_g, \\quad \\text{其中 } p_{g,0,s} = 0,\n$$\n且对于所有 $t$， $x_{g,t} \\in \\{0,1\\}$ 在各情景中均相同。\n\n您必须计算出能最小化上述模型期望成本的最优启停计划。您的算法设计应源于基本原则，并通过对可行的启停计划进行穷举以及为每个情景-时段计算成本最小的调度，从而为小型实例生成正确的优化计划。对于每个候选启停计划，执行经济调度，以最小化受爬坡和容量约束以及总和等于需求的等式约束下的每时段线性成本。如果一个计划对于任何情景-时段是不可行的，则丢弃该计划。\n\n使用以下三个实例的测试集。所有成本必须以美元（$\\$$）计算，功率以兆瓦（$\\mathrm{MW}$）计算，能量以兆瓦时（$\\mathrm{MWh}$）计算，爬坡率以兆瓦/时段（$\\mathrm{MW}/\\mathrm{period}$）计算。最终输出是表示启停状态的无单位二进制整数。这三个实例如下：\n\n- 实例 1：\n  - 机组 1：$\\overline{P}_1 = 100\\,\\mathrm{MW}$，$R^{\\uparrow}_1 = 50\\,\\mathrm{MW}/\\mathrm{period}$，$R^{\\downarrow}_1 = 100\\,\\mathrm{MW}/\\mathrm{period}$，$c_1 = 20\\,\\$\\!/\\,\\mathrm{MWh}$，$f_1 = 500\\,\\$/\\mathrm{period}$，$SU_1 = 2000\\,\\$.$\n  - 机组 2：$\\overline{P}_2 = 80\\,\\mathrm{MW}$，$R^{\\uparrow}_2 = 80\\,\\mathrm{MW}/\\mathrm{period}$，$R^{\\downarrow}_2 = 80\\,\\mathrm{MW}/\\mathrm{period}$，$c_2 = 30\\,\\$\\!/\\,\\mathrm{MWh}$，$f_2 = 300\\,\\$/\\mathrm{period}$，$SU_2 = 1500\\,\\$.$\n  - 情景概率：$(p_1,p_2,p_3) = (0.3, 0.4, 0.3)$。\n  - 需求：$D_{\\cdot,1} = [60, 100, 80]\\,\\mathrm{MW}$，$D_{\\cdot,2} = [50, 70, 110]\\,\\mathrm{MW}$，$D_{\\cdot,3} = [40, 90, 60]\\,\\mathrm{MW}.$\n\n- 实例 2：\n  - 机组 1：$\\overline{P}_1 = 120\\,\\mathrm{MW}$，$R^{\\uparrow}_1 = 30\\,\\mathrm{MW}/\\mathrm{period}$，$R^{\\downarrow}_1 = 120\\,\\mathrm{MW}/\\mathrm{period}$，$c_1 = 18\\,\\$\\!/\\,\\mathrm{MWh}$，$f_1 = 700\\,\\$/\\mathrm{period}$，$SU_1 = 2500\\,\\$.$\n  - 机组 2：$\\overline{P}_2 = 100\\,\\mathrm{MW}$，$R^{\\uparrow}_2 = 100\\,\\mathrm{MW}/\\mathrm{period}$，$R^{\\downarrow}_2 = 100\\,\\mathrm{MW}/\\mathrm{period}$，$c_2 = 26\\,\\$\\!/\\,\\mathrm{MWh}$，$f_2 = 200\\,\\$/\\mathrm{period}$，$SU_2 = 1000\\,\\$.$\n  - 情景概率：$(p_1,p_2,p_3) = (0.2, 0.5, 0.3)$。\n  - 需求：$D_{\\cdot,1} = [40, 120, 80]\\,\\mathrm{MW}$，$D_{\\cdot,2} = [60, 140, 70]\\,\\mathrm{MW}$，$D_{\\cdot,3} = [50, 100, 90]\\,\\mathrm{MW}.$\n\n- 实例 3：\n  - 机组 1：$\\overline{P}_1 = 90\\,\\mathrm{MW}$，$R^{\\uparrow}_1 = 45\\,\\mathrm{MW}/\\mathrm{period}$，$R^{\\downarrow}_1 = 90\\,\\mathrm{MW}/\\mathrm{period}$，$c_1 = 22\\,\\$\\!/\\,\\mathrm{MWh}$，$f_1 = 400\\,\\$/\\mathrm{period}$，$SU_1 = 1000\\,\\$.$\n  - 机组 2：$\\overline{P}_2 = 150\\,\\mathrm{MW}$，$R^{\\uparrow}_2 = 150\\,\\mathrm{MW}/\\mathrm{period}$，$R^{\\downarrow}_2 = 150\\,\\mathrm{MW}/\\mathrm{period}$，$c_2 = 24\\,\\$\\!/\\,\\mathrm{MWh}$，$f_2 = 50\\,\\$/\\mathrm{period}$，$SU_2 = 6000\\,\\$.$\n  - 情景概率：$(p_1,p_2,p_3) = (0.3, 0.4, 0.3)$。\n  - 需求：$D_{\\cdot,1} = [30, 80, 30]\\,\\mathrm{MW}$，$D_{\\cdot,2} = [20, 60, 20]\\,\\mathrm{MW}$，$D_{\\cdot,3} = [25, 75, 25]\\,\\mathrm{MW}.$\n\n您必须通过以下方式实现期望成本最小化：\n- 枚举所有可能的启停计划 $x_{g,t}$，其中 $g \\in \\{1,2\\}$ 且 $t \\in \\{1,2,3\\}$。\n- 对于一个固定的计划，为每个时段 $t$ 执行情景经济调度，以最小化 $\\sum_{g} c_g \\, p_{g,t,s}$，约束条件为 $p_{g,t,s} \\in [L_{g,t,s}, U_{g,t,s}]$ 和 $\\sum_{g} p_{g,t,s} = D_{t,s}$，其中\n  $L_{g,t,s} = 0$ 如果 $x_{g,t} = 0$，否则 $L_{g,t,s} = \\max\\{0, p_{g,t-1,s} - R^{\\downarrow}_g\\}$，\n  且\n  $U_{g,t,s} = 0$ 如果 $x_{g,t} = 0$，否则 $U_{g,t,s} = \\min\\{\\overline{P}_g, p_{g,t-1,s} + R^{\\uparrow}_g\\}$，\n  其中 $p_{g,0,s} = 0$。\n- 如果某一时段不满足可行性，则该计划为不可行。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。每个测试用例的结果必须是一个扁平化的包含六个二进制整数的列表，表示最优启停计划，顺序为 $[x_{1,1}, x_{1,2}, x_{1,3}, x_{2,1}, x_{2,2}, x_{2,3}]$。因此，最终输出应类似于 $[[\\dots],[\\dots],[\\dots]]$，其中每个内部列表仅包含整数（$0$ 或 $1$）。",
            "solution": "所给出的问题是一个针对小型电力系统的有效且适定的随机机组组合（SUC）问题。它基于运筹学和电力系统工程的既定原则。目标是确定两台火电机组在三个时段的时间范围内的最优启停计划，同时考虑三种不同的需求情景。解决方案必须最小化总期望成本，该成本包括固定的启停成本、启动成本和可变的调度成本。\n\n该问题的数学模型可表述为一个混合整数线性规划（MILP）。决策变量分为第一阶段（非预期性）的二进制启停变量 $x_{g,t} \\in \\{0,1\\}$（对于每个机组 $g \\in \\{1,2\\}$ 和时段 $t \\in \\{1,2,3\\}$），以及第二阶段（与情景相关）的连续调度变量 $p_{g,t,s} \\ge 0$。目标是最小化确定性的启停和启动成本与所有情景下调度成本的期望值之和。\n\n要最小化的目标函数是：\n$$\nC_{total} = C_{commit} + \\mathbb{E}[C_{dispatch}] = \\sum_{g=1}^{G} \\left( SU_g \\sum_{t=1}^{T} y_{g,t} + f_g \\sum_{t=1}^{T} x_{g,t} \\right) + \\sum_{s=1}^{S} \\pi_s \\left( \\sum_{t=1}^{T} \\sum_{g=1}^{G} c_g \\, p_{g,t,s} \\right)\n$$\n其中 $y_{g,t} = \\max\\{0, x_{g,t} - x_{g,t-1}\\}$ 是启动指示变量，初始状态为 $x_{g,0}=0$。约束条件为每个情景 $s$ 和时段 $t$ 强制执行功率平衡、机组容量限制和爬坡限制：\n1. 功率平衡：$\\sum_{g=1}^{G} p_{g,t,s} = D_{t,s}$\n2. 发电容量：$0 \\le p_{g,t,s} \\le \\overline{P}_g x_{g,t}$\n3. 爬坡限制：$p_{g,t-1,s} - R^{\\downarrow}_g \\le p_{g,t,s} \\le p_{g,t-1,s} + R^{\\uparrow}_g$，初始调度量为 $p_{g,0,s}=0$。\n\n该问题指定了采用穷举法来寻找最优启停计划。对于 $G=2$ 台机组和 $T=3$ 个时段，共有 $G \\times T = 6$ 个二进制启停变量（$x_{1,1}, x_{1,2}, x_{1,3}, x_{2,1}, x_{2,2}, x_{2,3}$）。这导致整个系统共有 $2^{G \\times T} = 2^6 = 64$ 种可能的启停计划。该算法会遍历每一个候选计划，评估其总期望成本，并找出成本最低的计划。\n\n对于每个候选启停计划，执行两部分的成本评估：\n\n首先，计算确定性的启停成本（$C_{commit}$）。此成本与情景无关，仅取决于启停计划 $x = \\{x_{g,t}\\}$。对于每个机组 $g$，计算其启动次数和总承诺时段数。成本计算如下：\n$$\nC_{commit}(x) = \\sum_{g=1}^{G} \\left( SU_g \\sum_{t=1}^{T} \\max\\{0, x_{g,t} - x_{g,t-1}\\} + f_g \\sum_{t=1}^{T} x_{g,t} \\right)\n$$\n\n其次，计算期望调度成本（$\\mathbb{E}[C_{dispatch}]$）。这需要评估每个情景下调度的可行性和成本。对于给定的启停计划 $x$，我们逐个情景进行处理。对于每个情景 $s$，我们模拟在时间范围 $t=1,2,3$ 内的调度：\n在每个时段 $t$，我们必须解决一个经济调度子问题，以找到满足需求 $D_{t,s}$ 且成本最低的机组出力 $p_{g,t,s}$。每个机组的可用调度范围受其启停状态、最大容量 $\\overline{P}_g$ 以及相对于前一时段出力 $p_{g,t-1,s}$ 的爬坡率限制。机组 $g$ 的有效可行调度范围 $[L_{g,t,s}, U_{g,t,s}]$ 为：\n- 如果机组 $g$ 停机（$x_{g,t}=0$）：$L_{g,t,s} = U_{g,t,s} = 0$。\n- 如果机组 $g$ 开机（$x_{g,t}=1$）：\n    $$\n    L_{g,t,s} = \\max\\{0, p_{g,t-1,s} - R^{\\downarrow}_g\\}\n    $$\n    $$\n    U_{g,t,s} = \\min\\{\\overline{P}_g, p_{g,t-1,s} + R^{\\uparrow}_g\\}\n    $$\n初始条件为对所有 $g,s$，有 $p_{g,0,s}=0$。\n\n只有当总需求 $D_{t,s}$ 处于聚合的系统容量范围内，即 $\\sum_{g=1}^{G} L_{g,t,s} \\le D_{t,s} \\le \\sum_{g=1}^{G} U_{g,t,s}$ 时，情景 $s$ 中时段 $t$ 的可行调度才存在。如果任一情景 $s$ 的任一时段 $t$ 违反了此条件，则整个启停计划被视为不可行，并从考虑中排除。\n\n如果该时段可行，则通过按可变成本 $c_g$ 的升序加载机组（按成本排序调度）来找到最优调度。对于一个双机组系统，其成本为 $c_1$ 和 $c_2$，不失一般性地假设 $c_1 \\le c_2$。为最小化调度成本 $c_1 p_{1,t,s} + c_2 p_{2,t,s}$，同时满足 $p_{1,t,s} + p_{2,t,s} = D_{t,s}$ 和边界 $[L_{g,t,s}, U_{g,t,s}]$，我们应最大化较便宜机组的出力 $p_{1,t,s}$。$p_{1,t,s}$ 的可行范围由其自身边界和 $p_{2,t,s}$ 的边界导出：\n$$\np_{1,t,s} \\in [\\max(L_{1,t,s}, D_{t,s} - U_{2,t,s}), \\min(U_{1,t,s}, D_{t,s} - L_{2,t,s})]\n$$\n为了最大化 $p_{1,t,s}$，我们将其设置为此范围的上限：\n$$\np_{1,t,s}^* = \\min(U_{1,t,s}, D_{t,s} - L_{2,t,s})\n$$\n然后，较昂贵机组的调度量由功率平衡方程确定：\n$$\np_{2,t,s}^* = D_{t,s} - p_{1,t,s}^*\n$$\n如果 $c_2  c_1$，我们则会通过将 $p_{1,t,s}$ 设置为其可行范围的下限 $p_{1,t,s}^* = \\max(L_{1,t,s}, D_{t,s} - U_{2,t,s})$ 来最小化 $p_{1,t,s}$。\n\n该时段的调度成本为 $C_{t,s} = \\sum_{g} c_g p_{g,t,s}^*$。情景 $s$ 的总调度成本为 $C_{dispatch,s} = \\sum_{t=1}^{T} C_{t,s}$。期望调度成本则通过将每个情景的成本与其概率加权计算得出：$\\mathbb{E}[C_{dispatch}] = \\sum_{s=1}^{S} \\pi_s C_{dispatch,s}$。\n\n候选计划的总期望成本为 $C_{total}(x) = C_{commit}(x) + \\mathbb{E}[C_{dispatch}]$。对所有 64 个计划重复此过程。产生最小有限总成本的计划即为最优解。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stochastic unit commitment problem for three given instances\n    using exhaustive enumeration of commitment schedules.\n    \"\"\"\n\n    test_cases = [\n        # Instance 1\n        {\n            \"G1\": {\"P_max\": 100, \"R_up\": 50, \"R_down\": 100, \"c\": 20, \"f\": 500, \"SU\": 2000},\n            \"G2\": {\"P_max\": 80, \"R_up\": 80, \"R_down\": 80, \"c\": 30, \"f\": 300, \"SU\": 1500},\n            \"probs\": [0.3, 0.4, 0.3],\n            \"demands\": [\n                [60, 100, 80],\n                [50, 70, 110],\n                [40, 90, 60],\n            ],\n        },\n        # Instance 2\n        {\n            \"G1\": {\"P_max\": 120, \"R_up\": 30, \"R_down\": 120, \"c\": 18, \"f\": 700, \"SU\": 2500},\n            \"G2\": {\"P_max\": 100, \"R_up\": 100, \"R_down\": 100, \"c\": 26, \"f\": 200, \"SU\": 1000},\n            \"probs\": [0.2, 0.5, 0.3],\n            \"demands\": [\n                [40, 120, 80],\n                [60, 140, 70],\n                [50, 100, 90],\n            ],\n        },\n        # Instance 3\n        {\n            \"G1\": {\"P_max\": 90, \"R_up\": 45, \"R_down\": 90, \"c\": 22, \"f\": 400, \"SU\": 1000},\n            \"G2\": {\"P_max\": 150, \"R_up\": 150, \"R_down\": 150, \"c\": 24, \"f\": 50, \"SU\": 6000},\n            \"probs\": [0.3, 0.4, 0.3],\n            \"demands\": [\n                [30, 80, 30],\n                [20, 60, 20],\n                [25, 75, 25],\n            ],\n        },\n    ]\n\n    results = []\n    T = 3\n    G = 2\n\n    for case in test_cases:\n        min_total_cost = float('inf')\n        best_schedule = None\n\n        # Enumerate all 2^(G*T) = 64 possible commitment schedules\n        for i in range(2**(G * T)):\n            # Generate the schedule from the integer i\n            # Format: [x11, x12, x13, x21, x22, x23]\n            schedule_flat = [int(bit) for bit in format(i, f'0{G*T}b')]\n            x = np.array(schedule_flat).reshape((G, T))\n            \n            # --- 1. Calculate deterministic commitment cost ---\n            commit_cost = 0.0\n            gens = [case[\"G1\"], case[\"G2\"]]\n            for g in range(G):\n                x_g_t = x[g, :]\n                x_g_t_prev = np.insert(x_g_t[:-1], 0, 0) # x_{g,t-1} with x_{g,0}=0\n                startups = np.maximum(0, x_g_t - x_g_t_prev)\n                \n                commit_cost += gens[g][\"SU\"] * np.sum(startups)\n                commit_cost += gens[g][\"f\"] * np.sum(x_g_t)\n\n            # --- 2. Calculate expected dispatch cost ---\n            expected_dispatch_cost = 0.0\n            schedule_is_feasible = True\n\n            for s, prob in enumerate(case[\"probs\"]):\n                scenario_dispatch_cost = 0.0\n                is_feasible_scenario = True\n                p_prev = np.zeros(G) # p_{g,t-1,s}, initialized for t=1\n\n                for t in range(T):\n                    demand = case[\"demands\"][s][t]\n                    \n                    # Calculate generator bounds [L_g, U_g] for this period\n                    L_g = np.zeros(G)\n                    U_g = np.zeros(G)\n                    for g in range(G):\n                        if x[g, t] == 1:\n                            L_g[g] = max(0, p_prev[g] - gens[g][\"R_down\"])\n                            U_g[g] = min(gens[g][\"P_max\"], p_prev[g] + gens[g][\"R_up\"])\n                        # If x[g,t] == 0, bounds are already 0.\n\n                    # Check feasibility for the period\n                    if not (np.sum(L_g) = demand = np.sum(U_g)):\n                        is_feasible_scenario = False\n                        break\n                    \n                    # Economic dispatch\n                    # Sort generators by cost\n                    gen_indices = sorted(range(G), key=lambda g_idx: gens[g_idx][\"c\"])\n                    g_cheap, g_exp = gen_indices[0], gen_indices[1]\n                    \n                    # Effective bounds for the cheaper generator's dispatch\n                    p_cheap_min = max(L_g[g_cheap], demand - U_g[g_exp])\n                    p_cheap_max = min(U_g[g_cheap], demand - L_g[g_exp])\n\n                    # Dispatch cheaper generator to its max feasible limit to minimize cost\n                    p_dispatch = np.zeros(G)\n                    # This logic assumes c_cheap  c_exp. If they were equal, any dispatch is fine.\n                    p_dispatch[g_cheap] = p_cheap_max \n                    p_dispatch[g_exp] = demand - p_dispatch[g_cheap]\n                    \n                    # Calculate period dispatch cost and update for next period\n                    period_cost = p_dispatch[0] * gens[0][\"c\"] + p_dispatch[1] * gens[1][\"c\"]\n                    scenario_dispatch_cost += period_cost\n                    p_prev = p_dispatch\n                \n                if not is_feasible_scenario:\n                    schedule_is_feasible = False\n                    break\n                else:\n                    expected_dispatch_cost += prob * scenario_dispatch_cost\n            \n            if schedule_is_feasible:\n                total_cost = commit_cost + expected_dispatch_cost\n                if total_cost  min_total_cost:\n                    min_total_cost = total_cost\n                    best_schedule = schedule_flat\n\n        results.append(best_schedule)\n    \n    # Format the final output as a list of lists of integers\n    # The provided print statement template with map(str,...) needs careful handling\n    # for lists of lists. A custom formatter is safer.\n    def format_results(res):\n        return '[' + ','.join(str(r) for r in res) + ']'\n    \n    print(f\"[{','.join(format_results(res) for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}