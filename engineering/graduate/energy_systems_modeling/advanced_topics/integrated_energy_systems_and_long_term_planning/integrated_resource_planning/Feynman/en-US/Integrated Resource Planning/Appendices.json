{
    "hands_on_practices": [
        {
            "introduction": "Integrated Resource Planning (IRP) fundamentally involves comparing projects with different lifespans and cost profiles. The decision between a high-capital, long-lived asset and a low-capital, short-lived one is not straightforward and depends crucially on how we value future expenditures. This exercise  explores the cornerstone of this comparison—the discount rate and Net Present Value (NPV)—challenging you to build a valuation model from first principles and quantify how this single parameter can alter the optimal choice.",
            "id": "4097905",
            "problem": "You are tasked with designing and implementing a sensitivity analysis for the discount rate and quantifying its impact on the ranking of long-lived versus short-lived resource plans using net present value in the context of integrated resource planning within energy systems modeling. The analysis must be formulated from first principles of intertemporal valuation and time preference. Consider a centralized planner who evaluates resource plans over a fixed planning horizon using the principle of the time value of money: future cash flows are valued less than present cash flows according to a constant real discount rate. A resource plan is defined by a sequence of cash flows that includes investment outlays, annual operating payments, annual operating benefits, and end-of-horizon salvage values. The planning horizon is fixed and common to all resource plans; competing plans must deliver identical annual service over this horizon. When a resource’s technical lifetime is shorter than the planning horizon, identical replacements are made as often as needed to provide service for the entire horizon. If a resource instance extends beyond the planning horizon, the unexpired lifetime is converted to a salvage value by proportional remaining-life valuation at the end of the horizon.\n\nBase assumptions to be used (do not use any shortcut formulas beyond what is derivable from these principles):\n- The time value of money is represented by a constant real discount rate $r \\in [0,1)$ per year. A cash flow occurring at the end of year $t$ has present value determined by the principle of discounting with rate $r$.\n- Each resource instance has a technical lifetime denoted by $L$, a one-time capital investment cost $K$ (a positive quantity measured in dollars), a constant annual operating and maintenance cost $C$ (measured in dollars per year), and a constant annual operating benefit $B$ (measured in dollars per year). The net operating cash flow per active year is $(B - C)$.\n- The planner uses a fixed planning horizon $H$ (in years). To ensure identical service across plans, the short-lived resource is replaced at years $0, L, 2L, \\dots$ until it covers the entire $H$. If the final instance extends beyond $H$, its remaining life is converted to a salvage value at year $H$ equal to the unexpired-life fraction times $K$. If the final instance ends exactly at $H$, the salvage is zero. Analogously, the long-lived resource is replaced as necessary to cover $H$; any remaining life of the last instance at $H$ yields salvage in the same manner.\n- All cash flows occur at the end of each year. Capital costs $K$ are incurred at the end of the year of installation, and annual net operating cash flows $(B - C)$ occur at the end of each active year. Salvage, if any, occurs at the end of year $H$.\n- All values are in United States dollars (USD). You must report all final numerical quantities in USD where applicable and dimensionless quantities as pure decimals. Angles are not involved.\n\nYour tasks:\n1. For each test case described below, implement a function that, given $r$, computes the net present value in USD of each resource plan over the horizon $H$ using the above principles. Then, for a specified grid of discount rates, determine the proportion (expressed as a decimal between $0$ and $1$) of discount rates for which the long-lived plan has strictly higher net present value than the short-lived plan. In the event of equality (to within a tolerance $\\varepsilon = 10^{-9}$), count it as $0.5$ toward the proportion.\n2. For each test case, determine the break-even discount rate $r^\\star \\in [0,1)$, if it exists, at which the net present values of the long-lived and short-lived plans are equal. If there is no such $r^\\star$ in $[0,1)$, return $-1.0$. Use a robust numerical method grounded in first principles and continuity to identify $r^\\star$.\n3. Sensitivity analysis output: For each test case, return a pair of floats: the proportion as described in Task 1 and the break-even discount rate from Task 2. The final program output must aggregate the results for all test cases into a single line of output containing the results as a comma-separated list enclosed in square brackets. Numbers must be rounded to six decimal places.\n\nTest suite:\nUse the following three test cases with specified parameters and the common discount rate grid $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$ (dimensionless decimals):\n\n- Test Case 1 (happy path with different lifetimes and moderate cash flows):\n    - Planning horizon: $H = 30$ years.\n    - Long-lived resource: lifetime $L_{\\mathrm{long}} = 25$ years, capital cost $K_{\\mathrm{long}} = 1200$ USD, annual benefit $B = 220$ USD/year, annual operating cost $C_{\\mathrm{long}} = 70$ USD/year.\n    - Short-lived resource: lifetime $L_{\\mathrm{short}} = 10$ years, capital cost $K_{\\mathrm{short}} = 700$ USD, annual benefit $B = 220$ USD/year, annual operating cost $C_{\\mathrm{short}} = 80$ USD/year.\n\n- Test Case 2 (boundary-dominance case designed so that one plan likely dominates across discount rates):\n    - Planning horizon: $H = 30$ years.\n    - Long-lived resource: lifetime $L_{\\mathrm{long}} = 30$ years, capital cost $K_{\\mathrm{long}} = 800$ USD, annual benefit $B = 230$ USD/year, annual operating cost $C_{\\mathrm{long}} = 60$ USD/year.\n    - Short-lived resource: lifetime $L_{\\mathrm{short}} = 10$ years, capital cost $K_{\\mathrm{short}} = 850$ USD, annual benefit $B = 230$ USD/year, annual operating cost $C_{\\mathrm{short}} = 80$ USD/year.\n\n- Test Case 3 (edge case with multiple replacements and significant salvage):\n    - Planning horizon: $H = 30$ years.\n    - Long-lived resource: lifetime $L_{\\mathrm{long}} = 35$ years, capital cost $K_{\\mathrm{long}} = 1500$ USD, annual benefit $B = 210$ USD/year, annual operating cost $C_{\\mathrm{long}} = 70$ USD/year.\n    - Short-lived resource: lifetime $L_{\\mathrm{short}} = 7$ years, capital cost $K_{\\mathrm{short}} = 500$ USD, annual benefit $B = 210$ USD/year, annual operating cost $C_{\\mathrm{short}} = 90$ USD/year.\n\nScientific realism and consistency:\n- Assume real (inflation-adjusted) dollars. Do not include taxes or depreciation beyond the proportional salvage rule. Assume perfect reliability and identical annual service for each resource when active.\n\nPrecision and formatting requirements:\n- Use $\\varepsilon = 10^{-9}$ for equality tolerance in ranking determination.\n- Use $r^\\star$ search interval $[0, 0.9]$. If no sign change is observed over this interval for the net present value difference, return $-1.0$.\n- Round all reported floats to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: $[\\text{prop}_1, r^\\star_1, \\text{prop}_2, r^\\star_2, \\text{prop}_3, r^\\star_3]$, where $\\text{prop}_i$ is the proportion for Test Case $i$ and $r^\\star_i$ is the break-even discount rate for Test Case $i$.\n\nYour implementation must be a complete, runnable program using any modern programming language. In your final answer, provide executable Python code that adheres to the specified runtime environment, prints only the required single-line output, and requires no external input.",
            "solution": "We proceed from first principles of intertemporal valuation and the definition of net present value. The fundamental base is the time value of money: a dollar received in the future is worth less today due to time preference and opportunity cost. Let $r \\in [0,1)$ denote the constant real annual discount rate. A cash flow occurring at the end of year $t$ has present value obtained by discounting using $r$, consistent with the principle that the present value operator is multiplicative over time intervals and additive over cash flows occurring at the same time.\n\nDefine a resource plan by parameters $(H, L, K, B, C)$. Each resource instance produces identical annual service from installation through its technical lifetime $L$, after which it must be replaced to maintain service. Over the planning horizon $H$, identical replacements occur at years $y \\in \\{0, L, 2L, \\ldots\\}$ while $y  H$. For each installation at year $y$, there is a capital cost $K$ at the end of year $y$, annual net operating cash flow $(B - C)$ at the end of each active year $t \\in \\{y+1, y+2, \\ldots, \\min(y+L, H)\\}$, and, if the instance extends beyond the horizon, a salvage cash flow at $t = H$ representing the remaining-life fraction times capital cost.\n\nThe salvage value is derived from proportional remaining-life valuation. If an installation occurs at year $y$ and its technical lifetime extends beyond the horizon, the unexpired life at $H$ is $(y + L - H)$ years, so the remaining-life fraction is $\\max\\{y + L - H, 0\\}/L$. The salvage cash flow at $t = H$ is then:\n$$\nS(y) = K \\cdot \\frac{\\max\\{y + L - H, 0\\}}{L}.\n$$\nThis $S(y)$, occurring at the end of year $H$, is discounted like any other cash flow at $t = H$.\n\nLet $CF_t$ denote the net cash flow at the end of year $t$ from all installations combined. By additivity of cash flows and linearity of present value under discounting, the net present value for discount rate $r$ is:\n$$\n\\mathrm{NPV}(r) = \\sum_{t = 0}^{H} \\frac{CF_t}{(1 + r)^t}.\n$$\nTo construct $CF_t$, for each installation at $y$:\n- At $t = y$: add $(-K)$.\n- For each $t \\in \\{y+1, \\ldots, \\min(y+L, H)\\}$: add $(B - C)$.\n- At $t = H$: add $S(y)$ if $y + L  H$.\n\nThis representation enforces identical service across plans by repeated installations for short-lived resources and, if needed, for long-lived resources.\n\nRanking and sensitivity analysis are defined as follows. Given two plans, long-lived and short-lived, with respective parameter sets, define their net present values as functions $\\mathrm{NPV}_{\\mathrm{long}}(r)$ and $\\mathrm{NPV}_{\\mathrm{short}}(r)$. For a grid of discount rates $R = \\{r_1, r_2, \\ldots, r_m\\}$, compute the proportion of rates where the long-lived plan strictly dominates by net present value. Formally, with equality tolerance $\\varepsilon = 10^{-9}$ to account for numerical precision, define for each $r \\in R$:\n- If $\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r)  \\varepsilon$, count $1$.\n- If $|\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r)| \\le \\varepsilon$, count $0.5$.\n- Otherwise, count $0$.\nThe proportion is the sum of counts divided by $|R|$ (a pure decimal between $0$ and $1$).\n\nTo compute the break-even discount rate $r^\\star$, consider the continuous function:\n$$\nf(r) = \\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r).\n$$\nUnder the assumptions above, each $\\mathrm{NPV}$ is a finite sum of terms of the form $a_t (1 + r)^{-t}$ with constants $a_t$. Therefore $f(r)$ is continuous and strictly decreasing in $r$ when positive cash flows dominate at later times and negative cash flows (investments) occur earlier, which is common in resource planning. A robust numerical approach is to use bisection on $[0, 0.9]$ when a sign change is observed, i.e., $f(0) \\cdot f(0.9)  0$. If no sign change occurs over $[0, 0.9]$, no root exists in this interval and we report $-1.0$. When bisection applies, iteratively bisect the interval and evaluate $f$ at the midpoint, narrowing the bracket until the interval width or $|f(r)|$ is below a small tolerance; we then report the midpoint as $r^\\star$.\n\nAlgorithmic design:\n1. Implement a function that, given $(H, L, K, B, C)$ and $r$, constructs the sequence $\\{CF_t\\}_{t=0}^{H}$ by iterating over installation times $y \\in \\{0, L, 2L, \\ldots\\}$ with $y  H$, and adding the capital outlay, annual net operating cash flows $(B - C)$ for active years up to $H$, and salvage at $t=H$ according to $S(y)$.\n2. Compute $\\mathrm{NPV}(r)$ as $\\sum_{t=0}^{H} CF_t (1 + r)^{-t}$. Note that for $r = 0$, discount factors reduce to $1$ and the sum is the undiscounted total.\n3. For each test case, define $\\mathrm{NPV}_{\\mathrm{long}}(r)$ and $\\mathrm{NPV}_{\\mathrm{short}}(r)$ using their respective parameters. For the rate grid $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$, calculate the proportion of rates where the long-lived plan strictly dominates, with equality counting as $0.5$ and tolerance $\\varepsilon = 10^{-9}$.\n4. For break-even $r^\\star$, evaluate $f(0)$ and $f(0.9)$. If there is a sign change, perform bisection to find $r^\\star$ to high precision (e.g., until interval width is below $10^{-12}$ or $|f(r)|$ is below $10^{-12}$). If no sign change, set $r^\\star = -1.0$.\n5. Format outputs: For each test case, round the proportion and $r^\\star$ to six decimal places and aggregate into a single line of output in the specified format.\n\nScientific realism is ensured by consistent annual benefits and costs, real-dollar discounting, equality of delivered service via repeated replacements, and salvage computed by proportional remaining life. The numerical methodology relies on continuity of present value functions in $r$ and uses a robust bracketing method for root-finding, avoiding reliance on non-principled shortcuts.\n\nThe final program computes, for each test case, the proportion of discount rates favoring the long-lived plan and the break-even discount rate (or $-1.0$ if not applicable), and prints them as a single bracketed comma-separated list rounded to six decimals.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_cash_flows(H: int, L: int, K: float, B: float, C: float) - np.ndarray:\n    \"\"\"\n    Construct the annual cash flow vector CF[0..H] for a resource plan defined by:\n    - Planning horizon H (years)\n    - Lifetime L (years)\n    - Capital cost K (USD)\n    - Annual benefit B (USD/year)\n    - Annual OM cost C (USD/year)\n\n    Convention:\n    - All flows occur at year-end.\n    - Installation at year y incurs -K at t=y.\n    - Net operating cash flow (B - C) occurs at end of active years t in [y+1, min(y+L, H)].\n    - Salvage occurs at t=H for installations whose lifetime extends beyond H:\n        S(y) = K * max(y + L - H, 0) / L\n    \"\"\"\n    CF = np.zeros(H + 1, dtype=float)\n    # Installation years: 0, L, 2L, ..., while y  H\n    y = 0\n    while y  H:\n        # Capital outlay at year y\n        CF[y] += -K\n        # Annual net operating cash flows for active years until horizon\n        active_end = min(y + L, H)\n        # Operating flows at end of years y+1 .. active_end\n        if active_end = y + 1:\n            CF[y + 1:active_end + 1] += (B - C)\n        # Salvage at end of horizon if lifetime extends beyond H\n        if y + L  H:\n            remaining_life = (y + L) - H  # positive if extends beyond H\n            salvage = K * (remaining_life / L)\n            CF[H] += salvage\n        # Next installation\n        y += L\n    return CF\n\ndef npv_of_plan(CF: np.ndarray, r: float) - float:\n    \"\"\"\n    Compute NPV given cash flow vector CF[0..H] and discount rate r in [0,1).\n    All flows are at year-end, discounted by (1 + r)^t.\n    \"\"\"\n    H = len(CF) - 1\n    if r == 0.0:\n        return float(np.sum(CF))\n    # Use stable computation for discount factors\n    t = np.arange(H + 1, dtype=float)\n    discount = np.power(1.0 + r, -t)\n    return float(np.dot(CF, discount))\n\ndef proportion_long_wins(npv_long, npv_short, rates, eps=1e-9) - float:\n    \"\"\"\n    Compute the proportion of rates where long-lived plan wins:\n    - Count 1 if NPV_long - NPV_short  eps\n    - Count 0.5 if abs difference = eps\n    - Count 0 if NPV_long - NPV_short  -eps\n    Return sum(counts) / len(rates).\n    \"\"\"\n    total = 0.0\n    for r in rates:\n        dl = npv_long(r)\n        ds = npv_short(r)\n        diff = dl - ds\n        if diff  eps:\n            total += 1.0\n        elif abs(diff) = eps:\n            total += 0.5\n        else:\n            total += 0.0\n    return total / len(rates)\n\ndef break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200) - float:\n    \"\"\"\n    Find r* in [r_low, r_high] such that NPV_long(r*) == NPV_short(r*),\n    using bisection if a sign change exists. If no sign change, return -1.0.\n    \"\"\"\n    def f(r):\n        return npv_long(r) - npv_short(r)\n    f_low = f(r_low)\n    f_high = f(r_high)\n    # If no sign change, no root in [r_low, r_high]\n    if f_low == 0.0:\n        return r_low\n    if f_high == 0.0:\n        return r_high\n    if f_low * f_high  0.0:\n        return -1.0\n    a, b = r_low, r_high\n    fa, fb = f_low, f_high\n    for _ in range(max_iter):\n        m = 0.5 * (a + b)\n        fm = f(m)\n        # Check convergence\n        if abs(fm)  tol or (b - a)  tol:\n            return m\n        # Update bracket\n        if fa * fm = 0.0:\n            b, fb = m, fm\n        else:\n            a, fa = m, fm\n    # Return midpoint after max_iter\n    return 0.5 * (a + b)\n\ndef format_float(x: float) - str:\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define discount rate grid\n    rates = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]\n\n    # Test cases parameters\n    test_cases = [\n        # (H, (L_long, K_long, B, C_long), (L_short, K_short, B, C_short))\n        (30, (25, 1200.0, 220.0, 70.0), (10, 700.0, 220.0, 80.0)),  # Test Case 1\n        (30, (30, 800.0, 230.0, 60.0), (10, 850.0, 230.0, 80.0)),  # Test Case 2\n        (30, (35, 1500.0, 210.0, 70.0), (7, 500.0, 210.0, 90.0)),  # Test Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        H, long_params, short_params = case\n        L_long, K_long, B_long, C_long = long_params\n        L_short, K_short, B_short, C_short = short_params\n\n        # Build cash flows for both plans\n        CF_long = build_cash_flows(H, L_long, K_long, B_long, C_long)\n        CF_short = build_cash_flows(H, L_short, K_short, B_short, C_short)\n\n        # Define NPV functions as closures over r\n        npv_long = lambda r, CF=CF_long: npv_of_plan(CF, r)\n        npv_short = lambda r, CF=CF_short: npv_of_plan(CF, r)\n\n        # Proportion of rates where long-lived wins\n        prop = proportion_long_wins(npv_long, npv_short, rates, eps=1e-9)\n\n        # Break-even discount rate via bisection on [0, 0.9]\n        r_star = break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200)\n\n        results.append(format_float(prop))\n        results.append(format_float(r_star))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "After mastering the \"when\" of investment, we turn to the \"where.\" Simple \"copperplate\" models that assume power can move anywhere without cost or constraint are useful for initial analysis but can produce deeply flawed results, especially in systems with high penetrations of location-dependent renewables. This practice  introduces the linearized DC power flow model to incorporate network constraints, allowing you to quantify the significant cost underestimation and planning errors that arise from ignoring the physical realities of the grid.",
            "id": "4097904",
            "problem": "You are tasked with implementing and solving a pair of linear programs that represent a stylized Integrated Resource Planning (IRP) problem for a power system with high Variable Renewable Energy (VRE) penetration, comparing a copperplate (no transmission limits) formulation against a network-constrained formulation using the linearized Direct Current (DC) power flow model. Your program must compute, for a set of test cases, the relative cost underestimation that arises when spatial constraints are ignored. The comparison must be purely mathematical, using the following fundamental bases: conservation of power (Kirchhoff’s Current Law), linearized DC power flow relations, and linear costs for capacity and generation.\n\nModeling primitives and units:\n- Decision variables per node $n$:\n  - VRE capacity $K^{\\mathrm{vre}}_n$ in $\\mathrm{MW}$.\n  - Firm (gas) capacity $K^{\\mathrm{gas}}_n$ in $\\mathrm{MW}$.\n- Operational variables per node $n$ and time slice $t$:\n  - VRE dispatch $g^{\\mathrm{vre}}_{n,t}$ in $\\mathrm{MW}$.\n  - Gas dispatch $g^{\\mathrm{gas}}_{n,t}$ in $\\mathrm{MW}$.\n  - Unserved energy (load shedding) $\\ell_{n,t}$ in $\\mathrm{MW}$.\n  - Voltage phase angle $\\theta_{n,t}$ in radians (use radians).\n- Operational variables per transmission line $\\ell$ and time slice $t$:\n  - Power flow $f_{\\ell,t}$ in $\\mathrm{MW}$.\n- Transmission network:\n  - Each line $\\ell$ connects ordered node pair $(i(\\ell), j(\\ell))$ with susceptance $b_\\ell$ in $\\mathrm{MW/rad}$ and thermal limit $F^{\\max}_\\ell$ in $\\mathrm{MW}$.\n  - Linearized DC relation: $f_{\\ell,t} = b_\\ell \\left(\\theta_{i(\\ell),t} - \\theta_{j(\\ell),t}\\right)$.\n  - Nodal power balance (Kirchhoff’s Current Law) at each node $n$ and time $t$: $g^{\\mathrm{vre}}_{n,t} + g^{\\mathrm{gas}}_{n,t} - d_{n,t} - \\ell_{n,t} - \\sum_{\\ell} A_{n\\ell} f_{\\ell,t} = 0$, where $A$ is the node–line incidence matrix with $A_{n\\ell} = 1$ if line $\\ell$ leaves node $n$, $A_{n\\ell} = -1$ if it enters node $n$, and $A_{n\\ell} = 0$ otherwise.\n- Physical and operational limits:\n  - $0 \\le g^{\\mathrm{vre}}_{n,t} \\le K^{\\mathrm{vre}}_n \\cdot r_{n,t}$, where $r_{n,t}$ is the VRE availability factor (dimensionless, between $0$ and $1$).\n  - $0 \\le g^{\\mathrm{gas}}_{n,t} \\le K^{\\mathrm{gas}}_n$.\n  - $0 \\le \\ell_{n,t}$ with an associated penalty cost to discourage non-served load.\n  - For each line and time: $-F^{\\max}_\\ell \\le f_{\\ell,t} \\le F^{\\max}_\\ell$.\n  - For each time slice $t$, fix one reference bus angle (choose node $0$) as $\\theta_{0,t} = 0$ radians to ground the DC system; other $\\theta_{n,t}$ are in radians.\n- Objective (annualized total cost):\n  - Minimize $C = \\sum_n \\left(c^{\\mathrm{inv}}_{\\mathrm{vre},n} K^{\\mathrm{vre}}_n + c^{\\mathrm{inv}}_{\\mathrm{gas},n} K^{\\mathrm{gas}}_n\\right) + \\sum_t h_t \\sum_n \\left(c^{\\mathrm{var}}_{\\mathrm{gas}} \\, g^{\\mathrm{gas}}_{n,t} + c^{\\mathrm{shed}} \\, \\ell_{n,t}\\right)$,\n  where $c^{\\mathrm{inv}}_{\\mathrm{vre},n}$ and $c^{\\mathrm{inv}}_{\\mathrm{gas},n}$ are in $\\$ / \\mathrm{MW\\!-\\!yr}$, $c^{\\mathrm{var}}_{\\mathrm{gas}}$ and $c^{\\mathrm{shed}}$ are in $\\$ / \\mathrm{MWh}$, and $h_t$ is the number of hours represented by time slice $t$ in $\\mathrm{h}$.\n\nCopperplate versus network-constrained planning:\n- Copperplate planning is modeled by relaxing all transmission limits to be effectively infinite, i.e., for each line $\\ell$, set $F^{\\max}_\\ell$ to a very large value, while keeping the DC power flow equations. This removes binding spatial constraints on power transfers.\n- Network-constrained planning uses the provided finite $F^{\\max}_\\ell$ values.\n\nError metric to quantify the effect of ignoring spatial constraints:\n- For each test case, compute $C^{\\mathrm{net}}$ as the optimal cost under network-constrained planning and $C^{\\mathrm{cop}}$ as the optimal cost under copperplate planning. Report the relative underestimation due to ignoring spatial constraints as a decimal: $E = \\dfrac{C^{\\mathrm{net}} - C^{\\mathrm{cop}}}{C^{\\mathrm{net}}}$.\n\nAngle unit: All angles $\\theta_{n,t}$ are in radians.\n\nPhysical units: Powers in $\\mathrm{MW}$, energies in $\\mathrm{MWh}$, costs in $\\$$. Express $E$ as a decimal (no percent sign).\n\nYour program must solve the linear programs exactly as specified and produce the results for the following three test cases. Each case uses the same nodes, time slices, costs, and profiles, but different transmission limits.\n\nGlobal data common to all test cases:\n- Nodes: $N = 2$, indexed $n \\in \\{0, 1\\}$.\n- Time slices: $T = 3$, indexed $t \\in \\{0, 1, 2\\}$ with durations $h_0 = 2920 \\, \\mathrm{h}$, $h_1 = 2920 \\, \\mathrm{h}$, $h_2 = 2920 \\, \\mathrm{h}$.\n- One transmission line $\\ell = 0$ connecting $i(0) = 0$ to $j(0) = 1$, susceptance $b_0 = 1.0 \\, \\mathrm{MW/rad}$.\n- Demands in $\\mathrm{MW}$:\n  - Node $0$: $[20, 20, 20]$.\n  - Node $1$: $[80, 80, 80]$.\n- VRE availability factors (dimensionless):\n  - Node $0$: $[0.9, 0.1, 0.4]$.\n  - Node $1$: $[0.2, 0.4, 0.3]$.\n- Investment costs in $\\$ / \\mathrm{MW\\!-\\!yr}$:\n  - VRE at each node: $c^{\\mathrm{inv}}_{\\mathrm{vre},0} = 100{,}000$, $c^{\\mathrm{inv}}_{\\mathrm{vre},1} = 100{,}000$.\n  - Gas at each node: $c^{\\mathrm{inv}}_{\\mathrm{gas},0} = 60{,}000$, $c^{\\mathrm{inv}}_{\\mathrm{gas},1} = 60{,}000$.\n- Variable costs in $\\$ / \\mathrm{MWh}$:\n  - Gas: $c^{\\mathrm{var}}_{\\mathrm{gas}} = 40$.\n  - Load shedding penalty: $c^{\\mathrm{shed}} = 10{,}000$.\n- Angle reference: For each time slice $t$, enforce $\\theta_{0,t} = 0$ radians.\n\nTest suite specifying line limits $F^{\\max}_0$ in $\\mathrm{MW}$:\n- Case A (moderately constrained): $F^{\\max}_0 = 50$.\n- Case B (unconstrained network boundary): $F^{\\max}_0 = 1{,}000{,}000$.\n- Case C (islanded): $F^{\\max}_0 = 0$.\n\nFor each case, solve two linear programs:\n- Network-constrained plan using the given $F^{\\max}_0$.\n- Copperplate plan with the same data but replacing $F^{\\max}_0$ by a very large value (use $F^{\\max}_0 = 1{,}000{,}000$) to approximate infinite transfer capability.\n\nCompute $E = \\dfrac{C^{\\mathrm{net}} - C^{\\mathrm{cop}}}{C^{\\mathrm{net}}}$ for each case as a floating-point number.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C], for example: \"[0.123456,0.000000,0.543210]\".\n- The values must be decimal numbers (no percent sign). Round each value to $6$ decimal places in the printed output.",
            "solution": "The user has provided a well-defined problem in the domain of energy systems modeling, specifically focusing on Integrated Resource Planning (IRP). The task is to quantify the cost underestimation that occurs when transmission network constraints are ignored. This is accomplished by comparing the optimal total system cost from a \"copperplate\" model (infinite transmission capacity) with a network-constrained model using a linearized DC power flow approximation. The problem is formulated as a linear program (LP), which is a standard and appropriate method for this type of analysis.\n\nThe problem is valid as it is scientifically grounded in established principles of power systems engineering and optimization, is well-posed, and provides all necessary data and definitions for a unique solution to be computed.\n\nThe solution approach involves two main steps:\n1.  Formulating the IRP problem as a standard linear program that can be solved using numerical optimization libraries.\n2.  Implementing a program to construct and solve this LP for the specified test cases and compute the required error metric.\n\n### Mathematical Formulation of the Linear Program\n\nThe problem is to minimize a total cost function subject to a set of linear equality and inequality constraints. We first define the decision variables, objective function, and constraints in mathematical terms. For clarity, let $N$ be the number of nodes, $T$ the number of time slices, and $L$ the number of transmission lines.\n\n**1. Decision Variables**\n\nThe decision variables are categorized into investment and operational variables. They are vectorized into a single column vector $\\mathbf{x}$ for the standard LP form. The variables are:\n-   Investment in VRE capacity: $K^{\\mathrm{vre}}_n$ for $n \\in \\{0, \\dots, N-1\\}$.\n-   Investment in gas capacity: $K^{\\mathrm{gas}}_n$ for $n \\in \\{0, \\dots, N-1\\}$.\n-   VRE generation dispatch: $g^{\\mathrm{vre}}_{n,t}$ for $n \\in \\{0, \\dots, N-1\\}$, $t \\in \\{0, \\dots, T-1\\}$.\n-   Gas generation dispatch: $g^{\\mathrm{gas}}_{n,t}$ for $n \\in \\{0, \\dots, N-1\\}$, $t \\in \\{0, \\dots, T-1\\}$.\n-   Load shedding: $\\ell_{n,t}$ for $n \\in \\{0, \\dots, N-1\\}$, $t \\in \\{0, \\dots, T-1\\}$.\n-   Power flow on lines: $f_{\\ell,t}$ for $\\ell \\in \\{0, \\dots, L-1\\}$, $t \\in \\{0, \\dots, T-1\\}$.\n-   Voltage phase angles: $\\theta_{n,t}$ for $n \\in \\{0, \\dots, N-1\\}$, $t \\in \\{0, \\dots, T-1\\}$.\n\nAll these variables must be non-negative, except for the phase angles $\\theta_{n,t}$ and power flows $f_{\\ell,t}$ which are unconstrained in sign (bipolar).\n\n**2. Objective Function**\n\nThe objective is to minimize the total annualized system cost $C$, which is the sum of investment costs and operational costs.\n$$\n\\text{Minimize} \\quad C = \\sum_{n=0}^{N-1} \\left(c^{\\mathrm{inv}}_{\\mathrm{vre},n} K^{\\mathrm{vre}}_n + c^{\\mathrm{inv}}_{\\mathrm{gas},n} K^{\\mathrm{gas}}_n\\right) + \\sum_{t=0}^{T-1} h_t \\sum_{n=0}^{N-1} \\left(c^{\\mathrm{var}}_{\\mathrm{gas}} \\, g^{\\mathrm{gas}}_{n,t} + c^{\\mathrm{shed}} \\, \\ell_{n,t}\\right)\n$$\nThis is a linear function of the decision variables, which can be written as $\\mathbf{c}^T \\mathbf{x}$ in the standard LP form.\n\n**3. Constraints**\n\nThe constraints ensure that the solution is physically and operationally feasible.\n\n-   **Capacity Constraints:** Generation at any time cannot exceed the installed capacity. For VRE, it is further limited by the time-varying availability factor $r_{n,t}$.\n    $$\n    g^{\\mathrm{vre}}_{n,t} - r_{n,t} K^{\\mathrm{vre}}_n \\le 0 \\quad \\forall n, t\n    $$\n    $$\n    g^{\\mathrm{gas}}_{n,t} - K^{\\mathrm{gas}}_n \\le 0 \\quad \\forall n, t\n    $$\n\n-   **Power Flow Definition (DC Approximation):** The power flow on each line is related to the difference in voltage phase angles at its connecting nodes and the line's susceptance $b_\\ell$.\n    $$\n    f_{\\ell,t} - b_\\ell \\left(\\theta_{i(\\ell),t} - \\theta_{j(\\ell),t}\\right) = 0 \\quad \\forall \\ell, t\n    $$\n    where $i(\\ell)$ and $j(\\ell)$ are the start and end nodes of line $\\ell$.\n\n-   **Nodal Power Balance (Kirchhoff's Current Law):** At each node and for each time slice, the total power injected must equal the total power withdrawn.\n    $$\n    (g^{\\mathrm{vre}}_{n,t} + g^{\\mathrm{gas}}_{n,t} + \\ell_{n,t}) - \\left(d_{n,t} + \\sum_{\\ell=0}^{L-1} A_{n\\ell} f_{\\ell,t}\\right) = 0 \\quad \\forall n, t\n    $$\n    Here, generation and unserved energy are injections, while demand $d_{n,t}$ and net power outflow are withdrawals. The term $\\ell_{n,t}$ is mathematically treated as a generator that meets the demand which could not be served by other resources, at a high cost. A more conventional formulation is presented in the problem statement, which is algebraically equivalent:\n    $$\n    g^{\\mathrm{vre}}_{n,t} + g^{\\mathrm{gas}}_{n,t} - \\ell_{n,t} - \\sum_{\\ell=0}^{L-1} A_{n\\ell} f_{\\ell,t} = d_{n,t} \\quad \\forall n, t\n    $$\n\n-   **Transmission Line Thermal Limits:** The power flow on each line must not exceed its thermal capacity $F^{\\max}_\\ell$.\n    $$\n    -F^{\\max}_\\ell \\le f_{\\ell,t} \\le F^{\\max}_\\ell \\quad \\forall \\ell, t\n    $$\n\n-   **Reference Angle:** To obtain a unique solution for the phase angles, one angle per connected electrical system per time slice is fixed to a reference value, typically $0$.\n    $$\n    \\theta_{0,t} = 0 \\quad \\forall t\n    $$\n\n**Implementation using `scipy.optimize.linprog`**\n\nTo solve this LP using `scipy.optimize.linprog`, we must convert the problem into the standard form:\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  \\mathbf{c}^T \\mathbf{x} \\\\\n\\text{subject to} \\quad  A_{\\text{ub}} \\mathbf{x} \\le \\mathbf{b}_{\\text{ub}} \\\\\n A_{\\text{eq}} \\mathbf{x} = \\mathbf{b}_{\\text{eq}} \\\\\n \\mathbf{lb} \\le \\mathbf{x} \\le \\mathbf{ub}\n\\end{aligned}\n$$\nThis requires a systematic mapping of our problem variables to the vector $\\mathbf{x}$ and the construction of the corresponding matrices ($A_{\\text{ub}}$, $A_{\\text{eq}}$) and vectors ($\\mathbf{c}$, $\\mathbf{b}_{\\text{ub}}$, $\\mathbf{b}_{\\text{eq}}$, $\\mathbf{lb}$, $\\mathbf{ub}$). The Python code implements this mapping and construction. For each test case, we solve two versions of the LP:\n1.  **Network-constrained ($C^{\\mathrm{net}}$):** Using the specific $F^{\\max}_0$ value provided for the case.\n2.  **Copperplate ($C^{\\mathrm{cop}}$):** Using a very large value for $F^{\\max}_0$ ($10^6$ MW as specified) to simulate unconstrained transmission.\n\nThe final error metric $E = (C^{\\mathrm{net}} - C^{\\mathrm{cop}}) / C^{\\mathrm{net}}$ is then calculated for each case. For Case B, where the network constraint is already non-binding, we expect $C^{\\mathrm{net}} \\approx C^{\\mathrm{cop}}$ and thus $E \\approx 0$. For Case C (islanding), we expect the largest cost difference and thus the highest value of $E$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the IRP problem for three test cases and calculates the relative cost\n    underestimation due to ignoring spatial constraints.\n    \"\"\"\n    \n    # Global data common to all test cases\n    N = 2  # Nodes\n    T = 3  # Time slices\n    L = 1  # Transmission lines\n    \n    h = np.array([2920., 2920., 2920.])\n    d = np.array([[20., 20., 20.], [80., 80., 80.]]) # d[n, t]\n    r = np.array([[0.9, 0.1, 0.4], [0.2, 0.4, 0.3]]) # r[n, t]\n    \n    c_inv_vre = np.array([100000., 100000.])\n    c_inv_gas = np.array([60000., 60000.])\n    c_var_gas = 40.\n    c_shed = 10000.\n    \n    b_line = np.array([1.0]) # Susceptance b_l\n    line_nodes = np.array([[0, 1]]) # from, to\n\n    # Test suite: line limits F_max_0 in MW\n    test_cases = [\n        {'name': 'A', 'F_max_net': 50.},\n        {'name': 'B', 'F_max_net': 1000000.},\n        {'name': 'C', 'F_max_net': 0.},\n    ]\n    \n    F_max_cop = 1000000.\n    \n    results = []\n    \n    for case in test_cases:\n        F_max_net = case['F_max_net']\n        \n        # Solve for the network-constrained case\n        res_net = solve_irp_lp(N, T, L, h, d, r, c_inv_vre, c_inv_gas, \n                               c_var_gas, c_shed, b_line, line_nodes, F_max_net)\n        C_net = res_net.fun\n        \n        # Solve for the copperplate case\n        res_cop = solve_irp_lp(N, T, L, h, d, r, c_inv_vre, c_inv_gas, \n                               c_var_gas, c_shed, b_line, line_nodes, F_max_cop)\n        C_cop = res_cop.fun\n        \n        if C_net == 0:\n            error = 0.0 # Avoid division by zero, though unlikely\n        else:\n            error = (C_net - C_cop) / C_net\n            \n        # Due to solver tolerances, small negative numbers close to zero can appear for E.\n        # This occurs when C_net and C_cop are theoretically equal.\n        if abs(error)  1e-9:\n             error = 0.0\n\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_irp_lp(N, T, L, h, d, r, c_inv_vre, c_inv_gas, c_var_gas, c_shed, \n                 b_line, line_nodes, F_max):\n    \"\"\"\n    Constructs and solves the linear program for the IRP problem.\n    \"\"\"\n    \n    # --- Variable Indexing ---\n    # K_vre, K_gas, g_vre, g_gas, l_shed, f_flow, theta\n    \n    num_vars = (N * 2) + (N * T * 2) + (N * T) + (L * T) + (N * T)\n    \n    # Helper functions for indexing\n    def idx_k_vre(n): return n\n    def idx_k_gas(n): return N + n\n    def idx_g_vre(n, t): return 2 * N + t * N + n\n    def idx_g_gas(n, t): return 2 * N + T * N + t * N + n\n    def idx_l_shed(n, t): return 2 * N + 2 * T * N + t * N + n\n    def idx_f_flow(l, t): return 2 * N + 3 * T * N + t * L + l\n    def idx_theta(n, t): return 2 * N + 3 * T * N + T * L + t * N + n\n\n    # --- Objective Function Vector (c) ---\n    c = np.zeros(num_vars)\n    for n in range(N):\n        c[idx_k_vre(n)] = c_inv_vre[n]\n        c[idx_k_gas(n)] = c_inv_gas[n]\n    for t in range(T):\n        for n in range(N):\n            c[idx_g_gas(n, t)] = h[t] * c_var_gas\n            c[idx_l_shed(n, t)] = h[t] * c_shed\n\n    # --- Bounds ---\n    bounds = [(0, None)] * num_vars\n    # Angles and flows can be negative\n    for t in range(T):\n        for l in range(L):\n            bounds[idx_f_flow(l, t)] = (None, None)\n        for n in range(N):\n            if n != 0: # Node 0 is the reference\n                bounds[idx_theta(n, t)] = (None, None)\n    # Reference angle\n    for t in range(T):\n        bounds[idx_theta(0, t)] = (0, 0)\n\n    # --- Constraints ---\n    \n    # Equality constraints (A_eq, b_eq)\n    num_eq_cons = (T * L) + (T * N) # Flow def + KCL\n    A_eq = np.zeros((num_eq_cons, num_vars))\n    b_eq = np.zeros(num_eq_cons)\n    eq_row = 0\n    \n    # Power flow definition\n    for t in range(T):\n        for l in range(L):\n            A_eq[eq_row, idx_f_flow(l, t)] = 1\n            from_node = line_nodes[l, 0]\n            to_node = line_nodes[l, 1]\n            A_eq[eq_row, idx_theta(from_node, t)] = -b_line[l]\n            A_eq[eq_row, idx_theta(to_node, t)] = b_line[l]\n            b_eq[eq_row] = 0\n            eq_row += 1\n\n    # Nodal power balance (KCL)\n    # The problem description is: g_vre + g_gas - d - l_shed - sum(A*f) = 0\n    # Rearranging for solver: g_vre + g_gas - l_shed - sum(A*f) = d\n    A_nl = np.zeros((N, L))\n    for l in range(L):\n        A_nl[line_nodes[l, 0], l] = 1\n        A_nl[line_nodes[l, 1], l] = -1\n\n    for t in range(T):\n        for n in range(N):\n            A_eq[eq_row, idx_g_vre(n, t)] = 1\n            A_eq[eq_row, idx_g_gas(n, t)] = 1\n            # In the KCL, shed load `l` is on the demand side of the balance.\n            # g_vre + g_gas = d + l_shed + flow_out\n            # The problem gives KCL as: g_vre + g_gas - d - l_shed - sum(A*f) = 0\n            # My solver setup uses g+gg-lshed-flow = d, so I should be consistent.\n            # My previous setup had g+gg+lshed = d+flow. \n            # The problem's KCL is more standard for optimization. Let's use it.\n            # g_vre + g_gas - l_shed - sum(A*f) = d\n            A_eq[eq_row, idx_l_shed(n, t)] = -1 # load shed is demand NOT met.\n            for l in range(L):\n                A_eq[eq_row, idx_f_flow(l,t)] -= A_nl[n, l]\n            b_eq[eq_row] = d[n, t] # demand is on the RHS.\n            eq_row += 1\n            \n    # Inequality constraints (A_ub, b_ub)\n    num_ub_cons = (T * N) * 2 + (T * L) * 2 # VRE/Gas dispatch + Flow limits\n    A_ub = np.zeros((num_ub_cons, num_vars))\n    b_ub = np.zeros(num_ub_cons)\n    ub_row = 0\n    \n    # Dispatch capacity limits\n    for t in range(T):\n        for n in range(N):\n            # VRE: g_vre = r * K_vre  =  g_vre - r*K_vre = 0\n            A_ub[ub_row, idx_g_vre(n, t)] = 1\n            A_ub[ub_row, idx_k_vre(n)] = -r[n, t]\n            b_ub[ub_row] = 0\n            ub_row += 1\n            # Gas: g_gas = K_gas  =  g_gas - K_gas = 0\n            A_ub[ub_row, idx_g_gas(n, t)] = 1\n            A_ub[ub_row, idx_k_gas(n)] = -1\n            b_ub[ub_row] = 0\n            ub_row += 1\n    \n    # Flow limits\n    for t in range(T):\n        for l in range(L):\n            # f = F_max\n            A_ub[ub_row, idx_f_flow(l, t)] = 1\n            b_ub[ub_row] = F_max\n            ub_row += 1\n            # -f = F_max  = f = -F_max\n            A_ub[ub_row, idx_f_flow(l, t)] = -1\n            b_ub[ub_row] = F_max\n            ub_row += 1\n\n    # --- Solve LP ---\n    # The 'highs' method is robust and generally faster for such problems.\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, \n                     bounds=bounds, method='highs')\n    \n    return result\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Modern energy planning is rarely about a single objective; it is a complex exercise in balancing competing goals, such as economic efficiency, system reliability, and environmental stewardship. This practice  moves beyond simple cost minimization to a bi-objective framework, tasking you with simultaneously optimizing for both system cost and CO2 emissions. By implementing the weighted-sum and epsilon-constraint methods, you will learn to generate a Pareto front, which maps the trade-offs between these goals and provides policymakers with a portfolio of optimal choices rather than a single prescriptive answer.",
            "id": "4097887",
            "problem": "Consider an Integrated Resource Planning (IRP) problem for a power system with two planning periods and two generation technologies. The objective is to construct and solve a bi-objective linear optimization model that simultaneously minimizes discounted cost and cumulative Carbon Dioxide (CO2) emissions, and then to generate approximate Pareto fronts using the Weighted Sum Method (WSM) and the Epsilon-Constraint (EC) method.\n\nThe fundamental base shall be the following accepted facts and definitions. Discounted cash flow uses Net Present Value (NPV), where cash flows at time index $t$ are multiplied by a discount factor $d_t = \\frac{1}{(1+r)^{\\Delta t_t}}$ for a constant real discount rate $r$ and period spacing $\\Delta t_t$. Cumulative emissions are the sum of period emissions without discounting. Annual generation must meet demand exactly in each period, and is limited by installed capacity times the annual energy per unit capacity, which is derived from the product of $8{,}760$ hours per year and the technology-specific capacity factor. Multi-Objective Optimization (MOO) seeks solutions that are Pareto efficient, where no objective can be improved without worsening another, and scalarization techniques such as Weighted Sum Method (WSM) and Epsilon-Constraint (EC) are commonly used to generate points on or near the Pareto front.\n\nModel structure and decision variables: Let the planning periods be indexed by $t \\in \\{1,2\\}$, corresponding to the years $2025$ and $2030$, respectively, and technologies $k \\in \\{\\text{gas}, \\text{wind}\\}$. Let $x_{k,t} \\ge 0$ denote capacity additions in megawatts (MW) for technology $k$ in period $t$. Let $c_{k,t} \\ge 0$ denote the total available capacity in MW for technology $k$ in period $t$, which accumulates capacity additions across periods. Let $y_{k,t} \\ge 0$ denote the annual energy generation in megawatt-hours (MWh) for technology $k$ in period $t$. The capacity accumulation is represented by $c_{k,1} = x_{k,1}$ and $c_{k,2} = c_{k,1} + x_{k,2}$. Annual energy balance requires $y_{\\text{gas},t} + y_{\\text{wind},t} = D_t$, with $D_t$ given. Annual generation limits are $y_{k,t} \\le E_k \\cdot c_{k,t}$, where $E_k$ is the annual energy per MW for technology $k$.\n\nParameters and physical realism: Use discount rate $r = 0.07$ and period spacing $\\Delta t_1 = 0$, $\\Delta t_2 = 5$, yielding discount factors $d_1 = 1$ and $d_2 = \\frac{1}{(1+0.07)^5}$. Demands are $D_1 = 4{,}000$ MWh and $D_2 = 5{,}000$ MWh. Technology parameters are:\nInvestment cost per MW: $I_{\\text{gas}} = 900{,}000$ United States dollars per MW, $I_{\\text{wind}} = 1{,}400{,}000$ United States dollars per MW.\nVariable operating cost per MWh: $V_{\\text{gas}} = 50$ United States dollars per MWh, $V_{\\text{wind}} = 5$ United States dollars per MWh.\nEmission rate per MWh: $e_{\\text{gas}} = 0.4$ metric tonnes of CO2 per MWh, $e_{\\text{wind}} = 0$ metric tonnes of CO2 per MWh.\nAnnual energy per MW: $E_{\\text{gas}} = 8{,}760 \\times 0.6 = 5{,}256$ MWh per MW-year, $E_{\\text{wind}} = 8{,}760 \\times 0.35 = 3{,}066$ MWh per MW-year.\n\nObjectives: Define discounted total system cost as the sum over periods of discounted investment and operating costs, that is, period $t$ terms using $d_t$, investment using $I_{k}$ times $x_{k,t}$, and operating cost using $V_{k}$ times $y_{k,t}$. Define cumulative emissions as the sum over periods of $e_{k} \\cdot y_{k,t}$ without discounting.\n\nMethods to generate Pareto fronts:\nWeighted Sum Method (WSM): Construct a single-objective scalarization with a weight $w \\in [0,1]$ placed on discounted cost and weight $(1-w)$ on cumulative emissions to obtain candidate Pareto-efficient solutions.\nEpsilon-Constraint (EC): Minimize discounted cost subject to a constraint that cumulative emissions do not exceed a specified bound $\\epsilon \\ge 0$.\n\nTasks:\n1. Formulate the bi-objective optimization using the variables and constraints stated above from first principles, and implement both WSM and EC computational approaches to find candidate Pareto points.\n2. Use the parameter values specified above.\n3. Units: Report discounted total cost in United States dollars and cumulative emissions in metric tonnes of CO2. Round both reported quantities to two decimal places.\n4. Test Suite: For WSM, solve the scalarized problem for weights $w \\in \\{0, 0.5, 1\\}$. For EC, solve the constrained problem for emission bounds $\\epsilon \\in \\{0, 100, 1{,}000, 3{,}600\\}$.\n5. Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list must itself be a two-element list of floats $[C, E]$ representing discounted total cost $C$ (in United States dollars) and cumulative emissions $E$ (in metric tonnes of CO2), ordered first by the WSM test cases with $w = 0$, then $w = 0.5$, then $w = 1$, followed by the EC test cases with $\\epsilon = 0$, then $\\epsilon = 100$, then $\\epsilon = 1{,}000$, then $\\epsilon = 3{,}600$. If a case is infeasible, represent its result by $[\\text{NaN}, \\text{NaN}]$. The final single printed line must match the format example $[[c_1,e_1],[c_2,e_2],\\dots]$ with no spaces, and numbers rounded to two decimal places.",
            "solution": "The user-provided problem has been analyzed and validated against the specified criteria.\n\n### Step 1: Extract Givens\n-   **Indices**: Periods $t \\in \\{1, 2\\}$, Technologies $k \\in \\{\\text{gas}, \\text{wind}\\}$.\n-   **Decision Variables**:\n    -   $x_{k,t} \\ge 0$: Capacity additions (MW) for technology $k$ in period $t$.\n    -   $c_{k,t} \\ge 0$: Total capacity (MW) for technology $k$ in period $t$.\n    -   $y_{k,t} \\ge 0$: Annual energy generation (MWh) for technology $k$ in period $t$.\n-   **Model Equations**:\n    -   Capacity accumulation: $c_{k,1} = x_{k,1}$, $c_{k,2} = c_{k,1} + x_{k,2}$.\n    -   Energy balance: $y_{\\text{gas},t} + y_{\\text{wind},t} = D_t$ for $t \\in \\{1, 2\\}$.\n    -   Generation limits: $y_{k,t} \\le E_k \\cdot c_{k,t}$ for $k, t$.\n-   **Parameters**:\n    -   Discount rate: $r = 0.07$.\n    -   Period spacing: $\\Delta t_1 = 0$, $\\Delta t_2 = 5$ years.\n    -   Discount factors: $d_1 = 1/(1+r)^0 = 1$, $d_2 = 1/(1+r)^5$.\n    -   Demands: $D_1 = 4{,}000$ MWh, $D_2 = 5{,}000$ MWh.\n    -   Investment cost: $I_{\\text{gas}} = 900{,}000$ USD/MW, $I_{\\text{wind}} = 1{,}400{,}000$ USD/MW.\n    -   Variable cost: $V_{\\text{gas}} = 50$ USD/MWh, $V_{\\text{wind}} = 5$ USD/MWh.\n    -   Emission rate: $e_{\\text{gas}} = 0.4$ tCO2/MWh, $e_{\\text{wind}} = 0$ tCO2/MWh.\n    -   Annual energy per MW: $E_{\\text{gas}} = 5{,}256$ MWh/MW, $E_{\\text{wind}} = 3{,}066$ MWh/MW.\n-   **Objectives**:\n    -   Minimize discounted cost: $Z_{cost} = \\sum_{t=1}^2 d_t \\left( \\sum_{k} I_k x_{k,t} + \\sum_{k} V_k y_{k,t} \\right)$.\n    -   Minimize cumulative emissions: $Z_{emissions} = \\sum_{t=1}^2 \\sum_{k} e_k y_{k,t}$.\n-   **Solution Methods**:\n    -   Weighted Sum Method (WSM): Minimize $w \\cdot Z_{cost} + (1-w) \\cdot Z_{emissions}$.\n    -   Epsilon-Constraint (EC) Method: Minimize $Z_{cost}$ subject to $Z_{emissions} \\le \\epsilon$.\n-   **Test Cases**:\n    -   WSM: $w \\in \\{0, 0.5, 1\\}$.\n    -   EC: $\\epsilon \\in \\{0, 100, 1000, 3600\\}$.\n-   **Output Requirements**:\n    -   A single line of text: `[[c1,e1],[c2,e2],...]`.\n    -   Costs and emissions rounded to two decimal places.\n    -   Infeasible cases represented as `[NaN, NaN]`.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Grounding**: The problem is a standard, albeit simplified, energy system capacity expansion model, a classic application within Integrated Resource Planning (IRP). All concepts, including discounted cash flow, emission accounting, capacity factors, and linear optimization, are fundamental to the field. The problem is scientifically and mathematically sound.\n-   **Well-Posedness**: The problem is formulated as a bi-objective linear program. The use of WSM and EC methods transforms it into a series of single-objective linear programs (LPs). A standard LP with a non-empty, bounded feasible region is well-posed and guaranteed to have a solution. The provided data and constraints are sufficient and consistent, allowing for a feasible solution space (e.g., a zero-emission solution is achievable with wind power).\n-   **Objectivity**: The problem is defined with precise mathematical equations and numerical parameters. The language is objective and free of subjective claims.\n-   **Completeness and Consistency**: All parameters, variables, and constraints needed to build the mathematical model are explicitly provided. There are no contradictions in the given data.\n-   **Feasibility**: The parameter values are plausible for an academic exercise. The demands, though small, are positive, making the problem non-trivial. The constraints allow for feasible solutions across the specified range of test cases. For instance, the maximum possible emissions if all demand is met by gas is $0.4 \\times (4000+5000) = 3600$, which matches one of the epsilon bounds, indicating the test suite is well-designed.\n-   **Other Flaws**: The problem is not trivial, metaphorical, or unverifiable. It is a direct application of established optimization techniques to a formalized problem.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-posed, scientifically grounded problem in energy systems modeling that can be solved using linear programming.\n\n### Mathematical Formulation\nThe bi-objective optimization problem is formulated as follows.\n\n**Decision Variables**:\nThe problem involves $12$ continuous, non-negative decision variables:\n-   Capacity additions: $x_{\\text{gas},1}, x_{\\text{gas},2}, x_{\\text{wind},1}, x_{\\text{wind},2}$.\n-   Energy generation: $y_{\\text{gas},1}, y_{\\text{gas},2}, y_{\\text{wind},1}, y_{\\text{wind},2}$.\n-   Total capacity: $c_{\\text{gas},1}, c_{\\text{gas},2}, c_{\\text{wind},1}, c_{\\text{wind},2}$.\n\n**Objective Functions**:\n1.  Minimize discounted total cost ($Z_{cost}$):\n    $$ \\min Z_{cost} = \\sum_{t=1}^{2} d_t \\left( I_{\\text{gas}} x_{\\text{gas},t} + I_{\\text{wind}} x_{\\text{wind},t} + V_{\\text{gas}} y_{\\text{gas},t} + V_{\\text{wind}} y_{\\text{wind},t} \\right) $$\n2.  Minimize cumulative CO2 emissions ($Z_{emissions}$):\n    $$ \\min Z_{emissions} = \\sum_{t=1}^{2} \\left( e_{\\text{gas}} y_{\\text{gas},t} + e_{\\text{wind}} y_{\\text{wind},t} \\right) $$\n\n**Constraints**:\n1.  **Energy Balance**: For each period $t \\in \\{1,2\\}$, total generation must meet demand $D_t$.\n    $$ y_{\\text{gas},1} + y_{\\text{wind},1} = D_1 $$\n    $$ y_{\\text{gas},2} + y_{\\text{wind},2} = D_2 $$\n2.  **Capacity Accumulation**: For each technology $k \\in \\{\\text{gas}, \\text{wind}\\}$, total capacity in a period is the sum of existing and new capacity.\n    $$ c_{k,1} = x_{k,1} $$\n    $$ c_{k,2} = c_{k,1} + x_{k,2} $$\n3.  **Generation Limit**: For each technology $k$ and period $t$, annual generation is limited by its installed capacity and energy availability $E_k$.\n    $$ y_{k,t} \\le E_k \\cdot c_{k,t} $$\n4.  **Non-negativity**: All decision variables must be non-negative.\n    $$ x_{k,t} \\ge 0, y_{k,t} \\ge 0, c_{k,t} \\ge 0 $$\n\n### Scalarization and Implementation Strategy\nThis bi-objective linear program is solved by converting it into a series of single-objective LPs using two scalarization techniques. The LPs are solved using `scipy.optimize.linprog`.\n\n**1. Weighted Sum Method (WSM)**\nA single objective function is created by taking a weighted sum of the two original objectives. The problem becomes:\n$$ \\min \\left( w \\cdot Z_{cost} + (1-w) \\cdot Z_{emissions} \\right) $$\nsubject to the full set of constraints. Here, $w \\in [0,1]$ is the weight assigned to the cost objective. This approach generates points on the convex portion of the Pareto front.\n\n**2. Epsilon-Constraint (EC) Method**\nOne objective is chosen for minimization (here, $Z_{cost}$), while the other ($Z_{emissions}$) is converted into a constraint. The problem is:\n$$ \\min Z_{cost} $$\nsubject to:\n-   All original constraints.\n-   An additional constraint: $Z_{emissions} \\le \\epsilon$, where $\\epsilon$ is the maximum allowable level of emissions.\n\nThis method can find both convex and non-convex parts of the Pareto front.\n\n**Implementation with SciPy**\nThe problem is cast into the standard LP form: $\\min \\mathbf{c}^T \\mathbf{z}$ subject to $\\mathbf{A}_{ub} \\mathbf{z} \\le \\mathbf{b}_{ub}$ and $\\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{b}_{eq}$.\n-   The decision variable vector $\\mathbf{z}$ is a $12 \\times 1$ column vector concatenating all $x, y, c$ variables.\n-   The equality constraint matrix $\\mathbf{A}_{eq}$ ($6 \\times 12$) and vector $\\mathbf{b}_{eq}$ ($6 \\times 1$) enforce the energy balance and capacity accumulation equations.\n-   The inequality constraint matrix $\\mathbf{A}_{ub}$ ($4 \\times 12$) and vector $\\mathbf{b}_{ub}$ ($4 \\times 1$) enforce the generation limits.\n-   For each WSM case, a composite objective vector $\\mathbf{c}$ is constructed from the cost and emission coefficient vectors.\n-   For each EC case, the objective vector $\\mathbf{c}$ is the cost coefficient vector, and the inequality constraint matrix/vector are augmented with a new row representing $Z_{emissions} \\le \\epsilon$.\n-   The `scipy.optimize.linprog` function is called for each test case. If the solver reports infeasibility (`status=2`), the result is recorded as `[NaN, NaN]`. Otherwise, the optimal cost and emissions are calculated from the solution vector $\\mathbf{z}$ and stored. Finally, the results are formatted and printed as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a bi-objective IRP problem using WSM and EC methods.\n    \"\"\"\n\n    # 1. DEFINE PARAMETERS\n    # ---------------------\n    params = {\n        'r': 0.07,\n        'D1': 4000.0,\n        'D2': 5000.0,\n        'I_gas': 900000.0,\n        'I_wind': 1400000.0,\n        'V_gas': 50.0,\n        'V_wind': 5.0,\n        'e_gas': 0.4,\n        'e_wind': 0.0,\n        'E_gas': 8760 * 0.6,\n        'E_wind': 8760 * 0.35,\n    }\n    params['d1'] = 1.0\n    params['d2'] = 1.0 / (1.0 + params['r'])**5\n\n    # 2. DEFINE LP STRUCTURE\n    # ----------------------\n    # Decision variable vector z (12 variables):\n    # z = [x_g1, x_g2, x_w1, x_w2, y_g1, y_g2, y_w1, y_w2, c_g1, c_g2, c_w1, c_w2]^T\n    # Indices: x_g1:0, x_g2:1, x_w1:2, x_w2:3, y_g1:4, y_g2:5, y_w1:6, y_w2:7, \n    #          c_g1:8, c_g2:9, c_w1:10, c_w2:11\n    \n    num_vars = 12\n\n    # Objective vectors\n    c_cost = np.zeros(num_vars)\n    c_cost[0] = params['d1'] * params['I_gas']\n    c_cost[1] = params['d2'] * params['I_gas']\n    c_cost[2] = params['d1'] * params['I_wind']\n    c_cost[3] = params['d2'] * params['I_wind']\n    c_cost[4] = params['d1'] * params['V_gas']\n    c_cost[5] = params['d2'] * params['V_gas']\n    c_cost[6] = params['d1'] * params['V_wind']\n    c_cost[7] = params['d2'] * params['V_wind']\n    \n    c_emissions = np.zeros(num_vars)\n    c_emissions[4] = params['e_gas']\n    c_emissions[5] = params['e_gas']\n    c_emissions[6] = params['e_wind']\n    c_emissions[7] = params['e_wind']\n\n    # Equality constraints: A_eq * z = b_eq\n    A_eq = np.zeros((6, num_vars))\n    b_eq = np.zeros(6)\n\n    # Capacity accumulation: c_k1 = x_k1 and c_k2 = c_k1 + x_k2\n    # -x_g1 + c_g1 = 0\n    A_eq[0, 0] = -1; A_eq[0, 8] = 1\n    # -x_g2 - c_g1 + c_g2 = 0\n    A_eq[1, 1] = -1; A_eq[1, 8] = -1; A_eq[1, 9] = 1\n    # -x_w1 + c_w1 = 0\n    A_eq[2, 2] = -1; A_eq[2, 10] = 1\n    # -x_w2 - c_w1 + c_w2 = 0\n    A_eq[3, 3] = -1; A_eq[3, 10] = -1; A_eq[3, 11] = 1\n    \n    # Energy balance: y_g_t + y_w_t = D_t\n    # y_g1 + y_w1 = D1\n    A_eq[4, 4] = 1; A_eq[4, 6] = 1\n    b_eq[4] = params['D1']\n    # y_g2 + y_w2 = D2\n    A_eq[5, 5] = 1; A_eq[5, 7] = 1\n    b_eq[5] = params['D2']\n\n    # Inequality constraints: A_ub * z = b_ub\n    A_ub = np.zeros((4, num_vars))\n    b_ub = np.zeros(4)\n    \n    # Generation limits: y_kt = E_k * c_kt = y_kt - E_k * c_kt = 0\n    # y_g1 - E_g * c_g1 = 0\n    A_ub[0, 4] = 1; A_ub[0, 8] = -params['E_gas']\n    # y_g2 - E_g * c_g2 = 0\n    A_ub[1, 5] = 1; A_ub[1, 9] = -params['E_gas']\n    # y_w1 - E_w * c_w1 = 0\n    A_ub[2, 6] = 1; A_ub[2, 10] = -params['E_wind']\n    # y_w2 - E_w * c_w2 = 0\n    A_ub[3, 7] = 1; A_ub[3, 11] = -params['E_wind']\n    \n    bounds = (0, None) # All variables are non-negative\n\n    results = []\n    \n    # 3. SOLVE FOR TEST CASES\n    # -----------------------\n\n    # WSM cases\n    wsm_weights = [0, 0.5, 1]\n    for w in wsm_weights:\n        c_wsm = w * c_cost + (1 - w) * c_emissions\n        res = linprog(c=c_wsm, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            cost = np.dot(c_cost, res.x)\n            emissions = np.dot(c_emissions, res.x)\n            results.append([cost, emissions])\n        else:\n            results.append([np.nan, np.nan])\n\n    # EC cases\n    ec_epsilons = [0, 100, 1000, 3600]\n    for epsilon in ec_epsilons:\n        # Augment A_ub and b_ub for the epsilon constraint: c_emissions * z = epsilon\n        A_ub_ec = np.vstack([A_ub, c_emissions])\n        b_ub_ec = np.hstack([b_ub, epsilon])\n        \n        res = linprog(c=c_cost, A_ub=A_ub_ec, b_ub=b_ub_ec, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            cost = res.fun\n            emissions = np.dot(c_emissions, res.x)\n            results.append([cost, emissions])\n        else:\n            results.append([np.nan, np.nan])\n\n    # 4. FORMAT AND PRINT OUTPUT\n    # --------------------------\n    formatted_results = []\n    for res_pair in results:\n        c, e = res_pair\n        c_str = f\"{c:.2f}\" if not np.isnan(c) else \"NaN\"\n        e_str = f\"{e:.2f}\" if not np.isnan(e) else \"NaN\"\n        formatted_results.append(f\"[{c_str},{e_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}