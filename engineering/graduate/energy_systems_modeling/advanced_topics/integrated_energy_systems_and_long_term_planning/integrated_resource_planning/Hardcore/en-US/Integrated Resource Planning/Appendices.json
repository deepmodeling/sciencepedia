{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of any long-term investment analysis, including Integrated Resource Planning, is the principle of the time value of money. This practice explores how the choice of a discount rate, which reflects societal or corporate preference for present versus future consumption, fundamentally alters the economic comparison between long-lived, capital-intensive resources and short-lived, less expensive ones. By building a cash flow model from first principles and performing a sensitivity analysis, you will gain a tangible understanding of how this single parameter can steer investment strategy ().",
            "id": "4097905",
            "problem": "You are tasked with designing and implementing a sensitivity analysis for the discount rate and quantifying its impact on the ranking of long-lived versus short-lived resource plans using net present value in the context of integrated resource planning within energy systems modeling. The analysis must be formulated from first principles of intertemporal valuation and time preference. Consider a centralized planner who evaluates resource plans over a fixed planning horizon using the principle of the time value of money: future cash flows are valued less than present cash flows according to a constant real discount rate. A resource plan is defined by a sequence of cash flows that includes investment outlays, annual operating payments, annual operating benefits, and end-of-horizon salvage values. The planning horizon is fixed and common to all resource plans; competing plans must deliver identical annual service over this horizon. When a resourceâ€™s technical lifetime is shorter than the planning horizon, identical replacements are made as often as needed to provide service for the entire horizon. If a resource instance extends beyond the planning horizon, the unexpired lifetime is converted to a salvage value by proportional remaining-life valuation at the end of the horizon.\n\nBase assumptions to be used (do not use any shortcut formulas beyond what is derivable from these principles):\n- The time value of money is represented by a constant real discount rate $r \\in [0,1)$ per year. A cash flow occurring at the end of year $t$ has present value determined by the principle of discounting with rate $r$.\n- Each resource instance has a technical lifetime denoted by $L$, a one-time capital investment cost $K$ (a positive quantity measured in dollars), a constant annual operating and maintenance cost $C$ (measured in dollars per year), and a constant annual operating benefit $B$ (measured in dollars per year). The net operating cash flow per active year is $(B - C)$.\n- The planner uses a fixed planning horizon $H$ (in years). To ensure identical service across plans, the short-lived resource is replaced at years $0, L, 2L, \\dots$ until it covers the entire $H$. If the final instance extends beyond $H$, its remaining life is converted to a salvage value at year $H$ equal to the unexpired-life fraction times $K$. If the final instance ends exactly at $H$, the salvage is zero. Analogously, the long-lived resource is replaced as necessary to cover $H$; any remaining life of the last instance at $H$ yields salvage in the same manner.\n- All cash flows occur at the end of each year. Capital costs $K$ are incurred at the end of the year of installation, and annual net operating cash flows $(B - C)$ occur at the end of each active year. Salvage, if any, occurs at the end of year $H$.\n- All values are in United States dollars (USD). You must report all final numerical quantities in USD where applicable and dimensionless quantities as pure decimals. Angles are not involved.\n\nYour tasks:\n1. For each test case described below, implement a function that, given $r$, computes the net present value in USD of each resource plan over the horizon $H$ using the above principles. Then, for a specified grid of discount rates, determine the proportion (expressed as a decimal between $0$ and $1$) of discount rates for which the long-lived plan has strictly higher net present value than the short-lived plan. In the event of equality (to within a tolerance $\\varepsilon = 10^{-9}$), count it as $0.5$ toward the proportion.\n2. For each test case, determine the break-even discount rate $r^\\star \\in [0,1)$, if it exists, at which the net present values of the long-lived and short-lived plans are equal. If there is no such $r^\\star$ in $[0,1)$, return $-1.0$. Use a robust numerical method grounded in first principles and continuity to identify $r^\\star$.\n3. Sensitivity analysis output: For each test case, return a pair of floats: the proportion as described in Task 1 and the break-even discount rate from Task 2. The final program output must aggregate the results for all test cases into a single line of output containing the results as a comma-separated list enclosed in square brackets. Numbers must be rounded to six decimal places.\n\nTest suite:\nUse the following three test cases with specified parameters and the common discount rate grid $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$ (dimensionless decimals):\n\n- Test Case 1 (happy path with different lifetimes and moderate cash flows):\n    - Planning horizon: $H = 30$ years.\n    - Long-lived resource: lifetime $L_{\\mathrm{long}} = 25$ years, capital cost $K_{\\mathrm{long}} = 1200$ USD, annual benefit $B = 220$ USD/year, annual operating cost $C_{\\mathrm{long}} = 70$ USD/year.\n    - Short-lived resource: lifetime $L_{\\mathrm{short}} = 10$ years, capital cost $K_{\\mathrm{short}} = 700$ USD, annual benefit $B = 220$ USD/year, annual operating cost $C_{\\mathrm{short}} = 80$ USD/year.\n\n- Test Case 2 (boundary-dominance case designed so that one plan likely dominates across discount rates):\n    - Planning horizon: $H = 30$ years.\n    - Long-lived resource: lifetime $L_{\\mathrm{long}} = 30$ years, capital cost $K_{\\mathrm{long}} = 800$ USD, annual benefit $B = 230$ USD/year, annual operating cost $C_{\\mathrm{long}} = 60$ USD/year.\n    - Short-lived resource: lifetime $L_{\\mathrm{short}} = 10$ years, capital cost $K_{\\mathrm{short}} = 850$ USD, annual benefit $B = 230$ USD/year, annual operating cost $C_{\\mathrm{short}} = 80$ USD/year.\n\n- Test Case 3 (edge case with multiple replacements and significant salvage):\n    - Planning horizon: $H = 30$ years.\n    - Long-lived resource: lifetime $L_{\\mathrm{long}} = 35$ years, capital cost $K_{\\mathrm{long}} = 1500$ USD, annual benefit $B = 210$ USD/year, annual operating cost $C_{\\mathrm{long}} = 70$ USD/year.\n    - Short-lived resource: lifetime $L_{\\mathrm{short}} = 7$ years, capital cost $K_{\\mathrm{short}} = 500$ USD, annual benefit $B = 210$ USD/year, annual operating cost $C_{\\mathrm{short}} = 90$ USD/year.\n\nScientific realism and consistency:\n- Assume real (inflation-adjusted) dollars. Do not include taxes or depreciation beyond the proportional salvage rule. Assume perfect reliability and identical annual service for each resource when active.\n\nPrecision and formatting requirements:\n- Use $\\varepsilon = 10^{-9}$ for equality tolerance in ranking determination.\n- Use $r^\\star$ search interval $[0, 0.9]$. If no sign change is observed over this interval for the net present value difference, return $-1.0$.\n- Round all reported floats to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: $[\\text{prop}_1, r^\\star_1, \\text{prop}_2, r^\\star_2, \\text{prop}_3, r^\\star_3]$, where $\\text{prop}_i$ is the proportion for Test Case $i$ and $r^\\star_i$ is the break-even discount rate for Test Case $i$.\n\nYour implementation must be a complete, runnable program using any modern programming language. In your final answer, provide executable Python code that adheres to the specified runtime environment, prints only the required single-line output, and requires no external input.",
            "solution": "We proceed from first principles of intertemporal valuation and the definition of net present value. The fundamental base is the time value of money: a dollar received in the future is worth less today due to time preference and opportunity cost. Let $r \\in [0,1)$ denote the constant real annual discount rate. A cash flow occurring at the end of year $t$ has present value obtained by discounting using $r$, consistent with the principle that the present value operator is multiplicative over time intervals and additive over cash flows occurring at the same time.\n\nDefine a resource plan by parameters $(H, L, K, B, C)$. Each resource instance produces identical annual service from installation through its technical lifetime $L$, after which it must be replaced to maintain service. Over the planning horizon $H$, identical replacements occur at years $y \\in \\{0, L, 2L, \\ldots\\}$ while $y  H$. For each installation at year $y$, there is a capital cost $K$ at the end of year $y$, annual net operating cash flow $(B - C)$ at the end of each active year $t \\in \\{y+1, y+2, \\ldots, \\min(y+L, H)\\}$, and, if the instance extends beyond the horizon, a salvage cash flow at $t = H$ representing the remaining-life fraction times capital cost.\n\nThe salvage value is derived from proportional remaining-life valuation. If an installation occurs at year $y$ and its technical lifetime extends beyond the horizon, the unexpired life at $H$ is $(y + L - H)$ years, so the remaining-life fraction is $\\max\\{y + L - H, 0\\}/L$. The salvage cash flow at $t = H$ is then:\n$$\nS(y) = K \\cdot \\frac{\\max\\{y + L - H, 0\\}}{L}.\n$$\nThis $S(y)$, occurring at the end of year $H$, is discounted like any other cash flow at $t = H$.\n\nLet $CF_t$ denote the net cash flow at the end of year $t$ from all installations combined. By additivity of cash flows and linearity of present value under discounting, the net present value for discount rate $r$ is:\n$$\n\\mathrm{NPV}(r) = \\sum_{t = 0}^{H} \\frac{CF_t}{(1 + r)^t}.\n$$\nTo construct $CF_t$, for each installation at $y$:\n- At $t = y$: add $(-K)$.\n- For each $t \\in \\{y+1, \\ldots, \\min(y+L, H)\\}$: add $(B - C)$.\n- At $t = H$: add $S(y)$ if $y + L  H$.\n\nThis representation enforces identical service across plans by repeated installations for short-lived resources and, if needed, for long-lived resources.\n\nRanking and sensitivity analysis are defined as follows. Given two plans, long-lived and short-lived, with respective parameter sets, define their net present values as functions $\\mathrm{NPV}_{\\mathrm{long}}(r)$ and $\\mathrm{NPV}_{\\mathrm{short}}(r)$. For a grid of discount rates $R = \\{r_1, r_2, \\ldots, r_m\\}$, compute the proportion of rates where the long-lived plan strictly dominates by net present value. Formally, with equality tolerance $\\varepsilon = 10^{-9}$ to account for numerical precision, define for each $r \\in R$:\n- If $\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r)  \\varepsilon$, count $1$.\n- If $|\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r)| \\le \\varepsilon$, count $0.5$.\n- Otherwise, count $0$.\nThe proportion is the sum of counts divided by $|R|$ (a pure decimal between $0$ and $1$).\n\nTo compute the break-even discount rate $r^\\star$, consider the continuous function:\n$$\nf(r) = \\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r).\n$$\nUnder the assumptions above, each $\\mathrm{NPV}$ is a finite sum of terms of the form $a_t (1 + r)^{-t}$ with constants $a_t$. Therefore $f(r)$ is continuous and strictly decreasing in $r$ when positive cash flows dominate at later times and negative cash flows (investments) occur earlier, which is common in resource planning. A robust numerical approach is to use bisection on $[0, 0.9]$ when a sign change is observed, i.e., $f(0) \\cdot f(0.9)  0$. If no sign change occurs over $[0, 0.9]$, no root exists in this interval and we report $-1.0$. When bisection applies, iteratively bisect the interval and evaluate $f$ at the midpoint, narrowing the bracket until the interval width or $|f(r)|$ is below a small tolerance; we then report the midpoint as $r^\\star$.\n\nAlgorithmic design:\n1. Implement a function that, given $(H, L, K, B, C)$ and $r$, constructs the sequence $\\{CF_t\\}_{t=0}^{H}$ by iterating over installation times $y \\in \\{0, L, 2L, \\ldots\\}$ with $y  H$, and adding the capital outlay, annual net operating cash flows $(B - C)$ for active years up to $H$, and salvage at $t=H$ according to $S(y)$.\n2. Compute $\\mathrm{NPV}(r)$ as $\\sum_{t=0}^{H} CF_t (1 + r)^{-t}$. Note that for $r = 0$, discount factors reduce to $1$ and the sum is the undiscounted total.\n3. For each test case, define $\\mathrm{NPV}_{\\mathrm{long}}(r)$ and $\\mathrm{NPV}_{\\mathrm{short}}(r)$ using their respective parameters. For the rate grid $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$, calculate the proportion of rates where the long-lived plan strictly dominates, with equality counting as $0.5$ and tolerance $\\varepsilon = 10^{-9}$.\n4. For break-even $r^\\star$, evaluate $f(0)$ and $f(0.9)$. If there is a sign change, perform bisection to find $r^\\star$ to high precision (e.g., until interval width is below $10^{-12}$ or $|f(r)|$ is below $10^{-12}$). If no sign change, set $r^\\star = -1.0$.\n5. Format outputs: For each test case, round the proportion and $r^\\star$ to six decimal places and aggregate into a single line of output in the specified format.\n\nScientific realism is ensured by consistent annual benefits and costs, real-dollar discounting, equality of delivered service via repeated replacements, and salvage computed by proportional remaining life. The numerical methodology relies on continuity of present value functions in $r$ and uses a robust bracketing method for root-finding, avoiding reliance on non-principled shortcuts.\n\nThe final program computes, for each test case, the proportion of discount rates favoring the long-lived plan and the break-even discount rate (or $-1.0$ if not applicable), and prints them as a single bracketed comma-separated list rounded to six decimals.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_cash_flows(H: int, L: int, K: float, B: float, C: float) - np.ndarray:\n    \"\"\"\n    Construct the annual cash flow vector CF[0..H] for a resource plan defined by:\n    - Planning horizon H (years)\n    - Lifetime L (years)\n    - Capital cost K (USD)\n    - Annual benefit B (USD/year)\n    - Annual OM cost C (USD/year)\n\n    Convention:\n    - All flows occur at year-end.\n    - Installation at year y incurs -K at t=y.\n    - Net operating cash flow (B - C) occurs at end of active years t in [y+1, min(y+L, H)].\n    - Salvage occurs at t=H for installations whose lifetime extends beyond H:\n        S(y) = K * max(y + L - H, 0) / L\n    \"\"\"\n    CF = np.zeros(H + 1, dtype=float)\n    # Installation years: 0, L, 2L, ..., while y  H\n    y = 0\n    while y  H:\n        # Capital outlay at year y\n        CF[y] += -K\n        # Annual net operating cash flows for active years until horizon\n        active_end = min(y + L, H)\n        # Operating flows at end of years y+1 .. active_end\n        if active_end = y + 1:\n            CF[y + 1:active_end + 1] += (B - C)\n        # Salvage at end of horizon if lifetime extends beyond H\n        if y + L  H:\n            remaining_life = (y + L) - H  # positive if extends beyond H\n            salvage = K * (remaining_life / L)\n            CF[H] += salvage\n        # Next installation\n        y += L\n    return CF\n\ndef npv_of_plan(CF: np.ndarray, r: float) - float:\n    \"\"\"\n    Compute NPV given cash flow vector CF[0..H] and discount rate r in [0,1).\n    All flows are at year-end, discounted by (1 + r)^t.\n    \"\"\"\n    H = len(CF) - 1\n    if r == 0.0:\n        return float(np.sum(CF))\n    # Use stable computation for discount factors\n    t = np.arange(H + 1, dtype=float)\n    discount = np.power(1.0 + r, -t)\n    return float(np.dot(CF, discount))\n\ndef proportion_long_wins(npv_long, npv_short, rates, eps=1e-9) - float:\n    \"\"\"\n    Compute the proportion of rates where long-lived plan wins:\n    - Count 1 if NPV_long - NPV_short  eps\n    - Count 0.5 if abs difference = eps\n    - Count 0 if NPV_long - NPV_short  -eps\n    Return sum(counts) / len(rates).\n    \"\"\"\n    total = 0.0\n    for r in rates:\n        dl = npv_long(r)\n        ds = npv_short(r)\n        diff = dl - ds\n        if diff  eps:\n            total += 1.0\n        elif abs(diff) = eps:\n            total += 0.5\n        else:\n            total += 0.0\n    return total / len(rates)\n\ndef break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200) - float:\n    \"\"\"\n    Find r* in [r_low, r_high] such that NPV_long(r*) == NPV_short(r*),\n    using bisection if a sign change exists. If no sign change, return -1.0.\n    \"\"\"\n    def f(r):\n        return npv_long(r) - npv_short(r)\n    f_low = f(r_low)\n    f_high = f(r_high)\n    # If no sign change, no root in [r_low, r_high]\n    if f_low == 0.0:\n        return r_low\n    if f_high == 0.0:\n        return r_high\n    if f_low * f_high  0.0:\n        return -1.0\n    a, b = r_low, r_high\n    fa, fb = f_low, f_high\n    for _ in range(max_iter):\n        m = 0.5 * (a + b)\n        fm = f(m)\n        # Check convergence\n        if abs(fm)  tol or (b - a)  tol:\n            return m\n        # Update bracket\n        if fa * fm = 0.0:\n            b, fb = m, fm\n        else:\n            a, fa = m, fm\n    # Return midpoint after max_iter\n    return 0.5 * (a + b)\n\ndef format_float(x: float) - str:\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define discount rate grid\n    rates = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]\n\n    # Test cases parameters\n    test_cases = [\n        # (H, (L_long, K_long, B, C_long), (L_short, K_short, B, C_short))\n        (30, (25, 1200.0, 220.0, 70.0), (10, 700.0, 220.0, 80.0)),  # Test Case 1\n        (30, (30, 800.0, 230.0, 60.0), (10, 850.0, 230.0, 80.0)),  # Test Case 2\n        (30, (35, 1500.0, 210.0, 70.0), (7, 500.0, 210.0, 90.0)),  # Test Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        H, long_params, short_params = case\n        L_long, K_long, B_long, C_long = long_params\n        L_short, K_short, B_short, C_short = short_params\n\n        # Build cash flows for both plans\n        CF_long = build_cash_flows(H, L_long, K_long, B_long, C_long)\n        CF_short = build_cash_flows(H, L_short, K_short, B_short, C_short)\n\n        # Define NPV functions as closures over r\n        npv_long = lambda r, CF=CF_long: npv_of_plan(CF, r)\n        npv_short = lambda r, CF=CF_short: npv_of_plan(CF, r)\n\n        # Proportion of rates where long-lived wins\n        prop = proportion_long_wins(npv_long, npv_short, rates, eps=1e-9)\n\n        # Break-even discount rate via bisection on [0, 0.9]\n        r_star = break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200)\n\n        results.append(format_float(prop))\n        results.append(format_float(r_star))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Real-world planning must grapple with deep uncertainty about the future, from fuel prices and demand growth to environmental regulations. This exercise moves beyond deterministic analysis and introduces the powerful framework of two-stage stochastic programming to make robust investment decisions. You will learn to structure a model where \"here-and-now\" capacity choices are optimized against a range of possible future scenarios, each with its own set of optimal \"in-the-future\" operational or recourse decisions, thereby minimizing expected total cost ().",
            "id": "4097963",
            "problem": "Consider a two-stage stochastic integrated resource planning model for an electric system with three generation technologies: natural gas, wind, and solar. The first stage chooses installed capacities in megawatts (MW), and the second stage operates these capacities to meet energy demand in megawatt-hours (MWh) under uncertainty in fuel prices, load growth, and policy parameters. All quantities and constants must be handled in the units specified, and all final cost outputs must be expressed in dollars.\n\nFundamental base and definitions:\n- Let the set of technologies be $\\mathcal{T} = \\{\\text{gas}, \\text{wind}, \\text{solar}\\}$.\n- Let the set of time blocks be $\\mathcal{H} = \\{\\text{peak}, \\text{offpeak}\\}$ with hours $H_{\\text{peak}} = 2000$ and $H_{\\text{offpeak}} = 6760$ so that $H_{\\text{peak}} + H_{\\text{offpeak}} = 8760$.\n- Base average demands are $D_{\\text{peak}} = 500$ megawatts (MW) and $D_{\\text{offpeak}} = 300$ megawatts (MW), leading to base energy requirements $E_{\\text{peak}}^{\\text{base}} = D_{\\text{peak}} \\cdot H_{\\text{peak}} = 1{,}000{,}000$ megawatt-hours (MWh) and $E_{\\text{offpeak}}^{\\text{base}} = D_{\\text{offpeak}} \\cdot H_{\\text{offpeak}} = 2{,}028{,}000$ megawatt-hours (MWh). Scenario-specific energy requirements scale by a load growth factor $g_s$, so $E_{s,h} = g_s \\cdot E_{h}^{\\text{base}}$ for $h \\in \\mathcal{H}$.\n\nTechnology parameters:\n- Annualized fixed capacity costs (per MW-year) are $C_{\\text{gas}}^{\\text{cap}} = 100{,}000$ dollars per MW-year, $C_{\\text{wind}}^{\\text{cap}} = 200{,}000$ dollars per MW-year, $C_{\\text{solar}}^{\\text{cap}} = 150{,}000$ dollars per MW-year.\n- Variable operation and maintenance (OM) costs (per MWh, excluding scenario fuel price and policy cost) are $c_{\\text{gas}}^{\\text{om}} = 5$ dollars per MWh, $c_{\\text{wind}}^{\\text{om}} = 3$ dollars per MWh, $c_{\\text{solar}}^{\\text{om}} = 2$ dollars per MWh.\n- Carbon dioxide emissions rate for natural gas is $e_{\\text{gas}} = 0.4$ tons of carbon dioxide per MWh. Wind and solar have zero emissions.\n- Availability (capacity factor by block) is $a_{\\text{gas},\\text{peak}} = 0.9$, $a_{\\text{gas},\\text{offpeak}} = 0.9$, $a_{\\text{wind},\\text{peak}} = 0.35$, $a_{\\text{wind},\\text{offpeak}} = 0.45$, $a_{\\text{solar},\\text{peak}} = 0.2$, $a_{\\text{solar},\\text{offpeak}} = 0.05$.\n\nScenario construction:\n- Let the scenario space be the Cartesian product of three sets: fuel price scenarios $\\mathcal{F}$ in dollars per MWh for natural gas fuel, load growth factors $\\mathcal{G}$ (dimensionless multiplier on base energy), and policy scenarios $\\mathcal{P}$ consisting of a carbon tax $p^{\\text{CO2}}$ in dollars per ton and an annual emissions cap $E^{\\text{cap}}$ in tons. Each scenario $s$ is a tuple $(f_s, g_s, p_s^{\\text{CO2}}, E_s^{\\text{cap}})$ with associated probability $\\pi_s$. Assume independence across the sets so that each scenario probability is the product of the component probabilities and equals the uniform probability over the Cartesian product.\n\nTwo-stage stochastic program:\n- First-stage decision variables are installed capacities $x_t \\ge 0$ in megawatts (MW) for $t \\in \\mathcal{T}$.\n- Second-stage decision variables are energy dispatch $y_{t,s,h} \\ge 0$ in megawatt-hours (MWh) for $t \\in \\mathcal{T}$, $s$ in the scenario set $\\mathcal{S}$, and $h \\in \\mathcal{H}$.\n\nObjective function (minimize expected total annual cost):\n$$\n\\min_{x, y} \\quad \\sum_{t \\in \\mathcal{T}} C_t^{\\text{cap}} \\, x_t \\;+\\; \\sum_{s \\in \\mathcal{S}} \\pi_s \\left( \\sum_{h \\in \\mathcal{H}} \\left[ \\left(c_{\\text{gas}}^{\\text{om}} + f_s + p_s^{\\text{CO2}} \\, e_{\\text{gas}}\\right) y_{\\text{gas},s,h} + c_{\\text{wind}}^{\\text{om}} \\, y_{\\text{wind},s,h} + c_{\\text{solar}}^{\\text{om}} \\, y_{\\text{solar},s,h} \\right] \\right) \\right).\n$$\n\nConstraints for each scenario $s \\in \\mathcal{S}$ and block $h \\in \\mathcal{H}$:\n1. Energy balance:\n$$\n\\sum_{t \\in \\mathcal{T}} y_{t,s,h} = E_{s,h}.\n$$\n2. Capacity-to-energy availability (per technology and block):\n$$\ny_{t,s,h} \\le x_t \\cdot a_{t,h} \\cdot H_h, \\quad \\forall t \\in \\mathcal{T}.\n$$\n3. Annual emissions cap:\n$$\ne_{\\text{gas}} \\sum_{h \\in \\mathcal{H}} y_{\\text{gas},s,h} \\le E_s^{\\text{cap}}.\n$$\n4. Non-negativity:\n$$\nx_t \\ge 0, \\quad y_{t,s,h} \\ge 0.\n$$\n\nThis formulation enforces nonanticipativity because the first-stage capacities $x_t$ are shared across all scenarios. The model is linear and can be solved by converting it into its deterministic equivalent linear program and solving with a standard linear programming solver.\n\nNumerical test suite:\nImplement the program to compute the minimum expected annual cost in dollars for each of the following three test cases. Use the exact values listed, and assume uniform probabilities over the Cartesian products.\n\n- Test Case $1$ (balanced uncertainties):\n  - Fuel price scenarios $\\mathcal{F} = \\{20, 40\\}$ dollars per MWh for natural gas.\n  - Load growth factors $\\mathcal{G} = \\{1.0, 1.1\\}$ (dimensionless).\n  - Policy scenarios $\\mathcal{P} = \\{(p^{\\text{CO2}} = 0, E^{\\text{cap}} = 2{,}000{,}000),\\; (p^{\\text{CO2}} = 50, E^{\\text{cap}} = 1{,}200{,}000)\\}$, where carbon tax is in dollars per ton and cap in tons.\n  - Scenario probability for each of the $8$ scenarios is $\\pi_s = 0.125$.\n\n- Test Case $2$ (tight emissions cap):\n  - Fuel price scenarios $\\mathcal{F} = \\{25, 35\\}$ dollars per MWh for natural gas.\n  - Load growth factors $\\mathcal{G} = \\{1.0, 1.2\\}$ (dimensionless).\n  - Policy scenarios $\\mathcal{P} = \\{(p^{\\text{CO2}} = 100, E^{\\text{cap}} = 400{,}000)\\}$.\n  - Scenario probability for each of the $4$ scenarios is $\\pi_s = 0.25$.\n\n- Test Case $3$ (cheap gas, lax policy):\n  - Fuel price scenarios $\\mathcal{F} = \\{10\\}$ dollars per MWh for natural gas.\n  - Load growth factors $\\mathcal{G} = \\{0.95, 1.0\\}$ (dimensionless).\n  - Policy scenarios $\\mathcal{P} = \\{(p^{\\text{CO2}} = 0, E^{\\text{cap}} = 5{,}000{,}000)\\}$.\n  - Scenario probability for each of the $2$ scenarios is $\\pi_s = 0.5$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry must be a floating-point number giving the minimum expected annual cost in dollars for the corresponding test case, rounded to two decimal places, in the order of Test Case $1$, Test Case $2$, and Test Case $3$. For example, the format must be exactly like $[c_1,c_2,c_3]$, where $c_1$, $c_2$, and $c_3$ are the computed costs in dollars.",
            "solution": "The problem statement has been validated and is determined to be a well-posed, scientifically grounded, and objective two-stage stochastic linear programming problem. All necessary data and definitions are provided, and there are no contradictions or ambiguities. The problem falls within the standard framework of energy systems modeling, specifically integrated resource planning under uncertainty.\n\nThe problem seeks to find the minimum expected total annual cost for an electric system by making optimal decisions on generation capacity investment (first stage) and subsequent operational dispatch (second stage) across a set of possible future scenarios. The solution consists of formulating this stochastic program as a deterministic equivalent linear program (LP) and solving it using a standard LP solver.\n\n**Model Formulation: Deterministic Equivalent LP**\n\nA two-stage stochastic program is solved by constructing a single, large-scale deterministic equivalent LP that represents all decisions across all scenarios simultaneously. The non-anticipativity constraint (first-stage decisions must be made before the uncertainty is resolved and thus must be the same for all scenarios) is implicitly enforced by having only one set of first-stage variables.\n\n**Decision Variables**\n\nThe decision variables for the deterministic equivalent LP are arranged into a single vector, denoted by $\\mathbf{z}$. This vector is a concatenation of the first-stage and second-stage variables.\n-   **First-stage variables**: The installed capacities $x_t$ for each technology $t \\in \\mathcal{T} = \\{\\text{gas}, \\text{wind}, \\text{solar}\\}$. There are $|\\mathcal{T}| = 3$ such variables.\n-   **Second-stage variables**: The energy dispatch $y_{t,s,h}$ for each technology $t \\in \\mathcal{T}$, scenario $s \\in \\mathcal{S}$, and time block $h \\in \\mathcal{H} = \\{\\text{peak}, \\text{offpeak}\\}$. The total number of scenarios $|\\mathcal{S}|$ varies for each test case. The number of second-stage variables is $|\\mathcal{T}| \\times |\\mathcal{S}| \\times |\\mathcal{H}| = 3 \\times |\\mathcal{S}| \\times 2 = 6|\\mathcal{S}|$.\n\nThe complete vector of decision variables is $\\mathbf{z} = [x_{\\text{gas}}, x_{\\text{wind}}, x_{\\text{solar}}, \\dots, y_{t,s,h}, \\dots]^T$, with a total of $3 + 6|\\mathcal{S}|$ variables.\n\n**Objective Function**\n\nThe objective is to minimize the total expected annual cost, which is the sum of the first-stage investment costs and the probability-weighted average of the second-stage operational costs. The LP objective function is expressed as $\\min \\mathbf{c}^T \\mathbf{z}$, where $\\mathbf{c}$ is the cost vector.\n\n-   **Investment Cost Coefficients**: The elements of $\\mathbf{c}$ corresponding to the capacity variables $x_t$ are the annualized fixed capacity costs, $C_{t}^{\\text{cap}}$.\n-   **Operational Cost Coefficients**: The element of $\\mathbf{c}$ corresponding to a dispatch variable $y_{t,s,h}$ is its marginal operational cost, weighted by the scenario probability $\\pi_s$. For a given scenario $s=(f_s, g_s, p_s^{\\text{CO2}}, E_s^{\\text{cap}})$, the variable costs are:\n    -   Gas: $c_{\\text{gas},s}^{\\text{var}} = c_{\\text{gas}}^{\\text{om}} + f_s + p_s^{\\text{CO2}} e_{\\text{gas}}$\n    -   Wind: $c_{\\text{wind},s}^{\\text{var}} = c_{\\text{wind}}^{\\text{om}}$\n    -   Solar: $c_{\\text{solar},s}^{\\text{var}} = c_{\\text{solar}}^{\\text{om}}$\nThe corresponding coefficient in $\\mathbf{c}$ for the variable $y_{t,s,h}$ is $\\pi_s \\cdot c_{t,s}^{\\text{var}}$.\n\n**Constraints**\n\nThe problem constraints are transformed into matrix form for the LP solver. They are categorized as equality constraints ($\\mathbf{A}_{\\text{eq}} \\mathbf{z} = \\mathbf{b}_{\\text{eq}}$) and inequality constraints ($\\mathbf{A}_{\\text{ub}} \\mathbf{z} \\le \\mathbf{b}_{\\text{ub}}$).\n\n1.  **Energy Balance (Equality Constraints)**: For each scenario $s$ and time block $h$, the total energy dispatched must equal the energy demand $E_{s,h} = g_s E_{h}^{\\text{base}}$.\n    $$ \\sum_{t \\in \\mathcal{T}} y_{t,s,h} = E_{s,h} \\quad \\forall s \\in \\mathcal{S}, h \\in \\mathcal{H} $$\n    This yields $2|\\mathcal{S}|$ equality constraints. Each row in $\\mathbf{A}_{\\text{eq}}$ corresponding to a specific $(s,h)$ pair will have coefficients of $1$ for the variables $y_{t,s,h}$ (for all $t \\in \\mathcal{T}$) and $0$ elsewhere. The corresponding element in $\\mathbf{b}_{\\text{eq}}$ will be $E_{s,h}$.\n\n2.  **Capacity-to-Energy Availability (Inequality Constraints)**: The energy dispatched from a technology in a given block cannot exceed its available energy potential, which is a function of its installed capacity $x_t$, availability factor $a_{t,h}$, and the duration of the block $H_h$.\n    $$ y_{t,s,h} \\le x_t \\cdot a_{t,h} \\cdot H_h \\implies y_{t,s,h} - (a_{t,h} H_h) x_t \\le 0 \\quad \\forall t \\in \\mathcal{T}, s \\in \\mathcal{S}, h \\in \\mathcal{H} $$\n    This yields $6|\\mathcal{S}|$ inequality constraints. Each row in $\\mathbf{A}_{\\text{ub}}$ will have a coefficient of $1$ for the variable $y_{t,s,h}$, a coefficient of $-a_{t,h} H_h$ for the variable $x_t$, and $0$ elsewhere. The corresponding element in $\\mathbf{b}_{\\text{ub}}$ will be $0$.\n\n3.  **Annual Emissions Cap (Inequality Constraints)**: For each scenario $s$, the total annual carbon dioxide emissions from natural gas generation must not exceed the scenario-specific cap $E_s^{\\text{cap}}$.\n    $$ e_{\\text{gas}} \\sum_{h \\in \\mathcal{H}} y_{\\text{gas},s,h} \\le E_s^{\\text{cap}} \\quad \\forall s \\in \\mathcal{S} $$\n    This yields $|\\mathcal{S}|$ inequality constraints. For each scenario $s$, the corresponding row in $\\mathbf{A}_{\\text{ub}}$ will have coefficients of $e_{\\text{gas}}$ for the variables $y_{\\text{gas},s,\\text{peak}}$ and $y_{\\text{gas},s,\\text{offpeak}}$, and $0$ elsewhere. The corresponding element in $\\mathbf{b}_{\\text{ub}}$ will be $E_s^{\\text{cap}}$.\n\n4.  **Non-negativity**: All capacity and dispatch variables must be non-negative. This is handled by setting a lower bound of $0$ for all variables in the LP solver.\n\n**Implementation**\n\nThe algorithmic implementation involves writing a function that, for each test case:\n1.  Generates the complete set of scenarios $\\mathcal{S}$ and their probabilities $\\pi_s$ from the Cartesian product of the given uncertainty sets $\\mathcal{F}$, $\\mathcal{G}$, and $\\mathcal{P}$.\n2.  Dynamically constructs the components of the deterministic equivalent LP: the cost vector $\\mathbf{c}$, the equality constraint matrix $\\mathbf{A}_{\\text{eq}}$ and vector $\\mathbf{b}_{\\text{eq}}$, and the inequality constraint matrix $\\mathbf{A}_{\\text{ub}}$ and vector $\\mathbf{b}_{\\text{ub}}$. `NumPy` is used for efficient matrix and vector operations.\n3.  Passes these components to the `scipy.optimize.linprog` function. This function solves the LP using the 'highs' solver, which is well-suited for such problems.\n4.  The optimal objective function value returned by the solver, `result.fun`, represents the minimum expected total annual cost in dollars. This value is then formatted as required.\n\nThis procedure is repeated for each of the three test cases, and the final results are collected and printed in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the solution process.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (balanced uncertainties)\n        {\n            'F': [20.0, 40.0],\n            'G': [1.0, 1.1],\n            'P': [(0.0, 2_000_000.0), (50.0, 1_200_000.0)]\n        },\n        # Test Case 2 (tight emissions cap)\n        {\n            'F': [25.0, 35.0],\n            'G': [1.0, 1.2],\n            'P': [(100.0, 400_000.0)]\n        },\n        # Test Case 3 (cheap gas, lax policy)\n        {\n            'F': [10.0],\n            'G': [0.95, 1.0],\n            'P': [(0.0, 5_000_000.0)]\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        cost = solve_irp_case(params['F'], params['G'], params['P'])\n        results.append(f\"{cost:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_irp_case(f_scenarios, g_scenarios, p_scenarios):\n    \"\"\"\n    Solves the two-stage stochastic IRP for a given set of scenario parameters.\n    \"\"\"\n    # --- Define Problem Constants ---\n    TECH_MAP = {'gas': 0, 'wind': 1, 'solar': 2}\n    NUM_TECHS = 3\n    NUM_BLOCKS = 2\n\n    H = np.array([2000.0, 6760.0])  # hours per block\n    E_base = np.array([1_000_000.0, 2_028_000.0])  # MWh per block\n    C_cap = np.array([100_000.0, 200_000.0, 150_000.0])  # $/MW-year\n    c_om = np.array([5.0, 3.0, 2.0])  # $/MWh\n    e_gas = 0.4  # tCO2/MWh\n\n    availability = np.array([\n        [0.9, 0.9],    # gas\n        [0.35, 0.45],  # wind\n        [0.2, 0.05]    # solar\n    ])\n\n    # 1. Generate scenarios from Cartesian product\n    scenarios = list(product(f_scenarios, g_scenarios, p_scenarios))\n    num_scenarios = len(scenarios)\n    pi_s = 1.0 / num_scenarios\n\n    # 2. Define LP problem dimensions\n    num_x_vars = NUM_TECHS\n    num_y_vars = num_scenarios * NUM_BLOCKS * NUM_TECHS\n    num_vars = num_x_vars + num_y_vars\n\n    def y_idx(s_idx, h_idx, t_idx):\n        # Helper to map (scenario, block, tech) to flat index for y variables\n        return num_x_vars + s_idx * (NUM_BLOCKS * NUM_TECHS) + h_idx * NUM_TECHS + t_idx\n\n    # 3. Construct objective function vector c\n    c = np.zeros(num_vars)\n    c[:num_x_vars] = C_cap  # First-stage capacity costs\n\n    for s_idx, (f_s, g_s, (p_co2_s, E_cap_s)) in enumerate(scenarios):\n        var_cost_gas = c_om[0] + f_s + p_co2_s * e_gas\n        var_costs_s = np.array([var_cost_gas, c_om[1], c_om[2]])\n        for h_idx in range(NUM_BLOCKS):\n            for t_idx in range(NUM_TECHS):\n                idx = y_idx(s_idx, h_idx, t_idx)\n                c[idx] = pi_s * var_costs_s[t_idx]\n\n    # 4. Construct equality constraints (energy balance)\n    num_eq_constraints = num_scenarios * NUM_BLOCKS\n    A_eq = np.zeros((num_eq_constraints, num_vars))\n    b_eq = np.zeros(num_eq_constraints)\n    eq_row = 0\n    for s_idx, (_, g_s, _) in enumerate(scenarios):\n        for h_idx in range(NUM_BLOCKS):\n            b_eq[eq_row] = g_s * E_base[h_idx]\n            for t_idx in range(NUM_TECHS):\n                A_eq[eq_row, y_idx(s_idx, h_idx, t_idx)] = 1.0\n            eq_row += 1\n\n    # 5. Construct inequality constraints (capacity  emissions)\n    num_ineq_cap = num_y_vars\n    num_ineq_emissions = num_scenarios\n    num_ineq_constraints = num_ineq_cap + num_ineq_emissions\n    A_ub = np.zeros((num_ineq_constraints, num_vars))\n    b_ub = np.zeros(num_ineq_constraints)\n    \n    # Capacity constraints: y_tsh - x_t * a_th * H_h = 0\n    ineq_row = 0\n    for s_idx in range(num_scenarios):\n        for h_idx in range(NUM_BLOCKS):\n            for t_idx in range(NUM_TECHS):\n                A_ub[ineq_row, y_idx(s_idx, h_idx, t_idx)] = 1.0\n                A_ub[ineq_row, t_idx] = -availability[t_idx, h_idx] * H[h_idx]\n                ineq_row += 1 # b_ub is 0 by default\n\n    # Emissions constraints: e_gas * sum(y_gas,s,h over h) = E_cap_s\n    for s_idx, (_, _, (_, E_cap_s)) in enumerate(scenarios):\n        b_ub[ineq_row] = E_cap_s\n        # y_gas,s,peak\n        A_ub[ineq_row, y_idx(s_idx, 0, TECH_MAP['gas'])] = e_gas\n        # y_gas,s,offpeak\n        A_ub[ineq_row, y_idx(s_idx, 1, TECH_MAP['gas'])] = e_gas\n        ineq_row += 1\n\n    # 6. Define bounds (all variables are non-negative)\n    bounds = (0, None)\n\n    # 7. Solve the Linear Program\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if not result.success:\n        # It's good practice to check if the solver succeeded.\n        raise RuntimeError(f\"LP solver failed for a test case. Status: {result.message}\")\n\n    return result.fun\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Modern energy planning rarely involves optimizing for a single objective like cost. More often, it requires balancing competing goals, such as minimizing economic costs while simultaneously reducing environmental externalities like carbon emissions. This final practice introduces you to bi-objective optimization and the concept of the Pareto front, which represents the set of all non-dominated solutions. By applying the Weighted Sum and Epsilon-Constraint methods, you will generate this trade-off frontier, providing the essential quantitative insight needed for informed policy and strategic decision-making ().",
            "id": "4097887",
            "problem": "Consider an Integrated Resource Planning (IRP) problem for a power system with two planning periods and two generation technologies. The objective is to construct and solve a bi-objective linear optimization model that simultaneously minimizes discounted cost and cumulative Carbon Dioxide (CO2) emissions, and then to generate approximate Pareto fronts using the Weighted Sum Method (WSM) and the Epsilon-Constraint (EC) method.\n\nThe fundamental base shall be the following accepted facts and definitions. Discounted cash flow uses Net Present Value (NPV), where cash flows at time index $t$ are multiplied by a discount factor $d_t = \\frac{1}{(1+r)^{\\Delta t_t}}$ for a constant real discount rate $r$ and period spacing $\\Delta t_t$. Cumulative emissions are the sum of period emissions without discounting. Annual generation must meet demand exactly in each period, and is limited by installed capacity times the annual energy per unit capacity, which is derived from the product of $8{,}760$ hours per year and the technology-specific capacity factor. Multi-Objective Optimization (MOO) seeks solutions that are Pareto efficient, where no objective can be improved without worsening another, and scalarization techniques such as Weighted Sum Method (WSM) and Epsilon-Constraint (EC) are commonly used to generate points on or near the Pareto front.\n\nModel structure and decision variables: Let the planning periods be indexed by $t \\in \\{1,2\\}$, corresponding to the years $2025$ and $2030$, respectively, and technologies $k \\in \\{\\text{gas}, \\text{wind}\\}$. Let $x_{k,t} \\ge 0$ denote capacity additions in megawatts (MW) for technology $k$ in period $t$. Let $c_{k,t} \\ge 0$ denote the total available capacity in MW for technology $k$ in period $t$, which accumulates capacity additions across periods. Let $y_{k,t} \\ge 0$ denote the annual energy generation in megawatt-hours (MWh) for technology $k$ in period $t$. The capacity accumulation is represented by $c_{k,1} = x_{k,1}$ and $c_{k,2} = c_{k,1} + x_{k,2}$. Annual energy balance requires $y_{\\text{gas},t} + y_{\\text{wind},t} = D_t$, with $D_t$ given. Annual generation limits are $y_{k,t} \\le E_k \\cdot c_{k,t}$, where $E_k$ is the annual energy per MW for technology $k$.\n\nParameters and physical realism: Use discount rate $r = 0.07$ and period spacing $\\Delta t_1 = 0$, $\\Delta t_2 = 5$, yielding discount factors $d_1 = 1$ and $d_2 = \\frac{1}{(1+0.07)^5}$. Demands are $D_1 = 4{,}000$ MWh and $D_2 = 5{,}000$ MWh. Technology parameters are:\nInvestment cost per MW: $I_{\\text{gas}} = 900{,}000$ United States dollars per MW, $I_{\\text{wind}} = 1{,}400{,}000$ United States dollars per MW.\nVariable operating cost per MWh: $V_{\\text{gas}} = 50$ United States dollars per MWh, $V_{\\text{wind}} = 5$ United States dollars per MWh.\nEmission rate per MWh: $e_{\\text{gas}} = 0.4$ metric tonnes of CO2 per MWh, $e_{\\text{wind}} = 0$ metric tonnes of CO2 per MWh.\nAnnual energy per MW: $E_{\\text{gas}} = 8{,}760 \\times 0.6 = 5{,}256$ MWh per MW-year, $E_{\\text{wind}} = 8{,}760 \\times 0.35 = 3{,}066$ MWh per MW-year.\n\nObjectives: Define discounted total system cost as the sum over periods of discounted investment and operating costs, that is, period $t$ terms using $d_t$, investment using $I_{k}$ times $x_{k,t}$, and operating cost using $V_{k}$ times $y_{k,t}$. Define cumulative emissions as the sum over periods of $e_{k} \\cdot y_{k,t}$ without discounting.\n\nMethods to generate Pareto fronts:\nWeighted Sum Method (WSM): Construct a single-objective scalarization with a weight $w \\in [0,1]$ placed on discounted cost and weight $(1-w)$ on cumulative emissions to obtain candidate Pareto-efficient solutions.\nEpsilon-Constraint (EC): Minimize discounted cost subject to a constraint that cumulative emissions do not exceed a specified bound $\\epsilon \\ge 0$.\n\nTasks:\n1. Formulate the bi-objective optimization using the variables and constraints stated above from first principles, and implement both WSM and EC computational approaches to find candidate Pareto points.\n2. Use the parameter values specified above.\n3. Units: Report discounted total cost in United States dollars and cumulative emissions in metric tonnes of CO2. Round both reported quantities to two decimal places.\n4. Test Suite: For WSM, solve the scalarized problem for weights $w \\in \\{0, 0.5, 1\\}$. For EC, solve the constrained problem for emission bounds $\\epsilon \\in \\{0, 100, 1{,}000, 3{,}600\\}$.\n5. Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list must itself be a two-element list of floats $[C, E]$ representing discounted total cost $C$ (in United States dollars) and cumulative emissions $E$ (in metric tonnes of CO2), ordered first by the WSM test cases with $w = 0$, then $w = 0.5$, then $w = 1$, followed by the EC test cases with $\\epsilon = 0$, then $\\epsilon = 100$, then $\\epsilon = 1{,}000$, then $\\epsilon = 3{,}600$. If a case is infeasible, represent its result by $[\\text{NaN}, \\text{NaN}]$. The final single printed line must match the format example $[[c_1,e_1],[c_2,e_2],\\dots]$ with no spaces, and numbers rounded to two decimal places.",
            "solution": "The user-provided problem has been analyzed and validated against the specified criteria.\n\n### Step 1: Extract Givens\n-   **Indices**: Periods $t \\in \\{1, 2\\}$, Technologies $k \\in \\{\\text{gas}, \\text{wind}\\}$.\n-   **Decision Variables**:\n    -   $x_{k,t} \\ge 0$: Capacity additions (MW) for technology $k$ in period $t$.\n    -   $c_{k,t} \\ge 0$: Total capacity (MW) for technology $k$ in period $t$.\n    -   $y_{k,t} \\ge 0$: Annual energy generation (MWh) for technology $k$ in period $t$.\n-   **Model Equations**:\n    -   Capacity accumulation: $c_{k,1} = x_{k,1}$, $c_{k,2} = c_{k,1} + x_{k,2}$.\n    -   Energy balance: $y_{\\text{gas},t} + y_{\\text{wind},t} = D_t$ for $t \\in \\{1, 2\\}$.\n    -   Generation limits: $y_{k,t} \\le E_k \\cdot c_{k,t}$ for $k, t$.\n-   **Parameters**:\n    -   Discount rate: $r = 0.07$.\n    -   Period spacing: $\\Delta t_1 = 0$, $\\Delta t_2 = 5$ years.\n    -   Discount factors: $d_1 = 1/(1+r)^0 = 1$, $d_2 = 1/(1+r)^5$.\n    -   Demands: $D_1 = 4{,}000$ MWh, $D_2 = 5{,}000$ MWh.\n    -   Investment cost: $I_{\\text{gas}} = 900{,}000$ USD/MW, $I_{\\text{wind}} = 1{,}400{,}000$ USD/MW.\n    -   Variable cost: $V_{\\text{gas}} = 50$ USD/MWh, $V_{\\text{wind}} = 5$ USD/MWh.\n    -   Emission rate: $e_{\\text{gas}} = 0.4$ tCO2/MWh, $e_{\\text{wind}} = 0$ tCO2/MWh.\n    -   Annual energy per MW: $E_{\\text{gas}} = 5{,}256$ MWh/MW, $E_{\\text{wind}} = 3{,}066$ MWh/MW.\n-   **Objectives**:\n    -   Minimize discounted cost: $Z_{cost} = \\sum_{t=1}^2 d_t \\left( \\sum_{k} I_k x_{k,t} + \\sum_{k} V_k y_{k,t} \\right)$.\n    -   Minimize cumulative emissions: $Z_{emissions} = \\sum_{t=1}^2 \\sum_{k} e_k y_{k,t}$.\n-   **Solution Methods**:\n    -   Weighted Sum Method (WSM): Minimize $w \\cdot Z_{cost} + (1-w) \\cdot Z_{emissions}$.\n    -   Epsilon-Constraint (EC) Method: Minimize $Z_{cost}$ subject to $Z_{emissions} \\le \\epsilon$.\n-   **Test Cases**:\n    -   WSM: $w \\in \\{0, 0.5, 1\\}$.\n    -   EC: $\\epsilon \\in \\{0, 100, 1000, 3600\\}$.\n-   **Output Requirements**:\n    -   A single line of text: `[[c1,e1],[c2,e2],...]`.\n    -   Costs and emissions rounded to two decimal places.\n    -   Infeasible cases represented as `[NaN, NaN]`.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Grounding**: The problem is a standard, albeit simplified, energy system capacity expansion model, a classic application within Integrated Resource Planning (IRP). All concepts, including discounted cash flow, emission accounting, capacity factors, and linear optimization, are fundamental to the field. The problem is scientifically and mathematically sound.\n-   **Well-Posedness**: The problem is formulated as a bi-objective linear program. The use of WSM and EC methods transforms it into a series of single-objective linear programs (LPs). A standard LP with a non-empty, bounded feasible region is well-posed and guaranteed to have a solution. The provided data and constraints are sufficient and consistent, allowing for a feasible solution space (e.g., a zero-emission solution is achievable with wind power).\n-   **Objectivity**: The problem is defined with precise mathematical equations and numerical parameters. The language is objective and free of subjective claims.\n-   **Completeness and Consistency**: All parameters, variables, and constraints needed to build the mathematical model are explicitly provided. There are no contradictions in the given data.\n-   **Feasibility**: The parameter values are plausible for an academic exercise. The demands, though small, are positive, making the problem non-trivial. The constraints allow for feasible solutions across the specified range of test cases. For instance, the maximum possible emissions if all demand is met by gas is $0.4 \\times (4000+5000) = 3600$, which matches one of the epsilon bounds, indicating the test suite is well-designed.\n-   **Other Flaws**: The problem is not trivial, metaphorical, or unverifiable. It is a direct application of established optimization techniques to a formalized problem.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-posed, scientifically grounded problem in energy systems modeling that can be solved using linear programming.\n\n### Mathematical Formulation\nThe bi-objective optimization problem is formulated as follows.\n\n**Decision Variables**:\nThe problem involves $12$ continuous, non-negative decision variables:\n-   Capacity additions: $x_{\\text{gas},1}, x_{\\text{gas},2}, x_{\\text{wind},1}, x_{\\text{wind},2}$.\n-   Energy generation: $y_{\\text{gas},1}, y_{\\text{gas},2}, y_{\\text{wind},1}, y_{\\text{wind},2}$.\n-   Total capacity: $c_{\\text{gas},1}, c_{\\text{gas},2}, c_{\\text{wind},1}, c_{\\text{wind},2}$.\n\n**Objective Functions**:\n1.  Minimize discounted total cost ($Z_{cost}$):\n    $$ \\min Z_{cost} = \\sum_{t=1}^{2} d_t \\left( I_{\\text{gas}} x_{\\text{gas},t} + I_{\\text{wind}} x_{\\text{wind},t} + V_{\\text{gas}} y_{\\text{gas},t} + V_{\\text{wind}} y_{k,t} \\right) $$\n2.  Minimize cumulative CO2 emissions ($Z_{emissions}$):\n    $$ \\min Z_{emissions} = \\sum_{t=1}^{2} \\left( e_{\\text{gas}} y_{\\text{gas},t} + e_{\\text{wind}} y_{\\text{wind},t} \\right) $$\n\n**Constraints**:\n1.  **Energy Balance**: For each period $t \\in \\{1,2\\}$, total generation must meet demand $D_t$.\n    $$ y_{\\text{gas},1} + y_{\\text{wind},1} = D_1 $$\n    $$ y_{\\text{gas},2} + y_{\\text{wind},2} = D_2 $$\n2.  **Capacity Accumulation**: For each technology $k \\in \\{\\text{gas}, \\text{wind}\\}$, total capacity in a period is the sum of existing and new capacity.\n    $$ c_{k,1} = x_{k,1} $$\n    $$ c_{k,2} = c_{k,1} + x_{k,2} $$\n3.  **Generation Limit**: For each technology $k$ and period $t$, annual generation is limited by its installed capacity and energy availability $E_k$.\n    $$ y_{k,t} \\le E_k \\cdot c_{k,t} $$\n4.  **Non-negativity**: All decision variables must be non-negative.\n    $$ x_{k,t} \\ge 0, y_{k,t} \\ge 0, c_{k,t} \\ge 0 $$\n\n### Scalarization and Implementation Strategy\nThis bi-objective linear program is solved by converting it into a series of single-objective LPs using two scalarization techniques. The LPs are solved using `scipy.optimize.linprog`.\n\n**1. Weighted Sum Method (WSM)**\nA single objective function is created by taking a weighted sum of the two original objectives. The problem becomes:\n$$ \\min \\left( w \\cdot Z_{cost} + (1-w) \\cdot Z_{emissions} \\right) $$\nsubject to the full set of constraints. Here, $w \\in [0,1]$ is the weight assigned to the cost objective. This approach generates points on the convex portion of the Pareto front.\n\n**2. Epsilon-Constraint (EC) Method**\nOne objective is chosen for minimization (here, $Z_{cost}$), while the other ($Z_{emissions}$) is converted into a constraint. The problem is:\n$$ \\min Z_{cost} $$\nsubject to:\n-   All original constraints.\n-   An additional constraint: $Z_{emissions} \\le \\epsilon$, where $\\epsilon$ is the maximum allowable level of emissions.\n\nThis method can find both convex and non-convex parts of the Pareto front.\n\n**Implementation with SciPy**\nThe problem is cast into the standard LP form: $\\min \\mathbf{c}^T \\mathbf{z}$ subject to $\\mathbf{A}_{ub} \\mathbf{z} \\le \\mathbf{b}_{ub}$ and $\\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{b}_{eq}$.\n-   The decision variable vector $\\mathbf{z}$ is a $12 \\times 1$ column vector concatenating all $x, y, c$ variables.\n-   The equality constraint matrix $\\mathbf{A}_{eq}$ ($6 \\times 12$) and vector $\\mathbf{b}_{eq}$ ($6 \\times 1$) enforce the energy balance and capacity accumulation equations.\n-   The inequality constraint matrix $\\mathbf{A}_{ub}$ ($4 \\times 12$) and vector $\\mathbf{b}_{ub}$ ($4 \\times 1$) enforce the generation limits.\n-   For each WSM case, a composite objective vector $\\mathbf{c}$ is constructed from the cost and emission coefficient vectors.\n-   For each EC case, the objective vector $\\mathbf{c}$ is the cost coefficient vector, and the inequality constraint matrix/vector are augmented with a new row representing $Z_{emissions} \\le \\epsilon$.\n-   The `scipy.optimize.linprog` function is called for each test case. If the solver reports infeasibility (`status=2`), the result is recorded as `[NaN, NaN]`. Otherwise, the optimal cost and emissions are calculated from the solution vector $\\mathbf{z}$ and stored. Finally, the results are formatted and printed as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a bi-objective IRP problem using WSM and EC methods.\n    \"\"\"\n\n    # 1. DEFINE PARAMETERS\n    # ---------------------\n    params = {\n        'r': 0.07,\n        'D1': 4000.0,\n        'D2': 5000.0,\n        'I_gas': 900000.0,\n        'I_wind': 1400000.0,\n        'V_gas': 50.0,\n        'V_wind': 5.0,\n        'e_gas': 0.4,\n        'e_wind': 0.0,\n        'E_gas': 8760 * 0.6,\n        'E_wind': 8760 * 0.35,\n    }\n    params['d1'] = 1.0\n    params['d2'] = 1.0 / (1.0 + params['r'])**5\n\n    # 2. DEFINE LP STRUCTURE\n    # ----------------------\n    # Decision variable vector z (12 variables):\n    # z = [x_g1, x_g2, x_w1, x_w2, y_g1, y_g2, y_w1, y_w2, c_g1, c_g2, c_w1, c_w2]^T\n    # Indices: x_g1:0, x_g2:1, x_w1:2, x_w2:3, y_g1:4, y_g2:5, y_w1:6, y_w2:7, \n    #          c_g1:8, c_g2:9, c_w1:10, c_w2:11\n    \n    num_vars = 12\n\n    # Objective vectors\n    c_cost = np.zeros(num_vars)\n    c_cost[0] = params['d1'] * params['I_gas']\n    c_cost[1] = params['d2'] * params['I_gas']\n    c_cost[2] = params['d1'] * params['I_wind']\n    c_cost[3] = params['d2'] * params['I_wind']\n    c_cost[4] = params['d1'] * params['V_gas']\n    c_cost[5] = params['d2'] * params['V_gas']\n    c_cost[6] = params['d1'] * params['V_wind']\n    c_cost[7] = params['d2'] * params['V_wind']\n    \n    c_emissions = np.zeros(num_vars)\n    c_emissions[4] = params['e_gas']\n    c_emissions[5] = params['e_gas']\n    c_emissions[6] = params['e_wind']\n    c_emissions[7] = params['e_wind']\n\n    # Equality constraints: A_eq * z = b_eq\n    A_eq = np.zeros((6, num_vars))\n    b_eq = np.zeros(6)\n\n    # Capacity accumulation: c_k1 = x_k1 and c_k2 = c_k1 + x_k2\n    # -x_g1 + c_g1 = 0\n    A_eq[0, 0] = -1; A_eq[0, 8] = 1\n    # -x_g2 - c_g1 + c_g2 = 0\n    A_eq[1, 1] = -1; A_eq[1, 8] = -1; A_eq[1, 9] = 1\n    # -x_w1 + c_w1 = 0\n    A_eq[2, 2] = -1; A_eq[2, 10] = 1\n    # -x_w2 - c_w1 + c_w2 = 0\n    A_eq[3, 3] = -1; A_eq[3, 10] = -1; A_eq[3, 11] = 1\n    \n    # Energy balance: y_g_t + y_w_t = D_t\n    # y_g1 + y_w1 = D1\n    A_eq[4, 4] = 1; A_eq[4, 6] = 1\n    b_eq[4] = params['D1']\n    # y_g2 + y_w2 = D2\n    A_eq[5, 5] = 1; A_eq[5, 7] = 1\n    b_eq[5] = params['D2']\n\n    # Inequality constraints: A_ub * z = b_ub\n    A_ub = np.zeros((4, num_vars))\n    b_ub = np.zeros(4)\n    \n    # Generation limits: y_kt = E_k * c_kt = y_kt - E_k * c_kt = 0\n    # y_g1 - E_g * c_g1 = 0\n    A_ub[0, 4] = 1; A_ub[0, 8] = -params['E_gas']\n    # y_g2 - E_g * c_g2 = 0\n    A_ub[1, 5] = 1; A_ub[1, 9] = -params['E_gas']\n    # y_w1 - E_w * c_w1 = 0\n    A_ub[2, 6] = 1; A_ub[2, 10] = -params['E_wind']\n    # y_w2 - E_w * c_w2 = 0\n    A_ub[3, 7] = 1; A_ub[3, 11] = -params['E_wind']\n    \n    bounds = (0, None) # All variables are non-negative\n\n    results = []\n    \n    # 3. SOLVE FOR TEST CASES\n    # -----------------------\n\n    # WSM cases\n    wsm_weights = [0, 0.5, 1]\n    for w in wsm_weights:\n        c_wsm = w * c_cost + (1 - w) * c_emissions\n        res = linprog(c=c_wsm, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            cost = np.dot(c_cost, res.x)\n            emissions = np.dot(c_emissions, res.x)\n            results.append([cost, emissions])\n        else:\n            results.append([np.nan, np.nan])\n\n    # EC cases\n    ec_epsilons = [0, 100, 1000, 3600]\n    for epsilon in ec_epsilons:\n        # Augment A_ub and b_ub for the epsilon constraint: c_emissions * z = epsilon\n        A_ub_ec = np.vstack([A_ub, c_emissions])\n        b_ub_ec = np.hstack([b_ub, epsilon])\n        \n        res = linprog(c=c_cost, A_ub=A_ub_ec, b_ub=b_ub_ec, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            cost = res.fun\n            emissions = np.dot(c_emissions, res.x)\n            results.append([cost, emissions])\n        else:\n            results.append([np.nan, np.nan])\n\n    # 4. FORMAT AND PRINT OUTPUT\n    # --------------------------\n    formatted_results = []\n    for res_pair in results:\n        c, e = res_pair\n        c_str = f\"{c:.2f}\" if not np.isnan(c) else \"NaN\"\n        e_str = f\"{e:.2f}\" if not np.isnan(e) else \"NaN\"\n        formatted_results.append(f\"[{c_str},{e_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}