{
    "hands_on_practices": [
        {
            "introduction": "长期规划的核心是比较发生在不同时间点的成本和收益。本练习将提供使用净现值 (Net Present Value, NPV) 方法的实践机会，这是综合资源规划中的一个基本工具。你将探索折现率如何深刻地影响着在资本密集型、长寿命资产和成本较低、短寿命资产之间的选择，而折现率正反映了资金的时间价值。",
            "id": "4097905",
            "problem": "您的任务是在能源系统建模中的综合资源规划背景下，设计并实施一项关于折现率的敏感性分析，并量化其对使用净现值方法进行的长寿命与短寿命资源计划排序的影响。该分析必须根据跨期估值和时间偏好的基本原理来构建。设想一个中心化规划者，他使用货币时间价值原理在一个固定的规划期内评估资源计划：根据一个恒定的实际折现率，未来现金流的价值低于当前现金流。一个资源计划由一系列现金流定义，包括投资支出、年度运营支出、年度运营收益以及期末残值。规划期是固定的，并且对所有资源计划都相同；在此期间，相互竞争的计划必须提供相同的年度服务。当一个资源的技术寿命短于规划期时，将根据需要进行相同的重置，以在整个规划期内提供服务。如果一个资源实例的寿命超出了规划期，在规划期末，其未到期寿命将通过按比例剩余年限估值法转换为残值。\n\n使用的基本假设（除了从这些原理中可以推导出的公式外，不要使用任何快捷公式）：\n- 货币时间价值由一个恒定的年度实际折现率 $r \\in [0,1)$ 表示。在第 $t$ 年末发生的现金流，其现值根据折现率 $r$ 的折现原理确定。\n- 每个资源实例都有一个技术寿命，记为 $L$；一次性资本投资成本 $K$（以美元计量的正数）；恒定的年度运营与维护成本 $C$（以美元/年计量）；以及恒定的年度运营收益 $B$（以美元/年计量）。每个活跃年份的净运营现金流为 $(B - C)$。\n- 规划者使用一个固定的规划期 $H$（以年为单位）。为确保各个计划提供相同的服务，短寿命资源将在第 $0, L, 2L, \\dots$ 年进行重置，只要安装年份 $y  H$。如果最后一个实例的寿命超出 $H$，其剩余寿命将在第 $H$ 年转换为残值，其值等于未到期寿命分数乘以 $K$。如果最后一个实例恰好在 $H$ 结束，则残值为零。类似地，长寿命资源也根据需要进行重置以覆盖 $H$；最后一个实例在 $H$ 时的任何剩余寿命也以同样的方式产生残值。\n- 所有现金流均在每年年末发生。资本成本 $K$ 在安装当年的年末产生，年度净运营现金流 $(B - C)$ 在每个活跃年份的年末产生。残值（如有）在第 $H$ 年年末产生。\n- 所有数值均以美元（USD）为单位。您必须以美元报告所有最终的数值量（如适用），并将无量纲量报告为纯小数。不涉及角度。\n\n您的任务：\n1. 对于下述每个测试用例，实现一个函数，在给定 $r$ 的情况下，使用上述原理计算每个资源计划在规划期 $H$ 内的净现值（以美元计）。然后，对于一个指定的折现率网格，确定一个比例（表示为0到1之间的小数），该比例代表了在多少折现率下，长寿命计划的净现值严格高于短寿命计划。如果出现相等情况（在容差 $\\varepsilon = 10^{-9}$ 内），则计为0.5。\n2. 对于每个测试用例，确定盈亏平衡折现率 $r^\\star \\in [0,1)$（如果存在），在该折现率下，长寿命和短寿命计划的净现值相等。如果在 $[0,1)$ 区间内不存在这样的 $r^\\star$，则返回 $-1.0$。使用基于基本原理和连续性的稳健数值方法来确定 $r^\\star$。\n3. 敏感性分析输出：对于每个测试用例，返回一对浮点数：任务1中描述的比例和任务2中的盈亏平衡折现率。最终的程序输出必须将所有测试用例的结果汇总到单行输出中，形式为方括号内以逗号分隔的列表。数字必须四舍五入到六位小数。\n\n测试套件：\n使用以下三个具有指定参数的测试用例，以及通用的折现率网格 $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$（无量纲小数）：\n\n- 测试用例1（具有不同寿命和中等现金流的理想路径）：\n    - 规划期：$H = 30$ 年。\n    - 长寿命资源：寿命 $L_{\\mathrm{long}} = 25$ 年，资本成本 $K_{\\mathrm{long}} = 1200$ 美元，年度收益 $B = 220$ 美元/年，年度运营成本 $C_{\\mathrm{long}} = 70$ 美元/年。\n    - 短寿命资源：寿命 $L_{\\mathrm{short}} = 10$ 年，资本成本 $K_{\\mathrm{short}} = 700$ 美元，年度收益 $B = 220$ 美元/年，年度运营成本 $C_{\\mathrm{short}} = 80$ 美元/年。\n\n- 测试用例2（边界主导情况，其设计使得某个计划可能在所有折现率下都占优）：\n    - 规划期：$H = 30$ 年。\n    - 长寿命资源：寿命 $L_{\\mathrm{long}} = 30$ 年，资本成本 $K_{\\mathrm{long}} = 800$ 美元，年度收益 $B = 230$ 美元/年，年度运营成本 $C_{\\mathrm{long}} = 60$ 美元/年。\n    - 短寿命资源：寿命 $L_{\\mathrm{short}} = 10$ 年，资本成本 $K_{\\mathrm{short}} = 850$ 美元，年度收益 $B = 230$ 美元/年，年度运营成本 $C_{\\mathrm{short}} = 80$ 美元/年。\n\n- 测试用例3（具有多次重置和显著残值的边缘情况）：\n    - 规划期：$H = 30$ 年。\n    - 长寿命资源：寿命 $L_{\\mathrm{long}} = 35$ 年，资本成本 $K_{\\mathrm{long}} = 1500$ 美元，年度收益 $B = 210$ 美元/年，年度运营成本 $C_{\\mathrm{long}} = 70$ 美元/年。\n    - 短寿命资源：寿命 $L_{\\mathrm{short}} = 7$ 年，资本成本 $K_{\\mathrm{short}} = 500$ 美元，年度收益 $B = 210$ 美元/年，年度运营成本 $C_{\\mathrm{short}} = 90$ 美元/年。\n\n科学真实性与一致性：\n- 假设使用实际（经通胀调整的）美元。除了比例残值规则外，不包括税收或折旧。假设每个资源在活跃时具有完全的可靠性和相同的年度服务。\n\n精度与格式要求：\n- 在排序确定中使用 $\\varepsilon = 10^{-9}$ 作为相等性容差。\n- 使用 $r^\\star$ 搜索区间 $[0, 0.9]$。如果在此区间内未观察到净现值差异的符号变化，则返回 $-1.0$。\n- 将所有报告的浮点数四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，顺序为：$[\\text{prop}_1, r^\\star_1, \\text{prop}_2, r^\\star_2, \\text{prop}_3, r^\\star_3]$，其中 $\\text{prop}_i$ 是测试用例 $i$ 的比例，而 $r^\\star_i$ 是测试用例 $i$ 的盈亏平衡折现率。\n\n您的实现必须是一个使用任何现代编程语言编写的完整、可运行的程序。在最终答案中，请提供可执行的 Python 代码，该代码应符合指定的运行环境，仅打印所需的单行输出，并且不需要外部输入。",
            "solution": "我们从跨期估值和净现值定义的基本原理出发。其根本基础是货币的时间价值：由于时间偏好和机会成本，未来收到的一美元在今天的价值较低。设 $r \\in [0,1)$ 表示恒定的年度实际折现率。在第 $t$ 年末发生的现金流，其现值通过使用 $r$ 进行折现得到，这与现值算子在时间区间上是可乘的、在同一时间发生的现金流上是可加的原理相一致。\n\n一个资源计划由参数 $(H, L, K, B, C)$ 定义。每个资源实例从安装开始到其技术寿命 $L$ 结束，都提供相同的年度服务，之后必须更换以维持服务。在规划期 $H$ 内，当 $y  H$ 时，在第 $y \\in \\{0, L, 2L, \\ldots\\}$ 年进行相同的重置。对于在第 $y$ 年的每次安装，在第 $y$ 年年末有资本成本 $K$，在每个活跃年份 $t \\in \\{y+1, y+2, \\ldots, \\min(y+L, H)\\}$ 的年末有年度净运营现金流 $(B - C)$，并且，如果该实例的寿命超出规划期，在 $t = H$ 时有代表剩余寿命分数乘以资本成本的残值现金流。\n\n残值源自按比例剩余年限估值法。如果一次安装发生在第 $y$ 年，且其技术寿命超出规划期，则在 $H$ 时的未到期寿命为 $(y + L - H)$ 年，因此剩余寿命分数为 $\\max\\{y + L - H, 0\\}/L$。在 $t = H$ 时的残值现金流则为：\n$$\nS(y) = K \\cdot \\frac{\\max\\{y + L - H, 0\\}}{L}.\n$$\n这个在第 $H$ 年年末发生的 $S(y)$，与在 $t = H$ 时的任何其他现金流一样被折现。\n\n设 $CF_t$ 表示所有安装合并后在第 $t$ 年末的净现金流。根据现金流的可加性和折现下现值的线性性，折现率 $r$ 的净现值为：\n$$\n\\mathrm{NPV}(r) = \\sum_{t = 0}^{H} \\frac{CF_t}{(1 + r)^t}.\n$$\n为构建 $CF_t$，对于在 $y$ 年的每次安装：\n- 在 $t = y$ 时：加上 $(-K)$。\n- 对于每个 $t \\in \\{y+1, \\ldots, \\min(y+L, H)\\}$：加上 $(B - C)$。\n- 在 $t = H$ 时：如果 $y + L > H$，则加上 $S(y)$。\n\n这种表示方法通过对短寿命资源进行重复安装，以及在需要时对长寿命资源进行安装，来确保各个计划提供相同的服务。\n\n排序和敏感性分析定义如下。给定长寿命和短寿命两个计划及其各自的参数集，将其净现值定义为函数 $\\mathrm{NPV}_{\\mathrm{long}}(r)$ 和 $\\mathrm{NPV}_{\\mathrm{short}}(r)$。对于一个折现率网格 $R = \\{r_1, r_2, \\ldots, r_m\\}$，计算长寿命计划在净现值上严格占优的折现率所占的比例。形式上，考虑到数值精度，设相等性容差为 $\\varepsilon = 10^{-9}$，对每个 $r \\in R$ 定义：\n- 如果 $\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r) > \\varepsilon$，计数为 $1$。\n- 如果 $|\\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r)| \\le \\varepsilon$，计数为 $0.5$。\n- 否则，计数为 $0$。\n比例是计数总和除以 $|R|$（一个介于0和1之间的纯小数）。\n\n为计算盈亏平衡折现率 $r^\\star$，考虑连续函数：\n$$\nf(r) = \\mathrm{NPV}_{\\mathrm{long}}(r) - \\mathrm{NPV}_{\\mathrm{short}}(r).\n$$\n在上述假设下，每个 $\\mathrm{NPV}$ 都是形如 $a_t (1 + r)^{-t}$ 的项的有限和，其中 $a_t$ 是常数。因此，当后期正现金流占主导且前期发生负现金流（投资）时（这在资源规划中很常见），$f(r)$ 是关于 $r$ 的连续且严格递减函数。一种稳健的数值方法是，当观察到符号变化时（即 $f(0) \\cdot f(0.9)  0$），在 $[0, 0.9]$ 上使用二分法。如果在 $[0, 0.9]$ 上没有发生符号变化，则此区间内不存在根，我们报告 $-1.0$。当应用二分法时，迭代地将区间对半分割并在中点评估 $f$，不断缩小区间范围，直到区间宽度或 $|f(r)|$ 低于一个很小的容差；然后我们将中点报告为 $r^\\star$。\n\n算法设计：\n1. 实现一个函数，在给定 $(H, L, K, B, C)$ 和 $r$ 的情况下，通过迭代安装时间 $y \\in \\{0, L, 2L, \\ldots\\}$（其中 $y  H$），并累加资本支出、直至 $H$ 的活跃年份的年度净运营现金流 $(B - C)$，以及根据 $S(y)$ 在 $t=H$ 时的残值，来构建序列 $\\{CF_t\\}_{t=0}^{H}$。\n2. 计算 $\\mathrm{NPV}(r)$ 为 $\\sum_{t=0}^{H} CF_t (1 + r)^{-t}$。注意，当 $r = 0$ 时，折现因子简化为 $1$，总和即为未折现的总额。\n3. 对于每个测试用例，使用各自的参数定义 $\\mathrm{NPV}_{\\mathrm{long}}(r)$ 和 $\\mathrm{NPV}_{\\mathrm{short}}(r)$。对于费率网格 $R = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]$，计算长寿命计划严格占优的折现率比例，其中相等情况计为 $0.5$，容差为 $\\varepsilon = 10^{-9}$。\n4. 为求解盈亏平衡点 $r^\\star$，计算 $f(0)$ 和 $f(0.9)$。如果存在符号变化，则执行二分法以高精度找到 $r^\\star$（例如，直到区间宽度小于 $10^{-12}$ 或 $|f(r)|$ 小于 $10^{-12}$）。如果没有符号变化，则设 $r^\\star = -1.0$。\n5. 格式化输出：对于每个测试用例，将比例和 $r^\\star$ 四舍五入到六位小数，并按指定格式汇总到单行输出中。\n\n通过一致的年度收益和成本、实际美元折现、通过重复重置实现的服务均等性，以及通过按比例剩余年限计算的残值，确保了科学真实性。数值方法依赖于现值函数在 $r$ 上的连续性，并使用稳健的区间法进行求根，避免了对无原理依据的捷径的依赖。\n\n最终程序为每个测试用例计算有利于长寿命计划的折现率比例和盈亏平衡折现率（如不适用则为 $-1.0$），并将它们作为一个以逗号分隔、用方括号括起来的列表打印出来，四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_cash_flows(H: int, L: int, K: float, B: float, C: float) - np.ndarray:\n    \"\"\"\n    Construct the annual cash flow vector CF[0..H] for a resource plan defined by:\n    - Planning horizon H (years)\n    - Lifetime L (years)\n    - Capital cost K (USD)\n    - Annual benefit B (USD/year)\n    - Annual O cost C (USD/year)\n\n    Convention:\n    - All flows occur at year-end.\n    - Installation at year y incurs -K at t=y.\n    - Net operating cash flow (B - C) occurs at end of active years t in [y+1, min(y+L, H)].\n    - Salvage occurs at t=H for installations whose lifetime extends beyond H:\n        S(y) = K * max(y + L - H, 0) / L\n    \"\"\"\n    CF = np.zeros(H + 1, dtype=float)\n    # Installation years: 0, L, 2L, ..., while y  H\n    y = 0\n    while y  H:\n        # Capital outlay at year y\n        CF[y] += -K\n        # Annual net operating cash flows for active years until horizon\n        active_end = min(y + L, H)\n        # Operating flows at end of years y+1 .. active_end\n        if active_end >= y + 1:\n            CF[y + 1:active_end + 1] += (B - C)\n        # Salvage at end of horizon if lifetime extends beyond H\n        if y + L > H:\n            remaining_life = (y + L) - H  # positive if extends beyond H\n            salvage = K * (remaining_life / L)\n            CF[H] += salvage\n        # Next installation\n        y += L\n    return CF\n\ndef npv_of_plan(CF: np.ndarray, r: float) - float:\n    \"\"\"\n    Compute NPV given cash flow vector CF[0..H] and discount rate r in [0,1).\n    All flows are at year-end, discounted by (1 + r)^t.\n    \"\"\"\n    H = len(CF) - 1\n    if r == 0.0:\n        return float(np.sum(CF))\n    # Use stable computation for discount factors\n    t = np.arange(H + 1, dtype=float)\n    discount = np.power(1.0 + r, -t)\n    return float(np.dot(CF, discount))\n\ndef proportion_long_wins(npv_long, npv_short, rates, eps=1e-9) - float:\n    \"\"\"\n    Compute the proportion of rates where long-lived plan wins:\n    - Count 1 if NPV_long - NPV_short > eps\n    - Count 0.5 if abs difference = eps\n    - Count 0 if NPV_long - NPV_short  -eps\n    Return sum(counts) / len(rates).\n    \"\"\"\n    total = 0.0\n    for r in rates:\n        dl = npv_long(r)\n        ds = npv_short(r)\n        diff = dl - ds\n        if diff > eps:\n            total += 1.0\n        elif abs(diff) = eps:\n            total += 0.5\n        else:\n            total += 0.0\n    return total / len(rates)\n\ndef break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200) - float:\n    \"\"\"\n    Find r* in [r_low, r_high] such that NPV_long(r*) == NPV_short(r*),\n    using bisection if a sign change exists. If no sign change, return -1.0.\n    \"\"\"\n    def f(r):\n        return npv_long(r) - npv_short(r)\n    f_low = f(r_low)\n    f_high = f(r_high)\n    # If no sign change, no root in [r_low, r_high]\n    if f_low == 0.0:\n        return r_low\n    if f_high == 0.0:\n        return r_high\n    if f_low * f_high > 0.0:\n        return -1.0\n    a, b = r_low, r_high\n    fa, fb = f_low, f_high\n    for _ in range(max_iter):\n        m = 0.5 * (a + b)\n        fm = f(m)\n        # Check convergence\n        if abs(fm)  tol or (b - a)  tol:\n            return m\n        # Update bracket\n        if fa * fm = 0.0:\n            b, fb = m, fm\n        else:\n            a, fa = m, fm\n    # Return midpoint after max_iter\n    return 0.5 * (a + b)\n\ndef format_float(x: float) - str:\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define discount rate grid\n    rates = [0.0, 0.02, 0.05, 0.08, 0.12, 0.20, 0.35]\n\n    # Test cases parameters\n    test_cases = [\n        # (H, (L_long, K_long, B, C_long), (L_short, K_short, B, C_short))\n        (30, (25, 1200.0, 220.0, 70.0), (10, 700.0, 220.0, 80.0)),  # Test Case 1\n        (30, (30, 800.0, 230.0, 60.0), (10, 850.0, 230.0, 80.0)),  # Test Case 2\n        (30, (35, 1500.0, 210.0, 70.0), (7, 500.0, 210.0, 90.0)),  # Test Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        H, long_params, short_params = case\n        L_long, K_long, B_long, C_long = long_params\n        L_short, K_short, B_short, C_short = short_params\n\n        # Build cash flows for both plans\n        CF_long = build_cash_flows(H, L_long, K_long, B_long, C_long)\n        CF_short = build_cash_flows(H, L_short, K_short, B_short, C_short)\n\n        # Define NPV functions as closures over r\n        npv_long = lambda r, CF=CF_long: npv_of_plan(CF, r)\n        npv_short = lambda r, CF=CF_short: npv_of_plan(CF, r)\n\n        # Proportion of rates where long-lived wins\n        prop = proportion_long_wins(npv_long, npv_short, rates, eps=1e-9)\n\n        # Break-even discount rate via bisection on [0, 0.9]\n        r_star = break_even_rate(npv_long, npv_short, r_low=0.0, r_high=0.9, tol=1e-12, max_iter=200)\n\n        results.append(format_float(prop))\n        results.append(format_float(r_star))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "现实世界的规划必须应对不确定的未来，从波动的燃料价格到不断变化的政策。本实践介绍两阶段随机规划，这是一个强大的框架，用于制定稳健的、能够适应各种未来情景的当下投资决策。通过对“此时此地”的容量决策和“等待观察”的运营调整进行建模，你将学习如何构建一个有弹性且成本效益高的能源组合。",
            "id": "4097963",
            "problem": "考虑一个用于电力系统的两阶段随机综合资源规划模型，该模型包含三种发电技术：天然气、风能和太阳能。第一阶段选择以兆瓦（MW）为单位的装机容量，第二阶段在燃料价格、负荷增长和政策参数不确定的情况下运营这些容量，以满足以兆瓦时（MWh）为单位的能源需求。所有数量和常数必须使用指定的单位进行处理，并且所有最终成本输出必须以美元表示。\n\n基本基准和定义：\n- 令技术集合为 $\\mathcal{T} = \\{\\text{gas}, \\text{wind}, \\text{solar}\\}$。\n- 令时间区块集合为 $\\mathcal{H} = \\{\\text{peak}, \\text{offpeak}\\}$，其中小时数 $H_{\\text{peak}} = 2000$ 和 $H_{\\text{offpeak}} = 6760$，因此 $H_{\\text{peak}} + H_{\\text{offpeak}} = 8760$。\n- 基本平均需求为 $D_{\\text{peak}} = 500$ 兆瓦（MW）和 $D_{\\text{offpeak}} = 300$ 兆瓦（MW），导致基本能源需求为 $E_{\\text{peak}}^{\\text{base}} = D_{\\text{peak}} \\cdot H_{\\text{peak}} = 1{,}000{,}000$ 兆瓦时（MWh）和 $E_{\\text{offpeak}}^{\\text{base}} = D_{\\text{offpeak}} \\cdot H_{\\text{offpeak}} = 2{,}028{,}000$ 兆瓦时（MWh）。特定情景的能源需求按负荷增长因子 $g_s$ 缩放，因此对于 $h \\in \\mathcal{H}$ 有 $E_{s,h} = g_s \\cdot E_{h}^{\\text{base}}$。\n\n技术参数：\n- 年化固定容量成本（每兆瓦年）为 $C_{\\text{gas}}^{\\text{cap}} = 100{,}000$ 美元/兆瓦年，$C_{\\text{wind}}^{\\text{cap}} = 200{,}000$ 美元/兆瓦年，$C_{\\text{solar}}^{\\text{cap}} = 150{,}000$ 美元/兆瓦年。\n- 可变运营和维护（OM）成本（每兆瓦时，不包括情景燃料价格和政策成本）为 $c_{\\text{gas}}^{\\text{om}} = 5$ 美元/兆瓦时，$c_{\\text{wind}}^{\\text{om}} = 3$ 美元/兆瓦时，$c_{\\text{solar}}^{\\text{om}} = 2$ 美元/兆瓦时。\n- 天然气的二氧化碳排放率为 $e_{\\text{gas}} = 0.4$ 吨二氧化碳/兆瓦时。风能和太阳能的排放为零。\n- 可用性（按区块划分的容量因子）为 $a_{\\text{gas},\\text{peak}} = 0.9$，$a_{\\text{gas},\\text{offpeak}} = 0.9$，$a_{\\text{wind},\\text{peak}} = 0.35$，$a_{\\text{wind},\\text{offpeak}} = 0.45$，$a_{\\text{solar},\\text{peak}} = 0.2$，$a_{\\text{solar},\\text{offpeak}} = 0.05$。\n\n情景构建：\n- 令情景空间为三个集合的笛卡尔积：天然气燃料的燃料价格情景 $\\mathcal{F}$（单位：美元/兆瓦时），负荷增长因子 $\\mathcal{G}$（对基础能源的无量纲乘数），以及政策情景 $\\mathcal{P}$，包括碳税 $p^{\\text{CO2}}$（单位：美元/吨）和年度排放上限 $E^{\\text{cap}}$（单位：吨）。每个情景 $s$ 是一个元组 $(f_s, g_s, p_s^{\\text{CO2}}, E_s^{\\text{cap}})$，具有相关概率 $\\pi_s$。假设集合之间相互独立，因此每个情景概率是各分量概率的乘积，并等于笛卡尔积上的均匀概率。\n\n两阶段随机规划：\n- 第一阶段决策变量为技术 $t \\in \\mathcal{T}$ 的装机容量 $x_t \\ge 0$，单位为兆瓦（MW）。\n- 第二阶段决策变量为技术 $t \\in \\mathcal{T}$、情景集 $\\mathcal{S}$ 中的情景 $s$ 和时间区块 $h \\in \\mathcal{H}$ 的能源调度 $y_{t,s,h} \\ge 0$，单位为兆瓦时（MWh）。\n\n目标函数（最小化预期年度总成本）：\n$$\n\\min_{x, y} \\quad \\sum_{t \\in \\mathcal{T}} C_t^{\\text{cap}} \\, x_t \\;+\\; \\sum_{s \\in \\mathcal{S}} \\pi_s \\left( \\sum_{h \\in \\mathcal{H}} \\left[ \\left(c_{\\text{gas}}^{\\text{om}} + f_s + p_s^{\\text{CO2}} \\, e_{\\text{gas}}\\right) y_{\\text{gas},s,h} + c_{\\text{wind}}^{\\text{om}} \\, y_{\\text{wind},s,h} + c_{\\text{solar}}^{\\text{om}} \\, y_{\\text{solar},s,h} \\right] \\right) \\right).\n$$\n\n每个情景 $s \\in \\mathcal{S}$ 和区块 $h \\in \\mathcal{H}$ 的约束条件：\n1. 能源平衡：\n$$\n\\sum_{t \\in \\mathcal{T}} y_{t,s,h} = E_{s,h}.\n$$\n2. 容量到能源的可用性（按技术和区块）：\n$$\ny_{t,s,h} \\le x_t \\cdot a_{t,h} \\cdot H_h, \\quad \\forall t \\in \\mathcal{T}.\n$$\n3. 年度排放上限：\n$$\ne_{\\text{gas}} \\sum_{h \\in \\mathcal{H}} y_{\\text{gas},s,h} \\le E_s^{\\text{cap}}.\n$$\n4. 非负性：\n$$\nx_t \\ge 0, \\quad y_{t,s,h} \\ge 0.\n$$\n\n该公式强制执行了非预期性（nonanticipativity），因为第一阶段容量 $x_t$ 在所有情景中共享。该模型是线性的，可以通过将其转换为其确定性等效线性规划并使用标准线性规划求解器来求解。\n\n数值测试套件：\n实施该程序以计算以下三个测试用例中每个用例的最小预期年度成本（以美元计）。使用列出的确切值，并假设笛卡尔积上的概率是均匀的。\n\n- 测试用例 1（平衡不确定性）：\n  - 燃料价格情景 $\\mathcal{F} = \\{20, 40\\}$ 美元/兆瓦时（天然气）。\n  - 负荷增长因子 $\\mathcal{G} = \\{1.0, 1.1\\}$（无量纲）。\n  - 政策情景 $\\mathcal{P} = \\{(p^{\\text{CO2}} = 0, E^{\\text{cap}} = 2{,}000{,}000),\\; (p^{\\text{CO2}} = 50, E^{\\text{cap}} = 1{,}200{,}000)\\}$，其中碳税单位为美元/吨，上限单位为吨。\n  - 8 个情景中每个情景的概率为 $\\pi_s = 0.125$。\n\n- 测试用例 2（严格排放上限）：\n  - 燃料价格情景 $\\mathcal{F} = \\{25, 35\\}$ 美元/兆瓦时（天然气）。\n  - 负荷增长因子 $\\mathcal{G} = \\{1.0, 1.2\\}$（无量纲）。\n  - 政策情景 $\\mathcal{P} = \\{(p^{\\text{CO2}} = 100, E^{\\text{cap}} = 400{,}000)\\}$。\n  - 4 个情景中每个情景的概率为 $\\pi_s = 0.25$。\n\n- 测试用例 3（廉价天然气，宽松政策）：\n  - 燃料价格情景 $\\mathcal{F} = \\{10\\}$ 美元/兆瓦时（天然气）。\n  - 负荷增长因子 $\\mathcal{G} = \\{0.95, 1.0\\}$（无量纲）。\n  - 政策情景 $\\mathcal{P} = \\{(p^{\\text{CO2}} = 0, E^{\\text{cap}} = 5{,}000{,}000)\\}$。\n  - 2 个情景中每个情景的概率为 $\\pi_s = 0.5$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个条目必须是一个浮点数，给出相应测试用例的最小预期年度成本（以美元计），四舍五入到两位小数，顺序为测试用例 1、测试用例 2 和测试用例 3。例如，格式必须与 $[c_1,c_2,c_3]$ 完全一样，其中 $c_1$、$c_2$ 和 $c_3$ 是计算出的成本（以美元计）。",
            "solution": "问题陈述已经过验证，被确定为一个定义明确、科学合理且客观的两阶段随机线性规划问题。所有必要的数据和定义均已提供，不存在矛盾或歧义。该问题属于能源系统建模的标准框架，特别是不确定性下的综合资源规划。\n\n该问题旨在通过对发电容量投资（第一阶段）和后续运营调度（第二阶段）在一系列可能的未来情景中做出最优决策，来找到电力系统的最小预期年度总成本。解决方案包括将此随机规划公式化为确定性等效线性规划（LP），并使用标准LP求解器进行求解。\n\n**模型构建：确定性等效LP**\n\n通过构建一个单一的、大规模的确定性等效LP来解决两阶段随机规划问题，该LP同时代表所有情景下的所有决策。非预期性约束（第一阶段决策必须在不确定性揭晓之前做出，因此对所有情景必须相同）通过仅设一组第一阶段变量而隐式地得到执行。\n\n**决策变量**\n\n确定性等效LP的决策变量被排列成一个单一向量，表示为 $\\mathbf{z}$。该向量是第一阶段和第二阶段变量的串联。\n- **第一阶段变量**：每种技术 $t \\in \\mathcal{T} = \\{\\text{gas}, \\text{wind}, \\text{solar}\\}$ 的装机容量 $x_t$，单位为兆瓦（MW）。共有 $|\\mathcal{T}| = 3$ 个此类变量。\n- **第二阶段变量**：每种技术 $t \\in \\mathcal{T}$、每个情景 $s \\in \\mathcal{S}$ 和每个时间区块 $h \\in \\mathcal{H} = \\{\\text{peak}, \\text{offpeak}\\}$ 的能源调度 $y_{t,s,h}$，单位为兆瓦时（MWh）。情景总数 $|\\mathcal{S}|$ 对每个测试用例都不同。第二阶段变量的数量为 $|\\mathcal{T}| \\times |\\mathcal{S}| \\times |\\mathcal{H}| = 3 \\times |\\mathcal{S}| \\times 2 = 6|\\mathcal{S}|$。\n\n完整的决策变量向量为 $\\mathbf{z} = [x_{\\text{gas}}, x_{\\text{wind}}, x_{\\text{solar}}, \\dots, y_{t,s,h}, \\dots]^T$，总共有 $3 + 6|\\mathcal{S}|$ 个变量。\n\n**目标函数**\n\n目标是最小化预期年度总成本，即第一阶段投资成本与第二阶段运营成本的概率加权平均值之和。LP目标函数表示为 $\\min \\mathbf{c}^T \\mathbf{z}$，其中 $\\mathbf{c}$ 是成本向量。\n\n- **投资成本系数**：$\\mathbf{c}$ 中对应于容量变量 $x_t$ 的元素是年化固定容量成本 $C_{t}^{\\text{cap}}$。\n- **运营成本系数**：$\\mathbf{c}$ 中对应于调度变量 $y_{t,s,h}$ 的元素是其边际运营成本，按情景概率 $\\pi_s$ 加权。对于给定的情景 $s=(f_s, g_s, p_s^{\\text{CO2}}, E_s^{\\text{cap}})$，可变成本为：\n    - 天然气：$c_{\\text{gas},s}^{\\text{var}} = c_{\\text{gas}}^{\\text{om}} + f_s + p_s^{\\text{CO2}} e_{\\text{gas}}$\n    - 风能：$c_{\\text{wind},s}^{\\text{var}} = c_{\\text{wind}}^{\\text{om}}$\n    - 太阳能：$c_{\\text{solar},s}^{\\text{var}} = c_{\\text{solar}}^{\\text{om}}$\n    $\\mathbf{c}$ 中对应于变量 $y_{t,s,h}$ 的系数为 $\\pi_s \\cdot c_{t,s}^{\\text{var}}$。\n\n**约束条件**\n\n问题约束被转换为LP求解器所需的矩阵形式。它们被分为等式约束（$\\mathbf{A}_{\\text{eq}} \\mathbf{z} = \\mathbf{b}_{\\text{eq}}$）和不等式约束（$\\mathbf{A}_{\\text{ub}} \\mathbf{z} \\le \\mathbf{b}_{\\text{ub}}$）。\n\n1.  **能源平衡（等式约束）**：对于每个情景 $s$ 和时间区块 $h$，总调度能量必须等于能源需求 $E_{s,h} = g_s E_{h}^{\\text{base}}$。\n    $$ \\sum_{t \\in \\mathcal{T}} y_{t,s,h} = E_{s,h} \\quad \\forall s \\in \\mathcal{S}, h \\in \\mathcal{H} $$\n    这产生了 $2|\\mathcal{S}|$ 个等式约束。$\\mathbf{A}_{\\text{eq}}$ 中对应于特定 $(s,h)$ 对的每一行，对于变量 $y_{t,s,h}$（对所有 $t \\in \\mathcal{T}$）的系数为 $1$，其他地方为 $0$。$\\mathbf{b}_{\\text{eq}}$ 中的相应元素将是 $E_{s,h}$。\n\n2.  **容量到能源的可用性（不等式约束）**：在给定区块内，一种技术的调度能量不能超过其可用能量潜力，该潜力是其装机容量 $x_t$、可用性因子 $a_{t,h}$ 和区块持续时间 $H_h$ 的函数。\n    $$ y_{t,s,h} \\le x_t \\cdot a_{t,h} \\cdot H_h \\implies y_{t,s,h} - (a_{t,h} H_h) x_t \\le 0 \\quad \\forall t \\in \\mathcal{T}, s \\in \\mathcal{S}, h \\in \\mathcal{H} $$\n    这产生了 $6|\\mathcal{S}|$ 个不等式约束。$\\mathbf{A}_{\\text{ub}}$ 中的每一行，对于变量 $y_{t,s,h}$ 的系数为 $1$，对于变量 $x_t$ 的系数为 $-a_{t,h} H_h$，其他地方为 $0$。$\\mathbf{b}_{\\text{ub}}$ 中的相应元素将是 $0$。\n\n3.  **年度排放上限（不等式约束）**：对于每个情景 $s$，天然气发电产生的年度二氧化碳总排放量不得超过特定情景的上限 $E_s^{\\text{cap}}$。\n    $$ e_{\\text{gas}} \\sum_{h \\in \\mathcal{H}} y_{\\text{gas},s,h} \\le E_s^{\\text{cap}} \\quad \\forall s \\in \\mathcal{S} $$\n    这产生了 $|\\mathcal{S}|$ 个不等式约束。对于每个情景 $s$，$\\mathbf{A}_{\\text{ub}}$ 中的相应行对于变量 $y_{\\text{gas},s,\\text{peak}}$ 和 $y_{\\text{gas},s,\\text{offpeak}}$ 的系数为 $e_{\\text{gas}}$，其他地方为 $0$。$\\mathbf{b}_{\\text{ub}}$ 中的相应元素将是 $E_s^{\\text{cap}}$。\n\n4.  **非负性**：所有容量和调度变量必须为非负。这通过在LP求解器中为所有变量设置下界为 $0$ 来处理。\n\n**实现**\n\n算法实现涉及编写一个函数，该函数针对每个测试用例：\n1.  从给定的不确定性集合 $\\mathcal{F}$、$\\mathcal{G}$ 和 $\\mathcal{P}$ 的笛卡尔积中生成完整的情景集合 $\\mathcal{S}$ 及其概率 $\\pi_s$。\n2.  动态构建确定性等效LP的组成部分：成本向量 $\\mathbf{c}$、等式约束矩阵 $\\mathbf{A}_{\\text{eq}}$ 和向量 $\\mathbf{b}_{\\text{eq}}$，以及不等式约束矩阵 $\\mathbf{A}_{\\text{ub}}$ 和向量 $\\mathbf{b}_{\\text{ub}}$。使用 `NumPy` 进行高效的矩阵和向量操作。\n3.  将这些组件传递给 `scipy.optimize.linprog` 函数。该函数使用 'highs' 求解器解决LP，该求解器非常适合此类问题。\n4.  求解器返回的最优目标函数值 `result.fun` 代表最小预期年度总成本（以美元计）。然后按要求格式化该值。\n\n对三个测试用例中的每一个重复此过程，并收集最终结果以指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the solution process.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (balanced uncertainties)\n        {\n            'F': [20.0, 40.0],\n            'G': [1.0, 1.1],\n            'P': [(0.0, 2_000_000.0), (50.0, 1_200_000.0)]\n        },\n        # Test Case 2 (tight emissions cap)\n        {\n            'F': [25.0, 35.0],\n            'G': [1.0, 1.2],\n            'P': [(100.0, 400_000.0)]\n        },\n        # Test Case 3 (cheap gas, lax policy)\n        {\n            'F': [10.0],\n            'G': [0.95, 1.0],\n            'P': [(0.0, 5_000_000.0)]\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        cost = solve_irp_case(params['F'], params['G'], params['P'])\n        results.append(f\"{cost:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_irp_case(f_scenarios, g_scenarios, p_scenarios):\n    \"\"\"\n    Solves the two-stage stochastic IRP for a given set of scenario parameters.\n    \"\"\"\n    # --- Define Problem Constants ---\n    TECH_MAP = {'gas': 0, 'wind': 1, 'solar': 2}\n    NUM_TECHS = 3\n    NUM_BLOCKS = 2\n\n    H = np.array([2000.0, 6760.0])  # hours per block\n    E_base = np.array([1_000_000.0, 2_028_000.0])  # MWh per block\n    C_cap = np.array([100_000.0, 200_000.0, 150_000.0])  # $/MW-year\n    c_om = np.array([5.0, 3.0, 2.0])  # $/MWh\n    e_gas = 0.4  # tCO2/MWh\n\n    availability = np.array([\n        [0.9, 0.9],    # gas\n        [0.35, 0.45],  # wind\n        [0.2, 0.05]    # solar\n    ])\n\n    # 1. Generate scenarios from Cartesian product\n    scenarios = list(product(f_scenarios, g_scenarios, p_scenarios))\n    num_scenarios = len(scenarios)\n    pi_s = 1.0 / num_scenarios\n\n    # 2. Define LP problem dimensions\n    num_x_vars = NUM_TECHS\n    num_y_vars = num_scenarios * NUM_BLOCKS * NUM_TECHS\n    num_vars = num_x_vars + num_y_vars\n\n    def y_idx(s_idx, h_idx, t_idx):\n        # Helper to map (scenario, block, tech) to flat index for y variables\n        return num_x_vars + s_idx * (NUM_BLOCKS * NUM_TECHS) + h_idx * NUM_TECHS + t_idx\n\n    # 3. Construct objective function vector c\n    c = np.zeros(num_vars)\n    c[:num_x_vars] = C_cap  # First-stage capacity costs\n\n    for s_idx, (f_s, g_s, (p_co2_s, E_cap_s)) in enumerate(scenarios):\n        var_cost_gas = c_om[0] + f_s + p_co2_s * e_gas\n        var_costs_s = np.array([var_cost_gas, c_om[1], c_om[2]])\n        for h_idx in range(NUM_BLOCKS):\n            for t_idx in range(NUM_TECHS):\n                idx = y_idx(s_idx, h_idx, t_idx)\n                c[idx] = pi_s * var_costs_s[t_idx]\n\n    # 4. Construct equality constraints (energy balance)\n    num_eq_constraints = num_scenarios * NUM_BLOCKS\n    A_eq = np.zeros((num_eq_constraints, num_vars))\n    b_eq = np.zeros(num_eq_constraints)\n    eq_row = 0\n    for s_idx, (_, g_s, _) in enumerate(scenarios):\n        for h_idx in range(NUM_BLOCKS):\n            b_eq[eq_row] = g_s * E_base[h_idx]\n            for t_idx in range(NUM_TECHS):\n                A_eq[eq_row, y_idx(s_idx, h_idx, t_idx)] = 1.0\n            eq_row += 1\n\n    # 5. Construct inequality constraints (capacity  emissions)\n    num_ineq_cap = num_y_vars\n    num_ineq_emissions = num_scenarios\n    num_ineq_constraints = num_ineq_cap + num_ineq_emissions\n    A_ub = np.zeros((num_ineq_constraints, num_vars))\n    b_ub = np.zeros(num_ineq_constraints)\n    \n    # Capacity constraints: y_tsh - x_t * a_th * H_h = 0\n    ineq_row = 0\n    for s_idx in range(num_scenarios):\n        for h_idx in range(NUM_BLOCKS):\n            for t_idx in range(NUM_TECHS):\n                A_ub[ineq_row, y_idx(s_idx, h_idx, t_idx)] = 1.0\n                A_ub[ineq_row, t_idx] = -availability[t_idx, h_idx] * H[h_idx]\n                ineq_row += 1 # b_ub is 0 by default\n\n    # Emissions constraints: e_gas * sum(y_gas,s,h over h) = E_cap_s\n    for s_idx, (_, _, (_, E_cap_s)) in enumerate(scenarios):\n        b_ub[ineq_row] = E_cap_s\n        # y_gas,s,peak\n        A_ub[ineq_row, y_idx(s_idx, 0, TECH_MAP['gas'])] = e_gas\n        # y_gas,s,offpeak\n        A_ub[ineq_row, y_idx(s_idx, 1, TECH_MAP['gas'])] = e_gas\n        ineq_row += 1\n\n    # 6. Define bounds (all variables are non-negative)\n    bounds = (0, None)\n\n    # 7. Solve the Linear Program\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if not result.success:\n        # It's good practice to check if the solver succeeded.\n        raise RuntimeError(f\"LP solver failed for a test case. Status: {result.message}\")\n\n    return result.fun\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "综合资源规划很少有单一的“最佳”答案；相反，它涉及到在相互竞争的目标之间寻求平衡，例如最小化成本和减少环境影响。本练习深入探讨多目标优化，教你如何生成帕累托前沿——代表成本和二氧化碳排放之间权衡的一组最优解。你将使用加权和法与ε-约束法来描绘这些选择，为决策者提供一幅清晰的可用路径图。",
            "id": "4097887",
            "problem": "考虑一个综合资源规划 (IRP) 问题，该问题涉及一个拥有两个规划期和两种发电技术的电力系统。目标是构建并求解一个双目标线性优化模型，以同时最小化折现成本和二氧化碳 (CO2) 累计排放量，然后使用加权和法 (WSM) 和 Epsilon 约束 (EC) 法生成近似的帕累托前沿。\n\n基本依据应基于以下公认的事实和定义。折现现金流使用净现值 (NPV) 计算，其中时间指数为 $t$ 的现金流乘以一个折现因子 $d_t = \\frac{1}{(1+r)^{\\Delta t_t}}$，其中 $r$ 为恒定的真实折现率，$\\Delta t_t$ 为周期长度。累计排放量是各时期排放量的总和，不进行折现。每个时期的年发电量必须恰好满足需求，并且受限于装机容量乘以单位容量的年发电能量，该能量由每年 $8{,}760$ 小时与特定技术的容量因子的乘积得出。多目标优化 (MOO) 旨在寻找帕累托有效的解，即在不恶化其他目标的情况下，任何一个目标都无法得到改善，而诸如加权和法 (WSM) 和 Epsilon 约束 (EC) 法等标量化技术常用于生成帕累托前沿上或其附近的点。\n\n模型结构和决策变量：令规划期由 $t \\in \\{1,2\\}$ 索引，分别对应于 $2025$ 年和 $2030$ 年，技术由 $k \\in \\{\\text{gas}, \\text{wind}\\}$ 索引。令 $x_{k,t} \\ge 0$ 表示在时期 $t$ 为技术 $k$ 增加的容量，单位为兆瓦 (MW)。令 $c_{k,t} \\ge 0$ 表示在时期 $t$ 技术 $k$ 的总可用容量，单位为兆瓦 (MW)，该容量是跨时期累积增加的。令 $y_{k,t} \\ge 0$ 表示在时期 $t$ 技术 $k$ 的年发电量，单位为兆瓦时 (MWh)。容量累积表示为 $c_{k,1} = x_{k,1}$ 和 $c_{k,2} = c_{k,1} + x_{k,2}$。年能量平衡要求 $y_{\\text{gas},t} + y_{\\text{wind},t} = D_t$，其中 $D_t$ 为给定值。年发电量限制为 $y_{k,t} \\le E_k \\cdot c_{k,t}$，其中 $E_k$ 是技术 $k$ 每兆瓦的年发电能量。\n\n参数和物理现实性：使用折现率 $r = 0.07$ 和周期长度 $\\Delta t_1 = 0$, $\\Delta t_2 = 5$，得到折现因子 $d_1 = 1$ 和 $d_2 = \\frac{1}{(1+0.07)^5}$。需求为 $D_1 = 4{,}000$ MWh 和 $D_2 = 5{,}000$ MWh。技术参数如下：\n每兆瓦投资成本：$I_{\\text{gas}} = 900{,}000$ 美元/兆瓦，$I_{\\text{wind}} = 1{,}400{,}000$ 美元/兆瓦。\n每兆瓦时可变运营成本：$V_{\\text{gas}} = 50$ 美元/兆瓦时，$V_{\\text{wind}} = 5$ 美元/兆瓦时。\n每兆瓦时排放率：$e_{\\text{gas}} = 0.4$ 公吨CO2/兆瓦时，$e_{\\text{wind}} = 0$ 公吨CO2/兆瓦时。\n每兆瓦年发电能量：$E_{\\text{gas}} = 8{,}760 \\times 0.6 = 5{,}256$ 兆瓦时/兆瓦-年，$E_{\\text{wind}} = 8{,}760 \\times 0.35 = 3{,}066$ 兆瓦时/兆瓦-年。\n\n目标：将折现总系统成本定义为各时期折现投资成本和运营成本的总和，即时期 $t$ 的项使用 $d_t$ 进行折现，投资成本使用 $I_{k}$ 乘以 $x_{k,t}$，运营成本使用 $V_{k}$ 乘以 $y_{k,t}$。将累计排放量定义为各时期 $e_{k} \\cdot y_{k,t}$ 的总和，不进行折现。\n\n生成帕累托前沿的方法：\n加权和法 (WSM)：构建一个单目标标量化问题，为折现成本设置权重 $w \\in [0,1]$，为累计排放量设置权重 $(1-w)$，以获得候选的帕累托有效解。\nEpsilon 约束 (EC) 法：最小化折现成本，同时满足累计排放量不超过指定边界 $\\epsilon \\ge 0$ 的约束。\n\n任务：\n1. 基于第一性原理，使用上述变量和约束构建双目标优化模型，并实现 WSM 和 EC 两种计算方法以寻找候选的帕累托点。\n2. 使用上文指定的参数值。\n3. 单位：以美元报告折现总成本，以公吨CO2报告累计排放量。报告的两个数值均四舍五入到小数点后两位。\n4. 测试集：对于 WSM，求解权重 $w \\in \\{0, 0.5, 1\\}$ 下的标量化问题。对于 EC，求解排放边界 $\\epsilon \\in \\{0, 100, 1{,}000, 3{,}600\\}$ 下的约束问题。\n5. 最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素本身必须是一个包含两个浮点数的列表 $[C, E]$，分别代表折现总成本 $C$（单位：美元）和累计排放量 $E$（单位：公吨CO2）。结果的排序应首先是 WSM 测试用例（按 $w = 0$, 然后 $w = 0.5$, 然后 $w = 1$ 的顺序），然后是 EC 测试用例（按 $\\epsilon = 0$, 然后 $\\epsilon = 100$, 然后 $\\epsilon = 1{,}000$, 然后 $\\epsilon = 3{,}600$ 的顺序）。如果某个情况不可行，则其结果表示为 $[\\text{NaN}, \\text{NaN}]$。最终打印的单行必须匹配示例格式 $[[c_1,e_1],[c_2,e_2],\\dots]$，不含空格，且数字四舍五入到小数点后两位。",
            "solution": "已根据指定标准对用户提供的问题进行了分析和验证。\n\n### 步骤 1：提取已知条件\n- **索引**：时期 $t \\in \\{1, 2\\}$，技术 $k \\in \\{\\text{gas}, \\text{wind}\\}$。\n- **决策变量**：\n    - $x_{k,t} \\ge 0$：时期 $t$ 技术 $k$ 的新增容量 (MW)。\n    - $c_{k,t} \\ge 0$：时期 $t$ 技术 $k$ 的总容量 (MW)。\n    - $y_{k,t} \\ge 0$：时期 $t$ 技术 $k$ 的年发电量 (MWh)。\n- **模型方程**：\n    - 容量累积：$c_{k,1} = x_{k,1}$，$c_{k,2} = c_{k,1} + x_{k,2}$。\n    - 能量平衡：$y_{\\text{gas},t} + y_{\\text{wind},t} = D_t$，对于 $t \\in \\{1, 2\\}$。\n    - 发电量限制：$y_{k,t} \\le E_k \\cdot c_{k,t}$，对于 $k, t$。\n- **参数**：\n    - 折现率：$r = 0.07$。\n    - 周期长度：$\\Delta t_1 = 0$，$\\Delta t_2 = 5$ 年。\n    - 折现因子：$d_1 = 1/(1+r)^0 = 1$，$d_2 = 1/(1+r)^5$。\n    - 需求：$D_1 = 4{,}000$ MWh，$D_2 = 5{,}000$ MWh。\n    - 投资成本：$I_{\\text{gas}} = 900{,}000$ 美元/兆瓦，$I_{\\text{wind}} = 1{,}400{,}000$ 美元/兆瓦。\n    - 可变成本：$V_{\\text{gas}} = 50$ 美元/兆瓦时，$V_{\\text{wind}} = 5$ 美元/兆瓦时。\n    - 排放率：$e_{\\text{gas}} = 0.4$ 吨CO2/兆瓦时，$e_{\\text{wind}} = 0$ 吨CO2/兆瓦时。\n    - 每兆瓦年发电能量：$E_{\\text{gas}} = 5{,}256$ 兆瓦时/兆瓦，$E_{\\text{wind}} = 3{,}066$ 兆瓦时/兆瓦。\n- **目标**：\n    - 最小化折现成本：$Z_{cost} = \\sum_{t=1}^2 d_t \\left( \\sum_{k} I_k x_{k,t} + \\sum_{k} V_k y_{k,t} \\right)$。\n    - 最小化累计排放量：$Z_{emissions} = \\sum_{t=1}^2 \\sum_{k} e_k y_{k,t}$。\n- **求解方法**：\n    - 加权和法 (WSM)：最小化 $w \\cdot Z_{cost} + (1-w) \\cdot Z_{emissions}$。\n    - Epsilon 约束 (EC) 法：最小化 $Z_{cost}$，约束条件为 $Z_{emissions} \\le \\epsilon$。\n- **测试用例**：\n    - WSM: $w \\in \\{0, 0.5, 1\\}$。\n    - EC: $\\epsilon \\in \\{0, 100, 1000, 3600\\}$。\n- **输出要求**：\n    - 单行文本：`[[c1,e1],[c2,e2],...]`。\n    - 成本和排放量四舍五入到小数点后两位。\n    - 不可行情况表示为 `[NaN, NaN]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题是一个标准（尽管简化了）的能源系统容量扩展模型，是综合资源规划 (IRP) 中的一个经典应用。所有概念，包括折现现金流、排放核算、容量因子和线性优化，都是该领域的基础。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题被构建为一个双目标线性规划。使用 WSM 和 EC 方法将其转化为一系列单目标线性规划 (LP)。一个具有非空有界可行域的标准 LP 是适定的，并保证有解。所提供的数据和约束是充分且一致的，允许存在一个可行解空间（例如，通过风力发电可以实现零排放解决方案）。\n- **客观性**：该问题由精确的数学方程和数值参数定义。语言是客观的，没有主观论断。\n- **完整性和一致性**：构建数学模型所需的所有参数、变量和约束都已明确提供。给定数据中没有矛盾之处。\n- **可行性**：参数值对于学术练习是合理的。需求虽然不大，但为正，使问题不至平庸。约束条件允许在指定的测试用例范围内存在可行解。例如，如果所有需求都由天然气满足，最大可能的排放量是 $0.4 \\times (4000+5000) = 3600$，这与其中一个 epsilon 边界相匹配，表明测试集设计良好。\n- **其他缺陷**：该问题不是琐碎的、隐喻性的或无法验证的。它是将已建立的优化技术直接应用于一个形式化的问题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个能源系统建模领域中适定的、有科学依据的问题，可以使用线性规划来解决。\n\n### 数学公式\n双目标优化问题公式如下。\n\n**决策变量**：\n该问题涉及 $12$ 个连续的非负决策变量：\n-   新增容量：$x_{\\text{gas},1}, x_{\\text{gas},2}, x_{\\text{wind},1}, x_{\\text{wind},2}$。\n-   发电量：$y_{\\text{gas},1}, y_{\\text{gas},2}, y_{\\text{wind},1}, y_{\\text{wind},2}$。\n-   总容量：$c_{\\text{gas},1}, c_{\\text{gas},2}, c_{\\text{wind},1}, c_{\\text{wind},2}$。\n\n**目标函数**：\n1.  最小化折现总成本 ($Z_{cost}$):\n    $$ \\min Z_{cost} = \\sum_{t=1}^{2} d_t \\left( I_{\\text{gas}} x_{\\text{gas},t} + I_{\\text{wind}} x_{\\text{wind},t} + V_{\\text{gas}} y_{\\text{gas},t} + V_{\\text{wind}} y_{\\text{wind},t} \\right) $$\n2.  最小化累计 CO2 排放量 ($Z_{emissions}$):\n    $$ \\min Z_{emissions} = \\sum_{t=1}^{2} \\left( e_{\\text{gas}} y_{\\text{gas},t} + e_{\\text{wind}} y_{\\text{wind},t} \\right) $$\n\n**约束条件**：\n1.  **能量平衡**：对于每个时期 $t \\in \\{1,2\\}$，总发电量必须满足需求 $D_t$。\n    $$ y_{\\text{gas},1} + y_{\\text{wind},1} = D_1 $$\n    $$ y_{\\text{gas},2} + y_{\\text{wind},2} = D_2 $$\n2.  **容量累积**：对于每种技术 $k \\in \\{\\text{gas}, \\text{wind}\\}$，一个时期的总容量是现有容量和新增容量的总和。\n    $$ c_{k,1} = x_{k,1} $$\n    $$ c_{k,2} = c_{k,1} + x_{k,2} $$\n3.  **发电量限制**：对于每种技术 $k$ 和每个时期 $t$，年发电量受其装机容量和能量可用性 $E_k$ 的限制。\n    $$ y_{k,t} \\le E_k \\cdot c_{k,t} $$\n4.  **非负性**：所有决策变量必须为非负。\n    $$ x_{k,t} \\ge 0, y_{k,t} \\ge 0, c_{k,t} \\ge 0 $$\n\n### 标量化与实现策略\n这个双目标线性规划通过两种标量化技术将其转化为一系列单目标线性规划 (LP) 来求解。这些 LP 使用 `scipy.optimize.linprog` 进行求解。\n\n**1. 加权和法 (WSM)**\n通过对两个原始目标进行加权求和，创建一个单目标函数。问题变为：\n$$ \\min \\left( w \\cdot Z_{cost} + (1-w) \\cdot Z_{emissions} \\right) $$\n受限于全套约束条件。这里，$w \\in [0,1]$ 是分配给成本目标的权重。这种方法生成帕累托前沿的凸部上的点。\n\n**2. Epsilon 约束 (EC) 法**\n选择一个目标进行最小化（这里是 $Z_{cost}$），而另一个目标（$Z_{emissions}$）则被转化为一个约束。问题变为：\n$$ \\min Z_{cost} $$\n约束条件：\n-   所有原始约束。\n-   一个附加约束：$Z_{emissions} \\le \\epsilon$，其中 $\\epsilon$ 是允许的最大排放水平。\n\n这种方法可以找到帕累托前沿的凸部和非凸部。\n\n**使用 SciPy 实现**\n问题被转化为标准 LP 形式：$\\min \\mathbf{c}^T \\mathbf{z}$，约束条件为 $\\mathbf{A}_{ub} \\mathbf{z} \\le \\mathbf{b}_{ub}$ 和 $\\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{b}_{eq}$。\n-   决策变量向量 $\\mathbf{z}$ 是一个 $12 \\times 1$ 的列向量，连接了所有 $x, y, c$ 变量。\n-   等式约束矩阵 $\\mathbf{A}_{eq}$ ($6 \\times 12$) 和向量 $\\mathbf{b}_{eq}$ ($6 \\times 1$) 用于强制执行能量平衡和容量累积方程。\n-   不等式约束矩阵 $\\mathbf{A}_{ub}$ ($4 \\times 12$) 和向量 $\\mathbf{b}_{ub}$ ($4 \\times 1$) 用于强制执行发电量限制。\n-   对于每个 WSM 情况，从成本和排放系数向量构造一个复合目标向量 $\\mathbf{c}$。\n-   对于每个 EC 情况，目标向量 $\\mathbf{c}$ 是成本系数向量，并且不等式约束矩阵/向量通过增加一个代表 $Z_{emissions} \\le \\epsilon$ 的新行进行扩充。\n-   对每个测试用例调用 `scipy.optimize.linprog` 函数。如果求解器报告不可行 (`status=2`)，则结果记录为 `[NaN, NaN]`。否则，从解向量 $\\mathbf{z}$ 计算最优成本和排放量并存储。最后，按要求格式化并打印结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a bi-objective IRP problem using WSM and EC methods.\n    \"\"\"\n\n    # 1. DEFINE PARAMETERS\n    # ---------------------\n    params = {\n        'r': 0.07,\n        'D1': 4000.0,\n        'D2': 5000.0,\n        'I_gas': 900000.0,\n        'I_wind': 1400000.0,\n        'V_gas': 50.0,\n        'V_wind': 5.0,\n        'e_gas': 0.4,\n        'e_wind': 0.0,\n        'E_gas': 8760 * 0.6,\n        'E_wind': 8760 * 0.35,\n    }\n    params['d1'] = 1.0\n    params['d2'] = 1.0 / (1.0 + params['r'])**5\n\n    # 2. DEFINE LP STRUCTURE\n    # ----------------------\n    # Decision variable vector z (12 variables):\n    # z = [x_g1, x_g2, x_w1, x_w2, y_g1, y_g2, y_w1, y_w2, c_g1, c_g2, c_w1, c_w2]^T\n    # Indices: x_g1:0, x_g2:1, x_w1:2, x_w2:3, y_g1:4, y_g2:5, y_w1:6, y_w2:7, \n    #          c_g1:8, c_g2:9, c_w1:10, c_w2:11\n    \n    num_vars = 12\n\n    # Objective vectors\n    c_cost = np.zeros(num_vars)\n    c_cost[0] = params['d1'] * params['I_gas']\n    c_cost[1] = params['d2'] * params['I_gas']\n    c_cost[2] = params['d1'] * params['I_wind']\n    c_cost[3] = params['d2'] * params['I_wind']\n    c_cost[4] = params['d1'] * params['V_gas']\n    c_cost[5] = params['d2'] * params['V_gas']\n    c_cost[6] = params['d1'] * params['V_wind']\n    c_cost[7] = params['d2'] * params['V_wind']\n    \n    c_emissions = np.zeros(num_vars)\n    c_emissions[4] = params['e_gas']\n    c_emissions[5] = params['e_gas']\n    c_emissions[6] = params['e_wind']\n    c_emissions[7] = params['e_wind']\n\n    # Equality constraints: A_eq * z = b_eq\n    A_eq = np.zeros((6, num_vars))\n    b_eq = np.zeros(6)\n\n    # Capacity accumulation: c_k1 = x_k1 and c_k2 = c_k1 + x_k2\n    # -x_g1 + c_g1 = 0\n    A_eq[0, 0] = -1; A_eq[0, 8] = 1\n    # -x_g2 - c_g1 + c_g2 = 0\n    A_eq[1, 1] = -1; A_eq[1, 8] = -1; A_eq[1, 9] = 1\n    # -x_w1 + c_w1 = 0\n    A_eq[2, 2] = -1; A_eq[2, 10] = 1\n    # -x_w2 - c_w1 + c_w2 = 0\n    A_eq[3, 3] = -1; A_eq[3, 10] = -1; A_eq[3, 11] = 1\n    \n    # Energy balance: y_g_t + y_w_t = D_t\n    # y_g1 + y_w1 = D1\n    A_eq[4, 4] = 1; A_eq[4, 6] = 1\n    b_eq[4] = params['D1']\n    # y_g2 + y_w2 = D2\n    A_eq[5, 5] = 1; A_eq[5, 7] = 1\n    b_eq[5] = params['D2']\n\n    # Inequality constraints: A_ub * z = b_ub\n    A_ub = np.zeros((4, num_vars))\n    b_ub = np.zeros(4)\n    \n    # Generation limits: y_kt = E_k * c_kt => y_kt - E_k * c_kt = 0\n    # y_g1 - E_g * c_g1 = 0\n    A_ub[0, 4] = 1; A_ub[0, 8] = -params['E_gas']\n    # y_g2 - E_g * c_g2 = 0\n    A_ub[1, 5] = 1; A_ub[1, 9] = -params['E_gas']\n    # y_w1 - E_w * c_w1 = 0\n    A_ub[2, 6] = 1; A_ub[2, 10] = -params['E_wind']\n    # y_w2 - E_w * c_w2 = 0\n    A_ub[3, 7] = 1; A_ub[3, 11] = -params['E_wind']\n    \n    bounds = (0, None) # All variables are non-negative\n\n    results = []\n    \n    # 3. SOLVE FOR TEST CASES\n    # -----------------------\n\n    # WSM cases\n    wsm_weights = [0, 0.5, 1]\n    for w in wsm_weights:\n        c_wsm = w * c_cost + (1 - w) * c_emissions\n        res = linprog(c=c_wsm, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            cost = np.dot(c_cost, res.x)\n            emissions = np.dot(c_emissions, res.x)\n            results.append([cost, emissions])\n        else:\n            results.append([np.nan, np.nan])\n\n    # EC cases\n    ec_epsilons = [0, 100, 1000, 3600]\n    for epsilon in ec_epsilons:\n        # Augment A_ub and b_ub for the epsilon constraint: c_emissions * z = epsilon\n        A_ub_ec = np.vstack([A_ub, c_emissions])\n        b_ub_ec = np.hstack([b_ub, epsilon])\n        \n        res = linprog(c=c_cost, A_ub=A_ub_ec, b_ub=b_ub_ec, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            cost = res.fun\n            emissions = np.dot(c_emissions, res.x)\n            results.append([cost, emissions])\n        else:\n            results.append([np.nan, np.nan])\n\n    # 4. FORMAT AND PRINT OUTPUT\n    # --------------------------\n    formatted_results = []\n    for res_pair in results:\n        c, e = res_pair\n        c_str = f\"{c:.2f}\" if not np.isnan(c) else \"NaN\"\n        e_str = f\"{e:.2f}\" if not np.isnan(e) else \"NaN\"\n        formatted_results.append(f\"[{c_str},{e_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}