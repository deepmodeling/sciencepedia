{
    "hands_on_practices": [
        {
            "introduction": "在进行任何复杂的耦合之前，数据必须在基础上保持一致，这是一个基本前提。一个常见但至关重要的陷阱是单位不匹配。本练习  提供了一个实际场景，涉及二氧化碳兆吨（$\\text{MtCO}_2$）和碳兆吨（$\\text{MtC}$）之间的单位转换错误。通过计算由此产生的差异，您将对这类错误的严重性有切实的体会，并养成严谨的单位验证这一至关重要的思维习惯。",
            "id": "4081500",
            "problem": "一个综合评估模型（IAM）将一个能源系统模块与一个碳循环气候模块耦合。气候模块期望的输入单位是百万吨碳（$\\text{MtC}$），而能源系统模块报告的年排放量单位是百万吨二氧化碳（$\\text{MtCO}_2$）。在 $2020$ 年到 $2024$ 年期间，能源系统模块报告的年二氧化碳排放量 $E_t$（单位：$\\text{MtCO}_2$）如下：$E_{2020} = 2750$，$E_{2021} = 2820$，$E_{2022} = 2895$，$E_{2023} = 2970$，以及 $E_{2024} = 3050$。由于一个单位处理的漏洞，耦合器在 $2022$ 年和 $2023$ 年期间未经单位转换就将这些数值直接传递给了气候模块；在其他年份，转换是正确执行的。假设原子质量为 $M_{\\mathrm{C}} = 12\\,\\mathrm{g/mol}$ 和 $M_{\\mathrm{O}} = 16\\,\\mathrm{g/mol}$，并且排放物仅由二氧化碳（$\\text{CO}_2$）组成。仅使用质量守恒和分子组成的第一性原理，计算在 $2020$-$2024$ 年期间，气候模块实际积分的累积排放量与物理上正确的累积排放量之间的差异，并以十亿吨二氧化碳（$\\text{GtCO}_2$）为单位表示你的最终答案。将你的答案四舍五入到四位有效数字。\n\n另外，请提出一个基于质量守恒和单位一致性的简明验证清单，用于耦合诊断，以便在运行模拟之前能够发现这种不一致性。你的清单应由第一性原理而非临时性的启发式方法来证明其合理性。",
            "solution": "该问题陈述被评估为具有科学依据、问题明确、客观且内部一致。它描述了综合评估建模中的一个现实情景，涉及一个单位转换错误，并要求基于化学的第一性原理进行计算，以及基于软件验证原则提出程序性建议。所有必要的数据都已提供。该问题是有效的。\n\n根据要求，解答分为两部分进行阐述。\n\n第一部分：排放差异的计算\n\n问题的核心在于二氧化碳（$\\text{CO}_2$）的质量与其所含碳（$\\text{C}$）的质量之间的转换。此关系由它们的摩尔质量之比决定。\n\n首先，我们使用给定的原子质量 $M_{\\mathrm{C}} = 12\\,\\mathrm{g/mol}$ 和 $M_{\\mathrm{O}} = 16\\,\\mathrm{g/mol}$ 来确定摩尔质量。\n碳的摩尔质量是 $M_{\\mathrm{C}} = 12\\,\\mathrm{g/mol}$。\n二氧化碳分子的摩尔质量（一个碳原子和两个氧原子组成）是：\n$$M_{\\text{CO}_2} = M_{\\mathrm{C}} + 2 \\times M_{\\mathrm{O}} = 12 + 2 \\times 16 = 12 + 32 = 44\\,\\mathrm{g/mol}$$\n\n根据定比定律，在任何纯 $\\text{CO}_2$ 样品中，碳的质量与二氧化碳的质量之比是恒定的，等于它们的摩尔质量之比。设这个转换因子为 $k_C$：\n$$k_C = \\frac{\\text{碳的质量}}{\\text{CO}_2\\text{的质量}} = \\frac{M_{\\mathrm{C}}}{M_{\\text{CO}_2}} = \\frac{12}{44} = \\frac{3}{11}$$\n这是用于将 $\\text{CO}_2$ 质量转换为相应 $\\text{C}$ 质量的因子。气候模块正确地期望输入单位为百万吨碳（$\\text{MtC}$），这应该通过将能源系统的输出（单位：百万吨二氧化碳, $\\text{MtCO}_2$）乘以 $k_C$ 来获得。\n\n差异仅在未执行单位转换的年份出现，即 $2022$ 年和 $2023$ 年。在这些年份，以 $\\text{MtCO}_2$ 为单位的排放数值（我们称之为 $E_t$）被气候模块错误地解释为以 $\\text{MtC}$ 为单位的质量。\n\n对于存在漏洞的年份 $t$，本应积分的物理上正确的碳质量是 $C_t^{\\text{correct}} = E_t \\times k_C$。\n实际积分的碳质量是 $C_t^{\\text{actual}} = E_t$。\n\n该年积分碳的差异（或误差）是两者之差：\n$$\\Delta C_t = C_t^{\\text{actual}} - C_t^{\\text{correct}} = E_t - E_t \\times k_C = E_t \\left(1 - k_C\\right)$$\n$$\\Delta C_t = E_t \\left(1 - \\frac{12}{44}\\right) = E_t \\left(\\frac{32}{44}\\right) = E_t \\left(\\frac{8}{11}\\right)$$\n这表示在受漏洞影响的给定年份 $t$ 中，气候模型对碳质量的高估。\n\n问题指出漏洞发生在 $2022$ 年和 $2023$ 年。这些年份的排放数据是 $E_{2022} = 2895\\,\\text{MtCO}_2$ 和 $E_{2023} = 2970\\,\\text{MtCO}_2$。\n整个期间积分碳的总差异 $\\Delta C_{\\text{total}}$ 是故障年份差异的总和：\n$$\\Delta C_{\\text{total}} = \\Delta C_{2022} + \\Delta C_{2023} = (E_{2022} + E_{2023}) \\left(1 - \\frac{12}{44}\\right)$$\n$$\\Delta C_{\\text{total}} = (2895 + 2970) \\left(\\frac{8}{11}\\right) = 5865 \\times \\frac{8}{11} = \\frac{46920}{11}\\,\\text{MtC}$$\n这个值 $\\Delta C_{\\text{total}} \\approx 4265.45\\,\\text{MtC}$ 是气候模块因漏洞而多积分的碳的总超额质量。\n\n问题要求将此差异以十亿吨二氧化碳（$\\text{GtCO}_2$）表示。这意味着我们必须找出含有超额碳质量 $\\Delta C_{\\text{total}}$ 的 $\\text{CO}_2$ 的质量。这需要进行逆转换，即乘以 $\\frac{M_{\\text{CO}_2}}{M_C} = \\frac{44}{12}$。\n设 $\\Delta E_{\\text{equiv}}$ 是表示为等效 $\\text{CO}_2$ 质量的差异。\n$$\\Delta E_{\\text{equiv}} = \\Delta C_{\\text{total}} \\times \\frac{M_{\\text{CO}_2}}{M_C} = \\left(5865 \\times \\frac{8}{11}\\right) \\times \\frac{44}{12}$$\n$$\\Delta E_{\\text{equiv}} = 5865 \\times \\frac{8}{11} \\times \\frac{11 \\times 4}{3 \\times 4} = 5865 \\times \\frac{8}{3}$$\n$$\\Delta E_{\\text{equiv}} = 1955 \\times 8 = 15640\\,\\text{MtCO}_2$$\n这是以百万吨二氧化碳为单位的差异大小。\n\n最后，我们将其转换为十亿吨（$\\text{GtCO}_2$）并进行要求的四舍五入。由于 $1\\,\\text{Gt} = 1000\\,\\text{Mt}$：\n$$\\Delta E_{\\text{equiv}} = \\frac{15640}{1000}\\,\\text{GtCO}_2 = 15.640\\,\\text{GtCO}_2$$\n问题要求将答案四舍五入到四位有效数字。计算值 $15.640$ 有五位有效数字。四舍五入到四位有效数字得到 $15.64$。\n\n第二部分：耦合诊断的验证清单\n\n一个基于质量守恒和单位一致性第一性原理的稳健验证清单，对于在耦合模型系统中防止此类错误至关重要。\n\n1.  **接口单位断言：** 模块间交换的所有数据量必须以编程方式用其物理单位进行标记（例如，作为数据结构或元数据的一部分）。在进行任何处理之前，接收模块或耦合组件必须断言输入数据的单位标记与预期单位匹配。如果存在不匹配，模拟必须终止并显示描述性错误。\n    *   *第一性原理依据：* 此检查强制执行了**单位一致性**的基本原则。没有单位的物理量是无意义的。此诊断将单位视为数据的组成部分，防止了代表物理上不同量（例如，$\\text{CO}_2$ 的质量 vs. $\\text{C}$ 的质量）的数值被错误地混淆。\n\n2.  **质量守恒转换检查：** 任何执行涉及守恒物质的单位转换（如将 $\\text{CO}_2$ 质量转换为 $\\text{C}$ 质量）的模块或耦合器，都必须立即执行一次“往返”验证。将输入量 $A$ 转换为输出量 $B$ 后，必须对 $B$ 应用逆转换以计算出 $A'$。然后必须断言 $A$ 和 $A'$ 在一个小的数值容差内相等，即 $|A-A'|/|A|  \\epsilon$。\n    *   *第一性原理依据：* 此检查是**质量守恒定律**的直接实现。化合物质量与其组成元素之一的质量之间的转换是质量守恒的体现。往返计算创建了一个代数不变量（$A = A'$），如果转换正确地嵌入了这一物理定律，该不变量必须成立。在给定的问题中，此检查将灾难性地失败：$E' = C \\times \\frac{44}{12} = E \\times \\frac{44}{12} \\neq E$。\n\n3.  **全系统质量平衡审计：** 在模拟的固定时间间隔或检查点，必须执行自动审计。此审计将源模块（能源系统）排放的守恒物质（碳）的总质量与汇模块（气候模型）接收的该物质的总质量进行比较。这两个累积量之比必须等于 $1$。\n    *   *第一性原理依据：* 这将检查从单个转换提升到集成的**系统级质量守恒验证**。它确保在模拟过程中，数据管道的任何地方都没有质量被“创造”或“销毁”，从而防范更细微的漏洞，如数据包丢失、浮点误差累积或仅随时间推移才显现的错误。",
            "answer": "$$\n\\boxed{15.64}\n$$"
        },
        {
            "introduction": "能源和气候模型通常在不同的空间尺度上运行——气候模型可能使用精细的网格，而能源模型则使用更大、不规则的区域。本练习  将指导您完成空间聚合这一复杂但至关重要的任务。您将实现一个映射，该映射不仅能在不同网格间传输数据，还能保留如均值和方差等关键统计特性，这是确保聚合数据能真实反映底层气候动态的关键一步。",
            "id": "4081536",
            "problem": "给定一个能源系统模型与一个区域气候模型之间的概念耦合任务，其中能源系统模型包含 $10$ 个负荷区域，区域气候模型在 $0.25^{\\circ}$ 经纬度网格上提供风速数据。目标是设计一个空间聚合映射，为每个负荷区域生成一个单一的聚合风速时间序列，该序列在聚合周期内的时间均值和时间方差与对底层网格单元应用指定加权方案所隐含的均值和方差完全匹配。\n\n请使用以下基本统计和物理基础：\n- 一组随机变量之和的时间均值等于它们各自时间均值的和。如果 $x_g(t)$ 是时间序列，那么对于满足 $\\sum_g \\pi_g = 1$ 的权重 $\\pi_g$，聚合序列为 $y(t) = \\sum_g \\pi_g x_g(t)$，其均值为 $\\mu_y = \\sum_g \\pi_g \\mu_g$，其中 $\\mu_g$ 是 $x_g(t)$ 的时间均值。\n- 全方差定律指出，对于一个以概率 $\\pi_g$ 选择单元 $g$ 并从该单元的时间序列中采样 $X$ 的混合分布，其方差为 $\\mathrm{Var}(X) = \\sum_g \\pi_g \\left( \\sigma_g^2 + (\\mu_g - \\mu)^2 \\right)$，其中 $\\sigma_g^2$ 是 $x_g(t)$ 的时间方差，$\\mu = \\sum_g \\pi_g \\mu_g$ 是混合均值。\n- 应用线性聚合和仿射变换从网格单元序列构建区域级序列。\n- 三角函数必须使用以弧度为单位的角度。\n\n网格与映射：\n- 定义一个包含 $4$ 个纬度行和 $5$ 个经度列的矩形网格，其中点位于纬度值 $30.125^{\\circ}$、$30.375^{\\circ}$、$30.625^{\\circ}$、$30.875^{\\circ}$ 和经度值 $-99.875^{\\circ}$、$-99.625^{\\circ}$、$-99.375^{\\circ}$、$-99.125^{\\circ}$、$-98.875^{\\circ}$。这些中点是 $0.25^{\\circ} \\times 0.25^{\\circ}$ 网格单元的中心；底层的纬度范围为 $30.0^{\\circ}$ 到 $31.0^{\\circ}$，经度范围为 $-100.0^{\\circ}$ 到 $-98.75^{\\circ}$。\n- 纬度行由 $i \\in \\{0,1,2,3\\}$ 索引，经度列由 $j \\in \\{0,1,2,3,4\\}$ 索引。负荷区域 $z \\in \\{0,1,\\dots,9\\}$ 包括以下单元隶属关系（以 $(i,j)$ 对的形式给出）：\n  - $z=0$: $(0,0)$, $(0,1)$\n  - $z=1$: $(0,2)$, $(0,3)$\n  - $z=2$: $(0,4)$, $(1,0)$, $(1,1)$\n  - $z=3$: $(1,2)$, $(1,3)$\n  - $z=4$: $(1,4)$, $(2,0)$\n  - $z=5$: $(2,1)$, $(2,2)$\n  - $z=6$: $(2,3)$, $(2,4)$\n  - $z=7$: $(3,0)$, $(3,1)$\n  - $z=8$: $(3,2)$, $(3,3)$\n  - $z=9$: $(3,4)$\n\n风速时间序列：\n- 对于每个网格单元 $(i,j)$，根据物理上合理的组合，为离散时间索引 $t \\in \\{0,1,\\dots,199\\}$ 定义一个确定性的 $T=200$ 步风速时间序列 $x_{i,j}(t)$，单位为米/秒（$\\mathrm{m/s}$）：\n  $$x_{i,j}(t) = 6 + a_{i,j}\\,C_1(t) + 0.2\\,C_2(t) + S_{i,j}(t) + L_{i,j},$$\n  其中\n  $$C_1(t) = 2\\sin\\!\\left(\\frac{2\\pi t}{T}\\right),\\quad C_2(t) = \\sin\\!\\left(\\frac{2\\pi t}{50}\\right),$$\n  $$a_{i,j} = 1 + 0.1\\sin(\\phi_{i,j}),\\quad \\phi_{i,j} = \\mathrm{lat}_{i}\\,\\pi/180 + \\mathrm{lon}_{j}\\,\\pi/180,$$\n  $$S_{i,j}(t) = 0.3\\sin\\!\\left(\\frac{2\\pi t}{T} + \\theta_{i,j}\\right),\\quad \\theta_{i,j} = 0.3(i - j),$$\n  $$L_{i,j} = 0.3(\\mathrm{lat}_i - 30.5) + 0.1(\\mathrm{lon}_j + 99.375) + 0.5\\sin\\!\\left(2\\pi\\frac{i + j}{5}\\right),$$\n  $\\mathrm{lat}_i$ 和 $\\mathrm{lon}_j$ 分别是索引 $i$ 和 $j$ 对应的纬度和经度中点（以度为单位）。所有三角函数参数均为弧度。\n\n加权方案：\n- 对于每个区域 $z$，您将为三种加权方案 $k \\in \\{1,2,3\\}$ 计算聚合权重 $w_{i,j}^{(k)}$：\n  1. 基于面积的权重：$$w_{i,j}^{(1)} = \\cos\\!\\left(\\mathrm{lat}_i\\,\\frac{\\pi}{180}\\right)$$\n  2. 均匀权重：$$w_{i,j}^{(2)} = 1$$\n  3. 自定义强调权重：$$w_{i,j}^{(3)} = 1 + 0.2\\left(\\mathrm{lon}_j - (-99.875)\\right) + 0.1\\left(\\mathrm{lat}_i - 30.125\\right)$$\n- 在每个区域 $z$ 内进行归一化，以获得 $\\pi_{i,j}^{(k)} = w_{i,j}^{(k)} \\Big/ \\sum_{(p,q)\\in z} w_{p,q}^{(k)}$。\n\n各区域和方案的目标统计量：\n- 对于每个区域 $z$ 和方案 $k$，令 $\\mu_{i,j}$ 为 $x_{i,j}(t)$ 的时间均值，$\\sigma^2_{i,j}$ 为 $x_{i,j}(t)$ 的时间方差，两者均在 $t=0,\\dots,199$ 上计算。\n- 定义目标混合均值\n  $$\\mu_z^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)}\\,\\mu_{i,j}$$\n- 使用全方差定律定义目标混合方差\n  $$\\left(\\sigma_z^{2}\\right)^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)}\\left(\\sigma^2_{i,j} + \\left(\\mu_{i,j} - \\mu_z^{*(k)}\\right)^2\\right)$$\n\n聚合映射要求：\n- 构建聚合区域序列 $y_z^{(k)}(t) = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)} x_{i,j}(t)$。\n- 设计并对 $y_z^{(k)}(t)$ 应用一个确定性的仿射变换，仅使用区域局部信息，使得变换后的序列 $\\tilde{y}_z^{(k)}(t)$ 满足\n  $$\\frac{1}{T}\\sum_{t=0}^{T-1} \\tilde{y}_z^{(k)}(t) = \\mu_z^{*(k)}\\quad\\text{和}\\quad \\frac{1}{T}\\sum_{t=0}^{T-1} \\left(\\tilde{y}_z^{(k)}(t) - \\mu_z^{*(k)}\\right)^2 = \\left(\\sigma_z^{2}\\right)^{*(k)}$$\n- 该变换必须在原始单元序列上是空间线性的，并且除了线性聚合和区域级仿射缩放外，不得要求修改原始气候模型输出。\n\n测试套件和输出规范：\n- 为所有 $10$ 个区域和所有 $3$ 种加权方案实现上述过程，生成 $30$ 个特定于区域的无量纲缩放系数（每个区域每个方案一个），以浮点数形式表示。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表，按方案 $k=1,2,3$ 排序，并在每个方案内按区域 $z=0,1,\\dots,9$ 排序；例如，前 $10$ 个数字对应方案 $k=1$ 的区域 $0$ 到 $9$，接下来 $10$ 个对应方案 $k=2$，最后 $10$ 个对应方案 $k=3$。\n- 缩放系数是无单位（无量纲）的数字。所有三角函数参数均使用弧度。输出中不需要任何其他单位。内部风速计算必须使用米/秒（$\\mathrm{m/s}$），但您不得打印单位。",
            "solution": "该问题要求设计一种空间聚合映射，以将网格化气候模型的风速数据与分区能源系统模型耦合。核心任务是为 $10$ 个负荷区域中的每一个和 $3$ 种不同的加权方案，构建一个聚合风速时间序列，其时间均值和时间方差与特定的目标值相匹配。这通过对线性聚合的时间序列应用特定于区域的仿射变换来实现。\n\n解决方法可以分解为以下步骤：\n\n1.  **生成网格单元时间序列**：我们首先为 $4 \\times 5 = 20$ 个网格单元中的每一个合成风速时间序列。单元 $(i,j)$ 的时间序列由以下公式给出：\n    $$x_{i,j}(t) = 6 + a_{i,j}\\,C_1(t) + 0.2\\,C_2(t) + S_{i,j}(t) + L_{i,j}$$\n    时间范围为 $T=200$ 步。该模型将风速表示为一个恒定基值（$6$）、共模周期性波动（$C_1(t)$ 和 $C_2(t)$）、一个空间变化的周期性分量（$S_{i,j}(t)$）和一个空间变化的时间不变偏移量（$L_{i,j}$）的叠加。参数 $a_{i,j}$ 和 $L_{i,j}$ 取决于单元的纬度（$\\mathrm{lat}_i$）和经度（$\\mathrm{lon}_j$），从而引入了空间异质性。所有三角函数均使用弧度进行计算。\n\n2.  **网格单元的统计特征描述**：对于每个网格单元 $(i,j)$，我们计算其时间序列 $x_{i,j}(t)$ 在周期 $T$ 内的时间均值 $\\mu_{i,j}$ 和时间方差 $\\sigma^2_{i,j}$：\n    $$\\mu_{i,j} = \\frac{1}{T}\\sum_{t=0}^{T-1} x_{i,j}(t)$$\n    $$\\sigma^2_{i,j} = \\frac{1}{T}\\sum_{t=0}^{T-1} (x_{i,j}(t) - \\mu_{i,j})^2$$\n    这些统计数据构成了构建聚合区域序列目标属性的基础。\n\n3.  **区域聚合与加权**：对于每个负荷区域 $z$ 和加权方案 $k \\in \\{1, 2, 3\\}$，我们首先为属于该区域的所有单元 $(i,j)$ 计算归一化权重 $\\pi_{i,j}^{(k)}$。原始权重 $w_{i,j}^{(k)}$ 由三种方案（面积、均匀、自定义）给出，并在区域内进行归一化：\n    $$\\pi_{i,j}^{(k)} = \\frac{w_{i,j}^{(k)}}{\\sum_{(p,q)\\in z} w_{p,q}^{(k)}}$$\n    使用这些权重，我们为该区域构建一个线性聚合的时间序列 $y_z^{(k)}(t)$：\n    $$y_z^{(k)}(t) = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)} x_{i,j}(t)$$\n\n4.  **目标统计量的定义**：问题指定了最终变换后的区域时间序列 $\\tilde{y}_z^{(k)}(t)$ 的目标统计特性。\n    -   目标均值 $\\mu_z^{*(k)}$ 是单个单元均值的加权平均值：\n        $$\\mu_z^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)}\\,\\mu_{i,j}$$\n        根据期望（均值）算子的线性特性，线性聚合序列的均值 $\\mathrm{Mean}(y_z^{(k)}(t))$ 天然等于此目标均值 $\\mu_z^{*(k)}$。\n    -   目标方差 $(\\sigma_z^2)^{*(k)}$ 使用全方差定律定义：\n        $$(\\sigma_z^2)^{*(k)} = \\sum_{(i,j)\\in z} \\pi_{i,j}^{(k)} \\left(\\sigma^2_{i,j} + (\\mu_{i,j} - \\mu_z^{*(k)})^2\\right)$$\n        这代表了统计混合模型的方差，其概念上不同于线性聚合和的方差 $\\sigma_{y,z,k}^2 = \\mathrm{Var}(y_z^{(k)}(t))$。后者计算为 $\\frac{1}{T}\\sum_{t=0}^{T-1} (y_z^{(k)}(t) - \\mu_z^{*(k)})^2$。\n\n5.  **仿射变换的设计**：最后一步是找到一个仿射变换 $\\tilde{y}(t) = A y(t) + B$，它将聚合序列 $y_z^{(k)}(t)$ 修改为具有目标统计量。系数 $A$ 和 $B$ 由以下两个条件确定：\n    1.  $\\mathrm{Mean}(\\tilde{y}) = \\mathrm{Mean}(A y + B) = A \\mathrm{Mean}(y) + B = \\mu_z^{*(k)}$\n    2.  $\\mathrm{Var}(\\tilde{y}) = \\mathrm{Var}(A y + B) = A^2 \\mathrm{Var}(y) = (\\sigma_z^2)^{*(k)}$\n\n    如前所述，$\\mathrm{Mean}(y) = \\mu_z^{*(k)}$。将此代入第一个方程得到 $A \\mu_z^{*(k)} + B = \\mu_z^{*(k)}$，这意味着 $B = (1-A)\\mu_z^{*(k)}$。\n    从第二个方程中，我们可以解出问题所要求的量——缩放系数 $A$。假设 $\\mathrm{Var}(y)  0$：\n    $$A^2 = \\frac{(\\sigma_z^2)^{*(k)}}{\\mathrm{Var}(y_z^{(k)}(t))} \\implies A_z^{(k)} = \\sqrt{\\frac{(\\sigma_z^2)^{*(k)}}{\\sigma_{y,z,k}^2}}$$\n    我们取缩放系数的正根。为 $10$ 个区域中的每一个和 $3$ 种加权方案中的每一种计算这个无量纲系数 $A_z^{(k)}$。\n\n该算法首先生成所有 $20$ 个网格单元时间序列及其均值和方差。然后，对于 $30$ 个区域-方案组合中的每一个，它计算归一化权重、目标均值和方差、线性聚合序列的方差，最后计算所需的缩放系数 $A_z^{(k)}$。这30个系数构成了最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spatial aggregation mapping problem by calculating dimensionless\n    scaling coefficients for 10 load zones under 3 weighting schemes.\n    \"\"\"\n\n    # --- Problem Definition ---\n\n    # Grid and time parameters\n    T = 200\n    NUM_LAT_ROWS = 4\n    NUM_LON_COLS = 5\n    NUM_ZONES = 10\n\n    # Grid midpoints\n    lats = 30.125 + 0.25 * np.arange(NUM_LAT_ROWS)\n    lons = -99.875 + 0.25 * np.arange(NUM_LON_COLS)\n    \n    # Zone memberships: list of (i, j) tuples for each zone\n    zone_memberships = [\n        [(0, 0), (0, 1)],  # z=0\n        [(0, 2), (0, 3)],  # z=1\n        [(0, 4), (1, 0), (1, 1)],  # z=2\n        [(1, 2), (1, 3)],  # z=3\n        [(1, 4), (2, 0)],  # z=4\n        [(2, 1), (2, 2)],  # z=5\n        [(2, 3), (2, 4)],  # z=6\n        [(3, 0), (3, 1)],  # z=7\n        [(3, 2), (3, 3)],  # z=8\n        [(3, 4)]           # z=9\n    ]\n\n    # Time vector\n    t = np.arange(T)\n\n    # --- Step 1: Generate Grid Cell Time Series and Statistics ---\n    \n    x_series = np.zeros((NUM_LAT_ROWS, NUM_LON_COLS, T))\n    mu_cells = np.zeros((NUM_LAT_ROWS, NUM_LON_COLS))\n    var_cells = np.zeros((NUM_LAT_ROWS, NUM_LON_COLS))\n\n    # Common time-varying components\n    C1_t = 2 * np.sin(2 * np.pi * t / T)\n    C2_t = np.sin(2 * np.pi * t / 50)\n\n    for i in range(NUM_LAT_ROWS):\n        for j in range(NUM_LON_COLS):\n            lat_deg, lon_deg = lats[i], lons[j]\n            \n            # Spatially varying parameters\n            phi_ij = np.deg2rad(lat_deg) + np.deg2rad(lon_deg)\n            a_ij = 1 + 0.1 * np.sin(phi_ij)\n            \n            theta_ij = 0.3 * (i - j)\n            S_ij_t = 0.3 * np.sin(2 * np.pi * t / T + theta_ij)\n            \n            L_ij = (0.3 * (lat_deg - 30.5) +\n                    0.1 * (lon_deg + 99.375) +\n                    0.5 * np.sin(2 * np.pi * (i + j) / 5))\n            \n            # Construct time series for cell (i, j)\n            x_series[i, j, :] = 6 + a_ij * C1_t + 0.2 * C2_t + S_ij_t + L_ij\n            \n            # Pre-compute cell mean and variance\n            mu_cells[i, j] = np.mean(x_series[i, j, :])\n            # Use population variance (ddof=0 is default)\n            var_cells[i, j] = np.var(x_series[i, j, :])\n\n    # --- Step 2  3: Iterate Schemes and Zones, Calculate Coefficients ---\n\n    results = []\n    \n    for k in range(1, 4):  # Iterate through schemes k=1, 2, 3\n        for z in range(NUM_ZONES): # Iterate through zones z=0, ..., 9\n            cell_indices = zone_memberships[z]\n            num_cells_in_zone = len(cell_indices)\n            \n            # Step 3a: Calculate weights for the current zone and scheme\n            raw_weights = np.zeros(num_cells_in_zone)\n            for idx, (i, j) in enumerate(cell_indices):\n                lat_deg, lon_deg = lats[i], lons[j]\n                if k == 1:  # Area-based weights\n                    raw_weights[idx] = np.cos(np.deg2rad(lat_deg))\n                elif k == 2:  # Uniform weights\n                    raw_weights[idx] = 1.0\n                else:  # k == 3, Custom emphasis weights\n                    raw_weights[idx] = 1 + 0.2 * (lon_deg - lons[0]) + 0.1 * (lat_deg - lats[0])\n            \n            pi_weights = raw_weights / np.sum(raw_weights)\n\n            # Step 3b: Calculate target statistics\n            zone_mu_cells = np.array([mu_cells[i, j] for i, j in cell_indices])\n            zone_var_cells = np.array([var_cells[i, j] for i, j in cell_indices])\n            \n            mu_star_target = np.sum(pi_weights * zone_mu_cells)\n            \n            var_star_target = np.sum(pi_weights * (zone_var_cells + (zone_mu_cells - mu_star_target)**2))\n\n            # Step 3c: Calculate aggregated series and its variance\n            y_series_z_k = np.zeros(T)\n            for idx, (i, j) in enumerate(cell_indices):\n                y_series_z_k += pi_weights[idx] * x_series[i, j, :]\n            \n            var_y = np.var(y_series_z_k)\n\n            # Step 3d: Compute the scaling coefficient\n            if var_y > 0:\n                A = np.sqrt(var_star_target / var_y)\n            elif var_star_target == 0: # If both are 0, variance is already matched\n                A = 1.0\n            else: # var_y is 0 but target is not, indicates an issue\n                A = np.inf # Should not happen in this problem\n                \n            results.append(A)\n\n    # --- Final Output ---\n    # Format the results as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "正如模型具有不同的空间尺度一样，它们也以不同的时间步长运行。本练习  探讨了在同步模型时，计算效率与数值精度之间的权衡。您将设计一个“松散耦合”时间表，以最大限度地减少模型间的通信，同时将气候数据的插值误差保持在指定容差之下，这是设计高效可靠的耦合模拟框架的一项核心技能。",
            "id": "4081556",
            "problem": "给定两个时间步进模拟器：一个原生时间步长为 $\\Delta t_{e} = 1 \\ \\text{hour}$ 的能量模型（EM）和一个原生时间步长为 $\\Delta t_{c} = 6 \\ \\text{hours}$ 的气候模型（CM）。目标是为为期一年的运行设计一个松耦合方案（LCS），以最小化 EM 和 CM 之间的通信开销，同时确保 EM 使用的气候输入的插值误差保持在指定的容差范围内。一年的时间范围为 $T = 8760 \\ \\text{hours}$。\n\n假设每个相关的气候输入都是时间 $t$ 的二次连续可微函数 $x(t)$，其二阶导数的幅值具有已知的全局上界，即对于所有 $t \\in [0, T]$，都有 $\\lvert x''(t) \\rvert \\le M$，其中 $M$ 是给定的。EM 在通信事件之间使用 CM 值的逐段线性插值。LCS 必须由 CM 步长的整数倍的通信时间组成，即通信之间的时间间隔 $h$ 必须满足 $h = N \\, \\Delta t_{c}$，其中 $N$ 为某个整数且 $N \\ge 1$。该方案必须包括 $t=0$ 和 $t=T$。\n\n您必须根据数值近似和光滑性界限的第一性原理，确定一个能产生最大可行通信间隔 $h$ 的 $N$（从而最小化通信次数），以使得 EM 气候输入的最大插值误差受限于给定的容差 $\\varepsilon$。如果不存在满足误差界限且符合 CM 原生步长约束 $h \\ge \\Delta t_{c}$ 的整数 $N \\ge 1$，则该方案不可行。\n\n对于由索引 $i$ 标记的多个气候输入，其界限为 $\\lvert x_i''(t) \\rvert \\le M_i$，容差为 $\\varepsilon_i$，误差约束必须在每个区间内对所有输入同时成立；因此，所选的 $h$ 必须满足所有输入中最严格的界限。\n\n将通信开销定义为在 $[0, T]$ 上的总通信事件数，包括两个端点。对于长度为 $h$ 的时间间隔，通信事件的数量为 $\\left\\lceil \\frac{T}{h} \\right\\rceil + 1$。您的程序必须为测试套件中的每个参数集计算：\n- 满足误差界限的最大可行整数 $N$（其中 $h = N \\, \\Delta t_{c}$）。\n- 在 $[0, T]$ 上相应的总通信事件数。\n如果问题不可行，则输出 $N = -1$ 和总通信事件数为 $-1$。\n\n单位：时间以 $\\text{hours}$ 报告。输出为整数。不涉及角度。不涉及百分比。\n\n测试套件：\n- 情况 (i) 单输入，典型情况：$M = 0.0004 \\ \\text{per} \\ \\text{hour}^{2}$，$\\varepsilon = 0.02$。\n- 情况 (ii) 单输入，边界可行情况：$M = 0.01 \\ \\text{per} \\ \\text{hour}^{2}$，$\\varepsilon = 0.045$。\n- 情况 (iii) 单输入，不可行情况：$M = 0.01 \\ \\text{per} \\ \\text{hour}^{2}$，$\\varepsilon = 0.044$。\n- 情况 (iv) 双输入，不同光滑度和容差：$M_1 = 0.0004 \\ \\text{per} \\ \\text{hour}^{2}$，$\\varepsilon_1 = 0.02$；$M_2 = 0.002 \\ \\text{per} \\ \\text{hour}^{2}$，$\\varepsilon_2 = 0.04$。\n\n您的程序应生成一行输出，其中包含测试套件的结果，格式为方括号括起来的逗号分隔列表：$[[N_1,C_1],[N_2,C_2],[N_3,C_3],[N_4,C_4]]$，其中 $N_k$ 是为情况 $k$ 选择的整数，$C_k$ 是总通信事件数。如果不可行，该对必须为 $[-1,-1]$。",
            "solution": "我们形式化能量模型（EM）和气候模型（CM）之间的耦合。EM 以时间步长 $\\Delta t_{e} = 1 \\ \\text{hour}$ 推进，并在每个 EM 步需要气候输入。CM 在其原生时间点提供气候输出，这些时间点之间相隔 $\\Delta t_{c} = 6 \\ \\text{hours}$。在一个松耦合方案（LCS）下，我们选择的通信时间间隔为 $h = N \\, \\Delta t_{c}$，其中 $N \\in \\mathbb{Z}$ 且 $N \\ge 1$，以便 EM 可以在通信点之间对气候输入进行线性插值。一年的时间范围是 $T = 8760 \\ \\text{hours}$，通信时间必须包括 $t=0$ 和 $t=T$。\n\n为确保科学真实性，我们将每个气候输入 $x(t)$ 建模为在 $[0, T]$ 上二次连续可微，且满足 $\\lvert x''(t) \\rvert \\le M$。EM 在通信点之间采用逐段线性插值。我们使用带有拉格朗日余项的泰勒定理和线性插值的标准误差分析，来推导插值误差的上界。\n\n设 $x(t)$ 为气候输入，考虑一个长度为 $h = b-a$ 的单个耦合区间 $[a,b]$。$x(t)$ 在 $a$ 和 $b$ 之间的线性插值是唯一的仿射函数 $\\ell(t)$，使得 $\\ell(a) = x(a)$ 且 $\\ell(b) = x(b)$。定义插值误差 $e(t) = x(t) - \\ell(t)$。根据经典数值分析，可以通过皮亚诺核（Peano kernel）或通过在任意点应用泰勒定理并减去插值函数，将 $e(t)$ 与二阶导数联系起来。可以得到恒等式\n$$\ne(t) = \\frac{x''(\\xi_t)}{2} \\, (t-a)(t-b),\n$$\n其中某个 $\\xi_t \\in (a,b)$ 依赖于 $t$。取绝对值并使用全局界限 $\\lvert x''(t) \\rvert \\le M$ 可得\n$$\n\\lvert e(t) \\rvert \\le \\frac{M}{2} \\, \\lvert (t-a)(t-b) \\rvert.\n$$\n函数 $\\lvert (t-a)(t-b) \\rvert$ 在中点 $t = \\frac{a+b}{2}$ 处达到其最大值，值为 $\\left(\\frac{h}{2}\\right)\\left(\\frac{h}{2}\\right) = \\frac{h^2}{4}$。因此，在该区间上的最大插值误差满足\n$$\n\\max_{t \\in [a,b]} \\lvert e(t) \\rvert \\le \\frac{M h^2}{8}.\n$$\n这个不等式是数值逼近理论中一个经过充分检验的结果，它根据区间长度 $h$ 和二阶导数界限 $M$ 提供了逐段线性插值误差的一个保守界限。\n\n为了对插值误差强制施加一个容差 $\\varepsilon$，我们要求\n$$\n\\frac{M h^2}{8} \\le \\varepsilon.\n$$\n解出 $h$ 可得最大允许区间长度\n$$\nh_{\\max} = \\sqrt{\\frac{8 \\varepsilon}{M}}.\n$$\n为了最小化通信开销，我们选择满足 CM 原生步长约束（即 $h$ 必须是 $\\Delta t_{c}$ 的整数倍，$h = N \\, \\Delta t_{c}$，其中 $N \\in \\mathbb{Z}$ 且 $N \\ge 1$）的最大可行 $h$。因此，\n$$\nN_{\\max} = \\left\\lfloor \\frac{h_{\\max}}{\\Delta t_{c}} \\right\\rfloor.\n$$\n可行性要求 $N_{\\max} \\ge 1$，这等价于 $h_{\\max} \\ge \\Delta t_{c}$。如果 $N_{\\max}  1$，则 $\\Delta t_{c}$ 的任何整数倍都不能满足误差界限，问题相对于给定的 CM 步长是不可行的。\n\n对于由索引 $i$ 标记的多个气候输入，其界限为 $M_i$，容差为 $\\varepsilon_i$，误差约束必须同时成立。因此，允许的区间受限于最严格的输入：\n$$\nh_{\\max} = \\min_{i} \\sqrt{\\frac{8 \\varepsilon_i}{M_i}},\n$$\n并且适用相同的整数倍约束：\n$$\nN_{\\max} = \\left\\lfloor \\frac{h_{\\max}}{\\Delta t_{c}} \\right\\rfloor, \\quad \\text{如果 } N_{\\max} \\ge 1 \\text{ 则可行}.\n$$\n\n一旦确定了 $N_{\\max}$，通信间隔即为 $h = N_{\\max} \\, \\Delta t_{c}$。在 $[0, T]$ 上的总通信事件数（包括两个端点）为\n$$\nC = \\left\\lceil \\frac{T}{h} \\right\\rceil + 1.\n$$\n包含 $t=T$ 确保了最后一个（可能更短的）区间 $[k h, T]$ 的两个端点都可供 EM 用于插值。如果 $N_{\\max}  1$，我们声明不可行并设置 $(N, C) = (-1, -1)$。\n\n我们现在评估测试套件：\n\n- 情况 (i)：$M = 0.0004$，$\\varepsilon = 0.02$，$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max} = \\sqrt{\\frac{8 \\cdot 0.02}{0.0004}} = \\sqrt{400} = 20$。那么 $N_{\\max} = \\left\\lfloor \\frac{20}{6} \\right\\rfloor = 3$。因此 $h = 18$，$C = \\left\\lceil \\frac{8760}{18} \\right\\rceil + 1 = 487 + 1 = 488$。\n\n- 情况 (ii)：$M = 0.01$，$\\varepsilon = 0.045$，$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max} = \\sqrt{\\frac{8 \\cdot 0.045}{0.01}} = \\sqrt{36} = 6$。那么 $N_{\\max} = \\left\\lfloor \\frac{6}{6} \\right\\rfloor = 1$。因此 $h = 6$，$C = \\left\\lceil \\frac{8760}{6} \\right\\rceil + 1 = 1460 + 1 = 1461$。\n\n- 情况 (iii)：$M = 0.01$，$\\varepsilon = 0.044$，$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max} = \\sqrt{\\frac{8 \\cdot 0.044}{0.01}} = \\sqrt{35.2} \\approx 5.93$。那么 $N_{\\max} = \\left\\lfloor \\frac{5.93}{6} \\right\\rfloor = 0$，这是不可行的。输出 $[-1, -1]$。\n\n- 情况 (iv)：两个输入，$(M_1, \\varepsilon_1) = (0.0004, 0.02)$ 和 $(M_2, \\varepsilon_2) = (0.002, 0.04)$；$\\Delta t_{c} = 6$，$T = 8760$。\n  计算 $h_{\\max,1} = \\sqrt{\\frac{8 \\cdot 0.02}{0.0004}} = \\sqrt{400} = 20$，以及 $h_{\\max,2} = \\sqrt{\\frac{8 \\cdot 0.04}{0.002}} = \\sqrt{160} \\approx 12.649$。因此 $h_{\\max} = \\min(20, 12.649) = 12.649$，所以 $N_{\\max} = \\left\\lfloor \\frac{12.649}{6} \\right\\rfloor = 2$。因此 $h = 12$，$C = \\left\\lceil \\frac{8760}{12} \\right\\rceil + 1 = 730 + 1 = 731$。\n\n算法如下：\n1) 对于每种情况，形成 $(M_i, \\varepsilon_i)$ 对的集合（对于单输入情况为单元集）。\n2) 计算 $h_{\\max,i} = \\sqrt{\\frac{8 \\varepsilon_i}{M_i}}$ 并取 $h_{\\max} = \\min_i h_{\\max,i}$。\n3) 计算 $N_{\\max} = \\left\\lfloor \\frac{h_{\\max}}{\\Delta t_{c}} \\right\\rfloor$。如果 $N_{\\max}  1$，返回 $[-1, -1]$。\n4) 否则，设置 $h = N_{\\max} \\, \\Delta t_{c}$ 和 $C = \\left\\lceil \\frac{T}{h} \\right\\rceil + 1$。\n5) 将所有情况的 $[N, C]$ 列表作为单个带括号的、逗号分隔的行输出。\n\n此过程通过选择气候步长的最大可行整数倍，同时遵守通过泰勒定理从光滑性约束中导出的插值误差界限，从而最小化了通信开销。",
            "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5, scipy 1.11.4 (not used)\nimport numpy as np\n\ndef largest_feasible_N_and_count(M_list, eps_list, dt_c_hours, T_hours):\n    \"\"\"\n    Compute the largest feasible integer N such that h = N * dt_c_hours\n    satisfies max interpolation error = epsilon for all inputs,\n    and the corresponding total number of communication events over [0, T].\n\n    Parameters:\n        M_list: list or scalar; bound(s) on |x''(t)| in units per hour^2\n        eps_list: list or scalar; tolerance(s) in same units as x\n        dt_c_hours: float; climate model native step in hours\n        T_hours: float; total horizon in hours (one year)\n\n    Returns:\n        (N_max, C) where:\n            N_max: int; largest feasible integer multiple\n            C: int; total communications including endpoints\n        If infeasible, returns (-1, -1).\n    \"\"\"\n    # Ensure arrays for uniform handling\n    Ms = np.atleast_1d(M_list).astype(float)\n    eps = np.atleast_1d(eps_list).astype(float)\n\n    # Validate lengths\n    if Ms.shape != eps.shape:\n        raise ValueError(\"M_list and eps_list must have the same shape\")\n\n    # Compute h_max for each input: sqrt(8 * eps_i / M_i)\n    # Guard against division by zero or negative values (not expected in test suite)\n    h_max_list = np.sqrt(8.0 * eps / Ms)\n\n    # Most restrictive bound across inputs\n    h_max = float(np.min(h_max_list))\n\n    # Integer multiple constraint\n    N_max = int(np.floor(h_max / dt_c_hours))\n\n    if N_max  1:\n        return (-1, -1)\n\n    h = N_max * dt_c_hours\n    C = int(np.ceil(T_hours / h)) + 1\n    return (N_max, C)\n\ndef format_nested_list(obj):\n    \"\"\"\n    Format a Python nested list of ints into a compact string without spaces,\n    e.g., [[3,488],[1,1461],[-1,-1],[2,731]]\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_nested_list(x) for x in obj) + \"]\"\n    elif isinstance(obj, (int, np.integer)):\n        return str(int(obj))\n    else:\n        # Should not occur for this problem; handle gracefully\n        return str(obj)\n\ndef solve():\n    # Constants per problem statement\n    dt_e_hours = 1.0  # energy model step; not directly used in computation\n    dt_c_hours = 6.0  # climate model step\n    T_hours = 8760.0  # one-year horizon\n\n    # Test suite: four cases\n    test_cases = [\n        # Case (i) Single-input, typical\n        {\"M\": 0.0004, \"eps\": 0.02},\n        # Case (ii) Single-input, boundary feasibility\n        {\"M\": 0.01, \"eps\": 0.045},\n        # Case (iii) Single-input, infeasible\n        {\"M\": 0.01, \"eps\": 0.044},\n        # Case (iv) Two inputs, differing smoothness and tolerances\n        {\"M\": [0.0004, 0.002], \"eps\": [0.02, 0.04]},\n    ]\n\n    results = []\n    for case in test_cases:\n        M = case[\"M\"]\n        eps = case[\"eps\"]\n        N_max, C = largest_feasible_N_and_count(M, eps, dt_c_hours, T_hours)\n        results.append([N_max, C])\n\n    print(format_nested_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}