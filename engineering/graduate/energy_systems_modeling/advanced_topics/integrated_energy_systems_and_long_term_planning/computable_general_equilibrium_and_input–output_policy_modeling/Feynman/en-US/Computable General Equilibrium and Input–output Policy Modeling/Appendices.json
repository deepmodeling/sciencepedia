{
    "hands_on_practices": [
        {
            "introduction": "To build complex models of the economy, we must first master the fundamentals of its production structure. This practice delves into the Leontief Input-Output (I-O) framework, the bedrock of many CGE models, which maps the flow of goods and services between industries. By calculating the total output required to meet a new final demand, you will learn to quantify the economic ripple effects that spread through an economy's interconnected supply chain .",
            "id": "4079489",
            "problem": "Consider a two-sector hybrid energy–economy Input–Output (IO) core used within a Computable General Equilibrium (CGE) model for energy systems policy analysis. The sectors are an energy sector and an aggregate non-energy sector. Let the gross output vector be $x \\in \\mathbb{R}^{2}$, the final demand vector be $y \\in \\mathbb{R}^{2}$, and the matrix of technical coefficients be $A \\in \\mathbb{R}^{2 \\times 2}$. The technical coefficient $a_{ij}$ denotes the input from sector $i$ required per unit of gross output of sector $j$. The model is given by the fundamental IO accounting identity that gross output equals intermediate demand plus final demand.\n\nSuppose the economy is characterized by the following technical coefficients:\n$$\nA \\;=\\; \\begin{pmatrix}\n0.25 & 0.10\\\\\n0.20 & 0.30\n\\end{pmatrix},\n$$\nwhere the first row/column refers to the energy sector and the second row/column refers to the non-energy sector. Consider a policy shock that raises final demand in the non-energy sector only, with the final demand vector\n$$\ny \\;=\\; \\begin{pmatrix} 0 \\\\ 101 \\end{pmatrix},\n$$\nmeasured in billion 2015 United States dollars.\n\nTasks:\n1. Starting solely from the IO accounting identity, derive a closed-form expression for $x$ in terms of $A$ and $y$, and state a sufficient condition under which this expression is well-defined.\n2. Compute the matrix $(I - A)^{-1}$ explicitly and use it to obtain the gross output vector $x$ implied by the given $A$ and $y$.\n3. Interpret the entries of $(I - A)^{-1}$ as total requirements multipliers, explaining what each entry means for the energy and non-energy sectors in response to one unit of final demand in each sector.\n4. What is the energy sector’s gross output $x_{\\text{energy}}$ under this policy shock? Report a single number rounded to four significant figures. Express your answer in billion 2015 United States dollars.",
            "solution": "The problem presents a standard Leontief Input-Output (IO) model for a $2$-sector economy. The problem statement has been validated and found to be scientifically grounded, well-posed, objective, complete, and consistent. The tasks will be addressed sequentially.\n\nThe fundamental IO accounting identity states that the total gross output of an economy is equal to the sum of intermediate demand and final demand. This can be expressed in matrix form as:\n$$\nx = Ax + y\n$$\nwhere $x$ is the gross output vector, $A$ is the matrix of technical coefficients, and $y$ is the final demand vector.\n\n**Task 1: Derivation of a closed-form expression for $x$ and its condition for existence.**\n\nWe begin with the IO accounting identity:\n$$\nx = Ax + y\n$$\nTo solve for the gross output vector $x$, we rearrange the equation by bringing all terms involving $x$ to one side:\n$$\nx - Ax = y\n$$\nFactoring out the vector $x$ using the properties of matrix algebra, where $I$ is the identity matrix of the same dimension as $A$:\n$$\nIx - Ax = y\n$$\n$$\n(I - A)x = y\n$$\nThe matrix $(I - A)$ is known as the Leontief matrix. To isolate $x$, we can pre-multiply both sides by the inverse of the Leontief matrix, $(I - A)^{-1}$, provided that this inverse exists.\n$$\n(I - A)^{-1}(I - A)x = (I - A)^{-1}y\n$$\nThis simplifies to the closed-form expression for the gross output vector:\n$$\nx = (I - A)^{-1}y\n$$\nA sufficient condition for this expression to be well-defined and for a unique solution for $x$ to exist is that the Leontief matrix $(I - A)$ must be non-singular, which means it must be invertible. This is equivalent to the condition that its determinant is non-zero:\n$$\n\\det(I - A) \\neq 0\n$$\nIn the context of IO analysis, for the solution to be economically meaningful (i.e., non-negative output for any non-negative final demand), the Hawkins-Simon condition must be satisfied. This condition requires that all principal minors of the matrix $(I-A)$ are positive. For a $2 \\times 2$ matrix, this implies that the diagonal elements of $(I-A)$ must be positive and its determinant must be positive.\n\n**Task 2: Computation of $(I - A)^{-1}$ and the gross output vector $x$.**\n\nGiven the matrix of technical coefficients:\n$$\nA = \\begin{pmatrix} 0.25 & 0.10 \\\\ 0.20 & 0.30 \\end{pmatrix}\n$$\nFirst, we compute the Leontief matrix, $(I - A)$:\n$$\nI - A = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 0.25 & 0.10 \\\\ 0.20 & 0.30 \\end{pmatrix} = \\begin{pmatrix} 1-0.25 & -0.10 \\\\ -0.20 & 1-0.30 \\end{pmatrix} = \\begin{pmatrix} 0.75 & -0.10 \\\\ -0.20 & 0.70 \\end{pmatrix}\n$$\nNext, we compute the determinant of $(I - A)$:\n$$\n\\det(I - A) = (0.75)(0.70) - (-0.10)(-0.20) = 0.525 - 0.02 = 0.505\n$$\nSince $\\det(I - A) = 0.505 \\neq 0$, the matrix is invertible. The inverse of a general $2 \\times 2$ matrix $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ is $\\frac{1}{ad-bc} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}$. Applying this formula:\n$$\n(I - A)^{-1} = \\frac{1}{0.505} \\begin{pmatrix} 0.70 & 0.10 \\\\ 0.20 & 0.75 \\end{pmatrix}\n$$\nTo express this with exact fractions, we note that $0.505 = \\frac{505}{1000} = \\frac{101}{200}$. Thus, $\\frac{1}{0.505} = \\frac{200}{101}$.\n$$\n(I - A)^{-1} = \\frac{200}{101} \\begin{pmatrix} 0.70 & 0.10 \\\\ 0.20 & 0.75 \\end{pmatrix} = \\begin{pmatrix} \\frac{200 \\times 0.70}{101} & \\frac{200 \\times 0.10}{101} \\\\ \\frac{200 \\times 0.20}{101} & \\frac{200 \\times 0.75}{101} \\end{pmatrix} = \\begin{pmatrix} \\frac{140}{101} & \\frac{20}{101} \\\\ \\frac{40}{101} & \\frac{150}{101} \\end{pmatrix}\n$$\nNow, we compute the gross output vector $x$ using the given final demand vector $y = \\begin{pmatrix} 0 \\\\ 101 \\end{pmatrix}$:\n$$\nx = (I - A)^{-1}y = \\begin{pmatrix} \\frac{140}{101} & \\frac{20}{101} \\\\ \\frac{40}{101} & \\frac{150}{101} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 101 \\end{pmatrix}\n$$\n$$\nx = \\begin{pmatrix} (\\frac{140}{101})(0) + (\\frac{20}{101})(101) \\\\ (\\frac{40}{101})(0) + (\\frac{150}{101})(101) \\end{pmatrix} = \\begin{pmatrix} 0 + 20 \\\\ 0 + 150 \\end{pmatrix} = \\begin{pmatrix} 20 \\\\ 150 \\end{pmatrix}\n$$\nThus, the gross output vector is $x = \\begin{pmatrix} 20 \\\\ 150 \\end{pmatrix}$.\n\n**Task 3: Interpretation of the entries of $(I - A)^{-1}$.**\n\nThe matrix $(I - A)^{-1}$, known as the Leontief inverse or the total requirements matrix, quantifies the total output required from each sector to deliver one unit of output to final demand. Let $L^{-1} = (I - A)^{-1}$. The entry $L^{-1}_{ij}$ represents the total gross output from sector $i$ required, both directly and indirectly, to satisfy one unit of final demand for the products of sector $j$.\n\nThe computed total requirements matrix is:\n$$\n(I - A)^{-1} = \\begin{pmatrix} \\frac{140}{101} & \\frac{20}{101} \\\\ \\frac{40}{101} & \\frac{150}{101} \\end{pmatrix} \\approx \\begin{pmatrix} 1.3861 & 0.1980 \\\\ 0.3960 & 1.4851 \\end{pmatrix}\n$$\nThe interpretation of each entry is as follows:\n- $L^{-1}_{11} \\approx 1.3861$: To deliver one unit (e.g., $1$ billion dollars) of output from the energy sector to final demand, a total of approximately $1.3861$ units of gross output are required from the energy sector itself. This includes the one unit for final demand plus the $0.3861$ units required as intermediate inputs throughout the production chain.\n- $L^{-1}_{12} \\approx 0.1980$: To deliver one unit of output from the non-energy sector to final demand, a total of approximately $0.1980$ units of gross output are required from the energy sector as an indirect input. This reflects the energy intensity of the non-energy sector.\n- $L^{-1}_{21} \\approx 0.3960$: To deliver one unit of output from the energy sector to final demand, a total of approximately $0.3960$ units of gross output are required from the non-energy sector as indirect inputs.\n- $L^{-1}_{22} \\approx 1.4851$: To deliver one unit of output from the non-energy sector to final demand, a total of approximately $1.4851$ units of gross output are required from the non-energy sector itself.\n\nThese are multipliers that capture the full ripple effect of a change in final demand throughout the economy.\n\n**Task 4: Energy sector's gross output $x_{\\text{energy}}$.**\n\nThe energy sector is designated as the first sector. Therefore, its gross output is the first component of the vector $x$, denoted as $x_{\\text{energy}}$ or $x_1$. From the calculation in Task 2:\n$$\nx = \\begin{pmatrix} x_{\\text{energy}} \\\\ x_{\\text{non-energy}} \\end{pmatrix} = \\begin{pmatrix} 20 \\\\ 150 \\end{pmatrix}\n$$\nSo, the energy sector's gross output is exactly $20$.\nThe units are specified as billion 2015 United States dollars. Therefore, $x_{\\text{energy}} = 20$ billion 2015 United States dollars.\nThe problem requires the answer to be reported as a single number rounded to four significant figures. The exact value is $20$. To express this with four significant figures, we write it as $20.00$.",
            "answer": "$$\\boxed{20.00}$$"
        },
        {
            "introduction": "An economic model's predictions depend critically on its underlying assumptions about how the broader economy adjusts to shocks. This practice introduces the crucial concept of 'macroeconomic closures' within a price-side I-O model, exploring how a carbon tax's burden is distributed across households and factors of production under different scenarios. By comparing outcomes, you will gain a deeper understanding of how model specification drives policy incidence analysis .",
            "id": "4079455",
            "problem": "You are asked to implement and solve a small, price-side Computable General Equilibrium (CGE) model for energy systems using the Input–Output price model to trace the incidence of a carbon tax under alternative macroeconomic closures. Your task is to compute the adjustments in real wages, real capital returns, and real consumption for a representative household when a per-unit carbon tax is applied to the energy sector, under three distinct closures.\n\nThe model has two production sectors: energy and non-energy. Let there be an Input–Output technical coefficient matrix $A \\in \\mathbb{R}^{2 \\times 2}$ with sectors ordered as energy (index $E$) and non-energy (index $N$). The price-side Leontief system is built on the fundamental Input–Output identity that equates unit prices to the sum of value-added and intermediate input costs. The following fundamental definitions and identities apply:\n\n- The Input–Output price identity is $p = v + A^{\\top} p$, where $p \\in \\mathbb{R}^{2}$ is the sectoral price vector and $v \\in \\mathbb{R}^{2}$ is the value-added plus tax component vector. Solving for prices gives the Leontief inverse form $p = (I - A^{\\top})^{-1} v$, where $I$ is the identity matrix.\n- The value-added in sector $i \\in \\{E,N\\}$ is a linear combination of factor payments and policy taxes:\n  $$v_i = s^L_i \\, w + s^K_i \\, r + \\tau_i,$$\n  where $s^L_i$ and $s^K_i$ are direct factor input coefficients for labor and capital in sector $i$, $w$ is the nominal wage rate, $r$ is the nominal capital return rate, and $\\tau_i$ is the per-unit tax applied to sector $i$ (only the energy sector has a carbon tax).\n- The household forms a consumption price index (Consumer Price Index (CPI)) as a Cobb–Douglas price aggregator:\n  $$\\mathrm{CPI}(p) = \\beta_E \\, p_E + \\beta_N \\, p_N,$$\n  with budget shares $\\beta_E$ and $\\beta_N$ satisfying $\\beta_E + \\beta_N = 1$.\n- The representative household has fixed endowments of labor and capital, denoted $L$ and $K$, with nominal income\n  $$Y = w \\, L + r \\, K.$$\n- Under Cobb–Douglas preferences, the household’s consumption of sector $i$ is\n  $$c_i = \\frac{\\beta_i \\, Y}{p_i},$$\n  and a real consumption index proportional to the utility aggregator can be measured by $Y/\\mathrm{CPI}$.\n\nThe energy sector is subject to a per-unit carbon tax given by\n$$\\tau_E = t \\cdot m_E,$$\nwhere $t$ is the carbon tax rate expressed in currency units per unit of emissions and $m_E$ is the emissions intensity per unit of energy output. The non-energy sector has no carbon tax, so $\\tau_N = 0$.\n\nYou must analyze how different closures alter the incidence of the carbon tax by solving for $(w,r)$ under each closure, computing prices, and then measuring changes in real wages $w/\\mathrm{CPI}$, real capital returns $r/\\mathrm{CPI}$, and real consumption $Y/\\mathrm{CPI}$ relative to a baseline without the carbon tax. Each closure imposes a second macroeconomic condition that pins down $(w,r)$ together with the choice of numeraire. The numeraire condition is set by fixing the non-energy sector price to unity:\n$$p_N(w,r,\\tau) = 1,$$\nfor all scenarios, where $p_N$ is the non-energy price arising from the Leontief price system.\n\nThe closures to be examined are:\n- Closure A (Nominal income fixed): Keep household nominal income at the baseline value, that is $Y = Y_0$, where $Y_0$ is the baseline nominal income computed under zero carbon tax using $p_N(w_0,r_0,\\tau=0)=1$ and an anchor $w_0=1$.\n- Closure B (Real wage fixed): Keep the real wage constant, that is\n  $$\\frac{w}{\\mathrm{CPI}(p)} = 1,$$\n  with baseline values $(w_0,r_0)$ computed under zero carbon tax by solving $p_N(w_0,r_0,\\tau=0)=1$ and $w_0/\\mathrm{CPI}(p(w_0,r_0,0))=1$.\n- Closure C (Real capital return fixed): Keep the real capital return constant, that is\n  $$\\frac{r}{\\mathrm{CPI}(p)} = 1,$$\n  with baseline values $(w_0,r_0)$ computed under zero carbon tax by solving $p_N(w_0,r_0,\\tau=0)=1$ and $r_0/\\mathrm{CPI}(p(w_0,r_0,0))=1$.\n\nYou are given the following parameters and data:\n- Technical coefficients:\n  $$A = \\begin{bmatrix}\n  0.1 & 0.2 \\\\\n  0.05 & 0.15\n  \\end{bmatrix},$$\n  meaning $a_{EE}=0.1$, $a_{EN}=0.2$, $a_{NE}=0.05$, $a_{NN}=0.15$.\n- Direct factor input coefficients:\n  $s^L_E = 0.425, \\quad s^K_E = 0.425, \\quad s^L_N = 0.39, \\quad s^K_N = 0.26,$\n  which are consistent with $1 - (a_{EE} + a_{NE}) = 0.85$ and $1 - (a_{EN} + a_{NN}) = 0.65$ for energy and non-energy value-added respectively.\n- Emissions intensity:\n  $$m_E = 0.6.$$\n- Household budget shares:\n  $$\\beta_E = 0.3, \\quad \\beta_N = 0.7.$$\n- Factor endowments:\n  $$L = 1.2, \\quad K = 0.8.$$\n\nYour program must:\n1. Implement the price mapping $p(w,r,\\tau)$ using the Leontief inverse, with $\\tau = (\\tau_E, \\tau_N)$ and $\\tau_E = t \\cdot m_E$, $\\tau_N = 0$.\n2. For each closure, compute the baseline $(w_0,r_0)$ under zero tax $\\tau=(0,0)$ using the closure’s defining equations and $p_N(w_0,r_0,0)=1$. For Closure A, use the anchor $w_0=1$ and determine $r_0$ from $p_N=1$; then compute $Y_0 = w_0 L + r_0 K$.\n3. For each test case, apply the carbon tax with rate $t$ and solve for $(w,r)$ under the specified closure and $p_N(w,r,\\tau)=1$.\n4. Compute the post-tax prices $p$, the Consumer Price Index $\\mathrm{CPI}$, nominal income $Y = w L + r K$, and the changes relative to baseline:\n   - Real wage change: $\\Delta W = (w/\\mathrm{CPI}) - (w_0/\\mathrm{CPI}_0)$.\n   - Real capital return change: $\\Delta R = (r/\\mathrm{CPI}) - (r_0/\\mathrm{CPI}_0)$.\n   - Real consumption change: $\\Delta C = (Y/\\mathrm{CPI}) - (Y_0/\\mathrm{CPI}_0)$.\n   All changes are to be reported as decimals.\n\nMonetary units are abstract; report all results as unitless decimals. Each output float must be rounded to six decimal places.\n\nTest Suite:\nProvide outputs for the following four test cases, each represented as a tuple $(t, \\text{closure})$:\n- Test $1$: $t = 0.3$, closure $A$.\n- Test $2$: $t = 0.3$, closure $B$.\n- Test $3$: $t = 0.0$, closure $C$.\n- Test $4$: $t = 1.0$, closure $C$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of three floats in the order $[\\Delta W, \\Delta R, \\Delta C]$. For example:\n$$\\text{output: } [[\\Delta W_1,\\Delta R_1,\\Delta C_1],[\\Delta W_2,\\Delta R_2,\\Delta C_2],[\\Delta W_3,\\Delta R_3,\\Delta C_3],[\\Delta W_4,\\Delta R_4,\\Delta C_4]].$$",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of Input-Output analysis and Computable General Equilibrium (CGE) modeling, is well-posed with sufficient information to derive a unique solution, and is free of contradictions or ambiguities.\n\nThe problem requires the analysis of a carbon tax's incidence within a two-sector (Energy E, Non-energy N) CGE model. The core of the model is the Leontief price equation, which links sectoral prices to the costs of intermediate inputs and primary factors (value-added). We will solve for changes in real wages, real capital returns, and real consumption under three different macroeconomic closure rules.\n\nThe provided parameters are:\n- Input-Output technical coefficient matrix:\n$$A = \\begin{bmatrix} 0.1 & 0.2 \\\\ 0.05 & 0.15 \\end{bmatrix}$$\n- Direct factor input coefficients for labor ($s^L_i$) and capital ($s^K_i$):\n$$s^L_E = 0.425, \\quad s^K_E = 0.425$$\n$$s^L_N = 0.39, \\quad s^K_N = 0.26$$\n- Emissions intensity of the energy sector: $m_E = 0.6$.\n- Household consumption budget shares: $\\beta_E = 0.3$, $\\beta_N = 0.7$.\n- Factor endowments: Labor $L = 1.2$, Capital $K = 0.8$.\n\nThe fundamental price identity is $p = v + A^{\\top} p$, where $p = \\begin{pmatrix} p_E \\\\ p_N \\end{pmatrix}$ is the price vector and $v = \\begin{pmatrix} v_E \\\\ v_N \\end{pmatrix}$ is the vector of value-added per unit of output. This can be solved for $p$ as:\n$$p = (I - A^{\\top})^{-1} v$$\nLet $B = (I - A^{\\top})^{-1}$ be the Leontief inverse matrix for prices.\nFirst, we compute $I - A^{\\top}$:\n$$I - A^{\\top} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} 0.1 & 0.05 \\\\ 0.2 & 0.15 \\end{bmatrix} = \\begin{bmatrix} 0.9 & -0.05 \\\\ -0.2 & 0.85 \\end{bmatrix}$$\nThe determinant is $\\det(I - A^{\\top}) = (0.9)(0.85) - (-0.05)(-0.2) = 0.765 - 0.01 = 0.755$.\nThe inverse matrix $B$ is:\n$$B = (I - A^{\\top})^{-1} = \\frac{1}{0.755} \\begin{bmatrix} 0.85 & 0.05 \\\\ 0.2 & 0.9 \\end{bmatrix} \\approx \\begin{bmatrix} 1.1258278 & 0.0662252 \\\\ 0.2649007 & 1.1920530 \\end{bmatrix}$$\n\nThe value-added per unit of output in each sector, $v_i$, is the sum of factor payments and taxes:\n$$v_i = s^L_i \\, w + s^K_i \\, r + \\tau_i$$\nwhere $w$ is the nominal wage, $r$ is the nominal return to capital, and $\\tau_i$ is the per-unit tax. The carbon tax applies only to the energy sector, so $\\tau_E = t \\cdot m_E$ and $\\tau_N = 0$.\nThe value-added vector is:\n$$v = \\begin{pmatrix} v_E \\\\ v_N \\end{pmatrix} = \\begin{pmatrix} s^L_E w + s^K_E r + t \\cdot m_E \\\\ s^L_N w + s^K_N r \\end{pmatrix}$$\n\nSectoral prices are linear functions of $w$, $r$, and $t$:\n$$p_E = B_{11} v_E + B_{12} v_N = (B_{11}s^L_E + B_{12}s^L_N)w + (B_{11}s^K_E + B_{12}s^K_N)r + (B_{11}m_E)t$$\n$$p_N = B_{21} v_E + B_{22} v_N = (B_{21}s^L_E + B_{22}s^L_N)w + (B_{21}s^K_E + B_{22}s^K_N)r + (B_{21}m_E)t$$\n\nLet's define coefficients for these linear forms:\n$C_{Ew} = B_{11}s^L_E + B_{12}s^L_N \\approx 0.504305$\n$C_{Er} = B_{11}s^K_E + B_{12}s^K_N \\approx 0.495695$\n$C_{Et} = B_{11}m_E \\approx 0.675497$\n$C_{Nw} = B_{21}s^L_E + B_{22}s^L_N \\approx 0.577483$\n$C_{Nr} = B_{21}s^K_E + B_{22}s^K_N \\approx 0.422517$\n$C_{Nt} = B_{21}m_E \\approx 0.158940$\n\nSo the price equations are:\n$p_E(w,r,t) = C_{Ew} w + C_{Er} r + C_{Et} t$\n$p_N(w,r,t) = C_{Nw} w + C_{Nr} r + C_{Nt} t$\n\nIn all scenarios, the price of the non-energy good is fixed as the numeraire: $p_N=1$. This gives our first equation for solving for $(w,r)$:\n$$C_{Nw} w + C_{Nr} r = 1 - C_{Nt} t \\quad (\\text{Equation 1})$$\nA second equation is provided by the macroeconomic closure rule. For each test case, we first compute a baseline state (with tax rate $t=0$) and then a policy state (with the given $t$).\n\nOther key variables are the Consumer Price Index $\\mathrm{CPI} = \\beta_E p_E + \\beta_N p_N$ and nominal income $Y = wL + rK$.\n\nWe now solve the system for each closure specified in the test cases.\n\n**Closure A: Fixed Nominal Income**\nThe nominal income $Y$ is held constant at its baseline value $Y_0$.\n- **Baseline ($t=0$):** We anchor the system with $w_0=1$.\n  Eq. 1 becomes $C_{Nw}(1) + C_{Nr}r_0 = 1$, giving $r_0 = (1 - C_{Nw})/C_{Nr} \\approx 0.996875$.\n  Baseline nominal income is $Y_0 = w_0 L + r_0 K = (1)(1.2) + (0.996875)(0.8) = 1.9975$.\n_Baseline values_: $w_0=1$, $r_0=0.996875$. This yields prices $p_{E0} \\approx 0.998447$, $p_{N0}=1$, and $\\mathrm{CPI}_0 = 0.3 p_{E0} + 0.7 p_{N0} \\approx 0.999534$. Real values are $w_0/\\mathrm{CPI}_0 \\approx 1.000466$, $r_0/\\mathrm{CPI}_0 \\approx 0.997340$, $Y_0/\\mathrm{CPI}_0 \\approx 1.998427$.\n- **Policy ($t=0.3$):** The closure condition is $wL+rK=Y_0=1.9975$. We solve the $2 \\times 2$ linear system:\n  $$C_{Nw} w + C_{Nr} r = 1 - C_{Nt} (0.3)$$\n  $$1.2 w + 0.8 r = 1.9975$$\n  Solving this system yields $w \\approx 0.952932$, $r \\approx 1.006900$.\n_Policy values_: Prices are $p_E \\approx 1.185203$, $p_N=1$. $\\mathrm{CPI} \\approx 1.055561$. Real values are $w/\\mathrm{CPI} \\approx 0.902778$, $r/\\mathrm{CPI} \\approx 0.953905$, $Y/\\mathrm{CPI} \\approx 1.892361$.\n- **Changes for Test 1 ($t=0.3$, Closure A):**\n  $\\Delta W = 0.902778 - 1.000466 = -0.097688$\n  $\\Delta R = 0.953905 - 0.997340 = -0.043435$\n  $\\Delta C = 1.892361 - 1.998427 = -0.106066$\n\n**Closure B: Fixed Real Wage**\nThe real wage is held constant, $w/\\mathrm{CPI} = 1$. This implies $w = \\mathrm{CPI} = \\beta_E p_E + \\beta_N p_N$. Since $p_N=1$, we have $w = \\beta_E p_E + \\beta_N$.\nSubstituting the expression for $p_E$ gives our second equation:\n$$(1 - \\beta_E C_{Ew})w - (\\beta_E C_{Er})r = \\beta_N + \\beta_E C_{Et}t \\quad (\\text{Equation 2B})$$\n- **Baseline ($t=0$):** We solve the system of Eq. 1 and Eq. 2B with $t=0$:\n  $$C_{Nw} w_0 + C_{Nr} r_0 = 1$$\n  $$(1 - \\beta_E C_{Ew})w_0 - (\\beta_E C_{Er})r_0 = \\beta_N$$\n  Solving yields $w_0 \\approx 0.999534$, $r_0 \\approx 0.996410$.\n_Baseline values_: $w_0/\\mathrm{CPI}_0 = 1$ by construction. $r_0/\\mathrm{CPI}_0 \\approx 0.996875$. $Y_0 \\approx 1.996551$, $Y_0/\\mathrm{CPI}_0 \\approx 1.997495$.\n- **Policy ($t=0.3$):** We solve the same system with $t=0.3$:\n  $$C_{Nw} w + C_{Nr} r = 1 - C_{Nt} (0.3)$$\n  $$(1 - \\beta_E C_{Ew})w - (\\beta_E C_{Er})r = \\beta_N + \\beta_E C_{Et}(0.3)$$\n  Solving yields $w \\approx 1.055561$, $r \\approx 0.811802$.\n_Policy values_: $w/\\mathrm{CPI}=1$ by construction. $r/\\mathrm{CPI} \\approx 0.769116$. $Y/\\mathrm{CPI} \\approx 1.815220$.\n- **Changes for Test 2 ($t=0.3$, Closure B):**\n  $\\Delta W = 1 - 1 = 0.0$\n  $\\Delta R = 0.769116 - 0.996875 = -0.227759$\n  $\\Delta C = 1.815220 - 1.997495 = -0.182275$\n\n**Closure C: Fixed Real Capital Return**\nThe real capital return is held constant, $r/\\mathrm{CPI} = 1$. This implies $r = \\mathrm{CPI} = \\beta_E p_E + \\beta_N$. This gives our second equation:\n$$-(\\beta_E C_{Ew})w + (1 - \\beta_E C_{Er})r = \\beta_N + \\beta_E C_{Et}t \\quad (\\text{Equation 2C})$$\n- **Baseline ($t=0$):** We solve the system of Eq. 1 and Eq. 2C with $t=0$:\n  $$C_{Nw} w_0 + C_{Nr} r_0 = 1$$\n  $$-(\\beta_E C_{Ew})w_0 + (1 - \\beta_E C_{Er})r_0 = \\beta_N$$\n  Solving yields $w_0 \\approx 1.003135$, $r_0 \\approx 1.000466$.\n_Baseline values_: $r_0/\\mathrm{CPI}_0 = 1$ by construction. $w_0/\\mathrm{CPI}_0 \\approx 1.002668$. $Y_0 \\approx 2.004130$, $Y_0/\\mathrm{CPI}_0 \\approx 2.003227$.\n- **Policy ($t=0$ for Test 3):** Since $t=0$, the policy scenario is identical to the baseline.\n_Policy values_: Same as baseline.\n- **Changes for Test 3 ($t=0.0$, Closure C):**\n  $\\Delta W = (w_0/\\mathrm{CPI}_0) - (w_0/\\mathrm{CPI}_0) = 0.0$\n  $\\Delta R = (r_0/\\mathrm{CPI}_0) - (r_0/\\mathrm{CPI}_0) = 0.0$\n  $\\Delta C = (Y_0/\\mathrm{CPI}_0) - (Y_0/\\mathrm{CPI}_0) = 0.0$\n\n- **Policy ($t=1.0$ for Test 4):** We solve the same system with $t=1.0$:\n  $$C_{Nw} w + C_{Nr} r = 1 - C_{Nt} (1.0)$$\n  $$-(\\beta_E C_{Ew})w + (1 - \\beta_E C_{Er})r = \\beta_N + \\beta_E C_{Et}(1.0)$$\n  Solving yields $w \\approx 0.697071$, $r \\approx 0.985957$.\n_Policy values_: $r/\\mathrm{CPI} = 1$ by construction. $w/\\mathrm{CPI} \\approx 0.707107$. $Y/\\mathrm{CPI} \\approx 1.666667$.\n- **Changes for Test 4 ($t=1.0$, Closure C):**\n  $\\Delta W = 0.707107 - 1.002668 = -0.295561$\n  $\\Delta R = 1 - 1 = 0.0$\n  $\\Delta C = 1.666667 - 2.003227 = -0.336560$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a price-side CGE model to analyze a carbon tax under different closures.\n    \"\"\"\n\n    # --- Model Parameters ---\n    # Input-Output technical coefficient matrix\n    A = np.array([\n        [0.1, 0.2],\n        [0.05, 0.15]\n    ])\n    # Direct factor input coefficients [Labor, Capital]\n    s_factors = {\n        'E': np.array([0.425, 0.425]),  # sL_E, sK_E\n        'N': np.array([0.39, 0.26])     # sL_N, sK_N\n    }\n    # Emissions intensity for the energy sector\n    m_E = 0.6\n    # Household budget shares [Energy, Non-energy]\n    beta = np.array([0.3, 0.7])\n    # Factor endowments [Labor, Capital]\n    endowments = np.array([1.2, 0.8])  # L, K\n\n    # --- Pre-computation ---\n    # Leontief price inverse matrix B = (I - A^T)^-1\n    I = np.identity(2)\n    B = np.linalg.inv(I - A.T)\n\n    # Coefficients for linear price equations p(w, r, t)\n    # p_i = C_iw * w + C_ir * r + C_it * t\n    sL = np.array([s_factors['E'][0], s_factors['N'][0]])\n    sK = np.array([s_factors['E'][1], s_factors['N'][1]])\n    \n    C_w = B @ sL  # [C_Ew, C_Nw]\n    C_r = B @ sK  # [C_Er, C_Nr]\n    C_t = B @ np.array([m_E, 0]) # [C_Et, C_Nt]\n\n    class CGESimulator:\n        def __init__(self, Cw, Cr, Ct, beta, endowments):\n            self.Cw = Cw\n            self.Cr = Cr\n            self.Ct = Ct\n            self.beta = beta\n            self.L, self.K = endowments\n            \n            # Unpack coefficients for clarity\n            self.C_Ew, self.C_Nw = Cw\n            self.C_Er, self.C_Nr = Cr\n            self.C_Et, self.C_Nt = Ct\n            self.beta_E, self.beta_N = beta\n\n        def _get_outputs(self, w, r, t):\n            p_E = self.C_Ew * w + self.C_Er * r + self.C_Et * t\n            p_N = 1.0 # By numeraire\n            cpi = self.beta_E * p_E + self.beta_N * p_N\n            y = w * self.L + r * self.K\n            \n            real_w = w / cpi\n            real_r = r / cpi\n            real_c = y / cpi\n            return real_w, real_r, real_c\n\n        def run_case(self, t, closure):\n            # 1. Calculate Baseline (t=0)\n            if closure == 'A':\n                w0 = 1.0\n                r0 = (1.0 - self.C_Nw * w0) / self.C_Nr\n                Y0 = w0 * self.L + r0 * self.K\n            elif closure == 'B':\n                M0 = np.array([\n                    [self.C_Nw, self.C_Nr],\n                    [1 - self.beta_E * self.C_Ew, -self.beta_E * self.C_Er]\n                ])\n                b0 = np.array([1.0, self.beta_N])\n                w0, r0 = np.linalg.solve(M0, b0)\n            elif closure == 'C':\n                M0 = np.array([\n                    [self.C_Nw, self.C_Nr],\n                    [-self.beta_E * self.C_Ew, 1 - self.beta_E * self.C_Er]\n                ])\n                b0 = np.array([1.0, self.beta_N])\n                w0, r0 = np.linalg.solve(M0, b0)\n            \n            rw0, rr0, rc0 = self._get_outputs(w0, r0, 0.0)\n\n            # 2. Calculate Policy Scenario\n            if closure == 'A':\n                M = np.array([\n                    [self.C_Nw, self.C_Nr],\n                    [self.L, self.K]\n                ])\n                b = np.array([1.0 - self.C_Nt * t, Y0])\n                w, r = np.linalg.solve(M, b)\n            elif closure == 'B':\n                M = np.array([\n                    [self.C_Nw, self.C_Nr],\n                    [1 - self.beta_E * self.C_Ew, -self.beta_E * self.C_Er]\n                ])\n                b = np.array([1.0 - self.C_Nt * t, self.beta_N + self.beta_E * self.C_Et * t])\n                w, r = np.linalg.solve(M, b)\n            elif closure == 'C':\n                M = np.array([\n                    [self.C_Nw, self.C_Nr],\n                    [-self.beta_E * self.C_Ew, 1 - self.beta_E * self.C_Er]\n                ])\n                b = np.array([1.0 - self.C_Nt * t, self.beta_N + self.beta_E * self.C_Et * t])\n                w, r = np.linalg.solve(M, b)\n\n            rw, rr, rc = self._get_outputs(w, r, t)\n\n            # 3. Calculate and return changes\n            delta_W = rw - rw0\n            delta_R = rr - rr0\n            delta_C = rc - rc0\n            return [round(delta_W, 6), round(delta_R, 6), round(delta_C, 6)]\n\n    # --- Test Suite Execution ---\n    simulator = CGESimulator(C_w, C_r, C_t, beta, endowments)\n    \n    test_cases = [\n        (0.3, 'A'),  # Test 1\n        (0.3, 'B'),  # Test 2\n        (0.0, 'C'),  # Test 3\n        (1.0, 'C'),  # Test 4\n    ]\n\n    all_results = []\n    for t, closure in test_cases:\n        result = simulator.run_case(t, closure)\n        all_results.append(result)\n\n    # Format the final output string\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final challenge integrates the supply and demand sides of the economy into a complete, non-linear Computable General Equilibrium (CGE) model. This exercise moves beyond the linear I-O framework to incorporate micro-foundations of producer and consumer behavior using Constant Elasticity of Substitution (CES) and Cobb-Douglas functions. By building and solving this model numerically, you will experience firsthand how equilibrium prices and quantities adjust simultaneously to satisfy all market-clearing, zero-profit, and income-balance conditions in a closed economic system .",
            "id": "4079532",
            "problem": "Consider a closed, static, two-sector energy-economy with a representative household, two primary factors, and ad valorem taxes. Sector $\\mathsf{E}$ produces the energy good, and sector $\\mathsf{M}$ produces the manufacturing good. There are two primary factors: labor $\\mathsf{L}$ and capital $\\mathsf{K}$ with fixed aggregate endowments $\\bar{L}$ and $\\bar{K}$. The representative household supplies $\\bar{L}$ and $\\bar{K}$ inelastically, receives all tax revenue as a lump-sum transfer, and has Cobb–Douglas preferences over final consumption.\n\nTechnologies are constant returns to scale and described by Constant Elasticity of Substitution (CES) value-added production functions. For each sector $i \\in \\{\\mathsf{E}, \\mathsf{M}\\}$, the production function is\n$$\ny_i = A_i \\left[a_i L_i^{\\frac{\\sigma_i - 1}{\\sigma_i}} + (1 - a_i) K_i^{\\frac{\\sigma_i - 1}{\\sigma_i}}\\right]^{\\frac{\\sigma_i}{\\sigma_i - 1}},\n$$\nwhere $A_i > 0$ is a productivity parameter, $a_i \\in (0,1)$ is the labor share parameter, and $\\sigma_i > 0$ is the elasticity of substitution. The dual unit cost function under competitive factor pricing with wage $w$ and rental rate $r$ is, for $\\sigma_i \\neq 1$,\n$$\nc_i(w,r) = \\frac{1}{A_i}\\left[a_i w^{1 - \\sigma_i} + (1 - a_i) r^{1 - \\sigma_i}\\right]^{\\frac{1}{1 - \\sigma_i}}.\n$$\nIn the Cobb–Douglas limit $\\sigma_i = 1$, the unit cost function is\n$$\nc_i(w,r) = \\frac{1}{A_i} w^{a_i} r^{1 - a_i}.\n$$\n\nTaxes are ad valorem. There is a consumption tax on energy at rate $\\tau_{\\mathsf{cE}} \\ge 0$ and an output tax on manufacturing at rate $\\tau_{\\mathsf{oM}} \\ge 0$. All tax rates must be expressed as decimal fractions (for example, a $10\\%$ tax is entered as $0.10$).\n\nLet $p_{\\mathsf{E}}$ denote the consumer price of energy and $p_{\\mathsf{M}}$ the consumer price of manufacturing. Normalize $p_{\\mathsf{M}} = 1$. Producers in energy receive the net-of-consumption-tax price $p_{\\mathsf{E}}^{p} = \\frac{p_{\\mathsf{E}}}{1 + \\tau_{\\mathsf{cE}}}$, and producers in manufacturing receive the net-of-output-tax price $p_{\\mathsf{M}}^{p} = \\frac{1}{1 + \\tau_{\\mathsf{oM}}}$. Under perfect competition and constant returns to scale, zero-profit conditions require\n$$\nc_{\\mathsf{E}}(w,r) = \\frac{p_{\\mathsf{E}}}{1 + \\tau_{\\mathsf{cE}}}, \\quad c_{\\mathsf{M}}(w,r) = \\frac{1}{1 + \\tau_{\\mathsf{oM}}}.\n$$\n\nBy Shephard’s lemma, the input demands per unit of output for sector $i$ are given by $L_{i}^{\\text{unit}} = \\frac{\\partial c_i}{\\partial w}$ and $K_{i}^{\\text{unit}} = \\frac{\\partial c_i}{\\partial r}$. For $\\sigma_i \\neq 1$, these are\n$$\nL_{i}^{\\text{unit}}(w,r) = \\frac{1}{A_i} a_i \\left[a_i w^{1 - \\sigma_i} + (1 - a_i) r^{1 - \\sigma_i}\\right]^{\\frac{\\sigma_i}{1 - \\sigma_i}} w^{-\\sigma_i},\n$$\n$$\nK_{i}^{\\text{unit}}(w,r) = \\frac{1}{A_i} (1 - a_i) \\left[a_i w^{1 - \\sigma_i} + (1 - a_i) r^{1 - \\sigma_i}\\right]^{\\frac{\\sigma_i}{1 - \\sigma_i}} r^{-\\sigma_i}.\n$$\nIn the Cobb–Douglas limit $\\sigma_i = 1$, the unit input demands are\n$$\nL_{i}^{\\text{unit}}(w,r) = \\frac{a_i}{A_i} \\frac{w^{a_i} r^{1 - a_i}}{w}, \\quad K_{i}^{\\text{unit}}(w,r) = \\frac{1 - a_i}{A_i} \\frac{w^{a_i} r^{1 - a_i}}{r}.\n$$\n\nThe representative household has Cobb–Douglas utility $U(c_{\\mathsf{E}}, c_{\\mathsf{M}}) = c_{\\mathsf{E}}^{\\beta} c_{\\mathsf{M}}^{1 - \\beta}$ for $\\beta \\in (0,1)$ and faces consumer prices $p_{\\mathsf{E}}$ and $p_{\\mathsf{M}} = 1$, choosing expenditures that are constant shares of income $Y$:\n$$\np_{\\mathsf{E}} c_{\\mathsf{E}} = \\beta Y, \\quad c_{\\mathsf{M}} = (1 - \\beta) Y.\n$$\nTotal income is factor income plus tax revenue rebated lump-sum:\n$$\nY = w \\bar{L} + r \\bar{K} + \\underbrace{\\frac{\\tau_{\\mathsf{cE}}}{1 + \\tau_{\\mathsf{cE}}} p_{\\mathsf{E}} c_{\\mathsf{E}}}_{\\text{energy consumption tax revenue}} + \\underbrace{\\frac{\\tau_{\\mathsf{oM}}}{1 + \\tau_{\\mathsf{oM}}} \\cdot 1 \\cdot q_{\\mathsf{M}}}_{\\text{manufacturing output tax revenue}},\n$$\nwhere $q_{\\mathsf{M}}$ is manufacturing output. Market clearing for goods requires $q_{\\mathsf{E}} = c_{\\mathsf{E}}$ and $q_{\\mathsf{M}} = c_{\\mathsf{M}}$. Market clearing for factors requires $L_{\\mathsf{E}} + L_{\\mathsf{M}} = \\bar{L}$ and $K_{\\mathsf{E}} + K_{\\mathsf{M}} = \\bar{K}$, with $L_i = q_i L_{i}^{\\text{unit}}(w,r)$ and $K_i = q_i K_{i}^{\\text{unit}}(w,r)$.\n\nYour program must compute a competitive general equilibrium that simultaneously satisfies:\n- Zero-profit conditions for both sectors,\n- Market clearing for both goods and both factors,\n- The representative household’s income balance (total spending equals total income at consumer prices).\n\nTo compute equilibrium, treat $p_{\\mathsf{E}}$ as an unknown. For any guess of $p_{\\mathsf{E}}$, solve the two zero-profit conditions for $(w,r)$, then solve the $2 \\times 2$ linear system implied by factor market clearing to obtain $(q_{\\mathsf{E}}, q_{\\mathsf{M}})$. Using the household’s expenditure rules, compute the implied $p_{\\mathsf{E}}^{*} = \\frac{\\beta Y}{q_{\\mathsf{E}}}$. At equilibrium, consistency requires $p_{\\mathsf{E}} = p_{\\mathsf{E}}^{*}$. Use a fixed-point iteration or root-finding to enforce $p_{\\mathsf{E}} = p_{\\mathsf{E}}^{*}$.\n\nImplement numerical tolerances as follows: a condition is considered satisfied if the absolute value of its residual is less than $\\varepsilon = 10^{-8}$.\n\nDesign your solution to produce boolean verification results for three conditions per test case: goods and factor market clearing, zero-profit, and income balance. For each test case, output a list $[b_{\\text{mc}}, b_{\\text{zp}}, b_{\\text{ib}}]$ where each entry is either $\\mathsf{True}$ or $\\mathsf{False}$ depending on whether the condition is satisfied within tolerance.\n\nTest Suite:\n- Case $1$ (baseline):\n  - Sector $\\mathsf{E}$: $A_{\\mathsf{E}} = 1.0$, $a_{\\mathsf{E}} = 0.6$, $\\sigma_{\\mathsf{E}} = 0.8$, $\\tau_{\\mathsf{cE}} = 0.2$.\n  - Sector $\\mathsf{M}$: $A_{\\mathsf{M}} = 1.0$, $a_{\\mathsf{M}} = 0.5$, $\\sigma_{\\mathsf{M}} = 0.7$, $\\tau_{\\mathsf{oM}} = 0.1$.\n  - Endowments: $\\bar{L} = 100.0$, $\\bar{K} = 80.0$.\n  - Preferences: $\\beta = 0.4$.\n- Case $2$ (high energy tax boundary):\n  - Sector $\\mathsf{E}$: $A_{\\mathsf{E}} = 0.9$, $a_{\\mathsf{E}} = 0.5$, $\\sigma_{\\mathsf{E}} = 0.6$, $\\tau_{\\mathsf{cE}} = 1.0$.\n  - Sector $\\mathsf{M}$: $A_{\\mathsf{M}} = 1.1$, $a_{\\mathsf{M}} = 0.4$, $\\sigma_{\\mathsf{M}} = 0.5$, $\\tau_{\\mathsf{oM}} = 0.0$.\n  - Endowments: $\\bar{L} = 90.0$, $\\bar{K} = 90.0$.\n  - Preferences: $\\beta = 0.5$.\n- Case $3$ (Cobb–Douglas limit in manufacturing):\n  - Sector $\\mathsf{E}$: $A_{\\mathsf{E}} = 1.2$, $a_{\\mathsf{E}} = 0.7$, $\\sigma_{\\mathsf{E}} = 0.3$, $\\tau_{\\mathsf{cE}} = 0.0$.\n  - Sector $\\mathsf{M}$: $A_{\\mathsf{M}} = 0.95$, $a_{\\mathsf{M}} = 0.5$, $\\sigma_{\\mathsf{M}} = 1.0$, $\\tau_{\\mathsf{oM}} = 0.25$.\n  - Endowments: $\\bar{L} = 110.0$, $\\bar{K} = 70.0$.\n  - Preferences: $\\beta = 0.6$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case result list. For example, the output must look like\n$$\n\\texttt{[[True,True,True],[True,True,True],[True,True,True]]}.\n$$",
            "solution": "The problem describes a complete, two-sector, two-factor Computable General Equilibrium (CGE) model and asks for the computation and verification of its equilibrium for several parameter sets. The equilibrium is a set of prices $(p_{\\mathsf{E}}, w, r)$ and quantities $(q_{\\mathsf{E}}, q_{\\mathsf{M}})$ that satisfies all model conditions simultaneously. Since the model is homogeneous of degree zero in prices, we can choose a numeraire. As specified, we fix the consumer price of the manufacturing good, $p_{\\mathsf{M}}=1$.\n\nThe solution strategy, as outlined in the problem, involves finding the equilibrium relative price of energy, $p_{\\mathsf{E}}$, that clears all markets. This is achieved using a root-finding algorithm. We define a residual function $f(p_{\\mathsf{E}}) = p_{\\mathsf{E}}^{\\text{guess}} - p_{\\mathsf{E}}^{\\text{implied}}$, where an equilibrium is a root $p_{\\mathsf{E}}^{eq}$ such that $f(p_{\\mathsf{E}}^{eq})=0$.\n\nFor any given guess of $p_{\\mathsf{E}}$, the implied price $p_{\\mathsf{E}}^{\\text{implied}}$ is found through the following sequence of steps:\n\n1.  **Solve for Factor Prices $(w, r)$**: Given $p_{\\mathsf{E}}$, the producer prices are fixed: $p_{\\mathsf{E}}^{p} = p_{\\mathsf{E}}/(1+\\tau_{\\mathsf{cE}})$ and $p_{\\mathsf{M}}^{p} = 1/(1+\\tau_{\\mathsf{oM}})$. The two zero-profit conditions, $c_{\\mathsf{E}}(w,r)=p_{\\mathsf{E}}^p$ and $c_{\\mathsf{M}}(w,r)=p_{\\mathsf{M}}^p$, form a system of two non-linear equations for the factor prices $(w,r)$. Since the cost functions are homogeneous of degree one, their ratio depends only on the wage-rental ratio $\\omega = w/r$. We can solve the single non-linear equation $\\frac{c_{\\mathsf{E}}(\\omega,1)}{c_{\\mathsf{M}}(\\omega,1)} = \\frac{p_{\\mathsf{E}}^{p}}{p_{\\mathsf{M}}^{p}}$ for $\\omega$ using a numerical root-finder. Once $\\omega$ is found, we find $r$ from $c_{\\mathsf{M}}(\\omega r, r) = r \\cdot c_{\\mathsf{M}}(\\omega, 1) = p_{\\mathsf{M}}^{p}$, and then $w = \\omega r$.\n\n2.  **Calculate Unit Factor Demands**: With the equilibrium factor prices $(w,r)$ known, we calculate the factor demands per unit of output, $L_i^{\\text{unit}}$ and $K_i^{\\text{unit}}$ for $i \\in \\{\\mathsf{E}, \\mathsf{M}\\}$, using the derivatives of the cost functions (Shephard's lemma). Special care is taken for the Cobb-Douglas case where $\\sigma_{\\mathsf{M}} = 1$.\n\n3.  **Solve for Sectoral Outputs $(q_{\\mathsf{E}}, q_{\\mathsf{M}})$**: The factor market clearing conditions, $L_{\\mathsf{E}}^{\\text{unit}} q_{\\mathsf{E}} + L_{\\mathsf{M}}^{\\text{unit}} q_{\\mathsf{M}} = \\bar{L}$ and $K_{\\mathsf{E}}^{\\text{unit}} q_{\\mathsf{E}} + K_{\\mathsf{M}}^{\\text{unit}} q_{\\mathsf{M}} = \\bar{K}$, constitute a $2 \\times 2$ system of linear equations in the outputs $(q_{\\mathsf{E}}, q_{\\mathsf{M}})$, which is solved using standard matrix algebra.\n\n4.  **Calculate Implied Energy Price $p_{\\mathsf{E}}^{*}$**: The household's total income $Y$ is the sum of factor income and the rebated tax revenue: $Y = w \\bar{L} + r \\bar{K} + \\tau_{\\mathsf{cE}} p_{\\mathsf{E}}^{p} q_{\\mathsf{E}} + \\tau_{\\mathsf{oM}} p_{\\mathsf{M}}^{p} q_{\\mathsf{M}}$. Given Cobb-Douglas preferences, the household's expenditure on energy is $p_{\\mathsf{E}} c_{\\mathsf{E}} = \\beta Y$. With goods market clearing ($q_{\\mathsf{E}} = c_{\\mathsf{E}}$), this implies a market-clearing price for energy: $p_{\\mathsf{E}}^{*} = \\frac{\\beta Y}{q_{\\mathsf{E}}}$.\n\nThis sequence maps a guessed $p_{\\mathsf{E}}$ to an implied $p_{\\mathsf{E}}^*$. A numerical root-finder is used to find the fixed point where $p_{\\mathsf{E}} = p_{\\mathsf{E}}^*$. Once this equilibrium price is found, all other equilibrium variables are determined.\n\nFinally, we verify the solution by checking if the fundamental equilibrium conditions (factor market clearing, zero-profit for both sectors, and household income-expenditure balance) hold to within the specified numerical tolerance of $\\varepsilon=10^{-8}$. The boolean results confirm the successful computation of the competitive general equilibrium for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Computes and verifies the general equilibrium for a two-sector CGE model\n    for three distinct test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Case 1\n            'E': {'A': 1.0, 'a': 0.6, 'sigma': 0.8, 'tau_cE': 0.2},\n            'M': {'A': 1.0, 'a': 0.5, 'sigma': 0.7, 'tau_oM': 0.1},\n            'endow': {'L_bar': 100.0, 'K_bar': 80.0},\n            'prefs': {'beta': 0.4}\n        },\n        { # Case 2\n            'E': {'A': 0.9, 'a': 0.5, 'sigma': 0.6, 'tau_cE': 1.0},\n            'M': {'A': 1.1, 'a': 0.4, 'sigma': 0.5, 'tau_oM': 0.0},\n            'endow': {'L_bar': 90.0, 'K_bar': 90.0},\n            'prefs': {'beta': 0.5}\n        },\n        { # Case 3\n            'E': {'A': 1.2, 'a': 0.7, 'sigma': 0.3, 'tau_cE': 0.0},\n            'M': {'A': 0.95, 'a': 0.5, 'sigma': 1.0, 'tau_oM': 0.25},\n            'endow': {'L_bar': 110.0, 'K_bar': 70.0},\n            'prefs': {'beta': 0.6}\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = compute_and_verify_equilibrium(params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_and_verify_equilibrium(params):\n    \"\"\"\n    Main function to compute equilibrium for a single parameter set and verify it.\n    \"\"\"\n    tol = 1e-8\n\n    def c_func(w, r, A, a, sigma):\n        \"\"\"Unit cost function.\"\"\"\n        if sigma == 1.0:\n            if w = 0 or r = 0: return np.inf\n            return (1/A) * (w**a) * (r**(1-a))\n        else:\n            term = a * w**(1-sigma) + (1-a) * r**(1-sigma)\n            if term  0 and (1-sigma)  0: # Avoid complex numbers for negative base\n                return np.inf\n            return (1/A) * term**(1/(1-sigma))\n\n    def unit_input_demands_func(w, r, A, a, sigma):\n        \"\"\"Unit input demand functions.\"\"\"\n        if sigma == 1.0:\n            c_val = c_func(w, r, A, a, sigma)\n            L_unit = a * c_val / w\n            K_unit = (1-a) * c_val / r\n        else:\n            # Using formulas from the problem description\n            common_term = a * w**(1-sigma) + (1-a) * r**(1-sigma)\n            L_unit = (1/A) * a * common_term**(sigma / (1-sigma)) * w**(-sigma)\n            K_unit = (1/A) * (1-a) * common_term**(sigma / (1-sigma)) * r**(-sigma)\n        return L_unit, K_unit\n\n    def get_all_vars(p_E, params):\n        \"\"\"\n        For a given p_E, calculates all other variables in the model.\n        Returns a dictionary of variables or None on failure.\n        \"\"\"\n        p_E_p = p_E / (1 + params['E']['tau_cE'])\n        p_M_p = 1.0 / (1 + params['M']['tau_oM'])\n\n        # Nested function for finding w/r ratio\n        def omega_residual(omega):\n            c_E_ratio = c_func(omega, 1, params['E']['A'], params['E']['a'], params['E']['sigma'])\n            c_M_ratio = c_func(omega, 1, params['M']['A'], params['M']['a'], params['M']['sigma'])\n            \n            if np.isinf(c_E_ratio) or np.isinf(c_M_ratio) or c_M_ratio == 0:\n                return 1e12 # Return large number for invalid omega\n            \n            target_ratio = p_E_p / p_M_p\n            return c_E_ratio / c_M_ratio - target_ratio\n\n        # Solve for omega = w/r\n        try:\n            sol_omega = root_scalar(omega_residual, bracket=[1e-6, 1e6], method='brentq')\n            if not sol_omega.converged: return None\n            omega = sol_omega.root\n        except (ValueError, RuntimeError):\n            return None\n\n        # Calculate w and r\n        c_M_ratio = c_func(omega, 1, params['M']['A'], params['M']['a'], params['M']['sigma'])\n        r = p_M_p / c_M_ratio\n        w = omega * r\n        \n        # Calculate unit input demands\n        L_E_unit, K_E_unit = unit_input_demands_func(w, r, params['E']['A'], params['E']['a'], params['E']['sigma'])\n        L_M_unit, K_M_unit = unit_input_demands_func(w, r, params['M']['A'], params['M']['a'], params['M']['sigma'])\n        \n        # Solve for q_E, q_M\n        A_matrix = np.array([[L_E_unit, L_M_unit], [K_E_unit, K_M_unit]])\n        b_vector = np.array([params['endow']['L_bar'], params['endow']['K_bar']])\n        try:\n            q_vector = np.linalg.solve(A_matrix, b_vector)\n            q_E, q_M = q_vector[0], q_vector[1]\n        except np.linalg.LinAlgError:\n            return None\n        \n        if q_E = 0 or q_M = 0: return None\n        \n        # Calculate income and implied p_E\n        tax_rev_E = params['E']['tau_cE'] * p_E_p * q_E\n        tax_rev_M = params['M']['tau_oM'] * p_M_p * q_M\n        Y = w * params['endow']['L_bar'] + r * params['endow']['K_bar'] + tax_rev_E + tax_rev_M\n        p_E_star = params['prefs']['beta'] * Y / q_E\n        \n        return {\n            'p_E': p_E, 'p_E_star': p_E_star, 'p_E_p': p_E_p, 'p_M_p': p_M_p, \n            'w': w, 'r': r, 'q_E': q_E, 'q_M': q_M, 'Y': Y,\n            'L_E_unit': L_E_unit, 'K_E_unit': K_E_unit,\n            'L_M_unit': L_M_unit, 'K_M_unit': K_M_unit\n        }\n\n    # Outer root finding for p_E\n    def p_E_residual(p_E):\n        res = get_all_vars(p_E, params)\n        if res is None: return 1e12\n        return res['p_E'] - res['p_E_star']\n\n    try:\n        sol_p_E = root_scalar(p_E_residual, bracket=[0.1, 10.0], method='brentq')\n        if not sol_p_E.converged: return [False, False, False]\n        p_E_eq = sol_p_E.root\n    except (ValueError, RuntimeError):\n        return [False, False, False]\n\n    # Get final equilibrium values\n    eq_vars = get_all_vars(p_E_eq, params)\n\n    # Verification\n    # 1. Market Clearing\n    L_demand = eq_vars['L_E_unit'] * eq_vars['q_E'] + eq_vars['L_M_unit'] * eq_vars['q_M']\n    K_demand = eq_vars['K_E_unit'] * eq_vars['q_E'] + eq_vars['K_M_unit'] * eq_vars['q_M']\n    mc_L_ok = abs(L_demand - params['endow']['L_bar'])  tol\n    mc_K_ok = abs(K_demand - params['endow']['K_bar'])  tol\n    b_mc = mc_L_ok and mc_K_ok\n\n    # 2. Zero Profit\n    c_E_val = c_func(eq_vars['w'], eq_vars['r'], params['E']['A'], params['E']['a'], params['E']['sigma'])\n    c_M_val = c_func(eq_vars['w'], eq_vars['r'], params['M']['A'], params['M']['a'], params['M']['sigma'])\n    zp_E_ok = abs(c_E_val - eq_vars['p_E_p'])  tol\n    zp_M_ok = abs(c_M_val - eq_vars['p_M_p'])  tol\n    b_zp = zp_E_ok and zp_M_ok\n\n    # 3. Income Balance (Walras' Law check)\n    expenditure = eq_vars['p_E'] * eq_vars['q_E'] + 1.0 * eq_vars['q_M']\n    b_ib = abs(expenditure - eq_vars['Y'])  tol\n\n    return [b_mc, b_zp, b_ib]\n\nsolve()\n```"
        }
    ]
}