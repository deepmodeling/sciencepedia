{
    "hands_on_practices": [
        {
            "introduction": "投资模型的基石是其目标函数，该函数通常旨在最小化整个系统在长规划期内的总成本。本练习  提供了从基本原理构建此目标函数的实践机会，使用贴现现金流方法来恰当评估不同时间点发生的成本。理解如何计算净现值成本（Net Present Cost, NPC），即所有资本支出（$\\text{CAPEX}$）和运营支出（$\\text{OPEX}$）的贴现总和，是建立和解读容量扩张模型的关键第一步。",
            "id": "4099352",
            "problem": "考虑一个能源系统建模中的简化容量扩张问题，该问题汇总了多年规划期内的投资支出和运营支出。目标是基于贴现现金流的第一性原理，构建一个综合目标函数，用于评估与投资和运营相关的所有现金流的净现值。您的程序必须从金融数学的基本原理出发，实现以下内容。\n\n基本原理：对于在年份 $y$ 发生的未来现金流，其相对于基准年 $y_0$ 和恒定年贴现率 $r$ 的现值，由该现金流与特定年份贴现因子 $d_y$ 的乘积给出，其中 $d_y$ 定义为\n$$\nd_y = (1 + r)^{-(y - y_0)}.\n$$\n该定义直接源于货币时间价值原理，其中贴现操作将未来价值转换为其等效的现值。在容量扩张建模中，目标是评估每年投资支出和运营支出总和的净现值，通过使用 $d_y$ 将所有价值对齐到基准年 $y_0$。资本支出 (CAPEX) 和运营支出 (OPEX) 定义如下：\n- 资本支出 (CAPEX) 是每项由 $i$ 索引的技术的年化投资现金流，在年份 $y$ 表示为 $\\text{CAPEX}_{i,y}$。\n- 运营支出 (OPEX) 是年份 $y$ 内每个年内时间步 $t$ 的运营现金流，对于 $t \\in \\mathcal{T}_y$ 表示为 $\\text{OPEX}_t$，其中 $\\mathcal{T}_y$ 是年份 $y$ 内的时间步集合。\n\n您的任务是实现净现成本目标函数，该函数对每一年 $y$，汇总 $\\sum_{i} \\text{CAPEX}_{i,y}$ 和 $\\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t$，并应用上述基本原理推导出的贴现因子 $d_y$。$d_y$ 的作用是根据贴现率 $r$ 对每年的汇总现金流进行加权，从而使较晚年份的金额对目标值的贡献减少。最终目标是规划期内所有年份的这些贴现后年度总额之和。\n\n单位：每个现金流 $\\text{CAPEX}_{i,y}$ 和 $\\text{OPEX}_t$ 均以百万货币单位提供。您的程序必须以百万货币单位输出目标值，格式为浮点数。不应包含任何货币符号。如果需要分数，请使用小数表示法。\n\n测试套件：请实现您的程序，为以下每个案例计算目标值，每个案例都以参数集的形式给出。在每个案例中，使用 $d_y = (1 + r)^{-(y - y_0)}$ 将年度总额贴现至基准年 $y_0$。\n\n案例 1（包含多种技术、多个年份和季度运营步长的通用案例）：\n- 基准年 $y_0$：$2025$。\n- 年份 $\\mathcal{Y}$：$[2025, 2026, 2027]$。\n- 贴现率 $r$：$0.07$。\n- 技术排序为 $\\text{CCGT}$、$\\text{Wind}$、$\\text{Battery}$。\n- 按年份的 $\\text{CAPEX}$（列表顺序对应技术）：\n  - 在 $2025$：$[300, 200, 100]$。\n  - 在 $2026$：$[0, 150, 50]$。\n  - 在 $2027$：$[0, 0, -20]$。\n- 按年份的 $\\text{OPEX}$（每年的季度值）：\n  - 在 $2025$：$[50, 48, 52, 50]$。\n  - 在 $2026$：$[55, 60, 58, 57]$。\n  - 在 $2027$：$[62, 64, 63, 65]$。\n\n案例 2（零贴现率和零运营成本的边界案例）：\n- 基准年 $y_0$：$2030$。\n- 年份 $\\mathcal{Y}$：$[2030, 2031]$。\n- 贴现率 $r$：$0$。\n- 技术排序为 $\\text{Solar}$、$\\text{Wind}$。\n- 按年份的 $\\text{CAPEX}$：\n  - 在 $2030$：$[120, 80]$。\n  - 在 $2031$：$[0, 40]$。\n- 按年份的 $\\text{OPEX}$：\n  - 在 $2030$：$[0, 0, 0]$。\n  - 在 $2031$：$[0, 0, 0]$。\n\n案例 3（高贴现率、月度运营步长及最后一年有残值收益的边缘案例）：\n- 基准年 $y_0$：$2024$。\n- 年份 $\\mathcal{Y}$：$[2024, 2025, 2026, 2027, 2028]$。\n- 贴现率 $r$：$0.15$。\n- 技术排序为 $\\text{Nuclear}$、$\\text{Wind}$。\n- 按年份的 $\\text{CAPEX}$：\n  - 在 $2024$：$[1000, 0]$。\n  - 在 $2025$：$[0, 200]$。\n  - 在 $2026$：$[500, 0]$。\n  - 在 $2027$：$[0, 200]$。\n  - 在 $2028$：$[-100, 0]$。\n- 按年份的 $\\text{OPEX}$（每年的月度值）：\n  - 在 $2024$：$[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]$。\n  - 在 $2025$：$[12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5]$。\n  - 在 $2026$：$[13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333]$。\n  - 在 $2027$：$[14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667]$。\n  - 在 $2028$：$[15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]$。\n\n案例 4（无投资决策和季节性运营步长的边缘案例）：\n- 基准年 $y_0$：$2020$。\n- 年份 $\\mathcal{Y}$：$[2020]$。\n- 贴现率 $r$：$0.05$。\n- 技术集为空（无 $\\text{CAPEX}$ 流）。\n- 按年份的 $\\text{CAPEX}$：\n  - 在 $2020$：$[]$。\n- 按年份的 $\\text{OPEX}$（该年的季节性值）：\n  - 在 $2020$：$[25, 25, 25, 25]$。\n\n您的程序必须使用上述原理和数据为每个案例计算净现成本目标值。输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，例如 $[x_1, x_2, x_3, x_4]$，其中每个 $x_k$ 是为案例 $k$ 计算的目标值（以百万货币单位表示的浮点数）。输出必须只有一行，没有任何附加文本。",
            "solution": "该问题要求为一个简化的能源系统容量扩张问题构建并实现一个净现成本 (NPC) 目标函数。该目标的基础是贴现现金流 (DCF) 原理，这是金融数学的基石，用于比较发生在不同时间点的现金流。\n\n其核心原则是，未来现金流的价值低于今天收到的相同金额的现金流。这种货币时间价值通过贴现率 $r$ 进行量化。发生在未来年份 $y$ 的现金流，通过乘以一个贴现因子 $d_y$ 转换为其在基准年 $y_0$ 的现值。根据题目规定，该贴现因子定义为：\n$$\nd_y = (1 + r)^{-(y - y_0)}\n$$\n该公式表明，对于一个正的贴现率 $r > 0$，随着时间差 $(y - y_0)$ 的增加，$d_y$ 的值会减小，这意味着越是未来的现金流，其价值越低。\n\n在规划期内的任何给定年份 $y$ 的总成本是所有投资（资本）支出和运营支出的总和。设 $C_y$ 为年份 $y$ 的未贴现总现金流。它由所有技术 $i$ 的资本支出 (CAPEX) 总和以及所有年内时间步 $t \\in \\mathcal{T}_y$ 的运营支出 (OPEX) 总和构成：\n$$\nC_y = \\left( \\sum_{i} \\text{CAPEX}_{i,y} \\right) + \\left( \\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t \\right)\n$$\n这里，$\\text{CAPEX}_{i,y}$ 表示技术 $i$ 在年份 $y$ 的投资成本，而 $\\text{OPEX}_t$ 表示年份 $y$ 内特定时间步 $t$ 的运营成本。负现金流，例如负的 $\\text{CAPEX}$，代表一笔收益或收入，例如来自退役资产的残值。\n\n总体目标是计算净现成本 (NPC)，即规划期 $\\mathcal{Y}$ 内所有年份 $y$ 的贴现后年度成本的总和。通过将贴现因子 $d_y$ 应用于每年的总成本 $C_y$，我们将所有成本对齐到基准年 $y_0$ 这个公共参考点。因此，完整的目标函数为：\n$$\n\\text{NPC} = \\sum_{y \\in \\mathcal{Y}} d_y \\cdot C_y = \\sum_{y \\in \\mathcal{Y}} (1 + r)^{-(y - y_0)} \\left( \\left( \\sum_{i} \\text{CAPEX}_{i,y} \\right) + \\left( \\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t \\right) \\right)\n$$\n程序化实现直接遵循此公式。设计一个算法来处理每个测试案例，执行以下步骤：\n1. 将总净现成本 $\\text{NPC}$ 初始化为 $0$。\n2. 对于指定规划期 $\\mathcal{Y}$ 中的每一年 $y$：\n    a. 通过对该年提供的 $\\text{CAPEX}$ 列表中的所有元素求和，计算年份 $y$ 的总资本支出。对于空的技术集，此和为 $0$。\n    b. 通过对该年提供的 $\\text{OPEX}$ 列表中的所有元素求和，计算年份 $y$ 的总运营支出。\n    c. 将步骤 2a 和 2b 的结果相加，得到年份 $y$ 的未贴现总成本 $C_y$。\n    d. 使用给定的贴现率 $r$、当前年份 $y$ 和基准年 $y_0$，计算贴现因子 $d_y = (1 + r)^{-(y - y_0)}$。\n    e. 将年度总成本 $C_y$ 乘以贴现因子 $d_y$，得到年份 $y$ 的贴现后成本。\n    f. 将此贴现后成本累加到 $\\text{NPC}$ 的运行总和中。\n3. 遍历完规划期中的所有年份后，最终的累计值即为该案例的 $\\text{NPC}$。\n\n此过程被系统地应用于四个测试案例中的每一个，使用它们各自的年份、贴现率和现金流参数来计算最终的目标值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present cost for a series of energy system investment cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"y0\": 2025,\n            \"years\": [2025, 2026, 2027],\n            \"r\": 0.07,\n            \"capex_data\": {2025: [300, 200, 100], 2026: [0, 150, 50], 2027: [0, 0, -20]},\n            \"opex_data\": {2025: [50, 48, 52, 50], 2026: [55, 60, 58, 57], 2027: [62, 64, 63, 65]},\n        },\n        {\n            \"y0\": 2030,\n            \"years\": [2030, 2031],\n            \"r\": 0.0,\n            \"capex_data\": {2030: [120, 80], 2031: [0, 40]},\n            \"opex_data\": {2030: [0, 0, 0], 2031: [0, 0, 0]},\n        },\n        {\n            \"y0\": 2024,\n            \"years\": [2024, 2025, 2026, 2027, 2028],\n            \"r\": 0.15,\n            \"capex_data\": {2024: [1000, 0], 2025: [0, 200], 2026: [500, 0], 2027: [0, 200], 2028: [-100, 0]},\n            \"opex_data\": {\n                2024: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10],\n                2025: [12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5],\n                2026: [13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333],\n                2027: [14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667],\n                2028: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],\n            },\n        },\n        {\n            \"y0\": 2020,\n            \"years\": [2020],\n            \"r\": 0.05,\n            \"capex_data\": {2020: []},\n            \"opex_data\": {2020: [25, 25, 25, 25]},\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        y0 = case[\"y0\"]\n        years = case[\"years\"]\n        r = case[\"r\"]\n        capex_data = case[\"capex_data\"]\n        opex_data = case[\"opex_data\"]\n        \n        total_npc = 0.0\n        \n        for y in years:\n            # Calculate total undiscounted cost for the year\n            annual_capex = np.sum(capex_data[y])\n            annual_opex = np.sum(opex_data[y])\n            total_annual_cost = annual_capex + annual_opex\n            \n            # Calculate discount factor\n            discount_factor = (1 + r) ** -(y - y0)\n            \n            # Add discounted cost to total NPC\n            total_npc += total_annual_cost * discount_factor\n            \n        results.append(total_npc)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "投资模型关注长期成本，而运行模型则必须确保系统在每个时刻都物理可行。本练习  深入探讨了一个关键的运行细节：发电机组的爬坡约束。您将探索投资决策（即所选发电机组的灵活性，体现在爬坡率 $R_i$ 和滑坡率 $S_i$ 上）如何直接影响短期运行的可行性，从而清晰地揭示两种模型类型之间的联系。",
            "id": "4099394",
            "problem": "考虑一个由技术 $i \\in \\{1,\\dots,N\\}$ 和时间周期 $t \\in \\{1,\\dots,T\\}$ 索引的发电系统。设 $p_{i,t}$ 表示技术 $i$ 在周期 $t$ 的发电调度决策，$x_i$ 表示技术 $i$ 的装机容量，$R_i$ 表示技术 $i$ 每个周期的最大爬坡能力，$S_i$ 表示技术 $i$ 每个周期的最大降坡能力，$p_{i,0}$ 表示周期 $t=1$ 之前的初始调度水平，$d_t$ 表示周期 $t$ 的电力需求。\n\n从电力系统运营可行性的以下基本基础出发：\n- 每个周期的功率平衡守恒：$$\\sum_{i=1}^{N} p_{i,t} = d_t \\quad \\text{for all } t \\in \\{1,\\dots,T\\}.$$\n- 每种技术的物理容量限制：$$0 \\le p_{i,t} \\le x_i \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; t \\in \\{1,\\dots,T\\}.$$\n- 表示有限灵活性的跨期爬坡约束：$$p_{i,t} - p_{i,t-1} \\le R_i, \\quad p_{i,t-1} - p_{i,t} \\le S_i \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; t \\in \\{1,\\dots,T\\},$$ 其中约定 $p_{i,0}$ 为给定值。\n\n你的任务是：\n- 将上述爬坡约束明确地构建为线性不等式，并用严谨的术语解释，即使装机容量 $x_i$ 看起来足以满足静态需求水平，但投资中的灵活性不足（体现在相对于需求变化的 $R_i$ 和 $S_i$ 较小）也会导致运营不可行的机制。\n- 实现一个程序，在给定一组与投资相关的参数 $\\{x_i,R_i,S_i\\}$、初始条件 $\\{p_{i,0}\\}$ 和需求轨迹 $\\{d_t\\}$ 的情况下，确定是否存在一个满足所有约束的可行调度方案 $\\{p_{i,t}\\}$。该程序必须构建并解决一个线性可行性问题。\n\n使用以下参数集测试套件。每个测试案例指定了 $(N,T)$、需求序列 $\\{d_t\\}$、容量 $\\{x_i\\}$、爬坡上限 $\\{R_i\\}$、降坡上限 $\\{S_i\\}$ 和初始出力 $\\{p_{i,0}\\}$。为清晰起见，每个列表均按适用的技术或时间周期的顺序列出。\n\n- 测试案例 1（一般理想情况）：\n  - $N = 2$, $T = 4$,\n  - $\\{d_t\\} = \\{80, 100, 120, 110\\}$,\n  - $\\{x_i\\} = \\{100, 100\\}$,\n  - $\\{R_i\\} = \\{50, 30\\}$,\n  - $\\{S_i\\} = \\{50, 30\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$。\n  预期定性行为：可行，因为总爬坡能力可以跟随需求变化。\n\n- 测试案例 2（边界情况，精确匹配爬坡）：\n  - $N = 1$, $T = 6$,\n  - $\\{d_t\\} = \\{20, 40, 60, 80, 100, 120\\}$,\n  - $\\{x_i\\} = \\{120\\}$,\n  - $\\{R_i\\} = \\{20\\}$,\n  - $\\{S_i\\} = \\{20\\}$,\n  - $\\{p_{i,0}\\} = \\{0\\}$。\n  预期定性行为：可行，爬坡精确匹配需求增量。\n\n- 测试案例 3（容量充足但爬坡能力不足）：\n  - $N = 1$, $T = 2$,\n  - $\\{d_t\\} = \\{0, 50\\}$,\n  - $\\{x_i\\} = \\{120\\}$,\n  - $\\{R_i\\} = \\{10\\}$,\n  - $\\{S_i\\} = \\{120\\}$,\n  - $\\{p_{i,0}\\} = \\{0\\}$。\n  预期定性行为：不可行，因为需求的 $50$ 增量超过了可用的 $10$ 的爬坡能力。\n\n- 测试案例 4（降坡能力不足导致无法跟随需求下降）：\n  - $N = 1$, $T = 2$,\n  - $\\{d_t\\} = \\{100, 0\\}$,\n  - $\\{x_i\\} = \\{100\\}$,\n  - $\\{R_i\\} = \\{100\\}$,\n  - $\\{S_i\\} = \\{10\\}$,\n  - $\\{p_{i,0}\\} = \\{100\\}$。\n  预期定性行为：不可行，因为需求的 $100$ 降量超过了可用的 $10$ 的降坡能力。\n\n- 测试案例 5（投资组合缺乏灵活技术，不可行）：\n  - $N = 2$, $T = 2$,\n  - $\\{d_t\\} = \\{50, 150\\}$,\n  - $\\{x_i\\} = \\{150, 50\\}$,\n  - $\\{R_i\\} = \\{5, 50\\}$,\n  - $\\{S_i\\} = \\{5, 50\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$。\n  预期定性行为：不可行，因为总爬坡能力 $5 + 50 = 55$ 无法覆盖 $100$ 的需求增长。\n\n- 测试案例 6（相同容量但对灵活性的投资更高，可行）：\n  - $N = 2$, $T = 2$,\n  - $\\{d_t\\} = \\{50, 150\\}$,\n  - $\\{x_i\\} = \\{150, 50\\}$,\n  - $\\{R_i\\} = \\{50, 50\\}$,\n  - $\\{S_i\\} = \\{50, 50\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$。\n  预期定性行为：可行，因为总爬坡能力 $50 + 50 = 100$ 正好覆盖需求增长。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试案例 1 到 6 的顺序给出结果，其中每个条目都是一个布尔值，表示可行性（例如，$\\left[\\text{True},\\text{False},\\dots\\right]$）。输出中不需要物理单位，因为结果是布尔值。算法必须是通用的，并适用于任何现代编程语言；你的最终答案必须是指定的一个完整的可运行程序。",
            "solution": "所提出的问题是一个有效的线性可行性问题，这是能源系统优化领域的一个基本概念。它具有科学依据，问题陈述清晰，并且解决问题所需的所有参数都已提供。我们继续进行分析和求解。\n\n该问题要求确定对于由 $N$ 种发电技术在 $T$ 个时间周期内组成的机组，是否存在一个可行的发电调度方案，该方案由变量集 $\\{p_{i,t}\\}$ 表示。如果一个方案同时满足三组线性约束：功率平衡、容量限制和跨期爬坡限制，则该方案是可行的。\n\n对于给定的技术 $i$，其爬坡约束由每个时间周期 $t \\in \\{1,\\dots,T\\}$ 的两个不等式给出：\n$$p_{i,t} - p_{i,t-1} \\le R_i$$\n$$p_{i,t-1} - p_{i,t} \\le S_i$$\n其中 $p_{i,t}$ 是周期 $t$ 的功率输出，$p_{i,t-1}$ 是前一个周期的输出（$p_{i,0}$ 是给定的初始条件），$R_i$ 是最大爬坡率，$S_i$ 是最大降坡率。这些可以组合成一个单一的表达式：\n$$-S_i \\le p_{i,t} - p_{i,t-1} \\le R_i$$\n这个复合不等式表明，技术 $i$ 在连续周期之间的功率输出变化是受限的。$R_i$ 和 $S_i$ 是发电厂的物理特性，反映了其“灵活性”。例如，一个大型燃煤电厂具有巨大的热惯性，无法快速改变其输出，导致其相对于容量的 $R_i$ 和 $S_i$ 值很小。相反，天然气调峰电厂或电池储能系统则非常灵活，对应着较大的 $R_i$ 和 $S_i$ 值。选择建造哪些技术，从而决定系统范围内的 $\\{R_i, S_i\\}$ 值，是一个投资决策。\n\n即使在静态容量充足的情况下，灵活性不足导致运营不可行的机制可以被严格证明。考虑从周期 $t-1$ 到 $t$ 的系统总需求变化，即 $d_t - d_{t-1}$。使用功率平衡约束 $\\sum_{i=1}^{N} p_{i,t} = d_t$，我们可以用发电调度来表示这个需求变化：\n$$d_t - d_{t-1} = \\sum_{i=1}^{N} p_{i,t} - \\sum_{i=1}^{N} p_{i,t-1} = \\sum_{i=1}^{N} (p_{i,t} - p_{i,t-1})$$\n从爬坡约束中，我们知道对于每种技术 $i$，都有 $p_{i,t} - p_{i,t-1} \\le R_i$。将此不等式对所有技术求和可得：\n$$\\sum_{i=1}^{N} (p_{i,t} - p_{i,t-1}) \\le \\sum_{i=1}^{N} R_i$$\n通过代入需求变化的表达式，我们得出了一个可行性的必要条件：\n$$d_t - d_{t-1} \\le \\sum_{i=1}^{N} R_i$$\n同样，从降坡约束 $p_{i,t-1} - p_{i,t} \\le S_i$，我们可以推导出：\n$$d_{t-1} - d_t \\le \\sum_{i=1}^{N} S_i$$\n这两个关系表明，整个系统的净需求变化必须小于或等于发电机组的总爬坡或降坡能力。如果需求增量 $d_t - d_{t-1}$ 大于系统总爬坡能力 $\\sum_i R_i$，那么在数学上就不可能找到一组 $\\{p_{i,t}\\}$ 同时满足爬坡约束和功率平衡约束。这正是一种情况，即一个投资组合，即使其总容量 $\\sum_i x_i$ 远大于峰值需求 $\\max_t d_t$，也可能由于缺乏灵活性而导致运营不可行。\n\n然而，满足这些总爬坡条件是可行性的必要但不充分条件。一个可行的解决方案还必须在每个时间步为每种技术遵守各自的容量限制 $0 \\le p_{i,t} \\le x_i$ 和各自的爬坡约束。例如，一个已经在其最大容量 $x_i$ 下运行的发电机，即使其 $R_i$很大，也无法进一步爬坡。因此，系统的可行性是所有约束在整个时间范围内的复杂相互作用的结果。在周期 $t$ 如何调度发电的决策，对周期 $t+1$ 的可行性具有影响。\n\n为了明确地确定可行性，我们必须解决一个线性可行性问题。我们试图在一个高维空间中找到一个能同时满足所有线性约束的点。这个问题的变量是所有 $i \\in \\{1,\\dots,N\\}$ 和 $t \\in \\{1,\\dots,T\\}$ 的调度水平 $p_{i,t}$。让我们定义一个大小为 $N \\times T$ 的单一决策变量向量 $\\mathbf{p}$，通过堆叠所有 $p_{i,t}$ 值得到。问题是找到 $\\mathbf{p}$，使得：\n1.  等式约束（功率平衡）：$A_{eq}\\mathbf{p} = \\mathbf{b}_{eq}$，其中每一行对应一个时间周期 $t$ 并强制 $\\sum_i p_{i,t} = d_t$。\n2.  不等式约束（爬坡）：$A_{ub}\\mathbf{p} \\le \\mathbf{b}_{ub}$，其中各行对所有 $i, t$ 强制 $p_{i,t} - p_{i,t-1} \\le R_i$ 和 $p_{i,t-1} - p_{i,t} \\le S_i$。\n3.  变量边界（容量限制）：$\\mathbf{0} \\le \\mathbf{p} \\le \\mathbf{x}_{stacked}$，其中上界由给定的容量 $x_i$ 导出。\n\n一个标准的线性规划（LP）求解器可以解决这个问题。如果求解器找到了满足所有约束的一组变量 $\\mathbf{p}$，则问题是可行的。如果它证明不存在这样的 $\\mathbf{p}$，则问题是不可行的。下面的实现构建了这些矩阵和向量，并使用一个 LP 求解器来确定每个测试案例的可行性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_feasibility(N, T, d, x, R, S, p0):\n    \"\"\"\n    Formulates and solves a linear feasibility problem for electricity dispatch.\n\n    Args:\n        N (int): Number of technologies.\n        T (int): Number of time periods.\n        d (list): Demand sequence of length T.\n        x (list): Installed capacities of length N.\n        R (list): Ramp-up limits of length N.\n        S (list): Ramp-down limits of length N.\n        p0 (list): Initial dispatch levels of length N.\n\n    Returns:\n        bool: True if a feasible schedule exists, False otherwise.\n    \"\"\"\n    # Total number of decision variables (p_i,t for all i, t)\n    num_vars = N * T\n\n    # The vector of variables is flattened as [p_1,1, ..., p_1,T, p_2,1, ..., p_N,T]\n    # The index for p_i,t is (i-1)*T + (t-1)\n\n    # Objective function: we only seek feasibility, so we can minimize a zero vector.\n    c = np.zeros(num_vars)\n\n    # --- Equality constraints: sum_{i} p_{i,t} = d_t for each t ---\n    # There are T equality constraints.\n    A_eq = np.zeros((T, num_vars))\n    b_eq = np.array(d)\n    for t_idx in range(T):  # t_idx corresponds to t-1\n        for i_idx in range(N):  # i_idx corresponds to i-1\n            var_idx = i_idx * T + t_idx\n            A_eq[t_idx, var_idx] = 1\n\n    # --- Inequality constraints: Ramping ---\n    # There are 2*N*T ramping constraints (one ramp-up, one ramp-down per i,t)\n    num_ineq_constr = 2 * N * T\n    A_ub = np.zeros((num_ineq_constr, num_vars))\n    b_ub = np.zeros(num_ineq_constr)\n    \n    constraint_idx = 0\n    for i_idx in range(N):\n        for t_idx in range(T):\n            var_idx_t = i_idx * T + t_idx\n            \n            # 1. Ramp-up: p_{i,t} - p_{i,t-1} = R_i\n            if t_idx == 0:  # t=1, uses p_{i,0}\n                # p_{i,1} - p_{i,0} = R_i  =>  p_{i,1} = R_i + p_{i,0}\n                A_ub[constraint_idx, var_idx_t] = 1\n                b_ub[constraint_idx] = R[i_idx] + p0[i_idx]\n            else:  # t > 1\n                var_idx_t_minus_1 = i_idx * T + (t_idx - 1)\n                A_ub[constraint_idx, var_idx_t] = 1\n                A_ub[constraint_idx, var_idx_t_minus_1] = -1\n                b_ub[constraint_idx] = R[i_idx]\n            constraint_idx += 1\n\n            # 2. Ramp-down: p_{i,t-1} - p_{i,t} = S_i\n            if t_idx == 0:  # t=1, uses p_{i,0}\n                # p_{i,0} - p_{i,1} = S_i  =>  -p_{i,1} = S_i - p_{i,0}\n                A_ub[constraint_idx, var_idx_t] = -1\n                b_ub[constraint_idx] = S[i_idx] - p0[i_idx]\n            else:  # t > 1\n                var_idx_t_minus_1 = i_idx * T + (t_idx - 1)\n                A_ub[constraint_idx, var_idx_t] = -1\n                A_ub[constraint_idx, var_idx_t_minus_1] = 1\n                b_ub[constraint_idx] = S[i_idx]\n            constraint_idx += 1\n            \n    # --- Variable bounds: 0 = p_{i,t} = x_i ---\n    bounds = []\n    for i_idx in range(N):\n        for _ in range(T):\n            bounds.append((0, x[i_idx]))\n\n    # Solve the linear program\n    # The 'highs' solver is robust and suitable for this feasibility problem.\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    # res.success is True if an optimal solution is found.\n    # For a feasibility problem, this means a feasible solution exists.\n    # If the problem is infeasible, res.status is 2 and res.success is False.\n    return res.success\n\ndef solve():\n    \"\"\"\n    Runs the feasibility check for all test cases provided in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, T, d, x, R, S, p0)\n        (2, 4, [80, 100, 120, 110], [100, 100], [50, 30], [50, 30], [0, 0]),\n        (1, 6, [20, 40, 60, 80, 100, 120], [120], [20], [20], [0]),\n        (1, 2, [0, 50], [120], [10], [120], [0]),\n        (1, 2, [100, 0], [100], [100], [10], [100]),\n        (2, 2, [50, 150], [150, 50], [5, 50], [5, 50], [0, 0]),\n        (2, 2, [50, 150], [150, 50], [50, 50], [50, 50], [0, 0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, d, x, R, S, p0 = case\n        is_feasible = check_feasibility(N, T, d, x, R, S, p0)\n        results.append(is_feasible)\n\n    # The final output must be a single line in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了保持计算上的可行性，投资模型通常会简化运行细节，例如使用“典型日”来代替完整的全年按时间顺序的模拟。本练习  直面这一核心权衡。您将实施一个完整的按时间顺序的模拟和一个典型日模型，以量化储能使用和爬坡需求等关键指标的误差，从而学习如何验证长期规划模型中固有的简化方法的有效性。",
            "id": "4099356",
            "problem": "构建一个完整的程序，用于在能源系统建模的投资与运行模型结构背景下，评估与全时序运行模拟相比，使用代表日对储能循环和爬坡约束准确性的影响。该比较必须使用基于科学的调度启发式算法和有原则的验证指标来执行。程序必须实现以下组件。\n\n1. 基本时间序列定义。设有一个包含$365$天，每天$24$小时的合成年份，由$d \\in \\{0,1,\\dots,364\\}$和$h \\in \\{0,1,\\dots,23\\}$索引。将确定性的小时电力负荷$L_{d,h}$和可变可再生能源$R_{d,h}$定义为具有日内和季节性结构的光滑函数：\n- 负荷：\n$$\nL_{d,h} = 80 + 12 \\sin\\left(\\frac{2\\pi h}{24} - \\frac{\\pi}{3}\\right) + 8 \\sin\\left(\\frac{2\\pi d}{365}\\right),\n$$\n- 由类太阳能项和类风能项组成的可再生能源发电：\n$$\n\\text{Solar}_{d,h} = 25 \\cdot \\max\\left(0, \\sin\\left(\\frac{2\\pi (h-6)}{24}\\right)\\right) \\cdot \\left(1 + 0.3 \\cos\\left(\\frac{2\\pi d}{365}\\right)\\right),\n$$\n$$\n\\text{Wind}_{d,h} = 15 + 6 \\cos\\left(\\frac{2\\pi d}{365} + 0.5\\right) + 3 \\sin\\left(\\frac{2\\pi h}{24} + 0.2\\right),\n$$\n$$\nR_{d,h} = \\text{Solar}_{d,h} + \\text{Wind}_{d,h}.\n$$\n净需求为\n$$\nD_{d,h} = L_{d,h} - R_{d,h}.\n$$\n将年份平展为单个时序序列$\\{D_t\\}_{t=0}^{T-1}$，其中$T = 365 \\cdot 24$且$t = 24d + h$。\n\n2. 物理设备约束和能量平衡。考虑一个理想化的单一电化学储能设备，其能量容量为$E_{\\text{cap}}$（单位$\\mathrm{MWh}$），对称的功率限制为$P_{\\text{ch}}$和$P_{\\text{dis}}$（单位$\\mathrm{MW}$），充电效率为$\\eta_{\\text{ch}} \\in (0,1]$，放电效率为$\\eta_{\\text{dis}} \\in (0,1]$。令$S_t$表示在小时$t$储能向电网的净注入功率（单位$\\mathrm{MW}$，$S_t > 0$表示放电；$S_t  0$表示充电）。令$E_t$表示荷电状态（单位$\\mathrm{MWh}$）。状态更新必须满足基本的能量守恒和设备限制：\n- 功率边界：\n$$\n-P_{\\text{ch}} \\leq S_t \\leq P_{\\text{dis}}.\n$$\n- 包含效率和边界的状态更新：\n$$\nE_t = E_{t-1} + \\eta_{\\text{ch}} \\cdot \\max(0, -S_t) - \\frac{1}{\\eta_{\\text{dis}}} \\cdot \\max(0, S_t),\n$$\n$$\n0 \\leq E_t \\leq E_{\\text{cap}}.\n$$\n设初始状态为$E_0 = E_{\\text{init}} = 0.5 E_{\\text{cap}}$。\n\n3. 爬坡需求和启发式平滑。将储能动作后的剩余净需求定义为\n$$\nR^{\\text{res}}_t = D_t - S_t.\n$$\n将发电机的每小时爬坡需求幅度定义为\n$$\n\\Delta_t = \\left|R^{\\text{res}}_t - R^{\\text{res}}_{t-1}\\right| \\quad \\text{for } t \\geq 1.\n$$\n设发电机的爬坡限制为$R_{\\max}$（单位$\\mathrm{MW}$/小时）。当$\\Delta_t > R_{\\max}$时，发生爬坡超限事件。为了在不求解优化问题的情况下模拟储能对运行爬坡的平滑作用，使用以下基于物理动机的启发式目标，该目标基于净需求的离散时间导数：\n$$\nS^{\\star}_t = -\\alpha \\cdot (D_t - D_{t-1}) \\quad \\text{for } t \\geq 1,\n$$\n且$S^{\\star}_0 = 0$，其中$\\alpha \\in [0,1]$是爬坡抵消系数。实际的$S_t$通过在每个小时顺序地将第2项中的功率和状态约束应用于$S^{\\star}_t$来获得，确保$E_t$保持在$[0, E_{\\text{cap}}]$范围内。\n\n4. 代表日建模结构。在投资型聚合运行模型中，年份由一组具有相关整数权重的代表日来近似，并舍弃跨天的时间顺序联系。设代表日集合为$\\{(d_i, w_i)\\}_{i=1}^K$，其中$d_i$是日期索引，$w_i$是其权重，且$\\sum_{i=1}^K w_i = 365$。对于代表日模型，每天都使用相同的设备约束独立模拟，并在每天开始时设置$E_{\\text{init}}$，并且$E_t$不在天与天之间传递。日内爬坡需求是基于每天23个日内转换计算的。使用加权聚合来形成年度指标。\n\n5. 需要计算和报告的验证指标。使用全年时序模型和代表日模型，计算以下验证指标：\n- 储能等效循环绝对误差：\n$$\n\\varepsilon_{\\text{cycles}} = \\left|\\frac{1}{2 E_{\\text{cap}}} \\sum_{t=0}^{T-1} \\left(\\eta_{\\text{ch}} \\cdot \\max(0, -S_t) + \\frac{1}{\\eta_{\\text{dis}}} \\cdot \\max(0, S_t)\\right) - \\frac{1}{2 E_{\\text{cap}}} \\sum_{\\text{rep days}} w_i \\sum_{h=0}^{23} \\left(\\eta_{\\text{ch}} \\cdot \\max(0, -S^{\\text{rep}}_{d_i,h}) + \\frac{1}{\\eta_{\\text{dis}}} \\cdot \\max(0, S^{\\text{rep}}_{d_i,h})\\right) \\right|.\n$$\n- 爬坡超限率绝对误差，其中全年超限率为\n$$\n\\rho_{\\text{full}} = \\frac{1}{T-1} \\sum_{t=1}^{T-1} \\mathbf{1}\\left(\\left|R^{\\text{res}}_t - R^{\\text{res}}_{t-1}\\right|  R_{\\max}\\right),\n$$\n代表日超限率为\n$$\n\\rho_{\\text{rep}} = \\frac{1}{\\sum_i w_i \\cdot 23} \\sum_{i=1}^K w_i \\sum_{h=1}^{23} \\mathbf{1}\\left(\\left|R^{\\text{res,rep}}_{d_i,h} - R^{\\text{res,rep}}_{d_i,h-1}\\right|  R_{\\max}\\right),\n$$\n误差为 $\\varepsilon_{\\text{ramp}} = \\left|\\rho_{\\text{rep}} - \\rho_{\\text{full}}\\right|$。\n- 全年模型与加权代表日模型的剩余爬坡幅度经验累积分布函数之间的柯尔莫哥洛夫-斯米尔诺夫（KS）距离，两者都考虑幅度单位为$\\mathrm{MW}$/小时：\n$$\n\\varepsilon_{\\text{KS}} = \\sup_{x \\ge 0} \\left| F_{\\text{full}}(x) - F_{\\text{rep}}(x) \\right|,\n$$\n其中$F_{\\text{full}}(x)$是$\\{\\Delta_t\\}_{t=1}^{T-1}$的经验累积分布函数，$F_{\\text{rep}}(x)$是代表日集合中日内幅度加权多重集的经验累积分布函数。\n\n所有指标必须表示为十进制浮点数，四舍五入到小数点后四位。最终的数值输出不需要物理单位，因为这些指标是无量纲的，尽管其内部构建使用了$\\mathrm{MW}$、$\\mathrm{MWh}$和$\\mathrm{MW}$/小时。\n\n6. 测试套件。在以下测试用例上评估程序，每个用例由$(\\text{rep set}, R_{\\max}, E_{\\text{cap}}, P_{\\text{ch}}, P_{\\text{dis}}, \\eta_{\\text{ch}}, \\eta_{\\text{dis}}, \\alpha)$指定：\n- 测试 1 (季节性覆盖，理想情况):\n$$\n\\text{rep set} = \\{(20, 91), (110, 91), (200, 91), (290, 92)\\}, \\quad R_{\\max} = 12, \\quad E_{\\text{cap}} = 200, \\quad P_{\\text{ch}} = 50, \\quad P_{\\text{dis}} = 50, \\quad \\eta_{\\text{ch}} = 0.92, \\quad \\eta_{\\text{dis}} = 0.92, \\quad \\alpha = 0.8.\n$$\n- 测试 2 (单一平均日，可能对极端情况代表性不足):\n$$\n\\text{rep set} = \\{(180, 365)\\}, \\quad R_{\\max} = 12, \\quad E_{\\text{cap}} = 200, \\quad P_{\\text{ch}} = 50, \\quad P_{\\text{dis}} = 50, \\quad \\eta_{\\text{ch}} = 0.92, \\quad \\eta_{\\text{dis}} = 0.92, \\quad \\alpha = 0.8.\n$$\n- 测试 3 (严格的爬坡限制，对时序性更敏感):\n$$\n\\text{rep set} = \\{(20, 91), (110, 91), (200, 91), (290, 92)\\}, \\quad R_{\\max} = 4, \\quad E_{\\text{cap}} = 200, \\quad P_{\\text{ch}} = 50, \\quad P_{\\text{dis}} = 50, \\quad \\eta_{\\text{ch}} = 0.92, \\quad \\eta_{\\text{dis}} = 0.92, \\quad \\alpha = 0.8.\n$$\n- 测试 4 (小储能容量边界):\n$$\n\\text{rep set} = \\{(60, 122), (120, 121), (240, 122)\\}, \\quad R_{\\max} = 12, \\quad E_{\\text{cap}} = 20, \\quad P_{\\text{ch}} = 50, \\quad P_{\\text{dis}} = 50, \\quad \\eta_{\\text{ch}} = 0.92, \\quad \\eta_{\\text{dis}} = 0.92, \\quad \\alpha = 0.8.\n$$\n\n7. 要求的最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的指标以$[\\varepsilon_{\\text{cycles}}, \\varepsilon_{\\text{ramp}}, \\varepsilon_{\\text{KS}}]$的顺序给出，并四舍五入到小数点后四位。例如，输出格式必须是\n$$\n\\big[\\,[m_{1,1}, m_{1,2}, m_{1,3}], [m_{2,1}, m_{2,2}, m_{2,3}], [m_{3,1}, m_{3,2}, m_{3,3}], [m_{4,1}, m_{4,2}, m_{4,3}]\\,\\big],\n$$\n其中$m_{i,j}$是测试$i$和指标$j$的十进制浮点数，根据上述定义计算。",
            "solution": "用户提供了一个在能源系统建模领域科学合理且定义明确的问题陈述。所有提供的定义、约束和参数都清晰、自洽且逻辑一致。该问题是有效的，可以按所述方式解决。\n\n核心任务是量化使用代表日建模方法（而非全时序模拟）所引入的误差。这是能源系统规划中的一个基本权衡，代表日模型以牺牲保真度为代价提供了计算上的易处理性，特别是对于包含储能等有状态组件的系统。本分析将重点关注受时序信息丢失影响的两个关键运行方面：储能循环和发电机爬坡。\n\n解决方案通过以下步骤实现：\n1.  首先，我们为全年（$T = 8760$小时）生成电力负荷（$L_{d,h}$）、可变可再生能源（$R_{d,h}$）和由此产生的净需求（$D_t$）的基本小时时间序列。\n2.  接下来，我们执行一个全时序模拟。这涉及按时间顺序模拟储能设备在全年的行为。储能调度由一个旨在平滑净需求曲线的启发式算法确定。\n3.  然后，我们使用代表日结构进行模拟。对于每个代表日，独立模拟一个24小时的调度，储能荷电状态在每天开始时重置。通过对每个代表日的结果进行加权来汇编年度结果。\n4.  最后，我们计算三个验证指标来比较两个模型的结果：总储能循环数的绝对误差（$\\varepsilon_{\\text{cycles}}$）、爬坡限制超限率的绝对误差（$\\varepsilon_{\\text{ramp}}$）以及剩余爬坡幅度分布之间的柯尔莫哥洛夫-斯米尔诺夫距离（$\\varepsilon_{\\text{KS}}$）。\n\n### 1. 时间序列生成\n分析基于一年的合成确定性时间序列，共$T = 365 \\cdot 24 = 8760$小时。时间索引为$t = 24d + h$，其中$d \\in \\{0, \\dots, 364\\}$是天，$h \\in \\{0, \\dots, 23\\}$是小时。\n\n电力负荷$L_{d,h}$定义为：\n$$\nL_{d,h} = 80 + 12 \\sin\\left(\\frac{2\\pi h}{24} - \\frac{\\pi}{3}\\right) + 8 \\sin\\left(\\frac{2\\pi d}{365}\\right)\n$$\n该函数结合了一个在下午达到峰值的日正弦模式和一个季节性正弦模式。\n\n可变可再生能源（VRE）发电量$R_{d,h}$是太阳能和风能部分的和：\n$$\n\\text{Solar}_{d,h} = 25 \\cdot \\max\\left(0, \\sin\\left(\\frac{2\\pi (h-6)}{24}\\right)\\right) \\cdot \\left(1 + 0.3 \\cos\\left(\\frac{2\\pi d}{365}\\right)\\right)\n$$\n$$\n\\text{Wind}_{d,h} = 15 + 6 \\cos\\left(\\frac{2\\pi d}{365} + 0.5\\right) + 3 \\sin\\left(\\frac{2\\pi h}{24} + 0.2\\right)\n$$\n$$\nR_{d,h} = \\text{Solar}_{d,h} + \\text{Wind}_{d,h}\n$$\n太阳能部分模拟了白天的发电情况，并带有峰值输出的季节性变化。风能部分则包括了季节性和日内波动。\n\n必须由可调度发电机和储能满足的净需求$D_{d,h}$是负荷减去VRE发电量：\n$$\nD_{d,h} = L_{d,h} - R_{d,h}\n$$\n这被平展成一个单一的时序向量$\\{D_t\\}_{t=0}^{T-1}$。\n\n### 2. 储能调度模拟\n模型中有一个单一的储能设备。其运行受其能量容量$E_{\\text{cap}}$、充放电功率限制（$P_{\\text{ch}}$和$P_{\\text{dis}}$）以及往返效率（$\\eta_{\\text{ch}}, \\eta_{\\text{dis}}$）的支配。储能向电网的注入功率为$S_t$（$S_t>0$为放电，$S_t0$为充电）。\n\n调度启发式算法旨在平滑净需求的爬坡。目标储能注入功率$S^{\\star}_t$与净需求的时间负梯度成正比：\n$$\nS^{\\star}_t = -\\alpha \\cdot (D_t - D_{t-1}) \\quad \\text{for } t \\geq 1, \\text{ with } S^{\\star}_0 = 0\n$$\n其中$\\alpha$是爬坡抵消系数。\n\n这个目标调度$S^{\\star}_t$可能不可行。实际调度功率$S_t$是通过依次应用设备的物理约束得到的。在每个小时$t$，给定前一小时的荷电状态$E_{t-1}$，确定可行的调度范围：\n最大放电功率受设备额定功率和可用能量的限制：\n$$\nP^{\\text{max\\_dis}}_t = \\min\\left(P_{\\text{dis}}, E_{t-1} \\cdot \\eta_{\\text{dis}}\\right)\n$$\n最大充电功率受设备额定功率和可用存储空间的限制：\n$$\nP^{\\text{max\\_ch}}_t = \\min\\left(P_{\\text{ch}}, \\frac{E_{\\text{cap}} - E_{t-1}}{\\eta_{\\text{ch}}}\\right)\n$$\n实际调度功率$S_t$是目标值$S^{\\star}_t$被裁剪到可行范围$[-P^{\\text{max\\_ch}}_t, P^{\\text{max\\_dis}}_t]$内的结果：\n$$\nS_t = \\max(-P^{\\text{max\\_ch}}_t, \\min(P^{\\text{max\\_dis}}_t, S^{\\star}_t))\n$$\n一旦确定了$S_t$，就更新荷电状态以用于下一个时间步：\n$$\nE_t = E_{t-1} + \\eta_{\\text{ch}} \\cdot \\max(0, -S_t) - \\frac{1}{\\eta_{\\text{dis}}} \\cdot \\max(0, S_t)\n$$\n此模拟分别针对全时序年和每个单独的代表日进行。对于全年， $E_0 = 0.5 E_{\\text{cap}}$，状态按时间顺序演变。对于代表日模型，对每个24小时周期运行模拟，每天开始时都设$E_{0, \\text{day}} = 0.5 E_{\\text{cap}}$。\n\n### 3. 验证指标\n两个模型之间的比较通过三个指标来量化。\n\n**储能等效循环误差（$\\varepsilon_{\\text{cycles}}$）：** 该指标衡量储能设备处理的总能量的差异。一个等效循环定义为电池容量的一次完全充电和放电。总吞吐量是全年流入和流出电池的能量总和。\n$$\n\\text{Total Throughput} = \\sum_t \\left(\\eta_{\\text{ch}} \\cdot \\max(0, -S_t) + \\frac{1}{\\eta_{\\text{dis}}} \\cdot \\max(0, S_t)\\right)\n$$\n$$\n\\text{Cycles} = \\frac{\\text{Total Throughput}}{2 E_{\\text{cap}}}\n$$\n误差$\\varepsilon_{\\text{cycles}}$是根据全时序模拟计算的循环数与代表日模型计算的加权平均循环数之间的绝对差。\n$$\n\\varepsilon_{\\text{cycles}} = \\left| \\text{Cycles}_{\\text{full}} - \\text{Cycles}_{\\text{rep}} \\right|\n$$\n\n**爬坡超限率误差（$\\varepsilon_{\\text{ramp}}$）：** 该指标评估模型预测极端爬坡事件的能力。剩余净需求为$R^{\\text{res}}_t = D_t - S_t$。如果小时变化$|R^{\\text{res}}_t - R^{\\text{res}}_{t-1}|$大于发电机爬坡限制$R_{\\max}$，则发生爬坡超限。超限率是发生这种情况的时间间隔的比例。\n$$\n\\rho_{\\text{full}} = \\frac{1}{T-1} \\sum_{t=1}^{T-1} \\mathbf{1}\\left(|R^{\\text{res}}_t - R^{\\text{res}}_{t-1}| > R_{\\max}\\right)\n$$\n对于代表日模型，只考虑日内爬坡，速率是一个加权平均值：\n$$\n\\rho_{\\text{rep}} = \\frac{\\sum_{i=1}^K w_i \\sum_{h=1}^{23} \\mathbf{1}\\left(|R^{\\text{res,rep}}_{d_i,h} - R^{\\text{res,rep}}_{d_i,h-1}| > R_{\\max}\\right)}{\\sum_{i=1}^K w_i \\cdot 23}\n$$\n误差是绝对差：$\\varepsilon_{\\text{ramp}} = \\left|\\rho_{\\text{rep}} - \\rho_{\\text{full}}\\right|$。\n\n**柯尔莫哥洛夫-斯米尔诺夫（KS）距离（$\\varepsilon_{\\text{KS}}$）：** 该指标提供了对剩余爬坡幅度整个分布的更全面比较，而不仅仅是尾部。它是全模型爬坡幅度$F_{\\text{full}}(x)$和代表日模型$F_{\\text{rep}}(x)$的经验累积分布函数（CDF）之间的最大绝对差。\n$$\n\\varepsilon_{\\text{KS}} = \\sup_{x \\ge 0} \\left| F_{\\text{full}}(x) - F_{\\text{rep}}(x) \\right|\n$$\n为了计算这个值，我们将来自全时序模拟的$T-1$个爬坡集合视为一个样本。第二个样本由代表日模型构建，方法是取每个代表日$d_i$的日内爬坡，并根据其在年中的权重$w_i$重复它们$w_i$次。然后在这两个样本之间计算KS距离。\n\n### 4. 实现设计\n该解决方案使用 Python 实现，利用`numpy`库进行高效的数值计算，并使用`scipy.stats.ks_2samp`计算 KS 距离。一个核心函数`run_dispatch_simulation`封装了储能调度逻辑，并被用于全时序序列和每个24小时的代表日周期。主函数遍历提供的测试用例，参数化模拟，运行两种模型类型，计算三个误差指标，并按规定格式化输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import ks_2samp\n\ndef run_dispatch_simulation(net_demand, E_cap, P_ch, P_dis, eta_ch, eta_dis, alpha, E_init_frac):\n    \"\"\"\n    Simulates storage dispatch over a given net demand series.\n\n    Args:\n        net_demand (np.ndarray): The net demand time series.\n        E_cap (float): Storage energy capacity (MWh).\n        P_ch (float): Storage charging power limit (MW).\n        P_dis (float): Storage discharging power limit (MW).\n        eta_ch (float): Charging efficiency.\n        eta_dis (float): Discharging efficiency.\n        alpha (float): Ramp-cancellation fraction.\n        E_init_frac (float): Initial state of charge as a fraction of E_cap.\n\n    Returns:\n        tuple: A tuple containing:\n            - S (np.ndarray): Storage injection series (MW).\n            - E (np.ndarray): State of charge series (MWh).\n    \"\"\"\n    T = len(net_demand)\n    S = np.zeros(T)\n    E = np.zeros(T + 1)\n    E[0] = E_init_frac * E_cap\n\n    # Calculate target dispatch based on net demand derivative\n    S_star = np.zeros(T)\n    S_star[1:] = -alpha * (net_demand[1:] - net_demand[:-1])\n\n    for t in range(T):\n        # Calculate state-of-charge dependent power limits\n        E_prev = E[t]\n        \n        # Max discharge power check\n        # discharge power S_t  0, energy change is -S_t/eta_dis, so E_t = E_prev - S_t/eta_dis.\n        # E_t = 0 - E_prev = S_t/eta_dis - S_t = E_prev * eta_dis\n        max_dis_power_soc = E_prev * eta_dis\n        \n        # Max charge power check\n        # charge power -S_t  0, energy change is -S_t * eta_ch, so E_t = E_prev - S_t * eta_ch\n        # E_t = E_cap - E_prev - S_t * eta_ch = E_cap - -S_t = (E_cap - E_prev) / eta_ch\n        max_ch_power_soc = (E_cap - E_prev) / eta_ch\n        \n        # Combine with device power ratings\n        P_dis_t = min(P_dis, max_dis_power_soc)\n        P_ch_t = min(P_ch, max_ch_power_soc)\n\n        # Clip target dispatch to feasible range\n        S[t] = max(-P_ch_t, min(P_dis_t, S_star[t]))\n\n        # Update state of charge\n        charge_power = max(0, -S[t])\n        discharge_power = max(0, S[t])\n        E[t+1] = E[t] + eta_ch * charge_power - (1 / eta_dis) * discharge_power\n\n    return S, E[:-1] # Return S and E of same length as demand\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        ({'rep_set': [(20, 91), (110, 91), (200, 91), (290, 92)], 'R_max': 12, 'E_cap': 200, 'P_ch': 50, 'P_dis': 50, 'eta_ch': 0.92, 'eta_dis': 0.92, 'alpha': 0.8}),\n        ({'rep_set': [(180, 365)], 'R_max': 12, 'E_cap': 200, 'P_ch': 50, 'P_dis': 50, 'eta_ch': 0.92, 'eta_dis': 0.92, 'alpha': 0.8}),\n        ({'rep_set': [(20, 91), (110, 91), (200, 91), (290, 92)], 'R_max': 4, 'E_cap': 200, 'P_ch': 50, 'P_dis': 50, 'eta_ch': 0.92, 'eta_dis': 0.92, 'alpha': 0.8}),\n        ({'rep_set': [(60, 122), (120, 121), (240, 122)], 'R_max': 12, 'E_cap': 20, 'P_ch': 50, 'P_dis': 50, 'eta_ch': 0.92, 'eta_dis': 0.92, 'alpha': 0.8})\n    ]\n\n    # Time series generation\n    days = 365\n    hours_per_day = 24\n    T = days * hours_per_day\n    \n    t_hr = np.arange(T)\n    d = t_hr // hours_per_day\n    h = t_hr % hours_per_day\n\n    L_t = 80 + 12 * np.sin(2 * np.pi * h / 24 - np.pi / 3) + 8 * np.sin(2 * np.pi * d / 365)\n    Solar_t = 25 * np.maximum(0, np.sin(2 * np.pi * (h - 6) / 24)) * (1 + 0.3 * np.cos(2 * np.pi * d / 365))\n    Wind_t = 15 + 6 * np.cos(2 * np.pi * d / 365 + 0.5) + 3 * np.sin(2 * np.pi * h / 24 + 0.2)\n    R_t = Solar_t + Wind_t\n    D_t = L_t - R_t\n\n    results = []\n    for params in test_cases:\n        p = params\n        rep_set, R_max, E_cap, P_ch, P_dis, eta_ch, eta_dis, alpha = \\\n            p['rep_set'], p['R_max'], p['E_cap'], p['P_ch'], p['P_dis'], p['eta_ch'], p['eta_dis'], p['alpha']\n        \n        # 1. Full Chronological Simulation\n        S_full, _ = run_dispatch_simulation(D_t, E_cap, P_ch, P_dis, eta_ch, eta_dis, alpha, 0.5)\n        \n        # Full year metrics\n        throughput_full = np.sum(eta_ch * np.maximum(0, -S_full) + (1 / eta_dis) * np.maximum(0, S_full))\n        cycles_full = throughput_full / (2 * E_cap)\n\n        R_res_full = D_t - S_full\n        ramps_full = np.abs(R_res_full[1:] - R_res_full[:-1])\n        exceedances_full = np.sum(ramps_full  R_max)\n        rho_full = exceedances_full / (T - 1)\n\n        # 2. Representative Day Simulation\n        total_rep_throughput = 0\n        total_rep_exceedances = 0\n        all_rep_ramps = []\n        all_rep_weights = []\n\n        for day_idx, weight in rep_set:\n            start_t = day_idx * hours_per_day\n            end_t = start_t + hours_per_day\n            D_day = D_t[start_t:end_t]\n\n            S_day, _ = run_dispatch_simulation(D_day, E_cap, P_ch, P_dis, eta_ch, eta_dis, alpha, 0.5)\n            \n            throughput_day = np.sum(eta_ch * np.maximum(0, -S_day) + (1 / eta_dis) * np.maximum(0, S_day))\n            total_rep_throughput += throughput_day * weight\n\n            R_res_day = D_day - S_day\n            ramps_day = np.abs(R_res_day[1:] - R_res_day[:-1])\n            exceedances_day = np.sum(ramps_day  R_max)\n            total_rep_exceedances += exceedances_day * weight\n            \n            all_rep_ramps.extend(ramps_day)\n            all_rep_weights.extend([weight] * len(ramps_day))\n        \n        cycles_rep = total_rep_throughput / (2 * E_cap)\n        total_weighted_intervals = sum(w for _, w in rep_set) * (hours_per_day - 1)\n        rho_rep = total_rep_exceedances / total_weighted_intervals\n\n        # 3. Calculate Error Metrics\n        eps_cycles = abs(cycles_full - cycles_rep)\n        eps_ramp = abs(rho_full - rho_rep)\n        \n        # For KS-test, expand the representative sample using weights\n        ramps_rep_expanded = np.repeat(all_rep_ramps, all_rep_weights)\n        ks_stat, _ = ks_2samp(ramps_full, ramps_rep_expanded)\n        eps_ks = ks_stat\n        \n        results.append([eps_cycles, eps_ramp, eps_ks])\n\n    # Format the final output string\n    formatted_sublists = []\n    for res in results:\n        formatted_sublists.append(f\"[{res[0]:.4f},{res[1]:.4f},{res[2]:.4f}]\")\n    final_output = f\"[[{','.join(formatted_sublists)}]]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}