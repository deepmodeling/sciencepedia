{
    "hands_on_practices": [
        {
            "introduction": "本练习构成了任何长期能源投资模型的财务支柱。我们将从基本原则出发，构建一个净现成本 (Net Present Cost, NPC) 目标函数，学习如何使用贴现方法来恰当核算和比较发生在不同时间点的成本。掌握这项技能是做出经济上合理的投资决策的第一步。",
            "id": "4099352",
            "problem": "考虑一个能源系统建模中的程式化容量扩展问题，该问题汇总了多年规划期内的投资支出和运营支出。目标是基于第一性原理，以折现现金流为基础，构建一个综合目标函数，用于评估与投资和运营相关的所有现金流的净现值。您的程序必须从金融数学的基本原理出发，实现以下内容。\n\n基本原理：对于在年份 $y$ 发生的未来现金流，其相对于基准年份 $y_0$ 和恒定年折现率 $r$ 的现值，由该现金流与特定年份折现因子 $d_y$ 的乘积给出，其中 $d_y$ 定义为\n$$\nd_y = (1 + r)^{-(y - y_0)}.\n$$\n该定义直接源于货币时间价值原理，即通过折现将未来价值转换为其等效的现值。容量扩展建模的目标是评估每年投资支出和运营支出的总和的净现值，使用 $d_y$ 将所有价值对齐到基准年份 $y_0$。资本支出 (Capital Expenditure, CAPEX) 和运营支出 (Operational Expenditure, OPEX) 定义如下：\n- 资本支出 (CAPEX) 是每项技术 $i$ 的年化投资现金流，在年份 $y$ 表示为 $\\text{CAPEX}_{i,y}$。\n- 运营支出 (OPEX) 是年份 $y$ 内每个年内时间步 $t$ 的运营现金流，对于 $t \\in \\mathcal{T}_y$ 表示为 $\\text{OPEX}_t$，其中 $\\mathcal{T}_y$ 是年份 $y$ 内的时间步集合。\n\n您的任务是实现净现成本目标函数。对于每年 $y$，该函数汇总 $\\sum_{i} \\text{CAPEX}_{i,y}$ 和 $\\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t$，并应用从上述基本原理推导出的折现因子 $d_y$。$d_y$ 的作用是为每年的总现金流加权，使得根据折现率 $r$，较晚年份的金额对目标值的贡献较小。最终目标是规划期内所有年份的这些折现后年度总和的总计。\n\n单位：每个现金流 $\\text{CAPEX}_{i,y}$ 和 $\\text{OPEX}_t$ 均以百万货币单位提供。您的程序必须以百万货币单位输出目标值，格式为浮点数。不要包含任何货币符号。如果需要分数，请使用小数表示。\n\n测试套件：实现您的程序，为以下各种情况计算目标值，每种情况都以参数集的形式给出。在每种情况下，使用 $d_y = (1 + r)^{-(y - y_0)}$ 将年度总和折现至基准年份 $y_0$。\n\n情况 $1$（一般情况，涉及多种技术、多个年份和季度性运营步骤）：\n- 基准年份 $y_0$：$2025$。\n- 年份 $\\mathcal{Y}$：$[2025, 2026, 2027]$。\n- 折现率 $r$：$0.07$。\n- 技术排序为 $\\text{CCGT}$、$\\text{Wind}$、$\\text{Battery}$。\n- 按年份列出的 $\\text{CAPEX}$（列表顺序对应技术）：\n  - 在 $2025$ 年：$[300, 200, 100]$。\n  - 在 $2026$ 年：$[0, 150, 50]$。\n  - 在 $2027$ 年：$[0, 0, -20]$。\n- 按年份列出的 $\\text{OPEX}$（每年的季度值）：\n  - 在 $2025$ 年：$[50, 48, 52, 50]$。\n  - 在 $2026$ 年：$[55, 60, 58, 57]$。\n  - 在 $2027$ 年：$[62, 64, 63, 65]$。\n\n情况 $2$（边界情况，折现率为零且运营成本为零）：\n- 基准年份 $y_0$：$2030$。\n- 年份 $\\mathcal{Y}$：$[2030, 2031]$。\n- 折现率 $r$：$0$。\n- 技术排序为 $\\text{Solar}$、$\\text{Wind}$。\n- 按年份列出的 $\\text{CAPEX}$：\n  - 在 $2030$ 年：$[120, 80]$。\n  - 在 $2031$ 年：$[0, 40]$。\n- 按年份列出的 $\\text{OPEX}$：\n  - 在 $2030$ 年：$[0, 0, 0]$。\n  - 在 $2031$ 年：$[0, 0, 0]$。\n\n情况 $3$（边缘情况，高折现率、月度运营步骤以及在最后一年有残值抵免）：\n- 基准年份 $y_0$：$2024$。\n- 年份 $\\mathcal{Y}$：$[2024, 2025, 2026, 2027, 2028]$。\n- 折现率 $r$：$0.15$。\n- 技术排序为 $\\text{Nuclear}$、$\\text{Wind}$。\n- 按年份列出的 $\\text{CAPEX}$：\n  - 在 $2024$ 年：$[1000, 0]$。\n  - 在 $2025$ 年：$[0, 200]$。\n  - 在 $2026$ 年：$[500, 0]$。\n  - 在 $2027$ 年：$[0, 200]$。\n  - 在 $2028$ 年：$[-100, 0]$。\n- 按年份列出的 $\\text{OPEX}$（每年的月度值）：\n  - 在 $2024$ 年：$[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]$。\n  - 在 $2025$ 年：$[12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5]$。\n  - 在 $2026$ 年：$[13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333]$。\n  - 在 $2027$ 年：$[14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667]$。\n  - 在 $2028$ 年：$[15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]$。\n\n情况 $4$（边缘情况，无投资决策和季节性运营步骤）：\n- 基准年份 $y_0$：$2020$。\n- 年份 $\\mathcal{Y}$：$[2020]$。\n- 折现率 $r$：$0.05$。\n- 技术集为空（无 $\\text{CAPEX}$ 现金流）。\n- 按年份列出的 $\\text{CAPEX}$：\n  - 在 $2020$ 年：$[]$。\n- 按年份列出的 $\\text{OPEX}$（当年的季节值）：\n  - 在 $2020$ 年：$[25, 25, 25, 25]$。\n\n您的程序必须使用上述原理和数据计算每种情况的净现成本目标值。输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[x_1, x_2, x_3, x_4]$，其中每个 $x_k$ 是为情况 $k$ 计算出的目标值，以百万货币单位表示的浮点数。输出必须仅为一行，不含任何额外文本。",
            "solution": "该问题要求为程式化的能源系统容量扩展问题构建并实现一个净现成本 (NPC) 目标函数。此目标函数的基础是折现现金流 (DCF) 原理，这是金融数学的基石，用于比较在不同时间点发生的现金流。\n\n其核心原理是，未来的现金流价值低于今天收到的相同数额的现金流。这种货币时间价值通过折现率 $r$ 来量化。发生在未来年份 $y$ 的现金流，通过乘以一个折现因子 $d_y$，被转换为其在基准年份 $y_0$ 的现值。根据规定，折现因子定义为：\n$$\nd_y = (1 + r)^{-(y - y_0)}\n$$\n此公式表明，对于正折现率 $r > 0$，$d_y$ 的值随着时间差 $(y - y_0)$ 的增加而减小，意味着越是未来的现金流，其价值越低。\n\n在规划期内的任何给定年份 $y$ 的总成本是所有投资（资本）支出和运营支出的总和。设 $C_y$ 为年份 $y$ 的未折现总现金流。它由所有技术 $i$ 的资本支出 (CAPEX) 总和，以及所有年内时间步 $t \\in \\mathcal{T}_y$ 的运营支出 (OPEX) 总和构成：\n$$\nC_y = \\left( \\sum_{i} \\text{CAPEX}_{i,y} \\right) + \\left( \\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t \\right)\n$$\n在此，$\\text{CAPEX}_{i,y}$ 表示技术 $i$ 在年份 $y$ 的投资成本，而 $\\text{OPEX}_t$ 表示年份 $y$ 内特定时间步 $t$ 的运营成本。负现金流，例如负的 $\\text{CAPEX}$，代表一笔信用或收入，例如来自退役资产的残值。\n\n总体目标是计算净现成本 (NPC)，即规划期 $\\mathcal{Y}$ 内所有年份 $y$ 的折现后年度成本的总和。通过将折现因子 $d_y$ 应用于每年的总成本 $C_y$，我们将所有成本对齐到基准年份 $y_0$ 这个共同的参考点。因此，完整的目标函数是：\n$$\n\\text{NPC} = \\sum_{y \\in \\mathcal{Y}} d_y \\cdot C_y = \\sum_{y \\in \\mathcal{Y}} (1 + r)^{-(y - y_0)} \\left( \\left( \\sum_{i} \\text{CAPEX}_{i,y} \\right) + \\left( \\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t \\right) \\right)\n$$\n程序化实现直接遵循此公式。设计一个算法来处理每个测试用例，执行以下步骤：\n1. 将总净现成本 $\\text{NPC}$ 初始化为 $0$。\n2. 对于指定规划期 $\\mathcal{Y}$ 中的每一年 $y$：\n    a. 通过对该年提供的 $\\text{CAPEX}$ 列表中的所有元素求和，计算年份 $y$ 的总资本支出。对于空的技术集，此和为 $0$。\n    b. 通过对该年提供的 $\\text{OPEX}$ 列表中的所有元素求和，计算年份 $y$ 的总运营支出。\n    c. 将步骤 2a 和 2b 的结果相加，得到年份 $y$ 的未折现总成本 $C_y$。\n    d. 使用给定的折现率 $r$、当前年份 $y$ 和基准年份 $y_0$ 计算折现因子 $d_y = (1 + r)^{-(y - y_0)}$。\n    e. 将年度总成本 $C_y$ 乘以折现因子 $d_y$，得到年份 $y$ 的折现成本。\n    f. 将此折现成本加到 $\\text{NPC}$ 的运行总和中。\n3. 在遍历完规划期内的所有年份后，最终累计值即为该情况下的 $\\text{NPC}$。\n\n此过程被系统地应用于四个测试用例中的每一个，使用它们各自的年份、折现率和现金流参数来计算最终的目标值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present cost for a series of energy system investment cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"y0\": 2025,\n            \"years\": [2025, 2026, 2027],\n            \"r\": 0.07,\n            \"capex_data\": {2025: [300, 200, 100], 2026: [0, 150, 50], 2027: [0, 0, -20]},\n            \"opex_data\": {2025: [50, 48, 52, 50], 2026: [55, 60, 58, 57], 2027: [62, 64, 63, 65]},\n        },\n        {\n            \"y0\": 2030,\n            \"years\": [2030, 2031],\n            \"r\": 0.0,\n            \"capex_data\": {2030: [120, 80], 2031: [0, 40]},\n            \"opex_data\": {2030: [0, 0, 0], 2031: [0, 0, 0]},\n        },\n        {\n            \"y0\": 2024,\n            \"years\": [2024, 2025, 2026, 2027, 2028],\n            \"r\": 0.15,\n            \"capex_data\": {2024: [1000, 0], 2025: [0, 200], 2026: [500, 0], 2027: [0, 200], 2028: [-100, 0]},\n            \"opex_data\": {\n                2024: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10],\n                2025: [12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5],\n                2026: [13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333],\n                2027: [14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667],\n                2028: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],\n            },\n        },\n        {\n            \"y0\": 2020,\n            \"years\": [2020],\n            \"r\": 0.05,\n            \"capex_data\": {2020: []},\n            \"opex_data\": {2020: [25, 25, 25, 25]},\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        y0 = case[\"y0\"]\n        years = case[\"years\"]\n        r = case[\"r\"]\n        capex_data = case[\"capex_data\"]\n        opex_data = case[\"opex_data\"]\n        \n        total_npc = 0.0\n        \n        for y in years:\n            # Calculate total undiscounted cost for the year\n            annual_capex = np.sum(capex_data[y])\n            annual_opex = np.sum(opex_data[y])\n            total_annual_cost = annual_capex + annual_opex\n            \n            # Calculate discount factor\n            discount_factor = (1 + r) ** -(y - y0)\n            \n            # Add discounted cost to total NPC\n            total_npc += total_annual_cost * discount_factor\n            \n        results.append(total_npc)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "投资模型关注“是否”以及“建多少”，而运行模型则处理“如何”实时运行系统的问题。本练习探讨爬坡约束，这是一个关键的动态限制，决定了发电机组改变其出力的速度。通过这个练习 ，您将发现为什么仅仅拥有足够的容量是不够的，以及对灵活性资产的投资对于保障系统运行可行性至关重要。",
            "id": "4099394",
            "problem": "考虑一个由技术 $i \\in \\{1,\\dots,N\\}$ 和时间段 $t \\in \\{1,\\dots,T\\}$ 索引的发电系统。设 $p_{i,t}$ 表示技术 $i$ 在时间段 $t$ 的功率调度决策，$x_i$ 表示技术 $i$ 的装机容量，$R_i$ 表示技术 $i$ 每个时间段的最大爬坡能力，$S_i$ 表示技术 $i$ 每个时间段的最大降坡能力，$p_{i,0}$ 表示时间段 $t=1$ 之前的初始调度水平，$d_t$ 表示时间段 $t$ 的电力需求。\n\n从电力系统运行可行性的以下基本基础出发：\n- 每个时间段的功率平衡守恒：$$\\sum_{i=1}^{N} p_{i,t} = d_t \\quad \\text{for all } t \\in \\{1,\\dots,T\\}.$$\n- 每种技术的物理容量边界：$$0 \\le p_{i,t} \\le x_i \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; t \\in \\{1,\\dots,T\\}.$$\n- 表示有限灵活性的跨期爬坡约束：$$p_{i,t} - p_{i,t-1} \\le R_i, \\quad p_{i,t-1} - p_{i,t} \\le S_i \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; t \\in \\{1,\\dots,T\\},$$ 其中约定 $p_{i,0}$ 为给定值。\n\n您的任务是：\n- 将上述爬坡约束明确地构建为线性不等式，并用严谨的术语解释，即使装机容量 $x_i$ 看起来足以满足静态需求水平，投资中灵活性不足（表现为相对于需求变化的 $R_i$ 和 $S_i$ 值较小）如何导致运行不可行的机制。\n- 实现一个程序，在给定一组与投资相关的参数 $\\{x_i,R_i,S_i\\}$、初始条件 $\\{p_{i,0}\\}$ 和需求轨迹 $\\{d_t\\}$ 的情况下，确定是否存在一个满足所有约束的可行调度计划 $\\{p_{i,t}\\}$。该程序必须构建并求解一个线性可行性问题。\n\n使用以下参数集测试套件。每个测试用例指定 $(N,T)$、需求序列 $\\{d_t\\}$、容量 $\\{x_i\\}$、爬坡限制 $\\{R_i\\}$、降坡限制 $\\{S_i\\}$ 和初始输出 $\\{p_{i,0}\\}$。为清晰起见，每个列表均按适用的技术或时间段顺序列出。\n\n- 测试用例 1（一般理想情况）：\n  - $N = 2$, $T = 4$,\n  - $\\{d_t\\} = \\{80, 100, 120, 110\\}$,\n  - $\\{x_i\\} = \\{100, 100\\}$,\n  - $\\{R_i\\} = \\{50, 30\\}$,\n  - $\\{S_i\\} = \\{50, 30\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$。\n  预期的定性行为：可行，因为总爬坡能力可以跟随需求变化。\n\n- 测试用例 2（边界情况，精确匹配爬坡）：\n  - $N = 1$, $T = 6$,\n  - $\\{d_t\\} = \\{20, 40, 60, 80, 100, 120\\}$,\n  - $\\{x_i\\} = \\{120\\}$,\n  - $\\{R_i\\} = \\{20\\}$,\n  - $\\{S_i\\} = \\{20\\}$,\n  - $\\{p_{i,0}\\} = \\{0\\}$。\n  预期的定性行为：可行，爬坡精确匹配需求增量。\n\n- 测试用例 3（容量充足但爬坡能力不足）：\n  - $N = 1$, $T = 2$,\n  - $\\{d_t\\} = \\{0, 50\\}$,\n  - $\\{x_i\\} = \\{120\\}$,\n  - $\\{R_i\\} = \\{10\\}$,\n  - $\\{S_i\\} = \\{120\\}$,\n  - $\\{p_{i,0}\\} = \\{0\\}$。\n  预期的定性行为：不可行，因为所需增加的 $50$ 超过了可用的爬坡能力 $10$。\n\n- 测试用例 4（降坡能力不足导致无法跟随需求下降）：\n  - $N = 1$, $T = 2$,\n  - $\\{d_t\\} = \\{100, 0\\}$,\n  - $\\{x_i\\} = \\{100\\}$,\n  - $\\{R_i\\} = \\{100\\}$,\n  - $\\{S_i\\} = \\{10\\}$,\n  - $\\{p_{i,0}\\} = \\{100\\}$。\n  预期的定性行为：不可行，因为所需减少的 $100$ 超过了可用的降坡能力 $10$。\n\n- 测试用例 5（投资组合缺乏灵活性技术，不可行）：\n  - $N = 2$, $T = 2$,\n  - $\\{d_t\\} = \\{50, 150\\}$,\n  - $\\{x_i\\} = \\{150, 50\\}$,\n  - $\\{R_i\\} = \\{5, 50\\}$,\n  - $\\{S_i\\} = \\{5, 50\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$。\n  预期的定性行为：不可行，因为总爬坡能力 $5 + 50 = 55$ 无法覆盖 $100$ 的需求增长。\n\n- 测试用例 6（容量相同但灵活性投资更高，可行）：\n  - $N = 2$, $T = 2$,\n  - $\\{d_t\\} = \\{50, 150\\}$,\n  - $\\{x_i\\} = \\{150, 50\\}$,\n  - $\\{R_i\\} = \\{50, 50\\}$,\n  - $\\{S_i\\} = \\{50, 50\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$。\n  预期的定性行为：可行，因为总爬坡能力 $50 + 50 = 100$ 正好覆盖了需求增长。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 6 的顺序显示结果，每个条目都是一个布尔值，表示可行性（例如，$\\left[\\text{True},\\text{False},\\dots\\right]$）。输出中不需要物理单位，因为结果是布尔值。算法必须是通用的，并适用于任何现代编程语言；您的最终答案必须是指定的一个完整的可运行程序。",
            "solution": "所提出的问题是一个有效的线性可行性问题，这是能源系统优化领域的一个基本概念。它具有科学依据，定义明确，并且提供了求解所需的所有参数。我们继续进行分析和求解。\n\n该问题要求确定在一个包含 $N$ 种发电技术、$T$ 个时间段的系统中，是否存在一个可行的功率调度计划，该计划由变量集 $\\{p_{i,t}\\}$ 表示。如果一个计划能同时满足三组线性约束：功率平衡、容量限制和跨期爬坡限制，则该计划是可行的。\n\n对于给定的技术 $i$，其爬坡约束由每个时间段 $t \\in \\{1,\\dots,T\\}$ 的两个不等式给出：\n$$p_{i,t} - p_{i,t-1} \\le R_i$$\n$$p_{i,t-1} - p_{i,t} \\le S_i$$\n其中 $p_{i,t}$ 是时间段 $t$ 的功率输出，$p_{i,t-1}$ 是前一个时间段的输出（$p_{i,0}$ 是给定的初始条件），$R_i$ 是最大爬坡率，$S_i$ 是最大降坡率。这些可以合并成一个表达式：\n$$-S_i \\le p_{i,t} - p_{i,t-1} \\le R_i$$\n这个复合不等式表明，技术 $i$ 在连续时间段之间的功率输出变化是受限的。$R_i$ 和 $S_i$ 是发电厂的物理特性，反映了其“灵活性”。例如，一个大型燃煤电厂具有巨大的热惯性，无法快速改变其输出，导致其相对于容量的 $R_i$ 和 $S_i$ 值很小。相反，一个天然气调峰电厂或电池储能系统具有高度灵活性，对应着较大的 $R_i$ 和 $S_i$ 值。建造哪些技术，从而决定系统范围内的 $\\{R_i, S_i\\}$ 值，是一个投资决策。\n\n即使在静态容量充足的情况下，灵活性不足导致运行不可行的机制可以被严格地证明。考虑系统总需求从时间段 $t-1$ 到 $t$ 的变化，即 $d_t - d_{t-1}$。使用功率平衡约束 $\\sum_{i=1}^{N} p_{i,t} = d_t$，我们可以用发电调度来表示这个需求变化：\n$$d_t - d_{t-1} = \\sum_{i=1}^{N} p_{i,t} - \\sum_{i=1}^{N} p_{i,t-1} = \\sum_{i=1}^{N} (p_{i,t} - p_{i,t-1})$$\n从爬坡约束中，我们知道对于每种技术 $i$ 都有 $p_{i,t} - p_{i,t-1} \\le R_i$。将这个不等式对所有技术求和，得到：\n$$\\sum_{i=1}^{N} (p_{i,t} - p_{i,t-1}) \\le \\sum_{i=1}^{N} R_i$$\n通过代入需求变化的表达式，我们得出一个可行性的必要条件：\n$$d_t - d_{t-1} \\le \\sum_{i=1}^{N} R_i$$\n类似地，从降坡约束 $p_{i,t-1} - p_{i,t} \\le S_i$，我们可以推导出：\n$$d_{t-1} - d_t \\le \\sum_{i=1}^{N} S_i$$\n这两个关系表明，整个系统的净需求变化必须小于或等于发电机组的总爬坡或总降坡能力。如果需求增量 $d_t - d_{t-1}$ 大于系统总爬坡能力 $\\sum_i R_i$，那么在数学上就不可能找到一组 $\\{p_{i,t}\\}$ 同时满足爬坡约束和功率平衡约束。这正是一种情况，即一个投资组合，即使其总容量 $\\sum_i x_i$ 远大于峰值需求 $\\max_t d_t$，也可能由于缺乏灵活性而导致运行不可行。\n\n然而，满足这些总爬坡条件是可行性的必要但不充分条件。一个可行的解决方案还必须在每个时间步为每种技术遵守各自的容量边界 $0 \\le p_{i,t} \\le x_i$ 和各自的爬坡约束。例如，一个已经以其最大容量 $x_i$ 运行的发电机，即使其 $R_i$很大，也无法进一步爬坡。因此，系统的可行性是所有约束在整个时间范围内复杂相互作用的结果。在时间段 $t$ 如何调度发电的决策，对时间段 $t+1$ 的可行性具有后续影响。\n\n为了确定地判断可行性，我们必须求解一个线性可行性问题。我们试图在一个高维空间中找到一个能同时满足所有线性约束的点。这个问题的变量是所有 $i \\in \\{1,\\dots,N\\}$ 和 $t \\in \\{1,\\dots,T\\}$ 的调度水平 $p_{i,t}$。让我们定义一个大小为 $N \\times T$ 的单一决策变量向量 $\\mathbf{p}$，通过堆叠所有 $p_{i,t}$ 值得到。问题是找到 $\\mathbf{p}$ 使得：\n1. 等式约束（功率平衡）：$A_{eq}\\mathbf{p} = \\mathbf{b}_{eq}$，其中每一行对应一个时间段 $t$，并强制执行 $\\sum_i p_{i,t} = d_t$。\n2. 不等式约束（爬坡）：$A_{ub}\\mathbf{p} \\le \\mathbf{b}_{ub}$，其中各行对所有 $i,t$ 强制执行 $p_{i,t} - p_{i,t-1} \\le R_i$ 和 $p_{i,t-1} - p_{i,t} \\le S_i$。\n3. 变量边界（容量限制）：$\\mathbf{0} \\le \\mathbf{p} \\le \\mathbf{x}_{stacked}$，其中上界由给定的容量 $x_i$ 导出。\n\n一个标准的线性规划（LP）求解器可以解决这个问题。如果求解器找到了满足所有约束的变量集 $\\mathbf{p}$，则问题是可行的。如果它证明不存在这样的 $\\mathbf{p}$，则问题是不可行的。下面的实现构建了这些矩阵和向量，并使用一个LP求解器来确定每个测试用例的可行性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_feasibility(N, T, d, x, R, S, p0):\n    \"\"\"\n    Formulates and solves a linear feasibility problem for electricity dispatch.\n\n    Args:\n        N (int): Number of technologies.\n        T (int): Number of time periods.\n        d (list): Demand sequence of length T.\n        x (list): Installed capacities of length N.\n        R (list): Ramp-up limits of length N.\n        S (list): Ramp-down limits of length N.\n        p0 (list): Initial dispatch levels of length N.\n\n    Returns:\n        bool: True if a feasible schedule exists, False otherwise.\n    \"\"\"\n    # Total number of decision variables (p_i,t for all i, t)\n    num_vars = N * T\n\n    # The vector of variables is flattened as [p_1,1, ..., p_1,T, p_2,1, ..., p_N,T]\n    # The index for p_i,t is (i-1)*T + (t-1)\n\n    # Objective function: we only seek feasibility, so we can minimize a zero vector.\n    c = np.zeros(num_vars)\n\n    # --- Equality constraints: sum_{i} p_{i,t} = d_t for each t ---\n    # There are T equality constraints.\n    A_eq = np.zeros((T, num_vars))\n    b_eq = np.array(d)\n    for t_idx in range(T):  # t_idx corresponds to t-1\n        for i_idx in range(N):  # i_idx corresponds to i-1\n            var_idx = i_idx * T + t_idx\n            A_eq[t_idx, var_idx] = 1\n\n    # --- Inequality constraints: Ramping ---\n    # There are 2*N*T ramping constraints (one ramp-up, one ramp-down per i,t)\n    num_ineq_constr = 2 * N * T\n    A_ub = np.zeros((num_ineq_constr, num_vars))\n    b_ub = np.zeros(num_ineq_constr)\n    \n    constraint_idx = 0\n    for i_idx in range(N):\n        for t_idx in range(T):\n            var_idx_t = i_idx * T + t_idx\n            \n            # 1. Ramp-up: p_{i,t} - p_{i,t-1} = R_i\n            if t_idx == 0:  # t=1, uses p_{i,0}\n                # p_{i,1} - p_{i,0} = R_i  =>  p_{i,1} = R_i + p_{i,0}\n                A_ub[constraint_idx, var_idx_t] = 1\n                b_ub[constraint_idx] = R[i_idx] + p0[i_idx]\n            else:  # t > 1\n                var_idx_t_minus_1 = i_idx * T + (t_idx - 1)\n                A_ub[constraint_idx, var_idx_t] = 1\n                A_ub[constraint_idx, var_idx_t_minus_1] = -1\n                b_ub[constraint_idx] = R[i_idx]\n            constraint_idx += 1\n\n            # 2. Ramp-down: p_{i,t-1} - p_{i,t} = S_i\n            if t_idx == 0:  # t=1, uses p_{i,0}\n                # p_{i,0} - p_{i,1} = S_i  =>  -p_{i,1} = S_i - p_{i,0}\n                A_ub[constraint_idx, var_idx_t] = -1\n                b_ub[constraint_idx] = S[i_idx] - p0[i_idx]\n            else:  # t > 1\n                var_idx_t_minus_1 = i_idx * T + (t_idx - 1)\n                A_ub[constraint_idx, var_idx_t] = -1\n                A_ub[constraint_idx, var_idx_t_minus_1] = 1\n                b_ub[constraint_idx] = S[i_idx]\n            constraint_idx += 1\n            \n    # --- Variable bounds: 0 = p_{i,t} = x_i ---\n    bounds = []\n    for i_idx in range(N):\n        for _ in range(T):\n            bounds.append((0, x[i_idx]))\n\n    # Solve the linear program\n    # The 'highs' solver is robust and suitable for this feasibility problem.\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    # res.success is True if an optimal solution is found.\n    # For a feasibility problem, this means a feasible solution exists.\n    # If the problem is infeasible, res.status is 2 and res.success is False.\n    return res.success\n\ndef solve():\n    \"\"\"\n    Runs the feasibility check for all test cases provided in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, T, d, x, R, S, p0)\n        (2, 4, [80, 100, 120, 110], [100, 100], [50, 30], [50, 30], [0, 0]),\n        (1, 6, [20, 40, 60, 80, 100, 120], [120], [20], [20], [0]),\n        (1, 2, [0, 50], [120], [10], [120], [0]),\n        (1, 2, [100, 0], [100], [100], [10], [100]),\n        (2, 2, [50, 150], [150, 50], [5, 50], [5, 50], [0, 0]),\n        (2, 2, [50, 150], [150, 50], [50, 50], [50, 50], [0, 0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, d, x, R, S, p0 = case\n        is_feasible = check_feasibility(N, T, d, x, R, S, p0)\n        results.append(is_feasible)\n\n    # The final output must be a single line in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的投资决策是在未来条件（如需求和可再生能源可用性）不确定的情况下做出的。本练习介绍两阶段随机规划，这是一个强大的框架，它将“此时此地”的投资决策与未来“拭目以待”的运行调整正式联系起来。通过解决这个问题 ，您将学习如何做出能够在多种未来情景下都保持稳健的投资选择。",
            "id": "4099405",
            "problem": "考虑一个程式化的单周期电力系统，该系统被建模为一个两阶段随机规划问题。第一阶段决策在不确定性显现之前投资于容量，而第二阶段决策在某个情景揭晓后运营该系统。其物理和经济基础如下：电力平衡要求在每个情景中供给满足需求，容量是发电调度以兆瓦为单位的物理上限，期望成本是随机情景特定成本的概率加权平均值。所使用的基本定义是随机变量的期望值定义和线性容量约束生产。\n\n设第一阶段投资决策由向量 $x = (x_G, x_W)$ 表示，其中 $x_G$ 是可调度发电机的容量，单位为兆瓦（$\\mathrm{MW}$），$x_W$ 是风力发电机的容量，单位为兆瓦（$\\mathrm{MW}$）。资本成本按运营小时摊销，由 $c = (c_G, c_W)$ 给出，单位为美元/兆瓦/小时。对于每个情景 $\\omega$，第二阶段运营决策为 $y(\\omega) = \\big(g_G(\\omega), g_W(\\omega), u(\\omega)\\big)$，其中 $g_G(\\omega)$ 和 $g_W(\\omega)$ 分别是可调度发电机和风力发电机在一小时内的发电调度水平，单位为兆瓦时（$\\mathrm{MWh}$），$u(\\omega)$ 是未满足的需求，单位为兆瓦时（$\\mathrm{MWh}$）。单位兆瓦时的可变成本为 $q = (q_G, q_W, p_U)$，单位为美元/兆瓦时。情景 $\\omega$ 中的需求为 $D(\\omega)$，单位为兆瓦时，风能可用性（容量因子）为 $a_W(\\omega)$，情景概率为 $p(\\omega)$，满足 $\\sum_{\\omega} p(\\omega) = 1$ 和 $p(\\omega) \\ge 0$。\n\n每个情景 $\\omega$ 的第二阶段运营约束如下：\n- 需求平衡：$g_G(\\omega) + g_W(\\omega) + u(\\omega) = D(\\omega)$。\n- 容量限制：$g_G(\\omega) \\le x_G$ 和 $g_W(\\omega) \\le a_W(\\omega) \\, x_W$。\n- 非负性：$g_G(\\omega) \\ge 0$、$g_W(\\omega) \\ge 0$ 和 $u(\\omega) \\ge 0$。\n\n目标是最小化以美元计量的摊销投资成本与期望运营成本之和，即最小化一小时内的期望总成本。您必须使用样本平均近似将此模型构建为单个线性规划，其中明确包含所有情景，并计算最优期望总成本。期望总成本必须以美元报告。百分比（例如，概率和容量因子）以小数形式提供，并且必须以小数形式使用。\n\n实现一个程序，为下面的每个测试用例构建并求解所述的线性规划，并以浮点数形式返回以美元计的最优期望总成本。\n\n测试套件：\n- 测试用例 1（具有非平凡权衡的一般情况）：\n  - 技术：可调度发电机和风力。\n  - 第一阶段摊销资本成本：$c_G = 200$ 美元/兆瓦/小时，$c_W = 150$ 美元/兆瓦/小时。\n  - 第二阶段可变成本：$q_G = 60$ 美元/兆瓦时，$q_W = 0$ 美元/兆瓦时，$p_U = 1000$ 美元/兆瓦时。\n  - 情景：\n    - $\\omega_1$：$D(\\omega_1) = 100$ $\\mathrm{MWh}$，$a_W(\\omega_1) = 0.5$，$p(\\omega_1) = 0.4$。\n    - $\\omega_2$：$D(\\omega_2) = 120$ $\\mathrm{MWh}$，$a_W(\\omega_2) = 0.2$，$p(\\omega_2) = 0.6$。\n- 测试用例 2（边界条件：所有情景中需求为零）：\n  - 第一阶段摊销资本成本：$c_G = 300$ 美元/兆瓦/小时，$c_W = 300$ 美元/兆瓦/小时。\n  - 第二阶段可变成本：$q_G = 50$ 美元/兆瓦时，$q_W = 0$ 美元/兆瓦时，$p_U = 1000$ 美元/兆瓦时。\n  - 情景：\n    - $\\omega_1$：$D(\\omega_1) = 0$ $\\mathrm{MWh}$，$a_W(\\omega_1) = 0.7$，$p(\\omega_1) = 0.5$。\n    - $\\omega_2$：$D(\\omega_2) = 0$ $\\mathrm{MWh}$，$a_W(\\omega_2) = 0.9$，$p(\\omega_2) = 0.5$。\n- 测试用例 3（边缘情况：未满足需求惩罚较低，有利于非投资）：\n  - 第一阶段摊销资本成本：$c_G = 500$ 美元/兆瓦/小时，$c_W = 600$ 美元/兆瓦/小时。\n  - 第二阶段可变成本：$q_G = 60$ 美元/兆瓦时，$q_W = 0$ 美元/兆瓦时，$p_U = 20$ 美元/兆瓦时。\n  - 情景：\n    - $\\omega_1$：$D(\\omega_1) = 50$ $\\mathrm{MWh}$，$a_W(\\omega_1) = 0.2$，$p(\\omega_1) = 0.6$。\n    - $\\omega_2$：$D(\\omega_2) = 80$ $\\mathrm{MWh}$，$a_W(\\omega_2) = 0.1$，$p(\\omega_2) = 0.4$。\n- 测试用例 4（边缘情况：高风能可用性和低风能资本成本）：\n  - 第一阶段摊销资本成本：$c_G = 250$ 美元/兆瓦/小时，$c_W = 50$ 美元/兆瓦/小时。\n  - 第二阶段可变成本：$q_G = 100$ 美元/兆瓦时，$q_W = 0$ 美元/兆瓦时，$p_U = 2000$ 美元/兆瓦时。\n  - 情景：\n    - $\\omega_1$：$D(\\omega_1) = 60$ $\\mathrm{MWh}$，$a_W(\\omega_1) = 0.9$，$p(\\omega_1) = 0.5$。\n    - $\\omega_2$：$D(\\omega_2) = 90$ $\\mathrm{MWh}$，$a_W(\\omega_2) = 0.8$，$p(\\omega_2) = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4]$）的结果，其中每个 $result_i$ 是测试用例 $i$ 的以美元计的最优期望总成本，表示为浮点数。",
            "solution": "所提出的问题是一个有效的两阶段随机线性规划，用于优化简化电力系统中的投资和运营。它在科学上基于能源经济学和运筹学的原理，是适定的、客观的，并包含构建和求解最优期望总成本所需的所有必要信息。\n\n该问题要求最小化第一阶段投资成本与第二阶段运营成本期望值之和。这可以被构建为一个单一的大型线性规划（LP），通常称为确定性等价规划。\n\n设情景集合为 $\\Omega = \\{\\omega_1, \\dots, \\omega_N\\}$，其中 $N$ 是情景的数量。决策变量为：\n- 第一阶段（投资）变量：$x_G$ 和 $x_W$，分别代表可调度发电机和风力发电机的容量。\n- 第二阶段（运营）变量：对于每个情景 $\\omega_i \\in \\Omega$，我们有变量 $g_{G,i}$、$g_{W,i}$ 和 $u_i$，分别代表可调度发电机的发电调度、风力发电机的发电调度和未满足的需求。\n\n目标是最小化总期望成本 $Z$，定义为：\n$$\nZ = c_G x_G + c_W x_W + \\sum_{i=1}^{N} p_i \\left( q_G g_{G,i} + q_W g_{W,i} + p_U u_i \\right)\n$$\n其中 $c_G, c_W$ 是摊销资本成本；$p_i$ 是情景 $\\omega_i$ 的概率；$q_G, q_W, p_U$ 是可调度发电、风力发电和未满足需求的单位可变成本。\n\n该最小化问题受制于每个情景 $\\omega_i \\in \\Omega$ 的以下约束：\n1. 供需平衡：$g_{G,i} + g_{W,i} + u_i = D_i$\n2. 可调度容量限制：$g_{G,i} \\le x_G$\n3. 风能容量限制：$g_{W,i} \\le a_{W,i} x_W$\n4. 所有变量的非负性：$x_G, x_W, g_{G,i}, g_{W,i}, u_i \\ge 0$\n\n这里，$D_i$ 是需求，$a_{W,i}$ 是情景 $\\omega_i$ 中的风能可用性因子。\n\n为使用像 `scipy.optimize.linprog` 这样的标准LP求解器来解决此问题，我们必须将其表示为规范形式：\n$$\n\\min_{\\mathbf{z}} \\mathbf{c}^T \\mathbf{z} \\quad \\text{subject to} \\quad A_{eq} \\mathbf{z} = \\mathbf{b}_{eq}, \\quad A_{ub} \\mathbf{z} \\le \\mathbf{b}_{ub}, \\quad \\mathbf{z} \\ge \\mathbf{0}\n$$\n\n对于一个有 $N$ 个情景的问题，我们构建一个大小为 $2 + 3N$ 的单一决策变量向量 $\\mathbf{z}$：\n$$\n\\mathbf{z} = [x_G, x_W, g_{G,1}, g_{W,1}, u_1, \\dots, g_{G,N}, g_{W,N}, u_N]^T\n$$\n对于给定的测试用例，$N=2$，因此向量 $\\mathbf{z}$ 有 $2 + 3 \\times 2 = 8$ 个分量。\n$$\n\\mathbf{z} = [x_G, x_W, g_{G,1}, g_{W,1}, u_1, g_{G,2}, g_{W,2}, u_2]^T\n$$\n\n大小为 8 的目标函数系数向量 $\\mathbf{c}$ 构建如下：\n$$\n\\mathbf{c} = [c_G, c_W, p_1 q_G, p_1 q_W, p_1 p_U, p_2 q_G, p_2 q_W, p_2 p_U]^T\n$$\n\n等式约束（每个情景的需求平衡）被构建为 $A_{eq} \\mathbf{z} = \\mathbf{b}_{eq}$。对于 $N=2$，矩阵 $A_{eq}$ 是 $2 \\times 8$ 的：\n$$\nA_{eq} = \\begin{pmatrix}\n0  0  1  1  1  0  0  0 \\\\\n0  0  0  0  0  1  1  1\n\\end{pmatrix}\n$$\n相应的右端向量 $\\mathbf{b}_{eq}$ 是：\n$$\n\\mathbf{b}_{eq} = [D_1, D_2]^T\n$$\n\n不等式约束（每个情景的容量限制），重写为 $A_{ub} \\mathbf{z} \\le \\mathbf{b}_{ub}$，是：\n- $g_{G,1} - x_G \\le 0$\n- $g_{W,1} - a_{W,1} x_W \\le 0$\n- $g_{G,2} - x_G \\le 0$\n- $g_{W,2} - a_{W,2} x_W \\le 0$\n\n对于 $N=2$，矩阵 $A_{ub}$ 是 $4 \\times 8$ 的：\n$$\nA_{ub} = \\begin{pmatrix}\n-1  0  1  0  0  0  0  0 \\\\\n0  -a_{W,1}  0  1  0  0  0  0 \\\\\n-1  0  0  0  0  1  0  0 \\\\\n0  -a_{W,2}  0  0  0  0  1  0\n\\end{pmatrix}\n$$\n相应的右端向量 $\\mathbf{b}_{ub}$ 是一个大小为 4 的零向量：\n$$\n\\mathbf{b}_{ub} = [0, 0, 0, 0]^T\n$$\n\n最后，通过将 $\\mathbf{z}$ 的每个分量的界限设置为 $(0, \\infty)$ 来强制所有变量的非负性。\n\n该实现将为每个测试用例构建这些矩阵和向量，使用 `scipy.optimize.linprog` 求解LP，并报告最优目标值，该值对应于最小期望总成本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the stochastic programming problems for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing all parameters.\n    test_cases = [\n        # Test Case 1\n        {\n            \"c_G\": 200.0, \"c_W\": 150.0,\n            \"q_G\": 60.0, \"q_W\": 0.0, \"p_U\": 1000.0,\n            \"scenarios\": [\n                {\"D\": 100.0, \"a_W\": 0.5, \"p\": 0.4},\n                {\"D\": 120.0, \"a_W\": 0.2, \"p\": 0.6},\n            ]\n        },\n        # Test Case 2\n        {\n            \"c_G\": 300.0, \"c_W\": 300.0,\n            \"q_G\": 50.0, \"q_W\": 0.0, \"p_U\": 1000.0,\n            \"scenarios\": [\n                {\"D\": 0.0, \"a_W\": 0.7, \"p\": 0.5},\n                {\"D\": 0.0, \"a_W\": 0.9, \"p\": 0.5},\n            ]\n        },\n        # Test Case 3\n        {\n            \"c_G\": 500.0, \"c_W\": 600.0,\n            \"q_G\": 60.0, \"q_W\": 0.0, \"p_U\": 20.0,\n            \"scenarios\": [\n                {\"D\": 50.0, \"a_W\": 0.2, \"p\": 0.6},\n                {\"D\": 80.0, \"a_W\": 0.1, \"p\": 0.4},\n            ]\n        },\n        # Test Case 4\n        {\n            \"c_G\": 250.0, \"c_W\": 50.0,\n            \"q_G\": 100.0, \"q_W\": 0.0, \"p_U\": 2000.0,\n            \"scenarios\": [\n                {\"D\": 60.0, \"a_W\": 0.9, \"p\": 0.5},\n                {\"D\": 90.0, \"a_W\": 0.8, \"p\": 0.5},\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(params):\n    \"\"\"\n    Constructs and solves the linear program for a single test case.\n\n    The decision variable vector z is structured as:\n    z = [x_G, x_W, g_G1, g_W1, u_1, g_G2, g_W2, u_2, ..., g_GN, g_WN, u_N]\n    where N is the number of scenarios.\n    \"\"\"\n    c_G = params[\"c_G\"]\n    c_W = params[\"c_W\"]\n    q_G = params[\"q_G\"]\n    q_W = params[\"q_W\"]\n    p_U = params[\"p_U\"]\n    scenarios = params[\"scenarios\"]\n    \n    num_scenarios = len(scenarios)\n    num_vars = 2 + 3 * num_scenarios\n    \n    # 1. Objective function vector c\n    c = np.zeros(num_vars)\n    c[0] = c_G\n    c[1] = c_W\n    for i in range(num_scenarios):\n        p_i = scenarios[i][\"p\"]\n        c[2 + 3*i] = p_i * q_G\n        c[2 + 3*i + 1] = p_i * q_W\n        c[2 + 3*i + 2] = p_i * p_U\n        \n    # 2. Equality constraints A_eq, b_eq (Demand Balance)\n    A_eq = np.zeros((num_scenarios, num_vars))\n    b_eq = np.zeros(num_scenarios)\n    for i in range(num_scenarios):\n        A_eq[i, 2 + 3*i : 2 + 3*i + 3] = 1.0\n        b_eq[i] = scenarios[i][\"D\"]\n\n    # 3. Inequality constraints A_ub, b_ub (Capacity Limits)\n    num_ineq = 2 * num_scenarios\n    A_ub = np.zeros((num_ineq, num_vars))\n    b_ub = np.zeros(num_ineq)\n    for i in range(num_scenarios):\n        # g_Gi - x_G = 0\n        A_ub[2*i, 0] = -1.0\n        A_ub[2*i, 2 + 3*i] = 1.0\n        \n        # g_Wi - a_Wi * x_W = 0\n        A_ub[2*i + 1, 1] = -scenarios[i][\"a_W\"]\n        A_ub[2*i + 1, 2 + 3*i + 1] = 1.0\n        \n    # 4. Bounds (Non-negativity)\n    bounds = [(0, None) for _ in range(num_vars)]\n    \n    # Solve the linear program\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if res.success:\n        return res.fun\n    else:\n        # In case of solver failure, which is not expected for these valid problems.\n        return float('nan')\n\nsolve()\n```"
        }
    ]
}