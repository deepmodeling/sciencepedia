{
    "hands_on_practices": [
        {
            "introduction": "Capacity expansion models guide long-term energy system planning by weighing costs and benefits over many years. A crucial element of this is comparing expenditures made at different points in time, which requires a firm grasp of financial discounting. This exercise will guide you through constructing a net present cost objective function from first principles, providing a solid foundation for understanding the economic heart of investment models. ",
            "id": "4099352",
            "problem": "Consider a stylized capacity expansion problem in energy systems modeling that aggregates investment expenditures and operational expenditures across a multi-year planning horizon. The goal is to construct a comprehensive objective from first principles, grounded in discounted cash flow, that evaluates the net present value of all cash flows associated with investments and operations. Your program must implement the following, starting from a fundamental base in financial mathematics.\n\nFundamental base: For a future cash flow occurring in year $y$, the present value with respect to a base year $y_0$ and a constant annual discount rate $r$ is given by the product of the cash flow and the year-specific discount factor $d_y$, where $d_y$ is defined by\n$$\nd_y = (1 + r)^{-(y - y_0)}.\n$$\nThis definition follows directly from the time value of money, where discounting converts future values into their present value equivalents. The objective in capacity expansion modeling is to evaluate the net present value of the aggregate of investment expenditures and operational expenditures by year, using $d_y$ to align all values to the base year $y_0$. Capital Expenditure (CAPEX) and Operational Expenditure (OPEX) are defined as follows:\n- Capital Expenditure (CAPEX) is the annualized investment cash flow for each technology indexed by $i$, denoted as $\\text{CAPEX}_{i,y}$ for year $y$.\n- Operational Expenditure (OPEX) is the operational cash flow at each intra-annual time step $t$ within year $y$, denoted as $\\text{OPEX}_t$ for $t \\in \\mathcal{T}_y$, where $\\mathcal{T}_y$ is the set of time steps inside year $y$.\n\nYour task is to implement the net present cost objective that, for each year $y$, aggregates $\\sum_{i} \\text{CAPEX}_{i,y}$ and $\\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t$, and applies the discount factor $d_y$ derived from the fundamental base above. The role of $d_y$ is to weight each yearâ€™s aggregated cash flows so that later-year amounts contribute less to the objective value according to the discount rate $r$. The final objective is the sum of these discounted annual aggregates across all years in the planning horizon.\n\nUnits: Every cash flow $\\text{CAPEX}_{i,y}$ and $\\text{OPEX}_t$ is provided in million currency units. Your program must output the objective values in million currency units as floating-point numbers. Do not include any currency symbols. Angles are not used. If fractions are needed, use decimal representation.\n\nTest suite: Implement your program to compute the objective for the following cases, each given as a parameter set. In each case, use $d_y = (1 + r)^{-(y - y_0)}$ to discount the annual aggregates to the base year $y_0$.\n\nCase $1$ (general case with multiple technologies, multiple years, and quarterly operational steps):\n- Base year $y_0$: $2025$.\n- Years $\\mathcal{Y}$: $[2025, 2026, 2027]$.\n- Discount rate $r$: $0.07$.\n- Technologies ordered as $\\text{CCGT}$, $\\text{Wind}$, $\\text{Battery}$.\n- $\\text{CAPEX}$ by year (list order corresponds to technologies):\n  - At $2025$: $[300, 200, 100]$.\n  - At $2026$: $[0, 150, 50]$.\n  - At $2027$: $[0, 0, -20]$.\n- $\\text{OPEX}$ by year (quarterly values for each year):\n  - At $2025$: $[50, 48, 52, 50]$.\n  - At $2026$: $[55, 60, 58, 57]$.\n  - At $2027$: $[62, 64, 63, 65]$.\n\nCase $2$ (boundary case with zero discount rate and zero operational costs):\n- Base year $y_0$: $2030$.\n- Years $\\mathcal{Y}$: $[2030, 2031]$.\n- Discount rate $r$: $0$.\n- Technologies ordered as $\\text{Solar}$, $\\text{Wind}$.\n- $\\text{CAPEX}$ by year:\n  - At $2030$: $[120, 80]$.\n  - At $2031$: $[0, 40]$.\n- $\\text{OPEX}$ by year:\n  - At $2030$: $[0, 0, 0]$.\n  - At $2031$: $[0, 0, 0]$.\n\nCase $3$ (edge case with high discount rate, monthly operational steps, and salvage credit in the final year):\n- Base year $y_0$: $2024$.\n- Years $\\mathcal{Y}$: $[2024, 2025, 2026, 2027, 2028]$.\n- Discount rate $r$: $0.15$.\n- Technologies ordered as $\\text{Nuclear}$, $\\text{Wind}$.\n- $\\text{CAPEX}$ by year:\n  - At $2024$: $[1000, 0]$.\n  - At $2025$: $[0, 200]$.\n  - At $2026$: $[500, 0]$.\n  - At $2027$: $[0, 200]$.\n  - At $2028$: $[-100, 0]$.\n- $\\text{OPEX}$ by year (monthly values for each year):\n  - At $2024$: $[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]$.\n  - At $2025$: $[12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5]$.\n  - At $2026$: $[13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333]$.\n  - At $2027$: $[14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667]$.\n  - At $2028$: $[15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]$.\n\nCase $4$ (edge case with no investment decisions and seasonal operational steps):\n- Base year $y_0$: $2020$.\n- Years $\\mathcal{Y}$: $[2020]$.\n- Discount rate $r$: $0.05$.\n- Technologies set is empty (no $\\text{CAPEX}$ flows).\n- $\\text{CAPEX}$ by year:\n  - At $2020$: $[]$.\n- $\\text{OPEX}$ by year (seasonal values for the year):\n  - At $2020$: $[25, 25, 25, 25]$.\n\nYour program must compute the net present cost objective value for each case using the above principles and data. Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[x_1, x_2, x_3, x_4]$, where each $x_k$ is the computed objective value in million currency units for Case $k$ expressed as a floating-point number. The output must be exactly one line with no additional text.",
            "solution": "The problem requires the construction and implementation of a net present cost (NPC) objective function for a stylized energy system capacity expansion problem. The foundation for this objective is the principle of discounted cash flow (DCF), a cornerstone of financial mathematics used to compare cash flows occurring at different points in time.\n\nThe core principle is that a future cash flow is worth less than an identical cash flow received today. This time value of money is quantified using a discount rate, $r$. A cash flow occurring in a future year $y$ is converted to its present value in a base year $y_0$ by multiplying it with a discount factor, $d_y$. As specified, the discount factor is defined as:\n$$\nd_y = (1 + r)^{-(y - y_0)}\n$$\nThis formula shows that for a positive discount rate $r > 0$, the value of $d_y$ decreases as the time difference $(y - y_0)$ increases, meaning cash flows further in the future are valued less.\n\nThe total cost in any given year $y$ of the planning horizon is the sum of all investment (capital) expenditures and operational expenditures. Let $C_y$ be the total undiscounted cash flow for year $y$. It is composed of the sum of Capital Expenditures (CAPEX) across all technologies $i$, and the sum of Operational Expenditures (OPEX) across all intra-annual time steps $t \\in \\mathcal{T}_y$:\n$$\nC_y = \\left( \\sum_{i} \\text{CAPEX}_{i,y} \\right) + \\left( \\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t \\right)\n$$\nHere, $\\text{CAPEX}_{i,y}$ represents the investment cost for technology $i$ in year $y$, and $\\text{OPEX}_t$ represents the operational cost for a specific time step $t$ within year $y$. A negative cash flow, such as a negative $\\text{CAPEX}$, represents a credit or income, for instance from the salvage value of a decommissioned asset.\n\nThe overall objective is to calculate the Net Present Cost (NPC), which is the sum of the discounted annual costs over all years $y$ in the planning horizon $\\mathcal{Y}$. By applying the discount factor $d_y$ to each year's total cost $C_y$, we align all costs to the common reference point of the base year $y_0$. The complete objective function is therefore:\n$$\n\\text{NPC} = \\sum_{y \\in \\mathcal{Y}} d_y \\cdot C_y = \\sum_{y \\in \\mathcal{Y}} (1 + r)^{-(y - y_0)} \\left( \\left( \\sum_{i} \\text{CAPEX}_{i,y} \\right) + \\left( \\sum_{t \\in \\mathcal{T}_y} \\text{OPEX}_t \\right) \\right)\n$$\nThe programmatic implementation follows this formulation directly. An algorithm is designed to process each test case by performing the following steps:\n1. Initialize the total Net Present Cost, $\\text{NPC}$, to $0$.\n2. For each year $y$ in the specified planning horizon $\\mathcal{Y}$:\n    a. Calculate the total capital expenditure for year $y$ by summing all elements in the provided $\\text{CAPEX}$ list for that year. For an empty set of technologies, this sum is $0$.\n    b. Calculate the total operational expenditure for year $y$ by summing all elements in the provided $\\text{OPEX}$ list for that year.\n    c. Sum the results from steps 2a and 2b to find the total undiscounted cost, $C_y$, for year $y$.\n    d. Calculate the discount factor $d_y = (1 + r)^{-(y - y_0)}$ using the given discount rate $r$, the current year $y$, and the base year $y_0$.\n    e. Multiply the total annual cost $C_y$ by the discount factor $d_y$ to obtain the discounted cost for year $y$.\n    f. Add this discounted cost to the running total for the $\\text{NPC}$.\n3. After iterating through all years in the horizon, the final accumulated value is the $\\text{NPC}$ for the given case.\n\nThis procedure is systematically applied to each of the four test cases, using their respective parameters for years, discount rates, and cash flows to compute the final objective values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present cost for a series of energy system investment cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"y0\": 2025,\n            \"years\": [2025, 2026, 2027],\n            \"r\": 0.07,\n            \"capex_data\": {2025: [300, 200, 100], 2026: [0, 150, 50], 2027: [0, 0, -20]},\n            \"opex_data\": {2025: [50, 48, 52, 50], 2026: [55, 60, 58, 57], 2027: [62, 64, 63, 65]},\n        },\n        {\n            \"y0\": 2030,\n            \"years\": [2030, 2031],\n            \"r\": 0.0,\n            \"capex_data\": {2030: [120, 80], 2031: [0, 40]},\n            \"opex_data\": {2030: [0, 0, 0], 2031: [0, 0, 0]},\n        },\n        {\n            \"y0\": 2024,\n            \"years\": [2024, 2025, 2026, 2027, 2028],\n            \"r\": 0.15,\n            \"capex_data\": {2024: [1000, 0], 2025: [0, 200], 2026: [500, 0], 2027: [0, 200], 2028: [-100, 0]},\n            \"opex_data\": {\n                2024: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10],\n                2025: [12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5],\n                2026: [13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333, 13.3333333333],\n                2027: [14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667, 14.1666666667],\n                2028: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],\n            },\n        },\n        {\n            \"y0\": 2020,\n            \"years\": [2020],\n            \"r\": 0.05,\n            \"capex_data\": {2020: []},\n            \"opex_data\": {2020: [25, 25, 25, 25]},\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        y0 = case[\"y0\"]\n        years = case[\"years\"]\n        r = case[\"r\"]\n        capex_data = case[\"capex_data\"]\n        opex_data = case[\"opex_data\"]\n        \n        total_npc = 0.0\n        \n        for y in years:\n            # Calculate total undiscounted cost for the year\n            annual_capex = np.sum(capex_data[y])\n            annual_opex = np.sum(opex_data[y])\n            total_annual_cost = annual_capex + annual_opex\n            \n            # Calculate discount factor\n            discount_factor = (1 + r) ** -(y - y0)\n            \n            # Add discounted cost to total NPC\n            total_npc += total_annual_cost * discount_factor\n            \n        results.append(total_npc)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While investment models determine the optimal capacity mix, operational models test if that mix can function reliably on a second-to-second basis. A critical operational constraint is the ability of generators to ramp their output up or down to follow fluctuating demand and renewable generation. This practice demonstrates how investment choices in fleet flexibility directly constrain operational feasibility, revealing that a system can have sufficient capacity but still fail due to inadequate ramping capability. ",
            "id": "4099394",
            "problem": "Consider an electricity generation fleet indexed by technologies $i \\in \\{1,\\dots,N\\}$ and time periods $t \\in \\{1,\\dots,T\\}$. Let $p_{i,t}$ denote the power dispatch decision for technology $i$ in period $t$, $x_i$ denote the installed capacity of technology $i$, $R_i$ denote the maximum ramp-up capability of technology $i$ per period, $S_i$ denote the maximum ramp-down capability of technology $i$ per period, $p_{i,0}$ denote the initial dispatch level prior to period $t=1$, and $d_t$ denote the electricity demand in period $t$. \n\nStarting from the following fundamental base for operational feasibility in electric power systems:\n- Conservation of power balance in each period: $$\\sum_{i=1}^{N} p_{i,t} = d_t \\quad \\text{for all } t \\in \\{1,\\dots,T\\}.$$\n- Physical capacity bounds for each technology: $$0 \\le p_{i,t} \\le x_i \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; t \\in \\{1,\\dots,T\\}.$$\n- Intertemporal ramping constraints expressing limited flexibility: $$p_{i,t} - p_{i,t-1} \\le R_i, \\quad p_{i,t-1} - p_{i,t} \\le S_i \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; t \\in \\{1,\\dots,T\\},$$ with the convention $p_{i,0}$ given.\n\nYour tasks are:\n- Construct the above ramping constraints explicitly as linear inequalities and explain, in rigorous terms, the mechanism by which insufficient flexibility in investments (reflected in small $R_i$ and $S_i$ relative to demand changes) yields infeasible operations, even when installed capacities $x_i$ appear sufficient to meet static demand levels.\n- Implement a program that, given a set of investment-dependent parameters $\\{x_i,R_i,S_i\\}$, initial conditions $\\{p_{i,0}\\}$, and a demand trajectory $\\{d_t\\}$, determines whether there exists a feasible dispatch schedule $\\{p_{i,t}\\}$ that satisfies all constraints. The program must formulate and solve a linear feasibility problem.\n\nUse the following test suite of parameter sets. Each test case specifies $(N,T)$, the demand sequence $\\{d_t\\}$, capacities $\\{x_i\\}$, ramp-up limits $\\{R_i\\}$, ramp-down limits $\\{S_i\\}$, and initial outputs $\\{p_{i,0}\\}$. For clarity, each list is written in the order of technologies or time periods as applicable.\n\n- Test case $1$ (general happy path): \n  - $N = 2$, $T = 4$,\n  - $\\{d_t\\} = \\{80, 100, 120, 110\\}$,\n  - $\\{x_i\\} = \\{100, 100\\}$,\n  - $\\{R_i\\} = \\{50, 30\\}$,\n  - $\\{S_i\\} = \\{50, 30\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$.\n  Expected qualitative behavior: feasible because aggregate ramping can follow demand changes.\n\n- Test case $2$ (boundary, exact ramp match): \n  - $N = 1$, $T = 6$,\n  - $\\{d_t\\} = \\{20, 40, 60, 80, 100, 120\\}$,\n  - $\\{x_i\\} = \\{120\\}$,\n  - $\\{R_i\\} = \\{20\\}$,\n  - $\\{S_i\\} = \\{20\\}$,\n  - $\\{p_{i,0}\\} = \\{0\\}$.\n  Expected qualitative behavior: feasible with exact ramping matching demand increments.\n\n- Test case $3$ (insufficient ramp-up despite adequate capacity): \n  - $N = 1$, $T = 2$,\n  - $\\{d_t\\} = \\{0, 50\\}$,\n  - $\\{x_i\\} = \\{120\\}$,\n  - $\\{R_i\\} = \\{10\\}$,\n  - $\\{S_i\\} = \\{120\\}$,\n  - $\\{p_{i,0}\\} = \\{0\\}$.\n  Expected qualitative behavior: infeasible because the required increase of $50$ exceeds available ramp-up of $10$.\n\n- Test case $4$ (insufficient ramp-down causing inability to follow demand drop):\n  - $N = 1$, $T = 2$,\n  - $\\{d_t\\} = \\{100, 0\\}$,\n  - $\\{x_i\\} = \\{100\\}$,\n  - $\\{R_i\\} = \\{100\\}$,\n  - $\\{S_i\\} = \\{10\\}$,\n  - $\\{p_{i,0}\\} = \\{100\\}$.\n  Expected qualitative behavior: infeasible because the required decrease of $100$ exceeds available ramp-down of $10$.\n\n- Test case $5$ (investment portfolio lacking flexible technology, infeasible):\n  - $N = 2$, $T = 2$,\n  - $\\{d_t\\} = \\{50, 150\\}$,\n  - $\\{x_i\\} = \\{150, 50\\}$,\n  - $\\{R_i\\} = \\{5, 50\\}$,\n  - $\\{S_i\\} = \\{5, 50\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$.\n  Expected qualitative behavior: infeasible because aggregate ramp-up of $5 + 50 = 55$ cannot cover the $100$ increase.\n\n- Test case $6$ (same capacities with higher investment in flexibility, feasible):\n  - $N = 2$, $T = 2$,\n  - $\\{d_t\\} = \\{50, 150\\}$,\n  - $\\{x_i\\} = \\{150, 50\\}$,\n  - $\\{R_i\\} = \\{50, 50\\}$,\n  - $\\{S_i\\} = \\{50, 50\\}$,\n  - $\\{p_{i,0}\\} = \\{0, 0\\}$.\n  Expected qualitative behavior: feasible because aggregate ramp-up of $50 + 50 = 100$ exactly covers the demand increase.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $6$, where each entry is a boolean indicating feasibility (e.g., [True, False, ...]). No physical units are required in the output because the results are booleans. The algorithm must be general and applicable to any modern programming language; your final answer must be a complete runnable program as specified.",
            "solution": "The problem presented is a valid linear feasibility problem, a foundational concept in the field of energy systems optimization. It is scientifically grounded, well-posed, and all necessary parameters for its solution are provided. We proceed with the analysis and solution.\n\nThe problem requires determining if a feasible power dispatch schedule, denoted by the set of variables $\\{p_{i,t}\\}$, exists for a fleet of $N$ generation technologies over $T$ time periods. A schedule is feasible if it simultaneously satisfies three sets of linear constraints: power balance, capacity limits, and intertemporal ramping limits.\n\nThe ramping constraints for a given technology $i$ are given by two inequalities for each time period $t \\in \\{1,\\dots,T\\}$:\n$$p_{i,t} - p_{i,t-1} \\le R_i$$\n$$p_{i,t-1} - p_{i,t} \\le S_i$$\nwhere $p_{i,t}$ is the power output in period $t$, $p_{i,t-1}$ is the output in the preceding period (with $p_{i,0}$ being a given initial condition), $R_i$ is the maximum ramp-up rate, and $S_i$ is the maximum ramp-down rate. These can be combined into a single expression:\n$$-S_i \\le p_{i,t} - p_{i,t-1} \\le R_i$$\nThis composite inequality states that the change in power output of technology $i$ between consecutive periods is bounded. $R_i$ and $S_i$ are physical characteristics of the power plant, reflecting its \"flexibility.\" For instance, a large coal-fired power plant has immense thermal inertia and cannot change its output rapidly, resulting in small $R_i$ and $S_i$ values relative to its capacity. Conversely, a natural gas peaker plant or a battery energy storage system is highly flexible, corresponding to large $R_i$ and $S_i$ values. The choice of which technologies to build, and thus the system-wide values of $\\{R_i, S_i\\}$, is an investment decision.\n\nThe mechanism by which insufficient flexibility leads to operational infeasibility, even with adequate static capacity, can be rigorously demonstrated. Consider the change in total system demand from period $t-1$ to $t$, which is $d_t - d_{t-1}$. Using the power balance constraint, $\\sum_{i=1}^{N} p_{i,t} = d_t$, we can express this demand change in terms of generation dispatch:\n$$d_t - d_{t-1} = \\sum_{i=1}^{N} p_{i,t} - \\sum_{i=1}^{N} p_{i,t-1} = \\sum_{i=1}^{N} (p_{i,t} - p_{i,t-1})$$\nFrom the ramp-up constraint, we know that $p_{i,t} - p_{i,t-1} \\le R_i$ for each technology $i$. Summing this inequality over all technologies yields:\n$$\\sum_{i=1}^{N} (p_{i,t} - p_{i,t-1}) \\le \\sum_{i=1}^{N} R_i$$\nBy substituting the expression for the demand change, we arrive at a necessary condition for feasibility:\n$$d_t - d_{t-1} \\le \\sum_{i=1}^{N} R_i$$\nSimilarly, from the ramp-down constraint $p_{i,t-1} - p_{i,t} \\le S_i$, we can derive:\n$$d_{t-1} - d_t \\le \\sum_{i=1}^{N} S_i$$\nThese two relations show that the net change in demand across the entire system must be less than or equal to the aggregate ramp-up or ramp-down capability of the generation fleet. If a demand increase $d_t - d_{t-1}$ is greater than the total system ramp-up capability $\\sum_i R_i$, it is mathematically impossible to find a set of $\\{p_{i,t}\\}$ that satisfies both the ramping and power balance constraints. This is precisely the situation where an investment portfolio, even if its total capacity $\\sum_i x_i$ is much larger than the peak demand $\\max_t d_t$, can be operationally infeasible due to a lack of flexibility.\n\nHowever, satisfying these aggregate ramping conditions is necessary but not sufficient for feasibility. A feasible solution must also respect the individual capacity bounds $0 \\le p_{i,t} \\le x_i$ and the individual ramping constraints for every technology at every time step. For example, a generator that is already operating at its maximum capacity $x_i$ cannot ramp up further, even if its $R_i$ is large. The feasibility of the system is thus a complex interplay of all constraints over the entire time horizon. The decision of how to dispatch generation in period $t$ has consequences for feasibility in period $t+1$.\n\nTo definitively determine feasibility, we must solve a linear feasibility problem. We seek to find a point in a high-dimensional space that satisfies all linear constraints simultaneously. The variables of this problem are the dispatch levels $p_{i,t}$ for all $i \\in \\{1,\\dots,N\\}$ and $t \\in \\{1,\\dots,T\\}$. Let us define a single vector of decision variables $\\mathbf{p}$ of size $N \\times T$ by stacking all $p_{i,t}$ values. The problem is to find $\\mathbf{p}$ such that:\n1. Equality constraints (power balance): $A_{eq}\\mathbf{p} = \\mathbf{b}_{eq}$, where each row corresponds to a time period $t$ and enforces $\\sum_i p_{i,t} = d_t$.\n2. Inequality constraints (ramping): $A_{ub}\\mathbf{p} \\le \\mathbf{b}_{ub}$, where rows enforce $p_{i,t} - p_{i,t-1} \\le R_i$ and $p_{i,t-1} - p_{i,t} \\le S_i$ for all $i,t$.\n3. Variable bounds (capacity limits): $\\mathbf{0} \\le \\mathbf{p} \\le \\mathbf{x}_{stacked}$, where the upper bounds are derived from the given capacities $x_i$.\n\nA standard linear programming (LP) solver can solve this problem. If the solver finds a set of variables $\\mathbf{p}$ that satisfies all constraints, the problem is feasible. If it proves that no such $\\mathbf{p}$ exists, the problem is infeasible. The implementation below constructs these matrices and vectors and uses an LP solver to determine feasibility for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_feasibility(N, T, d, x, R, S, p0):\n    \"\"\"\n    Formulates and solves a linear feasibility problem for electricity dispatch.\n\n    Args:\n        N (int): Number of technologies.\n        T (int): Number of time periods.\n        d (list): Demand sequence of length T.\n        x (list): Installed capacities of length N.\n        R (list): Ramp-up limits of length N.\n        S (list): Ramp-down limits of length N.\n        p0 (list): Initial dispatch levels of length N.\n\n    Returns:\n        bool: True if a feasible schedule exists, False otherwise.\n    \"\"\"\n    # Total number of decision variables (p_i,t for all i, t)\n    num_vars = N * T\n\n    # The vector of variables is flattened as [p_1,1, ..., p_1,T, p_2,1, ..., p_N,T]\n    # The index for p_i,t is (i-1)*T + (t-1)\n\n    # Objective function: we only seek feasibility, so we can minimize a zero vector.\n    c = np.zeros(num_vars)\n\n    # --- Equality constraints: sum_{i} p_{i,t} = d_t for each t ---\n    # There are T equality constraints.\n    A_eq = np.zeros((T, num_vars))\n    b_eq = np.array(d)\n    for t_idx in range(T):  # t_idx corresponds to t-1\n        for i_idx in range(N):  # i_idx corresponds to i-1\n            var_idx = i_idx * T + t_idx\n            A_eq[t_idx, var_idx] = 1\n\n    # --- Inequality constraints: Ramping ---\n    # There are 2*N*T ramping constraints (one ramp-up, one ramp-down per i,t)\n    num_ineq_constr = 2 * N * T\n    A_ub = np.zeros((num_ineq_constr, num_vars))\n    b_ub = np.zeros(num_ineq_constr)\n    \n    constraint_idx = 0\n    for i_idx in range(N):\n        for t_idx in range(T):\n            var_idx_t = i_idx * T + t_idx\n            \n            # 1. Ramp-up: p_{i,t} - p_{i,t-1} <= R_i\n            if t_idx == 0:  # t=1, uses p_{i,0}\n                # p_{i,1} - p_{i,0} <= R_i  =>  p_{i,1} <= R_i + p_{i,0}\n                A_ub[constraint_idx, var_idx_t] = 1\n                b_ub[constraint_idx] = R[i_idx] + p0[i_idx]\n            else:  # t > 1\n                var_idx_t_minus_1 = i_idx * T + (t_idx - 1)\n                A_ub[constraint_idx, var_idx_t] = 1\n                A_ub[constraint_idx, var_idx_t_minus_1] = -1\n                b_ub[constraint_idx] = R[i_idx]\n            constraint_idx += 1\n\n            # 2. Ramp-down: p_{i,t-1} - p_{i,t} <= S_i\n            if t_idx == 0:  # t=1, uses p_{i,0}\n                # p_{i,0} - p_{i,1} <= S_i  =>  -p_{i,1} <= S_i - p_{i,0}\n                A_ub[constraint_idx, var_idx_t] = -1\n                b_ub[constraint_idx] = S[i_idx] - p0[i_idx]\n            else:  # t > 1\n                var_idx_t_minus_1 = i_idx * T + (t_idx - 1)\n                A_ub[constraint_idx, var_idx_t] = -1\n                A_ub[constraint_idx, var_idx_t_minus_1] = 1\n                b_ub[constraint_idx] = S[i_idx]\n            constraint_idx += 1\n            \n    # --- Variable bounds: 0 <= p_{i,t} <= x_i ---\n    bounds = []\n    for i_idx in range(N):\n        for _ in range(T):\n            bounds.append((0, x[i_idx]))\n\n    # Solve the linear program\n    # The 'highs' solver is robust and suitable for this feasibility problem.\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    # res.success is True if an optimal solution is found.\n    # For a feasibility problem, this means a feasible solution exists.\n    # If the problem is infeasible, res.status is 2 and res.success is False.\n    return res.success\n\ndef solve():\n    \"\"\"\n    Runs the feasibility check for all test cases provided in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, T, d, x, R, S, p0)\n        (2, 4, [80, 100, 120, 110], [100, 100], [50, 30], [50, 30], [0, 0]),\n        (1, 6, [20, 40, 60, 80, 100, 120], [120], [20], [20], [0]),\n        (1, 2, [0, 50], [120], [10], [120], [0]),\n        (1, 2, [100, 0], [100], [100], [10], [100]),\n        (2, 2, [50, 150], [150, 50], [5, 50], [5, 50], [0, 0]),\n        (2, 2, [50, 150], [150, 50], [50, 50], [50, 50], [0, 0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, d, x, R, S, p0 = case\n        is_feasible = check_feasibility(N, T, d, x, R, S, p0)\n        results.append(is_feasible)\n\n    # The final output must be a single line in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The most sophisticated energy system models bridge the gap between long-term investment and short-term operations by explicitly accounting for uncertainty. Two-stage stochastic programming provides a powerful framework for this, modeling the sequence of \"investing now\" and \"operating later\" across a range of possible futures. In this exercise, you will build a stochastic model to see how optimal investment decisions are shaped by the need to maintain operational feasibility under uncertain conditions. ",
            "id": "4099405",
            "problem": "Consider a stylized single-period electric power system modeled as a two-stage stochastic program. First-stage decisions invest in capacities before uncertainties are realized, while second-stage decisions operate the system after a scenario is revealed. The physical and economic basis is the following: the electric power balance requires that supply meets demand in every scenario, capacities are physical upper limits on dispatch in megawatts, and expected cost is the probability-weighted average of random scenario-specific costs. The fundamental definitions used are the definition of expected value of a random variable and linear capacity-constrained production.\n\nLet first-stage investment decisions be denoted by the vector $x = (x_G, x_W)$, where $x_G$ is the capacity of a dispatchable generator in megawatts ($\\mathrm{MW}$) and $x_W$ is the capacity of a wind generator in megawatts ($\\mathrm{MW}$). Capital costs are amortized per operating hour and given by $c = (c_G, c_W)$ measured in dollars per megawatt per hour. For each scenario $\\omega$, the second-stage operational decisions are $y(\\omega) = \\big(g_G(\\omega), g_W(\\omega), u(\\omega)\\big)$, where $g_G(\\omega)$ and $g_W(\\omega)$ are the dispatch levels of the dispatchable and wind generators in megawatt-hours ($\\mathrm{MWh}$) over one hour, and $u(\\omega)$ is unmet demand in megawatt-hours ($\\mathrm{MWh}$). The variable costs per megawatt-hour are $q = (q_G, q_W, p_U)$ measured in dollars per megawatt-hour. Demand in scenario $\\omega$ is $D(\\omega)$ in megawatt-hours, wind availability (capacity factor) is $a_W(\\omega)$, and scenario probabilities are $p(\\omega)$ satisfying $\\sum_{\\omega} p(\\omega) = 1$ and $p(\\omega) \\ge 0$.\n\nThe second-stage operational constraints for each scenario $\\omega$ are:\n- Demand balance: $g_G(\\omega) + g_W(\\omega) + u(\\omega) = D(\\omega)$.\n- Capacity limits: $g_G(\\omega) \\le x_G$ and $g_W(\\omega) \\le a_W(\\omega) \\, x_W$.\n- Nonnegativity: $g_G(\\omega) \\ge 0$, $g_W(\\omega) \\ge 0$, and $u(\\omega) \\ge 0$.\n\nThe goal is to minimize the sum of amortized investment cost and expected operational cost measured in dollars, that is, minimize the expected total cost over one hour. You must formulate this model as a single linear program using sample average approximation, where all scenarios are included explicitly, and compute the optimal expected total cost. The expected total cost must be reported in dollars. Angles are not used; no angle unit is required. Percentages (e.g., probabilities and capacity factors) are provided as decimals and must be used as decimals.\n\nImplement a program that, for each test case below, constructs and solves the described linear program and returns the optimal expected total cost in dollars as a floating-point number.\n\nTest Suite:\n- Test Case 1 (general case with nontrivial trade-offs):\n  - Technologies: dispatchable generator and wind.\n  - First-stage amortized capital costs: $c_G = 200$ dollars per $\\mathrm{MW}$ per hour, $c_W = 150$ dollars per $\\mathrm{MW}$ per hour.\n  - Second-stage variable costs: $q_G = 60$ dollars per $\\mathrm{MWh}$, $q_W = 0$ dollars per $\\mathrm{MWh}$, $p_U = 1000$ dollars per $\\mathrm{MWh}$.\n  - Scenarios:\n    - $\\omega_1$: $D(\\omega_1) = 100$ $\\mathrm{MWh}$, $a_W(\\omega_1) = 0.5$, $p(\\omega_1) = 0.4$.\n    - $\\omega_2$: $D(\\omega_2) = 120$ $\\mathrm{MWh}$, $a_W(\\omega_2) = 0.2$, $p(\\omega_2) = 0.6$.\n- Test Case 2 (boundary condition: zero demand in all scenarios):\n  - First-stage amortized capital costs: $c_G = 300$ dollars per $\\mathrm{MW}$ per hour, $c_W = 300$ dollars per $\\mathrm{MW}$ per hour.\n  - Second-stage variable costs: $q_G = 50$ dollars per $\\mathrm{MWh}$, $q_W = 0$ dollars per $\\mathrm{MWh}$, $p_U = 1000$ dollars per $\\mathrm{MWh}$.\n  - Scenarios:\n    - $\\omega_1$: $D(\\omega_1) = 0$ $\\mathrm{MWh}$, $a_W(\\omega_1) = 0.7$, $p(\\omega_1) = 0.5$.\n    - $\\omega_2$: $D(\\omega_2) = 0$ $\\mathrm{MWh}$, $a_W(\\omega_2) = 0.9$, $p(\\omega_2) = 0.5$.\n- Test Case 3 (edge case: unmet demand penalty is low, favoring non-investment):\n  - First-stage amortized capital costs: $c_G = 500$ dollars per $\\mathrm{MW}$ per hour, $c_W = 600$ dollars per $\\mathrm{MW}$ per hour.\n  - Second-stage variable costs: $q_G = 60$ dollars per $\\mathrm{MWh}$, $q_W = 0$ dollars per $\\mathrm{MWh}$, $p_U = 20$ dollars per $\\mathrm{MWh}$.\n  - Scenarios:\n    - $\\omega_1$: $D(\\omega_1) = 50$ $\\mathrm{MWh}$, $a_W(\\omega_1) = 0.2$, $p(\\omega_1) = 0.6$.\n    - $\\omega_2$: $D(\\omega_2) = 80$ $\\mathrm{MWh}$, $a_W(\\omega_2) = 0.1$, $p(\\omega_2) = 0.4$.\n- Test Case 4 (edge case: high wind availability and low wind capital cost):\n  - First-stage amortized capital costs: $c_G = 250$ dollars per $\\mathrm{MW}$ per hour, $c_W = 50$ dollars per $\\mathrm{MW}$ per hour.\n  - Second-stage variable costs: $q_G = 100$ dollars per $\\mathrm{MWh}$, $q_W = 0$ dollars per $\\mathrm{MWh}$, $p_U = 2000$ dollars per $\\mathrm{MWh}$.\n  - Scenarios:\n    - $\\omega_1$: $D(\\omega_1) = 60$ $\\mathrm{MWh}$, $a_W(\\omega_1) = 0.9$, $p(\\omega_1) = 0.5$.\n    - $\\omega_2$: $D(\\omega_2) = 90$ $\\mathrm{MWh}$, $a_W(\\omega_2) = 0.8$, $p(\\omega_2) = 0.5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is the optimal expected total cost in dollars for Test Case $i$, expressed as a floating-point number.",
            "solution": "The problem presented is a valid two-stage stochastic linear program for optimizing investment and operation in a simplified electric power system. It is scientifically grounded in the principles of energy economics and operations research, well-posed, objective, and contains all necessary information to formulate and solve for the optimal expected total cost.\n\nThe problem asks to minimize the sum of first-stage investment costs and the expected value of second-stage operational costs. This can be formulated as a single, large-scale linear program (LP), often referred to as the deterministic equivalent program.\n\nLet the set of scenarios be $\\Omega = \\{\\omega_1, \\dots, \\omega_N\\}$, where $N$ is the number of scenarios. The decision variables are:\n- First-stage (investment) variables: $x_G$ and $x_W$, representing the capacities of the dispatchable and wind generators, respectively.\n- Second-stage (operational) variables: For each scenario $\\omega_i \\in \\Omega$, we have variables $g_{G,i}$, $g_{W,i}$, and $u_i$, representing the dispatch from the dispatchable generator, the dispatch from the wind generator, and the unmet demand.\n\nThe objective is to minimize the total expected cost, $Z$, defined as:\n$$\nZ = c_G x_G + c_W x_W + \\sum_{i=1}^{N} p_i \\left( q_G g_{G,i} + q_W g_{W,i} + p_U u_i \\right)\n$$\nwhere $c_G, c_W$ are the amortized capital costs; $p_i$ is the probability of scenario $\\omega_i$; and $q_G, q_W, p_U$ are the per-unit variable costs for dispatchable generation, wind generation, and unmet demand.\n\nThis minimization is subject to the following constraints for each scenario $\\omega_i \\in \\Omega$:\n1. Demand-supply balance: $g_{G,i} + g_{W,i} + u_i = D_i$\n2. Dispatchable capacity limit: $g_{G,i} \\le x_G$\n3. Wind capacity limit: $g_{W,i} \\le a_{W,i} x_W$\n4. Non-negativity of all variables: $x_G, x_W, g_{G,i}, g_{W,i}, u_i \\ge 0$\n\nHere, $D_i$ is the demand and $a_{W,i}$ is the wind availability factor in scenario $\\omega_i$.\n\nTo solve this problem using a standard LP solver like `scipy.optimize.linprog`, we must express it in the canonical form:\n$$\n\\min_{\\mathbf{z}} \\mathbf{c}^T \\mathbf{z} \\quad \\text{subject to} \\quad A_{eq} \\mathbf{z} = \\mathbf{b}_{eq}, \\quad A_{ub} \\mathbf{z} \\le \\mathbf{b}_{ub}, \\quad \\mathbf{z} \\ge \\mathbf{0}\n$$\n\nFor a problem with $N$ scenarios, we construct a single vector of decision variables $\\mathbf{z}$ of size $2 + 3N$:\n$$\n\\mathbf{z} = [x_G, x_W, g_{G,1}, g_{W,1}, u_1, \\dots, g_{G,N}, g_{W,N}, u_N]^T\n$$\nFor the given test cases, $N=2$, so the vector $\\mathbf{z}$ has $2 + 3 \\times 2 = 8$ components.\n$$\n\\mathbf{z} = [x_G, x_W, g_{G,1}, g_{W,1}, u_1, g_{G,2}, g_{W,2}, u_2]^T\n$$\n\nThe objective function coefficient vector $\\mathbf{c}$ of size $8$ is constructed as:\n$$\n\\mathbf{c} = [c_G, c_W, p_1 q_G, p_1 q_W, p_1 p_U, p_2 q_G, p_2 q_W, p_2 p_U]^T\n$$\n\nThe equality constraints (demand balance for each scenario) are formulated as $A_{eq} \\mathbf{z} = \\mathbf{b}_{eq}$. For $N=2$, the matrix $A_{eq}$ is $2 \\times 8$:\n$$\nA_{eq} = \\begin{pmatrix}\n0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 1 & 1 & 1\n\\end{pmatrix}\n$$\nThe corresponding right-hand side vector $\\mathbf{b}_{eq}$ is:\n$$\n\\mathbf{b}_{eq} = [D_1, D_2]^T\n$$\n\nThe inequality constraints (capacity limits for each scenario), rewritten as $A_{ub} \\mathbf{z} \\le \\mathbf{b}_{ub}$, are:\n- $g_{G,1} - x_G \\le 0$\n- $g_{W,1} - a_{W,1} x_W \\le 0$\n- $g_{G,2} - x_G \\le 0$\n- $g_{W,2} - a_{W,2} x_W \\le 0$\n\nFor $N=2$, the matrix $A_{ub}$ is $4 \\times 8$:\n$$\nA_{ub} = \\begin{pmatrix}\n-1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & -a_{W,1} & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n-1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & -a_{W,2} & 0 & 0 & 0 & 0 & 1 & 0\n\\end{pmatrix}\n$$\nThe corresponding right-hand side vector $\\mathbf{b}_{ub}$ is a zero vector of size $4$:\n$$\n\\mathbf{b}_{ub} = [0, 0, 0, 0]^T\n$$\n\nFinally, the non-negativity of all variables is enforced by setting the bounds for each component of $\\mathbf{z}$ to $(0, \\infty)$.\n\nThe implementation will construct these matrices and vectors for each test case, use `scipy.optimize.linprog` to solve the LP, and report the optimal objective value, which corresponds to the minimum expected total cost.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the stochastic programming problems for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing all parameters.\n    test_cases = [\n        # Test Case 1\n        {\n            \"c_G\": 200.0, \"c_W\": 150.0,\n            \"q_G\": 60.0, \"q_W\": 0.0, \"p_U\": 1000.0,\n            \"scenarios\": [\n                {\"D\": 100.0, \"a_W\": 0.5, \"p\": 0.4},\n                {\"D\": 120.0, \"a_W\": 0.2, \"p\": 0.6},\n            ]\n        },\n        # Test Case 2\n        {\n            \"c_G\": 300.0, \"c_W\": 300.0,\n            \"q_G\": 50.0, \"q_W\": 0.0, \"p_U\": 1000.0,\n            \"scenarios\": [\n                {\"D\": 0.0, \"a_W\": 0.7, \"p\": 0.5},\n                {\"D\": 0.0, \"a_W\": 0.9, \"p\": 0.5},\n            ]\n        },\n        # Test Case 3\n        {\n            \"c_G\": 500.0, \"c_W\": 600.0,\n            \"q_G\": 60.0, \"q_W\": 0.0, \"p_U\": 20.0,\n            \"scenarios\": [\n                {\"D\": 50.0, \"a_W\": 0.2, \"p\": 0.6},\n                {\"D\": 80.0, \"a_W\": 0.1, \"p\": 0.4},\n            ]\n        },\n        # Test Case 4\n        {\n            \"c_G\": 250.0, \"c_W\": 50.0,\n            \"q_G\": 100.0, \"q_W\": 0.0, \"p_U\": 2000.0,\n            \"scenarios\": [\n                {\"D\": 60.0, \"a_W\": 0.9, \"p\": 0.5},\n                {\"D\": 90.0, \"a_W\": 0.8, \"p\": 0.5},\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(params):\n    \"\"\"\n    Constructs and solves the linear program for a single test case.\n\n    The decision variable vector z is structured as:\n    z = [x_G, x_W, g_G1, g_W1, u_1, g_G2, g_W2, u_2, ..., g_GN, g_WN, u_N]\n    where N is the number of scenarios.\n    \"\"\"\n    c_G = params[\"c_G\"]\n    c_W = params[\"c_W\"]\n    q_G = params[\"q_G\"]\n    q_W = params[\"q_W\"]\n    p_U = params[\"p_U\"]\n    scenarios = params[\"scenarios\"]\n    \n    num_scenarios = len(scenarios)\n    num_vars = 2 + 3 * num_scenarios\n    \n    # 1. Objective function vector c\n    c = np.zeros(num_vars)\n    c[0] = c_G\n    c[1] = c_W\n    for i in range(num_scenarios):\n        p_i = scenarios[i][\"p\"]\n        c[2 + 3*i] = p_i * q_G\n        c[2 + 3*i + 1] = p_i * q_W\n        c[2 + 3*i + 2] = p_i * p_U\n        \n    # 2. Equality constraints A_eq, b_eq (Demand Balance)\n    A_eq = np.zeros((num_scenarios, num_vars))\n    b_eq = np.zeros(num_scenarios)\n    for i in range(num_scenarios):\n        A_eq[i, 2 + 3*i : 2 + 3*i + 3] = 1.0\n        b_eq[i] = scenarios[i][\"D\"]\n\n    # 3. Inequality constraints A_ub, b_ub (Capacity Limits)\n    num_ineq = 2 * num_scenarios\n    A_ub = np.zeros((num_ineq, num_vars))\n    b_ub = np.zeros(num_ineq)\n    for i in range(num_scenarios):\n        # g_Gi - x_G <= 0\n        A_ub[2*i, 0] = -1.0\n        A_ub[2*i, 2 + 3*i] = 1.0\n        \n        # g_Wi - a_Wi * x_W <= 0\n        A_ub[2*i + 1, 1] = -scenarios[i][\"a_W\"]\n        A_ub[2*i + 1, 2 + 3*i + 1] = 1.0\n        \n    # 4. Bounds (Non-negativity)\n    bounds = [(0, None) for _ in range(num_vars)]\n    \n    # Solve the linear program\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if res.success:\n        return res.fun\n    else:\n        # In case of solver failure, which is not expected for these valid problems.\n        return float('nan')\n\nsolve()\n```"
        }
    ]
}