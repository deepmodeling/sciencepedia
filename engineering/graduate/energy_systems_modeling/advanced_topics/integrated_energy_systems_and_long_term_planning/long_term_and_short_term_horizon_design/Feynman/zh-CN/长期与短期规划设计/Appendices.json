{
    "hands_on_practices": [
        {
            "introduction": "在构建长期能源系统模型时，一个核心挑战是如何在保持计算可行性的同时，准确地捕捉短期的运行动态。一种常用技术是将全年数千小时的时间序列压缩为一组“代表性时段”。然而，这种时间聚合必须尊重发电机组的物理限制，例如最小启动和停机时间。\n\n本练习将引导你探索这一基本权衡，通过一个具体的案例计算，为了让简化模型能够容纳一个符合物理和经济规律的完整启停周期，所需的最少连续代表性时段数量。这个过程将加深你对模型时间分辨率与物理可行性之间内在联系的理解。",
            "id": "4102481",
            "problem": "一个电力系统规划模型使用基于代表性时段的简化时序时间表示法，将长期投资决策与短期运行可行性相结合。考虑一个受最小开机和最小停机时间约束的单一非灵活性火电机组，其调度通过一个二元启停变量进行，该变量只能在固定长度的代表性时段的边界处改变状态。\n\n假设存在以下基于物理现实的数据和模型选择：\n- 每个代表性时段的长度为 $L$ 小时，且各时段按顺序连接以强制执行时序性。在本问题中，取 $L = 24$ 小时。\n- 该机组的最小开机时间为 $U$ 小时，最小停机时间为 $D$ 小时。在本问题中，取 $U = 72$ 小时， $D = 36$ 小时。\n- 典型的每周净负荷模式是这样的：在没有最小时间约束的情况下，该机组在每个重复的周循环中，会因经济性原因连续开机 $H_{\\text{on}}$ 小时，然后停机 $H_{\\text{off}}$ 小时。在本问题中，取 $H_{\\text{on}} = 5 \\times 24$ 小时， $H_{\\text{off}} = 2 \\times 24$ 小时，这反映了五个高负荷工作日和随后的两个低负荷周末日。\n\n仅从机组组合中最小开机和最小停机时间的核心定义，以及将代表性时段构建为固定长度时序块的构造方法出发，推导出一个必要下界。这个下界是关于必须按顺序连接的代表性时段数量 $K$ 的，以确保简化模型能够表示至少一个完整的开关机周循环，该循环既满足机组的最小时间约束，又忠实于所述的周负荷状况。然后，在给定数值下计算最小的 $K$。请用一个单一整数（无单位）表示最终答案。无需进行四舍五入。",
            "solution": "在尝试求解之前，将对问题进行验证。\n\n### 第1步：提取已知条件\n- 代表性时段的长度：$L = 24$ 小时。\n- 火电机组的最小开机时间：$U = 72$ 小时。\n- 火电机组的最小停机时间：$D = 36$ 小时。\n- 每个周期的经济开机时长：$H_{\\text{on}} = 5 \\times 24$ 小时。\n- 每个周期的经济停机时长：$H_{\\text{off}} = 2 \\times 24$ 小时。\n- 机组的启停状态（开/关）由一个二元变量表示。\n- 状态变化只能在代表性时段的边界发生。\n- 目标是找到所需连接的代表性时段数量 $K$ 的必要下界，以表示一个完整的、可行的开关机周期。\n\n### 第2步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学性**：该问题在电力系统工程和运筹学领域有充分的依据。机组组合、最小开/停机时间以及代表性时段（时间切片）的使用是长期能源规划模型（例如，容量扩张模型）中为管理计算复杂性同时保留运行可行性的标准技术。所提供的数值对于大型基荷或中等负荷的火电厂是现实的。\n- **适定性**：这个问题是适定的。它提供了一个明确的目标（找到最小整数 $K$）和一套完整的约束和参数（$L, U, D, H_{\\text{on}}, H_{\\text{off}}$）。从给定信息可以推导出唯一且有意义的解。\n- **客观性**：该问题以工程和数学建模中常见的精确、客观的语言陈述。没有主观或含糊不清的术语。\n\n该问题不存在任何无效性缺陷。它不是科学上不合理、不可形式化、不完整、不现实、不适定或微不足道的。它在能源系统建模中提出了一个真实且相关的问题。\n\n### 第3步：结论与行动\n问题有效。将推导解答。\n\n### 解答推导\n\n该问题要求确定需要按顺序连接的代表性时段的最小数量 $K$，以模拟一个火电机组的单个、可行的开关机周期。模型的时序表示是离散的，由长度为 $L$ 的时段组成。然而，机组的物理约束在连续时间内运行。\n\n设机组连续开机（ON）的时段数为 $N_{\\text{on}}$，连续停机（OFF）的时段数为 $N_{\\text{off}}$。由于启停状态只能在时段边界改变，$N_{\\text{on}}$ 和 $N_{\\text{off}}$ 必须是整数。\n\n模型中开机阶段的总时长为 $T_{\\text{on}} = N_{\\text{on}} L$。这个时长必须满足两个条件：\n1.  **物理可行性**：开机时长必须遵守机组的最小开机时间 $U$。因此，$T_{\\text{on}} \\geq U$。\n2.  **对负荷状况的忠实性**：模型必须能够表示经济上要求在线 $H_{\\text{on}}$ 小时的必要性。这意味着计划的开机时长必须至少与期望的经济开机时长一样长。如果 $T_{\\text{on}}  H_{\\text{on}}$，模型将无法满足经济信号，从而违反了问题的前提。因此，$T_{\\text{on}} \\geq H_{\\text{on}}$。\n\n结合这两个条件，简化模型中的总开机时间必须大于或等于物理和经济要求的最大值：\n$$N_{\\text{on}} L \\geq \\max(U, H_{\\text{on}})$$\n由于 $N_{\\text{on}}$ 必须是整数，开机阶段所需的最少时段数可以通过分离出 $N_{\\text{on}}$ 并对所得表达式取上整得到，因为任何小数部分都需要一个额外的完整时段。\n$$N_{\\text{on}} = \\left\\lceil \\frac{\\max(U, H_{\\text{on}})}{L} \\right\\rceil$$\n\n类似地，停机阶段的总时长为 $T_{\\text{off}} = N_{\\text{off}} L$。这个时长也必须满足两个类似的条件：\n1.  **物理可行性**：停机时长必须遵守机组的最小停机时间 $D$。因此，$T_{\\text{off}} \\geq D$。\n2.  **对负荷状况的忠实性**：模型必须能够表示经济上要求离线 $H_{\\text{off}}$ 小时的必要性。因此，$T_{\\text{off}} \\geq H_{\\text{off}}$。\n\n结合这些，总停机时间必须满足：\n$$N_{\\text{off}} L \\geq \\max(D, H_{\\text{off}})$$\n停机阶段所需的最少整数时段数为：\n$$N_{\\text{off}} = \\left\\lceil \\frac{\\max(D, H_{\\text{off}})}{L} \\right\\rceil$$\n\n一个“完整的开关机周循环”需要一个开机时段序列后跟一个停机时段序列。模拟这个完整周期所需的代表性时段总数 $K$ 是开机阶段所需的最少时段数与停机阶段所需的最少时段数之和。\n$$K = N_{\\text{on}} + N_{\\text{off}} = \\left\\lceil \\frac{\\max(U, H_{\\text{on}})}{L} \\right\\rceil + \\left\\lceil \\frac{\\max(D, H_{\\text{off}})}{L} \\right\\rceil$$\n\n现在，我们代入给定的数值：\n- $L = 24$\n- $U = 72$\n- $D = 36$\n- $H_{\\text{on}} = 5 \\times 24 = 120$\n- $H_{\\text{off}} = 2 \\times 24 = 48$\n\n首先，计算 $N_{\\text{on}}$:\n$$\\max(U, H_{\\text{on}}) = \\max(72, 120) = 120$$\n$$N_{\\text{on}} = \\left\\lceil \\frac{120}{24} \\right\\rceil = \\lceil 5 \\rceil = 5$$\n\n接着，计算 $N_{\\text{off}}$:\n$$\\max(D, H_{\\text{off}}) = \\max(36, 48) = 48$$\n$$N_{\\text{off}} = \\left\\lceil \\frac{48}{24} \\right\\rceil = \\lceil 2 \\rceil = 2$$\n\n最后，所需连接时段的最小总数 $K$ 是：\n$$K = N_{\\text{on}} + N_{\\text{off}} = 5 + 2 = 7$$\n\n因此，必须按时间顺序连接最少7个代表性时段（每个长度为24小时），以确保模型能够表示一个既符合机组物理约束又与指定的周运行模式一致的可行开关机周期。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "长短期联合优化模型的核心在于两个层面之间的信息传递：长期投资决策如何影响短期运行成本，以及短期运行的瓶颈如何指导未来的投资。Benders 分解法为这种信息传递提供了强大的数学框架。该方法通过从运行子问题生成“割平面”来迭代地通知投资主问题。\n\n本练习要求你深入Benders分解法的核心机制，通过推导一个典型运行子问题的对偶问题，来构建最优割。你将亲手推导出最优割的系数如何由容量限制的影子价格（即对偶变量）构成，从而在经济学上诠释了增加单位发电或存储容量所能带来的预期运行成本节约。",
            "id": "4102493",
            "problem": "考虑一个电力系统的两阶段规划模型，该模型包含一个长期投资主问题和一个短期运营子问题。投资向量为 $y = (y_{E}, y_{P}, y_{G})$，其中 $y_{E}$ 是已安装的储能能量容量，单位为兆瓦时 (MWh)；$y_{P}$ 是已安装的储能功率容量，单位为兆瓦 (MW)（假设其同时限制充电和放电速率）；$y_{G}$ 是已安装的可调度发电容量，单位为兆瓦 (MW)。对于给定的投资 $y$，运营子问题在 $T$ 个小时周期内进行优化。对于每个小时 $t \\in \\{1,\\dots,T\\}$，运营决策变量为：可调度发电量 $g_{t} \\geq 0$、储能充电量 $c_{t} \\geq 0$、储能放电量 $d_{t} \\geq 0$ 以及荷电状态 $s_{t} \\geq 0$。设需求 $D_{t} \\geq 0$ 为给定值，初始荷电状态为 $s_{0} \\geq 0$，充电和放电效率分别为 $\\eta_{c} \\in (0,1]$ 和 $\\eta_{d} \\in (0,1]$。设非负的线性运营成本为：发电成本 $C_{G}$（单位为美元/兆瓦时，记作 $\\$\\!/ \\mathrm{MWh}$），充电成本 $C_{c}$（单位为 $\\$\\!/ \\mathrm{MWh}$），放电成本 $C_{d}$（单位为 $\\$\\!/ \\mathrm{MWh}$）。运营子问题是如下的线性规划：\n$$\n\\min_{g_{t},\\,c_{t},\\,d_{t},\\,s_{t} \\geq 0} \\;\\sum_{t=1}^{T} \\big( C_{G}\\, g_{t} + C_{c}\\, c_{t} + C_{d}\\, d_{t} \\big)\n$$\n在满足以下约束的条件下，对于所有 $t=1,\\dots,T$：\n$$\n\\text{(balance)}\\quad g_{t} + d_{t} - c_{t} = D_{t},\n$$\n$$\n\\text{(intertemporal)}\\quad s_{t} = s_{t-1} + \\eta_{c}\\, c_{t} - \\eta_{d}^{-1} d_{t},\n$$\n$$\n\\text{(gen cap)}\\quad g_{t} \\leq y_{G},\n$$\n$$\n\\text{(charge cap)}\\quad c_{t} \\leq y_{P},\n$$\n$$\n\\text{(discharge cap)}\\quad d_{t} \\leq y_{P},\n$$\n$$\n\\text{(energy cap)}\\quad s_{t} \\leq y_{E},\n$$\n以及终端循环条件\n$$\n\\text{(terminal)}\\quad s_{T} = s_{0}.\n$$\n您可以假设所有数据都是可行的，并且对于任何非负的 $y$，运营子问题都有一个有限最优解。\n\n从线性规划的标准对偶性出发，仅使用基本的线性优化原理，按以下步骤进行：\n- 将运营子问题重构为矩阵形式的最小化问题，其包含等式约束和小于等于形式的容量约束，且这些容量约束的右侧项仿射地依赖于 $y$。\n- 推导其对偶问题，并清楚地标明与每类约束相关的对偶变量：设 $\\lambda_{t}$ 为平衡等式的对偶变量，$\\nu_{t}$ 为跨期等式的对偶变量，$\\tau$ 为终端等式的对偶变量，并设 $\\alpha_{t} \\geq 0$, $\\beta_{t} \\geq 0$, $\\gamma_{t} \\geq 0$, $\\sigma_{t} \\geq 0$ 分别为发电、充电、放电和能量容量约束的对偶变量。\n- 使用强对偶性将最优运营成本写为最优对偶解下的对偶目标值。确定偿付值对 $y$ 的依赖关系，并将关于 $y$ 的Benders最优性割的系数向量表示为最优对偶变量的函数。\n\n您的最终输出应该是关于 $(y_{E}, y_{P}, y_{G})$ 的Benders最优性割的系数向量，以一个紧凑的单行向量形式写出，其分量是对偶变量 $\\alpha_{t}$、$\\beta_{t}$、$\\gamma_{t}$ 和 $\\sigma_{t}$ 的符号表达式。请以“货币单位/容量单位”来表示此向量，其中第一个分量的单位为美元/兆瓦时，第二和第三个分量的单位为美元/兆瓦。请勿在最终的方框答案中包含单位。无需四舍五入；请提供精确的符号表达式。",
            "solution": "该任务要求为两阶段能源系统规划问题推导Benders最优性割的系数向量。\n\n### **第一步：问题验证**\n问题陈述描述了一个应用于能源系统规划的标准两阶段规划结构，其中第一阶段（主问题）决策是投资 $y = (y_E, y_P, y_G)$，第二阶段（子问题）决策是每小时的运营。子问题是一个线性规划（LP），其约束依赖于投资向量 $y$。任务是重构此LP，推导其对偶问题，并确定与投资变量相对应的Benders最优性割的系数。\n\n**已知条件：**\n- 投资向量：$y = (y_{E}, y_{P}, y_{G})$，分别代表储能能量容量 (MWh)、储能功率容量 (MW) 和发电容量 (MW)。\n- 运营变量（对于 $t \\in \\{1,\\dots,T\\}$）：$g_t, c_t, d_t, s_t \\ge 0$。\n- 参数：$D_t, s_0, \\eta_c, \\eta_d, C_G, C_c, C_d$。\n- 原始运营子问题 $P(y)$：\n    $$\n    \\min_{g_{t},\\,c_{t},\\,d_{t},\\,s_{t} \\geq 0} \\;\\sum_{t=1}^{T} \\big( C_{G}\\, g_{t} + C_{c}\\, c_{t} + C_{d}\\, d_{t} \\big)\n    $$\n    在满足以下约束的条件下，对于 $t=1,\\dots,T$：\n    1. $g_{t} + d_{t} - c_{t} = D_{t}$\n    2. $s_{t} = s_{t-1} + \\eta_{c}\\, c_{t} - \\eta_{d}^{-1} d_{t}$\n    3. $g_{t} \\leq y_{G}$\n    4. $c_{t} \\leq y_{P}$\n    5. $d_{t} \\leq y_{P}$\n    6. $s_{t} \\leq y_{E}$\n    以及 $s_{T} = s_{0}$。\n- 假设：对于任何 $y \\ge 0$，子问题都是可行且有界的。\n- 对偶变量分配：$\\lambda_t$ 对应平衡约束，$\\nu_t$ 对应跨期约束，$\\tau$ 对应终端约束，$\\alpha_t, \\beta_t, \\gamma_t, \\sigma_t \\ge 0$ 对应容量约束。\n\n**验证：**\n1. **科学依据：** 该模型是一个包含可调度发电和储能的电力系统的标准简化表示。约束条件代表了能量平衡和容量限制等基本原则。该公式在科学上是合理的。\n2. **适定性：** 这是一个适定的线性规划问题。从一个LP子问题推导Benders割是优化理论中的一个标准程序。可行性和有界性的假设确保了解的存在。\n3. **目标明确：** 问题的陈述具有数学上的精确性，没有歧义。\n\n该问题被认为是**有效的**。我们可以继续进行求解。\n\n### **第二步：重构与对偶推导**\n\n我们首先将原始子问题 $P(y)$ 形式化，然后推导其对偶问题。该问题可以写成一个适用对偶理论的标准形式。\n\n**原始问题重构：**\n运营子问题可以表述为：\n$$\nQ(y) = \\min_{g,c,d,s} \\sum_{t=1}^{T} (C_{G} g_{t} + C_{c} c_{t} + C_{d} d_{t})\n$$\n在满足以下约束的条件下：\n- $g_{t} - c_{t} + d_{t} = D_{t} \\quad \\forall t \\in \\{1, \\dots, T\\}$ (对偶变量: $\\lambda_t$)\n- $s_{t} - s_{t-1} - \\eta_{c} c_{t} + \\eta_{d}^{-1} d_{t} = 0 \\quad \\forall t \\in \\{1, \\dots, T\\}$ (对偶变量: $\\nu_t$)\n- $s_{T} = s_{0}$ (对偶变量: $\\tau$)\n- $g_{t} \\le y_{G} \\quad \\forall t \\in \\{1, \\dots, T\\}$ (对偶变量: $\\alpha_t \\ge 0$)\n- $c_{t} \\le y_{P} \\quad \\forall t \\in \\{1, \\dots, T\\}$ (对偶变量: $\\beta_t \\ge 0$)\n- $d_{t} \\le y_{P} \\quad \\forall t \\in \\{1, \\dots, T\\}$ (对偶变量: $\\gamma_t \\ge 0$)\n- $s_{t} \\le y_{E} \\quad \\forall t \\in \\{1, \\dots, T\\}$ (对偶变量: $\\sigma_t \\ge 0$)\n- $g_t, c_t, d_t, s_t \\ge 0 \\quad \\forall t \\in \\{1, \\dots, T\\}$\n\n其中 $s_0$ 是一个固定参数。\n\n**拉格朗日公式：**\n该问题的拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L} = \\sum_{t=1}^{T} (C_{G} g_{t} + C_{c} c_{t} + C_{d} d_{t}) \\\\\n+ \\sum_{t=1}^{T} \\lambda_{t} (D_{t} - g_{t} + c_{t} - d_{t}) \\\\\n+ \\sum_{t=1}^{T} \\nu_{t} (s_{t-1} + \\eta_{c} c_{t} - \\eta_{d}^{-1} d_{t} - s_{t}) \\\\\n+ \\tau (s_{0} - s_{T}) \\\\\n+ \\sum_{t=1}^{T} \\alpha_{t} (g_{t} - y_{G}) \\\\\n+ \\sum_{t=1}^{T} \\beta_{t} (c_{t} - y_{P}) \\\\\n+ \\sum_{t=1}^{T} \\gamma_{t} (d_{t} - y_{P}) \\\\\n+ \\sum_{t=1}^{T} \\sigma_{t} (s_{t} - y_{E})\n$$\n其中 $\\alpha_t, \\beta_t, \\gamma_t, \\sigma_t \\ge 0$，而 $\\lambda_t, \\nu_t, \\tau$ 的符号不受限制。\n\n按原始决策变量 $g_t, c_t, d_t, s_t$ 对各项进行分组并整理关于 $s_t$ 的求和项后，我们得到对偶约束，这些约束来自于确保拉格朗日函数关于非负原始变量的下确界有界的条件：\n1.  关于 $g_t$: $C_{G} - \\lambda_{t} + \\alpha_{t} \\ge 0$\n2.  关于 $c_t$: $C_{c} + \\lambda_{t} + \\eta_{c} \\nu_{t} + \\beta_{t} \\ge 0$\n3.  关于 $d_t$: $C_{d} - \\lambda_{t} - \\eta_{d}^{-1} \\nu_{t} + \\gamma_{t} \\ge 0$\n4.  关于 $s_t$ ($t  T$): $\\nu_{t+1} - \\nu_{t} + \\sigma_{t} \\ge 0$\n5.  关于 $s_T$: $-\\nu_T - \\tau + \\sigma_T \\ge 0$\n\n**对偶问题：**\n对偶目标是最大化 $\\mathcal{L}$ 中不涉及原始决策变量的项：\n$$\n\\max \\left\\{ \\sum_{t=1}^{T} \\lambda_{t} D_{t} + \\nu_1 s_0 + \\tau s_0 - y_G \\sum_{t=1}^{T} \\alpha_t - y_P \\sum_{t=1}^{T} (\\beta_t + \\gamma_t) - y_E \\sum_{t=1}^{T} \\sigma_t \\right\\}\n$$\n受限于上述推导出的对偶约束。\n\n### **第三步：Benders最优性割**\n根据线性规划的强对偶性，原始子问题的最优值 $Q(y)$ 等于其对偶问题的最优值。设对偶问题的一个最优解表示为 $(\\lambda^*, \\nu^*, \\tau^*, \\alpha^*, \\beta^*, \\gamma^*, \\sigma^*)$。那么：\n$$\nQ(y) = \\sum_{t=1}^{T} \\lambda^*_{t} D_{t} + (\\nu^*_{1} + \\tau^*)s_{0} - y_G \\sum_{t=1}^{T} \\alpha^*_t - y_P \\sum_{t=1}^{T} (\\beta^*_t + \\gamma^*_t) - y_E \\sum_{t=1}^{T} \\sigma^*_t\n$$\n函数 $Q(y)$ 是子问题的值函数，它是关于 $y$ 的凸函数。在Benders分解中，最优性割为 $Q(y)$ 提供了一个线性下界。Benders割在主问题中通常写为 $\\theta \\ge \\text{常数} - (\\text{系数})^T y$，其中 $\\theta$ 是表示子问题成本的主问题变量。\n\n通过对对偶目标函数关于 $y$求导，我们可以得到 $Q(y)$ 的次梯度（在这里是梯度）：\n$$\n\\frac{\\partial Q(y)}{\\partial y_E} = -\\sum_{t=1}^{T} \\sigma^*_t\n$$\n$$\n\\frac{\\partial Q(y)}{\\partial y_P} = -\\sum_{t=1}^{T} (\\beta^*_t + \\gamma^*_t)\n$$\n$$\n\\frac{\\partial Q(y)}{\\partial y_G} = -\\sum_{t=1}^{T} \\alpha^*_t\n$$\nBenders最优性割的系数向量对应于每单位容量增加所带来的预期运营成本节约，即 $-\\nabla_y Q(y)$。\n因此，关于 $(y_E, y_P, y_G)$ 的系数向量为：\n$$\n\\begin{pmatrix} -\\frac{\\partial Q(y)}{\\partial y_E} \\\\ -\\frac{\\partial Q(y)}{\\partial y_P} \\\\ -\\frac{\\partial Q(y)}{\\partial y_G} \\end{pmatrix} = \\begin{pmatrix} \\sum_{t=1}^{T} \\sigma^*_t \\\\ \\sum_{t=1}^{T} (\\beta^*_t + \\gamma^*_t) \\\\ \\sum_{t=1}^{T} \\alpha^*_t \\end{pmatrix}\n$$\n在最终表达式中省略星号上标，这些分量代表了相应容量约束的影子价格（边际价值）在整个运营周期内的总和。\n\n- $y_E$ 的系数 (单位为 $\\$!/ \\mathrm{MWh}$): $\\sum_{t=1}^{T} \\sigma_t$\n- $y_P$ 的系数 (单位为 $\\$!/ \\mathrm{MW}$): $\\sum_{t=1}^{T} (\\beta_t + \\gamma_t)$\n- $y_G$ 的系数 (单位为 $\\$!/ \\mathrm{MW}$): $\\sum_{t=1}^{T} \\alpha_t$\n\n最终的系数行向量为：\n$$\n\\begin{pmatrix} \\sum_{t=1}^{T} \\sigma_t  \\sum_{t=1}^{T} (\\beta_t + \\gamma_t)  \\sum_{t=1}^{T} \\alpha_t \\end{pmatrix}\n$$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sum_{t=1}^{T} \\sigma_{t}  \\sum_{t=1}^{T} (\\beta_{t} + \\gamma_{t})  \\sum_{t=1}^{T} \\alpha_{t}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论和实践之间的一大步是将抽象的建模概念转化为可执行的量化分析。在设计模型的时间尺度时，我们总是在追求更高精度（这需要更精细的时间分辨率）和控制计算负担（这需要更粗糙的分辨率）之间做出选择。这个权衡并非总是线性的，通常存在一个“收益递减”的临界点。\n\n这个综合性的编程练习将让你亲手实现这一权衡分析。你需要构建一个包含可再生能源和储能的系统仿真模型，并在不同时间分辨率下运行它，量化计算成本（以代理指标衡量）与求解精度之间的关系。通过计算并分析帕累托前沿，你将学习如何系统地识别出那个“恰到好处”的模型分辨率，即进一步提高复杂度所带来的精度收益已微不足道。",
            "id": "4102533",
            "problem": "设计并实现一个完整的、可运行的程序，用于评估离散化多时域能源系统模型中算法运行时间与解的质量之间的权衡，并识别收益递减发生的位置。该模型包含一个确定性的电力负荷、外生的可再生能源发电以及一个理想化的储能设备。程序必须计算一组时域长度和时间分辨率下的帕累托前沿，并为每个测试用例输出首次出现收益递减时的时间分辨率。所有计算必须是可复现的，并从能量平衡和算法复杂度的第一性原理推导得出。三角函数中使用的角度必须以弧度表示。单位必须按规定明确处理。\n\n您必须使用以下基本物理定义和约束，从连续时间函数构建离散时间模型：\n\n- 能量平衡与守恒：在每个时长为 $\\Delta t$（小时）的时间步内，火力发电 $g_k$（兆瓦）、可再生能源发电 $r_k$（兆瓦）、负荷 $L_k$（兆瓦）、充电功率 $c_k$（兆瓦）和放电功率 $d_k$（兆瓦）满足\n$$\ng_k + r_k + d_k = L_k + c_k,\n$$\n其中 $g_k \\ge 0$，$c_k \\ge 0$ 且 $d_k \\ge 0$。\n- 储能动态：储能状态 $s_k$（兆瓦时）演变如下\n$$\ns_{k+1} = s_k + \\eta_c \\, c_k \\, \\Delta t - \\frac{d_k \\, \\Delta t}{\\eta_d},\n$$\n其边界条件为 $0 \\le s_k \\le S_{\\max}$，充电功率边界为 $0 \\le c_k \\le P_c$，放电功率边界为 $0 \\le d_k \\le P_d$。此处 $\\eta_c \\in (0,1]$ 和 $\\eta_d \\in (0,1]$ 分别是充电和放电效率。\n\n连续时间负荷和可再生能源发电由平滑有界的时间函数 $t$（小时）给出，分别表示为 $L(t)$ 和 $R(t)$。离散时间近似在每个区间的中点 $t_k = (k + \\tfrac{1}{2}) \\Delta t$ 进行点采样，以获得 $L_k = L(t_k)$ 和 $r_k = R(t_k)$。\n\n对于每种离散化，将算法运行时间代理定义为基本操作总数，\n$$\n\\mathcal{T} = c_{\\text{ops}} \\, N,\n$$\n其中 $c_{\\text{ops}}$ 是一个固定常数，表示每步的基本操作数，而 $N = H / \\Delta t$ 是时域长度 $H$（小时）的步数。此代理的单位是“基本操作”，不是物理时间单位。\n\n将解的质量定义为在给定离散化下总火力发电能量与在精细分辨率 $\\Delta t_{\\text{ref}}$ 下计算的高保真度参考值之间的绝对兆瓦时差异。具体而言，时域内的总化石能源为\n$$\nE_{\\text{fossil}} = \\sum_{k=0}^{N-1} g_k \\, \\Delta t,\n$$\n参考值 $E_{\\text{fossil}}^{\\text{ref}}$ 使用 $\\Delta t_{\\text{ref}}$ 计算，则解的质量误差为\n$$\n\\varepsilon = \\left| E_{\\text{fossil}} - E_{\\text{fossil}}^{\\text{ref}} \\right| \\quad \\text{（单位：兆瓦时）}。\n$$\n\n算法策略要求：推导并实现一个基于能量守恒和线性成本的短视储能控制策略，其中仅当 $r_k  L_k$ 时充电，仅当 $r_k  L_k$ 时放电，每种操作均受功率限制和储能边界的约束。陈述从基本定义中证明此策略所需的任何假设。\n\n帕累托前沿要求：对于每个测试用例，评估所有指定的时间分辨率，并计算在同时最小化两个坐标的情况下得到的非支配对 $(\\mathcal{T}, \\varepsilon)$ 的集合。然后，在归一化坐标中\n$$\nx_i = \\frac{\\mathcal{T}_i - \\min_j \\mathcal{T}_j}{\\max_j \\mathcal{T}_j - \\min_j \\mathcal{T}_j}, \\quad\ny_i = \\frac{\\varepsilon_i - \\min_j \\varepsilon_j}{\\max_j \\varepsilon_j - \\min_j \\varepsilon_j},\n$$\n沿递增的 $x$ 方向，识别绝对斜率 $\\left| \\Delta y / \\Delta x \\right|$ 首次降至阈值 $\\tau$（无量纲）以下的点，并报告对应的 $\\Delta t$（小时）作为收益递减分辨率。如果不存在这样的点，则选择在归一化空间中使 $x + y$ 最小化的分辨率。\n\n物理和数值单位：\n- 时域长度 $H$ 的单位是小时。\n- 时间分辨率 $\\Delta t$ 的单位是小时。\n- 功率量 $L_k$、$r_k$、$g_k$、$c_k$、$d_k$、$P_c$ 和 $P_d$ 的单位是兆瓦。\n- 储能量 $s_k$ 和 $S_{\\max}$ 的单位是兆瓦时。\n- 效率 $\\eta_c$ 和 $\\eta_d$ 是无量纲的。\n- 解的质量误差 $\\varepsilon$ 必须以兆瓦时为单位进行计算和处理。\n- 三角函数内的角度必须是弧度。\n\n测试套件：\n实现程序以解决以下三种情况。对于每种情况，使用参考分辨率 $\\Delta t_{\\text{ref}} = 0.125$ 小时和 $c_{\\text{ops}} = 40$ 每步基本操作数；使用斜率阈值 $\\tau = 0.15$。\n\n- Case A (日度时域):\n  - 时域长度 $H = 24$。\n  - 负荷 $L(t) = L_b + A_L \\sin\\!\\left( \\frac{2\\pi t}{24} \\right) + B_L \\sin\\!\\left( \\frac{2\\pi t}{24 \\cdot 7} + \\psi \\right)$，其中 $L_b = 50$，$A_L = 10$，$B_L = 5$，$\\psi = 0.3$。\n  - 可再生能源 $R(t) = A_R \\max\\!\\left( 0, \\sin\\!\\left( \\frac{2\\pi (t \\bmod 24)}{24} - \\frac{\\pi}{2} \\right) \\right)$，其中 $A_R = 30$。\n  - 储能 $S_{\\max} = 50$，$P_c = 20$，$P_d = 20$，$\\eta_c = 0.95$，$\\eta_d = 0.90$，初始状态 $s_0 = S_{\\max}/2$。\n  - 候选分辨率 $\\Delta t \\in \\{ 8, 4, 2, 1, 0.5 \\}$。\n\n- Case B (短时域):\n  - 时域长度 $H = 6$。\n  - 负荷 $L(t) = L_b + A_L \\sin\\!\\left( \\frac{2\\pi t}{24} + \\phi \\right)$，其中 $L_b = 60$，$A_L = 15$，$\\phi = -0.5$。\n  - 可再生能源 $R(t) = A_R \\max\\!\\left( 0, \\sin\\!\\left( \\frac{2\\pi (t \\bmod 24)}{24} - \\frac{\\pi}{2} \\right) \\right)$，其中 $A_R = 10$。\n  - 储能 $S_{\\max} = 30$，$P_c = 15$，$P_d = 15$，$\\eta_c = 0.95$，$\\eta_d = 0.90$，初始状态 $s_0 = S_{\\max}/2$。\n  - 候选分辨率 $\\Delta t \\in \\{ 3, 2, 1, 0.5, 0.25 \\}$。\n\n- Case C (周度时域):\n  - 时域长度 $H = 168$。\n  - 负荷 $L(t) = L_b + A_L \\sin\\!\\left( \\frac{2\\pi t}{24} \\right) + B_L \\sin\\!\\left( \\frac{2\\pi t}{24 \\cdot 7} + \\psi \\right)$，其中 $L_b = 55$，$A_L = 8$，$B_L = 12$，$\\psi = -0.7$。\n  - 可再生能源 $R(t) = A_R \\max\\!\\left( 0, \\sin\\!\\left( \\frac{2\\pi (t \\bmod 24)}{24} - \\frac{\\pi}{2} \\right) \\right)$，其中 $A_R = 25$。\n  - 储能 $S_{\\max} = 200$，$P_c = 50$，$P_d = 50$，$\\eta_c = 0.95$，$\\eta_d = 0.90$，初始状态 $s_0 = S_{\\max}/2$。\n  - 候选分辨率 $\\Delta t \\in \\{ 24, 12, 6, 3, 1.5 \\}$。\n\n您的程序必须：\n- 使用中点采样 $t_k = (k + \\tfrac{1}{2}) \\Delta t$ 实现离散时间仿真。\n- 对于每个案例，在 $\\Delta t_{\\text{ref}}$ 下计算 $E_{\\text{fossil}}^{\\text{ref}}$，并为所有候选 $\\Delta t$ 计算 $(\\mathcal{T}, \\varepsilon)$ 对的集合。\n- 在 $\\mathcal{T}$ 和 $\\varepsilon$ 的双标准最小化下计算帕累托前沿。\n- 使用应用于归一化 $(x,y)$ 坐标的斜率阈值 $\\tau$ 来确定收益递减分辨率，并在需要时使用所述的备用方案。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含收益递减分辨率（每个测试用例一个），单位为小时，四舍五入到两位小数，作为用方括号括起来的逗号分隔列表（例如，$\\text{[result1,result2,result3]}$）。结果是单位为小时的浮点数。",
            "solution": "我们从每个长度为 $\\Delta t$ 小时的离散区间的能量守恒开始。在第 $k$ 步，平衡关系为\n$$\ng_k + r_k + d_k = L_k + c_k,\n$$\n其中 $g_k$ 代表为满足未被可再生能源或储能放电满足的剩余需求所需的火力发电。储能状态根据能量核算的第一性原理演变：\n$$\ns_{k+1} = s_k + \\eta_c \\, c_k \\, \\Delta t - \\frac{d_k \\, \\Delta t}{\\eta_d},\n$$\n受限于 $0 \\le s_k \\le S_{\\max}$，$0 \\le c_k \\le P_c$ 和 $0 \\le d_k \\le P_d$。这里 $\\eta_c \\in (0,1]$ 表示充电损耗，$\\eta_d \\in (0,1]$ 表示放电损耗。功率量的单位是兆瓦，能量量的单位是兆瓦时。\n\n在线性火力发电成本且对储存能量除了其对满足负荷的贡献外没有套利估值的情况下，最小化时域内总火力发电量的最优控制策略是短视且贪婪的：当有可再生能源盈余时充电，当有缺口时放电，每个动作都受设备限制和守恒约束的限制。这是因为在没有时变价格、弃电惩罚或储能退化的情况下，储能的边际价值在时间上是恒定的，因此使用盈余能量立即或稍后通过储能减少火力发电总是有利的，直到达到极限。形式上，令剩余功率为 $\\sigma_k = r_k - L_k$。如果 $\\sigma_k  0$，充电受到三个约束的限制：充电功率限制 $P_c$、可用盈余 $\\sigma_k$ 以及储能的剩余空间 $(S_{\\max} - s_k)$ 按该步的充电效率进行缩放，即\n$$\nc_k = \\min\\!\\left( P_c, \\sigma_k, \\frac{S_{\\max} - s_k}{\\eta_c \\, \\Delta t} \\right),\n$$\n导致 $g_k = 0$ 和 $s_{k+1} = s_k + \\eta_c c_k \\Delta t$。如果 $\\sigma_k  0$（缺口），放电受到放电功率限制 $P_d$、当前状态 $s_k$ 在该步内可输送的能量以及缺口大小 $-\\sigma_k$ 的限制。该步内可输送的放电功率受 $s_k \\eta_d / \\Delta t$ 限制（因为以功率 $d_k$ 放电 $\\Delta t$ 会使储存能量减少 $d_k \\Delta t / \\eta_d$，且我们要求 $s_{k+1} \\ge 0$）。因此，\n$$\nd_k = \\min\\!\\left( P_d, \\frac{s_k \\eta_d}{\\Delta t}, -\\sigma_k \\right),\n$$\n导致 $g_k = -\\sigma_k - d_k$ 和 $s_{k+1} = s_k - \\frac{d_k \\Delta t}{\\eta_d}$。当 $\\sigma_k = 0$ 时，设置 $c_k = d_k = 0$，$g_k = 0$。\n\n我们通过中点采样 $t_k = (k + \\tfrac{1}{2}) \\Delta t$ 对连续负荷 $L(t)$ 和可再生能源发电 $R(t)$ 进行离散化，得到 $L_k = L(t_k)$ 和 $r_k = R(t_k)$。在时域长度 $H$ 内的总火力发电能量为\n$$\nE_{\\text{fossil}} = \\sum_{k=0}^{N-1} g_k \\, \\Delta t,\n$$\n其中 $N = H / \\Delta t$ 是步数。参考火力发电能量 $E_{\\text{fossil}}^{\\text{ref}}$ 使用更精细的分辨率 $\\Delta t_{\\text{ref}}$ 进行类似计算。解的质量误差是兆瓦时的绝对差值，\n$$\n\\varepsilon = \\left| E_{\\text{fossil}} - E_{\\text{fossil}}^{\\text{ref}} \\right|。\n$$\n\n我们现在定义运行时间代理。贪婪控制的每一步需要评估一些算术运算（减法以形成 $\\sigma_k$）、比较和最小值运算，外加对 $s_{k+1}$ 的更新和 $E_{\\text{fossil}}$ 的累加。这些构成了每步恒定数量的基本操作。我们通过以下方式对运行时间代理进行建模\n$$\n\\mathcal{T} = c_{\\text{ops}} \\, N,\n$$\n其中 $c_{\\text{ops}}$ 是固定的；这里我们设置 $c_{\\text{ops}} = 40$ 来代表每步合理的恒定基本操作数。此代理在计算操作意义上是无量纲的，不是物理时间。\n\n为了在给定视域的候选分辨率中，根据 $(\\mathcal{T}, \\varepsilon)$ 的双标准最小化计算帕累托前沿，我们按如下方式进行。令 $\\{ (\\mathcal{T}_i, \\varepsilon_i, \\Delta t_i) \\}_{i=1}^M$ 为评估点的集合。如果存在 $j$ 使得 $\\mathcal{T}_j \\le \\mathcal{T}_i$ 且 $\\varepsilon_j \\le \\varepsilon_i$ 并至少有一个严格不等式成立，则点 $i$ 被支配。非支配集即为帕累托前沿。由于 $\\mathcal{T}$ 随着 $\\Delta t$ 减小而单调增加，并且我们期望 $\\varepsilon$ 随着 $\\Delta t$ 减小而减小，一个简单的前沿提取算法是按 $\\mathcal{T}$ 递增排序点，并保留相对于当前最小值 $\\varepsilon$ 严格递减的点。\n\n为了识别收益递减，我们使用以下公式将 $\\mathcal{T}$ 和 $\\varepsilon$ 归一化到 $x \\in [0,1]$ 和 $y \\in [0,1]$：\n$$\nx_i = \\frac{\\mathcal{T}_i - \\min_j \\mathcal{T}_j}{\\max_j \\mathcal{T}_j - \\min_j \\mathcal{T}_j}, \\quad\ny_i = \\frac{\\varepsilon_i - \\min_j \\varepsilon_j}{\\max_j \\varepsilon_j - \\min_j \\varepsilon_j}。\n$$\n我们沿 $x$ 递增的方向遍历前沿，并计算连续点之间的局部斜率 $\\Delta y / \\Delta x$。收益递减的开始是第一个索引 $k$，对于该索引\n$$\n\\left| \\frac{y_k - y_{k-1}}{x_k - x_{k-1}} \\right|  \\tau,\n$$\n其中 $\\tau = 0.15$。该标准检测单位运行时间的边际质量改进何时相对于归一化尺度变小。如果不存在这样的 $k$（即，在所有点上改进都保持陡峭），我们选择最小化 $x_i + y_i$ 的点，以在归一化空间中平衡运行时间和误差。\n\n我们将此程序应用于三个测试用例：\n\n- Case A: $H = 24$, $L(t) = L_b + A_L \\sin( 2\\pi t / 24 ) + B_L \\sin( 2\\pi t / (24 \\cdot 7) + \\psi )$ 其中 $(L_b, A_L, B_L, \\psi) = (50, 10, 5, 0.3)$; $R(t) = A_R \\max(0, \\sin( 2\\pi (t \\bmod 24)/24 - \\pi/2))$ 其中 $A_R = 30$; 储能 $(S_{\\max}, P_c, P_d, \\eta_c, \\eta_d, s_0) = (50, 20, 20, 0.95, 0.90, 25)$; 候选 $\\Delta t \\in \\{8,4,2,1,0.5\\}$; 参考 $\\Delta t_{\\text{ref}} = 0.125$; $c_{\\text{ops}} = 40$; $\\tau = 0.15$。\n\n- Case B: $H = 6$, $L(t) = L_b + A_L \\sin( 2\\pi t / 24 + \\phi )$ 其中 $(L_b, A_L, \\phi) = (60, 15, -0.5)$; $R(t)$ 同上，但 $A_R = 10$; 储能 $(S_{\\max}, P_c, P_d, \\eta_c, \\eta_d, s_0) = (30, 15, 15, 0.95, 0.90, 15)$; 候选 $\\Delta t \\in \\{3,2,1,0.5,0.25\\}$; 参考 $\\Delta t_{\\text{ref}} = 0.125$; $c_{\\text{ops}} = 40$; $\\tau = 0.15$。\n\n- Case C: $H = 168$, $L(t) = L_b + A_L \\sin( 2\\pi t / 24 ) + B_L \\sin( 2\\pi t / (24 \\cdot 7) + \\psi )$ 其中 $(L_b, A_L, B_L, \\psi) = (55, 8, 12, -0.7)$; $R(t)$ 同上，但 $A_R = 25$; 储能 $(S_{\\max}, P_c, P_d, \\eta_c, \\eta_d, s_0) = (200, 50, 50, 0.95, 0.90, 100)$; 候选 $\\Delta t \\in \\{24,12,6,3,1.5\\}$; 参考 $\\Delta t_{\\text{ref}} = 0.125$; $c_{\\text{ops}} = 40$; $\\tau = 0.15$。\n\n最终输出必须是包含 Case A、Case B 和 Case C 的收益递减分辨率的单行文本，单位为小时，四舍五入到两位小数，以逗号分隔的列表形式放在方括号内。例如，$\\text{[8.00,3.00,12.00]}$。\n\n算法步骤：\n\n1. 对于每个案例，使用 $\\Delta t_{\\text{ref}}$ 通过在 $N_{\\text{ref}} = H / \\Delta t_{\\text{ref}}$ 个中点样本上模拟储能策略来计算 $E_{\\text{fossil}}^{\\text{ref}}$。\n2. 对于每个候选 $\\Delta t$，计算 $E_{\\text{fossil}}$ 和误差 $\\varepsilon = | E_{\\text{fossil}} - E_{\\text{fossil}}^{\\text{ref}} |$；计算 $\\mathcal{T} = c_{\\text{ops}} \\cdot (H / \\Delta t)$。\n3. 通过按 $\\mathcal{T}$ 递增排序点并保留那些相对于当前最小值 $\\varepsilon$ 严格递减的点来提取帕累托前沿。\n4. 将 $\\mathcal{T}$ 和 $\\varepsilon$ 归一化为 $(x,y)$；扫描连续点并选择 $| \\Delta y / \\Delta x |  \\tau$ 的第一个索引；如果没有，则选择 $x + y$ 最小的点。\n5. 按指定格式输出每个案例选择的 $\\Delta t$，四舍五入到两位小数。\n\n此过程尊重能量守恒的基本定律，使用经过充分测试的数值离散化方法，并通过基本操作计数构建了一个可复现的运行时间概念。它通过改变 $H$ 和 $\\Delta t$ 来测试短期和长期时域设计，并产生可量化的、带有单位意识的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef load_case_A(t):\n    # L(t) = L_b + A_L * sin(2π t / 24) + B_L * sin(2π t / (24*7) + psi)\n    L_b, A_L, B_L, psi = 50.0, 10.0, 5.0, 0.3\n    return L_b + A_L * np.sin(2.0 * np.pi * t / 24.0) + B_L * np.sin(2.0 * np.pi * t / (24.0 * 7.0) + psi)\n\ndef load_case_B(t):\n    # L(t) = L_b + A_L * sin(2π t / 24 + phi)\n    L_b, A_L, phi = 60.0, 15.0, -0.5\n    return L_b + A_L * np.sin(2.0 * np.pi * t / 24.0 + phi)\n\ndef load_case_C(t):\n    # L(t) = L_b + A_L * sin(2π t / 24) + B_L * sin(2π t / (24*7) + psi)\n    L_b, A_L, B_L, psi = 55.0, 8.0, 12.0, -0.7\n    return L_b + A_L * np.sin(2.0 * np.pi * t / 24.0) + B_L * np.sin(2.0 * np.pi * t / (24.0 * 7.0) + psi)\n\ndef solar_R(t, A_R):\n    # R(t) = A_R * max(0, sin(2π (t mod 24)/24 - π/2))\n    tmod = np.mod(t, 24.0)\n    val = np.sin(2.0 * np.pi * tmod / 24.0 - np.pi / 2.0)\n    return A_R * np.maximum(0.0, val)\n\ndef simulate_storage(H, dt, load_func, A_R, S_max, P_c, P_d, eta_c, eta_d, s0):\n    \"\"\"\n    Simulate greedy storage over horizon H with step dt.\n    Returns total fossil energy E_fossil (MWh).\n    \"\"\"\n    N = int(round(H / dt))\n    # Ensure exact division\n    if abs(N * dt - H) > 1e-9:\n        raise ValueError(\"H must be divisible by dt\")\n    s = s0\n    E_fossil = 0.0\n    for k in range(N):\n        t_mid = (k + 0.5) * dt\n        Lk = load_func(t_mid)\n        rk = solar_R(t_mid, A_R)\n        sigma = rk - Lk  # surplus if positive, deficit if negative\n        g = 0.0\n        if sigma > 0.0:\n            # Charging\n            # Max charge power from surplus and device limits; also ensure not exceeding S_max\n            max_charge_power_by_headroom = (S_max - s) / (eta_c * dt) if eta_c * dt > 0 else float('inf')\n            c_power = min(P_c, sigma, max_charge_power_by_headroom)\n            s += eta_c * c_power * dt\n        elif sigma  0.0:\n            deficit = -sigma\n            # Discharging\n            max_discharge_power_by_state = (s * eta_d) / dt if dt > 0 else 0.0\n            d_power = min(P_d, max_discharge_power_by_state, deficit)\n            s -= (d_power * dt) / eta_d if eta_d > 0 else 0.0\n            # Remaining deficit met by thermal generation\n            g = deficit - d_power\n        \n        # Enforce numerical bounds\n        s = np.clip(s, 0, S_max)\n        E_fossil += g * dt\n    return E_fossil\n\ndef pareto_frontier(points):\n    \"\"\"\n    points: list of tuples (runtime_ops, error_MWh, dt)\n    Returns frontier sorted by runtime_ops ascending with strictly decreasing error.\n    \"\"\"\n    pts_sorted = sorted(points, key=lambda x: (x[0], x[1]))\n    frontier = []\n    best_err = np.inf\n    for rt, err, dt in pts_sorted:\n        # Keep point if it improves error (strictly less than best_err)\n        if err  best_err - 1e-12:\n            frontier.append((rt, err, dt))\n            best_err = err\n    return frontier\n\ndef select_knee(frontier, tau=0.15):\n    \"\"\"\n    Given frontier [(rt, err, dt), ...], select diminishing-returns resolution dt.\n    Uses normalized slope threshold tau; fallback minimizes x + y.\n    \"\"\"\n    if not frontier:\n        return None\n    if len(frontier) == 1:\n        return float(frontier[0][2])\n\n    rts = np.array([p[0] for p in frontier], dtype=float)\n    errs = np.array([p[1] for p in frontier], dtype=float)\n    dts = [p[2] for p in frontier]\n    \n    # Normalize to [0,1]\n    rt_min, rt_max = rts.min(), rts.max()\n    err_min, err_max = errs.min(), errs.max()\n\n    x = (rts - rt_min) / (rt_max - rt_min) if (rt_max - rt_min) > 1e-9 else np.zeros_like(rts)\n    y = (errs - err_min) / (err_max - err_min) if (err_max - err_min) > 1e-9 else np.zeros_like(errs)\n    \n    # Traverse in increasing x; check slopes between consecutive points\n    knee_idx = None\n    for i in range(1, len(x)):\n        dx = x[i] - x[i - 1]\n        dy = y[i] - y[i - 1]\n        slope = abs(dy / dx) if dx > 1e-9 else np.inf\n        if slope  tau:\n            knee_idx = i\n            break\n            \n    if knee_idx is None:\n        # Fallback: minimize x + y\n        scores = x + y\n        knee_idx = int(np.argmin(scores))\n        \n    return float(dts[knee_idx])\n\ndef solve():\n    # Constants\n    dt_ref = 0.125  # hours\n    c_ops = 40      # operations per step\n    tau = 0.15      # slope threshold (dimensionless)\n\n    # Define test cases\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"H\": 24.0,\n            \"load_func\": load_case_A,\n            \"A_R\": 30.0,\n            \"S_max\": 50.0,\n            \"P_c\": 20.0,\n            \"P_d\": 20.0,\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.90,\n            \"s0\": 25.0,\n            \"dts\": [8.0, 4.0, 2.0, 1.0, 0.5],\n        },\n        {\n            \"name\": \"B\",\n            \"H\": 6.0,\n            \"load_func\": load_case_B,\n            \"A_R\": 10.0,\n            \"S_max\": 30.0,\n            \"P_c\": 15.0,\n            \"P_d\": 15.0,\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.90,\n            \"s0\": 15.0,\n            \"dts\": [3.0, 2.0, 1.0, 0.5, 0.25],\n        },\n        {\n            \"name\": \"C\",\n            \"H\": 168.0,\n            \"load_func\": load_case_C,\n            \"A_R\": 25.0,\n            \"S_max\": 200.0,\n            \"P_c\": 50.0,\n            \"P_d\": 50.0,\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.90,\n            \"s0\": 100.0,\n            \"dts\": [24.0, 12.0, 6.0, 3.0, 1.5],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        H = case[\"H\"]\n        load_func = case[\"load_func\"]\n        A_R = case[\"A_R\"]\n        S_max = case[\"S_max\"]\n        P_c = case[\"P_c\"]\n        P_d = case[\"P_d\"]\n        eta_c = case[\"eta_c\"]\n        eta_d = case[\"eta_d\"]\n        s0 = case[\"s0\"]\n        dts = case[\"dts\"]\n\n        # Reference fossil energy at fine resolution\n        E_ref = simulate_storage(H, dt_ref, load_func, A_R, S_max, P_c, P_d, eta_c, eta_d, s0)\n\n        # Evaluate candidate resolutions\n        points = []\n        for dt in dts:\n            E_fossil = simulate_storage(H, dt, load_func, A_R, S_max, P_c, P_d, eta_c, eta_d, s0)\n            err = abs(E_fossil - E_ref)  # MWh\n            N = int(round(H / dt))\n            runtime_ops = c_ops * N\n            points.append((runtime_ops, err, dt))\n\n        # Compute Pareto frontier and knee\n        frontier = pareto_frontier(points)\n        knee_dt = select_knee(frontier, tau=tau)\n        results.append(round(knee_dt, 2))\n\n    print(f\"[{','.join(map(lambda x: f'{x:.2f}', results))}]\")\n\nsolve()\n```"
        }
    ]
}