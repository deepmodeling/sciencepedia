{
    "hands_on_practices": [
        {
            "introduction": "Siting models for energy infrastructure often begin by converting continuous, real-world landscapes into discrete digital grids, or rasters. The choice of grid resolution—for example, using 1 km versus 100 m pixels—is a fundamental decision about model granularity that can profoundly affect the outcome. This practice  allows you to directly quantify how raster resolution influences a renewable energy siting analysis, providing a tangible understanding of the trade-off between capturing local detail and the accuracy of the final solution.",
            "id": "4124067",
            "problem": "Consider a square planning region of side length $L$ measured in kilometers, with coordinates $(x,y)$ spanning the continuous domain $[0,L] \\times [0,L]$. Two spatially varying continuous fields are defined over this domain: a capacity density field $r(x,y)$ measured in Megawatts per square kilometer (Megawatt (MW) per $\\mathrm{km}^2$) and a cost density field $q(x,y)$ measured in United States dollars per square kilometer (U.S. dollars (USD) per $\\mathrm{km}^2$). A siting model selects locations within the region to build projects, with the objective of maximizing total capacity subject to either a budget constraint or an area limit. Spatial representation of the fields is carried out via a raster with two different pixel sizes to study sensitivity to model granularity: a fine raster with pixel size $100\\,\\mathrm{m}$ and a coarse raster with pixel size $1\\,\\mathrm{km}$. Pixel values are defined as the average of the underlying continuous field over the pixel area.\n\nFundamental base for siting decision: Under a budget constraint of $B$ dollars, the continuous optimization problem of maximizing total capacity subject to a total cost not exceeding $B$ and allowing fractional spatial selection reduces to a fractional knapsack formulation. In its discretized raster form, for pixels indexed by $i$ with capacity density $\\bar{r}_i$ and cost density $\\bar{q}_i$ (both defined as pixel-area averages of $r$ and $q$), and pixel area $a_i$, the optimal selection rule is to sort pixels by the value-to-cost ratio $\\bar{r}_i / \\bar{q}_i$ and select pixels in descending order of this ratio, allowing partial selection of the final pixel to exactly satisfy the budget. Under an area limit $A$ measured in $\\mathrm{km}^2$ (with no explicit budget constraint), the objective of maximizing total capacity with an area constraint and allowing fractional spatial selection reduces to selecting pixels in descending order of $\\bar{r}_i$ until the total selected area equals $A$, allowing partial selection of the final pixel if necessary.\n\nDefine the planning region size as $L = 10\\,\\mathrm{km}$, and two scenarios for the continuous fields:\n- Scenario $\\mathcal{H}$ (heterogeneous fields): \n  - Capacity density $r(x,y)$ is a smooth function with localized peaks:\n    $$r(x,y) = 5 + 20\\exp\\!\\left(-\\frac{(x-2)^2 + (y-7)^2}{0.4^2}\\right) + 10\\exp\\!\\left(-\\frac{(x-8)^2 + (y-3)^2}{0.6^2}\\right) + 3\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L}\\right),$$\n    measured in $\\mathrm{MW}/\\mathrm{km}^2$.\n  - Cost density $q(x,y)$ is a smooth positive field:\n    $$q(x,y) = 120{,}000 + 50{,}000\\exp\\!\\left(-\\frac{(x-5)^2 + (y-5)^2}{1.2^2}\\right) + 30{,}000\\sin\\!\\left(\\frac{2\\pi y}{L}\\right),$$\n    measured in $\\mathrm{USD}/\\mathrm{km}^2$.\n- Scenario $\\mathcal{U}$ (uniform fields):\n  - Capacity density $r(x,y) = 8\\,\\mathrm{MW}/\\mathrm{km}^2$ for all $(x,y)$.\n  - Cost density $q(x,y) = 100,000\\,\\mathrm{USD}/\\mathrm{km}^2$ for all $(x,y)$.\n\nRasterization rule: For a raster pixel size $\\Delta$ measured in kilometers, the domain is partitioned into square pixels of side length $\\Delta$. For each pixel $i$, the averaged capacity density $\\bar{r}_i$ and averaged cost density $\\bar{q}_i$ are defined as the area means of $r(x,y)$ and $q(x,y)$ over the pixel area. In computation, approximate the area mean via uniform sub-sampling within each pixel: use $n_{\\text{sub}} = 3$ samples per dimension for $\\Delta = 0.1\\,\\mathrm{km}$ (corresponding to $100\\,\\mathrm{m}$ pixels) and $n_{\\text{sub}} = 10$ samples per dimension for $\\Delta = 1\\,\\mathrm{km}$ pixels. The pixel area is $a_i = \\Delta^2$ $\\mathrm{km}^2$.\n\nSiting model outputs: For a given scenario and constraint type, compute the total selected capacity in $\\mathrm{MW}$ and the total selected cost in $\\mathrm{USD}$ for both raster resolutions. Under a budget $B$, select pixels to maximize total capacity subject to total cost not exceeding $B$, allowing partial selection of the final pixel so the cost exactly equals $B$ unless the set of pixels with positive capacity-to-cost ratio is exhausted. Under an area limit $A$, select pixels to maximize total capacity subject to total selected area exactly equalling $A$, allowing partial selection of the final pixel. Quantify sensitivity to raster resolution by reporting, for each test case, the difference in total capacity (fine minus coarse) in $\\mathrm{MW}$ and the difference in total cost (fine minus coarse) in $\\mathrm{USD}$.\n\nTest suite:\n- Test case $1$ (happy path, budget-constrained, heterogeneous fields): scenario $\\mathcal{H}$ with budget $B = 10{,}000{,}000$ $\\mathrm{USD}$.\n- Test case $2$ (area-limited, heterogeneous fields): scenario $\\mathcal{H}$ with area limit $A = 20$ $\\mathrm{km}^2$.\n- Test case $3$ (boundary case, uniform fields): scenario $\\mathcal{U}$ with budget $B = 5{,}000{,}000$ $\\mathrm{USD}$.\n\nYour program must:\n- Implement the raster averaging as specified.\n- Solve the selection problem using the fractional knapsack approach for budget constraints (sort by $\\bar{r}_i / \\bar{q}_i$) and the area-limited selection rule (sort by $\\bar{r}_i$).\n- Compute, for each test case, the capacity difference in $\\mathrm{MW}$ and the cost difference in $\\mathrm{USD}$ between the $100\\,\\mathrm{m}$ raster and the $1\\,\\mathrm{km}$ raster (fine minus coarse).\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\Delta C_1, \\Delta \\text{Cost}_1, \\Delta C_2, \\Delta \\text{Cost}_2, \\Delta C_3, \\Delta \\text{Cost}_3]$, where $\\Delta C_k$ is the capacity difference in $\\mathrm{MW}$ for test case $k$, and $\\Delta \\text{Cost}_k$ is the cost difference in $\\mathrm{USD}$ for test case $k$. Express all outputs as floating-point numbers in the specified units.\n\nAll numerical constants, variables, and operators in this problem are to be treated using their standard mathematical meanings. Angles do not appear in this problem; thus no angle unit specification is required.",
            "solution": "The user has provided a computational problem in the domain of energy systems modeling, focusing on the impact of spatial granularity on siting decisions. The problem requires the calculation of total installed capacity and cost for different scenarios and spatial resolutions, followed by a sensitivity analysis.\n\n### Step 1: Problem Validation\n\nThe submitted problem has been meticulously validated against the specified criteria.\n\n-   **Givens Extracted**:\n    -   **Domain**: Square region $[0, 10\\,\\mathrm{km}] \\times [0, 10\\,\\mathrm{km}]$.\n    -   **Fields**: Capacity density $r(x,y)$ ($\\mathrm{MW}/\\mathrm{km}^2$) and cost density $q(x,y)$ ($\\mathrm{USD}/\\mathrm{km}^2$).\n    -   **Scenarios**: Heterogeneous ($\\mathcal{H}$) and Uniform ($\\mathcal{U}$), with explicit mathematical functions provided for $r(x,y)$ and $q(x,y)$.\n    -   **Rasterization**: Two resolutions: fine ($\\Delta = 0.1\\,\\mathrm{km}$) and coarse ($\\Delta = 1\\,\\mathrm{km}$).\n    -   **Averaging Rule**: Pixel values are approximated by sub-sampling, with $n_{\\text{sub}}=3$ for fine and $n_{\\text{sub}}=10$ for coarse resolution.\n    -   **Optimization (Budget)**: Fractional knapsack approach; sort by $\\bar{r}_i/\\bar{q}_i$ ratio, select until budget $B$ is met.\n    -   **Optimization (Area)**: Greedy approach; sort by $\\bar{r}_i$, select until area limit $A$ is met.\n    -   **Test Cases**:\n        1.  $\\mathcal{H}$, Budget $B = 10{,}000{,}000\\,\\mathrm{USD}$.\n        2.  $\\mathcal{H}$, Area $A = 20\\,\\mathrm{km}^2$.\n        3.  $\\mathcal{U}$, Budget $B = 5{,}000{,}000\\,\\mathrm{USD}$.\n    -   **Output**: Differences (fine minus coarse) in total capacity ($\\mathrm{MW}$) and total cost ($\\mathrm{USD}$) for each test case.\n\n-   **Validation Assessment**:\n    1.  **Scientific Grounding**: The problem is well-grounded in operations research and spatial analysis as applied to energy systems. The functions and parameters are physically and economically plausible for a modeling study. The cost density function $q(x,y)$ is confirmed to be strictly positive, preventing division by zero in the value-to-cost ratio.\n    2.  **Well-Posedness**: The problem is well-posed. The use of fractional knapsack and greedy algorithms provides a unique, stable solution for each case. All necessary data and rules are provided.\n    3.  **Objectivity**: The problem is stated using precise mathematical language and objective criteria, free from ambiguity or subjective claims.\n\n-   **Verdict**: The problem is **valid**. It is a well-defined computational exercise that can be solved as stated.\n\n### Step 2: Solution Design\n\nThe solution involves implementing the specified spatial discretization and optimization algorithms. The process is broken down into modular components: field definition, rasterization, and selection.\n\n#### 1. Field Representation\nThe continuous density fields $r(x,y)$ and $q(x,y)$ for both scenarios, $\\mathcal{H}$ and $\\mathcal{U}$, are implemented as standard mathematical functions. These functions are designed to operate on coordinate arrays to enable efficient, vectorized computation using the `numpy` library.\n\n#### 2. Spatial Discretization and Averaging\nA core function is developed to perform the rasterization of the continuous domain. This operation partitions the $10\\,\\mathrm{km} \\times 10\\,\\mathrm{km}$ region into a grid of square pixels.\n-   For the fine resolution, the side length is $\\Delta = 0.1\\,\\mathrm{km}$, resulting in a $100 \\times 100$ grid.\n-   For the coarse resolution, the side length is $\\Delta = 1\\,\\mathrm{km}$, resulting in a $10 \\times 10$ grid.\n\nFor each pixel in the grid, the average density values, $\\bar{r}_i$ and $\\bar{q}_i$, are computed as specified. This is accomplished by generating a uniform sub-grid of sample points within each pixel, evaluating the continuous field functions at these points, and calculating the arithmetic mean. The number of samples per dimension is $n_{\\text{sub}}=3$ for fine pixels and $n_{\\text{sub}}=10$ for coarse pixels. The result of this stage is a list of all pixels, each characterized by its computed average capacity and cost densities.\n\n#### 3. Optimization and Selection Algorithms\nThe selection of pixels to site projects is performed according to the specified constraint type.\n\n-   **Budget-Constrained Selection**: This case follows a fractional knapsack paradigm.\n    1.  For each pixel $i$, the value-to-cost ratio $\\bar{r}_i / \\bar{q}_i$ is calculated.\n    2.  Pixels are sorted in descending order based on this ratio.\n    3.  The algorithm iterates through the sorted list, \"selecting\" pixels fully as long as the cumulative cost does not exceed the budget $B$.\n    4.  The final pixel that would cause the budget to be exceeded is selected partially. The fraction of this pixel selected is calculated to meet the budget $B$ exactly.\n    5.  Total capacity and total cost are accumulated. The final cost will be equal to $B$, unless the total cost of all pixels with a positive ratio is less than $B$.\n\n-   **Area-Constrained Selection**: This case uses a simpler greedy algorithm.\n    1.  Pixels are sorted in descending order based on their average capacity density $\\bar{r}_i$.\n    2.  The algorithm iterates through the sorted list, selecting pixels fully until the cumulative area equals the area limit $A$.\n    3.  Similar to the budget case, the final pixel is selected fractionally to meet the area limit $A$ exactly.\n    4.  Both total capacity and total cost are accumulated over the selected full and partial pixels.\n\n#### 4. Execution and Output Generation\nA main driver function executes the simulation for each of the three test cases. For each case, the process (rasterization and selection) is run twice: once for the fine resolution and once for the coarse resolution.\n\nThe total capacity and total cost from the coarse model are subtracted from a corresponding fine model to compute the differences, $\\Delta C_k$ and $\\Delta \\text{Cost}_k$, for each test case $k$. These six values are then collected and formatted into a single comma-separated string enclosed in square brackets as required. The uniform field scenario (Test Case 3) serves as an important sanity check, as the uniform densities should lead to zero difference between the resolutions, independent of the selection algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n#\n# --- Field Function Definitions ---\n#\n\ndef r_h(x, y, L=10.0):\n    \"\"\"\n    Computes heterogeneous capacity density r(x,y).\n    \"\"\"\n    term1 = 20.0 * np.exp(-((x - 2.0)**2 + (y - 7.0)**2) / 0.4**2)\n    term2 = 10.0 * np.exp(-((x - 8.0)**2 + (y - 3.0)**2) / 0.6**2)\n    term3 = 3.0 * np.sin(2.0 * np.pi * x / L) * np.cos(2.0 * np.pi * y / L)\n    return 5.0 + term1 + term2 + term3\n\ndef q_h(x, y, L=10.0):\n    \"\"\"\n    Computes heterogeneous cost density q(x,y).\n    \"\"\"\n    term1 = 50000.0 * np.exp(-((x - 5.0)**2 + (y - 5.0)**2) / 1.2**2)\n    term2 = 30000.0 * np.sin(2.0 * np.pi * y / L)\n    return 120000.0 + term1 + term2\n\ndef r_u(x, y, L=10.0):\n    \"\"\"\n    Computes uniform capacity density r(x,y).\n    Vectorized to handle array inputs.\n    \"\"\"\n    if isinstance(x, np.ndarray):\n        return np.full(x.shape, 8.0)\n    return 8.0\n\ndef q_u(x, y, L=10.0):\n    \"\"\"\n    Computes uniform cost density q(x,y).\n    Vectorized to handle array inputs.\n    \"\"\"\n    if isinstance(x, np.ndarray):\n        return np.full(x.shape, 100000.0)\n    return 100000.0\n\n#\n# --- Core Solver for a Given Resolution ---\n#\n\ndef solve_for_resolution(scenario, constraint_type, constraint_value, resolution):\n    \"\"\"\n    Solves the siting problem for a given scenario, constraint, and resolution.\n    \"\"\"\n    L = 10.0\n\n    if resolution == 'fine':\n        delta = 0.1\n        n_sub = 3\n    elif resolution == 'coarse':\n        delta = 1.0\n        n_sub = 10\n    else:\n        raise ValueError(\"Invalid resolution\")\n    \n    N = int(L / delta)\n    pixel_area = delta**2\n\n    if scenario == 'H':\n        r_func, q_func = r_h, q_h\n    elif scenario == 'U':\n        r_func, q_func = r_u, q_u\n    else:\n        raise ValueError(\"Invalid scenario\")\n\n    # Generate list of pixels with their properties\n    pixels = []\n    sub_offsets = (np.arange(n_sub) + 0.5) / n_sub * delta\n    \n    for j in range(N):\n        for k in range(N):\n            x_base = j * delta\n            y_base = k * delta\n            \n            # Generate sub-sample coordinates using meshgrid\n            sub_x, sub_y = np.meshgrid(x_base + sub_offsets, y_base + sub_offsets)\n            \n            # Evaluate fields at sub-sample points and average\n            r_avg = np.mean(r_func(sub_x, sub_y))\n            q_avg = np.mean(q_func(sub_x, sub_y))\n            \n            pixels.append({'r_avg': r_avg, 'q_avg': q_avg})\n\n    # Selection process\n    total_capacity = 0.0\n    total_cost = 0.0\n\n    if constraint_type == 'budget':\n        budget = constraint_value\n        \n        # Calculate ratio and filter for positive-ratio pixels\n        # Since q is always positive, this means r > 0. r is also always positive.\n        positive_pixels = [p for p in pixels if p['r_avg'] > 0 and p['q_avg'] > 0]\n        for p in positive_pixels:\n            p['ratio'] = p['r_avg'] / p['q_avg']\n        \n        sorted_pixels = sorted(positive_pixels, key=lambda p: p['ratio'], reverse=True)\n        \n        for p in sorted_pixels:\n            pixel_cost = p['q_avg'] * pixel_area\n            pixel_capacity = p['r_avg'] * pixel_area\n            \n            if total_cost + pixel_cost = budget:\n                total_cost += pixel_cost\n                total_capacity += pixel_capacity\n            else:\n                remaining_budget = budget - total_cost\n                if pixel_cost > 0:\n                    fraction = remaining_budget / pixel_cost\n                    total_cost += fraction * pixel_cost\n                    total_capacity += fraction * pixel_capacity\n                break\n        \n    elif constraint_type == 'area':\n        area_limit = constraint_value\n        \n        # Sort by capacity density\n        sorted_pixels = sorted(pixels, key=lambda p: p['r_avg'], reverse=True)\n        \n        total_area = 0.0\n        for p in sorted_pixels:\n            if total_area + pixel_area = area_limit:\n                total_area += pixel_area\n                total_capacity += p['r_avg'] * pixel_area\n                total_cost += p['q_avg'] * pixel_area\n            else:\n                remaining_area = area_limit - total_area\n                fraction = remaining_area / pixel_area\n                total_area += fraction * pixel_area\n                total_capacity += fraction * p['r_avg'] * pixel_area\n                total_cost += fraction * p['q_avg'] * pixel_area\n                break\n\n    return total_capacity, total_cost\n\n#\n# --- Main Execution Block ---\n#\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'scenario': 'H', 'constraint_type': 'budget', 'constraint_value': 10000000.0},\n        # Test case 2\n        {'scenario': 'H', 'constraint_type': 'area', 'constraint_value': 20.0},\n        # Test case 3\n        {'scenario': 'U', 'constraint_type': 'budget', 'constraint_value': 5000000.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Solve for fine resolution\n        cap_fine, cost_fine = solve_for_resolution(\n            case['scenario'], case['constraint_type'], case['constraint_value'], 'fine'\n        )\n        \n        # Solve for coarse resolution\n        cap_coarse, cost_coarse = solve_for_resolution(\n            case['scenario'], case['constraint_type'], case['constraint_value'], 'coarse'\n        )\n        \n        # Calculate differences (fine - coarse)\n        delta_C = cap_fine - cap_coarse\n        delta_Cost = cost_fine - cost_coarse\n        \n        results.append(delta_C)\n        results.append(delta_Cost)\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "For computational tractability, energy system models often aggregate individual nodes into larger zones. However, the way these zones are defined is not always objective and can significantly alter model results, a phenomenon known as the Modifiable Areal Unit Problem (MAUP). This exercise  provides a striking and quantifiable demonstration of MAUP, showing how two different but plausible zoning schemes can lead to contradictory investment signals from the same underlying data.",
            "id": "4124078",
            "problem": "Consider a synthetic energy system with four nodes and a single interzonal transmission interface. Each node $i \\in \\{1,2,3,4\\}$ has a fixed demand $D_i$ in megawatts (MW), a single generator with maximum capacity $\\overline{G}_i$ in MW, and a constant marginal cost $c_i$ in dollars per megawatt-hour ($\\$/\\text{MWh}$). The system is operated under least-cost dispatch and a transmission planning rule that evaluates whether reinforcement of the interzonal interface is recommended. The system must satisfy energy balance, meaning total generation equals total demand.\n\nThe fundamental base is as follows:\n- Energy balance: $$\\sum_{i=1}^{4} g_i = \\sum_{i=1}^{4} D_i,$$ where $g_i$ is the dispatched generation at node $i$ in MW.\n- Operational feasibility: $$0 \\le g_i \\le \\overline{G}_i \\quad \\text{for all } i.$$\n- Cost minimization: The least-cost dispatch minimizes $$\\sum_{i=1}^{4} c_i g_i$$ subject to the constraints above, and assumes that interzonal transmission capacity does not bind for the purpose of computing the unconstrained least-cost dispatch.\n\nDefine two zoning schemes that partition the four nodes into two zones each, thereby inducing different interzonal interfaces:\n- Zoning scheme $\\mathcal{Z}_A$: West zone $W_A = \\{1,2\\}$ and East zone $E_A = \\{3,4\\}$.\n- Zoning scheme $\\mathcal{Z}_B$: West zone $W_B = \\{1,3\\}$ and East zone $E_B = \\{2,4\\}$.\n\nThe interzonal interface has a capacity $K$ in MW. Under a given zoning scheme $\\mathcal{Z}$, let $G_Z$ denote the total generation in the West zone and $D_Z$ the total demand in the West zone. The required interzonal transfer magnitude $T_{\\mathcal{Z}}$ in MW under unconstrained least-cost dispatch is:\n$$T_{\\mathcal{Z}} = \\left|D_Z - G_Z\\right|.$$\nThis quantity represents the absolute net import of the West zone (equivalently, the absolute net export if $G_Z  D_Z$), and because there are exactly two zones, it equals the magnitude of the corresponding import/export across the interzonal interface.\n\nPlanning rule: Transmission reinforcement is recommended under zoning scheme $\\mathcal{Z}$ if the unconstrained least-cost required interzonal transfer $T_{\\mathcal{Z}}$ strictly exceeds the existing capacity $K$, that is, if $$T_{\\mathcal{Z}}  K.$$\n\nModifiable Areal Unit Problem (MAUP) instability metric: For a pair of zoning schemes $(\\mathcal{Z}_A,\\mathcal{Z}_B)$ and a given capacity $K$, define the binary decision under each scheme as\n$$d_{\\mathcal{Z}} = \\begin{cases}\n1  \\text{if } T_{\\mathcal{Z}}  K,\\\\\n0  \\text{if } T_{\\mathcal{Z}} \\le K.\n\\end{cases}$$\nDefine the MAUP-induced decision instability indicator\n$$I = |d_{\\mathcal{Z}_A} - d_{\\mathcal{Z}_B}|,$$\nand the normalized transfer difference (a dimensionless decimal number)\n$$R = \\frac{\\left|T_{\\mathcal{Z}_A} - T_{\\mathcal{Z}_B}\\right|}{K},$$\nwhere $K  0$ is required. The quantity $I$ is $1$ if the two zoning schemes yield opposite conclusions about the need for reinforcement, and $0$ otherwise; $R$ captures the relative magnitude difference in required interzonal transfers normalized by capacity and must be expressed as a decimal number, not a percentage.\n\nSynthetic system data:\n- Demands: $D_1 = 10$ MW, $D_2 = 10$ MW, $D_3 = 30$ MW, $D_4 = 30$ MW.\n- Generator maximum capacities: $\\overline{G}_1 = 60$ MW, $\\overline{G}_2 = 20$ MW, $\\overline{G}_3 = 40$ MW, $\\overline{G}_4 = 40$ MW.\n- Marginal costs: $c_1 = 20\\,\\$/\\text{MWh}$, $c_2 = 30\\,\\$/\\text{MWh}$, $c_3 = 100\\,\\$/\\text{MWh}$, $c_4 = 120\\,\\$/\\text{MWh}$.\n\nYou must compute the unconstrained least-cost dispatch $g_i$ that satisfies the energy balance and capacity constraints, then compute $T_{\\mathcal{Z}_A}$ and $T_{\\mathcal{Z}_B}$, and finally compute $I$ and $R$ for each test case.\n\nTest suite:\n- Case $1$: $K = 50$ MW (a case designed to yield opposite conclusions).\n- Case $2$: $K = 60$ MW (a boundary case where required transfer equals capacity under one scheme).\n- Case $3$: $K = 10$ MW (a case where both schemes recommend reinforcement).\n- Case $4$: $K = 80$ MW (a case where neither scheme recommends reinforcement).\n\nPhysical units: All power quantities ($D_i$, $g_i$, $\\overline{G}_i$, $T_{\\mathcal{Z}}$, $K$) must be treated and computed in megawatts (MW). All costs are in dollars per megawatt-hour ($\\$/\\text{MWh}$). Angles are not used. Normalized transfer differences $R$ must be expressed as decimal numbers without a percentage sign.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list $[I,R]$. For example, the output format must be:\n$$\\left[ [I_1,R_1],[I_2,R_2],[I_3,R_3],[I_4,R_4] \\right]$$\nwith numeric values replacing the symbols.",
            "solution": "The problem statement has been evaluated and is determined to be **valid**. It is scientifically grounded in the principles of energy system economics (least-cost dispatch), well-posed with a unique and derivable solution, and is stated objectively with all necessary data provided. The problem is a formalizable exploration of the Modifiable Areal Unit Problem (MAUP) in the context of transmission planning.\n\nThe solution proceeds in three primary steps:\n1.  Determination of the unconstrained least-cost dispatch.\n2.  Calculation of the required interzonal transfers for each zoning scheme.\n3.  Evaluation of the instability metrics for each test case.\n\n### Step 1: Unconstrained Least-Cost Dispatch\n\nThe objective is to minimize the total generation cost, $\\sum_{i=1}^{4} c_i g_i$, subject to energy balance and generator capacity constraints. This is achieved by dispatching generators in ascending order of their marginal cost ($c_i$), a principle known as merit-order dispatch, until the total demand is met.\n\nThe system parameters are:\n- Demands: $D_1 = 10$ MW, $D_2 = 10$ MW, $D_3 = 30$ MW, $D_4 = 30$ MW.\n- Generator capacities: $\\overline{G}_1 = 60$ MW, $\\overline{G}_2 = 20$ MW, $\\overline{G}_3 = 40$ MW, $\\overline{G}_4 = 40$ MW.\n- Marginal costs: $c_1 = 20\\,\\$/\\text{MWh}$, $c_2 = 30\\,\\$/\\text{MWh}$, $c_3 = 100\\,\\$/\\text{MWh}$, $c_4 = 120\\,\\$/\\text{MWh}$.\n\nFirst, we calculate the total system demand:\n$$D_{\\text{total}} = \\sum_{i=1}^{4} D_i = 10 + 10 + 30 + 30 = 80 \\text{ MW}$$\n\nThe total available generation capacity is $\\sum \\overline{G}_i = 60+20+40+40 = 160$ MW, which exceeds the total demand, ensuring a feasible solution exists.\n\nThe merit order of the generators, from cheapest to most expensive, is:\n1.  Generator $1$ ($c_1 = 20\\,\\$/\\text{MWh}$)\n2.  Generator $2$ ($c_2 = 30\\,\\$/\\text{MWh}$)\n3.  Generator $3$ ($c_3 = 100\\,\\$/\\text{MWh}$)\n4.  Generator $4$ ($c_4 = 120\\,\\$/\\text{MWh}$)\n\nWe dispatch generators sequentially to meet the $80$ MW demand:\n- Dispatch Generator $1$: Its capacity is $\\overline{G}_1 = 60$ MW. We dispatch it fully.\n  - $g_1 = 60$ MW.\n  - Demand remaining: $80 - 60 = 20$ MW.\n- Dispatch Generator $2$: Its capacity is $\\overline{G}_2 = 20$ MW. We use its full capacity to meet the remaining demand.\n  - $g_2 = 20$ MW.\n  - Demand remaining: $20 - 20 = 0$ MW.\n- The total demand is now met. Generators $3$ and $4$ are not needed.\n  - $g_3 = 0$ MW.\n  - $g_4 = 0$ MW.\n\nThe unconstrained least-cost dispatch vector is $g = (g_1, g_2, g_3, g_4) = (60, 20, 0, 0)$ MW.\n\n### Step 2: Calculation of Interzonal Transfers\n\nUsing the dispatch results from Step 1, we calculate the required interzonal transfer $T_{\\mathcal{Z}} = |D_Z - G_Z|$ for each zoning scheme, where $Z$ represents the respective West zone.\n\n**Zoning Scheme $\\mathcal{Z}_A$**:\n- West zone $W_A = \\{1,2\\}$, East zone $E_A = \\{3,4\\}$.\n- Demand in West zone: $D_{W_A} = D_1 + D_2 = 10 + 10 = 20$ MW.\n- Generation in West zone: $G_{W_A} = g_1 + g_2 = 60 + 20 = 80$ MW.\n- Required transfer: $T_{\\mathcal{Z}_A} = |D_{W_A} - G_{W_A}| = |20 - 80| = 60$ MW.\n\n**Zoning Scheme $\\mathcal{Z}_B$**:\n- West zone $W_B = \\{1,3\\}$, East zone $E_B = \\{2,4\\}$.\n- Demand in West zone: $D_{W_B} = D_1 + D_3 = 10 + 30 = 40$ MW.\n- Generation in West zone: $G_{W_B} = g_1 + g_3 = 60 + 0 = 60$ MW.\n- Required transfer: $T_{\\mathcal{Z}_B} = |D_{W_B} - G_{W_B}| = |40 - 60| = 20$ MW.\n\n### Step 3: Evaluation of Test Cases\n\nWe now evaluate the instability indicator $I = |d_{\\mathcal{Z}_A} - d_{\\mathcal{Z}_B}|$ and the normalized transfer difference $R = \\frac{|T_{\\mathcal{Z}_A} - T_{\\mathcal{Z}_B}|}{K}$ for each provided capacity $K$. The decision variable $d_{\\mathcal{Z}}$ is $1$ if $T_{\\mathcal{Z}}  K$ and $0$ otherwise. The absolute difference in transfers is a constant for all cases: $|T_{\\mathcal{Z}_A} - T_{\\mathcal{Z}_B}| = |60 - 20| = 40$ MW.\n\n**Case 1: $K = 50$ MW**\n- $d_{\\mathcal{Z}_A}$: $T_{\\mathcal{Z}_A} = 60  50$, so $d_{\\mathcal{Z}_A} = 1$.\n- $d_{\\mathcal{Z}_B}$: $T_{\\mathcal{Z}_B} = 20 \\le 50$, so $d_{\\mathcal{Z}_B} = 0$.\n- $I_1 = |1 - 0| = 1$.\n- $R_1 = \\frac{40}{50} = 0.8$.\n- Result: $[1, 0.8]$.\n\n**Case 2: $K = 60$ MW**\n- $d_{\\mathcal{Z}_A}$: $T_{\\mathcal{Z}_A} = 60 \\ngtr 60$ (the condition is strict inequality), so $d_{\\mathcal{Z}_A} = 0$.\n- $d_{\\mathcal{Z}_B}$: $T_{\\mathcal{Z}_B} = 20 \\le 60$, so $d_{\\mathcal{Z}_B} = 0$.\n- $I_2 = |0 - 0| = 0$.\n- $R_2 = \\frac{40}{60} = \\frac{2}{3} \\approx 0.666...$.\n- Result: $[0, 0.666...]$.\n\n**Case 3: $K = 10$ MW**\n- $d_{\\mathcal{Z}_A}$: $T_{\\mathcal{Z}_A} = 60  10$, so $d_{\\mathcal{Z}_A} = 1$.\n- $d_{\\mathcal{Z}_B}$: $T_{\\mathcal{Z}_B} = 20  10$, so $d_{\\mathcal{Z}_B} = 1$.\n- $I_3 = |1 - 1| = 0$.\n- $R_3 = \\frac{40}{10} = 4.0$.\n- Result: $[0, 4.0]$.\n\n**Case 4: $K = 80$ MW**\n- $d_{\\mathcal{Z}_A}$: $T_{\\mathcal{Z}_A} = 60 \\le 80$, so $d_{\\mathcal{Z}_A} = 0$.\n- $d_{\\mathcal{Z}_B}$: $T_{\\mathcal{Z}_B} = 20 \\le 80$, so $d_{\\mathcal{Z}_B} = 0$.\n- $I_4 = |0 - 0| = 0$.\n- $R_4 = \\frac{40}{80} = 0.5$.\n- Result: $[0, 0.5]$.\n\nThe final compiled results for the four test cases are $[[1, 0.8], [0, 0.666...], [0, 4.0], [0, 0.5]]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the energy system modeling problem presented, calculating MAUP instability metrics.\n    \"\"\"\n    # Define the system data from the problem statement.\n    # Demands (MW)\n    demands = np.array([10.0, 10.0, 30.0, 30.0])\n    # Generator max capacities (MW)\n    gen_caps = np.array([60.0, 20.0, 40.0, 40.0])\n    # Marginal costs ($/MWh)\n    gen_costs = np.array([20.0, 30.0, 100.0, 120.0])\n    # Node indices\n    nodes = np.arange(len(demands))\n    \n    # Define the test cases for transmission capacity K (MW).\n    test_cases = [50.0, 60.0, 10.0, 80.0]\n\n    # Step 1: Calculate the unconstrained least-cost dispatch.\n    # This follows the principle of merit-order dispatch.\n    total_demand = np.sum(demands)\n    \n    # Combine generator properties and sort by cost in ascending order.\n    # Each element is (cost, capacity, original_index)\n    generators_sorted = sorted(zip(gen_costs, gen_caps, nodes), key=lambda x: x[0])\n    \n    # Initialize dispatched generation for each node to zero.\n    dispatched_generation = np.zeros(len(demands))\n    demand_to_meet = total_demand\n    \n    for cost, capacity, index in generators_sorted:\n        if demand_to_meet = 0:\n            break\n        # Dispatch the cheaper generator up to its capacity or until demand is met.\n        dispatch_amount = min(demand_to_meet, capacity)\n        dispatched_generation[index] = dispatch_amount\n        demand_to_meet -= dispatch_amount\n\n    # Step 2: Calculate the required interzonal transfers for each zoning scheme.\n    # Zoning scheme Z_A: West zone W_A = {1,2} (indices 0, 1)\n    D_WA = demands[0] + demands[1]\n    G_WA = dispatched_generation[0] + dispatched_generation[1]\n    T_zA = abs(D_WA - G_WA)\n\n    # Zoning scheme Z_B: West zone W_B = {1,3} (indices 0, 2)\n    D_WB = demands[0] + demands[2]\n    G_WB = dispatched_generation[0] + dispatched_generation[2]\n    T_zB = abs(D_WB - G_WB)\n\n    # Step 3: Evaluate MAUP metrics for each test case.\n    results = []\n    for k_capacity in test_cases:\n        # Determine the binary decision for each scheme. Reinforcement is\n        # recommended if the required transfer strictly exceeds capacity K.\n        d_zA = 1 if T_zA > k_capacity else 0\n        d_zB = 1 if T_zB > k_capacity else 0\n        \n        # Calculate MAUP-induced decision instability indicator I.\n        I = abs(d_zA - d_zB)\n        \n        # Calculate normalized transfer difference R.\n        # This is guaranteed to be safe as K > 0 in all test cases.\n        R = abs(T_zA - T_zB) / k_capacity\n        \n        results.append([I, R])\n\n    # Final print statement in the exact required format.\n    # The format is [[I1,R1],[I2,R2],...], created by joining string representations.\n    stringified_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(stringified_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from conceptual aggregation to physical impacts, this exercise explores how spatial simplification affects power flow analysis in electricity networks. While zonal models are essential for managing the complexity of large-scale grids, they can introduce significant errors by obscuring intra-zonal congestion. In this practice , you will use Power Transfer Distribution Factors (PTDFs) to measure the concrete errors in line flow calculations that arise from aggregating a detailed nodal power system model into a simplified zonal one.",
            "id": "4124091",
            "problem": "You are given a connected direct-current (DC) approximation of a transmission network with $4$ buses and $5$ transmission lines. Under the DC approximation, bus voltage magnitudes are set to $1$ per unit, reactive power is neglected, and active power flows are linearly related to bus voltage angles through line susceptances. For each line $(i,j)$ with susceptance $b_{ij}$, the active power flow $f_{ij}$ is given by $f_{ij} = b_{ij} \\left( \\theta_i - \\theta_j \\right)$, where $\\theta_i$ is the voltage angle at bus $i$ in radians. Nodal power balance imposes $\\sum_j B_{ij} \\theta_j = P_i$, where $P_i$ is the net active power injection at bus $i$ in megawatts (MW) and $B$ is the bus susceptance matrix assembled from the line susceptances $b_{ij}$. Take bus $1$ as the slack (reference) bus with fixed angle $\\theta_1 = 0$ radians. All angles must be in radians and all active powers must be in megawatts (MW).\n\nNetwork specification:\n- Buses: $\\{1,2,3,4\\}$.\n- Lines (with fixed orientation and susceptance in $\\text{MW}/\\text{rad}$):\n  - Line $\\ell_1$: $(1 \\rightarrow 2)$, $b_{12} = 10$.\n  - Line $\\ell_2$: $(2 \\rightarrow 3)$, $b_{23} = 5$.\n  - Line $\\ell_3$: $(3 \\rightarrow 4)$, $b_{34} = 8$.\n  - Line $\\ell_4$: $(1 \\rightarrow 4)$, $b_{14} = 7$.\n  - Line $\\ell_5$: $(2 \\rightarrow 4)$, $b_{24} = 6$.\n\nZones and aggregation:\n- Define $2$ zones: Zone $\\mathcal{A} = \\{2,3\\}$ and Zone $\\mathcal{B} = \\{4\\}$. Bus $1$ is the slack and is not part of any zone.\n- The zonal aggregation uses fixed distribution keys within each zone: in Zone $\\mathcal{A}$, weights are $w_2 = 0.5$ and $w_3 = 0.5$; in Zone $\\mathcal{B}$, weight is $w_4 = 1.0$. These weights state that a net zonal injection $Z_{\\mathcal{A}}$ is internally distributed as $P_2 = 0.5 Z_{\\mathcal{A}}$ and $P_3 = 0.5 Z_{\\mathcal{A}}$, while a net zonal injection $Z_{\\mathcal{B}}$ is assigned entirely to bus $4$.\n\nTasks:\n1. Using only the DC approximation and network definitions above, construct the bus susceptance matrix $B$ and the reduced system for non-slack buses. Compute the nodal Power Transfer Distribution Factors (PTDFs) for lines $\\ell_1$ through $\\ell_5$ with respect to buses $\\{2,3,4\\}$ and slack $1$, defined as the sensitivity of line flows $f_{\\ell}$ in MW to a $+1$ MW injection at bus $n \\in \\{2,3,4\\}$ with a $-1$ MW withdrawal at the slack bus $1$.\n2. From the nodal PTDFs and the given zonal weights, compute the zonal PTDFs mapping net zonal injections $(Z_{\\mathcal{A}}, Z_{\\mathcal{B}})$ to line flows, under the aggregation rule described above.\n3. For each test case below, compute:\n   - The actual line flows (MW) using the nodal PTDFs and the specified bus-level injections at buses $\\{2,3,4\\}$, with the slack bus injection $P_1$ chosen to enforce $\\sum_{i=1}^4 P_i = 0$.\n   - The aggregated (approximate) line flows (MW) using the zonal PTDFs and the corresponding net zonal injections $Z_{\\mathcal{A}} = P_2 + P_3$ and $Z_{\\mathcal{B}} = P_4$.\n   - The maximum absolute aggregation error across the $5$ lines, defined as $\\max_{\\ell \\in \\{\\ell_1,\\dots,\\ell_5\\}} \\left| f_{\\ell}^{\\text{zonal}} - f_{\\ell}^{\\text{actual}} \\right|$, expressed in MW.\n\nTest suite (bus-level injections in MW at buses $\\{2,3,4\\}$; all angles in radians):\n- Case $1$: $(P_2, P_3, P_4) = (30, 30, -60)$.\n- Case $2$: $(P_2, P_3, P_4) = (60, 0, -60)$.\n- Case $3$: $(P_2, P_3, P_4) = (0, 0, 0)$.\n- Case $4$: $(P_2, P_3, P_4) = (100, -80, -20)$.\n\nYour program must:\n- Implement the required computations from first principles as described.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in MW, with one floating-point number per test case in the order above. For example, the output format must be exactly like $[r_1,r_2,r_3,r_4]$, where each $r_k$ is the maximum absolute aggregation error (MW) for Case $k$.",
            "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of a DC power flow analysis, a standard method in power systems engineering. It is well-posed, with sufficient information and clear objectives to lead to a unique, meaningful solution. The language is objective and the data are internally consistent.\n\nThe solution proceeds in three main steps as outlined in the problem:\n1.  Construction of the system matrices and computation of nodal Power Transfer Distribution Factors (PTDFs).\n2.  Computation of zonal PTDFs based on the specified aggregation scheme.\n3.  Calculation of actual and aggregated line flows for each test case to determine the maximum aggregation error.\n\n### Step 1: System Matrices and Nodal PTDF Computation\nThe DC power flow model relates net nodal power injections $P$ to bus voltage angles $\\theta$ via the bus susceptance matrix $B$:\n$$B \\theta = P$$\n\nFirst, we construct the $4 \\times 4$ bus susceptance matrix $B$ for the network. The diagonal elements $B_{ii}$ are the sum of susceptances of lines connected to bus $i$, and the off-diagonal elements $B_{ij}$ ($i \\neq j$) are the negative of the susceptance of the line between bus $i$ and bus $j$.\nGiven susceptances are $b_{12}=10$, $b_{23}=5$, $b_{34}=8$, $b_{14}=7$, and $b_{24}=6$.\n- $B_{11} = b_{12} + b_{14} = 10 + 7 = 17$\n- $B_{22} = b_{12} + b_{23} + b_{24} = 10 + 5 + 6 = 21$\n- $B_{33} = b_{23} + b_{34} = 5 + 8 = 13$\n- $B_{44} = b_{14} + b_{24} + b_{34} = 7 + 6 + 8 = 21$\n- $B_{12} = B_{21} = -b_{12} = -10$\n- $B_{23} = B_{32} = -b_{23} = -5$\n- $B_{34} = B_{43} = -b_{34} = -8$\n- $B_{14} = B_{41} = -b_{14} = -7$\n- $B_{24} = B_{42} = -b_{24} = -6$\n- $B_{13} = B_{31} = 0$\n\nThe full bus susceptance matrix is:\n$$B = \\begin{pmatrix} 17  -10  0  -7 \\\\ -10  21  -5  -6 \\\\ 0  -5  13  -8 \\\\ -7  -6  -8  21 \\end{pmatrix}$$\n\nBus $1$ is the slack bus, so its angle is fixed at $\\theta_1=0$. We can form a reduced system for the non-slack buses $\\{2, 3, 4\\}$. This involves removing the first row and column of $B$, giving the reduced matrix $B_{\\text{red}}$. The system for the unknown angles $\\theta_{\\text{red}} = [\\theta_2, \\theta_3, \\theta_4]^T$ is $B_{\\text{red}} \\theta_{\\text{red}} = P_{\\text{red}}$, where $P_{\\text{red}} = [P_2, P_3, P_4]^T$.\n$$B_{\\text{red}} = \\begin{pmatrix} 21  -5  -6 \\\\ -5  13  -8 \\\\ -6  -8  21 \\end{pmatrix}$$\nThe solution for the angles is $\\theta_{\\text{red}} = B_{\\text{red}}^{-1} P_{\\text{red}}$. Let $X = B_{\\text{red}}^{-1}$.\n\nThe active power flow $f_{ij}$ on a line $(i,j)$ is $f_{ij} = b_{ij}(\\theta_i - \\theta_j)$. We can express the vector of all $5$ line flows $f = [f_{12}, f_{23}, f_{34}, f_{14}, f_{24}]^T$ as a linear transformation of the non-slack angle vector $\\theta_{\\text{red}}$: $f = M \\theta_{\\text{red}}$.\n- $f_{12} = b_{12}(\\theta_1 - \\theta_2) = 10(0 - \\theta_2) = -10\\theta_2$\n- $f_{23} = b_{23}(\\theta_2 - \\theta_3) = 5\\theta_2 - 5\\theta_3$\n- $f_{34} = b_{34}(\\theta_3 - \\theta_4) = 8\\theta_3 - 8\\theta_4$\n- $f_{14} = b_{14}(\\theta_1 - \\theta_4) = 7(0 - \\theta_4) = -7\\theta_4$\n- $f_{24} = b_{24}(\\theta_2 - \\theta_4) = 6\\theta_2 - 6\\theta_4$\n\nThis defines the matrix $M$:\n$$M = \\begin{pmatrix} -10  0  0 \\\\ 5  -5  0 \\\\ 0  8  -8 \\\\ 0  0  -7 \\\\ 6  0  -6 \\end{pmatrix}$$\nSubstituting $\\theta_{\\text{red}} = X P_{\\text{red}}$, we find the relationship between line flows and nodal injections: $f = M X P_{\\text{red}}$. The nodal PTDF matrix is the matrix that multiplies $P_{\\text{red}}$ to give $f$.\n$$\\text{PTDF}_{\\text{nodal}} = M X = M B_{\\text{red}}^{-1}$$\n$\\text{PTDF}_{\\text{nodal}}$ is a $5 \\times 3$ matrix where the element $(\\ell, n)$ represents the change in flow on line $\\ell$ for a $1$ MW injection at non-slack bus $n$ (and a corresponding withdrawal at the slack bus).\n\n### Step 2: Zonal PTDF Computation\nThe problem defines two zones, $\\mathcal{A}=\\{2,3\\}$ and $\\mathcal{B}=\\{4\\}$, with net injections $Z_{\\mathcal{A}}$ and $Z_{\\mathcal{B}}$. The nodal injections are distributed from the zonal injections according to weights $w_2 = 0.5, w_3 = 0.5$ for Zone $\\mathcal{A}$ and $w_4=1.0$ for Zone $\\mathcal{B}$.\nThis defines a linear mapping from zonal injections $Z = [Z_{\\mathcal{A}}, Z_{\\mathcal{B}}]^T$ to nodal injections $P_{\\text{red}}$:\n$$P_{\\text{red}} = W Z \\quad \\text{where} \\quad W = \\begin{pmatrix} 0.5  0 \\\\ 0.5  0 \\\\ 0  1.0 \\end{pmatrix}$$\nThe line flows calculated using the zonal model, $f^{\\text{zonal}}$, are given by:\n$$f^{\\text{zonal}} = \\text{PTDF}_{\\text{nodal}} (W Z)$$\nThis can be rewritten as $f^{\\text{zonal}} = (\\text{PTDF}_{\\text{nodal}} W) Z$. The term in parentheses is the zonal PTDF matrix:\n$$\\text{PTDF}_{\\text{zonal}} = \\text{PTDF}_{\\text{nodal}} W$$\n$\\text{PTDF}_{\\text{zonal}}$ is a $5 \\times 2$ matrix mapping zonal injections to line flows.\n\n### Step 3: Aggregation Error Calculation\nFor each test case, we are given a set of nodal injections $(P_2, P_3, P_4)$.\nThe actual line flows, $f^{\\text{actual}}$, are calculated using the full nodal model:\n$$f^{\\text{actual}} = \\text{PTDF}_{\\text{nodal}} \\begin{pmatrix} P_2 \\\\ P_3 \\\\ P_4 \\end{pmatrix}$$\nThe aggregated (approximate) line flows, $f^{\\text{zonal}}$, are calculated using the zonal model. First, we find the net zonal injections: $Z_{\\mathcal{A}} = P_2 + P_3$ and $Z_{\\mathcal{B}} = P_4$.\n$$f^{\\text{zonal}} = \\text{PTDF}_{\\text{zonal}} \\begin{pmatrix} Z_{\\mathcal{A}} \\\\ Z_{\\mathcal{B}} \\end{pmatrix} = \\text{PTDF}_{\\text{zonal}} \\begin{pmatrix} P_2+P_3 \\\\ P_4 \\end{pmatrix}$$\nFinally, the aggregation error for each line is the difference $f_{\\ell}^{\\text{zonal}} - f_{\\ell}^{\\text{actual}}$. The problem asks for the maximum absolute aggregation error across all $5$ lines for each test case:\n$$\\text{Error} = \\max_{\\ell \\in \\{1,\\dots,5\\}} \\left| f_{\\ell}^{\\text{zonal}} - f_{\\ell}^{\\text{actual}} \\right|$$\nThis procedure is repeated for all four test cases. The error arises from the difference between the actual nodal injection pattern $[P_2, P_3]^T$ within Zone $\\mathcal{A}$ and the pattern assumed by the aggregation weights, $[0.5(P_2+P_3), 0.5(P_2+P_3)]^T$. The error is zero if the actual injections $P_2, P_3$ are equal, as they perfectly match the $50\\%$-$50\\%$ split.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the power system aggregation error problem.\n\n    The solution follows these steps:\n    1. Define the network parameters (susceptances).\n    2. Construct the reduced bus susceptance matrix (B_red) for non-slack buses.\n    3. Compute its inverse (X), which relates nodal injections to bus angles.\n    4. Construct the matrix M, which maps non-slack bus angles to line flows.\n    5. Compute the nodal PTDF matrix: PTDF_nodal = M @ X.\n    6. Define the zonal aggregation weight matrix W.\n    7. Compute the zonal PTDF matrix: PTDF_zonal = PTDF_nodal @ W.\n    8. For each test case:\n        a. Calculate actual line flows using nodal PTDFs and nodal injections.\n        b. Calculate aggregated line flows using zonal PTDFs and zonal injections.\n        c. Compute the maximum absolute difference between the two flow vectors.\n    9. Format and print the results.\n    \"\"\"\n\n    # --- Step 1  2: Construct system matrices ---\n    # Reduced bus susceptance matrix B_red for buses {2, 3, 4}\n    # B_22 = 10 + 5 + 6 = 21\n    # B_33 = 5 + 8 = 13\n    # B_44 = 7 + 8 + 6 = 21\n    # B_23 = -5, B_24 = -6, B_34 = -8\n    B_red = np.array([\n        [21., -5., -6.],\n        [-5., 13., -8.],\n        [-6., -8., 21.]\n    ])\n\n    # --- Step 3: Compute inverse of B_red ---\n    # X = B_red^{-1}\n    X = np.linalg.inv(B_red)\n\n    # --- Step 4: Construct line flow mapping matrix M ---\n    # f = M * [theta_2, theta_3, theta_4]^T\n    # Lines are l1:(1->2), l2:(2->3), l3:(3->4), l4:(1->4), l5:(2->4)\n    # Susceptances b12=10, b23=5, b34=8, b14=7, b24=6\n    # f12 = 10(t1-t2) = -10*t2 since t1=0\n    # f23 = 5(t2-t3)\n    # f34 = 8(t3-t4)\n    # f14 = 7(t1-t4) = -7*t4\n    # f24 = 6(t2-t4)\n    M = np.array([\n        [-10.,  0.,  0.],\n        [  5., -5.,  0.],\n        [  0.,  8., -8.],\n        [  0.,  0., -7.],\n        [  6.,  0., -6.]\n    ])\n\n    # --- Step 5: Compute nodal PTDF matrix ---\n    PTDF_nodal = M @ X\n\n    # --- Step 6: Define zonal aggregation matrix W ---\n    # P_red = W * Z\n    # P2 = 0.5*ZA, P3 = 0.5*ZA, P4 = 1.0*ZB\n    W = np.array([\n        [0.5, 0.0],\n        [0.5, 0.0],\n        [0.0, 1.0]\n    ])\n\n    # --- Step 7: Compute zonal PTDF matrix ---\n    PTDF_zonal = PTDF_nodal @ W\n\n    # --- Step 8: Process test cases ---\n    test_cases = [\n        (30., 30., -60.),\n        (60., 0., -60.),\n        (0., 0., 0.),\n        (100., -80., -20.),\n    ]\n\n    results = []\n    for case in test_cases:\n        P2, P3, P4 = case\n        \n        # Nodal (actual) model\n        P_red = np.array([P2, P3, P4])\n        f_actual = PTDF_nodal @ P_red\n\n        # Zonal (aggregated) model\n        Z_A = P2 + P3\n        Z_B = P4\n        Z = np.array([Z_A, Z_B])\n        f_zonal = PTDF_zonal @ Z\n        \n        # Calculate maximum absolute aggregation error\n        max_error = np.max(np.abs(f_zonal - f_actual))\n        results.append(max_error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}