{
    "hands_on_practices": [
        {
            "introduction": "能源系统模型，尤其是电力系统模型，常常需要对空间细节进行简化，以在计算可行性和模型精度之间取得平衡。这个练习将带你深入电力系统建模的核心，通过比较精细的节点模型和聚合的区域模型来实践这一权衡 。你将亲手计算节点和区域级别的功率传输分布因子（PTDFs），并量化因空间聚合而产生的潮流计算误差，从而深刻理解模型粒度对分析结果准确性的影响。",
            "id": "4124091",
            "problem": "给定一个由 $4$ 条母线和 $5$ 条输电线路组成的连通输电网络的直流 (DC) 近似模型。在直流近似下，母线电压幅值设为 $1$ 标幺值，忽略无功功率，有功功率潮流通过线路电纳与母线电压相角呈线性关系。对于每条电纳为 $b_{ij}$ 的线路 $(i,j)$，其有功功率潮流 $f_{ij}$ 由 $f_{ij} = b_{ij} \\left( \\theta_i - \\theta_j \\right)$ 给出，其中 $\\theta_i$ 是母线 $i$ 的电压相角，单位为弧度。节点功率平衡要求 $\\sum_j B_{ij} \\theta_j = P_i$，其中 $P_i$ 是母线 $i$ 的净有功注入功率，单位为兆瓦 (MW)，$B$ 是由线路电纳 $b_{ij}$ 构成的母线电纳矩阵。将母线 $1$ 作为平衡（参考）母线，其相角固定为 $\\theta_1 = 0$ 弧度。所有相角单位必须是弧度，所有有功功率单位必须是兆瓦 (MW)。\n\n网络规格：\n- 母线：$\\{1,2,3,4\\}$。\n- 线路（具有固定方向和电纳，单位为 $\\text{MW}/\\text{rad}$）：\n  - 线路 $\\ell_1$：$(1 \\rightarrow 2)$，$b_{12} = 10$。\n  - 线路 $\\ell_2$：$(2 \\rightarrow 3)$，$b_{23} = 5$。\n  - 线路 $\\ell_3$：$(3 \\rightarrow 4)$，$b_{34} = 8$。\n  - 线路 $\\ell_4$：$(1 \\rightarrow 4)$，$b_{14} = 7$。\n  - 线路 $\\ell_5$：$(2 \\rightarrow 4)$，$b_{24} = 6$。\n\n区域与聚合：\n- 定义 $2$ 个区域：区域 $\\mathcal{A} = \\{2,3\\}$ 和区域 $\\mathcal{B} = \\{4\\}$。母线 $1$ 是平衡母线，不属于任何区域。\n- 区域聚合在每个区域内使用固定的分配因子：在区域 $\\mathcal{A}$ 中，权重为 $w_2 = 0.5$ 和 $w_3 = 0.5$；在区域 $\\mathcal{B}$ 中，权重为 $w_4 = 1.0$。这些权重表明，一个区域净注入 $Z_{\\mathcal{A}}$ 在内部自分配为 $P_2 = 0.5 Z_{\\mathcal{A}}$ 和 $P_3 = 0.5 Z_{\\mathcal{A}}$，而一个区域净注入 $Z_{\\mathcal{B}}$ 则完全分配给母线 $4$。\n\n任务：\n1. 仅使用上述直流近似和网络定义，构建母线电纳矩阵 $B$ 和非平衡母线的降阶系统。计算线路 $\\ell_1$ 至 $\\ell_5$ 相对于母线 $\\{2,3,4\\}$ 和平衡母线 $1$ 的节点功率传输分布因子 (PTDFs)。PTDF 定义为：当非平衡母线 $n \\in \\{2,3,4\\}$ 注入 $+1$ MW 且平衡母线 $1$ 取出 $-1$ MW 时，线路潮流 $f_{\\ell}$（单位 MW）的灵敏度。\n2. 根据节点 PTDF 和给定的区域权重，计算在上述聚合规则下，将区域净注入 $(Z_{\\mathcal{A}}, Z_{\\mathcal{B}})$ 映射到线路潮流的区域 PTDF。\n3. 对以下每个测试用例，计算：\n   - 使用节点 PTDF 和在母线 $\\{2,3,4\\}$ 上指定的母线级注入功率，计算实际线路潮流（单位 MW）。平衡母线注入 $P_1$ 的选择应满足 $\\sum_{i=1}^4 P_i = 0$。\n   - 使用区域 PTDF 和相应的区域净注入 $Z_{\\mathcal{A}} = P_2 + P_3$ 及 $Z_{\\mathcal{B}} = P_4$，计算聚合（近似）线路潮流（单位 MW）。\n   - 跨越 $5$ 条线路的最大绝对聚合误差，定义为 $\\max_{\\ell \\in \\{\\ell_1,\\dots,\\ell_5\\}} \\left| f_{\\ell}^{\\text{zonal}} - f_{\\ell}^{\\text{actual}} \\right|$，以 MW 表示。\n\n测试套件（母线 $\\{2,3,4\\}$ 的母线级注入功率，单位 MW；所有相角单位为弧度）：\n- 用例 1：$(P_2, P_3, P_4) = (30, 30, -60)$。\n- 用例 2：$(P_2, P_3, P_4) = (60, 0, -60)$。\n- 用例 3：$(P_2, P_3, P_4) = (0, 0, 0)$。\n- 用例 4：$(P_2, P_3, P_4) = (100, -80, -20)$。\n\n你的程序必须：\n- 根据描述从第一性原理实现所需的计算。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。结果以 MW 为单位，每个测试用例对应一个浮点数，并按上述顺序排列。例如，输出格式必须与 $[r_1,r_2,r_3,r_4]$ 完全一样，其中每个 $r_k$ 是用例 $k$ 的最大绝对聚合误差（MW）。",
            "solution": "该问题被评估为有效，因为它科学地基于直流潮流分析的原理，这是电力系统工程中的一种标准方法。问题提法清晰，信息充分，目标明确，可以导出一个唯一的、有意义的解。语言客观，数据内部一致。\n\n解决方案按照问题中概述的三个主要步骤进行：\n1.  构建系统矩阵并计算节点功率传输分布因子 (PTDF)。\n2.  基于指定的聚合方案计算区域 PTDF。\n3.  为每个测试用例计算实际和聚合的线路潮流，以确定最大聚合误差。\n\n### 步骤 1：系统矩阵和节点 PTDF 计算\n直流潮流模型通过母线电纳矩阵 $B$ 将净节点注入功率 $P$ 与母线电压相角 $\\theta$ 联系起来：\n$$B \\theta = P$$\n\n首先，我们为该网络构建 $4 \\times 4$ 的母线电纳矩阵 $B$。对角元素 $B_{ii}$ 是连接到母线 $i$ 的所有线路的电纳之和，非对角元素 $B_{ij}$ ($i \\neq j$) 是母线 $i$ 和母线 $j$ 之间线路电纳的负值。\n给定的电纳为 $b_{12}=10$、$b_{23}=5$、$b_{34}=8$、$b_{14}=7$ 和 $b_{24}=6$。\n- $B_{11} = b_{12} + b_{14} = 10 + 7 = 17$\n- $B_{22} = b_{12} + b_{23} + b_{24} = 10 + 5 + 6 = 21$\n- $B_{33} = b_{23} + b_{34} = 5 + 8 = 13$\n- $B_{44} = b_{14} + b_{24} + b_{34} = 7 + 6 + 8 = 21$\n- $B_{12} = B_{21} = -b_{12} = -10$\n- $B_{23} = B_{32} = -b_{23} = -5$\n- $B_{34} = B_{43} = -b_{34} = -8$\n- $B_{14} = B_{41} = -b_{14} = -7$\n- $B_{24} = B_{42} = -b_{24} = -6$\n- $B_{13} = B_{31} = 0$\n\n完整的母线电纳矩阵是：\n$$B = \\begin{pmatrix} 17  -10  0  -7 \\\\ -10  21  -5  -6 \\\\ 0  -5  13  -8 \\\\ -7  -6  -8  21 \\end{pmatrix}$$\n\n母线 $1$ 是平衡母线，因此其相角固定为 $\\theta_1=0$。我们可以为非平衡母线 $\\{2, 3, 4\\}$ 形成一个降阶系统。这涉及到移除 $B$ 的第一行和第一列，得到降阶矩阵 $B_{\\text{red}}$。未知相角 $\\theta_{\\text{red}} = [\\theta_2, \\theta_3, \\theta_4]^T$ 的方程组为 $B_{\\text{red}} \\theta_{\\text{red}} = P_{\\text{red}}$，其中 $P_{\\text{red}} = [P_2, P_3, P_4]^T$。\n$$B_{\\text{red}} = \\begin{pmatrix} 21  -5  -6 \\\\ -5  13  -8 \\\\ -6  -8  21 \\end{pmatrix}$$\n相角的解为 $\\theta_{\\text{red}} = B_{\\text{red}}^{-1} P_{\\text{red}}$。令 $X = B_{\\text{red}}^{-1}$。\n\n线路 $(i,j)$ 上的有功功率潮流 $f_{ij}$ 是 $f_{ij} = b_{ij}(\\theta_i - \\theta_j)$。我们可以将全部 $5$ 条线路的潮流向量 $f = [f_{12}, f_{23}, f_{34}, f_{14}, f_{24}]^T$ 表示为非平衡母线相角向量 $\\theta_{\\text{red}}$ 的线性变换：$f = M \\theta_{\\text{red}}$。\n- $f_{12} = b_{12}(\\theta_1 - \\theta_2) = 10(0 - \\theta_2) = -10\\theta_2$\n- $f_{23} = b_{23}(\\theta_2 - \\theta_3) = 5\\theta_2 - 5\\theta_3$\n- $f_{34} = b_{34}(\\theta_3 - \\theta_4) = 8\\theta_3 - 8\\theta_4$\n- $f_{14} = b_{14}(\\theta_1 - \\theta_4) = 7(0 - \\theta_4) = -7\\theta_4$\n- $f_{24} = b_{24}(\\theta_2 - \\theta_4) = 6\\theta_2 - 6\\theta_4$\n\n这定义了矩阵 $M$：\n$$M = \\begin{pmatrix} -10  0  0 \\\\ 5  -5  0 \\\\ 0  8  -8 \\\\ 0  0  -7 \\\\ 6  0  -6 \\end{pmatrix}$$\n代入 $\\theta_{\\text{red}} = X P_{\\text{red}}$，我们得到线路潮流和节点注入功率之间的关系：$f = M X P_{\\text{red}}$。节点 PTDF 矩阵就是乘以 $P_{\\text{red}}$ 得到 $f$ 的那个矩阵。\n$$\\text{PTDF}_{\\text{nodal}} = M X = M B_{\\text{red}}^{-1}$$\n$\\text{PTDF}_{\\text{nodal}}$ 是一个 $5 \\times 3$ 矩阵，其中元素 $(\\ell, n)$ 表示当非平衡母线 $n$ 注入 $1$ MW（并在平衡母线相应地取出功率）时，线路 $\\ell$ 上的潮流变化。\n\n### 步骤 2：区域 PTDF 计算\n问题定义了两个区域 $\\mathcal{A}=\\{2,3\\}$ 和 $\\mathcal{B}=\\{4\\}$，其净注入功率为 $Z_{\\mathcal{A}}$ 和 $Z_{\\mathcal{B}}$。节点注入功率根据权重从区域注入功率分配而来：区域 $\\mathcal{A}$ 的权重为 $w_2 = 0.5, w_3 = 0.5$，区域 $\\mathcal{B}$ 的权重为 $w_4=1.0$。\n这定义了一个从区域注入 $Z = [Z_{\\mathcal{A}}, Z_{\\mathcal{B}}]^T$ 到节点注入 $P_{\\text{red}}$ 的线性映射：\n$$P_{\\text{red}} = W Z \\quad \\text{其中} \\quad W = \\begin{pmatrix} 0.5  0 \\\\ 0.5  0 \\\\ 0  1.0 \\end{pmatrix}$$\n使用区域模型计算的线路潮流 $f^{\\text{zonal}}$ 由下式给出：\n$$f^{\\text{zonal}} = \\text{PTDF}_{\\text{nodal}} (W Z)$$\n这可以重写为 $f^{\\text{zonal}} = (\\text{PTDF}_{\\text{nodal}} W) Z$。括号中的项即为区域 PTDF 矩阵：\n$$\\text{PTDF}_{\\text{zonal}} = \\text{PTDF}_{\\text{nodal}} W$$\n$\\text{PTDF}_{\\text{zonal}}$ 是一个将区域注入映射到线路潮流的 $5 \\times 2$ 矩阵。\n\n### 步骤 3：聚合误差计算\n对于每个测试用例，我们都给定了一组节点注入功率 $(P_2, P_3, P_4)$。\n实际线路潮流 $f^{\\text{actual}}$ 使用完整的节点模型计算：\n$$f^{\\text{actual}} = \\text{PTDF}_{\\text{nodal}} \\begin{pmatrix} P_2 \\\\ P_3 \\\\ P_4 \\end{pmatrix}$$\n聚合（近似）线路潮流 $f^{\\text{zonal}}$ 使用区域模型计算。首先，我们求出区域净注入：$Z_{\\mathcal{A}} = P_2 + P_3$ 和 $Z_{\\mathcal{B}} = P_4$。\n$$f^{\\text{zonal}} = \\text{PTDF}_{\\text{zonal}} \\begin{pmatrix} Z_{\\mathcal{A}} \\\\ Z_{\\mathcal{B}} \\end{pmatrix} = \\text{PTDF}_{\\text{zonal}} \\begin{pmatrix} P_2+P_3 \\\\ P_4 \\end{pmatrix}$$\n最后，每条线路的聚合误差是差值 $f_{\\ell}^{\\text{zonal}} - f_{\\ell}^{\\text{actual}}$。问题要求计算每个测试用例中所有 $5$ 条线路的最大绝对聚合误差：\n$$\\text{Error} = \\max_{\\ell \\in \\{1,\\dots,5\\}} \\left| f_{\\ell}^{\\text{zonal}} - f_{\\ell}^{\\text{actual}} \\right|$$\n对所有四个测试用例重复此过程。误差源于区域 $\\mathcal{A}$ 内的实际节点注入模式 $[P_2, P_3]^T$ 与聚合权重所假设的模式 $[0.5(P_2+P_3), 0.5(P_2+P_3)]^T$ 之间的差异。如果实际注入 $P_2, P_3$ 相等，则误差为零，因为它们完美匹配了 $50\\%$-$50\\%$ 的分配比例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the power system aggregation error problem.\n\n    The solution follows these steps:\n    1. Define the network parameters (susceptances).\n    2. Construct the reduced bus susceptance matrix (B_red) for non-slack buses.\n    3. Compute its inverse (X), which relates nodal injections to bus angles.\n    4. Construct the matrix M, which maps non-slack bus angles to line flows.\n    5. Compute the nodal PTDF matrix: PTDF_nodal = M @ X.\n    6. Define the zonal aggregation weight matrix W.\n    7. Compute the zonal PTDF matrix: PTDF_zonal = PTDF_nodal @ W.\n    8. For each test case:\n        a. Calculate actual line flows using nodal PTDFs and nodal injections.\n        b. Calculate aggregated line flows using zonal PTDFs and zonal injections.\n        c. Compute the maximum absolute difference between the two flow vectors.\n    9. Format and print the results.\n    \"\"\"\n\n    # --- Step 1  2: Construct system matrices ---\n    # Reduced bus susceptance matrix B_red for buses {2, 3, 4}\n    # B_22 = 10 + 5 + 6 = 21\n    # B_33 = 5 + 8 = 13\n    # B_44 = 7 + 8 + 6 = 21\n    # B_23 = -5, B_24 = -6, B_34 = -8\n    B_red = np.array([\n        [21., -5., -6.],\n        [-5., 13., -8.],\n        [-6., -8., 21.]\n    ])\n\n    # --- Step 3: Compute inverse of B_red ---\n    # X = B_red^{-1}\n    X = np.linalg.inv(B_red)\n\n    # --- Step 4: Construct line flow mapping matrix M ---\n    # f = M * [theta_2, theta_3, theta_4]^T\n    # Lines are l1:(1->2), l2:(2->3), l3:(3->4), l4:(1->4), l5:(2->4)\n    # Susceptances b12=10, b23=5, b34=8, b14=7, b24=6\n    # f12 = 10(t1-t2) = -10*t2 since t1=0\n    # f23 = 5(t2-t3)\n    # f34 = 8(t3-t4)\n    # f14 = 7(t1-t4) = -7*t4\n    # f24 = 6(t2-t4)\n    M = np.array([\n        [-10.,  0.,  0.],\n        [  5., -5.,  0.],\n        [  0.,  8., -8.],\n        [  0.,  0., -7.],\n        [  6.,  0., -6.]\n    ])\n\n    # --- Step 5: Compute nodal PTDF matrix ---\n    PTDF_nodal = M @ X\n\n    # --- Step 6: Define zonal aggregation matrix W ---\n    # P_red = W * Z\n    # P2 = 0.5*ZA, P3 = 0.5*ZA, P4 = 1.0*ZB\n    W = np.array([\n        [0.5, 0.0],\n        [0.5, 0.0],\n        [0.0, 1.0]\n    ])\n\n    # --- Step 7: Compute zonal PTDF matrix ---\n    PTDF_zonal = PTDF_nodal @ W\n\n    # --- Step 8: Process test cases ---\n    test_cases = [\n        (30., 30., -60.),\n        (60., 0., -60.),\n        (0., 0., 0.),\n        (100., -80., -20.),\n    ]\n\n    results = []\n    for case in test_cases:\n        P2, P3, P4 = case\n        \n        # Nodal (actual) model\n        P_red = np.array([P2, P3, P4])\n        f_actual = PTDF_nodal @ P_red\n\n        # Zonal (aggregated) model\n        Z_A = P2 + P3\n        Z_B = P4\n        Z = np.array([Z_A, Z_B])\n        f_zonal = PTDF_zonal @ Z\n        \n        # Calculate maximum absolute aggregation error\n        max_error = np.max(np.abs(f_zonal - f_actual))\n        results.append(max_error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习的基础上，我们进一步探讨空间聚合的一个更深层次的问题：可变分区单元问题（Modifiable Areal Unit Problem, MAUP）。该问题揭示了区域划分方式本身可以极大地影响甚至扭转模型结论，而不仅仅是引入计算误差 。通过分析一个合成的能源系统，你将看到两种不同的、看似都合理的分区方案如何对同一个输电投资决策问题得出截然相反的建议，从而体会到模型中空间单元定义的重要性及其对决策稳定性的潜在威胁。",
            "id": "4124078",
            "problem": "考虑一个包含四个节点和单一区间输电接口的合成能源系统。每个节点 $i \\in \\{1,2,3,4\\}$ 都有固定的需求 $D_i$（单位为兆瓦, MW），一个最大容量为 $\\overline{G}_i$（MW）的单台发电机，以及一个恒定的边际成本 $c_i$（单位为美元/兆瓦时, $\\$/\\text{MWh}$）。该系统在最低成本调度下运行，并遵循一个输电规划规则，该规则评估是否建议对区间接口进行加强。系统必须满足电力平衡，即总发电量等于总需求量。\n\n基本原则如下：\n- 电力平衡：$$\\sum_{i=1}^{4} g_i = \\sum_{i=1}^{4} D_i,$$ 其中 $g_i$ 是节点 $i$ 的调度发电量，单位为兆瓦（MW）。\n- 运行可行性：$$0 \\le g_i \\le \\overline{G}_i \\quad \\text{for all } i.$$\n- 成本最小化：最低成本调度在满足上述约束的条件下最小化 $$\\sum_{i=1}^{4} c_i g_i$$，并假设为了计算无约束最低成本调度，区间输电容量不构成约束。\n\n定义两种分区方案，将四个节点各划分为两个区域，从而产生不同的区间接口：\n- 分区方案 $\\mathcal{Z}_A$：西区 $W_A = \\{1,2\\}$ 和东区 $E_A = \\{3,4\\}$。\n- 分区方案 $\\mathcal{Z}_B$：西区 $W_B = \\{1,3\\}$ 和东区 $E_B = \\{2,4\\}$。\n\n区间接口的容量为 $K$ 兆瓦。在给定的分区方案 $\\mathcal{Z}$下，令 $G_Z$ 表示西区的总发电量， $D_Z$ 表示西区的总需求量。在无约束最低成本调度下，所需的区间传输量大小 $T_{\\mathcal{Z}}$（MW）为：\n$$T_{\\mathcal{Z}} = \\left|D_Z - G_Z\\right|.$$\n该数量代表西区的净输入绝对值（如果 $G_Z > D_Z$，则等效于净输出绝对值），并且因为恰好有两个区域，它等于跨区间接口的相应输入/输出的大小。\n\n规划规则：在分区方案 $\\mathcal{Z}$ 下，如果无约束最低成本所需的区间传输量 $T_{\\mathcal{Z}}$ 严格超过现有容量 $K$，即如果 $$T_{\\mathcal{Z}} > K$$，则建议进行输电加强。\n\n可变面元问题 (MAUP) 不稳定性度量：对于一对分区方案 $(\\mathcal{Z}_A,\\mathcal{Z}_B)$ 和给定的容量 $K$，将每种方案下的二元决策定义为\n$$d_{\\mathcal{Z}} = \\begin{cases}\n1  \\text{if } T_{\\mathcal{Z}} > K,\\\\\n0  \\text{if } T_{\\mathcal{Z}} \\le K.\n\\end{cases}$$\n定义MAUP引起的决策不稳定性指标\n$$I = |d_{\\mathcal{Z}_A} - d_{\\mathcal{Z}_B}|,$$\n以及归一化传输差异（一个无量纲十进制数）\n$$R = \\frac{\\left|T_{\\mathcal{Z}_A} - T_{\\mathcal{Z}_B}\\right|}{K},$$\n其中要求 $K > 0$。$I$ 的值，如果两种分区方案对是否需要加强得出相反的结论，则为1，否则为0；$R$ 捕捉了所需区间传输量的相对大小差异（按容量归一化），并且必须表示为十进制数，而不是百分比。\n\n合成系统数据：\n- 需求：$D_1 = 10$ MW, $D_2 = 10$ MW, $D_3 = 30$ MW, $D_4 = 30$ MW。\n- 发电机最大容量：$\\overline{G}_1 = 60$ MW, $\\overline{G}_2 = 20$ MW, $\\overline{G}_3 = 40$ MW, $\\overline{G}_4 = 40$ MW。\n- 边际成本：$c_1 = 20\\,\\$/\\text{MWh}$, $c_2 = 30\\,\\$/\\text{MWh}$, $c_3 = 100\\,\\$/\\text{MWh}$, $c_4 = 120\\,\\$/\\text{MWh}$。\n\n您必须计算满足电力平衡和容量约束的无约束最低成本调度 $g_i$，然后计算 $T_{\\mathcal{Z}_A}$ 和 $T_{\\mathcal{Z}_B}$，最后计算每个测试用例的 $I$ 和 $R$。\n\n测试套件：\n- 用例1：$K = 50$ MW（一个旨在得出相反结论的用例）。\n- 用例2：$K = 60$ MW（一个边界用例，其中一种方案下所需的传输量等于容量）。\n- 用例3：$K = 10$ MW（一个两种方案都建议加强的用例）。\n- 用例4：$K = 80$ MW（一个两种方案都不建议加强的用例）。\n\n物理单位：所有功率量（$D_i$, $g_i$, $\\overline{G}_i$, $T_{\\mathcal{Z}}$, $K$）必须以兆瓦（MW）为单位处理和计算。所有成本单位为美元/兆瓦时（$\\$/\\text{MWh}$）。不使用角度。归一化传输差异 $R$ 必须表示为不带百分号的十进制数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个双元素列表 $[I,R]$。例如，输出格式必须为：\n$$\\left[ [I_1,R_1],[I_2,R_2],[I_3,R_3],[I_4,R_4] \\right]$$\n其中符号被数值替换。",
            "solution": "问题陈述已经过评估并被确定为**有效**。它在科学上植根于能源系统经济学（最低成本调度）的原理，提法恰当，具有唯一且可推导的解，并且陈述客观，提供了所有必要的数据。该问题是在输电规划背景下对可变面元问题（MAUP）的一次可形式化探索。\n\n求解过程分为三个主要步骤：\n1.  确定无约束的最低成本调度。\n2.  计算每种分区方案所需的区间传输量。\n3.  评估每个测试用例的不稳定性度量。\n\n### 步骤1：无约束的最低成本调度\n\n目标是在满足电力平衡和发电机容量约束的条件下，最小化总发电成本 $\\sum_{i=1}^{4} c_i g_i$。这是通过按照边际成本（$c_i$）的升序调度发电机来实现的，这一原则被称为优先顺序调度法，直到满足总需求为止。\n\n系统参数如下：\n- 需求：$D_1 = 10$ MW, $D_2 = 10$ MW, $D_3 = 30$ MW, $D_4 = 30$ MW。\n- 发电机容量：$\\overline{G}_1 = 60$ MW, $\\overline{G}_2 = 20$ MW, $\\overline{G}_3 = 40$ MW, $\\overline{G}_4 = 40$ MW。\n- 边际成本：$c_1 = 20\\,\\$/\\text{MWh}$, $c_2 = 30\\,\\$/\\text{MWh}$, $c_3 = 100\\,\\$/\\text{MWh}$, $c_4 = 120\\,\\$/\\text{MWh}$。\n\n首先，我们计算系统总需求：\n$$D_{\\text{total}} = \\sum_{i=1}^{4} D_i = 10 + 10 + 30 + 30 = 80 \\text{ MW}$$\n\n总可用发电容量为 $\\sum \\overline{G}_i = 60+20+40+40 = 160$ MW，超过了总需求，确保存在可行解。\n\n发电机的优先顺序，从最便宜到最贵，是：\n1.  发电机 $1$ ($c_1 = 20\\,\\$/\\text{MWh}$)\n2.  发电机 $2$ ($c_2 = 30\\,\\$/\\text{MWh}$)\n3.  发电机 $3$ ($c_3 = 100\\,\\$/\\text{MWh}$)\n4.  发电机 $4$ ($c_4 = 120\\,\\$/\\text{MWh}$)\n\n我们依次调度发电机以满足 $80$ MW 的需求：\n- 调度发电机1：其容量为 $\\overline{G}_1 = 60$ MW。我们全额调度它。\n  - $g_1 = 60$ MW。\n  - 剩余需求：$80 - 60 = 20$ MW。\n- 调度发电机2：其容量为 $\\overline{G}_2 = 20$ MW。我们用其全部容量来满足剩余需求。\n  - $g_2 = 20$ MW。\n  - 剩余需求：$20 - 20 = 0$ MW。\n- 总需求现已满足。不需要发电机3和4。\n  - $g_3 = 0$ MW。\n  - $g_4 = 0$ MW。\n\n无约束的最低成本调度向量是 $g = (g_1, g_2, g_3, g_4) = (60, 20, 0, 0)$ MW。\n\n### 步骤2：计算区间传输量\n\n使用步骤1的调度结果，我们为每种分区方案计算所需的区间传输量 $T_{\\mathcal{Z}} = |D_Z - G_Z|$，其中 $Z$ 代表相应的西区。\n\n**分区方案 $\\mathcal{Z}_A$**：\n- 西区 $W_A = \\{1,2\\}$，东区 $E_A = \\{3,4\\}$。\n- 西区需求：$D_{W_A} = D_1 + D_2 = 10 + 10 = 20$ MW。\n- 西区发电量：$G_{W_A} = g_1 + g_2 = 60 + 20 = 80$ MW。\n- 所需传输量：$T_{\\mathcal{Z}_A} = |D_{W_A} - G_{W_A}| = |20 - 80| = 60$ MW。\n\n**分区方案 $\\mathcal{Z}_B$**：\n- 西区 $W_B = \\{1,3\\}$，东区 $E_B = \\{2,4\\}$。\n- 西区需求：$D_{W_B} = D_1 + D_3 = 10 + 30 = 40$ MW。\n- 西区发电量：$G_{W_B} = g_1 + g_3 = 60 + 0 = 60$ MW。\n- 所需传输量：$T_{\\mathcal{Z}_B} = |D_{W_B} - G_{W_B}| = |40 - 60| = 20$ MW。\n\n### 步骤3：评估测试用例\n\n现在我们为每个给定的容量 $K$ 评估不稳定性指标 $I = |d_{\\mathcal{Z}_A} - d_{\\mathcal{Z}_B}|$ 和归一化传输差异 $R = \\frac{|T_{\\mathcal{Z}_A} - T_{\\mathcal{Z}_B}|}{K}$。决策变量 $d_{\\mathcal{Z}}$ 在 $T_{\\mathcal{Z}} > K$ 时为1，否则为0。传输量的绝对差值对所有用例都是一个常数：$|T_{\\mathcal{Z}_A} - T_{\\mathcal{Z}_B}| = |60 - 20| = 40$ MW。\n\n**用例1：$K = 50$ MW**\n- $d_{\\mathcal{Z}_A}$：$T_{\\mathcal{Z}_A} = 60 > 50$，所以 $d_{\\mathcal{Z}_A} = 1$。\n- $d_{\\mathcal{Z}_B}$：$T_{\\mathcal{Z}_B} = 20 \\le 50$，所以 $d_{\\mathcal{Z}_B} = 0$。\n- $I_1 = |1 - 0| = 1$。\n- $R_1 = \\frac{40}{50} = 0.8$。\n- 结果：$[1, 0.8]$。\n\n**用例2：$K = 60$ MW**\n- $d_{\\mathcal{Z}_A}$：$T_{\\mathcal{Z}_A} = 60 \\ngtr 60$（条件是严格不等式），所以 $d_{\\mathcal{Z}_A} = 0$。\n- $d_{\\mathcal{Z}_B}$：$T_{\\mathcal{Z}_B} = 20 \\le 60$，所以 $d_{\\mathcal{Z}_B} = 0$。\n- $I_2 = |0 - 0| = 0$。\n- $R_2 = \\frac{40}{60} = \\frac{2}{3} \\approx 0.666...$。\n- 结果：$[0, 0.666...]$。\n\n**用例3：$K = 10$ MW**\n- $d_{\\mathcal{Z}_A}$：$T_{\\mathcal{Z}_A} = 60 > 10$，所以 $d_{\\mathcal{Z}_A} = 1$。\n- $d_{\\mathcal{Z}_B}$：$T_{\\mathcal{Z}_B} = 20 > 10$，所以 $d_{\\mathcal{Z}_B} = 1$。\n- $I_3 = |1 - 1| = 0$。\n- $R_3 = \\frac{40}{10} = 4.0$。\n- 结果：$[0, 4.0]$。\n\n**用例4：$K = 80$ MW**\n- $d_{\\mathcal{Z}_A}$：$T_{\\mathcal{Z}_A} = 60 \\le 80$，所以 $d_{\\mathcal{Z}_A} = 0$。\n- $d_{\\mathcal{Z}_B}$：$T_{\\mathcal{Z}_B} = 20 \\le 80$，所以 $d_{\\mathcal{Z}_B} = 0$。\n- $I_4 = |0 - 0| = 0$。\n- $R_4 = \\frac{40}{80} = 0.5$。\n- 结果：$[0, 0.5]$。\n\n四个测试用例的最终汇总结果是 $[[1, 0.8], [0, 0.666...], [0, 4.0], [0, 0.5]]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the energy system modeling problem presented, calculating MAUP instability metrics.\n    \"\"\"\n    # Define the system data from the problem statement.\n    # Demands (MW)\n    demands = np.array([10.0, 10.0, 30.0, 30.0])\n    # Generator max capacities (MW)\n    gen_caps = np.array([60.0, 20.0, 40.0, 40.0])\n    # Marginal costs ($/MWh)\n    gen_costs = np.array([20.0, 30.0, 100.0, 120.0])\n    # Node indices\n    nodes = np.arange(len(demands))\n    \n    # Define the test cases for transmission capacity K (MW).\n    test_cases = [50.0, 60.0, 10.0, 80.0]\n\n    # Step 1: Calculate the unconstrained least-cost dispatch.\n    # This follows the principle of merit-order dispatch.\n    total_demand = np.sum(demands)\n    \n    # Combine generator properties and sort by cost in ascending order.\n    # Each element is (cost, capacity, original_index)\n    generators_sorted = sorted(zip(gen_costs, gen_caps, nodes), key=lambda x: x[0])\n    \n    # Initialize dispatched generation for each node to zero.\n    dispatched_generation = np.zeros(len(demands))\n    demand_to_meet = total_demand\n    \n    for cost, capacity, index in generators_sorted:\n        if demand_to_meet == 0:\n            break\n        # Dispatch the cheaper generator up to its capacity or until demand is met.\n        dispatch_amount = min(demand_to_meet, capacity)\n        dispatched_generation[index] = dispatch_amount\n        demand_to_meet -= dispatch_amount\n\n    # Step 2: Calculate the required interzonal transfers for each zoning scheme.\n    # Zoning scheme Z_A: West zone W_A = {1,2} (indices 0, 1)\n    D_WA = demands[0] + demands[1]\n    G_WA = dispatched_generation[0] + dispatched_generation[1]\n    T_zA = abs(D_WA - G_WA)\n\n    # Zoning scheme Z_B: West zone W_B = {1,3} (indices 0, 2)\n    D_WB = demands[0] + demands[2]\n    G_WB = dispatched_generation[0] + dispatched_generation[2]\n    T_zB = abs(D_WB - G_WB)\n\n    # Step 3: Evaluate MAUP metrics for each test case.\n    results = []\n    for k_capacity in test_cases:\n        # Determine the binary decision for each scheme. Reinforcement is\n        # recommended if the required transfer strictly exceeds capacity K.\n        d_zA = 1 if T_zA > k_capacity else 0\n        d_zB = 1 if T_zB > k_capacity else 0\n        \n        # Calculate MAUP-induced decision instability indicator I.\n        I = abs(d_zA - d_zB)\n        \n        # Calculate normalized transfer difference R.\n        # This is guaranteed to be safe as K > 0 in all test cases.\n        R = abs(T_zA - T_zB) / k_capacity\n        \n        results.append([I, R])\n\n    # Final print statement in the exact required format.\n    # The format is [[I1,R1],[I2,R2],...], created by joining string representations.\n    stringified_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(stringified_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了聚合离散节点，能源建模中另一种常见的空间表示方法是使用栅格数据，尤其是在可再生能源选址等依赖地理信息系统（GIS）的分析中。此练习将焦点转向栅格数据的分辨率，即模型粒度对优化结果的影响 。你将为一个预算或面积约束下的选址问题，分别在精细（$100\\,\\mathrm{m}$）和粗糙（$1\\,\\mathrm{km}$）两种分辨率的栅格上求解，通过比较最终选择的总容量和总成本差异，亲身体验空间平滑效应如何掩盖局部最优解，并导致次优的规划决策。",
            "id": "4124067",
            "problem": "考虑一个边长为 $L$ 公里（km）的方形规划区域，其坐标 $(x,y)$ 覆盖连续域 $[0,L] \\times [0,L]$。此域上定义了两个空间变化的连续场：一个容量密度场 $r(x,y)$，单位为兆瓦/平方公里（$\\text{MW}/\\text{km}^2$）；以及一个成本密度场 $q(x,y)$，单位为美元/平方公里（$\\text{USD}/\\text{km}^2$）。一个选址模型在该区域内选择位置建设发电项目，目标是在预算约束或面积限制下最大化总容量。为研究模型粒度的敏感性，通过具有两种不同像素尺寸的栅格来对场进行空间表示：像素尺寸为 $100\\,\\mathrm{m}$ 的精细栅格和像素尺寸为 $1\\,\\mathrm{km}$ 的粗糙栅格。像素值定义为基础连续场在该像素面积上的平均值。\n\n选址决策的基本依据：在 $B$ 美元的预算约束下，目标为最大化总容量，同时总成本不超过 $B$ 且允许分数式空间选择的连续优化问题，可以简化为一个分数背包问题。在其离散化的栅格形式中，对于由索引 $i$ 标识的像素，其容量密度为 $\\bar{r}_i$，成本密度为 $\\bar{q}_i$（两者均定义为 $r$ 和 $q$ 在像素面积上的平均值），像素面积为 $a_i$，最优选择规则是按价值成本比 $\\bar{r}_i / \\bar{q}_i$ 对像素进行排序，并按此比率的降序选择像素，允许对最后一个像素进行部分选择以精确满足预算。在面积限制为 $A$ 平方公里（$\\mathrm{km}^2$）（无明确预算约束）的情况下，目标为在面积约束下最大化总容量并允许分数式空间选择，可以简化为按 $\\bar{r}_i$ 的降序选择像素，直到总选定面积等于 $A$，必要时允许对最后一个像素进行部分选择。\n\n定义规划区域尺寸为 $L = 10\\,\\mathrm{km}$，以及连续场的两种情景：\n- 情景 $\\mathcal{H}$（异构场）：\n  - 容量密度 $r(x,y)$ 是一个具有局部峰值的平滑函数：\n    $$r(x,y) = 5 + 20\\exp\\!\\left(-\\frac{(x-2)^2 + (y-7)^2}{0.4^2}\\right) + 10\\exp\\!\\left(-\\frac{(x-8)^2 + (y-3)^2}{0.6^2}\\right) + 3\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L}\\right),$$\n    单位为 $\\mathrm{MW}/\\mathrm{km}^2$。\n  - 成本密度 $q(x,y)$ 是一个平滑的正值场：\n    $$q(x,y) = 120{,}000 + 50{,}000\\exp\\!\\left(-\\frac{(x-5)^2 + (y-5)^2}{1.2^2}\\right) + 30{,}000\\sin\\!\\left(\\frac{2\\pi y}{L}\\right),$$\n    单位为 $\\mathrm{USD}/\\mathrm{km}^2$。\n- 情景 $\\mathcal{U}$（均匀场）：\n  - 对于所有 $(x,y)$，容量密度 $r(x,y) = 8$ $\\mathrm{MW}/\\mathrm{km}^2$。\n  - 对于所有 $(x,y)$，成本密度 $q(x,y) = 100{,}000$ $\\mathrm{USD}/\\mathrm{km}^2$。\n\n栅格化规则：对于一个以公里为单位的栅格像素尺寸 $\\Delta$，该域被划分为边长为 $\\Delta$ 的方形像素。对于每个像素 $i$，其平均容量密度 $\\bar{r}_i$ 和平均成本密度 $\\bar{q}_i$ 定义为 $r(x,y)$ 和 $q(x,y)$ 在该像素面积上的面积均值。在计算中，通过在每个像素内进行均匀子采样来近似面积均值：对于 $\\Delta = 0.1\\,\\mathrm{km}$（对应于 $100\\,\\mathrm{m}$ 像素），每个维度使用 $n_{\\text{sub}} = 3$ 个样本；对于 $\\Delta = 1\\,\\mathrm{km}$ 像素，每个维度使用 $n_{\\text{sub}} = 10$ 个样本。像素面积为 $a_i = \\Delta^2$ $\\mathrm{km}^2$。\n\n选址模型输出：对于给定的情景和约束类型，计算两种栅格分辨率下的总选定容量（MW）和总选定成本（USD）。在预算 $B$ 下，选择像素以最大化总容量，同时总成本不超过 $B$，允许部分选择最后一个像素，使得成本恰好等于 $B$，除非具有正容量成本比的像素集已用尽。在面积限制 $A$ 下，选择像素以最大化总容量，同时总选定面积恰好等于 $A$，允许部分选择最后一个像素。通过报告每个测试用例中总容量的差异（精细减去粗糙，单位 MW）和总成本的差异（精细减去粗糙，单位 USD），来量化对栅格分辨率的敏感性。\n\n测试套件：\n- 测试用例 $1$（理想路径，预算约束，异构场）：情景 $\\mathcal{H}$，预算 $B = 10{,}000{,}000$ $\\mathrm{USD}$。\n- 测试用例 $2$（面积限制，异构场）：情景 $\\mathcal{H}$，面积限制 $A = 20$ $\\mathrm{km}^2$。\n- 测试用例 $3$（边界情况，均匀场）：情景 $\\mathcal{U}$，预算 $B = 5{,}000{,}000$ $\\mathrm{USD}$。\n\n您的程序必须：\n- 按规定实现栅格平均化。\n- 对于预算约束，使用分数背包方法（按 $\\bar{r}_i / \\bar{q}_i$ 排序）解决选择问题；对于面积限制，使用面积限制选择规则（按 $\\bar{r}_i$ 排序）。\n- 为每个测试用例，计算 $100\\,\\mathrm{m}$ 栅格和 $1\\,\\mathrm{km}$ 栅格之间的容量差异（MW）和成本差异（USD）（精细减去粗糙）。\n- 生成一行输出，包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\Delta C_1, \\Delta \\text{Cost}_1, \\Delta C_2, \\Delta \\text{Cost}_2, \\Delta C_3, \\Delta \\text{Cost}_3]$，其中 $\\Delta C_k$ 是测试用例 $k$ 的容量差异（MW），$\\Delta \\text{Cost}_k$ 是测试用例 $k$ 的成本差异（USD）。所有输出均以指定单位的浮点数表示。\n\n本问题中的所有数值常数、变量和运算符均应按其标准数学含义处理。本问题不涉及角度，因此无需指定角度单位。",
            "solution": "用户提供了一个能源系统建模领域的计算问题，重点关注空间粒度对选址决策的影响。该问题要求计算不同情景和空间分辨率下的总装机容量和成本，然后进行敏感性分析。\n\n### 步骤1：问题验证\n\n提交的问题已根据指定标准进行了仔细验证。\n\n-   **已提取的给定条件**：\n    -   **域**：方形区域 $[0, 10\\,\\mathrm{km}] \\times [0, 10\\,\\mathrm{km}]$。\n    -   **场**：容量密度 $r(x,y)$ ($\\mathrm{MW}/\\mathrm{km}^2$) 和成本密度 $q(x,y)$ ($\\mathrm{USD}/\\mathrm{km}^2$)。\n    -   **情景**：异构 ($\\mathcal{H}$) 和均匀 ($\\mathcal{U}$)，为 $r(x,y)$ 和 $q(x,y)$ 提供了明确的数学函数。\n    -   **栅格化**：两种分辨率：精细 ($\\Delta = 0.1\\,\\mathrm{km}$) 和粗糙 ($\\Delta = 1\\,\\mathrm{km}$)。\n    -   **平均规则**：像素值通过子采样来近似，精细分辨率为 $n_{\\text{sub}}=3$，粗糙分辨率为 $n_{\\text{sub}}=10$。\n    -   **优化（预算）**：分数背包方法；按 $\\bar{r}_i/\\bar{q}_i$ 比率排序，选择直至达到预算 $B$。\n    -   **优化（面积）**：贪心方法；按 $\\bar{r}_i$ 排序，选择直至达到面积限制 $A$。\n    -   **测试用例**：\n        1.  $\\mathcal{H}$，预算 $B = 10{,}000{,}000\\,\\mathrm{USD}$。\n        2.  $\\mathcal{H}$，面积 $A = 20\\,\\mathrm{km}^2$。\n        3.  $\\mathcal{U}$，预算 $B = 5{,}000{,}000\\,\\mathrm{USD}$。\n    -   **输出**：每个测试用例的总容量 ($\\mathrm{MW}$) 和总成本 ($\\mathrm{USD}$) 的差异（精细减去粗糙）。\n\n-   **验证评估**：\n    1.  **科学基础**：该问题在应用于能源系统的运筹学和空间分析方面有良好的基础。函数和参数对于建模研究而言，在物理上和经济上都是合理的。成本密度函数 $q(x,y)$ 被确认为严格为正，防止了在价值成本比中出现除以零的情况。\n    2.  **适定性**：该问题是适定的。使用分数背包和贪心算法为每种情况提供了唯一、稳定的解。所有必要的数据和规则都已提供。\n    3.  **客观性**：该问题使用精确的数学语言和客观标准陈述，没有歧义或主观声明。\n\n-   **结论**：该问题是**有效的**。它是一个定义明确的计算练习，可以按所述方式解决。\n\n### 步骤2：解决方案设计\n\n解决方案涉及实现指定的空间离散化和优化算法。该过程被分解为模块化组件：场定义、栅格化和选择。\n\n#### 1. 场表示\n将情景 $\\mathcal{H}$ 和 $\\mathcal{U}$ 的连续密度场 $r(x,y)$ 和 $q(x,y)$ 实现为标准数学函数。这些函数被设计为可以对坐标数组进行操作，以便使用 `numpy` 库进行高效的向量化计算。\n\n#### 2. 空间离散化与平均\n开发了一个核心函数来执行连续域的栅格化。此操作将 $10\\,\\mathrm{km} \\times 10\\,\\mathrm{km}$ 的区域划分为方形像素网格。\n-   对于精细分辨率，边长为 $\\Delta = 0.1\\,\\mathrm{km}$，产生一个 $100 \\times 100$ 的网格。\n-   对于粗糙分辨率，边长为 $\\Delta = 1\\,\\mathrm{km}$，产生一个 $10 \\times 10$ 的网格。\n\n对于网格中的每个像素，按规定计算平均密度值 $\\bar{r}_i$ 和 $\\bar{q}_i$。这是通过在每个像素内生成一个均匀的样本点子网格，在这些点上评估连续场函数，并计算算术平均值来完成的。每个维度的样本数对于精细像素是 $n_{\\text{sub}}=3$，对于粗糙像素是 $n_{\\text{sub}}=10$。此阶段的结果是所有像素的列表，每个像素都由其计算出的平均容量和成本密度表征。\n\n#### 3. 优化与选择算法\n根据指定的约束类型执行项目选址的像素选择。\n\n-   **预算约束选择**：此情况遵循分数背包范式。\n    1.  对于每个像素 $i$，计算价值成本比 $\\bar{r}_i / \\bar{q}_i$。\n    2.  根据此比率按降序对像素进行排序。\n    3.  算法遍历排序后的列表，只要累计成本不超过预算 $B$，就完全“选择”像素。\n    4.  对于会导致超出预算的最后一个像素，将进行部分选择。计算选择该像素的分数，以精确满足预算 $B$。\n    5.  累加总容量和总成本。最终成本将等于 $B$，除非所有具有正比率的像素的总成本小于 $B$。\n\n-   **面积约束选择**：此情况使用一个更简单的贪心算法。\n    1.  根据其平均容量密度 $\\bar{r}_i$ 按降序对像素进行排序。\n    2.  算法遍历排序后的列表，完全选择像素，直到累计面积等于面积限制 $A$。\n    3.  与预算情况类似，最后一个像素被分数式选择以精确满足面积限制 $A$。\n    4.  在所选的完整和部分像素上累加总容量和总成本。\n\n#### 4. 执行与输出生成\n一个主驱动函数为三个测试用例中的每一个执行模拟。对于每个用例，该过程（栅格化和选择）运行两次：一次用于精细分辨率，一次用于粗糙分辨率。\n\n将粗糙模型的总容量和总成本从相应精细模型的结果中减去，以计算每个测试用例 $k$ 的差异 $\\Delta C_k$ 和 $\\Delta \\text{Cost}_k$。然后将这六个值收集并格式化为所需的、由方括号括起的单个逗号分隔字符串。均匀场情景（测试用例3）作为一个重要的合理性检查，因为均匀的密度应该导致分辨率之间的差异为零，这与选择算法无关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n#\n# --- Field Function Definitions ---\n#\n\ndef r_h(x, y, L=10.0):\n    \"\"\"\n    Computes heterogeneous capacity density r(x,y).\n    \"\"\"\n    term1 = 20.0 * np.exp(-((x - 2.0)**2 + (y - 7.0)**2) / 0.4**2)\n    term2 = 10.0 * np.exp(-((x - 8.0)**2 + (y - 3.0)**2) / 0.6**2)\n    term3 = 3.0 * np.sin(2.0 * np.pi * x / L) * np.cos(2.0 * np.pi * y / L)\n    return 5.0 + term1 + term2 + term3\n\ndef q_h(x, y, L=10.0):\n    \"\"\"\n    Computes heterogeneous cost density q(x,y).\n    \"\"\"\n    term1 = 50000.0 * np.exp(-((x - 5.0)**2 + (y - 5.0)**2) / 1.2**2)\n    term2 = 30000.0 * np.sin(2.0 * np.pi * y / L)\n    return 120000.0 + term1 + term2\n\ndef r_u(x, y, L=10.0):\n    \"\"\"\n    Computes uniform capacity density r(x,y).\n    Vectorized to handle array inputs.\n    \"\"\"\n    if isinstance(x, np.ndarray):\n        return np.full(x.shape, 8.0)\n    return 8.0\n\ndef q_u(x, y, L=10.0):\n    \"\"\"\n    Computes uniform cost density q(x,y).\n    Vectorized to handle array inputs.\n    \"\"\"\n    if isinstance(x, np.ndarray):\n        return np.full(x.shape, 100000.0)\n    return 100000.0\n\n#\n# --- Core Solver for a Given Resolution ---\n#\n\ndef solve_for_resolution(scenario, constraint_type, constraint_value, resolution):\n    \"\"\"\n    Solves the siting problem for a given scenario, constraint, and resolution.\n    \"\"\"\n    L = 10.0\n\n    if resolution == 'fine':\n        delta = 0.1\n        n_sub = 3\n    elif resolution == 'coarse':\n        delta = 1.0\n        n_sub = 10\n    else:\n        raise ValueError(\"Invalid resolution\")\n    \n    N = int(L / delta)\n    pixel_area = delta**2\n\n    if scenario == 'H':\n        r_func, q_func = r_h, q_h\n    elif scenario == 'U':\n        r_func, q_func = r_u, q_u\n    else:\n        raise ValueError(\"Invalid scenario\")\n\n    # Generate list of pixels with their properties\n    pixels = []\n    sub_offsets = (np.arange(n_sub) + 0.5) / n_sub * delta\n    \n    for j in range(N):\n        for k in range(N):\n            x_base = j * delta\n            y_base = k * delta\n            \n            # Generate sub-sample coordinates using meshgrid\n            sub_x, sub_y = np.meshgrid(x_base + sub_offsets, y_base + sub_offsets)\n            \n            # Evaluate fields at sub-sample points and average\n            r_avg = np.mean(r_func(sub_x, sub_y))\n            q_avg = np.mean(q_func(sub_x, sub_y))\n            \n            pixels.append({'r_avg': r_avg, 'q_avg': q_avg})\n\n    # Selection process\n    total_capacity = 0.0\n    total_cost = 0.0\n\n    if constraint_type == 'budget':\n        budget = constraint_value\n        \n        # Calculate ratio and filter for positive-ratio pixels\n        # Since q is always positive, this means r > 0. r is also always positive.\n        positive_pixels = [p for p in pixels if p['r_avg'] > 0 and p['q_avg'] > 0]\n        for p in positive_pixels:\n            p['ratio'] = p['r_avg'] / p['q_avg']\n        \n        sorted_pixels = sorted(positive_pixels, key=lambda p: p['ratio'], reverse=True)\n        \n        for p in sorted_pixels:\n            pixel_cost = p['q_avg'] * pixel_area\n            pixel_capacity = p['r_avg'] * pixel_area\n            \n            if total_cost + pixel_cost = budget:\n                total_cost += pixel_cost\n                total_capacity += pixel_capacity\n            else:\n                remaining_budget = budget - total_cost\n                if pixel_cost > 0:\n                    fraction = remaining_budget / pixel_cost\n                    total_cost += fraction * pixel_cost\n                    total_capacity += fraction * pixel_capacity\n                break\n        \n    elif constraint_type == 'area':\n        area_limit = constraint_value\n        \n        # Sort by capacity density\n        sorted_pixels = sorted(pixels, key=lambda p: p['r_avg'], reverse=True)\n        \n        total_area = 0.0\n        for p in sorted_pixels:\n            if total_area + pixel_area = area_limit:\n                total_area += pixel_area\n                total_capacity += p['r_avg'] * pixel_area\n                total_cost += p['q_avg'] * pixel_area\n            else:\n                remaining_area = area_limit - total_area\n                fraction = remaining_area / pixel_area\n                total_area += fraction * pixel_area\n                total_capacity += fraction * p['r_avg'] * pixel_area\n                total_cost += fraction * p['q_avg'] * pixel_area\n                break\n\n    return total_capacity, total_cost\n\n#\n# --- Main Execution Block ---\n#\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'scenario': 'H', 'constraint_type': 'budget', 'constraint_value': 10000000.0},\n        # Test case 2\n        {'scenario': 'H', 'constraint_type': 'area', 'constraint_value': 20.0},\n        # Test case 3\n        {'scenario': 'U', 'constraint_type': 'budget', 'constraint_value': 5000000.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Solve for fine resolution\n        cap_fine, cost_fine = solve_for_resolution(\n            case['scenario'], case['constraint_type'], case['constraint_value'], 'fine'\n        )\n        \n        # Solve for coarse resolution\n        cap_coarse, cost_coarse = solve_for_resolution(\n            case['scenario'], case['constraint_type'], case['constraint_value'], 'coarse'\n        )\n        \n        # Calculate differences (fine - coarse)\n        delta_C = cap_fine - cap_coarse\n        delta_Cost = cost_fine - cost_coarse\n        \n        results.append(delta_C)\n        results.append(delta_Cost)\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}