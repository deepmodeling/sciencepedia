{
    "hands_on_practices": [
        {
            "introduction": "GARCH模型是捕捉能源价格等时间序列中波动率聚集现象的基石。理解其平稳性条件对于长期预测和风险评估至关重要，因为这确保了模型的无条件方差是有限且不随时间变化的。本练习 () 将引导您从第一性原理出发，推导GARCH(1,1)模型的协方差平稳性条件及其无条件方差的表达式，从而巩固您在应用和解释波动率模型时所需的分析基础。",
            "id": "4068740",
            "problem": "一位能源系统分析师研究日前电价的去季节性和去均值后的小时对数回报率，该序列记为 $\\{\\epsilon_t\\}$。波动率的条件异方差性采用广义自回归条件异方差（GARCH）框架进行建模，具体为一个 $\\text{GARCH}(1,1)$ 过程。数据生成方案假定为\n$$\n\\epsilon_t = \\sqrt{h_t}\\, z_t,\\quad \\text{其中}\\quad \\mathbb{E}[z_t]=0,\\ \\mathbb{E}[z_t^2]=1,\\ \\text{$\\{z_t\\}$ 独立于 $\\mathcal{F}_{t-1}$},\n$$\n以及条件方差递归式\n$$\nh_t \\equiv \\mathbb{V}\\mathrm{ar}(\\epsilon_t \\mid \\mathcal{F}_{t-1}) = \\omega + \\alpha \\epsilon_{t-1}^2 + \\beta h_{t-1}.\n$$\n此处，$\\omega>0$、$\\alpha \\ge 0$ 和 $\\beta \\ge 0$ 是未知参数，$\\mathcal{F}_{t-1}$ 表示截至时间 $t-1$ 的信息集。在能源市场结构突变检测的背景下，一个关键的诊断指标是波动率动态是否为协方差平稳的，因为协方差平稳性的丧失可能预示着向一个具有结构性不同风险的新机制的转变。\n\n从协方差平稳性（存在有限且不随时间变化的无条件方差）的基本定义和全期望定律出发，推导在上述 $\\text{GARCH}(1,1)$ 递归下确保 $\\{\\epsilon_t\\}$ 存在有限且不随时间变化的无条件方差的参数限制条件，并求出用 $\\omega$、$\\alpha$ 和 $\\beta$ 表示的无条件方差的表达式。\n\n然后，使用从一个未检测到结构突变的时期内的高频电价回报序列获得的参数估计值 $\\omega = 3.6 \\times 10^{-6}$、$\\alpha = 0.07$ 和 $\\beta = 0.90$，计算无条件方差的数值。将您的最终答案表示为一个无单位的纯数，并四舍五入至四位有效数字。",
            "solution": "问题要求进行两个主要的推导，然后进行数值计算。首先，我们必须推导 $\\text{GARCH}(1,1)$ 过程协方差平稳的参数限制条件。其次，我们必须在此限制条件下求出无条件方差的表达式。最后，我们将使用提供的参数估计值计算该方差的数值。\n\n对数回报率 $\\{\\epsilon_t\\}$ 的 $\\text{GARCH}(1,1)$ 过程定义如下：\n$$\n\\epsilon_t = \\sqrt{h_t}\\, z_t\n$$\n$$\nh_t = \\omega + \\alpha \\epsilon_{t-1}^2 + \\beta h_{t-1}\n$$\n其中 $\\{z_t\\}$ 是一个独立同分布的随机变量序列，满足 $\\mathbb{E}[z_t] = 0$ 和 $\\mathbb{E}[z_t^2] = 1$。参数受约束，使得 $\\omega > 0$，$\\alpha \\ge 0$ 和 $\\beta \\ge 0$。变量 $h_t$ 是在给定截至时间 $t-1$ 的信息集 $\\mathcal{F}_{t-1}$ 的情况下 $\\epsilon_t$ 的条件方差，即 $h_t = \\mathbb{V}\\mathrm{ar}(\\epsilon_t \\mid \\mathcal{F}_{t-1})$。\n\n为使过程 $\\{\\epsilon_t\\}$ 是协方差平稳的（或弱平稳的），其前两个无条件矩必须存在且不随时间变化。具体来说，无条件均值 $\\mathbb{E}[\\epsilon_t]$ 必须是一个常数，无条件方差 $\\mathbb{V}\\mathrm{ar}(\\epsilon_t)$ 必须是一个有限的常数。\n\n首先，我们计算 $\\epsilon_t$ 的无条件均值。我们使用全期望定律：\n$$\n\\mathbb{E}[\\epsilon_t] = \\mathbb{E}[\\mathbb{E}[\\epsilon_t \\mid \\mathcal{F}_{t-1}]]\n$$\n内部的期望是：\n$$\n\\mathbb{E}[\\epsilon_t \\mid \\mathcal{F}_{t-1}] = \\mathbb{E}[\\sqrt{h_t}\\, z_t \\mid \\mathcal{F}_{t-1}]\n$$\n由于 $h_t$ 是在时间 $t-1$ 已知的变量（具体是 $\\epsilon_{t-1}^2$ 和 $h_{t-1}$）的函数，因此它是 $\\mathcal{F}_{t-1}$-可测的。因此，我们可以将 $\\sqrt{h_t}$ 相对于条件期望视为常数：\n$$\n\\mathbb{E}[\\epsilon_t \\mid \\mathcal{F}_{t-1}] = \\sqrt{h_t}\\, \\mathbb{E}[z_t \\mid \\mathcal{F}_{t-1}]\n$$\n问题陈述 $\\{z_t\\}$ 独立于 $\\mathcal{F}_{t-1}$，这意味着 $\\mathbb{E}[z_t \\mid \\mathcal{F}_{t-1}] = \\mathbb{E}[z_t]$。给定 $\\mathbb{E}[z_t] = 0$。因此：\n$$\n\\mathbb{E}[\\epsilon_t \\mid \\mathcal{F}_{t-1}] = \\sqrt{h_t} \\cdot 0 = 0\n$$\n将此代回全期望定律：\n$$\n\\mathbb{E}[\\epsilon_t] = \\mathbb{E}[0] = 0\n$$\n该过程的无条件均值对所有 $t$ 均为 $0$。\n\n接下来，我们计算无条件方差，记为 $\\sigma^2$。由于均值为 $0$，方差等于二阶矩：\n$$\n\\sigma^2 = \\mathbb{V}\\mathrm{ar}(\\epsilon_t) = \\mathbb{E}[\\epsilon_t^2] - (\\mathbb{E}[\\epsilon_t])^2 = \\mathbb{E}[\\epsilon_t^2]\n$$\n再次，我们应用全期望定律：\n$$\n\\sigma^2 = \\mathbb{E}[\\epsilon_t^2] = \\mathbb{E}[\\mathbb{E}[\\epsilon_t^2 \\mid \\mathcal{F}_{t-1}]]\n$$\n内部期望是 $\\epsilon_t$ 的条件方差，因为条件均值为 $0$：\n$$\n\\mathbb{E}[\\epsilon_t^2 \\mid \\mathcal{F}_{t-1}] = \\mathbb{V}\\mathrm{ar}(\\epsilon_t \\mid \\mathcal{F}_{t-1}) + (\\mathbb{E}[\\epsilon_t \\mid \\mathcal{F}_{t-1}])^2 = h_t + 0^2 = h_t\n$$\n这给出了一个关键关系：$\\epsilon_t$ 的无条件方差是条件方差 $h_t$ 的无条件期望：\n$$\n\\sigma^2 = \\mathbb{E}[h_t]\n$$\n现在，我们对 $h_t$ 递归方程取无条件期望：\n$$\n\\mathbb{E}[h_t] = \\mathbb{E}[\\omega + \\alpha \\epsilon_{t-1}^2 + \\beta h_{t-1}]\n$$\n利用期望的线性性质：\n$$\n\\mathbb{E}[h_t] = \\omega + \\alpha \\mathbb{E}[\\epsilon_{t-1}^2] + \\beta \\mathbb{E}[h_{t-1}]\n$$\n对于协方差平稳性，无条件方差必须不随时间变化。令 $\\sigma^2 = \\mathbb{V}\\mathrm{ar}(\\epsilon_t) = \\mathbb{V}\\mathrm{ar}(\\epsilon_{t-1})$。这意味着 $\\mathbb{E}[\\epsilon_t^2] = \\mathbb{E}[\\epsilon_{t-1}^2] = \\sigma^2$。因此，条件方差的无条件期望也必须是常数，即 $\\mathbb{E}[h_t] = \\mathbb{E}[h_{t-1}] = \\sigma^2$。\n\n将这些代入期望递归式：\n$$\n\\sigma^2 = \\omega + \\alpha \\sigma^2 + \\beta \\sigma^2\n$$\n我们现在可以解出 $\\sigma^2$：\n$$\n\\sigma^2 = \\omega + (\\alpha + \\beta) \\sigma^2\n$$\n$$\n\\sigma^2 - (\\alpha + \\beta) \\sigma^2 = \\omega\n$$\n$$\n\\sigma^2 (1 - (\\alpha + \\beta)) = \\omega\n$$\n$$\n\\sigma^2 = \\frac{\\omega}{1 - (\\alpha + \\beta)}\n$$\n这就是 $\\text{GARCH}(1,1)$ 过程的无条件方差的表达式。\n\n为了使这个无条件方差 $\\sigma^2$ 是良定义的、有限的且为正，必须满足两个条件。由于根据定义 $\\omega > 0$，分母必须严格为正：\n$$\n1 - (\\alpha + \\beta) > 0\n$$\n这就得出了协方差平稳性的参数限制条件：\n$$\n\\alpha + \\beta  1\n$$\n结合非负性约束，完整的条件集是 $\\omega  0$，$\\alpha \\ge 0$，$\\beta \\ge 0$ 和 $\\alpha + \\beta  1$。\n\n现在，我们使用提供的参数估计值进行数值计算：\n$$\n\\omega = 3.6 \\times 10^{-6}\n$$\n$$\n\\alpha = 0.07\n$$\n$$\n\\beta = 0.90\n$$\n首先，我们检查平稳性条件：\n$$\n\\alpha + \\beta = 0.07 + 0.90 = 0.97\n$$\n由于 $0.97  1$，协方差平稳性的条件得到满足，并且存在一个有限的正的无条件方差。\n\n我们使用推导出的公式计算无条件方差 $\\sigma^2$：\n$$\n\\sigma^2 = \\frac{\\omega}{1 - (\\alpha + \\beta)} = \\frac{3.6 \\times 10^{-6}}{1 - 0.97}\n$$\n$$\n\\sigma^2 = \\frac{3.6 \\times 10^{-6}}{0.03}\n$$\n$$\n\\sigma^2 = \\frac{3.6}{3 \\times 10^{-2}} \\times 10^{-6} = 1.2 \\times 10^2 \\times 10^{-6} = 1.2 \\times 10^{-4}\n$$\n问题要求答案四舍五入到四位有效数字。计算值为 $1.2 \\times 10^{-4}$，其小数形式为 $0.00012$。为用四位有效数字表示，我们将其写为 $0.0001200$ 或用科学记数法表示为 $1.200 \\times 10^{-4}$。",
            "answer": "$$\\boxed{1.200 \\times 10^{-4}}$$"
        },
        {
            "introduction": "在能源系统中，许多过程（如电力需求）在不同条件下（如寒冷与温暖天气）会表现出截然不同的动态行为。阈值自回归（TAR）模型为此类体制转换行为提供了一个直观而强大的建模框架。本练习 () 要求您通过编程实现一个TAR模型，以探索系统对外部冲击的动态响应（即脉冲响应函数）如何依赖于其所处的体制，从而加深对非线性动力学和状态依赖冲击传导机制的理解。",
            "id": "4068748",
            "problem": "考虑一个能源需求偏差过程，该过程被建模为一个门限自回归 (TAR) 系统，其短期动态取决于环境温度状态。设在离散时间索引 $t$ 时净负荷与其基线的偏差表示为 $y_t$（单位：兆瓦）。该过程遵循一个基于温度的单一门限的一阶 TAR 递归：\n$$\ny_t =\n\\begin{cases}\n\\phi_{\\text{cold}} \\, y_{t-1} + \\varepsilon_t,  \\text{若 } T_{t-1}  \\tau, \\\\\n\\phi_{\\text{warm}} \\, y_{t-1} + \\varepsilon_t,  \\text{若 } T_{t-1} \\ge \\tau,\n\\end{cases}\n$$\n其中 $T_{t}$ 是环境温度（单位：摄氏度），$\\tau$ 是一个固定的门限（单位：摄氏度），$\\phi_{\\text{cold}}$ 和 $\\phi_{\\text{warm}}$ 是特定状态的自回归系数，而 $\\varepsilon_t$ 是一个加性冲击。\n\n在此非线性设定中，将脉冲响应函数 (IRF) 定义为当时间 $t=0$ 时施加一个大小为 $s$ 的单一冲击，$y_{-1}=0$，$\\varepsilon_0 = s$，且对所有 $t \\ge 1$ 都有 $\\varepsilon_t = 0$ 时，$y_t$ 的确定性路径。在此定义下，有限期界 $H$ 内的 IRF 序列 $\\{y_t\\}_{t=0}^H$ 遵循\n$$\ny_0 = s, \\quad\ny_t =\n\\begin{cases}\n\\phi_{\\text{cold}} \\, y_{t-1},  \\text{若 } T_{t-1}  \\tau, \\\\\n\\phi_{\\text{warm}} \\, y_{t-1},  \\text{若 } T_{t-1} \\ge \\tau,\n\\end{cases}\n\\quad \\text{对于 } t=1,2,\\dots,H,\n$$\n其中步骤 $t$ 的状态由前一时刻的温度 $T_{t-1}$ 决定。温度路径 $\\{T_{0}, T_{1}, \\dots, T_{H-1}\\}$ 被视为外生且已知。\n\n您的任务是实现一个程序，给定状态系数、门限、冲击大小、期界和温度路径，根据上述递归计算特定状态的 IRF 序列 $\\{y_t\\}_{t=0}^H$。所有 IRF 值必须以兆瓦为单位返回，并四舍五入到六位小数。\n\n从时间序列分析和能源系统建模的公认基础出发，推导过程必须仅依赖于以下基础：\n- 一阶自回归满足 $y_t = \\phi \\, y_{t-1} + \\varepsilon_t$ 的自回归定义。\n- 脉冲响应函数的定义，即一次性冲击在所有后续冲击为零的情况下的传播。\n- 基于外生门限变量的状态选择规则，其中系数根据 $T_{t-1}$ 是低于还是高于门限 $\\tau$ 进行切换。\n\n问题陈述中不提供额外的快捷公式。\n\n实现您的程序，为以下测试套件计算 IRF，该套件探讨了特定状态冲击传播的不同方面：\n\n- 测试用例 1 (持续寒冷): $\\phi_{\\text{cold}} = 0.8$，$\\phi_{\\text{warm}} = 0.3$，$\\tau = 0.0$ 摄氏度，$s = 100.0$ 兆瓦，$H = 10$，以及对所有 $t=0,\\dots,9$ 恒定的温度路径 $T_t = -5.0$ 摄氏度。\n\n- 测试用例 2 (较高门限下的持续温暖): $\\phi_{\\text{cold}} = 0.7$，$\\phi_{\\text{warm}} = 0.4$，$\\tau = 15.0$ 摄氏度，$s = 120.0$ 兆瓦，$H = 8$，以及对所有 $t=0,\\dots,7$ 恒定的温度路径 $T_t = 20.0$ 摄氏度。\n\n- 测试用例 3 (从寒冷状态切换到温暖状态): $\\phi_{\\text{cold}} = 0.98$，$\\phi_{\\text{warm}} = 0.4$，$\\tau = 0.0$ 摄氏度，$s = 50.0$ 兆瓦，$H = 10$，以及由列表 $[-3.0,-2.0,-1.0,0.5,5.0,5.0,5.0,5.0,5.0,5.0]$ 给出的温度路径 $T_t$。\n\n- 测试用例 4 (带符号变化的门限等式边界): $\\phi_{\\text{cold}} = 0.6$，$\\phi_{\\text{warm}} = -0.1$，$\\tau = 10.0$ 摄氏度，$s = 80.0$ 兆瓦，$H = 9$，以及由列表 $[10.0,10.0,9.5,10.0,10.5,10.0,10.0,10.0,10.0]$ 给出的温度路径 $T_t$。请注意，根据定义，当 $T_{t-1} \\ge \\tau$ 时使用温暖状态。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。每个“result”本身必须是一个带括号的逗号分隔浮点数列表（四舍五入到六位小数），代表相应测试用例的 IRF 序列 $[y_0,y_1,\\dots,y_H]$（单位：兆瓦）。",
            "solution": "该问题是有效的。它在科学上基于非线性时间序列分析的既有理论，特别是门限自回归 (TAR) 模型。这些模型常用于为具有状态转换行为的物理和经济系统（如能源需求）建模。该问题是适定的，提供了一套完整且明确的定义、参数和清晰的递归公式，确保了唯一且可计算的解。所有术语都得到了客观而精确的定义，所提供的测试用例是一致且在计算上可行的。\n\n该问题要求计算一阶 TAR 模型的脉冲响应函数 (IRF)。该模型将净负荷偏差 $y_t$ 的演变描述为其过去值 $y_{t-1}$ 和一个外生门限变量（环境温度 $T_{t-1}$）的函数。系统动态在“寒冷”和“温暖”两种状态之间切换，具体取决于温度是低于还是高于给定的门限 $\\tau$。\n\n该模型由以下递归定义：\n$$\ny_t =\n\\begin{cases}\n\\phi_{\\text{cold}} \\, y_{t-1} + \\varepsilon_t,  \\text{若 } T_{t-1}  \\tau \\\\\n\\phi_{\\text{warm}} \\, y_{t-1} + \\varepsilon_t,  \\text{若 } T_{t-1} \\ge \\tau\n\\end{cases}\n$$\n在这里，$y_t$ 是以兆瓦为单位的偏差，$T_{t-1}$ 是时间 $t-1$ 时以摄氏度为单位的温度，$\\tau$ 是温度门限，$\\phi_{\\text{cold}}$ 和 $\\phi_{\\text{warm}}$ 分别是寒冷和温暖状态的自回归系数，$\\varepsilon_t$ 是一个随机冲击项。\n\nIRF 被定义为系统对单一、一次性冲击响应的确定性路径。具体来说，我们给定在时间 $t=0$ 时的初始冲击 $\\varepsilon_0 = s$，系统从静止状态 ($y_{-1}=0$) 开始，并且没有后续冲击（对于 $t \\ge 1$，$\\varepsilon_t = 0$）。将这些条件代入通用模型，可以得到有限期界 $H$ 内 IRF 序列 $\\{y_t\\}_{t=0}^H$ 的递归公式：\n\n时间 $t=0$ 时的初始响应就是冲击本身，即 $y_0 = \\phi \\cdot y_{-1} + \\varepsilon_0 = \\phi \\cdot 0 + s$。\n$$\ny_0 = s\n$$\n对于所有后续时间 $t=1, 2, \\dots, H$，冲击项为零，其演变由模型的确定性部分控制：\n$$\ny_t =\n\\begin{cases}\n\\phi_{\\text{cold}} \\, y_{t-1},  \\text{若 } T_{t-1}  \\tau \\\\\n\\phi_{\\text{warm}} \\, y_{t-1},  \\text{若 } T_{t-1} \\ge \\tau\n\\end{cases}\n$$\n这是一个一阶差分方程，其系数不是常数，而是在每个时间步根据外生给定的温度路径 $\\{T_0, T_1, \\dots, T_{H-1}\\}$ 来选择。\n\n计算 IRF 序列 $\\{y_0, y_1, \\dots, y_H\\}$ 的算法是该递归定义的直接、迭代应用。\n\n1.  初始化一个空序列来存储 IRF 值。我们将其表示为 $\\mathcal{Y}$。\n2.  将响应的初始值 $y_0$ 设置为 $s$，并将其添加到序列 $\\mathcal{Y}$ 中。\n3.  对从 $1$ 到 $H$ 的每个时间步 $t$ 进行迭代。在每一步中：\n    a. 检索响应的前一个值 $y_{t-1}$，它是已计算并存储在 $\\mathcal{Y}$ 中的最后一个元素。\n    b. 从给定的温度路径中检索前一个时间步的温度 $T_{t-1}$。\n    c. 将 $T_{t-1}$ 与门限 $\\tau$进行比较，以确定活动状态并选择相应的自回归系数 $\\phi$。\n    $$\n    \\phi =\n    \\begin{cases}\n    \\phi_{\\text{cold}},  \\text{若 } T_{t-1}  \\tau \\\\\n    \\phi_{\\text{warm}},  \\text{若 } T_{t-1} \\ge \\tau\n    \\end{cases}\n    $$\n    d. 计算响应的下一个值，$y_t = \\phi \\cdot y_{t-1}$。\n    e. 将 $y_t$ 追加到序列 $\\mathcal{Y}$ 中。\n4.  迭代到 $t=H$ 后，序列 $\\mathcal{Y}$ 将包含 IRF 的 $H+1$ 个元素，即 $\\{y_0, y_1, \\dots, y_H\\}$。\n5.  根据问题的要求，最终序列中的每个值都必须四舍五入到六位小数。\n\n让我们为测试用例 3 追踪此过程：$\\phi_{\\text{cold}} = 0.98$，$\\phi_{\\text{warm}} = 0.4$，$\\tau = 0.0$，$s = 50.0$，$H = 10$，以及 $T_t = [-3.0, -2.0, -1.0, 0.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]$。\n\n-   $t=0$：$y_0 = s = 50.0$。\n-   $t=1$：相关温度为 $T_0 = -3.0$。由于 $-3.0  0.0$，我们使用 $\\phi_{\\text{cold}} = 0.98$。\n    $y_1 = \\phi_{\\text{cold}} \\cdot y_0 = 0.98 \\times 50.0 = 49.0$。\n-   $t=2$：相关温度为 $T_1 = -2.0$。由于 $-2.0  0.0$，我们使用 $\\phi_{\\text{cold}} = 0.98$。\n    $y_2 = \\phi_{\\text{cold}} \\cdot y_1 = 0.98 \\times 49.0 = 48.02$。\n-   $t=3$：相关温度为 $T_2 = -1.0$。由于 $-1.0  0.0$，我们使用 $\\phi_{\\text{cold}} = 0.98$。\n    $y_3 = \\phi_{\\text{cold}} \\cdot y_2 = 0.98 \\times 48.02 = 47.0596$。\n-   $t=4$：相关温度为 $T_3 = 0.5$。由于 $0.5 \\ge 0.0$，状态发生切换。我们使用 $\\phi_{\\text{warm}} = 0.4$。\n    $y_4 = \\phi_{\\text{warm}} \\cdot y_3 = 0.4 \\times 47.0596 = 18.82384$。\n-   $t=5$：相关温度为 $T_4 = 5.0$。由于 $5.0 \\ge 0.0$，我们继续在温暖状态。\n    $y_5 = \\phi_{\\text{warm}} \\cdot y_4 = 0.4 \\times 18.82384 = 7.529536$。\n\n这个过程对 $t=6, \\dots, 10$ 迭代继续。实现将推广此逻辑以适用于任何给定的参数集。特别注意边界条件 $T_{t-1} = \\tau$，根据定义，该条件属于温暖状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the impulse response function (IRF)\n    for a Threshold Autoregressive (TAR) process for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: (phi_cold, phi_warm, tau, s, H, T_path)\n        (0.8, 0.3, 0.0, 100.0, 10, [-5.0] * 10),\n        # Test Case 2\n        (0.7, 0.4, 15.0, 120.0, 8, [20.0] * 8),\n        # Test Case 3\n        (0.98, 0.4, 0.0, 50.0, 10, [-3.0, -2.0, -1.0, 0.5, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]),\n        # Test Case 4\n        (0.6, -0.1, 10.0, 80.0, 9, [10.0, 10.0, 9.5, 10.0, 10.5, 10.0, 10.0, 10.0, 10.0]),\n    ]\n\n    def compute_irf(phi_cold, phi_warm, tau, s, H, T_path):\n        \"\"\"\n        Computes the IRF for a TAR(1) model.\n\n        Args:\n            phi_cold (float): AR coefficient for the cold regime.\n            phi_warm (float): AR coefficient for the warm regime.\n            tau (float): Temperature threshold.\n            s (float): Magnitude of the initial shock.\n            H (int): Horizon for the IRF.\n            T_path (list of float): Exogenous temperature path of length H.\n\n        Returns:\n            list of float: The IRF sequence [y_0, y_1, ..., y_H],\n                           with each value rounded to 6 decimal places.\n        \"\"\"\n        irf_sequence = []\n\n        # Initial value of the response at t=0\n        y_current = s\n        irf_sequence.append(y_current)\n\n        # Iterate from t=1 to H to compute the rest of the sequence\n        for t in range(1, H + 1):\n            # The regime is determined by the temperature at the previous time_step\n            # For y_t, we need T_{t-1}\n            temp_prev = T_path[t - 1]\n            y_prev = irf_sequence[t - 1]\n\n            if temp_prev  tau:\n                # Cold regime\n                phi = phi_cold\n            else:\n                # Warm regime (handles T_{t-1} = tau)\n                phi = phi_warm\n            \n            y_current = phi * y_prev\n            irf_sequence.append(y_current)\n        \n        # Round all values in the sequence to 6 decimal places\n        rounded_irf = [round(val, 6) for val in irf_sequence]\n        \n        return rounded_irf\n\n    results = []\n    for case in test_cases:\n        phi_cold, phi_warm, tau, s, H, T_path = case\n        result_sequence = compute_irf(phi_cold, phi_warm, tau, s, H, T_path)\n        \n        # Format the sequence as a string \"[v1,v2,...]\"\n        result_str = \"[\" + \",\".join(map(str, result_sequence)) + \"]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在时间序列分析中，检测未知的结构突变点是一个核心挑战，而高斯过程（GP）为此提供了一种灵活的非参数化方法。通过巧妙地设计协方差函数（即核函数），我们可以将关于数据结构的先验知识（如体制转换的存在）融入模型中。本项高级计算实践 () 将引导您应用带有转换点核的高斯过程，对一个发生结构突变的光伏发电序列进行建模，并通过最大化边际似然函数来自动定位变化点并进行预测，从而掌握一项复杂的现代建模技术。",
            "id": "4068711",
            "problem": "您的任务是构建一个完整的、可运行的程序，该程序应用带有变化点核的高斯过程（GP）来预测太阳能光伏发电量，并计算检测到的体系变化前后的预测均值和预测方差。背景是能源系统建模，涉及先进的时间序列建模和体系变化检测。所有角度都必须以弧度处理。所有预测均值必须以千瓦（kilowatts）为单位表示，所有预测方差必须以千瓦的平方为单位表示，但您必须输出原始数值，格式为浮点数，不带单位字符串。\n\n假设标量时间序列 $y(t)$ 服从零均值和协方差为 $k(t,t')$ 的高斯过程（GP）先验。训练输入是以天为单位的时间 $t$，输出 $y(t)$ 是从物理上合理的日循环模式中导出的确定性太阳能发电测量值。对于太阳能发电，使用物理上现实的半波正弦函数\n$$\ng(t) = \\max\\{0, \\sin(2\\pi t)\\},\n$$\n它模拟了周期为 $p=1$ 天的日间发电量。考虑在未知断点位置 $t_0$（以天为单位）发生的体系变化，使用平滑的逻辑斯蒂转换权重\n$$\nw(t; a, t_0) = \\frac{1}{1 + \\exp\\left(-a\\,(t - t_0)\\right)},\n$$\n其中 $a$ 是一个正的陡度参数。定义一个基础协方差，它通过周期核和平方指数核的和来捕捉每日周期性和缓慢的时间相关性：\n$$\nk_{\\mathrm{per}}(t,t'; p, \\ell_p) = \\exp\\!\\left(-\\frac{2\\sin^2\\!\\left(\\pi\\,\\frac{|t-t'|}{p}\\right)}{\\ell_p^2}\\right),\n$$\n$$\nk_{\\mathrm{se}}(t,t'; \\ell_{\\mathrm{se}}) = \\exp\\!\\left(-\\frac{(t-t')^2}{2\\ell_{\\mathrm{se}}^2}\\right),\n$$\n以及\n$$\nk_{\\mathrm{base}}(t,t') = k_{\\mathrm{per}}(t,t'; p, \\ell_p) + k_{\\mathrm{se}}(t,t'; \\ell_{\\mathrm{se}}).\n$$\n令体系变化前后的振幅分别为 $ \\alpha_1 $ 和 $ \\alpha_2 $。变化点协方差指定为\n$$\nk_{\\mathrm{cp}}(t,t') = \\bigl(1-w(t; a, t_0)\\bigr)\\bigl(1-w(t'; a, t_0)\\bigr)\\,\\alpha_1^2\\, k_{\\mathrm{base}}(t,t') \\;+\\; w(t; a, t_0)\\, w(t'; a, t_0)\\,\\alpha_2^2\\, k_{\\mathrm{base}}(t,t').\n$$\n假设存在独立同分布的高斯观测噪声，其方差为 $\\sigma_n^2$，因此训练协方差为 $K = k_{\\mathrm{cp}}(X,X) + \\sigma_n^2 I$，其中 $X$ 是训练时间的向量。\n\n您的程序必须：\n- 为每个测试用例确定性地生成训练数据，方法是在从 $0$ 到 $T_{\\mathrm{end}}$ 的范围内以 $\\Delta t = 1/6$ 天为步长对时间 $t$ 进行采样。真实的太阳能发电量为\n$$\ny(t) = \\begin{cases}\n\\alpha_1\\, g(t),  t  t_{\\mathrm{break}}\\\\\n\\alpha_2\\, g(t),  t \\ge t_{\\mathrm{break}}\n\\end{cases}\n$$\n$y(t)$ 中不添加随机噪声。量 $t_{\\mathrm{break}}$ 是用于构建数据的真实断点；它对GP是未知的，除了用于构建训练集外，算法不应使用它。GP模型使用变化点核，其中固定的 $(\\alpha_1,\\alpha_2)$ 取自数据生成振幅，固定的 $(p,\\ell_p,\\ell_{\\mathrm{se}},a,\\sigma_n)$ 如下文所述。\n- 通过在候选断点位置 $t_0 \\in [0.5, T_{\\mathrm{end}}-0.5]$ 的网格上（增量为0.25天）最大化对数边际似然来检测断点位置 $t_0$，同时保持所有其他超参数固定。使用标准高斯过程对数边际似然定义和Cholesky分解以保证数值稳定性，并在协方差对角线上添加一个抖动项以增强鲁棒性。\n- 使用检测到的断点 $\\hat{t}_0$，计算在三个查询时间点 $t_q^{-} = \\hat{t}_0 - 0.25$、$t_q^{0} = \\hat{t}_0$ 和 $t_q^{+} = \\hat{t}_0 + 0.25$ 处潜在函数的GP预测均值和预测方差。使用从高斯先验和高斯似然导出的潜在函数的后验预测均值和方差（在查询时从方差中排除观测噪声）。均值以千瓦为单位表示，方差以千瓦的平方为单位表示。所有三角函数中的角度必须使用弧度。\n\n所有测试用例的固定超参数：\n- 周期 $p = 1$。\n- 周期性长度尺度 $\\ell_p = 0.3$。\n- 平方指数长度尺度 $\\ell_{\\mathrm{se}} = 1.5$。\n- 逻辑斯蒂陡度 $a = 15$。\n- 观测噪声标准差 $\\sigma_n = 0.05$。\n\n测试套件（每个元组提供 $(T_{\\mathrm{end}}, t_{\\mathrm{break}}, \\alpha_1, \\alpha_2)$）：\n- 用例1： $(30, 12, 5.0, 3.5)$。\n- 用例2（边界断点和振幅增加）： $(10, 1.5, 4.0, 6.0)$。\n- 用例3： $(20, 15, 6.0, 4.2)$。\n- 用例4（数据中无断点场景，但仍继续进行检测）： $(15, 0.0, 5.0, 5.0)$。\n\n算法要求：\n- 使用上述定义和高斯随机向量的基本性质来推导和实现检测与预测所需的后验和对数边际似然。不要假设任何不能从高斯过程先验和高斯似然推导出的捷径公式。\n- 在协方差矩阵的对角线上添加 $10^{-8}$ 的抖动项，以确保Cholesky分解的数值稳定性。\n\n最终输出格式：\n- 对每个测试用例，按顺序 $[\\mu^{-}, v^{-}, \\mu^{0}, v^{0}, \\mu^{+}, v^{+}]$ 生成一个包含6个浮点数的列表，其中 $\\mu^{\\cdot}$ 是在 $t_q^{-}$、$t_q^{0}$ 和 $t_q^{+}$ 处的预测均值（单位：千瓦），$v^{\\cdot}$ 是预测方差（单位：千瓦的平方）。\n- 将所有测试用例的结果汇总到一个单一的Python列表中，按照测试套件的顺序展平并连接，然后精确打印一行包含此列表的内容，格式为 $[r_1,r_2,\\dots,r_{24}]$，其中24是四个测试用例的总值数。",
            "solution": "问题根据验证标准进行评估。\n\n**第1步：提取给定条件**\n- **数据生成模型：** $y(t) = \\begin{cases} \\alpha_1\\, g(t),  t  t_{\\mathrm{break}}\\\\ \\alpha_2\\, g(t),  t \\ge t_{\\mathrm{break}} \\end{cases}$，其中 $g(t) = \\max\\{0, \\sin(2\\pi t)\\}$.\n- **GP先验：** 零均值。协方差 $k(t,t')$ 是一个变化点核 $k_{\\mathrm{cp}}(t,t')$。\n- **变化点核：** $k_{\\mathrm{cp}}(t,t') = \\bigl(1-w(t; a, t_0)\\bigr)\\bigl(1-w(t'; a, t_0)\\bigr)\\,\\alpha_1^2\\, k_{\\mathrm{base}}(t,t') \\;+\\; w(t; a, t_0)\\, w(t'; a, t_0)\\,\\alpha_2^2\\, k_{\\mathrm{base}}(t,t')$。\n- **转换权重：** $w(t; a, t_0) = \\frac{1}{1 + \\exp\\left(-a\\,(t - t_0)\\right)}$。\n- **基础核：** $k_{\\mathrm{base}}(t,t') = k_{\\mathrm{per}}(t,t'; p, \\ell_p) + k_{\\mathrm{se}}(t,t'; \\ell_{\\mathrm{se}})$。\n- **构成核：** $k_{\\mathrm{per}}(t,t'; p, \\ell_p) = \\exp\\!\\left(-\\frac{2\\sin^2\\!\\left(\\pi\\,\\frac{|t-t'|}{p}\\right)}{\\ell_p^2}\\right)$ 和 $k_{\\mathrm{se}}(t,t'; \\ell_{\\mathrm{se}}) = \\exp\\!\\left(-\\frac{(t-t')^2}{2\\ell_{\\mathrm{se}}^2}\\right)$。\n- **观测噪声：** 独立同分布的高斯噪声，方差为 $\\sigma_n^2$。\n- **训练协方差：** $K_y = k_{\\mathrm{cp}}(X,X) + \\sigma_n^2 I$。\n- **训练数据采样：** 时间 $t$ 从 $0$ 到 $T_{\\mathrm{end}}$，步长为 $\\Delta t = 1/6$ 天。\n- **变化点检测：** 在 $t_0 \\in [0.5, T_{\\mathrm{end}}-0.5]$ 上以步长 $0.25$ 天最大化对数边际似然。\n- **预测查询时间：** $t_q^{-} = \\hat{t}_0 - 0.25$, $t_q^{0} = \\hat{t}_0$, 和 $t_q^{+} = \\hat{t}_0 + 0.25$，其中 $\\hat{t}_0$ 是检测到的断点。\n- **固定超参数：** $p = 1$, $\\ell_p = 0.3$, $\\ell_{\\mathrm{se}} = 1.5$, $a = 15$, $\\sigma_n = 0.05$。\n- **数值稳定性：** 在协方差对角线上加 $10^{-8}$ 的抖动项。\n- **测试用例** $(T_{\\mathrm{end}}, t_{\\mathrm{break}}, \\alpha_1, \\alpha_2)$: 用例1： $(30, 12, 5.0, 3.5)$；用例2： $(10, 1.5, 4.0, 6.0)$；用例3： $(20, 15, 6.0, 4.2)$；用例4： $(15, 0.0, 5.0, 5.0)$。\n\n**第2步：使用提取的给定条件进行验证**\n该问题在科学和数学上是合理的，基于高斯过程的既定框架。所有模型、参数和程序都有明确定义，使得问题适定、客观且完整。计算任务是可行的。未发现不一致或违反科学原则之处。\n\n**第3步：结论与行动**\n问题是**有效的**。下面是一个基于原则的解决方案。\n\n**理论阐述**\n高斯过程（GP）定义了函数上的一个分布。我们将时间序列 $f(t)$ 建模为从一个零均值函数和协方差函数（或核）$k(t, t')$ 的GP中抽取。观测值 $y$ 被假定为真实函数 $f$ 的带噪声版本，即 $y(t) = f(t) + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma_n^2)$。\n\n令 $X = \\{t_1, \\dots, t_N\\}$ 为 $N$ 个训练时间点的集合， $y$ 为对应的观测太阳能发电量值的向量。令 $X_*$ 为我们希望进行预测的测试（查询）时间点的集合。训练输出 $y$ 和在测试点 $X_*$ 处的潜在函数值 $f_*$ 的联合分布由一个多元高斯分布给出：\n$$\n\\begin{pmatrix} y \\\\ f_* \\end{pmatrix} \\sim \\mathcal{N}\\left( \\mathbf{0}, \\begin{pmatrix} K(X,X)+\\sigma_n^2 I  K(X,X_*) \\\\ K(X_*,X)  K(X_*,X_*) \\end{pmatrix} \\right)\n$$\n其中 $K(A, B)$ 是所有 $t_a \\in A, t_b \\in B$ 的协方差 $k(t_a, t_b)$ 构成的矩阵， $I$ 是单位矩阵。为方便起见，令 $K_y = K(X,X)+\\sigma_n^2 I$，$K_* = K(X,X_*)$，以及 $K_{**} = K(X_*,X_*)$。\n\n**通过对数边际似然（LML）进行变化点检测**\n模型参数 $t_0$ 是通过最大化给定输入 $X$ 和超参数 $\\theta = \\{t_0, \\alpha_1, \\alpha_2, p, \\ell_p, \\ell_{\\mathrm{se}}, a, \\sigma_n\\}$ 下观测值 $y$ 的对数边际似然来确定的。LML是证据 $p(y | X, \\theta)$ 的概率密度的对数，该概率密度是在所有可能的函数 $f$ 上积分得到的：\n$$\n\\log p(y | X, \\theta) = -\\frac{1}{2} y^T K_y^{-1} y - \\frac{1}{2} \\log |K_y| - \\frac{N}{2} \\log(2\\pi)\n$$\n直接计算逆矩阵 $K_y^{-1}$ 和行列式 $|K_y|$ 在数值上不稳定且计算成本高昂（$O(N^3)$）。取而代之，我们使用Cholesky分解 $K_y = L L^T$，其中 $L$ 是一个下三角矩阵。LML的各项随后可以高效且稳定地计算：\n1. 对数行列式项为 $\\log|K_y| = \\log|L L^T| = 2 \\log|L| = 2 \\sum_{i=1}^N \\log(L_{ii})$。\n2. 二次项 $y^T K_y^{-1} y$ 通过首先求解 $L \\mathbf{v} = y$ 得到 $\\mathbf{v}$（前向替换），然后求解 $L^T \\boldsymbol{\\alpha} = \\mathbf{v}$ 得到 $\\boldsymbol{\\alpha}$（后向替换），其中 $\\boldsymbol{\\alpha} = K_y^{-1} y$。该项即为 $y^T \\boldsymbol{\\alpha}$。\n\nLML在候选 $t_0$ 值的离散网格上被最大化，以找到最佳断点位置 $\\hat{t}_0$。\n\n**后验预测**\n使用多元高斯分布的条件化规则，我们可以找到给定训练数据下 $f_*$ 的分布 $p(f_* | X, y, X_*)$。这个后验分布也是一个高斯分布 $\\mathcal{N}(\\mu_*, \\Sigma_*)$，其均值和协方差由以下公式给出：\n$$\n\\mu_* = K(X_*, X) [K(X,X)+\\sigma_n^2 I]^{-1} y = K_*^T K_y^{-1} y\n$$\n$$\n\\Sigma_* = K(X_*, X_*) - K(X_*, X) [K(X,X)+\\sigma_n^2 I]^{-1} K(X, X_*) = K_{**} - K_*^T K_y^{-1} K_*\n$$\n问题要求潜在函数的预测方差，即后验协方差矩阵 $\\Sigma_*$ 的对角元素。这些也可以使用 $K_y$ 的Cholesky因子 $L$ 高效计算：\n- 预测均值：$\\mu_* = K_*^T \\boldsymbol{\\alpha}$，使用为LML计算的相同 $\\boldsymbol{\\alpha} = K_y^{-1} y$。\n- 预测协方差：令 $V$ 为通过前向替换求解系统 $L V = K_*$ 得到的矩阵 $V$。那么 $K_*^T K_y^{-1} K_* = (L^{-1}K_*)^T(L^{-1}K_*) = V^T V$。因此，$\\Sigma_* = K_{**} - V^T V$。\n\n**算法实现**\n该解决方案首先通过为太阳能发电模型 $g(t)$ 和所有核分量（$w$、$k_{\\mathrm{per}}$、$k_{\\mathrm{se}}$、$k_{\\mathrm{base}}$、$k_{\\mathrm{cp}}$）定义函数来实现。这些函数使用向量化的 `numpy` 操作以提高效率。\n\n对于每个测试用例：\n1. 根据指定规则，使用 $T_{\\mathrm{end}}$、$t_{\\mathrm{break}}$ 以及给定的振幅 $\\alpha_1, \\alpha_2$ 生成训练数据 $(X, y)$。\n2. 对变化点参数 $t_0$ 进行网格搜索。对于网格上的每个候选 $t_0$，使用完整的变化点核 $k_{\\mathrm{cp}}$ 构建协方差矩阵 $K_y$，在其对角线上添加 $10^{-8}$ 的抖动以增强数值鲁棒性，并通过Cholesky分解计算对数边际似然。产生最高LML的 $t_0$ 被选为 $\\hat{t}_0$。\n3. 使用确定的 $\\hat{t}_0$，定义查询点 $X_* = \\{\\hat{t}_0 - 0.25, \\hat{t}_0, \\hat{t}_0 + 0.25\\}$。\n4. 使用 $\\hat{t}_0$ 构建必要的协方差矩阵 $K_y$、$K_*$ 和 $K_{**}$。\n5. 使用上述基于Cholesky的公式计算后验预测均值 $\\mu_*$ 和方差（$\\Sigma_*$ 的对角线）。\n6. 将得到的六个值（三个均值和三个方差）收集并附加到一个最终列表中以供输出。\n\n对所有四个测试用例重复此过程，并将结果汇总到一个扁平化的列表中作为最终输出。",
            "answer": "```python\n# 完整的、可运行的 Python 3 代码在此处。\n# 导入必须符合指定的执行环境。\nimport numpy as np\nfrom scipy.linalg import cholesky, solve_triangular\n\ndef solve():\n    \"\"\"\n    Main function to solve the GP changepoint detection and forecasting problem.\n    \"\"\"\n    # Fixed hyperparameters for all test cases as specified in the problem.\n    P = 1.0\n    L_P = 0.3\n    L_SE = 1.5\n    A = 15.0\n    SIGMA_N = 0.05\n    JITTER = 1e-8\n\n    def g(t):\n        \"\"\"Physically realistic half-wave sinusoid for solar generation.\"\"\"\n        return np.maximum(0, np.sin(2 * np.pi * t))\n\n    def w(t, a, t0):\n        \"\"\"Smooth logistic transition weight.\"\"\"\n        return 1.0 / (1.0 + np.exp(-a * (t - t0)))\n\n    def k_per(t1, t2, p, lp):\n        \"\"\"Periodic kernel.\"\"\"\n        dist = np.abs(np.subtract.outer(t1, t2))\n        return np.exp(-2.0 * (np.sin(np.pi * dist / p)**2) / lp**2)\n\n    def k_se(t1, t2, l_se):\n        \"\"\"Squared-exponential kernel.\"\"\"\n        sq_dist = np.subtract.outer(t1, t2)**2\n        return np.exp(-sq_dist / (2.0 * l_se**2))\n\n    def k_base(t1, t2, p, lp, l_se):\n        \"\"\"Base kernel, sum of periodic and squared-exponential.\"\"\"\n        return k_per(t1, t2, p, lp) + k_se(t1, t2, l_se)\n\n    def k_cp(t1, t2, a, t0, alpha1, alpha2, p, lp, l_se):\n        \"\"\"Changepoint covariance function.\"\"\"\n        t1_flat = t1.flatten()\n        t2_flat = t2.flatten()\n        \n        w_t1 = w(t1_flat, a, t0)[:, np.newaxis]\n        w_t2 = w(t2_flat, a, t0)[np.newaxis, :]\n        \n        k_b = k_base(t1_flat, t2_flat, p, lp, l_se)\n        \n        term1 = ((1.0 - w_t1) @ (1.0 - w_t2)) * alpha1**2\n        term2 = (w_t1 @ w_t2) * alpha2**2\n        \n        return (term1 + term2) * k_b\n        \n    def solve_case(T_end, t_break, alpha1, alpha2):\n        \"\"\"\n        Processes a single test case: generates data, finds the changepoint,\n        and computes predictions.\n        \"\"\"\n        # 1. Generate training data\n        X_train = np.arange(0, T_end + 1e-9, 1/6)\n        N = len(X_train)\n        y_train = np.where(X_train  t_break, alpha1 * g(X_train), alpha2 * g(X_train))\n        y_train = y_train[:, np.newaxis] # Ensure y is a column vector\n\n        # 2. Find best changepoint location t0_hat by maximizing log marginal likelihood\n        t0_grid = np.arange(0.5, T_end - 0.5 + 1e-9, 0.25)\n        max_lml = -np.inf\n        t0_hat = -1\n\n        for t0_candidate in t0_grid:\n            K = k_cp(X_train, X_train, A, t0_candidate, alpha1, alpha2, P, L_P, L_SE)\n            Ky = K + np.eye(N) * SIGMA_N**2 + np.eye(N) * JITTER\n            \n            try:\n                L = cholesky(Ky, lower=True)\n                alpha_vec = solve_triangular(L.T, solve_triangular(L, y_train, lower=True))\n                # Constant term -(N/2)log(2pi) is omitted as it doesn't affect maximization\n                lml = -0.5 * y_train.T @ alpha_vec - np.sum(np.log(np.diag(L)))\n                \n                if lml > max_lml:\n                    max_lml = lml\n                    t0_hat = t0_candidate\n            except np.linalg.LinAlgError:\n                # In case of numerical issues, skip this candidate\n                continue\n        \n        # 3. Perform prediction with the detected changepoint t0_hat\n        X_star = np.array([t0_hat - 0.25, t0_hat, t0_hat + 0.25])\n        \n        K = k_cp(X_train, X_train, A, t0_hat, alpha1, alpha2, P, L_P, L_SE)\n        Ky = K + np.eye(N) * SIGMA_N**2 + np.eye(N) * JITTER\n        L = cholesky(Ky, lower=True)\n        alpha_vec = solve_triangular(L.T, solve_triangular(L, y_train, lower=True))\n        \n        K_star = k_cp(X_train, X_star, A, t0_hat, alpha1, alpha2, P, L_P, L_SE)\n        K_star_star = k_cp(X_star, X_star, A, t0_hat, alpha1, alpha2, P, L_P, L_SE)\n\n        # Predictive mean: mu_star = K_star^T * alpha_vec\n        mu_star = K_star.T @ alpha_vec\n\n        # Predictive variance: Sigma_star = K_star_star - K_star^T * Ky^-1 * K_star\n        v = solve_triangular(L, K_star, lower=True)\n        Sigma_star = K_star_star - v.T @ v\n        var_star = np.diag(Sigma_star)\n        \n        mu_star_flat = mu_star.flatten()\n        return [\n            mu_star_flat[0], var_star[0],\n            mu_star_flat[1], var_star[1],\n            mu_star_flat[2], var_star[2]\n        ]\n\n    test_cases = [\n        (30, 12, 5.0, 3.5),\n        (10, 1.5, 4.0, 6.0),\n        (20, 15, 6.0, 4.2),\n        (15, 0.0, 5.0, 5.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = solve_case(*case)\n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8f}' for x in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}