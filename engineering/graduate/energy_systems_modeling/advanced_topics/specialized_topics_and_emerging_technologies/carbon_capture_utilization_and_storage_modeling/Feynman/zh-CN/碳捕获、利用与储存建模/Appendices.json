{
    "hands_on_practices": [
        {
            "introduction": "胺吸收法是目前最成熟的燃烧后二氧化碳捕集技术之一。然而，在实际运行中，溶剂会因化学和热降解而逐渐失效，这不仅影响捕集效率，也增加了运行成本。本实践旨在引导您将溶剂降解的动力学模型与吸收塔的传质模型相结合，从而定量分析并预测捕集性能随时间的衰减，加深对传质理论（如双膜理论、Hatta数）在解决实际工程问题中应用的理解。",
            "id": "4076063",
            "problem": "一个胺基二氧化碳($\\text{CO}_2$)吸收塔作为活塞流设备运行，其气相摩尔流率为 $F_g$ (单位: $\\mathrm{mol/s}$)，横截面积为 $A$ (单位: $\\mathrm{m^2}$)，填料界面面积为 $a$ (单位: $\\mathrm{m^2/m^3}$)，液相传质系数为 $k_L$ (单位: $\\mathrm{m/s}$)，吸收塔高度为 $H_{\\mathrm{col}}$ (单位: $\\mathrm{m}$)，总压为 $P$ (单位: $\\mathrm{Pa}$)。入口$\\text{CO}_2$摩尔分数为 $y_{\\mathrm{in}}$ (无量纲)。$\\text{CO}_2$在水中的亨利定律常数为 $H_{\\mathrm{CO2}}$ (单位: $\\mathrm{Pa \\cdot m^3/mol}$)，它通过 $c^* = p_{\\mathrm{CO2}} / H_{\\mathrm{CO2}}$ 将平衡溶解浓度 $c^*$ 与气体分压关联起来，其中 $p_{\\mathrm{CO2}} = y P$。$\\text{CO}_2$在溶剂中的扩散系数为 $D_{\\mathrm{CO2}}$ (单位: $\\mathrm{m^2/s}$)。溶剂反应性遵循准一级动力学，其速率常数 $k_{\\mathrm{rxn}}(t)$ (单位: $\\mathrm{s^{-1}}$) 随时间变化，由于溶剂降解，该常数遵循一级失活规律，失活速率为 $k_{\\mathrm{deg}}$ (单位: $\\mathrm{h^{-1}}$)，因此 $k_{\\mathrm{rxn}}(t) = k_{\\mathrm{rxn},0} \\exp(-k_{\\mathrm{deg}} t)$，其中 $t$ 是累计运行时间 (单位: $\\mathrm{h}$)，$k_{\\mathrm{rxn},0}$ 是初始准一级速率常数 (单位: $\\mathrm{s^{-1}}$)。\n\n从以下几点出发：\n- 气相活塞流质量平衡 $d(F_g y)/dz = -A N_{\\mathrm{CO2}}$，其中轴向坐标为 $z$ (单位: $\\mathrm{m}$)，\n- 双膜理论，其中液相通量为 $N_{\\mathrm{CO2}} = k_L a \\mathcal{E}(t) (c^* - c_{\\mathrm{bulk}})$，\n- 亨利定律 $c^* = y P / H_{\\mathrm{CO2}}$，\n- 液膜中准一级反应的Danckwerts增强因子 $\\mathcal{E}(t) = \\sqrt{1 + \\mathrm{Ha}(t)^2}$，其中Hatta数为 $\\mathrm{Ha}(t) = \\sqrt{k_{\\mathrm{rxn}}(t) D_{\\mathrm{CO2}}}/k_L$，\n\n并假设为稀溶液吸收，使得 $c_{\\mathrm{bulk}} \\approx 0$ 且 $F_g$ 沿 $z$ 近似恒定，推导在时间 $t$ 的瞬时捕获效率 $\\eta(t)$ 的表达式，并量化效率下降 $\\Delta \\eta(t) = \\eta(0) - \\eta(t)$ 为一个十进制小数（无百分号），其中 $\\eta(t) = 1 - y_{\\mathrm{out}}(t)/y_{\\mathrm{in}}$，$y_{\\mathrm{out}}(t)$ 是在 $z = H_{\\mathrm{col}}$ 处的出口摩尔分数。\n\n您的程序必须实现推导出的表达式，并为以下测试套件计算 $\\Delta \\eta(t)$。请使用所提供的参数值及其指定单位，并将结果以单行逗号分隔列表的形式输出，并用方括号括起来。每个结果必须是四舍五入到六位小数的浮点数。必须保持科学真实性：不要改变上面列出的建模假设，并确保量纲一致性。\n\n所有案例的通用常数：\n- $P = 101325$ (单位: $\\mathrm{Pa}$)\n- $H_{\\mathrm{CO2}} = 3000$ (单位: $\\mathrm{Pa \\cdot m^3/mol}$)\n- $k_L = 5 \\times 10^{-4}$ (单位: $\\mathrm{m/s}$)\n- $a = 250$ (单位: $\\mathrm{m^2/m^3}$)\n- $D_{\\mathrm{CO2}} = 1.6 \\times 10^{-9}$ (单位: $\\mathrm{m^2/s}$)\n- $A = 1.0$ (单位: $\\mathrm{m^2}$)\n- $F_g = 100$ (单位: $\\mathrm{mol/s}$)\n- $y_{\\mathrm{in}} = 0.12$ (无量纲)\n\n测试套件（每个案例指定（$H_{\\mathrm{col}}$ (单位: $\\mathrm{m}$)，$k_{\\mathrm{rxn},0}$ (单位: $\\mathrm{s^{-1}}$)，$k_{\\mathrm{deg}}$ (单位: $\\mathrm{h^{-1}}$)，$t$ (单位: $\\mathrm{h}$)））：\n1. $(10,\\ 200,\\ 0.02,\\ 24)$: 一天内有中等程度降解的一般情况。\n2. $(10,\\ 200,\\ 0.0,\\ 100)$: 无降解的边界情况；下降应为 $0$。\n3. $(10,\\ 200,\\ 0.5,\\ 48)$: 两天内快速降解的边缘情况。\n4. $(10,\\ 0,\\ 0.1,\\ 24)$: 纯物理吸收（无反应）的边缘情况；下降应为 $0$。\n5. $(30,\\ 200,\\ 0.02,\\ 24)$: 用于测试对 $H_{\\mathrm{col}}$ 敏感性的高吸收塔。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5]”），其中每个“result”是对应案例的 $\\Delta \\eta(t)$，表示为四舍五入到六位小数的十进制小数。",
            "solution": "用户提供了一个关于$\\text{CO}_2$吸收塔建模的问题，并要求进行推导和数值求解。\n\n### 第一步：提取已知条件\n\n**系统变量与方程：**\n- 气相摩尔流率：$F_g$ (mol/s)\n- 吸收塔横截面积：$A$ ($\\mathrm{m^2}$)\n- 填料界面面积：$a$ ($\\mathrm{m^2/m^3}$)\n- 液相传质系数：$k_L$ (m/s)\n- 吸收塔高度：$H_{\\mathrm{col}}$ (m)\n- 总压：$P$ (Pa)\n- 入口$\\text{CO}_2$摩尔分数：$y_{\\mathrm{in}}$ (无量纲)\n- 时间 $t$ 时的出口$\\text{CO}_2$摩尔分数：$y_{\\mathrm{out}}(t)$ (无量纲)\n- 亨利定律常数：$H_{\\mathrm{CO2}}$ ($\\mathrm{Pa \\cdot m^3/mol}$)\n- $\\text{CO}_2$在溶剂中的扩散系数：$D_{\\mathrm{CO2}}$ ($\\mathrm{m^2/s}$)\n- 初始准一级速率常数：$k_{\\mathrm{rxn},0}$ ($\\mathrm{s^{-1}}$)\n- 一级失活速率常数：$k_{\\mathrm{deg}}$ ($\\mathrm{h^{-1}}$)\n- 累计运行时间：$t$ (h)\n- 轴向坐标：$z$ (m)\n\n**控制关系与定义：**\n1.  气相活塞流质量平衡：$d(F_g y)/dz = -A N_{\\mathrm{CO2}}$\n2.  随时间变化的反应速率常数：$k_{\\mathrm{rxn}}(t) = k_{\\mathrm{rxn},0} \\exp(-k_{\\mathrm{deg}} t)$\n3.  双膜理论通量：$N_{\\mathrm{CO2}} = k_L a \\mathcal{E}(t) (c^* - c_{\\mathrm{bulk}})$\n4.  亨利定律：$c^* = y P / H_{\\mathrm{CO2}}$\n5.  Danckwerts增强因子：$\\mathcal{E}(t) = \\sqrt{1 + \\mathrm{Ha}(t)^2}$\n6.  Hatta数：$\\mathrm{Ha}(t) = \\sqrt{k_{\\mathrm{rxn}}(t) D_{\\mathrm{CO2}}}/k_L$\n7.  瞬时捕获效率：$\\eta(t) = 1 - y_{\\mathrm{out}}(t)/y_{\\mathrm{in}}$\n8.  效率下降：$\\Delta \\eta(t) = \\eta(0) - \\eta(t)$\n\n**假设：**\n1.  稀溶液吸收：液相主体浓度 $c_{\\mathrm{bulk}} \\approx 0$。\n2.  恒定气相摩尔流率：$F_g$ 沿吸收塔高度 $z$ 恒定。\n\n**所有案例的通用常数：**\n- $P = 101325$ Pa\n- $H_{\\mathrm{CO2}} = 3000$ $\\mathrm{Pa \\cdot m^3/mol}$\n- $k_L = 5 \\times 10^{-4}$ m/s\n- $a = 250$ $\\mathrm{m^2/m^3}$\n- $D_{\\mathrm{CO2}} = 1.6 \\times 10^{-9}$ $\\mathrm{m^2/s}$\n- $A = 1.0$ $\\mathrm{m^2}$\n- $F_g = 100$ mol/s\n- $y_{\\mathrm{in}} = 0.12$\n\n**测试套件（案例格式：$(H_{\\mathrm{col}}, k_{\\mathrm{rxn},0}, k_{\\mathrm{deg}}, t)$）：**\n1.  $(10, 200, 0.02, 24)$\n2.  $(10, 200, 0.0, 100)$\n3.  $(10, 200, 0.5, 48)$\n4.  $(10, 0, 0.1, 24)$\n5.  $(30, 200, 0.02, 24)$\n\n### 第二步：使用提取的已知条件进行验证\n\n根据验证标准对此问题进行评估：\n-   **科学性**：该问题基于化学反应工程和传质学的标准、成熟原理，特别是带化学反应的气体吸收塔（如胺洗法）的建模。双膜理论、亨利定律、Danckwerts增强因子、Hatta数和活塞流反应器模型都是该领域的基础。将溶剂降解建模为一级衰减过程是一种合理且常见的动力学简化。物理常数的数量级对于此类系统是现实的。该问题在科学上是合理的。\n-   **适定性**：该问题提供了一套完整的方程、参数和边界条件（$y(z=0) = y_{\\mathrm{in}}$），足以推导出出口浓度 $y_{\\mathrm{out}}(t)$ 的唯一表达式，从而得出效率 $\\eta(t)$。简化假设（$c_{\\mathrm{bulk}} \\approx 0$，恒定 $F_g$）使得控制微分方程可解析求解。任务明确：推导表达式并为一组给定的测试案例计算特定量 $\\Delta \\eta(t)$。存在唯一、稳定且有意义的解。\n-   **客观性**：该问题以精确、定量和技术性的语言陈述。它没有主观论断、观点或模糊之处。\n-   **其他缺陷**：该问题不完整、不矛盾、不切实际、不适定、不琐碎或无法验证。它是一个标准的、可形式化的工程问题。\n\n### 第三步：结论与行动\n\n此问题是**有效的**。将进行分步推导求解。\n\n### 求解推导\n\n目标是推导效率下降的表达式，$\\Delta \\eta(t) = \\eta(0) - \\eta(t)$。\n\n1.  **简化质量平衡：** 从活塞流质量平衡方程开始，$d(F_g y)/dz = -A N_{\\mathrm{CO2}}$。根据气体摩尔流率 $F_g$ 恒定的假设，我们可以写出：\n    $$ F_g \\frac{dy}{dz} = -A N_{\\mathrm{CO2}} $$\n\n2.  **构建通量表达式：** $\\text{CO}_2$进入液相的通量 $N_{\\mathrm{CO2}}$ 由双膜理论给出：$N_{\\mathrm{CO2}} = k_L a \\mathcal{E}(t) (c^* - c_{\\mathrm{bulk}})$。应用 $c_{\\mathrm{bulk}} \\approx 0$ 的假设并代入亨利定律 $c^* = y P / H_{\\mathrm{CO2}}$，我们得到：\n    $$ N_{\\mathrm{CO2}} = k_L a \\mathcal{E}(t) \\frac{y P}{H_{\\mathrm{CO2}}} $$\n\n3.  **构建微分方程：** 将通量表达式代入质量平衡方程：\n    $$ F_g \\frac{dy}{dz} = -A \\left( k_L a \\mathcal{E}(t) \\frac{y P}{H_{\\mathrm{CO2}}} \\right) $$\n    这是一个关于 $y(z)$ 的一阶常微分方程。右侧除 $y$ 外的所有项都相对于空间坐标 $z$ 是常数。整理以进行积分：\n    $$ \\frac{dy}{y} = - \\left( \\frac{A k_L a P \\mathcal{E}(t)}{F_g H_{\\mathrm{CO2}}} \\right) dz $$\n\n4.  **对微分方程进行积分：** 我们沿吸收塔的长度从 $z=0$ 到 $z=H_{\\mathrm{col}}$ 进行积分，此时摩尔分数从 $y(0) = y_{\\mathrm{in}}$ 变为 $y(H_{\\mathrm{col}}) = y_{\\mathrm{out}}(t)$：\n    $$ \\int_{y_{\\mathrm{in}}}^{y_{\\mathrm{out}}(t)} \\frac{dy}{y} = \\int_{0}^{H_{\\mathrm{col}}} - \\frac{A k_L a P \\mathcal{E}(t)}{F_g H_{\\mathrm{CO2}}} dz $$\n    $$ \\ln(y)\\Big|_{y_{\\mathrm{in}}}^{y_{\\mathrm{out}}(t)} = - \\frac{A k_L a P H_{\\mathrm{col}}}{F_g H_{\\mathrm{CO2}}} \\mathcal{E}(t) $$\n    $$ \\ln\\left(\\frac{y_{\\mathrm{out}}(t)}{y_{\\mathrm{in}}}\\right) = - \\frac{A k_L a P H_{\\mathrm{col}}}{F_g H_{\\mathrm{CO2}}} \\mathcal{E}(t) $$\n\n5.  **求解捕获效率 $\\eta(t)$：** 对两边取指数，得到出口与入口摩尔分数之比：\n    $$ \\frac{y_{\\mathrm{out}}(t)}{y_{\\mathrm{in}}} = \\exp\\left( - \\frac{A k_L a P H_{\\mathrm{col}}}{F_g H_{\\mathrm{CO2}}} \\mathcal{E}(t) \\right) $$\n    捕获效率定义为 $\\eta(t) = 1 - y_{\\mathrm{out}}(t)/y_{\\mathrm{in}}$。代入摩尔分数比的表达式：\n    $$ \\eta(t) = 1 - \\exp\\left( - \\frac{A k_L a P H_{\\mathrm{col}}}{F_g H_{\\mathrm{CO2}}} \\mathcal{E}(t) \\right) $$\n\n6.  **表达随时间变化的增强因子 $\\mathcal{E}(t)$：**\n    时间 $t$ 时的Hatta数为 $\\mathrm{Ha}(t) = \\sqrt{k_{\\mathrm{rxn}}(t) D_{\\mathrm{CO2}}}/k_L$。\n    代入衰减速率常数的表达式，$k_{\\mathrm{rxn}}(t) = k_{\\mathrm{rxn},0} \\exp(-k_{\\mathrm{deg}} t)$:\n    $$ \\mathrm{Ha}(t)^2 = \\frac{k_{\\mathrm{rxn}}(t) D_{\\mathrm{CO2}}}{k_L^2} = \\frac{k_{\\mathrm{rxn},0} D_{\\mathrm{CO2}}}{k_L^2} \\exp(-k_{\\mathrm{deg}} t) $$\n    增强因子为 $\\mathcal{E}(t) = \\sqrt{1 + \\mathrm{Ha}(t)^2}$：\n    $$ \\mathcal{E}(t) = \\sqrt{1 + \\frac{k_{\\mathrm{rxn},0} D_{\\mathrm{CO2}}}{k_L^2} \\exp(-k_{\\mathrm{deg}} t)} $$\n    注意 $k_{\\mathrm{deg}}$ 的单位（$\\mathrm{h^{-1}}$）和 $t$ 的单位（$\\mathrm{h}$）是一致的，使得 $k_{\\mathrm{deg}}t$ 项是无量纲的。\n\n7.  **推导效率下降 $\\Delta \\eta(t)$：** 效率下降为 $\\Delta \\eta(t) = \\eta(0) - \\eta(t)$。\n    为清晰起见，我们定义一个组合参数 $\\beta_H$，它代表纯物理吸收的传质单元数乘以塔高：\n    $$ \\beta_H = \\frac{A k_L a P H_{\\mathrm{col}}}{F_g H_{\\mathrm{CO2}}} $$\n    效率表达式变为：\n    $$ \\eta(t) = 1 - \\exp(-\\beta_H \\mathcal{E}(t)) $$\n    $$ \\eta(0) = 1 - \\exp(-\\beta_H \\mathcal{E}(0)) $$\n    其中 $\\mathcal{E}(0) = \\sqrt{1 + k_{\\mathrm{rxn},0} D_{\\mathrm{CO2}} / k_L^2}$ 因为 $\\exp(0) = 1$。\n    因此，下降量为：\n    $$ \\Delta \\eta(t) = \\left[1 - \\exp(-\\beta_H \\mathcal{E}(0))\\right] - \\left[1 - \\exp(-\\beta_H \\mathcal{E}(t))\\right] $$\n    $$ \\Delta \\eta(t) = \\exp(-\\beta_H \\mathcal{E}(t)) - \\exp(-\\beta_H \\mathcal{E}(0)) $$\n    这是需要实现的最终表达式。计算过程首先包括计算 $t=0$ 和时间 $t$ 时的Hatta数，然后计算相应的增强因子 $\\mathcal{E}(0)$ 和 $\\mathcal{E}(t)$，最后将这些值代入 $\\Delta \\eta(t)$ 的表达式中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the CO2 capture efficiency decline for a set of test cases\n    based on a derived model for an amine-based absorber.\n    \"\"\"\n    # Define constants common to all cases\n    P = 101325.0       # Total pressure, Pa\n    H_CO2 = 3000.0     # Henry's law constant, Pa * m^3 / mol\n    k_L = 5.0e-4       # Liquid-side mass transfer coefficient, m/s\n    a = 250.0          # Packing interfacial area, m^2/m^3\n    D_CO2 = 1.6e-9     # Diffusivity of CO2 in solvent, m^2/s\n    A = 1.0            # Absorber cross-sectional area, m^2\n    F_g = 100.0        # Gas-phase molar flow rate, mol/s\n    # y_in = 0.12, not needed for delta_eta calculation\n\n    # Define the test cases from the problem statement.\n    # Format: (H_col (m), k_rxn_0 (s^-1), k_deg (h^-1), t (h))\n    test_cases = [\n        (10.0, 200.0, 0.02, 24.0), # general case\n        (10.0, 200.0, 0.0, 100.0), # no degradation\n        (10.0, 200.0, 0.5, 48.0),  # rapid degradation\n        (10.0, 0.0, 0.1, 24.0),    # no reaction (physical absorption)\n        (30.0, 200.0, 0.02, 24.0)  # tall absorber\n    ]\n\n    results = []\n\n    # Pre-calculate constant groups to simplify the loop\n    beta_base = (A * k_L * a * P) / (F_g * H_CO2)\n    Ha_sq_base = D_CO2 / (k_L**2)\n\n    for case in test_cases:\n        H_col, k_rxn_0, k_deg, t = case\n\n        # Calculate the dimensionless group for the exponent\n        beta_H = beta_base * H_col\n\n        # Calculate the square of the initial Hatta number\n        Ha_0_sq = Ha_sq_base * k_rxn_0\n\n        # Calculate the enhancement factor at time t=0\n        # E(0) = sqrt(1 + Ha(0)^2)\n        E_0 = np.sqrt(1.0 + Ha_0_sq)\n\n        # Calculate the enhancement factor at time t\n        # k_rxn(t) = k_rxn_0 * exp(-k_deg * t)\n        # E(t) = sqrt(1 + Ha(0)^2 * exp(-k_deg * t))\n        # Note: k_deg is in h^-1 and t is in h, so k_deg*t is dimensionless.\n        E_t = np.sqrt(1.0 + Ha_0_sq * np.exp(-k_deg * t))\n\n        # Calculate the efficiency decline delta_eta(t) = eta(0) - eta(t)\n        # delta_eta(t) = exp(-beta_H * E(t)) - exp(-beta_H * E(0))\n        delta_eta = np.exp(-beta_H * E_t) - np.exp(-beta_H * E_0)\n        \n        results.append(delta_eta)\n\n    # Format results as a list of strings with 6 decimal places\n    results_str = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在过程模拟的基础上，技术经济优化是做出工程设计与操作决策的关键步骤。工程师常常需要在多个相互冲突的目标之间寻找平衡，以实现整体成本的最小化，而非仅仅追求单一物理指标的最优化。本实践将指导您构建一个胺法捕集系统的简化成本模型，并应用该模型来寻找最佳的溶剂浓度，从而学会在捕集效率、再生能耗以及溶剂补充成本等多个因素之间进行权衡。",
            "id": "4076080",
            "problem": "您正在使用单乙醇胺 (Monoethanolamine, MEA) 对一个基于胺的燃烧后碳捕集装置进行建模。决策变量是溶剂中 MEA 的质量分数，记为 $x$，其中 $x$ 代表 MEA 的重量分数（以小数形式表示，例如，$0.30$ 对应于 $30$ 重量百分比）。目标是选择 $x$ 以在满足指定的二氧化碳捕集分数目标的同时，最小化总运行成本。您的模型必须基于物理上合理、与此类系统中广泛观察到的行为一致的单调关系。\n\n从以下基本思想出发：\n- 捕集的二氧化碳摩尔流量是入口摩尔流量乘以捕集分数。如果 $F_{\\text{CO2}}$ 是二氧化碳的摩尔流量（单位为 $\\text{mol}/\\text{s}$），$y_{\\text{cap}}(x)$ 是捕集分数，那么捕集的摩尔流量为 $F_{\\text{CO2}} \\cdot y_{\\text{cap}}(x)$。\n- 对于一个气液吸收过程，采用一级近似达到平衡，且容量随溶剂浓度增加而增加，一个简化但物理上一致的捕集分数可以表示为 $y_{\\text{cap}}(x) = 1 - \\exp(-\\beta x)$，其中 $\\beta > 0$ 是一个集总参数，包含了接触器性能和烟气性质。\n- 每摩尔再生的二氧化碳所需的比再沸器能耗 $e_{\\text{reb}}(x)$（单位为 $\\text{MJ}/\\text{mol}$），会因显热升温和有效解吸热的增加而随 $x$ 增大。一个能够捕捉此趋势的凸多项式近似为 $e_{\\text{reb}}(x) = e_0 + a_1 x + a_2 x^2$，其中 $e_0 > 0$，$a_1 \\ge 0$ 且 $a_2 \\ge 0$。\n- 每摩尔捕集的二氧化碳所需的液压能（用于泵送）$e_{\\text{pump}}(x)$（单位为 $\\text{MJ}/\\text{mol}$），会随着 $x$ 增加导致粘度增加而增大，可以建模为 $e_{\\text{pump}}(x) = c_P x^{\\delta}$，其中 $c_P > 0$ 且 $\\delta \\ge 1$。\n- 每摩尔捕集的二氧化碳所需的溶剂降解补充量 $d(x)$（单位为 $\\text{kg}/\\text{mol}$），会因氧化和热降解加速而随 $x$ 增大。一个常用的单调形式是 $d(x) = d_0 \\exp(\\eta x)$，其中 $d_0 > 0$ 且 $\\eta > 0$。\n\n设 $p_E$ 为能源价格（单位为 $\\$/\\text{MJ}$），$p_M$ 为溶剂补充价格（单位为 $\\$/\\text{kg}$）。那么，在给定 $x$ 时，总成本速率（单位：美元/秒）定义为\n$$\nC(x) = \\Big(p_E \\cdot \\big[e_{\\text{reb}}(x) + e_{\\text{pump}}(x)\\big] + p_M \\cdot d(x)\\Big) \\cdot F_{\\text{CO2}} \\cdot y_{\\text{cap}}(x).\n$$\n\n您的任务是，对于下面测试套件中的每一组参数，计算最优的 MEA 质量分数 $x^\\star \\in [x_{\\min}, x_{\\max}]$，该值在满足捕集目标约束 $y_{\\text{cap}}(x) \\ge \\tau$ 的条件下最小化 $C(x)$。如果在 $[x_{\\min}, x_{\\max}]$ 内不存在满足 $y_{\\text{cap}}(x) \\ge \\tau$ 的可行 $x$，则为该测试用例返回一个哨兵值 $-1.0$。\n\n所有答案必须使用以下单位表示：\n- $F_{\\text{CO2}}$ 单位为 $\\text{mol}/\\text{s}$。\n- $e_{\\text{reb}}(x)$ 和 $e_{\\text{pump}}(x)$ 单位为 $\\text{MJ}/\\text{mol}$。\n- $p_E$ 单位为 $\\$/\\text{MJ}$。\n- $d(x)$ 单位为 $\\text{kg}/\\text{mol}$。\n- $p_M$ 单位为 $\\$/\\text{kg}$。\n- 捕集目标 $\\tau$ 必须以小数形式提供和处理（例如，$0.90$ 代表 $90$ 百分比），不得使用百分号。\n- 决策变量 $x$ 必须以小数形式返回（例如，$0.3000$），不得使用百分号。\n\n使用以下测试套件。每个测试用例是一个参数元组\n$(F_{\\text{CO2}}, p_E, p_M, \\beta, e_0, a_1, a_2, c_P, \\delta, d_0, \\eta, x_{\\min}, x_{\\max}, \\tau)$：\n\n- 案例 1（一般情况，典型的烟气和价格）：\n  $(100, 0.02, 3, 8, 0.12, 0.02, 0.09, 0.003, 2, 1.0\\times 10^{-6}, 5, 0.20, 0.40, 0.90)$。\n- 案例 2（高能源价格，更严格的捕集目标）：\n  $(100, 0.08, 2, 10, 0.12, 0.02, 0.09, 0.003, 2, 1.0\\times 10^{-6}, 5, 0.20, 0.40, 0.95)$。\n- 案例 3（传质受限导致不可行）：\n  $(100, 0.02, 3, 4, 0.12, 0.02, 0.09, 0.003, 2, 1.0\\times 10^{-6}, 5, 0.20, 0.40, 0.85)$。\n- 案例 4（溶剂补充成本昂贵）：\n  $(100, 0.02, 10, 9, 0.12, 0.02, 0.09, 0.003, 2, 1.0\\times 10^{-6}, 5, 0.20, 0.40, 0.90)$。\n\n算法要求：\n- 将决策视为在 $x \\in [x_{\\min}, x_{\\max}]$ 上的连续优化问题。\n- 强制执行约束 $y_{\\text{cap}}(x) \\ge \\tau$。\n- 如果约束在该区间内不可行，则返回 $-1.0$。\n- 否则，计算在可行域上最小化 $C(x)$ 的 $x^\\star$。使用对给定的类凸形式具有鲁棒性的数值方法，例如在 $x$ 上使用足够精细分辨率的网格搜索。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。每一项必须是相应测试用例的最优 $x^\\star$（四舍五入到四位小数），如果不可行则为 $-1.0$。例如，格式必须为 $\\left[0.3000,0.2950,-1.0,0.2600\\right]$（这是一个示例，不是要求的答案）。",
            "solution": "该问题已经过验证，被确定为一个适定、有科学依据的优化问题。所有定义都清晰，提供的参数也一致。\n\n任务是找到最优的 MEA 质量分数 $x^\\star$，在满足 $x$ 的允许范围和最小二氧化碳捕集分数 $\\tau$ 的约束条件下，最小化总运行成本速率 $C(x)$。该问题可正式表述为：\n\n$$\n\\min_{x} C(x) \\quad \\text{subject to} \\quad x \\in [x_{\\min}, x_{\\max}] \\quad \\text{and} \\quad y_{\\text{cap}}(x) \\ge \\tau\n$$\n\n总成本速率 $C(x)$ 由下式给出：\n$$\nC(x) = \\Big(p_E \\cdot \\big[e_{\\text{reb}}(x) + e_{\\text{pump}}(x)\\big] + p_M \\cdot d(x)\\Big) \\cdot F_{\\text{CO2}} \\cdot y_{\\text{cap}}(x)\n$$\n其中，各组成函数为：\n- 捕集分数：$y_{\\text{cap}}(x) = 1 - \\exp(-\\beta x)$\n- 再沸器能耗：$e_{\\text{reb}}(x) = e_0 + a_1 x + a_2 x^2$\n- 泵送能耗：$e_{\\text{pump}}(x) = c_P x^{\\delta}$\n- 溶剂降解：$d(x) = d_0 \\exp(\\eta x)$\n\n首先，我们分析问题的可行性。主要约束是捕集分数：\n$$\ny_{\\text{cap}}(x) \\ge \\tau\n$$\n代入 $y_{\\text{cap}}(x)$ 的定义：\n$$\n1 - \\exp(-\\beta x) \\ge \\tau\n$$\n由于 $\\tau \\in (0, 1)$，我们可以重新整理不等式：\n$$\n1 - \\tau \\ge \\exp(-\\beta x)\n$$\n对两边取自然对数（这是一个单调递增函数，保持不等式方向不变）：\n$$\n\\ln(1 - \\tau) \\ge -\\beta x\n$$\n鉴于 $\\beta > 0$，我们可以除以 $-\\beta$，这会反转不等号：\n$$\nx \\ge -\\frac{\\ln(1 - \\tau)}{\\beta}\n$$\n我们将达到目标捕集分数 $\\tau$ 所需的最小质量分数定义为 $x_{\\text{req}}$：\n$$\nx_{\\text{req}} = -\\frac{\\ln(1 - \\tau)}{\\beta}\n$$\n问题规定决策变量 $x$ 也必须在操作范围 $[x_{\\min}, x_{\\max}]$ 内。因此，一个可行的解必须同时满足两个条件：\n$$\nx \\ge x_{\\text{req}} \\quad \\text{and} \\quad x_{\\min} \\le x \\le x_{\\max}\n$$\n结合这些条件， $x$ 的可行域为区间 $[\\max(x_{\\min}, x_{\\text{req}}), x_{\\max}]$。\n\n只有当这个区间非空时，才存在可行解，这意味着下界不能超过上界：\n$$\n\\max(x_{\\min}, x_{\\text{req}}) \\le x_{\\max}\n$$\n根据区间的定义，$x_{\\min} \\le x_{\\max}$，因此该条件简化为 $x_{\\text{req}} \\le x_{\\max}$。如果 $x_{\\text{req}} > x_{\\max}$，则在允许的浓度范围内无法满足捕集目标，问题不可行。在这种情况下，必须返回指定的哨兵值 $-1.0$。\n\n接下来，我们分析目标函数 $C(x)$。我们将其表示为两项的乘积：\n$$\nC(x) = f_1(x) \\cdot f_2(x)\n$$\n其中：\n$$\nf_1(x) = p_E \\cdot \\big(e_0 + a_1 x + a_2 x^2 + c_P x^{\\delta}\\big) + p_M \\cdot d_0 \\exp(\\eta x)\n$$\n$$\nf_2(x) = F_{\\text{CO2}} \\cdot \\big(1 - \\exp(-\\beta x)\\big)\n$$\n参数 $p_E, p_M, e_0, a_1, a_2, c_P, d_0, \\eta, \\delta, F_{\\text{CO2}}, \\beta$ 都被指定为非负（且大多数是严格正数）。我们感兴趣的定义域是 $x > 0$。\n\n$f_1(x)$ 关于 $x$ 的一阶导数是：\n$$\n\\frac{df_1}{dx} = p_E \\cdot \\big(a_1 + 2 a_2 x + c_P \\delta x^{\\delta-1}\\big) + p_M \\cdot d_0 \\eta \\exp(\\eta x)\n$$\n鉴于所有参数都是非负的且 $\\delta \\ge 1$，对于 $x > 0$，此导数中的每一项都是非负的。因此，$\\frac{df_1}{dx} \\ge 0$，这意味着 $f_1(x)$ 是一个单调不减函数。实际上，根据给定的参数，它是一个严格递增函数。\n\n$f_2(x)$ 关于 $x$ 的一阶导数是：\n$$\n\\frac{df_2}{dx} = F_{\\text{CO2}} \\cdot \\big(-\\exp(-\\beta x) \\cdot (-\\beta)\\big) = F_{\\text{CO2}} \\beta \\exp(-\\beta x)\n$$\n由于 $F_{\\text{CO2}} > 0$ 且 $\\beta > 0$，对于所有 $x$，$\\frac{df_2}{dx} > 0$。因此，$f_2(x)$ 是一个关于 $x$ 的严格递增函数。\n\n目标函数 $C(x)$ 是两个正的、单调递增函数 $f_1(x)$ 和 $f_2(x)$ 在正数定义域上的乘积。两个这样的函数的乘积本身也是单调递增的。\n\n因此，要在可行区间 $[\\max(x_{\\min}, x_{\\text{req}}), x_{\\max}]$ 上最小化单调递增函数 $C(x)$，必须选择该区间中最小的 $x$ 值。因此，最优解位于可行集的下界：\n$$\nx^\\star = \\max(x_{\\min}, x_{\\text{req}})\n$$\n\n这个解析结果避免了进行数值网格搜索的需要。算法如下：\n1. 对于每个测试用例，计算 $x_{\\text{req}} = -\\frac{\\ln(1 - \\tau)}{\\beta}$。\n2. 通过将 $x_{\\text{req}}$ 与 $x_{\\max}$ 进行比较来检查可行性。如果 $x_{\\text{req}} > x_{\\max}$，则解不可行，结果为 $-1.0$。\n3. 如果问题是可行的，则计算最优质量分数 $x^\\star = \\max(x_{\\min}, x_{\\text{req}})$。\n4. 报告结果，四舍五入到四位小数。\n\n将此算法应用于测试用例：\n\n案例 1: $(\\beta, \\tau, x_{\\min}, x_{\\max}) = (8, 0.90, 0.20, 0.40)$\n$x_{\\text{req}} = -\\frac{\\ln(1 - 0.90)}{8} \\approx 0.28782$。\n由于 $0.28782 \\le 0.40$，问题是可行的。\n$x^\\star = \\max(0.20, 0.28782) = 0.28782$。\n\n案例 2: $(\\beta, \\tau, x_{\\min}, x_{\\max}) = (10, 0.95, 0.20, 0.40)$\n$x_{\\text{req}} = -\\frac{\\ln(1 - 0.95)}{10} \\approx 0.29957$。\n由于 $0.29957 \\le 0.40$，问题是可行的。\n$x^\\star = \\max(0.20, 0.29957) = 0.29957$。\n\n案例 3: $(\\beta, \\tau, x_{\\min}, x_{\\max}) = (4, 0.85, 0.20, 0.40)$\n$x_{\\text{req}} = -\\frac{\\ln(1 - 0.85)}{4} \\approx 0.47428$。\n由于 $0.47428 > 0.40$，问题是不可行的。结果为 $-1.0$。\n\n案例 4: $(\\beta, \\tau, x_{\\min}, x_{\\max}) = (9, 0.90, 0.20, 0.40)$\n$x_{\\text{req}} = -\\frac{\\ln(1 - 0.90)}{9} \\approx 0.25584$。\n由于 $0.25584 \\le 0.40$，问题是可行的。\n$x^\\star = \\max(0.20, 0.25584) = 0.25584$。\n\n这些结果将在最终程序中实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal MEA mass fraction x* for a series of test cases.\n\n    The problem is to minimize a cost function C(x) subject to a capture\n    target constraint y_cap(x) >= tau over an interval x in [x_min, x_max].\n\n    The analysis shows that the objective function C(x) is monotonically\n    increasing for x > 0. Therefore, the minimum cost is achieved at the\n    minimum feasible value of x.\n\n    The feasible region is determined by two constraints:\n    1. x >= x_min\n    2. y_cap(x) >= tau, which implies x >= -ln(1 - tau) / beta. Let this be x_req.\n\n    Combining these, the optimal solution x* is max(x_min, x_req).\n\n    Feasibility requires that a solution exists within the search space, i.e.,\n    x_req must be less than or equal to x_max. If x_req > x_max, no\n    feasible solution exists.\n    \"\"\"\n\n    # Each case is a tuple:\n    # (F_CO2, p_E, p_M, beta, e0, a1, a2, cP, delta, d0, eta, x_min, x_max, tau)\n    test_cases = [\n        (100, 0.02, 3, 8, 0.12, 0.02, 0.09, 0.003, 2, 1.0e-6, 5, 0.20, 0.40, 0.90),\n        (100, 0.08, 2, 10, 0.12, 0.02, 0.09, 0.003, 2, 1.0e-6, 5, 0.20, 0.40, 0.95),\n        (100, 0.02, 3, 4, 0.12, 0.02, 0.09, 0.003, 2, 1.0e-6, 5, 0.20, 0.40, 0.85),\n        (100, 0.02, 10, 9, 0.12, 0.02, 0.09, 0.003, 2, 1.0e-6, 5, 0.20, 0.40, 0.90),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters. Many are not needed for the final analytical solution,\n        # but are kept here for clarity corresponding to the problem statement.\n        _F_CO2, _p_E, _p_M, beta, _e0, _a1, _a2, _cP, _d, _d0, _eta, x_min, x_max, tau = case\n\n        # Calculate the minimum required mass fraction to meet the capture target\n        #\n        # y_cap(x) = 1 - exp(-beta * x) >= tau\n        # exp(-beta * x) <= 1 - tau\n        # -beta * x <= ln(1 - tau)\n        # x >= -ln(1 - tau) / beta\n        if 1 - tau = 0:\n            # This edge case occurs if tau = 1. log is undefined for non-positive args.\n            # If tau = 1, x_req -> infinity, so infeasible.\n            # If tau > 1, 1-tau is negative, log is undefined, also infeasible.\n            results.append(-1.0)\n            continue\n            \n        x_req = -np.log(1 - tau) / beta\n\n        # Check for feasibility: the required concentration must be achievable\n        # within the maximum allowed concentration.\n        if x_req > x_max:\n            # The problem is infeasible as the target cannot be met.\n            results.append(-1.0)\n        else:\n            # The objective function is proven to be monotonically increasing.\n            # Therefore, the optimal x is the minimum feasible x.\n            # The feasible range for x is [max(x_min, x_req), x_max].\n            # The minimum value is at the lower bound of this interval.\n            x_star = max(x_min, x_req)\n            results.append(x_star)\n\n    # Format the results into the required string format\n    # \"[res1,res2,res3,res4]\" with 4 decimal places rounding.\n    formatted_results = [f\"{r:.4f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "从“捕集”环节过渡到“封存”环节，确保二氧化碳地质封存的长期安全性是整个CCUS技术链成功的关键。地表及地下的环境监测是验证封存有效性、及时发现潜在泄漏风险的核心手段。本实践将引导您使用经典的扩散方程来模拟二氧化碳在地下非饱和区的迁移过程，通过求解该模型，您将能够预测潜在泄漏如何在监测传感器位置及地表产生可测量的浓度信号，从而评估监测系统的灵敏度。",
            "id": "4076105",
            "problem": "一项针对碳捕获、利用与封存（CCUS）的监测计划旨在利用包气带中的一维扩散模型，评估地表二氧化碳（$\\text{CO}_2$）通量测量对地下泄漏的敏感性，并计算地下传感器预期的浓度变化。从第一性原理出发，使用多孔介质中沿深度的被动标量扩散来模拟气孔中$\\text{CO}_2$的瞬态输运。其基本依据是带源项的一维空间菲克第二扩散定律，表述如下：$$\\frac{\\partial C(z,t)}{\\partial t} = \\frac{\\partial}{\\partial z}\\left(D \\frac{\\partial C(z,t)}{\\partial z}\\right) + s(z,t),$$ 其中$C(z,t)$是摩尔浓度（单位为$\\mathrm{mol/m^3}$），$D$是有效扩散系数（单位为$\\mathrm{m^2/s}$，本问题中假定其在空间和时间上为常数），$s(z,t)$是体积源项（单位为$\\mathrm{mol/(m^3\\,s)}$）。该区域原则上是半无限的，但为了计算，使用一个有限深度$z \\in [0,L]$，在地表设置狄利克雷边界，在深处设置诺伊曼边界：$$C(0,t) = C_{\\mathrm{atm}}, \\quad \\frac{\\partial C(L,t)}{\\partial z} = 0.$$ 初始条件是均匀的背景浓度：$$C(z,0) = C_{\\mathrm{bg}}.$$\n\n将深度$z_0$处的地下泄漏模拟为一个面摩尔通量$F_{\\mathrm{leak}}$（单位为$\\mathrm{mol/(m^2\\,s)}$），在$z=z_0$处的薄层中注入孔隙空间。对于在间距为$\\Delta z$的均匀网格上的数值实现，将其近似为包含$z_0$的网格单元内的体积源，其大小为$$s(z,t) = \\frac{F_{\\mathrm{leak}}}{\\Delta z}$$，在泄漏区间$0 \\le t \\le T_{\\mathrm{leak}}$内成立，其他情况下$s(z,t)=0$。对于此问题，假定$C_{\\mathrm{atm}} = C_{\\mathrm{bg}}$。\n\n使用菲克第一定律定义可测量的地表扩散通量：$$J(0,t) = -D \\left.\\frac{\\partial C}{\\partial z}\\right|_{z=0},$$其单位为$\\mathrm{mol/(m^2\\,s)}$。地表通量测量对地下泄漏的敏感性定义为无量纲比率$$S = \\frac{J(0,T)}{F_{\\mathrm{leak}}},$$在指定的最终时间$T$进行评估。此外，对于一组给定的传感器深度$\\{z_s\\}$，计算在时间$T$时这些深度相对于背景浓度的预期变化量，$$\\Delta C(z_s,T) = C(z_s,T) - C_{\\mathrm{bg}}.$$ 所有输出必须以规定的物理单位表示，时间单位为$\\mathrm{s}$，深度单位为$\\mathrm{m}$，扩散系数单位为$\\mathrm{m^2/s}$，摩尔浓度单位为$\\mathrm{mol/m^3}$，通量单位为$\\mathrm{mol/(m^2\\,s)}$。\n\n算法要求：\n- 在间距为$\\Delta z$的均匀网格上对$z$方向的控制方程进行离散化，并使用从菲克定律和所述边界条件推导出的无条件稳定的隐式方法进行时间积分。确保在$z=0$处的狄利克雷边界和$z=L$处的诺伊曼边界的正确实现。\n- 按照规定表示泄漏源，并将其叠加在基线上。\n- 根据地表的离散浓度梯度计算$J(0,T)$，并评估如上定义的敏感性$S$。\n- 在每个传感器深度处计算$\\Delta C(z_s,T)$，如果需要，使用网格上的适当插值。\n\n测试套件：\n使用以下参数集来评估程序。在每种情况下，报告一个敏感性值，然后按指定顺序报告所有传感器的浓度变化。\n\n- 案例 $1$ (一般“理想路径”)：\n  - $L = 5.0\\,\\mathrm{m}$，$\\Delta z = 0.01\\,\\mathrm{m}$，\n  - $D = 1.0\\times 10^{-6}\\,\\mathrm{m^2/s}$，\n  - $T = 86400\\,\\mathrm{s}$，$\\Delta t = 120\\,\\mathrm{s}$，\n  - $z_0 = 2.0\\,\\mathrm{m}$，\n  - $F_{\\mathrm{leak}} = 1.0\\times 10^{-5}\\,\\mathrm{mol/(m^2\\,s)}$，\n  - $T_{\\mathrm{leak}} = 86400\\,\\mathrm{s}$，\n  - $C_{\\mathrm{bg}} = 1.6\\times 10^{-2}\\,\\mathrm{mol/m^3}$，\n  - 传感器深度 $\\{z_s\\} = [0.1\\,\\mathrm{m}, 0.5\\,\\mathrm{m}, 1.0\\,\\mathrm{m}, 2.0\\,\\mathrm{m}, 4.0\\,\\mathrm{m}]$。\n\n- 案例 $2$ (边界情况：极浅泄漏，短时间范围)：\n  - $L = 5.0\\,\\mathrm{m}$，$\\Delta z = 0.01\\,\\mathrm{m}$，\n  - $D = 1.0\\times 10^{-6}\\,\\mathrm{m^2/s}$，\n  - $T = 10000\\,\\mathrm{s}$，$\\Delta t = 60\\,\\mathrm{s}$，\n  - $z_0 = 0.1\\,\\mathrm{m}$，\n  - $F_{\\mathrm{leak}} = 1.0\\times 10^{-5}\\,\\mathrm{mol/(m^2\\,s)}$，\n  - $T_{\\mathrm{leak}} = 10000\\,\\mathrm{s}$，\n  - $C_{\\mathrm{bg}} = 1.6\\times 10^{-2}\\,\\mathrm{mol/m^3}$，\n  - 传感器深度 $\\{z_s\\} = [0.1\\,\\mathrm{m}, 0.5\\,\\mathrm{m}, 1.0\\,\\mathrm{m}, 2.0\\,\\mathrm{m}, 4.0\\,\\mathrm{m}]$。\n\n- 案例 $3$ (边缘情况：深层泄漏，低扩散系数)：\n  - $L = 5.0\\,\\mathrm{m}$，$\\Delta z = 0.01\\,\\mathrm{m}$，\n  - $D = 1.0\\times 10^{-7}\\,\\mathrm{m^2/s}$，\n  - $T = 50000\\,\\mathrm{s}$，$\\Delta t = 100\\,\\mathrm{s}$，\n  - $z_0 = 4.0\\,\\mathrm{m}$，\n  - $F_{\\mathrm{leak}} = 1.0\\times 10^{-5}\\,\\mathrm{mol/(m^2\\,s)}$，\n  - $T_{\\mathrm{leak}} = 50000\\,\\mathrm{s}$，\n  - $C_{\\mathrm{bg}} = 1.6\\times 10^{-2}\\,\\mathrm{mol/m^3}$，\n  - 传感器深度 $\\{z_s\\} = [0.1\\,\\mathrm{m}, 0.5\\,\\mathrm{m}, 1.0\\,\\mathrm{m}, 2.0\\,\\mathrm{m}, 4.0\\,\\mathrm{m}]$。\n\n- 案例 $4$ (瞬态泄漏：短时注入，长时间范围)：\n  - $L = 5.0\\,\\mathrm{m}$，$\\Delta z = 0.01\\,\\mathrm{m}$，\n  - $D = 1.0\\times 10^{-6}\\,\\mathrm{m^2/s}$，\n  - $T = 86400\\,\\mathrm{s}$，$\\Delta t = 120\\,\\mathrm{s}$，\n  - $z_0 = 3.0\\,\\mathrm{m}$，\n  - $F_{\\mathrm{leak}} = 1.0\\times 10^{-5}\\,\\mathrm{mol/(m^2\\,s)}$，\n  - $T_{\\mathrm{leak}} = 3600\\,\\mathrm{s}$，\n  - $C_{\\mathrm{bg}} = 1.6\\times 10^{-2}\\,\\mathrm{mol/m^3}$，\n  - 传感器深度 $\\{z_s\\} = [0.1\\,\\mathrm{m}, 0.5\\,\\mathrm{m}, 1.0\\,\\mathrm{m}, 2.0\\,\\mathrm{m}, 4.0\\,\\mathrm{m}]$。\n\n答案规范和最终输出格式：\n- 对于每种情况，计算$S$和列表$[\\Delta C(z_{s,1},T), \\Delta C(z_{s,2},T), \\dots]$（单位为$\\mathrm{mol/m^3}$）。\n- 你的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，并用方括号括起来，每个内部列表按$[S, \\Delta C(z_{s,1},T), \\Delta C(z_{s,2},T), \\dots]$的顺序排列。例如：$$[[S_1,\\Delta C_{1,1},\\dots],[S_2,\\Delta C_{2,1},\\dots],\\dots].$$",
            "solution": "用户希望解决一个带源项的一维瞬态扩散问题，以模拟二氧化碳泄漏并计算可测量量。\n\n### **1. 问题陈述形式化**\n\n关于摩尔浓度$C(z,t)$（单位$\\mathrm{mol/m^3}$）作为深度$z$和时间$t$的函数的控制偏微分方程（PDE）是带源项的菲克第二定律：\n$$\n\\frac{\\partial C(z,t)}{\\partial t} = D \\frac{\\partial^2 C(z,t)}{\\partial z^2} + s(z,t)\n$$\n其中$D$是常数有效扩散系数（单位$\\mathrm{m^2/s}$），$s(z,t)$是体积源项（单位$\\mathrm{mol/(m^3 \\cdot s)}$）。\n\n区域为$z \\in [0,L]$，具有以下初始和边界条件：\n- 初始条件：$C(z,0) = C_{\\mathrm{bg}}$\n- 在$z=0$（地表）的边界条件：$C(0,t) = C_{\\mathrm{atm}}$\n- 在$z=L$（深层边界）的边界条件：$\\frac{\\partial C(L,t)}{\\partial z} = 0$\n\n问题指明大气浓度等于背景浓度，$C_{\\mathrm{atm}} = C_{\\mathrm{bg}}$。\n\n为了在数值上简化问题，我们定义相对于背景的浓度变化量 $\\Delta C(z,t) = C(z,t) - C_{\\mathrm{bg}}$。由于$C_{\\mathrm{bg}}$是一个常数，其导数为$\\frac{\\partial \\Delta C}{\\partial t} = \\frac{\\partial C}{\\partial t}$和$\\frac{\\partial \\Delta C}{\\partial z} = \\frac{\\partial C}{\\partial z}$。代入控制方程和边界/初始条件，得到一个关于$\\Delta C$的转换后问题：\n- 偏微分方程（PDE）：$\\frac{\\partial \\Delta C(z,t)}{\\partial t} = D \\frac{\\partial^2 \\Delta C(z,t)}{\\partial z^2} + s(z,t)$\n- 初始条件：$\\Delta C(z,0) = C(z,0) - C_{\\mathrm{bg}} = C_{\\mathrm{bg}} - C_{\\mathrm{bg}} = 0$\n- 在$z=0$的边界条件：$\\Delta C(0,t) = C(0,t) - C_{\\mathrm{bg}} = C_{\\mathrm{atm}} - C_{\\mathrm{bg}} = 0$\n- 在$z=L$的边界条件：$\\frac{\\partial \\Delta C(L,t)}{\\partial z} = 0$\n\n这个转换后的问题更方便，因为它具有齐次的初始条件和狄利克雷边界条件。\n\n### **2. 数值离散化**\n\n我们将使用有限差分法求解转换后的问题。空间域$z \\in [0,L]$被离散化为一个包含$N_z$个点的均匀网格，使得$z_i = i \\cdot \\Delta z$，其中$i=0, 1, \\dots, N_z-1$，总点数为$N_z = L/\\Delta z + 1$。时间域以恒定的步长$\\Delta t$离散化，使得$t_n = n \\cdot \\Delta t$。令$u_i^n \\approx \\Delta C(z_i, t_n)$。\n\n**时间离散化：**我们使用无条件稳定的隐式（后向）欧拉方法：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = D \\left(\\frac{\\partial^2 \\Delta C}{\\partial z^2}\\right)\\bigg|_{i}^{n+1} + s_i^{n+1}\n$$\n\n**空间离散化：**我们对空间导数使用二阶中心差分格式：\n$$\n\\left(\\frac{\\partial^2 \\Delta C}{\\partial z^2}\\right)\\bigg|_{i}^{n+1} \\approx \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{(\\Delta z)^2}\n$$\n\n将它们组合用于内部网格节点（$i = 1, \\dots, N_z-2$），我们得到：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = D \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{(\\Delta z)^2} + s_i^{n+1}\n$$\n重新整理，将时间步$n+1$的项组合在左侧：\n$$\n- \\frac{D \\Delta t}{(\\Delta z)^2} u_{i-1}^{n+1} + \\left(1 + 2\\frac{D \\Delta t}{(\\Delta z)^2}\\right) u_i^{n+1} - \\frac{D \\Delta t}{(\\Delta z)^2} u_{i+1}^{n+1} = u_i^n + \\Delta t \\, s_i^{n+1}\n$$\n定义无量纲扩散数$\\alpha = \\frac{D \\Delta t}{(\\Delta z)^2}$，方程变为：\n$$\n-\\alpha u_{i-1}^{n+1} + (1 + 2\\alpha) u_i^{n+1} - \\alpha u_{i+1}^{n+1} = u_i^n + \\Delta t \\, s_i^{n+1}\n$$\n\n### **3. 边界条件实现**\n\n方程组涉及未知浓度$u_i^{n+1}$（$i=1, \\dots, N_z-1$）。值$u_0^{n+1}$由边界条件可知。\n\n- **地表（$z=0$, $i=0$）：**狄利克雷条件是$u_0^{n+1} = \\Delta C(0, t_{n+1}) = 0$。这个值是已知的，并且在所有时间步中都是固定的。\n\n- **深层边界（$z=L$, $i=N_z-1$）：**诺伊曼条件是$\\frac{\\partial \\Delta C}{\\partial z} = 0$。为保持二阶精度，我们采用一个位于$z_{N_z} = L + \\Delta z$的“虚拟点”。在$z_{N_z-1}=L$处导数的中心差分近似为：\n$$\n\\frac{u_{N_z}^{n+1} - u_{N_z-2}^{n+1}}{2 \\Delta z} = 0 \\implies u_{N_z}^{n+1} = u_{N_z-2}^{n+1}\n$$\n现在，我们写出边界节点$i=N_z-1$处的离散化PDE：\n$$\n-\\alpha u_{N_z-2}^{n+1} + (1 + 2\\alpha) u_{N_z-1}^{n+1} - \\alpha u_{N_z}^{n+1} = u_{N_z-1}^n + \\Delta t \\, s_{N_z-1}^{n+1}\n$$\n代入虚拟点条件$u_{N_z}^{n+1} = u_{N_z-2}^{n+1}$：\n$$\n-2\\alpha u_{N_z-2}^{n+1} + (1 + 2\\alpha) u_{N_z-1}^{n+1} = u_{N_z-1}^n + \\Delta t \\, s_{N_z-1}^{n+1}\n$$\n\n### **4. 线性系统构建**\n\n未知向量$\\mathbf{u}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N_z-1}^{n+1}]^T$的方程组构成一个线性系统$\\mathbf{A}\\mathbf{u}^{n+1} = \\mathbf{b}$。矩阵$\\mathbf{A}$是一个大小为$(N_z-1) \\times (N_z-1)$的三对角矩阵，并且不随时间变化：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1+2\\alpha  -\\alpha  0  \\dots  0 \\\\\n-\\alpha  1+2\\alpha  -\\alpha  \\dots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n0  \\dots  -\\alpha  1+2\\alpha  -\\alpha \\\\\n0  \\dots  0  -2\\alpha  1+2\\alpha\n\\end{pmatrix}\n$$\n右侧向量$\\mathbf{b}$取决于前一时间步的解$\\mathbf{u}^n$和源项：\n- 对于$i=1$：$b_1 = u_1^n + \\Delta t \\, s_1^{n+1} + \\alpha u_0^{n+1} = u_1^n + \\Delta t \\, s_1^{n+1}$（因为$u_0=0$）。\n- 对于$1  i  N_z-1$：$b_i = u_i^n + \\Delta t \\, s_i^{n+1}$。\n- 对于$i=N_z-1$：$b_{N_z-1} = u_{N_z-1}^n + \\Delta t \\, s_{N_z-1}^{n+1}$。\n\n### **5. 源项和输出计算**\n\n- **源项：**深度$z_0$处的泄漏通量$F_{\\mathrm{leak}}$被建模为包含$z_0$的网格单元内的体积源$s = F_{\\mathrm{leak}} / \\Delta z$。令$i_0 = \\text{round}(z_0 / \\Delta z)$。如果$t_{n+1} \\le T_{\\mathrm{leak}}$，源向量$\\mathbf{s}^{n+1}$有一个非零元素$s_{i_0}^{n+1} = F_{\\mathrm{leak}}/\\Delta z$，否则为零。\n\n- **地表通量$J(0,T)$：**地表通量由菲克第一定律给出。我们使用$\\Delta C$的解在最终时间$T$评估它。在$z=0$处使用一阶向前差分近似梯度：\n$$\nJ(0,T) = -D \\left.\\frac{\\partial C}{\\partial z}\\right|_{z=0,t=T} = -D \\left.\\frac{\\partial \\Delta C}{\\partial z}\\right|_{z=0,t=T} \\approx -D \\frac{u_1^N - u_0^N}{\\Delta z} = -D \\frac{u_1^N}{\\Delta z}\n$$\n其中$N$是最终时间步的索引。\n\n- **敏感性$S$：**敏感性按无量纲比率计算：\n$$\nS = \\frac{J(0,T)}{F_{\\mathrm{leak}}}\n$$\n\n- **浓度变化$\\Delta C(z_s,T)$：**对于每个深度为$z_s$的传感器，我们从最终浓度分布$u_i^N$中找到值$\\Delta C(z_s,T)$。如果$z_s$与网格点不重合，则使用线性插值。对于给定的$z_s$，我们找到下网格索引$i = \\lfloor z_s / \\Delta z \\rfloor$和分数距离$\\phi = (z_s/\\Delta z) - i$。插值结果为：\n$$\n\\Delta C(z_s,T) \\approx u_i^N (1 - \\phi) + u_{i+1}^N \\phi\n$$\n由于问题是直接求解$\\Delta C$的，这个插值就是最终所需的量。\n\n总体算法包括初始化$\\mathbf{u}^0 = \\mathbf{0}$，构建不随时间变化的矩阵$\\mathbf{A}$，然后遍历时间步。在每一步中，组装右侧向量$\\mathbf{b}$，并使用计算效率高的`scipy.linalg.solve_banded`来求解三对角系统以得到$\\mathbf{u}^{n+1}$。最后，从最终浓度分布$\\mathbf{u}^N$计算所需的输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(L, delta_z, D, T, delta_t, z0, F_leak, T_leak, C_bg, sensor_depths):\n    \"\"\"\n    Solves the 1D diffusion equation for CCUS leakage monitoring.\n\n    The function solves for delta_C = C - C_bg.\n    PDE: d(delta_C)/dt = D * d^2(delta_C)/dz^2 + s(z,t)\n    IC: delta_C(z,0) = 0\n    BC: delta_C(0,t) = 0 (Dirichlet), d(delta_C)/dz(L,t) = 0 (Neumann)\n    \"\"\"\n\n    # 1. Grid and Time Setup\n    Nz = int(round(L / delta_z)) + 1\n    z_nodes = np.linspace(0, L, Nz)\n    \n    time_steps = np.arange(0, T + delta_t, delta_t)\n    Nt = len(time_steps) - 1\n\n    # Number of internal nodes (unknowns)\n    M = Nz - 1\n\n    # 2. Discretization Parameters and Initialization\n    # Dimensionless diffusion number (alpha)\n    alpha = D * delta_t / (delta_z ** 2)\n    \n    # Initialize concentration change vector delta_C (u)\n    # The full vector includes the boundary at z=0\n    u_full = np.zeros(Nz)\n    \n    # Internal nodes vector (the unknowns we solve for)\n    u_internal = u_full[1:]\n\n    # 3. Construct the Tridiagonal Matrix A\n    # A is of size M x M, for unknowns u_1 to u_{Nz-1}\n    # Using scipy.linalg.solve_banded which requires bands format\n    # ab has shape (3, M), for l=1, u=1\n    ab = np.zeros((3, M))\n    # Main diagonal (b_i)\n    ab[1, :] = 1 + 2 * alpha\n    # Upper diagonal (c_i)\n    ab[0, 1:] = -alpha\n    # Lower diagonal (a_i)\n    ab[2, :-1] = -alpha\n    # Modify for Neumann boundary at z=L (i=Nz-1)\n    # Equation: -2*alpha*u_{M-2} + (1+2*alpha)*u_{M-1} = ...\n    # This affects the last element of the lower diagonal\n    ab[2, M - 2] = -2 * alpha\n\n    # 4. Source Term Setup\n    s_vec = np.zeros(Nz)\n    i0 = int(round(z0 / delta_z))\n    if i0 > 0 and i0  Nz:\n        volumetric_source = F_leak / delta_z\n        s_vec[i0] = volumetric_source\n\n    s_internal = s_vec[1:] # Source term for internal nodes\n\n    # 5. Time Stepping Loop\n    for n in range(Nt):\n        current_time = (n + 1) * delta_t\n\n        # Right-hand side vector b\n        b = u_internal.copy()\n        \n        # Add source term if leakage is active\n        if current_time = T_leak:\n            b += delta_t * s_internal\n        \n        # The Dirichlet BC u_0 = 0 means no term is added from the z=0 boundary\n        \n        # Solve the linear system A * u_new = b\n        u_internal = solve_banded((1, 1), ab, b)\n    \n    # Final concentration profile (full array)\n    u_final_full = np.zeros(Nz)\n    u_final_full[1:] = u_internal\n    \n    # 6. Calculate Output Quantities\n    \n    # Surface diffusive efflux J(0,T)\n    # J = -D * d(delta_C)/dz at z=0\n    # Using first-order forward difference: (u_1 - u_0) / delta_z\n    J_surface = -D * (u_final_full[1] - u_final_full[0]) / delta_z\n\n    # Sensitivity S\n    S = J_surface / F_leak if F_leak != 0 else 0.0\n\n    # Concentration change at sensor depths\n    delta_C_sensors = []\n    for zs in sensor_depths:\n        # Using linear interpolation\n        idx_float = zs / delta_z\n        idx_floor = int(idx_float)\n        frac = idx_float - idx_floor\n        \n        if idx_floor + 1  Nz:\n            val = u_final_full[idx_floor] * (1 - frac) + u_final_full[idx_floor + 1] * frac\n        else: # On the last node\n            val = u_final_full[idx_floor]\n        delta_C_sensors.append(val)\n\n    return [S] + delta_C_sensors\n\ndef solve():\n    test_cases = [\n        {\n            \"L\": 5.0, \"delta_z\": 0.01,\n            \"D\": 1.0e-6,\n            \"T\": 86400, \"delta_t\": 120,\n            \"z0\": 2.0,\n            \"F_leak\": 1.0e-5,\n            \"T_leak\": 86400,\n            \"C_bg\": 1.6e-2,\n            \"sensor_depths\": [0.1, 0.5, 1.0, 2.0, 4.0]\n        },\n        {\n            \"L\": 5.0, \"delta_z\": 0.01,\n            \"D\": 1.0e-6,\n            \"T\": 10000, \"delta_t\": 60,\n            \"z0\": 0.1,\n            \"F_leak\": 1.0e-5,\n            \"T_leak\": 10000,\n            \"C_bg\": 1.6e-2,\n            \"sensor_depths\": [0.1, 0.5, 1.0, 2.0, 4.0]\n        },\n        {\n            \"L\": 5.0, \"delta_z\": 0.01,\n            \"D\": 1.0e-7,\n            \"T\": 50000, \"delta_t\": 100,\n            \"z0\": 4.0,\n            \"F_leak\": 1.0e-5,\n            \"T_leak\": 50000,\n            \"C_bg\": 1.6e-2,\n            \"sensor_depths\": [0.1, 0.5, 1.0, 2.0, 4.0]\n        },\n        {\n            \"L\": 5.0, \"delta_z\": 0.01,\n            \"D\": 1.0e-6,\n            \"T\": 86400, \"delta_t\": 120,\n            \"z0\": 3.0,\n            \"F_leak\": 1.0e-5,\n            \"T_leak\": 3600,\n            \"C_bg\": 1.6e-2,\n            \"sensor_depths\": [0.1, 0.5, 1.0, 2.0, 4.0]\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        all_results.append(result)\n    \n    # Format the final output as a string representation of a list of lists\n    # e.g., [[S1, dC1_1, dC1_2], [S2, dC2_1, dC2_2]]\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{val:.6e}\" for val in res) + \"]\"\n        for res in all_results\n    ) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}