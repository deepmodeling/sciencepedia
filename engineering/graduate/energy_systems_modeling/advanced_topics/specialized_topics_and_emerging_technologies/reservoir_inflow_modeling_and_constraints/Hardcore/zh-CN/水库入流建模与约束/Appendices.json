{
    "hands_on_practices": [
        {
            "introduction": "本练习通过一个经典的洪水事件管理场景，帮助您深入理解水库的确定性调度。在面对不断增加入流的情况下，您需要综合考虑涡轮机容量和爬坡率等多种现实约束，以最小化溢流量。 这项练习旨在锻炼您在多重约束下平衡入流、释放和蓄水的核心能力，这是水资源管理的基础。",
            "id": "4118221",
            "problem": "一个单水库水电系统使用连续性方程和符合物理现实的运行约束进行建模。假设水库在相关运行区间内具有面积为 $A$ 的水平水面和线性的水位-库容关系，因此水位上升 $\\Delta h$ 对应于可用蓄水容量 $\\Delta V = A \\Delta h$。在所考虑的时间范围内，忽略蒸发、库区降水和渗漏。水库接收来流 $Q_{\\mathrm{in}}(t)$，释放受水力容量和爬坡约束限制的涡轮机泄流 $Q_{\\mathrm{turb}}(t)$，并在必要时通过溢洪道进行泄流 $Q_{\\mathrm{spill}}(t)$。质量平衡方程为\n$$\\frac{dV(t)}{dt} = Q_{\\mathrm{in}}(t) - Q_{\\mathrm{turb}}(t) - Q_{\\mathrm{spill}}(t),$$\n其中 $V(t)$ 是时刻 $t$ 时相对于初始状态的水库库容。涡轮机泄流受到最大水力容量 $Q_{\\mathrm{T,max}}$ 和对称的爬坡率限制 $|dQ_{\\mathrm{turb}}/dt| \\le R$ 的约束。当 $V(t)$ 达到 $\\Delta V$ 时，溢洪道的泄流量不得超过其最大水力容量 $Q_{\\mathrm{S,max}}$。\n\n考虑在时间范围 $H$ 内发生的以下事件：\n- 初始来流为 $Q_{0}$，在上升持续时间 $T$ 内线性增加到 $Q_{1}$，即对于 $0 \\le t \\le T$ 有 $Q_{\\mathrm{in}}(t) = Q_{0} + \\alpha t$，其中 $\\alpha = (Q_{1} - Q_{0})/T$，而对于 $T \\le t \\le H$ 有 $Q_{\\mathrm{in}}(t) = Q_{1}$。\n- 涡轮机初始泄流量为 $Q_{\\mathrm{turb}}(0) = Q_{0}$，其运行目标是在遵守 $Q_{\\mathrm{turb}}(t) \\le Q_{\\mathrm{T,max}}$ 和 $|dQ_{\\mathrm{turb}}/dt| \\le R$ 的前提下，最小化在 $[0,H]$ 时间段内的总弃水量。\n- 溢洪道约束为：每当 $V(t) = \\Delta V$ 时，$Q_{\\mathrm{spill}}(t) \\le Q_{\\mathrm{S,max}}$。\n\n数据如下：\n- $A = 2.0 \\times 10^{6}~\\mathrm{m^{2}}$,\n- $\\Delta h = 1.5~\\mathrm{m}$,\n- $Q_{0} = 200~\\mathrm{m^{3}/s}$,\n- $Q_{1} = 800~\\mathrm{m^{3}/s}$,\n- $T = 10{,}800~\\mathrm{s}$,\n- $H = 21{,}600~\\mathrm{s}$,\n- $Q_{\\mathrm{T,max}} = 700~\\mathrm{m^{3}/s}$,\n- $R = 100~\\mathrm{m^{3}/s~每~小时}$,\n- $Q_{\\mathrm{S,max}} = 500~\\mathrm{m^{3}/s}$.\n\n假设操作员采用一种控制策略，以最大允许速率增加 $Q_{\\mathrm{turb}}(t)$ 直至达到水力容量 $Q_{\\mathrm{T,max}}$，以最小化弃水，并且不会发生负弃水（$Q_{\\mathrm{spill}}(t) \\ge 0$）。仅使用连续性方程和给定的约束作为建模基础，推导在时间范围 $[0,H]$ 内的总弃水量。以立方米为单位表示最终弃水量，并将您的答案四舍五入到四位有效数字。",
            "solution": "问题陈述被评估为有效。它在科学上基于质量守恒原理，是适定的，具有一套完整且一致的数据和约束，并以客观、可形式化的语言表达。没有可识别的缺陷会使其无效。因此，我们可以进行完整解答。\n\n水库库容 $V(t)$ 的控制方程是连续性方程：\n$$\n\\frac{dV(t)}{dt} = Q_{\\mathrm{in}}(t) - Q_{\\mathrm{turb}}(t) - Q_{\\mathrm{spill}}(t)\n$$\n其中 $V(0) = 0$。在时间范围 $[0, H]$ 内的总弃水量为 $V_{\\mathrm{spill}} = \\int_{0}^{H} Q_{\\mathrm{spill}}(t) dt$。\n\n首先，我们用一致的国际单位制（SI）单位来定义所有参数。\n- 水库面积: $A = 2.0 \\times 10^{6}~\\mathrm{m^{2}}$\n- 对应容量的水位上升高度: $\\Delta h = 1.5~\\mathrm{m}$\n- 可用蓄水容量: $\\Delta V = A \\Delta h = (2.0 \\times 10^{6}~\\mathrm{m^{2}}) \\times (1.5~\\mathrm{m}) = 3.0 \\times 10^{6}~\\mathrm{m^{3}}$\n- 初始来流: $Q_{0} = 200~\\mathrm{m^{3}/s}$\n- 最终来流率: $Q_{1} = 800~\\mathrm{m^{3}/s}$\n- 来流上升持续时间: $T = 10{,}800~\\mathrm{s}$\n- 时间范围: $H = 21{,}600~\\mathrm{s}$\n- 最大涡轮机泄流量: $Q_{\\mathrm{T,max}} = 700~\\mathrm{m^{3}/s}$\n- 最大溢洪道泄流量: $Q_{\\mathrm{S,max}} = 500~\\mathrm{m^{3}/s}$\n- 涡轮机爬坡率限制: $R = 100~\\mathrm{m^{3}/s~每~小时}$。我们将其转换为 $\\mathrm{m^{3}/s^2}$:\n$$\nR = \\frac{100~\\mathrm{m^{3}/s}}{1~\\mathrm{小时}} = \\frac{100~\\mathrm{m^{3}/s}}{3600~\\mathrm{s}} = \\frac{1}{36}~\\mathrm{m^{3}/s^2}\n$$\n\n接下来，我们建立来流 $Q_{\\mathrm{in}}(t)$ 和涡轮机泄流 $Q_{\\mathrm{turb}}(t)$ 随时间变化的函数。\n\n来流 $Q_{\\mathrm{in}}(t)$ 在区间 $[0, T]$ 内从 $Q_{0}$ 线性增加到 $Q_{1}$，然后保持不变。\n- 对于 $0 \\le t \\le T$：$Q_{\\mathrm{in}}(t) = Q_{0} + \\alpha t$，其中 $\\alpha = \\frac{Q_{1} - Q_{0}}{T} = \\frac{800 - 200}{10{,}800} = \\frac{600}{10{,}800} = \\frac{1}{18}~\\mathrm{m^{3}/s^2}$。因此，$Q_{\\mathrm{in}}(t) = 200 + \\frac{1}{18}t$。\n- 对于 $T  t \\le H$：$Q_{\\mathrm{in}}(t) = Q_{1} = 800~\\mathrm{m^{3}/s}$。\n\n涡轮机泄流 $Q_{\\mathrm{turb}}(t)$ 起始值为 $Q_{\\mathrm{turb}}(0) = Q_{0} = 200~\\mathrm{m^{3}/s}$，并以最大爬坡率 $R$ 增加，直到达到 $Q_{\\mathrm{T,max}}$。\n设 $t_1$ 为 $Q_{\\mathrm{turb}}(t)$ 达到 $Q_{\\mathrm{T,max}}$ 的时间。\n$Q_{\\mathrm{T,max}} = Q_{\\mathrm{turb}}(0) + R t_1 \\implies t_1 = \\frac{Q_{\\mathrm{T,max}} - Q_0}{R}$。\n$$\nt_1 = \\frac{700~\\mathrm{m^{3}/s} - 200~\\mathrm{m^{3}/s}}{(1/36)~\\mathrm{m^{3}/s^2}} = \\frac{500}{1/36} = 18{,}000~\\mathrm{s}\n$$\n由于 $t_1 = 18{,}000~\\mathrm{s}  H = 21{,}600~\\mathrm{s}$，涡轮机在时间范围的一部分内以最大容量运行。\n- 对于 $0 \\le t \\le t_1$：$Q_{\\mathrm{turb}}(t) = Q_0 + R t = 200 + \\frac{1}{36}t$。\n- 对于 $t_1  t \\le H$：$Q_{\\mathrm{turb}}(t) = Q_{\\mathrm{T,max}} = 700~\\mathrm{m^{3}/s}$。\n\n弃水 $Q_{\\mathrm{spill}}(t)$ 仅在水库达到其最大容量 $V(t) = \\Delta V$ 且净入流为正时发生。对连续性方程进行积分可得：\n$$\nV(H) - V(0) = \\int_{0}^{H} Q_{\\mathrm{in}}(t) dt - \\int_{0}^{H} Q_{\\mathrm{turb}}(t) dt - \\int_{0}^{H} Q_{\\mathrm{spill}}(t) dt\n$$\n当 $V(0)=0$ 且 $V_{\\mathrm{spill}} = \\int_{0}^{H} Q_{\\mathrm{spill}}(t) dt$ 时，我们有 $V_{\\mathrm{spill}} = \\int_{0}^{H} \\left( Q_{\\mathrm{in}}(t) - Q_{\\mathrm{turb}}(t) \\right) dt - V(H)$。\n为了最小化弃水，最终库容 $V(H)$ 应被最大化，直至蓄水容量 $\\Delta V$。\n我们来分析净入流率 $Q_{\\mathrm{net}}(t) = Q_{\\mathrm{in}}(t) - Q_{\\mathrm{turb}}(t)$。\n- 对于 $0 \\le t \\le T = 10{,}800$：$Q_{\\mathrm{net}}(t) = (200 + \\frac{1}{18}t) - (200 + \\frac{1}{36}t) = (\\frac{1}{18} - \\frac{1}{36})t = \\frac{1}{36}t$。这是非负的。\n- 对于 $T  t \\le t_1 = 18{,}000$：$Q_{\\mathrm{net}}(t) = 800 - (200 + \\frac{1}{36}t) = 600 - \\frac{1}{36}t$。在 $t=T=10{,}800$ 时，$Q_{\\mathrm{net}}(T) = 600 - 300 = 300~\\mathrm{m^{3}/s}$。在 $t=t_1=18{,}000$ 时，$Q_{\\mathrm{net}}(t_1) = 600 - 500 = 100~\\mathrm{m^{3}/s}$。在此区间内，该率为正。\n- 对于 $t_1  t \\le H = 21{,}600$：$Q_{\\mathrm{net}}(t) = 800 - 700 = 100~\\mathrm{m^{3}/s}$。这是正的。\n\n由于在整个时间范围 $t \\in [0, H]$ 内 $Q_{\\mathrm{net}}(t) \\ge 0$，水库中的潜在库容是单调不减的。这意味着如果水库蓄满至容量 $\\Delta V$，在时间范围结束前它不会排空。总弃水量是总潜在累积库容减去蓄水容量。\n$$\nV_{\\mathrm{spill}} = \\max\\left(0, \\int_{0}^{H} \\left( Q_{\\mathrm{in}}(t) - Q_{\\mathrm{turb}}(t) \\right) dt - \\Delta V\\right)\n$$\n我们计算总入库水量，$V_{\\mathrm{in,tot}} = \\int_{0}^{H} Q_{\\mathrm{in}}(t) dt$：\n$$\nV_{\\mathrm{in,tot}} = \\int_{0}^{T} (Q_0 + \\alpha t) dt + \\int_{T}^{H} Q_1 dt = \\left(\\frac{Q_0+Q_1}{2}\\right)T + Q_1(H-T)\n$$\n$$\nV_{\\mathrm{in,tot}} = \\left(\\frac{200+800}{2}\\right) \\times 10{,}800 + 800 \\times (21{,}600-10{,}800) = 500 \\times 10{,}800 + 800 \\times 10{,}800\n$$\n$$\nV_{\\mathrm{in,tot}} = 5.4 \\times 10^{6} + 8.64 \\times 10^{6} = 14.04 \\times 10^{6}~\\mathrm{m^{3}}\n$$\n接下来，我们计算总涡轮机泄流量，$V_{\\mathrm{turb,tot}} = \\int_{0}^{H} Q_{\\mathrm{turb}}(t) dt$：\n$$\nV_{\\mathrm{turb,tot}} = \\int_{0}^{t_1} (Q_0 + R t) dt + \\int_{t_1}^{H} Q_{\\mathrm{T,max}} dt = \\left(\\frac{Q_0+Q_{\\mathrm{T,max}}}{2}\\right)t_1 + Q_{\\mathrm{T,max}}(H-t_1)\n$$\n$$\nV_{\\mathrm{turb,tot}} = \\left(\\frac{200+700}{2}\\right) \\times 18{,}000 + 700 \\times (21{,}600-18{,}000) = 450 \\times 18{,}000 + 700 \\times 3600\n$$\n$$\nV_{\\mathrm{turb,tot}} = 8.1 \\times 10^{6} + 2.52 \\times 10^{6} = 10.62 \\times 10^{6}~\\mathrm{m^{3}}\n$$\n总潜在累积库容是总入库水量和总涡轮机泄流量之差：\n$$\nV_{\\mathrm{p}}(H) = V_{\\mathrm{in,tot}} - V_{\\mathrm{turb,tot}} = 14.04 \\times 10^{6} - 10.62 \\times 10^{6} = 3.42 \\times 10^{6}~\\mathrm{m^{3}}\n$$\n该库容大于可用蓄水容量 $\\Delta V = 3.0 \\times 10^{6}~\\mathrm{m^{3}}$。因此，将会发生弃水。总弃水量为：\n$$\nV_{\\mathrm{spill}} = V_{\\mathrm{p}}(H) - \\Delta V = 3.42 \\times 10^{6} - 3.0 \\times 10^{6} = 0.42 \\times 10^{6}~\\mathrm{m^{3}} = 420{,}000~\\mathrm{m^{3}}\n$$\n作为最后检查，我们必须确保溢洪道容量约束 $Q_{\\mathrm{spill}}(t) \\le Q_{\\mathrm{S,max}}$ 未被违反。当 $V(t) = \\Delta V$ 时会发生弃水，此时 $Q_{\\mathrm{spill}}(t) = Q_{\\mathrm{net}}(t)$。我们必须检查弃水期间 $\\max(Q_{\\mathrm{net}}(t))$ 是否小于 $Q_{\\mathrm{S,max}} = 500~\\mathrm{m^{3}/s}$。$Q_{\\mathrm{net}}(t)$ 的最大值出现在 $t=T=10{,}800~\\mathrm{s}$ 时，此时 $Q_{\\mathrm{net}}(T) = 300~\\mathrm{m^{3}/s}$。由于函数 $Q_{\\mathrm{net}}(t)$ 从 $t=T$ 到 $t=t_1$ 是单调递减的，然后保持恒定，因此最大弃水率将小于或等于 $300~\\mathrm{m^{3}/s}$。这远低于 $500~\\mathrm{m^{3}/s}$ 的溢洪道容量，因此该约束得到满足。\n\n最终答案，四舍五入到四位有效数字，是 $4.200 \\times 10^{5}~\\mathrm{m^{3}}$。",
            "answer": "$$\n\\boxed{4.200 \\times 10^{5}}\n$$"
        },
        {
            "introduction": "从一次性计算到构建通用工具，是建模能力的一大步。本练习将指导您把连续的质量平衡方程转化为离散时间的计算机模型，并实现一个包含多重约束的逐步仿真逻辑。 这是能量系统建模中的一项核心任务，能让您亲手处理水库调度中复杂的决策流程，例如如何处理溢流和水量削减。",
            "id": "4118229",
            "problem": "构建一个程序，在一个离散的时间范围内，执行物理上一致的水库质量平衡和状态更新约束。该水库被表示为一个控制体积，其蓄水量 $s(t)$ 以立方米为单位，入库流量 $I(t)$ 以立方米/秒为单位，出库流量 $R(t)$ 以立方米/秒为单位，蒸发速率 $E(t)$ 以米/秒为单位。水库表面积被建模为一个与蓄水量相关的函数 $A(s)$，单位为平方米。程序必须从质量守恒定律推导出离散时间的状态更新，然后在每个时间步强制执行运行约束。\n\n从控制体积的质量守恒开始：蓄水量的变化率等于净入流量减去净出流量和损失量。使用一阶显式时间离散化方法，在一个固定的时间步长 $\\Delta t$ 上，从这个基本定律推导出离散时间更新 $s_{t+1}$，并假设在每个区间内入流、出流和蒸发是分段恒定的。将蒸发建模为通量 $E_t$（单位为米/秒），作用于瞬时表面积 $A(s_t)$（单位为平方米），从而产生体积损失率 $E_t A(s_t)$（单位为立方米/秒）。\n\n强制执行以下约束，所有约束均针对每个时间步 $t$ 表示：\n- 蓄水量边界：对于所有 $t$， $S_{\\min} \\le s_t \\le S_{\\max}$。如果无约束更新将导致 $s_{t+1}  S_{\\max}$，多余的水必须被溢出，使得 $s_{t+1} = S_{\\max}$。如果无约束更新将导致 $s_{t+1}  S_{\\min}$，则必须削减出库流量以精确满足 $s_{t+1} = S_{\\min}$。\n- 最小生态下泄流量：$\\underline{R} \\le R_t$。\n- 水轮机容量（最大下泄流量）：$R_t \\le \\overline{R}$。\n- 爬坡率约束：$\\lvert R_t - R_{t-1} \\rvert \\le \\rho$，其中 $\\rho$ 是每个时间步长内下泄流量的最大变化量。初始的前一时刻下泄流量 $R_{-1}$ 已被指定。\n\n将表面积函数定义为 $A(s) = A_0 + \\alpha s$，其中 $A_0$ 是一个单位为平方米的正常量，$\\alpha$ 是一个单位为米⁻¹的非负常量。当为满足最小蓄水量而削减 $R_t$ 时，应确保所选的 $R_t$ 是在保持 $s_{t+1} \\ge S_{\\min}$ 的同时，如果物理上可能，也满足最小生态下泄流量的最大值；如果无法在不违反 $S_{\\min}$ 的情况下满足最小生态下泄流量，则将 $R_t$ 设置为最大可行值，并报告未满足生态流量要求。\n\n单位和数值要求：\n- 所有蓄水量 $s_t$ 以立方米表示，所有入库流量 $I_t$ 以立方米/秒表示，所有出库流量 $R_t$ 以立方米/秒表示，蒸发速率 $E_t$ 以米/秒表示，表面积 $A(s)$ 以平方米表示，时间步长 $\\Delta t$ 以秒表示。\n- 程序必须计算蓄水量序列 $\\{s_1, s_2, \\dots, s_T\\}$，以浮点数形式表示，单位为立方米。\n- 程序必须为每个测试用例计算三个布尔值：是否在每个时间步都满足了最小生态下泄流量，是否在任何时间步发生了溢流，以及相对于期望下泄流量，是否因 $\\lvert R_t - R_{t-1} \\rvert  \\rho$ 而发生任何爬坡限制。\n\n测试套件：\n使用长度为 $T = 4$ 的时间范围，以及以下全局共享参数：\n- $S_{\\min} = 10{,}000{,}000$ 立方米，\n- $S_{\\max} = 100{,}000{,}000$ 立方米，\n- $A_0 = 3{,}000{,}000$ 平方米，\n- $\\alpha = 0.005$ 米⁻¹，\n- $\\Delta t = 86{,}400$ 秒，\n- $\\underline{R} = 50$ 立方米/秒，\n- $\\overline{R} = 400$ 立方米/秒，\n- $\\rho = 100$ 立方米/秒，\n- 对于所有案例，$R_{-1} = 50$ 立方米/秒，\n- 对于每个案例中的所有 $t$，$E_t = 6 \\times 10^{-8}$ 米/秒。\n\n定义四个测试用例，每个用例由初始蓄水量 $s_0$、入库流量向量 $\\{I_0, I_1, I_2, I_3\\}$（单位：立方米/秒）和期望下泄流量向量 $\\{R^{\\mathrm{des}}_0, R^{\\mathrm{des}}_1, R^{\\mathrm{des}}_2, R^{\\mathrm{des}}_3\\}$（单位：立方米/秒）指定：\n- 案例1（典型运行条件）：$s_0 = 50{,}000{,}000$，$\\{I_t\\} = \\{180, 160, 150, 140\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{150, 200, 180, 160\\}$。\n- 案例2（高入流量接近库容导致溢流）：$s_0 = 95{,}000{,}000$，$\\{I_t\\} = \\{500, 600, 800, 900\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{200, 200, 200, 200\\}$。\n- 案例3（低入流量有触及最低蓄水量的风险，生态流量可能无法满足）：$s_0 = 12{,}000{,}000$，$\\{I_t\\} = \\{40, 30, 20, 10\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{60, 60, 60, 60\\}$。\n- 案例4（剧烈的下泄流量变化违反爬坡约束但其他方面可行）：$s_0 = 50{,}000{,}000$，$\\{I_t\\} = \\{200, 200, 200, 200\\}$，$\\{R^{\\mathrm{des}}_t\\} = \\{50, 350, 50, 350\\}$。\n\n对于每个测试用例，生成一个形式为 $[\\text{storage\\_sequence},\\ \\text{env\\_met},\\ \\text{spill\\_occurred},\\ \\text{ramp\\_clipped\\_occurred}]$ 的结果，其中 $\\text{storage\\_sequence}$ 是列表 $[s_1, s_2, s_3, s_4]$（单位为立方米），$\\text{env\\_met}$ 是一个布尔值，指示在执行所有约束后是否每一步都满足了 $\\underline{R}$，$\\text{spill\\_occurred}$ 是一个布尔值，指示是否发生了任何溢流，$\\text{ramp\\_clipped\\_occurred}$ 是一个布尔值，指示是否由于爬坡约束而调整了任何期望的下泄流量。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3,result4]$），其中每个 $resulti$ 是为第 $i$ 个测试用例指定的上述列表。所有蓄水量值必须以立方米为单位。本问题不涉及角度。本问题不涉及百分比。",
            "solution": "用户提供的问题被评估为有效。它在科学上基于质量守恒原理，在数学上是适定的，具有一套完整的参数和约束，并以客观、正式的语言表达。该问题要求为水库开发一个离散时间仿真模型，这是水资源和能源系统工程中的一项标准任务。\n\n解决方案首先推导控制性的离散时间方程，然后开发一个分步算法来执行指定的运行约束。\n\n控制水库的基本原理是质量守恒。对于一个控制体积，蓄水量 $s(t)$ 的变化率等于体积入流量减去体积出流量。入流量由 $I(t)$ 给出，出流量包括受控下泄流量 $R(t)$ 和自然蒸发。\n\n体积蒸发损失率是蒸发速率 $E(t)$（单位为长度/时间，米/秒）与水库表面积 $A(s(t))$（单位为面积，平方米）的乘积。表面积被给定为蓄水的线性函数：\n$$ A(s) = A_0 + \\alpha s $$\n其中 $A_0$ 是基础面积，$\\alpha$ 决定了面积随蓄水量的增加而增加的程度。\n\n质量平衡的连续时间微分方程是：\n$$ \\frac{ds(t)}{dt} = I(t) - R(t) - E(t) A(s(t)) $$\n\n为了数值求解该方程，我们使用一阶显式（前向欧拉）时间离散化方法，时间步长固定为 $\\Delta t$。我们假设速率 $I_t$、$R_t$ 和 $E_t$ 在区间 $[t, t+\\Delta t]$ 上是分段恒定的。导数近似为：\n$$ \\frac{ds(t)}{dt} \\approx \\frac{s_{t+1} - s_t}{\\Delta t} $$\n将此代入质量平衡方程，并在时间 $t$ 评估右侧项，得到：\n$$ \\frac{s_{t+1} - s_t}{\\Delta t} = I_t - R_t - E_t A(s_t) $$\n重新整理以求解下一时间步的蓄水量 $s_{t+1}$，我们得到离散时间状态更新方程：\n$$ s_{t+1} = s_t + \\left( I_t - R_t - E_t (A_0 + \\alpha s_t) \\right) \\Delta t $$\n\n问题的核心是在每个时间步确定实际下泄流量 $R_t$，同时考虑期望下泄流量 $R_t^{\\mathrm{des}}$ 以及一系列物理和运行约束。对于从 $0$ 到 $T-1$ 的每个时间步 $t$，在给定状态 $s_t$ 和前一时刻下泄流量 $R_{t-1}$ 的情况下，执行以下算法。\n\n1.  **确定候选下泄流量**：下泄流量的初始目标是期望下泄流量 $R_t^{\\mathrm{des}}$。该目标将按顺序调整以满足运行约束。\n    a.  **爬坡率约束**：下泄流量不能变化太快。变化量 $|R_t - R_{t-1}|$ 不得超过爬坡率限制 $\\rho$。这为 $R_t$ 定义了一个可行范围：$[R_{t-1} - \\rho, R_{t-1} + \\rho]$。期望下泄流量被限制在此范围内。如果发生限制，`ramp_clipped_occurred` 标志位被设置为真。\n        $$ R_t' = \\max(R_{t-1} - \\rho, \\min(R_{t-1} + \\rho, R_t^{\\mathrm{des}})) $$\n    b.  **水轮机和生态约束**：下泄流量必须在水轮机容量 $\\overline{R}$ 之内，并且必须满足最小生态流量 $\\underline{R}$。这定义了第二个可行范围 $[\\underline{R}, \\overline{R}]$。然后，将受爬坡率约束的下泄流量 $R_t'$ 限制在此范围内，以产生最终的候选下泄流量 $R_t^{\\text{cand}}$。\n        $$ R_t^{\\text{cand}} = \\max(\\underline{R}, \\min(\\overline{R}, R_t')) $$\n\n2.  **计算试验性下一时刻蓄水量**：使用候选下泄流量 $R_t^{\\text{cand}}$，我们通过状态更新方程计算下一时间步的试验性蓄水量 $s_{t+1}^{\\text{tentative}}$。\n    $$ s_{t+1}^{\\text{tentative}} = s_t + \\left( I_t - R_t^{\\text{cand}} - E_t (A_0 + \\alpha s_t) \\right) \\Delta t $$\n\n3.  **执行蓄水量边界约束**：将试验性蓄水量与绝对最小和最大蓄水限制 $S_{\\min}$ 和 $S_{\\max}$ 进行比较。$s_{t+1}$ 和 $R_t$ 的最终值基于此检查确定。\n\n    a.  **溢流条件**：如果 $s_{t+1}^{\\text{tentative}} > S_{\\max}$，则水库溢流。最终蓄水量被限制在最大库容 $s_{t+1} = S_{\\max}$。多余的水被溢出。通过水轮机的受控下泄流量保持为候选下泄流量 $R_t = R_t^{\\text{cand}}$。`spill_occurred` 标志位被设置为真。\n\n    b.  **削减条件**：如果 $s_{t+1}^{\\text{tentative}}  S_{\\min}$，则候选下泄流量过高，将使水库水位降至最低水平以下。必须削减下泄流量。问题陈述要求调整下泄流量以精确满足 $s_{t+1} = S_{\\min}$。我们通过在状态更新方程中设置 $s_{t+1} = S_{\\min}$ 并求解 $R_t$ 来找到所需的下泄流量 $R_t^{\\text{req}}$：\n        $$ S_{\\min} = s_t + \\left( I_t - R_t^{\\text{req}} - E_t (A_0 + \\alpha s_t) \\right) \\Delta t $$\n        $$ R_t^{\\text{req}} = I_t - E_t (A_0 + \\alpha s_t) - \\frac{S_{\\min} - s_t}{\\Delta t} $$\n        这个值 $R_t^{\\text{req}}$ 是不违反最小蓄水量约束的最大可能下泄流量。这个物理限制会覆盖运行目标。因此，最终下泄流量被设置为此值：$R_t = R_t^{\\text{req}}$。最终蓄水量为 $s_{t+1} = S_{\\min}$。在确定此必要下泄流量后，我们检查它是否满足最小生态流量：如果 $R_t  \\underline{R}$，则 `env_met` 标志位被设置为假。\n\n    c.  **正常条件**：如果 $S_{\\min} \\le s_{t+1}^{\\text{tentative}} \\le S_{\\max}$，则候选下泄流量是可行的。最终蓄水量为试验性蓄水量 $s_{t+1} = s_{t+1}^{\\text{tentative}}$，最终下泄流量为候选下泄流量 $R_t = R_t^{\\text{cand}}$。由于 $R_t^{\\text{cand}}$ 已被强制要求 $\\ge \\underline{R}$，因此在这种情况下满足了生态流量要求。\n\n在每个时间步之后，最终下泄流量 $R_t$ 成为下一步的前一时刻下泄流量，$R_t \\rightarrow R_{t-1}$，然后仿真继续进行。对每个测试用例，在整个时间范围内重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reservoir simulation problem for all specified test cases.\n    \"\"\"\n    # Globally shared parameters\n    S_min = 10_000_000.0  # m^3\n    S_max = 100_000_000.0 # m^3\n    A0 = 3_000_000.0      # m^2\n    alpha = 0.005        # m^-1\n    delta_t = 86400.0    # seconds (1 day)\n    R_env_min = 50.0     # m^3/s\n    R_turbine_max = 400.0# m^3/s\n    rho = 100.0          # m^3/s per time step\n    R_minus_1 = 50.0     # m^3/s\n    E = 6e-8             # m/s\n    T = 4                # Number of time steps\n\n    # Test cases\n    test_cases = [\n        # Case 1 (typical operating conditions)\n        {\n            \"s0\": 50_000_000.0,\n            \"I\": np.array([180.0, 160.0, 150.0, 140.0]),\n            \"R_des\": np.array([150.0, 200.0, 180.0, 160.0]),\n        },\n        # Case 2 (high inflow near capacity causing spillage)\n        {\n            \"s0\": 95_000_000.0,\n            \"I\": np.array([500.0, 600.0, 800.0, 900.0]),\n            \"R_des\": np.array([200.0, 200.0, 200.0, 200.0]),\n        },\n        # Case 3 (low inflow risking minimum storage)\n        {\n            \"s0\": 12_000_000.0,\n            \"I\": np.array([40.0, 30.0, 20.0, 10.0]),\n            \"R_des\": np.array([60.0, 60.0, 60.0, 60.0]),\n        },\n        # Case 4 (aggressive release changes violating ramp constraints)\n        {\n            \"s0\": 50_000_000.0,\n            \"I\": np.array([200.0, 200.0, 200.0, 200.0]),\n            \"R_des\": np.array([50.0, 350.0, 50.0, 350.0]),\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        s_current = case[\"s0\"]\n        I_t = case[\"I\"]\n        R_des_t = case[\"R_des\"]\n        \n        R_prev = R_minus_1\n        storage_sequence = []\n        \n        # Flags for the entire horizon\n        env_met_horizon = True\n        spill_occurred_horizon = False\n        ramp_clipped_occurred_horizon = False\n\n        for t in range(T):\n            # Step 1: Determine Candidate Release\n            R_target = R_des_t[t]\n\n            # a. Ramp Rate Constraint\n            R_ramped = np.clip(R_target, R_prev - rho, R_prev + rho)\n            if R_ramped != R_target:\n                ramp_clipped_occurred_horizon = True\n\n            # b. Turbine and Environmental Constraints\n            R_cand = np.clip(R_ramped, R_env_min, R_turbine_max)\n\n            # Step 2: Calculate Tentative Next Storage\n            surface_area = A0 + alpha * s_current\n            evap_rate_volumetric = E * surface_area  # m^3/s\n            \n            s_next_tentative = s_current + (I_t[t] - R_cand - evap_rate_volumetric) * delta_t\n\n            # Step 3: Enforce Storage Bounds\n            R_final = 0.0\n            s_next = 0.0\n            \n            if s_next_tentative  S_max:\n                # Spillage condition\n                s_next = S_max\n                R_final = R_cand\n                spill_occurred_horizon = True\n            elif s_next_tentative  S_min:\n                # Curtailment condition\n                s_next = S_min\n                # Recalculate release to hit S_min exactly\n                R_req = I_t[t] - evap_rate_volumetric - (S_min - s_current) / delta_t\n                R_final = R_req\n            else:\n                # Normal condition\n                s_next = s_next_tentative\n                R_final = R_cand\n\n            # Check if environmental flow was met for this step\n            if R_final  R_env_min:\n                env_met_horizon = False\n\n            # Store result and update state for next iteration\n            storage_sequence.append(s_next)\n            s_current = s_next\n            R_prev = R_final\n\n        results.append([storage_sequence, env_met_horizon, spill_occurred_horizon, ramp_clipped_occurred_horizon])\n\n    # The custom string formatting is required to match the exact output spec.\n    results_str = [f\"[{item[0]}, {item[1]}, {item[2]}, {item[3]}]\" for item in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的水库入流充满不确定性，因此处理随机性是高级建模的关键。本练习将引导您进入现代水库建模的前沿，学习如何使用集合预报来表示和验证不确定性。 您将亲手计算如连续分级概率评分（CRPS）等专业指标，并利用集合预报进行风险评估，量化水库运行中违反最小蓄水量等风险的概率。",
            "id": "4118226",
            "problem": "考虑一个由随机入流补给的水库，该入流由一组轨迹集合表示。操作员根据涡轮机容量和蓄水上限约束进行泄放，并根据观测到的入流计算验证指标。从基本原理出发：水库蓄水量动态的质量守恒定律、累积分布函数的定义以及基础概率论。您需要实现对概率性入流集合和约束的验证，并为提供的测试套件返回定量指标。\n\n使用的基本原理和定义：\n- 质量守恒：对于每个时间步 $t$，蓄水量更新公式为\n$$\nS_{t+1} \\;=\\; S_t \\;+\\; \\Delta t\\cdot I_t \\;-\\; \\Delta t\\cdot R_t \\;-\\; E_t \\;-\\; \\text{Spill}_t,\n$$\n其中 $S_t$ 是蓄水量（单位 $\\mathrm{m}^3$），$I_t$ 是入流量（单位 $\\mathrm{m}^3/\\mathrm{s}$），$R_t$ 是出库流量（单位 $\\mathrm{m}^3/\\mathrm{s}$），$E_t$ 是该时间步内的蒸发损失量（单位 $\\mathrm{m}^3$），$\\text{Spill}_t \\ge 0$ 是弃水量（单位 $\\mathrm{m}^3$），$\\Delta t$ 是时间步长（单位 $\\mathrm{s}$）。涡轮机容量限制 $R_t \\le C_t$，蓄水量边界限制 $S_{\\min} \\le S_t \\le S_{\\max}$。\n- 累积分布函数：对于一个随机变量 $X$，其分布函数为 $F_X(x) = \\mathbb{P}(X \\le x)$，以及一个观测值 $y$，预测 $F_X$ 相对于 $y$ 的连续分级概率评分（CRPS）为\n$$\n\\text{CRPS}(F_X, y) \\;=\\; \\int_{-\\infty}^{+\\infty} \\bigl(F_X(z) - \\mathbb{1}\\{y \\le z\\}\\bigr)^2\\,\\mathrm{d}z,\n$$\n其中 $\\mathbb{1}\\{\\cdot\\}$ 是指示函数。对于离散集合，请实现此定义所隐含的相应经验计算。\n- 二元事件的Brier评分：对于事件 $A$（例如，入流量超过阈值），其预测概率为 $p$，观测结果为 $o \\in \\{0,1\\}$，Brier评分为\n$$\n\\text{BS} \\;=\\; (p - o)^2.\n$$\n\n需为每个测试案例实现的任务：\n1. 使用上述积分定义所隐含的经验离散集合公式，计算每个时间点 $t$ 的入流集合与该时间点观测入流之间的逐时间步CRPS，然后返回各时间步CRPS值的算术平均值，结果为一个浮点数。\n2. 对于“入流量超过阈值”这一二元事件，计算逐时间步Brier评分。预测概率取为超过阈值的集合成员比例，如果观测入流超过阈值，则观测结果为 $1$，否则为 $0$。返回各时间步Brier评分的算术平均值，结果为一个浮点数。\n3. 通过使用每个时间点 $t$ 的集合在 $(1-p_{\\mathrm{cov}})/2$ 和 $1-(1-p_{\\mathrm{cov}})/2$ 水平上的经验分位数，计算名义覆盖水平为 $p_{\\mathrm{cov}}$ 的中心预测区间的经验覆盖率，然后计算落入相应区间的观测入流的比例。返回一个布尔值，表示经验覆盖率与 $p_{\\mathrm{cov}}$ 的差距是否在指定的容差 $tol_{\\mathrm{cov}}$ 范围内。\n4. 在策略 $R_t = \\min\\{C_t, \\text{median}(\\text{时间 } t \\text{ 的入流集合})\\}$下，模拟所有集合轨迹的水库蓄水量。时间步长 $\\Delta t = 3600\\,\\mathrm{s}$，每个时间步的蒸发量为 $E_t$（单位 $\\mathrm{m}^3$），通过设置 $S_{t+1} = \\min\\{S_{\\max}, S_t + \\Delta t\\cdot I_t - \\Delta t\\cdot R_t - E_t\\}$ 来强制执行上限约束以产生弃水，并在 $S_{t+1}  S_{\\min}$ 时记录一次下限违规。返回在任何时间步发生下限违规的集合成员的经验概率（以小数形式）。\n\n物理单位和报告：\n- 入流量和出库流量单位为 $\\mathrm{m}^3/\\mathrm{s}$。\n- 蓄水量单位为 $\\mathrm{m}^3$。\n- 每个时间步的蒸发量单位为 $\\mathrm{m}^3$。\n- 所有测试案例均使用 $\\Delta t = 3600\\,\\mathrm{s}$。\n- 所有返回的数值指标均为无量纲浮点数；覆盖率以布尔值形式返回。\n- 不涉及角度单位。\n- 程序的最终输出必须是单行文本，包含一个由方括号括起来的逗号分隔列表，其中是每个测试案例的结果。每个测试案例的结果本身是一个列表，顺序为 $[\\text{mean\\_CRPS}, \\text{mean\\_Brier}, \\text{coverage\\_ok}, \\text{lower\\_bound\\_violation\\_probability}]$。\n\n测试套件：\n- 测试案例1（理想情况）：\n    - 集合大小 $K = 10$，时间步数 $T = 3$。\n    - 集合入流轨迹（每个列表为时间 $t=1,2,3$ 时的 $\\mathrm{m}^3/\\mathrm{s}$）：\n        - $[90, 100, 95]$\n        - $[92, 98, 96]$\n        - $[88, 97, 103]$\n        - $[105, 110, 102]$\n        - $[98, 101, 99]$\n        - $[93, 94, 97]$\n        - $[102, 108, 106]$\n        - $[97, 96, 100]$\n        - $[91, 99, 95]$\n        - $[100, 104, 101]$\n    - 观测入流：$[95, 102, 100]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 超阈值事件的阈值：$100$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 名义覆盖水平：$p_{\\mathrm{cov}} = 0.9$，容差 $tol_{\\mathrm{cov}} = 0.05$。\n    - 涡轮机容量 $C_t$：$[100, 100, 100]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 每个时间步的蒸发量 $E_t$：$[5000, 5000, 5000]$，单位 $\\mathrm{m}^3$。\n    - 蓄水量边界和初始蓄水量：$S_{\\min} = 2{,}000{,}000$ $\\mathrm{m}^3$，$S_{\\max} = 5{,}000{,}000$ $\\mathrm{m}^3$，$S_0 = 3{,}000{,}000$ $\\mathrm{m}^3$。\n- 测试案例2（高蒸发量下的下限风险）：\n    - 集合大小 $K = 8$，时间步数 $T = 4$。\n    - 集合入流轨迹：\n        - $[35, 34, 36, 33]$\n        - $[38, 39, 37, 35]$\n        - $[32, 31, 33, 30]$\n        - $[50, 45, 48, 47]$\n        - $[40, 42, 41, 43]$\n        - $[37, 36, 35, 34]$\n        - $[45, 44, 43, 42]$\n        - $[39, 38, 40, 37]$\n    - 观测入流：$[36, 38, 40, 35]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 超阈值事件的阈值：$42$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 名义覆盖水平：$p_{\\mathrm{cov}} = 0.9$，容差 $tol_{\\mathrm{cov}} = 0.05$。\n    - 涡轮机容量 $C_t$：$[150, 150, 150, 150]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 每个时间步的蒸发量 $E_t$：$[60000, 60000, 60000, 60000]$，单位 $\\mathrm{m}^3$。\n    - 蓄水量边界和初始蓄水量：$S_{\\min} = 2{,}000{,}000$ $\\mathrm{m}^3$，$S_{\\max} = 5{,}000{,}000$ $\\mathrm{m}^3$，$S_0 = 2{,}050{,}000$ $\\mathrm{m}^3$。\n- 测试案例3（确定性预测边缘案例）：\n    - 集合大小 $K = 1$，时间步数 $T = 2$。\n    - 集合入流轨迹：\n        - $[120, 80]$\n    - 观测入流：$[110, 90]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 超阈值事件的阈值：$100$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 名义覆盖水平：$p_{\\mathrm{cov}} = 0.8$，容差 $tol_{\\mathrm{cov}} = 0.10$。\n    - 涡轮机容量 $C_t$：$[90, 90]$，单位 $\\mathrm{m}^3/\\mathrm{s}$。\n    - 每个时间步的蒸发量 $E_t$：$[5000, 5000]$，单位 $\\mathrm{m}^3$。\n    - 蓄水量边界和初始蓄水量：$S_{\\min} = 1{,}000{,}000$ $\\mathrm{m}^3$，$S_{\\max} = 1{,}500{,}000$ $\\mathrm{m}^3$，$S_0 = 1{,}050{,}000$ $\\mathrm{m}^3$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例的结果列表，顺序为 $[\\text{mean\\_CRPS}, \\text{mean\\_Brier}, \\text{coverage\\_ok}, \\text{lower\\_bound\\_violation\\_probability}]$。例如，输出格式必须完全类似于 $[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],[r_{3,1},r_{3,2},r_{3,3},r_{3,4}]]$。",
            "solution": "该问题要求实现四个与水库入流预测和管理相关的不同验证与模拟任务。解决方案的设计思路是将每个任务实现为一个模块化函数，并严格遵守所提供的定义和原则。\n\n**1. 平均连续分级概率评分 (CRPS)**\n\n第一个任务是计算平均CRPS，这是一个评估概率性预测的指标。问题给出了对于连续预测分布 $F_X$ 和观测值 $y$ 的CRPS积分定义：\n$$\n\\text{CRPS}(F_X, y) \\;=\\; \\int_{-\\infty}^{+\\infty} \\bigl(F_X(z) - \\mathbb{1}\\{y \\le z\\}\\bigr)^2\\,\\mathrm{d}z\n$$\n对于一个离散集合预测 $\\{x_i\\}_{i=1}^K$，其经验累积分布函数为 $F_K(z) = \\frac{1}{K}\\sum_{i=1}^K \\mathbb{1}\\{x_i \\le z\\}$。虽然可以直接使用这个阶梯函数来解积分，但我们采用了一种计算上更方便且被广泛使用的公式，称为能量形式（energy form）。该公式将CRPS表示为预测成员与观测值之间绝对误差的期望值，减去任意两个预测成员之间绝对差期望值的一半：\n$$\n\\text{CRPS}(F_K, y) = \\mathbb{E}[|X - y|] - \\frac{1}{2}\\mathbb{E}[|X - X'|]\n$$\n其中 $X$ 和 $X'$ 是从预测分布 $F_K$ 中抽取的独立随机变量。对于给定的集合 $\\{x_i\\}_{i=1}^K$，这些期望值的经验估计为：\n$$\n\\mathbb{E}[|X - y|] \\approx \\frac{1}{K}\\sum_{i=1}^K |x_i - y|\n$$\n$$\n\\mathbb{E}[|X - X'|] \\approx \\frac{1}{K^2}\\sum_{i=1}^K \\sum_{j=1}^K |x_i - x_j|\n$$\n算法通过遍历从 $0$ 到 $T-1$ 的每个时间步 $t$ 来进行。在每个时间步，使用入流集合 $\\{I_{k,t}\\}_{k=1}^K$ 和相应的观测值 $I_{\\text{obs},t}$ 来计算该时间步的CRPS值。最终的指标是这些逐时间步CRPS值的算术平均值。\n\n**2. 平均Brier评分**\n\n第二个任务是计算一个二元事件的平均Brier评分。该事件被定义为入流量超过给定阈值。Brier评分由下式给出：\n$$\n\\text{BS} \\;=\\; (p - o)^2\n$$\n其中 $p$ 是事件的预测概率，$o \\in \\{0,1\\}$ 是观测到的二元结果。\n\n该算法同样遍历每个时间步 $t$。对于每个时间步：\n- 预测概率 $p_t$ 计算为入流量 $I_{k,t}$ 严格大于指定阈值的集合成员所占的比例。\n- 如果观测入流 $I_{\\text{obs},t}$ 严格大于阈值，则观测结果 $o_t$ 设为 $1$，否则设为 $0$。\n- 计算该时间步的Brier评分 $\\text{BS}_t = (p_t - o_t)^2$。\n\n最终的指标是所有时间步上这些评分的算术平均值。\n\n**3. 经验覆盖率验证**\n\n第三个任务是验证一个中心预测区间的经验覆盖率是否在其名义水平 $p_{\\mathrm{cov}}$ 的给定容差 $tol_{\\mathrm{cov}}$ 范围内。中心预测区间由入流集合在水平 $\\alpha_1 = (1 - p_{\\mathrm{cov}})/2$ 和 $\\alpha_2 = 1 - \\alpha_1 = (1 + p_{\\mathrm{cov}})/2$ 上的经验分位数定义。\n\n该算法包括以下步骤：\n- 对于每个时间步 $t$，分别计算区间下界 $q_{1,t}$ 和上界 $q_{2,t}$，它们是入流集合 $\\{I_{k,t}\\}_{k=1}^K$ 在水平 $\\alpha_1$ 和 $\\alpha_2$ 上的经验分位数。\n- 检查观测入流 $I_{\\text{obs},t}$ 是否落在此区间内，即 $q_{1,t} \\le I_{\\text{obs},t} \\le q_{2,t}$。\n- 统计观测值被覆盖的总时间步数 $T_{\\text{covered}}$。\n- 计算经验覆盖率 $p_{\\text{emp}} = T_{\\text{covered}} / T$。\n- 最后，算法返回一个布尔值，指示经验覆盖率与名义覆盖率之间的绝对差是否在容差范围内：$|p_{\\text{emp}} - p_{\\mathrm{cov}}| \\le tol_{\\mathrm{cov}}$。\n\n**4. 水库下限违规概率**\n\n第四个任务是通过模拟来估计违反最低蓄水位 $S_{\\min}$ 的概率。模拟对 $K$ 个集合入流轨迹中的每一个都运行一次。水库蓄水量 $S_t$ 根据质量守恒方程演变：\n$$\nS_{t+1}^{\\text{pre-spill}} \\;=\\; S_t \\;+\\; \\Delta t\\cdot I_t \\;-\\; \\Delta t\\cdot R_t \\;-\\; E_t\n$$\n出库策略给定为 $R_t = \\min\\{C_t, \\text{median}(\\text{时间 } t \\text{ 的入流集合})\\}$。一个关键点是，在任何时间步 $t$ 的出库流量 $R_t$ 对所有模拟运行都是恒定的，因为它取决于该时间步整个入流集合的中位数，而不是单个成员的入流量。\n\n模拟算法设计如下：\n- 首先，根据给定策略预先计算所有时间步 $t=0, ..., T-1$ 的出库流量序列 $R_t$。\n- 然后，对于 $K$ 个集合成员中的每一个：\n    - 在时间范围 $T$ 内进行模拟。蓄水量初始化为 $S_0$。\n    - 在每个时间步 $t$，使用该特定成员的入流量 $I_{k,t}$ 和预先计算的出库流量 $R_t$，计算考虑弃水之前的下一个蓄水状态 $S'_{k, t+1}$。\n    - 通过设置该时间步的最终蓄水量为 $S_{k,t+1} = \\min\\{S_{\\max}, S'_{k, t+1}\\}$ 来强制执行蓄水上限。\n    - 进行检查：如果在成员 $k$ 的模拟过程中任何时刻 $S_{k,t+1}  S_{\\min}$，则为该成员记录一次违规，并可提前停止对该成员的模拟。\n- 在模拟完所有 $K$ 个成员后，统计记录到违规的成员数量 $N_{\\text{violations}}$。\n- 最终结果是违规的经验概率，计算为 $N_{\\text{violations}} / K$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the required metrics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Test case 1 (happy path)\",\n            \"ensemble_inflow\": np.array([\n                [90, 100, 95], [92, 98, 96], [88, 97, 103], [105, 110, 102], [98, 101, 99],\n                [93, 94, 97], [102, 108, 106], [97, 96, 100], [91, 99, 95], [100, 104, 101]\n            ]),\n            \"observed_inflow\": np.array([95, 102, 100]),\n            \"threshold\": 100.0,\n            \"p_cov\": 0.9, \"tol_cov\": 0.05,\n            \"C_t\": np.array([100, 100, 100]),\n            \"E_t\": np.array([5000, 5000, 5000]),\n            \"S_min\": 2000000.0, \"S_max\": 5000000.0, \"S_0\": 3000000.0,\n            \"delta_t\": 3600.0\n        },\n        {\n            \"name\": \"Test case 2 (lower-bound risk under high evaporation)\",\n            \"ensemble_inflow\": np.array([\n                [35, 34, 36, 33], [38, 39, 37, 35], [32, 31, 33, 30], [50, 45, 48, 47],\n                [40, 42, 41, 43], [37, 36, 35, 34], [45, 44, 43, 42], [39, 38, 40, 37]\n            ]),\n            \"observed_inflow\": np.array([36, 38, 40, 35]),\n            \"threshold\": 42.0,\n            \"p_cov\": 0.9, \"tol_cov\": 0.05,\n            \"C_t\": np.array([150, 150, 150, 150]),\n            \"E_t\": np.array([60000, 60000, 60000, 60000]),\n            \"S_min\": 2000000.0, \"S_max\": 5000000.0, \"S_0\": 2050000.0,\n            \"delta_t\": 3600.0\n        },\n        {\n            \"name\": \"Test case 3 (deterministic forecast edge case)\",\n            \"ensemble_inflow\": np.array([[120, 80]]),\n            \"observed_inflow\": np.array([110, 90]),\n            \"threshold\": 100.0,\n            \"p_cov\": 0.8, \"tol_cov\": 0.10,\n            \"C_t\": np.array([90, 90]),\n            \"E_t\": np.array([5000, 5000]),\n            \"S_min\": 1000000.0, \"S_max\": 1500000.0, \"S_0\": 1050000.0,\n            \"delta_t\": 3600.0\n        }\n    ]\n\n    def _calculate_crps(ensemble_slice, observation):\n        \"\"\"Computes empirical CRPS for a single time step.\"\"\"\n        K = len(ensemble_slice)\n        term1 = np.mean(np.abs(ensemble_slice - observation))\n        \n        # Reshape for broadcasting\n        ens_col = ensemble_slice[:, np.newaxis]\n        ens_row = ensemble_slice[np.newaxis, :]\n        \n        term2 = 0.5 * np.mean(np.abs(ens_col - ens_row))\n        return term1 - term2\n\n    def _calculate_brier(ensemble_slice, observation, threshold):\n        \"\"\"Computes Brier score for a single time step.\"\"\"\n        p_forecast = np.mean(ensemble_slice > threshold)\n        o_observed = 1 if observation > threshold else 0\n        return (p_forecast - o_observed)**2\n\n    def process_case(case):\n        \"\"\"Processes a single test case and returns the four metrics.\"\"\"\n        I_ens = case[\"ensemble_inflow\"]\n        I_obs = case[\"observed_inflow\"]\n        threshold = case[\"threshold\"]\n        p_cov, tol_cov = case[\"p_cov\"], case[\"tol_cov\"]\n        C_t, E_t = case[\"C_t\"], case[\"E_t\"]\n        S_min, S_max, S_0 = case[\"S_min\"], case[\"S_max\"], case[\"S_0\"]\n        delta_t = case[\"delta_t\"]\n\n        K, T = I_ens.shape\n\n        # Task 1: Mean CRPS\n        crps_values = [_calculate_crps(I_ens[:, t], I_obs[t]) for t in range(T)]\n        mean_crps = np.mean(crps_values)\n\n        # Task 2: Mean Brier Score\n        brier_scores = [_calculate_brier(I_ens[:, t], I_obs[t], threshold) for t in range(T)]\n        mean_brier = np.mean(brier_scores)\n        \n        # Task 3: Coverage Check\n        alpha1 = (1.0 - p_cov) / 2.0\n        alpha2 = 1.0 - alpha1\n        \n        covered_count = 0\n        for t in range(T):\n            q1 = np.quantile(I_ens[:, t], alpha1)\n            q2 = np.quantile(I_ens[:, t], alpha2)\n            if q1 = I_obs[t] = q2:\n                covered_count += 1\n        \n        p_emp = covered_count / T\n        coverage_ok = np.abs(p_emp - p_cov) = tol_cov\n\n        # Task 4: Lower-bound violation probability\n        # Pre-calculate releases, constant for all members at each time step\n        R_t = np.array([min(C_t[t], np.median(I_ens[:, t])) for t in range(T)])\n        \n        violations = 0\n        for k in range(K):\n            S_current = S_0\n            violation_found = False\n            for t in range(T):\n                inflow_vol = I_ens[k, t] * delta_t\n                release_vol = R_t[t] * delta_t\n                evap_vol = E_t[t]\n                \n                S_next_pre_spill = S_current + inflow_vol - release_vol - evap_vol\n                S_next = min(S_max, S_next_pre_spill)\n                \n                if S_next  S_min:\n                    violation_found = True\n                    break\n                S_current = S_next\n            \n            if violation_found:\n                violations += 1\n        \n        violation_prob = violations / K\n        \n        return [mean_crps, mean_brier, coverage_ok, violation_prob]\n\n    results = [process_case(case) for case in test_cases]\n    \n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}