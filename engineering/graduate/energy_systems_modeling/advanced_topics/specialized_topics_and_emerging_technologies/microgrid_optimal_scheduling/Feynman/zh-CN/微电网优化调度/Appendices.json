{
    "hands_on_practices": [
        {
            "introduction": "利用储能进行能量套利是微电网最核心的经济应用之一。此练习旨在帮助你将一个动态优化问题转化为标准的数学模型，特别是线性规划模型。通过此练习 ，你将学习如何把电池的物理约束（如能量守恒、充放电效率、功率与容量限制）精确地表达为数学方程和不等式，从而在确定的市场价格下找到最大化收益的调度策略。掌握这种建模能力是成为一名优秀的能源系统分析师所需具备的基本功。",
            "id": "4103641",
            "problem": "考虑一个配备单个电化学电池的微电网的三个周期的能量套利问题。在每个周期，电池与外部市场进行交互，购买能量进行充电，并在放电时出售能量。假设时间是离散的，每个周期的固定时间步长为一小时，因此在一个周期内，能量和功率在数值上是相等的。使用以下物理建模原则和核心定义：\n\n- 每个周期的能量守恒，通过荷电状态递归关系表示，该关系由考虑了转换损耗的能量守恒定律推导得出。设周期 $t$ 的充电功率为 $c_t \\ge 0$，放电功率为 $d_t \\ge 0$。设周期末的荷电状态为 $E_t$。假设存在一个单一的往返效率参数 $0  \\eta \\le 1$，它被分解为对称的充电效率和放电效率，即 $\\eta_c = \\sqrt{\\eta}$ 和 $\\eta_d = \\sqrt{\\eta}$，因此往返效率为 $\\eta_c \\eta_d = \\eta$。荷电状态的更新遵循以下公式\n$$\nE_t = E_{t-1} + \\eta_c \\, c_t - \\frac{1}{\\eta_d} \\, d_t,\n$$\n其中 $t \\in \\{1,2,3\\}$，初始荷电状态 $E_0$ 为给定值。\n- 边界约束源于物理限制：\n  - 能量边界 $E_{\\min} \\le E_t \\le E_{\\max}$，其中 $t \\in \\{1,2,3\\}$。\n  - 每个周期 $t$ 的充电功率边界 $0 \\le c_t \\le P_{\\max}^{\\mathrm{ch}}$ 和放电功率边界 $0 \\le d_t \\le P_{\\max}^{\\mathrm{dis}}$。\n- 市场交易的价格为每千瓦时 $p_t$ 美元，其中 $t \\in \\{1,2,3\\}$。购买 $c_t$ 的能量会产生 $p_t c_t$ 的成本，而出售 $d_t$ 的能量会获得 $p_t d_t$ 的收入。\n- 为防止剩余能量产生人为价值，施加一个终端约束 $E_3 = E_{\\mathrm{final}}$，其中 $E_{\\mathrm{final}}$ 是指定的。所有能量单位为千瓦时 (kWh)，所有功率单位为千瓦 (kW)，所有价格单位为美元/千瓦时。\n\n从这些原则出发，将微电网电池套利问题建模为一个线性优化问题并进行求解，其目标是在满足能量守恒、边界约束和终端约束的条件下，最大化三个周期内的总利润。对于每个测试用例，你的程序必须计算最优的充/放电量 $(c_1,c_2,c_3)$ 和 $(d_1,d_2,d_3)$ 以及由此产生的总利润。所有测试用例都必须满足能量平衡、边界一致性和目标函数。\n\n将所有充放电值以千瓦时 (kWh) 表示，总利润以美元表示，均四舍五入到三位小数。最终的程序输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身也是一个由方括号括起来的、包含七个十进制数的逗号分隔列表：\n$$\n[c_1,c_2,c_3,d_1,d_2,d_3,\\text{利润}].\n$$\n\n使用以下测试套件。对于每个测试用例，参数为 $(p_1,p_2,p_3)$、$\\eta$、$E_0$、$E_{\\mathrm{final}}$、$E_{\\min}$、$E_{\\max}$、$P_{\\max}^{\\mathrm{ch}}$、$P_{\\max}^{\\mathrm{dis}}$：\n\n- 测试用例1（价格先谷后峰的典型套利）：\n  - 价格：$(p_1,p_2,p_3) = (0.03, 0.01, 0.08)$ 每 kWh。\n  - 效率：$\\eta = 0.9$。\n  - 初始状态：$E_0 = 5$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 5$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 10$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 5$ kW, $P_{\\max}^{\\mathrm{dis}} = 5$ kW。\n- 测试用例2（电池满电且价格单调下降）：\n  - 价格：$(p_1,p_2,p_3) = (0.07, 0.05, 0.04)$ 每 kWh。\n  - 效率：$\\eta = 0.88$。\n  - 初始状态：$E_0 = 8$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 8$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 8$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 10$ kW, $P_{\\max}^{\\mathrm{dis}} = 10$ kW。\n- 测试用例3（价格持平，因损耗无盈利循环）：\n  - 价格：$(p_1,p_2,p_3) = (0.05, 0.05, 0.05)$ 每 kWh。\n  - 效率：$\\eta = 0.95$。\n  - 初始状态：$E_0 = 5$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 5$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 10$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 5$ kW, $P_{\\max}^{\\mathrm{dis}} = 5$ kW。\n- 测试用例4（放电功率受限且往返效率低）：\n  - 价格：$(p_1,p_2,p_3) = (0.04, 0.10, 0.06)$ 每 kWh。\n  - 效率：$\\eta = 0.6$。\n  - 初始状态：$E_0 = 2$ kWh。\n  - 终端状态：$E_{\\mathrm{final}} = 2$ kWh。\n  - 能量边界：$E_{\\min} = 0$ kWh, $E_{\\max} = 6$ kWh。\n  - 功率边界：$P_{\\max}^{\\mathrm{ch}} = 2$ kW, $P_{\\max}^{\\mathrm{dis}} = 1.5$ kW。\n\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果是一个包含七个十进制数的带括号列表，顺序为 $[c_1,c_2,c_3,d_1,d_2,d_3,\\text{利润}]$，四舍五入到三位小数，例如：\n$$\n[[0.000,0.000,0.000,0.000,0.000,0.000,0.000],[\\dots],\\dots].\n$$",
            "solution": "所提出的问题是确定一个微电网中的电池在三个周期的时间范围内的最优能量套利策略。这需要建立并求解一个数学优化问题，以在系统的物理和操作约束下最大化利润。该问题陈述具有科学依据、内容自洽且提法适定，因此适合进行形式化求解。\n\n解决方案的核心在于将问题表述为一个线性规划 (Linear Program, LP)。一个LP问题包含一个待优化的目标函数和一组约束条件，其中目标函数和约束条件都是决策变量的线性函数。\n\n首先，我们定义决策变量。对于每个时间周期 $t \\in \\{1, 2, 3\\}$，电池可以充电或放电。设 $c_t$ 为周期 $t$ 内充入的能量， $d_t$ 为周期 $t$ 内放出的能量。由于时间步长为1小时，功率（单位kW）在数值上等于能量（单位kWh）。整个时间范围内的决策变量被收集到一个向量 $x$ 中：\n$$\nx = [c_1, c_2, c_3, d_1, d_2, d_3]^T\n$$\n这些变量是非负的，即 $c_t \\ge 0$ 且 $d_t \\ge 0$。\n\n接下来，我们建立目标函数。目标是最大化总利润，即出售能量的总收入减去购买能量的总成本。设市场价格为 $p_t$，则利润 $\\Pi$ 为：\n$$\n\\text{maximize} \\quad \\Pi = \\sum_{t=1}^{3} (p_t d_t - p_t c_t)\n$$\n标准的LP求解器执行最小化操作。最大化 $\\Pi$ 等价于最小化 $-\\Pi$。因此，需要最小化的目标函数是：\n$$\n\\text{minimize} \\quad \\sum_{t=1}^{3} (p_t c_t - p_t d_t)\n$$\n这可以写成矩阵形式 $c_{obj}^T x$，其中成本向量 $c_{obj}$ 为：\n$$\nc_{obj} = [p_1, p_2, p_3, -p_1, -p_2, -p_3]^T\n$$\n\n该系统受几个约束条件制约。\n\n1.  **荷电状态 (SOC) 动态：** 电池在周期 $t$ 结束时存储的能量 $E_t$ 根据能量守恒定律演变，同时考虑了效率损失。给定的状态方程为：\n    $$\n    E_t = E_{t-1} + \\eta_c c_t - \\frac{1}{\\eta_d} d_t\n    $$\n    其中 $\\eta_c = \\sqrt{\\eta}$ 和 $\\eta_d = \\sqrt{\\eta}$ 分别是充电和放电效率。我们可以将 $t \\in \\{1, 2, 3\\}$ 时的 $E_t$ 表示为初始状态 $E_0$ 和决策变量的函数：\n    $$\n    E_1 = E_0 + \\eta_c c_1 - \\frac{1}{\\eta_d} d_1\n    $$\n    $$\n    E_2 = E_1 + \\eta_c c_2 - \\frac{1}{\\eta_d} d_2 = E_0 + \\eta_c(c_1 + c_2) - \\frac{1}{\\eta_d}(d_1 + d_2)\n    $$\n    $$\n    E_3 = E_2 + \\eta_c c_3 - \\frac{1}{\\eta_d} d_3 = E_0 + \\eta_c(c_1 + c_2 + c_3) - \\frac{1}{\\eta_d}(d_1 + d_2 + d_3)\n    $$\n\n2.  **能量边界：** 存储的能量必须始终保持在物理限制范围内：\n    $$\n    E_{\\min} \\le E_t \\le E_{\\max} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    这些不等式应用于 $E_1$ 和 $E_2$ 的表达式。对于 $E_3$，给出了一个更具体的约束。这些约束在决策变量上是线性的。对于 $t=1$：\n    $$\n    \\eta_c c_1 - \\frac{1}{\\eta_d} d_1 \\le E_{\\max} - E_0\n    $$\n    $$\n    -\\eta_c c_1 + \\frac{1}{\\eta_d} d_1 \\le E_0 - E_{\\min}\n    $$\n    对于 $t=2$ 也类似：\n    $$\n    \\eta_c(c_1 + c_2) - \\frac{1}{\\eta_d}(d_1 + d_2) \\le E_{\\max} - E_0\n    $$\n    $$\n    -\\eta_c(c_1 + c_2) + \\frac{1}{\\eta_d}(d_1 + d_2) \\le E_0 - E_{\\min}\n    $$\n\n3.  **终端状态约束：** 施加一个终端约束以确保最终荷电状态为一个指定值 $E_{\\mathrm{final}}$：\n    $$\n    E_3 = E_{\\mathrm{final}}\n    $$\n    代入 $E_3$ 的表达式：\n    $$\n    E_0 + \\eta_c \\sum_{t=1}^{3} c_t - \\frac{1}{\\eta_d} \\sum_{t=1}^{3} d_t = E_{\\mathrm{final}}\n    $$\n    这可以重排为一个线性等式约束：\n    $$\n    \\eta_c \\sum_{t=1}^{3} c_t - \\frac{1}{\\eta_d} \\sum_{t=1}^{3} d_t = E_{\\mathrm{final}} - E_0\n    $$\n\n4.  **功率边界：** 充放电速率受到电池功率容量的限制：\n    $$\n    0 \\le c_t \\le P_{\\max}^{\\mathrm{ch}} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    $$\n    0 \\le d_t \\le P_{\\max}^{\\mathrm{dis}} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    这些是对决策变量的简单框式约束。\n\n问题建模不需要一个显式约束来防止同时充电和放电（即 $c_t d_t = 0$）。任何在某个周期 $t$ 中 $c_t > 0$ 且 $d_t > 0$ 的可行解都是次优的。由于存在往返效率损失 $(\\eta = \\eta_c \\eta_d  1)$，人们可以通过以某种方式少量减少 $c_t$ 和 $d_t$ 来保持净能量变化不变，但降低成本。因此，LP求解器会自然地将每个周期中这两个变量之一驱动为0。\n\n完整的问题通过使用标准LP求解器来解决。我们为标准LP形式构建矩阵和向量：最小化 $c_{obj}^T x$，约束条件为 $A_{eq} x = b_{eq}$，$A_{ub} x \\le b_{ub}$，以及对 $x$ 的逐元素边界。\n\n对于给定的参数集 $(p_1, p_2, p_3), \\eta, E_0, E_{\\mathrm{final}}, E_{\\min}, E_{\\max}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{dis}}$：\n\n- **等式约束：** $A_{eq}$ 是一个 $1 \\times 6$ 的矩阵， $b_{eq}$ 是一个标量。\n  $$\n  A_{eq} = [\\eta_c, \\eta_c, \\eta_c, -1/\\eta_d, -1/\\eta_d, -1/\\eta_d]\n  $$\n  $$\n  b_{eq} = [E_{\\mathrm{final}} - E_0]\n  $$\n\n- **不等式约束：** $A_{ub}$ 是一个 $4 \\times 6$ 的矩阵， $b_{ub}$ 是一个 $4 \\times 1$ 的向量。\n  $$\n  A_{ub} = \\begin{pmatrix}\n  \\eta_c   0   0   -1/\\eta_d   0   0 \\\\\n  -\\eta_c  0   0   1/\\eta_d   0   0 \\\\\n  \\eta_c   \\eta_c   0   -1/\\eta_d   -1/\\eta_d   0 \\\\\n  -\\eta_c  -\\eta_c  0   1/\\eta_d   1/\\eta_d   0\n  \\end{pmatrix}\n  $$\n  $$\n  b_{ub} = [E_{\\max} - E_0, E_0 - E_{\\min}, E_{\\max} - E_0, E_0 - E_{\\min}]^T\n  $$\n\n- **边界：** 下界均为 $0$。上界为：\n  $$\n  [P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{dis}}, P_{\\max}^{\\mathrm{dis}}, P_{\\max}^{\\mathrm{dis}}]^T\n  $$\n\nPython实现将为每个测试用例构建这些矩阵和向量，并将它们传递给 `scipy.optimize.linprog` 函数以找到最优的充/放电计划 $x^*$ 和相应的最小成本。最大利润是最小成本的相反数。然后按指定格式化最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the microgrid battery arbitrage problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: (p1,p2,p3), eta, E0, E_final, Emin, Emax, Pch_max, Pdis_max\n        ((0.03, 0.01, 0.08), 0.9, 5, 5, 0, 10, 5, 5),\n        # Test case 2\n        ((0.07, 0.05, 0.04), 0.88, 8, 8, 0, 8, 10, 10),\n        # Test case 3\n        ((0.05, 0.05, 0.05), 0.95, 5, 5, 0, 10, 5, 5),\n        # Test case 4\n        ((0.04, 0.10, 0.06), 0.6, 2, 2, 0, 6, 2, 1.5)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(*case)\n        results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join([f\"{val:.3f}\" for val in res]) + \"]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\ndef solve_one_case(prices, eta, E0, E_final, E_min, E_max, P_max_ch, P_max_dis):\n    \"\"\"\n    Formulates and solves the linear program for a single test case.\n    \n    The decision variable vector is x = [c1, c2, c3, d1, d2, d3].\n    \"\"\"\n    p1, p2, p3 = prices\n    \n    # Efficiencies\n    eta_c = np.sqrt(eta)\n    eta_d = np.sqrt(eta)\n\n    # Objective function: minimize (p*c - p*d)\n    c_obj = np.array([p1, p2, p3, -p1, -p2, -p3])\n\n    # --- Constraints ---\n    \n    # 1. Equality constraint: E3 = E_final\n    # E0 + eta_c*(c1+c2+c3) - (1/eta_d)*(d1+d2+d3) = E_final\n    # eta_c*(c1+c2+c3) - (1/eta_d)*(d1+d2+d3) = E_final - E0\n    A_eq = np.array([[eta_c, eta_c, eta_c, -1/eta_d, -1/eta_d, -1/eta_d]])\n    b_eq = np.array([E_final - E0])\n    \n    # 2. Inequality constraints: E_min = E_t = E_max for t=1, 2\n    # E1 = E_max => E0 + eta_c*c1 - (1/eta_d)*d1 = E_max => eta_c*c1 - (1/eta_d)*d1 = E_max - E0\n    # E1 >= E_min => E0 + eta_c*c1 - (1/eta_d)*d1 >= E_min => -eta_c*c1 + (1/eta_d)*d1 = E0 - E_min\n    # E2 = E_max => E0 + eta_c*(c1+c2) - (1/eta_d)*(d1+d2) = E_max => eta_c*(c1+c2) - (1/eta_d)*(d1+d2) = E_max - E0\n    # E2 >= E_min => E0 + eta_c*(c1+c2) - (1/eta_d)*(d1+d2) >= E_min => -eta_c*(c1+c2) + (1/eta_d)*(d1+d2) = E0 - E_min\n    A_ub = np.array([\n        [eta_c, 0, 0, -1/eta_d, 0, 0],\n        [-eta_c, 0, 0, 1/eta_d, 0, 0],\n        [eta_c, eta_c, 0, -1/eta_d, -1/eta_d, 0],\n        [-eta_c, -eta_c, 0, 1/eta_d, 1/eta_d, 0]\n    ])\n    b_ub = np.array([\n        E_max - E0,\n        E0 - E_min,\n        E_max - E0,\n        E0 - E_min\n    ])\n    \n    # 3. Bounds on variables: 0 = c_t = P_max_ch, 0 = d_t = P_max_dis\n    bounds = (\n        [(0, P_max_ch), (0, P_max_ch), (0, P_max_ch)] +\n        [(0, P_max_dis), (0, P_max_dis), (0, P_max_dis)]\n    )\n\n    # Solve the Linear Program\n    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if res.success:\n        # Clean up near-zero values from solver precision\n        solution = np.maximum(0, res.x)\n        c1, c2, c3 = solution[0:3]\n        d1, d2, d3 = solution[3:6]\n        # Profit is the negative of the minimized objective function value\n        profit = -res.fun\n        return [c1, c2, c3, d1, d2, d3, profit]\n    else:\n        # Should not happen for this well-posed problem, but handle defensively.\n        return [0.0] * 7\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "真实的微电网运营充满了不确定性，例如可再生能源发电量的波动或负荷的随机变化。在一个确定性模型中简单地使用预测的平均值，往往会导致次优甚至代价高昂的决策。这个练习  引入了随机规划中的两个核心概念：随机解的价值（Value of the Stochastic Solution, VSS）和完美信息期望价值（Expected Value of Perfect Information, EVPI）。通过亲手计算这些指标，你将学会如何量化评估采用复杂随机模型的经济效益，并理解更准确的预测所能带来的价值理论上限。",
            "id": "4103650",
            "problem": "考虑一个两阶段、风险中性的微电网优化调度问题，其中不确定的可再生能源发电由一个随机变量 $\\xi$ 表示，该变量取有限个情景 $\\{\\xi_i\\}_{i=1}^S$，其概率为 $p_i$，满足 $\\sum_{i=1}^S p_i = 1$ 且对所有 $i$ 都有 $p_i \\geq 0$。第一阶段（日前）决策 $x$ 在随机变量 $\\xi$ 的实现被观测到之前做出，而第二阶段（实时）追索决策 $y(\\xi)$ 则在观测到具体情景后做出。总成本是第一阶段成本与依赖于情景的追索成本之和，在风险中性的假设下通过数学期望进行建模。使用的基本原则是：期望的定义，以及在成本最小化问题中，拥有更多信息进行优化不会使最优期望结果变差的原则。\n\n从第一性原理出发，定义以下问题结构：\n- 追索问题 (RP)：选择第一阶段决策 $x^{\\mathrm{RP}}$ 以最小化期望总成本 $\\mathbb{E}[C_1(x) + Q(x,\\xi)]$，其中 $C_1(x)$ 是第一阶段成本，$Q(x,\\xi)$ 是在情景 $\\xi$ 下的最优追索成本。其最优期望目标值记为 $Z^{\\mathrm{RP}}$。\n- 期望值 (EV) 问题：用随机变量 $\\xi$ 的期望值替代它，并进行确定性优化以获得 $x^{\\mathrm{EV}}$。期望评估 (EEV) 是在原始随机环境中执行 $x^{\\mathrm{EV}}$ 决策，并在每个情景中采取最优追索策略时所产生的期望总成本，记为 $Z^{\\mathrm{EEV}}$。\n- 等待观望 (WS) 结构：假设拥有完美信息；对每个情景 $i$，选择针对该情景的第一阶段和追索决策以最小化该情景的总成本，得到情景总成本 $Z^{\\mathrm{WS}}(\\xi_i)$。完美信息下的期望总成本为 $Z^{\\mathrm{WS}} = \\sum_{i=1}^S p_i Z^{\\mathrm{WS}}(\\xi_i)$。\n\n在成本最小化下，这些结构满足 $Z^{\\mathrm{WS}} \\leq Z^{\\mathrm{RP}} \\leq Z^{\\mathrm{EEV}}$，这是因为 WS 相对于 RP 具有信息优势，并且在不确定性下进行评估时，固定 EV 决策相对于 RP 决策是次优的。\n\n对于每个测试用例，给定以下数据：情景概率 $p_i$、期望值决策的标量第一阶段成本 $C_1^{\\mathrm{EV}}$、在决策 $x^{\\mathrm{EV}}$ 下通过最优求解每个情景的第二阶段问题而计算出的一系列情景追索成本 $Q^{\\mathrm{EV}}(\\xi_i)$、追索问题决策的标量第一阶段成本 $C_1^{\\mathrm{RP}}$、在决策 $x^{\\mathrm{RP}}$ 下计算出的一系列情景追索成本 $Q^{\\mathrm{RP}}(\\xi_i)$，以及在完美信息下的一系列情景总成本 $Z^{\\mathrm{WS}}(\\xi_i)$。\n\n根据这些量，计算：\n- 随机解的价值 (VSS)，定义为通过追索问题相对于期望值决策的期望评估所实现的期望总成本的改善，表示为期望成本的差值。\n- 完美信息的期望价值 (EVPI)，定义为完美信息相对于追索问题所能带来的期望总成本的改善，表示为期望成本的差值。\n\n使用以下测试套件。所有成本均以美元 (USD) 表示。您的程序必须以美元为单位计算所需的指标，并将每个报告的指标四舍五入到小数点后两位。\n\n测试用例 1：\n- 情景概率 $p = [0.2, 0.5, 0.3]$。\n- 期望值第一阶段成本 $C_1^{\\mathrm{EV}} = 500$。\n- 期望值情景追索成本 $Q^{\\mathrm{EV}}(\\xi) = [3000, 2200, 1500]$。\n- 追索问题第一阶段成本 $C_1^{\\mathrm{RP}} = 600$。\n- 追索问题情景追索成本 $Q^{\\mathrm{RP}}(\\xi) = [2800, 2100, 1400]$。\n- 等待观望情景总成本 $Z^{\\mathrm{WS}}(\\xi) = [2500, 2000, 1300]$。\n\n测试用例 2（零不确定性）：\n- 情景概率 $p = [0.4, 0.6]$。\n- 期望值第一阶段成本 $C_1^{\\mathrm{EV}} = 200$。\n- 期望值情景追索成本 $Q^{\\mathrm{EV}}(\\xi) = [1000, 1000]$。\n- 追索问题第一阶段成本 $C_1^{\\mathrm{RP}} = 200$。\n- 追索问题情景追索成本 $Q^{\\mathrm{RP}}(\\xi) = [1000, 1000]$。\n- 等待观望情景总成本 $Z^{\\mathrm{WS}}(\\xi) = [1200, 1200]$。\n\n测试用例 3（罕见的极端情景）：\n- 情景概率 $p = [0.01, 0.49, 0.5]$。\n- 期望值第一阶段成本 $C_1^{\\mathrm{EV}} = 400$。\n- 期望值情景追索成本 $Q^{\\mathrm{EV}}(\\xi) = [6000, 1800, 1600]$。\n- 追索问题第一阶段成本 $C_1^{\\mathrm{RP}} = 450$。\n- 追索问题情景追索成本 $Q^{\\mathrm{RP}}(\\xi) = [5800, 1700, 1500]$。\n- 等待观望情景总成本 $Z^{\\mathrm{WS}}(\\xi) = [5700, 1650, 1450]$。\n\n测试用例 4：\n- 情景概率 $p = [0.25, 0.25, 0.25, 0.25]$。\n- 期望值第一阶段成本 $C_1^{\\mathrm{EV}} = 800$。\n- 期望值情景追索成本 $Q^{\\mathrm{EV}}(\\xi) = [2400, 2000, 1600, 1200]$。\n- 追索问题第一阶段成本 $C_1^{\\mathrm{RP}} = 820$。\n- 追索问题情景追索成本 $Q^{\\mathrm{RP}}(\\xi) = [2300, 1950, 1550, 1150]$。\n- 等待观望情景总成本 $Z^{\\mathrm{WS}}(\\xi) = [2200, 1900, 1500, 1100]$。\n\n测试用例 5（存在零概率情景）：\n- 情景概率 $p = [0.0, 0.7, 0.3]$。\n- 期望值第一阶段成本 $C_1^{\\mathrm{EV}} = 300$。\n- 期望值情景追索成本 $Q^{\\mathrm{EV}}(\\xi) = [2000, 1500, 1000]$。\n- 追索问题第一阶段成本 $C_1^{\\mathrm{RP}} = 320$。\n- 追索问题情景追索成本 $Q^{\\mathrm{RP}}(\\xi) = [1900, 1400, 900]$。\n- 等待观望情景总成本 $Z^{\\mathrm{WS}}(\\xi) = [1850, 1350, 850]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个测试用例的结果是一个包含两个元素的列表 $[ \\mathrm{VSS}, \\mathrm{EVPI} ]$，以美元为单位，并四舍五入到两位小数。例如，输出格式应类似于 $[[v_1,e_1],[v_2,e_2],\\dots]$，与上述测试用例的顺序相匹配。",
            "solution": "该问题被验证为是合理的、适定的，并与两阶段随机规划的基本原则一致。所有测试用例提供的数据均满足经典不等式 $Z^{\\mathrm{WS}} \\leq Z^{\\mathrm{RP}} \\leq Z^{\\mathrm{EEV}}$，这对于在信息不确定性水平递增的情况下，一个具有物理意义的成本最小化问题而言，是一个必要条件。\n\n任务是为一系列测试用例计算随机解的价值 ($VSS$) 和完美信息的期望价值 ($EVPI$)。这些指标分别对于量化使用随机模型相对于确定性模型的价值，以及获取完美信息的潜在收益至关重要。\n\n我们首先正式定义必要的量。设离散情景集由 $i \\in \\{1, \\dots, S\\}$ 索引，每个情景 $\\xi_i$ 发生的概率为 $p_i$。对于每个测试用例，我们获得了以下值：\n- 情景概率，$p = [p_1, \\dots, p_S]$。\n- 期望值 (EV) 解的第一阶段成本，$C_1^{\\mathrm{EV}} = C_1(x^{\\mathrm{EV}})$。\n- EV 解的依赖于情景的第二阶段追索成本，$Q^{\\mathrm{EV}}(\\xi) = [Q(x^{\\mathrm{EV}}, \\xi_1), \\dots, Q(x^{\\mathrm{EV}}, \\xi_S)]$。\n- 追索问题 (RP) 解的第一阶段成本，$C_1^{\\mathrm{RP}} = C_1(x^{\\mathrm{RP}})$。\n- RP 解的依赖于情景的第二阶段追索成本，$Q^{\\mathrm{RP}}(\\xi) = [Q(x^{\\mathrm{RP}}, \\xi_1), \\dots, Q(x^{\\mathrm{RP}}, \\xi_S)]$。\n- 完美信息（等待观望, WS）下的总情景成本，$Z^{\\mathrm{WS}}(\\xi) = [Z^{\\mathrm{WS}}(\\xi_1), \\dots, Z^{\\mathrm{WS}}(\\xi_S)]$。\n\n根据这些输入，我们首先计算三种建模范式中每一种的期望总成本。\n\n1. EV 解的期望评估 ($Z^{\\mathrm{EEV}}$) 是将决策 $x^{\\mathrm{EV}}$（该决策源自一个使用随机变量均值的确定性模型）应用于真实的随机环境时所产生的期望总成本。它是第一阶段成本与期望追索成本之和：\n$$Z^{\\mathrm{EEV}} = C_1^{\\mathrm{EV}} + \\mathbb{E}[Q(x^{\\mathrm{EV}},\\xi)] = C_1^{\\mathrm{EV}} + \\sum_{i=1}^{S} p_i Q(x^{\\mathrm{EV}}, \\xi_i)$$\n\n2. 追索问题 ($Z^{\\mathrm{RP}}$) 的最优期望成本是通过求解完整的两阶段随机问题可实现的最小期望总成本。对于给定的不确定性模型，此解 $x^{\\mathrm{RP}}$ 在设计上就是最优的。其成本为：\n$$Z^{\\mathrm{RP}} = C_1^{\\mathrm{RP}} + \\mathbb{E}[Q(x^{\\mathrm{RP}},\\xi)] = C_1^{\\mathrm{RP}} + \\sum_{i=1}^{S} p_i Q(x^{\\mathrm{RP}}, \\xi_i)$$\n\n3. 等待观望解 ($Z^{\\mathrm{WS}}$) 的期望成本是期望成本的理论下界，对应于拥有完美预见能力。它是对各情景最优成本的期望：\n$$Z^{\\mathrm{WS}} = \\mathbb{E}[Z^{\\mathrm{WS}}(\\xi)] = \\sum_{i=1}^{S} p_i Z^{\\mathrm{WS}}(\\xi_i)$$\n\n在确定了这些期望成本后，$VSS$ 和 $EVPI$ 的定义如下：\n\n随机解的价值 ($VSS$) 代表了使用随机解 ($x^{\\mathrm{RP}}$) 相对于确定性解 ($x^{\\mathrm{EV}}$) 所节省的成本。它是它们各自期望总成本之间的差值：\n$$VSS = Z^{\\mathrm{EEV}} - Z^{\\mathrm{RP}}$$\n\n完美信息的期望价值 ($EVPI$) 是指如果能够提前知道随机变量的结果所能获得的期望性能增益。它是不确定性下的最优成本与具有完美预见能力的理论成本之间的差值：\n$$EVPI = Z^{\\mathrm{RP}} - Z^{\\mathrm{WS}}$$\n\n现在我们将这些公式应用于每个测试用例。所有货币价值均以美元 (USD) 为单位。\n\n**测试用例 1**\n已知：$p = [0.2, 0.5, 0.3]$，$C_1^{\\mathrm{EV}} = 500$，$Q^{\\mathrm{EV}}(\\xi) = [3000, 2200, 1500]$，$C_1^{\\mathrm{RP}} = 600$，$Q^{\\mathrm{RP}}(\\xi) = [2800, 2100, 1400]$，$Z^{\\mathrm{WS}}(\\xi) = [2500, 2000, 1300]$。\n$Z^{\\mathrm{EEV}} = 500 + (0.2)(3000) + (0.5)(2200) + (0.3)(1500) = 500 + 600 + 1100 + 450 = 2650$。\n$Z^{\\mathrm{RP}} = 600 + (0.2)(2800) + (0.5)(2100) + (0.3)(1400) = 600 + 560 + 1050 + 420 = 2630$。\n$Z^{\\mathrm{WS}} = (0.2)(2500) + (0.5)(2000) + (0.3)(1300) = 500 + 1000 + 390 = 1890$。\n$VSS = 2650 - 2630 = 20$。\n$EVPI = 2630 - 1890 = 740$。\n结果：$[20.00, 740.00]$。\n\n**测试用例 2（零不确定性）**\n已知：$p = [0.4, 0.6]$，$C_1^{\\mathrm{EV}} = 200$，$Q^{\\mathrm{EV}}(\\xi) = [1000, 1000]$，$C_1^{\\mathrm{RP}} = 200$，$Q^{\\mathrm{RP}}(\\xi) = [1000, 1000]$，$Z^{\\mathrm{WS}}(\\xi) = [1200, 1200]$。\n$Z^{\\mathrm{EEV}} = 200 + (0.4)(1000) + (0.6)(1000) = 200 + 400 + 600 = 1200$。\n$Z^{\\mathrm{RP}} = 200 + (0.4)(1000) + (0.6)(1000) = 200 + 400 + 600 = 1200$。\n$Z^{\\mathrm{WS}} = (0.4)(1200) + (0.6)(1200) = 480 + 720 = 1200$。\n$VSS = 1200 - 1200 = 0$。\n$EVPI = 1200 - 1200 = 0$。\n结果：$[0.00, 0.00]$。正如预期的那样，在确定性设置中，$VSS$ 和 $EVPI$ 均为零。\n\n**测试用例 3（罕见的极端情景）**\n已知：$p = [0.01, 0.49, 0.5]$，$C_1^{\\mathrm{EV}} = 400$，$Q^{\\mathrm{EV}}(\\xi) = [6000, 1800, 1600]$，$C_1^{\\mathrm{RP}} = 450$，$Q^{\\mathrm{RP}}(\\xi) = [5800, 1700, 1500]$，$Z^{\\mathrm{WS}}(\\xi) = [5700, 1650, 1450]$。\n$Z^{\\mathrm{EEV}} = 400 + (0.01)(6000) + (0.49)(1800) + (0.5)(1600) = 400 + 60 + 882 + 800 = 2142$。\n$Z^{\\mathrm{RP}} = 450 + (0.01)(5800) + (0.49)(1700) + (0.5)(1500) = 450 + 58 + 833 + 750 = 2091$。\n$Z^{\\mathrm{WS}} = (0.01)(5700) + (0.49)(1650) + (0.5)(1450) = 57 + 808.5 + 725 = 1590.5$。\n$VSS = 2142 - 2091 = 51$。\n$EVPI = 2091 - 1590.5 = 500.5$。\n结果：$[51.00, 500.50]$。\n\n**测试用例 4**\n已知：$p = [0.25, 0.25, 0.25, 0.25]$，$C_1^{\\mathrm{EV}} = 800$，$Q^{\\mathrm{EV}}(\\xi) = [2400, 2000, 1600, 1200]$，$C_1^{\\mathrm{RP}} = 820$，$Q^{\\mathrm{RP}}(\\xi) = [2300, 1950, 1550, 1150]$，$Z^{\\mathrm{WS}}(\\xi) = [2200, 1900, 1500, 1100]$。\n$Z^{\\mathrm{EEV}} = 800 + (0.25)(2400+2000+1600+1200) = 800 + (0.25)(7200) = 800 + 1800 = 2600$。\n$Z^{\\mathrm{RP}} = 820 + (0.25)(2300+1950+1550+1150) = 820 + (0.25)(6950) = 820 + 1737.5 = 2557.5$。\n$Z^{\\mathrm{WS}} = (0.25)(2200+1900+1500+1100) = (0.25)(6700) = 1675$。\n$VSS = 2600 - 2557.5 = 42.5$。\n$EVPI = 2557.5 - 1675 = 882.5$。\n结果：$[42.50, 882.50]$。\n\n**测试用例 5（存在零概率情景）**\n已知：$p = [0.0, 0.7, 0.3]$，$C_1^{\\mathrm{EV}} = 300$，$Q^{\\mathrm{EV}}(\\xi) = [2000, 1500, 1000]$，$C_1^{\\mathrm{RP}} = 320$，$Q^{\\mathrm{RP}}(\\xi) = [1900, 1400, 900]$，$Z^{\\mathrm{WS}}(\\xi) = [1850, 1350, 850]$。零概率情景对期望值没有影响。\n$Z^{\\mathrm{EEV}} = 300 + (0.0)(2000) + (0.7)(1500) + (0.3)(1000) = 300 + 0 + 1050 + 300 = 1650$。\n$Z^{\\mathrm{RP}} = 320 + (0.0)(1900) + (0.7)(1400) + (0.3)(900) = 320 + 0 + 980 + 270 = 1570$。\n$Z^{\\mathrm{WS}} = (0.0)(1850) + (0.7)(1350) + (0.3)(850) = 0 + 945 + 255 = 1200$。\n$VSS = 1650 - 1570 = 80$。\n$EVPI = 1570 - 1200 = 370$。\n结果：$[80.00, 370.00]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Value of the Stochastic Solution (VSS) and the\n    Expected Value of Perfect Information (EVPI) for a series of\n    two-stage stochastic programming test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"p\": [0.2, 0.5, 0.3],\n            \"C1_EV\": 500,\n            \"Q_EV\": [3000, 2200, 1500],\n            \"C1_RP\": 600,\n            \"Q_RP\": [2800, 2100, 1400],\n            \"Z_WS_scenarios\": [2500, 2000, 1300],\n        },\n        # Test Case 2 (zero uncertainty)\n        {\n            \"p\": [0.4, 0.6],\n            \"C1_EV\": 200,\n            \"Q_EV\": [1000, 1000],\n            \"C1_RP\": 200,\n            \"Q_RP\": [1000, 1000],\n            \"Z_WS_scenarios\": [1200, 1200],\n        },\n        # Test Case 3 (rare extreme scenario)\n        {\n            \"p\": [0.01, 0.49, 0.5],\n            \"C1_EV\": 400,\n            \"Q_EV\": [6000, 1800, 1600],\n            \"C1_RP\": 450,\n            \"Q_RP\": [5800, 1700, 1500],\n            \"Z_WS_scenarios\": [5700, 1650, 1450],\n        },\n        # Test Case 4\n        {\n            \"p\": [0.25, 0.25, 0.25, 0.25],\n            \"C1_EV\": 800,\n            \"Q_EV\": [2400, 2000, 1600, 1200],\n            \"C1_RP\": 820,\n            \"Q_RP\": [2300, 1950, 1550, 1150],\n            \"Z_WS_scenarios\": [2200, 1900, 1500, 1100],\n        },\n        # Test Case 5 (zero-probability scenario present)\n        {\n            \"p\": [0.0, 0.7, 0.3],\n            \"C1_EV\": 300,\n            \"Q_EV\": [2000, 1500, 1000],\n            \"C1_RP\": 320,\n            \"Q_RP\": [1900, 1400, 900],\n            \"Z_WS_scenarios\": [1850, 1350, 850],\n        },\n    ]\n\n    results_list = []\n    for case in test_cases:\n        p = np.array(case[\"p\"])\n        C1_EV = case[\"C1_EV\"]\n        Q_EV_scenarios = np.array(case[\"Q_EV\"])\n        C1_RP = case[\"C1_RP\"]\n        Q_RP_scenarios = np.array(case[\"Q_RP\"])\n        Z_WS_scenarios = np.array(case[\"Z_WS_scenarios\"])\n\n        # Calculate Z_EEV (Expected cost of the Expected Value solution)\n        Z_EEV = C1_EV + np.dot(p, Q_EV_scenarios)\n        \n        # Calculate Z_RP (Expected cost of the Recourse Problem solution)\n        Z_RP = C1_RP + np.dot(p, Q_RP_scenarios)\n        \n        # Calculate Z_WS (Expected cost of the Wait-and-See solution)\n        Z_WS = np.dot(p, Z_WS_scenarios)\n        \n        # Calculate VSS (Value of the Stochastic Solution)\n        VSS = Z_EEV - Z_RP\n        \n        # Calculate EVPI (Expected Value of Perfect Information)\n        EVPI = Z_RP - Z_WS\n        \n        # Round to two decimal places and format for output\n        vss_rounded = round(VSS, 2)\n        evpi_rounded = round(EVPI, 2)\n        \n        # Store result as a formatted string: \"[vss,evpi]\"\n        results_list.append(f\"[{vss_rounded:.2f},{evpi_rounded:.2f}]\")\n\n    # Final print statement in the exact required format: \"[[v1,e1],[v2,e2],...]\"\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了随机模型的价值之后，我们将着手解决如何求解这类复杂问题。大规模的随机机组组合问题通常计算量巨大，难以直接求解。此练习  将指导你实现Benders分解算法，这是一种强大的优化技术，它将原问题分解为一个主问题和多个与场景相关的子问题。你将亲自推导并实施用于迭代求解的最优性割（optimality cut）和可行性割（feasibility cut），从而获得解决现实世界中复杂且棘手的微电网调度问题的实践经验。",
            "id": "4103624",
            "problem": "考虑一个在 $T$ 个离散时间段内，净需求存在分场景不确定性的两阶段微电网优化调度问题。该微电网拥有两台可调度发电机和一个外部电网连接，该连接有每时段的输入容量限制。第一阶段决定发电机的二进制启停决策，第二阶段则在第一阶段启停决策的约束下，针对每个场景独立地决定经济调度。您的任务是通过将第一阶段的启停决策与第二阶段的分场景调度分离，来实现 Benders 分解，并推导用于迭代优化主问题的最优性割和可行性割。\n\n基本依据与定义：\n- 令 $y_1 \\in \\{0,1\\}$ 和 $y_2 \\in \\{0,1\\}$ 分别为发电机 1 和发电机 2 的第一阶段启停决策。该二进制值表示发电机是否启停（开）或不启停（关）。\n- 对于每个场景 $s \\in \\mathcal{S}$ 和每个时间段 $t \\in \\{1,\\dots,T\\}$，定义净缺额 $d_{s,t} = D_{s,t} - \\text{PV}_{s,t}$，其中 $D_{s,t}$ 是需求，$\\text{PV}_{s,t}$ 是可再生光伏发电量。每个时间段持续 1 小时，因此功率（单位 kW）在数值上等于该时段内的能量（单位 kWh）。\n- 场景 $s$ 下的第二阶段决策变量为 $g_{1,t} \\ge 0$、$g_{2,t} \\ge 0$（发电机出力）和 $g^{\\text{grid}}_{t} \\ge 0$（电网输入），对于 $t=1,\\dots,T$。\n- 发电机容量为 $C_1$ 和 $C_2$，单位为 $\\text{kW}$；每时段电网输入容量为 $G^{\\max}_t$，单位为 $\\text{kW}$。可变发电成本为 $c_1$、$c_2$，电网电价为 $c_G$，单位为 $\\$/\\text{kWh}$。固定启停成本为 $F_1$ 和 $F_2$，单位为 $\\$$。\n- 场景 $s$ 的第二阶段调度问题是一个线性规划问题，其目标是在满足每时段的平衡约束和容量约束下，最小化运行成本。\n- Benders 主问题包括第一阶段成本和通过变量 $\\theta_s$ 对分场景追索成本的近似，该近似通过从第二阶段线性规划的对偶性和可行性条件推导出的割进行迭代优化。\n\n您必须从线性规划的对偶性和可行性条件出发，推导出：\n- 对于每个场景 $s$，利用第二阶段线性规划的对偶乘子，推导一个形式为 $\\theta_s \\ge \\alpha_s + \\beta_{1,s} y_1 + \\beta_{2,s} y_2$ 的最优性割。\n- 如果一个场景的第二阶段调度对于给定的 $(y_1,y_2)$ 是不可行的，则推导一个可行性割，以确保每个时间段都有足够的已启停容量：$C_1 y_1 + C_2 y_2 \\ge \\max\\{d_{s,t} - G^{\\max}_t, 0\\}$，对于该场景中的所有 $t$。\n\n实现一个迭代的 Benders 算法：\n- 初始化，不设置任何最优性割和可行性割。\n- 在每次迭代中，通过枚举 $(y_1,y_2)$ 的所有二进制组合来求解主问题，并选择满足所有累积可行性割的可行组合，该组合能最小化当前的主问题目标函数。其中 $\\theta_s$ 被替换为在该 $(y_1,y_2)$ 处评估的所有现有场景 $s$ 最优性割的最大值，如果场景 $s$ 尚无最优性割，则为 $0$。\n- 给定选定的 $(y_1,y_2)$，求解每个场景的第二阶段调度线性规划。如果可行，则添加其最优性割；如果不可行，则为所有存在未满足缺额的时间段添加可行性割。维护并更新全局下界和上界，直到收敛或所有可行的 $(y_1,y_2)$ 组合都已被处理。\n\n物理和数值单位：\n- 所有功率和能量单位必须分别以 $\\text{kW}$ 和 $\\text{kWh}$ 处理。所有成本必须以美元 $\\$$ 为单位。以美元为单位表示每个测试用例的最终期望总成本，并四舍五入到两位小数。\n\n角度单位不适用。不得使用百分比。\n\n测试套件和参数规范：\n为以下三个测试用例实现上述算法。每个测试用例是一个参数元组 $(T, C_1, C_2, c_1, c_2, c_G, F_1, F_2, \\{G^{\\max}_t\\}_{t=1}^T, \\mathcal{S}, \\{p_s\\}_{s \\in \\mathcal{S}})$，其中场景数据包括 $\\{D_{s,t}\\}_{t=1}^T$ 和 $\\{\\text{PV}_{s,t}\\}_{t=1}^T$。\n\n- 测试用例 1（理想情况；电网和光伏足以满足需求，无需启停发电机）：\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$。\n  - $G^{\\max} = [80, 80, 80]$。\n  - 场景 $\\mathcal{S} = \\{A, B\\}$，概率为 $p_A = 0.5$, $p_B = 0.5$。\n  - 场景 $A$：$D_{A} = [70, 60, 50]$, $\\text{PV}_{A} = [30, 40, 50]$。\n  - 场景 $B$：$D_{B} = [60, 55, 65]$, $\\text{PV}_{B} = [35, 25, 30]$。\n\n- 测试用例 2（电网受限；至少必须启停一台发电机）：\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$。\n  - $G^{\\max} = [20, 20, 20]$。\n  - 场景 $\\mathcal{S} = \\{A, B\\}$，概率为 $p_A = 0.5$, $p_B = 0.5$。\n  - 场景 $A$：$D_{A} = [70, 60, 50]$, $\\text{PV}_{A} = [30, 40, 50]$。\n  - 场景 $B$：$D_{B} = [60, 55, 65]$, $\\text{PV}_{B} = [35, 25, 30]$。\n\n- 测试用例 3（边界情况；需要两台发电机才能满足所有时间段的需求）：\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$。\n  - $G^{\\max} = [0, 0, 0]$。\n  - 场景 $\\mathcal{S} = \\{C\\}$，概率为 $p_C = 1.0$。\n  - 场景 $C$：$D_{C} = [100, 100, 100]$, $\\text{PV}_{C} = [10, 10, 10]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的期望最优总成本。该输出为一个用方括号括起来的逗号分隔列表（例如，“[$x_1$,$x_2$,$x_3$]”），其中每个 $x_i$ 是一个以 $\\$$ 为单位、四舍五入到两位小数的浮点数。",
            "solution": "用户指定了一个用于微电网调度的两阶段随机优化问题，该问题将使用 Benders 分解进行求解。该问题定义明确，在电力系统工程和运筹学方面有科学依据，并且为指定的测试用例提供了所有必要的参数。因此，该问题被认定为有效。\n\n求解方法包括将问题分解为一个用于第一阶段发电机启停决策的主问题和一组用于在每个不确定性场景下进行经济调度的第二阶段子问题。主问题通过添加从子问题推导出的最优性割和可行性割进行迭代优化。\n\n### 数学公式\n\n总体目标是最小化第一阶段固定成本与第二阶段期望运行成本之和。\n\n**第一阶段（主）问题**\n主问题决定二进制发电机启停变量 $y_1, y_2 \\in \\{0, 1\\}$。其目标函数包括固定启停成本和期望第二阶段成本的近似值，该近似值由每个场景 $s \\in \\mathcal{S}$ 的追索变量 $\\theta_s \\ge 0$ 表示。\n\n$$\n\\min_{y_1, y_2, \\theta_s} \\quad F_1 y_1 + F_2 y_2 + \\sum_{s \\in \\mathcal{S}} p_s \\theta_s\n$$\n约束条件：\n$$\ny_1, y_2 \\in \\{0, 1\\}\n$$\n$$\n\\theta_s \\ge 0 \\quad \\forall s \\in \\mathcal{S}\n$$\n以及一组迭代添加的 Benders 割（最优性割和可行性割）。\n\n**第二阶段（子问题）**\n对于给定的第一阶段决策 $(\\bar{y}_1, \\bar{y}_2)$ 和特定场景 $s$，第二阶段子问题是一个最小化运行成本的线性规划（LP）。整个子问题可按时间段 $t \\in \\{1, \\dots, T\\}$ 分解。对于每个时间段，我们求解：\n\n$$\nQ_{s,t}(\\bar{y}_1, \\bar{y}_2) = \\min_{g_{1,t}, g_{2,t}, g^{\\text{grid}}_{t}} \\quad c_1 g_{1,t} + c_2 g_{2,t} + c_G g^{\\text{grid}}_{t}\n$$\n约束条件：\n\\begin{align*}\n(S1_t):  \\quad g_{1,t} + g_{2,t} + g^{\\text{grid}}_{t} \\ge d_{s,t}  [\\lambda_{s,t} \\ge 0] \\\\\n(S2_{1,t}):  \\quad g_{1,t} \\le C_1 \\bar{y}_1  [\\mu_{1,s,t} \\ge 0] \\\\\n(S3_{2,t}):  \\quad g_{2,t} \\le C_2 \\bar{y}_2  [\\mu_{2,s,t} \\ge 0] \\\\\n(S4_t):  \\quad g^{\\text{grid}}_{t} \\le G^{\\max}_t  [\\nu_{s,t} \\ge 0] \\\\\n \\quad g_{1,t}, g_{2,t}, g^{\\text{grid}}_{t} \\ge 0\n\\end{align*}\n场景 $s$ 的第二阶段总成本为 $Q_s(\\bar{y}_1, \\bar{y}_2) = \\sum_{t=1}^T Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$。每个约束的对偶变量在方括号中表示。\n\n### Benders 割推导\n\n**1. 可行性割**\n如果总可用发电容量小于净缺额 $d_{s,t} = D_{s,t} - \\text{PV}_{s,t}$，则给定时间段 $t$ 和场景 $s$ 的子问题是不可行的。最大可用供应量为 $C_1 \\bar{y}_1 + C_2 \\bar{y}_2 + G^{\\max}_t$。可行性要求：\n$$\nC_1 \\bar{y}_1 + C_2 \\bar{y}_2 + G^{\\max}_t \\ge d_{s,t}\n$$\n如果对于特定的 $(\\bar{y}_1, \\bar{y}_2)$ 违反了此条件，则生成一个可行性割并添加到主问题中，以在未来的迭代中排除此类不可行的启停决策。该割对通用的 $y_1, y_2$ 表示为：\n$$\nC_1 y_1 + C_2 y_2 \\ge d_{s,t} - G^{\\max}_t\n$$\n由于左侧是非负的，只有当右侧为正时，此割才有意义。因此，对于场景 $s$ 下子问题不可行的每个时间段 $t'$，我们添加以下割：\n$$\nC_1 y_1 + C_2 y_2 \\ge \\max\\{0, d_{s,t'} - G^{\\max}_{t'}\\}\n$$\n\n**2. 最优性割**\n如果场景 $s$ 的子问题对于给定的 $(\\bar{y}_1, \\bar{y}_2)$ 是可行的，则从其对偶问题生成一个最优性割。每时段子问题的对偶问题是：\n$$\n\\max_{\\lambda, \\mu, \\nu} \\quad d_{s,t} \\lambda_{s,t} - C_1 \\bar{y}_1 \\mu_{1,s,t} - C_2 \\bar{y}_2 \\mu_{2,s,t} - G^{\\max}_t \\nu_{s,t}\n$$\n约束条件：\n\\begin{align*}\n\\lambda_{s,t} - \\mu_{1,s,t} \\le c_1 \\\\\n\\lambda_{s,t} - \\mu_{2,s,t} \\le c_2 \\\\\n\\lambda_{s,t} - \\nu_{s,t} \\le c_G \\\\\n\\lambda_{s,t}, \\mu_{1,s,t}, \\mu_{2,s,t}, \\nu_{s,t} \\ge 0\n\\end{align*}\n根据强对偶性，原子问题 $Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$ 的最优目标值等于该对偶问题的最优值。令 $(\\bar{\\lambda}_{s,t}, \\bar{\\mu}_{1,s,t}, \\bar{\\mu}_{2,s,t}, \\bar{\\nu}_{s,t})$ 为最优对偶变量。值 $Q_s(\\bar{y}_1, \\bar{y}_2) = \\sum_t Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$ 为 $\\theta_s$ 提供了一个值，该值可作为任何可行启停决策的下界。最优性割是追索函数 $Q_s(y_1, y_2)$ 的一个线性下近似。其形式为：\n$$\n\\theta_s \\ge Q_s(\\bar{y}_1, \\bar{y}_2) + \\nabla Q_s(\\bar{y}_1, \\bar{y}_2)^T \\begin{pmatrix} y_1 - \\bar{y}_1 \\\\ y_2 - \\bar{y}_2 \\end{pmatrix}\n$$\n梯度分量为 $\\frac{\\partial Q_s}{\\partial y_i} = - \\sum_{t=1}^T C_i \\bar{\\mu}_{i,s,t}$。这导出了割 $\\theta_s \\ge \\alpha_s + \\beta_{1,s} y_1 + \\beta_{2,s} y_2$，其中：\n$$\n\\alpha_s = \\sum_{t=1}^T (d_{s,t} \\bar{\\lambda}_{s,t} - G^{\\max}_t \\bar{\\nu}_{s,t})\n$$\n$$\n\\beta_{1,s} = - \\sum_{t=1}^T C_1 \\bar{\\mu}_{1,s,t}\n$$\n$$\n\\beta_{2,s} = - \\sum_{t=1}^T C_2 \\bar{\\mu}_{2,s,t}\n$$\n此割被添加到主问题中，从而改善其对第二阶段成本函数的近似。\n\n### Benders 分解算法\n\n迭代算法的步骤如下：\n\n1.  **初始化**：初始化全局下界 $LB = -\\infty$ 和上界 $UB = +\\infty$。最优性割和可行性割的集合为空。\n2.  **主问题求解**：在每次迭代中，求解主问题。鉴于第一阶段决策的规模很小（$2^2=4$ 种组合），这可以通过枚举所有组合对 $(y_1, y_2) \\in \\{(0,0), (0,1), (1,0), (1,1)\\}$ 来完成。对于每个组合对：\n    *   检查其是否满足所有当前的可行性割。\n    *   如果可行，则计算其主问题目标值 $F_1 y_1 + F_2 y_2 + \\sum_s p_s \\theta_s$，其中每个 $\\theta_s$ 是在该场景下，在 $(y_1, y_2)$ 处评估所有现有最优性割后返回的最大值。\n    *   选择主问题目标值最小的组合对 $(y_1^{(k)}, y_2^{(k)})$。该目标值 $Z_{MP}^{(k)}$ 用于更新全局下界：$LB = \\max(LB, Z_{MP}^{(k)})$。\n3.  **子问题求解**：对于选定的 $(y_1^{(k)}, y_2^{(k)})$，求解每个场景 $s \\in \\mathcal{S}$ 的第二阶段 LP。\n    *   如果任何场景 $s$ 的子问题是不可行的（对于任何时间段 $t$），则将相应的可行性割添加到主问题中。此启停决策的真实成本为无穷大。\n    *   如果所有场景的子问题都可行，则计算总真实成本：$Z^{(k)} = F_1 y_1^{(k)} + F_2 y_2^{(k)} + \\sum_s p_s Q_s(y_1^{(k)}, y_2^{(k)})$。该值用于更新全局上界：$UB = \\min(UB, Z^{(k)})$。对于每个场景 $s$，使用其子问题解的对偶变量生成一个最优性割，并将其添加到主问题中。\n4.  **收敛性检查**：如果上界和下界之间的间隙小于一个小的容差（$UB - LB \\le \\epsilon$），或者所有四种可能的启停组合都已通过子问题进行了评估，则算法终止。最优解是产生最佳上界的启停决策，最优值为 $UB$。\n\n该过程被实现以解决三个指定的测试用例。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the solution process.\n    \"\"\"\n    # Test Case 1: Happy path; grid and PV suffice\n    case1 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([80, 80, 80]),\n        \"scenarios\": [\n            {\n                \"id\": \"A\", \"prob\": 0.5,\n                \"D\": np.array([70, 60, 50]), \"PV\": np.array([30, 40, 50])\n            },\n            {\n                \"id\": \"B\", \"prob\": 0.5,\n                \"D\": np.array([60, 55, 65]), \"PV\": np.array([35, 25, 30])\n            }\n        ]\n    }\n\n    # Test Case 2: Grid-limited; at least one generator needed\n    case2 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([20, 20, 20]),\n        \"scenarios\": [\n            {\n                \"id\": \"A\", \"prob\": 0.5,\n                \"D\": np.array([70, 60, 50]), \"PV\": np.array([30, 40, 50])\n            },\n            {\n                \"id\": \"B\", \"prob\": 0.5,\n                \"D\": np.array([60, 55, 65]), \"PV\": np.array([35, 25, 30])\n            }\n        ]\n    }\n\n    # Test Case 3: Boundary; both generators required\n    case3 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([0, 0, 0]),\n        \"scenarios\": [\n            {\n                \"id\": \"C\", \"prob\": 1.0,\n                \"D\": np.array([100, 100, 100]), \"PV\": np.array([10, 10, 10])\n            }\n        ]\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        cost = run_benders_for_case(case)\n        results.append(f\"{cost:.2f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_subproblem(s_data, y, params, s_idx):\n    \"\"\"\n    Solves the second-stage LP for a given scenario and commitment decision.\n    \"\"\"\n    y1, y2 = y\n    T, C1, C2, c1, c2, cG = params[\"T\"], params[\"C1\"], params[\"C2\"], params[\"c1\"], params[\"c2\"], params[\"cG\"]\n    G_max = params[\"G_max\"]\n    \n    total_cost_s = 0.0\n    alpha_s, beta1_s, beta2_s = 0.0, 0.0, 0.0\n    \n    infeasible_periods = []\n    d_s = s_data['D'] - s_data['PV']\n\n    for t in range(T):\n        net_deficit_t = max(0, d_s[t])\n\n        c = np.array([c1, c2, cG])\n        A_ub = np.array([\n            [-1, -1, -1],  # g1+g2+g_grid >= d_st\n            [1, 0, 0],     # g1 = C1*y1\n            [0, 1, 0],     # g2 = C2*y2\n            [0, 0, 1]      # g_grid = G_max_t\n        ])\n        b_ub = np.array([-net_deficit_t, C1 * y1, C2 * y2, G_max[t]])\n        \n        bounds = [(0, None), (0, None), (0, None)]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.status == 2: # Infeasible\n            infeasible_periods.append(t)\n        elif not res.success: # other errors\n            # For this problem, non-success other than infeasibility is unexpected\n            # but treat as infeasible to be safe.\n            infeasible_periods.append(t)\n        else:\n            total_cost_s += res.fun\n            \n            duals = res.ineqlin.marginals\n            lambda_st, mu1_st, mu2_st, nu_st = duals[0], duals[1], duals[2], duals[3]\n            \n            alpha_s += lambda_st * net_deficit_t - nu_st * G_max[t]\n            beta1_s -= mu1_st * C1\n            beta2_s -= mu2_st * C2\n\n    if infeasible_periods:\n        cuts = []\n        for t_inf in infeasible_periods:\n            rhs = max(0, d_s[t_inf] - G_max[t_inf])\n            cut = {'coeffs': [C1, C2], 'rhs': rhs}\n            cuts.append(cut)\n        return {'status': 'infeasible', 'cuts': cuts}\n    \n    cut = {'type': 'optimality', 's_idx': s_idx, 'params': (alpha_s, beta1_s, beta2_s)}\n    return {'status': 'feasible', 'cost': total_cost_s, 'cut': cut}\n\ndef run_benders_for_case(params):\n    \"\"\"\n    Executes the Benders decomposition algorithm for a single test case.\n    \"\"\"\n    y_options = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    optimality_cuts = {i: [] for i, _ in enumerate(params[\"scenarios\"])}\n    feasibility_cuts = []\n    \n    lower_bound = -np.inf\n    upper_bound = np.inf\n    \n    y_processed = set()\n    \n    max_iter = len(y_options) + 2  # Sufficient iterations for this small problem\n\n    for _ in range(max_iter):\n        \n        # 1. Solve Master Problem by enumeration\n        master_results = {}\n        for y_candidate in y_options:\n            y1, y2 = y_candidate\n\n            # Check feasibility cuts\n            is_feasible = all(c['coeffs'][0] * y1 + c['coeffs'][1] * y2 >= c['rhs'] for c in feasibility_cuts)\n            if not is_feasible:\n                continue\n\n            # Calculate objective for this y\n            first_stage_cost = params['F1'] * y1 + params['F2'] * y2\n            expected_recourse_cost = 0.0\n            for s_idx, s_data in enumerate(params[\"scenarios\"]):\n                theta_s = 0.0\n                for o_cut_params in optimality_cuts[s_idx]:\n                    alpha, beta1, beta2 = o_cut_params\n                    cut_val = alpha + beta1 * y1 + beta2 * y2\n                    theta_s = max(theta_s, cut_val)\n                expected_recourse_cost += s_data['prob'] * theta_s\n            \n            total_master_cost = first_stage_cost + expected_recourse_cost\n            master_results[y_candidate] = total_master_cost\n            \n        if not master_results:\n            break # All combinations are infeasible\n        \n        current_y = min(master_results, key=master_results.get)\n        current_lb = master_results[current_y]\n        lower_bound = max(lower_bound, current_lb)\n        \n        y_processed.add(current_y)\n        \n        # 2. Solve Subproblems for current_y\n        y1_k, y2_k = current_y\n        total_second_stage_real_cost = 0.0\n        all_subproblems_feasible = True\n        new_feasibility_cuts = []\n        \n        for s_idx, s_data in enumerate(params[\"scenarios\"]):\n            sub_result = solve_subproblem(s_data, current_y, params, s_idx)\n            \n            if sub_result['status'] == 'infeasible':\n                all_subproblems_feasible = False\n                new_feasibility_cuts.extend(sub_result['cuts'])\n                break\n            else:\n                total_second_stage_real_cost += s_data['prob'] * sub_result['cost']\n                optimality_cuts[s_idx].append(sub_result['cut']['params'])\n\n        if all_subproblems_feasible:\n            current_ub = (params['F1'] * y1_k + params['F2'] * y2_k) + total_second_stage_real_cost\n            upper_bound = min(upper_bound, current_ub)\n        else:\n             for f_cut in new_feasibility_cuts:\n                if not any(np.array_equal(c['coeffs'], f_cut['coeffs']) and c['rhs'] == f_cut['rhs'] for c in feasibility_cuts):\n                    feasibility_cuts.append(f_cut)\n\n        # 3. Check Convergence\n        if upper_bound - lower_bound = 1e-6:\n            break\n        if len(y_processed) == len(y_options):\n            break\n\n    return upper_bound if upper_bound != np.inf else 0.0\n\nsolve()\n```"
        }
    ]
}