{
    "hands_on_practices": [
        {
            "introduction": "This first practice introduces the fundamental concepts of optimal scheduling through a tangible application: energy arbitrage. By formulating a linear program to control a battery system, you will learn to translate physical constraints—such as energy capacity, power limits, and efficiency losses—into a mathematical model. This exercise builds a foundational skill set for tackling more complex, multi-asset scheduling problems. ",
            "id": "4103641",
            "problem": "Consider a three-period energy arbitrage problem for a microgrid equipped with a single electrochemical battery. The battery interacts with an external market in each period, buying energy to charge and selling energy when discharging. Assume discrete time with a fixed time step of one hour per period so that energy and power are numerically equal over a period. Use the following physical modeling principles and core definitions:\n\n- Energy conservation over each period, expressed by the state-of-charge recursion, derived from conservation of energy with conversion losses. Let the charge power in period $t$ be $c_t \\ge 0$ and the discharge power in period $t$ be $d_t \\ge 0$. Let the end-of-period state of charge be $E_t$. Assume a single round-trip efficiency parameter $0  \\eta \\le 1$, which is decomposed into symmetric charge efficiency and discharge efficiency as $\\eta_c = \\sqrt{\\eta}$ and $\\eta_d = \\sqrt{\\eta}$ so that the round-trip efficiency is $\\eta_c \\eta_d = \\eta$. The state-of-charge update obeys\n$$\nE_t = E_{t-1} + \\eta_c \\, c_t - \\frac{1}{\\eta_d} \\, d_t,\n$$\nfor $t \\in \\{1,2,3\\}$, with given initial state of charge $E_0$.\n- Bound constraints follow from physical limitations:\n  - Energy bounds $E_{\\min} \\le E_t \\le E_{\\max}$ for $t \\in \\{1,2,3\\}$.\n  - Charge power bounds $0 \\le c_t \\le P_{\\max}^{\\mathrm{ch}}$ and discharge power bounds $0 \\le d_t \\le P_{\\max}^{\\mathrm{dis}}$ for each $t$.\n- Market transactions are priced at $p_t$ dollars per kilowatt-hour for $t \\in \\{1,2,3\\}$. Buying $c_t$ incurs a cost of $p_t c_t$, while selling $d_t$ earns revenue $p_t d_t$.\n- To prevent artificial value from leftover energy, impose a terminal constraint $E_3 = E_{\\mathrm{final}}$, where $E_{\\mathrm{final}}$ is specified. All energy quantities are in kilowatt-hours (kWh), all power quantities are in kilowatts (kW), and all prices are in dollars per kilowatt-hour ($/kWh).\n\nStarting from these principles, formulate and solve the microgrid battery arbitrage problem as a linear optimization that maximizes total profit over the three periods subject to the energy conservation, bound constraints, and terminal constraint. Your program must compute, for each test case, the optimal charge/discharge amounts $(c_1,c_2,c_3)$ and $(d_1,d_2,d_3)$ and the resulting total profit. The energy balance, bound consistency, and objective must be respected for all test cases.\n\nExpress all charge and discharge values in kilowatt-hours (kWh) and the total profit in dollars, each rounded to three decimal places. The final program output must be a single line containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a bracket-enclosed, comma-separated list of seven decimal numbers:\n$$\n[c_1,c_2,c_3,d_1,d_2,d_3,\\text{profit}].\n$$\n\nUse the following test suite. For each test case, the parameters are $(p_1,p_2,p_3)$, $\\eta$, $E_0$, $E_{\\mathrm{final}}$, $E_{\\min}$, $E_{\\max}$, $P_{\\max}^{\\mathrm{ch}}$, $P_{\\max}^{\\mathrm{dis}}$:\n\n- Test case 1 (canonical arbitrage with price valley then peak):\n  - Prices: $(0.03, 0.01, 0.08)$ per kWh.\n  - Efficiency: $\\eta = 0.9$.\n  - Initial state: $E_0 = 5$ kWh.\n  - Terminal state: $E_{\\mathrm{final}} = 5$ kWh.\n  - Energy bounds: $E_{\\min} = 0$ kWh, $E_{\\max} = 10$ kWh.\n  - Power bounds: $P_{\\max}^{\\mathrm{ch}} = 5$ kW, $P_{\\max}^{\\mathrm{dis}} = 5$ kW.\n- Test case 2 (monotone decreasing prices with full battery):\n  - Prices: $(0.07, 0.05, 0.04)$ per kWh.\n  - Efficiency: $\\eta = 0.88$.\n  - Initial state: $E_0 = 8$ kWh.\n  - Terminal state: $E_{\\mathrm{final}} = 8$ kWh.\n  - Energy bounds: $E_{\\min} = 0$ kWh, $E_{\\max} = 8$ kWh.\n  - Power bounds: $P_{\\max}^{\\mathrm{ch}} = 10$ kW, $P_{\\max}^{\\mathrm{dis}} = 10$ kW.\n- Test case 3 (flat prices, no profitable cycling due to losses):\n  - Prices: $(0.05, 0.05, 0.05)$ per kWh.\n  - Efficiency: $\\eta = 0.95$.\n  - Initial state: $E_0 = 5$ kWh.\n  - Terminal state: $E_{\\mathrm{final}} = 5$ kWh.\n  - Energy bounds: $E_{\\min} = 0$ kWh, $E_{\\max} = 10$ kWh.\n  - Power bounds: $P_{\\max}^{\\mathrm{ch}} = 5$ kW, $P_{\\max}^{\\mathrm{dis}} = 5$ kW.\n- Test case 4 (tight discharge power and low round-trip efficiency):\n  - Prices: $(0.04, 0.10, 0.06)$ per kWh.\n  - Efficiency: $\\eta = 0.6$.\n  - Initial state: $E_0 = 2$ kWh.\n  - Terminal state: $E_{\\mathrm{final}} = 2$ kWh.\n  - Energy bounds: $E_{\\min} = 0$ kWh, $E_{\\max} = 6$ kWh.\n  - Power bounds: $P_{\\max}^{\\mathrm{ch}} = 2$ kW, $P_{\\max}^{\\mathrm{dis}} = 1.5$ kW.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a bracketed list of seven decimal numbers in the order $[c_1,c_2,c_3,d_1,d_2,d_3,\\text{profit}]$, rounded to three decimal places, for example:\n$$\n[[0.000,0.000,0.000,0.000,0.000,0.000,0.000],[\\dots],\\dots].\n$$",
            "solution": "The problem posed is to determine the optimal energy arbitrage strategy for a battery in a microgrid over a three-period time horizon. This requires formulating and solving a mathematical optimization problem that maximizes profit, subject to the physical and operational constraints of the system. The problem statement is scientifically grounded, self-contained, and well-posed, making it valid for a formal solution.\n\nThe core of the solution lies in expressing the problem as a Linear Program (LP). An LP consists of an objective function to be optimized and a set of constraints, where both the objective and the constraints are linear functions of the decision variables.\n\nFirst, we define the decision variables. For each time period $t \\in \\{1, 2, 3\\}$, the battery can either charge or discharge. Let $c_t$ be the energy charged during period $t$, and $d_t$ be the energy discharged during period $t$. Since the time step is $1$ hour, power (in kW) is numerically equal to energy (in kWh). The decision variables for the entire horizon are collected into a single vector $x$:\n$$\nx = [c_1, c_2, c_3, d_1, d_2, d_3]^T\n$$\nThese variables are non-negative, i.e., $c_t \\ge 0$ and $d_t \\ge 0$.\n\nNext, we formulate the objective function. The goal is to maximize total profit, which is the total revenue from selling energy minus the total cost of buying energy. With market prices $p_t$, the profit $\\Pi$ is:\n$$\n\\text{maximize} \\quad \\Pi = \\sum_{t=1}^{3} (p_t d_t - p_t c_t)\n$$\nStandard LP solvers perform minimization. Maximizing $\\Pi$ is equivalent to minimizing $-\\Pi$. Thus, the objective function to minimize is:\n$$\n\\text{minimize} \\quad \\sum_{t=1}^{3} (p_t c_t - p_t d_t)\n$$\nThis can be written in matrix form as $c_{obj}^T x$, where the cost vector $c_{obj}$ is:\n$$\nc_{obj} = [p_1, p_2, p_3, -p_1, -p_2, -p_3]^T\n$$\n\nThe system is governed by several constraints.\n\n1.  **State-of-Charge (SOC) Dynamics:** The energy stored in the battery, $E_t$, at the end of period $t$ evolves according to the conservation of energy, accounting for efficiency losses. The given state equation is:\n    $$\n    E_t = E_{t-1} + \\eta_c c_t - \\frac{1}{\\eta_d} d_t\n    $$\n    where $\\eta_c = \\sqrt{\\eta}$ and $\\eta_d = \\sqrt{\\eta}$ are the charge and discharge efficiencies, respectively. We can express $E_t$ for $t \\in \\{1, 2, 3\\}$ in terms of the initial state $E_0$ and the decision variables:\n    $$\n    E_1 = E_0 + \\eta_c c_1 - \\frac{1}{\\eta_d} d_1\n    $$\n    $$\n    E_2 = E_1 + \\eta_c c_2 - \\frac{1}{\\eta_d} d_2 = E_0 + \\eta_c(c_1 + c_2) - \\frac{1}{\\eta_d}(d_1 + d_2)\n    $$\n    $$\n    E_3 = E_2 + \\eta_c c_3 - \\frac{1}{\\eta_d} d_3 = E_0 + \\eta_c(c_1 + c_2 + c_3) - \\frac{1}{\\eta_d}(d_1 + d_2 + d_3)\n    $$\n\n2.  **Energy Bounds:** The stored energy must remain within physical limits at all times:\n    $$\n    E_{\\min} \\le E_t \\le E_{\\max} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    These inequalities are applied to the expressions for $E_1$ and $E_2$. For $E_3$, a more specific constraint is given. These constraints are linear in the decision variables. For $t=1$:\n    $$\n    \\eta_c c_1 - \\frac{1}{\\eta_d} d_1 \\le E_{\\max} - E_0\n    $$\n    $$\n    -\\eta_c c_1 + \\frac{1}{\\eta_d} d_1 \\le E_0 - E_{\\min}\n    $$\n    Similarly for $t=2$:\n    $$\n    \\eta_c(c_1 + c_2) - \\frac{1}{\\eta_d}(d_1 + d_2) \\le E_{\\max} - E_0\n    $$\n    $$\n    -\\eta_c(c_1 + c_2) + \\frac{1}{\\eta_d}(d_1 + d_2) \\le E_0 - E_{\\min}\n    $$\n\n3.  **Terminal State Constraint:** A terminal constraint is imposed to ensure the final state of charge is a specified value, $E_{\\mathrm{final}}$:\n    $$\n    E_3 = E_{\\mathrm{final}}\n    $$\n    Substituting the expression for $E_3$:\n    $$\n    E_0 + \\eta_c \\sum_{t=1}^{3} c_t - \\frac{1}{\\eta_d} \\sum_{t=1}^{3} d_t = E_{\\mathrm{final}}\n    $$\n    This can be rearranged into a linear equality constraint:\n    $$\n    \\eta_c \\sum_{t=1}^{3} c_t - \\frac{1}{\\eta_d} \\sum_{t=1}^{3} d_t = E_{\\mathrm{final}} - E_0\n    $$\n\n4.  **Power Bounds:** The charge and discharge rates are limited by the battery's power capacity:\n    $$\n    0 \\le c_t \\le P_{\\max}^{\\mathrm{ch}} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    $$\n    0 \\le d_t \\le P_{\\max}^{\\mathrm{dis}} \\quad \\text{for } t \\in \\{1, 2, 3\\}\n    $$\n    These are simple box constraints on the decision variables.\n\nThe problem formulation does not require an explicit constraint to prevent simultaneous charging and discharging (i.e., $c_t d_t = 0$). Any feasible solution where $c_t > 0$ and $d_t > 0$ for some period $t$ is suboptimal. One could reduce both $c_t$ and $d_t$ by a small amount in a way that keeps the net energy change the same but reduces the cost, due to the round-trip efficiency loss $(\\eta = \\eta_c \\eta_d  1)$. An LP solver will thus naturally drive one of the two variables to $0$ for each period.\n\nThe complete problem is solved by using a standard LP solver. We construct the matrices and vectors for the canonical LP form: minimize $c_{obj}^T x$ subject to $A_{eq} x = b_{eq}$, $A_{ub} x \\le b_{ub}$, and element-wise bounds on $x$.\n\nFor a given set of parameters $(p_1, p_2, p_3), \\eta, E_0, E_{\\mathrm{final}}, E_{\\min}, E_{\\max}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{dis}}$:\n\n- **Equality Constraint:** $A_{eq}$ is a $1 \\times 6$ matrix and $b_{eq}$ is a scalar.\n  $$\n  A_{eq} = [\\eta_c, \\eta_c, \\eta_c, -1/\\eta_d, -1/\\eta_d, -1/\\eta_d]\n  $$\n  $$\n  b_{eq} = [E_{\\mathrm{final}} - E_0]\n  $$\n\n- **Inequality Constraints:** $A_{ub}$ is a $4 \\times 6$ matrix and $b_{ub}$ is a $4 \\times 1$ vector.\n  $$\n  A_{ub} = \\begin{pmatrix}\n  \\eta_c  0  0  -1/\\eta_d  0  0 \\\\\n  -\\eta_c  0  0  1/\\eta_d  0  0 \\\\\n  \\eta_c  \\eta_c  0  -1/\\eta_d  -1/\\eta_d  0 \\\\\n  -\\eta_c  -\\eta_c  0  1/\\eta_d  1/\\eta_d  0\n  \\end{pmatrix}\n  $$\n  $$\n  b_{ub} = [E_{\\max} - E_0, E_0 - E_{\\min}, E_{\\max} - E_0, E_0 - E_{\\min}]^T\n  $$\n\n- **Bounds:** The lower bounds are all $0$. The upper bounds are:\n  $$\n  [P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{ch}}, P_{\\max}^{\\mathrm{dis}}, P_{\\max}^{\\mathrm{dis}}, P_{\\max}^{\\mathrm{dis}}]^T\n  $$\n\nThe Python implementation will construct these matrices and vectors for each test case and pass them to the `scipy.optimize.linprog` function to find the optimal charge/discharge schedule $x^*$ and the corresponding minimal cost. The maximum profit is the negative of the minimal cost. The final results are then formatted as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the microgrid battery arbitrage problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: (p1,p2,p3), eta, E0, E_final, Emin, Emax, Pch_max, Pdis_max\n        ((0.03, 0.01, 0.08), 0.9, 5, 5, 0, 10, 5, 5),\n        # Test case 2\n        ((0.07, 0.05, 0.04), 0.88, 8, 8, 0, 8, 10, 10),\n        # Test case 3\n        ((0.05, 0.05, 0.05), 0.95, 5, 5, 0, 10, 5, 5),\n        # Test case 4\n        ((0.04, 0.10, 0.06), 0.6, 2, 2, 0, 6, 2, 1.5)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(*case)\n        results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join([f\"{val:.3f}\" for val in res]) + \"]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\ndef solve_one_case(prices, eta, E0, E_final, E_min, E_max, P_max_ch, P_max_dis):\n    \"\"\"\n    Formulates and solves the linear program for a single test case.\n    \n    The decision variable vector is x = [c1, c2, c3, d1, d2, d3].\n    \"\"\"\n    p1, p2, p3 = prices\n    \n    # Efficiencies\n    eta_c = np.sqrt(eta)\n    eta_d = np.sqrt(eta)\n\n    # Objective function: minimize (p*c - p*d)\n    c_obj = np.array([p1, p2, p3, -p1, -p2, -p3])\n\n    # --- Constraints ---\n    \n    # 1. Equality constraint: E3 = E_final\n    # E0 + eta_c*(c1+c2+c3) - (1/eta_d)*(d1+d2+d3) = E_final\n    # eta_c*(c1+c2+c3) - (1/eta_d)*(d1+d2+d3) = E_final - E0\n    A_eq = np.array([[eta_c, eta_c, eta_c, -1/eta_d, -1/eta_d, -1/eta_d]])\n    b_eq = np.array([E_final - E0])\n    \n    # 2. Inequality constraints: E_min = E_t = E_max for t=1, 2\n    # E1 = E_max  = E0 + eta_c*c1 - (1/eta_d)*d1 = E_max = eta_c*c1 - (1/eta_d)*d1 = E_max - E0\n    # E1 = E_min  = E0 + eta_c*c1 - (1/eta_d)*d1 = E_min = -eta_c*c1 + (1/eta_d)*d1 = E0 - E_min\n    # E2 = E_max  = E0 + eta_c*(c1+c2) - (1/eta_d)*(d1+d2) = E_max = eta_c*(c1+c2) - (1/eta_d)*(d1+d2) = E_max - E0\n    # E2 = E_min  = E0 + eta_c*(c1+c2) - (1/eta_d)*(d1+d2) = E_min = -eta_c*(c1+c2) + (1/eta_d)*(d1+d2) = E0 - E_min\n    A_ub = np.array([\n        [eta_c, 0, 0, -1/eta_d, 0, 0],\n        [-eta_c, 0, 0, 1/eta_d, 0, 0],\n        [eta_c, eta_c, 0, -1/eta_d, -1/eta_d, 0],\n        [-eta_c, -eta_c, 0, 1/eta_d, 1/eta_d, 0]\n    ])\n    b_ub = np.array([\n        E_max - E0,\n        E0 - E_min,\n        E_max - E0,\n        E0 - E_min\n    ])\n    \n    # 3. Bounds on variables: 0 = c_t = P_max_ch, 0 = d_t = P_max_dis\n    bounds = (\n        [(0, P_max_ch), (0, P_max_ch), (0, P_max_ch)] +\n        [(0, P_max_dis), (0, P_max_dis), (0, P_max_dis)]\n    )\n\n    # Solve the Linear Program\n    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if res.success:\n        # Clean up near-zero values from solver precision\n        solution = np.maximum(0, res.x)\n        c1, c2, c3 = solution[0:3]\n        d1, d2, d3 = solution[3:6]\n        # Profit is the negative of the minimized objective function value\n        profit = -res.fun\n        return [c1, c2, c3, d1, d2, d3, profit]\n    else:\n        # Should not happen for this well-posed problem, but handle defensively.\n        return [0.0] * 7\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Real-world energy systems are fraught with uncertainty, from volatile market prices to unpredictable renewable generation. This practice moves beyond deterministic models to explore the value of explicitly modeling this uncertainty. You will calculate the Value of the Stochastic Solution (VSS) and the Expected Value of Perfect Information (EVPI), two critical metrics that quantify the economic benefit of using advanced stochastic optimization methods. ",
            "id": "4103650",
            "problem": "Consider a two-stage, risk-neutral microgrid optimal scheduling problem with uncertain renewable generation represented by a random variable $\\xi$ taking finitely many scenarios $\\{\\xi_i\\}_{i=1}^S$ with probabilities $p_i$ satisfying $\\sum_{i=1}^S p_i = 1$ and $p_i \\geq 0$ for all $i$. The first-stage (day-ahead) decision $x$ is chosen before $\\xi$ is realized, and the second-stage (real-time) recourse decision $y(\\xi)$ is chosen after observing the scenario. The total cost is the sum of the first-stage cost and the scenario-dependent recourse cost, modeled under risk neutrality by the mathematical expectation. Fundamental principles to use are: the definition of expectation and the principle that optimizing with more information cannot worsen an optimal expected outcome under cost minimization.\n\nDefine the following problem constructs from first principles:\n- The Recourse Problem (RP): Choose the first-stage decision $x^{\\mathrm{RP}}$ to minimize the expected total cost $\\mathbb{E}[C_1(x) + Q(x,\\xi)]$, where $C_1(x)$ is the first-stage cost and $Q(x,\\xi)$ is the optimal recourse cost in scenario $\\xi$. Its optimal expected objective is denoted by $Z^{\\mathrm{RP}}$.\n- The Expected Value (EV) problem: Replace the random variable $\\xi$ with its expectation and optimize deterministically to obtain $x^{\\mathrm{EV}}$. The expected evaluation (EEV) is the expected total cost incurred when executing $x^{\\mathrm{EV}}$ in the original stochastic environment with optimal recourse in each scenario, denoted by $Z^{\\mathrm{EEV}}$.\n- The Wait-and-See (WS) construct: Assume perfect information; for each scenario $i$, choose scenario-specific first-stage and recourse decisions to minimize the scenario’s total cost, giving a scenario total $Z^{\\mathrm{WS}}(\\xi_i)$. The perfect-information expected total is $Z^{\\mathrm{WS}} = \\sum_{i=1}^S p_i Z^{\\mathrm{WS}}(\\xi_i)$.\n\nThese constructs satisfy $Z^{\\mathrm{WS}} \\leq Z^{\\mathrm{RP}} \\leq Z^{\\mathrm{EEV}}$ under cost minimization due to the informational advantage of WS over RP, and the suboptimality of fixing the EV decision relative to the RP decision when evaluated under uncertainty.\n\nYou are given, for each test case, scenario probabilities $p_i$, a scalar first-stage cost for the Expected Value decision $C_1^{\\mathrm{EV}}$, a list of scenario-wise recourse costs $Q^{\\mathrm{EV}}(\\xi_i)$ computed by optimally solving the second stage for each scenario under $x^{\\mathrm{EV}}$, a scalar first-stage cost for the Recourse Problem decision $C_1^{\\mathrm{RP}}$, a list of scenario-wise recourse costs $Q^{\\mathrm{RP}}(\\xi_i)$ computed under $x^{\\mathrm{RP}}$, and a list of scenario-wise total costs with perfect information $Z^{\\mathrm{WS}}(\\xi_i)$.\n\nFrom these quantities, compute:\n- The Value of the Stochastic Solution (VSS), defined as the improvement in expected total cost achieved by the Recourse Problem over the expected evaluation of the Expected Value decision, expressed as a difference in expected costs.\n- The Expected Value of Perfect Information (EVPI), defined as the improvement in expected total cost that perfect information would provide over the Recourse Problem, expressed as a difference in expected costs.\n\nUse the following test suite. All costs are expressed in United States Dollar (USD). Your program must compute the required metrics in USD and round each reported metric to two decimal places.\n\nTest Case $1$:\n- Scenario probabilities $p = [0.2, 0.5, 0.3]$.\n- Expected Value first-stage cost $C_1^{\\mathrm{EV}} = 500$.\n- Expected Value scenario recourse costs $Q^{\\mathrm{EV}}(\\xi) = [3000, 2200, 1500]$.\n- Recourse Problem first-stage cost $C_1^{\\mathrm{RP}} = 600$.\n- Recourse Problem scenario recourse costs $Q^{\\mathrm{RP}}(\\xi) = [2800, 2100, 1400]$.\n- Wait-and-See scenario total costs $Z^{\\mathrm{WS}}(\\xi) = [2500, 2000, 1300]$.\n\nTest Case $2$ (zero uncertainty):\n- Scenario probabilities $p = [0.4, 0.6]$.\n- Expected Value first-stage cost $C_1^{\\mathrm{EV}} = 200$.\n- Expected Value scenario recourse costs $Q^{\\mathrm{EV}}(\\xi) = [1000, 1000]$.\n- Recourse Problem first-stage cost $C_1^{\\mathrm{RP}} = 200$.\n- Recourse Problem scenario recourse costs $Q^{\\mathrm{RP}}(\\xi) = [1000, 1000]$.\n- Wait-and-See scenario total costs $Z^{\\mathrm{WS}}(\\xi) = [1200, 1200]$.\n\nTest Case $3$ (rare extreme scenario):\n- Scenario probabilities $p = [0.01, 0.49, 0.5]$.\n- Expected Value first-stage cost $C_1^{\\mathrm{EV}} = 400$.\n- Expected Value scenario recourse costs $Q^{\\mathrm{EV}}(\\xi) = [6000, 1800, 1600]$.\n- Recourse Problem first-stage cost $C_1^{\\mathrm{RP}} = 450$.\n- Recourse Problem scenario recourse costs $Q^{\\mathrm{RP}}(\\xi) = [5800, 1700, 1500]$.\n- Wait-and-See scenario total costs $Z^{\\mathrm{WS}}(\\xi) = [5700, 1650, 1450]$.\n\nTest Case $4$:\n- Scenario probabilities $p = [0.25, 0.25, 0.25, 0.25]$.\n- Expected Value first-stage cost $C_1^{\\mathrm{EV}} = 800$.\n- Expected Value scenario recourse costs $Q^{\\mathrm{EV}}(\\xi) = [2400, 2000, 1600, 1200]$.\n- Recourse Problem first-stage cost $C_1^{\\mathrm{RP}} = 820$.\n- Recourse Problem scenario recourse costs $Q^{\\mathrm{RP}}(\\xi) = [2300, 1950, 1550, 1150]$.\n- Wait-and-See scenario total costs $Z^{\\mathrm{WS}}(\\xi) = [2200, 1900, 1500, 1100]$.\n\nTest Case $5$ (zero-probability scenario present):\n- Scenario probabilities $p = [0.0, 0.7, 0.3]$.\n- Expected Value first-stage cost $C_1^{\\mathrm{EV}} = 300$.\n- Expected Value scenario recourse costs $Q^{\\mathrm{EV}}(\\xi) = [2000, 1500, 1000]$.\n- Recourse Problem first-stage cost $C_1^{\\mathrm{RP}} = 320$.\n- Recourse Problem scenario recourse costs $Q^{\\mathrm{RP}}(\\xi) = [1900, 1400, 900]$.\n- Wait-and-See scenario total costs $Z^{\\mathrm{WS}}(\\xi) = [1850, 1350, 850]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is a two-element list $[ \\mathrm{VSS}, \\mathrm{EVPI} ]$ in USD, rounded to two decimals. For example, the output format should be like $[[v_1,e_1],[v_2,e_2],\\dots]$, matching the order of the test cases above.",
            "solution": "The problem is validated as sound, well-posed, and consistent with the fundamental principles of two-stage stochastic programming. The data provided for all test cases satisfy the canonical inequality $Z^{\\mathrm{WS}} \\leq Z^{\\mathrm{RP}} \\leq Z^{\\mathrm{EEV}}$, which is a necessary condition for a physically meaningful cost-minimization problem under increasing levels of informational uncertainty.\n\nThe task is to compute the Value of the Stochastic Solution ($VSS$) and the Expected Value of Perfect Information ($EVPI$) for a series of test cases. These metrics are central to quantifying the value of using a stochastic model versus a deterministic one, and the potential benefit of acquiring perfect information, respectively.\n\nWe begin by formally defining the necessary quantities. Let the set of discrete scenarios be indexed by $i \\in \\{1, \\dots, S\\}$, with each scenario $\\xi_i$ occurring with probability $p_i$. For each test case, we are provided with the following values:\n- The scenario probabilities, $p = [p_1, \\dots, p_S]$.\n- The first-stage cost for the Expected Value (EV) solution, $C_1^{\\mathrm{EV}} = C_1(x^{\\mathrm{EV}})$.\n- The scenario-dependent second-stage recourse costs for the EV solution, $Q^{\\mathrm{EV}}(\\xi) = [Q(x^{\\mathrm{EV}}, \\xi_1), \\dots, Q(x^{\\mathrm{EV}}, \\xi_S)]$.\n- The first-stage cost for the Recourse Problem (RP) solution, $C_1^{\\mathrm{RP}} = C_1(x^{\\mathrm{RP}})$.\n- The scenario-dependent second-stage recourse costs for the RP solution, $Q^{\\mathrm{RP}}(\\xi) = [Q(x^{\\mathrm{RP}}, \\xi_1), \\dots, Q(x^{\\mathrm{RP}}, \\xi_S)]$.\n- The total scenario costs under perfect information (Wait-and-See, WS), $Z^{\\mathrm{WS}}(\\xi) = [Z^{\\mathrm{WS}}(\\xi_1), \\dots, Z^{\\mathrm{WS}}(\\xi_S)]$.\n\nFrom these inputs, we first calculate the expected total cost for each of the three modeling paradigms.\n\n1. The Expected Evaluation of the EV solution ($Z^{\\mathrm{EEV}}$) is the expected total cost when the decision $x^{\\mathrm{EV}}$, derived from a deterministic model using the mean of the random variable, is applied to the true stochastic environment. It is the sum of the first-stage cost and the expected recourse cost:\n$$Z^{\\mathrm{EEV}} = C_1^{\\mathrm{EV}} + \\mathbb{E}[Q(x^{\\mathrm{EV}},\\xi)] = C_1^{\\mathrm{EV}} + \\sum_{i=1}^{S} p_i Q(x^{\\mathrm{EV}}, \\xi_i)$$\n\n2. The optimal expected cost of the Recourse Problem ($Z^{\\mathrm{RP}}$) is the minimum achievable expected total cost obtained by solving the full two-stage stochastic problem. This solution $x^{\\mathrm{RP}}$ is optimal by design for the given uncertainty model. The cost is:\n$$Z^{\\mathrm{RP}} = C_1^{\\mathrm{RP}} + \\mathbb{E}[Q(x^{\\mathrm{RP}},\\xi)] = C_1^{\\mathrm{RP}} + \\sum_{i=1}^{S} p_i Q(x^{\\mathrm{RP}}, \\xi_i)$$\n\n3. The expected cost of the Wait-and-See solution ($Z^{\\mathrm{WS}}$) is the theoretical lower bound on expected cost, corresponding to having perfect foresight. It is the expectation over the scenario-optimal costs:\n$$Z^{\\mathrm{WS}} = \\mathbb{E}[Z^{\\mathrm{WS}}(\\xi)] = \\sum_{i=1}^{S} p_i Z^{\\mathrm{WS}}(\\xi_i)$$\n\nWith these expected costs established, the $VSS$ and $EVPI$ are defined as follows:\n\nThe Value of the Stochastic Solution ($VSS$) represents the cost savings of using the stochastic solution ($x^{\\mathrm{RP}}$) over the deterministic one ($x^{\\mathrm{EV}}$). It is the difference between their respective expected total costs:\n$$VSS = Z^{\\mathrm{EEV}} - Z^{\\mathrm{RP}}$$\n\nThe Expected Value of Perfect Information ($EVPI$) is the expected performance gain if one could know the outcome of the random variable in advance. It is the difference between the optimal cost under uncertainty and the theoretical cost with perfect foresight:\n$$EVPI = Z^{\\mathrm{RP}} - Z^{\\mathrm{WS}}$$\n\nWe now apply these formulas to each test case. All monetary values are in USD.\n\n**Test Case $1$**\nGiven: $p = [0.2, 0.5, 0.3]$, $C_1^{\\mathrm{EV}} = 500$, $Q^{\\mathrm{EV}}(\\xi) = [3000, 2200, 1500]$, $C_1^{\\mathrm{RP}} = 600$, $Q^{\\mathrm{RP}}(\\xi) = [2800, 2100, 1400]$, $Z^{\\mathrm{WS}}(\\xi) = [2500, 2000, 1300]$.\n$Z^{\\mathrm{EEV}} = 500 + (0.2)(3000) + (0.5)(2200) + (0.3)(1500) = 500 + 600 + 1100 + 450 = 2650$.\n$Z^{\\mathrm{RP}} = 600 + (0.2)(2800) + (0.5)(2100) + (0.3)(1400) = 600 + 560 + 1050 + 420 = 2630$.\n$Z^{\\mathrm{WS}} = (0.2)(2500) + (0.5)(2000) + (0.3)(1300) = 500 + 1000 + 390 = 1890$.\n$VSS = 2650 - 2630 = 20$.\n$EVPI = 2630 - 1890 = 740$.\nResult: $[20.00, 740.00]$.\n\n**Test Case $2$ (zero uncertainty)**\nGiven: $p = [0.4, 0.6]$, $C_1^{\\mathrm{EV}} = 200$, $Q^{\\mathrm{EV}}(\\xi) = [1000, 1000]$, $C_1^{\\mathrm{RP}} = 200$, $Q^{\\mathrm{RP}}(\\xi) = [1000, 1000]$, $Z^{\\mathrm{WS}}(\\xi) = [1200, 1200]$.\n$Z^{\\mathrm{EEV}} = 200 + (0.4)(1000) + (0.6)(1000) = 200 + 400 + 600 = 1200$.\n$Z^{\\mathrm{RP}} = 200 + (0.4)(1000) + (0.6)(1000) = 200 + 400 + 600 = 1200$.\n$Z^{\\mathrm{WS}} = (0.4)(1200) + (0.6)(1200) = 480 + 720 = 1200$.\n$VSS = 1200 - 1200 = 0$.\n$EVPI = 1200 - 1200 = 0$.\nResult: $[0.00, 0.00]$. As expected, in a deterministic setting, $VSS$ and $EVPI$ are zero.\n\n**Test Case $3$ (rare extreme scenario)**\nGiven: $p = [0.01, 0.49, 0.5]$, $C_1^{\\mathrm{EV}} = 400$, $Q^{\\mathrm{EV}}(\\xi) = [6000, 1800, 1600]$, $C_1^{\\mathrm{RP}} = 450$, $Q^{\\mathrm{RP}}(\\xi) = [5800, 1700, 1500]$, $Z^{\\mathrm{WS}}(\\xi) = [5700, 1650, 1450]$.\n$Z^{\\mathrm{EEV}} = 400 + (0.01)(6000) + (0.49)(1800) + (0.5)(1600) = 400 + 60 + 882 + 800 = 2142$.\n$Z^{\\mathrm{RP}} = 450 + (0.01)(5800) + (0.49)(1700) + (0.5)(1500) = 450 + 58 + 833 + 750 = 2091$.\n$Z^{\\mathrm{WS}} = (0.01)(5700) + (0.49)(1650) + (0.5)(1450) = 57 + 808.5 + 725 = 1590.5$.\n$VSS = 2142 - 2091 = 51$.\n$EVPI = 2091 - 1590.5 = 500.5$.\nResult: $[51.00, 500.50]$.\n\n**Test Case $4$**\nGiven: $p = [0.25, 0.25, 0.25, 0.25]$, $C_1^{\\mathrm{EV}} = 800$, $Q^{\\mathrm{EV}}(\\xi) = [2400, 2000, 1600, 1200]$, $C_1^{\\mathrm{RP}} = 820$, $Q^{\\mathrm{RP}}(\\xi) = [2300, 1950, 1550, 1150]$, $Z^{\\mathrm{WS}}(\\xi) = [2200, 1900, 1500, 1100]$.\n$Z^{\\mathrm{EEV}} = 800 + (0.25)(2400+2000+1600+1200) = 800 + (0.25)(7200) = 800 + 1800 = 2600$.\n$Z^{\\mathrm{RP}} = 820 + (0.25)(2300+1950+1550+1150) = 820 + (0.25)(6950) = 820 + 1737.5 = 2557.5$.\n$Z^{\\mathrm{WS}} = (0.25)(2200+1900+1500+1100) = (0.25)(6700) = 1675$.\n$VSS = 2600 - 2557.5 = 42.5$.\n$EVPI = 2557.5 - 1675 = 882.5$.\nResult: $[42.50, 882.50]$.\n\n**Test Case $5$ (zero-probability scenario present)**\nGiven: $p = [0.0, 0.7, 0.3]$, $C_1^{\\mathrm{EV}} = 300$, $Q^{\\mathrm{EV}}(\\xi) = [2000, 1500, 1000]$, $C_1^{\\mathrm{RP}} = 320$, $Q^{\\mathrm{RP}}(\\xi) = [1900, 1400, 900]$, $Z^{\\mathrm{WS}}(\\xi) = [1850, 1350, 850]$. The scenario with zero probability has no effect on the expected values.\n$Z^{\\mathrm{EEV}} = 300 + (0.0)(2000) + (0.7)(1500) + (0.3)(1000) = 300 + 0 + 1050 + 300 = 1650$.\n$Z^{\\mathrm{RP}} = 320 + (0.0)(1900) + (0.7)(1400) + (0.3)(900) = 320 + 0 + 980 + 270 = 1570$.\n$Z^{\\mathrm{WS}} = (0.0)(1850) + (0.7)(1350) + (0.3)(850) = 0 + 945 + 255 = 1200$.\n$VSS = 1650 - 1570 = 80$.\n$EVPI = 1570 - 1200 = 370$.\nResult: $[80.00, 370.00]$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Value of the Stochastic Solution (VSS) and the\n    Expected Value of Perfect Information (EVPI) for a series of\n    two-stage stochastic programming test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"p\": [0.2, 0.5, 0.3],\n            \"C1_EV\": 500,\n            \"Q_EV\": [3000, 2200, 1500],\n            \"C1_RP\": 600,\n            \"Q_RP\": [2800, 2100, 1400],\n            \"Z_WS_scenarios\": [2500, 2000, 1300],\n        },\n        # Test Case 2 (zero uncertainty)\n        {\n            \"p\": [0.4, 0.6],\n            \"C1_EV\": 200,\n            \"Q_EV\": [1000, 1000],\n            \"C1_RP\": 200,\n            \"Q_RP\": [1000, 1000],\n            \"Z_WS_scenarios\": [1200, 1200],\n        },\n        # Test Case 3 (rare extreme scenario)\n        {\n            \"p\": [0.01, 0.49, 0.5],\n            \"C1_EV\": 400,\n            \"Q_EV\": [6000, 1800, 1600],\n            \"C1_RP\": 450,\n            \"Q_RP\": [5800, 1700, 1500],\n            \"Z_WS_scenarios\": [5700, 1650, 1450],\n        },\n        # Test Case 4\n        {\n            \"p\": [0.25, 0.25, 0.25, 0.25],\n            \"C1_EV\": 800,\n            \"Q_EV\": [2400, 2000, 1600, 1200],\n            \"C1_RP\": 820,\n            \"Q_RP\": [2300, 1950, 1550, 1150],\n            \"Z_WS_scenarios\": [2200, 1900, 1500, 1100],\n        },\n        # Test Case 5 (zero-probability scenario present)\n        {\n            \"p\": [0.0, 0.7, 0.3],\n            \"C1_EV\": 300,\n            \"Q_EV\": [2000, 1500, 1000],\n            \"C1_RP\": 320,\n            \"Q_RP\": [1900, 1400, 900],\n            \"Z_WS_scenarios\": [1850, 1350, 850],\n        },\n    ]\n\n    results_list = []\n    for case in test_cases:\n        p = np.array(case[\"p\"])\n        C1_EV = case[\"C1_EV\"]\n        Q_EV_scenarios = np.array(case[\"Q_EV\"])\n        C1_RP = case[\"C1_RP\"]\n        Q_RP_scenarios = np.array(case[\"Q_RP\"])\n        Z_WS_scenarios = np.array(case[\"Z_WS_scenarios\"])\n\n        # Calculate Z_EEV (Expected cost of the Expected Value solution)\n        Z_EEV = C1_EV + np.dot(p, Q_EV_scenarios)\n        \n        # Calculate Z_RP (Expected cost of the Recourse Problem solution)\n        Z_RP = C1_RP + np.dot(p, Q_RP_scenarios)\n        \n        # Calculate Z_WS (Expected cost of the Wait-and-See solution)\n        Z_WS = np.dot(p, Z_WS_scenarios)\n        \n        # Calculate VSS (Value of the Stochastic Solution)\n        VSS = Z_EEV - Z_RP\n        \n        # Calculate EVPI (Expected Value of Perfect Information)\n        EVPI = Z_RP - Z_WS\n        \n        # Round to two decimal places and format for output\n        vss_rounded = round(VSS, 2)\n        evpi_rounded = round(EVPI, 2)\n        \n        # Store result as a formatted string: \"[vss,evpi]\"\n        results_list.append(f\"[{vss_rounded:.2f},{evpi_rounded:.2f}]\")\n\n    # Final print statement in the exact required format: \"[[v1,e1],[v2,e2],...]\"\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established the value of stochastic programming, we now turn to a powerful technique for solving these often large-scale and complex problems. This exercise guides you through implementing Benders decomposition, a classic method that splits a problem into a master problem for strategic decisions and subproblems for operational adjustments. This practice provides direct experience with an advanced computational technique essential for tackling realistic microgrid scheduling challenges under uncertainty. ",
            "id": "4103624",
            "problem": "Consider a two-stage microgrid optimal scheduling problem over $T$ discrete time periods with scenario-wise uncertainty in net demand. The microgrid has two dispatchable generators and an external grid connection with a per-period import capacity limit. The first stage decides binary commitments of the generators, and the second stage decides, for each scenario independently, economic dispatch subject to the first-stage commitments. Your task is to implement Benders decomposition by separating the first-stage commitments and the second-stage scenario-wise dispatch, and to derive optimality and feasibility cuts that iteratively refine the master problem.\n\nFundamental base and definitions:\n- Let $y_1 \\in \\{0,1\\}$ and $y_2 \\in \\{0,1\\}$ be first-stage commitment decisions for generator $1$ and generator $2$, respectively. The binary value indicates whether a generator is committed (on) or not (off).\n- For each scenario $s \\in \\mathcal{S}$ and each time period $t \\in \\{1,\\dots,T\\}$, define net deficit $d_{s,t} = D_{s,t} - \\text{PV}_{s,t}$, where $D_{s,t}$ is the demand and $\\text{PV}_{s,t}$ is the renewable photovoltaic generation. Each period is of duration $1$ hour, so power in $\\text{kW}$ equals energy in $\\text{kWh}$ over the period.\n- Second-stage decision variables under scenario $s$ are $g_{1,t} \\ge 0$, $g_{2,t} \\ge 0$ (generator outputs), and $g^{\\text{grid}}_{t} \\ge 0$ (grid import), for $t=1,\\dots,T$.\n- Generator capacities are $C_1$ and $C_2$ in $\\text{kW}$; grid import capacity per period is $G^{\\max}_t$ in $\\text{kW}$. Variable generation costs are $c_1$, $c_2$, and grid energy price $c_G$ in $\\$/\\text{kWh}$. Fixed commitment costs are $F_1$ and $F_2$ in $\\$$.\n- The second-stage dispatch problem for scenario $s$ is a linear program that minimizes operating cost subject to per-period balance and capacity constraints.\n- The Benders master problem includes first-stage costs and a scenario-wise recourse cost approximation via variables $\\theta_s$, refined iteratively using cuts derived from duality of the second-stage linear programs and feasibility conditions.\n\nYou must start from linear programming duality and feasibility conditions and derive:\n- For each scenario $s$, an optimality cut of the form $\\theta_s \\ge \\alpha_s + \\beta_{1,s} y_1 + \\beta_{2,s} y_2$ using the dual multipliers of the second-stage linear program.\n- If a scenario’s second-stage dispatch is infeasible for a given $(y_1,y_2)$, a feasibility cut ensuring sufficient committed capacity in each time period: $C_1 y_1 + C_2 y_2 \\ge \\max\\{d_{s,t} - G^{\\max}_t, 0\\}$ for all $t$ in that scenario.\n\nImplement an iterative Benders algorithm:\n- Initialize with no optimality cuts and no feasibility cuts.\n- At each iteration, solve the master problem by enumerating all binary combinations of $(y_1,y_2)$ and selecting the feasible one (w.r.t. accumulated feasibility cuts) that minimizes the current master objective with $\\theta_s$ replaced by the maximum of existing optimality cuts for scenario $s$ evaluated at $(y_1,y_2)$, or $0$ if no optimality cut exists yet for $s$.\n- Given the selected $(y_1,y_2)$, solve each scenario’s second-stage dispatch linear program. If feasible, add its optimality cut; if infeasible, add feasibility cuts for all periods with unmet deficit. Maintain and update global lower and upper bounds until convergence or until all feasible $(y_1,y_2)$ combinations have been processed.\n\nPhysical and numerical units:\n- All power and energy quantities must be treated in $\\text{kW}$ and $\\text{kWh}$. All costs must be in dollars $\\$$. Express the final expected total cost for each test case in dollars, rounded to two decimal places.\n\nTest suite and parameter specification:\nImplement the above for the following three test cases. Each test case is a tuple of parameters ($T$, $C_1$, $C_2$, $c_1$, $c_2$, $c_G$, $F_1$, $F_2$, $\\{G^{\\max}_t\\}_{t=1}^T$, $\\mathcal{S}$, $\\{p_s\\}_{s \\in \\mathcal{S}}$), where scenario data include $\\{D_{s,t}\\}_{t=1}^T$ and $\\{\\text{PV}_{s,t}\\}_{t=1}^T$.\n\n- Test Case $1$ (happy path; grid and photovoltaic suffice without commitments):\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$.\n  - $G^{\\max} = [80, 80, 80]$.\n  - Scenarios $\\mathcal{S} = \\{A, B\\}$ with probabilities $p_A = 0.5$, $p_B = 0.5$.\n  - Scenario $A$: $D_{A} = [70, 60, 50]$, $\\text{PV}_{A} = [30, 40, 50]$.\n  - Scenario $B$: $D_{B} = [60, 55, 65]$, $\\text{PV}_{B} = [35, 25, 30]$.\n\n- Test Case $2$ (grid-limited; at least one generator must commit):\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$.\n  - $G^{\\max} = [20, 20, 20]$.\n  - Scenarios $\\mathcal{S} = \\{A, B\\}$ with probabilities $p_A = 0.5$, $p_B = 0.5$.\n  - Scenario $A$: $D_{A} = [70, 60, 50]$, $\\text{PV}_{A} = [30, 40, 50]$.\n  - Scenario $B$: $D_{B} = [60, 55, 65]$, $\\text{PV}_{B} = [35, 25, 30]$.\n\n- Test Case $3$ (boundary; both generators required to satisfy all periods):\n  - $T = 3$, $C_1 = 50$, $C_2 = 40$, $c_1 = 0.18$, $c_2 = 0.22$, $c_G = 0.25$, $F_1 = 100$, $F_2 = 80$.\n  - $G^{\\max} = [0, 0, 0]$.\n  - Scenarios $\\mathcal{S} = \\{C\\}$ with probability $p_C = 1.0$.\n  - Scenario $C$: $D_{C} = [100, 100, 100]$, $\\text{PV}_{C} = [10, 10, 10]$.\n\nFinal output format:\nYour program should produce a single line of output containing the expected total optimal cost for each of the three test cases, as a comma-separated list enclosed in square brackets (e.g., \"[$x_1$,$x_2$,$x_3$]\"), where each $x_i$ is a float rounded to two decimals in $\\$$.",
            "solution": "The user has specified a two-stage stochastic optimization problem for microgrid scheduling, to be solved using Benders decomposition. The problem is well-defined, scientifically grounded in power systems engineering and operations research, and all necessary parameters for the specified test cases are provided. The problem is thus deemed valid.\n\nThe solution approach involves decomposing the problem into a master problem for first-stage generator commitment decisions and a set of second-stage subproblems for the economic dispatch under each uncertain scenario. The master problem is iteratively refined by adding optimality and feasibility cuts derived from the subproblems.\n\n### Mathematical Formulation\n\nThe overall objective is to minimize the sum of first-stage fixed costs and the expected second-stage operational costs.\n\n**First-Stage (Master) Problem**\nThe master problem decides the binary generator commitment variables $y_1, y_2 \\in \\{0, 1\\}$. Its objective function includes the fixed commitment costs and an approximation of the expected second-stage costs, represented by recourse variables $\\theta_s \\ge 0$ for each scenario $s \\in \\mathcal{S}$.\n\n$$\n\\min_{y_1, y_2, \\theta_s} \\quad F_1 y_1 + F_2 y_2 + \\sum_{s \\in \\mathcal{S}} p_s \\theta_s\n$$\nSubject to:\n$$\ny_1, y_2 \\in \\{0, 1\\}\n$$\n$$\n\\theta_s \\ge 0 \\quad \\forall s \\in \\mathcal{S}\n$$\nAnd a set of Benders cuts (optimality and feasibility) that are added iteratively.\n\n**Second-Stage (Subproblem)**\nFor a given first-stage decision $(\\bar{y}_1, \\bar{y}_2)$ and a specific scenario $s$, the second-stage subproblem is a linear program (LP) that minimizes the operational cost. The full subproblem is separable by time period $t \\in \\{1, \\dots, T\\}$. For each period, we solve:\n\n$$\nQ_{s,t}(\\bar{y}_1, \\bar{y}_2) = \\min_{g_{1,t}, g_{2,t}, g^{\\text{grid}}_{t}} \\quad c_1 g_{1,t} + c_2 g_{2,t} + c_G g^{\\text{grid}}_{t}\n$$\nSubject to:\n\\begin{align*}\n(S1_t):  \\quad g_{1,t} + g_{2,t} + g^{\\text{grid}}_{t} \\ge d_{s,t}  [\\lambda_{s,t} \\ge 0] \\\\\n(S2_{1,t}):  \\quad g_{1,t} \\le C_1 \\bar{y}_1  [\\mu_{1,s,t} \\ge 0] \\\\\n(S3_{2,t}):  \\quad g_{2,t} \\le C_2 \\bar{y}_2  [\\mu_{2,s,t} \\ge 0] \\\\\n(S4_t):  \\quad g^{\\text{grid}}_{t} \\le G^{\\max}_t  [\\nu_{s,t} \\ge 0] \\\\\n \\quad g_{1,t}, g_{2,t}, g^{\\text{grid}}_{t} \\ge 0\n\\end{align*}\nThe total second-stage cost for scenario $s$ is $Q_s(\\bar{y}_1, \\bar{y}_2) = \\sum_{t=1}^T Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$. The dual variables for each constraint are indicated in brackets.\n\n### Benders Cut Derivation\n\n**1. Feasibility Cut**\nThe subproblem for a given period $t$ and scenario $s$ is infeasible if the total available generation capacity is less than the net deficit $d_{s,t} = D_{s,t} - \\text{PV}_{s,t}$. The maximum available supply is $C_1 \\bar{y}_1 + C_2 \\bar{y}_2 + G^{\\max}_t$. Feasibility requires:\n$$\nC_1 \\bar{y}_1 + C_2 \\bar{y}_2 + G^{\\max}_t \\ge d_{s,t}\n$$\nIf this condition is violated for a particular $(\\bar{y}_1, \\bar{y}_2)$, a feasibility cut is generated and added to the master problem to exclude such infeasible commitment decisions in future iterations. The cut is formulated for general $y_1, y_2$:\n$$\nC_1 y_1 + C_2 y_2 \\ge d_{s,t} - G^{\\max}_t\n$$\nSince the left side is non-negative, this cut is only meaningful if the right side is positive. Thus, for each period $t'$ where the subproblem under scenario $s$ is infeasible, we add the following cut:\n$$\nC_1 y_1 + C_2 y_2 \\ge \\max\\{0, d_{s,t'} - G^{\\max}_{t'}\\}\n$$\n\n**2. Optimality Cut**\nIf the subproblem for scenario $s$ is feasible for a given $(\\bar{y}_1, \\bar{y}_2)$, an optimality cut is generated from its dual. The dual of the per-period subproblem is:\n$$\n\\max_{\\lambda, \\mu, \\nu} \\quad d_{s,t} \\lambda_{s,t} - C_1 \\bar{y}_1 \\mu_{1,s,t} - C_2 \\bar{y}_2 \\mu_{2,s,t} - G^{\\max}_t \\nu_{s,t}\n$$\nSubject to:\n\\begin{align*}\n\\lambda_{s,t} - \\mu_{1,s,t} \\le c_1 \\\\\n\\lambda_{s,t} - \\mu_{2,s,t} \\le c_2 \\\\\n\\lambda_{s,t} - \\nu_{s,t} \\le c_G \\\\\n\\lambda_{s,t}, \\mu_{1,s,t}, \\mu_{2,s,t}, \\nu_{s,t} \\ge 0\n\\end{align*}\nBy strong duality, the optimal objective value of the primal subproblem, $Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$, is equal to the optimal value of this dual. Let $(\\bar{\\lambda}_{s,t}, \\bar{\\mu}_{1,s,t}, \\bar{\\mu}_{2,s,t}, \\bar{\\nu}_{s,t})$ be the optimal dual variables. The value $Q_s(\\bar{y}_1, \\bar{y}_2) = \\sum_t Q_{s,t}(\\bar{y}_1, \\bar{y}_2)$ provides a value for $\\theta_s$ that serves as a lower bound for any feasible commitment. An optimality cut is a linear under-approximation of the recourse function $Q_s(y_1, y_2)$. It takes the form:\n$$\n\\theta_s \\ge Q_s(\\bar{y}_1, \\bar{y}_2) + \\nabla Q_s(\\bar{y}_1, \\bar{y}_2)^T \\begin{pmatrix} y_1 - \\bar{y}_1 \\\\ y_2 - \\bar{y}_2 \\end{pmatrix}\n$$\nThe gradient components are $\\frac{\\partial Q_s}{\\partial y_i} = - \\sum_{t=1}^T C_i \\bar{\\mu}_{i,s,t}$. This leads to the cut $\\theta_s \\ge \\alpha_s + \\beta_{1,s} y_1 + \\beta_{2,s} y_2$, where:\n$$\n\\alpha_s = \\sum_{t=1}^T (d_{s,t} \\bar{\\lambda}_{s,t} - G^{\\max}_t \\bar{\\nu}_{s,t})\n$$\n$$\n\\beta_{1,s} = - \\sum_{t=1}^T C_1 \\bar{\\mu}_{1,s,t}\n$$\n$$\n\\beta_{2,s} = - \\sum_{t=1}^T C_2 \\bar{\\mu}_{2,s,t}\n$$\nThis cut is added to the master problem, improving its approximation of the second-stage cost function.\n\n### Benders Decomposition Algorithm\n\nThe iterative algorithm proceeds as follows:\n\n1.  **Initialization**: Initialize a global lower bound $LB = -\\infty$ and an upper bound $UB = +\\infty$. The sets of optimality and feasibility cuts are empty.\n2.  **Master Problem Solution**: At each iteration, solve the master problem. Given the small scale of the first-stage decisions ($2^2=4$ combinations), this is done by enumerating all pairs $(y_1, y_2) \\in \\{(0,0), (0,1), (1,0), (1,1)\\}$. For each pair:\n    *   Check if it satisfies all current feasibility cuts.\n    *   If feasible, calculate its master objective value $F_1 y_1 + F_2 y_2 + \\sum_s p_s \\theta_s$, where each $\\theta_s$ is the maximum value returned by evaluating all existing optimality cuts for that scenario at $(y_1, y_2)$.\n    *   The pair $(y_1^{(k)}, y_2^{(k)})$ with the minimum master objective value is chosen. This objective value, $Z_{MP}^{(k)}$, updates the global lower bound: $LB = \\max(LB, Z_{MP}^{(k)})$.\n3.  **Subproblem Solution**: For the chosen $(y_1^{(k)}, y_2^{(k)})$, solve the second-stage LP for each scenario $s \\in \\mathcal{S}$.\n    *   If the subproblem for any scenario $s$ is infeasible (for any period $t$), add the corresponding feasibility cut(s) to the master problem. The true cost for this commitment is infinite.\n    *   If the subproblems for all scenarios are feasible, calculate the total true cost: $Z^{(k)} = F_1 y_1^{(k)} + F_2 y_2^{(k)} + \\sum_s p_s Q_s(y_1^{(k)}, y_2^{(k)})$. This value updates the global upper bound: $UB = \\min(UB, Z^{(k)})$. For each scenario $s$, an optimality cut is generated using the dual variables from its subproblem solution and added to the master problem.\n4.  **Convergence Check**: The algorithm terminates if the gap between the upper and lower bounds is below a small tolerance ($UB - LB \\le \\epsilon$), or if all four possible commitment combinations have been evaluated via the subproblems. The optimal solution is the commitment decision that produced the best upper bound, and the optimal value is $UB$.\n\nThis procedure is implemented to solve the three specified test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the solution process.\n    \"\"\"\n    # Test Case 1: Happy path; grid and PV suffice\n    case1 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([80, 80, 80]),\n        \"scenarios\": [\n            {\n                \"id\": \"A\", \"prob\": 0.5,\n                \"D\": np.array([70, 60, 50]), \"PV\": np.array([30, 40, 50])\n            },\n            {\n                \"id\": \"B\", \"prob\": 0.5,\n                \"D\": np.array([60, 55, 65]), \"PV\": np.array([35, 25, 30])\n            }\n        ]\n    }\n\n    # Test Case 2: Grid-limited; at least one generator needed\n    case2 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([20, 20, 20]),\n        \"scenarios\": [\n            {\n                \"id\": \"A\", \"prob\": 0.5,\n                \"D\": np.array([70, 60, 50]), \"PV\": np.array([30, 40, 50])\n            },\n            {\n                \"id\": \"B\", \"prob\": 0.5,\n                \"D\": np.array([60, 55, 65]), \"PV\": np.array([35, 25, 30])\n            }\n        ]\n    }\n\n    # Test Case 3: Boundary; both generators required\n    case3 = {\n        \"T\": 3, \"C1\": 50, \"C2\": 40, \"c1\": 0.18, \"c2\": 0.22, \"cG\": 0.25,\n        \"F1\": 100, \"F2\": 80, \"G_max\": np.array([0, 0, 0]),\n        \"scenarios\": [\n            {\n                \"id\": \"C\", \"prob\": 1.0,\n                \"D\": np.array([100, 100, 100]), \"PV\": np.array([10, 10, 10])\n            }\n        ]\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        cost = run_benders_for_case(case)\n        results.append(f\"{cost:.2f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_subproblem(s_data, y, params, s_idx):\n    \"\"\"\n    Solves the second-stage LP for a given scenario and commitment decision.\n    \"\"\"\n    y1, y2 = y\n    T, C1, C2, c1, c2, cG = params[\"T\"], params[\"C1\"], params[\"C2\"], params[\"c1\"], params[\"c2\"], params[\"cG\"]\n    G_max = params[\"G_max\"]\n    \n    total_cost_s = 0.0\n    alpha_s, beta1_s, beta2_s = 0.0, 0.0, 0.0\n    \n    infeasible_periods = []\n    d_s = s_data['D'] - s_data['PV']\n\n    for t in range(T):\n        net_deficit_t = max(0, d_s[t])\n\n        c = np.array([c1, c2, cG])\n        A_ub = np.array([\n            [-1, -1, -1],  # g1+g2+g_grid = d_st\n            [1, 0, 0],     # g1 = C1*y1\n            [0, 1, 0],     # g2 = C2*y2\n            [0, 0, 1]      # g_grid = G_max_t\n        ])\n        b_ub = np.array([-net_deficit_t, C1 * y1, C2 * y2, G_max[t]])\n        \n        bounds = [(0, None), (0, None), (0, None)]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.status == 2: # Infeasible\n            infeasible_periods.append(t)\n        elif not res.success: # other errors\n            # For this problem, non-success other than infeasibility is unexpected\n            # but treat as infeasible to be safe.\n            infeasible_periods.append(t)\n        else:\n            total_cost_s += res.fun\n            \n            duals = res.ineqlin.marginals\n            # The 'highs' solver returns non-positive duals (marginals) for constraints of the form A_ub @ x = b_ub.\n            # The standard Benders cut formulation uses non-negative dual variables (Lagrange multipliers).\n            # We must therefore negate the marginals returned by SciPy.\n            lambda_st = -duals[0] # Dual for demand satisfaction\n            mu1_st = -duals[1]    # Dual for gen 1 capacity\n            mu2_st = -duals[2]    # Dual for gen 2 capacity\n            nu_st = -duals[3]     # Dual for grid capacity\n\n            # alpha is the constant part of the cut, derived from the dual objective value at y=0.\n            alpha_s += lambda_st * net_deficit_t - nu_st * G_max[t]\n            # beta1 is the coefficient for y1, derived from the sensitivity to generator 1 capacity.\n            beta1_s -= mu1_st * C1\n            # beta2 is the coefficient for y2, derived from the sensitivity to generator 2 capacity.\n            beta2_s -= mu2_st * C2\n\n    if infeasible_periods:\n        cuts = []\n        for t_inf in infeasible_periods:\n            rhs = max(0, d_s[t_inf] - G_max[t_inf])\n            cut = {'coeffs': [C1, C2], 'rhs': rhs}\n            cuts.append(cut)\n        return {'status': 'infeasible', 'cuts': cuts}\n    \n    cut = {'type': 'optimality', 's_idx': s_idx, 'params': (alpha_s, beta1_s, beta2_s)}\n    return {'status': 'feasible', 'cost': total_cost_s, 'cut': cut}\n\ndef run_benders_for_case(params):\n    \"\"\"\n    Executes the Benders decomposition algorithm for a single test case.\n    \"\"\"\n    y_options = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    optimality_cuts = {i: [] for i, _ in enumerate(params[\"scenarios\"])}\n    feasibility_cuts = []\n    \n    lower_bound = -np.inf\n    upper_bound = np.inf\n    \n    y_processed = set()\n    \n    max_iter = len(y_options) + 2  # Sufficient iterations for this small problem\n\n    for _ in range(max_iter):\n        \n        # 1. Solve Master Problem by enumeration\n        master_results = {}\n        for y_candidate in y_options:\n            y1, y2 = y_candidate\n\n            # Check feasibility cuts\n            is_feasible = all(c['coeffs'][0] * y1 + c['coeffs'][1] * y2 = c['rhs'] for c in feasibility_cuts)\n            if not is_feasible:\n                continue\n\n            # Calculate objective for this y\n            first_stage_cost = params['F1'] * y1 + params['F2'] * y2\n            expected_recourse_cost = 0.0\n            for s_idx, s_data in enumerate(params[\"scenarios\"]):\n                theta_s = 0.0\n                for o_cut_params in optimality_cuts[s_idx]:\n                    alpha, beta1, beta2 = o_cut_params\n                    cut_val = alpha + beta1 * y1 + beta2 * y2\n                    theta_s = max(theta_s, cut_val)\n                expected_recourse_cost += s_data['prob'] * theta_s\n            \n            total_master_cost = first_stage_cost + expected_recourse_cost\n            master_results[y_candidate] = total_master_cost\n            \n        if not master_results:\n            break # All combinations are infeasible\n        \n        current_y = min(master_results, key=master_results.get)\n        current_lb = master_results[current_y]\n        lower_bound = max(lower_bound, current_lb)\n        \n        y_processed.add(current_y)\n        \n        # 2. Solve Subproblems for current_y\n        y1_k, y2_k = current_y\n        total_second_stage_real_cost = 0.0\n        all_subproblems_feasible = True\n        new_feasibility_cuts = []\n        \n        for s_idx, s_data in enumerate(params[\"scenarios\"]):\n            sub_result = solve_subproblem(s_data, current_y, params, s_idx)\n            \n            if sub_result['status'] == 'infeasible':\n                all_subproblems_feasible = False\n                new_feasibility_cuts.extend(sub_result['cuts'])\n                break\n            else:\n                total_second_stage_real_cost += s_data['prob'] * sub_result['cost']\n                optimality_cuts[s_idx].append(sub_result['cut']['params'])\n\n        if all_subproblems_feasible:\n            current_ub = (params['F1'] * y1_k + params['F2'] * y2_k) + total_second_stage_real_cost\n            upper_bound = min(upper_bound, current_ub)\n        else:\n             for f_cut in new_feasibility_cuts:\n                if not any(np.array_equal(c['coeffs'], f_cut['coeffs']) and c['rhs'] == f_cut['rhs'] for c in feasibility_cuts):\n                    feasibility_cuts.append(f_cut)\n\n        # 3. Check Convergence\n        if upper_bound - lower_bound = 1e-6:\n            break\n        if len(y_processed) == len(y_options):\n            break\n\n    return upper_bound if upper_bound != np.inf else 0.0\n\nsolve()\n```"
        }
    ]
}