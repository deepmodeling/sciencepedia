{
    "hands_on_practices": [
        {
            "introduction": "在任何可再生能源系统建模中，首要任务是将原始的气象数据（如风速和太阳辐照度）转化为有意义的能源产出指标。本练习旨在通过构建基于物理原理的计算模型，将时间序列数据转换为风力和光伏发电系统的容量因子。通过这个实践，您将掌握将抽象气象信息与具体发电性能联系起来的核心技能，为后续更复杂的时空资源评估和电网集成分析奠定坚实基础。",
            "id": "4093383",
            "problem": "地理空间和高分辨率时空资源建模工作流通常需要将小时资源序列转换为风力涡轮机和光伏系统的容量因子场。从基本物理关系出发，推导算法方法，以映射小时风速序列 $v(t)$ 到基于物理功率曲线的涡轮机功率输出，以及小时阵列平面辐照度序列 $POA(t)$ (记作 $G(t)$) 和环境温度序列 $T_{\\mathrm{amb}}(t)$ 到基于温度调整性能模型的光伏功率输出。使用这些方法计算每个站点的容量因子，即发电量与同期在额定功率下可产生的能量之比。容量因子是无量纲的，必须以小数形式表示。\n\n您的推导必须从一个有效的基础出发。对于风能，从通过一个区域的动能通量以及涡轮机功率曲线强制执行的切入、额定和切出行为的概念开始。对于光伏，从阵列平面辐照度通过标准测试条件下的组件效率和线性温度系数转换为直流功率开始，其中电池温度由标称工作电池温度估算。不应假定任何快捷公式；从这些基础逻辑地推导出每个映射关系。确保所有算法选择都具有科学真实性。\n\n单位必须使用如下：\n- 风速单位为 $\\mathrm{m/s}$。\n- 辐照度单位为 $\\mathrm{W/m^2}$。\n- 环境和电池温度单位为 $^\\circ\\mathrm{C}$。\n- 功率单位为 $\\mathrm{kW}$。\n- 容量因子为无量纲小数。\n\n将包含 $N$ 个小时样本的时间序列的容量因子定义为 $CF = \\dfrac{\\sum_{t=1}^{N} P(t)}{P_{\\mathrm{rated}} \\cdot N}$，其中 $P(t)$ 是第 $t$ 小时的功率，$P_{\\mathrm{rated}}$ 是额定功率。该定义普遍适用；当所提供的序列跨越一整年时，它将得出年容量因子。\n\n实现所推导的方法，并为以下测试套件计算容量因子，每个案例代表一个不同的场站或网格单元：\n\n- 风能案例 A (理想情况)：\n  - 额定功率 $P_{\\mathrm{rated}} = 3000\\,\\mathrm{kW}$。\n  - 切入风速 $v_{\\mathrm{ci}} = 3\\,\\mathrm{m/s}$。\n  - 额定风速 $v_{\\mathrm{r}} = 12\\,\\mathrm{m/s}$。\n  - 切出风速 $v_{\\mathrm{co}} = 25\\,\\mathrm{m/s}$。\n  - $N=10$ 小时的小时风速 $v(t)$：$[0, 2.5, 3, 6, 10, 12, 15, 24, 26, 8]$，单位 $\\mathrm{m/s}$。\n\n- 风能案例 B (边缘案例，始终低于切入风速)：\n  - 额定功率 $P_{\\mathrm{rated}} = 3000\\,\\mathrm{kW}$。\n  - 切入风速 $v_{\\mathrm{ci}} = 3\\,\\mathrm{m/s}$。\n  - 额定风速 $v_{\\mathrm{r}} = 12\\,\\mathrm{m/s}$。\n  - 切出风速 $v_{\\mathrm{co}} = 25\\,\\mathrm{m/s}$。\n  - $N=10$ 小时的小时风速 $v(t)$：$[0, 1, 2, 2.9, 0.5, 2.8, 2.999, 2, 1.5, 0]$，单位 $\\mathrm{m/s}$。\n\n- 光伏案例 C (昼夜变化，无削波)：\n  - 额定功率 $P_{\\mathrm{rated}} = 500\\,\\mathrm{kW}$。\n  - 标准测试条件下的参考组件效率 $\\eta_{\\mathrm{ref}} = 0.18$。\n  - 功率温度系数 $\\beta = -0.004\\,^\\circ\\mathrm{C}^{-1}$。\n  - 标称工作电池温度 $NOCT = 45\\,^\\circ\\mathrm{C}$。\n  - $N=10$ 小时的小时阵列平面辐照度 $G(t)$：$[0, 0, 200, 400, 600, 800, 1000, 800, 400, 0]$，单位 $\\mathrm{W/m^2}$。\n  - $N=10$ 小时的小时环境温度 $T_{\\mathrm{amb}}(t)$：$[15, 15, 16, 17, 18, 20, 22, 24, 22, 18]$，单位 $^\\circ\\mathrm{C}$。\n\n- 光伏案例 D (高辐照度伴随逆变器削波)：\n  - 额定功率 $P_{\\mathrm{rated}} = 1000\\,\\mathrm{kW}$。\n  - 标准测试条件下的参考组件效率 $\\eta_{\\mathrm{ref}} = 0.18$。\n  - 功率温度系数 $\\beta = -0.004\\,^\\circ\\mathrm{C}^{-1}$。\n  - 标称工作电池温度 $NOCT = 45\\,^\\circ\\mathrm{C}$。\n  - $N=10$ 小时的小时阵列平面辐照度 $G(t)$：$[0, 300, 600, 900, 1100, 1200, 1100, 900, 600, 300]$，单位 $\\mathrm{W/m^2}$。\n  - $N=10$ 小时的小时环境温度 $T_{\\mathrm{amb}}(t)$：$[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$，单位 $^\\circ\\mathrm{C}$。\n\n您的程序应生成单行输出，其中包含与上述案例相对应的四个容量因子值，四舍五入到六位小数，以方括号括起来的逗号分隔列表形式表示，例如 $[x_1, x_2, x_3, x_4]$。",
            "solution": "问题要求推导并实现算法方法，用于根据小时时间序列数据计算风能和光伏（PV）发电系统的容量因子。推导必须源于指定的基本物理原理。\n\n首先，我们来处理风力涡轮机模型。风中的可用功率源于运动空气的动能。质量为 $m$、速度为 $v$ 的空气的动能 $E_k$ 由 $E_k = \\frac{1}{2}mv^2$ 给出。功率是能量流动的速率。考虑在时间 $\\Delta t$ 内通过涡轮机转子面积 $A$ 的气流，空气体积为 $V = A \\cdot v \\cdot \\Delta t$。设空气密度为 $\\rho$，则质量为 $m = \\rho V = \\rho A v \\Delta t$。因此，动能通量，即风中功率为 $P_{\\text{wind}} = \\frac{E_k}{\\Delta t} = \\frac{1}{2}\\rho A v^3$。这确定了可用功率与风速的立方成正比，即 $P_{\\text{wind}} \\propto v^3$。\n\n实际风力涡轮机的电功率输出 $P(t)$ 由功率曲线描述，该曲线是瞬时风速 $v(t)$ 的函数。该曲线由基于切入风速 $v_{\\mathrm{ci}}$、额定风速 $v_{\\mathrm{r}}$ 和切出风速 $v_{\\mathrm{co}}$ 的四个运行区域定义。\n1.  对于 $v(t)  v_{\\mathrm{ci}}$，风速不足以克服涡轮机的机械和电气损耗，因此功率输出为零：$P(t) = 0$。\n2.  对于 $v_{\\mathrm{ci}} \\le v(t)  v_{\\mathrm{r}}$，涡轮机发电。遵循提取的功率应与风中可用功率相关的物理动机，该区域的输出被建模为 $v(t)^3$ 的函数。一个满足边界条件 $P(v_{\\mathrm{ci}}) = 0$ 和 $P(v_{\\mathrm{r}}) = P_{\\mathrm{rated}}$ 的常见且物理上一致的模型是按比例缩放的立方函数：\n    $$P(t) = P_{\\mathrm{rated}} \\cdot \\left( \\frac{v(t)^3 - v_{\\mathrm{ci}}^3}{v_{\\mathrm{r}}^3 - v_{\\mathrm{ci}}^3} \\right)$$\n    这确保了平滑且基于物理的功率爬升。\n3.  对于 $v_{\\mathrm{r}} \\le v(t)  v_{\\mathrm{co}}$，涡轮机的控制系统将其输出限制在额定功率 $P_{\\mathrm{rated}}$，以保护发电机和电力电子设备。因此，$P(t) = P_{\\mathrm{rated}}$。\n4.  对于 $v(t) \\ge v_{\\mathrm{co}}$，涡轮机关闭以防止极端风荷载造成的结构性损坏。功率输出降至零：$P(t) = 0$。\n\n结合这些区域，从 $v(t)$到 $P(t)$ 的风力涡轮机完整算法映射为：\n$$\nP(t) = \n\\begin{cases} \n0  \\text{若 } v(t)  v_{\\mathrm{ci}} \\text{ 或 } v(t) \\ge v_{\\mathrm{co}} \\\\\nP_{\\mathrm{rated}} \\cdot \\left(\\frac{v(t)^3 - v_{\\mathrm{ci}}^3}{v_{\\mathrm{r}}^3 - v_{\\mathrm{ci}}^3}\\right)  \\text{若 } v_{\\mathrm{ci}} \\le v(t)  v_{\\mathrm{r}} \\\\\nP_{\\mathrm{rated}}  \\text{若 } v_{\\mathrm{r}} \\le v(t)  v_{\\mathrm{co}}\n\\end{cases}\n$$\n\n接下来，我们来处理光伏（PV）系统模型。光伏系统产生的功率取决于入射的太阳辐照度、系统面积及其转换效率。额定功率 $P_{\\mathrm{rated}}$ 是在标准测试条件（STC）下指定的，即参考辐照度 $G_{\\mathrm{ref}} = 1000\\,\\mathrm{W/m^2}$ 和参考电池温度 $T_{\\mathrm{ref}} = 25\\,^\\circ\\mathrm{C}$。在这些条件下，功率为 $P_{\\mathrm{rated}} = G_{\\mathrm{ref}} \\cdot A_{\\mathrm{sys}} \\cdot \\eta_{\\mathrm{ref}}$，其中 $A_{\\mathrm{sys}}$ 是系统总面积，$\\eta_{\\mathrm{ref}}$ 是参考组件效率。我们必须小心处理单位；如果 $P_{\\mathrm{rated}}$ 的单位是 $\\mathrm{kW}$，我们通过乘以 $1000$ 将其转换为 $\\mathrm{W}$。系统的有效面积可以推导为 $A_{\\mathrm{sys}} = \\frac{1000 \\cdot P_{\\mathrm{rated}}}{G_{\\mathrm{ref}} \\cdot \\eta_{\\mathrm{ref}}}$。\n在任意阵列平面辐照度 $G(t)$ 下，不考虑温度效应时产生的功率将是 $P_{\\text{potential}}(t) = G(t) \\cdot A_{\\mathrm{sys}} \\cdot \\eta_{\\mathrm{ref}}$。代入 $A_{\\mathrm{sys}}$ 的表达式并使用 $G_{\\mathrm{ref}} = 1000\\,\\mathrm{W/m^2}$：\n$$P_{\\text{potential}}(t) = G(t) \\cdot \\left(\\frac{1000 \\cdot P_{\\mathrm{rated}}}{1000 \\cdot \\eta_{\\mathrm{ref}}}\\right) \\cdot \\eta_{\\mathrm{ref}} = P_{\\mathrm{rated}} \\cdot \\frac{G(t)}{1000}$$\n这提供了通过辐照度比率对额定功率的直接缩放，其中 $P(t)$ 的单位与 $P_{\\mathrm{rated}}$ (kW) 相同。\n\n组件的效率，及其功率输出，对其工作温度 $T_{\\mathrm{cell}}(t)$ 很敏感。首先，我们必须估算 $T_{\\mathrm{cell}}(t)$。问题指定使用标称工作电池温度（$NOCT$）模型。$NOCT$ 是在 $G_{\\mathrm{NOCT}} = 800\\,\\mathrm{W/m^2}$ 和 $T_{\\mathrm{amb,NOCT}} = 20\\,^\\circ\\mathrm{C}$ 条件下的电池温度。电池温度比环境温度高出的部分与入射辐照度成正比。该模型是：\n$$T_{\\mathrm{cell}}(t) = T_{\\mathrm{amb}}(t) + (NOCT - T_{\\mathrm{amb,NOCT}}) \\cdot \\frac{G(t)}{G_{\\mathrm{NOCT}}} = T_{\\mathrm{amb}}(t) + (NOCT - 20) \\cdot \\frac{G(t)}{800}$$\n其中所有温度单位均为 $^\\circ\\mathrm{C}$。\n\n接下来，我们使用给定的线性功率温度系数 $\\beta$ 来计算温度对功率输出的影响。该系数相对于参考温度 $T_{\\mathrm{ref}} = 25\\,^\\circ\\mathrm{C}$ 来修正功率输出。那么，生成的总直流功率 $P_{\\mathrm{DC}}(t)$ 为：\n$$P_{\\mathrm{DC}}(t) = P_{\\text{potential}}(t) \\cdot [1 + \\beta(T_{\\mathrm{cell}}(t) - T_{\\mathrm{ref}})] = P_{\\mathrm{rated}} \\cdot \\frac{G(t)}{1000} \\cdot [1 + \\beta(T_{\\mathrm{cell}}(t) - 25)]$$\n由于晶体硅光伏组件的 $\\beta$ 值通常为负，因此较高的电池温度会导致较低的功率输出。\n\n最后，输送到电网的交流功率 $P(t)$ 受到逆变器最大功率输出的限制，该最大功率输出假定等于系统的额定功率 $P_{\\mathrm{rated}}$。这种现象被称为逆变器削波。因此，最终的功率输出是计算出的直流功率和额定功率中的较小者。我们还确保功率为非负值。\n$$P(t) = \\max(0, \\min(P_{\\mathrm{DC}}(t), P_{\\mathrm{rated}}))$$\n\n对于风能和光伏系统，一个包含 $N$ 小时周期的容量因子（$CF$）定义为实际总发电量与系统在该周期内以额定功率 $P_{\\mathrm{rated}}$ 运行时可能产生的最大能量之比。\n$$CF = \\frac{\\sum_{t=1}^{N} P(t) \\cdot (1\\,\\text{hr})}{P_{\\mathrm{rated}} \\cdot N \\cdot (1\\,\\text{hr})} = \\frac{\\sum_{t=1}^{N} P(t)}{P_{\\mathrm{rated}} \\cdot N}$$\n使用推导出的 $P(t)$ 函数，我们可以为每个给定的测试案例计算容量因子。所有计算将按规定以 $\\mathrm{kW}$ 为单位保持功率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Derives and implements models for wind and PV power generation to calculate\n    capacity factors for a given set of test cases.\n    \"\"\"\n\n    # --- Model Implementation ---\n\n    def calculate_wind_power_series(v_series, p_rated, v_ci, v_r, v_co):\n        \"\"\"\n        Calculates hourly power output for a wind turbine from a wind speed series.\n        \n        Args:\n            v_series (list or np.array): Hourly wind speeds in m/s.\n            p_rated (float): Rated power in kW.\n            v_ci (float): Cut-in speed in m/s.\n            v_r (float): Rated speed in m/s.\n            v_co (float): Cut-out speed in m/s.\n\n        Returns:\n            np.array: Hourly power output in kW.\n        \"\"\"\n        v = np.array(v_series, dtype=float)\n        power = np.zeros_like(v)\n\n        # Region 1: Normal operation between cut-in and rated speed\n        # P(v) = P_rated * (v^3 - v_ci^3) / (v_r^3 - v_ci^3)\n        op_mask = (v = v_ci)  (v  v_r)\n        v_op = v[op_mask]\n        \n        # Avoid division by zero if v_r = v_ci, though not expected for valid problems\n        v_r3_minus_v_ci3 = v_r**3 - v_ci**3\n        if v_r3_minus_v_ci3  0:\n            power[op_mask] = p_rated * (v_op**3 - v_ci**3) / v_r3_minus_v_ci3\n\n        # Region 2: Rated power output\n        rated_mask = (v = v_r)  (v  v_co)\n        power[rated_mask] = p_rated\n\n        # Regions 3  4 (below cut-in and above cut-out) are already 0.\n        \n        return power\n\n    def calculate_pv_power_series(g_series, t_amb_series, p_rated, beta, noct):\n        \"\"\"\n        Calculates hourly power output for a PV system.\n        \n        Args:\n            g_series (list or np.array): Hourly plane-of-array irradiance in W/m^2.\n            t_amb_series (list or np.array): Hourly ambient temperature in °C.\n            p_rated (float): Rated power in kW.\n            beta (float): Power temperature coefficient in 1/°C.\n            noct (float): Nominal Operating Cell Temperature in °C.\n\n        Returns:\n            np.array: Hourly power output in kW.\n        \"\"\"\n        g = np.array(g_series, dtype=float)\n        t_amb = np.array(t_amb_series, dtype=float)\n        power = np.zeros_like(g)\n\n        # Constants from PV modeling standards\n        G_REF = 1000.0  # W/m^2 (STC irradiance)\n        T_REF = 25.0    # °C (STC cell temperature)\n        G_NOCT = 800.0  # W/m^2 (NOCT irradiance)\n        T_AMB_NOCT = 20.0 # °C (NOCT ambient temperature)\n\n        # Calculate only for hours with sunlight\n        sunlight_mask = g > 0\n        g_sun = g[sunlight_mask]\n        t_amb_sun = t_amb[sunlight_mask]\n\n        # 1. Calculate cell temperature using the NOCT model\n        t_cell = t_amb_sun + (noct - T_AMB_NOCT) * g_sun / G_NOCT\n\n        # 2. Calculate DC power with temperature adjustment\n        # P_potential = P_rated * G / G_ref\n        # P_dc = P_potential * (1 + beta * (T_cell - T_ref))\n        p_dc = (p_rated * g_sun / G_REF) * (1 + beta * (t_cell - T_REF))\n        \n        # 3. Apply inverter clipping and ensure non-negative power\n        p_final = np.maximum(0, np.minimum(p_dc, p_rated))\n\n        power[sunlight_mask] = p_final\n        return power\n\n    # --- Test Case Definitions ---\n    \n    test_cases = [\n        {\n            \"type\": \"wind\",\n            \"params\": {\n                \"v_series\": [0, 2.5, 3, 6, 10, 12, 15, 24, 26, 8],\n                \"p_rated\": 3000.0, \"v_ci\": 3.0, \"v_r\": 12.0, \"v_co\": 25.0\n            }\n        },\n        {\n            \"type\": \"wind\",\n            \"params\": {\n                \"v_series\": [0, 1, 2, 2.9, 0.5, 2.8, 2.999, 2, 1.5, 0],\n                \"p_rated\": 3000.0, \"v_ci\": 3.0, \"v_r\": 12.0, \"v_co\": 25.0\n            }\n        },\n        {\n            \"type\": \"pv\",\n            \"params\": {\n                \"g_series\": [0, 0, 200, 400, 600, 800, 1000, 800, 400, 0],\n                \"t_amb_series\": [15, 15, 16, 17, 18, 20, 22, 24, 22, 18],\n                \"p_rated\": 500.0, \"beta\": -0.004, \"noct\": 45.0\n            }\n        },\n        {\n            \"type\": \"pv\",\n            \"params\": {\n                \"g_series\": [0, 300, 600, 900, 1100, 1200, 1100, 900, 600, 300],\n                \"t_amb_series\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                \"p_rated\": 1000.0, \"beta\": -0.004, \"noct\": 45.0\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        p_rated = params[\"p_rated\"]\n        \n        if case[\"type\"] == \"wind\":\n            power_series = calculate_wind_power_series(**params)\n            N = len(params[\"v_series\"])\n        elif case[\"type\"] == \"pv\":\n            power_series = calculate_pv_power_series(**params)\n            N = len(params[\"g_series\"])\n        \n        # Calculate Capacity Factor\n        # CF = sum(P_t) / (P_rated * N)\n        total_energy_generated = np.sum(power_series)\n        max_possible_energy = p_rated * N\n        \n        if max_possible_energy == 0:\n            capacity_factor = 0.0\n        else:\n            capacity_factor = total_energy_generated / max_possible_energy\n            \n        results.append(capacity_factor)\n\n    # Format results to six decimal places for the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在生成逐点的资源数据后，下一步通常是将其汇总到网格单元中以创建资源地图。然而，这个聚合过程隐藏着对坐标系统选择的敏感性。本练习探讨了一个关键的地理空间问题：大地基准的微小差异（简化为米级水平平移）如何影响聚合后的容量因子统计。通过这个思想实验，您将深入理解空间数据处理中“边界效应”的重要性，并培养对地理空间分析结果不确定性的批判性思维。",
            "id": "4093404",
            "problem": "您的任务是形式化并量化大地基准面转换对聚合能源资源测绘的影响。从大地测量定义和实现的角度，区分1984年世界大地坐标系 (WGS84) 和1983年北美基准 (NAD83)，并推导在投影平面坐标系中，当点被分组到面积为 $100\\,\\mathrm{km}^2$ 的多边形内时，量级为 $1\\,\\mathrm{m}$ 的水平平移会如何改变容量因子的聚合结果。为保证局部区域内算法的易处理性和科学真实性，假设采用与通用横轴墨卡托 (UTM) 系列一致的局部平面地图投影，在此投影下，小的水平位移被保留为以米为单位的平面平移。\n\n您必须使用的基本依据包括：大地基准面的定义，即一个地心地固坐标参考框架及相关椭球体的规范；基准面差异可通过七参数赫尔默特变换表示的概念；以及容量因子的定义，即一个时期内实际能量产量与最大可能产量之间的无量纲比率。\n\n将平面划分为一系列轴对齐的正方形多边形，每个多边形面积为 $100\\,\\mathrm{km}^2$，边长为 $L = 10{,}000\\,\\mathrm{m}$，并采用以下隶属规则以避免边界上的歧义：一个坐标为 $(x,y)$ 的点属于多边形 $[x_0,x_1) \\times [y_0,y_1)$，当且仅当 $x_0 \\le x  x_1$ 且 $y_0 \\le y  y_1$。根据该隶属规则，一个多边形的容量因子聚合结果是所有属于该多边形的点的容量因子的算术平均值。\n\n您必须实现一个程序，针对下面提供的每个测试用例，计算因所有点按指定的水平位移向量平移而引起的多边形级别聚合容量因子的最大绝对变化。具体而言，对于每个测试用例，令 $\\mu_p$ 表示多边形 $p$ 的位移前平均容量因子，令 $\\mu'_p$ 表示将每个点按给定向量平移后的位移后平均值。计算该测试用例的影响度量 $I = \\max_{p} \\left| \\mu'_p - \\mu_p \\right|$。所有坐标均以米表示，所有容量因子均视为无量纲小数。最终输出是每个测试用例的 $I$ 值，表示为四舍五入到六位小数的小数。\n\n使用以下测试套件。每个测试用例包含一组多边形、一组具有相关容量因子的资源点，以及一个以米为单位的水平位移向量 $\\Delta \\mathbf{x} = (\\Delta x, \\Delta y)$。多边形是边长为 $10{,}000\\,\\mathrm{m}$ 的轴对齐正方形，按规定的半开区间 $[x_0,x_1) \\times [y_0,y_1)$ 定义。\n\n测试用例 1 (理想情况，无边界穿越)：\n- 多边形：单个多边形 $P_0$，范围为 $[0,10{,}000) \\times [0,10{,}000)$。\n- 点和容量因子：$(x,y,c)$ 三元组\n  - $(5{,}000,5{,}000,0.4)$\n  - $(2{,}000,2{,}000,0.5)$\n- 位移向量：$\\Delta \\mathbf{x} = (1,0)\\,\\mathrm{m}$。\n\n测试用例 2 (在相邻多边形间向东穿越边界)：\n- 多边形：$P_0$ 范围为 $[0,10{,}000) \\times [0,10{,}000)$，$P_1$ 范围为 $[10{,}000,20{,}000) \\times [0,10{,}000)$。\n- 点和容量因子：\n  - $(9{,}999.6,3{,}000,0.6)$\n  - $(7{,}000,7{,}000,0.2)$\n  - $(15{,}000,5{,}000,0.8)$\n- 位移向量：$\\Delta \\mathbf{x} = (1,0)\\,\\mathrm{m}$。\n\n测试用例 3 (在相邻多边形间向北穿越边界)：\n- 多边形：$P_0$ 范围为 $[0,10{,}000) \\times [0,10{,}000)$，$P_2$ 范围为 $[0,10{,}000) \\times [10{,}000,20{,}000)$。\n- 点和容量因子：\n  - $(5{,}000,9{,}999.5,0.9)$\n  - $(4{,}000,2{,}000,0.1)$\n  - $(5{,}000,15{,}000,0.3)$\n- 位移向量：$\\Delta \\mathbf{x} = (0,1)\\,\\mathrm{m}$。\n\n测试用例 4 (点恰好在边界上且向西位移的边缘情况)：\n- 多边形：$P_0$ 范围为 $[0,10{,}000) \\times [0,10{,}000)$，$P_1$ 范围为 $[10{,}000,20{,}000) \\times [0,10{,}000)$。\n- 点和容量因子：\n  - $(10{,}000.0,5{,}000,0.7)$\n  - $(8{,}000,6{,}000,0.5)$\n  - $(15{,}000,4{,}000,0.6)$\n- 位移向量：$\\Delta \\mathbf{x} = (-1,0)\\,\\mathrm{m}$。\n\n您的程序应生成单行输出，其中包含四个影响度量值，格式为方括号内以逗号分隔的列表，每个值四舍五入到六位小数，例如 $[0.000000,0.123456,0.500000,0.010000]$。不应打印任何其他文本。计算必须是确定性的，并且仅使用提供的测试用例数据。",
            "solution": "所提出的问题是对地理空间数据分析（特别是在能源资源建模领域）中一个实际问题的有效且适定的形式化表述。它关注的是聚合空间数据对基础坐标系中微小扰动的敏感性，例如由1984年世界大地坐标系 (WGS84) 和1983年北美基准 (NAD83) 等大地基准面之间的差异引起的扰动。尽管这些基准面由复杂的大地测量参数（参考椭球体、原点、定向）定义，但对于局部尺度的分析，它们实现之间的差异通常可以很好地通过一个简单的水平平移向量来近似，正如问题中所设定的那样。这个位移的量级在 $1\\,\\mathrm{m}$ 左右，这在物理上是现实的。问题要求我们量化这种位移对在规则正方形多边形网格上聚合的平均容量因子的最大影响。\n\n所研究的核心科学原理是离散空间聚合中的边界条件效应。当连续的点数据被聚合到离散区域（多边形）时，位于边界附近的点在其坐标受到轻微扰动时，很容易被重新分配到相邻区域。这种重新分配改变了受影响多边形内点集的构成，从而改变了它们的聚合统计数据。该问题为分析这种效应提供了一个严谨的框架。\n\n我们的算法将基于所提供的定义，通过一系列精确的步骤系统地计算聚合值的变化。\n\n**算法形式化**\n\n1.  **系统定义**：系统由一组资源数据点 $S = \\{(x_i, y_i, c_i)\\}_{i=1}^N$ 组成，其中 $(x_i, y_i)$ 是以米为单位的平面坐标，而 $c_i$ 是无量纲的容量因子。该平面被划分为一个由轴对齐的正方形多边形组成的网格，每个多边形的边长为 $L = 10{,}000\\,\\mathrm{m}$，面积为 $100\\,\\mathrm{km}^2$。\n\n2.  **多边形隶属规则**：一个坐标为 $(x,y)$ 的点被分配给由半开区间 $[jL, (j+1)L) \\times [kL, (k+1)L)$ 定义的唯一多边形 $P_{j,k}$，其中的整数索引 $(j,k)$ 由向下取整函数确定：\n    $$\n    j = \\lfloor x/L \\rfloor, \\quad k = \\lfloor y/L \\rfloor\n    $$\n    此规则清晰无歧义，确保平面上的每个点都恰好属于一个多边形。\n\n3.  **聚合函数**：一个多边形 $p$ 的聚合容量因子是其所包含的所有点的容量因子的算术平均值。设 $S_p = \\{(x_i, y_i, c_i) \\in S \\mid (x_i, y_i) \\in p\\}$。位移前的平均容量因子 $\\mu_p$ 为：\n    $$\n    \\mu_p = \\begin{cases} \\frac{1}{|S_p|} \\sum_{(x,y,c) \\in S_p} c  \\text{如果 } |S_p|  0 \\\\ 0  \\text{如果 } |S_p| = 0 \\end{cases}\n    $$\n\n4.  **坐标变换**：基准面转换被建模为一个由向量 $\\Delta \\mathbf{x} = (\\Delta x, \\Delta y)$ 定义的均匀水平平移。每个点 $(x_i, y_i)$ 被变换到一个新的坐标 $(x'_i, y'_i)$：\n    $$\n    (x'_i, y'_i) = (x_i + \\Delta x, y_i + \\Delta y)\n    $$\n    这会生成一个新的位移点集 $S' = \\{(x'_i, y'_i, c_i)\\}_{i=1}^N$。注意，容量因子 $c_i$ 是资源点的内在属性，在坐标变换下保持不变。\n\n5.  **位移后聚合**：对位移后的点重复聚合过程。设 $S'_p = \\{(x'_i, y'_i, c_i) \\in S' \\mid (x'_i, y'_i) \\in p\\}$。位移后的平均容量因子 $\\mu'_p$ 为：\n    $$\n    \\mu'_p = \\begin{cases} \\frac{1}{|S'_p|} \\sum_{(x',y',c) \\in S'_p} c  \\text{如果 } |S'_p|  0 \\\\ 0  \\text{如果 } |S'_p| = 0 \\end{cases}\n    $$\n\n6.  **影响度量**：位移的影响通过所有受影响多边形中平均容量因子的最大绝对变化来量化。设 $\\mathcal{P}_{affected}$ 为所有满足 $S_p$ 或 $S'_p$ 非空的多边形 $p$ 的集合。影响度量 $I$ 为：\n    $$\n    I = \\max_{p \\in \\mathcal{P}_{affected}} |\\mu'_p - \\mu_p|\n    $$\n\n**实现策略**\n\n该算法通过按以下方式处理每个测试用例来实现：\n- 定义边长 $L=10000.0$。\n- 对于每个测试用例，我们首先计算位移前的聚合结果。我们使用一个字典将多边形索引 $(j,k)$ 映射到容量因子列表。\n- 我们遍历给定的点，使用向下取整除法规则确定每个点的多边形索引，并填充该字典。\n- 从这个字典中，我们计算出第二个字典，将多边形索引映射到其位移前的平均容量因子 $\\mu_p$。\n- 接下来，我们将位移向量 $(\\Delta x, \\Delta y)$ 应用于所有点的坐标。\n- 我们对位移后的坐标重复聚合过程，以计算位移后的平均容量因子 $\\mu'_p$。\n- 然后，我们识别出在位移前或位移后计算中出现过的所有唯一多边形索引的集合。\n- 对于这些多边形中的每一个，我们计算绝对差 $|\\mu'_p - \\mu_p|$，从平均值字典中检索数值（如果一个多边形在某种状态下为空，则使用默认值 $0$）。\n- 这些差异中的最大值即为该测试用例的影响度量 $I$。\n\n让我们以测试用例 2 为例进行追踪：\n- **多边形**：$P_{0,0} = [0, 10000) \\times [0, 10000)$ 和 $P_{1,0} = [10000, 20000) \\times [0, 10000)$。\n- **点**：$(9999.6, 3000, 0.6)$、$(7000, 7000, 0.2)$、$(15000, 5000, 0.8)$。\n- **位移**：$\\Delta \\mathbf{x} = (1, 0)$。\n\n**位移前分析**：\n- 点 $(9999.6, 3000)$: $\\lfloor 9999.6/10000 \\rfloor = 0$, $\\lfloor 3000/10000 \\rfloor = 0$。属于 $P_{0,0}$。\n- 点 $(7000, 7000)$: $\\lfloor 7000/10000 \\rfloor = 0$, $\\lfloor 7000/10000 \\rfloor = 0$。属于 $P_{0,0}$。\n- 点 $(15000, 5000)$: $\\lfloor 15000/10000 \\rfloor = 1$, $\\lfloor 5000/10000 \\rfloor = 0$。属于 $P_{1,0}$。\n- 位移前平均值：\n  - $\\mu_{P_{0,0}} = (0.6 + 0.2) / 2 = 0.4$。\n  - $\\mu_{P_{1,0}} = 0.8 / 1 = 0.8$。\n\n**位移后分析**：\n- 位移后的点：$(10000.6, 3000)$、$(7001, 7000)$、$(15001, 5000)$。\n- 点 $(10000.6, 3000)$: $\\lfloor 10000.6/10000 \\rfloor = 1$。属于 $P_{1,0}$。（该点穿越了边界）。\n- 点 $(7001, 7000)$: $\\lfloor 7001/10000 \\rfloor = 0$。属于 $P_{0,0}$。\n- 点 $(15001, 5000)$: $\\lfloor 15001/10000 \\rfloor = 1$。属于 $P_{1,0}$。\n- 位移后平均值：\n  - $\\mu'_{P_{0,0}} = 0.2 / 1 = 0.2$。\n  - $\\mu'_{P_{1,0}} = (0.6 + 0.8) / 2 = 0.7$。\n\n**影响计算**：\n- $P_{0,0}$ 的变化：$|\\mu'_{P_{0,0}} - \\mu_{P_{0,0}}| = |0.2 - 0.4| = 0.2$。\n- $P_{1,0}$ 的变化：$|\\mu'_{P_{1,0}} - \\mu_{P_{1,0}}| = |0.7 - 0.8| = 0.1$。\n- $I = \\max(0.2, 0.1) = 0.2$。\n\n将此过程应用于所有测试用例，以得出最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"points\": [(5000.0, 5000.0, 0.4), (2000.0, 2000.0, 0.5)],\n            \"shift\": (1.0, 0.0)\n        },\n        {\n            \"points\": [(9999.6, 3000.0, 0.6), (7000.0, 7000.0, 0.2), (15000.0, 5000.0, 0.8)],\n            \"shift\": (1.0, 0.0)\n        },\n        {\n            \"points\": [(5000.0, 9999.5, 0.9), (4000.0, 2000.0, 0.1), (5000.0, 15000.0, 0.3)],\n            \"shift\": (0.0, 1.0)\n        },\n        {\n            \"points\": [(10000.0, 5000.0, 0.7), (8000.0, 6000.0, 0.5), (15000.0, 4000.0, 0.6)],\n            \"shift\": (-1.0, 0.0)\n        }\n    ]\n\n    L = 10000.0  # Side length of the square polygons in meters.\n\n    def get_polygon_aggregates(points, L_val):\n        \"\"\"\n        Aggregates capacity factors by polygon.\n\n        Args:\n            points (list): A list of (x, y, capacity_factor) tuples.\n            L_val (float): The side length of the polygon grid.\n\n        Returns:\n            dict: A dictionary mapping polygon indices (ix, iy) to a list of capacity factors.\n        \"\"\"\n        aggregates = {}\n        for x, y, c in points:\n            # Determine the polygon index using the floor function.\n            # This corresponds to the rule x_0 = x  x_1.\n            ix = int(np.floor(x / L_val))\n            iy = int(np.floor(y / L_val))\n            key = (ix, iy)\n            if key not in aggregates:\n                aggregates[key] = []\n            aggregates[key].append(c)\n        return aggregates\n\n    def calculate_means(aggregates):\n        \"\"\"\n        Calculates the mean capacity factor for each polygon.\n\n        Args:\n            aggregates (dict): A dictionary mapping polygon indices to lists of factors.\n\n        Returns:\n            dict: A dictionary mapping polygon indices to mean capacity factors.\n        \"\"\"\n        means = {}\n        for key, values in aggregates.items():\n            if values:\n                means[key] = sum(values) / len(values)\n            else:\n                means[key] = 0.0\n        return means\n\n    def compute_impact_for_case(points, shift, L_val):\n        \"\"\"\n        Computes the impact metric I for a single test case.\n\n        Args:\n            points (list): A list of (x, y, capacity_factor) tuples.\n            shift (tuple): A (dx, dy) shift vector.\n            L_val (float): The side length of the polygon grid.\n\n        Returns:\n            float: The computed impact metric I.\n        \"\"\"\n        # 1. Pre-shift calculations\n        pre_shift_aggs = get_polygon_aggregates(points, L_val)\n        pre_shift_means = calculate_means(pre_shift_aggs)\n\n        # 2. Post-shift calculations\n        dx, dy = shift\n        shifted_points = [(x + dx, y + dy, c) for x, y, c in points]\n        post_shift_aggs = get_polygon_aggregates(shifted_points, L_val)\n        post_shift_means = calculate_means(post_shift_aggs)\n\n        # 3. Calculate impact metric I\n        # Get the union of all polygon keys that have points in either state.\n        all_polygon_keys = set(pre_shift_means.keys()) | set(post_shift_means.keys())\n        \n        max_abs_change = 0.0\n        for key in all_polygon_keys:\n            # Use .get(key, 0.0) to handle polygons that become empty or are newly populated.\n            mu_p = pre_shift_means.get(key, 0.0)\n            mu_p_prime = post_shift_means.get(key, 0.0)\n            abs_change = abs(mu_p_prime - mu_p)\n            if abs_change  max_abs_change:\n                max_abs_change = abs_change\n        \n        return max_abs_change\n\n    results = []\n    for case in test_cases:\n        impact_metric = compute_impact_for_case(case[\"points\"], case[\"shift\"], L)\n        results.append(impact_metric)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这是将地理空间资源建模应用于实际工程规划的综合性实践。您将学习如何结合地形、土地利用限制和工程成本等多种空间数据层，构建一个“成本表面”。在此基础上，通过应用如图论中的Dijkstra算法等寻路方法，您可以为输电线路等能源基础设施规划出经济上最优的走廊，这展示了资源建模在辅助现实世界决策中的最终价值。",
            "id": "4093384",
            "problem": "您的任务是在离散栅格上为输电走廊设计实现一个最低成本路径（Least-Cost Path, LCP）程序。目标是，在给定一个对坡度和保护区进行惩罚的成本表面的情况下，形式化并计算最小总路径成本和相应的路径长度。该公式必须基于具有物理意义的定义。程序必须解决所提供测试套件中指定的案例，并以要求的格式输出最终结果。\n\n定义和建模基础：\n- 走廊设计问题假设在一个具有均匀间距的规则单元格网格上进行。设单元格大小为 $c$ 米。设高程场为数字高程模型（DEM）$Z(i,j)$，单位为米。设保护区掩码为 $P(i,j)$，其中 $P(i,j)=1$ 表示受保护的单元格，$P(i,j)=0$ 表示其他情况。所有移动都限制在 $8$-连通邻域内（基本方向和对角线方向移动）。\n- 在一个位置上，单位长度的通行成本建模为\n$$\nC(i,j) = \\gamma + \\alpha \\cdot \\theta(i,j) + \\beta \\cdot P(i,j),\n$$\n其中 $\\gamma$ 是基础成本（美元/米），$\\alpha$ 是坡度惩罚系数（美元/米/弧度），$\\beta$ 是保护区惩罚（美元/米），$\\theta(i,j)$ 是局部坡度角（弧度）。\n- 局部坡度角 $\\theta(i,j)$ 从表面梯度的大小推导而来。通过有限差分近似偏导数：\n$$\ng_x(i,j)=\n\\begin{cases}\n\\dfrac{Z(i+1,j)-Z(i,j)}{c}  \\text{若 } i=0, \\\\\n\\dfrac{Z(i,j)-Z(i-1,j)}{c}  \\text{若 } i=n_x-1, \\\\\n\\dfrac{Z(i+1,j)-Z(i-1,j)}{2c}  \\text{其他情况},\n\\end{cases}\n\\qquad\ng_y(i,j)=\n\\begin{cases}\n\\dfrac{Z(i,j+1)-Z(i,j)}{c}  \\text{若 } j=0, \\\\\n\\dfrac{Z(i,j)-Z(i,j-1)}{c}  \\text{若 } j=n_y-1, \\\\\n\\dfrac{Z(i,j+1)-Z(i,j-1)}{2c}  \\text{其他情况}.\n\\end{cases}\n$$\n则坡度大小为\n$$\nm(i,j)=\\sqrt{g_x(i,j)^2+g_y(i,j)^2},\n$$\n坡度角为\n$$\n\\theta(i,j)=\\arctan\\!\\big(m(i,j)\\big),\n$$\n以弧度表示。\n- 对于从单元格 $i$ 到 $8$-连通邻域中相邻单元格 $j$ 的移动，边长 $d_{ij}$ 为\n$$\nd_{ij}=\n\\begin{cases}\nc  \\text{对于基本方向移动},\\\\\nc\\sqrt{2}  \\text{对于对角线方向移动}。\n\\end{cases}\n$$\n为了离散化沿路径的成本线积分，使用梯形法则近似边的通行成本，\n$$\nw_{ij}=d_{ij}\\cdot \\dfrac{C(i)+C(j)}{2}.\n$$\n总路径成本是沿所选路径的 $w_{ij}$ 之和，路径长度是沿路径的 $d_{ij}$ 之和。\n- 计算网格上指定起始单元格 $(s_x,s_y)$ 和目标单元格 $(t_x,t_y)$ 之间的最低成本路径，将每个单元格视为图中一个节点，其边权重如上定义的 $w_{ij}$。实现一个与非负边权重一致的路径搜索方法。\n\n角度单位要求：\n- 所有角度都必须以弧度计算和使用。\n\n单位和输出要求：\n- 以米表示最终路径长度，以美元表示最终路径成本。将两个数字都四舍五入到 $3$ 位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果，每个测试用例结果都是一个二元列表 $[ \\text{total\\_cost}, \\text{route\\_length} ]$。例如，输出应类似于 $[[x_1,y_1],[x_2,y_2],\\dots]$，不含空格。\n\n测试套件：\n为以下参数集实现算法。在每个案例中，$Z$ 的单位是米，$P$ 是无量纲的，值为 $0$ 或 $1$，$c$ 的单位是米，成本 $\\gamma$、$\\alpha$ 和 $\\beta$ 的单位是美元/米（$\\alpha$ 的单位是美元/米/弧度）。\n\n案例 1（带有中心保护区的常规路径）：\n- 网格大小：$n_x=5$, $n_y=5$。\n- 单元格大小：$c=100$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n100  120  140  160  180 \\\\\n100  120  140  160  200 \\\\\n100  120  160  200  240 \\\\\n100  120  160  200  240 \\\\\n90  110  130  150  170\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0  0  0  0  0 \\\\\n0  0  1  1  0 \\\\\n0  1  1  1  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  0  0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=500$, $\\alpha=1000$, $\\beta=4000$。\n- 起点和终点：$(s_x,s_y)=(0,0)$, $(t_x,t_y)=(4,4)$。\n\n案例 2（起点等于终点，平坦地形）：\n- 网格大小：$n_x=3$, $n_y=3$。\n- 单元格大小：$c=50$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=400$, $\\alpha=800$, $\\beta=2000$。\n- 起点和终点：$(s_x,s_y)=(1,1)$, $(t_x,t_y)=(1,1)$。\n\n案例 3（由山脊引起的坡度惩罚和一个小的受保护单元格）：\n- 网格大小：$n_x=4$, $n_y=4$。\n- 单元格大小：$c=100$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n0  0  0  0 \\\\\n0  50  200  250 \\\\\n0  50  200  250 \\\\\n0  0  0  0\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0  0  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=600$, $\\alpha=1200$, $\\beta=3000$。\n- 起点和终点：$(s_x,s_y)=(0,3)$, $(t_x,t_y)=(3,0)$。\n\n案例 4（绕过受保护屏障的走廊避让）：\n- 网格大小：$n_x=6$, $n_y=6$。\n- 单元格大小：$c=200$。\n- 高程 $Z$：\n$$\n\\begin{bmatrix}\n0  10  20  30  40  50 \\\\\n10  20  30  40  50  60 \\\\\n20  30  40  50  60  70 \\\\\n30  40  50  60  70  80 \\\\\n40  50  60  70  80  90 \\\\\n50  60  70  80  90  100\n\\end{bmatrix}\n$$\n- 保护区掩码 $P$：\n$$\n\\begin{bmatrix}\n0  0  1  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  0  1  1  1  0 \\\\\n0  0  1  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  0  1  0  0  0\n\\end{bmatrix}\n$$\n- 参数：$\\gamma=700$, $\\alpha=900$, $\\beta=5000$。\n- 起点和终点：$(s_x,s_y)=(0,0)$, $(t_x,t_y)=(5,5)$。\n\n实现和输出：\n- 按照规定实现坡度计算，计算 $C(i,j)$，建立带有边权重 $w_{ij}$ 的 $8$-连通图，并找到从起点到终点的最低成本路径。计算总路径成本和总路径长度。所有角度计算均使用弧度。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果，每个测试用例结果格式化为 $[\\text{total\\_cost},\\text{route\\_length}]$，四舍五入到 $3$ 位小数，不含空格。例如：$[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$。",
            "solution": "### 问题验证\n\n**步骤 1：提取给定信息**\n-   **网格：** 具有统一间距 `$c$`（米）的规则单元格网格，一个高程场 `$Z(i,j)`（米），以及一个保护区掩码 `$P(i,j)`（1 表示受保护，0 表示其他）。网格尺寸为 `$n_x \\times n_y$`。\n-   **移动：** 限制在 `$8$`-连通邻域内（基本方向和对角线方向移动）。\n-   **单位长度通行成本：** 在每个单元格 `$(i,j)$` 定义为 `$C(i,j) = \\gamma + \\alpha \\cdot \\theta(i,j) + \\beta \\cdot P(i,j)$`，其中 `$\\gamma$` 是基础成本（美元/米），`$\\alpha$` 是坡度惩罚（美元/米/弧度），`$\\beta$` 是保护区惩罚（美元/米）。\n-   **坡度计算：**\n    -   高程的偏导数 `$g_x(i,j)$` 和 `$g_y(i,j)$` 在边界处使用一阶前向/后向有限差分近似，在内部使用二阶中心差分近似。\n    -   坡度大小为 `$m(i,j) = \\sqrt{g_x(i,j)^2 + g_y(i,j)^2}$`。\n    -   坡度角为 `$\\theta(i,j) = \\arctan(m(i,j))$`（弧度）。\n-   **边通行成本：** 从相邻单元格 `$i$` 移动到 `$j$` 的成本为 `$w_{ij} = d_{ij} \\cdot \\frac{C(i)+C(j)}{2}$`，其中边长 `$d_{ij}$` 对于基本方向移动是 `$c$`，对于对角线移动是 `$c\\sqrt{2}$`。\n-   **目标：** 计算从起始单元格 `$(s_x, s_y)$` 到目标单元格 `$(t_x, t_y)$` 的最小总路径成本（`$w_{ij}$` 的总和）和相应的路径长度（`$d_{ij}$` 的总和）。\n-   **算法约束：** 路径搜索方法必须与非负边权重一致。\n-   **测试案例：** 提供了四个完整的参数集，指定了 `$Z, P, c, \\gamma, \\alpha, \\beta$`，以及起点和终点坐标。\n-   **输出：** 一个单行字符串 `[[cost1,length1],[cost2,length2],...]`，数值四舍五入到 $3$ 位小数。\n\n**步骤 2：使用提取的给定信息进行验证**\n根据验证标准对问题进行评估：\n-   **科学性（关键）：** 该问题牢固地植根于地理空间科学和运筹学等成熟领域。在栅格表面上进行最低成本路径（LCP）分析是各种领域中路线规划的标准技术，包括生态学、土木工程和城市规划。成本模型虽然是线性的简化，但基于具有物理意义的因素：内在建设成本（`$\\gamma$`）、地形难度（坡度惩罚 `$\\alpha$`）和土地使用限制（保护区惩罚 `$\\beta$`）。通过有限差分计算坡度和通过数值积分（梯形法则）计算路径成本的数学公式都是标准且适当的数值方法。\n-   **适定性：** 该问题是适定的。它要求在一个图中的离散路径集合上求成本函数的最小值。由于成本参数 `$\\gamma, \\alpha, \\beta$` 是非负的，且坡度角 `$\\theta(i,j)` 非负，因此单位长度成本 `$C(i,j)$` 和边权重 `$w_{ij}$` 保证是非负的。这确保了像 Dijkstra 这样的最短路径算法能够找到一个稳定且值唯一的最小成本。计算所需的所有数据和常量都在测试套件中提供。\n-   **客观性（关键）：** 该问题使用精确、客观的数学语言指定。所有术语都有定义，计算过程描述清晰明确。没有主观或基于意见的元素。\n\n该问题没有表现出任何使其无效的缺陷。它在科学上是合理的，规范是完整的，是客观的，并且需要实现一个非平凡的标准算法。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将开发一个解决方案。\n\n### 算法解决方案\n在栅格网格上寻找最低成本路径的问题，通过将网格建模为图并应用最短路径算法来解决。每个网格单元 `$(i,j)$` 都是图中的一个节点，边连接每个节点到其 8 个邻居。解决方案的核心包括三个阶段：计算成本表面，定义图的边权重，以及执行 Dijkstra 算法以找到最优路径。\n\n**1. 成本表面计算**\n路径的总成本取决于每个单元格的单位长度通行成本 `$C(i,j)$`。此成本是局部坡度角 `$\\theta(i,j)$` 和保护区状态 `$P(i,j)$` 的函数。\n\n首先，我们计算整个网格的坡度。高程的偏导数 `$g_x$` 和 `$g_y$` 根据指定的有限差分公式计算。这些公式与 `numpy.gradient` 函数在提供统一间距 `$c$` 时的行为完全对应。具体来说，对于一个高程网格 `$Z$`，`g_x, g_y = np.gradient(Z, c)`，其中 `g_x` 是沿第一轴（行，索引 `$i$`）的梯度，`g_y` 是沿第二轴（列，索引 `$j$`）的梯度。这种向量化方法效率很高。\n\n根据梯度，为每个单元格计算坡度大小 `$m(i,j) = \\sqrt{g_x(i,j)^2 + g_y(i,j)^2}$`。然后使用 `$\\theta(i,j) = \\arctan(m(i,j))$` 计算以弧度为单位的坡度角。\n\n有了坡度角网格 `$\\theta$` 和保护区掩码 `$P$`，使用给定的线性模型计算单位长度成本网格 `$C$`：`$C(i,j) = \\gamma + \\alpha \\cdot \\theta(i,j) + \\beta \\cdot P(i,j)$`。这将创建一个完整的“成本表面”，其中每个单元格都关联了每米行程的成本。\n\n**2. 图遍历和边权重**\n网格隐式地定义了一个图。从单元格 `$(i,j)$` 移动到相邻单元格 `$(k,l)$` 对应于遍历一条边。该边的权重 `$w$` 表示该移动段的总成本。它按照指定的梯形法则计算：`$w = d \\cdot \\frac{C(i,j) + C(k,l)}{2}$`。距离 `$d$` 对于基本方向移动（水平或垂直）是 `$c$`，对于对角线移动是 `$c\\sqrt{2}$`。\n\n**3. Dijkstra 最短路径算法**\n由于所有边权重都是非负的，Dijkstra 算法是找到从起始单元格 `$(s_x, s_y)$` 到目标单元格 `$(t_x, t_y)$` 的最低成本路径的合适方法。该算法使用优先队列（最小堆）来实现，以有效地选择下一个要访问的单元格。\n\n我们维护两个与输入维度相同的网格：\n-   `dist(i,j)`：存储从起始单元格到单元格 `$(i,j)$` 所找到的最小累积成本。除起始单元格 `dist(s_x, s_y) = 0` 外，所有单元格都初始化为无穷大。\n-   `length(i,j)`：存储与到 `$(i,j)$` 的最低成本路径相对应的物理路径长度。它以类似 `dist` 的方式初始化，`length(s_x, s_y) = 0`。\n\n优先队列存储 `(cost, (row, col))` 的元组。它用 `(0.0, (s_x, s_y))` 初始化。\n\n算法流程如下：\n1.  从优先队列中弹出成本最小的单元格。设其为单元格 `$u$`。\n2.  如果 `$u$` 之前已被访问，则跳过。否则，将其标记为已访问。\n3.  如果 `$u$` 是目标单元格，则算法终止，因为到该单元格的最短路径已经找到。\n4.  对于 `$u$` 的 `$8$` 个邻居中的每一个 `$v$`：\n    a. 计算边长 `$d_{uv}$` 和边成本 `$w_{uv}$`。\n    b. 计算通过 `$u$` 到达 `$v$` 的新的潜在成本：`new_cost = dist(u) + w_{uv}`。\n    c. 如果 `new_cost  dist(v)`，则找到了到 `$v$` 的更短路径。更新 `dist(v) = new_cost`，更新 `length(v) = length(u) + d_{uv}`，并将 `(new_cost, v)` 推入优先队列。\n\n一旦算法终止，`dist(t_x, t_y)` 和 `length(t_x, t_y)` 分别保存最终的总成本和路径长度。然后将这些值四舍五入到三位小数，以满足要求。起点和终点单元格相同的平凡情况作为特殊情况处理，直接返回成本和长度都为 `$0.0$`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef _calculate_path(Z, P, c, gamma, alpha, beta, start, target):\n    \"\"\"\n    Calculates the least-cost path cost and length on a raster grid.\n    \"\"\"\n    start_node = tuple(start)\n    target_node = tuple(target)\n\n    if start_node == target_node:\n        return [0.0, 0.0]\n\n    Z = np.array(Z, dtype=float)\n    P = np.array(P, dtype=float)\n    n_rows, n_cols = Z.shape\n\n    # Step 1: Compute slope and cost grids\n    # The finite difference formulas match numpy's gradient function when\n    # a single spacing 'c' is provided.\n    # np.gradient returns [d/d_axis0, d/d_axis1], which corresponds to [g_y, g_x].\n    # But for a square grid, this is an implementation detail. Let's use it as [g_y, g_x].\n    g_y, g_x = np.gradient(Z, c)\n    m = np.sqrt(g_x**2 + g_y**2)\n    theta = np.arctan(m)\n    \n    C = gamma + alpha * theta + beta * P\n\n    # Step 2: Dijkstra's algorithm\n    dist = np.full((n_rows, n_cols), np.inf)\n    length = np.full((n_rows, n_cols), np.inf)\n    \n    dist[start_node] = 0.0\n    length[start_node] = 0.0\n    \n    # Priority queue stores (cost, (row, col))\n    pq = [(0.0, start_node)]\n    visited = set()\n    \n    sqrt2c = c * np.sqrt(2)\n\n    while pq:\n        cost, current_node = heapq.heappop(pq)\n        \n        if current_node in visited:\n            continue\n        \n        visited.add(current_node)\n        \n        if current_node == target_node:\n            break\n            \n        r, c_node = current_node\n        \n        # Explore 8-connected neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                \n                nr, nc = r + dr, c_node + dc\n                neighbor_node = (nr, nc)\n                \n                if not (0 = nr  n_rows and 0 = nc  n_cols):\n                    continue\n\n                # Calculate edge length and cost\n                is_cardinal = (dr == 0 or dc == 0)\n                d_ij = c if is_cardinal else sqrt2c\n                \n                # Trapezoidal rule for edge weight\n                avg_cost = (C[current_node] + C[neighbor_node]) / 2.0\n                w_ij = d_ij * avg_cost\n                \n                new_cost = dist[current_node] + w_ij\n                \n                if new_cost  dist[neighbor_node]:\n                    dist[neighbor_node] = new_cost\n                    length[neighbor_node] = length[current_node] + d_ij\n                    heapq.heappush(pq, (new_cost, neighbor_node))\n\n    final_cost = dist[target_node]\n    final_length = length[target_node]\n    \n    return [round(final_cost, 3), round(final_length, 3)]\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Z\": [[100, 120, 140, 160, 180],\n                  [100, 120, 140, 160, 200],\n                  [100, 120, 160, 200, 240],\n                  [100, 120, 160, 200, 240],\n                  [90, 110, 130, 150, 170]],\n            \"P\": [[0, 0, 0, 0, 0],\n                  [0, 0, 1, 1, 0],\n                  [0, 1, 1, 1, 0],\n                  [0, 0, 1, 0, 0],\n                  [0, 0, 0, 0, 0]],\n            \"c\": 100, \"gamma\": 500, \"alpha\": 1000, \"beta\": 4000,\n            \"start\": (0, 0), \"target\": (4, 4)\n        },\n        {\n            \"Z\": [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n            \"P\": [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n            \"c\": 50, \"gamma\": 400, \"alpha\": 800, \"beta\": 2000,\n            \"start\": (1, 1), \"target\": (1, 1)\n        },\n        {\n            \"Z\": [[0, 0, 0, 0],\n                  [0, 50, 200, 250],\n                  [0, 50, 200, 250],\n                  [0, 0, 0, 0]],\n            \"P\": [[0, 0, 0, 0],\n                  [0, 0, 1, 0],\n                  [0, 0, 0, 0],\n                  [0, 0, 0, 0]],\n            \"c\": 100, \"gamma\": 600, \"alpha\": 1200, \"beta\": 3000,\n            \"start\": (0, 3), \"target\": (3, 0)\n        },\n        {\n            \"Z\": [[0, 10, 20, 30, 40, 50],\n                  [10, 20, 30, 40, 50, 60],\n                  [20, 30, 40, 50, 60, 70],\n                  [30, 40, 50, 60, 70, 80],\n                  [40, 50, 60, 70, 80, 90],\n                  [50, 60, 70, 80, 90, 100]],\n            \"P\": [[0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 1, 1, 0],\n                  [0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0]],\n            \"c\": 200, \"gamma\": 700, \"alpha\": 900, \"beta\": 5000,\n            \"start\": (0, 0), \"target\": (5, 5)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_path(\n            case[\"Z\"], case[\"P\"], case[\"c\"],\n            case[\"gamma\"], case[\"alpha\"], case[\"beta\"],\n            case[\"start\"], case[\"target\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{cost},{length}]\" for cost, length in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}